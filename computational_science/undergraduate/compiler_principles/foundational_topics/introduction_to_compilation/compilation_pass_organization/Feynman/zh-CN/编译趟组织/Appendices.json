{
    "hands_on_practices": [
        {
            "introduction": "在编译器中，优化遍的执行顺序并非无关紧要，它能显著影响最终代码的质量。此练习通过一个量化模型，帮助你探索不同优化遍之间的相互依赖关系。通过为几种常见的优化——全局值编号 (GVN)、循环不变代码外提 (LICM) 和死代码消除 (DCE)——计算不同执行序列的结果，你将具体地理解它们之间存在的“启用”与“禁用”关系。",
            "id": "3629247",
            "problem": "一个编译器流水线包含三个优化遍，它们以某种顺序对单个过程的中间表示各执行一次：全局值编号（GVN）、循环不变代码外提（LICM）和死代码消除（DCE）。以下基本事实适用于这些遍：\n\n- 全局值编号（GVN）识别具有相同值语义的计算，并在较早计算的值支配较晚计算时，消除后者这一冗余计算。\n- 循环不变代码外提（LICM）将操作数在循环迭代中不发生变化的计算从循环体中提升到一个支配该循环的位置（例如循环前置头部）。\n- 死代码消除（DCE）根据先前转换后的数据流分析，移除结果未被使用且无副作用的指令。\n\n假设该过程包含被划分为不相交组的独立代码片段，每组都可能贡献可被消除的指令，但这取决于各优化遍之间的启用关系。设各组的数量为：\n- 类型 $1$：$t_{1} = 7$ 组。每组包含位于不同代码块中的重复的循环不变计算，这些代码块最初互不支配。只有在 $LICM$ 将这些计算提升到一个公共支配点之后，$GVN$ 才能在每组中消除一个冗余计算。因此，当且仅当流水线中 $LICM$ 在 $GVN$ 之前执行时，这些组中才会发生消除，此时 $GVN$ 会在每组中恰好消除 $1$ 条指令；否则消除 $0$ 条。\n- 类型 $2$：$t_{2} = 5$ 组。每组包含一个 $GVN$ 始终可以消除的冗余，这与 $LICM$ 无关。此外，$GVN$ 转换会在每组中恰好暴露一个额外的死临时变量，当且仅当 $DCE$ 在 $GVN$ 之后运行时，$DCE$ 才能消除该变量。因此，在所有顺序下，$GVN$ 都会在每个这样的组中恰好消除 $1$ 条指令，且仅当 $DCE$ 在 $GVN$ 之后执行时，$DCE$ 才会额外消除 $1$ 条指令。\n- 类型 $3$：$t_{3} = 4$ 组。每组包含一个循环内部的临时变量，其使用范围仅限于该循环。在 $LICM$ 将不变表达式的生产者移出循环并重写其使用后，该临时变量变得未使用。只有当 $DCE$ 在 $LICM$ 之后运行时，$DCE$ 才会消除这个临时变量。$GVN$ 对这些组不起作用。因此，当且仅当 $LICM$ 在 $DCE$ 之前执行时，才会发生消除，此时 $DCE$ 会在每组中恰好消除 $1$ 条指令；否则消除 $0$ 条。\n- 类型 $4$：$t_{4} = 6$ 组。每组都需要一个启用链：首先必须由 $LICM$ 进行提升，以在重复计算之间建立支配关系；然后 $GVN$ 消除一个冗余计算；这又会暴露一个死临时变量，只有当 $DCE$ 在 $GVN$ 之后运行时，$DCE$ 才能消除它。在这些组中，如果 $LICM$ 在 $GVN$ 之前执行，并且 $DCE$ 在 $GVN$ 之后运行，则每组恰好消除 $2$ 条指令（$GVN$ 消除一条，$DCE$ 消除一条）。如果 $LICM$ 在 $GVN$ 之前执行，但 $DCE$ 在 $GVN$ 之前运行，则每组仅消除 $1$ 条指令（由 $GVN$ 消除）。如果 $LICM$ 不在 $GVN$ 之前执行，则该组中消除 $0$ 条指令。\n\n假设所有组都是不相交且独立的（没有指令属于一个以上的组），没有副作用或未定义行为干扰消除过程，并且除了所述的启用关系外，没有优化遍会创造新的机会。考虑这三个遍的所有 $6$ 种排列：$GVN \\rightarrow LICM \\rightarrow DCE$、$GVN \\rightarrow DCE \\rightarrow LICM$、$LICM \\rightarrow GVN \\rightarrow DCE$、$LICM \\rightarrow DCE \\rightarrow GVN$、$DCE \\rightarrow GVN \\rightarrow LICM$ 和 $DCE \\rightarrow LICM \\rightarrow GVN$。\n\n计算在这 $6$ 种排列下，被消除指令总数的算术平均值。将最终答案表示为一个精确的数字，不带单位。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于编译器优化的原理，问题定义良好，具有明确的目标和充足的数据，并且没有矛盾或含糊之处。我们可以开始求解。\n\n目标是计算在三个优化遍——全局值编号（$GVN$）、循环不变代码外提（$LICM$）和死代码消除（$DCE$）——的所有可能排序下，被消除指令总数的算术平均值。我们分别用 $G$、$L$ 和 $D$ 来表示这些遍。这三个遍共有 $3! = 6$ 种唯一的排列。\n\n不相交指令组的数量如下：\n- 类型 $1$：$t_{1} = 7$\n- 类型 $2$：$t_{2} = 5$\n- 类型 $3$：$t_{3} = 4$\n- 类型 $4$：$t_{4} = 6$\n\n令 $pos(X)$ 表示优化遍 $X$ 在给定排列中的位置（$1$、$2$ 或 $3$）。每种类型组的指令消除条件可以形式化如下：\n\n- **类型 1（$t_1$ 组）：** 当且仅当 $pos(L)  pos(G)$ 时，每组消除 $1$ 条指令。这将产生 $t_{1} \\times 1 = 7$ 条指令。否则，消除 $0$ 条指令。\n- **类型 2（$t_2$ 组）：** $GVN$ 总是消除 $1$ 条指令。当且仅当 $pos(D) > pos(G)$ 时，$DCE$ 会额外消除 $1$ 条指令。如果 $pos(D)  pos(G)$，这将产生总共 $t_{2} \\times 1 = 5$ 条指令；如果 $pos(D) > pos(G)$，则产生 $t_{2} \\times (1+1) = 10$ 条指令。\n- **类型 3（$t_3$ 组）：** 当且仅当 $pos(D) > pos(L)$ 时，每组消除 $1$ 条指令。这将产生 $t_{3} \\times 1 = 4$ 条指令。否则，消除 $0$ 条指令。\n- **类型 4（$t_4$ 组）：**\n    - 如果 $pos(L)  pos(G)$ 且 $pos(D) > pos(G)$，每组总共消除 $2$ 条指令。这将产生 $t_{4} \\times 2 = 12$ 条指令。\n    - 如果 $pos(L)  pos(G)$ 且 $pos(D)  pos(G)$，每组总共消除 $1$ 条指令。这将产生 $t_{4} \\times 1 = 6$ 条指令。\n    - 如果 $pos(L) > pos(G)$，消除 $0$ 条指令。\n\n现在我们将系统地计算每种排列下被消除指令的总数 $E_i$。\n\n1.  **排列 $P_1: G \\rightarrow L \\rightarrow D$** ($pos(G)=1, pos(L)=2, pos(D)=3$)\n    - 类型 1：$pos(L) > pos(G)$。消除：$0$。\n    - 类型 2：$pos(D) > pos(G)$。消除：$t_2 \\times (1+1) = 5 \\times 2 = 10$。\n    - 类型 3：$pos(D) > pos(L)$。消除：$t_3 \\times 1 = 4$。\n    - 类型 4：$pos(L) > pos(G)$。消除：$0$。\n    - 总计 $E_1 = 0 + 10 + 4 + 0 = 14$。\n\n2.  **排列 $P_2: G \\rightarrow D \\rightarrow L$** ($pos(G)=1, pos(D)=2, pos(L)=3$)\n    - 类型 1：$pos(L) > pos(G)$。消除：$0$。\n    - 类型 2：$pos(D) > pos(G)$。消除：$t_2 \\times (1+1) = 10$。\n    - 类型 3：$pos(D)  pos(L)$。消除：$0$。\n    - 类型 4：$pos(L) > pos(G)$。消除：$0$。\n    - 总计 $E_2 = 0 + 10 + 0 + 0 = 10$。\n\n3.  **排列 $P_3: D \\rightarrow G \\rightarrow L$** ($pos(D)=1, pos(G)=2, pos(L)=3$)\n    - 类型 1：$pos(L) > pos(G)$。消除：$0$。\n    - 类型 2：$pos(D)  pos(G)$。消除：$t_2 \\times 1 = 5$。\n    - 类型 3：$pos(D)  pos(L)$。消除：$0$。\n    - 类型 4：$pos(L) > pos(G)$。消除：$0$。\n    - 总计 $E_3 = 0 + 5 + 0 + 0 = 5$。\n\n4.  **排列 $P_4: L \\rightarrow G \\rightarrow D$** ($pos(L)=1, pos(G)=2, pos(D)=3$)\n    - 类型 1：$pos(L)  pos(G)$。消除：$t_1 \\times 1 = 7$。\n    - 类型 2：$pos(D) > pos(G)$。消除：$t_2 \\times (1+1) = 10$。\n    - 类型 3：$pos(D) > pos(L)$。消除：$t_3 \\times 1 = 4$。\n    - 类型 4：$pos(L)  pos(G)$ 且 $pos(D) > pos(G)$。消除：$t_4 \\times 2 = 6 \\times 2 = 12$。\n    - 总计 $E_4 = 7 + 10 + 4 + 12 = 33$。\n\n5.  **排列 $P_5: L \\rightarrow D \\rightarrow G$** ($pos(L)=1, pos(D)=2, pos(G)=3$)\n    - 类型 1：$pos(L)  pos(G)$。消除：$t_1 \\times 1 = 7$。\n    - 类型 2：$pos(D)  pos(G)$。消除：$t_2 \\times 1 = 5$。\n    - 类型 3：$pos(D) > pos(L)$。消除：$t_3 \\times 1 = 4$。\n    - 类型 4：$pos(L)  pos(G)$ 且 $pos(D)  pos(G)$。消除：$t_4 \\times 1 = 6$。\n    - 总计 $E_5 = 7 + 5 + 4 + 6 = 22$。\n\n6.  **排列 $P_6: D \\rightarrow L \\rightarrow G$** ($pos(D)=1, pos(L)=2, pos(G)=3$)\n    - 类型 1：$pos(L)  pos(G)$。消除：$t_1 \\times 1 = 7$。\n    - 类型 2：$pos(D)  pos(G)$。消除：$t_2 \\times 1 = 5$。\n    - 类型 3：$pos(D)  pos(L)$。消除：$0$。\n    - 类型 4：$pos(L)  pos(G)$ 且 $pos(D)  pos(G)$。消除：$t_4 \\times 1 = 6$。\n    - 总计 $E_6 = 7 + 5 + 0 + 6 = 18$。\n\n所有 $6$ 种排列下被消除指令的总数是每种排列总数的和：\n$$ E_{\\text{total}} = E_1 + E_2 + E_3 + E_4 + E_5 + E_6 $$\n$$ E_{\\text{total}} = 14 + 10 + 5 + 33 + 22 + 18 = 102 $$\n算术平均值 $\\mu$ 是这个总和除以排列数 $6$：\n$$ \\mu = \\frac{E_{\\text{total}}}{6} = \\frac{102}{6} $$\n$$ \\mu = 17 $$\n被消除指令总数的算术平均值为 $17$。",
            "answer": "$$\\boxed{17}$$"
        },
        {
            "introduction": "为了构建更高效的编译器，我们不仅要考虑串行执行，还要探索更高级的调度策略。理解优化遍的交换性等形式化属性，是实现这一目标的关键。这项练习将挑战你识别哪些优化遍组合可以按任意顺序执行（甚至并行执行）而不会改变程序的语义。这是构建更快、更现代化编译器的核心概念之一。",
            "id": "3629191",
            "problem": "编译器将其流水线组织为一系列的遍（pass），每个遍都被建模为对程序中间表示（IR）的纯函数。考虑一个中间表示（IR），它是一个有向控制流图（CFG），其中每个节点是一个包含指令列表的基本块，并对虚拟寄存器使用静态单赋值（SSA）形式。控制流图（CFG）和静态单赋值（SSA）的定义如下：CFG 是由控制流边连接的基本块构成的图，而 SSA 形式中每个变量仅被精确赋值一次，并使用显式的 $\\phi$ 节点进行合并。一个遍是一个将 IR 图映射到 IR 图的全函数 $p$。如果对于所有 IR 输入 $I$，都有以下等式成立，则称两个遍 $p$ 和 $q$ 是可交换的（commute）：\n$$(p \\circ q)(I) \\equiv (q \\circ p)(I),$$\n其中 $\\equiv$ 表示语义等价，此等价是在 SSA 名称的 alpha 重命名和基本块的重标记（即，保持控制流和指令多重集的图同构）的意义下定义的。\n\n假设程序语义是确定性的、良定义的，并使用以下遍的规范作为基本依据：\n\n- 变量重命名 (VR)：通过名称上的双射对 SSA 虚拟寄存器进行无捕获的 alpha 重命名。VR 不会改变 CFG、指令操作码或定值-使用边，只重命名标识符。它在重命名的意义下保留所有数据流事实。\n- 基本块重标记与布局 (BRL)：基本块标识符和线性顺序的排列。BRL 不改变 CFG 边、块内的指令序列或任何指令内容；它只改变标签和布局元数据。\n- 局部常量折叠 (LCF)：对于任何操作数均为字面常量的指令，用计算出的字面值替换该指令。LCF 不会增加或删除基本块或控制流边；它用字面值替换某些指令节点，但不会在指令间传播常量。\n- 不可达代码消除 (UCE)：移除当前 CFG 中从入口块不可达的基本块。UCE 不会重写可达块中的指令；它会删除不可达块及其所有关联的边。\n- 常量传播 (CP)：利用支配关系沿定值-使用链传播编译期常量，当定义是字面值且中间没有发生重定义时，用字面常量替换使用点。CP 不会改变 CFG。\n\n一个调度器希望在不改变语义的情况下并行运行可交换的遍对。如果 $p$ 和 $q$ 可交换，任何等价于先提交 $p$ 再提交 $q$ 或先提交 $q$ 再提交 $p$ 的并行执行都被认为是语义保持的。根据上述遍的定义，哪个选项（些）只列出了可以在此意义下安全并行调度的可交换遍对？\n\n选择所有适用项。\n\n- A. 对 $\\{$(LCF, UCE), (BRL, VR)$\\}$\n\n- B. 对 $\\{$(CP, 无用分支消除)$\\}$，其中无用分支消除在条件为字面布尔值时，用直接跳转替换条件分支，并删除现已不可达的后继节点及其后代。\n\n- C. 对 $\\{$(LCF, CP), (UCE, 无用分支消除)$\\}$\n\n- D. 对 $\\{$(UCE, BRL), (LCF, BRL)$\\}$\n\n- E. 对 $\\{$(VR, LCF), (VR, UCE)$\\}$\n\n你的推理应从上述形式化定义出发，不应假设任何未文档化的行为。对于错误选项，只需给出一个反例 IR $I$，使得 $(p \\circ q)(I) \\not\\equiv (q \\circ p)(I)$，或者指明一个被违反的独立性原则。对于正确选项，需从第一性原理（读/写足迹、不变性和图同构）出发进行论证，说明对所有 $I$ 可交换性都成立，因此一个可串行化为任一顺序的并行调度都保持语义。",
            "solution": "### 第 1 步：提取已知条件\n\n问题陈述提供了以下定义和条件：\n- **中间表示 (IR)**：一个有向控制流图 (CFG)，其中节点是基本块，虚拟寄存器采用静态单赋值 (SSA) 形式。\n- **CFG**：由控制流边连接的基本块构成的图。\n- **SSA**：每个变量仅被精确赋值一次，并使用显式的 $\\phi$ 节点进行合并。\n- **遍 (Pass)**：一个将 IR 图映射到另一个 IR 图的全函数 $p$。\n- **可交换性**：如果对于所有 IR 输入 $I$，都有 $(p \\circ q)(I) \\equiv (q \\circ p)(I)$，则两个遍 $p$ 和 $q$ 是可交换的。\n- **等价性 ($\\equiv$)**：语义等价，定义为在 SSA 名称的 alpha 重命名和基本块重标记的意义下，保持控制流和每个块中指令多重集的 CFG 图同构。\n- **遍的规范**：\n    - **变量重命名 (VR)**：对 SSA 虚拟寄存器进行 Alpha 重命名。不改变 CFG、操作码或定值-使用边（重命名除外）。\n    - **基本块重标记与布局 (BRL)**：排列基本块标识符及其线性顺序。不改变 CFG 边或指令。\n    - **局部常量折叠 (LCF)**：对于操作数均为字面常量的指令，将其替换为计算出的字面值结果。不改变 CFG。不传播常量。\n    - **不可达代码消除 (UCE)**：移除从入口块不可达的基本块及其关联的边。不重写可达块中的指令。\n    - **常量传播 (CP)**：如果一个变量的定义是字面常量，并且路径上没有发生重定义，则用该字面常量替换其使用点。不改变 CFG。\n- **调度目标**：并行运行可交换的遍对。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n- **科学依据**：该问题在编译器构造原理方面有充分的依据。IR、CFG、SSA 以及像常量折叠和死代码消除这样的编译器遍的概念，都是该领域的标准内容。\n- **良构性**：该问题是良构的。它为遍提供了形式化定义，并为等价性（$\\equiv$）提供了一个精确但严格的定义。问题要求根据这个形式化的可交换性定义来评估特定的遍对。可以确定一组唯一的正确选项。\n- **客观性**：问题使用形式化、客观的语言陈述，没有歧义或主观断言。\n\n问题陈述是自洽且内部一致的。这些定义虽然经过简化，但足以进行严格的分析。选项中引入了一个新的遍，即无用分支消除，但其定义已提供，因此可以在该上下文中进行分析。验证适用于核心设定，该设定是合理的。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。我将继续推导解决方案。\n\n### 解决方案推导\n\n要确定两个遍 $p$ 和 $q$ 是否可交换，我们必须检查对于任何 IR $I$，$(p \\circ q)(I)$ 的应用结果是否与 $(q \\circ p)(I)$ 的应用结果在给定的 $\\equiv$ 定义下等价。这种等价性要求最终的 CFG 是同构的，并且相应基本块中的指令多重集是相同的，允许不同的 SSA 变量名（alpha 重命名）和基本块标签。\n\n让我们分析每个选项中的遍对。\n\n**A. 对 $\\{$(LCF, UCE), (BRL, VR)$\\}$**\n\n- **对 ($LCF$, $UCE$)**:\n    - $LCF$ 修改基本块内的指令，但不改变 CFG 结构（边或块）。\n    - $UCE$ 从 CFG 中移除块和边，但不改变可达块内的指令。\n    - 我们来分析其组合。设 $I_r$ 为 $I$ 中可达块和指令的集合，而 $I_u$ 为不可达部分。\n    - $(UCE \\circ LCF)(I)$：$LCF$ 作用于 $I$，生成 $LCF(I)$。由于 $LCF$ 不改变 CFG，因此 $LCF(I)$ 中的可达块集合与 $I$ 中的相同。然后 $UCE$ 移除不可达部分，得到一个只包含可达块的 IR，其中的指令已被 $LCF$ 修改。结果实际上是 $LCF(I_r)$。\n    - $(LCF \\circ UCE)(I)$：$UCE$ 作用于 $I$，移除 $I_u$ 以生成 $I_r$。然后 $LCF$ 作用于 $I_r$，生成 $LCF(I_r)$。\n    - 由于 $(UCE \\circ LCF)(I)$ 和 $(LCF \\circ UCE)(I)$ 都生成 $LCF(I_r)$，因此得到的 IR 不仅仅是等价的，而且是相同的。因此，$LCF$ 和 $UCE$ 是可交换的。\n\n- **对 ($BRL$, $VR$)**:\n    - $BRL$ 修改基本块标识符和布局。\n    - $VR$ 修改 SSA 虚拟寄存器名称。\n    - 这两个遍作用于 IR 完全不相交的方面。$BRL$ 影响 CFG 节点元数据，而 $VR$ 影响指令级的操作数/定义名称。一个遍的操作不会改变另一个遍作用的对象集合。\n    - $(VR \\circ BRL)(I)$：首先，重标记基本块。其次，重命名寄存器。\n    - $(BRL \\circ VR)(I)$：首先，重命名寄存器。其次，重标记基本块。\n    - 两种情况下，最终的 IR 具有相同的 CFG 结构、相同的指令，但是块被重标记，寄存器被重命名。无论顺序如何，最终结果都相同。因此，$BRL$ 和 $VR$ 是可交换的。\n\n- **对 A 的结论**：两对遍均可交换。**正确**。\n\n\n**B. 对 $\\{$(CP, 无用分支消除)$\\}$**\n\n- **对 ($CP$, $DBE$)**:\n    - $CP$ 传播常量，这可以将条件分支中的变量条件变为字面常量。\n    - $DBE$ 的定义是简化条件为字面值的条件分支，然后移除新产生的不可达代码。这意味着 $CP$ 可以为 $DBE$ 创造机会。\n    - 我们来构造一个反例。考虑 IR $I$：\n    $$\n    B_1: x = \\text{true} \\\\\n    \\quad \\text{goto } B_2 \\\\\n    B_2: \\text{if } (x)\\text{ goto } B_3 \\text{ else goto } B_4\n    $$\n    - $(DBE \\circ CP)(I)$:\n        1. $CP(I)$：传播 $x = \\text{true}$。$B_2$ 中的分支变为 `if (true) goto $B_3$ else goto $B_4$`。\n        2. $DBE$ 作用于这个修改后的 IR。它将分支简化为无条件跳转 `goto $B_3$`，并删除现已不可达的块 $B_4$ 及其关联的边。最终的 CFG 不包含 $B_4$。\n    - $(CP \\circ DBE)(I)$:\n        1. $DBE(I)$：分支 `if (x)` 中的条件 $x$ 不是字面常量。$DBE$ 不做任何操作。IR 保持不变。\n        2. $CP$ 作用于原始 IR。它传播 $x = \\text{true}$，所以分支变为 `if (true) goto $B_3$ else goto $B_4$`。块 $B_4$ 及其入口边仍保留在 CFG 中。\n    - 最终的 CFG 不是同构的，因为一个包含块 $B_4$ 而另一个不包含。因此，$(DBE \\circ CP)(I) \\not\\equiv (CP \\circ DBE)(I)$。它们不可交换。\n\n- **对 B 的结论**：该对遍不可交换。**不正确**。\n\n\n**C. 对 $\\{$(LCF, CP), (UCE, 无用分支消除)$\\}$**\n\n- **对 ($LCF$, $CP$)**:\n    - $LCF$ 可以创建新的常量定义，而 $CP$ 随后可以传播这些常量。这表明存在依赖关系。\n    - 考虑一个单一基本块中的 IR $I$：\n    $$\n    x = 2 + 3 \\\\\n    y = x\n    $$\n    - $(CP \\circ LCF)(I)$:\n        1. $LCF(I)$：指令 `x = 2 + 3` 被折叠为 `x = 5`。IR 变为 `x = 5; y = x`。\n        2. $CP$ 作用于此。$x$ 的定义是字面值 $5$，所以它将此值传播到 `y = x` 的使用点。该指令变为 `y = 5`。最终的指令多重集是 $\\{ `x = 5`, `y = 5` \\}$。\n    - $(LCF \\circ CP)(I)$:\n        1. $CP(I)$：$x$ 的定义是一个表达式，而不是一个字面值。$CP$ 不做任何操作。IR 保持不变。\n        2. $LCF$ 作用于此。它将 `x = 2 + 3` 折叠为 `x = 5`。指令 `y = x` 不受影响。最终的指令多重集是 $\\{ `x = 5`, `y = x` \\}$。\n    - 指令多重集不同：$\\{ `x=5`, `y=5` \\}$ 与 $\\{ `x=5`, `y=x` \\}$。根据等价性 $\\equiv$ 的严格定义（要求保留指令多重集），结果是不等价的。因此，$LCF$ 和 $CP$ 不可交换。\n\n- **对 C 的结论**：由于第一对遍不可交换，该选项不正确。我们无需分析第二对。**不正确**。\n\n\n**D. 对 $\\{$(UCE, BRL), (LCF, BRL)$\\}$**\n\n- **对 ($UCE$, $BRL$)**:\n    - $UCE$ 依赖于 CFG 的连通性。$BRL$ 改变块标签，但明确“不改变 CFG 边”。\n    - $(BRL \\circ UCE)(I)$：$UCE$ 移除不可达块，得到一个子图 $I_r$。然后 $BRL$ 对 $I_r$ 中的块进行重标记。\n    - $(UCE \\circ BRL)(I)$：$BRL$ 首先对 $I$ 中的所有块进行重标记，创建一个同构图 $I'$。然后 $UCE$ 作用于 $I'$。由于可达性是一个图结构属性，$UCE$ 将移除 $I'$ 中对应于 $I$ 中不可达块的那些块。最终的图与 $I_r$ 同构，只是标签不同。\n    - 由于等价性 $\\equiv$ 是在基本块重标记的意义下定义的，这两个结果是等价的。因此，$UCE$ 和 $BRL$ 是可交换的。\n\n- **对 ($LCF$, $BRL$)**:\n    - $LCF$ 修改块内部的指令。$BRL$ 修改块的标签。这些是正交的操作。$LCF$ 的操作不依赖于块标签，而 $BRL$ 的操作不依赖于指令内容。\n    - $(BRL \\circ LCF)(I)$：先折叠常量，再重标记块。\n    - $(LCF \\circ BRL)(I)$：先重标记块，再折叠常量。\n    - 相应块内的最终指令多重集将是相同的。最终的 CFG 结构将是相同的。唯一的区别可能是块标签，而这是等价关系 $\\equiv$ 所允许的。因此，$LCF$ 和 $BRL$ 是可交换的。\n\n- **对 D 的结论**：两对遍均可交换。**正确**。\n\n\n**E. 对 $\\{$(VR, LCF), (VR, UCE)$\\}$**\n\n- **对 ($VR$, $LCF$)**:\n    - $VR$ 重命名 SSA 寄存器。\n    - $LCF$ 作用于操作数“全部为字面常量”的指令。SSA 寄存器不是字面常量，即使它们持有一个常量值。因此，$VR$ 和 $LCF$ 的操作是不相交的。$VR$ 读/写寄存器名称，而 $LCF$ 读/写定义在字面值上的指令。\n    - $(LCF \\circ VR)(I)$：先重命名寄存器。然后运行 $LCF$，它不受重命名的影响。\n    - $(VR \\circ LCF)(I)$：先运行 $LCF$。然后 $VR$ 重命名寄存器，这不受 $LCF$ 可能执行的折叠操作的影响。\n    - 最终的 IR 在 alpha 重命名的意义下是等价的。它们是可交换的。\n\n- **对 ($VR$, $UCE$)**:\n    - $VR$ 重命名寄存器。它不改变 CFG。\n    - $UCE$ 移除不可达块。\n    - $(UCE \\circ VR)(I)$：$VR$ 对整个程序 $I$ 中的寄存器进行重命名，生成 $I_v$。然后 $UCE$ 在 $I_v$ 上运行。由于 $VR$ 没有改变 CFG，$UCE$ 移除的块集合与它从 $I$ 中移除的相同。\n    - $(VR \\circ UCE)(I)$：$UCE$ 首先从 $I$ 中移除不可达块，生成 $I_r$。然后 $VR$ 对剩余的可达代码 $I_r$ 中的寄存器进行重命名。\n    - 两个最终的 IR 在 alpha 重命名下是等价的。因此，$VR$ 和 $UCE$ 是可交换的。\n\n- **对 E 的结论**：两对遍均可交换。**正确**。",
            "answer": "$$\\boxed{ADE}$$"
        }
    ]
}