{
    "hands_on_practices": [
        {
            "introduction": "翻译系统分类中最根本的区别之一，在于系统是仅仅操作程序的表面形式（纯句法替换），还是会深入理解其内在含义（语义分析）。这个练习  将我们带入熟悉的前端开发领域，通过分析几种常见的模板引擎和代码转换器，来具体辨析这两种方法的差异。掌握这种区分能力，是构建翻译系统分类心智模型的第一步。",
            "id": "3678697",
            "problem": "在编译原理中，一个翻译系统将源语言 $L_s$ 中的字符串映射到目标域中的输出。经典的编译器流水线包含词法分析、语法分析、语义分析和代码生成等阶段。语义分析是这样一个阶段，它根据语言定义检查程序的与意义相关的属性，通常需要一个抽象语法树（AST）以及诸如符号表、作用域解析和类型检查等结构；其形式化通常使用属性文法，其中属性在 AST 上进行计算以强制执行约束。相比之下，纯粹的句法替换在表层形式上操作，而不为源语言构建 AST 或强制执行作用域和类型规则；例子包括由文本标记的模式匹配驱动的宏展开和模板替换。\n\n考虑以下四个 Web 开发翻译系统，每个系统都将一些输入文本映射到浏览器或运行时所消费的输出。你的任务是分类哪些系统必然执行语义分析（如上定义），而不是纯粹的句法替换。\n\n- 系统 $T_1$：一个 Mustache 风格的模板引擎，它将像 $\\{\\{name\\}\\}$ 这样的定界符替换为来自上下文对象的值，支持通过遍历上下文中的数组来重复片段的迭代部分，并将结果字符串插入到超文本标记语言（HTML）页面中。它不解析层叠样式表（CSS）或 JavaScript（JS），不为模板语言构建抽象语法树（AST），也不执行类型检查或符号表构建；未定义的变量仅渲染为空字符串。\n\n- 系统 $T_2$：一个使用正则表达式实现的 JavaScript XML (JSX) 转换器，它扫描 JavaScript 源代码文本以查找尖括号标签，然后将对库函数的调用注入到文本中。它不调用 JavaScript 解析器，不跟踪标识符绑定，并且不知道诸如字符串或模板字面量之类的嵌套语法上下文；它在标签出现在字符串或模板字面量内部的输入上会失败。\n\n- 系统 $T_3$：一个 Babel 转译器插件，它接收现代 JavaScript（ECMAScript (ES) 版本 $6$）并输出 ES 版本 $5$。它首先将输入解析成一个抽象语法树（AST），然后将箭头函数转换为函数表达式，并将块级作用域声明转换为函数作用域声明。在转换期间，它执行作用域分析以避免变量捕获，并维护一个符号表以便在必要时重命名标识符。\n\n- 系统 $T_4$：一个 TypeScript 到 JavaScript 的转译器，它在通过擦除类型来生成 JavaScript 之前，根据 TypeScript 规范对程序进行完全的类型检查。该转译器构建一个符号表，解析导入和命名空间，并拒绝有类型不匹配的程序。生成的 JavaScript 对应于除去类型注解后的原始程序。\n\n哪些选项正确列出了属于语义分析类别而非纯粹句法替换的系统？\n\nA. $T_3$ 和 $T_4$\n\nB. $T_2$、$T_3$ 和 $T_4$\n\nC. $T_1$ 和 $T_3$\n\nD. $T_1$、$T_2$ 和 $T_4$",
            "solution": "首先将验证问题陈述，以确保其科学上可靠、内容自洽且客观。\n\n**问题验证**\n\n**第1步：提取已知信息**\n\n问题提供了以下定义和描述：\n-   **翻译系统：** 一个将源语言 $L_s$ 中的字符串映射到目标域中的输出的系统。\n-   **经典的编译器流水线：** 包含词法分析、语法分析、语义分析和代码生成等阶段。\n-   **语义分析：** 定义为这样一个阶段：\n    1.  检查程序的与意义相关的属性。\n    2.  通常需要一个抽象语法树（AST）。\n    3.  使用诸如符号表、作用域解析和类型检查等结构。\n    4.  可以使用属性文法进行形式化。\n-   **纯粹的句法替换：** 定义为这样一个过程：\n    1.  在表层形式（例如，文本标记）上操作。\n    2.  不为源语言构建 AST。\n    3.  不强制执行作用域和类型规则。\n    4.  例子包括宏展开和模板替换。\n\n问题接着描述了四个翻译系统：\n-   **系统 $T_1$（Mustache 风格的模板引擎）：** 将像 `\\{\\{name\\}\\}` 这样的定界符替换为上下文值。它明确“不为模板语言构建抽象语法树（AST），也不执行类型检查或符号表构建”。未定义的变量被渲染为空字符串。\n-   **系统 $T_2$（使用正则表达式的 JSX 转换器）：** 使用正则表达式扫描 JavaScript 文本以查找标签，并注入函数调用。它明确“不调用 JavaScript 解析器，不跟踪标识符绑定，并且不知道嵌套的语法上下文”。\n-   **系统 $T_3$（Babel 转译器插件）：** 将 ECMAScript (ES) 版本 $6$ 转换为 ES 版本 $5$。它“将输入解析成一个抽象语法树（AST）”， “执行作用域分析以避免变量捕获”，并“维护一个符号表以便在必要时重命名标识符”。\n-   **系统 $T_4$（TypeScript 到 JavaScript 的转译器）：** 它在生成 JavaScript 之前，“完全地对程序进行类型检查”，“构建一个符号表”，“解析导入和命名空间”，并“拒绝有类型不匹配的程序”。\n\n任务是识别这些系统（$T_1$、$T_2$、$T_3$、$T_4$）中哪些执行了所定义的语义分析。\n\n**第2步：使用提取的已知信息进行验证**\n\n根据验证标准评估问题陈述。\n-   **科学上可靠：** 该问题牢固地植根于编译器设计这一计算机科学核心领域的既定原则。语义分析、AST、符号表、作用域和类型检查的定义都是标准且准确的。所举的技术例子（Mustache、JSX、Babel、TypeScript）都是真实世界的，其描述的行为与它们（或类似系统）的运作方式一致。\n-   **定义明确：** 问题定义明确。它为感兴趣的两个类别（“语义分析”和“纯粹的句法替换”）提供了清晰、明确的定义。然后，它对四个系统进行了足够详细的描述，以便根据这些定义对其进行分类。问题毫不含糊，并指导解题者执行此分类。存在唯一解。\n-   **客观：** 语言是技术性的、精确的，并且没有主观或模糊的术语。对系统的描述是基于事实的，并依据其操作机制。\n\n问题陈述没有可辨别的缺陷。它不是科学上不可靠、不完整、矛盾、不现实或模棱两可的。这是编译器原理领域一个有效的、结构良好的问题。\n\n**第3步：结论与行动**\n\n问题是**有效的**。现在将进行求解过程。\n\n**解题推导**\n\n任务是根据所提供的定义，将每个系统（$T_1$、$T_2$、$T_3$、$T_4$）分类为执行“语义分析”或“纯粹的句法替换”。\n\n如果一个系统检查与意义相关的属性，需要构建 AST 并使用像符号表这样的结构进行作用域解析或类型检查，那么它就执行**语义分析**。\n如果一个系统在表层文本上操作，而不构建 AST 且不强制执行作用域或类型规则，那么它就执行**纯粹的句法替换**。\n\n**系统 $T_1$ 的分析：**\n$T_1$ 的描述明确指出它“不为模板语言构建抽象语法树（AST）”并且“不执行类型检查或符号表构建”。相反，它基于定界符执行文本替换。这种行为完全符合“纯粹的句法替换”的定义。因此，$T_1$ 不执行语义分析。\n\n**系统 $T_2$ 的分析：**\n$T_2$ 的描述指出它使用“正则表达式”来“扫描……源代码文本”。它“不调用 JavaScript 解析器”并且“不跟踪标识符绑定”。在不进行解析的情况下使用正则表达式对原始文本进行操作是表层替换的标志，而不是深层的结构或语义理解。无法处理像字符串这样的嵌套上下文进一步证实了它缺乏句法意识，更不用说语义意识了。这符合“纯粹的句法替换”的定义。因此，$T_2$ 不执行语义分析。\n\n**系统 $T_3$ 的分析：**\n$T_3$ 的描述指出它“将输入解析成一个抽象语法树（AST）”。此外，它“执行作用域分析”并“维护一个符号表”。这些活动——构建 AST、管理符号表和分析作用域——是问题陈述中定义的语义分析的核心活动。重命名标识符的目的是在转换过程中保留程序的意义（语义）。因此，$T_3$ 执行语义分析。\n\n**系统 $T_4$ 的分析：**\n$T_4$ 的描述指出它“完全地对程序进行类型检查”、“构建一个符号表”并“解析导入和命名空间”。类型检查是语义分析的一种主要且关键的形式。构建符号表和解析命名空间也是此阶段的基本组成部分，因为它们决定了标识符的意义和关系。如果不先将代码解析成 AST 以便有一个可操作的结构，这些活动是不可能完成的。因此，$T_4$ 执行语义分析。\n\n**结论：**\n根据分析，系统 $T_3$ 和 $T_4$ 是执行语义分析的系统。系统 $T_1$ 和 $T_2$ 是纯粹句法替换的例子。问题要求找出属于语义分析类别的系统。它们是 $T_3$ 和 $T_4$。\n\n**逐项分析选项**\n\n-   **A. $T_3$ 和 $T_4$**：此选项列出了被识别为执行语义分析的两个系统，$T_3$ 和 $T_4$。\n    **结论：正确。**\n\n-   **B. $T_2$、$T_3$ 和 $T_4$**：此选项错误地包含了 $T_2$，它被识别为纯粹的句法替换系统。\n    **结论：不正确。**\n\n-   **C. $T_1$ 和 $T_3$**：此选项错误地包含了 $T_1$，它被识别为纯粹的句法替换系统。\n    **结论：不正确。**\n\n-   **D. $T_1$、$T_2$ 和 $T_4$**：此选项错误地包含了 $T_1$ 和 $T_2$，它们被识别为纯粹的句法替换系统。\n    **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了语义分析的重要性之后，我们进一步会发现，一个复杂的翻译器并非一个整体。不同的转换任务必须在特定的阶段执行，这取决于它们所需信息的类型（例如词法单元、抽象语法树或类型信息）。本练习  使用宏作为范例，通过分析不同类型的宏（如卫生宏、条件包含和类型导向宏）所需的编译信息，来揭示如何在编译流程中为这些转换任务定位，从而深化对编译阶段化本质的理解。",
            "id": "3678689",
            "problem": "考虑一个源语言 $\\mathcal{L}$，其到目标语言 $\\mathcal{T}$ 的翻译系统按顺序组织为以下几个阶段：词法分析、解析为抽象语法树 (AST)、包括类型检查在内的语义分析、优化和代码生成。一个翻译系统，在编译原理的意义上，被定义为一组分阶段的转换，这些转换在生成 $\\mathcal{T}$ 的同时保留 $\\mathcal{L}$ 的预期语义。一个独立的预翻译工具是翻译器外部的，其操作无法访问编译器内部产物，如AST或符号表；它可以在翻译器开始之前修改源文本，但其本身不是语言的一个语义阶段。\n\n现为语言 $\\mathcal{L}$ 提出一个宏处理器 $\\mathcal{M}$，支持三种构造：\n\n- 构造 $1$：基于模式的卫生宏，它匹配已解析的AST形式并展开为新的AST，通过与编译器符号表绑定的生成的唯一标识符来引入新的词法绑定。卫生性保证新引入的绑定不会意外捕获现有标识符或被现有标识符捕获。\n\n- 构造 $2$：条件包含指令，如 $\\mathsf{ifdef}$ 和 $\\mathsf{endif}$，它们作用于词法单元流，并仅由外部配置标志控制。这些指令在解析之前操作，可以在不检查语言级语义的情况下排除或包含词法单元序列。\n\n- 构造 $3$：类型导向的宏，它根据宏参数的静态类型在多个专用函数调用之间进行选择。其展开需要类型推导后解析出的类型知识，并可能查询符号表和重载解析结果。\n\n你必须根据翻译系统分类法对 $\\mathcal{M}$ 进行分类，并将每个构造放置在编译流水线中，以保证保留 $\\mathcal{L}$ 的预期语义并且在科学上是合理的。选择最能反映所有三个构造的正确分类和放置策略的选项。\n\nA. 将 $\\mathcal{M}$ 的所有构造都视为一个独立的预翻译工具，在词法分析之前完全运行 $\\mathcal{M}$。理由是：宏展开纯粹是文本性的，独立于编译器；编译器只看到展开后的文本，并在此后执行其常规阶段。\n\nB. 仅将构造 $1$ 集成到翻译器内部，将卫生宏展开置于解析之后和语义分析之前，但将构造 $2$ 和 $3$ 视为外部预翻译，在词法分析之前完全运行。\n\nC. 将 $\\mathcal{M}$ 作为翻译器的一部分。将构造 $2$ 放置在解析之前，作用于词法单元流，作为集成在前端的一个早期文本门控；将构造 $1$ 放置在解析和语义分析之间，操作于AST并可访问符号表；将构造 $3$ 放置在类型解析之后的语义分析阶段内，允许基于已解析的静态类型做出展开决策。\n\nD. 在代码生成之后运行 $\\mathcal{M}$，通过宏展开来转换机器代码。理由是：通过延迟展开，可以利用目标表示来指导宏决策，同时避免干扰早期的分析。\n\nE. 将所有构造都集成在解析之后、但在类型解析严格之前，这样宏系统只能看到语法而看不到任何语义信息。理由是：统一的放置简化了流水线并避免了外部预处理，同时使宏远离词法分析。",
            "solution": "该问题要求对一个为语言 $\\mathcal{L}$ 提出的宏处理器 $\\mathcal{M}$ 进行分析，并将其正确定位在一个标准的编译流水线中。给定的流水线是：词法分析 $\\rightarrow$ 解析为抽象语法树 (AST) $\\rightarrow$ 语义分析 (包括类型检查) $\\rightarrow$ 优化 $\\rightarrow$ 代码生成。必须首先评估问题陈述的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **编译流水线**：词法分析 $\\rightarrow$ 解析 (生成 AST) $\\rightarrow$ 语义分析 (带类型检查) $\\rightarrow$ 优化 $\\rightarrow$ 代码生成。\n- **源语言**：$\\mathcal{L}$。\n- **目标语言**：$\\mathcal{T}$。\n- **预翻译工具定义**：在翻译器外部，操作时无法访问编译器内部产物（AST、符号表），在翻译前改变源文本，并且不是一个语义阶段。\n- **宏处理器 $\\mathcal{M}$ 的构造**：\n    1.  **构造 1 (卫生宏)**：匹配已解析的AST形式，展开为新的AST，使用与编译器符号表绑定的唯一标识符引入词法绑定。\n    2.  **构造 2 (条件包含)**：作用于词法单元流（$\\mathsf{ifdef}$），由外部标志控制，在解析前操作，不检查语言级语义。\n    3.  **构造 3 (类型导向的宏)**：根据参数的静态类型选择函数调用，需要类型推导后解析出的类型知识，可能查询符号表和重载解析结果。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述在科学上是可靠的、适定的和客观的。它使用了编译器设计领域的标准术语。\n- **科学合理性**：编译阶段（词法分析、语法分析、语义分析）、内部表示（AST、符号表）以及不同的宏展开策略（基于文本/词法单元、基于AST、类型导向）等概念在计算机科学中都是基础且公认的。对这三种构造的描述与现实世界中的语言特性是一致的（例如，构造2类似C风格的预处理器，构造1类似Lisp/Scheme宏，构造3类似Nim或D等语言中的元编程特性）。\n- **适定性**：每个构造的属性都为其在编译流水线中的位置提供了具体的约束。例如，一个操作AST的构造必须放在解析之后，而一个依赖于已解析类型的构造必须放在语义分析的相关阶段之后。这些约束是清晰且充分的，足以确定一个唯一的、合乎逻辑的安排。\n- **客观性**：问题以精确、技术性的术语陈述，没有歧义或主观看法。任务是找到一个科学上合理的放置方式，这在编译器工程领域是一个客观的标准。\n\n该问题没有表现出任何诸如事实不正确、不完整、矛盾或模糊等缺陷。其定义是自洽的，足以进行严谨的分析。\n\n**步骤 3：结论与行动**\n问题是有效的。解决方案将通过分析每个构造的放置要求来展开。\n\n### 解题推导\n\n每个宏构造的正确放置位置由其对编译过程中产生的数据结构的依赖性决定。\n\n1.  **构造 1 (卫生宏) 的分析**：\n    - 描述中称其“匹配已解析的AST形式并展开为新的AST”。这明确要求抽象语法树 (AST) 的存在。AST是语法分析阶段的输出。因此，此构造必须在语法分析*之后*运行。\n    - 它还需要“与编译器符号表绑定”以生成用于卫生性的唯一标识符。这证实了它不是一个外部工具，而必须与编译器的内部状态集成。\n    - 其输出是一个新的AST，这个新的AST必须随后进行语义正确性分析（例如，类型检查）。因此，展开应在语义分析*之前*发生。\n    - **构造 1 的结论**：放置位置在语法分析阶段和语义分析阶段之间。\n\n2.  **构造 2 (条件包含) 的分析**：\n    - 描述指明它“作用于词法单元流”并“在解析之前操作”。词法单元流是词法分析阶段的输出和语法分析阶段的输入。\n    - 它基于“外部配置标志”操作，并且不需要“语言级语义”。这使其成为一个简单的、非语义的过滤步骤。\n    - 这种行为是集成在编译器前端的预处理器的典型特征，它在词法单元被送入解析器之前对其进行操作。\n    - **构造 2 的结论**：放置位置在词法分析（生成词法单元流）之后和语法分析之前。\n\n3.  **构造 3 (类型导向的宏) 的分析**：\n    - 定义是它基于“宏参数的静态类型”进行展开，并“需要类型推导后解析出的类型知识”以及“重载解析结果”。\n    - 类型推导、类型检查和重载解析是语义分析阶段的主要职责。此构造的宏展开器直到这些信息可用后才能运行。\n    - 因此，此展开必须在语义分析阶段计算出必要的类型信息*期间*或*之后*发生。它作用于一个经过语义标注的AST。\n    - **构造 3 的结论**：放置位置在语义分析阶段内部，在类型解析发生之后。\n\n**综合分析**：\n这三个构造必须被放置在编译流水线的三个不同阶段：\n- 构造 2：在语法分析之前（作用于词法单元流）。\n- 构造 1：在语法分析之后，语义分析之前（作用于原始AST）。\n- 构造 3：在语义分析期间/之后（作用于类型标注的AST）。\n\n由于这些构造需要与编译器的内部数据结构（词法单元流、AST、符号表、类型信息）深度集成，宏处理器 $\\mathcal{M}$ 不可能是一个如问题所定义的单一的、整体的“预翻译工具”。它必须是翻译器本身的一个集成组件，其功能分布在整个流水线中。\n\n### 选项评估\n\n**A. 将 $\\mathcal{M}$ 的所有构造都视为一个独立的预翻译工具，在词法分析之前完全运行 $\\mathcal{M}$。理由是：宏展开纯粹是文本性的，独立于编译器；编译器只看到展开后的文本，并在此后执行其常规阶段。**\n这是不正确的。其理由被构造 $1$ 和 $3$ 的定义所证伪。构造 $1$ 需要AST，而AST在语法分析前是不可用的。构造 $3$ 需要已解析的类型，这在语义分析之前也是不可用的。将 $\\mathcal{M}$ 归类为外部预翻译工具与其对编译器内部产物的明确依赖相矛盾。\n**结论：不正确。**\n\n**B. 仅将构造 $1$ 集成到翻译器内部，将卫生宏展开置于解析之后和语义分析之前，但将构造 $2$ 和 $3$ 视为外部预翻译，在词法分析之前完全运行。**\n这是不正确的。虽然它正确地放置了构造 $1$，但它错误地分类和放置了构造 $3$。构造 $3$ 需要来自语义分析器的类型信息，绝不可能作为一个外部预翻译工具运行。\n**结论：不正确。**\n\n**C. 将 $\\mathcal{M}$ 作为翻译器的一部分。将构造 $2$ 放置在解析之前，作用于词法单元流，作为集成在前端的一个早期文本门控；将构造 $1$ 放置在解析和语义分析之间，操作于AST并可访问符号表；将构造 $3$ 放置在类型解析之后的语义分析阶段内，允许基于已解析的静态类型做出展开决策。**\n这个选项与为所有三个构造推导出的放置位置完美契合。它正确地指出 $\\mathcal{M}$ 必须是翻译器的一个集成部分。它将构造 $2$ 放在解析前的词法单元流上。它将构造 $1$ 放在解析和语义分析之间的AST上。它将构造 $3$ 放在语义分析阶段内，在类型解析之后。这代表了一种科学上合理且内部一致的编译器架构。\n**结论：正确。**\n\n**D. 在代码生成之后运行 $\\mathcal{M}$，通过宏展开来转换机器代码。理由是：通过延迟展开，可以利用目标表示来指导宏决策，同时避免干扰早期的分析。**\n这是不正确的。这些构造是根据高级语言概念定义的：词法单元（构造 $2$）、通过AST的句法结构（构造 $1$）和静态类型（构造 $3$）。这些概念在最终的机器代码输出中要么不存在结构化的形式，要么根本不存在。宏展开从根本上说是一种源到源或源到中间表示（IR）的转换，而不是一种编译后二进制修改。\n**结论：不正确。**\n\n**E. 将所有构造都集成在解析之后、但在类型解析严格之前，这样宏系统只能看到语法而看不到任何语义信息。理由是：统一的放置简化了流水线并避免了外部预处理，同时使宏远离词法分析。**\n这是不正确的。这个放置位置只对构造 $1$ 是正确的。对于在解析前操作于词法单元流的构造 $2$ 来说是错误的。对于构造 $3$ 来说是严重错误的，因为它明确需要语义信息（已解析的类型），因此*必须*被放置在类型解析开始之后，而不是“严格之前”。其理由中“宏系统只能看到语法而看不到任何语义信息”的说法与构造 $3$ 的定义直接矛盾。\n**结论：不正确。**",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "本章的最终实践将抽象的翻译系统架构与一个非常实际的结果联系起来：它究竟能支持哪些编程语言特性？这个练习  挑战我们去分析像闭包、异常和生成器这样的高级语言特性，是如何依赖于底层编译器和运行时的特定能力（例如堆内存分配或专门的控制流原语）。通过这个思想实验，我们可以清晰地看到，翻译系统类型的选择，对源语言的表达能力有着深远的影响。",
            "id": "3678705",
            "problem": "考虑编译器原理中翻译系统的分类。假设在以下明确约束条件下存在三种翻译系统类别，以及必须支持的三种小型语言特性：\n\n翻译系统类别：\n- $T_0$：一个语法指导的翻译器，它为一台传统的调用/返回栈式机生成目标三地址码，该栈式机支持基本算术、条件分支和函数调用/返回。它没有堆分配，没有除了普通返回之外的动态栈展开机制，也不支持协程或续延。运行时系统仅限于调用和返回所需的最小代码；它不提供专门的控制特性。\n- $T_{lib}$：一个将源码进行语法指导翻译成传统低级语言的编译器，并链接一个标准的运行时库，该库提供堆分配、带标签的记录、函数指针和普通的调用/返回。除了可以在用户代码中实现的功能外，它没有内置的非局部控制转移原语（没有异常，没有续延）。\n- $T_{\\text{VM}}$：一个字节码虚拟机（VM）解释器，内置了用于抛出异常（包括跨活动记录的动态栈展开）和用于让出/恢复协程（生成器帧）的操作。翻译器将源语言构造映射到虚拟机字节码；运行时系统实现栈展开和协程恢复。\n\n语言特性：\n- 闭包（Closures）：具有词法作用域的一等公民函数。闭包可能逃逸其定义作用域。闭包的行为由其代码指针和来自词法环境的自由变量绑定所定义。\n- 异常（Exceptions）：通过 raise/try/catch 实现的非局部控制转移。一个抛出的异常可以跨越任意 $k \\ge 1$ 个动态调用帧传播，直到找到匹配的处理程序。\n- 生成器（Generators）：可以通过 `yield` 挂起，并稍后从挂起点恢复的函数，可能多次恢复，并在多次 `yield` 之间保持局部状态。\n\n定义和基础：\n- 语法指导的翻译将规则与抽象语法树（AST）关联起来，确定性地将源构造映射到目标构造，而无需超出目标现有原语的新运行时机制。其正确性基于这样一个原则：翻译所保留的语义必须能够通过组合可用的目标操作来实现。\n- 当源语言的某个语义效果无法通过局部句法重写，在不进行全局植入或引入在执行时改变活动记录、控制流或内存生命周期的专门机制的情况下，归约为一个现有目标原语序列时，就需要运行时支持。\n\n任务：\n使用上述约束和定义，从第一性原理出发，围绕环境、活动记录的生命周期和控制转移语义进行推理，以预测哪种翻译系统类别能够主要通过语法指导的翻译来处理每种特性，以及哪种需要运行时支持。通过描述在规定约束下实现每个特性的最小原型来验证你的预测。\n\n在这些假设下，选择所有正确的陈述：\n\nA. 在 $T_{lib}$ 中，具有词法作用域的一等公民闭包可以通过语法指导的翻译来实现。该翻译将每个闭包转换为一个由代码指针和捕获其自由变量的堆分配环境记录组成的对，仅使用运行时库提供的堆分配和普通函数调用。\n\nB. 在 $T_0$ 中，跨越 $k$ 个帧（$k \\ge 1$）进行非局部传播的异常，可以仅通过语法指导的翻译来实现，而无需改变任何函数签名或调用约定。\n\nC. 在 $T_{lib}$ 中，生成器可以通过语法指导的翻译编译成显式状态机。其中，每个生成器被翻译成一个存储有限状态和局部变量的堆分配记录，以及一个在每次调用时推进状态的调度函数，而无需任何特殊的虚拟机恢复操作。\n\nD. 在 $T_{\\text{VM}}$ 中，异常可以通过语法指导的翻译来处理，该翻译插入虚拟机的 `raise` 和处理程序设置字节码，而动态展开和处理程序发现则由虚拟机运行时提供；因此，主要机制是对非局部控制转移的运行时支持。\n\nE. 在 $T_0$ 中，闭包可以完全在调用栈上实现而无需堆分配，并且仍然是一等公民（即可任意逃逸），仅使用语法指导的翻译和普通的调用/返回。",
            "solution": "该问题陈述是编译器设计原则中的一个有效练习。它为翻译系统（`$T_0$`、`$T_{lib}$`、`$T_{\\text{VM}}$`）建立了一个清晰的分类，具有明确定义的约束和能力。它还定义了三种标准的语言特性（闭包、异常、生成器），并为“语法指导的翻译”与“运行时支持”提供了正式定义。任务是推理哪个系统可以通过哪种机制支持哪个特性。该问题是自包含的，科学上基于已建立的计算机科学理论，并且是客观的。\n\n分析的核心在于活动记录的生命周期和控制转移的机制。\n- 在像 `$T_0$` 的目标机这样的简单基于栈的机器中，函数调用的活动记录（栈帧）仅在该调用的动态范围内存在。它在函数进入时创建，在退出（返回）时销毁。控制流仅限于函数内的直接跳转和调用/返回序列。\n- 在一个带有堆的系统中，如 `$T_{lib}$` 的目标系统，可以分配生命周期独立于调用栈的数据。这对于实现那些状态必须比创建它的函数调用存活更久的特性至关重要。\n- 像 `$T_{\\text{VM}}$` 这样的虚拟机提供了一个更高级别的抽象，其中运行时系统可以将复杂的控制和数据管理操作（如栈展开或协程状态管理）作为原子原语来实现，从而简化了编译器的任务。\n\n基于这些第一性原理，我们评估每个选项：\n\nA. 在 `$T_{lib}$` 中，具有词法作用域的一等公民闭包可以通过语法指导的翻译来实现。该翻译将每个闭包转换为一个由代码指针和捕获其自由变量的堆分配环境记录组成的对，仅使用运行时库提供的堆分配和普通函数调用。\n\n该陈述描述了在编译到带堆分配的目标（如C语言）的语言中，实现一等公民（可逃逸）闭包的标准且正确的方法。闭包的根本问题在于，如果它们能逃逸其定义的范围（例如，通过从函数返回），它们的词法环境（其自由变量的绑定）必须在定义函数的栈帧被释放后仍然存活。一个纯粹基于栈的环境会导致悬挂指针，这被称为“向上 funarg 问题”（upward funarg problem）。\n系统 `$T_{lib}` 提供了堆分配。一个语法指导的翻译方案可以如下解决这个问题：\n1. 当创建闭包时，编译器生成代码在堆上分配一个记录。\n2. 然后，它生成代码将所有自由变量的值或引用从当前词法环境复制到这个堆分配的记录中。\n3. 闭包值本身随后被表示为一对指针：一个指向函数机器码的指针，和一个指向这个堆分配环境记录的指针。\n当闭包被调用时，环境指针作为一个隐藏参数传递，使函数代码能够访问其捕获的变量。整个过程只使用堆分配、记录创建和普通函数调用，根据 `$T_{lib}` 的定义，这些都是其目标中可用的原语。这是一个通过局部句法重写将复杂的源级语义（词法闭包）实现为可用目标原语组合的完美示例。\n结论：**正确**。\n\nB. 在 `$T_0$` 中，跨越 `$k$` 个帧（`$k \\ge 1$`）进行非局部传播的异常，可以仅通过语法指导的翻译来实现，而无需改变任何函数签名或调用约定。\n\n该陈述是错误的。系统 `$T_0$` 受到严格限制：它“没有除了普通返回之外的动态栈展开机制”。跨 `$k$` 个帧传播异常需要非局部控制转移，即从 `raise` 点跳转到某个祖先活动记录中的处理程序，并展开（销毁）所有中间的 `$k-1$` 个活动记录。`$T_0$` 缺乏任何实现此功能的原语。要“仅通过语法指导的翻译”来实现这一点，编译器必须转换代码以显式管理控制流。一种常见（尽管低效）的方法是从每个函数返回一个错误状态。例如，调用 `y = f(x);` 将被转换为 `status = f(x, ); if (status != OK) return status;`。然而，这明确地改变了函数签名（增加了一个返回参数和一个状态返回值）和调用约定，直接违反了陈述的条件。如果不改变签名，可以使用一个全局标志，但每个函数仍然需要在每次调用后被植入代码以检查此标志并手动返回，这是一种全局植入，而非问题定义中语法指导翻译所暗示的局部重写。栈展开的基本机制在 `$T_0$` 中缺失，并且无法在没有专门的运行时机制或侵入性的全局代码转换的情况下合成出来。\n结论：**错误**。\n\nC. 在 `$T_{lib}$` 中，生成器可以通过语法指导的翻译编译成显式状态机。其中，每个生成器被翻译成一个存储有限状态和局部变量的堆分配记录，以及一个在每次调用时推进状态的调度函数，而无需任何特殊的虚拟机恢复操作。\n\n该陈述是正确的。生成器必须在多次 `yield` 调用之间保留其局部状态和执行点。普通函数调用不支持这一点，因为其活动记录在返回时被销毁。与闭包非常相似，解决方案是将必须持久化的状态从栈上移到堆上。`$T_{lib}` 提供了堆。\n一个语法指导的翻译可以将生成器函数转换为：\n1. 一个在堆上分配的状态记录，用于存储生成器的所有局部变量和一个表示当前执行点的附加状态变量（即，它位于哪个 `yield` 处）。\n2. 一个单一的调度函数。每次调用时，此函数使用状态变量（例如，在 `switch` 语句中）跳转到紧跟上一个 `yield` 之后的代码段。它执行直到遇到下一个 `yield`，此时它将新的执行点和任何更新的局部变量保存回堆分配的状态记录中，然后返回 `yield` 的值。\n这种技术，有时被称为“生成器转换”或与“续延传递风格转换”相关，仅依赖于堆分配、记录和普通函数调用。运行时系统不需要特殊的 `resume` 或 `yield` 原语。挂起和恢复的语义完全由转换后的代码结构模拟。\n结论：**正确**。\n\nD. 在 `$T_{\\text{VM}}$` 中，异常可以通过语法指导的翻译来处理，该翻译插入虚拟机的 `raise` 和处理程序设置字节码，而动态展开和处理程序发现则由虚拟机运行时提供；因此，主要机制是对非局部控制转移的运行时支持。\n\n该陈述是正确的。`$T_{\\text{VM}}$` 的定义指出它具有“用于抛出异常的内置操作（包括跨活动记录的动态栈展开）”。问题对“运行时支持”的定义包括“在执行时改变活动记录、控制流或内存生命周期的专门机制”。动态栈展开正是这样一种机制。因此，编译器的任务变成了一个直接的、语法指导的映射：一个 `try/catch` 块被翻译成注册处理程序的字节码，一个 `raise` 语句被翻译成一个 `RAISE` 字节码。虚拟机解释器在遇到 `RAISE` 字节码时，执行复杂的逻辑来搜索调用栈以寻找处理程序并展开栈帧。这与选项中的描述完全匹配。编译器使用简单的翻译，而运行时提供强大的语义实现。\n结论：**正确**。\n\nE. 在 `$T_0$` 中，闭包可以完全在调用栈上实现而无需堆分配，并且仍然是一等公民（即可任意逃逸），仅使用语法指导的翻译和普通的调用/返回。\n\n该陈述是根本错误的。“一等公民”一词意味着闭包可以像任何其他数据一样被对待：存储在变量中，传递给函数，以及至关重要的是，从函数返回。能够“任意逃逸”是关键。如果一个函数创建并返回一个闭包，该闭包的生命周期必须超过其创建函数的活动周期。创建函数的活动记录存在于调用栈上，并在函数返回时被销毁。如果闭包的词法环境（包含其自由变量）存储在此栈帧中，那么随后对返回的闭包的任何使用都将访问已释放的内存，导致悬挂指针和未定义行为。正确实现一等公民的、可逃逸的闭包要求其捕获的环境具有独立于栈的生命周期，这需要具有动态范围的存储，即堆分配。系统 `$T_0$` 明确规定“没有堆分配”。因此，它只能支持不可逃逸的闭包（向下 funarg），而不能支持完全一等公民的闭包。\n结论：**错误**。",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}