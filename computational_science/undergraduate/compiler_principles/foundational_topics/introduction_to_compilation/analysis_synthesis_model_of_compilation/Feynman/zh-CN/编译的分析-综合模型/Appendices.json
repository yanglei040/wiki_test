{
    "hands_on_practices": [
        {
            "introduction": "编译器为了提升性能，常常会对内存操作进行重排序，但如果处理不当，这会是一种有风险的优化。本实践演示了别名分析的精度如何直接影响编译器安全重排内存读写操作的能力。你将比较不同精度级别 ($\\alpha$) 的分析，从字段不敏感分析到分配点敏感分析，以理解更详细的分析信息为何能实现更强大的综合（优化）阶段 。",
            "id": "3621393",
            "problem": "在编译的分析-综合模型中，分析阶段计算保守的别名信息，综合（转换）阶段使用这些信息来证明内存重排的合理性。一个基本准则是，在一个顺序、单线程、非易失性程序中，对内存读和写的重排是语义保持的，当且仅当这两个内存操作不访问相同的抽象位置，并且其中至少一个是写操作。等价地，如果两个内存操作可能访问相同的抽象位置，且至少一个是写操作，则存在一个潜在的内存依赖，此时不允许重排。\n\n考虑精度参数为 $\\alpha \\in \\{0,1,2\\}$ 的别名分析，其解释如下：\n- $\\alpha=0$：流不敏感、字段不敏感、上下文不敏感、堆不敏感；所有兼容类型的指针都可能互为别名，一个结构体的所有字段被合并到一个抽象位置类中。\n- $\\alpha=1$：流不敏感、字段敏感（同一结构体的不同字段是独立的抽象位置）、上下文不敏感、堆不敏感（所有堆分配被合并到一个抽象位置类中）。\n- $\\alpha=2$：流不敏感、字段敏感、上下文不敏感、堆分配点敏感（语法上不同的分配点是不同的抽象位置）；此外，分配被建模为返回新的、不重叠的内存。\n\n假设一种具有严格顺序语义、无并发、无易失性访问、无未定义行为的语言。考虑以下两个线性代码片段和提议的优化序列，这些序列试图重排一个加载和一个存储操作。所有变量都表示指向整数的指针，$\\rightarrow$ 表示通过指向结构体实例的指针进行字段选择。\n\n片段 A（结构体字段）：\n- 程序：设 $p$ 是一个指向带有整数类型字段 $x$ 和 $y$ 的结构体的指针。按顺序执行：\n  $$\n  S_x:\\; p \\rightarrow x := 1;\\quad L_y:\\; t := p \\rightarrow y.\n  $$\n- 提议的序列 $\\Sigma_A$：将加载重排到存储之前，即转换为\n  $$\n  L_y:\\; t := p \\rightarrow y;\\quad S_x:\\; p \\rightarrow x := 1.\n  $$\n\n片段 B（不同的堆分配点）：\n- 程序：设 $a := \\mathrm{alloc}_1()$ 和 $b := \\mathrm{alloc}_2()$，其中 $\\mathrm{alloc}_1$ 和 $\\mathrm{alloc}_2$ 表示语法上不同的分配点，每个都返回一个新的、不重叠的堆对象。按顺序执行：\n  $$\n  S_a:\\; *a := 0;\\quad L_b:\\; u := *b.\n  $$\n- 提议的序列 $\\Sigma_B$：将加载重排到存储之前，即转换为\n  $$\n  L_b:\\; u := *b;\\quad S_a:\\; *a := 0.\n  $$\n\n问题：仅使用上述定义和开头陈述的合法性标准，哪个选项正确地描述了在每种 $\\alpha \\in \\{0,1,2\\}$ 的情况下，$\\Sigma_A$ 和 $\\Sigma_B$ 哪些是语义保持的？\n\nA. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_A$ 合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均合法。\n\nB. 在 $\\alpha=0$ 下：$\\Sigma_A$ 合法；在 $\\alpha=1$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法。\n\nC. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法；在 $\\alpha=1$ 下：两者均不合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。\n\nD. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_B$ 合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。",
            "solution": "问题陈述在编译器设计，特别是关于别名分析及其在代码优化中的应用的既定原则内，提出了一个定义明确的问题。关于不同分析精度级别（$\\alpha$）的定义以及内存操作重排的合法性标准是清晰、内部一致的，并且足以推导出唯一的解。该问题是有效的。\n\n问题的核心是确定一个提议的对存储和后续加载的重排是否合法。合法性标准指出，当且仅当别名分析能够证明两个内存操作访问不同的抽象位置时，这种重排才是允许的。如果分析结论是这些位置*可能互为别名*，则存在一个潜在的写后读（RAW）依赖，重排是不允许的。我们将对每个精度级别 $\\alpha \\in \\{0, 1, 2\\}$ 评估转换 $\\Sigma_A$ 和 $\\Sigma_B$ 的合法性。\n\n**对 $\\alpha=0$ 的分析**\n该级别的分析被定义为流不敏感、字段不敏感、上下文不敏感和堆不敏感。\n\n-   **片段 A ($\\Sigma_A$)**：操作是一个存储 $S_x: p \\rightarrow x := 1$ 和一个加载 $L_y: t := p \\rightarrow y$。因为分析是**字段不敏感**的，它将一个结构体的所有字段合并到单个抽象位置中。因此，从分析器的角度来看，$p \\rightarrow x$ 的抽象位置与 $p \\rightarrow y$ 的抽象位置是无法区分的。它们被认为是*可能互为别名*。因此，编译器必须假定 $S_x$ 和 $L_y$ 之间存在依赖，这使得 $\\Sigma_A$ 中的重排**不合法**。\n\n-   **片段 B ($\\Sigma_B$)**：操作是一个存储 $S_a: *a := 0$ 和一个加载 $L_b: u := *b$。指针 $a$ 和 $b$ 是兼容类型（指向整数的指针）。分析是**堆不敏感**的，意味着所有堆分配都被合并到单个抽象位置类中。分析器无法区分在 $\\mathrm{alloc}_1()$ 处分配的内存和在 $\\mathrm{alloc}_2()$ 处分配的内存。它必须保守地假定 $a$ 和 $b$ 可能指向这个单一抽象堆区域内的相同位置。因此， $*a$ 和 $*b$ *可能互为别名*。编译器必须假定存在依赖，$\\Sigma_B$ 中的重排是**不合法**的。\n\n-   **$\\alpha=0$ 的结论**：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法。\n\n**对 $\\alpha=1$ 的分析**\n该级别的分析是流不敏感、**字段敏感**、上下文不敏感和堆不敏感。\n\n-   **片段 A ($\\Sigma_A$)**：分析是**字段敏感**的。这是与 $\\alpha=0$ 的关键区别。它将同一结构体的不同字段（$x$ 和 $y$）视为独立的抽象位置。因此，分析器可以证明 $p \\rightarrow x$ 和 $p \\rightarrow y$ 访问不相交的内存区域。由于 $S_x$ 和 $L_y$ 之间没有内存依赖，$\\Sigma_A$ 中的重排是语义保持的，因此是**合法**的。\n\n-   **片段 B ($\\Sigma_B$)**：分析仍然是**堆不敏感**的。与 $\\alpha=0$ 一样，所有堆分配都被合并到单个抽象位置中。字段敏感性的改进在这里不适用。分析仍然无法区分由 $a$（来自 $\\mathrm{alloc}_1()$）和 $b$（来自 $\\mathrm{alloc}_2()$）指向的内存。它必须保守地假定 $*a$ 和 $*b$ *可能互为别名*。$\\Sigma_B$ 中的重排是**不合法**的。\n\n-   **$\\alpha=1$ 的结论**：只有 $\\Sigma_A$ 合法。\n\n**对 $\\alpha=2$ 的分析**\n该级别的分析是流不敏感、**字段敏感**、上下文不敏感和**堆分配点敏感**的。\n\n-   **片段 A ($\\Sigma_A$)**：分析是字段敏感的，就像 $\\alpha=1$ 一样。它可以证明 $p \\rightarrow x$ 和 $p \\rightarrow y$ 是不同的位置。因此，$\\Sigma_A$ 中的重排仍然是**合法**的。\n\n-   **片段 B ($\\Sigma_B$)**：分析是**堆分配点敏感**的。这意味着它可以区分在不同语法分配点创建的对象。由于 $a$ 被赋值为 $\\mathrm{alloc}_1()$ 的结果，而 $b$ 被赋值为 $\\mathrm{alloc}_2()$ 的结果，并且这些是语法上不同的位置，分析器将它们指向的内存位置建模为不同且不重叠的抽象位置。它可以证明 $*a$ 和 $*b$ 不会互为别名。由于没有内存依赖，$\\Sigma_B$ 中的重排是**合法**的。\n\n-   **$\\alpha=2$ 的结论**：$\\Sigma_A$ 和 $\\Sigma_B$ 均合法。\n\n**结论总结：**\n-   对于 $\\alpha=0$：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法。\n-   对于 $\\alpha=1$：只有 $\\Sigma_A$ 合法。\n-   对于 $\\alpha=2$：$\\Sigma_A$ 和 $\\Sigma_B$ 均合法。\n\n**选项评估：**\n\n-   **A. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_A$ 合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均合法。**\n    该陈述与我们为所有三个 $\\alpha$ 值推导出的结论完全匹配。\n    **结论：正确。**\n\n-   **B. 在 $\\alpha=0$ 下：$\\Sigma_A$ 合法；在 $\\alpha=1$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法。**\n    该陈述在所有三个方面都是错误的。对于 $\\alpha=0$，$\\Sigma_A$ 不合法。对于 $\\alpha=1$，$\\Sigma_B$ 不合法。对于 $\\alpha=2$，两者都合法。\n    **结论：不正确。**\n\n-   **C. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法；在 $\\alpha=1$ 下：两者均不合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。**\n    该陈述对于 $\\alpha=1$（其中 $\\Sigma_A$ 合法）和 $\\alpha=2$（其中 $\\Sigma_A$ 也合法）是错误的。\n    **结论：不正确。**\n\n-   **D. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 均不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_B$ 合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。**\n    该陈述对于 $\\alpha=1$（它颠倒了 $\\Sigma_A$ 和 $\\Sigma_B$ 的合法性）和 $\\alpha=2$（其中 $\\Sigma_A$ 也合法）是错误的。\n    **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "将代码移出循环或移入公共前驱基本块是一种强大的全局优化。这个问题挑战你在一个控制流图上应用分析-综合模型来进行全局代码移动。在指示代码移动安全性的分析标志的指导下，你的任务是综合出一个新的调度方案，将计算放置在它们最早的有效位置，同时遵守支配关系和数据依赖。这个练习将加深你对分析-综合原则如何应用于现代编译器中复杂的非局部转换的理解 。",
            "id": "3621417",
            "problem": "一个编译器应用分析-综合模型，对一个处于静态单赋值（SSA）形式、基于控制流图（CFG）的程序执行全局代码移动。分析阶段已经为每个指令节点 $n$ 计算了一个布尔标志 $MotionSafe(n)$，该标志指示将 $n$ 移动到更早的 CFG 块是否保持可观察的语义，包括内存效应和异常。综合阶段必须将每个可移动的计算放置到一个支配其所有使用的块中，同时受限于操作数的可用性以及以下约束：在 $MotionSafe(n)$ 不满足的情况下，具有副作用或可能引发异常的操作保持原地不动。为保证正确性，综合阶段必须将每个可移动节点放置到支配其所有使用的最小（在支配树中）块中，以免不必要地增加活跃范围。\n\n考虑以下包含块 $b_0$（入口）、$b_1$、$b_2$、$b_3$ 和 $b_4$ 的 CFG：\n- 控制流：$b_0 \\to b_1$，$b_1$ 分支到 $b_2$ 和 $b_3$，且 $b_2$ 和 $b_3$ 都进入 $b_4$。支配关系为：$b_0$ 支配 $b_1$，$b_1$ 支配 $b_2$、$b_3$ 和 $b_4$。直接支配者为 $idom(b_1)=b_0$, $idom(b_2)=b_1$, $idom(b_3)=b_1$, $idom(b_4)=b_1$。\n- 指令（SSA 名称在数学公式中）：\n  - 在 $b_1$ 中：$n_1$: $x := a + b$，其中 $MotionSafe(n_1) = \\mathrm{true}$。然后基于 $p$ 进行分支。\n  - 在 $b_2$ 中：$n_2$: $t_2 := x \\times 2$，其中 $MotionSafe(n_2) = \\mathrm{true}$。然后 $n_3$: $store(s, t_2)$，其中 $MotionSafe(n_3) = \\mathrm{false}$。然后跳转到 $b_4$。\n  - 在 $b_3$ 中：$n_4$: $t_4 := x \\times 3$，其中 $MotionSafe(n_4) = \\mathrm{true}$。然后 $n_5$: $t_5 := u / v$，其中 $MotionSafe(n_5) = \\mathrm{false}$，因为可能出现除零异常。然后跳转到 $b_4$。\n  - 在 $b_4$ 中：$\\phi$: $y := \\phi(t_2, t_4)$。然后 $n_6a$: $l := load(q)$，其中 $MotionSafe(n_6a) = \\mathrm{true}$，并且别名分析保证对 $s$ 的存储不会与 $q$ 发生别名。然后 $n_6b$: $z := y + l$，其中 $MotionSafe(n_6b) = \\mathrm{true}$。\n\n定义：\n- 支配：如果从 $b_0$到 $m$ 的每条路径都包含块 $d$，则块 $d$ 支配块 $m$。\n- 最小支配放置：对于一个在块 $\\{u_i\\}$ 中有使用的节点 $n$，一个合法的放置块 $d$ 必须支配每个 $u_i$，并且在支配树中是最小的，意味着 $d$ 的任何严格后代节点都不支配所有的 $\\{u_i\\}$。\n\n根据这些规则：\n- 只有 $MotionSafe(n) = \\mathrm{true}$ 的节点可以被提前移动。\n- $MotionSafe(n) = \\mathrm{false}$ 的节点保持原地不动，并且不得跨控制流重新排序，以致其执行频率或顺序发生变化。\n- 被移动的节点必须被放置在其所有操作数都可用的地方（即，放置块必须支配其操作数的定义点），并且该节点必须支配其所有的使用点。\n\n下列哪个调度选择既合法又符合最小支配放置策略？\n\nA. 将 $n_1$ 保持在 $b_1$ 中。将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。将 $n_3$ 保持在 $b_2$ 中，将 $n_5$ 保持在 $b_3$ 中。将 $n_6a$ 和 $n_6b$ 保持在 $b_4$ 中。\n\nB. 将 $n_1$ 从 $b_1$ 移动到 $b_0$。将 $n_2$ 从 $b_2$ 移动到 $b_0$。将 $n_4$ 从 $b_3$ 移动到 $b_0$。将 $n_6a$ 从 $b_4$ 移动到 $b_0$。将 $n_6b$ 从 $b_4$ 移动到 $b_1$。将 $n_3$ 保持在 $b_2$ 中，将 $n_5$ 保持在 $b_3$ 中。\n\nC. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。将 $n_5$ 从 $b_3$ 移动到 $b_1$。将 $n_6b$ 从 $b_4$ 移动到 $b_1$。将 $n_1$ 保持在 $b_1$ 中，将 $n_3$ 保持在 $b_2$ 中，将 $n_6a$ 保持在 $b_4$ 中。\n\nD. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 保持在 $b_3$ 中。将 $n_1$ 保持在 $b_1$ 中，将 $n_3$ 保持在 $b_2$ 中，将 $n_5$ 保持在 $b_3$ 中，并将 $n_6a$、$n_6b$ 保持在 $b_4$ 中。",
            "solution": "用户提供了一个关于编译器中全局代码移动优化的问题。任务是验证问题陈述的有效性，如果有效，则根据给定规则确定正确的代码调度。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **模型**：用于全局代码移动的编译分析-综合模型。\n- **程序表示**：基于控制流图（CFG）的静态单赋值（SSA）形式。\n- **分析信息**：对每个指令节点 $n$，预先计算了一个布尔标志 $MotionSafe(n)$。\n- **综合目标**：将每个可移动的计算放置到一个支配其所有使用的块中。\n- **综合约束**：\n    1. 可移动的计算必须被放置在其操作数可用的地方。\n    2. $MotionSafe(n) = \\mathrm{false}$ 的操作必须保持原地不动。\n    3. **最小支配放置策略**：将每个可移动节点放置到仍能支配其所有使用的最小（在支配树中）块中。其定义为：对于一个在块 $\\{u_i\\}$ 中有使用的节点 $n$，一个合法的放置块 $d$ 必须支配每个 $u_i$，并且 $d$ 在支配树中的任何严格后代都不支配所有的 $\\{u_i\\}$。\n- **CFG 结构**：\n    - 块：$b_0$（入口）、$b_1$、$b_2$、$b_3$、$b_4$。\n    - 控制流：$b_0 \\to b_1$；$b_1$ 分支到 $b_2$ 和 $b_3$；$b_2 \\to b_4$；$b_3 \\to b_4$。\n    - 直接支配者：$idom(b_1)=b_0$, $idom(b_2)=b_1$, $idom(b_3)=b_1$, $idom(b_4)=b_1$。\n- **指令和移动安全性**：\n    - 在 $b_1$ 中：$n_1$: $x := a + b$, $MotionSafe(n_1) = \\mathrm{true}$。\n    - 在 $b_2$ 中：$n_2$: $t_2 := x \\times 2$, $MotionSafe(n_2) = \\mathrm{true}$。以及 $n_3$: $store(s, t_2)$, $MotionSafe(n_3) = \\mathrm{false}$。\n    - 在 $b_3$ 中：$n_4$: $t_4 := x \\times 3$, $MotionSafe(n_4) = \\mathrm{true}$。以及 $n_5$: $t_5 := u / v$, $MotionSafe(n_5) = \\mathrm{false}$。\n    - 在 $b_4$ 中：$\\phi$: $y := \\phi(t_2, t_4)$。以及 $n_{6a}$: $l := load(q)$, $MotionSafe(n_{6a}) = \\mathrm{true}$。以及 $n_{6b}$: $z := y + l$, $MotionSafe(n_{6b}) = \\mathrm{true}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据已建立的标准评估问题陈述。\n\n- **科学依据**：该问题根植于编译器设计和优化这一成熟领域。CFG、SSA、支配者分析和全局代码移动（与部分冗余消除或懒惰代码移动等算法相关）等概念是计算机科学中的标准内容。所提供的规则和定义与该领域一致。\n- **良构性**：该问题是良构的。CFG 结构定义清晰。明确陈述的支配关系与 CFG 的控制流一致。代码移动的规则，特别是“最小支配放置”策略，为综合阶段提供了明确的目标函数。这种结构允许为每个可移动指令推导出唯一、正确的放置位置。\n- **客观性**：问题以精确、客观和形式化的语言陈述。所有术语要么是该领域的标准术语，要么被明确定义。\n- **一致性与完整性**：所提供的信息内部一致。从 `idom` 关系（$b_0$ 是 $b_1$ 的父节点，$b_1$ 是 $b_2$、$b_3$ 和 $b_4$ 的父节点）推导出的支配树与控制流图所隐含的支配属性相匹配。问题提供了确定每个指令放置位置所需的所有信息。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的。这是一个来自编译器优化领域、科学上合理、良构且客观的问题。我将继续推导解决方案。\n\n### 解题推导\n\n综合阶段必须为每个可移动的指令确定正确的放置位置，即可移动指令是 $MotionSafe(n) = \\mathrm{true}$ 的指令。固定的指令（$MotionSafe(n) = \\mathrm{false}$）是 $b_2$ 中的 $n_3$ 和 $b_3$ 中的 $n_5$。\n\n首先，让我们根据提供的直接支配者关系建立支配树：\n- $b_0$ 是根节点。\n- $idom(b_1)=b_0$ 意味着 $b_1$ 是 $b_0$ 的子节点。\n- $idom(b_2)=b_1$, $idom(b_3)=b_1$ 和 $idom(b_4)=b_1$ 意味着 $b_2$、$b_3$ 和 $b_4$ 都是 $b_1$ 的子节点。\n\n支配树是：\n$$\n\\begin{array}{c}\nb_0 \\\\\n| \\\\\nb_1 \\\\\n\\swarrow \\downarrow \\searrow \\\\\nb_2 \\quad b_3 \\quad b_4\n\\end{array}\n$$\n\n我们现在将根据放置规则分析每个可移动的指令。\n\n1.  **指令 $n_1: x := a + b$ (原在 $b_1$ 中)**\n    - $MotionSafe(n_1) = \\mathrm{true}$。\n    - **使用点**：结果 $x$ 被 $b_2$ 块中的 $n_2$ 和 $b_3$ 块中的 $n_4$ 使用。使用块的集合是 $\\{u_i\\} = \\{b_2, b_3\\}$。\n    - **支配要求**：放置块必须同时支配 $b_2$ 和 $b_3$。$b_2$ 和 $b_3$ 的共同支配者集合是 $\\{b_0, b_1\\}$。\n    - **最小放置**：我们必须在 $\\{b_0, b_1\\}$ 中找到一个块 $d$，使得 $d$ 的任何严格后代都不在该集合中。在支配树中，$b_1$ 是 $b_0$ 的严格后代。因此，最小支配放置点是 $b_1$。\n    - **操作数可用性**：假设操作数 $a$ 和 $b$ 在过程入口处可用，因此它们在 $b_1$ 中可用。\n    - **结论**：$n_1$ 的最优放置位置是其原始块 $b_1$。它应该保持在 $b_1$ 中。\n\n2.  **指令 $n_2: t_2 := x \\times 2$ (原在 $b_2$ 中)**\n    - $MotionSafe(n_2) = \\mathrm{true}$。\n    - **使用点**：结果 $t_2$ 被 $b_2$ 中的 $n_3$ 使用，并作为 $b_4$ 中 $\\phi$-函数的输入。使用块的集合是 $\\{b_2, b_4\\}$。\n    - **支配要求**：放置块必须同时支配 $b_2$ 和 $b_4$。$b_2$ 和 $b_4$ 的共同支配者集合是 $\\{b_0, b_1\\}$。\n    - **最小放置**：最小支配块同样是 $b_1$。\n    - **操作数可用性**：操作数是 $x$，由 $b_1$ 块中的 $n_1$ 定义。由于 $b_1$ 是目标放置块，操作数 $x$ 是可用的（假设 $n_1$ 放置在 $n_2$ 之前）。\n    - **结论**：$n_2$ 必须从 $b_2$ 移动到 $b_1$。\n\n3.  **指令 $n_4: t_4 := x \\times 3$ (原在 $b_3$ 中)**\n    - $MotionSafe(n_4) = \\mathrm{true}$。\n    - **使用点**：结果 $t_4$ 作为 $b_4$ 中 $\\phi$-函数的输入。使用块的集合是 $\\{b_4\\}$。\n    - **支配要求**：放置块必须支配 $b_4$。$b_4$ 的支配者集合是 $\\{b_0, b_1, b_4\\}$。然而，代码移动（提升）是将指令移动到支配其原始块的块中。原始块 $b_3$ 的支配者是 $\\{b_0, b_1\\}$。这两个块也都支配使用块 $b_4$。\n    - **最小放置**：在有效的提升目标 $\\{b_0, b_1\\}$ 之间，最小的是 $b_1$。\n    - **操作数可用性**：操作数是 $x$，由 $b_1$ 中的 $n_1$ 定义。操作数在目标块 $b_1$ 中可用。\n    - **结论**：$n_4$ 必须从 $b_3$ 移动到 $b_1$。\n\n4.  **指令 $n_6a: l := load(q)$ (原在 $b_4$ 中)**\n    - $MotionSafe(n_6a) = \\mathrm{true}$。\n    - **使用点**：结果 $l$ 被 $b_4$ 中的 $n_6b$ 使用。使用块的集合是 $\\{b_4\\}$。\n    - **支配要求**：放置块必须支配 $b_4$。$b_4$ 的支配者集合是 $\\{b_0, b_1, b_4\\}$。\n    - **最小放置**：最小支配块是 $b_4$ 本身。\n    - **结论**：$n_6a$ 的最优放置位置是其原始块 $b_4$。它应该保持在 $b_4$ 中。\n\n5.  **指令 $n_6b: z := y + l$ (原在 $b_4$ 中)**\n    - $MotionSafe(n_6b) = \\mathrm{true}$。\n    - **使用点**：问题没有指明 $z$ 的使用点。我们假设它在从 $b_4$ 退出时是活跃的，这使得 $b_4$ 成为使用块。\n    - **操作数可用性**：操作数是 $y$ 和 $l$。操作数 $l$ 由 $b_4$ 中的 $n_6a$ 定义。操作数 $y$ 由 $b_4$ 入口处的 $\\phi$-函数定义。$\\phi$-函数的值仅在其所在的块 *内部* 定义，而不是在块的入口处。因此，在任何严格支配 $b_4$ 的块中（即在 $b_1$ 或 $b_0$ 中），$y$ 都是不可用的。\n    - **结论**：由于操作数 $y$ 在 $b_4$ 之外不可用，$n_6b$ 不能被移动。它必须保持在 $b_4$ 中。\n\n**最优放置总结**：\n- $n_1$：保持在 $b_1$ 中。\n- $n_2$：移动到 $b_1$。\n- $n_3$：保持在 $b_2$ 中（固定）。\n- $n_4$：移动到 $b_1$。\n- $n_5$：保持在 $b_3$ 中（固定）。\n- $n_6a$：保持在 $b_4$ 中。\n- $n_6b$：保持在 $b_4$ 中。\n\n### 逐项分析选项\n\n现在我们根据这个推导出的正确调度来评估每个选项。\n\n**A. 将 $n_1$ 保持在 $b_1$ 中。将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。将 $n_3$ 保持在 $b_2$ 中，将 $n_5$ 保持在 $b_3$ 中。将 $n_6a$ 和 $n_6b$ 保持在 $b_4$ 中。**\n- $n_1$ 放置在 $b_1$：正确。\n- $n_2$ 放置在 $b_1$：正确。\n- $n_4$ 放置在 $b_1$：正确。\n- $n_3$ 放置在 $b_2$：正确。\n- $n_5$ 放置在 $b_3$：正确。\n- $n_6a$ 放置在 $b_4$：正确。\n- $n_6b$ 放置在 $b_4$：正确。\n这个选项在每个细节上都与推导出的调度相匹配。\n**结论：正确。**\n\n**B. 将 $n_1$ 从 $b_1$ 移动到 $b_0$。将 $n_2$ 从 $b_2$ 移动到 $b_0$。将 $n_4$ 从 $b_3$ 移动到 $b_0$。将 $n_{6a}$ 从 $b_4$ 移动到 $b_0$。将 $n_{6b}$ 从 $b_4$ 移动到 $b_1$。将 $n_3$ 保持在 $b_2$ 中，将 $n_5$ 保持在 $b_3$ 中。**\n- 将 $n_1$ 移动到 $b_0$：错误。这违反了最小支配放置规则，该规则要求放置在 $b_1$ 中。\n- 将 $n_2$ 移动到 $b_0$：错误。最小放置点是 $b_1$。\n- 将 $n_4$ 移动到 $b_0$：错误。最小放置点是 $b_1$。\n- 将 $n_{6b}$ 移动到 $b_1$：错误。操作数 $y$（来自 $b_4$ 中的 $\\phi$-函数）在 $b_1$ 中不可用。\n**结论：错误。**\n\n**C. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。将 $n_5$ 从 $b_3$ 移动到 $b_1$。将 $n_{6b}$ 从 $b_4$ 移动到 $b_1$。将 $n_1$ 保持在 $b_1$ 中，将 $n_3$ 保持在 $b_2$ 中，将 $n_{6a}$ 保持在 $b_4$ 中。**\n- 将 $n_5$ 移动到 $b_1$：错误。$MotionSafe(n_5)$ 为 $\\mathrm{false}$，所以 $n_5$ 必须固定在 $b_3$ 中。\n- 将 $n_{6b}$ 移动到 $b_1$：错误。操作数 $y$ 在 $b_1$ 中不可用。\n**结论：错误。**\n\n**D. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 保持在 $b_3$ 中。将 $n_1$ 保持在 $b_1$ 中，将 $n_3$ 保持在 $b_2$ 中，将 $n_5$ 保持在 $b_3$ 中，并将 $n_6a$、$n_6b$ 保持在 $b_4$ 中。**\n- 将 $n_4$ 保持在 $b_3$ 中：错误。问题陈述指出，综合阶段*必须*根据策略放置每个可移动的计算。由于 $n_4$ 是可移动的（$MotionSafe(n_4) = \\mathrm{true}$），它必须被移动到其最优放置位置，即 $b_1$。将其保留在 $b_3$ 中与既定的综合策略不符。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}