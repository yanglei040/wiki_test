{
    "hands_on_practices": [
        {
            "introduction": "即时（JIT）编译器在严格的时间限制下运行，这使得资源分配成为一项关键挑战。这项实践  将 JIT 编译视为一个经济学问题：如何将固定的编译预算分配给多个“热”函数，以实现最大的整体性能提升。通过对编译工作的边际效益递减进行建模，你将使用优化技术来推导出最有效的投资策略。",
            "id": "3648582",
            "problem": "即时 (JIT) 编译器在程序执行期间动态地将编译精力投入到“热”函数中，以减少未来的执行时间。设一组热函数表示为 $\\{f_i\\}_{i=1}^{n}$，投入到函数 $f_i$ 的编译时间为 $b_i \\ge 0$。总编译时间预算为 $B$，因此 $\\sum_{i=1}^{n} b_i = B$。将编译时间投入到函数 $f_i$ 中所带来的预期加速贡献，由一个凹增函数 $s_i(b_i)$ 建模，该函数随着编译精力的增加表现出边际效益递减。对于本问题，假设采用经过充分检验的建模选择\n$$\ns_i(b_i) = \\alpha_i \\ln\\!\\big(1 + \\beta_i b_i\\big),\n$$\n其中 $\\alpha_i  0$ 反映了函数 $f_i$ 的热度和优化空间，而 $\\beta_i  0$ 反映了对函数 $f_i$ 每毫秒编译精力的有效性。$\\ln$ 函数的凹性意味着边际效益递减，并确保在固定预算下全局最优解存在且唯一。\n\n给定三个热函数及其参数\n$$\n\\alpha_1 = 5,\\quad \\beta_1 = 0.1,\\qquad \\alpha_2 = 3,\\quad \\beta_2 = 0.2,\\qquad \\alpha_3 = 2,\\quad \\beta_3 = 0.05,\n$$\n以及总编译时间预算 $B = 100$ 毫秒，请从第一性原理出发，推导出能在约束条件 $\\sum_{i=1}^{3} b_i = B$ 和 $b_i \\ge 0$ 下最大化总预期加速 $\\sum_{i=1}^{3} s_i(b_i)$ 的分配方案 $b_1$、$b_2$ 和 $b_3$。\n\n将最终分配结果四舍五入到四位有效数字，并以毫秒为单位表示。最终答案必须是一个包含 $(b_1, b_2, b_3)$ 的单行矩阵，矩阵内不含单位。",
            "solution": "问题是在一组 $n$ 个热函数 $\\{f_i\\}_{i=1}^{n}$ 之间，确定一个固定的编译时间预算 $B$ 的最优分配，以最大化总预期加速。这是一个经典的约束优化问题。\n\n首先，我们将问题陈述形式化。\n需要最大化的目标函数是总加速 $S$，它由各个加速贡献之和给出：\n$$S(b_1, b_2, \\dots, b_n) = \\sum_{i=1}^{n} s_i(b_i)$$\n其中 $s_i(b_i) = \\alpha_i \\ln(1 + \\beta_i b_i)$。变量 $b_i$ 代表投入到函数 $f_i$ 的编译时间。\n\n该优化受两个约束条件限制：\n1. 预算约束：总投入时间不能超过预算 $B$。由于加速函数 $s_i(b_i)$ 随 $b_i$ 严格递增，为了达到最大值，预算将被完全用尽。因此，该约束是一个等式：\n$$ \\sum_{i=1}^{n} b_i = B $$\n2. 非负约束：投入的时间不能为负：\n$$ b_i \\ge 0 \\quad \\text{for all } i \\in \\{1, 2, \\dots, n\\} $$\n目标函数 $S$ 是一系列凹函数之和（因为对数函数是凹函数，且其参数 $1 + \\beta_i b_i$ 是 $b_i$ 的仿射函数），因此其本身也是凹函数。由线性约束定义的可行域是一个紧凸集。在凸集上最大化一个凹函数是一个标准的凸优化问题，这保证了局部最大值也是全局最大值。\n\n我们将使用拉格朗日乘子法，并结合 Karush-Kuhn-Tucker (KKT) 条件来处理不等式约束，以解决此问题。拉格朗日函数 $\\mathcal{L}$ 构建如下：\n$$ \\mathcal{L}(b_1, \\dots, b_n, \\lambda, \\mu_1, \\dots, \\mu_n) = \\sum_{i=1}^{n} \\alpha_i \\ln(1 + \\beta_i b_i) - \\lambda \\left(\\sum_{i=1}^{n} b_i - B\\right) + \\sum_{i=1}^{n} \\mu_i b_i $$\n在此，$\\lambda$ 是等式（预算）约束的拉格朗日乘子，而 $\\mu_i \\ge 0$ 是非负约束 $b_i \\ge 0$ 的 KKT 乘子。\n\n最优解 $(b_1^*, \\dots, b_n^*)$ 的 KKT 条件如下：\n1. 稳定性条件：对每个 $i=1, \\dots, n$，有 $\\frac{\\partial \\mathcal{L}}{\\partial b_i} = 0$。\n2. 原始可行性：$\\sum_{i=1}^{n} b_i^* = B$ 且 $b_i^* \\ge 0$。\n3. 对偶可行性：$\\mu_i \\ge 0$。\n4. 互补松弛性：$\\mu_i b_i^* = 0$。\n\n让我们为稳定性条件计算偏导数：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial b_i} = \\frac{d}{db_i} \\left[ \\alpha_i \\ln(1 + \\beta_i b_i) \\right] - \\lambda + \\mu_i = \\frac{\\alpha_i \\beta_i}{1 + \\beta_i b_i} - \\lambda + \\mu_i = 0 $$\n根据互补松弛性条件，如果我们找到一个解其中 $b_i^*  0$，那么必然有 $\\mu_i = 0$。我们假设一个内部解，即对所有 $i$ 都有 $b_i^*  0$。在这种情况下，所有的 $\\mu_i=0$，稳定性条件简化为：\n$$ \\frac{\\alpha_i \\beta_i}{1 + \\beta_i b_i} = \\lambda $$\n这个条件有一个清晰的解释：在最优点，每单位编译时间的边际加速 $\\frac{ds_i}{db_i} = \\frac{\\alpha_i \\beta_i}{1 + \\beta_i b_i}$，对于所有获得非零时间分配的函数，该值必须相等。这个共同的值就是拉格朗日乘子 $\\lambda$。\n\n现在我们可以用 $\\lambda$ 来求解 $b_i$：\n$$ 1 + \\beta_i b_i = \\frac{\\alpha_i \\beta_i}{\\lambda} \\implies \\beta_i b_i = \\frac{\\alpha_i \\beta_i}{\\lambda} - 1 \\implies b_i = \\frac{\\alpha_i}{\\lambda} - \\frac{1}{\\beta_i} $$\n这个表达式对每个 $b_i  0$ 的 $i$ 都有效。现在我们将其代入预算约束中，以求出 $\\lambda$ 的值：\n$$ \\sum_{i=1}^{n} b_i = \\sum_{i=1}^{n} \\left(\\frac{\\alpha_i}{\\lambda} - \\frac{1}{\\beta_i}\\right) = B $$\n$$ \\frac{1}{\\lambda} \\sum_{i=1}^{n} \\alpha_i - \\sum_{i=1}^{n} \\frac{1}{\\beta_i} = B $$\n$$ \\frac{1}{\\lambda} \\left(\\sum_{i=1}^{n} \\alpha_i\\right) = B + \\sum_{i=1}^{n} \\frac{1}{\\beta_i} $$\n求解 $\\frac{1}{\\lambda}$：\n$$ \\frac{1}{\\lambda} = \\frac{B + \\sum_{j=1}^{n} \\frac{1}{\\beta_j}}{\\sum_{j=1}^{n} \\alpha_j} $$\n现在我们将此应用于具有 $n=3$、预算 $B=100$ 和给定参数的具体问题：\n- $\\alpha_1 = 5, \\beta_1 = 0.1$\n- $\\alpha_2 = 3, \\beta_2 = 0.2$\n- $\\alpha_3 = 2, \\beta_3 = 0.05$\n\n首先，我们计算所需的和：\n$$ \\sum_{i=1}^{3} \\alpha_i = 5 + 3 + 2 = 10 $$\n$$ \\sum_{i=1}^{3} \\frac{1}{\\beta_i} = \\frac{1}{0.1} + \\frac{1}{0.2} + \\frac{1}{0.05} = 10 + 5 + 20 = 35 $$\n现在我们可以计算 $\\frac{1}{\\lambda}$：\n$$ \\frac{1}{\\lambda} = \\frac{100 + 35}{10} = \\frac{135}{10} = 13.5 $$\n利用 $\\frac{1}{\\lambda}$ 的值，我们可以求出各个分配值 $b_i$：\n$$ b_i = \\alpha_i \\left(\\frac{1}{\\lambda}\\right) - \\frac{1}{\\beta_i} $$\n对于 $i=1$：\n$$ b_1 = \\alpha_1 (13.5) - \\frac{1}{\\beta_1} = 5 \\times 13.5 - 10 = 67.5 - 10 = 57.5 $$\n对于 $i=2$：\n$$ b_2 = \\alpha_2 (13.5) - \\frac{1}{\\beta_2} = 3 \\times 13.5 - 5 = 40.5 - 5 = 35.5 $$\n对于 $i=3$：\n$$ b_3 = \\alpha_3 (13.5) - \\frac{1}{\\beta_3} = 2 \\times 13.5 - 20 = 27.0 - 20 = 7.0 $$\n我们必须验证我们最初的假设，即对所有 $i$ 都有 $b_i  0$。计算出的值为 $b_1 = 57.5$、$b_2 = 35.5$ 和 $b_3 = 7.0$，它们都是正数。因此，我们的假设是正确的，并且 KKT 条件在 $\\mu_1 = \\mu_2 = \\mu_3 = 0$ 时得到满足。\n\n作为最后核对，我们确认预算约束得到满足：\n$$ \\sum_{i=1}^{3} b_i = 57.5 + 35.5 + 7.0 = 93.0 + 7.0 = 100.0 $$\n该约束被精确满足。\n\n题目要求将最终分配结果四舍五入到四位有效数字。\n- $b_1 = 57.5$ 变为 $57.50$\n- $b_2 = 35.5$ 变为 $35.50$\n- $b_3 = 7.0$ 变为 $7.000$\n\n以毫秒为单位的最优分配为 $(b_1, b_2, b_3) = (57.50, 35.50, 7.000)$。",
            "answer": "$$ \\boxed{\n\\begin{pmatrix}\n57.50  35.50  7.000\n\\end{pmatrix}\n} $$"
        },
        {
            "introduction": "在 JIT 设计中，决定何时编译一个函数是一个关键的策略问题。过早编译会浪费精力，而过晚编译则会错失优化良机。这个练习  要求你分析一个复杂的触发机制，该机制使用调用点计数和指数退避策略，让你亲手应用概率论来建模和理解编译器的启发式策略。",
            "id": "3648579",
            "problem": "一个即时编译器使用一个带有指数退避决策策略的、基于每个调用点的计数器。对单个调用点的调用以速率为每秒 $\\lambda$ 次的泊松过程到达。该策略如下：在第一次调用之后，当自首次调用以来的计数器达到 $\\tau$ 次调用时，运行时会安排第一次编译决策，其中 $\\tau \\in \\mathbb{N}$ 且 $\\tau \\geq 1$。如果在该点的决策是不编译，则下一次决策将在额外的 $\\beta \\tau$ 次调用后安排，再下一次在额外的 $\\beta^{2} \\tau$ 次调用后安排，依此类推，其中退避因子满足 $\\beta  1$。在每个决策点，运行时以概率 $q \\in (0,1]$ 独立地决定进行编译，并以概率 $1 - q$ 决定不编译。一旦发生编译，该过程即停止。\n\n使用关于泊松过程（第 $n$ 个事件的期望时间为 $n/\\lambda$）和几何随机变量（直到首次成功的独立试验次数服从几何分布）的公认事实，推导出一个关于编译期望时间 $\\mathbb{E}[T]$ 的闭式表达式，该表达式是 $\\lambda$、$\\tau$、$\\beta$ 和 $q$ 的函数。请以秒为单位表示 $\\mathbb{E}[T]$ 的最终答案。不要提供任何数值近似。",
            "solution": "设 $T$ 为编译发生的总时间，这是一个随机变量。我们的目标是计算其期望值 $\\mathbb{E}[T]$。\n\n我们可以通过对编译发生的决策点 $K$ 进行条件化来求解 $\\mathbb{E}[T]$。$K$ 是一个随机变量，表示在第几个决策点上发生了编译，其取值为 $k \\in \\{1, 2, 3, \\ldots\\}$。在每个决策点，编译是一个独立的伯努利试验，成功概率为 $q$。因此，$K$ 服从几何分布，其概率质量函数为：\n$$P(K=k) = (1-q)^{k-1} q$$\n\n根据全期望定律，$\\mathbb{E}[T]$ 可以表示为：\n$$\\mathbb{E}[T] = \\sum_{k=1}^{\\infty} \\mathbb{E}[T | K=k] P(K=k)$$\n\n首先，我们计算条件期望 $\\mathbb{E}[T | K=k]$，即假设编译在第 $k$ 个决策点发生时的期望时间。\n到达第 $k$ 个决策点所需的总调用次数 $N_k$ 是一个几何级数之和：\n$$N_k = \\tau + \\beta\\tau + \\beta^2\\tau + \\dots + \\beta^{k-1}\\tau = \\tau \\sum_{i=0}^{k-1} \\beta^i$$\n利用几何级数求和公式，我们得到：\n$$N_k = \\tau \\left( \\frac{\\beta^k - 1}{\\beta - 1} \\right)$$\n根据泊松过程的性质，观察到 $N_k$ 次调用所需的期望时间为 $N_k/\\lambda$。因此：\n$$\\mathbb{E}[T | K=k] = \\frac{N_k}{\\lambda} = \\frac{\\tau}{\\lambda(\\beta - 1)} (\\beta^k - 1)$$\n\n现在，我们将此条件期望代入全期望定律的公式中：\n$$\\mathbb{E}[T] = \\sum_{k=1}^{\\infty} \\left[ \\frac{\\tau}{\\lambda(\\beta - 1)} (\\beta^k - 1) \\right] (1-q)^{k-1} q$$\n将常数项移到求和符号之外：\n$$\\mathbb{E}[T] = \\frac{\\tau q}{\\lambda(\\beta - 1)} \\sum_{k=1}^{\\infty} (\\beta^k - 1) (1-q)^{k-1}$$\n我们将求和部分分解为两项：\n$$\\sum_{k=1}^{\\infty} (\\beta^k - 1) (1-q)^{k-1} = \\sum_{k=1}^{\\infty} \\beta^k (1-q)^{k-1} - \\sum_{k=1}^{\\infty} (1-q)^{k-1}$$\n\n计算第一项，这是一个几何级数：\n$$\\sum_{k=1}^{\\infty} \\beta^k (1-q)^{k-1} = \\beta \\sum_{k=1}^{\\infty} [\\beta(1-q)]^{k-1} = \\beta \\sum_{j=0}^{\\infty} [\\beta(1-q)]^j$$\n该级数收敛的条件是公比的绝对值小于 1，即 $|\\beta(1-q)|  1$。由于 $\\beta  1$ 且 $q \\in (0, 1]$，该条件简化为 $\\beta(1-q)  1$。如果满足此条件，和为：\n$$\\frac{\\beta}{1 - \\beta(1-q)}$$\n\n计算第二项，也是一个几何级数：\n$$\\sum_{k=1}^{\\infty} (1-q)^{k-1} = \\sum_{j=0}^{\\infty} (1-q)^j = \\frac{1}{1 - (1-q)} = \\frac{1}{q}$$\n\n将两项的结果合并：\n$$\\frac{\\beta}{1 - \\beta(1-q)} - \\frac{1}{q} = \\frac{\\beta q - [1 - \\beta(1-q)]}{q[1 - \\beta(1-q)]} = \\frac{\\beta q - 1 + \\beta - \\beta q}{q[1 - \\beta(1-q)]} = \\frac{\\beta - 1}{q[1 - \\beta(1-q)]}$$\n\n最后，代入 $\\mathbb{E}[T]$ 的表达式中：\n$$\\mathbb{E}[T] = \\frac{\\tau q}{\\lambda(\\beta - 1)} \\cdot \\frac{\\beta - 1}{q[1 - \\beta(1-q)]}$$\n化简后得到最终结果，单位为秒：\n$$\\mathbb{E}[T] = \\frac{\\tau}{\\lambda(1 - \\beta(1-q))}$$\n此表达式在 $\\beta(1-q)  1$ 的条件下成立，否则期望时间为无穷大。",
            "answer": "$$\\boxed{\\frac{\\tau}{\\lambda(1 - \\beta(1-q))}}$$"
        },
        {
            "introduction": "JIT 编译的威力通常源于其做出的乐观假设，但这些假设并非总是成立。当一个推测失败时，编译器必须通过一个称为“去优化”（deoptimization）的过程安全地回退到未经优化的执行路径。在这个问题中 ，你将设计一个测试来触发去优化，并明确指出为保证程序正确性所需做的精确状态重构，从而揭示这个关键安全网背后的复杂工程。",
            "id": "3648573",
            "problem": "考虑一个用于简单命令式、动态类型语言的即时 (JIT) 编译器，该语言支持数组和结构化循环。该语言支持深度为 $d$ 的嵌套循环，迭代器为 $i_0,\\dots,i_{d-1}$，并有一个累加器变量 $v$。源程序模式如下：\n\n- 初始化：$v \\leftarrow 0$。\n- 对于每个 $k \\in \\{0,\\dots,d-1\\}$，按自然递增顺序执行一个形式为 `for $i_k$ from $0$ to $N_k-1$` (含边界) 的循环。\n- 在最内层循环体中，执行一条将当前数组元素加到 $v$ 上的语句：$v \\leftarrow v + B[i_{d-1}]$。\n\n假设 JIT 基于剖析 (profiling) 进行推测性优化，认为最内层循环体中的大多数加法是整数加法。它在加法操作前紧邻的位置保留一个守卫 (guard)，检查 $B[i_{d-1}]$ 是否为整数类型。如果守卫失败，JIT 必须在语义上等同于加法操作发生前一刻的去优化点，去优化 (bail out) 到解释器。去优化过程必须重构一个等价的源码级状态，包括与嵌套循环对应的 $d$ 个逻辑帧、累加器 $v$ 以及所有迭代器 $i_0,\\dots,i_{d-1}$。\n\n您需要根据去优化正确性和结构化循环语义的基本原则，确定以下哪个选项同时满足：\n\n- 给出一个最小测试配置（循环边界 $N_0,\\dots,N_{d-1}$ 和数组内容），该配置可证明地在深度为 $d$ 的最内层循环内部（即，不在循环头或循环退出后）触发一次去优化，同时最小化为观察到非平凡的累加器值和一次守卫失败所必需执行的最内层迭代总次数，并且\n- 指定一个正确的 Bailout 映射，该映射重构解释器状态，以便在相应的源码点恢复执行时，能够产生与优化后执行在守卫失败前的可观察行为相同的行为。\n\n使用以下基本定义：\n\n- 如果在去优化点，重构的解释器状态 $\\sigma_{\\text{interp}}$ 与从优化后的机器状态 $\\sigma_{\\text{opt}}$ 中抽象出的源码级状态在观察上等价，程序计数器指向与守卫点相对应的源语句，且所有活跃变量都绑定到它们在该点的源码级值，则去优化是正确的。\n- 对于结构化循环，在执行最内层循环体期间，迭代器 $i_k$ 的值是该循环在迭代字典序中的当前索引。如果去优化点恰好在执行 $v \\leftarrow v + B[i_{d-1}]$ 之前，那么 $i_{d-1}$ 的正确值是当前的最内层索引，而不是为下一次迭代递增后的值。\n- 此处的最小性是指，在满足以下两个约束条件的前提下，最小化乘积 $\\prod_{k=0}^{d-1} N_k$：(i) 控制流至少有一次到达守卫并成功通过，从而使 $v$ 至少被更新一次；(ii) 在同一动态嵌套中，后续访问守卫时失败，从而在最内层循环体内触发去优化。\n\n哪个选项满足这两个条件？\n\nA. 选择循环边界 $N_0=\\cdots=N_{d-2}=1$ 和 $N_{d-1}=2$。选择数组 $B$ 使得 $B[0]$ 是一个整数（例如，整数 $1$），而 $B[1]$ 是一个非整数（例如，一个浮点数值）。将守卫紧邻加法操作之前放置。Bailout 映射：重构 $d$ 个逻辑帧，在 $v \\leftarrow v + B[i_{d-1}]$ 的源码位置恢复执行；将 $v$ 映射到第一次成功加法后的优化累加器值；将迭代器映射为 $i_k \\mapsto 0$（对于所有 $k \\in \\{0,\\dots,d-2\\}$）和 $i_{d-1} \\mapsto 1$；确保任何物化值在此时点与源码语义匹配。\n\nB. 选择循环边界 $N_0=\\cdots=N_{d-3}=1$，$N_{d-2}=2$ 和 $N_{d-1}=1$。选择 $B$ 作为一个同质整数数组。在循环退出时插入一个检查内层循环边界 $i_{d-2}  N_{d-2}$ 的守卫；当 $i_{d-2}$ 第二次迭代结束时边界检查失败则去优化。Bailout 映射：在 $i_{d-2}$ 循环的循环头恢复执行，此时 $i_{d-2} \\mapsto 2$，$i_{d-1} \\mapsto 0$，且 $v$ 为至今为止累加的值。\n\nC. 选择循环边界 $N_0=\\cdots=N_{d-2}=1$ 和 $N_{d-1}=2$。选择 $B[0]=1$ 和 $B[1]=2$，二者均为整数。推测循环是单态的 (monomorphic) 并完全移除守卫。Bailout 映射：不需要，因为推测不可能失败。\n\nD. 选择循环边界 $N_0=\\cdots=N_{d-2}=1$ 和 $N_{d-1}=2$。选择 $B[0]$ 为整数，$B[1]$ 为非整数。在加法操作前放置守卫，并在失败时去优化。Bailout 映射：重构帧并在 $v \\leftarrow v + B[i_{d-1}]$ 的源码位置恢复执行；将 $v$ 映射到它在与 $B[i_{d-1}]$ 执行加法操作后会有的值；将迭代器映射为 $i_k \\mapsto 0$（对于 $k \\in \\{0,\\dots,d-2\\}$）和 $i_{d-1} \\mapsto 2$，因为循环将在守卫失败后递增。\n\n选择所有适用的选项。",
            "solution": "该问题要求确定一个选项，该选项既能提供触发特定去优化事件的最小测试配置，又能提供重构程序状态以供解释器使用的正确 Bailout 映射。\n\n### 基于基本原则的需求分析\n\n**1. 最小测试配置**\n\n问题为测试配置指定了几个约束：\n- 程序执行一个深度为 $d$ 的嵌套循环。最内层循环体的总执行次数由循环边界的乘积给出：$\\prod_{k=0}^{d-1} N_k$。\n- 去优化由一个守卫失败触发，`check(type(B[i_{d-1}]) == integer)`，该失败发生在*最内层循环体内部*。\n- 配置必须是最小的，这被定义为最小化最内层迭代的总次数 $\\prod_{k=0}^{d-1} N_k$。\n- 这种最小性受两个条件约束：(i) 守卫至少成功一次，以便累加器 $v$ 被更新；(ii) 守卫在随后的访问中失败。\n\n为了满足条件 (i) 和 (ii)，最内层循环体必须至少执行两次。第一次执行将访问数组 $B$ 中一个为整数的元素，第二次执行将访问一个非整数的元素。由于数组由 $i_{d-1}$ 索引，这两次执行之间 $i_{d-1}$ 的值必须改变。这意味着由 $i_{d-1}$ 控制的最内层循环必须至少迭代两次。\n\n让我们形式化这个最小化过程：\n- 最内层循环迭代的总次数为 $I = \\prod_{k=0}^{d-1} N_k$。\n- 每个循环边界 $N_k$ 必须至少为 $1$ 才能使循环执行。\n- 我们需要至少两次迭代，所以 $I \\ge 2$。\n- 为了最小化 $I$，我们设置 $I=2$。\n- 对于整数 $N_k \\ge 1$ 的乘积要为 $2$，必须恰好有一个 $N_k$ 为 $2$，所有其他的 $N_j$ (对于 $j \\neq k$) 必须为 $1$。\n\n数组访问是 $B[i_{d-1}]$。要根据 $B$ 元素的值触发类型失败，索引 $i_{d-1}$ 必须变化。这只有在 $i_{d-1}$ 的循环运行一次以上时才可能。因此，我们必须有 $N_{d-1} \\ge 2$。为了实现最小乘积 $2$，我们必须选择 $N_{d-1}=2$ 并且对于所有 $k \\in \\{0, \\dots, d-2\\}$，$N_k=1$。\n\n因此，最小配置是：\n- 循环边界：对于 $k \\in \\{0, \\dots, d-2\\}$，$N_k=1$，以及 $N_{d-1}=2$。\n- 数组内容：为了满足先成功后失败的守卫条件，我们需要 `type(B[0])` 是整数，而 `type(B[1])` 是非整数。例如，$B[0]=1$ (整数) 和 $B[1]=1.5$ (浮点数)。\n\n**2. 正确的 Bailout 映射**\n\n去优化被指定为在 $B[i_{d-1}]$ 上的守卫失败时发生。这发生在最内层循环的第二次迭代，即 $i_{d-1}=1$ 时。去优化点“语义上等同于加法操作发生前的一刻”。\n\n我们必须在这一精确时刻重构源码级状态：\n- **程序计数器**：解释器应在失败语句的开头处恢复执行，即 $v \\leftarrow v + B[i_{d-1}]$。\n- **迭代器**：迭代器必须保持它们在失败发生时的值。\n  - 外层循环迭代器 $i_0, \\dots, i_{d-2}$ 只取过值 $0$。\n  - 最内层循环处于其第二次迭代，所以 $i_{d-1}=1$。问题陈述明确证实了这一点：“$i_{d-1}$ 的正确值是当前的最内层索引，而不是为下一次迭代递增后的值。”\n- **累加器 $v$**：$v$ 的值必须是它在失败操作*之前*的值。\n  - 初始值：$v \\leftarrow 0$。\n  - 第一次迭代后 ($i_{d-1}=0$)：守卫 `check(type(B[0]) == integer)` 成功。加法被执行：$v \\leftarrow v + B[0]$。如果我们假设 $B[0]=1$，那么 $v$ 变为 $1$。\n  - 在去优化点（第二次迭代中加法之前），没有对 $v$ 进行进一步的修改。因此，要重构的 $v$ 的正确值是它在最后一次成功操作后的值，即 $1$（假设 $B[0]=1$）。\n\n总而言之，一个正确的 Bailout 映射必须重构状态，使得程序即将以迭代器 $(i_0, \\dots, i_{d-2}, i_{d-1}) = (0, \\dots, 0, 1)$ 和 $v=B[0]$ 来执行 $v \\leftarrow v + B[1]$。\n\n### 逐项分析\n\n**A. 选择循环边界 $N_0=\\cdots=N_{d-2}=1$ 和 $N_{d-1}=2$。选择数组 $B$ 使得 $B[0]$ 是一个整数（例如，整数 $1$），而 $B[1]$ 是一个非整数（例如，一个浮点数值）。将守卫紧邻加法操作之前放置。Bailout 映射：重构 $d$ 个逻辑帧，在 $v \\leftarrow v + B[i_{d-1}]$ 的源码位置恢复执行；将 $v$ 映射到第一次成功加法后的优化累加器值；将迭代器映射为 $i_k \\mapsto 0$（对于所有 $k \\in \\{0,\\dots,d-2\\}$）和 $i_{d-1} \\mapsto 1$；确保任何物化值在此时点与源码语义匹配。**\n\n- **测试配置**：循环边界（对于 $k  d-1$，$N_k=1$；$N_{d-1}=2$）和数组内容（$B[0]$ 是整数，$B[1]$ 是非整数）与我们导出的最小配置完全匹配。\n- **Bailout 映射**：\n    - 恢复位置：在 $v \\leftarrow v + B[i_{d-1}]$ 处。正确。\n    - 累加器 $v$：映射到“第一次成功加法后的优化累加器值”。正确。\n    - 迭代器：映射为 $i_k \\mapsto 0$ (对于 $k  d-1$) 和 $i_{d-1} \\mapsto 1$。正确。\n- **结论**：此选项完美满足所有条件。\n\n**B. 选择循环边界 $N_0=\\cdots=N_{d-3}=1$，$N_{d-2}=2$ 和 $N_{d-1}=1$。选择 $B$ 作为一个同质整数数组。在循环退出时插入一个检查内层循环边界 $i_{d-2}  N_{d-2}$ 的守卫；当 $i_{d-2}$ 第二次迭代结束时边界检查失败则去优化。Bailout 映射：在 $i_{d-2}$ 循环的循环头恢复执行，此时 $i_{d-2} \\mapsto 2$，$i_{d-1} \\mapsto 0$，且 $v$ 为至今为止累加的值。**\n\n- **测试配置**：此配置更改了触发去优化的机制（边界检查而不是类型检查）和位置（循环退出而不是循环体内）。这与问题描述不符。\n\n**C. 选择循环边界 $N_0=\\cdots=N_{d-2}=1$ 和 $N_{d-1}=2$。选择 $B[0]=1$ 和 $B[1]=2$，二者均为整数。推测循环是单态的 (monomorphic) 并完全移除守卫。Bailout 映射：不需要，因为推测不可能失败。**\n\n- **测试配置**：此配置不会触发守卫失败，因为它使用了同质的整数数组。因此，它不满足问题的核心要求。移除守卫是基于不成立的假设而做出的不安全优化。\n\n**D. 选择循环边界 $N_0=\\cdots=N_{d-2}=1$ 和 $N_{d-1}=2$。选择 $B[0]$ 为整数，$B[1]$ 为非整数。在加法操作前放置守卫，并在失败时去优化。Bailout 映射：重构帧并在 $v \\leftarrow v + B[i_{d-1}]$ 的源码位置恢复执行；将 $v$ 映射到它在与 $B[i_{d-1}]$ 执行加法操作后会有的值；将迭代器映射为 $i_k \\mapsto 0$（对于 $k \\in \\{0,\\dots,d-2\\}$）和 $i_{d-1} \\mapsto 2$，因为循环将在守卫失败后递增。**\n\n- **Bailout 映射**：此映射不正确。它将 $v$ 映射到操作*之后*的值，并且将 $i_{d-1}$ 映射到下一个迭代的值 ($2$)。正确的去优化必须在操作*之前*重构状态，因此迭代器应该是其当前值 ($1$)。\n\n因此，只有选项 A 提供了既正确又符合最小性原则的配置和 Bailout 映射。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}