{
    "hands_on_practices": [
        {
            "introduction": "The abstract concept of a closure environment becomes concrete when a compiler must generate code to manage it in memory. This first practice grounds our understanding in this physical reality by focusing on the crucial details of memory layout. By calculating field offsets and padding based on standard Application Binary Interface (ABI) alignment rules, you will see how compilers ensure both correctness and performance for the data structures they create .",
            "id": "3627610",
            "problem": "Consider closure conversion of a lexically scoped function in a compiler for a 64-bit Application Binary Interface (ABI), where the function captures three free variables in its environment record: $x:\\mathrm{int32}$, $y:\\mathrm{double}$, and $z:\\mathrm{int64}$. The environment is a contiguous record allocated on the heap. Assume the following widely used ABI alignment facts: a field of type $\\mathrm{int32}$ has an alignment requirement of $4$ bytes and size $4$ bytes, a field of type $\\mathrm{double}$ has an alignment requirement of $8$ bytes and size $8$ bytes, and a field of type $\\mathrm{int64}$ has an alignment requirement of $8$ bytes and size $8$ bytes. For correctness and interoperability, the record’s alignment must be chosen to satisfy the most stringent field alignment among its members, and each field must start at an offset that is a multiple of its own alignment. Fields must be laid out in the declared order $x$, then $y$, then $z$.\n\nUsing these foundational rules, determine:\n- the appropriate record alignment for the environment,\n- the minimal non-negative byte offsets for $x$, $y$, and $z$ within the record that satisfy all alignment constraints,\n- the final packed size of the environment record in bytes after applying any necessary trailing padding so that the total size is a multiple of the record alignment.\n\nJustify any padding you introduce between fields. Express the final offsets for $(x, y, z)$ followed by the final record size as four integers in bytes. No rounding is required. Do not include units in your final boxed answer, but compute all quantities in bytes.",
            "solution": "The problem requires the determination of the memory layout for a compiler-generated environment record, specifically its alignment, the offsets of its fields, and its total size, adhering to standard Application Binary Interface (ABI) alignment rules.\n\n### Step 1: Problem Validation\n\nThe problem statement is validated according to the specified criteria.\n\n**1. Extract Givens:**\n- Architecture: 64-bit ABI.\n- Captured free variables (fields) and their order:\n  1. $x$: type $\\mathrm{int32}$, size $4$ bytes, alignment $4$ bytes.\n  2. $y$: type $\\mathrm{double}$, size $8$ bytes, alignment $8$ bytes.\n  3. $z$: type $\\mathrm{int64}$, size $8$ bytes, alignment $8$ bytes.\n- Field Layout Rule: Fields must be laid out in the declared order: $x$, then $y$, then $z$.\n- Field Alignment Rule: Each field must start at an offset from the beginning of the record that is a multiple of its own alignment requirement.\n- Record Alignment Rule: The alignment of the entire record must be equal to the most stringent (i.e., largest) alignment requirement of any of its fields.\n- Record Size Rule: The total size of the record must be a multiple of the record's alignment, which may require adding trailing padding.\n\n**2. Validate Using Extracted Givens:**\n- **Scientifically Grounded:** The problem is firmly rooted in computer science, specifically in compiler design and systems programming. The alignment rules for data structures are fundamental concepts in how compilers manage memory for performance and correctness on modern hardware. The specified sizes and alignments for $\\mathrm{int32}$, $\\mathrm{double}$, and $\\mathrm{int64}$ are standard for common 64-bit ABIs (e.g., the System V AMD64 ABI). The problem is scientifically sound.\n- **Well-Posed:** The problem provides a complete set of rules and data. The objective is to calculate four specific integer values. The constraints are well-defined, leading to a unique and stable solution.\n- **Objective:** The problem is stated using precise, technical terminology with no ambiguity or subjective elements.\n\n**3. Verdict and Action:**\nThe problem is valid. It is a well-posed, scientifically grounded, and objective question from the domain of compiler principles. The solution process may proceed.\n\n### Step 2: Solution Derivation\n\nThe solution is derived by systematically applying the given rules. All calculations are performed in bytes.\n\n**1. Determine the Record Alignment**\nThe alignment of the environment record is dictated by the most stringent alignment of its members.\n- Alignment of $x$ ($\\mathrm{int32}$): $4$ bytes.\n- Alignment of $y$ ($\\mathrm{double}$): $8$ bytes.\n- Alignment of $z$ ($\\mathrm{int64}$): $8$ bytes.\n\nThe most stringent alignment is the maximum of these values:\n$$ \\text{Record Alignment} = \\max(4, 8, 8) = 8 \\text{ bytes} $$\nThe base address of the entire environment record must be a multiple of $8$.\n\n**2. Determine the Field Offsets**\nWe lay out the fields in the specified order ($x, y, z$), adding padding where necessary to satisfy each field's alignment requirement. Let the offset of a field be its starting byte position relative to the beginning of the record (offset $0$).\n\n- **Field $x$ ($\\mathrm{int32}$):**\n  - Size: $4$ bytes.\n  - Alignment: $4$ bytes.\n  - The record begins at offset $0$. The first available offset for $x$ is $0$.\n  - Since $0$ is a multiple of $4$ (i.e., $0 = 0 \\times 4$), this position is valid.\n  - **Offset of $x$ is $0$.**\n  - $x$ occupies bytes $0$ through $3$.\n  - The current size of the record is $4$ bytes.\n\n- **Field $y$ ($\\mathrm{double}$):**\n  - Size: $8$ bytes.\n  - Alignment: $8$ bytes.\n  - The next available offset after $x$ is $4$.\n  - The offset of $y$ must be a multiple of its alignment, $8$.\n  - The value $4$ is not a multiple of $8$. We must advance the offset to the next multiple of $8$.\n  - The smallest multiple of $8$ that is greater than or equal to $4$ is $8$.\n  - Therefore, we must insert padding between field $x$ and field $y$.\n  - Padding size = Required offset - Current size = $8 - 4 = 4$ bytes.\n  - These $4$ padding bytes occupy offsets $4$ through $7$.\n  - **Offset of $y$ is $8$.**\n  - $y$ occupies bytes $8$ through $15$.\n  - The current size of the record is now (offset of $y$ + size of $y$) = $8 + 8 = 16$ bytes.\n\n- **Field $z$ ($\\mathrm{int64}$):**\n  - Size: $8$ bytes.\n  - Alignment: $8$ bytes.\n  - The next available offset after $y$ is $16$.\n  - The offset of $z$ must be a multiple of its alignment, $8$.\n  - Since $16$ is a multiple of $8$ (i.e., $16 = 2 \\times 8$), this position is valid without any additional padding.\n  - **Offset of $z$ is $16$.**\n  - $z$ occupies bytes $16$ through $23$.\n  - The current size of the record is now (offset of $z$ + size of $z$) = $16 + 8 = 24$ bytes.\n\n**3. Determine the Final Record Size**\nThe total size of the record must be a multiple of its alignment ($8$ bytes). This is to ensure that in an array of such records, each record starts at a properly aligned address.\n\n- The size of the record after laying out all fields is $24$ bytes.\n- The record alignment is $8$ bytes.\n- We check if the current size is a multiple of the record alignment. $24$ is a multiple of $8$ ($24 = 3 \\times 8$).\n- Since the size is already a multiple of the alignment, no trailing padding is necessary.\n- **The final packed size of the environment record is $24$ bytes.**\n\n**Summary of Results:**\n- Record Alignment: $8$ bytes.\n- Offset of $x$: $0$ bytes.\n- Offset of $y$: $8$ bytes.\n- Offset of $z$: $16$ bytes.\n- Final Record Size: $24$ bytes.\n\nThe problem asks for the four integer values: the offsets for $(x, y, z)$ and the final record size. These are $0, 8, 16, 24$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 0 & 8 & 16 & 24 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Beyond static structure, the true power and complexity of closures emerge from their dynamic behavior at runtime. This exercise challenges you to trace the execution of a program where closures interact with shared, mutable state and variable aliasing. Successfully predicting the final program state requires a deep understanding of how an environment pointer connects a function to its lexical scope, even as that scope evolves .",
            "id": "3658728",
            "problem": "Consider a statically scoped, call-by-value language with first-class anonymous functions denoted by $\\lambda$, lexical environments, and mutable bindings. The compiler performs closure conversion by synthesizing an explicit heap-allocated environment record for each closure, consisting of references (pointers) to boxes for captured mutable variables and direct values for captured immutable variables. The semantics are:\n\n- All mutable variables are represented as heap-allocated boxes; assignment $v := e$ writes into the box for $v$.\n- A closure consists of a code pointer plus an environment pointer; the environment stores captured free variables. If a captured variable is mutable, the environment holds a pointer to its box. If it is immutable, the environment holds its value directly.\n- Aliasing means two names refer to the same mutable box. Aliasing is created in the outer scope by binding a second name to the pointer of an existing variable’s box; thus mutating either name mutates the same underlying box.\n\nYou are given the following program fragment in an outer scope:\n- Initialize $x := 1$ and $y := 0$ as mutable bindings (each bound to its own box).\n- Create an alias $u$ to $x$ by binding $u$ to the same box as $x$ (i.e., $u$ and $x$ share the same mutable cell).\n- Define a nested function generator\n  $$\\text{make} \\equiv \\lambda a.\\; \\lambda b.\\; \\big( x := x + a + b;\\; y := y + x \\big).$$\n  The inner $\\lambda$ closes over $x$, $y$, and $a$.\n- Execute the following sequence:\n  1. Bind $h := \\text{make}(2)$.\n  2. Call $h(3)$.\n  3. Perform the outer-scope mutation $u := u + 4$.\n  4. Call $h(1)$.\n  5. Bind $k := \\text{make}(1)$.\n  6. Call $k(2)$.\n\nTasks:\n- Using only the fundamental definitions of lexical scoping, free versus bound variables, and the closure conversion rule given above, derive the environment structure that the compiler synthesizes for the closures returned by $\\text{make}$, explicitly identifying which fields are pointers to boxes and which are immediate values. Explain how the aliasing of $x$ in the outer scope via $u$ interacts with these environments at runtime.\n- Compute the final value stored in the box for $x$ after the entire sequence completes. Provide this final value as your single numerical answer. No rounding is required; report the exact integer.",
            "solution": "The problem is well-posed and scientifically grounded within the principles of compiler design and programming language semantics. It provides a clear, self-contained set of rules for scoping, mutability, and closure conversion, along with a deterministic sequence of operations. The problem is therefore deemed valid and a solution can be formulated.\n\nThe solution is divided into two parts as requested: first, an analysis of the closure environment structure, and second, a step-by-step trace of the program's execution to determine the final value of the variable $x$.\n\n**Part 1: Closure Environment Structure**\n\nThe problem defines a function generator, $\\text{make}$:\n$$ \\text{make} \\equiv \\lambda a.\\; \\lambda b.\\; \\big( x := x + a + b;\\; y := y + x \\big) $$\nThe `make` function takes a parameter $a$ and returns an anonymous inner function. Let us denote this inner function as $f_{\\text{inner}} = \\lambda b.\\; \\big( \\dots \\big)$. To determine the structure of the closure for $f_{\\text{inner}}$, we must identify its free variables according to the rules of lexical scoping.\n\nThe body of $f_{\\text{inner}}$ uses the variables $x$, $y$, $a$, and $b$.\n- The variable $b$ is a parameter to $f_{\\text{inner}}$, so it is a bound variable within $f_{\\text{inner}}$. It is not part of the closure's captured environment; its value is supplied at call time.\n- The variables $x$, $y$, and $a$ are not bound within $f_{\\text{inner}}$ (i.e., they are not its parameters or locally defined variables). Therefore, they are free variables.\n\nUnder lexical scoping, these free variables are captured from the environment in which $f_{\\text{inner}}$ is defined. This definition occurs within the body of the `make` function.\n- $a$ is a parameter to `make`. Following standard functional language conventions, function parameters are immutable bindings.\n- $x$ and $y$ are defined in the outer scope, outside of `make`. The problem statement specifies they are mutable variables.\n\nThe problem provides explicit rules for closure conversion:\n1.  Captured mutable variables are stored in the environment as pointers to their heap-allocated boxes.\n2.  Captured immutable variables are stored in the environment as direct values.\n\nApplying these rules to the free variables of $f_{\\text{inner}}$:\n- $x$ is mutable, so the closure's environment will contain a pointer to the heap-allocated box for $x$.\n- $y$ is mutable, so the environment will contain a pointer to the heap-allocated box for $y$.\n- $a$ is the immutable parameter of `make`, so the environment will contain the value of $a$ that was passed to `make` when the closure was created.\n\nTherefore, the compiler synthesizes an environment record for each closure returned by `make` with the following structure:\n- A field for $x$, containing a pointer to the shared, heap-allocated box for the variable $x$.\n- A field for $y$, containing a pointer to the shared, heap-allocated box for the variable $y$.\n- A field for $a$, containing the immediate integer value passed to `make`.\n\nThe aliasing of $x$ by $u$ in the outer scope means that both names, $x$ and $u$, are bound to pointers that reference the exact same heap-allocated box. Any closure created by `make` will capture a pointer to this very same box. Consequently, any assignment to $x$ within a closure, or any assignment to $x$ in the outer scope, or any assignment to the alias $u$ in the outer scope will all modify the contents of this single, shared box. All three access paths ($x$, $u$, and the captured reference in any closure) are aliased to the same mutable memory location.\n\n**Part 2: Execution Trace**\n\nWe trace the values stored in the heap-allocated boxes for $x$ and $y$. Let us denote the value in the box for $x$ as $\\text{val}(x)$ and for $y$ as $\\text{val}(y)$.\n\n**Initial State:**\n- A box for $x$ is created and initialized: $\\text{val}(x) = 1$.\n- A box for $y$ is created and initialized: $\\text{val}(y) = 0$.\n- The name $u$ is set to be an alias for $x$, pointing to the same box.\n\n**1. `h := make(2)`**\n- The `make` function is called with $a = 2$.\n- It returns a new closure, which we name $h$.\n- The environment for $h$, let's call it $E_h$, is created.\n  - $E_h$ captures a pointer to the box of $x$.\n  - $E_h$ captures a pointer to the box of $y$.\n  - $E_h$ captures the value of $a$, which is $2$.\n- The state of the boxes is unchanged: $\\text{val}(x) = 1$, $\\text{val}(y) = 0$.\n\n**2. `h(3)`**\n- The closure $h$ is called with $b = 3$.\n- The body `x := x + a + b; y := y + x` is executed using environment $E_h$.\n- First statement: `x := x + a + b`.\n  - Read $\\text{val}(x) = 1$.\n  - Read $a$ from $E_h$, which is $2$.\n  - Parameter $b$ is $3$.\n  - The new value for $x$ is $1 + 2 + 3 = 6$. This is written to the box for $x$.\n  - State becomes: $\\text{val}(x) = 6$, $\\text{val}(y) = 0$.\n- Second statement: `y := y + x`.\n  - Read $\\text{val}(y) = 0$.\n  - Read the *new* value of $\\text{val}(x) = 6$.\n  - The new value for $y$ is $0 + 6 = 6$. This is written to the box for $y$.\n  - State becomes: $\\text{val}(x) = 6$, $\\textval}(y) = 6$.\n\n**3. `u := u + 4`**\n- This assignment occurs in the outer scope.\n- Since $u$ is an alias for $x$, it refers to the same box.\n- Read $\\text{val}(u)$, which is $\\text{val}(x) = 6$.\n- The new value is $6 + 4 = 10$. This is written to the box for $x$ (via the alias $u$).\n- State becomes: $\\text{val}(x) = 10$, $\\text{val}(y) = 6$.\n\n**4. `h(1)`**\n- The same closure $h$ is called again, this time with $b = 1$.\n- It uses the same environment $E_h$, where the captured value of $a$ is still $2$.\n- First statement: `x := x + a + b`.\n  - Read $\\text{val}(x) = 10$.\n  - Read $a$ from $E_h$, which is $2$.\n  - Parameter $b$ is $1$.\n  - The new value for $x$ is $10 + 2 + 1 = 13$.\n  - State becomes: $\\text{val}(x) = 13$, $\\text{val}(y) = 6$.\n- Second statement: `y := y + x`.\n  - Read $\\text{val}(y) = 6$.\n  - Read the new value $\\text{val}(x) = 13$.\n  - The new value for $y$ is $6 + 13 = 19$.\n  - State becomes: $\\text{val}(x) = 13$, $\\text{val}(y) = 19$.\n\n**5. `k := make(1)`**\n- The `make` function is called with $a = 1$.\n- It returns a *new* closure, which we name $k$.\n- A new environment $E_k$ is created for $k$.\n  - $E_k$ captures a pointer to the *same* box of $x$.\n  - $E_k$ captures a pointer to the *same* box of $y$.\n  - $E_k$ captures the value of $a$, which is $1$.\n- The state of the boxes is unchanged: $\\text{val}(x) = 13$, $\\text{val}(y) = 19$.\n\n**6. `k(2)`**\n- The closure $k$ is called with $b = 2$.\n- It executes using environment $E_k$.\n- First statement: `x := x + a + b`.\n  - Read $\\text{val}(x) = 13$.\n  - Read $a$ from $E_k$, which is $1$.\n  - Parameter $b$ is $2$.\n  - The new value for $x$ is $13 + 1 + 2 = 16$.\n  - State becomes: $\\text{val}(x) = 16$, $\\text{val}(y) = 19$.\n- Second statement: `y := y + x`.\n  - Read $\\text{val}(y) = 19$.\n  - Read the new value $\\text{val}(x) = 16$.\n  - The new value for $y$ is $19 + 16 = 35$.\n  - State becomes: $\\text{val}(x) = 16$, $\\text{val}(y) = 35$.\n\nThe execution sequence is complete. The final value stored in the box for $x$ is $16$.",
            "answer": "$$ \\boxed{16} $$"
        },
        {
            "introduction": "A compiler's choice of capture semantics—whether by-value or by-reference—fundamentally alters a program's behavior, a distinction famously demonstrated by capturing variables within loops. This practice explores this critical design choice by having you analyze the same code under both capture models. By deriving the final outcomes, you will gain a firm grasp on why this semantic detail is so important and how it impacts the logic of higher-order functions .",
            "id": "3653501",
            "problem": "Consider the following high-level program fragment that builds an array of closures inside a loop and then invokes them after the loop terminates. Let $N$ be a positive integer.\n\nProgram description:\n- Initialize an empty array $A$.\n- For each integer $i$ from $1$ to $N$ do:\n  - Let $m = 2 i$.\n  - Append to $A$ the closure $g(x) = 3 x + i + m$.\n- After the loop terminates, invoke the $k$-th closure in $A$ with the argument $x = k$ for each $k$ from $1$ to $N$.\n\nAssume lexical scoping and standard closure conversion, and adopt these core definitions:\n- Under capture-by-value for a variable $v$, the closure stores a copy of the current value of $v$ at the time of closure creation.\n- Under capture-by-reference for a variable $v$, the closure stores a pointer to a location (an environment cell) that holds the value of $v$, so that future changes to $v$ are visible to all closures that reference this location.\n\nAssume the conventional translation of the loop induction variable into an environment cell when captured by reference, so that all closures created within the loop that capture $i$ by reference share a single heap-allocated cell for $i$. The loop increments this cell on each iteration; after the loop terminates, the cell holds $N+1$. The variable $m$ is a fresh per-iteration local that is captured by value.\n\nDefine $S_{\\text{val}}$ to be the sum of the values returned by the invocations when $i$ is captured by value, and define $S_{\\text{ref}}$ to be the sum of the values returned by the invocations when $i$ is captured by reference (with a single shared cell for $i$ across all closures, as above). Let\n$$\nD \\equiv S_{\\text{val}} - S_{\\text{ref}}.\n$$\n\nUsing only the definitions above and the semantics of lexical scoping and closure conversion, derive a closed-form expression for $D$ as a function of $N$. Give your final answer as a single closed-form analytic expression in terms of $N$. No rounding is required and no units are involved.",
            "solution": "The user wants me to solve the problem.\n\n### Step 1: Extract Givens\n- A positive integer $N$.\n- An array $A$, initially empty.\n- A loop: `for i from 1 to N`.\n- Inside the loop:\n    - A local variable $m$ is defined as $m=2i$.\n    - A closure $g(x) = 3x + i + m$ is appended to $A$.\n- After the loop: For each integer $k$ from $1$ to $N$, the $k$-th closure in $A$ is invoked with argument $x=k$.\n- Definition of capture-by-value for a variable $v$: The closure stores a copy of the current value of $v$ at the time of closure creation.\n- Definition of capture-by-reference for a variable $v$: The closure stores a pointer to the location of $v$.\n- Semantic rule for loop variable $i$ under capture-by-reference: All closures share a single heap-allocated cell for $i$. After the loop terminates, this cell holds the value $N+1$.\n- Semantic rule for local variable $m$: It is a fresh per-iteration local that is captured by value.\n- $S_{\\text{val}}$ is the sum of results when $i$ is captured by value.\n- $S_{\\text{ref}}$ is the sum of results when $i$ is captured by reference.\n- $D \\equiv S_{\\text{val}} - S_{\\text{ref}}$.\n- The objective is to find a closed-form expression for $D$ in terms of $N$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is grounded in the principles of compiler design and programming language semantics. The concepts of lexical scoping, closures, and capture mechanisms (by-value, by-reference) are fundamental and well-defined in computer science.\n- **Well-Posed**: The problem is well-posed. It provides all necessary definitions and constraints to determine a unique analytical solution for $D$ as a function of $N$.\n- **Objective**: The problem is stated using precise, objective language common in formal computer science.\n- The problem does not violate any of the invalidity criteria. The provided semantics for capture-by-reference of a loop variable, while specific, models a real-world behavior (e.g., JavaScript's `var` in loops prior to ES6's `let`) and is described unambiguously.\n\n### Step 3: Verdict and Action\nThe problem is valid and can be solved.\n\n### Solution Derivation\n\nThe goal is to compute $D = S_{\\text{val}} - S_{\\text{ref}}$. We will first derive expressions for $S_{\\text{val}}$ and $S_{\\text{ref}}$ separately.\n\nThe program creates $N$ closures, one for each iteration of the loop from $i=1$ to $N$. Let's denote the closure created during the $i$-th iteration as $c_i$. The function defined by this closure is $g(x) = 3x+i+m$, where $m=2i$. The key distinction between the two cases lies in how the variable $i$ is captured. The variable $m$ is always captured by value.\n\nAt the $i$-th iteration of the loop (where the loop counter is $i$), the variable $m$ is assigned the value $2i$. Since $m$ is a fresh per-iteration local captured by value, the closure $c_i$ will permanently store the value $2i$ for $m$. The definition of the function within $c_i$ is thus effectively $g(x) = 3x + i_{\\text{captured}} + 2i$.\n\nAfter the loop, the $k$-th closure in the array $A$ (which is $c_k$) is invoked with the argument $x=k$.\n\n**1. Calculation of $S_{\\text{val}}$ (Capture `i` by value)**\n\nIn this scenario, the loop variable $i$ is captured by value. When the closure $c_k$ is created during the $k$-th iteration, it stores a copy of the current value of $i$, which is $k$.\nSo, for the $k$-th closure $c_k$, the value of $i_{\\text{captured}}$ is $k$.\nThe function implemented by $c_k$ is:\n$$g_k(x) = 3x + k + 2k = 3x + 3k$$\nThis closure is then invoked with the argument $x=k$. The returned value is:\n$$g_k(k) = 3k + 3k = 6k$$\n$S_{\\text{val}}$ is the sum of these returned values for $k$ from $1$ to $N$:\n$$S_{\\text{val}} = \\sum_{k=1}^{N} g_k(k) = \\sum_{k=1}^{N} 6k$$\nUsing the formula for the sum of the first $N$ integers, $\\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}$:\n$$S_{\\text{val}} = 6 \\sum_{k=1}^{N} k = 6 \\left( \\frac{N(N+1)}{2} \\right) = 3N(N+1)$$\n\n**2. Calculation of $S_{\\text{ref}}$ (Capture `i` by reference)**\n\nIn this scenario, the loop variable $i$ is captured by reference. All closures, $c_1, c_2, \\dots, c_N$, share a reference to a single memory location for $i$. The problem states that the loop increments the value in this location, and after the loop terminates, the value in this location is $N+1$.\nThe closures are invoked *after* the loop has finished. Therefore, at the time of invocation, a dereference of the shared reference to $i$ will yield the value $N+1$ for every closure.\n\nWhen the closure $c_k$ is created during the $k$-th iteration, it captures a reference to $i$ and captures the value of $m$ at that moment, which is $2k$.\nThe function implemented by $c_k$ is:\n$$g_k(x) = 3x + i_{\\text{ref}} + 2k$$\nwhere $i_{\\text{ref}}$ represents the value obtained by dereferencing the shared pointer to $i$ at the time of invocation.\nThis closure $c_k$ is invoked with argument $x=k$ *after* the loop. At this time, $i_{\\text{ref}} = N+1$. The returned value is:\n$$g_k(k) = 3k + (N+1) + 2k = 5k + N + 1$$\n$S_{\\text{ref}}$ is the sum of these values for $k$ from $1$ to $N$:\n$$S_{\\text{ref}} = \\sum_{k=1}^{N} (5k + N + 1)$$\nWe can split the summation:\n$$S_{\\text{ref}} = \\sum_{k=1}^{N} 5k + \\sum_{k=1}^{N} (N+1)$$\n$$S_{\\text{ref}} = 5 \\left( \\sum_{k=1}^{N} k \\right) + N(N+1)$$\nUsing the sum formula again:\n$$S_{\\text{ref}} = 5 \\left( \\frac{N(N+1)}{2} \\right) + N(N+1)$$\nFactoring out $N(N+1)$:\n$$S_{\\text{ref}} = N(N+1) \\left( \\frac{5}{2} + 1 \\right) = N(N+1) \\left( \\frac{7}{2} \\right) = \\frac{7}{2}N(N+1)$$\n\n**3. Calculation of $D$**\n\nNow we can compute $D = S_{\\textual}} - S_{\\text{ref}}$:\n$$D = 3N(N+1) - \\frac{7}{2}N(N+1)$$\nFactoring out $N(N+1)$:\n$$D = N(N+1) \\left( 3 - \\frac{7}{2} \\right) = N(N+1) \\left( \\frac{6}{2} - \\frac{7}{2} \\right)$$\n$$D = N(N+1) \\left( -\\frac{1}{2} \\right) = -\\frac{N(N+1)}{2}$$\nThis is the final closed-form expression for $D$ as a function of $N$.",
            "answer": "$$\n\\boxed{-\\frac{N(N+1)}{2}}\n$$"
        }
    ]
}