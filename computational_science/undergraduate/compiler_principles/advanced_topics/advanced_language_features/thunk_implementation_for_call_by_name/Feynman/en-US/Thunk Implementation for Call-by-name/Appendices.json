{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp call-by-name, one must be able to trace the flow of demand. This first exercise challenges you to become a human debugger, meticulously tracking each time a thunk is forced within a nested expression . By counting the re-evaluations, you will build a concrete mental model of how this \"evaluate on demand\" strategy unfolds in practice.",
            "id": "3675795",
            "problem": "In the context of compiler principles, consider a first-order, call-by-name evaluation strategy implemented via thunks. A thunk is a deferred computation represented as a closure that captures an expression and its environment and is executed only when its value is demanded (forced). In call-by-name, there is no memoization: each use of a formal parameter re-evaluates the thunk from scratch. Assume a deterministic left-to-right evaluation order for primitive operations: for an addition operator, the left operand is evaluated before the right operand; for a conditional expression, the condition is evaluated before the selected branch; for a lexical binding, a $\\text{let}$ binds by name (non-strict) and the bound expression is not evaluated until the bound name is used.\n\nLet the actual argument be the expression $x_{n} = \\sum_{i=1}^{n} i$, where $n$ is an integer with $n \\geq 1$, and let the formal parameter be $a$. The argument is passed to a function $f$ as a thunk $\\theta_{a}$ that re-evaluates $x_{n}$ every time $a$ is referenced. Instrument the runtime so that each time $\\theta_{a}$ is forced, a global counter $F$ increases by $1$. We ignore any other costs and count only the number of forces of $\\theta_{a}$.\n\nDefine the function $f$ as follows, where $k$ is a nonnegative integer parameter:\n1. The auxiliary replication function is defined by\n$$\\operatorname{rep}_{k}(a) = \\begin{cases}\n0, & \\text{if } k = 0, \\\\\na + \\operatorname{rep}_{k-1}(a), & \\text{if } k > 0,\n\\end{cases}$$\nwith addition evaluated left-to-right.\n2. The function $f$ is defined by\n$$\nf(a, k) = \\text{if } a > 0 \\text{ then } \n\\Big(\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a)\n\\Big)\n\\text{ else } 0.\n$$\n\nUnder the above call-by-name semantics with non-memoizing thunks and $n \\geq 1$, determine a closed-form expression in terms of $k$ for the total number of times $\\theta_{a}$ is forced during the evaluation of $f(a, k)$ when the actual argument is the thunk $\\theta_{a}$ for $x_{n}$. Express your final answer as a single analytic expression. No rounding is required.",
            "solution": "The fundamental basis for this derivation is the definition of call-by-name with thunks: a formal parameter $a$ denotes a thunk $\\theta_{a}$ that, when forced, re-evaluates its associated expression in the captured environment. Under call-by-name without memoization, each syntactic occurrence of $a$ in the executed code results in a separate force of $\\theta_{a}$. We also use the specified left-to-right evaluation order for primitive operations and non-strict $\\text{let}$ bindings that delay evaluation until use.\n\nWe proceed by analyzing the demand-driven forcing behavior of $\\theta_{a}$ in the evaluation of $f(a, k)$, counting how many times $a$ is referenced and thus how many times $\\theta_{a}$ is forced. We assume $n \\geq 1$, so $x_{n} = \\sum_{i=1}^{n} i$ is positive, and hence $a > 0$ holds. Therefore, the $\\text{then}$ branch is taken, and the $\\text{else}$ branch is not evaluated.\n\nStep 1: Evaluate the conditional guard $a > 0$.\n- The condition references $a$ once.\n- This forces $\\theta_{a}$ exactly once.\n- Contribution to $F$: $1$.\n\nStep 2: Enter the $\\text{then}$ branch and process the nested $\\text{let}$ bindings. Because $\\text{let}$ binds by name, the right-hand sides are not evaluated at binding time, but only when their bound names are used.\n\nThe $\\text{then}$ branch body is:\n$$\n\\text{let } b = a + a \\text{ in }\n\\text{let } c = a + b \\text{ in }\n\\text{let } d = b + b \\text{ in }\nc + d + \\operatorname{rep}_{k}(a).\n$$\n\nWe evaluate the final expression $c + d + \\operatorname{rep}_{k}(a)$ from left to right.\n\nStep 2a: Force $c$.\n- $c$ is defined as $a + b$, evaluated left-to-right.\n- First, evaluate $a$ in $a + b$: this forces $\\theta_{a}$ once.\n- Next, evaluate $b$ in $a + b$: this forces $b$.\n- Forcing $b$ evaluates $a + a$, left-to-right:\n  - Evaluate left $a$: forces $\\theta_{a}$ once.\n  - Evaluate right $a$: forces $\\theta_{a}$ once.\n- Total forces of $\\theta_{a}$ due to $c$: $1$ (for the $a$ in $a+b$) $+ 2$ (for the two $a$ in $b$) $= 3$.\n- Contribution to $F$: $3$.\n\nStep 2b: Force $d$.\n- $d$ is defined as $b + b$, evaluated left-to-right.\n- Evaluate the left $b$: forcing $b$ evaluates $a + a$, which forces $\\theta_{a}$ twice (left $a$ and right $a$).\n- Evaluate the right $b$: forcing $b$ again evaluates $a + a$, which forces $\\theta_{a}$ twice more.\n- Total forces of $\\theta_{a}$ due to $d$: $2 + 2 = 4$.\n- Contribution to $F$: $4$.\n\nStep 2c: Force $\\operatorname{rep}_{k}(a)$.\n- The definition is $\\operatorname{rep}_{k}(a) = 0$ if $k=0$, else $a + \\operatorname{rep}_{k-1}(a)$.\n- For $k > 0$, each recursive step evaluates $a$ first (left-to-right addition) and then recurses on $\\operatorname{rep}_{k-1}(a)$.\n- Therefore, for each of the $k$ steps, $a$ is referenced exactly once, and thus $\\theta_{a}$ is forced once per step.\n- Total forces of $\\theta_{a}$ due to $\\operatorname{rep}_{k}(a)$: $k$.\n- Contribution to $F$: $k$.\n\nStep 3: Summation of all contributions.\n- From the conditional guard: $1$.\n- From forcing $c$: $3$.\n- From forcing $d$: $4$.\n- From forcing $\\operatorname{rep}_{k}(a)$: $k$.\n\nThus, the total number of forces of $\\theta_{a}$ during the evaluation of $f(a, k)$ is\n$$k + 1 + 3 + 4 = k + 8.$$\n\nThis count depends only on the syntactic occurrences and the specified evaluation order; the value $x_{n}$ being positive for $n \\geq 1$ ensures the $\\text{then}$ branch is taken, but no further branching depends on $a$. Therefore, the closed-form expression for the total number of forces is $k + 8$.",
            "answer": "$$\\boxed{k+8}$$"
        },
        {
            "introduction": "Now that we've seen *how* re-evaluation works, this practice explores *why* it is the defining characteristic of call-by-name. We will compare pure re-evaluation with a memoized approach (known as call-by-need) to understand the critical impact of side effects and non-termination on program correctness . This thought experiment reveals the fundamental semantic guarantees that call-by-name provides.",
            "id": "3675807",
            "problem": "In a standard interpreter for a language with lexical scope and first-class procedures, call-by-name (CBN) is implemented by passing a thunk for each actual argument. A thunk is a pair $\\langle e,\\rho\\rangle$, where $e$ is the unevaluated expression and $\\rho$ is the environment mapping free variables of $e$ to locations or values. Forcing a thunk, denoted $\\operatorname{force}(\\langle e,\\rho\\rangle)$, evaluates $e$ under $\\rho$. By definition of call-by-name, the actual argument expression is evaluated each time its corresponding formal parameter is used in the callee body; that is, there is no reuse of a previous evaluation result across uses.\n\nConsider a function application where the callee has two formal parameters and the caller supplies the same actual expression for both, so the callee receives two bindings that alias a single thunk $\\langle e,\\rho\\rangle$. You are evaluating whether the implementation of $\\operatorname{force}$ should recompute $e$ on each invocation or reuse a memoized result stored in the thunk after the first evaluation. Two implementation policies are under consideration:\n- Policy $1$: Never memoize; every call $\\operatorname{force}(\\langle e,\\rho\\rangle)$ re-evaluates $e$ in $\\rho$.\n- Policy $2$: Memoize inside the thunk; the first call to $\\operatorname{force}(\\langle e,\\rho\\rangle)$ evaluates $e$ in $\\rho$ and stores the result in the thunk; subsequent calls return the stored result without reevaluating $e$.\n\nAssume the language may include effects (such as mutation or printing) and may have non-terminating computations. The callee may use each parameter multiple times. The two formal parameters may alias the same thunk object when the caller passes the same expression twice, as in a call syntactically analogous to $f(x,x)$.\n\nWhich of the following statements are correct?\n\nA. Under call-by-name, Policy $1$ is required; even when two formals alias the same thunk $\\langle e,\\rho\\rangle$, each parameter force must recompute $e$ independently. Using Policy $2$ in general changes semantics when $e$ has effects or may diverge.\n\nB. Policy $2$ is observationally equivalent to call-by-name for all programs; memoization can only improve performance and cannot change observable behavior.\n\nC. Because of aliasing, the callee must duplicate the thunk object so that each formal parameter has a distinct thunk; otherwise, even with Policy $1$, forcing via one parameter can incorrectly affect forcing via the other.\n\nD. In a pure setting where $e$ is referentially transparent and terminating, Policies $1$ and $2$ are observationally equivalent for calls of the form $f(e,e)$; sharing a single memoized thunk yields the same results as call-by-name in that setting.",
            "solution": "This problem requires analyzing the semantic differences between two thunk implementation policies in the context of call-by-name (CBN).\n\n1.  **Core Definitions**:\n    *   **Call-by-Name (CBN)**: The defining characteristic is that the argument expression is re-evaluated *every single time* its corresponding parameter is used.\n    *   **Policy 1 (Re-evaluation)**: Implements CBN directly. Every `force` operation re-runs the computation.\n    *   **Policy 2 (Memoization)**: Implements call-by-need. The `force` operation computes the value on the first call and caches it. Subsequent calls return the cached value.\n\n2.  **Analysis of Option A**: This statement claims Policy 1 is required for CBN and that Policy 2 changes the semantics if the expression `e` has side effects or may not terminate. This is correct.\n    *   **Side Effects**: Consider an expression `e` that increments a global counter and returns its new value. In a call like `f(e, e)` where the function body is `param1 + param2`, CBN (Policy 1) would evaluate `e` twice, incrementing the counter twice and potentially using two different values in the sum. Call-by-need (Policy 2) would evaluate `e` only once, incrementing the counter once and using the same value for both parameters. These are different observable behaviors.\n    *   **Non-termination**: If `e` terminates on the first evaluation but would diverge on the second (due to a state change), Policy 1 would cause the program to diverge, while Policy 2 would succeed.\n    Therefore, Policy 2 is not a valid implementation of CBN in the general case, and Policy 1 is the correct definition. **Statement A is correct.**\n\n3.  **Analysis of Option B**: This claims the policies are always observationally equivalent. As demonstrated above with side effects, this is false. They lead to different results and behaviors. **Statement B is incorrect.**\n\n4.  **Analysis of Option C**: This suggests duplicating the thunk to prevent \"incorrect effects\" when parameters alias. This misunderstands CBN. In CBN, the \"effect\" of one force on a subsequent one (e.g., via state change) is part of the defined semantics. If `f(e, e)` is called, both parameters correctly point to the same promise-to-compute-`e`. Forcing one re-evaluates `e`. Forcing the other *also* re-evaluates `e` according to the rules, in whatever state the program is now in. There is no need for duplication; aliasing is handled correctly by the core definition of re-evaluation. **Statement C is incorrect.**\n\n5.  **Analysis of Option D**: This considers the special case where `e` is pure (referentially transparent) and always terminates. In this case, re-evaluating `e` is guaranteed to produce the exact same value as the first evaluation. Therefore, the result of re-evaluating (Policy 1) is indistinguishable from returning a cached value (Policy 2). The two policies are observationally equivalent in this restricted, pure setting. **Statement D is correct.**\n\nBased on this analysis, statements A and D are correct.",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "Building on semantic and mechanical understanding, we now turn to performance. This practice places you in the role of a compiler designer, armed with a formal cost model to analyze a real-world trade-off . You will calculate the execution cost of a function under pure call-by-name and compare it to an optimized strategy involving memoization, learning how to make data-driven decisions about when to avoid the expense of recomputation.",
            "id": "3675854",
            "problem": "A compiler for a strict first-order arithmetic language implements call-by-name via thunks. A thunk is a closure that stores an unevaluated argument expression and its environment. Forcing a thunk triggers evaluation of that expression in the captured environment. Under pure call-by-name, each force re-evaluates the expression. Consider the function body $f(x,y) = x + y + x$ and assume that addition is a strict primitive operator in both operands.\n\nAssume the following cost model, where all costs are additive:\n- Forcing any thunk once incurs a fixed overhead cost $h$.\n- Evaluating the expression for $x$ (exclusive of thunk overhead) costs $c_{x}$.\n- Evaluating the expression for $y$ (exclusive of thunk overhead) costs $c_{y}$.\n- Each primitive addition $+$ costs $a$.\n- As an optional transformation, the compiler may introduce a local binding to share the value of $x$ across its multiple uses (simulating call-by-need for $x$ only): allocate a cell once at cost $m$, store the result of the first evaluation once at cost $s$, and satisfy each subsequent use of $x$ from the cell at cost $r$ without re-evaluating the $x$ expression. The first use of $x$ still forces and evaluates the thunk, incurring $h + c_{x}$.\n\nStarting from the basic definitions of call-by-name thunks and strict evaluation of $+$, do the following reasoning:\n- Determine the dynamic force multiplier for each of the arguments $x$ and $y$ in the body $f(x,y) = x + y + x$.\n- Derive, from first principles of the cost model and the determined multipliers, the total execution cost for evaluating $f(x,y)$ under pure call-by-name (no sharing).\n- Derive the total execution cost if the compiler applies the sharing transformation to $x$ only (do not share $y$).\n- Discuss whether reordering the summands using associativity and commutativity (for example, $(x + x) + y$ or $y + x + x$) changes the total cost under either regime, and choose the plan (pure call-by-name vs. sharing $x$) and ordering that minimizes the total cost.\n- Using the parameter values $h = 3$, $c_{x} = 40$, $c_{y} = 10$, $a = 1$, $m = 2$, $s = 1$, and $r = 1$, compute the minimal total cost for evaluating $f(x,y)$ under the optimal plan and ordering.\n\nExpress your final answer as a single real-valued number with no units. No rounding is required.",
            "solution": "**1. Dynamic Force Multipliers**\nThe function body is $f(x,y) = x + y + x$. Assuming standard left-to-right associativity for the $+$ operator, this expression is evaluated as $(x+y)+x$. The $+$ operator is strict, meaning it must evaluate both of its operands to produce a result.\n- To evaluate the outer $+$, the runtime system must first evaluate its left operand, $(x+y)$, and its right operand, $x$.\n- To evaluate the sub-expression $(x+y)$, the runtime must evaluate its operands, $x$ and $y$. This requires forcing the thunk for $x$ (first time) and forcing the thunk for $y$ (first time).\n- After the value of $(x+y)$ is computed, the evaluation of the main expression continues. The runtime now evaluates the right operand of the outer $+$, which is $x$. This requires forcing the thunk for $x$ a second time.\nTherefore, the dynamic force multiplier for $x$ is $2$, and for $y$ is $1$.\n\n**2. Total Cost under Pure Call-by-Name (CBN)**\nUnder a pure call-by-name regime, each time an argument's thunk is forced, its corresponding expression is re-evaluated.\nThe cost of one evaluation of $x$ is the sum of the thunk overhead $h$ and the expression evaluation cost $c_x$, totaling $h+c_x$.\nThe cost of one evaluation of $y$ is $h+c_y$.\nThe expression has two addition operations, contributing a total cost of $2a$.\nThe total cost, $C_{CBN}$, is the sum of the costs for two evaluations of $x$, one evaluation of $y$, and two additions.\n$$C_{CBN} = 2(h + c_x) + 1(h + c_y) + 2a$$\n$$C_{CBN} = 2h + 2c_x + h + c_y + 2a = 3h + 2c_x + c_y + 2a$$\n\n**3. Total Cost with Sharing Transformation for $x$**\nWith this transformation, the value of $x$ is computed once and stored.\n- A one-time cost $m$ is incurred to allocate a cell for $x$'s value.\n- The first time $x$ is needed, its thunk is forced (cost $h$), its expression is evaluated (cost $c_x$), and the result is stored (cost $s$). The cost of this first use is $h + c_x + s$.\n- The second (and any subsequent) time $x$ is needed, its value is retrieved from the cell at cost $r$.\n- The argument $y$ is not shared, so its single use costs $h+c_y$.\n- The two additions still contribute $2a$.\nThe total cost, $C_{share-x}$, is the sum of these individual costs.\n$$C_{share-x} = m + (h+c_x+s) + r + (h+c_y) + 2a$$\n$$C_{share-x} = m + s + r + 2h + c_x + c_y + 2a$$\n\n**4. Optimal Plan and Ordering**\nThe problem asks to consider reordering the summands, for example to $(x+x)+y$. Since addition is strict, the total number of times each operand must be evaluated is determined by its number of occurrences in the expression, regardless of the grouping. In $x+y+x$, $x$ appears twice and $y$ appears once. Any reordering, such as $(x+x)+y$ or $y+(x+x)$, preserves this count. Thus, the total cost for both the pure CBN and the sharing regimes is independent of the evaluation order. The ordering is therefore not a factor in the minimal cost.\n\nThe optimal plan is found by comparing $C_{CBN}$ and $C_{share-x}$. The sharing plan is better if $C_{share-x} < C_{CBN}$.\n$$m + s + r + 2h + c_x + c_y + 2a < 3h + 2c_x + c_y + 2a$$\nBy subtracting common terms ($2h + c_x + c_y + 2a$) from both sides, we simplify the inequality to:\n$$m + s + r < h + c_x$$\nThis inequality states that sharing is advantageous if the total overhead of sharing ($m+s+r$) is less than the cost of the re-evaluation it saves ($h+c_x$).\n\n**5. Minimal Total Cost Calculation**\nWe use the given parameter values: $h=3$, $c_x=40$, $c_y=10$, $a=1$, $m=2$, $s=1$, $r=1$.\nFirst, we check the condition to determine the optimal plan:\n$$m + s + r < h + c_x$$\n$$2 + 1 + 1 < 3 + 40$$\n$$4 < 43$$\nThe condition holds, so the optimal plan is to use the sharing transformation for $x$. The minimal cost is $C_{share-x}$.\nWe now compute this cost:\n$$C_{share-x} = m + s + r + 2h + c_x + c_y + 2a$$\n$$C_{share-x} = 2 + 1 + 1 + 2(3) + 40 + 10 + 2(1)$$\n$$C_{share-x} = 4 + 6 + 40 + 10 + 2$$\n$$C_{share-x} = 62$$\nFor completeness, the cost under pure CBN would be:\n$$C_{CBN} = 3h + 2c_x + c_y + 2a = 3(3) + 2(40) + 10 + 2(1) = 9 + 80 + 10 + 2 = 101$$\nAs expected, $62 < 101$. The minimal cost is $62$.",
            "answer": "$$\\boxed{62}$$"
        }
    ]
}