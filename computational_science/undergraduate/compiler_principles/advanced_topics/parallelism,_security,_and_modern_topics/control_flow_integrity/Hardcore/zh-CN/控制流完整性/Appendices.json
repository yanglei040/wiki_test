{
    "hands_on_practices": [
        {
            "introduction": "控制流完整性（CFI）的有效性在很大程度上取决于静态确定的目标集的精确度。此练习旨在阐明，编译器优化（如部分求值和常量传播）可以在强制执行CFI策略之前显著收紧此目标集，从而增强安全性。通过本练习，你将通过量化计算来理解编译器优化如何直接提升CFI的精度，具体方法是计算因优化而减少的允许控制流路径的数量。",
            "id": "3632876",
            "problem": "编译器在间接调用点强制执行控制流完整性 (Control Flow Integrity, CFI)，要求动态目标属于静态计算出的目标集 $T$。考虑一个程序，其中间接调用的目标由一个表驱动的分派器选择，该分派器通过一个三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 进行索引。计算 $T$ 的静态分析基于以下保守但一致的事实，这些事实在任何特化之前都成立：\n- 有 $N$ 种不同的运行时类型可能到达该调用点。\n- 对于每种运行时类型，静态分析认为在该调用点恰好有 $u$ 个操作可以安全地与该类型配对。\n- 对于每个安全的 $(\\text{type}, \\text{op})$ 对，恰好有 $v$ 种模式被认为是安全的。\n\n所有量 $N$、$u$ 和 $v$ 都是正整数。假设安全判断在上述意义上对于不同类型和操作是一致的。\n\n现在假设编译器在计算用于强制执行的 $T$ 之前执行了部分求值 (Partial Evaluation, PE) 和常量传播。以下编译时事实变得已知：\n- 到达该调用点的运行时类型是单一的已知常量类型。\n- 一个全局配置常量强制分派器将每对安全 $(\\text{type}, \\text{op})$ 的模式限制为一个大小为 $v_{s}$ 的子集，其中 $v_{s}$ 是一个正整数且 $v_{s} \\leq v$。\n- 之前的一个特化步骤用一个常量替换了一个数据相关的操作过滤器，将已知类型的安全操作集限制为一个大小为 $w$ 的子集，其中 $w$ 是一个正整数且 $w \\leq u$。\n\n在这些假设下，仅使用有限集的基本计数原理，将CFI目标集建模为在相应分析后仍然可行的所有处理程序条目的集合。使用第一性原理（CFI的定义即为将动态目标限制在一个静态确定的有限集合内，部分求值的定义即为针对已知常量的特化，以及独立有限选择的基数乘法法则），推导出一个目标集大小绝对减少量的闭式符号表达式，\n$$\\Delta \\;=\\; \\lvert T \\rvert \\;-\\; \\lvert T' \\rvert,$$\n其中 $T$ 是在特化前计算的，$T'$ 是在特化后计算的。用 $N$、$u$、$v$、$w$ 和 $v_{s}$ 将你的最终答案表示为单个解析表达式。",
            "solution": "在尝试给出解答之前，对问题陈述进行了严格验证。\n\n### 步骤1：提取已知条件\n- 控制流完整性（CFI）目标集用 $T$ 表示。\n- 间接调用的目标由一个三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 选择。\n- 在特化之前，计算 $T$ 时以下事实成立：\n    - 不同运行时类型的数量为 $N$。\n    - 对于每种类型，安全操作的数量为 $u$。\n    - 对于每个安全的 $(\\text{type}, \\text{op})$ 对，安全模式的数量为 $v$。\n- 所有量 $N$、$u$ 和 $v$ 都是正整数。\n- 在部分求值（PE）和常量传播之后，根据以下编译时事实计算出一个新的目标集 $T'$：\n    - 到达的运行时类型的数量为 $1$。\n    - 对于已知类型，安全操作的数量是一个大小为 $w$ 的子集，其中 $w$ 是一个正整数且 $w \\leq u$。\n    - 对于每个安全的 $(\\text{type}, \\text{op})$ 对，安全模式的数量是一个大小为 $v_{s}$ 的子集，其中 $v_{s}$ 是一个正整数且 $v_{s} \\leq v$。\n- 目标是推导目标集大小绝对减少量的闭式符号表达式 $\\Delta = |T| - |T'|$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据：** 该问题牢固地植根于编译器设计和计算机安全的原理。控制流完整性（CFI）、静态分析、部分求值（PE）和常量传播等概念是计算机科学中标准且明确定义的主题。该问题模拟了一个编译器优化提炼静态分析结果的常见场景，这是一个科学上合理的前提。\n- **良构性（Well-Posed）：** 该问题提供了所有必要的变量（$N, u, v, w, v_s$）和关系，以唯一确定集合 $T$ 和 $T'$ 的大小。目标明确陈述为求其基数之差 $\\Delta$。约束条件 $w \\leq u$ 和 $v_s \\leq v$ 确保特化后的集合是该选择所允许集合的子集，这在逻辑上是合理的。存在一个唯一的、有意义的解。\n- **客观性：** 语言正式而精确，使用了编译器领域的既定术语。没有主观或含糊不清的陈述。\n\n该问题未表现出任何已定义的不成立缺陷。它是一个基于既定科学原理的、结构良好、可形式化的问题。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将推导解答。\n\n### 解答推导\n\n问题的核心是确定两个目标集 $T$（特化前）和 $T'$（特化后）的基数，然后计算它们的差。问题陈述指出，目标由一个三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 索引。因此，有效目标的总数是可以形成的唯一有效三元组的总数。我们将使用计数的基本乘法法则，该法则指出，如果一个过程可以分解为一系列独立的选择，那么结果的总数是每个阶段选项数量的乘积。\n\n首先，我们计算在进行任何特化之前初始目标集的大小 $|T|$。\n1.  `type` 的选择可以是可能到达该调用点的 $N$ 个不同运行时类型中的任意一个。因此，三元组的第一个元素有 $N$ 个选项。\n2.  对于这 $N$ 种类型中的每一种，静态分析都认为恰好有 $u$ 个操作是安全的。因此，对于任何给定的 `type` 选择，`op` 有 $u$ 个选项。\n3.  对于每个安全的 $(\\text{type}, \\text{op})$ 对，恰好有 $v$ 种安全模式。因此，对于三元组前两个元素的任何给定选择，`mode` 有 $v$ 个选项。\n\n由于这些选择是独立的，有效三元组 $(\\text{type}, \\text{op}, \\text{mode})$ 的总数是每个阶段选项数量的乘积。\n$$|T| = N \\times u \\times v$$\n\n接下来，我们计算在应用部分求值和其他优化之后，特化目标集 $|T'|$ 的大小。\n1.  编译器确定到达的运行时类型是单个已知常量。这将 `type` 的选项数量从 $N$ 减少到 $1$。\n2.  对于这个单一的已知类型，一个特化步骤已将安全操作集限制为大小为 $w$ 的子集。因此，现在 `op` 有 $w$ 个选项。\n3.  一个全局配置常量将每个安全 $(\\text{type}, \\text{op})$ 对允许的模式数量限制为大小为 $v_s$ 的子集。这意味着对于我们单一的已知类型及其 $w$ 个安全操作中的任何一个，`mode` 都有 $v_s$ 个选项。\n\n再次对特化情况应用乘法法则：\n$$|T'| = 1 \\times w \\times v_s = w v_s$$\n\n问题要求目标集大小的绝对减少量，即 $\\Delta = |T| - |T'|$。代入我们推导出的 $|T|$ 和 $|T'|$ 的表达式：\n$$\\Delta = (Nuv) - (wv_s)$$\n\n这个表达式代表了被编译器的特化和常量传播优化所剪除的控制流路径的总数。它是关于给定参数 $N$、$u$、$v$、$w$ 和 $v_{s}$ 的一个闭式符号表达式。",
            "answer": "$$\\boxed{Nuv - w v_{s}}$$"
        },
        {
            "introduction": "保护间接跳转是CFI的一项核心任务，一个常见的例子是保护由跳转表实现的 `switch` 语句。静态分析，特别是区间算术，能够在编译时推断出跳转表索引的可能取值范围。本实践将指导你如何为一个索引表达式推导出最精确的安全边界检查，从而学习实施一个既安全（阻止越界跳转）又正确（允许所有合法跳转）的CFI防护机制，将抽象的分析技术应用于具体的编译器安全任务中。",
            "id": "3632863",
            "problem": "编译器将一个结构化多分支语句降级为一个由整数表达式索引的跳转表。在控制流完整性 (Control Flow Integrity, CFI) 约束下，每个间接分支都必须被插桩，以确保其跳转目标只能是静态确定的有效基本块集合中的一个。考虑一个针对整数 case 的结构化 switch 语句，编译器已将其布局为一个覆盖 case 标签 $0, 1, \\dots, 20$ 的连续跳转表和一个单独的 default 块。用于对该表进行寻址的索引是根据程序变量 $x$ 和 $y$ 计算得出的，公式如下：\n$$\nj \\;=\\; \\left(\\left\\lfloor \\frac{3x - 2y + 7}{2} \\right\\rfloor \\right) \\bmod 64,\n$$\n其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数，模运算产生 $\\{0,1,\\dots,63\\}$ 中的非负余数。一项静态范围分析确定了在 switch 语句所在的程序点，输入变量的范围为 $x \\in [-4,12]$ 和 $y \\in [1,9]$。\n\n你需要为使用跳转表的 switch 语句提出一种符合 CFI 的插桩方法，该方法在执行间接跳转之前，对计算出的索引进行单一边界检查。请使用区间算术以及整数向下取整和模运算的明确定义语义，推导出最紧的常量上界 $U$。插入一个形式为“仅当 $j  U$ 时执行间接跳转，否则跳转到 default 块”的守卫，必须能保证对于所有 $x \\in [-4,12]$ 和 $y \\in [1,9]$，间接跳转只能跳转到表项 $0$ 到 $20$。\n\n请提供满足条件的最小常量 $U$ 作为最终答案。无需四舍五入。",
            "solution": "目标是为一个形式为 $j  U$ 的安全检查确定最小整数常量 $U$。该检查必须保证任何由 $j$ 索引的间接跳转只跳转到跳转表的有效表项，这些有效表项被指定为 $\\{0, 1, \\dots, 20\\}$。该检查还必须是正确的，即它必须允许所有有效且可达的跳转目标。索引 $j$ 是根据已知范围的程序变量 $x$ 和 $y$ 计算得出的。\n\n索引 $j$ 由以下表达式给出：\n$$\nj = \\left(\\left\\lfloor \\frac{3x - 2y + 7}{2} \\right\\rfloor \\right) \\bmod 64\n$$\n静态分析提供的变量 $x$ 和 $y$ 的范围是 $x \\in [-4, 12]$ 和 $y \\in [1, 9]$。我们假设 $x$ 和 $y$ 可以是这些闭区间内的任何实数。模运算被定义为产生 $\\{0, 1, \\dots, 63\\}$ 中的一个非负余数。\n\n首先，我们必须通过对表达式应用区间算术来确定 $j$ 的所有可能值的集合。设向下取整函数的参数为 $V$：\n$$\nV = \\frac{3x - 2y + 7}{2}\n$$\n我们推导分子 $3x - 2y + 7$ 的区间：\n1.  项 $3x$：因为 $x \\in [-4, 12]$，乘以 $3$ 得到 $3x \\in [3 \\times (-4), 3 \\times 12] = [-12, 36]$。\n2.  项 $-2y$：因为 $y \\in [1, 9]$，所以 $2y \\in [2, 18]$。对该区间取反得到 $-2y \\in [-18, -2]$。\n3.  将 $3x$、$ -2y$ 和常量 $7$ 的区间相加：\n    下界是 $-12 + (-18) + 7 = -23$。\n    上界是 $36 + (-2) + 7 = 41$。\n    因此，$3x - 2y + 7 \\in [-23, 41]$。\n\n现在，我们通过除以 $2$ 来找到 $V$ 的区间：\n$$\nV \\in \\left[\\frac{-23}{2}, \\frac{41}{2}\\right] = [-11.5, 20.5]\n$$\n\n令 $k = \\lfloor V \\rfloor = \\lfloor \\frac{3x - 2y + 7}{2} \\rfloor$。由于向下取整函数是非递减的，我们可以通过对 $V$ 的区间端点取整来找到 $k$ 的范围。\n$k$ 的最小值为 $\\lfloor -11.5 \\rfloor = -12$。\n$k$ 的最大值为 $\\lfloor 20.5 \\rfloor = 20$。\n$V$ 的区间是连续的，宽度为 $20.5 - (-11.5) = 32$，大于 $1$。因此，$k$ 可以取其最小值和最大值之间的任何整数值。\n所以，$k$ 的可能值集合为 $\\{-12, -11, \\dots, 19, 20\\}$。\n\n接下来，我们计算最终索引 $j = k \\bmod 64$。我们分两种情况来分析 $k$ 的值：\n1.  对于非负的 $k$，其中 $k \\in \\{0, 1, \\dots, 20\\}$：\n    在此范围内，$j = k \\bmod 64 = k$。\n    因此，$k$ 的这个范围部分产生的索引集合为 $\\{0, 1, \\dots, 20\\}$。这些都是有效的跳转目标。\n2.  对于负的 $k$，其中 $k \\in \\{-12, -11, \\dots, -1\\}$：\n    题目规定模运算产生非负余数。这对应于数学定义 $a \\bmod n = a - n \\lfloor a/n \\rfloor$。对于负数 $a$ 和正数 $n$，这通常等价于 $a + m \\cdot n$ 直到结果为非负。例如，在许多语言中，对于 $k=-12$，$j = -12 \\bmod 64 = 52$。\n    对于 $k = -1$，$j = -1 \\bmod 64 = 63$。\n    对于 $k = -2$，$j = -2 \\bmod 64 = 62$。\n    ...\n    对于 $k = -12$，$j = -12 \\bmod 64 = 52$。\n    因此，$k$ 的这个范围部分产生的索引集合为 $\\{52, 53, \\dots, 63\\}$。这些都是无效的跳转目标，因为它们位于有效范围 $\\{0, 1, \\dots, 20\\}$ 之外。\n\n综合两种情况，索引 $j$ 的所有可能计算值的集合 $S$ 是：\n$$\nS = \\{0, 1, \\dots, 20\\} \\cup \\{52, 53, \\dots, 63\\}\n$$\n控制流完整性 (CFI) 守卫是 `if (j  U) jump() else default()`。该机制必须满足两个条件：\n1.  **安全性**：它必须阻止所有向无效目标的跳转。任何通过检查 (即 $j  U$) 的计算索引 $j$ 都必须是一个有效的目标。通过检查的计算索引集合是 $S \\cap \\{0, 1, \\dots, U-1\\}$。这个集合必须是有效目标集合 $\\{0, 1, \\dots, 20\\}$ 的子集。\n    $$\n    S \\cap \\{0, 1, \\dots, U-1\\} \\subseteq \\{0, 1, \\dots, 20\\}\n    $$\n    $S$ 中的无效索引是 $\\{52, 53, \\dots, 63\\}$。为使该条件成立，这些无效索引都不能通过检查 $j  U$。这意味着对于任何 $j_{invalid} \\in \\{52, 53, \\dots, 63\\}$，我们必须有 $j_{invalid} \\ge U$。最具限制性的情况是这些无效索引中最小的那个，即 $52$。所以，我们必须有 $52 \\ge U$。\n\n2.  **正确性**：它不能阻止有效的程序执行。所有可以到达的有效 case 标签都必须被检查所允许。可达的有效目标集合是 $\\{0, 1, \\dots, 20\\}$。对于其中的每一个值 $j_{valid}$，检查 $j_{valid}  U$ 都必须为真。\n    这对于所有 $j \\in \\{0, 1, \\dots, 20\\}$ 都必须成立。最具限制性的情况是这些有效索引中最大的那个，即 $20$。所以，我们必须有 $20  U$。\n\n结合这两个条件，$U$ 必须是一个满足 $20  U$ 和 $U \\le 52$ 的整数。这意味着 $U$ 可以是范围 $[21, 52]$ 内的任何整数。\n题目要求的是满足条件的*最小*常量 $U$。这对应于在不违反正确性的前提下，使检查尽可能紧。满足 $20  U$ 的最小整数值是 $21$。这个值也满足 $U \\le 52$。\n\n因此，最小常量上界是 $U=21$。使用这个上界，检查变为 $j  21$。\n- 如果计算出的索引 $j$ 在 $\\{0, 1, \\dots, 20\\}$ 中，检查 $j  21$ 通过，执行有效跳转。\n- 如果计算出的索引 $j$ 在 $\\{52, 53, \\dots, 63\\}$ 中，检查 $j  21$ 失败，程序正确地跳转到 default 块，从而防止了无效跳转。\n这满足了所有要求。",
            "answer": "$$\\boxed{21}$$"
        },
        {
            "introduction": "除了保护调用和跳转等前向边控制转移，CFI还必须保护函数返回等后向边。影子栈是一种常用的返回地址保护机制，它通过确保调用和返回的配对来维持控制流的完整性。然而，异常处理等语言特性会引发非局部控制转移，打破简单的后进先出（LIFO）调用模式。本练习要求你深入思考在这种复杂场景下如何维护安全不变性，阐明一个稳健的CFI实现必须如何在异常栈回溯等事件中，使其安全元数据（影子栈）与程序的实际执行状态保持同步，以防止出现严重的不匹配。",
            "id": "3632877",
            "problem": "一个编译器将控制流完整性（CFI）插桩代码插入到一个程序中，并维护一个独立的影子堆栈，以强制执行 $call$ 和 $return$ 控制流边的严格配对。考虑以下涉及结构化异常处理的场景。函数 $\\mathsf{main}$ 调用 $\\mathsf{A}$，$\\mathsf{A}$ 接着调用 $\\mathsf{B}$；$\\mathsf{B}$ 调用 $\\mathsf{C}$。在 $\\mathsf{A}$ 内部有一个处理程序，它捕获由 $\\mathsf{C}$ 抛出的异常，并在 $\\mathsf{A}$ 内的一个着陆点 $\\mathsf{L_A}$ 继续执行。当 $\\mathsf{C}$ 抛出异常时，运行时会展开（unwind）并越过 $\\mathsf{C}$ 和 $\\mathsf{B}$ 的栈帧，执行它们的清理代码，然后将控制权直接转移到位于 $\\mathsf{L_A}$ 的 $\\mathsf{A}$ 的处理程序中，从而绕过了 $\\mathsf{C}$ 和 $\\mathsf{B}$ 的正常返回。\n\n用控制流图 $\\mathsf{G} = (V, E)$ 来为该控制流建模，并将 $E$ 划分为前向边和返回边。令 $E_{\\text{call}} \\subseteq E$ 表示调用边，令 $E_{\\text{return}} \\subseteq E$ 表示在正常执行下与调用点配对的返回边。调用-返回规程对应于一种良括号属性：如果 $\\sigma$ 是动态控制转移序列，那么来自 $E_{\\text{call}} \\cup E_{\\text{return}}$ 的边子序列构成了一个戴克语言（Dyck language），其中调用是开括号，返回是闭括号。影子堆栈 $S$ 通过在每次动态调用时存储 CFI 策略允许的唯一返回点的标签 $\\ell$，来抽象化预期的返回目标。在执行 $return$ 时，CFI 机制会验证控制权是否转移到 $S$ 顶部的标签 $\\ell$，然后弹出顶部元素。\n\n在上述异常场景中，语言运行时会展开硬件堆栈以到达 $\\mathsf{A}$ 中的 $\\mathsf{L_A}$，跳过 $\\mathsf{C}$ 和 $\\mathsf{B}$ 的正常函数尾声（epilogue）。为了保持健全性，CFI 策略必须在这种非局部转移的情况下，仍然保持 $call$ 和 $return$ 边的良括号配对属性。在这样的异常展开过程中，为了确保后续的 $return$ 边仍然与其对应的 $call$ 边匹配，哪个选项最能描述集成了 CFI 的影子堆栈所需采取的行动？\n\nA. 维护一个由预期返回标签组成的影子堆栈 $S$；在每次动态 $call$ 时，将唯一允许的返回标签推入 $S$。在异常展开期间，每当从硬件堆栈中移除一个栈帧时，就从 $S$ 中弹出一个元素，以丢弃现在无效的预期返回地址，并且只将控制权转移到前向边 CFI 策略所允许的着陆点。进入处理程序后，仅当 $return$ 的目标与 $S$ 顶部的标签相等时才允许其执行。\n\nB. 在异常展开期间保持影子堆栈 $S$ 不变，以保留异常前的调用历史；在处理程序运行后，只要下一个 $return$ 的目标是任何静态有效的地址，就允许其执行，因为异常已经逻辑上终止了被跳过的栈帧。\n\nC. 用检查硬件堆栈指针在展开期间单调递增来取代返回目标检查；如果该条件成立，则认为调用-返回匹配得以保持，因为物理堆栈已经编码了正确的嵌套关系。\n\nD. 在异常展开期间，在运行时修补所有被跳过的栈帧的代码，以使其 $return$ 指令无效，从而防止不匹配的返回；影子堆栈 $S$ 直到程序从处理程序返回后才更新。\n\n选择正确的选项。你的推理应从控制流图、良括号调用-返回规程和影子堆栈抽象的正式定义出发，并阐明由异常引起的非局部控制转移必须如何在 $S$ 中反映，以在 CFI 强制执行下保持调用-返回边的戴克语言属性。假设前向边，包括对着陆点的间接跳转，已由 CFI 策略根据 $\\mathsf{G}$ 单独进行了验证，重点关注 $E_{\\text{return}}$ 匹配的正确性。",
            "solution": "问题陈述描述了一个场景，其中涉及通过影子堆栈强制执行的控制流完整性（CFI）及其与结构化异常处理的交互，后者涉及非局部控制转移。核心任务是确定在堆栈展开期间，为了维持调用-返回匹配的完整性，影子堆栈需要执行哪些必要操作。\n\n### 第一步：提取已知条件\n\n1.  **系统组件**：一个插入CFI插桩代码并使用影子堆栈的编译器。\n2.  **控制流模型**：一个控制流图 $\\mathsf{G} = (V, E)$，其边被划分为前向边和返回边。$E_{\\text{call}} \\subseteq E$ 是调用边，$E_{\\text{return}} \\subseteq E$ 是返回边。\n3.  **CFI 不变量**：来自 $E_{\\text{call}} \\cup E_{\\text{return}}$ 的动态边序列必须构成一个戴克语言，表示调用和返回的良括号匹配。\n4.  **影子堆栈机制**：一个影子堆栈 $S$ 存储允许的返回点的标签 $\\ell$。在动态 `call` 时，一个唯一返回点的标签 $\\ell$ 被推入 $S$。在 `return` 时，控制转移目标必须与 $S$ 顶部的标签 $\\ell$ 匹配。如果匹配，则弹出 $S$ 的栈顶元素。\n5.  **执行场景**：一个调用链：$\\mathsf{main} \\rightarrow \\mathsf{A} \\rightarrow \\mathsf{B} \\rightarrow \\mathsf{C}$。函数 $\\mathsf{C}$ 抛出一个异常。在函数 $\\mathsf{A}$ 内部存在一个异常处理程序，其入口点（着陆点）在 $\\mathsf{L_A}$。运行时展开堆栈，绕过 $\\mathsf{C}$ 和 $\\mathsf{B}$ 的正常返回。这包括执行 $\\mathsf{C}$ 和 $\\mathsf{B}$ 的清理代码，并将控制权直接转移到 $\\mathsf{L_A}$。\n6.  **问题**：在这个由异常引起的展开过程中，影子堆栈机制必须执行什么操作，以维持后续返回的良括号匹配属性？\n7.  **假设**：前向边 CFI，包括对着陆点 $\\mathsf{L_A}$ 的跳转，被单独且正确地处理。重点在于 $E_{\\text{return}}$ 中边的匹配正确性。\n\n### 第二步：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行评估。\n\n1.  **科学依据**：该问题牢固地植根于计算机科学中的既定概念，特别是编译器设计和系统安全。控制流完整性、影子堆栈、异常处理语义和堆栈展开都是定义明确的标准主题。使用控制流图和戴克语言进行形式化是程序控制流分析中的标准做法。\n2.  **适定性**：该问题是适定的。它描述了一个具体、明确的场景，并要求为维持一个明确定义的不变量（戴克语言属性）而采取必要的操作。上下文的约束足以得出一个唯一的、合乎逻辑的结论。\n3.  **客观性**：语言是技术性的、精确的和客观的。它通过正式定义其术语来避免歧义和主观性。\n4.  **缺陷清单**：\n    -   **科学上不健全**：无。计算模型是标准的。\n    -   **不可形式化**：无。该问题已被部分形式化，并且适合于进一步的形式推理。\n    -   **不完整/矛盾**：无。设定是自洽和一致的。调用链、异常源、处理程序位置以及展开的效果都已明确指定。只关注返回边完整性的假设是一个有效的简化，而不是一个缺陷。\n    -   **不现实/不可行**：无。这是一个关键且现实的问题，现实世界中的 CFI 实现（例如微软的 Control Flow Guard 或 Clang 的 CFI）必须解决此问题，才能正确处理 C++ 中的异常。\n    -   **不适定**：无。可以从原则中推导出一个唯一且稳定的解决方案。\n    -   **伪深刻/琐碎**：无。该问题需要对程序执行状态（调用堆栈）和安全元数据（影子堆栈）之间的相互作用有深入的理解。它并非微不足道。\n    -   **超出科学可验证性**：无。其推理可通过形式逻辑和算法分析进行验证。\n\n### 第三步：结论与行动\n\n问题陈述是有效的。它在科学上是健全的、适定的和客观的。我现在将继续推导解决方案。\n\n### 正确机制的推导\n\n影子堆栈 CFI 机制的基本原则是，影子堆栈 $S$ 必须作为程序调用堆栈的一个抽象模型，特别是在预期返回目标方面。为了使 CFI 保证成立，$S$ 的状态必须与活动函数调用的逻辑嵌套保持同步。\n\n1.  **初始状态**：让我们追踪硬件堆栈和影子堆栈 $S$ 的状态。\n    -   `main` 调用 `A`。返回到 `main` 的地址（我们称之为 $r_A$）被推入硬件堆栈。CFI 机制将一个对应的标签（我们也可以表示为 $r_A$）推入影子堆栈 $S$。状态：$S = [r_A]$。\n    -   `A` 调用 `B`。返回到 `A` 的地址 $r_B$ 被推入硬件堆栈。影子堆栈变为 $S = [r_A, r_B]$。\n    -   `B` 调用 `C`。返回到 `B` 的地址 $r_C$ 被推入硬件堆栈。影子堆栈变为 $S = [r_A, r_B, r_C]$。\n\n    此时，在 `C` 抛出异常之前，硬件堆栈包含 `main`、`A`、`B` 和 `C` 的活动记录。影子堆栈 $S$ 包含每个活动调用的预期返回目标序列。$S$ 的顶部 $r_C$ 对应于从 `C` 到 `B` 的预期返回。\n\n2.  **异常和展开**：函数 `C` 抛出一个异常。语言运行时开始堆栈展开以寻找处理程序。\n    -   运行时检查 `C` 的栈帧。未找到处理程序。该栈帧必须被展开。\n    -   运行时检查 `B` 的栈帧。未找到处理程序。该栈帧必须被展开。\n    -   运行时检查 `A` 的栈帧。找到一个处理程序。展开在此处停止。\n\n    `C` 和 `B` 栈帧的“展开”意味着这些函数活动被强制终止。它们将永远不会执行其正常的 `return` 指令返回到各自的地址 $r_C$ 和 $r_B$。导致这些预期返回的控制流路径已被中止。\n\n3.  **维持不变量**：CFI 不变量是动态调用和返回的序列构成一个戴克语言。一个 `call` 是一个开括号 `(`，一个 `return` 是一个闭括号 `)`。在异常发生时，影子堆栈上的事件序列是 `push(r_A)`、`push(r_B)`、`push(r_C)`，这对应于字符串 `(((`。\n    异常展开有效地取消了最近的两次调用（`A` 到 `B`，以及 `B` 到 `C`），而没有相应的返回。为了为未来的执行保持良括号属性，影子堆栈的状态必须反映这种取消。与这些调用相对应的两个开括号 `((` 必须被移除。\n\n4.  **必需的影子堆栈操作**：由于 `C` 和 `B` 的活动记录已从硬件堆栈中移除，它们存储在影子堆栈上的相应返回目标 $r_C$ 和 $r_B$ 现在已无效，必须被丢弃。在堆栈数据结构中，唯一的方法就是将它们弹出。\n    -   当 `C` 的栈帧被展开时，CFI 运行时必须从 $S$ 中弹出 $r_C$。$S$ 变为 $[r_A, r_B]$。\n    -   当 `B` 的栈帧被展开时，CFI 运行时必须从 $S$ 中弹出 $r_B$。$S$ 变为 $[r_A]$。\n\n    这个操作使影子堆栈 $S$ 与硬件调用堆栈同步。展开后，活动调用堆栈由 `main` 和 `A` 的栈帧组成，而影子堆栈正确地只包含 $r_A$。\n\n5.  **展开后执行**：控制权被转移到 `A` 内部的着陆点 $\\mathsf{L_A}$。`A` 的执行恢复。当 `A` 最终完成并执行其 `return` 指令时，它将以 $r_A$ 为目标。CFI 机制将此目标与影子堆栈的顶部（也是 $r_A$）进行检查。检查通过，$r_A$ 从 $S$ 中弹出，控制权返回到 `main`。`A` 的调用-返回对被正确匹配，CFI 不变量得以保持。\n\n### 选项评估\n\n**A. 维护一个由预期返回标签组成的影子堆栈 $S$；在每次动态 $call$ 时，将唯一允许的返回标签推入 $S$。在异常展开期间，每当从硬件堆栈中移除一个栈帧时，就从 $S$ 中弹出一个元素，以丢弃现在无效的预期返回地址，并且只将控制权转移到前向边 CFI 策略所允许的着陆点。进入处理程序后，仅当 $return$ 的目标与 $S$ 顶部的标签相等时才允许其执行。**\n-   此选项准确地描述了上面推导的过程。它正确地指出，在展开期间，影子堆栈必须通过为每个被展开的栈帧弹出一个元素来与硬件堆栈同步。这确保了 $S$ 的状态能正确反映剩余的活动调用，从而为后续的返回保留了调用-返回匹配。提及对着陆点的前向边 CFI 与一个完整的 CFI 系统是一致的。\n-   **结论：正确。**\n\n**B. 在异常展开期间保持影子堆栈 $S$ 不变，以保留异常前的调用历史；在处理程序运行后，只要下一个 $return$ 的目标是任何静态有效的地址，就允许其执行，因为异常已经逻辑上终止了被跳过的栈帧。**\n-   这种方法存在根本性缺陷。如果 $S$ 保持不变，其状态将是 $[r_A, r_B, r_C]$。当函数 `A` 稍后返回到 $r_A$ 时，CFI 检查将失败，因为它预期返回到 $r_C$。这将导致一个虚假的 CFI 违规。\"异常前的调用历史\" 正是因展开而变得部分无效的东西。放宽 CFI 检查以允许返回到“任何静态有效的地址”，将违背影子堆栈所提供的精确、动态的调用-返回匹配的目的。\n-   **结论：不正确。**\n\n**C. 用检查硬件堆栈指针在展开期间单调递增来取代返回目标检查；如果该条件成立，则认为调用-返回匹配得以保持，因为物理堆栈已经编码了正确的嵌套关系。**\n-   这个选项混淆了两个不同的安全属性。检查堆栈指针的移动验证的是展开机制自身的属性（即，它是否正确地释放了栈帧），但它并没有为 `return` 指令强制执行控制流完整性。影子堆栈的目的是验证 `return` 的*目标地址*，而不是堆栈指针的值。该选项不当地建议放弃对 `return` 边的核心 CFI 检查。\n-   **结论：不正确。**\n\n**D. 在异常展开期间，在运行时修补所有被跳过的栈帧的代码，以使其 $return$ 指令无效，从而防止不匹配的返回；影子堆栈 $S$ 直到程序从处理程序返回后才更新。**\n-   这种机制既过于复杂又无效。被跳过的栈帧（`B` 和 `C`）中的 `return` 指令无论如何都不会被执行，所以修补它们是毫无意义的。根本问题依然存在：影子堆栈 $S$ 与调用堆栈不同步。由于不更新 $S$，这种方法与选项 B 有着相同的缺陷，当处理程序的函数（`A`）返回时，会导致一个假阳性的 CFI 违规。\n-   **结论：不正确。**\n\n基于从影子堆栈操作的第一性原理和维持戴克语言属性的目标进行的严格推导，选项 A 是唯一正确描述了必要程序的选项。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}