{
    "hands_on_practices": [
        {
            "introduction": "要想真正掌握 Earley 算法，没有什么比亲手进行一次模拟更有效了。这个练习  将引导你为一个简单但具有歧义性的文法构建 Earley 分析表。通过这个过程，你将直观地看到预测（Predictor）、扫描（Scanner）和完成（Completer）这三个核心操作如何协同工作，并理解该算法是如何自然地处理多个分析树的。",
            "id": "3639800",
            "problem": "考虑上下文无关文法 (CFG) $G$，其开始符号为 $S$，产生式为 $S \\to S\\,S \\mid a$。设输入串为 $\\mathtt{aaa}$，长度为 $3$。使用 Earley 分析算法，该算法将状态表示为点项 $[A \\to \\alpha\\,\\cdot\\,\\beta, i]$，其中 $A$ 是一个非终结符，$\\alpha$ 和 $\\beta$ 是（可能为空的）终结符和非终结符串，点表示在产生式右侧的当前位置，而 $i$ 是该成分开始的起始索引。Earley 算法使用三个基本操作：预测（Predictor，为紧邻点右侧的非终结符添加产生式）、扫描（Scanner，从输入中消耗一个匹配的终结符来前移点）和完成（Completer，当一个成分完成时，它会前移任何在其起始位置等待该成分的状态）。用新的开始符号 $S'$ 和产生式 $S' \\to S$ 来增广该文法。\n\n为输入 $\\mathtt{aaa}$ 构建 Earley 分析表 $C_0, C_1, C_2, C_3$，显示在每个位置由预测、扫描和完成操作创建的项，并保留起始索引。基于完成的项以及完成步骤所隐含的回溯指针，从第一性原理推断该算法在文法 $G$ 下为 $\\mathtt{aaa}$ 发现了多少棵不同的分析树。以单个整数形式提供您的最终答案。无需四舍五入，答案中不应包含任何单位。",
            "solution": "上下文无关文法 $G$ 由产生式 $S \\to S\\,S \\mid a$ 给出。输入串是 $\\mathtt{aaa}$，我们记为 $w = w_1 w_2 w_3$，其中 $w_1=w_2=w_3=\\mathtt{a}$。根据题目要求，我们用一个新的开始符号 $S'$ 和一个产生式 $S' \\to S$ 来增广该文法。增广文法 $G'$ 是：\n$S' \\to S$\n$S \\to S\\,S$\n$S \\to a$\n\n我们构建 Earley 分析表 $C_0, C_1, C_2, C_3$。一个项的形式为 $[A \\to \\alpha\\,\\cdot\\,\\beta, i]$，其中 $i$ 是输入串中的起始索引（从 $0$ 到 $3$）。\n\n**分析表 $C_0$：**\n初始化时，我们在索引 $0$ 处为增广开始规则添加一个项。然后我们应用预测（Predictor）操作，直到没有新项可以添加。\n1. $[S' \\to \\cdot S, 0]$ (种子)\n2. $[S \\to \\cdot S\\,S, 0]$ (对项 1 进行预测，因为 $S$ 在点的右侧)\n3. $[S \\to \\cdot a, 0]$ (对项 1 进行预测)\n   (对项 2 应用预测会重新生成项 2 和 3，因此该分析表已完成。)\n\n**分析表 $C_1$ (处理输入 $w_1 = \\mathtt{a}$ 后)：**\n我们首先对 $C_0$ 中期望终结符 $\\mathtt{a}$ 的项应用扫描（Scanner），然后运行完成（Completer）和预测（Predictor）操作直到达到不动点。\n1. $[S \\to a \\cdot, 0]$ (对 $C_0$ 中的 $[S \\to \\cdot a, 0]$ 进行扫描)\n2. $[S' \\to S \\cdot, 0]$ (对项 1 进行完成，前移 $C_0$ 中的 $[S' \\to \\cdot S, 0]$)\n3. $[S \\to S \\cdot S, 0]$ (对项 1 进行完成，前移 $C_0$ 中的 $[S \\to \\cdot S S, 0]$)\n4. $[S \\to \\cdot S\\,S, 1]$ (对项 3 进行预测，针对当前位置 $1$ 所需的 $S$)\n5. $[S \\to \\cdot a, 1]$ (对项 3 进行预测)\n\n**分析表 $C_2$ (处理输入 $w_2 = \\mathtt{a}$ 后)：**\n1. $[S \\to a \\cdot, 1]$ (对 $C_1$ 中的 $[S \\to \\cdot a, 1]$ 进行扫描)\n   现在我们用这个新完成的项 $[S \\to a \\cdot, 1]$ 应用完成器，该项表示一个跨越索引 $1$ 到 $2$ 的 $S$。\n2. $[S \\to S \\cdot S, 1]$ (对项 1 进行完成，前移 $C_1$ 中的 $[S \\to \\cdot S\\,S, 1]$)\n3. $[S \\to S\\,S \\cdot, 0]$ (对项 1 进行完成，前移 $C_1$ 中的 $[S \\to S \\cdot S, 0]$。这个新项是一个跨越 $0$ 到 $2$ 的已完成的 $S$。)\n   现在我们再次对项 3 应用完成器。\n4. $[S' \\to S \\cdot, 0]$ (对项 3 进行完成，前移 $C_0$ 中的 $[S' \\to \\cdot S, 0]$)\n5. $[S \\to S \\cdot S, 0]$ (对项 3 进行完成，前移 $C_0$ 中的 $[S \\to \\cdot S\\,S, 0]$)\n   最后，我们对新的未完成项应用预测器。\n6. $[S \\to \\cdot S\\,S, 2]$ (对项 2 和 5 进行预测，针对当前位置 $2$ 所需的 $S$)\n7. $[S \\to \\cdot a, 2]$ (对项 2 和 5 进行预测)\n\n**分析表 $C_3$ (处理输入 $w_3 = \\mathtt{a}$ 后)：**\n1. $[S \\to a \\cdot, 2]$ (对 $C_2$ 中的 $[S \\to \\cdot a, 2]$ 进行扫描)\n   这是一个从索引 $2$ 到 $3$ 的已完成的 $S$。我们运行完成器。\n2. $[S \\to S \\cdot S, 2]$ (对项 1 进行完成，前移 $C_2$ 中的 $[S \\to \\cdot S\\,S, 2]$)\n3. $[S \\to S\\,S \\cdot, 1]$ (对项 1 进行完成，前移 $C_2$ 中的 $[S \\to S \\cdot S, 1]$。这是一个从 $1$ 到 $3$ 的已完成的 $S$。)\n4. $[S \\to S\\,S \\cdot, 0]$ (对项 1 进行完成，前移 $C_2$ 中的 $[S \\to S \\cdot S, 0]$。这是形成一个从 $0$ 到 $3$ 的已完成的 $S$ 的一种方式。)\n   我们对新完成的项继续使用完成器。来自步骤 3 的项 $[S \\to S\\,S \\cdot, 1]$（一个从 $1$ 到 $3$ 的 $S$）可以完成等待中的项。\n5. $[S \\to S\\,S \\cdot, 0]$ 的第二次推导 (对项 3 进行完成，前移 $C_1$ 中的 $[S \\to S \\cdot S, 0]$)。请注意，虽然结果项与项 4 在文本上相同，但其推导路径是不同的。\n   无论它们是如何被推导出来的，项 $[S \\to S\\,S \\cdot, 0]$ 都代表从 $0$ 到 $3$ 的已完成的 $S$ 成分。它们触发了从 $C_0$ 开始的进一步完成。\n6. $[S' \\to S \\cdot, 0]$ (对项 4 和 5 进行完成，前移 $C_0$ 中的 $[S' \\to \\cdot S, 0]$)。该项表示对整个字符串的成功分析。\n7. $[S \\to S \\cdot S, 0]$ (对项 4 和 5 进行完成，前移 $C_0$ 中的 $[S \\to \\cdot S\\,S, 0]$)。\n没有更多的项可以被添加。$[S' \\to S \\cdot, 0]$ 在 $C_3$ 中的存在证实了字符串 $\\mathtt{aaa}$ 属于该语言。\n\n**计算分析树：**\n不同分析树的数量就是最终接受项 $[S' \\to S \\cdot, 0]$ 在 $C_3$ 中的不同推导的数量。由于产生式 $S' \\to S$ 是无二义的，这个数量等于构成一个跨越索引 $0$ 到 $3$ 的成分 $S$ 的方式数量。\n\n我们用 $N(A, i, j)$ 表示非终结符 $A$ 跨越从索引 $i$ 到 $j$ 的输入子串的不同分析树的数量。我们可以用自底向上的方式从分析表结构中计算这个值。\n- 来自终结产生式（如 $S \\to a$）的成分只有一个推导。\n  - $N(S, 0, 1)$ 来自 $C_1$ 中的 $[S \\to a \\cdot, 0]$，所以 $N(S, 0, 1) = 1$。\n  - $N(S, 1, 2)$ 来自 $C_2$ 中的 $[S \\to a \\cdot, 1]$，所以 $N(S, 1, 2) = 1$。\n  - $N(S, 2, 3)$ 来自 $C_3$ 中的 $[S \\to a \\cdot, 2]$，所以 $N(S, 2, 3) = 1$。\n\n- 对于跨越 $(i, j)$ 的递归产生式（如 $S \\to S\\,S$），我们必须对所有可能的分割点 $k$（其中 $i  k  j$）求和：\n  $N(S, i, j) = \\sum_{k=i+1}^{j-1} N(S, i, k) \\times N(S, k, j)$\n\n- 我们计算子串 $\\mathtt{aa}$ 的 $N(S, 0, 2)$：唯一的分割点是 $k=1$。\n  $N(S, 0, 2) = N(S, 0, 1) \\times N(S, 1, 2) = 1 \\times 1 = 1$。\n  这对应于在 $C_2$ 中创建 $[S \\to S\\,S \\cdot, 0]$。\n\n- 我们计算子串 $\\mathtt{aa}$ 的 $N(S, 1, 3)$：唯一的分割点是 $k=2$。\n  $N(S, 1, 3) = N(S, 1, 2) \\times N(S, 2, 3) = 1 \\times 1 = 1$。\n  这对应于在 $C_3$ 中创建 $[S \\to S\\,S \\cdot, 1]$。\n\n- 最后，我们计算完整字符串 $\\mathtt{aaa}$ 的 $N(S, 0, 3)$。可能的分割点是 $k=1$ 和 $k=2$。\n  $N(S, 0, 3) = N(S, 0, 1) \\times N(S, 1, 3) + N(S, 0, 2) \\times N(S, 2, 3)$\n  代入我们找到的值：\n  $N(S, 0, 3) = (1 \\times 1) + (1 \\times 1) = 1 + 1 = 2$。\n\n这两项对应于在 $(0, 3)$ 上形成 $S$ 的两条不同完成路径：\n1. $N(S, 0, 1) \\times N(S, 1, 3) = 1$ 项对应于具有顶层结构 $(S_{0,1} S_{1,3})$ 的分析。在分析表中，这是用 $S_{1,3}$ 的完成项（即 $C_3$ 中的 $[S \\to S\\,S \\cdot, 1]$）来完成 $C_1$ 中的 $[S \\to S \\cdot S, 0]$。这产生一棵分析树（右结合：$\\mathtt{a}(\\mathtt{aa})$）。\n\n2. $N(S, 0, 2) \\times N(S, 2, 3) = 1$ 项对应于具有顶层结构 $(S_{0,2} S_{2,3})$ 的分析。在分析表中，这是用 $S_{2,3}$ 的完成项（即 $C_3$ 中的 $[S \\to a \\cdot, 2]$）来完成 $C_2$ 中的 $[S \\to S \\cdot S, 0]$。这产生第二棵不同的分析树（左结合：$(\\mathtt{aa})\\mathtt{a}$）。\n\n由于有两种方式可以推导出一个跨越整个输入的 $S$，该算法发现了两棵不同的分析树。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "分析器的效率不仅取决于算法本身，还与它所处理的文法结构密切相关。这个练习  通过要求你比较在应用左因子提取（一种常见的文法转换）前后生成的 Earley 项目数量，来揭示这种关系。通过这种量化比较，你将更深刻地体会到文法设计对分析性能的影响。",
            "id": "3639827",
            "problem": "考虑上下文无关文法 (CFG) $G$，其开始符号为 $S$，产生式为 $S \\to a\\,A \\mid a\\,B$，$A \\to x$ 和 $B \\to y$。令 $G$ 的提取左公因子重构 $G^{\\mathrm{lf}}$ 定义为引入一个新的非终结符 $C$，使得产生式变为 $S \\to a\\,C$，$C \\to A \\mid B$，$A \\to x$ 和 $B \\to y$。使用 Earley 分析算法，并以增广开始符号 $S_{0} \\to S$ 来分析输入串 $w = a\\,x$。Earley 算法构造一个集合序列（通常称为图表），其中位置 $i$ 处的集合表示为 $E_{i}$，包含形式为 $[A \\to \\alpha\\,\\bullet\\,\\beta, j]$ 的 Earley 项目。该项目表示一个产生式 $A \\to \\alpha\\beta$，其中的点表示右侧的当前位置，$j$ 是起始索引。\n\n定义以下两个度量：\n- 对于输入 $w$，一个文法的总预测数是在所有 $E_{i}$ 中由预测器操作添加的不同项目的数量（每个不同的项目在整体上只计数一次）。\n- 对于输入 $w$，一个文法的总项目增长量是在位置 $|w|$ 处的图表在预测器、扫描器和完成器操作下完全闭合后（在每个 $E_i$ 内消除了重复项），所有位置 $i$ 上的基数 $|E_{i}|$ 的总和。\n\n计算在输入 $w = a\\,x$ 上，$G^{\\mathrm{lf}}$ 的总项目增长量与 $G$ 的总项目增长量之比 $R$。将最终的 $R$ 表示为一个简化的精确分数，无需四舍五入。",
            "solution": "问题要求计算在使用 Earley 算法分析输入串 $w = a\\,x$ 时，提取左公因子的上下文无关文法 $G^{\\mathrm{lf}}$ 的总项目增长量与原始文法 $G$ 的总项目增长量之比。总项目增长量定义为所有 Earley 集的基数之和，即 $\\sum_{i=0}^{|w|} |E_i|$。\n\n对于长度为 $n$ 的输入串，Earley 算法构造一系列集合 $E_0, E_1, \\dots, E_n$。每个集合 $E_i$ 包含形式为 $[A \\to \\alpha \\bullet \\beta, j]$ 的 Earley 项目，这表示我们在输入的位置 $i$，正在匹配产生式 $A \\to \\alpha \\beta$，并且规则中对应于 $\\alpha$ 的部分已经匹配了从位置 $j$ 到 $i$ 的输入子串。\n\n该算法使用三个主要操作来填充这些集合：\n1.  **预测器 (Predictor)**：如果 $[A \\to \\alpha \\bullet B \\beta, j]$ 在 $E_i$ 中且 $B$ 是一个非终结符，则对于每个产生式 $B \\to \\gamma$，将项目 $[B \\to \\bullet \\gamma, i]$ 添加到 $E_i$ 中。\n2.  **扫描器 (Scanner)**：如果 $[A \\to \\alpha \\bullet a \\beta, j]$ 在 $E_i$ 中且下一个输入符号是 $a$，则将项目 $[A \\to \\alpha a \\bullet \\beta, j]$ 添加到 $E_{i+1}$ 中。\n3.  **完成器 (Completer)**：如果 $[B \\to \\gamma \\bullet, k]$ 在 $E_i$ 中，则对于 $E_k$ 中每个形如 $[A \\to \\alpha \\bullet B \\beta, j]$ 的项目，将新项目 $[A \\to \\alpha B \\bullet \\beta, j]$ 添加到 $E_i$ 中。\n\n我们将对输入串 $w = a\\,x$（其长度 $|w|=2$）将此算法应用于两个文法。我们将构造集合 $E_0, E_1$ 和 $E_2$。增广开始规则是 $S_0 \\to S$。\n\n### 第 1 部分：文法 $G$ 的分析\n\n文法 $G$ 由以下产生式给出：\n$S_0 \\to S$\n$S \\to a\\,A \\mid a\\,B$\n$A \\to x$\n$B \\to y$\n\n**为 $G$ 构造 Earley 图表：**\n\n**集合 $E_0$：**\n1.  用增广开始规则初始化：将 $[S_0 \\to \\bullet S, 0]$ 添加到 $E_0$ 中。\n2.  **预测器**：对于 $[S_0 \\to \\bullet S, 0]$，点在非终结符 $S$ 之前。我们添加所有起始索引为 $0$ 的 $S$ 的产生式。\n    - 将 $[S \\to \\bullet a A, 0]$ 添加到 $E_0$ 中。\n    - 将 $[S \\to \\bullet a B, 0]$ 添加到 $E_0$ 中。\n新项目中的点在终结符 $a$ 之前，因此不再进行预测。\n最终集合为 $E_0 = \\{ [S_0 \\to \\bullet S, 0], [S \\to \\bullet a A, 0], [S \\to \\bullet a B, 0] \\}$。\n基数为 $|E_0| = 3$。\n\n**集合 $E_1$：**\n下一个输入符号是 $a$。\n1.  **扫描器**：我们扫描 $E_0$ 中点在 $a$ 之前的项目。\n    - 从 $[S \\to \\bullet a A, 0]$，我们扫描 $a$ 并将 $[S \\to a \\bullet A, 0]$ 添加到 $E_1$ 中。\n    - 从 $[S \\to \\bullet a B, 0]$，我们扫描 $a$ 并将 $[S \\to a \\bullet B, 0]$ 添加到 $E_1$ 中。\n2.  **预测器**：我们闭合集合 $E_1$。\n    - 对于 $[S \\to a \\bullet A, 0]$，点在 $A$ 之前。我们预测起始索引为 1 的 $A$ 的规则。\n        - 将 $[A \\to \\bullet x, 1]$ 添加到 $E_1$ 中。\n    - 对于 $[S \\to a \\bullet B, 0]$，点在 $B$ 之前。我们预测起始索引为 1 的 $B$ 的规则。\n        - 将 $[B \\to \\bullet y, 1]$ 添加到 $E_1$ 中。\n新项目中的点在终结符之前，因此不再进行预测。\n最终集合为 $E_1 = \\{ [S \\to a \\bullet A, 0], [S \\to a \\bullet B, 0], [A \\to \\bullet x, 1], [B \\to \\bullet y, 1] \\}$。\n基数为 $|E_1| = 4$。\n\n**集合 $E_2$：**\n下一个输入符号是 $x$。\n1.  **扫描器**：我们扫描 $E_1$ 中点在 $x$ 之前的项目。\n    - 从 $[A \\to \\bullet x, 1]$，我们扫描 $x$ 并将 $[A \\to x \\bullet, 1]$ 添加到 $E_2$ 中。\n2.  **完成器**：我们闭合集合 $E_2$。新项目 $[A \\to x \\bullet, 1]$ 是一个已完成项目，其起始索引为 $k=1$。我们在 $E_1$ 中寻找形如 $[X \\to \\alpha \\bullet A \\beta, j]$ 的项目。\n    - 我们在 $E_1$ 中找到 $[S \\to a \\bullet A, 0]$。我们将 $[S \\to a A \\bullet, 0]$ 添加到 $E_2$ 中。\n3.  **完成器**：新项目 $[S \\to a A \\bullet, 0]$ 是一个已完成项目，其起始索引为 $k=0$。我们在 $E_0$ 中寻找形如 $[X \\to \\alpha \\bullet S \\beta, j]$ 的项目。\n    - 我们在 $E_0$ 中找到 $[S_0 \\to \\bullet S, 0]$。我们将 $[S_0 \\to S \\bullet, 0]$ 添加到 $E_2$ 中。\n该集合现已闭合。\n最终集合为 $E_2 = \\{ [A \\to x \\bullet, 1], [S \\to a A \\bullet, 0], [S_0 \\to S \\bullet, 0] \\}$。\n基数为 $|E_2| = 3$。\n\n**$G$ 的总项目增长量：**\n总项目增长量是基数之和：\n$\\text{Total}(G) = |E_0| + |E_1| + |E_2| = 3 + 4 + 3 = 10$。\n\n### 第 2 部分：文法 $G^{\\mathrm{lf}}$ 的分析\n\n提取左公因子的文法 $G^{\\mathrm{lf}}$ 由以下产生式给出：\n$S_0 \\to S$\n$S \\to a\\,C$\n$C \\to A \\mid B$\n$A \\to x$\n$B \\to y$\n\n**为 $G^{\\mathrm{lf}}$ 构造 Earley 图表：**\n\n**集合 $E_0$：**\n1.  用增广开始规则初始化：将 $[S_0 \\to \\bullet S, 0]$ 添加到 $E_0$ 中。\n2.  **预测器**：对于 $[S_0 \\to \\bullet S, 0]$，预测所有 $S$ 的产生式。\n    - 将 $[S \\to \\bullet a C, 0]$ 添加到 $E_0$ 中。\n新项目中的点在终结符之前，因此不再进行预测。\n最终集合为 $E_0 = \\{ [S_0 \\to \\bullet S, 0], [S \\to \\bullet a C, 0] \\}$。\n基数为 $|E_0| = 2$。\n\n**集合 $E_1$：**\n下一个输入符号是 $a$。\n1.  **扫描器**：扫描 $E_0$ 中点在 $a$ 之前的项目。\n    - 从 $[S \\to \\bullet a C, 0]$，扫描 $a$ 并将 $[S \\to a \\bullet C, 0]$ 添加到 $E_1$ 中。\n2.  **预测器**：闭合 $E_1$。\n    - 对于 $[S \\to a \\bullet C, 0]$，预测起始索引为 1 的 $C$ 的规则。\n        - 将 $[C \\to \\bullet A, 1]$ 添加到 $E_1$ 中。\n        - 将 $[C \\to \\bullet B, 1]$ 添加到 $E_1$ 中。\n    - 对于新项目 $[C \\to \\bullet A, 1]$，预测起始索引为 1 的 $A$ 的规则。\n        - 将 $[A \\to \\bullet x, 1]$ 添加到 $E_1$ 中。\n    - 对于新项目 $[C \\to \\bullet B, 1]$，预测起始索引为 1 的 $B$ 的规则。\n        - 将 $[B \\to \\bullet y, 1]$ 添加到 $E_1$ 中。\n新项目中的点在终结符之前，因此不再进行预测。\n最终集合为 $E_1 = \\{ [S \\to a \\bullet C, 0], [C \\to \\bullet A, 1], [C \\to \\bullet B, 1], [A \\to \\bullet x, 1], [B \\to \\bullet y, 1] \\}$。\n基数为 $|E_1| = 5$。\n\n**集合 $E_2$：**\n下一个输入符号是 $x$。\n1.  **扫描器**：扫描 $E_1$ 中点在 $x$ 之前的项目。\n    - 从 $[A \\to \\bullet x, 1]$，扫描 $x$ 并将 $[A \\to x \\bullet, 1]$ 添加到 $E_2$ 中。\n2.  **完成器**：闭合 $E_2$。新项目 $[A \\to x \\bullet, 1]$ 是一个已完成项目 ($k=1$)。在 $E_1$ 中寻找形如 $[X \\to \\alpha \\bullet A \\beta, j]$ 的项目。\n    - 我们在 $E_1$ 中找到 $[C \\to \\bullet A, 1]$。将 $[C \\to A \\bullet, 1]$ 添加到 $E_2$ 中。\n3.  **完成器**：新项目 $[C \\to A \\bullet, 1]$ 是一个已完成项目 ($k=1$)。在 $E_1$ 中寻找形如 $[X \\to \\alpha \\bullet C \\beta, j]$ 的项目。\n    - 我们在 $E_1$ 中找到 $[S \\to a \\bullet C, 0]$。将 $[S \\to a C \\bullet, 0]$ 添加到 $E_2$ 中。\n4.  **完成器**：新项目 $[S \\to a C \\bullet, 0]$ 是一个已完成项目 ($k=0$)。在 $E_0$ 中寻找形如 $[X \\to \\alpha \\bullet S \\beta, j]$ 的项目。\n    - 我们在 $E_0$ 中找到 $[S_0 \\to \\bullet S, 0]$。将 $[S_0 \\to S \\bullet, 0]$ 添加到 $E_2$ 中。\n该集合现已闭合。\n最终集合为 $E_2 = \\{ [A \\to x \\bullet, 1], [C \\to A \\bullet, 1], [S \\to a C \\bullet, 0], [S_0 \\to S \\bullet, 0] \\}$。\n基数为 $|E_2| = 4$。\n\n**$G^{\\mathrm{lf}}$ 的总项目增长量：**\n总项目增长量是基数之和：\n$\\text{Total}(G^{\\mathrm{lf}}) = |E_0| + |E_1| + |E_2| = 2 + 5 + 4 = 11$。\n\n### 第 3 部分：计算比率 $R$\n\n问题要求计算 $G^{\\mathrm{lf}}$ 的总项目增长量与 $G$ 的总项目增长量之比。\n$R = \\frac{G^{\\mathrm{lf}} \\text{的总项目增长量}}{G \\text{的总项目增长量}}$\n$R = \\frac{11}{10}$。\n\n这个比率已经是一个简化的精确分数。",
            "answer": "$$\\boxed{\\frac{11}{10}}$$"
        },
        {
            "introduction": "从理论走向实践，这项练习  将挑战你实现 Earley 分析器，并应用一项关键优化：前瞻剪枝（lookahead pruning）。通过使用 $FIRST$ 集合来避免不必要的预测，你可以显著提高分析器的效率。这项实践不仅能巩固你对核心算法的理解，还能将其与编译器理论中的其他基本概念联系起来。",
            "id": "3639842",
            "problem": "您需要实现并分析带与不带基于 $FIRST$ 集的预测剪枝的 Earley 分析算法。该任务必须使用编译器原理中的核心定义来构建。一个上下文无关文法是一个元组 $\\mathcal{G} = (N, \\Sigma, P, S)$，其中 $N$ 是一个非终结符的有限集合，$\\Sigma$ 是一个终结符的有限集合，$P$ 是一个形如 $A \\rightarrow \\alpha$ 的产生式的有限集合，其中 $A \\in N$ 且 $\\alpha \\in (N \\cup \\Sigma)^{\\ast}$，$S \\in N$ 是开始符号。一个序列 $\\alpha$ 的 $FIRST$ 集定义为可以作为任何由 $\\alpha$ 推导出的字符串的第一个符号的终结符集合，如果 $\\alpha$ 能推导出 $\\epsilon$，则该集合还包含空串符号 $\\epsilon$。\n\nEarley 算法为每个输入位置 $k$ 维护一个项目表，项目形式为 $(X \\rightarrow \\alpha \\bullet \\beta, i)$，其中 $X \\rightarrow \\alpha \\beta$ 是一个产生式，$\\bullet$ 指示了在产生式右侧的当前位置，$i$ 是该项目开始的起始索引。三个基本操作是：预测、扫描和完成。预测操作为紧跟在 $\\bullet$ 后面的非终结符 $Y$ 的每个产生式添加项目 $(Y \\rightarrow \\bullet \\gamma, k)$。扫描操作在与下一个输入符号匹配的终结符上推进 $\\bullet$。完成操作推进那些其 $\\beta$ 部分以一个已完成的非终结符开始的项目。\n\n您必须实现该算法两次：一个执行所有预测的基准 Earley 分析器，以及一个仅当相对于当前向前看符号的 $FIRST$ 集成员关系合理时才执行预测的剪枝变体。具体来说，对于输入位置 $k$ 处的项目 $(X \\rightarrow \\alpha \\bullet Y \\beta, k)$，剪枝预测器仅在以下情况下才可添加 $(Y \\rightarrow \\bullet \\gamma, k)$：位置 $k$ 的向前看终结符 $t$ 满足 $t \\in FIRST(Y)$，或者 $\\epsilon \\in FIRST(Y)$（后者在 $Y$ 可以推导出空串时确保完备性）。在输入结束时（当 $k$ 等于输入长度时），剪枝必须仅在 $\\epsilon \\in FIRST(Y)$ 时才允许预测。\n\n从以下基本基础开始：\n- 上下文无关文法 $FIRST$ 集的定义，包括处理 $\\epsilon$ 推导：对于一个序列 $\\alpha_1 \\alpha_2 \\dots \\alpha_m$，$FIRST(\\alpha_1 \\alpha_2 \\dots \\alpha_m)$ 包含来自 $FIRST(\\alpha_1)$ 中除 $\\epsilon$ 之外的终结符，并且如果 $\\epsilon \\in FIRST(\\alpha_1)$，则还包含来自 $FIRST(\\alpha_2)$ 中除 $\\epsilon$ 之外的终结符，依此类推；如果每个 $\\alpha_j$ 都能推导出 $\\epsilon$，则 $\\epsilon$ 属于 $FIRST(\\alpha_1 \\alpha_2 \\dots \\alpha_m)$。\n- 根据项目表索引和产生式结构定义的 Earley 项目和操作。\n- 向前看符号的确定性解释：位置 $k$ 处的向前看终结符是输入符号 $w_k$（如果 $k$ 小于输入长度），否则不存在终结符，只允许基于 $\\epsilon$ 的预测。\n\n使用以下文法 $\\mathcal{G}$，其中 $FIRST(A) = \\{a, b\\}$ 得到满足：\n- 非终结符 $N = \\{S, A, C\\}$ 和开始符号 $S$。\n- 终结符 $\\Sigma = \\{a, b, c\\}$。\n- 产生式 $P$：\n  1. $S \\rightarrow A \\, C$\n  2. $A \\rightarrow a \\, A$\n  3. $A \\rightarrow a$\n  4. $A \\rightarrow b$\n  5. $C \\rightarrow c \\, C$\n  6. $C \\rightarrow \\epsilon$\n\n为了进行接受检查，使用一个合成的开始符号 $S'$ 和产生式 $S' \\rightarrow S$ 来增广文法。计算所有非终结符（包括 $S'$）的 $FIRST$ 集。\n\n您的程序必须：\n- 使用上述定义，通过不动点算法计算 $FIRST$ 集。\n- 在相同的项目表基础设施上实现两个分析器：基准 Earley 和剪枝 Earley。剪枝预测器必须仅在位置 $k$ 的向前看终结符 $t$ 满足 $t \\in FIRST(Y)$ 或 $\\epsilon \\in FIRST(Y)$ 时才添加 $(Y \\rightarrow \\bullet \\gamma, k)$。\n- 为每次分析跟踪两个可量化的指标：\n  - $p$：在所有项目表中，通过预测步骤添加的唯一项目的整数计数。\n  - $u$：在所有项目表中，通过所有步骤（预测、扫描、完成）添加的所有唯一项目的整数计数。\n\n对于接受条件，当且仅当项目 $(S' \\rightarrow S \\bullet, 0)$ 出现在索引等于输入长度的项目表中时，分析成功。\n\n测试套件：\n- 输入 $w_1 = \\text{\"accc\"}$。\n- 输入 $w_2 = \\text{\"b\"}$。\n- 输入 $w_3 = \\text{\"bc\"}$。\n- 输入 $w_4 = \\text{\"d\"}$。\n- 输入 $w_5 = \\text{\"\"}$ (空串)。\n- 输入 $w_6 = \\text{\"a\"}$。\n\n对于每个输入 $w_i$，运行两个分析器并报告一个列表 $[s_b, s_p, p_b, p_p, u_b, u_p]$，其中 $s_b$ 和 $s_p$ 分别是表示基准和剪枝分析器接受情况的 $0$ 或 $1$，$p_b$ 和 $p_p$ 分别是基准和剪枝分析器的预测计数，$u_b$ 和 $u_p$ 分别是基准和剪枝分析器的唯一项目总数。您的程序应生成单行输出，其中包含一个由逗号分隔的六元素列表组成的列表，并用方括号括起来，例如 $[[s_b, s_p, p_b, p_p, u_b, u_p], \\dots]$。\n\n最终输出格式必须恰好为一行：\n- 一个外部列表，按 $w_1$ 到 $w_6$ 的顺序包含每个测试用例的一个内部列表。\n- 输出中没有空白字符。\n- 所有条目必须是整数。\n\n此问题不涉及物理单位或角度；所有数字输出必须是纯整数。",
            "solution": "该解决方案源于编译器理论的第一性原理，依赖于 $FIRST$ 集和 Earley 算法的正式定义。一个上下文无关文法 $\\mathcal{G} = (N, \\Sigma, P, S)$ 通过产生式指定推导。符号序列的 $FIRST$ 集决定了哪个终结符可以作为从该序列推导出的任何字符串的第一个符号，以及是否可以推导出空串 $\\epsilon$。\n\n$FIRST$ 集的计算使用单调不动点方法。对每个非终结符 $A \\in N$，初始化 $FIRST(A)$ 为空，当 $A \\rightarrow \\epsilon$ 存在时标记 $\\epsilon \\in FIRST(A)$。然后，迭代地对每个产生式 $A \\rightarrow \\alpha_1 \\alpha_2 \\dots \\alpha_m$ 执行以下操作：\n- 从 $j=1$ 到 $m$，将 $FIRST(\\alpha_j)$ 中除 $\\epsilon$ 以外的终结符并入 $FIRST(A)$。如果 $\\epsilon \\in FIRST(\\alpha_j)$，则继续到 $j+1$；否则，停止。\n- 如果每个 $\\alpha_j$ 都能推导出 $\\epsilon$（包括 $m=0$ 的情况），则将 $\\epsilon$ 包含在 $FIRST(A)$ 中。\n当没有 $FIRST$ 集再增长时，此过程终止。根据定义，对于终结符 $a \\in \\Sigma$，$FIRST(a) = \\{a\\}$。\n\nEarley 算法对存储在按输入位置 $k$ 索引的项目表中的项目 $(X \\rightarrow \\alpha \\bullet \\beta, i)$ 进行操作。它执行三个操作，直到没有新项目被添加到项目表中：\n- 预测：如果 $\\beta$ 以非终结符 $Y$ 开始，则为所有产生式 $Y \\rightarrow \\gamma$ 添加项目 $(Y \\rightarrow \\bullet \\gamma, k)$。\n- 扫描：如果 $\\beta$ 以终结符 $t$ 开始，且下一个输入符号是 $t$，则在项目表 $k + 1$ 中前进到 $(X \\rightarrow \\alpha t \\bullet \\beta', i)$。\n- 完成：如果在项目表 $k$ 中完成了一个项目 $(Y \\rightarrow \\gamma \\bullet, j)$，则将项目表 $j$ 中的任何项目 $(X \\rightarrow \\alpha \\bullet Y \\beta, i)$ 在项目表 $k$ 中推进到 $(X \\rightarrow \\alpha Y \\bullet \\beta, i)$。\n\n如果在索引等于输入长度的项目表中出现 $(S' \\rightarrow S \\bullet, 0)$，则接受成立。为了比较基准和剪枝的预测策略，我们引入一个基于 $FIRST$ 集的剪枝规则。当遇到一个项目 $(X \\rightarrow \\alpha \\bullet Y \\beta, k)$ 时：\n- 设 $t$ 为位置 $k$ 处的向前看终结符（如果 $k$ 小于输入长度）。如果 $t \\in FIRST(Y)$，则允许对 $(Y \\rightarrow \\bullet \\gamma, k)$ 进行预测。\n- 如果 $\\epsilon \\in FIRST(Y)$，则始终允许预测（包括在输入结束时），因为 $Y$ 可以在不消耗输入的情况下推导出 $\\epsilon$；禁止此类预测会阻止必要的完成步骤，从而破坏完备性。\n- 在输入结束时，只允许在 $\\epsilon \\in FIRST(Y)$ 的情况下进行预测。\n\n此规则保留了完备性，因为任何需要 $Y$ 匹配终结符 $t$ 的推导都必须有 $t \\in FIRST(Y)$，因此剪枝所不允许的预测无法产生成功的扫描。如果 $Y$ 可以推导出 $\\epsilon$，剪枝允许独立于向前看符号进行预测，确保完成步骤仍然可以用于在不消耗输入的情况下推进越过 $Y$ 的项目。因此，剪枝不会移除任何可能导致接受的推导，但在向前看终结符不在 $FIRST(Y)$ 中时，它会减少预测项目的数量。\n\n对于给定的文法：\n- $S \\rightarrow A \\, C$,\n- $A \\rightarrow a \\, A \\mid a \\mid b$,\n- $C \\rightarrow c \\, C \\mid \\epsilon$,\n我们计算出 $FIRST(A) = \\{a, b\\}$，$FIRST(C) = \\{c, \\epsilon\\}$，以及 $FIRST(S) = FIRST(A) = \\{a, b\\}$，因为 $A$ 不能推导出 $\\epsilon$。增广的开始符号 $S'$ 满足 $FIRST(S') = FIRST(S) = \\{a, b\\}$。\n\n我们实现了共享项目表基础设施和项目表示的两个分析器。我们强制项目的唯一性以确保终止和准确的度量。对于每个输入 $w_i$，我们记录：\n- $s_b$：基准接受情况（$1$ 表示成功，$0$ 表示失败），\n- $s_p$：剪枝接受情况（$1$ 表示成功，$0$ 表示失败），\n- $p_b$：基准分析中添加的预测项目计数，\n- $p_p$：剪枝分析中添加的预测项目计数，\n- $u_b$：基准分析中添加的唯一项目总数，\n- $u_p$：剪枝分析中添加的唯一项目总数。\n\n解释测试套件：\n- 对于 $w_1 = \\text{\"accc\"}$，预期会接受，因为 $A$ 推导出 $\\text{\"a\"}$ 且 $C$ 推导出 $\\text{\"ccc\"}$。当向前看符号与预期的非终结符的 $FIRST$ 集不一致时，剪枝应减少预测。\n- 对于 $w_2 = \\text{\"b\"}$，预期会接受，因为 $A$ 推导出 $\\text{\"b\"}$ 且 $C$ 推导出 $\\epsilon$；由于 $\\epsilon \\in FIRST(C)$，剪枝应保持完备性。\n- 对于 $w_3 = \\text{\"bc\"}$，预期会接受，因为 $A$ 推导出 $\\text{\"b\"}$ 且 $C$ 推导出 $\\text{\"c\"}$；剪枝应该是安全的。\n- 对于 $w_4 = \\text{\"d\"}$，预期会失败，因为 $\\text{\"d\"} \\notin FIRST(S)$；剪枝将避免在起始项目表中的许多预测。\n- 对于 $w_5 = \\text{\"\"}$，预期会失败，因为 $A$ 不能推导出 $\\epsilon$；剪枝会阻止在位置 0 对 $A$ 进行不必要的预测，而基准分析器仍会探索这些项目。\n- 对于 $w_6 = \\text{\"a\"}$，预期会接受，因为 $A$ 推导出 $\\text{\"a\"}$ 且 $C$ 推导出 $\\epsilon$。\n\n最终程序构建文法，通过不动点迭代计算 $FIRST$ 集，运行两个分析器，聚合每个测试用例的指标，并以所需的无空格嵌套列表格式打印单行结果。这证明了剪枝预测器的完备性保持，并通过项目计数来量化性能变化。",
            "answer": "[[1,1,15,9,39,31],[1,1,9,7,17,15],[1,1,12,9,26,23],[0,0,4,0,5,1],[0,0,6,2,7,3],[1ayana1,9,7,17,15]]"
        }
    ]
}