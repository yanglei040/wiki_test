{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握程序依赖图，第一步是能够从代码的控制流图中精确地推导出控制依赖关系。这个练习将指导你应用后支配（post-dominator）的正式定义，为一个包含嵌套循环和条件语句的复杂代码片段构建控制依赖图。通过这个过程，你将加深对程序执行如何受分支决策控制的理解，这是后续进行程序分析和优化的基础。",
            "id": "3664766",
            "problem": "给定以下带有行号标签的命令式伪代码结构化片段。所有赋值和条件都以数学符号表示，为了清晰起见，每个可执行行都标记为 $L_{k}$。在 return 语句之后紧跟着一个唯一的出口节点 $E$。\n\n$L_{1}$: $s := 0$\n\n$L_{2}$: $i := 0$\n\n$L_{3}$: while $\\big(i < n\\big)$ do\n- $L_{4}$: if $\\big(p(i)\\big)$ then\n  - $L_{5}$: $s := s + a[i]$\n  - $L_{6}$: if $\\big(q(i)\\big)$ then\n    - $L_{7}$: $s := s + 1$\n    - else\n    - $L_{9}$: $s := s - 1$\n- else\n  - $L_{12}$: $j := 0$\n  - $L_{13}$: while $\\big(j < m\\big)$ do\n    - $L_{14}$: if $\\big(r(j)\\big)$ then\n      - $L_{15}$: $s := s + b[j]$\n    - end if\n    - $L_{17}$: $j := j + 1$\n  - end while\n- end if\n- $L_{20}$: $i := i + 1$\nend while\n\n$L_{22}$: return $s$\n\n$E$: exit\n\n为此代码片段构建控制流图（CFG），然后构建程序依赖图（PDG），仅关注控制依赖。在具有唯一出口节点的 CFG 上，使用基于后支配节点的标准控制依赖定义。具体来说，当且仅当存在 $X$ 的一个后继节点 $W$，使得 $Y$ 后支配 $W$ 且 $Y$ 不后支配 $X$ 时，节点 $Y$ 控制依赖于节点 $X$。当且仅当从 $V$ 到 $E$ 的每一条路径都经过 $U$ 时，节点 $U$ 后支配节点 $V$。\n\n将每个谓词行（$L_{3}$, $L_{4}$, $L_{6}$, $L_{13}$, $L_{14}$）和每个可执行语句行（$L_{1}$, $L_{2}$, $L_{5}$, $L_{7}$, $L_{9}$, $L_{12}$, $L_{15}$, $L_{17}$, $L_{20}$, $L_{22}$）视为 PDG 节点。忽略任何特殊的入口节点，不要从任何人为的起始节点添加控制依赖边。不要将出口节点 $E$ 作为 PDG 节点。\n\n你的任务是：基于上述定义和此代码的 CFG，识别 PDG 中所有的控制依赖边，并计算这些边的总数。以精确整数形式提供最终答案（不要四舍五入）。",
            "solution": "用户希望确定给定代码片段的程序依赖图（PDG）中控制依赖边的总数。该分析将基于所提供的、使用后支配节点的控制依赖定义。\n\n解决过程包括三个连续的步骤：\n1.  为给定代码构建控制流图（CFG）。\n2.  确定 CFG 中每个节点的后支配节点集。\n3.  应用给定的控制依赖定义来识别所有控制依赖边并进行计数。\n\n### 第 1 步：构建控制流图（CFG）\n\nCFG 的节点对应于伪代码的带标签行和一个唯一的出口节点 $E$。边代表这些行之间的控制流。\n\nCFG 的边如下：\n- $L_{1} \\to L_{2}$\n- $L_{2} \\to L_{3}$\n- $L_{3} \\to L_{4}$ (`while` 的真分支)\n- $L_{3} \\to L_{22}$ (`while` 的假分支)\n- $L_{4} \\to L_{5}$ (`if p(i)` 的真分支)\n- $L_{4} \\to L_{12}$ (`if p(i)` 的假分支)\n- $L_{5} \\to L_{6}$\n- $L_{6} \\to L_{7}$ (`if q(i)` 的真分支)\n- $L_{6} \\to L_{9}$ (`if q(i)` 的假分支)\n- $L_{7} \\to L_{20}$ (`if q(i)` 真分支的结尾)\n- $L_{9} \\to L_{20}$ (`if q(i)` 假分支的结尾)\n- $L_{12} \\to L_{13}$\n- $L_{13} \\to L_{14}$ (`while` 的真分支)\n- $L_{13} \\to L_{20}$ (`while` 的假分支)\n- $L_{14} \\to L_{15}$ (`if r(j)` 的真分支)\n- $L_{14} \\to L_{17}$ (`if r(j)` 的假分支)\n- $L_{15} \\to L_{17}$ (`if r(j)` 真分支的结尾)\n- $L_{17} \\to L_{13}$ (循环返回)\n- $L_{20} \\to L_{3}$ (循环返回)\n- $L_{22} \\to E$\n\n### 第 2 步：确定后支配节点\n\n如果从节点 $V$ 到出口节点 $E$ 的每一条路径都包含节点 $U$，则节点 $U$ 后支配节点 $V$。我们将 $V$ 的后支配节点集表示为 $\\text{pdom}(V)$。我们将此定义应用于 CFG 中的每个节点。\n\n- $\\text{pdom}(E) = \\{E\\}$\n- 从 $L_{22}$ 到 $E$ 的唯一路径是 $L_{22} \\to E$。因此，$\\text{pdom}(L_{22}) = \\{L_{22}, E\\}$。\n- 从代码中的任何节点出发，到 $E$ 的每一条路径都必须经过 $L_{22}$。因此，$L_{22}$ 后支配所有其他节点。\n- 从外部 `while` 循环内部的任何节点（从 $L_4$ 到 $L_{20}$）出发，任何路径最终都必须通过边 $L_3 \\to L_{22}$ 退出循环或通过循环体返回到$L_3$。所有离开循环体的路径都会汇合到$L_3$。因此，对于循环体内任何会返回自身的节点（例如，$L_{20}$），$L_3$ 是一个后支配节点。\n- 通过系统地分析 CFG，我们确定每个相关节点的后支配节点集：\n  - $\\text{pdom}(L_{22}) = \\{L_{22}, E\\}$\n  - $\\text{pdom}(L_{20}) = \\{L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{17}) = \\{L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{15}) = \\{L_{15}\\} \\cup \\text{pdom}(L_{17}) = \\{L_{15}, L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{14})$: 从 $L_{14}$ 出发的路径在 $L_{17}$ 处汇合。因此，$\\text{pdom}(L_{14}) = \\{L_{14}\\} \\cup \\text{pdom}(L_{17}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{13})$: 从 $L_{13}$ 出发的路径可以循环，但最终必须退出到 $L_{20}$。因此，$\\text{pdom}(L_{13}) = \\{L_{13}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{13}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{12}) = \\{L_{12}\\} \\cup \\text{pdom}(L_{13}) = \\{L_{12}, L_{13}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{9}) = \\{L_{9}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{9}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{7}) = \\{L_{7}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{7}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{6})$: 从 $L_6$ 出发的路径在 $L_{20}$ 处汇合。因此，$\\text{pdom}(L_{6}) = \\{L_{6}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{6}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{5}) = \\{L_{5}\\} \\cup \\text{pdom}(L_{6}) = \\{L_{5}, L_{6}, L_{20}, L_{3}, L_{22}, E\\}$\n  - $\\text{pdom}(L_{4})$: 从 $L_4$ 出发的路径在 $L_{20}$ 处汇合。因此，$\\text{pdom}(L_{4}) = \\{L_{4}\\} \\cup \\text{pdom}(L_{20}) = \\{L_{4}, L_{20}, L_{3}, L_{22}, E\\}$。\n  - $\\text{pdom}(L_{3})$: 从 $L_3$ 出发的路径可以循环，但最终必须退出到 $L_{22}$。因此，$\\text{pdom}(L_{3}) = \\{L_{3}\\} \\cup \\text{pdom}(L_{22}) = \\{L_{3}, L_{22}, E\\}$。\n\n### 第 3 步：应用控制依赖的定义\n\n问题陈述为：“当且仅当存在 $X$ 的一个后继节点 $W$，使得 $Y$ 后支配 $W$ 且 $Y$ 不后支配 $X$ 时，节点 $Y$ 控制依赖于节点 $X$。” 我们用 $X \\to_c Y$ 来表示。我们将此定义应用于每个谓词节点 $X$。\n\n**1. $X = L_3$ (谓词 `while i < n`)**\n- $X$ 的后继节点：$W_T = L_4$, $W_F = L_{22}$。\n- 条件：$Y \\notin \\text{pdom}(L_3) = \\{L_3, L_{22}, E\\}$。\n- 对于 $W = L_4$：$Y \\in \\text{pdom}(L_4) = \\{L_4, L_{20}, L_3, L_{22}, E\\}$。同时满足两个条件的节点是 $Y=L_4$ 和 $Y=L_{20}$。\n- 对于 $W = L_{22}$：$Y \\in \\text{pdom}(L_{22}) = \\{L_{22}, E\\}$。没有节点 $Y$ 能同时满足两个条件。\n- 边：$(L_3, L_4), (L_3, L_{20})$。总计：2。\n\n**2. $X = L_4$ (谓词 `if p(i)`)**\n- $X$ 的后继节点：$W_T = L_5$, $W_F = L_{12}$。\n- 条件：$Y \\notin \\text{pdom}(L_4) = \\{L_4, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_5$：$Y \\in \\text{pdom}(L_5) = \\{L_5, L_6, L_{20}, L_3, L_{22}, E\\}$。同时满足两个条件的节点是 $Y=L_5$ 和 $Y=L_6$。\n- 对于 $W = L_{12}$：$Y \\in \\text{pdom}(L_{12}) = \\{L_{12}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。同时满足两个条件的节点是 $Y=L_{12}$ 和 $Y=L_{13}$。\n- 边：$(L_4, L_5), (L_4, L_6), (L_4, L_{12}), (L_4, L_{13})$。总计：4。\n\n**3. $X = L_6$ (谓词 `if q(i)`)**\n- $X$ 的后继节点：$W_T = L_7$, $W_F = L_9$。\n- 条件：$Y \\notin \\text{pdom}(L_6) = \\{L_6, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_7$：$Y \\in \\text{pdom}(L_7) = \\{L_7, L_{20}, L_3, L_{22}, E\\}$。满足两个条件的节点是 $Y=L_7$。\n- 对于 $W = L_9$：$Y \\in \\text{pdom}(L_9) = \\{L_9, L_{20}, L_3, L_{22}, E\\}$。满足两个条件的节点是 $Y=L_9$。\n- 边：$(L_6, L_7), (L_6, L_9)$。总计：2。\n\n**4. $X = L_{13}$ (谓词 `while j < m`)**\n- $X$ 的后继节点：$W_T = L_{14}$, $W_F = L_{20}$。\n- 条件：$Y \\notin \\text{pdom}(L_{13}) = \\{L_{13}, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_{14}$：$Y \\in \\text{pdom}(L_{14}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。同时满足两个条件的节点是 $Y=L_{14}$ 和 $Y=L_{17}$。\n- 对于 $W = L_{20}$：$Y \\in \\text{pdom}(L_{20}) = \\{L_{20}, L_3, L_{22}, E\\}$。没有节点 $Y$ 能同时满足两个条件。\n- 边：$(L_{13}, L_{14}), (L_{13}, L_{17})$。总计：2。\n\n**5. $X = L_{14}$ (谓词 `if r(j)`)**\n- $X$ 的后继节点：$W_T = L_{15}$, $W_F = L_{17}$。\n- 条件：$Y \\notin \\text{pdom}(L_{14}) = \\{L_{14}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。\n- 对于 $W = L_{15}$：$Y \\in \\text{pdom}(L_{15}) = \\{L_{15}, L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。满足两个条件的节点是 $Y=L_{15}$。\n- 对于 $W = L_{17}$：$Y \\in \\text{pdom}(L_{17}) = \\{L_{17}, L_{13}, L_{20}, L_3, L_{22}, E\\}$。没有节点 $Y$ 能同时满足这两个条件，因为任何这样的 $Y$ 也都在 $\\text{pdom}(L_{14})$ 中。\n- 边：$(L_{14}, L_{15})$。总计：1。\n\n### 最终计数\n将来自每个谓词节点的控制依赖边数量相加：\n- 来自 $L_3$：$2$ 条边\n- 来自 $L_4$：$4$ 条边\n- 来自 $L_6$：$2$ 条边\n- 来自 $L_{13}$：$2$ 条边\n- 来自 $L_{14}$：$1$ 条边\n\n总边数 = $2 + 4 + 2 + 2 + 1 = 11$。",
            "answer": "$$\\boxed{11}$$"
        },
        {
            "introduction": "识别出控制依赖后，我们能用它做什么呢？这个练习探讨了编译器中的一个重要优化技术：条件选择转换（if-conversion）。通过这个练习 ，你将看到分支（一种控制依赖）如何被巧妙地替换为带谓词的计算（一种数据依赖）。这个转换过程不仅能提升在某些现代处理器上的性能，也直观地展示了控制依赖和数据依赖之间的深刻联系。",
            "id": "3664735",
            "problem": "考虑以下结构化代码片段及其控制流图（CFG）：\n\n- 代码：\n  - if ($x > 0$) then { $y := x + 1$ } else { $y := 0$ }\n  - $z := y * 2$\n\n- CFG 节点和边：\n  - $B_0$ (入口) $\\to B_1$\n  - $B_1$：基于 ($x > 0$) 的条件，真边到 $B_2$，假边到 $B_3$\n  - $B_2$：$y := x + 1$，然后 $\\to B_4$\n  - $B_3$：$y := 0$，然后 $\\to B_4$\n  - $B_4$：$z := y * 2$，然后退出\n\n使用编译器理论中的标准定义：\n\n- 程序依赖图（PDG）中的控制依赖：一个节点 $Y$ 控制依赖于一个节点 $X$，当且仅当 (i) 存在一条从 $X$ 到 $Y$ 的路径，在该路径上 $Y$ 后支配（post-dominates）除 $X$ 之外的所有节点，并且 (ii) $Y$ 不后支配 $X$。\n- 控制流图（CFG）中的后支配：如果从节点 $B$到出口（exit）的每条路径都包含节点 $A$，则节点 $A$ 后支配节点 $B$。\n\n现在执行 if-conversion（谓词化），通过引入谓词 $p := (x > 0)$ 和一个直线计算 $y := select(p, x + 1, 0)$ 来移除分支，随后是 $z := y * 2$。假设 $select(p, t, e)$ 在 $p$ 为真时表示值 $t$，在 $p$ 为假时表示值 $e$。\n\n问题：哪个陈述正确地描述了 if-conversion 前后 $PDG$ 中的控制依赖关系，并指明了为反映基于分支的控制依赖的移除而对 $PDG$ 进行的正确更新？\n\n选择一项：\n\nA. if-conversion 之前：存在从分支节点 $B_1$ 到 $y := x + 1$（在 $B_2$ 中）和到 $y := 0$（在 $B_3$ 中）的控制依赖边，但不存在到 $z := y * 2$（在 $B_4$ 中）的控制依赖边。if-conversion 之后：基于分支的控制依赖被移除；没有控制依赖从 $p$ 发出，并且 $PDG$ 获得了一个从 $p$ 的定义到定义 $y$ 的 $select$ 的数据依赖。\n\nB. if-conversion 之前：存在从 $B_1$ 到 $y := x + 1$、到 $y := 0$ 以及到 $z := y * 2$ 的控制依赖边。if-conversion 之后：控制依赖仍然存在，因为 $z$ 在语义上仍然依赖于该条件，所以 $PDG$ 保留了从 $p$ 到 $z$ 的控制依赖。\n\nC. if-conversion 之前：只有 $y := 0$ 控制依赖于 $B_1$，因为它位于假边上；$y := x + 1$ 不是控制依赖的。if-conversion 之后：$y$ 和 $z$ 都控制依赖于 $p$。\n\nD. if-conversion 之前：不存在控制依赖，因为两个分支在 $B_4$ 处重新汇合。if-conversion 之后：引入一个从 $p$ 到 $z$ 的控制依赖，因为 $z$ 跟在 $y$ 的选择之后。",
            "solution": "### 解答推导\n\n#### 第 1 部分：If-Conversion 前的分析\n\n我们必须使用所提供的定义来确定原始 CFG 中的控制依赖。这首先需要建立后支配关系。`exit` 节点是 CFG 的单一出口点。\n\n1.  **后支配分析**：\n    -   从 `$B_1$`、`$B_2$` 或 `$B_3$` 出发的任何路径都必须经过 `$B_4$` 才能到达 `exit` 节点。例如，从 `$B_1$` 到 `exit` 有两条路径：`$B_1 \\to B_2 \\to B_4 \\to \\text{exit}$` 和 `$B_1 \\to B_3 \\to B_4 \\to \\text{exit}$`。两条路径都包含 `$B_4$`。因此，`$B_4$` 后支配 `$B_1$`、`$B_2$` 和 `$B_3$`。\n    -   `$B_2$` 是否后支配 `$B_1$`？不是，因为存在一条从 `$B_1$` 到 `exit` 的路径绕过了 `$B_2$`（即通过 `$B_3$` 的路径）。\n    -   `$B_3$` 是否后支配 `$B_1$`？不是，因为存在一条从 `$B_1$` 到 `exit` 的路径绕过了 `$B_3$`（即通过 `$B_2$` 的路径）。\n\n2.  **控制依赖分析**：我们应用定义：`$Y$` 控制依赖于 `$X$`，如果 (i) 存在一条从 `$X$`到 `$Y$` 的路径，其中 `$Y$` 后支配 `$X$` 和 `$Y$` 之间的所有节点，并且 (ii) `$Y$` 不后支配 `$X$`。令 `$X = B_1$`。\n\n    -   **`$B_2$`（包含 `$y := x + 1$`）是否控制依赖于 `$B_1$`？**\n        -   (i) 考虑路径 `$B_1 \\to B_2$`。没有中间节点，因此 `$B_2$` 后支配 `$B_1$` 和 `$B_2$` 之间的所有节点的条件是空真（vacuously true）。\n        -   (ii) `$B_2$` 是否不后支配 `$B_1$`？是的，如上所述。\n        -   结论：**是**，`$B_2$` 控制依赖于 `$B_1$`。存在一条从 `$B_1$` 到 `$B_2$` 的控制依赖边。\n\n    -   **`$B_3$`（包含 `$y := 0$`）是否控制依赖于 `$B_1$`？**\n        -   (i) 考虑路径 `$B_1 \\to B_3$`。没有中间节点，因此该条件是空真。\n        -   (ii) `$B_3$` 是否不后支配 `$B_1$`？是的，如上所述。\n        -   结论：**是**，`$B_3$` 控制依赖于 `$B_1$`。存在一条从 `$B_1$` 到 `$B_3$` 的控制依赖边。\n\n    -   **`$B_4$`（包含 `$z := y * 2$`）是否控制依赖于 `$B_1$`？**\n        -   (i) 考虑路径 `$B_1 \\to B_2 \\to B_4$`。中间节点是 `$B_2$`。`$B_4$` 是否后支配 `$B_2$`？是的。对于这条路径，该条件成立。\n        -   (ii) `$B_4$` 是否不后支配 `$B_1$`？不，这是错误的。我们已经确定 `$B_4$` *确实* 后支配 `$B_1$`，因为所有从 `$B_1$` 出发的路径都必须经过 `$B_4$`。\n        -   结论：**否**，`$B_4$` 不控制依赖于 `$B_1$`，因为条件 (ii) 不满足。\n\n    **“之前”的总结**：`$B_2$` 和 `$B_3$` 中的语句控制依赖于 `$B_1$` 中的分支。`$B_4$` 中的语句则不是。\n\n#### 第 2 部分：If-Conversion 后的分析\n\n代码被转换为一个直线序列：\n1.  `$p := (x > 0)$`\n2.  `$y := select(p, x + 1, 0)$`\n3.  `$z := y * 2$`\n\n1.  **控制流**：这个指令序列构成一个单一的基本块。现在的 CFG 非常简单：`$B'_{entry} \\to B'_{code} \\to B'_{exit}$`。没有分支。\n\n2.  **控制依赖**：由于转换后的 CFG 中没有条件分支，因此在控制流意义上，不存在其他节点的执行依赖于某个节点的情况。由分支产生的控制依赖概念在直线代码中是不存在的。因此，在转换后的程序中不存在控制依赖。\n\n3.  **PDG 更新**：从 `$B_1$` 到 `$B_2$` 和 `$B_3$` 的原始控制依赖被移除。If-conversion 的目的就是将控制依赖转换为数据依赖。\n    -   `$y$` 的值现在依赖于谓词 `$p$` 的值。这创建了一个从 `$p$` 的定义（`$p := (x > 0)$`）到 `$p$` 在 `$select$` 指令中的使用（`$y := select(p, ...)$`）的**数据依赖**。\n    -   从 `$y$` 的定义到其在 `$z := y * 2$` 中使用的原有数据依赖保持不变。\n\n    **“之后”的总结**：基于分支的控制依赖被消除。它们被一个新的、从谓词定义到其使用的数据依赖所取代。\n\n### 逐项分析\n\n-   **A. if-conversion 之前：存在从分支节点 $B_1$ 到 $y := x + 1$（在 $B_2$ 中）和到 $y := 0$（在 $B_3$ 中）的控制依赖边，但不存在到 $z := y * 2$（在 $B_4$ 中）的控制依赖边。if-conversion 之后：基于分支的控制依赖被移除；没有控制依赖从 $p$ 发出，并且 $PDG$ 获得了一个从 $p$ 的定义到定义 $y$ 的 $select$ 的数据依赖。**\n    -   “之前”的描述与我们的推导完全一致。`$B_2$` 和 `$B_3$` 控制依赖于 `$B_1$`，但 `$B_4$` 不是。\n    -   “之后”的描述也完全一致。If-conversion 移除了分支及其相关的控制依赖。形式模型用对谓词 `$p$` 的数据依赖来取代它。\n    -   **结论：正确。**\n\n-   **B. if-conversion 之前：存在从 $B_1$ 到 $y := x + 1$、到 $y := 0$ 以及到 $z := y * 2$ 的控制依赖边。if-conversion 之后：控制依赖仍然存在，因为 $z$ 在语义上仍然依赖于该条件，所以 $PDG$ 保留了从 $p$ 到 $z$ 的控制依赖。**\n    -   “之前”部分不正确。它错误地声称 `$z := y * 2$`（在 `$B_4$` 中）控制依赖于 `$B_1$`。如前所示，`$B_4$` 后支配 `$B_1$`，这违反了控制依赖的定义。\n    -   “之后”部分不正确。它将语义依赖与控制依赖的形式化定义混淆了。在 if-conversion 之后，没有分支，因此没有控制依赖。语义上的联系由数据依赖来捕获。\n    -   **结论：不正确。**\n\n-   **C. if-conversion 之前：只有 $y := 0$ 控制依赖于 $B_1$，因为它位于假边上；$y := x + 1$ 不是控制依赖的。if-conversion 之后：$y$ 和 $z$ 都控制依赖于 $p$。**\n    -   “之前”部分不正确。控制依赖的定义对称地适用于不后支配分支节点的真、假后继路径。`$B_2$` 和 `$B_3$` 都控制依赖于 `$B_1$`。\n    -   “之后”部分不正确。如选项 B 的解释，转换后的直线代码中不存在控制依赖。\n    -   **结论：不正确。**\n\n-   **D. if-conversion 之前：不存在控制依赖，因为两个分支在 $B_4$ 处重新汇合。if-conversion 之后：引入一个从 $p$ 到 $z$ 的控制依赖，因为 $z$ 跟在 $y$ 的选择之后。**\n    -   “之前”部分不正确。在 `$B_4$` 处的重新汇合是 `$B_4$` *不* 控制依赖于 `$B_1$` 的原因，但这也正是为什么在分叉路径上的节点*是*控制依赖的。该陈述误解了重新汇合的后果。\n    -   “之后”部分不正确。它错误地指出引入了*控制*依赖。If-conversion 用*数据*依赖取代了控制依赖。\n    -   **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "程序依赖图的另一半关键是数据依赖，它描述了数据在语句之间的流动。分析循环迭代之间的数据流对于自动并行化至关重要，这是现代编译器最重要的优化之一。本练习  将带你深入一个循环的内部，通过分析数组访问来识别“循环携带依赖”（loop-carried dependences），并最终判断这种依赖是否阻碍了循环的并行执行。",
            "id": "3664740",
            "problem": "考虑以下关于整数归纳变量 $i$ 的单循环：\n- 对于 $i$ 从 $2$ 到 $N-1$（其中 $N \\geq 6$）的范围，执行由三个语句组成的循环体：\n  - $S_1$: $X[i+2] := Y[i] + Z[i-1]$，\n  - $S_2$: $Y[i+1] := X[i] + W[i]$，\n  - $S_3$: $Z[i-1] := Y[i-2] + 5$。\n假设数组 $X$, $Y$, $Z$ 和 $W$ 的大小和初始化均已设置，以使所有使用的下标均有效，并且其语义为某种语言中循环的标准顺序语义，该语言在每次迭代中具有单次赋值的语句执行和严格的求值顺序 $S_1$ 然后 $S_2$ 然后 $S_3$。\n\n在程序依赖图（PDG）中，节点对应于语句 $S_1$, $S_2$ 和 $S_3$，边表示控制依赖和数据依赖。从源语句到汇点语句的真数据依赖（流依赖）存在于源语句写入一个内存位置而汇点语句随后读取该位置的情况下，而当源和汇点处于不同迭代中时，存在循环携带的真数据依赖。为了确定并行化的合法性，可以忽略反依赖和输出依赖，因为它们可以通过重命名来消除。\n\n仅使用真数据依赖、循环携带依赖的基本定义，以及两个数组访问当且仅当下标相等时引用相同内存位置这一事实，分析由循环体导出的 PDG 以：\n- 根据 $S_1$, $S_2$ 和 $S_3$ 中的数组下标，提取循环携带的真数据依赖距离集合。\n- 令 $\\mathcal{D}$ 表示此循环中存在的所有循环携带真依赖的正整数距离 $d$ 的集合。如果 $\\mathcal{D}$ 非空，定义 $d^{\\star}$ 为 $\\mathcal{D}$ 的最小元素。\n- 将在标准语义下跨迭代并行化循环的合法性指标 $L$ 定义为：如果循环可以合法地并行化（即，不存在循环携带的真数据依赖），则 $L=1$；否则 $L=0$。\n\n以包含 $d^{\\star}$ 和 $L$ 的行矩阵形式提供最终答案。无需四舍五-入，也无需单位。如果 $\\mathcal{D}$ 为空，则按惯例取 $d^{\\star}$ 为 $0$。",
            "solution": "为了解决这个问题，我们需要系统地识别在给定循环中所有语句对之间存在的循环携带的真（流）数据依赖。流依赖（写后读）发生于一个语句在某次迭代中写入一个内存位置，而另一个语句在稍后的迭代中读取同一个位置。依赖距离是两次迭代的索引之差。\n\n循环的语句如下：\n- $S_1(i)$: $X[i+2] := Y[i] + Z[i-1]$\n- $S_2(i)$: $Y[i+1] := X[i] + W[i]$\n- $S_3(i)$: $Z[i-1] := Y[i-2] + 5$\n\n我们寻找从迭代 $i$ 的语句 $S_a$ 到迭代 $j$ 的语句 $S_b$ 的依赖，其中 $i < j$。依赖距离为 $d = j - i > 0$。\n\n1.  **`S1` 写入 `X`，`S2` 读取 `X`**\n    -   `S1(i)` 写入 `X[i+2]`。\n    -   `S2(j)` 读取 `X[j]`。\n    -   依赖存在于 `i+2 = j`。\n    -   因为 `j = i+2`，所以 `j > i`。这是一个合法的循环携带依赖。\n    -   依赖距离 $d = j - i = (i+2) - i = 2$。\n\n2.  **`S2` 写入 `Y`，`S1` 读取 `Y`**\n    -   `S2(i)` 写入 `Y[i+1]`。\n    -   `S1(j)` 读取 `Y[j]`。\n    -   依赖存在于 `i+1 = j`。\n    -   因为 `j = i+1`，所以 `j > i`。这是一个合法的循环携带依赖。\n    -   依赖距离 $d = j - i = (i+1) - i = 1$。\n\n3.  **`S2` 写入 `Y`，`S3` 读取 `Y`**\n    -   `S2(i)` 写入 `Y[i+1]`。\n    -   `S3(j)` 读取 `Y[j-2]`。\n    -   依赖存在于 `i+1 = j-2`，即 `j = i+3`。\n    -   因为 `j = i+3`，所以 `j > i`。这是一个合法的循环携带依赖。\n    -   依赖距离 $d = j - i = (i+3) - i = 3$。\n\n4.  **`S3` 写入 `Z`，`S1` 读取 `Z`**\n    -   `S3(i)` 写入 `Z[i-1]`。\n    -   `S1(j)` 读取 `Z[j-1]`。\n    -   依赖存在于 `i-1 = j-1`，即 `i = j`。\n    -   这是一个循环独立依赖（距离为0），不是循环携带依赖。然而，我们还必须检查执行顺序。在一次迭代中，`S1` 在 `S3` *之前* 执行。因此，`S1(i)` 在 `S3(i)` 写入 `Z[i-1]` 之前读取了该位置。这是一个反依赖（读后写），而不是真依赖（写后读）。根据题目要求，我们可以忽略反依赖。因此，此处不存在循环携带的真数据依赖。\n\n5.  **其他组合**\n    -   `S1` 写入 `X`，`S1`, `S3` 不读取 `X`。\n    -   `S2` 写入 `Y`，`S2` 不读取 `Y`。\n    -   `S3` 写入 `Z`，`S2`, `S3` 不读取 `Z`。\n    -   因此，没有其他真数据依赖。\n\n**总结与计算**\n-   我们找到了三个循环携带的真数据依赖。\n-   它们的距离分别为 $1$、$2$ 和 $3$。\n-   因此，正整数距离的集合是 $\\mathcal{D} = \\{1, 2, 3\\}$。\n\n根据问题的定义：\n-   $d^{\\star}$ 是 $\\mathcal{D}$ 的最小元素。$d^{\\star} = \\min(\\{1, 2, 3\\}) = 1$。\n-   $L$ 是并行化的合法性指标。由于存在循环携带的真数据依赖（$\\mathcal{D}$ 非空），该循环不能被合法地并行化。因此，$L = 0$。\n\n最终答案是以行矩阵形式表示的 $(d^{\\star}, L)$。\n$$ \\begin{pmatrix} d^{\\star}  L \\end{pmatrix} = \\begin{pmatrix} 1  0 \\end{pmatrix} $$",
            "answer": "$$\\boxed{\\begin{pmatrix}1  0\\end{pmatrix}}$$"
        }
    ]
}