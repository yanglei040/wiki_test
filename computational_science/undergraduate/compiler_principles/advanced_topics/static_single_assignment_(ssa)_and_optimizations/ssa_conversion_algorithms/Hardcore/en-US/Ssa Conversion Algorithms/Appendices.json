{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a foundational walkthrough of the classic algorithm for converting a program into Static Single Assignment (SSA) form. By working through a concrete Control-Flow Graph (CFG), you will apply the core concepts of dominance and dominance frontiers ($\\mathrm{DF}$) to determine where $\\phi$-functions are strictly necessary. This hands-on process  is crucial for building an intuition for how compilers systematically transform code to enable powerful optimizations.",
            "id": "3670674",
            "problem": "Consider the following Control Flow Graph (CFG) for a procedure whose entry block is $B_1$ and exit block is $B_8$. The directed edges between basic blocks are:\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$, $B_3 \\to B_5$\n- $B_4 \\to B_6$\n- $B_5 \\to B_6$\n- $B_6 \\to B_2$, $B_6 \\to B_7$\n- $B_7 \\to B_8$\n\nEach block contains straight-line code as follows, with assignments to variables $x$ and $z$:\n- $B_1$: $x := 0$; $z := 0$\n- $B_2$: $x := x + 1$\n- $B_3$: $z := 1$\n- $B_4$: (no definitions of $x$ or $z$)\n- $B_5$: $x := 2$\n- $B_6$: $z := z + x$\n- $B_7$: (no definitions of $x$ or $z$)\n- $B_8$: (no definitions of $x$ or $z$)\n\nTasks:\n- Construct the dominator tree of the CFG rooted at $B_1$.\n- Compute the dominance frontier $\\mathrm{DF}(B_i)$ for each block $B_i$, for $i \\in \\{1,2,3,4,5,6,7,8\\}$.\n- Using the classic minimal Static Single Assignment (SSA) form construction (Cytron et al.) based on iterated dominance frontiers, derive the minimal $\\phi$-function placement for variables $x$ and $z$. Assume the following convention: do not perform liveness-based pruning, and do not insert a $\\phi$-function for a variable in a block that already contains a definition of that same variable.\n\nFinally, report a single quantity: the total number of $\\phi$-functions inserted for variables $x$ and $z$ combined. Provide your answer as an integer. No rounding is needed, and no units are required.",
            "solution": "The solution requires three main steps:\n1. Construction of the dominator tree.\n2. Computation of the dominance frontiers for all basic blocks.\n3. Application of the iterated dominance frontiers algorithm to determine the placement of $\\phi$-functions.\n\n### Step 1: Dominator Tree Construction\n\nA block $D$ dominates a block $N$ if every path from the entry block to $N$ must pass through $D$. The immediate dominator of a block $N$, denoted $\\mathrm{idom}(N)$, is the unique dominator of $N$ that does not dominate any other dominator of $N$. The dominator tree is formed by the edges $(\\mathrm{idom}(N), N)$ for all blocks $N$ except the entry block. The entry block is $B_1$.\n\nBy analyzing the paths in the given CFG:\n- $\\mathrm{dom}(B_1) = \\{B_1\\}$.\n- Any path to $B_2$ must pass through $B_1$. Paths can be $B_1 \\to B_2$ or through the loop $B_1 \\to \\dots \\to B_6 \\to B_2$. All paths from the entry to $B_2$ must start with $B_1$. Thus, $\\mathrm{dom}(B_2) = \\{B_1, B_2\\}$, and $\\mathrm{idom}(B_2) = B_1$.\n- Any path to $B_3$ must be $B_1 \\to B_3$. Thus, $\\mathrm{dom}(B_3) = \\{B_1, B_3\\}$, and $\\mathrm{idom}(B_3) = B_1$.\n- Paths to $B_4$ are $B_1 \\to B_2 \\to B_4$ and $B_1 \\to B_3 \\to B_4$. The only common block on all paths to $B_4$ other than $B_4$ itself is $B_1$. Thus, $\\mathrm{dom}(B_4) = \\{B_1, B_4\\}$, and $\\mathrm{idom}(B_4) = B_1$.\n- Any path to $B_5$ must go through $B_3$ ($B_1 \\to B_3 \\to B_5$). Thus, $\\mathrm{dom}(B_5) = \\{B_1, B_3, B_5\\}$, and $\\mathrm{idom}(B_5) = B_3$.\n- Paths to $B_6$ can come from $B_4$ or $B_5$. Example paths are $B_1 \\to B_2 \\to B_4 \\to B_6$ and $B_1 \\to B_3 \\to B_5 \\to B_6$. The only common block on all paths from entry to $B_6$ is $B_1$. Thus, $\\mathrm{dom}(B_6) = \\{B_1, B_6\\}$, and $\\mathrm{idom}(B_6) = B_1$.\n- Any path to $B_7$ must come from $B_6$. Thus, $B_6$ dominates $B_7$. Since $B_1$ dominates $B_6$, $B_1$ also dominates $B_7$. Thus, $\\mathrm{dom}(B_7) = \\{B_1, B_6, B_7\\}$, and $\\mathrm{idom}(B_7) = B_6$.\n- Any path to $B_8$ must come from $B_7$. Thus, $B_7$ dominates $B_8$. Transitivity implies $B_6$ and $B_1$ also dominate $B_8$. Thus, $\\mathrm{dom}(B_8) = \\{B_1, B_6, B_7, B_8\\}$, and $\\mathrm{idom}(B_8) = B_7$.\n\nThe dominator tree, rooted at $B_1$, is defined by the following immediate dominator relationships:\n- $\\mathrm{idom}(B_2) = B_1$\n- $\\mathrm{idom}(B_3) = B_1$\n- $\\mathrm{idom}(B_4) = B_1$\n- $\\mathrm{idom}(B_5) = B_3$\n- $\\mathrm{idom}(B_6) = B_1$\n- $\\mathrm{idom}(B_7) = B_6$\n- $\\mathrm{idom}(B_8) = B_7$\n\n### Step 2: Dominance Frontier Calculation\n\nThe dominance frontier of a block $X$, denoted $\\mathrm{DF}(X)$, is the set of all blocks $Y$ such that $X$ dominates a predecessor of $Y$, but $X$ does not strictly dominate $Y$. A block $X$ strictly dominates $Y$ if $X$ dominates $Y$ and $X \\neq Y$.\n\n- $\\mathrm{DF}(B_1)$: $B_1$ strictly dominates every block it dominates (except itself). There is no block $Y$ such that $B_1$ does not strictly dominate it (except $Y=B_1$, which has no predecessors). Hence, $\\mathrm{DF}(B_1) = \\emptyset$.\n- $\\mathrm{DF}(B_2)$: $B_2$ has successor $B_4$. Predecessors of $B_4$ are $B_2, B_3$. $B_2$ dominates its predecessor $B_2$. However, $B_2$ does not strictly dominate $B_4$ (since $\\mathrm{idom}(B_4)=B_1$). Thus, $B_4 \\in \\mathrm{DF}(B_2)$. No other such blocks exist. $\\mathrm{DF}(B_2) = \\{B_4\\}$.\n- $\\mathrm{DF}(B_3)$:\n    - For $Y=B_4$, $B_3 \\in \\mathrm{pred}(B_4)$, and $B_3$ dominates itself. $B_3$ does not strictly dominate $B_4$. Thus, $B_4 \\in \\mathrm{DF}(B_3)$.\n    - For $Y=B_6$, $B_5 \\in \\mathrm{pred}(B_6)$. $B_3$ dominates $B_5$. $B_3$ does not strictly dominate $B_6$. Thus, $B_6 \\in \\mathrm{DF}(B_3)$.\n    - $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$.\n- $\\mathrm{DF}(B_4)$: $B_4 \\in \\mathrm{pred}(B_6)$. $B_4$ dominates itself. $B_4$ does not strictly dominate $B_6$. Thus, $B_6 \\in \\mathrm{DF}(B_4)$. $\\mathrm{DF}(B_4) = \\{B_6\\}$.\n- $\\mathrm{DF}(B_5)$: $B_5 \\in \\mathrm{pred}(B_6)$. $B_5$ dominates itself. $B_5$ does not strictly dominate $B_6$. Thus, $B_6 \\in \\mathrm{DF}(B_5)$. $\\mathrm{DF}(B_5) = \\{B_6\\}$.\n- $\\mathrm{DF}(B_6)$: $B_6 \\in \\mathrm{pred}(B_2)$ due to the back edge. $B_6$ dominates itself. $B_6$ does not strictly dominate $B_2$. Thus, $B_2 \\in \\mathrm{DF}(B_6)$. $B_6$ strictly dominates its other successor $B_7$. $\\mathrm{DF}(B_6) = \\{B_2\\}$.\n- $\\mathrm{DF}(B_7)$: The only successor of $B_7$ is $B_8$, and $B_7$ strictly dominates $B_8$. Therefore, $\\mathrm{DF}(B_7) = \\emptyset$.\n- $\\mathrm{DF}(B_8)$: This block has no successors. Therefore, $\\mathrm{DF(B_8)} = \\emptyset$.\n\nSummary of Dominance Frontiers:\n- $\\mathrm{DF}(B_1) = \\emptyset$\n- $\\mathrm{DF}(B_2) = \\{B_4\\}$\n- $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$\n- $\\mathrm{DF}(B_4) = \\{B_6\\}$\n- $\\mathrm{DF}(B_5) = \\{B_6\\}$\n- $\\mathrm{DF}(B_6) = \\{B_2\\}$\n- $\\mathrm{DF}(B_7) = \\emptyset$\n- $\\mathrm{DF}(B_8) = \\emptyset$\n\n### Step 3: Minimal $\\phi$-Function Placement\n\nWe use the iterated dominance frontier (IDF) algorithm. For each variable $v$, we compute the set of blocks $\\Phi_v$ that require a $\\phi$-function. The algorithm is:\n1. Initialize a set $\\Phi_v = \\emptyset$ and a worklist $W$ with all blocks containing an original definition of $v$. Let this set of blocks be $\\mathrm{Defs}_v$.\n2. While $W$ is not empty, extract a block $N$ from $W$.\n3. For each block $Y \\in \\mathrm{DF}(N)$:\n   If $Y \\notin \\Phi_v$ and, per the problem constraint, $Y \\notin \\mathrm{Defs}_v$, then add $Y$ to $\\Phi_v$ and to the worklist $W$.\n\n**Variable $x$**:\n- The set of blocks with original definitions is $\\mathrm{Defs}_x = \\{B_1, B_2, B_5\\}$.\n- Initialize: $\\Phi_x = \\emptyset$, $W = \\{B_1, B_2, B_5\\}$.\n- Pop $B_1$: $\\mathrm{DF}(B_1) = \\emptyset$. $W = \\{B_2, B_5\\}$.\n- Pop $B_2$: $\\mathrm{DF}(B_2) = \\{B_4\\}$. $B_4 \\notin \\mathrm{Defs}_x$ and $B_4 \\notin \\Phi_x$. Add $B_4$ to $\\Phi_x$ and $W$. $\\Phi_x = \\{B_4\\}$, $W = \\{B_5, B_4\\}$.\n- Pop $B_5$: $\\mathrm{DF}(B_5) = \\{B_6\\}$. $B_6 \\notin \\mathrm{Defs}_x$ and $B_6 \\notin \\Phi_x$. Add $B_6$ to $\\Phi_x$ and $W$. $\\Phi_x = \\{B_4, B_6\\}$, $W = \\{B_4, B_6\\}$.\n- Pop $B_4$: $\\mathrm{DF}(B_4) = \\{B_6\\}$. $B_6 \\in \\Phi_x$. No change. $W = \\{B_6\\}$.\n- Pop $B_6$: $\\mathrm{DF}(B_6) = \\{B_2\\}$. $B_2 \\in \\mathrm{Defs}_x$. Per the problem constraint, no $\\phi$-function is added. No change. $W = \\emptyset$.\n- The worklist is empty. The final placement set for $x$ is $\\Phi_x = \\{B_4, B_6\\}$.\n- Number of $\\phi$-functions for $x$: $|\\Phi_x| = 2$.\n\n**Variable $z$**:\n- The set of blocks with original definitions is $\\mathrm{Defs}_z = \\{B_1, B_3, B_6\\}$.\n- Initialize: $\\Phi_z = \\emptyset$, $W = \\{B_1, B_3, B_6\\}$.\n- Pop $B_1$: $\\mathrm{DF}(B_1) = \\emptyset$. $W = \\{B_3, B_6\\}$.\n- Pop $B_3$: $\\mathrm{DF}(B_3) = \\{B_4, B_6\\}$.\n    - For $B_4$: $B_4 \\notin \\mathrm{Defs}_z$ and $B_4 \\notin \\Phi_z$. Add $B_4$ to $\\Phi_z$ and $W$. $\\Phi_z = \\{B_4\\}$, $W = \\{B_6, B_4\\}$.\n    - For $B_6$: $B_6 \\in \\mathrm{Defs}_z$. No $\\phi$-function is added.\n- Pop $B_6$: $\\mathrm{DF}(B_6) = \\{B_2\\}$. $B_2 \\notin \\mathrm{Defs}_z$ and $B_2 \\notin \\Phi_z$. Add $B_2$ to $\\Phi_z$ and $W$. $\\Phi_z = \\{B_4, B_2\\}$, $W = \\{B_4, B_2\\}$.\n- Pop $B_4$: $\\mathrm{DF}(B_4) = \\{B_6\\}$. $B_6 \\in \\mathrm{Defs}_z$. No $\\phi$-function is added. $W = \\{B_2\\}$.\n- Pop $B_2$: $\\mathrm{DF}(B_2) = \\{B_4\\}$. $B_4 \\in \\Phi_z$. No change. $W = \\emptyset$.\n- The worklist is empty. The final placement set for $z$ is $\\Phi_z = \\{B_2, B_4\\}$.\n- Number of $\\phi$-functions for $z$: $|\\Phi_z| = 2$.\n\n### Step 4: Final Calculation\n\nThe total number of $\\phi$-functions inserted is the sum of the counts for each variable.\nTotal $\\phi$-functions = (Number for $x$) + (Number for $z$) = $2 + 2 = 4$.\nThe required $\\phi$-functions are:\n- For $x$: in $B_4$ and $B_6$.\n- For $z$: in $B_2$ and $B_4$.\n\nThe total count is $4$.",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "While the standard SSA construction algorithm guarantees correctness, it can sometimes insert $\\phi$-functions whose results are never used. This exercise  introduces 'Pruned SSA', an optimization that uses liveness analysis to identify and eliminate these superfluous $\\phi$-functions. By comparing the standard placement with a pruned one, you will see how data-flow analysis helps create a more efficient and compact intermediate representation.",
            "id": "3670701",
            "problem": "Consider the task of converting a program to Static Single Assignment (SSA) form, where each variable is assigned exactly once and $\\phi$ functions merge values that flow from multiple predecessors at join points. Use the following foundational definitions as the base of your reasoning.\n\n- A Control-Flow Graph (CFG) is a directed graph whose nodes are basic blocks and whose edges represent possible control flow between blocks. A node $d$ dominates a node $n$ if every path from the entry to $n$ contains $d$. The Dominance Frontier (DF) of a node $d$ is the set of nodes $n$ such that $d$ dominates a predecessor of $n$ but $d$ does not strictly dominate $n$.\n- In the classical SSA construction via iterated Dominance Frontier, for a variable $v$, $\\phi$ functions are inserted in the DF of blocks that contain assignments to $v$, iterated until a fixed point across newly inserted $\\phi$ definitions as needed.\n- Pruned SSA removes $\\phi$ functions for a variable $v$ in any block where $v$ is not live-in in the original program. A variable $v$ is live-in at a point if there exists a path from that point to a use of $v$ such that $v$ is not redefined along that path before the use.\n- Consider a conservative liveness-based pruning variant that over-approximates liveness for a variable $v$ by treating $v$ as live-in at a block whenever there exists any path from that block to a use of $v$, ignoring intervening redefinitions. This variant may retain $\\phi$ functions that pruned SSA would remove.\n\nYou are given the following CFG (conditions $p$, $q$, $r$ are arbitrary boolean expressions; control edges are specified by “goto” transitions):\n\n- Block $B_0$: entry; goto $B_1$.\n- Block $B_1$: if $p$ then goto $B_2$ else goto $B_3$.\n- Block $B_2$: $x := 1$; $y := 1$; goto $B_4$.\n- Block $B_3$: if $q$ then goto $B_5$ else goto $B_6$.\n- Block $B_5$: $x := 2$; goto $B_4$.\n- Block $B_6$: $y := 3$; goto $B_4$.\n- Block $B_4$: join of $B_2$, $B_5$, $B_6$; goto $B_7$.\n- Block $B_7$: $y := 4$; if $r$ then goto $B_8$ else goto $B_9$.\n- Block $B_8$: $x := 5$; $t := x + 1$; goto $B_{10}$.\n- Block $B_9$: $u := x$; goto $B_{10}$.\n- Block $B_{10}$: $w := y + 1$; exit.\n\nObserve that:\n- Assignments to $y$ in $B_2$ and $B_6$ are followed by an unconditional redefinition $y := 4$ in $B_7$ before any use, making the earlier assignments to $y$ dead. Thus, $y$ has partially dead assignments in $B_2$ and $B_6$.\n- Assignments to $x$ in $B_2$ and $B_5$ are used along the $B_4 \\rightarrow B_7 \\rightarrow B_9$ path, but are redefined in $B_8$ on the $B_4 \\rightarrow B_7 \\rightarrow B_8$ path. Hence, $x$ has partially dead assignments.\n\nUsing only the definitions above and reasoning from first principles about dominance, dominance frontiers, and liveness:\n- Derive the $\\phi$-insertion block set for $x$ and $y$ produced by the classical iterated Dominance Frontier method. Denote these sets $S_x^{\\mathrm{DF}}$ and $S_y^{\\mathrm{DF}}$.\n- Derive the pruned SSA $\\phi$-insertion block sets for $x$ and $y$ using exact liveness (i.e., liveness that accounts for redefinitions). Denote these sets $S_x^{\\mathrm{pruned}}$ and $S_y^{\\mathrm{pruned}}$.\n- Derive the conservative liveness-based pruning variant $\\phi$-insertion block sets for $x$ and $y$ (i.e., using the over-approximated liveness that ignores redefinitions when propagating from uses). Denote these sets $S_x^{\\mathrm{live}}$ and $S_y^{\\mathrm{live}}$.\n\nShow that $S_x^{\\mathrm{live}} = S_x^{\\mathrm{pruned}}$ but $S_y^{\\mathrm{live}} \\neq S_y^{\\mathrm{pruned}}$ for the CFG above. Finally, compute the scalar\n$$E = \\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| + \\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right|.$$\nProvide $E$ as a single integer. No rounding is needed. No units are required.",
            "solution": "### Step 1: Dominance and Dominance Frontier Analysis\n\nThe structure of the CFG is given. First, we determine the dominators for each basic block. A block $d$ dominates a block $n$ if every path from the entry block ($B_0$) to $n$ must pass through $d$. Based on the CFG, the immediate dominators (`idom`) are:\n- $\\mathrm{idom}(B_1) = B_0$\n- $\\mathrm{idom}(B_2) = B_1$\n- $\\mathrm{idom}(B_3) = B_1$\n- $\\mathrm{idom}(B_4) = B_1$\n- $\\mathrm{idom}(B_5) = B_3$\n- $\\mathrm{idom}(B_6) = B_3$\n- $\\mathrm{idom}(B_7) = B_4$\n- $\\mathrm{idom}(B_8) = B_7$\n- $\\mathrm{idom}(B_9) = B_7$\n- $\\mathrm{idom}(B_{10}) = B_7$\n\nThe Dominance Frontier $\\mathrm{DF}(d)$ of a node $d$ is the set of all nodes $n$ such that $d$ dominates a predecessor of $n$, but $d$ does not strictly dominate $n$. We need the DFs for blocks that contain original assignments to $x$ or $y$. These are $B_2, B_5, B_6, B_7, B_8$.\n- $\\mathrm{DF}(B_2) = \\{B_4\\}$: $B_2$ dominates itself (a predecessor of $B_4$), but does not strictly dominate $B_4$.\n- $\\mathrm{DF}(B_5) = \\{B_4\\}$: $B_5$ dominates itself (a predecessor of $B_4$), but does not strictly dominate $B_4$.\n- $\\mathrm{DF}(B_6) = \\{B_4\\}$: $B_6$ dominates itself (a predecessor of $B_4$), but does not strictly dominate $B_4$.\n- $\\mathrm{DF}(B_7) = \\{B_{10}\\}$: $B_7$ dominates its successors $B_8$ and $B_9$ (predecessors of $B_{10}$), but $B_7$ does not strictly dominate $B_{10}$ (it is the immediate dominator). The join happens at $B_{10}$.\n- $\\mathrm{DF}(B_8) = \\{B_{10}\\}$: $B_8$ dominates itself (a predecessor of $B_{10}$), but does not strictly dominate $B_{10}$.\n- For the iterative algorithm, we also need the DFs of blocks where new $\\phi$-functions are placed:\n- $\\mathrm{DF}(B_4) = \\{B_{10}\\}$: $B_4$ dominates $B_7$, which has successors $B_8$ and $B_9$ that lead to the join point $B_{10}$. $B_4$ does not strictly dominate $B_{10}$.\n- $\\mathrm{DF}(B_{10}) = \\emptyset$.\n\n### Step 2: Classical Iterated Dominance Frontier ($S_x^{\\mathrm{DF}}$, $S_y^{\\mathrm{DF}}$)\n\nWe compute the set of nodes for $\\phi$-insertions for a variable $v$ by starting with the set of nodes containing assignments to $v$ and iteratively adding the dominance frontiers of these nodes to a worklist until a fixed point is reached.\n\nFor variable $x$:\nThe set of blocks with original assignments is $A_x = \\{B_2, B_5, B_8\\}$.\n1.  The initial set of blocks for which we compute DFs is $A_x$.\n2.  $\\mathrm{DF}(B_2) \\cup \\mathrm{DF}(B_5) \\cup \\mathrm{DF}(B_8) = \\{B_4\\} \\cup \\{B_4\\} \\cup \\{B_{10}\\} = \\{B_4, B_{10}\\}$. Let this be $P_1 = \\{B_4, B_{10}\\}$.\n3.  Now iterate on the new definitions in $P_1$. $\\mathrm{DF}(B_4) \\cup \\mathrm{DF}(B_{10}) = \\{B_{10}\\} \\cup \\emptyset = \\{B_{10}\\}$.\n4.  This adds no new blocks to our set of $\\phi$-nodes. The process has reached a fixed point.\nThe set of insertion blocks is $S_x^{\\mathrm{DF}} = P_1 = \\{B_4, B_{10}\\}$.\n\nFor variable $y$:\nThe set of blocks with original assignments is $A_y = \\{B_2, B_6, B_7\\}$.\n1.  The initial set of blocks is $A_y$.\n2.  $\\mathrm{DF}(B_2) \\cup \\mathrm{DF}(B_6) \\cup \\mathrm{DF}(B_7) = \\{B_4\\} \\cup \\{B_4\\} \\cup \\{B_{10}\\} = \\{B_4, B_{10}\\}$. Let this be $P_1 = \\{B_4, B_{10}\\}$.\n3.  Iterating on $P_1$: $\\mathrm{DF}(B_4) \\cup \\mathrm{DF}(B_{10}) = \\{B_{10}\\} \\cup \\emptyset = \\{B_{10}\\}$.\n4.  No new blocks are added. The process terminates.\nThe set of insertion blocks is $S_y^{\\mathrm{DF}} = P_1 = \\{B_4, B_{10}\\}$.\n\n### Step 3: Pruned SSA ($S_x^{\\mathrm{pruned}}$, $S_y^{\\mathrm{pruned}}$)\n\nPruned SSA removes a $\\phi$-function from a block $B$ if the variable is not live-in at $B$. We perform a standard backward liveness analysis. A variable is live-in at a block if its value may be read in a successor block or later on some path.\n\nFor variable $x$:\n- Upward-exposed uses of $x$: $u := x$ in $B_9$. The use in $B_8$ ($t := x + 1$) is not upward-exposed as it is preceded by a definition ($x := 5$) in the same block. So, $\\mathrm{use}_x(B_9) = \\{x\\}$.\n- Definitions of $x$: $\\mathrm{def}_x(B_2) = \\{x\\}$, $\\mathrm{def}_x(B_5) = \\{x\\}$, $\\mathrm{def}_x(B_8) = \\{x\\}$.\n- Liveness computation (flowing backwards from $B_9$):\n  - $x$ is live-in at $B_9$.\n  - This makes $x$ live-out at $B_7$. Since $B_7$ does not redefine $x$, $x$ is live-in at $B_7$.\n  - This makes $x$ live-out at $B_4$. Since $B_4$ does not redefine $x$, $x$ is live-in at $B_4$.\n  - Liveness of $x$ propagates from $B_4$ backwards to its predecessors $B_2, B_5, B_6$.\n  - In $B_2$ and $B_5$, $x$ is redefined, so liveness is killed ( $x$ is not live-in at $B_2$ or $B_5$).\n  - In $B_6$, $x$ is not redefined, so $x$ is live-in.\n  - Liveness propagates up from $B_2, B_3, \\dots$ to the entry.\nThe set of blocks where $x$ is live-in is $\\{B_0, B_1, B_3, B_4, B_6, B_7, B_9\\}$.\n- Pruning $S_x^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$:\n  - Is $x$ live-in at $B_4$? Yes. We keep the $\\phi$-function.\n  - Is $x$ live-in at $B_{10}$? No. We prune the $\\phi$-function.\n- Therefore, $S_x^{\\mathrm{pruned}} = \\{B_4\\}$.\n\nFor variable $y$:\n- Upward-exposed uses of $y$: $w := y + 1$ in $B_{10}$. So, $\\mathrm{use}_y(B_{10}) = \\{y\\}$.\n- Definitions of $y$: $\\mathrm{def}_y(B_2) = \\{y\\}$, $\\mathrm{def}_y(B_6) = \\{y\\}$, $\\mathrm{def}_y(B_7) = \\{y\\}$.\n- Liveness computation (flowing backwards from $B_{10}$):\n  - $y$ is live-in at $B_{10}$.\n  - This makes $y$ live-out at its predecessors, $B_8$ and $B_9$. Since neither redefines $y$, $y$ is live-in at both $B_8$ and $B_9$.\n  - This makes $y$ live-out at $B_7$. However, $B_7$ contains a definition $y := 4$, which kills the liveness. Thus, $y$ is not live-in at $B_7$.\n  - Because liveness is killed at $B_7$, it does not propagate further up the CFG. $y$ is not live-in at $B_4$ or any of its predecessors.\nThe set of blocks where $y$ is live-in is $\\{B_8, B_9, B_{10}\\}$.\n- Pruning $S_y^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$:\n  - Is $y$ live-in at $B_4$? No. We prune the $\\phi$-function.\n  - Is $y$ live-in at $B_{10}$? Yes. We keep the $\\phi$-function.\n- Therefore, $S_y^{\\mathrm{pruned}} = \\{B_{10}\\}$.\n\n### Step 4: Conservative Liveness-based Pruning ($S_x^{\\mathrm{live}}$, $S_y^{\\mathrm{live}}$)\n\nThis variant considers a variable $v$ live-in at a block $B$ if there exists any path from $B$ to a use of $v$, ignoring redefinitions.\n\nFor variable $x$:\n- Uses of $x$ are in blocks $B_8$ and $B_9$.\n- To prune $S_x^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$:\n  - At $B_4$: There is a path from $B_4$ to a use of $x$ (e.g., $B_4 \\rightarrow B_7 \\rightarrow B_9$). Thus, $x$ is considered live-in. We keep the $\\phi$-function.\n  - At $B_{10}$: There is no path from $B_{10}$ to a use of $x$ ($B_8$ or $B_9$). Thus, $x$ is not live-in. We prune the $\\phi$-function.\n- Therefore, $S_x^{\\mathrm{live}} = \\{B_4\\}$.\n\nFor variable $y$:\n- The use of $y$ is in block $B_{10}$.\n- To prune $S_y^{\\mathrm{DF}} = \\{B_4, B_{10}\\}$:\n  - At $B_4$: There is a path from $B_4$ to the use of $y$ (e.g., $B_4 \\rightarrow B_7 \\rightarrow B_8 \\rightarrow B_{10}$). The redefinition in $B_7$ is ignored. Thus, $y$ is considered live-in. We keep the $\\phi$-function.\n  - At $B_{10}$: This is the block with the use, so a trivial path of length $0$ exists. $y$ is live-in. We keep the $\\phi$-function.\n- Therefore, $S_y^{\\mathrm{live}} = \\{B_4, B_{10}\\}$.\n\n### Step 5: Comparison and Final Calculation\n\nWe now summarize the results and compute $E$.\n- For $x$: $S_x^{\\mathrm{pruned}} = \\{B_4\\}$ and $S_x^{\\mathrm{live}} = \\{B_4\\}$. Thus, $S_x^{\\mathrm{live}} = S_x^{\\mathrm{pruned}}$.\n- For $y$: $S_y^{\\mathrm{pruned}} = \\{B_{10}\\}$ and $S_y^{\\mathrm{live}} = \\{B_4, B_{10}\\}$. Thus, $S_y^{\\mathrm{live}} \\neq S_y^{\\mathrm{pruned}}$. The inequality holds because the conservative liveness analysis for $y$ ignores the redefinition $y := 4$ in $B_7$, causing it to incorrectly consider $y$ live-in at $B_4$ and thus fail to prune the $\\phi$-function there.\n\nFinally, we compute the scalar $E$:\n$$ E = \\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| + \\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right| $$\n- $S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}} = \\{B_4\\} \\setminus \\{B_4\\} = \\emptyset$. So $\\left|S_x^{\\mathrm{live}} \\setminus S_x^{\\mathrm{pruned}}\\right| = 0$.\n- $S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}} = \\{B_4, B_{10}\\} \\setminus \\{B_{10}\\} = \\{B_4\\}$. So $\\left|S_y^{\\mathrm{live}} \\setminus S_y^{\\mathrm{pruned}}\\right| = 1$.\n\n$$ E = 0 + 1 = 1 $$",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "After optimizations are performed on the SSA representation, the compiler must convert the program back into a linear sequence of instructions. This final practice  focuses on this deconstruction phase, challenging you to translate $\\phi$-functions into register-to-register moves. You will grapple with the core problem of implementing parallel copy semantics, including resolving swap cycles that require careful instruction ordering and the use of temporary registers.",
            "id": "3670685",
            "problem": "You are given a control-flow graph with three predecessor blocks $B_1$, $B_2$, $B_3$ converging at a join block $J$. The program is in Static Single Assignment (SSA) form, and $J$ contains four $\\phi$-functions that define $a_4$, $b_4$, $c_4$, and $d_4$. After register allocation, the following register assignments hold:\n\n- At the entry of $J$, the destinations are assigned as follows: $a_4$ in $r_1$, $b_4$ in $r_2$, $c_4$ in $r_3$, $d_4$ in $r_4$.\n- At the exit of $B_1$, the live SSA names are in registers: $a_1$ in $r_2$, $b_1$ in $r_3$, $c_1$ in $r_4$, $d_1$ in $r_1$.\n- At the exit of $B_2$, the live SSA names are in registers: $a_2$ in $r_1$, $b_2$ in $r_4$, $c_2$ in $r_2$, $d_2$ in $r_3$.\n- At the exit of $B_3$, the live SSA names are in registers: $a_3$ in $r_3$, $b_3$ in $r_2$, $c_3$ in $r_1$, $d_3$ in $r_4$.\n\nThe $\\phi$-functions in $J$ are:\n- $a_4 := \\phi(B_1: a_1, B_2: a_2, B_3: a_3)$\n- $b_4 := \\phi(B_1: b_1, B_2: b_2, B_3: b_3)$\n- $c_4 := \\phi(B_1: c_1, B_2: c_2, B_3: c_3)$\n- $d_4 := \\phi(B_1: d_1, B_2: d_2, B_3: d_3)$\n\nTo convert out of SSA, you must insert at the end of each predecessor block a single parallel copy that implements all $\\phi$ arguments destined for $J$. A parallel copy is a set of assignments that must behave as if they occur simultaneously.\n\nYou are to reconstruct the non-SSA code by replacing each parallel copy with a sequence of register-to-register moves of the form mov dest, src, while preserving parallel copy semantics. You may use at most one scratch register $t$ per edge, distinct from $r_1$, $r_2$, $r_3$, $r_4$, and you must not insert any unnecessary moves. An identity assignment (e.g., $r_2 := r_2$) should not be emitted as a move.\n\nAssuming no other constraints (e.g., no memory spills and unlimited instruction scheduling freedom within the edge epilogue), what is the minimal total number of move instructions that must be inserted across all three edges $B_1 \\to J$, $B_2 \\to J$, and $B_3 \\to J$? Express your answer as an integer.",
            "solution": "The general method for resolving a parallel copy `(d_1, d_2, ..., d_n) := (s_1, s_2, ..., s_n)`, where $d_i$ are destination registers and $s_i$ are source registers, is to model it as a directed graph. The nodes of the graph are the registers, and a directed edge from $u$ to $v$ ($u \\to v$) represents the assignment $v := u$. The graph can be partitioned into disjoint paths and cycles.\n- An identity assignment ($d_i := d_i$) corresponds to a self-loop ($r \\to r$) and requires $0$ moves.\n- A set of assignments forming a path can be resolved with a number of moves equal to the number of assignments.\n- A set of assignments forming a cycle of length $k > 1$ requires a temporary register to break the cycle. The minimal number of moves to resolve such a cycle is $k+1$.\n\nWe will analyze the parallel copy required for each of the three predecessor blocks $B_1, B_2, B_3$.\n\n### Edge $B_1 \\to J$\n\nThe $\\phi$-functions at join block $J$ specify which SSA names from $B_1$ provide the values for the new SSA names $a_4, b_4, c_4, d_4$. The register assignments at the entry of $J$ and the exit of $B_1$ define the required register-to-register transfers.\n\n- At entry of $J$: $a_4$ is in $r_1$, $b_4$ in $r_2$, $c_4$ in $r_3$, $d_4$ in $r_4$.\n- From $\\phi$-functions for $B_1$: $a_4 \\leftarrow a_1, b_4 \\leftarrow b_1, c_4 \\leftarrow c_1, d_4 \\leftarrow d_1$.\n- At exit of $B_1$: $a_1$ is in $r_2$, $b_1$ in $r_3$, $c_1$ in $r_4$, $d_1$ in $r_1$.\n\nCombining these, we derive the required parallel copy on the edge $B_1 \\to J$:\n- To get $a_1$ into $r_1$ (where $a_4$ must be), we need $r_1 := r_2$.\n- To get $b_1$ into $r_2$ (where $b_4$ must be), we need $r_2 := r_3$.\n- To get $c_1$ into $r_3$ (where $c_4$ must be), we need $r_3 := r_4$.\n- To get $d_1$ into $r_4$ (where $d_4$ must be), we need $r_4 := r_1$.\n\nThe dependency graph for these moves has edges $r_2 \\to r_1$, $r_3 \\to r_2$, $r_4 \\to r_3$, and $r_1 \\to r_4$. These form a single cycle of length $k=4$: $r_1 \\to r_4 \\to r_3 \\to r_2 \\to r_1$. Using a temporary register $t$, this cycle can be broken with $k+1 = 4+1 = 5$ moves. For example:\n1. `mov t, r_1`\n2. `mov r_1, r_2`\n3. `mov r_2, r_3`\n4. `mov r_3, r_4`\n5. `mov r_4, t`\nThe number of moves for $B_1 \\to J$ is $5$.\n\n### Edge $B_2 \\to J$\n\n- From $\\phi$-functions for $B_2$: $a_4 \\leftarrow a_2, b_4 \\leftarrow b_2, c_4 \\leftarrow c_2, d_4 \\leftarrow d_2$.\n- At exit of $B_2$: $a_2$ is in $r_1$, $b_2$ in $r_4$, $c_2$ in $r_2$, $d_2$ in $r_3$.\n\nThe required parallel copy on the edge $B_2 \\to J$ is:\n- $r_1 := r_1$ (for $a_4 \\leftarrow a_2$)\n- $r_2 := r_4$ (for $b_4 \\leftarrow b_2$)\n- $r_3 := r_2$ (for $c_4 \\leftarrow c_2$)\n- $r_4 := r_3$ (for $d_4 \\leftarrow d_2$)\n\nThe dependency graph for these moves has:\n- A self-loop $r_1 \\to r_1$, which is an identity assignment requiring $0$ moves.\n- A cycle of length $k=3$: $r_2 \\to r_3 \\to r_4 \\to r_2$. This requires $k+1 = 3+1 = 4$ moves.\nThe total number of moves for $B_2 \\to J$ is $0 + 4 = 4$.\n\n### Edge $B_3 \\to J$\n\n- From $\\phi$-functions for $B_3$: $a_4 \\leftarrow a_3, b_4 \\leftarrow b_3, c_4 \\leftarrow c_3, d_4 \\leftarrow d_3$.\n- At exit of $B_3$: $a_3$ is in $r_3$, $b_3$ in $r_2$, $c_3$ in $r_1$, $d_3$ in $r_4$.\n\nThe required parallel copy on the edge $B_3 \\to J$ is:\n- $r_1 := r_3$ (for $a_4 \\leftarrow a_3$)\n- $r_2 := r_2$ (for $b_4 \\leftarrow b_3$)\n- $r_3 := r_1$ (for $c_4 \\leftarrow c_3$)\n- $r_4 := r_4$ (for $d_4 \\leftarrow d_3$)\n\nThe dependency graph for these moves has:\n- Two self-loops, $r_2 \\to r_2$ and $r_4 \\to r_4$. Each requires $0$ moves.\n- A cycle of length $k=2$: $r_1 \\to r_3 \\to r_1$. This is a swap and requires $k+1 = 2+1 = 3$ moves.\nThe total number of moves for $B_3 \\to J$ is $0 + 0 + 3 = 3$.\n\n### Total Number of Moves\n\nThe minimal total number of move instructions is the sum of the moves required for each of the three edges.\nTotal moves = (Moves for $B_1 \\to J$) + (Moves for $B_2 \\to J$) + (Moves for $B_3 \\to J$)\nTotal moves = $5 + 4 + 3 = 12$.",
            "answer": "$$\n\\boxed{12}\n$$"
        }
    ]
}