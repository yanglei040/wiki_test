{
    "hands_on_practices": [
        {
            "introduction": "Understanding Static Single Assignment form begins with mastering the algorithm for placing $\\phi$-functions. This placement is not arbitrary but is precisely determined by the control-flow graph's structure through the concept of dominance frontiers. This first practice will guide you through the foundational steps of calculating dominance frontiers and applying the iterated dominance frontier algorithm to determine the exact locations for $\\phi$-functions ().",
            "id": "3671703",
            "problem": "Consider the following Control Flow Graph (CFG) for a procedure, with basic blocks labeled $B_1$ through $B_8$. The entry is $B_1$ and the exit is $B_8$. The directed edges of the CFG are:\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$\n- $B_4 \\to B_5$, $B_4 \\to B_6$\n- $B_5 \\to B_7$\n- $B_6 \\to B_7$\n- $B_7 \\to B_4$, $B_7 \\to B_8$\n\nAssume the procedure contains a single variable $v$ with assignments only in blocks $B_1$ and $B_2$. Your tasks are:\n1. Using the standard definitions of the dominator relation and dominance frontier from compiler principles, compute the dominance frontier $DF(n)$ for every node $n \\in \\{B_1,B_2,B_3,B_4,B_5,B_6,B_7,B_8\\}$.\n2. Using the iterated dominance frontier method of Cytron et al. for Static Single Assignment form (SSA), determine all blocks where $\\phi$-functions for $v$ must be placed, starting from the set of definition sites $\\{B_1,B_2\\}$ and iterating until convergence.\n3. Provide, as your final answer, the total number of distinct $\\phi$-functions inserted for $v$ in this CFG. Express your final answer as a single integer. No rounding is required.",
            "solution": "The user wants me to solve a problem related to Static Single Assignment (SSA) form in compiler theory.\n\nHere's my plan:\n1.  **Validate the problem statement:**\n    *   **Extract Givens:** List the CFG structure (nodes and edges), the entry/exit blocks, the variable `v`, and its definition sites.\n    *   **Check for Validity:**\n        *   **Scientifically Grounded:** The problem is about compiler theory, specifically SSA form, dominance, and dominance frontiers. These are well-established concepts in computer science. The CFG is a standard representation. The problem is scientifically sound.\n        *   **Well-Posed:** The problem asks for specific computations (dominance frontiers, $\\phi$-function placement) based on a well-defined algorithm (iterated dominance frontier). A unique solution exists.\n        *   **Objective:** The language is precise and technical. No subjective elements.\n        *   **Completeness:** The CFG is fully described. The variable and its definition sites are given. The algorithm to use is specified. The problem is self-contained.\n        *   **Consistency:** The CFG structure is consistent. There are no contradictions.\n        *   **Realism:** The CFG is a typical example one would find in a textbook. It's a realistic representation for a small procedure.\n        *   **No other flaws:** It's not metaphorical, trivial, or unverifiable.\n\n    *   **Verdict:** The problem is valid. I will proceed with the solution.\n\n2.  **Solve the problem:**\n\n    *   **Part 1: Compute Dominance Frontiers**\n        1.  **Compute Dominators:** First, I need to determine the dominator set for each node.\n            *   A node `d` dominates a node `n` if every path from the entry node (`B_1`) to `n` goes through `d`.\n            *   Let's analyze the graph:\n                *   Entry: $B_1$\n                *   Edges:\n                    *   $B_1 \\to B_2$, $B_1 \\to B_3$\n                    *   $B_2 \\to B_4$\n                    *   $B_3 \\to B_4$\n                    *   $B_4 \\to B_5$, $B_4 \\to B_6$\n                    *   $B_5 \\to B_7$\n                    *   $B_6 \\to B_7$\n                    *   $B_7 \\to B_4$, $B_7 \\to B_8$\n                *   Exit: $B_8$\n\n            *   Let's find the dominators for each node `n`, `Dom(n)`:\n                *   `Dom(B_1)`: $\\{B_1\\}$ (by definition)\n                *   `Dom(B_2)`: Paths to $B_2$: $B_1 \\to B_2$. So, $\\{B_1, B_2\\}$.\n                *   `Dom(B_3)`: Paths to $B_3$: $B_1 \\to B_3$. So, $\\{B_1, B_3\\}$.\n                *   `Dom(B_4)`: Paths to $B_4$: $B_1 \\to B_2 \\to B_4$, $B_1 \\to B_3 \\to B_4$. The only common node is $B_1$. Wait, there's a loop $B_4 \\leftrightarrow B_7$. Let's trace paths more carefully.\n                    *   Any path to $B_4$ must start at $B_1$. After $B_1$, it can go to $B_2$ or $B_3$. Both paths lead to $B_4$. So, $B_1$ dominates $B_4$.\n                    *   Also, there's a loop $B_4 \\to B_5 \\to B_7 \\to B_4$ and $B_4 \\to B_6 \\to B_7 \\to B_4$. Once we are in the loop $\\{B_4, B_5, B_6, B_7\\}$, any path from the entry to any node in that loop *must* go through $B_4$.\n                    *   So, $B_4$ is the header of this loop.\n                    *   Paths to $B_4$: $(B_1, B_2, B_4)$, $(B_1, B_3, B_4)$. The only common node is $B_1$. And, of course, $B_4$ dominates itself. So, `Dom(B_4)`: $\\{B_1, B_4\\}$.\n                *   `Dom(B_5)`: Paths to $B_5$: must go through $B_4$. Example path: $B_1 \\to B_2 \\to B_4 \\to B_5$. Every path to $B_5$ must go through $B_1$ and $B_4$. So, `Dom(B_5)`: $\\{B_1, B_4, B_5\\}$.\n                *   `Dom(B_6)`: Paths to $B_6$: must go through $B_4$. Example path: $B_1 \\to B_2 \\to B_4 \\to B_6$. Every path to $B_6$ must go through $B_1$ and $B_4$. So, `Dom(B_6)`: $\\{B_1, B_4, B_6\\}$.\n                *   `Dom(B_7)`: Paths to $B_7$: must go through $B_4$. They can come from $B_5$ or $B_6$. So every path to $B_7$ must go through $B_1$ and $B_4$. So, `Dom(B_7)`: $\\{B_1, B_4, B_7\\}$.\n                *   `Dom(B_8)`: Paths to $B_8$: must go through $B_7$. The only edge to $B_8$ is $B_7 \\to B_8$. So, every path to $B_8$ must pass through $B_7$. And every path to $B_7$ passes through $B_1$ and $B_4$. So, `Dom(B_8)`: $\\{B_1, B_4, B_7, B_8\\}$.\n\n        2.  **Compute Immediate Dominators:** The immediate dominator `idom(n)` of a node `n != n_entry` is the unique node `d` in `Dom(n) - {n}` that is dominated by all other nodes in `Dom(n) - {n}`.\n            *   `idom(B_1)`: none (it's the entry)\n            *   `idom(B_2)`: `Dom(B_2) = {B_1, B_2}`. `Dom(B_2) - {B_2} = {B_1}`. So, `idom(B_2) = B_1`.\n            *   `idom(B_3)`: `Dom(B_3) = {B_1, B_3}`. `Dom(B_3) - {B_3} = {B_1}`. So, `idom(B_3) = B_1`.\n            *   `idom(B_4)`: `Dom(B_4) = {B_1, B_4}`. `Dom(B_4) - {B_4} = {B_1}`. So, `idom(B_4) = B_1`.\n            *   `idom(B_5)`: `Dom(B_5) = {B_1, B_4, B_5}`. `Dom(B_5) - {B_5} = {B_1, B_4}`. $B_1$ dominates $B_4$. So, `idom(B_5) = B_4`.\n            *   `idom(B_6)`: `Dom(B_6) = {B_1, B_4, B_6}`. `Dom(B_6) - {B_6} = {B_1, B_4}`. $B_1$ dominates $B_4$. So, `idom(B_6) = B_4`.\n            *   `idom(B_7)`: `Dom(B_7) = {B_1, B_4, B_7}`. `Dom(B_7) - {B_7} = {B_1, B_4}`. $B_1$ dominates $B_4$. So, `idom(B_7) = B_4`.\n            *   `idom(B_8)`: `Dom(B_8) = {B_1, B_4, B_7, B_8}`. `Dom(B_8) - {B_8} = {B_1, B_4, B_7}`. $B_1$ dominates $B_4$, which dominates $B_7$. So, `idom(B_8) = B_7`.\n\n        3.  **Construct the Dominator Tree:**\n            *   Root: $B_1$\n            *   Children of $B_1$: $B_2$, $B_3$, $B_4$\n            *   Children of $B_2$: none\n            *   Children of $B_3$: none\n            *   Children of $B_4$: $B_5$, $B_6$, $B_7$\n            *   Children of $B_5$: none\n            *   Children of $B_6$: none\n            *   Children of $B_7$: $B_8$\n            *   Children of $B_8$: none\n            *   Tree:\n                *   $B_1 \\to B_2$\n                *   $B_1 \\to B_3$\n                *   $B_1 \\to B_4 \\to B_5$\n                *   $B_1 \\to B_4 \\to B_6$\n                *   $B_1 \\to B_4 \\to B_7 \\to B_8$\n            *   Let's check `idom(B_4) = B_1`. Paths to $B_4$ are $B_1 \\to B_2 \\to B_4$ and $B_1 \\to B_3 \\to B_4$. The common dominators are $\\{B_1, B_4\\}$. Yes, `idom(B_4)=B_1`. My analysis was correct.\n\n        4.  **Compute Dominance Frontiers:**\n            *   The dominance frontier `DF(n)` of a node `n` is the set of all nodes `y` such that `n` dominates an immediate predecessor of `y`, but `n` does not *strictly* dominate `y`. (`n` strictly dominates `m` if `n` dominates `m` and `n != m`).\n            *   Equivalently, `y` is in `DF(n)` if there exists a path from `n` to `y` that does not go through any other node that strictly dominates `n`. Oh, wait, that's a different concept. The definition is: `DF(n) = { y | ∃p ∈ pred(y) s.t. n dom p, but n does not strictly dominate y }`.\n\n            Let's compute for each node `n`:\n            *   `DF(B_1)`:\n                *   `n = B_1`. Does `B_1` strictly dominate any node? Yes, all of them. So this part of the condition is not helpful.\n                *   Let's use the standard definition. We are looking for nodes `y` where `B_1` dominates a predecessor `p` of `y`, but `B_1` does not strictly dominate `y`.\n                *   `B_1` dominates every node except itself non-strictly. `B_1` strictly dominates all nodes except `B_1`.\n                *   The only node `y` which `B_1` does not strictly dominate is `B_1` itself. But predecessors of `B_1` don't exist. So `DF(B_1) = {}`.\n            *   `DF(B_2)`:\n                *   `n = B_2`. `idom(B_2)=B_1`.\n                *   `B_2` dominates only itself. We need `y` such that `B_2` dominates `p \\in pred(y)`. The only possible `p` is `B_2` itself. Successors of `B_2` is `{B_4}`. So `y = B_4`.\n                *   Predecessor of `B_4` is `p=B_2`. `B_2` dom `B_2`.\n                *   Does `B_2` strictly dominate `B_4`? No. `Dom(B_4) = {B_1, B_4}`.\n                *   So `B_4 \\in DF(B_2)`.\n                *   Any other successor of `B_2`? No. So `DF(B_2) = {B_4}`.\n            *   `DF(B_3)`:\n                *   `n = B_3`.\n                *   Successors of `B_3`: `{B_4}`. So `y = B_4`.\n                *   Predecessor of `B_4` is `p=B_3`. `B_3` dom `B_3`.\n                *   Does `B_3` strictly dominate `B_4`? No. `Dom(B_4) = {B_1, B_4}`.\n                *   So `B_4 \\in DF(B_3)`.\n                *   `DF(B_3) = {B_4}`.\n            *   `DF(B_4)`:\n                *   `n = B_4`. `idom(B_4)=B_1`.\n                *   Nodes dominated by `B_4`: `B_4, B_5, B_6, B_7, B_8`.\n                *   Let's check successors of these nodes.\n                *   Succs of `B_4`: `{B_5, B_6}`. For `y=B_5`, `p=B_4`. `B_4` dom `B_4`. `B_4` strictly dom `B_5`. So `B_5` is not in `DF(B_4)`. Same for `B_6`.\n                *   Succs of `B_5`: `{B_7}`. For `y=B_7`, `p=B_5`. `B_4` dom `B_5`. Does `B_4` strictly dom `B_7`? Yes. `idom(B_7)=B_4`. So `B_7` is not in `DF(B_4)`.\n                *   Succs of `B_6`: `{B_7}`. For `y=B_7`, `p=B_6`. `B_4` dom `B_6`. `B_4` strictly dom `B_7`. So `B_7` is not in `DF(B_4)`.\n                *   Succs of `B_7`: `{B_4, B_8}`.\n                *   Case `y = B_4`: `p=B_7`. `B_4` dom `B_7`. Does `B_4` strictly dom `B_4`? No. So, `B_4 \\in DF(B_4)`. This is the loop-back edge. Join points in loops are in their own DF.\n                *   Case `y = B_8`: `p=B_7`. `B_4` dom `B_7`. Does `B_4` strictly dom `B_8`? Yes. `idom(B_8)=B_7`, and `idom(B_7)=B_4`. So `B_4` is an ancestor of `B_8` in the dom-tree. So `B_8` is not in `DF(B_4)`.\n                *   Succs of `B_8`: `{}`.\n                *   So, `DF(B_4) = {B_4}`.\n            *   `DF(B_5)`:\n                *   `n = B_5`. `B_5` dom only `B_5`.\n                *   Successor of `B_5` is `y=B_7`. Predecessor `p=B_5`.\n                *   `B_5` dom `B_5`. Does `B_5` strictly dom `B_7`? No. `Dom(B_7) = {B_1, B_4, B_7}`.\n                *   So, `B_7 \\in DF(B_5)`.\n                *   `DF(B_5) = {B_7}`.\n            *   `DF(B_6)`:\n                *   `n = B_6`. `B_6` dom only `B_6`.\n                *   Successor of `B_6` is `y=B_7`. Predecessor `p=B_6`.\n                *   `B_6` dom `B_6`. Does `B_6` strictly dom `B_7`? No. `Dom(B_7) = {B_1, B_4, B_7}`.\n                *   So, `B_7 \\in DF(B_6)`.\n                *   `DF(B_6) = {B_7}`.\n            *   `DF(B_7)`:\n                *   `n = B_7`. `B_7` dom `B_7` and `B_8`.\n                *   Successors of `B_7`: `{B_4, B_8}`.\n                *   `y = B_4`. Predecessor `p = B_7`. `B_7` dom `B_7`. Does `B_7` strictly dom `B_4`? No. `B_4` dom `B_7`. So `B_4 \\in DF(B_7)`.\n                *   `y = B_8`. Predecessor `p=B_7`. `B_7` dom `B_7`. Does `B_7` strictly dom `B_8`? Yes, `idom(B_8)=B_7`. So, `B_8` is not in `DF(B_7)`.\n                *   Successors of `B_8`: `{}`. Predecessor of anything is not `B_8`.\n                *   So, `DF(B_7) = {B_4}`.\n            *   `DF(B_8)`:\n                *   `n = B_8`. `B_8` dom only `B_8`.\n                *   Successors of `B_8`: `{}`.\n                *   `DF(B_8) = {}`.\n\n        *   **Summary of Dominance Frontiers (Part 1):**\n            *   `DF(B_1) = {}`\n            *   `DF(B_2) = {B_4}`\n            *   `DF(B_3) = {B_4}`\n            *   `DF(B_4) = {B_4}`\n            *   `DF(B_5) = {B_7}`\n            *   `DF(B_6) = {B_7}`\n            *   `DF(B_7) = {B_4}`\n            *   `DF(B_8) = {}`\n\n    *   **Part 2: Compute $\\phi$-function placement**\n        *   Algorithm: Iterated Dominance Frontier.\n        *   Input: A set of nodes `S` containing definitions of a variable `v`.\n        *   Output: A set of nodes `\\Phi` that need $\\phi$-functions for `v`.\n        *   Algorithm:\n            1.  `W = S` (Worklist)\n            2.  `\\Phi = {}` (Set of nodes with $\\phi$-functions)\n            3.  `while W is not empty:`\n            4.      `remove a node n from W`\n            5.      `for each y in DF(n):`\n            6.          `if y not in \\Phi:`\n            7.              `\\Phi = \\Phi U {y}`\n            8.              `add y to W`\n        *   Let's trace it.\n        *   **Initial state:**\n            *   `S = {B_1, B_2}` (given definition sites for `v`)\n            *   `W = {B_1, B_2}`\n            *   `\\Phi = {}`\n\n        *   **Iteration 1:**\n            *   `remove B_1 from W`. `W = {B_2}`.\n            *   `DF(B_1) = {}`. The inner loop does nothing.\n            *   `\\Phi` remains `{}`.\n\n        *   **Iteration 2:**\n            *   `remove B_2 from W`. `W = {}`.\n            *   `DF(B_2) = {B_4}`.\n            *   Let `y = B_4`.\n            *   `B_4` is not in `\\Phi`.\n            *   `\\Phi = \\Phi U {B_4} = {B_4}`.\n            *   `add B_4 to W`. So, `W = {B_4}`.\n\n        *   **Iteration 3:**\n            *   `W` is not empty. `W = {B_4}`.\n            *   `remove B_4 from W`. `W = {}`.\n            *   `DF(B_4) = {B_4}`.\n            *   Let `y = B_4`.\n            *   Is `B_4` in `\\Phi`? Yes. The `if` condition `y not in \\Phi` is false.\n            *   The loop finishes. `W` is empty. Wait. Oh, I made a mistake.\n            *   Initial definition sites are `S = {B_1, B_2}`.\n            *   The algorithm from the dragon book says: for each variable `a`, let `Defs(a)` be the set of blocks containing definitions of `a`. Calculate `DF^+(Defs(a))`. `DF^+(X) = DF(X)`.\n            *   The algorithm should compute the iterated dominance frontier of the set `S`.\n            *   `F_0 = S = {B_1, B_2}`\n            *   `F_{i+1} = F_i U DF(F_i)`, where `DF(X) = U_{x \\in X} DF(x)`. Take the union until a fixed point is reached.\n            *   The set of nodes for $\\phi$-functions is `DF^+(S)`. Let's re-read the algorithm I wrote down. It's the standard worklist algorithm for `DF^+`. Let's re-trace.\n\n        *   **Let's re-trace the worklist algorithm carefully.**\n        *   **Initial state:**\n            *   `S = {B_1, B_2}`\n            *   `W = {B_1, B_2}`\n            *   `\\Phi = {}`\n\n        *   **Step 1:** pop `B_1` from `W`.\n            *   `W = {B_2}`.\n            *   `DF(B_1) = {}`. Nothing happens.\n            *   `\\Phi = {}`.\n\n        *   **Step 2:** pop `B_2` from `W`.\n            *   `W = {}`.\n            *   `DF(B_2) = {B_4}`.\n            *   For `y = B_4`:\n                *   Is `B_4` in `\\Phi`? No.\n                *   `\\Phi = {B_4}`.\n                *   Add `B_4` to `W`. `W = {B_4}`.\n\n        *   **Step 3:** `W` is not empty. Pop `B_4` from `W`.\n            *   `W = {}`.\n            *   `DF(B_4) = {B_4}`.\n            *   For `y = B_4`:\n                *   Is `B_4` in `\\Phi`? Yes.\n                *   The `if` condition is false. Nothing is added to `\\Phi` or `W`.\n\n        *   **Step 4:** `W` is now empty. The algorithm terminates.\n\n        *   The resulting set of blocks where $\\phi$-functions must be placed is `\\Phi = {B_4}`.\n\n    *   Wait, I might have misunderstood something. Let's double check the process.\n    *   The problem is about placing $\\phi$-functions.\n    *   A $\\phi$-function is needed for variable `v` at node `n` if `n` is in the dominance frontier of any node `m` containing a definition of `v`, and `v` is live-in at `n`. The liveness part is often simplified by placing them at all DF locations and then pruning dead ones. The question asks for placement based on the iterated dominance frontier, which is the standard algorithm.\n    *   The iterated dominance frontier `DF^+(S)` is the set of all nodes `y` such that there exists a path `n_0 \\to n_1 \\to ... \\to n_k = y` in the CFG where `n_0 \\in S` and `y \\in DF(n_{i})` for some `i  k`, and for all `j  k`, `n_{j+1}` is in the dominance frontier of some node dominated by `n_j`. The worklist algorithm correctly computes `DF^+(S)`.\n\n    *   Let's check the logic again.\n    *   The algorithm computes the set of nodes `\\Phi` where $\\phi$-functions for `v` are needed.\n    *   Initial definitions of `v` are in `A_0 = {B_1, B_2}`.\n    *   We need to compute `DF^+(A_0)`.\n    *   `DF^+(S)` is the smallest set `Y` such that:\n        1. `DF(S) \\subseteq Y`\n        2. `x \\in Y \\implies DF(x) \\subseteq Y`\n    *   Let's compute it iteratively:\n        *   `S_0 = A_0 = {B_1, B_2}`.\n        *   `J_0 = DF(S_0) = DF(B_1) U DF(B_2) = {} U {B_4} = {B_4}`.\n        *   `S_1 = S_0 U J_0 = {B_1, B_2, B_4}`.\n        *   `J_1 = DF(S_1) = DF(B_1) U DF(B_2) U DF(B_4) = {} U {B_4} U {B_4} = {B_4}`.\n        *   `S_2 = S_1 U J_1 = {B_1, B_2, B_4} U {B_4} = {B_1, B_2, B_4}`.\n        *   `S_2 = S_1`. We have reached a fixed point. The set of new definitions is `S_1 = {B_1, B_2, B_4}`.\n        *   The set of nodes where $\\phi$-functions are placed is `J_0 U J_1 U ...` which is the union of all new nodes added, i.e., `J_0 U J_1 = {B_4}`.\n\n    *   So, the set of nodes requiring a $\\phi$-function is `{B_4}`. This seems correct.\n    *   The worklist algorithm I ran also gave `{B_4}`. Let's re-verify that.\n    *   `W = {B_1, B_2}`\n    *   `\\Phi = {}`\n    *   Pop `B_1`: `DF(B_1) = {}`. No change. `W={B_2}`, `\\Phi={}`.\n    *   Pop `B_2`: `DF(B_2) = {B_4}`. `B_4` is not in `\\Phi`. Add `B_4` to `\\Phi` and `W`. `W={B_4}`, `\\Phi={B_4}`.\n    *   Pop `B_4`: `DF(B_4) = {B_4}`. `B_4` is already in `\\Phi`. No change. `W={}`.\n    *   `W` is empty. Terminate. `\\Phi = {B_4}`.\n    *   Both methods give the same result. The set of blocks where $\\phi$-functions for `v` must be placed is `{B_4}`.\n\n    *   **Interpretation of the result:**\n        *   Variable `v` is defined in `B_1` and `B_2`.\n        *   `B_1` and `B_2` are two branches that join at `B_4`.\n        *   Therefore, at the entry of `B_4`, we need to know which version of `v` to use: the one from `B_2` or the one from `B_3` (which in turn gets it from `B_1`).\n        *   A $\\phi$-function `v_3 = \\phi(v_1, v_2)` is needed at `B_4`. Here `v_1` comes from `B_2` and `v_2` comes from `B_3`.\n        *   The definition of `v` in `B_1` gives `v` a value.\n        *   The definition of `v` in `B_2` gives `v` a new value.\n        *   So, on the path `B_1 \\to B_2 \\to B_4`, the value of `v` reaching `B_4` is the one defined in `B_2`.\n        *   On the path `B_1 \\to B_3 \\to B_4`, the value of `v` reaching `B_4` is the one defined in `B_1`.\n        *   So different definitions of `v` reach `B_4`. `B_4` is a join point. A $\\phi$-function is needed. This matches intuition.\n        *   Now, consider the new \"definition\" `v_3` created by the $\\phi$-function in `B_4`.\n        *   This new `v_3` is used in the loop `B_4 \\to ... \\to B_7 \\to B_4`.\n        *   The path `B_4 \\to B_5 \\to B_7 \\to B_4` brings a value of `v` back to `B_4`. This value depends on `v_3`.\n        *   But the original problem states definitions are ONLY in `B_1` and `B_2`. So, inside the loop, `v` is not redefined.\n        *   So, the value of `v` entering the loop `B_4` is either from `B_2` or from `B_1` (via `B_3`). Let's call these `v_def_B2` and `v_def_B1`.\n        *   At `B_4`, a $\\phi$-node is needed: `v_phi_B4 = \\phi(v_from_B2, v_from_B3)`.\n        *   The problem is about PLACEMENT, based on the iterated dominance frontier. We are computing `DF^+({B_1, B_2})`.\n        *   A definition in `B_1` reaches `B_3`.\n        *   A definition in `B_2`.\n        *   These two \"reach\" `B_4`. The dominance frontier of `{B_2, B_3}` will contain `B_4`. But we only care about `DF` of definition sites.\n        *   `DF(B_1) = {}`.\n        *   `DF(B_2) = {B_4}`.\n        *   So `DF({B_1, B_2}) = {B_4}`.\n        *   This causes a $\\phi$-function to be inserted at `B_4`. This $\\phi$-function itself is a new definition site for `v`.\n        *   So the new set of definitions is `{B_1, B_2, B_4}`.\n        *   We must now compute the DF for `B_4`. `DF(B_4) = {B_4}`.\n        *   This means a $\\phi$-function is needed at `B_4`. But we already put one there. So we don't add a new one. The set of locations for $\\phi$-functions stops growing.\n        *   What about other nodes?\n        *   `B_5` and `B_6` have a common successor `B_7`, which is a join point. Are any definitions of `v` reaching `B_7` from different paths?\n        *   The `v` used in `B_5` comes from `B_4`. The `v` used in `B_6` also comes from `B_4`.\n        *   So, at the join point `B_7`, both incoming paths (`B_5 \\to B_7` and `B_6 \\to B_7`) carry the *same* version of `v` (the one from `B_4`). Therefore, a $\\phi$-function is NOT needed at `B_7`.\n        *   Let's check this with the algorithm.\n        *   A phi-function is needed at `y` if `y` is in `DF^+(S)`.\n        *   Our `S = {B_1, B_2}`. We found `DF^+(S) = {B_4}`.\n        *   `B_7` is not in this set. So the algorithm confirms no $\\phi$-function is needed at `B_7`.\n        *   Let's see why. For `B_7` to require a $\\phi$-function, it must be in the dominance frontier of a node that has a definition.\n        *   The original definition sites are `B_1` and `B_2`. `DF(B_1) = {}`. `DF(B_2) = {B_4}`. Neither is `{B_7}`.\n        *   The new virtual definition site is `B_4`. `DF(B_4) = {B_4}`. Not `{B_7}`.\n        *   What about `B_5` and `B_6`? They do not contain definitions of `v`. `DF(B_5) = {B_7}` and `DF(B_6) = {B_7}`. But since there are no definitions in `B_5` or `B_6`, this doesn't trigger a $\\phi$-function placement at `B_7`.\n        *   So the calculation `DF^+( {B_1, B_2} ) = {B_4}` appears correct.\n\n    *   **Part 3: Final Answer**\n        *   The question asks for the total number of distinct $\\phi$-functions inserted for `v`.\n        *   This is the size of the set `\\Phi`.\n        *   `\\Phi = {B_4}`.\n        *   The size is `|{B_4}| = 1`.\n        *   So one $\\phi$-function is inserted, in basic block `B_4`.\n\n    *   **Final Sanity Check of the entire process:**\n        1.  **Dominators:**\n            *   `Dom(B_1) = {B_1}`\n            *   `Dom(B_2) = {B_1, B_2}`\n            *   `Dom(B_3) = {B_1, B_3}`\n            *   `Dom(B_4) = {B_1, B_4}` (Paths `B_1-B_2-B_4` and `B_1-B_3-B_4` meet at `B_4`. Post-`B_1`, no common node until `B_4`. The loop `B_4-B_7` does not change this). It seems correct.\n            *   `Dom(B_5) = {B_1, B_4, B_5}` (Must go through `B_4`). Correct.\n            *   `Dom(B_6) = {B_1, B_4, B_6}` (Must go through `B_4`). Correct.\n            *   `Dom(B_7) = {B_1, B_4, B_7}` (Must go through `B_4`). Correct.\n            *   `Dom(B_8) = {B_1, B_4, B_7, B_8}` (Must go through `B_7`, which must go through `B_4`). Correct.\n        2.  **Immediate Dominators:**\n            *   `idom(B_2) = B_1`\n            *   `idom(B_3) = B_1`\n            *   `idom(B_4) = B_1`\n            *   `idom(B_5) = B_4`\n            *   `idom(B_6) = B_4`\n            *   `idom(B_7) = B_4`\n            *   `idom(B_8) = B_7`\n            *   This generates the Dominator Tree: `B_1` is parent of `B_2, B_3, B_4`. `B_4` is parent of `B_5, B_6, B_7`. `B_7` is parent of `B_8`. This looks correct.\n\n        3.  **Dominance Frontiers:**\n            *   `DF(n) = { y | ∃p ∈ pred(y) s.t. n dom p, but n !sdom y }`\n            *   `DF(B_1) = {}` (Entry node) - OK.\n            *   `DF(B_2) = {B_4}`. `p=B_2`, `y=B_4`. `B_2` dom `B_2`. `B_2` !sdom `B_4`. OK.\n            *   `DF(B_3) = {B_4}`. `p=B_3`, `y=B_4`. `B_3` dom `B_3`. `B_3` !sdom `B_4`. OK.\n            *   `DF(B_4) = {B_4}`. `p=B_7`, `y=B_4`. `B_4` dom `B_7`. `B_4` !sdom `B_4`. This is the loop-back edge. OK.\n            *   `DF(B_5) = {B_7}`. `p=B_5`, `y=B_7`. `B_5` dom `B_5`. `B_5` !sdom `B_7` (`Dom(B_7)` does not contain `B_5`). OK.\n            *   `DF(B_6) = {B_7}`. `p=B_6`, `y=B_7`. `B_6` dom `B_6`. `B_6` !sdom `B_7`. OK.\n            *   `DF(B_7) = {B_4}`. `p=B_7`, `y=B_4`. `B_7` dom `B_7`. `B_7` !sdom `B_4`. OK.\n            *   `DF(B_8) = {}`. `B_8` has no successors. OK.\n            *   The DF calculations seem solid.\n\n        4.  **Iterated Dominance Frontier:**\n            *   `S = {B_1, B_2}`\n            *   `W = {B_1, B_2}`\n            *   `Phi = {}`\n            *   Process `B_1`: `DF(B_1) = {}`. No additions.\n            *   Process `B_2`: `DF(B_2) = {B_4}`. Add `B_4` to `Phi` and `W`. `Phi = {B_4}`, `W = {B_4}`.\n            *   Process `B_4`: `DF(B_4) = {B_4}`. `B_4` is already in `Phi`. No additions.\n            *   `W` is empty. Algorithm terminates.\n            *   The result is `Phi = {B_4}`.\n            *   The number of elements in `Phi` is 1.\n\n    *   The entire chain of reasoning seems correct. The concepts are standard compiler theory. The application of the algorithms to the specific CFG is methodical and verifiable. The final answer is the size of the resulting set.\n\n    *   Let's check for any subtle traps. Is there any ambiguity in \"total number of distinct $\\phi$-functions inserted for `v`\"? No, it just means the number of basic blocks that get a $\\phi$-function for this variable. It's `|\\Phi|`. The wording is clear.\n    *   The problem is well-defined and my solution appears robust.\n    *   The structure of my response will be:\n        1.  Problem validation (it's valid).\n        2.  First principles: Define Dominator, Immediate Dominator, Dominance Frontier.\n        3.  Step 1 of the problem: Compute dominators and then dominance frontiers for all blocks. Present the results clearly, maybe in a table.\n        4.  Step 2 of the problem: Define the iterated dominance frontier algorithm. Execute it step-by-step with the given initial definition set `{B_1, B_2}` and the DFs calculated in the previous step.\n        5.  Step 3: State the final result from the algorithm, which is the set of blocks for $\\phi$-functions. Then state the count, which is the final answer.\n    *   All math entities will be in LaTeX.\n    *   No markdown headers.\n    *   The final answer will be in `$$\\boxed{...}$$`.\n\n    *   The process looks sound. I am confident in the result. The result is `1`.",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "With the foundational algorithm in hand, we can now apply it to more complex and realistic code structures. Real-world loops often contain control-flow statements like `break` and `continue`, which create non-obvious join points that must be handled correctly during SSA construction. This exercise challenges you to analyze such a program, model its control-flow graph, and determine the necessary $\\phi$-functions for a variable modified within the loop ().",
            "id": "3671619",
            "problem": "An optimizing compiler converts a program into Static Single Assignment (SSA) form, where each variable is assigned exactly once and merges of different reaching definitions at control-flow joins are expressed with the $\\phi$-function. The compiler uses the Control-Flow Graph (CFG) as the structural basis and follows the standard dominance and dominance-frontier method to place $\\phi$-functions, with pruning by liveness so that a $\\phi$-function for a variable is inserted at a join only if the variable is live there. Consider the following structured program, which uses both a loop and control transfers via break and continue:\n- Inputs: an integer $n$ and an integer array $A[\\,]$ indexed from $0$.\n- Variables: integers $x$, $y$, $i$.\n- Initialization: $x \\leftarrow 0$; $i \\leftarrow 0$.\n- Loop: while $\\big(i  n\\big)$ do\n  1. If $\\big(A[i]  0\\big)$ then $x \\leftarrow x + 1$ else $x \\leftarrow x + A[i]$.\n  2. If $\\big(A[i] = 0\\big)$ then break.\n  3. If $\\big((A[i] \\bmod 2) = 0\\big)$ then $i \\leftarrow i + 1$; continue.\n  4. $y \\leftarrow x + i$.\n  5. $i \\leftarrow i + 1$.\n- After the loop exits, return $x$.\nAssume the usual structured translation to a Control-Flow Graph (CFG), in which:\n- The loop condition forms a loop header with two predecessors: a unique preheader and the loop backedge(s).\n- The first conditional (step 1) is an if-else that reconverges before step 2.\n- The break in step 2 transfers control to the unique loop-exit block, which also receives the fall-through from the loop header when the loop condition fails.\n- The continue in step 3 transfers control along a backedge to the loop header.\nUsing the standard dominance and dominance-frontier characterization of $\\phi$-placement (as in Cytron et al.), and constructing pruned SSA (insert $\\phi$ only where the variable is live), determine the minimal total number of $\\phi$-functions that must be inserted specifically for the variable $x$ across the entire program, including at the loop header and at the loop exit due to break paths. Provide the final answer as an integer. No rounding is required.",
            "solution": "The problem requires determining the minimal number of $\\phi$-functions for the variable $x$ when converting a given program into pruned Static Single Assignment (SSA) form. The standard algorithm for this task, as specified, involves two main stages:\n1.  Placement of $\\phi$-functions using the dominance frontier criterion.\n2.  Pruning of inserted $\\phi$-functions where the variable is not live.\n\nWe will follow these steps methodically.\n\nFirst, we construct the Control-Flow Graph (CFG) based on the program structure and the provided translation rules. Let us define the basic blocks:\n-   `B_Init`: Contains the initial assignments $x \\leftarrow 0$ and $i \\leftarrow 0$. It is the preheader to the loop.\n-   `B_Header`: The loop header, which evaluates the condition $i  n$.\n-   `B_IfBody`: The entry to the loop body, containing the first conditional test, $A[i]  0$.\n-   `B_Then`: The 'then' branch of the first conditional, containing $x \\leftarrow x + 1$.\n-   `B_Else`: The 'else' branch of the first conditional, containing $x \\leftarrow x + A[i]$.\n-   `B_Join1`: The reconvergence point for the first `if-else` statement.\n-   `B_BreakTest`: Contains the second conditional test, $A[i] = 0$, for the `break`.\n-   `B_ContTest`: Contains the third conditional test, $(A[i] \\bmod 2) = 0$, for the `continue`.\n-   `B_Continue`: Contains $i \\leftarrow i + 1$ and the `continue` transfer.\n-   `B_BodyEnd`: Contains the final part of the loop body, $y \\leftarrow x + i$ and $i \\leftarrow i + 1$.\n-   `B_Exit`: The unique loop-exit block, containing `return x`.\n\nThe control flow is as follows:\n-   `B_Init` $\\rightarrow$ `B_Header`\n-   `B_Header` $\\rightarrow$ `B_IfBody` (if $i  n$)\n-   `B_Header` $\\rightarrow$ `B_Exit` (if $i \\ge n$)\n-   `B_IfBody` $\\rightarrow$ `B_Then` (if $A[i]  0$)\n-   `B_IfBody` $\\rightarrow$ `B_Else` (if $A[i] \\ge 0$)\n-   `B_Then` $\\rightarrow$ `B_Join1`\n-   `B_Else` $\\rightarrow$ `B_Join1`\n-   `B_Join1` $\\rightarrow$ `B_BreakTest`\n-   `B_BreakTest` $\\rightarrow$ `B_Exit` (if $A[i] = 0$, the `break` path)\n-   `B_BreakTest` $\\rightarrow$ `B_ContTest` (if $A[i] \\ne 0$)\n-   `B_ContTest` $\\rightarrow$ `B_Continue` (if $(A[i] \\bmod 2) = 0$)\n-   `B_ContTest` $\\rightarrow$ `B_BodyEnd` (if $(A[i] \\bmod 2) \\ne 0$)\n-   `B_Continue` $\\rightarrow$ `B_Header` (backedge)\n-   `B_BodyEnd` $\\rightarrow$ `B_Header` (backedge)\n\nThe core principle of SSA construction is that a $\\phi$-function for a variable $v$ is required at any node $N$ where different reaching definitions of $v$ converge. The set of all such nodes $N$ is precisely the iterated dominance frontier, denoted $DF^+$, of the set of nodes containing assignments to $v$.\n\nThe assignments (definitions) to the variable $x$ occur in three blocks:\n-   `B_Init`: $x \\leftarrow 0$\n-   `B_Then`: $x \\leftarrow x + 1$\n-   `B_Else`: $x \\leftarrow x + A[i]$\n\nLet $S = \\{ \\text{B\\_Init, B\\_Then, B\\_Else} \\}$ be the set of blocks containing definitions of $x$. We must compute $DF^+(S)$. This is done iteratively. Let $\\Phi$ be the set of blocks where $\\phi$-functions are placed. Initially, $\\Phi = \\emptyset$.\n\n1.  **Initial $\\phi$-placement:** We compute the dominance frontiers for the blocks in $S$.\n    -   The definitions in `B_Then` and `B_Else` are distinct. They both reach `B_Join1`, which is the first point of control-flow convergence after these blocks. Formally, `B_Join1` is in the dominance frontier of both `B_Then` and `B_Else`. Thus, a $\\phi$-function for $x$ must be placed at `B_Join1`.\n    $\\Phi_1 = DF(\\text{B\\_Then}) \\cup DF(\\text{B\\_Else}) = \\{ \\text{B\\_Join1} \\}$.\n    So, a $\\phi$-function is placed at `B_Join1`. This is our first $\\phi$-function.\n\n2.  **Iterated $\\phi$-placement:** The placement of a $\\phi$-function at `B_Join1` effectively creates a new definition of $x$ at that block. We must now consider the dominance frontier of `B_Join1`.\n    -   A definition of $x$ at `B_Init` (outside the loop) and the new definition of $x$ at `B_Join1` (inside the loop, which flows back via the backedges from `B_Continue` and `B_BodyEnd`) both reach `B_Header`. Therefore, `B_Header` is a join point for these definitions. Formally, `B_Header` is in the dominance frontier of `B_Join1` (and other blocks inside the loop). Thus, a $\\phi$-function is needed at `B_Header`.\n    -   The `break` statement creates a path from `B_BreakTest` to `B_Exit`. The value of $x$ on this path comes from the definition at `B_Join1`. The normal loop termination path is from `B_Header` to `B_Exit`. The value of $x$ on this path comes from the $\\phi$-function at `B_Header`. These two distinct definitions of $x$ meet at `B_Exit`. Therefore, `B_Exit` is a join point. Formally, `B_Exit` is in the dominance frontier of `B_Join1`.\n    So, we have $\\Phi_2 = DF(\\text{B\\_Join1}) = \\{ \\text{B\\_Header, B\\_Exit} \\}$. We add these two blocks to our set of $\\phi$-locations. These are our second and third $\\phi$-functions.\n\n3.  **Further Iteration:** We must now consider the dominance frontiers of the new $\\phi$-locations, `B_Header` and `B_Exit`.\n    -   `DF(\\text{B\\_Header}) = \\emptyset`. No further join points are created by the definition at `B_Header`.\n    -   `DF(\\text{B\\_Exit}) = \\emptyset`. This block is the end of this part of the control flow.\n    The iteration terminates. The set of blocks requiring $\\phi$-functions for $x$ in unpruned SSA form is $\\{ \\text{B\\_Join1, B\\_Header, B\\_Exit} \\}$. This gives a total of $3$ $\\phi$-functions.\n\nNow, we must apply the pruning rule: a $\\phi$-function for $x$ is inserted at a block $N$ only if $x$ is \"live\" at the entry of $N$. A variable is live if its current value may be used in the future. We examine the liveness of $x$ at the entry of each of the three candidate blocks.\n\nThe uses of $x$ occur in:\n-   `B_Then`: in the expression $x + 1$.\n-   `B_Else`: in the expression $x + A[i]$.\n-   `B_BodyEnd`: in the expression $x + i$.\n-   `B_Exit`: in the expression `return x`.\n\n-   **Liveness at `B_Join1`:** Is $x$ live at the entry of `B_Join1`? Yes. There is a path from `B_Join1` to `B_BodyEnd` where $x$ is used to compute $y$. There is also a path from `B_Join1` to `B_Exit` via the `break`, where $x$ is used in the `return` statement. Since there is a future use, $x$ is live. The $\\phi$-function at `B_Join1` is **not pruned**.\n\n-   **Liveness at `B_Header`:** Is $x$ live at the entry of `B_Header`? Yes. A value of $x$ entering the loop header can be used on the first iteration in either `B_Then` or `B_Else`. It can also be used after the loop terminates via the path `B_Header` $\\rightarrow$ `B_Exit`, where the `return x` statement is. Since there is a future use, $x$ is live. The $\\phi$-function at `B_Header` is **not pruned**.\n\n-   **Liveness at `B_Exit`:** Is $x$ live at the entry of `B_Exit`? Yes. The block `B_Exit` itself contains the statement `return x`, which is a use of $x$. A variable is always live at the entry of a block if it is used in that block before any re-definition. The $\\phi$-function at `B_Exit` is **not pruned**.\n\nSince $x$ is live at the entry of all three blocks—`B_Join1`, `B_Header`, and `B_Exit`—none of the $\\phi$-functions placed by the dominance frontier criterion are pruned.\n\nTherefore, the minimal total number of $\\phi$-functions required for the variable $x$ is $3$.",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "The lifecycle of SSA form concludes when the compiler generates executable code, a process known as \"lowering\" or SSA elimination. The abstract $\\phi$-functions, which notionally execute in parallel, must be translated into a sequence of concrete machine instructions like register-to-register moves. This final practice explores the challenge of scheduling these moves, especially when dependencies create cycles that require temporary registers to resolve ().",
            "id": "3671657",
            "problem": "In static single assignment (SSA) form, the semantics of a $\\phi$-function at the entry of a basic block require that upon control transfer along a predecessor edge, each $\\phi$-node selects exactly the value produced along that edge, as if all selected assignments happen simultaneously at block entry. Let $B$ be a join block with predecessors $P_1$ and $P_2$. The block $B$ contains three $\\phi$-nodes for variables $x$, $y$, and $z$. A target register assignment in $B$ has been fixed: $x$ is assigned to register $r_2$, $y$ to $r_3$, and $z$ to $r_1$. At the end of each predecessor, the values that feed these $\\phi$-nodes reside in the following machine registers:\n\n- Along edge $P_1 \\to B$: $x_1$ is in $r_1$, $y_1$ is in $r_2$, and $z_1$ is in $r_3$.\n- Along edge $P_2 \\to B$: $x_2$ is in $r_2$, $y_2$ is in $r_1$, and $z_2$ is in $r_3$.\n\nTo eliminate the $\\phi$-nodes, you will lower them into per-edge parallel copies that move source registers into their destination registers in $B$. A parallel copy set on an edge must be implemented by a sequential list of concrete moves of the form $a := b$, executed at the edge, that collectively preserve the simultaneous semantics. You may omit any move where source and destination are the same register. You are allowed exactly one fresh temporary register $t$ (which is distinct from $r_1$, $r_2$, and $r_3$) to break cycles in a copy dependency; using $t$ is permitted independently on each edge. Define an “extra move” on an edge to be any executed move beyond the number of non-identity copies implied by that edge’s parallel copy set.\n\nTasks:\n- For each edge $P_i \\to B$ ($i \\in \\{1,2\\}$), derive the parallel copy set induced by the three $\\phi$-nodes under the specified register locations.\n- Propose a valid sequential move schedule on each edge that implements the parallel copy set, avoids destructive cycles by using $t$ only when strictly necessary, and minimizes the number of extra moves on that edge.\n- Among all valid schedules under these rules, determine the minimal total number of extra moves across both edges $P_1 \\to B$ and $P_2 \\to B$.\n\nProvide as your final answer a single integer equal to this minimal total number of extra moves across the two edges. No rounding is required.",
            "solution": "The problem requires us to determine the minimal total number of \"extra moves\" needed to lower the $\\phi$-functions at the entry of a basic block $B$ into sequential move instructions on its predecessor edges, $P_1 \\to B$ and $P_2 \\to B$. An extra move is defined as any executed move beyond the number of non-identity copies for a given edge.\n\nFirst, let's establish the target state. At the entry of block $B$, the values for variables $x$, $y$, and $z$ must be in registers $r_2$, $r_3$, and $r_1$ respectively. The $\\phi$-functions define which predecessor values are used:\n- $x_{B} = \\phi(x_1 \\text{ from } P_1, x_2 \\text{ from } P_2)$\n- $y_{B} = \\phi(y_1 \\text{ from } P_1, y_2 \\text{ from } P_2)$\n- $z_{B} = \\phi(z_1 \\text{ from } P_1, z_2 \\text{ from } P_2)$\n\nWe analyze each predecessor edge separately.\n\n**Analysis of Edge $P_1 \\to B$**\n\nOn the edge from predecessor $P_1$, the values $x_1$, $y_1$, and $z_1$ are the sources for the $\\phi$-functions. The problem states their locations at the end of block $P_1$:\n- $x_1$ is in register $r_1$.\n- $y_1$ is in register $r_2$.\n- $z_1$ is in register $r_3$.\n\nTo establish the required state at the entry of block $B$, the following simultaneous assignments, known as a parallel copy, must occur on the edge $P_1 \\to B$:\n- The value for $x$ in $B$ (in $r_2$) must come from $x_1$ (in $r_1$). This implies the copy $r_2 := r_1$.\n- The value for $y$ in $B$ (in $r_3$) must come from $y_1$ (in $r_2$). This implies the copy $r_3 := r_2$.\n- The value for $z$ in $B$ (in $r_1$) must come from $z_1$ (in $r_3$). This implies the copy $r_1 := r_3$.\n\nThe parallel copy set for this edge is $\\{r_2 := r_1, r_3 := r_2, r_1 := r_3\\}$. All three are non-identity copies. To implement this with sequential moves, we must analyze the dependencies. A dependency $r_s \\to r_d$ exists for each copy $r_d := r_s$, as the original value in $r_s$ is needed. The dependency graph is:\n$r_1 \\to r_2$\n$r_2 \\to r_3$\n$r_3 \\to r_1$\n\nThese dependencies form a 3-cycle: $r_1 \\to r_2 \\to r_3 \\to r_1$. A direct sequential implementation, such as $r_2 := r_1$, would destroy the value in $r_1$ needed for a subsequent copy. Such a cycle makes it \"strictly necessary\" to use the provided temporary register, $t$.\n\nTo break a cycle of length $k \\ge 2$, the optimal sequence using a temporary register requires $k+1$ moves. Here, $k=3$. A minimal move schedule is:\n1. $t := r_3$ (Save the value of $z_1$)\n2. $r_3 := r_2$ (Move the value of $y_1$ to its destination $r_3$)\n3. $r_2 := r_1$ (Move the value of $x_1$ to its destination $r_2$)\n4. $r_1 := t$ (Move the saved value of $z_1$ to its destination $r_1$)\n\nThe number of non-identity copies is $3$. The number of executed sequential moves is $4$. The number of extra moves is the difference: $4 - 3 = 1$. This is the minimum possible for this edge, as one extra move is required to break the cycle.\n\n**Analysis of Edge $P_2 \\to B$**\n\nOn the edge from predecessor $P_2$, the values $x_2$, $y_2$, and $z_2$ are the sources. Their locations at the end of block $P_2$ are:\n- $x_2$ is in register $r_2$.\n- $y_2$ is in register $r_1$.\n- $z_2$ is in register $r_3$.\n\nThe parallel copy for the edge $P_2 \\to B$ is derived similarly:\n- The value for $x$ in $B$ (in $r_2$) must come from $x_2$ (in $r_2$). This implies the copy $r_2 := r_2$.\n- The value for $y$ in $B$ (in $r_3$) must come from $y_2$ (in $r_1$). This implies the copy $r_3 := r_1$.\n- The value for $z$ in $B$ (in $r_1$) must come from $z_2$ (in $r_3$). This implies the copy $r_1 := r_3$.\n\nThe parallel copy set is $\\{r_2 := r_2, r_3 := r_1, r_1 := r_3\\}$.\nThe problem allows us to omit moves where the source and destination are identical. Thus, the move $r_2 := r_2$ is not executed. The set of non-identity copies is $\\{r_3 := r_1, r_1 := r_3\\}$.\n\nThe dependency graph for these two copies is:\n$r_1 \\to r_3$\n$r_3 \\to r_1$\n\nThis forms a 2-cycle: $r_1 \\to r_3 \\to r_1$. This represents a swap operation. As with the previous case, a cycle necessitates the use of the temporary register $t$. To break this cycle of length $k=2$, we need $k+1 = 3$ sequential moves. A minimal move schedule is:\n1. $t := r_1$ (Save the value of $y_2$)\n2. $r_1 := r_3$ (Move the value of $z_2$ to its destination $r_1$)\n3. $r_3 := t$ (Move the saved value of $y_2$ to its destination $r_3$)\n\nThe number of non-identity copies is $2$. The number of executed sequential moves is $3$. The number of extra moves is the difference: $3 - 2 = 1$. This is the minimum possible, as one extra move is required to resolve the swap cycle.\n\n**Total Minimal Extra Moves**\n\nThe minimal number of extra moves is the sum of the minimal extra moves required for each edge.\n- Minimal extra moves for edge $P_1 \\to B$: $1$.\n- Minimal extra moves for edge $P_2 \\to B$: $1$.\n\nThe total minimal number of extra moves across both edges is $1 + 1 = 2$.",
            "answer": "$$\n\\boxed{2}\n$$"
        }
    ]
}