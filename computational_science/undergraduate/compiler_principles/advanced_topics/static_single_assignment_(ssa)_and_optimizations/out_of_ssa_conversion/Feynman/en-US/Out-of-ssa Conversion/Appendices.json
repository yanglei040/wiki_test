{
    "hands_on_practices": [
        {
            "introduction": "The parallel assignment semantics of $\\phi$-functions are powerful for analysis but pose a direct challenge for code generation on sequential machines. This exercise  isolates the most fundamental conflict that arises: a cyclic dependency where two variables must swap values. By reasoning from first principles, you will discover why a sequence of simple moves is insufficient and how a temporary variable becomes essential, forming the basis for any general-purpose out-of-SSA algorithm.",
            "id": "3660448",
            "problem": "Consider a control-flow graph with two predecessor blocks $B_1$ and $B_2$ that both branch to a join block $J$. The program is in Static Single Assignment (SSA) form, where each variable is assigned exactly once, and $\\phi$ nodes in $J$ select incoming values based on the control-flow path. The semantics of a $\\phi$ node are equivalent to inserting parallel copies on the incoming edges to $J$, meaning all copies execute simultaneously at each edge.\n\nSuppose the program is as follows. In $B_1$:\n$x_1 := \\text{val}_x$, $y_1 := \\text{val}_y$, and the control flows to $J$. In $B_2$: $x_2 := \\text{val}_x'$, $y_2 := \\text{val}_y'$, and the control flows to $J$. In $J$:\n$x_3 := \\phi(y_1, x_2)$ and $y_3 := \\phi(x_1, y_2)$, followed by a use $r := x_3 + y_3$. During out-of-SSA conversion, assume a standard coalescing strategy that intends to map $x_3$ to the non-SSA variable $x$ and $y_3$ to $y$, and also maps $x_1$ to $x$ and $y_1$ to $y$ in $B_1$ (similarly for $B_2$). Under these assumptions, the $\\phi$ assignments induce the following parallel copies at the edge $B_1 \\to J$:\n$x \\leftarrow y$ and $y \\leftarrow x$, forming a move cycle. You may assume all variables $x$ and $y$ are live across the edge $B_1 \\to J$.\n\nUsing first principles of SSA semantics and out-of-SSA conversion (parallel copy semantics and sequential move implementation), construct the induced move cycle at $B_1 \\to J$, and then derive a minimal-temporary strategy to implement these parallel copies with sequential moves without violating program semantics. Specifically, model the copies as a directed graph on variables where an edge $u \\to v$ represents a required move $v \\leftarrow u$. Argue from these definitions how to schedule acyclic moves and how to break cycles.\n\nCompute the minimal number of temporaries required to correctly implement the cycle $x \\leftarrow y, y \\leftarrow x$ under the above assumptions. Your final answer must be a single exact integer. No rounding is needed.",
            "solution": "The problem requires an analysis of the out-of-Static Single Assignment (SSA) conversion process, specifically the implementation of parallel copies induced by $\\phi$ nodes. We must determine the minimal number of temporary variables needed to correctly sequentialize a specific move cycle.\n\nFirst, we formalize the setup based on the provided information. The program is in SSA form. In block $B_1$, we have assignments $x_1 := \\text{val}_x$ and $y_1 := \\text{val}_y$. In block $B_2$, we have $x_2 := \\text{val}_x'$ and $y_2 := \\text{val}_y'$. Both blocks branch to a join block $J$. In $J$, two $\\phi$ nodes merge the incoming values:\n$$x_3 := \\phi(y_1, x_2)$$\n$$y_3 := \\phi(x_1, y_2)$$\nThe semantics of the $\\phi$ nodes are defined as parallel copies on the incoming control-flow edges. We are concerned with the edge from $B_1$ to $J$. For this path, the effective assignments are specified by the first arguments of the $\\phi$ nodes:\n$$x_3 \\leftarrow y_1$$\n$$y_3 \\leftarrow x_1$$\nThese assignments must be executed simultaneously.\n\nThe problem states that during out-of-SSA conversion, a coalescing strategy is applied. The SSA variables $\\{x_1, x_2, x_3\\}$ are all mapped to a single non-SSA variable $x$, and $\\{y_1, y_2, y_3\\}$ are mapped to a single non-SSA variable $y$. Applying this mapping to the parallel copy semantics for the edge $B_1 \\to J$, we substitute $x_3 \\to x$, $y_1 \\to y$, $y_3 \\to y$, and $x_1 \\to x$:\n$$x \\leftarrow y$$\n$$y \\leftarrow x$$\nThis means that upon traversing the edge from $B_1$ to $J$, the value of the non-SSA variable $x$ must be updated to the original value of $y$, and simultaneously, the value of $y$ must be updated to the original value of $x$. This is a classic swap operation.\n\nThe problem asks to model these copies as a directed graph where an edge $u \\to v$ represents the move $v \\leftarrow u$. Based on this convention:\n*   The copy $x \\leftarrow y$ is represented by a directed edge from $y$ to $x$: $y \\to x$.\n*   The copy $y \\leftarrow x$ is represented by a directed edge from $x$ to $y$: $x \\to y$.\nThe resulting graph consists of two nodes, $x$ and $y$, and two edges forming a cycle of length $2$: $x \\to y \\to x$.\n\nThe task is to implement these parallel copies using a sequence of simple move instructions. Let's denote the values of $x$ and $y$ before the copies as $x_{old}$ and $y_{old}$. The desired final state is $x = y_{old}$ and $y = x_{old}$.\n\nLet's consider attempting to implement this with zero temporary variables, using only sequential moves between $x$ and $y$. There are two possible orderings:\n\nCase 1: Execute $x \\leftarrow y$ first.\n1. $x := y$: The variable $x$ now holds the value $y_{old}$. The original value $x_{old}$ is overwritten and lost.\n2. $y := x$: The variable $y$ is assigned the current value of $x$, which is $y_{old}$.\nThe final state is $x = y_{old}$ and $y = y_{old}$. This is incorrect because $y$ should be $x_{old}$.\n\nCase 2: Execute $y \\leftarrow x$ first.\n1. $y := x$: The variable $y$ now holds the value $x_{old}$. The original value $y_{old}$ is overwritten and lost.\n2. $x := y$: The variable $x$ is assigned the current value of $y$, which is $x_{old}$.\nThe final state is $y = x_{old}$ and $x = x_{old}$. This is also incorrect because $x$ should be $y_{old}$.\n\nIn both cases, the first sequential move destroys a value that is needed for the second move. This phenomenon is known as the \"lost copy\" problem. Therefore, it is impossible to correctly implement this specific move cycle with zero temporary variables. The minimal number of temporaries must be greater than $0$.\n\nNow, let's consider using one temporary variable, let's call it $t$. The strategy to break a cycle of moves is to first save one of the values in the cycle into the temporary variable.\n1. Save the value of one variable, say $x$, into the temporary: $t \\leftarrow x$. ($t$ now holds $x_{old}$)\n2. The variable $x$ can now be safely overwritten. Perform the move that targets $x$: $x \\leftarrow y$. ($x$ now holds $y_{old}$, which is correct).\n3. The original value of $x$ is now needed to update $y$. This value was preserved in $t$. Perform the move: $y \\leftarrow t$. ($y$ now holds $x_{old}$, which is correct).\n\nThe sequence of three moves ($t \\leftarrow x$, $x \\leftarrow y$, $y \\leftarrow t$) correctly implements the parallel swap. The final state is $x = y_{old}$ and $y = x_{old}$, as required.\n\nSince we have shown that $0$ temporaries are insufficient and $1$ temporary is sufficient, the minimal number of temporaries required to correctly implement the cycle is $1$. This is a general result for resolving a single cycle of moves of any length $k \\ge 2$; one temporary variable is both necessary and sufficient.",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "Building on the concept of move cycles, this practice  places the out-of-SSA conversion process into a more realistic context. Here, register allocation decisions made within predecessor blocks are fixed, creating constraints that dictate the moves needed at a join point. This problem demonstrates how these constraints can induce a swap on one control-flow path but not another, forcing you to analyze the consequences of register assignments and choose an optimal strategy to minimize conversion overhead.",
            "id": "3660417",
            "problem": "Consider a control-flow graph with four basic blocks $B_0$, $B_1$, $B_2$, and $B_3$, plus a final block $B_4$. Block $B_0$ branches to either $B_1$ or $B_2$, and both $B_1$ and $B_2$ fall through to the join block $B_3$, which then goes to $B_4$. The program is in Static Single Assignment (SSA) form. The statements in each block are:\n\n- In $B_1$: first compute $x_1$, then $y_1$, then $a_1$ using $y_1$, and finally $b_1$ using $x_1$ and $a_1$; then branch to $B_3$.\n- In $B_2$: first compute $x_2$, then $y_2$, then $a_2$ using $y_2$, and finally $b_2$ using $x_2$ and $a_2$; then branch to $B_3$.\n- In $B_3$: two $\\phi$ functions and subsequent uses:\n  $$p := \\phi(a_1, a_2), \\quad q := \\phi(b_1, b_2),$$\n  followed by\n  $$r := p + q, \\quad t := q,$$\n  and then branch to $B_4$.\n- In $B_4$: \n  $$u := r + t,$$\n  and the program ends.\n\nAssume the machine target has exactly two physical registers $R_1$ and $R_2$, and a local register assignment inside each predecessor block $B_1$ and $B_2$ has already been fixed and cannot be changed due to intra-block interference with temporaries $x_1, y_1$ and $x_2, y_2$ (details of those temporaries are irrelevant to inter-block liveness but force distinct register choices for $a_i$ and $b_i$). The fixed assignments are:\n- In $B_1$: $a_1$ is in $R_1$ and $b_1$ is in $R_2$.\n- In $B_2$: $a_2$ is in $R_2$ and $b_2$ is in $R_1$.\n\nTasks:\n1. Using standard backward liveness dataflow equations, and the conventional semantics of $\\phi$ functions (each $\\phi$ operand is used along its corresponding incoming edge), compute the sets $\\mathrm{live\\_in}(B_1)$, $\\mathrm{live\\_out}(B_1)$, $\\mathrm{live\\_in}(B_2)$, $\\mathrm{live\\_out}(B_2)$, $\\mathrm{live\\_in}(B_3)$, and $\\mathrm{live\\_out}(B_3)$.\n2. Perform out-of-SSA conversion at $B_3$ by inserting the minimal number of move instructions on edges $B_1 \\to B_3$ and $B_2 \\to B_3$, respecting the fixed register assignments given above. You may assign $p$ and $q$ to $R_1$ or $R_2$ in $B_3$, but there are only two registers and $p$ and $q$ are simultaneously live in $B_3$. Moves on each edge are to implement the parallel copies induced by the $\\phi$ functions. If a cycle arises in the register-to-register copies, you may use one scratch temporary to break cycles. Determine the minimal total number of move instructions that must be inserted across both incoming edges to $B_3$.\n\nExpress your final answer as a single integer. No rounding is required.",
            "solution": "The problem consists of two parts. First, we compute the liveness sets for the specified basic blocks. Second, we determine the minimal number of move instructions required to implement the semantics of the $\\phi$-functions at the join block $B_3$.\n\n**Part 1: Liveness Analysis**\n\nWe use backward dataflow analysis to compute the live-in and live-out sets. The standard dataflow equations are:\n$$ \\mathrm{live\\_out}(B) = \\bigcup_{S \\in \\mathrm{succ}(B)} \\mathrm{live\\_in}(S) $$\n$$ \\mathrm{live\\_in}(B) = \\mathrm{use}(B) \\cup (\\mathrm{live\\_out}(B) - \\mathrm{def}(B)) $$\nwhere $\\mathrm{use}(B)$ is the set of variables used in block $B$ before being defined, and $\\mathrm{def}(B)$ is the set of variables defined in $B$.\n\nFor programs in SSA form, the semantics of $\\phi$-functions require special handling. A $\\phi$-function $v := \\phi(v_1, \\dots, v_n)$ at the beginning of a block $B$ with predecessors $P_1, \\dots, P_n$ implies that each operand $v_i$ is used on the corresponding incoming edge $P_i \\to B$. This means that $v_i$ is live at the exit of block $P_i$. The variable $v$ is defined within block $B$.\n\nLet's analyze the control-flow graph and the variable uses/definitions block by block, starting from the end of the program.\n\n*   **Block $B_4$**: The program ends after $B_4$, so $\\mathrm{live\\_out}(B_4) = \\emptyset$.\n    The statement in $B_4$ is $u := r + t$.\n    The set of variables defined is $\\mathrm{def}(B_4) = \\{u\\}$.\n    The set of variables used is $\\mathrm{use}(B_4) = \\{r, t\\}$.\n    The live-in set for $B_4$ is:\n    $\\mathrm{live\\_in}(B_4) = \\mathrm{use}(B_4) \\cup (\\mathrm{live\\_out}(B_4) - \\mathrm{def}(B_4)) = \\{r, t\\} \\cup (\\emptyset - \\{u\\}) = \\{r, t\\}$.\n\n*   **Block $B_3$**: The only successor of $B_3$ is $B_4$.\n    Therefore, $\\mathrm{live\\_out}(B_3) = \\mathrm{live\\_in}(B_4) = \\{r, t\\}$.\n    The statements in $B_3$ are:\n    $1. p := \\phi(a_1, a_2)$\n    $2. q := \\phi(b_1, b_2)$\n    $3. r := p + q$\n    $4. t := q$\n    The non-$\\phi$ statements define $\\mathrm{def}_{non-\\phi}(B_3)=\\{r, t\\}$ and use $\\mathrm{use}_{non-\\phi}(B_3)=\\{p, q\\}$. The $\\phi$-functions define $\\mathrm{def}_{\\phi}(B_3) = \\{p, q\\}$. The total set of defined variables in $B_3$ is $\\mathrm{def}(B_3) = \\{p, q, r, t\\}$.\n    The set of variables that must be live at the beginning of the non-$\\phi$ instructions in $B_3$ is computed by propagating liveness backward through these instructions:\n    - Before $t := q$: Live set is $(\\mathrm{live\\_out}(B_3) \\setminus \\{t\\}) \\cup \\{q\\} = (\\{r, t\\} \\setminus \\{t\\}) \\cup \\{q\\} = \\{r, q\\}$.\n    - Before $r := p + q$: Live set is $(\\{r, q\\} \\setminus \\{r\\}) \\cup \\{p, q\\} = \\{p, q\\}$.\n    This set, $\\{p, q\\}$, represents the variables that must be live immediately after the $\\phi$-functions are evaluated. We take this to be the intended meaning of $\\mathrm{live\\_in}(B_3)$, as it reflects the resource needs for the body of the block.\n    So, $\\mathrm{live\\_in}(B_3) = \\{p, q\\}$.\n\n*   **Block $B_1$**: The only successor of $B_1$ is $B_3$. The liveness at the exit of $B_1$ is determined by the uses on the edge $B_1 \\to B_3$. These uses are given by the operands of the $\\phi$-functions in $B_3$ that correspond to the predecessor $B_1$.\n    - $p := \\phi(a_1, a_2)$: uses $a_1$ on the edge from $B_1$.\n    - $q := \\phi(b_1, b_2)$: uses $b_1$ on the edge from $B_1$.\n    Thus, the set of variables used on edge $B_1 \\to B_3$ is $\\{a_1, b_1\\}$. This constitutes the live-out set for $B_1$.\n    $\\mathrm{live\\_out}(B_1) = \\{a_1, b_1\\}$.\n    Within $B_1$, the variables $x_1, y_1, a_1, b_1$ are defined. $\\mathrm{def}(B_1)=\\{x_1, y_1, a_1, b_1\\}$.\n    The problem statement implies that $x_1$ and $y_1$ are computed without using any variables from preceding blocks, and they are used to compute $a_1$ and $b_1$ within the same block. There are no upward-exposed uses. So, $\\mathrm{use}(B_1) = \\emptyset$.\n    The live-in set for $B_1$ is:\n    $\\mathrm{live\\_in}(B_1) = \\mathrm{use}(B_1) \\cup (\\mathrm{live\\_out}(B_1) - \\mathrm{def}(B_1)) = \\emptyset \\cup (\\{a_1, b_1\\} - \\{x_1, y_1, a_1, b_1\\}) = \\emptyset$.\n\n*   **Block $B_2$**: The analysis for $B_2$ is symmetric to $B_1$. The successor is $B_3$. The uses on edge $B_2 \\to B_3$ are from the second operands of the $\\phi$-functions:\n    - $p := \\phi(a_1, a_2)$: uses $a_2$ on the edge from $B_2$.\n    - $q := \\phi(b_1, b_2)$: uses $b_2$ on the edge from $B_2$.\n    So, $\\mathrm{live\\_out}(B_2) = \\{a_2, b_2\\}$.\n    Within $B_2$, the variables $x_2, y_2, a_2, b_2$ are defined. $\\mathrm{def}(B_2)=\\{x_2, y_2, a_2, b_2\\}$.\n    There are no upward-exposed uses, so $\\mathrm{use}(B_2) = \\emptyset$.\n    The live-in set for $B_2$ is:\n    $\\mathrm{live\\_in}(B_2) = \\mathrm{use}(B_2) \\cup (\\mathrm{live\\_out}(B_2) - \\mathrm{def}(B_2)) = \\emptyset \\cup (\\{a_2, b_2\\} - \\{x_2, y_2, a_2, b_2\\}) = \\emptyset$.\n\nSummary of liveness sets for Part 1:\n- $\\mathrm{live\\_in}(B_1) = \\emptyset$\n- $\\mathrm{live\\_out}(B_1) = \\{a_1, b_1\\}$\n- $\\mathrm{live\\_in}(B_2) = \\emptyset$\n- $\\mathrm{live\\_out}(B_2) = \\{a_2, b_2\\}$\n- $\\mathrm{live\\_in}(B_3) = \\{p, q\\}$\n- $\\mathrm{live\\_out}(B_3) = \\{r, t\\}$\n\n**Part 2: Out-of-SSA Conversion and Move Insertion**\n\nThe task is to convert the program out of SSA form at block $B_3$ by inserting `move` instructions on the incoming edges $B_1 \\to B_3$ and $B_2 \\to B_3$. These moves implement the parallel assignments defined by the $\\phi$-functions.\nThe $\\phi$-functions are:\n$p := \\phi(a_1, a_2)$\n$q := \\phi(b_1, b_2)$\n\nIn block $B_3$, the variables $p$ and $q$ are simultaneously live, as they are both used in the statement $r := p + q$. The machine has two physical registers, $R_1$ and $R_2$. Therefore, $p$ and $q$ must be assigned to different registers. There are two possible assignments for $(p, q)$ in $B_3$: $(R_1, R_2)$ or $(R_2, R_1)$. We must find the assignment that minimizes the total number of moves inserted across both edges.\n\n**Case 1: Assign $p$ to $R_1$ and $q$ to $R_2$ in $B_3$.**\n\n*   **Edge $B_1 \\to B_3$**:\n    The copy semantics are $p \\leftarrow a_1$ and $q \\leftarrow b_1$.\n    The register states are:\n    - At the end of $B_1$: $a_1$ is in $R_1$, $b_1$ is in $R_2$.\n    - At the start of $B_3$: $p$ must be in $R_1$, $q$ must be in $R_2$.\n    The required parallel copy is $(R_1, R_2) \\leftarrow (R_1, R_2)$, where the target registers are for $(p, q)$ and the source registers are for $(a_1, b_1)$.\n    - $R_1 \\leftarrow R_1$ (for $p \\leftarrow a_1$): This is a no-op, requiring $0$ moves.\n    - $R_2 \\leftarrow R_2$ (for $q \\leftarrow b_1$): This is a no-op, requiring $0$ moves.\n    Total moves on this edge: $0$.\n\n*   **Edge $B_2 \\to B_3$**:\n    The copy semantics are $p \\leftarrow a_2$ and $q \\leftarrow b_2$.\n    The register states are:\n    - At the end of $B_2$: $a_2$ is in $R_2$, $b_2$ is in $R_1$.\n    - At the start of $B_3$: $p$ must be in $R_1$, $q$ must be in $R_2$.\n    The required parallel copy is $(R_1, R_2) \\leftarrow (R_2, R_1)$.\n    - $R_1 \\leftarrow R_2$ (for $p \\leftarrow a_2$).\n    - $R_2 \\leftarrow R_1$ (for $q \\leftarrow b_2$).\n    This is a register swap. To implement this using `move` instructions, we need a temporary scratch location (let's call it $T$), as allowed by the problem.\n    $1. T \\leftarrow R_1$\n    $2. R_1 \\leftarrow R_2$\n    $3. R_2 \\leftarrow T$\n    Total moves on this edge: $3$.\n\nThe total number of moves for this assignment is $0 + 3 = 3$.\n\n**Case 2: Assign $p$ to $R_2$ and $q$ to $R_1$ in $B_3$.**\n\n*   **Edge $B_1 \\to B_3$**:\n    The copy semantics are $p \\leftarrow a_1$ and $q \\leftarrow b_1$.\n    The register states are:\n    - At the end of $B_1$: $a_1$ is in $R_1$, $b_1$ is in $R_2$.\n    - At the start of $B_3$: $p$ must be in $R_2$, $q$ must be in $R_1$.\n    The required parallel copy is $(R_2, R_1) \\leftarrow (R_1, R_2)$. This is a swap.\n    This requires $3$ moves, using a temporary.\n    Total moves on this edge: $3$.\n\n*   **Edge $B_2 \\to B_3$**:\n    The copy semantics are $p \\leftarrow a_2$ and $q \\leftarrow b_2$.\n    The register states are:\n    - At the end of $B_2$: $a_2$ is in $R_2$, $b_2$ is in $R_1$.\n    - At the start of $B_3$: $p$ must be in $R_2$, $q$ must be in $R_1$.\n    The required parallel copy is $(R_2, R_1) \\leftarrow (R_2, R_1)$.\n    - $R_2 \\leftarrow R_2$ (for $p \\leftarrow a_2$): No-op, $0$ moves.\n    - $R_1 \\leftarrow R_1$ (for $q \\leftarrow b_2$): No-op, $0$ moves.\n    Total moves on this edge: $0$.\n\nThe total number of moves for this assignment is $3 + 0 = 3$.\n\nBoth possible register assignments for $p$ and $q$ in block $B_3$ lead to a total of $3$ move instructions. Therefore, the minimal total number of moves is $3$.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "Real-world code often leads to complex scenarios where multiple $\\phi$-functions create an intricate web of dependencies. This capstone exercise  models a sophisticated parallel copy problem involving multiple disjoint and overlapping cycles within the move dependency graph. To find the solution, you must apply a systematic approach: construct a formal dependency graph, identify all cyclic components, and devise an optimal schedule of moves that resolves all data transfers correctly using a single scratch register, thereby mastering the general algorithm for parallel copy scheduling.",
            "id": "3660351",
            "problem": "Consider a control-flow join block $B$ in Static Single Assignment (SSA) form that has two predecessors $P$ and $Q$. The block $B$ contains six $\\phi$-functions, three of which form a $\\phi$-web on the $P \\to B$ edge by sharing the same incoming SSA version from $P$. The $\\phi$-functions and their incoming arguments are:\n- $x_{1} \\gets \\phi(P: a,\\; Q: e)$\n- $x_{2} \\gets \\phi(P: a,\\; Q: f)$\n- $x_{3} \\gets \\phi(P: a,\\; Q: g)$\n- $x_{4} \\gets \\phi(P: b,\\; Q: h)$\n- $x_{5} \\gets \\phi(P: c,\\; Q: i)$\n- $x_{6} \\gets \\phi(P: d,\\; Q: j)$\n\nAssume register assignment is predetermined by a mapping $\\rho(\\cdot)$ to machine registers $R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}$ as follows:\n- Sources from $P$: $\\rho(a)=R_{0},\\; \\rho(b)=R_{1},\\; \\rho(c)=R_{2},\\; \\rho(d)=R_{3}$.\n- Sources from $Q$: $\\rho(e)=R_{2},\\; \\rho(f)=R_{3},\\; \\rho(g)=R_{1},\\; \\rho(h)=R_{0},\\; \\rho(i)=R_{5},\\; \\rho(j)=R_{4}$.\n- Destinations in $B$: $\\rho(x_{1})=R_{1},\\; \\rho(x_{2})=R_{2},\\; \\rho(x_{3})=R_{3},\\; \\rho(x_{4})=R_{0},\\; \\rho(x_{5})=R_{4},\\; \\rho(x_{6})=R_{5}$.\n\nOut-of-SSA conversion is performed by inserting, on each incoming edge, a parallel copy that implements the simultaneous assignments prescribed by the $\\phi$-functions on that edge. Parallel copy semantics require that every right-hand side is read from its source before any left-hand side is written. The implementation model permits only register-to-register moves of the form $u := v$, with exactly one extra scratch register $T$ that is not any of $R_{0},\\ldots,R_{5}$, and no swap instruction is available.\n\nStarting only from the definitions of SSA $\\phi$ semantics and parallel copy semantics, and without assuming any specialized shortcut formula, determine the minimal total number of register-to-register move instructions required to implement the out-of-SSA parallel copies on both edges $P \\to B$ and $Q \\to B$ combined, under an optimal schedule that exploits the $\\phi$-web sharing of $a$ on the $P \\to B$ edge to avoid unnecessary saves and re-loads. Give your answer as a single integer. No rounding is required and no physical units are involved.",
            "solution": "The problem requires determining the minimal total number of register-to-register move instructions to implement the out-of-SSA parallel copies for a join block $B$ with two predecessor edges, $P \\to B$ and $Q \\to B$. We must analyze each edge separately and sum the costs. The analysis must be derived from the semantics of parallel copies without recourse to unstated specialized formulae. A parallel copy dictates that all source values are read before any destination registers are modified.\n\n**Analysis for Edge $P \\to B$**\n\nFirst, we formalize the parallel copy required on the edge $P \\to B$. The $\\phi$-functions define the assignments:\n- $x_{1} \\gets a$\n- $x_{2} \\gets a$\n- $x_{3} \\gets a$\n- $x_{4} \\gets b$\n- $x_{5} \\gets c$\n- $x_{6} \\gets d$\n\nApplying the given register allocation mapping $\\rho(\\cdot)$, we translate these assignments into register-to-register transfers:\n- $\\rho(x_{1}) \\gets \\rho(a) \\implies R_{1} := R_{0}$\n- $\\rho(x_{2}) \\gets \\rho(a) \\implies R_{2} := R_{0}$\n- $\\rho(x_{3}) \\gets \\rho(a) \\implies R_{3} := R_{0}$\n- $\\rho(x_{4}) \\gets \\rho(b) \\implies R_{0} := R_{1}$\n- $\\rho(x_{5}) \\gets \\rho(c) \\implies R_{4} := R_{2}$\n- $\\rho(x_{6}) \\gets \\rho(d) \\implies R_{5} := R_{3}$\n\nTo determine the minimal sequence of moves, we construct a dependency graph $G_P = (V, E)$, where $V$ is the set of registers $\\{R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}\\}$ and an edge $(u, v) \\in E$ signifies a copy $v := u$. The edges are:\n- $R_{0} \\to R_{1}$\n- $R_{0} \\to R_{2}$\n- $R_{0} \\to R_{3}$\n- $R_{1} \\to R_{0}$\n- $R_{2} \\to R_{4}$\n- $R_{3} \\to R_{5}$\n\nAnalyzing the structure of $G_P$:\nThe graph reveals a 2-cycle between registers $R_{0}$ and $R_{1}$ (i.e., $R_{0} \\to R_{1}$ and $R_{1} \\to R_{0}$). Resolving such a cycle requires breaking it, as neither copy can be executed first without destroying a value needed by the other. This necessitates the use of the temporary scratch register, $T$.\n\nThe register $R_{0}$ is part of this cycle and is also the source for three distinct copies (the $\\phi$-web). The register $R_{1}$ is also part of the cycle. To break the cycle, we must save the value of either $R_{0}$ or $R_{1}$. Since the value in $R_{0}$ is required for three destinations ($R_{1}, R_{2}, R_{3}$), while its own destination register will be overwritten by the value from $R_{1}$, the optimal strategy is to save the value of $R_{0}$ into the temporary register $T$. This single save makes the value available for all its intended targets.\n\n1.  $T := R_{0}$: The value of $R_{0}$ (from variable $a$) is saved. This costs $1$ move.\n\nAfter this move, the set of required parallel transfers is conceptually transformed. Any transfer that required the original value of $R_{0}$ now requires the value from $T$. The new set of transfers is:\n- $R_{1} := T$\n- $R_{2} := T$\n- $R_{3} := T$\n- $R_{0} := R_{1}$\n- $R_{4} := R_{2}$\n- $R_{5} := R_{3}$\n\nThe dependency graph for this new set of transfers is acyclic. We can now generate a sequence of moves that respects the remaining dependencies. A copy $d := s$ can be executed if its destination $d$ is not a source for any other pending copy.\n- The copies $R_{0} := R_{1}$, $R_{4} := R_{2}$, and $R_{5} := R_{3}$ have destinations ($R_{0}, R_{4}, R_{5}$) that are not sources for any other remaining copy. However, their sources ($R_{1}, R_{2}, R_{3}$) are destinations for other copies. To respect parallel copy semantics, we must execute the copies that consume the original values of $R_1, R_2, R_3$ before these registers are overwritten.\n\nA valid minimal sequence of moves is constructed as follows:\n1.  $T := R_{0}$: Save the value of $R_{0}$. ($1$ move)\n2.  $R_{0} := R_{1}$: The value of $R_{1}$ is now copied to $R_{0}$. This is safe because the original value of $R_{0}$ is in $T$. ($1$ move)\n3.  $R_{4} := R_{2}$: The original value of $R_{2}$ is copied to $R_{4}$. This must happen before $R_{2}$ is updated. ($1$ move)\n4.  $R_{5} := R_{3}$: The original value of $R_{3}$ is copied to $R_5$. This must happen before $R_{3}$ is updated. ($1$ move)\n5.  $R_{1} := T$: The saved value of $R_{0}$ is copied to $R_{1}$. Together with steps 1 and 2, this completes the cyclic swap of $R_0$ and $R_1$. ($1$ move)\n6.  $R_{2} := T$: The saved value of $R_{0}$ is copied to $R_{2}$. ($1$ move)\n7.  $R_{3} := T$: The saved value of $R_{0}$ is copied to $R_{3}$. ($1$ move)\n\nThis sequence correctly implements all transfers. The total number of moves is $7$. This is minimal because there are $6$ fundamental assignments to perform, and the single cycle requires one additional move to break it using a temporary register.\n\n**Analysis for Edge $Q \\to B$**\n\nNext, we formalize the parallel copy for the edge $Q \\to B$. The $\\phi$-functions define the assignments:\n- $x_{1} \\gets e$\n- $x_{2} \\gets f$\n- $x_{3} \\gets g$\n- $x_{4} \\gets h$\n- $x_{5} \\gets i$\n- $x_{6} \\gets j$\n\nApplying the register allocation mapping $\\rho(\\cdot)$:\n- $\\rho(x_{1}) \\gets \\rho(e) \\implies R_{1} := R_{2}$\n- $\\rho(x_{2}) \\gets \\rho(f) \\implies R_{2} := R_{3}$\n- $\\rho(x_{3}) \\gets \\rho(g) \\implies R_{3} := R_{1}$\n- $\\rho(x_{4}) \\gets \\rho(h) \\implies R_{0} := R_{0}$\n- $\\rho(x_{5}) \\gets \\rho(i) \\implies R_{4} := R_{5}$\n- $\\rho(x_{6}) \\gets \\rho(j) \\implies R_{5} := R_{4}$\n\nThe copy $R_{0} := R_{0}$ is a no-op and requires $0$ moves. We analyze the remaining five non-trivial transfers. The dependency graph $G_Q$ consists of the following edges:\n- $R_{2} \\to R_{1}$\n- $R_{3} \\to R_{2}$\n- $R_{1} \\to R_{3}$\n- $R_{5} \\to R_{4}$\n- $R_{4} \\to R_{5}$\n\nThe graph $G_Q$ decomposes into two disjoint components:\n1.  A $3$-cycle: $R_{1} \\to R_{3} \\to R_{2} \\to R_{1}$.\n2.  A $2$-cycle: $R_{4} \\leftrightarrow R_{5}$.\n\nWe must resolve each cycle using the temporary register $T$. Since the components are disjoint, we can resolve them sequentially, reusing $T$.\n\nTo resolve the $3$-cycle on $\\{R_{1}, R_{2}, R_{3}\\}$, which involves $3$ registers, we need $3+1 = 4$ moves:\n1.  $T := R_{1}$ (Save the value of any register in the cycle, e.g., $R_1$)\n2.  $R_{1} := R_{2}$\n3.  $R_{2} := R_{3}$\n4.  $R_{3} := T$ (Restore the saved value to complete the cycle)\nThis sub-problem costs $4$ moves.\n\nTo resolve the $2$-cycle on $\\{R_{4}, R_{5}\\}$, which involves $2$ registers, we need $2+1 = 3$ moves. The register $T$ is available again.\n1.  $T := R_{4}$ (Save the value of $R_4$)\n2.  $R_{4} := R_{5}$\n3.  $R_{5} := T$ (Restore the saved value)\nThis sub-problem costs $3$ moves.\n\nThe total number of moves for the edge $Q \\to B$ is the sum of the moves for each disjoint component: $4 + 3 = 7$.\n\n**Total Minimal Moves**\n\nThe total minimal number of moves is the sum of the moves required for each edge:\nTotal moves = (Moves for $P \\to B$) + (Moves for $Q \\to B$) = $7 + 7 = 14$.\n\nThe final answer is $14$.",
            "answer": "$$\\boxed{14}$$"
        }
    ]
}