{
    "hands_on_practices": [
        {
            "introduction": "The theoretical elegance of $\\phi$-functions lies in their parallel assignment semantics, but machine code executes sequentially. This practice  explores the most fundamental conflict that arises during this translation: the move cycle. By examining a classic swap scenario, you will discover why a naive sequence of copies fails and how a temporary variable is essential for correctly implementing parallel semantics.",
            "id": "3660448",
            "problem": "Consider a control-flow graph with two predecessor blocks $B_1$ and $B_2$ that both branch to a join block $J$. The program is in Static Single Assignment (SSA) form, where each variable is assigned exactly once, and $\\phi$ nodes in $J$ select incoming values based on the control-flow path. The semantics of a $\\phi$ node are equivalent to inserting parallel copies on the incoming edges to $J$, meaning all copies execute simultaneously at each edge.\n\nSuppose the program is as follows. In $B_1$:\n$x_1 := \\text{val}_x$, $y_1 := \\text{val}_y$, and the control flows to $J$. In $B_2$: $x_2 := \\text{val}_x'$, $y_2 := \\text{val}_y'$, and the control flows to $J$. In $J$:\n$x_3 := \\phi(y_1, x_2)$ and $y_3 := \\phi(x_1, y_2)$, followed by a use $r := x_3 + y_3$. During out-of-SSA conversion, assume a standard coalescing strategy that intends to map $x_3$ to the non-SSA variable $x$ and $y_3$ to $y$, and also maps $x_1$ to $x$ and $y_1$ to $y$ in $B_1$ (similarly for $B_2$). Under these assumptions, the $\\phi$ assignments induce the following parallel copies at the edge $B_1 \\to J$:\n$x \\leftarrow y$ and $y \\leftarrow x$, forming a move cycle. You may assume all variables $x$ and $y$ are live across the edge $B_1 \\to J$.\n\nUsing first principles of SSA semantics and out-of-SSA conversion (parallel copy semantics and sequential move implementation), construct the induced move cycle at $B_1 \\to J$, and then derive a minimal-temporary strategy to implement these parallel copies with sequential moves without violating program semantics. Specifically, model the copies as a directed graph on variables where an edge $u \\to v$ represents a required move $v \\leftarrow u$. Argue from these definitions how to schedule acyclic moves and how to break cycles.\n\nCompute the minimal number of temporaries required to correctly implement the cycle $x \\leftarrow y, y \\leftarrow x$ under the above assumptions. Your final answer must be a single exact integer. No rounding is needed.",
            "solution": "The problem requires an analysis of the out-of-Static Single Assignment (SSA) conversion process, specifically the implementation of parallel copies induced by $\\phi$ nodes. We must determine the minimal number of temporary variables needed to correctly sequentialize a specific move cycle.\n\nFirst, we formalize the setup based on the provided information. The program is in SSA form. In block $B_1$, we have assignments $x_1 := \\text{val}_x$ and $y_1 := \\text{val}_y$. In block $B_2$, we have $x_2 := \\text{val}_x'$ and $y_2 := \\text{val}_y'$. Both blocks branch to a join block $J$. In $J$, two $\\phi$ nodes merge the incoming values:\n$$x_3 := \\phi(y_1, x_2)$$\n$$y_3 := \\phi(x_1, y_2)$$\nThe semantics of the $\\phi$ nodes are defined as parallel copies on the incoming control-flow edges. We are concerned with the edge from $B_1$ to $J$. For this path, the effective assignments are specified by the first arguments of the $\\phi$ nodes:\n$$x_3 \\leftarrow y_1$$\n$$y_3 \\leftarrow x_1$$\nThese assignments must be executed simultaneously.\n\nThe problem states that during out-of-SSA conversion, a coalescing strategy is applied. The SSA variables $\\{x_1, x_2, x_3\\}$ are all mapped to a single non-SSA variable $x$, and $\\{y_1, y_2, y_3\\}$ are mapped to a single non-SSA variable $y$. Applying this mapping to the parallel copy semantics for the edge $B_1 \\to J$, we substitute $x_3 \\to x$, $y_1 \\to y$, $y_3 \\to y$, and $x_1 \\to x$:\n$$x \\leftarrow y$$\n$$y \\leftarrow x$$\nThis means that upon traversing the edge from $B_1$ to $J$, the value of the non-SSA variable $x$ must be updated to the original value of $y$, and simultaneously, the value of $y$ must be updated to the original value of $x$. This is a classic swap operation.\n\nThe problem asks to model these copies as a directed graph where an edge $u \\to v$ represents the move $v \\leftarrow u$. Based on this convention:\n\\begin{itemize}\n    \\item The copy $x \\leftarrow y$ is represented by a directed edge from $y$ to $x$: $y \\to x$.\n    \\item The copy $y \\leftarrow x$ is represented by a directed edge from $x$ to $y$: $x \\to y$.\n\\end{itemize}\nThe resulting graph consists of two nodes, $x$ and $y$, and two edges forming a cycle of length $2$: $x \\to y \\to x$.\n\nThe task is to implement these parallel copies using a sequence of simple move instructions. Let's denote the values of $x$ and $y$ before the copies as $x_{old}$ and $y_{old}$. The desired final state is $x = y_{old}$ and $y = x_{old}$.\n\nLet's consider attempting to implement this with zero temporary variables, using only sequential moves between $x$ and $y$. There are two possible orderings:\n\nCase 1: Execute $x \\leftarrow y$ first.\n1. $x := y$: The variable $x$ now holds the value $y_{old}$. The original value $x_{old}$ is overwritten and lost.\n2. $y := x$: The variable $y$ is assigned the current value of $x$, which is $y_{old}$.\nThe final state is $x = y_{old}$ and $y = y_{old}$. This is incorrect because $y$ should be $x_{old}$.\n\nCase 2: Execute $y \\leftarrow x$ first.\n1. $y := x$: The variable $y$ now holds the value $x_{old}$. The original value $y_{old}$ is overwritten and lost.\n2. $x := y$: The variable $x$ is assigned the current value of $y$, which is $x_{old}$.\nThe final state is $y = x_{old}$ and $x = x_{old}$. This is also incorrect because $x$ should be $y_{old}$.\n\nIn both cases, the first sequential move destroys a value that is needed for the second move. This phenomenon is known as the \"lost copy\" problem. Therefore, it is impossible to correctly implement this specific move cycle with zero temporary variables. The minimal number of temporaries must be greater than $0$.\n\nNow, let's consider using one temporary variable, let's call it $t$. The strategy to break a cycle of moves is to first save one of the values in the cycle into the temporary variable.\n1. Save the value of one variable, say $x$, into the temporary: $t \\leftarrow x$. ($t$ now holds $x_{old}$)\n2. The variable $x$ can now be safely overwritten. Perform the move that targets $x$: $x \\leftarrow y$. ($x$ now holds $y_{old}$, which is correct).\n3. The original value of $x$ is now needed to update $y$. This value was preserved in $t$. Perform the move: $y \\leftarrow t$. ($y$ now holds $x_{old}$, which is correct).\n\nThe sequence of three moves ($t \\leftarrow x$, $x \\leftarrow y$, $y \\leftarrow t$) correctly implements the parallel swap. The final state is $x = y_{old}$ and $y = x_{old}$, as required.\n\nSince we have shown that $0$ temporaries are insufficient and $1$ temporary is sufficient, the minimal number of temporaries required to correctly implement the cycle is $1$. This is a general result for resolving a single cycle of moves of any length $k \\ge 2$; one temporary variable is both necessary and sufficient.",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "Correctly converting out of SSA form requires looking beyond the join point itself and into the predecessor blocks. The properties of the target machine's instruction set can introduce subtle challenges, as this exercise demonstrates . You will analyze a scenario where a two-address instruction clobbers a source value that is still needed by a $\\phi$-function, forcing the insertion of a preemptive copy within the predecessor block to preserve program correctness.",
            "id": "3660382",
            "problem": "Consider a program fragment in Static Single Assignment (SSA) form that merges a value with its post-incremented version at a join point. You are given a Control Flow Graph (CFG) with three basic blocks $B_0$, $B_1$, $B_2$, and a join block $B_3$. In $B_0$, a value $a_0$ is defined and control branches to either $B_1$ or $B_2$. Each of $B_1$ and $B_2$ then flows to $B_3$. The SSA code (ignoring control predicates) is as follows:\n- In $B_0$: define $a_0$; branch to $B_1$ or $B_2$.\n- In $B_1$: compute $a_1 := a_0 + 1$; fall through to $B_3$.\n- In $B_2$: compute $a_2 := a_0 + 1$; fall through to $B_3$.\n- In $B_3$: two $\\phi$-functions produce\n  - $z_3 := \\phi(a_0 \\text{ from } B_2,\\ a_1 \\text{ from } B_1)$, which merges the original value and its post-incremented version, and\n  - $w_3 := \\phi(a_2 \\text{ from } B_2,\\ a_0 \\text{ from } B_1)$, which merges the post-incremented version and the original value in the opposite way.\n\nAssume a target machine where integer addition is a two-address operation that overwrites its source register (i.e., computing $a_1 := a_0 + 1$ clobbers the location that held $a_0$). Out-of-SSA conversion (OoSSA) must preserve the $\\phi$-function semantics, which are defined as simultaneous assignments at the start of $B_3$.\n\nYou will lower $\\phi$-functions by inserting moves on the incoming edges $B_1 \\to B_3$ and $B_2 \\to B_3$ that realize the parallel copy semantics at the beginning of $B_3$: for each $\\phi$-function and each predecessor, insert one explicit move of the form “destination := source” on that predecessor edge. Additionally, to respect the two-address clobber semantics in $B_1$ and $B_2$, you may introduce an explicit copy inside a predecessor before the increment if the original $a_0$ value must be preserved for a $\\phi$-argument from that predecessor. Count only explicit copies and moves added by the compiler beyond the arithmetic instructions; do not assume any copy coalescing or dead-move elimination.\n\nUsing only the core definitions of SSA $\\phi$-semantics (simultaneous assignment at block entry) and two-address overwrite behavior (“clobbering” of the source), determine the minimal total number of explicit move instructions that must be inserted across all blocks and edges to correctly lower both $\\phi$-functions for $B_3$ while ensuring that any copy of the merged original value occurs before it is clobbered by the increment. Provide your final answer as a single integer. No rounding is required.",
            "solution": "The goal is to determine the minimum number of explicit `copy` and `move` instructions required to correctly implement the two $\\phi$-functions in block $B_3$. This requires analyzing each of the two paths leading into $B_3$ and accounting for the two-address instruction constraint that clobbers a source register.\n\n**Path 1: $B_1 \\to B_3$**\n\nWhen control flows from $B_1$ to $B_3$, the $\\phi$-functions specify the simultaneous assignments $z_3 := a_1$ and $w_3 := a_0$. However, in block $B_1$, the instruction $a_1 := a_0 + 1$ overwrites the location holding $a_0$. Since the original value of $a_0$ is needed for $w_3$, it must be saved before the addition. This requires one explicit `copy` instruction within $B_1$:\n1.  **In $B_1$:** Insert `a_0_copy := a_0`. (1st instruction)\nAfter this copy, the addition $a_1 := a_0 + 1$ can safely execute.\n\nNext, on the edge $B_1 \\to B_3$, we insert `move` instructions to satisfy the $\\phi$-functions:\n2.  **On edge $B_1 \\to B_3$:** Insert `z_3 := a_1`. (2nd instruction)\n3.  **On edge $B_1 \\to B_3$:** Insert `w_3 := a_0_copy`. (3rd instruction)\nThis path requires a total of 3 instructions.\n\n**Path 2: $B_2 \\to B_3$**\n\nSimilarly, when control flows from $B_2$ to $B_3$, the $\\phi$-functions specify the assignments $z_3 := a_0$ and $w_3 := a_2$. In block $B_2$, the instruction $a_2 := a_0 + 1$ clobbers the original value of $a_0$. Since this value is needed for $z_3$, we must save it first.\n1.  **In $B_2$:** Insert `a_0_copy := a_0`. (4th instruction)\n\nThen, on the edge $B_2 \\to B_3$, we insert the required `move` instructions:\n2.  **On edge $B_2 \\to B_3$:** Insert `z_3 := a_0_copy`. (5th instruction)\n3.  **On edge $B_2 \\to B_3$:** Insert `w_3 := a_2`. (6th instruction)\nThis path also requires a total of 3 instructions.\n\n**Total Minimal Instructions**\n\nThe total number of explicit instructions is the sum of the instructions added for both paths: $3 + 3 = 6$. Each instruction is necessary due to the problem's constraints (clobbering semantics and no copy coalescing). Therefore, 6 is the minimal number.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "Real-world code often produces complex webs of data flow at join points. This final practice  moves from simple cycles to a challenging scenario with multiple, overlapping, and disjoint copy dependencies. To find the most efficient solution, you must construct a formal dependency graph, identify all cycles, and devise an optimal schedule of moves that minimizes instruction count by intelligently using a single scratch register.",
            "id": "3660351",
            "problem": "Consider a control-flow join block $B$ in Static Single Assignment (SSA) form that has two predecessors $P$ and $Q$. The block $B$ contains six $\\phi$-functions, three of which form a $\\phi$-web on the $P \\to B$ edge by sharing the same incoming SSA version from $P$. The $\\phi$-functions and their incoming arguments are:\n- $x_{1} \\gets \\phi(P: a,\\; Q: e)$\n- $x_{2} \\gets \\phi(P: a,\\; Q: f)$\n- $x_{3} \\gets \\phi(P: a,\\; Q: g)$\n- $x_{4} \\gets \\phi(P: b,\\; Q: h)$\n- $x_{5} \\gets \\phi(P: c,\\; Q: i)$\n- $x_{6} \\gets \\phi(P: d,\\; Q: j)$\n\nAssume register assignment is predetermined by a mapping $\\rho(\\cdot)$ to machine registers $R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}$ as follows:\n- Sources from $P$: $\\rho(a)=R_{0},\\; \\rho(b)=R_{1},\\; \\rho(c)=R_{2},\\; \\rho(d)=R_{3}$.\n- Sources from $Q$: $\\rho(e)=R_{2},\\; \\rho(f)=R_{3},\\; \\rho(g)=R_{1},\\; \\rho(h)=R_{0},\\; \\rho(i)=R_{5},\\; \\rho(j)=R_{4}$.\n- Destinations in $B$: $\\rho(x_{1})=R_{1},\\; \\rho(x_{2})=R_{2},\\; \\rho(x_{3})=R_{3},\\; \\rho(x_{4})=R_{0},\\; \\rho(x_{5})=R_{4},\\; \\rho(x_{6})=R_{5}$.\n\nOut-of-SSA conversion is performed by inserting, on each incoming edge, a parallel copy that implements the simultaneous assignments prescribed by the $\\phi$-functions on that edge. Parallel copy semantics require that every right-hand side is read from its source before any left-hand side is written. The implementation model permits only register-to-register moves of the form $u := v$, with exactly one extra scratch register $T$ that is not any of $R_{0},\\ldots,R_{5}$, and no swap instruction is available.\n\nStarting only from the definitions of SSA $\\phi$ semantics and parallel copy semantics, and without assuming any specialized shortcut formula, determine the minimal total number of register-to-register move instructions required to implement the out-of-SSA parallel copies on both edges $P \\to B$ and $Q \\to B$ combined, under an optimal schedule that exploits the $\\phi$-web sharing of $a$ on the $P \\to B$ edge to avoid unnecessary saves and re-loads. Give your answer as a single integer. No rounding is required and no physical units are involved.",
            "solution": "The problem requires determining the minimal total number of register-to-register move instructions to implement the out-of-SSA parallel copies for a join block $B$ with two predecessor edges, $P \\to B$ and $Q \\to B$. We must analyze each edge separately and sum the costs. The analysis must be derived from the semantics of parallel copies without recourse to unstated specialized formulae. A parallel copy dictates that all source values are read before any destination registers are modified.\n\n**Analysis for Edge $P \\to B$**\n\nFirst, we formalize the parallel copy required on the edge $P \\to B$. The $\\phi$-functions define the assignments:\n- $x_{1} \\gets a$\n- $x_{2} \\gets a$\n- $x_{3} \\gets a$\n- $x_{4} \\gets b$\n- $x_{5} \\gets c$\n- $x_{6} \\gets d$\n\nApplying the given register allocation mapping $\\rho(\\cdot)$, we translate these assignments into register-to-register transfers:\n- $\\rho(x_{1}) \\gets \\rho(a) \\implies R_{1} := R_{0}$\n- $\\rho(x_{2}) \\gets \\rho(a) \\implies R_{2} := R_{0}$\n- $\\rho(x_{3}) \\gets \\rho(a) \\implies R_{3} := R_{0}$\n- $\\rho(x_{4}) \\gets \\rho(b) \\implies R_{0} := R_{1}$\n- $\\rho(x_{5}) \\gets \\rho(c) \\implies R_{4} := R_{2}$\n- $\\rho(x_{6}) \\gets \\rho(d) \\implies R_{5} := R_{3}$\n\nTo determine the minimal sequence of moves, we construct a dependency graph $G_P = (V, E)$, where $V$ is the set of registers $\\{R_{0}, R_{1}, R_{2}, R_{3}, R_{4}, R_{5}\\}$ and an edge $(u, v) \\in E$ signifies a copy $v := u$. The edges are:\n- $R_{0} \\to R_{1}$\n- $R_{0} \\to R_{2}$\n- $R_{0} \\to R_{3}$\n- $R_{1} \\to R_{0}$\n- $R_{2} \\to R_{4}$\n- $R_{3} \\to R_{5}$\n\nAnalyzing the structure of $G_P$:\nThe graph reveals a 2-cycle between registers $R_{0}$ and $R_{1}$ (i.e., $R_{0} \\to R_{1}$ and $R_{1} \\to R_{0}$). Resolving such a cycle requires breaking it, as neither copy can be executed first without destroying a value needed by the other. This necessitates the use of the temporary scratch register, $T$.\n\nThe register $R_{0}$ is part of this cycle and is also the source for three distinct copies (the $\\phi$-web). The register $R_{1}$ is also part of the cycle. To break the cycle, we must save the value of either $R_{0}$ or $R_{1}$. Since the value in $R_{0}$ is required for three destinations ($R_{1}, R_{2}, R_{3}$), while its own destination register will be overwritten by the value from $R_{1}$, the optimal strategy is to save the value of $R_{0}$ into the temporary register $T$. This single save makes the value available for all its intended targets.\n\n1.  $T := R_{0}$: The value of $R_{0}$ (from variable $a$) is saved. This costs $1$ move.\n\nAfter this move, the set of required parallel transfers is conceptually transformed. Any transfer that required the original value of $R_{0}$ now requires the value from $T$. The new set of transfers is:\n- $R_{1} := T$\n- $R_{2} := T$\n- $R_{3} := T$\n- $R_{0} := R_{1}$\n- $R_{4} := R_{2}$\n- $R_{5} := R_{3}$\n\nThe dependency graph for this new set of transfers is acyclic. We can now generate a sequence of moves that respects the remaining dependencies. A copy $d := s$ can be executed if its destination $d$ is not a source for any other pending copy.\n- The copies $R_{0} := R_{1}$, $R_{4} := R_{2}$, and $R_{5} := R_{3}$ have destinations ($R_{0}, R_{4}, R_{5}$) that are not sources for any other remaining copy. However, their sources ($R_{1}, R_{2}, R_{3}$) are destinations for other copies. To respect parallel copy semantics, we must execute the copies that consume the original values of $R_1, R_2, R_3$ before these registers are overwritten.\n\nA valid minimal sequence of moves is constructed as follows:\n1.  $T := R_{0}$: Save the value of $R_{0}$. ($1$ move)\n2.  $R_{0} := R_{1}$: The value of $R_{1}$ is now copied to $R_{0}$. This is safe because the original value of $R_{0}$ is in $T$. ($1$ move)\n3.  $R_{4} := R_{2}$: The original value of $R_{2}$ is copied to $R_{4}$. This must happen before $R_{2}$ is updated. ($1$ move)\n4.  $R_{5} := R_{3}$: The original value of $R_{3}$ is copied to $R_5$. This must happen before $R_{3}$ is updated. ($1$ move)\n5.  $R_{1} := T$: The saved value of $R_{0}$ is copied to $R_{1}$. Together with steps 1 and 2, this completes the cyclic swap of $R_0$ and $R_1$. ($1$ move)\n6.  $R_{2} := T$: The saved value of $R_{0}$ is copied to $R_{2}$. ($1$ move)\n7.  $R_{3} := T$: The saved value of $R_{0}$ is copied to $R_{3}$. ($1$ move)\n\nThis sequence correctly implements all transfers. The total number of moves is $7$. This is minimal because there are $6$ fundamental assignments to perform, and the single cycle requires one additional move to break it using a temporary register.\n\n**Analysis for Edge $Q \\to B$**\n\nNext, we formalize the parallel copy for the edge $Q \\to B$. The $\\phi$-functions define the assignments:\n- $x_{1} \\gets e$\n- $x_{2} \\gets f$\n- $x_{3} \\gets g$\n- $x_{4} \\gets h$\n- $x_{5} \\gets i$\n- $x_{6} \\gets j$\n\nApplying the register allocation mapping $\\rho(\\cdot)$:\n- $\\rho(x_{1}) \\gets \\rho(e) \\implies R_{1} := R_{2}$\n- $\\rho(x_{2}) \\gets \\rho(f) \\implies R_{2} := R_{3}$\n- $\\rho(x_{3}) \\gets \\rho(g) \\implies R_{3} := R_{1}$\n- $\\rho(x_{4}) \\gets \\rho(h) \\implies R_{0} := R_{0}$\n- $\\rho(x_{5}) \\gets \\rho(i) \\implies R_{4} := R_{5}$\n- $\\rho(x_{6}) \\gets \\rho(j) \\implies R_{5} := R_{4}$\n\nThe copy $R_{0} := R_{0}$ is a no-op and requires $0$ moves. We analyze the remaining five non-trivial transfers. The dependency graph $G_Q$ consists of the following edges:\n- $R_{2} \\to R_{1}$\n- $R_{3} \\to R_{2}$\n- $R_{1} \\to R_{3}$\n- $R_{5} \\to R_{4}$\n- $R_{4} \\to R_{5}$\n\nThe graph $G_Q$ decomposes into two disjoint components:\n1.  A $3$-cycle: $R_{1} \\to R_{3} \\to R_{2} \\to R_{1}$.\n2.  A $2$-cycle: $R_{4} \\leftrightarrow R_{5}$.\n\nWe must resolve each cycle using the temporary register $T$. Since the components are disjoint, we can resolve them sequentially, reusing $T$.\n\nTo resolve the $3$-cycle on $\\{R_{1}, R_{2}, R_{3}\\}$, which involves $3$ registers, we need $3+1 = 4$ moves:\n1.  $T := R_{1}$ (Save the value of any register in the cycle, e.g., $R_1$)\n2.  $R_{1} := R_{2}$\n3.  $R_{2} := R_{3}$\n4.  $R_{3} := T$ (Restore the saved value to complete the cycle)\nThis sub-problem costs $4$ moves.\n\nTo resolve the $2$-cycle on $\\{R_{4}, R_{5}\\}$, which involves $2$ registers, we need $2+1 = 3$ moves. The register $T$ is available again.\n1.  $T := R_{4}$ (Save the value of $R_4$)\n2.  $R_{4} := R_{5}$\n3.  $R_{5} := T$ (Restore the saved value)\nThis sub-problem costs $3$ moves.\n\nThe total number of moves for the edge $Q \\to B$ is the sum of the moves for each disjoint component: $4 + 3 = 7$.\n\n**Total Minimal Moves**\n\nThe total minimal number of moves is the sum of the moves required for each edge:\nTotal moves = (Moves for $P \\to B$) + (Moves for $Q \\to B$) = $7 + 7 = 14$.\n\nThe final answer is $14$.",
            "answer": "$$\\boxed{14}$$"
        }
    ]
}