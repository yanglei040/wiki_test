{
    "hands_on_practices": [
        {
            "introduction": "条件常量传播最直接的应用是识别和消除不可达代码路径。在这个练习中，我们将分析一个典型的菱形控制流图，其中一个分支的条件在编译时就能被确定为假。通过模拟条件常量传播的过程，你将亲身体验编译器如何剪除整个代码分支，并简化后续的 $\\phi$ 函数，从而得到一个在运行时更高效的程序。",
            "id": "3630643",
            "problem": "考虑以下处于静态单赋值（SSA）形式的程序及其菱形控制流图（CFG）。该程序在合并点处使用 SSA $\\phi$-函数的标准语义。你需要应用条件常量传播（CCP）来确定在出口处计算出的常量值。\n\n基本块和语句：\n- 入口块 $B_{0}$：\n  - $a_{0} := 7$\n  - $b_{0} := a_{0} - a_{0}$\n  - $\\text{if } (b_{0} = 1) \\text{ then goto } B_{1} \\text{ else goto } B_{2}$\n- Then 块 $B_{1}$：\n  - $c_{1} := 11$\n  - $\\text{goto } B_{3}$\n- Else 块 $B_{2}$：\n  - $c_{2} := 17$\n  - $\\text{goto } B_{3}$\n- 合并块 $B_{3}$：\n  - $c_{3} := \\phi(c_{1}, c_{2})$\n  - $r := 3 \\times c_{3} - 2$\n\n你必须根据数据流分析的基本定义在 CCP 中的应用进行推理：\n- CCP 的值域是三点常量传播格 $D = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其中 $\\bot$ 表示“未初始化/不可达”，任何 $z \\in \\mathbb{Z}$ 表示一个已知的整数常量，而 $\\top$ 表示“未知/非常量”。\n- 传递函数使用标准算术语义来评估对已知常量的操作。\n- 谓词为已知常量的条件分支决定了边的可行性和可达性。\n- 一个 SSA $\\phi$-函数会产生来自实际可行前驱的输入值；如果多个可行前驱提供相同的已知常量，则结果是该常量；否则，如果存在多个可行前驱但它们的值不同或不是常量，则结果为 $\\top$。\n\n从这些基础出发，在给定的菱形 CFG 上模拟 CCP。$B_{0}$ 中的守卫条件可能会产生一个矛盾，从而影响一个分支的可达性。在 CCP 稳定并且所有可能的常量折叠都已执行后，计算块 $B_{3}$ 出口处 $r$ 的精确值。\n\n你的最终答案应为一个精确的整数。不需要四舍五入。",
            "solution": "该问题要求将条件常量传播（CCP）算法应用于一个给定的静态单赋值（SSA）形式的程序，以确定变量 $r$ 的最终值。CCP 算法将常量传播与可达性分析相结合。每个变量的分析状态在三点格 $D = \\{\\bot, \\mathbb{Z}, \\top\\}$ 上进行维护，其中 $\\bot$ 表示变量未初始化或其定义代码不可达，任何整数 $z \\in \\mathbb{Z}$ 代表一个已知的常量值，而 $\\top$ 表示一个不是常量的值。\n\n分析过程通过模拟程序的执行、更新变量的格值并确定控制流路径的可行性来进行。我们为所有变量维护一个格值映射，并将其初始化为 $\\bot$：\n$Val(a_{0}) = \\bot$, $Val(b_{0}) = \\bot$, $Val(c_{1}) = \\bot$, $Val(c_{2}) = \\bot$, $Val(c_{3}) = \\bot$, $Val(r) = \\bot$。\n\n我们还跟踪每个基本块的可达性。最初，只有入口块 $B_{0}$ 是可达的。\n\n1.  **入口块 $B_0$ 的分析**：\n    这个块是入口点，因此是可达的。我们按顺序分析其语句。\n    -   语句 $a_{0} := 7$：变量 $a_{0}$ 被赋予定常量值 $7$。其格值从 $\\bot$ 更新为 $7$。因此，$Val(a_{0}) = 7$。\n    -   语句 $b_{0} := a_{0} - a_{0}$：减法的传递函数应用于 $a_{0}$ 的格值。由于 $Val(a_{0}) = 7$ 是一个已知常量，该表达式求值为 $7 - 7 = 0$。$b_{0}$ 的格值从 $\\bot$ 更新为 $0$。因此，$Val(b_{0}) = 0$。\n    -   语句 $\\text{if } (b_{0} = 1) \\text{ then goto } B_{1} \\text{ else goto } B_{2}$：这是一个条件分支。谓词涉及变量 $b_{0}$，我们已知其常量值为 $Val(b_{0}) = 0$。该条件被评估为 $0 = 1$，这确定无疑是 `false`。\n    -   根据 CCP 的原理，谓词为已知常量的条件分支决定了边的可行性。由于谓词为假，前往块 $B_{1}$ 的 `then` 分支被确定为不可执行，而前往块 $B_{2}$ 的 `else` 分支被确定为可执行。\n    -   这意味着块 $B_{1}$ 是不可达的，而块 $B_{2}$ 是可达的。\n\n2.  **Then 块 $B_1$ 的分析**：\n    -   根据对 $B_{0}$ 的分析，块 $B_{1}$ 是不可达的。因此，在抽象释义期间，其中的语句永远不会被执行。\n    -   语句 $c_{1} := 11$ 不会被处理。\n    -   $c_{1}$ 的格值保持其初始状态，$Val(c_{1}) = \\bot$。\n\n3.  **Else 块 $B_2$ 的分析**：\n    -   这个块通过来自 $B_{0}$ 的边是可达的。我们分析其语句。\n    -   语句 $c_{2} := 17$：变量 $c_{2}$ 被赋予定常量值 $17$。其格值从 $\\bot$ 更新为 $17$。因此，$Val(c_{2}) = 17$。\n    -   语句 $\\text{goto } B_{3}$：这是一个无条件跳转。从 $B_{2}$ 到 $B_{3}$ 的边是可执行的，这使得合并块 $B_{3}$ 变为可达。\n\n4.  **合并块 $B_3$ 的分析**：\n    -   这个块是可达的。我们分析其语句。\n    -   语句 $c_{3} := \\phi(c_{1}, c_{2})$：这个 SSA $\\phi$-函数合并来自前驱块 $B_{1}$ 和 $B_{2}$ 的值。CCP 对 $\\phi$-函数的规则是只考虑来自可行前驱路径的输入。\n    -   来自 $B_{1}$ 的前驱路径是不可执行的。因此，在 $B_{1}$ 中定义的 $c_{1}$ 的值是无关的。其格值为 $\\bot$。\n    -   来自 $B_{2}$ 的前驱路径是可执行的。沿此路径提供的值是 $c_{2}$，我们已知其值为 $Val(c_{2}) = 17$。\n    -   由于只有一条可行路径到达 $\\phi$-函数，$\\phi$-函数的结果就是来自那条唯一路径的值。因此，$c_{3}$ 取 $c_{2}$ 的值。\n    -   $c_{3}$ 的格值从 $\\bot$ 更新为 $17$。因此，$Val(c_{3}) = 17$。\n    -   语句 $r := 3 \\times c_{3} - 2$：应用此算术表达式的传递函数。我们使用已确定的 $c_{3}$ 的常量值，即 $17$。\n    -   表达式求值为 $3 \\times 17 - 2 = 51 - 2 = 49$。\n    -   $r$ 的格值从 $\\bot$ 更新为 $49$。因此，$Val(r) = 49$。\n\n算法已达到不动点，因为没有循环，并且所有可达块都已处理完毕。变量的最终格值为：\n$Val(a_{0}) = 7$\n$Val(b_{0}) = 0$\n$Val(c_{1}) = \\bot$\n$Val(c_{2}) = 17$\n$Val(c_{3}) = 17$\n$Val(r) = 49$\n\n在块 $B_{3}$ 出口处 $r$ 的值是由 CCP 计算出的常量值，即 $49$。",
            "answer": "$$\\boxed{49}$$"
        },
        {
            "introduction": "优化的威力常常体现在其级联效应上，一个小的简化可以引发一连串的连锁反应。本练习展示了条件常量传播的这一特性，其中第一次路径剪枝产生的新常量，恰好是下一个条件判断所需要的。通过这个实践，你将看到优化是如何一步步地“解锁”更多简化机会，最终将一段看似复杂的代码折叠成一个简单的结果。",
            "id": "3630625",
            "problem": "给你以下以静态单赋值（SSA）形式（SSA 是 Static Single Assignment 的缩写）表示的程序，该程序具有显式控制流和守卫更新。假设算术和比较运算具有其通常的整数语义。程序入口为一个变量赋一个常量值，然后求值一个可能更新该值的守卫比较。在守卫之后，该值与零进行比较，并返回一个最终值。\n\n程序（标签是为了便于阅读；所有变量均为 SSA 形式）：\n- 入口 (Entry)：定义 $x_0 := 1$ 并分支到 $B_1$。\n- 块 $B_1$：求值守卫：如果 $(x_0  0)$ 则分支到 $B_2$，否则分支到 $B_3$。\n- 块 $B_2$：计算守卫更新 $x_1 := x_0 - 1$ 并分支到 $B_4$。\n- 块 $B_3$：计算备选更新 $x_2 := x_0 + 2$ 并分支到 $B_4$。\n- 块 $B_4$：使用 $\\phi$-函数合并值 $x_3 := \\phi(B_2: x_1,\\; B_3: x_2)$；然后如果 $(x_3 == 0)$ 则赋值 $y_1 := 7$ 并分支到 $B_5$，否则赋值 $y_2 := 9$ 并分支到 $B_5$。\n- 块 $B_5$：使用 $\\phi$-函数合并 $y$，$y_3 := \\phi(B_4\\_\\text{true}: y_1,\\; B_4\\_\\text{false}: y_2)$；计算 $z_1 := y_3 + x_3$ 并返回 $z_1$。\n\n从第一性原理出发，应用条件常量传播。从标准的值格开始，其中每个 SSA 变量取抽象值 $\\bot$、一个具体的整型常量 $c$ 或 $\\top$ 之一，并结合当操作数为常量时通过求值守卫来确定的控制流可执行性。持续进行直到达到不动点，在此过程中折叠常量、移除不可执行代码并简化 $\\phi$-函数。\n\n在条件常量传播所隐含的所有常量折叠和不可达代码消除之后，程序的返回值是多少（以单个整数表示）？请提供确切的整数；无需四舍五入。",
            "solution": "用户提供了一个问题陈述，要求将条件常量传播（CCP）优化算法应用于一个给定的静态单赋值（SSA）形式的程序。\n\n### 第 1 步：提取已知信息\n\n问题提供了以下内容：\n- 一个 SSA 形式的程序，其控制流块标记为 `Entry`、$B_1$、$B_2$、$B_3$、$B_4$ 和 $B_5$。\n- 这些块内的一组指令：\n    - `Entry`: `定义` $x_0 := 1$ `并分支到` $B_1$。\n    - `块` $B_1$: `如果` $(x_0  0)$ `则分支到` $B_2$ `否则分支到` $B_3$。\n    - `块` $B_2$: `计算` $x_1 := x_0 - 1$ `并分支到` $B_4$。\n    - `块` $B_3$: `计算` $x_2 := x_0 + 2$ `并分支到` $B_4$。\n    - `块` $B_4$: `合并` $x_3 := \\phi(B_2: x_1, B_3: x_2)$; `然后如果` $(x_3 == 0)$ `赋值` $y_1 := 7$ `并分支到` $B_5$, `否则赋值` $y_2 := 9$ `并分支到` $B_5$。\n    - `块` $B_5$: `合并` $y_3 := \\phi(B_4\\_\\text{true}: y_1, B_4\\_\\text{false}: y_2)$; `计算` $z_1 := y_3 + x_3$ `并返回` $z_1$。\n- 变量值的抽象格被指定为 {$ \\bot $, 常量 $c$, $\\top$}。\n- 任务是从第一性原理出发应用 CCP 来找出最终返回的整数值。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n- **科学依据**：该问题在编译器理论的原理上有充分的依据。条件常量传播、静态单赋值（SSA）形式、控制流图和格理论都是该领域的标准、形式化概念。\n- **良定性**：CCP 算法是确定性的，并且保证会终止，因为抽象值的格具有有限的高度，且值在格中只会向上移动（$\\bot \\to c \\to \\top$）。存在唯一的不动点解。\n- **客观性**：该问题使用计算机科学和编译器设计中常见的形式化、精确的语言进行陈述，没有主观解释的余地。\n- **完整性和一致性**：程序的结构、初始值以及要应用的算法都已明确提供。描述是自洽的，没有矛盾。块 $B_5$ 中 $\\phi$-函数前驱的表示法（`$B_4\\_\\text{true}$` 和 `$B_4\\_\\text{false}$`）是一种清晰且标准的方式，用于指代前驱块中条件分支的结果。\n\n### 结论与行动\n该问题是有效的。这是一个定义明确的应用标准编译器优化算法的练习。我们可以继续进行求解。\n\n### 解法\n\n我们应用条件常量传播（CCP）算法。我们维护一个从 SSA 变量到其在格 {$\\bot$, $c$, $\\top$} 中抽象值的映射，并跟踪控制流图边的可执行性。\n\n**初始化：**\n- 所有 SSA 变量（$x_0, x_1, x_2, x_3, y_1, y_2, y_3, z_1$）都初始化为抽象值 $\\bot$。\n- `Entry` 块是可执行的，因此其指令被放入一个工作列表中。第一条指令是 $x_0 := 1$。\n\n**第 1 步：传播初始常量。**\n- 指令：`Entry` 中的 $x_0 := 1$。\n- 我们求值右侧，即常量 $1$。\n- $x_0$ 的抽象值从 $\\bot$ 更新为 $1$。\n- 控制流从 `Entry` 流向 $B_1$。$B_1$ 中的指令 `if ($x_0  0$)` 使用了 $x_0$，因此它被添加到工作列表中。\n\n**第 2 步：求值第一个条件分支。**\n- 指令：$B_1$ 中的 `if ($x_0  0$)`。\n- 我们检索 $x_0$ 的抽象值，为 $1$。\n- 条件变为 $1  0$，求值为 `true`。\n- 由于条件是常量 `true`，我们可以确定控制流。从 $B_1$ 到 $B_2$ 的边被标记为可执行。从 $B_1$ 到 $B_3$ 的边被标记为不可执行。\n- 块 $B_3$ 及其中的所有指令都不可达。因此，赋值语句 $x_2 := x_0 + 2$ 将不会被执行。\n- 可达块 $B_2$ 中的指令 $x_1 := x_0 - 1$ 被添加到工作列表中。\n\n**第 3 步：通过 'then' 分支进行传播。**\n- 指令：$B_2$ 中的 $x_1 := x_0 - 1$。\n- $x_0$ 的值为 $1$。表达式变为 $1 - 1$，求值为 $0$。\n- $x_1$ 的抽象值从 $\\bot$ 更新为 $0$。\n- 块 $B_2$ 无条件地分支到 $B_4$。$x_1$ 在 $B_4$ 开始处的 $x_3$ 的 $\\phi$-函数中使用，因此包含该 $\\phi$-函数的块 $B_4$ 的处理被添加到工作列表中。\n\n**第 4 步：求值第一个 $\\phi$-函数。**\n- 指令：$B_4$ 中的 $x_3 := \\phi(B_2: x_1, B_3: x_2)$。\n- 我们通过检查来自可执行前驱块的输入来求值 $\\phi$-函数。\n- 前驱 $B_2$ 是可达的。来自该路径的值是 $x_1$，其抽象值为 $0$。\n- 前驱 $B_3$ 是不可达的。\n- 由于只有一条路径到达该 $\\phi$-函数是可执行的，所以该 $\\phi$-函数简化为来自那条单一路径的值。\n- $x_3$ 的抽象值从 $\\bot$ 更新为 $0$。\n- 使用 $x_3$ 的指令，即 `if ($x_3 == 0$)` 和 $z_1 := y_3 + x_3$，被添加到工作列表中。\n\n**第 5 步：求值第二个条件分支。**\n- 指令：$B_4$ 中的 `if ($x_3 == 0$)`。\n- $x_3$ 的抽象值是 $0$。\n- 条件变为 $0 == 0$，求值为 `true`。\n- 采用 'true' 路径，使得指令 $y_1 := 7$ 变得可执行。\n- 不采用 'false' 路径，使得指令 $y_2 := 9$ 变得不可达。\n- 指令 $y_1 := 7$ 被添加到工作列表中。\n\n**第 6 步：传播新的常量。**\n- 指令：$y_1 := 7$。\n- $y_1$ 的抽象值从 $\\bot$ 更新为 $7$。\n- $y_1$ 在 $B_5$ 中用于 $y_3$ 的 $\\phi$-函数，因此该 $\\phi$-函数的处理被添加到工作列表中。\n\n**第 7 步：求值第二个 $\\phi$-函数。**\n- 指令：$B_5$ 中的 $y_3 := \\phi(B_4\\_\\text{true}: y_1, B_4\\_\\text{false}: y_2)$。\n- 我们通过检查其输入来求值 $\\phi$-函数。\n- 对应于 `$B_4\\_\\text{true}$` 的路径是可执行的。来自该路径的值是 $y_1$，其抽象值为 $7$。\n- 对应于 `$B_4\\_\\text{false}$` 的路径是不可执行的。$y_2$ 的值保持为 $\\bot$。\n- 该 $\\phi$-函数再次简化为来自单一可执行路径的值。\n- $y_3$ 的抽象值从 $\\bot$ 更新为 $7$。\n- 使用 $y_3$ 的指令 $z_1 := y_3 + x_3$ 已经在工作列表中，我们现在处理它。\n\n**第 8 步：计算最终值。**\n- 指令：$B_5$ 中的 $z_1 := y_3 + x_3$。\n- 我们检索操作数的抽象值。$y_3$ 的值是 $7$，$x_3$ 的值是 $0$。\n- 表达式变为 $7 + 0$，求值为 $7$。\n- $z_1$ 的抽象值从 $\\bot$ 更新为 $7$。\n- $z_1$ 是程序返回的值。\n\n**不动点：**\n工作列表现在为空。所有可达指令都已被求值，所有可达 SSA 变量的抽象值都已确定为常量。不会再有进一步的变化。算法已达到不动点。\n\n优化后的程序已被简化为一系列直线计算：\n1. $x_0 := 1$\n2. $x_1 := 1 - 1 = 0$\n3. $x_3 := 0$ (来自简化的 $\\phi$-函数)\n4. $y_1 := 7$\n5. $y_3 := 7$ (来自简化的 $\\phi$-函数)\n6. $z_1 := 7 + 0 = 7$\n7. 返回 $z_1$\n\n返回值为 $7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "条件常量传播不仅仅是向前传播已知常量，它还能从代码的结构中“反向推导”出变量的隐藏属性。这个高级练习将挑战你进行路径敏感分析。你将看到，即使一个变量在某个汇合点看起来不是常量，但为了到达程序的某个特定位置，它必须经过一系列的“卫语句”过滤，从而使其在该路径上必然为一个特定的常量值。",
            "id": "3630560",
            "problem": "一个编译器对一个程序应用静态单赋值（SSA）形式的稀疏条件常量传播（SCCP）。SCCP 使用一个三点格来表示值状态，其元素为 $\\bot$（未定义）、常量 $c \\in \\mathbb{Z}$ 和 $\\top$（过度定义），其 meet 算子偏好更精确的信息，并使用条件边可行性来限制哪些传入 $\\phi$-函数和使用的值被考虑。SSA 的语义是，每个变量名只被赋值一次，而 $\\phi$-函数合并来自不同控制流前驱的值。\n\n考虑以下 SSA 形式的控制流图（CFG），其中所有分支在执行时是互斥的，并到达一个共同的汇合点，变量 $x$ 是整数类型：\n\n- 入口块 $\\mathrm{E}$ 非确定性地分裂到三个前驱块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。\n- 在 $\\mathrm{A}$ 中：赋值 $x_{\\mathrm{A}} := 1$ 并 $\\mathrm{goto}$ 汇合点 $\\mathrm{J}$。\n- 在 $\\mathrm{B}$ 中：赋值 $x_{\\mathrm{B}} := 2$ 并 $\\mathrm{goto}$ 汇合点 $\\mathrm{J}$。\n- 在 $\\mathrm{C}$ 中：赋值 $x_{\\mathrm{C}} := 3$ 并 $\\mathrm{goto}$ 汇合点 $\\mathrm{J}$。\n- 在汇合块 $\\mathrm{J}$ 中：定义 $x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$，然后根据守卫条件分支 $\\mathrm{if}\\ (x  1)\\ \\mathrm{goto}\\ \\mathrm{T1}\\ \\mathrm{else}\\ \\mathrm{goto}\\ \\mathrm{F1}$。\n- 在块 $\\mathrm{T1}$ 中：根据守卫条件分支 $\\mathrm{if}\\ (x  3)\\ \\mathrm{goto}\\ \\mathrm{U}\\ \\mathrm{else}\\ \\mathrm{goto}\\ \\mathrm{F2}$。\n- 在块 $\\mathrm{U}$ 中：计算 $y := 3x^{2} - 5x + 7$ 然后停止。\n- 在块 $\\mathrm{F1}$ 和 $\\mathrm{F2}$ 中：不计算 $y$ 并停止。\n\n从上述基本的 SCCP 定义（值格 $\\{\\bot, c, \\top\\}$、SSA $\\phi$-语义以及通过评估守卫条件得出的控制流边的可行性）出发，通过对可行前驱进行交集来确定 SCCP 在块 $\\mathrm{U}$ 推导出的 $x$ 的值，然后计算在块 $\\mathrm{U}$ 中 $y := 3x^{2} - 5x + 7$ 的最终值。\n\n请以单个实数值的形式提供 $y$ 的最终答案。无需四舍五入。",
            "solution": "用户希望我按照以下步骤解决问题：\n1.  验证问题陈述。\n2.  如果有效，提供一个合理的解决方案。\n3.  解决方案必须按照严格的规则进行格式化，包括所有数学实体都必须使用 LaTeX。\n\n### 问题验证\n\n**第1步：提取已知信息**\n\n*   **算法：** 静态单赋值（SSA）形式的稀疏条件常量传播（SCCP）。\n*   **值格：** $\\{\\bot, c, \\top\\}$，其中 $\\bot$ 是未定义，$c \\in \\mathbb{Z}$ 是常量，$\\top$ 是过度定义。meet 算子 $\\sqcap$ 偏好更精确的信息（$\\bot$ 最不精确，$c$ 更精确，当常量不一致时 $\\top$ 最通用/最不精确）。\n*   **语义：** 每个变量只被赋值一次。$\\phi$-函数合并来自不同控制流前驱的值。\n*   **控制流图（CFG）和赋值：**\n    *   入口块 $\\mathrm{E}$ 分裂到块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。\n    *   块 $\\mathrm{A}$：$x_{\\mathrm{A}} := 1$，然后进入汇合块 $\\mathrm{J}$。\n    *   块 $\\mathrm{B}$：$x_{\\mathrm{B}} := 2$，然后进入汇合块 $\\mathrm{J}$。\n    *   块 $\\mathrm{C}$：$x_{\\mathrm{C}} := 3$，然后进入汇合块 $\\mathrm{J}$。\n    *   汇合块 $\\mathrm{J}$：$x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$，后跟分支 `if` $(x  1)$ `goto` $\\mathrm{T1}$ `else` `goto` $\\mathrm{F1}$。\n    *   块 $\\mathrm{T1}$：`if` $(x  3)$ `goto` $\\mathrm{U}$ `else` `goto` $\\mathrm{F2}$。\n    *   块 $\\mathrm{U}$：$y := 3x^{2} - 5x + 7$，然后停止。\n    *   块 $\\mathrm{F1}$、$\\mathrm{F2}$：停止。\n*   **目标：** 确定 SCCP 在块 $\\mathrm{U}$ 推导出的 $x$ 的值，并计算 $y$ 的最终值。$y$ 的最终答案必须是一个实数值。\n\n**第2步：使用提取的已知信息进行验证**\n\n*   **科学依据：** 该问题基于编译器设计中的标准、公认的概念：SCCP、SSA、CFG 和格理论。所描述的原理是正确的。\n*   **适定性：** 该问题定义了一个特定的程序结构和要应用的算法。它要求此应用的确定性结果。应该存在一个唯一的、有意义的解。\n*   **客观性：** 该问题以精确、正式的语言陈述，没有主观或模糊的元素。\n\n该问题不违反任何无效标准。它是编译器优化领域中一个定义明确的问题。短语“通过对可行前驱进行交集来确定 SCCP 在块 $\\mathrm{U}$ 推导出的 $x$ 的值”是指导分析的关键指令，暗示了算法条件性所固有的路径敏感解释。\n\n**第3步：结论和行动**\n\n问题有效。我将继续进行解答。\n\n### 解题过程\n\n问题要求我们追踪稀疏条件常量传播（SCCP）算法，以确定块 $\\mathrm{U}$ 中变量 $y$ 的值。SCCP 是一种乐观算法，它同时确定控制流的可达性和变量的值。\n\n算法开始时，所有变量的格值为 $\\bot$（未定义），所有控制流边都被认为不可执行。分析从入口块 $\\mathrm{E}$ 开始。\n\n1.  **初始传播：** 入口块 $\\mathrm{E}$ 无条件地将控制权转移到块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。因此，边 $\\mathrm{E} \\to \\mathrm{A}$、$\\mathrm{E} \\to \\mathrm{B}$ 和 $\\mathrm{E} \\to \\mathrm{C}$ 被标记为可执行。\n    *   在块 $\\mathrm{A}$ 中，变量 $x_{\\mathrm{A}}$ 被赋常量值 $1$。其格值变为 $1$。\n    *   在块 $\\mathrm{B}$ 中，$x_{\\mathrm{B}}$ 被赋值为 $2$。其格值变为 $2$。\n    *   在块 $\\mathrm{C}$ 中，$x_{\\mathrm{C}}$ 被赋值为 $3$。其格值变为 $3$。\n    *   由于块 $\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$ 都进入汇合块 $\\mathrm{J}$，因此边 $\\mathrm{A} \\to \\mathrm{J}$、$\\mathrm{B} \\to \\mathrm{J}$ 和 $\\mathrm{C} \\to \\mathrm{J}$ 也被标记为可执行。\n\n2.  **在块 J 进行 Phi-函数求值：** 块 $\\mathrm{J}$ 可从三个可执行的前驱到达：$\\mathrm{A}$、$\\mathrm{B}$ 和 $\\mathrm{C}$。$x$ 的值由 $\\phi$-函数决定：$x := \\phi(x_{\\mathrm{A}}, x_{\\mathrm{B}}, x_{\\mathrm{C}})$。$\\phi$-函数的值是其从所有可执行前驱路径传入的参数值的 meet（记为 $\\sqcap$）运算结果。\n    \n    输入的格值为 $1$、$2$ 和 $3$。meet 运算定义为：如果 $c_1=c_2$，则 $c_1 \\sqcap c_2 = c_1$；如果 $c_1 \\neq c_2$，则 $c_1 \\sqcap c_2 = \\top$。\n    \n    在块 $\\mathrm{J}$ 中，$x$ 的值计算如下：\n    $$ \\text{val}(x) = \\text{val}(x_{\\mathrm{A}}) \\sqcap \\text{val}(x_{\\mathrm{B}}) \\sqcap \\text{val}(x_{\\mathrm{C}}) = 1 \\sqcap 2 \\sqcap 3 $$\n    由于常量不相等，meet 运算的结果是 $\\top$（过度定义）。\n    $$ \\text{val}(x) = \\top $$\n\n3.  **条件分支传播：** 对 SCCP 的一个朴素应用会将 $\\text{val}(x) = \\top$ 传播到所有 $x$ 的使用点。这意味着条件 `if` $(x  1)$ 和 `if` $(x  3)$ 无法被解析为常量布尔值。算法将不得不假设每个条件分支的两条路径都是可执行的。这将意味着块 $\\mathrm{U}$ 是可达的，但 $\\text{val}(x) = \\top$，导致 $\\text{val}(y)=\\top$，这不是一个数值答案。\n\n    然而，SCCP 中的“条件”（Conditional）意味着更强大的分析。算法知道，要到达程序中的某个点，必须满足特定的条件为真。我们必须专门确定*在块 $\\mathrm{U}$ 处*的 $x$ 的值。\n\n4.  **对块 U 的路径敏感推导：**\n    *   要从 $\\mathrm{J}$ 到达块 $\\mathrm{T1}$，条件 $(x  1)$ 必须为真。\n    *   要从 $\\mathrm{T1}$ 到达块 $\\mathrm{U}$，条件 $(x  3)$ 必须为真。\n    *   因此，对于任何到达块 $\\mathrm{U}$ 的执行路径，该路径上的 $x$ 值必须满足组合条件 $(x  1) \\land (x  3)$。\n\n5.  **精化 x 的值：** 进入块 $\\mathrm{J}$ 的 $x$ 的可能常量值是 $\\{1, 2, 3\\}$，对应于来自块 $\\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}\\}$ 的路径。我们分析这些初始值中哪些与到达块 $\\mathrm{U}$ 所需的条件一致。\n    *   如果 $x=1$（来自路径 $\\mathrm{A}$），条件 $(x  1)$ 为假。程序将走 `else` 分支到 $\\mathrm{F1}$。块 $\\mathrm{U}$ 不可达。\n    *   如果 $x=2$（来自路径 $\\mathrm{B}$），条件 $(x  1)$ 为真。控制流传递到 $\\mathrm{T1}$。在 $\\mathrm{T1}$ 中，条件 $(x  3)$ 也为真。控制流传递到 $\\mathrm{U}$。此路径是可行的。\n    *   如果 $x=3$（来自路径 $\\mathrm{C}$），条件 $(x  1)$ 为真。控制流传递到 $\\mathrm{T1}$。在 $\\mathrm{T1}$ 中，条件 $(x  3)$ 为假。程序走 `else` 分支到 $\\mathrm{F2}$。块 $\\mathrm{U}$ 不可达。\n    \n    分析表明，唯一能够到达块 $\\mathrm{U}$ 的路径是源自块 $\\mathrm{B}$ 的那条。因此，SCCP可以推断出，如果执行到达块 $\\mathrm{U}$，则 $x$ 的值必须是 $2$。\n\n6.  **最终计算：** 根据在块 $\\mathrm{U}$ 推导出的值 $x=2$，我们可以计算 $y$ 的值。\n    $$ y := 3x^{2} - 5x + 7 $$\n    代入 $x=2$：\n    $$ y = 3(2)^{2} - 5(2) + 7 $$\n    $$ y = 3(4) - 10 + 7 $$\n    $$ y = 12 - 10 + 7 $$\n    $$ y = 2 + 7 $$\n    $$ y = 9 $$\n\n在块 $\\mathrm{U}$ 中计算出的 $y$ 的值为 $9$。",
            "answer": "$$\\boxed{9}$$"
        }
    ]
}