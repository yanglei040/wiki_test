{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数据流分析算法之前，我们必须首先掌握其基本构件：格（lattice）和转换函数（transfer function）。本练习将指导你从第一性原理出发，为一个同时追踪整数符号和奇偶性的分析任务构建一个乘积格，并推导一条算术语句的转换函数。这是一个核心技能，能让你理解抽象解释（abstract interpretation）如何精确地对程序行为进行建模 。",
            "id": "3635977",
            "problem": "考虑一个前向数据流分析，该分析在每个程序点跟踪每个整型变量的抽象符号和奇偶性。该分析使用一个由符号格和奇偶性格构成的积格，并在分支合并处使用一个汇合算子，该算子是关于所选偏序的最大下界（meet）。你的任务是从第一性原理出发，推导这个积格，为赋值语句 $x := 2y + 1$ 构建转换函数，并分析信息在一个简单控制流图中的流动。最终，你将计算该积格的高度。仅报告这个高度作为你的最终答案。\n\n从以下基本原理开始：\n\n1. 该分析使用一个有限格来表示符号信息，记为 $\\mathcal{S}$，以及一个有限格来表示奇偶性信息，记为 $\\mathcal{P}$。每个格元素通过一个具体化函数抽象一个整数集合。分支合并处的汇合算子是格的偏序关系下的最大下界（meet）。\n\n2. 符号格 $\\mathcal{S}$ 抽象了以下整数集合：所有整数的集合（将元素记为 $\\mathsf{AnyS}$）、负整数（记为 $\\mathsf{Neg}$）、零（记为 $\\mathsf{Zero}$）、正整数（记为 $\\mathsf{Pos}$）和空集（记为 $\\mathsf{NoneS}$）。具体化函数 $\\gamma_{\\mathcal{S}}$ 将这些元素映射到相应的整数集合。格序 $\\preceq_{\\mathcal{S}}$ 由具体化集合的反向包含关系定义：对于 $a, b \\in \\mathcal{S}$，\n$$\na \\preceq_{\\mathcal{S}} b \\;\\;\\text{if and only if}\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n$$\n因此，$\\mathsf{AnyS}$ 是 $\\mathcal{S}$ 的最小元，$\\mathsf{NoneS}$ 是最大元；元素 $\\mathsf{Neg}$、$\\mathsf{Zero}$ 和 $\\mathsf{Pos}$ 严格位于它们之间且两两不可比。meet 算子 $\\sqcap_{\\mathcal{S}}$ 是关于 $\\preceq_{\\mathcal{S}}$ 的最大下界。\n\n3. 奇偶性格 $\\mathcal{P}$ 抽象了以下整数集合：所有整数的集合（将元素记为 $\\mathsf{AnyP}$）、偶数（记为 $\\mathsf{Even}$）、奇数（记为 $\\mathsf{Odd}$）和空集（记为 $\\mathsf{NoneP}$）。具体化函数 $\\gamma_{\\mathcal{P}}$ 和序 $\\preceq_{\\mathcal{P}}$ 类似地由反向集合包含关系定义：对于 $p, q \\in \\mathcal{P}$，\n$$\np \\preceq_{\\mathcal{P}} q \\;\\;\\text{if and only if}\\;\\; \\gamma_{\\mathcal{P}}(p) \\supseteq \\gamma_{\\mathcal{P}}(q).\n$$\n因此，$\\mathsf{AnyP}$ 是最小元，$\\mathsf{NoneP}$ 是最大元，而 $\\mathsf{Even}$ 和 $\\mathsf{Odd}$ 是它们之间不可比的原子。meet 算子 $\\sqcap_{\\mathcal{P}}$ 是关于 $\\preceq_{\\mathcal{P}}$ 的最大下界。\n\n4. 积格 $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ 是分量有序的：对于 $(s_{1}, p_{1}), (s_{2}, p_{2}) \\in \\mathcal{L}$，\n$$\n(s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\text{if and only if}\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\;\\text{and}\\;\\; p_{1} \\preceq_{\\mathcal{P}} p_{2}.\n$$\nmeet 算子 $\\sqcap_{\\mathcal{L}}$ 由分量方式给出：\n$$\n(s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n$$\n\n给定以下带有一个合并节点的直线型控制流图，使用了一个非确定性条件语句。控制流图（CFG）的节点如下：\n- 入口节点将 $x$ 和 $y$ 的抽象状态都初始化为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n- 然后是一个带有两个后继节点的分支节点：\n  - 分支 $B_{1}$ 赋值 $y := 0$。\n  - 分支 $B_{2}$ 赋值 $y := -1$。\n- 两个分支在节点 $M$ 处合并，该节点赋值 $x := 2y + 1$。\n- 没有其他语句。\n\n你必须在推理中完成以下任务：\n- 使用表达式的抽象解释的基本定义，在积格 $\\mathcal{L}$ 上为节点 $M$ 的赋值语句 $x := 2y + 1$ 推导转换函数 $f_{n}$。你的推导必须从乘以二再加一在抽象符号和奇偶性上的算术性质出发进行明确论证。\n- 在合并点使用汇合算子，从两个前驱节点的事实计算出 $M$ 的抽象输入，然后应用 $f_{n}$ 来获得在 $M$ 处 $x$ 的抽象输出。\n- 根据积格的结构性质以及上面 $\\mathcal{S}$ 和 $\\mathcal{P}$ 的定义，推导积格 $\\mathcal{L}$ 的高度 $h_{\\mathcal{L}}$，其中高度是在 $\\preceq_{\\mathcal{L}}$ 下最长严格升链中的元素数量。\n\n仅报告 $h_{\\mathcal{L}}$ 的值作为最终答案。无需四舍五入。没有适用单位。",
            "solution": "我们首先精确地形式化抽象域和汇合算子，然后为 $x := 2y + 1$ 推导转换函数，计算在 $M$ 处的合并，最后计算积格的高度。\n\n基础格的基本设置：\n- 符号格 $\\mathcal{S}$ 由元素 $\\{\\mathsf{AnyS}, \\mathsf{Neg}, \\mathsf{Zero}, \\mathsf{Pos}, \\mathsf{NoneS}\\}$ 组成，其具体化函数 $\\gamma_{\\mathcal{S}}$ 如下：\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{AnyS}) = \\mathbb{Z}$，\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Neg}) = \\{ n \\in \\mathbb{Z} \\mid n  0 \\}$，\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Zero}) = \\{ 0 \\}$，\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{Pos}) = \\{ n \\in \\mathbb{Z} \\mid n > 0 \\}$，\n  - $\\gamma_{\\mathcal{S}}(\\mathsf{NoneS}) = \\varnothing$。\n  偏序由反向集合包含关系定义：\n  $$\n  a \\preceq_{\\mathcal{S}} b \\;\\;\\Leftrightarrow\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n  $$\n  因此，$\\mathsf{AnyS}$ 是最小元，$\\mathsf{NoneS}$ 是最大元，三个原子 $\\mathsf{Neg}$、$\\mathsf{Zero}$、$\\mathsf{Pos}$ 严格位于它们之间且两两不可比。meet 算子 $\\sqcap_{\\mathcal{S}}$ 是关于 $\\preceq_{\\mathcal{S}}$ 的最大下界。具体来说，因为 $\\preceq_{\\mathcal{S}}$ 是具体化集合的反向包含关系，所以 $\\sqcap_{\\mathcal{S}}$ 对应于具体层面的集合并集：\n  $$\n  \\gamma_{\\mathcal{S}}(a \\sqcap_{\\mathcal{S}} b) \\;=\\; \\gamma_{\\mathcal{S}}(a) \\cup \\gamma_{\\mathcal{S}}(b).\n  $$\n  因此，例如，$\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Pos} = \\mathsf{AnyS}$ 且 $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Zero} = \\mathsf{AnyS}$，而 $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Neg} = \\mathsf{Neg}$。\n\n- 奇偶性格 $\\mathcal{P}$ 由 $\\{\\mathsf{AnyP}, \\mathsf{Even}, \\mathsf{Odd}, \\mathsf{NoneP}\\}$ 组成，其具体化函数 $\\gamma_{\\mathcal{P}}$ 如下：\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{AnyP}) = \\mathbb{Z}$，\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{Even}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 0 \\pmod{2} \\}$，\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{Odd}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 1 \\pmod{2} \\}$，\n  - $\\gamma_{\\mathcal{P}}(\\mathsf{NoneP}) = \\varnothing$。\n  序关系是 $\\preceq_{\\mathcal{P}}$，具有相同的反向包含定义，且 meet 算子 $\\sqcap_{\\mathcal{P}}$ 满足\n  $$\n  \\gamma_{\\mathcal{P}}(p \\sqcap_{\\mathcal{P}} q) \\;=\\; \\gamma_{\\mathcal{P}}(p) \\cup \\gamma_{\\mathcal{P}}(q).\n  $$\n  因此 $\\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{AnyP}$ 且 $\\mathsf{Odd} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{Odd}$。\n\n积格与汇合：\n- 积格是 $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$，具有分量有序的 $\\preceq_{\\mathcal{L}}$ 和 meet 算子 $\\sqcap_{\\mathcal{L}}$：\n  $$\n  (s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\Leftrightarrow\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\wedge\\; p_{1} \\preceq_{\\mathcal{P}} p_{2},\n  $$\n  $$\n  (s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n  $$\n  在分支合并处，我们使用 $\\sqcap_{\\mathcal{L}}$ 作为汇合算子。\n\n$x := 2y + 1$ 的转换函数：\n- 我们分别推导对奇偶性和符号的抽象影响，然后将它们组合起来。\n\n奇偶性分量。对任意整数 $y$，$2y$ 是偶数，$2y + 1$ 是奇数。因此，无论输入的 $y$ 的奇偶性如何（除了不可达的 $\\mathsf{NoneP}$），$x := 2y+1$ 的奇偶性都确定为 $\\mathsf{Odd}$。形式上，定义 $f^{\\mathcal{P}}_{n} : \\mathcal{P} \\to \\mathcal{P}$ 为\n$$\nf^{\\mathcal{P}}_{n}(p) \\;=\\; \n\\begin{cases}\n\\mathsf{Odd},  \\text{if } p \\neq \\mathsf{NoneP},\\\\[4pt]\n\\mathsf{NoneP},  \\text{if } p = \\mathsf{NoneP}.\n\\end{cases}\n$$\n\n符号分量。对任意整数 $y$，$2y + 1 \\neq 0$ 因为 $2y$ 是偶数，加 1 得到奇数。当 $y \\geq 0$ 时，$2y + 1$ 的符号为正；当 $y \\leq -1$ 时，符号为负。在抽象元素上，精确结果取决于输入：\n- 如果 $y$ 恰好是 $\\mathsf{Zero}$，那么 $x = 1$，所以符号是 $\\mathsf{Pos}$。\n- 如果 $y$ 恰好是 $\\mathsf{Pos}$，那么 $2y + 1 \\geq 3$，所以符号是 $\\mathsf{Pos}$。\n- 如果 $y$ 恰好是 $\\mathsf{Neg}$，那么 $2y + 1 \\leq -1$，所以符号是 $\\mathsf{Neg}$。\n- 如果 $y$ 是 $\\mathsf{AnyS}$，那么可能的符号的具体集合是 $\\{\\mathsf{Neg}, \\mathsf{Pos}\\}$；由于我们的格没有专门的 $\\mathsf{NonZero}$ 元素，最精确的可表示抽象符号是 $\\mathsf{AnyS}$。\n- 如果 $y$ 是 $\\mathsf{NoneS}$，那么输出是 $\\mathsf{NoneS}$。\n\n因此定义 $f^{\\mathcal{S}}_{n} : \\mathcal{S} \\to \\mathcal{S}$ 为\n$$\nf^{\\mathcal{S}}_{n}(s) \\;=\\;\n\\begin{cases}\n\\mathsf{Pos},  \\text{if } s \\in \\{ \\mathsf{Zero}, \\mathsf{Pos} \\},\\\\[4pt]\n\\mathsf{Neg},  \\text{if } s = \\mathsf{Neg},\\\\[4pt]\n\\mathsf{AnyS},  \\text{if } s = \\mathsf{AnyS},\\\\[4pt]\n\\mathsf{NoneS},  \\text{if } s = \\mathsf{NoneS}.\n\\end{cases}\n$$\n\n积转换函数。节点 $M$ 赋值 $x := 2y+1$ 并保持 $y$ 不变。因此，对于变量 $\\{x,y\\}$ 的环境，转换函数 $f_{n} : \\mathcal{L}^{\\{x,y\\}} \\to \\mathcal{L}^{\\{x,y\\}}$ 为\n$$\nf_{n}\\big((s_{x}, p_{x}), (s_{y}, p_{y})\\big) \\;=\\; \\Big( \\big(f^{\\mathcal{S}}_{n}(s_{y}),\\, f^{\\mathcal{P}}_{n}(p_{y})\\big),\\; (s_{y}, p_{y}) \\Big),\n$$\n其中第一个分量是 $x$ 的新抽象值，第二个分量是 $y$ 不变的抽象值。\n\n通过控制流图的流：\n- 入口节点将 $x$ 和 $y$ 都初始化为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n- 分支 $B_{1}$ 赋值 $y := 0$，所以在 $B_{1}$ 的末尾，$y$ 的抽象事实是 $(\\mathsf{Zero}, \\mathsf{Even})$；$x$ 保持为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n- 分支 $B_{2}$ 赋值 $y := -1$，所以在 $B_{2}$ 的末尾，$y$ 的抽象事实是 $(\\mathsf{Neg}, \\mathsf{Odd})$；$x$ 保持为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n\n在 $M$ 处的汇合逐分量使用 meet 算子 $\\sqcap_{\\mathcal{L}}$（回想一下，在我们的反向包含序下，此算子对应于取具体化集合的并集）。对于 $y$ 到 $M$ 的输入，我们有\n$$\n(\\mathsf{Zero}, \\mathsf{Even}) \\;\\sqcap_{\\mathcal{L}}\\; (\\mathsf{Neg}, \\mathsf{Odd}) \\;=\\; \\big(\\,\\mathsf{Zero} \\sqcap_{\\mathcal{S}} \\mathsf{Neg},\\; \\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd}\\,\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{AnyP}).\n$$\n然后在 $M$ 处应用 $f_{n}$，对 $x$ 得到：\n$$\n\\big(f^{\\mathcal{S}}_{n}(\\mathsf{AnyS}),\\; f^{\\mathcal{P}}_{n}(\\mathsf{AnyP})\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{Odd}),\n$$\n而 $y$ 保持为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。这说明联合积抽象捕捉到了 $2y+1$ 确保为奇数的奇偶性，而在此域中符号无法被精化到比 $\\mathsf{AnyS}$ 更精确的程度。\n\n积格的高度：\n- 有限偏序集的高度是最长严格升链中的元素数量。对于 $\\mathcal{S}$，在 $\\preceq_{\\mathcal{S}}$ 下的最长链是\n$$\n\\mathsf{AnyS} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{Neg} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{NoneS},\n$$\n或者类似地使用 $\\mathsf{Zero}$ 或 $\\mathsf{Pos}$ 作为中间原子。因此 $\\mathcal{S}$ 的高度是\n$$\nh_{\\mathcal{S}} \\;=\\; 3.\n$$\n- 对于 $\\mathcal{P}$，在 $\\preceq_{\\mathcal{P}}$ 下的最长链是\n$$\n\\mathsf{AnyP} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{Even} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{NoneP},\n$$\n或者以 $\\mathsf{Odd}$ 作为中间原子。因此\n$$\nh_{\\mathcal{P}} \\;=\\; 3.\n$$\n- 对于具有分量序的积格 $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$，其高度满足\n$$\nh_{\\mathcal{L}} \\;=\\; h_{\\mathcal{S}} \\;+\\; h_{\\mathcal{P}} \\;-\\; 1,\n$$\n因为积中的任何严格升链在每一步都必须至少在一个分量上增加，并且我们可以交错来自 $\\mathcal{S}$ 和 $\\mathcal{P}$ 的最长链，同时注意到共享的起始元素。代入数值可得\n$$\nh_{\\mathcal{L}} \\;=\\; 3 \\;+\\; 3 \\;-\\; 1 \\;=\\; 5.\n$$\n\n因此，积格的高度是 $5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "数据流分析的真正威力体现在处理循环时，因为信息会在循环中反复迭代直到达到一个稳定状态，即不动点（fixpoint）。本练习模拟了一个实际场景，即追踪循环中位运算对处理器标志位（符号位和零位）的影响 。通过手动执行不动点迭代过程，你将深入理解分析是如何收敛到循环不变式（loop invariant）的。",
            "id": "3635973",
            "problem": "考虑一个在编译器中间表示中对循环进行的前向数据流分析，该分析旨在跟踪 $32$ 位二进制补码整数的两个机器标志位：符号标志位 $S$ 和零标志位 $Z$。符号标志位 $S$ 的定义为：当且仅当当前值 $x$ 的最高有效位（位索引 $31$）为 $1$ 时为 $\\mathsf{T}$，若该位为 $0$ 则为 $\\mathsf{F}$。零标志位 $Z$ 的定义为：当且仅当当前值 $x$ 等于 $0$ 时为 $\\mathsf{T}$，否则为 $\\mathsf{F}$。每个标志位都在一个三值格 $\\{\\mathsf{T},\\mathsf{F},\\mathsf{U}\\}$ 中被独立地抽象，其中 $\\mathsf{U}$ 表示“未知”。此格上的精度顺序为 $\\mathsf{T} \\preceq \\mathsf{U}$ 和 $\\mathsf{F} \\preceq \\mathsf{U}$，而 $\\mathsf{T}$ 和 $\\mathsf{F}$ 是不可比的。设以下循环的控制流图（Control Flow Graph (CFG)）如下所示：\n$$\n\\text{do }\\{\\, x := x  0x\\text{FFFFFFFE};\\quad x := x \\,|\\, 0x\\text{00000001}; \\,\\}\\ \\text{while }(\\text{unknown condition})\n$$\n假设循环条件是任意的，并且可能导致任意 $\\geq 1$ 次的迭代。在第一次迭代进入循环体之前（即循环头处）的程序点，抽象事实为 $S=\\mathsf{U}$ 和 $Z=\\mathsf{U}$，这反映了传入值 $x$ 是不受约束的。\n\n要求您在一个单调数据流框架中，使用不动点公式计算循环出口处的抽象事实 $(S,Z)$，并遵循以下转换函数规则，这些规则仅使用事实 $S$ 和 $Z$，并且相对于位运算的语义是保守的：\n\n- 对于语句 $y := x  m$（其中 $m$ 为常量掩码），如果 $m$ 的最高有效位为 $1$，则 $S$ 不变；否则 $S$ 变为 $\\mathsf{U}$。在除了 $S$ 和 $Z$ 之外没有任何信息的情况下，将 $Z$ 设置为 $\\mathsf{U}$，除非 $m=0$，此时 $Z=\\mathsf{T}$。\n- 对于语句 $y := x \\,|\\, c$（其中 $c$ 为常量），如果 $c$ 的最高有效位为 $1$，则 $S=\\mathsf{T}$；如果为 $0$，则 $S$ 不变。如果 $c \\neq 0$，则 $Z=\\mathsf{F}$；如果 $c=0$，则 $Z$ 不变。\n\n在给定的循环体中，$m=0x\\text{FFFFFFFE}$ 且 $c=0x\\text{00000001}$。循环体至少执行一次（do-while 语义）。请使用在有限高格上基于单调转换函数的前向数据流的标准最小不动点语义。使用映射 $\\mathsf{T}\\mapsto 2$、$\\mathsf{U}\\mapsto 1$ 和 $\\mathsf{F}\\mapsto 0$，将循环出口处的最终抽象事实 $(S,Z)$ 编码为一个数值行矩阵。仅以该行矩阵的形式提供您的最终答案。不需要四舍五入，也不涉及物理单位。",
            "solution": "题目要求我们计算一个 `do-while` 循环出口处的抽象状态 $(S,Z)$。这是一个前向数据流分析问题，我们通过求解该循环的数据流方程的最小不动点来解决它。\n\n单个标志位的抽象域是三点格 $L = \\{\\mathsf{T}, \\mathsf{F}, \\mathsf{U}\\}$，其序关系为 $\\mathsf{F} \\preceq \\mathsf{U}$ 和 $\\mathsf{T} \\preceq \\mathsf{U}$。对于两个元素 $a,b \\in L$，其并运算 $\\sqcup$ 是它们的最小上界：如果 $a=b$，则 $a \\sqcup b = a$，否则 $a \\sqcup b = \\mathsf{U}$。我们的分析状态是一个对 $(S,Z)$，它是乘积格 $L \\times L$ 中的一个元素，其中并运算是分量级地执行的。\n\n首先，我们确定循环体 $f_{body}$ 的转换函数。循环体由两条指令组成。设循环体开始处的状态为 $(S_{in}, Z_{in})$。\n\n第一条指令是 $x := x  m$，其中 $m=0x\\text{FFFFFFFE}$。\n- **符号标志位 $S$**：掩码 $m$ 的最高有效位（MSB）为 $1$。根据给定规则，MSB=$1$ 的掩码使 $S$ 保持不变。因此，此操作后的符号标志位 $S_{mid}$ 等于 $S_{in}$。\n- **零标志位 $Z$**：掩码 $m=0x\\text{FFFFFFFE}$ 不等于 $0$。规则规定，对于 $m \\neq 0$，$Z$ 变为 $\\mathsf{U}$。所以，$Z_{mid} = \\mathsf{U}$。\n第一条指令执行后的状态是 $(S_{mid}, Z_{mid}) = (S_{in}, \\mathsf{U})$。\n\n第二条指令是 $x := x \\,|\\, c$，其中 $c=0x\\text{00000001}$。这条指令对第一条指令产生的 $x$ 值进行操作，因此其输入抽象状态是 $(S_{mid}, Z_{mid})$。\n- **符号标志位 $S$**：常量 $c$ 的 MSB 为 $0$。规则规定，如果 $c$ 的 MSB 为 $0$，则 $S$ 不变。因此，最终的符号标志位 $S_{out}$ 等于 $S_{mid}$，也就是 $S_{in}$。所以，$S_{out} = S_{in}$。\n- **零标志位 $Z$**：常量 $c=0x\\text{00000001}$ 不等于 $0$。规则规定，如果 $c \\neq 0$，$Z$ 变为 $\\mathsf{F}$。所以，$Z_{out} = \\mathsf{F}$。\n第二条指令执行后的状态是 $(S_{out}, Z_{out}) = (S_{in}, \\mathsf{F})$。\n\n综合起来，整个循环体的转换函数是 $f_{body}(S_{in}, Z_{in}) = (S_{in}, \\mathsf{F})$。\n\n接下来，我们必须找到循环头处抽象状态的不动点。设 $H$ 为循环头处的状态。$H$ 是循环前状态 $H_{pre}$ 和循环回边状态 $H_{back}$ 的并。\n题目指出，在循环头处的传入抽象事实是 $(\\mathsf{U},\\mathsf{U})$。这就是 $H_{pre}$。\n所以，$H_{pre} = (\\mathsf{U}, \\mathsf{U})$。\n回边上的状态 $H_{back}$ 是将循环体的转换函数应用于循环头处的状态的结果，即 $H_{back} = f_{body}(H)$。\n循环头的不动点方程为：\n$$H = H_{pre} \\sqcup H_{back} = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(H)$$\n我们可以通过迭代来求解此方程，从 $H$ 的一个初始近似开始。一种标准方法是用表示无信息的“底”元素 $(\\bot, \\bot)$ 进行初始化，其性质为对于任何 $v$ 都有 $v \\sqcup \\bot = v$。\n\n迭代 $0$：$H_0 = (\\bot, \\bot)$。\n\n迭代 $1$：\n$$H_1 = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(H_0) = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(\\bot, \\bot)$$\n根据我们推导出的转换函数 $f_{body}(S, Z) = (S, \\mathsf{F})$，所以 $f_{body}(\\bot, \\bot) = (\\bot, \\mathsf{F})$。\n$$H_1 = (\\mathsf{U}, \\mathsf{U}) \\sqcup (\\bot, \\mathsf{F}) = (\\mathsf{U} \\sqcup \\bot, \\mathsf{U} \\sqcup \\mathsf{F})$$\n使用并运算的定义：$\\mathsf{U} \\sqcup \\bot = \\mathsf{U}$ 和 $\\mathsf{U} \\sqcup \\mathsf{F} = \\mathsf{U}$。\n$$H_1 = (\\mathsf{U}, \\mathsf{U})$$\n\n迭代 $2$：\n$$H_2 = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(H_1) = (\\mathsf{U}, \\mathsf{U}) \\sqcup f_{body}(\\mathsf{U}, \\mathsf{U})$$\n应用转换函数：$f_{body}(\\mathsf{U}, \\mathsf{U}) = (\\mathsf{U}, \\mathsf{F})$。\n$$H_2 = (\\mathsf{U}, \\mathsf{U}) \\sqcup (\\mathsf{U}, \\mathsf{F}) = (\\mathsf{U} \\sqcup \\mathsf{U}, \\mathsf{U} \\sqcup \\mathsf{F}) = (\\mathsf{U}, \\mathsf{U})$$\n由于 $H_2 = H_1$，迭代已收敛。循环头处的最小不动点（以及循环不变量）是 $H_{fixpoint} = (\\mathsf{U}, \\mathsf{U})$。\n\n最后，我们需要确定循环出口处的抽象状态。对于 `do-while` 循环，条件分支发生在循环体执行之后。出口处的状态是当条件为假时从条件分支流出的状态。这个状态恰好是循环体执行后、分支决策作出前的状态。\n因此，循环出口处的状态 $H_{exit}$ 是将循环体的转换函数应用于循环头处不动点状态的结果。\n$$H_{exit} = f_{body}(H_{fixpoint}) = f_{body}(\\mathsf{U}, \\mathsf{U}) = (\\mathsf{U}, \\mathsf{F})$$\n\n循环出口处的最终抽象状态是 $(S,Z) = (\\mathsf{U}, \\mathsf{F})$。我们必须使用给定的映射 $\\mathsf{T} \\mapsto 2$, $\\mathsf{U} \\mapsto 1$, $\\mathsf{F} \\mapsto 0$ 对其进行编码。\n- $S = \\mathsf{U}$ 映射到 $1$。\n- $Z = \\mathsf{F}$ 映射到 $0$。\n\n结果为序对 $(1, 0)$，表示为一个行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论概念最终需要通过高效的算法来实现，而工作列表（worklist）算法是求解数据流方程的标准方法。本练习将带你走进工作列表算法的核心，通过分析一个包含不可达代码的控制流图（CFG），你将看到正确的算法初始化和执行流程如何确保分析的精度 。这揭示了为何仔细的算法设计对于避免来自不可达代码的“幽灵”信息污染最终结果至关重要。",
            "id": "3635901",
            "problem": "考虑在一个控制流图（CFG）上进行的前向数据流分析，其中控制流图（CFG）表示一个有向图，其节点为基本块，边对应于可能的控制转移。给定一个包含四个基本块的程序：$B_{\\mathrm{entry}}$、$B_{1}$、$B_{2}$ 和 $B_{3}$。这些块和边如下所述。\n\n- 块 $B_{\\mathrm{entry}}$：包含单条语句 $y := 0$，然后无条件跳转到 $B_{2}$。\n- 块 $B_{1}$：包含一个永远不会从 $B_{\\mathrm{entry}}$ 接收到控制的循环（它从 $B_{\\mathrm{entry}}$ 是不可达的）。其语句为 $x := 7$，然后是一个条件分支，要么跳转回 $B_{1}$，要么跳转到 $B_{3}$。因此，$B_{1}$ 有一条自循环边和一条到 $B_{3}$ 的边，但没有任何从 $B_{\\mathrm{entry}}$ 可达的块指向 $B_{1}$ 的入边。\n- 块 $B_{2}$：包含单条语句 $x := 1$，然后无条件跳转到 $B_{3}$。\n- 块 $B_{3}$：包含单条语句 $z := x$。有两条指向 $B_{3}$ 的入边：一条来自 $B_{2}$，一条来自 $B_{1}$。\n\n形式上，边集为 $\\{(B_{\\mathrm{entry}},B_{2}),(B_{1},B_{1}),(B_{1},B_{3}),(B_{2},B_{3})\\}$。\n\n设数据流问题为仅针对单个变量 $x$ 的到达定值分析。其域由 $x$ 的定值点组成，它们是：\n- $d_{u}$：$B_{1}$ 中的定值 $x := 7$。\n- $d_{r}$：$B_{2}$ 中的定值 $x := 1$。\n\n使用前向、路径不敏感、“may”分析的单调框架，在有限幂集格上进行，仅从核心定值开始（用于“may”分析的格序和交会运算、块局部的 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集合，以及传递函数的标准组合）。假设使用一个标准的工作列表求解器，该求解器：\n- 将 $\\mathrm{IN}[B_{\\mathrm{entry}}]$ 初始化为格的最小元 $\\bot$，\n- 将所有其他数据流集合初始化为 $\\bot$，\n- 仅用 $B_{\\mathrm{entry}}$ 填充初始工作列表，然后沿 CFG 边传播，直到达到不动点。\n\n根据这些原则推导出数据流方程，并在指定的边界条件下求解直至不动点。特别地，确定在给定边界条件下，求解器在 $B_{3}$ 的入口处产生的 $x$ 的不同到达定值的数量（即 $\\mathrm{IN}[B_{3}]$ 关于 $x$ 的基数）。作为推理的一部分，请说明为什么当 $\\mathrm{IN}[B_{\\mathrm{entry}}]=\\bot$ 时，$B_{1}$ 中的不可达循环不会污染 $B_{3}$ 处的解，并解释为什么在存在不可达代码的情况下，这个边界条件很重要。\n\n只需报告最终数字。无需四舍五入。",
            "solution": "该问题是有效的，因为它是自洽的，以编译原理为科学基础，并且是客观表述的。我们将进行形式化的求解。\n\n问题要求计算在基本块 $B_{3}$ 入口处，变量 $x$ 的到达定值的数量。这是一个前向的、“may”数据流分析问题。\n\n### 1. 形式化框架\n- **方向**：前向分析。\n- **$x$ 的定值集合**：$D = \\{d_{u}, d_{r}\\}$，其中 $d_{u}$ 是 $B_1$ 中的 $x := 7$，$d_{r}$ 是 $B_2$ 中的 $x := 1$。\n- **域**：格是 $D$ 的幂集，记为 $\\mathcal{P}(D)$。元素是到达定值的集合。\n- **格属性**：\n    - 偏序关系是集合包含关系 $\\subseteq$。\n    - “may”分析的交会算子（$\\wedge$）是集合并集 $\\cup$。这在控制流图（CFG）的汇合点使用。\n    - 底元素是 $\\bot = \\emptyset$，表示没有定值到达。\n    - 顶元素是 $T = D = \\{d_{u}, d_{r}\\}$，表示所有定值都可能到达。\n- **数据流方程**：对于一个基本块 $B$，IN 和 OUT 集合的关系如下：\n$$ \\mathrm{OUT}[B] = F_B(\\mathrm{IN}[B]) $$\n$$ \\mathrm{IN}[B] = \\bigcup_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n其中 $\\mathrm{pred}(B)$ 是 $B$ 的前驱节点集合。对于入口块，$\\mathrm{IN}[B_{\\mathrm{entry}}]$ 是一个边界条件。\n\n### 2. GEN 和 KILL 集合\n块 $B$ 的传递函数 $F_B$ 是通过其局部效应来定义的，由 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集合捕获。对于一个输入的定值集合 $S$，输出的定值是 $F_B(S) = (S \\setminus \\mathrm{KILL}_B) \\cup \\mathrm{GEN}_B$。我们针对变量 $x$ 来确定每个块的这些集合。\n\n- **块 $B_{\\mathrm{entry}}$**：包含 $y := 0$。这不定义也不使用 $x$。\n    - $\\mathrm{GEN}[B_{\\mathrm{entry}}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{\\mathrm{entry}}] = \\emptyset$\n\n- **块 $B_{1}$**：包含 $x := 7$ (定值 $d_{u}$)。这个定值会杀死所有其他 $x$ 的定值。\n    - $\\mathrm{GEN}[B_{1}] = \\{d_u\\}$\n    - $\\mathrm{KILL}[B_{1}] = D \\setminus \\{d_u\\} = \\{d_r\\}$\n\n- **块 $B_{2}$**：包含 $x := 1$ (定值 $d_{r}$)。这个定值会杀死所有其他 $x$ 的定值。\n    - $\\mathrm{GEN}[B_{2}] = \\{d_r\\}$\n    - $\\mathrm{KILL}[B_{2}] = D \\setminus \\{d_r\\} = \\{d_u\\}$\n\n- **块 $B_{3}$**：包含 $z := x$。这不定义 $x$。\n    - $\\mathrm{GEN}[B_{3}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{3}] = \\emptyset$\n\n### 3. 传递函数\n基于 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集合，传递函数如下：\n- $F_{B_{\\mathrm{entry}}}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n- $F_{B_1}(S) = (S \\setminus \\{d_r\\}) \\cup \\{d_u\\}$\n- $F_{B_2}(S) = (S \\setminus \\{d_u\\}) \\cup \\{d_r\\}$\n- $F_{B_3}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n\n### 4. 工作列表算法模拟\n问题指定了一个工作列表求解器，其初始化如下：\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\bot = \\emptyset$。\n- 对于所有其他块 $B \\neq B_{\\mathrm{entry}}$，所有数据流集合（IN 和 OUT）都初始化为 $\\bot = \\emptyset$。\n- 工作列表仅用入口块 $B_{\\mathrm{entry}}$ 进行初始填充：$W = \\{B_{\\mathrm{entry}}\\}$。\n\n让我们追踪算法的执行过程。\n\n**初始状态：**\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\emptyset$, $\\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$\n- $\\mathrm{IN}[B_{1}] = \\emptyset$, $\\mathrm{OUT}[B_{1}] = \\emptyset$\n- $\\mathrm{IN}[B_{2}] = \\emptyset$, $\\mathrm{OUT}[B_{2}] = \\emptyset$\n- $\\mathrm{IN}[B_{3}] = \\emptyset$, $\\mathrm{OUT}[B_{3}] = \\emptyset$\n- $W = \\{B_{\\mathrm{entry}}\\}$\n\n**步骤 1：**\n- 从 $W$ 中弹出 $B_{\\mathrm{entry}}$。（$W = \\emptyset$）\n- $\\mathrm{IN}[B_{\\mathrm{entry}}]$ 是边界条件 $\\emptyset$。\n- 计算新的 $\\mathrm{OUT}[B_{\\mathrm{entry}}]$: $F_{B_{\\mathrm{entry}}}(\\emptyset) = \\emptyset$。\n- $\\mathrm{OUT}[B_{\\mathrm{entry}}]$ 的值并未从其初始值 $\\emptyset$ 发生改变。\n- 算法传播到后继节点。$B_{\\mathrm{entry}}$ 的后继是 $B_2$。\n- 将 $B_2$ 添加到 $W$。（$W = \\{B_2\\}$）\n\n**步骤 2：**\n- 从 $W$ 中弹出 $B_2$。（$W = \\emptyset$）\n- 计算 $\\mathrm{IN}[B_2]$: $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$。\n- 计算新的 $\\mathrm{OUT}[B_2]$: $new\\_OUT = F_{B_2}(\\mathrm{IN}[B_2]) = F_{B_2}(\\emptyset) = (\\emptyset \\setminus \\{d_u\\}) \\cup \\{d_r\\} = \\{d_r\\}$。\n- 当前的 $\\mathrm{OUT}[B_2]$ 是 $\\emptyset$。由于 $new\\_OUT \\neq \\mathrm{OUT}[B_2]$，我们更新：$\\mathrm{OUT}[B_2] := \\{d_r\\}$。\n- $B_2$ 的后继是 $B_3$。\n- 将 $B_3$ 添加到 $W$。（$W = \\{B_3\\}$）\n\n**步骤 3：**\n- 从 $W$ 中弹出 $B_3$。（$W = \\emptyset$）\n- 计算 $\\mathrm{IN}[B_3]$。$B_3$ 的前驱是 $B_1$ 和 $B_2$。\n- $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$。\n- 从初始状态看，$\\mathrm{OUT}[B_1]$ 仍然是 $\\emptyset$。从步骤 2 可知，$\\mathrm{OUT}[B_2]$ 是 $\\{d_r\\}$。\n- $\\mathrm{IN}[B_3] = \\emptyset \\cup \\{d_r\\} = \\{d_r\\}$。\n- 计算新的 $\\mathrm{OUT}[B_3]$: $new\\_OUT = F_{B_3}(\\mathrm{IN}[B_3]) = F_{B_3}(\\{d_r\\}) = \\{d_r\\}$。\n- 当前的 $\\mathrm{OUT}[B_3]$ 是 $\\emptyset$。由于 $new\\_OUT \\neq \\mathrm{OUT}[B_3]$，我们更新：$\\mathrm{OUT}[B_3] := \\{d_r\\}$。\n- 块 $B_3$ 没有后继节点，所以没有块被添加到工作列表。\n\n**终止：**\n- 工作列表 $W$ 现在为空。算法终止。\n\n**最终不动点解：**\n- $\\mathrm{IN}[B_3] = \\{d_r\\}$\n- 这个集合的基数是 $|\\mathrm{IN}[B_3]| = |\\{d_r\\}| = 1$。\n\n### 5. 关于不可达代码的论证\n问题询问为何 $B_1$ 中的不可达循环没有“污染”解，以及为何边界和初始化条件很重要。\n\n指定的工作列表算法开始时，工作列表中只有入口块 $B_{\\mathrm{entry}}$。只有当某个块的 OUT 集合发生变化时，其后继节点才会被添加到工作列表中。由于在 CFG 中没有从 $B_{\\mathrm{entry}}$到 $B_1$ 的路径，所以 $B_1$ 永远不会被添加到工作列表中。\n\n因此，$B_1$ 的数据流集合，特别是 $\\mathrm{OUT}[B_1]$，在整个分析过程中都保持其初始值 $\\bot = \\emptyset$。在计算 $B_3$ 的输入时，汇合运算为 $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$。当 $\\mathrm{OUT}[B_1]=\\emptyset$ 时，该式变为 $\\mathrm{IN}[B_3] = \\emptyset \\cup \\mathrm{OUT}[B_2] = \\mathrm{OUT}[B_2]$。值 $\\emptyset$ 是集合并集算子的单位元，因此来自不可达块 $B_1$ 的贡献对结果没有影响。\n\n初始化方案至关重要。例如，如果使用不同的算法，如一种在每一轮中不考虑可达性而处理所有块的朴素迭代法，结果将不够精确。这种算法会计算出 $\\mathrm{OUT}[B_1]=\\{d_u\\}$ 并将其传播到 $B_3$，从而得到 $\\mathrm{IN}[B_3] = \\{d_u, d_r\\}$。指定的初始化（对于所有 $B \\neq B_{\\mathrm{entry}}$，$\\mathrm{IN}[B] = \\bot$）以及仅从 $B_{\\mathrm{entry}}$ 开始工作列表，确保了分析能考虑到从程序入口点的可达性。这对于路径不敏感分析而言，能够产生可能的最精确解，正确地反映了来自不可达代码的定值无法到达程序可执行部分的任何点。\n\n最终答案是在 $B_3$ 入口处的到达定值集合的基数。根据推导，$\\mathrm{IN}[B_3] = \\{d_r\\}$。定值的数量是 1。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}