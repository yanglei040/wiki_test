{
    "hands_on_practices": [
        {
            "introduction": "理论是指导，但真正的理解源于实践。要设计一个有效的数据流分析，我们不仅要会应用现成的框架，更要能从第一性原理出发，构建自己的抽象域和传递函数。本练习将引导你完成这一过程，你将通过组合两个基础格（符号格与奇偶格）来创建一个更强大的乘积格。通过为一条算术表达式推导其传递函数，你将深入体会抽象释义的核心思想：如何用抽象值安全地近似具体计算。",
            "id": "3635977",
            "problem": "考虑一个前向数据流分析，该分析在每个程序点跟踪每个整型变量的抽象符号和奇偶性。该分析使用一个由符号格和奇偶性格构建的积格，并在分支合并点使用一个汇合算子，该算子是所选偏序关系下的最大下界（meet）。您的任务是：从第一性原理出发推导此积格，为赋值语句 $x := 2y + 1$ 构建转换函数，并分析信息在一个简单控制流图中的流动情况。最终，您需要计算该积格的高度。仅报告此高度作为您的最终答案。\n\n从以下基本原理开始：\n\n1.  该分析使用一个表示符号信息的有限格 $\\mathcal{S}$ 和一个表示奇偶性信息的有限格 $\\mathcal{P}$。每个格元素通过一个具体化函数来抽象一个整数集合。分支合并点的汇合算子是格偏序关系下的最大下界（meet）。\n\n2.  符号格 $\\mathcal{S}$ 抽象以下整数集合：所有整数的集合（元素记为 $\\mathsf{AnyS}$）、负整数（记为 $\\mathsf{Neg}$）、零（记为 $\\mathsf{Zero}$）、正整数（记为 $\\mathsf{Pos}$）以及空集（记为 $\\mathsf{NoneS}$）。具体化函数 $\\gamma_{\\mathcal{S}}$ 将这些元素映射到相应的整数集合。格序 $\\preceq_{\\mathcal{S}}$ 由具体化集合的反向包含关系定义：对于 $a, b \\in \\mathcal{S}$，\n    $$\n    a \\preceq_{\\mathcal{S}} b \\;\\;\\text{当且仅当}\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n    $$\n    因此，$\\mathsf{AnyS}$ 是 $\\mathcal{S}$ 的最小元，$\\mathsf{NoneS}$ 是最大元；元素 $\\mathsf{Neg}$、$\\mathsf{Zero}$ 和 $\\mathsf{Pos}$ 严格位于它们之间且两两不可比。meet 算子 $\\sqcap_{\\mathcal{S}}$ 是关于 $\\preceq_{\\mathcal{S}}$ 的最大下界。\n\n3.  奇偶性格 $\\mathcal{P}$ 抽象以下整数集合：所有整数的集合（元素记为 $\\mathsf{AnyP}$）、偶数（记为 $\\mathsf{Even}$）、奇数（记为 $\\mathsf{Odd}$）以及空集（记为 $\\mathsf{NoneP}$）。具体化函数 $\\gamma_{\\mathcal{P}}$ 和序关系 $\\preceq_{\\mathcal{P}}$ 同样由反向集合包含关系定义：对于 $p, q \\in \\mathcal{P}$，\n    $$\n    p \\preceq_{\\mathcal{P}} q \\;\\;\\text{当且仅当}\\;\\; \\gamma_{\\mathcal{P}}(p) \\supseteq \\gamma_{\\mathcal{P}}(q).\n    $$\n    因此，$\\mathsf{AnyP}$ 是最小元，$\\mathsf{NoneP}$ 是最大元，而 $\\mathsf{Even}$ 和 $\\mathsf{Odd}$ 是它们之间不可比的原子。meet 算子 $\\sqcap_{\\mathcal{P}}$ 是关于 $\\preceq_{\\mathcal{P}}$ 的最大下界。\n\n4.  积格 $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$ 按分量排序：对于 $(s_{1}, p_{1}), (s_{2}, p_{2}) \\in \\mathcal{L}$，\n    $$\n    (s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\text{当且仅当}\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\;\\text{并且}\\;\\; p_{1} \\preceq_{\\mathcal{P}} p_{2}.\n    $$\n    meet 运算 $\\sqcap_{\\mathcal{L}}$ 按分量给出：\n    $$\n    (s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n    $$\n\n给定以下带有一个合并点的线性控制流图，该图使用一个非确定性条件。控制流图 (CFG) 节点如下：\n-   入口节点将 $x$ 和 $y$ 的抽象状态初始化为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n-   然后是一个具有两个后继节点的分支节点：\n    -   分支 $B_{1}$ 赋值 $y := 0$。\n    -   分支 $B_{2}$ 赋值 $y := -1$。\n-   两个分支在节点 $M$ 处合并，该节点赋值 $x := 2y + 1$。\n-   没有更多语句。\n\n您在推理中必须完成以下任务：\n-   使用表达式的抽象解释的基本定义来推导节点 $M$ 处赋值语句 $x := 2y + 1$ 在积格 $\\mathcal{L}$ 上的转换函数 $f_{n}$。您的推导必须根据在抽象符号和奇偶性上进行倍增和加一的算术属性进行明确论证。\n-   使用合并点的汇合算子，从两个前驱节点的事实计算 $M$ 的抽象输入，然后应用 $f_{n}$ 得到在 $M$ 处 $x$ 的抽象输出。\n-   根据积格的结构特性以及上述 $\\mathcal{S}$ 和 $\\mathcal{P}$ 的定义，推导出积格 $\\mathcal{L}$ 的高度 $h_{\\mathcal{L}}$，其中高度是在 $\\preceq_{\\mathcal{L}}$ 下最长严格升链中的元素数量。\n\n仅报告 $h_{\\mathcal{L}}$ 的值作为最终答案。无需四舍五入。无适用单位。",
            "solution": "我们首先精确地形式化抽象域和汇合算子，然后推导 $x := 2y + 1$ 的转换函数，计算在 M 点的合并，最后计算积格的高度。\n\n基础格的基本设置：\n-   符号格 $\\mathcal{S}$ 由元素 $\\{\\mathsf{AnyS}, \\mathsf{Neg}, \\mathsf{Zero}, \\mathsf{Pos}, \\mathsf{NoneS}\\}$ 组成，其具体化函数 $\\gamma_{\\mathcal{S}}$ 定义如下：\n    -   $\\gamma_{\\mathcal{S}}(\\mathsf{AnyS}) = \\mathbb{Z}$，\n    -   $\\gamma_{\\mathcal{S}}(\\mathsf{Neg}) = \\{ n \\in \\mathbb{Z} \\mid n  0 \\}$，\n    -   $\\gamma_{\\mathcal{S}}(\\mathsf{Zero}) = \\{ 0 \\}$，\n    -   $\\gamma_{\\mathcal{S}}(\\mathsf{Pos}) = \\{ n \\in \\mathbb{Z} \\mid n > 0 \\}$，\n    -   $\\gamma_{\\mathcal{S}}(\\mathsf{NoneS}) = \\varnothing$。\n    偏序由集合包含关系的反向关系定义：\n    $$\n    a \\preceq_{\\mathcal{S}} b \\;\\;\\Leftrightarrow\\;\\; \\gamma_{\\mathcal{S}}(a) \\supseteq \\gamma_{\\mathcal{S}}(b).\n    $$\n    因此，$\\mathsf{AnyS}$ 是最小元，$\\mathsf{NoneS}$ 是最大元，三个原子 $\\mathsf{Neg}$、$\\mathsf{Zero}$、$\\mathsf{Pos}$ 严格位于它们之间且两两不可比。meet 算子 $\\sqcap_{\\mathcal{S}}$ 是关于 $\\preceq_{\\mathcal{S}}$ 的最大下界。具体来说，因为 $\\preceq_{\\mathcal{S}}$ 是具体化集合的反向包含关系，所以 $\\sqcap_{\\mathcal{S}}$ 在具体层面上对应于集合并集：\n    $$\n    \\gamma_{\\mathcal{S}}(a \\sqcap_{\\mathcal{S}} b) \\;=\\; \\gamma_{\\mathcal{S}}(a) \\cup \\gamma_{\\mathcal{S}}(b).\n    $$\n    因此，例如 $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Pos} = \\mathsf{AnyS}$ 且 $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Zero} = \\mathsf{AnyS}$，而 $\\mathsf{Neg} \\sqcap_{\\mathcal{S}} \\mathsf{Neg} = \\mathsf{Neg}$。\n\n-   奇偶性格 $\\mathcal{P}$ 由 $\\{\\mathsf{AnyP}, \\mathsf{Even}, \\mathsf{Odd}, \\mathsf{NoneP}\\}$ 组成，其具体化函数 $\\gamma_{\\mathcal{P}}$ 定义如下：\n    -   $\\gamma_{\\mathcal{P}}(\\mathsf{AnyP}) = \\mathbb{Z}$，\n    -   $\\gamma_{\\mathcal{P}}(\\mathsf{Even}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 0 \\pmod{2} \\}$，\n    -   $\\gamma_{\\mathcal{P}}(\\mathsf{Odd}) = \\{ n \\in \\mathbb{Z} \\mid n \\equiv 1 \\pmod{2} \\}$，\n    -   $\\gamma_{\\mathcal{P}}(\\mathsf{NoneP}) = \\varnothing$。\n    序关系为 $\\preceq_{\\mathcal{P}}$，定义与前者相同，为反向包含关系，meet 算子 $\\sqcap_{\\mathcal{P}}$ 满足\n    $$\n    \\gamma_{\\mathcal{P}}(p \\sqcap_{\\mathcal{P}} q) \\;=\\; \\gamma_{\\mathcal{P}}(p) \\cup \\gamma_{\\mathcal{P}}(q).\n    $$\n    因此，$\\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{AnyP}$ 且 $\\mathsf{Odd} \\sqcap_{\\mathcal{P}} \\mathsf{Odd} = \\mathsf{Odd}$。\n\n积格与合流：\n-   积格为 $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$，其序关系 $\\preceq_{\\mathcal{L}}$ 和 meet 算子 $\\sqcap_{\\mathcal{L}}$ 均为逐分量定义：\n    $$\n    (s_{1}, p_{1}) \\preceq_{\\mathcal{L}} (s_{2}, p_{2}) \\;\\;\\Leftrightarrow\\;\\; s_{1} \\preceq_{\\mathcal{S}} s_{2} \\;\\wedge\\; p_{1} \\preceq_{\\mathcal{P}} p_{2},\n    $$\n    $$\n    (s_{1}, p_{1}) \\sqcap_{\\mathcal{L}} (s_{2}, p_{2}) \\;=\\; (\\,s_{1} \\sqcap_{\\mathcal{S}} s_{2},\\; p_{1} \\sqcap_{\\mathcal{P}} p_{2}\\,).\n    $$\n    在分支合并点，我们使用 $\\sqcap_{\\mathcal{L}}$ 作为汇合算子。\n\n$x := 2y + 1$ 的转换函数：\n-   我们分别推导对奇偶性和符号的抽象影响，然后将它们组合起来。\n\n奇偶性分量。对于任何整数 $y$，$2y$ 是偶数，$2y + 1$ 是奇数。因此，无论输入的 $y$ 的奇偶性如何（除了不可达的 $\\mathsf{NoneP}$），$x := 2y+1$ 的奇偶性都确定为 $\\mathsf{Odd}$。形式上，定义 $f^{\\mathcal{P}}_{n} : \\mathcal{P} \\to \\mathcal{P}$ 为\n$$\nf^{\\mathcal{P}}_{n}(p) \\;=\\; \n\\begin{cases}\n\\mathsf{Odd},   \\text{若 } p \\neq \\mathsf{NoneP}, \\\\\n\\mathsf{NoneP},  \\text{若 } p = \\mathsf{NoneP}.\n\\end{cases}\n$$\n\n符号分量。对于任何整数 $y$，$2y + 1 \\neq 0$，因为 $2y$ 是偶数，加 1 后得到一个奇数。如果 $y \\geq 0$，$2y + 1$ 的符号为正；如果 $y \\leq -1$，则为负。在抽象元素上，精确结果取决于输入：\n-   如果 $y$ 恰好为 $\\mathsf{Zero}$，那么 $x = 1$，所以符号是 $\\mathsf{Pos}$。\n-   如果 $y$ 恰好为 $\\mathsf{Pos}$，那么 $2y + 1 \\geq 3$，所以符号是 $\\mathsf{Pos}$。\n-   如果 $y$ 恰好为 $\\mathsf{Neg}$，那么 $2y + 1 \\leq -1$，所以符号是 $\\mathsf{Neg}$。\n-   如果 $y$ 为 $\\mathsf{AnyS}$，那么可能的具体符号集合是 $\\{\\mathsf{Neg}, \\mathsf{Pos}\\}$；由于我们的格中没有专用的 $\\mathsf{NonZero}$ 元素，最精确的可表示的抽象符号是 $\\mathsf{AnyS}$。\n-   如果 $y$ 为 $\\mathsf{NoneS}$，那么输出是 $\\mathsf{NoneS}$。\n\n因此，定义 $f^{\\mathcal{S}}_{n} : \\mathcal{S} \\to \\mathcal{S}$ 为\n$$\nf^{\\mathcal{S}}_{n}(s) \\;=\\;\n\\begin{cases}\n\\mathsf{Pos},   \\text{若 } s \\in \\{ \\mathsf{Zero}, \\mathsf{Pos} \\}, \\\\\n\\mathsf{Neg},   \\text{若 } s = \\mathsf{Neg}, \\\\\n\\mathsf{AnyS},  \\text{若 } s = \\mathsf{AnyS}, \\\\\n\\mathsf{NoneS},  \\text{若 } s = \\mathsf{NoneS}.\n\\end{cases}\n$$\n\n积转换函数。节点 $M$ 赋值 $x := 2y+1$ 并保持 $y$ 不变。因此，在变量 $\\{x,y\\}$ 的环境上，转换函数 $f_{n} : \\mathcal{L}^{\\{x,y\\}} \\to \\mathcal{L}^{\\{x,y\\}}$ 是\n$$\nf_{n}\\big((s_{x}, p_{x}), (s_{y}, p_{y})\\big) \\;=\\; \\Big( \\big(f^{\\mathcal{S}}_{n}(s_{y}),\\, f^{\\mathcal{P}}_{n}(p_{y})\\big),\\; (s_{y}, p_{y}) \\Big),\n$$\n其中第一部分是 $x$ 的新抽象值，第二部分是 $y$ 不变的抽象值。\n\n通过控制流图的流：\n-   入口节点将 $x$ 和 $y$ 初始化为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n-   分支 $B_{1}$ 赋值 $y := 0$，所以在 $B_{1}$ 末尾 $y$ 的抽象事实是 $(\\mathsf{Zero}, \\mathsf{Even})$；$x$ 保持为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n-   分支 $B_{2}$ 赋值 $y := -1$，所以在 $B_{2}$ 末尾 $y$ 的抽象事实是 $(\\mathsf{Neg}, \\mathsf{Odd})$；$x$ 保持为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。\n\n在 $M$ 处的合流逐分量地使用 meet 算子 $\\sqcap_{\\mathcal{L}}$（回想一下，在我们的反向包含序下，该算子对应于取具体化集合的并集）。对于 $M$ 的输入 $y$，我们有\n$$\n(\\mathsf{Zero}, \\mathsf{Even}) \\;\\sqcap_{\\mathcal{L}}\\; (\\mathsf{Neg}, \\mathsf{Odd}) \\;=\\; \\big(\\,\\mathsf{Zero} \\sqcap_{\\mathcal{S}} \\mathsf{Neg},\\; \\mathsf{Even} \\sqcap_{\\mathcal{P}} \\mathsf{Odd}\\,\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{AnyP}).\n$$\n接着在 $M$ 处应用 $f_{n}$，得到 $x$ 的结果为：\n$$\n\\big(f^{\\mathcal{S}}_{n}(\\mathsf{AnyS}),\\; f^{\\mathcal{P}}_{n}(\\mathsf{AnyP})\\big) \\;=\\; (\\mathsf{AnyS}, \\mathsf{Odd}),\n$$\n而 $y$ 保持为 $(\\mathsf{AnyS}, \\mathsf{AnyP})$。这说明联合积抽象捕捉到了 $2y+1$ 保证为奇数的奇偶性，而在此域中符号无法被精化到比 $\\mathsf{AnyS}$ 更精确。\n\n积格的高度：\n-   有限偏序集的高度是最长严格升链中的元素数量。对于 $\\mathcal{S}$，在 $\\preceq_{\\mathcal{S}}$ 下的最长链是\n    $$\n    \\mathsf{AnyS} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{Neg} \\;\\prec_{\\mathcal{S}}\\; \\mathsf{NoneS},\n    $$\n    或者使用 $\\mathsf{Zero}$ 或 $\\mathsf{Pos}$ 作为中间原子也类似。因此 $\\mathcal{S}$ 的高度是\n    $$\n    h_{\\mathcal{S}} \\;=\\; 3.\n    $$\n-   对于 $\\mathcal{P}$，在 $\\preceq_{\\mathcal{P}}$ 下的最长链是\n    $$\n    \\mathsf{AnyP} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{Even} \\;\\prec_{\\mathcal{P}}\\; \\mathsf{NoneP},\n    $$\n    或者以 $\\mathsf{Odd}$ 作为中间原子。因此\n    $$\n    h_{\\mathcal{P}} \\;=\\; 3.\n    $$\n-   对于具有逐分量序的积格 $\\mathcal{L} = \\mathcal{S} \\times \\mathcal{P}$，其高度满足\n    $$\n    h_{\\mathcal{L}} \\;=\\; h_{\\mathcal{S}} \\;+\\; h_{\\mathcal{P}} \\;-\\; 1,\n    $$\n    因为积格中的任何严格升链在每一步都必须至少在一个分量上增加，并且我们可以交错来自 $\\mathcal{S}$ 和 $\\mathcal{P}$ 的最长链，同时注意到它们共享的起始元素。代入这些值可得\n    $$\n    h_{\\mathcal{L}} \\;=\\; 3 \\;+\\; 3 \\;-\\; 1 \\;=\\; 5.\n    $$\n\n因此，积格的高度是 5。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "到达定值分析是编译器中一种典型的“may”分析，用于追踪一个变量的定值（赋值）可能到达程序中的哪些点。这个练习的巧妙之处在于其控制流图中包含了一个不可达的代码块。通过追踪从空集 $⊥$ （代表没有信息）开始的分析过程，你将亲眼见证一个设计良好的工作表算法如何自然地避免了不可达代码的干扰，从而得出精确的分析结果。这揭示了数据流分析算法在处理复杂控制流时的优雅与高效。",
            "id": "3635901",
            "problem": "考虑在控制流图（CFG）上进行的前向数据流分析，其中控制流图（CFG）表示一个基本块的有向图，其边对应于可能的控制转移。给定一个包含四个基本块的程序：$B_{\\mathrm{entry}}$、$B_{1}$、$B_{2}$ 和 $B_{3}$。这些块和边如下所示。\n\n- 块 $B_{\\mathrm{entry}}$：包含单条语句 $y := 0$，然后无条件跳转到 $B_{2}$。\n- 块 $B_{1}$：包含一个永远不会从 $B_{\\mathrm{entry}}$ 接收到控制权的循环（它从 $B_{\\mathrm{entry}}$ 不可达）。其语句是 $x := 7$，然后是一个条件分支，要么跳回 $B_{1}$，要么跳转到 $B_{3}$。因此，$B_{1}$ 有一条自循环边和一条到 $B_{3}$ 的边，但没有任何从 $B_{\\mathrm{entry}}$ 可达的块指向 $B_{1}$ 的入边。\n- 块 $B_{2}$：包含单条语句 $x := 1$，然后无条件跳转到 $B_{3}$。\n- 块 $B_{3}$：包含单条语句 $z := x$。有两条指向 $B_{3}$ 的入边：一条来自 $B_{2}$，一条来自 $B_{1}$。\n\n形式上，边集为 $\\{(B_{\\mathrm{entry}},B_{2}),(B_{1},B_{1}),(B_{1},B_{3}),(B_{2},B_{3})\\}$。\n\n设数据流问题为仅针对单个变量 $x$ 的到达定值分析。定义域由 $x$ 的定值点组成，它们是：\n- $d_{u}$：$B_{1}$ 中的定值 $x := 7$，\n- $d_{r}$：$B_{2}$ 中的定值 $x := 1$。\n\n使用单调框架对有限幂集格进行前向、路径不敏感、“may”分析，仅从核心定义开始（用于“may”分析的格序和交汇运算，块局部的 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集，以及转移函数的标准组合）。假设使用一个标准的工作列表求解器，该求解器：\n- 将 $\\mathrm{IN}[B_{\\mathrm{entry}}]$ 初始化为格的最小元素 $\\bot$，\n- 将所有其他数据流集初始化为 $\\bot$，\n- 仅用 $B_{\\mathrm{entry}}$ 初始化工作列表，然后沿 CFG 边传播，直到达到不动点。\n\n从这些原则推导出数据流方程，并在指定的边界条件下求解它们以达到不动点。特别是，确定在给定边界条件下，求解器在 $B_{3}$ 入口处产生的 $x$ 的不同到达定值的数量（即 $\\mathrm{IN}[B_{3}]$ 对 $x$ 的基数）。作为推理的一部分，请证明当 $\\mathrm{IN}[B_{\\mathrm{entry}}]=\\bot$ 时，为什么 $B_{1}$ 中的不可达循环不会污染 $B_{3}$ 处的解，并解释为什么在存在不可达代码的情况下此边界条件很重要。\n\n只报告最终的数字。不需要四舍五入。",
            "solution": "该问题是有效的，因为它是自洽的，科学上基于编译器理论的原则，并且是客观表述的。我们将进行形式化的求解。\n\n问题要求计算在基本块 $B_{3}$ 入口处变量 $x$ 的到达定值数量。这是一个前向的、“may”数据流分析问题。\n\n### 1. 形式化框架\n- **方向**：前向分析。\n- **$x$ 的定值集合**：$D = \\{d_{u}, d_{r}\\}$，其中 $d_{u}$ 是 $B_1$ 中的 $x := 7$，$d_{r}$ 是 $B_2$ 中的 $x := 1$。\n- **定义域**：格是 $D$ 的幂集，记作 $\\mathcal{P}(D)$。其元素是到达定值的集合。\n- **格的性质**：\n    - 偏序关系是集合包含关系，$\\subseteq$。\n    - 对于“may”分析，交汇运算符 ($\\wedge$) 是集合并集，$\\cup$。这用于控制流图（CFG）中的汇合点。\n    - 底元素是 $\\bot = \\emptyset$，表示没有定值到达。\n    - 顶元素是 $T = D = \\{d_{u}, d_{r}\\}$，表示所有定值都可能到达。\n- **数据流方程**：对于一个基本块 $B$，IN 集和 OUT 集通过以下方式关联：\n$$ \\mathrm{OUT}[B] = F_B(\\mathrm{IN}[B]) $$\n$$ \\mathrm{IN}[B] = \\bigcup_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P] $$\n其中 $\\mathrm{pred}(B)$ 是 $B$ 的前驱节点集合。对于入口块，$\\mathrm{IN}[B_{\\mathrm{entry}}]$ 是一个边界条件。\n\n### 2. GEN 和 KILL 集\n块 $B$ 的转移函数 $F_B$ 是使用其局部效应定义的，由 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集捕获。对于一个输入的定值集合 $S$，输出的定值是 $F_B(S) = (S \\setminus \\mathrm{KILL}_B) \\cup \\mathrm{GEN}_B$。我们针对变量 $x$ 为每个块确定这些集合。\n\n- **块 $B_{\\mathrm{entry}}$**：包含 $y := 0$。这既不定义也不使用 $x$。\n    - $\\mathrm{GEN}[B_{\\mathrm{entry}}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{\\mathrm{entry}}] = \\emptyset$\n\n- **块 $B_{1}$**：包含 $x := 7$ (定值 $d_{u}$)。这个定值会杀死所有其他对 $x$ 的定值。\n    - $\\mathrm{GEN}[B_{1}] = \\{d_u\\}$\n    - $\\mathrm{KILL}[B_{1}] = D \\setminus \\{d_u\\} = \\{d_r\\}$\n\n- **块 $B_{2}$**：包含 $x := 1$ (定值 $d_{r}$)。这个定值会杀死所有其他对 $x$ 的定值。\n    - $\\mathrm{GEN}[B_{2}] = \\{d_r\\}$\n    - $\\mathrm{KILL}[B_{2}] = D \\setminus \\{d_r\\} = \\{d_u\\}$\n\n- **块 $B_{3}$**：包含 $z := x$。这不定义 $x$。\n    - $\\mathrm{GEN}[B_{3}] = \\emptyset$\n    - $\\mathrm{KILL}[B_{3}] = \\emptyset$\n\n### 3. 转移函数\n基于 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集，转移函数如下：\n- $F_{B_{\\mathrm{entry}}}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n- $F_{B_1}(S) = (S \\setminus \\{d_r\\}) \\cup \\{d_u\\}$\n- $F_{B_2}(S) = (S \\setminus \\{d_u\\}) \\cup \\{d_r\\}$\n- $F_{B_3}(S) = (S \\setminus \\emptyset) \\cup \\emptyset = S$\n\n### 4. 工作列表算法模拟\n问题指定了一个工作列表求解器，其初始化如下：\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\bot = \\emptyset$。\n- 对于所有其他块 $B \\neq B_{\\mathrm{entry}}$，所有数据流集（IN 和 OUT）都被初始化为 $\\bot = \\emptyset$。\n- 工作列表仅用入口块初始化：$W = \\{B_{\\mathrm{entry}}\\}$。\n\n让我们追踪算法的执行过程。\n\n**初始状态：**\n- $\\mathrm{IN}[B_{\\mathrm{entry}}] = \\emptyset$, $\\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$\n- $\\mathrm{IN}[B_{1}] = \\emptyset$, $\\mathrm{OUT}[B_{1}] = \\emptyset$\n- $\\mathrm{IN}[B_{2}] = \\emptyset$, $\\mathrm{OUT}[B_{2}] = \\emptyset$\n- $\\mathrm{IN}[B_{3}] = \\emptyset$, $\\mathrm{OUT}[B_{3}] = \\emptyset$\n- $W = \\{B_{\\mathrm{entry}}\\}$\n\n**步骤 1：**\n- 从 $W$ 中弹出 $B_{\\mathrm{entry}}$。（$W = \\emptyset$）\n- $\\mathrm{IN}[B_{\\mathrm{entry}}]$ 是边界条件 $\\emptyset$。\n- 计算新的 $\\mathrm{OUT}[B_{\\mathrm{entry}}]$: $F_{B_{\\mathrm{entry}}}(\\emptyset) = \\emptyset$。\n- $\\mathrm{OUT}[B_{\\mathrm{entry}}]$ 的值并未从其初始值 $\\emptyset$ 改变。\n- 算法传播到后继节点。$B_{\\mathrm{entry}}$ 的后继节点是 $B_2$。\n- 将 $B_2$ 添加到 $W$。（$W = \\{B_2\\}$）\n\n**步骤 2：**\n- 从 $W$ 中弹出 $B_2$。（$W = \\emptyset$）\n- 计算 $\\mathrm{IN}[B_2]$: $\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_{\\mathrm{entry}}] = \\emptyset$。\n- 计算新的 $\\mathrm{OUT}[B_2]$: $new\\_OUT = F_{B_2}(\\mathrm{IN}[B_2]) = F_{B_2}(\\emptyset) = (\\emptyset \\setminus \\{d_u\\}) \\cup \\{d_r\\} = \\{d_r\\}$。\n- 当前的 $\\mathrm{OUT}[B_2]$ 是 $\\emptyset$。由于 $new\\_OUT \\neq \\mathrm{OUT}[B_2]$，我们更新：$\\mathrm{OUT}[B_2] := \\{d_r\\}$。\n- $B_2$ 的后继节点是 $B_3$。\n- 将 $B_3$ 添加到 $W$。（$W = \\{B_3\\}$）\n\n**步骤 3：**\n- 从 $W$ 中弹出 $B_3$。（$W = \\emptyset$）\n- 计算 $\\mathrm{IN}[B_3]$。$B_3$ 的前驱节点是 $B_1$ 和 $B_2$。\n- $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$。\n- 从初始状态看，$\\mathrm{OUT}[B_1]$ 仍然是 $\\emptyset$。从步骤 2 看，$\\mathrm{OUT}[B_2]$ 是 $\\{d_r\\}$。\n- $\\mathrm{IN}[B_3] = \\emptyset \\cup \\{d_r\\} = \\{d_r\\}$。\n- 计算新的 $\\mathrm{OUT}[B_3]$: $new\\_OUT = F_{B_3}(\\mathrm{IN}[B_3]) = F_{B_3}(\\{d_r\\}) = \\{d_r\\}$。\n- 当前的 $\\mathrm{OUT}[B_3]$ 是 $\\emptyset$。由于 $new\\_OUT \\neq \\mathrm{OUT}[B_3]$，我们更新：$\\mathrm{OUT}[B_3] := \\{d_r\\}$。\n- 块 $B_3$ 没有后继节点，因此没有块被添加到工作列表。\n\n**终止：**\n- 工作列表 $W$ 现在为空。算法终止。\n\n**最终不动点解：**\n- $\\mathrm{IN}[B_3] = \\{d_r\\}$\n- 这个集合的基数是 $|\\mathrm{IN}[B_3]| = |\\{d_r\\}| = 1$。\n\n### 5. 关于不可达代码的论证\n问题询问为什么 $B_1$ 中的不可达循环不会“污染”解，以及为什么边界和初始化条件很重要。\n\n指定的工作列表算法开始时，工作列表中只有入口块 $B_{\\mathrm{entry}}$。只有当一个块的 OUT 集发生变化时，它的后继节点才会被添加到工作列表中。由于在 CFG 中没有从 $B_{\\mathrm{entry}}$ 到 $B_1$ 的路径，因此 $B_1$ 永远不会被添加到工作列表中。\n\n因此，$B_1$ 的数据流集，特别是 $\\mathrm{OUT}[B_1]$，在整个分析过程中保持其初始值 $\\bot = \\emptyset$。在计算 $B_3$ 的输入时，汇合操作为 $\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_1] \\cup \\mathrm{OUT}[B_2]$。当 $\\mathrm{OUT}[B_1]=\\emptyset$ 时，这变为 $\\mathrm{IN}[B_3] = \\emptyset \\cup \\mathrm{OUT}[B_2] = \\mathrm{OUT}[B_2]$。值 $\\emptyset$ 是集合并集运算符的单位元，因此来自不可达块 $B_1$ 的贡献对结果没有影响。\n\n初始化方案至关重要。例如，如果使用不同的算法，比如一个简单的迭代方法，在每一轮都处理所有块而不考虑可达性，那么结果将不那么精确。这样的算法会计算出 $\\mathrm{OUT}[B_1]=\\{d_u\\}$ 并将其传播到 $B_3$，从而得到 $\\mathrm{IN}[B_3] = \\{d_u, d_r\\}$。指定的初始化（对于所有 $B \\neq B_{\\mathrm{entry}}$，$\\mathrm{IN}[B] = \\bot$）以及仅从 $B_{\\mathrm{entry}}$ 开始工作列表，确保了分析在从程序入口的可达性方面是路径敏感的。这为路径不敏感分析产生了最精确的可能解，正确地反映了来自不可达代码的定值无法到达程序可执行部分的任何点。\n\n最终答案是在 $B_3$ 入口处的到达定值集合的基数。根据推导，$\\mathrm{IN}[B_3] = \\{d_r\\}$。定值的数量是 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "与“may”分析追踪可能性不同，“must”分析则用于证明确定性，可用表达式分析就是其经典代表。本练习将带你探索“must”分析的工作机制，特别是交汇点处的处理方式（集合交集）以及为何必须从全集 $⊤$ （代表未知或所有可能性）开始迭代。你将分析一个带有不可达前驱节点的场景，并理解为什么 $⊤$ 作为交集的单位元，能够保证来自不可达路径的“无信息”状态不会削弱我们已证明的结论，从而确保分析的可靠性。",
            "id": "3635923",
            "problem": "考虑一个程序片段的控制流图 (CFG)，其节点为 $N_0$ (入口)、$N_1$、$N_2$ 和 $N_3$，有向边为 $N_0 \\rightarrow N_1$、$N_1 \\rightarrow N_3$ 和 $N_2 \\rightarrow N_3$。节点 $N_2$ 没有来自入口 $N_0$ 的入边，因此是不可达的。每个基本块中的语句如下：\n- $N_1$：$t_1 = a + b;$ 接着 $t_2 = a \\ast c;$ 接着 $c = t_2;$ \n- $N_2$：无语句，\n- $N_3$：无语句，\n- $N_0$：无语句 (入口)。\n\n假设数据流问题是可用表达式 (Available Expressions) 的前向 must 分析，定义在程序中所有语法上出现的算术表达式集合的幂集格上，全集为 $\\mathcal{E} = \\{a+b, a\\ast c\\}$。偏序关系是集合包含 $\\subseteq$，控制流汇合处的 meet 算子是集合交集，顶元素是 $\\top = \\mathcal{E}$，底元素是 $\\bot = \\varnothing$。边界条件是 $IN[N_0] = \\varnothing$，并且对于任何除了入口之外没有前驱节点的节点（特别是不可达节点），其 $IN[n]$ 初始化为 $\\top$。\n\n对于可用表达式，每个块的传递函数是\n$$OUT[n] = GEN[n] \\cup \\bigl(IN[n] \\setminus KILL[n]\\bigr),$$\n其中 $GEN[n]$ 包含在 $n$ 中明确求值且之后在 $n$ 中未被杀死的表达式，而 $KILL[n]$ 包含 $\\mathcal{E}$ 中所有提到在 $n$ 中被赋值的变量的表达式。汇合点的汇合方程是\n$$IN[n] = \\bigcap_{p \\in pred(n)} OUT[p].$$\n\n使用这些定义，计算最大不动点处的 $IN[N_3]$，并评估不可达前驱节点 $N_2$ 在汇入 $N_3$ 的连接点处提供 $\\top$ 的影响。\n\n哪个选项是正确的？\n- A. $IN[N_3] = \\{a+b\\}$；不可达前驱节点提供 $\\top$，并且没有影响，因为 $\\top$ 是交集的单位元。\n- B. $IN[N_3] = \\{a+b, a\\ast c\\}$；不可达前驱节点在汇合点处强制为 $\\top$。\n- C. $IN[N_3] = \\varnothing$；由于包含了不可达前驱节点，交集收缩为 $\\bot$。\n- D. $IN[N_3] = \\{a\\ast c\\}$；不可达前驱节点杀死了 $a+b$，只有 $a\\ast c$ 保持可用。",
            "solution": "### 步骤 1：提取已知条件\n\n问题陈述提供了以下信息：\n1.  **控制流图 (CFG)**：\n    -   节点：$N_0$ (入口)、$N_1$、$N_2$、$N_3$。\n    -   边：$N_0 \\rightarrow N_1$、$N_1 \\rightarrow N_3$、$N_2 \\rightarrow N_3$。\n    -   节点 $N_2$ 是不可达的，因为它没有来自入口块 $N_0$ 的入边。实际上，它没有任何入边。\n    -   $pred(N_1) = \\{N_0\\}$\n    -   $pred(N_2) = \\varnothing$\n    -   $pred(N_3) = \\{N_1, N_2\\}$\n\n2.  **基本块语句**：\n    -   $N_1$：$t_1 = a + b$; 接着 $t_2 = a \\ast c$; 接着 $c = t_2$;\n    -   $N_2$：无语句。\n    -   $N_3$：无语句。\n    -   $N_0$：无语句 (入口)。\n\n3.  **数据流分析框架**：\n    -   问题：可用表达式的前向 “must” 分析。\n    -   域：$\\mathcal{E} = \\{a+b, a\\ast c\\}$ 的幂集。\n    -   格：\n        -   偏序：集合包含，$\\subseteq$。\n        -   Meet 算子：集合交集，$\\cap$。\n        -   顶元素：$\\top = \\mathcal{E} = \\{a+b, a\\ast c\\}$。\n        -   底元素：$\\bot = \\varnothing$。\n    -   边界条件：$IN[N_0] = \\varnothing$。\n    -   不可达节点的初始化：对于没有前驱节点的节点 $n$（例如 $N_2$），其 $IN[n]$ 初始化为 $\\top$。\n    -   传递函数：$OUT[n] = GEN[n] \\cup \\bigl(IN[n] \\setminus KILL[n]\\bigr)$。\n    -   汇合方程：$IN[n] = \\bigcap_{p \\in pred(n)} OUT[p]$。\n\n4.  **$GEN$ 和 $KILL$ 集合**：\n    -   $GEN[n]$：在 $n$ 中求值且之后在 $n$ 中未被杀死的表达式。\n    -   $KILL[n]$：$\\mathcal{E}$ 中所有提到在 $n$ 中被赋值的变量的表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了一个编译器理论中的标准数据流分析问题。\n-   **科学依据**：控制流图、基本块、可用表达式分析、数据流方程、格（幂集、$\\cap$、$\\subseteq$）和不动点迭代等概念都是编译器设计领域中的基础且成熟的概念。该设置在科学上和数学上都是合理的。\n-   **适定性**：该问题定义明确。它提供了一个特定的 CFG，一个完整的数据流框架（格、传递函数、边界条件），并要求计算不动点处的一个特定值（$IN[N_3]$）。对于这类问题，标准的数据流分析迭代算法保证收敛到一个唯一最大不动点。\n-   **客观性**：语言精确且技术性强。所有术语如 “must 分析”、“可用表达式”、“GEN/KILL 集合”以及数据流方程本身，在编译器理论的背景下都有标准的、无歧义的定义。\n-   **完整性和一致性**：问题提供了所有必要的信息。对不可达节点 $N_2$ 的处理有明确定义，包括其缺少前驱节点以及其 $IN$ 集合的初始化规则。此规则与数据流分析的一般理论一致，即在一个空前驱节点集合上进行 meet 运算得到的是格的顶元素。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。这是一个在编译器理论中适定的、内部一致的标准问题。我将继续进行求解推导。\n\n### 求解推导\n\n首先，我们必须根据给定的定义确定每个基本块的 $GEN$ 和 $KILL$ 集合。表达式的全集是 $\\mathcal{E} = \\{a+b, a\\ast c\\}$。\n\n-   **块 $N_0$**：无语句。\n    -   $GEN[N_0] = \\varnothing$\n    -   $KILL[N_0] = \\varnothing$\n\n-   **块 $N_1$**：语句是 $t_1 = a + b; t_2 = a \\ast c; c = t_2;$。\n    -   表达式 $a+b$ 被求值。在 $N_1$ 中后续没有赋值语句修改 $a$ 或 $b$。因此，$a+b$ 在该块内被生成且未被杀死。\n    -   表达式 $a\\ast c$ 被求值。然而，在同一个块内，变量 $c$ 随后被赋值 ($c = t_2$)。因此，表达式 $a\\ast c$ 在块的出口处是不可用的。它不在 $GEN[N_1]$ 中。\n    -   $GEN[N_1] = \\{a+b\\}$。\n    -   变量 $c$ 在 $N_1$ 中被赋值。$\\mathcal{E}$ 中任何包含 $c$ 的表达式都会被杀死。表达式 $a\\ast c$ 包含 $c$。\n    -   $KILL[N_1] = \\{a\\ast c\\}$。\n\n-   **块 $N_2$**：无语句。\n    -   $GEN[N_2] = \\varnothing$\n    -   $KILL[N_2] = \\varnothing$\n\n-   **块 $N_3$**：无语句。\n    -   $GEN[N_3] = \\varnothing$\n    -   $KILL[N_3] = \\varnothing$\n\n现在，我们使用标准迭代工作列表算法建立并求解数据流方程，以找到最大不动点。我们求解每个节点的 $IN$ 和 $OUT$ 集合。\n\n**初始化：**\n-   $IN[N_0] = \\varnothing$ (边界条件)\n-   对于前向分析，我们可以将所有其他 $IN$ 集合初始化为顶元素 $\\top$，以开始向最大不动点的迭代。这与为不可达节点指定的规则是一致的。\n-   $IN[N_1] = \\top = \\{a+b, a\\ast c\\}$\n-   $IN[N_2] = \\top = \\{a+b, a\\ast c\\}$\n-   $IN[N_3] = \\top = \\{a+b, a\\ast c\\}$\n-   我们计算初始的 $OUT$ 集合。让我们从 $OUT[n]=\\varnothing$ 开始（除了那些 $IN$ 集合可能改变的节点），然后进行迭代。一个更正式的方法是将除了入口节点之外的所有 OUT 集合初始化为 $\\top$ 并进行迭代。让我们来追踪这些值。\n\n**迭代循环：**\n我们计算这些集合直到它们稳定为止。\n\n1.  **入口节点 $N_0$**：\n    -   $IN[N_0] = \\varnothing$ (固定的)。\n    -   $OUT[N_0] = GEN[N_0] \\cup (IN[N_0] \\setminus KILL[N_0]) = \\varnothing \\cup (\\varnothing \\setminus \\varnothing) = \\varnothing$。\n\n2.  **节点 $N_1$**：\n    -   $IN[N_1] = OUT[N_0] = \\varnothing$。\n    -   $OUT[N_1] = GEN[N_1] \\cup (IN[N_1] \\setminus KILL[N_1]) = \\{a+b\\} \\cup (\\varnothing \\setminus \\{a\\ast c\\}) = \\{a+b\\}$。\n\n3.  **节点 $N_2$** (不可达)：\n    -   节点 $N_2$ 没有前驱节点，$pred(N_2) = \\varnothing$。\n    -   汇合方程是 $IN[N_2] = \\bigcap_{p \\in pred(N_2)} OUT[p] = \\bigcap_{p \\in \\varnothing} OUT[p]$。\n    -   在一个空集上的交集（meet）被定义为格的顶元素。\n    -   因此，$IN[N_2] = \\top = \\{a+b, a\\ast c\\}$。这个值是固定的，在整个迭代过程中不会改变。\n    -   $OUT[N_2] = GEN[N_2] \\cup (IN[N_2] \\setminus KILL[N_2]) = \\varnothing \\cup (\\top \\setminus \\varnothing) = \\top = \\{a+b, a\\ast c\\}$。\n\n4.  **节点 $N_3$** (汇合点)：\n    -   节点 $N_3$ 有前驱节点 $pred(N_3) = \\{N_1, N_2\\}$。\n    -   $IN[N_3] = OUT[N_1] \\cap OUT[N_2]$。\n    -   代入我们为 $OUT[N_1]$ 和 $OUT[N_2]$ 找到的稳定值：\n    -   $IN[N_3] = \\{a+b\\} \\cap \\{a+b, a\\ast c\\} = \\{a+b\\}$。\n\n迭代过程已达到不动点，因为所有 IN/OUT 集合现在都已稳定。$IN[N_3]$ 的最终值是 $\\{a+b\\}$。\n\n**不可达前驱节点影响的分析**：\n不可达前驱节点 $N_2$ 将其 $OUT$ 集合（即 $OUT[N_2] = \\top$）贡献给节点 $N_3$ 的汇合点。汇合操作是交集（$\\cap$）。对于格中的任何集合 $S$，属性 $S \\cap \\top = S$ 成立。在我们的例子中，$S = OUT[N_1]$。因此，$IN[N_3] = OUT[N_1] \\cap \\top = OUT[N_1]$。来自不可达路径的贡献不会改变结果，因为 $\\top$ 是交集算子的单位元。这是“must”分析中的一个普遍原则：来自未访问或不可达路径的悲观假设（由 $\\top$ 表示）不会错误地约束已证实事实的集合。\n\n### 逐项分析选项\n\n-   **A. $IN[N_3] = \\{a+b\\}$；不可达前驱节点提供 $\\top$，并且没有影响，因为 $\\top$ 是交集的单位元。**\n    -   我们的推导得出 $IN[N_3] = \\{a+b\\}$。这是正确的。\n    -   我们的分析表明，不可达前驱节点 $N_2$ 提供 $OUT[N_2] = \\top$。这是正确的。\n    -   关于其没有影响的理由——因为 $\\top$ 是 meet 算子（交集）的单位元——也是正确的。\n    -   **结论：正确。**\n\n-   **B. $IN[N_3] = \\{a+b, a\\ast c\\}$；不可达前驱节点在汇合点处强制为 $\\top$。**\n    -   结果 $IN[N_3] = \\{a+b, a\\ast c\\}$ 是不正确的。如果 meet 算子是并集（$\\cup$），这会是正确的，但对于 “must” 分析，它是交集（$\\cap$）。\n    -   **结论：不正确。**\n\n-   **C. $IN[N_3] = \\varnothing$；由于包含了不可达前驱节点，交集收缩为 $\\bot$。**\n    -   结果 $IN[N_3] = \\varnothing$ 是不正确的。如果不可达前驱节点提供 $\\bot=\\varnothing$，这将会发生。然而，事实恰恰相反；它提供的是 $\\top$。$\\bot$ 是并集的单位元，而不是交集的。对于交集，$\\bot$ 是吸收元（$S \\cap \\bot = \\bot$）。\n    -   **结论：不正确。**\n\n-   **D. $IN[N_3] = \\{a\\ast c\\}$；不可达前驱节点杀死了 $a+b$，只有 $a\\ast c$ 保持可用。**\n    -   结果 $IN[N_3] = \\{a\\ast c\\}$ 是不正确的。\n    -   其理由也是有缺陷的。块 $N_2$ 是空的，因此其 $KILL$ 集合为空（$KILL[N_2] = \\varnothing$）。它不杀死任何表达式。它的输出是 $\\top$，因为它的输入是 $\\top$。\n    -   **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}