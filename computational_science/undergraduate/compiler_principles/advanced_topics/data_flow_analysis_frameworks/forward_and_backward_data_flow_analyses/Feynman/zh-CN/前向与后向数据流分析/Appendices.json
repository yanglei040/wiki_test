{
    "hands_on_practices": [
        {
            "introduction": "数据流分析的核心是为一组方程找到一个不动点。这个练习通过一个极简的控制流图（一个带自循环的基本块），让你能够专注于分析的数学本质，而非复杂的程序结构。通过解析求解这个前向“may”分析的最小不动点 ，你将直观地理解 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集合如何驱动迭代算法达到收敛，并揭示在此特定结构下，最终结果与这些集合的内在关系。",
            "id": "3642676",
            "problem": "考虑一个在控制流图（CFG）上进行的前向、may-style（可能分析）单调数据流分析。该CFG由一个没有入边的唯一入口节点 $E$ 和一个基本块 $B$ 组成，其中有一条从 $E$ 到 $B$ 的边和一条从 $B$ 到自身的自环边。数据流域是某个有限事实全集 $U$ 的有限幂集格 $\\left(\\mathcal{P}(U), \\subseteq \\right)$，其交汇（meet）算子定义为对所有前驱节点的逐点集并集。在唯一入口处的边界条件是 $ \\mathrm{OUT}[E] = \\varnothing$。\n\n基本块 $B$ 的传递函数以前向可能分析的标准 kill/gen 形式指定：\n$$\nf_{B}(S) \\;=\\; \\mathrm{GEN} \\;\\cup\\; \\left(S \\setminus \\mathrm{KILL}\\right),\n$$\n其中 $\\mathrm{GEN} \\subseteq U$ 和 $\\mathrm{KILL} \\subseteq U$ 是与 $B$ 关联的固定集合。\n\n仅使用有限格上的单调框架和不动点的基本定义，建立 $\\mathrm{IN}[B]$ 和 $\\mathrm{OUT}[B]$ 的数据流方程，并推导 $\\mathrm{OUT}[B]$ 的最小不动点解关于 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 的封闭形式解析表达式。你的最终答案必须是单个符号化的封闭形式表达式。不需要数值舍入，也不涉及物理单位。",
            "solution": "用户提供了一个编译器理论领域的问题陈述，具体涉及数据流分析。我将首先验证该问题，如果问题有效，则继续进行求解。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   **分析类型**：前向、可能分析（may-style）、单调数据流分析。\n-   **控制流图 (CFG)**：一个没有入边的唯一入口节点 $E$，一个基本块 $B$，一条从 $E$ 到 $B$ 的边，以及一条从 $B$ 到自身的自环边。\n-   **数据流域**：有限幂集格 $(\\mathcal{P}(U), \\subseteq)$，其中 $U$ 是一个有限的事实全集。\n-   **交汇算子**：对前驱节点的 `OUT` 集进行逐点集并集 ($\\cup$) 操作。\n-   **边界条件**：$\\mathrm{OUT}[E] = \\varnothing$。\n-   **基本块 $B$ 的传递函数**：$f_{B}(S) = \\mathrm{GEN} \\cup (S \\setminus \\mathrm{KILL})$，其中 $\\mathrm{GEN} \\subseteq U$ 和 $\\mathrm{KILL} \\subseteq U$ 是固定集合。\n-   **目标**：推导 $\\mathrm{OUT}[B]$ 的最小不动点解关于 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 的封闭形式解析表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于编译器构造中数据流分析的标准且成熟的理论，这是计算机科学的核心主题。所有定义（单调框架、幂集格、前向分析、kill/gen集）都是标准的。该问题在科学上是合理的。\n-   **适定性**：该问题旨在寻找一个方程组的最小不动点。由于数据流框架定义在有限格上，且传递函数是单调的，根据 Tarski-Knaster 定理，保证存在唯一的最小不动点。该问题是适定的。\n-   **客观性**：语言精确且正式。所用术语在编译器理论的背景下具有明确的含义。该问题是客观的。\n-   **完整性**：该问题提供了所有必要信息：CFG结构、域、交汇算子、边界条件以及传递函数的形式。它是自包含的，没有欠定。\n\n**步骤3：结论与行动**\n该问题是有效的，因为它是一个标准的、适定的、自包含的数据流分析练习。我现在将进行求解。\n\n### 求解推导\n\n问题要求我们找到 $\\mathrm{OUT}[B]$ 的最小不动点解。我们首先根据问题描述建立数据流方程。\n\n该分析是**前向**分析，因此一个基本块入口处的状态（$\\mathrm{IN}$）由其所有前驱节点出口处的状态（$\\mathrm{OUT}$）决定。此**可能**（may）分析的交汇算子是集合并集（$\\cup$）。\n\n基本块 $B$ 有两个前驱节点：入口节点 $E$ 和块 $B$ 本身（由于自环）。因此，$\\mathrm{IN}[B]$ 的数据流方程为：\n$$\n\\mathrm{IN}[B] = \\mathrm{OUT}[E] \\cup \\mathrm{OUT}[B]\n$$\n\n问题给出了边界条件 $\\mathrm{OUT}[E] = \\varnothing$。将其代入 $\\mathrm{IN}[B]$ 的方程，得到：\n$$\n\\mathrm{IN}[B] = \\varnothing \\cup \\mathrm{OUT}[B] = \\mathrm{OUT}[B]\n$$\n\n出口状态 $\\mathrm{OUT}[B]$ 是通过将传递函数 $f_B$ 应用于入口状态 $\\mathrm{IN}[B]$ 来确定的：\n$$\n\\mathrm{OUT}[B] = f_B(\\mathrm{IN}[B])\n$$\n传递函数给定为 $f_B(S) = \\mathrm{GEN} \\cup (S \\setminus \\mathrm{KILL})$。因此：\n$$\n\\mathrm{OUT}[B] = \\mathrm{GEN} \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL})\n$$\n\n我们现在有一个包含两个方程的系统。通过将 $\\mathrm{IN}[B] = \\mathrm{OUT}[B]$ 代入第二个方程，我们得到了一个关于 $\\mathrm{OUT}[B]$ 的单一不动点方程。为简化表示，令 $X = \\mathrm{OUT}[B]$：\n$$\nX = \\mathrm{GEN} \\cup (X \\setminus \\mathrm{KILL})\n$$\n\n我们需要在格 $(\\mathcal{P}(U), \\subseteq)$ 中找到 $X$ 的最小解。单调框架理论保证，最小不动点可以通过从格的底元素开始，迭代应用函数来找到。在幂集格 $(\\mathcal{P}(U), \\subseteq)$ 中，底元素是空集 $\\varnothing$。\n\n令 $X_k$ 表示第 $k$ 次迭代的解的近似值。迭代过程定义如下：\n-   $X_0 = \\varnothing$ （初始化）。\n-   $X_{k+1} = \\mathrm{GEN} \\cup (X_k \\setminus \\mathrm{KILL})$。\n\n让我们执行迭代：\n\n**第1次迭代 ($k=0$):**\n$$\nX_1 = \\mathrm{GEN} \\cup (X_0 \\setminus \\mathrm{KILL}) = \\mathrm{GEN} \\cup (\\varnothing \\setminus \\mathrm{KILL}) = \\mathrm{GEN} \\cup \\varnothing = \\mathrm{GEN}\n$$\n因此，在第一次迭代之后，解为 $X_1 = \\mathrm{GEN}$。\n\n**第2次迭代 ($k=1$):**\n$$\nX_2 = \\mathrm{GEN} \\cup (X_1 \\setminus \\mathrm{KILL}) = \\mathrm{GEN} \\cup (\\mathrm{GEN} \\setminus \\mathrm{KILL})\n$$\n为了简化此表达式，我们使用集合的一个基本性质。对于任意两个集合 $A$ 和 $B$，差集 $A \\setminus B$ 是 $A$ 的一个子集，即 $(A \\setminus B) \\subseteq A$。一个集合与其任何子集的并集是该集合本身。因此，$A \\cup (A \\setminus B) = A$。\n将此性质应用于 $A = \\mathrm{GEN}$ 和 $B = \\mathrm{KILL}$，我们得到：\n$$\n\\mathrm{GEN} \\cup (\\mathrm{GEN} \\setminus \\mathrm{KILL}) = \\mathrm{GEN}\n$$\n因此，第二次迭代的结果是：\n$$\nX_2 = \\mathrm{GEN}\n$$\n\n由于 $X_2 = X_1$，迭代过程已达到不动点。因为我们从底元素 $\\varnothing$ 开始，并且传递函数是单调的，所以这个不动点是最小不动点。\n\n$\\mathrm{OUT}[B]$ 的最小不动点解的封闭形式解析表达式就是 $\\mathrm{GEN}$。在这个特定的CFG配置中，集合 $\\mathrm{KILL}$ 对最终的稳定结果没有影响，因为任何将被杀死的（killed）事实都必须是在前一步由 $\\mathrm{GEN}$ 生成的，而 $\\mathrm{GEN}$ 会在当前步骤中重新添加它。",
            "answer": "$$\\boxed{\\mathrm{GEN}}$$"
        },
        {
            "introduction": "理论必须应用于实践。真实世界的代码充满了像带有“贯穿”（fall-through）特性的 `switch` 语句这样的复杂控制流结构。这个练习  要求你将一段包含 `switch`、`fall-through` 和 `break` 的代码转换成控制流图（CFG），并精确地执行前向到达定值分析。通过这个练习，你将掌握处理复杂程序结构和追踪变量定义在程序中传播路径的核心技能。",
            "id": "3642723",
            "problem": "考虑以下直线型伪代码，它包含一个使用 $switch$ 语句和显式贯穿（fall-through）语义的多路分支。每个编号标签 $n_i$ 表示一个含单条语句的程序点，但 $n_3$ 除外，它是 $switch$ 的分派点。程序如下：\n\n$n_1$: $a \\leftarrow 0$\n\n$n_2$: $b \\leftarrow 0$\n\n$n_3$: 基于 $t$ 进行 switch，情况如下：\n- 情况 $0$：\n  $n_4$: $a \\leftarrow 1$\n  (贯穿到情况 $1$)\n- 情况 $1$：\n  $n_5$: $b \\leftarrow a + 2$\n  中断并跳转到 switch 之后\n- 情况 $2$：\n  $n_6$: $c \\leftarrow b + 3$\n  (贯穿到情况 $3$)\n- 情况 $3$：\n  $n_7$: $a \\leftarrow c + 4$\n  (贯穿到默认情况)\n- 默认情况：\n  $n_8$: $b \\leftarrow a + b$\n\n$n_9$: $d \\leftarrow a + b$\n\n为该程序建立控制流图（CFG）模型。其中，$n_3$ 拥有指向每个匹配情况（case）的第一条语句的出边，以及在没有情况匹配时指向默认（default）情况的出边；在没有 $break$ 的情况下，贯穿（fall-through）会创建一条从一个情况主体的最后一条语句到下一个情况主体的第一条语句的边。$n_5$ 处的显式 $break$ 会将控制权转移到 $n_9$（紧跟在 $switch$ 之后的点）。\n\n使用标准的、在 CFG 边上进行的前向“可能到达定义”（May-Reaching-Definitions）分析。将每个赋值与一个唯一定义标识符关联如下：\n- $d_1$ 在 $n_1$ 处定义 $a$，\n- $d_2$ 在 $n_2$ 处定义 $b$，\n- $d_3$ 在 $n_4$ 处定义 $a$，\n- $d_4$ 在 $n_5$ 处定义 $b$，\n- $d_5$ 在 $n_6$ 处定义 $c$，\n- $d_6$ 在 $n_7$ 处定义 $a$，\n- $d_7$ 在 $n_8$ 处定义 $b$，\n- $d_8$ 在 $n_9$ 处定义 $d$。\n\n对于每条 CFG 边 $(n_i \\rightarrow n_j)$，根据以下语义建立基于边（edge-based）的前向 $GEN(n_i \\rightarrow n_j)$ 和 $KILL(n_i \\rightarrow n_j)$ 集合：\n- 如果 $n_i$ 包含某个变量 $x$ 的定义，则 $GEN(n_i \\rightarrow n_j) = \\{d_k\\}$，其中 $d_k$ 是 $n_i$ 处定义的唯一标识符，而 $KILL(n_i \\rightarrow n_j)$ 是该过程中所有其他对 $x$ 的定义的集合（即除 $d_k$ 外所有对 $x$ 的定义）。\n- 如果 $n_i$ 不包含定义，则 $GEN(n_i \\rightarrow n_j) = \\varnothing$ 且 $KILL(n_i \\rightarrow n_j) = \\varnothing$。\n\n然后，使用这些基于边的 $GEN$/$KILL$ 集合和标准的、以并集为汇合（meet）运算符的前向“可能到达定义”数据流方程，确定可能到达 $n_9$ 之前程序点的不同定义的数量。将最终答案报告为等于 $RD_{\\text{in}}(n_9)$ 基数的单个整数，其中 $RD_{\\text{in}}(n_9)$ 表示所有能够沿着遵循 $switch$ 和贯穿语义的某条 CFG 路径到达 $n_9$ 之前那个点的定义标识符的集合。答案必须是一个实数。无需四舍五入。",
            "solution": "该问题提法明确，科学上基于编译器理论的原理，且内容客观。它为给定伪代码片段上的前向“可能到达定义”分析提供了完整的规范。所有构建控制流图（CFG）、定义分析集以及应用数据流方程的必要规则都得到了明确陈述且内部一致。因此，该问题是有效的，并且可以推导出解决方案。\n\n第一步是根据所提供的伪代码和分支规则，为程序建立控制流图（CFG）模型。图的节点是编号从 $n_1$ 到 $n_9$ 的程序点。边由控制流决定：\n*   顺序流：$(n_1 \\rightarrow n_2)$, $(n_2 \\rightarrow n_3)$。\n*   从 $n_3$ 的 $switch$ 分派：问题陈述 $n_3$ 有指向每个情况的第一条语句和默认情况的出边。这给出了边 $(n_3 \\rightarrow n_4)$、$(n_3 \\rightarrow n_5)$、$(n_3 \\rightarrow n_6)$、$(n_3 \\rightarrow n_7)$ 和 $(n_3 \\rightarrow n_8)$。\n*   贯穿（Fall-through）：情况 0 贯穿到情况 1，创建边 $(n_4 \\rightarrow n_5)$。情况 2 贯穿到情况 3，创建边 $(n_6 \\rightarrow n_7)$。情况 3 贯穿到默认情况，创建边 $(n_7 \\rightarrow n_8)$。\n*   $break$：$n_5$ 处的 $break$ 将控制转移到 switch 语句之后的点，即 $n_9$。这创建了边 $(n_5 \\rightarrow n_9)$。\n*   switch 结束：在 $n_8$ 的默认情况主体执行后，控制流向下一条语句 $n_9$。这创建了边 $(n_8 \\rightarrow n_9)$。\n所以，目标节点 $n_9$ 的前驱节点是 $n_5$ 和 $n_8$。\n\n接下来，我们建立定义和 $GEN/KILL$ 集合。问题分配了唯一定义标识符 $d_1, \\dots, d_8$。我们首先按定义的变量对这些定义进行分组：\n*   变量 $a$：$Defs(a) = \\{d_1, d_3, d_6\\}$\n*   变量 $b$：$Defs(b) = \\{d_2, d_4, d_7\\}$\n*   变量 $c$：$Defs(c) = \\{d_5\\}$\n*   变量 $d$：$Defs(d) = \\{d_8\\}$\n\n问题为 $GEN$ 和 $KILL$ 集合指定了基于边的公式。对于一条边 $(n_i \\rightarrow n_j)$：\n*   如果 $n_i$ 包含变量 $x$ 的定义 $d_k$，则 $GEN(n_i \\rightarrow n_j) = \\{d_k\\}$ 且 $KILL(n_i \\rightarrow n_j) = Defs(x) \\setminus \\{d_k\\}$。\n*   如果 $n_i$ 不包含定义，则 $GEN(n_i \\rightarrow n_j) = \\varnothing$ 且 $KILL(n_i \\rightarrow n_j) = \\varnothing$。\n基于此，对于源于带定义节点的边，其 $GEN/KILL$ 集合如下：\n*   $n_1: a \\leftarrow 0$。对于边 $(n_1 \\rightarrow n_2)$，$GEN = \\{d_1\\}$，$KILL = \\{d_3, d_6\\}$。\n*   $n_2: b \\leftarrow 0$。对于边 $(n_2 \\rightarrow n_3)$，$GEN = \\{d_2\\}$，$KILL = \\{d_4, d_7\\}$。\n*   $n_4: a \\leftarrow 1$。对于边 $(n_4 \\rightarrow n_5)$，$GEN = \\{d_3\\}$，$KILL = \\{d_1, d_6\\}$。\n*   $n_5: b \\leftarrow a + 2$。对于边 $(n_5 \\rightarrow n_9)$，$GEN = \\{d_4\\}$，$KILL = \\{d_2, d_7\\}$。\n*   $n_6: c \\leftarrow b + 3$。对于边 $(n_6 \\rightarrow n_7)$，$GEN = \\{d_5\\}$，$KILL = \\varnothing$。\n*   $n_7: a \\leftarrow c + 4$。对于边 $(n_7 \\rightarrow n_8)$，$GEN = \\{d_6\\}$，$KILL = \\{d_1, d_3\\}$。\n*   $n_8: b \\leftarrow a + b$。对于边 $(n_8 \\rightarrow n_9)$，$GEN = \\{d_7\\}$，$KILL = \\{d_2, d_4\\}$。\n对于节点 $n_3$，它没有定义，其所有出边的 $GEN=\\varnothing$ 和 $KILL=\\varnothing$。\n\n到达定义（Reaching Definitions, RD）分析是一种前向“可能”（may）分析，因此汇合运算符是集合并集（$\\cup$）。数据流方程为：\n$$RD_{in}(n_j) = \\bigcup_{(n_i, n_j) \\in Edges} RD_{edge}(n_i \\rightarrow n_j)$$\n$$RD_{edge}(n_i \\rightarrow n_j) = (RD_{in}(n_i) \\setminus KILL(n_i \\rightarrow n_j)) \\cup GEN(n_i \\rightarrow n_j)$$\n我们初始化 $RD_{in}(n_1) = \\varnothing$ 以及所有其他节点 $k$ 的 $RD_{in}(n_k) = \\varnothing$。我们进行迭代直到集合收敛。\n\n**迭代 1：**\n1.  $RD_{in}(n_1) = \\varnothing$。\n2.  $RD_{edge}(n_1 \\rightarrow n_2) = (RD_{in}(n_1) \\setminus \\{d_3, d_6\\}) \\cup \\{d_1\\} = \\{d_1\\}$。\n3.  $RD_{in}(n_2) = RD_{edge}(n_1 \\rightarrow n_2) = \\{d_1\\}$。\n4.  $RD_{edge}(n_2 \\rightarrow n_3) = (RD_{in}(n_2) \\setminus \\{d_4, d_7\\}) \\cup \\{d_2\\} = (\\{d_1\\} \\setminus \\{d_4, d_7\\}) \\cup \\{d_2\\} = \\{d_1, d_2\\}$。\n5.  $RD_{in}(n_3) = RD_{edge}(n_2 \\rightarrow n_3) = \\{d_1, d_2\\}$。\n6.  对于所有边 $(n_3 \\rightarrow n_j)$，$RD_{edge}(n_3 \\rightarrow n_j) = (RD_{in}(n_3) \\setminus \\varnothing) \\cup \\varnothing = \\{d_1, d_2\\}$。\n7.  $RD_{in}(n_4) = RD_{edge}(n_3 \\rightarrow n_4) = \\{d_1, d_2\\}$。\n8.  $RD_{edge}(n_4 \\rightarrow n_5) = (RD_{in}(n_4) \\setminus \\{d_1, d_6\\}) \\cup \\{d_3\\} = (\\{d_1, d_2\\} \\setminus \\{d_1, d_6\\}) \\cup \\{d_3\\} = \\{d_2, d_3\\}$。\n9.  $RD_{in}(n_5) = RD_{edge}(n_3 \\rightarrow n_5) \\cup RD_{edge}(n_4 \\rightarrow n_5) = \\{d_1, d_2\\} \\cup \\{d_2, d_3\\} = \\{d_1, d_2, d_3\\}$。\n10. $RD_{in}(n_6) = RD_{edge}(n_3 \\rightarrow n_6) = \\{d_1, d_2\\}$。\n11. $RD_{edge}(n_6 \\rightarrow n_7) = (RD_{in}(n_6) \\setminus \\varnothing) \\cup \\{d_5\\} = \\{d_1, d_2, d_5\\}$。\n12. $RD_{in}(n_7) = RD_{edge}(n_3 \\rightarrow n_7) \\cup RD_{edge}(n_6 \\rightarrow n_7) = \\{d_1, d_2\\} \\cup \\{d_1, d_2, d_5\\} = \\{d_1, d_2, d_5\\}$。\n13. $RD_{edge}(n_7 \\rightarrow n_8) = (RD_{in}(n_7) \\setminus \\{d_1, d_3\\}) \\cup \\{d_6\\} = (\\{d_1, d_2, d_5\\} \\setminus \\{d_1, d_3\\}) \\cup \\{d_6\\} = \\{d_2, d_5, d_6\\}$。\n14. $RD_{in}(n_8) = RD_{edge}(n_3 \\rightarrow n_8) \\cup RD_{edge}(n_7 \\rightarrow n_8) = \\{d_1, d_2\\} \\cup \\{d_2, d_5, d_6\\} = \\{d_1, d_2, d_5, d_6\\}$。\n15. 最后，我们计算到 $n_9$ 的输入：\n    *   $RD_{edge}(n_5 \\rightarrow n_9) = (RD_{in}(n_5) \\setminus \\{d_2, d_7\\}) \\cup \\{d_4\\} = (\\{d_1, d_2, d_3\\} \\setminus \\{d_2, d_7\\}) \\cup \\{d_4\\} = \\{d_1, d_3, d_4\\}$。\n    *   $RD_{edge}(n_8 \\rightarrow n_9) = (RD_{in}(n_8) \\setminus \\{d_2, d_4\\}) \\cup \\{d_7\\} = (\\{d_1, d_2, d_5, d_6\\} \\setminus \\{d_2, d_4\\}) \\cup \\{d_7\\} = \\{d_1, d_5, d_6, d_7\\}$。\n16. $RD_{in}(n_9) = RD_{edge}(n_5 \\rightarrow n_9) \\cup RD_{edge}(n_8 \\rightarrow n_9) = \\{d_1, d_3, d_4\\} \\cup \\{d_1, d_5, d_6, d_7\\} = \\{d_1, d_3, d_4, d_5, d_6, d_7\\}$。\n\n**迭代 2：**\n必须进行第二次迭代以检查是否收敛。\n$n_1, \\dots, n_8$ 的 $RD_{in}$ 集合使用迭代 1 的值重新计算。\n1.  $RD_{in}(n_2)$ 依赖于 $RD_{in}(n_1)=\\varnothing$，无变化。\n2.  $RD_{in}(n_3)$ 依赖于 $RD_{in}(n_2)$，无变化。\n3.  $RD_{in}(n_4)$ 依赖于 $RD_{in}(n_3)$，无变化。\n4.  $RD_{in}(n_5)$ 依赖于 $RD_{in}(n_3)$ 和 $RD_{in}(n_4)$，无变化。\n5.  $RD_{in}(n_6)$ 依赖于 $RD_{in}(n_3)$，无变化。\n6.  $RD_{in}(n_7)$ 依赖于 $RD_{in}(n_3)$ 和 $RD_{in}(n_6)$，无变化。\n7.  $RD_{in}(n_8)$ 依赖于 $RD_{in}(n_3)$ 和 $RD_{in}(n_7)$，无变化。\n由于从 $n_1$ 到 $n_8$ 的任何节点的 $RD_{in}$ 集合都没有改变，用于计算 $RD_{in}(n_9)$ 的输入也未改变。因此，算法已经收敛。\n\n可能到达 $n_9$ 之前程序点的定义集合是：\n$$RD_{in}(n_9) = \\{d_1, d_3, d_4, d_5, d_6, d_7\\}$$\n问题要求的是这个集合中不同定义的数量，也就是它的基数。\n$$|RD_{in}(n_9)| = |\\{d_1, d_3, d_4, d_5, d_6, d_7\\}| = 6$$\n可以到达此点的定义有：\n*   $d_1$：$a$ 的初始定义。通过不经过 $n_4$ 或 $n_7$ 的路径到达（例如，当 $t=1$ 时的路径）。\n*   $d_3$：情况 0 中对 $a$ 的定义。通过当 $t=0$ 时的路径到达。\n*   $d_4$：情况 1 中对 $b$ 的定义。通过当 $t=0$ 或 $t=1$ 时的路径到达。\n*   $d_5$：情况 2 中对 $c$ 的定义。通过当 $t=2$ 时的路径到达。\n*   $d_6$：情况 3 中对 $a$ 的定义。通过当 $t=2$ 或 $t=3$ 时的路径到达。\n*   $d_7$：默认情况中对 $b$ 的定义。通过当 $t=2$、$t=3$ 或默认情况时的路径到达。\n唯一没有到达的定义是 $d_2$（$b$ 的初始定义），因为每条到 $n_9$ 的路径都包含对 $b$ 的后续重定义（$d_4$ 或 $d_7$）。定义 $d_8$ 在 $n_9$ 处生成，因此它不在 $RD_{in}(n_9)$ 中。\n\n不同定义的总数是 6。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "得到数据流分析的正确解是一回事，高效地得到解则是另一回事。本练习将你的注意力从“解是什么”转移到“如何高效地求解”。通过对一个后向活性变量分析实例，比较两种不同的工作列表策略（FIFO 与逆后序）的收敛速度 ，你将深入理解算法效率、数据流方向和节点处理顺序之间的内在联系。这对于设计和实现高性能的静态分析工具至关重要。",
            "id": "3642671",
            "problem": "考虑一个在控制流图（CFG）上进行的后向数据流分析实例——活性分析。目标是比较两种工作列表策略，并量化它们在求解活性方程时对收敛速度的影响。\n\n使用以下内容作为基本依据：\n- 对于每个基本块 $n$，后向活性传递方程为\n$$\\mathrm{OUT}[n] \\;=\\; \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{IN}[s], \\qquad \\mathrm{IN}[n] \\;=\\; \\mathrm{USE}[n] \\;\\cup\\; \\left(\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]\\right).$$\n- 格是变量的有限幂集，按集合包含关系排序，其交运算等于集合并集，底元素等于 $\\emptyset$。\n- 对所有块 $n$，初始化 $\\mathrm{IN}[n] \\leftarrow \\emptyset$ 和 $\\mathrm{OUT}[n] \\leftarrow \\emptyset$。\n- 工作列表算法维护一个基于集合的工作列表，该列表从不包含重复的块。初始时，将所有块插入工作列表。当工作列表非空时，根据所选策略移除一个块 $n$，根据其后继的当前 $\\mathrm{IN}$ 值重新计算 $\\mathrm{OUT}[n]$，然后重新计算 $\\mathrm{IN}[n]$。如果 $\\mathrm{IN}[n]$ 发生变化，则将 $n$ 的所有当前不在工作列表中的前驱插入。不要因为 $n$ 自身的变化而将其重新插入。每次从工作列表中移除一个块计为一个处理步骤。\n\nCFG 包含块 $B_1, B_2, B_3, B_4, B_5$，其后继为\n- $\\mathrm{succ}(B_1) = \\{B_2, B_3\\}$,\n- $\\mathrm{succ}(B_2) = \\{B_4\\}$,\n- $\\mathrm{succ}(B_3) = \\{B_4\\}$,\n- $\\mathrm{succ}(B_4) = \\{B_2, B_5\\}$,\n- $\\mathrm{succ}(B_5) = \\varnothing$,\n其在变量 $\\{a,b\\}$ 上的 $\\mathrm{USE}/\\mathrm{DEF}$ 集合为\n- $B_1$: $\\mathrm{USE} = \\varnothing$, $\\mathrm{DEF} = \\{a\\}$,\n- $B_2$: $\\mathrm{USE} = \\{a\\}$, $\\mathrm{DEF} = \\{b\\}$,\n- $B_3$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\varnothing$,\n- $B_4$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\{a\\}$,\n- $B_5$: $\\mathrm{USE} = \\varnothing$, $\\mathrm{DEF} = \\varnothing$.\n\n比较以下两种工作列表移除策略：\n- 先入先出 (FIFO)：使用一个队列，初始顺序为 $B_1, B_2, B_3, B_4, B_5$，从队首移除，并按块索引递增的顺序将新添加的前驱追加到队尾。\n- 按逆后序 (RPO) 的优先级：从 $B_1$ 开始对前向 CFG 进行深度优先搜索，按块索引递增的顺序访问后继，根据完成时间分配后序编号，并令逆后序为递减的后序序列。维护一个以在此逆后序序列中的位置为键的优先级工作列表；每一步移除位置最小（在 RPO 中最早）的块。任意但确定性地解决平局；不允许工作列表中出现重复项。\n\n任务：\n1. 仅根据后向活性的基本性质，定性预测这两种策略中哪一种可能在此 CFG 上产生更少的处理步骤，并说明你的预测理由。\n2. 然后，通过在两种策略下执行指定的工作列表算法直至收敛来进行经验性验证。设 $C_{\\mathrm{FIFO}}$ 为 FIFO 策略下的总块移除次数，$C_{\\mathrm{RPO}}$ 为 RPO 策略下的总次数。报告单个数值 $C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}}$。\n\n你的最终答案必须是 $C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}}$ 的精确值，作为一个实数。不需要四舍五入。",
            "solution": "该问题要求进行定性预测和经验性计算，以比较两种工作列表策略（FIFO 和 RPO）在后向活性分析中的效率。\n\n### 第 1 部分：定性预测\n\n数据流分析问题的特点是信息流动的方向。在后向分析（如活性分析）中，一个基本块 $n$ 入口处的数据流事实（即 $\\mathrm{IN}[n]$）依赖于该块出口处的事实（$\\mathrm{OUT}[n]$），而后者又依赖于其后继入口处的事实（对于 $s \\in \\mathrm{succ}(n)$ 的 $\\mathrm{IN}[s]$）。因此，信息从后继“向后”传播到前驱，与控制流的方向相反。\n\n一个高效的工作列表算法会以与数据流方向一致的顺序处理块，从而最大限度地减少因其依赖项变化而必须重新处理一个块的次数。对于后向分析，这意味着理想的处理顺序是在处理完一个块的所有后继并且它们的数据流信息稳定之后，再处理该块。因此，一个近似于控制流图（CFG）逆拓扑排序的顺序是理想的。前向 CFG 的后序遍历提供了这样一种排序。\n\n问题指定了两种策略：\n1.  **先入先出 (FIFO)**：此策略不强加任何基于结构信息的顺序。其效率取决于队列中块的初始排列以及 CFG 的具体结构。它本身并未针对前向或后向分析进行优化。\n2.  **逆后序 (RPO)**：前向 CFG 的逆后序是众所周知的对*前向*数据流分析非常有效的启发式方法。它倾向于以拓扑排序的顺序访问节点，确保在处理一个块时，其前驱的数据流信息很可能是最新的。\n\n当 RPO 策略应用于*后向*分析时，它会系统性地产生反效果。通过以前向流高效的顺序处理块，它内在的就以后向流低效的顺序处理它们。一个块 $n$ 很可能在其后继 $s \\in \\mathrm{succ}(n)$ 之前被处理，而它需要从这些后继获取信息来计算其 $\\mathrm{OUT}[n]$ 集合。这导致初始计算基于不完整的信息（例如，在处理 $s$ 之前使用 $\\mathrm{IN}[s] = \\emptyset$），这迫使 $n$ 被重新添加回工作列表，并在其后继的信息可用时稍后被重新处理。这种处理顺序和数据流方向之间的系统性错位预计将导致更多的块处理步骤。\n\nFIFO 策略没有表现出这种与数据流方向的系统性对立。虽然不是最优的，但其较少结构化的特性使其不太可能成为最差的。因此，预测对于此后向分析，RPO 策略的效率将低于 FIFO。这意味着 RPO 的总块移除次数 $C_{\\mathrm{RPO}}$ 将大于 FIFO 的总块移除次数 $C_{\\mathrm{FIFO}}$。\n\n### 第 2 部分：经验性验证\n\n我们现在将追踪两种策略下工作列表算法的执行过程，以确定确切的处理步骤数。状态由每个块的 $\\mathrm{IN}$ 集合定义，记为 $I_1, \\dots, I_5$。初始时，所有 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合均为 $\\emptyset$。\n\n数据流方程为：\n$\\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{IN}[s]$\n$\\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup (\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n])$\n\n相关集合为：\n- $B_1$: $\\mathrm{USE} = \\emptyset$, $\\mathrm{DEF} = \\{a\\}$\n- $B_2$: $\\mathrm{USE} = \\{a\\}$, $\\mathrm{DEF} = \\{b\\}$\n- $B_3$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\emptyset$\n- $B_4$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\{a\\}$\n- $B_5$: $\\mathrm{USE} = \\emptyset$, $\\mathrm{DEF} = \\emptyset$\n\n前驱为：\n- $\\mathrm{pred}(B_1) = \\emptyset$\n- $\\mathrm{pred}(B_2) = \\{B_1, B_4\\}$\n- $\\mathrm{pred}(B_3) = \\{B_1\\}$\n- $\\mathrm{pred}(B_4) = \\{B_2, B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_4\\}$\n\n#### FIFO 策略执行过程\n\n初始工作列表是一个队列 $W = [B_1, B_2, B_3, B_4, B_5]$。步骤计数器 $C_{\\mathrm{FIFO}}$ 初始化为 $0$。\n\n1.  **步骤 1**：移除 $B_1$。$C_{\\mathrm{FIFO}}=1$。$O_1 = I_2 \\cup I_3 = \\emptyset$。$I_1' = \\emptyset \\cup (\\emptyset \\setminus \\{a\\}) = \\emptyset$。$I_1$ 未变。$W = [B_2, B_3, B_4, B_5]$。\n2.  **步骤 2**：移除 $B_2$。$C_{\\mathrm{FIFO}}=2$。$O_2 = I_4 = \\emptyset$。$I_2' = \\{a\\} \\cup (\\emptyset \\setminus \\{b\\}) = \\{a\\}$。$I_2$ 改变。添加前驱 $\\{B_1, B_4\\}$。$B_4$ 在 $W$ 中。添加 $B_1$。$W = [B_3, B_4, B_5, B_1]$。\n3.  **步骤 3**：移除 $B_3$。$C_{\\mathrm{FIFO}}=3$。$O_3 = I_4 = \\emptyset$。$I_3' = \\{b\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{b\\}$。$I_3$ 改变。添加前驱 $B_1$。$B_1$ 在 $W$ 中。$W = [B_4, B_5, B_1]$。\n4.  **步骤 4**：移除 $B_4$。$C_{\\mathrm{FIFO}}=4$。$O_4 = I_2 \\cup I_5 = \\{a\\} \\cup \\emptyset = \\{a\\}$。$I_4' = \\{b\\} \\cup (\\{a\\} \\setminus \\{a\\}) = \\{b\\}$。$I_4$ 改变。添加前驱 $\\{B_2, B_3\\}$。$W = [B_5, B_1, B_2, B_3]$。\n5.  **步骤 5**：移除 $B_5$。$C_{\\mathrm{FIFO}}=5$。$O_5 = \\emptyset$。$I_5' = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$。$I_5$ 未变。$W = [B_1, B_2, B_3]$。\n6.  **步骤 6**：移除 $B_1$。$C_{\\mathrm{FIFO}}=6$。$O_1 = I_2 \\cup I_3 = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。$I_1' = \\emptyset \\cup (\\{a, b\\} \\setminus \\{a\\}) = \\{b\\}$。$I_1$ 改变。没有前驱可添加。$W = [B_2, B_3]$。\n7.  **步骤 7**：移除 $B_2$。$C_{\\mathrm{FIFO}}=7$。$O_2 = I_4 = \\{b\\}$。$I_2' = \\{a\\} \\cup (\\{b\\} \\setminus \\{b\\}) = \\{a\\}$。$I_2$ 未变。$W = [B_3]$。\n8.  **步骤 8**：移除 $B_3$。$C_{\\mathrm{FIFO}}=8$。$O_3 = I_4 = \\{b\\}$。$I_3' = \\{b\\} \\cup (\\{b\\} \\setminus \\emptyset) = \\{b\\}$。$I_3$ 未变。$W = []$。\n\n工作列表为空。算法终止。总处理步骤数为 $C_{\\mathrm{FIFO}} = 8$。\n\n#### RPO 策略执行过程\n\n首先，我们确定逆后序。从 $B_1$ 开始的深度优先搜索（按递增索引顺序访问后继）过程为 $B_1 \\to B_2 \\to B_4 \\to B_5$。$B_2$ 是 $B_4$ 的一个后继但同时也是一个祖先，这表明存在一条回边。然后我们回溯并从 $B_1$ 访问 $B_3$。\n- 后序完成时间：$B_5(1)$, $B_4(2)$, $B_2(3)$, $B_3(4)$, $B_1(5)$。\n- 后序序列：$(B_5, B_4, B_2, B_3, B_1)$。\n- 逆后序 (RPO) 序列：$(B_1, B_3, B_2, B_4, B_5)$。\n块的优先级是其在 RPO 序列中的位置（位置越小，优先级越高）。优先级：$p(B_1)=1, p(B_3)=2, p(B_2)=3, p(B_4)=4, p(B_5)=5$。\n\n初始工作列表是一个集合 $W = \\{B_1, B_2, B_3, B_4, B_5\\}$。步骤计数器 $C_{\\mathrm{RPO}}$ 初始化为 $0$。\n\n1.  **步骤 1**：提取 $B_1$ ($p=1$) 。$C_{\\mathrm{RPO}}=1$。$O_1 = I_2 \\cup I_3 = \\emptyset$。$I_1' = \\emptyset$。未变。$W = \\{B_2, B_3, B_4, B_5\\}$。\n2.  **步骤 2**：提取 $B_3$ ($p=2$) 。$C_{\\mathrm{RPO}}=2$。$O_3 = I_4 = \\emptyset$。$I_3' = \\{b\\}$。$I_3$ 改变。添加前驱 $B_1$。$W = \\{B_1, B_2, B_4, B_5\\}$。\n3.  **步骤 3**：提取 $B_1$ ($p=1$) 。$C_{\\mathrm{RPO}}=3$。$O_1 = I_2 \\cup I_3 = \\emptyset \\cup \\{b\\} = \\{b\\}$。$I_1' = \\{b\\}$。$I_1$ 改变。没有前驱。$W = \\{B_2, B_4, B_5\\}$。\n4.  **步骤 4**：提取 $B_2$ ($p=3$) 。$C_{\\mathrm{RPO}}=4$。$O_2 = I_4 = \\emptyset$。$I_2' = \\{a\\}$。$I_2$ 改变。添加前驱 $\\{B_1, B_4\\}$。$B_4$ 在 $W$ 中。添加 $B_1$。$W = \\{B_1, B_4, B_5\\}$。\n5.  **步骤 5**：提取 $B_1$ ($p=1$) 。$C_{\\mathrm{RPO}}=5$。$O_1 = I_2 \\cup I_3 = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。$I_1' = \\{b\\}$。$I_1$ 未变。$W = \\{B_4, B_5\\}$。\n6.  **步骤 6**：提取 $B_4$ ($p=4$) 。$C_{\\mathrm{RPO}}=6$。$O_4 = I_2 \\cup I_5 = \\{a\\} \\cup \\emptyset = \\{a\\}$。$I_4' = \\{b\\}$。$I_4$ 改变。添加前驱 $\\{B_2, B_3\\}$。$W = \\{B_2, B_3, B_5\\}$。\n7.  **步骤 7**：提取 $B_3$ ($p=2$) 。$C_{\\mathrm{RPO}}=7$。$O_3 = I_4 = \\{b\\}$。$I_3' = \\{b\\}$。$I_3$ 未变。$W = \\{B_2, B_5\\}$。\n8.  **步骤 8**：提取 $B_2$ ($p=3$) 。$C_{\\mathrm{RPO}}=8$。$O_2 = I_4 = \\{b\\}$。$I_2' = \\{a\\}$。$I_2$ 未变。$W = \\{B_5\\}$。\n9.  **步骤 9**：提取 $B_5$ ($p=5$) 。$C_{\\mathrm{RPO}}=9$。$O_5 = \\emptyset$。$I_5' = \\emptyset$。$I_5$ 未变。$W = \\emptyset$。\n\n工作列表为空。算法终止。总处理步骤数为 $C_{\\mathrm{RPO}} = 9$。\n\n#### 最终计算\n\n每个策略的步骤数分别为 $C_{\\mathrm{FIFO}} = 8$ 和 $C_{\\mathrm{RPO}} = 9$。问题要求计算 $C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}}$ 的值。\n$$C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}} = 9 - 8 = 1$$\n该经验性结果证实了定性预测，即 RPO 策略对于此后向分析问题效率较低。",
            "answer": "$$\\boxed{1}$$"
        }
    ]
}