{
    "hands_on_practices": [
        {
            "introduction": "这个练习将带你入门常量传播分析，这是数据流分析中最基础也最常见的应用之一。我们将构建一个格，用来表示一个变量是“未定义”、“某个特定常量”还是“非常量”。通过这个练习 ，你将亲手定义并使用交汇操作（meet operator），来安全地合并来自不同控制流路径的信息，并理解如何处理路径冲突和不可达代码。",
            "id": "3657805",
            "problem": "对于单个变量的前向必须常量传播分析使用抽象域 $D = \\{\\perp\\} \\cup \\{n \\in \\mathbb{Z}\\} \\cup \\{\\top\\}$，其中 $\\perp$ 表示不可达信息，$n$ 表示变量绝对是整数常量 $n$，而 $\\top$ 表示变量不是单个常量。考虑变量集 $V = \\{x,y,z,w\\}$ 的逐点积域 $D^{V}$。你需要构建 $D$ 上的格结构，选择一个序，在该序下，跨前驱的汇合是一个交运算符，该运算符将冲突的常量合并为 $\\top$。\n\n任务：\n- 使用格论的第一性原理，在 $D$ 上指定一个偏序 $\\preceq$，使得 $(D,\\preceq)$ 成为一个适用于前向必须常量传播分析的格，并从此序中为 $D$ 上的二元交运算符 $a \\sqcap b$ 推导出一个精确的、分情况的定义。\n- 然后，在控制流图（CFG）的连接点 $P$ 处，对以下代码片段进行前向必须常量传播分析。假设抽象域中的算术运算当且仅当所有操作数都是常量时才计算出一个常量；否则它产生 $\\top$。\n\n程序（$P$ 的三个前驱）：\n- 入口：$y := 7$；控制流分裂到 $B_{1}$、$B_{2}$、$B_{3}$。\n- 块 $B_{1}$：$x := 4$; $z := y$; $w := 0$; goto $P$。\n- 块 $B_{2}$：$x := 5$; $z := 9$; $w := x - x$; goto $P$。\n- 块 $B_{3}$：assume false; $x := 100$; $z := 1000$; $w := 10000$; goto $P$。\n\n$B_{3}$ 中的守卫条件恒为假，因此通过 $B_{3}$ 的路径是不可达的。\n\n问题：在点 $P$ 处，使用你定义的 $a \\sqcap b$ 将来自三个前驱的传入抽象状态进行交运算后，计算 $V$ 中抽象值（在 $D$ 中）为 $\\top$ 的变量数量。请以整数形式给出最终答案。",
            "solution": "该问题要求我们对给定的代码片段执行前向必须常量传播分析。这个过程包括两个主要部分：首先，为抽象域定义格结构；其次，应用此结构来分析代码。\n\n第1部分：定义格和交运算符\n\n单个变量的抽象域为 $D = \\{\\perp\\} \\cup \\{n \\in \\mathbb{Z}\\} \\cup \\{\\top\\}$。\n-   $\\top$（顶，或“任何值”）表示变量不确定是否为单个常量。\n-   $n \\in \\mathbb{Z}$ 表示变量已知具有常量整数值 $n$。\n-   $\\perp$（底）表示程序点不可达。注意：问题描述使用 $\\perp$ 来表示“不可达信息”，这在数据流分析的格论背景下对应于信息格的顶元素，而 $\\top$ 对应于底元素。我们将遵循这个标准约定，即更多信息意味着在格中的位置“更高”。\n\n对于“必须”分析，信息只有在所有传入路径上都为真时才被保留。这意味着信息在连接点处减少。汇合运算符是一个交 ($\\sqcap$)，它计算其操作数的最大下界（GLB）。序关系 $a \\preceq b$ 意味着“$a$ 拥有的信息量小于或等于 $b$”。\n\n-   状态 $\\top$ 携带最少的信息（最大的不确定性）。\n-   一个常量状态 $n$ 比 $\\top$ 携带更多的信息。\n-   状态 $\\perp$ 携带最多的信息，因为它对不可达性做出了明确的断言。\n\n因此，我们如下建立 $D$ 上的偏序 $\\preceq$：\n1. 对所有 $a \\in D$，$\\top \\preceq a$。这使得 $\\top$ 成为格的最小元或底元。\n2. 对所有 $a \\in D$，$a \\preceq \\perp$。这使得 $\\perp$ 成为格的最大元或顶元。\n3. 对任意常量 $c \\in \\mathbb{Z}$，$\\top \\preceq c \\preceq \\perp$。\n4. 对任意两个不同的常量 $c_1, c_2 \\in \\mathbb{Z}$，它们是不可比的：$c_1 \\not\\preceq c_2$ 且 $c_2 \\not\\preceq c_1$。\n\n这个结构定义了一个完备格 $(D, \\preceq)$。交运算符 $a \\sqcap b$ 找到 $a$ 和 $b$ 的最大下界。基于偏序 $\\preceq$，我们推导出其定义：\n-   对任意 $a \\in D$，$a \\sqcap \\perp = a$。与顶元素 $\\perp$（不可达路径）进行交运算不会改变值，因为不可达路径对可达状态不提供任何约束。\n-   对任意 $a \\in D$，$a \\sqcap \\top = \\top$。与底元素 $\\top$ 进行交运算结果为 $\\top$，因为这代表了所有常量信息的丢失。\n-   对于 $c_1, c_2 \\in \\mathbb{Z}$：\n    -   如果 $c_1 = c_2$，它们的最大下界是 $c_1 \\sqcap c_2 = c_1$。\n    -   如果 $c_1 \\neq c_2$，唯一同时小于二者的元素是 $\\top$。因此，它们的最大下界是 $c_1 \\sqcap c_2 = \\top$。这符合冲突的常量被解析为 $\\top$ 的要求。\n\n第2部分：分析代码片段\n\n分析在变量集 $V = \\{x, y, z, w\\}$ 的积域 $D^V$ 上进行。一个抽象状态是一个元组 $(v_x, v_y, v_z, v_w)$。状态的交运算是逐点进行的。\n\n程序以语句 $y := 7$ 开始。假设在此之前变量不是常量，那么进入三个后继块（$B_1$、$B_2$、$B_3$）时的状态是 $S_{in} = (\\top, 7, \\top, \\top)$。我们现在跟踪每个块的执行，以找出它们出口处的抽象状态。\n\n-   **通过块 $B_1$ 的路径**：\n    -   入口状态：$(\\top, 7, \\top, \\top)$。\n    -   在 `x := 4` 之后：$(4, 7, \\top, \\top)$。\n    -   在 `z := y` 之后：由于 $y$ 的抽象值是 $7$，所以 $z$ 被赋值为 $7$。状态变为 $(4, 7, 7, \\top)$。\n    -   在 `w := 0` 之后：状态变为 $(4, 7, 7, 0)$。\n    -   从 $B_1$ 输出的状态是 $S_{out,1} = (4, 7, 7, 0)$。\n\n-   **通过块 $B_2$ 的路径**：\n    -   入口状态：$(\\top, 7, \\top, \\top)$。\n    -   在 `x := 5` 之后：$(5, 7, \\top, \\top)$。\n    -   在 `z := 9` 之后：$(5, 7, 9, \\top)$。\n    -   在 `w := x - x` 之后：$x$ 的抽象值是 $5$。操作是 $5 - 5$，其计算结果为常量 $0$。状态变为 $(5, 7, 9, 0)$。\n    -   从 $B_2$ 输出的状态是 $S_{out,2} = (5, 7, 9, 0)$。\n\n-   **通过块 $B_3$ 的路径**：\n    -   该块以 `assume false` 开始。这将该路径从控制流图中剪除。\n    -   对于数据流分析，一个不可达路径贡献了格的顶元素 $\\perp$，它代表了最大的信息（即不可达性的断言）。\n    -   从 $B_3$ 输出的状态是 $S_{out,3} = (\\perp, \\perp, \\perp, \\perp)$。\n\n在连接点 $P$ 处，我们计算来自三个前驱块的抽象状态的交：\n$$S_P = S_{out,1} \\sqcap S_{out,2} \\sqcap S_{out,3}$$\n$$S_P = (4, 7, 7, 0) \\sqcap (5, 7, 9, 0) \\sqcap (\\perp, \\perp, \\perp, \\perp)$$\n\n我们逐点计算每个变量的交：\n-   $v_x = 4 \\sqcap 5 \\sqcap \\perp$。因为 $4 \\neq 5$，所以 $4 \\sqcap 5 = \\top$。然后，$\\top \\sqcap \\perp = \\top$。所以，$v_x = \\top$。\n-   $v_y = 7 \\sqcap 7 \\sqcap \\perp$。因为常量相等，所以 $7 \\sqcap 7 = 7$。然后，$7 \\sqcap \\perp = 7$。所以，$v_y = 7$。\n-   $v_z = 7 \\sqcap 9 \\sqcap \\perp$。因为 $7 \\neq 9$，所以 $7 \\sqcap 9 = \\top$。然后，$\\top \\sqcap \\perp = \\top$。所以，$v_z = \\top$。\n-   $v_w = 0 \\sqcap 0 \\sqcap \\perp$。因为常量相等，所以 $0 \\sqcap 0 = 0$。然后，$0 \\sqcap \\perp = 0$。所以，$v_w = 0$。\n\n在点 $P$ 的最终抽象状态是 $S_P = (\\top, 7, \\top, 0)$。\n\n问题要求的是抽象值为 $\\top$ 的变量的数量。\n-   变量 $x$：抽象值为 $\\top$。\n-   变量 $y$：抽象值为 $7$。\n-   变量 $z$：抽象值为 $\\top$。\n-   变量 $w$：抽象值为 $0$。\n\n抽象值为 $\\top$ 的变量是 $x$ 和 $z$。数量是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在掌握了基于值的分析之后，我们来探索一个结构更独特的格：分区格（partition lattice）。这个练习  将向你展示，同样的格理论框架如何应用于“必为别名”（must-alias）分析，即确定两个变量是否在任何执行路径上都指向同一个内存位置。你将学习如何通过“精化”（refinement）来定义偏序关系，并使用交汇操作来合并别名信息，这会加深你对数据流框架通用性的理解。",
            "id": "3657763",
            "problem": "考虑一个在有限变量集 $V = \\{a,b,c,d\\}$ 上定义的前向必别名数据流分析，该分析作用于一个控制流图 (CFG)。数据流域是 $V$ 的所有划分的集合，记为 $\\Pi(V)$，其结构如下：\n\n- 偏序：对于 $P, Q \\in \\Pi(V)$，记 $P \\preceq Q$ 当且仅当 $P$ 是 $Q$ 的一个细化，等价地，如果由 $P$ 诱导的等价关系 $R_{P} \\subseteq V \\times V$ 满足 $R_{P} \\subseteq R_{Q}$。\n- 会合算子：对于 $P, Q \\in \\Pi(V)$，会合 $P \\wedge Q \\in \\Pi(V)$ 通过等价关系 $R_{P \\wedge Q} = R_{P} \\cap R_{Q}$ 定义，这是 $P$ 和 $Q$ 的公共细化。\n- 转换函数：每个语句 $\\operatorname{alias}(u,v)$（其中 $u,v \\in V$）定义了一个单调转换函数 $f_{u,v} : \\Pi(V) \\to \\Pi(V)$，它将一个划分 $P$ 映射到一个新的划分，该新划分的等价关系是包含 $R_{P} \\cup \\{(u,v),(v,u)\\}$ 的最小等价关系，即，它合并 $P$ 中包含 $u$ 和 $v$ 的块（然后在自反性、对称性和传递性下闭合）。\n\n该 CFG 由一个入口节点、一个菱形分支结构和一个汇合后块组成，边上标记的语句如下：\n\n- 从入口到左分支，该块先应用 $\\operatorname{alias}(a,b)$，然后应用 $\\operatorname{alias}(b,c)$。\n- 从入口到右分支，该块应用 $\\operatorname{alias}(a,b)$。\n- 两个分支在一个汇合节点处连接。\n- 汇合后，一个最终块应用 $\\operatorname{alias}(c,d)$，然后流向出口。\n\n假设入口处的初始输入为离散划分 $P_{\\text{entry}} = \\{\\{a\\},\\{b\\},\\{c\\},\\{d\\}\\}$（$\\Pi(V)$ 在 $\\preceq$ 下的底元素）。仅使用上述定义，沿着 CFG 执行基于会合的不动点计算，以确定出口划分。你的答案必须是出口划分中块的数量，以一个单一整数的形式给出。不需要单位，也不需要四舍五入。",
            "solution": "问题要求计算在给定控制流图 (CFG) 出口处的必别名数据流事实。这是一个在变量集 $V = \\{a, b, c, d\\}$ 的划分格上定义的前向数据流分析问题。分析过程通过在 CFG 中传播划分信息、对语句应用转换函数以及在汇合点处使用会合算子来进行。\n\n格域为 $\\Pi(V)$，即 $V$ 的所有划分的集合。偏序由细化关系给出：对于两个划分 $P, Q \\in \\Pi(V)$，$P \\preceq Q$ 当且仅当 $P$ 是 $Q$ 的一个细化。该格的底元素代表最少的信息（没有已知的别名），是每个变量都位于其自身块中的离散划分。\n\nCFG 入口点处的初始条件为底元素：\n$P_{\\text{entry}} = \\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}$。\n\n分析过程如下：\n\n1.  **从入口到分支的流**：数据流事实 $P_{\\text{entry}}$ 传播到左、右两个分支的输入端。设 $P_{L_{\\text{in}}}$ 和 $P_{R_{\\text{in}}}$ 分别为左、右分支输入端的划分。\n    $$P_{L_{\\text{in}}} = P_{R_{\\text{in}}} = P_{\\text{entry}} = \\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}$$\n\n2.  **左分支分析**：左分支包含一个由两个顺序语句组成的块：$\\operatorname{alias}(a,b)$ 之后是 $\\operatorname{alias}(b,c)$。我们依次应用它们对应的转换函数。\n    -   $\\operatorname{alias}(a,b)$ 的转换函数（记为 $f_{a,b}$）合并包含 $a$ 和 $b$ 的块。\n        $$P_1 = f_{a,b}(P_{L_{\\text{in}}}) = f_{a,b}(\\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$$\n    -   接下来，将 $\\operatorname{alias}(b,c)$ 的转换函数（记为 $f_{b,c}$）应用于 $P_1$。它合并包含 $b$（即 $\\{a,b\\}$）和 $c$（即 $\\{c\\}$）的块。\n        $$P_{L_{\\text{out}}} = f_{b,c}(P_1) = f_{b,c}(\\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b,c\\}, \\{d\\}\\}$$\n    这是左分支输出端的数据流事实。\n\n3.  **右分支分析**：右分支包含单个语句 $\\operatorname{alias}(a,b)$。\n    -   将其转换函数 $f_{a,b}$ 应用于输入划分 $P_{R_{\\text{in}}}$。\n        $$P_{R_{\\text{out}}} = f_{a,b}(P_{R_{\\text{in}}}) = f_{a,b}(\\{\\{a\\}, \\{b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$$\n    这是右分支输出端的数据流事实。\n\n4.  **汇合点分析**：两个分支在一个汇合节点处合并。对于“必”分析，汇合点的数据流事实是所有入路径事实的会合。会合算子 $\\wedge$ 通过相应等价关系的交集定义：$R_{P \\wedge Q} = R_P \\cap R_Q$。这对应于在格中寻找输入划分的最大下界 (GLB)，即它们的最细公共细化。\n    -   汇合点的输入是 $P_{L_{\\text{out}}} = \\{\\{a,b,c\\}, \\{d\\}\\}$ 和 $P_{R_{\\text{out}}} = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$。\n    -   我们需要计算 $P_{\\text{join}} = P_{L_{\\text{out}}} \\wedge P_{R_{\\text{out}}}$。\n    -   让我们分析这两个划分在细化序 $\\preceq$ 下的关系。如果划分 $P$ 中的每个块都是划分 $Q$ 中某个块的子集，则 $P$ 是 $Q$ 的一个细化 ($P \\preceq Q$)。\n    -   考虑 $P_{R_{\\text{out}}}$ 的块：$\\{a,b\\}$、$\\{c\\}$ 和 $\\{d\\}$。\n    -   考虑 $P_{L_{\\text{out}}}$ 的块：$\\{a,b,c\\}$ 和 $\\{d\\}$。\n    -   我们检查 $P_{R_{\\text{out}}}$ 是否是 $P_{L_{\\text{out}}}$ 的细化：\n        -   $P_{R_{\\text{out}}}$ 中的块 $\\{a,b\\}$ 是 $P_{L_{\\text{out}}}$ 中块 $\\{a,b,c\\}$ 的子集。\n        -   $P_{R_{\\text{out}}}$ 中的块 $\\{c\\}$ 是 $P_{L_{\\text{out}}}$ 中块 $\\{a,b,c\\}$ 的子集。\n        -   $P_{R_{\\text{out}}}$ 中的块 $\\{d\\}$ 是 $P_{L_{\\text{out}}}$ 中块 $\\{d\\}$ 的子集。\n    -   由于 $P_{R_{\\text{out}}}$ 的所有块都是 $P_{L_{\\text{out}}}$ 中块的子集，我们有 $P_{R_{\\text{out}}} \\preceq P_{L_{\\text{out}}}$。\n    -   两个元素中，如果一个小于等于另一个，它们的会合（GLB）就是较小的那个元素。\n        $$P_{\\text{join}} = P_{L_{\\text{out}}} \\wedge P_{R_{\\text{out}}} = P_{R_{\\text{out}}} = \\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}$$\n    这个划分成为汇合后块的输入。\n\n5.  **汇合后块分析**：汇合后，一个最终块应用语句 $\\operatorname{alias}(c,d)$。\n    -   转换函数 $f_{c,d}$ 应用于划分 $P_{\\text{join}}$。它合并包含 $c$（即 $\\{c\\}$）和 $d$（即 $\\{d\\}$）的块。\n        $$P_{\\text{exit}} = f_{c,d}(P_{\\text{join}}) = f_{c,d}(\\{\\{a,b\\}, \\{c\\}, \\{d\\}\\}) = \\{\\{a,b\\}, \\{c,d\\}\\}$$\n    这是 CFG 出口处的最终划分。\n\n6.  **最终答案**：问题要求的是出口划分 $P_{\\text{exit}}$ 中的块的数量。\n    -   出口划分为 $P_{\\text{exit}} = \\{\\{a,b\\}, \\{c,d\\}\\}$。\n    -   块是 $\\{a,b\\}$ 和 $\\{c,d\\}$。\n    -   块的数量是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "数据流分析总能得到最精确的结果吗？这个练习  将引导你深入探索数据流分析的理论边界，特别是分配性（distributivity）的关键作用。我们将构造一个非分配性的分析框架，并让你亲手计算算法解（最大不动点，MFP）与理论最优解（所有路径上的交汇，MOP）之间的精度差异。通过这个实践，你将直观地理解为什么某些分析会损失精度，以及这种损失是如何发生的。",
            "id": "3657744",
            "problem": "考虑在一个小型控制流图（CFG）上进行前向、may风格的到达定值分析，该控制流图有两条并行路径在一个汇合块处合并。其基本基础是 Kildall 的单调数据流分析框架：一个数据流问题指定一个流事实的格、一个汇合算子和沿边应用的单调传递函数；该算法计算一个最大不动点（MFP）。已知当框架是分配性时，即当每个传递函数对汇合算子满足分配律时，MFP 等于所有路径上交汇（MOP）解。在本题中，您将为到达定值构建一个非分配性框架，并量化其精度损失。\n\n设具体定值标识符的全集为 $D = \\{d_{1}, d_{2}, d_{3}\\}$，对应单个变量。我们定义一个抽象域（一个商格）$L = \\{\\bot, a, b, c, \\top\\}$，通过具体化映射 $\\gamma : L \\to \\mathcal{P}(D)$ 解释如下：\n- $\\gamma(\\bot) = \\varnothing$，\n- $\\gamma(a) = \\{d_{1}\\}$，\n- $\\gamma(b) = \\{d_{2}\\}$，\n- $\\gamma(c) = \\{d_{1}, d_{2}\\}$，\n- $\\gamma(\\top) = \\{d_{1}, d_{2}, d_{3}\\}$。\n\n为 $L$ 配备由其代表元上的反子集关系导出的偏序，即对于 $x, y \\in L$，$x \\preceq y$ 当且仅当 $\\gamma(x) \\supseteq \\gamma(y)$。使用汇合算子 $\\sqcap$ 作为 $\\preceq$ 中的最大下界，这与其代表元上的集合论并集一致：\n$$\nx \\sqcap y \\;=\\; \\alpha\\big(\\gamma(x) \\cup \\gamma(y)\\big),\n$$\n其中 $\\alpha$ 是一个自然抽象，它将 $\\mathcal{P}(D)$ 中的具体集映射到 $L$，方法是将任何包含 $d_{3}$ 的集合压缩到 $\\top$，否则完全如上映射。具体来说，$\\sqcap$ 满足 $a \\sqcap b = c$, $c \\sqcap a = c$, $c \\sqcap b = c$，对于任何 $x \\in L$ 有 $\\top \\sqcap x = \\top$，以及 $\\bot \\sqcap x = x$。\n\n在汇合块处定义一个传递函数 $f : L \\to L$，该函数模拟一个粗略的、路径敏感的“类phi”合并，它恰好在 $d_{1}$ 和 $d_{2}$ 可能同时到达时引入一个新的定值 $d_{3}$。形式上，令 $p : \\mathcal{P}(D) \\to \\mathcal{P}(D)$ 为\n$$\np(S) \\;=\\; \\begin{cases}\nS \\cup \\{d_{3}\\},  \\text{若 } \\{d_{1}, d_{2}\\} \\subseteq S, \\\\\nS,  \\text{其他情况},\n\\end{cases}\n$$\n并设 $f(x) = \\alpha\\big(p(\\gamma(x))\\big)$。这个 $f$ 关于 $\\preceq$ 是单调的，但它对 $\\sqcap$ 不满足分配律。\n\n现在考虑一个CFG片段，其中左前驱为汇合块产生抽象输入 $a$（只有 $d_{1}$ 可能到达），右前驱产生 $b$（只有 $d_{2}$ 可能到达）。汇合点出口处的MFP解是将传递函数应用于前驱的汇合，即 $f(a \\sqcap b)$，而在同一程序点处的MOP解是 $f(a) \\sqcap f(b)$。\n\n计算整数差\n$$\n\\Delta \\;=\\; \\big|\\gamma\\big(f(a \\sqcap b)\\big)\\big| \\;-\\; \\big|\\gamma\\big(f(a) \\sqcap f(b)\\big)\\big|,\n$$\n其中 $|\\cdot|$ 表示集合的基数。以整数形式表示您的最终答案。无需四舍五入，也无需单位。",
            "solution": "用户希望我解决一个数据流分析问题。\n\n**1. 问题验证**\n\n*   **步骤1：提取已知条件**\n    *   定值全集: $D = \\{d_{1}, d_{2}, d_{3}\\}$。\n    *   抽象域: $L = \\{\\bot, a, b, c, \\top\\}$。\n    *   具体化映射 $\\gamma: L \\to \\mathcal{P}(D)$:\n        *   $\\gamma(\\bot) = \\varnothing$\n        *   $\\gamma(a) = \\{d_{1}\\}$\n        *   $\\gamma(b) = \\{d_{2}\\}$\n        *   $\\gamma(c) = \\{d_{1}, d_{2}\\}$\n        *   $\\gamma(\\top) = \\{d_{1}, d_{2}, d_{3}\\}$\n    *   偏序 $\\preceq$: 对于 $x, y \\in L$, $x \\preceq y \\iff \\gamma(x) \\supseteq \\gamma(y)$。\n    *   汇合算子 (交) $\\sqcap$: $x \\sqcap y = \\alpha(\\gamma(x) \\cup \\gamma(y))$。\n    *   抽象映射 $\\alpha: \\mathcal{P}(D) \\to L$: 将任何包含 $d_3$ 的集合压缩到 $\\top$；否则，它是在其像集上 $\\gamma$ 的逆。\n    *   具体传递函数 $p: \\mathcal{P}(D) \\to \\mathcal{P}(D)$:\n        $p(S) = \\begin{cases} S \\cup \\{d_{3}\\},  \\text{若 } \\{d_{1}, d_{2}\\} \\subseteq S \\\\ S,  \\text{其他情况} \\end{cases}$\n    *   抽象传递函数 $f: L \\to L$: $f(x) = \\alpha(p(\\gamma(x)))$。\n    *   汇合块的输入: 抽象值 $a$ 和 $b$。\n    *   汇合出口处的MFP解: $f(a \\sqcap b)$。\n    *   汇合出口处的MOP解: $f(a) \\sqcap f(b)$。\n    *   任务：计算 $\\Delta = |\\gamma(f(a \\sqcap b))| - |\\gamma(f(a) \\sqcap f(b))|$。\n\n*   **步骤2：使用提取的已知条件进行验证**\n    *   该问题在应用于编译器数据流分析的格理论标准数学框架内具有科学依据。所有概念（格、交算子、传递函数、MFP、MOP）在该领域都是标准的。\n    *   该问题是适定（well-posed）的。所有组件都已明确定义，且所需的计算是明确的。\n    *   该问题是客观的，并使用精确的数学语言。\n    *   该框架虽然与一些教科书示例相比使用了反向偏序，但其内部是一致的。偏序 $\\preceq$ 和交算子 $\\sqcap$ 的定义是相互一致的。例如，相对于 $\\preceq$，$ \\{a, b\\}$ 的最大下界确实是 $c$，这与所提供公式 $\\alpha(\\gamma(a) \\cup \\gamma(b))$ 的结果相匹配。\n    *   该问题是一个有效且形式良好的数据流分析练习。\n\n*   **步骤3：结论与行动**\n    *   **结论：** 问题是**有效的**。\n    *   **行动：** 继续进行求解。\n\n**2. 求解**\n\n目标是计算 $\\Delta$ 的值，它被定义为最大不动点（MFP）解和所有路径上交汇（MOP）解之间具体定值数量的差异。\n$$\n\\Delta = |\\gamma(f(a \\sqcap b))| - |\\gamma(f(a) \\sqcap f(b))|\n$$\n我们将分别计算减法中的两项。\n\n首先，我们评估MFP项，它对应于在路径汇合后应用传递函数：$|\\gamma(f(a \\sqcap b))|$。\n\n1.  我们首先计算来自两个前驱路径的输入 $a$ 和 $b$ 的汇合（交）。交算子定义为 $x \\sqcap y = \\alpha(\\gamma(x) \\cup \\gamma(y))$。\n    $$\n    a \\sqcap b = \\alpha(\\gamma(a) \\cup \\gamma(b))\n    $$\n    使用给定的具体化映射 $\\gamma$：\n    $$\n    \\gamma(a) = \\{d_{1}\\}\n    $$\n    $$\n    \\gamma(b) = \\{d_{2}\\}\n    $$\n    这些具体集的并集是：\n    $$\n    \\gamma(a) \\cup \\gamma(b) = \\{d_{1}\\} \\cup \\{d_{2}\\} = \\{d_{1}, d_{2}\\}\n    $$\n    现在，我们应用抽象映射 $\\alpha$。集合 $\\{d_{1}, d_{2}\\}$ 不包含 $d_{3}$。问题定义意味着 $\\alpha$ 将 $\\{d_{1}, d_{2}\\}$ 映射到抽象元素 $c$。\n    $$\n    a \\sqcap b = \\alpha(\\{d_{1}, d_{2}\\}) = c\n    $$\n\n2.  接下来，我们将传递函数 $f$ 应用于此结果 $c$。该函数定义为 $f(x) = \\alpha(p(\\gamma(x)))$。对于 $x=c$：\n    $$\n    f(c) = \\alpha(p(\\gamma(c)))\n    $$\n    $c$ 的具体化是：\n    $$\n    \\gamma(c) = \\{d_{1}, d_{2}\\}\n    $$\n    现在我们将具体传递函数 $p$ 应用于此集合。$p(S)$ 的定义有一个条件：$\\{d_{1}, d_{2}\\} \\subseteq S$。对于 $S = \\{d_{1}, d_{2}\\}$，此条件满足。\n    $$\n    p(\\{d_{1}, d_{2}\\}) = \\{d_{1}, d_{2}\\} \\cup \\{d_{3}\\} = \\{d_{1}, d_{2}, d_{3}\\}\n    $$\n    将抽象映射 $\\alpha$ 应用于这个新集合：任何包含 $d_{3}$ 的集合都被抽象为 $\\top$。\n    $$\n    f(c) = \\alpha(\\{d_{1}, d_{2}, d_{3}\\}) = \\top\n    $$\n    因此，MFP解是 $f(a \\sqcap b) = \\top$。\n\n3.  最后，我们求出MFP解的具体化的基数。\n    $$\n    |\\gamma(f(a \\sqcap b))| = |\\gamma(\\top)| = |\\{d_{1}, d_{2}, d_{3}\\}| = 3\n    $$\n\n接下来，我们评估MOP项，它对应于对沿每条路径应用传递函数后的结果取汇合：$|\\gamma(f(a) \\sqcap f(b))|$。\n\n1.  我们首先将传递函数 $f$ 分别应用于每个输入 $a$ 和 $b$。\n    对于输入 $a$：\n    $$\n    f(a) = \\alpha(p(\\gamma(a))) = \\alpha(p(\\{d_{1}\\}))\n    $$\n    对于 $p(\\{d_{1}\\})$，条件 $\\{d_{1}, d_{2}\\} \\subseteq \\{d_{1}\\}$ 为假。因此，我们使用 'otherwise' 分支：\n    $$\n    p(\\{d_{1}\\}) = \\{d_{1}\\}\n    $$\n    应用抽象：\n    $$\n    f(a) = \\alpha(\\{d_{1}\\}) = a\n    $$\n    对于输入 $b$：\n    $$\n    f(b) = \\alpha(p(\\gamma(b))) = \\alpha(p(\\{d_{2}\\}))\n    $$\n    对于 $p(\\{d_{2}\\})$，条件 $\\{d_{1}, d_{2}\\} \\subseteq \\{d_{2}\\}$ 为假。因此，我们使用 'otherwise' 分支：\n    $$\n    p(\\{d_{2}\\}) = \\{d_{2}\\}\n    $$\n    应用抽象：\n    $$\n    f(b) = \\alpha(\\{d_{2}\\}) = b\n    $$\n\n2.  现在，我们计算这两个结果的交：\n    $$\n    f(a) \\sqcap f(b) = a \\sqcap b\n    $$\n    如前所算，$a \\sqcap b = c$。\n    因此，MOP解是 $f(a) \\sqcap f(b) = c$。\n\n3.  最后，我们求出MOP解的具体化的基数。\n    $$\n    |\\gamma(f(a) \\sqcap f(b))| = |\\gamma(c)| = |\\{d_{1}, d_{2}\\}| = 2\n    $$\n\n计算出两项后，我们现在可以计算 $\\Delta$。\n$$\n\\Delta = |\\gamma(f(a \\sqcap b))| - |\\gamma(f(a) \\sqcap f(b))| = 3 - 2 = 1\n$$\n值 $\\Delta = 1$ 量化了MFP解相对于更精确的MOP解的精度损失。MFP分析错误地得出结论，定值 $d_{3}$ 可能到达该程序点，而MOP分析则正确地确定它不可能到达。",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}