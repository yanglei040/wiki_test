{
    "hands_on_practices": [
        {
            "introduction": "指令选择的核心是解决一个优化问题：如何用最低成本的目标指令序列覆盖表达式树。本练习  提供了一个具体的场景，让您应用自底向上的动态规划算法，比较使用基础指令集与增加了特殊指令（如 `$LEA$` 指令）后的成本差异。这是亲身体会编译器如何做出智能权衡的第一步。",
            "id": "3679133",
            "problem": "您正在设计一个教学用的指令集架构（ISA），用以说明用于指令选择的树模式匹配。该ISA支持以下指令模块，每个模块在被选中时都会生成一条机器指令：\n\n- 一个二元加法模块，匹配树模式 $+(x,y)$，成本为 $1$。\n- 一个常数左移模块，匹配树模式 $\\ll(x,k)$，其中 $k$ 为整数，成本为 $1$。\n- 一系列寻址模式模块（通用有效地址加载，记作 $LEA$），当同一子表达式 $x$ 出现两次时，可匹配 $+(x,\\ll(x,k))$ 或 $+(\\ll(x,k),x)$。对于这些模块：\n  - 如果 $k \\in \\{0,1,2,3\\}$，成本为 $1$。\n  - 如果 $k \\in \\{4,5\\}$，成本为 $2$。\n  - 如果 $k \\notin \\{0,1,2,3,4,5\\}$，该模式无法匹配。\n\n假设叶节点 $a$、$b$、$c$ 已驻留在寄存器中，可以作为操作数使用，成本为零。除了将 $+(x,\\ll(x,k))$ 和 $+(\\ll(x,k),x)$ 都匹配为相同的 $LEA$ 模式外，不允许进行重组或代数重写。您必须使用自底向上的树模式匹配，通过最小化模块成本之和来计算给定表达式树的最优覆盖。\n\n考虑表达式树\n$$\nE = +\\Big( +\\big( +(a, \\ll(a,3)), +(b, \\ll(b,4)) \\big), +(\\ll(c,5), c) \\Big).\n$$\n\n令 $C_{\\text{base}}$ 表示仅使用加法和移位模块（即不允许使用 $LEA$ 模块）时的最小总成本。令 $C_{\\text{lea}}$ 表示当上述所有模块，包括 $LEA$ 系列，都作为具有所述成本的独立模块可用（针对每个可编码的 $k$）时的最小总成本。\n\n计算单个数值\n$$\nD \\triangleq C_{\\text{base}} - C_{\\text{lea}}.\n$$\n\n请以单个实数形式提供您的最终答案。无需四舍五入。无需单位。",
            "solution": "该问题要求计算用两种不同的指令模块集覆盖给定表达式树的最小成本。我们将使用自底向上的动态规划方法，计算每个子树的最小成本。令 $cost(N)$ 表示评估以节点 $N$ 为根的子树的最小成本。叶节点 $a, b, c$ 的成本给定为 $0$。\n\n让我们将表达式树 $E$ 分解为其主要子树：\n- $E_1 = +(a, \\ll(a,3))$\n- $E_2 = +(b, \\ll(b,4))$\n- $E_3 = +(\\ll(c,5), c)$\n完整的树是 $E = +\\big(+(E_1, E_2), E_3\\big)$。\n\n#### 计算 $C_{\\text{base}}$\n\n在这种情况下，只有加法模块（成本 $= 1$）和移位模块（成本 $= 1$）可用。令 $cost_B(N)$ 为子树 $N$ 的成本。\n\n1.  **移位子树的成本：**\n    - $cost_B(\\ll(a,3)) = \\text{cost}(\\ll) + cost_B(a) = 1 + 0 = 1$。使用一个移位模块。\n    - $cost_B(\\ll(b,4)) = \\text{cost}(\\ll) + cost_B(b) = 1 + 0 = 1$。\n    - $cost_B(\\ll(c,5)) = \\text{cost}(\\ll) + cost_B(c) = 1 + 0 = 1$。\n\n2.  **子树 $E_1, E_2, E_3$ 的成本：**\n    - 对于 $E_1 = +(a, \\ll(a,3))$，我们必须使用一个加法模块。其成本是模块成本加上其子节点子树的成本：\n      $cost_B(E_1) = \\text{cost}(+) + cost_B(a) + cost_B(\\ll(a,3)) = 1 + 0 + 1 = 2$。\n    - 对于 $E_2 = +(b, \\ll(b,4))$ 类似：\n      $cost_B(E_2) = \\text{cost}(+) + cost_B(b) + cost_B(\\ll(b,4)) = 1 + 0 + 1 = 2$。\n    - 对于 $E_3 = +(\\ll(c,5), c)$：\n      $cost_B(E_3) = \\text{cost}(+) + cost_B(\\ll(c,5)) + cost_B(c) = 1 + 1 + 0 = 2$。\n\n3.  **中间节点和根节点的成本：**\n    - 下一个节点是 $+(E_1, E_2)$：\n      $cost_B(+(E_1, E_2)) = \\text{cost}(+) + cost_B(E_1) + cost_B(E_2) = 1 + 2 + 2 = 5$。\n    - 根节点是 $E = +\\big(+(E_1, E_2), E_3\\big)$：\n      $cost_B(E) = \\text{cost}(+) + cost_B(+(E_1, E_2)) + cost_B(E_3) = 1 + 5 + 2 = 8$。\n\n因此，仅使用基础模块的最小成本为 $C_{\\text{base}} = 8$。\n\n#### 计算 $C_{\\text{lea}}$\n\n现在，我们引入 $LEA$ 系列模块。在每个 $+$ 节点，我们必须检查 $LEA$ 模块是否能提供一个成本更低的覆盖。令 $cost_L(N)$ 为子树 $N$ 的成本。\n\n1.  **移位子树的成本：** 这些不受影响，因为没有新的模块匹配它们。\n    - $cost_L(\\ll(a,3)) = 1$\n    - $cost_L(\\ll(b,4)) = 1$\n    - $cost_L(\\ll(c,5)) = 1$\n\n2.  **子树 $E_1 = +(a, \\ll(a,3))$ 的成本：**\n    - **选项1（ADD模块）：** $cost_L = \\text{cost}(+) + cost_L(a) + cost_L(\\ll(a,3)) = 1 + 0 + 1 = 2$。\n    - **选项2（LEA模块）：** 模式 $+(x, \\ll(x,k))$ 匹配，其中 $x=a$ 且 $k=3$。因为 $k=3$ 在集合 $\\{0,1,2,3\\}$ 中，所以该模块的成本为 $1$。这个模块覆盖了整个子树 $E_1$。\n    - 最小成本是 $cost_L(E_1) = \\min(2, 1) = 1$。\n\n3.  **子树 $E_2 = +(b, \\ll(b,4))$ 的成本：**\n    - **选项1（ADD模块）：** $cost_L = \\text{cost}(+) + cost_L(b) + cost_L(\\ll(b,4)) = 1 + 0 + 1 = 2$。\n    - **选项2（LEA模块）：** 模式 $+(x, \\ll(x,k))$ 匹配，其中 $x=b$ 且 $k=4$。因为 $k=4$ 在集合 $\\{4,5\\}$ 中，所以该模块的成本为 $2$。\n    - 最小成本是 $cost_L(E_2) = \\min(2, 2) = 2$。\n\n4.  **子树 $E_3 = +(\\ll(c,5), c)$ 的成本：**\n    - **选项1（ADD模块）：** $cost_L = \\text{cost}(+) + cost_L(\\ll(c,5)) + cost_L(c) = 1 + 1 + 0 = 2$。\n    - **选项2（LEA模块）：** 模式 $+(\\ll(x,k), x)$ 匹配，其中 $x=c$ 且 $k=5$。因为 $k=5$ 在集合 $\\{4,5\\}$ 中，所以该模块的成本为 $2$。\n    - 最小成本是 $cost_L(E_3) = \\min(2, 2) = 2$。\n\n5.  **中间节点和根节点的成本：**\n    - 节点 $+(E_1, E_2)$ 不匹配任何 $LEA$ 模式。我们必须使用一个加法模块。\n      $cost_L(+(E_1, E_2)) = \\text{cost}(+) + cost_L(E_1) + cost_L(E_2) = 1 + 1 + 2 = 4$。\n    - 根节点 $E = +\\big(+(E_1, E_2), E_3\\big)$ 也不匹配任何 $LEA$ 模式。我们必须使用一个加法模块。\n      $cost_L(E) = \\text{cost}(+) + cost_L(+(E_1, E_2)) + cost_L(E_3) = 1 + 4 + 2 = 7$。\n\n因此，使用所有可用模块的最小成本为 $C_{\\text{lea}} = 7$。\n\n#### 最终计算\n\n题目要求我们计算 $D = C_{\\text{base}} - C_{\\text{lea}}$。\n使用我们计算出的值：\n$D = 8 - 7 = 1$。\n成本差异是由于能够用一个单一、成本更低的 $LEA$ 指令（成本 $1$）来覆盖子树 $+(a, \\ll(a,3))$，而不是使用移位和加法指令的组合（总成本 $2$）。对于另外两个潜在的 $LEA$ 匹配，特殊模块并未比通用组合提供成本上的改进。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "在真实的复杂指令集（CISC）架构中，一条复杂指令的可用性并非总是确定的。本练习  引入了一个概率模型，要求您为表达式 `$x + (y \\ll k)$` 计算覆盖它的*期望*最小成本，从而将寄存器可用性和寻址模式限制等现实因素纳入考量。这是构建在平均情况下表现优异的稳健编译器的关键一步。",
            "id": "3679177",
            "problem": "考虑一个类似于英特尔复杂指令集计算机（CISC）架构的目标机器，它提供了一条加载有效地址（Load Effective Address, LEA）指令，能够计算形如 $b + s \\cdot i + d$ 的地址，其中 $b$ 是一个基址寄存器，$i$ 是一个变址寄存器，$s \\in \\{1,2,4,8\\}$ 是一个硬件支持的比例因子，$d$ 是一个位移。您正在对表达式树 $x + (y \\ll k)$ 进行树模式匹配以进行指令选择，其中 $x$ 和 $y$ 是寄存器中的值，$k$ 是一个非负整数常量。有两种候选覆盖方案可供选择：\n\n- 使用 LEA 的单指令覆盖，当可以将 $y \\ll k$ 编码为 $s \\cdot y$（其中 $s = 2^{k}$，因此要求 $k \\in \\{0,1,2,3\\}$）时，此方案可行，但受限于寻址模式的约束（变址寄存器可用且寻址形式被允许）。使用 LEA 的成本取决于 $k$：对于 $k \\in \\{0,1,2\\}$，LEA 的成本为 $c_{\\mathrm{LEA}}(k) = 1.0$（抽象成本单位）；对于 $k = 3$，由于比例因子为8的端口压力效应，LEA 的成本为 $c_{\\mathrm{LEA}}(3) = 1.3$。\n- 使用加法和移位（即 $\\mathrm{ADD} + \\mathrm{SHL}$）的双指令覆盖，此方案始终可行，总成本为 $c_{\\mathrm{ADD}} + c_{\\mathrm{SHL}} = 2.0$（以相同的抽象成本单位计算）。\n\n编译器的寄存器分配器和周围的上下文引入了以下随机约束，假设它们是独立的：\n\n- $k$ 对于 LEA 可编码（即 $k \\in \\{0,1,2,3\\}$）的概率为 $p_{S} = 0.65$。在可编码的条件下，$k$ 的分布为：$\\Pr(k = 0) = 0.25$，$\\Pr(k = 1) = 0.25$，$\\Pr(k = 2) = 0.35$，以及 $\\Pr(k = 3) = 0.15$。\n- 变址寄存器 $y$ 在 LEA 寻址模式中可用（例如，它不是栈指针）的概率为 $p_{I} = 0.90$。\n- 所需的 LEA 寻址形式被当前模式约束（例如，位移形式和寄存器目标）所允许的概率为 $p_{M} = 0.80$。\n\n使用指令选择寻求最小成本覆盖以及期望成本是成本的概率加权平均值这些基本定义。用一个指示器来建模 LEA 的可行性，该指示器要求所有约束同时成立，并假设这些约束是独立的。\n\n在这些条件下，从第一性原理出发，推导覆盖表达式 $x + (y \\ll k)$ 的期望最小成本，并计算最终的数值。将您的最终数值答案四舍五入到五位有效数字。以抽象成本单位表示最终成本。",
            "solution": "设 $C_{min}$ 是表示覆盖该表达式的最小成本的随机变量。我们的任务是计算其期望值 $E[C_{min}]$。\n\n首先，我们定义决定 `LEA` 指令可行性的事件。`LEA` 指令可以将表达式实现为 $x + s \\cdot y$，其中基址寄存器持有 $x$，变址寄存器持有 $y$，比例因子为 $s=2^k$，位移为 $d=0$。可行性要求三个独立的条件同时满足：\n1.  事件 $S$：比例因子 $s=2^k$ 受到硬件支持。支持的比例因子为 $s \\in \\{1, 2, 4, 8\\}$，这对应于移位量 $k$ 属于集合 $\\{0, 1, 2, 3\\}$。此事件的概率为 $\\Pr(S) = p_S = 0.65$。\n2.  事件 $I$：持有值 $y$ 的寄存器可用作变址寄存器。其概率为 $\\Pr(I) = p_I = 0.90$。\n3.  事件 $M$：当前的上下文允许使用 `LEA` 寻址形式。其概率为 $\\Pr(M) = p_M = 0.80$。\n\n设 $F_{LEA}$ 为 `LEA` 指令是一个可行覆盖的事件。由于事件 $S$、$I$ 和 $M$ 是独立的，所以 $F_{LEA}$ 的概率是它们各自概率的乘积：\n$$\n\\Pr(F_{LEA}) = \\Pr(S \\cap I \\cap M) = \\Pr(S)\\Pr(I)\\Pr(M) = p_S p_I p_M\n$$\n代入给定的数值：\n$$\n\\Pr(F_{LEA}) = 0.65 \\times 0.90 \\times 0.80 = 0.468\n$$\n其补事件 $\\neg F_{LEA}$，即 `LEA` 覆盖不可行，其概率为：\n$$\n\\Pr(\\neg F_{LEA}) = 1 - \\Pr(F_{LEA}) = 1 - 0.468 = 0.532\n$$\n\n接下来，我们确定每种情况下的相关成本。指令选择过程寻求最小成本的覆盖。\n双指令（`ADD` + `SHL`）覆盖的成本是恒定的：$C_{AS} = 2.0$。这种覆盖总是可用的。\n`LEA` 覆盖的成本 $C_{LEA}(k)$ 取决于 $k$ 的值：\n$$\nC_{LEA}(k) = \\begin{cases} 1.0  \\text{ if } k \\in \\{0, 1, 2\\} \\\\ 1.3  \\text{ if } k = 3 \\end{cases}\n$$\n如果 `LEA` 指令不可行（事件 $\\neg F_{LEA}$），唯一的选择是 `ADD`+`SHL` 序列，因此成本为 $C_{min} = C_{AS} = 2.0$。\n如果 `LEA` 指令可行（事件 $F_{LEA}$），编译器会选择成本较低的覆盖：$C_{min} = \\min(C_{LEA}(k), C_{AS})$。事件 $F_{LEA}$ 意味着 $k \\in \\{0, 1, 2, 3\\}$。对于这些 $k$ 值，$C_{LEA}(k)$ 要么是 $1.0$ 要么是 $1.3$。两者都小于 $C_{AS} = 2.0$。因此，如果 `LEA` 可行，它总是成本最小的选择。于是，如果 $F_{LEA}$ 发生，$C_{min} = C_{LEA}(k)$。\n\n现在我们可以使用全期望定律，通过以 `LEA` 的可行性为条件来计算期望最小成本 $E[C_{min}]$：\n$$\nE[C_{min}] = \\Pr(F_{LEA}) \\cdot E[C_{min} | F_{LEA}] + \\Pr(\\neg F_{LEA}) \\cdot E[C_{min} | \\neg F_{LEA}]\n$$\n我们已经确定了各个组成部分：\n$E[C_{min} | \\neg F_{LEA}] = C_{AS} = 2.0$。\n$E[C_{min} | F_{LEA}] = E[C_{LEA}(k) | F_{LEA}]$。\n\n期望 $E[C_{LEA}(k) | F_{LEA}]$ 是在 `LEA` 可行的条件下 `LEA` 的期望成本。由于 $F_{LEA} = S \\cap I \\cap M$，且 $k$ 的值与事件 $I$ 和 $M$ 无关，这个条件期望可以简化为：\n$$\nE[C_{LEA}(k) | F_{LEA}] = E[C_{LEA}(k) | S \\cap I \\cap M] = E[C_{LEA}(k) | S]\n$$\n这是在移位量 $k$ 可编码的条件下，`LEA` 的期望成本。我们使用为 $k$ 提供的条件概率来计算它：\n$$\nE[C_{LEA}(k) | S] = \\sum_{j \\in \\{0,1,2,3\\}} C_{LEA}(j) \\cdot \\Pr(k=j | S)\n$$\n代入给定的值：\n$$\nE[C_{LEA}(k) | S] = C_{LEA}(0)\\Pr(k=0|S) + C_{LEA}(1)\\Pr(k=1|S) + C_{LEA}(2)\\Pr(k=2|S) + C_{LEA}(3)\\Pr(k=3|S)\n$$\n$$\nE[C_{LEA}(k) | S] = (1.0)(0.25) + (1.0)(0.25) + (1.0)(0.35) + (1.3)(0.15)\n$$\n$$\nE[C_{LEA}(k) | S] = 1.0 \\cdot (0.25 + 0.25 + 0.35) + 1.3 \\cdot 0.15\n$$\n$$\nE[C_{LEA}(k) | S] = 1.0 \\cdot (0.85) + 0.195 = 0.85 + 0.195 = 1.045\n$$\n所以，当 `LEA` 可行时的期望成本是 $E[C_{min} | F_{LEA}] = 1.045$。\n\n最后，我们将所有值代回 $E[C_{min}]$ 的公式中：\n$$\nE[C_{min}] = (\\Pr(F_{LEA}))(E[C_{min} | F_{LEA}]) + (\\Pr(\\neg F_{LEA}))(E[C_{min} | \\neg F_{LEA}])\n$$\n$$\nE[C_{min}] = (0.468)(1.045) + (0.532)(2.0)\n$$\n$$\nE[C_{min}] = 0.48906 + 1.064 = 1.55306\n$$\n问题要求将答案四舍五入到五位有效数字。\n$$\nE[C_{min}] \\approx 1.5531\n$$\n这就是覆盖该表达式的期望最小成本，以抽象成本单位表示。",
            "answer": "$$ \\boxed{1.5531} $$"
        },
        {
            "introduction": "最后，我们将焦点从成本优化转移到语义保持上——这是编译器一个不可妥协的目标。本练习  探讨了一个经典而微妙的语义不匹配问题：当尝试用算术右移指令 `$SAR(x,1)$` 来优化有符号除法 `$\\mathrm{sdiv}(x,2)$` 时，两者在负数取整模式上的差异。它展示了模式匹配器为何必须使用类型信息和保护条件，以确保生成的代码不仅快，而且绝对正确。",
            "id": "3679147",
            "problem": "编译器后端为树形结构的中间表示（IR）执行指令选择（IS）。考虑一个表示整数除以2的常数次幂的IR节点，写作二元操作符树 $/(x,2)$，其中操作符 $/$ 表示整数除以 $2$，操作数 $x$ 是某种机器整数类型的值。目标架构提供算术右移指令 $SAR(u,k)$，该指令对 $u$ 进行符号扩展并右移 $k$ 位；以及逻辑右移指令 $SHR(u,k)$，该指令对 $u$ 进行零扩展并右移 $k$ 位。编译器的IR是类型化的，并且区分有符号和无符号整数操作。\n\n从以下基本依据出发：\n- 在二进制补码表示法中，算术右移 $SAR(x,1)$ 会复制符号位，在代数上等价于乘以 $2^{-1}$，但对于负奇数 $x$ 会向负无穷大舍入。\n- 逻辑右移 $SHR(x,1)$ 会用零填充高位，对于无符号整数，这对应于除以 $2$，其截断方式与无符号整数除法语义相匹配。\n- 语言或IR中对有符号整数除法的语义可能规定向零舍入；这与对负奇数 $x$ 向负无穷大舍入不同。\n\n你正在设计一个树模式匹配器，它可以在合法的情况下将 $/(x,2)$ 重写为移位操作。哪个选项正确地提出了一个模式，该模式仅在 $x$ 是有符号数时才使用 $SAR(x,1)$，并且还指定了匹配器必须如何结合类型信息或守卫条件以避免非法匹配？\n\nA. 匹配类型化的有符号除法节点 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,1)$，但前提条件是IR的有符号除法语义是向负无穷大舍入，或者已证明的范围分析确保 $x \\ge 0$。否则，不进行匹配。\n\nB. 匹配任何 $x$ 为有符号类型的 $/(x,2)$ 出现，并无条件地将其重写为 $SAR(x,1)$，因为仅凭有符号性就保证了等价性。\n\nC. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SHR(x,1)$，因为无论符号如何，右移总是实现除以 $2$。\n\nD. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,2)$，因为移位量应等于除数。",
            "solution": "核心任务是确定何时可以将有符号整数除以 $2$（表示为 $\\mathrm{sdiv}(x,2)$）合法地替换为算术右移1位（表示为 $\\mathrm{SAR}(x,1)$）。问题强调了一个关键的语义差异：$\\mathrm{sdiv}$ 可能向零舍入，而 $\\mathrm{SAR}$ 向负无穷大舍入。\n\n让我们分析这两个操作在二进制补码下对有符号整数 $x$ 的行为。\n\n令 $f_{sdiv}(x) = \\mathrm{sdiv}(x,2)$ 表示向零舍入（截断）的除法。\n令 $f_{sar}(x) = \\mathrm{SAR}(x,1)$ 表示算术右移，它等价于向负无穷大舍入（向下取整）的除法。\n\n我们来分析 $f_{sdiv}(x)$ 和 $f_{sar}(x)$ 的等价性。\n\n**情况1：$x \\ge 0$（非负整数）**\n对于任何非负数 $z$，向零舍入（$\\mathrm{trunc}(z)$）和向负无穷大舍入（$\\mathrm{floor}(z)$）产生相同的结果。\n例如，$\\mathrm{trunc}(3.5) = 3$ 且 $\\mathrm{floor}(3.5) = 3$。\n因此，对于任何 $x \\ge 0$，我们有：\n$\\mathrm{sdiv}(x,2) = \\mathrm{trunc}(x/2) = \\mathrm{floor}(x/2) = \\mathrm{SAR}(x,1)$\n当已知 $x$ 为非负数时，此转换总是有效的。\n\n**情况2：$x  0$（负整数）**\n对于负数 $z$，如果 $z$ 不是整数，则向零舍入和向负无穷大舍入的结果不同。\n具体来说，当 $z  0$ 时，$\\mathrm{trunc}(z) = \\lceil z \\rceil$，而 $\\mathrm{floor}(z)$ 仍然是向下取整。\n- 如果 $x$ 是负偶数，则 $x/2$ 是一个整数。在这种情况下，$\\mathrm{trunc}(x/2) = \\mathrm{floor}(x/2) = x/2$。\n  例如，如果 $x = -8$，则 $\\mathrm{sdiv}(-8,2) = -4$ 且 $\\mathrm{SAR}(-8,1) = -4$。它们是相等的。\n- 如果 $x$ 是负奇数，则 $x/2$ 不是整数（例如，$-3.5$）。\n  在这种情况下，$\\mathrm{trunc}(x/2) \\ne \\mathrm{floor}(x/2)$。\n  例如，如果 $x = -7$，则 $x/2 = -3.5$。\n  $\\mathrm{sdiv}(-7,2) = \\mathrm{trunc}(-3.5) = -3$\n  $\\mathrm{SAR}(-7,1) = \\mathrm{floor}(-3.5) = -4$\n  结果不相等。\n\n**推导结论**\n只有在IR的有符号除法语义保证向负无穷大舍入，或者可以证明操作数 $x$ 永远不会是负奇数的情况下，用 $\\mathrm{SAR}(x,1)$ 直接替换 $\\mathrm{sdiv}(x,2)$ 才是正确的。后者的一个充分条件是证明 $x \\ge 0$。如果IR语义规定向零舍入（这是C99/C++/Java等语言中的常见标准），则该转换对于负奇数输入是非法的，不能无条件应用。一个正确的模式匹配规则必须将这些条件作为守卫条件包含在内。\n\n### 逐项分析选项\n\n**A. 匹配类型化的有符号除法节点 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,1)$，但前提条件是IR的有符号除法语义是向负无穷大舍入，或者已证明的范围分析确保 $x \\ge 0$。否则，不进行匹配。**\n该选项提出了一个带守卫条件的转换。让我们检查这些守卫条件：\n1.  **守卫条件1：“IR的有符号除法语义是向负无穷大舍入”**：如果源操作（$\\mathrm{sdiv}$）和目标指令（$\\mathrm{SAR}$）具有相同的舍入语义，那么根据定义，该转换对所有输入都是正确的。这是一个有效的条件。\n2.  **守卫条件2：“已证明的范围分析确保 $x \\ge 0$”**：如上所述，对于所有非负数 $x$，两种舍入模式产生相同的结果。因此，如果证明 $x$ 是非负数，则无论IR对负数的舍入模式语义如何，该转换都是正确的。这也是一个有效的条件。\n该规则正确地指出，如果两个守卫条件都不满足，则不进行匹配。这防止了在除法语义是向零舍入时为负奇数输入生成不正确的代码。此选项完美地概括了进行安全正确优化所必需的条件。\n**结论：正确**\n\n**B. 匹配任何 $x$ 为有符号类型的 $/(x,2)$ 出现，并无条件地将其重写为 $SAR(x,1)$，因为仅凭有符号性就保证了等价性。**\n该选项提出了无条件重写。我们的分析表明这是不正确的。当IR除法向零舍入时，对于负奇数，等价性不成立。“仅凭有符号性就保证了等价性”的说法是错误的，因为舍入模式是一个关键因素。例如，如果 $\\mathrm{sdiv}(-3,2)$ 定义为 $-1$，$\\mathrm{SAR}(-3,1)$ 将会计算出 $-2$。\n**结论：错误**\n\n**C. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SHR(x,1)$，因为无论符号如何，右移总是实现除以 $2$。**\n该选项建议对有符号值使用逻辑右移（$\\mathrm{SHR}$）。逻辑右移会在最高有效位插入零。对于最高有效位（符号位）为 $1$ 的负数，此操作将改变符号并产生一个大的正数。例如，对于一个8位有符号整数 $x=-2$（二进制 `11111110`），$\\mathrm{SHR}(x,1)$ 将得到 `01111111`，即 $+127$。正确的结果是 $-1$。“无论符号如何，右移总是实现除以 $2$” 的前提是错误的；必须为正确的整数类型（无符号 vs. 有符号）使用正确类型的移位（逻辑 vs. 算术）。\n**结论：错误**\n\n**D. 只要 $x$ 是有符号数，就匹配 $\\mathrm{sdiv}(x,2)$ 并将其重写为 $SAR(x,2)$，因为移位量应等于除数。**\n该选项使用了正确类型的移位（$\\mathrm{SAR}$）但移位量不正确。右移 $k$ 位等价于除以 $2^k$。因此，要实现除以 $2$，移位量 $k$ 必须是 $1$，因为 $2^1=2$。移位量为 $2$（$\\mathrm{SAR}(x,2)$）将实现除以 $2^2=4$。“移位量应等于除数”的说法是根本错误的。\n**结论：错误**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}