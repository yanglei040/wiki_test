{
    "hands_on_practices": [
        {
            "introduction": "理解链接时优化（LTO）最直观的方式之一就是看它如何实实在在地减小最终可执行文件的大小。本练习将通过一个具体场景，向您展示 LTO 如何通过全程序分析识别并移除无法访问的代码，进而使链接器能够回收这些代码所引用的数据（如字符串字面量）。通过亲手计算内存节省量，您将深入理解 LTO 在死代码和死数据消除方面的威力 。",
            "id": "3650482",
            "problem": "考虑一个由三个翻译单元组成的程序，每个翻译单元都被编译成一个目标文件。构建系统使用链接时优化 (LTO) 和一个支持可合并字符串节的链接器。LTO 在一个通用的中间表示 (IR) 上执行全程序分析，而链接器通过识别以 null 结尾的字符串池来合并跨输入文件的相同字符串。目标文件将每个字符串字面量放入其自己的可合并输入节中，该节被标记为用于字符串合并，元素大小为 $1$ 字节。链接器被配置为在 LTO 移除不可达代码后执行节的垃圾回收 (GC-sections)。目标平台将最终的只读数据输出节对齐到 $16$ 字节，为此节预留的内存被建模为大于或等于所有保留字符串总字节数的 $16$ 的最小倍数（每个字符串包括其结尾的 null 字符）。\n\n这些翻译单元贡献了以下字符串字面量（每次出现最初都存在于其自己的输入节中）：\n- 单元 A 贡献了字面量：\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"。\n- 单元 B 贡献了字面量：\"beta\", \"delta\", \"alpha\", \"zeta\"。\n- 单元 C 贡献了字面量：\"eta\", \"theta\", \"alpha\", \"epsilon\", \"iota\"。\n\n假设不同字符串的长度如下（仅计算字符，不包括 null 终止符）：$\\text{\"alpha\"}$ 长度为 $5$，$\\text{\"beta\"}$ 长度为 $4$，$\\text{\"gamma\"}$ 长度为 $5$，$\\text{\"delta\"}$ 长度为 $5$，$\\text{\"epsilon\"}$ 长度为 $7$，$\\text{\"zeta\"}$ 长度为 $4$，$\\text{\"eta\"}$ 长度为 $3$，$\\text{\"theta\"}$ 长度为 $5$，$\\text{\"iota\"}$ 长度为 $4$。每个保留的字符串占据其长度加上 $1$ 字节用于 null 终止符的空间。\n\n在非 LTO 和 LTO 配置中，链接器都会合并跨输入节的相同字符串，因此最终输出节中只保留每个不同字符串的一个副本。然而，在 LTO 下，全程序分析证明某些函数是不可达的并移除了它们，这反过来在 GC-sections 运行之前去除了对它们关联的字符串字面量的引用。具体来说，启用 LTO 后，引用字符串 $\\text{\"gamma\"}$、$\\text{\"zeta\"}$ 和 $\\text{\"iota\"}$ 的函数被消除，使得这些字符串变为未被引用状态，从而被 GC-sections 移除。在没有 LTO 的情况下，所有列出的函数都被视为可达，因此在链接时合并之前，没有任何列出的字符串被消除。\n\n将内存节省量 $\\Delta$（单位为字节）定义为未使用 LTO 时的合并后只读数据节的最终对齐大小与使用 LTO 时的合并后只读数据节的最终对齐大小之间的差值。请将 $\\Delta$ 精确计算为整数字节数。以字节为单位表示你的答案。无需四舍五入。",
            "solution": "首先将根据所需标准对问题进行验证。\n\n### 问题验证\n\n#### 步骤 1：提取已知条件\n\n- **系统配置**：一个由 $3$ 个翻译单元（A、B、C）组成的程序，被编译成目标文件。构建系统使用链接时优化 (LTO) 和一个链接器。\n- **链接器特性**：\n    1.  合并跨输入文件的相同、以 null 结尾的字符串。每个字符串字面量位于其自己的可合并输入节中，元素大小为 $1$ 字节。\n    2.  执行节的垃圾回收 (GC-sections) 以移除不可达的代码和数据。\n- **内存模型**：\n    1.  最终的只读数据输出节对齐到 $16$ 字节。\n    2.  此节的大小是大于或等于所有保留字符串总大小的 $16$ 的最小倍数。\n    3.  每个字符串的大小是其字符长度加上 $1$ 字节用于结尾的 null 字符。\n- **各单元的字符串字面量**：\n    - 单元 A：\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"\n    - 单元 B：\"beta\", \"delta\", \"alpha\", \"zeta\"\n    - 单元 C：\"eta\", \"theta\", \"alpha\", \"epsilon\", \"iota\"\n- **字符串长度（仅字符）**：\n    - $\\text{length(\"alpha\")} = 5$\n    - $\\text{length(\"beta\")} = 4$\n    - $\\text{length(\"gamma\")} = 5$\n    - $\\text{length(\"delta\")} = 5$\n    - $\\text{length(\"epsilon\")} = 7$\n    - $\\text{length(\"zeta\")} = 4$\n    - $\\text{length(\"eta\")} = 3$\n    - $\\text{length(\"theta\")} = 5$\n    - $\\text{length(\"iota\")} = 4$\n- **LTO 效果**：启用 LTO 后，引用 \"gamma\"、\"zeta\" 和 \"iota\" 的函数被消除。因此，这三个字符串变为未被引用状态，并被 GC-sections 移除。\n- **非 LTO 行为**：不使用 LTO 时，所有列出的字符串都被视为被引用并被保留。\n- **目标**：计算内存节省量 $\\Delta$，定义为未使用 LTO 和使用 LTO 时的最终对齐节大小之差。$\\Delta = S_{\\text{no-LTO}} - S_{\\text{LTO}}$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n根据既定标准对问题陈述进行评估。\n\n1.  **科学基础**：该问题基于编译器构造和链接器设计中公认的原则。LTO、字符串合并（特别是针对字符串的 COMDAT 折叠）以及节的垃圾回收是现代工具链（如 GCC 和 LLVM/Clang）中的标准特性。所描述的场景是这些优化如何影响最终二进制文件大小的一个现实且实际的例子。\n2.  **适定性**：该问题是适定的。它提供了所有必要的数据（字符串内容、长度、LTO 行为、对齐规则）和一个明确的目标。可以从给定信息中推导出一个唯一、稳定且有意义的解。\n3.  **客观性**：语言精确且技术性强。它描述了一个计算过程，没有歧义、主观性或基于观点的论断。\n4.  **完整性与一致性**：该问题是自包含的。所提供的数据是一致的（例如，字符串列表和长度不矛盾）。没有缺失或矛盾的约束。\n5.  **可行性**：在软件编译和链接的背景下，这些条件是完全可行的。\n\n满足了有效问题的所有标准。\n\n#### 步骤 3：结论与行动\n\n该问题有效。将提供完整的解决方案。\n\n### 解题过程\n\n该问题要求计算由链接时优化 (LTO) 带来的内存节省量。这通过比较两种情况下的只读数据节的最终大小来确定：不使用 LTO 和使用 LTO。\n\n#### 场景 1：不使用 LTO 进行编译\n\n在这种情况下，翻译单元中列出的所有字符串都被视为可达。链接器将合并相同的字符串，以便只存储每个唯一字符串的一个副本。\n\n首先，我们确定所有三个单元中的唯一字符串集合。\n- 单元 A：$\\{\"\\text{alpha}\", \"\\text{beta}\", \"\\text{gamma}\", \"\\text{delta}\", \"\\text{epsilon}\"\\}$\n- 单元 B：$\\{\"\\text{beta}\", \"\\text{delta}\", \"\\text{alpha}\", \"\\text{zeta}\"\\}$\n- 单元 C：$\\{\"\\text{eta}\", \"\\text{theta}\", \"\\text{alpha}\", \"\\text{epsilon}\", \"\\text{iota}\"\\}$\n\n这些集合的并集给出了唯一的字符串的完整集合 $U$：\n$U = \\{\"\\text{alpha}\", \"\\text{beta}\", \"\\text{gamma}\", \"\\text{delta}\", \"\\text{epsilon}\", \"\\text{zeta}\", \"\\text{eta}\", \"\\text{theta}\", \"\\text{iota}\"\\}$\n\n接下来，我们计算每个唯一字符串在内存中的大小。字符串的大小是其长度加上用于 null 终止符的 $1$ 字节。\n- 大小(\"alpha\") = $5 + 1 = 6$ 字节\n- 大小(\"beta\") = $4 + 1 = 5$ 字节\n- 大小(\"gamma\") = $5 + 1 = 6$ 字节\n- 大小(\"delta\") = $5 + 1 = 6$ 字节\n- 大小(\"epsilon\") = $7 + 1 = 8$ 字节\n- 大小(\"zeta\") = $4 + 1 = 5$ 字节\n- 大小(\"eta\") = $3 + 1 = 4$ 字节\n- 大小(\"theta\") = $5 + 1 = 6$ 字节\n- 大小(\"iota\") = $4 + 1 = 5$ 字节\n\n不使用 LTO 时数据节的总未对齐大小 $B_{\\text{no-LTO}}$ 是这些唯一字符串大小的总和：\n$$B_{\\text{no-LTO}} = 6 + 5 + 6 + 6 + 8 + 5 + 4 + 6 + 5 = 51 \\text{ 字节}$$\n\n最终节大小 $S_{\\text{no-LTO}}$ 必须对齐到 $16$ 字节。这是大于或等于 $B_{\\text{no-LTO}}$ 的 $16$ 的最小倍数。我们需要找到最小的整数 $k$ 使得 $16k \\geq 51$。\n$k = \\lceil \\frac{51}{16} \\rceil = \\lceil 3.1875 \\rceil = 4$。\n因此，对齐后的大小为：\n$$S_{\\text{no-LTO}} = 16 \\times 4 = 64 \\text{ 字节}$$\n\n#### 场景 2：使用 LTO 进行编译\n\n使用 LTO 时，全程序分析确定字符串 \"gamma\"、\"zeta\" 和 \"iota\" 未被引用。因此，链接器的 GC-sections 过程将从最终的二进制文件中移除它们。\n\nLTO 后保留的唯一字符串集合 $U'$ 是原始集合 $U$ 减去被移除的字符串：\n$U' = U \\setminus \\{\"\\text{gamma}\", \"\\text{zeta}\", \"\\text{iota}\"\\} = \\{\"\\text{alpha}\", \"\\text{beta}\", \"\\text{delta}\", \"\\text{epsilon}\", \"\\text{eta}\", \"\\text{theta}\"\\}$\n\n现在，我们计算使用 LTO 时数据节的总未对齐大小 $B_{\\text{LTO}}$。我们对 $U'$ 中字符串的大小求和。\n- 大小(\"alpha\") = $6$ 字节\n- 大小(\"beta\") = $5$ 字节\n- 大小(\"delta\") = $6$ 字节\n- 大小(\"epsilon\") = $8$ 字节\n- 大小(\"eta\") = $4$ 字节\n- 大小(\"theta\") = $6$ 字节\n\n$$B_{\\text{LTO}} = 6 + 5 + 6 + 8 + 4 + 6 = 35 \\text{ 字节}$$\n\n最终对齐后的节大小 $S_{\\text{LTO}}$ 是大于或等于 $B_{\\text{LTO}}$ 的 $16$ 的最小倍数。我们找到最小的整数 $k'$ 使得 $16k' \\geq 35$。\n$k' = \\lceil \\frac{35}{16} \\rceil = \\lceil 2.1875 \\rceil = 3$。\n因此，对齐后的大小为：\n$$S_{\\text{LTO}} = 16 \\times 3 = 48 \\text{ 字节}$$\n\n#### 内存节省量计算\n\n内存节省量 $\\Delta$ 是不使用 LTO 时的对齐大小与使用 LTO 时的对齐大小之差。\n$$\\Delta = S_{\\text{no-LTO}} - S_{\\text{LTO}}$$\n$$\\Delta = 64 - 48 = 16 \\text{ 字节}$$\n\n由于 LTO 和后续的垃圾回收所节省的内存为 $16$ 字节。",
            "answer": "$$\n\\boxed{16}\n$$"
        },
        {
            "introduction": "链接时优化的核心在于它能够获得整个程序的“全局视野”，从而做出比单个编译单元更优的决策。当来自不同模块的信息发生冲突时，LTO 如何解决这些矛盾呢？本练习  提出了一个经典情景：同一个函数在一个模块中被建议内联，而在另一个模块中被禁止内联。通过分析 LTO 如何权衡和选择，您将学会编译器在进行全局优化时所遵循的保守且安全的决策原则。",
            "id": "3650523",
            "problem": "考虑一个程序被分割到两个翻译单元中，表示为 $M_1$ 和 $M_2$。一个函数 $g$ 在共享头文件 $H$ 中声明，该头文件被 $M_1$ 和 $M_2$ 同时包含。在 $M_1$ 中，$g$ 的声明被一个请求内联的内联指令所注解（例如，一个类似于 $always\\_inline$ 的厂商属性）。在 $M_2$ 中，$g$ 的定义被一个禁止内联的内联指令所注解（例如，一个类似于 $noinline$ 的厂商属性）。假设以下条件成立：\n\n- 构建过程使用链接时优化（LTO），因此编译器在链接时拥有对中间表示的全局程序视图。\n- 优化级别很高（例如，$-O3$），在没有任何冲突注解的情况下，内联器会在大多数调用点内联像 $g$ 这样的小型纯函数。\n- 函数 $g$ 是非递归的，函数体简单，并且在合法性检查下完全符合内联条件（没有可变参数，没有间接调用，且其定义对链接器可见）。\n- 程序的可观察行为由一个从程序 $P$ 和输入 $x$ 到其可观察输出的映射 $B(P;x)$ 定义，优化器必须确保转换后的程序 $\\tilde{P}$ 对所有 $x$ 都满足 $B(P;x) = B(\\tilde{P};x)$。\n\n在链接时，编译器必须合并来自 $M_1$（请求内联）和 $M_2$（禁止内联）的关于 $g$ 的注解信息。将内联注解视为关于 $g$ 的一组转换约束和提示的元素。假设这些注解上存在一个偏序关系 $\\preceq$，其中更严格的约束在该序中被认为是“更大”的（即，当冲突发生时，它们支配较弱的提示），并且跨模块的合并会选择一个与该偏序关系一致的、保守的、保持语义的组合。\n\n哪个陈述最能描述LTO如何解决这些冲突的注解，以及在最终链接的二进制文件中对 $g$ 的调用会发生什么？\n\nA. 对 $g$ 的所有调用都在各模块中被内联，因为 $always\\_inline$ 请求占主导地位；如果任何调用点的内联失败，链接就会失败。\n\nB. 对 $g$ 的调用均不被内联；LTO通过遵循比 $always\\_inline$ 提示更严格的 $noinline$ 约束来解决冲突以保持语义，从而产生一个禁止内联的单一有效属性集。\n\nC. 在 $M_1$ 中编译的对 $g$ 的调用被内联，而在 $M_2$ 中编译的调用则不被内联，因为局部声明的注解只控制局部的调用点，并且LTO尊重每个模块的控制，而不是一个统一的函数级属性。\n\nD. 只有当 $g$ 在链接时被内部化时，对 $g$ 的调用才会被内联；否则，对于在优化级别 $O \\ge 2$ 下编译的调用点，$always\\_inline$ 请求被优先考虑，并且冲突仅触发一个警告而不改变内联行为。",
            "solution": "问题陈述具有科学依据，提法恰当，客观，并提供了足够的信息以根据编译器理论推导出唯一解。它描述了现代软件编译中一个有效但复杂的场景，涉及链接时优化（LTO）和冲突的函数属性。因此，该问题是有效的。\n\n问题的核心在于解决函数 $g$ 的冲突注解。在翻译单元 $M_1$ 中，$g$ 被注解为一个始终内联的提示 (`always_inline`)。在定义 $g$ 的翻译单元 $M_2$ 中，它被注解为一个永不内联的指令 (`noinline`)。构建过程使用LTO，这意味着编译器框架在链接时对程序的中间表示有一个整体视图，使其能够全局地解决此类冲突。\n\n问题指定了解决机制：注解是一个集合的元素，它们被合并，并且合并过程遵循一个偏序关系 $\\preceq$，其中“更严格的约束在该序中被认为是‘更大’的”。选择一个保守的、保持语义的组合。\n\n让我们从严格性的角度分析这两个注解：\n1.  `always_inline` 指令是一个性能提示。它鼓励优化器执行一个它原本可能不会执行的动作（内联）。虽然这是一个强提示，但如果内联不合法或不可能（例如，如果函数的地址被获取并且必须可用于函数指针），编译器通常保留忽略它的权利。它指导优化，但并不严格禁止生成非内联的函数体。\n2.  `noinline` 指令是一个严格的约束。它禁止优化器执行内联转换。如果不内联函数（因为这是默认的调用约定），那么保持语义（如条件 $B(P;x) = B(\\tilde{P};x)$ 所要求的）总是能得到保证。`noinline` 属性从优化器中移除了一个选项，因此比一个偏好某个选项的提示更严格地限制了其行为。\n\n给定偏序关系 $\\preceq$，其中更严格的约束是“更大”的，那么 `noinline` 指令就大于 `always_inline` 指令。即：`always_inline` $\\preceq$ `noinline`。\n\nLTO过程必须合并来自所有翻译单元的关于 $g$ 的属性。它看到属性集 {`always_inline`, `noinline`}。根据与偏序关系一致的合并规则，“最大”的元素 `noinline` 将占主导地位。这也是最保守和最安全的选择。编译器必须遵守禁令而不是建议，以确保正确性和可预测的行为，特别是因为 `noinline` 属性可能由于优化器不立即明了的原因（例如，调试、打补丁或特定的地址敏感代码）而至关重要。\n\n因此，在全程序级别，LTO框架通过将有效的 `noinline` 属性分配给函数 $g$ 的单一、合并后的表示来解决冲突。因此，整个程序中对 $g$ 的所有调用点都不会被内联。编译器将为 $g$ 生成一个非内联的函数体，并且所有调用点都将被编译为标准函数调用。\n\n根据这个推导，我们可以评估各个选项：\n\nA. 对 $g$ 的所有调用都在各模块中被内联，因为 $always\\_inline$ 请求占主导地位；如果任何调用点的内联失败，链接就会失败。\n这是 **不正确** 的。`always_inline` 请求是一个提示，而不是一个严格的要求，并且它比 `noinline` 禁令的限制性要小。在保守的合并方案中，`noinline` 约束占主导地位。关于链接失败的说法对于 `always_inline` 通常也是错误的。\n\nB. 对 $g$ 的调用均不被内联；LTO通过遵循比 $always\\_inline$ 提示更严格的 $noinline$ 约束来解决冲突以保持语义，从而产生一个禁止内联的单一有效属性集。\n这是 **正确** 的。它准确地将 `noinline` 识别为更严格的约束，并正确地描述了LTO下的保守解决机制。结果是在程序级别为函数 $g$ 生成一个统一的 `noinline` 属性，从而阻止在所有调用点进行内联。\n\nC. 在 $M_1$ 中编译的对 $g$ 的调用被内联，而在 $M_2$ 中编译的调用则不被内联，因为局部声明的注解只控制局部的调用点，并且LTO尊重每个模块的控制，而不是一个统一的函数级属性。\n这是 **不正确** 的。这描述了在没有LTO的情况下会发生的行为。LTO的全部目的就是创建一个统一的、全程序的视图并全局应用优化。它会合成一个具有单一、合并后属性集的 $g$ 的表示，而不是区别对待来自 $M_1$ 和 $M_2$ 的调用。\n\nD. 只有当 $g$ 在链接时被内部化时，对 $g$ 的调用才会被内联；否则，对于在优化级别 $O \\ge 2$ 下编译的调用点，$always\\_inline$ 请求被优先考虑，并且冲突仅触发一个警告而不改变内联行为。\n这是 **不正确** 的。虽然内部化是一个常见的LTO概念，但它不能解决属性冲突。主要的错误在于声称 `always_inline` 被优先考虑。这与遵循更严格约束的原则相矛盾。虽然可能会发出警告，但行为 *确实* 因冲突解决而改变，即选择了 `noinline`。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "尽管 LTO 功能强大，但它并非无所不能，它必须在平台应用程序二进制接口（ABI）规定的框架内运作。本练习  探讨了 LTO 与动态链接这一关键系统机制之间的相互作用，特别是与符号劫持（Symbol Interposition）相关的场景。通过这个案例，您将理解为什么 LTO 不能随意地跨共享库边界内联函数，因为它必须保留动态链接器在加载时重定向函数调用的能力，这是现代操作系统灵活性和可维护性的基石。",
            "id": "3650484",
            "problem": "一个可执行文件 $E$ 调用一个在共享对象 $L$ (例如, $libapi.so$) 中定义的函数 $api$。第二个共享对象 $I$ (例如, $liblog.so$) 通过环境变量机制 $LD\\_PRELOAD$ 加载，并定义了其自己的 $api$ 函数，该函数会记录调用，然后使用动态符号查找将调用转发到下一个定义。假设所有对象都使用位置无关代码编译，并且可执行文件链接到 $L$。构建过程启用了链接时优化 (LTO)，这允许在链接时对呈现给链接器的编译单元进行全程序优化。\n\n平台遵循可执行与可链接格式 (ELF) System V 应用程序二进制接口 (ABI)。在此 ABI 中，从共享对象导出的具有默认可见性 (即，可见性为 $\\mathrm{STV\\_DEFAULT}$) 和全局绑定 (即，绑定为 $\\mathrm{STB\\_GLOBAL}$) 的符号是可介入的 (interposable)：在加载时，动态链接器可能会将其引用解析到解析顺序中更早出现的另一个共享对象中的不同定义。从可执行文件对此类符号的引用是通过过程链接表 ($PLT$) 和全局偏移表 ($GOT$)进行的，而环境变量 $LD\\_PRELOAD$ 会安排预加载的对象被首先搜索，从而为日志记录启用符号介入。C 和 C$++$ 语言的“as-if”规则要求任何优化，包括 LTO，都必须保留由语言和平台 ABI 定义的可观察行为；对于可介入的符号，该可观察行为包括动态链接器在加载时重定向调用的能力。\n\n另请考虑 $L$ 定义了一个辅助函数 $helper$，它不属于其公共应用程序编程接口 (API) 的一部分。两种情况是相关的：$helper$ 以默认可见性导出 (情况 $H\\_D$)，或者 $helper$ 被赋予隐藏可见性 (情况 $H\\_H$) 。在情况 $H\\_D$下，$helper$ 是可介入的；在情况 $H\\_H$ 下，$helper$ 在 $L$ 外部不可见，因此不可介入。\n\n根据这些第一性原理和事实，确定哪些陈述正确描述了 LTO 必须如何尊重符号介入，并避免内联可能绕过由 $I$ 提供的日志记录的调用。\n\n选择所有适用的选项：\n\nA. 当 $L$ 中的 $api$ 具有默认可见性并从 $E$ 调用时，LTO 必须将该调用视为可抢占的 (preemptible)，并且不得将 $api$ 内联到 $E$ 中。在 $L$ 内部，LTO 可以在情况 $H\\_H$ 下将 $helper$ 内联到 $api$ 中，因为 $helper$ 是不可介入的，但在情况 $H\\_D$ 下必须避免这样做。\n\nB. 即使 $I$ 通过 $LD\\_PRELOAD$ 介入了 $api$，LTO 也可以将 $api$ 内联到 $E$ 中，因为动态链接器仍然会在任何内联代码执行之前调用被介入的定义。\n\nC. 在 $L$ 中将 $api$ 标记为隐藏可见性允许 LTO 将 $api$ 内联到 $E$ 中，同时仍然允许 $I$ 通过 $LD\\_PRELOAD$ 介入该调用。\n\nD. 使用选项 `-fno-semantic-interposition` 进行编译是在保留介入的同时启用对 $api$ 到 $E$ 的激进 LTO 内联的正确方法。\n\nE. 如果 $api$ 是 $E$ 中的一个外部引用，并在 $L$ 中以默认可见性定义，LTO 必须将该调用建模为通过 $PLT$/$GOT$ 指向一个可抢占的目标，并且可以在 $E$ 中执行局部优化，但不能内联或去虚拟化 $api$，否则会改变平台定义的可观察行为，该行为允许 $LD\\_PRELOAD$ 介入。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n**步骤 1：提取已知条件**\n-   一个可执行文件 $E$ 调用一个在共享对象 $L$ 中定义的函数 $api$。\n-   第二个共享对象 $I$ 通过环境变量机制 $LD\\_PRELOAD$ 加载。\n-   $I$ 定义了其自己的 $api$ 函数，该函数会记录调用，然后使用动态符号查找将调用转发到下一个定义。\n-   所有对象都使用位置无关代码 ($PIC$) 编译。\n-   $E$ 链接到 $L$。\n-   构建过程启用了链接时优化 (LTO)。\n-   平台遵循可执行与可链接格式 ($ELF$) System V 应用程序二进制接口 ($ABI$) 。\n-   从共享对象导出的具有默认可见性 ($\\mathrm{STV\\_DEFAULT}$) 和全局绑定 ($\\mathrm{STB\\_GLOBAL}$) 的符号是可介入的。\n-   从可执行文件对此类符号的引用是通过过程链接表 ($PLT$) 和全局偏移表 ($GOT$)进行的。\n-   $LD\\_PRELOAD$ 会安排预加载的对象被首先搜索，从而启用符号介入。\n-   C 和 C$++$ 的“as-if”规则要求优化必须保留由语言和平台 $ABI$ 定义的可观察行为。\n-   对于可介入的符号，可观察行为包括动态链接器在加载时重定向调用的能力。\n-   $L$ 定义了一个辅助函数 $helper$。\n-   情况 $H\\_D$：$helper$ 以默认可见性导出并且是可介入的。\n-   情况 $H\\_H$：$helper$ 被赋予隐藏可见性并且是不可介入的。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学性基础：** 问题牢固地建立在编译器设计、链接器和操作系统的既定原则之上，特别是基于 $ELF$ 的系统上的动态链接行为。所有术语（$LTO$, $PIC$, $PLT/GOT$, $LD\\_PRELOAD$, 符号可见性）都是计算机科学中的标准概念。\n-   **良构性 (Well-Posed)：** 问题陈述清晰，提供了足够的前提和一个精确的问题，允许基于所提供的规则推导出唯一的解决方案。\n-   **客观性：** 语言是技术性的、无歧义的，没有主观或基于观点的断言。\n-   问题没有表现出事实不健全、不完整或模糊不清等缺陷。它描述了编译时优化和运行时链接行为之间一个现实且不平凡的相互作用。\n\n**步骤 3：结论和行动**\n问题陈述有效。将根据提供的原则推导解决方案。\n\n**推导**\n\n分析的关键在于“as-if”规则，如前所述，该规则延伸到保留平台 $ABI$ 的可观察行为。可观察行为的关键部分是通过动态链接器在加载时对具有默认可见性的符号进行介入的能力。只要不改变这种可观察行为，链接时优化 ($LTO$) 就被允许执行任何转换。\n\n1.  **模块间调用 (从 $E$ 到 $L$ 中的 $api$)**：\n    函数 $api$ 具有默认可见性，意味着它从 $L$ 导出并且被设计为可介入的。可执行文件 $E$ 是与共享对象 $L$ 分开的模块。为了允许动态链接器截获该调用，编译器必须在 $E$ 中生成通过 $PLT$ 和 $GOT$ 进行间接调用的代码。$LD\\_PRELOAD$ 机制确保当动态链接器在加载时解析符号时，它会在找到 $L$ 中的 $api$ 定义之前先找到 $I$ 中的定义。链接器随后会修补 $api$ 的 $GOT$ 条目，使其指向 $I$ 中的实现。如果 LTO 将 $api$ 的主体（来自 $L$）直接内联到 $E$ 中，那么 $api$ 的调用指令和整个 $PLT/GOT$ 查找机制将从 $E$ 中被消除。这将使动态链接器无法将调用重定向到 $I$ 中被介入的版本，从而破坏了介入机制。这构成了一种可观察行为的改变，违反了主要约束。因此，LTO 必须将从 $E$到 $api$ 的调用视为对一个*可抢占* (preemptible) 目标的调用，并且不得内联它。该调用必须保持为通过 $PLT/GOT$ 的间接调用。\n\n2.  **模块内调用 (在 $L$ 内部)**：\n    我们考虑从共享对象 $L$ 内部对 $helper$ 函数的调用。\n    -   **情况 $H\\_H$ (隐藏可见性)**：当 $helper$ 被赋予隐藏可见性时，它作为对工具链的明确指令，表明此符号是 $L$ 内部的。它不会在动态符号表中导出，因此保证是不可介入的。由于 LTO 过程在同一模块 ($L$) 中既能看到调用点（在 $api$ 内）也能看到 $helper$ 的定义，并且知道该定义在运行时不能被替换，因此它可以自由地执行优化，例如将 $helper$ 内联到 $api$ 中。这并不违反“as-if”规则，因为 $ABI$ 对隐藏符号的可介入性没有做出任何承诺。\n    -   **情况 $H\\_D$ (默认可见性)**：当 $helper$ 具有默认可见性时，它是一个导出的、可介入的符号，就像 $api$ 一样。另一个库有可能被预加载以覆盖 $helper$。如果 LTO 将 $helper$ 的定义内联到 $api$ 中，它将硬编码内部实现并阻止任何潜在的介入。这将违反 $helper$ 符号的可观察行为。因此，在这种情况下，LTO 必须避免内联 $helper$，并且必须通过 $L$ 自己的 $PLT/GOT$ 生成一个间接调用以允许抢占。\n\n**逐项分析**\n\n**A. 当 $L$ 中的 $api$ 具有默认可见性并从 $E$ 调用时，LTO 必须将该调用视为可抢占的，并且不得将 $api$ 内联到 $E$ 中。在 $L$ 内部，LTO 可以在情况 $H\\_H$ 下将 $helper$ 内联到 $api$ 中，因为 $helper$ 是不可介入的，但在情况 $H\\_D$ 下必须避免这样做。**\n该陈述准确地反映了推导出的原则。对可介入符号 ($api$) 的模块间调用不能被内联。对不可介入符号（情况 $H\\_H$ 下的 $helper$）的模块内调用可以被内联。对可介入符号（情况 $H\\_D$ 下的 $helper$）的模块内调用不能被内联。\n**结论：正确。**\n\n**B. 即使 $I$ 通过 $LD\\_PRELOAD$ 介入了 $api$，LTO 也可以将 $api$ 内联到 $E$ 中，因为动态链接器仍然会在任何内联代码执行之前调用被介入的定义。**\n这是不正确的。内联是在编译/链接时将函数调用替换为函数主体的操作。如果 $api$被内联到 $E$ 中，对 $api$ 的调用在最终的可执行代码中将不复存在。动态链接器没有调用可以重定向。来自 $L$ 的 $api$ 定义的内联代码将直接执行，完全绕过 $I$ 中的介入函数。\n**结论：不正确。**\n\n**C. 在 $L$ 中将 $api$ 标记为隐藏可见性允许 LTO 将 $api$ 内联到 $E$ 中，同时仍然允许 $I$ 通过 $LD\\_PRELOAD$ 介入该调用。**\n这个陈述是自相矛盾的。如果 $api$ 在 $L$ 中具有隐藏可见性，根据定义，它就不会在动态符号表中导出，并且不能从像 $E$ 这样的外部模块引用（这将是一个链接时错误），也不能被 $I$ 介入。关于隐藏符号可以被介入的前提是错误的。\n**结论：不正确。**\n\n**D. 使用选项 `-fno-semantic-interposition` 进行编译是在保留介入的同时启用对 $api$ 到 $E$ 的激进 LTO 内联的正确方法。**\n这是不正确的。编译器选项 `-fno-semantic-interposition` 指示编译器*假设*公共符号在其定义模块内部不会被介入。这通过*牺牲*在这些情况下可介入性的保证，来允许更激进的模块内优化（例如在情况 $H\\_D$ 下内联 $helper$）。它并没有提供一种神奇的方法来执行模块间内联（将 $api$ 内联到 $E$ 中），同时又能保留这种内联会破坏的介入机制。该陈述描述了一个矛盾。\n**结论：不正确。**\n\n**E. 如果 $api$ 是 $E$ 中的一个外部引用，并在 $L$ 中以默认可见性定义，LTO 必须将该调用建模为通过 $PLT$/$GOT$ 指向一个可抢占的目标，并且可以在 $E$ 中执行局部优化，但不能内联或去虚拟化 $api$，否则会改变平台定义的可观察行为，该行为允许 $LD\\_PRELOAD$ 介入。**\n这是对 LTO 约束的精确而正确的描述。调用必须被建模为通过 $PLT/GOT$ 对一个可抢占（可替换）目标的间接调用。这允许动态链接器执行其功能。内联会消除这种间接性，因此是被禁止的，因为它会改变由 $ABI$ 保证的可观察行为。该陈述正确地指出了 LTO 能做什么和不能做什么。\n**结论：正确。**",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}