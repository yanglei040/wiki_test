{
    "hands_on_practices": [
        {
            "introduction": "在深入研究波动率的建模与预测之前，我们必须首先理解模型的基本性质。ARCH 模型提供了一个框架，其中条件方差取决于过去的冲击，而一个关键特性是其无条件方差，即过程将回归到的长期平均波动水平。这项练习将通过推导 ARCH(1) 模型的无条件方差，巩固您对模型参数如何决定其长期稳态行为的理解，并阐明波动率持续性这一核心概念 。",
            "id": "2411107",
            "problem": "考虑一阶自回归条件异方差模型（ARCH(1)）。令 $\\{\\varepsilon_t\\}$ 表示一个由 $\\varepsilon_t = \\sigma_t z_t$ 定义的均值为零的收益创新过程，其中 $\\{z_t\\}$ 是独立同分布（i.i.d.）的随机变量，满足 $\\mathbb{E}[z_t] = 0$，$\\mathbb{V}\\mathrm{ar}(z_t) = 1$，且 $z_t$ 独立于所有在 $t-1$ 时刻及之前的所有信息。条件方差根据 $\\sigma_t^2 = \\alpha_0 + \\alpha_1 \\varepsilon_{t-1}^2$ 演变，其中 $\\alpha_0 > 0$ 且 $0 \\le \\alpha_1  1$。假设该过程是协方差平稳的。\n\n仅使用上述定义以及条件期望和方差的基本性质，推导无条件方差 $\\mathbb{V}\\mathrm{ar}(\\varepsilon_t)$，并以 $\\alpha_0$ 和 $\\alpha_1$ 的闭式表达式表示。然后，简要地用文字解释当 $\\alpha_1 \\to 1^{-}$ 时，这一结果对波动率的行为意味着什么。\n\n请将无条件方差的最终结果以单个闭式表达式的形式给出。不需要进行数值计算。",
            "solution": "问题陈述需经过验证。\n\n**步骤1：提取已知条件**\n- 模型：一阶自回归条件异方差模型，记为 ARCH(1)。\n- 过程：均值为零的收益创新过程 $\\{\\varepsilon_t\\}$。\n- 创新的定义：$\\varepsilon_t = \\sigma_t z_t$。\n- 误差项性质：$\\{z_t\\}$ 是独立同分布（i.i.d.）的随机变量，满足 $\\mathbb{E}[z_t] = 0$ 和 $\\mathbb{V}\\mathrm{ar}(z_t) = 1$。\n- 独立性条件：$z_t$ 独立于所有在 $t-1$ 时刻及之前的信息，我们将其表示为信息集 $\\mathcal{F}_{t-1}$。\n- 条件方差演变：$\\sigma_t^2 = \\alpha_0 + \\alpha_1 \\varepsilon_{t-1}^2$。\n- 参数约束：$\\alpha_0 > 0$ 和 $0 \\le \\alpha_1  1$。\n- 平稳性假设：过程 $\\{\\varepsilon_t\\}$ 是协方差平稳的。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是基于成熟的ARCH模型在金融计量经济学中的一个标准推导。问题是适定的，具有充分条件（$\\alpha_0 > 0$， $0 \\le \\alpha_1  1$ 和协方差平稳性）以确保存在唯一的稳定解。语言客观且精确。该问题不违反任何无效性标准。它是一个可形式化、完整且可验证的数学问题。\n\n**步骤3：结论与行动**\n此问题是**有效的**。将提供解答。\n\n目标是推导过程 $\\{\\varepsilon_t\\}$ 的无条件方差，记为 $\\mathbb{V}\\mathrm{ar}(\\varepsilon_t)$。无条件方差定义为 $\\mathbb{V}\\mathrm{ar}(\\varepsilon_t) = \\mathbb{E}[\\varepsilon_t^2] - (\\mathbb{E}[\\varepsilon_t])^2$。\n\n首先，我们确定无条件均值 $\\mathbb{E}[\\varepsilon_t]$。我们使用全期望定律，以信息集 $\\mathcal{F}_{t-1}$ 为条件：\n$$\n\\mathbb{E}[\\varepsilon_t] = \\mathbb{E}[\\mathbb{E}[\\varepsilon_t | \\mathcal{F}_{t-1}]]\n$$\n内部的条件期望为：\n$$\n\\mathbb{E}[\\varepsilon_t | \\mathcal{F}_{t-1}] = \\mathbb{E}[\\sigma_t z_t | \\mathcal{F}_{t-1}]\n$$\n条件方差 $\\sigma_t^2$ 定义为 $\\alpha_0 + \\alpha_1 \\varepsilon_{t-1}^2$。由于 $\\varepsilon_{t-1}$ 是信息集 $\\mathcal{F}_{t-1}$ 的一部分，$\\sigma_t$ 是 $\\mathcal{F}_{t-1}$-可测的。因此，在条件期望中可以将其视为常数：\n$$\n\\mathbb{E}[\\sigma_t z_t | \\mathcal{F}_{t-1}] = \\sigma_t \\mathbb{E}[z_t | \\mathcal{F}_{t-1}]\n$$\n根据定义，$z_t$ 独立于 $\\mathcal{F}_{t-1}$。因此，$\\mathbb{E}[z_t | \\mathcal{F}_{t-1}] = \\mathbb{E}[z_t] = 0$。\n这导致：\n$$\n\\mathbb{E}[\\varepsilon_t | \\mathcal{F}_{t-1}] = \\sigma_t \\cdot 0 = 0\n$$\n将此结果代回全期望定律：\n$$\n\\mathbb{E}[\\varepsilon_t] = \\mathbb{E}[0] = 0\n$$\n过程 $\\{\\varepsilon_t\\}$ 是一个零均值过程。因此，其方差简化为二阶矩：\n$$\n\\mathbb{V}\\mathrm{ar}(\\varepsilon_t) = \\mathbb{E}[\\varepsilon_t^2]\n$$\n我们将常数无条件方差记为 $\\sigma^2$，这是协方差平稳性假设的一个结果。因此，$\\sigma^2 = \\mathbb{E}[\\varepsilon_t^2]$。\n\n为了求 $\\sigma^2$，我们再次应用全期望定律：\n$$\n\\sigma^2 = \\mathbb{E}[\\varepsilon_t^2] = \\mathbb{E}[\\mathbb{E}[\\varepsilon_t^2 | \\mathcal{F}_{t-1}]]\n$$\n内部的条件期望是 $\\varepsilon_t$ 的条件二阶矩。鉴于 $\\mathbb{E}[\\varepsilon_t | \\mathcal{F}_{t-1}]=0$，这也是 $\\varepsilon_t$ 的条件方差：\n$$\n\\mathbb{E}[\\varepsilon_t^2 | \\mathcal{F}_{t-1}] = \\mathbb{V}\\mathrm{ar}(\\varepsilon_t | \\mathcal{F}_{t-1}) = \\sigma_t^2\n$$\n我们来正式地证明这一点：\n$$\n\\mathbb{E}[\\varepsilon_t^2 | \\mathcal{F}_{t-1}] = \\mathbb{E}[(\\sigma_t z_t)^2 | \\mathcal{F}_{t-1}] = \\mathbb{E}[\\sigma_t^2 z_t^2 | \\mathcal{F}_{t-1}]\n$$\n由于 $\\sigma_t^2$ 是 $\\mathcal{F}_{t-1}$-可测的，可以将其从期望中提出：\n$$\n\\mathbb{E}[\\sigma_t^2 z_t^2 | \\mathcal{F}_{t-1}] = \\sigma_t^2 \\mathbb{E}[z_t^2 | \\mathcal{F}_{t-1}]\n$$\n由于 $z_t$ 独立于 $\\mathcal{F}_{t-1}$，所以 $\\mathbb{E}[z_t^2 | \\mathcal{F}_{t-1}] = \\mathbb{E}[z_t^2]$。已知 $\\mathbb{V}\\mathrm{ar}(z_t) = 1$ 且 $\\mathbb{E}[z_t] = 0$。因为 $\\mathbb{V}\\mathrm{ar}(z_t) = \\mathbb{E}[z_t^2] - (\\mathbb{E}[z_t])^2$，我们有 $\\mathbb{E}[z_t^2] = 1 - 0^2 = 1$。\n因此：\n$$\n\\mathbb{E}[\\varepsilon_t^2 | \\mathcal{F}_{t-1}] = \\sigma_t^2 \\cdot 1 = \\sigma_t^2\n$$\n现在我们将此结果代回无条件方差的表达式：\n$$\n\\sigma^2 = \\mathbb{E}[\\sigma_t^2]\n$$\n使用条件方差的定义 $\\sigma_t^2 = \\alpha_0 + \\alpha_1 \\varepsilon_{t-1}^2$：\n$$\n\\sigma^2 = \\mathbb{E}[\\alpha_0 + \\alpha_1 \\varepsilon_{t-1}^2]\n$$\n根据期望的线性性质：\n$$\n\\sigma^2 = \\mathbb{E}[\\alpha_0] + \\mathbb{E}[\\alpha_1 \\varepsilon_{t-1}^2] = \\alpha_0 + \\alpha_1 \\mathbb{E}[\\varepsilon_{t-1}^2]\n$$\n协方差平稳性的假设意味着无条件方差不随时间变化，所以 $\\mathbb{V}\\mathrm{ar}(\\varepsilon_{t-1}) = \\mathbb{V}\\mathrm{ar}(\\varepsilon_t) = \\sigma^2$。由于该过程是零均值的，这意味着 $\\mathbb{E}[\\varepsilon_{t-1}^2] = \\sigma^2$。将此代入方程中：\n$$\n\\sigma^2 = \\alpha_0 + \\alpha_1 \\sigma^2\n$$\n我们现在求解这个关于 $\\sigma^2$ 的代数方程：\n$$\n\\sigma^2 - \\alpha_1 \\sigma^2 = \\alpha_0\n$$\n$$\n\\sigma^2 (1 - \\alpha_1) = \\alpha_0\n$$\n$$\n\\sigma^2 = \\frac{\\alpha_0}{1 - \\alpha_1}\n$$\n这就是无条件方差 $\\mathbb{V}\\mathrm{ar}(\\varepsilon_t)$ 的闭式表达式。给定条件 $0 \\le \\alpha_1  1$ 确保了分母 $(1 - \\alpha_1)$ 为正且非零，从而保证了无条件方差是有限的正数，这正是平稳过程的要求。\n\n关于当 $\\alpha_1 \\to 1^{-}$ 时的行为，我们分析推导出的 $\\sigma^2$ 表达式。参数 $\\alpha_1$ 代表波动率的持续性；它衡量了过去的冲击 $\\varepsilon_{t-1}^2$ 对当前条件方差 $\\sigma_t^2$ 的影响程度。当 $\\alpha_1$ 从下方趋近于 $1$ 时，分母 $(1 - \\alpha_1)$ 从正方向趋近于 $0$。因此，无条件方差 $\\sigma^2$ 趋向于无穷大：\n$$\n\\lim_{\\alpha_1 \\to 1^{-}} \\frac{\\alpha_0}{1 - \\alpha_1} = +\\infty\n$$\n这意味着随着波动率冲击的持续性变得更强（即，$\\alpha_1$ 越来越接近 $1$），该过程的整体、长期波动率将无界增长。在极限情况下，当 $\\alpha_1=1$（单位根情况，称为整合ARCH或IARCH），该过程不再是协方差平稳的，其无条件方差未定义或为无穷大。在这种情况下，对波动率的冲击会对系统未来的波动路径产生永久性影响。",
            "answer": "$$\n\\boxed{\\frac{\\alpha_0}{1 - \\alpha_1}}\n$$"
        },
        {
            "introduction": "掌握了理论基础后，我们便可将其转化为代码。在实践中，单一资产的波动率不仅受其自身历史数据的影响，还可能与更广泛的市场情绪或外部因素（例如 VIX 指数）联动。此练习将指导您动手实现一个因子 GARCH (Factor-GARCH) 模型的核心递推算法，直观展示如何将外部变量纳入波动率方程，为构建更复杂的估计任务奠定坚实基础 。",
            "id": "2411181",
            "problem": "要求您实现一个简单的因子广义自回归条件异方差(GARCH)模型。在该模型中，一个可观测的市场范围波动率因子，例如芝加哥期权交易所(CBOE)波动率指数(VIX)，会影响单个资产收益过程的条件方差。\n\n请从以下基本原则和定义开始：\n- 资产收益的典型化事实：资产收益表现出波动率聚集现象，即大的(小的)冲击之后倾向于跟随着大的(小的)冲击。\n- 条件方差建模：向前一期的条件方差被建模为其自身滞后项和滞后平方新息的函数。\n- 条件异方差过程的高斯(正态)对数似然。\n\n模型设定：\n- 设收益序列为 $\\{r_t\\}_{t=1}^T$，可观测的非负因子序列为 $\\{f_t\\}_{t=1}^T$，条件方差序列为 $\\{h_t\\}_{t=1}^T$。\n- 观测方程为 $r_t = \\sqrt{h_t}\\,\\varepsilon_t$，其中 $\\varepsilon_t \\sim \\text{i.i.d. } \\mathcal{N}(0,1)$。\n- 方差递归(含一阶滞后的因子GARCH)为\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1} + \\phi f_{t-1},\n$$\n其中参数 $\\omega \\ge 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, $\\phi \\ge 0$。为保证数值稳定性和现实性，假设 $\\alpha + \\beta  1$ 且对于所有 $t$ 都有 $f_t \\ge 0$。\n- 初始化：\n  - 设置 $r_0 = 0$ 和 $f_0 = f_1$。\n  - 设置一个小的下限值 $\\epsilon = 10^{-8}$ 以强制其为正。\n  - 初始化\n  $$\n  h_0 = \\max\\left(\\epsilon,\\ \\frac{\\omega}{\\max(1 - \\alpha - \\beta,\\ \\epsilon)} + \\phi f_0\\right).\n  $$\n  - 对每个 $t \\in \\{1,\\dots,T\\}$，通过递归计算 $h_t$，并强制 $h_t \\leftarrow \\max(h_t, \\epsilon)$。\n- 向前一步的方差预测为\n$$\nh_{T+1} = \\omega + \\alpha r_T^2 + \\beta h_T + \\phi f_T,\n$$\n强制其至少为 $\\epsilon$。\n- 高斯负对数似然为\n$$\n\\text{NLL} = \\frac{1}{2}\\sum_{t=1}^T \\left(\\ln(2\\pi) + \\ln(h_t) + \\frac{r_t^2}{h_t}\\right).\n$$\n\n您的任务：\n- 实现一个程序，对于下述每个测试用例，计算三个量：最终条件方差 $h_T$、向前一步的预测值 $h_{T+1}$ 和高斯负对数似然 $\\text{NLL}$。\n- 严格使用上述初始化和递归规则。\n- 将每个报告的量四舍五入到6位小数。\n\n测试套件：\n- 使用以下收益序列和因子序列，其中所有值均为无量纲：\n  - 序列A (用于用例 $1, 2, 3$):\n    - 收益: $[0.01,\\ -0.02,\\ 0.015,\\ -0.005,\\ 0.0,\\ 0.02,\\ -0.015,\\ 0.01]$\n    - 因子: $[0.20,\\ 0.25,\\ 0.22,\\ 0.24,\\ 0.21,\\ 0.23,\\ 0.26,\\ 0.22]$\n  - 序列B (用于用例 $4$):\n    - 收益: $[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0]$\n    - 因子: $[0.10,\\ 0.20,\\ 0.30,\\ 0.25,\\ 0.15]$\n\n- 用例及参数 $(\\omega,\\ \\alpha,\\ \\beta,\\ \\phi)$:\n  - 用例 $1$ (正常路径): 使用序列 A，参数为 $(0.0001,\\ 0.10,\\ 0.85,\\ 0.05)$。\n  - 用例 $2$ (无因子效应): 使用序列 A，参数为 $(0.0001,\\ 0.10,\\ 0.85,\\ 0.00)$。\n  - 用例 $3$ (近边界持续性): 使用序列 A，参数为 $(0.00005,\\ 0.08,\\ 0.91,\\ 0.07)$。\n  - 用例 $4$ (零收益下的纯因子驱动): 使用序列 B，参数为 $(0.0001,\\ 0.00,\\ 0.90,\\ 0.20)$。\n\n要求的输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 对每个用例，按顺序输出 $h_T$, $h_{T+1}$ 和 $\\text{NLL}$，所有值均四舍五入到6位小数。\n- 按用例 $1$、用例 $2$、用例 $3$、用例 $4$ 的顺序汇总所有用例，并展平输出。例如，最终输出应如下所示\n$[h_T^{(1)}, h_{T+1}^{(1)}, \\text{NLL}^{(1)}, h_T^{(2)}, h_{T+1}^{(2)}, \\text{NLL}^{(2)}, h_T^{(3)}, h_{T+1}^{(3)}, \\text{NLL}^{(3)}, h_T^{(4)}, h_{T+1}^{(4)}, \\text{NLL}^{(4)}]$,\n每个条目打印到6位小数。",
            "solution": "所提出的问题是金融计量经济学领域中一个明确定义的计算任务。它具有科学依据，数学上一致，并为得出唯一解提供了所有必要信息。指定的模型，即因子GARCH(1,1)过程，是广义自回归条件异方差(GARCH)框架的一个标准扩展，旨在捕捉资产收益中根据经验观察到的波动率聚集现象。包含外部因子使得模型能够解释影响单个资产方差的市场范围波动率冲击。该问题是有效的，可以通过仔细实现指定的算法来构建解决方案。\n\n问题的核心是为资产收益序列 $\\{r_t\\}_{t=1}^T$ 的条件方差 $h_t$ 建模。$t$ 时刻的收益由观测方程 $r_t = \\sqrt{h_t}\\,\\varepsilon_t$ 定义，其中 $\\varepsilon_t$ 是一个来自标准正态分布 $\\mathcal{N}(0,1)$ 的独立同分布随机变量。这意味着，在给定直至 $t-1$ 时刻信息的条件下，$r_t$ 的条件分布是均值为 $0$、方差为 $h_t$ 的正态分布。\n\n条件方差的演变由因子GARCH(1,1)递归描述：\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1} + \\phi f_{t-1}\n$$\n该方程有四个组成部分：\n1.  一个常数截距项 $\\omega$，它为方差提供了一个基准水平。\n2.  ARCH 项 $\\alpha r_{t-1}^2$，它捕捉了前一期平方冲击（即平方收益）的影响。$|r_{t-1}|$ 的一个大值会导致更高的方差 $h_t$，从而对波动率聚集进行建模。\n3.  GARCH 项 $\\beta h_{t-1}$，它代表了前一期条件方差的影响。该项向波动率过程引入了持续性。\n4.  因子项 $\\phi f_{t-1}$，它包含了可观测的滞后外部因子 $f_{t-1}$ 对当前方差的影响。\n\n参数被约束为非负（$\\omega, \\alpha, \\beta, \\phi \\ge 0$）以确保方差 $h_t$ 为非负。约束 $\\alpha + \\beta  1$ 是为了在没有因子的情况下，方差过程是弱平稳的。\n\n计算过程建立在该递归定义之上。一个精确的算法实现如下：\n\n首先，我们必须初始化该过程。$h_t$ 的递归依赖于 $t-1$ 时的值。因此，我们需要 $t=0$ 时的初始值。问题指定 $r_0 = 0$ 和 $f_0 = f_1$，其中 $f_1$ 是因子序列中的第一个观测值。初始方差 $h_0$ 是基于GARCH过程的长期无条件方差，并根据初始因子水平进行调整而设定的。GARCH(1,1)过程的无条件方差为 $E[h] = \\frac{\\omega}{1-\\alpha-\\beta}$。初始化将其扩展为：\n$$\nh_0 = \\max\\left(\\epsilon,\\ \\frac{\\omega}{\\max(1 - \\alpha - \\beta,\\ \\epsilon)} + \\phi f_0\\right)\n$$\n一个小的正下限值 $\\epsilon = 10^{-8}$ 用于确保分母不为零且 $h_0$ 严格为正，这对于数值稳定性至关重要，尤其是在为似然函数计算对数时。\n\n其次，我们从 $t=1$ 迭代到 $T$ 以计算条件方差序列 $\\{h_t\\}_{t=1}^T$。在每一步中，我们使用前一步的已知值（$r_{t-1}$、$h_{t-1}$、$f_{t-1}$）应用方差递归公式。每次计算后，得到的 $h_t$ 也以 $\\epsilon$ 为下限，以在整个序列中保持正性。此循环中计算的最终值为 $h_T$。\n\n第三，我们计算向前一步的方差预测值 $h_{T+1}$。这是使用在时间 $T$ 的最新可用数据直接应用递归公式：\n$$\nh_{T+1} = \\omega + \\alpha r_T^2 + \\beta h_T + \\phi f_T\n$$\n该值也以 $\\epsilon$ 为下限。\n\n第四，我们计算高斯负对数似然(NLL)。对于单个观测值 $r_t$，其条件对数似然为 $\\ell_t = -\\frac{1}{2}(\\ln(2\\pi) + \\ln(h_t) + r_t^2/h_t)$。整个序列 $\\{r_t\\}_{t=1}^T$ 的总NLL是这些单个对数似然负值的总和：\n$$\n\\text{NLL} = \\frac{1}{2}\\sum_{t=1}^T \\left(\\ln(2\\pi) + \\ln(h_t) + \\frac{r_t^2}{h_t}\\right)\n$$\n此计算使用观测到的收益序列 $\\{r_t\\}_{t=1}^T$ 和计算出的条件方差序列 $\\{h_t\\}_{t=1}^T$。\n\n整个算法是作为一个函数实现的，该函数接受收益序列、因子序列和模型参数。此函数执行所述的初始化、递归、预测和NLL计算。对问题陈述中指定的四个测试用例中的每一个重复此过程。最终结果——每个用例的 $h_T$, $h_{T+1}$ 和 $\\text{NLL}$——被四舍五入到6位小数，并汇总到一个列表中进行输出。使用NumPy有助于数组操作和诸如 `log` 和 `pi` 等数学函数的使用。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_factor_garch(r_data, f_data, params):\n    \"\"\"\n    Computes h_T, h_{T+1}, and NLL for a Factor-GARCH(1,1) model.\n\n    Args:\n        r_data (list): The return series {r_t}.\n        f_data (list): The observable factor series {f_t}.\n        params (tuple): The model parameters (omega, alpha, beta, phi).\n\n    Returns:\n        tuple: A tuple containing (h_T, h_{T+1}, NLL).\n    \"\"\"\n    omega, alpha, beta, phi = params\n    epsilon = 1e-8\n\n    r = np.array(r_data, dtype=float)\n    f = np.array(f_data, dtype=float)\n    T = len(r)\n\n    # Prepare extended series with initial values at t=0.\n    # r_ext corresponds to {r_0, r_1, ..., r_T}\n    r_ext = np.insert(r, 0, 0.0) \n    # f_ext corresponds to {f_0, f_1, ..., f_T}\n    # f_0 = f_1, where f_1 is the first element of the original f_data array.\n    f_ext = np.insert(f, 0, f[0])\n\n    # h array will store {h_0, h_1, ..., h_T}\n    h = np.zeros(T + 1)\n\n    # Initialize h_0\n    h_denom = max(1.0 - alpha - beta, epsilon)\n    h_uncond = omega / h_denom + phi * f_ext[0]\n    h[0] = max(epsilon, h_uncond)\n\n    # Recursion for h_t, t = 1, ..., T\n    for t in range(1, T + 1):\n        h_val = omega + alpha * r_ext[t - 1]**2 + beta * h[t - 1] + phi * f_ext[t - 1]\n        h[t] = max(h_val, epsilon)\n\n    # The final conditional variance is h at time T.\n    h_T = h[T]\n\n    # One-step-ahead forecast for h_{T+1}\n    h_Tplus1_val = omega + alpha * r_ext[T]**2 + beta * h[T] + phi * f_ext[T]\n    h_Tplus1 = max(h_Tplus1_val, epsilon)\n\n    # Calculate Gaussian Negative Log-Likelihood\n    # The sum is over t=1,...,T, which corresponds to h[1:]\n    h_for_nll = h[1:]\n    nll = 0.5 * np.sum(np.log(2 * np.pi) + np.log(h_for_nll) + r**2 / h_for_nll)\n\n    return h_T, h_Tplus1, nll\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the required quantities for each,\n    then prints the formatted output.\n    \"\"\"\n    # Series A data\n    series_A_r = [0.01, -0.02, 0.015, -0.005, 0.0, 0.02, -0.015, 0.01]\n    series_A_f = [0.20, 0.25, 0.22, 0.24, 0.21, 0.23, 0.26, 0.22]\n    \n    # Series B data\n    series_B_r = [0.0, 0.0, 0.0, 0.0, 0.0]\n    series_B_f = [0.10, 0.20, 0.30, 0.25, 0.15]\n\n    test_cases = [\n        # Case 1: Series A, (omega, alpha, beta, phi) = (0.0001, 0.10, 0.85, 0.05)\n        {\"r\": series_A_r, \"f\": series_A_f, \"params\": (0.0001, 0.10, 0.85, 0.05)},\n        # Case 2: Series A, (omega, alpha, beta, phi) = (0.0001, 0.10, 0.85, 0.00)\n        {\"r\": series_A_r, \"f\": series_A_f, \"params\": (0.0001, 0.10, 0.85, 0.00)},\n        # Case 3: Series A, (omega, alpha, beta, phi) = (0.00005, 0.08, 0.91, 0.07)\n        {\"r\": series_A_r, \"f\": series_A_f, \"params\": (0.00005, 0.08, 0.91, 0.07)},\n        # Case 4: Series B, (omega, alpha, beta, phi) = (0.0001, 0.00, 0.90, 0.20)\n        {\"r\": series_B_r, \"f\": series_B_f, \"params\": (0.0001, 0.00, 0.90, 0.20)},\n    ]\n\n    results = []\n    for case in test_cases:\n        h_T, h_Tplus1, nll = calculate_factor_garch(case[\"r\"], case[\"f\"], case[\"params\"])\n        results.extend([\n            round(h_T, 6),\n            round(h_Tplus1, 6),\n            round(nll, 6)\n        ])\n\n    # Format the final output string to 6 decimal places.\n    # The format specifier ensures trailing zeros are included.\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将理论知识与编程实践相结合，应用 GARCH 模型来检验一个真实的经济学假设。通过在一个标准 GARCH 模型中嵌入代表星期的虚拟变量，我们可以构建一个包含星期效应的扩展模型，并利用似然比 (Likelihood Ratio, LR) 检验来判断“星期几效应”在统计上是否显著。这项综合性练习将带您走过一个完整的计量经济学研究流程——从数据模拟、利用拟最大似然法进行模型估计，到执行正式的假设检验，让您全面体验实证金融分析师的工作 。",
            "id": "2411105",
            "problem": "要求您设计并实现一个完整的、可运行的程序，通过将虚拟变量引入一个能够捕捉金融回报率中波动率聚集现象的条件方差模型，来检验波动率中的“星期效应”。使用的基本原理包括：条件期望和方差的定义、许多金融回报率序列呈现出时变条件方差（即“波动率聚集”）的观测现象，以及广义自回归条件异方差（GARCH）模型是表示此类条件方差动态的一种经过充分检验的方法。在 高斯假设下，基于似然的推断（准最大似然）是经过充分检验且适合于估计的方法，而似然比检验是检验嵌套假设的标准方法。\n\n您的程序必须为一组综合测试用例执行以下操作：\n\n1. 将回报率序列 $\\{r_t\\}_{t=1}^T$ 视为均值为零、条件异方差的序列，其条件方差 $\\sigma_t^2$ 服从 GARCH(1,1) 型递归。在条件方差方程中，通过加性虚拟变量引入“星期效应”。设 $D_t$ 为代表周一、周二、周四和周五的星期指示向量（周三是基准日，没有指示变量）。指示向量 $D_t \\in \\mathbb{R}^4$ 按一个 5 天的周期定义如下：$D_t = [\\mathbb{1}\\{\\text{Mon}\\}, \\mathbb{1}\\{\\text{Tue}\\}, \\mathbb{1}\\{\\text{Thu}\\}, \\mathbb{1}\\{\\text{Fri}\\}]^\\top$。日期按周一、周二、周三、周四、周五的固定顺序循环重复；模拟指数中没有周末。\n\n2. 将无约束模型（含波动率的星期效应）定义为：\n$$\nr_t = \\sigma_t z_t, \\quad z_t \\stackrel{\\text{i.i.d.}}{\\sim} \\mathcal{N}(0,1),\n$$\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2 + \\gamma^\\top D_t,\n$$\n参数满足 $\\omega  0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, $\\alpha + \\beta  1$，并且 $\\gamma \\in \\mathbb{R}_+^4$ 受到约束以确保 $\\sigma_t^2  0$ 几乎必然成立。受约束（零）模型将 $\\gamma = 0$ 并使用：\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2.\n$$\n这些是用于建模波动率聚集和外生方差效应的标准且经过充分检验的结构。\n\n3. 对于每个测试用例，使用已知的参数值 $(\\omega, \\alpha, \\beta, \\gamma)$ 和一个用于保证可复现性的固定种子，从一个采用上述无约束形式的已知数据生成过程（DGP）模拟回报率。使用 $B$ 个观测值作为预烧期（burn-in），然后保留最后的 $T$ 个观测值用于估计。使用一个遵循 $\\alpha + \\beta  1$ 以及 $D_t$ 在 5 天周期内的平均贡献的长期平均值来初始化 $\\sigma_1^2$。\n\n4. 通过最大化高斯对数似然（准最大似然）来估计无约束模型和受约束模型。使用任何能够确保 $\\omega  0$, $\\alpha \\ge 0$, $\\beta \\ge 0$, $\\alpha + \\beta  1$ 及 $\\gamma \\ge 0$ 的平滑重参数化方法，从而使得数值优化在原始参数空间中无约束，但约束在模型空间中成立。对于观测值 $t$，高斯对数似然贡献为：\n$$\n\\ell_t = -\\tfrac{1}{2}\\left(\\log(2\\pi) + \\log \\sigma_t^2 + \\frac{r_t^2}{\\sigma_t^2}\\right),\n$$\n总对数似然为 $L = \\sum_{t=1}^{T} \\ell_t$。\n\n5. 使用似然比统计量检验零假设 $H_0: \\gamma = 0$ 相对于无约束备择假设：\n$$\n\\text{LR} = 2\\left[L_{\\text{unrestricted}} - L_{\\text{restricted}}\\right].\n$$\n在标准正则性条件下，且当 $H_0$ 成立时，$\\text{LR}$ 渐近服从自由度为 $k$ 的卡方分布，其中 $k$ 是约束的数量。此处，$k=4$。使用自由度为 4 的卡方分布计算 $p$-值，如果 $p$-值小于 0.05，则在 0.05 的显著性水平上拒绝 $H_0$。将拒绝决策表示为一个布尔值。\n\n6. 您的程序必须生成单行输出，其中包含所有测试用例的布尔结果，格式为方括号内以逗号分隔的列表，例如，“[True,False,True]”。\n\n测试套件（所有数字均为与日回报率一致的十进制单位；不涉及物理单位）：\n\n- 通用设置：对所有测试用例，使用 $T = 2000$ 和预烧期 $B = 500$。星期模式从 $t=1$ 的周一开始，然后是周二、周三、周四、周五，并循环重复。\n\n- 测试用例 1（零假设，中等持久性）：\n  - 种子：$123$。\n  - 参数：$\\omega = 5 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.90$, $\\gamma = [0, 0, 0, 0]$。\n  - 预期行为：在 0.05 的水平上不拒绝 $H_0$。\n\n- 测试用例 2（单一强周一效应）：\n  - 种子：$456$。\n  - 参数：$\\omega = 5 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.90$, $\\gamma = [2\\times 10^{-5}, 0, 0, 0]$。\n  - 预期行为：在 0.05 的水平上拒绝 $H_0$。\n\n- 测试用例 3（多重强星期效应）：\n  - 种子：$789$。\n  - 参数：$\\omega = 5 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.90$, $\\gamma = [2\\times 10^{-5}, 1.5\\times 10^{-5}, 1\\times 10^{-5}, 5\\times 10^{-6}]$。\n  - 预期行为：在 0.05 的水平上拒绝 $H_0$。\n\n- 测试用例 4（零假设，接近单位根的高持久性）：\n  - 种子：$321$。\n  - 参数：$\\omega = 1 \\times 10^{-6}$, $\\alpha = 0.05$, $\\beta = 0.94$, $\\gamma = [0, 0, 0, 0]$。\n  - 预期行为：在 0.05 的水平上不拒绝 $H_0$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号内以逗号分隔的 `True` 或 `False` 布尔值列表，例如：“[False,True,True,False]”。",
            "solution": "所述问题是有效的。这是一个定义明确的计算计量经济学练习，其基础是成熟的时间序列分析和假设检验理论。任务是实现一个似然比检验，以检验 GARCH($1,1$) 模型的条件方差设定中是否存在确定性的星期效应。该过程需要几个不同的步骤：从已知的数据生成过程（DGP）模拟合成数据，通过准最大似然（QML）方法估计受约束和无约束模型，最后，计算检验统计量及其相关的 p-值以做出决策。\n\n问题的核心在于 GARCH($1,1$) 模型，该模型捕捉了在许多金融时间序列中观察到的波动率聚集现象。回报率 $r_t$ 的模型由下式给出\n$$\nr_t = \\sigma_t z_t, \\quad z_t \\stackrel{\\text{i.i.d.}}{\\sim} \\mathcal{N}(0,1)\n$$\n其中 $z_t$ 是一个标准正态新息，$\\sigma_t^2$ 是时间 $t$ 的条件方差。问题为该条件方差指定了两个嵌套模型。\n\n无约束模型通过虚拟变量向量 $D_t \\in \\mathbb{R}^4$ 引入星期效应：\n$$\n\\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2 + \\gamma^\\top D_t\n$$\n对应于零假设 $H_0$ 的受约束模型通过将参数向量 $\\gamma$ 设置为零来排除这些效应：\n$$\nH_0: \\gamma = 0 \\quad \\implies \\quad \\sigma_t^2 = \\omega + \\alpha r_{t-1}^2 + \\beta \\sigma_{t-1}^2\n$$\n参数受到约束以确保方差过程是良态的：$\\omega > 0$, $\\alpha \\ge 0$, $\\beta \\ge 0$，并且为了平稳性，$\\alpha + \\beta  1$。星期效应的系数 $\\gamma$ 被约束为非负，即 $\\gamma \\ge 0$，以排除负的方差贡献。\n\n算法设计如下：\n\n首先，构建一个数据生成函数。对于每个测试用例，我们使用指定的参数 $(\\omega, \\alpha, \\beta, \\gamma)$ 和随机种子，从无约束模型中模拟一个长度为 $T+B$ 的时间序列。星期虚拟变量 $D_t$ 是周期性构建的。该过程使用无条件方差进行初始化，在平稳性假设下，该方差为 $E[\\sigma_t^2] = (\\omega + E[\\gamma^\\top D_t]) / (1 - \\alpha - \\beta)$。由于日期按 5 天一周循环，期望 $E[\\gamma^\\top D_t]$ 是一周内的平均效应：$\\frac{1}{5}(\\gamma_1 + \\gamma_2 + \\gamma_3 + \\gamma_4)$，其中 $\\gamma = [\\gamma_1, \\gamma_2, \\gamma_3, \\gamma_4]^\\top$。最初的 $B=500$ 个观测值作为预烧期被丢弃，以减轻初始条件的影响，留下大小为 $T=2000$ 的样本用于估计。\n\n其次，我们必须定义用于估计的对数似然函数。假设高斯新息，观测值 $t$ 的对数似然贡献为：\n$$\n\\ell_t(\\theta) = -\\frac{1}{2}\\left(\\log(2\\pi) + \\log \\sigma_t^2(\\theta) + \\frac{r_t^2}{\\sigma_t^2(\\theta)}\\right)\n$$\n其中 $\\theta$ 代表模型参数的向量。总对数似然为 $L(\\theta) = \\sum_{t=1}^T \\ell_t(\\theta)$。通过使用数值优化器最大化此函数来执行估计。\n\n为了在优化过程中处理参数约束，采用了重参数化方法。优化器在一个无约束的参数空间上操作，这些参数在用于似然计算之前被转换以满足所需的约束。设无约束参数为 $p_i$。一个合适的转换为：\n- $\\omega = \\exp(p_0)$ 以确保 $\\omega > 0$。\n- $\\alpha = \\frac{\\exp(p_1)}{1+\\exp(p_1)}$ 以确保 $\\alpha \\in (0,1)$。\n- $\\beta = (1-\\alpha) \\times \\frac{\\exp(p_2)}{1+\\exp(p_2)}$ 以确保 $\\beta \\in (0, 1-\\alpha)$，从而 $\\alpha+\\beta  1$。\n- $\\gamma_j = \\exp(p_{2+j})$ 对 $j \\in \\{1,2,3,4\\}$ 以确保 $\\gamma_j > 0$。\n\n条件方差序列 $\\sigma_t^2(\\theta)$ 通过递归计算。我们使用当前参数估计值 $\\theta$ 通过模型隐含的无条件方差初始化 $\\sigma_1^2$。然后，对于 $t=2, \\dots, T$，我们使用 GARCH 递归计算 $\\sigma_t^2$。优化器将最小化总对数似然的负数，即 $-L(\\theta)$。\n\n第三，对于每个测试用例，我们执行两次估计。我们首先拟合有 3 个参数 $(\\omega, \\alpha, \\beta)$ 的受约束模型，以获得最大化对数似然 $L_{\\text{restricted}}$。然后我们拟合有 7 个参数 $(\\omega, \\alpha, \\beta, \\gamma_1, \\gamma_2, \\gamma_3, \\gamma_4)$ 的无约束模型，以获得 $L_{\\text{unrestricted}}$。\n\n最后，计算似然比（LR）检验统计量：\n$$\n\\text{LR} = 2(L_{\\text{unrestricted}} - L_{\\text{restricted}})\n$$\n在零假设 $H_0: \\gamma = 0$下，该统计量渐近服从自由度等于约束数量（即 $k=4$）的卡方分布。p-值计算为 $P(\\chi^2_4 > \\text{LR})$。如果此 p-值小于指定的显著性水平 0.05，则拒绝零假设。随后报告每个测试用例的决策结果，即一个布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef generate_data(T, B, seed, omega, alpha, beta, gamma):\n    \"\"\"\n    Generates synthetic returns from a GARCH(1,1) model with day-of-week effects.\n    \"\"\"\n    np.random.seed(seed)\n    total_len = T + B\n    \n    # Create day-of-week dummy variables\n    # D_t = [Mon, Tue, Thu, Fri]\n    dummies = np.zeros((total_len, 4))\n    for t in range(total_len):\n        day_of_week = t % 5  # 0:Mon, 1:Tue, 2:Wed, 3:Thu, 4:Fri\n        if day_of_week == 0:   # Monday\n            dummies[t, 0] = 1.0\n        elif day_of_week == 1: # Tuesday\n            dummies[t, 1] = 1.0\n        elif day_of_week == 3: # Thursday\n            dummies[t, 2] = 1.0\n        elif day_of_week == 4: # Friday\n            dummies[t, 3] = 1.0\n            \n    # Initialize returns and variances\n    returns = np.zeros(total_len)\n    sigma_sq = np.zeros(total_len)\n    \n    # Initial variance is the unconditional variance\n    mean_gamma_effect = np.sum(gamma) / 5.0\n    uncond_var = (omega + mean_gamma_effect) / (1.0 - alpha - beta)\n    \n    # Generate standard normal innovations\n    z = np.random.normal(0.0, 1.0, total_len)\n    \n    # First observation\n    sigma_sq[0] = uncond_var\n    returns[0] = np.sqrt(sigma_sq[0]) * z[0]\n    \n    # Generate the rest of the series\n    for t in range(1, total_len):\n        gamma_effect = np.dot(gamma, dummies[t])\n        sigma_sq[t] = omega + alpha * returns[t-1]**2 + beta * sigma_sq[t-1] + gamma_effect\n        if sigma_sq[t]  1e-12: # Floor variance to avoid numerical issues\n            sigma_sq[t] = 1e-12\n        returns[t] = np.sqrt(sigma_sq[t]) * z[t]\n        \n    return returns[B:], dummies[B:]\n\ndef neg_log_likelihood(params_unconstrained, returns, dummies, is_unrestricted):\n    \"\"\"\n    Calculates the negative of the GARCH log-likelihood function.\n    \"\"\"\n    T = len(returns)\n    \n    # Reparameterization to enforce constraints\n    omega = np.exp(params_unconstrained[0])\n    alpha_trans = np.exp(params_unconstrained[1])\n    alpha = alpha_trans / (1.0 + alpha_trans)\n    beta_trans = np.exp(params_unconstrained[2])\n    beta = (1.0 - alpha) * (beta_trans / (1.0 + beta_trans))\n\n    if is_unrestricted:\n        gamma = np.exp(params_unconstrained[3:])\n        mean_gamma_effect = np.sum(gamma) / 5.0\n    else:\n        gamma = np.zeros(4)\n        mean_gamma_effect = 0.0\n\n    # Ensure stationarity for unconditional variance calculation\n    if (alpha + beta) = 1.0:\n        return 1e9 # Penalize non-stationary region\n        \n    # Initialize variance series\n    sigma_sq = np.zeros(T)\n    uncond_var = (omega + mean_gamma_effect) / (1.0 - alpha - beta)\n    \n    # It's standard to initialize with unconditional variance.\n    sigma_sq[0] = uncond_var\n\n    # GARCH recursion\n    for t in range(1, T):\n        gamma_effect = np.dot(gamma, dummies[t])\n        sigma_sq[t] = omega + alpha * returns[t-1]**2 + beta * sigma_sq[t-1] + gamma_effect\n        if sigma_sq[t]  1e-12:\n            sigma_sq[t] = 1e-12\n\n    # Avoid log(0) or division by zero\n    if np.any(sigma_sq = 0):\n        return 1e9\n\n    # Log-likelihood calculation\n    log_likelihood = -0.5 * np.sum(np.log(2 * np.pi) + np.log(sigma_sq) + returns**2 / sigma_sq)\n\n    if np.isnan(log_likelihood) or np.isinf(log_likelihood):\n        return 1e9\n\n    return -log_likelihood\n\ndef fit_garch(returns, dummies, is_unrestricted):\n    \"\"\"\n    Fits a GARCH(1,1) model (restricted or unrestricted) using QML.\n    \"\"\"\n    if is_unrestricted:\n        # Initial guess for [log(w), ...log(alpha_trans), ...log(beta_trans), ...log(gamma)]\n        x0 = np.array([-12.0, -2.5, 2.5, -16.0, -16.0, -16.0, -16.0])\n    else:\n        # Initial guess for [log(w), ...log(alpha_trans), ...log(beta_trans)]\n        x0 = np.array([-12.0, -2.5, 2.5])\n    \n    res = minimize(\n        neg_log_likelihood,\n        x0=x0,\n        args=(returns, dummies, is_unrestricted),\n        method='L-BFGS-B'\n    )\n    \n    max_log_likelihood = -res.fun\n    return max_log_likelihood\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {'seed': 123, 'omega': 5e-6, 'alpha': 0.05, 'beta': 0.90, 'gamma_vec': np.array([0.0, 0.0, 0.0, 0.0])},\n        # Test Case 2\n        {'seed': 456, 'omega': 5e-6, 'alpha': 0.05, 'beta': 0.90, 'gamma_vec': np.array([2e-5, 0.0, 0.0, 0.0])},\n        # Test Case 3\n        {'seed': 789, 'omega': 5e-6, 'alpha': 0.05, 'beta': 0.90, 'gamma_vec': np.array([2e-5, 1.5e-5, 1e-5, 5e-6])},\n        # Test Case 4\n        {'seed': 321, 'omega': 1e-6, 'alpha': 0.05, 'beta': 0.94, 'gamma_vec': np.array([0.0, 0.0, 0.0, 0.0])}\n    ]\n    \n    common_settings = {'T': 2000, 'B': 500}\n    results = []\n\n    for case in test_cases:\n        # 1. Generate data\n        returns, dummies = generate_data(\n            T=common_settings['T'],\n            B=common_settings['B'],\n            seed=case['seed'],\n            omega=case['omega'],\n            alpha=case['alpha'],\n            beta=case['beta'],\n            gamma=case['gamma_vec']\n        )\n        \n        # 2. Fit restricted model (H0)\n        logL_restricted = fit_garch(returns, dummies, is_unrestricted=False)\n        \n        # 3. Fit unrestricted model (H1)\n        logL_unrestricted = fit_garch(returns, dummies, is_unrestricted=True)\n        \n        # 4. Perform Likelihood Ratio test\n        LR_statistic = 2 * (logL_unrestricted - logL_restricted)\n        \n        # The LR statistic should be non-negative.\n        if LR_statistic  0:\n            LR_statistic = 0\n            \n        degrees_of_freedom = 4\n        p_value = chi2.sf(LR_statistic, df=degrees_of_freedom)\n        \n        # 5. Make decision\n        reject_H0 = p_value  0.05\n        results.append(reject_H0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}