{
    "hands_on_practices": [
        {
            "introduction": "现实世界中的许多系统，从呼叫中心、银行柜台到计算机网络和交易引擎，都可以被抽象为排队系统。通过离散事件模拟，我们可以有效地分析这些系统的性能指标（如平均等待时间），而这些指标往往因其复杂性而难以用简单的数学公式直接求解。本练习将通过模拟一个高频交易中的订单匹配引擎，让你亲手实践构建一个基本的离散事件模拟器，从而掌握分析复杂随机系统的核心技能 。",
            "id": "2403274",
            "problem": "您将为一个单服务器队列构建一个离散事件模拟器，该队列代表一个高频交易交易所的撮合引擎。订单以速率参数为 $\\lambda$（订单/秒）的泊松过程到达，每个订单的处理时间服从速率参数为 $\\mu$（订单/秒）的指数分布。服务器遵循先到先服务（FCFS）规则。系统在时间 $t=0$ 时为空且空闲。您的任务是估算队列中的平均等待时间（即从订单到达直到开始服务的时间），单位为秒。\n\n请基于以下定义进行模拟：\n- 速率为 $\\lambda$ 的泊松到达过程具有独立平稳增量。等价地，到达间隔时间 $\\{I_i\\}_{i \\ge 1}$ 是独立的、均值为 $1/\\lambda$ 的同分布指数随机变量。\n- 均值为 $1/\\mu$ 的指数服务时间 $\\{X_i\\}_{i \\ge 1}$ 独立于到达过程，且相互独立。\n- 设 $A_i$ 表示第 $i$ 个订单的到达时间，$S_i$ 为服务开始时间，$C_i$ 为完成时间。第 $i$ 个订单的排队等待时间为 $W_i = S_i - A_i$。在丢弃 $b$ 个订单的预热期后，平均等待时间的估计量为\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i.\n$$\n\n实现要求：\n- 模拟器必须在 $t=0$ 时以空系统和空闲服务器开始。\n- 生成均值为 $1/\\lambda$ 的独立指数随机变量作为到达间隔时间 $\\{I_i\\}$，并生成均值为 $1/\\mu$ 的独立指数随机变量作为服务时间 $\\{X_i\\}$。\n- 将到达时间构造为 $A_i = \\sum_{j=1}^{i} I_j$，并采用单服务器执行FCFS服务。\n- 对于每组参数，通过丢弃前 $b$ 个等待时间（预热期）并对其余部分求平均，来估算 $\\widehat{W}_q$（单位：秒）。\n- 为确保整个测试套件的可复现性，必须在开始时用种子 $123456$ 对随机数生成器进行唯一一次初始化。\n- 时间以秒为单位。您的程序必须以秒为单位打印估算值，并四舍五入到六位小数。\n\n测试套件：\n为以下五组参数 $(\\lambda, \\mu, N, b)$ 运行您的模拟器，其中 $N$ 是模拟的总到达数，$b$ 是预热期丢弃的订单数：\n1. $(800.0, 1000.0, 200000, 5000)$\n2. $(100.0, 1000.0, 200000, 5000)$\n3. $(990.0, 1000.0, 200000, 5000)$\n4. $(450.0, 500.0, 200000, 5000)$\n5. $(1000.0, 1000.0, 200000, 5000)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个估算的平均排队等待时间（单位：秒），四舍五入到六位小数，以逗号分隔，并用方括号括起来，不含空格。例如，\n`[0.004123,0.000111,0.098765,0.018400,0.537219]`。",
            "solution": "所给问题要求构建一个单服务器队列的离散事件模拟器，在排队论中称为M/M/1队列。该系统模拟了一个高频交易交易所的撮合引擎。到达过程服从泊松过程，服务时间呈指数分布。服务规则是先到先服务（FCFS）。我们的目标是估算队列中的平均等待时间 $\\widehat{W}_q$。\n\n该问题在科学上和计算上都是良构的。它基于排队论的既定原则，而排队论是性能分析的标准工具。所有必要的参数（$\\lambda, \\mu, N, b$）和初始条件（系统在 $t=0$ 时为空且空闲）都已提供，同时还指定了随机数生成器种子，确保了计算结果的唯一性和可复现性。因此，该问题是有效的。\n\n设泊松到达率为 $\\lambda$，指数服务率为 $\\mu$。相应的平均到达间隔时间为 $1/\\lambda$，平均服务时间为 $1/\\mu$。我们将订单 $i-1$ 和 $i$ 之间的到达间隔时间表示为 $I_i$，将订单 $i$ 的服务时间表示为 $X_i$。\n\n模拟的核心是一组描述系统状态随时间演化的递推关系。设 $A_i$、$S_i$ 和 $C_i$ 分别为第 $i$ 个订单的到达时间、服务开始时间和完成时间，其中 $i \\in \\{1, 2, \\dots, N\\}$。\n\n第 $i$ 个订单的到达时间由到达间隔时间的累积和给出：\n$$\nA_i = \\sum_{j=1}^{i} I_j \\quad \\text{其中 } A_0 = 0\n$$\n可以通过迭代计算为 $A_i = A_{i-1} + I_i$。\n\n系统初始为空，因此第一个订单（$i=1$）在到达时立即开始服务：$S_1 = A_1$。其完成时间为 $C_1 = S_1 + X_1$。\n\n对于任何后续订单 $i > 1$，其服务必须在其到达（时间 $A_i$）且服务器空闲后才能开始。服务器在完成前一个订单的服务后变为空闲，时间为 $C_{i-1}$。因此，订单 $i$ 的服务开始时间由这两个事件中较晚的那个决定：\n$$\nS_i = \\max(A_i, C_{i-1})\n$$\n订单 $i$ 的完成时间则为：\n$$\nC_i = S_i + X_i\n$$\n订单 $i$ 的排队等待时间 $W_i$ 是从其到达直到服务开始所经过的时间：\n$$\nW_i = S_i - A_i = \\max(A_i, C_{i-1}) - A_i = \\max(0, C_{i-1} - A_i)\n$$\n这组关系允许对排队过程进行迭代模拟。\n\n系统负载 $\\rho = \\lambda/\\mu$ 是一个关键参数。为使稳定的稳态存在，必须满足 $\\rho  1$。在这种情况下，理论平均等待时间为 $W_q = \\frac{\\rho}{\\mu(1-\\rho)}$。测试用例5中，$(\\lambda, \\mu) = (1000.0, 1000.0)$，对应 $\\rho=1$。这是一个零常返马尔可夫链，其期望等待时间是无限的。然而，对有限数量的订单 $N$ 运行模拟的计算任务仍然是良构的，并将产生一个有限的结果。这个结果不应被理解为对有限稳态均值的估计，而是指定有限时间过程的结果。\n\n模拟算法如下：\n1. 使用种子 $123456$ 初始化一个随机数生成器。\n2. 对于每个测试用例 $(\\lambda, \\mu, N, b)$：\n    a. 从均值为 $1/\\lambda$ 的指数分布中生成 $N$ 个独立同分布的到达间隔时间 $\\{I_i\\}_{i=1}^N$。\n    b. 从均值为 $1/\\mu$ 的指数分布中生成 $N$ 个独立同分布的服务时间 $\\{X_i\\}_{i=1}^N$。\n    c. 将 `arrival_time` 和 `completion_time_of_previous_customer` 初始化为 $0.0$。\n    d. 从 $i=1$ 迭代到 $N$，用 $I_i$ 更新 `arrival_time`，并使用递推关系计算 $S_i$、$W_i$ 和 $C_i$。$C_{i-1}$ 的值由 `completion_time_of_previous_customer` 跟踪。存储每个 $W_i$。\n3. 模拟完所有 $N$ 个订单后，丢弃前 $b$ 个等待时间，以消除初始空闲状态的瞬态效应（预热期）。\n4. 平均等待时间通过对剩余 $N-b$ 个观测值求样本均值来估计：\n$$\n\\widehat{W}_q = \\frac{1}{N - b} \\sum_{i=b+1}^{N} W_i\n$$\n这个计算出的值，四舍五入到六位小数，构成了每个测试用例所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_queue(lambda_rate, mu_rate, N, b, rng):\n    \"\"\"\n    Simulates a single-server M/M/1 queue to estimate average waiting time.\n\n    Args:\n        lambda_rate (float): Arrival rate of orders.\n        mu_rate (float): Service rate of orders.\n        N (int): Total number of orders to simulate.\n        b (int): Number of burn-in orders to discard.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated average waiting time in the queue.\n    \"\"\"\n    # Scale parameter for exponential distribution is the mean.\n    # Mean interarrival time = 1 / lambda_rate\n    # Mean service time = 1 / mu_rate\n    interarrival_times = rng.exponential(scale=1.0/lambda_rate, size=N)\n    service_times = rng.exponential(scale=1.0/mu_rate, size=N)\n\n    # Initialize simulation state variables\n    current_arrival_time = 0.0\n    # Tracks the completion time of the previous customer, C_{i-1}\n    completion_time_of_previous = 0.0\n    waiting_times = np.zeros(N)\n\n    # Main simulation loop over N customers\n    for i in range(N):\n        # Calculate arrival time of current customer: A_i = A_{i-1} + I_i\n        current_arrival_time += interarrival_times[i]\n        \n        # Service start time: S_i = max(A_i, C_{i-1})\n        service_start_time = max(current_arrival_time, completion_time_of_previous)\n        \n        # Waiting time in queue: W_i = S_i - A_i\n        waiting_times[i] = service_start_time - current_arrival_time\n        \n        # Update completion time for the next iteration: C_i = S_i + X_i\n        completion_time_of_previous = service_start_time + service_times[i]\n\n    # Calculate the average waiting time after the burn-in period\n    # np.mean on the slice waiting_times[b:N] is equivalent to the formula in the problem.\n    avg_waiting_time = np.mean(waiting_times[b:])\n    \n    return avg_waiting_time\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Initialize the random number generator exactly once at the beginning\n    # with seed 123456 to ensure reproducibility.\n    rng = np.random.default_rng(123456)\n    \n    # Define the test cases from the problem statement.\n    # Format: (lambda, mu, N, b)\n    test_cases = [\n        (800.0, 1000.0, 200000, 5000),\n        (100.0, 1000.0, 200000, 5000),\n        (990.0, 1000.0, 200000, 5000),\n        (450.0, 500.0, 200000, 5000),\n        (1000.0, 1000.0, 200000, 5000)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_rate, mu_rate, N, b = case\n        estimated_wait = simulate_queue(lambda_rate, mu_rate, N, b, rng)\n        # Format the result to six decimal places, as a string.\n        results.append(f\"{estimated_wait:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在金融领域，准确评估和管理风险是投资决策的核心。像“最大回撤”（maximum drawdown）这样的风险指标，对于衡量一项投资可能经历的最坏情况至关重要，但其分布通常难以通过解析方法获得。本练习将指导你使用蒙特卡洛模拟，为遵循几何布朗运动的投资组合生成数千条可能的价格路径，并以此为基础构建其风险状况的统计图景 。",
            "id": "2403314",
            "problem": "考虑一个投资组合，其价值过程在连续时间内由几何布朗运动 (GBM) 建模。令 $S_t$ 表示在时间 $t \\in [0,T]$ 时的投资组合价值，初始水平为 $S_0 > 0$。该过程满足随机微分方程 $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $\\mu \\in \\mathbb{R}$ 是漂移，$\\sigma \\ge 0$ 是波动率，$(W_t)_{t \\ge 0}$ 是一个标准布朗运动。在一个均匀时间网格 $t_k = k \\Delta t$（其中 $k \\in \\{0,1,\\dots,n\\}$ 且 $\\Delta t = T/n$）上，假设 GBM 的精确有限期增量性质成立：对于每个 $k \\in \\{0,1,\\dots,n-1\\}$，对数回报 $\\log\\left(\\frac{S_{t_{k+1}}}{S_{t_k}}\\right)$ 服从正态分布，其均值为 $(\\mu - \\tfrac{1}{2}\\sigma^2)\\Delta t$，方差为 $\\sigma^2 \\Delta t$，并且在不同的 $k$ 和不同的模拟路径之间是独立的。\n\n将在网格上的运行最大值定义为 $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$，将在时间 $t_k$ 的回撤定义为 $D_{t_k} = 1 - \\frac{S_{t_k}}{M_{t_k}}$。一条路径在 $[0,T]$ 上的最大回撤为 $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$。此问题中的所有回撤都必须以小数形式表示，而不是使用百分号。\n\n对于下面测试套件中的每一组参数，请在指定的网格上独立模拟 $N_{\\text{paths}}$ 条样本路径，并根据得到的最大回撤样本 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 计算：\n- 样本均值 $\\widehat{\\mathbb{E}}[\\mathrm{MDD}] = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathrm{MDD}^{(i)}$。\n- 在阈值 $d^\\star$ 处的超额概率，定义为 $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star) = \\frac{1}{N_{\\text{paths}}}\\sum_{i=1}^{N_{\\text{paths}}} \\mathbf{1}\\{\\mathrm{MDD}^{(i)} \\ge d^\\star\\}$。\n- 在概率水平 $q$ 处的经验上分位数，记为 $Q_q$，定义为集合 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 的 $q$ 阶样本分位数。\n\n为保证可复现性，在模拟下面每个案例时，请使用为该案例指定的精确整数随机种子。不涉及物理单位。不使用角度。所有要求的输出都必须是实数。\n\n参数集测试套件，其中每个元组列出了 $(S_0,\\mu,\\sigma,T,n,N_{\\text{paths}},d^\\star,q,\\text{seed})$：\n- 案例 $1$：$(100,\\ 0.05,\\ 0.20,\\ 1.0,\\ 252,\\ 8000,\\ 0.20,\\ 0.95,\\ 202311)$。\n- 案例 $2$：$(100,\\ 0.05,\\ 0.0001,\\ 1.0,\\ 252,\\ 8000,\\ 0.01,\\ 0.95,\\ 202312)$。\n- 案例 $3$：$(100,\\ 0.00,\\ 0.60,\\ 1.0,\\ 252,\\ 8000,\\ 0.50,\\ 0.95,\\ 202313)$。\n- 案例 $4$：$(100,\\ -0.10,\\ 0.25,\\ 2.0,\\ 504,\\ 8000,\\ 0.30,\\ 0.95,\\ 202314)$。\n- 案例 $5$：$(100,\\ 0.02,\\ 0.15,\\ 0.25,\\ 63,\\ 8000,\\ 0.10,\\ 0.95,\\ 202315)$。\n\n您的程序必须生成单行输出，其中包含一个列表，该列表汇总了所有案例的结果。对于每个案例，请按所列顺序输出三个值，顺序完全如下：最大回撤的样本均值、给定阈值的超额概率以及在水平 $q$ 处的经验分位数。按案例顺序将这些三元组连接起来，形成一个扁平列表。每个值必须四舍五入到恰好 $6$ 位小数。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，且不含空格。例如，对于两个案例，格式将是像 `[x_{1,1},x_{1,2},x_{1,3},x_{2,1},x_{2,2},x_{2,3}]` 这样的一行，其中 $x_{i,j}$ 表示案例 $i$ 的第 $j$ 个值。",
            "solution": "问题陈述经过了严格验证，并被认定为有效。它在科学上基于随机微积分的既定理论及其在金融建模中的应用，特别是几何布朗运动模型。该问题是适定的，所有参数、定义和约束都得到了清晰、客观的说明。它代表了计算金融领域一个标准的、可形式化的任务。因此，我将提供一个完整的解决方案。\n\n目标是计算与最大回撤 ($\\mathrm{MDD}$) 相关的统计数据，该投资组合的价值遵循几何布朗运动 (GBM)。过程 $S_t$ 由随机微分方程 $dS_t = \\mu S_t \\, dt + \\sigma S_t \\, dW_t$ 描述。我们将采用蒙特卡罗模拟方法，生成大量样本路径，计算每条路径的 $\\mathrm{MDD}$，然后从得到的 $\\mathrm{MDD}$ 值分布中计算所需的样本统计量。\n\n对于所提供的每一组参数，解决方法包括四个主要步骤。\n\n首先，初始化模拟参数。对于每个测试案例，我们给定初始投资组合价值 $S_0$、漂移 $\\mu$、波动率 $\\sigma$、时间范围 $T$、时间步数 $n$、模拟路径数 $N_{\\text{paths}}$、回撤阈值 $d^\\star$、分位数水平 $q$ 以及一个随机种子。时间离散化步长计算为 $\\Delta t = T/n$。为保证可复现性，为每个案例使用指定的种子初始化一个新的随机数生成器。\n\n其次，我们生成 GBM 过程的 $N_{\\text{paths}}$ 条样本路径。问题正确地指出，对于离散时间网格 $t_k = k \\Delta t$，GBM SDE 的精确解提供了以下关系：\n$$ S_{t_{k+1}} = S_{t_k} \\exp\\left( (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k \\right) $$\n其中每个 $Z_k$ 是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的独立随机变量。为保证数值稳定性和计算效率，我们首先模拟价格过程的对数 $X_t = \\log(S_t)$。对数价格过程的增量由下式给出：\n$$ X_{t_{k+1}} - X_{t_k} = (\\mu - \\frac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_k $$\n我们生成一个 $N_{\\text{paths}} \\times n$ 的标准正态随机数矩阵。然后，对每条路径，我们计算这些增量的累积和，以获得从 $X_0 = \\log(S_0)$ 开始的对数价格轨迹。最后，通过对对数价格路径取指数，我们得到价格路径 $S$。整个过程使用向量化的 `numpy` 操作实现，以高效地同时生成所有 $N_{\\text{paths}}$ 条路径。得到的资产价格矩阵 $S$ 的维度为 $N_{\\text{paths}} \\times (n+1)$。\n\n第三，对于每条模拟路径，我们计算最大回撤。时间 $t_k$ 的运行最大值定义为 $M_{t_k} = \\max_{0 \\le j \\le k} S_{t_j}$。时间 $t_k$ 的回撤为 $D_{t_k} = 1 - S_{t_k}/M_{t_k}$。单条路径的最大回撤为 $\\mathrm{MDD} = \\max_{0 \\le k \\le n} D_{t_k}$。在计算上，对于所有路径的矩阵 $S$，我们首先使用 `numpy.maximum.accumulate` 沿每一行（路径）计算运行最大值。这会产生一个运行最大值矩阵 $M$。然后，回撤矩阵 $D$ 计算为 $D = 1 - S/M$。通过取 $D$ 矩阵每一行的最大值，可以找到每条路径的最大回撤，从而得到一个包含 $N_{\\text{paths}}$ 个 $\\mathrm{MDD}$ 值的向量。\n\n第四，从表示为 $\\{\\mathrm{MDD}^{(i)}\\}_{i=1}^{N_{\\text{paths}}}$ 的 $N_{\\text{paths}}$ 个最大回撤样本中，我们计算所需的统计量：\n- 样本均值 $\\widehat{\\mathbb{E}}[\\mathrm{MDD}]$ 是 $\\mathrm{MDD}$ 样本的算术平均值。\n- 超额概率 $\\widehat{\\mathbb{P}}(\\mathrm{MDD} \\ge d^\\star)$ 是模拟路径中 $\\mathrm{MDD}$ 大于或等于指定阈值 $d^\\star$ 的路径所占的比例。\n- 经验分位数 $Q_q$ 是一个值，样本中 $q$ 比例的 $\\mathrm{MDD}$ 值低于该值。这是使用 `numpy.quantile` 函数计算的，该函数提供了样本分位数的标准实现。\n\n每个测试案例的这三个计算值被收集起来，四舍五入到 $6$ 位小数，并按照问题规定格式化为一个扁平列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating maximum drawdown statistics for a\n    Geometric Brownian Motion process via Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        # (S0, mu, sigma, T, n, N_paths, d_star, q, seed)\n        (100.0, 0.05, 0.20, 1.0, 252, 8000, 0.20, 0.95, 202311),\n        (100.0, 0.05, 0.0001, 1.0, 252, 8000, 0.01, 0.95, 202312),\n        (100.0, 0.00, 0.60, 1.0, 252, 8000, 0.50, 0.95, 202313),\n        (100.0, -0.10, 0.25, 2.0, 504, 8000, 0.30, 0.95, 202314),\n        (100.0, 0.02, 0.15, 0.25, 63, 8000, 0.10, 0.95, 202315),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        S0, mu, sigma, T, n, N_paths, d_star, q, seed = case\n\n        # Step 1: Initialization\n        # Set the time step and initialize the random number generator for reproducibility.\n        dt = T / n\n        rng = np.random.default_rng(seed)\n\n        # Step 2: Path Generation\n        # Generate N_paths x n matrix of standard normal random variates.\n        Z = rng.standard_normal(size=(N_paths, n))\n\n        # Calculate log-returns using the exact discretization of GBM's log-process.\n        # This results in an N_paths x n matrix.\n        log_returns = (mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z\n\n        # Compute log-prices by taking the cumulative sum of log-returns.\n        # The resulting matrix has shape N_paths x (n+1).\n        log_prices = np.zeros((N_paths, n + 1))\n        log_prices[:, 0] = np.log(S0)\n        log_prices[:, 1:] = np.log(S0) + np.cumsum(log_returns, axis=1)\n\n        # Convert log-prices to prices by exponentiation.\n        S = np.exp(log_prices)\n\n        # Step 3: Maximum Drawdown (MDD) Calculation\n        # Compute the running maximum for each path.\n        M = np.maximum.accumulate(S, axis=1)\n\n        # Compute the drawdown at each time step for each path.\n        # Division by zero is avoided as S0 > 0 implies M > 0.\n        D = 1 - S / M\n\n        # Find the maximum drawdown for each path by taking the max over time.\n        mdd_samples = np.max(D, axis=1)\n\n        # Step 4: Statistical Estimation\n        # Calculate the sample mean of the maximum drawdowns.\n        mean_mdd = np.mean(mdd_samples)\n\n        # Calculate the exceedance probability P(MDD >= d*).\n        exceedance_prob = np.mean(mdd_samples >= d_star)\n\n        # Calculate the empirical q-quantile of the maximum drawdowns.\n        quantile_mdd = np.quantile(mdd_samples, q)\n\n        results.extend([mean_mdd, exceedance_prob, quantile_mdd])\n\n    # Final print statement in the exact required format.\n    # Each value is formatted to 6 decimal places.\n    output_str = f\"[{','.join([f'{val:.6f}' for val in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "蒙特卡洛模拟是一个强大的工具，但理解其结果的准确性和局限性也同样重要。本练习不仅要求你为一种金融衍生品（数字期权）定价，更关键的是，它要求你将模拟结果与精确的解析解进行比较。通过这项实践，你将深入理解蒙特卡洛误差的概念，并观察误差大小如何随问题参数（如期权行使价）而变化，这对于任何模拟实践者都是一项至关重要的洞察 。",
            "id": "2403319",
            "problem": "要求您实现一个完整的、可运行的程序，通过蒙特卡洛模拟对数字现金或无价值看涨期权进行定价，并分析当行权价接近在风险中性测度下期权方差最大时的阈值时，蒙特卡洛误差的行为。请在标准的布莱克-斯科尔斯（Black–Scholes）框架下，使用风险中性测度进行操作。所有符号定义如下。\n\n定义与建模假设：\n- 标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 在风险中性测度下遵循几何布朗运动，其漂移率等于连续复利无风险利率 $r$，即 $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $\\sigma > 0$ 为恒定波动率，$\\{W_t\\}_{t \\ge 0}$ 为标准维纳过程。\n- $0$时刻现货价格为 $S_0$，到期日为 $T > 0$，行权价为 $K > 0$。当且仅当 $S_T \\ge K$ 时，该期权在时间 $T$ 支付固定现金金额 $L > 0$，否则支付0。到$0$时刻的折现因子为 $\\exp(-rT)$。\n\n基本原理：\n- 在风险中性测度下，$S_T$ 服从对数正态分布，$\\ln S_T$ 服从正态分布，其均值为 $\\ln S_0 + (r - \\tfrac{1}{2}\\sigma^2)T$，方差为 $\\sigma^2 T$。\n- 风险中性定价原理指出，任何可积支付 $X_T$ 的$0$时刻价格为 $\\exp(-rT)\\,\\mathbb{E}[X_T]$，其中期望是在风险中性测度下计算的。\n\n需实现与计算的任务：\n1. 通过使用模型隐含的对数正态表示，模拟 $N$ 次独立的 $S_T$ 抽样，从而为数字现金或无价值看涨期权的价格实现一个蒙特卡洛估计量。对所有行权价使用相同的标准正态抽样流（公共随机数），以分离出行权价本身对蒙特卡洛误差的影响。为保证可复现性，请使用固定的随机种子。\n2. 对每个行权价 $K$ 计算：\n   - 蒙特卡洛价格估计值 $\\hat{C}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{1}{N}\\sum_{i=1}^{N} L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$。\n   - 蒙特卡洛标准误 $\\widehat{\\text{se}}_{\\text{MC}}(K) = \\exp(-rT)\\,\\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}}$，其中 $\\widehat{\\sigma}_{\\text{payoff}}$ 是使用总体归一化计算的未折现模拟支付 $L \\,\\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ 的样本标准差。\n3. 从基本原理出发，推导并计算解析价格 $C_{\\text{BS}}(K)$。请勿假设任何未从模型的 $\\ln S_T$ 高斯性质和风险中性定价原理推导出的定价捷径。此外，通过使用成功概率为 $p(K) = \\mathbb{P}(S_T \\ge K)$ 的伯努利随机变量的方差，推导并计算相应的解析蒙特卡洛标准误 $\\text{se}_{\\text{BS}}(K)$。\n4. 使用以下参数值和一组测试行权价，以展示当行权价在最大方差水平附近移动时蒙特卡洛误差的行为：\n   - 全局参数：$S_0 = 100$，$r = 0.02$，$\\sigma = 0.2$，$T = 1$，$L = 1$，$N = 200000$。\n   - 待评估的行权价：$K \\in \\{60, 90, 100, 110, 140\\}$。\n   - 对伪随机数生成器使用固定的种子 $123456$，并对不同行权价使用公共随机数。\n\n答案规格与输出格式：\n- 对于指定集合中的每个行权价 $K$，您的程序必须按此确切顺序计算一个包含以下五个条目的列表：`[K, \\hat{C}_{\\text{MC}}(K), C_{\\text{BS}}(K), \\widehat{\\text{se}}_{\\text{MC}}(K), \\text{se}_{\\text{BS}}(K)]`。\n- 最终程序输出必须是单行，由这些按行权价列表组成的、由方括号括起且以逗号分隔的列表构成，并保持与输入相同的行权价顺序。例如，一个语法有效的输出结构为 `[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]`，且仅包含十进制数。请勿打印任何额外文本。\n\n注意：\n- 所有输出均以十进制数（浮点数）表示，不含任何货币符号。\n- 不涉及角度；无需角度单位。",
            "solution": "所提出的问题是计算金融学中的一个标准练习，其科学依据充分、问题适定且完整。它被验证为一个可以构建解决方案的合理问题。任务是使用从布莱克-斯科尔斯（Black-Scholes）模型推导出的解析公式和蒙特卡洛模拟两种方法，对一个数字现金或无价值看涨期权进行定价。我们还将分析蒙特卡洛估计误差的行为。\n\n首先，我们推导期权的解析价格。该期权在到期日 $T$ 的支付是：如果资产价格 $S_T$ 大于或等于行权价 $K$，则支付为 $L$；否则为0。支付函数为 $X_T = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。根据风险中性定价原理，期权在时间 $t=0$ 的价格，记为 $C(K)$，是在风险中性测度 $\\mathbb{Q}$ 下的折现期望支付：\n$$C(K) = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[X_T] = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[L \\cdot \\mathbf{1}\\{S_T \\ge K\\}]$$\n根据期望的线性性质，这变为：\n$$C(K) = L e^{-rT} \\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}\\{S_T \\ge K\\}] = L e^{-rT} \\mathbb{Q}(S_T \\ge K)$$\n问题指出，在测度 $\\mathbb{Q}$ 下，资产价格遵循几何布朗运动，这意味着 $\\ln S_T$ 服从正态分布。其均值和方差由下式给出：\n$$ \\ln S_T \\sim \\mathcal{N}\\left(\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T\\right) $$\n为了计算概率 $\\mathbb{Q}(S_T \\ge K)$，我们对随机变量 $\\ln S_T$ 进行标准化。条件 $S_T \\ge K$ 等价于 $\\ln S_T \\ge \\ln K$：\n$$ \\mathbb{Q}(\\ln S_T \\ge \\ln K) = \\mathbb{Q}\\left(\\frac{\\ln S_T - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}} \\ge \\frac{\\ln K - (\\ln S_0 + (r - \\frac{1}{2}\\sigma^2)T)}{\\sigma\\sqrt{T}}\\right) $$\n左侧项是一个标准正态随机变量 $Z \\sim \\mathcal{N}(0, 1)$。右侧的表达式通常被处理成标准的布莱克-斯科尔斯（Black-Scholes）$d_2$ 参数：\n$$ d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n因此，概率为：\n$$\\mathbb{Q}(S_T \\ge K) = \\mathbb{Q}(Z \\ge -d_2) = \\mathbb{Q}(Z \\le d_2) = \\Phi(d_2)$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。因此，我们记为 $C_{\\text{BS}}(K)$ 的解析价格是：\n$$ C_{\\text{BS}}(K) = L e^{-rT} \\Phi(d_2) $$\n\n接下来，我们推导蒙特卡洛估计量的标准误的解析公式。蒙特卡洛价格估计量为 $\\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}$，其中 $Y^{(i)} = L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\}$ 是未折现支付的独立样本。标准误是该估计量方差的平方根：\n$$ \\text{se}(\\hat{C}_{\\text{MC}}(K)) = \\sqrt{\\text{Var}(\\hat{C}_{\\text{MC}}(K))} = \\sqrt{\\text{Var}\\left(e^{-rT} \\frac{1}{N}\\sum_{i=1}^{N} Y^{(i)}\\right)} $$\n利用方差的性质，上式可简化为：\n$$\\text{se}(\\hat{C}_{\\text{MC}}(K)) = e^{-rT} \\sqrt{\\frac{\\text{Var}(Y^{(1)})}{N}} = \\frac{e^{-rT} \\sigma_{\\text{payoff}}}{\\sqrt{N}}$$\n其中 $\\sigma_{\\text{payoff}}$ 是单个未折现支付的标准差。支付随机变量 $Y = L \\cdot \\mathbf{1}\\{S_T \\ge K\\}$ 是一个缩放的伯努利变量。它以成功概率 $p(K) = \\mathbb{Q}(S_T \\ge K) = \\Phi(d_2)$ 取值 $L$，否则取0。$Y$ 的方差为：\n$$ \\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2 = (L^2 \\cdot p(K)) - (L \\cdot p(K))^2 = L^2 p(K)(1 - p(K)) $$\n支付的标准差为 $\\sigma_{\\text{payoff}} = \\sqrt{\\text{Var}(Y)} = L \\sqrt{p(K)(1 - p(K))}$。因此，记为 $\\text{se}_{\\text{BS}}(K)$ 的解析蒙特卡洛标准误是：\n$$ \\text{se}_{\\text{BS}}(K) = \\frac{e^{-rT} L \\sqrt{\\Phi(d_2)(1 - \\Phi(d_2))}}{\\sqrt{N}} $$\n\n蒙特卡洛模拟的实现方式是：生成 $N$ 个标准正态随机变量 $Z^{(i)}$ 的独立抽样，并用它们来计算 $N$ 个模拟的终端资产价格：\n$$ S_T^{(i)} = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T} Z^{(i)} \\right) $$\n对于每个行权价 $K$，蒙特卡洛价格估计值 $\\hat{C}_{\\text{MC}}(K)$ 是模拟支付的折现样本均值：\n$$ \\hat{C}_{\\text{MC}}(K) = e^{-rT} \\frac{1}{N} \\sum_{i=1}^{N} L \\cdot \\mathbf{1}\\{S_T^{(i)} \\ge K\\} $$\n估计标准误 $\\widehat{\\text{se}}_{\\text{MC}}(K)$ 是使用未折现支付的样本标准差 $\\widehat{\\sigma}_{\\text{payoff}}$ 计算的。按照规定，使用总体归一化（即除以 $N$）：\n$$ \\widehat{\\sigma}_{\\text{payoff}} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(Y^{(i)} - \\bar{Y}\\right)^2}, \\quad \\text{where } \\bar{Y} = \\frac{1}{N} \\sum_{i=1}^{N} Y^{(i)} $$\n$$ \\widehat{\\text{se}}_{\\text{MC}}(K) = e^{-rT} \\frac{\\widehat{\\sigma}_{\\text{payoff}}}{\\sqrt{N}} $$\n为确保不同行权价之间的可比性，我们使用公共随机数，这意味着对所有 $K$ 值，都使用同一组 $N$ 次抽样 $\\{Z^{(i)}\\}$ 来生成资产价格路径 $\\{S_T^{(i)}\\}$。为确保可复现性，随机数生成器使用固定的种子。\n\n由标准误表示的蒙特卡洛误差与 $\\sqrt{p(K)(1 - p(K))}$ 成正比。当行权概率 $p(K) = \\Phi(d_2) = 0.5$ 时，该项达到最大值，这发生在 $d_2 = 0$ 时。解出 $K$ 可得到最大方差对应的行权价：\n$$ K_{\\text{max var}} = S_0 \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)T\\right) $$\n对于给定的参数 $S_0=100$，$r=0.02$，$\\sigma=0.2$ 和 $T=1$，这得出 $K_{\\text{max var}} = 100 \\cdot \\exp(0.02-0.02) = 100$。所提供的行权价集合 $\\{60, 90, 100, 110, 140\\}$ 是经过适当选择的，旨在展示误差在这一点最大不确定性点周围的行为。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes analytical and Monte Carlo prices and standard errors for a digital\n    cash-or-nothing call option under the Black-Scholes framework.\n    \"\"\"\n    # Global parameters from the problem statement\n    S0 = 100.0\n    r = 0.02\n    sigma = 0.2\n    T = 1.0\n    L = 1.0\n    N = 200000\n\n    # Strike prices to evaluate\n    K_values = [60.0, 90.0, 100.0, 110.0, 140.0]\n\n    # Fixed seed for reproducibility\n    seed = 123456\n\n    # --- Monte Carlo Simulation Setup ---\n    # Use a single stream of random numbers for all strikes (common random numbers)\n    rng = np.random.default_rng(seed)\n    z = rng.standard_normal(N)\n\n    # Simulate terminal asset prices based on the lognormal property\n    drift = (r - 0.5 * sigma**2) * T\n    diffusion = sigma * np.sqrt(T)\n    S_T = S0 * np.exp(drift + diffusion * z)\n\n    # --- Calculation Loop ---\n    results = []\n    discount_factor = np.exp(-r * T)\n\n    for K in K_values:\n        # 1. Analytical Calculations (Black-Scholes)\n        d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        p_K = norm.cdf(d2)  # Probability P(S_T >= K)\n\n        # Analytical price\n        C_bs = L * discount_factor * p_K\n        \n        # Analytical standard error of the MC estimator\n        payoff_var_analytical = (L**2) * p_K * (1 - p_K)\n        se_bs = discount_factor * np.sqrt(payoff_var_analytical / N)\n\n        # 2. Monte Carlo Estimators\n        # Calculate undiscounted payoffs for each simulated path\n        payoffs = L * (S_T >= K)\n\n        # Monte Carlo price estimate\n        mean_payoff = np.mean(payoffs)\n        C_mc = discount_factor * mean_payoff\n\n        # Monte Carlo standard error estimate\n        # Use population standard deviation (ddof=0) as specified\n        payoff_std_sample = np.std(payoffs, ddof=0)\n        se_mc = discount_factor * payoff_std_sample / np.sqrt(N)\n        \n        # Store the five required values for a given strike K\n        results.append([K, C_mc, C_bs, se_mc, se_bs])\n\n    # --- Output Formatting ---\n    # The final output must be a single line in the format [[...],[...],...]\n    # without extra spaces.\n    list_of_strings = []\n    for sublist in results:\n        # Format each sublist as a string \"[v1,v2,v3,v4,v5]\"\n        str_sublist = \"[\" + \",\".join(map(str, sublist)) + \"]\"\n        list_of_strings.append(str_sublist)\n\n    final_output = \"[\" + \",\".join(list_of_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}