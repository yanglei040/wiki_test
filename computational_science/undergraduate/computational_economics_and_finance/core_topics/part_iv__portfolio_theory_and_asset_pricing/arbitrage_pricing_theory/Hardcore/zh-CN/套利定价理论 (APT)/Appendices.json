{
    "hands_on_practices": [
        {
            "introduction": "套利定价理论（APT）的一个核心应用是构建能够精确捕捉特定风险因子回报的投资组合。本练习将指导您完成一个基础但至关重要的任务：构建一个“纯因子”投资组合。通过应用二次优化方法，您将学习如何构建一个对目标因子具有单位暴露、对其他因子保持中性，同时最小化整体投资组合风险的投资组合。",
            "id": "2372091",
            "problem": "设计一个程序，从第一性原理出发，使用二次优化构建套利定价理论（Arbitrage Pricing Theory, APT）意义下的“纯因子”投资组合。对于每个测试用例，给定一个因子载荷矩阵 $B \\in \\mathbb{R}^{N \\times K}$、一个对称正定资产收益协方差矩阵 $\\Sigma \\in \\mathbb{R}^{N \\times N}$ 以及一个目标因子索引 $j \\in \\{1,\\dots,K\\}$。任务是计算投资组合权重 $w \\in \\mathbb{R}^{N}$，该权重在满足对目标因子有单位敞口、对所有其他因子有零敞口，并且是零投资（资金中性）的约束条件下，最小化投资组合的方差。\n\n形式上，对于每个测试用例，求解以下优化问题：\n最小化投资组合方差\n$$\n\\min_{w \\in \\mathbb{R}^{N}} \\; w^{\\top} \\Sigma \\, w\n$$\n受限于以下线性等式约束\n$$\nB^{\\top} w \\;=\\; e_j, \\quad \\mathbf{1}^{\\top} w \\;=\\; 0,\n$$\n其中 $e_j \\in \\mathbb{R}^{K}$ 是第 $j$ 个标准基向量（即在位置 $j$ 为 $1$，其他位置为 $0$ 的向量），$\\mathbf{1} \\in \\mathbb{R}^{N}$ 表示全为1的向量。所有量均无单位；任何“百分比”必须以小数形式表示。\n\n您的程序必须为每个测试用例生成三个诊断指标：\n- 最大绝对因子敞口偏差\n$$\n\\epsilon_{\\text{fac}} \\;=\\; \\max_{1 \\le k \\le K} \\left| \\left(B^{\\top} w\\right)_k - (e_j)_k \\right|.\n$$\n- 绝对净投资额\n$$\n\\epsilon_{\\text{net}} \\;=\\; \\left| \\mathbf{1}^{\\top} w \\right|.\n$$\n- 实现的最小方差\n$$\nv \\;=\\; w^{\\top} \\Sigma \\, w.\n$$\n\n您对每个测试用例的输出必须是列表 $[\\epsilon_{\\text{fac}}, \\epsilon_{\\text{net}}, v]$，其中每个值都四舍五入到 $8$ 位小数。\n\n测试套件。请严格使用以下三个测试用例：\n\n测试用例 A（标准路径）：\n- $N = 5$, $K = 2$, $j = 1$。\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n0.5  1.0 \\\\\n1.2  -0.3 \\\\\n-0.7  0.8 \\\\\n0.0  -0.5 \\\\\n0.9  0.2\n\\end{bmatrix}.\n$$\n- 协方差（对角、正定）\n$$\n\\Sigma \\;=\\; \\mathrm{diag}\\!\\left(0.04, \\; 0.09, \\; 0.025, \\; 0.16, \\; 0.0625\\right).\n$$\n\n测试用例 B（边界情况：$N = K+1$，存在唯一可行解）：\n- $N = 3$, $K = 2$, $j = 1$。\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n1.0  0.0 \\\\\n0.5  1.0 \\\\\n-0.5  0.5\n\\end{bmatrix}.\n$$\n- 协方差（对角、正定）\n$$\n\\Sigma \\;=\\; \\mathrm{diag}\\!\\left(0.01, \\; 0.02, \\; 0.03\\right).\n$$\n\n测试用例 C（病态但正定的协方差）：\n- $N = 8$, $K = 3$, $j = 1$。\n- 因子载荷\n$$\nB \\;=\\;\n\\begin{bmatrix}\n0.2  -0.1  0.3 \\\\\n1.1  0.4  -0.2 \\\\\n-0.3  0.9  0.5 \\\\\n0.0  -0.2  0.1 \\\\\n0.7  0.0  -0.4 \\\\\n-0.6  0.3  0.2 \\\\\n0.4  -0.5  0.0 \\\\\n0.8  0.1  0.6\n\\end{bmatrix}.\n$$\n- 协方差定义为\n$$\n\\Sigma \\;=\\; D \\;+\\; 0.001 \\cdot \\mathbf{1}\\mathbf{1}^{\\top},\n$$\n其中 $D = \\mathrm{diag}\\!\\left(0.04, \\; 0.01, \\; 0.09, \\; 0.0025, \\; 0.0225, \\; 0.01, \\; 0.04, \\; 0.0025\\right)$ 且 $\\mathbf{1}\\mathbf{1}^{\\top}$ 是 $N \\times N$ 的全1矩阵。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由三个元素列表组成的逗号分隔列表，每个内部列表按 A、B、C 的顺序对应一个测试用例。每个数字必须四舍五入到 $8$ 位小数。例如，输出格式必须是\n$$\n\\texttt{[[a\\_1,a\\_2,a\\_3],[b\\_1,b\\_2,b\\_3],[c\\_1,c\\_2,c\\_3]]}\n$$\n不带任何额外文本，其中每个符号代表一个如上指定的小数。",
            "solution": "所呈现的问题是一个约束二次优化任务，这是计算金融学中的一个基本问题，特别是在套利定价理论（APT）背景下的投资组合构建中。其目标是找到一个投资组合权重向量 $w$，该向量在满足一组定义投资组合对系统性风险因子的敞口及其净投资额的线性约束的同时，最小化风险（以投资组合方差量化）。\n\n该问题可以正式表述如下。找到投资组合权重向量 $w \\in \\mathbb{R}^{N}$，该向量求解：\n$$\n\\min_{w} f(w) = \\frac{1}{2} w^{\\top} \\Sigma w\n$$\n受限于以下线性等式约束：\n$$\nB^{\\top} w = e_j\n$$\n$$\n\\mathbf{1}^{\\top} w = 0\n$$\n这里，$w$ 是 $N \\times 1$ 的资产权重向量，$\\Sigma$ 是 $N \\times N$ 的对称正定资产收益协方差矩阵，$B$ 是 $N \\times K$ 的因子载荷矩阵，$\\mathbf{1}$ 是 $N \\times 1$ 的全1向量，$e_j$ 是 $K \\times 1$ 的标准基向量，其第 $j$ 个位置为1，其余位置为0。因子 $\\frac{1}{2}$ 的引入是为了数学上的便利，它不改变最小值的位置。\n\n约束可以合并为单个矩阵方程 $C w = d$，其中 $C$ 是一个 $(K+1) \\times N$ 的矩阵，$d$ 是一个 $(K+1) \\times 1$ 的向量：\n$$\nC = \\begin{bmatrix} B^{\\top} \\\\ \\mathbf{1}^{\\top} \\end{bmatrix}, \\quad d = \\begin{bmatrix} e_j \\\\ 0 \\end{bmatrix}\n$$\n因此，该问题是一个标准的等式约束二次规划问题。由于协方差矩阵 $\\Sigma$ 是正定的，目标函数 $f(w)$ 是严格凸的。这一性质与约束的线性特性相结合，保证了唯一全局最小值的存在，前提是约束系统是可行的且 $C$ 的行是线性无关的。\n\n为了找到解析解，我们采用拉格朗日乘子法。该问题的拉格朗日函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(w, \\lambda) = \\frac{1}{2} w^{\\top} \\Sigma w + \\lambda^{\\top} (d - Cw)\n$$\n其中 $\\lambda$ 是一个 $(K+1) \\times 1$ 的拉格朗日乘子向量。最优性的一阶必要条件要求拉格朗日函数关于 $w$ 和 $\\lambda$ 的梯度为零。\n\n关于 $w$ 的梯度是：\n$$\n\\nabla_w \\mathcal{L} = \\Sigma w - C^{\\top} \\lambda = 0\n$$\n由于 $\\Sigma$ 是正定的，它是可逆的。因此，我们可以用 $\\lambda$ 来表示 $w$：\n$$\nw = \\Sigma^{-1} C^{\\top} \\lambda\n$$\n关于 $\\lambda$ 的梯度只是恢复了线性约束：\n$$\n\\nabla_\\lambda \\mathcal{L} = d - Cw = 0 \\implies Cw = d\n$$\n将 $w$ 的表达式代入约束方程，得到：\n$$\nC (\\Sigma^{-1} C^{\\top} \\lambda) = d\n$$\n这可以写成关于拉格朗日乘子 $\\lambda$ 的一个线性系统：\n$$\n(C \\Sigma^{-1} C^{\\top}) \\lambda = d\n$$\n矩阵 $M = C \\Sigma^{-1} C^{\\top}$ 是一个 $(K+1) \\times (K+1)$ 的矩阵。鉴于 $\\Sigma^{-1}$ 是正定的，并且我们假设约束矩阵 $C$ 具有行满秩（即其行线性无关），矩阵 $M$ 也是正定且因此可逆的。我们可以解出 $\\lambda$：\n$$\n\\lambda = (C \\Sigma^{-1} C^{\\top})^{-1} d\n$$\n最后，将此 $\\lambda$ 的表达式代回 $w$ 的方程中，便可得到最优投资组合权重的闭式解：\n$$\nw = \\Sigma^{-1} C^{\\top} (C \\Sigma^{-1} C^{\\top})^{-1} d\n$$\n一个特殊情况出现在 $N = K+1$ 时，如测试用例 B。此时，约束矩阵 $C$ 是方阵。如果它是可逆的，系统 $Cw=d$ 有唯一解 $w=C^{-1}d$。这个唯一的可行点根据定义就是最小值。通用公式正确地退化到这种情况，因为 $w = \\Sigma^{-1} C^{\\top} (C^{\\top})^{-1} \\Sigma C^{-1} d = C^{-1}d$。\n\n计算步骤如下：\n1.  对于每个测试用例，构建矩阵 $B$、$\\Sigma$ 和参数 $N$、$K$、$j$。\n2.  构建复合约束矩阵 $C$ 和目标向量 $d$。注意，问题指定的 $j$ 是1-索引的，必须转换为0-索引以进行数组操作。\n3.  计算协方差矩阵的逆 $\\Sigma^{-1}$。\n4.  构建矩阵 $M = C \\Sigma^{-1} C^{\\top}$。\n5.  求解线性系统 $M \\lambda = d$ 以得到向量 $\\lambda$。使用线性求解器在数值上优于显式计算 $M$ 的逆。\n6.  计算最优权重向量 $w = \\Sigma^{-1} C^{\\top} \\lambda$。\n7.  使用计算出的 $w$，计算三个所需的诊断量：\n    - 最大绝对因子敞口偏差：$\\epsilon_{\\text{fac}} = \\max_{k} |(B^{\\top} w)_k - (e_j)_k|$。\n    - 绝对净投资额：$\\epsilon_{\\text{net}} = |\\mathbf{1}^{\\top} w|$。\n    - 最小投资组合方差：$v = w^{\\top} \\Sigma w$。\n\n$\\epsilon_{\\text{fac}}$ 和 $\\epsilon_{\\text{net}}$ 的数值结果应接近机器精度，这确认了实现在满足约束方面的准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_single_case(B, Sigma, j, N, K):\n    \"\"\"\n    Solves the quadratic optimization problem for a single test case.\n\n    Args:\n        B (np.ndarray): Factor loading matrix (N x K).\n        Sigma (np.ndarray): Asset return covariance matrix (N x N).\n        j (int): 1-based index of the target factor.\n        N (int): Number of assets.\n        K (int): Number of factors.\n\n    Returns:\n        list: A list containing [eps_fac, eps_net, variance].\n    \"\"\"\n    # Convert 1-based target factor index to 0-based\n    target_idx = j - 1\n\n    # Construct the constraint matrix C of size (K+1) x N\n    C_mat = np.vstack([B.T, np.ones(N)])\n\n    # Construct the constraint target vector d of size (K+1)\n    d_vec = np.zeros(K + 1)\n    d_vec[target_idx] = 1.0\n\n    # Since Sigma is positive definite, its inverse exists.\n    Sigma_inv = np.linalg.inv(Sigma)\n\n    # Form the matrix for the linear system for Lagrange multipliers.\n    # M = C * Sigma_inv * C.T, which is of size (K+1) x (K+1).\n    M = C_mat @ Sigma_inv @ C_mat.T\n\n    # Solve the system M * lambda = d for the Lagrange multipliers lambda.\n    # This is numerically more stable than computing inv(M).\n    try:\n        lambda_vec = np.linalg.solve(M, d_vec)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if M is singular, though not expected\n        # for valid problems.\n        lambda_vec = np.linalg.pinv(M) @ d_vec\n\n    # Calculate the optimal portfolio weights w = Sigma_inv * C.T * lambda\n    w = Sigma_inv @ C_mat.T @ lambda_vec\n\n    # --- Calculate Diagnostics ---\n\n    # 1. Maximum absolute factor exposure deviation (eps_fac)\n    ej_vec = np.zeros(K)\n    ej_vec[target_idx] = 1.0\n    factor_exposures = B.T @ w\n    eps_fac = np.max(np.abs(factor_exposures - ej_vec))\n\n    # 2. Absolute net investment (eps_net)\n    net_investment = np.sum(w)\n    eps_net = np.abs(net_investment)\n\n    # 3. Achieved minimum variance (v)\n    variance = w.T @ Sigma @ w\n\n    return [eps_fac, eps_net, variance]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Test case A (happy path)\n    B_A = np.array([\n        [0.5, 1.0], [1.2, -0.3], [-0.7, 0.8], [0.0, -0.5], [0.9, 0.2]\n    ])\n    Sigma_A = np.diag([0.04, 0.09, 0.025, 0.16, 0.0625])\n    N_A, K_A, j_A = 5, 2, 1\n\n    # Test case B (boundary: N = K+1)\n    B_B = np.array([[1.0, 0.0], [0.5, 1.0], [-0.5, 0.5]])\n    Sigma_B = np.diag([0.01, 0.02, 0.03])\n    N_B, K_B, j_B = 3, 2, 1\n\n    # Test case C (ill-conditioned covariance)\n    B_C = np.array([\n        [0.2, -0.1, 0.3], [1.1, 0.4, -0.2], [-0.3, 0.9, 0.5],\n        [0.0, -0.2, 0.1], [0.7, 0.0, -0.4], [-0.6, 0.3, 0.2],\n        [0.4, -0.5, 0.0], [0.8, 0.1, 0.6]\n    ])\n    N_C, K_C, j_C = 8, 3, 1\n    D_C = np.diag([0.04, 0.01, 0.09, 0.0025, 0.0225, 0.01, 0.04, 0.0025])\n    ones_mat_C = np.ones((N_C, N_C))\n    Sigma_C = D_C + 0.001 * ones_mat_C\n\n    test_cases = [\n        (B_A, Sigma_A, j_A, N_A, K_A),\n        (B_B, Sigma_B, j_B, N_B, K_B),\n        (B_C, Sigma_C, j_C, N_C, K_C),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, Sigma, j, N, K = case\n        res = solve_single_case(B, Sigma, j, N, K)\n        results.append(res)\n\n    # Format the final output string as per requirements\n    formatted_results = []\n    for res_list in results:\n        # Format each number to 8 decimal places\n        formatted_list = [f\"{val:.8f}\" for val in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在将APT模型应用于实际数据之前，我们必须首先估计资产对各个因子的敏感度，即因子载荷（$\\beta$）。然而，金融市场数据常表现出“肥尾”特性，即极端事件（离群值）的发生频率高于正态分布的预期。本练习通过模拟这一现实情境，让您比较传统最小二乘法（OLS）与更稳健的Huber回归在估计因子载荷时的表现，从而深刻理解在存在离群值时选择正确估计方法的重要性。",
            "id": "2372129",
            "problem": "考虑套利定价理论 (APT) 的线性多因子表示，其中对于每个资产指数 $i \\in \\{1,\\dots,N\\}$ 和时间指数 $t \\in \\{1,\\dots,T\\}$，收益率 $R_{i,t}$ 满足\n$$\nR_{i,t} \\;=\\; a_i \\;+\\; \\sum_{k=1}^{K} b_{i k}\\, f_{k,t} \\;+\\; \\varepsilon_{i,t}.\n$$\n假设以下数据生成过程。\n- 截距项对所有 $i$ 满足 $a_i = 0$。\n- 因子载荷对 $i$ 和 $k$ 独立地满足 $b_{i k} \\sim \\mathcal{N}(0,1)$。\n- 因子对 $k$ 和 $t$ 独立地满足 $f_{k,t} \\sim \\mathcal{N}(0,1)$，并且与所有其他随机元素独立。\n- 特异性误差是肥尾的。令 $z_{i,t}$ 为自由度为 $\\nu$ 的独立同分布 (i.i.d.) 标准学生t分布变量，对于 $\\nu>2$，其方差通常为 $\\nu/(\\nu-2)$。定义单位方差变换 $e_{i,t} = \\sqrt{\\frac{\\nu-2}{\\nu}}\\, z_{i,t}$，使得 $\\mathrm{Var}(e_{i,t}) = 1$。设误差标准差为 $\\sigma_{\\varepsilon} = 0.5$，并设 $\\varepsilon_{i,t} = \\sigma_{\\varepsilon} e_{i,t}$。\n\n对于每个资产 $i$，考虑基于 $T$ 个观测值 $\\{(R_{i,t}, f_{1,t},\\dots,f_{K,t})\\}_{t=1}^{T}$ 和一个截距项，通过两种估计量来估计 $K$ 维因子载荷向量 $(b_{i1},\\dots,b_{iK})$。令 $X_t = (1, f_{1,t}, \\dots, f_{K,t})$ 和 $\\theta_i = (a_i, b_{i1},\\dots,b_{iK})$。\n- 普通最小二乘 (OLS) 估计量是以下目标函数的最小化子\n$$\n\\sum_{t=1}^{T} \\left(R_{i,t} - X_t \\theta_i\\right)^2.\n$$\n- Huber 稳健估计量是以下目标函数的最小化子\n$$\n\\sum_{t=1}^{T} \\rho_{\\kappa}\\!\\left(R_{i,t} - X_t \\theta_i\\right),\n$$\n其中带阈值 $\\kappa$ 的 Huber 损失为\n$$\n\\rho_{\\kappa}(u) \\;=\\; \\begin{cases} \\frac{1}{2}u^2,  \\text{if } |u| \\le \\kappa, \\\\ \\kappa\\left(|u| - \\frac{1}{2}\\kappa\\right),  \\text{if } |u| > \\kappa. \\end{cases}\n$$\n其中 $\\kappa = c\\,\\sigma_{\\varepsilon}$ 且 $c = 1.345$。\n\n对于每个估计量，将所有资产和因子的因子载荷估计的均方根误差 (RMSE) 定义为\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N K} \\sum_{i=1}^{N} \\sum_{k=1}^{K} \\left(\\widehat{b}_{i k} - b_{i k}\\right)^2},\n$$\n其中 $\\widehat{b}_{ik}$ 是资产 $i$ 和因子 $k$ 的估计因子载荷（不包括截距项）。\n\n模拟协议和测试套件：\n- 使用固定的基础伪随机种子 $s = 20231105$。对于测试用例索引 $j \\in \\{0,1,2,3\\}$，在为该测试用例生成所有随机元素之前，将伪随机种子设置为 $s+j$。\n- 对于下面的每个测试用例，从模型中生成一个模拟面板 $\\{R_{i,t}\\}$，并计算 OLS 估计量和 Huber 稳健估计量的 RMSE。对于该测试用例，输出布尔指标\n$$\nI_j \\;=\\; \\mathbf{1}\\!\\left\\{\\mathrm{RMSE}_{\\text{robust}}  \\mathrm{RMSE}_{\\text{OLS}}\\right\\}.\n$$\n\n测试套件（每个测试用例指定为 $(N, K, T, \\nu)$）：\n1. $(50, 3, 250, 30)$。\n2. $(50, 3, 250, 3)$。\n3. $(50, 3, 60, 4)$。\n4. $(200, 5, 250, 3)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为方括号括起来的逗号分隔列表，即 $[I_0,I_1,I_2,I_3]$（例如，`[True,False,True,True]`）。不应打印任何其他文本。",
            "solution": "该问题陈述已经过严格验证，被认为是有效的。它在科学上基于金融计量经济学的原理，特别是套利定价理论 (APT)，并提出了一个适定、客观且完整的计算任务。所有参数、分布和程序都以足够的精度定义，以确保解决方案的唯一性和可复现性。\n\n任务是比较 APT 模型中因子载荷的两种估计量的性能：普通最小二乘 (OLS) 和使用 Huber 损失函数的稳健 M-估计量。该比较将通过模拟研究在模型的不同参数化下进行，特别是关于特异性误差分布的尾部厚度。\n\n资产收益率模型由下式给出\n$$\nR_{i,t} \\;=\\; a_i \\;+\\; \\sum_{k=1}^{K} b_{i k}\\, f_{k,t} \\;+\\; \\varepsilon_{i,t}\n$$\n其中 $a_i$ 是截距项，$b_{ik}$ 是因子载荷，$f_{k,t}$ 是系统性因子，$\\varepsilon_{i,t}$ 是特异性误差。数据生成过程的参数指定为：$a_i = 0$，$b_{i k} \\sim \\mathcal{N}(0,1)$，以及 $f_{k,t} \\sim \\mathcal{N}(0,1)$。\n\n该模型的一个关键特征是特异性误差 $\\varepsilon_{i,t}$ 的分布。这些误差被指定为肥尾分布，遵循一个缩放的学生t分布。具体来说，$\\varepsilon_{i,t} = \\sigma_{\\varepsilon} e_{i,t}$，其中 $\\sigma_{\\varepsilon} = 0.5$，$e_{i,t}$ 是一个自由度为 $\\nu$ 的标准学生t变量 $z_{i,t}$ 的变换，$e_{i,t} = \\sqrt{(\\nu-2)/\\nu} \\, z_{i,t}$。当 $\\nu > 2$ 时，此变换确保 $\\mathrm{Var}(e_{i,t}) = 1$，因此 $\\mathrm{Var}(\\varepsilon_{i,t}) = \\sigma_{\\varepsilon}^2$。自由度参数 $\\nu$ 控制误差分布的尾部厚度；较小的 $\\nu$ 值对应于更重的尾部和更高的极端值（异常值）出现概率。\n\n对于每个资产 $i$，参数向量 $\\theta_i = (a_i, b_{i1},\\dots,b_{iK})^T$ 使用 $T$ 个时间序列观测值进行估计。资产 $i$ 的回归模型为 $R_i = X \\theta_i + \\varepsilon_i$，其中 $R_i$ 是 $T \\times 1$ 的收益率向量，$X$ 是 $T \\times (K+1)$ 的设计矩阵，其列为 $(1, f_{1,\\cdot}, \\dots, f_{K,\\cdot})$，$\\varepsilon_i$ 是 $T \\times 1$ 的误差向量。\n\n这两种估计量是：\n1.  **普通最小二乘 (OLS)**：该估计量最小化残差平方和 $\\sum_{t=1}^{T} (R_{i,t} - X_t \\theta_i)^2$。其解具有闭式形式 $\\widehat{\\theta}_{i,\\text{OLS}} = (X^T X)^{-1} X^T R_i$。虽然在高斯-马尔可夫假设下（此处成立，因为误差是独立且同方差的），OLS 是最佳线性无偏估计量，但当误差分布不是正态分布而是肥尾分布时，由于其对大残差的敏感性，其效率会显著下降。\n\n2.  **Huber 稳健估计量**：该 M-估计量最小化 Huber 损失之和 $\\sum_{t=1}^{T} \\rho_{\\kappa}(R_{i,t} - X_t \\theta_i)$。Huber 损失函数 $\\rho_{\\kappa}(u)$ 对于小参数 ($|u| \\le \\kappa$) 是二次的，对于大参数 ($|u| > \\kappa$) 是线性的。这种混合特性使得该估计量对于具有小残差的观测值表现得像 OLS，但减少了具有大残差（异常值）的观测值的影响，从而提供了稳健性。阈值设置为 $\\kappa = c\\,\\sigma_{\\varepsilon} = 1.345 \\times 0.5 = 0.6725$。这个凸目标函数的最小化没有闭式解，需要数值优化。像 BFGS 这样的拟牛顿法是完成此任务的合适算法。\n\n估计量的性能使用因子载荷估计值 $\\widehat{b}_{ik}$ 的均方根误差 (RMSE) 进行评估，定义如下：\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{N K} \\sum_{i=1}^{N} \\sum_{k=1}^{K} \\left(\\widehat{b}_{i k} - b_{i k}\\right)^2}\n$$\n对于每个测试用例，我们计算一个布尔指标 $I_j = \\mathbf{1}\\{\\mathrm{RMSE}_{\\text{robust}}  \\mathrm{RMSE}_{\\text{OLS}}\\}$。我们预期当误差分布具有重尾（小 $\\nu$）时，稳健估计量的性能会优于 OLS（即产生更小的 RMSE），而当误差接近正态分布（大 $\\nu$）时，OLS 可能略有优势。\n\n解决方案通过实施指定的模拟协议来进行。对于每个测试用例，所有随机元素都基于一个固定的种子生成。然后，对于 $N$ 个资产中的每一个，计算因子载荷的 OLS 估计和 Huber 估计。Huber 估计使用 `scipy.optimize` 库中的 `minimize` 函数执行。在收集所有资产的估计值后，计算各自的 RMSE 并进行比较，以确定布尔指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating asset returns from an APT model\n    and comparing the performance of OLS and Huber robust regression estimators.\n    \"\"\"\n    \n    # Simulation protocol parameters\n    base_seed = 20231105\n    c = 1.345\n    sigma_eps = 0.5\n    kappa = c * sigma_eps\n\n    test_cases = [\n        (50, 3, 250, 30),  # Case j=0\n        (50, 3, 250, 3),   # Case j=1\n        (50, 3, 60, 4),    # Case j=2\n        (200, 5, 250, 3),  # Case j=3\n    ]\n\n    results = []\n\n    def huber_loss(u, k):\n        \"\"\"Vectorized Huber loss function.\"\"\"\n        abs_u = np.abs(u)\n        is_small = abs_u = k\n        \n        quadratic_loss = 0.5 * u[is_small]**2\n        linear_loss = k * (abs_u[~is_small] - 0.5 * k)\n        \n        loss = np.zeros_like(u)\n        loss[is_small] = quadratic_loss\n        loss[~is_small] = linear_loss\n        \n        return loss\n\n    def huber_objective(theta, X, y, k):\n        \"\"\"Objective function for Huber regression.\"\"\"\n        residuals = y - X @ theta\n        return np.sum(huber_loss(residuals, k))\n\n    for j, (N, K, T, nu) in enumerate(test_cases):\n        # Set the seed for reproducibility for the current test case\n        np.random.seed(base_seed + j)\n\n        # 1. Generate data from the specified DGP\n        # True factor loadings b_ik ~ N(0,1)\n        b_true = np.random.randn(N, K)\n        \n        # Factors f_kt ~ N(0,1)\n        factors = np.random.randn(K, T)\n        \n        # Idiosyncratic errors e_it with heavy tails\n        # z_it ~ Student's t with nu degrees of freedom\n        z = np.random.standard_t(df=nu, size=(N, T))\n        # Scale z to have unit variance\n        e = z * np.sqrt((nu - 2) / nu)\n        # Scale by error standard deviation\n        eps = sigma_eps * e\n        \n        # Generate asset returns R = b*f + eps (since a_i=0)\n        # R is an N x T matrix\n        R = b_true @ factors + eps\n\n        # 2. Prepare for estimation\n        # Design matrix X is T x (K+1), common for all assets\n        X = np.hstack([np.ones((T, 1)), factors.T])\n        \n        # Matrices to store estimated factor loadings (excluding intercept)\n        b_hat_ols = np.zeros((N, K))\n        b_hat_huber = np.zeros((N, K))\n\n        # 3. Estimate parameters for each asset\n        for i in range(N):\n            R_i = R[i, :]  # Returns for asset i (T x 1)\n            \n            # OLS Estimation\n            # theta_ols = (X'X)^-1 X'R_i\n            try:\n                theta_ols = np.linalg.solve(X.T @ X, X.T @ R_i)\n            except np.linalg.LinAlgError:\n                # Use pseudo-inverse if X'X is singular, though unlikely\n                theta_ols = np.linalg.pinv(X) @ R_i\n            \n            b_hat_ols[i, :] = theta_ols[1:]\n            \n            # Huber Robust Estimation\n            # Use OLS estimate as a starting point for the optimization\n            res = minimize(\n                fun=huber_objective,\n                x0=theta_ols,\n                args=(X, R_i, kappa),\n                method='BFGS',\n                options={'gtol': 1e-6}\n            )\n            theta_huber = res.x\n            b_hat_huber[i, :] = theta_huber[1:]\n\n        # 4. Calculate RMSE for factor loadings\n        rmse_ols = np.sqrt(np.mean((b_hat_ols - b_true)**2))\n        rmse_huber = np.sqrt(np.mean((b_hat_huber - b_true)**2))\n        \n        # 5. Compare RMSEs and store the boolean indicator\n        results.append(rmse_huber  rmse_ols)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "因子风险溢价（$\\lambda$）是承担特定系统性风险所获得的回报，是APT模型的核心输出之一。本练习将带您实现一个在学术界和业界都广为使用的经典计量方法——两步回归法（Fama-MacBeth procedure），来估计时变的因子风险溢价。通过实施滚动窗口估计，您不仅能计算出风险溢价的平均水平，还能观察其随时间变化的动态过程，这对于理解市场定价机制至关重要。",
            "id": "2372104",
            "problem": "您的任务是在套利定价理论（Arbitrage Pricing Theory, APT）的框架下，实现一个时变因子风险溢价的滚动估计器。考虑一个针对 $N$ 个资产在 $T$ 个时间周期内的线性 $K$ 因子模型。对于每个资产 $i \\in \\{1,\\dots,N\\}$ 和时间 $t \\in \\{1,\\dots,T\\}$，超额收益过程定义为\n$$\nr_{i,t} \\;=\\; \\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{f}_{t} \\;+\\; \\varepsilon_{i,t},\n$$\n其中 $\\boldsymbol{\\beta}_{i} \\in \\mathbb{R}^{K}$ 是资产 $i$ 的（不随时间变化的）因子载荷向量，$\\boldsymbol{f}_{t} \\in \\mathbb{R}^{K}$ 是时间 $t$ 的因子实现值向量，其期望 $\\mathbb{E}[\\boldsymbol{f}_{t}] = \\boldsymbol{\\lambda}$（因子风险溢价向量），$\\varepsilon_{i,t}$ 是异质性噪声，其期望 $\\mathbb{E}[\\varepsilon_{i,t}] = 0$，且在资产间独立并独立于 $\\boldsymbol{f}_{t}$。\n\n您必须使用如下定义的滚动窗口程序来估计与第三个因子（解释为高减低因子 High Minus Low factor，记为 $\\mathrm{HML}$）相关的风险溢价的时间序列 $\\{\\widehat{\\lambda}_{\\mathrm{HML}}(t)\\}$。固定一个窗口长度 $W$。对于每个时间 $t \\in \\{W, W+1, \\dots, T-1\\}$：\n1. 通过求解最小二乘问题，为每个资产 $i$ 估计因子载荷 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$\n$$\n\\widehat{\\boldsymbol{\\beta}}_{i}(t) \\;=\\; \\arg\\min_{\\boldsymbol{b} \\in \\mathbb{R}^{K}} \\sum_{\\tau = t-W}^{t-1} \\left(r_{i,\\tau} \\;-\\; \\boldsymbol{b}^{\\top}\\boldsymbol{f}_{\\tau}\\right)^{2}.\n$$\n2. 通过求解横截面最小二乘问题，估计时间 $t$ 的因子风险溢价\n$$\n\\widehat{\\boldsymbol{\\lambda}}(t) \\;=\\; \\arg\\min_{\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}} \\sum_{i = 1}^{N} \\left(r_{i,t} \\;-\\; \\widehat{\\boldsymbol{\\beta}}_{i}(t)^{\\top}\\boldsymbol{\\theta}\\right)^{2}.\n$$\n3. 将 $\\mathrm{HML}$ 溢价估计值记录为 $\\widehat{\\lambda}_{\\mathrm{HML}}(t)$，即 $\\widehat{\\boldsymbol{\\lambda}}(t)$ 的第三个分量。\n\n所有收益和溢价都必须作为纯小数处理（例如，$0.01$ 代表百分之一的小数形式）。不涉及物理单位。不涉及角度。不得使用百分比；必须用小数表示数量。\n\n您不会得到经验数据。相反，您必须根据上述模型和下面测试套件中指定的参数来模拟数据。对于每个测试用例，请执行以下操作：\n- 根据测试用例中指定的均值和标准差，将因子载荷 $\\boldsymbol{\\beta}_{i}$ 作为在资产和因子间独立的高斯抽样进行模拟。\n- 根据测试用例中指定的均值 $\\boldsymbol{\\lambda}$ 和对角协方差，将因子实现值 $\\boldsymbol{f}_{t}$ 作为独立的多元正态抽样进行模拟。\n- 根据测试用例中指定的均值 $0$ 和标准差 $\\sigma_{\\varepsilon}$，将异质性冲击 $\\varepsilon_{i,t}$ 作为独立的高斯抽样进行模拟。\n- 严格按照上述定义构建收益 $r_{i,t}$。\n- 应用滚动估计获得时间序列 $\\{\\widehat{\\lambda}_{\\mathrm{HML}}(t)\\}_{t=W}^{T-1}$。\n- 对每个测试用例，生成 $\\mathrm{HML}$ 溢价估计值的时间序列平均值，\n$$\n\\overline{\\lambda}_{\\mathrm{HML}} \\;=\\; \\frac{1}{T-W}\\sum_{t=W}^{T-1} \\widehat{\\lambda}_{\\mathrm{HML}}(t),\n$$\n四舍五入到六位小数。\n\n测试套件：\n使用 $K = 3$ 个因子，顺序为 $\\mathrm{MKT}$、$\\mathrm{SMB}$、$\\mathrm{HML}$，因此 $\\mathrm{HML}$ 的索引为 $3$。对于所有情况，将收益视为小数。\n\n- 情况 A（理想情况，数十年样本）：\n  - $N = 40$, $T = 480$, $W = 120$, 随机种子 $= 202311$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.005, 0.002, 0.004]$。\n  - 因子协方差对角线 $= [0.03^{2}, 0.02^{2}, 0.025^{2}]$。\n  - 异质性标准差 $\\sigma_{\\varepsilon} = 0.04$。\n  - 因子载荷均值 $[\\mu_{\\beta,\\mathrm{MKT}}, \\mu_{\\beta,\\mathrm{SMB}}, \\mu_{\\beta,\\mathrm{HML}}] = [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $[\\sigma_{\\beta,\\mathrm{MKT}}, \\sigma_{\\beta,\\mathrm{SMB}}, \\sigma_{\\beta,\\mathrm{HML}}] = [0.3, 0.2, 0.25]$。\n\n- 情况 B（较短窗口，较高波动性）：\n  - $N = 25$, $T = 240$, $W = 24$, 随机种子 $= 202312$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.006, 0.001, 0.004]$。\n  - 因子协方差对角线 $= [0.05^{2}, 0.025^{2}, 0.035^{2}]$。\n  - 异质性标准差 $\\sigma_{\\varepsilon} = 0.06$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n- 情况 C（零 $\\mathrm{HML}$ 溢价）：\n  - $N = 35$, $T = 360$, $W = 36$, 随机种子 $= 202313$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.004, 0.002, 0.0]$。\n  - 因子协方差对角线 $= [0.03^{2}, 0.02^{2}, 0.025^{2}]$。\n  - 异质性标准差 $\\sigma_{\\varepsilon} = 0.04$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n- 情况 D（横截面中接近识别边界）：\n  - $N = 4$, $T = 120$, $W = 36$, 随机种子 $= 202314$。\n  - 真实因子溢价 $\\boldsymbol{\\lambda} = [0.005, 0.003, 0.003]$。\n  - 因子协方差对角线 $= [0.02^{2}, 0.015^{2}, 0.02^{2}]$。\n  - 异质性标准差 $\\sigma_{\\varepsilon} = 0.03$。\n  - 因子载荷均值 $= [1.0, 0.5, 0.8]$。\n  - 因子载荷标准差 $= [0.3, 0.2, 0.25]$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应测试用例的 $\\overline{\\lambda}_{\\mathrm{HML}}$ 值，顺序为 A、B、C、D。每个值必须四舍五入到六位小数。例如：\"[0.003950,0.004210,-0.000015,0.003120]\"。",
            "solution": "问题陈述已经过验证，被认为是可接受的。这是一个计算金融领域中定义明确的问题，其基础是成熟的计量经济学方法。它要求实施一种滚动两步回归法，通常称为 Fama-MacBeth 过程，在一个模拟的套利定价理论（APT）框架中估计因子风险溢价。模拟参数和估计步骤的规定具有足够的清晰度和严谨性，可以得出一个唯一且可验证的解。\n\n此问题的核心是根据资产收益的线性因子模型估计时变因子风险溢价 $\\{\\widehat{\\boldsymbol{\\lambda}}(t)\\}$。资产 $i$ 在时间 $t$ 的模型由下式给出：\n$$\nr_{i,t} \\;=\\; \\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{f}_{t} \\;+\\; \\varepsilon_{i,t}\n$$\n其中 $\\boldsymbol{\\beta}_{i} \\in \\mathbb{R}^{K}$ 是不随时间变化的因子载荷，$\\boldsymbol{f}_{t} \\in \\mathbb{R}^{K}$ 是因子实现值，$\\varepsilon_{i,t}$ 是异质性噪声。该过程涉及在滚动窗口上执行的两个连续阶段的普通最小二乘法（OLS）估计。\n\n首先，我们必须根据指定的随机过程生成数据。对于一个给定的具有 $N$ 个资产、$T$ 个时间周期和 $K=3$ 个因子的测试用例，我们按以下步骤操作：\n\n1.  **因子载荷模拟**：生成因子载荷矩阵 $\\boldsymbol{\\beta} \\in \\mathbb{R}^{N \\times K}$。该矩阵的每一列 $k \\in \\{1, 2, 3\\}$ 对应一个单一因子，是从独立的​​正态分布中抽取的，即对于每个资产 $i=1, \\dots, N$，有 $\\boldsymbol{\\beta}_{i,k} \\sim \\mathcal{N}(\\mu_{\\beta,k}, \\sigma_{\\beta,k}^2)$。\n\n2.  **因子实现值模拟**：生成因子实现值矩阵 $\\mathbf{F} \\in \\mathbb{R}^{T \\times K}$。每一行 $\\boldsymbol{f}_{t}^{\\top}$ 都是从一个多元正态分布中独立抽取的，即 $\\boldsymbol{f}_{t} \\sim \\mathcal{N}(\\boldsymbol{\\lambda}, \\boldsymbol{\\Sigma}_{f})$，其中 $\\boldsymbol{\\lambda}$ 是真实因子溢价的向量，$\\boldsymbol{\\Sigma}_{f}$ 是指定的对角协方差矩阵。\n\n3.  **异质性冲击模拟**：生成异质性冲击矩阵 $\\mathbf{E} \\in \\mathbb{R}^{T \\times N}$。每个元素 $\\varepsilon_{i,t}$ 都是从均值为 $0$、标准差为 $\\sigma_{\\varepsilon}$ 的正态分布中独立抽取的，即 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$。\n\n4.  **资产收益构建**：根据模型组合模拟出的各分量，构建资产收益矩阵 $\\mathbf{R} \\in \\mathbb{R}^{T \\times N}$：\n    $$\n    \\mathbf{R} = \\mathbf{F}\\boldsymbol{\\beta}^{\\top} + \\mathbf{E}\n    $$\n    这里，$\\mathbf{R}$ 的第 $(t,i)$ 个元素是 $r_{i,t}$。\n\n有了模拟数据后，我们实施滚动的两步估计法。对于从 $W$ 到 $T-1$ 的每个时间步 $t$：\n\n**阶段 1：时间序列回归**\n对于每个资产 $i \\in \\{1,\\dots,N\\}$，我们使用长度为 $W$ 的前一个窗口的数据（即从时间 $\\tau = t-W$ 到 $t-1$）来估计其因子载荷 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$。这是将资产收益对因子实现值进行的 OLS 回归。对于所有资产同时进行，以矩阵形式表示，令 $\\mathbf{R}_{\\text{win},t} \\in \\mathbb{R}^{W \\times N}$ 为窗口内所有资产的收益矩阵，$\\mathbf{F}_{\\text{win},t} \\in \\mathbb{R}^{W \\times K}$ 为因子实现值矩阵。我们求解估计载荷矩阵 $\\widehat{\\mathbf{B}}(t) \\in \\mathbb{R}^{K \\times N}$：\n$$\n\\mathbf{R}_{\\text{win},t} = \\mathbf{F}_{\\text{win},t} \\widehat{\\mathbf{B}}(t) + \\text{误差矩阵}\n$$\nOLS 解为 $\\widehat{\\mathbf{B}}(t) = (\\mathbf{F}_{\\text{win},t}^{\\top} \\mathbf{F}_{\\text{win},t})^{-1} \\mathbf{F}_{\\text{win},t}^{\\top} \\mathbf{R}_{\\text{win},t}$。为保证数值稳定性，此问题使用诸如 QR 分解等方法求解，如 `numpy.linalg.lstsq` 中所实现的。结果是一个矩阵，其第 $i$ 列为 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)$。\n\n**阶段 2：横截面回归**\n在时间 $t$，我们使用阶段 1 中估计的载荷 $\\widehat{\\mathbf{B}}(t)$ 来估计因子风险溢价 $\\widehat{\\boldsymbol{\\lambda}}(t) \\in \\mathbb{R}^{K}$。这是在时间 $t$ 对所有资产的收益与其对应的估计载荷进行的单次横截面 OLS 回归。令 $\\mathbf{r}_{t} \\in \\mathbb{R}^{N}$ 为时间 $t$ 的资产收益向量，令 $\\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t} \\in \\mathbb{R}^{N \\times K}$ 为阶段 1 所得矩阵的转置，即 $\\widehat{\\mathbf{B}}(t)^{\\top}$，使其第 $i$ 行为 $\\widehat{\\boldsymbol{\\beta}}_{i}(t)^{\\top}$。我们求解 $\\widehat{\\boldsymbol{\\lambda}}(t)$：\n$$\n\\mathbf{r}_{t} = \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t} \\widehat{\\boldsymbol{\\lambda}}(t) + \\text{误差向量}\n$$\nOLS 解为 $\\widehat{\\boldsymbol{\\lambda}}(t) = (\\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t}^{\\top} \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t})^{-1} \\widehat{\\boldsymbol{\\beta}}_{\\text{CS},t}^{\\top} \\mathbf{r}_{t}$。同样，采用了数值稳定的求解器。\n\n从得到的向量 $\\widehat{\\boldsymbol{\\lambda}}(t)$ 中，我们提取第三个分量，它对应于 $\\mathrm{HML}$ 因子溢价，即 $\\widehat{\\lambda}_{\\mathrm{HML}}(t)$。对 $[W, T-1]$ 范围内的所有 $t$ 重复此过程。\n\n最后，$\\mathrm{HML}$ 平均溢价的总体估计值计算为所收集到的估计值的时间序列均值：\n$$\n\\overline{\\lambda}_{\\mathrm{HML}} \\;=\\; \\frac{1}{T-W}\\sum_{t=W}^{T-1} \\widehat{\\lambda}_{\\mathrm{HML}}(t)\n$$\n实现过程将封装这一逻辑，通过使用带种子的生成器确保随机数生成的可复现性，并使用高效的线性代数程序进行 OLS 估计。每个测试用例的最终结果将按要求四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef estimate_hml_premium_average(\n    N: int, T: int, W: int, seed: int,\n    lambda_true: np.ndarray, factor_cov_diag: np.ndarray,\n    sigma_eps: float, beta_means: np.ndarray, beta_stds: np.ndarray\n) - float:\n    \"\"\"\n    Simulates data and computes the time-series average of the estimated HML factor premium.\n\n    This function implements a rolling two-pass regression (Fama-MacBeth) procedure.\n    \"\"\"\n    # Use a seeded random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n    \n    # The number of factors K is implicitly 3 from the input array dimensions.\n    K = len(lambda_true)\n\n    # 1. Simulate data according to the APT model.\n    # 1a. Factor loadings (betas): N x K matrix. Time-invariant.\n    beta_true = rng.normal(loc=beta_means, scale=beta_stds, size=(N, K))\n\n    # 1b. Factor realizations: T x K matrix.\n    factor_cov = np.diag(factor_cov_diag)\n    factors = rng.multivariate_normal(mean=lambda_true, cov=factor_cov, size=T)\n\n    # 1c. Idiosyncratic shocks: T x N matrix.\n    epsilon = rng.normal(loc=0.0, scale=sigma_eps, size=(T, N))\n    \n    # 1d. Asset excess returns: T x N matrix.\n    # The equation is r_it = beta_i' * f_t + eps_it.\n    # In matrix form: R = F @ B.T + E\n    returns = factors @ beta_true.T + epsilon\n\n    hml_premium_estimates = []\n\n    # 2. Perform rolling estimation for t from W to T-1.\n    for t in range(W, T):\n        # Define the time window for the first-pass regression.\n        window_start = t - W\n        window_end = t\n\n        # --- Stage 1: Time-series regressions to estimate betas ---\n        # For each asset, regress its return history on factor history.\n        # X: factor realizations in the window (W x K)\n        # Y: asset returns in the window (W x N)\n        X_ts = factors[window_start:window_end, :]\n        Y_ts = returns[window_start:window_end, :]\n        \n        # np.linalg.lstsq solves aX = b. Here a=X_ts, b=Y_ts.\n        # The solution X is a (K x N) matrix of estimated betas.\n        # Each column is the beta vector for one asset.\n        beta_hat_matrix = np.linalg.lstsq(X_ts, Y_ts, rcond=None)[0]\n        \n        # We need an (N x K) matrix for the second stage, where each row is a beta vector.\n        beta_hats_for_cs = beta_hat_matrix.T\n\n        # --- Stage 2: Cross-sectional regression to estimate risk premia ---\n        # At time t, regress asset returns on their estimated betas.\n        # X: estimated betas across assets (N x K)\n        # y: asset returns at time t (N x 1)\n        X_cs = beta_hats_for_cs\n        y_cs = returns[t, :]\n        \n        # Solves X_cs @ lambda_hat = y_cs for lambda_hat.\n        # The solution is the (K x 1) vector of estimated factor premia at time t.\n        lambda_hat_t = np.linalg.lstsq(X_cs, y_cs, rcond=None)[0]\n\n        # The HML factor is the third factor (index 2).\n        hml_premium_t = lambda_hat_t[2]\n        hml_premium_estimates.append(hml_premium_t)\n\n    # 3. Calculate the time-series average of the HML premium estimates.\n    average_hml_premium = np.mean(hml_premium_estimates)\n    \n    return average_hml_premium\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the estimation for each, printing the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 40, \"T\": 480, \"W\": 120, \"seed\": 202311,\n            \"lambda_true\": np.array([0.005, 0.002, 0.004]),\n            \"factor_cov_diag\": np.array([0.03**2, 0.02**2, 0.025**2]),\n            \"sigma_eps\": 0.04,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 25, \"T\": 240, \"W\": 24, \"seed\": 202312,\n            \"lambda_true\": np.array([0.006, 0.001, 0.004]),\n            \"factor_cov_diag\": np.array([0.05**2, 0.025**2, 0.035**2]),\n            \"sigma_eps\": 0.06,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 35, \"T\": 360, \"W\": 36, \"seed\": 202313,\n            \"lambda_true\": np.array([0.004, 0.002, 0.0]),\n            \"factor_cov_diag\": np.array([0.03**2, 0.02**2, 0.025**2]),\n            \"sigma_eps\": 0.04,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        },\n        {\n            \"N\": 4, \"T\": 120, \"W\": 36, \"seed\": 202314,\n            \"lambda_true\": np.array([0.005, 0.003, 0.003]),\n            \"factor_cov_diag\": np.array([0.02**2, 0.015**2, 0.02**2]),\n            \"sigma_eps\": 0.03,\n            \"beta_means\": np.array([1.0, 0.5, 0.8]),\n            \"beta_stds\": np.array([0.3, 0.2, 0.25]),\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        avg_premium = estimate_hml_premium_average(**case_params)\n        # Round the final average to 6 decimal places and format.\n        results.append(f\"{avg_premium:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}