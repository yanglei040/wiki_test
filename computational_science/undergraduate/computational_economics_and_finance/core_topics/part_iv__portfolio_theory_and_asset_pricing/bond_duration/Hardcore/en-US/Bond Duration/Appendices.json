{
    "hands_on_practices": [
        {
            "introduction": "This first practice will ground your understanding of bond duration by having you build a calculator from first principles. You will translate the fundamental mathematical definitions of bond price, Macaulay duration, and modified duration directly into a working algorithm, without relying on pre-built financial libraries. This exercise, , is essential for mastering the mechanics of how a bond's cash flows and yield interact to determine its price and sensitivity to interest rate changes.",
            "id": "2377212",
            "problem": "You are tasked with implementing a program that computes the price, Macaulay duration, and modified duration of a fixed-rate, discrete-compounding coupon bond from first principles. Work in pure present value terms, using the following definitions.\n\nA fixed-rate bond has face value $F$, annual coupon rate $c$ (expressed as a decimal, not a percentage), yield to maturity $y$ (expressed as a decimal, not a percentage), payments per year $m$ (an integer), and years to maturity $n$ (an integer). Coupon payments occur at equal intervals, $m$ times per year, with the first payment at time $t=\\frac{1}{m}$ years and the last payment at time $t=n$ years. Settlement is at time $t=0$, immediately before a coupon date. Use nominal annual yield compounded $m$ times per year.\n\nDefine the number of payment periods as $N = m \\cdot n$. Define the per-period coupon as $C = \\frac{F \\cdot c}{m}$. The cash flow at period index $k \\in \\{1,2,\\dots,N\\}$ is $C$ for $k \\lt N$ and $C + F$ for $k = N$. The per-period discount factor is $d = \\frac{1}{1 + \\frac{y}{m}}$. The present value of the cash flow at period $k$ is $PV_k = \\text{CF}_k \\cdot d^{k}$, and the bond price is\n$$\nP = \\sum_{k=1}^{N} PV_k.\n$$\nLet $t_k = \\frac{k}{m}$ denote the time in years of the $k$th cash flow. The Macaulay duration in years is defined as\n$$\nD_{\\mathrm{Mac}} = \\sum_{k=1}^{N} t_k \\cdot \\frac{PV_k}{P}.\n$$\nThe modified duration in years is defined as\n$$\nD_{\\mathrm{Mod}} = \\frac{D_{\\mathrm{Mac}}}{1 + \\frac{y}{m}}.\n$$\n\nAll outputs must be expressed in years for durations and in the same currency units as $F$ for the price. Coupon rates and yields must be provided and treated as decimals (for example, $0.05$ for five percent). Your program must compute, for each test case, the triplet $[P, D_{\\mathrm{Mac}}, D_{\\mathrm{Mod}}]$ where each value is rounded to exactly $6$ decimal places.\n\nImplement your program to evaluate the following test suite, which covers a range of cases:\n- Case $1$ (standard case): $F = 1000$, $c = 0.06$, $y = 0.05$, $m = 2$, $n = 5$.\n- Case $2$ (zero-coupon bond): $F = 1000$, $c = 0.0$, $y = 0.05$, $m = 1$, $n = 3$.\n- Case $3$ (single-period maturity): $F = 100$, $c = 0.08$, $y = 0.10$, $m = 1$, $n = 1$.\n- Case $4$ (very low yield, high coupon, frequent compounding): $F = 1000$, $c = 0.12$, $y = 0.0001$, $m = 12$, $n = 10$.\n- Case $5$ (longer maturity, quarterly payments): $F = 100$, $c = 0.05$, $y = 0.07$, $m = 4$, $n = 7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following format:\n$$\n\\big[ [P_1,D_{\\mathrm{Mac},1},D_{\\mathrm{Mod},1}], [P_2,D_{\\mathrm{Mac},2},D_{\\mathrm{Mod},2}], \\dots, [P_5,D_{\\mathrm{Mac},5},D_{\\mathrm{Mod},5}] \\big]\n$$\nwith no spaces anywhere in the line and each numeric value rounded to exactly $6$ decimal places.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, objective, and complete. It provides a set of precise, standard financial definitions for calculating a bond's price and durations. The task is a direct application of these definitions to a given set of parameters. The solution is thus derived by a direct algorithmic implementation of the provided formulas.\n\nThe methodology is to compute, for each test case specified by the parameters $(F, c, y, m, n)$, the required triplet $[P, D_{\\mathrm{Mac}}, D_{\\mathrm{Mod}}]$. The parameters represent the face value ($F$), annual coupon rate ($c$), annual yield to maturity ($y$), number of coupon payments per year ($m$), and maturity in years ($n$).\n\nThe computational procedure is executed as follows:\n\nFirst, we establish the fundamental parameters for the periodic calculations. The total number of payment periods is $N = m \\cdot n$. The coupon payment per period is $C = \\frac{F \\cdot c}{m}$. The per-period yield, consistent with a nominal annual yield $y$ compounded $m$ times per year, is $y_{\\mathrm{p}} = \\frac{y}{m}$.\n\nSecond, we construct the stream of cash flows. For each period index $k$ from $1$ to $N$, a cash flow $\\text{CF}_k$ occurs at time $t_k = \\frac{k}{m}$ years. The cash flow is the periodic coupon $C$ for all periods except the last. For the final period, $k=N$, the cash flow also includes the repayment of the face value $F$. Thus:\n$$\n\\text{CF}_k =\n\\begin{cases}\nC & \\text{for } k \\in \\{1, 2, \\dots, N-1\\} \\\\\nC + F & \\text{for } k = N\n\\end{cases}\n$$\n\nThird, we calculate the present value of each cash flow by discounting it to time $t=0$. The present value of the cash flow at period $k$, denoted $PV_k$, is given by:\n$$\nPV_k = \\frac{\\text{CF}_k}{(1 + y_{\\mathrm{p}})^k}\n$$\nThe bond's price, $P$, is the sum of the present values of all its future cash flows:\n$$\nP = \\sum_{k=1}^{N} PV_k\n$$\n\nFourth, we compute the Macaulay duration, $D_{\\mathrm{Mac}}$. This is a weighted average of the times of the cash flows, where the weights are the ratio of each cash flow's present value to the total price of the bond. It is measured in years.\n$$\nD_{\\mathrm{Mac}} = \\sum_{k=1}^{N} t_k \\cdot \\frac{PV_k}{P} = \\frac{1}{P} \\sum_{k=1}^{N} \\frac{k}{m} \\cdot PV_k\n$$\n\nFifth, we calculate the modified duration, $D_{\\mathrm{Mod}}$. This is a measure of the bond's price sensitivity to changes in yield. It is derived from the Macaulay duration by adjusting for the compounding frequency of the yield:\n$$\nD_{\\mathrm{Mod}} = \\frac{D_{\\mathrm{Mac}}}{1 + y_{\\mathrm{p}}} = \\frac{D_{\\mathrm{Mac}}}{1 + \\frac{y}{m}}\n$$\n\nThis entire procedure is implemented algorithmically. For efficiency, the sequences of periods $k$, times $t_k$, cash flows $\\text{CF}_k$, and present values $PV_k$ are generated as numerical arrays. The summations required for $P$ and $D_{\\mathrm{Mac}}$ are performed as vector operations. The final computed values for $P$, $D_{\\mathrm{Mac}}$, and $D_{\\mathrm{Mod}}$ are rounded to $6$ decimal places as required. This process is repeated for each of the $5$ test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes bond price, Macaulay duration, and modified duration for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (F, c, y, m, n)\n    test_cases = [\n        # Case 1 (standard case)\n        (1000, 0.06, 0.05, 2, 5),\n        # Case 2 (zero-coupon bond)\n        (1000, 0.0, 0.05, 1, 3),\n        # Case 3 (single-period maturity)\n        (100, 0.08, 0.10, 1, 1),\n        # Case 4 (very low yield, high coupon, frequent compounding)\n        (1000, 0.12, 0.0001, 12, 10),\n        # Case 5 (longer maturity, quarterly payments)\n        (100, 0.05, 0.07, 4, 7),\n    ]\n\n    results = []\n    for case in test_cases:\n        F, c, y, m, n = case\n        result_triplet = compute_bond_metrics(F, c, y, m, n)\n        results.append(result_triplet)\n\n    # Format the final output string as specified.\n    # e.g., [[P1,DMac1,DMod1],[P2,DMac2,DMod2],...]\n    # with 6 decimal places and no spaces.\n    formatted_results = []\n    for triplet in results:\n        # Format each number in the triplet to exactly 6 decimal places.\n        formatted_triplet = [f\"{val:.6f}\" for val in triplet]\n        # Create the string representation of the inner list.\n        formatted_results.append(f\"[{','.join(formatted_triplet)}]\")\n    \n    # Join the inner list strings into the final output string.\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n\n    print(final_output_str)\n\ndef compute_bond_metrics(F, c, y, m, n):\n    \"\"\"\n    Calculates the price, Macaulay duration, and modified duration of a bond.\n\n    Args:\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        y (float): Annual yield to maturity (decimal).\n        m (int): Number of coupon payments per year.\n        n (int): Years to maturity.\n\n    Returns:\n        list: A list containing [price, macaulay_duration, modified_duration].\n    \"\"\"\n    # 1. Calculate derived quantities\n    if n == 0 or m == 0:  # Handle case with no periods\n        return [F if n==0 else 0, 0, 0] # Or other appropriate handling for maturity at t=0\n        \n    N = m * n  # Total number of periods\n    C = (F * c) / m  # Coupon payment per period\n    y_period = y / m  # Yield per period\n\n    # 2. Generate calculation arrays using numpy for vectorized operations\n    # Array of period indices k = 1, 2, ..., N\n    k_periods = np.arange(1, N + 1)\n    \n    # Array of times for each cash flow in years, t_k = k/m\n    t_k_years = k_periods / m\n\n    # 3. Construct the cash flow stream\n    # All periods receive coupon C\n    cash_flows = np.full(N, C)\n    # The last period also receives the face value F\n    cash_flows[-1] += F\n\n    # 4. Calculate the present value (PV) of each cash flow\n    # Discount factors for each period: 1 / (1 + y_period)^k\n    discount_factors = (1 + y_period) ** -k_periods\n    # Present value of each cash flow: PV_k = CF_k * discount_factor_k\n    pv_cash_flows = cash_flows * discount_factors\n\n    # 5. Calculate the bond price (P)\n    # P = sum of all PV_k\n    price = np.sum(pv_cash_flows)\n\n    # Prevent division by zero if price is zero (e.g., y is infinite).\n    if price == 0:\n        return [0.0, 0.0, 0.0]\n\n    # 6. Calculate Macaulay Duration (D_Mac)\n    # D_Mac = (1/P) * sum(t_k * PV_k)\n    weighted_pvs = t_k_years * pv_cash_flows\n    macaulay_duration = np.sum(weighted_pvs) / price\n\n    # 7. Calculate Modified Duration (D_Mod)\n    # D_Mod = D_Mac / (1 + y_period)\n    modified_duration = macaulay_duration / (1 + y_period)\n\n    # 8. Return the raw (unrounded) triplet of results\n    return [price, macaulay_duration, modified_duration]\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond the simplifying assumption of a single, flat yield curve, this exercise tackles a more realistic valuation scenario. You will implement the essential technique of bootstrapping to derive a zero-coupon yield curve from the market prices of several coupon-bearing bonds. By using this curve to calculate a target bond's duration, you will gain a deeper appreciation for how duration is determined by the entire term structure of interest rates, a cornerstone of modern fixed-income analysis .",
            "id": "2377196",
            "problem": "You must write a complete program that bootstraps a zero-coupon yield curve from given coupon bond prices and then computes the Macaulay duration of a different bond using that curve. The program must rely only on no-arbitrage pricing with annual compounding and standard definitions. All results must be expressed in years, as decimal numbers rounded to six decimal places.\n\nStart from the following fundamental base:\n- No-arbitrage pricing states that the price $P$ of a bond equals the sum of the present values of its cash flows discounted at the appropriate zero-coupon rates. If a cash flow $CF(t)$ is paid at time $t$ (in years), and the annual-compounded zero-coupon yield for maturity $t$ is $r(t)$, then the present value of that cash flow is $CF(t) \\cdot \\left(1 + r(t)\\right)^{-t}$. Define the discount factor as $D(t) \\equiv \\left(1 + r(t)\\right)^{-t}$.\n- A fixed-rate coupon bond with face value $F$, annual coupon rate $c$, and payment frequency $m$ (payments per year) has a per-period coupon $q \\equiv \\dfrac{cF}{m}$, with payments at times $t_k \\equiv \\dfrac{k}{m}$ for $k \\in \\{1,2,\\dots,n\\}$ where $n \\equiv mT$ and $T$ is the maturity in years. The cash flows are $q$ at $t_1,\\dots,t_{n-1}$ and $F+q$ at $t_n$.\n- The Macaulay duration $D_{\\text{Mac}}$ of a bond, discounted with a term structure, is defined as $D_{\\text{Mac}} \\equiv \\dfrac{\\sum_{i} t_i \\cdot PV_i}{\\sum_{i} PV_i}$, where $PV_i$ is the present value of the $i$-th cash flow computed with the discount factor $D(t_i)$, and $t_i$ is measured in years.\n\nYour program must:\n- Bootstrap the discount factors $\\{D(t)\\}$ from the provided set of coupon bond prices by solving, in increasing order of maturity, the linear no-arbitrage equations for $D(t)$ at each new maturity. Then compute the annual-compounded zero-coupon yields $r(t)$ via $r(t) \\equiv D(t)^{-1/t} - 1$. You must use only annual compounding.\n- Use the resulting discount factors to price the specified target bond in each test case and compute its Macaulay duration: $D_{\\text{Mac}} \\equiv \\dfrac{\\sum_{i} t_i \\cdot CF(t_i) \\cdot D(t_i)}{\\sum_{i} CF(t_i) \\cdot D(t_i)}$.\n- Express each final duration in years as a decimal number rounded to six decimal places.\n\nImportant implementation notes:\n- Assume face value $F = 100$ for all bonds.\n- For each bootstrapping set, maturities and coupon schedules are aligned so that solving for discount factors proceeds triangularly: at each step there is exactly one new maturity $T$ whose discount factor $D(T)$ is unknown. For a bond maturing at $T$ with per-period coupon $q$, price $P$, and earlier payment times $\\{t_1,\\dots,t_{n-1}\\}$ with known discount factors, the unknown $D(T)$ is determined by a single linear equation:\n$$\nP \\;=\\; \\sum_{k=1}^{n-1} q \\cdot D(t_k) \\;+\\; (F+q)\\cdot D(T).\n$$\n- After bootstrapping $\\{D(t)\\}$ for a test case, compute the Macaulay duration of the specified target bond using those discount factors.\n\nTest suite (three independent cases):\n- Case $1$ (semiannual coupons, upward-sloping curve implied by prices):\n  - Bootstrapping bonds (all with $c = 0.03$, $m=2$, $F=100$), given as tuples $(T, P)$ in years and price:\n    - $(0.5, 100.254595)$\n    - $(1.0, 100.313044)$\n    - $(1.5, 100.037059)$\n    - $(2.0, 99.680484)$\n  - Target bond to compute duration: $(c=0.04, m=2, T=1.5, F=100)$.\n\n- Case $2$ (annual coupons, includes a zero-coupon target to test the boundary where duration equals maturity):\n  - Bootstrapping bonds (all with $c = 0.03$, $m=1$, $F=100$), tuples $(T, P)$:\n    - $(1.0, 100.980392)$\n    - $(2.0, 100.917763)$\n    - $(3.0, 100.054489)$\n  - Target bond: zero-coupon $(c=0.0, m=1, T=3.0, F=100)$.\n\n- Case $3$ (quarterly coupons, low coupon target):\n  - Bootstrapping bonds (all with $c = 0.015$, $m=4$, $F=100$), tuples $(T, P)$:\n    - $(0.25, 100.002107)$\n    - $(0.50, 99.905457)$\n    - $(0.75, 99.749335)$\n    - $(1.00, 99.522182)$\n  - Target bond: $(c=0.01, m=4, T=1.00, F=100)$.\n\nOutput specification:\n- Your program should produce a single line of output containing the three Macaulay durations for Cases $1$, $2$, and $3$, respectively, as a comma-separated list enclosed in square brackets, with each value rounded to six decimals, for example, $\\left[\\text{d}_1,\\text{d}_2,\\text{d}_3\\right]$.\n\nDo not read any input and do not print anything else.",
            "solution": "We ground the solution in no-arbitrage pricing with annual compounding. Let $D(t) \\equiv \\left(1 + r(t)\\right)^{-t}$ denote the discount factor at maturity $t$. For a bond with face value $F$, coupon rate $c$, frequency $m$ (payments per year), maturity $T$ (in years), and per-period coupon $q \\equiv \\dfrac{cF}{m}$, the cash flows occur at $t_k \\equiv \\dfrac{k}{m}$ for $k \\in \\{1,\\dots,n\\}$ with $n \\equiv mT$. The cash flows are $q$ at $t_1,\\dots,t_{n-1}$ and $F+q$ at $t_n$. No-arbitrage pricing under the term structure implies\n$$\nP \\;=\\; \\sum_{k=1}^{n-1} q \\cdot D(t_k) \\;+\\; (F + q) \\cdot D(t_n).\n$$\nThe bootstrapping method solves for the unknown discount factors in increasing order of maturity. Suppose we have already obtained $D(t_k)$ for all $t_k < T$. Then for the bond maturing at $T$ we solve the single linear equation\n$$\nP \\;=\\; \\left(\\sum_{k=1}^{n-1} q \\cdot D(t_k)\\right) \\;+\\; (F+q)\\cdot D(T)\n\\quad\\Rightarrow\\quad\nD(T) \\;=\\; \\dfrac{P - \\sum_{k=1}^{n-1} q \\cdot D(t_k)}{F+q}.\n$$\nOnce $D(T)$ is known, the annual-compounded zero-coupon yield is\n$$\nr(T) \\;=\\; D(T)^{-1/T} - 1.\n$$\n\nTo compute the Macaulay duration using a term structure, we use its defining expression:\n$$\nD_{\\text{Mac}} \\;=\\; \\dfrac{\\sum_{i} t_i \\cdot CF(t_i) \\cdot D(t_i)}{\\sum_{i} CF(t_i) \\cdot D(t_i)}.\n$$\nThe numerator is the time-weighted sum of present values of all cash flows, and the denominator is the price. This definition follows directly from the interpretation of duration as the present-value-weighted average timing of cash flows. For a zero-coupon bond paying only at $T$, this reduces to $D_{\\text{Mac}} = T$, since the sole present value is at $t=T$.\n\nAlgorithmic steps for each test case:\n- Step $1$: Sort the bootstrapping bonds by maturity $T$.\n- Step $2$: For each bond in order, compute per-period coupon $q = \\dfrac{cF}{m}$, enumerate times $t_k = \\dfrac{k}{m}$ for $k=1,\\dots,n$ with $n=mT$, use known $D(t_k)$ for $k<n$ to solve the linear equation for $D(T)$ via\n$$\nD(T) \\;=\\; \\dfrac{P - \\sum_{k=1}^{n-1} q \\cdot D(t_k)}{F+q}.\n$$\nStore $D(T)$ in a dictionary keyed by $T$. Optionally, compute $r(T) = D(T)^{-1/T} - 1$ to have the zero-coupon yield curve.\n- Step $3$: For the target bond, construct cash flows using the same $(F,c,m,T)$ convention, compute the price $P = \\sum_i CF(t_i)\\,D(t_i)$ and the numerator $\\sum_i t_i\\,CF(t_i)\\,D(t_i)$, then return $D_{\\text{Mac}}$ as their ratio.\n- Step $4$: Round the resulting duration to six decimals.\n\nEdge-case verification:\n- In Case $2$, the target is a zero-coupon bond with $T=3.0$. The formula yields $D_{\\text{Mac}} = 3.0$ exactly (up to rounding), providing a boundary check.\n- In Case $3$, quarterly payments with a small coupon produce a duration close to, but slightly below, $1.0$, consistent with theory that lower coupons increase duration toward maturity.\n\nThe final program hard-codes the test cases, performs bootstrapping and duration calculation per the steps above, and prints a single line with the three durations in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_times(m, T):\n    n_float = T * m\n    n = int(round(n_float))\n    # Guard against small floating discrepancies\n    times = [ (k / m) for k in range(1, n + 1) ]\n    return times\n\ndef bootstrap_discount_factors(bootstrap_bonds):\n    \"\"\"\n    Given a list of bonds for bootstrapping, each as a dict with keys:\n      'P' (price), 'c' (annual coupon rate), 'm' (payments per year),\n      'T' (maturity in years), 'F' (face value),\n    return a dict mapping time t -> discount factor D(t), and a dict mapping t -> zero rate r(t)\n    using annual compounding: r(t) = D(t)^(-1/t) - 1.\n    \"\"\"\n    # Sort bonds by maturity\n    bonds_sorted = sorted(bootstrap_bonds, key=lambda b: b['T'])\n    df = {}  # discount factors by time\n    \n    for b in bonds_sorted:\n        P = float(b['P'])\n        c = float(b['c'])\n        m = int(b['m'])\n        T = float(b['T'])\n        F = float(b['F'])\n        \n        q = F * c / m  # per-period coupon\n        times = generate_times(m, T)\n        # Sum PV of earlier coupons using already known discount factors\n        pv_earlier = 0.0\n        for t in times[:-1]:\n            if t not in df:\n                raise ValueError(f\"Missing discount factor for time {t} needed to bootstrap time {T}.\")\n            pv_earlier += q * df[t]\n        denom = F + q\n        # Solve for D(T)\n        DT = (P - pv_earlier) / denom\n        df[times[-1]] = DT\n    \n    # Compute zero rates (annual compounding) for completeness\n    zr = {}\n    for t, DT in df.items():\n        if t <= 0:\n            raise ValueError(\"Time must be positive for zero rate computation.\")\n        if DT <= 0:\n            raise ValueError(\"Discount factor must be positive.\")\n        zr[t] = DT ** (-1.0 / t) - 1.0\n    return df, zr\n\ndef macaulay_duration(target_bond, df_map):\n    \"\"\"\n    Compute Macaulay duration given target bond specification and discount factors.\n    target_bond dict keys: 'c','m','T','F'\n    \"\"\"\n    c = float(target_bond['c'])\n    m = int(target_bond['m'])\n    T = float(target_bond['T'])\n    F = float(target_bond['F'])\n    q = F * c / m\n    \n    times = generate_times(m, T)\n    # Build cash flows\n    cashflows = [q] * (len(times) - 1) + [F + q]\n    \n    # Compute price and time-weighted PV sum using df_map\n    price = 0.0\n    tw_pv = 0.0\n    for t, cf in zip(times, cashflows):\n        if t not in df_map:\n            raise ValueError(f\"Missing discount factor for time {t} required to price target bond.\")\n        disc = df_map[t]\n        pv = cf * disc\n        price += pv\n        tw_pv += t * pv\n    if price <= 0:\n        raise ValueError(\"Computed price must be positive to define duration.\")\n    return tw_pv / price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: Semiannual coupons\n    case1_bootstrap_bonds = [\n        {'P': 100.254595, 'c': 0.03, 'm': 2, 'T': 0.5, 'F': 100.0},\n        {'P': 100.313044, 'c': 0.03, 'm': 2, 'T': 1.0, 'F': 100.0},\n        {'P': 100.037059, 'c': 0.03, 'm': 2, 'T': 1.5, 'F': 100.0},\n        {'P': 99.680484,  'c': 0.03, 'm': 2, 'T': 2.0, 'F': 100.0},\n    ]\n    case1_target = {'c': 0.04, 'm': 2, 'T': 1.5, 'F': 100.0}\n    \n    # Case 2: Annual coupons, zero-coupon target\n    case2_bootstrap_bonds = [\n        {'P': 100.980392, 'c': 0.03, 'm': 1, 'T': 1.0, 'F': 100.0},\n        {'P': 100.917763, 'c': 0.03, 'm': 1, 'T': 2.0, 'F': 100.0},\n        {'P': 100.054489, 'c': 0.03, 'm': 1, 'T': 3.0, 'F': 100.0},\n    ]\n    case2_target = {'c': 0.0, 'm': 1, 'T': 3.0, 'F': 100.0}\n    \n    # Case 3: Quarterly coupons\n    case3_bootstrap_bonds = [\n        {'P': 100.002107, 'c': 0.015, 'm': 4, 'T': 0.25, 'F': 100.0},\n        {'P': 99.905457,  'c': 0.015, 'm': 4, 'T': 0.50, 'F': 100.0},\n        {'P': 99.749335,  'c': 0.015, 'm': 4, 'T': 0.75, 'F': 100.0},\n        {'P': 99.522182,  'c': 0.015, 'm': 4, 'T': 1.00, 'F': 100.0},\n    ]\n    case3_target = {'c': 0.01, 'm': 4, 'T': 1.00, 'F': 100.0}\n    \n    test_cases = [\n        (case1_bootstrap_bonds, case1_target),\n        (case2_bootstrap_bonds, case2_target),\n        (case3_bootstrap_bonds, case3_target),\n    ]\n\n    results = []\n    for boot_bonds, target in test_cases:\n        df_map, _zr_map = bootstrap_discount_factors(boot_bonds)\n        dur = macaulay_duration(target, df_map)\n        # Round to six decimals\n        results.append(f\"{dur:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice demonstrates the power of duration as a tool for practical portfolio management. You will design and implement an optimization algorithm to construct a bond portfolio that achieves a desired level of interest rate risk, represented by a target dollar duration, at the lowest possible cost. This capstone exercise, , bridges theory and application, showing precisely how portfolio managers use duration to actively shape and control their exposure to market fluctuations.",
            "id": "2377225",
            "problem": "You are given a fixed universe of coupon bonds and must construct a long-only portfolio that achieves a target duration with the smallest possible initial cost. You must start from foundational definitions of present value from discounted cash flows and the time-weighted nature of duration, and then derive any additional constructs you need, including a mathematically sound optimization formulation. Your implementation must be self-contained and compute bond prices and durations directly from the input parameters.\n\nFundamental base to use:\n- Present value of a stream of deterministic cash flows discounted at a constant yield to maturity.\n- Definition of time-weighted average for Macaulay duration.\n- First-order sensitivity of price to a small change in yield as the meaning of duration in dollars.\n\nUniverse of bonds:\n- All bonds have face value $F = 100$ and pay coupons at frequency $m = 2$ times per year (semiannual).\n- For bond $i$, the inputs are annual coupon rate $c_i$ (as a decimal per year), yield to maturity $y_i$ (as a nominal annual rate compounded $m$ times per year, as a decimal), and maturity $T_i$ (in years). Coupons are $c_i F / m$ each period for $m T_i - 1$ periods, and the final cash flow at $t = T_i$ equals $F + c_i F / m$.\n- The price $P_i$ of bond $i$ is the present value of its cash flows discounted at yield $y_i$ with compounding frequency $m$.\n- The Macaulay duration $D^{\\text{Mac}}_i$ (in years) is the time-weighted average of the cash flow present value times $t_k$ over the price, where $t_k = k/m$ for $k = 1,2,\\dots,m T_i$.\n\nPortfolio construction and optimization:\n- Decision variables are the non-negative quantities (in units of face value $F$) $n_i$ of each bond $i$, subject to per-bond availability constraints $0 \\le n_i \\le \\bar{n}_i$ where $\\bar{n}_i$ is the maximum available units of bond $i$.\n- Define the dollar duration of one unit of bond $i$ as the first-order sensitivity (in dollars) of its price to a small parallel change in the yield $y_i$. You must derive and compute this quantity from the fundamental base above.\n- The total portfolio dollar duration is the sum of the dollar durations of the chosen units.\n- The portfolio construction problem is: minimize the initial cost (present value) subject to achieving at least a target dollar duration $DD_{\\text{target}}$, with long-only and availability constraints.\n\nMathematical requirements you must adhere to:\n1. Compute each bond price $P_i$ from discounted cash flows:\n   - For $k = 1,2,\\dots,m T_i - 1$, the cash flow is $CF_{i,k} = c_i F / m$ at time $t_k = k/m$, discounted by $(1 + y_i/m)^{-k}$.\n   - For $k = m T_i$, the cash flow is $CF_{i,k} = F + c_i F / m$, discounted by $(1 + y_i/m)^{-k}$.\n   - The price is $P_i = \\sum_{k=1}^{m T_i} CF_{i,k} (1 + y_i/m)^{-k}$.\n2. Compute the Macaulay duration $D^{\\text{Mac}}_i$ of each bond as\n   $$D^{\\text{Mac}}_i = \\frac{\\sum_{k=1}^{m T_i} t_k \\, CF_{i,k} \\, (1 + y_i/m)^{-k}}{P_i}, \\quad \\text{where } t_k = \\frac{k}{m}.$$\n3. Using only the principles above, derive and compute for each bond $i$ the dollar duration per unit, namely the dollar sensitivity of $P_i$ to a small parallel change in $y_i$. You must implement this without hard-coding any closed-form shortcut that is not derived from the definitions.\n4. Formulate and solve the optimization problem:\n   - Decision vector $n \\in \\mathbb{R}^N$ where $N$ is the number of bonds.\n   - Objective: minimize $\\sum_{i=1}^N P_i n_i$.\n   - Constraint: $\\sum_{i=1}^N (\\text{dollar duration per unit of bond } i) \\cdot n_i \\ge DD_{\\text{target}}$.\n   - Bounds: $0 \\le n_i \\le \\bar{n}_i$ for all $i$.\n   - If the problem is infeasible, return a sentinel value as specified below.\n\nTest suite:\nUse the following bond universe (all have $F = 100$ and $m = 2$):\n- Bond $A$: $c_A = 0.04$, $y_A = 0.05$, $T_A = 2$, $\\bar{n}_A = 50$.\n- Bond $B$: $c_B = 0.06$, $y_B = 0.04$, $T_B = 5$, $\\bar{n}_B = 30$.\n- Bond $C$: $c_C = 0.03$, $y_C = 0.05$, $T_C = 10$, $\\bar{n}_C = 40$.\n- Bond $D$: $c_D = 0.00$, $y_D = 0.04$, $T_D = 3$, $\\bar{n}_D = 10$.\n\nEvaluate your algorithm on the following four target dollar durations (in dollars):\n- Case $1$: $DD_{\\text{target}} = 0$.\n- Case $2$: $DD_{\\text{target}} = 500$.\n- Case $3$: $DD_{\\text{target}} = 30000$.\n- Case $4$: $DD_{\\text{target}} = 60000$.\n\nAnswer specification:\n- For each case, output the minimal initial cost (a float) if feasible, rounded to $10^{-4}$ (four decimal places).\n- If a case is infeasible (i.e., the maximum attainable dollar duration under the bounds is strictly less than $DD_{\\text{target}}$), output the float $-1.0$ for that case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where $r_j$ is the result for case $j$ as defined above.",
            "solution": "The problem posed is the construction of a long-only, minimum-cost bond portfolio that achieves a specified target for total dollar duration. The solution must be derived from first principles of bond pricing and duration. The problem is well-posed, scientifically sound, and contains all necessary information for a unique solution. We proceed with the derivation and solution.\n\nFirst, we formalize the price of a bond. A bond is a series of deterministic cash flows. For a bond $i$ with face value $F$, annual coupon rate $c_i$, maturity $T_i$ years, and coupon frequency $m$, the cash flow at time $t_k = k/m$ for $k=1, 2, \\dots, m T_i$ is denoted $CF_{i,k}$. For coupon-paying periods, $k < m T_i$, the cash flow is the periodic coupon payment, $CF_{i,k} = c_i F / m$. At maturity, $k = m T_i$, the cash flow includes the final coupon and the face value, $CF_{i, m T_i} = F + c_i F / m$.\n\nThe price of bond $i$, denoted $P_i$, is the present value of its stream of cash flows, discounted at the periodic yield to maturity, $y_i/m$. The yield $y_i$ is given as a nominal annual rate compounded $m$ times per year. The price is given by the formula:\n$$ P_i(y_i) = \\sum_{k=1}^{m T_i} CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\nThis formula directly computes the cost per unit of bond $i$.\n\nSecond, we must derive the dollar duration of the bond. The problem defines this as the first-order sensitivity of the price to a small parallel change in the yield, $y_i$. Mathematically, this is the derivative of the price with respect to the yield, $\\frac{dP_i}{dy_i}$. It is conventional in finance to define dollar duration as a positive quantity, representing the dollar loss for a unit increase in yield. Since price and yield are inversely related, we define the dollar duration per unit of bond $i$, denoted $DD_i$, as:\n$$ DD_i = -\\frac{dP_i}{dy_i} $$\nWe derive this derivative from the price formula using the chain rule:\n$$ \\frac{dP_i}{dy_i} = \\frac{d}{dy_i} \\sum_{k=1}^{m T_i} CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} = \\sum_{k=1}^{m T_i} CF_{i,k} \\frac{d}{dy_i} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\nThe derivative of the discount factor term is:\n$$ \\frac{d}{dy_i} \\left(1 + \\frac{y_i}{m}\\right)^{-k} = -k \\left(1 + \\frac{y_i}{m}\\right)^{-k-1} \\cdot \\frac{1}{m} $$\nSubstituting this into the expression for $\\frac{dP_i}{dy_i}$ yields:\n$$ \\frac{dP_i}{dy_i} = \\sum_{k=1}^{m T_i} CF_{i,k} \\left( - \\frac{k}{m} \\right) \\left(1 + \\frac{y_i}{m}\\right)^{-k-1} $$\n$$ \\frac{dP_i}{dy_i} = - \\frac{1}{1 + y_i/m} \\sum_{k=1}^{m T_i} \\frac{k}{m} \\cdot CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} $$\nLet us denote the time of the $k$-th cash flow as $t_k = k/m$. The expression becomes:\n$$ \\frac{dP_i}{dy_i} = - \\frac{1}{1 + y_i/m} \\sum_{k=1}^{m T_i} t_k \\cdot \\left[ CF_{i,k} \\left(1 + \\frac{y_i}{m}\\right)^{-k} \\right] $$\nThe term in the square brackets is the present value of the $k$-th cash flow. The sum is the numerator of the Macaulay duration formula. As required, we compute Macaulay duration $D^{\\text{Mac}}_i$:\n$$ D^{\\text{Mac}}_i = \\frac{\\sum_{k=1}^{m T_i} t_k \\cdot PV(CF_{i,k})}{P_i} = \\frac{\\sum_{k=1}^{m T_i} t_k \\cdot CF_{i,k} (1 + y_i/m)^{-k}}{P_i} $$\nFrom this, we see that $\\sum t_k \\cdot PV(CF_{i,k}) = D^{\\text{Mac}}_i \\cdot P_i$. Substituting this into our derivative expression, we obtain the relationship between the price sensitivity and Macaulay duration:\n$$ \\frac{dP_i}{dy_i} = - \\frac{D^{\\text{Mac}}_i \\cdot P_i}{1 + y_i/m} $$\nTherefore, the dollar duration per unit of bond $i$ is:\n$$ DD_i = -\\frac{dP_i}{dy_i} = \\frac{D^{\\text{Mac}}_i \\cdot P_i}{1 + y_i/m} $$\nThis quantity is also known as the product of the price and the modified duration, $P_i \\cdot D^{\\text{Mod}}_i$. Our implementation will compute the sum $\\sum t_k \\cdot PV(CF_{i,k})$ and use it directly to find $DD_i = \\frac{1}{1+y_i/m} \\sum t_k \\cdot PV(CF_{i,k})$, which is algebraically equivalent and adheres to the derivation from first principles.\n\nThird, we formulate the optimization problem. Let $n_i$ be the quantity (number of units) of bond $i$ to hold in the portfolio. The decision variables are the elements of the vector $n = [n_1, n_2, \\dots, n_N]^T$, where $N$ is the number of bonds in the universe. The objective is to minimize the total initial cost of the portfolio, which is the sum of the costs of the individual bond holdings:\n$$ \\text{Minimize } \\quad C(n) = \\sum_{i=1}^N P_i n_i $$\nThis minimization is subject to several constraints. The portfolio must be long-only ($n_i \\ge 0$), the quantity of each bond cannot exceed its availability ($n_i \\le \\bar{n}_i$), and the total portfolio dollar duration must meet or exceed the target $DD_{\\text{target}}$. The portfolio dollar duration is the sum of the dollar durations of its components:\n$$ \\sum_{i=1}^N DD_i n_i \\ge DD_{\\text{target}} $$\nThe complete optimization problem is a Linear Program (LP):\n$$ \\begin{aligned}\n\\text{minimize} \\quad & \\sum_{i=1}^N P_i n_i \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^N DD_i n_i \\ge DD_{\\text{target}} \\\\\n& 0 \\le n_i \\le \\bar{n}_i \\quad \\text{for } i = 1, \\dots, N\n\\end{aligned} $$\n\nThis specific form of LP, known as a continuous knapsack problem, can be solved efficiently with a greedy algorithm. The logic is to \"purchase\" dollar duration from the most cost-effective source first. The cost-effectiveness of bond $i$ is the ratio of its price to its dollar duration, $R_i = P_i / DD_i$. A lower ratio signifies a cheaper source of duration.\n\nThe algorithm is as follows:\n1.  For each bond $i$ in the universe, calculate its price $P_i$ and dollar duration $DD_i$.\n2.  If $DD_{\\text{target}} \\le 0$, the constraint $\\sum DD_i n_i \\ge DD_{\\text{target}}$ is satisfied by choosing $n_i=0$ for all $i$ (since $DD_i > 0$ for conventional bonds). The minimum cost is therefore $0$.\n3.  For $DD_{\\text{target}} > 0$, first check for feasibility. Calculate the maximum possible dollar duration from the available bonds: $DD_{\\text{max\\_total}} = \\sum_{i=1}^N DD_i \\bar{n}_i$. If $DD_{\\text{target}} > DD_{\\text{max\\_total}}$, the problem is infeasible.\n4.  If feasible, sort the bonds in increasing order of their cost-effectiveness ratio $R_i = P_i / DD_i$.\n5.  Iterate through the sorted bonds. For each bond $i$, acquire as much duration as needed, up to the maximum available from that bond ($DD_i \\bar{n}_i$), until the target duration $DD_{\\text{target}}$ is met.\n6.  The total cost is the sum of the costs incurred at each step. The cost to acquire an amount $\\Delta DD$ of duration from bond $i$ is $\\Delta DD \\cdot R_i$.\n\nWe apply this procedure to the provided test suite. The bond universe consists of four bonds (A, B, C, D) with $F=100$ and $m=2$. First, we compute their properties:\n- Bond A ($c=0.04, y=0.05, T=2, \\bar{n}=50$): $P_A \\approx 98.1190$, $DD_A \\approx 185.8330$, $R_A \\approx 0.5280$. Max DD from A: $9291.65$.\n- Bond B ($c=0.06, y=0.04, T=5, \\bar{n}=30$): $P_B \\approx 108.9828$, $DD_B \\approx 485.4385$, $R_B \\approx 0.2245$. Max DD from B: $14563.16$.\n- Bond C ($c=0.03, y=0.05, T=10, \\bar{n}=40$): $P_C \\approx 84.4443$, $DD_C \\approx 683.7196$, $R_C \\approx 0.1235$. Max DD from C: $27348.78$.\n- Bond D ($c=0.00, y=0.04, T=3, \\bar{n}=10$): $P_D \\approx 88.7971$, $DD_D \\approx 261.1680$, $R_D \\approx 0.3400$. Max DD from D: $2611.68$.\n\nThe order of cost-effectiveness is C, B, D, A. The total available duration is $\\approx 53815.27$.\n\nCase 1: $DD_{\\text{target}} = 0$. The minimum cost is $0$.\n\nCase 2: $DD_{\\text{target}} = 500$. This target is positive and less than the max available from bond C. We acquire $500$ units of duration from bond C. The cost is $500 \\cdot R_C \\approx 500 \\cdot 0.12351 = 61.7550$.\n\nCase 3: $DD_{\\text{target}} = 30000$.\n1.  Acquire all available duration from bond C: $27348.78$. Cost is $P_C \\cdot \\bar{n}_C \\approx 84.4443 \\cdot 40 = 3377.7706$.\n2.  Remaining duration needed: $30000 - 27348.78 = 2651.22$.\n3.  Acquire this from the next cheapest source, bond B. Cost is $2651.22 \\cdot R_B \\approx 2651.22 \\cdot 0.22452 = 595.2974$.\n4.  Total cost: $3377.7706 + 595.2974 = 3973.0680$.\n\nCase 4: $DD_{\\text{target}} = 60000$. The total available duration is $\\approx 53815.27$, which is less than $60000$. The problem is infeasible. The result is $-1.0$.\n\nThe implementation will perform these calculations precisely and provide the final rounded results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bond_properties(c, y, T, F=100, m=2):\n    \"\"\"\n    Calculates the price and dollar duration of a bond from first principles.\n\n    Args:\n        c (float): Annual coupon rate (decimal).\n        y (float): Nominal annual yield to maturity (decimal).\n        T (int): Maturity in years.\n        F (float): Face value.\n        m (int): Compounding/payment frequency per year.\n\n    Returns:\n        tuple[float, float]: A tuple containing the bond's price and dollar duration.\n    \"\"\"\n    if T <= 0:\n        return 0.0, 0.0\n\n    num_periods = int(m * T)\n    y_per = y / m\n    c_per = c * F / m\n\n    periods = np.arange(1, num_periods + 1)\n    \n    # Cash flows\n    cash_flows = np.full(num_periods, c_per)\n    cash_flows[-1] += F\n\n    # Discount factors\n    discount_factors = np.power(1 + y_per, -periods)\n\n    # Present value of cash flows\n    pv_cash_flows = cash_flows * discount_factors\n\n    # Price is the sum of PV of cash flows\n    price = np.sum(pv_cash_flows)\n\n    # For dollar duration, we need the sum of time-weighted PV of cash flows\n    # t_k = k/m\n    times = periods / m\n    weighted_pv_sum = np.sum(times * pv_cash_flows)\n\n    # Dollar Duration derived from first principles as -(dP/dy)\n    # dP/dy = - [1 / (1 + y/m)] * sum( t_k * PV(CF_k) )\n    # DD = -dP/dy = [1 / (1 + y/m)] * weighted_pv_sum\n    dollar_duration = weighted_pv_sum / (1 + y_per)\n\n    return price, dollar_duration\n\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for the given test cases.\n    \"\"\"\n    # Bond universe definition\n    # (c, y, T, n_bar, name)\n    bond_defs = [\n        (0.04, 0.05, 2, 50, 'A'),\n        (0.06, 0.04, 5, 30, 'B'),\n        (0.03, 0.05, 10, 40, 'C'),\n        (0.00, 0.04, 3, 10, 'D'),\n    ]\n\n    # Target dollar durations for each case\n    target_dds = [0, 500, 30000, 60000]\n\n    # Calculate properties for each bond\n    bonds = []\n    for c, y, T, n_bar, name in bond_defs:\n        price, dd = calculate_bond_properties(c, y, T)\n        if dd > 1e-9:  # Avoid division by zero for bonds with no duration\n            ratio = price / dd\n            bonds.append({\n                'name': name,\n                'price': price,\n                'dd': dd,\n                'n_bar': n_bar,\n                'ratio': ratio,\n            })\n\n    # Sort bonds by cost-effectiveness (price/dd ratio)\n    bonds.sort(key=lambda b: b['ratio'])\n\n    # Check for overall feasibility\n    total_available_dd = sum(b['dd'] * b['n_bar'] for b in bonds)\n\n    results = []\n    for dd_target in target_dds:\n        if dd_target <= 0:\n            results.append(0.0)\n            continue\n\n        if dd_target > total_available_dd:\n            results.append(-1.0)\n            continue\n\n        cost = 0.0\n        dd_to_go = dd_target\n\n        for bond in bonds:\n            if dd_to_go <= 1e-9: # Effectively zero\n                break\n\n            max_dd_from_bond = bond['dd'] * bond['n_bar']\n            dd_to_take = min(dd_to_go, max_dd_from_bond)\n            \n            # Cost to acquire this duration from this bond is dd_to_take * ratio\n            cost += dd_to_take * bond['ratio']\n            dd_to_go -= dd_to_take\n\n        results.append(round(cost, 4))\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}