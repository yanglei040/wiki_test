{
    "hands_on_practices": [
        {
            "introduction": "在利用傅里叶变换进行期权定价的众多方法中，其核心环节之一便是从特征函数（characteristic function）出发，数值化地反演出标的资产的概率密度函数。本练习旨在通过一个基础但至关重要的思想实验，来实践这一核心技能。我们将利用快速傅里叶变换（FFT）计算独立同分布随机变量之和的概率分布，并借此直观地验证中心极限定理（Central Limit Theorem）的威力。",
            "id": "2392443",
            "problem": "给定独立同分布 (i.i.d.) 的单期对数回报率，其单期分布为均值为 $0$、尺度参数为 $b$ 的拉普拉斯分布，即其密度函数为 $f_{X}(x) = \\frac{1}{2b}\\exp(-|x|/b)$，特征函数为 $\\varphi_{X}(u) = \\mathbb{E}[e^{iuX}]$。在计算经济学和金融学中，期限为 $n$ 的多期对数回报率是总和 $S_{n} = X_{1} + \\cdots + X_{n}$，这在定价和风险度量中至关重要。快速傅里叶变换 (FFT) 是一个关键工具，可用于高效地进行分布卷积和特征函数求逆，它也是基于傅里叶的期权估值方法的基础。你的任务是使用 FFT 计算 $S_{n}$ 的概率密度，并通过将该密度与具有匹配均值和方差的高斯分布进行比较，来数值化地验证中心极限定理 (CLT)。\n\n仅从以下基本事实出发：\n- 随机变量 $X$ 的特征函数为 $\\varphi_{X}(u) = \\mathbb{E}[e^{iuX}]$。\n- 如果 $X_{1},\\dots,X_{n}$ 是独立同分布的，那么对于 $S_{n} = \\sum_{k=1}^{n} X_{k}$，有 $\\varphi_{S_{n}}(u) = [\\varphi_{X}(u)]^{n}$。\n- 密度函数的（逆）傅里叶变换表示（若存在）为\n$$\nf_{S_{n}}(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} e^{-iux}\\,\\varphi_{S_{n}}(u)\\,du.\n$$\n- 离散傅里叶变换 (DFT) 及其逆变换为上述形式的积分在等距网格上提供了黎曼和近似，而快速傅里叶变换 (FFT) 能以 $\\mathcal{O}(N\\log N)$ 的时间复杂度计算 DFT。\n\n推导一个数值稳定的、基于 FFT 的算法，通过在 $[-U_{\\max},U_{\\max}]$ 上对频率网格 $\\{u_{k}\\}_{k=0}^{N-1}$ 进行采样，来近似对称区间 $[-X_{\\max},X_{\\max}]$ 上的等距空间网格 $\\{x_{j}\\}_{j=0}^{N-1}$ 上的 $f_{S_{n}}(x)$，其中 $N$ 为偶数，且网格间距满足\n$$\n\\Delta x\\,\\Delta u = \\frac{2\\pi}{N},\\quad X_{\\max} = \\frac{N\\Delta x}{2},\\quad U_{\\max} = \\frac{N\\Delta u}{2}.\n$$\n选择 $X_{\\max}$ 作为 $S_{n}$ 标准差的倍数，以控制环绕混叠效应。然后，通过将你基于 FFT 的密度与均值为 $0$、方差为 $\\sigma^{2} = \\mathrm{Var}(S_{n})$ 的高斯分布进行比较，来数值化地验证中心极限定理。其中，对于拉普拉斯增量，$\\mathrm{Var}(X) = 2b^{2}$，因此 $\\sigma^{2} = 2nb^{2}$。\n\n你的程序必须：\n- 为拉普拉斯($0,b$)增量实现基于 FFT 的求逆，以获得 $f_{S_{n}}(x)$ 的近似值。仅使用上述基本事实来设计数值方案，并显式构造满足 $\\Delta x\\,\\Delta u = \\frac{2\\pi}{N}$ 的频率和空间网格，其中 $N$ 是2的幂。\n- 对于每个测试用例，计算两个诊断指标来量化 CLT 和数值精度：\n    1. FFT 密度与具有匹配方差的高斯密度之间的 $\\mathcal{L}^{1}$ 距离，\n    $$\n    \\varepsilon_{\\mathrm{L1}} \\approx \\sum_{j=0}^{N-1} \\left| f^{\\mathrm{FFT}}_{S_{n}}(x_{j}) - \\phi_{\\mathcal{N}(0,\\sigma^{2})}(x_{j}) \\right|\\,\\Delta x.\n    $$\n    2. FFT 密度的质量误差，\n    $$\n    \\varepsilon_{\\mathrm{mass}} \\approx \\left|\\sum_{j=0}^{N-1} f^{\\mathrm{FFT}}_{S_{n}}(x_{j})\\,\\Delta x - 1\\right|.\n    $$\n- 对所有测试用例，使用 $N = 2^{14}$ 并选择 $X_{\\max} = m_{\\sigma}\\,\\sigma$，其中 $m_{\\sigma} = 12$。任何三角函数或复指数中的角度均以弧度为单位。\n\n测试套件：\n使用以下四组参数集 $(n,b)$：\n- 用例 1：$(n,b) = (1,\\,0.5)$。\n- 用例 2：$(n,b) = (5,\\,0.5)$。\n- 用例 3：$(n,b) = (50,\\,0.5)$。\n- 用例 4：$(n,b) = (2,\\,0.1)$。\n\n对于每个用例，计算 $(\\varepsilon_{\\mathrm{L1}}, \\varepsilon_{\\mathrm{mass}})$ 作为两个浮点数。你的程序应生成单行输出，其中包含按用例顺序连接的所有结果，且在每个用例内部，结果按 $(\\varepsilon_{\\mathrm{L1}}, \\varepsilon_{\\mathrm{mass}})$ 的顺序排列，四舍五入到六位小数，并以逗号分隔的列表形式包含在方括号内，例如：\n\"[e11,e12,e21,e22,e31,e32,e41,e42]\"。",
            "solution": "经评估，用户提供的问题是**有效的**。它在科学上基于概率论和傅里叶分析的原理，特别是关于特征函数的性质以及通过快速傅里叶变换 (FFT) 对其进行数值求逆。该问题定义明确，为获得唯一的数值解提供了所有必要的参数和约束条件。其目标陈述清晰，并且属于计算金融和定量分析的标准实践范围。\n\n### 理论框架与算法设计\n\n主要目标是计算 $n$ 个独立同分布 (i.i.d.) 随机变量之和 $S_{n} = \\sum_{k=1}^{n} X_{k}$ 的概率密度函数 (PDF) $f_{S_{n}}(x)$。每个 $X_{k}$ 服从均值为 $0$、尺度参数为 $b$ 的拉普拉斯分布，记为拉普拉斯($0, b$)。\n\n**1. 特征函数**\n\n单个拉普拉斯($0,b$)随机变量 $X$ 的特征函数由 $\\varphi_{X}(u) = \\mathbb{E}[e^{iuX}]$ 给出。它可以从密度函数 $f_X(x) = \\frac{1}{2b}\\exp(-|x|/b)$ 推导得出：\n$$\n\\varphi_{X}(u) = \\int_{-\\infty}^{\\infty} e^{iux} \\frac{1}{2b}e^{-|x|/b} dx = \\frac{1}{1 + b^2 u^2}\n$$\n鉴于变量 $X_k$ 是独立同分布的，它们的和 $S_n$ 的特征函数是各自特征函数的乘积，可简化为：\n$$\n\\varphi_{S_{n}}(u) = [\\varphi_{X}(u)]^n = \\left(\\frac{1}{1 + b^2 u^2}\\right)^n\n$$\n\n**2. 密度的傅里叶逆变换**\n\n概率密度函数 $f_{S_{n}}(x)$ 可以通过傅里叶逆变换从其特征函数 $\\varphi_{S_{n}}(u)$ 中恢复：\n$$\nf_{S_{n}}(x) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} e^{-iux}\\,\\varphi_{S_{n}}(u)\\,du\n$$\n\n**3. 离散化与基于 FFT 的算法**\n\n为了数值计算该积分，我们将积分域截断为 $[-U_{\\max}, U_{\\max}]$，并用离散网格上的黎曼和来近似该积分。问题指定了一个大小为 $N$、以零为中心的对称空间网格 $\\{x_j\\}$ 和频率网格 $\\{u_k\\}$。\n\n网格定义如下：\n- 空间网格：$x_j = (j - N/2)\\Delta x$，其中 $j = 0, \\dots, N-1$。\n- 频率网格：$u_k = (k - N/2)\\Delta u$，其中 $k = 0, \\dots, N-1$。\n\n网格间距必须满足关系 $\\Delta x \\Delta u = 2\\pi/N$，这对于基于 FFT 的傅里叶变换近似是至关重要的。问题指定的截断参数为 $X_{\\max} = N\\Delta x/2$ 和 $U_{\\max} = N\\Delta u/2$。由此，我们推导出 $\\Delta u = \\frac{2\\pi}{N\\Delta x} = \\frac{\\pi}{X_{\\max}}$。\n\n在网格点 $x_j$ 处，积分的离散近似为：\n$$\nf_{S_{n}}(x_j) \\approx \\frac{1}{2\\pi} \\sum_{k=0}^{N-1} e^{-iu_k x_j}\\,\\varphi_{S_{n}}(u_k)\\,\\Delta u\n$$\n为了将此和式与标准的离散傅里叶变换 (DFT)（可由 FFT 算法高效计算）关联起来，我们分析指数项：\n$$\n-iu_k x_j = -i \\left(k - \\frac{N}{2}\\right)\\Delta u \\left(j - \\frac{N}{2}\\right)\\Delta x = -i \\left(k - \\frac{N}{2}\\right)\\left(j - \\frac{N}{2}\\right) \\frac{2\\pi}{N}\n$$\n展开此式可得：\n$$\n-iu_k x_j = -i\\frac{2\\pi}{N}\\left(kj - \\frac{N}{2}k - \\frac{N}{2}j + \\frac{N^2}{4}\\right)\n$$\n指数项变为：\n$$\ne^{-iu_k x_j} = e^{-i\\frac{2\\pi}{N}kj} e^{i\\pi k} e^{i\\pi j} e^{-i\\pi\\frac{N}{2}}\n$$\n由于 $N=2^{14}$，$N/2=2^{13}$ 是一个偶数。因此，$e^{-i\\pi N/2} = \\cos(-\\pi N/2) + i\\sin(-\\pi N/2) = \\cos(2^{12}\\pi) - i\\sin(2^{12}\\pi) = 1$。$e^{i\\pi k}$ 和 $e^{i\\pi j}$ 两项分别等于 $(-1)^k$ 和 $(-1)^j$。指数项简化为：\n$$\ne^{-iu_k x_j} = (-1)^{k+j} e^{-i\\frac{2\\pi}{N}kj}\n$$\n将此代回和式，我们得到：\n$$\nf_{S_{n}}(x_j) \\approx \\frac{\\Delta u}{2\\pi} \\sum_{k=0}^{N-1} (-1)^{k+j} e^{-i\\frac{2\\pi}{N}kj}\\,\\varphi_{S_{n}}(u_k) = \\frac{\\Delta u}{2\\pi} (-1)^j \\sum_{k=0}^{N-1} \\left[(-1)^k \\varphi_{S_{n}}(u_k)\\right] e^{-i\\frac{2\\pi}{N}kj}\n$$\n该和式现在的形式是 DFT。`scipy.fft.fft` 函数计算 $F_j = \\sum_{k=0}^{N-1} Y_k e^{-i\\frac{2\\pi}{N}kj}$。通过设置 $Y_k = (-1)^k \\varphi_{S_{n}}(u_k)$，密度由下式给出：\n$$\nf^{\\mathrm{FFT}}_{S_{n}}(x_j) = \\frac{\\Delta u}{2\\pi} (-1)^j \\text{Re}\\left(\\text{FFT}\\left[(-1)^k \\varphi_{S_{n}}(u_k)\\right]_j\\right)\n$$\n我们取实部，因为 PDF 必须是实值函数，任何虚部都是由数值浮点误差引起的。\n\n**4. 中心极限定理与诊断指标**\n\n中心极限定理 (CLT) 指出，在特定条件下，大量独立同分布随机变量的和将近似呈正态分布。$S_n$ 的均值为 $\\mathbb{E}[S_n] = n\\mathbb{E}[X] = 0$。方差为 $\\mathrm{Var}(S_n) = n\\mathrm{Var}(X) = n(2b^2) = 2nb^2$。\n我们将我们通过 FFT 计算的密度与具有匹配均值 $0$ 和方差 $\\sigma^2 = 2nb^2$ 的高斯 PDF $\\phi_{\\mathcal{N}(0,\\sigma^{2})}(x)$ 进行比较：\n$$\n\\phi_{\\mathcal{N}(0,\\sigma^{2})}(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\n该比较通过两个指标进行量化：\n1.  **$\\mathcal{L}^1$ 距离**：$\\varepsilon_{\\mathrm{L1}} = \\int |f^{\\mathrm{FFT}}_{S_{n}}(x) - \\phi_{\\mathcal{N}(0,\\sigma^{2})}(x)| dx$，通过和式 $\\sum_{j=0}^{N-1} \\left| f^{\\mathrm{FFT}}_{S_{n}}(x_{j}) - \\phi_{\\mathcal{N}(0,\\sigma^{2})}(x_{j}) \\right|\\,\\Delta x$ 来近似。\n2.  **质量误差**：$\\varepsilon_{\\mathrm{mass}} = |\\int f^{\\mathrm{FFT}}_{S_{n}}(x) dx - 1|$，通过 $\\left|\\sum_{j=0}^{N-1} f^{\\mathrm{FFT}}_{S_{n}}(x_{j})\\,\\Delta x - 1\\right|$ 来近似。该指标评估 FFT 逆变换的数值精度（离散化和截断误差）。\n\n对每个测试用例 $(n, b)$ 执行该算法，以计算这两个诊断指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 0.5),  # Case 1\n        (5, 0.5),  # Case 2\n        (50, 0.5), # Case 3\n        (2, 0.1),  # Case 4\n    ]\n\n    results = []\n    \n    # Numerical parameters\n    N = 2**14\n    m_sigma = 12.0\n\n    for n, b in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        \n        # 1. Calculate variance and set up grid parameters based on it.\n        # Variance of the sum of n i.i.d. Laplace(0, b) variables.\n        sigma_sq = 2.0 * n * b**2\n        sigma = np.sqrt(sigma_sq)\n        \n        # Truncation range for the spatial domain.\n        X_max = m_sigma * sigma\n        \n        # Grid spacing for spatial and frequency domains.\n        # dx: spatial step, du: frequency step.\n        dx = 2.0 * X_max / N\n        du = (2.0 * np.pi) / (N * dx)\n\n        # 2. Create centered spatial and frequency grids.\n        # Indices for grid construction.\n        j_indices = np.arange(N)\n        k_indices = np.arange(N)\n        \n        # x_grid: Spatial points from -X_max to X_max - dx.\n        x_grid = (j_indices - N / 2.0) * dx\n        \n        # u_grid: Frequency points.\n        u_grid = (k_indices - N / 2.0) * du\n\n        # 3. Compute the density using the FFT-based inversion.\n        # Characteristic function of S_n evaluated on the frequency grid.\n        phi_of_u = (1.0 + b**2 * u_grid**2)**(-n)\n        \n        # Prepare the vector for FFT according to the shift theorem.\n        # This handles the centered grids correctly.\n        Y_k = phi_of_u * (-1.0)**k_indices\n        \n        # Perform the Fast Fourier Transform.\n        F_j = fft(Y_k)\n        \n        # Recover the density from the FFT output, applying scaling and shift.\n        # The result must be real, so we take np.real to discard numerical noise.\n        f_fft = (du / (2.0 * np.pi)) * np.real((-1.0)**j_indices * F_j)\n        \n        # 4. Compute the Gaussian PDF for comparison (Central Limit Theorem).\n        # The Gaussian has the same mean (0) and variance (sigma_sq) as S_n.\n        gaussian_pdf = (1.0 / np.sqrt(2.0 * np.pi * sigma_sq)) * np.exp(-x_grid**2 / (2.0 * sigma_sq))\n        \n        # 5. Calculate the diagnostic metrics.\n        # L1 distance between the FFT density and the Gaussian density.\n        # This is a numerical approximation of the L1 integral.\n        eps_L1 = np.sum(np.abs(f_fft - gaussian_pdf)) * dx\n        \n        # Mass error of the FFT density.\n        # This checks if the numerical density integrates to 1.\n        total_mass = np.sum(f_fft) * dx\n        eps_mass = np.abs(total_mass - 1.0)\n        \n        # Append formatted results to the list.\n        results.append(\"{:.6f}\".format(eps_L1))\n        results.append(\"{:.6f}\".format(eps_mass))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了从特征函数恢复密度函数的基本功后，我们自然地要将其应用于真实的金融问题中，例如计算期权的风险敏感性指标——“希腊字母”（Greeks）。本练习将引导你推导并在傅里叶域中计算期权的重要风险指标 $Gamma$，并将其结果与经典的有限差分法（central-difference approximation）进行对比。这个过程不仅能让你体会到 FFT 方法在金融衍生品领域的强大功能，还能加深对数值方法收敛性的理解。",
            "id": "2392450",
            "problem": "你需要通过计算来验证，当现货价格扰动量趋于零时，期权价格关于现货价格的二阶导数（Gamma）的中心差分近似，会收敛到在傅里叶域中解析计算出的导数。在 Black–Scholes 设定下进行，并使用快速傅里叶变换 (FFT) 来评估所需的傅里叶积分。\n\n假设以下基本前提：\n\n- 在风险中性测度下，折现后的资产价格是一个鞅。在 Black–Scholes 模型中，对数价格 $x_t = \\ln S_t$ 的动态为 $x_T \\sim \\mathcal{N}\\left(x_0 + (r - q - \\tfrac{1}{2}\\sigma^2)T,\\ \\sigma^2 T\\right)$，其中 $S_0 = e^{x_0}$，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是波动率，$T$ 是到期时间。$x_T$ 的特征函数为\n$$\n\\varphi_{x_T}(u) = \\mathbb{E}\\left[e^{i u x_T}\\right] = \\exp\\left( i u \\left( x_0 + (r - q - \\tfrac{1}{2}\\sigma^2)T \\right) - \\tfrac{1}{2}\\sigma^2 u^2 T \\right).\n$$\n- Carr–Madan 阻尼变换通过处理指数阻尼看涨期权价格 $c(k) = e^{\\alpha k} C(K)$ 来为欧式看涨期权定价，其中 $k = \\ln K$ 且 $\\alpha > 0$ 是一个阻尼参数。$c(k)$ 关于 $k$ 的傅里叶变换为\n$$\n\\widehat{c}(u) = \\int_{-\\infty}^{\\infty} e^{i u k} c(k)\\, dk\n= e^{-rT}\\,\\frac{\\varphi_{x_T}(u - i(\\alpha + 1))}{\\alpha^2 + \\alpha - u^2 + i u (2\\alpha + 1)}.\n$$\n通过傅里叶逆变换可以恢复 $c(k)$，从而得到 $C(K)$，该逆变换可以通过快速傅里叶变换 (FFT) 进行数值近似。\n\n你的任务：\n\n1) 从上述定义以及关于现货价格 $S$ 的微分恒等式出发，即令 $x = \\ln S$，从而有\n$$\n\\frac{\\partial}{\\partial S} = \\frac{1}{S}\\frac{\\partial}{\\partial x},\\qquad\n\\Gamma(S) = \\frac{\\partial^2 C}{\\partial S^2}(S) = \\frac{1}{S^2}\\left(\\frac{\\partial^2 C}{\\partial x^2}(x) - \\frac{\\partial C}{\\partial x}(x)\\right),\n$$\n并认识到 $x$ 仅通过 $\\varphi_{x_T}(u - i(\\alpha + 1)) = \\exp\\left( i(u - i(\\alpha + 1)) x \\right) \\times \\text{(独立于 }x\\text{ 的项)}$ 进入 $\\widehat{c}(u)$，推导 Gamma 的傅里叶域表示。得出结论：在傅里叶域中，算子 $\\tfrac{\\partial}{\\partial x}$ 对 $\\widehat{c}(u)$ 的作用等同于乘以 $i(u - i(\\alpha + 1))$，并得出一个表达式，表明与 $g(k) = e^{\\alpha k}\\,\\Gamma(K)$ 相关的阻尼 Gamma 变换 $\\widehat{g}(u)$ 是通过将一个乘法因子应用于 $\\widehat{c}(u)$ 得到的。不要使用任何无法从上述基础推导出的公式，并展示所有中间推理步骤。\n\n2) 在 Black–Scholes 模型下，使用 Carr–Madan 框架实现一个用于欧式看涨期权的快速傅里叶变换 (FFT) 定价器，以在对数执行价格 $k = \\ln K$ 的网格上计算 $C(K)$。然后实现：\n- 使用第 1 部分的结果，通过将相应的乘法因子应用于 $\\widehat{c}(u)$ 并通过 FFT 进行逆变换，来计算给定执行价格 $K$ 处的傅里叶域 Gamma，从而得到 $g(k) = e^{\\alpha k}\\Gamma(K)$ 并因此得到 $\\Gamma(K)$。\n- 在现货价格 $S_0$ 和执行价格 $K$ 处的中心差分 Gamma 近似，其定义为\n$$\n\\Gamma_{\\Delta S}(S_0;K) = \\frac{C(S_0 + \\Delta S, K) - 2\\,C(S_0, K) + C(S_0 - \\Delta S, K)}{(\\Delta S)^2},\n$$\n通过在扰动后的现货价格 $S_0 \\pm \\Delta S$ 处重新评估 Carr–Madan FFT 看涨期权价格来计算。\n\n3) 数值上证明，当 $\\Delta S \\to 0$ 时，中心差分 Gamma 收敛到第 1 部分推导出的解析傅里叶域 Gamma。为使此测试独立且可复现，请使用以下数值配置和测试套件：\n\n- 使用阻尼参数 $\\alpha = 1.5$，FFT 节点数 $N = 2^{12}$，傅里叶网格间距 $\\eta = 0.25$，因此对数执行价格间距为 $\\lambda = \\dfrac{2\\pi}{N \\eta}$，对数执行价格范围以 $b = \\dfrac{\\pi}{\\eta}$ 为中心，使得 $k_m = -b + m \\lambda$ 对于 $m = 0, 1, \\dots, N-1$。\n- 使用 Simpson 法则权重进行傅里叶积分的离散化。\n- 使用线性插值从计算出的网格中读取给定 $k = \\ln K$ 处的值。\n- 对于下面的每个测试用例，评估在扰动量 $\\Delta S \\in \\{ 2.0,\\ 1.0,\\ 0.5,\\ 0.25 \\}$ 下的误差列表\n$$\nE(\\Delta S) = \\left| \\Gamma_{\\Delta S}(S_0;K) - \\Gamma_{\\text{Fourier}}(S_0;K) \\right|\n$$\n- 对于每个测试用例，输出一个布尔值，指示是否观察到收敛。收敛的定义是：当 $\\Delta S$ 减半时，误差序列总体上是递减的（允许小的数值波动），量化标准为：在三次减半过程中至少有两次连续下降，并且当通过 $\\max\\{|\\Gamma_{\\text{Fourier}}|,\\ 10^{-8}\\}$ 进行归一化时，$E(0.25)$ 不大于 $0.8 \\times E(2.0)$。\n\n模型参数和评估点的测试套件：\n- 案例 A（平价，中等期限）：$(S_0, K, T, r, q, \\sigma) = (100.0,\\ 100.0,\\ 0.5,\\ 0.01,\\ 0.0,\\ 0.2)$。\n- 案例 B（价外，一年期）：$(S_0, K, T, r, q, \\sigma) = (80.0,\\ 120.0,\\ 1.0,\\ 0.0,\\ 0.0,\\ 0.25)$。\n- 案例 C（临近到期，轻微价外）：$(S_0, K, T, r, q, \\sigma) = (100.0,\\ 105.0,\\ 0.05,\\ 0.0,\\ 0.0,\\ 0.3)$。\n\n你的程序应生成单行输出，其中包含三个测试用例的布尔结果，以逗号分隔并用方括号括起来（例如，$\\texttt{[True,True,False]}$）。不应打印任何其他输出。",
            "solution": "用户确认问题有效并继续生成解决方案。\n该问题要求推导期权 Gamma 的傅里叶域表示，使用快速傅里叶变换 (FFT) 对其进行实现，并对中心差分近似到该解析 Gamma 的收敛性进行数值验证。我将按顺序处理每个部分。\n\n整个分析在 Black-Scholes 模型内进行，并利用 Carr-Madan FFT 定价框架。\n\n**第 1 部分：傅里叶域 Gamma 的推导**\n\n目标是求出阻尼 Gamma 的傅里叶变换，记为 $\\widehat{g}(u)$，其中 $g(k) = e^{\\alpha k} \\Gamma(K)$ 且 $k = \\ln K$。期权的 Gamma，即 $\\Gamma$，是其价格 $C$ 关于现货价格 $S$ 的二阶导数。关于 $S$ 的导数和关于对数价格 $x = \\ln S$ 的导数之间的关系由链式法则给出：\n$$ \\frac{\\partial}{\\partial S} = \\frac{\\partial x}{\\partial S} \\frac{\\partial}{\\partial x} = \\frac{1}{S}\\frac{\\partial}{\\partial x} $$\n应用此法则两次，我们得到问题陈述中提供的 Gamma 表达式：\n$$ \\Gamma(S, K) = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{\\partial}{\\partial S}\\left(\\frac{1}{S}\\frac{\\partial C}{\\partial x}\\right) = -\\frac{1}{S^2}\\frac{\\partial C}{\\partial x} + \\frac{1}{S^2}\\frac{\\partial^2 C}{\\partial x^2} = \\frac{1}{S^2}\\left(\\frac{\\partial^2 C}{\\partial x^2} - \\frac{\\partial C}{\\partial x}\\right) $$\n此处，期权价格 $C$ 是现货价格 $S$ 和执行价格 $K$ 的函数。傅里叶变换方法在固定现货价格（我们记为 $S_0$）下，对对数执行价格 $k = \\ln K$ 的网格进行操作。因此，导数是关于 $S_0$ 处的现货价格计算的，这对应于关于 $x_0 = \\ln S_0$ 的导数。\n$$ \\Gamma(S_0, K) = \\frac{1}{S_0^2}\\left(\\frac{\\partial^2 C}{\\partial x_0^2} - \\frac{\\partial C}{\\partial x_0}\\right) $$\n在 Carr-Madan 框架中，看涨期权价格通过对阻尼看涨期权价格变换 $\\widehat{c}(u)$ 进行傅里叶逆变换来恢复。\n$$ C(S_0, K) = e^{-\\alpha k} c(k) = e^{-\\alpha k} \\mathcal{F}^{-1}[\\widehat{c}(u)](k) = e^{-\\alpha k} \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-iuk} \\widehat{c}(u) du $$\n对 $x_0$ 的依赖完全包含在 $\\widehat{c}(u)$ 中，通过特征函数 $\\varphi_{x_T}$ 体现。问题陈述指出：\n$$ \\varphi_{x_T}(v) = \\exp\\left( i v x_0 \\right) \\times (\\text{独立于 } x_0 \\text{ 的项}) $$\n其中 $v$ 是特征函数的参数。这使我们可以轻松计算 $\\varphi_{x_T}$ 关于 $x_0$ 的导数：\n$$ \\frac{\\partial \\varphi_{x_T}(v)}{\\partial x_0} = (iv) \\varphi_{x_T}(v) $$\n$$ \\frac{\\partial^2 \\varphi_{x_T}(v)}{\\partial x_0^2} = (iv)^2 \\varphi_{x_T}(v) = -v^2 \\varphi_{x_T}(v) $$\n在 $\\widehat{c}(u)$ 的表达式中，特征函数的参数是 $v = u - i(\\alpha+1)$。由于 $\\widehat{c}(u)$ 中的所有其他项都独立于 $x_0$，微分属性可以传递进去：\n$$ \\frac{\\partial \\widehat{c}(u)}{\\partial x_0} = i(u - i(\\alpha+1)) \\widehat{c}(u) $$\n$$ \\frac{\\partial^2 \\widehat{c}(u)}{\\partial x_0^2} = (i(u - i(\\alpha+1)))^2 \\widehat{c}(u) = -(u - i(\\alpha+1))^2 \\widehat{c}(u) $$\n看涨期权价格 $C$ 关于 $x_0$ 的导数现在可以在傅里叶域中表示。由于微分和傅里叶逆变换是线性算子，它们可以交换顺序：\n$$ \\frac{\\partial C}{\\partial x_0} = e^{-\\alpha k} \\mathcal{F}^{-1}\\left[\\frac{\\partial \\widehat{c}(u)}{\\partial x_0}\\right](k) = e^{-\\alpha k} \\mathcal{F}^{-1}[i(u - i(\\alpha+1)) \\widehat{c}(u)](k) $$\n$$ \\frac{\\partial^2 C}{\\partial x_0^2} = e^{-\\alpha k} \\mathcal{F}^{-1}\\left[\\frac{\\partial^2 \\widehat{c}(u)}{\\partial x_0^2}\\right](k) = e^{-\\alpha k} \\mathcal{F}^{-1}[-(u - i(\\alpha+1))^2 \\widehat{c}(u)](k) $$\n现在，我们将这些代入 $\\Gamma(S_0, K)$ 的表达式中。阻尼 Gamma 为 $g(k) = e^{\\alpha k}\\Gamma(S_0, K)$：\n$$ g(k) = e^{\\alpha k} \\frac{1}{S_0^2} \\left[ \\left(e^{-\\alpha k} \\mathcal{F}^{-1}[-(u - i(\\alpha+1))^2 \\widehat{c}(u)](k)\\right) - \\left(e^{-\\alpha k} \\mathcal{F}^{-1}[i(u - i(\\alpha+1)) \\widehat{c}(u)](k)\\right) \\right] $$\n项 $e^{\\alpha k}$ 和 $e^{-\\alpha k}$ 相互抵消。根据傅里叶逆变换的线性性质：\n$$ g(k) = \\frac{1}{S_0^2} \\mathcal{F}^{-1}\\left[ \\left( -(u-i(\\alpha+1))^2 - i(u-i(\\alpha+1)) \\right) \\widehat{c}(u) \\right](k) $$\n对两边进行傅里叶变换，得到阻尼 Gamma 变换 $\\widehat{g}(u)$：\n$$ \\widehat{g}(u) = \\mathcal{F}[g(k)](u) = \\frac{1}{S_0^2} \\left[ -(u-i(\\alpha+1))^2 - i(u-i(\\alpha+1)) \\right] \\widehat{c}(u) $$\n我们来简化这个乘法因子。令 $v = u - i(\\alpha+1)$：\n$$ -(v^2) - iv = -(u^2 - (\\alpha+1)^2 - 2iu(\\alpha+1)) - i(u - i(\\alpha+1)) $$\n$$ = -u^2 + (\\alpha+1)^2 + 2iu(\\alpha+1) - iu - (\\alpha+1) $$\n$$ = -u^2 + (\\alpha^2 + 2\\alpha + 1) + i(2u\\alpha + 2u - u) - \\alpha - 1 $$\n$$ = -u^2 + \\alpha^2 + \\alpha + iu(2\\alpha + 1) $$\n这个表达式恰好是 Carr-Madan 公式中 $\\widehat{c}(u)$ 的分母：\n$$ \\widehat{c}(u) = e^{-rT}\\,\\frac{\\varphi_{x_T}(u - i(\\alpha + 1))}{\\alpha^2 + \\alpha - u^2 + i u (2\\alpha + 1)} $$\n将其代回，我们得到了一个非常简洁的 $\\widehat{g}(u)$ 形式：\n$$ \\widehat{g}(u) = \\frac{1}{S_0^2} \\left( \\alpha^2 + \\alpha - u^2 + iu(2\\alpha+1) \\right) \\left( e^{-rT}\\,\\frac{\\varphi_{x_T}(u - i(\\alpha + 1))}{\\alpha^2 + \\alpha - u^2 + i u (2\\alpha + 1)} \\right) $$\n$$ \\widehat{g}(u) = \\frac{e^{-rT}}{S_0^2} \\varphi_{x_T}(u - i(\\alpha + 1)) $$\n这就是 Gamma 的傅里叶域表示。阻尼 Gamma 变换 $\\widehat{g}(u)$ 是通过将 $\\widehat{c}(u)$ 乘以因子 $\\frac{1}{S_0^2}(\\alpha^2 + \\alpha - u^2 + iu(2\\alpha+1))$ 得到的。\n\n**第 2 和 3 部分：实现与数值验证**\n\n为实现基于 FFT 的计算并执行验证，我们遵循以下步骤：\n1.  **网格设置**：我们按照规定定义对数执行价格 $k$ 和傅里叶域变量 $u$ 的网格。\n    - 点数 $N = 2^{12}$。\n    - 阻尼参数 $\\alpha = 1.5$。\n    - 傅里叶网格间距 $\\eta = 0.25$。\n    - 对数执行价格网格间距 $\\lambda = \\frac{2\\pi}{N \\eta}$。\n    - 对数执行价格网格：$k_m = -\\frac{\\pi}{\\eta} + m\\lambda$ 对于 $m=0, \\dots, N-1$。\n    - 用于积分的傅里叶网格：$u_j = j\\eta$ 对于 $j=0, \\dots, N-1$。\n\n2.  **基于 FFT 的逆变换**：傅里叶逆变换被近似为一个求和，然后映射到标准的 FFT 算法。来自单边傅里叶积分的看涨期权价格公式为：\n    $$ C(k) = \\frac{e^{-\\alpha k}}{\\pi} \\text{Re} \\left[ \\int_0^{\\infty} e^{-iuk} \\widehat{c}_{CM}(u) du \\right] $$\n    其中 $\\widehat{c}_{CM}(u) = e^{-rT} \\frac{\\varphi_{x_T}(u - i(\\alpha+1))}{\\alpha^2+\\alpha-u^2+i(2\\alpha+1)u}$。\n    该积分使用 Simpson 法则进行离散化，并使用 FFT 进行求值：\n    $$ \\int_0^\\infty \\approx \\sum_{j=0}^{N-1} W_j e^{-iu_j k_m} \\widehat{c}_{CM}(u_j) $$\n    其中 $W_j$ 是 Simpson 权重。项 $e^{-iu_j k_m} = e^{-i(j\\eta)(-\\pi/\\eta + m\\lambda)} = e^{ij\\pi}e^{-ijm\\eta\\lambda} = (-1)^j e^{-i2\\pi jm/N}$。该求和成为序列 $Y_j = (-1)^j \\widehat{c}_{CM}(u_j) W_j$ 的标准 DFT。\n    计算 Gamma 时应用相同的过程，只需将 $\\widehat{c}_{CM}(u)$ 替换为与 Gamma 的单边积分相对应的变换，即 $\\frac{1}{S_0^2} e^{-rT} \\varphi_{x_T}(u-i(\\alpha+1))$。\n\n3.  **数值方案**：\n    - **Simpson 权重**：对于 $N=2^{12}$ 个点（偶数），我们有 $N-1$ 个区间（奇数）。这与要求偶数个区间的标准 Simpson 法则不兼容。我们使用一种常见的调整方法：对前 $N-2$ 个区间（前 $N-1$ 个点）应用 Simpson 法则，对最后一个区间应用梯形法则。构造一个能够实现这一点的权重向量。\n    - **Gamma 计算**：我们实现两种方法：\n        a) **傅里叶域 Gamma**：通过对第 1 部分推导出的 $\\widehat{g}(u)$ 进行 FFT 逆变换，并在目标对数执行价格 $k = \\ln K$ 处进行插值，计算 $\\Gamma_{\\text{Fourier}}(S_0, K)$。\n        b) **中心差分 Gamma**：通过调用 FFT 看涨期权定价器三次，分别使用现货价格 $S_0+\\Delta S$、$S_0$ 和 $S_0-\\Delta S$，然后应用有限差分公式，来计算 $\\Gamma_{\\Delta S}(S_0, K)$。\n    - **收敛性测试**：对于每个测试用例，我们计算在 $\\Delta S \\in \\{2.0, 1.0, 0.5, 0.25\\}$ 下的误差 $E(\\Delta S) = |\\Gamma_{\\Delta S} - \\Gamma_{\\text{Fourier}}|$。然后我们检查两个条件：(i) 在 $\\Delta S$ 的至少两次连续减半中，误差是减小的；(ii) 最终误差 $E(0.25)$ 至多是初始误差 $E(2.0)$ 的 $80\\%$。\n\n按照要求，该实现将被封装在一个单独的 Python 脚本中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to perform the derivation, implementation, and verification.\n    \"\"\"\n\n    # 1. Numerical Configuration\n    alpha = 1.5\n    N = 2**12\n    eta = 0.25\n    lambda_ = (2 * np.pi) / (N * eta)\n    b = np.pi / eta\n    k_grid = -b + np.arange(N) * lambda_\n    u_grid = np.arange(N) * eta\n\n    # Simpson's rule weights for an even number of points (N).\n    # This uses Simpson's rule on the first N-1 points and Trapezoidal on the last interval.\n    weights = np.zeros(N)\n    # Simpson weights for first N-1 points (N-2 intervals)\n    weights[0] = 1/3\n    weights[1:N-1:2] = 4/3\n    weights[2:N-2:2] = 2/3\n    weights[N-2] = 1/3 # Last point of the Simpson part\n    # Add trapezoidal for last interval\n    weights[N-2] += 1/2\n    weights[N-1] = 1/2\n    simpson_weights = weights * eta\n\n    def characteristic_function(u, x0, T, r, q, sigma):\n        \"\"\"\n        Calculates the characteristic function of the log-price in the Black-Scholes model.\n        \"\"\"\n        mu = x0 + (r - q - 0.5 * sigma**2) * T\n        return np.exp(1j * u * mu - 0.5 * u**2 * sigma**2 * T)\n\n    def fft_pricer(S0, T, r, q, sigma, is_gamma):\n        \"\"\"\n        A general FFT-based calculator for call prices or Gammas.\n        If is_gamma=False, it computes call prices.\n        If is_gamma=True, it computes Gammas.\n        \"\"\"\n        x0 = np.log(S0)\n        \n        # Argument for the characteristic function in the integrand\n        v = u_grid - 1j * (alpha + 1)\n        \n        phi_val = characteristic_function(v, x0, T, r, q, sigma)\n\n        if not is_gamma:\n            # Carr-Madan integrand for call price transform\n            denominator = alpha**2 + alpha - u_grid**2 + 1j * u_grid * (2*alpha + 1)\n            integrand = (np.exp(-r * T) * phi_val) / denominator\n        else:\n            # Integrand for damped Gamma transform\n            # This follows from the derivation in the solution text\n            integrand = (np.exp(-r * T) / S0**2) * phi_val\n\n        # Apply Simpson's rule weights and prepare for FFT\n        fft_input = integrand * simpson_weights * (-1)**np.arange(N)\n        \n        # Perform FFT\n        fft_output = np.fft.fft(fft_input)\n        \n        # Recover real-space values\n        if not is_gamma:\n            # Damped call prices c(k)\n            damped_values = np.real(fft_output) / np.pi\n            # Undamp to get call prices C(K)\n            values = np.exp(-alpha * k_grid) * damped_values\n        else:\n            # Damped Gammas g(k)\n            damped_values = np.real(fft_output) / np.pi\n            # Undamp to get Gammas Gamma(K)\n            values = np.exp(-alpha * k_grid) * damped_values\n\n        return values\n\n    def get_value_at_K(S0, K, T, r, q, sigma, is_gamma):\n        \"\"\"\n        Gets the price or Gamma at a specific strike K by interpolating the FFT grid.\n        \"\"\"\n        k_target = np.log(K)\n        values_grid = fft_pricer(S0, T, r, q, sigma, is_gamma)\n        # Linear interpolation to find value at the target log-strike\n        return np.interp(k_target, k_grid, values_grid)\n\n    # 2. Test Suite Definition\n    test_cases = [\n        # (S0, K, T, r, q, sigma)\n        (100.0, 100.0, 0.5, 0.01, 0.0, 0.2),   # Case A\n        (80.0, 120.0, 1.0, 0.0, 0.0, 0.25),  # Case B\n        (100.0, 105.0, 0.05, 0.0, 0.0, 0.3),   # Case C\n    ]\n    bump_sizes = np.array([2.0, 1.0, 0.5, 0.25])\n    \n    results = []\n\n    # 3. Main Loop for Verification\n    for case in test_cases:\n        S0, K, T, r, q, sigma = case\n\n        # Calculate the analytical Fourier-domain Gamma\n        gamma_fourier = get_value_at_K(S0, K, T, r, q, sigma, is_gamma=True)\n\n        errors = []\n        for dS in bump_sizes:\n            # Calculate prices for central difference\n            price_up = get_value_at_K(S0 + dS, K, T, r, q, sigma, is_gamma=False)\n            price_mid = get_value_at_K(S0, K, T, r, q, sigma, is_gamma=False)\n            price_down = get_value_at_K(S0 - dS, K, T, r, q, sigma, is_gamma=False)\n            \n            # Calculate central-difference Gamma\n            gamma_cd = (price_up - 2 * price_mid - price_down) / (dS**2)\n            \n            # Calculate and store the absolute error\n            errors.append(np.abs(gamma_cd - gamma_fourier))\n\n        # Check for convergence\n        E = np.array(errors)\n        \n        # Condition 1: At least two successive decreases\n        decrease_1 = E[1] < E[0]\n        decrease_2 = E[2] < E[1]\n        decrease_3 = E[3] < E[2]\n        cond1 = (decrease_1 and decrease_2) or (decrease_2 and decrease_3)\n        \n        # Condition 2: Final error is at most 80% of initial error\n        cond2 = E[3] <= 0.8 * E[0]\n        \n        convergence_observed = cond1 and cond2\n        results.append(convergence_observed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个数值方法的强大与否，不仅取决于其理论基础，也依赖于实施中的各种技术细节。零填充（zero-padding）是 FFT 应用中一个用以提高输出分辨率的关键技巧。本练习将深入探究零填充的长度如何影响我们恢复出的风险中性概率密度（risk-neutral density）的精度，特别是对于风险管理至关重要的分布尾部区域。",
            "id": "2392491",
            "problem": "考虑一个 Black–Scholes 框架下的无摩擦市场。设风险中性测度下的资产价格过程使得时间-$T$ 的对数价格 $X_T = \\ln(S_T)$ 服从正态分布，其均值为 $\\mu$，方差为 $\\sigma_X^2$，其中 $S_0 &gt; 0$ 是初始价格，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是波动率。具体地，令\n$$\n\\mu = \\ln(S_0) + (r - q - \\tfrac{1}{2}\\sigma^2)T,\\quad \\sigma_X^2 = \\sigma^2 T.\n$$\n$X_T$ 的特征函数为\n$$\n\\varphi_{X_T}(u) = \\mathbb{E}[e^{i u X_T}] = \\exp\\left(i u \\mu - \\tfrac{1}{2}\\sigma_X^2 u^2\\right).\n$$\n$X_T$ 的风险中性密度由傅里叶逆变换给出\n$$\np_{X_T}(x) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} e^{-i u x}\\, \\varphi_{X_T}(u)\\, du.\n$$\n定义一个均匀频率网格，其间距为 $\\Delta u &gt; 0$，并在 $U_{\\max} = \\Delta u \\cdot \\tfrac{N_{\\mathrm{sig}}}{2}$ 处进行有限截断，该截断由一个偶数整数 $N_{\\mathrm{sig}}\\ge 2$ 决定。令\n$$\nu_k = u_{\\min} + k\\, \\Delta u,\\quad \\text{对于 } k=0,1,\\dots,N_{\\mathrm{sig}}-1,\\quad \\text{其中 } u_{\\min} = - U_{\\max}.\n$$\n令 $f_k = \\varphi_{X_T}(u_k)$，对于 $k=0,\\dots,N_{\\mathrm{sig}}-1$。对于选定的整数 $N_{\\mathrm{tot}} \\ge N_{\\mathrm{sig}}$，通过设置 $f_k = 0$（对于 $k = N_{\\mathrm{sig}},\\dots,N_{\\mathrm{tot}}-1$）来定义补零序列 $\\{f_k\\}_{k=0}^{N_{\\mathrm{tot}}-1}$。离散逆变换将在均匀的对数价格网格上执行\n$$\nx_j = j\\, \\Delta x,\\quad \\Delta x = \\frac{2\\pi}{N_{\\mathrm{tot}}\\, \\Delta u},\\quad j=0,1,\\dots,N_{\\mathrm{tot}}-1,\n$$\n通过计算\n$$\n\\widehat{p}(x_j) = \\frac{\\Delta u}{2\\pi}\\, e^{-i u_{\\min} x_j} \\sum_{k=0}^{N_{\\mathrm{tot}}-1} f_k\\, e^{-i 2\\pi \\frac{j k}{N_{\\mathrm{tot}}}},\n$$\n这是与上述采样方案一致的离散傅里叶变换 (DFT) 逆变换。注意，理论上 $\\widehat{p}(x_j)$ 是实数值；在数值计算中出现的任何虚部都应被忽略。\n\n设 $X_T$ 的真实密度为正态密度\n$$\np_{\\mathrm{true}}(x) = \\frac{1}{\\sqrt{2\\pi}\\, \\sigma_X} \\exp\\!\\left(-\\frac{(x - \\mu)^2}{2\\sigma_X^2}\\right).\n$$\n通过条件 $\\lvert x - \\mu \\rvert \\ge \\kappa \\sigma_X$（其中 $\\kappa = 3$）定义合并的双尾区域。对于给定的 $N_{\\mathrm{tot}}$，将尾部绝对误差定义为尾部上 $L^1$-误差的黎曼和近似：\n$$\nE(N_{\\mathrm{tot}}) = \\Delta x \\sum_{\\{j: \\lvert x_j - \\mu \\rvert \\ge \\kappa \\sigma_X\\}} \\left| \\operatorname{Re}\\left(\\widehat{p}(x_j)\\right) - p_{\\mathrm{true}}(x_j) \\right|.\n$$\n\n使用以下数值：\n- $S_0 = 100$\n- $r = 0.02$\n- $q = 0.00$\n- $\\sigma = 0.20$\n- $T = 1.0$\n- $\\Delta u = 0.25$\n- $N_{\\mathrm{sig}} = 512$\n- $\\kappa = 3$\n\n通过为以下总变换长度测试套件计算 $E(N_{\\mathrm{tot}})$，研究补零长度对所恢复的风险中性密度在尾部区域的准确性的影响：\n- $N_{\\mathrm{tot}} = 512$ (无补零)\n- $N_{\\mathrm{tot}} = 1024$ (中度补零)\n- $N_{\\mathrm{tot}} = 4096$ (大量补零)\n- $N_{\\mathrm{tot}} = 16384$ (超大量补零)\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其顺序与上述测试套件相对应，即 $[E(512),E(1024),E(4096),E(16384)]$。所有输出必须是无单位的实数（浮点数）。",
            "solution": "在尝试解答之前，需对问题进行验证。\n\n步骤 1：提取已知条件\n- 框架：无摩擦市场，Black–Scholes 模型。\n- 时间 $T$ 的对数价格：$X_T = \\ln(S_T)$ 服从正态分布。\n- 对数价格的均值：$\\mu = \\ln(S_0) + (r - q - \\tfrac{1}{2}\\sigma^2)T$。\n- 对数价格的方差：$\\sigma_X^2 = \\sigma^2 T$。\n- $X_T$ 的特征函数：$\\varphi_{X_T}(u) = \\exp\\left(i u \\mu - \\tfrac{1}{2}\\sigma_X^2 u^2\\right)$。\n- $X_T$ 的真实概率密度函数：$p_{\\mathrm{true}}(x) = \\frac{1}{\\sqrt{2\\pi}\\, \\sigma_X} \\exp(-\\frac{(x - \\mu)^2}{2\\sigma_X^2})$。\n- 频率网格参数：$\\Delta u = 0.25$，$N_{\\mathrm{sig}} = 512$ (偶数)。\n- 频率网格定义：$u_k = u_{\\min} + k\\, \\Delta u$ 对于 $k=0,\\dots,N_{\\mathrm{sig}}-1$，其中 $u_{\\min} = -U_{\\max} = -\\Delta u \\cdot \\tfrac{N_{\\mathrm{sig}}}{2}$。\n- 采样特征函数：$f_k = \\varphi_{X_T}(u_k)$。\n- 补零：对于 $N_{\\mathrm{tot}} \\ge N_{\\mathrm{sig}}$，序列 $\\{f_k\\}_{k=0}^{N_{\\mathrm{sig}}-1}$ 通过设置 $f_k = 0$（对于 $k=N_{\\mathrm{sig}},\\dots,N_{\\mathrm{tot}}-1$）扩展到长度 $N_{\\mathrm{tot}}$。\n- 对数价格网格定义：$x_j = j\\, \\Delta x$，其中 $\\Delta x = \\frac{2\\pi}{N_{\\mathrm{tot}}\\, \\Delta u}$，对于 $j=0,1,\\dots,N_{\\mathrm{tot}}-1$。\n- DFT 逆变换公式：$\\widehat{p}(x_j) = \\frac{\\Delta u}{2\\pi}\\, e^{-i u_{\\min} x_j} \\sum_{k=0}^{N_{\\mathrm{tot}}-1} f_k\\, e^{-i 2\\pi \\frac{j k}{N_{\\mathrm{tot}}}}$。\n- 尾部定义：尾部区域由 $\\lvert x - \\mu \\rvert \\ge \\kappa \\sigma_X$ 定义，其中 $\\kappa = 3$。\n- 尾部误差度量：$E(N_{\\mathrm{tot}}) = \\Delta x \\sum_{\\{j: \\lvert x_j - \\mu \\rvert \\ge \\kappa \\sigma_X\\}} \\left| \\operatorname{Re}\\left(\\widehat{p}(x_j)\\right) - p_{\\mathrm{true}}(x_j) \\right|$。\n- 数值常量：$S_0 = 100$, $r = 0.02$, $q = 0.00$, $\\sigma = 0.20$, $T = 1.0$, $\\kappa = 3$。\n- 测试用例：$N_{\\mathrm{tot}} \\in \\{512, 1024, 4096, 16384\\}$。\n\n步骤 2：使用提取的已知条件进行验证\n根据验证标准检查问题陈述。\n- **科学依据**：该问题基于标准的 Black-Scholes 模型，并利用傅里叶变换从其特征函数中恢复概率密度函数。这在计算金融学和概率论中是一种成熟有效的技术。\n- **适定性**：所有必要的参数、方程和数值都已提供以执行计算。目标陈述清晰，且该过程对每个测试用例都能得出唯一的数值结果。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观或模棱两可的术语。\n\n未发现任何缺陷。该问题是完整的、一致的且科学上是合理的。\n\n步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n目标是为一组四个 $N_{\\mathrm{tot}}$ 值计算尾部误差 $E(N_{\\mathrm{tot}})$。这需要实现指定的数值方案，使用快速傅里叶变换 (FFT) 恢复概率密度函数，并将其与尾部区域已知的真实密度进行比较。研究了补零对该数值积分准确性的影响。\n\n步骤 1：模型参数计算\n首先，我们计算对数价格 $X_T$ 分布的常数参数。\n给定初始资产价格 $S_0 = 100$，无风险利率 $r = 0.02$，股息率 $q = 0.00$，波动率 $\\sigma = 0.20$ 以及到期时间 $T = 1.0$：\n对数价格 $X_T$ 的均值 $\\mu$ 为：\n$$ \\mu = \\ln(S_0) + (r - q - \\tfrac{1}{2}\\sigma^2)T = \\ln(100) \\approx 4.60517 $$\n对数价格 $X_T$ 的标准差 $\\sigma_X$ 为：\n$$ \\sigma_X = \\sigma\\sqrt{T} = 0.20\\sqrt{1.0} = 0.20 $$\n\n步骤 2：频域离散化\n连续特征函数 $\\varphi_{X_T}(u)$ 在频域中的离散均匀网格上进行采样。\n网格间距为 $\\Delta u = 0.25$，有 $N_{\\mathrm{sig}} = 512$ 个点。\n频率范围由 $U_{\\max} = \\Delta u \\cdot \\frac{N_{\\mathrm{sig}}}{2} = 0.25 \\cdot \\frac{512}{2} = 64$ 决定。\n网格以 $u_{\\min} = -U_{\\max} = -64$ 为中心。\n频率点为 $u_k = u_{\\min} + k\\, \\Delta u$，对于 $k = 0, \\dots, 511$。\n正态分布 $N(\\mu, \\sigma_X^2)$ 的特征函数在该网格上采样：\n$$ f_k = \\varphi_{X_T}(u_k) = \\exp\\left(i u_k \\mu - \\tfrac{1}{2}\\sigma_X^2 u_k^2\\right) $$\n此序列 $\\{f_k\\}_{k=0}^{511}$ 包含了重构密度函数的必要信息。\n\n步骤 3：补零与空间域离散化\n对于每个测试用例 $N_{\\mathrm{tot}}$，将序列 $\\{f_k\\}_{k=0}^{N_{\\mathrm{sig}}-1}$ 放入一个更长的、大小为 $N_{\\mathrm{tot}}$ 的数组中，并将附加的元素设置为零。这个过程称为补零，它并未从特征函数中添加新信息，而是用于在空间域中对所得的密度函数进行插值。补零信号的 DFT 会产生原始信号的连续傅里叶逆变换的更精细采样。\n空间网格间距 $\\Delta x$ 取决于 $N_{\\mathrm{tot}}$：\n$$ \\Delta x = \\frac{2\\pi}{N_{\\mathrm{tot}}\\, \\Delta u} $$\n随着 $N_{\\mathrm{tot}}$ 的增加，$\\Delta x$ 减小，从而为恢复的密度函数提供了更高分辨率的网格。问题陈述指定了空间网格点为：\n$$ x_j = j\\, \\Delta x, \\quad \\text{对于 } j=0,1,\\dots,N_{\\mathrm{tot}}-1 $$\n\n步骤 4：通过快速傅里叶变换 (FFT) 恢复密度\n傅里叶逆变换的离散近似由下式给出：\n$$ \\widehat{p}(x_j) = \\frac{\\Delta u}{2\\pi}\\, e^{-i u_{\\min} x_j} \\sum_{k=0}^{N_{\\mathrm{tot}}-1} f_k\\, e^{-i 2\\pi \\frac{j k}{N_{\\mathrm{tot}}}} $$\n求和项是补零序列 $\\{f_k\\}_{k=0}^{N_{\\mathrm{tot}}-1}$ 的离散傅里叶变换 (DFT)。我们使用 FFT 算法高效地计算它。项 $e^{-i u_{\\min} x_j}$ 是一个相位校正因子，它解释了频率网格偏离原点 $u=0$ 的情况。\n对于每个 $N_{\\mathrm{tot}}$ 的过程是：\n1. 构建特征函数采样的补零序列 $\\{f_k\\}_{k=0}^{N_{\\mathrm{tot}}-1}$。\n2. 计算其 FFT: $F_j = \\text{FFT}(\\{f_k\\})_j = \\sum_{k=0}^{N_{\\mathrm{tot}}-1} f_k\\, e^{-i 2\\pi \\frac{j k}{N_{\\mathrm{tot}}}}$。\n3. 构建空间网格 $\\{x_j\\}$。\n4. 应用缩放和相位校正：$\\widehat{p}(x_j) = \\frac{\\Delta u}{2\\pi}\\, e^{-i u_{\\min} x_j} F_j$。\n5. 由于真实密度是实数值，我们取结果的实部：$\\operatorname{Re}(\\widehat{p}(x_j))$。\n\n步骤 5：误差计算\n恢复密度的准确性通过分布尾部的 $L^1$-误差来衡量。尾部区域定义为 $|x - \\mu| \\ge \\kappa \\sigma_X$。当 $\\kappa = 3$ 且 $\\sigma_X = 0.2$ 时，这对应于 $|x - \\mu| \\ge 0.6$。\n对于网格上的每个点 $x_j$，我们使用正态概率密度函数公式计算真实密度 $p_{\\mathrm{true}}(x_j)$。\n尾部误差 $E(N_{\\mathrm{tot}})$ 计算为恢复密度与真实密度在落入已定义尾部区域的网格点上的绝对差的黎曼和：\n$$ E(N_{\\mathrm{tot}}) = \\Delta x \\sum_{\\{j: \\lvert x_j - \\mu \\rvert \\ge 0.6\\}} \\left| \\operatorname{Re}\\left(\\widehat{p}(x_j)\\right) - p_{\\mathrm{true}}(x_j) \\right| $$\n\n步骤 6：迭代与最终结果\n对测试套件 $N_{\\mathrm{tot}} \\in \\{512, 1024, 4096, 16384\\}$ 中的每个值重复步骤 3 到步骤 5 的整个过程。将得到的四个误差值 $E(512)$、$E(1024)$、$E(4096)$ 和 $E(16384)$ 收集起来，并以要求的格式呈现。计算在提供的 Python 程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the tail error of a recovered risk-neutral density\n    for different levels of zero-padding in an FFT-based inversion.\n    \"\"\"\n    #\n    # === Problem Parameters ===\n    #\n    S0 = 100.0       # Initial asset price\n    r = 0.02         # Risk-free rate\n    q = 0.00         # Dividend yield\n    sigma = 0.20     # Volatility\n    T = 1.0          # Time to maturity in years\n    \n    du = 0.25        # Frequency grid spacing\n    N_sig = 512      # Number of signal points in frequency domain\n    kappa = 3.0      # Tail threshold in standard deviations\n\n    # Test suite for total transform length\n    test_cases_N_tot = [512, 1024, 4096, 16384]\n\n    #\n    # === Step 1: Calculate Log-Price Distribution Parameters ===\n    #\n    mu = np.log(S0) + (r - q - 0.5 * sigma**2) * T\n    sigma_X = sigma * np.sqrt(T)\n\n    #\n    # === Step 2: Setup Frequency Grid and Sample Characteristic Function ===\n    #\n    # The characteristic function is sampled on a grid u_k.\n    # U_max defines the truncation of the Fourier integral.\n    U_max = du * N_sig / 2.0\n    u_min = -U_max\n    # Frequency grid u_k = u_min + k*du for k=0,...,N_sig-1\n    u_grid_sig = u_min + np.arange(N_sig) * du\n    \n    # Characteristic function of Normal(mu, sigma_X^2) distribution\n    # phi(u) = exp(i*u*mu - 0.5*sigma_X^2*u^2)\n    f_sig = np.exp(1j * u_grid_sig * mu - 0.5 * sigma_X**2 * u_grid_sig**2)\n\n    results = []\n    for N_tot in test_cases_N_tot:\n        #\n        # === Step 3: Zero-Padding and Spatial Domain Grid Setup ===\n        #\n        # Zero-pad the characteristic function samples. This interpolates\n        # the resulting density onto a finer spatial grid.\n        f_tot = np.zeros(N_tot, dtype=np.complex128)\n        f_tot[0:N_sig] = f_sig\n\n        # The spatial grid x_j is determined by N_tot and du.\n        # A larger N_tot (more zero-padding) leads to a smaller dx.\n        dx = (2 * np.pi) / (N_tot * du)\n        \n        # As per the problem statement, the grid is x_j = j*dx.\n        # This grid starts at 0 and is not centered.\n        x_grid = np.arange(N_tot) * dx\n\n        #\n        # === Step 4: Density Recovery via FFT ===\n        #\n        # The sum in the problem's formula is a DFT, computed via FFT.\n        fft_f = np.fft.fft(f_tot)\n\n        # Apply the phase correction and scaling factor from the formula.\n        # The phase term e^(-i*u_min*x_j) corrects for the frequency grid shift.\n        phase_correction = np.exp(-1j * u_min * x_grid)\n        p_hat = (du / (2 * np.pi)) * phase_correction * fft_f\n        \n        # The density must be real; numerical noise can create a small imag part.\n        p_hat_real = np.real(p_hat)\n\n        #\n        # === Step 5: Error Calculation ===\n        #\n        # Calculate the true normal density on the same grid for comparison.\n        p_true = norm.pdf(x_grid, loc=mu, scale=sigma_X)\n        \n        # Identify the indices corresponding to the tail regions.\n        # Tail region is where |x - mu| >= kappa * sigma_X.\n        tail_mask = np.abs(x_grid - mu) >= kappa * sigma_X\n\n        # Calculate the absolute error on the grid points in the tails.\n        abs_error_in_tails = np.abs(p_hat_real[tail_mask] - p_true[tail_mask])\n        \n        # Approximate the L1-error integral using a Riemann sum.\n        E_N_tot = dx * np.sum(abs_error_in_tails)\n        results.append(E_N_tot)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}