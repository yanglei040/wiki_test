{
    "hands_on_practices": [
        {
            "introduction": "直接在标的资产价格 $S$ 的均匀网格上对布莱克-斯科尔斯偏微分方程进行离散化，其效率并不高。此练习将指导您通过对数变换 $x = \\ln(S)$ 这一关键技巧，将原始方程转换为一个系数恒定的偏微分方程，这种形式更便于使用标准的有限差分法求解。这项实践旨在为您提供分析变换与数值离散化相结合的核心技能。",
            "id": "2393113",
            "problem": "考虑一个带有连续股息率的欧式或有债权的风险中性 Black-Scholes 偏微分方程 (PDE)，其形式为 $V_{t} + \\tfrac{1}{2}\\sigma^{2} S^{2} V_{SS} + (r - q) S V_{S} - r V = 0$，其中 $S \\in (0,\\infty)$ 且 $t \\in [0,T)$。令 $x = \\ln(S)$ 并定义 $u(x,t) = V(S,t)$，其中 $S = \\exp(x)$。从该 PDE 出发，仅使用链式法则和标准中心有限差分，执行以下步骤。\n\n1. 在变量替换 $x = \\ln(S)$ 下，推导 $u(x,t)$ 所满足的变换后的 PDE。然后引入到期时间变量 $\\tau = T - t$，使方程在 $\\tau$ 上是前向的，并将其改写为常系数形式 $u_{\\tau} = a\\,u_{xx} + b\\,u_{x} - r\\,u$，确定常数 $a$ 和 $b$（用 $\\sigma$、$r$ 和 $q$ 表示）。\n\n2. 考虑 $x$ 上的均匀空间网格 $x_{i} = x_{\\min} + i\\,\\Delta x$（$i$ 为整数）和 $\\tau$ 上的均匀时间网格 $\\tau^{n} = n\\,\\Delta t$（$n$ 为整数）。对 $u_{x}$ 和 $u_{xx}$ 使用中心差分，并对 $\\tau$ 上的 PDE 使用 Crank-Nicolson (CN) 时间离散化，写出在内部节点 $i$ 和时间层 $n+1$ 处的完全离散格式，其标准三对角形式为 $A\\,u_{i-1}^{n+1} + B\\,u_{i}^{n+1} + C\\,u_{i+1}^{n+1} = \\text{RHS}$，其中 $A$、$B$ 和 $C$ 分别是乘以节点 $i-1$、$i$ 和 $i+1$ 处 $u^{n+1}$ 的左侧系数。\n\n您的任务是给出内部对角系数 $B$ 作为 $\\sigma$、$r$、$\\Delta x$ 和 $\\Delta t$ 的函数的闭式解析表达式。将您的最终答案表示为单个解析表达式。无需进行数值计算，也无需四舍五入。",
            "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n**问题验证**\n\n**第 1 步：提取已知条件**\n-   控制偏微分方程 (PDE) 是风险中性 Black-Scholes 方程：$V_{t} + \\tfrac{1}{2}\\sigma^{2} S^{2} V_{SS} + (r - q) S V_{S} - r V = 0$。\n-   定义域为 $S \\in (0,\\infty)$ 且 $t \\in [0,T)$。\n-   定义了变量替换：$x = \\ln(S)$ 且 $u(x,t) = V(S,t)$，意味着 $S = \\exp(x)$。\n-   引入了第二个时间变量：$\\tau = T - t$。\n-   变换后的 PDE 的目标形式被指定为 $u_{\\tau} = a\\,u_{xx} + b\\,u_{x} - r\\,u$。\n-   定义了均匀网格：$x_{i} = x_{\\min} + i\\,\\Delta x$ 和 $\\tau^{n} = n\\,\\Delta t$。\n-   离散化方法被指定为 Crank-Nicolson 格式，其中空间导数使用中心差分。\n-   得到的离散方程必须为 $A\\,u_{i-1}^{n+1} + B\\,u_{i}^{n+1} + C\\,u_{i+1}^{n+1} = \\text{RHS}$ 的形式。\n-   目标是求出系数 $B$ 的解析表达式。\n\n**第 2 步：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于 Black-Scholes 方程，这是金融数学中的一个基本模型。该 PDE 的变换及其使用有限差分法的数值解是计算金融学中标准、成熟的技术。该问题在科学和数学上都是合理的。\n-   **适定性**：问题陈述清晰，提供了从初始 PDE 推导到最终离散系数所需的所有必要信息。任务按顺序和逻辑指定，从而可以得出一个唯一的、有意义的答案。\n-   **客观性**：该问题使用精确的数学语言表述，没有任何主观或模棱两可的术语。\n\n**第 3 步：结论与行动**\n问题是有效的。这是偏微分方程数值分析在金融领域应用中的一个标准练习。我们现在开始进行解答。\n\n**解的推导**\n\n求解过程需要两个主要步骤：首先，变换 PDE；其次，对其进行离散化以求出指定的系数。\n\n**第 1 部分：PDE 的变换**\n\n我们从或有债权价值 $V(S,t)$ 的 Black-Scholes 方程开始：\n$$V_{t} + \\frac{1}{2}\\sigma^{2} S^{2} V_{SS} + (r - q) S V_{S} - r V = 0$$\n我们引入变量替换 $x = \\ln(S)$ 并定义 $u(x,t) = V(S,t)$。我们使用链式法则将 $V$ 关于 $S$ 和 $t$ 的导数用 $u$ 关于 $x$ 和 $t$ 的导数来表示。\n\n首先，我们求关于 $S$ 的偏导数：\n$$V_{S} = \\frac{\\partial V}{\\partial S} = \\frac{\\partial u}{\\partial x} \\frac{\\partial x}{\\partial S} = u_{x} \\frac{1}{S}$$\n$$V_{SS} = \\frac{\\partial}{\\partial S} \\left( u_{x} \\frac{1}{S} \\right) = \\left( \\frac{\\partial u_{x}}{\\partial S} \\right) \\frac{1}{S} - u_{x} \\frac{1}{S^{2}} = \\left( \\frac{\\partial u_{x}}{\\partial x} \\frac{\\partial x}{\\partial S} \\right) \\frac{1}{S} - \\frac{u_{x}}{S^{2}} = \\left( u_{xx} \\frac{1}{S} \\right) \\frac{1}{S} - \\frac{u_{x}}{S^{2}} = \\frac{1}{S^{2}} (u_{xx} - u_{x})$$\n关于 $t$ 的导数是直接的，因为 $x$ 不依赖于 $t$：\n$$V_{t} = \\frac{\\partial V}{\\partial t} = \\frac{\\partial u}{\\partial t} = u_{t}$$\n将这些代入 Black-Scholes PDE 得到：\n$$u_{t} + \\frac{1}{2}\\sigma^{2} S^{2} \\left[ \\frac{1}{S^{2}} (u_{xx} - u_{x}) \\right] + (r - q) S \\left[ u_{x} \\frac{1}{S} \\right] - r u = 0$$\n通过消去项来简化此表达式：\n$$u_{t} + \\frac{1}{2}\\sigma^{2} (u_{xx} - u_{x}) + (r - q) u_{x} - r u = 0$$\n按 $u$ 关于 $x$ 的导数阶数对各项进行分组：\n$$u_{t} + \\frac{1}{2}\\sigma^{2} u_{xx} + \\left( r - q - \\frac{1}{2}\\sigma^{2} \\right) u_{x} - r u = 0$$\n接下来，我们引入到期时间变量 $\\tau = T - t$。这意味着 $t = T - \\tau$，因此 $\\frac{\\partial}{\\partial t} = \\frac{\\partial \\tau}{\\partial t} \\frac{\\partial}{\\partial \\tau} = -1 \\cdot \\frac{\\partial}{\\partial \\tau}$。所以，$u_{t} = -u_{\\tau}$。\n将此代入变换后的 PDE：\n$$-u_{\\tau} + \\frac{1}{2}\\sigma^{2} u_{xx} + \\left( r - q - \\frac{1}{2}\\sigma^{2} \\right) u_{x} - r u = 0$$\n重新整理以解出 $u_{\\tau}$，我们得到 $\\tau$ 上的前向方程：\n$$u_{\\tau} = \\frac{1}{2}\\sigma^{2} u_{xx} + \\left( r - q - \\frac{1}{2}\\sigma^{2} \\right) u_{x} - r u$$\n将此与指定形式 $u_{\\tau} = a\\,u_{xx} + b\\,u_{x} - r\\,u$ 进行比较，我们确定常系数为：\n$$a = \\frac{1}{2}\\sigma^{2}$$\n$$b = r - q - \\frac{1}{2}\\sigma^{2}$$\n\n**第 2 部分：Crank-Nicolson 离散化**\n\n我们现在对 PDE $u_{\\tau} = a\\,u_{xx} + b\\,u_{x} - r\\,u$ 进行离散化。令 $u_{i}^{n}$ 表示 $u(x_{i}, \\tau^{n})$ 的数值近似。Crank-Nicolson 方法是一种隐式格式，它对时间层 $n$ 和 $n+1$ 上的空间算子取平均：\n$$\\frac{u_{i}^{n+1} - u_{i}^{n}}{\\Delta t} = \\frac{1}{2} \\left[ \\left( a\\,u_{xx} + b\\,u_{x} - r\\,u \\right)_{i}^{n+1} + \\left( a\\,u_{xx} + b\\,u_{x} - r\\,u \\right)_{i}^{n} \\right]$$\n我们对空间导数 $u_{x}$ 和 $u_{xx}$ 使用标准的二阶中心差分近似：\n$$u_{x} \\approx \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}$$\n$$u_{xx} \\approx \\frac{u_{i+1} - 2u_{i} + u_{i-1}}{(\\Delta x)^{2}}$$\n将这些代入 Crank-Nicolson 公式，并重新排序，将时间层 $n+1$ 的项组合在左侧 (LHS)，将时间层 $n$ 的项组合在右侧 (RHS)：\n$$u_{i}^{n+1} - \\frac{\\Delta t}{2} \\left[ a \\frac{u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^{2}} + b \\frac{u_{i+1}^{n+1} - u_{i-1}^{n+1}}{2\\,\\Delta x} - r u_{i}^{n+1} \\right] = \\text{RHS}$$\n我们只关心左侧的系数。让我们将左侧整理成 $A\\,u_{i-1}^{n+1} + B\\,u_{i}^{n+1} + C\\,u_{i+1}^{n+1}$ 的形式。我们收集每个节点值 $u_{j}^{n+1}$ 的系数：\n\n-   对于 $u_{i-1}^{n+1}$：系数为 $A = -\\frac{\\Delta t}{2} \\left( \\frac{a}{(\\Delta x)^{2}} - \\frac{b}{2\\,\\Delta x} \\right)$。\n-   对于 $u_{i+1}^{n+1}$：系数为 $C = -\\frac{\\Delta t}{2} \\left( \\frac{a}{(\\Delta x)^{2}} + \\frac{b}{2\\,\\Delta x} \\right)$。\n-   对于 $u_{i}^{n+1}$：系数从乘以 $u_{i}^{n+1}$ 的项中获得。\n    $$B = 1 - \\frac{\\Delta t}{2} \\left( a \\frac{-2}{(\\Delta x)^{2}} - r \\right) = 1 + \\frac{\\Delta t}{2} \\left( \\frac{2a}{(\\Delta x)^{2}} + r \\right)$$\n\n问题要求给出内部对角系数 $B$ 的闭式表达式。简化 $B$ 的表达式：\n$$B = 1 + \\frac{a\\,\\Delta t}{(\\Delta x)^{2}} + \\frac{r\\,\\Delta t}{2}$$\n最后，我们代入在第 1 部分中推导出的 $a = \\frac{1}{2}\\sigma^{2}$ 的表达式：\n$$B = 1 + \\frac{(\\frac{1}{2}\\sigma^{2})\\,\\Delta t}{(\\Delta x)^{2}} + \\frac{r\\,\\Delta t}{2}$$\n这可以简化为：\n$$B = 1 + \\frac{\\sigma^{2}\\,\\Delta t}{2(\\Delta x)^{2}} + \\frac{r\\,\\Delta t}{2}$$\n通过提出公因子 $\\frac{\\Delta t}{2}$，这可以写得更紧凑：\n$$B = 1 + \\frac{\\Delta t}{2} \\left( \\frac{\\sigma^{2}}{(\\Delta x)^{2}} + r \\right)$$\n这就是系数 $B$ 作为给定参数 $\\sigma$、$r$、$\\Delta x$ 和 $\\Delta t$ 的函数的最终表达式。请注意，系数 $B$ 与股息率 $q$ 无关，$q$ 只影响平流项，因此只影响非对角系数 $A$ 和 $C$。",
            "answer": "$$\\boxed{1 + \\frac{\\Delta t}{2} \\left( \\frac{\\sigma^{2}}{(\\Delta x)^{2}} + r \\right)}$$"
        },
        {
            "introduction": "在金融实践中，仅仅计算出期权价格通常只是第一步；风险管理还需要理解其价格敏感性指标，即“希腊字母”。本练习将向您展示如何利用有限差分法得到的数值价格网格，直接计算最重要的希腊字母之一——伽马（Gamma, $\\Gamma$）。这个过程不仅将数值解与关键金融指标联系起来，也引入了通过与解析公式对比来验证数值结果准确性的重要思想。",
            "id": "2393056",
            "problem": "考虑一个关于欧式看涨期权价值 $V(S,t)$ 的 Black-Scholes 偏微分方程，该期权的标的资产不支付股息，当前价格为 $S$，执行价格为 $K$，无风险利率为 $r$，波动率为 $\\sigma$，到期日为 $T$：\n$$\n\\frac{\\partial V}{\\partial t}(S,t) + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}(S,t) + r S \\frac{\\partial V}{\\partial S}(S,t) - r V(S,t) = 0,\n$$\n该方程定义在 $(S,t) \\in [0,S_{\\max}] \\times [0,T]$ 上，带有终值条件\n$$\nV(S,T) = \\max(S - K, 0),\n$$\n以及边界条件\n$$\nV(0,t) = 0 \\quad \\text{和} \\quad V(S_{\\max},t) = S_{\\max} - K e^{-r (T - t)}, \\quad \\text{对于 } t \\in [0,T].\n$$\n\n您的任务是在间距为 $\\Delta S$ 的均匀空间网格和间距为 $\\Delta t$ 的均匀时间网格上计算数值价格网格 $V(S_i, t_n)$。然后，在时间 $t=0$ 时，通过在空间网格上使用二阶中心差分对价格网格进行差分，计算期权在 $S=K$ 处的 Gamma 值：\n$$\n\\Gamma_{\\text{num}}(K,0) \\approx \\frac{V(K+\\Delta S,0) - 2 V(K,0) + V(K-\\Delta S,0)}{(\\Delta S)^2}.\n$$\n将此数值 Gamma 与欧式看涨期权的解析 Black-Scholes Gamma 进行比较：\n$$\n\\Gamma_{\\text{BS}}(S,t) = \\frac{\\phi(d_1)}{S \\sigma \\sqrt{T-t}}, \\quad \\text{其中} \\quad d_1 = \\frac{\\ln\\!\\left(\\frac{S}{K}\\right) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right)(T-t)}{\\sigma \\sqrt{T-t}},\n$$\n其中 $\\phi(x) = \\frac{1}{\\sqrt{2\\pi}} e^{-x^2/2}$ 是标准正态概率密度函数。计算绝对误差\n$$\nE = \\left|\\Gamma_{\\text{num}}(K,0) - \\Gamma_{\\text{BS}}(K,0)\\right|.\n$$\n\n使用以下参数值：$r = 0.05$，$\\sigma = 0.2$，$K = 100$，$T = 1$ 以及 $S_{\\max} = 400$。假设 $S$ 上的均匀网格有 $N_S$ 个区间，因此 $\\Delta S = S_{\\max}/N_S$，$t$ 上的均匀网格有 $N_t$ 个步长，因此 $\\Delta t = T/N_t$。空间网格必须精确包含 $S=K$（即，$K/\\Delta S$ 是一个整数）。\n\n实现您的程序，为以下六个测试用例 $(N_S, N_t)$ 计算 $E$：\n\n- 在小 $\\Delta t$ 下进行空间细化：\n  1. $(N_S, N_t) = (100, 1600)$,\n  2. $(N_S, N_t) = (200, 1600)$,\n  3. $(N_S, N_t) = (400, 1600)$.\n\n- 在精细空间下进行时间细化：\n  4. $(N_S, N_t) = (400, 50)$,\n  5. $(N_S, N_t) = (400, 100)$,\n  6. $(N_S, N_t) = (400, 200)$.\n\n您的程序必须按照上面列出的顺序，返回与六个测试用例相对应的六个绝对误差 $E$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。",
            "solution": "用户提供了一个来自计算金融领域的有效且适定的问题陈述。它具有科学依据，并包含进行求解所需的所有必要信息。\n\n该问题要求对欧式看涨期权的布莱克-斯科尔斯偏微分方程（PDE）进行数值求解。该PDE由以下公式给出：\n$$\n\\frac{\\partial V}{\\partial t}(S,t) + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}(S,t) + r S \\frac{\\partial V}{\\partial S}(S,t) - r V(S,t) = 0\n$$\n其中 $V(S,t)$ 是期权价格，$S$ 是标的资产价格，$t$ 是时间，$r$ 是无风险利率，$\\sigma$ 是波动率。该方程定义在域 $(S,t) \\in [0, S_{\\max}] \\times [0, T]$ 上，在时间 $T$ 有一个终值条件 $V(S,T) = \\max(S-K, 0)$，以及边界条件 $V(0,t)=0$ 和 $V(S_{\\max},t) = S_{\\max} - Ke^{-r(T-t)}$。\n\n这是一个终值问题，通常通过从 $t=T$ 到 $t=0$ 的时间逆向步进法来求解。为了便于使用标准的正向时间数值方法，我们引入时间变量替换：$\\tau = T - t$。通过此替换，$\\frac{\\partial}{\\partial t} = -\\frac{\\partial}{\\partial \\tau}$，PDE 变换为一个初值问题：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V, \\quad \\text{对于 } \\tau \\in [0,T]\n$$\n在 $\\tau=0$ 时的初始条件为 $V(S,0) = \\max(S-K, 0)$。边界条件变为 $V(0,\\tau) = 0$ 和 $V(S_{\\max},\\tau) = S_{\\max} - Ke^{-r\\tau}$。\n\n我们在一个具有 $N_S+1$ 个空间点 $S_i = i\\Delta S$（其中 $i=0, \\dots, N_S$）和 $N_t+1$ 个时间点 $\\tau_n = n\\Delta t$（其中 $n=0, \\dots, N_t$）的均匀网格上离散化此 PDE。令 $V_i^n$ 表示 $V(S_i, \\tau_n)$ 的数值近似值。我们采用 Crank-Nicolson 方法，该方法在时间和空间上都是无条件稳定且二阶精确的。该格式通过对时间步 $n$ 和 $n+1$ 处的空间算子进行平均来构建：\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta t} = \\frac{1}{2} \\left( (\\mathcal{L}_h V^{n+1})_i + (\\mathcal{L}_h V^n)_i \\right)\n$$\n其中 $\\mathcal{L}_h$ 是离散化的空间算子。使用二阶中心差分来处理空间导数，我们可以重新排列方程，将未知值 $V_i^{n+1}$ 隔离在左侧，将已知值 $V_i^n$ 放在右侧。对于每个内部空间点 $i=1, \\dots, N_S-1$，可得到以下方程：\n$$\n-l_i V_{i-1}^{n+1} + d_i V_i^{n+1} - u_i V_{i+1}^{n+1} = l_i V_{i-1}^n + (2-d_i) V_i^n + u_i V_{i+1}^n\n$$\n其中系数定义为：\n$$\nl_i = \\frac{\\Delta t}{4} (\\sigma^2 i^2 - ri), \\quad d_i = 1 + \\frac{\\Delta t}{2} (\\sigma^2 i^2 + r), \\quad u_i = \\frac{\\Delta t}{4} (\\sigma^2 i^2 + ri)\n$$\n这构成了一个关于未知期权价格向量 $\\mathbf{V}^{n+1} = [V_1^{n+1}, \\dots, V_{N_S-1}^{n+1}]^T$ 在每个时间步的三对角线性方程组 $A \\mathbf{V}^{n+1} = \\mathbf{b}^n$。矩阵 $A$ 不随时间变化，其对角线由系数 $-l_i$、$d_i$ 和 $-u_i$ 构成。右侧向量 $\\mathbf{b}^n$ 取决于前一个时间步的已知值 $\\mathbf{V}^n$。通过修改第一个（$i=1$）和最后一个（$i=N_S-1$）内部点的方程来并入边界条件。条件 $V_0^n=0$ 简化了第一个方程。对于最后一个方程，已知的边界值 $V_{N_S}^{n+1} = S_{\\max} - K e^{-r\\tau_{n+1}}$ 被移到右侧，从而调整了向量 $\\mathbf{b}^n$ 的最后一个元素。\n\n求解过程从 $\\tau=0$（$t=T$）处的已知终值收益开始。然后，我们从 $n=0$ 到 $n=N_t-1$ 为每个时间步迭代求解三对角系统，在 $\\tau$ 方向上向前推进解，直到达到 $\\tau=T$（$t=0$）。\n\n在时间 $t=0$ 获得期权价格网格 $V(S_i, 0)$ 后，我们计算 $S=K$ 处的数值 Gamma，$\\Gamma_{\\text{num}}$。问题陈述保证了 $S=K$ 是一个网格点，$S_{k_{\\text{idx}}}=K$。我们使用二阶中心差分公式：\n$$\n\\Gamma_{\\text{num}}(K,0) = \\frac{V_{k_{\\text{idx}}+1}^0 - 2V_{k_{\\text{idx}}}^0 + V_{k_{\\text{idx}}-1}^0}{(\\Delta S)^2}\n$$\n将此数值结果与 $S=K$ 和 $t=0$ 时的解析布莱克-斯科尔斯 Gamma, $\\Gamma_{\\text{BS}}$ 进行比较：\n$$\n\\Gamma_{\\text{BS}}(K,0) = \\frac{\\phi(d_1)}{K \\sigma \\sqrt{T}}, \\quad \\text{其中} \\quad d_1 = \\frac{(r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n其中 $\\phi(x)$ 是标准正态概率密度函数。然后为每个指定的测试用例计算绝对误差 $E = |\\Gamma_{\\text{num}} - \\Gamma_{\\text{BS}}|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between numerical and analytical Gamma of a European call option\n    for six different grid configurations using a Crank-Nicolson finite difference method.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Ns, Nt)\n        (100, 1600),\n        (200, 1600),\n        (400, 1600),\n        (400, 50),\n        (400, 100),\n        (400, 200),\n    ]\n\n    r = 0.05\n    sigma = 0.2\n    K = 100.0\n    T = 1.0\n    S_max = 400.0\n\n    results = []\n    \n    # --- Analytical Gamma Calculation (constant for all cases) ---\n    d1_analytical = (np.log(K / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    phi_d1 = norm.pdf(d1_analytical)\n    analytical_gamma = phi_d1 / (K * sigma * np.sqrt(T))\n\n    for Ns, Nt in test_cases:\n        # --- Grid and Parameter Setup ---\n        dS = S_max / Ns\n        dt = T / Nt\n        S = np.linspace(0, S_max, Ns + 1)\n\n        # --- Terminal Condition (at t=T, which is tau=0) ---\n        V = np.maximum(S - K, 0)\n        \n        # --- Crank-Nicolson Finite Difference Method Setup ---\n        # We solve forward in tau = T-t\n        \n        # Coefficients for the tridiagonal systems\n        # Vector i for all interior points\n        i = np.arange(1, Ns)\n        l_coeff = 0.25 * dt * (sigma**2 * i**2 - r * i)\n        d_coeff = 1 + 0.5 * dt * (sigma**2 * i**2 + r)\n        u_coeff = 0.25 * dt * (sigma**2 * i**2 + r * i)\n\n        # LHS matrix A does not change over time, so we pre-assemble it\n        # in the format required by scipy.linalg.solve_banded\n        # For l=1, u=1: ab[0,:]=upper, ab[1,:]=main, ab[2,:]=lower\n        A = np.zeros((3, Ns - 1))\n        A[0, 1:] = -u_coeff[:-1]  # Upper diagonal\n        A[1, :] = d_coeff         # Main diagonal\n        A[2, :-1] = -l_coeff[1:]  # Lower diagonal\n\n        # --- Time-stepping Loop (from tau=dt to tau=T) ---\n        # Corresponds to stepping from t=T-dt down to t=0\n        for n in range(1, Nt + 1):\n            tau_n = n * dt\n            \n            # Construct the RHS vector b from known values V at the previous time step\n            b = l_coeff * V[:-2] + (2 - d_coeff) * V[1:-1] + u_coeff * V[2:]\n            \n            # Apply boundary condition at S=S_max for the current time step\n            # The equation for i=Ns-1 is modified\n            # -l * V_{Ns-2} + d * V_{Ns-1} - u * V_{Ns} = ...\n            # The V_{Ns} term is known and moves to the RHS.\n            v_boundary_n = S_max - K * np.exp(-r * tau_n)\n            b[-1] += u_coeff[-1] * v_boundary_n\n\n            # Solve the tridiagonal system A * V_interior_new = b\n            V_interior_new = solve_banded((1, 1), A, b)\n            \n            # Update the solution vector V for the current time step\n            V[1:-1] = V_interior_new\n            V[0] = 0.0  # V(0, t) = 0 boundary condition\n            V[-1] = v_boundary_n # V(S_max, t) boundary condition\n        \n        # --- At this point, V contains option prices at t=0 (tau=T) ---\n\n        # --- Numerical Gamma Calculation ---\n        # S=K must be on the grid\n        k_idx = int(round(K / dS))\n        \n        v_minus = V[k_idx - 1]\n        v_zero = V[k_idx]\n        v_plus = V[k_idx + 1]\n        \n        numerical_gamma = (v_plus - 2 * v_zero + v_minus) / (dS**2)\n\n        # --- Error Calculation ---\n        error = abs(numerical_gamma - analytical_gamma)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.12f}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从欧式期权转向美式期权会带来巨大挑战，因为允许提前行权引入了“自由边界”问题。此外，到期时非光滑的收益函数在使用某些数值格式（如Crank-Nicolson）时可能引发数值振荡。这项高级练习将探讨如何处理提前行权约束，并介绍一种名为“Rannacher平滑”的强大技术，以确保解的稳定性和准确性。",
            "id": "2393097",
            "problem": "考虑在 Black-Scholes 模型下对美式看跌期权进行定价。设期权价格为 $V(S,t)$，其中标的资产价格 $S \\ge 0$，时间 $t \\in [0,T]$，行权价 $K > 0$，无风险利率 $r \\ge 0$，波动率 $\\sigma > 0$。欧式期权的 Black-Scholes 偏微分方程 (PDE) 由 $V(S,t)$ 满足以下条件给出\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其终端条件为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n对于美式看跌期权，允许提前行权，其价格满足以下线性互补系统：\n$$\n\\begin{cases}\nV(S,t) \\ge \\max(K-S,0), \\\\\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V \\le 0, \\\\\n\\left(V(S,t) - \\max(K-S,0)\\right)\\left(\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\\right) = 0,\n\\end{cases}\n$$\n并附带适用于美式看跌期权的边界条件：$V(0,t) = K$ 以及对于足够大的 $S_{\\max}$ 有 $V(S_{\\max}, t) \\approx 0$，以及终端条件 $V(S,T) = \\max(K-S,0)$。\n\n您将在一个均匀空间网格 $S_j = j \\Delta S$（其中 $j = 0,1,\\dots,N$，$ \\Delta S = S_{\\max}/N$）和均匀时间步 $t_n = n \\Delta t$（其中 $n=0,1,\\dots,M$，$ \\Delta t = T/M$）上实现两种时间步进格式，从时间 $t_M = T$ 向后推至 $t_{M-1} = T - \\Delta t$：\n- 一种 Crank–Nicolson 格式，在空间上使用中心差分，在时间上使用梯形法则。\n- 一种 Rannacher 平滑变体，在执行任何进一步的 Crank–Nicolson 步骤之前，将第一个 Crank–Nicolson 步骤替换为两个大小各为 $\\Delta t/2$ 的向后欧拉半步（对于本任务，您仅需这两个半步即可达到 $t_{M-1}$）。\n\n对于美式期权提前行权的约束，在每个时间步通过求解相应的线性互补问题来强制执行不等式 $V(S,t) \\ge \\max(K-S,0)$。该问题通过在您的离散化所产生的三对角有限差分系统上使用投影迭代法（如投影逐次超松弛法 (PSOR)）来求解。在内部点上使用中心有限差分计算空间导数，使用标准 Dirichlet 边界条件 $V(0,t) = K$ 和 $V(S_{\\max},t) = 0$，并确保您的线性系统能反映这些边界值。\n\n将给定时间层上网格的离散凸性度量定义为二阶中心差分为负的索引 $j \\in \\{1,2,\\dots,N-1\\}$ 的数量，即满足以下条件的索引数量：\n$$\nV_{j+1} - 2 V_j + V_{j-1} < 0,\n$$\n其中 $V_j$ 表示在所关注的时间层上对 $V(S_j, \\cdot)$ 的数值近似。对于一个关于 $S$ 的凸函数，此离散凸性应为非负，违例则表示存在振荡。为了量化 Rannacher 平滑在抑制由支付函数引起的振荡方面的效果，请比较在时间层 $t = T - \\Delta t$ 处以下两种方法产生的凸性违例数量：\n- 从 $t = T$ 开始向后执行一个步长为 $\\Delta t$ 的 Crank–Nicolson 单步。\n- 从 $t = T$ 开始向后执行两个步长各为 $\\Delta t/2$ 的向后欧拉半步，到达 $t = T - \\Delta t$（Rannacher 平滑）。\n\n您的程序必须：\n- 根据上述描述从第一性原理构建有限差分格式，空间上仅使用中心差分，时间步进仅使用指定的选择。\n- 在所需的时间层上使用投影迭代法求解美式期权线性互补问题，以确保在每个网格点上都满足不等式约束。\n- 对每个测试用例，计算一个等于以下公式的整数：\n$$\n\\text{diff} = \\left(\\text{未使用平滑时在 } t = T - \\Delta t \\text{ 处的凸性违例数}\\right) - \\left(\\text{使用 Rannacher 平滑时在 } t = T - \\Delta t \\text{ 处的数量}\\right)。\n$$\n一个正的 $\\text{diff}$ 值表明，相对于普通的 Crank–Nicolson 步骤，Rannacher 平滑减少了振荡。\n\n使用以下参数集测试套件，其中每个元组为 $(K, r, \\sigma, T, S_{\\max}, N, M)$：\n- 测试 1：$(100, 0.05, 0.2, 0.25, 400, 120, 10)$\n- 测试 2：$(100, 0.03, 0.3, 0.5, 400, 80, 8)$\n- 测试 3：$(50, 0.1, 0.4, 1.0, 200, 100, 10)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试顺序排列结果，例如 $[d_1,d_2,d_3]$，其中每个 $d_i$ 是测试 $i$ 的整数 $\\text{diff}$ 值。输出中不需要物理单位。数值答案类型必须是整数。计算应仅使用给定的参数值，不需要用户输入。",
            "solution": "所提出的问题是计算金融学中一个标准的、适定的问题，涉及美式看跌期权的定价和数值格式的分析。它在科学上以 Black-Scholes 框架为基础，在数学上是合理的。所有参数、边界条件和目标都得到了清晰、客观的定义。该问题是完整的且内部一致的。因此，该问题被认为是**有效**的，并将提供一个解决方案。\n\n问题的核心是求解美式看跌期权的 Black-Scholes 线性互补问题，并比较两种有限差分格式的数值稳定性。我们被特别要求量化在使用标准 Crank-Nicolson 格式时，由到期时的非光滑支付函数可能引起的伪振荡，并衡量 Rannacher 平滑的抑制效果。\n\n首先，我们将连续的 Black-Scholes 偏微分方程 (PDE) 转换为一个离散方程组。设 $V(S,t)$ 为期权价格。我们将资产价格 $S$ 和时间 $t$ 的域离散化为一个网格。空间网格为 $S_j = j \\Delta S$，其中 $j=0, 1, \\dots, N$，$\\Delta S = S_{\\max}/N$。时间网格为 $t_n = n \\Delta t$，其中 $n=0, 1, \\dots, M$，$\\Delta t = T/M$。我们通过从到期日 $t_M=T$ 向时间 $t_0=0$ 回溯来求解该问题。\n\nBlack-Scholes 算子 $\\mathcal{L}V = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V$ 中的空间导数，在内部网格点 $j=1, \\dots, N-1$ 上使用二阶中心差分进行近似：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - V_{j-1}}{2 \\Delta S}\n$$\n$$\n\\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - 2V_j + V_{j-1}}{(\\Delta S)^2}\n$$\n其中 $V_j(t)$ 是 $V(S_j, t)$ 的近似值。将这些近似代入算子 $\\mathcal{L}$，得到一个离散算子，可以由一个大小为 $(N-1) \\times (N-1)$ 的三对角矩阵 $A$ 表示。该矩阵作用于内部期权价格向量 $\\mathbf{V} = [V_1, \\dots, V_{N-1}]^T$ 上。系数为：\n$$\n\\alpha_j = \\frac{1}{2}\\sigma^2 j^2 - \\frac{1}{2}r j, \\quad \\beta_j = -\\sigma^2 j^2 - r, \\quad \\gamma_j = \\frac{1}{2}\\sigma^2 j^2 + \\frac{1}{2}r j\n$$\n其中 $j=1, \\dots, N-1$。\n\nDirichlet 边界条件 $V(0,t) = K$ 和 $V(S_{\\max},t) = 0$ 被并入该系统。涉及 $V_0=K$ 的项会影响 $j=1$ 的方程，引入一个仿射项。涉及 $V_N=0$ 的项在 $j=N-1$ 时消失。\n\n时间导数使用 $\\theta$-格式进行离散化，该格式可用于表示 Crank-Nicolson 和向后欧拉方法。从时间层 $n$ 推进到 $n-1$，PDE $\\frac{\\partial V}{\\partial t} + \\mathcal{L}V = 0$ 变为：\n$$\n\\frac{\\mathbf{V}^n - \\mathbf{V}^{n-1}}{\\Delta t} + (1-\\theta) (A\\mathbf{V}^n + \\mathbf{c}_b) + \\theta (A\\mathbf{V}^{n-1} + \\mathbf{c}_b) = 0\n$$\n其中 $\\mathbf{V}^n$ 是时间 $t_n$ 的价格向量，$A$ 是表示离散空间算子的矩阵，$\\mathbf{c}_b$ 是边界条件项的向量。对未知量 $\\mathbf{V}^{n-1}$ 进行整理，得到一个线性系统：\n$$\n(I - \\theta \\Delta t A) \\mathbf{V}^{n-1} = (I + (1-\\theta) \\Delta t A) \\mathbf{V}^n - \\Delta t \\mathbf{c}_b\n$$\n- 对于 **Crank-Nicolson** 格式，$\\theta = 1/2$。\n- 对于 **向后欧拉** 格式，$\\theta = 1$。\n\n对于美式期权，我们必须强制执行提前行权约束 $V(S,t) \\ge g(S)$，其中 $g(S) = \\max(K-S, 0)$。在每个时间步，这将线性系统转化为一个线性互补问题 (LCP)，我们使用指定的**投影逐次超松弛法 (PSOR)** 来求解。对于一个带有约束 $\\mathbf{v} \\ge \\mathbf{g}$ 的系统 $M\\mathbf{v} = \\mathbf{b}$，PSOR 迭代按如下方式更新每个分量 $v_i$：\n$$\nv_i^{(k+1)} = \\max\\left(g_i, \\ v_i^{(k)} + \\frac{\\omega}{M_{ii}}\\left(b_i - \\sum_{j",
            "answer": "```python\nimport numpy as np\n\ndef solve_lcp_psor(A, b, g, v_initial, omega, tol, max_iter):\n    \"\"\"\n    Solves the linear complementarity problem corresponding to the implicit\n    time-stepping of the American option PDE using Projected Successive\n    Over-Relaxation (PSOR).\n\n    The problem is to find v such that:\n    v >= g\n    A*v - b >= 0\n    (v - g) * (A*v - b) = 0\n\n    Args:\n        A (np.ndarray): The system matrix (LHS).\n        b (np.ndarray): The system vector (RHS).\n        g (np.ndarray): The exercise payoff vector (the constraint).\n        v_initial (np.ndarray): The initial guess for the solution v.\n        omega (float): The relaxation parameter for SOR.\n        tol (float): The convergence tolerance.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        np.ndarray: The solution vector v.\n    \"\"\"\n    v = v_initial.copy()\n    n = len(v)\n    for k in range(max_iter):\n        v_old = v.copy()\n        max_abs_diff = 0.0\n        for i in range(n):\n            # Sum over components already updated in this iteration (j  i)\n            s1 = np.dot(A[i, :i], v[:i])\n            # Sum over components from the previous iteration (j > i)\n            s2 = np.dot(A[i, i+1:], v_old[i+1:])\n            \n            # Standard SOR update value before projection\n            # This is equivalent to (1-omega)*v_old[i] + omega*(Gauss-Seidel update)\n            sor_val = v_old[i] + omega * ((b[i] - s1 - s2) / A[i, i] - v_old[i])\n\n            # Projection step to enforce the early exercise constraint\n            new_vi = max(g[i], sor_val)\n            \n            max_abs_diff = max(max_abs_diff, abs(new_vi - v_old[i]))\n            v[i] = new_vi\n        \n        if max_abs_diff  tol:\n            break\n            \n    return v\n\ndef count_convexity_violations(V_interior, K, N):\n    \"\"\"\n    Counts the number of indices j in {1, ..., N-1} where the discrete\n    second spatial derivative of the option price is negative.\n\n    Args:\n        V_interior (np.ndarray): Vector of option prices at interior points V_1, ..., V_{N-1}.\n        K (float): The strike price, used as the boundary value V_0.\n        N (float): The number of spatial divisions.\n\n    Returns:\n        int: The number of convexity violations.\n    \"\"\"\n    V_full = np.zeros(N + 1)\n    V_full[0] = K\n    V_full[1:N] = V_interior\n    # V_full[N] is 0.0, as V(S_max, t) = 0\n    \n    # Check V_{j+1} - 2*V_j + V_{j-1}  0 for j=1, ..., N-1\n    second_derivs = V_full[2:] - 2 * V_full[1:-1] + V_full[:-2]\n    \n    return int(np.sum(second_derivs  0))\n\ndef compute_oscillation_diff(params):\n    \"\"\"\n    Main computational routine for a single test case. It computes the option\n    price at time T-dt using both standard Crank-Nicolson and Rannacher\n    smoothing, and returns the difference in convexity violations.\n    \"\"\"\n    K, r, sigma, T, S_max, N, M = params\n    \n    # Grid parameters\n    dt = T / M\n    dS = S_max / N\n    \n    # Spatial grid for interior points (j = 1, ..., N-1)\n    j = np.arange(1, N) \n    \n    # Terminal condition at t=T and payoff constraint g(S)\n    S_grid = np.linspace(0, S_max, N + 1)\n    V_T = np.maximum(K - S_grid, 0)\n    g_interior = V_T[1:N]\n    \n    # --- Setup finite difference matrix A for the spatial operator ---\n    A = np.zeros((N - 1, N - 1))\n    \n    alpha = 0.5 * sigma**2 * j**2 - 0.5 * r * j\n    beta = -sigma**2 * j**2 - r\n    gamma = 0.5 * sigma**2 * j**2 + 0.5 * r * j\n    \n    A[np.arange(N - 1), np.arange(N - 1)] = beta\n    A[np.arange(N - 2), np.arange(N - 2) + 1] = gamma[:-1]\n    A[np.arange(1, N - 1), np.arange(1, N - 1) - 1] = alpha[1:]\n            \n    # Vector for boundary condition V(0, t)=K\n    bc_term_vector = np.zeros(N - 1)\n    bc_term_vector[0] = alpha[0] * K\n    \n    # PSOR parameters\n    omega = 1.2\n    tol = 1e-9\n    max_iter = 20000\n    \n    # --- Method 1: Single Crank-Nicolson Step ---\n    # We step backwards from t_M=T to t_{M-1}=T-dt\n    # (I - 0.5*dt*A)V^{M-1} = (I + 0.5*dt*A)V^M - dt*bc\n    V_prev_ts = V_T[1:N]\n    theta_dt_cn = 0.5 * dt\n    \n    L_cn = np.identity(N - 1) - theta_dt_cn * A\n    R_cn = np.identity(N - 1) + theta_dt_cn * A\n    \n    # Assemble the RHS vector\n    b_cn = R_cn @ V_prev_ts - dt * bc_term_vector\n    \n    V_cn_interior = solve_lcp_psor(L_cn, b_cn, g_interior, g_interior.copy(), omega, tol, max_iter)\n    violations_cn = count_convexity_violations(V_cn_interior, K, N)\n\n    # --- Method 2: Rannacher Smoothing (Two Backward Euler half-steps) ---\n    dt_half = dt / 2.0\n    L_be = np.identity(N - 1) - dt_half * A\n    \n    # First half-step from T to T - dt/2\n    # (I - dt_half*A)V^{M-1/2} = V^M - dt_half*bc\n    b_be1 = V_T[1:N] - dt_half * bc_term_vector\n    V_half_step = solve_lcp_psor(L_be, b_be1, g_interior, g_interior.copy(), omega, tol, max_iter)\n    \n    # Second half-step from T - dt/2 to T - dt\n    # (I - dt_half*A)V^{M-1} = V^{M-1/2} - dt_half*bc\n    b_be2 = V_half_step - dt_half * bc_term_vector\n    V_rannacher_interior = solve_lcp_psor(L_be, b_be2, g_interior, V_half_step, omega, tol, max_iter)\n    \n    violations_rannacher = count_convexity_violations(V_rannacher_interior, K, N)\n    \n    return violations_cn - violations_rannacher\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (K, r, sigma, T, S_max, N, M)\n        (100.0, 0.05, 0.2, 0.25, 400.0, 120, 10),\n        (100.0, 0.03, 0.3, 0.5, 400.0, 80, 8),\n        (50.0, 0.1, 0.4, 1.0, 200.0, 100, 10),\n    ]\n\n    results = []\n    for case in test_cases:\n        diff = compute_oscillation_diff(case)\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}