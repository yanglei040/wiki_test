{
    "hands_on_practices": [
        {
            "introduction": "在深入复杂的并行编程之前，理解并行化所能带来的性能提升的理论上限至关重要。阿姆达尔定律（Amdahl's Law）为我们提供了一个基本的现实检验。这个练习  揭示了并行计算的一个核心原则：性能的提升最终会受限于任务中必须串行执行的部分。通过这个计算，你将对“为什么优化代码的串行部分与并行化其余部分同样重要”有一个定量的认识。",
            "id": "2417876",
            "problem": "一家中央银行运行一个大规模宏观金融压力测试流水线，该流水线包含 $2$ 个阶段：一个严格串行的数据收集和清理阶段，以及一个可以在独立场景中以可忽略不计的开销进行完全并行化的蒙特卡洛模拟阶段。在单核基准上，模拟阶段占总运行时间的 $0.99$。将加速比定义为单核运行时间与在具有 $N$ 个相同核心的机器上的运行时间之比，其中只有模拟阶段被并行化，而串行阶段保持严格串行。在 $N \\to \\infty$ 的极限情况下，相对于单核基准的理论最大加速比是多少？以一个不带单位的精确数字形式提供答案。",
            "solution": "在尝试求解之前，将对所述问题进行验证。\n\n首先，我们提取给定的信息。\n1.  该过程包括 $2$ 个阶段：一个严格串行的数据收集和清理阶段，以及一个可完全并行化的蒙特卡洛模拟阶段。\n2.  可并行化模拟阶段占总单核运行时间的比例为 $P$。因此，$P = 0.99$。\n3.  加速比 $S(N)$ 定义为单核运行时间与在具有 $N$ 个相同核心的机器上的运行时间之比。\n4.  目标是求出当核心数 $N$ 趋于无穷大时的理论最大加速比。\n\n其次，我们验证该问题。该问题是并行计算中的一个基本概念——阿姆达尔定律 (Amdahl's Law) 的一个直接应用。所描述的场景是科学和工程领域（包括计算金融）中计算流水线的经典且现实的模型。该问题是自洽的、有科学依据且适定的。所有术语都定义清晰，没有信息缺失或矛盾。因此，该问题被视为有效，可以进行求解。\n\n解答过程遵循阿姆达尔定律 (Amdahl's Law) 的原理。设 $T_1$ 为单核上的总运行时间。这个总时间可以分解为一个串行部分和一个可并行化部分。\n\n任务中严格串行的部分是 $1 - P$。这部分所花费的时间是 $T_{seq} = (1 - P) T_1$。\n任务中可并行化的部分是 $P$。在单核上，这部分所花费的时间是 $T_{par} = P T_1$。\n\n根据问题陈述，$P = 0.99$。\n因此，串行部分的比例是 $1 - P = 1 - 0.99 = 0.01$。\n\n当任务在具有 $N$ 个核心的系统上运行时，任务的串行部分保持不变，耗时 $T_{seq}$。然而，可并行化的部分分布在 $N$ 个核心上。假设完全并行化且开销可忽略不计，这部分的时间变为 $\\frac{T_{par}}{N}$。\n\n在 $N$ 个核心上的总运行时间 $T(N)$ 是这两部分执行时间的总和：\n$$T(N) = T_{seq} + \\frac{T_{par}}{N} = (1 - P) T_1 + \\frac{P T_1}{N}$$\n\n加速比 $S(N)$ 定义为单核运行时间与 $N$ 核运行时间之比：\n$$S(N) = \\frac{T_1}{T(N)} = \\frac{T_1}{(1 - P) T_1 + \\frac{P T_1}{N}}$$\n\n项 $T_1$ 是分子和分母的公因子，可以消去。这是符合预期的，因为加速比是一个相对度量：\n$$S(N) = \\frac{1}{(1 - P) + \\frac{P}{N}}$$\n\n问题要求的是理论最大加速比，这在核心数 $N$ 趋于无穷大的极限情况下达到。我们必须计算当 $N \\to \\infty$ 时 $S(N)$ 的极限。\n$$S_{max} = \\lim_{N \\to \\infty} S(N) = \\lim_{N \\to \\infty} \\frac{1}{(1 - P) + \\frac{P}{N}}$$\n\n当 $N \\to \\infty$ 时，项 $\\frac{P}{N}$ 趋近于 $0$，因为 $P$ 是一个有限常数。\n$$\\lim_{N \\to \\infty} \\frac{P}{N} = 0$$\n\n因此，加速比函数的极限是：\n$$S_{max} = \\frac{1}{(1 - P) + 0} = \\frac{1}{1 - P}$$\n\n这个结果是阿姆达尔定律 (Amdahl's Law) 的核心论述：最大加速比受代码中串行部分的限制。\n\n将给定值 $P = 0.99$ 代入最大加速比的表达式中：\n$$S_{max} = \\frac{1}{1 - 0.99} = \\frac{1}{0.01}$$\n\n计算此表达式得出最终答案。\n$$S_{max} = 100$$\n这是给定流水线的理论最大加速比，无论在超过某个点后增加多少处理器。性能从根本上受到必须串行完成的 $1\\%$ 工作的瓶颈限制。",
            "answer": "$$\n\\boxed{100}\n$$"
        },
        {
            "introduction": "经济模型常常涉及多个主体同时做出决策。在并行程序中正确实现这种“同时性”并非易事，它需要精心的同步控制。本练习  使用经典的古诺（Cournot）双寡头模型，来阐明“屏障”（barrier）在同步线程中的关键作用，并揭示当线程读取不一致状态时会产生的建模错误。通过亲手实现一个正确的（同步的）和一个错误的（非同步的）模拟，你将直接体验到同步机制如何保证离散时间模拟的正确性，从而精确地对经济理论进行建模。",
            "id": "2417917",
            "problem": "您被要求编写一个完整、可运行的程序，该程序使用两个独立的线程，在离散时间步中模拟一个古诺双寡头垄断，其中两家公司同时选择产量。该程序必须证明，为了正确地将由 $t \\in \\{0,1,2,\\dots\\}$ 索引的离散时间步建模为同时决策，需要使用屏障同步，以确保两家公司都从时间步 $t$ 的同一状态进行更新，并同时将其更新提交到时间步 $t+1$。您将比较一个使用屏障的同步模拟与一个不强制同时读取约束、故意采用非同步顺序更新的模拟，并突显后者中的建模错误。\n\n要使用的基本和核心定义：\n- 设反需求函数为 $P(Q) = a - b Q$，其中 $a > 0$，$b > 0$，总产量为 $Q = q_1 + q_2$，公司 $i$ 的恒定边际成本为 $c_i \\ge 0$。公司 $i$ 的利润为 $\\pi_i(q_i,q_j) = \\left(P(q_i+q_j) - c_i\\right) q_i$。\n- 在古诺竞争中，在任何时间步 $t$，每个公司 $i$ 选择 $q_i^{t+1}$ 以在给定竞争对手在时间 $t$ 的产量的情况下最大化其利润。存在非负约束 $q_i^{t+1} \\ge 0$。\n- 离散时间同时博弈所预期的步进更新是，两家公司仅使用来自时间步 $t$ 的信息计算 $q_i^{t+1}$，然后原子性地提交 $q^{t+1}$。这要求在线程之间进行屏障同步，以确保两家公司都读取相同的过去状态，并且它们的写入在同一离散时间边界上提交。\n- 相反，如果没有屏障来强制同时读取和提交，一个线程可能会提前更新，而另一个线程可能会读取一个部分更新的状态，从而违反了在 $t$ 和 $t+1$ 之间边界上同时决策的预期模型。\n\n您的程序必须：\n1. 从第一性原理出发，通过在 $q_i \\ge 0$ 的约束下最大化 $\\pi_i(q_i,q_j)$，推导并实现公司 $i$ 在给定 $q_j$ 时的唯一最优反应 $BR_i(q_j)$。在所有更新中使用推导出的 $BR_i(q_j)$。\n2. 从给定的初始产量 $(q_1^0,q_2^0)$ 开始，为 $T$ 个离散步骤实现双线程模拟：\n   - 带屏障的同步模拟：两个线程代表两家公司。在每个步骤 $t$，两者都仅使用 $(q_1^t,q_2^t)$ 计算 $q_i^{t+1} = BR_i(q_j^t)$，并在屏障处原子性地提交对 $(q_1^{t+1},q_2^{t+1})$，以便两者都从步骤 $t$ 读取完全相同的状态。\n   - 无屏障的非同步顺序模拟：两个线程代表两家公司，但它们不协调同时读取。在每个步骤内，强制执行确定性的顺序更新顺序：公司 1 首先使用 $q_2^t$ 进行更新，并立即写入 $q_1^{t+1}$；然后公司 2 读取这个已更新的 $q_1^{t+1}$ 并写入 $q_2^{t+1}$。这种构造是故意违反同时决策，以说明在没有屏障的情况下的建模错误。\n3. 通过求解满足非负约束的古诺均衡，计算静态纳什均衡 $(q_1^\\star,q_2^\\star)$。如果无约束均衡对两个 $i$ 都得出 $q_i^\\star \\ge 0$，则使用内部解。如果一个无约束的 $q_i^\\star$ 为负，则通过将该 $q_i^\\star = 0$ 来强制执行角点解情况，并重新计算另一家公司对这个零产量的最优反应；如果两者都为负，则设 $(q_1^\\star,q_2^\\star) = (0,0)$。\n4. 对于每个测试用例，从指定的初始状态开始，对两种模拟运行指定的步数 $T$。然后计算并报告：\n   - 在步骤 $T$ 时，同步和非同步最终产量之间的最大绝对差：\n     $$ d = \\max\\left\\{ \\left| q_1^{T,\\mathrm{sync}} - q_1^{T,\\mathrm{unsync}} \\right|, \\left| q_2^{T,\\mathrm{sync}} - q_2^{T,\\mathrm{unsync}} \\right| \\right\\}. $$\n   - 同步最终状态相对于静态均衡的误差的欧几里得范数：\n     $$ e_{\\mathrm{sync}} = \\sqrt{\\left(q_1^{T,\\mathrm{sync}} - q_1^\\star\\right)^2 + \\left(q_2^{T,\\mathrm{sync}} - q_2^\\star\\right)^2}. $$\n   - 非同步最终状态相对于静态均衡的误差的欧几里得范数：\n     $$ e_{\\mathrm{unsync}} = \\sqrt{\\left(q_1^{T,\\mathrm{unsync}} - q_1^\\star\\right)^2 + \\left(q_2^{T,\\mathrm{unsync}} - q_2^\\star\\right)^2}. $$\n\n覆盖不同方面的测试套件：\n- 案例 A（理想路径；对称成本；单步差异最显著）：$a = 100$，$b = 1$，$c_1 = 10$，$c_2 = 10$，$T = 1$，初始 $(q_1^0,q_2^0) = (0,0)$。\n- 案例 B（非对称成本；多步；内部均衡）：$a = 90$，$b = 1.5$，$c_1 = 10$，$c_2 = 30$，$T = 5$，初始 $(q_1^0,q_2^0) = (0,0)$。\n- 案例 C（边界情况，一家公司的非负约束生效）：$a = 40$，$b = 2$，$c_1 = 50$，$c_2 = 4$，$T = 3$，初始 $(q_1^0,q_2^0) = (0,0)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表的列表，每个内部列表对应一个测试用例，并按此确切顺序包含三个浮点值 $[d, e_{\\mathrm{sync}}, e_{\\mathrm{unsync}}]$。输出必须以单行形式打印，格式为\n  \"[[d_A,e_sync_A,e_unsync_A],[d_B,e_sync_B,e_unsync_B],[d_C,e_sync_C,e_unsync_C]]\"\n  其中每个浮点数应以定点表示法呈现，小数点后保留六位数字。不应打印任何额外文本。\n不涉及物理单位。所有角度（如果有）均不适用。所有比率必须以小数形式表示。",
            "solution": "问题陈述经过验证，被认为是有效的。它在已建立的经济学理论（古诺竞争）和计算科学（并行同步）方面具有科学依据。该问题是适定的，为获得唯一、可验证的解提供了所有必要的参数和定义。没有矛盾、歧义或事实不准确之处。因此，我们可以着手进行正式的求解。\n\n问题的核心是模拟一个离散时间的古诺双寡头垄断。首先，我们必须推导出每个公司的最优反应函数，该函数定义了在给定其竞争对手产量的情况下，它的最优产量选择。\n\n公司 $i$ 的利润 $\\pi_i$ 由其收入减去成本给出：\n$$ \\pi_i(q_i, q_j) = P(Q)q_i - c_i q_i $$\n其中 $Q = q_i + q_j$，反需求函数为 $P(Q) = a - b Q$，$c_i$ 是恒定的边际成本。代入需求函数，我们得到：\n$$ \\pi_i(q_i, q_j) = (a - b(q_i + q_j) - c_i)q_i = aq_i - bq_i^2 - bq_j q_i - c_i q_i $$\n为了找到最大化此利润的产量 $q_i$，我们对 $q_i$ 取一阶偏导数并将其设为零，这是一阶最大化条件：\n$$ \\frac{\\partial \\pi_i}{\\partial q_i} = a - 2bq_i - bq_j - c_i = 0 $$\n求解 $q_i$ 得到无约束的反应函数：\n$$ 2bq_i = a - c_i - bq_j \\implies q_i = \\frac{a - c_i - bq_j}{2b} $$\n二阶最大化条件得到满足，因为 $\\frac{\\partial^2 \\pi_i}{\\partial q_i^2} = -2b < 0$（由于给定 $b > 0$）。然而，公司不能生产负数量的商品，因此我们必须强制执行非负约束 $q_i \\ge 0$。因此，最优反应函数 $BR_i(q_j)$ 为：\n$$ BR_i(q_j) = \\max\\left\\{0, \\frac{a - c_i - bq_j}{2b}\\right\\} $$\n\n接下来，我们确定静态古诺-纳什均衡 $(q_1^\\star, q_2^\\star)$，这是一个稳定状态，在此状态下，没有公司有单方面改变其产量的动机。当两家公司同时处于其最优反应曲线上时，即 $q_1^\\star = BR_1(q_2^\\star)$ 和 $q_2^\\star = BR_2(q_1^\\star)$，就会出现这种情况。\n假设存在一个内部解，其中 $q_1^\\star > 0$ 且 $q_2^\\star > 0$，我们求解以下线性方程组：\n$$ q_1^\\star = \\frac{a - c_1 - bq_2^\\star}{2b} $$\n$$ q_2^\\star = \\frac{a - c_2 - bq_1^\\star}{2b} $$\n将 $q_2^\\star$ 的表达式代入第一个方程并求解 $q_1^\\star$ 得：\n$$ q_1^\\star = \\frac{a - 2c_1 + c_2}{3b} $$\n通过对称性，公司 2 的均衡产量为：\n$$ q_2^\\star = \\frac{a - 2c_2 + c_1}{3b} $$\n如果这些公式对某个公司得出的产量为负，例如 $q_i^\\star < 0$，则其均衡产量必须在边界上，即 $q_i^\\star = 0$。另一家公司 $j$ 则会对这个零产量做出反应：$q_j^\\star = BR_j(0) = \\max\\{0, (a-c_j)/(2b)\\}$。如果两个无约束产量都为负，则均衡为 $(q_1^\\star, q_2^\\star) = (0,0)$。\n\n该问题要求对从初始状态 $(q_1^0, q_2^0)$ 开始，在 $T$ 个时间步内的两种动态模拟模型进行比较。两种模型都使用两个线程实现，每个线程代表一个公司。\n\n$1$. **同步模拟 (Synchronous Simulation)**：这正确地模拟了离散时间中古诺竞争的同时行动性质。在每个步骤 $t$，两家公司都必须基于*相同*的信息来决定它们在步骤 $t+1$ 的产量，这个信息就是市场在时间 $t$ 的状态，即 $(q_1^t, q_2^t)$。\n$$ q_1^{t+1} = BR_1(q_2^t) $$\n$$ q_2^{t+1} = BR_2(q_1^t) $$\n要在多线程程序中强制执行此操作，必须使用同步屏障。线程们根据时间 $t$ 的共享状态计算它们的下一个产量。然后它们在屏障处等待。在所有线程都到达屏障后，步骤 $t+1$ 的新产量将被提交到共享状态。这确保了没有线程在计算其自身的 $t+1$ 值时，能够读取到来自步骤 $t+1$ 的部分更新状态。这在计算上类似于求解线性系统的雅可比法。\n\n$2$. **非同步顺序模拟 (Unsynchronized Sequential Simulation)**：此模拟通过省略同步屏障，故意引入了建模错误。它强制执行一个确定性的更新顺序：公司 1 先更新，公司 2 随后。\n$$ q_1^{t+1} = BR_1(q_2^t) $$\n$$ q_2^{t+1} = BR_2(q_1^{t+1}) $$\n在这里，公司 2 对步骤 $t+1$ 的决策是基于公司 1 在步骤 $t+1$ 的产量，而不是 $t$。这违反了同时行动的原则。它模拟了一个序贯博弈动态，其中在每个时间步内，公司 1 是领导者，公司 2 是跟随者。这对应于高斯-赛德尔法。此模拟的轨迹与同步模拟轨迹之间的差异，突显了在模拟并行或同时事件时正确同步的至关重要性。\n\n该程序将实现这两种模拟，为给定的测试用例计算指定的度量（$d$，$e_{\\mathrm{sync}}$，$e_{\\mathrm{unsync}}$），并展示由非同步情况下的建模错误引起的发散。同步模型的实现将使用带有 `Barrier` 的 `threading` 模块，以正确地模拟“同时读取然后同时提交”的逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport threading\nfrom collections import namedtuple\n\n# Define data structure for problem parameters\nCaseParams = namedtuple('CaseParams', ['a', 'b', 'c1', 'c2', 'T', 'q0'])\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path, symmetric costs\n        CaseParams(a=100.0, b=1.0, c1=10.0, c2=10.0, T=1, q0=np.array([0.0, 0.0])),\n        # Case B: Asymmetric costs, multiple steps\n        CaseParams(a=90.0, b=1.5, c1=10.0, c2=30.0, T=5, q0=np.array([0.0, 0.0])),\n        # Case C: Boundary case, non-negativity constraint binding\n        CaseParams(a=40.0, b=2.0, c1=50.0, c2=4.0, T=3, q0=np.array([0.0, 0.0])),\n    ]\n\n    results = []\n    for params in test_cases:\n        results.append(solve_case(params))\n\n    # Format the final output string as specified\n    formatted_results = [\n        f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef best_response(q_other, a, b, c):\n    \"\"\"\n    Calculates the best response for a firm given the other's quantity.\n    BR_i(q_j) = max(0, (a - c_i - b*q_j) / (2*b))\n    \"\"\"\n    num = a - c - b * q_other\n    den = 2.0 * b\n    return max(0.0, num / den)\n\ndef calculate_nash_equilibrium(params):\n    \"\"\"\n    Calculates the static Cournot-Nash equilibrium quantities.\n    Handles both interior and corner solutions.\n    \"\"\"\n    a, b, c1, c2 = params.a, params.b, params.c1, params.c2\n    \n    # Calculate unconstrained interior solution\n    q1_star_unconstrained = (a - 2.0 * c1 + c2) / (3.0 * b)\n    q2_star_unconstrained = (a - 2.0 * c2 + c1) / (3.0 * b)\n\n    if q1_star_unconstrained >= 0 and q2_star_unconstrained >= 0:\n        return np.array([q1_star_unconstrained, q2_star_unconstrained])\n    \n    # Handle corner solutions\n    q1_star, q2_star = 0.0, 0.0\n    if q1_star_unconstrained < 0 and q2_star_unconstrained < 0:\n        # If both would be negative, both produce 0\n        q1_star, q2_star = 0.0, 0.0\n    elif q1_star_unconstrained < 0:\n        # Firm 1 is non-competitive, check firm 2's monopoly power\n        q1_star = 0.0\n        q2_star = best_response(0.0, a, b, c2)\n    elif q2_star_unconstrained < 0:\n        # Firm 2 is non-competitive, check firm 1's monopoly power\n        q2_star = 0.0\n        q1_star = best_response(0.0, a, b, c1)\n\n    return np.array([q1_star, q2_star])\n\ndef simulate_synchronized(params):\n    \"\"\"\n    Performs the synchronous simulation using two threads and a barrier.\n    This correctly models simultaneous moves.\n    \"\"\"\n    q_state = [params.q0.copy(), np.zeros(2)] # Double buffer for current and next state\n    read_idx, write_idx = 0, 1\n    \n    barrier = threading.Barrier(2)\n\n    def firm_worker(firm_id):\n        nonlocal read_idx, write_idx\n        my_c = params.c1 if firm_id == 0 else params.c2\n        other_firm_id = 1 - firm_id\n\n        for _ in range(params.T):\n            # Read from the same state (t)\n            q_other = q_state[read_idx][other_firm_id]\n            \n            # Compute own next quantity for state (t+1)\n            my_next_q = best_response(q_other, params.a, params.b, my_c)\n            q_state[write_idx][firm_id] = my_next_q\n            \n            # Wait at barrier for other firm to finish its calculation\n            barrier.wait()\n            \n            # One thread swaps buffers for the next iteration\n            if firm_id == 0:\n                read_idx, write_idx = write_idx, read_idx\n            \n            # Second barrier to ensure buffers are swapped before next read starts\n            barrier.wait()\n\n    thread1 = threading.Thread(target=firm_worker, args=(0,))\n    thread2 = threading.Thread(target=firm_worker, args=(1,))\n    \n    thread1.start()\n    thread2.start()\n    \n    thread1.join()\n    thread2.join()\n    \n    return q_state[read_idx]\n\ndef simulate_unsynchronized(params):\n    \"\"\"\n    Performs the unsynchronized sequential simulation.\n    This demonstrates the modeling error from lack of synchronization.\n    \"\"\"\n    q = params.q0.copy()\n    a, b, c1, c2, T = params.a, params.b, params.c1, params.c2, params.T\n    \n    for _ in range(T):\n        # Firm 1 updates first, based on q from step t\n        q1_next = best_response(q[1], a, b, c1)\n        q[0] = q1_next\n        \n        # Firm 2 updates second, based on the *new* q1 from step t+1\n        q2_next = best_response(q[0], a, b, c2)\n        q[1] = q2_next\n        \n    return q\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case: calculates equilibrium, runs simulations,\n    and computes the required output metrics.\n    \"\"\"\n    q_star = calculate_nash_equilibrium(params)\n    \n    q_sync_final = simulate_synchronized(params)\n    q_unsync_final = simulate_unsynchronized(params)\n\n    # Calculate metrics\n    d = np.max(np.abs(q_sync_final - q_unsync_final))\n    e_sync = np.linalg.norm(q_sync_final - q_star)\n    e_unsync = np.linalg.norm(q_unsync_final - q_star)\n    \n    return d, e_sync, e_unsync\n\n# Run the solver\nsolve()\n\n```"
        },
        {
            "introduction": "在保证了算法的正确性之后，下一个挑战便是性能优化。有时，与计算机硬件架构（如内存系统）的隐藏交互会出乎意料地拖慢并行程序的执行速度。这个练习  介绍了一种常见的性能陷阱——“伪共享”（false sharing）。当不同的处理器核心在处理不同数据时，如果这些数据恰好位于同一个缓存行（cache line）上，它们就会相互干扰。通过模拟计算这种现象导致的性能下降，你将对内存中的数据布局如何显著影响并行经济模拟的效率建立起直观的理解。",
            "id": "2417854",
            "problem": "给定一个关于一维家庭网格并行模拟中“伪共享”的简化第一性原理模型。总共有 $N$ 个家庭，索引为 $h_0,h_1,\\dots,h_{N-1}$，并在内存中连续排列。内存系统使用缓存行，每个缓存行可以精确容纳 $L$ 个家庭，因此家庭 $h_i$ 的缓存行标识符为 $\\ell(i)=\\left\\lfloor i/L \\right\\rfloor$。有 $K$ 个相同的工作单元（可理解为中央处理器（CPU）的核心），时间以离散的轮次 $r\\in\\{0,1,\\dots,R-1\\}$ 推进，其中 $R=\\lceil N/K \\rceil$。在每一轮 $r$ 中，每个工作单元 $k\\in\\{0,1,\\dots,K-1\\}$ 最多更新一个家庭，具体来说是索引为 $i=k+rK$ 的家庭（如果 $i<N$）。否则，该工作单元在本轮次中处于空闲状态。\n\n每次家庭更新都是一次单独的写入操作。单次写入的基础时间为 $c>0$。如果在同一轮 $r$ 中，多个工作单元更新了映射到同一缓存行的家庭，缓存一致性将导致如下的额外延迟。对于任何轮次 $r$ 和任何缓存行 $x$，将 $m_x(r)$ 定义为在轮次 $r$ 中，目标家庭满足 $\\ell(i)=x$ 的更新次数。轮次 $r$ 的挂钟持续时间为\n$$\nt_r \\;=\\; c \\;+\\; p\\cdot\\big(\\max_{x} m_x(r) - 1\\big),\n$$\n约定：如果一轮中没有活动的工作单元，则认为该轮次不发生。在这种交错调度下，执行的总模拟挂钟时间为\n$$\nT_{\\mathrm{interleaved}} \\;=\\; \\sum_{r=0}^{R-1} t_r.\n$$\n\n作为对比，考虑一种无冲突的填充布局方案，其中家庭在内存中通过填充进行布局，以确保任意两个同时更新的家庭都不会共享同一个缓存行（实际上，每个缓存行只有一个家庭）。在相同的索引调度下，每个有至少一个活动工作单元的轮次的持续时间恰好为 $c$，因此\n$$\nT_{\\mathrm{padded}} \\;=\\; R\\cdot c.\n$$\n\n将减速因子定义为\n$$\nS \\;=\\; \\frac{T_{\\mathrm{interleaved}}}{T_{\\mathrm{padded}}}.\n$$\n\n您的任务是实现一个程序，为每个指定的测试用例计算如上定义的减速因子 $S$。\n\n测试套件：\n- 用例 1：$(N,K,L,c,p) = ($16$,$2$,$2$,$1.0$,$0.5$)$.\n- 用例 2：$(N,K,L,c,p) = ($16$,$2$,$1$,$1.0$,$10.0$)$.\n- 用例 3：$(N,K,L,c,p) = ($17$,$1$,$8$,$1.0$,$2.0$)$.\n- 用例 4：$(N,K,L,c,p) = ($100$,$4$,$4$,$2.0$,$0.0$)$.\n- 用例 5：$(N,K,L,c,p) = ($32$,$4$,$4$,$1.0$,$1.0$)$.\n\n答案规格：\n- 对于每个用例，以十进制数形式输出减速因子 $S$。\n- 您的程序应生成单行输出，其中包含所有用例的结果，格式为方括号括起来的逗号分隔列表，结果顺序与上述用例顺序一致，且每个数字小数点后保留三位（例如，[$1.000$,$1.500$]）。",
            "solution": "问题陈述经检验有效。它在科学上基于并行计算的原理，特别是缓存一致性系统中的“伪共享”概念。该问题是良构的，所有变量、常数和函数关系都得到了明确的定义，从而允许一个唯一且稳定的解。其语言表述客观，设定内部一致且完整。\n\n目标是计算减速因子 $S$，其定义为交错并行调度下的总执行时间 $T_{\\text{interleaved}}$ 与无冲突填充调度下的总执行时间 $T_{\\text{padded}}$ 之比。\n$$\nS = \\frac{T_{\\text{interleaved}}}{T_{\\text{padded}}}\n$$\n计算过程是，对于给定的一组参数 $(N, K, L, c, p)$，分别确定 $T_{\\text{padded}}$ 和 $T_{\\text{interleaved}}$。其中，$N$ 是家庭总数，$K$ 是工作单元数，$L$ 是每个缓存行容纳的家庭数，$c$ 是基础写入成本，$p$ 是冲突惩罚系数。\n\n首先，我们计算填充布局的总时间 $T_{\\text{padded}}$。模拟以离散的轮次 $r$ 进行。用 $K$ 个工作单元处理所有 $N$ 个家庭所需的总轮次数为 $R = \\lceil N/K \\rceil$。在填充布局中，伪共享被消除，因此每个有至少一个活动工作单元的轮次耗时为一个恒定时间 $c$。可以证明，对于所有轮次 $r \\in \\{0, 1, \\dots, R-1\\}$，至少工作单元 $k=0$ 是活动的，因为其目标索引 $i=rK$ 满足 $rK < (\\lceil N/K \\rceil)K$，这意味着 $rK \\le (N/K)K = N$，并且对于 $r < N/K$ 严格不等式成立。对于最后一轮 $r=R-1$，我们有 $(R-1)K < N$，所以工作单元 0 始终是活动的。因此，所有 $R$ 个轮次都是活动的，总时间为：\n$$\nT_{\\text{padded}} = R \\cdot c\n$$\n\n接下来，我们计算交错布局的总时间 $T_{\\text{interleaved}}$。该时间是每个单独轮次持续时间 $t_r$ 的总和：\n$$\nT_{\\text{interleaved}} = \\sum_{r=0}^{R-1} t_r\n$$\n单个轮次 $r$ 的持续时间取决于同时访问同一缓存行的最大工作单元数。该持续时间由下式给出：\n$$\nt_r = c + p \\cdot \\left(\\max_{x} m_x(r) - 1\\right)\n$$\n其中 $m_x(r)$ 是在轮次 $r$ 中对位于缓存行 $x$ 上的家庭的更新次数。为了计算 $t_r$，我们必须首先找到 $\\max_{x} m_x(r)$。\n\n对从 $0$ 到 $R-1$ 的每一轮 $r$ 的算法如下：\n1.  确定本轮中更新的家庭索引集合。对于每个工作单元 $k \\in \\{0, 1, \\dots, K-1\\}$，目标索引为 $i = k + rK$。仅当 $i < N$ 时才进行更新。\n2.  对于每个此类活动索引 $i$，确定其缓存行标识符 $\\ell(i) = \\lfloor i/L \\rfloor$。\n3.  统计每个唯一缓存行标识符的出现次数。这将给出本轮中访问的所有缓存行 $x$ 对应的 $m_x(r)$ 值。\n4.  确定最大计数值 $\\max_{x} m_x(r)$。令其为 $M_r$。\n5.  计算轮次持续时间 $t_r = c + p \\cdot (M_r - 1)$。\n6.  将所有轮次的这些持续时间相加，得到 $T_{\\text{interleaved}}$。\n\n最后，通过这两个总时间的比率计算减速因子 $S$。对问题中指定的每个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases and print the results.\n    \"\"\"\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # (N, K, L, c, p)\n        (16, 2, 2, 1.0, 0.5),\n        (16, 2, 1, 1.0, 10.0),\n        (17, 1, 8, 1.0, 2.0),\n        (100, 4, 4, 2.0, 0.0),\n        (32, 4, 4, 1.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for each case\n        N, K, L, c, p = case\n        # Calculate the slowdown factor\n        result = calculate_slowdown(N, K, L, c, p)\n        # Format the result to three decimal places as a string.\n        results.append(f\"{result:.3f}\")\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_slowdown(N, K, L, c, p):\n    \"\"\"\n    Computes the slowdown factor S for a given set of parameters.\n\n    Args:\n        N (int): Total number of households.\n        K (int): Number of workers.\n        L (int): Number of households per cache line.\n        c (float): Base time for a single write.\n        p (float): Penalty coefficient for cache conflicts.\n\n    Returns:\n        float: The slowdown factor S.\n    \"\"\"\n    # The total number of rounds, R, is the ceiling of N/K.\n    R = int(np.ceil(N / K))\n\n    # The total time for the padded, conflict-free layout is R * c.\n    # As established in the analysis, every round from 0 to R-1 has at least one\n    # active worker, so all R rounds take time c.\n    if R == 0: # Handle edge case where N=0\n        return 1.0\n    T_padded = R * c\n\n    # Calculate the total time for the interleaved layout by summing round durations.\n    T_interleaved = 0.0\n    for r in range(R):\n        # Determine the household indices accessed by all workers in this round.\n        indices_this_round = []\n        for k in range(K):\n            idx = k + r * K\n            if idx < N:\n                indices_this_round.append(idx)\n        \n        # A round r < R always has at least one active worker, so this list is not empty.\n        \n        # Map each household index to its corresponding cache line ID.\n        cache_lines_this_round = [idx // L for idx in indices_this_round]\n        \n        # Count the number of updates for each unique cache line to find the maximum contention.\n        # This corresponds to finding max_x m_x(r).\n        if not cache_lines_this_round:\n             max_updates_on_a_line = 0\n        else:\n            _, counts = np.unique(cache_lines_this_round, return_counts=True)\n            max_updates_on_a_line = np.max(counts)\n            \n        # Calculate the duration of the current round, t_r.\n        # The penalty is proportional to the number of excess workers on the most contended cache line.\n        if max_updates_on_a_line > 0:\n            t_r = c + p * (max_updates_on_a_line - 1)\n        else: # Should not happen for r  R\n            t_r = 0\n\n        T_interleaved += t_r\n    \n    # The slowdown factor S is the ratio of the two total times.\n    # Division by zero is not a risk as c  0 and N  0 implies R  0 and T_padded  0.\n    if T_padded == 0: # Handle case where N=0, R=0\n        return 1.0\n    slowdown = T_interleaved / T_padded\n    \n    return slowdown\n\n# Execute the main function to run the simulation and print the output.\nsolve()\n```"
        }
    ]
}