{
    "hands_on_practices": [
        {
            "introduction": "在数值求解随机微分方程时，最基础的方法是欧拉-丸山（Euler-Maruyama）格式。然而，一个关键问题是：这种离散化方法在精度和计算成本之间如何权衡？本练习  将通过一个经典案例——Ornstein-Uhlenbeck 过程，引导你从第一性原理出发，数值化地对比欧拉格式与精确抽样方法的效率，让你切身体会到离散化偏差（discretization bias）对蒙特卡洛估计器均方误差（Mean-Squared Error, MSE）的影响。",
            "id": "2415924",
            "problem": "考虑在计算经济学和金融学中广泛使用的均值回归短期利率模型，即 Ornstein–Uhlenbeck 过程（也称为 Vasicek 模型），其由以下随机微分方程（SDE）定义\n$$\ndX_t = \\kappa(\\theta - X_t)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0,\n$$\n其中 $X_t$ 是状态变量（例如，短期利率），$\\kappa  0$ 是均值回归速度，$\\theta$ 是长期均值，$\\sigma  0$ 是扩散系数，而 $W_t$ 是标准布朗运动。您的任务是从第一性原理出发，通过数值方法证明，在估计固定时间 $T$ 的期望值 $E[X_T]$ 时，在离散时间点上对精确解进行抽样比使用 Euler–Maruyama 格式更有效。此处的效率是根据固定计算预算下，单位模拟成本的均方误差来衡量的。\n\n请基于以下基本原理进行工作：\n- 对于 $dX_t = a(X_t,t)\\,dt + b(X_t,t)\\,dW_t$ 的 Itô 随机微分方程和 Itô 积分的定义。\n- Ornstein–Uhlenbeck 过程是一个线性 SDE；线性一阶 SDE 可以使用积分因子求解。\n- Euler–Maruyama 格式是通过在步长为 $\\Delta$ 的小区间 $[t_n,t_{n+1}]$ 上使用 Itô 积分的定义对 SDE 进行时间离散化，并在左端点近似漂移项和扩散项得到的。\n\n任务：\n1) 使用积分因子，推导 Ornstein–Uhlenbeck 过程在大小为 $\\Delta$ 的单步上的精确离散时间转移。也就是说，给定 $X_t$，获得 $X_{t+\\Delta}$ 作为 $X_t$ 的仿射函数加上一个高斯新息的表达式。将其均值和方差表示为 $\\kappa$、$\\theta$、$\\sigma$ 和 $\\Delta$ 的函数。\n\n2) 通过在 $[t_n,t_{n+1}]$ 上应用 Itô 积分的定义并在 $t_n$ 处近似漂移项和扩散项，推导此 SDE 在大小为 $\\Delta$ 的单步上的 Euler–Maruyama 更新规则。\n\n3) 对于固定的终止时间 $T$，定义一个计算预算，该预算由生成的总高斯随机变量数量来衡量：\n$$\nC = M \\times N,\n$$\n其中 $N = T/\\Delta$ 是每条路径的时间步数（假设 $T/\\Delta$ 是一个整数），$M$ 是模拟的路径数。为了在固定成本下进行公平比较，您必须在改变 $\\Delta$ 的同时保持 $C$ 恒定，并设置 $M = \\lfloor C/N \\rfloor$。\n\n4) 对于下面的每个参数配置，以及该配置给定的每个时间步长 $\\Delta$，使用以下方法模拟 $M$ 条直到时间 $T$ 的独立路径：\n- 您在任务1中推导的精确离散时间转移（精确抽样）。\n- 您在任务2中推导的 Euler–Maruyama 格式（欧拉格式）。\n\n在每一步和每条路径上，对两种方法使用相同的高斯新息，以确保公平、方差缩减的比较。对于每个配置和 $\\Delta$，通过以下公式估计 $E[X_T]$ 的蒙特卡洛估计量的均方误差（MSE）：\n$$\n\\widehat{\\mathrm{MSE}} = \\left(\\overline{X}_T - \\mu_T\\right)^2 + \\frac{S_T^2}{M},\n$$\n其中 $\\overline{X}_T$ 是 $M$ 条路径上 $X_T$ 的样本均值，$S_T^2$ 是 $M$ 条路径上 $X_T$ 的样本方差，而 $\\mu_T = E[X_T]$ 是由 SDE 在时间 $T$ 的精确解所隐含的精确均值。对于每个配置和 $\\Delta$，在相同的计算预算 $C$ 下，报告以下比率：\n$$\nR = \\frac{\\widehat{\\mathrm{MSE}}_{\\mathrm{Euler}}}{\\widehat{\\mathrm{MSE}}_{\\mathrm{Exact}}},\n$$\n\n5) 随机性控制和公平性：\n- 对于每个配置索引 $i \\in \\{0,1,2\\}$，使用一个基础整数种子 $s_i$。对于该配置中的第 $j$ 个步长，使用种子 $s_i + j$ 生成一个独立标准正态随机变量矩阵 $Z \\in \\mathbb{R}^{M \\times N}$。在该配置和步长下，对精确法和欧拉法重复使用相同的 $Z$。\n\n实现和数值规范：\n- 本问题不涉及物理单位。\n- 本问题不涉及角度。\n- 不涉及百分比；任何分数量必须表示为小数或分数。\n- 最终程序必须是一个单一、完整、可运行的程序，它能执行所有计算并产生指定的输出，无需用户输入。\n\n参数配置测试套件：\n- 配置 0：$\\kappa = 1.2$，$\\theta = 0.04$，$\\sigma = 0.25$，$x_0 = 0.03$，$T = 1.0$，步长 $\\Delta \\in \\{0.2, 0.05, 0.01\\}$，基础种子 $s_0 = 13579$。\n- 配置 1：$\\kappa = 3.0$，$\\theta = 0.02$，$\\sigma = 0.15$，$x_0 = 0.08$，$T = 0.5$，步长 $\\Delta \\in \\{0.1, 0.05, 0.01\\}$，基础种子 $s_1 = 24680$。\n- 配置 2：$\\kappa = 0.3$，$\\theta = 0.01$，$\\sigma = 0.05$，$x_0 = 0.00$，$T = 2.0$，步长 $\\Delta \\in \\{0.4, 0.1, 0.02\\}$，基础种子 $s_2 = 11223$。\n\n在所有配置中，将计算预算设置为相同的值 $C = 2{,}000{,}000$，并设置 $M = \\lfloor C/N \\rfloor$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含 $9$ 个比率 $R$（每个配置三个，按上面列出的配置和步长顺序排列），格式为逗号分隔的列表，并用方括号括起来，每个比率四舍五入到 $6$ 位小数。例如，包含三个比率的输出看起来像 $[1.234000,1.050000,1.002345]$。",
            "solution": "所述问题是有效的。它在科学上基于随机微分方程和数值分析的既定理论，问题设定良好，提供了所有必要的参数和条件，并且是客观的，依赖于精确的数学定义。我将继续进行解答。\n\n该问题要求对模拟 Ornstein-Uhlenbeck 过程的两种方法进行数值比较，该过程由以下随机微分方程（SDE）描述：\n$$ dX_t = \\kappa(\\theta - X_t)\\,dt + \\sigma\\,dW_t, \\quad X_0 = x_0 $$\n其中 $\\kappa  0$、$\\theta$ 和 $\\sigma  0$ 是常数。这是一个线性 SDE。\n\n首先，我将推导所需的模拟格式。\n\n**1. 精确离散时间转移的推导**\n\n该 SDE 可以重写为：\n$$ dX_t + \\kappa X_t dt = \\kappa \\theta dt + \\sigma dW_t $$\n这是一个一阶线性微分方程。我们采用一个积分因子 $I(t) = e^{\\int \\kappa dt} = e^{\\kappa t}$。将 SDE 乘以 $e^{\\kappa t}$ 得到：\n$$ e^{\\kappa t} dX_t + \\kappa e^{\\kappa t} X_t dt = \\kappa \\theta e^{\\kappa t} dt + \\sigma e^{\\kappa t} dW_t $$\n根据 Itô 乘积法则，左边是 $e^{\\kappa t} X_t$ 的微分：\n$$ d(e^{\\kappa t} X_t) = \\kappa \\theta e^{\\kappa t} dt + \\sigma e^{\\kappa t} dW_t $$\n我们将此表达式从任意时间 $t$ 积分到 $t+\\Delta$：\n$$ \\int_t^{t+\\Delta} d(e^{\\kappa s} X_s) = \\int_t^{t+\\Delta} \\kappa \\theta e^{\\kappa s} ds + \\int_t^{t+\\Delta} \\sigma e^{\\kappa s} dW_s $$\n$$ e^{\\kappa (t+\\Delta)} X_{t+\\Delta} - e^{\\kappa t} X_t = \\kappa \\theta \\left[ \\frac{e^{\\kappa s}}{\\kappa} \\right]_t^{t+\\Delta} + \\sigma \\int_t^{t+\\Delta} e^{\\kappa s} dW_s $$\n$$ e^{\\kappa (t+\\Delta)} X_{t+\\Delta} = e^{\\kappa t} X_t + \\theta (e^{\\kappa (t+\\Delta)} - e^{\\kappa t}) + \\sigma \\int_t^{t+\\Delta} e^{\\kappa s} dW_s $$\n乘以 $e^{-\\kappa(t+\\Delta)}$，我们分离出 $X_{t+\\Delta}$：\n$$ X_{t+\\Delta} = X_t e^{-\\kappa\\Delta} + \\theta (1 - e^{-\\kappa\\Delta}) + \\sigma \\int_t^{t+\\Delta} e^{-\\kappa(t+\\Delta - s)} dW_s $$\n随机积分项是一个确定性函数的 Itô 积分，其结果是一个均值为零的正态分布随机变量。其方差使用 Itô 等距性质计算：\n$$ \\mathrm{Var}\\left( \\int_t^{t+\\Delta} e^{-\\kappa(t+\\Delta - s)} dW_s \\right) = \\int_t^{t+\\Delta} \\left( e^{-\\kappa(t+\\Delta - s)} \\right)^2 ds = \\int_t^{t+\\Delta} e^{-2\\kappa(t+\\Delta - s)} ds $$\n通过变量替换 $u = s - t$，这变为：\n$$ \\int_0^{\\Delta} e^{-2\\kappa(\\Delta - u)} du = e^{-2\\kappa\\Delta} \\int_0^{\\Delta} e^{2\\kappa u} du = e^{-2\\kappa\\Delta} \\left[ \\frac{e^{2\\kappa u}}{2\\kappa} \\right]_0^{\\Delta} = \\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa} $$\n因此，随机积分可以表示为 $\\sqrt{\\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa}} Z_{t+\\Delta}$，其中 $Z_{t+\\Delta} \\sim \\mathcal{N}(0, 1)$。\n精确的离散时间转移规则是：\n$$ X_{t+\\Delta} = X_t e^{-\\kappa\\Delta} + \\theta(1 - e^{-\\kappa\\Delta}) + \\sigma \\sqrt{\\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa}} Z_{t+\\Delta} $$\n给定 $X_t$，$X_{t+\\Delta}$ 的条件分布是高斯分布，其：\n- 均值：$E[X_{t+\\Delta} | X_t] = X_t e^{-\\kappa\\Delta} + \\theta(1 - e^{-\\kappa\\Delta})$\n- 方差：$\\mathrm{Var}(X_{t+\\Delta} | X_t) = \\sigma^2 \\frac{1 - e^{-2\\kappa\\Delta}}{2\\kappa}$\n\n**2. Euler–Maruyama 更新规则的推导**\n\nEuler–Maruyama 格式通过在一个小时间步长 $\\Delta = t_{n+1} - t_n$ 上离散化其积分形式来近似 SDE。\n$$ X_{t_{n+1}} - X_{t_n} = \\int_{t_n}^{t_{n+1}} \\kappa(\\theta - X_s) ds + \\int_{t_n}^{t_{n+1}} \\sigma dW_s $$\n该格式将在区间 $[t_n, t_{n+1}]$ 上的被积函数近似为常数，取其在左端点 $t_n$ 的值：\n$$ \\int_{t_n}^{t_{n+1}} \\kappa(\\theta - X_s) ds \\approx \\kappa(\\theta - X_{t_n})\\Delta $$\n$$ \\int_{t_n}^{t_{n+1}} \\sigma dW_s = \\sigma (W_{t_{n+1}} - W_{t_n}) = \\sigma \\sqrt{\\Delta} Z_{n+1} $$\n其中 $Z_{n+1} \\sim \\mathcal{N}(0, 1)$。将这些结合起来得到更新规则，我们记 $X_n \\equiv X_{t_n}$：\n$$ X_{n+1} = X_n + \\kappa(\\theta - X_n)\\Delta + \\sigma\\sqrt{\\Delta}Z_{n+1} $$\n这就是 Ornstein-Uhlenbeck 过程所需的 Euler-Maruyama 离散化。\n\n**3. 数值实验设计与评估**\n\n目标是比较精确抽样法和 Euler-Maruyama 格式的效率。效率是通过在固定计算预算 $C$ 下，$E[X_T]$ 的蒙特卡洛估计量的均方误差（MSE）来衡量的。\n\n计算预算定义为 $C = M \\times N$，其中 $M$ 是模拟路径数，$N$ 是每条路径的时间步数。给定 $T$ 和步长 $\\Delta$，则 $N = T/\\Delta$。路径数则为 $M = \\lfloor C/N \\rfloor$。这种设置确保了对于任何 $\\Delta$ 的选择，生成的总高斯随机数数量近似恒定。\n\n对于每次模拟运行（由一组参数和一个步长 $\\Delta$ 定义），我们执行以下操作：\n1. 生成一个 $M \\times N$ 的独立标准正态离散值矩阵 $Z$。该矩阵用于精确模拟和欧拉模拟，以确保方差缩减下的公平比较。\n2. 使用精确转移和 Euler-Maruyama 格式，从 $t=0$ 到 $t=T$ 模拟 $M$ 条路径，起始点为 $X_0 = x_0$。\n3. 对于每种方法，这将产生一个包含 $M$ 个在时间 $T$ 的最终状态的向量。我们计算样本均值 $\\overline{X}_T$ 和样本方差 $S_T^2$。\n4. 过程在时间 $T$ 的真实解析均值 $\\mu_T = E[X_T] = \\theta + (x_0 - \\theta)e^{-\\kappa T}$ 是通过求解期望值的常微分方程 $d\\mu_t/dt = \\kappa(\\theta - \\mu_t)$ 得到的。\n5. 每种方法的估计 MSE 按规定公式计算：\n    $$ \\widehat{\\mathrm{MSE}} = \\left(\\overline{X}_T - \\mu_T\\right)^2 + \\frac{S_T^2}{M} $$\n    $(\\overline{X}_T - \\mu_T)^2$ 项捕捉了样本均值的平方误差，它由偏差和统计波动两部分组成。$S_T^2/M$ 项是样本均值方差的估计。\n6. 最后，我们计算估计 MSE 的比率：\n    $$ R = \\frac{\\widehat{\\mathrm{MSE}}_{\\mathrm{Euler}}}{\\widehat{\\mathrm{MSE}}_{\\mathrm{Exact}}} $$\n比率 $R > 1$ 表明 Euler-Maruyama 格式效率较低（在相同计算成本下产生更高的 MSE）。欧拉方法的弱收敛误差（偏差）随 $\\Delta$ 增长，预计是造成这种效率差异的主要原因。根据定义，精确抽样器没有这种偏差。\n\n以下程序为指定的测试配置实现了这整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating the Ornstein-Uhlenbeck process using\n    the exact method and the Euler-Maruyama scheme, and computes the ratio\n    of their Mean-Squared Errors.\n    \"\"\"\n\n    # Test suite of parameter configurations.\n    test_cases = [\n        # Configuration 0\n        {\n            \"params\": {\"kappa\": 1.2, \"theta\": 0.04, \"sigma\": 0.25, \"x0\": 0.03, \"T\": 1.0},\n            \"deltas\": [0.2, 0.05, 0.01],\n            \"base_seed\": 13579\n        },\n        # Configuration 1\n        {\n            \"params\": {\"kappa\": 3.0, \"theta\": 0.02, \"sigma\": 0.15, \"x0\": 0.08, \"T\": 0.5},\n            \"deltas\": [0.1, 0.05, 0.01],\n            \"base_seed\": 24680\n        },\n        # Configuration 2\n        {\n            \"params\": {\"kappa\": 0.3, \"theta\": 0.01, \"sigma\": 0.05, \"x0\": 0.00, \"T\": 2.0},\n            \"deltas\": [0.4, 0.1, 0.02],\n            \"base_seed\": 11223\n        }\n    ]\n\n    C = 2_000_000\n    results = []\n\n    for case_config in test_cases:\n        p = case_config[\"params\"]\n        kappa, theta, sigma, x0, T = p[\"kappa\"], p[\"theta\"], p[\"sigma\"], p[\"x0\"], p[\"T\"]\n        \n        # Calculate the true mean at time T for MSE calculation.\n        mu_T = theta + (x0 - theta) * np.exp(-kappa * T)\n\n        for j, delta in enumerate(case_config[\"deltas\"]):\n            # Set up simulation parameters\n            N = int(T / delta)\n            M = C // N\n            seed = case_config[\"base_seed\"] + j\n            \n            # Generate all standard normal random variables at once\n            rng = np.random.default_rng(seed)\n            Z = rng.standard_normal(size=(M, N))\n\n            # --- Exact Simulation ---\n            X_exact = np.full(M, x0, dtype=np.float64)\n            # Precompute constants for the exact update rule\n            e_neg_kd = np.exp(-kappa * delta)\n            var_term = sigma * np.sqrt((1 - np.exp(-2 * kappa * delta)) / (2 * kappa))\n            for i in range(N):\n                X_exact = X_exact * e_neg_kd + theta * (1 - e_neg_kd) + var_term * Z[:, i]\n\n            # --- Euler-Maruyama Simulation ---\n            X_euler = np.full(M, x0, dtype=np.float64)\n            # Precompute constant for the Euler update rule\n            sqrt_delta = np.sqrt(delta)\n            for i in range(N):\n                X_euler = X_euler + kappa * (theta - X_euler) * delta + sigma * sqrt_delta * Z[:, i]\n            \n            # --- Calculate MSE for both methods ---\n            # MSE for Exact method\n            mean_exact = np.mean(X_exact)\n            var_exact = np.var(X_exact, ddof=1) if M > 1 else 0.0\n            mse_exact = (mean_exact - mu_T)**2 + var_exact / M\n\n            # MSE for Euler method\n            mean_euler = np.mean(X_euler)\n            var_euler = np.var(X_euler, ddof=1) if M > 1 else 0.0\n            mse_euler = (mean_euler - mu_T)**2 + var_euler / M\n\n            # Avoid division by zero, although MSE_exact should be positive\n            if mse_exact > 0:\n                ratio = mse_euler / mse_exact\n            else:\n                # If exact MSE is zero, Euler MSE must also be zero for a ratio of 1\n                ratio = 1.0 if mse_euler == 0 else np.inf\n            \n            results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the simulation and print the results.\nsolve()\n```"
        },
        {
            "introduction": "随机微分方程的定义不仅涉及漂移项和扩散项，还依赖于随机积分的具体诠释。本练习  聚焦于 Itô 积分与 Stratonovich 积分这两种主流定义之间的根本差异。你将通过分析一个基础的线性随机模型，从理论上推导出两种解释如何导致对系统长期稳定性的截然相反的预测，并通过数值模拟来验证这一惊人但至关重要的结论。这个实践将深化你对随机微积分理论基础及其在实践中重要性的理解。",
            "id": "2415964",
            "problem": "您被要求设计、分析并数值验证一个案例，在该案例中，同一符号随机微分方程的伊藤 (Itô) 和斯特拉托诺维奇 (Stratonovich) 解释会得出相反的长期稳定性评估。请严格在计算经济学和金融学中使用的线性、乘性噪声模型的参数族内进行研究：\n$$\ndX_t = \\alpha\\,X_t\\,dt + \\beta\\,X_t\\,\\star\\,dW_t, \n$$\n其中 $X_t$ 是一个实值状态，$\\alpha \\in \\mathbb{R}$ 是一个常数漂移系数，$\\beta \\in \\mathbb{R}$ 是一个常数扩散载荷，$W_t$ 是一个标准维纳 (Wiener) 过程，$\\star$ 表示伊藤 (Itô) 解释（写作 $dW_t$）或斯特拉托诺维奇 (Stratonovich) 解释（写作 $\\circ\\,dW_t$）。您的目标是从第一性原理出发，证明 $X_t$ 的长期几乎必然增长率为何依赖于解释，构建一个参数集使得稳定性结论相反，然后通过数值方法进行验证。\n\n您的推理起点：\n- 伊藤 (Itô) 积分和斯特拉托诺维奇 (Stratonovich) 积分的定义及其不同的链式法则。\n- 应用于足够光滑被积函数的、用于随机积分的伊藤 (Itô) 到斯特拉托诺维奇 (Stratonovich) 转换法则。\n- $X_t$ 的几乎必然长期增长率的定义，即当极限存在时，$\\frac{1}{T}\\ln|X_T|$ 在 $T \\to \\infty$ 时的极限。\n\n您的任务：\n1) 根据上述基本原理，并且不使用任何现成的“捷径”公式，推导出在伊藤 (Itô) 解释和斯特拉托诺维奇 (Stratonovich) 解释下，方程族 $dX_t = \\alpha X_t\\,dt + \\beta X_t\\,\\star\\,dW_t$ 的几乎必然长期增长率的显式表达式。\n2) 找出常数系数 $\\alpha$ 和 $\\beta$，使得伊藤 (Itô) 解释预测长期稳定到 $0$（负增长率），而斯特拉托诺维奇 (Stratonovich) 解释预测长期不稳定（正增长率）。使用您推导出的表达式，逻辑地解释您的选择。\n3) 实现两种数值格式来近似样本路径和经验增长率：\n   - 对于伊藤 (Itô) 解释：使用欧拉-丸山 (Euler–Maruyama) 法，应用于 $dX_t = \\alpha X_t\\,dt + \\beta X_t\\,dW_t$。\n   - 对于斯特拉托诺维奇 (Stratonovich) 解释：使用一种强 1 阶的斯特拉托诺维奇 (Stratonovich) 相容方法，例如随机休恩 (Heun) 法，应用于 $dX_t = \\alpha X_t\\,dt + \\beta X_t \\circ dW_t$。\n   使用单一路径（无系综平均），设 $X_0 = 1$，时间跨度为 $T$，均匀步长为 $\\Delta t$。使用固定的随机种子生成布朗增量 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$ 以确保可复现性。对每种解释，计算经验长期增长率 $\\widehat{g} = \\frac{1}{T}\\ln|X_T|$。\n\n4) 对每种解释，使用一个带有容差 $\\varepsilon$ 的三向决策进行数值稳定性分类：“稳定”（如果 $\\widehat{g}  -\\varepsilon$），“不稳定”（如果 $\\widehat{g} > \\varepsilon$），否则为“中性”。\n\n5) 将数值分类与您在任务 1) 中推导出的理论分类进行比较，并为每个测试案例返回一个表示是否一致的布尔值。\n\n所有测试案例使用的仿真参数：\n- 初始条件：$X_0 = 1$。\n- 时间跨度：$T = 1000$。\n- 时间步长：$\\Delta t = 10^{-3}$。\n- 分类容差：$\\varepsilon = 2\\times 10^{-2}$。\n- 伪随机数生成器种子：$12345$。\n- 此处不适用角度或物理单位。\n\n测试套件（五个案例），每个案例以 $(\\alpha, \\beta)$ 形式给出：\n- 案例 A（目标：相反稳定性）：$(\\alpha, \\beta) = (0.05, 0.4)$。\n- 案例 B（两者皆稳定）：$(\\alpha, \\beta) = (-0.05, 0.2)$。\n- 案例 C（两者皆不稳定）：$(\\alpha, \\beta) = (0.2, 0.1)$。\n- 案例 D（伊藤 (Itô) 接近中性边界）：$(\\alpha, \\beta) = (0.08, 0.4)$。\n- 案例 E（斯特拉托诺维奇 (Stratonovich) 接近中性边界）：$(\\alpha, \\beta) = (0.0, 0.4)$。\n\n所需输出：\n- 对每个案例，使用指定的数值格式计算两种解释下的经验增长率，用容差 $\\varepsilon$ 对其进行分类，与您在任务 1) 中的理论分类进行比较，并输出一个表示是否一致的布尔值。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[True,False,True,True,False]”）。\n\n关于数值实现的说明：\n- 对于应用于 $dX_t = \\alpha X_t\\,dt + \\beta X_t\\,dW_t$ 的伊藤 (Itô) 欧拉-丸山 (Euler–Maruyama) 步，在 $\\Delta t$ 上的单步更新（增量为 $\\Delta W$）是 $X_{n+1} = X_n + \\alpha X_n \\Delta t + \\beta X_n \\Delta W$。\n- 对于应用于 $dX_t = \\alpha X_t\\,dt + \\beta X_t \\circ dW_t$ 的斯特拉托诺维奇 (Stratonovich) 相容的随机休恩 (Heun) 步，首先构建预测子 $X_n^\\ast = X_n + \\alpha X_n \\Delta t + \\beta X_n \\Delta W$，然后 $X_{n+1} = X_n + \\tfrac{1}{2}\\left[\\alpha X_n + \\alpha X_n^\\ast\\right]\\Delta t + \\tfrac{1}{2}\\left[\\beta X_n + \\beta X_n^\\ast\\right]\\Delta W$。\n\n最终输出格式：\n- 一行包含 Python 风格的布尔值列表，顺序与上述五个测试案例完全一致，无空格，例如，“[True,True,False,True,True]”。",
            "solution": "所提出的问题是随机微积分和随机微分方程（SDEs）数值方法领域的一个有效练习。它具有科学依据，问题提法恰当，客观且完整。所有参数和方法都已明确指定，从而可以得出唯一且可复现的解。我将着手进行推导和数值验证。\n\n问题的核心是几何布朗运动的随机微分方程：\n$$\ndX_t = \\alpha\\,X_t\\,dt + \\beta\\,X_t\\,\\star\\,dW_t\n$$\n其中 $\\alpha, \\beta \\in \\mathbb{R}$ 是常数系数，$W_t$ 是一个标准维纳 (Wiener) 过程，$\\star$ 表示随机积分可以按伊藤 (Itô) 或斯特拉托诺维奇 (Stratonovich) 的意义来解释。我们的任务是证明解释的选择可以导致关于解 $X_t$ 长期稳定性的不同结论。稳定性通过几乎必然长期增长率来评估，定义为 $g = \\lim_{T \\to \\infty} \\frac{1}{T}\\ln|X_T|$。\n\n我们将推导每种解释下的增长率，找出使稳定性结论相反的参数，然后对这些理论发现进行数值验证。\n\n**任务 1：长期增长率的推导**\n\n为了分析 $X_t$ 的长期行为，我们研究 $Y_t = \\ln(X_t)$ 的动态。由于初始条件为 $X_0 = 1  0$ 且随机微分方程是线性的，解 $X_t$ 不会穿过零，因此我们可以使用 $\\ln(X_t)$ 而不是 $\\ln|X_t|$。我们对函数 $f(x) = \\ln(x)$（其导数为 $f'(x) = 1/x$ 和 $f''(x) = -1/x^2$）应用每种解释对应的链式法则。\n\n**伊藤 (Itô) 解释**\n\n随机微分方程为 $dX_t = \\alpha X_t dt + \\beta X_t dW_t$。我们对 $Y_t = f(X_t)$ 应用伊藤 (Itô) 引理：\n$$\ndY_t = f'(X_t)dX_t + \\frac{1}{2}f''(X_t)(dX_t)^2\n$$\n二次变分项 $(dX_t)^2$ 使用乘法规则 $dt \\cdot dt = 0$, $dt \\cdot dW_t = 0$ 和 $dW_t \\cdot dW_t = dt$ 计算。\n$$\n(dX_t)^2 = (\\alpha X_t dt + \\beta X_t dW_t)^2 = \\beta^2 X_t^2 (dW_t)^2 = \\beta^2 X_t^2 dt\n$$\n将导数和 $(dX_t)^2$ 代入引理：\n$$\ndY_t = \\frac{1}{X_t}(\\alpha X_t dt + \\beta X_t dW_t) + \\frac{1}{2}\\left(-\\frac{1}{X_t^2}\\right)(\\beta^2 X_t^2 dt)\n$$\n$$\ndY_t = (\\alpha dt + \\beta dW_t) - \\frac{1}{2}\\beta^2 dt = \\left(\\alpha - \\frac{1}{2}\\beta^2\\right)dt + \\beta dW_t\n$$\n从 $t=0$ 到 $t=T$ 积分：\n$$\nY_T - Y_0 = \\int_{0}^{T}\\left(\\alpha - \\frac{1}{2}\\beta^2\\right)ds + \\int_{0}^{T}\\beta dW_s = \\left(\\alpha - \\frac{1}{2}\\beta^2\\right)T + \\beta W_T\n$$\n由于 $X_0 = 1$，我们有 $Y_0 = \\ln(1) = 0$。因此，$\\ln(X_T) = (\\alpha - \\frac{1}{2}\\beta^2)T + \\beta W_T$。那么几乎必然长期增长率为：\n$$\ng_{\\text{Itô}} = \\lim_{T \\to \\infty} \\frac{1}{T}\\ln(X_T) = \\lim_{T \\to \\infty} \\left[ \\left(\\alpha - \\frac{1}{2}\\beta^2\\right) + \\beta \\frac{W_T}{T} \\right]\n$$\n根据重对数律，$\\lim_{T \\to \\infty} W_T/T = 0$ 几乎必然成立。因此，增长率为：\n$$\ng_{\\text{Itô}} = \\alpha - \\frac{1}{2}\\beta^2\n$$\n\n**斯特拉托诺维奇 (Stratonovich) 解释**\n\n随机微分方程为 $dX_t = \\alpha X_t dt + \\beta X_t \\circ dW_t$。斯特拉托诺维奇 (Stratonovich) 链式法则与普通链式法则形式相同：$d(f(X_t)) = f'(X_t) \\circ dX_t$。\n将其应用于 $Y_t = \\ln(X_t)$：\n$$\ndY_t = \\frac{1}{X_t} \\circ dX_t = \\frac{1}{X_t} \\circ (\\alpha X_t dt + \\beta X_t \\circ dW_t) = \\alpha dt + \\beta \\circ dW_t\n$$\n从 $t=0$ 到 $t=T$ 积分：\n$$\nY_T - Y_0 = \\int_{0}^{T} \\alpha ds + \\int_{0}^{T} \\beta \\circ dW_s = \\alpha T + \\beta W_T\n$$\n由于 $Y_0=0$，我们有 $\\ln(X_T) = \\alpha T + \\beta W_T$。增长率为：\n$$\ng_{\\text{Stratonovich}} = \\lim_{T \\to \\infty} \\frac{1}{T}\\ln(X_T) = \\lim_{T \\to \\infty} \\left[ \\alpha + \\beta \\frac{W_T}{T} \\right] = \\alpha\n$$\n这一结果可以通过将斯特拉托诺维奇 (Stratonovich) SDE 转换为其等价的伊藤 (Itô) SDE 来证实。修正项为 $\\frac{1}{2} b(x) b'(x)$，其中 $b(x) = \\beta x$。这得到 $\\frac{1}{2}(\\beta x)(\\beta) = \\frac{1}{2}\\beta^2 x$。等价的伊藤 (Itô) SDE 是 $dX_t = (\\alpha X_t + \\frac{1}{2}\\beta^2 X_t) dt + \\beta X_t dW_t$。此伊藤 (Itô) 形式的漂移系数是 $\\alpha' = \\alpha + \\frac{1}{2}\\beta^2$。使用伊藤 (Itô) 增长率公式 $g = \\alpha' - \\frac{1}{2}\\beta^2$，我们得到 $g = (\\alpha + \\frac{1}{2}\\beta^2) - \\frac{1}{2}\\beta^2 = \\alpha$，这与之前的结果一致。\n\n**任务 2：确定导致相反稳定性的参数**\n\n我们寻找参数 $(\\alpha, \\beta)$，使得 $g_{\\text{Itô}}$ 和 $g_{\\text{Stratonovich}}$ 的符号相反，从而导致不同的稳定性结论。我们要求伊藤 (Itô) 系统是稳定的（$g  0$），而斯特拉托诺维奇 (Stratonovich) 系统是不稳定的（$g > 0$）。\n1.  在斯特拉托诺维奇 (Stratonovich) 解释下不稳定：$g_{\\text{Stratonovich}} = \\alpha > 0$。\n2.  在伊藤 (Itô) 解释下稳定：$g_{\\text{Itô}} = \\alpha - \\frac{1}{2}\\beta^2  0$。\n\n这两个条件结合起来得到不等式 $0  \\alpha  \\frac{1}{2}\\beta^2$。任何满足此条件的 $(\\alpha, \\beta)$ 对都将产生所期望的相反稳定性行为。问题提供了案例 A，其参数为 $(\\alpha, \\beta) = (0.05, 0.4)$。我们来检验这个选择。\n这里，$\\alpha = 0.05$ 且 $\\frac{1}{2}\\beta^2 = \\frac{1}{2}(0.4)^2 = 0.08$。条件 $0  0.05  0.08$ 得到满足。\n对于这些参数：\n- $g_{\\text{Itô}} = 0.05 - 0.08 = -0.03  0$，预测为稳定（$\\lim_{t\\to\\infty}X_t = 0$）。\n- $g_{\\text{Stratonovich}} = 0.05 > 0$，预测为不稳定（$\\lim_{t\\to\\infty}X_t = \\infty$）。\n参数的选择是合乎逻辑的，并正确地阐释了这一现象。\n\n**任务 3、4 和 5：数值验证**\n\n现在我们将实现数值格式，并对给定的测试套件验证理论分类。该实现将对伊藤 (Itô) SDE 使用欧拉-丸山 (Euler-Maruyama) 法，对斯特拉托诺维奇 (Stratonovich) SDE 使用随机休恩 (Heun) 法。我们将生成一个维纳 (Wiener) 过程的单一样本路径，并将其用于每个测试案例的两种仿真中，以确保直接比较。数值增长率计算为 $\\widehat{g} = \\frac{1}{T}\\ln|X_T|$。通过将 $\\widehat{g}$ 与容差 $\\varepsilon = 2 \\times 10^{-2}$ 进行比较来对稳定性进行数值分类。数值分类将与从 $g_{\\text{Itô}}$ 和 $g_{\\text{Stratonovich}}$ 公式推导出的理论分类（使用相同的容差 $\\varepsilon$）进行比较。每个案例的最终输出是一个布尔值，当且仅当两种数值分类都与它们对应的理论分类相匹配时，该值为 `True`。\n\n五个测试案例的理论分类如下，使用的规则是：“稳定”（如果 $g  -0.02$），“不稳定”（如果 $g > 0.02$），否则为“中性”。\n\n- **案例 A** $(\\alpha, \\beta) = (0.05, 0.4)$:\n  $g_{\\text{Itô}} = -0.03$ (稳定), $g_{\\text{Stratonovich}} = 0.05$ (不稳定)。\n- **案例 B** $(\\alpha, \\beta) = (-0.05, 0.2)$:\n  $g_{\\text{Itô}} = -0.05 - 0.5(0.2)^2 = -0.07$ (稳定), $g_{\\text{Stratonovich}} = -0.05$ (稳定)。\n- **案例 C** $(\\alpha, \\beta) = (0.2, 0.1)$:\n  $g_{\\text{Itô}} = 0.2 - 0.5(0.1)^2 = 0.195$ (不稳定), $g_{\\text{Stratonovich}} = 0.2$ (不稳定)。\n- **案例 D** $(\\alpha, \\beta) = (0.08, 0.4)$:\n  $g_{\\text{Itô}} = 0.08 - 0.5(0.4)^2 = 0.0$ (中性), $g_{\\text{Stratonovich}} = 0.08$ (不稳定)。\n- **案例 E** $(\\alpha, \\beta) = (0.0, 0.4)$:\n  $g_{\\text{Itô}} = 0.0 - 0.5(0.4)^2 = -0.08$ (稳定), $g_{\\text{Stratonovich}} = 0.0$ (中性)。\n\n最终答案中的代码将执行仿真和比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the stability of a linear SDE under Itô and Stratonovich\n    interpretations, comparing theoretical predictions with numerical simulations.\n    \"\"\"\n\n    # --- Simulation Parameters ---\n    X0 = 1.0\n    T = 1000.0\n    dt = 1e-3\n    epsilon = 2e-2\n    seed = 12345\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.05, 0.4),   # Case A\n        (-0.05, 0.2),  # Case B\n        (0.2, 0.1),    # Case C\n        (0.08, 0.4),   # Case D\n        (0.0, 0.4),    # Case E\n    ]\n\n    # --- Generate Wiener Path ---\n    # The same path is used for all test cases and both interpretations\n    # to ensure consistency and reproducibility.\n    num_steps = int(T / dt)\n    rng = np.random.default_rng(seed)\n    dW = rng.normal(0.0, np.sqrt(dt), num_steps)\n\n    def classify_stability(g, eps):\n        \"\"\"Classifies stability based on growth rate g and tolerance eps.\"\"\"\n        if g  -eps:\n            return \"stable\"\n        if g > eps:\n            return \"unstable\"\n        return \"neutral\"\n\n    results = []\n    for alpha, beta in test_cases:\n        # --- 1. Theoretical Classification ---\n        g_ito_theo = alpha - 0.5 * beta**2\n        g_strato_theo = alpha\n\n        theo_class_ito = classify_stability(g_ito_theo, epsilon)\n        theo_class_strato = classify_stability(g_strato_theo, epsilon)\n\n        # --- 2. Numerical Simulation: Itô (Euler-Maruyama) ---\n        x_ito = X0\n        for i in range(num_steps):\n            x_ito = x_ito * (1.0 + alpha * dt + beta * dW[i])\n\n        # Compute and classify empirical growth rate\n        g_ito_num = np.log(np.abs(x_ito)) / T if x_ito != 0 else -np.inf\n        num_class_ito = classify_stability(g_ito_num, epsilon)\n\n        # --- 3. Numerical Simulation: Stratonovich (Heun) ---\n        x_strato = X0\n        for i in range(num_steps):\n            # Predictor step\n            x_pred = x_strato * (1.0 + alpha * dt + beta * dW[i])\n            # Corrector step\n            x_strato = x_strato \\\n                + 0.5 * (alpha * x_strato + alpha * x_pred) * dt \\\n                + 0.5 * (beta * x_strato + beta * x_pred) * dW[i]\n\n        # Compute and classify empirical growth rate\n        g_strato_num = np.log(np.abs(x_strato)) / T if x_strato != 0 else -np.inf\n        num_class_strato = classify_stability(g_strato_num, epsilon)\n\n        # --- 4. Comparison ---\n        # Agreement is True if both numerical classifications match their\n        # theoretical counterparts.\n        agreement = (theo_class_ito == num_class_ito) and \\\n                    (theo_class_strato == num_class_strato)\n        results.append(agreement)\n\n    # --- Final Output ---\n    # Must be a single line with a list of booleans, as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在金融工程中，理论模型的数值实现往往需要在精度和效率之间做出艰难的抉择。本练习  将你置于量化分析师的角色，任务是在固定的计算预算下，为欧式期权的蒙特卡洛定价寻找最优的时间步长 $\\Delta t$。你将通过系统的数值实验，量化并权衡离散化带来的偏差（bias）和蒙特卡洛抽样引入的方差（variance），最终通过最小化均方误差来确定最佳策略。这项实践将理论误差分析与计算金融的实际约束相结合，锻炼了解决复杂优化问题的核心能力。",
            "id": "2415926",
            "problem": "设计并实现一个完整的程序，该程序执行一个有原则的、基于模拟的最优时间步长 $\\Delta t$ 选择，用于在几何布朗运动 (GBM) 模型下对欧式看涨期权价格进行蒙特卡洛估计。该方法必须量化并平衡减小 $\\Delta t$ 会降低离散化偏差，但对于固定的计算预算会增加计算成本这一权衡。\n\n您必须在以下严格的规范内工作。\n\n模型和估计器定义：\n- 在风险中性测度下，资产动态由随机微分方程 (SDE) $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$ 给出，初始条件为 $S_0  0$，在时间范围 $[0,T]$ 内具有恒定的无风险利率 $r \\ge 0$ 和恒定的波动率 $\\sigma \\ge 0$。过程 $W_t$ 是一个标准维纳过程。\n- 目标量是一个欧式看涨期权的无套利价格，其敲定价格为 $K$，到期日为 $T$，收益为 $f(S_T) = \\max(S_T - K, 0)$，并以无风险利率贴现。精确的参考价格是经典的 Black–Scholes 解析解值，您必须计算此值作为基准真实值。\n- 数值估计器必须使用欧拉-丸山格式来离散化 SDE，在 $[0,T]$ 上使用一个包含 $N$ 个步骤的均匀网格，其中 $N = T / \\Delta t$ 是一个整数，时间步长为 $\\Delta t = T/N$。从$S_k$ 到 $S_{k+1}$的一个欧拉-丸山步骤是 $S_{k+1} = S_k + r S_k \\Delta t + \\sigma S_k \\sqrt{\\Delta t} Z_k$，其中 $Z_k \\sim \\mathcal{N}(0,1)$ 是独立同分布的。对于每个模拟路径，贴现后的收益为 $\\exp(-rT)\\max(S_N - K, 0)$，蒙特卡洛估计器是$M$条独立路径的样本均值。\n\n成本模型和预算约束：\n- 计算成本定义为在所有路径上模拟的欧拉-丸山时间步长的总数，对于给定的$N$选择，该成本等于$M \\times N$。对于每个测试用例，您将获得一个硬性预算 $C_{\\max}$（以欧拉步数计）。您必须通过为任何候选$N$选择$M = \\max\\{1, \\lfloor C_{\\max}/N \\rfloor\\}$来强制执行约束 $M \\times N \\le C_{\\max}$。\n\n误差度量和经验风险最小化：\n- 对于一个固定的$\\Delta t$（等效于$N$）及其隐含的$M$，将单次运行的估计器 $\\hat{V}$ 定义为使用 $M$ 条路径的贴现收益的蒙特卡洛样本均值。\n- 使用精确的 Black–Scholes 值 $V^\\star$ 作为基准真实值。对于单次运行，将平方误差定义为 $(\\hat{V} - V^\\star)^2$。\n- 为了在比较不同的 $\\Delta t$ 时减少随机性，通过对$R$次独立重复实验的平方误差进行平均来估计给定 $\\Delta t$ 的均方误差 (MSE)。每次重复实验都有全新的随机性，但使用相同的$M$和$N$。也就是说，对于每个候选 $\\Delta t$，计算 $\\widehat{\\mathrm{MSE}}(\\Delta t) = \\frac{1}{R}\\sum_{i=1}^R (\\hat{V}^{(i)} - V^\\star)^2$。\n- 最优时间步长是在提供的有限候选集上最小化 $\\widehat{\\mathrm{MSE}}(\\Delta t)$ 的那个 $\\Delta t$。如果出现数值上的并列（值在绝对容差 $\\varepsilon = 10^{-12}$ 内相等），则选择并列项中最大的 $\\Delta t$。\n\n实现约束：\n- 仅使用欧拉-丸山格式；不要使用 GBM 的精确离散化进行模拟。\n- 在每次重复实验中，跨时间和路径使用独立的标准正态抽样；在进行平均时使用独立的重复实验。\n- 对于每个测试用例，评估一个预先规定的有限候选步长集合 $\\{\\Delta t_j\\}$，每个 $\\Delta t_j$ 都构建为 $\\Delta t_j = T/N_j$，其中 $N_j \\in \\mathbb{N}$ 在下方提供。\n\n测试套件：\n- 对于每个测试用例，返回在预算下最小化估计 MSE 所选的 $\\Delta t$，作为一个以年为单位的浮点数。\n- 每个候选步长恰好使用 $R = 12$ 次重复实验。\n- 为保证数值稳定性和可复现性，您必须以一种确定性的方式固定所有随机数生成器的种子，这种方式不依赖于执行环境中指定的语言和库之外的库或平台特性。\n\n参数和候选集：\n- 情况 A (理想情况)：\n  - $S_0 = 100$, $K = 100$, $r = 0.05$, $\\sigma = 0.20$, $T = 1.0$, $C_{\\max} = 100{,}000$。\n  - 候选步数 $N \\in \\{8, 16, 32, 64, 128\\}$，因此 $\\Delta t \\in \\{T/8, T/16, T/32, T/64, T/128\\}$。\n- 情况 B (低波动率和较短到期日)：\n  - $S_0 = 100$, $K = 100$, $r = 0.02$, $\\sigma = 0.05$, $T = 0.5$, $C_{\\max} = 50{,}000$。\n  - 候选步数 $N \\in \\{4, 8, 16, 32, 64\\}$，因此 $\\Delta t \\in \\{T/4, T/8, T/16, T/32, T/64\\}$。\n- 情况 C (高波动率和较长到期日)：\n  - $S_0 = 100$, $K = 110$, $r = 0.03$, $\\sigma = 0.60$, $T = 2.0$, $C_{\\max} = 150{,}000$。\n  - 候选步数 $N \\in \\{8, 16, 32, 64, 128\\}$，因此 $\\Delta t \\in \\{T/8, T/16, T/32, T/64, T/128\\}$。\n\n最终输出格式：\n- 您的程序必须输出一行，其中包含一个 Python 风格的列表，列表内有三个浮点数，按顺序分别对应情况 A、情况 B 和情况 C 所选的 $\\Delta t$（以年为单位）。\n- 每个 $\\Delta t$ 必须精确到 $6$ 位小数。\n- 输出不能有任何额外的文本。例如，语法形式必须像 $\\texttt{[a,b,c]}$。\n\n您提交的必须是一个完整的、可运行的程序，该程序执行所有指定的计算并打印所需的单行输出。",
            "solution": "该问题要求设计一个程序来选择一个最优的时间步长 $\\Delta t$，用于欧式看涨期权价格的数值模拟。该选择必须基于在固定计算预算下最小化蒙特卡洛估计器的均方误差 (MSE)。这项任务体现了计算科学中的一个基本权衡：离散化误差和统计误差之间的平衡。\n\n基础金融模型是一个不支付股息股票的几何布朗运动 (GBM)，在风险中性测度 $\\mathbb{Q}$ 下，由以下随机微分方程 (SDE) 描述：\n$$\ndS_t = r S_t \\, dt + \\sigma S_t \\, dW_t\n$$\n在这里，$S_t$ 是资产在时间 $t$ 的价格，$r$ 是恒定的无风险利率，$\\sigma$ 是恒定的波动率，$W_t$ 是在 $\\mathbb{Q}$ 下的标准维纳过程。\n\n我们估计的目标是在时间 $t=0$ 的欧式看涨期权价格，由到期日 $T$ 的贴现预期收益给出：\n$$\nV(S_0, 0) = \\mathbb{E}^{\\mathbb{Q}}[\\exp(-rT) \\max(S_T - K, 0) | S_0]\n$$\n其中 $K$ 是敲定价格。这个理论价格，记为 $V^\\star$，作为我们的基准真实值，由 Black-Scholes 公式给出：\n$$\nV^\\star = S_0 \\Phi(d_1) - K \\exp(-rT) \\Phi(d_2)\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} \\quad \\text{和} \\quad d_2 = d_1 - \\sigma\\sqrt{T}\n$$\n在这里，$\\Phi(\\cdot)$ 代表标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数 (CDF)。\n\n数值估计器是使用欧拉-丸山格式在均匀时间网格 $0 = t_0  t_1  \\dots  t_N = T$ 上离散化 SDE 来构建的，其中 $t_k = k \\Delta t$，时间步长为 $\\Delta t = T/N$。资产价格的离散时间演化为：\n$$\nS_{k+1} = S_k(1 + r \\Delta t + \\sigma \\sqrt{\\Delta t} Z_k)\n$$\n对于 $k = 0, 1, \\dots, N-1$，其中 $Z_k$ 是从 $\\mathcal{N}(0,1)$ 中抽取的独立同分布的随机变量。\n\n单条蒙特卡洛模拟路径会生成一个最终资产价格 $S_N$。期权价格通过对 $M$ 条独立路径的贴现收益进行平均来估计：\n$$\n\\hat{V} = \\frac{1}{M} \\sum_{j=1}^{M} \\exp(-rT) \\max(S_N^{(j)} - K, 0)\n$$\n总计算成本定义为 $C = M \\times N$。固定的预算 $C_{\\max}$ 施加了约束 $M \\times N \\le C_{\\max}$。对于选定的时间步数 $N$，模拟路径数 $M$ 在此预算下被最大化：$M = \\max\\{1, \\lfloor C_{\\max}/N \\rfloor\\}$。\n\n问题的核心在于分析估计器 $\\hat{V}$ 相对于真实值 $V^\\star$ 的均方误差 (MSE)：\n$$\n\\text{MSE}(\\Delta t) = \\mathbb{E}[(\\hat{V} - V^\\star)^2] = (\\mathbb{E}[\\hat{V}] - V^\\star)^2 + \\text{Var}(\\hat{V})\n$$\nMSE 分解为两个部分：\n1.  偏差的平方，$(\\mathbb{E}[\\hat{V}] - V^\\star)^2$：该项捕捉了由欧拉-丸山离散化引入的系统性误差。该格式的弱误差为 $O(\\Delta t)$ 阶，因此偏差的平方近似与 $(\\Delta t)^2$ 成正比。增加 $N$（减小 $\\Delta t$）会减少此偏差。\n2.  方差，$\\text{Var}(\\hat{V})$：该项捕捉了蒙特卡洛抽样产生的统计误差。它由 $\\frac{1}{M} \\text{Var}(\\exp(-rT)\\max(S_N - K, 0))$ 给出。由于 $M \\approx C_{\\max}/N = C_{\\max} \\Delta t / T$，方差近似与 $1/M$ 成正比，因此与 $N$ 或 $1/\\Delta t$ 成反比。增加 $N$（减小 $\\Delta t$）需要相应减少 $M$ 以保持在预算内，这会增加方差。\n\n这就建立了一个基本的权衡关系：减小 $\\Delta t$ 会降低离散化偏差，但会增加统计方差。最优的 $\\Delta t$ 是使总 MSE 最小化的那一个。\n\n指定的算法是一个经验风险最小化过程。由于真实的 MSE 是未知的，我们对其进行估计。对于每个候选时间步长 $\\Delta t_j$（对应 $N_j=T/\\Delta t_j$），我们计算一个经验 MSE，即 $\\widehat{\\mathrm{MSE}}(\\Delta t_j)$。这是通过对整个蒙特卡洛估计过程执行 $R$ 次独立重复实验来完成的。对于每次重复实验 $i \\in \\{1, \\dots, R\\}$，都会模拟一组新的 $M$ 条路径来产生一个估计值 $\\hat{V}^{(i)}$。然后，经验 MSE 为：\n$$\n\\widehat{\\mathrm{MSE}}(\\Delta t_j) = \\frac{1}{R} \\sum_{i=1}^{R} (\\hat{V}^{(i)} - V^\\star)^2\n$$\n$R$ 的值固定为 12。对 $R$ 次重复实验进行平均，为给定的 $\\Delta t_j$ 提供了一个比单次平方误差测量更稳定的 MSE 估计。\n\n最后一步是从给定的有限候选集 $\\{\\Delta t_j\\}$ 中选择最优的 $\\Delta t$。算法遍历每个候选者，计算其 $\\widehat{\\mathrm{MSE}}$，并识别出达到的最小 $\\widehat{\\mathrm{MSE}}$ 值。选择相应的 $\\Delta t_j$。指定了一个打破并列的规则：如果多个候选者产生的 MSE 值在数值容差 $\\varepsilon = 10^{-12}$ 内与最小值相等，则选择具有最大 $\\Delta t$（最小 $N$）的那个。这是一个明智的启发式方法，因为它在性能相当的选项中倾向于计算成本更低的一个。\n\n在实现上，所有 $M$ 条路径的模拟都使用 NumPy 中的向量化操作同时执行，以获得卓越的性能。为确保可复现性，随机数生成器被确定性地设置种子。对于每个测试用例，使用一个基础种子。由此为每个候选 $N$ 和 $R$ 次重复实验中的每一次生成唯一且确定性的种子，确保随机性在所有不同的估计任务中是受控且独立的。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\n#\n# MIT License\n#\n# Copyright (c) 2024, The Strict Russian Professor\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n\ndef black_scholes_call(S0, K, T, r, sigma):\n    \"\"\"\n    Computes the Black-Scholes price for a European call option.\n    \"\"\"\n    if sigma == 0:\n        return np.maximum(0.0, S0 * np.exp(r * T) - K) * np.exp(-r * T)\n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef vectorized_monte_carlo(S0, K, T, r, sigma, N, M, rng):\n    \"\"\"\n    Estimates European call option price using a vectorized Euler-Maruyama simulation.\n    \"\"\"\n    dt = T / N\n    S = np.full(M, S0, dtype=np.float64)\n\n    for _ in range(N):\n        Z = rng.standard_normal(size=M)\n        S = S * (1 + r * dt + sigma * np.sqrt(dt) * Z)\n\n    payoffs = np.maximum(S - K, 0)\n    discounted_mean_payoff = np.exp(-r * T) * np.mean(payoffs)\n    return discounted_mean_payoff\n\ndef estimate_mse(S0, K, T, r, sigma, C_max, N, R, V_star, base_seed):\n    \"\"\"\n    Estimates the Mean Squared Error for a given N by averaging over R replications.\n    \"\"\"\n    M = max(1, C_max // N)\n    squared_errors = []\n\n    for i in range(R):\n        seed = base_seed + i\n        rng = np.random.default_rng(seed)\n        V_hat = vectorized_monte_carlo(S0, K, T, r, sigma, N, M, rng)\n        sq_err = (V_hat - V_star)**2\n        squared_errors.append(sq_err)\n\n    return np.mean(squared_errors)\n\ndef find_optimal_dt(S0, K, T, r, sigma, C_max, N_candidates, case_base_seed):\n    \"\"\"\n    Finds the optimal time step dt by minimizing empirical MSE over a set of candidates.\n    \"\"\"\n    R = 12\n    V_star = black_scholes_call(S0, K, T, r, sigma)\n    \n    mse_results = []\n    \n    for i, N in enumerate(N_candidates):\n        # Assign a unique, deterministic block of seeds for each candidate N\n        N_base_seed = case_base_seed + i * R\n        \n        mse = estimate_mse(S0, K, T, r, sigma, C_max, N, R, V_star, N_base_seed)\n        dt = T / N\n        mse_results.append({'mse': mse, 'dt': dt})\n\n    min_mse = min(res['mse'] for res in mse_results)\n    \n    tolerance = 1e-12\n    \n    # Filter for candidates that are within the tolerance of the minimum MSE\n    minimizers = [res for res in mse_results if abs(res['mse'] - min_mse)  tolerance]\n    \n    # Tie-breaking: select the largest dt among the minimizers\n    optimal_dt = max(res['dt'] for res in minimizers)\n    \n    return optimal_dt\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        {   # Case A\n            'params': {'S0': 100.0, 'K': 100.0, 'T': 1.0, 'r': 0.05, 'sigma': 0.20},\n            'C_max': 100000,\n            'N_candidates': [8, 16, 32, 64, 128],\n            'seed': 1234\n        },\n        {   # Case B\n            'params': {'S0': 100.0, 'K': 100.0, 'T': 0.5, 'r': 0.02, 'sigma': 0.05},\n            'C_max': 50000,\n            'N_candidates': [4, 8, 16, 32, 64],\n            'seed': 5678\n        },\n        {   # Case C\n            'params': {'S0': 100.0, 'K': 110.0, 'T': 2.0, 'r': 0.03, 'sigma': 0.60},\n            'C_max': 150000,\n            'N_candidates': [8, 16, 32, 64, 128],\n            'seed': 9101\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        optimal_dt = find_optimal_dt(\n            S0=case['params']['S0'],\n            K=case['params']['K'],\n            T=case['params']['T'],\n            r=case['params']['r'],\n            sigma=case['params']['sigma'],\n            C_max=case['C_max'],\n            N_candidates=case['N_candidates'],\n            case_base_seed=case['seed']\n        )\n        final_results.append(optimal_dt)\n        \n    print(f\"[{','.join(f'{res:.6f}' for res in final_results)}]\")\n\nsolve()\n```"
        }
    ]
}