{
    "hands_on_practices": [
        {
            "introduction": "This practice introduces Richardson Extrapolation, a powerful method for systematically improving the accuracy of your numerical results. By combining two Crank-Nicolson solutions computed with different time steps, you can eliminate the leading-order error term and achieve a more precise valuation. This exercise () highlights the practical importance of understanding error structures and provides a valuable tool for accelerating the convergence of your financial models.",
            "id": "2439320",
            "problem": "Consider the Black–Scholes partial differential equation for the value $V(S,t)$ of a European call option under risk-neutral dynamics:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\nfor asset price $S \\ge 0$ and time $t \\in [0,T]$, with terminal condition at maturity $T$ given by the payoff\n$$\nV(S,T) = \\max(S-K,0),\n$$\nand boundary conditions (for all $t \\in [0,T]$)\n$$\nV(0,t) = 0, \\quad V(S_{\\max},t) = S_{\\max} - K e^{-r(T-t)}.\n$$\nAll rates and volatilities must be treated as decimals (for example, $5\\%$ must be input as $0.05$). Angles do not appear in this problem. No physical units are involved. Let $S_{\\max}$ be a finite truncation of the asset domain, chosen large enough to make the truncation error negligible relative to the discretization errors under consideration.\n\nYou must write a complete program that:\n- Computes two numerical solutions to the above problem using the Crank–Nicolson method on the same uniform asset grid with a common number of spatial steps $M$ but with two different time step counts $N$ and $2N$ (i.e., time steps $\\Delta t = T/N$ and $\\Delta t/2 = T/(2N)$).\n- From the two numerical solutions at time $t=0$, applies Richardson extrapolation in time to combine the two solutions into an extrapolated value at $t=0$ that eliminates the leading-order time discretization error.\n- Computes the corresponding analytical Black–Scholes formula value at $t=0$ for a European call,\n$$\nC_{\\mathrm{BS}}(S_0,K,r,\\sigma,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2),\n$$\nwith\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2) T}{\\sigma \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma \\sqrt{T},\n$$\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function of the standard normal distribution.\n- Quantifies the absolute errors of the coarse-time-step numerical value, the fine-time-step numerical value, and the Richardson-extrapolated value against the analytical value at $t=0$ and $S=S_0$.\n- Reports, for each test case, two accuracy improvement factors as real numbers: the ratio of the coarse-step absolute error to the extrapolated absolute error, and the ratio of the fine-step absolute error to the extrapolated absolute error.\n\nUse the same uniform asset grid for both time step counts for each test case, and obtain the $t=0$ value at $S=S_0$ by linear interpolation on the asset grid. All outputs must be real numbers.\n\nTest suite:\n- Test case $1$: $S_0=100$, $K=100$, $r=0.03$, $\\sigma=0.25$, $T=1.0$, $S_{\\max}=5K$, $M=800$, $N=200$.\n- Test case $2$: $S_0=80$, $K=100$, $r=0.01$, $\\sigma=0.15$, $T=0.25$, $S_{\\max}=5K$, $M=800$, $N=120$.\n- Test case $3$: $S_0=120$, $K=100$, $r=0.00$, $\\sigma=0.05$, $T=2.0$, $S_{\\max}=6K$, $M=900$, $N=240$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case in the order listed above, output five real numbers in this order: the absolute error using $N$ time steps, the absolute error using $2N$ time steps, the absolute error after Richardson extrapolation, the improvement factor defined as the ratio of the $N$-step absolute error to the extrapolated absolute error, and the improvement factor defined as the ratio of the $2N$-step absolute error to the extrapolated absolute error. Aggregate the values for all three test cases into one flat list in the same order. For example, the output format must be\n$[e_{1,N}, e_{1,2N}, e_{1,\\mathrm{RE}}, \\rho_{1,N\\to \\mathrm{RE}}, \\rho_{1,2N\\to \\mathrm{RE}}, e_{2,N}, e_{2,2N}, e_{2,\\mathrm{RE}}, \\rho_{2,N\\to \\mathrm{RE}}, \\rho_{2,2N\\to \\mathrm{RE}}, e_{3,N}, e_{3,2N}, e_{3,\\mathrm{RE}}, \\rho_{3,N\\to \\mathrm{RE}}, \\rho_{3,2N\\to \\mathrm{RE}}]$.",
            "solution": "The problem requires the numerical solution of the Black–Scholes partial differential equation (PDE) for a European call option, using the Crank–Nicolson finite difference method. This solution is then improved using Richardson extrapolation and compared against the analytical Black–Scholes formula to quantify accuracy.\n\nThe governing Black–Scholes PDE is given by:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nwhere $V(S,t)$ is the option value at asset price $S$ and time $t$, $\\sigma$ is the volatility, $r$ is the risk-free interest rate, $K$ is the strike price, and $T$ is the maturity time. The problem is defined for $S \\ge 0$ and $t \\in [0,T]$.\n\nThis is a terminal value problem, with the condition at $t=T$ given by the payoff function:\n$$\nV(S,T) = \\max(S-K, 0)\n$$\nTo transform this into an initial value problem, we introduce a new time variable $\\tau = T-t$. As $t$ goes from $0$ to $T$, $\\tau$ goes from $T$ to $0$. The time derivative transforms as $\\partial/\\partial t = -\\partial/\\partial \\tau$. The PDE becomes a forward parabolic equation in $\\tau$:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\nwith the initial condition at $\\tau=0$:\n$$\nV(S,0) = \\max(S-K, 0)\n$$\nand boundary conditions for $\\tau \\in [0,T]$:\n$$\nV(0,\\tau) = 0 \\quad \\text{and} \\quad V(S_{\\max},\\tau) = S_{\\max} - K e^{-r\\tau}\n$$\nHere, $t$ has been replaced by $T-\\tau$ in the original boundary condition for $V(S_{\\max},t)$. The domain for $S$ is truncated to $[0, S_{\\max}]$.\n\nWe discretize the problem domain. The asset price domain $[0, S_{\\max}]$ is divided into $M$ uniform intervals of width $\\Delta S = S_{\\max}/M$, creating grid points $S_i = i \\Delta S$ for $i=0, 1, \\dots, M$. The time domain $[0,T]$ is divided into $N$ intervals of width $\\Delta \\tau = T/N$, with time steps $\\tau_j = j \\Delta \\tau$ for $j=0, 1, \\dots, N$. Let $V_i^j$ denote the numerical approximation of $V(S_i, \\tau_j)$.\n\nThe Crank–Nicolson method approximates the time derivative at the midpoint of a time interval, $\\tau_{j+1/2}$, and averages the spatial derivative operator over time levels $j$ and $j+1$:\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left[ (\\mathcal{L}_h V^{j+1})_i + (\\mathcal{L}_h V^j)_i \\right]\n$$\nwhere $\\mathcal{L}_h$ is the finite difference approximation of the spatial differential operator $\\mathcal{L} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + r S \\frac{\\partial}{\\partial S} - r$. We use second-order central differences for the spatial derivatives:\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\qquad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\nSubstituting these into the operator $\\mathcal{L}_h$ yields:\n$$\n(\\mathcal{L}_h V)_i = \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} - \\frac{r S_i}{2\\Delta S}\\right) V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{(\\Delta S)^2} - r\\right) V_i + \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} + \\frac{r S_i}{2\\Delta S}\\right) V_{i+1}\n$$\nRearranging the Crank-Nicolson scheme separates the unknown values at time level $j+1$ (on the left-hand side) from the known values at time level $j$ (on the right-hand side):\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\nThis forms a system of linear equations for the interior grid points $i=1, \\dots, M-1$. The equation for each interior point $i$ is:\n$$\n-\\alpha_i V_{i-1}^{j+1} + \\beta_i V_i^{j+1} - \\gamma_i V_{i+1}^{j+1} = \\alpha_i V_{i-1}^{j} + (2-\\beta_i) V_i^{j} + \\gamma_i V_{i+1}^{j}\n$$\nwhere the coefficients are defined as:\n$$\n\\alpha_i = \\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - ri\\right) \\quad (\\text{since } S_i=i\\Delta S)\n$$\n$$\n\\beta_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\n\\gamma_i = \\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + ri\\right)\n$$\nThe left-hand side defines a tridiagonal matrix, and the right-hand side is a vector computed from values at the previous time step. The boundary conditions $V_0^j = 0$ and $V_M^j = S_{\\max} - K e^{-r\\tau_j}$ are incorporated by modifying the first and last equations of the system. Specifically, for $i=1$, the term involving $V_0^{j+1}$ is zero. For $i=M-1$, the term $-\\gamma_{M-1}V_M^{j+1}$ is known and moved to the right-hand side. The resulting tridiagonal system is efficiently solved at each time step to advance the solution from $\\tau=0$ to $\\tau=T$.\n\nThe Crank–Nicolson method has a time discretization error of order $O((\\Delta \\tau)^2)$. We can use Richardson extrapolation to improve the accuracy. Let $C_N(S_0)$ be the numerical solution at $S=S_0$ and $t=0$ using $N$ time steps (step size $\\Delta \\tau = T/N$), and $C_{2N}(S_0)$ be the solution using $2N$ time steps (step size $\\Delta \\tau/2$). The error expansion is:\n$$\nC_N \\approx C_{\\text{true}} + c (\\Delta \\tau)^2, \\quad C_{2N} \\approx C_{\\text{true}} + c (\\Delta \\tau/2)^2\n$$\nSolving for the leading error term and substituting, we obtain an extrapolated value $C_{\\text{RE}}$ with a higher order of accuracy $O((\\Delta \\tau)^4)$:\n$$\nC_{\\text{RE}}(S_0) = \\frac{4C_{2N}(S_0) - C_N(S_0)}{3}\n$$\nFinally, we compute the analytical solution using the Black–Scholes formula for a European call option at $t=0$:\n$$\nC_{\\text{BS}}(S_0,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\nwith\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2) T}{\\sigma \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma \\sqrt{T}\n$$\nwhere $\\Phi(\\cdot)$ is the standard normal cumulative distribution function. The absolute errors of the numerical solutions ($e_N = |C_N - C_{\\text{BS}}|$, $e_{2N} = |C_{2N} - C_{\\text{BS}}|$) and the extrapolated solution ($e_{\\text{RE}} = |C_{\\text{RE}} - C_{\\text{BS}}|$) are calculated. The accuracy improvement factors are computed as the ratios $\\rho_{N\\to \\mathrm{RE}} = e_N/e_{\\text{RE}}$ and $\\rho_{2N\\to \\mathrm{RE}} = e_{2N}/e_{\\text{RE}}$.\n\nThe numerical solution at $S=S_0$ is obtained by linear interpolation on the final asset grid if $S_0$ is not a grid point.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.linalg import solve_banded\n\ndef solve_black_scholes_cn(params):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    Unpacks S0, K, r, sigma, T, S_max, M, N from a dictionary.\n    Returns the option value at S0, t=0.\n    \"\"\"\n    S0, K, r, sigma, T, S_max, M, N = params['S0'], params['K'], params['r'], params['sigma'], params['T'], params['S_max'], params['M'], params['N']\n\n    # Grid setup\n    dt = T / N  # Time step, in forward tau time\n    ds = S_max / M  # Asset price step\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    # Grid for interior points i = 1, ..., M-1\n    i_pts = np.arange(1, M)\n    \n    # Coefficients for the tridiagonal matrix\n    alpha = 0.25 * dt * (sigma**2 * i_pts**2 - r * i_pts)\n    beta = 1.0 + 0.5 * dt * (sigma**2 * i_pts**2 + r)\n    gamma = 0.25 * dt * (sigma**2 * i_pts**2 + r * i_pts)\n    \n    # Tridiagonal matrix for the LHS (constant in time)\n    # Using scipy's solve_banded format (l=1, u=1)\n    ab = np.zeros((3, M - 1))\n    ab[0, 1:] = -gamma[:-1]\n    ab[1, :] = beta\n    ab[2, :-1] = -alpha[1:]\n    \n    # Initial condition at tau=0 (t=T)\n    V = np.maximum(S_grid - K, 0)\n    \n    # Time-stepping loop (forward in tau from 0 to T)\n    for j in range(N):\n        tau_jp1 = (j + 1) * dt\n        \n        # RHS vector, computed from known values at time j\n        D = alpha * V[0:M-1] + (2.0 - beta) * V[1:M] + gamma * V[2:M+1]\n        \n        # Apply boundary condition at S=S_max\n        V_M_jp1 = S_max - K * np.exp(-r * tau_jp1)\n        D[-1] += gamma[-1] * V_M_jp1\n        \n        # Solve the tridiagonal system Ax=b\n        V_interior_new = solve_banded((1, 1), ab, D)\n        \n        # Update V for the next time step\n        V[1:M] = V_interior_new\n        V[0] = 0.0  # Dirichlet BC at S=0\n        V[M] = V_M_jp1 # Update boundary for use in next iteration's RHS calculation\n\n    # Interpolate to find V(S0, t=0)\n    if np.isclose(S0 % ds, 0.0) or np.isclose(S0 % ds, ds):\n        k = int(round(S0 / ds))\n        return V[k]\n    else:\n        k = int(S0 / ds)\n        w = (S0 - S_grid[k]) / ds\n        return V[k] * (1.0 - w) + V[k+1] * w\n\ndef black_scholes_analytical(params):\n    \"\"\"\n    Calculates the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    S0, K, r, sigma, T = params['S0'], params['K'], params['r'], params['sigma'], params['T']\n    \n    if T == 0.0:\n        return np.maximum(S0 - K, 0.0)\n    if sigma == 0.0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0.0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'S0': 100, 'K': 100, 'r': 0.03, 'sigma': 0.25, 'T': 1.0, 'S_max_factor': 5, 'M': 800, 'N': 200},\n        {'S0': 80, 'K': 100, 'r': 0.01, 'sigma': 0.15, 'T': 0.25, 'S_max_factor': 5, 'M': 800, 'N': 120},\n        {'S0': 120, 'K': 100, 'r': 0.00, 'sigma': 0.05, 'T': 2.0, 'S_max_factor': 6, 'M': 900, 'N': 240},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # Calculate S_max based on K and the factor\n        case_params['S_max'] = case_params['K'] * case_params['S_max_factor']\n        \n        # Analytical solution\n        C_BS = black_scholes_analytical(case_params)\n\n        # Numerical solution with N steps\n        params_N = case_params.copy()\n        C_N = solve_black_scholes_cn(params_N)\n        \n        # Numerical solution with 2N steps\n        params_2N = case_params.copy()\n        params_2N['N'] = 2 * case_params['N']\n        C_2N = solve_black_scholes_cn(params_2N)\n        \n        # Richardson extrapolation\n        C_RE = (4.0 * C_2N - C_N) / 3.0\n        \n        # Absolute errors\n        e_N = abs(C_N - C_BS)\n        e_2N = abs(C_2N - C_BS)\n        e_RE = abs(C_RE - C_BS)\n\n        # Improvement factors\n        # Handle division by zero if extrapolated error is zero\n        rho_N_RE = e_N / e_RE if e_RE > 0 else np.inf\n        rho_2N_RE = e_2N / e_RE if e_RE > 0 else np.inf\n\n        results.extend([e_N, e_2N, e_RE, rho_N_RE, rho_2N_RE])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The Crank-Nicolson method, despite its accuracy, can struggle with non-smooth initial data, leading to unphysical oscillations in the solution. This exercise () demonstrates how to resolve this issue by applying Rannacher smoothing, where a more dissipative scheme is used for the first few time steps to smooth the solution. This practice illustrates a critical refinement for ensuring the stability and reliability of numerical pricing for instruments with discontinuous or kinked payoffs.",
            "id": "2439391",
            "problem": "You are asked to compute the time-zero value of a cash-or-nothing digital call option by solving the Black–Scholes Partial Differential Equation (PDE) on a bounded spatial domain using two distinct time-discretization schemes. The underlying asset price is modeled under a risk-neutral geometric Brownian motion, and the value function $V(S,t)$ satisfies the Black–Scholes PDE\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\non a domain $S \\in [0, S_{\\max}]$, $t \\in [0, T]$, with terminal condition at $t = T$\n$$\nV(S,T) = \\begin{cases}\n1, & \\text{if } S > K,\\\\\n0, & \\text{if } S \\le K,\n\\end{cases}\n$$\nand boundary conditions for all $t \\in [0,T]$\n$$\nV(0,t) = 0,\\qquad \\lim_{S \\to \\infty} V(S,t) = e^{-r (T - t)}.\n$$\nOn the bounded domain, you must use $S_{\\max} = 4K$ and impose the boundary condition at $S = S_{\\max}$ by setting $V(S_{\\max}, t) = e^{-r (T - t)}$. Work in the transformed time-to-maturity variable $\\tau = T - t$, so that the evolution forward in $\\tau$ from $\\tau = 0$ to $\\tau = T$ satisfies\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V,\n$$\nwith initial condition at $\\tau = 0$\n$$\nV(S,0) = \\begin{cases}\n1, & \\text{if } S > K,\\\\\n0, & \\text{if } S \\le K,\n\\end{cases}\n$$\nand boundary conditions $V(0,\\tau) = 0$, $V(S_{\\max}, \\tau) = e^{-r \\tau}$.\n\nDiscretize the spatial domain $[0, S_{\\max}]$ uniformly with $M$ equal intervals (thus $M+1$ grid points), and advance in time-to-maturity with $N$ equal time steps of size $\\Delta \\tau = T/N$. Construct both of the following schemes on the same grid:\n\n- Scheme A: Use a time-discretization that is unconditionally stable and second-order accurate in time for all $N$ steps.\n- Scheme B: Use a time-discretization that is first-order accurate and unconditionally stable for two initial half time steps of size $\\Delta \\tau/2$ each, and then use the same second-order accurate scheme as in Scheme A for the remaining $N-1$ full steps of size $\\Delta \\tau$.\n\nFor the spatial operator, use standard centered second-order finite differences on the uniform spatial grid for the first and second derivatives. For each parameter set, compute the option value at $S = S_0$ by linear interpolation from the computed spatial grid at $\\tau = T$ under both schemes. Quantify the accuracy by comparing to the closed-form Black–Scholes value of a cash-or-nothing digital call option at time zero,\n$$\nV_{\\text{BS}}(S_0,0) = e^{-rT}\\,\\Phi(d_2),\\quad d_2 = \\frac{\\ln(S_0/K) + \\left(r - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma \\sqrt{T}},\n$$\nwhere $\\Phi(\\cdot)$ is the standard normal cumulative distribution function. For each case, report three floats: the absolute error of Scheme A, the absolute error of Scheme B, and the difference in absolute errors (Scheme A minus Scheme B). Positive difference indicates an improvement by Scheme B.\n\nUse the following common discretization parameters for all test cases:\n- Spatial grid size $M = 400$,\n- Time steps $N = 200$,\n- Upper boundary $S_{\\max} = 4K$.\n\nTest suite (each tuple lists $(S_0, K, r, \\sigma, T)$):\n\n1. $(S_0, K, r, \\sigma, T) = (100, 100, 0.05, 0.2, 1.0)$,\n2. $(S_0, K, r, \\sigma, T) = (80, 100, 0.01, 0.4, 0.25)$,\n3. $(S_0, K, r, \\sigma, T) = (120, 100, 0.10, 0.15, 2.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$[\\text{errA}_1, \\text{errB}_1, \\text{errA}_1 - \\text{errB}_1, \\text{errA}_2, \\text{errB}_2, \\text{errA}_2 - \\text{errB}_2, \\text{errA}_3, \\text{errB}_3, \\text{errA}_3 - \\text{errB}_3]$,\nwhere $\\text{errA}_i$ and $\\text{errB}_i$ are the absolute errors of Scheme A and Scheme B respectively for test case $i$. All quantities are dimensionless and should be reported as decimal numbers.",
            "solution": "The problem presented is a valid and well-posed initial-boundary value problem from the field of computational finance. It requires the numerical solution of the Black-Scholes partial differential equation (PDE) for a cash-or-nothing digital call option using finite difference methods. All parameters, conditions, and numerical schemes are specified with sufficient clarity to permit a unique solution. The core of the problem is to compare the accuracy of the standard Crank-Nicolson scheme with a modified version employing Rannacher time-stepping to handle the non-smooth initial condition. This is a standard and meaningful exercise in numerical analysis for PDEs.\n\nWe begin with the Black-Scholes PDE transformed to time-to-maturity coordinates, $\\tau = T - t$. The value of the option, $V(S, \\tau)$, is governed by:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\nThis is a parabolic PDE, which we can write in a more compact form as $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$, where $\\mathcal{L}$ is the spatial differential operator:\n$$\n\\mathcal{L} \\equiv \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + r S \\frac{\\partial}{\\partial S} - r\n$$\nThe problem is solved on the domain $S \\in [0, S_{\\max}]$ and $\\tau \\in [0, T]$, with $S_{\\max} = 4K$. The initial condition at $\\tau=0$ (corresponding to time $t=T$) is the discontinuous payoff of the digital option:\n$$\nV(S, 0) = H(S-K) = \\begin{cases} 1, & \\text{if } S > K \\\\ 0, & \\text{if } S \\le K \\end{cases}\n$$\nThe boundary conditions are $V(0, \\tau) = 0$ and $V(S_{\\max}, \\tau) = e^{-r\\tau}$ for all $\\tau \\in [0, T]$.\n\nWe discretize the spatial domain into $M=400$ intervals of width $\\Delta S = S_{\\max}/M$, creating a grid of points $S_j = j\\Delta S$ for $j = 0, 1, \\dots, M$. The time-to-maturity domain is discretized into $N=200$ steps of size $\\Delta\\tau = T/N$, with time points $\\tau_k = k\\Delta\\tau$. Let $V_j^k$ denote the numerical approximation of $V(S_j, \\tau_k)$.\n\nThe spatial derivatives in the operator $\\mathcal{L}$ are approximated using second-order central finite differences for the interior grid points $j = 1, \\dots, M-1$:\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - V_{j-1}}{2\\Delta S}, \\qquad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_j} \\approx \\frac{V_{j+1} - 2V_j + V_{j-1}}{(\\Delta S)^2}\n$$\nApplying these to $\\mathcal{L}V$ at grid point $S_j$ gives:\n$$\n(\\mathcal{L}V)_j \\approx \\alpha_j V_{j-1} + \\beta_j V_j + \\gamma_j V_{j+1}\n$$\nwhere the coefficients are defined as:\n$$\n\\alpha_j = \\frac{1}{2} \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 - \\frac{r S_j}{2\\Delta S} = \\frac{1}{2}\\sigma^2 j^2 - \\frac{1}{2}rj \\quad (\\text{since } S_j = j\\Delta S)\n$$\n$$\n\\beta_j = - \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 - r = -\\sigma^2 j^2 - r\n$$\n$$\n\\gamma_j = \\frac{1}{2} \\left(\\frac{\\sigma S_j}{\\Delta S}\\right)^2 + \\frac{r S_j}{2\\Delta S} = \\frac{1}{2}\\sigma^2 j^2 + \\frac{1}{2}rj\n$$\nThis semi-discretization results in a system of ordinary differential equations for the vector of interior unknowns $\\mathbf{V}(\\tau) = [V_1(\\tau), \\dots, V_{M-1}(\\tau)]^T$:\n$$\n\\frac{d\\mathbf{V}}{d\\tau} = \\mathbf{A}\\mathbf{V} + \\mathbf{f}(\\tau)\n$$\nHere, $\\mathbf{A}$ is a tridiagonal matrix whose entries are derived from the coefficients $\\alpha_j$, $\\beta_j$, $\\gamma_j$. The vector $\\mathbf{f}(\\tau)$ contains terms arising from the boundary conditions. Specifically, $V_0=0$ is handled by starting the grid at $j=1$, and the condition at $S_M = S_{\\max}$ contributes a term to the equation for $V_{M-1}$: the last component of $\\mathbf{f}(\\tau)$ is $\\gamma_{M-1}V(S_M, \\tau) = \\gamma_{M-1}e^{-r\\tau}$.\n\nWe now apply the specified time-stepping schemes.\n\n**Scheme A: Crank-Nicolson Method**\nThis scheme is second-order accurate in time and unconditionally stable. It averages the spatial operator between time levels $k$ and $k+1$:\n$$\n\\frac{\\mathbf{V}^{k+1} - \\mathbf{V}^k}{\\Delta\\tau} = \\frac{1}{2} \\left( (\\mathbf{A}\\mathbf{V}^{k+1} + \\mathbf{f}^{k+1}) + (\\mathbf{A}\\mathbf{V}^k + \\mathbf{f}^k) \\right)\n$$\nRearranging terms yields a linear system to be solved for $\\mathbf{V}^{k+1}$ at each time step:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta\\tau}{2}\\mathbf{A}\\right)\\mathbf{V}^{k+1} = \\left(\\mathbf{I} + \\frac{\\Delta\\tau}{2}\\mathbf{A}\\right)\\mathbf{V}^k + \\frac{\\Delta\\tau}{2}(\\mathbf{f}^{k+1} + \\mathbf{f}^k)\n$$\nThe matrix on the left-hand side is tridiagonal and constant throughout the time-stepping, allowing for efficient solution via a tridiagonal matrix algorithm.\n\n**Scheme B: Rannacher Smoothing**\nThe Crank-Nicolson method, while high-order, is known to produce spurious oscillations when applied to problems with non-smooth initial data, such as the Heaviside function in this problem. These oscillations can degrade the accuracy. Scheme B is designed to mitigate this. It uses a strongly damping, first-order method for the initial steps to smooth the solution before switching to the more accurate Crank-Nicolson method.\n\n1.  **Initial Smoothing Steps:** We use the Implicit Euler method for two steps of size $\\Delta\\tau/2$. The Implicit Euler method is first-order accurate and L-stable, which provides strong damping of high-frequency error components. For a step of size $\\Delta\\tau'$, its formulation is:\n    $$\n    \\frac{\\mathbf{V}^{k+1} - \\mathbf{V}^k}{\\Delta\\tau'} = \\mathbf{A}\\mathbf{V}^{k+1} + \\mathbf{f}^{k+1} \\implies \\left(\\mathbf{I} - \\Delta\\tau'\\mathbf{A}\\right)\\mathbf{V}^{k+1} = \\mathbf{V}^k + \\Delta\\tau'\\mathbf{f}^{k+1}\n    $$\n    We apply this twice with $\\Delta\\tau' = \\Delta\\tau/2$, advancing the solution from $\\tau=0$ to $\\tau=\\Delta\\tau/2$, and then to $\\tau=\\Delta\\tau$.\n\n2.  **Crank-Nicolson Steps:** For the remaining $N-1$ steps, from $\\tau=\\Delta\\tau$ to $\\tau=T$, the solution is sufficiently smooth, and we switch to the standard Crank-Nicolson scheme with step size $\\Delta\\tau$ as in Scheme A.\n\nAfter $N$ total time steps, both schemes produce a vector of option values $\\mathbf{V}^N$ at $\\tau=T$. The final value at the specific spot price $S_0$ is obtained by linear interpolation on the grid of computed values $[V_0^N, V_1^N, \\dots, V_M^N]^T$, where $V_0^N=0$ and $V_M^N=e^{-rT}$. The accuracy of each scheme is measured by the absolute error against the analytical Black-Scholes formula for a cash-or-nothing digital call:\n$$\nV_{\\text{BS}}(S_0, 0) = e^{-rT}\\Phi(d_2), \\quad \\text{with} \\quad d_2 = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\nwhere $\\Phi(\\cdot)$ is the cumulative distribution function of the standard normal distribution. The implementation will compute the values for both schemes and report the required error metrics.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.stats import norm\n\ndef compute_option_values(S0, K, r, sigma, T, M, N):\n    \"\"\"\n    Computes the price of a cash-or-nothing digital call option using Scheme A and Scheme B.\n    \"\"\"\n\n    # 1. Grid and parameter setup\n    S_max = 4.0 * K\n    ds = S_max / M\n    dt = T / N\n\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    # 2. PDE coefficients\n    # We define coefficients for interior points j = 1, ..., M-1\n    j = np.arange(1, M)\n    alpha = 0.5 * sigma**2 * j**2 - 0.5 * r * j\n    beta = -sigma**2 * j**2 - r\n    gamma = 0.5 * sigma**2 * j**2 + 0.5 * r * j\n\n    # 3. Initial condition for V(S, tau=0)\n    V0 = np.zeros(M + 1)\n    V0[S_grid > K] = 1.0\n    V0_int = V0[1:M] # Interior points V_1 to V_{M-1}\n\n    # --- Scheme A: Crank-Nicolson for all steps ---\n    V_A = V0_int.copy()\n\n    # LHS matrix for CN, constant through time\n    mat_LHS_CN = np.zeros((3, M - 1))\n    mat_LHS_CN[0, 1:] = -0.5 * dt * gamma[:-1]\n    mat_LHS_CN[1, :] = 1.0 - 0.5 * dt * beta\n    mat_LHS_CN[2, :-1] = -0.5 * dt * alpha[1:]\n\n    for k in range(N):\n        tau_k = k * dt\n        tau_k1 = (k + 1) * dt\n        \n        # RHS vector construction: (I + 0.5*dt*A)V_A\n        RHS = V_A.copy()\n        RHS[0]    += 0.5 * dt * (beta[0] * V_A[0] + gamma[0] * V_A[1])\n        RHS[1:-1] += 0.5 * dt * (alpha[1:-1] * V_A[:-2] + beta[1:-1] * V_A[1:-1] + gamma[1:-1] * V_A[2:])\n        RHS[-1]   += 0.5 * dt * (alpha[-1] * V_A[-2] + beta[-1] * V_A[-1])\n\n        # Add boundary condition term for V_M\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n\n        V_A = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # --- Scheme B: Rannacher Smoothing (IE + CN) ---\n    V_B = V0_int.copy()\n    dt_half = dt / 2.0\n\n    # LHS matrix for IE steps, constant\n    mat_LHS_IE = np.zeros((3, M - 1))\n    mat_LHS_IE[0, 1:] = -dt_half * gamma[:-1]\n    mat_LHS_IE[1, :] = 1.0 - dt_half * beta\n    mat_LHS_IE[2, :-1] = -dt_half * alpha[1:]\n\n    # First IE half-step (tau = 0 to dt/2)\n    RHS_IE1 = V_B.copy()\n    bc_term_1 = dt_half * gamma[-1] * np.exp(-r * dt_half)\n    RHS_IE1[-1] += bc_term_1\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE1)\n\n    # Second IE half-step (tau = dt/2 to dt)\n    RHS_IE2 = V_B.copy()\n    bc_term_2 = dt_half * gamma[-1] * np.exp(-r * dt)\n    RHS_IE2[-1] += bc_term_2\n    V_B = solve_banded((1, 1), mat_LHS_IE, RHS_IE2)\n\n    # Remaining N-1 CN steps (tau = dt to T)\n    for k in range(1, N):\n        tau_k = k * dt\n        tau_k1 = (k + 1) * dt\n        \n        # RHS vector construction: (I + 0.5*dt*A)V_B\n        RHS = V_B.copy()\n        RHS[0]    += 0.5 * dt * (beta[0] * V_B[0] + gamma[0] * V_B[1])\n        RHS[1:-1] += 0.5 * dt * (alpha[1:-1] * V_B[:-2] + beta[1:-1] * V_B[1:-1] + gamma[1:-1] * V_B[2:])\n        RHS[-1]   += 0.5 * dt * (alpha[-1] * V_B[-2] + beta[-1] * V_B[-1])\n\n        # Add boundary condition term\n        bc_term = 0.5 * dt * gamma[-1] * (np.exp(-r * tau_k) + np.exp(-r * tau_k1))\n        RHS[-1] += bc_term\n\n        V_B = solve_banded((1, 1), mat_LHS_CN, RHS)\n\n    # --- Final value extraction ---\n    \n    # Reconstruct full solution vectors at tau=T\n    V_final_A = np.zeros(M + 1)\n    V_final_A[1:M] = V_A\n    V_final_A[M] = np.exp(-r * T)\n    \n    V_final_B = np.zeros(M + 1)\n    V_final_B[1:M] = V_B\n    V_final_B[M] = np.exp(-r * T)\n    \n    # Interpolate to find value at S0\n    val_A = np.interp(S0, S_grid, V_final_A)\n    val_B = np.interp(S0, S_grid, V_final_B)\n\n    return val_A, val_B\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and format output.\n    \"\"\"\n    # Common discretization parameters\n    M = 400\n    N = 200\n\n    # Test suite: (S0, K, r, sigma, T)\n    test_cases = [\n        (100.0, 100.0, 0.05, 0.2, 1.0),\n        (80.0, 100.0, 0.01, 0.4, 0.25),\n        (120.0, 100.0, 0.10, 0.15, 2.0),\n    ]\n\n    results = []\n    for S0, K, r, sigma, T in test_cases:\n        # Compute numerical values\n        val_A, val_B = compute_option_values(S0, K, r, sigma, T, M, N)\n\n        # Compute analytical value\n        d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        analytical_val = np.exp(-r * T) * norm.cdf(d2)\n\n        # Compute errors\n        err_A = abs(val_A - analytical_val)\n        err_B = abs(val_B - analytical_val)\n        err_diff = err_A - err_B\n\n        results.extend([err_A, err_B, err_diff])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This practice extends the Crank-Nicolson framework to price American options, where the possibility of early exercise creates a free-boundary problem. You will see how the standard linear system becomes a linear complementarity problem, requiring an iterative solver at each time step. This exercise () provides hands-on experience with the Projected Successive Over-Relaxation (PSOR) method, a powerful technique for handling the inequality constraints inherent in pricing American-style derivatives.",
            "id": "2439350",
            "problem": "You are asked to implement a numerical solver for the early-exercise premium of an American put option under the Black–Scholes framework, using the Crank–Nicolson time-stepping scheme combined with the Projected Successive Over-Relaxation (PSOR) method at each time step to enforce the inequality constraints. Your program must be a complete, runnable program that takes no input and prints the results for a fixed test suite as specified below.\n\nStart from the following fundamental base:\n- Risk-neutral valuation and the no-arbitrage partial differential equation (PDE) for the arbitrage-free price of a derivative written on a non-dividend or dividend-paying underlying. Under the risk-neutral measure, the underlying price $S$ follows a geometric Brownian motion with drift $r - q$, where $r$ is the continuously-compounded risk-free rate and $q$ is the continuous dividend yield. The Black–Scholes partial differential equation (PDE) for a sufficiently smooth price function $V(S,t)$ is\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\nwhere $\\sigma$ is the constant volatility, $r$ is the constant risk-free rate, and $q$ is the constant dividend yield.\n- For an American put option with strike $K$ and maturity $T$, the value $V(S,t)$ must satisfy the linear complementarity conditions\n$$\nV(S,t) \\geq \\max(K - S, 0), \\quad -\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V \\geq 0,\n$$\nand the pointwise complementarity\n$$\n\\left(V(S,t) - \\max(K - S, 0)\\right)\\left(-\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V\\right) = 0,\n$$\nfor all $S \\geq 0$ and $t \\in [0,T)$. The terminal payoff condition is\n$$\nV(S,T) = \\max(K - S, 0).\n$$\nUse boundary conditions consistent with economic reasoning: for the American put, for all $t \\in [0,T]$, at the lower boundary $S = 0$ take $V(0,t) = K$, and for a sufficiently large upper boundary $S = S_{\\max}$ take $V(S_{\\max}, t) = 0$.\n\nTask requirements:\n- Discretize the spatial domain $S \\in [0, S_{\\max}]$ on a uniform grid with $N$ subintervals, $\\Delta S = S_{\\max} / N$, and the temporal domain $[0,T]$ with $M$ uniform steps of size $\\Delta t = T/M$. Apply the Crank–Nicolson method to the interior grid nodes to form, at each backward time step, a tridiagonal linear complementarity problem (LCP).\n- At each time step, solve the discrete LCP using the Projected Successive Over-Relaxation (PSOR) method. The iteration must use an over-relaxation factor $\\omega \\in (0,2)$ and enforce the exercise constraint by projecting the iterates onto the obstacle $\\max(K - S_i, 0)$ at each spatial node $S_i$.\n- Use linear interpolation to return the price at a given spot $S_0$ that may not lie exactly on a grid node.\n- All rates $r$, $q$, and volatility $\\sigma$ must be expressed as decimals (for example, $0.05$ for $5$ percent). Time $T$ must be in years. No angle units are involved. No percentage sign is to appear in the input or output; only decimals are used.\n\nImplementation detail expectations:\n- Derive the Crank–Nicolson semi-implicit interior-node discretization on the uniform grid, yielding a tridiagonal left-hand side for the new time level, a tridiagonal right-hand side using the previous time level, and incorporate boundary values consistently. Do not use any closed-form American pricing formulas or penalty methods; you must enforce the early-exercise constraint via PSOR.\n- Implement a stopping criterion for PSOR based on the maximum absolute change across all interior nodes being less than a tolerance $\\varepsilon$, and a hard cap on the maximum number of iterations to guarantee termination.\n- Ensure numerical stability by choosing a sufficiently large $S_{\\max}$ and sufficient spatial and temporal resolutions for each test case below.\n\nTest suite:\nCompute the American put price at the spot $S_0$ for each parameter set below. Use the specified $S_{\\max}$, $N$, $M$, PSOR relaxation $\\omega$, tolerance $\\varepsilon$, and maximum iterations per time step $I_{\\max}$. Parameters are given as tuples $(S_0, K, T, r, q, \\sigma, S_{\\max}, N, M, \\omega, \\varepsilon, I_{\\max})$:\n- Case $1$ (baseline, one year, moderate volatility): $(100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1\\times 10^{-8}, 10000)$.\n- Case $2$ (one year, high volatility, low rate): $(100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1\\times 10^{-8}, 10000)$.\n- Case $3$ (one year, zero rate): $(100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1\\times 10^{-8}, 10000)$.\n- Case $4$ (short maturity, in-the-money): $(50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1\\times 10^{-8}, 10000)$.\n\nFinal output specification:\n- Your program must produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets, ordered by the cases $1$ through $4$.\n- Each number must be rounded to exactly $6$ decimal places.\n- For example, the output format must look like $[v_1,v_2,v_3,v_4]$, where each $v_i$ is a float rounded to $6$ decimals.",
            "solution": "The user has specified a problem in computational finance: pricing an American put option by numerically solving the Black-Scholes partial differential equation (PDE) with early-exercise constraints. The problem is scientifically grounded, well-posed, and all necessary parameters for a complete solution are provided. It is therefore deemed valid. The solution requires implementing the Crank-Nicolson method for time discretization and the Projected Successive Over-Relaxation (PSOR) method to handle the linear complementarity problem arising from the early-exercise feature.\n\nThe Black-Scholes model for an option price $V(S,t)$, where $S$ is the underlying asset price and $t$ is time, is given by the PDE:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nHere, $r$ is the risk-free interest rate, $q$ is the continuous dividend yield, and $\\sigma$ is the volatility of the underlying asset. For an American put option, this equation becomes an inequality, and the solution must satisfy a linear complementarity formulation, as it is a free-boundary problem. The price must always be greater than or equal to its intrinsic value, $V(S,t) \\geq \\max(K-S, 0)$, where $K$ is the strike price.\n\nThis is a terminal value problem, solved backwards in time from maturity $T$ to the present time $t=0$. To facilitate a standard forward-stepping numerical scheme, we perform a change of variable for time, $\\tau = T - t$. The PDE becomes:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V\n$$\nWe discretize the spatial domain $S \\in [0, S_{\\max}]$ into $N$ intervals of size $\\Delta S = S_{\\max}/N$, creating grid points $S_i = i\\Delta S$ for $i=0, 1, \\dots, N$. The time domain $\\tau \\in [0, T]$ is discretized into $M$ steps of size $\\Delta \\tau = T/M$, creating time points $\\tau_j = j\\Delta\\tau$ for $j=0, 1, \\dots, M$. Let $V_i^j$ denote the numerical approximation of $V(S_i, \\tau_j)$.\n\nThe Crank-Nicolson method approximates the time derivative at the midpoint $\\tau_{j+1/2}$ and averages the spatial operator over time levels $j$ and $j+1$:\n$$\n\\frac{V^{j+1} - V^{j}}{\\Delta \\tau} = \\frac{1}{2}(\\mathcal{L}V^{j+1} + \\mathcal{L}V^{j})\n$$\nwhere $\\mathcal{L}$ is the spatial differential operator. Rearranging gives a system of linear equations to solve at each time step:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j+1} = \\left(\\mathbf{I} + \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j}\n$$\nwhere $\\mathbf{L}$ is the matrix representation of $\\mathcal{L}$ after spatial discretization using central finite differences for the derivatives $\\frac{\\partial V}{\\partial S}$ and $\\frac{\\partial^2 V}{\\partial S^2}$:\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\quad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\nSubstituting these into the operator $\\mathcal{L}$ yields a tridiagonal structure for the matrix $\\mathbf{L}$. The equation for each interior node $i=1, \\dots, N-1$ is:\n$$\nL_i V_{i-1}^{j+1} + M_i V_i^{j+1} + R_i V_{i+1}^{j+1} = Q_i\n$$\nThe coefficients are defined as:\n$$\nL_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - (r-q)i\\right)\n$$\n$$\nM_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\nR_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + (r-q)i\\right)\n$$\nThe right-hand side $Q_i$ is constructed from known values at time step $j$:\n$$\nQ_i = -L_i V_{i-1}^{j} + (2-M_i)V_i^{j} - R_i V_{i+1}^{j}\n$$\nBoundary conditions for an American put are $V(0,\\tau) = K$ and $V(S_{\\max}, \\tau) = 0$. These are incorporated by adjusting the right-hand side vector $Q$. For the first interior node $i=1$, the term $L_1 V_0^{j+1}$ moves to the right, becoming $L_1 K$. Similarly, at the last interior node $i=N-1$, the term $R_{N-1}V_N^{j+1}$ is $0$.\n\nThe early-exercise constraint requires that $V_i^{j+1} \\geq g_i = \\max(K-S_i, 0)$ for all $i$. This turns the linear system into a linear complementarity problem (LCP), which we solve using the Projected Successive Over-Relaxation (PSOR) method. For each time step, we iterate to find the vector $\\mathbf{V}^{j+1}$. The update rule for the $k$-th iteration for each interior node $i$ is:\n\n1. Compute the standard SOR update:\n$$\nv_i^{*} = (1-\\omega)V_i^{(k)} + \\frac{\\omega}{M_i} \\left( Q_i - L_i V_{i-1}^{(k+1)} - R_i V_{i+1}^{(k)} \\right)\n$$\nwhere $\\omega \\in (0,2)$ is the relaxation parameter, $V^{(k)}$ is the vector from the previous iteration, and $V^{(k+1)}$ uses already updated values within the current iteration.\n\n2. Project the result onto the exercise value (obstacle):\n$$\nV_i^{(k+1)} = \\max(v_i^{*}, g_i)\n$$\nThe PSOR iterations continue until the maximum absolute change between successive iterates across all nodes falls below a tolerance $\\varepsilon$, or a maximum number of iterations $I_{\\max}$ is reached.\n\nThe overall algorithm is as follows:\n1.  Initialize the grid of option values $\\mathbf{V}$ at maturity $\\tau=0$ (i.e., $t=T$) with the terminal payoff: $V_i^0 = \\max(K - S_i, 0)$.\n2.  Iterate backward in time from $j=0$ to $M-1$. In each step:\n    a.  Compute the right-hand side vector $\\mathbf{Q}$ using values from $\\mathbf{V}^j$.\n    b.  Adjust $\\mathbf{Q}$ for boundary conditions.\n    c.  Solve the LCP for $\\mathbf{V}^{j+1}$ using the PSOR algorithm, with $\\mathbf{V}^j$ as the initial guess.\n    d.  Enforce the boundary conditions $V_0^{j+1} = K$ and $V_N^{j+1} = 0$.\n3.  After the final time step, the vector $\\mathbf{V}^M$ contains the option prices at $t=0$.\n4.  Use linear interpolation to find the price at the specific spot $S_0$, which may not be on a grid point.\n\nThis procedure yields a robust numerical solution for the American put option price, respecting the no-arbitrage conditions and early-exercise constraints of the Black-Scholes framework.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_american_put_price(S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max):\n    \"\"\"\n    Computes the American put option price using the Crank-Nicolson FDM and PSOR.\n\n    :param S0: Initial stock price\n    :param K: Strike price\n    :param T: Time to maturity (in years)\n    :param r: Risk-free interest rate (decimal)\n    :param q: Continuous dividend yield (decimal)\n    :param sigma: Volatility (decimal)\n    :param S_max: Maximum stock price in the grid\n    :param N: Number of spatial steps\n    :param M: Number of time steps\n    :param omega: SOR relaxation factor\n    :param epsilon: PSOR tolerance\n    :param I_max: Max iterations for PSOR\n    :return: American put option price at S0\n    \"\"\"\n    # 1. Grid setup\n    dt = T / M\n    ds = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n    \n    # 2. Initialize option values at maturity (t=T)\n    V = np.maximum(K - S, 0)\n    \n    # 3. Pre-compute Crank-Nicolson coefficients for the tridiagonal system\n    # These coefficients are used for the matrix on the LHS of the time-step equation.\n    i = np.arange(1, N)  # Interior nodes\n    \n    # Coefficients for L_i * V_{i-1} + M_i * V_i + R_i * V_{i+1} = Q_i\n    L_coeffs = -0.25 * dt * (sigma**2 * i**2 - (r - q) * i)\n    M_coeffs = 1 + 0.5 * dt * (sigma**2 * i**2 + r)\n    R_coeffs = -0.25 * dt * (sigma**2 * i**2 + (r - q) * i)\n\n    # 4. Time-stepping loop (backward from T to 0)\n    for j in range(M - 1, -1, -1):\n        # Calculate the explicit part (RHS) of the CN scheme\n        Q = -L_coeffs * V[:-2] + (2 - M_coeffs) * V[1:-1] - R_coeffs * V[2:]\n\n        # Adjust RHS for boundary conditions\n        # For S=0, V=K. For S=S_max, V=0.\n        # Boundary condition V(0,t)=K affects the equation for the first interior node (i=1)\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from LHS, moved to RHS\n        Q[0] += L_coeffs[0] * K  # Term involving V_0 from RHS side\n        # V(S_max,t)=0 means the R_coeffs[N-2] term involving V_N is zero, no adjustment needed\n\n        # 5. PSOR solver for the linear complementarity problem at each time step\n        v_interior = V[1:-1].copy()  # Initial guess from previous time step\n        obstacle = np.maximum(K - S[1:-1], 0)\n\n        for k in range(I_max):\n            v_old_iter = v_interior.copy()\n\n            # Iterate through interior nodes\n            for i in range(N - 1):\n                # SOR update calculation\n                sor_sum = 0\n                if i > 0:\n                    sor_sum += L_coeffs[i] * v_interior[i - 1]\n                if i < N - 2:\n                    sor_sum += R_coeffs[i] * v_old_iter[i + 1]\n\n                v_star = (1 - omega) * v_old_iter[i] + (omega / M_coeffs[i]) * (Q[i] - sor_sum)\n                \n                # Projection step\n                v_interior[i] = max(v_star, obstacle[i])\n\n            # Check for convergence\n            if np.max(np.abs(v_interior - v_old_iter)) < epsilon:\n                break\n        \n        # Update V with the solution for the current time step\n        V[1:-1] = v_interior\n        V[0] = K  # Boundary at S=0\n        V[N] = 0.0 # Boundary at S=S_max\n        \n    # 6. Interpolate to find price at S0\n    idx = int(S0 / ds)\n    if idx >= N: # Handle case where S0 is at or beyond S_max\n        return 0.0\n    \n    # Linear interpolation\n    price = V[idx] + (V[idx + 1] - V[idx]) * (S0 - S[idx]) / ds\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max)\n        (100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1e-8, 10000),\n        (50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1e-8, 10000),\n    ]\n\n    results = []\n    for case in test_cases:\n        params = {\n            \"S0\": case[0], \"K\": case[1], \"T\": case[2], \"r\": case[3], \"q\": case[4], \n            \"sigma\": case[5], \"S_max\": case[6], \"N\": case[7], \"M\": case[8], \n            \"omega\": case[9], \"epsilon\": case[10], \"I_max\": case[11]\n        }\n        price = compute_american_put_price(**params)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}