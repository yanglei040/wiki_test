{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你直接比较Crank-Nicolson方法与更简单的完全显式方法。通过关注短期期权，你将研究一个关键的数值挑战：在非光滑支付区域附近产生的伪振荡。这项实践对于建立直观理解至关重要，让你明白为何像Crank-Nicolson这样的无条件稳定格式并非总是完美的解决方案，并学会如何诊断数值计算中产生的偏差。",
            "id": "2439346",
            "problem": "编写一个完整、可运行的程序，比较 Crank-Nicolson (CN) 有限差分法和完全显式时间步进有限差分法在评估由 Black-Scholes 偏微分方程 (PDE) 控制的欧式看涨期权时的行为。您的目标是研究在短到期日下行权价附近的数值振荡，并用一个简单、客观的度量标准来量化它们。\n\n您必须将您的公式建立在以下公认的基础之上：\n- 在风险中性估值下，欧式看涨期权价格 $V(S,t)$ 的 Black-Scholes PDE 为：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中 $S$ 为标的资产价格，$r$ 为无风险利率，$\\sigma$ 为波动率，$t$ 表示当前时间（时间越早，距离到期日的时间越长）。\n- 到期日 $t = T$ 时的终端条件：\n$$\nV(S,T) = \\max(S - K, 0),\n$$\n其中 $K$ 为行权价。\n- 对于一个足够大的有限域 $S \\in [0, S_{\\max}]$，边界条件为：\n$$\nV(0,t) = 0, \\quad V(S_{\\max}, t) \\approx S_{\\max} - K e^{-r (T - t)}.\n$$\n\n将空间域用 $M$ 个区间进行均匀离散化，使得 $S_j = j \\Delta S$，$j = 0,1,\\dots,M$，其中 $\\Delta S = S_{\\max}/M$。将时间用 $N_t$ 个步长进行均匀离散化，使得 $t_n = n \\Delta t$，$n=0,1,\\dots,N_t$，其中 $\\Delta t = T/N_t$。在均匀网格上使用标准的空间中心有限差分。实现以下方法：\n- Crank-Nicolson (CN) 时间步进法（时间上的隐式梯形法则）。\n- 完全显式的时间前向法（使用相同的空间差分格式）。\n\n两种方案都应将数值解从 $t=T$ 向后推进到 $t=0$。\n\n定义并计算一个关注于行权价邻域的振荡度量标准，如下所示。设 $j_K$ 是最接近行权价的空间索引，$j_K = \\mathrm{round}(K/\\Delta S)$。对于一个固定的窗口半宽 $w$，考虑索引 $j \\in \\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$。设在 $j$ 处的离散二阶差分为\n$$\n\\Delta^2 V_j = V_{j+1}(0) - 2 V_j(0) + V_{j-1}(0),\n$$\n其中 $V_j(0)$ 表示在 $t=0$ 时的数值解。定义振荡幅度为\n$$\n\\mathcal{O} = \\max_{j} \\big( 0, -\\Delta^2 V_j \\big),\n$$\n该最大值在指定的窗口内取。对于像欧式看涨期权这样的凸性收益，真实解在 $S$ 上是凸的，因此行权价附近的任何负的离散二阶差分都表明存在虚假的数值振荡。\n\n为每个测试用例实现这两种方法，并计算比率\n$$\nR = \\frac{\\mathcal{O}_{\\mathrm{CN}}}{\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon},\n$$\n其中使用一个小的 $\\varepsilon = 10^{-12}$ 来避免除以零。报告每个测试用例的 $R$ 值。\n\n所有利率必须以小数形式表示（例如，年化利率为百分之五时，$r = 0.05$）。没有物理单位。\n\n使用以下测试套件，该套件在保持空间网格相同的情况下，探索了一系列短到期日和波动率。在所有情况下，设置 $K = 100$，$S_{\\max} = 5K$，$M = 100$，窗口半宽 $w = 5$。\n- 用例 A（短到期日，粗时间网格）：$\\sigma = 0.2$, $r = 0.05$, $T = 0.01$, $N_t = 10$。\n- 用例 B（短到期日，细时间网格）：$\\sigma = 0.2$, $r = 0.05$, $T = 0.01$, $N_t = 40$。\n- 用例 C（极短到期日，低波动率）：$\\sigma = 0.1$, $r = 0.05$, $T = 0.005$, $N_t = 8$。\n- 用例 D（短到期日，较高波动率）：$\\sigma = 0.3$, $r = 0.05$, T = 0.02, $N_t = 64$。\n\n您的程序必须按 A, B, C, D 的顺序计算每个用例的 $R$ 值，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,x_3,x_4]$。每个 $x_i$ 都应该是一个浮点数。不强制要求四舍五入，但保留固定小数位数是可以接受的。\n\n在您的实现中，请确保科学真实性和内部一致性。仅使用所描述的标准有限差分进行离散化。不要在您的度量标准中使用任何封闭形式的定价公式；纯粹通过行权价邻域的离散凸性来评估振荡。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上以 Black-Scholes 模型和标准数值分析技术为基础，问题设定完整且一致，表述客观。我们将着手提供一个完整的解决方案。\n\n该问题要求实现并比较两种用于求解欧式看涨期权 Black-Scholes 偏微分方程 (PDE) 的有限差分方法。目标是量化在短到期日下行权价附近的数值振荡。\n\nBlack-Scholes PDE 如下：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这是一个终值问题，在到期日 $t=T$ 时的终端条件是期权的收益函数：\n$$\nV(S,T) = \\max(S-K, 0)\n$$\n为了进行数值求解，我们通常将其转换为一个初值问题。令 $\\tau = T - t$。这个变换将时间导数 $\\frac{\\partial}{\\partial t}$ 变为 $-\\frac{\\partial}{\\partial \\tau}$，问题就从 $\\tau=0$（到期日）向前求解到 $\\tau=T$（今天）。PDE 变为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n这是一个形式为 $\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V$ 的抛物型 PDE，其中 $\\mathcal{L}$ 是一个线性空间微分算子。\n\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $M$ 个宽度为 $\\Delta S = S_{\\max}/M$ 的区间，使得 $S_j = j \\Delta S$，$j \\in \\{0, 1, \\dots, M\\}$。时间域 $\\tau \\in [0, T]$ 被离散化为 $N_t$ 个步长为 $\\Delta\\tau = T/N_t$ 的时间步，使得 $\\tau_n = n \\Delta\\tau$，$n \\in \\{0, 1, \\dots, N_t\\}$。令 $V_j^n$ 表示 $V(S_j, \\tau_n)$ 的数值近似。\n\n使用标准的中心有限差分来处理空间导数，并将 $S_j = j\\Delta S$ 代入，离散化的空间算子 $\\mathcal{L}_h$ 作用于 $V_j$ 可以写作：\n$$\n(\\mathcal{L}_h V)_j \\approx \\frac{1}{(\\Delta S)^2} \\left[ \\left(\\frac{1}{2}\\sigma^2 (j\\Delta S)^2 - \\frac{r(j\\Delta S)\\Delta S}{2}\\right)V_{j-1} + \\left(-\\sigma^2 (j\\Delta S)^2 - r(\\Delta S)^2\\right)V_j + \\left(\\frac{1}{2}\\sigma^2 (j\\Delta S)^2 + \\frac{r(j\\Delta S)\\Delta S}{2}\\right)V_{j+1} \\right]\n$$\n为了简化符号，在实现中通常会定义与 $\\Delta\\tau$ 和网格索引 $j$ 相关的系数。\n\n**1. 完全显式方法**\n该方法在 $\\tau$ 上使用前向欧拉离散化：$\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\mathcal{L}_h V^n$。内部节点（$j = 1, \\dots, M-1$）的更新规则可以表示为：\n$$\nV_j^{n+1} = a_j V_{j-1}^n + b_j V_j^n + c_j V_{j+1}^n\n$$\n其中，\n$a_j = \\frac{\\Delta\\tau}{2}(\\sigma^2 j^2 - rj)$\n$b_j = 1 - \\Delta\\tau(\\sigma^2 j^2 + r)$\n$c_j = \\frac{\\Delta\\tau}{2}(\\sigma^2 j^2 + rj)$\n该方案计算简单，但只是有条件稳定的。对于每个时间步，我们根据上一步的向量 $V^n$ 来计算新值的向量 $V^{n+1}$。\n\n**2. Crank-Nicolson 方法**\n该方法对时间导数使用梯形法则：$\\frac{V^{n+1}-V^n}{\\Delta\\tau} = \\frac{1}{2}(\\mathcal{L}_h V^n + \\mathcal{L}_h V^{n+1})$。这是一个隐式方法，它在每个时间步都会导致一个三对角线性方程组：\n$$\n-a_j V_{j-1}^{n+1} + (2+2b_j') V_j^{n+1} - c_j V_{j+1}^{n+1} = a_j V_{j-1}^n + (2-2b_j') V_j^n + c_j V_{j+1}^n\n$$\n其中 $a_j, c_j$ 与显式方法中的定义相同，$b_j' = \\frac{\\Delta\\tau}{2}(\\sigma^2 j^2 + r)$。左侧包含第 $n+1$ 步的未知值，形成一个三对角方程组 $A \\boldsymbol{V}^{n+1} = \\boldsymbol{b}$，其中 $\\boldsymbol{V}^{n+1}$ 是未知期权价格的向量。矩阵 $A$ 在整个时间步进过程中是常数，这使得可以使用像 Thomas 算法这样的三对角求解器进行高效求解。\n\n**边界条件**\n对于这两种方法，必须在每个时间步 $n$ 应用边界条件：\n- 在 $S=0$ 处：$V_0^{n+1} = 0$。\n- 在 $S=S_{\\max}$ 处：$V_M^{n+1} = S_{\\max} - K e^{-r \\tau_{n+1}}$。\n对于 Crank-Nicolson 方法，已知的 $V_M^{n+1}$ 值被移到节点 $j=M-1$ 方程的线性系统右侧。\n\n**振荡度量**\n解的凸性在 $\\tau=T$（即 $t=0$）时进行评估。在空间节点 $j$ 处的离散二阶差分为 $\\Delta^2 V_j = V_{j+1} - 2V_j + V_{j-1}$。对于欧式看涨期权，价格是 $S$ 的一个凸函数，所以我们期望 $\\Delta^2 V_j \\ge 0$。振荡幅度 $\\mathcal{O}$ 定义为在行权价 $K$ 附近的一个窗口内二阶差分负值的最大值：\n$$\n\\mathcal{O} = \\max_{j \\in W} \\left( 0, - (V_{j+1} - 2V_j + V_{j-1}) \\right)\n$$\n其中窗口 $W$ 是 $\\{ \\max(1, j_K - w), \\dots, \\min(M-1, j_K + w) \\}$，$j_K = \\mathrm{round}(K/\\Delta S)$。一个更大的 $\\mathcal{O}$ 值意味着更严重的虚假振荡。最终要求的输出是比率 $R = \\mathcal{O}_{\\mathrm{CN}} / (\\mathcal{O}_{\\mathrm{EXP}} + \\varepsilon)$。\n\n对每个测试用例，执行以下步骤：\n1. 设置空间和时间网格。\n2. 使用终端条件 $V(S,T)$ 初始化解向量。\n3. 使用显式或 Crank-Nicolson 更新规则，从 $\\tau=0$ 迭代到 $\\tau=T$，在每一步应用边界条件。\n4. 在最后一个时间步之后，为每种方法计算振荡度量 $\\mathcal{O}$。\n5. 计算比率 $R$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n#   name: scipy\n#   version: 1.11.4\n\ndef solve_black_scholes_fdm(params, method):\n    \"\"\"\n    Solves the Black-Scholes PDE using the specified finite difference method.\n\n    Args:\n        params (dict): Dictionary of parameters (K, S_max, M, T, N_t, r, sigma).\n        method (str): 'explicit' or 'cn' (Crank-Nicolson).\n\n    Returns:\n        numpy.ndarray: The option prices at t=0 across the spatial grid.\n    \"\"\"\n    K, S_max, M, T, N_t, r, sigma = params['K'], params['S_max'], params['M'], params['T'], params['N_t'], params['r'], params['sigma']\n\n    # Grid setup\n    dS = S_max / M\n    dt = T / N_t  # This is delta_tau\n    S = np.linspace(0, S_max, M + 1)\n    \n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S - K, 0)\n    \n    # Coefficients for the discretized PDE (do not depend on time)\n    # These are for the interior points j = 1, ..., M-1\n    j = np.arange(1, M)\n    alpha = 0.5 * dt * (sigma**2 * j**2 - r * j)\n    beta = dt * (sigma**2 * j**2 + r)\n    gamma = 0.5 * dt * (sigma**2 * j**2 + r * j)\n\n    if method == 'explicit':\n        # Time-stepping loop\n        for n in range(N_t):\n            V_old = V.copy()\n            # Vectorized update for interior points\n            V[1:M] = (1 - beta) * V_old[1:M] + alpha * V_old[0:M-1] + gamma * V_old[2:M+1]\n            \n            # Apply boundary conditions for the next step\n            V[0] = 0.0\n            V[M] = S_max - K * np.exp(-r * (n + 1) * dt)\n            \n    elif method == 'cn':\n        # Setup the tridiagonal matrix A for the linear system A*V_new = B\n        l_diag = -alpha[1:]      # Lower diagonal\n        m_diag = 1 + beta\n        u_diag = -gamma[:-1]     # Upper diagonal\n        \n        # Matrix A in banded format for scipy solver\n        # 1st row: super-diagonal, 2nd row: main-diagonal, 3rd row: sub-diagonal\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = u_diag\n        A_banded[1, :] = m_diag\n        A_banded[2, :-1] = l_diag\n\n        # Time-stepping loop\n        for n in range(N_t):\n            # Setup RHS vector B\n            B = alpha * V[0:M-1] + (1 - beta) * V[1:M] + gamma * V[2:M+1]\n\n            # Adjust RHS for boundary conditions\n            # BC at S=0 (V[0]=0) does not require adjustment as alpha[0]*V[0]=0\n            v_M_new = S_max - K * np.exp(-r * (n + 1) * dt)\n            B[-1] += gamma[-1] * v_M_new\n\n            # Solve the linear system\n            V[1:M] = solve_banded((1, 1), A_banded, B)\n            \n            # Update boundary conditions\n            V[0] = 0.0\n            V[M] = v_M_new\n            \n    return V\n\ndef calculate_oscillation_metric(V, K, S_max, M, w):\n    \"\"\"\n    Calculates the oscillation metric from the final option prices.\n    \"\"\"\n    dS = S_max / M\n    j_K = int(round(K / dS))\n    \n    start_j = max(1, j_K - w)\n    end_j = min(M - 1, j_K + w)\n    \n    max_neg_convexity = 0.0\n    for j in range(start_j, end_j + 1):\n        second_diff = V[j+1] - 2 * V[j] + V[j-1]\n        max_neg_convexity = max(max_neg_convexity, -second_diff)\n\n    return max_neg_convexity\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 10},\n        # Case B\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.2, 'r': 0.05, 'T': 0.01, 'N_t': 40},\n        # Case C\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.1, 'r': 0.05, 'T': 0.005, 'N_t': 8},\n        # Case D\n        {'K': 100, 'S_max': 500, 'M': 100, 'w': 5, 'sigma': 0.3, 'r': 0.05, 'T': 0.02, 'N_t': 64},\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for params in test_cases:\n        # Solve with Crank-Nicolson\n        V_cn = solve_black_scholes_fdm(params, method='cn')\n        osc_cn = calculate_oscillation_metric(V_cn, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Solve with Explicit method\n        V_exp = solve_black_scholes_fdm(params, method='explicit')\n        osc_exp = calculate_oscillation_metric(V_exp, params['K'], params['S_max'], params['M'], params['w'])\n\n        # Calculate the ratio\n        ratio = osc_cn / (osc_exp + epsilon)\n        results.append(ratio)\n\n    # Format the output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在识别出数值格式的局限性后，下一步自然是提升其精度。本练习将介绍一种强大且通用的技术——理查森外推法（Richardson Extrapolation），用以提高收敛阶数。你将结合使用两种不同时间步长计算出的Crank-Nicolson解，从而得出一个精度显著更高的结果，借此掌握一种科学计算中经典的加速收敛方法。",
            "id": "2439320",
            "problem": "考虑风险中性动态下，欧式看涨期权价值 $V(S,t)$ 的布莱克-斯科尔斯偏微分方程：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n对于资产价格 $S \\ge 0$ 和时间 $t \\in [0,T]$，其在到期日 $T$ 的终端条件由收益给出\n$$\nV(S,T) = \\max(S-K,0),\n$$\n以及边界条件（对于所有 $t \\in [0,T]$）\n$$\nV(0,t) = 0, \\quad V(S_{\\max},t) = S_{\\max} - K e^{-r(T-t)}.\n$$\n所有利率和波动率都必须以小数形式处理（例如，$5\\%$ 必须输入为 $0.05$）。此问题不涉及角度。不涉及物理单位。设 $S_{\\max}$ 是资产域的有限截断，其选择应足够大，以使截断误差相对于所考虑的离散化误差可以忽略不计。\n\n您必须编写一个完整的程序，该程序：\n- 使用 Crank-Nicolson 方法，在相同的均匀资产网格上计算上述问题的两个数值解。这两个解使用相同的空间步数 $M$，但时间步数不同，分别为 $N$ 和 $2N$（即时间步长为 $\\Delta t = T/N$ 和 $\\Delta t/2 = T/(2N)$）。\n- 根据 $t=0$ 时的两个数值解，应用时间上的 Richardson 外推法，将这两个解组合成一个 $t=0$ 时的外推值，以消除主阶时间离散化误差。\n- 计算欧式看涨期权在 $t=0$ 时对应的布莱克-斯科尔斯解析公式值，\n$$\nC_{\\mathrm{BS}}(S_0,K,r,\\sigma,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2) T}{\\sigma \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma \\sqrt{T},\n$$\n$\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。\n- 在 $t=0$ 和 $S=S_0$ 处，量化粗时间步长数值、细时间步长数值以及 Richardson 外推值相对于解析值的绝对误差。\n- 对于每个测试用例，报告两个作为实数的精度改进因子：粗略步长绝对误差与外推绝对误差之比，以及精细步长绝对误差与外推绝对误差之比。\n\n对于每个测试用例，对两种时间步数使用相同的均匀资产网格，并通过在资产网格上进行线性插值获得 $S=S_0$ 处 $t=0$ 时的值。所有输出都必须是实数。\n\n测试套件：\n- 测试用例 $1$：$S_0=100$, $K=100$, $r=0.03$, $\\sigma=0.25$, $T=1.0$, $S_{\\max}=5K$, $M=800$, $N=200$。\n- 测试用例 $2$：$S_0=80$, $K=100$, $r=0.01$, $\\sigma=0.15$, $T=0.25$, $S_{\\max}=5K$, $M=800$, $N=120$。\n- 测试用例 $3$：$S_0=120$, $K=100$, $r=0.00$, $\\sigma=0.05$, $T=2.0$, $S_{\\max}=6K$, $M=900$, $N=240$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于上面列出的每个测试用例，按此顺序输出五个实数：使用 $N$ 个时间步长的绝对误差，使用 $2N$ 个时间步长的绝对误差，Richardson 外推后的绝对误差，定义为 $N$ 步绝对误差与外推绝对误差之比的改进因子，以及定义为 $2N$ 步绝对误差与外推绝对误差之比的改进因子。将所有三个测试用例的值按相同顺序汇总到一个扁平列表中。例如，输出格式必须是\n$[e_{1,N}, e_{1,2N}, e_{1,\\mathrm{RE}}, \\rho_{1,N\\to \\mathrm{RE}}, \\rho_{1,2N\\to \\mathrm{RE}}, e_{2,N}, e_{2,2N}, e_{2,\\mathrm{RE}}, \\rho_{2,N\\to \\mathrm{RE}}, \\rho_{2,2N\\to \\mathrm{RE}}, e_{3,N}, e_{3,2N}, e_{3,\\mathrm{RE}}, \\rho_{3,N\\to \\mathrm{RE}}, \\rho_{3,2N\\to \\mathrm{RE}}]$。",
            "solution": "该问题要求使用 Crank-Nicolson 有限差分法对欧式看涨期权的布莱克-斯科尔斯偏微分方程（PDE）进行数值求解。然后使用 Richardson 外推法改进该解，并与布莱克-斯科尔斯解析公式进行比较以量化精度。\n\n欧式看涨期权价值 $V(S,t)$ 所遵循的布莱克-斯科尔斯 PDE 由下式给出：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n其中 $V(S,t)$ 是资产价格为 $S$、时间为 $t$ 时的期权价值，$\\sigma$ 是波动率， $r$ 是无风险利率， $K$ 是执行价格， $T$ 是到期时间。该问题定义在 $S \\ge 0$ 和 $t \\in [0,T]$ 上。\n\n这是一个终端值问题，其在 $t=T$ 时的条件由收益函数给出：\n$$\nV(S,T) = \\max(S-K, 0)\n$$\n为了将其转换为初值问题，我们引入一个新的时间变量 $\\tau = T-t$。当 $t$ 从 $0$ 变为 $T$ 时，$\\tau$ 从 $T$ 变为 $0$。时间导数变换为 $\\partial/\\partial t = -\\partial/\\partial \\tau$。该 PDE 变为一个关于 $\\tau$ 的前向抛物线方程：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n其在 $\\tau=0$ 时的初始条件为：\n$$\nV(S,0) = \\max(S-K, 0)\n$$\n以及对于 $\\tau \\in [0,T]$ 的边界条件：\n$$\nV(0,\\tau) = 0 \\quad \\text{和} \\quad V(S_{\\max},\\tau) = S_{\\max} - K e^{-r\\tau}\n$$\n这里，在 $V(S_{\\max},t)$ 的原始边界条件中，$t$ 已被 $T-\\tau$ 替换。$S$ 的域被截断为 $[0, S_{\\max}]$。\n\n我们对问题域进行离散化。资产价格域 $[0, S_{\\max}]$ 被划分为 $M$ 个宽度为 $\\Delta S = S_{\\max}/M$ 的均匀区间，创建网格点 $S_i = i \\Delta S$，$i=0, 1, \\dots, M$。时间域 $[0,T]$ 被划分为 $N$ 个宽度为 $\\Delta \\tau = T/N$ 的区间，时间步为 $\\tau_j = j \\Delta \\tau$，$j=0, 1, \\dots, N$。设 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似值。\n\nCrank-Nicolson 方法在时间区间的中点 $\\tau_{j+1/2}$ 处近似时间导数，并在时间层 $j$ 和 $j+1$ 上对空间导数算子进行平均：\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left[ (\\mathcal{L}_h V^{j+1})_i + (\\mathcal{L}_h V^j)_i \\right]\n$$\n其中 $\\mathcal{L}_h$ 是空间微分算子 $\\mathcal{L} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + r S \\frac{\\partial}{\\partial S} - r$ 的有限差分近似。我们对空间导数使用二阶中心差分：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\qquad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\n将这些代入算子 $\\mathcal{L}_h$ 并整理 Crank-Nicolson 格式，将时间层 $j+1$ 的未知值（在左侧）与时间层 $j$ 的已知值（在右侧）分离开，我们得到一个三对角线性系统：\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\n对于内部网格点 $i=1, \\dots, M-1$，该系统的第 $i$ 行可以写为：\n$$\n-\\alpha_i V_{i-1}^{j+1} + \\beta_i V_i^{j+1} - \\gamma_i V_{i+1}^{j+1} = \\alpha_i V_{i-1}^{j} + (2-\\beta_i) V_i^{j} + \\gamma_i V_{i+1}^{j}\n$$\n其中系数（假设 $\\Delta S=1$ 以简化符号，并在代码中体现）定义为：\n$$\n\\alpha_i = \\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - ri\\right)\n$$\n$$\n\\beta_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\n\\gamma_i = \\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + ri\\right)\n$$\n左侧定义了一个三对角矩阵，右侧是一个根据前一个时间步的值计算出的向量。边界条件 $V_0^j = 0$ 和 $V_M^j = S_{\\max} - K e^{-r\\tau_j}$ 通过修改方程组的第一个和最后一个方程来并入。具体来说，对于 $i=1$，涉及 $V_0^{j+1}$ 的项为零。对于 $i=M-1$，项 $-\\gamma_{M-1}V_M^{j+1}$ 是已知的，并移到右侧。在每个时间步高效地求解所得的三对角系统，将解从 $\\tau=0$ 推进到 $\\tau=T$。\n\nCrank-Nicolson 方法的时间离散化误差为 $O((\\Delta \\tau)^2)$ 阶。我们可以使用 Richardson 外推法来提高精度。设 $C_N(S_0)$ 是使用 $N$ 个时间步（步长 $\\Delta \\tau = T/N$）在 $S=S_0$ 和 $t=0$ 处的数值解，而 $C_{2N}(S_0)$ 是使用 $2N$ 个时间步（步长 $\\Delta \\tau/2$）的解。误差展开式为：\n$$\nC_N \\approx C_{\\text{true}} + c (\\Delta \\tau)^2, \\quad C_{2N} \\approx C_{\\text{true}} + c (\\Delta \\tau/2)^2\n$$\n求解主误差项并代入，我们得到一个具有更高精度阶 $O((\\Delta \\tau)^4)$ 的外推值 $C_{\\text{RE}}$：\n$$\nC_{\\text{RE}}(S_0) = \\frac{4C_{2N}(S_0) - C_N(S_0)}{3}\n$$\n最后，我们使用布莱克-斯科尔斯公式计算欧式看涨期权在 $t=0$ 时的解析解：\n$$\nC_{\\text{BS}}(S_0,T) = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2) T}{\\sigma \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma \\sqrt{T}\n$$\n$\\Phi(\\cdot)$ 是标准正态累积分布函数。计算数值解（$e_N = |C_N - C_{\\text{BS}}|$，$e_{2N} = |C_{2N} - C_{\\text{BS}}|$）和外推解（$e_{\\text{RE}} = |C_{\\text{RE}} - C_{\\text{BS}}|$）的绝对误差。精度改进因子计算为比率 $\\rho_{N\\to \\mathrm{RE}} = e_N/e_{\\text{RE}}$ 和 $\\rho_{2N\\to \\mathrm{RE}} = e_{2N}/e_{\\text{RE}}$。\n\n如果 $S_0$ 不是网格点，则通过在最终资产网格上进行线性插值来获得 $S=S_0$ 处的数值解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.linalg import solve_banded\n\ndef solve_black_scholes_cn(params):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    Unpacks S0, K, r, sigma, T, S_max, M, N from a dictionary.\n    Returns the option value at S0, t=0.\n    \"\"\"\n    S0, K, r, sigma, T, S_max, M, N = params['S0'], params['K'], params['r'], params['sigma'], params['T'], params['S_max'], params['M'], params['N']\n\n    # Grid setup\n    dt = T / N  # Time step, in forward tau time\n    ds = S_max / M  # Asset price step\n    S_grid = np.linspace(0, S_max, M + 1)\n    \n    # Grid for interior points i = 1, ..., M-1\n    i_pts = np.arange(1, M)\n    \n    # Coefficients for the tridiagonal matrix\n    alpha = 0.25 * dt * (sigma**2 * i_pts**2 - r * i_pts)\n    beta = 1.0 + 0.5 * dt * (sigma**2 * i_pts**2 + r)\n    gamma = 0.25 * dt * (sigma**2 * i_pts**2 + r * i_pts)\n    \n    # Tridiagonal matrix for the LHS (constant in time)\n    # Using scipy's solve_banded format (l=1, u=1)\n    ab = np.zeros((3, M - 1))\n    ab[0, 1:] = -gamma[:-1]\n    ab[1, :] = beta\n    ab[2, :-1] = -alpha[1:]\n    \n    # Initial condition at tau=0 (t=T)\n    V = np.maximum(S_grid - K, 0)\n    \n    # Time-stepping loop (forward in tau from 0 to T)\n    for j in range(N):\n        tau_jp1 = (j + 1) * dt\n        \n        # RHS vector, computed from known values at time j\n        D = alpha * V[0:M-1] + (2.0 - beta) * V[1:M] + gamma * V[2:M+1]\n        \n        # Apply boundary condition at S=S_max\n        V_M_jp1 = S_max - K * np.exp(-r * tau_jp1)\n        D[-1] += gamma[-1] * V_M_jp1\n        \n        # Solve the tridiagonal system Ax=b\n        V_interior_new = solve_banded((1, 1), ab, D)\n        \n        # Update V for the next time step\n        V[1:M] = V_interior_new\n        V[0] = 0.0  # Dirichlet BC at S=0\n        V[M] = V_M_jp1 # Update boundary for use in next iteration's RHS calculation\n\n    # Interpolate to find V(S0, t=0)\n    if np.isclose(S0 % ds, 0.0) or np.isclose(S0 % ds, ds):\n        k = int(round(S0 / ds))\n        return V[k]\n    else:\n        k = int(S0 / ds)\n        w = (S0 - S_grid[k]) / ds\n        return V[k] * (1.0 - w) + V[k+1] * w\n\ndef black_scholes_analytical(params):\n    \"\"\"\n    Calculates the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    S0, K, r, sigma, T = params['S0'], params['K'], params['r'], params['sigma'], params['T']\n    \n    if T == 0.0:\n        return np.maximum(S0 - K, 0.0)\n    if sigma == 0.0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0.0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'S0': 100, 'K': 100, 'r': 0.03, 'sigma': 0.25, 'T': 1.0, 'S_max_factor': 5, 'M': 800, 'N': 200},\n        {'S0': 80, 'K': 100, 'r': 0.01, 'sigma': 0.15, 'T': 0.25, 'S_max_factor': 5, 'M': 800, 'N': 120},\n        {'S0': 120, 'K': 100, 'r': 0.00, 'sigma': 0.05, 'T': 2.0, 'S_max_factor': 6, 'M': 900, 'N': 240},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # Calculate S_max based on K and the factor\n        case_params['S_max'] = case_params['K'] * case_params['S_max_factor']\n        \n        # Analytical solution\n        C_BS = black_scholes_analytical(case_params)\n\n        # Numerical solution with N steps\n        params_N = case_params.copy()\n        C_N = solve_black_scholes_cn(params_N)\n        \n        # Numerical solution with 2N steps\n        params_2N = case_params.copy()\n        params_2N['N'] = 2 * case_params['N']\n        C_2N = solve_black_scholes_cn(params_2N)\n        \n        # Richardson extrapolation\n        C_RE = (4.0 * C_2N - C_N) / 3.0\n        \n        # Absolute errors\n        e_N = abs(C_N - C_BS)\n        e_2N = abs(C_2N - C_BS)\n        e_RE = abs(C_RE - C_BS)\n\n        # Improvement factors\n        # Handle division by zero if extrapolated error is zero\n        rho_N_RE = e_N / e_RE if e_RE > 0 else np.inf\n        rho_2N_RE = e_2N / e_RE if e_RE > 0 else np.inf\n\n        results.extend([e_N, e_2N, e_RE, rho_N_RE, rho_2N_RE])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了欧式期权定价的基础上，本练习将Crank-Nicolson方法扩展到更复杂的美式期权领域。由于存在提前行权特性，美式期权定价是一个自由边界问题，我们将通过在每个时间步内使用投影逐次超松弛（Projected Successive Over-Relaxation, PSOR）方法来处理这一挑战。这项实践展示了如何调整有限差分框架，以解决金融领域中常见的线性互补问题，体现了该方法的强大适应性。",
            "id": "2439350",
            "problem": "要求您在 Black-Scholes 框架下，使用 Crank-Nicolson 时间步进格式结合投影逐次超松弛 (PSOR) 方法，为美式看跌期权的提前行权溢价实现一个数值求解器。在每个时间步，PSOR 方法用于强制执行不等式约束。您的程序必须是一个完整的、可运行的程序，不接受任何输入，并为下方指定的固定测试套件打印结果。\n\n从以下基本原理出发：\n- 风险中性定价以及针对在不支付股息或支付股息的标的资产上发行的衍生品，其无套利价格所满足的偏微分方程 (PDE)。在风险中性测度下，标的价格 $S$ 服从一个漂移项为 $r - q$ 的几何布朗运动，其中 $r$ 是连续复利无风险利率，$q$ 是连续股息收益率。对于一个足够平滑的价格函数 $V(S,t)$，其 Black-Scholes 偏微分方程 (PDE) 为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其中 $\\sigma$ 是恒定波动率，$r$ 是恒定无风险利率，$q$ 是恒定股息收益率。\n- 对于执行价格为 $K$、到期日为 $T$ 的美式看跌期权，其价值 $V(S,t)$ 必须满足线性互补条件\n$$\nV(S,t) \\geq \\max(K - S, 0), \\quad -\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V \\geq 0,\n$$\n以及逐点互补性\n$$\n\\left(V(S,t) - \\max(K - S, 0)\\right)\\left(-\\frac{\\partial V}{\\partial t} - \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - (r - q) S \\frac{\\partial V}{\\partial S} + r V\\right) = 0,\n$$\n对于所有 $S \\geq 0$ 和 $t \\in [0,T)$。终端支付条件为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n使用符合经济学推理的边界条件：对于美式看跌期权，在所有 $t \\in [0,T]$，下边界 $S = 0$ 处取 $V(0,t) = K$，而在一个足够大的上边界 $S = S_{\\max}$ 处取 $V(S_{\\max}, t) = 0$。\n\n任务要求：\n- 在一个具有 $N$ 个子区间的均匀网格上对空间域 $S \\in [0, S_{\\max}]$ 进行离散化，$\\Delta S = S_{\\max} / N$；对时间域 $[0,T]$ 以大小为 $\\Delta t = T/M$ 的 $M$ 个均匀步长进行离散化。对内部网格节点应用 Crank-Nicolson 方法，以便在每个后向时间步形成一个三对角线性互补问题 (LCP)。\n- 在每个时间步，使用投影逐次超松弛 (PSOR) 方法求解离散的 LCP。迭代必须使用一个超松弛因子 $\\omega \\in (0,2)$，并通过在每个空间节点 $S_i$ 上将迭代值投影到障碍 $\\max(K - S_i, 0)$ 来强制执行行权约束。\n- 使用线性插值返回在给定即期价格 $S_0$ 处的期权价格，该价格可能不恰好落在网格节点上。\n- 所有利率 $r$、$q$ 和波动率 $\\sigma$ 必须以小数形式表示（例如，$5\\%$ 表示为 $0.05$）。时间 $T$ 必须以年为单位。不涉及角度单位。输入或输出中不得出现百分号；仅使用小数。\n\n实现细节要求：\n- 在均匀网格上推导 Crank-Nicolson 半隐式内部节点离散化，从而为新的时间层级生成一个三对角的左侧项，为使用前一个时间层级生成一个三对角的右侧项，并一致地并入边界值。不要使用任何美式期权定价的闭式解公式或惩罚方法；您必须通过 PSOR 强制执行提前行权约束。\n- 实现一个基于所有内部节点上的最大绝对变化量小于容差 $\\varepsilon$ 的 PSOR 停止准则，并设置一个最大迭代次数的硬性上限以保证终止。\n- 通过为下面的每个测试案例选择足够大的 $S_{\\max}$ 以及足够的空间和时间分辨率来确保数值稳定性。\n\n测试套件：\n为下面每个参数集计算在即期价格 $S_0$ 处的美式看跌期权价格。使用指定的 $S_{\\max}$、$N$、$M$、PSOR 松弛因子 $\\omega$、容差 $\\varepsilon$ 和每个时间步的最大迭代次数 $I_{\\max}$。参数以元组 $(S_0, K, T, r, q, \\sigma, S_{\\max}, N, M, \\omega, \\varepsilon, I_{\\max})$ 形式给出：\n- 案例 1（基准情况，一年期，中等波动率）：$(100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1\\times 10^{-8}, 10000)$。\n- 案例 2（一年期，高波动率，低利率）：$(100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1\\times 10^{-8}, 10000)$。\n- 案例 3（一年期，零利率）：$(100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1\\times 10^{-8}, 10000)$。\n- 案例 4（短期限，价内）：$(50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1\\times 10^{-8}, 10000)$。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含一个由方括号括起来的、按案例 1 至 4 排序的、逗号分隔的浮点数列表。\n- 每个数字必须四舍五入到恰好 $6$ 位小数。\n- 例如，输出格式必须类似于 $[v_1,v_2,v_3,v_4]$，其中每个 $v_i$ 是一个四舍五入到 $6$ 位小数的浮点数。",
            "solution": "用户指定了一个计算金融领域的问题：通过数值求解带提前行权约束的 Black-Scholes 偏微分方程 (PDE) 来为美式看跌期权定价。该问题具有科学依据、是适定的，并且提供了完整解决方案所需的所有必要参数。因此，该问题被认为是有效的。解决方案需要实现用于时间离散化的 Crank-Nicolson 方法，以及用于处理因提前行权特性而产生的线性互补问题的投影逐次超松弛 (PSOR) 方法。\n\n期权价格 $V(S,t)$（其中 $S$ 是标的资产价格，$t$ 是时间）的 Black-Scholes 模型由以下 PDE 给出：\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\n这里，$r$ 是无风险利率，$q$ 是连续股息收益率，$\\sigma$ 是标的资产的波动率。对于美式看跌期权，此方程变为一个不等式，且解必须满足一个线性互补形式，因为它是一个自由边界问题。价格必须始终大于或等于其内在价值，$V(S,t) \\geq \\max(K-S, 0)$，其中 $K$ 是执行价格。\n\n这是一个终端值问题，从到期时间 $T$ 向后求解至当前时间 $t=0$。为便于使用标准的向前步进数值格式，我们对时间进行变量替换，令 $\\tau = T - t$。PDE 变为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + (r - q) S \\frac{\\partial V}{\\partial S} - r V\n$$\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散化为 $N$ 个大小为 $\\Delta S = S_{\\max}/N$ 的区间，创建网格点 $S_i = i\\Delta S$，其中 $i=0, 1, \\dots, N$。时间域 $\\tau \\in [0, T]$ 被离散化为 $M$ 个大小为 $\\Delta \\tau = T/M$ 的步长，创建时间点 $\\tau_j = j\\Delta\\tau$，其中 $j=0, 1, \\dots, M$。令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似。\n\nCrank-Nicolson 方法在时间中点 $\\tau_{j+1/2}$ 逼近时间导数，并在时间层级 $j$ 和 $j+1$ 上对空间算子取平均：\n$$\n\\frac{V^{j+1} - V^{j}}{\\Delta \\tau} = \\frac{1}{2}(\\mathcal{L}V^{j+1} + \\mathcal{L}V^{j})\n$$\n其中 $\\mathcal{L}$ 是空间微分算子。整理后，在每个时间步得到一个需求解的线性方程组：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j+1} = \\left(\\mathbf{I} + \\frac{\\Delta \\tau}{2}\\mathbf{L}\\right) \\mathbf{V}^{j}\n$$\n其中 $\\mathbf{L}$ 是在使用中心有限差分对导数 $\\frac{\\partial V}{\\partial S}$ 和 $\\frac{\\partial^2 V}{\\partial S^2}$ 进行空间离散化后，算子 $\\mathcal{L}$ 的矩阵表示：\n$$\n\\frac{\\partial V}{\\partial S}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - V_{i-1}}{2\\Delta S}, \\quad \\frac{\\partial^2 V}{\\partial S^2}\\bigg|_{S_i} \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{(\\Delta S)^2}\n$$\n将这些代入算子 $\\mathcal{L}$ 中，矩阵 $\\mathbf{L}$ 会呈现出三对角结构。每个内部节点 $i=1, \\dots, N-1$ 的方程为：\n$$\nL_i V_{i-1}^{j+1} + M_i V_i^{j+1} + R_i V_{i+1}^{j+1} = Q_i\n$$\n系数定义如下：\n$$\nL_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 - (r-q)i\\right)\n$$\n$$\nM_i = 1 + \\frac{\\Delta \\tau}{2}\\left(\\sigma^2 i^2 + r\\right)\n$$\n$$\nR_i = -\\frac{\\Delta \\tau}{4}\\left(\\sigma^2 i^2 + (r-q)i\\right)\n$$\n右侧项 $Q_i$ 由时间步 $j$ 的已知值构造：\n$$\nQ_i = -L_i V_{i-1}^{j} + (2-M_i)V_i^{j} - R_i V_{i+1}^{j}\n$$\n美式看跌期权的边界条件是 $V(0,\\tau) = K$ 和 $V(S_{\\max}, \\tau) = 0$。这些条件通过调整右侧向量 $Q$ 来并入。对于第一个内部节点 $i=1$，项 $L_1 V_0^{j+1}$ 移到右侧，变为 $L_1 K$。类似地，在最后一个内部节点 $i=N-1$ 处，项 $R_{N-1}V_N^{j+1}$ 为 $0$。\n\n提前行权约束要求对于所有 $i$，$V_i^{j+1} \\geq g_i = \\max(K-S_i, 0)$。这将线性系统转化为一个线性互补问题 (LCP)，我们使用投影逐次超松弛 (PSOR) 方法来求解。对于每个时间步，我们进行迭代以找到向量 $\\mathbf{V}^{j+1}$。每个内部节点 $i$ 的第 $k$ 次迭代的更新规则如下：\n\n1. 计算标准 SOR 更新：\n$$\nv_i^{*} = (1-\\omega)V_i^{(k)} + \\frac{\\omega}{M_i} \\left( Q_i - L_i V_{i-1}^{(k+1)} - R_i V_{i+1}^{(k)} \\right)\n$$\n其中 $\\omega \\in (0,2)$ 是松弛参数，$V^{(k)}$ 是上一次迭代的向量，$V^{(k+1)}$ 使用当前迭代中已更新的值。\n\n2. 将结果投影到行权价值（障碍）上：\n$$\nV_i^{(k+1)} = \\max(v_i^{*}, g_i)\n$$\nPSOR 迭代持续进行，直到所有节点上连续迭代之间的最大绝对变化量低于容差 $\\varepsilon$，或者达到最大迭代次数 $I_{\\max}$。\n\n整体算法如下：\n1.  在到期日 $\\tau=0$（即 $t=T$）时，用终端支付函数初始化期权价值网格 $\\mathbf{V}$：$V_i^0 = \\max(K - S_i, 0)$。\n2.  从 $j=0$ 到 $M-1$ 进行时间上的向后迭代。在每一步中：\n    a.  使用 $\\mathbf{V}^j$ 的值计算右侧向量 $\\mathbf{Q}$。\n    b.  根据边界条件调整 $\\mathbf{Q}$。\n    c.  以 $\\mathbf{V}^j$ 为初始猜测，使用 PSOR 算法求解 LCP 得到 $\\mathbf{V}^{j+1}$。\n    d.  强制执行边界条件 $V_0^{j+1} = K$ 和 $V_N^{j+1} = 0$。\n3.  在最后一个时间步之后，向量 $\\mathbf{V}^M$ 包含 $t=0$ 时的期权价格。\n4.  使用线性插值找到在特定即期价格 $S_0$ 处的期权价格，该价格可能不在网格点上。\n\n此过程为美式看跌期权价格提供了一个稳健的数值解，同时遵循了 Black-Scholes 框架的无套利条件和提前行权约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_american_put_price(S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max):\n    \"\"\"\n    Computes the American put option price using the Crank-Nicolson FDM and PSOR.\n\n    :param S0: Initial stock price\n    :param K: Strike price\n    :param T: Time to maturity (in years)\n    :param r: Risk-free interest rate (decimal)\n    :param q: Continuous dividend yield (decimal)\n    :param sigma: Volatility (decimal)\n    :param S_max: Maximum stock price in the grid\n    :param N: Number of spatial steps\n    :param M: Number of time steps\n    :param omega: SOR relaxation factor\n    :param epsilon: PSOR tolerance\n    :param I_max: Max iterations for PSOR\n    :return: American put option price at S0\n    \"\"\"\n    # 1. Grid setup\n    dt = T / M\n    ds = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n    \n    # 2. Initialize option values at maturity (t=T)\n    V = np.maximum(K - S, 0)\n    \n    # 3. Pre-compute Crank-Nicolson coefficients for the tridiagonal system\n    # These coefficients are used for the matrix on the LHS of the time-step equation.\n    i = np.arange(1, N)  # Interior nodes\n    \n    # Coefficients for L_i * V_{i-1} + M_i * V_i + R_i * V_{i+1} = Q_i\n    L_coeffs = -0.25 * dt * (sigma**2 * i**2 - (r - q) * i)\n    M_coeffs = 1 + 0.5 * dt * (sigma**2 * i**2 + r)\n    R_coeffs = -0.25 * dt * (sigma**2 * i**2 + (r - q) * i)\n\n    # 4. Time-stepping loop (backward from T to 0, which is forward in tau)\n    for j in range(M):\n        # Calculate the explicit part (RHS) of the CN scheme\n        Q = -L_coeffs * V[:-2] + (2 - M_coeffs) * V[1:-1] - R_coeffs * V[2:]\n\n        # Adjust RHS for boundary conditions.\n        # The full system for node i=1 is: L_1*V_0^{j+1} + M_1*V_1^{j+1} + R_1*V_2^{j+1} = -L_1*V_0^j + ...\n        # Since V_0 is always K, this becomes: M_1*V_1^{j+1} + R_1*V_2^{j+1} = (-L_1*K + ...) - L_1*K\n        # The first term (-L_1*K) is already in Q[0]. We need to subtract the second term.\n        Q[0] -= L_coeffs[0] * K\n\n        # 5. PSOR solver for the linear complementarity problem at each time step\n        v_interior = V[1:-1].copy()  # Initial guess from previous time step\n        obstacle = np.maximum(K - S[1:-1], 0)\n\n        for k in range(I_max):\n            v_old_iter = v_interior.copy()\n\n            # Iterate through interior nodes\n            for i in range(N - 1):\n                # SOR update calculation\n                sor_sum = 0\n                if i > 0:\n                    sor_sum += L_coeffs[i] * v_interior[i - 1]\n                if i  N - 2:\n                    sor_sum += R_coeffs[i] * v_old_iter[i + 1]\n\n                v_star = (1 - omega) * v_old_iter[i] + (omega / M_coeffs[i]) * (Q[i] - sor_sum)\n                \n                # Projection step\n                v_interior[i] = max(v_star, obstacle[i])\n\n            # Check for convergence\n            if np.max(np.abs(v_interior - v_old_iter))  epsilon:\n                break\n        \n        # Update V with the solution for the current time step\n        V[1:-1] = v_interior\n        V[0] = K  # Boundary at S=0\n        V[N] = 0.0 # Boundary at S=S_max\n        \n    # 6. Interpolate to find price at S0\n    idx = int(S0 / ds)\n    if idx >= N: # Handle case where S0 is at or beyond S_max\n        return 0.0\n    \n    # Linear interpolation\n    price = V[idx] + (V[idx + 1] - V[idx]) * (S0 - S[idx]) / ds\n    return price\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, T, r, q, sigma, S_max, N, M, omega, epsilon, I_max)\n        (100.0, 100.0, 1.0, 0.05, 0.0, 0.2, 500.0, 200, 400, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.01, 0.0, 0.6, 600.0, 180, 500, 1.5, 1e-8, 10000),\n        (100.0, 100.0, 1.0, 0.0, 0.0, 0.2, 500.0, 180, 400, 1.5, 1e-8, 10000),\n        (50.0, 100.0, 0.0833333333333, 0.05, 0.0, 0.2, 500.0, 140, 120, 1.5, 1e-8, 10000),\n    ]\n\n    results = []\n    for case in test_cases:\n        params = {\n            \"S0\": case[0], \"K\": case[1], \"T\": case[2], \"r\": case[3], \"q\": case[4], \n            \"sigma\": case[5], \"S_max\": case[6], \"N\": case[7], \"M\": case[8], \n            \"omega\": case[9], \"epsilon\": case[10], \"I_max\": case[11]\n        }\n        price = compute_american_put_price(**params)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}