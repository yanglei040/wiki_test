{
    "hands_on_practices": [
        {
            "introduction": "Before we can simulate a market, we must understand the motivations of its participants. This exercise uses game theory to model the fundamental choice every trader faces: the speed and certainty of a market order ($M$) versus the potential for a better price with a limit order ($L$). By finding the symmetric mixed-strategy Nash equilibrium where traders choose $M$ with probability $p^\\star$, you will quantify this trade-off and build a theoretical basis for the agent behaviors we simulate next .",
            "id": "2406558",
            "problem": "Consider a one-step limit order book (LOB) environment with best bid price $b$ and best ask price $a$, where $a  b$. Two risk-neutral traders simultaneously arrive and each demands one unit of the asset. Each trader has a common valuation $v$ for one unit, with $v$ known to both traders and satisfying $v \\geq a$. Each trader chooses one of two actions: submit a market order to buy at the best ask (denote this action by $M$), or submit a limit buy order at the best bid (denote this action by $L$). The following institutional features and payoffs hold:\n\n- If a trader chooses $M$ and the other chooses $L$, the market order executes immediately at price $a$, yielding surplus $v - a$ to the market-order trader. The limit order does not execute immediately and may execute against an exogenous noise seller with probability $\\theta \\in (0,1)$ at price $b$, yielding surplus $v - b$ if it executes, and $0$ otherwise.\n\n- If both traders choose $M$ simultaneously, the limit order book has depth of one unit at price $a$ and one unit at the next best ask price $a + \\delta$, with $\\delta  0$. The continuous double auction breaks ties uniformly at random so that one trader executes at price $a$ and the other executes at price $a + \\delta$. Thus, each trader’s expected purchase price is $a + \\delta / 2$, and each trader’s expected surplus is $v - (a + \\delta / 2)$.\n\n- If both traders choose $L$ simultaneously, their limit orders enter the bid queue at price $b$. A single unit of noise-seller supply arrives with probability $\\theta \\in (0,1)$ and executes against the first order in the bid queue. Under uniform tie-breaking for queue priority, each trader’s limit order executes with probability $\\theta / 2$ at price $b$, yielding expected surplus $(\\theta / 2)(v - b)$ per trader.\n\nAssume parameters $a$, $b$, $v$, $\\theta$, and $\\delta$ satisfy the inequalities $0  2(v - a) - \\theta (v - b)  \\delta + \\theta (v - b)$ so that there exists an interior symmetric mixed-strategy Nash equilibrium.\n\nLet each trader independently choose $M$ with probability $p$ and $L$ with probability $1 - p$. Determine, in closed form, the symmetric mixed-strategy Nash equilibrium probability $p^\\star$ with which each trader chooses $M$, expressed as a function of $a$, $b$, $v$, $\\theta$, and $\\delta$.\n\nYour final answer must be a single closed-form analytic expression. Do not approximate or round.",
            "solution": "The problem statement is subjected to validation.\n\nStep 1: Extract Givens.\n- Best bid price: $b$.\n- Best ask price: $a$, with $a  b$.\n- Number of traders: $2$.\n- Demand per trader: $1$ unit.\n- Common asset valuation: $v$, with $v \\geq a$.\n- Trader actions: Market order ($M$) or Limit order ($L$).\n- Payoffs (Surplus):\n    - Trader $1$ plays $M$, Trader $2$ plays $L$: Payoff for Trader $1$ is $v - a$. Payoff for Trader $2$ is $\\theta (v - b)$ in expectation.\n    - Both traders play $M$: Each trader's expected surplus is $v - (a + \\delta / 2)$, where $\\delta  0$.\n    - Both traders play $L$: Each trader's expected surplus is $(\\theta / 2)(v - b)$, where $\\theta \\in (0,1)$.\n- Parameter constraint: $0  2(v - a) - \\theta (v - b)  \\delta + \\theta (v - b)$.\n- Strategy: Each trader independently chooses action $M$ with probability $p$ and action $L$ with probability $1 - p$.\n- Objective: Find the symmetric mixed-strategy Nash equilibrium probability $p^\\star$.\n\nStep 2: Validate Using Extracted Givens.\nThe problem is scientifically grounded, well-posed, and objective. It is a standard application of game theory to the domain of financial market microstructure, a subfield of computational economics. The problem provides all necessary information to construct a payoff matrix for a $2$-player symmetric game. The given inequality ensures that a non-trivial (interior) mixed-strategy Nash equilibrium exists, which is precisely what the question asks to find. The problem is free of logical contradictions, factual errors, and ambiguity. It is a formalizable scientific problem.\n\nStep 3: Verdict and Action.\nThe problem is valid. A solution will be provided.\n\nThe problem describes a symmetric $2$-player game where each player has two strategies: submit a market order ($M$) or a limit order ($L$). We seek a symmetric mixed-strategy Nash equilibrium where each player chooses $M$ with probability $p^\\star$ and $L$ with probability $1-p^\\star$.\n\nFirst, we construct the payoff matrix for a representative player (Player $1$) based on the actions of both players. The entries $(U_{1}, U_{2})$ represent the payoffs (surpluses) to Player $1$ and Player $2$, respectively.\n\n1.  If both players choose $M$: The expected surplus for each is given as $v - (a + \\frac{\\delta}{2})$. The payoff entry is $(v - a - \\frac{\\delta}{2}, v - a - \\frac{\\delta}{2})$.\n2.  If Player $1$ chooses $M$ and Player $2$ chooses $L$: Player $1$'s surplus is $v - a$. Player $2$'s expected surplus is $\\theta(v-b)$. The payoff entry is $(v - a, \\theta(v-b))$.\n3.  If Player $1$ chooses $L$ and Player $2$ chooses $M$: By symmetry, Player $1$'s expected surplus is $\\theta(v-b)$ and Player $2$'s surplus is $v-a$. The payoff entry is $(\\theta(v-b), v - a)$.\n4.  If both players choose $L$: The expected surplus for each is given as $\\frac{\\theta}{2}(v - b)$. The payoff entry is $(\\frac{\\theta}{2}(v-b), \\frac{\\theta}{2}(v-b))$.\n\nThe payoff matrix for Player $1$ is therefore:\n$$\n\\begin{array}{c|c|c}\n  \\text{Player 2 plays } M  \\text{Player 2 plays } L \\\\\n\\hline\n\\text{Player 1 plays } M  v - a - \\frac{\\delta}{2}  v - a \\\\\n\\hline\n\\text{Player 1 plays } L  \\theta(v-b)  \\frac{\\theta}{2}(v-b) \\\\\n\\end{array}\n$$\nIn a symmetric mixed-strategy Nash equilibrium, a player must be indifferent between their pure strategies, given the other player's mixed strategy. Let's assume Player $2$ chooses $M$ with probability $p$ and $L$ with probability $1-p$. We can find the equilibrium probability $p^\\star$ by equating the expected payoffs for Player $1$ from choosing $M$ and $L$.\n\nThe expected payoff for Player $1$ from choosing $M$, denoted $E[U_1(M)]$, is:\n$$E[U_1(M)] = p \\left( v - a - \\frac{\\delta}{2} \\right) + (1-p)(v-a)$$\nThe expected payoff for Player $1$ from choosing $L$, denoted $E[U_1(L)]$, is:\n$$E[U_1(L)] = p \\left( \\theta(v-b) \\right) + (1-p)\\left( \\frac{\\theta}{2}(v-b) \\right)$$\nFor indifference, we must have $E[U_1(M)] = E[U_1(L)]$.\n$$p \\left( v - a - \\frac{\\delta}{2} \\right) + (1-p)(v-a) = p \\theta(v-b) + (1-p)\\frac{\\theta}{2}(v-b)$$\nWe expand and simplify both sides of the equation.\nLeft-hand side (LHS):\n$$LHS = p(v-a) - p\\frac{\\delta}{2} + (v-a) - p(v-a) = (v-a) - p\\frac{\\delta}{2}$$\nRight-hand side (RHS):\n$$RHS = p\\theta(v-b) + \\frac{\\theta}{2}(v-b) - p\\frac{\\theta}{2}(v-b) = p\\frac{\\theta}{2}(v-b) + \\frac{\\theta}{2}(v-b)$$\nSetting LHS equal to RHS:\n$$(v-a) - p\\frac{\\delta}{2} = p\\frac{\\theta}{2}(v-b) + \\frac{\\theta}{2}(v-b)$$\nNow, we solve for $p$. We group terms containing $p$ on one side and constant terms on the other.\n$$(v-a) - \\frac{\\theta}{2}(v-b) = p\\frac{\\delta}{2} + p\\frac{\\theta}{2}(v-b)$$\n$$(v-a) - \\frac{\\theta(v-b)}{2} = p\\left(\\frac{\\delta}{2} + \\frac{\\theta(v-b)}{2}\\right)$$\nMultiply the entire equation by $2$ to eliminate the fractions:\n$$2(v-a) - \\theta(v-b) = p(\\delta + \\theta(v-b))$$\nFinally, we isolate $p$ to find the equilibrium probability, which we denote $p^\\star$:\n$$p^\\star = \\frac{2(v-a) - \\theta(v-b)}{\\delta + \\theta(v-b)}$$\nThe problem states that the parameters satisfy $0  2(v - a) - \\theta (v - b)  \\delta + \\theta (v - b)$. This inequality ensures that the numerator is positive and strictly less than the denominator. Given that $\\delta  0$, $\\theta \\in (0,1)$, and $v  b$, the denominator $\\delta + \\theta(v-b)$ is strictly positive. Therefore, the condition guarantees that $0  p^\\star  1$, which is required for an interior mixed-strategy equilibrium.",
            "answer": "$$\\boxed{\\frac{2(v-a) - \\theta(v-b)}{\\delta + \\theta(v-b)}}$$"
        },
        {
            "introduction": "With a grasp of individual trading strategy, we can now build a complete market ecosystem from the ground up. This practice challenges you to construct a discrete-time limit order book simulator, incorporating various event types and the behavior of a stylized high-frequency trading (HFT) agent . This simulation will allow you to directly observe how market rules, such as the minimum price increment or tick size, affect market dynamics and HFT profitability.",
            "id": "2406579",
            "problem": "Construct a complete, runnable program that simulates a discrete-time limit order book under price-time priority, to examine the impact of allowing sub-penny pricing on order queue dynamics and a stylized high-frequency trading (HFT) strategy. The model must be defined as follows.\n\nThe asset has a fixed reference level price $P^{\\ast}$ measured in arbitrary currency units. Prices are constrained to a grid with tick size $\\Delta p$, so any quote must be a multiple of $\\Delta p$. Initialize the baseline best bid and best ask at $B_0 = P^{\\ast} - \\Delta p$ and $A_0 = P^{\\ast} + \\Delta p$. Initialize the baseline best bid queue size $Q^0_B$ and best ask queue size $Q^0_A$ (in units), each measured as integers. Time is discrete with steps $t \\in \\{1,2,\\ldots,T\\}$. At each time step exactly one event occurs, independently of the past, according to a categorical distribution with probabilities $p_{\\text{MB}}$, $p_{\\text{MS}}$, $p_{\\text{LB}}$, $p_{\\text{LS}}$, and $p_{\\text{C}}$ that sum to $1$. The five event types are:\n- Market buy (MB) of unit size $1$: removes $1$ unit from the current best ask queue, if available.\n- Market sell (MS) of unit size $1$: removes $1$ unit from the current best bid queue, if available.\n- Baseline limit buy (LB) of unit size $1$: adds $1$ unit to the baseline best bid queue at price $B_t$.\n- Baseline limit sell (LS) of unit size $1$: adds $1$ unit to the baseline best ask queue at price $A_t$.\n- Baseline cancellation (C) of unit size $1$: removes $1$ unit from exactly one of the baseline best queues that currently has strictly positive size, chosen uniformly at random among such sides; if both baseline best queues are empty, this event has no effect.\n\nPrice-time priority means that trades execute at the highest bid and the lowest ask; within a price level, execution priority is first-in-first-out, but since the simulation aggregates homogeneous unit-size orders per side, it is sufficient to update the aggregate queue sizes accordingly. Prices $B_t$ and $A_t$ for baseline orders remain fixed at $B_t = P^{\\ast} - \\Delta p$ and $A_t = P^{\\ast} + \\Delta p$ for all $t$.\n\nIntroduce a stylized high-frequency trading (HFT) agent characterized by parameters: HFT posting quantity $q_{\\text{HFT}} \\in \\mathbb{Z}_{\\ge 0}$ (units) and a time-to-live $\\tau \\in \\mathbb{Z}_{\\ge 1}$ (steps) for its limit orders. The HFT agent is allowed to improve the price by exactly one tick relative to the baseline best on at most one side at any time, which is feasible only because the tick grid allows such price improvement. The HFT agent follows these rules:\n- Activation: Immediately after an LB event, if $q_{\\text{HFT}} \\ge 1$, the HFT posts a buy limit order of size $q_{\\text{HFT}}$ at the improved price $P^{\\ast}$ (one-tick better than the baseline best bid). Immediately after an LS event, if $q_{\\text{HFT}} \\ge 1$, the HFT posts a sell limit order of size $q_{\\text{HFT}}$ at the improved price $P^{\\ast}$ (one-tick better than the baseline best ask). If the HFT already has an active order on the opposite side, that order is cancelled upon this activation. On activation (or re-activation on the same side), the HFT order’s remaining quantity is set to $q_{\\text{HFT}}$ and its remaining time-to-live is set to $\\tau$.\n- Priority and spread: If the HFT has an active buy at price $P^{\\ast}$, then the current best bid becomes $P^{\\ast}$ while the best ask remains at $A_t = P^{\\ast} + \\Delta p$, yielding a current spread of $\\Delta p$. If the HFT has an active sell at price $P^{\\ast}$, then the current best ask becomes $P^{\\ast}$ while the best bid remains at $B_t = P^{\\ast} - \\Delta p$, yielding a current spread of $\\Delta p$. If the HFT has no active order, the spread equals $2\\Delta p$.\n- Execution against market orders: A market buy (respectively market sell) first executes against any active HFT sell (respectively HFT buy) because of the improved price. If the HFT order is present on that side with strictly positive remaining quantity, one unit fills, reducing the HFT’s remaining quantity by $1$, and the HFT immediately neutralizes inventory by submitting an offsetting market order of unit size against the opposite baseline best, which reduces that opposite baseline queue by $1$ if available. If no HFT order is present on the relevant side, the market order consumes the corresponding baseline best queue by $1$ if available.\n- HFT order lifetime: At the end of every time step, if the HFT has an active order, its remaining time-to-live decreases by $1$. If the remaining time-to-live reaches $0$ or the remaining quantity reaches $0$, the HFT cancels its order (no longer active).\n- HFT profit accounting: Each filled HFT unit immediately generates realized profit equal to the contemporaneous spread between the opposite side execution and the HFT’s improved price, which in this model equals $\\Delta p$ per HFT unit filled. The HFT’s profit at time step $t$ is $0$ if no HFT fill occurs at $t$.\n\nLet the following performance statistics be computed over the horizon $\\{1,\\ldots,T\\}$:\n- Average spread: $\\frac{1}{T}\\sum_{t=1}^{T} \\left(A^{\\text{best}}_t - B^{\\text{best}}_t\\right)$, where $A^{\\text{best}}_t$ and $B^{\\text{best}}_t$ are the best ask and best bid at time $t$ implied by the HFT activation rules above.\n- HFT fill rate per step: total number of HFT unit fills divided by $T$.\n- HFT average profit per step: total HFT profit divided by $T$.\n- Average baseline best-queue size: $\\frac{1}{T}\\sum_{t=1}^{T} \\left(Q_{B,t} + Q_{A,t}\\right)$, where $Q_{B,t}$ and $Q_{A,t}$ are the baseline best bid and best ask queue sizes at the end of step $t$.\n\nAll quantities are unitless except prices which are in arbitrary currency units. No angles or physical units are involved. All answers must be expressed as floats.\n\nYour program must run the simulation for the following test suite. Each tuple lists $(\\Delta p, T, q_{\\text{HFT}}, \\tau, \\text{seed}, (p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}}))$. Use $P^{\\ast} = 100$, $Q^0_B = 10$, $Q^0_A = 10$, and unit sizes $1$ for all market and baseline limit orders and cancellations in all test cases.\n- Case $1$: $(0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $2$: $(0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $3$: $(0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $4$: $(0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- Case $5$: $(0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4))$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is itself a list $[\\text{avg\\_spread}, \\text{hft\\_fill\\_rate}, \\text{hft\\_profit\\_per\\_step}, \\text{avg\\_baseline\\_queue}]$ with floats. For example, the output format must be of the form\n$[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],[x_{3,1},x_{3,2},x_{3,3},x_{3,4}],[x_{4,1},x_{4,2},x_{4,3},x_{4,4}],[x_{5,1},x_{5,2},x_{5,3},x_{5,4}]]$\nwith no spaces anywhere in the line.",
            "solution": "The problem requires the construction of a discrete-time simulation model of a limit order book (LOB) to analyze the effects of a high-frequency trading (HFT) strategy. The problem is well-posed, scientifically grounded in the domain of computational finance, and its parameters and rules are specified with sufficient detail to permit a unique, reproducible solution.\n\nThe solution is a direct implementation of the specified stochastic process. The core of the solution is a function that simulates the LOB's evolution over a time horizon of $T$ steps.\n\n**1. State Representation**\nThe state of the system at any discrete time step $t$ is fully described by a set of variables:\n- $Q_{B,t}$: The number of resting units in the baseline best bid queue at price $P^{\\ast} - \\Delta p$.\n- $Q_{A,t}$: The number of resting units in the baseline best ask queue at price $P^{\\ast} + \\Delta p$.\n- HFT Order State: A structure representing the HFT's single active order, defined by its side (buy or sell), remaining quantity $q_{\\text{rem}}$, and remaining time-to-live (TTL) $\\tau_{\\text{rem}}$. If no order is active, its state is marked as 'none'.\n\nThe simulation begins at $t=0$ with initial queue sizes $Q^0_B$ and $Q^0_A$, and with no active HFT order.\n\n**2. Simulation Dynamics**\nThe simulation proceeds from $t=1$ to $T$. Within each time step, a strict sequence of operations is followed to update the state of the LOB.\n\n**Step 2.1: Event Generation**\nAt the beginning of each step $t$, a single event is drawn from a categorical distribution defined by the probabilities $(p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}})$. The five possible events are: Market Buy (MB), Market Sell (MS), Baseline Limit Buy (LB), Baseline Limit Sell (LS), and Baseline Cancellation (C).\n\n**Step 2.2: State Transition Logic**\nThe system state is updated based on the drawn event and the HFT agent's rules.\n\n- **Market Orders (MB, MS):** If an HFT order exists at a better price (price $P^{\\ast}$), the market order first consumes liquidity from the HFT. A market buy (MB) consumes the HFT's sell order, and a market sell (MS) consumes the HFT's buy order.\n    - Upon a fill of one unit, the HFT's order quantity $q_{\\text{rem}}$ is decremented.\n    - The HFT's total fills are incremented by $1$, and its total profit is incremented by the defined profit-per-fill, $\\Delta p$.\n    - The HFT immediately neutralizes its acquired position by sending an offsetting market order of size $1$ to the opposite baseline queue. For example, after an HFT buy order is filled, the HFT submits a market buy, which consumes one unit from the baseline ask queue $Q_{A,t}$.\n    - If no HFT order is available on the corresponding side, the market order consumes one unit from the respective baseline queue ($Q_{A,t}$ for an MB, $Q_{B,t}$ for an MS), if the queue is not empty.\n\n- **Baseline Limit Orders (LB, LS):** A baseline limit buy (LB) increments $Q_{B,t}$ by $1$, and a baseline limit sell (LS) increments $Q_{A,t}$ by $1$.\n    - Immediately following an LB or LS event, the HFT agent (if $q_{\\text{HFT}} \\ge 1$) places a new limit order of size $q_{\\text{HFT}}$ and TTL $\\tau$ at the improved price $P^{\\ast}$. An LB triggers an HFT buy order, and an LS triggers an HFT sell order.\n    - Posting a new HFT order cancels any pre-existing HFT order, ensuring the HFT is active on at most one side of the book. Activating an order resets its quantity to $q_{\\text{HFT}}$ and its TTL to $\\tau$.\n\n- **Baseline Cancellation (C):** A single unit is removed from one of the non-empty baseline queues ($Q_{B,t}$ or $Q_{A,t}$). If both are non-empty, one is chosen uniformly at random. If only one is non-empty, it is chosen. If both are empty, there is no effect.\n\n**Step 2.3: End-of-Step Updates**\nAfter the event logic is fully resolved, end-of-step updates are performed.\n- **HFT Order Lifecycle:** If an HFT order is active, its TTL, $\\tau_{\\text{rem}}$, is decremented by $1$. The order is then checked for cancellation. If its TTL has reached $0$ or its remaining quantity $q_{\\text{rem}}$ has reached $0$, the order is removed from the book (its state is set to 'none').\n\n**3. Metrics Calculation**\nPerformance statistics are aggregated over the $T$ time steps. At the end of each step $t$, after all state transitions and cancellations have been processed, the following metrics are recorded:\n\n- **Spread:** The best bid-ask spread, $A^{\\text{best}}_t - B^{\\text{best}}_t$, is calculated. If the HFT has an active order (post-cancellation check), the spread is $\\Delta p$. Otherwise, the spread is determined by the baseline queues, which is $2\\Delta p$.\n- **Baseline Queue Size:** The total size of the baseline queues, $Q_{B,t} + Q_{A,t}$, is recorded.\n\nAfter the simulation completes, the final average metrics are computed by dividing the accumulated totals by $T$:\n- Average Spread: $\\frac{1}{T}\\sum_{t=1}^{T} (A^{\\text{best}}_t - B^{\\text{best}}_t)$\n- HFT Fill Rate: $\\frac{1}{T} \\times (\\text{Total HFT Fills})$\n- HFT Average Profit: $\\frac{1}{T} \\times (\\text{Total HFT Profit})$\n- Average Baseline Queue Size: $\\frac{1}{T}\\sum_{t=1}^{T} (Q_{B,t} + Q_{A,t})$\n\n**4. Implementation**\nThe simulation is implemented in Python, using the `numpy` library for reproducible random number generation, which is controlled by a specified seed for each test case. The logic described above is encapsulated in a function that takes the model parameters as input. A main function iterates through the provided test cases, calls the simulation, and formats the results into the precise string format required.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(delta_p, T, q_hft, tau, seed, probs):\n    \"\"\"\n    Runs a single simulation of the limit order book model.\n    \"\"\"\n    # Fixed parameters\n    P_star = 100.0\n    Q0_B = 10\n    Q0_A = 10\n    \n    # State variables\n    q_b = Q0_B\n    q_a = Q0_A\n    hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n    # Statistics accumulators\n    total_spread = 0.0\n    total_hft_fills = 0\n    total_hft_profit = 0.0\n    total_baseline_queue_size = 0.0\n\n    # Setup random number generator\n    rng = np.random.default_rng(seed)\n    events = ['MB', 'MS', 'LB', 'LS', 'C']\n\n    for _ in range(T):\n        # Step 1: Draw event\n        event = rng.choice(events, p=probs)\n        \n        # Step 2: State Transition Logic\n        if event == 'MB':  # Market Buy\n            if hft_order['side'] == 'sell' and hft_order['qty']  0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market sell against baseline bid)\n                if q_b  0:\n                    q_b -= 1\n            else:\n                if q_a  0:\n                    q_a -= 1\n        \n        elif event == 'MS':  # Market Sell\n            if hft_order['side'] == 'buy' and hft_order['qty']  0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market buy against baseline ask)\n                if q_a  0:\n                    q_a -= 1\n            else:\n                if q_b  0:\n                    q_b -= 1\n        \n        elif event == 'LB':  # Baseline Limit Buy\n            q_b += 1\n            if q_hft = 1:\n                hft_order = {'side': 'buy', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'LS':  # Baseline Limit Sell\n            q_a += 1\n            if q_hft = 1:\n                hft_order = {'side': 'sell', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'C':  # Baseline Cancellation\n            can_cancel_b = q_b  0\n            can_cancel_a = q_a  0\n            if can_cancel_b and can_cancel_a:\n                if rng.random()  0.5:\n                    q_b -= 1\n                else:\n                    q_a -= 1\n            elif can_cancel_b:\n                q_b -= 1\n            elif can_cancel_a:\n                q_a -= 1\n\n        # Step 3: End-of-step HFT order lifecycle update\n        if hft_order['side'] != 'none':\n            hft_order['ttl'] -= 1\n            if hft_order['ttl'] = 0 or hft_order['qty'] = 0:\n                hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n        # Step 4: Calculate and accumulate metrics for the current step t\n        current_spread = 2.0 * delta_p\n        if hft_order['side'] != 'none':\n            current_spread = delta_p\n        \n        total_spread += current_spread\n        total_baseline_queue_size += (q_b + q_a)\n\n    # Final calculation of average metrics\n    avg_spread = total_spread / T\n    hft_fill_rate = total_hft_fills / T\n    hft_avg_profit = total_hft_profit / T\n    avg_baseline_queue = total_baseline_queue_size / T\n\n    return [avg_spread, hft_fill_rate, hft_avg_profit, avg_baseline_queue]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        delta_p, T, q_hft, tau, seed, probs = case\n        result = run_simulation(delta_p, T, q_hft, tau, seed, probs)\n        all_results.append(result)\n\n    # Format the output string exactly as specified\n    result_strings = []\n    for res_list in all_results:\n        # Format each float to a reasonable precision to avoid excessive length\n        inner_str = f\"[{','.join(f'{x:.8f}' for x in res_list)}]\"\n        result_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "A powerful application of order book analysis is the detection of sophisticated trading strategies that are not immediately visible. This exercise guides you in developing a statistical model to detect hidden \"iceberg\" orders by analyzing patterns in trade and replenishment data . You will use hypothesis testing to distinguish between random market noise and the signature of a hidden large order, a crucial skill in algorithmic trading and market surveillance.",
            "id": "2406526",
            "problem": "You are given a stylized, one-sided limit order book at a single price level. The event stream consists of two types of time-stamped events measured in seconds: marketable trades that consume displayed liquidity at the level and replenishments that add displayed liquidity at the same level. For each test case, you must decide whether the observed trade flow and replenishment timing are more consistent with the presence of a hidden \"iceberg\" order at that price level during a specified detection interval. A hidden iceberg order is defined here as latent liquidity that tends to restore displayed quantity shortly after it is consumed by trades.\n\nFormulation. Let the calibration interval be the half-open interval $\\left[0,T_{\\mathrm{cal}}\\right)$ with duration $T_{\\mathrm{cal}}$ in seconds. Let replenishment (add-liquidity) event times inside the calibration interval be $\\{r_i^{(\\mathrm{cal})}\\}_{i=1}^{N_{\\mathrm{cal}}}$, where $N_{\\mathrm{cal}}$ is the count of replenishments observed during calibration. In the subsequent detection interval $\\left[T_{\\mathrm{cal}}, T_{\\mathrm{end}}\\right]$, let the marketable trade times be $\\{t_j\\}_{j=1}^{m}$ and the replenishment times be $\\{s_\\ell\\}_{\\ell=1}^{L}$. Fix a window length $\\tau0$ seconds and a significance level $\\alpha\\in(0,1)$ expressed as a decimal. For each trade time $t_j$, define the indicator\n$$\nY_j \\equiv \\mathbf{1}\\left\\{\\exists\\, s_\\ell \\text{ such that } t_j  s_\\ell \\le t_j + \\tau\\right\\},\n$$\nwhich records whether a replenishment occurs within $\\tau$ seconds after the trade.\n\nModeling assumptions. During calibration, replenishments follow a homogeneous Poisson process with constant rate $\\lambda$ (per second). During detection under the null hypothesis of no iceberg, replenishments continue to follow a homogeneous Poisson process with the same rate $\\lambda$, independent of the trade times $\\{t_j\\}_{j=1}^m$. Under this null, for any fixed $\\tau$, the probability that $Y_j=1$ equals $p_0 = 1 - e^{-\\lambda \\tau}$. Under the alternative of an iceberg, replenishments are more likely to occur promptly after trades; specifically, conditional on a trade, a replenishment occurs within $\\tau$ seconds with probability $p_1=0.9$, independently across trades.\n\nLearning and decision rule. Estimate $\\lambda$ from first principles using the calibration data as the maximum likelihood estimator for a homogeneous Poisson process,\n$$\n\\widehat{\\lambda} \\equiv \\frac{N_{\\mathrm{cal}}}{T_{\\mathrm{cal}}}.\n$$\nSet $\\widehat{p}_0 \\equiv 1 - e^{-\\widehat{\\lambda} \\tau}$. In the detection interval, compute $K \\equiv \\sum_{j=1}^{m} Y_j$, the number of trades that are followed by at least one replenishment within $\\tau$ seconds. Decide \"iceberg present\" if and only if $K \\ge k^\\star$, where $k^\\star$ is the smallest integer in $\\{0,1,\\dots,m\\}$ such that the upper tail of the Binomial distribution with parameters $m$ and $\\widehat{p}_0$ is no larger than $\\alpha$:\n$$\n\\sum_{k=k^\\star}^{m} \\binom{m}{k} \\widehat{p}_0^{\\,k} \\left(1-\\widehat{p}_0\\right)^{m-k} \\le \\alpha.\n$$\nIf $m=0$ (no trades in the detection interval), return the decision \"iceberg present\" as $\\mathrm{False}$.\n\nUnits and angle conventions. All times must be treated in seconds. There are no angular quantities.\n\nYour program must implement the above estimator and decision rule exactly and apply them to the test suite below. For each test case, you are given $T_{\\mathrm{cal}}$, the lists $\\{r_i^{(\\mathrm{cal})}\\}$, $\\{t_j\\}$, $\\{s_\\ell\\}$, and the parameters $\\tau$ and $\\alpha$. Compute the boolean decision for each test case in order.\n\nTest suite. Each list below contains strictly increasing real numbers in seconds. All replenishment events listed for calibration occur in $\\left[0,T_{\\mathrm{cal}}\\right)$; all detection events occur in $\\left[T_{\\mathrm{cal}}, T_{\\mathrm{end}}\\right]$ with unspecified $T_{\\mathrm{end}}$ (only relative timing within the detection interval matters for the decision rule).\n\n- Test case $1$ (highly suggestive replenishment after every trade):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [1.0,\\, 2.7,\\, 4.0,\\, 5.5,\\, 7.2,\\, 9.8]$.\n  - Detection trades $\\{t_j\\} = [10.0,\\, 11.0,\\, 12.0,\\, 13.0,\\, 14.0,\\, 15.0]$.\n  - Detection replenishments $\\{s_\\ell\\} = [10.05,\\, 11.05,\\, 12.05,\\, 13.05,\\, 14.05,\\, 15.05,\\, 19.0]$.\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\n- Test case $2$ (rare replenishments; mostly absent after trades):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [2.0,\\, 7.0]$.\n  - Detection trades $\\{t_j\\} = [10.0,\\, 10.5,\\, 11.0,\\, 12.0,\\, 13.0,\\, 14.0,\\, 15.0]$.\n  - Detection replenishments $\\{s_\\ell\\} = [12.05,\\, 16.0]$.\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\n- Test case $3$ (borderline frequency of post-trade replenishments):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [0.5,\\, 1.7,\\, 3.0,\\, 6.3,\\, 8.9]$.\n  - Detection trades $\\{t_j\\} = [10.0,\\, 10.3,\\, 11.0,\\, 12.0,\\, 13.0,\\, 14.0,\\, 15.0,\\, 16.0,\\, 17.0,\\, 18.0]$.\n  - Detection replenishments $\\{s_\\ell\\} = [10.05,\\, 12.30,\\, 14.10,\\, 17.30]$.\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\n- Test case $4$ (no trades in detection interval):\n  - $T_{\\mathrm{cal}}=10.0$.\n  - Calibration replenishments $\\{r_i^{(\\mathrm{cal})}\\} = [1.0,\\, 2.0,\\, 3.0]$.\n  - Detection trades $\\{t_j\\} = [\\,]$ (empty list).\n  - Detection replenishments $\\{s_\\ell\\} = [\\,]$ (empty list).\n  - $\\tau = 0.15$, $\\alpha=0.05$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets and ordered as the test cases above, for example: \"[True,False,True,False]\".",
            "solution": "The problem presents a well-defined task in statistical hypothesis testing, applied to the analysis of limit order book data. The formulation is scientifically grounded, internally consistent, and complete. There are no logical contradictions, ambiguities, or factual errors. Therefore, the problem is deemed valid and a formal solution can be constructed.\n\nThe core of the problem is to decide between two hypotheses concerning the behavior of liquidity replenishments following trades.\n- The null hypothesis, $H_0$, posits that replenishments are random events governed by a homogeneous Poisson process, independent of trade occurrences.\n- The alternative hypothesis, $H_1$, posits that a hidden \"iceberg\" order exists, which causes a high probability of rapid replenishment after a trade.\n\nThe solution proceeds systematically through the steps outlined in the problem statement.\n\n**Step 1: Estimation of the Baseline Replenishment Rate**\n\nUnder the null hypothesis $H_0$, replenishments in the calibration interval $\\left[0, T_{\\mathrm{cal}}\\right)$ follow a homogeneous Poisson process with an unknown constant rate $\\lambda$. The problem provides the maximum likelihood estimator (MLE) for this rate, which is derived from first principles of statistical inference for point processes. Given $N_{\\mathrm{cal}}$ events observed over a duration of $T_{\\mathrm{cal}}$, the MLE for $\\lambda$ is:\n$$\n\\widehat{\\lambda} = \\frac{N_{\\mathrm{cal}}}{T_{\\mathrm{cal}}}\n$$\nThis estimator represents the empirical frequency of replenishment events and serves as our baseline expectation for replenishment activity in the absence of any special mechanism like an iceberg order.\n\n**Step 2: Derivation of the Null Probability of Post-Trade Replenishment**\n\nUnder $H_0$, the number of replenishments in any time interval of length $\\tau$ is a random variable following a Poisson distribution with mean $\\lambda \\tau$. The probability of observing zero replenishments in such an interval is $e^{-\\lambda \\tau}$. Consequently, the probability of observing at least one replenishment within $\\tau$ seconds is:\n$$\np_0 = 1 - e^{-\\lambda \\tau}\n$$\nSince $\\lambda$ is unknown, we substitute its estimate $\\widehat{\\lambda}$ to obtain an estimated probability under the null hypothesis:\n$$\n\\widehat{p}_0 = 1 - e^{-\\widehat{\\lambda}\\tau}\n$$\nThis value, $\\widehat{p}_0$, is the probability that a single, arbitrary trade is followed by a replenishment within the time window $\\tau$, assuming no iceberg order is present.\n\n**Step 3: Construction of the Test Statistic**\n\nIn the detection interval $\\left[T_{\\mathrm{cal}}, T_{\\mathrm{end}}\\right]$, we observe $m$ trades at times $\\{t_j\\}_{j=1}^m$. For each trade $t_j$, we define a Bernoulli random variable $Y_j$:\n$$\nY_j = \\mathbf{1}\\left\\{\\exists\\, s_\\ell \\text{ such that } t_j  s_\\ell \\le t_j + \\tau\\right\\}\n$$\nUnder $H_0$, the $Y_j$ are assumed to be independent and identically distributed, with $P(Y_j=1) = \\widehat{p}_0$. The test statistic, $K$, is the sum of these indicators:\n$$\nK = \\sum_{j=1}^{m} Y_j\n$$\nThis statistic $K$ counts the number of trades that are \"quickly\" followed by a replenishment. Under $H_0$, $K$ follows a Binomial distribution with parameters $m$ and $\\widehat{p}_0$, denoted $K \\sim \\text{Binomial}(m, \\widehat{p}_0)$. An unusually high value of $K$ would cast doubt on the null hypothesis.\n\n**Step 4: The Decision Rule**\n\nWe perform a one-sided hypothesis test at a significance level $\\alpha$. We reject $H_0$ in favor of $H_1$ if the observed value of $K$ is sufficiently large. To formalize \"sufficiently large,\" we find a critical value $k^\\star$, which is the smallest integer in $\\{0, 1, \\dots, m\\}$ defining the rejection region $[k^\\star, m]$. This $k^\\star$ is chosen such that the probability of a Type I error (falsely rejecting a true $H_0$) is controlled at or below $\\alpha$. Mathematically, $k^\\star$ is the minimum integer satisfying:\n$$\nP(X \\ge k^\\star) = \\sum_{k=k^\\star}^{m} \\binom{m}{k} \\widehat{p}_0^{\\,k} \\left(1-\\widehat{p}_0\\right)^{m-k} \\le \\alpha,\n$$\nwhere $X \\sim \\text{Binomial}(m, \\widehat{p}_0)$. This sum is the survival function (SF) of the binomial distribution.\n\nThe final decision is made by comparing the observed statistic $K$ to this critical value:\n- If $K \\ge k^\\star$, we reject $H_0$ and conclude that an iceberg order is present (return True).\n- If $K  k^\\star$, we fail to reject $H_0$ and conclude there is not enough evidence for an iceberg order (return False).\nA special case is stipulated: if $m=0$, no trades occur, and the decision is automatically False.\n\n**Application to Test Cases**\n\n**Test Case 1:**\n- Given: $T_{\\mathrm{cal}}=10.0$, $N_{\\mathrm{cal}}=6$, $m=6$, $\\tau=0.15$, $\\alpha=0.05$.\n- $\\widehat{\\lambda} = 6 / 10.0 = 0.6$.\n- $\\widehat{p}_0 = 1 - e^{-0.6 \\times 0.15} = 1 - e^{-0.09} \\approx 0.08607$.\n- For each of the $m=6$ trades, there is a replenishment within the $(t_j, t_j+0.15]$ window. Thus, $K=6$.\n- We seek the smallest integer $k^\\star \\in \\{0, \\dots, 6\\}$ such that $P(X \\ge k^\\star) \\le 0.05$ for $X \\sim \\text{Binomial}(6, 0.08607)$.\n  - $P(X \\ge 2) \\approx 0.0835  0.05$.\n  - $P(X \\ge 3) \\approx 0.0031 \\le 0.05$.\n- The critical value is $k^\\star=3$.\n- Decision: Since $K=6 \\ge k^\\star=3$, we reject $H_0$. The result is True.\n\n**Test Case 2:**\n- Given: $T_{\\mathrm{cal}}=10.0$, $N_{\\mathrm{cal}}=2$, $m=7$, $\\tau=0.15$, $\\alpha=0.05$.\n- $\\widehat{\\lambda} = 2 / 10.0 = 0.2$.\n- $\\widehat{p}_0 = 1 - e^{-0.2 \\times 0.15} = 1 - e^{-0.03} \\approx 0.02956$.\n- The trade at $t_4=12.0$ is followed by a replenishment at $s_1=12.05$, which is within the window $(12.0, 12.15]$. No other trades are followed by a replenishment. Thus, $K=1$.\n- We seek $k^\\star$ for $X \\sim \\text{Binomial}(7, 0.02956)$.\n  - $P(X \\ge 1) \\approx 0.1885  0.05$.\n  - $P(X \\ge 2) \\approx 0.0153 \\le 0.05$.\n- The critical value is $k^\\star=2$.\n- Decision: Since $K=1  k^\\star=2$, we fail to reject $H_0$. The result is False.\n\n**Test Case 3:**\n- Given: $T_{\\mathrm{cal}}=10.0$, $N_{\\mathrm{cal}}=5$, $m=10$, $\\tau=0.15$, $\\alpha=0.05$.\n- $\\widehat{\\lambda} = 5 / 10.0 = 0.5$.\n- $\\widehat{p}_0 = 1 - e^{-0.5 \\times 0.15} = 1 - e^{-0.075} \\approx 0.07226$.\n- The trade at $t_1=10.0$ has a replenishment at $10.05$. The trade at $t_6=14.0$ has a replenishment at $14.10$. No other trades have a valid subsequent replenishment. Thus, $K=2$.\n- We seek $k^\\star$ for $X \\sim \\text{Binomial}(10, 0.07226)$.\n  - $P(X \\ge 2) \\approx 0.1565  0.05$.\n  - $P(X \\ge 3) \\approx 0.0271 \\le 0.05$.\n- The critical value is $k^\\star=3$.\n- Decision: Since $K=2  k^\\star=3$, we fail to reject $H_0$. The result is False.\n\n**Test Case 4:**\n- Given: $m=0$.\n- According to the problem's explicit rule for no trades in the detection interval, the decision must be False. We do not need to perform any calculations.\n- Decision: The result is False.\n\nThe final sequence of boolean decisions is [True, False, False, False].",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\n\ndef solve():\n    \"\"\"\n    Implements the iceberg order detection algorithm based on hypothesis testing.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [1.0, 2.7, 4.0, 5.5, 7.2, 9.8],\n            \"t_det\": [10.0, 11.0, 12.0, 13.0, 14.0, 15.0],\n            \"s_det\": [10.05, 11.05, 12.05, 13.05, 14.05, 15.05, 19.0],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        },\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [2.0, 7.0],\n            \"t_det\": [10.0, 10.5, 11.0, 12.0, 13.0, 14.0, 15.0],\n            \"s_det\": [12.05, 16.0],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        },\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [0.5, 1.7, 3.0, 6.3, 8.9],\n            \"t_det\": [10.0, 10.3, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0],\n            \"s_det\": [10.05, 12.30, 14.10, 17.30],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        },\n        {\n            \"T_cal\": 10.0,\n            \"r_cal\": [1.0, 2.0, 3.0],\n            \"t_det\": [],\n            \"s_det\": [],\n            \"tau\": 0.15,\n            \"alpha\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        T_cal = case[\"T_cal\"]\n        r_cal = case[\"r_cal\"]\n        t_det = case[\"t_det\"]\n        s_det = case[\"s_det\"]\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n\n        m = len(t_det)\n        \n        # Per problem specification, if m=0, return False.\n        if m == 0:\n            results.append(False)\n            continue\n            \n        N_cal = len(r_cal)\n        \n        # Step 1: Estimate lambda\n        if T_cal  0:\n            lambda_hat = N_cal / T_cal\n        else: # Handle division by zero, although not in test cases\n            lambda_hat = 0.0\n\n        # Step 2: Estimate p0 under the null hypothesis\n        p0_hat = 1 - np.exp(-lambda_hat * tau)\n\n        # Step 3: Compute the test statistic K\n        K = 0\n        trades_np = np.array(t_det)\n        replenishments_np = np.array(s_det)\n        \n        if len(replenishments_np)  0:\n            # For each trade, find the index of the first replenishment that occurs *after* it.\n            # searchsorted with side='right' finds insertion points for trades\n            # which is the index of the first element in replenishments  trade_time.\n            indices = np.searchsorted(replenishments_np, trades_np, side='right')\n            \n            for i in range(m):\n                trade_time = trades_np[i]\n                repl_index = indices[i]\n                \n                # Check if there is a replenishment after the trade\n                if repl_index  len(replenishments_np):\n                    # Check if this replenishment is within the tau window\n                    if replenishments_np[repl_index] = trade_time + tau:\n                        K += 1\n        \n        # Step 4: Find the critical value k_star\n        # k_star is the smallest integer such that P(X = k_star) = alpha\n        # P(X = k) is the survival function, binom.sf(k-1, n, p)\n        k_star = m + 1 # Initialize to a value that guarantees K  k_star\n        for k_test in range(m + 1): # Iterate up to m\n            # binom.sf(k-1) computes P(X = k)\n            p_value = binom.sf(k_test - 1, m, p0_hat)\n            if p_value = alpha:\n                k_star = k_test\n                break\n        \n        # Step 5: Make the decision\n        decision = K = k_star\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}