{
    "hands_on_practices": [
        {
            "introduction": "在投入编写代码实现任何算法之前，深刻理解其计算效率是至关重要的一步。本练习旨在引导您分析朗斯塔夫-施瓦茨算法的计算复杂度（大O表示法）。通过将其与传统金融工程中的另一种常用方法——有限差分法——进行对比，您将能从理论层面体会到为何蒙特卡洛方法，特别是朗斯塔夫-施瓦茨算法，在高维定价问题中展现出独特的优势。",
            "id": "2442266",
            "problem": "考虑使用两种不同的数值方法为具有二维状态变量的美式或有债权定价：Longstaff–Schwartz 蒙特卡罗方法 (LSMC) 和有限差分法。假定以下设置和约定。\n\n- 状态是二维的，并且有 $T$ 个离散的行权日期。对于 Longstaff–Schwartz 蒙特卡罗方法 (LSMC)，模拟了 $M$ 条具有 $T$ 个行权日期的独立样本路径。在到期前的每个行权日期，执行一次最小二乘回归，使用两个状态变量中总次数至多为 $p$ 的多项式基来估计持续价值。回归通过正规方程组实现，该方程组通过计算 $X^{\\top} X$ 和 $X^{\\top} y$ 形成，然后在每个行权日期通过高斯消元法求解。假设在最坏情况下，所有 $M$ 条路径在所有行权日期都处于价内状态，并且对实数的每次算术运算都计为单位成本。\n- 对于有限差分法，时间域被离散化为 $N_{t}$ 个步长，空间网格为 $G \\times G$。在每个时间步，通过投影逐次超松弛法 (PSOR) 求解投影线性互补条件来强制执行美式提前行权约束，每个时间步进行 $I$ 次迭代，其中 $I$ 不依赖于 $G$。每次 PSOR 迭代访问每个网格点一次，每个点的算术工作量为 $\\mathcal{O}(1)$。\n\n假设 $N_{t} = T$，以便两种方法使用相同数量的时间层级。忽略常数因子和低阶项。在随机存取机器模型中工作，其中对于一个 $M \\times K$ 的设计矩阵，形成 $X^{\\top} X$ 的复杂度为 $\\mathcal{O}(M K^{2})$，形成 $X^{\\top} y$ 的复杂度为 $\\mathcal{O}(M K)$，通过高斯消元法求解一个稠密的 $K \\times K$ 线性系统的复杂度为 $\\mathcal{O}(K^{3})$。设 $K$ 表示由组合计数得到的两个变量中总次数至多为 $p$ 的多项式基函数的数量，包括常数项。\n\n将 $C_{\\mathrm{LSMC}}$ 和 $C_{\\mathrm{FD}}$ 分别定义为 LSMC 和有限差分法的主阶算术运算计数（忽略常数因子）。在 $C_{\\mathrm{LSMC}}$ 中 $M K^{2}$ 支配 $K^{3}$ 和 $M$，且在 $C_{\\mathrm{FD}}$ 中 $I$ 被视为常数的渐进情况下，推导渐进比率\n$$\nR \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}\n$$\n并仅用 $M$、$p$ 和 $G$ 来完全简化它。\n\n将你的最终答案以 $R$ 的单一闭式解析表达式形式给出。无需四舍五入。",
            "solution": "该问题要求推导用于为美式或有债权定价的两种数值方法——Longstaff-Schwartz 蒙特卡罗 (LSMC) 方法和有限差分 (FD) 方法——的计算成本之比 $R \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}$。\n\n首先，我们确定 LSMC 方法的主阶算术运算计数 $C_{\\mathrm{LSMC}}$。\nLSMC 算法从行权日期 $T-1$ 向后推至 $1$。执行回归的时间步数为 $T-1$。\n在这些时间步的每一步，都使用最小二乘回归来估计持续价值。回归的基由两个状态变量中总次数至多为 $p$ 的多项式构成。此类基函数的数量，记为 $K$，可以通过组合论证确定。不等式 $i_1 + i_2 \\le p$ 的非负整数解的数量等价于 $i_1 + i_2 + s = p$ 的非负整数解的数量，其中 $s$ 是一个松弛变量。这是一个经典的隔板法问题，解的数量由 $\\binom{p+d}{d}$ 给出，其中变量数量是 $d=2$。\n因此，基函数的数量为：\n$$\nK = \\binom{p+2}{2} = \\frac{(p+2)!}{2!p!} = \\frac{(p+2)(p+1)}{2}\n$$\n回归在 $M$ 条路径上执行，因此设计矩阵 $X$ 的维度为 $M \\times K$。回归过程的成本被指定为形成 $X^{\\top}X$、形成 $X^{\\top}y$ 和求解所得线性系统的成本之和。这些成本分别由 $\\mathcal{O}(M K^2)$、$\\mathcal{O}(M K)$ 和 $\\mathcal{O}(K^3)$ 给出。问题指出，我们处于 $M K^2$ 项占主导地位的渐进区域。因此，单个时间步的回归成本被视为与 $M K^2$ 成正比。\nLSMC 方法的总成本 $C_{\\mathrm{LSMC}}$ 是每个时间步的成本乘以时间步数 $T-1$。忽略常数因子和低阶项，主阶复杂度为：\n$$\nC_{\\mathrm{LSMC}} \\propto (T-1) M K^2 \\sim T M K^2\n$$\n代入 $K$ 的表达式：\n$$\nC_{\\mathrm{LSMC}} = T M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2\n$$\n在这里，我们将 $C_{\\mathrm{LSMC}}$ 定义为运算计数中的主导项，根据问题“忽略常数因子”的指示，将比例常数设为 $1$。\n\n接下来，我们确定有限差分 (FD) 方法的主阶算术运算计数 $C_{\\mathrm{FD}}$。\nFD 方案也是时间上向后进行的。时间步数指定为 $N_t$，我们被要求设置 $N_t = T$。因此有 $T-1$ 个回溯步骤。\n空间域是一个大小为 $G \\times G$ 的网格，包含 $G^2$ 个点。\n在每个时间步，通过投影逐次超松弛法 (PSOR) 求解投影线性互补问题来处理提前行权约束。此过程需要 $I$ 次迭代。每次迭代访问 $G^2$ 个网格点中的每一个，并为每个点执行 $\\mathcal{O}(1)$ 的工作量。因此，一次 PSOR 迭代的成本为 $\\mathcal{O}(G^2)$。每个时间步的总成本是每次迭代的成本乘以迭代次数 $I$，即 $\\mathcal{O}(I G^2)$。\n问题指出 $I$ 是一个常数。因此，每个时间步的主阶成本与 $G^2$ 成正比。\nFD 方法的总成本 $C_{\\mathrm{FD}}$ 是每个时间步的成本乘以时间步数 $T-1$。\n$$\nC_{\\mathrm{FD}} \\propto (T-1) G^2 \\sim T G^2\n$$\n同样，忽略常数因子（其中包括 $I$），我们将主阶计数定义为：\n$$\nC_{\\mathrm{FD}} = T G^2\n$$\n\n最后，我们计算比率 $R \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}$。\n$$\nR = \\frac{T M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2}{T G^2}\n$$\n分子和分母中的因子 $T$ 被约去：\n$$\nR = \\frac{M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2}{G^2}\n$$\n简化此表达式得出最终结果：\n$$\nR = \\frac{M (p+1)^2 (p+2)^2}{4 G^2}\n$$\n此表达式按要求给出了计算成本关于 $M$、$p$ 和 $G$ 的渐进比率。",
            "answer": "$$\n\\boxed{\\frac{M(p+1)^{2}(p+2)^{2}}{4G^{2}}}\n$$"
        },
        {
            "introduction": "理解了算法的理论效率后，我们接下来将亲手实现它，并探索其一个核心的统计特性。这个实践任务将指导您揭示朗斯塔夫-施瓦茨算法中一个潜在的陷阱：当模拟路径数量相对于基函数数量不足时，由于回归模型的过拟合，会导致期权价格估算中出现正向偏差。通过分别执行样本内（in-sample）和样本外（out-of-sample）评估，您将掌握识别和量化这种偏差的关键技术，这是计算金融领域一项至关重要的实践技能。",
            "id": "2442310",
            "problem": "实现一个完整的程序，以量化并说明在使用Longstaff–Schwartz蒙特卡洛（LSMC）方法估算美式看跌期权价格时，当模拟路径数量相对于回归中使用的基函数数量较少时，产生的正向偏差。您的实现必须基于以下基本原理：在无套利和风险中性定价的假设下，美式期权的价值等于所有停止时间下贴现期望收益的上确界，而最优停止规则由动态规划和条件期望来刻画。在LSMC中，条件期望通过投影到状态函数的有限维基上进行近似，并使用模拟路径通过最小二乘法进行估计。\n\n您必须纯粹按照数学和算法的术语进行如下操作：\n\n- 在风险中性概率测度下，通过几何布朗运动对动态进行建模：对于股价过程$\\{S_t\\}_{t \\in [0,T]}$，在一个包含$M$个时间步长的等距网格上，使用随机微分方程$\\mathrm{d}S_t = r S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t$的精确离散化来模拟路径。其中，$r$是连续复利无风险利率，$\\sigma$是波动率，$\\{W_t\\}$是标准维纳过程。使用精确的转移方程$S_{t+\\Delta t} = S_t \\exp\\!\\left((r - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z\\right)$，其中$Z \\sim \\mathcal{N}(0,1)$在时间和路径上是独立的。\n\n- 考虑一个美式看跌期权，其执行价格为$K$，在任何行权时间$t \\in [0,T]$的收益为$\\max(K - S_t, 0)$。设时间网格为$t_m = m \\Delta t$，其中$\\Delta t = T/M$，且$m \\in \\{0,1,\\dots,M\\}$。\n\n- 实现Longstaff–Schwartz算法，通过最小二乘投影到形式为$\\{\\phi_j(x)\\}_{j=0}^{d}$（其中$\\phi_j(x) = x^j$）的多项式基上来估计持续价值。该基函数应用于缩放后的状态$x = S_t / K$，其中$d$是多项式阶数。在每个行权时间$t_m$（不包括$t_0$），将下一步的贴现已实现现金流对在当前价内状态下评估的基函数进行回归。使用无正则化的普通最小二乘法。使用相同的模拟路径来估计回归系数，并计算由此产生的行权策略和现金流，从而获得样本内（in-sample）LSMC价格估计。\n\n- 为消除样本内（前视）偏差，执行一次样本外（out-of-sample）评估。将在每个时间步从训练样本中拟合得到的回归系数应用于一个独立的模拟路径集（具有相同的模型参数和时间网格），以确定行权决策和已实现的贴现现金流。这些贴现现金流的均值给出了期权价格的一个样本外下界估计。\n\n- 将给定配置的度量偏差定义为样本内估计与样本外下界估计之差。\n\n需使用的参数值（所有数值必须与$S_0$和$K$使用相同的货币单位进行解释；不涉及物理单位）：\n- 初始股价 $S_0 = 100$。\n- 执行价格 $K = 100$。\n- 无风险利率 $r = 0.06$。\n- 波动率 $\\sigma = 0.2$。\n- 到期日 $T = 1$。\n- 时间步数 $M = 50$（因此 $\\Delta t = T/M$）。\n- 为保证数值稳定性，如上所述，使用$S_t/K$对基函数进行缩放。\n\n随机性与可复现性：\n- 对样本外（评估）模拟使用一个固定的伪随机种子，其值为$4444$。\n- 对于训练模拟，使用下面测试套件中为每个测试用例提供的种子。\n- 训练和样本外评估使用独立的随机数。\n\n行权时间约定：\n- 允许在时间点$t_m$（其中$m \\in \\{1,2,\\dots,M-1\\}$）做出行权决策，并为在时间$0$进行估值而再次贴现至$t_0$。最后，在$t_0$，取贴现后的持续价值与即时行权价值$\\max(K - S_0, 0)$的最大值，以确保样本内和样本外估计在$t_0$的美式行权权利上的一致性。\n\n基函数规格：\n- 对于多项式阶数$d$，使用大小为$d+1$的基，其单项式为$\\{1, x, x^2, \\dots, x^d\\}$，其中$x = S_t/K$。\n\n测试套件：\n针对以下三种配置，计算度量偏差（定义为样本内估计减去样本外估计），并使用指定的种子。在每种情况下，使用一个包含$N_{\\text{eval}} = 8000$条独立路径的样本外评估集。\n1. 情况A（小样本，高复杂度）：训练路径数$N_{\\text{train}} = 120$，多项式阶数$d = 6$，训练种子$111$。\n2. 情况B（大样本，同等复杂度）：训练路径数$N_{\\text{train}} = 1000$，多项式阶数$d = 6$，训练种子$222$。\n3. 情况C（小样本，低复杂度）：训练路径数$N_{\\text{train}} = 120$，多项式阶数$d = 2$，训练种子$333$。\n\n数值输出：\n- 对每种情况，计算标量偏差并四舍五入到$4$位小数。\n- 您的程序应生成单行输出，其中包含三个四舍五入后的偏差，形式为逗号分隔的列表并用方括号括起（例如，\"[0.1234,0.5678,0.9012]\"）。\n\n覆盖性设计：\n- 情况A探讨了由于$N_{\\text{train}}$较小和基函数维度相对较大而可能出现的强正向偏差。\n- 情况B作为一个“典型情况”，其中随着$N_{\\text{train}}$增加，偏差应该会减小。\n- 情况C作为一个对比，使用相同的小$N_{\\text{train}}$但更少的基函数，以说明过拟合的减少。\n\n您的实现必须是完全自包含的，不需要用户输入，并且严格遵守指定的输出格式。",
            "solution": "我们从风险中性概率测度下的基本无套利原理出发。令$\\{S_t\\}_{t \\in [0,T]}$在风险中性测度下遵循几何布朗运动：\n$$\n\\mathrm{d}S_t = r S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t,\n$$\n其中$r$为连续复利无风险利率，$\\sigma$为波动率，$\\{W_t\\}$为标准维纳过程。在离散化步长$\\Delta t$上的精确转移方程为\n$$\nS_{t+\\Delta t} = S_t \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z\\right),\n$$\n其中$Z \\sim \\mathcal{N}(0,1)$在时间和路径上是独立的。对于一个收益过程为$\\{g(S_t)\\}$的美式期权（此处对于看跌期权，$g(s) = \\max(K - s, 0)$），其在时间$0$的无套利价格等于\n$$\nV_0 = \\sup_{\\tau \\in \\mathcal{T}} \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\tau} g(S_{\\tau}) \\right],\n$$\n其中$\\mathcal{T}$是取值在$[0,T]$区间且关于$\\{S_t\\}$生成的σ-代数流的停止时间集合，$\\mathbb{Q}$是风险中性测度。在一个离散时间网格$t_m = m \\Delta t$（$m \\in \\{0,1,\\dots,M\\}$）上，该最优停止问题的动态规划递推关系为\n$$\nV_m(S_{t_m}) = \\max\\left( g(S_{t_m}), \\, \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\Delta t} V_{m+1}(S_{t_{m+1}}) \\mid S_{t_m} \\right] \\right),\n$$\n其终端条件为$V_M(S_{t_M}) = g(S_{t_M})$。\n\nLongstaff–Schwartz蒙特卡洛（LSMC）方法通过一个到状态（此处为$S_{t_m}$）的基函数有限维线性张成的$L^2$投影来近似条件期望$\\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\Delta t} V_{m+1}(S_{t_{m+1}}) \\mid S_{t_m} \\right]$。具体来说，在每个时间步$t_m$（不包括初始时间$t_0$），估计回归方程\n$$\nY = \\beta_0 \\phi_0(X) + \\beta_1 \\phi_1(X) + \\cdots + \\beta_d \\phi_d(X) + \\varepsilon,\n$$\n其中$X := S_{t_m}/K$是缩放后的状态，$Y := e^{-r \\Delta t} \\hat{V}_{m+1}$是在当前策略下，从下一个时间步开始的贴现已实现现金流，该回归仅使用处于价内（即$g(S_{t_m}) > 0$）的模拟路径。基函数是单项式$\\phi_j(x) = x^j$，其中$j = 0,1,\\dots,d$。系数$\\{\\beta_j\\}$通过对模拟的训练样本进行普通最小二乘法得到。在时间$t_m$的估计持续价值则为\n$$\n\\widehat{C}_m(S_{t_m}) = \\sum_{j=0}^d \\widehat{\\beta}_j \\phi_j(S_{t_m}/K).\n$$\n对于价内状态，如果$g(S_{t_m}) > \\widehat{C}_m(S_{t_m})$，估计的策略就在$t_m$行权；否则，就继续持有。这个反向归纳过程从$t_{M-1}$一直进行到$t_1$，每一步都将已实现的现金流贴现$e^{-r \\Delta t}$。最后，在$t_0$的估值需要再进行一次$e^{-r \\Delta t}$贴现，并与$g(S_0)$取最大值，以尊重在$t_0$的提前行权权利：\n$$\n\\widehat{V}_0 = \\max\\left(g(S_0), \\, e^{-r \\Delta t} \\cdot \\frac{1}{N} \\sum_{n=1}^N \\widehat{C}_0^{(n)} \\right),\n$$\n其中$\\widehat{C}_0^{(n)}$表示在估计策略下，路径$n$的贴现持续现金流。\n\n当路径数量相对于基函数数量较少时产生偏差的机制：\n- 回归步骤使用来自同一样本的含噪声目标$Y$来估计系数$\\{\\widehat{\\beta}_j\\}$。当样本量$N$相对于基维度$d+1$较小时，回归倾向于在训练集上过拟合$Y$中的噪声，特别是因为回归是在价内子集上进行的，而这个子集在很多时间步可能非常小。这在样本内降低了训练残差，人为地在对样本内估值有利的地方提高了估计的持续价值，并且关键地，影响了行权决策，以选择在样本内看起来更有利的路径结果。\n- 由于行权决策基于将$g(S_{t_m})$与一个过拟合的$\\widehat{C}_m(S_{t_m})$进行比较，决策边界可能被扭曲，以在样本内减少提前行权，从而增加在同一样本上度量的贴现现金流。这在LSMC价格估计中引入了一个正向的前视（或样本内）偏差。\n- 样本外评估将相同的回归系数应用于一个独立的路径集。过拟合不会转移到新数据上；因此，该策略通常不会表现出同样被人为抬高的持续价值。样本外估计是真实价格的一个有效下界，并消除了样本内的乐观性，因此样本内和样本外估计之间的差异提供了一个对正向偏差的经验度量。\n\n程序的算法设计：\n1.  使用给定的$S_0$, $r$, $\\sigma$, $T$, 和 $M$，通过精确离散化模拟训练路径$\\{S^{\\text{train}}_{t_m}\\}$，并使用固定的训练种子以保证可复现性。\n2.  用于训练的反向归纳：\n    -   在到期日$t_M$将路径的现金流初始化为$g(S^{\\text{train}}_{t_M})$。\n    -   对于$m = M-1, M-2, \\dots, 1$：\n        -   将下一步的现金流贴现$e^{-r \\Delta t}$。\n        -   识别出$g(S^{\\text{train}}_{t_m}) > 0$的价内路径。\n        -   仅使用价内路径，将贴现现金流对$\\{\\phi_j(S^{\\text{train}}_{t_m}/K)\\}_{j=0}^d$进行回归，得到$\\{\\widehat{\\beta}_{m,j}\\}_{j=0}^d$。\n        -   使用这些系数计算所有训练路径的$\\widehat{C}_m$，并在价内路径上当$g(S^{\\text{train}}_{t_m}) > \\widehat{C}_m$时行权来更新现金流；否则，保留贴现后的持续现金流。\n    -   在$m=1$处完成后，再贴现一次到$t_0$，并取$\\widehat{V}^{\\text{in}}_0 = \\max\\big(g(S_0), \\text{在} t_0 \\text{的贴现现金流均值}\\big)$。\n    -   存储所有$m \\in \\{1,\\dots,M-1\\}$的回归系数$\\{\\widehat{\\beta}_{m,j}\\}$。\n3.  样本外评估：\n    -   使用固定的评估种子，模拟一个包含$N_{\\text{eval}}$条路径的独立评估集$\\{S^{\\text{eval}}_{t_m}\\}$。\n    -   在$t_M$将评估现金流初始化为$g(S^{\\text{eval}}_{t_M})$。\n    -   对于$m = M-1, M-2, \\dots, 1$：\n        -   贴现$e^{-r \\Delta t}$。\n        -   使用存储的$\\{\\widehat{\\beta}_{m,j}\\}$在$S^{\\text{eval}}_{t_m}$处计算$\\widehat{C}_m$。\n        -   在价内路径上当$g(S^{\\text{eval}}_{t_m}) > \\widehat{C}_m$时行权，更新现金流；否则继续持有。\n    -   在$m=1$处完成后，再贴现一次到$t_0$，并取$\\widehat{V}^{\\text{out}}_0 = \\max\\big(g(S_0), \\text{在} t_0 \\text{的贴现现金流均值}\\big)$。\n4.  度量的偏差为$B = \\widehat{V}^{\\text{in}}_0 - \\widehat{V}^{\\text{out}}_0$，四舍五入到4位小数。\n\n测试套件的基本原理：\n- 情况A：$N_{\\text{train}} = 120$且阶数$d = 6$，意味着有$d+1 = 7$个基函数，这相对于许多时间步的价内样本量而言是相当大的。我们预计会有一个显著的正向偏差。\n- 情况B：$N_{\\text{train}} = 1000$且阶数相同$d = 6$，增加了样本量，应会减少过拟合；因此，度量的偏差应小于情况A。\n- 情况C：$N_{\\text{train}} = 120$且阶数$d = 2$，相对于情况A降低了模型复杂度，从而减轻了过拟合，尽管$N_{\\text{train}}$同样很小，但其偏差会小于情况A。\n\n程序必须生成单行输出，其中包含一个按情况A、B、C顺序排列的三个偏差的列表，每个偏差都四舍五入到4位小数并用逗号分隔。这个输出简洁地量化了$N_{\\text{train}}$与基维度之比对LSMC中样本内乐观性的影响。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_gbm_paths(S0, r, sigma, T, M, N, rng):\n    dt = T / M\n    # Generate standard normal increments\n    Z = rng.standard_normal(size=(N, M))\n    drift = (r - 0.5 * sigma * sigma) * dt\n    vol = sigma * np.sqrt(dt)\n    # Log increments\n    log_increments = drift + vol * Z\n    # Cumulative sum along time, prepend zeros for t0\n    log_paths = np.concatenate(\n        [np.zeros((N, 1)), np.cumsum(log_increments, axis=1)], axis=1\n    )\n    S_paths = S0 * np.exp(log_paths)\n    return S_paths  # shape (N, M+1)\n\ndef payoff_put(S, K):\n    return np.maximum(K - S, 0.0)\n\ndef basis_matrix(S_scaled, degree):\n    # S_scaled: shape (n,) or (n,1), build [1, x, x^2, ..., x^degree]\n    x = S_scaled.reshape(-1)\n    # Use Vandermonde with increasing powers\n    return np.vander(x, N=degree+1, increasing=True)\n\ndef lsmc_train_and_coeffs(S_paths, K, r, T, M, degree):\n    \"\"\"\n    Train LSMC on given paths:\n    - Returns in-sample price and list of regression coefficients per time step m=1..M-1.\n    \"\"\"\n    N = S_paths.shape[0]\n    dt = T / M\n    disc = np.exp(-r * dt)\n\n    # Initialize cashflows at maturity\n    cf = payoff_put(S_paths[:, M], K).copy()\n\n    # Store coefficients for each time step m (1..M-1). We'll use None if regression is skipped.\n    coeffs = [None] * (M + 1)\n\n    # Backward induction from m = M-1 down to 1\n    for m in range(M-1, 0, -1):\n        # Discount cashflows to time m\n        cf *= disc\n\n        S_m = S_paths[:, m]\n        immediate = payoff_put(S_m, K)\n        itm_mask = immediate > 0.0\n        idx = np.where(itm_mask)[0]\n\n        if idx.size > 0:\n            # Regression on in-the-money paths only\n            X = basis_matrix(S_m[idx] / K, degree)\n            Y = cf[idx]\n            # Ordinary least squares (minimum-norm solution if underdetermined)\n            beta, *_ = np.linalg.lstsq(X, Y, rcond=None)\n            coeffs[m] = beta\n            # Continuation estimates for all paths at time m\n            X_all = basis_matrix(S_m / K, degree)\n            cont = X_all.dot(beta)\n            # Exercise decision for in-the-money paths\n            exercise = itm_mask  (immediate > cont)\n            # Update cashflows: for exercised paths, set to immediate payoff; others keep continuation cf\n            cf[exercise] = immediate[exercise]\n        else:\n            # No in-the-money paths; keep coeffs[m] as None and no exercise updates\n            coeffs[m] = np.zeros(degree+1, dtype=float)  # zero continuation\n\n    # Discount once more to time 0\n    cf0 = cf * disc\n    # Enforce American right at t=0\n    price_in_sample = max(payoff_put(np.array([S_paths[0, 0]]), K)[0], float(np.mean(cf0)))\n    return price_in_sample, coeffs\n\ndef lsmc_evaluate_oos(S_paths_eval, K, r, T, M, degree, coeffs):\n    \"\"\"\n    Apply stored regression coefficients to an independent evaluation set to compute out-of-sample price.\n    \"\"\"\n    N = S_paths_eval.shape[0]\n    dt = T / M\n    disc = np.exp(-r * dt)\n\n    cf = payoff_put(S_paths_eval[:, M], K).copy()\n\n    for m in range(M-1, 0, -1):\n        cf *= disc\n        S_m = S_paths_eval[:, m]\n        immediate = payoff_put(S_m, K)\n        itm_mask = immediate > 0.0\n\n        beta = coeffs[m]\n        if beta is None:\n            # No regression info; continuation is zero -> immediate exercise if in-the-money\n            exercise = itm_mask  # since cont = 0\n            cf[exercise] = immediate[exercise]\n        else:\n            X_all = basis_matrix(S_m / K, degree)\n            cont = X_all.dot(beta)\n            # Exercise decision for in-the-money paths\n            exercise = itm_mask  (immediate > cont)\n            cf[exercise] = immediate[exercise]\n\n    cf0 = cf * disc\n    price_oos = max(payoff_put(np.array([S_paths_eval[0, 0]]), K)[0], float(np.mean(cf0)))\n    return price_oos\n\ndef run_case(S0, K, r, sigma, T, M, degree, N_train, N_eval, seed_train, seed_eval):\n    rng_train = np.random.default_rng(seed_train)\n    rng_eval = np.random.default_rng(seed_eval)\n\n    # Simulate training and evaluation paths\n    S_train = simulate_gbm_paths(S0, r, sigma, T, M, N_train, rng_train)\n    S_eval = simulate_gbm_paths(S0, r, sigma, T, M, N_eval, rng_eval)\n\n    # Train LSMC and get in-sample price and coefficients\n    price_in, coeffs = lsmc_train_and_coeffs(S_train, K, r, T, M, degree)\n    # Evaluate out-of-sample lower bound\n    price_oos = lsmc_evaluate_oos(S_eval, K, r, T, M, degree, coeffs)\n\n    bias = price_in - price_oos\n    return bias\n\ndef solve():\n    # Model and grid parameters\n    S0 = 100.0\n    K = 100.0\n    r = 0.06\n    sigma = 0.2\n    T = 1.0\n    M = 50\n\n    # Evaluation (out-of-sample) set size and seed\n    N_eval = 8000\n    seed_eval = 4444\n\n    # Test cases: (N_train, degree, seed_train)\n    test_cases = [\n        (120, 6, 111),   # Case A: small N_train, high degree\n        (1000, 6, 222),  # Case B: larger N_train, same degree\n        (120, 2, 333),   # Case C: small N_train, low degree\n    ]\n\n    results = []\n    for N_train, degree, seed_train in test_cases:\n        bias = run_case(S0, K, r, sigma, T, M, degree, N_train, N_eval, seed_train, seed_eval)\n        results.append(bias)\n\n    # Round to 4 decimals and print in required format\n    formatted = \"[\" + \",\".join(f\"{x:.4f}\" for x in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "朗斯塔夫-施瓦茨算法的精确度在很大程度上取决于我们选择用来近似未来期望收益（即继续持有价值）的基函数。这个动手练习将引导您深入探究模型对基函数选择的敏感性。您将在相同的模拟路径上，分别使用简单的幂函数和物理学中常用的拉盖尔（Laguerre）多项式作为基函数，来比较两者对美式期权最优执行边界估计的影响。",
            "id": "2442309",
            "problem": "考虑使用 Langstaff-Schwartz 算法（最小二乘蒙特卡洛，Langstaff-Schwartz 算法）在风险中性测度下为美式看跌期权定价。标的资产价格过程被建模为几何布朗运动，其在风险中性概率测度下的风险中性动态由以下随机微分方程给出：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t,$$ 其中 $S_t$ 是资产价格，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。该美式看跌期权的执行价格为 $K$，到期日为 $T$，在时间 $t$ 的支付由下式给出：$$\\max\\{K - S_t, 0\\}.$$ Langstaff-Schwartz 算法通过将折现后的已实现现金流投影到一组选定的关于当前状态的基函数族上，来近似每个行权时间的条件继续价值。基函数族的选择会产生近似误差，这会影响估计的最优停止策略，特别是估计的行权边界。您的任务是通过在相同的模拟路径上运行该算法两次来量化估计的行权边界对基函数族的敏感性，一次使用简单单项式，一次使用 Laguerre 多项式，然后比较在选定时间点得到的估计边界。\n\n您必须从风险中性定价和最优停止的基本原理出发，实现以下内容：\n\n1) 使用几何布朗运动的精确解，在均匀时间网格上模拟 $S_t$。对于大小为 $\\Delta t = T/N$ 的 $N$ 个时间步，每条路径的递推公式为 $$S_{t+\\Delta t} = S_t \\exp\\left(\\left(r - q - \\tfrac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\right),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$ 是独立的标准正态分布随机抽取值。\n\n2) 为美式看跌期权实现 Langstaff-Schwartz 算法：\n   a) 在到期日 $t_N = T$，将每条路径的现金流设置为其支付 $C_N = \\max\\{K - S_{t_N}, 0\\}$。\n   b) 从 $i = N-1, N-2, \\dots, 1$ 开始向后递推。首先，用单步折现因子 $\\exp(-r \\Delta t)$ 折现已有的现金流，以获得其在 $t_i$ 时刻的价值。在 $t_i$ 时刻处于价内（即 $\\max\\{K - S_{t_i}, 0\\}  0$）的路径中，对折现后的现金流与选定的关于缩放后状态 $x = S_{t_i}/K$ 的基函数族进行最小二乘回归拟合。使用该回归为价内路径估计继续价值 $\\widehat{C}_{\\text{cont}}(S_{t_i})$。对于那些立即行权价值 $\\max\\{K - S_{t_i}, 0\\}$ 大于或等于估计继续价值的价内路径，执行行权；否则，继续持有，并保持折现后的现金流不变。\n   c) 在向后归纳法于 $t_1$ 结束之后，将剩余的现金流再折现一步到时间 $t_0$，以获得时间为 $0$ 的现值，并计算所有路径的平均值作为期权价格的估计值。此价格不是此处的最终目标输出，但它是算法内部一致性所必需的。\n\n3) 对于步骤 2b 中的回归，在相同的模拟路径上使用两种不同的基函数族：\n   a) 单项式：使用基向量 $$[1, x, x^2, x^3]$$ 其中 $x = S_{t_i}/K$。\n   b) Laguerre 多项式：使用前四个（物理学家版本）Laguerre 多项式在 $x = S_{t_i}/K$ 处的值，即 $$L_0(x) = 1, \\; L_1(x) = 1 - x, \\; L_2(x) = 1 - 2x + \\tfrac{x^2}{2}, \\; L_3(x) = 1 - 3x + \\tfrac{3}{2}x^2 - \\tfrac{1}{6}x^3.$$ 用这些列构建回归的设计矩阵。\n\n4) 在由到期时间的分数 $\\{1/4, 1/2, 3/4\\}$ 指定的三个内部行权时间点，为每个基函数族按如下方式估计行权边界。设 $t_i$ 是最接近 $T$ 的每个分数的（四舍五入到 $\\{1, \\dots, N-1\\}$ 中最近的整数）时间索引。在时间 $t_i$，给定拟合的回归函数 $\\widehat{C}_{\\text{cont}}(S)$，定义函数 $$f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S).$$ 在区间 $[0, K]$ 上用 $M$ 个点均匀离散化的网格上，找到满足 $f(S) \\ge 0$ 的 $S$ 的上确界。如果存在索引 $j$ 使得 $f(S_j) \\ge 0$ 且 $f(S_{j+1})  0$，则在 $S_j$ 和 $S_{j+1}$ 之间进行线性插值以精化根的估计值；否则，如果对于所有网格点都有 $f(S) \\ge 0$，则将边界设置为 $K$，如果对于所有网格点都有 $f(S)  0$，则将边界设置为 $0$。这为每个基函数族在每个选定时间点定义了一个估计的行权边界 $\\widehat{S}^*_{\\text{family}}(t_i)$。\n\n5) 敏感性度量：对于每个测试用例，计算在三个选定时间点上，使用 Laguerre 多项式基和单项式基得到的边界之间的最大绝对差：$$D = \\max_{t \\in \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t) - \\widehat{S}^*_{\\text{Monomials}}(t) \\right|.$$\n\n实现细节和约束：\n- 每个测试用例使用指定数量的 $N$ 个时间步和 $P$ 条独立路径（见下文）。在每个测试用例中，对两种基函数族使用相同的随机数种子和相同的模拟路径，以隔离基函数选择所产生的影响。\n- 使用第 1 项中概述的几何布朗运动的精确离散化方法。\n- 通过数值稳定的方法使用最小二乘法。如果在某回归步骤中没有价内路径，则按惯例将该时间的边界估计值（如果需要）定义为 $0$。如果至少有一条价内路径，则继续进行回归；如果矩阵是病态的，则使用最小化残差平方和的最小二乘解。\n- 对于边界网格，在 $[0, K]$ 上使用 $M = 400$ 个均匀间隔的点。\n- 所有的利率和波动率都以小数表示（例如，$5$ 个百分点表示为 $0.05$），并且不涉及物理单位。\n\n测试套件：\n为以下三个测试用例提供结果。在所有情况中，使用 $P = 8{,}192$ 条路径，边界网格大小 $M = 400$，以及指定的时间步数 $N$。\n\n1) 用例 A（平衡，中等波动率）：$S_0 = 100$，$K = 100$，$r = 0.05$，$q = 0$，$\\sigma = 0.2$，$T = 1$，$N = 50$，随机数种子 $= 12345$。\n2) 用例 B（初始价外，高波动率）：$S_0 = 90$，$K = 100$，$r = 0.03$，$q = 0$，$\\sigma = 0.5$，$T = 1$，$N = 50$，随机数种子 $= 2023$。\n3) 用例 C（初始价内，低波动率，较短到期时间）：$S_0 = 110$，$K = 100$，$r = 0.01$，$q = 0$，$\\sigma = 0.1$，$T = 0.5$，$N = 40$，随机数种子 $= 42$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试用例 A、B 和 C 的三个敏感性值 $D$，分别四舍五入到 $6$ 位小数，并以逗号分隔的列表形式用方括号括起来，例如，$$[0.123456,0.234567,0.345678].$$",
            "solution": "对所述问题进行验证。\n\n**第 1 步：提取的已知条件**\n-   **资产动态**：在风险中性测度下，资产价格 $S_t$ 服从几何布朗运动：$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t$。其离散化形式由 $S_{t+\\Delta t} = S_t \\exp\\left(\\left(r - q - \\tfrac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\right)$ 给出，其中 $Z \\sim \\mathcal{N}(0,1)$。\n-   **期权细节**：一个美式看跌期权，执行价格为 $K$，到期日为 $T$，支付为 $\\max\\{K - S_t, 0\\}$。\n-   **算法**：将使用向后归纳法在大小为 $\\Delta t = T/N$ 的 $N$ 个时间步上实现 Longstaff-Schwartz 算法。\n-   **回归步骤**：通过对期权处于“价内”($S_{t_i}  K$)的路径进行最小二乘回归来估计条件继续价值。回归的自变量是关于缩放后状态 $x = S_{t_i}/K$ 的基函数。\n-   **基函数族**：\n    1.  单项式：$[1, x, x^2, x^3]$。\n    2.  Laguerre 多项式：$[L_0(x), L_1(x), L_2(x), L_3(x)]$，其中 $L_0(x) = 1$，$L_1(x) = 1 - x$，$L_2(x) = 1 - 2x + \\tfrac{x^2}{2}$，$L_3(x) = 1 - 3x + \\tfrac{3}{2}x^2 - \\tfrac{1}{6}x^3$。\n-   **边界估计**：行权边界 $\\widehat{S}^*_{\\text{family}}(t_i)$ 将在最接近 $\\{T/4, T/2, 3T/4\\}$ 的时间索引 $t_i$ 处进行估计。这是通过在 $[0, K]$ 区间上一个包含 $M=400$ 个点的网格上找到函数 $f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S)$ 的根来完成的，并使用线性插值进行精化。\n-   **敏感性度量**：$D = \\max_{t \\in \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t) - \\widehat{S}^*_{\\text{Monomials}}(t) \\right|$。\n-   **数值参数**：$P = 8192$ 条路径，边界网格大小 $M = 400$。\n-   **测试用例**：\n    -   用例 A：$S_0 = 100$，$K = 100$，$r = 0.05$，$q = 0$，$\\sigma = 0.2$，$T = 1$，$N = 50$，种子 $= 12345$。\n    -   用例 B：$S_0 = 90$，$K = 100$，$r = 0.03$，$q = 0$，$\\sigma = 0.5$，$T = 1$，$N = 50$，种子 $= 2023$。\n    -   用例 C：$S_0 = 110$，$K = 100$，$r = 0.01$，$q = 0$，$\\sigma = 0.1$，$T = 0.5$，$N = 40$，种子 $= 42$。\n-   **输出格式**：一个包含三个测试用例的 $D$ 值的列表，每个值都四舍五入到 $6$ 位小数。\n\n**第 2 步：验证**\n评估问题的有效性。\n-   **科学依据**：该问题植根于金融工程的既定理论，采用了 Black-Scholes-Merton 框架和用于美式期权定价的标准 Longstaff-Schwartz 算法。所有模型、方程和方法都是标准的、事实可靠的。\n-   **适定性**：问题规定明确，没有歧义。所有必要的参数、边界条件和程序步骤都明确提供，确保在给定随机数种子的情况下，有一条唯一的路径通向确定性解。\n-   **客观性**：问题要求进行定量计算和比较，不含主观因素。\n\n**第 3 步：结论**\n问题是有效的。这是量化金融中一个定义明确的计算任务。现在提供解决方案。\n\n该问题要求实现 Longstaff-Schwartz 算法，以分析美式看跌期权行权边界对基函数选择的敏感性。解决方案从基本原理出发，逻辑地展开。\n\n**1. 资产路径的风险中性模拟**\n衍生品定价的基础是风险中性定价原理。我们在风险中性测度 $\\mathbb{Q}$ 下模拟标的资产价格 $S_t$ 的演变。其动态由随机微分方程描述：\n$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t^{\\mathbb{Q}}$$\n其中 $r$ 是无风险利率，$q$ 是股息率，$\\sigma$ 是波动率，$W_t^{\\mathbb{Q}}$ 是在 $\\mathbb{Q}$ 下的标准布朗运动。该方程有精确解，这使得可以在离散时间网格 $t_0, t_1, \\dots, t_N$（其中 $t_i = i \\Delta t$ 且 $\\Delta t = T/N$）上进行精确模拟。对于 $P$ 条路径中的每一条，我们生成价格序列如下：\n$$S_{t_{i+1}} = S_{t_i} \\exp\\left(\\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_{i+1}\\right)$$\n在这里，$\\{Z_i\\}_{i=1}^N$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。为确保受控对比，两种基函数分析使用同一组 $P$ 条模拟路径。\n\n**2. Longstaff-Schwartz 算法：向后归纳与回归**\n在任何时间 $t$，美式期权的价值是其立即行权价值和其继续价值（持有期权的期望价值）中的较大者。这个最优停止问题通过使用动态规划中的向后归纳法来解决。\n\n设 $C_i(S_{t_i})$ 为在给定状态 $S_{t_i}$ 下，期权在时间 $t_i$ 的价值。\n在到期日 $t_N = T$，期权价值就是其内在价值：\n$$C_N(S_{t_N}) = \\max(K - S_{t_N}, 0)$$\n然后我们从时间 $i = N-1$ 向后推至 $1$。在每个时间 $t_i$，继续价值 $C_{\\text{cont}}(S_{t_i})$ 是在给定 $t_i$ 时刻信息下，下一步期权价值的折现期望值：\n$$C_{\\text{cont}}(S_{t_i}) = \\mathbb{E}^{\\mathbb{Q}}\\left[e^{-r\\Delta t} C_{i+1}(S_{t_{i+1}}) \\mid S_{t_i}\\right]$$\nLongstaff-Schwartz 算法的核心创新是使用线性回归来近似这个条件期望。回归仅对“价内”($S_{t_i}  K$)路径执行，因为对于价外路径，决策总是继续持有。对于这些价内路径，我们将折现后的未来现金流 $\\{e^{-r\\Delta t} C_{i+1}^{(j)}\\}$（其中 $j$ 是路径索引）对一组关于缩放后状态变量 $x = S_{t_i}/K$ 的基函数 $\\{f_k(S_{t_i}^{(j)}/K)\\}_{k=0}^d$ 进行回归。这产生了一个估计的继续价值函数：\n$$\\widehat{C}_{\\text{cont}}(S_{t_i}) = \\sum_{k=0}^{d} \\beta_{i,k} f_k(S_{t_i}/K)$$\n系数 $\\boldsymbol{\\beta}_i = \\{\\beta_{i,k}\\}$ 通过最小化误差平方和来找到。我们按规定使用两种不同的基函数族：\n-   **单项式**：基为 $[1, x, x^2, x^3]$。\n-   **Laguerre 多项式**：基为 $[L_0(x), L_1(x), L_2(x), L_3(x)]$。\n一旦估计出 $\\widehat{C}_{\\text{cont}}(S_{t_i})$，就对每条价内路径应用最优停止规则：\n$$\n\\text{如果 } \\max(K - S_{t_i}, 0) \\geq \\widehat{C}_{\\text{cont}}(S_{t_i}), \\text{ 则行权；否则，继续持有。}\n$$\n如果行权是最优选择，则该路径在时间 $t_i$ 的现金流设为 $K - S_{t_i}$，并且该值（折现后）在后续步骤中向后传递。如果继续持有是最优选择，则 $t_i$ 处的现金流是来自 $t_{i+1}$ 的折现现金流。此过程定义了所有路径的现金流向量 $\\{C_i^{(j)}\\}$。\n\n**3. 行权边界的估计**\n行权边界 $S^*(t)$ 是指期权持有人在立即行权和继续持有之间无差异的临界股票价格。这个无差异点由行权价值和继续价值相等来定义：\n$$K - S^*(t) = C_{\\text{cont}}(S^*(t), t)$$\n我们通过找到函数 $f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S)$ 的根来估计指定时间 $t_i$ 的边界 $\\widehat{S}^*(t_i)$，其中 $\\widehat{C}_{\\text{cont}}(S)$ 是使用在 $t_i$ 步骤计算出的回归系数 $\\boldsymbol{\\beta}_i$ 构建的。通过在区间 $[0, K]$ 上一个包含 $M=400$ 个点的精细网格上评估 $f(S)$ 来数值求解根。当在两个相邻网格点 $S_j$ 和 $S_{j+1}$ 之间检测到 $f(S)$ 的符号变化时，使用线性插值以高精度逼近根。如果 $f(S) \\geq 0$ 遍及整个网格，则边界设为 $K$。如果 $f(S)  0$ 在所有地方都成立，则设为 $0$。\n\n**4. 敏感性分析**\n每个测试用例的整个过程都执行两次——一次使用单项式基函数，一次使用 Laguerre 基函数，都在完全相同的模拟资产路径集上进行。这隔离了基函数选择对估计行权边界的影响。对于每个指定的时间点 $t_i \\in \\{T/4, T/2, 3T/4\\}$，我们计算两个边界估计值，$\\widehat{S}^*_{\\text{Monomials}}(t_i)$ 和 $\\widehat{S}^*_{\\text{Laguerre}}(t_i)$。最终的敏感性度量 $D$ 是这三个时间点上估计值之间最大绝对差：\n$$D = \\max_{i \\in \\text{indices for } \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t_i) - \\widehat{S}^*_{\\text{Monomials}}(t_i) \\right|$$\n该度量量化了 Longstaff-Schwartz 算法中与基函数选择相关的模型风险。以下代码实现了这一完整方法论。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_basis_functions(x, basis_type):\n    \"\"\"\n    Generates the design matrix for given states and basis type.\n\n    Args:\n        x (np.ndarray): Scaled asset prices (S/K).\n        basis_type (str): 'monomials' or 'laguerre'.\n\n    Returns:\n        np.ndarray: The design matrix (number of paths x number of basis functions).\n    \"\"\"\n    if basis_type == 'monomials':\n        return np.vstack([np.ones_like(x), x, x**2, x**3]).T\n    elif basis_type == 'laguerre':\n        L0 = np.ones_like(x)\n        L1 = 1.0 - x\n        L2 = 1.0 - 2.0 * x + 0.5 * x**2\n        L3 = 1.0 - 3.0 * x + 1.5 * x**2 - (1.0 / 6.0) * x**3\n        return np.vstack([L0, L1, L2, L3]).T\n    else:\n        raise ValueError(\"Unknown basis type specified.\")\n\ndef run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, basis_type, boundary_times_indices):\n    \"\"\"\n    Runs the Longstaff-Schwartz algorithm and computes exercise boundaries at specified times.\n\n    Args:\n        S_paths (np.ndarray): Simulated asset price paths.\n        K (float): Strike price.\n        r (float): Risk-free rate.\n        dt (float): Time step size.\n        N (int): Number of time steps.\n        M (int): Number of points in the boundary estimation grid.\n        basis_type (str): 'monomials' or 'laguerre'.\n        boundary_times_indices (set): Set of time indices to estimate the boundary.\n\n    Returns:\n        dict: A dictionary mapping time index to the estimated boundary value.\n    \"\"\"\n    P = S_paths.shape[0]\n    cash_flows = np.maximum(K - S_paths[:, -1], 0)\n    boundary_estimates = {}\n\n    for i in range(N - 1, 0, -1):\n        cash_flows *= np.exp(-r * dt)\n        S_t = S_paths[:, i]\n        itm_indices = np.where(S_t  K)[0]\n\n        if len(itm_indices) > 0:\n            X = get_basis_functions(S_t[itm_indices] / K, basis_type)\n            y = cash_flows[itm_indices]\n\n            try:\n                beta = np.linalg.lstsq(X, y, rcond=None)[0]\n            except np.linalg.LinAlgError:\n                # In case of a fatal error, which is unlikely with lstsq, \n                # we assume continuation value is 0 (or some other robust handling).\n                # This would mean exercising whenever in the money.\n                beta = np.zeros(X.shape[1])\n\n            if i in boundary_times_indices:\n                S_grid = np.linspace(1e-6, K, M)\n                x_grid = S_grid / K\n                basis_grid = get_basis_functions(x_grid, basis_type)\n                cont_val_grid = basis_grid @ beta\n                f_S = (K - S_grid) - cont_val_grid\n\n                positive_f = np.where(f_S >= 0)[0]\n                if len(positive_f) == 0:\n                    boundary = 0.0\n                elif len(positive_f) == M:\n                    boundary = K\n                else:\n                    root_idx = positive_f[-1]\n                    if root_idx + 1  M:\n                        f1, f2 = f_S[root_idx], f_S[root_idx + 1]\n                        s1, s2 = S_grid[root_idx], S_grid[root_idx + 1]\n                        boundary = s1 - f1 * (s2 - s1) / (f2 - f1)\n                    else:\n                        boundary = K\n                boundary_estimates[i] = boundary\n\n            continuation_value = get_basis_functions(S_t[itm_indices] / K, basis_type) @ beta\n            exercise_value = K - S_t[itm_indices]\n            exercise_indices = itm_indices[exercise_value >= continuation_value]\n            cash_flows[exercise_indices] = K - S_t[exercise_indices]\n        \n        else:\n            if i in boundary_times_indices:\n                boundary_estimates[i] = 0.0\n\n    return boundary_estimates\n\ndef calculate_sensitivity(S0, K, r, q, sigma, T, N, P, M, seed):\n    \"\"\"\n    Calculates the sensitivity metric D for a single test case.\n\n    Args:\n        S0, K, r, q, sigma, T, N, P, M, seed: All problem parameters.\n\n    Returns:\n        float: The sensitivity metric D.\n    \"\"\"\n    np.random.seed(seed)\n    dt = T / N\n    S_paths = np.zeros((P, N + 1))\n    S_paths[:, 0] = S0\n    drift = (r - q - 0.5 * sigma**2) * dt\n    diffusion = sigma * np.sqrt(dt)\n\n    for i in range(1, N + 1):\n        Z = np.random.standard_normal(P)\n        S_paths[:, i] = S_paths[:, i-1] * np.exp(drift + diffusion * Z)\n\n    time_fractions = [0.25, 0.5, 0.75]\n    boundary_times_indices = {int(round(f * N)) for f in time_fractions}\n    boundary_times_indices = {max(1, min(N-1, idx)) for idx in boundary_times_indices}\n\n    boundaries_mono = run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, 'monomials', boundary_times_indices)\n    boundaries_laguerre = run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, 'laguerre', boundary_times_indices)\n    \n    differences = []\n    for idx in sorted(list(boundary_times_indices)):\n        b_mono = boundaries_mono.get(idx, 0.0)\n        b_lag = boundaries_laguerre.get(idx, 0.0)\n        differences.append(np.abs(b_lag - b_mono))\n        \n    return np.max(differences) if differences else 0.0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'S0': 100., 'K': 100., 'r': 0.05, 'q': 0., 'sigma': 0.2, 'T': 1.0, 'N': 50, 'seed': 12345},\n        {'S0': 90., 'K': 100., 'r': 0.03, 'q': 0., 'sigma': 0.5, 'T': 1.0, 'N': 50, 'seed': 2023},\n        {'S0': 110., 'K': 100., 'r': 0.01, 'q': 0., 'sigma': 0.1, 'T': 0.5, 'N': 40, 'seed': 42}\n    ]\n    common_params = {'P': 8192, 'M': 400}\n    \n    results = []\n    for case_params in test_cases:\n        params = {**case_params, **common_params}\n        D = calculate_sensitivity(**params)\n        results.append(D)\n        \n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}