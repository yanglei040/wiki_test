{
    "hands_on_practices": [
        {
            "introduction": "在实现任何算法之前，理解其计算性能至关重要。本练习通过分析 Longstaff-Schwartz 蒙特卡罗 (LSMC) 方法的计算复杂性，并将其与传统的有限差分法进行比较，为您奠定理论基础。通过此练习，您将理解为何 LSMC 方法在处理高维问题时尤其强大。",
            "id": "2442266",
            "problem": "考虑使用两种不同的数值方法为具有二维状态变量的美式或有债权定价：Longstaff–Schwartz 蒙特卡洛方法 (LSMC) 和有限差分法。假设使用以下设置和约定。\n\n- 状态是二维的，并且有 $T$ 个离散的行权日。对于 Longstaff–Schwartz 蒙特卡洛方法 (LSMC)，模拟了 $M$ 条独立的样本路径，每条路径有 $T$ 个行权日。在到期前的每个行权日，执行一次最小二乘回归，使用总次数最多为 $p$ 的两个状态变量的多项式基来估计持续价值。该回归通过正规方程实现，即通过计算 $X^{\\top} X$ 和 $X^{\\top} y$ 形成方程组，然后在每个行权日通过高斯消元法求解。假设最坏情况，即所有 $M$ 条路径在所有行权日都处于价内状态，并且对实数的每次算术运算都计为单位成本。\n- 对于有限差分法，时间域被离散化为 $N_{t}$ 个时间步，空间网格为 $G \\times G$。在每个时间步，通过投影逐次超松弛法 (PSOR) 求解一个投影线性互补条件来强制执行美式提早行权约束，每个时间步进行 $I$ 次迭代，其中 $I$ 不依赖于 $G$。每次 PSOR 迭代访问每个网格点一次，每个点的算术工作量为 $\\mathcal{O}(1)$。\n\n假设 $N_{t} = T$，因此两种方法使用相同数量的时间层级。忽略常数因子和低阶项。在随机存取机器模型中，对于一个 $M \\times K$ 的设计矩阵，形成 $X^{\\top} X$ 的计算量为 $\\mathcal{O}(M K^{2})$，形成 $X^{\\top} y$ 的计算量为 $\\mathcal{O}(M K)$，通过高斯消元法求解一个稠密的 $K \\times K$ 线性系统的计算量为 $\\mathcal{O}(K^{3})$。设 $K$ 表示由组合计数得到的两个变量中总次数最多为 $p$ 的多项式基函数的数量，包括常数项。\n\n将 $C_{\\mathrm{LSMC}}$ 和 $C_{\\mathrm{FD}}$ 分别定义为 LSMC 和有限差分法的主阶算术运算次数（忽略常数因子）。在 $C_{\\mathrm{LSMC}}$ 中 $M K^{2}$ 支配 $K^{3}$ 和 $M$ 的渐近状态下，并且在 $C_{\\mathrm{FD}}$ 中将 $I$ 视为常数，推导渐近比率\n$$\nR \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}\n$$\n并仅用 $M$、$p$ 和 $G$ 完全简化它。\n\n以 $R$ 的单个闭式解析表达式的形式提供您的最终答案。无需四舍五入。",
            "solution": "本题要求推导两种用于美式或有债权定价的数值方法的计算成本之比 $R \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}$：Longstaff-Schwartz 蒙特卡洛 (LSMC) 方法和有限差分 (FD) 方法。\n\n首先，我们确定 LSMC 方法的主阶算术运算次数 $C_{\\mathrm{LSMC}}$。\nLSMC 算法从行权日 $T-1$ 向后推至 $1$。执行回归的时间步数为 $T-1$。\n在每个时间步，使用最小二乘回归来估计持续价值。回归的基由总次数最多为 $p$ 的两个状态变量的多项式组成。此类基函数的数量，记为 $K$，可以通过组合学论证来确定。不等式 $i_1 + i_2 \\le p$ 的非负整数解的数量等价于 $i_1 + i_2 + s = p$ 的非负整数解的数量，其中 $s$ 是一个松弛变量。这是一个经典的星号和隔板问题，解的数量由 $\\binom{p+d}{d}$ 给出，其中变量数量 $d=2$。\n因此，基函数的数量为：\n$$\nK = \\binom{p+2}{2} = \\frac{(p+2)!}{2!p!} = \\frac{(p+2)(p+1)}{2}\n$$\n回归是在 $M$ 条路径上执行的，因此设计矩阵 $X$ 的维度是 $M \\times K$。回归过程的成本被指定为形成 $X^{\\top}X$、形成 $X^{\\top}y$ 和求解所得线性系统的成本之和。这些成本分别被给出为 $\\mathcal{O}(M K^2)$、$\\mathcal{O}(M K)$ 和 $\\mathcal{O}(K^3)$。题目指出，我们处于一个 $M K^2$ 项占主导地位的渐近状态。因此，单个时间步的回归成本被认为与 $M K^2$ 成正比。\nLSMC 方法的总成本 $C_{\\mathrm{LSMC}}$ 是每个时间步的成本乘以时间步数 $T-1$。忽略常数因子和低阶项，主阶复杂度为：\n$$\nC_{\\mathrm{LSMC}} \\propto (T-1) M K^2 \\sim T M K^2\n$$\n代入 $K$ 的表达式：\n$$\nC_{\\mathrm{LSMC}} = T M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2\n$$\n在此，我们根据题目“忽略常数因子”的指示，将 $C_{\\mathrm{LSMC}}$ 定义为运算次数中的主导项，并将比例常数设为 1。\n\n接下来，我们确定有限差分 (FD) 方法的主阶算术运算次数 $C_{\\mathrm{FD}}$。\nFD 方案也按时间向后进行。时间步数给定为 $N_t$，我们被指示设置 $N_t = T$。所以有 $T-1$ 个后向步骤。\n空间域是一个大小为 $G \\times G$ 的网格，包含 $G^2$ 个点。\n在每个时间步，通过投影逐次超松弛法 (PSOR) 求解一个投影线性互补问题来处理提早行权约束。此过程需要 $I$ 次迭代。每次迭代访问 $G^2$ 个网格点中的每一个，并对每个点执行 $\\mathcal{O}(1)$ 的工作量。因此，一次 PSOR 迭代的成本是 $\\mathcal{O}(G^2)$。每个时间步的总成本是每次迭代的成本乘以迭代次数 $I$，即 $\\mathcal{O}(I G^2)$。\n题目指出 $I$ 是一个常数。因此，每个时间步的主阶成本与 $G^2$ 成正比。\nFD 方法的总成本 $C_{\\mathrm{FD}}$ 是每个时间步的成本乘以时间步数 $T-1$。\n$$\nC_{\\mathrm{FD}} \\propto (T-1) G^2 \\sim T G^2\n$$\n再次忽略常数因子（包括 $I$），我们将主阶计数定义为：\n$$\nC_{\\mathrm{FD}} = T G^2\n$$\n\n最后，我们计算比率 $R \\equiv \\frac{C_{\\mathrm{LSMC}}}{C_{\\mathrm{FD}}}$。\n$$\nR = \\frac{T M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2}{T G^2}\n$$\n分子和分母中的因子 $T$ 被消去：\n$$\nR = \\frac{M \\left( \\frac{(p+1)(p+2)}{2} \\right)^2}{G^2}\n$$\n简化此表达式得到最终结果：\n$$\nR = \\frac{M (p+1)^2 (p+2)^2}{4 G^2}\n$$\n该表达式给出了计算成本的渐近比率，用 $M$、$p$ 和 $G$ 表示，符合题目要求。",
            "answer": "$$\n\\boxed{\\frac{M(p+1)^{2}(p+2)^{2}}{4G^{2}}}\n$$"
        },
        {
            "introduction": "在对算法效率有了理论上的理解之后，我们现在转向实际操作。本练习将指导您从零开始构建 LSMC 算法，并探讨一个关键的实际问题：当模拟路径数量较少时，由于过拟合可能产生的正向偏差。通过比较样本内和样本外估计，您将学会量化这种偏差，并体会到稳健验证的重要性。",
            "id": "2442310",
            "problem": "实现一个完整的程序，以量化和说明在用于回归的基函数数量相对于模拟路径数量较少时，美式看跌期权的 Longstaff–Schwartz 蒙特卡洛 (LSMC) 价格估计中出现的正偏差。您的实现必须基于以下基本原理：在无套利和风险中性定价下，美式期权的价值等于所有停止时间的折现预期收益的上确界，并且带有条件期望的动态规划刻画了最优停止规则。在 LSMC 中，条件期望通过投影到状态函数的有限维基上进行近似，并使用模拟路径通过最小二乘法进行估计。\n\n您必须严格按照数学和算法的术语进行如下操作：\n\n- 在风险中性概率测度下，通过几何布朗运动对动态进行建模：对于股票价格过程 $\\{S_t\\}_{t \\in [0,T]}$，使用随机微分方程 $\\mathrm{d}S_t = r S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t$ 的精确离散化，在具有 $M$ 个时间步的等距网格上模拟路径，其中 $r$ 是连续复利无风险利率，$\\sigma$ 是波动率，$\\{W_t\\}$ 是标准维纳过程。使用精确转移 $S_{t+\\Delta t} = S_t \\exp\\!\\left((r - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z\\right)$，其中 $Z \\sim \\mathcal{N}(0,1)$ 在时间和路径上独立。\n\n- 考虑一个美式看跌期权，其执行价格为 $K$，在任何行权时间 $t \\in [0,T]$ 的收益为 $\\max(K - S_t, 0)$。设时间网格为 $t_m = m \\Delta t$，其中 $\\Delta t = T/M$ 且 $m \\in \\{0,1,\\dots,M\\}$。\n\n- 实现 Longstaff–Schwartz 算法，通过对形式为 $\\{\\phi_j(x)\\}_{j=0}^{d}$（其中 $\\phi_j(x) = x^j$）的多项式基进行最小二乘投影来估计持续价值，该基函数应用于缩放后的状态 $x = S_t / K$，其中 $d$ 是多项式次数。在每个行权时间 $t_m$（不包括 $t_0$），将在当前处于价内（即$g(S_t)>0$）状态下评估的基函数上，对下一步的折现已实现现金流进行回归。使用无正则化的普通最小二乘法。使用相同的模拟路径来估计回归系数并计算最终的行权策略和现金流，以获得样本内 LSMC 价格估计。\n\n- 为消除样本内（前视）偏差，通过将每个时间步上从训练样本中拟合的回归系数应用于一组独立的模拟路径（具有相同的模型参数和时间网格）来执行样本外评估，以确定行权决策和已实现的折现现金流。这些折现现金流的均值给出了期权价格的样本外下界估计。\n\n- 将给定配置的测得偏差定义为样本内估计与样本外下界估计之间的差值。\n\n要使用的参数值（所有数字必须与 $S_0$ 和 $K$ 在相同的货币单位下解释；不涉及物理单位）：\n- 初始股价 $S_0 = 100$。\n- 执行价格 $K = 100$。\n- 无风险利率 $r = 0.06$。\n- 波动率 $\\sigma = 0.2$。\n- 到期时间 $T = 1$。\n- 时间步数 $M = 50$（因此 $\\Delta t = T/M$）。\n- 为保证数值稳定性，如上所述，通过 $S_t/K$ 对基函数进行缩放。\n\n随机性与可复现性：\n- 对样本外（评估）模拟使用固定的伪随机种子，等于 $4444$。\n- 对于训练模拟，使用下面测试套件中为每个测试用例提供的种子。\n- 对训练和样本外评估使用独立的随机数。\n\n行权时间约定：\n- 允许在时间点 $t_m$（其中 $m \\in \\{1,2,\\dots,M-1\\}$）进行行权决策，并为了在时间 0 进行估值，再折现一次至 $t_0$。最后，在 $t_0$ 时，取折现后的持续价值与即时行权价值 $\\max(K - S_0, 0)$ 中的较大者，以确保样本内和样本外估计在 $t_0$ 时与美式行权权利保持一致。\n\n基函数规格：\n- 对于多项式次数 $d$，使用大小为 $d+1$ 的基，其单项式为 $\\{1, x, x^2, \\dots, x^d\\}$，其中 $x = S_t/K$。\n\n测试套件：\n根据指定的种子，计算以下三种配置中每一种的测得偏差（定义为样本内估计减去样本外估计）。在每种情况下，使用大小为 $N_{\\text{eval}} = 8000$ 条独立路径的样本外评估集。\n1. 情况 A（小样本，高复杂度）：训练路径数 $N_{\\text{train}} = 120$，多项式次数 $d = 6$，训练种子 $111$。\n2. 情况 B（大样本，相同复杂度）：训练路径数 $N_{\\text{train}} = 1000$，多项式次数 $d = 6$，训练种子 $222$。\n3. 情况 C（小样本，低复杂度）：训练路径数 $N_{\\text{train}} = 120$，多项式次数 $d = 2$，训练种子 $333$。\n\n数值输出：\n- 对于每种情况，计算标量偏差并四舍五入到 $4$ 位小数。\n- 您的程序应生成单行输出，其中包含三个四舍五入后的偏差，形式为逗号分隔的列表，并用方括号括起来（例如，“[0.1234,0.5678,0.9012]”）。\n\n覆盖设计：\n- 情况 A 探索了由于 $N_{\\text{train}}$ 较小和基函数相对较大而可能产生的强正偏差。\n- 情况 B 作为“理想路径”，其中随着 $N_{\\text{train}}$ 的增加，偏差应该更小。\n- 情况 C 作为对比的边界情况，其中使用相同的小 $N_{\\text{train}}$ 但更少的基函数，以说明过拟合的减少。\n\n您的实现必须完全自包含，不需要用户输入，并严格遵守指定的输出格式。",
            "solution": "我们从风险中性概率测度下的基本无套利原理开始。设 $\\{S_t\\}_{t \\in [0,T]}$ 在风险中性测度下遵循几何布朗运动：\n$$\n\\mathrm{d}S_t = r S_t \\,\\mathrm{d}t + \\sigma S_t \\,\\mathrm{d}W_t,\n$$\n其中 $r$ 为连续复利无风险利率，$\\sigma$ 为波动率，$\\{W_t\\}$ 为标准维纳过程。在离散化步长 $\\Delta t$ 上的精确转移为\n$$\nS_{t+\\Delta t} = S_t \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z\\right),\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$ 在时间和路径上独立。对于一个收益过程为 $\\{g(S_t)\\}$ 的美式期权，这里对于看跌期权是 $g(s) = \\max(K - s, 0)$，时间 0 的无套利价格等于\n$$\nV_0 = \\sup_{\\tau \\in \\mathcal{T}} \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\tau} g(S_{\\tau}) \\right],\n$$\n其中 $\\mathcal{T}$ 是相对于由 $\\{S_t\\}$ 生成的滤子取值在 $[0,T]$ 内的停止时间集合，$\\mathbb{Q}$ 是风险中性测度。在离散时间网格 $t_m = m \\Delta t$，$m \\in \\{0,1,\\dots,M\\}$ 上，最优停止问题的动态规划递归是\n$$\nV_m(S_{t_m}) = \\max\\left( g(S_{t_m}), \\, \\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\Delta t} V_{m+1}(S_{t_{m+1}}) \\mid S_{t_m} \\right] \\right),\n$$\n其终端条件为 $V_M(S_{t_M}) = g(S_{t_M})$。\n\nLongstaff–Schwartz 蒙特卡洛 (LSMC) 方法通过到状态（此处为 $S_{t_m}$）基函数有限维线性张成的 $L^2$-投影来近似条件期望 $\\mathbb{E}^{\\mathbb{Q}}\\left[ e^{-r \\Delta t} V_{m+1}(S_{t_{m+1}}) \\mid S_{t_m} \\right]$。具体来说，在每个时间步 $t_m$（不包括初始时间 $t_0$）估计回归\n$$\nY = \\beta_0 \\phi_0(X) + \\beta_1 \\phi_1(X) + \\cdots + \\beta_d \\phi_d(X) + \\varepsilon,\n$$\n其中 $X := S_{t_m}/K$ 是缩放后的状态，而 $Y := e^{-r \\Delta t} \\hat{V}_{m+1}$ 是在当前策略下，对于价内（即 $g(S_{t_m}) > 0$）的模拟路径，从下一个时间步开始的折现已实现现金流。基函数是单项式 $\\phi_j(x) = x^j$，其中 $j = 0,1,\\dots,d$。系数 $\\{\\beta_j\\}$ 通过在模拟训练样本上进行普通最小二乘法得到。在时间 $t_m$ 的估计持续价值则为\n$$\n\\widehat{C}_m(S_{t_m}) = \\sum_{j=0}^d \\widehat{\\beta}_j \\phi_j(S_{t_m}/K).\n$$\n对于价内状态，如果 $g(S_{t_m}) > \\widehat{C}_m(S_{t_m})$，则估计的策略在 $t_m$ 行权；否则，继续持有。这个反向归纳从 $t_{M-1}$ 向下进行到 $t_1$，在每一步将已实现现金流以 $e^{-r \\Delta t}$ 进行折现。最后，在 $t_0$ 的估值需要再折现一次 $e^{-r \\Delta t}$，并与 $g(S_0)$ 取最大值，以尊重在 $t_0$ 的提早行权权利：\n$$\n\\widehat{V}_0 = \\max\\left(g(S_0), \\, e^{-r \\Delta t} \\cdot \\frac{1}{N} \\sum_{n=1}^N \\widehat{C}_0^{(n)} \\right),\n$$\n其中 $\\widehat{C}_0^{(n)}$ 表示在估计策略下的路径折现持续现金流。\n\n当路径数量相对于基函数数量较少时的偏差机制：\n- 回归步骤使用来自同一模拟样本的带噪声目标 $Y$ 来估计系数 $\\{\\widehat{\\beta}_j\\}$。当样本量 $N$ 相对于基维度 $d+1$ 较小时，回归倾向于对训练集中的 $Y$ 的噪声进行过拟合，特别是因为回归是基于价内子集，而在许多时间步上该子集可能相当小。这减少了样本内的训练残差，在方便样本内估值的地方人为地增加了估计的持续价值，并且关键地，影响了行权决策，从而选择了在样本内看起来更有利的路径结果。\n- 由于行权决策是基于将 $g(S_{t_m})$ 与过拟合的 $\\widehat{C}_m(S_{t_m})$ 进行比较，决策边界可能被扭曲以减少样本内的提早行权，从而增加了在同一样本上测量的已实现折现现金流。这在 LSMC 价格估计中引入了正向的前视（或样本内）偏差。\n- 样本外评估将相同的回归系数应用于一个独立的路径集。过拟合并不会转移到新数据上；因此，该策略通常不会表现出同样被人为高估的持续价值。样本外估计是真实价格的一个有效下界，并消除了样本内的乐观情绪，因此样本内估计和样本外估计之间的差异提供了正偏差的经验度量。\n\n程序的算法设计：\n1. 使用给定的 $S_0$、$r$、$\\sigma$、$T$ 和 $M$，以及固定的训练种子，通过精确离散化模拟训练路径 $\\{S^{\\text{train}}_{t_m}\\}$ 以保证可复现性。\n2. 训练的反向归纳：\n   - 在到期日 $t_M$ 将路径现金流初始化为 $g(S^{\\text{train}}_{t_M})$。\n   - 对于 $m = M-1, M-2, \\dots, 1$：\n     - 将下一步的现金流以 $e^{-r \\Delta t}$ 折现。\n     - 识别出 $g(S^{\\text{train}}_{t_m}) > 0$ 的价内路径。\n     - 仅使用价内路径，将折现现金流对 $\\{\\phi_j(S^{\\text{train}}_{t_m}/K)\\}_{j=0}^d$ 进行回归，以获得 $\\{\\widehat{\\beta}_{m,j}\\}_{j=0}^d$。\n     - 使用这些系数计算所有训练路径的 $\\widehat{C}_m$，并在价内路径上当 $g(S^{\\text{train}}_{t_m}) > \\widehat{C}_m$ 时行权，更新现金流；否则，继续持有折现后的现金流。\n   - 在 $m=1$ 完成后，再折现一次到 $t_0$，并取 $\\widehat{V}^{\\text{in}}_0 = \\max\\big(g(S_0), \\text{在 } t_0 \\text{ 的折现现金流的均值}\\big)$。\n   - 存储所有 $m \\in \\{1,\\dots,M-1\\}$ 的回归系数 $\\{\\widehat{\\beta}_{m,j}\\}$。\n3. 样本外评估：\n   - 使用固定的评估种子，模拟一个包含 $N_{\\text{eval}}$ 条路径的独立评估集 $\\{S^{\\text{eval}}_{t_m}\\}$。\n   - 在 $t_M$ 将评估现金流初始化为 $g(S^{\\text{eval}}_{t_M})$。\n   - 对于 $m = M-1, M-2, \\dots, 1$：\n     - 以 $e^{-r \\Delta t}$ 折现。\n     - 使用存储的 $\\{\\widehat{\\beta}_{m,j}\\}$ 计算在 $S^{\\text{eval}}_{t_m}$ 处的 $\\widehat{C}_m$。\n     - 在价内路径上当 $g(S^{\\text{eval}}_{t_m}) > \\widehat{C}_m$ 时行权，更新现金流；否则继续持有。\n   - 在 $m=1$ 完成后，再折现一次到 $t_0$，并取 $\\widehat{V}^{\\text{out}}_0 = \\max\\big(g(S_0), \\text{在 } t_0 \\text{ 的折现现金流的均值}\\big)$。\n4. 测得的偏差为 $B = \\widehat{V}^{\\text{in}}_0 - \\widehat{V}^{\\text{out}}_0$，四舍五入到 $4$ 位小数。\n\n测试套件的基本原理：\n- 情况 A：$N_{\\text{train}} = 120$ 且次数 $d = 6$ 意味着有 $d+1 = 7$ 个基函数，相对于许多时间步上的价内样本量而言是相当大的。我们预计会出现一个显著的正偏差。\n- 情况 B：$N_{\\text{train}} = 1000$ 且次数相同 $d = 6$，增加了样本量，应该会减少过拟合；因此，测得的偏差应小于情况 A。\n- 情况 C：$N_{\\text{train}} = 120$ 且次数 $d = 2$，相对于情况 A 降低了模型复杂度，从而减轻了过拟合并产生比情况 A 更小的偏差，尽管 $N_{\\text{train}}$ 同样很小。\n\n程序必须生成单行输出，包含按情况 A、B、C 顺序排列的三个偏差的列表，每个偏差四舍五入到 $4$ 位小数并用逗号分隔。这个输出简洁地量化了 $N_{\\text{train}}$ 与基维度之比对 LSMC 中样本内乐观情绪的影响。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_gbm_paths(S0, r, sigma, T, M, N, rng):\n    dt = T / M\n    # Generate standard normal increments\n    Z = rng.standard_normal(size=(N, M))\n    drift = (r - 0.5 * sigma * sigma) * dt\n    vol = sigma * np.sqrt(dt)\n    # Log increments\n    log_increments = drift + vol * Z\n    # Cumulative sum along time, prepend zeros for t0\n    log_paths = np.concatenate(\n        [np.zeros((N, 1)), np.cumsum(log_increments, axis=1)], axis=1\n    )\n    S_paths = S0 * np.exp(log_paths)\n    return S_paths  # shape (N, M+1)\n\ndef payoff_put(S, K):\n    return np.maximum(K - S, 0.0)\n\ndef basis_matrix(S_scaled, degree):\n    # S_scaled: shape (n,) or (n,1), build [1, x, x^2, ..., x^degree]\n    x = S_scaled.reshape(-1)\n    # Use Vandermonde with increasing powers\n    return np.vander(x, N=degree+1, increasing=True)\n\ndef lsmc_train_and_coeffs(S_paths, K, r, T, M, degree):\n    \"\"\"\n    Train LSMC on given paths:\n    - Returns in-sample price and list of regression coefficients per time step m=1..M-1.\n    \"\"\"\n    N = S_paths.shape[0]\n    dt = T / M\n    disc = np.exp(-r * dt)\n\n    # Initialize cashflows at maturity\n    cf = payoff_put(S_paths[:, M], K).copy()\n\n    # Store coefficients for each time step m (1..M-1). We'll use None if regression is skipped.\n    coeffs = [None] * (M + 1)\n\n    # Backward induction from m = M-1 down to 1\n    for m in range(M-1, 0, -1):\n        # Discount cashflows to time m\n        cf *= disc\n\n        S_m = S_paths[:, m]\n        immediate = payoff_put(S_m, K)\n        itm_mask = immediate > 0.0\n        idx = np.where(itm_mask)[0]\n\n        if idx.size > 0:\n            # Regression on in-the-money paths only\n            X = basis_matrix(S_m[idx] / K, degree)\n            Y = cf[idx]\n            # Ordinary least squares (minimum-norm solution if underdetermined)\n            beta, *_ = np.linalg.lstsq(X, Y, rcond=None)\n            coeffs[m] = beta\n            # Continuation estimates for all paths at time m\n            X_all = basis_matrix(S_m / K, degree)\n            cont = X_all.dot(beta)\n            # Exercise decision for in-the-money paths\n            exercise = itm_mask  (immediate > cont)\n            # Update cashflows: for exercised paths, set to immediate payoff; others keep continuation cf\n            cf[exercise] = immediate[exercise]\n        else:\n            # No in-the-money paths; keep coeffs[m] as None and no exercise updates\n            coeffs[m] = np.zeros(degree+1, dtype=float)  # zero continuation\n\n    # Discount once more to time 0\n    cf0 = cf * disc\n    # Enforce American right at t=0\n    price_in_sample = max(payoff_put(np.array([S_paths[0, 0]]), K)[0], float(np.mean(cf0)))\n    return price_in_sample, coeffs\n\ndef lsmc_evaluate_oos(S_paths_eval, K, r, T, M, degree, coeffs):\n    \"\"\"\n    Apply stored regression coefficients to an independent evaluation set to compute out-of-sample price.\n    \"\"\"\n    N = S_paths_eval.shape[0]\n    dt = T / M\n    disc = np.exp(-r * dt)\n\n    cf = payoff_put(S_paths_eval[:, M], K).copy()\n\n    for m in range(M-1, 0, -1):\n        cf *= disc\n        S_m = S_paths_eval[:, m]\n        immediate = payoff_put(S_m, K)\n        itm_mask = immediate > 0.0\n\n        beta = coeffs[m]\n        if beta is None:\n            # No regression info; continuation is zero -> immediate exercise if in-the-money\n            exercise = itm_mask  # since cont = 0\n            cf[exercise] = immediate[exercise]\n        else:\n            X_all = basis_matrix(S_m / K, degree)\n            cont = X_all.dot(beta)\n            # Exercise decision for in-the-money paths\n            exercise = itm_mask  (immediate > cont)\n            cf[exercise] = immediate[exercise]\n\n    cf0 = cf * disc\n    price_oos = max(payoff_put(np.array([S_paths_eval[0, 0]]), K)[0], float(np.mean(cf0)))\n    return price_oos\n\ndef run_case(S0, K, r, sigma, T, M, degree, N_train, N_eval, seed_train, seed_eval):\n    rng_train = np.random.default_rng(seed_train)\n    rng_eval = np.random.default_rng(seed_eval)\n\n    # Simulate training and evaluation paths\n    S_train = simulate_gbm_paths(S0, r, sigma, T, M, N_train, rng_train)\n    S_eval = simulate_gbm_paths(S0, r, sigma, T, M, N_eval, rng_eval)\n\n    # Train LSMC and get in-sample price and coefficients\n    price_in, coeffs = lsmc_train_and_coeffs(S_train, K, r, T, M, degree)\n    # Evaluate out-of-sample lower bound\n    price_oos = lsmc_evaluate_oos(S_eval, K, r, T, M, degree, coeffs)\n\n    bias = price_in - price_oos\n    return bias\n\ndef solve():\n    # Model and grid parameters\n    S0 = 100.0\n    K = 100.0\n    r = 0.06\n    sigma = 0.2\n    T = 1.0\n    M = 50\n\n    # Evaluation (out-of-sample) set size and seed\n    N_eval = 8000\n    seed_eval = 4444\n\n    # Test cases: (N_train, degree, seed_train)\n    test_cases = [\n        (120, 6, 111),   # Case A: small N_train, high degree\n        (1000, 6, 222),  # Case B: larger N_train, same degree\n        (120, 2, 333),   # Case C: small N_train, low degree\n    ]\n\n    results = []\n    for N_train, degree, seed_train in test_cases:\n        bias = run_case(S0, K, r, sigma, T, M, degree, N_train, N_eval, seed_train, seed_eval)\n        results.append(bias)\n\n    # Round to 4 decimals and print in required format\n    formatted = \"[\" + \",\".join(f\"{x:.4f}\" for x in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "LSMC 算法的灵活性和强大功能的一个关键方面在于回归分析中基函数的选择，但这种选择也引入了模型风险。本练习旨在探讨算法结果（特别是估计的提前行权边界）对不同基函数族（例如，简单单项式与拉盖尔多项式）的敏感性。这将加深您对模型设定如何影响定价结果准确性和稳定性的理解。",
            "id": "2442309",
            "problem": "考虑使用 Longstaff–Schwartz 算法（最小二乘蒙特卡洛，Longstaff–Schwartz 算法）在风险中性测度下为美式看跌期权定价。标的资产价格过程被建模为几何布朗运动，其在风险中性概率测度下的风险中性动态由以下随机微分方程给出：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t,$$ 其中 $S_t$ 是资产价格，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。该美式看跌期权的行权价为 $K$，到期日为 $T$，在时间 $t$ 的支付为 $$\\max\\{K - S_t, 0\\}.$$ Longstaff–Schwartz 算法通过将折现后的已实现现金流投影到当前状态的选定基函数族上，来近似每个行权时间的条件期望继续价值。基函数族的选择会产生近似误差，这可能影响估计的最优停止策略，特别是估计的行权边界。您的任务是通过在相同的模拟路径上运行该算法两次来量化估计的行权边界对基函数族的敏感性，一次使用简单单项式，一次使用拉盖尔（Laguerre）多项式，然后比较在选定时间点上得到的估计边界。\n\n您必须从风险中性定价和最优停止的首要原则出发，实现以下内容：\n\n1) 使用几何布朗运动的精确解，在均匀时间网格上模拟 $S_t$。对于 $N$ 个大小为 $\\Delta t = T/N$ 的时间步，每条路径的递推公式为 $$S_{t+\\Delta t} = S_t \\exp\\left(\\left(r - q - \\tfrac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\right),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$ 是独立的标准正态分布抽样。\n\n2) 实现美式看跌期权的 Longstaff–Schwartz 算法：\n   a) 在到期日 $t_N = T$，将每条路径的现金流设置为支付 $C_N = \\max\\{K - S_{t_N}, 0\\}$。\n   b) 从 $i = N-1, N-2, \\dots, 1$ 向后进行。首先，用单步折现因子 $\\exp(-r \\Delta t)$ 对现有现金流进行折现，以获得它们在 $t_i$ 时刻的价值。在 $t_i$ 时刻处于价内（即满足 $\\max\\{K - S_{t_i}, 0\\} > 0$）的路径中，将折现后的现金流对标准化状态 $x = S_{t_i}/K$ 的选定基函数族进行最小二乘回归。使用该回归来估计价内路径的继续价值 $\\widehat{C}_{\\text{cont}}(S_{t_i})$。对于那些立即行权价值 $\\max\\{K - S_{t_i}, 0\\}$ 大于或等于估计继续价值的价内路径，执行行权；否则，继续持有，并保持折现后的现金流不变。\n   c) 在 $t_1$ 结束向后归纳后，将剩余的现金流再折现一步至时间 $t_0$，以获得 $0$ 时刻现值，并计算期权价格估计值为所有路径的平均值。此价格不是此处的最终输出目标，但对于算法的内部一致性是必要的。\n\n3) 对于步骤 2b 中的回归，在相同的模拟路径上使用两种不同的基函数族：\n   a) 单项式：使用基向量 $$[1, x, x^2, x^3]$$ 其中 $x = S_{t_i}/K$。\n   b) 拉盖尔（Laguerre）多项式：使用前四个（物理学家版本）拉盖尔（Laguerre）多项式，在 $x = S_{t_i}/K$ 处求值，即 $$L_0(x) = 1, \\; L_1(x) = 1 - x, \\; L_2(x) = 1 - 2x + \\tfrac{x^2}{2}, \\; L_3(x) = 1 - 3x + \\tfrac{3}{2}x^2 - \\tfrac{1}{6}x^3.$$ 用这些列构建回归设计矩阵。\n\n4) 在由到期日分位数 $\\{1/4, 1/2, 3/4\\}$ 指定的三个内部行权时间点，按如下方式为每个基函数族估计行权边界。设 $t_i$ 是最接近 $T$ 的每个分位数的时间索引（四舍五入到 $\\{1, \\dots, N-1\\}$ 中的最近整数索引）。在时间 $t_i$，给定拟合的回归函数 $\\widehat{C}_{\\text{cont}}(S)$，定义函数 $$f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S).$$ 在用 $M$ 个点均匀离散化的网格 $S \\in [0, K]$ 上，找到该网格上满足 $f(S) \\ge 0$ 的 $S$ 的上确界。如果存在索引 $j$ 使得 $f(S_j) \\ge 0$ 且 $f(S_{j+1})  0$，则在 $S_j$ 和 $S_{j+1}$ 之间进行线性插值以优化根的估计；否则，如果对所有网格点 $f(S) \\ge 0$，则将边界设为 $K$，如果对所有网格点 $f(S)  0$，则将边界设为 $0$。\n\n5) 敏感性度量：对于每个测试案例，计算在三个选定时间点上，使用拉盖尔多项式和单项式基函数得到的边界之间的最大绝对差： $$D = \\max_{t \\in \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t) - \\widehat{S}^*_{\\text{Monomials}}(t) \\right|.$$\n\n实现细节和约束：\n- 每个测试案例使用指定的 $N$ 个时间步和 $P$ 条独立路径。在每个测试案例中，对两种基函数族使用相同的随机数种子和相同的模拟路径，以隔离基函数选择的影响。\n- 使用第 1 项中概述的精确几何布朗运动离散化方法。\n- 使用数值稳定的方法进行最小二乘计算。如果在回归步骤中没有价内路径，则按惯例将该时间的边界估计值（如果需要）定义为 $0$。如果至少有一条价内路径，则继续进行回归；如果出现病态问题，则使用使平方残差最小化的最小二乘解。\n- 对于边界网格，使用在 $[0, K]$ 上的 $M = 400$ 个均匀间隔点。\n- 所有利率和波动率均以小数表示（例如，$5\\%$ 表示为 $0.05$），不涉及物理单位。\n\n测试套件：\n为以下三个测试案例提供结果。在所有案例中，使用 $P = 8{,}192$ 条路径，边界网格大小 $M = 400$，以及指定的时间步数 $N$。\n\n1) 案例 A（平衡，中等波动率）：$S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0$, $\\sigma = 0.2$, $T = 1$, $N = 50$, 随机数种子 $= 12345$。\n2) 案例 B（价外开局，高波动率）：$S_0 = 90$, $K = 100$, $r = 0.03$, $q = 0$, $\\sigma = 0.5$, $T = 1$, $N = 50$, 随机数种子 $= 2023$。\n3) 案例 C（价内开局，低波动率，较短到期日）：$S_0 = 110$, $K = 100$, $r = 0.01$, $q = 0$, $\\sigma = 0.1$, $T = 0.5$, $N = 40$, 随机数种子 $= 42$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含测试案例 A、B 和 C 的三个敏感性值 $D$，分别四舍五入到 $6$ 位小数，格式为用方括号括起来的逗号分隔列表，例如，$$[0.123456,0.234567,0.345678].$$",
            "solution": "该问题要求实现 Longstaff-Schwartz 算法，以分析美式看跌期权行权边界对基函数选择的敏感性。解决方案从首要原则出发，逻辑清晰。\n\n**1. 资产路径的风险中性模拟**\n衍生品定价的基础是风险中性定价原则。我们在风险中性测度 $\\mathbb{Q}$ 下模拟标的资产价格 $S_t$ 的演变。其动态由以下随机微分方程描述：\n$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t^{\\mathbb{Q}}$$\n其中 $r$ 是无风险利率，$q$ 是股息率，$\\sigma$ 是波动率，$W_t^{\\mathbb{Q}}$ 是在 $\\mathbb{Q}$ 下的标准布朗运动。该方程有精确解，这使得在离散时间网格 $t_0, t_1, \\dots, t_N$（其中 $t_i = i \\Delta t$ 且 $\\Delta t = T/N$）上进行精确模拟成为可能。对于 $P$ 条路径中的每一条，我们按如下方式生成价格序列：\n$$S_{t_{i+1}} = S_{t_i} \\exp\\left(\\left(r - q - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_{i+1}\\right)$$\n这里，$\\{Z_i\\}_{i=1}^N$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。为了确保可控的比较，同一组 $P$ 条模拟路径将用于两种基函数的分析。\n\n**2. Longstaff-Schwartz 算法：向后归纳与回归**\n美式期权在任何时间 $t$ 的价值是其立即行权价值和其继续价值（持有期权的期望价值）中的较大者。这个最优停止问题通过向后归纳的动态规划方法解决。\n\n设 $C_i(S_{t_i})$ 为在给定状态 $S_{t_i}$ 下，期权在时间 $t_i$ 的价值。\n在到期日 $t_N = T$，期权价值就是其内在价值：\n$$C_N(S_{t_N}) = \\max(K - S_{t_N}, 0)$$\n然后我们从 $i = N-1$ 到 $1$ 向后递推。在每个时间点 $t_i$，继续价值 $C_{\\text{cont}}(S_{t_i})$ 是下一步期权价值的折现期望值，以 $t_i$ 时刻的信息为条件：\n$$C_{\\text{cont}}(S_{t_i}) = \\mathbb{E}^{\\mathbb{Q}}\\left[e^{-r\\Delta t} C_{i+1}(S_{t_{i+1}}) \\mid S_{t_i}\\right]$$\nLongstaff-Schwartz 算法的核心创新是使用线性回归来近似这个条件期望。回归仅对“价内”($S_{t_i}  K$) 的路径进行，因为对于价外路径，决策总是继续持有。对于这些价内路径，我们将折现后的未来现金流 $\\{e^{-r\\Delta t} C_{i+1}^{(j)}\\}$（其中 $j$ 是路径索引）对标准化状态变量 $x = S_{t_i}/K$ 的一组基函数 $\\{f_k(S_{t_i}^{(j)}/K)\\}_{k=0}^d$ 进行回归。这产生了一个估计的继续价值函数：\n$$\\widehat{C}_{\\text{cont}}(S_{t_i}) = \\sum_{k=0}^{d} \\beta_{i,k} f_k(S_{t_i}/K)$$\n系数 $\\boldsymbol{\\beta}_i = \\{\\beta_{i,k}\\}$ 通过最小化平方误差和来找到。我们按规定使用两种不同的基函数族：\n- **单项式**：基为 $[1, x, x^2, x^3]$。\n- **拉盖尔（Laguerre）多项式**：基为 $[L_0(x), L_1(x), L_2(x), L_3(x)]$。\n一旦估计出 $\\widehat{C}_{\\text{cont}}(S_{t_i})$，就对每个价内路径应用最优停止规则：\n如果 $\\max(K - S_{t_i}, 0) \\geq \\widehat{C}_{\\text{cont}}(S_{t_i}), \\text{ 则行权；否则，继续持有。}$\n如果行权是最优选择，则该路径在时间 $t_i$ 的现金流设为 $K - S_{t_i}$，并且该值在后续步骤中（折现后）向后传递。如果继续持有是最优选择，则 $t_i$ 的现金流是来自 $t_{i+1}$ 的折现现金流。此过程定义了所有路径的现金流向量 $\\{C_i^{(j)}\\}$。\n\n**3. 行权边界的估计**\n行权边界 $S^*(t)$ 是期权持有者在立即行权和继续持有之间无差异的关键股票价格。这个无差异点由行权价值与继续价值相等来定义：\n$$K - S^*(t) = C_{\\text{cont}}(S^*(t), t)$$\n我们在指定的时间 $t_i$ 估计此边界 $\\widehat{S}^*(t_i)$，方法是找到函数 $f(S) = (K - S) - \\widehat{C}_{\\text{cont}}(S)$ 的根，其中 $\\widehat{C}_{\\text{cont}}(S)$ 是使用在步骤 $t_i$ 计算出的回归系数 $\\boldsymbol{\\beta}_i$ 构建的。根是通过在区间 $[0, K]$ 上的一个包含 $M=400$ 个点的细网格上评估 $f(S)$ 来数值定位的。当在两个相邻网格点 $S_j$ 和 $S_{j+1}$ 之间检测到 $f(S)$ 的符号变化时，使用线性插值以高精度近似根。如果 $f(S) \\geq 0$ 在整个网格上成立，则边界设为 $K$。如果 $f(S)  0$ 在所有地方都成立，则设为 $0$。\n\n**4. 敏感性分析**\n对每个测试案例，整个过程执行两次——一次使用单项式基函数，一次使用拉盖尔（Laguerre）基函数，均在相同的模拟资产路径集上进行。这隔离了基函数选择对估计行权边界的影响。对于每个指定的时间点 $t_i \\in \\{T/4, T/2, 3T/4\\}$，我们计算两个边界估计值 $\\widehat{S}^*_{\\text{Monomials}}(t_i)$ 和 $\\widehat{S}^*_{\\text{Laguerre}}(t_i)$。最终的敏感性度量 $D$ 是这三个时间点上这些估计值之间差异的绝对值的最大值：\n$$D = \\max_{i \\in \\text{indices for } \\{T/4, T/2, 3T/4\\}} \\left| \\widehat{S}^*_{\\text{Laguerre}}(t_i) - \\widehat{S}^*_{\\text{Monomials}}(t_i) \\right|$$\n该度量量化了与 Longstaff-Schwartz 算法中基函数选择相关的模型风险。以下代码实现了这一完整方法论。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_basis_functions(x, basis_type):\n    \"\"\"\n    Generates the design matrix for given states and basis type.\n\n    Args:\n        x (np.ndarray): Scaled asset prices (S/K).\n        basis_type (str): 'monomials' or 'laguerre'.\n\n    Returns:\n        np.ndarray: The design matrix (number of paths x number of basis functions).\n    \"\"\"\n    if basis_type == 'monomials':\n        return np.vstack([np.ones_like(x), x, x**2, x**3]).T\n    elif basis_type == 'laguerre':\n        L0 = np.ones_like(x)\n        L1 = 1.0 - x\n        L2 = 1.0 - 2.0 * x + 0.5 * x**2\n        L3 = 1.0 - 3.0 * x + 1.5 * x**2 - (1.0 / 6.0) * x**3\n        return np.vstack([L0, L1, L2, L3]).T\n    else:\n        raise ValueError(\"Unknown basis type specified.\")\n\ndef run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, basis_type, boundary_times_indices):\n    \"\"\"\n    Runs the Longstaff-Schwartz algorithm and computes exercise boundaries at specified times.\n\n    Args:\n        S_paths (np.ndarray): Simulated asset price paths.\n        K (float): Strike price.\n        r (float): Risk-free rate.\n        dt (float): Time step size.\n        N (int): Number of time steps.\n        M (int): Number of points in the boundary estimation grid.\n        basis_type (str): 'monomials' or 'laguerre'.\n        boundary_times_indices (set): Set of time indices to estimate the boundary.\n\n    Returns:\n        dict: A dictionary mapping time index to the estimated boundary value.\n    \"\"\"\n    P = S_paths.shape[0]\n    cash_flows = np.maximum(K - S_paths[:, -1], 0)\n    boundary_estimates = {}\n\n    for i in range(N - 1, 0, -1):\n        cash_flows *= np.exp(-r * dt)\n        S_t = S_paths[:, i]\n        itm_indices = np.where(S_t  K)[0]\n\n        if len(itm_indices) > 0:\n            X = get_basis_functions(S_t[itm_indices] / K, basis_type)\n            y = cash_flows[itm_indices]\n\n            try:\n                beta = np.linalg.lstsq(X, y, rcond=None)[0]\n            except np.linalg.LinAlgError:\n                # In case of a fatal error, which is unlikely with lstsq, \n                # we assume continuation value is 0 (or some other robust handling).\n                # This would mean exercising whenever in the money.\n                beta = np.zeros(X.shape[1])\n\n            if i in boundary_times_indices:\n                S_grid = np.linspace(1e-6, K, M)\n                x_grid = S_grid / K\n                basis_grid = get_basis_functions(x_grid, basis_type)\n                cont_val_grid = basis_grid @ beta\n                f_S = (K - S_grid) - cont_val_grid\n\n                positive_f = np.where(f_S >= 0)[0]\n                if len(positive_f) == 0:\n                    boundary = 0.0\n                elif len(positive_f) == M:\n                    boundary = K\n                else:\n                    root_idx = positive_f[-1]\n                    if root_idx + 1  M:\n                        f1, f2 = f_S[root_idx], f_S[root_idx + 1]\n                        s1, s2 = S_grid[root_idx], S_grid[root_idx + 1]\n                        boundary = s1 - f1 * (s2 - s1) / (f2 - f1)\n                    else:\n                        boundary = K\n                boundary_estimates[i] = boundary\n\n            continuation_value = get_basis_functions(S_t[itm_indices] / K, basis_type) @ beta\n            exercise_value = K - S_t[itm_indices]\n            exercise_indices = itm_indices[exercise_value >= continuation_value]\n            cash_flows[exercise_indices] = K - S_t[exercise_indices]\n        \n        else:\n            if i in boundary_times_indices:\n                boundary_estimates[i] = 0.0\n\n    return boundary_estimates\n\ndef calculate_sensitivity(S0, K, r, q, sigma, T, N, P, M, seed):\n    \"\"\"\n    Calculates the sensitivity metric D for a single test case.\n\n    Args:\n        S0, K, r, q, sigma, T, N, P, M, seed: All problem parameters.\n\n    Returns:\n        float: The sensitivity metric D.\n    \"\"\"\n    np.random.seed(seed)\n    dt = T / N\n    S_paths = np.zeros((P, N + 1))\n    S_paths[:, 0] = S0\n    drift = (r - q - 0.5 * sigma**2) * dt\n    diffusion = sigma * np.sqrt(dt)\n\n    for i in range(1, N + 1):\n        Z = np.random.standard_normal(P)\n        S_paths[:, i] = S_paths[:, i-1] * np.exp(drift + diffusion * Z)\n\n    time_fractions = [0.25, 0.5, 0.75]\n    boundary_times_indices = {int(round(f * N)) for f in time_fractions}\n    boundary_times_indices = {max(1, min(N-1, idx)) for idx in boundary_times_indices}\n\n    boundaries_mono = run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, 'monomials', boundary_times_indices)\n    boundaries_laguerre = run_lsm_and_get_boundaries(S_paths, K, r, dt, N, M, 'laguerre', boundary_times_indices)\n    \n    differences = []\n    for idx in sorted(list(boundary_times_indices)):\n        b_mono = boundaries_mono.get(idx, 0.0)\n        b_lag = boundaries_laguerre.get(idx, 0.0)\n        differences.append(np.abs(b_lag - b_mono))\n        \n    return np.max(differences) if differences else 0.0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'S0': 100., 'K': 100., 'r': 0.05, 'q': 0., 'sigma': 0.2, 'T': 1.0, 'N': 50, 'seed': 12345},\n        {'S0': 90., 'K': 100., 'r': 0.03, 'q': 0., 'sigma': 0.5, 'T': 1.0, 'N': 50, 'seed': 2023},\n        {'S0': 110., 'K': 100., 'r': 0.01, 'q': 0., 'sigma': 0.1, 'T': 0.5, 'N': 40, 'seed': 42}\n    ]\n    common_params = {'P': 8192, 'M': 400}\n    \n    results = []\n    for case_params in test_cases:\n        params = {**case_params, **common_params}\n        D = calculate_sensitivity(**params)\n        results.append(D)\n        \n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}