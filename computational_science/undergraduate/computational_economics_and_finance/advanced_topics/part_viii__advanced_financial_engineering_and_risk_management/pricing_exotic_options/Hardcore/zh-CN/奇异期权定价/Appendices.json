{
    "hands_on_practices": [
        {
            "introduction": "理论模型为我们提供了定价的基础，但在实际应用中，我们必须处理影响资产价格的各种复杂因素，例如股息支付。此练习将指导您修改经典的二叉树模型，以准确地为支付离散股息的美式期权定价。通过在除息日调整股票价格路径，您将掌握一项在实践中至关重要的技能，因为对于美式期权而言，是否提前行权的决策与即将到来的股息密切相关 。",
            "id": "2420973",
            "problem": "您必须编写一个完整、可运行的程序，该程序使用修正的二叉树模型，为支付已知离散现金股息流的标的资产上的美式看涨期权定价，该模型考虑了除息日的股价下跌。该模型以纯数学术语指定，并且必须严格按照所述方式实现。\n\n其理论基础是风险中性测度下的无套利原理以及用于标的资产除息前动态的 Cox–Ross–Rubinstein (CRR) 二叉树模型。时间被离散化为$N$个等长的步长，$\\Delta t = T/N$。设连续复利无风险利率为$r$，波动率为$\\sigma$，初始价格为$S_0$。定义乘性上涨和下跌因子以及风险中性概率如下：\n- $u = e^{\\sigma \\sqrt{\\Delta t}}$，\n- $d = 1/u$，\n- $p = \\dfrac{e^{r \\Delta t} - d}{u - d}$。\n\n为除息前过程构建一个可重组的股价网格：\n- $S_{\\text{base}}(j,i) = S_0 \\, u^i \\, d^{j-i}$，其中时间索引 $j \\in \\{0,1,\\dots,N\\}$，节点索引 $i \\in \\{0,1,\\dots,j\\}$。\n\n将每个离散股息作为外生现金量$D_j$纳入，这些股息在与网格对齐的特定除息时间 $t_j = j \\Delta t$ 支付。如果金额为$D$的股息发生在时间$\\tau$，它将通过 $j = \\operatorname{round}(\\tau/\\Delta t)$ 与网格对齐，并且只要 $0 \\le \\tau \\le T$，它就贡献给$D_j$。在同一时间索引的多个股息必须相加。在任何除息时间索引$j$，该节点的可交易除息后股价为\n- $S_{\\text{eff}}(j,i) = \\max\\{ S_{\\text{base}}(j,i) - D_j, 0 \\}$，\n否则$S_{\\text{eff}}(j,i) = S_{\\text{base}}(j,i)$。这模拟了除息瞬间的价格下跌，并强制股价的非负性。\n\n设$V(j,i)$表示在时间索引$j$和节点$i$的美式看涨期权价值。将到期时的期末收益设置为\n- $V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$，\n其中$K$是行权价。对于向后归纳法，对每个$j = N-1, N-2, \\dots, 0$和$i \\in \\{0,1,\\dots,j\\}$，使用单步风险中性估值和折现因子$e^{-r \\Delta t}$计算持有价值：\n- $C(j,i) = e^{-r \\Delta t} \\left( p \\, V(j+1,i+1) + (1-p) \\, V(j+1,i) \\right)$。\n使用经除息调整后的股票计算在时间$j$的立即行权价值：\n- $E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\}$。\n然后通过以下方式强制执行提前行权\n- $V(j,i) = \\max\\{ E(j,i), \\, C(j,i) \\}$。\n\n要求的输出是时间为$0$时的价格$V(0,0)$。\n\n您的程序必须实现以上内容，并为以下测试套件中的每组参数计算价格。所有股息时间均以年为单位给出，并保证如所述与二叉网格完全对齐。任何严格大于$T$的股息时间都必须被忽略。对于每种情况，输出一个四舍五入到六位小数的浮点数。\n\n测试套件（每个项目是一个元组$(S_0, K, r, \\sigma, T, N, \\text{dividends})$，其中dividends是一个$(\\tau, D)$的列表）：\n\n- Case A（一般情况，多次股息）：$(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [ (0.5, \\$1.0), (0.75, \\$1.0) ])$。\n- Case B（无股息）：$(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [\\,])$。\n- Case C（到期后股息，应被忽略）：$(\\$100, \\$100, 0.05, 0.2, 1.0, 200, [ (1.5, \\$2.0) ])$。\n- Case D（大额股息导致除息后股价触及零底）：$(\\$50, \\$40, 0.01, 0.25, 0.5, 100, [ (0.25, \\$60.0) ])$。\n- Case E（到期日股息）：$(\\$120, \\$100, 0.03, 0.15, 1.0, 200, [ (1.0, \\$5.0) ])$。\n- Case F（单步边界情况）：$(\\$100, \\$90, 0.1, 0.3, 0.25, 1, [ (0.25, \\$2.0) ])$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,\\dots,x_6]$），其中每个$x_k$是对应情况的价格，四舍五入到六位小数，没有额外的空格。",
            "solution": "所提出的问题经过了严格的验证。\n\n**步骤1：提取已知条件**\n\n该问题为带有离散股息的股票上的美式看涨期权建模提供了以下数学定义和参数：\n-   到期时间$T$，时间步数$N$，时间步长$\\Delta t = T/N$。\n-   初始股价$S_0$，行权价$K$。\n-   连续复利无风险利率$r$，波动率$\\sigma$。\n-   Cox-Ross-Rubinstein (CRR) 模型参数：上涨因子$u = e^{\\sigma \\sqrt{\\Delta t}}$，下跌因子$d = 1/u$，以及风险中性概率$p = \\dfrac{e^{r \\Delta t} - d}{u - d}$。\n-   时间索引$j \\in \\{0, 1, \\dots, N\\}$和节点索引$i \\in \\{0, 1, \\dots, j\\}$处的基础股价：$S_{\\text{base}}(j,i) = S_0 \\, u^i \\, d^{j-i}$。\n-   股息处理：股息$(D, \\tau)$被分配到时间索引$j = \\operatorname{round}(\\tau/\\Delta t)$。在同一索引$j$的所有股息被加总为总金额$D_j$。\n-   有效的除息后股价：$S_{\\text{eff}}(j,i) = \\max\\{S_{\\text{base}}(j,i) - D_j, 0\\}$。如果在时间$j$没有股息，则$D_j=0$。\n-   到期时（时间$N$）的期权价值：$V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$。\n-   在时间$j$的持有价值：$C(j,i) = e^{-r \\Delta t} \\left( p \\cdot V(j+1,i+1) + (1-p) \\cdot V(j+1,i) \\right)$。\n-   在时间$j$的立即行权价值：$E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\}$。\n-   美式期权价值递归关系：$V(j,i) = \\max\\{ E(j,i), C(j,i) \\}$。\n-   目标是计算初始期权价格，$V(0,0)$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题指定了一个用于美式期权定价的修正二叉树模型，这是计算金融学的基石。该框架源自风险中性世界中的基本无套利原理。从股价中减去股息现值的方法是学术界和业界的标准做法。该问题在科学上是合理的。\n-   **适定性**：该问题被表述为一个递归算法（向后归纳法）。对于给定的一组输入参数，该算法会为期权产生一个单一、唯一的价格。解的存在性和唯一性由问题的结构保证。\n-   **客观性与完整性**：该问题使用精确、无歧义的数学形式主义进行陈述。测试用例所需的所有参数和数据都已提供。该模型是自洽的，没有主观因素。\n\n**步骤3：结论与行动**\n\n该问题被认为是有效的。它是金融工程中一个定义明确的标准问题。我将继续提供一个完整的解决方案。\n\n解决方案是通过在二叉网格上进行向后归纳法构建的。算法的核心是在树的每个节点上确定期权的价值，从到期时的终端节点开始，向后推导到时间$t=0$的初始节点。\n\n首先，我们预处理提供的股息流。使用一个由时间步$j \\in \\{0, \\dots, N\\}$索引的一维数组来存储在每个离散时间点支付的总股息金额$D_j$。对于每个在时间$\\tau$金额为$D$的股息，我们计算其对应的时间索引$j = \\operatorname{round}(\\tau/\\Delta t)$。如果$\\tau \\le T$（即$j \\le N$），则金额$D$被加到总额$D_j$中。\n\n向后归纳法过程如下：\n\n1.  **到期时初始化 ($j=N$)**：每个终端节点$i \\in \\{0, \\dots, N\\}$的期权价值是其内在价值。用于此计算的股价必须是除息后的价格。\n    -   基础（除息前）股价为$S_{\\text{base}}(N,i) = S_0 u^i d^{N-i}$。\n    -   有效（除息后）股价为$S_{\\text{eff}}(N,i) = \\max\\{ S_{\\text{base}}(N,i) - D_N, 0 \\}$。\n    -   终端期权价值为$V(N,i) = \\max\\{ S_{\\text{eff}}(N,i) - K, 0 \\}$。\n    这些值存储在一个大小为$N+1$的数组中。\n\n2.  **向后递归 ($j = N-1, N-2, \\dots, 0$)**：对于每个时间步$j$和每个节点$i \\in \\{0, \\dots, j\\}$，期权价值$V(j,i)$由无套利原理确定，该原理规定价值必须是其立即行权价值和其持有价值中的较大者。\n    -   **持有价值** $C(j,i)$，是在风险中性测度下计算的下一时间步期权的折现期望值：\n        $$C(j,i) = e^{-r \\Delta t} \\left( p \\cdot V(j+1,i+1) + (1-p) \\cdot V(j+1,i) \\right)$$\n        这里，$V(j+1,i+1)$ 和 $V(j+1,i)$ 是已在步骤$j+1$计算出的期权价值。\n    -   **立即行权价值** $E(j,i)$，是如果期权在此节点被行权所收到的收益。这是使用此节点的除息后股价计算的：\n        $$E(j,i) = \\max\\{ S_{\\text{eff}}(j,i) - K, 0 \\} = \\max\\{ \\max\\{S_{\\text{base}}(j,i) - D_j, 0\\} - K, 0 \\}$$\n        其中 $S_{\\text{base}}(j,i) = S_0 u^i d^{j-i}$。\n    -   美式期权价值则是这两者中的最大值：\n        $$V(j,i) = \\max\\{ C(j,i), E(j,i) \\}$$\n    这个过程重复进行，从后向前遍历整个树。一个大小为$N+1$的数组足以进行计算，其中在每个步骤$j$，步骤$j+1$的值被新的步骤$j$的值覆盖。\n\n3.  **最终结果**：循环完成后，数组中包含一个相关的单一值$V(0,0)$，这是时间$t=0$时的美式期权价格。这就是最终结果。\n\n该算法被实现用于每个提供的测试用例，以计算所需的期权价格。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def price_american_call_dividend_tree(S0, K, r, sigma, T, N, dividends):\n        \"\"\"\n        Prices an American call option on a stock with discrete dividends using a binomial tree.\n\n        Args:\n            S0 (float): Initial stock price.\n            K (float): Strike price.\n            r (float): Risk-free interest rate (continuously compounded).\n            sigma (float): Volatility.\n            T (float): Time to maturity in years.\n            N (int): Number of time steps in the binomial tree.\n            dividends (list): A list of tuples (tau, D), where tau is the dividend time in years\n                              and D is the dividend amount.\n\n        Returns:\n            float: The calculated price of the American call option.\n        \"\"\"\n        # 1. Parameter setup\n        dt = T / N\n        if sigma == 0 or dt == 0: # Handle edge cases\n             # For a single-step model where T=0, an immediate exercise check is all that's needed.\n             # This simple case is handled well by the general logic if dt is small but non-zero.\n             # If dt=0, we can evaluate only at t=0.\n             if T == 0:\n                 div_at_0 = sum(D for tau, D in dividends if tau == 0)\n                 return max(S0 - div_at_0 - K, 0)\n             else: # sigma=0, T>0\n                 # In a zero-volatility world, the stock price grows deterministically.\n                 # S(T) = S0 * exp(r*T) - sum of future value of dividends.\n                 fwd_price = S0 * np.exp(r * T)\n                 for tau, D in dividends:\n                     if 0  tau = T:\n                         fwd_price -= D * np.exp(r * (T - tau))\n                 payoff_at_T = max(fwd_price - K, 0)\n                 # Exercise value at t=0\n                 div_at_0 = sum(D for tau, D in dividends if tau == 0)\n                 exercise_at_0 = max(S0 - div_at_0 - K, 0)\n                 # Value is max of discounted payoff or immediate exercise\n                 return max(exercise_at_0, payoff_at_T * np.exp(-r*T))\n        \n        u = np.exp(sigma * np.sqrt(dt))\n        d = 1 / u\n        p = (np.exp(r * dt) - d) / (u - d)\n        discount = np.exp(-r * dt)\n\n        # 2. Process dividends into a time-step indexed array\n        # Problem guarantees dividend times align, so tau/dt will be an integer.\n        div_amounts = np.zeros(N + 1)\n        for tau, D in dividends:\n            if tau > T + 1e-9: # Ignore dividends after maturity, add tolerance\n                continue\n            j = int(round(tau / dt))\n            # Ensure index is within bounds, though problem guarantees it\n            if 0 = j = N:\n                div_amounts[j] += D\n\n        # 3. Initialize option values at maturity (j=N)\n        V = np.zeros(N + 1)\n        for i in range(N + 1):\n            s_base_N = S0 * (u**i) * (d**(N - i))\n            s_eff_N = max(s_base_N - div_amounts[N], 0)\n            V[i] = max(s_eff_N - K, 0)\n\n        # 4. Perform backward induction\n        for j in range(N - 1, -1, -1):\n            for i in range(j + 1):\n                # Calculate continuation value\n                continuation_value = discount * (p * V[i + 1] + (1 - p) * V[i])\n                \n                # Calculate immediate exercise value\n                s_base_j = S0 * (u**i) * (d**(j - i))\n                s_eff_j = max(s_base_j - div_amounts[j], 0)\n                exercise_value = max(s_eff_j - K, 0)\n                \n                # Update option value with early exercise decision\n                V[i] = max(continuation_value, exercise_value)\n\n        # 5. Return the option price at t=0\n        return V[0]\n\n    test_cases = [\n        # Case A (general, multiple dividends)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, [(0.5, 1.0), (0.75, 1.0)]),\n        # Case B (no dividends)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, []),\n        # Case C (dividend after maturity, should be ignored)\n        (100.0, 100.0, 0.05, 0.2, 1.0, 200, [(1.5, 2.0)]),\n        # Case D (large dividend causing post-drop floor at zero)\n        (50.0, 40.0, 0.01, 0.25, 0.5, 100, [(0.25, 60.0)]),\n        # Case E (dividend at maturity)\n        (120.0, 100.0, 0.03, 0.15, 1.0, 200, [(1.0, 5.0)]),\n        # Case F (single-step boundary)\n        (100.0, 90.0, 0.1, 0.3, 0.25, 1, [(0.25, 2.0)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, N, dividends = case\n        price = price_american_call_dividend_tree(S0, K, r, sigma, T, N, dividends)\n        results.append(round(price, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一些奇异期权的设计引入了有趣的递归逻辑，例如一个期权的行权价取决于其自身的价格。这种“自我参照”的结构使得我们无法直接套用公式，而是需要将定价问题转化为求解一个非线性方程的不动点问题 $C_0 = f(C_0)$。这个练习不仅要求您应用 Black-Scholes 模型，更重要的是，您需要从理论上证明解的存在性和唯一性，并设计一个稳健的数值算法（如二分法）来迭代求解这个隐含的价格 。",
            "id": "2420984",
            "problem": "要求您实现一个完整、可运行的程序，用于在 Black–Scholes 框架下计算一个自指欧式期权在时间$0$的价格。该期权在到期日$T$的期末收益为 $\\max(0, S_T - C_0)$，其中 $S_T$ 是标的资产在时间$T$的价格，$C_0$ 是未知的、期权本身在时间$0$的价格。模型假设为标准的 Black–Scholes 假设：无摩擦市场、无套利、恒定的无风险利率 $r$、零股息，以及标的资产价格在风险中性测度下遵循几何布朗运动 (GBM)。定价必须从风险中性定价原理推导得出，即从“无套利价格等于收益的贴现风险中性期望”这一定义出发。您的推导只能基于广为接受且经过充分检验的结论，不得依赖任何未经证明或临时的公式。\n\n您的任务是：\n1. 从风险中性定价的定义出发，将该自指期权的定价问题构建为一个关于未知数 $C_0$ 的一维非线性方程。\n2. 借助单调性以及由无套利原理导出的适当边界条件，解释为何在给定假设下存在唯一解。\n3. 设计一个稳健的数值算法来求解 $C_0$。您的算法必须：\n   - 对通用参数值（$S_0 \\ge 0$, $r \\in \\mathbb{R}$, $\\sigma \\ge 0$, $T \\ge 0$）均有效。\n   - 无需进行除零或未定义操作即可处理如 $\\sigma = 0$ 和 $T = 0$ 等边界情况。\n   - 使用保证收敛的区间法（例如，二分法）来求解该非线性方程。\n4. 在单个程序中实现该算法。您可以将 Black–Scholes 模型下欧式看涨期权价格的标准闭式解作为一个经过充分检验的事实来使用，也可以使用标准正态累积分布函数 (CDF)。如果使用 CDF，则必须给出其数学定义。\n\n使用以下测试套件。每个测试用例指定了 $(S_0, r, \\sigma, T)$：\n- 测试 $1$：$(100, 0.02, 0.2, 1)$\n- 测试 $2$：$(100, 0.05, 0, 1)$\n- 测试 $3$：$(100, 0.05, 0.3, 0)$\n- 测试 $4$：$(50, 0.10, 1.0, 2)$\n- 测试 $5$：$(10, 0, 0.1, 5)$\n- 测试 $6$：$(1, 0, 0, 3)$\n\n您的程序所需的输出为单行文本，其中包含六个测试计算出的价格 $C_0$ 列表，顺序与上文所列相同，四舍五入到恰好 $8$ 位小数，且无空格。例如，输出格式必须与 $[x_1,x_2,x_3,x_4,x_5,x_6]$ 完全一致，其中每个 $x_i$ 都是一个格式化为恰好 $8$ 位小数的浮点数。\n\n不涉及物理单位。此任务中没有角度或百分比。\n\n您的程序必须是自包含的，不得要求任何用户输入，并须遵守指定的执行环境。运行时，它必须以指定格式生成最终的输出行。",
            "solution": "所提出的问题是确定一个自指欧式期权在时间$0$的价格，记为 $C_0$。该期权在到期日 $T$ 的收益为 $\\max(0, S_T - C_0)$，其中 $S_T$ 是标的资产在时间 $T$ 的价格。这个问题是良定义的、科学上合理的，并且是在标准的 Black-Scholes 框架内。我们着手进行求解。\n\n无套利定价的基本原理规定，任何衍生证券的价格都是其未来收益在风险中性概率测度 $\\mathbb{Q}$ 下的贴现期望。对于这个特定的期权，我们将其表示为：\n$$ C_0 = e^{-rT} \\mathbb{E}_{\\mathbb{Q}} \\left[ \\max(0, S_T - C_0) | \\mathcal{F}_0 \\right] $$\n其中 $r$ 是恒定的无风险利率，$T$ 是到期时间，$\\mathcal{F}_0$ 表示在时间 $t=0$ 时的可用信息。\n\n右侧的表达式恰好是执行价格为 $K = C_0$ 的标准欧式看涨期权的 Black-Scholes 价格定义。让我们将 Black-Scholes 看涨期权价格表示为一个函数 $BS(S_t, K, r, \\sigma, \\tau)$，其中 $S_t$ 是时间 $t$ 的资产价格，$K$ 是执行价格，$r$ 是无风险利率，$\\sigma$ 是波动率，$\\tau = T-t$ 是距离到期日的时间。在时间 $t=0$ 时，我们有 $\\tau=T$。因此，该自指期权的定价关系就成为了一个关于 $C_0$ 的非线性方程：\n$$ C_0 = BS(S_0, C_0, r, \\sigma, T) $$\n\n为了求解 $C_0$，我们定义一个函数 $f(C)$，使得求出 $f(C)=0$ 的根即可得到期权价格：\n$$ f(C) = BS(S_0, C, r, \\sigma, T) - C $$\n欧式看涨期权的 Black-Scholes 公式由下式给出：\n$$ BS(S_0, K, r, \\sigma, T) = S_0 N(d_1) - K e^{-rT} N(d_2) $$\n其中 $N(x)$ 是标准正态分布的累积分布函数 (CDF)，\n$$ N(x) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{x} e^{-z^2/2} dz $$\n并且 $d_1$ 和 $d_2$ 项为：\n$$ d_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} \\quad \\text{和} \\quad d_2 = d_1 - \\sigma\\sqrt{T} $$\n将 $K=C$ 代入这些表达式，我们便得到函数 $f(C)$ 的完整形式。\n\n在设计数值算法之前，我们必须证明唯一解 $C_0$ 存在。\n首先，我们确定 $C_0$ 的界限。期权的收益 $\\max(0, S_T - C_0)$ 总是非负的，因此其价格也必须是非负的，$C_0 \\ge 0$。该收益也严格小于 $S_T$（除非 $C_0 \\le 0$，而这对一个有意义的期权是不可能的）。一个收益为 $S_T$ 的期权等价于持有标的资产（假设零股息），其价格为 $S_0$。根据优势原则，$C_0  S_0$。因此，任何有效解都必须位于区间 $[0, S_0)$ 内。\n\n解的存在性可以通过介值定理来证明。函数 $f(C)$ 在区间 $[0, S_0]$ 上是连续的，因为 Black-Scholes 价格函数相对于其执行价格 $K$ 是连续的。我们计算 $f(C)$ 在该区间边界处的值：\n1.  当 $C=0$ 时：执行价格为零。一个零执行价格的看涨期权是一种在到期日支付 $S_T$ 的工具。其时间$0$的价格为 $S_0$。因此，$BS(S_0, 0, r, \\sigma, T) = S_0$。\n    $f(0) = BS(S_0, 0, r, \\sigma, T) - 0 = S_0$。对于 $S_0  0$ 的非平凡情况，我们有 $f(0)  0$。\n2.  当 $C=S_0$ 时：执行价格等于初始股票价格。\n    $f(S_0) = BS(S_0, S_0, r, \\sigma, T) - S_0$。看涨期权的价格总是严格小于标的资产的价格，即 $BS(S_t, K, \\dots)  S_t$，因为它只提供对资产的或有索取权。因此，$BS(S_0, S_0, r, \\sigma, T)  S_0$，这意味着 $f(S_0)  0$。\n\n由于 $f(C)$ 是连续的，并且 $f(0)  0$ 和 $f(S_0)  0$，因此在 $(0, S_0)$ 区间内必定存在至少一个根 $C_0$。\n\n解的唯一性可以通过证明 $f(C)$ 是一个严格单调函数来确立。我们考察它关于 $C$ 的导数：\n$$ f'(C) = \\frac{d}{dC} \\left( BS(S_0, C, r, \\sigma, T) \\right) - 1 $$\nBlack-Scholes 看涨期权价格对执行价格 $K$ 的导数是金融数学中的一个标准结果：\n$$ \\frac{\\partial BS}{\\partial K} = -e^{-rT} N(d_2) $$\n用 $C$ 替换 $K$，我们得到 $f(C)$ 的导数：\n$$ f'(C) = -e^{-rT} N(d_2(C)) - 1 $$\n由于 $e^{-rT}  0$ 且 CDF $N(d_2)$ 的取值范围是 $[0, 1]$，因此项 $-e^{-rT}N(d_2(C))$ 总是非正的。所以，$f'(C) \\le -1$，这意味着对于所有 $C0$，$f'(C)$ 都是严格为负的。一个导数严格为负的函数是严格单调递减的。一个严格单调的函数最多与横轴相交一次。这一点，结合前面解存在性的证明，保证了存在唯一的解 $C_0$。\n\n用于求解 $C_0$ 的数值算法必须能处理存在闭式解的特定边界情况，从而避免诸如除以零之类的数值不稳定性问题。\n情况 1：$T=0$。到期日是即刻的。估值方程变为 $C_0 = \\max(0, S_0 - C_0)$。\n如果 $S_0 - C_0 \\le 0$，那么 $C_0=0$。这只在 $S_0=0$ 时才可能。\n如果 $S_0 - C_0  0$，那么 $C_0 = S_0 - C_0$，得到 $2C_0 = S_0$，所以 $C_0 = S_0/2$。这对任何 $S_0  0$ 都是一致的。解是 $C_0 = S_0/2$。\n\n情况 2：$\\sigma=0$ 且 $T0$。资产价格确定性增长：$S_T = S_0 e^{rT}$。估值方程为：\n$$ C_0 = e^{-rT} \\max(0, S_0 e^{rT} - C_0) = \\max(0, S_0 - e^{-rT} C_0) $$\n如前所述，对于 $S_0  0$，解必须为正，所以我们有 $C_0 = S_0 - e^{-rT} C_0$。\n解出 $C_0$ 可得 $C_0(1 + e^{-rT}) = S_0$，最终得到 $C_0 = \\frac{S_0}{1 + e^{-rT}}$。\n\n一般情况：$T0$ 且 $\\sigma0$。我们使用二分法求解非线性方程 $f(C)=0$。鉴于我们已证明在一个已知区间内存在唯一根，该方法是稳健的且保证收敛。\n二分法算法过程如下：\n1.  将搜索区间（托架）初始化为 $[a, b] = [0, S_0]$。我们已经证明了 $f(a)  0$ 且 $f(b)  0$。如果 Black-Scholes 公式的实现在 $K=0$ 时不够稳健，可以使用一个小的正数作为 $a$ 来避免数值问题，但一个正确的实现能够正确处理 $K=0$ 的情况（价格为 $S_0$）。\n2.  迭代直至区间宽度 $(b-a)$ 小于预设的容差 $\\epsilon$：\n    a. 计算中点 $m = a + (b-a)/2$。\n    b. 计算 $f(m) = BS(S_0, m, r, \\sigma, T) - m$。\n    c. 如果 $f(m)$ 与 $f(a)$ 同号（即 $f(m)0$），则根必在 $[m, b]$ 区间内。设置 $a=m$。\n    d. 否则，根在 $[a, m]$ 区间内。设置 $b=m$。\n3.  根 $C_0$ 的最终近似值是最后区间的中点 $(a+b)/2$。\n\n此过程为在指定的 Black-Scholes 假设下计算自指期权的价格提供了一个完整而稳健的方法。具体的实现将遵循此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the final result.\n    \"\"\"\n\n    test_cases = [\n        (100.0, 0.02, 0.2, 1.0),   # Test 1\n        (100.0, 0.05, 0.0, 1.0),   # Test 2\n        (100.0, 0.05, 0.3, 0.0),   # Test 3\n        (50.0, 0.10, 1.0, 2.0),    # Test 4\n        (10.0, 0.0, 0.1, 5.0),    # Test 5\n        (1.0, 0.0, 0.0, 3.0),     # Test 6\n    ]\n\n    results = []\n    for params in test_cases:\n        s0, r, sigma, t = params\n        price = compute_self_referential_option_price(s0, r, sigma, t)\n        results.append(f\"{price:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef black_scholes_call_price(s0, k, r, sigma, t):\n    \"\"\"\n    Computes the price of a European call option using the Black-Scholes formula.\n    Handles the edge case of t=0 or sigma=0, which should be pre-empted,\n    but provides a safe fallback.\n    \"\"\"\n    if t = 0 or sigma = 0:\n        # Payoff is deterministic: max(0, s0 - k)\n        return max(0.0, s0 - k)\n\n    # To avoid log(0) or division by zero for k=0\n    if k = 1e-12:\n        return s0\n\n    d1 = (np.log(s0 / k) + (r + 0.5 * sigma**2) * t) / (sigma * np.sqrt(t))\n    d2 = d1 - sigma * np.sqrt(t)\n\n    price = s0 * norm.cdf(d1) - k * np.exp(-r * t) * norm.cdf(d2)\n    return price\n\ndef compute_self_referential_option_price(s0, r, sigma, t):\n    \"\"\"\n    Computes the time-0 price of the self-referential option.\n    The payoff is max(0, S_T - C_0), where C_0 is the price itself.\n    \"\"\"\n    # Trivial case: if S0 is 0, the option price is 0.\n    if s0 = 0:\n        return 0.0\n\n    # Boundary case: T=0. The price is C0 = max(0, S0 - C0), which gives C0 = S0/2.\n    if t == 0:\n        return s0 / 2.0\n\n    # Boundary case: sigma=0. The price is C0 = S0 / (1 + exp(-r*T)).\n    if sigma == 0:\n        return s0 / (1.0 + np.exp(-r * t))\n\n    # General case: Solve C = BS(S0, C, r, sigma, T) using bisection.\n    # We are looking for the root of f(C) = BS(S0, C, ...) - C = 0.\n    def f(c):\n        if c = 0:\n            # For C -> 0, BS price -> S0. Thus f(0) = S0.\n            return s0\n        return black_scholes_call_price(s0, c, r, sigma, t) - c\n\n    # The root C0 is guaranteed to be in [0, S0].\n    low = 0.0\n    high = s0\n\n    # Check signs at boundaries (as proved in theory)\n    # f(low) = f(0) = S0 > 0\n    # f(high) = f(S0) = BS(S0, S0, ...) - S0  0\n    # If for some reason f(high) is not negative (e.g., numerical precision),\n    # the bisection might fail. This is not expected for valid parameters.\n\n    tolerance = 1e-12\n    max_iterations = 100\n\n    for _ in range(max_iterations):\n        mid = low + (high - low) / 2.0\n        if mid == low or mid == high: # Precision limit reached\n            break\n            \n        f_mid = f(mid)\n\n        if f_mid == 0:\n            return mid\n        elif f(low) * f_mid  0: # Root is in the lower half\n            high = mid\n        else: # Root is in the upper half\n            low = mid\n        \n        if (high - low)  tolerance:\n            break\n\n    return (low + high) / 2.0\n\nsolve()\n```"
        },
        {
            "introduction": "这个练习将挑战您回归到风险中性定价和最优停止理论的第一性原理，来为一个结构独特的“延迟支付”美式期权定价。与直接应用复杂的美式期权定价公式不同，您将通过巧妙的代数变换和鞅定价理论来分析其行权收益。这个过程将揭示一个深刻的结论：在某些特定结构下，看似有价值的提前行权权利实际上可能毫无价值，从而将一个复杂的美式期权问题简化为一个等价的欧式期权问题 。",
            "id": "2421044",
            "problem": "考虑一个在带域流的概率空间上定义的连续时间、无摩擦、无套利的市场，该空间支撑一个标准布朗运动。标的股票价格过程 $\\{S_{t}\\}_{t \\in [0,T]}$ 在风险中性测度 $\\mathbb{Q}$ 下遵循Black–Scholes–Merton动态模型，其中无风险利率 $r0$ 为常数，股息率为零，波动率 $\\sigma0$ 为常数：\n$$\n\\mathrm{d}S_{t} = r S_{t} \\,\\mathrm{d}t + \\sigma S_{t} \\,\\mathrm{d}W_{t}, \\quad S_{0}0.\n$$\n定义一个到期日为 $T0$、执行价格为 $K0$ 的美式看涨期权。该期权赋予持有者在任何停止时间 $\\tau \\in [0,T]$ 行权的权利，在时间 $\\tau$ 立即获得一股股票，但在到期日 $T$ 才支付执行价格 $K$（即，即使 $\\tauT$，支付也延迟到 $T$）。\n\n您的任务是运用鞅定价理论和最优停止原理来推导出该期权在时间 $0$ 的闭式解价格。您必须：\n1.  写出在任何停止时间 $\\tau \\in [0,T]$ 行权时，在时间 $\\tau$ 的净回报的价值。\n2.  写出该美式期权在时间 $0$ 价格的正式定义，即作为所有可能停止时间下贴现回报期望的上确界。\n3.  通过代数变换和定义一个合适的鞅过程，简化定价表达式。\n4.  基于您简化的表达式，论证最优行权策略是什么，并由此推导出期权在时间 $0$ 的最终价格公式。\n\n您必须以一个单一的、用 $\\LaTeX$ 排版的数学表达式给出最终答案，该表达式使用标准Black-Scholes符号表示，如 $S_0, K, r, \\sigma, T$ 以及标准正态累积分布函数 $N(\\cdot)$。请勿提交任何代码。",
            "solution": "问题是确定一个特定美式看涨期权在时间 $0$ 的价格 $V_0$。标的资产价格 $S_t$ 在风险中性测度 $\\mathbb{Q}$ 下遵循Black-Scholes-Merton模型：\n$$\n\\mathrm{d}S_{t} = r S_{t} \\mathrm{d}t + \\sigma S_{t} \\mathrm{d}W_{t}\n$$\n其中 $r$ 是恒定的无风险利率，$\\sigma$ 是恒定的波动率，$\\{W_{t}\\}$ 是在 $\\mathbb{Q}$ 下的标准布朗运动。\n\n该期权的到期日为 $T$，执行价格为 $K$。如果在某个停止时间 $\\tau \\in [0,T]$ 行权，持有者会收到一股股票（当时价值为 $S_{\\tau}$），并同时承担在固定的未来时间 $T$ 支付金额 $K$ 的义务。\n\n首先，我们确定在时间 $\\tau$ 行权时收到的回报的价值。持有者获得一份价值为 $S_{\\tau}$ 的资产。其义务是在时间 $T$ 支付 $K$。在时间 $\\tau$，该义务的价值是其贴现值，即 $K \\exp(-r(T-\\tau))$。因此，在时间 $\\tau$ 的净回报值为 $S_{\\tau} - K \\exp(-r(T-\\tau))$。由于这是一个期权，持有者只有在该值为正时才会行权。因此，在时间 $\\tau$ 的回报函数为 $P_{\\tau} = \\max(S_{\\tau} - K \\exp(-r(T-\\tau)), 0)$。\n\n根据美式期权的风险中性定价原理，时间 $t$ 的价格是贴现回报过程的Snell包络。这是对所有容许的停止时间 $\\tau \\in [t,T]$，取贴现回报的风险中性期望的上确界。对于 $t=0$，价格 $V_0$ 为：\n$$\nV_{0} = \\sup_{\\tau \\in [0,T]} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\exp(-r\\tau) \\max(S_{\\tau} - K \\exp(-r(T-\\tau)), 0) \\right]\n$$\n此处，$\\mathbb{E}^{\\mathbb{Q}}[\\cdot]$ 表示在时间 $0$ 的信息条件下，基于风险中性测度 $\\mathbb{Q}$ 的期望。\n\n为了解决这个最优停止问题，我们对期望内的项进行代数操作。贴现因子 $\\exp(-r\\tau)$ 是正的，因此可以移入 $\\max$ 函数内部：\n$$\n\\exp(-r\\tau) \\max(S_{\\tau} - K \\exp(-r(T-\\tau)), 0) = \\max(\\exp(-r\\tau)S_{\\tau} - \\exp(-r\\tau)K \\exp(-r(T-\\tau)), 0)\n$$\n化简括号中的第二项得到：\n$$\n\\exp(-r\\tau)K \\exp(-r(T-\\tau)) = K \\exp(-r\\tau - rT + r\\tau) = K \\exp(-rT)\n$$\n因此，定价公式变为：\n$$\nV_{0} = \\sup_{\\tau \\in [0,T]} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\max(\\exp(-r\\tau)S_{\\tau} - K \\exp(-rT), 0) \\right]\n$$\n让我们定义一个新过程 $H_{t} = \\exp(-rt)S_{t}$。该过程代表以货币市场账户 $B_{t} = \\exp(rt)$ 为单位的股票价格。使用伊藤引理，我们求得 $H_t$ 的动态过程：\n$$\n\\mathrm{d}H_{t} = \\mathrm{d}(\\exp(-rt)S_{t}) = -r\\exp(-rt)S_{t}\\mathrm{d}t + \\exp(-rt)\\mathrm{d}S_{t} = \\exp(-rt)(-rS_{t}\\mathrm{d}t + (rS_{t}\\mathrm{d}t + \\sigma S_{t}\\mathrm{d}W_{t})) = \\sigma H_{t}\\mathrm{d}W_{t}\n$$\n由于 $H_t$ 在 $\\mathbb{Q}$ 下的漂移为零，所以它是一个 $\\mathbb{Q}$-鞅。\n我们再定义一个常数 $K' = K \\exp(-rT)$。现在 $V_0$ 的定价公式可以写成 $H_t$ 和 $K'$ 的形式：\n$$\nV_{0} = \\sup_{\\tau \\in [0,T]} \\mathbb{E}^{\\mathbb{Q}}\\left[ \\max(H_{\\tau} - K', 0) \\right]\n$$\n问题简化为为过程 $Y_{t} = \\max(H_{t} - K', 0)$ 寻找最优停止时间。函数 $f(x) = \\max(x-K', 0)$ 是一个凸函数。由于 $H_t$ 是一个鞅，根据条件期望的琴生不等式，过程 $Y_{t} = f(H_{t})$ 是一个下鞅。对于任何 $tu$，我们有\n$$\nY_{t} = \\max(H_{t} - K', 0) = \\max(\\mathbb{E}^{\\mathbb{Q}}[H_{u}|\\mathcal{F}_t] - K', 0) \\le \\mathbb{E}^{\\mathbb{Q}}[\\max(H_{u} - K', 0)|\\mathcal{F}_t] = \\mathbb{E}^{\\mathbb{Q}}[Y_u|\\mathcal{F}_t]\n$$\n根据可选停止定理的一个推论，对于有界停止时间 $\\tau \\le T$ 的下鞅，我们有 $\\mathbb{E}^{\\mathbb{Q}}[Y_{\\tau}] \\le \\mathbb{E}^{\\mathbb{Q}}[Y_T]$。这意味着期望值随着停止时间的推迟而增加（或至少不减少）。因此，为了最大化期望值，我们应该选择最晚的可能停止时间，即 $\\tau=T$。\n\n因此，最优行权策略是持有该期权至到期日 $T$。这表明，尽管该期权具有美式特征，但其价值等同于一个在时间 $T$ 到期的欧式期权，该期权的收益为 $\\max(S_{T} - K \\exp(-r(T-T)), 0) = \\max(S_T - K, 0)$。\n价格 $V_0$ 为：\n$$\nV_{0} = \\mathbb{E}^{\\mathbb{Q}}\\left[ \\exp(-rT) \\max(S_T - K, 0) \\right]\n$$\n这正是具有执行价格 $K$ 和到期日 $T$ 的标准欧式看涨期权的定义。其价格由Black-Scholes-Merton公式给出。\n\n因此，该“延迟支付”美式看涨期权的价格与标准的欧式看涨期权完全相同。最终答案是标准的Black-Scholes公式。",
            "answer": "$$\n\\boxed{S_{0} N\\left(\\frac{\\ln\\left(\\frac{S_{0}}{K}\\right) + \\left(r + \\frac{\\sigma^{2}}{2}\\right)T}{\\sigma\\sqrt{T}}\\right) - K \\exp(-rT) N\\left(\\frac{\\ln\\left(\\frac{S_{0}}{K}\\right) + \\left(r - \\frac{\\sigma^{2}}{2}\\right)T}{\\sigma\\sqrt{T}}\\right)}\n$$"
        }
    ]
}