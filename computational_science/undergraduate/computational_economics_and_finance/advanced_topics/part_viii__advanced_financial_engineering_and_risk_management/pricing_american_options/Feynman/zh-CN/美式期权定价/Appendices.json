{
    "hands_on_practices": [
        {
            "introduction": "二叉树模型是为美式期权定价奠定基础的直观工具。本练习将超越基础模型，指导您构建一个考虑了季节性和存储成本等时变参数的二叉树。通过将这些现实世界中的商品特性建模为随时间变化的有效收益率 $q(t)$，您将学习如何调整和应用二叉树方法来解决更复杂的定价问题。",
            "id": "2420641",
            "problem": "你需要通过编程计算一份美式期权的价值，该期权标的为一种商品，其现货价格过程受季节性和仓储成本的影响。在风险中性测度下进行计算。商品现货价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 具有瞬时动态特性\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t,\n$$\n其中 $r$ 是连续复利的无风险利率，$\\sigma$ 是波动率，而 $q(t)$ 是一个随时间变化的有效收益率。该有效收益率结合了一个确定性的季节性成分和一个被视为负连续股息收益率的仓储成本：\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s.\n$$\n此处 $q_0$ 是基准便利收益率水平，$A$ 是季节性振幅，$\\phi$ 是相位（以弧度为单位），$s$ 是仓储成本率。所有利率均以小数形式表示年化率，时间 $t$ 以年为单位，$T$ 也以年为单位。\n\n对于数值定价，使用离散时间近似，采用 Cox-Ross-Rubinstein 可重组二叉树模型，该模型包含 $N$ 个等长的步长，$\\Delta t = T/N$。上涨和下跌乘数分别为\n$$\nu = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u},\n$$\n在对应于时间 $t_i = i \\Delta t$ 的第 $i$ 步（$i \\in \\{0,1,\\dots,N-1\\}$），单步风险中性概率为\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}.\n$$\n单步贴现因子为 $D = e^{-r \\Delta t}$。在时间 0 时的美式期权价值是上述模型下，所有在网格点 $\\{0, \\Delta t, 2 \\Delta t, \\dots, T\\}$ 上取值的停止时间 $\\tau$ 对应的贴现期望收益的上确界。对于看涨期权，收益函数为 $\\Pi(S) = \\max(S - K, 0)$；对于看跌期权，收益函数为 $\\Pi(S) = \\max(K - S, 0)$。\n\n请实现一个程序，为以下每个测试用例计算在时间 0 时的美式期权价值。所有输入均使用上述单位，其中 $\\phi$ 以弧度为单位。每个用例的输出必须是单个实数（浮点数）。每个结果必须四舍五入到六位小数。\n\n测试套件：\n- 用例 1（由于仓储成本，季节性有效收益率在负值附近波动，基准一年期到期）：\n  - $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, 期权类型：看跌期权。\n  - $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$。\n- 用例 2（极短到期日边界，单步树模型）：\n  - $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, 期权类型：看跌期权。\n  - $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$。\n- 用例 3（由于仓储成本和零无风险利率，有效收益率为负的美式看涨期权）：\n  - $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, 期权类型：看涨期权。\n  - $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$。\n- 用例 4（由于强便利收益率，有效收益率为正，一年期到期）：\n  - $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, 期权类型：看跌期权。\n  - $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个价格都四舍五入到六位小数并以十进制数形式打印（例如：$[12.345678,9.876543,0.123456,4.000000]$）。不应打印任何其他文本。",
            "solution": "问题在尝试解决前需要经过验证。\n\n### 步骤 1：提取已知条件\n\n现货价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 遵循以下随机微分方程：\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t\n$$\n其中 $r$ 是无风险利率，$\\sigma$ 是波动率，$q(t)$ 是随时间变化的有效收益率。\n\n有效收益率定义为：\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s\n$$\n其中 $q_0$ 是基准便利收益率，$A$ 是季节性振幅，$\\phi$ 是相位，$s$ 是仓储成本率。\n\n数值方法是一个 Cox-Ross-Rubinstein (CRR) 二叉树模型，在周期 $T$ 内有 $N$ 步。\n- 时间步长：$\\Delta t = T/N$。\n- 上涨/下跌乘数：$u = e^{\\sigma \\sqrt{\\Delta t}}$，$d = 1/u$。\n- 在时间 $t_i = i \\Delta t$ 时的单步风险中性概率：\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n$$\n- 单步贴现因子：$D = e^{-r \\Delta t}$。\n- 收益函数：看涨期权为 $\\Pi(S) = \\max(S - K, 0)$，看跌期权为 $\\Pi(S) = \\max(K - S, 0)$。\n\n测试用例：\n1.  **用例 1**：$S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, `期权类型：看跌期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$。\n2.  **用例 2**：$S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, `期权类型：看跌期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$。\n3.  **用例 3**：$S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, `期权类型：看涨期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$。\n4.  **用例 4**：$S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, `期权类型：看跌期权`。$q(t)$ 的参数：$q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准评估问题。\n- **科学依据**：所提供的模型是带有随时间变化漂移项的几何布朗运动的一个变体，这是量化金融中为商品价格建模的标准框架。包含季节性和仓储成本的有效收益率 $q(t)$ 的形式也是一种常规方法。数值定价方法，即二叉树模型，是计算金融中期权定价的基石。所有方程和概念都基于成熟的金融工程原理。\n- **良态的**：该问题是良态的。每个测试用例的输入都是完整的，并且足以使用指定的算法计算出唯一的数值结果。带有随时间变化股息率的 CRR 模型已知可以提供收敛到连续时间解的近似值。参数在合理范围内，确保风险中性概率 $p_i$ 满足无套利条件 $0 < p_i < 1$。\n- **客观性**：问题以精确、客观的数学和金融语言陈述。它提供了具体的测试用例并要求数值输出，没有主观解释的余地。\n\n该问题没有表现出任何科学上不健全、不完整、矛盾或模糊等缺陷。它是计算经济学和金融学中一个标准且定义明确的问题。\n\n### 步骤 3：结论与行动\n\n问题陈述是有效的。将提供一个解决方案。\n\n对具有指定动态特性的商品美式期权进行估值，是使用二叉晶格模型完成的。其基本原理是风险中性定价结合动态规划，以处理提前行权的特性。在任何时间点，美式期权的价格是其内在价值（来自立即行权）与持有价值（来自继续持有期权）中的最大值。\n\n该算法通过在可重组二叉树上进行反向归纳来执行。\n\n1.  **模型的离散化**：到期时间 $T$ 被划分为 $N$ 个长度为 $\\Delta t = T/N$ 的相等时间间隔。商品价格 $S$ 的状态空间被离散化为一个二叉晶格。在时间 $t_i = i\\Delta t$ 的节点 $(i, j)$ 处，经历了 $j$ 次上涨和 $i-j$ 次下跌后的价格由 $S_{i,j} = S_0 u^j d^{i-j}$ 给出。上涨和下跌乘数 $u$ 和 $d$ 由波动率 $\\sigma$ 和时间步长 $\\Delta t$ 根据 CRR 模型确定：\n    $$\n    u = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = e^{-\\sigma \\sqrt{\\Delta t}} = \\frac{1}{u}\n    $$\n    单步贴现因子是恒定的：$D = e^{-r \\Delta t}$。\n\n2.  **随时间变化的风险中性概率**：上涨的风险中性概率不是恒定的，而是由于随时间变化的有效收益率 $q(t_i)$ 而取决于时间步 $i$。对于每个时间步 $t_i = i \\Delta t$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$），有效收益率为：\n    $$\n    q(t_i) = q_0 + A \\cos(2\\pi t_i + \\phi) - s\n    $$\n    这为从 $t_i$ 到 $t_{i+1}$ 的转移提供了随步长变化的风险中性概率 $p_i$：\n    $$\n    p_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n    $$\n\n3.  **反向归纳算法**：\n    - **在到期日（时间 $T$）的初始化**：在最终时间步 $N$，每个（共 $N+1$ 个）节点的期权价值就是其由收益函数给出的内在价值。令看涨期权 $\\omega = 1$，看跌期权 $\\omega = -1$。在节点 $(N,j)$ 的价值 $V_{N,j}$ 为：\n      $$\n      V_{N,j} = \\max(\\omega \\cdot (S_{N,j} - K), 0) \\quad \\text{for } j = 0, 1, \\dots, N\n      $$\n      这些值存储在一个大小为 $N+1$ 的一维数组中。\n\n    - **迭代**：算法从时间步 $i = N-1$ 向后迭代至 0。在每一步 $i$，它计算所有节点 $j \\in \\{0, 1, \\dots, i\\}$ 的期权价值 $V_{i,j}$。\n      - 对于每个节点 $(i,j)$，持有价值 $C_{i,j}$ 是下一时间步期权的贴现期望值，使用风险中性概率 $p_i$ 计算：\n        $$\n        C_{i,j} = D \\cdot [p_i V_{i+1, j+1} + (1-p_i) V_{i+1, j}]\n        $$\n      - 内在价值 $I_{i,j}$ 是在节点 $(i,j)$ 行权时的价值：\n        $$\n        I_{i,j} = \\max(\\omega \\cdot (S_{i,j} - K), 0)\n        $$\n      - 在此节点的美式期权价值是这两个价值中的最大值，反映了最优决策：\n        $$\n        V_{i,j} = \\max(I_{i,j}, C_{i,j})\n        $$\n      在实施中，一个表示第 $i+1$ 步期权价值的一维数组可以被就地更新，以存储第 $i$ 步的价值。\n\n    - **最终价值**：该过程在步骤 $i=0$ 处终止。单个值 $V_{0,0}$ 即为时间 $t=0$ 时的美式期权价格。\n\n对每个测试用例实施此程序，以计算所需的期权价格。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_american_option(S0, K, r, sigma, T, N, option_type, q_params):\n    \"\"\"\n    Computes the value of an American option on a commodity with seasonality.\n\n    Args:\n        S0 (float): Initial spot price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of steps in the binomial tree.\n        option_type (str): 'call' or 'put'.\n        q_params (dict): Parameters for the effective yield q(t).\n                         Keys: 'q0', 'A', 'phi', 's'.\n\n    Returns:\n        float: The price of the American option at time 0.\n    \"\"\"\n    # Unpack parameters for q(t)\n    q0 = q_params['q0']\n    A = q_params['A']\n    phi = q_params['phi']\n    s = q_params['s']\n\n    # Step 1: Discretization and constant parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    discount_factor = np.exp(-r * dt)\n\n    # Step 2: Initialize option values at maturity (time T)\n    # Omega = 1 for call, -1 for put\n    omega = 1.0 if option_type == 'call' else -1.0\n    \n    # Create a vector for option values. This will be updated at each step.\n    # It stores values at step i+1, and is used to compute values at step i.\n    V = np.zeros(N + 1)\n    \n    # Asset prices at maturity\n    S_T = np.array([(S0 * u**j * d**(N - j)) for j in range(N + 1)])\n    \n    # Option payoff at maturity\n    V[:] = np.maximum(omega * (S_T - K), 0)\n\n    # Step 3: Backward induction\n    for i in range(N - 1, -1, -1):\n        # Calculate time-dependent risk-neutral probability for this step\n        ti = i * dt\n        q_ti = q0 + A * np.cos(2 * np.pi * ti + phi) - s\n        \n        # Risk-neutral probability for transition from t_i to t_{i+1}\n        p_i = (np.exp((r - q_ti) * dt) - d) / (u - d)\n        \n        # Stability check, should hold for reasonable parameters\n        if not (0 < p_i < 1):\n             # This indicates an arbitrage opportunity or unstable parameters.\n             # The problem parameters are well-behaved, so this is a safeguard.\n             # For some extreme parameters, one might need to adjust u,d,p.\n             # but here it is not necessary.\n             pass\n\n        # Calculate option values at time step i\n        for j in range(i + 1):\n            # Continuation value (if not exercised)\n            continuation_value = discount_factor * (p_i * V[j+1] + (1 - p_i) * V[j])\n            \n            # Stock price at this node (i, j)\n            S_ij = S0 * u**j * d**(i - j)\n            \n            # Intrinsic value (if exercised now)\n            intrinsic_value = np.maximum(omega * (S_ij - K), 0)\n            \n            # American option value is the max of exercising or holding\n            V[j] = np.maximum(intrinsic_value, continuation_value)\n            \n    # The final result is the option value at the root of the tree (t=0)\n    return round(V[0], 6)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'S0': 100.0, 'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.03, 'phi': 0.0, 's': 0.02}},\n        # Case 2\n        {'S0': 80.0, 'K': 100.0, 'r': 0.01, 'sigma': 0.25, 'T': 1/365, 'N': 1, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.02, 'phi': np.pi/2, 's': 0.01}},\n        # Case 3\n        {'S0': 50.0, 'K': 40.0, 'r': 0.0, 'sigma': 0.3, 'T': 0.5, 'N': 300, 'option_type': 'call',\n         'q_params': {'q0': 0.0, 'A': 0.0, 'phi': 0.0, 's': 0.05}},\n        # Case 4\n        {'S0': 100.0, 'K': 90.0, 'r': 0.02, 'sigma': 0.25, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.07, 'A': 0.02, 'phi': np.pi, 's': 0.02}},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = calculate_american_option(\n            S0=case['S0'],\n            K=case['K'],\n            r=case['r'],\n            sigma=case['sigma'],\n            T=case['T'],\n            N=case['N'],\n            option_type=case['option_type'],\n            q_params=case['q_params']\n        )\n        results.append(price)\n    \n    # Format the final output according to specification\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了无套利定价的视角，期权的行权决策也可以从经济学中的效用最大化角度来理解。本练习将引导您从一个具有恒定绝对风险规避（CARA）指数效用函数的风险规避代理人的角度出发，解决一个最优停时问题。通过在真实世界概率 $p$ 下进行动态规划，您将确定最优的行权策略并计算其确定性等价物，从而将金融工程与微观经济决策理论联系起来。",
            "id": "2420683",
            "problem": "给定一个离散时间金融市场，其中一位具有指数效用的代理人持有一份美式看跌期权。时间被划分为 $N$ 步，日期为 $t \\in \\{0,1,\\dots,N\\}$，总期限为 $T>0$。令 $\\Delta t = T/N$。标的资产价格过程 $\\{S_t\\}$ 按乘性随机游走演变：\n$$\nS_{t+1} = S_t \\cdot \\begin{cases}\nu & \\text{概率为 } p,\\\\\nd & \\text{概率为 } 1-p,\n\\end{cases}\n$$\n其中 $u = \\exp(\\sigma \\sqrt{\\Delta t})$，$d = 1/u$，且 $p = \\dfrac{\\exp(\\mu \\Delta t) - d}{u - d}$。连续复利无风险利率为 $r$，因此每步的总回报率为 $R = \\exp(r \\Delta t)$。该代理人持有一份执行价格为 $K$ 的美式看跌期权；在日期 $t$ 的即时行权收益为 $P_t = \\max(K - S_t, 0)$。如果在日期 $t$ 行权，收益 $P_t$ 将存入无风险资产直至时间 $T$，产生的期末存款价值为 $R^{N-t} P_t$。代理人对期末财富 $W_T$ 的效用是具有恒定绝对风险规避 (CARA) 的指数形式：$U(W_T) = -\\exp(-\\gamma W_T)$，其中 $\\gamma > 0$ 是风险规避系数。假设初始财富 $W_0 = 0$，因此 $W_T$ 等于仅由期权行权决策产生的期末价值。\n\n定义代理人的目标为选择一个适应于价格过程的停止时间 $\\tau \\in \\{0,1,\\dots,N\\}$，以最大化期末财富的期望效用：\n$$\n\\sup_{\\tau \\in \\{0,1,\\dots,N\\}} \\mathbb{E}\\left[ U\\left( R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\right].\n$$\n\n您的任务是编写一个程序，对于每个指定的参数集，计算以下两个输出：\n- 效用最优行权策略在日期 $0$ 的现值确定性等价值，\n$$\n\\text{CE}_0 = \\frac{1}{R^N} \\cdot \\left( -\\frac{1}{\\gamma} \\ln \\left( \\inf_{\\tau \\in \\{0,1,\\dots,N\\}} \\mathbb{E}\\left[ \\exp\\left( -\\gamma \\, R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\right] \\right) \\right),\n$$\n以与 $S$ 和 $K$ 相同的货币单位表示，并报告为一个四舍五入到 $6$ 位小数的浮点数。\n- 一个布尔值，指示在相同的效用标准下，是否在 $t=0$ 时立即行权是最优选择。\n\n使用以下测试套件。在所有情况下，所有利率均以小数（而非百分比）表示，所有输出必须使用与 $S$ 和 $K$ 一致的货币单位。\n\n测试用例，每个元组为 $(S_0, K, r, \\mu, \\sigma, T, N, \\gamma)$：\n- 用例 1：$(100, 100, 0.02, 0.06, 0.2, 1, 50, 1)$。\n- 用例 2：$(40, 100, 0.02, 0.06, 0.2, 1, 50, 1)$。\n- 用例 3：$(100, 100, 0.02, 0.06, 0.2, 1, 50, 10^{-6})$。\n- 用例 4：$(90, 100, 0.10, 0.00, 0.25, 1, 50, 5)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[\\text{CE}_0^{(1)}, \\text{ExNow}^{(1)}, \\text{CE}_0^{(2)}, \\text{ExNow}^{(2)}, \\text{CE}_0^{(3)}, \\text{ExNow}^{(3)}, \\text{CE}_0^{(4)}, \\text{ExNow}^{(4)}],\n$$\n其中 $\\text{CE}_0^{(i)}$ 是用例 $i$ 在日期 $0$ 的确定性等价值（四舍五入到 $6$ 位小数），而 $\\text{ExNow}^{(i)}$ 是一个布尔值，如果对于用例 $i$ 在 $t=0$ 时立即行权是最优的，则为 $\\text{True}$，否则为 $\\text{False}$。输出必须在一行中包含恰好 $8$ 个条目，格式如上指定，并且不包含任何其他内容。",
            "solution": "提出的问题是一个离散时间最优停止问题。代理人的目标是为美式看跌期权选择一个行权时间 $\\tau$，以最大化期末财富的期望效用。效用函数为指数形式 $U(W_T) = -\\exp(-\\gamma W_T)$，这意味着恒定绝对风险规避 (CARA)。该问题可以通过动态规划，从期权到期日开始向后递推求解。\n\n让我们定义一个价值函数 $J(t, S_t)$，它表示在时间 $t$ 股票价格为 $S_t$ 的条件下，$\\exp(-\\gamma W_T)$ 的最小期望值。最大化期望效用 $\\mathbb{E}[U(W_T)]$ 等价于最小化 $\\mathbb{E}[\\exp(-\\gamma W_T)]$，因为 $U(W_T)$ 是 $\\exp(-\\gamma W_T)$ 的一个严格递减的单调变换。因此，价值函数定义为：\n$$\nJ(t, S_t) = \\inf_{\\tau \\in \\{t, \\dots, N\\}} \\mathbb{E} \\left[ \\exp\\left( -\\gamma R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\, \\Big| \\, S_t \\right]\n$$\n其中 $\\mathbb{E}[\\cdot|S_t]$ 表示在时间 $t$ 的信息下的条件期望。解是通过在每个时间步应用最优性原理（贝尔曼方程）来找到的。\n\n在任何时间 $t < N$ 且对于给定的股票价格 $S_t$，代理人有两个选择：立即行使期权或继续持有它。价值函数是与这两个行动相关联的价值的最小值。\n$$\nJ(t, S_t) = \\min\\left( J_{\\text{行权}}(t, S_t), J_{\\text{持有}}(t, S_t) \\right)\n$$\n\n立即行权的价值 $J_{\\text{行权}}(t, S_t)$，是通过行使期权获得收益 $P_t = \\max(K-S_t, 0)$ 得到的。然后将这笔金额以无风险利率投资，直到终止日期 $T$。期末财富为 $W_T = R^{N-t} P_t$。由于一旦做出行权决定，这个结果就是确定的，因此其价值为：\n$$\nJ_{\\text{行权}}(t, S_t) = \\exp\\left( -\\gamma R^{N-t} \\max(K - S_t, 0) \\right)\n$$\n\n持有期权的价值 $J_{\\text{持有}}(t, S_t)$，是下一个时间步 $t+1$ 决策问题的期望值。标的资产价格 $S_t$ 可以以物理概率 $p$ 移动到 $S_{t+1}^u = S_t \\cdot u$，或以概率 $1-p$ 移动到 $S_{t+1}^d = S_t \\cdot d$。因此，持有价值为：\n$$\nJ_{\\text{持有}}(t, S_t) = \\mathbb{E} \\left[ J(t+1, S_{t+1}) \\,|\\, S_t \\right] = p \\cdot J(t+1, S_t u) + (1-p) \\cdot J(t+1, S_t d)\n$$\n概率 $p$ 和 $1-p$ 是真实世界（或物理）概率，由资产的期望回报 $\\mu$ 推导得出，这适用于效用最大化问题。\n\n该问题通过在代表股票价格可能演变的二叉格上进行向后归纳法来求解。\n时间 $t$ 的状态可由上涨次数 $j \\in \\{0, 1, \\dots, t\\}$ 唯一确定，其对应的股票价格为 $S_{t, j} = S_0 u^j d^{t-j}$。\n\n1.  **终端条件 (在 $t=N$ 时)**：在到期时，如果期权是价内期权，则必须行权。没有“持有”的选择。期末财富就是即时收益 $\\max(K-S_N, 0)$，因为 $R^{N-N}=R^0=1$。因此，对于每个可能的最终股票价格 $S_{N, j} = S_0 u^j d^{N-j}$，其中 $j \\in \\{0, 1, \\dots, N\\}$：\n    $$\n    J(N, S_{N,j}) = \\exp\\left( -\\gamma \\max(K - S_{N,j}, 0) \\right)\n    $$\n\n2.  **向后归纳 (对于 $t=N-1, \\dots, 0$)**：对于每个时间步 $t$ 和每个对应价格 $S_{t,j}$ 的状态 $j \\in \\{0, 1, \\dots, t\\}$：\n    *   计算行权价值 $J_{\\text{行权}}(t, S_{t,j})$。\n    *   计算持有价值 $J_{\\text{持有}}(t, S_{t,j}) = p \\cdot J(t+1, S_{t+1, j+1}) + (1-p) \\cdot J(t+1, S_{t+1, j})$。\n    *   此节点上的价值为 $J(t, S_{t,j}) = \\min\\left(J_{\\text{行权}}(t, S_{t,j}), J_{\\text{持有}}(t, S_{t,j})\\right)$。\n\n这个过程一直持续到时间 $t=0$，得出价值 $J(0, S_0)$。这是最小的期望转换后期末财富。\n最优行权策略在每个节点上被隐式地确定：如果 $J_{\\text{行权}} \\le J_{\\text{持有}}$，则行权。因此，关于是否在 $t=0$ 时立即行权的布尔值是通过比较 $J_{\\text{行权}}(0, S_0)$ 和 $J_{\\text{持有}}(0, S_0)$ 来确定的。\n\n最后，我们计算现值确定性等价值 $\\text{CE}_0$。确定性等价期末财富 $\\text{CE}_T$ 是指能够提供与最优（但不确定）行权策略相同效用的确定财富量。它由 $U(\\text{CE}_T) = \\mathbb{E}[U(W_T^*)]$ 定义，其中 $W_T^*$ 是最优期末财富。\n$$\n-\\exp(-\\gamma \\cdot \\text{CE}_T) = \\sup_{\\tau} \\mathbb{E} \\left[ -\\exp\\left(-\\gamma R^{N-\\tau}\\max(K-S_\\tau, 0)\\right) \\right] = -J(0, S_0)\n$$\n求解 $\\text{CE}_T$，我们得到：\n$$\n\\text{CE}_T = -\\frac{1}{\\gamma} \\ln\\left( J(0, S_0) \\right)\n$$\n该问题要求的是此确定性等价值的现值，即以无风险利率从时间 $T$ 折现到时间 $0$。总折现因子为 $R^N = (\\exp(r \\Delta t))^N = \\exp(r T)$。\n$$\n\\text{CE}_0 = \\frac{\\text{CE}_T}{R^N} = \\frac{1}{R^N} \\left( -\\frac{1}{\\gamma} \\ln\\left( J(0, S_0) \\right) \\right)\n$$\n这个公式提供了最终所需的货币价值。该算法对每个参数集计算 $J(0, S_0)$、即时行权决策以及 $\\text{CE}_0$。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef price_american_put_fdm(K, r, sigma, T, S0, M, S_min_val, S_max_factor, N):\n    \"\"\"\n    Computes the American put option price using an explicit finite difference method.\n\n    Args:\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility of the underlying asset.\n        T (float): Time to maturity.\n        S0 (float): Initial stock price.\n        M (int): Number of spatial intervals.\n        S_min_val (float): Minimum value for the price domain S.\n        S_max_factor (float): Factor to determine S_max = S_max_factor * K.\n        N (int): Number of time steps.\n\n    Returns:\n        float: The price of the American put option at S0 and t=0.\n    \"\"\"\n    # 1. Setup grid\n    S_max = S_max_factor * K\n    x_min, x_max = np.log(S_min_val), np.log(S_max)\n    dx = (x_max - x_min) / M\n    dt = T / N\n\n    x_grid = np.linspace(x_min, x_max, M + 1)\n    S_grid = np.exp(x_grid)\n\n    # 2. Initial condition at maturity T (n=0)\n    V = np.maximum(K - S_grid, 0)\n\n    # 3. FDM coefficients\n    nu = r - 0.5 * sigma**2\n    \n    # Coefficients for the explicit scheme u_j^{n+1} = a*u_{j-1}^n + b*u_j^n + c*u_{j+1}^n\n    # Note: we are calculating V at previous time step (n+1 in backward time) from current (n)\n    a = dt * (0.5 * sigma**2 / dx**2 - nu / (2 * dx))\n    b = 1 - dt * (sigma**2 / dx**2 + r)\n    c = dt * (0.5 * sigma**2 / dx**2 + nu / (2 * dx))\n\n    # 4. Time-stepping loop (from T back to 0)\n    for _ in range(N):\n        V_old = V.copy()\n        \n        # Update interior points using the PDE\n        V[1:-1] = a * V_old[:-2] + b * V_old[1:-1] + c * V_old[2:]\n\n        # Apply boundary conditions\n        V[0] = K  # V(S_min, t) = K\n        V[-1] = 0 # V(S_max, t) = 0\n        \n        # Apply American option early exercise constraint\n        payoff = np.maximum(K - S_grid, 0)\n        V = np.maximum(V, payoff)\n\n    # 5. Interpolate to find price at S0\n    price_at_t0 = np.interp(S0, S_grid, V)\n    \n    return price_at_t0\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite.\n    \"\"\"\n    # Common settings from the problem statement\n    M = 400\n    S_min_val = 1e-4\n    S_max_factor = 5.0\n    \n    test_cases = [\n        # Test 1: Happy-path stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'stable'},\n        # Test 2: Violated stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'unstable'},\n        # Test 3: Near-boundary asset price case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 1.0, 'case_type': 'stable'}\n    ]\n\n    results = []\n\n    # Calculate stability parameters (only depends on K, sigma, M) for the first two tests\n    params1 = test_cases[0]\n    K1, sigma1, T1 = params1['K'], params1['sigma'], params1['T']\n    \n    S_max1 = S_max_factor * K1\n    x_min1 = np.log(S_min_val)\n    x_max1 = np.log(S_max1)\n    dx1 = (x_max1 - x_min1) / M\n    \n    # Diffusion-based stability bound B\n    B = dx1**2 / sigma1**2\n    \n    # Time step counts\n    N_stable = int(math.ceil(T1 / (0.9 * B)))\n    N_unstable = int(max(1, math.floor(T1 / (1.1 * B))))\n\n    # --- Test Case 1 ---\n    price1 = price_american_put_fdm(\n        K=params1['K'], r=params1['r'], sigma=params1['sigma'], T=params1['T'], S0=params1['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price1)\n    \n    # --- Test Case 2 ---\n    params2 = test_cases[1]\n    price2 = price_american_put_fdm(\n        K=params2['K'], r=params2['r'], sigma=params2['sigma'], T=params2['T'], S0=params2['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_unstable\n    )\n    results.append(price2)\n    \n    dt_unstable = params2['T'] / N_unstable\n    violation_indicator = 1 if dt_unstable > B else 0\n    results.append(violation_indicator)\n\n    # --- Test Case 3 ---\n    params3 = test_cases[2]\n    # Reuse N_stable as per problem description\n    price3 = price_american_put_fdm(\n        K=params3['K'], r=params3['r'], sigma=params3['sigma'], T=params3['T'], S0=params3['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price3)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了无套利定价的视角，期权的行权决策也可以从经济学中的效用最大化角度来理解。本练习将引导您从一个具有恒定绝对风险规避（CARA）指数效用函数的风险规避代理人的角度出发，解决一个最优停时问题。通过在真实世界概率 $p$ 下进行动态规划，您将确定最优的行权策略并计算其确定性等价物，从而将金融工程与微观经济决策理论联系起来。",
            "id": "2420671",
            "problem": "给定一个离散时间金融市场，其中一位具有指数效用的代理人持有一份美式看跌期权。时间被划分为 $N$ 步，日期为 $t \\in \\{0,1,\\dots,N\\}$，总期限为 $T>0$。令 $\\Delta t = T/N$。标的资产价格过程 $\\{S_t\\}$ 按乘性随机游走演变：\n$$\nS_{t+1} = S_t \\cdot \\begin{cases}\nu & \\text{概率为 } p,\\\\\nd & \\text{概率为 } 1-p,\n\\end{cases}\n$$\n其中 $u = \\exp(\\sigma \\sqrt{\\Delta t})$，$d = 1/u$，且 $p = \\dfrac{\\exp(\\mu \\Delta t) - d}{u - d}$。连续复利无风险利率为 $r$，因此每步的总回报率为 $R = \\exp(r \\Delta t)$。该代理人持有一份执行价格为 $K$ 的美式看跌期权；在日期 $t$ 的即时行权收益为 $P_t = \\max(K - S_t, 0)$。如果在日期 $t$ 行权，收益 $P_t$ 将存入无风险资产直至时间 $T$，产生的期末存款价值为 $R^{N-t} P_t$。代理人对期末财富 $W_T$ 的效用是具有恒定绝对风险规避 (CARA) 的指数形式：$U(W_T) = -\\exp(-\\gamma W_T)$，其中 $\\gamma > 0$ 是风险规避系数。假设初始财富 $W_0 = 0$，因此 $W_T$ 等于仅由期权行权决策产生的期末价值。\n\n定义代理人的目标为选择一个适应于价格过程的停止时间 $\\tau \\in \\{0,1,\\dots,N\\}$，以最大化期末财富的期望效用：\n$$\n\\sup_{\\tau \\in \\{0,1,\\dots,N\\}} \\mathbb{E}\\left[ U\\left( R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\right].\n$$\n\n您的任务是编写一个程序，对于每个指定的参数集，计算以下两个输出：\n- 效用最优行权策略在日期 $0$ 的现值确定性等价值，\n$$\n\\text{CE}_0 = \\frac{1}{R^N} \\cdot \\left( -\\frac{1}{\\gamma} \\ln \\left( \\inf_{\\tau \\in \\{0,1,\\dots,N\\}} \\mathbb{E}\\left[ \\exp\\left( -\\gamma \\, R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\right] \\right) \\right),\n$$\n以与 $S$ 和 $K$ 相同的货币单位表示，并报告为一个四舍五入到 $6$ 位小数的浮点数。\n- 一个布尔值，指示在相同的效用标准下，是否在 $t=0$ 时立即行权是最优选择。\n\n使用以下测试套件。在所有情况下，所有利率均以小数（而非百分比）表示，所有输出必须使用与 $S$ 和 $K$ 一致的货币单位。\n\n测试用例，每个元组为 $(S_0, K, r, \\mu, \\sigma, T, N, \\gamma)$：\n- 用例 1：$(100, 100, 0.02, 0.06, 0.2, 1, 50, 1)$。\n- 用例 2：$(40, 100, 0.02, 0.06, 0.2, 1, 50, 1)$。\n- 用例 3：$(100, 100, 0.02, 0.06, 0.2, 1, 50, 10^{-6})$。\n- 用例 4：$(90, 100, 0.10, 0.00, 0.25, 1, 50, 5)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[\\text{CE}_0^{(1)}, \\text{ExNow}^{(1)}, \\text{CE}_0^{(2)}, \\text{ExNow}^{(2)}, \\text{CE}_0^{(3)}, \\text{ExNow}^{(3)}, \\text{CE}_0^{(4)}, \\text{ExNow}^{(4)}],\n$$\n其中 $\\text{CE}_0^{(i)}$ 是用例 $i$ 在日期 $0$ 的确定性等价值（四舍五入到 $6$ 位小数），而 $\\text{ExNow}^{(i)}$ 是一个布尔值，如果对于用例 $i$ 在 $t=0$ 时立即行权是最优的，则为 $\\text{True}$，否则为 $\\text{False}$。输出必须在一行中包含恰好 $8$ 个条目，格式如上指定，并且不包含任何其他内容。",
            "solution": "提出的问题是一个离散时间最优停止问题。代理人的目标是为美式看跌期权选择一个行权时间 $\\tau$，以最大化期末财富的期望效用。效用函数为指数形式 $U(W_T) = -\\exp(-\\gamma W_T)$，这意味着恒定绝对风险规避 (CARA)。该问题可以通过动态规划，从期权到期日开始向后递推求解。\n\n让我们定义一个价值函数 $J(t, S_t)$，它表示在时间 $t$ 股票价格为 $S_t$ 的条件下，$\\exp(-\\gamma W_T)$ 的最小期望值。最大化期望效用 $\\mathbb{E}[U(W_T)]$ 等价于最小化 $\\mathbb{E}[\\exp(-\\gamma W_T)]$，因为 $U(W_T)$ 是 $\\exp(-\\gamma W_T)$ 的一个严格递减的单调变换。因此，价值函数定义为：\n$$\nJ(t, S_t) = \\inf_{\\tau \\in \\{t, \\dots, N\\}} \\mathbb{E} \\left[ \\exp\\left( -\\gamma R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\, \\Big| \\, S_t \\right]\n$$\n其中 $\\mathbb{E}[\\cdot|S_t]$ 表示在时间 $t$ 的信息下的条件期望。解是通过在每个时间步应用最优性原理（贝尔曼方程）来找到的。\n\n在任何时间 $t < N$ 且对于给定的股票价格 $S_t$，代理人有两个选择：立即行使期权或继续持有它。价值函数是与这两个行动相关联的价值的最小值。\n$$\nJ(t, S_t) = \\min\\left( J_{\\text{行权}}(t, S_t), J_{\\text{持有}}(t, S_t) \\right)\n$$\n\n立即行权的价值 $J_{\\text{行权}}(t, S_t)$，是通过行使期权获得收益 $P_t = \\max(K-S_t, 0)$ 得到的。然后将这笔金额以无风险利率投资，直到终止日期 $T$。期末财富为 $W_T = R^{N-t} P_t$。由于一旦做出行权决定，这个结果就是确定的，因此其价值为：\n$$\nJ_{\\text{行权}}(t, S_t) = \\exp\\left( -\\gamma R^{N-t} \\max(K - S_t, 0) \\right)\n$$\n\n持有期权的价值 $J_{\\text{持有}}(t, S_t)$，是下一个时间步 $t+1$ 决策问题的期望值。标的资产价格 $S_t$ 可以以物理概率 $p$ 移动到 $S_{t+1}^u = S_t \\cdot u$，或以概率 $1-p$ 移动到 $S_{t+1}^d = S_t \\cdot d$。因此，持有价值为：\n$$\nJ_{\\text{持有}}(t, S_t) = \\mathbb{E} \\left[ J(t+1, S_{t+1}) \\,|\\, S_t \\right] = p \\cdot J(t+1, S_t u) + (1-p) \\cdot J(t+1, S_t d)\n$$\n概率 $p$ 和 $1-p$ 是真实世界（或物理）概率，由资产的期望回报 $\\mu$ 推导得出，这适用于效用最大化问题。\n\n该问题通过在代表股票价格可能演变的二叉格上进行向后归纳法来求解。\n时间 $t$ 的状态可由上涨次数 $j \\in \\{0, 1, \\dots, t\\}$ 唯一确定，其对应的股票价格为 $S_{t, j} = S_0 u^j d^{t-j}$。\n\n1.  **终端条件 (在 $t=N$ 时)**：在到期时，如果期权是价内期权，则必须行权。没有“持有”的选择。期末财富就是即时收益 $\\max(K-S_N, 0)$，因为 $R^{N-N}=R^0=1$。因此，对于每个可能的最终股票价格 $S_{N, j} = S_0 u^j d^{N-j}$，其中 $j \\in \\{0, 1, \\dots, N\\}$：\n    $$\n    J(N, S_{N,j}) = \\exp\\left( -\\gamma \\max(K - S_{N,j}, 0) \\right)\n    $$\n\n2.  **向后归纳 (对于 $t=N-1, \\dots, 0$)**：对于每个时间步 $t$ 和每个对应价格 $S_{t,j}$ 的状态 $j \\in \\{0, 1, \\dots, t\\}$：\n    *   计算行权价值 $J_{\\text{行权}}(t, S_{t,j})$。\n    *   计算持有价值 $J_{\\text{持有}}(t, S_{t,j}) = p \\cdot J(t+1, S_{t+1, j+1}) + (1-p) \\cdot J(t+1, S_{t+1, j})$。\n    *   此节点上的价值为 $J(t, S_{t,j}) = \\min\\left(J_{\\text{行权}}(t, S_{t,j}), J_{\\text{持有}}(t, S_{t,j})\\right)$。\n\n这个过程一直持续到时间 $t=0$，得出价值 $J(0, S_0)$。这是最小的期望转换后期末财富。\n最优行权策略在每个节点上被隐式地确定：如果 $J_{\\text{行权}} \\le J_{\\text{持有}}$，则行权。因此，关于是否在 $t=0$ 时立即行权的布尔值是通过比较 $J_{\\text{行权}}(0, S_0)$ 和 $J_{\\text{持有}}(0, S_0)$ 来确定的。\n\n最后，我们计算现值确定性等价值 $\\text{CE}_0$。确定性等价期末财富 $\\text{CE}_T$ 是指能够提供与最优（但不确定）行权策略相同效用的确定财富量。它由 $U(\\text{CE}_T) = \\mathbb{E}[U(W_T^*)]$ 定义，其中 $W_T^*$ 是最优期末财富。\n$$\n-\\exp(-\\gamma \\cdot \\text{CE}_T) = \\sup_{\\tau} \\mathbb{E} \\left[ -\\exp\\left(-\\gamma R^{N-\\tau}\\max(K-S_\\tau, 0)\\right) \\right] = -J(0, S_0)\n$$\n求解 $\\text{CE}_T$，我们得到：\n$$\n\\text{CE}_T = -\\frac{1}{\\gamma} \\ln\\left( J(0, S_0) \\right)\n$$\n该问题要求的是此确定性等价值的现值，即以无风险利率从时间 $T$ 折现到时间 $0$。总折现因子为 $R^N = (\\exp(r \\Delta t))^N = \\exp(r T)$。\n$$\n\\text{CE}_0 = \\frac{\\text{CE}_T}{R^N} = \\frac{1}{R^N} \\left( -\\frac{1}{\\gamma} \\ln\\left( J(0, S_0) \\right) \\right)\n$$\n这个公式提供了最终所需的货币价值。该算法对每个参数集计算 $J(0, S_0)$、即时行权决策以及 $\\text{CE}_0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the certainty equivalent and optimal immediate exercise decision\n    for an American put option under exponential utility.\n    \"\"\"\n\n    test_cases = [\n        # (S0, K, r, mu, sigma, T, N, gamma)\n        (100.0, 100.0, 0.02, 0.06, 0.2, 1.0, 50, 1.0),\n        (40.0, 100.0, 0.02, 0.06, 0.2, 1.0, 50, 1.0),\n        (100.0, 100.0, 0.02, 0.06, 0.2, 1.0, 50, 1e-6),\n        (90.0, 100.0, 0.10, 0.00, 0.25, 1.0, 50, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        ce_0, ex_now = calculate_utility_optimal_policy(*case)\n        results.append(f\"{ce_0:.6f}\")\n        results.append(str(ex_now))\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_utility_optimal_policy(S0, K, r, mu, sigma, T, N, gamma):\n    \"\"\"\n    Calculates the present-value certainty equivalent and immediate exercise decision\n    for an American put option with exponential utility via dynamic programming.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (continuously compounded).\n        mu (float): Expected return of the stock (continuously compounded).\n        sigma (float): Volatility of the stock.\n        T (float): Time to maturity in years.\n        N (int): Number of time steps in the binomial model.\n        gamma (float): Coefficient of absolute risk aversion.\n\n    Returns:\n        tuple: A tuple containing:\n            - ce_0 (float): The present-value certainty equivalent at time 0.\n            - ex_now (bool): True if immediate exercise at t=0 is optimal, False otherwise.\n    \"\"\"\n    # 1. Calculate model parameters\n    delta_t = T / N\n    u = np.exp(sigma * np.sqrt(delta_t))\n    d = 1.0 / u\n    R = np.exp(r * delta_t)  # Gross risk-free return per step\n    p = (np.exp(mu * delta_t) - d) / (u - d) # Physical probability\n\n    # 2. Initialize values at terminal time N\n    # J_next stores the values of the function J(t+1, S)\n    # The size is N+1 for the N+1 possible stock prices at time N.\n    J_next = np.zeros(N + 1)\n    for j in range(N + 1):\n        S_N = S0 * (u**j) * (d**(N - j))\n        payoff = max(K - S_N, 0)\n        J_next[j] = np.exp(-gamma * payoff)\n\n    # Variables to store the decision at t=0\n    ex_now = False\n\n    # 3. Backward induction from t=N-1 to t=0\n    for t in range(N - 1, -1, -1):\n        # J_curr stores the values of J(t, S)\n        # There are t+1 possible nodes at time t.\n        J_curr = np.zeros(t + 1)\n        for j in range(t + 1):\n            S_t = S0 * (u**j) * (d**(t - j))\n            \n            # Calculate exercise value\n            payoff_t = max(K - S_t, 0)\n            terminal_value_of_payoff = payoff_t * (R**(N - t))\n            J_exercise = np.exp(-gamma * terminal_value_of_payoff)\n            \n            # Calculate continuation (hold) value\n            # Next states from (t,j) are (t+1, j+1) [up] and (t+1, j) [down]\n            J_hold = p * J_next[j + 1] + (1 - p) * J_next[j]\n\n            # Bellman equation: take the minimum\n            J_curr[j] = min(J_exercise, J_hold)\n\n            # At t=0, determine if immediate exercise is optimal\n            if t == 0:\n                # Standard convention: exercise if equal\n                if J_exercise <= J_hold:\n                    ex_now = True\n\n        J_next = J_curr\n\n    # 4. Calculate final results\n    J_0_S0 = J_next[0]\n    \n    # Handle the case where J_0_S0 is extremely close to 0, which can lead to -inf\n    if J_0_S0 <= 0:\n      # This corresponds to infinite utility, so CE is infinite.\n      # Highly unlikely with finite payoffs, but a safeguard.\n      ce_T = float('inf')\n    else:\n      ce_T = -np.log(J_0_S0) / gamma\n    \n    # Discount to present value\n    total_discount_factor = np.exp(r * T)\n    ce_0 = ce_T / total_discount_factor\n    \n    return ce_0, ex_now\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}