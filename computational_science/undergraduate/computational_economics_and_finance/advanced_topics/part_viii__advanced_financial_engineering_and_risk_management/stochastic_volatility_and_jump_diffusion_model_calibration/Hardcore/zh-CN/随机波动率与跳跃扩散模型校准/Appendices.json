{
    "hands_on_practices": [
        {
            "introduction": "我们将从一个简化场景开始动手实践，旨在分离出金融时间序列中离散跳跃的影响。第一个练习  使用一个简化的仿射期限结构模型，演示如何从观测数据中估计跳跃过程的基本参数——其强度 $\\lambda$ 和幅度 $\\mu_J$。通过这个简化的场景，你将为理解如何对突发市场冲击进行建模建立起基础直觉，为后续更复杂的校准挑战做好准备。",
            "id": "2370067",
            "problem": "给定一个风险中性测度下的单因子仿射短率跳跃模型，其中短率 $r_t$ 服从随机微分方程 (SDE)\n$$\ndr_t \\;=\\; \\kappa \\,(\\theta - r_t)\\,dt \\;+\\; \\sigma\\, dW_t \\;+\\; J\\, dN_t,\n$$\n其中均值回归速度 $\\kappa > 0$，长期水平 $\\theta$，波动率 $\\sigma \\ge 0$，标准维纳过程 $W_t$，以及强度恒为 $\\lambda \\ge 0$ 的泊松跳跃过程 $N_t$。跳跃大小 $J$ 是确定性的，等于一个常数 $\\mu_J$（以年化小数利率单位计）。对于到期日为 $\\tau$ 的连续复利零息收益率 $y(t,\\tau)$，该模型意味着一个仿射关系\n$$\ny(t,\\tau) \\;=\\; -\\frac{A(\\tau)}{\\tau} \\;+\\; \\frac{B(\\tau)}{\\tau}\\, r_t,\n$$\n其中 $B(\\tau) \\;=\\; \\frac{1 - e^{-\\kappa \\tau}}{\\kappa}$，$A(\\tau)$ 是标准的 Vasicek 函数。假设在长度为 $\\Delta t$ 的一个极短区间内，到期日为 $\\tau$ 的收益率变化满足\n$$\n\\Delta y(t,\\tau) \\;=\\; \\frac{B(\\tau)}{\\tau} \\, \\Delta r_t,\n$$\n其中 $\\Delta r_t$ 表示该区间内短率的变化。假设在每个区间内，最多只能发生一次跳跃，扩散和漂移的贡献相对于跳跃可以忽略不计，且跳跃大小是确定性的 $\\mu_J$。因此，$\\Delta r_t$ 要么是 $0$（无跳跃），要么是 $\\mu_J$（一次跳跃）。设 $p = \\lambda \\Delta t$ 表示单个区间内发生跳跃的概率。\n\n您的任务是根据在包含一次重大市场冲击的 $K$ 个日度区间内观察到的横截面收益率变化，校准跳跃强度 $\\lambda$（年化）和确定性跳跃幅度 $\\mu_J$（年化小数利率）。使用上述 $\\Delta y$ 和 $\\Delta r$ 之间的已知关系以及所描述的模型假设，从数据中推断 $\\lambda$ 和 $\\mu_J$。\n\n使用以下固定参数和约定：\n- 到期日（年）：$\\{\\tau_i\\}_{i=1}^6 = \\{0.25,\\, 0.5,\\, 1.0,\\, 2.0,\\, 5.0,\\, 10.0\\}$。\n- 均值回归速度：$\\kappa = 0.3$（年化）。\n- 区间长度：$\\Delta t = \\frac{1}{252}$（年）。\n- 对于每个区间 $k$，载荷为 $L(\\tau_i) = \\frac{B(\\tau_i)}{\\tau_i}$，其中 $B(\\tau) = \\frac{1 - e^{-\\kappa \\tau}}{\\kappa}$。\n- 对于每个数据集，观察到的收益率变化向量 $\\{\\Delta y_k(\\tau_i)\\}_{i=1}^6$ 由给定的短率增量 $\\{\\Delta r_k\\}$ 通过 $\\Delta y_k(\\tau_i) = L(\\tau_i)\\,\\Delta r_k$ 生成。\n\n测试套件（三个覆盖不同情景的数据集）：\n1. 数据集 $\\mathbf{1}$（$K=5$ 天内的冲击）：短率增量 $\\{\\Delta r_k\\}_{k=1}^5 = [0.0,\\, 0.0,\\, -0.015,\\, 0.0,\\, 0.0]$。\n2. 数据集 $\\mathbf{2}$（$K=4$ 天内无变化）：短率增量 $\\{\\Delta r_k\\}_{k=1}^4 = [0.0,\\, 0.0,\\, 0.0,\\, 0.0]$。\n3. 数据集 $\\mathbf{3}$（单日极端冲击，$K=1$）：短率增量 $\\{\\Delta r_k\\}_{k=1}^1 = [-0.02]$。\n\n对于每个数据集：\n- 使用载荷 $L(\\tau_i)$ 和给定的 $\\Delta r_k$ 构建收益率变化横截面 $\\{\\Delta y_k(\\tau_i)\\}_{i=1}^6$。\n- 从这些收益率变化和模型关系中，估计跳跃强度 $\\lambda$（年化）和确定性跳跃幅度 $\\mu_J$（年化小数利率）。\n\n您的程序必须生成单行输出，包含一个由逗号分隔的三个元素组成的列表，其中每个元素本身是对应数据集的两个浮点数 $[\\lambda,\\mu_J]$ 的列表，两个数字都四舍五入到恰好六位小数。要求的最终输出格式为：\n$$\n[[\\lambda_1,\\mu_{J,1}],[\\lambda_2,\\mu_{J,2}],[\\lambda_3,\\mu_{J,3}]]\n$$\n例如，输出必须类似于 $[[a,b],[c,d],[e,f]]$，其中 $a,b,c,d,e,f$ 每个都打印到六位小数。",
            "solution": "该问题已经过仔细审查，并被确认为有效。这是一个针对特定随机模型的参数估计的明确定义的练习。数据生成过程直接提供了底层的短率增量，这将估计任务简化为对统计定义的直接应用。我们将开始解答。\n\n短率 $r_t$ 由以下随机微分方程建模：\n$$\ndr_t = \\kappa (\\theta - r_t)dt + \\sigma dW_t + J dN_t\n$$\n其中 $\\kappa$ 是均值回归速度，$\\theta$ 是长期均值，$\\sigma$ 是波动率，$W_t$ 是标准维纳过程，$N_t$ 是强度恒为 $\\lambda$ 的泊松过程。跳跃大小 $J$ 是一个确定性常数，记为 $\\mu_J$。\n\n问题陈述，对于一个短时间区间 $\\Delta t$，短率的变化 $\\Delta r_t$ 可以通过仅考虑跳跃部分来近似，因为漂移和扩散被假定为可以忽略不计。此外，在任何区间 $\\Delta t$ 内最多只能发生一次跳跃。因此，短率的变化是二元的：\n$$\n\\Delta r_t =\n\\begin{cases}\n\\mu_J  \\text{如果发生跳跃} \\\\\n0  \\text{如果没有发生跳跃}\n\\end{cases}\n$$\n单个区间内发生跳跃的概率由 $p = \\lambda \\Delta t$ 给出。\n\n到期日为 $\\tau$ 的零息收益率 $y(t,\\tau)$ 的变化通过仿射关系与短率变化相关联：\n$$\n\\Delta y(t,\\tau) = \\frac{B(\\tau)}{\\tau} \\Delta r_t = L(\\tau) \\Delta r_t\n$$\n其中载荷 $L(\\tau) = B(\\tau)/\\tau$ 是到期日 $\\tau$ 和参数 $\\kappa$ 的函数。\n\n任务是从给定的三个不同数据集的短率增量时间序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中估计跳跃强度 $\\lambda$ 和跳跃幅度 $\\mu_J$。问题指示首先构建收益率变化，然后估计参数。然而，由于底层的短率增量 $\\Delta r_k$ 是直接给出的，并且关系 $\\Delta y_k(\\tau_i) = L(\\tau_i) \\Delta r_k$ 是精确的，任何试图从构建的 $\\Delta y_k(\\tau_i)$ 中估计 $\\Delta r_k$ 的尝试都只会恢复所提供的 $\\Delta r_k$ 值。因此，问题简化为直接从序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中估计 $(\\lambda, \\mu_J)$。\n\n估计逻辑如下：\n$1$. **跳跃幅度 $\\mu_J$ 的估计**：跳跃幅度 $\\mu_J$ 是确定性的。序列 $\\{\\Delta r_k\\}$ 中观察到的任何非零值都必须对应一次跳跃，因此必须等于 $\\mu_J$。\n    - 如果非零增量的数量大于零，估计值 $\\hat{\\mu}_J$ 就是这些增量的唯一值。问题设置保证了每个数据集内的所有非零增量都是相同的，因为每个数据集只模拟一个跳跃事件。\n    - 如果没有非零增量（未观察到跳跃），则参数 $\\mu_J$ 无法从数据中进行统计识别。在这种情况下，一个标准且合乎逻辑的约定是将其估计值设为零，$\\hat{\\mu}_J = 0$，因为如果跳跃不发生，其值是无关紧要的。\n\n$2$. **跳跃强度 $\\lambda$ 的估计**：在 $K$ 个区间中的任何一个区间内观察到一次跳跃构成一个伯努利试验。设 $N_J$ 为观察到的总跳跃次数，即序列 $\\{\\Delta r_k\\}_{k=1}^K$ 中非零元素的数量。单个区间内发生跳跃的概率 $p$ 的最大似然估计量是样本比例：\n$$\n\\hat{p} = \\frac{N_J}{K}\n$$\n根据关系 $p = \\lambda \\Delta t$，跳跃强度 $\\lambda$ 的估计量为：\n$$\n\\hat{\\lambda} = \\frac{\\hat{p}}{\\Delta t} = \\frac{N_J}{K \\Delta t}\n$$\n我们已知固定参数 $\\Delta t = 1/252$。\n\n我们现在将此方法应用于每个数据集。\n\n**数据集 1:**\n- 短率增量：$\\{\\Delta r_k\\}_{k=1}^5 = [0.0, 0.0, -0.015, 0.0, 0.0]$。\n- 区间数量：$K = 5$。\n- 观察到的跳跃次数：$N_J = 1$。非零增量为 $-0.015$。\n- $\\mu_J$ 的估计：从单次观察到的跳跃中，我们直接确定跳跃幅度。\n$$\n\\hat{\\mu}_{J,1} = -0.015\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_1 = \\frac{N_J}{K \\Delta t} = \\frac{1}{5 \\times (1/252)} = \\frac{252}{5} = 50.4\n$$\n\n**数据集 2:**\n- 短率增量：$\\{\\Delta r_k\\}_{k=1}^4 = [0.0, 0.0, 0.0, 0.0]$。\n- 区间数量：$K = 4$。\n- 观察到的跳跃次数：$N_J = 0$。\n- $\\mu_J$ 的估计：未观察到跳跃，因此 $\\mu_J$ 无法识别。我们采用约定。\n$$\n\\hat{\\mu}_{J,2} = 0.0\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_2 = \\frac{N_J}{K \\Delta t} = \\frac{0}{4 \\times (1/252)} = 0.0\n$$\n\n**数据集 3:**\n- 短率增量：$\\{\\Delta r_k\\}_{k=1}^1 = [-0.02]$。\n- 区间数量：$K = 1$。\n- 观察到的跳跃次数：$N_J = 1$。非零增量为 $-0.02$。\n- $\\mu_J$ 的估计：\n$$\n\\hat{\\mu}_{J,3} = -0.02\n$$\n- $\\lambda$ 的估计：\n$$\n\\hat{\\lambda}_3 = \\frac{N_J}{K \\Delta t} = \\frac{1}{1 \\times (1/252)} = 252.0\n$$\n\n总而言之，估计的参数是：\n- 数据集 $1$：$(\\hat{\\lambda}_1, \\hat{\\mu}_{J,1}) = (50.4, -0.015)$\n- 数据集 $2$：$(\\hat{\\lambda}_2, \\hat{\\mu}_{J,2}) = (0.0, 0.0)$\n- 数据集 $3$：$(\\hat{\\lambda}_3, \\hat{\\mu}_{J,3}) = (252.0, -0.02)$\n\n这些结果将按要求格式化为六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates jump intensity (lambda) and jump magnitude (mu_J) for a one-factor\n    affine short-rate model with jumps, based on provided short-rate increments.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    delta_t = 1.0 / 252.0\n\n    # Test suite: three datasets of short-rate increments {delta_r_k}.\n    test_cases = [\n        [0.0, 0.0, -0.015, 0.0, 0.0],  # Dataset 1: K=5, one jump\n        [0.0, 0.0, 0.0, 0.0],         # Dataset 2: K=4, no jumps\n        [-0.02]                       # Dataset 3: K=1, one jump\n    ]\n\n    results = []\n    for dr_increments in test_cases:\n        # K is the total number of observation intervals in the dataset.\n        K = len(dr_increments)\n        \n        # We use a numpy array for efficient vectorized operations.\n        dr_array = np.array(dr_increments)\n        \n        # N_J is the number of observed jumps, counted as non-zero increments.\n        num_jumps = np.count_nonzero(dr_array)\n        \n        # Estimate lambda using the maximum likelihood estimator for a sequence of Bernoulli trials.\n        # lambda_hat = (N_J / K) / delta_t\n        if K > 0:\n            lambda_est = num_jumps / (K * delta_t)\n        else:\n            # This case will not be reached with the given test data.\n            lambda_est = 0.0\n\n        # Estimate mu_J, the deterministic jump magnitude.\n        if num_jumps > 0:\n            # If jumps are observed, mu_J is identified as the magnitude of these jumps.\n            # As mu_J is deterministic, all non-zero increments must be identical.\n            # We can take the first non-zero element.\n            mu_j_est = dr_array[dr_array != 0][0]\n        else:\n            # If no jumps are observed, mu_J is not statistically identifiable.\n            # We follow the standard convention of setting its estimate to 0,\n            # as its value is irrelevant in this scenario.\n            mu_j_est = 0.0\n            \n        results.append([lambda_est, mu_j_est])\n\n    # Format the final results into the required string format.\n    # The output is a list of lists, e.g., [[lambda1,mu_J1],[lambda2,mu_J2],...],\n    # with each float formatted to exactly six decimal places.\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # The final print statement must produce only the required single-line output.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在我们理解了跳跃过程的基础上，现在我们将此概念应用于股票期权定价，具体采用 Merton 跳跃扩散模型。这个练习  要求你实现一个完整的校准程序，通过最小化模型价格与观测价格之间的误差来确定参数。本练习的一个关键特点是引入了吉洪诺夫正则化 (Tikhonov regularization)，这是一种确保参数估计稳定且符合现实的强大技术，尤其是在市场数据稀疏的情况下。",
            "id": "2434399",
            "problem": "给定一个随机跳跃下的跳跃-扩散模型中的欧式看涨期权定价模型，具体为 Merton 跳跃-扩散模型。在风险中性测度下，标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 遵循如下随机微分方程\n$$\n\\frac{\\,\\mathrm{d}S_t\\,}{S_{t^-}} \\;=\\; \\bigl(r - q - \\lambda k\\bigr)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t \\;+\\; (J - 1)\\,\\mathrm{d}N_t,\n$$\n其中 $r$ 是连续复利无风险利率（以小数表示），$q$ 是连续复利股息率（以小数表示），$\\sigma$ 是扩散波动率（以小数表示），$\\lambda$ 是跳跃强度（单位时间内的事件数），$N_t$ 是强度为 $\\lambda$ 的泊松过程，$J$ 是跳跃乘数，满足 $\\ln J \\sim \\mathcal{N}(\\mu_J, \\delta_J^2)$。跳跃补偿项为 $k \\equiv \\mathbb{E}[J - 1] = \\exp\\!\\bigl(\\mu_J + \\tfrac{1}{2}\\delta_J^2\\bigr) - 1$。所有利率和波动率都必须视为小数，而不是百分比。\n\n对于一个即期价格为 $S$、行权价为 $K$、到期日为 $T$（以年为单位）、无风险利率为 $r$、股息率为 $q$ 的欧式看涨期权，其在该模型下的无套利价格可以写成 Black–Scholes 价格的泊松混合形式：\n$$\nC_{\\text{MJD}}(S,K,T;r,q;\\sigma,\\lambda,\\mu_J,\\delta_J) \\;=\\;\n\\sum_{n=0}^{\\infty} \\mathrm{e}^{-\\lambda T} \\frac{(\\lambda T)^n}{n!}\\;\nC_{\\text{BS}}\\!\\Bigl(S \\mathrm{e}^{n\\mu_J},K,T;\\; r - \\lambda k,\\; q,\\; \\sqrt{\\sigma^2 + \\tfrac{n\\,\\delta_J^2}{T}} \\Bigr),\n$$\n其中 $C_{\\text{BS}}$ 是连续股息率为 $q$ 的 Black–Scholes–Merton 价格，且 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。Black–Scholes–Merton 看涨期权价格满足\n$$\nC_{\\text{BS}}(S,K,T;\\, r, q, \\sigma)\n=\nS\\,\\mathrm{e}^{-qT}\\,\\Phi(d_1) - K\\,\\mathrm{e}^{-rT}\\,\\Phi(d_2),\n\\quad\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}},\n\\quad\nd_2 = d_1 - \\sigma\\sqrt{T},\n$$\n其中 $\\Phi$ 表示标准正态累积分布函数。\n\n校准问题被构建为一个采用 Tikhonov 正则化的正则化非线性最小二乘问题。对于一组给定的、在行权价 $\\{K_i\\}_{i=1}^M$ 和共同到期日 $T$ 下观测到的市场期权价格 $\\{C_i^{\\text{mkt}}\\}_{i=1}^M$，定义参数向量 $\\boldsymbol{\\theta} = [\\sigma,\\lambda,\\mu_J,\\delta_J]^\\top$ 和一个先验（参考）向量 $\\boldsymbol{\\theta}_0$。校准问题为\n$$\n\\min_{\\boldsymbol{\\theta}} \\;\\; \\sum_{i=1}^{M} \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\boldsymbol{\\theta}) - C_i^{\\text{mkt}}\\bigr)^2\n\\;+\\;\n\\alpha \\,\\bigl\\| \\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0 \\bigr\\|_2^2,\n$$\n其中 $\\alpha \\ge 0$ 是 Tikhonov 正则化强度。$\\boldsymbol{\\theta}$ 的分量必须满足边界条件 $\\sigma \\in [0.01, 1.50]$、$\\lambda \\in [0.00, 2.00]$、$\\mu_J \\in [-0.50, 0.50]$ 和 $\\delta_J \\in [0.01, 1.00]$。\n\n您的任务是实现一个程序，对于下方的每个测试用例，该程序通过上述模型（无噪声）从指定的“真实”参数构建合成市场价格，通过求解优化问题来校准 $\\boldsymbol{\\theta}$，并报告校准后的模型价格与合成市场价格之间的均方根误差（RMSE）。所有利率和波动率都必须按小数处理和报告。不涉及角度。最终的数值结果必须以浮点数形式打印。\n\n测试套件：\n- 案例 $1$（一般情况）：\n  - $S = 100$，$r = 0.01$，$q = 0.00$，$T = 0.50$，行权价 $K \\in \\{90, 100, 110\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.20,\\, 0.30,\\, -0.10,\\, 0.20]$。\n  - 先验 $\\boldsymbol{\\theta}_0 = [0.18,\\, 0.10,\\, 0.00,\\, 0.25]$，正则化 $\\alpha = 10^{-4}$。\n- 案例 $2$（稀疏数据，欠定）：\n  - $S = 100$，$r = 0.00$，$q = 0.00$，$T = 0.50$，行权价 $K \\in \\{90, 110\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.18,\\, 0.40,\\, -0.05,\\, 0.25]$。\n  - 先验 $\\boldsymbol{\\theta}_0 = [0.20,\\, 0.20,\\, 0.00,\\, 0.20]$，正则化 $\\alpha = 10^{-2}$。\n- 案例 $3$（边界情况，无跳跃）：\n  - $S = 100$，$r = 0.01$，$q = 0.00$，$T = 1.00$，行权价 $K \\in \\{80, 100, 120\\}$。\n  - 真实参数 $\\boldsymbol{\\theta}^{\\star} = [0.25,\\, 0.00,\\, 0.00,\\, 0.20]$。\n  - 先验 $\\boldsymbol{\\theta}_0 = [0.22,\\, 0.30,\\, -0.10,\\, 0.25]$，正则化 $\\alpha = 10^{-4}$。\n\n实现要求：\n- 直接使用上述定义，不假设任何此处未说明的额外公式。\n- 在计算 $C_{\\text{MJD}}$ 时，通过有限和来近似无限级数，以产生数值稳定且准确的值。\n- 对每个案例，通过在指定的 $(S,r,q,T,K_i)$ 下使用 $\\boldsymbol{\\theta}^{\\star}$ 来计算 $C_{\\text{MJD}}$，从而合成 $C_i^{\\text{mkt}}$，然后使用指定的先验和正则化来校准 $\\boldsymbol{\\theta}$。\n- 对每个案例，计算 RMSE\n$$\n\\mathrm{RMSE} = \\sqrt{ \\frac{1}{M} \\sum_{i=1}^{M} \\bigl( C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\widehat{\\boldsymbol{\\theta}}) - C_i^{\\text{mkt}} \\bigr)^2 }.\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 $1$、$2$ 和 $3$ 的三个 RMSE 值，按此顺序排列，四舍五入到 $6$ 位小数，并以逗号分隔列表的形式包含在方括号中。例如，一个有效的输出格式为\n$[x_1,x_2,x_3]$\n其中每个 $x_j$ 是一个四舍五入到 $6$ 位小数的浮点数，且没有其他附加文本。",
            "solution": "该问题要求通过最小化在一组稀疏期权价格上的正则化最小二乘目标函数，来校准 Merton 跳跃-扩散模型的参数。该目标函数是根据风险中性定价的第一性原理和 Merton 模型的结构构建的。\n\n首先，在风险中性测度下，资产价格动态由以下公式给出\n$$\n\\frac{\\,\\mathrm{d}S_t\\,}{S_{t^-}} \\;=\\; \\bigl(r - q - \\lambda k\\bigr)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t \\;+\\; (J - 1)\\,\\mathrm{d}N_t,\n$$\n其中 $\\ln J \\sim \\mathcal{N}(\\mu_J,\\delta_J^2)$ 且 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。此设定通过减去 $\\lambda k$ 来补偿漂移项，从而确保折现后的价格过程是一个鞅。\n\n其次，欧式看涨期权在到期日的收益为 $\\max(S_T - K, 0)$。在时间 $t=0$ 时的风险中性价格是折现后的期望值\n$$\nC_{\\text{MJD}}(S,K,T;\\, r,q;\\boldsymbol{\\theta}) \\;=\\; \\mathrm{e}^{-rT}\\,\\mathbb{E}^{\\mathbb{Q}}\\bigl[(S_T - K)^+ \\,\\big|\\, S_0 = S \\bigr].\n$$\n通过以 $N_T = n$ 为条件，我们使用全期望定律以及跳跃时间和大小的独立性，将 $\\ln S_T$ 的分布写为正态分布的混合形式：当 $N_T=n$ 时，跳跃部分贡献一个均值为 $n\\mu_J$、方差为 $n\\delta_J^2$ 的正态位移，而扩散部分贡献方差 $\\sigma^2 T$ 和漂移项 $r - q - \\lambda k$。因此，看涨期权价格可以表示为 Black–Scholes–Merton 价格的泊松加权和，\n$$\nC_{\\text{MJD}}(S,K,T;\\, r,q;\\sigma,\\lambda,\\mu_J,\\delta_J) \\;=\\;\n\\sum_{n=0}^{\\infty} \\mathrm{e}^{-\\lambda T} \\frac{(\\lambda T)^n}{n!}\\;\nC_{\\text{BS}}\\!\\Bigl(S \\mathrm{e}^{n\\mu_J},K,T;\\; r - \\lambda k,\\; q,\\; \\sqrt{\\sigma^2 + \\tfrac{n\\,\\delta_J^2}{T}} \\Bigr),\n$$\n其中 $k = \\exp(\\mu_J + \\tfrac{1}{2}\\delta_J^2) - 1$。具有连续股息率的 Black–Scholes–Merton 公式为\n$$\nC_{\\text{BS}}(S,K,T;\\, r,q,\\sigma) = S\\,\\mathrm{e}^{-qT}\\,\\Phi(d_1) - K\\,\\mathrm{e}^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}},\n\\qquad\nd_2 = d_1 - \\sigma\\sqrt{T},\n$$\n且 $\\Phi$ 为标准正态累积分布函数。\n\n第三，校准过程构建一个参数向量 $\\boldsymbol{\\theta} = [\\sigma,\\lambda,\\mu_J,\\delta_J]^\\top$ 并最小化一个正则化的残差平方和：\n$$\n\\min_{\\boldsymbol{\\theta}} \\;\\; \\sum_{i=1}^{M} \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\boldsymbol{\\theta}) - C_i^{\\text{mkt}}\\bigr)^2\n\\;+\\;\n\\alpha \\,\\bigl\\| \\boldsymbol{\\theta} - \\boldsymbol{\\theta}_0 \\bigr\\|_2^2.\n$$\n这是一个 Tikhonov (ridge) 正则化项，强度为 $\\alpha \\ge 0$，惩罚矩阵为单位矩阵（因此惩罚是针对偏离先验 $\\boldsymbol{\\theta}_0$ 的 $\\ell_2$ 范数）。加入正则化项可以通过向先验收缩，来避免在稀疏数据设置下出现不稳定的解。\n\n第四，优化在物理和统计上合理的边界条件下执行：\n$$\n\\sigma \\in [0.01, 1.50],\\quad \\lambda \\in [0.00, 2.00],\\quad \\mu_J \\in [-0.50, 0.50],\\quad \\delta_J \\in [0.01, 1.00].\n$$\n这些边界条件强制尺度参数为正，并将跳跃幅度限制在数值稳定的范围内，这与高等本科练习题中的设定一致。\n\n第五，对于每个测试用例，通过在给定的真实参数 $\\boldsymbol{\\theta}^\\star$ 和 $(S,r,q,T,K_i)$ 下计算 $C_{\\text{MJD}}$ 来得到合成的“市场”价格 $\\{C_i^{\\text{mkt}}\\}_{i=1}^M$。这确保了一个内部一致且无噪声的数据集，从而能够将校准精度的评估纯粹作为优化和正则化练习。\n\n第六，通过截断来计算 $C_{\\text{MJD}}$ 的无限级数。通过对足够多的泊松项求和来达到精度。一种实用的方法是求和至一个足够大的最大索引 $N_{\\max}$，使得对于当前参数范围，被忽略的尾部可以忽略不计。例如，使用 $N_{\\max}$ 作为固定上限和 $\\lambda T$ 的函数（例如均值加上几个标准差）中的较大者，可确保稳健的近似。\n\n第七，在为每个案例求解优化问题并获得 $\\widehat{\\boldsymbol{\\theta}}$ 后，均方根误差计算如下\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\bigl(C_{\\text{MJD}}(S,K_i,T;\\, r,q;\\widehat{\\boldsymbol{\\theta}}) - C_i^{\\text{mkt}}\\bigr)^2}.\n$$\n由于合成数据是无噪声的，并且由同一模型生成，因此在适定问题中（案例 $1$ 和案例 $3$），RMSE 值预计接近于 $0$；而在稀疏、欠定的情况下（案例 $2$），RMSE 值预计非零但很小，此时正则化会影响解。\n\n最后，程序将案例 $1$、$2$ 和 $3$ 的 RMSE 值汇总到单行中，格式为 $[x_1,x_2,x_3]$，其中每个 $x_j$ 四舍五入到 $6$ 位小数。所有利率和波动率都作为小数使用和解释，不带百分号。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import log, sqrt, exp, erf\nfrom scipy.optimize import minimize\nfrom math import factorial\n\ndef std_norm_cdf(x: float) -> float:\n    # Standard normal CDF via error function\n    return 0.5 * (1.0 + erf(x / sqrt(2.0)))\n\ndef bs_call_price(S: float, K: float, r: float, q: float, sigma: float, T: float) -> float:\n    # Black-Scholes-Merton call with continuous dividend yield\n    if sigma == 0.0 or T == 0.0:\n        # In the limiting case, treat as forward intrinsic value\n        forward = S * np.exp(-q * T)\n        discK = K * np.exp(-r * T)\n        return max(forward - discK, 0.0)\n    vol_sqrt_T = sigma * sqrt(T)\n    d1 = (log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / vol_sqrt_T\n    d2 = d1 - vol_sqrt_T\n    return S * np.exp(-q * T) * std_norm_cdf(d1) - K * np.exp(-r * T) * std_norm_cdf(d2)\n\ndef merton_call_price(S: float, K: float, r: float, q: float, T: float,\n                      sigma: float, lam: float, mu_j: float, delta_j: float) -> float:\n    # Merton jump-diffusion call via Poisson mixture of BSM prices\n    # Compute jump compensator\n    k = np.exp(mu_j + 0.5 * (delta_j ** 2)) - 1.0\n    r_eff = r - lam * k\n    # Poisson mean\n    m = lam * T\n    # Choose truncation level: mean + 10 stddevs, but at least 50 terms\n    Nmax = max(50, int(np.ceil(m + 10.0 * sqrt(m + 1e-12))))\n    # Compute Poisson weights iteratively to avoid overflow\n    # Start with p0 = exp(-m)\n    p = np.exp(-m)\n    price = 0.0\n    for n in range(0, Nmax + 1):\n        # Effective sigma and shifted spot for the nth term\n        sigma_n_sq = sigma * sigma + (n * delta_j * delta_j) / max(T, 1e-16)\n        sigma_n = sqrt(max(sigma_n_sq, 1e-16))\n        S_n = S * np.exp(n * mu_j)\n        price += p * bs_call_price(S_n, K, r_eff, q, sigma_n, T)\n        # Update Poisson weight for next n\n        # p_{n+1} = p_n * m / (n + 1)\n        if n  Nmax:\n            p = p * (m / (n + 1.0))\n    return price\n\ndef synthesize_market_prices(S, r, q, T, Ks, theta_true):\n    sigma, lam, mu_j, delta_j = theta_true\n    prices = []\n    for K in Ks:\n        prices.append(merton_call_price(S, K, r, q, T, sigma, lam, mu_j, delta_j))\n    return np.array(prices, dtype=float)\n\ndef calibrate_case(S, r, q, T, Ks, market_prices, theta0, alpha):\n    Ks = np.array(Ks, dtype=float)\n    M = len(Ks)\n    theta0 = np.array(theta0, dtype=float)\n\n    # Bounds: sigma in [0.01, 1.50], lambda in [0.0, 2.0], mu in [-0.5, 0.5], delta in [0.01, 1.0]\n    bounds = [(0.01, 1.50), (0.0, 2.0), (-0.5, 0.5), (0.01, 1.0)]\n\n    def objective(theta):\n        sigma, lam, mu_j, delta_j = theta\n        model_prices = np.array(\n            [merton_call_price(S, K, r, q, T, sigma, lam, mu_j, delta_j) for K in Ks],\n            dtype=float\n        )\n        resid = model_prices - market_prices\n        data_term = float(np.dot(resid, resid))\n        reg = float(alpha) * float(np.dot(theta - theta0, theta - theta0))\n        return data_term + reg\n\n    # Use prior as initial guess\n    x0 = theta0.copy()\n    result = minimize(objective, x0, method='L-BFGS-B', bounds=bounds)\n    theta_hat = result.x\n    # Compute RMSE\n    model_prices_hat = np.array(\n        [merton_call_price(S, K, r, q, T, theta_hat[0], theta_hat[1], theta_hat[2], theta_hat[3]) for K in Ks],\n        dtype=float\n    )\n    rmse = float(np.sqrt(np.mean((model_prices_hat - market_prices) ** 2)))\n    return theta_hat, rmse\n\ndef solve():\n    # Define test cases as specified in the problem statement.\n\n    # Case 1: general case\n    S1, r1, q1, T1 = 100.0, 0.01, 0.0, 0.50\n    Ks1 = [90.0, 100.0, 110.0]\n    theta_true_1 = [0.20, 0.30, -0.10, 0.20]\n    theta0_1 = [0.18, 0.10, 0.00, 0.25]\n    alpha_1 = 1e-4\n    market1 = synthesize_market_prices(S1, r1, q1, T1, Ks1, theta_true_1)\n\n    # Case 2: sparse data\n    S2, r2, q2, T2 = 100.0, 0.00, 0.00, 0.50\n    Ks2 = [90.0, 110.0]\n    theta_true_2 = [0.18, 0.40, -0.05, 0.25]\n    theta0_2 = [0.20, 0.20, 0.00, 0.20]\n    alpha_2 = 1e-2\n    market2 = synthesize_market_prices(S2, r2, q2, T2, Ks2, theta_true_2)\n\n    # Case 3: no jumps\n    S3, r3, q3, T3 = 100.0, 0.01, 0.00, 1.00\n    Ks3 = [80.0, 100.0, 120.0]\n    theta_true_3 = [0.25, 0.00, 0.00, 0.20]\n    theta0_3 = [0.22, 0.30, -0.10, 0.25]\n    alpha_3 = 1e-4\n    market3 = synthesize_market_prices(S3, r3, q3, T3, Ks3, theta_true_3)\n\n    # Calibrate each case\n    _, rmse1 = calibrate_case(S1, r1, q1, T1, Ks1, market1, theta0_1, alpha_1)\n    _, rmse2 = calibrate_case(S2, r2, q2, T2, Ks2, market2, theta0_2, alpha_2)\n    _, rmse3 = calibrate_case(S3, r3, q3, T3, Ks3, market3, theta0_3, alpha_3)\n\n    results = [rmse1, rmse2, rmse3]\n    # Print in required format with 6 decimal places\n    print(f\"[{results[0]:.6f},{results[1]:.6f},{results[2]:.6f}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的练习将重点从跳跃转向现实世界资产价格的另一个关键特征：随机波动率。你将使用著名的 Heston 模型，超越 Black-Scholes 模型中恒定波动率的假设 。本练习将指导你使用先进的傅里叶变换方法为期权定价，并校准控制波动率动态的关键参数，例如“波动率的波动率”($\\nu$)和杠杆效应相关系数($\\rho$)。",
            "id": "2434416",
            "problem": "您需要编写一个完整的、可运行的程序，该程序为每个测试案例中的两只股票分别校准 Heston 随机波动率模型，并比较它们的相关性参数和波动率的波动率参数。您必须使用基于傅里叶变换的方法在 Heston 模型下实现欧式看涨期权定价，并且仅校准资产和方差布朗运动之间的相关性参数（用 $\\rho$ 表示）以及方差的波动率参数（用 $\\nu$ 表示）。所有其他参数都是固定的。您的程序必须根据给定的真实 Heston 参数生成合成的“观测”期权价格，然后通过在每个股票的指定期权网格上最小化定价平方误差来恢复 $\\rho$ 和 $\\nu$。最后，程序必须报告每个测试案例的绝对差值 $|\\rho_{A} - \\rho_{B}|$ 和 $|\\nu_{A} - \\nu_{B}|$，结果为浮点数并四舍五入到六位小数。\n\n基本原理。在风险中性测度下，根据 Heston 模型，资产价格过程 $S_{t}$ 和瞬时方差 $v_{t}$ 服从\n$$\ndS_{t} = r S_{t} \\, dt + \\sqrt{v_{t}} \\, S_{t} \\, dW^{(1)}_{t},\n\\qquad\ndv_{t} = \\kappa \\left(\\theta - v_{t}\\right) dt + \\nu \\sqrt{v_{t}} \\, dW^{(2)}_{t},\n$$\n其中 $\\mathbb{E}\\left[dW^{(1)}_{t}\\, dW^{(2)}_{t}\\right] = \\rho \\, dt$，$r$ 是连续复利无风险利率，$\\kappa$ 是方差的均值回归速度，$\\theta$ 是长期方差，$\\nu$ 是方差的波动率，$\\rho$ 是资产和方差布朗运动之间的瞬时相关性。根据无套利原则和风险中性定价，到期日为 $T$、执行价为 $K$ 的欧式看涨期权在时间 $0$ 的价格是其收益的贴现风险中性期望值。\n\n您的实现要求：\n- 基于风险中性特征函数和带数值积分的傅里叶逆变换，实现一个数值稳定的 Heston 欧式看涨期权定价器。除了风险中性定价原则和特征函数的使用外，您不能假定任何给定的期权价格闭式解。\n- 不使用股息（股息收益率为 $0$）。\n- 通过带有简单边界的非线性最小二乘法校准 $\\rho$ 和 $\\nu$，同时保持其他 Heston 参数固定并在每个测试案例中由两只股票共享。使用边界 $-0.999 \\le \\rho \\le 0.999$ 和 $10^{-4} \\le \\nu \\le 2.0$。\n- 用于校准的“观测”期权价格必须由您自己的 Heston 定价器，使用每个测试案例中每只股票的真实参数生成。\n\n校准设计：\n- 每个测试案例中两只股票使用的期权网格：\n  - 到期日 $T \\in \\{\\,0.25,\\,0.5,\\,1.0\\,\\}$（以年为单位）。\n  - 执行价 $K$ 由应用于现货价格的执行价乘数给出，乘数为 $\\{\\,0.8,\\,0.9,\\,1.1,\\,1.2\\,\\}$。例如，$K = 0.8 \\times S_{0}$ 为买方产生一个深度价内看涨期权。\n- 对于每只股票，将所有到期日-执行价组合的模型价格与观测价格之差构成残差向量，并在上述边界条件下，关于 $(\\rho,\\nu)$ 最小化残差平方和。\n\n测试套件：\n提供三个测试案例。在每个案例中，两只股票共享相同的 $(S_{0}, r, \\kappa, \\theta, v_{0})$，但具有不同的真实 $(\\rho, \\nu)$。您的程序必须从这些真实值合成观测价格，然后在每个案例中为股票 A 和股票 B 独立校准 $(\\rho, \\nu)$。\n\n- 案例 1：\n  - 共享：$S_{0} = 100$，$r = 0.01$，$\\kappa = 1.5$，$\\theta = 0.04$，$v_{0} = 0.04$。\n  - 股票 A 真实值：$\\rho_{A} = -0.7$，$\\nu_{A} = 0.6$。\n  - 股票 B 真实值：$\\rho_{B} = -0.6$，$\\nu_{B} = 0.55$。\n- 案例 2：\n  - 共享：$S_{0} = 100$，$r = 0.005$，$\\kappa = 2.0$，$\\theta = 0.03$，$v_{0} = 0.03$。\n  - 股票 A 真实值：$\\rho_{A} = -0.95$，$\\nu_{A} = 0.3$。\n  - 股票 B 真实值：$\\rho_{B} = -0.90$，$\\nu_{B} = 0.28$。\n- 案例 3：\n  - 共享：$S_{0} = 100$，$r = 0.02$，$\\kappa = 1.2$，$\\theta = 0.05$，$v_{0} = 0.05$。\n  - 股票 A 真实值：$\\rho_{A} = -0.5$，$\\nu_{A} = 0.9$。\n  - 股票 B 真实值：$\\rho_{B} = -0.48$，$\\nu_{B} = 1.0$。\n\n答案规格和输出格式：\n- 对于每个测试案例，在校准两只股票后，计算两个浮点数：\n  - $d_{\\rho} = \\left|\\hat{\\rho}_{A} - \\hat{\\rho}_{B}\\right|$，\n  - $d_{\\nu} = \\left|\\hat{\\nu}_{A} - \\hat{\\nu}_{B}\\right|$，\n  其中帽子符号表示校准值。\n- 将这些浮点数都四舍五入到恰好六位小数。\n- 您的程序应生成单行输出，包含所有结果，按案例顺序和案例内参数顺序展平为\n  $[d_{\\rho}^{(1)}, d_{\\nu}^{(1)}, d_{\\rho}^{(2)}, d_{\\nu}^{(2)}, d_{\\rho}^{(3)}, d_{\\nu}^{(3)}]$，\n  其中上标表示案例索引。例如，一个有效的输出可能看起来像\n  $[0.100000,0.050000,0.050000,0.020000,0.020000,0.100000]$。\n\n注意：\n- 不涉及角度。\n- 没有物理单位；在此处使用的风险中性定价框架下，所有量都是无量纲的。\n- 实现必须是完全确定性的，并且不得使用任何随机性。",
            "solution": "问题陈述已经过验证。\n\n### 步骤 1：提取已知信息\n- **Heston 模型动态**：在风险中性测度 $\\mathbb{Q}$ 下，资产价格 $S_t$ 及其方差 $v_t$ 服从以下随机微分方程：\n$$\ndS_{t} = r S_{t} \\, dt + \\sqrt{v_{t}} \\, S_{t} \\, dW^{(1)}_{t}\n$$\n$$\ndv_{t} = \\kappa \\left(\\theta - v_{t}\\right) dt + \\nu \\sqrt{v_{t}} \\, dW^{(2)}_{t}\n$$\n其中 $dW^{(1)}_{t}$ 和 $dW^{(2)}_{t}$ 是维纳过程，其相关性为 $\\mathbb{E}\\left[dW^{(1)}_{t}\\, dW^{(2)}_{t}\\right] = \\rho \\, dt$。\n- **参数**：\n    - $r$：连续复利无风险利率。\n    - $\\kappa$：方差的均值回归速度。\n    - $\\theta$：长期平均方差。\n    - $\\nu$：方差的波动率（vol-of-vol）。\n    - $\\rho$：资产和方差过程之间的相关性。\n    - $S_0$：初始资产价格。\n    - $v_0$：初始方差。\n- **任务**：为每个测试案例中的股票 A 和 B 校准参数 $(\\rho, \\nu)$。\n- **固定参数**：对于每个测试案例，$(S_0, r, \\kappa, \\theta, v_0)$ 由股票 A 和 B 共享。\n- **校准方法**：\n    - 目标：最小化模型预测的欧式看涨期权价格与综合生成的“观测”价格之间的平方误差总和。\n    - 优化变量：$(\\rho, \\nu)$。\n    - 边界：$-0.999 \\le \\rho \\le 0.999$ 和 $10^{-4} \\le \\nu \\le 2.0$。\n- **观测数据生成**：“观测”价格是使用提供的 Heston 模型定价器，并为每只股票使用真实参数生成的。\n- **用于校准的期权网格**：\n    - 到期日 $T \\in \\{0.25, 0.5, 1.0\\}$ 年。\n    - 执行价 $K = S_0 \\times m$，其中乘数 $m \\in \\{0.8, 0.9, 1.1, 1.2\\}$。\n- **测试案例**：\n    - **案例 1**：共享：$S_{0} = 100$，$r = 0.01$，$\\kappa = 1.5$，$\\theta = 0.04$，$v_{0} = 0.04$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.7, 0.6)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.6, 0.55)$。\n    - **案例 2**：共享：$S_{0} = 100$，$r = 0.005$，$\\kappa = 2.0$，$\\theta = 0.03$，$v_{0} = 0.03$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.95, 0.3)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.90, 0.28)$。\n    - **案例 3**：共享：$S_{0} = 100$，$r = 0.02$，$\\kappa = 1.2$，$\\theta = 0.05$，$v_{0} = 0.05$。股票 A 真实值：$(\\rho_{A}, \\nu_{A}) = (-0.5, 0.9)$。股票 B 真实值：$(\\rho_{B}, \\nu_{B}) = (-0.48, 1.0)$。\n- **输出**：对于每个案例，计算 $d_{\\rho} = |\\hat{\\rho}_{A} - \\hat{\\rho}_{B}|$ 和 $d_{\\nu} = |\\hat{\\nu}_{A} - \\hat{\\nu}_{B}|$，其中带帽子的变量是校准值。报告这些值的扁平化列表，四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知信息进行验证\n- **科学依据**：该问题基于 Heston 随机波动率模型，这是量化金融中的一个经典模型。通过特征函数的傅里叶逆变换进行定价的方法是一种标准且严谨的技术。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它要求根据同一模型生成的合成数据来校准模型，这是测试定价和校准程序实现的标准流程。鉴于数据的合成性质，预期优化问题存在唯一解。\n- **客观性**：该问题使用精确的数学定义、数值和明确的目标进行陈述。它没有主观性。\n- **完整性和一致性**：该问题提供了实现解决方案所需的所有数据和约束。参数，包括那些违反 Feller 条件 ($2\\kappa\\theta > \\nu^2$) 的参数，都在特征函数定义的域内，这使得问题规范与所选的数学框架保持一致。\n- **其他缺陷**：该问题不是隐喻性的、微不足道的，也没有超出科学可验证性的范围。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 解决方案设计\n\n解决方案的核心是实现一个 Heston 模型的欧式看涨期权定价器，并在一个用于校准的数值优化程序中使用它。\n\n**1. Heston 模型期权定价**\n\n执行价为 $K$、到期日为 $T$ 的欧式看涨期权价格 $C$ 由风险中性定价公式给出：\n$$\nC(S_0, v_0, T) = e^{-rT} \\mathbb{E}_{\\mathbb{Q}}[\\max(S_T - K, 0) | \\mathcal{F}_0]\n$$\n这个期望值可以通过傅里叶方法高效计算。价格可以分解为：\n$$\nC(S_0, K, T) = S_0 P_1 - K e^{-rT} P_2\n$$\n其中 $P_1$ 和 $P_2$ 是不同计价单位下的概率。Heston 表明，这些概率可以通过对数价格 $x_T = \\ln(S_T)$ 的条件特征函数进行逆变换来计算。基于 Gil-Pelaez 逆变换定理的公式为：\n$$\nP_j(\\phi; K) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Re}\\left[ \\frac{e^{-i\\phi \\ln K} f_j(\\phi)}{i\\phi} \\right] d\\phi\n$$\n对于 $j \\in \\{1, 2\\}$，其中 $f_j$ 是相关的特征函数。\n\n风险中性测度下对数价格 $x_T = \\ln(S_T)$ 的特征函数由 $f(\\phi) = \\mathbb{E}[e^{i\\phi x_T}]$ 给出。对于 Heston 模型，它有一个已知的半闭式形式：\n$$\nf(\\phi, T) = \\exp(C(\\phi, T) + D(\\phi, T)v_0 + i\\phi (\\ln S_0 + rT))\n$$\n其中\n$$\nC(\\phi, T) = \\frac{\\kappa\\theta}{\\nu^2} \\left[ (\\kappa - \\rho\\nu i\\phi - d)T - 2\\ln\\left(\\frac{1 - ge^{-dT}}{1-g}\\right) \\right]\n$$\n$$\nD(\\phi, T) = \\frac{\\kappa - \\rho\\nu i\\phi - d}{\\nu^2} \\left(\\frac{1 - e^{-dT}}{1-ge^{-dT}}\\right)\n$$\n带有辅助变量：\n$$\nd = \\sqrt{(\\kappa - \\rho\\nu i\\phi)^2 + (\\phi^2 + i\\phi)\\nu^2}\n$$\n$$\ng = \\frac{\\kappa - \\rho\\nu i\\phi - d}{\\kappa - \\rho\\nu i\\phi + d}\n$$\n$P_1$ 和 $P_2$ 所需的特征函数是：\n- $f_2(\\phi) = f(\\phi, T)$：风险中性测度下 $\\ln(S_T)$ 的特征函数。\n- $f_1(\\phi) = f(\\phi-i, T)$：一个相关的特征函数，对应于股票计价单位。这等价于用 $\\phi-i$ 替换 $\\phi$ 来评估 $f(\\phi, T)$。\n\n$P_1$ 和 $P_2$ 的积分使用求积法进行数值计算，`scipy.integrate.quad` 适用于此目的。\n\n**2. 校准过程**\n\n校准旨在找到参数 $(\\hat{\\rho}, \\hat{\\nu})$，使模型的输出与一组观测到的市场价格最佳匹配。问题规定，这些“观测”价格是使用相同的定价模型和已知的真实参数合成生成的。\n\n设 $\\Theta = (\\rho, \\nu)$ 是待校准的参数向量。设用于校准的期权集由 $i=1, \\dots, N$ 索引，其执行价为 $K_i$，到期日为 $T_i$。\n要最小化的目标函数是平方误差和 (SSE)：\n$$\n\\text{SSE}(\\Theta) = \\sum_{i=1}^{N} \\left[ C_{\\text{model}}(K_i, T_i; \\Theta) - C_{\\text{observed}}(K_i, T_i) \\right]^2\n$$\n其中 $C_{\\text{model}}$ 是我们 Heston 定价器的价格，$C_{\\text{observed}}$ 是合成的目标价格。\n\n这个最小化是一个带盒约束的非线性最小二乘问题：\n$$\n-0.999 \\le \\rho \\le 0.999 \\quad \\text{and} \\quad 10^{-4} \\le \\nu \\le 2.0\n$$\n我们采用 `scipy.optimize.minimize` 中可用的 L-BFGS-B 算法，这是一种非常适合此类约束优化问题的拟牛顿法。对于 $\\rho$ 的严格不等式，我们通过使用指定的值作为包含边界来处理，这是一种标准做法。\n\n**3. 算法实现**\n\n总体算法如下：\n1. 对于提供的三个测试案例中的每一个：\n    a. 定义共享参数 $(S_0, r, \\kappa, \\theta, v_0)$ 以及股票 A 的真实参数 $(\\rho_A, \\nu_A)$ 和股票 B 的真实参数 $(\\rho_B, \\nu_B)$。\n    b. 根据指定的到期日和执行价乘数，构建包含 $3 \\times 4 = 12$ 个看涨期权的期权网格。\n    c. 对于股票 A：\n        i. 使用真实参数 $(\\rho_A, \\nu_A)$ 通过 Heston 定价器生成 12 个“观测”价格。\n        ii. 定义一个目标函数，用于计算给定参数对 $(\\rho, \\nu)$ 的 SSE。\n        iii. 使用 `scipy.optimize.minimize`，配合 L-BFGS-B 方法、边界和一个合理的初始猜测（例如 $\\rho=-0.5, \\nu=0.5$）来找到校准后的参数 $\\hat{\\rho}_A$ 和 $\\hat{\\nu}_A$。\n    d. 对于股票 B：\n        i. 使用真实参数 $(\\rho_B, \\nu_B)$ 重复 (c) 中的过程，以找到校准后的参数 $\\hat{\\rho}_B$ 和 $\\hat{\\nu}_B$。\n    e. 计算绝对差值 $d_{\\rho} = |\\hat{\\rho}_A - \\hat{\\rho}_B|$ 和 $d_{\\nu} = |\\hat{\\nu}_A - \\hat{\\nu}_B|$。\n2. 收集六个得到的差值 ($d_{\\rho}^{(1)}, d_{\\nu}^{(1)}, d_{\\rho}^{(2)}, d_{\\nu}^{(2)}, d_{\\rho}^{(3)}, d_{\\nu}^{(3)}$)。\n3. 将这些值格式化为逗号分隔的数字字符串，每个数字四舍五入到六位小数，并用方括号括起来。这是最终的输出。\n这个确定性程序严格遵守了问题要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the Heston model calibration problem.\n    \"\"\"\n\n    def heston_char_func(phi, T, r, kappa, theta, nu, rho, v0, S0):\n        \"\"\"\n        Computes the Heston characteristic function for the log-price ln(S_T).\n        f(phi, T) = E[exp(i*phi*ln(S_T))]\n        \"\"\"\n        x0 = np.log(S0)\n        \n        # d and g are auxiliary variables in the Heston characteristic function\n        d = np.sqrt((kappa - rho * nu * 1j * phi)**2 + (phi**2 + 1j * phi) * nu**2)\n        g = (kappa - rho * nu * 1j * phi - d) / (kappa - rho * nu * 1j * phi + d)\n        \n        # C and D are the main components of the characteristic function's exponent\n        C = r * 1j * phi * T + (kappa * theta / nu**2) * \\\n            ((kappa - rho * nu * 1j * phi - d) * T - 2 * np.log((1 - g * np.exp(-d * T)) / (1 - g)))\n        \n        D = (kappa - rho * nu * 1j * phi - d) / nu**2 * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        \n        return np.exp(C + D * v0 + 1j * phi * x0)\n\n    def heston_price_integrand(phi, j, S0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Computes the integrand for calculating P_j in the Heston pricing formula.\n        j=1 or j=2.\n        \"\"\"\n        if j == 1:\n            # Use characteristic function f(phi-i) for P1\n            char_val = heston_char_func(phi - 1j, T, r, kappa, theta, nu, rho, v0, S0)\n        else: # j == 2\n            # Use characteristic function f(phi) for P2\n            char_val = heston_char_func(phi, T, r, kappa, theta, nu, rho, v0, S0)\n        \n        integrand = np.real(np.exp(-1j * phi * np.log(K)) * char_val / (1j * phi))\n        return integrand\n        \n    def heston_call_price(S0, K, T, r, kappa, theta, nu, rho, v0):\n        \"\"\"\n        Calculates the Heston European call price using Fourier inversion.\n        \"\"\"\n        # Integration limit for the semi-infinite integral\n        integration_limit = 200.0\n\n        # Integral for P1\n        args1 = (1, S0, K, T, r, kappa, theta, nu, rho, v0)\n        integral1, _ = quad(heston_price_integrand, 0, integration_limit, args=args1)\n        P1 = 0.5 + integral1 / np.pi\n\n        # Integral for P2\n        args2 = (2, S0, K, T, r, kappa, theta, nu, rho, v0)\n        integral2, _ = quad(heston_price_integrand, 0, integration_limit, args=args2)\n        P2 = 0.5 + integral2 / np.pi\n        \n        price = S0 * P1 - K * np.exp(-r * T) * P2\n        return price\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.01, \"kappa\": 1.5, \"theta\": 0.04, \"v0\": 0.04},\n            \"A\": {\"rho\": -0.7, \"nu\": 0.6},\n            \"B\": {\"rho\": -0.6, \"nu\": 0.55}\n        },\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.005, \"kappa\": 2.0, \"theta\": 0.03, \"v0\": 0.03},\n            \"A\": {\"rho\": -0.95, \"nu\": 0.3},\n            \"B\": {\"rho\": -0.90, \"nu\": 0.28}\n        },\n        {\n            \"shared\": {\"S0\": 100, \"r\": 0.02, \"kappa\": 1.2, \"theta\": 0.05, \"v0\": 0.05},\n            \"A\": {\"rho\": -0.5, \"nu\": 0.9},\n            \"B\": {\"rho\": -0.48, \"nu\": 1.0}\n        }\n    ]\n    \n    # Define the option grid structure\n    maturities = [0.25, 0.5, 1.0]\n    strike_multipliers = [0.8, 0.9, 1.1, 1.2]\n    \n    results = []\n    \n    for case in test_cases:\n        shared_params = case[\"shared\"]\n        S0, r, kappa, theta, v0 = shared_params.values()\n        \n        params_A_truth = case[\"A\"]\n        params_B_truth = case[\"B\"]\n        \n        # Construct the option grid for this case\n        option_grid = []\n        for T in maturities:\n            for mult in strike_multipliers:\n                K = S0 * mult\n                option_grid.append({\"T\": T, \"K\": K})\n\n        calibrated_params = {}\n        for stock_label, truth_params in [(\"A\", params_A_truth), (\"B\", params_B_truth)]:\n            \n            # 1. Generate synthetic \"observed\" prices\n            observed_prices = np.array([\n                heston_call_price(S0, opt['K'], opt['T'], r, kappa, theta,\n                                   truth_params['nu'], truth_params['rho'], v0)\n                for opt in option_grid\n            ])\n            \n            # 2. Define the objective function for minimization\n            def objective_function(params):\n                rho, nu = params\n                model_prices = np.array([\n                    heston_call_price(S0, opt['K'], opt['T'], r, kappa, theta, nu, rho, v0)\n                    for opt in option_grid\n                ])\n                return np.sum((model_prices - observed_prices)**2)\n\n            # 3. Calibrate parameters rho and nu\n            initial_guess = [-0.5, 0.5]\n            bounds = ((-0.999, 0.999), (1e-4, 2.0))\n            \n            opt_result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds)\n            \n            calibrated_params[stock_label] = opt_result.x\n\n        rho_A_cal, nu_A_cal = calibrated_params[\"A\"]\n        rho_B_cal, nu_B_cal = calibrated_params[\"B\"]\n        \n        # 4. Compute and store absolute differences\n        d_rho = abs(rho_A_cal - rho_B_cal)\n        d_nu = abs(nu_A_cal - nu_B_cal)\n        \n        results.append(d_rho)\n        results.append(d_nu)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}