{
    "hands_on_practices": [
        {
            "introduction": "模拟未来价格路径最直接的方法之一是假设“历史会重演”。本练习将指导您使用自助法（bootstrapping）从历史收益率中抽样，以构建数千条可能的价格路径。通过这个练习 ()，您将亲手实现一个非参数蒙特卡洛模拟，并计算在险价值（Value-at-Risk, VaR），这是理解基于模拟的风险度量的基础。",
            "id": "2412304",
            "problem": "给定一个在离散时间步上定义的价格过程，其初始价格为 $S_0 \\in \\mathbb{R}_{+}$。在每个时间步 $t \\in \\{1,2,\\dots,H\\}$，简单收益率 $r_t$ 是从一个给定的有限历史简单收益率集合 $\\{r^{(1)}, r^{(2)}, \\dots, r^{(m)}\\}$ 所支持的经验分布中独立抽取的，每个支持点的抽取概率相等，为 $1/m$。价格通过简单复利演变，因此 $S_{t} = S_{t-1}\\,(1 + r_t)$，其中 $t=1,\\dots,H$。对于一个固定的时间范围 $H \\in \\mathbb{N}_0$，在此模型下模拟 $N \\in \\mathbb{N}$ 个独立的终端价格，以获得终端价格样本 $\\{S_H^{(i)}\\}_{i=1}^N$。将路径 $i$ 上的损失定义为 $L^{(i)} = S_0 - S_H^{(i)}$（正值表示损失）。对于给定的概率水平 $q \\in [0,1]$，将风险价值 (VaR) 定义为损失分布的样本 $q$-分位数。具体来说，如果 $L_{(1)} \\le \\dots \\le L_{(N)}$ 是排序后的损失，且 $h = (N-1)\\,q + 1$，其中 $k = \\lfloor h \\rfloor$ 且 $\\gamma = h - k$，则\n$$\n\\operatorname{VaR}_q =\n\\begin{cases}\nL_{(k)} + \\gamma \\big(L_{(k+1)} - L_{(k)}\\big),  & \\text{if } 1 \\le k  N, \\\\\nL_{(N)},   \\text{if } k \\ge N.\n\\end{cases}\n$$\n如果 $N=1$，则 $\\operatorname{VaR}_q = L_{(1)}$。所有收益率必须被视为以小数表示的简单收益率（例如，$0.01$ 表示百分之一），并且 VaR 必须表示为与 $S_0$ 相同货币单位的浮点数（而不是比例）。对每个测试用例使用指定的伪随机种子来初始化随机数生成器，以确保结果是可复现的。如果 $H=0$，则将其解释为一个退化时间范围，此时几乎必然有 $S_H = S_0$。\n\n您的任务是为以下每个测试用例计算 $\\operatorname{VaR}_q$。最终输出必须是单行文本，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例相同。每个结果必须四舍五入到六位小数。\n\n测试套件：\n1) $S_0 = 100.0$，历史收益率 $[ -0.03,\\,-0.01,\\,0.0,\\,0.005,\\,0.01,\\,0.015,\\,0.02,\\,0.03 ]$，$H = 5$，$N = 20000$，$q = 0.99$，种子 $= 202311$。\n2) $S_0 = 250.0$，历史收益率 $[ -0.02,\\,-0.015,\\,-0.01,\\,-0.005,\\,0.0,\\,0.005,\\,0.01,\\,0.015 ]$，$H = 10$，$N = 15000$，$q = 0.95$，种子 $= 42$。\n3) $S_0 = 100.0$，历史收益率 $[ -0.02,\\,0.0,\\,0.02 ]$，$H = 1$，$N = 100000$，$q = 0.5$，种子 $= 7$。\n4) $S_0 = 123.45$，历史收益率 $[ -0.01,\\,0.0,\\,0.01,\\,0.02 ]$，$H = 0$，$N = 10000$，$q = 0.99$，种子 $= 99$。\n5) $S_0 = 80.0$，历史收益率 $[ -0.05,\\,-0.01,\\,0.0,\\,0.02,\\,0.04 ]$，$H = 3$，$N = 1$，$q = 0.975$，种子 $= 555$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4,result5]\"），其中每个结果是四舍五入到六位小数的风险价值。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、适定且完整的。它提出了一个标准的计算金融任务：使用非参数蒙特卡罗模拟来估计风险价值。我们现在将进行正式的求解。\n\n问题的核心是为一个初始值为 $S_0$ 的金融头寸估计风险价值 ($\\operatorname{VaR}_q$)。价格过程 $S_t$ 在离散时间步 $t \\in \\{1, 2, \\dots, H\\}$ 上演变。其演变由简单收益率 $r_t$ 驱动，这些收益率被建模为独立同分布的随机变量。它们的分布是给定的一组 $m$ 个历史收益率 $\\{r^{(1)}, r^{(2)}, \\dots, r^{(m)}\\}$ 的经验分布，其中每个历史收益率以 $1/m$ 的概率被抽中。\n\n在时间 $t$ 的价格由简单复利法则给出：\n$$\nS_t = S_{t-1} (1 + r_t)\n$$\n从初始价格 $S_0$ 开始，在时间范围 $H$ 的终端价格是 $H$ 次连续乘法的结果：\n$$\nS_H = S_0 \\prod_{t=1}^{H} (1 + r_t)\n$$\n与价格路径相关的损失定义为初始价格与终端价格之差：\n$$\nL = S_0 - S_H\n$$\n$L$ 的正值对应于货币损失。\n\n为了估计作为损失分布的 $q$-分位数的 $\\operatorname{VaR}_q$，我们采用蒙特卡罗方法。这涉及到模拟价格过程的 $N$ 条独立路径。对于每个模拟路径 $i \\in \\{1, \\dots, N\\}$，我们生成一个由 $H$ 个随机收益率组成的序列 $\\{r_{i,t}\\}_{t=1}^H$，每个收益率都从指定的经验分布中抽取。这样就得到了一个包含 $N$ 个终端价格的样本：\n$$\nS_H^{(i)} = S_0 \\prod_{t=1}^{H} (1 + r_{i,t}) \\quad \\text{for } i=1, \\dots, N\n$$\n从这个终端价格样本中，我们计算出相应的损失样本：\n$$\nL^{(i)} = S_0 - S_H^{(i)} \\quad \\text{for } i=1, \\dots, N\n$$\n然后，$\\operatorname{VaR}_q$ 被计算为损失集合 $\\{L^{(i)}\\}_{i=1}^N$ 的样本 $q$-分位数。问题为样本分位数指定了一个基于线性插值的精确定义。令 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(N)}$ 为按非递减顺序排序的损失。分位数使用索引 $h = (N-1)q + 1$ 计算。令 $k = \\lfloor h \\rfloor$ 为整数部分，$\\gamma = h - k$ 为小数部分。$\\operatorname{VaR}_q$ 由以下公式给出：\n$$\n\\operatorname{VaR}_q = L_{(k)} + \\gamma (L_{(k+1)} - L_{(k)})\n$$\n对于 $1 \\le k  N$。如果 $k \\ge N$（这在 $q=1$ 时发生），则 $\\operatorname{VaR}_q = L_{(N)}$。这个定义等同于分位数的 `'linear'` 插值方法，这是 `numpy` 等数值计算库中可用的标准实现。\n\n该计算算法被设计为使用向量化操作以提高效率：\n1.  对于每个测试用例，初始化参数 $S_0$、历史收益率数组 $\\mathcal{R}$、时间范围 $H$、路径数 $N$、分位数水平 $q$ 和随机种子。\n2.  为确保可复现性，播种一个伪随机数生成器。\n3.  特殊情况 $H=0$ 意味着 $S_H = S_0$，因此损失总是 $0$，且 $\\operatorname{VaR}_q = 0.0$。\n4.  特殊情况 $N=1$ 需要仅模拟一条路径。由此产生的单个损失 $L^{(1)} = S_0 - S_H^{(1)}$ 根据定义就是 $\\operatorname{VaR}_q$。\n5.  在一般情况下（$H > 0, N > 1$），通过从历史收益率数组中有放回地抽样，生成一个 $N \\times H$ 的收益率矩阵。\n6.  这个收益率矩阵被转换为一个增长因子 $(1+r)$ 矩阵。沿每行（时间轴）对这些因子求积，得到一个总路径乘数向量。\n7.  将此向量乘以 $S_0$ 得到 $N$ 个终端价格的向量 $\\{S_H^{(i)}\\}$。\n8.  损失向量 $\\{L^{(i)}\\}$ 计算为 $S_0 - \\{S_H^{(i)}\\}$。\n9.  最后，将配置为线性插值的 `numpy.quantile` 函数应用于损失向量，并使用指定的分位数水平 $q$ 来计算 $\\operatorname{VaR}_q$。\n\n此过程被系统地应用于问题陈述中提供的每个测试用例。最终结果被四舍五入到指定的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Value-at-Risk (VaR) for several test cases using Monte Carlo simulation.\n    \"\"\"\n    test_cases = [\n        (100.0, [-0.03, -0.01, 0.0, 0.005, 0.01, 0.015, 0.02, 0.03], 5, 20000, 0.99, 202311),\n        (250.0, [-0.02, -0.015, -0.01, -0.005, 0.0, 0.005, 0.01, 0.015], 10, 15000, 0.95, 42),\n        (100.0, [-0.02, 0.0, 0.02], 1, 100000, 0.5, 7),\n        (123.45, [-0.01, 0.0, 0.01, 0.02], 0, 10000, 0.99, 99),\n        (80.0, [-0.05, -0.01, 0.0, 0.02, 0.04], 3, 1, 0.975, 555),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, hist_returns, H, N, q, seed = case\n        \n        # Handle the degenerate case where the horizon H is 0.\n        # The terminal price is S0, so the loss is always 0.\n        if H == 0:\n            var = 0.0\n            results.append(var)\n            continue\n            \n        rng = np.random.default_rng(seed)\n        hist_returns_arr = np.array(hist_returns)\n        \n        # Handle the case where only one path is simulated (N=1).\n        # The VaR is simply the loss from that single path.\n        if N == 1:\n            # Simulate one path of H steps.\n            returns_path = rng.choice(hist_returns_arr, size=H, replace=True)\n            # The problem defines simple compounding.\n            path_multiplier = np.prod(1 + returns_path)\n            S_H = S0 * path_multiplier\n            loss = S0 - S_H\n            var = loss\n            results.append(var)\n            continue\n\n        # General case for Monte Carlo simulation (H  0, N  1).\n        # Generate N x H matrix of random returns by choosing from historical returns.\n        returns_matrix = rng.choice(hist_returns_arr, size=(N, H), replace=True)\n        \n        # Calculate terminal prices for all N paths using vectorized operations.\n        # The product of (1 + r_t) is taken along the time axis (axis=1).\n        path_multipliers = np.prod(1 + returns_matrix, axis=1)\n        terminal_prices = S0 * path_multipliers\n        \n        # Calculate the distribution of losses.\n        losses = S0 - terminal_prices\n        \n        # Calculate VaR, which is the sample q-quantile of the loss distribution.\n        # The problem's VaR formula corresponds to numpy's 'linear' interpolation method.\n        var = np.quantile(losses, q, method='linear')\n        \n        results.append(var)\n\n    # Format the final output as a comma-separated list string, with each\n    # result rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然基础的历史模拟很有用，但它假设市场的波动性保持不变，这在现实中往往不成立。本练习 () 介绍了一种更动态的方法——过滤历史模拟（Filtered Historical Simulation）。该方法通过使用当前的市场波动性来调整历史数据，从而使风险评估更能反映当前的市场状况，这是一种在专业实践中广泛应用的VaR估算技术。",
            "id": "2412321",
            "problem": "实现一个程序，使用过滤历史模拟法计算线性投资组合的单日风险价值 (VaR)。从以下定义和假设开始：一个投资组合包含 $N$ 种资产，在时间 $t \\in \\{1,\\dots,T\\}$ 内，资产 $i \\in \\{1,\\dots,N\\}$ 的历史简单收益率为 $\\{r_{i,t}\\}$，对应时间的条件历史波动率为 $\\{\\sigma_{i,t}\\}$，当前的条件波动率向量为 $\\sigma_{i,0}$，以及总和为 $1$ 的固定投资组合权重 $w_i$。对于每个历史时间 $t$，定义标准化残差 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$，假设所有的 $\\sigma_{i,t}  0$。过滤历史模拟法通过将每个标准化的历史残差缩放到当前条件来构建一个经验情景集：情景 $t$ 中模拟的未来资产收益为 $\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$。情景 $t$ 中相应的投资组合收益为 $s_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t}$。将投资组合收益的经验 $\\alpha$-分位数定义为 $\\{s_t\\}_{t=1}^T$ 的第 $k$ 个顺序统计量，其中 $k = \\lceil \\alpha T \\rceil$（$\\lceil \\cdot \\rceil$ 表示向上取整函数），使用基于 1 的索引。将在 $\\alpha$ 水平下的单日 VaR 定义为 $\\text{VaR}_\\alpha = - q_\\alpha$，其中 $q_\\alpha$ 是 $\\{s_t\\}_{t=1}^T$ 的经验 $\\alpha$-分位数。所有收益率都必须作为无单位的小数值（而不是百分比）处理。\n\n您的任务是严格按照上述步骤实现程序，不进行任何重采样：直接使用 $T$ 个缩放后的情景 $\\{\\tilde{r}_{i,t}\\}$。使用以下三个测试用例；每个用例都是独立的，并应在相同的程序逻辑上进行评估：\n\n- 测试用例 1（双资产投资组合，基准当前波动率）：\n  - 历史收益率矩阵 $R \\in \\mathbb{R}^{T \\times N}$，其中 $T=5, N=2$：\n    - 行 $t=1$：$[-0.02,\\;0.01]$\n    - 行 $t=2$：$[0.01,\\;-0.005]$\n    - 行 $t=3$：$[-0.01,\\;0.015]$\n    - 行 $t=4$：$[0.02,\\;-0.01]$\n    - 行 $t=5$：$[-0.015,\\;0.005]$\n  - 历史条件波动率矩阵 $S \\in \\mathbb{R}_{0}^{T \\times N}$：\n    - 行 $t=1$：$[0.02,\\;0.01]$\n    - 行 $t=2$：$[0.01,\\;0.005]$\n    - 行 $t=3$：$[0.01,\\;0.015]$\n    - 行 $t=4$：$[0.02,\\;0.01]$\n    - 行 $t=5$：$[0.015,\\;0.005]$\n  - 权重 $w = [0.6,\\;0.4]$。\n  - 当前波动率 $\\sigma_0 = [0.03,\\;0.02]$。\n  - 水平 $\\alpha = 0.05$。\n\n- 测试用例 2（相同的历史和权重，较低的当前波动率，不同的 $\\alpha$）：\n  - $R$ 和 $S$ 与测试用例 1 相同。\n  - 权重 $w = [0.6,\\;0.4]$。\n  - 当前波动率 $\\sigma_0 = [0.015,\\;0.01]$。\n  - 水平 $\\alpha = 0.10$。\n\n- 测试用例 3（单资产边界情况）：\n  - 历史收益率向量 $R_A = [-0.02,\\;0.01,\\;-0.01,\\;0.02,\\;-0.015]$，其中 $T=5, N=1$。\n  - 历史条件波动率 $S_A = [0.02,\\;0.01,\\;0.01,\\;0.02,\\;0.015]$。\n  - 权重 $w = [1.0]$。\n  - 当前波动率 $\\sigma_0 = [0.04]$。\n  - 水平 $\\alpha = 0.20$。\n\n程序要求：\n- 严格按照定义实现：对于每个情景 $t$，计算 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$，然后计算 $\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$，接着计算 $s_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t}$。\n- 将经验 $\\alpha$-分位数计算为第 $k$ 小的值，其中 $k = \\lceil \\alpha T \\rceil$，然后计算 $\\text{VaR}_\\alpha = -q_\\alpha$。\n- 将每个测试用例的 VaR 报告为小数（无百分号），并四舍五入到六位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表（例如，“[x1,x2,x3]”），不含空格，并按测试用例 1、测试用例 2、测试用例 3 的顺序排列。\n\n您的程序必须是自包含的，且不得读取任何外部输入或文件。",
            "solution": "我们从风险计量和时变波动率建模的第一性原理推导出该算法。目标是使用过滤历史模拟法计算线性投资组合在 $\\alpha$ 水平下的单日风险价值 (VaR)。在 $\\alpha$ 水平下的风险价值 (VaR) 定义为一个数值 $\\text{VaR}_\\alpha$，使得在特定模型下，损失超过 $\\text{VaR}_\\alpha$ 的概率为 $\\alpha$。对于单日时间范围和线性投资组合，设投资组合收益为 $s$，一个常见的经验定义使用收益分布的 $\\alpha$-分位数的负值：令 $q_\\alpha$ 为收益的 $\\alpha$-分位数，则 $\\text{VaR}_\\alpha = - q_\\alpha$。\n\n为了构建过滤历史模拟法中的 $q_\\alpha$，我们从资产 $i \\in \\{1,\\dots,N\\}$ 在时间 $t \\in \\{1,\\dots,T\\}$ 内的历史简单收益率 $r_{i,t}$ 开始。我们假设每个历史时间 $t$ 都有一个条件波动率序列 $\\sigma_{i,t}  0$，以及一个当前的条件波动率 $\\sigma_{i,0}  0$。在条件异方差但标准化且平稳的创新过程的假设下，我们通过波动率对收益率进行标准化，得到 $z_{i,t} = r_{i,t} / \\sigma_{i,t}$。标准化残差 $z_{i,t}$ 被视为从一个均值为零、单位尺度的平稳分布中抽取的样本，它能捕捉到可能存在的偏度和峰度等特征。\n\n为了在不指定参数分布的情况下模拟当前条件下的未来资产收益，过滤历史模拟法将每个标准化残差按当前波动率进行缩放：$\\tilde{r}_{i,t} = \\sigma_{i,0} \\cdot z_{i,t}$。对于权重 $w_i$ 总和为 1 的线性投资组合，情景 $t$ 中的模拟投资组合收益为\n$$\ns_t = \\sum_{i=1}^N w_i \\tilde{r}_{i,t} = \\sum_{i=1}^N w_i \\sigma_{i,0} \\frac{r_{i,t}}{\\sigma_{i,t}}.\n$$\n这 $T$ 个值 $\\{s_t\\}_{t=1}^T$ 构成了经验情景集。将它们升序排序，$s_{(1)} \\le \\cdots \\le s_{(T)}$，经验 $\\alpha$-分位数定义为 $q_\\alpha = s_{(k)}$，其中 $k = \\lceil \\alpha T \\rceil$，使用基于 1 的索引。那么 VaR 就是 $\\text{VaR}_\\alpha = - q_\\alpha$。\n\n我们将此方法应用于三个指定的测试用例。\n\n测试用例 1：\n- $T=5, N=2$，历史收益率 $R$ 和历史波动率 $S$：\n  - $t=1$: $r_{1,1} = -0.02$, $r_{2,1} = 0.01$, $\\sigma_{1,1} = 0.02$, $\\sigma_{2,1} = 0.01$。\n  - $t=2$: $r_{1,2} = 0.01$, $r_{2,2} = -0.005$, $\\sigma_{1,2} = 0.01$, $\\sigma_{2,2} = 0.005$。\n  - $t=3$: $r_{1,3} = -0.01$, $r_{2,3} = 0.015$, $\\sigma_{1,3} = 0.01$, $\\sigma_{2,3} = 0.015$。\n  - $t=4$: $r_{1,4} = 0.02$, $r_{2,4} = -0.01$, $\\sigma_{1,4} = 0.02$, $\\sigma_{2,4} = 0.01$。\n  - $t=5$: $r_{1,5} = -0.015$, $r_{2,5} = 0.005$, $\\sigma_{1,5} = 0.015$, $\\sigma_{2,5} = 0.005$。\n- 标准化残差 $z_{1,t} = r_{1,t}/\\sigma_{1,t} \\in \\{-1, 1, -1, 1, -1\\}$ 和 $z_{2,t} = r_{2,t}/\\sigma_{2,t} \\in \\{1, -1, 1, -1, 1\\}$。\n- 权重 $w_1 = 0.6, w_2 = 0.4$，当前波动率 $\\sigma_{1,0} = 0.03, \\sigma_{2,0} = 0.02$。\n- 对于每个 $t$，$\\tilde{r}_{1,t} = 0.03 z_{1,t}$，$\\tilde{r}_{2,t} = 0.02 z_{2,t}$。因此 $s_t = 0.6 \\cdot \\tilde{r}_{1,t} + 0.4 \\cdot \\tilde{r}_{2,t} = 0.6 \\cdot 0.03 z_{1,t} + 0.4 \\cdot 0.02 z_{2,t} = 0.018 z_{1,t} + 0.008 z_{2,t}$。\n- 使用符号模式，我们得到 $s_t \\in \\{-0.01, 0.01, -0.01, 0.01, -0.01\\}$。排序后：$[-0.01, -0.01, -0.01, 0.01, 0.01]$。\n- 当 $\\alpha = 0.05$ 时，$k = \\lceil 0.05 \\cdot 5 \\rceil = \\lceil 0.25 \\rceil = 1$，所以 $q_\\alpha = -0.01$ 且 $\\text{VaR}_\\alpha = 0.01$。\n\n测试用例 2：\n- 与测试用例 1 相同的 $R, S$ 和 $w$。\n- 当前波动率减半：$\\sigma_{1,0} = 0.015, \\sigma_{2,0} = 0.01$；因此 $\\tilde{r}_{1,t} = 0.015 z_{1,t}, \\tilde{r}_{2,t} = 0.01 z_{2,t}$ 且 $s_t = 0.6 \\cdot 0.015 z_{1,t} + 0.4 \\cdot 0.01 z_{2,t} = 0.009 z_{1,t} + 0.004 z_{2,t}$。\n- 使用相同的符号模式，$s_t \\in \\{-0.005, 0.005, -0.005, 0.005, -0.005\\}$。排序后：$[-0.005, -0.005, -0.005, 0.005, 0.005]$。\n- 当 $\\alpha = 0.10$ 时，$k = \\lceil 0.10 \\cdot 5 \\rceil = \\lceil 0.5 \\rceil = 1$，所以 $q_\\alpha = -0.005$ 且 $\\text{VaR}_\\alpha = 0.005$。\n\n测试用例 3：\n- 单一资产，$R_A = [-0.02, 0.01, -0.01, 0.02, -0.015]$, $S_A = [0.02, 0.01, 0.01, 0.02, 0.015]$，所以 $z_{1,t} \\in \\{-1, 1, -1, 1, -1\\}$。\n- 权重 $w_1 = 1.0$，当前波动率 $\\sigma_{1,0} = 0.04$，得到 $\\tilde{r}_{1,t} = 0.04 z_{1,t}$ 且 $s_t = \\tilde{r}_{1,t} \\in \\{-0.04, 0.04, -0.04, 0.04, -0.04\\}$。\n- 排序后：$[-0.04, -0.04, -0.04, 0.04, 0.04]$。\n- 当 $\\alpha = 0.20$ 时，$k = \\lceil 0.20 \\cdot 5 \\rceil = \\lceil 1.0 \\rceil = 1$，所以 $q_\\alpha = -0.04$ 且 $\\text{VaR}_\\alpha = 0.04$。\n\n实现细节：\n- 逐元素计算 $z_{i,t}$ 为 $r_{i,t}/\\sigma_{i,t}$。\n- 对于每个 $t$，使用给定的 $w_i$ 和 $\\sigma_{i,0}$ 计算 $s_t$。\n- 将 $\\{s_t\\}$ 升序排序，并取第 $k$ 个元素，其中 $k = \\lceil \\alpha T \\rceil$。\n- 为每个测试用例输出 $\\text{VaR}_\\alpha = - q_\\alpha$，四舍五入到六位小数。\n- 生成单行输出：一个方括号括起来的逗号分隔列表，按测试用例 1、测试用例 2、测试用例 3 的顺序排列。\n\n根据以上推导，三个测试用例的预期 VaR 输出分别为 $0.01$, $0.005$ 和 $0.04$，每个都表示为小数并四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef empirical_var_fhs(R, S, w, sigma_now, alpha):\n    \"\"\"\n    Filtered Historical Simulation VaR:\n    - R: array of shape (T, N) historical returns\n    - S: array of shape (T, N) historical conditional volatilities (0)\n    - w: array of shape (N,) portfolio weights summing to 1\n    - sigma_now: array of shape (N,) current conditional volatilities (0)\n    - alpha: float in (0,1), VaR level\n    Returns VaR as a positive float (-alpha-quantile of returns).\n    \"\"\"\n    R = np.asarray(R, dtype=float)\n    S = np.asarray(S, dtype=float)\n    w = np.asarray(w, dtype=float)\n    sigma_now = np.asarray(sigma_now, dtype=float)\n    T, N = R.shape\n    assert S.shape == (T, N)\n    assert w.shape == (N,)\n    assert sigma_now.shape == (N,)\n    assert np.all(S > 0), \"Historical sigmas must be > 0\"\n    assert np.all(sigma_now > 0), \"Current sigmas must be > 0\"\n    # Standardized residuals z_{i,t}\n    Z = R / S\n    # Scaled returns under current volatility: \\tilde r_{i,t} = sigma_now[i] * Z[t,i]\n    # Portfolio return per scenario t: s_t = sum_i w_i * \\tilde r_{i,t}\n    scaled = Z * sigma_now  # shape (T, N)\n    s = scaled @ w  # shape (T,)\n    # Empirical alpha-quantile using k = ceil(alpha * T), 1-based\n    s_sorted = np.sort(s)\n    k = int(np.ceil(alpha * T))\n    k = max(k, 1)  # ensure at least first order statistic\n    q_alpha = s_sorted[k - 1]\n    var = -q_alpha\n    return var\n\ndef solve():\n    results = []\n\n    # Test Case 1\n    R1 = np.array([\n        [-0.02,   0.01 ],\n        [ 0.01,  -0.005],\n        [-0.01,   0.015],\n        [ 0.02,  -0.01 ],\n        [-0.015,  0.005]\n    ], dtype=float)\n    S1 = np.array([\n        [0.02,  0.01 ],\n        [0.01,  0.005],\n        [0.01,  0.015],\n        [0.02,  0.01 ],\n        [0.015, 0.005]\n    ], dtype=float)\n    w1 = np.array([0.6, 0.4], dtype=float)\n    sigma_now1 = np.array([0.03, 0.02], dtype=float)\n    alpha1 = 0.05\n    var1 = empirical_var_fhs(R1, S1, w1, sigma_now1, alpha1)\n    results.append(var1)\n\n    # Test Case 2\n    sigma_now2 = np.array([0.015, 0.01], dtype=float)\n    alpha2 = 0.10\n    var2 = empirical_var_fhs(R1, S1, w1, sigma_now2, alpha2)\n    results.append(var2)\n\n    # Test Case 3 (single asset)\n    R3 = np.array([[-0.02],\n                   [ 0.01],\n                   [-0.01],\n                   [ 0.02],\n                   [-0.015]], dtype=float)\n    S3 = np.array([[0.02],\n                   [0.01],\n                   [0.01],\n                   [0.02],\n                   [0.015]], dtype=float)\n    w3 = np.array([1.0], dtype=float)\n    sigma_now3 = np.array([0.04], dtype=float)\n    alpha3 = 0.20\n    var3 = empirical_var_fhs(R3, S3, w3, sigma_now3, alpha3)\n    results.append(var3)\n\n    # Print in exact required format: single line, comma-separated, no spaces, in brackets\n    # Each result must be rounded to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个理想的风险度量应该能够体现投资组合多样化带来的好处，即组合风险不应超过其各组成部分风险之和。然而，在险价值（VaR）在某些情况下并不满足这一被称为“次可加性”（subadditivity）的原则。在本练习 () 中，您将通过构建具体的投资组合案例，亲手验证 VaR 的这一理论缺陷，从而深刻理解为何需要更先进的、满足一致性公理的风险度量。",
            "id": "2412240",
            "problem": "构建一个独立的程序，从第一性原理出发，计算在险价值（VaR）在特定定义的情况下是否具有次可加性。设损失为一个实值随机变量。对于一个损失随机变量 $X$，其累积分布函数为 $F_X(x)$，以及一个水平 $\\alpha \\in (0,1)$，将在水平 $\\alpha$ 的在险价值定义为\n$$\n\\operatorname{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_X(x) \\ge \\alpha\\}.\n$$\n给定来自 $X$ 的一个独立同分布样本 $L_1,\\dots,L_n$，定义经验分布函数 $F_n(x) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{L_i \\le x\\}$ 和经验在险价值估计量\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}.\n$$\n对于下面的每个测试用例，考虑两个损失随机变量 $A$ 和 $B$，并定义投资组合损失 $P = A + B$。对于每个测试用例 $j$，计算布尔结果\n$$\nI_j = \\big[\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)\\big].\n$$\n所有用例均使用相同的样本量 $n$ 和相同的固定伪随机种子 $s$。所有概率都应解释为 $[0,1]$ 内的小数。不适用任何物理单位。\n\n您的程序必须实现以下测试套件。在所有用例中，抽样数量为 $n = 400{,}000$，伪随机种子为 $s = 20231407$。所有伯努利事件和标准正态变量都必须根据指定的依赖结构进行抽取。\n\n- 测试用例 1（独立，罕见大额损失）：$\\alpha = 0.95$。资产 $A$ 有 $0.03$ 的概率损失 $10$，否则损失 $0$。资产 $B$ 具有相同的分布。$A$ 和 $B$ 是独立的。\n- 测试用例 2（独立，不对称罕见损失）：$\\alpha = 0.975$。资产 $A$ 有 $0.02$ 的概率损失 $8$，否则损失 $0$。资产 $B$ 有 $0.02$ 的概率损失 $12$，否则损失 $0$。$A$ 和 $B$ 是独立的。\n- 测试用例 3（共单调罕见损失）：$\\alpha = 0.95$。资产 $A$ 有 $0.03$ 的概率损失 $10$，否则损失 $0$。资产 $B$ 具有相同的边际分布。其依赖关系是共单调的：存在一个在 $[0,1]$ 上的均匀分布变量 $U$，当且仅当 $U  0.03$ 时，$A$ 和 $B$ 都等于其损失水平，否则两者都等于 $0$。\n- 测试用例 4（相关高斯损失）：$\\alpha = 0.99$。资产 $A$ 是均值为 $0$、标准差为 $1$ 的高斯分布。资产 $B$ 是均值为 $0$、标准差为 $1.2$ 的高斯分布。$A$ 和 $B$ 之间的相关性为 $0.6$。\n- 测试用例 5（完全负相关高斯损失）：$\\alpha = 0.99$。资产 $A$ 是均值为 $0$、标准差为 $1$ 的高斯分布。资产 $B$ 几乎必然等于 $-A$（完全负相关），因此投资组合损失恒等于 $0$。\n\n对于每个用例，生成完全符合所述分布和依赖关系的 $n$ 对抽样 $(A_i,B_i)$。使用上面 $\\widehat{\\operatorname{VaR}}_{\\alpha}$ 的定义，计算 $A$、$B$ 和 $P = A+B$ 在指定 $\\alpha$ 水平下的经验在险价值。然后按定义计算 $I_j$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[true,false,true,true,false]”），但使用大写的 Python 布尔文字。也就是说，确切的输出格式必须是“[result1,result2,result3,result4,result5]”，其中每个结果为“True”或“False”。",
            "solution": "该问题要求对在险价值（$\\operatorname{VaR}$）度量的次可加性进行计算研究。如果对于任意两个损失随机变量 $X$ 和 $Y$，不等式 $\\rho(X+Y) \\le \\rho(X) + \\rho(Y)$ 成立，则风险度量 $\\rho$ 被定义为次可加的。此属性将分散化原则形式化：合并投资组合的风险不应大于其各个组成部分风险的总和。在险价值是一种广泛使用的风险度量，但它不是 Artzner 等人 (1999) 意义上的一致性风险度量，这恰恰是因为它可能不满足次可加性。本练习通过具体的、构造的例子来证明这种失效情况。\n\n任务是为五个不同的测试用例计算不等式 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)$ 的布尔结果，其中 $A$ 和 $B$ 是损失随机变量，$P=A+B$ 是投资组合损失，而 $\\widehat{\\operatorname{VaR}}_{\\alpha}$ 是在置信水平 $\\alpha$ 下的经验在险价值估计量。\n\n经验 $\\operatorname{VaR}$ 定义为 $\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R} : F_n(x) \\ge \\alpha\\}$，其中 $F_n(x)$ 是来自大小为 $n$ 的样本的经验累积分布函数。对于一个损失样本 $L_1, \\dots, L_n$，设排序后的样本为 $L_{(1)} \\le L_{(2)} \\le \\dots \\le L_{(n)}$。经验 CDF $F_n(x)$ 是一个阶梯函数，在每个数据点处跳跃 $1/n$。条件 $F_n(x) \\ge \\alpha$ 等价于说至少有 $n\\alpha$ 个样本点小于或等于 $x$。这意味着 $x$ 必须至少与第 $\\lceil n\\alpha \\rceil$ 个顺序统计量一样大。因此，经验 VaR 正是该顺序统计量的值：\n$$\n\\widehat{\\operatorname{VaR}}_{\\alpha}(X) = L_{(\\lceil n\\alpha \\rceil)}\n$$\n我们对每个测试用例的通用流程如下：\n1.  使用固定种子 $s = 20231407$ 初始化一个伪随机数生成器。\n2.  根据指定的边际分布和依赖结构，为 $i=1, \\dots, n$ 生成一个大小为 $n = 400,000$ 的成对抽样样本 $(A_i, B_i)$。\n3.  创建投资组合损失样本 $P_i = A_i + B_i$。\n4.  对于三个样本 $\\{A_i\\}$、$\\{B_i\\}$ 和 $\\{P_i\\}$ 中的每一个，计算在指定水平 $\\alpha$ 下的经验 $\\operatorname{VaR}$。这包括对样本进行排序，并选择索引为 $k-1$（使用基于 0 的索引）的元素，其中 $k = \\lceil n\\alpha \\rceil$。\n5.  评估布尔表达式 $I_j = [\\widehat{\\operatorname{VaR}}_{\\alpha}(P) > \\widehat{\\operatorname{VaR}}_{\\alpha}(A) + \\widehat{\\operatorname{VaR}}_{\\alpha}(B)]$。\n\n每个用例的具体生成方法如下：\n\n测试用例 1（独立，罕见大额损失）：$\\alpha = 0.95$。$A$ 和 $B$ 的损失是从伯努利分布中抽取的，表示以概率 $p=0.03$ 发生损失 $10$，否则损失为 $0$。独立性通过使用两个独立的均匀随机数流 $U_A$ 和 $U_B$ 来为 $A$ 和 $B$ 生成样本来建模。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_{A,i}  0.03$，则 $A_i=10$，否则 $A_i=0$，对于 $B_i$ 也使用 $U_{B,i}$ 进行类似操作。VaR 计算的索引是 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试用例 2（独立，不对称罕见损失）：$\\alpha = 0.975$。此用例在结构上与第一个相似，但参数不对称。资产 $A$ 以 $0.02$ 的概率发生损失 $8$，资产 $B$ 以 $0.02$ 的概率发生损失 $12$。独立性再次通过独立的随机数流进行建模。VaR 索引为 $k = \\lceil 400,000 \\times 0.975 \\rceil = 390,000$。\n\n测试用例 3（共单调罕见损失）：$\\alpha = 0.95$。$A$ 和 $B$ 的边际分布与用例 1 相同。但是，依赖关系是共单调的。这通过使用单一的均匀随机数流 $U$ 来建模。对于每个 $i \\in \\{1, \\dots, n\\}$，如果 $U_i  0.03$，则 $A_i$ 和 $B_i$ 都设为 $10$，否则都为 $0$。这表示尾部事件中的完全正相关。VaR 索引为 $k = \\lceil 400,000 \\times 0.95 \\rceil = 380,000$。\n\n测试用例 4（相关高斯损失）：$\\alpha = 0.99$。$A \\sim \\mathcal{N}(0, 1^2)$ 且 $B \\sim \\mathcal{N}(0, 1.2^2)$，相关性为 $\\rho(A, B) = 0.6$。我们从此二元正态分布中生成成对样本。这可以通过首先生成成对的独立标准正态变量 $(Z_{1,i}, Z_{2,i})$，然后应用与协方差矩阵 $\\Sigma$ 的 Cholesky分解相对应的线性变换来实现：\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_A^2  \\rho \\sigma_A \\sigma_B \\\\ \\rho \\sigma_A \\sigma_B  \\sigma_B^2 \\end{pmatrix} = \\begin{pmatrix} 1  0.72 \\\\ 0.72  1.44 \\end{pmatrix}\n$$\n一个更简单、等价的构造是 $A_i = Z_{1,i}$ 和 $B_i = \\sigma_B (\\rho Z_{1,i} + \\sqrt{1-\\rho^2} Z_{2,i})$。VaR 索引是 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。对于像多元正态分布这样的椭圆分布，已知 VaR 是次可加的。\n\n测试用例 5（完全负相关高斯损失）：$\\alpha = 0.99$。资产 $A \\sim \\mathcal{N}(0, 1^2)$ 且 $B = -A$。这是一个完美对冲的案例。我们为 $A$ 生成一个标准正态变量样本，并将 $B$ 的样本设置为其逐元素的负值。投资组合损失 $P = A+B = 0$ 对所有结果都成立。因此，其经验 $\\widehat{\\operatorname{VaR}}_{\\alpha}(P)$ 必须为 $0$。VaR 索引为 $k = \\lceil 400,000 \\times 0.99 \\rceil = 396,000$。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes whether Value-at-Risk (VaR) is subadditive in five specific cases.\n    \"\"\"\n    \n    # Global parameters\n    N_SAMPLES = 400_000\n    SEED = 20231407\n    \n    # Initialize a single random number generator for all simulations\n    rng = np.random.default_rng(SEED)\n\n    test_cases = [\n        # Case 1: Independent, rare large losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"independent\"\n        },\n        # Case 2: Independent, asymmetric rare losses\n        {\n            \"alpha\": 0.975,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 8.0, \"p\": 0.02},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 12.0, \"p\": 0.02},\n            \"dep\": \"independent\"\n        },\n        # Case 3: Comonotonic rare losses\n        {\n            \"alpha\": 0.95,\n            \"A\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"B\": {\"type\": \"bernoulli\", \"loss\": 10.0, \"p\": 0.03},\n            \"dep\": \"comonotonic\"\n        },\n        # Case 4: Correlated Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.2},\n            \"dep\": \"correlated\", \"rho\": 0.6\n        },\n        # Case 5: Perfectly negatively dependent Gaussian losses\n        {\n            \"alpha\": 0.99,\n            \"A\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"B\": {\"type\": \"gaussian\", \"mean\": 0.0, \"std\": 1.0},\n            \"dep\": \"negatively_dependent\"\n        }\n    ]\n\n    results = []\n\n    def get_empirical_var(samples, alpha):\n        \"\"\"\n        Calculates the empirical Value-at-Risk.\n        Defined as the k-th order statistic, where k = ceil(n*alpha).\n        \"\"\"\n        n = len(samples)\n        k = math.ceil(n * alpha)\n        # Using k-1 for 0-based indexing\n        sorted_samples = np.sort(samples)\n        return sorted_samples[k - 1]\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        \n        # --- Generate samples for A and B based on the case ---\n        if case[\"dep\"] == \"independent\":\n            u_a = rng.random(size=N_SAMPLES)\n            u_b = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u_a  params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u_b  params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"comonotonic\":\n            u = rng.random(size=N_SAMPLES)\n            params_a = case[\"A\"]\n            samples_a = np.where(u  params_a[\"p\"], params_a[\"loss\"], 0.0)\n            params_b = case[\"B\"]\n            samples_b = np.where(u  params_b[\"p\"], params_b[\"loss\"], 0.0)\n\n        elif case[\"dep\"] == \"correlated\":\n            params_a = case[\"A\"]\n            params_b = case[\"B\"]\n            rho = case[\"rho\"]\n            \n            mean = [params_a[\"mean\"], params_b[\"mean\"]]\n            cov = [[params_a[\"std\"]**2, rho * params_a[\"std\"] * params_b[\"std\"]],\n                   [rho * params_a[\"std\"] * params_b[\"std\"], params_b[\"std\"]**2]]\n            \n            samples = rng.multivariate_normal(mean, cov, size=N_SAMPLES)\n            samples_a = samples[:, 0]\n            samples_b = samples[:, 1]\n            \n        elif case[\"dep\"] == \"negatively_dependent\":\n            params_a = case[\"A\"]\n            samples_a = rng.normal(loc=params_a[\"mean\"], scale=params_a[\"std\"], size=N_SAMPLES)\n            samples_b = -samples_a\n        \n        # --- Create portfolio samples ---\n        samples_p = samples_a + samples_b\n        \n        # --- Calculate VaR for A, B, and Portfolio P ---\n        var_a = get_empirical_var(samples_a, alpha)\n        var_b = get_empirical_var(samples_b, alpha)\n        var_p = get_empirical_var(samples_p, alpha)\n        \n        # --- Check for subadditivity violation ---\n        is_violated = var_p > (var_a + var_b)\n        results.append(is_violated)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}