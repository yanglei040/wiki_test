{
    "hands_on_practices": [
        {
            "introduction": "掌握任何一种数值方法的第一步都是亲手实现其基本形式。这项练习将指导你为一阶自回归 (AR(1)) 过程（这是经济模型中最常见的随机过程之一）从零开始构建陶肯方法 (Tauchen method) 的离散化。通过解决这个具有负持续性参数的案例 ，你不仅能验证算法的每一个细节，还能确保自己理解该方法在不同动态情境下的稳健性。",
            "id": "2436547",
            "problem": "考虑由随机差分方程 $z_{t+1} = \\rho z_t + \\varepsilon_{t+1}$ 定义的一阶自回归（AR）过程，其中 $\\varepsilon_{t}$ 是独立同分布的高斯随机变量，均值为 $0$，方差为 $\\sigma_{\\varepsilon}^2$。对于 $|\\rho| < 1$，该过程是协方差平稳的，其无条件方差为 $\\sigma_z^2 = \\sigma_{\\varepsilon}^2 / (1 - \\rho^2)$，无条件均值为 $0$。目标是使用 Tauchen 方法，通过一个有限状态马尔可夫链来近似这个连续状态过程，并研究当持续性参数为负值时（特别强调 $\\rho = -0.5$ 的情况）其性能表现。\n\n实现一个程序，对于给定的参数 $(\\rho, \\sigma_{\\varepsilon}, N, m)$：\n- 在 $[-m \\sigma_z, m \\sigma_z]$ 区间上构建一个包含 $\\{z_1, \\ldots, z_N\\}$ 的均匀间隔网格，其中 $\\sigma_z = \\sigma_{\\varepsilon}/\\sqrt{1-\\rho^2}$。\n- 使用 Tauchen 方法构建转移概率矩阵 $P \\in \\mathbb{R}^{N \\times N}$：将每个网格点解释为一个区间的中心，使用中点来定义区间边界，并通过在这些区间上对给定 $z_t$ 的 $z_{t+1}$ 的高斯条件分布进行积分来计算转移概率。使用标准正态累积分布函数（CDF）。\n- 计算马尔可夫链的平稳分布 $\\pi$，该分布是满足 $\\pi = \\pi P$ 和 $\\sum_{i=1}^N \\pi_i = 1$ 的不变分布。\n- 使用 $\\pi$ 和 $P$，计算：\n  1. 近似无条件均值 $\\mu_{\\text{disc}} = \\sum_{i=1}^N \\pi_i z_i$。\n  2. 近似无条件方差 $\\sigma_{\\text{disc}}^2 = \\sum_{i=1}^N \\pi_i (z_i - \\mu_{\\text{disc}})^2$。\n  3. 隐含的一阶自相关 $\\rho_{\\text{disc}}$，定义为当 $z_t$ 从马尔可夫链的平稳分布中抽取时，$z_t$ 和 $z_{t+1}$ 之间的相关性。通过协方差 $\\operatorname{Cov}(z_t, z_{t+1}) = \\sum_{i=1}^N \\pi_i z_i \\left(\\sum_{j=1}^N P_{ij} z_j\\right) - \\mu_{\\text{disc}}^2$ 除以 $\\sigma_{\\text{disc}}^2$ 来计算。\n\n对于每个测试用例，报告以下三个定量诊断指标：\n- 绝对均值误差 $|\\mu_{\\text{disc}} - 0|$。\n- 相对方差误差 $\\left|\\sigma_{\\text{disc}}^2 - \\sigma_z^2\\right| / \\sigma_z^2$。\n- 绝对自相关误差 $|\\rho_{\\text{disc}} - \\rho|$。\n\n您无需证明即可假设以下基本前提：\n- 高斯分布的性质，包括标准正态累积分布函数（CDF）。\n- 当 $|\\rho| < 1$ 时，AR(1) 过程的平稳方差公式 $\\sigma_z^2 = \\sigma_{\\varepsilon}^2/(1-\\rho^2)$。\n- 遍历的有限状态马尔可夫链存在且唯一的不变分布。\n\n测试套件：\n在以下参数集 $(\\rho, \\sigma_{\\varepsilon}, N, m)$ 上评估您的实现：\n- 用例 1（理想情况）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.5, 0.2, 9, 3)$。\n- 用例 2（高幅值负持续性）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.95, 0.2, 21, 4)$。\n- 用例 3（小新息方差）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.5, 0.001, 7, 3)$。\n- 用例 4（粗糙网格）：$(\\rho, \\sigma_{\\varepsilon}, N, m) = (-0.5, 0.2, 3, 3)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例应产生一个包含三个浮点数的列表 $[e_{\\mu}, e_{\\sigma^2}, e_{\\rho}]$，其中 $e_{\\mu}$ 是绝对均值误差，$e_{\\sigma^2}$ 是相对方差误差，$e_{\\rho}$ 是绝对自相关误差。将它们按测试套件的顺序聚合成一个列表。所有浮点数打印时四舍五入到六位小数。例如，输出应如下所示：\n[[e_mu_1,e_var_1,e_rho_1],[e_mu_2,e_var_2,e_rho_2],[e_mu_3,e_var_3,e_rho_3],[e_mu_4,e_var_4,e_rho_4]]",
            "solution": "问题陈述已经过严格验证。所有规格均被认为是科学上可靠、数学上一致且定义明确的。因此，该问题被判定为 **有效**。我们接下来给出一个完整的解法。\n\n本题的目标是使用 Tauchen 提出的方法，将一个连续状态的一阶自回归过程 AR($1$) 离散化。该过程由随机差分方程定义：\n$$ z_{t+1} = \\rho z_t + \\varepsilon_{t+1} $$\n其中 $\\varepsilon_t$ 是来自均值为 $0$、方差为 $\\sigma_{\\varepsilon}^2$ 的正态分布的独立同分布随机变量，记为 $\\varepsilon_{t} \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$。为使过程协方差平稳，持续性参数必须满足 $|\\rho|  1$。在此条件下，该过程的无条件均值为 $E[z_t] = 0$，无条件方差为 $\\sigma_z^2 = \\sigma_{\\varepsilon}^2 / (1 - \\rho^2)$。\n\n该解法分五个步骤构建：网格生成、转移矩阵构建、平稳分布的确定、离散过程统计量的计算，最后是误差度量的计算。\n\n**步骤 1：网格构建**\n变量 $z$ 的连续状态空间由一个有限的离散网格来近似。给定网格点数 $N$ 和一个缩放因子 $m$，我们构建一个均匀间隔的网格 $Z = \\{z_1, z_2, \\ldots, z_N\\}$。\n首先，计算连续过程的无条件标准差：\n$$ \\sigma_z = \\sqrt{\\frac{\\sigma_{\\varepsilon}^2}{1 - \\rho^2}} $$\n网格跨越区间 $[-m \\sigma_z, m \\sigma_z]$。网格的端点是 $z_1 = -m \\sigma_z$ 和 $z_N = m \\sigma_z$。对于 $N  1$，相邻网格点之间的恒定步长是：\n$$ \\Delta z = \\frac{z_N - z_1}{N-1} = \\frac{2 m \\sigma_z}{N-1} $$\n如果 $N=1$，网格只包含一个点 $z_1=0$。\n\n**步骤 2：转移矩阵构建**\n离散化过程的动态由一个 $N \\times N$ 的马尔可夫转移矩阵 $P$ 描述。元素 $P_{ij}$ 表示在时间 $t$ 从状态 $z_i$ 转移到时间 $t+1$ 状态 $z_j$ 的概率。\n给定 $z_t = z_i$，$z_{t+1}$ 的条件分布是均值为 $\\rho z_i$、方差为 $\\sigma_{\\varepsilon}^2$ 的正态分布，即 $z_{t+1} | (z_t = z_i) \\sim \\mathcal{N}(\\rho z_i, \\sigma_{\\varepsilon}^2)$。\nTauchen 方法定义了 $N$ 个区间，其中每个网格点 $z_j$ 是一个区间的中心。这些区间的边界是相邻网格点的中点。概率 $P_{ij}$ 是条件正态密度在对应于区间 $j$ 的积分。\n这些区间的定义如下：\n- 区间 1：$(-\\infty, z_1 + \\Delta z/2]$\n- 区间 $j$（对于 $j \\in \\{2, \\ldots, N-1\\}$）：$(z_j - \\Delta z/2, z_j + \\Delta z/2]$\n- 区间 $N$：$(z_N - \\Delta z/2, \\infty)$\n\n令 $\\Phi(\\cdot)$ 为标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数（CDF）。通过对区间边界进行标准化并使用 CDF 来计算转移概率：\n$$\nP_{ij} = \\mathbb{P}(z_{t+1} \\in \\text{bin}_j | z_t = z_i) =\n\\begin{cases}\n\\Phi\\left(\\frac{(z_1 + \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right)   \\text{若 } j=1 \\\\\n\\Phi\\left(\\frac{(z_j + \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right) - \\Phi\\left(\\frac{(z_j - \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right)   \\text{若 } 1  j  N \\\\\n1 - \\Phi\\left(\\frac{(z_N - \\Delta z/2) - \\rho z_i}{\\sigma_{\\varepsilon}}\\right)   \\text{若 } j=N\n\\end{cases}\n$$\n这种构建方式确保了对于任何初始状态 $z_i$，转移到所有可能的下一个状态的概率之和为 1，即 $\\sum_{j=1}^N P_{ij} = 1$。\n\n**步骤 3：平稳分布**\n马尔可夫链的平稳分布是一个概率向量 $\\pi = (\\pi_1, \\pi_2, \\ldots, \\pi_N)$，它在应用转移矩阵后保持不变。它必须满足两个条件：\n$$ \\pi P = \\pi \\quad \\text{且} \\quad \\sum_{i=1}^N \\pi_i = 1 $$\n这意味着 $\\pi$ 是 $P$ 对应于特征值 $\\lambda = 1$ 的左特征向量。等价地，其转置 $\\pi^T$ 是转置矩阵 $P^T$ 对应于特征值 $\\lambda=1$ 的右特征向量：\n$$ P^T \\pi^T = \\pi^T $$\n对于一个行为良好（遍历）的马尔可夫链，如此方法产生的链，保证存在唯一的平稳分布。可以通过数值方法计算 $P^T$ 的特征系统，找到与最接近 $1$ 的特征值相关联的特征向量，并将其归一化使其总和为 $1$。\n\n**步骤 4：离散化过程的近似矩**\n使用平稳分布 $\\pi$ 和网格 $Z$，我们计算近似过程的统计矩。\n- **无条件均值**：过程在其平稳状态下的均值是网格上的期望值，由平稳概率加权。\n  $$ \\mu_{\\text{disc}} = E[z] = \\sum_{i=1}^N \\pi_i z_i = \\pi \\cdot Z $$\n- **无条件方差**：\n  $$ \\sigma_{\\text{disc}}^2 = E[(z-\\mu_{\\text{disc}})^2] = \\sum_{i=1}^N \\pi_i (z_i - \\mu_{\\text{disc}})^2 = \\left(\\sum_{i=1}^N \\pi_i z_i^2\\right) - \\mu_{\\text{disc}}^2 $$\n- **一阶自相关**：自相关 $\\rho_{\\text{disc}}$ 是当过程处于平稳状态时，$z_t$ 和 $z_{t+1}$ 之间的相关性。它定义为 $\\rho_{\\text{disc}} = \\operatorname{Cov}(z_t, z_{t+1}) / \\sigma_{\\text{disc}}^2$。协方差由下式给出：\n  $$ \\operatorname{Cov}(z_t, z_{t+1}) = E[z_t z_{t+1}] - E[z_t]E[z_{t+1}] $$\n  根据平稳性，$E[z_t] = E[z_{t+1}] = \\mu_{\\text{disc}}$。$E[z_t z_{t+1}]$ 项使用全期望定律计算：\n  $$ E[z_t z_{t+1}] = E_{z_t} [z_t E[z_{t+1}|z_t]] = \\sum_{i=1}^N \\pi_i z_i \\left( \\sum_{j=1}^N P_{ij} z_j \\right) $$\n  因此，协方差为：\n  $$ \\operatorname{Cov}(z_t, z_{t+1}) = \\left(\\sum_{i=1}^N \\pi_i z_i \\sum_{j=1}^N P_{ij} z_j\\right) - \\mu_{\\text{disc}}^2 $$\n  自相关为：\n  $$ \\rho_{\\text{disc}} = \\frac{\\operatorname{Cov}(z_t, z_{t+1})}{\\sigma_{\\text{disc}}^2} $$\n\n**步骤 5：误差度量**\n通过将马尔可夫链近似的矩与连续 AR($1$) 过程的理论对应值进行比较，来评估离散化的准确性。\n- **绝对均值误差**：$e_{\\mu} = |\\mu_{\\text{disc}} - 0| = |\\mu_{\\text{disc}}|$。\n- **相对方差误差**：$e_{\\sigma^2} = \\frac{|\\sigma_{\\text{disc}}^2 - \\sigma_z^2|}{\\sigma_z^2}$。\n- **绝对自相关误差**：$e_{\\rho} = |\\rho_{\\text{disc}} - \\rho|$。\n这三个度量量化了 Tauchen 方法在给定参数化下的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path): (rho, sigma_e, N, m)\n        (-0.5, 0.2, 9, 3),\n        # Case 2 (high-magnitude negative persistence): (rho, sigma_e, N, m)\n        (-0.95, 0.2, 21, 4),\n        # Case 3 (small innovation variance): (rho, sigma_e, N, m)\n        (-0.5, 0.001, 7, 3),\n        # Case 4 (coarse grid): (rho, sigma_e, N, m)\n        (-0.5, 0.2, 3, 3),\n    ]\n\n    results = []\n    for params in test_cases:\n        rho, sigma_e, N, m = params\n        \n        # --- Step 1: Grid Construction ---\n        # Theoretical unconditional variance and standard deviation\n        sigma_z_sq = sigma_e**2 / (1 - rho**2)\n        sigma_z = np.sqrt(sigma_z_sq)\n        \n        # Create an evenly spaced grid\n        if N  1:\n            z_grid = np.linspace(-m * sigma_z, m * sigma_z, N)\n            delta_z = z_grid[1] - z_grid[0]\n        else: # N=1 is a special case\n            z_grid = np.array([0.0])\n            delta_z = 0.0\n\n        # --- Step 2: Transition Matrix Construction ---\n        P = np.zeros((N, N))\n        for i in range(N):\n            mu_cond = rho * z_grid[i]\n            \n            # Handle bin probabilities\n            if N  1:\n                # Bin 1: (-inf, z_1 + delta_z/2]\n                upper_bound_1 = z_grid[0] + delta_z / 2\n                P[i, 0] = norm.cdf((upper_bound_1 - mu_cond) / sigma_e)\n                \n                # Bin N: (z_{N-1} + delta_z/2, inf)\n                lower_bound_N = z_grid[N-1] - delta_z / 2\n                P[i, N-1] = 1 - norm.cdf((lower_bound_N - mu_cond) / sigma_e)\n                \n                # Bins 2 to N-1\n                for j in range(1, N - 1):\n                    lower_bound_j = z_grid[j] - delta_z / 2\n                    upper_bound_j = z_grid[j] + delta_z / 2\n                    P[i, j] = norm.cdf((upper_bound_j - mu_cond) / sigma_e) - \\\n                              norm.cdf((lower_bound_j - mu_cond) / sigma_e)\n            else: # N=1 case, P is just [[1.0]]\n                 P[i, 0] = 1.0\n\n        # --- Step 3: Stationary Distribution ---\n        # Find the eigenvector of P.T with eigenvalue 1\n        eigvals, eigvecs = np.linalg.eig(P.T)\n        idx = np.argmin(np.abs(eigvals - 1.0))\n        pi_vec = eigvecs[:, idx].real\n        # Normalize to get a probability distribution\n        pi = pi_vec / pi_vec.sum()\n\n        # --- Step 4: Calculation of Diagnostic Statistics ---\n        # Approximate unconditional mean\n        mu_disc = np.dot(pi, z_grid)\n        \n        # Approximate unconditional variance\n        var_disc = np.dot(pi, (z_grid - mu_disc)**2)\n\n        # Approximate first-order autocorrelation\n        # E[z' | z] = sum_j(P_ij * z_j) for each i\n        expected_z_next = P @ z_grid\n        # E[z * z'] = sum_i(pi_i * z_i * E[z' | z=z_i])\n        E_z_z_next = np.dot(pi * z_grid, expected_z_next)\n        \n        cov_disc = E_z_z_next - mu_disc**2\n        \n        if var_disc == 0:\n            rho_disc = 0.0 # Avoid division by zero if variance is zero\n        else:\n            rho_disc = cov_disc / var_disc\n\n        # --- Step 5: Error Metrics ---\n        # Absolute mean error\n        e_mu = np.abs(mu_disc)\n        \n        # Relative variance error\n        e_var = np.abs(var_disc - sigma_z_sq) / sigma_z_sq\n        \n        # Absolute autocorrelation error\n        e_rho = np.abs(rho_disc - rho)\n        \n        results.append([e_mu, e_var, e_rho])\n\n    # Final print statement in the exact required format.\n    result_strings = [f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\" for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本 AR(1) 过程的离散化之后，一个自然而关键的步骤是将其推广到更高阶的系统。这项练习将挑战你把陶肯方法应用于二阶自回归 (AR(2)) 过程，这需要你将问题转化为向量自回归 (VAR) 的形式，并对一个二维状态空间进行离散化。完成这项练习  将使你掌握处理多维动态模型的关键技能，这是将数值方法应用于实际宏观经济模型的基石。",
            "id": "2436526",
            "problem": "给定一个均值为零的二阶高斯自回归（AR(2)）过程，由以下递归式定义\n$$\ny_t = \\rho_1 y_{t-1} + \\rho_2 y_{t-2} + \\epsilon_t,\n$$\n其中 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_\\epsilon^2)$ 在时间 $t$ 上独立同分布，且参数 $(\\rho_1,\\rho_2)$ 保证了平稳分布的存在。定义二维状态向量 $x_t = \\begin{bmatrix} y_t \\\\ y_{t-1} \\end{bmatrix}$ 并考虑其一阶马尔可夫表示\n$$\nx_{t+1} = A x_t + B \\epsilon_{t+1}, \\quad A = \\begin{bmatrix} \\rho_1  \\rho_2 \\\\ 1  0 \\end{bmatrix}, \\quad B = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}.\n$$\n通过对 $y$ 维度使用一个包含 $N$ 个节点的均匀网格，来构建一个近似 $x_t$ 动态的有限状态时间齐次马尔可夫链。该网格以 $0$ 为中心对称，范围为平稳标准差 $y_t$ 的 $\\pm m$ 倍。$y$ 维度上的网格用向量 $Y = (y_1,\\dots,y_N)$ 表示，其中 $y_1  \\dots  y_N$，$y_1=-m\\,\\sigma_y$ 且 $y_N=+m\\,\\sigma_y$，$\\sigma_y$ 是 $y_t$ 的平稳标准差，内部节点等距分布。完整的状态空间是笛卡尔积 $S = Y \\times Y$，其状态表示为有序对 $(y_i,y_j)$。\n\n对于任意当前状态 $(y_i,y_j)$，$y_{t+1}$ 的条件分布是高斯分布，其条件均值为 $\\mu_{i,j}=\\rho_1 y_i + \\rho_2 y_j$，条件标准差为 $\\sigma_\\epsilon$。通过中点为 $Y$ 定义区间边界：\n$$\nb_k = \\frac{y_k+y_{k+1}}{2} \\quad \\text{for } k=1,\\dots,N-1,\\quad b_0=-\\infty,\\quad b_N=+\\infty.\n$$\n将从 $(y_i,y_j)$ 到 $(y_k,y_i)$ 的一步转移概率定义为，在均值为 $\\mu_{i,j}$、标准差为 $\\sigma_\\epsilon$ 的高斯分布下，$y_{t+1}$ 落在区间 $(b_{k-1},b_k]$ 内的概率。从 $(y_i,y_j)$ 到任何 $\\ell \\ne i$ 的状态 $(y_k,y_\\ell)$ 的所有其他转移概率均为零。这定义了一个在 $S$ 上的时间齐次马尔可夫转移核，它完全由 $(\\rho_1,\\rho_2,\\sigma_\\epsilon,N,m)$ 确定。\n\n对于下面测试套件中的每一组参数，计算所构建的马尔可夫链的以下两个标量诊断指标：\n- 任意行和与 $1$ 之间的最大绝对偏差，定义为\n$$\n\\Delta_{\\text{row}} = \\max_{(i,j)} \\left| \\sum_{k=1}^N p_{(i,j)\\to (y_k,y_i)} - 1 \\right|.\n$$\n- 所有状态下条件期望近似误差的最大绝对值，定义为\n$$\n\\Delta_{\\mathbb{E}} = \\max_{(i,j)} \\left| \\sum_{k=1}^N y_k \\, p_{(i,j)\\to (y_k,y_i)} - \\mu_{i,j} \\right|.\n$$\n\n$x_t$ 的平稳协方差矩阵是离散时间李亚普诺夫方程的唯一对称正定解 $\\Sigma$\n$$\n\\Sigma = A \\Sigma A^\\top + \\sigma_\\epsilon^2\\, B B^\\top,\n$$\n$y_t$ 的平稳方差等于 $\\Sigma$ 的 $(1,1)$ 元素，因此 $\\sigma_y=\\sqrt{\\Sigma_{11}}$。使用此 $\\sigma_y$ 来定义网格 $Y$。\n\n测试套件（每个案例提供 $(\\rho_1,\\rho_2,\\sigma_\\epsilon,N,m)$）：\n- 案例 1：$(0.5,\\,0.2,\\,0.1,\\,7,\\,3)$。\n- 案例 2：$(1.8,\\,-0.81,\\,0.05,\\,9,\\,4)$。\n- 案例 3：$(0.0,\\,0.0,\\,1.0,\\,5,\\,3)$。\n- 案例 4：$(0.0,\\,0.5,\\,0.2,\\,3,\\,3)$。\n\n您的程序必须为每个测试案例计算出由两个实数组成的列表对 $[\\Delta_{\\text{row}},\\Delta_{\\mathbb{E}}]$。最终输出必须是单行，包含按测试案例顺序排列的这些列表对，无空格，例如\n$$\n[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]].\n$$\n不涉及物理单位。如果出现任何角度，此处不适用。所有输出都必须是标准十进制表示的数值实数。程序不得读取任何输入，并且必须以指定格式精确打印一行。",
            "solution": "该问题要求构建并分析一个有限状态马尔可夫链，以近似一个连续状态的二阶自回归过程 AR(2)。这是计算经济学和应用宏观经济学中的一个标准问题，它通过使用向量自回归（VAR）表示，将 Tauchen (1986) 提出的用于 AR(1) 过程的方法推广到更高阶的情况。目标是计算两个特定的诊断指标，以衡量该近似在几种参数设置下的质量。该问题定义明确，科学上合理，且计算上易于处理。\n\nAR(2) 过程由下式给出\n$$y_t = \\rho_1 y_{t-1} + \\rho_2 y_{t-2} + \\epsilon_t, \\quad \\epsilon_t \\sim \\mathcal{N}(0, \\sigma_\\epsilon^2)$$\n其状态空间表示为 $x_{t+1} = A x_t + B \\epsilon_{t+1}$，其中 $x_t = \\begin{bmatrix} y_t \\\\ y_{t-1} \\end{bmatrix}$，$A = \\begin{bmatrix} \\rho_1  \\rho_2 \\\\ 1  0 \\end{bmatrix}$，以及 $B = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n对于每一组给定的参数 $(\\rho_1, \\rho_2, \\sigma_\\epsilon, N, m)$，该解决方案按四个逻辑步骤进行。\n\n第一步：计算平稳方差\n第一步是确定过程 $y_t$ 的平稳标准差，记为 $\\sigma_y$。这是定义状态空间网格所必需的。状态向量 $x_t$ 的平稳无条件协方差矩阵，记为 $\\Sigma = \\text{Cov}(x_t, x_t^\\top)$，是离散时间李亚普诺夫方程的对称正定解：\n$$\\Sigma = A \\Sigma A^\\top + Q$$\n其中 $Q = \\sigma_\\epsilon^2 B B^\\top = \\begin{bmatrix} \\sigma_\\epsilon^2  0 \\\\ 0  0 \\end{bmatrix}$。$y_t$ 的平稳方差是 $\\Sigma$ 的 $(1,1)$ 元素，即 $\\sigma_y^2 = \\Sigma_{11}$。我们数值求解这个矩阵方程得到 $\\Sigma$，然后计算 $\\sigma_y = \\sqrt{\\Sigma_{11}}$。对于给定的参数集，$(\\rho_1, \\rho_2)$ 上的平稳性条件得到满足，确保了 $\\Sigma$ 存在唯一解。\n\n第二步：构建状态空间网格\n过程的连续状态空间通过一个离散网格来近似。$y$ 维度的网格，记为 $Y$，由 $N$ 个点组成，围绕 $0$ 对称，并跨越区间 $[-m\\sigma_y, m\\sigma_y]$。网格点是等距的。向量 $Y = (y_1, \\dots, y_N)$ 的构建方式使得 $y_1 = -m\\sigma_y$ 且 $y_N = m\\sigma_y$。马尔可夫链的完整状态空间 $S$ 是笛卡尔积 $S = Y \\times Y$，由 $N^2$ 个形式为 $(y_i, y_j)$ 的状态组成，其中 $y_i, y_j \\in Y$。\n\n第三步：计算转移概率\n离散马尔可夫链的转移概率必须近似原始 AR(2) 过程的转移动态。该问题指定了一种特定的离散化方案。给定当前状态为 $(y_t, y_{t-1}) = (y_i, y_j)$，下一期的值 $y_{t+1}$ 服从正态分布，其条件均值为 $\\mu_{i,j} = \\rho_1 y_i + \\rho_2 y_j$，标准差为 $\\sigma_\\epsilon$。\n状态向量从 $x_t = (y_i, y_j)$ 演化到 $x_{t+1} = (y_{t+1}, y_i)$。新状态必须是 $(y_k, y_i)$ 的形式，其中某个 $y_k \\in Y$。此转移的概率 $p_{(y_i,y_j) \\to (y_k,y_i)}$ 是 $y_{t+1}$ 落入与网格点 $y_k$ 相关联的区间的概率。这些区间（或箱）由相邻网格点之间的中点定义：\n$$b_k = \\frac{y_k + y_{k+1}}{2} \\quad \\text{for } k=1, \\dots, N-1$$\n外部边界设置为 $b_0 = -\\infty$ 和 $b_N = +\\infty$。第 $k$ 个区间是 $(b_{k-1}, b_k]$。\n因此，该转移概率由条件正态分布的累积分布函数（CDF）给出：\n$$p_{(y_i,y_j) \\to (y_k,y_i)} = P(b_{k-1}  y_{t+1} \\le b_k \\mid y_t=y_i, y_{t-1}=y_j)$$\n$$= \\Phi\\left(\\frac{b_k - \\mu_{i,j}}{\\sigma_\\epsilon}\\right) - \\Phi\\left(\\frac{b_{k-1} - \\mu_{i,j}}{\\sigma_\\epsilon}\\right)$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布 $\\mathcal{N}(0,1)$ 的 CDF。对于给定的源状态 $(y_i, y_j)$，我们为 $k=1, \\dots, N$ 计算这 $N$ 个概率。向任何非 $(y_k, y_i)$ 形式的状态的转移概率为 $0$。\n\n第四步：计算诊断指标\n最后，我们计算两个指定的诊断指标，它们衡量离散化的准确性。我们遍历所有 $N^2$ 个初始状态 $(y_i, y_j) \\in S$。\n第一个诊断指标 $\\Delta_{\\text{row}}$ 衡量从单个状态出发的转移概率之和与 1 之间的最大偏差。\n$$\\Delta_{\\text{row}} = \\max_{(i,j)} \\left| \\left( \\sum_{k=1}^N p_{(y_i,y_j)\\to (y_k,y_i)} \\right) - 1 \\right|$$\n理论上，这个和是一个伸缩级数，等于 $\\Phi(\\infty) - \\Phi(-\\infty) = 1$。因此，$\\Delta_{\\text{row}}$ 仅因浮点精度限制才会非零。\n\n第二个诊断指标 $\\Delta_{\\mathbb{E}}$ 衡量近似条件期望的最大绝对误差。从状态 $(y_i, y_j)$ 出发的近似条件期望是 $\\sum_{k=1}^N y_k \\, p_{(y_i,y_j)\\to(y_k,y_i)}$。真实的条件期望是 $\\mu_{i,j} = \\rho_1 y_i + \\rho_2 y_j$。误差则为：\n$$\\Delta_{\\mathbb{E}} = \\max_{(i,j)} \\left| \\sum_{k=1}^N y_k \\, p_{(y_i,y_j)\\to (y_k,y_i)} - \\mu_{i,j} \\right|$$\n该指标量化了离散化过程在多大程度上保留了原始过程动态的一阶矩。较小的 $\\Delta_{\\mathbb{E}}$ 表示更好的近似。\n\n以下程序为每个测试案例实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_discrete_lyapunov\nfrom scipy.stats import norm\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (rho1, rho2, sigma_eps, N, m)\n        (0.5, 0.2, 0.1, 7, 3),\n        (1.8, -0.81, 0.05, 9, 4),\n        (0.0, 0.0, 1.0, 5, 3),\n        (0.0, 0.5, 0.2, 3, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho1, rho2, sigma_eps, N, m = case\n\n        # Step 1: Compute stationary variance\n        A = np.array([[rho1, rho2], [1.0, 0.0]])\n        B = np.array([[1.0], [0.0]])\n        Q = (sigma_eps**2) * (B @ B.T)\n        \n        Sigma = solve_discrete_lyapunov(A, Q)\n        sigma_y = np.sqrt(Sigma[0, 0])\n\n        # Step 2: Construct the state space grid\n        y_grid = np.linspace(-m * sigma_y, m * sigma_y, N)\n\n        # Step 3: Define bin boundaries\n        step = y_grid[1] - y_grid[0]\n        bin_boundaries_mid = y_grid[:-1] + step / 2.0\n        # Full boundaries for CDF calculation\n        b = np.concatenate(([-np.inf], bin_boundaries_mid, [np.inf]))\n\n        # Step 4: Compute diagnostics\n        max_row_dev = 0.0\n        max_exp_err = 0.0\n\n        for i in range(N):\n            for j in range(N):\n                y_i = y_grid[i]\n                y_j = y_grid[j]\n                \n                # Conditional mean\n                mu_ij = rho1 * y_i + rho2 * y_j\n                \n                # Compute transition probabilities\n                cdf_at_bins = norm.cdf((b - mu_ij) / sigma_eps)\n                probs = np.diff(cdf_at_bins)\n\n                # Diagnostic 1: Row sum deviation\n                row_sum = np.sum(probs)\n                row_dev = abs(row_sum - 1.0)\n                if row_dev  max_row_dev:\n                    max_row_dev = row_dev\n                \n                # Diagnostic 2: Conditional expectation error\n                approx_exp = np.sum(y_grid * probs)\n                exp_err = abs(approx_exp - mu_ij)\n                if exp_err  max_exp_err:\n                    max_exp_err = exp_err\n                    \n        results.append([max_row_dev, max_exp_err])\n\n    # Final print statement in the exact required format.\n    # Format each pair as [val1,val2] and join them with commas.\n    pair_strs = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(pair_strs)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "这项高级练习将颠覆我们通常的视角，提供一个加深理解的独特机会。我们不再从已知的过程参数（如 $\\rho$ 和 $\\sigma_{\\epsilon}$）出发来构建转移矩阵，而是反其道而行之：从给定的离散状态网格和转移矩阵中“逆向工程”出这些未知参数。这项练习  迫使你深入思考陶肯方法背后的核心假设——线性条件期望和恒定条件方差——从而在数值近似与计量经济学估计之间建立起一座深刻的桥梁。",
            "id": "2436597",
            "problem": "实现一个完整、可运行的程序，对零均值高斯一阶自回归过程（AR(1)）执行“逆”Tauchen方法。假设连续时间数据生成过程为带高斯新息的一阶自回归（AR）模型，定义为 $z_{t+1} = \\rho z_t + \\epsilon_t$，其中 $\\epsilon_t \\sim \\mathcal{N}(0,\\sigma_{\\epsilon}^2)$ 且 $|\\rho|  1$。Tauchen离散化方法在高斯新息和线性条件期望的假设下，在网格上构建一个有限状态马尔可夫链近似。在正向Tauchen方法中，一个包含$N$个节点的对称网格由区间 $\\left[-m \\cdot \\sigma_z, m \\cdot \\sigma_z\\right]$ 上的等距点定义，其中 $\\sigma_z = \\sigma_{\\epsilon}/\\sqrt{1-\\rho^2}$ 是 $z_t$ 的平稳标准差，而转移概率则是通过在网格中点之间的区间边界处评估标准正态累积分布函数来计算的。\n\n您的任务是实现逆问题：给定一个状态网格和一个转移矩阵（它们是由某个未知的 $\\rho$ 和 $\\sigma_{\\epsilon}$ 通过类似Tauchen的方案生成的），估计 $\\rho$ 和 $\\sigma_{\\epsilon}$。您的估计器必须仅基于带高斯新息的AR(1)过程的定义属性，特别是其条件期望对于当前状态是线性的，并且其条件方差在不同状态间是恒定的，以及马尔可夫链转移矩阵如何编码给定当前网格状态下下一网格状态的条件分布。不要假设您可以使用任何估计器的现成公式；相反，您需要通过将马尔可夫链所蕴含的条件矩与连续AR(1)过程的条件矩联系起来，从第一性原理推导出一个相合估计器。\n\n为了使任务具体且可测试，您的程序必须同时实现以下两者：\n- 一个正向Tauchen生成器，对于给定的参数 $(\\rho,\\sigma_{\\epsilon},N,m)$，它在 $\\left[-m \\cdot \\sigma_z, m \\cdot \\sigma_z\\right]$ 上构建一个对称的等距网格 $\\{z_j\\}_{j=1}^N$，以及一个转移矩阵 $P \\in \\mathbb{R}^{N \\times N}$。其中，条目 $P_{ij}$ 等于当当前状态为第 $i$ 个网格点时，下一状态落入第 $j$ 个网格单元的概率。该概率是通过在由相邻网格点中点定义的区间内对均值为 $\\rho z_i$、标准差为 $\\sigma_{\\epsilon}$ 的高斯分布进行积分计算得出的，其中最下和最上的区间分别延伸至 $-\\infty$ 和 $+\\infty$。使用标准正态累积分布函数进行这些积分。\n- 一个逆Tauchen估计器，它以 $(\\{z_j\\}_{j=1}^N, P)$ 为输入，通过利用马尔可夫链的条件矩与连续AR(1)过程的条件矩之间的关系，输出估计值 $(\\widehat{\\rho},\\widehat{\\sigma}_{\\epsilon})$。\n\n您的程序必须执行以下测试套件。对于每组参数，首先使用您的正向Tauchen实现生成 $(\\{z_j\\},P)$，然后应用您的逆估计器来恢复 $(\\widehat{\\rho},\\widehat{\\sigma}_{\\epsilon})$。使用以下测试用例：\n- 测试用例 $1$：$(\\rho,\\sigma_{\\epsilon},N,m) = (0.9, 0.1, 7, 3.0)$。\n- 测试用例 $2$：$(\\rho,\\sigma_{\\epsilon},N,m) = (0.0, 0.2, 5, 3.0)$。\n- 测试用例 $3$：$(\\rho,\\sigma_{\\epsilon},N,m) = (0.99, 0.05, 11, 3.5)$。\n- 测试用例 $4$：$(\\rho,\\sigma_{\\epsilon},N,m) = (-0.5, 0.15, 9, 3.0)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个扁平的浮点数列表，按顺序包含每个测试用例的估计值，格式为 $[\\widehat{\\rho}_1,\\widehat{\\sigma}_{\\epsilon,1},\\widehat{\\rho}_2,\\widehat{\\sigma}_{\\epsilon,2},\\widehat{\\rho}_3,\\widehat{\\sigma}_{\\epsilon,3},\\widehat{\\rho}_4,\\widehat{\\sigma}_{\\epsilon,4}]$。\n- 每个浮点数必须四舍五入到恰好 $6$ 位小数。\n- 不应打印任何额外文本。\n\n此处不涉及任何角度（如有）。不涉及物理单位。唯一要求的数值规范是所有打印的浮点数必须四舍五入到 $6$ 位小数。输出必须是单行：一个如上所述的、用方括号括起来的逗号分隔列表。",
            "solution": "提交审议的问题陈述是有效的。它具有科学依据，定义明确，客观且内部一致。它描述了量化经济学领域中的一个具体计算任务：对一个连续时间随机过程进行离散化，并随后从该离散近似中估计基础过程的参数。任务是首先为高斯AR(1)过程实现标准的Tauchen方法，然后推导并实现一个“逆”过程，从得到的离散状态网格和转移矩阵中估计过程参数 $(\\rho, \\sigma_{\\epsilon})$。这是数值方法和计量经济学中的一个标准问题。\n\n我现在将提供完整的推导和解决方案。该解决方案分为两部分：首先是正向Tauchen离散化的形式化构建，其次是从第一性原理推导逆问题的估计器。\n\n令连续时间数据生成过程为一个零均值一阶自回归过程（AR(1)）：\n$$z_{t+1} = \\rho z_t + \\epsilon_t$$\n其中新息项 $\\epsilon_t$ 是一个独立同分布的随机变量，服从均值为零、方差为 $\\sigma_{\\epsilon}^2$ 的正态分布，记为 $\\epsilon_t \\sim \\mathcal{N}(0, \\sigma_{\\epsilon}^2)$。为保证平稳性，持续性参数 $\\rho$ 满足 $|\\rho|  1$。过程 $z_t$ 的无条件方差为 $\\sigma_z^2 = \\text{Var}(z_t) = \\sigma_{\\epsilon}^2 / (1-\\rho^2)$。\n\n**第一部分：正向Tauchen方法**\n\n正向Tauchen方法构建一个有限状态马尔可夫链来近似连续的AR(1)过程。这包括定义一个离散状态空间（一个网格）和一个转移概率矩阵。\n\n1.  **状态网格构建：**\n    状态空间是一个包含 $N$ 个点的对称网格，记为 $\\{z_j\\}_{j=1}^N$。构建该网格是为了跨越该过程的一定数量的无条件标准差。\n    -   平稳标准差为 $\\sigma_z = \\sigma_{\\epsilon} / \\sqrt{1-\\rho^2}$。\n    -   网格覆盖区间 $[-m\\sigma_z, m\\sigma_z]$，其中 $m$ 是一个缩放参数。\n    -   这 $N$ 个网格点是等距的。最大值和最小值分别为 $z_N = m\\sigma_z$ 和 $z_1 = -m\\sigma_z$。\n    -   网格点可以使用线性空间函数生成：\n        $$z_j \\quad \\text{对于 } j=1, \\dots, N \\quad \\text{由 } \\text{linspace}(-m\\sigma_z, m\\sigma_z, N) \\text{ 给出}$$\n\n2.  **转移矩阵构建：**\n    转移矩阵 $P \\in \\mathbb{R}^{N \\times N}$ 提供了从状态 $z_i$ 转移到状态 $z_j$ 的概率 $P_{ij}$。这些概率是通过对与每个网格点 $z_j$ 相关联的区间（bins）上的 $z_{t+1}$ 的条件密度进行积分来计算的。\n    -   给定 $z_t = z_i$，下一状态 $z_{t+1}$ 服从正态分布：\n        $$z_{t+1} | z_t=z_i \\sim \\mathcal{N}(\\rho z_i, \\sigma_{\\epsilon}^2)$$\n    -   区间边界定义为相邻网格点之间的中点。令 $\\Delta z = z_{j+1} - z_j$ 为恒定的步长。$z_j$ 和 $z_{j+1}$ 之间的中点是 $b_j = z_j + \\Delta z / 2$，对于 $j=1, \\dots, N-1$。\n    -   区间定义如下：\n        -   区间 $1$：$(-\\infty, b_1]$\n        -   区间 $j$：$(b_{j-1}, b_j]$ 对于 $j=2, \\dots, N-1$\n        -   区间 $N$：$(b_{N-1}, +\\infty)$\n    -   转移概率 $P_{ij}$ 是在给定 $z_t=z_i$ 的条件下，$z_{t+1}$ 落入区间 $j$ 的概率。令 $\\Phi(\\cdot)$ 为标准正态分布 $\\mathcal{N}(0,1)$ 的累积分布函数（CDF）。\n        $$P(z_{t+1} \\le x | z_t=z_i) = P(\\rho z_i + \\epsilon_t \\le x) = P\\left(\\frac{\\epsilon_t}{\\sigma_\\epsilon} \\le \\frac{x-\\rho z_i}{\\sigma_\\epsilon}\\right) = \\Phi\\left(\\frac{x-\\rho z_i}{\\sigma_\\epsilon}\\right)$$\n    -   因此，转移矩阵的元素为：\n        -   对于 $j=1$：\n            $$P_{i1} = P(z_{t+1} \\in \\text{Bin } 1 | z_t=z_i) = \\Phi\\left(\\frac{b_1 - \\rho z_i}{\\sigma_\\epsilon}\\right)$$\n        -   对于 $j=2, \\dots, N-1$：\n            $$P_{ij} = P(z_{t+1} \\in \\text{Bin } j | z_t=z_i) = \\Phi\\left(\\frac{b_j - \\rho z_i}{\\sigma_\\epsilon}\\right) - \\Phi\\left(\\frac{b_{j-1} - \\rho z_i}{\\sigma_\\epsilon}\\right)$$\n        -   对于 $j=N$：\n            $$P_{iN} = P(z_{t+1} \\in \\text{Bin } N | z_t=z_i) = 1 - \\Phi\\left(\\frac{b_{N-1} - \\rho z_i}{\\sigma_\\epsilon}\\right)$$\n\n**第二部分：逆Tauchen方法（估计器推导）**\n\n逆问题是在给定网格 $\\mathbf{z} = [z_1, \\dots, z_N]^T$ 和转移矩阵 $P$ 的情况下，估计参数 $(\\rho, \\sigma_{\\epsilon})$。推导过程依赖于将AR(1)过程的理论条件矩与马尔可夫链近似的经验对应项相等同。\n\n1.  **AR(1)过程的基本矩条件：**\n    -   **条件期望：** 给定当前状态 $z_t$，下一状态的期望是线性的：\n        $$E[z_{t+1} | z_t] = E[\\rho z_t + \\epsilon_t | z_t] = \\rho z_t + E[\\epsilon_t] = \\rho z_t$$\n    -   **条件方差：** 给定当前状态 $z_t$，下一状态的方差是恒定的：\n        $$\\text{Var}(z_{t+1} | z_t) = \\text{Var}(\\rho z_t + \\epsilon_t | z_t) = \\text{Var}(\\epsilon_t) = \\sigma_{\\epsilon}^2$$\n\n2.  **估计 $\\rho$：**\n    马尔可夫链近似提供了下一个网格状态的条件概率分布。对于每个当前状态 $z_i$，我们可以计算下一状态的期望值 $E[z'|z=z_i]$：\n    $$E[z'|z=z_i] = \\sum_{j=1}^N z_j P_{ij}$$\n    我们将其视为真实条件期望的近似：$E[z'|z=z_i] \\approx E[z_{t+1}|z_t=z_i] = \\rho z_i$。这给了我们一个包含 $N$ 个方程的方程组：\n    $$\\sum_{j=1}^N z_j P_{ij} \\approx \\rho z_i \\quad \\text{对于 } i=1, \\dots, N$$\n    这是一个关于未知数 $\\rho$ 的超定线性系统。解决这个问题的一个自然方法是普通最小二乘法（OLS）。令 $Y_i = \\sum_{j=1}^N z_j P_{ij}$ 和 $X_i = z_i$。我们拟合模型 $Y_i = \\rho X_i + \\text{误差}$。通过原点的回归的OLS估计器是：\n    $$\\widehat{\\rho} = \\frac{\\sum_{i=1}^N X_i Y_i}{\\sum_{i=1}^N X_i^2} = \\frac{\\sum_{i=1}^N z_i \\left(\\sum_{j=1}^N z_j P_{ij}\\right)}{\\sum_{i=1}^N z_i^2}$$\n    用向量表示法，令条件期望向量为 $\\mathbf{E_z} = P\\mathbf{z}$。那么估计器为：\n    $$\\widehat{\\rho} = \\frac{\\mathbf{z}^T \\mathbf{E_z}}{\\mathbf{z}^T \\mathbf{z}} = \\frac{\\mathbf{z}^T P \\mathbf{z}}{\\mathbf{z}^T \\mathbf{z}}$$\n\n3.  **估计 $\\sigma_{\\epsilon}$：**\n    过程的条件方差是恒定的，为 $\\sigma_{\\epsilon}^2$。对于马尔可夫链中的每个状态 $z_i$，我们可以计算下一状态的条件方差 $\\text{Var}(z'|z=z_i)$：\n    $$\\text{Var}(z'|z=z_i) = E[(z')^2|z=z_i] - (E[z'|z=z_i])^2$$\n    其中条件二阶矩为 $E[(z')^2|z=z_i] = \\sum_{j=1}^N z_j^2 P_{ij}$。\n    这 $N$ 个计算出的条件方差中的每一个，$V_i = \\text{Var}(z'|z=z_i)$，都是对真实恒定方差 $\\sigma_{\\epsilon}^2$ 的一个估计。通过取这些单个方差估计的平均值，可以构成 $\\sigma_{\\epsilon}^2$ 的一个相合估计器：\n    $$\\widehat{\\sigma}_{\\epsilon}^2 = \\frac{1}{N} \\sum_{i=1}^N \\text{Var}(z'|z=z_i) = \\frac{1}{N} \\sum_{i=1}^N \\left[ \\left(\\sum_{j=1}^N z_j^2 P_{ij}\\right) - \\left(\\sum_{j=1}^N z_j P_{ij}\\right)^2 \\right]$$\n    那么新息标准差的估计器就是简单地取平方根：\n    $$\\widehat{\\sigma}_{\\epsilon} = \\sqrt{\\widehat{\\sigma}_{\\epsilon}^2}$$\n    这样就完成了逆Tauchen问题估计器的推导。实现将遵循这些推导出的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the reverse Tauchen method.\n    It first generates a discrete Markov approximation (grid and transition matrix)\n    for a given AR(1) process using the forward Tauchen method. Then, it uses\n    the reverse Tauchen method to estimate the original AR(1) parameters.\n    \"\"\"\n\n    def forward_tauchen(rho, sigma_eps, N, m):\n        \"\"\"\n        Generates a state grid and transition matrix for an AR(1) process\n        using Tauchen's method.\n\n        Args:\n            rho (float): The persistence parameter of the AR(1) process.\n            sigma_eps (float): The standard deviation of the innovation term.\n            N (int): The number of grid points.\n            m (float): The number of standard deviations the grid should span.\n\n        Returns:\n            tuple: A tuple containing:\n                - z_grid (np.ndarray): The state grid.\n                - P (np.ndarray): The transition matrix.\n        \"\"\"\n        # Step 1: Create the state grid\n        # Unconditional standard deviation of the process z\n        if abs(rho) = 1.0:\n            raise ValueError(\"rho must be less than 1 for stationarity.\")\n            \n        sigma_z = sigma_eps / np.sqrt(1 - rho**2)\n        z_max = m * sigma_z\n        z_grid = np.linspace(-z_max, z_max, N)\n\n        # Step 2: Create the transition matrix\n        P = np.zeros((N, N))\n        step = z_grid[1] - z_grid[0]\n        \n        # Define bin boundaries as midpoints between grid points\n        midpoints = z_grid[:-1] + step / 2\n\n        for i in range(N):\n            # Conditional mean of z_{t+1} given z_t = z_grid[i]\n            mu_z_prime = rho * z_grid[i]\n            \n            # Probability for the first bin (-inf, midpoint_1]\n            z_val = (midpoints[0] - mu_z_prime) / sigma_eps\n            P[i, 0] = norm.cdf(z_val)\n            \n            # Probabilities for the middle bins (midpoint_{j-1}, midpoint_j]\n            for j in range(1, N - 1):\n                z_val_upper = (midpoints[j] - mu_z_prime) / sigma_eps\n                z_val_lower = (midpoints[j-1] - mu_z_prime) / sigma_eps\n                P[i, j] = norm.cdf(z_val_upper) - norm.cdf(z_val_lower)\n            \n            # Probability for the last bin (midpoint_{N-1}, +inf)\n            z_val = (midpoints[-1] - mu_z_prime) / sigma_eps\n            P[i, N - 1] = 1 - norm.cdf(z_val)\n            \n        return z_grid, P\n\n    def reverse_tauchen(z_grid, P):\n        \"\"\"\n        Estimates the parameters of an AR(1) process from its Tauchen\n        discretization.\n\n        Args:\n            z_grid (np.ndarray): The state grid.\n            P (np.ndarray): The transition matrix.\n\n        Returns:\n            tuple: A tuple containing the estimated parameters:\n                - rho_hat (float): Estimated persistence parameter.\n                - sigma_eps_hat (float): Estimated standard deviation of innovation.\n        \"\"\"\n        # Step 1: Estimate rho using OLS on E[z'|z] = rho*z\n        # Conditional expectation of the next state: E[z'|z] = P @ z\n        cond_exp = P @ z_grid\n        \n        # OLS estimator for regression through the origin: (z' * E[z'|z]) / (z' * z)\n        rho_hat = (z_grid @ cond_exp) / (z_grid @ z_grid)\n        \n        # Step 2: Estimate sigma_epsilon\n        # Conditional second moment: E[(z')^2|z] = P @ (z^2)\n        z_grid_sq = z_grid**2\n        cond_sec_moment = P @ z_grid_sq\n        \n        # Conditional variance: Var(z'|z) = E[(z')^2|z] - (E[z'|z])^2\n        cond_var = cond_sec_moment - cond_exp**2\n        \n        # sigma_eps^2 is the constant conditional variance, so we average\n        # the estimates from each state.\n        sigma_eps_sq_hat = np.mean(cond_var)\n        sigma_eps_hat = np.sqrt(sigma_eps_sq_hat)\n        \n        return rho_hat, sigma_eps_hat\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.9, 0.1, 7, 3.0),\n        (0.0, 0.2, 5, 3.0),\n        (0.99, 0.05, 11, 3.5),\n        (-0.5, 0.15, 9, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, sigma_eps, N, m = case\n        \n        # Generate the discrete approximation\n        z, P = forward_tauchen(rho, sigma_eps, N, m)\n        \n        # Estimate the parameters from the approximation\n        rho_hat, sigma_eps_hat = reverse_tauchen(z, P)\n        \n        results.append(rho_hat)\n        results.append(sigma_eps_hat)\n\n    # Format the results for the final print statement\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}