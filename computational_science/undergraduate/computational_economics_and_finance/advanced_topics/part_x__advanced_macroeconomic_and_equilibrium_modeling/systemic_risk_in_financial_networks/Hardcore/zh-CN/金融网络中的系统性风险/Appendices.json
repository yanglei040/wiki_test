{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的动态传染模型之前，一个关键的初始步骤是开发能够评估系统固有脆弱性的静态指标。本练习将指导你构建一个假设的“金融脆弱性”指数，它综合了网络的拓扑属性（如银行间的紧密程度）与机构的财务状况（如杠杆率）。通过这项实践，你将学习如何将抽象的网络度量与具体的金融数据相结合，从而创建一个单一、可解释的系统性风险度量。",
            "id": "2435773",
            "problem": "一个金融系统由一个包含5家银行（标记为$A,B,C,D,E$）的无向网络表示，其中两家银行之间的无向边表示双边风险暴露关系。其边集为 $\\{AB,AC,BC,BD,CD,DE\\}$。每家银行 $i$ 的总资产 $A_i$ 和净资产 $E_i$ 如下：\n- 银行 $A$：$A_A=100$， $E_A=10$。\n- 银行 $B$：$A_B=150$， $E_B=12.5$。\n- 银行 $C$：$A_C=120$， $E_C=15$。\n- 银行 $D$：$A_D=80$， $E_D=8$。\n- 银行 $E$：$A_E=50$， $E_E=10$。\n\n定义以下基本量：\n1. 一个无向简单图的全局聚类系数（传递性）$C$ 定义为 $C = \\dfrac{3 T}{W}$，其中 $T$ 是图中三角形的数量，$W$ 是连通顶点三元组的数量。一个连通三元组是一个无序的、由三个不同顶点构成的组合，其中至少有两条边共享一个共同顶点。\n2. 银行 $i$ 的节点杠杆率是 $L_i = \\dfrac{A_i}{E_i}$。总杠杆率是资产加权平均杠杆率\n$$\n\\bar{L} = \\sum_{i \\in \\{A,B,C,D,E\\}} \\omega_i L_i, \\quad \\text{其中 } \\omega_i = \\dfrac{A_i}{\\sum_{j \\in \\{A,B,C,D,E\\}} A_j}。\n$$\n\n一个“金融脆弱性”指数 $B$ 将通过以下校准方案结合拓扑结构和杠杆率来构建。首先，定义相对于两个锚定状态的线性归一化度量：\n$$\nx_C = \\dfrac{C - C_{\\mathrm{S}}}{C_{\\mathrm{R}} - C_{\\mathrm{S}}}, \\qquad x_L = \\dfrac{\\bar{L} - \\bar{L}_{\\mathrm{S}}}{\\bar{L}_{\\mathrm{R}} - \\bar{L}_{\\mathrm{S}}},\n$$\n其中“安全”锚点为 $(C_{\\mathrm{S}}, \\bar{L}_{\\mathrm{S}}) = (0, 5)$，“风险”锚点为 $(C_{\\mathrm{R}}, \\bar{L}_{\\mathrm{R}}) = (0.6, 15)$。\n\n设\n$$\nB = \\gamma + \\lambda \\big( w x_L + (1-w) x_C \\big),\n$$\n其中杠杆率的权重是聚类系数的两倍，因此 $w = \\dfrac{2}{3}$。常数 $\\gamma$ 和 $\\lambda$ 由校准条件决定：在安全锚点处 $B=0.2$，在风险锚点处 $B=0.8$。\n\n使用这些定义和校准，计算给定网络的脆弱性指数 $B$。将最终结果四舍五入到四位有效数字。答案以纯数字形式表示，不带单位。",
            "solution": "该问题定义明确、内容完整，并与网络科学和金融建模的原理一致。所有必要的数据和定义均已提供，可以得出唯一解。因此，我将系统地计算金融脆弱性指数 $B$。\n\n计算过程分为五个连续步骤：(1) 计算网络的全局聚类系数 $C$；(2) 计算系统的总杠杆率 $\\bar{L}$；(3) 对这两个度量进行归一化处理；(4) 校准脆弱性指数公式；(5) 计算 $B$ 的最终值。\n\n首先，我们分析网络拓扑以求得全局聚类系数 $C = \\frac{3T}{W}$。该网络由 $N=5$ 个顶点（银行）$\\{A, B, C, D, E\\}$ 和边集 $\\{AB, AC, BC, BD, CD, DE\\}$ 组成。\n$T$ 是三角形（3个顶点的完全子图）的数量。通过检查边集：\n-   顶点集 $\\{A, B, C\\}$ 构成一个三角形，因为边 $AB$、$AC$ 和 $BC$ 都存在。\n-   顶点集 $\\{B, C, D\\}$ 构成一个三角形，因为边 $BC$、$BD$ 和 $CD$ 都存在。\n没有其他三个顶点的组合能构成三角形。因此，三角形的数量为 $T=2$。\n\n$W$ 是连通三元组的数量，即长度为2的路径。以顶点 $v$ 为中心的此类路径的数量由 $\\binom{d(v)}{2}$ 给出，其中 $d(v)$ 是顶点 $v$ 的度。我们首先计算所有顶点的度：\n-   $d(A) = 2$（连接到 $B, C$）\n-   $d(B) = 3$（连接到 $A, C, D$）\n-   $d(C) = 3$（连接到 $A, B, D$）\n-   $d(D) = 3$（连接到 $B, C, E$）\n-   $d(E) = 1$（连接到 $D$）\n连通三元组的总数是所有顶点上该值的总和：\n$$W = \\sum_{i \\in \\{A,B,C,D,E\\}} \\binom{d(i)}{2} = \\binom{2}{2} + \\binom{3}{2} + \\binom{3}{2} + \\binom{3}{2} + \\binom{1}{2}$$\n$$W = 1 + 3 + 3 + 3 + 0 = 10$$\n现在，我们可以计算全局聚类系数：\n$$C = \\frac{3T}{W} = \\frac{3 \\times 2}{10} = \\frac{6}{10} = 0.6$$\n\n第二步，我们计算总杠杆率 $\\bar{L}$。首先，我们计算每家银行的杠杆率 $L_i = \\frac{A_i}{E_i}$：\n-   $L_A = \\frac{A_A}{E_A} = \\frac{100}{10} = 10$\n-   $L_B = \\frac{A_B}{E_B} = \\frac{150}{12.5} = 12$\n-   $L_C = \\frac{A_C}{E_C} = \\frac{120}{15} = 8$\n-   $L_D = \\frac{A_D}{E_D} = \\frac{80}{8} = 10$\n-   $L_E = \\frac{A_E}{E_E} = \\frac{50}{10} = 5$\n接下来，我们确定资产加权平均值。系统中的总资产为：\n$$\\sum_{j} A_j = A_A + A_B + A_C + A_D + A_E = 100 + 150 + 120 + 80 + 50 = 500$$\n权重 $\\omega_i = \\frac{A_i}{\\sum_j A_j}$ 为：\n-   $\\omega_A = \\frac{100}{500} = 0.2$\n-   $\\omega_B = \\frac{150}{500} = 0.3$\n-   $\\omega_C = \\frac{120}{500} = 0.24$\n-   $\\omega_D = \\frac{80}{500} = 0.16$\n-   $\\omega_E = \\frac{50}{500} = 0.1$\n总杠杆率 $\\bar{L}$ 是加权和：\n$$\\bar{L} = \\sum_{i} \\omega_i L_i = (0.2)(10) + (0.3)(12) + (0.24)(8) + (0.16)(10) + (0.1)(5)$$\n$$\\bar{L} = 2.0 + 3.6 + 1.92 + 1.6 + 0.5 = 9.62$$\n\n第三步，我们使用给定的锚定状态对计算出的 $C$ 和 $\\bar{L}$ 值进行归一化：“安全”锚点 $(C_{\\mathrm{S}}, \\bar{L}_{\\mathrm{S}}) = (0, 5)$ 和“风险”锚点 $(C_{\\mathrm{R}}, \\bar{L}_{\\mathrm{R}}) = (0.6, 15)$。\n归一化的聚类度量是：\n$$x_C = \\frac{C - C_{\\mathrm{S}}}{C_{\\mathrm{R}} - C_{\\mathrm{S}}} = \\frac{0.6 - 0}{0.6 - 0} = 1$$\n归一化的杠杆率度量是：\n$$x_L = \\frac{\\bar{L} - \\bar{L}_{\\mathrm{S}}}{\\bar{L}_{\\mathrm{R}} - \\bar{L}_{\\mathrm{S}}} = \\frac{9.62 - 5}{15 - 5} = \\frac{4.62}{10} = 0.462$$\n\n第四步，我们使用边界条件校准脆弱性指数 $B = \\gamma + \\lambda(w x_L + (1-w) x_C)$。\n在安全锚点，$(x_C, x_L)=(0,0)$ 且 $B=0.2$。代入这些值得到：\n$$0.2 = \\gamma + \\lambda(w \\cdot 0 + (1-w) \\cdot 0) \\implies \\gamma = 0.2$$\n在风险锚点，$(x_C, x_L)=(1,1)$ 且 $B=0.8$。代入这些值得到：\n$$0.8 = \\gamma + \\lambda(w \\cdot 1 + (1-w) \\cdot 1) = \\gamma + \\lambda$$\n使用 $\\gamma = 0.2$，我们解出 $\\lambda$：\n$$0.8 = 0.2 + \\lambda \\implies \\lambda = 0.6$$\n校准后的脆弱性指数公式为 $B = 0.2 + 0.6(w x_L + (1-w) x_C)$。\n\n第五步，我们计算给定网络的 $B$ 的最终值。我们使用计算出的归一化值 $x_C=1$ 和 $x_L=0.462$，以及给定的权重 $w = \\frac{2}{3}$。\n$$B = 0.2 + 0.6 \\left( \\left(\\frac{2}{3}\\right) x_L + \\left(1-\\frac{2}{3}\\right) x_C \\right)$$\n$$B = 0.2 + 0.6 \\left( \\left(\\frac{2}{3}\\right)(0.462) + \\left(\\frac{1}{3}\\right)(1) \\right)$$\n$$B = 0.2 + 0.6 \\left( \\frac{2 \\times 0.462 + 1}{3} \\right)$$\n$$B = 0.2 + 0.2 (0.924 + 1)$$\n$$B = 0.2 + 0.2 (1.924)$$\n$$B = 0.2 + 0.3848 = 0.5848$$\n题目要求将结果四舍五入到四位有效数字。计算出的值 $0.5848$ 已经有四位有效数字。",
            "answer": "$$\n\\boxed{0.5848}\n$$"
        },
        {
            "introduction": "在学会衡量静态风险之后，下一步是理解冲击如何在网络中动态传播。本练习将向你介绍一个确定性的违约级联模型，这是金融传染的核心机制。通过模拟“监管套利”——即银行将部分业务转移到一个更脆弱的“影子”银行层——你将亲眼观察到金融系统结构的变化如何显著放大其崩溃的风险，即使面对的是相同的初始冲击。",
            "id": "2435816",
            "problem": "给定一个程式化的银行间网络，该网络包含两个债务层，分别代表受监管层和影子（不受监管）层。银行可以将其一部分银行间总债务通过影子层进行转移，而影子层由于违约回收率较低而更为脆弱。该金融体系根据资产负债表恒等式和一个带有违约损失的离散时间违约级联，进行确定性的演变。\n\n基本基础：\n- 对于每家银行 $i$，其权益由会计恒等式定义：$q_i = A_i - P_i$，其中 $A_i$ 是总资产，$P_i$ 是总负债。有限责任原则意味着当 $q_i < 0$ 时发生违约。\n- 银行间债务由一个负债矩阵 $\\mathbf{L} \\in \\mathbb{R}_+^{N \\times N}$ 表示，其中条目 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 的金额为 $L_{ij}$。对于每家银行 $i$，其银行间总负债为 $\\bar{p}_i = \\sum_{j=1}^N L_{ij}$，银行间总资产为 $\\sum_{k=1}^N L_{ki}$。\n- 外部资产 $e_i \\ge 0$ 受到一个外生的、确定性的冲击量 $\\Delta_i \\ge 0$，产生冲击后的外部资产 $e_i - \\Delta_i$。\n- 违约损失率（LGD）被确定性地建模：当债务人违约时，每个债权人对其违约敞口实现固定的回收率。受监管层的回收率为 $r_R \\in [0,1]$，影子层的回收率为 $r_S \\in [0,1]$，且 $r_S < r_R$。相应的LGD值为 $1 - r_R$ 和 $1 - r_S$。\n\n分层结构与监管套利：\n- 对于给定的转移比例 $s \\in [0,1]$，每笔双边总债务被分解为受监管层的 $L_{ij}^{(R)} = (1-s) L_{ij}$ 和影子层的 $L_{ij}^{(S)} = s L_{ij}$。\n- 当银行 $j$ 违约时，任何对 $j$ 有敞口的债权人 $i$ 将确定性地损失\n$$\n\\text{loss}_{i \\leftarrow j}(s) = (1-r_R) L_{j i}^{(R)} + (1-r_S) L_{j i}^{(S)} = \\big( (1-s)(1-r_R) + s(1-r_S) \\big) L_{j i}.\n$$\n定义有效损失乘数\n$$\nm(s) = (1-s)(1-r_R) + s(1-r_S).\n$$\n\n传染机制（离散时间级联）：\n- 步骤 $0$：计算每家银行 $i$ 的初始冲击后权益，\n$$\nq_i^{(0)} = \\big(e_i - \\Delta_i\\big) + \\sum_{k=1}^N L_{k i} - \\sum_{j=1}^N L_{i j}.\n$$\n任何满足 $q_i^{(0)} < 0$ 的银行 $i$ 在步骤 $0$ 违约。\n- 步骤 $t \\ge 1$：对于在步骤 $t-1$ 新违约的每个债务人 $j$，将每个债权人 $i$ 的权益减少 $\\text{loss}_{i \\leftarrow j}(s) = m(s) L_{j i}$。如果此减少导致某个有偿付能力的银行 $i$ 的权益变为 $q_i^{(t)} < 0$，则银行 $i$ 成为步骤 $t$ 的新违约者。每个债务人仅在其首次违约时触发一次损失。迭代直至没有新的违约发生。\n\n你的任务：\n- 针对以下固定的网络和参数值，实现此确定性级联算法。\n- 对每个测试案例，输出最终违约银行的总数，结果为一个非负整数。\n\n固定的网络和回收率：\n- 银行数量：$N = 3$。\n- 银行间负债矩阵 $\\mathbf{L}$，其中行代表债务人，列代表债权人：\n$$\n\\mathbf{L} =\n\\begin{bmatrix}\n0  70  0 \\\\\n0  0  80 \\\\\n30  0  0\n\\end{bmatrix}.\n$$\n- 外部资产向量：\n$$\n\\mathbf{e} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix}.\n$$\n- 受监管层回收率 $r_R = 0.9$，影子层回收率 $r_S = 0.2$。\n\n测试套件：\n每个测试案例指定了转移比例 $s$ 和外部冲击向量 $\\boldsymbol{\\Delta}$。所有的 $s$ 值均为 $[0,1]$ 区间内的小数，$\\boldsymbol{\\Delta}$ 的所有分量均为非负实数。\n\n- 测试 1：$s = 0.0$, $\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 2：$s = 0.3$, $\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 3：$s = 0.5$, $\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 4：$s = 1.0$, $\\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 5：$s = 0.8$, $\\boldsymbol{\\Delta} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n\n程序要求：\n- 编写一个完整的、可运行的程序，使用上述级联机制和固定数据，计算每个测试案例的最终违约数量。不允许有随机性。\n- 最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，例如 $[x_1,x_2,\\dots,x_5]$，其中每个 $x_k$ 是按上述顺序列出的测试 $k$ 的违约整数数量。",
            "solution": "所呈现的问题是计算金融领域一个定义明确的练习，具体涉及在一个程式化的多层银行间网络中系统性风险的传播。所有必要的参数和动态都以足够的清晰度和数学严谨性给出。因此，该问题是有效的，并且可以推导出确定性的解。\n\n问题的核心在于追踪在初始冲击和随后的传染效应下银行权益的演变。该系统由一组 $N$ 家银行、它们的银行间债务以及它们持有的外部资产定义。金融结构由每家银行 $i$ 的基本资产负债表恒等式决定：\n$$\nq_i = A_i - P_i\n$$\n其中 $q_i$ 是权益，$A_i$ 是总资产，$P_i$ 是总负债。根据有限责任原则，如果银行的权益变为负数，即 $q_i  0$，则该银行被视为违约。\n\n银行 $i$ 的总资产 $A_i$ 由其外部资产 $e_i$ 和其银行间资产 $\\bar{a}_i$（即对其他银行的债权）组成。总负债 $P_i$ 是其银行间负债 $\\bar{p}_i$（即对其他银行的债务）。银行间敞口被编码在负债矩阵 $\\mathbf{L}$ 中，其中 $L_{ij}$ 代表银行 $i$ 欠银行 $j$ 的金额。\n因此，对于每家银行 $i$，我们可以写出：\n- 银行间总负债：$\\bar{p}_i = \\sum_{j=1}^N L_{ij}$\n- 银行间总资产：$\\bar{a}_i = \\sum_{k=1}^N L_{ki}$\n\n因此，银行 $i$ 的初始冲击前权益为：\n$$\nq_{i, \\text{pre-shock}} = e_i + \\bar{a}_i - \\bar{p}_i\n$$\n\n对于给定的 $N=3$ 的网络：\n- 负债矩阵：$\\mathbf{L} = \\begin{bmatrix} 0  70  0 \\\\ 0  0  80 \\\\ 30  0  0 \\end{bmatrix}$\n- 外部资产：$\\mathbf{e} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix}$\n\n我们首先通过对 $\\mathbf{L}$ 的行求和来计算银行间总负债向量 $\\bar{\\mathbf{p}}$：\n$$\n\\bar{\\mathbf{p}} = \\begin{bmatrix} 0+70+0 \\\\ 0+0+80 \\\\ 30+0+0 \\end{bmatrix} = \\begin{bmatrix} 70 \\\\ 80 \\\\ 30 \\end{bmatrix}\n$$\n接下来，我们通过对 $\\mathbf{L}$ 的列求和来计算银行间总资产向量 $\\bar{\\mathbf{a}}$：\n$$\n\\bar{\\mathbf{a}} = \\begin{bmatrix} 0+0+30 \\\\ 70+0+0 \\\\ 0+80+0 \\end{bmatrix} = \\begin{bmatrix} 30 \\\\ 70 \\\\ 80 \\end{bmatrix}\n$$\n初始的、冲击前的权益向量 $\\mathbf{q}_{\\text{pre-shock}}$ 为：\n$$\n\\mathbf{q}_{\\text{pre-shock}} = \\mathbf{e} + \\bar{\\mathbf{a}} - \\bar{\\mathbf{p}} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix} + \\begin{bmatrix} 30 \\\\ 70 \\\\ 80 \\end{bmatrix} - \\begin{bmatrix} 70 \\\\ 80 \\\\ 30 \\end{bmatrix} = \\begin{bmatrix} 20 \\\\ 20 \\\\ 55 \\end{bmatrix}\n$$\n所有银行初始时都有偿付能力。传染过程始于对外部资产的外生冲击 $\\boldsymbol{\\Delta}$。\n\n传染机制关键取决于违约损失率，该损失率由受监管层（$r_R=0.9$）和影子层（$r_S=0.2$）的回收率决定。转移到影子层的债务比例为 $s$。当一家银行违约时，其债权人会遭受损失。该损失被有效损失乘数 $m(s)$ 放大：\n$$\nm(s) = (1-s)(1-r_R) + s(1-r_S) = (1-s)(1-0.9) + s(1-0.2) = 0.1(1-s) + 0.8s = 0.1 + 0.7s\n$$\n级联以离散时间步进行。\n\n**步骤 0：初始冲击**\n初始冲击后权益向量 $\\mathbf{q}^{(0)}$ 计算如下：\n$$\n\\mathbf{q}^{(0)} = \\mathbf{q}_{\\text{pre-shock}} - \\boldsymbol{\\Delta}\n$$\n任何满足 $q_i^{(0)}  0$ 的银行 $i$ 被宣告违约。\n\n**步骤 $t \\ge 1$：传染**\n如果一组银行 $D_{t-1}$ 在步骤 $t-1$ 新违约，那么对于每个未违约的银行 $i$，其权益被更新以反映这些新违约带来的损失：\n$$\nq_i^{(t)} = q_i^{(t-1)} - \\sum_{j \\in D_{t-1}} m(s) L_{ji}\n$$\n任何银行 $i$，如果其 $q_i^{(t)}$ 跌破零，则成为步骤 $t$ 的新违约者。该过程被迭代直至某个步骤中没有新的违约发生。\n\n我们现在对每个测试案例进行求解。\n\n**测试案例 1：** $s = 0.0$, $\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.0) = 0.1 + 0.7(0.0) = 0.1$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [20, 20, 55]^T - [55, 0, 0]^T = [-35, 20, 55]^T$。银行 1 ($q_1^{(0)} = -35  0$) 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 欠银行 2 的金额为 $L_{12} = 70$。\n  - 银行 2 的损失：$m(0.0) \\times L_{12} = 0.1 \\times 70 = 7$。\n  - 银行 2 的权益：$q_2^{(1)} = q_2^{(0)} - 7 = 20 - 7 = 13$。银行 2 仍有偿付能力。\n- 无进一步违约。级联终止。\n- 违约总数：$1$。\n\n**测试案例 2：** $s = 0.3$, $\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.3) = 0.1 + 0.7(0.3) = 0.1 + 0.21 = 0.31$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 的违约传播。\n  - 银行 2 的损失：$m(0.3) \\times L_{12} = 0.31 \\times 70 = 21.7$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 21.7 = -1.7$。银行 2 ($q_2^{(1)}  0$) 违约。违约集合：$\\{1, 2\\}$。\n- 步骤 2：银行 2 的违约传播。银行 2 欠银行 3 的金额为 $L_{23} = 80$。\n  - 银行 3 的损失：$m(0.3) \\times L_{23} = 0.31 \\times 80 = 24.8$。\n  - 银行 3 的权益：$q_3^{(2)} = q_3^{(0)} - 24.8 = 55 - 24.8 = 30.2$。银行 3 仍有偿付能力。\n- 无进一步违约。级联终止。\n- 违约总数：$2$。\n\n**测试案例 3：** $s = 0.5$, $\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.5) = 0.1 + 0.7(0.5) = 0.1 + 0.35 = 0.45$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 的违约传播。\n  - 银行 2 的损失：$m(0.5) \\times L_{12} = 0.45 \\times 70 = 31.5$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 31.5 = -11.5$。银行 2 违约。违约集合：$\\{1, 2\\}$。\n- 步骤 2：银行 2 的违约传播。\n  - 银行 3 的损失：$m(0.5) \\times L_{23} = 0.45 \\times 80 = 36$。\n  - 银行 3 的权益：$q_3^{(2)} = 55 - 36 = 19$。银行 3 仍有偿付能力。\n- 无进一步违约。\n- 违约总数：$2$。\n\n**测试案例 4：** $s = 1.0$, $\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(1.0) = 0.1 + 0.7(1.0) = 0.8$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 违约。\n  - 银行 2 的损失：$m(1.0) \\times L_{12} = 0.8 \\times 70 = 56$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 56 = -36$。银行 2 违约。违约集合：$\\{1, 2\\}$。\n- 步骤 2：银行 2 违约。\n  - 银行 3 的损失：$m(1.0) \\times L_{23} = 0.8 \\times 80 = 64$。\n  - 银行 3 的权益：$q_3^{(2)} = 55 - 64 = -9$。银行 3 违约。违约集合：$\\{1, 2, 3\\}$。\n- 步骤 3：银行 3 的违约传播。银行 3 欠银行 1 的金额为 $L_{31}=30$。由于银行 1 已经违约，这对违约者集合没有影响。\n- 整个系统已经崩溃。\n- 违约总数：$3$。\n\n**测试案例 5：** $s = 0.8$, $\\boldsymbol{\\Delta} = [0, 0, 0]^T$\n- 损失乘数：$m(0.8) = 0.1 + 0.7(0.8) = 0.66$。\n- 步骤 0：$\\mathbf{q}^{(0)} = \\mathbf{q}_{\\text{pre-shock}} - [0, 0, 0]^T = [20, 20, 55]^T$。\n- 所有初始权益均为正。没有初始违约。\n- 级联未被启动。\n- 违约总数：$0$。\n\n分析揭示了一个关键现象：随着金融体系将债务转移到一个监管更少、更脆弱的“影子”层（即 $s$ 增加），其对初始冲击的抵御能力下降。一个在 $s=0.0$ 时被控制住的冲击，在 $s$ 取中间值时导致了部分级联，而在 $s=1.0$ 时导致了完全的系统性崩溃。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the number of defaulted banks in a stylized interbank network\n    for a given set of test cases.\n    \"\"\"\n\n    # Fixed network parameters\n    # L_ij means bank i (row) owes bank j (column)\n    L = np.array([\n        [0.0, 70.0, 0.0],\n        [0.0, 0.0, 80.0],\n        [30.0, 0.0, 0.0]\n    ])\n    e = np.array([60.0, 30.0, 5.0])\n    r_R = 0.9\n    r_S = 0.2\n    N = 3\n\n    # Test cases: (shift fraction s, shock vector Delta)\n    test_cases = [\n        (0.0, np.array([55.0, 0.0, 0.0])),\n        (0.3, np.array([55.0, 0.0, 0.0])),\n        (0.5, np.array([55.0, 0.0, 0.0])),\n        (1.0, np.array([55.0, 0.0, 0.0])),\n        (0.8, np.array([0.0, 0.0, 0.0]))\n    ]\n\n    results = []\n\n    # Calculate fixed network properties once\n    p_bar = np.sum(L, axis=1)  # Total interbank liabilities (row sums)\n    a_bar = np.sum(L, axis=0)  # Total interbank assets (column sums)\n    q_pre_shock = e + a_bar - p_bar\n\n    for s, Delta in test_cases:\n        # Effective loss multiplier for the current s\n        m_s = (1 - s) * (1 - r_R) + s * (1 - r_S)\n\n        # Step 0: Initial shock and defaults\n        q = q_pre_shock - Delta\n        \n        # Sets to track defaulted banks\n        # Bank indices are 1-based, numpy arrays are 0-based\n        defaulted_banks = set(np.where(q  0)[0] + 1)\n        newly_defaulted = defaulted_banks.copy()\n        \n        # Iterative contagion process\n        while newly_defaulted:\n            # Banks that defaulted in the previous wave trigger new losses\n            current_wave_defaulters = newly_defaulted.copy()\n            newly_defaulted.clear()\n            \n            for j_defaulter in current_wave_defaulters:\n                # Propagate losses to creditors of the defaulted bank j_defaulter\n                # A bank i is a creditor if L[j-1, i-1] > 0\n                for i_creditor in range(1, N + 1):\n                    # Continue if creditor is already defaulted\n                    if i_creditor in defaulted_banks:\n                        continue\n                    \n                    # Calculate loss for creditor i from defaulter j\n                    # L is indexed by (borrower, creditor)\n                    loss = m_s * L[j_defaulter - 1, i_creditor - 1]\n                    \n                    if loss > 0:\n                        # Update equity of the creditor\n                        q[i_creditor - 1] -= loss\n                        \n                        # Check if the creditor defaults\n                        if q[i_creditor - 1]  0:\n                            defaulted_banks.add(i_creditor)\n                            newly_defaulted.add(i_creditor)\n        \n        # The result for this case is the total number of defaulted banks\n        results.append(len(defaulted_banks))\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解和模拟传染过程本身不是最终目的，我们的最终目标是设计出有效的干预措施。本练习将让你扮演监管者的角色，任务是寻找最具成本效益的方式来阻止一场违约级联。通过模拟不同的“防火墙”策略——即为特定的银行间负债提供担保——你将学习如何运用传染模型进行政策分析，并在一个网络中识别出最优的干预点。",
            "id": "2435828",
            "problem": "给定一个银行间传染模型，其中包含一组固定的银行，由整数 $0$ 到 $n-1$ 索引。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为银行间总负债矩阵，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的名义金额。设 $E \\in \\mathbb{R}_{0}^n$ 为初始权益向量，其中 $E_i$ 是银行 $i$ 的初始权益。设 $R \\in [0,1]$ 为银行间债权的共同外生回收率，因此违约损失率为 $\\lambda = 1 - R$。一个单一的外生冲击作用于指定的银行 $s \\in \\{0,1,\\dots,n-1\\}$，使其权益减少了 $\\Delta \\in \\mathbb{R}_{\\ge 0}$。传染的动态遵循以下原则。\n\n- 资产负债表影响规则：当银行 $i$ 在某个传染轮次中违约时，其每个债权银行 $j$ 在随后的更新中会遭受 $\\lambda \\, L_{ij}$ 的权益损失。\n- 违约标准：任何轮次中，只要银行 $i$ 的权益小于或等于零，它就处于违约状态。一旦银行违约，它将保持违约状态，不会恢复。\n- 更新时间表：在时间 $t=0$ 时，对银行 $s$ 施加外生冲击，将其权益设置为 $E_s - \\Delta$。确定权益小于或等于零的银行集合 $D_0$。对于 $t=1,2,\\dots$，令 $N_t$ 为在 $t-1$ 轮次中新违约的银行子集（即，属于 $D_{t-1}$ 但不属于 $D_{t-2}$ 的银行，约定 $D_{-1}=\\varnothing$）。对于任何 $i \\in N_t$ 的每个债权人 $j$ 在第 $t$ 轮次中遭受 $\\lambda \\, L_{ij}$ 的权益损失。然后更新所有权益小于或等于零的银行集合 $D_t$。当首次出现 $T$ 使得 $D_T = D_{T-1}$ 时，过程终止。\n- 担保干预：监管机构可以选择最多一个有序对 $(i,j)$（其中 $L_{ij}  0$）进行担保。如果银行 $i$ 违约，则债权人 $j$ 不会因被担保的负债 $(i,j)$ 而遭受任何损失。当且仅当银行 $i$ 在传染过程中违约时，担保负债 $(i,j)$ 的已实现财政成本为 $\\lambda \\, L_{ij}$；否则，成本为 $0$。\n\n目标是按照以下精确定义来阻止传染级联：在实施担保且传染过程终止后，要么没有任何银行违约，要么唯一违约的银行是最初受冲击的银行 $s$。在所有能实现此目标的单一负债担保中，监管机构应选择一个能最小化上述定义的已实现财政成本的担保。如果多个担保都能达到最小已实现成本，则选择索引对 $(i,j)$ 字典序最小的那个，其中当且仅当 $i  i'$ 或 $i=i'$ 且 $j  j'$ 时，有 $(i,j)  (i',j')$。如果在没有任何担保的情况下级联已经停止，则不采取任何行动。如果没有任何单一担保可以阻止级联，则报告为不可能。\n\n对于以下测试套件中的每个测试用例，您的程序必须输出所选的担保，形式为列表 $[i,j,c]$，其中 $i$ 和 $j$ 是整数，$c$ 是已实现成本（实数）。对于特殊情况，请使用以下约定：\n- 如果因为级联在没有干预的情况下已经停止而不需要担保，则输出 $[-1,-1,0.0]$。\n- 如果无法通过任何单一担保来阻止级联，则输出 $[-2,-2,-1.0]$。\n\n测试套件：\n- 用例1：\n  - $n = 4$。\n  - $R = 0.4$。\n  - $E = [0.3,\\, 0.5,\\, 0.7,\\, 0.5]$。\n  - $L$ 的非零项为 $L_{0,1} = 1.0$，$L_{0,2} = 0.1$，$L_{1,2} = 1.2$，$L_{2,3} = 1.0$，所有其他 $L_{i,j} = 0$。\n  - 受冲击银行 $s = 0$，冲击幅度 $\\Delta = 0.5$。\n- 用例2：\n  - $n = 3$。\n  - $R = 0.5$。\n  - $E = [0.2,\\, 0.2,\\, 0.2]$。\n  - $L$ 的非零项为 $L_{0,1} = 0.5$，$L_{0,2} = 0.5$，所有其他 $L_{i,j} = 0$。\n  - 受冲击银行 $s = 0$，冲击幅度 $\\Delta = 0.5$。\n- 用例3：\n  - $n = 3$。\n  - $R = 0.4$。\n  - $E = [0.5,\\, 0.5,\\, 0.5]$。\n  - $L$ 的非零项为 $L_{0,1} = 0.1$，$L_{0,2} = 0.1$，所有其他 $L_{i,j} = 0$。\n  - 受冲击银行 $s = 0$，冲击幅度 $\\Delta = 0.4$。\n- 用例4：\n  - $n = 5$。\n  - $R = 0.2$。\n  - $E = [0.3,\\, 0.9,\\, 0.6,\\, 0.6,\\, 1.0]$。\n  - $L$ 的非零项为 $L_{0,1} = 0.2$，$L_{0,2} = 0.8$，$L_{2,3} = 0.8$，$L_{3,4} = 0.9$，所有其他 $L_{i,j} = 0$。\n  - 受冲击银行 $s = 0$，冲击幅度 $\\Delta = 0.5$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有用例的结果，结果是一个用方括号括起来的逗号分隔列表，每个结果本身都是 $[i,j,c]$ 形式的列表，不含空格。例如，包含三个用例的输出应如下所示：$[[i_1,j_1,c_1],[i_2,j_2,c_2],[i_3,j_3,c_3]]$。",
            "solution": "该问题要求我们找到一个最优的单一负债担保，以减轻金融网络中的系统性风险。该网络由 $n$ 家银行组成，它们的相互关联性由负债矩阵 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 描述，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。每家银行 $i$ 都有一个初始资本缓冲，即其权益 $E_i  0$。传染过程由对单一银行 $s$ 的权益施加大小为 $\\Delta \\ge 0$ 的外生冲击引发。目标是选择一个能“阻止”随之而来的违约级联的担保，其定义是达到一个最终状态，在该状态下，要么没有银行违约，要么只有最初受冲击的银行 $s$ 违约。在所有能实现此目标的担保中，我们必须选择一个能最小化已实现财政成本的担保，并对被担保的负债 $(i,j)$ 使用字典序决胜规则。\n\n系统动态是时间离散的。在时间 $t=0$ 时，冲击被施加，因此银行 $s$ 的权益变为 $E_s - \\Delta$。如果一家银行 $i$ 的权益变得小于或等于 $0$，则定义为处于违约状态。令 $D_t$ 为第 $t$ 轮结束时所有违约银行的集合。集合 $D_0$ 在初始冲击后立即确定。对于随后的轮次 $t=1, 2, \\dots$，我们确定新违约银行的集合 $N_t = D_{t-1} \\setminus D_{t-2}$ (约定 $D_{-1} = \\varnothing$)。这些银行的倒闭会给其债权人造成损失。具体来说，对于每个 $i \\in N_t$，每个债权银行 $j$ 都会遭受等于 $\\lambda L_{ij}$ 的损失，其中 $\\lambda = 1-R$ 是违约损失率，$R \\in [0,1]$ 是回收率。这些损失从债权人的当前权益中扣除。之后，违约银行集合 $D_t$ 会更新，以包括任何权益已降至 $0$ 或以下的银行。当某一轮没有新的违约发生时，即对于某个轮次 $T$ 有 $D_T = D_{T-1}$ 时，过程终止。\n\n对负债 $(i,j)$ 的担保意味着如果银行 $i$ 违约，相关的损失 $\\lambda L_{ij}$ 不会传递给银行 $j$。如果银行 $i$ 在此过程中违约，此担保的已实现财政成本为 $\\lambda L_{ij}$，否则为 $0$。我们的任务是找到最佳的此类担保。\n\n解决方案策略是对所有可能的单一负债担保进行系统性搜索。该策略的核心是一个函数，用于模拟任何给定场景（包括指定的担保）下的传染过程。\n\n首先，我们必须通过模拟无担保情况下的传染来建立基线。设初始权益向量为 $E$。银行 $s$ 的权益减少到 $E_s - \\Delta$。然后我们迭代计算后果。设 $E^{(t)}$ 为第 $t$ 轮开始时的权益向量。我们从 $E^{(0)} = E$ 开始。使用一个临时向量 $E'_{s} = E^{(0)}_{s} - \\Delta$ 和 $E'_{k}=E^{(0)}_{k}$ (当 $k \\ne s$ 时) 来确定 $D_0$。设 $D_{new}$ 为一轮中新违约银行的集合。模拟过程如下：\n1. 从初始向量 $E$ 初始化当前权益 $E_{current}$。对银行 $s$ 施加冲击：$E_{current,s} \\leftarrow E_{current,s} - \\Delta$。\n2. 确定初始违约银行的集合 $D_0 = \\{i \\mid E_{current,i} \\le 0\\}$。设置 $D_{total} = D_0$ 和 $D_{new} = D_0$。\n3. 当 $D_{new}$ 不为空时：\n    a. 计算每家银行的总损失。对于每个债权银行 $k$，总损失为 $\\sum_{i \\in D_{new}} \\lambda L_{ik}(\\mathcal{G})$，其中如果 $(i,k)$ 是被担保的负债 $\\mathcal{G}$，则 $L_{ik}(\\mathcal{G})$ 为 $0$，否则为 $L_{ik}$。\n    b. 更新权益：$E_{current} \\leftarrow E_{current} - \\text{losses}$。\n    c. 确定本轮新的违约集合：$D_{round} = \\{j \\mid E_{current,j} \\le 0 \\text{ and } j \\notin D_{total}\\}$。\n    d. 更新集合：$D_{new} = D_{round}$，并且 $D_{total} = D_{total} \\cup D_{new}$。\n4. 当 $D_{new}$ 为空时，模拟终止。最终的违约银行集合为 $D_{total}$。\n\n如果基线模拟得到的违约集合为空或仅包含银行 $s$，则无需干预，正确输出为 $[-1, -1, 0.0]$。\n\n否则，我们必须搜索最优担保。可能的担保集合包括所有满足 $L_{ij}  0$ 的对 $(i,j)$。我们生成这些对的列表，并按字典序排序以遵守决胜规则。我们将目前找到的最小成本 $c_{min}$ 初始化为无穷大，并将最佳担保选择初始化为空值。\n\n然后，我们遍历排序后的潜在担保列表。对于每个担保 $(i,j)$：\n1. 我们运行带有此担保的传染模拟。\n2. 我们检查最终的违约银行集合 $D_{final}$ 是否满足停止条件：$D_{final} = \\varnothing$ 或 $D_{final} = \\{s\\}$。\n3. 如果满足条件，我们计算已实现成本。如果债务人银行 $i$ 在 $D_{final}$ 中，成本为 $c = \\lambda L_{ij}$，否则 $c=0$。\n4. 我们将此成本 $c$ 与目前找到的最小成本 $c_{min}$ 进行比较。如果 $c  c_{min}$，我们就找到了一个新的最佳解决方案。我们更新 $c_{min} = c$ 并将 $(i,j,c)$ 存储为当前最佳选择。由于我们是按字典序遍历担保，此过程自动遵守了决胜规则。\n\n检查完所有可能的担保后，如果我们找到了至少一个能阻止传染的担保，那么存储的最佳选择就是我们的答案。如果没有单一担保能够阻止级联，则认为是不可能的，输出为 $[-2, -2, -1.0]$。这种全面搜索确保了根据问题标准找到最优干预措施。",
            "answer": "```python\nimport numpy as np\n\ndef simulate_contagion(n, L, E, R, s, delta, guarantee=(-1, -1)):\n    \"\"\"\n    Simulates the interbank contagion process.\n\n    Args:\n        n (int): Number of banks.\n        L (np.array): n x n liability matrix.\n        E (list or np.array): Vector of initial equities.\n        R (float): Recovery rate.\n        s (int): Index of the shocked bank.\n        delta (float): Magnitude of the shock.\n        guarantee (tuple): The (i, j) pair for the guaranteed liability.\n\n    Returns:\n        set: The set of indices of defaulted banks at the end of the process.\n    \"\"\"\n    lambda_val = 1.0 - R\n    E_current = np.array(E, dtype=float)\n\n    # Apply initial shock\n    E_current[s] -= delta\n\n    defaulted_total = set()\n    newly_defaulted = set()\n\n    # Check for initial defaults after the shock (round 0)\n    for i in range(n):\n        if E_current[i] = 0:\n            newly_defaulted.add(i)\n    \n    defaulted_total.update(newly_defaulted)\n\n    # Propagate contagion in rounds\n    while newly_defaulted:\n        losses = np.zeros(n)\n        for i in newly_defaulted:\n            for j in range(n):\n                if L[i, j] > 0:\n                    if (i, j) == guarantee:\n                        # This liability is guaranteed, no loss passes to bank j\n                        pass\n                    else:\n                        losses[j] += lambda_val * L[i, j]\n        \n        E_current -= losses\n        \n        round_defaults = set()\n        for k in range(n):\n            if E_current[k] = 0 and k not in defaulted_total:\n                round_defaults.add(k)\n        \n        newly_defaulted = round_defaults\n        defaulted_total.update(newly_defaulted)\n        \n    return defaulted_total\n\ndef solve_case(n, L_raw, E, R, s, delta):\n    \"\"\"\n    Solves a single test case for the optimal guarantee problem.\n    \"\"\"\n    L = np.zeros((n, n))\n    for i, j, val in L_raw:\n        L[i, j] = val\n\n    # 1. Baseline simulation (no guarantee)\n    defaulted_base = simulate_contagion(n, L, E, R, s, delta)\n    \n    # Check if cascade is already halted (final defaults are none or only the shocked bank)\n    if not defaulted_base or defaulted_base == {s}:\n        return [-1, -1, 0.0]\n\n    # 2. Search for optimal guarantee\n    potential_guarantees = []\n    for i in range(n):\n        for j in range(n):\n            if L[i, j] > 0:\n                potential_guarantees.append((i, j))\n    \n    min_cost = float('inf')\n    best_guarantee_info = None\n\n    for i, j in potential_guarantees:\n        guarantee = (i, j)\n        defaulted_final = simulate_contagion(n, L, E, R, s, delta, guarantee)\n        \n        # Check if cascade is halted\n        if not defaulted_final or defaulted_final == {s}:\n            # Calculate realized cost\n            cost = 0.0\n            if i in defaulted_final:\n                cost = (1.0 - R) * L[i, j]\n            \n            # Check if this is a better solution (lower cost)\n            if cost  min_cost:\n                min_cost = cost\n                best_guarantee_info = [i, j, cost]\n\n    if best_guarantee_info is not None:\n        return best_guarantee_info\n    else:\n        # No single guarantee could halt the cascade\n        return [-2, -2, -1.0]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"n\": 4, \"R\": 0.4, \"E\": [0.3, 0.5, 0.7, 0.5],\n            \"L_raw\": [(0, 1, 1.0), (0, 2, 0.1), (1, 2, 1.2), (2, 3, 1.0)],\n            \"s\": 0, \"delta\": 0.5\n        },\n        # Case 2\n        {\n            \"n\": 3, \"R\": 0.5, \"E\": [0.2, 0.2, 0.2],\n            \"L_raw\": [(0, 1, 0.5), (0, 2, 0.5)],\n            \"s\": 0, \"delta\": 0.5\n        },\n        # Case 3\n        {\n            \"n\": 3, \"R\": 0.4, \"E\": [0.5, 0.5, 0.5],\n            \"L_raw\": [(0, 1, 0.1), (0, 2, 0.1)],\n            \"s\": 0, \"delta\": 0.4\n        },\n        # Case 4\n        {\n            \"n\": 5, \"R\": 0.2, \"E\": [0.3, 0.9, 0.6, 0.6, 1.0],\n            \"L_raw\": [(0, 1, 0.2), (0, 2, 0.8), (2, 3, 0.8), (3, 4, 0.9)],\n            \"s\": 0, \"delta\": 0.5\n        }\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"n\"], case[\"L_raw\"], case[\"E\"], case[\"R\"], case[\"s\"], case[\"delta\"])\n        results.append(str(result).replace(\" \", \"\"))\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}