{
    "hands_on_practices": [
        {
            "introduction": "理论通过实践得以升华。为了真正掌握系统性风险，我们必须亲手构建模型并观察其动态。这个练习将指导您建立一个清晰的确定性违约瀑布模型，模拟“监管套利”现象，即银行将部分资产转移到一个更脆弱的“影子银行”层。通过这个实践，您将直观地理解一个初始冲击是如何通过网络传播，并发现看似微小的结构变化（例如更高的影子银行敞口）如何显著放大风险，最终导致系统性的崩溃。这是理解系统性风险传播机制的基础。",
            "id": "2435816",
            "problem": "给定一个程式化的银行间网络，该网络具有两层债务，分别代表一个受监管层和一个影子（不受监管）层。银行可将其总银行间债务的一部分重新路由至影子层，由于违约后的回收率较低，影子层更为脆弱。该金融系统根据资产负债表恒等式和一个带有违约损失的离散时间违约级联进行确定性演化。\n\n基本基础：\n- 对于每家银行 $i$，权益由会计恒等式定义：$q_i = A_i - P_i$，其中 $A_i$ 是总资产，$P_i$ 是总负债。有限责任意味着当 $q_i < 0$ 时发生违约。\n- 银行间债务由负债矩阵 $\\mathbf{L} \\in \\mathbb{R}_+^{N \\times N}$ 表示，其中条目 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 金额为 $L_{ij}$。对于每家银行 $i$，其总银行间负债为 $\\bar{p}_i = \\sum_{j=1}^N L_{ij}$，总银行间资产为 $\\sum_{k=1}^N L_{ki}$。\n- 外部资产 $e_i \\ge 0$ 受到外生的、确定性的冲击量 $\\Delta_i \\ge 0$ 的影响，产生冲击后的外部资产 $e_i - \\Delta_i$。\n- 违约损失率（LGD）是确定性建模的：当借款人违约时，每个债权人对违约风险敞口实现固定的回收率。受监管层的回收率为 $r_R \\in [0,1]$，影子层的回收率为 $r_S \\in [0,1]$，且 $r_S < r_R$。相应的违约损失率值为 $1 - r_R$ 和 $1 - r_S$。\n\n分层构建与监管套利：\n- 对于给定的转移比例 $s \\in [0,1]$，每笔总双边债务被分解为受监管层中的 $L_{ij}^{(R)} = (1-s) L_{ij}$ 和影子层中的 $L_{ij}^{(S)} = s L_{ij}$。\n- 当银行 $j$ 违约时，任何对 $j$ 有风险敞口的债权人 $i$ 将确定性地损失\n$$\n\\text{loss}_{i \\leftarrow j}(s) = (1-r_R) L_{j i}^{(R)} + (1-r_S) L_{j i}^{(S)} = \\big( (1-s)(1-r_R) + s(1-r_S) \\big) L_{j i}.\n$$\n定义有效损失乘数\n$$\nm(s) = (1-s)(1-r_R) + s(1-r_S).\n$$\n\n传染机制（离散时间级联）：\n- 步骤 $0$：计算每家银行 $i$ 的初始冲击后权益，\n$$\nq_i^{(0)} = \\big(e_i - \\Delta_i\\big) + \\sum_{k=1}^N L_{k i} - \\sum_{j=1}^N L_{i j}.\n$$\n任何满足 $q_i^{(0)} < 0$ 的银行 $i$ 在步骤 $0$ 违约。\n- 步骤 $t \\ge 1$：对于在步骤 $t-1$ 新违约的每个借款人 $j$，将每个债权人 $i$ 的权益减少 $\\text{loss}_{i \\leftarrow j}(s) = m(s) L_{j i}$。如果此减少导致某个有偿付能力的银行 $i$ 的权益变为 $q_i^{(t)} < 0$，则银行 $i$ 成为步骤 $t$ 的新违约者。每个借款人只触发一次损失（在其首次违约时）。迭代此过程，直到没有新的违约发生。\n\n你的任务：\n- 为下面给出的固定网络和参数值实现此确定性级联算法。\n- 对于每个测试用例，输出最终违约银行的总数，结果为一个非负整数。\n\n固定网络与回收率：\n- 银行数量：$N = 3$。\n- 银行间负债矩阵 $\\mathbf{L}$，其中行代表借款人，列代表债权人：\n$$\n\\mathbf{L} =\n\\begin{bmatrix}\n0 & 70 & 0 \\\\\n0 & 0 & 80 \\\\\n30 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产向量：\n$$\n\\mathbf{e} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix}.\n$$\n- 受监管层回收率 $r_R = 0.9$ 和影子层回收率 $r_S = 0.2$。\n\n测试套件：\n每个测试用例指定了转移比例 $s$ 和外部冲击向量 $\\boldsymbol{\\Delta}$。所有的 $s$ 值是 $[0,1]$ 内的小数，$\\boldsymbol{\\Delta}$ 的所有分量都是非负实数。\n\n- 测试 1：$s = 0.0$，$$ \\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix} $$。\n- 测试 2：$s = 0.3$，$$ \\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix} $$。\n- 测试 3：$s = 0.5$，$$ \\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix} $$。\n- 测试 4：$s = 1.0$，$$ \\boldsymbol{\\Delta} = \\begin{bmatrix} 55 \\\\ 0 \\\\ 0 \\end{bmatrix} $$。\n- 测试 5：$s = 0.8$，$$ \\boldsymbol{\\Delta} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix} $$。\n\n程序要求：\n- 编写一个完整、可运行的程序，使用上述级联机制和固定数据，为每个测试用例计算最终的违约数量。不允许使用随机性。\n- 最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,\\dots,x_5]$，其中每个 $x_k$ 是按上述顺序列出的测试 $k$ 的违约整数数量。",
            "solution": "所呈现的问题是计算金融学中一个适定（well-posed）的练习，具体涉及程式化的多层银行间网络中的系统性风险传播。所有必要的参数和动态都以足够的清晰度和数学严谨性给出。因此，该问题是有效的，并且可以推导出确定性解。\n\n问题的核心在于追踪银行权益在初始冲击和随后的传染效应下的演变。该系统由一组 $N$ 家银行、它们的银行间债务以及它们持有的外部资产定义。金融结构由每家银行 $i$ 的基本资产负债表恒等式决定：\n$$\nq_i = A_i - P_i\n$$\n其中 $q_i$ 是权益，$A_i$ 是总资产，$P_i$ 是总负债。如果一家银行的权益变为负数，即 $q_i < 0$，则认为该银行违约，这与有限责任原则一致。\n\n银行 $i$ 的总资产 $A_i$ 由其外部资产 $e_i$ 和其银行间资产 $\\bar{a}_i$（即对其他银行的债权）组成。总负债 $P_i$ 是其银行间负债 $\\bar{p}_i$（即对其他银行的债务）。银行间风险敞口被编码在负债矩阵 $\\mathbf{L}$ 中，其中 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 的金额。\n因此，对于每家银行 $i$，我们可以写出：\n- 总银行间负债：$\\bar{p}_i = \\sum_{j=1}^N L_{ij}$\n- 总银行间资产：$\\bar{a}_i = \\sum_{k=1}^N L_{ki}$\n\n因此，银行 $i$ 的初始、冲击前权益为：\n$$\nq_{i, \\text{pre-shock}} = e_i + \\bar{a}_i - \\bar{p}_i\n$$\n\n对于给定的 $N=3$ 的网络：\n- 负债矩阵：$$ \\mathbf{L} = \\begin{bmatrix} 0 & 70 & 0 \\\\ 0 & 0 & 80 \\\\ 30 & 0 & 0 \\end{bmatrix} $$\n- 外部资产：$$ \\mathbf{e} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix} $$\n\n我们首先通过对 $\\mathbf{L}$ 的行求和来计算总银行间负债向量 $\\bar{\\mathbf{p}}$:\n$$\n\\bar{\\mathbf{p}} = \\begin{bmatrix} 0+70+0 \\\\ 0+0+80 \\\\ 30+0+0 \\end{bmatrix} = \\begin{bmatrix} 70 \\\\ 80 \\\\ 30 \\end{bmatrix}\n$$\n接下来，我们通过对 $\\mathbf{L}$ 的列求和来计算总银行间资产向量 $\\bar{\\mathbf{a}}$:\n$$\n\\bar{\\mathbf{a}} = \\begin{bmatrix} 0+0+30 \\\\ 70+0+0 \\\\ 0+80+0 \\end{bmatrix} = \\begin{bmatrix} 30 \\\\ 70 \\\\ 80 \\end{bmatrix}\n$$\n初始、冲击前权益向量 $\\mathbf{q}_{\\text{pre-shock}}$ 为：\n$$\n\\mathbf{q}_{\\text{pre-shock}} = \\mathbf{e} + \\bar{\\mathbf{a}} - \\bar{\\mathbf{p}} = \\begin{bmatrix} 60 \\\\ 30 \\\\ 5 \\end{bmatrix} + \\begin{bmatrix} 30 \\\\ 70 \\\\ 80 \\end{bmatrix} - \\begin{bmatrix} 70 \\\\ 80 \\\\ 30 \\end{bmatrix} = \\begin{bmatrix} 20 \\\\ 20 \\\\ 55 \\end{bmatrix}\n$$\n所有银行最初都有偿付能力。传染过程始于对外部资产的外生冲击 $\\boldsymbol{\\Delta}$。\n\n传染机制关键取决于违约损失率，该损失率由受监管层（$r_R=0.9$）和影子层（$r_S=0.2$）的回收率决定。转移到影子层的债务比例为 $s$。当一家银行违约时，其债权人会遭受损失。损失被有效损失乘数 $m(s)$ 放大：\n$$\nm(s) = (1-s)(1-r_R) + s(1-r_S) = (1-s)(1-0.9) + s(1-0.2) = 0.1(1-s) + 0.8s = 0.1 + 0.7s\n$$\n级联过程以离散时间步进行。\n\n**步骤 0：初始冲击**\n初始冲击后权益向量 $\\mathbf{q}^{(0)}$ 计算如下：\n$$\n\\mathbf{q}^{(0)} = \\mathbf{q}_{\\text{pre-shock}} - \\boldsymbol{\\Delta}\n$$\n任何满足 $q_i^{(0)} < 0$ 的银行 $i$ 被宣告违约。\n\n**步骤 $t \\ge 1$: 传染**\n如果在步骤 $t-1$ 有一组银行 $D_{t-1}$ 新发生违约，则对于每个未违约的银行 $i$，其权益会更新以反映这些新违约造成的损失：\n$$\nq_i^{(t)} = q_i^{(t-1)} - \\sum_{j \\in D_{t-1}} m(s) L_{ji}\n$$\n任何权益 $q_i^{(t)}$ 降至零以下的银行 $i$ 将在步骤 $t$ 成为新的违约者。重复该过程，直到某一步骤中没有新的违约发生。\n\n我们现在为每个测试用例求解。\n\n**测试用例 1：** $s = 0.0$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.0) = 0.1 + 0.7(0.0) = 0.1$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [20, 20, 55]^T - [55, 0, 0]^T = [-35, 20, 55]^T$。银行 1 ($q_1^{(0)} = -35 < 0$) 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 欠银行 2 金额为 $L_{12} = 70$。\n  - 银行 2 的损失：$m(0.0) \\times L_{12} = 0.1 \\times 70 = 7$。\n  - 银行 2 的权益：$q_2^{(1)} = q_2^{(0)} - 7 = 20 - 7 = 13$。银行 2 仍有偿付能力。\n- 无更多违约。级联终止。\n- 违约总数：$1$。\n\n**测试用例 2：** $s = 0.3$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.3) = 0.1 + 0.7(0.3) = 0.1 + 0.21 = 0.31$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 的违约传播。\n  - 银行 2 的损失：$m(0.3) \\times L_{12} = 0.31 \\times 70 = 21.7$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 21.7 = -1.7$。银行 2 ($q_2^{(1)} < 0$) 违约。违约集合：$\\{1, 2\\}$。\n- 步骤 2：银行 2 的违约传播。银行 2 欠银行 3 金额为 $L_{23} = 80$。\n  - 银行 3 的损失：$m(0.3) \\times L_{23} = 0.31 \\times 80 = 24.8$。\n  - 银行 3 的权益：$q_3^{(2)} = q_3^{(0)} - 24.8 = 55 - 24.8 = 30.2$。银行 3 仍有偿付能力。\n- 无更多违约。级联终止。\n- 违约总数：$2$。\n\n**测试用例 3：** $s = 0.5$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(0.5) = 0.1 + 0.7(0.5) = 0.1 + 0.35 = 0.45$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 的违约传播。\n  - 银行 2 的损失：$m(0.5) \\times L_{12} = 0.45 \\times 70 = 31.5$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 31.5 = -11.5$。银行 2 违约。违约集合：$\\{1, 2\\}$。\n- 步骤 2：银行 2 的违约传播。\n  - 银行 3 的损失：$m(0.5) \\times L_{23} = 0.45 \\times 80 = 36$。\n  - 银行 3 的权益：$q_3^{(2)} = 55 - 36 = 19$。银行 3 仍有偿付能力。\n- 无更多违约。\n- 违约总数：$2$。\n\n**测试用例 4：** $s = 1.0$，$\\boldsymbol{\\Delta} = [55, 0, 0]^T$\n- 损失乘数：$m(1.0) = 0.1 + 0.7(1.0) = 0.8$。\n- 步骤 0：$\\mathbf{q}^{(0)} = [-35, 20, 55]^T$。银行 1 违约。违约集合：$\\{1\\}$。\n- 步骤 1：银行 1 违约。\n  - 银行 2 的损失：$m(1.0) \\times L_{12} = 0.8 \\times 70 = 56$。\n  - 银行 2 的权益：$q_2^{(1)} = 20 - 56 = -36$。银行 2 违约。违约集合：$\\{1, 2\\}$。\n- 步骤 2：银行 2 违约。\n  - 银行 3 的损失：$m(1.0) \\times L_{23} = 0.8 \\times 80 = 64$。\n  - 银行 3 的权益：$q_3^{(2)} = 55 - 64 = -9$。银行 3 违约。违约集合：$\\{1, 2, 3\\}$。\n- 步骤 3：银行 3 的违约传播。银行 3 欠银行 1 金额为 $L_{31}=30$。由于银行 1 已经违约，这对违约者集合没有影响。\n- 整个系统已经崩溃。\n- 违约总数：$3$。\n\n**测试用例 5：** $s = 0.8$，$\\boldsymbol{\\Delta} = [0, 0, 0]^T$\n- 损失乘数：$m(0.8) = 0.1 + 0.7(0.8) = 0.66$。\n- 步骤 0：$\\mathbf{q}^{(0)} = \\mathbf{q}_{\\text{pre-shock}} - [0, 0, 0]^T = [20, 20, 55]^T$。\n- 所有初始权益均为正。没有初始违约。\n- 级联未被启动。\n- 违约总数：$0$。\n\n该分析展示了一个关键现象：随着金融系统将债务转移到一个监管较少、更脆弱的“影子”层（即增加 $s$），其对初始冲击的韧性会恶化。在 $s=0.0$ 时被遏制的冲击，在中间 $s$ 值时会导致部分级联，而在 $s=1.0$ 时则导致全面的系统性崩溃。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the number of defaulted banks in a stylized interbank network\n    for a given set of test cases.\n    \"\"\"\n\n    # Fixed network parameters\n    # L_ij means bank i (row) owes bank j (column)\n    L = np.array([\n        [0.0, 70.0, 0.0],\n        [0.0, 0.0, 80.0],\n        [30.0, 0.0, 0.0]\n    ])\n    e = np.array([60.0, 30.0, 5.0])\n    r_R = 0.9\n    r_S = 0.2\n    N = 3\n\n    # Test cases: (shift fraction s, shock vector Delta)\n    test_cases = [\n        (0.0, np.array([55.0, 0.0, 0.0])),\n        (0.3, np.array([55.0, 0.0, 0.0])),\n        (0.5, np.array([55.0, 0.0, 0.0])),\n        (1.0, np.array([55.0, 0.0, 0.0])),\n        (0.8, np.array([0.0, 0.0, 0.0]))\n    ]\n\n    results = []\n\n    # Calculate fixed network properties once\n    p_bar = np.sum(L, axis=1)  # Total interbank liabilities (row sums)\n    a_bar = np.sum(L, axis=0)  # Total interbank assets (column sums)\n    q_pre_shock = e + a_bar - p_bar\n\n    for s, Delta in test_cases:\n        # Effective loss multiplier for the current s\n        m_s = (1 - s) * (1 - r_R) + s * (1 - r_S)\n\n        # Step 0: Initial shock and defaults\n        q = q_pre_shock - Delta\n        \n        # Sets to track defaulted banks\n        # Bank indices are 1-based, numpy arrays are 0-based\n        defaulted_banks = set(np.where(q < 0)[0] + 1)\n        newly_defaulted = defaulted_banks.copy()\n        \n        # Iterative contagion process\n        while newly_defaulted:\n            # Banks that defaulted in the previous wave trigger new losses\n            current_wave_defaulters = newly_defaulted.copy()\n            newly_defaulted.clear()\n            \n            for j_defaulter in current_wave_defaulters:\n                # Propagate losses to creditors of the defaulted bank j_defaulter\n                # A bank i is a creditor if L[j-1, i-1] > 0\n                for i_creditor in range(1, N + 1):\n                    # Continue if creditor is already defaulted\n                    if i_creditor in defaulted_banks:\n                        continue\n                    \n                    # Calculate loss for creditor i from defaulter j\n                    # L is indexed by (borrower, creditor)\n                    loss = m_s * L[j_defaulter - 1, i_creditor - 1]\n                    \n                    if loss > 0:\n                        # Update equity of the creditor\n                        q[i_creditor - 1] -= loss\n                        \n                        # Check if the creditor defaults\n                        if q[i_creditor - 1] < 0:\n                            defaulted_banks.add(i_creditor)\n                            newly_defaulted.add(i_creditor)\n        \n        # The result for this case is the total number of defaulted banks\n        results.append(len(defaulted_banks))\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了风险如何传播之后，我们需要工具来量化一个系统在危机发生前的脆弱性。本练习旨在构建一个综合性的“金融脆弱性指数”。您将学习如何融合两种不同维度的风险来源：一是网络拓扑结构，它通过“聚类系数”$C$来衡量银行间的紧密程度；二是金融脆弱性，它通过系统的总“杠杆率”$\\bar{L}$来衡量。这项实践的核心价值在于，它教会您如何将复杂的多维信息整合成一个单一、可解释的风险评分，这是风险管理和政策分析中一项至关重要的技能。",
            "id": "2435773",
            "problem": "一个金融系统由一个包含$5$家银行（标记为$A,B,C,D,E$）的无向网络表示，其中两家银行之间的无向边表示双边风险敞口关系。边集为 $\\{AB,AC,BC,BD,CD,DE\\}$。每家银行 $i$ 的总资产 $A_i$ 和权益 $E_i$ 如下：\n- 银行 $A$：$A_A=100$， $E_A=10$。\n- 银行 $B$：$A_B=150$， $E_B=12.5$。\n- 银行 $C$：$A_C=120$， $E_C=15$。\n- 银行 $D$：$A_D=80$， $E_D=8$。\n- 银行 $E$：$A_E=50$， $E_E=10$。\n\n定义以下基本要素：\n1. 无向简单图的全局聚类系数 $C$（传递性）定义为 $C = \\dfrac{3 T}{W}$，其中 $T$ 是图中三角形的数量，$W$ 是连通三元组顶点的数量。一个连通三元组是一个无序的、由三个不同顶点构成的组合，其中至少存在两条共享一个公共顶点的边。\n2. 银行 $i$ 的节点杠杆率是 $L_i = \\dfrac{A_i}{E_i}$。总体杠杆率是资产加权平均杠杆率\n$$\n\\bar{L} = \\sum_{i \\in \\{A,B,C,D,E\\}} \\omega_i L_i, \\quad \\text{其中 } \\omega_i = \\dfrac{A_i}{\\sum_{j \\in \\{A,B,C,D,E\\}} A_j}。\n$$\n\n一个“金融脆弱性”指数 $B$ 将通过以下校准协议结合拓扑结构和杠杆率来构建。首先，定义线性归一化度量\n$$\nx_C = \\dfrac{C - C_{\\mathrm{S}}}{C_{\\mathrm{R}} - C_{\\mathrm{S}}}, \\qquad x_L = \\dfrac{\\bar{L} - \\bar{L}_{\\mathrm{S}}}{\\bar{L}_{\\mathrm{R}} - \\bar{L}_{\\mathrm{S}}},\n$$\n相对于两个锚定状态：一个“安全”锚点 $(C_{\\mathrm{S}}, \\bar{L}_{\\mathrm{S}}) = (0, 5)$ 和一个“风险”锚点 $(C_{\\mathrm{R}}, \\bar{L}_{\\mathrm{R}}) = (0.6, 15)$。\n\n设\n$$\nB = \\gamma + \\lambda \\big( w x_L + (1-w) x_C \\big),\n$$\n其中杠杆率的权重是聚类系数的两倍，因此 $w = \\dfrac{2}{3}$。常数 $\\gamma$ 和 $\\lambda$ 由校准条件决定：在安全锚点处 $B=0.2$，在风险锚点处 $B=0.8$。\n\n使用这些定义和校准，计算给定网络的脆弱性指数 $B$。将最终结果四舍五入到四位有效数字。答案以纯数字形式表示，不带单位。",
            "solution": "该问题定义明确、自成体系，并符合网络科学和金融建模的原则。所有必需的数据和定义均已提供，可以得出唯一解。因此，我将系统地计算金融脆弱性指数 $B$。\n\n计算过程分为五个连续步骤：（1）计算网络的全局聚类系数 $C$；（2）计算系统的总体杠杆率 $\\bar{L}$；（3）对这两个度量进行归一化处理；（4）校准脆弱性指数公式；（5）计算 $B$ 的最终值。\n\n首先，我们分析网络拓扑以求得全局聚类系数 $C = \\frac{3T}{W}$。该网络由 $N=5$ 个顶点（银行）$\\{A, B, C, D, E\\}$ 和边集 $\\{AB, AC, BC, BD, CD, DE\\}$ 组成。\n$T$ 是三角形（$3$个顶点的完全子图）的数量。通过检查边集：\n-   顶点集 $\\{A, B, C\\}$ 构成一个三角形，因为边 $AB$、$AC$ 和 $BC$ 都存在。\n-   顶点集 $\\{B, C, D\\}$ 构成一个三角形，因为边 $BC$、$BD$ 和 $CD$ 都存在。\n没有其他三个顶点的组合能构成三角形。因此，三角形的数量为 $T=2$。\n\n$W$ 是连通三元组的数量，即长度为 $2$ 的路径数量。以顶点 $v$ 为中心的此类路径数量由 $\\binom{d(v)}{2}$ 给出，其中 $d(v)$ 是顶点 $v$ 的度。我们首先计算所有顶点的度：\n-   $d(A) = 2$ (连接到 $B, C$)\n-   $d(B) = 3$ (连接到 $A, C, D$)\n-   $d(C) = 3$ (连接到 $A, B, D$)\n-   $d(D) = 3$ (连接到 $B, C, E$)\n-   $d(E) = 1$ (连接到 $D$)\n连通三元组的总数是所有顶点上该值的总和：\n$$W = \\sum_{i \\in \\{A,B,C,D,E\\}} \\binom{d(i)}{2} = \\binom{2}{2} + \\binom{3}{2} + \\binom{3}{2} + \\binom{3}{2} + \\binom{1}{2}$$\n$$W = 1 + 3 + 3 + 3 + 0 = 10$$\n现在，我们可以计算全局聚类系数：\n$$C = \\frac{3T}{W} = \\frac{3 \\times 2}{10} = \\frac{6}{10} = 0.6$$\n\n第二，我们计算总体杠杆率 $\\bar{L}$。首先，我们求出每家银行的杠杆率 $L_i = \\frac{A_i}{E_i}$：\n-   $L_A = \\frac{A_A}{E_A} = \\frac{100}{10} = 10$\n-   $L_B = \\frac{A_B}{E_B} = \\frac{150}{12.5} = 12$\n-   $L_C = \\frac{A_C}{E_C} = \\frac{120}{15} = 8$\n-   $L_D = \\frac{A_D}{E_D} = \\frac{80}{8} = 10$\n-   $L_E = \\frac{A_E}{E_E} = \\frac{50}{10} = 5$\n接下来，我们确定资产加权平均值。系统中的总资产为：\n$$\\sum_{j} A_j = A_A + A_B + A_C + A_D + A_E = 100 + 150 + 120 + 80 + 50 = 500$$\n权重 $\\omega_i = \\frac{A_i}{\\sum_j A_j}$ 为：\n-   $\\omega_A = \\frac{100}{500} = 0.2$\n-   $\\omega_B = \\frac{150}{500} = 0.3$\n-   $\\omega_C = \\frac{120}{500} = 0.24$\n-   $\\omega_D = \\frac{80}{500} = 0.16$\n-   $\\omega_E = \\frac{50}{500} = 0.1$\n总体杠杆率 $\\bar{L}$ 是加权和：\n$$\\bar{L} = \\sum_{i} \\omega_i L_i = (0.2)(10) + (0.3)(12) + (0.24)(8) + (0.16)(10) + (0.1)(5)$$\n$$\\bar{L} = 2.0 + 3.6 + 1.92 + 1.6 + 0.5 = 9.62$$\n\n第三，我们使用给定的锚定状态对计算出的 $C$ 和 $\\bar{L}$ 值进行归一化： “安全”锚点 $(C_{\\mathrm{S}}, \\bar{L}_{\\mathrm{S}}) = (0, 5)$ 和“风险”锚点 $(C_{\\mathrm{R}}, \\bar{L}_{\\mathrm{R}}) = (0.6, 15)$。\n归一化的聚类度量是：\n$$x_C = \\frac{C - C_{\\mathrm{S}}}{C_{\\mathrm{R}} - C_{\\mathrm{S}}} = \\frac{0.6 - 0}{0.6 - 0} = 1$$\n归一化的杠杆率度量是：\n$$x_L = \\frac{\\bar{L} - \\bar{L}_{\\mathrm{S}}}{\\bar{L}_{\\mathrm{R}} - \\bar{L}_{\\mathrm{S}}} = \\frac{9.62 - 5}{15 - 5} = \\frac{4.62}{10} = 0.462$$\n\n第四，我们使用边界条件校准脆弱性指数 $B = \\gamma + \\lambda(w x_L + (1-w) x_C)$。\n在安全锚点处，$(x_C, x_L)=(0,0)$ 且 $B=0.2$。代入这些值可得：\n$$0.2 = \\gamma + \\lambda(w \\cdot 0 + (1-w) \\cdot 0) \\implies \\gamma = 0.2$$\n在风险锚点处，$(x_C, x_L)=(1,1)$ 且 $B=0.8$。代入这些值可得：\n$$0.8 = \\gamma + \\lambda(w \\cdot 1 + (1-w) \\cdot 1) = \\gamma + \\lambda$$\n使用 $\\gamma = 0.2$，我们求解 $\\lambda$：\n$$0.8 = 0.2 + \\lambda \\implies \\lambda = 0.6$$\n校准后的脆弱性指数公式为 $B = 0.2 + 0.6(w x_L + (1-w) x_C)$。\n\n第五，我们计算给定网络的 $B$ 的最终值。我们使用计算出的归一化值 $x_C=1$ 和 $x_L=0.462$，以及指定的权重 $w = \\frac{2}{3}$。\n$$B = 0.2 + 0.6 \\left( \\left(\\frac{2}{3}\\right) x_L + \\left(1-\\frac{2}{3}\\right) x_C \\right)$$\n$$B = 0.2 + 0.6 \\left( \\left(\\frac{2}{3}\\right)(0.462) + \\left(\\frac{1}{3}\\right)(1) \\right)$$\n$$B = 0.2 + 0.6 \\left( \\frac{2 \\times 0.462 + 1}{3} \\right)$$\n$$B = 0.2 + 0.2 (0.924 + 1)$$\n$$B = 0.2 + 0.2 (1.924)$$\n$$B = 0.2 + 0.3848 = 0.5848$$\n题目要求将结果四舍五入到四位有效数字。计算出的值 $0.5848$ 已经有四位有效数字。",
            "answer": "$$\n\\boxed{0.5848}\n$$"
        },
        {
            "introduction": "当我们能够识别并衡量风险后，下一步便是设计有效的干预措施。本练习将向您介绍经典的 Eisenberg-Noe 清算模型，这是一个用于判断金融系统能否完全清偿其债务的强大框架。您的任务是精确计算，在系统遭受初始冲击后，监管机构需要向受冲击的节点注入的“最小资本”是多少才能稳定整个网络。这项实践将您的技能从动态模拟提升到分析求解的层面，为您提供一个用于危机管理的精确工具，并揭示了现实世界中监管者所面临的权衡。",
            "id": "2435808",
            "problem": "考虑一个包含 $n$ 个机构的金融系统，该系统由一个有向加权负债网络表示。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为名义负债矩阵，其中 $L_{ij}$ 是机构 $i$ 对机构 $j$ 的债务。定义总名义负债向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ 如下：\n$$\n\\bar{p}_i \\equiv \\sum_{j=1}^{n} L_{ij}.\n$$\n定义相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 如下：\n$$\n\\Pi_{ij} \\equiv \n\\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i}, & \\text{若 } \\bar{p}_i > 0, \\\\\n0, & \\text{若 } \\bar{p}_i = 0,\n\\end{cases}\n$$\n因此 $\\Pi$ 的每行之和最多为 $1$。设 $x \\in \\mathbb{R}_{\\ge 0}^{n}$ 为遭受任何冲击之前的外部资产向量。\n\n对指定节点 $i \\in \\{1,\\dots,n\\}$ 施加一次大小为 $S_0 \\ge 0$ 的初始冲击，会将其外部资产减少至 $x_i' = \\max\\{x_i - S_0, 0\\}$，而对于所有 $k \\ne i$，$x_k' = x_k$。接着，可以向受冲击节点 $i$ 单独分配一笔非负资本注入 $\\Delta C \\ge 0$，得到注入后的外部资产 $x_i'' = x_i' + \\Delta C$，而对于所有 $k \\ne i$，$x_k'' = x_k'$。\n\n支付根据 Eisenberg–Noe 不动点模型进行清算：一个清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 必须满足\n$$\np = \\min\\left\\{\\bar{p},\\, \\Pi^\\top p + x''\\right\\},\n$$\n其中最小值为按分量取值，$x''$ 是注入后的外部资产向量。\n\n定义“稳定网络”为所有机构都全额偿付，即清算支付等于总名义负债：$p = \\bar{p}$。换言之，稳定要求在给定冲击和仅对节点 $i$ 应用资本注入的情况下，所有机构根据 Eisenberg–Noe 模型实现全额偿还是可行的。\n\n任务。对于下方的每个测试用例，计算在指定节点 $i$ 遭受大小为 $S_0$ 的初始冲击后，稳定网络所需的最小资本注入 $\\Delta C_{\\min}$（资本单位与 $x$ 和 $L$ 相同）。如果仅向节点 $i$ 分配任何有限非负的 $\\Delta C$ 都无法使所有机构实现全额偿付，则该测试用例返回数值 $-1.0$。\n\n您的程序必须生成单行输出，其中包含所有结果，形式为方括号内的逗号分隔列表，每个数字都四舍五入到恰好 $6$ 位小数。例如，四个结果的有效输出形式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 显示为 $6$ 位小数。\n\n请使用以下测试套件。在每个案例中，网络大小为 $n = 3$。\n\n测试用例 $1$（一般情况）：\n- 受冲击的节点索引：$i = 1$（使用基于1的索引；您的程序内部可以使用基于0的索引，但必须遵守此处给出的数据）。\n- 初始冲击：$S_0 = 1.5$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 2 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n0.5\n\\end{bmatrix}.\n$$\n\n测试用例 $2$（冲击后已稳定，需要零注入）：\n- 受冲击的节点索引：$i = 1$。\n- 初始冲击：$S_0 = 0.2$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 2 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n0.5\n\\end{bmatrix}.\n$$\n\n测试用例 $3$（仅通过在受冲击节点注入无法稳定）：\n- 受冲击的节点索引：$i = 3$。\n- 初始冲击：$S_0 = 0$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n0 & 0 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n0.1 \\\\\n0.1 \\\\\n0.1\n\\end{bmatrix}.\n$$\n\n测试用例 $4$（边界情况，零负债节点受到冲击）：\n- 受冲击的节点索引：$i = 1$。\n- 初始冲击：$S_0 = 10.0$。\n- 负债矩阵：\n$$\nL = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n1 & 0 & 0 \\\\\n0 & 1 & 0\n\\end{bmatrix}.\n$$\n- 外部资产：\n$$\nx = \\begin{bmatrix}\n0.5 \\\\\n0.5 \\\\\n1.0\n\\end{bmatrix}.\n$$\n\n最终输出格式要求。您的程序应生成单行输出，其中按顺序包含测试用例$1$至$4$的结果，形式为方括号内的逗号分隔列表，每个值四舍五入到恰好$6$位小数，例如\n$$\n[\\Delta C_{\\min}^{(1)},\\Delta C_{\\min}^{(2)},\\Delta C_{\\min}^{(3)},\\Delta C_{\\min}^{(4)}].\n$$\n如果仅通过在受冲击节点注入无法实现稳定，则为该情况打印 $-1.000000$。",
            "solution": "问题陈述经验证。\n\n步骤 1：提取已知条件\n- 机构数量为 $n$。\n- 名义负债矩阵为 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是机构 $i$ 对 $j$ 的债务。\n- 总名义负债向量为 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$，定义为 $\\bar{p}_i \\equiv \\sum_{j=1}^{n} L_{ij}$。\n- 相对负债矩阵为 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，定义为若 $\\bar{p}_i > 0$，则 $\\Pi_{ij} \\equiv L_{ij}/\\bar{p}_i$；若 $\\bar{p}_i = 0$，则 $\\Pi_{ij} = 0$。\n- 外部资产向量为 $x \\in \\mathbb{R}_{\\ge 0}^{n}$。\n- 对指定节点 $i$ 施加大小为 $S_0 \\ge 0$ 的初始冲击。\n- 冲击后外部资产向量 $x'$ 定义为 $x_i' = \\max\\{x_i - S_0, 0\\}$ 且对于 $k \\ne i$ 有 $x_k' = x_k$。\n- 向受冲击节点 $i$ 分配一笔资本注入 $\\Delta C \\ge 0$。\n- 注入后外部资产向量 $x''$ 定义为 $x_i'' = x_i' + \\Delta C$ 且对于 $k \\ne i$ 有 $x_k'' = x_k'$。\n- 清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 满足不动点方程 $p = \\min\\left\\{\\bar{p},\\, \\Pi^\\top p + x''\\right\\}$。\n- 网络稳定定义为所有机构全额偿付的条件，即 $p = \\bar{p}$。\n- 任务是找到稳定网络所需的最小资本注入 $\\Delta C_{\\min}$。如果仅通过在节点 $i$ 注入无法实现稳定，则值为 $-1.0$。\n- 提供了四个测试用例，包含 $n$、$L$、$x$、$i$ 和 $S_0$ 的具体值。\n\n步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于 Eisenberg–Noe 金融清算模型，这是计算经济学中系统性风险分析的基石。该模型在数学上是严谨的，并被广泛接受。在此框架内，各项前提在事实上是合理的。\n- **适定性**：该问题要求在一组线性不等式的约束下求一个非负量 $\\Delta C$ 的最小值。这种结构是适定的。解的存在性和唯一性条件由问题的约束明确定义。\n- **客观性**：所有术语都经过数学上的精确定义。指令清晰明确，没有主观性语言。\n- **完整性与一致性**：该问题提供了构建解决方案所需的所有必要数据（$L, x, i, S_0$）和定义。内部没有矛盾。\n\n步骤 3：结论与行动\n问题有效。它是在一个公认的经济模型背景下的一个定义明确的数学练习。现在将构建一个解决方案。\n\n问题的核心是确定实现网络稳定所需的最小非负资本注入 $\\Delta C_{\\min}$。稳定被定义为清算支付向量 $p$ 等于总名义负债向量 $\\bar{p}$，即 $p = \\bar{p}$。\n\n清算过程由以下不动点方程控制：\n$$\np = \\min\\left\\{\\bar{p}, \\Pi^\\top p + x''\\right\\}\n$$\n其中最小值为按分量取值。为实现稳定，必须有 $p = \\bar{p}$。将此条件代入方程可得：\n$$\n\\bar{p} = \\min\\left\\{\\bar{p}, \\Pi^\\top \\bar{p} + x''\\right\\}\n$$\n此等式成立，当且仅当对于每个机构 $k \\in \\{1, \\dots, n\\}$，以下不等式都得到满足：\n$$\n\\bar{p}_k \\le (\\Pi^\\top \\bar{p})_k + x''_k\n$$\n这个由 $n$ 个线性不等式组成的系统代表了每个机构的总可用资金（来自其他机构的流入支付 $\\Pi^\\top \\bar{p}$，加上其自身的注入后外部资产 $x''$）足以覆盖其总名义负债 $\\bar{p}$ 的条件。我们展开矩阵-向量乘积项：\n$$\n(\\Pi^\\top \\bar{p})_k = \\sum_{j=1}^{n} (\\Pi^\\top)_{kj} \\bar{p}_j = \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j\n$$\n注入后外部资产向量 $x''$ 取决于初始冲击 $S_0$ 和资本注入 $\\Delta C$，两者都作用于单个节点 $i$。$x''$ 的分量为：\n$$\nx''_k = \\begin{cases}\n\\max\\{x_i - S_0, 0\\} + \\Delta C, & \\text{若 } k=i \\\\\nx_k, & \\text{若 } k \\ne i \\text{ 且 } k \\text{ 不是受冲击的节点}\n\\end{cases}\n$$\n更准确地说，冲击作用于节点 $i$，之后向同一节点 $i$ 进行注入。设受冲击节点的索引为 $i_{shock}$。\n那么对于任何节点 $k$：\n$$\nx'_k = \\begin{cases}\n\\max\\{x_{i_{shock}} - S_0, 0\\}, & \\text{若 } k=i_{shock} \\\\\nx_k, & \\text{若 } k \\ne i_{shock}\n\\end{cases}\n$$\n注入后的资产为：\n$$\nx''_k = \\begin{cases}\nx'_{i_{shock}} + \\Delta C, & \\text{若 } k=i_{shock} \\\\\nx'_k, & \\text{若 } k \\ne i_{shock}\n\\end{cases}\n$$\n我们将此代入我们的不等式系统。\n\n对于任何机构 $k \\ne i_{shock}$，稳定条件为：\n$$\n\\bar{p}_k \\le \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x_k\n$$\n此条件独立于冲击 $S_0$ 和注入 $\\Delta C$。让我们将每个节点 $k$ 在注入前的“偿付能力缺口”定义为：\n$$\nG_k = \\bar{p}_k - \\left( \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x'_k \\right)\n$$\n为使仅向节点 $i_{shock}$ 注入资本就能实现稳定成为可能，所有其他节点 $k \\ne i_{shock}$ 必须自身具有偿付能力。也就是说，对于所有 $k \\ne i_{shock}$，必须有 $G_k \\le 0$。如果存在任何 $k \\ne i_{shock}$ 使得 $G_k > 0$，那么向节点 $i_{shock}$ 注入任何数量的资本都无法弥补节点 $k$ 的短缺。在这种情况下，稳定是不可能的，结果为 $-1.0$。\n\n对于受冲击的节点 $k = i_{shock}$，稳定条件为：\n$$\n\\bar{p}_{i_{shock}} \\le \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x''_{i_{shock}}\n$$\n代入 $x''_{i_{shock}} = x'_{i_{shock}} + \\Delta C$：\n$$\n\\bar{p}_{i_{shock}} \\le \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x'_{i_{shock}} + \\Delta C\n$$\n我们可以重新排列这个不等式来求解所需的注入 $\\Delta C$：\n$$\n\\Delta C \\ge \\bar{p}_{i_{shock}} - \\left( \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x'_{i_{shock}} \\right) = G_{i_{shock}}\n$$\n由于资本注入必须是非负的（$\\Delta C \\ge 0$），所需的最小资本注入为 $\\Delta C_{\\min} = \\max\\{0, G_{i_{shock}}\\}$。\n\n完整的算法如下：\n1. 给定 $L$、$x$、$i_{shock}$（基于1）和 $S_0$。将 $i_{shock}$ 转换为基于0的索引。\n2. 根据 $L$ 计算总名义负债向量 $\\bar{p}$：$\\bar{p}_i = \\sum_j L_{ij}$。\n3. 计算相对负债矩阵 $\\Pi$。对于每一行 $i$：如果 $\\bar{p}_i > 0$，则 $\\Pi_{ij} = L_{ij} / \\bar{p}_i$；否则 $\\Pi_{ij} = 0$。\n4. 计算冲击后的外部资产向量 $x'$。令 $i_{idx} = i_{shock} - 1$。- $x'_{i_{idx}} = \\max\\{x_{i_{idx}} - S_0, 0\\}$。- 对于所有 $k \\ne i_{idx}$，$x'_k = x_k$。\n5. 假设全额偿付，计算来自其他机构的总预期流入支付向量：$v = \\Pi^\\top \\bar{p}$。\n6. 对于每个机构 $k=0, \\dots, n-1$，计算偿付能力缺口 $G_k = \\bar{p}_k - (v_k + x'_k)$。\n7. 检查不可能性。对于每个 $k \\ne i_{idx}$，如果 $G_k > 0$，则无法实现稳定。返回 $-1.0$。\n8. 如果第7步的检查通过，则计算所需的最小注入：$\\Delta C_{\\min} = \\max\\{0, G_{i_{idx}}\\}$。返回这个值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum capital injection to stabilize a financial network\n    for a series of test cases.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 1.5,\n            \"L\": np.array([\n                [0, 2, 0],\n                [0, 0, 1],\n                [1, 0, 0]\n            ]),\n            \"x\": np.array([2, 1, 0.5])\n        },\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 0.2,\n            \"L\": np.array([\n                [0, 2, 0],\n                [0, 0, 1],\n                [1, 0, 0]\n            ]),\n            \"x\": np.array([2, 1, 0.5])\n        },\n        {\n            \"shocked_node_idx\": 3,\n            \"S0\": 0.0,\n            \"L\": np.array([\n                [0, 1, 0],\n                [0, 0, 1],\n                [0, 0, 0]\n            ]),\n            \"x\": np.array([0.1, 0.1, 0.1])\n        },\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 10.0,\n            \"L\": np.array([\n                [0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]\n            ]),\n            \"x\": np.array([0.5, 0.5, 1.0])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        x = case[\"x\"]\n        # Convert 1-based shocked_node_idx to 0-based index\n        shocked_node_idx_0based = case[\"shocked_node_idx\"] - 1\n        S0 = case[\"S0\"]\n        n = L.shape[0]\n\n        # Step 2: Compute total nominal liabilities p_bar\n        p_bar = np.sum(L, axis=1)\n\n        # Step 3: Compute relative liability matrix Pi\n        Pi = np.zeros_like(L, dtype=float)\n        # Use np.divide to handle division by zero where p_bar_i is 0\n        non_zero_liabilities = p_bar > 1e-12 # Use tolerance for float comparison\n        Pi[non_zero_liabilities] = np.divide(\n            L[non_zero_liabilities], \n            p_bar[non_zero_liabilities, np.newaxis]\n        )\n\n        # Step 4: Compute post-shock external asset vector x_prime\n        x_prime = x.copy().astype(float)\n        x_prime[shocked_node_idx_0based] = np.maximum(\n            x[shocked_node_idx_0based] - S0, 0\n        )\n\n        # Step 5: Compute expected incoming payments v = Pi^T * p_bar\n        v = Pi.T @ p_bar\n\n        # Step 6: Compute solvency gaps G_k\n        # G_k = p_bar_k - (v_k + x_prime_k)\n        gaps = p_bar - (v + x_prime)\n\n        # Step 7: Check for impossibility\n        is_impossible = False\n        for k in range(n):\n            if k != shocked_node_idx_0based:\n                # If any non-shocked node has a positive gap, stabilization is impossible.\n                # A small tolerance is used for floating point comparisons.\n                if gaps[k] > 1e-9:\n                    is_impossible = True\n                    break\n        \n        if is_impossible:\n            results.append(-1.0)\n            continue\n\n        # Step 8: Calculate minimum injection for the shocked node\n        # delta_C_min = max(0, G_{i_shock})\n        delta_C_min = np.maximum(0.0, gaps[shocked_node_idx_0based])\n        results.append(delta_C_min)\n\n    # Format the final output according to problem specification\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}