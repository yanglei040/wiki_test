{
    "hands_on_practices": [
        {
            "introduction": "这个实践练习将引导你应用打靶法解决一个经典的离散时间动态优化问题：水库的最优管理。这是一个线性二次（LQ）问题，其结构清晰，能让你专注于打靶法的核心机制。你将通过猜测一个初始的“共态”变量，并使用求根算法来调整这个猜测，直到水库在期末达到预设的目标水位，从而掌握将两点边值问题转化为初值问题求解的基本技巧。",
            "id": "2429166",
            "problem": "考虑在 $T$ 个月的规划期内对单个水库进行离散时间最优管理，其中 $T = 12$。在月份 $t$ 开始时，水库的蓄水量用 $s_t$ 表示；在月份 $t$ 期间，受控释放量为 $r_t$，其中 $t \\in \\{0,1,\\ldots,T-1\\}$。每月入流量 $I_t$ 和目标需水量 $D_t$ 是外生且已知的。一个恒定的月度蒸发损失系数 $e \\in [0,1)$ 应用于存量。蓄水量的动态由以下线性运动定律定义\n$$\ns_{t+1} = (1 - e) s_t + I_t - r_t,\n$$\n初始蓄水量 $s_0$ 为给定值。为防洪起见，期末蓄水量必须满足一个硬边界条件，\n$$\ns_T = S^\\star.\n$$\n规划者旨在最小化以下跨期二次损失\n$$\n\\sum_{t=0}^{T-1} \\left( \\tfrac{1}{2}\\alpha \\, (r_t - D_t)^2 + \\tfrac{1}{2}\\beta \\, s_t^2 \\right),\n$$\n其中 $\\alpha  0$ 和 $\\beta \\ge 0$ 是给定的权重。释放量 $r_t$ 是无约束的实数，代表净受控流出量（正值）或净抽入量（负值），这使得问题保持为线性二次型，并确保对于给定的损失和动态方程存在唯一的内部最优点。\n\n你的任务是为此有限期、离散时间动态优化问题实现一个单次打靶法。使用动态优化的基本原理来构建一阶必要条件，并确定一个合适的未知边界值进行打靶。然后，设计一个鲁棒的区间求根程序来调整该未知数，以高数值精度满足期末蓄水量约束 $s_T = S^\\star$。满足边界条件后，为给定的参数评估最小化的目标函数值。\n\n数值实现要求：\n- 采用单次打靶法，选择一个未知的标量边界值，从而可以正向模拟状态和控制。使用区间求根法调整此未知数，直到期末约束 $s_T = S^\\star$ 在严格的容差范围内得到满足。\n- 正向模拟必须是稳定的，并且应能处理任何 $e \\in [0,1)$ 的情况。\n- 每个测试用例的最终答案必须是最小化的目标函数值，以实数形式表示。\n\n测试套件：\n- 情况A（一般情况）：$T = 12$, $\\alpha = 2.0$, $\\beta = 0.1$, $e = 0.02$, $s_0 = 30.0$, $S^\\star = 40.0$, $I = [22.0, 18.0, 15.0, 12.0, 10.0, 8.0, 7.0, 8.0, 10.0, 12.0, 16.0, 24.0]$, $D = [16.0, 16.5, 17.0, 17.5, 18.0, 19.0, 20.0, 19.5, 18.5, 17.5, 17.0, 16.5]$。\n- 情况B（无蒸发且精确平衡的边界情况）：$T = 12$, $\\alpha = 10.0$, $\\beta = 0.0$, $e = 0.0$, $s_0 = 50.0$, $S^\\star = 50.0$, $I = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]$, $D = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]$。\n- 情况C（高蒸发、强存量惩罚和低初始存量的边缘权衡情况）：$T = 12$, $\\alpha = 0.5$, $\\beta = 0.2$, $e = 0.05$, $s_0 = 5.0$, $S^\\star = 8.0$, $I = [5.0, 4.0, 3.5, 3.0, 2.5, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0]$, $D = [3.0, 3.2, 3.5, 3.8, 4.0, 4.2, 4.5, 4.2, 4.0, 3.8, 3.5, 3.2]$。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含情况A、B和C的最小化目标函数值，按此顺序排列，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[x_A,x_B,x_C]$）。",
            "solution": "用户提供的问题是一个适定的、离散时间、有限期的线性二次动态优化问题。它要求实现一种单次打靶法，以找到管理水库的最优控制策略，并计算相应的最小化目标函数值。\n\n该问题是有效的，因为它在科学上基于最优控制理论，在数学上是一致的、完整的和客观的。因此，我们可以着手解决。\n\n### 步骤1：理论构建\n\n问题是在控制序列 $\\{r_t\\}_{t=0}^{T-1}$ 上最小化目标函数 $J$：\n$$\nJ = \\sum_{t=0}^{T-1} \\left( \\frac{1}{2}\\alpha (r_t - D_t)^2 + \\frac{1}{2}\\beta s_t^2 \\right)\n$$\n受状态动态约束：\n$$\ns_{t+1} = (1 - e) s_t + I_t - r_t, \\quad \\text{for } t=0, \\ldots, T-1\n$$\n以及边界条件：\n$$\ns_0 = \\text{given}, \\quad s_T = S^\\star\n$$\n\n为推导最优性必要条件，我们使用离散时间哈密顿方法。在时间 $t$ 的哈密顿量定义为：\n$$\nH_t = \\frac{1}{2}\\alpha (r_t - D_t)^2 + \\frac{1}{2}\\beta s_t^2 + \\lambda_{t+1} \\left( (1 - e)s_t + I_t - r_t \\right)\n$$\n其中 $\\lambda_{t+1}$ 是与状态 $s_{t+1}$ 相关联的协态变量（影子价格）。\n\n一阶必要条件源于离散系统的 Pontryagin 最小值原理：\n1.  **控制最优性条件**：控制量 $r_t$ 必须在每个时间点 $t$ 最小化哈密顿量。\n    $$\n    \\frac{\\partial H_t}{\\partial r_t} = \\alpha (r_t - D_t) - \\lambda_{t+1} = 0 \\implies r_t = D_t + \\frac{1}{\\alpha}\\lambda_{t+1}\n    $$\n2.  **协态动态方程**：协态的演化由下式给出：\n    $$\n    \\lambda_t = \\frac{\\partial H_t}{\\partial s_t} = \\beta s_t + (1 - e)\\lambda_{t+1}\n    $$\n3.  **状态动态方程**（如给定）：\n    $$\n    s_{t+1} = (1 - e)s_t + I_t - r_t\n    $$\n4.  **横截性条件**：由于初始状态 $s_0$ 是固定的，期末状态 $s_T$ 也是固定的，因此相应的协态值 $\\lambda_0$ 和 $\\lambda_T$ 是自由的。\n\n这组方程构成了一个两点边值问题（TPBVP），因为我们有状态在起点（$s_0$）和终点（$s_T$）的条件，而状态和协态的动态方程是耦合的，并且在时间上朝相反方向演化（状态前向，协态后向）。\n\n### 步骤2：单次打靶法设计\n\n单次打靶法将两点边值问题（TPBVP）转换为一个初值问题（IVP）。我们选择一个未知的初始值，通过积分动态方程在时间上“向前打靶”，然后调整我们的初始猜测，直到满足终端条件。\n\n一个自然的选择是使用协态的初始值 $\\lambda_0$ 作为打靶变量。如果 $\\lambda_0$ 已知，我们就可以正向模拟整个系统。\n\n给定一个 $\\lambda_0$ 的猜测值，正向模拟的步骤如下：用 $s_t = s_0$ 和 $\\lambda_t = \\lambda_0$ 进行初始化。对于 $t = 0, 1, \\ldots, T-1$：\n1.  从协态方程求解 $\\lambda_{t+1}$：\n    $$\n    \\lambda_{t+1} = \\frac{\\lambda_t - \\beta s_t}{1 - e}\n    $$\n    这是良定的，因为问题规定 $e \\in [0, 1)$。\n2.  使用 $\\lambda_{t+1}$ 找到最优控制 $r_t$：\n    $$\n    r_t = D_t + \\frac{1}{\\alpha}\\lambda_{t+1}\n    $$\n3.  使用 $r_t$ 找到下一个状态 $s_{t+1}$：\n    $$\n    s_{t+1} = (1 - e)s_t + I_t - r_t\n    $$\n4.  为下一次迭代更新状态和协态：设置 $s_t \\to s_{t+1}$ 和 $\\lambda_t \\to \\lambda_{t+1}$。\n\n这个模拟过程定义了一个函数，它将初始猜测值 $\\lambda_0$ 映射到最终的期末状态，我们将其表示为 $s_T(\\lambda_0)$。我们的目标是找到特定的值 $\\lambda_0^*$，使得期末约束得到满足：\n$$\ns_T(\\lambda_0^*) = S^\\star\n$$\n这是一个关于残差函数 $f(\\lambda_0)$ 的求根问题：\n$$\nf(\\lambda_0) = s_T(\\lambda_0) - S^\\star = 0\n$$\n\n### 步骤3：使用区间法求根\n\n问题要求使用一种区间求根法。我们将使用二分法，该方法是鲁棒的，并且如果找到了初始区间，则保证收敛。一个区间是指一个区间 $[\\lambda_a, \\lambda_b]$，其中 $f(\\lambda_a)$ 和 $f(\\lambda_b)$ 的符号相反。\n\n为确保二分法有效，我们必须分析 $f(\\lambda_0)$ 的单调性。通过对模拟方程关于 $\\lambda_0$ 求导，我们可以证明对于所有 $t0$（只要 $\\alpha  0$），$\\frac{ds_T}{d\\lambda_0}  0$。这意味着 $s_T(\\lambda_0)$，以及 $f(\\lambda_0)$，是关于 $\\lambda_0$ 的严格单调递减函数。此性质保证了唯一根的存在，并简化了寻找区间的过程。\n\n二分法算法流程如下：\n1.  建立一个初始区间 $[\\lambda_{low}, \\lambda_{high}]$，使得 $f(\\lambda_{low}) > 0$ 且 $f(\\lambda_{high})  0$。可以系统地扩展区间的初始猜测，直到它包含根。\n2.  迭代地缩小区间：\n    a. 计算中点 $\\lambda_{mid} = (\\lambda_{low} + \\lambda_{high}) / 2$。\n    b. 计算 $f(\\lambda_{mid})$。\n    c. 如果 $f(\\lambda_{mid}) > 0$，根必定位于 $[\\lambda_{mid}, \\lambda_{high}]$。设置 $\\lambda_{low} = \\lambda_{mid}$。\n    d. 如果 $f(\\lambda_{mid})  0$，根必定位于 $[\\lambda_{low}, \\lambda_{mid}]$。设置 $\\lambda_{high} = \\lambda_{mid}$。\n3.  重复此过程，直到区间宽度 $(\\lambda_{high} - \\lambda_{low})$ 小于指定的容差。根随后由最终区间的中点近似。\n\n### 步骤4：最终计算\n\n一旦以足够的精度找到最优的初始协态 $\\lambda_0^*$，我们就使用这个值进行最后一次正向模拟。在此模拟过程中，我们计算最优状态路径 $\\{s_t^*\\}_{t=0}^{T-1}$ 和最优控制路径 $\\{r_t^*\\}_{t=0}^{T-1}$。然后通过对各周期成本求和来计算最小化的目标函数值：\n$$\nJ^* = \\sum_{t=0}^{T-1} \\left( \\frac{1}{2}\\alpha (r_t^* - D_t)^2 + \\frac{1}{2}\\beta (s_t^*)^2 \\right)\n$$\n该值是每个测试用例的最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the reservoir management problem for all test cases.\n    \"\"\"\n    # Test suite:\n    # (T, alpha, beta, e, s0, S_star, I, D)\n    test_cases = [\n        (\n            12, 2.0, 0.1, 0.02, 30.0, 40.0,\n            np.array([22.0, 18.0, 15.0, 12.0, 10.0, 8.0, 7.0, 8.0, 10.0, 12.0, 16.0, 24.0]),\n            np.array([16.0, 16.5, 17.0, 17.5, 18.0, 19.0, 20.0, 19.5, 18.5, 17.5, 17.0, 16.5]),\n        ),\n        (\n            12, 10.0, 0.0, 0.0, 50.0, 50.0,\n            np.array([10.0] * 12),\n            np.array([10.0] * 12),\n        ),\n        (\n            12, 0.5, 0.2, 0.05, 5.0, 8.0,\n            np.array([5.0, 4.0, 3.5, 3.0, 2.5, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0]),\n            np.array([3.0, 3.2, 3.5, 3.8, 4.0, 4.2, 4.5, 4.2, 4.0, 3.8, 3.5, 3.2]),\n        ),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        obj_val = solve_single_case(*case_params)\n        results.append(f\"{obj_val:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_single_case(T, alpha, beta, e, s0, S_star, I, D):\n    \"\"\"\n    Solves a single instance of the dynamic optimization problem using a single-shooting method.\n    \n    Args:\n        T (int): Planning horizon.\n        alpha (float): Weight on control deviation.\n        beta (float): Weight on state deviation.\n        e (float): Evaporation factor.\n        s0 (float): Initial storage.\n        S_star (float): Target terminal storage.\n        I (np.array): Inflow vector.\n        D (np.array): Demand vector.\n\n    Returns:\n        float: The minimized objective function value.\n    \"\"\"\n\n    one_minus_e = 1.0 - e\n\n    def forward_simulation(lambda0):\n        \"\"\"\n        Simulates the system dynamics forward given an initial co-state lambda0.\n        Returns the terminal state s_T and the accumulated objective value.\n        \"\"\"\n        s = s0\n        lam = lambda0\n        total_objective = 0.0\n\n        for t in range(T):\n            # Add cost associated with state s_t\n            total_objective += 0.5 * beta * s**2\n\n            # Calculate co-state lambda_{t+1}\n            lam_next = (lam - beta * s) / one_minus_e\n\n            # Calculate control r_t\n            r = D[t] + lam_next / alpha\n            \n            # Add cost associated with control r_t\n            total_objective += 0.5 * alpha * (r - D[t])**2\n\n            # Calculate next state s_{t+1}\n            s_next = one_minus_e * s + I[t] - r\n            \n            # Update for next iteration\n            s = s_next\n            lam = lam_next\n\n        return s, total_objective\n\n    def residual_function(lambda0):\n        \"\"\"\n        Calculates the residual s_T(lambda0) - S_star. This is the function\n        for which we a find a root.\n        \"\"\"\n        s_T, _ = forward_simulation(lambda0)\n        return s_T - S_star\n\n    # --- Bracketed Root-Finding (Bisection Method) ---\n\n    # 1. Find a bracket [low, high] for lambda0\n    low, high = -100.0, 100.0\n    f_low = residual_function(low)\n    f_high = residual_function(high)\n\n    # Expand the bracket if the root is not contained\n    expansion_iter = 0\n    while f_low * f_high > 0 and expansion_iter  20:\n        if abs(f_low)  abs(f_high):\n            low *= 2.0\n            f_low = residual_function(low)\n        else:\n            high *= 2.0\n            f_high = residual_function(high)\n        expansion_iter += 1\n\n    if f_low * f_high > 0:\n        raise RuntimeError(\"Failed to find a bracket for the root.\")\n\n    # The function s_T(lambda0) is monotonically decreasing.\n    # We ensure f(low) > 0 and f(high)  0.\n    if f_low  f_high:\n        low, high = high, low\n        f_low, f_high = f_high, f_low\n\n    # 2. Bisection to find the root\n    tol = 1e-12\n    max_iter = 100\n    for _ in range(max_iter):\n        mid = (low + high) / 2.0\n        if high - low  tol:\n            break\n        \n        f_mid = residual_function(mid)\n\n        if abs(f_mid)  tol:\n            low = high = mid\n            break\n        \n        # As s_T(lambda0) is decreasing, so is the residual function.\n        # If f_mid > 0, the root is in the upper half of the interval.\n        if f_mid > 0:\n            low = mid\n        else:\n            high = mid\n            \n    lambda0_optimal = (low + high) / 2.0\n\n    # 3. Final calculation with the optimal lambda0\n    _, final_objective = forward_simulation(lambda0_optimal)\n\n    return final_objective\n\n# The script should be runnable \"as is\"\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在掌握了离散时间模型的基础后，我们将进入连续时间的领域，探讨一个关于抗生素使用与耐药性演化的动态优化问题。这个练习要求你将打靶法应用于一个由常微分方程（ODEs）描述的系统。对于这类线性边值问题，你将学习并应用一个更为高效的技巧——叠加原理（superposition principle），它能够直接解出所需的初始值，而无需进行迭代式的求根搜索，这展示了针对特定问题结构采用专门方法的重要性。",
            "id": "2429165",
            "problem": "考虑以下作为一个带有固定终端状态的边值问题提出的二次最优控制问题。一个标量状态 $R(t)$ 表示在时间 $t$ 医院中耐药病原体的份额，一个标量控制 $u(t)$ 表示抗生素的使用强度。其动力学是线性的，由下式给出\n$$\\dot{R}(t) = \\theta u(t) - \\delta R(t), \\quad R(0) = R_0,$$\n其中 $\\theta  0$ 是抗生素使用对耐药性的边际效应，$\\delta  0$ 是在没有抗生素使用情况下耐药性的自然衰减率。目标是最小化二次折现成本泛函\n$$J[u] = \\int_0^T \\frac{1}{2}\\left(u(t)^2 + q R(t)^2\\right)\\,dt,$$\n并满足在固定的终端时间 $T$ 达到目标耐药水平 $R(T) = R_T$ 的约束。假设所有参数 $\\theta  0$、$\\delta  0$、$q  0$、$T  0$ 均为常数，并给定初始值 $R_0$ 和终端值 $R_T$。没有控制界限。\n\n你的任务是编写一个完整的、可运行的程序，该程序：\n- 从第一性原理出发，使用庞特里亚金极大值原理推导出一个可实现的必要条件系统，并通过适当地选择初始协态，使用打靶法来数值上强制施加终端条件 $R(T) = R_T$。\n- 使用前向积分和一个对未知初始协态的求根更新来解决由此产生的两点边值问题。你的实现必须是完全自包含的，并且不得要求任何用户输入。\n- 对于每个测试用例，返回最优初始控制 $u(0)$ 和最小化的目标值 $J$。\n\n你可以假设以下基本知识为已知：庞特里亚金极大值原理的定义，最优控制问题的哈密顿量的定义，将必要条件与协态联系起来的欧拉-拉格朗日逻辑，以及标准的常微分方程求解概念。你不得假设针对此特定问题量身定制的专门公式；必须从定义开始，在实现数值方法之前推导出必要条件。\n\n数值规格：\n- 使用前向打靶法。将初始协态 $\\lambda(0)$ 视为一个待求的未知数，以便在哈密顿系统的前向求解下，状态能够达到终端目标 $R(T) = R_T$。你必须将终端状态条件的绝对容差强制为 $10^{-8}$。\n- 对常微分方程使用一个鲁棒的时间积分器，并对 $\\lambda(0)$ 使用一个数值稳定的更新。数值实现必须在给定的测试套件下保持稳定。\n\n测试套件：\n- 情况 A：$T = 10.0$，$R_0 = 0.1$，$R_T = 0.2$，$\\theta = 0.8$，$\\delta = 0.05$，$q = 0.4$。\n- 情况 B：$T = 0.5$，$R_0 = 0.2$，$R_T = 0.21$，$\\theta = 1.0$，$\\delta = 0.1$，$q = 0.7$。\n- 情况 C：$T = 5.0$，$R_0 = 0.3$，$R_T = 0.15$，$\\theta = 1.2$，$\\delta = 0.3$，$q = 0.2$。\n\n答案规格：\n- 对于每个测试用例，计算最优初始控制 $u(0)$ 和最小化的目标值 $J$。将这两个数字表示为精确到 $6$ 位小数的十进制浮点值。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是 $[u(0), J]$ 顺序的一个双元素列表。对于上述三个测试用例，要求的格式是\n\"[[u0_A,J_A],[u0_B,J_B],[u0_C,J_C]]\"。具体来说，你的程序必须打印完全符合以下格式的单行：\n\"[[u0_A,J_A],[u0_B,J_B],[u0_C,J_C]]\"\n其中每个符号都被替换为相应的小数并四舍五入到 $6$ 位。\n\n此问题中没有物理单位。此问题中不出现角度。任何地方都不得使用百分比；所有结果必须是十进制数。",
            "solution": "所呈现的问题是一个具有固定终端状态的连续时间有限时域线性二次最优控制问题。通过应用庞特里亚金极大值原理推导出一组必要条件来获得解，这导致了一个两点边值问题（TPBVP）。然后使用前向打靶法数值求解这个TPBVP。\n\n首先，我们从第一性原理建立理论基础。状态变量是 $R(t)$，控制变量是 $u(t)$。状态动力学由下式给出\n$$ \\dot{R}(t) = \\theta u(t) - \\delta R(t), \\quad R(0) = R_0 $$\n目标是最小化成本泛函\n$$ J[u] = \\int_0^T \\frac{1}{2}\\left(u(t)^2 + q R(t)^2\\right)\\,dt $$\n并满足终端约束 $R(T) = R_T$。\n\n为了应用庞特里亚金极大值原理，我们引入协态（或伴随）变量 $\\lambda(t)$ 并定义哈密顿量 $H$：\n$$ H(R, u, \\lambda) = \\frac{1}{2}(u(t)^2 + q R(t)^2) + \\lambda(t)(\\theta u(t) - \\delta R(t)) $$\n最优轨迹 $(R^*(t), u^*(t))$ 的必要条件由状态方程、协态方程和最优性条件给出。\n\n1. 状态方程：\n$$ \\dot{R}^*(t) = \\frac{\\partial H}{\\partial \\lambda} = \\theta u^*(t) - \\delta R^*(t) $$\n这恢复了系统动力学，其初始条件为 $R^*(0) = R_0$，终端条件为 $R^*(T) = R_T$。\n\n2. 协态方程：\n$$ \\dot{\\lambda}^*(t) = -\\frac{\\partial H}{\\partial R} = -(q R^*(t) - \\delta \\lambda^*(t)) = -q R^*(t) + \\delta \\lambda^*(t) $$\n由于终端状态 $R(T)$ 是固定的，因此对 $\\lambda^*(T)$ 没有横截性条件；其值是不受限制的。\n\n3. 最优性条件：\n哈密顿量必须在每个时间 $t \\in [0, T]$ 关于控制 $u(t)$ 最小化。由于控制是无约束的，我们通过将 $H$ 关于 $u$ 的一阶导数设为零来找到最小值：\n$$ \\frac{\\partial H}{\\partial u} = u^*(t) + \\theta \\lambda^*(t) = 0 $$\n这得出了以协态表示的最优控制律：\n$$ u^*(t) = -\\theta \\lambda^*(t) $$\n二阶导数 $\\frac{\\partial^2 H}{\\partial u^2} = 1  0$ 证实了这个条件对应于一个最小值。\n\n将最优控制律代回状态和协态方程，得到一个关于 $R(t)$ 和 $\\lambda(t)$ 的耦合线性常微分方程（ODEs）系统：\n$$ \\dot{R}(t) = -\\delta R(t) - \\theta^2 \\lambda(t) $$\n$$ \\dot{\\lambda}(t) = -q R(t) + \\delta \\lambda(t) $$\n这些方程受边界条件 $R(0) = R_0$ 和 $R(T) = R_T$ 的约束。这构成了一个两点边值问题。\n\n为了解决这个TPBVP，我们采用前向打靶法。未知的初始条件是初始协态，我们记为 $p = \\lambda(0)$。目标是找到 $p$ 的值，使得如果我们从 $(R(0), \\lambda(0)) = (R_0, p)$ 开始对ODE系统进行前向积分，解满足 $R(T) = R_T$。\n\n由于ODE系统的线性特性，我们可以应用叠加原理来高效地求解 $p$。$R(t)$ 的解可以表示为由 $R_0$ 驱动的齐次解和由 $p$ 驱动的特解的线性组合。设 $(R_h(t), \\lambda_h(t))$ 是初始条件为 $(R_h(0), \\lambda_h(0)) = (R_0, 0)$ 的ODE系统的解，设 $(R_p(t), \\lambda_p(t))$ 是初始条件为 $(R_p(0), \\lambda_p(0)) = (0, 1)$ 的解。那么从 $(R_0, p)$ 开始的通解由下式给出：\n$$ R(t) = R_h(t) + p \\cdot R_p(t) $$\n为满足终端条件 $R(T) = R_T$，我们必须有：\n$$ R_T = R_h(T) + p \\cdot R_p(T) $$\n解出未知的初始协态 $p$ 得到：\n$$ p = \\lambda(0) = \\frac{R_T - R_h(T)}{R_p(T)} $$\n这提供了一种直接找到正确 $\\lambda(0)$ 的方法。数值步骤如下：\n1. 从 $t=0$ 到 $t=T$ 用初始条件 $(R_0, 0)$ 数值积分ODE系统，以找到 $R_h(T)$。\n2. 从 $t=0$ 到 $t=T$ 用初始条件 $(0, 1)$ 数值积分相同的系统，以找到 $R_p(T)$。\n3. 使用上面的公式计算所需的初始协态 $\\lambda(0) = p$。\n\n现在正确的初始条件 $(R(0), \\lambda(0)) = (R_0, p)$ 已完全确定，可以计算最小化的目标值 $J$。$J$ 的被积函数是 $\\frac{1}{2}(u(t)^2 + qR(t)^2) = \\frac{1}{2}(\\theta^2 \\lambda(t)^2 + qR(t)^2)$。为了计算该积分，我们用一个表示累积成本的第三个状态变量 $V(t)$ 来增广ODE系统：\n$$ \\dot{V}(t) = \\frac{1}{2}(\\theta^2 \\lambda(t)^2 + q R(t)^2), \\quad V(0) = 0 $$\n通过使用初始条件 $(R(0), \\lambda(0), V(0)) = (R_0, p, 0)$ 从 $t=0$ 到 $t=T$ 积分这个增广的三维系统，最小化的目标值可以作为 $J = V(T)$ 获得。最优初始控制由 $u(0) = -\\theta \\lambda(0) = -\\theta p$ 给出。此过程对提供的每个测试用例实施。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the quadratic optimal control problem for three test cases\n    using a forward shooting method based on the principle of superposition.\n    \"\"\"\n    # Test cases as provided in the problem statement.\n    # Format: (T, R0, RT, theta, delta, q)\n    test_cases = [\n        (10.0, 0.1, 0.2, 0.8, 0.05, 0.4),  # Case A\n        (0.5, 0.2, 0.21, 1.0, 0.1, 0.7),  # Case B\n        (5.0, 0.3, 0.15, 1.2, 0.3, 0.2),  # Case C\n    ]\n\n    results = []\n\n    for case in test_cases:\n        T, R0, RT, theta, delta, q = case\n\n        # Pre-compute squared parameters for efficiency in the ODE integrators.\n        theta_sq = theta**2\n\n        # Define the Hamiltonian ODE system for R(t) and lambda(t).\n        def hamiltonian_system(t, y):\n            \"\"\"\n            Represents the system d(y)/dt = A*y, where y = [R, lambda].\n            \"\"\"\n            R, lam = y\n            R_dot = -delta * R - theta_sq * lam\n            lam_dot = -q * R + delta * lam\n            return [R_dot, lam_dot]\n\n        # Use high-precision tolerances for the numerical integration to ensure\n        # the terminal condition is met accurately.\n        atol = 1e-12\n        rtol = 1e-12\n        \n        # --- Shooting Method using Superposition ---\n\n        # 1. Integrate for the homogeneous part of the solution, driven by R0.\n        #    Initial conditions: [R(0), lambda(0)] = [R0, 0].\n        y0_h = [R0, 0.0]\n        sol_h = solve_ivp(\n            hamiltonian_system, [0, T], y0_h, atol=atol, rtol=rtol\n        )\n        R_h_T = sol_h.y[0, -1]\n\n        # 2. Integrate for the particular part of the solution, driven by lambda(0).\n        #    Initial conditions: [R(0), lambda(0)] = [0, 1].\n        y0_p = [0.0, 1.0]\n        sol_p = solve_ivp(\n            hamiltonian_system, [0, T], y0_p, atol=atol, rtol=rtol\n        )\n        R_p_T = sol_p.y[0, -1]\n        \n        if abs(R_p_T)  1e-10:\n            raise RuntimeError(\n                \"Shooting method failed: R_p(T) is near zero, \"\n                \"indicating lambda(0) has no influence on R(T).\"\n            )\n\n        # 3. Compute the correct initial costate lambda(0) such that R(T) = RT.\n        #    From linearity: RT = R_h(T) + lambda_0 * R_p(T)\n        lambda_0 = (RT - R_h_T) / R_p_T\n\n        # --- Final Calculation ---\n\n        # The optimal initial control is derived from the optimal lambda_0.\n        u0_opt = -theta * lambda_0\n\n        # Define the augmented system including the cost functional integral V(t).\n        def augmented_system(t, y):\n            \"\"\"\n            Represents the system for [R, lambda, V], where V is the accumulated cost.\n            \"\"\"\n            R, lam, V = y\n            R_dot = -delta * R - theta_sq * lam\n            lam_dot = -q * R + delta * lam\n            V_dot = 0.5 * (theta_sq * lam**2 + q * R**2)\n            return [R_dot, lam_dot, V_dot]\n\n        # 4. Integrate the full system forward with the correct initial conditions\n        #    [R(0), lambda(0), V(0)] to find the optimal trajectory and cost.\n        y0_final = [R0, lambda_0, 0.0]\n        sol_final = solve_ivp(\n            augmented_system, [0, T], y0_final, atol=atol, rtol=rtol\n        )\n\n        # The minimized total cost J is the value of V(T).\n        J_opt = sol_final.y[2, -1]\n        \n        # Verify terminal condition is met within the specified tolerance of 1e-8.\n        R_T_final = sol_final.y[0, -1]\n        if abs(R_T_final - RT) > 1e-8:\n             raise RuntimeError(\n                f\"Terminal condition not met. Error: {abs(R_T_final - RT)}\"\n            )\n\n        # Append the formatted results for the current test case.\n        # Results are rounded to 6 decimal places as specified.\n        results.append(f\"[{u0_opt:.6f},{J_opt:.6f}]\")\n\n    # Print the final output in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个练习将带你从线性二次模型的世界，进入到经济学中更普遍、更核心的非线性模型领域——新古典增长模型。你将应用打靶法来寻找最优的初始消费水平，以确保经济在有限的时期后能够达到理想的稳态资本水平。由于模型的非线性特性，之前练习中的叠加原理将不再适用，你将回归到打靶法的基本思路上，即定义一个残差函数，并使用像Brent算法这样的鲁棒求根器来精确求解，这充分展示了打靶法作为一种通用工具的强大功能。",
            "id": "2429167",
            "problem": "考虑一个具有恒定相对风险厌恶 (CRRA) 偏好和柯布-道格拉斯生产函数的确定性有限期最优增长模型。令 $t \\in \\{0,1,\\dots,T\\}$ 表示时间。资源动态和一阶最优性条件意味着以下要素。\n\n- 令 $k_t$ 表示时间 $t$ 的资本，$c_t$ 表示时间 $t$ 的消费，参数为 $\\alpha \\in (0,1)$，$\\beta \\in (0,1)$，$\\delta \\in (0,1)$ 和 $\\sigma  0$。\n- 生产函数为 $f(k_t) = k_t^{\\alpha}$，边际产出为 $f'(k_t) = \\alpha k_t^{\\alpha-1}$，可用总资源为 $y_t = f(k_t) + (1-\\delta) k_t$。\n- 运动定律为 $k_{t+1} = y_t - c_t$。\n- 由效用导数为 $u'(c_t) = c_t^{-\\sigma}$ 的 CRRA 偏好得出的欧拉方程，当 $k_{t+1}  0$ 时，意味着以下前向递归关系\n$$\nc_{t+1} = c_t \\left(\\beta \\left(f'(k_{t+1}) + 1 - \\delta\\right)\\right)^{1/\\sigma}\n$$\n\n对于任意备选初始消费 $c_0$ 和给定的初始资本 $k_0  0$，通过从 $(k_0,c_0)$ 开始，将上述两个递归关系前向迭代 $T$ 步，然后最后一次应用资源恒等式得到 $k_{T+1} = f(k_T) + (1-\\delta)k_T - c_T$，来定义模拟的 $(T+1)$ 步后资本 $k_{T+1}(c_0)$。\n\n将目标稳态资本 $k^{\\ast}$ 定义为下式的唯一正解\n$$\nf'(k^{\\ast}) = \\frac{1}{\\beta} - (1 - \\delta),\n$$\n即\n$$\n\\alpha (k^{\\ast})^{\\alpha - 1} = \\frac{1}{\\beta} - (1 - \\delta).\n$$\n\n定义标量误差函数\n$$\nE(c_0) = k_{T+1}(c_0) - k^{\\ast}.\n$$\n\n你的任务是编写一个完整的程序，对于下面测试套件中的每一组参数，计算出一个值 $\\hat{c}_0$，该值在可行性约束 $0  c_0  y_0$（其中 $y_0 = f(k_0) + (1-\\delta) k_0$）下，满足 $|E(\\hat{c}_0)| \\leq \\varepsilon$，其中 $\\varepsilon$ 是指定的容差。\n\n该测试套件包含四个案例。在每个案例中，初始资本 $k_0$ 和 $c_0$ 的取值区间分别用 $k^{\\ast}$ 和 $y_0$ 表示。对于每个案例，根据参数计算 $k^{\\ast}$，然后按规定设置 $k_0$ 以及 $c_0$ 的区间和初始备选值。\n\n- 案例 A (一般可行性与收敛性)：\n  - 参数：$\\alpha = 0.33$，$\\beta = 0.96$，$\\delta = 0.08$，$\\sigma = 2.0$， $T = 75$。\n  - 初始资本：$k_0 = 0.8 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的区间：$[c_{\\min}, c_{\\max}] = [0.05 \\, y_0, 0.95 \\, y_0]$。\n  - 初始备选值：$c_0^{(0)} = 0.5 \\, (c_{\\min} + c_{\\max})$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n\n- 案例 B (高曲率的短期界)：\n  - 参数：$\\alpha = 0.33$，$\\beta = 0.985$，$\\delta = 0.05$，$\\sigma = 10.0$， $T = 20$。\n  - 初始资本：$k_0 = 1.2 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的区间：$[c_{\\min}, c_{\\max}] = [0.05 \\, y_0, 0.95 \\, y_0]$。\n  - 初始备选值：$c_0^{(0)} = 0.25 \\, (c_{\\min} + 3 c_{\\max})$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n\n- 案例 C (极低初始资本与长期界)：\n  - 参数：$\\alpha = 0.35$，$\\beta = 0.96$，$\\delta = 0.08$，$\\sigma = 1.5$， $T = 150$。\n  - 初始资本：$k_0 = 0.5 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的区间：$[c_{\\min}, c_{\\max}] = [0.2 \\, y_0, 0.99 \\, y_0]$。\n  - 初始备选值：$c_0^{(0)} = 0.98 \\, y_0$。\n  - 容差：$\\varepsilon = 10^{-8}$。\n\n- 案例 D (初始处于稳态)：\n  - 参数：$\\alpha = 0.3$，$\\beta = 0.95$，$\\delta = 0.08$，$\\sigma = 2.0$， $T = 60$。\n  - 初始资本：$k_0 = 1.0 \\, k^{\\ast}$。\n  - 定义 $y_0 = f(k_0) + (1-\\delta) k_0$。\n  - $c_0$ 的区间：$[c_{\\min}, c_{\\max}] = [0.2 \\, y_0, 0.95 \\, y_0]$。\n  - 初始备选值：$c_0^{(0)} = 0.5 \\, (c_{\\min} + c_{\\max})$。\n  - 容差：$\\varepsilon = 10^{-10}$。\n\n对于每个案例，返回一个浮点近似值 $\\hat{c}_0$，满足 $|E(\\hat{c}_0)| \\leq \\varepsilon$ 和 $c_{\\min} \\leq \\hat{c}_0 \\leq c_{\\max}$。所有量都是无单位的实数。最终输出格式必须是单行，包含一个由四个近似值组成的逗号分隔列表，四舍五入到六位小数，并用方括号括起来，例如 $\\texttt{[0.123456,0.234567,0.345678,0.456789]}$。",
            "solution": "问题陈述已经过验证并被认为是有效的。它代表了计算经济学中一个适定的、有科学依据的问题，具体来说是应用打靶法来求解一个确定性有限期最优增长模型。所有参数和函数都有清晰的定义，目标是可量化且明确的。\n\n问题的核心是找到一个初始消费水平 $\\hat{c}_0$，使得有限期末的资本存量 $k_{T+1}$ 与一个预定目标相匹配。这个目标是模型的稳态资本 $k^{\\ast}$。这是一个经典的求根问题。我们定义一个误差函数 $E(c_0)$，作为模拟的期末资本与目标稳态资本之间的差值：\n$$\nE(c_0) = k_{T+1}(c_0) - k^{\\ast}\n$$\n任务是找到一个 $\\hat{c}_0$，使得 $|E(\\hat{c}_0)|$ 小于指定的容差 $\\varepsilon$。\n\n函数 $k_{T+1}(c_0)$ 是通过前向模拟经济动态来构建的。给定初始资本存量 $k_0  0$ 和一个备选初始消费 $c_0$，资本 $\\{k_t\\}_{t=1}^{T+1}$ 和消费 $\\{c_t\\}_{t=1}^{T}$ 的轨迹由以下适用于 $t = 0, 1, \\dots, T-1$ 的差分方程组确定：\n$$\nk_{t+1} = k_t^{\\alpha} + (1-\\delta)k_t - c_t\n$$\n$$\nc_{t+1} = c_t \\left(\\beta \\left(\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right)^{1/\\sigma}\n$$\n模拟从 $(k_0, c_0)$ 开始，计算出 $(k_1, c_1)$，然后是 $(k_2, c_2)$，以此类推，直到 $(k_T, c_T)$。最后，再对资本积累方程进行一次迭代，得到 $k_{T+1} = k_T^{\\alpha} + (1-\\delta)k_T - c_T$。这个最终值 $k_{T+1}$ 是初始选择 $c_0$ 的函数。\n\n稳态资本 $k^{\\ast}$ 是从一个条件推导出来的，即在稳态下，资本的边际回报等于经折旧校正后的时间偏好率。它是 $f'(k^{\\ast}) + 1 - \\delta = 1/\\beta$ 的唯一正解，即：\n$$\n\\alpha (k^{\\ast})^{\\alpha-1} = \\frac{1}{\\beta} - 1 + \\delta\n$$\n这意味着：\n$$\nk^{\\ast} = \\left(\\frac{\\alpha}{\\frac{1}{\\beta} - 1 + \\delta}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n\n误差函数 $E(c_0)$ 是 $c_0$ 的一个严格递减函数。初始消费 $c_0$ 的增加必然会减少初始投资 $k_1 = k_0^{\\alpha} + (1-\\delta)k_0 - c_0$。这个较低的资本存量 $k_1$ 会减少下一期可用的资源，从而导致此后资本和消费的路径都相应缩减。因此，$k_{T+1}$ 随着 $c_0$ 的增加而减少。这种单调性保证了如果 $E(c_0)=0$ 的根存在，它就是唯一的。\n\n鉴于 $E(c_0)$ 的单调性以及每个测试案例都提供了区间 $[c_{\\min}, c_{\\max}]$，一个鲁棒的求根算法是合适的工具。Brent 方法是一个绝佳的选择。它在 SciPy 库中以 `scipy.optimize.brentq` 的形式提供。该方法结合了二分法的安全性、割线法的速度和逆二次插值。只要端点处的函数值异号，它就保证能在指定的区间内找到一个根。根据经济学原理推断，较低的 $c_0$（如 $c_{\\min}$）会导致资本的过度积累，因此 $k_{T+1}(c_{\\min})  k^{\\ast}$ 且 $E(c_{\\min})  0$。相反，较高的 $c_0$（如 $c_{\\max}$）会导致资本耗尽，因此 $k_{T+1}(c_{\\max})  k^{\\ast}$ 且 $E(c_{\\max})  0$。因此，所提供的区间对于 Brent 方法是有效的。虽然问题陈述中提到了一个“初始备选值” $c_0^{(0)}$，但区间算法不使用它，因此为了采用更鲁棒的基于区间的方法而忽略该值。\n\n每个测试案例的计算步骤如下：\n$1$. 使用给定的参数 $\\alpha$、$\\beta$ 和 $\\delta$ 计算稳态资本 $k^{\\ast}$。\n$2$. 定义初始资本 $k_0$ 和可用资源 $y_0 = k_0^{\\alpha} + (1-\\delta)k_0$。\n$3$. 使用指定的 $y_0$ 建立搜索区间 $[c_{\\min}, c_{\\max}]$。\n$4$. 实现误差函数 $E(c_0)$，该函数执行 $T$ 步前向模拟以计算 $k_{T+1}(c_0)$ 并返回差值 $k_{T+1}(c_0) - k^{\\ast}$。在模拟过程中，必须检查以确保资本保持为正 ($k_t  0$)。如果选择的 $c_0$ 导致在任何步骤 $t$ 的资本存量为非正数，则该路径在经济上是不可行的。这种情况发生在 $c_0$ 过高时。在这种情况下，函数应返回一个绝对值很大的负值，以向求解器正确地指示该 $c_0$ 位于根的对应于低期末资本的一侧。\n$5$. 使用 `scipy.optimize.brentq` 在区间 $[c_{\\min}, c_{\\max}]$ 内找到误差函数 $E(c_0)$ 的根 $\\hat{c}_0$，并达到很高的精度，这将满足问题对函数值的容差要求。\n$6$. 将每个案例计算出的值 $\\hat{c}_0$ 收集起来并格式化以备最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the optimal initial consumption c_0 for four different\n    parameterizations of a deterministic optimal growth model.\n    \"\"\"\n\n    test_cases = [\n        # Case A: General feasibility and convergence\n        {\n            'alpha': 0.33, 'beta': 0.96, 'delta': 0.08, 'sigma': 2.0, 'T': 75,\n            'k0_factor': 0.8, 'c_min_factor': 0.05, 'c_max_factor': 0.95,\n            'tolerance': 1e-8,\n        },\n        # Case B: Short horizon with high curvature\n        {\n            'alpha': 0.33, 'beta': 0.985, 'delta': 0.05, 'sigma': 10.0, 'T': 20,\n            'k0_factor': 1.2, 'c_min_factor': 0.05, 'c_max_factor': 0.95,\n            'tolerance': 1e-8,\n        },\n        # Case C: Very low initial capital and long horizon\n        {\n            'alpha': 0.35, 'beta': 0.96, 'delta': 0.08, 'sigma': 1.5, 'T': 150,\n            'k0_factor': 0.5, 'c_min_factor': 0.2, 'c_max_factor': 0.99,\n            'tolerance': 1e-8,\n        },\n        # Case D: Initially at steady state\n        {\n            'alpha': 0.3, 'beta': 0.95, 'delta': 0.08, 'sigma': 2.0, 'T': 60,\n            'k0_factor': 1.0, 'c_min_factor': 0.2, 'c_max_factor': 0.95,\n            'tolerance': 1e-10,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        c0_hat = compute_c0_hat_for_case(params)\n        results.append(c0_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef compute_c0_hat_for_case(params):\n    \"\"\"\n    Computes the optimal initial consumption for a single parameter set.\n    \"\"\"\n    alpha = params['alpha']\n    beta = params['beta']\n    delta = params['delta']\n    sigma = params['sigma']\n    T = params['T']\n\n    # 1. Calculate steady-state capital k_star\n    # From alpha * (k_star)^(alpha - 1) = 1/beta - 1 + delta\n    rhs = 1.0 / beta - 1.0 + delta\n    k_star = (alpha / rhs) ** (1.0 / (1.0 - alpha))\n\n    # 2. Set up initial conditions\n    k0 = params['k0_factor'] * k_star\n    y0 = k0**alpha + (1.0 - delta) * k0\n\n    # 3. Establish the search bracket for c0\n    c_min = params['c_min_factor'] * y0\n    c_max = params['c_max_factor'] * y0\n    \n    def error_function(c0):\n        \"\"\"\n        Computes the error E(c0) = k_{T+1}(c0) - k_star.\n        This function closes over the model parameters for the specific case.\n        \"\"\"\n        k = k0\n        c = c0\n\n        for _ in range(T):\n            # Law of motion for capital\n            k_next = k**alpha + (1.0 - delta) * k - c\n            \n            # Check for economic feasibility. If capital becomes non-positive,\n            # this c0 is too high, leading to a very low k_{T+1}.\n            # Return a large negative error to guide the solver.\n            if k_next = 0:\n                return -1e100\n\n            # Euler equation for consumption\n            f_prime = alpha * k_next**(alpha - 1.0)\n            c_next = c * (beta * (f_prime + 1.0 - delta))**(1.0 / sigma)\n            \n            k = k_next\n            c = c_next\n\n        # After T steps, k is k_T and c is c_T. Compute k_{T+1}.\n        k_T_plus_1 = k**alpha + (1.0 - delta) * k - c\n        \n        return k_T_plus_1 - k_star\n\n    # 4. Use brentq to find the root of the error function\n    # The default tolerances of brentq are more than sufficient to meet the\n    # problem's requirement on the error value.\n    try:\n        c0_hat = brentq(error_function, c_min, c_max)\n    except ValueError:\n        # This might happen if error_function(c_min) and error_function(c_max)\n        # do not have opposite signs, indicating a problem with the setup.\n        # For this well-behaved problem, this is not expected.\n        return np.nan\n\n    return c0_hat\n\nsolve()\n```"
        }
    ]
}