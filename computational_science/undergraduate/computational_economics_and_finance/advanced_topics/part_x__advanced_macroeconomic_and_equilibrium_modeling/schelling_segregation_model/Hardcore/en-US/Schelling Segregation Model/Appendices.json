{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the Schelling model, one must build it. This first exercise guides you through a foundational simulation of the model, framed within the language of statistical physics. You will implement the core stochastic dynamic where individual agents, unhappy with their local neighborhood, move to a random vacant location, which is a key concept for understanding the model's emergent properties . This practice is essential for developing a hands-on intuition for how simple, decentralized rules can lead to the large-scale phenomenon of segregation.",
            "id": "2411695",
            "problem": "You will model Schelling’s residential segregation as a time-homogeneous Markov chain on a two-dimensional periodic square lattice, formulated in the language of statistical physics. The lattice has linear size $N$, sites indexed by integer coordinates $(i,j)$ with $i \\in \\{0,\\dots,N-1\\}$ and $j \\in \\{0,\\dots,N-1\\}$, and periodic boundary conditions. Each site carries a state $s_{i,j} \\in \\{-1,0,+1\\}$, where $s_{i,j}=+1$ denotes an agent of group $A$, $s_{i,j}=-1$ denotes an agent of group $B$, and $s_{i,j}=0$ denotes an empty site.\n\nDefine the Moore neighborhood of radius $r$ for site $(i,j)$ to be all sites $(i+\\Delta i \\bmod N, j+\\Delta j \\bmod N)$ with $\\Delta i,\\Delta j \\in \\{-r,\\dots,r\\}$ excluding $(\\Delta i,\\Delta j)=(0,0)$. For any occupied site $(i,j)$ with $s_{i,j} \\in \\{-1,+1\\}$, define the occupied-neighbor count $n_{i,j}^{\\mathrm{occ}}$ as the number of occupied neighbors in its neighborhood, and define the like-neighbor count $n_{i,j}^{\\mathrm{like}}$ as the number of those occupied neighbors whose state equals $s_{i,j}$. The satisfaction fraction is\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}},  \\text{if } n_{i,j}^{\\mathrm{occ}} > 0, \\\\[6pt]\n1,  \\text{if } n_{i,j}^{\\mathrm{occ}} = 0,\n\\end{cases}\n$$\nand an occupied site is said to be satisfied at threshold $\\tau \\in [0,1]$ if $\\phi_{i,j} \\ge \\tau$. Empty sites have no satisfaction value.\n\nLet the state space be the set of all configurations with fixed counts of $+1$, $-1$, and $0$ determined by specified fractions. The Markov chain transitions in discrete time as follows. At each step, if at least one occupied site is unsatisfied, choose uniformly at random one unsatisfied occupied site and uniformly at random one empty site, and move the chosen agent to the chosen empty site (the agent’s original site becomes empty). If no occupied site is unsatisfied, the chain remains in the current state. This defines a time-homogeneous Markov chain on the finite state space with periodic boundary conditions. The process is terminated either when all occupied sites are satisfied (an absorbing configuration for this kernel) or when a specified maximum number of steps $S_{\\max}$ is reached.\n\nInitialization is random subject to fixed counts: given $N$, an empty-site fraction $f_{\\mathrm{empty}} \\in [0,1)$, and a plus-type fraction among occupied sites $f_{+} \\in [0,1]$, the total number of sites is $N^2$, the number of empty sites is $N^2 f_{\\mathrm{empty}}$, and among the $N^2(1-f_{\\mathrm{empty}})$ occupied sites, $N^2(1-f_{\\mathrm{empty}}) f_{+}$ are $+1$ and the remainder are $-1$. Assume all these counts are integers for the specified test cases. The initial configuration is constructed by placing these counts uniformly at random across the lattice without bias.\n\nFor each test case below, simulate the chain from the specified random initial condition with the given neighborhood radius $r$, satisfaction threshold $\\tau$, and maximum steps $S_{\\max}$. Let $T$ be the number of executed moves until termination (so $T=0$ if the initial configuration is already absorbing, and $T=S_{\\max}$ if the cap is reached before absorption). Let $\\bar{\\phi}$ be the mean satisfaction fraction at termination, defined as the arithmetic mean of $\\phi_{i,j}$ over all occupied sites $(i,j)$. Report $\\bar{\\phi}$ rounded to three decimal places.\n\nYour program must produce results for the following test suite. In each case, use independent pseudo-random initialization and random choices with the given seed for reproducibility.\n\n- Case $1$: $N=20$, $f_{\\mathrm{empty}}=0.1$, $f_{+}=0.5$, $\\tau=0.5$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=1$.\n- Case $2$: $N=15$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=2$.\n- Case $3$: $N=20$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0.9$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=3$.\n- Case $4$: $N=5$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0.6$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=4$.\n\nFinal output format: Your program should produce a single line containing the results as a comma-separated list enclosed in square brackets, where each element is the pair $[T,\\bar{\\phi}]$ for a test case, with $\\bar{\\phi}$ rounded to three decimal places. For example, a valid output with two hypothetical results would look like \"[[$1$, $0.750$],[$200$, $0.643$]]\". There must be no additional text. All reported $\\bar{\\phi}$ values must be rounded to three decimal places, and $T$ must be an integer.",
            "solution": "The problem is valid. It presents a well-defined computational task based on the established Schelling model of segregation, formulated within the framework of statistical physics using a time-homogeneous Markov chain on a lattice. All parameters, initial conditions, and dynamics are specified unambiguously.\n\nThe solution requires the simulation of this Markov chain. The core of the methodology is outlined below.\n\n**1. System State and Initialization**\nThe system state is a configuration on a $2$-dimensional square lattice of linear size $N$. This is represented by an $N \\times N$ matrix, $\\mathbf{S}$, with periodic boundary conditions. Each site $(i,j)$ has a state $s_{i,j} \\in \\{-1, 0, +1\\}$, where $+1$ and $-1$ denote agents of two different types, and $0$ denotes an empty site.\n\nThe initial configuration is generated randomly, but with fixed numbers of each type of site. Given the total number of sites $N^2$, an empty-site fraction $f_{\\mathrm{empty}}$, and a plus-type fraction among occupied sites $f_{+}$, the counts are:\n- Number of empty sites: $N_{\\mathrm{empty}} = \\lfloor N^2 f_{\\mathrm{empty}} \\rfloor$\n- Number of occupied sites: $N_{\\mathrm{occ}} = N^2 - N_{\\mathrm{empty}}$\n- Number of type $+1$ agents: $N_{+} = \\lfloor N_{\\mathrm{occ}} f_{+} \\rfloor$\n- Number of type $-1$ agents: $N_{-} = N_{\\mathrm{occ}} - N_{+}$\n\nA $1$-dimensional array is created with these specified counts of $+1$, $-1$, and $0$ values. This array is shuffled using the provided pseudo-random seed and then reshaped into the $N \\times N$ matrix $\\mathbf{S}$, ensuring a uniform random placement of agents.\n\n**2. Agent Satisfaction and Neighborhood Analysis**\nThe dynamics are driven by agent dissatisfaction. The satisfaction of an agent at an occupied site $(i,j)$ is quantified by the satisfaction fraction $\\phi_{i,j}$. This is determined by its local environment within a Moore neighborhood of radius $r$. For each agent, we must compute the number of its occupied neighbors, $n_{i,j}^{\\mathrm{occ}}$, and the number of its neighbors of the same type, $n_{i,j}^{\\mathrm{like}}$. The satisfaction fraction is defined as:\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}},  \\text{if } n_{i,j}^{\\mathrm{occ}} > 0\\\\\n1,  \\text{if } n_{i,j}^{\\mathrm{occ}} = 0\n\\end{cases}\n$$\nAn agent is deemed unsatisfied if its satisfaction fraction is below a given threshold, i.e., $\\phi_{i,j}  \\tau$.\n\nTo compute the neighbor counts efficiently for all sites simultaneously, we employ $2$-dimensional convolution. We define binary indicator matrices for occupied sites ($\\mathbf{M}_{\\mathrm{occ}}$), type $+1$ sites ($\\mathbf{M}_{+}$), and type $-1$ sites ($\\mathbf{M}_{-}$). A convolution kernel $\\mathbf{K}$, a $(2r+1) \\times (2r+1)$ matrix of $1$s with a $0$ at its center, represents the neighborhood sum. The neighbor count maps are then given by the convolution operation (denoted by $*$) with periodic boundary handling:\n- Occupied neighbor count map: $\\mathbf{N}_{\\mathrm{occ}} = \\mathbf{M}_{\\mathrm{occ}} * \\mathbf{K}$\n- Type $+1$ neighbor map: $\\mathbf{N}_{+} = \\mathbf{M}_{+} * \\mathbf{K}$\n- Type $-1$ neighbor map: $\\mathbf{N}_{-} = \\mathbf{M}_{-} * \\mathbf{K}$\nFrom these maps, the $n_{i,j}^{\\mathrm{like}}$ value for each site is determined by its own type, and the matrix of $\\phi_{i,j}$ values is subsequently calculated.\n\n**3. Markov Chain Dynamics**\nThe system evolves over discrete time steps. The simulation proceeds for a maximum of $S_{\\max}$ steps. In each step:\n1.  The satisfaction of every agent is computed. The set of all coordinates of unsatisfied agents is identified.\n2.  If this set is empty, all agents are satisfied. The system has reached an absorbing state, and the simulation terminates. The total number of moves, $T$, is recorded.\n3.  If unsatisfied agents exist, one unsatisfied agent and one empty site are chosen uniformly at random from their respective sets of available locations.\n4.  The state of the chosen agent's site is swapped with the state of the chosen empty site. This constitutes one move, and the step counter $T$ is incremented.\n5.  If the simulation runs for the maximum number of steps without reaching an absorbing state, it terminates, and $T=S_{\\max}$.\n\n**4. Final Measurement**\nUpon termination, the final mean satisfaction fraction, $\\bar{\\phi}$, is calculated. This is the arithmetic mean of $\\phi_{i,j}$ over all occupied sites in the final grid configuration. The required outputs for each test case are the integer number of moves $T$ and the value of $\\bar{\\phi}$ rounded to three decimal places. The implementation performs this entire procedure for each test case specified in the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef run_simulation(N, f_empty, f_plus, tau, r, S_max, seed):\n    \"\"\"\n    Simulates Schelling's segregation model for a given set of parameters.\n\n    Args:\n        N (int): Linear size of the lattice.\n        f_empty (float): Fraction of empty sites.\n        f_plus (float): Fraction of +1 agents among occupied sites.\n        tau (float): Satisfaction threshold.\n        r (int): Radius of the Moore neighborhood.\n        S_max (int): Maximum number of simulation steps.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple[int, float]: A tuple containing the number of moves (T)\n                           and the mean satisfaction (phi_bar).\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n\n    N_total = N * N\n    N_empty = int(N_total * f_empty)\n    N_occ = N_total - N_empty\n    N_plus = int(N_occ * f_plus)\n    N_minus = N_occ - N_plus\n\n    # Create and shuffle the initial population on a 1D array\n    initial_flat_grid = np.array(\n        [1] * N_plus + [-1] * N_minus + [0] * N_empty, dtype=np.int8\n    )\n    rng.shuffle(initial_flat_grid)\n    grid = initial_flat_grid.reshape((N, N))\n\n    # Convolution kernel for Moore neighborhood\n    kernel = np.ones((2 * r + 1, 2 * r + 1), dtype=np.uint8)\n    kernel[r, r] = 0\n\n    T = 0\n    # 2. Main simulation loop\n    for _ in range(S_max):\n        occupied_mask = grid != 0\n        plus_mask = grid == 1\n        minus_mask = grid == -1\n\n        # Use convolution to find neighbor counts efficiently\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n        # Calculate satisfaction for all agents\n        # Default phi to 1, for agents with 0 occupied neighbors\n        phi_map = np.ones_like(grid, dtype=float)\n        \n        # Identify sites where phi needs to be calculated (occupied with neighbors)\n        calc_phi_mask = occupied_mask  (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n            \n            # Use errstate to prevent warnings on potential division by zero,\n            # though the mask should already prevent this.\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        unsatisfied_mask = occupied_mask  (phi_map  tau)\n        unsatisfied_coords = np.argwhere(unsatisfied_mask)\n\n        # Check for termination (absorbing state)\n        if len(unsatisfied_coords) == 0:\n            break\n\n        # 3. Perform a move\n        T += 1\n        empty_coords = np.argwhere(grid == 0)\n\n        # Choose one unsatisfied agent and one empty site uniformly at random\n        u_idx = rng.choice(len(unsatisfied_coords))\n        e_idx = rng.choice(len(empty_coords))\n\n        u_coords = tuple(unsatisfied_coords[u_idx])\n        e_coords = tuple(empty_coords[e_idx])\n\n        # Swap the agent and the empty site\n        grid[e_coords], grid[u_coords] = grid[u_coords], grid[e_coords]\n\n    # 4. Final calculation of mean satisfaction\n    occupied_mask = grid != 0\n    num_occupied = np.sum(occupied_mask)\n\n    if num_occupied == 0:\n        mean_phi = 0.0 # Should not happen based on problem constraints\n    else:\n        # Recalculate phi_map for the final configuration\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n        phi_map = np.ones_like(grid, dtype=float)\n        calc_phi_mask = occupied_mask  (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            plus_mask = grid == 1\n            minus_mask = grid == -1\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            \n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        total_phi = np.sum(phi_map[occupied_mask])\n        mean_phi = total_phi / num_occupied\n\n    return T, mean_phi\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, f_empty, f_plus, tau, r, S_max, seed)\n        (20, 0.1, 0.5, 0.5, 1, 20000, 1),\n        (15, 0.2, 0.5, 0.0, 1, 20000, 2),\n        (20, 0.2, 0.5, 0.9, 1, 20000, 3),\n        (5, 0.2, 0.5, 0.6, 1, 20000, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, f_empty, f_plus, tau, r, S_max, seed = case\n        T, phi_bar = run_simulation(N, f_empty, f_plus, tau, r, S_max, seed)\n        results.append(f\"[{T}, {phi_bar:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world landscapes are not uniform; they contain fixed features that influence behavior. This next practice extends the basic model by introducing immobile \"influencer\" agents, which act as spatial anchors for segregation. You will implement a deterministic best-response dynamic and develop metrics to quantify the \"anchoring lift\" these influencers provide . This exercise challenges you to think about how heterogeneity and fixed structures can fundamentally alter a model's emergent patterns.",
            "id": "2428488",
            "problem": "Consider a two-type Schelling segregation model on a finite two-dimensional discrete lattice with immobile \"influencer\" agents. The lattice is an $n \\times n$ grid with toroidal boundary conditions (wrap-around on both axes). Each site holds either an empty cell (coded $0$), a type $1$ agent (coded $1$), or a type $2$ agent (coded $2$). A subset of agents are influencers: they have a fixed type and fixed positions and never move; non-influencer agents may move. Neighborhoods are of Moore type with radius $1$ under toroidal geometry: each cell has $8$ neighbors (all cells whose Chebyshev distance is exactly $1$ on the torus). For any occupied cell at coordinates $(i,j)$ with agent type $s \\in \\{1,2\\}$, define its local same-type fraction as\n$$\nf_s(i,j) \\equiv \n\\begin{cases}\n\\frac{\\text{number of occupied neighbors of type } s}{\\text{number of occupied neighbors}},  \\text{if the number of occupied neighbors} > 0,\\\\\n1,  \\text{if the number of occupied neighbors} = 0.\n\\end{cases}\n$$\nAn agent is satisfied if $f_s(i,j) \\ge \\tau$, where $\\tau \\in [0,1]$ is the common tolerance.\n\nInitialization: For given integers $N_1 \\ge 0$ and $N_2 \\ge 0$ with $N_1 + N_2 \\le n^2$, place all influencers first at their specified coordinates with their specified types (they count toward the totals $N_1$ or $N_2$). Then, fill the remaining $N_1 + N_2 - (\\text{number of influencers})$ non-influencer agents in row-major order (increasing row index $i$, breaking ties by increasing column index $j$), skipping already occupied influencer cells. The non-influencer agents are placed by alternating types $1,2,1,2,\\dots$ starting with type $1$, subject to the remaining counts of each type: when the remaining count of the current type is zero, switch to the other type; continue until all required agents are placed. All remaining cells are empty.\n\nDynamics: Only non-influencer agents may move. The dynamics proceed in discrete sweeps indexed by $t = 1,2,\\dots$, each sweep iterating over all grid coordinates in row-major order. During a sweep, whenever a non-influencer agent of type $s$ at $(i,j)$ is encountered, compute its current $f_s(i,j)$. If $f_s(i,j) \\ge \\tau$, it does not move. If $f_s(i,j)  \\tau$, consider all currently empty cells as potential destinations; for each empty cell, evaluate the same-type fraction the agent of type $s$ would have if placed at that destination, under the state where the agent’s current cell $(i,j)$ is vacated prior to evaluation. The agent selects the destination that maximizes this fraction; if there are multiple maximizers, choose the lexicographically smallest coordinates (smallest row, then smallest column). The agent moves if and only if the maximal destination fraction is strictly greater than its current $f_s(i,j)$. Influencers never move. A sweep ends after all coordinates are processed; the process stops when a full sweep occurs with no movements, or when a specified maximum number of sweeps $T_{\\max}$ is reached.\n\nSegregation metrics after termination: Let $H$ denote the global mean homophily,\n$$\nH \\equiv \\frac{1}{M}\\sum_{(i,j)\\ \\text{occupied}} f_{s(i,j)}(i,j),\n$$\nwhere $M$ is the number of occupied cells and $s(i,j)\\in\\{1,2\\}$ is the type at $(i,j)$. For each influencer $k$ of type $s_k$ at position $(i_k,j_k)$, and a given neighborhood radius $r \\in \\mathbb{N}$, define the influencer’s local same-type share $L_k$ as the fraction of occupied cells within Chebyshev distance at most $r$ on the torus from $(i_k,j_k)$ that are of type $s_k$ (include the influencer’s own cell in both numerator and denominator). Let $G_{s}$ be the global share of type $s$ among all occupied cells, i.e.,\n$$\nG_s \\equiv \\frac{\\text{number of occupied cells of type } s}{M}.\n$$\nDefine the anchoring lift of influencer $k$ as $L_k - G_{s_k}$. For each test case below, define the test-case result as the arithmetic mean of the anchoring lifts across its influencers. If a test case has zero influencers, define its result to be $H$.\n\nImplement the model exactly as defined above and compute, for each test case, the test-case result. Use Chebyshev distance and toroidal wrap-around consistently for all neighborhood and radius calculations. All coordinates are zero-indexed with rows and columns in $\\{0,1,\\dots,n-1\\}$.\n\nTest suite:\n- Case A (general case): $n=10$, tolerance $\\tau=0.5$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(45,45)$, influencers: two type $1$ influencers at $(0,0)$ and $(9,9)$.\n- Case B (central anchors of the other type): $n=10$, tolerance $\\tau=0.5$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(45,45)$, influencers: two type $2$ influencers at $(5,5)$ and $(5,6)$.\n- Case C (higher tolerance boundary): $n=10$, tolerance $\\tau=0.75$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(50,40)$, influencers: one type $1$ influencer at $(0,0)$ and one type $2$ influencer at $(0,9)$.\n- Case D (no vacancies edge case): $n=10$, tolerance $\\tau=0.5$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(50,50)$, influencers: one type $1$ influencer at $(5,5)$.\n\nFinal output format: Your program should produce a single line of output containing the results for Cases A through D in that order as a comma-separated list of four real numbers enclosed in square brackets, with each number rounded to exactly four digits after the decimal point (e.g., [$x_A$,$x_B$,$x_C$,$x_D$]).",
            "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Lattice:** $n \\times n$ grid with toroidal boundary conditions.\n- **Cell States:** Empty ($0$), Type $1$ ($1$), Type $2$ ($2$).\n- **Agent Types:** Mobile non-influencers and immobile influencers with fixed positions and types.\n- **Neighborhood:** Moore, radius $1$, toroidal geometry ($8$ neighbors).\n- **Local Same-Type Fraction ($f_s(i,j)$):** For an agent of type $s$ at $(i,j)$, the fraction of its occupied neighbors that are of type $s$. If there are no occupied neighbors, $f_s(i,j) = 1$.\n- **Satisfaction:** Agent is satisfied if $f_s(i,j) \\ge \\tau$.\n- **Initialization:** Place influencers first. Then, fill remaining agents ($N_1$, $N_2$ total) in row-major order, alternating types ($1,2,1,2,\\dots$) but using the other type if the preferred one is exhausted.\n- **Dynamics:** Sweeps iterate over the grid in row-major order. Unsatisfied non-influencers evaluate all empty cells as potential destinations. A move to the destination that maximizes the hypothetical same-type fraction occurs only if this maximum is strictly greater than the current fraction. Tie-breaking for destinations is lexicographical. Grid updates are sequential within a sweep.\n- **Termination:** Stop after a sweep with zero moves or after $T_{\\max}$ sweeps.\n- **Metrics:**\n  - $H$: Global mean homophily.\n  - $L_k$: For influencer $k$ of type $s_k$, the fraction of same-type agents within a Chebyshev distance $r$ on the torus.\n  - $G_s$: Global fraction of agents of type $s$.\n  - Anchoring Lift: $L_k - G_{s_k}$.\n- **Test-Case Result:** The arithmetic mean of anchoring lifts for all influencers. If no influencers, the result is $H$.\n- **Test Cases:**\n  - A: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$, influencers: two type $1$ at $(0,0), (9,9)$.\n  - B: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$, influencers: two type $2$ at $(5,5), (5,6)$.\n  - C: $n=10, \\tau=0.75, T_{\\max}=200, r=2, (N_1,N_2)=(50,40)$, influencers: one type $1$ at $(0,0)$, one type $2$ at $(0,9)$.\n  - D: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(50,50)$, influencer: one type $1$ at $(5,5)$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem describes a variant of Schelling's segregation model, a canonical model in computational social science. The rules are extensions of the standard model and are scientifically coherent.\n2.  **Well-Posed:** The problem is deterministic. The initialization rules, agent dynamics, and tie-breaking procedures are specified unambiguously, guaranteeing a unique evolution of the system from a given initial state. Termination is guaranteed.\n3.  **Objective:** The problem is stated in precise, mathematical, and algorithmic terms, free of any subjectivity.\n4.  **Completeness:** All necessary parameters ($n$, $\\tau$, $N_1$, $N_2$, $T_{\\max}$, $r$, influencer details) are provided. The rules for all special cases (e.g., zero occupied neighbors, no empty cells) are logically consistent with the overall framework.\n5.  **Structure:** The problem is well-structured and poses a clear computational task.\n\n### Step 3: Verdict and Action\nThe problem is valid. The premises are sound, and the specifications are complete and unambiguous. We proceed with the construction of a solution.\n\nThe solution is a direct simulation of the described agent-based model. The implementation is structured into three principal components: grid initialization, simulation of agent dynamics, and calculation of the final segregation metrics.\n\n**1. Grid Initialization**\n\nThe $n \\times n$ lattice is represented by a two-dimensional integer array. A parallel boolean array is used to flag influencer locations.\n- The process begins by creating an $n \\times n$ grid initialized to state $0$ (empty).\n- Influencers are placed at their specified coordinates $(i,j)$ with their given types $s \\in \\{1,2\\}$. The corresponding entries in the influencer flag array are set to true. The total counts of agents to be placed, $N_1$ and $N_2$, are decremented accordingly.\n- The remaining non-influencer agents are placed in the vacant cells by iterating through the grid in row-major order (from $(0,0)$ to $(n-1, n-1)$). Agent types are assigned by following an alternating sequence $1, 2, 1, 2, \\dots$. If the count for the designated type in the sequence is exhausted, the other type is placed instead. The sequence then continues its alternation for the next available cell. This process continues until all $N_1$ and $N_2$ agents are on the grid.\n\n**2. Simulation of Dynamics**\n\nThe simulation proceeds in discrete sweeps, up to a maximum of $T_{\\max}$.\n- Each sweep consists of a single pass over all grid cells $(i,j)$ in row-major order.\n- At each cell, if it contains a non-influencer agent of type $s$, its local same-type fraction $f_s(i,j)$ is calculated.\n- If the agent is unsatisfied, i.e., $f_s(i,j)  \\tau$, a search for a new location is initiated.\n  - The set of potential destinations comprises all currently empty cells on the grid.\n  - For each potential destination, a hypothetical same-type fraction is calculated. This is the fraction the agent would experience if it moved there. The calculation is performed on a hypothetical grid copy where the agent's original cell $(i,j)$ has been vacated.\n  - The agent identifies the destination that yields the maximum hypothetical fraction. Ties are broken by selecting the destination with the lexicographically smallest coordinates.\n  - A move is executed only if this maximal destination fraction is strictly greater than the agent's current fraction $f_s(i,j)$.\n- If a move occurs, the grid is updated immediately: the agent's type is placed in the new cell, and its original cell becomes empty. This updated grid state is used for all subsequent agent evaluations within the same sweep.\n- The simulation terminates if a full sweep completes with no agent movements, or if $T_{\\max}$ sweeps are completed.\n\n**3. Metric Calculation**\n\nAfter the simulation terminates, the final test-case result is computed from the final grid configuration.\n- For each test case, which contains influencers, the result is the arithmetic mean of the anchoring lifts of all influencers.\n- The anchoring lift for an influencer $k$ of type $s_k$ is $L_k - G_{s_k}$.\n- $G_{s_k}$ is the global share of agents of type $s_k$, given by $G_{s_k} = \\frac{N_{s_k}}{N_1 + N_2}$.\n- $L_k$ is the influencer's local same-type share. To compute it, we consider a square neighborhood of radius $r$ around the influencer at $(i_k,j_k)$ using the toroidal Chebyshev distance. $L_k$ is the ratio of the number of occupied cells of type $s_k$ within this neighborhood to the total number of occupied cells within the same neighborhood. The influencer's own cell is included in both counts.\n\nThis detailed algorithmic procedure ensures a faithful implementation of the model as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Schelling segregation model for the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((0, 0), 1), ((9, 9), 1)]},\n        # Case B\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((5, 5), 2), ((5, 6), 2)]},\n        # Case C\n        {'n': 10, 'tau': 0.75, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 40, \n         'influencers': [((0, 0), 1), ((0, 9), 2)]},\n        # Case D\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 50, \n         'influencers': [((5, 5), 1)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    print(f\"[{','.join([f'{x:.4f}' for x in results])}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case from initialization to final metric calculation.\n    \"\"\"\n    n, N1, N2, tau, T_max, r = params['n'], params['N1'], params['N2'], params['tau'], params['T_max'], params['r']\n    influencers = params['influencers']\n\n    grid, is_influencer, influencer_info = initialize_grid(n, N1, N2, influencers)\n    final_grid = run_simulation(grid, is_influencer, n, tau, T_max)\n    metric = calculate_metrics(final_grid, N1, N2, influencer_info, n, r)\n    \n    return metric\n\ndef get_moore_neighbors(r, c, n):\n    \"\"\"Gets Moore neighborhood coordinates with toroidal boundary.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = (r + dr) % n, (c + dc) % n\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef calculate_homophily(grid, r, c, agent_type, n):\n    \"\"\"\n    Calculates the local same-type fraction for an agent of `agent_type` at (r,c).\n    \"\"\"\n    neighbors = get_moore_neighbors(r, c, n)\n    same_type_neighbors = 0\n    occupied_neighbors = 0\n    \n    for nr, nc in neighbors:\n        neighbor_type = grid[nr, nc]\n        if neighbor_type > 0:\n            occupied_neighbors += 1\n            if neighbor_type == agent_type:\n                same_type_neighbors += 1\n    \n    if occupied_neighbors == 0:\n        return 1.0\n    return same_type_neighbors / occupied_neighbors\n\ndef initialize_grid(n, N1, N2, influencers):\n    \"\"\"Initializes the grid according to the problem statement.\"\"\"\n    grid = np.zeros((n, n), dtype=int)\n    is_influencer = np.zeros((n, n), dtype=bool)\n    \n    rem_N1, rem_N2 = N1, N2\n    influencer_info = []\n\n    for pos, type in influencers:\n        grid[pos] = type\n        is_influencer[pos] = True\n        influencer_info.append((pos, type))\n        if type == 1:\n            rem_N1 -= 1\n        else:\n            rem_N2 -= 1\n            \n    next_type_in_sequence = 1\n    for r in range(n):\n        for c in range(n):\n            if rem_N1 == 0 and rem_N2 == 0:\n                break\n            if grid[r, c] == 0:\n                type_to_place = 0\n                if next_type_in_sequence == 1:\n                    if rem_N1 > 0:\n                        type_to_place = 1\n                    elif rem_N2 > 0:\n                        type_to_place = 2\n                else: \n                    if rem_N2 > 0:\n                        type_to_place = 2\n                    elif rem_N1 > 0:\n                        type_to_place = 1\n                \n                if type_to_place == 1:\n                    grid[r, c] = 1\n                    rem_N1 -= 1\n                elif type_to_place == 2:\n                    grid[r, c] = 2\n                    rem_N2 -= 1\n                \n                next_type_in_sequence = 3 - next_type_in_sequence\n        if rem_N1 == 0 and rem_N2 == 0:\n            break\n            \n    return grid, is_influencer, influencer_info\n\ndef run_simulation(grid, is_influencer, n, tau, T_max):\n    \"\"\"Runs the Schelling model simulation with sequential updates.\"\"\"\n    current_grid = grid.copy()\n    for _ in range(T_max):\n        moved_in_sweep = False\n        for r in range(n):\n            for c in range(n):\n                agent_type = current_grid[r, c]\n                if agent_type > 0 and not is_influencer[r, c]:\n                    current_f = calculate_homophily(current_grid, r, c, agent_type, n)\n                    \n                    if current_f  tau:\n                        empty_cells = list(zip(*np.where(current_grid == 0)))\n                        if not empty_cells:\n                            continue\n\n                        max_f = -1.0\n                        best_dest = None\n                        \n                        hypothetical_grid = current_grid.copy()\n                        hypothetical_grid[r, c] = 0\n\n                        for dest_r, dest_c in empty_cells:\n                            f_dest = calculate_homophily(hypothetical_grid, dest_r, dest_c, agent_type, n)\n                            if f_dest > max_f:\n                                max_f = f_dest\n                                best_dest = (dest_r, dest_c)\n                            elif f_dest == max_f:\n                                if best_dest is not None and (dest_r, dest_c)  best_dest:\n                                    best_dest = (dest_r, dest_c)\n                        \n                        if best_dest is not None and max_f > current_f:\n                            current_grid[best_dest] = agent_type\n                            current_grid[r, c] = 0\n                            moved_in_sweep = True\n                            \n        if not moved_in_sweep:\n            break\n            \n    return current_grid\n\ndef torus_chebyshev_dist(p1, p2, n):\n    \"\"\"Calculates Chebyshev distance on an n x n torus.\"\"\"\n    dr = abs(p1[0] - p2[0])\n    dc = abs(p1[1] - p2[1])\n    torus_dr = min(dr, n - dr)\n    torus_dc = min(dc, n - dc)\n    return max(torus_dr, torus_dc)\n\ndef calculate_metrics(final_grid, N1, N2, influencer_info, n, r):\n    \"\"\"Calculates the final test-case result (mean anchoring lift).\"\"\"\n    M = N1 + N2\n    if M == 0: return 0.0\n\n    if not influencer_info: # This case is not in the test suite but handled for completeness\n        total_homophily = 0.0\n        occupied_coords = np.argwhere(final_grid > 0)\n        for r_occ, c_occ in occupied_coords:\n            agent_type = final_grid[r_occ, c_occ]\n            total_homophily += calculate_homophily(final_grid, r_occ, c_occ, agent_type, n)\n        return total_homophily / M\n    \n    lifts = []\n    G1 = N1 / M\n    G2 = N2 / M\n    G_map = {1: G1, 2: G2}\n\n    for inf_pos, inf_type in influencer_info:\n        local_same_count = 0\n        local_total_count = 0\n        for r_cell in range(n):\n            for c_cell in range(n):\n                if torus_chebyshev_dist(inf_pos, (r_cell, c_cell), n) = r:\n                    cell_type = final_grid[r_cell, c_cell]\n                    if cell_type > 0:\n                        local_total_count += 1\n                        if cell_type == inf_type:\n                            local_same_count += 1\n        \n        Lk = local_same_count / local_total_count if local_total_count > 0 else 0.0\n        Gs_k = G_map[inf_type]\n        lift = Lk - Gs_k\n        lifts.append(lift)\n        \n    return np.mean(lifts)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond observing segregation, economists are often interested in how to mitigate it. This final practice reframes the Schelling model from a descriptive simulation to a prescriptive optimization problem. Here, you take on the role of a central planner with a limited budget, tasked with finding the optimal set of agent relocations to minimize a global segregation index . This exercise will introduce you to the computational challenges of policy intervention and the shift from simulating \"what is\" to optimizing for \"what should be.\"",
            "id": "2428437",
            "problem": "Consider a finite Schelling-type environment on a square lattice. Let $n \\in \\mathbb{N}$ denote the grid side length, and consider a configuration $X \\in \\{0,1,2\\}^{n \\times n}$ where $0$ denotes an empty cell, $1$ denotes a type $A$ agent, and $2$ denotes a type $B$ agent. Two cells are neighbors if they are at Manhattan distance $1$ (von Neumann neighborhood), with no wrap-around at the boundary.\n\nDefine the set of unordered adjacent pairs\n$$\n\\mathcal{E} \\;=\\; \\left\\{ \\{(i,j),(i',j')\\} \\;:\\; |i-i'| + |j-j'| = 1,\\; 1 \\le i,i' \\le n,\\; 1 \\le j,j' \\le n \\right\\}.\n$$\nThe global segregation of a configuration $X$ is defined by\n$$\nS(X) \\;=\\; \\begin{cases}\n\\dfrac{\\displaystyle \\sum_{\\{u,v\\} \\in \\mathcal{E}} \\mathbf{1}\\left[X(u) \\in \\{1,2\\},\\, X(v) \\in \\{1,2\\},\\, X(u) = X(v)\\right]}{\\displaystyle \\sum_{\\{u,v\\} \\in \\mathcal{E}} \\mathbf{1}\\left[X(u) \\in \\{1,2\\},\\, X(v) \\in \\{1,2\\}\\right]}  \\text{if the denominator is } > 0,\\\\[2ex]\n0  \\text{if the denominator is } 0,\n\\end{cases}\n$$\nwhere $X(u)$ is the entry of $X$ at cell $u$ and $\\mathbf{1}[\\cdot]$ is the indicator function. Thus $S(X) \\in [0,1]$ is the fraction (in decimal form) of adjacent occupied pairs that are of the same type.\n\nA central planner can intervene by relocating agents subject to a budget. A relocation intervention is defined as follows. Let $E_0 \\subset \\{1,\\dots,n\\} \\times \\{1,\\dots,n\\}$ be the set of empty cells in the initial configuration $X$. For a given nonnegative integer budget $k \\in \\mathbb{N}$, the planner may choose a subset of agents of cardinality at most $k$ and relocate each chosen agent to a distinct cell in $E_0$. Each chosen agent is relocated at most once. Cells vacated by relocated agents become empty. All agents not chosen remain in their original cells. The planner’s objective is to minimize $S(X')$ over all configurations $X'$ reachable from $X$ under these constraints, with at most $k$ agents relocated and all destinations belonging to $E_0$.\n\nTask. For each test case below, compute the minimal attainable global segregation\n$$\nS^{\\star} \\;=\\; \\min \\{ S(X') \\;:\\; X' \\text{ is reachable from } X \\text{ by relocating at most } k \\text{ agents to distinct cells in } E_0 \\}.\n$$\nReport $S^{\\star}$ as a decimal rounded to exactly $4$ digits after the decimal point.\n\nTest suite. Use the following four test cases. In each, $X^{(t)}$ is specified by a matrix and $k^{(t)}$ is the budget.\n\n- Test case $1$: $n=2$, \n$$\nX^{(1)} \\;=\\; \\begin{bmatrix}\n1  1\\\\\n2  2\n\\end{bmatrix}, \\quad k^{(1)} \\;=\\; 1.\n$$\n\n- Test case $2$: $n=3$,\n$$\nX^{(2)} \\;=\\; \\begin{bmatrix}\n1  1  0\\\\\n2  2  0\\\\\n0  0  0\n\\end{bmatrix}, \\quad k^{(2)} \\;=\\; 2.\n$$\n\n- Test case $3$: $n=3$,\n$$\nX^{(3)} \\;=\\; \\begin{bmatrix}\n1  1  1\\\\\n1  0  2\\\\\n2  2  2\n\\end{bmatrix}, \\quad k^{(3)} \\;=\\; 1.\n$$\n\n- Test case $4$: $n=2$,\n$$\nX^{(4)} \\;=\\; \\begin{bmatrix}\n1  0\\\\\n0  0\n\\end{bmatrix}, \\quad k^{(4)} \\;=\\; 1.\n$$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and in the same order as the test cases, with each number rounded to exactly $4$ digits after the decimal point, for example, `[a,b,c,d]` where $a$, $b$, $c$, and $d$ are the rounded values for test cases $1$ through $4$ respectively.",
            "solution": "The problem posed is a well-defined exercise in combinatorial optimization, set within the context of Schelling's segregation model. Before proceeding to a solution, we must validate its premises.\n\n**Problem Validation**\n\n**Step 1: Extracted Givens**\n- A square lattice of side length $n \\in \\mathbb{N}$.\n- A configuration $X \\in \\{0, 1, 2\\}^{n \\times n}$, where $0$ is an empty cell, $1$ is an agent of type A, and $2$ is an agent of type B.\n- A von Neumann neighborhood defines adjacency (Manhattan distance of $1$) without wrap-around boundaries.\n- The set of unordered adjacent pairs (edges in the grid graph) is $\\mathcal{E}$.\n- The global segregation index $S(X)$ is defined as the fraction of adjacent occupied cell pairs that contain agents of the same type. If no such pairs exist, $S(X) = 0$.\n- An intervention consists of relocating a set of at most $k$ agents to distinct, initially empty cells ($E_0$).\n- The objective is to find the minimum segregation index $S^{\\star}$ over all configurations reachable from an initial configuration $X$ with a budget of at most $k$ relocations.\n- Four test cases are provided, each specifying an initial configuration matrix $X^{(t)}$ and a budget $k^{(t)}$.\n\n**Step 2: Validation of Givens**\nThe problem is assessed against the required criteria:\n- **Scientifically Grounded:** The problem is based on Schelling's model, a cornerstone of agent-based computational economics. The optimization task is a standard formulation in operations research and computer science. The problem is scientifically and mathematically sound.\n- **Well-Posed:** The objective function $S(X)$ is clearly defined. The set of allowed actions (relocations) is finite and explicitly constrained. The task is to find the minimum of a function over a finite set of states; a minimum is guaranteed to exist.\n- **Objective:** The problem is stated in precise mathematical language, free from subjectivity or ambiguity.\n- **Completeness and Consistency:** All necessary parameters ($n, X, k$) are provided for each test case. The rules for relocation are unambiguous: agents are moved to cells that were empty in the initial state $X$, and the destinations must be distinct. The setup is self-contained and consistent.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. It is a well-posed, scientifically grounded optimization problem. A solution will be derived.\n\n**Methodology**\n\nThe problem asks for the minimum segregation index $S^{\\star}$ achievable by relocating at most $k$ agents. Since the number of agents and empty cells in the provided test cases is small, we can solve this problem by an exhaustive search over all valid relocation strategies. A relocation strategy is defined by three choices:\n1. The number of agents to move, $m$, where $0 \\le m \\le k$.\n2. The specific set of $m$ agents to be relocated.\n3. The specific set of $m$ distinct destination cells, chosen from the initially empty cells $E_0$.\n4. The bijective mapping between the chosen agents and the chosen destination cells.\n\nThe algorithm proceeds as follows:\nFirst, we define a function to compute the segregation index $S(X')$ for any given grid configuration $X'$. This function iterates through all adjacent cell pairs $\\{u, v\\} \\in \\mathcal{E}$, counts the total number of occupied pairs (denominator) and the number of same-type occupied pairs (numerator), and returns their ratio. For clarity, we use 0-based indexing for grid coordinates $(r, c)$.\n\nThe main algorithm for each test case $(X, k)$ is:\n1.  Initialize $S^{\\star}$ with the segregation of the initial configuration, $S(X)$.\n2.  Identify the set of all agents with their positions and types, and the set of all initially empty cells, $E_0$.\n3.  Iterate through the number of agents to move, $m$, from $1$ to $\\min(k, |\\text{agents}|, |E_0|)$.\n4.  For each $m$, generate all combinations of $m$ agents to be relocated.\n5.  For each combination of agents, generate all combinations of $m$ destination cells from $E_0$.\n6.  For each pair of agent/destination combinations, generate all $m!$ possible one-to-one mappings (permutations) of the chosen agents to the chosen destinations.\n7.  For each such mapping, construct the resulting new grid configuration $X'$.\n8.  Calculate $S(X')$ and update $S^{\\star} = \\min(S^{\\star}, S(X'))$.\n\nThis brute-force approach guarantees finding the optimal solution as it explores the entire space of reachable configurations. We now apply this procedure to each test case.\n\n**Analysis of Test Cases**\n\n**Test Case 1:** $n=2$, $X^{(1)} = \\begin{pmatrix} 1  1 \\\\ 2  2 \\end{pmatrix}$, $k^{(1)}=1$.\n- The grid has no empty cells ($E_0 = \\emptyset$).\n- Relocation is impossible. The only reachable configuration is $X^{(1)}$ itself (a move of $m=0$ agents).\n- We compute $S(X^{(1)})$. The grid has $4$ adjacent occupied pairs:\n  - Horizontal: $\\{(0,0), (0,1)\\}$ (type $1$-$1$, same), $\\{(1,0), (1,1)\\}$ (type $2$-$2$, same).\n  - Vertical: $\\{(0,0), (1,0)\\}$ (type $1$-$2$, different), $\\{(0,1), (1,1)\\}$ (type $1$-$2$, different).\n- The number of same-type pairs is $2$. The total number of occupied pairs is $4$.\n- $S(X^{(1)}) = 2/4 = 0.5$.\n- Thus, $S^{\\star} = 0.5$.\n\n**Test Case 2:** $n=3$, $X^{(2)} = \\begin{pmatrix} 1  1  0 \\\\ 2  2  0 \\\\ 0  0  0 \\end{pmatrix}$, $k^{(2)}=2$.\n- The grid contains $2$ agents of type $A$ at $\\{(0,0), (0,1)\\}$, $2$ agents of type $B$ at $\\{(1,0), (1,1)\\}$, and $5$ empty cells. The budget is $k=2$.\n- The initial segregation is $S(X^{(2)}) = 2/4 = 0.5$.\n- We seek to minimize $S(X')$. The ideal configuration to minimize segregation is one where no two agents of the same type are adjacent.\n- Consider relocating $m=2$ agents. We can choose to move one agent of type $A$ and one of type $B$. For example, move agent $A$ from $(0,0)$ and agent $B$ from $(1,0)$. The remaining agents are $A$ at $(0,1)$ and $B$ at $(1,1)$.\n- The available destinations are $E_0 = \\{(0,2), (1,2), (2,0), (2,1), (2,2)\\}$.\n- Let's place the moved $A$ at $(2,0)$ and the moved $B$ at $(2,2)$. The new configuration $X'$ has agents at positions: $A$ at $\\{(0,1), (2,0)\\}$ and $B$ at $\\{(1,1), (2,2)\\}$.\n- Let's analyze adjacencies in $X'$:\n  - $A$ at $(0,1)$ is adjacent to $B$ at $(1,1)$. This is one different-type pair.\n  - No other agents are adjacent.\n- The total number of adjacent occupied pairs is $1$. The number of same-type pairs is $0$.\n- The new segregation is $S(X')=0/1=0$.\n- Since $0$ is the minimum possible value for $S$, we have $S^{\\star} = 0.0$.\n\n**Test Case 3:** $n=3$, $X^{(3)} = \\begin{pmatrix} 1  1  1 \\\\ 1  0  2 \\\\ 2  2  2 \\end{pmatrix}$, $k^{(3)}=1$.\n- The grid has one empty cell at $(1,1)$. The budget is $k=1$.\n- Any valid relocation must move one agent to the cell $(1,1)$. We must choose which of the $8$ agents to move to minimize $S$.\n- Initial segregation $S(X^{(3)})$:\n  - Edges in the grid graph not involving $(1,1)$ are $8$. So the denominator is $8$.\n  - Same-type pairs (numerator): $\\{(0,0), (0,1)\\}_{AA}$, $\\{(0,1), (0,2)\\}_{AA}$, $\\{(0,0), (1,0)\\}_{AA}$, $\\{(1,2), (2,2)\\}_{BB}$, $\\{(2,0), (2,1)\\}_{BB}$, $\\{(2,1), (2,2)\\}_{BB}$. Total is $6$.\n  - $S(X^{(3)}) = 6/8 = 0.75$.\n- A move consists of choosing an agent at position $p$, making $p$ empty, and placing that agent's type at $(1,1)$.\n- The new cell $(1,1)$ becomes adjacent to $A$ at $(0,1)$, $A$ at $(1,0)$, $B$ at $(1,2)$, and $B$ at $(2,1)$.\n- Let $N_{same}$ and $N_{total}$ be the numerator and denominator of $S(X)$. When an agent at $p$ with $n_s(p)$ same-type neighbors and $n_d(p)$ different-type neighbors is moved to $(1,1)$:\n  - The change at $p$ is $\\Delta N_{same} = -n_s(p)$, $\\Delta N_{total} = -(n_s(p)+n_d(p))$.\n  - If a type $A$ agent moves to $(1,1)$, it creates $2$ same-type pairs and $2$ different-type pairs. So, $\\Delta N_{same} = +2$, $\\Delta N_{total} = +4$.\n  - If a type $B$ agent moves to $(1,1)$, it creates $2$ same-type pairs and $2$ different-type pairs. So, $\\Delta N_{same} = +2$, $\\Delta N_{total} = +4$.\n- The new score is $S' = \\frac{N_{same} - n_s(p) + 2}{N_{total} - (n_s(p)+n_d(p)) + 4} = \\frac{6 - n_s(p) + 2}{8 - (n_s(p)+n_d(p)) + 4} = \\frac{8 - n_s(p)}{12 - n_s(p) - n_d(p)}$.\n- To minimize $S'$, we should maximize $n_s(p)$.\n- We analyze the neighbors of each agent in $X^{(3)}$:\n  - Agents at $(0,0), (0,1), (2,1), (2,2)$ each have $n_s=2, n_d=0$.\n  - Agents at $(0,2), (1,0), (1,2), (2,0)$ each have $n_s=1, n_d=1$.\n- Choosing an agent with $n_s=2, n_d=0$ (e.g., agent $A$ at $(0,0)$):\n  - $S' = \\frac{8-2}{12-2-0} = \\frac{6}{10} = 0.6$.\n- Choosing an agent with $n_s=1, n_d=1$ (e.g., agent $A$ at $(0,2)$):\n  - $S' = \\frac{8-1}{12-1-1} = \\frac{7}{10} = 0.7$.\n- The minimum attainable segregation is $S^{\\star} = 0.6$.\n\n**Test Case 4:** $n=2$, $X^{(4)} = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}$, $k^{(4)}=1$.\n- The grid contains only one agent. There are no pairs of adjacent occupied cells.\n- The denominator for $S(X^{(4)})$ is $0$. By the problem definition, $S(X^{(4)}) = 0$.\n- With a budget of $k=1$, we can move this single agent to any of the $3$ empty cells.\n- Any resulting configuration $X'$ will also contain only one agent. The segregation index $S(X')$ will therefore always be $0$.\n- The minimal attainable segregation is $S^{\\star} = 0.0$.",
            "answer": "```python\n# Final answer must be a single, complete, standalone program.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the Schelling segregation optimization problem\n    for the given test suite.\n    \"\"\"\n\n    def calculate_s(grid: np.ndarray) -> float:\n        \"\"\"\n        Calculates the global segregation index S(X) for a given grid configuration.\n        \"\"\"\n        n = grid.shape[0]\n        same_type_pairs = 0\n        total_pairs = 0\n\n        # Iterate over all cells and check right and down neighbors to count each edge once.\n        for r in range(n):\n            for c in range(n):\n                # Skip empty cells\n                if grid[r, c] == 0:\n                    continue\n\n                # Check neighbor to the right\n                if c + 1  n:\n                    if grid[r, c + 1] != 0:\n                        total_pairs += 1\n                        if grid[r, c] == grid[r, c + 1]:\n                            same_type_pairs += 1\n                \n                # Check neighbor below\n                if r + 1  n:\n                    if grid[r + 1, c] != 0:\n                        total_pairs += 1\n                        if grid[r, c] == grid[r + 1, c]:\n                            same_type_pairs += 1\n\n        if total_pairs == 0:\n            return 0.0\n        \n        return same_type_pairs / total_pairs\n\n    def solve_case(X_initial: list, k: int) -> float:\n        \"\"\"\n        Solves a single test case by exhaustively searching all valid relocations.\n        \"\"\"\n        X_initial_np = np.array(X_initial, dtype=int)\n        n = X_initial_np.shape[0]\n        \n        min_s = calculate_s(X_initial_np)\n        \n        agents = []\n        empty_cells = []\n        for r in range(n):\n            for c in range(n):\n                if X_initial_np[r, c] != 0:\n                    agents.append(((r, c), X_initial_np[r, c]))  # ((pos), type)\n                else:\n                    empty_cells.append((r, c))\n\n        num_agents = len(agents)\n        num_empty = len(empty_cells)\n        \n        # Number of agents to move, m\n        max_moves = min(k, num_agents, num_empty)\n        \n        for m in range(1, max_moves + 1):\n            # Iterate through all combinations of agents to move\n            for agents_to_move in itertools.combinations(agents, m):\n                stationary_agents = set(agents) - set(agents_to_move)\n\n                # Iterate through all combinations of destination cells\n                for dest_cells in itertools.combinations(empty_cells, m):\n                    # Iterate through all possible assignments of agents to destinations\n                    for perm_agents in itertools.permutations(agents_to_move):\n                        \n                        X_prime = np.zeros_like(X_initial_np)\n                        \n                        # Place stationary agents\n                        for pos, agent_type in stationary_agents:\n                            X_prime[pos] = agent_type\n                            \n                        # Place moved agents in their new destinations\n                        for i in range(m):\n                            agent_info = perm_agents[i]\n                            dest_pos = dest_cells[i]\n                            X_prime[dest_pos] = agent_info[1] # agent_info[1] is the type\n                        \n                        s_prime = calculate_s(X_prime)\n                        if s_prime  min_s:\n                            min_s = s_prime\n        \n        return min_s\n\n    test_cases = [\n        (\n            [[1, 1], \n             [2, 2]], \n            1\n        ),\n        (\n            [[1, 1, 0], \n             [2, 2, 0], \n             [0, 0, 0]], \n            2\n        ),\n        (\n            [[1, 1, 1], \n             [1, 0, 2], \n             [2, 2, 2]], \n            1\n        ),\n        (\n            [[1, 0], \n             [0, 0]], \n            1\n        )\n    ]\n\n    results = []\n    for X, k in test_cases:\n        result = solve_case(X, k)\n        results.append(f\"{result:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}