{
    "hands_on_practices": [
        {
            "introduction": "我们的起点是一个在日常生活中常见的场景：商店促销。标准的预算线是线性的，但这假设了商品价格是恒定的。这个练习  将挑战这一假设，通过分析“买一送一”这类非线性定价策略，你将学会如何根据具体规则精确地描绘出预算集。掌握这项技能对于理解现实世界中消费者行为的复杂性至关重要。",
            "id": "2378669",
            "problem": "一位消费者选择两种完全可分商品（商品 $x_1$ 和商品 $x_2$）的数量，面临非负价格 $p_1$ 和 $p_2$ 以及货币收入 $m$。预算集是指在商店公布的定价规则下，总支出不超过 $m$ 的所有非负商品组合的集合。商店对商品 $x_1$ 提供买一赠一（BOGO）促销活动，但有上限：消费者每购买一单位的 $x_1$，最多可购买 $K$ 个付费单位，就有权免费获得等量的 $x_1$。超过此上限后，额外的 $x_1$ 单位不会产生免费单位，所有后续单位都必须按公布的价格 $p_1$ 支付。假设两种商品都是完全可分的，因此促销活动按比例适用。\n\n仅从预算集的定义和所描述的促销活动出发，推导预算集横轴截距（当 $x_2=0$ 时可获得的最大 $x_1$）作为 $m$、$p_1$ 和 $K$ 的函数的精确表达式。然后，当 $p_1 = 4$、$p_2 = 5$、$m = 90$ 且 $K = 8$ 时，对该截距进行数值计算。提供截距的最终数值。无需四舍五入。",
            "solution": "在尝试任何解答之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 商品：两种完全可分的商品，$x_1$ 和 $x_2$。\n- 价格：非负价格 $p_1$ 和 $p_2$。\n- 收入：货币收入 $m$。\n- 预算集：所有总支出不超过 $m$ 的非负商品组合 $(x_1, x_2)$ 的集合。\n- 促销：商品 $x_1$ 的买一赠一（BOGO）活动。每购买一单位的 $x_1$，即可免费获得等量的 $x_1$。\n- 促销上限：BOGO促销活动最多适用于 $K$ 个付费单位的 $x_1$。超过此上限后，所有后续的 $x_1$ 单位都必须以价格 $p_1$ 购买。\n- 可分性：对于完全可分的商品，促销活动按比例适用。\n- 目标1：推导预算集横轴截距（当 $x_2=0$ 时的最大 $x_1$）作为 $m$、$p_1$ 和 $K$ 的函数的表达式。\n- 目标2：当 $p_1 = 4$、$p_2 = 5$、$m = 90$ 且 $K = 8$ 时，对该截距进行数值计算。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法得当，且客观。它描述了一个非线性预算约束，这是微观经济学消费者理论中的一个标准课题。问题设定清晰，内部一致，并包含推导唯一解所需的所有信息。语言精确，没有主观论断。因此，该问题被认定为**有效**。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解答。\n\n目标是求当商品 $x_2$ 的数量为零时，即 $x_2 = 0$ 时，可获得商品 $x_1$ 的最大数量。这就是预算集的横轴截距。商品的总支出不能超过收入 $m$。当 $x_2=0$ 时，全部收入 $m$ 都可以用于购买商品 $x_1$。因此，我们必须确定用支出 $m$ 可以获得的最大 $x_1$ 数量。\n\n让我们首先形式化地表示获得第一种商品总量 $x_1$ 所需的支出 $E_1(x_1)$。定价规则是分段的。\n\n第1部分：BOGO促销机制\n促销活动规定，每支付一单位 $x_1$ 的费用，即可免费获得一单位。这意味着要获得总量为 $x_1$ 的商品，消费者只需支付 $x_1/2$ 单位的费用。因此，成本为 $E_1(x_1) = p_1 \\cdot \\frac{x_1}{2}$。\n此促销活动的有效条件是付费单位数量不超过 $K$。付费单位数量为 $x_1/2$。因此，此定价规则适用于 $x_1/2 \\le K$，即 $0 \\le x_1 \\le 2K$。\n\n第2部分：标准定价机制\n如果消费者希望获得超过 $2K$ 单位的 $x_1$，他们必须首先用完BOGO促销的额度。获得前 $2K$ 单位 $x_1$ 的成本是支付 $K$ 个单位的费用，即 $p_1 K$。\n对于任何超过 $2K$ 的数量，即 $x_1 > 2K$，额外的单位 $(x_1 - 2K)$ 必须按标准价格 $p_1$ 支付。这些额外单位的支出为 $p_1 (x_1 - 2K)$。\n获得超过 $2K$ 数量的 $x_1$ 的总支出是前 $2K$ 单位的成本与额外单位成本之和：\n$$E_1(x_1) = p_1 K + p_1 (x_1 - 2K) = p_1 K + p_1 x_1 - 2p_1 K = p_1 x_1 - p_1 K = p_1 (x_1 - K)$$\n\n结合这两个部分，获得 $x_1$ 的支出函数为：\n$$ E_1(x_1) = \\begin{cases} \\frac{p_1 x_1}{2}  \\text{若 } 0 \\le x_1 \\le 2K \\\\ p_1(x_1 - K)  \\text{若 } x_1 > 2K \\end{cases} $$\n\n为了找到横轴截距，我们将总支出设为等于收入 $m$（因为 $x_2=0$），然后求解 $x_1$。解取决于 $m$ 相对于用完BOGO促销所需支出 $p_1 K$ 的值。\n\n情况A：$m \\le p_1 K$\n如果收入不足以支付 $K$ 个单位，消费者将完全在BOGO促销机制内操作。通过将此机制下的支出设为等于 $m$ 来找到 $x_1$ 的最大数量：\n$$\\frac{p_1 x_1}{2} = m$$\n$$x_1 = \\frac{2m}{p_1}$$\n我们必须验证此结果与条件 $x_1 \\le 2K$ 是否一致。\n由于 $m \\le p_1 K$，我们有 $\\frac{m}{p_1} \\le K$，因此 $\\frac{2m}{p_1} \\le 2K$。条件满足。\n\n情况B：$m > p_1 K$\n如果收入大于用完促销额度的成本，消费者将获得超过 $2K$ 单位的 $x_1$。支出由函数的第二部分给出：\n$$p_1(x_1 - K) = m$$\n$$x_1 - K = \\frac{m}{p_1}$$\n$$x_1 = K + \\frac{m}{p_1}$$\n我们必须验证此结果与条件 $x_1 > 2K$ 是否一致。\n由于 $m > p_1 K$，我们有 $\\frac{m}{p_1} > K$，这意味着 $K + \\frac{m}{p_1} > K+K = 2K$。条件满足。\n\n横轴截距 $x_{1, \\text{intercept}}$ 的一般表达式为：\n$$ x_{1, \\text{intercept}} = \\begin{cases} \\frac{2m}{p_1}  \\text{若 } m \\le p_1 K \\\\ K + \\frac{m}{p_1}  \\text{若 } m > p_1 K \\end{cases} $$\n问题的第一个部分到此结束。\n\n对于第二部分，我们必须根据给定的数值计算该截距：$p_1 = 4$、$p_2 = 5$、$m = 90$ 和 $K = 8$。$p_2$ 的值与此计算无关。\n首先，我们通过比较 $m$ 和 $p_1 K$ 来确定适用哪种情况：\n$$m = 90$$\n$$p_1 K = 4 \\times 8 = 32$$\n由于 $90 > 32$，我们有 $m > p_1 K$，这对应于情况B。\n截距的公式为 $x_{1, \\text{intercept}} = K + \\frac{m}{p_1}$。\n代入数值：\n$$x_{1, \\text{intercept}} = 8 + \\frac{90}{4}$$\n$$x_{1, \\text{intercept}} = 8 + 22.5$$\n$$x_{1, \\text{intercept}} = 30.5$$\n可获得商品 $x_1$ 的最大数量是 $30.5$。",
            "answer": "$$\\boxed{30.5}$$"
        },
        {
            "introduction": "在掌握了非线性定价后，我们将更进一步，研究公共政策如何塑造我们的经济选择。累进所得税是一种常见的政策工具，它会产生一个分段线性的预算约束，即预算线上存在“拐点”。这个练习  要求你不仅要构建这个复杂的预算约束，还要通过编程找到消费者的最优劳动-休闲选择。这个过程将理论与计算实践相结合，让你体验如何用模型来评估政策的微观影响。",
            "id": "2378657",
            "problem": "考虑一个单一的代表性个体，在导致分段线性预算约束的累进所得税下做出劳动-闲暇选择。时间是稀缺资源。该个体拥有固定的时间禀赋 $T$ 小时，选择劳动时间 $h \\in [0,T]$，进行消费 $c$，并享受闲暇 $s = T - h$。税前工资率为每小时 $w$，且该个体拥有非劳动收入 $b$。该个体的偏好由柯布-道格拉斯效用函数 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ 表示，其中 $\\alpha \\in (0,1)$。\n\n政府根据一个税收级距表对劳动收入征收累进税。令税前劳动收入为 $y = w h$。税收表由一系列级距阈值 $\\{K_0, K_1, \\dots, K_{N}\\}$（其中 $K_0 = 0$ 且 $K_{N} = +\\infty$）和相应的边际税率 $\\{t_1, t_2, \\dots, t_{N}\\}$ 定义，这些税率适用于阈值之间的收入增量。所有边际税率必须以小数形式提供（例如，使用 $0.2$ 而不是 $20\\%$）。应纳税额的计算方式为：较低级距的累计税额加上当前级距内收入所对应的边际税额。消费由 $c = b + y - \\mathcal{T}(y)$ 给出，其中 $\\mathcal{T}(y)$ 是根据税收级距表定义的收入 $y$ 的总应纳税额。\n\n您的任务是：\n\n- 仅使用以下基本依据：(i) 预算约束的定义 $c = b + y - \\mathcal{T}(y)$，其中 $y = w h$，且 $\\mathcal{T}(y)$ 由分段的边际税率和阈值定义；(ii) 闲暇的定义 $s = T - h$；以及 (iii) 在适用情况下，将闲暇与消费之间的边际替代率等同于某个级距内的税后工资的内部最优解的一阶条件。非内部最优解可能出现在拐点或端点 $h=0$ 或 $h=T$ 处。\n- 对于每个级距 $i \\in \\{1,\\dots,N\\}$，边际税率 $t_i$ 适用于 $y \\in [K_{i-1},K_i)$，总应纳税额可以写为更低级距的税收总和加上 $t_i$ 乘以当前级距内的收入额。这意味着一个分段线性的预算约束，其在级距 $i$ 内的斜率等于税后工资 $w(1 - t_i)$。\n- 您的程序必须为每个测试用例确定效用最大化的劳动时间选择 $h^\\star \\in [0,T]$。这需要通过检查所有理论上可能的候选解来实现：(a) 在每个级距内满足一阶条件的内部解，前提是其所隐含的收入 $y = w h$ 位于该级距的收入范围内；以及 (b) 对应于阈值 $\\{K_1,\\dots,K_{N-1}\\}$ 的、在时间禀赋内可达到的所有拐点，此外还包括端点 $h=0$ 和 $h=T$。对于每个候选的 $h$，计算 $c = b + w h - \\mathcal{T}(w h)$、$s = T - h$ 和 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$，然后选择使 $U(c,s)$ 最大化的候选解。\n- 所有输入均为纯数值；除了 $T$ 和 $h$ 的单位是小时外，没有其他物理单位。所有输出都必须是数值。不涉及角度。百分比必须以小数形式提供。\n\n要实现的测试套件：\n\n提供以下五个测试用例；在每个用例中，$K$ 列出阈值，$t$ 列出相应的边际税率：\n\n- 用例1：$T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$。\n- 用例2：$T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$。\n- 用例3：$T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$。\n- 用例4：$T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$。\n- 用例5：$T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$。\n\n最终输出格式：\n\n- 对于每个测试用例，输出一个列表 $[h^\\star, c^\\star, s^\\star, U^\\star]$，其中 $h^\\star$、$c^\\star$、$s^\\star$ 和 $U^\\star$ 是四舍五入到恰好六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含五个用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，每个用例都表示为其自己的列表。例如：“[[h1,c1,s1,U1],[h2,c2,s2,U2],...]”，每个数字都精确到六位小数，且无任何附加文本。",
            "solution": "我们从基本定义开始。个体选择劳动时间 $h \\in [0,T]$，闲暇为 $s = T - h$，税前劳动收入为 $y = w h$，消费为 $c = b + y - \\mathcal{T}(y)$。偏好由柯布-道格拉斯效用函数 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ 给出，参数 $\\alpha \\in (0,1)$。\n\n累进税收表由阈值 $\\{K_0,\\dots,K_N\\}$（其中 $K_0 = 0$ 且 $K_N = +\\infty$）和级距边际税率 $\\{t_1,\\dots,t_N\\}$ 定义。在级距 $i$ 内，对于 $y \\in [K_{i-1}, K_i)$，总税额可以表示为\n$$\n\\mathcal{T}(y) \\;=\\; \\underbrace{\\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})}_{\\text{cumulative tax up to } K_{i-1}} \\;+\\; t_i \\, (y - K_{i-1}) \\;=\\; C_{i-1} + t_i y - t_i K_{i-1},\n$$\n其中 $C_{i-1} = \\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})$ 是在下限阈值 $K_{i-1}$ 处的累计税额。因此，在级距 $i$ 内，\n$$\nc \\;=\\; b + y - \\mathcal{T}(y) \\;=\\; \\underbrace{b - C_{i-1} + t_i K_{i-1}}_{B_i} \\;+\\; (1 - t_i) y,\n$$\n这是 $y$（因此也是 $h$）的线性函数，其斜率等于级距 $i$ 内的税后工资，由 $w_i = w (1 - t_i)$ 给出。因此，对于级距 $i$ 内的 $y = w h$，\n$$\nc(h) \\;=\\; B_i + w_i h\n\\quad\\text{和}\\quad\ns(h) \\;=\\; T - h.\n$$\n\n对于给定级距 $i$ 内的内部解，一阶条件将边际替代率等同于相关的税后工资：\n$$\n\\text{MRS}_{s,c} \\;=\\; \\frac{\\partial U/\\partial s}{\\partial U/\\partial c} \\;=\\; \\frac{(1-\\alpha)}{\\alpha} \\,\\frac{c}{s} \\;=\\; w_i.\n$$\n代入 $c = B_i + w_i h$ 和 $s = T - h$ 可得\n$$\n\\frac{(1-\\alpha)}{\\alpha}\\,\\frac{B_i + w_i h}{T - h} \\;=\\; w_i.\n$$\n求解 $h$ 得到级距 $i$ 内的候选内部解：\n$$\nh_i^\\circ \\;=\\; \\alpha T \\;-\\; \\frac{1-\\alpha}{w_i}\\, B_i.\n$$\n此 $h_i^\\circ$ 仅在可行时有效，即可行性意味着它满足 $0 \\le h_i^\\circ \\le T$ 且其所隐含的收入 $y_i^\\circ = w h_i^\\circ$ 位于该级距的收入范围之内，即 $K_{i-1} \\le y_i^\\circ  K_i$。如果候选解不满足这些条件，则最优解不可能位于该级距内部。\n\n除了内部候选解之外，最优解也可能出现在拐点处，因为预算约束的斜率在阈值 $\\{K_1,\\dots,K_{N-1}\\}$ 处发生变化。每个拐点对应劳动时间 $h_k = K_k / w$，前提是 $h_k \\le T$。端点 $h=0$ 和 $h=T$ 也是候选解。对于每个候选的 $h$，计算：\n- $y = w h$,\n- 根据税收级距表计算总税额 $\\mathcal{T}(y)$，\n- $c = b + y - \\mathcal{T}(y)$,\n- $s = T - h$,\n- $U(c,s) = c^{\\alpha} s^{1-\\alpha}$.\n\n在所有候选解中，选择使 $U(c,s)$ 最大化的 $h^\\star$。如果多个候选解产生的效用值在数值容差范围内相等，为了确定性，可以选择具有最小 $h$ 值的候选解。\n\n算法设计：\n- 预先计算每个级距 $i$ 的累计税额 $C_{i-1}$、常数 $B_i = b - C_{i-1} + t_i K_{i-1}$ 和税后工资 $w_i = w(1 - t_i)$。\n- 生成由以下各项组成的候选集：\n  - 内部候选解 $h_i^\\circ = \\alpha T - \\frac{1-\\alpha}{w_i} B_i$，限制条件为 $0 \\le h_i^\\circ \\le T$ 和 $K_{i-1} \\le w h_i^\\circ  K_i$。\n  - 对于所有阈值，拐点候选解为 $h_k = K_k / w$，且 $h_k \\le T$。\n  - 端点 $h=0$ 和 $h=T$。\n- 对所有候选解计算 $U(c(h), s(h))$ 并选择最大化者。\n\n此过程独立应用于五个测试用例中的每一个：\n- 用例1：$T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$。\n- 用例2：$T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$。\n- 用例3：$T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$。\n- 用例4：$T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$。\n- 用例5：$T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$。\n\n该程序实现了这种候选解评估方法，为每个用例计算最优的 $[h^\\star, c^\\star, s^\\star, U^\\star]$，将每个值四舍五入到恰好六位小数，并按照规定格式将结果打印为单行的列表之列表。",
            "answer": "```python\nimport numpy as np\n\ndef compute_cumulative_tax_thresholds(K, t):\n    \"\"\"\n    Given thresholds K (length N+1 with K[0]=0, K[N]=inf) and marginal rates t (length N),\n    compute cumulative tax up to each lower threshold K[i] for bracket i (i from 0..N-1).\n    Returns list C where C[i] = cumulative tax up to K[i] (i.e., sum_{j i} t[j]*(K[j+1]-K[j])).\n    \"\"\"\n    N = len(t)\n    C = [0.0] * (N + 1)\n    cum = 0.0\n    for i in range(1, N + 1):\n        # Tax in bracket i-1 fully applied up to K[i]\n        width = K[i] - K[i - 1]\n        if np.isfinite(width):\n            cum += t[i - 1] * width\n        else:\n            # Last width is infinite; do not add to cumulative because it's unbounded\n            cum += 0.0\n        C[i] = cum\n    return C\n\ndef total_tax(y, K, t):\n    \"\"\"\n    Compute total tax owed given income y, thresholds K, and marginal rates t.\n    \"\"\"\n    N = len(t)\n    tax = 0.0\n    remaining = y\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        if remaining = lower:\n            break\n        taxable = min(remaining, upper) - lower\n        if taxable > 0:\n            tax += t[i] * taxable\n    return tax\n\ndef evaluate_candidates(case):\n    T = float(case[\"T\"])\n    w = float(case[\"w\"])\n    b = float(case[\"b\"])\n    alpha = float(case[\"alpha\"])\n    # Ensure K and t are numpy arrays, last K can be inf\n    K = np.array(case[\"K\"], dtype=float)\n    t_rates = np.array(case[\"t\"], dtype=float)\n    N = len(t_rates)\n    # Precompute cumulative taxes at thresholds\n    C = compute_cumulative_tax_thresholds(K, t_rates)  # length N+1\n    # Generate candidates: endpoints\n    candidates = [0.0, T]\n    # Kinks: K[1..N-1]\n    for j in range(1, len(K) - 1):\n        h_kink = K[j] / w\n        if h_kink = T + 1e-12:\n            candidates.append(max(0.0, min(T, h_kink)))\n    # Interior candidates within each bracket\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        wi = w * (1.0 - t_rates[i])\n        # If after-tax wage is effectively zero, skip interior candidate\n        if wi = 1e-12:\n            continue\n        Bi = b - C[i] + t_rates[i] * K[i]\n        h_int = alpha * T - (1.0 - alpha) * Bi / wi\n        # Feasibility: within [0,T] and income within bracket\n        if h_int  -1e-12 or h_int > T + 1e-12:\n            continue\n        y_int = w * h_int\n        lower_ok = y_int >= lower - 1e-9\n        upper_ok = (y_int  upper - 1e-9) or not np.isfinite(upper)\n        if lower_ok and upper_ok:\n            # Clamp to [0,T]\n            h_int = max(0.0, min(T, h_int))\n            candidates.append(h_int)\n    # Deduplicate candidates with tolerance\n    candidates_sorted = sorted(candidates)\n    uniq = []\n    for h in candidates_sorted:\n        if not uniq or abs(h - uniq[-1]) > 1e-9:\n            uniq.append(h)\n    # Evaluate utility and select best\n    best = None\n    best_tuple = None\n    for h in uniq:\n        y = w * h\n        tax = total_tax(y, K, t_rates)\n        c = b + y - tax\n        s = T - h\n        # Utility: c^alpha * s^(1-alpha); by convention, if c=0 or s=0, utility is 0\n        if c = 0.0 or s = 0.0:\n            U = 0.0\n        else:\n            U = (c ** alpha) * (s ** (1.0 - alpha))\n        # Select by utility, tie-break by smallest h\n        sel_key = (U, -h)  # since we want smallest h on tie, use -h with max\n        if (best is None) or (sel_key > best):\n            best = sel_key\n            best_tuple = (h, c, s, U)\n    # Round to six decimals\n    h_star, c_star, s_star, U_star = best_tuple\n    return [round(h_star, 6), round(c_star, 6), round(s_star, 6), round(U_star, 6)]\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\"T\": 16.0, \"w\": 25.0, \"b\": 10.0, \"alpha\": 0.4,\n         \"K\": [0.0, 200.0, 400.0, np.inf], \"t\": [0.0, 0.2, 0.35]},\n        # Case 2\n        {\"T\": 24.0, \"w\": 20.0, \"b\": 300.0, \"alpha\": 0.2,\n         \"K\": [0.0, 100.0, 200.0, np.inf], \"t\": [0.5, 0.7, 0.9]},\n        # Case 3\n        {\"T\": 8.0, \"w\": 30.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, np.inf], \"t\": [0.25]},\n        # Case 4\n        {\"T\": 6.0, \"w\": 40.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, 80.0, 120.0, np.inf], \"t\": [0.0, 0.5, 0.6]},\n        # Case 5\n        {\"T\": 12.0, \"w\": 15.0, \"b\": 0.0, \"alpha\": 0.9,\n         \"K\": [0.0, 60.0, 120.0, np.inf], \"t\": [0.1, 0.2, 0.4]},\n    ]\n    results = []\n    for case in test_cases:\n        results.append(evaluate_candidates(case))\n\n    # Format as a single-line list of lists with exactly six decimals\n    def fmt_num(x):\n        return f\"{x:.6f}\"\n\n    inner = []\n    for res in results:\n        inner.append(\"[\" + \",\" + \",\".join(fmt_num(v) for v in res)[1:] + \"]\" if False else \"[\" + \",\".join(fmt_num(v) for v in res) + \"]\")\n    output = \"[\" + \",\".join(inner) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "我们最后的挑战将预算约束的概念引入了现代金融的核心——不确定性。当收入来源（如加密货币）价值波动时，预算规划变得尤为复杂。这个练习  模拟了一个消费者需要基于其不稳定的未来收入来决定当前借贷额度的情景。你需要通过分析“最坏情况”来确定一个稳健的借贷上限，这展示了预算约束如何在风险管理和金融合约设计中发挥关键作用。",
            "id": "2378611",
            "problem": "一位消费者选择两种非负数量的商品，分别表示为 $x_1$ 和 $x_2$，其法定货币价格分别为 $p_1$ 和 $p_2$。该消费者在日期 0 时拥有当前法定货币财富 $w_0$，并将在日期 1 时收到 $q$ 单位的加密货币。在日期 1 时，该加密货币的法定货币汇率是不确定的，属于一个已知的闭区间 $[E_{\\min}, E_{\\max}]$，其中 $E_{\\min} \\ge 0$。消费者在日期 1 之前不能出售该加密货币。\n\n在日期 0，消费者可以借入一笔法定货币，金额为 $b$，但受外生上限 $B_{\\max} \\ge 0$ 的限制，并且必须在日期 1 偿还 $(1+r)b$，其中 $r \\ge 0$ 是利率。为偿还债务，消费者可以在日期 1 观察到已实现的汇率 $E \\in [E_{\\min}, E_{\\max}]$ 后，出售任意数量 $z(E) \\in [0,q]$ 的加密货币。如果 $z(E) = 0$，则不支付任何交易费用，法定货币收益为 $0$。如果 $z(E)  0$，交易所会按费率 $f \\in [0,1)$ 征收从价费，并收取一笔固定费用 $k \\ge 0$，因此以汇率 $E$ 出售 $z(E)$ 单位加密货币的法定货币收益为 $(1-f) E \\, z(E) - k$。\n\n贷款人施加了一个稳健的偿付能力要求：对于每一个 $E \\in [E_{\\min}, E_{\\max}]$，都必须存在一个选择 $z(E) \\in [0,q]$，使得日期 1 的出售净收益至少为还款额 $(1+r)b$。形式上，对于所有 $E \\in [E_{\\min}, E_{\\max}]$，存在一个 $z(E) \\in [0,q]$ 满足\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E)  0\\}} \\;\\ge\\; (1+r) b,$$\n其中 $\\mathbf{1}_{\\{\\cdot\\}}$ 是指示函数，当其参数为真时等于 $1$，否则等于 $0$。\n\n在日期 0，消费者的预算集是满足以下条件的 $(x_1,x_2)$ 集合\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\n其中 $x_1 \\ge 0$，$x_2 \\ge 0$，且 $b \\in [0,B_{\\max}]$ 满足上述稳健的偿付能力要求。\n\n任务。对于下面测试套件中的每一组参数，计算以下三个量：\n- 最大稳健可行借款能力 $b_{\\max}$。\n- 由此产生的预算线在 $x_2 = 0$ 时与 $x_1$ 轴的截距 $x_1^{\\max}$，即 $x_1^{\\max} = (w_0 + b_{\\max})/p_1$。\n- 由此产生的预算线在 $x_1 = 0$ 时与 $x_2$ 轴的截距 $x_2^{\\max}$，即 $x_2^{\\max} = (w_0 + b_{\\max})/p_2$。\n\n将这三个量中的每一个都报告为四舍五入到小数点后六位的小数。\n\n测试套件。每个案例都是一个元组 $(p_1,p_2,w_0,q,E_{\\min},E_{\\max},f,k,r,B_{\\max})$：\n- 案例 1：$(2.0,\\,3.0,\\,10.0,\\,5.0,\\,180.0,\\,220.0,\\,0.01,\\,5.0,\\,0.05,\\,1000.0)$。\n- 案例 2：$(1.5,\\,4.0,\\,20.0,\\,2.0,\\,5.555555555555556,\\,6.0,\\,0.1,\\,10.0,\\,0.1,\\,100.0)$。\n- 案例 3：$(5.0,\\,2.0,\\,0.0,\\,3.0,\\,100.0,\\,200.0,\\,0.0,\\,0.0,\\,0.2,\\,1000.0)$。\n- 案例 4：$(1.0,\\,1.0,\\,5.0,\\,10.0,\\,50.0,\\,60.0,\\,0.05,\\,0.0,\\,0.0,\\,100.0)$。\n- 案例 5：$(2.0,\\,2.0,\\,0.0,\\,1.0,\\,100.0,\\,150.0,\\,0.1,\\,5.0,\\,1.0,\\,1000.0)$。\n- 案例 6：$(3.0,\\,6.0,\\,7.0,\\,0.0,\\,100.0,\\,120.0,\\,0.2,\\,1.0,\\,0.3,\\,50.0)$。\n\n最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个案例 $i$，输出列表 $[b_{\\max,i},x_{1,i}^{\\max},x_{2,i}^{\\max}]$，每个数字四舍五入到小数点后六位。将六个案例级别的列表按上述相同顺序聚合成一个单一列表，其中不含任何空格。例如，包含两个假设案例的输出将如下所示：$[[1.000000,2.000000,3.000000],[4.000000,5.000000,6.000000]]$。",
            "solution": "问题是在给定一个不确定但有界的未来加密货币收入以及一个要求对区间 $[E_{\\min}, E_{\\max}]$ 内的每一个汇率实现都具有稳健偿付能力的贷款人的条件下，确定日期 0 的法定货币预算线。核心步骤依赖于稳健偿付能力约束下的可行性定义以及预算线的定义。\n\n首先，考虑稳健的借款约束。对于任何选定的贷款 $b \\in [0,B_{\\max}]$，偿付能力要求对于每个 $E \\in [E_{\\min}, E_{\\max}]$，都存在一个出售数量 $z(E) \\in [0,q]$ 使得\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E)  0\\}} \\;\\ge\\; (1+r) b.$$\n让我们分析在 $E$ 实现后可以选择 $z(E)$ 的情况下，对于所有 $E$ 可以保证用于还款的最大法定货币金额。\n\n固定 $E \\in [E_{\\min}, E_{\\max}]$。出售 $z \\in [0,q]$ 单位时的收益函数是\n$$\\pi(E,z) \\;=\\; \\begin{cases}\n0,  z = 0,\\\\\n(1-f) E \\, z - k,  z \\in (0,q].\n\\end{cases}$$\n对于给定的 $E$，收益 $\\pi(E,z)$ 在 $(0,q]$ 上是关于 $z$ 的非递减函数，因为 $(1-f)E \\ge 0$。因此，在决定出售的前提下，该 $E$ 下的最大收益来自于出售全部持有量：\n$$\\max_{z \\in (0,q]} \\pi(E,z) \\;=\\; (1-f) E \\, q - k.$$\n然而，消费者也可以选择不出售，从而避免固定费用 $k$，获得收益 $0$。因此，在汇率 $E$ 下，通过该 $E$ 下的最优出售决策可以保证的最大收益是\n$$\\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E \\, q - k\\big).$$\n\n贷款人要求还款额 $(1+r) b$ 不超过在任何 $E \\in [E_{\\min}, E_{\\max}]$ 下，根据该 $E$ 的最优出售决策所能获得的收益。这导出了稳健的界限\n$$(1+r) b \\;\\le\\; \\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E).$$\n因为 $\\Pi(E)$ 是关于 $E$ 的非递减函数（因为 $(1-f) E \\, q - k$ 是非递减的，且与 $0$ 取最大值保留了单调性），所以 $[E_{\\min}, E_{\\max}]$ 上的下确界在 $E_{\\min}$ 处取得：\n$$\\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big).$$\n因此，与稳健偿付能力和外生上限相符的最大 $b$ 是\n$$b_{\\max} \\;=\\; \\min\\!\\left(B_{\\max},\\; \\frac{\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)}{1+r}\\right).$$\n\n接下来，日期 0 的预算集由标准线性支出约束定义\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\n其中 $b \\in [0,b_{\\max}]$ 且 $x_1 \\ge 0$，$x_2 \\ge 0$。预算集的外包络线是当 $b = b_{\\max}$ 时得到的预算线。通过将另一种商品的消费设为零，得到的该线与 $x_1$ 轴和 $x_2$ 轴的截距分别为\n$$x_1^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_1}, \\qquad x_2^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_2}.$$\n\n因此，每个案例的计算从第一性原理出发，按以下步骤进行：\n1. 计算最坏情况下的保证收益 $\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)$。\n2. 除以 $(1+r)$ 以获得由还款所隐含的借款上限，然后与 $B_{\\max}$ 取最小值以得到 $b_{\\max}$。\n3. 计算 $x_1^{\\max} = (w_0 + b_{\\max})/p_1$ 和 $x_2^{\\max} = (w_0 + b_{\\max})/p_2$。\n\n将这些步骤应用于每个测试案例，并将所有报告的数字四舍五入到小数点后六位，即可得出规范所要求的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max):\n    \"\"\"\n    Compute b_max = min(B_max, max(0, (1-f)*E_min*q - k) / (1+r))\n    Then compute axis intercepts:\n      x1_max = (w0 + b_max)/p1\n      x2_max = (w0 + b_max)/p2\n    \"\"\"\n    # Worst-case guaranteed proceeds at E_min given optimal choice of z(E)\n    proceeds_low = (1.0 - f) * E_min * q - k\n    guaranteed = proceeds_low if proceeds_low > 0.0 else 0.0\n    denom = 1.0 + r\n    # Guard against any numerical issues (denom should be > 0 given r >= 0 in problem)\n    if denom = 0.0:\n        # Fallback: if denom is zero or negative (not in provided tests), set borrowing bound to 0\n        b_bound = 0.0\n    else:\n        b_bound = guaranteed / denom\n    b_max = b_bound if b_bound = B_max else B_max\n    # Axis intercepts\n    x1_max = (w0 + b_max) / p1\n    x2_max = (w0 + b_max) / p2\n    return b_max, x1_max, x2_max\n\ndef fmt6(x):\n    # Format with exactly 6 digits after the decimal, avoiding \"-0.000000\"\n    if abs(x)  0.0000005:\n        x = 0.0\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n    test_cases = [\n        (2.0, 3.0, 10.0, 5.0, 180.0, 220.0, 0.01, 5.0, 0.05, 1000.0),            # Case 1\n        (1.5, 4.0, 20.0, 2.0, 5.555555555555556, 6.0, 0.1, 10.0, 0.1, 100.0),    # Case 2\n        (5.0, 2.0, 0.0, 3.0, 100.0, 200.0, 0.0, 0.0, 0.2, 1000.0),               # Case 3\n        (1.0, 1.0, 5.0, 10.0, 50.0, 60.0, 0.05, 0.0, 0.0, 100.0),                # Case 4\n        (2.0, 2.0, 0.0, 1.0, 100.0, 150.0, 0.1, 5.0, 1.0, 1000.0),               # Case 5\n        (3.0, 6.0, 7.0, 0.0, 100.0, 120.0, 0.2, 1.0, 0.3, 50.0),                 # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        p1, p2, w0, q, E_min, E_max, f, k, r, B_max = case\n        b_max, x1_max, x2_max = robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n        results.append((b_max, x1_max, x2_max))\n\n    # Build output string with no spaces and six decimals per number\n    inner_lists = []\n    for b, x1, x2 in results:\n        inner = f\"[{fmt6(b)},{fmt6(x1)},{fmt6(x2)}]\"\n        inner_lists.append(inner)\n    output = f\"[{','.join(inner_lists)}]\"\n    # Final print statement in the exact required format.\n    print(output)\n\nsolve()\n```"
        }
    ]
}