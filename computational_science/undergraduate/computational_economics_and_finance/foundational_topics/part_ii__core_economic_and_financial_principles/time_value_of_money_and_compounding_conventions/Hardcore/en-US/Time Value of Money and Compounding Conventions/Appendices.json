{
    "hands_on_practices": [
        {
            "introduction": "Many fundamental concepts in finance, such as a bond's Yield-to-Maturity (YTM), are defined implicitly by an equation rather than an explicit formula. Finding the YTM, the interest rate that equates a bond's market price to the present value of its future cash flows, is a classic root-finding problem. This practice guides you through implementing a numerical bracketing method to solve for YTM, bridging the gap between financial theory and practical computational skills .",
            "id": "2377925",
            "problem": "You will implement a bracketing root-finding algorithm to compute the yield-to-maturity (YTM) of coupon-bearing and zero-coupon bonds. The YTM is the nominal annual interest rate (compounded at a specified frequency per year) that makes the present value of all future cash flows equal to the current market price. This task must be formulated as a scalar root-finding problem in a single unknown, solved using a bracketing method on a continuous function, and justified from first principles.\n\nFundamental base:\n- Time value of money: the present value of a future cash flow equals its amount multiplied by an appropriate discount factor derived from the nominal annual yield, the compounding frequency, and elapsed time.\n- Continuity and monotonicity: for a stream of strictly positive cash flows discounted by a nominal annual yield compounded a fixed number of times per year, the present value is a continuous and strictly decreasing function of the yield.\n- Intermediate Value Theorem (IVT): if a continuous function on a closed interval takes values of opposite sign at the endpoints, then it has at least one root in that interval.\n\nDefine the scalar function as follows. Let the nominal annual yield be the unknown $y$. Let the compounding frequency be $m$ payments per year, with $m \\in \\mathbb{N}$, and assume $m T \\in \\mathbb{N}$ so the total number of periods is an integer. For a bond with face value $F$, annual coupon rate $c$ (as a decimal fraction per year), maturity $T$ years, and current market price $P$, define $f(y)$ to be the difference between the present value of all future coupon payments and the redemption amount, discounted using the nominal annual yield $y$ with compounding frequency $m$, and the observed price $P$. The YTM is any $y$ such that $f(y) = 0$ subject to the financial feasibility condition $1 + y/m > 0$.\n\nYour program must:\n- Implement a bracketing method for root finding (for example, the bisection method or the false-position method) that uses only function evaluations and interval endpoints, and guarantees convergence for continuous functions with a sign change, without relying on derivative information. You must use a fixed initial bracket $[y_{\\min}, y_{\\max}] = [-0.99, 3.0]$ and verify that $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$ for each test case. If the initial bracket does not straddle a root, you must expand the bracket conservatively while maintaining the feasibility condition $1 + y/m > 0$ until a sign change is found or a reasonable expansion limit is reached. \n- For each bond, compute the present value by discounting each cash flow at the per-period rate implied by the nominal annual yield $y$ compounded $m$ times per year, summing over all cash flows at their respective period indices. The per-period discount factor must enforce the financial feasibility condition $1 + y/m > 0$.\n- Use a stopping criterion that ensures the absolute width of the bracketing interval is less than or equal to a specified tolerance $\\varepsilon$ or the absolute function value at the midpoint is less than or equal to a specified tolerance $\\delta$. Use $\\varepsilon = 10^{-12}$ and $\\delta = 10^{-12}$, and a maximum of $10{,}000$ iterations per root find.\n- Produce results in units of decimal fraction per year (no percent sign). Angles are not involved. Monetary values are in arbitrary consistent units; no currency symbol is required.\n\nTest suite:\nFor each case, parameters are given as $(F, c, m, T, P)$ with the conventions above. Assume $m T \\in \\mathbb{N}$.\n\n- Case $1$ (general coupon bond, discount): $(F=\\$1000, c=0.05, m=2, T=5, P=\\$950)$.\n- Case $2$ (zero-coupon, positive yield): $(F=\\$1000, c=0.0, m=1, T=3, P=\\$850)$.\n- Case $3$ (par bond, consistency check): $(F=\\$1000, c=0.04, m=2, T=7, P=\\$1000)$.\n- Case $4$ (zero-coupon, negative yield): $(F=\\$1000, c=0.0, m=1, T=1, P=\\$1005)$.\n\nAnswer specification:\n- For each test case, output the YTM as a floating-point number in decimal fraction per year, rounded to exactly $10$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as Cases $1$ through $4$. For example, the output format must be exactly like $[y_1,y_2,y_3,y_4]$ with each $y_k$ rounded to $10$ decimal places.",
            "solution": "The problem statement has been rigorously validated. All givens were extracted and checked against criteria for scientific soundness, completeness, and objectivity. The problem is well-posed, grounded in established financial mathematics, and contains no ambiguities, contradictions, or factual errors. The parameters provided for the test cases are physically and financially plausible. Therefore, the problem is deemed valid and a solution will be provided.\n\nThe central task is to determine the yield-to-maturity (YTM), denoted by $y$, for a set of bonds. The YTM is the nominal annual interest rate that equates the present value of a bond's future cash flows to its current market price. This is a root-finding problem for a scalar function of the yield, $y$.\n\nFirst, we must construct this function from first principles. Let a bond have a face value $F$, an annual coupon rate $c$, a maturity of $T$ years, and a coupon compounding frequency of $m$ times per year. The problem specifies that the total number of periods, $N = mT$, is an integer.\n\nThe total cash flow from the bond consists of two components: periodic coupon payments and the final redemption of the face value.\nThe annual coupon amount is $cF$. Since there are $m$ payments per year, each coupon payment is $C = \\frac{cF}{m}$. These payments occur at the end of each period, for a total of $N = mT$ periods.\nAt the end of the final period, $N$, the face value $F$ is also returned.\nThus, the cash flow at the end of period $k \\in \\{1, 2, \\dots, N-1\\}$ is $C_k = C$, and the cash flow at the final period $N$ is $C_N = C + F$.\n\nThe principle of the time value of money states that a future cash flow must be discounted to find its present value. Let $y$ be the nominal annual yield. The per-period yield is $r = \\frac{y}{m}$. The discount factor for a cash flow at period $k$ is $(1+r)^{-k} = (1 + y/m)^{-k}$. A critical condition for financial feasibility is that the discount rate must be well-defined, requiring $1 + y/m > 0$.\n\nThe total present value of all future cash flows, $\\text{PV}(y)$, is the sum of the discounted values of each cash flow:\n$$ \\text{PV}(y) = \\sum_{k=1}^{N} \\frac{C_k}{(1 + y/m)^k} $$\nSubstituting the specific cash flows for a coupon-bearing bond ($c>0$):\n$$ \\text{PV}(y) = \\left( \\sum_{k=1}^{N} \\frac{C}{(1+y/m)^k} \\right) + \\frac{F}{(1+y/m)^N} $$\nwhere $C = \\frac{cF}{m}$ and $N=mT$. For a zero-coupon bond ($c=0$), the coupon payments are zero, and the formula simplifies to the present value of a single lump sum:\n$$ \\text{PV}(y) = \\frac{F}{(1+y/m)^N} $$\nThe problem defines the function to be solved, $f(y)$, as the difference between the present value of cash flows and the market price $P$:\n$$ f(y) = \\text{PV}(y) - P = 0 $$\nFor any set of positive cash flows, the function $\\text{PV}(y)$ is a continuous and strictly decreasing function of $y$ over its feasible domain $y > -m$. Consequently, $f(y)$ is also a continuous and strictly decreasing function. This monotonicity guarantees that if a root exists, it is unique.\n\nThe existence of a root within an interval is guaranteed by the Intermediate Value Theorem (IVT), which states that for a continuous function on a closed interval $[a, b]$, if $f(a)$ and $f(b)$ have opposite signs, there must be at least one value $y^* \\in (a, b)$ such that $f(y^*) = 0$. This is the theoretical foundation for bracketing root-finding methods.\n\nWe will implement the bisection method, a robust and simple bracketing algorithm that does not require derivative information. Its convergence is guaranteed, albeit at a linear rate, which is acceptable for the required precision.\n\nThe algorithm proceeds as follows:\n$1$. Initialize the search bracket. The problem specifies an initial bracket $[a, b] = [y_{\\min}, y_{\\max}] = [-0.99, 3.0]$. We must verify that this bracket is valid, i.e., $f(a) \\cdot f(b) \\le 0$. Given that $f(y)$ is monotonically decreasing, we expect $f(a) > 0$ and $f(b) < 0$. If this condition does not hold, the bracket must be expanded. Since $f(y) \\to \\infty$ as $y \\to -m^+$ and $f(y) \\to -P < 0$ as $y \\to \\infty$, a bracket satisfying the IVT condition is guaranteed to exist. An expansion logic would increase $b$ if $f(b)>0$ and decrease $a$ (towards $-m$) if $f(a)<0$. For the specified test cases, the initial bracket $[-0.99, 3.0]$ is sufficient and requires no expansion.\n\n$2$. Iterate until a stopping criterion is met. In each iteration:\n   a. Calculate the midpoint of the current interval: $y_{\\text{mid}} = a + \\frac{b-a}{2}$. This formulation is preferred over $(a+b)/2$ to avoid potential floating-point overflow with large-magnitude numbers.\n   b. Evaluate the function at the midpoint, $f(y_{\\text{mid}})$.\n   c. Check the stopping criteria. The process terminates if the interval width is sufficiently small, $|b-a| \\le \\varepsilon = 10^{-12}$, or if the function value at the midpoint is close to zero, $|f(y_{\\text{mid}})| \\le \\delta = 10^{-12}$. A limit on the number of iterations ($10,000$) is also enforced to prevent infinite loops.\n   d. Update the bracket. Based on the sign of $f(y_{\\text{mid}})$, the half of the interval that is guaranteed to not contain the root is discarded. If $f(y_{\\text{mid}})$ has the same sign as $f(a)$, the new interval becomes $[y_{\\text{mid}}, b]$. Otherwise, it becomes $[a, y_{\\text{mid}}]$. As we established $f(a)>0$ is expected, if $f(y_{\\text{mid}})>0$ the root lies in $[y_{\\text{mid}},b]$, so we set $a = y_{\\text{mid}}$. If $f(y_{\\text{mid}})<0$, the root lies in $[a, y_{\\text{mid}}]$, so we set $b = y_{\\text{mid}}$.\n\n$3$. The final result is the midpoint of the last computed interval, which approximates the root $y^*$ with a guaranteed error bound.\n\nThis method will be applied to each test case to compute the corresponding YTM. The calculations are performed using floating-point arithmetic, and the final results are rounded to $10$ decimal places as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem specification\nTOLERANCE_EPSILON = 1e-12\nTOLERANCE_DELTA = 1e-12\nMAX_ITERATIONS = 10000\nINITIAL_BRACKET = [-0.99, 3.0]\n\ndef calculate_f_y(y, F, c, m, T, P):\n    \"\"\"\n    Calculates the value of the price-yield function f(y) = PV(y) - P.\n    \n    Args:\n        y (float): The nominal annual yield (YTM).\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        m (int): Compounding frequency per year.\n        T (int): Maturity in years.\n        P (float): Current market price.\n\n    Returns:\n        float: The value of f(y).\n    \"\"\"\n    # Financial feasibility condition: 1 + y/m > 0\n    if 1.0 + y / m <= 0:\n        return float('inf')  # Return a large positive value for infeasible yields\n\n    num_periods = int(m * T)\n    coupon_per_period = c * F / m\n\n    present_value = 0.0\n    \n    # The term (1 + y/m) is used repeatedly\n    discount_base = 1.0 + y / m\n    \n    # Calculate present value of coupon payments using direct summation\n    if c > 0:\n        for k in range(1, num_periods + 1):\n            present_value += coupon_per_period / (discount_base ** k)\n\n    # Add present value of face value redemption\n    present_value += F / (discount_base ** num_periods)\n    \n    return present_value - P\n\ndef find_ytm(params):\n    \"\"\"\n    Computes the Yield-to-Maturity (YTM) for a bond using the bisection method.\n\n    Args:\n        params (tuple): A tuple containing bond parameters (F, c, m, T, P).\n\n    Returns:\n        float: The calculated YTM.\n    \"\"\"\n    F, c, m, T, P = params\n    \n    a, b = INITIAL_BRACKET[0], INITIAL_BRACKET[1]\n    \n    fa = calculate_f_y(a, F, c, m, T, P)\n    fb = calculate_f_y(b, F, c, m, T, P)\n    \n    # Bracket expansion logic as required by the problem statement.\n    # Note: For the given test cases, the initial bracket is sufficient.\n    # This logic is included for robustness as per the directive.\n    expansion_limit = 20\n    expand_iter = 0\n    while fa * fb > 0 and expand_iter < expansion_limit:\n        # f(y) is monotonically decreasing.\n        # If both are positive, root is to the right of b.\n        if fa > 0 and fb > 0:\n            b *= 2.0\n        # If both are negative, root is to the left of a.\n        elif fa < 0 and fb < 0:\n            # Conservatively move 'a' towards the theoretical limit -m\n            a = (a - m) / 2.0\n            if a <= -m: # Ensure feasibility\n                a = -m + 1e-9\n        else: # One or both are zero, which is a root\n            return a if fa == 0 else b\n\n        fa = calculate_f_y(a, F, c, m, T, P)\n        fb = calculate_f_y(b, F, c, m, T, P)\n        expand_iter += 1\n\n    if fa * fb > 0:\n        raise ValueError(f\"Failed to find a bracketing interval for params: {params}\")\n\n    # Ensure fa is positive and fb is negative to simplify bisection logic\n    if fa < 0:\n        a, b = b, a\n        fa, fb = fb, fa\n\n    # Bisection method implementation\n    for _ in range(MAX_ITERATIONS):\n        mid = a + (b - a) / 2.0\n        f_mid = calculate_f_y(mid, F, c, m, T, P)\n        \n        # Check stopping criteria\n        if (b - a) <= TOLERANCE_EPSILON or abs(f_mid) <= TOLERANCE_DELTA:\n            return mid\n        \n        # Update bracket\n        if f_mid > 0:  # Root is in the right half [mid, b]\n            a = mid\n            fa = f_mid\n        else:  # Root is in the left half [a, mid]\n            b = mid\n            fb = f_mid\n            \n    # If max iterations is reached, return the best estimate.\n    return a + (b - a) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (F, c, m, T, P)\n    test_cases = [\n        (1000.0, 0.05, 2, 5.0, 950.0),    # Case 1: General coupon bond, discount\n        (1000.0, 0.0, 1, 3.0, 850.0),    # Case 2: Zero-coupon, positive yield\n        (1000.0, 0.04, 2, 7.0, 1000.0),   # Case 3: Par bond, consistency check\n        (1000.0, 0.0, 1, 1.0, 1005.0)     # Case 4: Zero-coupon, negative yield\n    ]\n\n    results = []\n    for case in test_cases:\n        ytm = find_ytm(case)\n        # Format to 10 decimal places as required\n        results.append(f\"{ytm:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "While translating financial formulas into code may seem straightforward, it often harbors hidden numerical challenges. This exercise focuses on the numerical instability of the standard present value of an annuity formula, particularly as the interest rate $r$ approaches zero, leading to a loss of precision known as catastrophic cancellation. By comparing the naive implementation with a more robust Taylor series approximation, you will develop a critical understanding of how finite-precision arithmetic can affect financial calculations and learn techniques to ensure model accuracy .",
            "id": "2444517",
            "problem": "You are given the present value of a level annuity under discrete compounding, defined for per-period payment $Pmt$, per-period effective interest rate $r$ (expressed as a decimal), and integer number of payments $n \\in \\mathbb{N}$, by the function\n$$\nPV(Pmt,r,n) \\;=\\; Pmt \\times \\begin{cases}\n\\dfrac{1 - (1+r)^{-n}}{r}, & r \\neq 0,\\\\[6pt]\nn, & r = 0.\n\\end{cases}\n$$\nThis function can be extended continuously to $r=0$ via the limit, which equals $Pmt \\times n$. Consider the numerical stability of evaluating $PV(Pmt,r,n)$ as $r \\to 0$ when arithmetic is performed in finite precision.\n\nYour task is to implement two numerical approximations for $PV(Pmt,r,n)$ and compare them to the mathematically exact value of $PV(Pmt,r,n)$ (in real arithmetic, with the $r=0$ case interpreted by the limit). The two approximations are:\n\n- The direct formula for $r \\neq 0$:\n$$\nPV_{\\text{naive}}(Pmt,r,n) \\;=\\; Pmt \\times \\frac{1 - (1+r)^{-n}}{r},\n$$\nwith the convention $PV_{\\text{naive}}(Pmt,0,n) = Pmt \\times n$.\n\n- A Taylor series approximation centered at $r=0$, truncated after the $r^4$ term. Define\n$$\nA_4(r,n) \\;=\\; n \\;-\\; \\frac{n(n+1)}{2}\\,r \\;+\\; \\frac{n(n+1)(n+2)}{6}\\,r^2 \\;-\\; \\frac{n(n+1)(n+2)(n+3)}{24}\\,r^3 \\;+\\; \\frac{n(n+1)(n+2)(n+3)(n+4)}{120}\\,r^4,\n$$\nand set\n$$\nPV_{\\text{series4}}(Pmt,r,n) \\;=\\; Pmt \\times \\begin{cases}\nA_4(r,n), & r \\neq 0,\\\\[6pt]\nn, & r = 0.\n\\end{cases}\n$$\n\nFor each test case below, compute the mathematically exact $PV(Pmt,r,n)$ as defined above (interpreted as a real-valued function with the $r=0$ case given by the limit), then compute the absolute errors\n$$\nE_{\\text{naive}} \\;=\\; \\big| PV_{\\text{naive}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|,\n\\qquad\nE_{\\text{series4}} \\;=\\; \\big| PV_{\\text{series4}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|.\n$$\nAlso report a boolean value indicating whether the truncated Taylor series yields a smaller absolute error than the direct formula, i.e., whether $E_{\\text{series4}} < E_{\\text{naive}}$.\n\nAll interest rates must be provided and interpreted as decimals (for example, $r=0.05$ means five-hundredths). There are no physical units; payments and present values are pure numbers. Your program must produce floating-point results rounded to $12$ decimal places.\n\nUse the following test suite of parameter triples $(Pmt, r, n)$:\n\n- Test $1$: $(100.0,\\; 0.05,\\; 30)$.\n- Test $2$: $(100.0,\\; 10^{-8},\\; 360)$.\n- Test $3$: $(100.0,\\; 0,\\; 360)$.\n- Test $4$: $(100.0,\\; -10^{-8},\\; 360)$.\n- Test $5$: $(1000.0,\\; 10^{-4},\\; 10000)$.\n- Test $6$: $(250.0,\\; 10^{-12},\\; 100)$.\n- Test $7$: $(500.0,\\; 0.15,\\; 10)$.\n\nRequired final output format: A single line containing a list with one entry per test case, preserving the test order. Each entry must be a list of the form $[E_{\\text{naive}}, E_{\\text{series4}}, \\text{series\\_better}]$, where the first two components are floats rounded to $12$ decimal places and the third component is a boolean indicating whether $E_{\\text{series4}} < E_{\\text{naive}}$. The list must be printed as a single line with no spaces, for example:\n$$\n\\text{[[0.000000000000,0.000000000000,True],[\\dots],[\\dots],\\dots]}\n$$",
            "solution": "The user's problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Present Value Function for a Level Annuity**:\n$$\nPV(Pmt,r,n) \\;=\\; Pmt \\times \\begin{cases}\n\\dfrac{1 - (1+r)^{-n}}{r}, & r \\neq 0,\\\\[6pt]\nn, & r = 0.\n\\end{cases}\n$$\nwhere $Pmt$ is the per-period payment, $r$ is the per-period effective interest rate, and $n \\in \\mathbb{N}$ is the number of payments.\n\n- **Naive Approximation**:\n$$\nPV_{\\text{naive}}(Pmt,r,n) \\;=\\; Pmt \\times \\frac{1 - (1+r)^{-n}}{r}, \\quad (\\text{with } PV_{\\text{naive}}(Pmt,0,n) = Pmt \\times n)\n$$\n\n- **Fourth-Order Taylor Series Approximation**:\n$$\nPV_{\\text{series4}}(Pmt,r,n) \\;=\\; Pmt \\times A_4(r,n), \\quad (\\text{with } PV_{\\text{series4}}(Pmt,0,n) = Pmt \\times n)\n$$\nwhere the annuity factor approximation $A_4(r,n)$ is given by:\n$$\nA_4(r,n) \\;=\\; n \\;-\\; \\frac{n(n+1)}{2}\\,r \\;+\\; \\frac{n(n+1)(n+2)}{6}\\,r^2 \\;-\\; \\frac{n(n+1)(n+2)(n+3)}{24}\\,r^3 \\;+\\; \\frac{n(n+1)(n+2)(n+3)(n+4)}{120}\\,r^4\n$$\n\n- **Error Metrics**:\n$$\nE_{\\text{naive}} \\;=\\; \\big| PV_{\\text{naive}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|\n$$\n$$\nE_{\\text{series4}} \\;=\\; \\big| PV_{\\text{series4}}(Pmt,r,n) \\;-\\; PV(Pmt,r,n) \\big|\n$$\n\n- **Comparison**: A boolean value indicating if $E_{\\text{series4}} < E_{\\text{naive}}$.\n\n- **Test Cases**: A suite of seven parameter triples $(Pmt, r, n)$:\n  1. $(100.0,\\; 0.05,\\; 30)$\n  2. $(100.0,\\; 10^{-8},\\; 360)$\n  3. $(100.0,\\; 0,\\; 360)$\n  4. $(100.0,\\; -10^{-8},\\; 360)$\n  5. $(1000.0,\\; 10^{-4},\\; 10000)$\n  6. $(250.0,\\; 10^{-12},\\; 100)$\n  7. $(500.0,\\; 0.15,\\; 10)$\n\n- **Formatting**: Results must be floating-point numbers rounded to $12$ decimal places. The output must be a single-line list of lists of the form $[E_{\\text{naive}}, E_{\\text{series4}}, \\text{series\\_better}]$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is based on the standard financial formula for the present value of an annuity. The core of the problem addresses the issue of numerical instability (catastrophic cancellation) when evaluating this formula for interest rates $r$ near zero. This is a classic, well-understood topic in numerical analysis. The use of a Taylor series expansion as a remedy is a standard and correct technique. The provided Taylor series coefficients are mathematically correct, derived from the Maclaurin series of the annuity factor $(1-(1+r)^{-n})/r$. Therefore, the problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. All functions, variables, and objectives are clearly and unambiguously defined. The test cases are provided, and the expected output format is specified precisely, ensuring a unique and verifiable solution exists.\n- **Objective**: The problem statement is objective and devoid of subjective or speculative content. It presents a purely formal computational task.\n- **Completeness and Consistency**: The problem is self-contained. All necessary formulas and data are provided. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Principle-Based Design\nThe solution is designed based on principles of numerical analysis to address the instability of financial formulas in finite-precision arithmetic.\n\n1.  **The Problem of Catastrophic Cancellation**: The \"naive\" formula for the present value annuity factor, $A(r,n) = \\frac{1 - (1+r)^{-n}}{r}$, is numerically unstable as $r \\to 0$. In floating-point arithmetic, when $r$ is very small, $(1+r)$ is very close to $1$, and consequently $(1+r)^{-n}$ is also very close to $1$. The subtraction in the numerator, $1 - (1+r)^{-n}$, involves two nearly identical numbers. This operation, known as catastrophic cancellation, results in a significant loss of relative precision, yielding an inaccurate result.\n\n2.  **Establishing a High-Precision Benchmark**: To quantify the error of the naive formula, a \"ground truth\" or benchmark value, denoted $PV(Pmt,r,n)$ in the problem, must be computed with high accuracy. This can be achieved by algebraically reformulating the expression to avoid the problematic subtraction. Using the identities $x = \\exp(\\ln x)$, `log1p(x)` for $\\ln(1+x)$, and `expm1(x)` for $e^x - 1$, we can rewrite the annuity factor $A(r,n)$ as:\n    $$\n    A(r,n) = \\frac{1 - (1+r)^{-n}}{r} = \\frac{1 - \\exp(-n \\ln(1+r))}{r} = \\frac{-(\\exp(-n \\ln(1+r)) - 1)}{r}\n    $$\n    This expression can be computed accurately using the `numpy.log1p` and `numpy.expm1` functions, which are specifically designed to maintain high precision for small arguments. This stable calculation serves as our `PV_exact`.\n\n3.  **Taylor Series Approximation**: An alternative to reformulation is to approximate the function near the problematic point. For $r \\approx 0$, the annuity factor $A(r,n)$ can be approximated by its Maclaurin (Taylor series at $r=0$) expansion. The problem provides this expansion truncated to the fourth-order term, $A_4(r,n)$. This polynomial approximation avoids the subtraction of nearly equal terms and is expected to be highly accurate for values of $r$ very close to zero. The error of this method, $E_{\\text{series4}}$, is a truncation error, which depends on the magnitude of the first neglected term in the series.\n\n4.  **Algorithmic Implementation**: The algorithm proceeds as follows for each test case $(Pmt, r, n)$:\n    -   The special case of $r=0$ is handled first. As per the problem definition, $PV_{\\text{exact}}$, $PV_{\\text{naive}}$, and $PV_{\\text{series4}}$ all equal $Pmt \\times n$. Thus, both errors are $0.0$, and the comparison $E_{\\text{series4}} < E_{\\text{naive}}$ is `False`.\n    -   For $r \\neq 0$:\n        a.  `PV_exact` is calculated using the stable `log1p`/`expm1` formulation.\n        b.  `PV_naive` is calculated using the direct formula.\n        c.  `PV_series4` is calculated by evaluating the provided polynomial $A_4(r,n)$. To enhance numerical stability and efficiency, the polynomial is evaluated using Horner's method. The coefficients of the polynomial are calculated recursively to avoid manipulating large numbers, e.g., $c_k = c_{k-1} \\times (-(n+k)/ (k+1))$.\n        d.  The absolute errors $E_{\\text{naive}} = |PV_{\\text{naive}} - PV_{\\text{exact}}|$ and $E_{\\text{series4}} = |PV_{\\text{series4}} - PV_{\\text{exact}}|$ are computed.\n        e.  The boolean value $E_{\\text{series4}} < E_{\\text{naive}}$ is determined.\n    -   The final numerical results are formatted to $12$ decimal places as fixed-point numbers before being added to the final output list. This ensures compliance with the specified output format.\nThis approach systematically evaluates and compares the numerical properties of the different computational methods, demonstrating a fundamental concept in computational science.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical errors of two approximations for the\n    present value of an annuity, demonstrating the effects of catastrophic\n    cancellation for interest rates near zero.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 0.05, 30),\n        (100.0, 1e-8, 360),\n        (100.0, 0.0, 360),\n        (100.0, -1e-8, 360),\n        (1000.0, 1e-4, 10000),\n        (250.0, 1e-12, 100),\n        (500.0, 0.15, 10),\n    ]\n\n    all_results = []\n    for Pmt, r, n in test_cases:\n        # The case r=0 is defined specifically.\n        if r == 0.0:\n            e_naive = 0.0\n            e_series4 = 0.0\n            # 0.0 < 0.0 is False.\n            series_better = False\n            all_results.append([e_naive, e_series4, series_better])\n            continue\n\n        # Convert n to float for calculations to ensure float arithmetic throughout.\n        n_f = float(n)\n\n        # 1. Calculate PV_exact (high-precision benchmark).\n        # This uses numerically stable functions to avoid cancellation error.\n        # PV = Pmt * (1 - (1+r)^-n) / r = Pmt * -(exp(-n*log(1+r)) - 1) / r\n        pv_exact = Pmt * (-np.expm1(-n_f * np.log1p(r))) / r\n\n        # 2. Calculate PV_naive using the direct formula.\n        # This is prone to catastrophic cancellation for small r.\n        pv_naive = Pmt * (1.0 - (1.0 + r)**(-n_f)) / r\n\n        # 3. Calculate PV_series4 using the Taylor expansion.\n        # This is an approximation whose accuracy depends on r and the order of truncation.\n        # Coefficients are calculated recursively for stability.\n        c0 = n_f\n        c1 = -n_f * (n_f + 1.0) / 2.0\n        c2 = -c1 * (n_f + 2.0) / 3.0\n        c3 = -c2 * (n_f + 3.0) / 4.0\n        c4 = -c3 * (n_f + 4.0) / 5.0\n        \n        # Evaluate polynomial using Horner's method for efficiency and stability.\n        a4 = c0 + r * (c1 + r * (c2 + r * (c3 + r * c4)))\n        pv_series4 = Pmt * a4\n\n        # 4. Calculate absolute errors.\n        e_naive = abs(pv_naive - pv_exact)\n        e_series4 = abs(pv_series4 - pv_exact)\n        \n        # 5. Compare errors.\n        series_better = e_series4 < e_naive\n\n        all_results.append([e_naive, e_series4, series_better])\n\n    # Final print statement in the exact required format.\n    output_parts = []\n    for e_n, e_s, better in all_results:\n        # Format the float values to 12 decimal places, fixed-point notation.\n        part = f\"[{e_n:.12f},{e_s:.12f},{str(better)}]\"\n        output_parts.append(part)\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Effective capital budgeting requires not just calculation, but sound judgment based on reliable metrics. This practice explores a common pitfall with the Internal Rate of Return (IRR) when evaluating projects with non-conventional cash flows, such as those with large terminal costs. By analyzing a project with multiple sign changes in its cash flow stream, you will discover why the IRR can be ambiguous and how the Modified Internal Rate of Return (MIRR) provides a more consistent and trustworthy tool for making investment decisions .",
            "id": "2444465",
            "problem": "A strip-mining project has the following end-of-period cash flows in million monetary units (MMU) at times $t=0,1,2,3,4$: $C_0=-1{,}000$, $C_1=+1{,}200$, $C_2=+1{,}200$, $C_3=+1{,}200$, and a large environmental remediation outlay $C_4=-2{,}700$. The firm’s cost of capital (used both as the finance rate for negative cash flows and the reinvestment rate for positive cash flows when computing the Modified Internal Rate of Return) is $10\\%$.\n\nWhich statement about the Internal Rate(s) of Return (IRR) and the Modified Internal Rate of Return (MIRR) for this project is correct?\n\nA. The project has a unique IRR approximately equal to $11.3\\%$, which is also its MIRR; since this roughly equals the $10\\%$ cost of capital, the project is marginal.\n\nB. The project exhibits two IRRs, approximately $3.2\\%$ and $77.6\\%$. The MIRR at a $10\\%$ finance and reinvestment rate is approximately $11.3\\%$, and the Net Present Value (NPV) at $10\\%$ is positive; MIRR provides a unique, decision-consistent summary here despite multiple IRRs.\n\nC. The project has no IRR because the NPV is negative at all discount rates; the MIRR is negative as well.\n\nD. The project has two IRRs, approximately $-3\\%$ and $30\\%$; the MIRR always equals the cost of capital $10\\%$ by construction, so the multiple-IRR issue is irrelevant.",
            "solution": "Define the Net Present Value (NPV) at discount rate $r$ by\n$$\n\\text{NPV}(r)\\;=\\;-1{,}000\\;+\\;\\frac{1{,}200}{(1+r)^1}\\;+\\;\\frac{1{,}200}{(1+r)^2}\\;+\\;\\frac{1{,}200}{(1+r)^3}\\;-\\;\\frac{2{,}700}{(1+r)^4}.\n$$\nBy definition, an Internal Rate of Return (IRR) is any $r$ that satisfies $\\text{NPV}(r)=0$. Because the sign pattern of the cash flows is $(-,+,+,+,-)$, there are two sign changes, so by Descartes’ rule of signs there can be $0$ or $2$ positive IRRs. The Modified Internal Rate of Return (MIRR) at finance rate $f$ and reinvestment rate $g$ is defined by equating the future value (at the horizon) of positive cash flows compounded at $g$ to the present value (at $t=0$) of negative cash flows discounted at $f$, grown over $n$ periods:\n$$\n\\text{MIRR}\\;=\\;\\left(\\frac{\\text{FV of positive cash flows at }g}{\\text{PV of negative cash flows at }f}\\right)^{1/n}-1,\n$$\nwith $n=4$ here.\n\nStep 1: Determine the sign of $\\text{NPV}(r)$ at benchmark rates and bracket IRR roots.\n\n- At $r=0$, $\\text{NPV}(0)= -1{,}000+1{,}200+1{,}200+1{,}200-2{,}700=-100<0$.\n\n- At $r=0.10$, compute each present value:\n$\\frac{1{,}200}{1.1}=1{,}090.909$, $\\frac{1{,}200}{1.1^2}=\\frac{1{,}200}{1.21}=991.736$, $\\frac{1{,}200}{1.1^3}=\\frac{1{,}200}{1.331}\\approx 901.580$, and $\\frac{2{,}700}{1.1^4}=\\frac{2{,}700}{1.4641}\\approx 1{,}843.277$.\nThus,\n$$\n\\text{NPV}(0.10)\\approx -1{,}000+(1{,}090.909+991.736+901.580)-1{,}843.277\\approx 140.95>0.\n$$\nSince $\\text{NPV}(0)<0$ and $\\text{NPV}(0.10)>0$, there is at least one IRR in $(0,0.10)$.\n\n- At $r=0.78$, with $1+r=1.78$, we have $(1+r)^2=3.1684$, $(1+r)^3\\approx 5.6398$, $(1+r)^4\\approx 10.0359$. Then\n$\\frac{1{,}200}{1.78}\\approx 674.157$, $\\frac{1{,}200}{3.1684}\\approx 378.904$, $\\frac{1{,}200}{5.6398}\\approx 212.796$, $\\frac{2{,}700}{10.0359}\\approx 268.93$.\nHence\n$$\n\\text{NPV}(0.78)\\approx -1{,}000+(674.157+378.904+212.796)-268.93\\approx -3.07<0.\n$$\n\n- At $r=0.77$, with $1+r=1.77$, $(1+r)^2=3.1329$, $(1+r)^3\\approx 5.545$, $(1+r)^4\\approx 9.815$. Then\n$\\frac{1{,}200}{1.77}\\approx 677.966$, $\\frac{1{,}200}{3.1329}\\approx 382.900$, $\\frac{1{,}200}{5.545}\\approx 216.460$, $\\frac{2{,}700}{9.815}\\approx 274.97$.\nThus\n$$\n\\text{NPV}(0.77)\\approx -1{,}000+(677.966+382.900+216.460)-274.97\\approx 2.36>0.\n$$\nSince $\\text{NPV}(0.77)>0$ and $\\text{NPV}(0.78)<0$, a second IRR lies in $(0.77,0.78)$.\n\nTo refine the low IRR, evaluate near $r=0.031$ and $r=0.032$:\n\n- At $r=0.031$, $(1+r)=1.031$, $(1+r)^2\\approx 1.063$, $(1+r)^3\\approx 1.095$, $(1+r)^4\\approx 1.128$. Then\n$\\frac{1{,}200}{1.031}\\approx 1{,}164.89$, $\\frac{1{,}200}{1.063}\\approx 1{,}128.53$, $\\frac{1{,}200}{1.095}\\approx 1{,}095.89$, $\\frac{2{,}700}{1.128}\\approx 2{,}392.0$.\nHence\n$$\n\\text{NPV}(0.031)\\approx -1{,}000}+(1{,}164.89+1{,}128.53+1{,}095.89)-2{,}392.0\\approx -2.69<0.\n$$\n\n- At $r=0.032$, $(1+r)=1.032$, $(1+r)^2\\approx 1.0650$, $(1+r)^3\\approx 1.0981$, $(1+r)^4\\approx 1.1343$. Then\n$\\frac{1{,}200}{1.032}\\approx 1{,}162.79$, $\\frac{1{,}200}{1.0650}\\approx 1{,}126.76$, $\\frac{1{,}200}{1.0981}\\approx 1{,}092.86$, $\\frac{2{,}700}{1.1343}\\approx 2{,}380.5$.\nThus\n$$\n\\text{NPV}(0.032)\\approx -1{,}000}+(1{,}162.79+1{,}126.76+1{,}092.86)-2{,}380.5\\approx 1.91>0.\n$$\nTherefore, the small IRR is approximately $r\\approx 3.2\\%$. The large IRR, by the bracketing above, is approximately $r\\approx 77.6\\%$ (refined numerically from the interval $(0.77,0.78)$).\n\nStep 2: Compute the MIRR at finance rate $f=10\\%$ and reinvestment rate $g=10\\%$ with $n=4$.\n\n- Present value of negative cash flows at $f=10\\%$:\n$$\n\\text{PV}_{-} = 1{,}000+\\frac{2{,}700}{(1.10)^4}=1{,}000+\\frac{2{,}700}{1.4641}\\approx 1{,}000+1{,}843.277=2{,}843.277.\n$$\n\n- Future value at $t=4$ of positive cash flows compounded at $g=10\\%$:\n$$\n\\text{FV}_{+} = 1{,}200(1.10)^3+1{,}200(1.10)^2+1{,}200(1.10)=1{,}200(1.331+1.21+1.10)=1{,}200(3.641)=4{,}369.2.\n$$\n\n- MIRR:\n$$\n\\text{MIRR}=\\left(\\frac{\\text{FV}_{+}}{\\text{PV}_{-}}\\right)^{1/4}-1=\\left(\\frac{4{,}369.2}{2{,}843.277}\\right)^{1/4}-1\\approx (1.5362)^{0.25}-1\\approx 0.113\\;\\text{or}\\;11.3\\%.\n$$\n\nStep 3: Check NPV at $10\\%$ to align the decision with MIRR:\nFrom the computation above,\n$$\n\\text{NPV}(0.10)\\approx 140.95>0,\n$$\nso at the cost of capital $10\\%$ the project is value-adding by the NPV criterion. The MIRR of approximately $11.3\\%$ exceeds the $10\\%$ hurdle, yielding the same accept/reject decision. In contrast, the existence of two IRRs ($\\approx 3.2\\%$ and $\\approx 77.6\\%$) makes the unmodified IRR criterion ambiguous.\n\nOption-by-option analysis:\n\n- Option A: States a unique IRR equal to approximately $11.3\\%$ and equal to MIRR. This is incorrect. The cash-flow pattern $(-,+,+,+,-)$ admits two IRRs, and the computed MIRR $\\approx 11.3\\%$ is not an IRR.\n\n- Option B: Reports two IRRs close to $3.2\\%$ and $77.6\\%$, a MIRR near $11.3\\%$, and notes that NPV at $10\\%$ is positive and MIRR provides a unique, decision-consistent summary. This matches the calculations and is correct.\n\n- Option C: Claims no IRR and negative MIRR. This contradicts both the bracketing showing two IRRs and the computed positive MIRR.\n\n- Option D: Gives implausible IRR values ($-3\\%$ and $30\\%$) and claims MIRR always equals the cost of capital. MIRR equals the cost of capital only under special cash-flow configurations, not by construction in general; here MIRR $\\approx 11.3\\%\\neq 10\\%$. This is incorrect.\n\nTherefore, the correct choice is Option B.",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}