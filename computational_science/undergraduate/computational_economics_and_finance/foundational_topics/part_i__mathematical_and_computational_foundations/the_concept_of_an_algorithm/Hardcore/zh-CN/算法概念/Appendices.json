{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个实践练习将引导你迈出算法思维的第一步：将一个经典的经济决策问题形式化。通过将风险中性代理人的预期收益最大化过程转化为一个精确、确定性的算法 ()，我们将明确地推导出决策的临界条件。这个练习旨在阐明，即使是复杂的行为也可以被分解为具有明确输入、处理规则和输出的算法。",
            "id": "2438853",
            "problem": "在一个与计算经济学和金融学相关的简单微观经济决策模型中，考虑一个风险中性的代理人。该代理人正在考虑是否实施一项白领犯罪行为，若未被发现则可获得货币收益，若被发现则会受到货币惩罚。设决策算法的输入为三元组 $\\left(p, V, C\\right)$，其中 $p \\in [0,1]$ 是被发现的概率，$V>0$ 是仅在未被发现时实现的收益，而 $C>0$ 是仅在被发现时产生的惩罚。如果代理人不实施该行为，货币支付为 $0$。如果代理人实施该行为，则有 $1-p$ 的概率获得货币支付 $V$，有 $p$ 的概率获得货币支付 $-C$。该代理人是风险中性的，其目标是最大化期望货币支付。\n\n将代理人的决策建模为一个确定性算法 $f$，该算法将输入 $\\left(p, V, C\\right)$ 映射到一个二元行动 $f\\left(p,V,C\\right) \\in \\{0,1\\}$，其中 $f\\left(p,V,C\\right)=1$ 表示选择实施，$f\\left(p,V,C\\right)=0$ 表示放弃。通过实施与放弃之间的无差异条件来定义算法决策边界，并推导出最大侦查概率 $p^{\\ast}$（仅作为 $V$ 和 $C$ 的函数）的闭式表达式，使得当且仅当 $p \\le p^{\\ast}$ 时，$f\\left(p,V,C\\right)=1$。\n\n请以 $V$ 和 $C$ 表示的单个闭式解析表达式的形式提供您的最终答案。不需要数值近似或四舍五入。",
            "solution": "该问题要求将一个决策问题表示为一个算法，并根据一个依赖于 $V$ 和 $C$ 的阈值概率 $p^{\\ast}$ 来刻画决策边界。基本原则是风险中性下的期望支付最大化。\n\n令实施行为的期望支付为 $\\mathbb{E}\\left[\\Pi_{\\text{commit}}\\right]$，放弃行为的期望支付为 $\\mathbb{E}\\left[\\Pi_{\\text{abstain}}\\right]$。根据设定，放弃的支付为 $0$，因此\n$$\n\\mathbb{E}\\left[\\Pi_{\\text{abstain}}\\right] = 0.\n$$\n如果代理人实施该行为，支付为 $V$ 的概率是 $1-p$，支付为 $-C$ 的概率是 $p$。因此，根据全期望定律，\n$$\n\\mathbb{E}\\left[\\Pi_{\\text{commit}}\\right] = (1-p)\\cdot V + p \\cdot (-C) = V - p\\left(V + C\\right).\n$$\n\n如果实施行为的期望支付不小于放弃行为的期望支付，则算法 $f\\left(p,V,C\\right)$ 返回 $1$（实施）；否则返回 $0$（放弃）。因此，定义两种行为之间边界的无差异条件是\n$$\n\\mathbb{E}\\left[\\Pi_{\\text{commit}}\\right] = \\mathbb{E}\\left[\\Pi_{\\text{abstain}}\\right].\n$$\n代入以上表达式可得\n$$\nV - p\\left(V + C\\right) = 0.\n$$\n对 $p$ 求解，得到阈值侦查概率 $p^{\\ast}$：\n$$\np^{\\ast} = \\frac{V}{V + C}.\n$$\n\n那么，该算法的决策规则可以表述为：对于给定的输入 $\\left(p,V,C\\right)$（其中 $V>0$ 且 $C>0$），当且仅当 $p \\le p^{\\ast}$ 时选择实施，其中 $p^{\\ast}$ 是使代理人处于无差异状态的最大侦查概率。所要求的以 $V$ 和 $C$ 表示的 $p^{\\ast}$ 的闭式表达式是\n$$\np^{\\ast} = \\frac{V}{V + C}.\n$$",
            "answer": "$$\\boxed{\\frac{V}{V+C}}$$"
        },
        {
            "introduction": "在掌握了如何将决策规则形式化之后，我们进入一个更具挑战性的任务：设计一个主动寻求目标的算法。这个问题 () 模拟了一个在金融科技中日益重要的场景，即“算法纠正”（algorithmic recourse）。你将设计一个贪心算法——这是算法设计中的一个基本范式——来找到改变贷款申请以获得批准的最低成本路径，这需要你运用经济学中边际分析的核心思想。",
            "id": "2438838",
            "problem": "给定一个信用审批决策的形式化表述以及一个相关的最小侵入性、合理编辑的贷款申请概念。设特征向量为$\\mathbf{x} \\in \\mathbb{R}^d$，权重向量为$\\mathbf{w} \\in \\mathbb{R}^d$，截距为$b \\in \\mathbb{R}$。信用评分规则是一个确定性分类器，当且仅当$\\mathbf{w}^\\top \\mathbf{x} + b \\ge 0$时批准申请，否则拒绝。一个对抗性编辑是一个向量$\\boldsymbol{\\delta} \\in \\mathbb{R}^d$，它产生一个修改后的申请$\\mathbf{x} + \\boldsymbol{\\delta}$。\n\n一个变更是合理的，当且仅当它满足以下所有约束：\n- 对于每个特征索引$i \\in \\{0,1,\\dots,d-1\\}$，编辑后的值必须在$l_i \\le x_i + \\delta_i \\le u_i$的范围内，其中$\\mathbf{l}, \\mathbf{u} \\in \\mathbb{R}^d$且$l_i \\le u_i$。\n- 对于每个不可变特征索引$i \\in \\mathcal{I} \\subseteq \\{0,1,\\dots,d-1\\}$，变更必须等于$\\delta_i = 0$。\n- 编辑的目标成本由一个非负成本向量$\\mathbf{c} \\in \\mathbb{R}^d_{\\ge 0}$定义为加权$\\ell_1$范数$C(\\boldsymbol{\\delta}) = \\sum_{i=0}^{d-1} c_i |\\delta_i|$。\n\n您的任务是设计一个算法，对于给定的实例$(\\mathbf{w}, b, \\mathbf{x}, \\mathbf{l}, \\mathbf{u}, \\mathbf{c}, \\mathcal{I})$，计算所有能使申请获得批准的合理编辑$\\boldsymbol{\\delta}$（即满足$\\mathbf{w}^\\top (\\mathbf{x} + \\boldsymbol{\\delta}) + b \\ge 0$）中的最小成本$C^\\star$。如果原始申请已被批准，则最小成本为$0.0$。如果没有合理的编辑可以使申请获得批准，则返回$-1.0$。\n\n将此算法实现为一个完整的、可运行的程序，该程序不接受任何输入，并评估以下固定的测试套件。在所有情况下，索引都是基于0的，并且所有向量都按坐标顺序$(0,1,\\dots,d-1)$列出。\n\n测试套件（每个案例指定$(\\mathbf{w}, b, \\mathbf{x}, \\mathbf{l}, \\mathbf{u}, \\mathbf{c}, \\mathcal{I})$）：\n- 案例 A:\n  - $\\mathbf{w} = (1.0,\\, 0.5,\\, -0.2)$, $b = -0.5$,\n  - $\\mathbf{x} = (0.0,\\, 0.0,\\, 0.0)$,\n  - $\\mathbf{l} = (0.0,\\, -1.0,\\, -1.0)$, $\\mathbf{u} = (2.0,\\, 2.0,\\, 1.0)$,\n  - $\\mathbf{c} = (1.0,\\, 2.0,\\, 1.0)$,\n  - $\\mathcal{I} = \\varnothing$。\n- 案例 B:\n  - $\\mathbf{w} = (1.0,\\, 1.0)$, $b = -1.0$,\n  - $\\mathbf{x} = (0.6,\\, 0.6)$,\n  - $\\mathbf{l} = (0.0,\\, 0.0)$, $\\mathbf{u} = (1.0,\\, 1.0)$,\n  - $\\mathbf{c} = (1.0,\\, 1.0)$,\n  - $\\mathcal{I} = \\varnothing$。\n- 案例 C:\n  - $\\mathbf{w} = (0.1,\\, 0.1)$, $b = -5.0$,\n  - $\\mathbf{x} = (0.0,\\, 0.0)$,\n  - $\\mathbf{l} = (0.0,\\, 0.0)$, $\\mathbf{u} = (10.0,\\, 10.0)$,\n  - $\\mathbf{c} = (1.0,\\, 1.0)$,\n  - $\\mathcal{I} = \\varnothing$。\n- 案例 D:\n  - $\\mathbf{w} = (1.0,\\, 0.5)$, $b = -0.4$,\n  - $\\mathbf{x} = (0.0,\\, 0.0)$,\n  - $\\mathbf{l} = (0.0,\\, 0.0)$, $\\mathbf{u} = (0.1,\\, 2.0)$,\n  - $\\mathbf{c} = (0.1,\\, 10.0)$,\n  - $\\mathcal{I} = \\{0\\}$。\n- 案例 E:\n  - $\\mathbf{w} = (-1.0)$, $b = -0.4$,\n  - $\\mathbf{x} = (0.0)$,\n  - $\\mathbf{l} = (-1.0)$, $\\mathbf{u} = (1.0)$,\n  - $\\mathbf{c} = (3.0)$,\n  - $\\mathcal{I} = \\varnothing$。\n\n答案规格：\n- 对于每个案例，计算一个实数，该实数等于获得批准的合理编辑的最小成本$C^\\star$。按照惯例，如果申请已被批准，则答案为$0.0$；如果在约束下无法获得批准，则答案为$-1.0$。\n- 报告每个结果，四舍五入到$6$位小数。\n- 最终输出格式：您的程序应生成单行文本，其中包含案例A到E的结果，按此顺序排列，形式为一个逗号分隔的列表，并用方括号括起来，不含空格，例如$[\\alpha,\\beta,\\gamma,\\delta,\\epsilon]$，其中每个符号是对应案例的四舍五入结果。",
            "solution": "问题陈述是有效的。这是一个适定、有科学依据的优化问题，没有矛盾、歧义和未经证实的论断。它属于计算金融学和算法追索的领域，后者是计算经济学的一个子领域。现在我将提供正式的解决方案。\n\n任务是找到对特征向量$\\mathbf{x} \\in \\mathbb{R}^d$进行编辑的向量$\\boldsymbol{\\delta} \\in \\mathbb{R}^d$的最小成本$C^\\star$，以使线性分类器的决策边界被跨越。成本函数是加权$\\ell_1$范数$C(\\boldsymbol{\\delta}) = \\sum_{i=0}^{d-1} c_i |\\delta_i|$。该优化问题可以表述如下：\n$$\n\\begin{align*}\n\\text{最小化} \\quad  C(\\boldsymbol{\\delta}) = \\sum_{i=0}^{d-1} c_i |\\delta_i| \\\\\n\\text{约束条件} \\quad  \\mathbf{w}^\\top (\\mathbf{x} + \\boldsymbol{\\delta}) + b \\ge 0 \\\\\n l_i \\le x_i + \\delta_i \\le u_i \\quad \\forall i \\in \\{0, 1, \\dots, d-1\\} \\\\\n \\delta_i = 0 \\quad \\forall i \\in \\mathcal{I}\n\\end{align*}\n$$\n\n首先，我们处理平凡情况。如果原始申请$\\mathbf{x}$已被批准，则得分$S_{\\text{initial}} = \\mathbf{w}^\\top \\mathbf{x} + b$为非负，即$S_{\\text{initial}} \\ge 0$。通过选择$\\boldsymbol{\\delta} = \\mathbf{0}$（这是一个合理的编辑），达到批准状态的最小成本显然为$0$。\n\n如果申请被拒绝，则$S_{\\text{initial}} < 0$。我们必须找到一个$\\boldsymbol{\\delta}$来满足约束条件。批准约束可以重写为$\\mathbf{w}^\\top \\boldsymbol{\\delta} \\ge -(\\mathbf{w}^\\top \\mathbf{x} + b)$。设$S_{\\text{needed}} = -S_{\\text{initial}} > 0$。优化问题是在最小成本下实现总分增加至少$S_{\\text{needed}}$。对于每个可变特征$i \\notin \\mathcal{I}$，对$\\delta_i$的约束是$l_i - x_i \\le \\delta_i \\le u_i - x_i$。\n\n该问题有一个凸目标函数（加权$\\ell_1$范数）和一个由线性不等式定义的可行域（一个凸多胞体）。因此，如果可行域非空，则存在唯一的最小值。该问题的结构类似于连续背包问题，它允许精确的贪心解。\n\n贪心策略的核心是优先改变那些每单位成本能提供最大得分增益的特征。必须为每个特征计算这种“效率”或逆边际成本。为了增加得分$\\mathbf{w}^\\top\\boldsymbol{\\delta}$， $w_i \\delta_i$的符号必须为正。这意味着对于任何有正贡献的特征$i$，$\\text{sign}(\\delta_i) = \\text{sign}(w_i)$。\n\n让我们分析每个$w_i \\neq 0$的可变特征$i \\notin \\mathcal{I}$的潜在贡献：\n\\begin{itemize}\n    \\item 如果$w_i > 0$，我们必须有$\\delta_i > 0$。变化量受限于$0 < \\delta_i \\le u_i - x_i$。这只有在$u_i > x_i$时才可能。得分增益为$w_i \\delta_i$，成本为$c_i \\delta_i$。边际成本，即每单位得分增益的成本，是$c_i / w_i$。\n    \\item 如果$w_i < 0$，我们必须有$\\delta_i < 0$。变化量受限于$l_i - x_i \\le \\delta_i < 0$。这只有在$l_i < x_i$时才可能。得分增益为$w_i \\delta_i = |w_i| |\\delta_i|$，成本为$c_i |\\delta_i|$。边际成本是$c_i / |w_i| = c_i / (-w_i)$。\n\\end{itemize}\n在两种情况下，对于非零成本$c_i > 0$，边际成本是$c_i / |w_i|$。如果$c_i = 0$且$w_i \\ne 0$，则边际成本为$0$，这意味着可以免费获得得分。这种“免费”的变更应始终最先进行。\n\n算法如下：\n1.  计算初始得分$S_{\\text{initial}} = \\mathbf{w}^\\top \\mathbf{x} + b$。如果$S_{\\text{initial}} \\ge 0$，则成本为$0.0$。\n2.  否则，计算所需的得分增量$S_{\\text{needed}} = -S_{\\text{initial}}$。\n3.  对于每个能够贡献得分增益的可变特征$i \\notin \\mathcal{I}$（即$w_i > 0$且$u_i > x_i$，或$w_i < 0$且$l_i < x_i$），创建一个“行动”元组。每个行动代表一个特征的潜力，并包含其边际成本（$c_i/|w_i|$）、它能提供的最大得分增益以及与该最大增益相关的成本。\n    \\begin{itemize}\n        \\item 对于$w_i > 0$：最大得分增益为$w_i (u_i-x_i)$。\n        \\item 对于$w_i < 0$：最大得分增益为$w_i (l_i-x_i)$。\n    \\end{itemize}\n4.  在继续之前，检查是否不可能实现。将所有可用行动的最大可能得分增益相加。如果总和小于$S_{\\text{needed}}$，则无法获得批准，结果为$-1.0$。\n5.  按边际成本的升序对行动进行排序。这将最有效的变更放在前面。\n6.  遍历排序后的行动。对于每个行动，“购买”所需或可用的得分增益，取两者中的较小者。获得一定量得分增益所产生的成本就是该增益乘以该行动的边际成本。更新剩余所需得分和累计总成本。\n7.  继续此过程，直到达到所需的得分$S_{\\text{needed}}$。最终的累计成本即为最小成本$C^\\star$。\n\n这个贪心过程保证能找到最优解，因为每个特征贡献的边际成本是恒定的。我们实际上是在用具有不同价值与重量比（逆边际成本）的可分物品（得分增益）填充一个容量为$S_{\\text{needed}}$的“得分背包”，而最优策略总是先选择最佳比率的物品。",
            "answer": "```python\nimport numpy as np\n\ndef solve_case(w: np.ndarray, b: float, x: np.ndarray, l: np.ndarray, u: np.ndarray, c: np.ndarray, I: set) -> float:\n    \"\"\"\n    Computes the minimal cost for a plausible edit to achieve loan approval.\n    \"\"\"\n    # 1. Calculate initial score\n    initial_score = np.dot(w, x) + b\n    if initial_score >= 0.0:\n        return 0.0\n\n    score_needed = -initial_score\n\n    # 2. Build list of possible actions\n    actions = []\n    d = len(w)\n    for i in range(d):\n        if i in I:\n            continue\n        \n        wi = w[i]\n        ci = c[i]\n        \n        if wi == 0:\n            continue\n\n        if wi > 0:\n            # We need to increase x_i, so delta_i > 0\n            # Change is bounded by [max(0, l_i-x_i), u_i-x_i]\n            # We are interested in positive delta_i, so max change is u_i-x_i\n            max_delta = u[i] - x[i]\n            if max_delta > 0:\n                max_score_gain = wi * max_delta\n                # Handle c_i = 0 case, which means infinite efficiency (zero cost)\n                cost_per_score = ci / wi if ci > 0 else 0.0\n                actions.append({'cost_per_score': cost_per_score, 'max_gain': max_score_gain})\n        \n        elif wi < 0:\n            # We need to decrease x_i, so delta_i < 0\n            # Change is bounded by [l_i-x_i, min(0, u_i-x_i)]\n            # We are interested in negative delta_i, so max change (magnitude) is x_i - l_i\n            max_delta_magnitude = x[i] - l[i]\n            if max_delta_magnitude > 0:\n                # Actual delta is -(x_i - l_i) = l_i - x_i\n                max_score_gain = wi * (l[i] - x[i]) # both negative, product is positive\n                # Similarly handle c_i = 0\n                cost_per_score = ci / abs(wi) if ci > 0 else 0.0\n                actions.append({'cost_per_score': cost_per_score, 'max_gain': max_score_gain})\n    \n    # 3. Check for impossibility\n    max_possible_gain = sum(action['max_gain'] for action in actions)\n    if max_possible_gain < score_needed:\n        return -1.0\n        \n    # 4. Sort actions by cost-effectiveness (lowest cost per score first)\n    actions.sort(key=lambda p: p['cost_per_score'])\n    \n    # 5. Greedily apply actions\n    total_cost = 0.0\n    remaining_score_needed = score_needed\n    \n    for action in actions:\n        if remaining_score_needed <= 0:\n            break\n            \n        gain_from_this_action = min(remaining_score_needed, action['max_gain'])\n        cost_for_this_gain = gain_from_this_action * action['cost_per_score']\n        \n        total_cost += cost_for_this_gain\n        remaining_score_needed -= gain_from_this_action\n        \n    return total_cost\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            'w': [1.0, 0.5, -0.2], 'b': -0.5,\n            'x': [0.0, 0.0, 0.0],\n            'l': [0.0, -1.0, -1.0], 'u': [2.0, 2.0, 1.0],\n            'c': [1.0, 2.0, 1.0],\n            'I': []\n        },\n        # Case B\n        {\n            'w': [1.0, 1.0], 'b': -1.0,\n            'x': [0.6, 0.6],\n            'l': [0.0, 0.0], 'u': [1.0, 1.0],\n            'c': [1.0, 1.0],\n            'I': []\n        },\n        # Case C\n        {\n            'w': [0.1, 0.1], 'b': -5.0,\n            'x': [0.0, 0.0],\n            'l': [0.0, 0.0], 'u': [10.0, 10.0],\n            'c': [1.0, 1.0],\n            'I': []\n        },\n        # Case D\n        {\n            'w': [1.0, 0.5], 'b': -0.4,\n            'x': [0.0, 0.0],\n            'l': [0.0, 0.0], 'u': [0.1, 2.0],\n            'c': [0.1, 10.0],\n            'I': [0]\n        },\n        # Case E\n        {\n            'w': [-1.0], 'b': -0.4,\n            'x': [0.0],\n            'l': [-1.0], 'u': [1.0],\n            'c': [3.0],\n            'I': []\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w = np.array(case['w'])\n        b = case['b']\n        x = np.array(case['x'])\n        l = np.array(case['l'])\n        u = np.array(case['u'])\n        c = np.array(case['c'])\n        I = set(case['I'])\n        \n        result = solve_case(w, b, x, l, u, c, I)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的实践练习将批判性地审视简单算法的局限性。通过一个经典的资源开采模型 ()，你将实现并比较一个短视的贪心策略和一个具有远见的全局最优解。这个对比突显了在跨期决策中 foresight (前瞻性) 的重要性，并揭示了为什么在动态经济和金融问题中，局部最优选择往往不等于全局最优。",
            "id": "2438788",
            "problem": "考虑一个受计算经济学和金融学启发的有限期资源开采问题。一家公司拥有一个含有不可再生资源的矿山。时间是离散的，有 $T$ 个时期，由 $t \\in \\{1,\\dots,T\\}$ 索引。公司在每个时期选择开采量 $x_t$，受储量约束和特定时期的运营能力限制。设初始储量为 $S \\ge 0$。设各时期的产能上限为 $u_t \\ge 0$。设矿石品位（收入的一个乘数因子）为 $c_t \\ge 0$。设恒定产出价格为 $p \\ge 0$。设各时期的凸性开采成本为二次函数形式，其参数为 $a > 0$。设跨期贴现因子为 $\\beta \\in (0,1]$。利润以贴现单位计算。\n\n在时期 $t$ 开采 $x_t$ 的当期瞬时净收益由以下凹函数给出\n$$\nb_t(x_t) \\equiv p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2,\n$$\n总贴现净现值 (NPV) 为\n$$\n\\sum_{t=1}^T \\beta^{t-1}\\, b_t(x_t).\n$$\n\n可行性约束为\n$$\n0 \\le x_t \\le u_t \\quad \\text{for all } t, \\qquad \\sum_{t=1}^T x_t \\le S.\n$$\n\n您的任务是实现并比较两种算法：\n\n- 一种短视的贪心算法：在每个时期 $t$，它选择 $x_t$ 来最大化当前时期的 $b_t(x_t)$，仅受瞬时约束 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$ 的限制，其中 $s_t$ 是在做出时期 $t$ 决策之前的剩余储量。贪心算法忽略了除当前储量可行性之外对未来时期的任何影响。选择 $x_t$ 后，通过 $s_{t+1} = s_t - x_t$ 更新剩余储量，其中 $s_1 = S$。\n- 一种基于 Bellman 最优性原理的最优动态规划 (DP) 解法，该解法在所有约束条件下最大化总贴现净现值。您可以通过任何等效于求解有限期 DP 问题的正确算法来计算此最优解。\n\n对于这两种算法，计算贴现净现值\n$$\nV \\equiv \\sum_{t=1}^T \\beta^{t-1}\\, \\left(p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2\\right).\n$$\n\n实现一个程序，对于以下测试套件，为每组参数返回一个三元组，包括最优 NPV、贪心 NPV 以及一个相等指示符。如果两个 NPV 之间的绝对差值最多为 $10^{-6}$，则该指示符定义为 $1$，否则为 $0$。所有浮点输出必须四舍五入到 $6$ 位小数。\n\n测试套件（每个案例都是一个元组 $\\left(T,\\ \\beta,\\ p,\\ a,\\ S,\\ \\mathbf{c},\\ \\mathbf{u}\\right)$，其中 $\\mathbf{c}=(c_1,\\dots,c_T)$ 且 $\\mathbf{u}=(u_1,\\dots,u_T)$）：\n\n- 案例 1：$T=4$, $\\beta=0.95$, $p=2.0$, $a=2.0$, $S=6.0$, $\\mathbf{c}=(1.0,\\ 1.5,\\ 1.2,\\ 1.1)$, $\\mathbf{u}=(5.0,\\ 5.0,\\ 5.0,\\ 5.0)$。\n- 案例 2：$T=3$, $\\beta=0.98$, $p=1.0$, $a=1.0$, $S=3.0$, $\\mathbf{c}=(1.0,\\ 2.0,\\ 5.0)$, $\\mathbf{u}=(10.0,\\ 10.0,\\ 10.0)$。\n- 案例 3：$T=3$, $\\beta=0.5$, $p=1.0$, $a=1.0$, $S=3.0$, $\\mathbf{c}=(5.0,\\ 2.0,\\ 1.0)$, $\\mathbf{u}=(10.0,\\ 10.0,\\ 10.0)$。\n- 案例 4：$T=4$, $\\beta=0.99$, $p=1.0$, $a=1.0$, $S=1.5$, $\\mathbf{c}=(2.0,\\ 2.0,\\ 10.0,\\ 2.0)$, $\\mathbf{u}=(10.0,\\ 10.0,\\ 1.0,\\ 10.0)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序跨测试案例展平：对于案例 $i$，依次附加最优 NPV、贪心 NPV、相等指示符（按此顺序），所有数值均按规定四舍五入。例如，输出必须如下所示：\n$$\n[\\text{opt}_1,\\ \\text{greedy}_1,\\ \\text{eq}_1,\\ \\text{opt}_2,\\ \\text{greedy}_2,\\ \\text{eq}_2,\\ \\dots].\n$$",
            "solution": "首先对问题陈述进行严格的验证程序。\n\n**步骤1：提取已知信息**\n- **时间范围**：离散的，$T$ 个时期，$t \\in \\{1,\\dots,T\\}$。\n- **决策变量**：开采量 $x_t$。\n- **参数**：初始储量 $S \\ge 0$，各时期产能 $u_t \\ge 0$，矿石品位 $c_t \\ge 0$，产出价格 $p \\ge 0$，成本参数 $a > 0$，贴现因子 $\\beta \\in (0,1]$。\n- **目标函数**：最大化总贴现净现值 (NPV)，$V = \\sum_{t=1}^T \\beta^{t-1}\\, b_t(x_t)$，其中各时期净收益为 $b_t(x_t) \\equiv p\\,c_t\\,x_t - \\frac{a}{2}\\,x_t^2$。\n- **约束条件**：\n    1. 产能：对所有 $t$，$0 \\le x_t \\le u_t$。\n    2. 储量：$\\sum_{t=1}^T x_t \\le S$。\n- **算法**：\n    1. **贪心算法**：在每个时期 $t$，选择 $x_t$ 以最大化 $b_t(x_t)$，约束条件为 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$，其中 $s_t$ 是剩余储量。\n    2. **最优算法**：动态规划解法或等效方法，在所有约束条件下最大化总贴现 NPV。\n- **输出要求**：对于每个测试案例，提供一个三元组：（最优 NPV，贪心 NPV，相等指示符）。如果绝对差值 $\\le 10^{-6}$，则指示符为 $1$，否则为 $0$。输出必须四舍五入到 $6$ 位小数。测试案例已提供。\n\n**步骤2：验证**\n- **科学依据**：该问题是一个典型的有限期资源开采模型，是计算经济学和资源经济学中的一个基本课题。该模型基于已确立的经济学原理。它是有效的。\n- **适定性**：目标函数 $\\sum \\beta^{t-1} (p c_t x_t - \\frac{a}{2} x_t^2)$ 是关于向量 $\\mathbf{x} = (x_1, \\dots, x_T)$ 的严格凹函数，因为 $a>0$ 且 $\\beta>0$。由线性不等式定义的可行集是凸集和紧集。在一个非空、紧、凸集上最大化一个严格凹函数，其解是唯一的。该问题是适定的。\n- **客观性和完整性**：该问题使用精确的数学语言进行描述，并为给定的测试案例提供了所有必要的数据。它是有效的。\n\n**步骤3：结论**\n问题是有效的。我们继续进行求解。\n\n该问题要求实现并比较两种用于资源开采问题的算法。\n\n**贪心算法**\n贪心算法是短视的。在每个时期 $t$，它仅在当前约束条件下最大化当期收益 $b_t(x_t) = p c_t x_t - \\frac{a}{2} x_t^2$。函数 $b_t(x_t)$ 是一个开口向下的抛物线。其无约束最大值可以通过将其关于 $x_t$ 的导数设为零来找到：\n$$\n\\frac{d b_t(x_t)}{d x_t} = p c_t - a x_t = 0 \\implies x_t^* = \\frac{p c_t}{a}\n$$\n在时期 $t$，贪心决策者面临的约束是产能上限 $u_t$ 和剩余储量 $s_t$。因此，选择必须满足 $0 \\le x_t \\le \\min\\{u_t, s_t\\}$。由于 $p, c_t, a$ 都是非负的，所以 $x_t^* \\ge 0$。因此，贪心选择 $x_t^g$ 是无约束最优解 $x_t^*$ 在可行区间上的投影：\n$$\nx_t^g = \\min\\left(\\frac{p c_t}{a}, u_t, s_t\\right)\n$$\n该算法通过从 $t=1$ 到 $T$ 进行迭代，计算 $x_t^g$，并用初始储量 $s_1 = S$ 更新剩余储量 $s_{t+1} = s_t - x_t^g$。然后使用得到的开采路径 $\\{x_t^g\\}_{t=1}^T$ 计算总 NPV。\n\n**最优算法**\n该问题是一个凸优化问题，具体来说是一个二次规划 (QP) 问题，因为目标函数是二次的，约束是线性的。虽然可以用通用的 QP 求解器求解，但通过分析 Karush-Kuhn-Tucker (KKT) 条件可以得到一种更高效的方法。\n\n该优化问题的拉格朗日函数为：\n$$\n\\mathcal{L}(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = \\sum_{t=1}^T \\beta^{t-1}\\left(p c_t x_t - \\frac{a}{2} x_t^2\\right) - \\lambda\\left(\\sum_{t=1}^T x_t - S\\right) - \\sum_{t=1}^T \\mu_t(x_t - u_t) - \\sum_{t=1}^T \\nu_t(-x_t)\n$$\n其中 $\\lambda \\ge 0$，$\\mu_t \\ge 0$ 和 $\\nu_t \\ge 0$ 分别是总储量、各时期产能上限和各时期非负性约束的拉格朗日乘子。\n\n关于 $x_t$ 的平稳性一阶条件是：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_t} = \\beta^{t-1}(p c_t - a x_t) - \\lambda - \\mu_t + \\nu_t = 0\n$$\n互补松弛条件意味着如果 $0 < x_t < u_t$，则 $\\mu_t = \\nu_t = 0$。在这种内部情况下，最优开采量 $x_t$ 满足：\n$$\n\\beta^{t-1}(p c_t - a x_t) = \\lambda \\implies p c_t - a x_t = \\lambda \\beta^{-(t-1)} \\implies x_t = \\frac{p c_t - \\lambda \\beta^{-(t-1)}}{a}\n$$\n项 $\\lambda$ 是资源储量 $S$ 的影子价格。该条件表明，在所有开采量为正且不处于边界的时期，开采的贴现边际利润必须等于这个影子价格。\n考虑到边界条件（$x_t=0$ 或 $x_t=u_t$），对于给定的 $\\lambda$，最优开采量 $x_t^*$ 为：\n$$\nx_t^*(\\lambda) = \\text{max}\\left(0, \\min\\left(\\frac{p c_t - \\lambda \\beta^{-(t-1)}}{a}, u_t\\right)\\right)\n$$\n设 $X(\\lambda) = \\sum_{t=1}^T x_t^*(\\lambda)$。函数 $X(\\lambda)$ 是 $\\lambda$ 的一个连续非增函数。$\\lambda$ 的正确值由总储量约束和互补松弛条件 $\\lambda(\\sum_{t=1}^T x_t^* - S) = 0$ 决定。\n\n寻找最优路径的算法如下：\n1.  假设储量约束不具有约束力，计算总开采量，这对应于设置影子价格 $\\lambda=0$。令其为 $X(0) = \\sum_t \\max(0, \\min(\\frac{p c_t}{a}, u_t))$。\n2.  如果 $X(0) \\le S$，则相对于其有利可图的开采机会，资源并不稀缺。最优解在 $\\lambda^*=0$ 时获得，且对所有 $t$ 都有 $x_t^* = x_t^*(0)$。\n3.  如果 $X(0) > S$，则储量约束具有约束力，要求 $\\lambda^* > 0$。我们必须找到满足市场出清条件 $X(\\lambda^*) = S$ 的唯一 $\\lambda^* > 0$。这是一个求解方程 $g(\\lambda) = X(\\lambda) - S = 0$ 的一维求根问题。二分法或牛顿族方法（例如 Brent 方法）可以有效地找到 $\\lambda^*$。$\\lambda$ 的搜索区间是 $[0, \\lambda_{max}]$，其中 $\\lambda_{max} = \\max_t(p c_t \\beta^{t-1})$ 是一个确保所有 $x_t=0$ 的上界。\n4.  一旦找到 $\\lambda^*$，最优开采路径 $\\{x_t^*(\\lambda^*)\\}_{t=1}^T$ 就确定了，并且可以计算出最优 NPV。\n\n对于此问题结构，这种基于 KKT 的方法优于通用的 QP 求解器。实现将使用 Brent 方法进行求根，因为它既稳健又高效。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves a series of finite-horizon resource extraction problems using both a greedy\n    and an optimal algorithm, then compares the results.\n    \"\"\"\n\n    test_cases = [\n        (4, 0.95, 2.0, 2.0, 6.0, np.array([1.0, 1.5, 1.2, 1.1]), np.array([5.0, 5.0, 5.0, 5.0])),\n        (3, 0.98, 1.0, 1.0, 3.0, np.array([1.0, 2.0, 5.0]), np.array([10.0, 10.0, 10.0])),\n        (3, 0.5, 1.0, 1.0, 3.0, np.array([5.0, 2.0, 1.0]), np.array([10.0, 10.0, 10.0])),\n        (4, 0.99, 1.0, 1.0, 1.5, np.array([2.0, 2.0, 10.0, 2.0]), np.array([10.0, 10.0, 1.0, 10.0])),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T, beta, p, a, S, c, u = case\n        \n        # --- Greedy Algorithm ---\n        x_g = np.zeros(T)\n        s_rem = S\n        for t in range(T):\n            x_unconstrained = p * c[t] / a\n            x_g[t] = np.clip(x_unconstrained, 0, min(u[t], s_rem))\n            s_rem -= x_g[t]\n\n        # --- Optimal Algorithm ---\n        betas = beta ** np.arange(T)\n        \n        def get_x_opt(lam, T, p, a, beta, c, u):\n            \"\"\"Computes optimal extraction path for a given lambda.\"\"\"\n            beta_inv_powers = beta ** (-np.arange(T))\n            numerators = p * c - lam * beta_inv_powers\n            x_unbounded = numerators / a\n            return np.clip(x_unbounded, 0, u)\n\n        # Check if resource constraint is binding\n        x_opt_lam0 = get_x_opt(0, T, p, a, beta, c, u)\n        \n        if np.sum(x_opt_lam0) <= S:\n            lam_opt = 0.0\n            x_opt = x_opt_lam0\n        else:\n            # Resource constraint is binding, find lambda > 0\n            # Define the function whose root we want to find\n            def total_extraction_diff(lam):\n                return np.sum(get_x_opt(lam, T, p, a, beta, c, u)) - S\n            \n            # Find a safe upper bound for lambda search\n            # Any lambda larger than this will result in all xt = 0\n            lam_upper_bound = np.max(p * c * (beta ** np.arange(T))) + 1.0\n\n            try:\n                lam_opt = brentq(total_extraction_diff, 0, lam_upper_bound, xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # Fallback if signs are not different, though theoretically they should be\n                lam_opt = 0.0 # Should not happen with this problem structure\n            \n            x_opt = get_x_opt(lam_opt, T, p, a, beta, c, u)\n\n        # --- NPV Calculation ---\n        def calculate_npv(x_path, T, beta, p, c, a):\n            npv = 0.0\n            for t in range(T):\n                benefit = p * c[t] * x_path[t] - (a / 2) * x_path[t]**2\n                npv += (beta**t) * benefit\n            return npv\n\n        greedy_npv = calculate_npv(x_g, T, beta, p, c, a)\n        optimal_npv = calculate_npv(x_opt, T, beta, p, c, a)\n\n        # --- Formatting and Appending Results ---\n        optimal_npv_rounded = round(optimal_npv, 6)\n        greedy_npv_rounded = round(greedy_npv, 6)\n        \n        eq_indicator = 1 if abs(optimal_npv - greedy_npv) <= 1e-6 else 0\n        \n        results.extend([f\"{optimal_npv_rounded:.6f}\", f\"{greedy_npv_rounded:.6f}\", eq_indicator])\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}