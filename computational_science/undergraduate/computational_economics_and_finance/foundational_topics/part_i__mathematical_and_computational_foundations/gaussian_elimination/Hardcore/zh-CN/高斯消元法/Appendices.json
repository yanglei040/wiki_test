{
    "hands_on_practices": [
        {
            "introduction": "理论必须通过实践来巩固。第一个练习将引导你完成高斯消元法的基础步骤。通过解决一个标准的 $3 \\times 3$ 线性方程组，你将熟悉将系统转化为易于求解的行阶梯形矩阵所需的核心行操作。掌握这个基础是应用更高级计算技术的前提。",
            "id": "23125",
            "problem": "考虑下列关于三个变量 $x, y,$ 和 $z$ 的线性方程组：\n$$\n\\begin{cases}\nx + y + z = 4 \\\\\n2x - y + z = 8 \\\\\nx - 2y - z = 1\n\\end{cases}\n$$\n使用高斯消元法，将该方程组变换为行阶梯形，并求出变量 $z$ 的值。",
            "solution": "我们写出该方程组的增广矩阵：\n$$\n\\begin{pmatrix}\n1  1  1  \\big|  4 \\\\\n2  -1  1  \\big|  8 \\\\\n1  -2  -1  \\big|  1\n\\end{pmatrix}\n$$\n第一步：通过 $R_2\\leftarrow R_2-2R_1$ 消去第二行中的 $x$，通过 $R_3\\leftarrow R_3-R_1$ 消去第三行中的 $x$：\n$$\nR_2: (2-2\\cdot1,\\;-1-2\\cdot1,\\;1-2\\cdot1\\;|\\;8-2\\cdot4)\n=(0,\\,-3,\\,-1\\;|\\;0),\n$$\n$$\nR_3: (1-1,\\;-2-1,\\;-1-1\\;|\\;1-4)\n=(0,\\,-3,\\,-2\\;|\\;-3).\n$$\n矩阵变为\n$$\n\\begin{pmatrix}\n1  1  1  \\big|  4 \\\\\n0  -3  -1  \\big|  0 \\\\\n0  -3  -2  \\big|  -3\n\\end{pmatrix}\n$$\n第二步：通过 $R_3\\leftarrow R_3-R_2$ 消去第三行中的 $y$：\n$$\nR_3: (0-0,\\;-3-(-3),\\;-2-(-1)\\;|\\;-3-0)\n=(0,\\;0,\\;-1\\;|\\;-3).\n$$\n现在矩阵为行阶梯形式：\n$$\n\\begin{pmatrix}\n1  1  1  \\big|  4 \\\\\n0  -3  -1  \\big|  0 \\\\\n0  0  -1  \\big|  -3\n\\end{pmatrix}\n$$\n由第三行我们得到\n$$\n-1\\cdot z=-3,\n$$\n因此\n$$\nz=3.\n$$",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在计算金融领域，理论算法与计算机实现的现实之间存在着重要差异。这个练习探讨了一个关键问题：数值稳定性。通过一个关于无套利定价的假设场景，你将看到有限精度计算如何导致错误的结论，并理解为何像“主元选择”这样的技术并非只是理论上的细节，而是确保金融分析可靠性的必要工具。",
            "id": "2396422",
            "problem": "考虑一个具有完全市场的两状态、单期经济。令 $q_1$ 和 $q_2$ 表示 Arrow–Debreu 状态价格（分别是在状态 $1$ 或状态 $2$ 时交付一单位消费品的今日价格）。根据无套利原则，任何交易资产 $j$ 的价格 $p_j$（其在两种状态下的支付分别为 $x_{1j}$ 和 $x_{2j}$）满足以下方程组\n$$\np_j \\;=\\; q_1 x_{1j} \\;+\\; q_2 x_{2j}, \\quad j \\in \\{1,2\\}.\n$$\n您观察到两种交易资产，其支付和价格如下（所有货币金额均以美元计）：\n- 资产 $1$：支付向量 $(x_{11}, x_{21}) = (0.001234,\\, 1.000000)$，价格 $p_1 = 1.001234$。\n- 资产 $2$：支付向量 $(x_{12}, x_{22}) = (1.000000,\\, 1.000000)$，价格 $p_2 = 2.000000$。\n\n假设市场是无套利且完全的。一位分析师试图通过使用高斯消元法求解关于 $(q_1, q_2)$ 的 $2\\times 2$ 线性系统来恢复 $(q_1, q_2)$ 的值。然而，该分析师在算法的每个中间步骤都使用四舍五入到三位有效数字的算术方法。\n\n任务：\n1) 建立形式为 $A \\boldsymbol{q} = \\boldsymbol{p}$ 的线性系统，其中\n$$\nA \\;=\\; \\begin{pmatrix}\n0.001234  1.000000 \\\\\n1.000000  1.000000\n\\end{pmatrix}, \n\\quad \n\\boldsymbol{q} \\;=\\; \\begin{pmatrix} q_1 \\\\ q_2 \\end{pmatrix}, \n\\quad \n\\boldsymbol{p} \\;=\\; \\begin{pmatrix} 1.001234 \\\\ 2.000000 \\end{pmatrix}.\n$$\n2) 对增广矩阵执行不使用主元法的高斯消元，将所有算术运算（包括每个中间结果）通过四舍五入保留三位有效数字。将所得估计值记为 $(\\tilde{q}_1, \\tilde{q}_2)$。\n3) 使用 $(\\tilde{q}_1, \\tilde{q}_2)$，计算在两种状态下支付为 $(1, 0)$ 的 Arrow–Debreu 证券的模型隐含无套利价值 $\\tilde{v}$。\n4) 在同一个无套利市场中，该 Arrow–Debreu 证券的观测市场价值 $v$ 与精确求解上述系统的真实状态价格一致（因此 $v = q_1$）。根据给定的数据，观测到的 $v$ 等于 $1.000000$。因此，使用不带主元的高斯消元法的分析师会声称存在一个虚假套利机会，即通过卖空观测到的证券，并以其模型隐含价值购买其复制投资组合，单位利润为 $\\pi = v - \\tilde{v}$。\n5) 现在使用部分主元法（在消元前总是交换行，将当前列中绝对值最大的可用元素放在对角线上作为主元）重复消元过程，每一步仍使用三位有效数字的算术，以获得 $(\\hat{q}_1, \\hat{q}_2)$ 和相应的 $\\hat{v}$。解释为什么这样做可以消除虚假套利。\n\n作为您的最终答案，报告在步骤4中计算的单位虚假套利利润 $\\pi$，四舍五入到三位有效数字。以美元表示最终利润。",
            "solution": "对问题陈述的有效性进行评估。\n\n**步骤1：提取已知条件**\n- 资产价格的方程组为 $p_j = q_1 x_{1j} + q_2 x_{2j}$，其中 $j \\in \\{1, 2\\}$。\n- 资产 $1$：支付向量 $(x_{11}, x_{21}) = (0.001234, 1.000000)$，价格 $p_1 = 1.001234$。\n- 资产 $2$：支付向量 $(x_{12}, x_{22}) = (1.000000, 1.000000)$，价格 $p_2 = 2.000000$。\n- 线性系统以矩阵形式 $A \\boldsymbol{q} = \\boldsymbol{p}$ 给出：\n$$\nA = \\begin{pmatrix} 0.001234  1.000000 \\\\ 1.000000  1.000000 \\end{pmatrix}, \\quad \\boldsymbol{q} = \\begin{pmatrix} q_1 \\\\ q_2 \\end{pmatrix}, \\quad \\boldsymbol{p} = \\begin{pmatrix} 1.001234 \\\\ 2.000000 \\end{pmatrix}\n$$\n- 所有算术运算都需在每个中间步骤四舍五入到 $3$ 位有效数字。\n- 支付为 $(1, 0)$ 的 Arrow-Debreu 证券的真实价值为 $v = q_1 = 1.000000$。\n- 虚假套利利润定义为 $\\pi = v - \\tilde{v}$，其中 $\\tilde{v}$ 是使用不带主元的高斯消元法计算出的价值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，根植于资产定价基本定理和标准的数值线性代数。这是一个适定问题；矩阵 $A$ 是非奇异的，因为其行列式为 $0.001234 \\times 1.000000 - 1.000000 \\times 1.000000 = -0.998766 \\neq 0$，这保证了 $(q_1, q_2)$ 存在唯一解。问题是客观、完整的，并且不包含任何矛盾。所选的数据值旨在说明一个众所周知的数值不稳定性问题，这是计算科学中的一种标准教学手段。该问题是可形式化的，并且与指定主题相关。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n通过直接的代数运算可以找到该系统的精确解。第二个方程减去第一个方程得到 $(1 - 0.001234)q_1 = 2 - 1.001234$，化简为 $0.998766 q_1 = 0.998766$，这意味着 $q_1 = 1$。代回原方程可得 $q_2 = 1$。因此，真实的状态价格向量为 $(q_1, q_2) = (1, 1)$。\n\n我们现在使用有限精度算术来分析解。\n\n**第1部分：不使用主元法的高斯消元**\n\n首先，我们建立增广矩阵 $[A|\\boldsymbol{p}]$ 并将所有元素四舍五入到3位有效数字。\n$$\n[A|\\boldsymbol{p}] = \\left[ \\begin{array}{cc|c}\n0.001234  1.000000  1.001234 \\\\\n1.000000  1.000000  2.000000\n\\end{array} \\right] \\quad \\rightarrow \\quad \\left[ \\begin{array}{cc|c}\n0.00123  1.00  1.00 \\\\\n1.00  1.00  2.00\n\\end{array} \\right]\n$$\n主元是 $a_{11} = 0.00123$。第二行的乘数是 $m_{21} = \\frac{a_{21}}{a_{11}} = \\frac{1.00}{0.00123}$。\n计算：$1.00 \\div 0.00123 \\approx 813.008...$。四舍五入到3位有效数字得到 $m_{21} = 813$。\n我们执行行运算 $R_2 \\leftarrow R_2 - m_{21} R_1$。\n第二行的新元素计算如下：\n$a'_{22} = a_{22} - m_{21} \\times a_{12} = 1.00 - 813 \\times 1.00 = 1.00 - 813 = -812$。\n$p'_{2} = p_{2} - m_{21} \\times p_{1} = 2.00 - 813 \\times 1.00 = 2.00 - 813 = -811$。\n系统变为上三角形式：\n$$\n\\left[ \\begin{array}{cc|c}\n0.00123  1.00  1.00 \\\\\n0  -812  -811\n\\end{array} \\right]\n$$\n现在我们执行回代以求得近似解 $(\\tilde{q}_1, \\tilde{q}_2)$。\n根据第二行：$-812 \\tilde{q}_2 = -811$。\n$\\tilde{q}_2 = \\frac{-811}{-812} \\approx 0.99876...$。四舍五入到3位有效数字：$\\tilde{q}_2 = 0.999$。\n根据第一行：$0.00123 \\tilde{q}_1 + 1.00 \\tilde{q}_2 = 1.00$。\n代入 $\\tilde{q}_2$：$0.00123 \\tilde{q}_1 + 1.00 \\times 0.999 = 1.00$。\n乘积 $1.00 \\times 0.999 = 0.999$。\n$0.00123 \\tilde{q}_1 + 0.999 = 1.00$。\n$0.00123 \\tilde{q}_1 = 1.00 - 0.999 = 0.001$。这个中间结果只有1位有效数字。\n$\\tilde{q}_1 = \\frac{0.001}{0.00123} \\approx 0.81300...$。四舍五入到3位有效数字：$\\tilde{q}_1 = 0.813$。\n因此，不使用主元法的解是 $(\\tilde{q}_1, \\tilde{q}_2) = (0.813, 0.999)$。\n\n支付为 $(1, 0)$ 的 Arrow-Debreu 证券的模型隐含价值是 $\\tilde{v} = 1 \\cdot \\tilde{q}_1 + 0 \\cdot \\tilde{q}_2 = \\tilde{q}_1 = 0.813$。\n真实市场价值是 $v = 1.000000$。\n虚假套利利润是 $\\pi = v - \\tilde{v} = 1.000 - 0.813 = 0.187$。\n\n**第2部分：使用部分主元法的高斯消元**\n\n我们从相同的经过四舍五入的增广矩阵开始：\n$$\n\\left[ \\begin{array}{cc|c}\n0.00123  1.00  1.00 \\\\\n1.00  1.00  2.00\n\\end{array} \\right]\n$$\n在第一列中， $|a_{21}| = 1.00 > |a_{11}| = 0.00123$。因此，我们交换第1行和第2行。\n$$\n\\left[ \\begin{array}{cc|c}\n1.00  1.00  2.00 \\\\\n0.00123  1.00  1.00\n\\end{array} \\right]\n$$\n现在主元是 $a_{11} = 1.00$。乘数是 $m_{21} = \\frac{a_{21}}{a_{11}} = \\frac{0.00123}{1.00} = 0.00123$。\n我们执行行运算 $R_2 \\leftarrow R_2 - m_{21} R_1$。\n第二行的新元素计算如下：\n$a'_{22} = a_{22} - m_{21} \\times a_{12} = 1.00 - 0.00123 \\times 1.00 = 1.00 - 0.00123 = 0.99877$。四舍五入到3位有效数字得到 $0.999$。\n$p'_{2} = p_{2} - m_{21} \\times p_{1} = 1.00 - 0.00123 \\times 2.00 = 1.00 - 0.00246 = 0.99754$。四舍五入到3位有效数字得到 $0.998$。\n系统变为：\n$$\n\\left[ \\begin{array}{cc|c}\n1.00  1.00  2.00 \\\\\n0  0.999  0.998\n\\end{array} \\right]\n$$\n我们执行回代以求得解 $(\\hat{q}_1, \\hat{q}_2)$。\n根据第二行：$0.999 \\hat{q}_2 = 0.998$。\n$\\hat{q}_2 = \\frac{0.998}{0.999} \\approx 0.99899...$。四舍五入到3位有效数字：$\\hat{q}_2 = 0.999$。\n根据第一行：$1.00 \\hat{q}_1 + 1.00 \\hat{q}_2 = 2.00$。\n$1.00 \\hat{q}_1 + 1.00 \\times 0.999 = 2.00$。\n$1.00 \\hat{q}_1 + 0.999 = 2.00$。\n$1.00 \\hat{q}_1 = 2.00 - 0.999 = 1.001$。四舍五入到3位有效数字得到 $1.00$。\n$1.00 \\hat{q}_1 = 1.00$，所以 $\\hat{q}_1 = 1.00$。\n使用部分主元法的解是 $(\\hat{q}_1, \\hat{q}_2) = (1.00, 0.999)$。\n\n新的模型隐含价值是 $\\hat{v} = \\hat{q}_1 = 1.00$。\n现在套利利润是 $\\hat{\\pi} = v - \\hat{v} = 1.00 - 1.00 = 0$。\n\n**解释**\n\n虚假套利是未使用主元法的高斯消元算法中数值不稳定性的直接后果。矩阵 $A$ 的元素在数量级上差异巨大。\n\n当不使用主元法时，选择小元素 $a_{11} = 0.00123$ 作为主元。这导致一个非常大的乘数 $m_{21} = 813$。在消元步骤 $R_2 \\leftarrow R_2 - m_{21} R_1$ 中，第2行中的原始信息因减去一个大数而被有效地破坏了。项 $m_{21} \\times a_{12} = 813$ 淹没了 $a_{22}=1.00$ 的原始值。这在随后的回代步骤中导致了灾难性抵消（$1.00 - 0.999 = 0.001$），其中两个几乎相等的数相减，导致有效数字从3位损失到1位。最终结果 $\\tilde{q}_1 = 0.813$ 与真实值 $q_1 = 1$ 相比极其不准确。\n\n部分主元法纠正了这种不稳定性。通过交换行，它确保主元是该列中可用的绝对值最大的元素。在本例中，$1.00$ 成为主元。这保证了乘数 $m_{21} = 0.00123$ 很小（具体来说， $|m_{ij}| \\le 1$）。在执行消元步骤时，我们减去一个小的量，这保留了原始矩阵元素的有效数字。由此产生的计算是数值稳定的，得到 $\\hat{q}_1 = 1.00$，在其3位有效数字的工作精度下是准确的。这个准确的状态价格导致模型价值 $\\hat{v}$ 与观测到的市场价值 $v$ 相匹配，从而正确地表明不存在套利机会。",
            "answer": "$$\n\\boxed{0.187}\n$$"
        },
        {
            "introduction": "这个练习将我们的视角从解决单个问题提升到高效地解决成千上万个相关问题。通过将高斯消元法以 LU 分解的形式应用于一个列昂惕夫投入产出模型，你将领会计算经济学的一个核心原则：“一次分解，多次求解”。这突显了该算法在处理大规模动态经济模型时的强大威力与效率。",
            "id": "2396443",
            "problem": "考虑一个来自计算经济学的静态投入产出模型（Leontief系统），其中总产出向量 $x$ 必须满足 $(I - A)\\,x = d$。这里，$A$ 是给定的非负产业间系数矩阵，$d$ 是最终需求向量。假设矩阵 $I - A$ 是非奇异的。使用的基本原理是：任何具有非奇异矩阵 $A$ 的系统 $A\\,x = b$ 都可以通过高斯消元法求解。高斯消元法执行一系列基本行变换和行交换，将 $A$ 转换为一个上三角矩阵 $U$，同时记录下构成单位下三角矩阵 $L$ 的乘数以及由置换向量编码的行交换序列。这将高斯消元法的结果紧凑地表示为一个分解式 $P\\,A = L\\,U$，其中 $P$ 是由行交换定义的置换矩阵。一旦得到了 $L$ 和 $U$，任何右端项 $b$ 都可以通过两次三角求解来解决：首先通过前向代入求解 $L\\,y = P\\,b$，然后通过反向代入求解 $U\\,x = y$。在初始的 $O(n^3)$ 分解成本之后，这将每个右端项的求解成本降低到 $O(n^2)$ 级别的算术运算。当需要为许多不同的需求向量 $d_i$ 求解同一系统时，这一点至关重要。\n\n你的任务是编写一个完整的、可运行的程序，该程序：\n- 对于下方的每个测试用例，根据给定的 $A$ 构建 $B = I - A$，然后仅进行一次带部分主元法的高斯消元，以获得上三角矩阵 $U$、相关的单位下三角矩阵 $L$（由消元乘数编码）以及编码行交换的置换向量，然后利用这些结果快速求解多个不同 $d$ 值的方程 $B\\,x = d$，而无需重新计算消元过程。\n- 仅使用分解输出，通过置换、前向代入和反向代入来求解每个右端项。\n- 生成所要求的数值聚合结果。\n\n仅使用不带物理单位的纯数字。不涉及角度。百分比（如果概念上出现）必须表示为小数。\n\n测试套件及所需输出：\n1) 一般重复求解场景 ($3\\times 3$)。令\n$$\nA_1 = \\begin{bmatrix}\n0.2  0.1  0.05 \\\\\n0.05  0.25  0.1 \\\\\n0.1  0.05  0.2\n\\end{bmatrix}, \\quad\nB_1 = I - A_1.\n$$\n对于每个整数 $i \\in \\{1,2,\\dots,1000\\}$，定义最终需求向量\n$$\nd_i = \\begin{bmatrix}\n0.5 + 0.0003\\,i \\\\\n0.4 + 0.0001\\,i \\\\\n0.3 + 0.0002\\,i\n\\end{bmatrix}.\n$$\n对 $B_1$ 进行单次高斯消元，然后通过重用相同的 $U$ 和置换向量，并使用前向和反向代入法，求解所有 $i$ 对应的 $B_1\\,x_i = d_i$。报告以下三个浮点数输出：$i=1$、$i=500$ 和 $i=1000$ 时的总产出 $t_i = \\mathbf{1}^\\top x_i$（其中 $\\mathbf{1}$ 是全1向量）。\n\n2) 具有两个需求的较大型系统 ($4\\times 4$)。令\n$$\nA_2 = \\begin{bmatrix}\n0.1  0.05  0.02  0.0 \\\\\n0.03  0.2  0.04  0.01 \\\\\n0.0  0.05  0.15  0.02 \\\\\n0.02  0.0  0.03  0.1\n\\end{bmatrix}, \\quad\nB_2 = I - A_2.\n$$\n为以下两个需求向量分别求解 $B_2\\,x = d$\n$$\nd^{(a)} = \\begin{bmatrix} 0.2 \\\\ 0.1 \\\\ 0.15 \\\\ 0.05 \\end{bmatrix}, \\quad\nd^{(b)} = \\begin{bmatrix} 0.3 \\\\ 0.0 \\\\ 0.2 \\\\ 0.1 \\end{bmatrix}.\n$$\n报告 $d^{(a)}$ 和 $d^{(b)}$ 对应的第二部门产出（即解向量 $x$ 的第二个分量）。\n\n3) 边界情况（单位矩阵系统, $2\\times 2$）。令\n$$\nA_3 = \\begin{bmatrix}\n0  0 \\\\\n0  0\n\\end{bmatrix}, \\quad\nB_3 = I - A_3 = I.\n$$\n为以下三个需求向量分别求解\n$$\nd^{(1)} = \\begin{bmatrix} 0.7 \\\\ 0.9 \\end{bmatrix}, \\quad\nd^{(2)} = \\begin{bmatrix} 0.0 \\\\ 0.12345 \\end{bmatrix}, \\quad\nd^{(3)} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}.\n$$\n报告这三个需求向量对应的解向量 $x$ 的第一个分量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序必须完全如下：\n- 测试1的三个值（$t_1$、$t_{500}$、$t_{1000}$），其后是测试2的两个值（$d^{(a)}$ 和 $d^{(b)}$ 对应的第二个分量），最后是测试3的三个值（$d^{(1)}$、$d^{(2)}$ 和 $d^{(3)}$ 对应的第一个分量）。\n- 具体来说，打印的行必须如下所示\n$$\n[\\,v_1,v_2,v_3,v_4,v_5,v_6,v_7,v_8\\,],\n$$\n其中每个 $v_j$ 是您的程序按上述顺序计算出的浮点数。",
            "solution": "所述问题是有效的。它定义明确，科学上基于经济学中既定的Leontief投入产出模型和数值线性代数中的LU分解方法。所有需要的数据和条件都已提供，并且它们是一致且无歧义的。我们将着手进行求解。\n\n基本任务是在给定技术矩阵 $A$ 的情况下，为不同的需求向量 $d$ 求解线性系统 $(I - A)x = d$。令 $B = I - A$。我们需要求解 $B x = d$。对于每个测试用例，矩阵 $B$ 是固定的，而向量 $d$ 是变化的。这种结构使得先计算 $B$ 的带部分主元法的LU分解，然后重用此分解来求解每个 $d$ 变得非常高效。\n\n带部分主元法的LU分解会找到一个置换矩阵 $P$、一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $P B = L U$。原始系统 $B x = d$ 等价于 $P B x = P d$，即 $L U x = P d$。我们可以通过一个两步过程来求解：\n1.  首先，使用前向代入法求解下三角系统 $L y = P d$，得到向量 $y$。\n2.  然后，使用反向代入法求解上三角系统 $U x = y$，得到最终解向量 $x$。\n\n对于一个 $n \\times n$ 的矩阵，初始的分解是一个计算密集型操作，复杂度为 $O(n^3)$。然而，每次使用该分解进行的后续求解仅需 $O(n^2)$ 次操作。这是我们必须实现的原理。我们将使用提供此过程优化实现的库函数。\n\n### 测试用例 1\n\n技术矩阵为：\n$$\nA_1 = \\begin{bmatrix}\n0.2  0.1  0.05 \\\\\n0.05  0.25  0.1 \\\\\n0.1  0.05  0.2\n\\end{bmatrix}\n$$\nLeontief矩阵 $B_1 = I - A_1$ 为：\n$$\nB_1 = \\begin{bmatrix}\n0.8  -0.1  -0.05 \\\\\n-0.05  0.75  -0.1 \\\\\n-0.1  -0.05  0.8\n\\end{bmatrix}\n$$\n我们对 $B_1$ 进行一次LU分解。\n需求向量 $d_i$ 对于 $i \\in \\{1, 2, \\dots, 1000\\}$ 定义如下：\n$$\nd_i = \\begin{bmatrix}\n0.5 + 0.0003 i \\\\\n0.4 + 0.0001 i \\\\\n0.3 + 0.0002 i\n\\end{bmatrix}\n$$\n我们使用计算出的分解来求解 $i \\in \\{1, 500, 1000\\}$ 时的 $B_1 x_i = d_i$。对于每个解 $x_i$，我们计算总产出 $t_i = \\mathbf{1}^\\top x_i = \\sum_{j=1}^3 (x_i)_j$。这三个值 $t_1$、$t_{500}$ 和 $t_{1000}$ 是需要报告的前三个结果。\n\n### 测试用例 2\n\n技术矩阵为：\n$$\nA_2 = \\begin{bmatrix}\n0.1  0.05  0.02  0.0 \\\\\n0.03  0.2  0.04  0.01 \\\\\n0.0  0.05  0.15  0.02 \\\\\n0.02  0.0  0.03  0.1\n\\end{bmatrix}\n$$\nLeontief矩阵 $B_2 = I - A_2$ 为：\n$$\nB_2 = \\begin{bmatrix}\n0.9  -0.05  -0.02  0.0 \\\\\n-0.03  0.8  -0.04  -0.01 \\\\\n0.0  -0.05  0.85  -0.02 \\\\\n-0.02  0.0  -0.03  0.9\n\\end{bmatrix}\n$$\n我们对 $B_2$ 进行一次LU分解。然后我们为两个独立的需求向量求解 $B_2 x = d$：\n$$\nd^{(a)} = \\begin{bmatrix} 0.2 \\\\ 0.1 \\\\ 0.15 \\\\ 0.05 \\end{bmatrix}, \\quad\nd^{(b)} = \\begin{bmatrix} 0.3 \\\\ 0.0 \\\\ 0.2 \\\\ 0.1 \\end{bmatrix}\n$$\n对于每个解 $x^{(a)}$ 和 $x^{(b)}$，我们报告其第二个分量 $(x^{(a)})_2$ 和 $(x^{(b)})_2$。这是第四和第五个结果。\n\n### 测试用例 3\n\n技术矩阵是 $2 \\times 2$ 的零矩阵：\n$$\nA_3 = \\begin{bmatrix}\n0  0 \\\\\n0  0\n\\end{bmatrix}\n$$\nLeontief矩阵就是单位矩阵 $B_3 = I - A_3 = I$。\n$$\nB_3 = \\begin{bmatrix}\n1  0 \\\\\n0  1\n\\end{bmatrix}\n$$\n虽然 $I x = d$ 的解显然是 $x=d$，但我们必须遵守程序，使用其LU分解（$P=L=U=I$）。我们为三个需求向量求解：\n$$\nd^{(1)} = \\begin{bmatrix} 0.7 \\\\ 0.9 \\end{bmatrix}, \\quad\nd^{(2)} = \\begin{bmatrix} 0.0 \\\\ 0.12345 \\end{bmatrix}, \\quad\nd^{(3)} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}\n$$\n对于每个解，我们报告其第一个分量。这些值将是 $(x^{(1)})_1 = 0.7$，$(x^{(2)})_1 = 0.0$ 和 $(x^{(3)})_1 = 1.0$。这是最后三个结果。\n\n程序将被构造成执行这些计算，按顺序收集所有八个指定的值，并以要求的格式打印它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Solves a series of Leontief input-output models using LU factorization.\n    \"\"\"\n    # This list will store the final results in the required order.\n    final_results = []\n\n    # === Test Case 1 ===\n    # General repeated-solve scenario (3x3).\n    A1 = np.array([\n        [0.2, 0.1, 0.05],\n        [0.05, 0.25, 0.1],\n        [0.1, 0.05, 0.2]\n    ])\n    B1 = np.identity(A1.shape[0]) - A1\n    \n    # Compute LU factorization of B1 once.\n    # lu_factor returns the LU-factored matrix and pivot indices.\n    lu1, piv1 = lu_factor(B1)\n    \n    # Indices for which to compute the solution.\n    indices_to_report = [1, 500, 1000]\n    \n    # Solve for each specified index i.\n    for i in indices_to_report:\n        d_i = np.array([\n            0.5 + 0.0003 * i,\n            0.4 + 0.0001 * i,\n            0.3 + 0.0002 * i\n        ])\n        \n        # Solve B1 * x_i = d_i using the pre-computed factorization.\n        x_i = lu_solve((lu1, piv1), d_i)\n        \n        # Calculate total output t_i = 1^T * x_i (sum of components).\n        t_i = np.sum(x_i)\n        final_results.append(t_i)\n\n    # === Test Case 2 ===\n    # Larger system with two demands (4x4).\n    A2 = np.array([\n        [0.1, 0.05, 0.02, 0.0],\n        [0.03, 0.2, 0.04, 0.01],\n        [0.0, 0.05, 0.15, 0.02],\n        [0.02, 0.0, 0.03, 0.1]\n    ])\n    B2 = np.identity(A2.shape[0]) - A2\n    \n    # Compute LU factorization of B2 once.\n    lu2, piv2 = lu_factor(B2)\n    \n    demands2 = [\n        np.array([0.2, 0.1, 0.15, 0.05]),  # d^(a)\n        np.array([0.3, 0.0, 0.2, 0.1])    # d^(b)\n    ]\n    \n    for d in demands2:\n        # Solve B2 * x = d using the factorization.\n        x = lu_solve((lu2, piv2), d)\n        \n        # Report the second component of the solution vector.\n        final_results.append(x[1])\n        \n    # === Test Case 3 ===\n    # Boundary case (identity system, 2x2).\n    A3 = np.array([\n        [0.0, 0.0],\n        [0.0, 0.0]\n    ])\n    B3 = np.identity(A3.shape[0]) - A3\n    \n    # Compute LU factorization of B3 (which is I) once.\n    lu3, piv3 = lu_factor(B3)\n    \n    demands3 = [\n        np.array([0.7, 0.9]),          # d^(1)\n        np.array([0.0, 0.12345]),      # d^(2)\n        np.array([1.0, 1.0])           # d^(3)\n    ]\n    \n    for d in demands3:\n        # Solve B3 * x = d. Since B3=I, x will be equal to d.\n        # We still use the solver as required by the problem statement.\n        x = lu_solve((lu3, piv3), d)\n        \n        # Report the first component of the solution vector.\n        final_results.append(x[0])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}