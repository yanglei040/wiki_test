{
    "hands_on_practices": [
        {
            "introduction": "Standard flow networks model constraints on the pathways, represented by edges, but what if the junctions, or nodes, themselves have limited throughput? This exercise challenges you to adapt the classic max-flow problem to include node capacities, a common feature in logistics and communication networks. Solving this problem  requires a clever transformation of the network, a fundamental skill in applying theoretical algorithms to more complex, real-world scenarios.",
            "id": "3249870",
            "problem": "Consider a directed flow network with a distinguished source node $s$ and sink node $t$. In addition to edge capacities, each internal node has a capacity limiting the total flow that can pass through it. The network has nodes $s$, $v_{1}$, $v_{2}$, $v_{3}$, $v_{4}$, and $t$. The directed edges and their capacities are as follows: $s \\to v_{1}$ with capacity $8$, $s \\to v_{2}$ with capacity $7$, $v_{1} \\to v_{3}$ with capacity $5$, $v_{1} \\to v_{4}$ with capacity $3$, $v_{2} \\to v_{3}$ with capacity $4$, $v_{2} \\to v_{4}$ with capacity $6$, $v_{3} \\to t$ with capacity $9$, and $v_{4} \\to t$ with capacity $5$. The node capacities are: $c(v_{1}) = 6$, $c(v_{2}) = 5$, $c(v_{3}) = 7$, $c(v_{4}) = 4$, and the source $s$ and sink $t$ have no limiting node capacities (effectively infinite).\n\nUsing only the foundations of flow networks—capacity constraints on edges and nodes and conservation of flow at intermediate nodes—and applying a correct reduction or algorithmic strategy consistent with the Ford–Fulkerson method, the Edmonds–Karp algorithm, or Dinic's algorithm, determine the maximum $s$-$t$ flow value in this network.\n\nProvide your final answer as a single real number representing the maximum flow value. No rounding is required.",
            "solution": "We start from the definitions of a flow network. A feasible flow $f$ assigns to each directed edge $(u,v)$ a nonnegative value $f(u,v)$ such that $0 \\le f(u,v) \\le c(u,v)$ for each edge capacity $c(u,v)$, and flow conservation holds at each intermediate node: for any node $w \\notin \\{s,t\\}$, the sum of inflows equals the sum of outflows. With node capacities, each internal node $w$ additionally satisfies that the total flow passing through $w$ is at most the node capacity $c(w)$, which can be enforced by ensuring that the total outflow (equivalently, inflow) from $w$ does not exceed $c(w)$.\n\nA standard and well-tested reduction transforms node capacities into edge capacities by splitting each node $v$ into two nodes $v_{\\mathrm{in}}$ and $v_{\\mathrm{out}}$ with an edge $(v_{\\mathrm{in}}, v_{\\mathrm{out}})$ of capacity $c(v)$, and redirecting each original incoming edge $(u,v)$ to $(u_{\\mathrm{out}}, v_{\\mathrm{in}})$ and each original outgoing edge $(v,w)$ to $(v_{\\mathrm{out}}, w_{\\mathrm{in}})$. The source $s$ and sink $t$ can be left unsplit or treated with infinite capacity. The maximum flow in the transformed graph equals the maximum flow in the original node-capacitated network.\n\nWe analyze the given network. Edges and capacities:\n- $s \\to v_{1}$ with capacity $8$,\n- $s \\to v_{2}$ with capacity $7$,\n- $v_{1} \\to v_{3}$ with capacity $5$,\n- $v_{1} \\to v_{4}$ with capacity $3$,\n- $v_{2} \\to v_{3}$ with capacity $4$,\n- $v_{2} \\to v_{4}$ with capacity $6$,\n- $v_{3} \\to t$ with capacity $9$,\n- $v_{4} \\to t$ with capacity $5$.\n\nNode capacities:\n- $c(v_{1}) = 6$,\n- $c(v_{2}) = 5$,\n- $c(v_{3}) = 7$,\n- $c(v_{4}) = 4$,\n- $c(s)$ and $c(t)$ effectively infinite.\n\nFrom fundamental capacity constraints, the total flow that can leave $v_{1}$ is at most $6$ and must also respect edge capacities $5$ and $3$ on its outgoing edges. The total flow that can leave $v_{2}$ is at most $5$ and must also respect edge capacities $4$ and $6$. On the sink side, the total that can pass through $v_{3}$ is at most $7$ and must also respect edge capacity $9$ to $t$; for $v_{4}$, it is at most $4$ and must respect edge capacity $5$ to $t$.\n\nThese observations yield immediate upper bounds on the total $s$-$t$ flow:\n- From the source side, no more than $c(v_{1}) + c(v_{2}) = 6 + 5 = 11$ units can pass through the two internal source-adjacent nodes, regardless of the larger edge capacities $8$ and $7$.\n- From the sink side, no more than $c(v_{3}) + c(v_{4}) = 7 + 4 = 11$ units can be absorbed by the two internal nodes before reaching $t$, regardless of the larger edge capacities $9$ and $5$.\n\nTherefore, the maximum flow value is upper bounded by $11$.\n\nWe now construct an explicit feasible flow achieving $11$, which, combined with the upper bound, proves optimality. Let variables denote flows on intermediate edges:\n- $x_{13} = f(v_{1}, v_{3})$ with $0 \\le x_{13} \\le 5$,\n- $x_{14} = f(v_{1}, v_{4})$ with $0 \\le x_{14} \\le 3$,\n- $y_{23} = f(v_{2}, v_{3})$ with $0 \\le y_{23} \\le 4$,\n- $y_{24} = f(v_{2}, v_{4})$ with $0 \\le y_{24} \\le 6$.\n\nNode-capacity constraints translate to:\n- $x_{13} + x_{14} \\le 6$ for $v_{1}$,\n- $y_{23} + y_{24} \\le 5$ for $v_{2}$,\n- $x_{13} + y_{23} \\le 7$ for $v_{3}$ (and also $\\le 9$ by edge $v_{3} \\to t$, so $7$ is binding),\n- $x_{14} + y_{24} \\le 4$ for $v_{4}$ (and also $\\le 5$ by edge $v_{4} \\to t$, so $4$ is binding).\n\nThe total flow to $t$ equals $(x_{13} + y_{23}) + (x_{14} + y_{24})$. Choose the following values:\n- $x_{14} = 3$ and $y_{24} = 1$ so that $x_{14} + y_{24} = 4$, saturating the node capacity of $v_{4}$ and respecting edge bounds $3$ and $6$.\n- $x_{13} = 3$ and $y_{23} = 4$ so that $x_{13} + y_{23} = 7$, saturating the node capacity of $v_{3}$ and respecting edge bounds $5$ and $4$.\n\nVerify node capacities:\n- $v_{1}$: $x_{13} + x_{14} = 3 + 3 = 6 \\le 6$,\n- $v_{2}$: $y_{23} + y_{24} = 4 + 1 = 5 \\le 5$,\n- $v_{3}$: $x_{13} + y_{23} = 3 + 4 = 7 \\le 7$,\n- $v_{4}$: $x_{14} + y_{24} = 3 + 1 = 4 \\le 4$.\n\nVerify edge capacities:\n- $v_{1} \\to v_{3}$: $x_{13} = 3 \\le 5$,\n- $v_{1} \\to v_{4}$: $x_{14} = 3 \\le 3$,\n- $v_{2} \\to v_{3}$: $y_{23} = 4 \\le 4$,\n- $v_{2} \\to v_{4}$: $y_{24} = 1 \\le 6$,\n- $v_{3} \\to t$: total $7 \\le 9$,\n- $v_{4} \\to t$: total $4 \\le 5$,\n- $s \\to v_{1}$ and $s \\to v_{2}$ are sufficient since $f(s,v_{1}) = x_{13} + x_{14} = 6 \\le 8$ and $f(s,v_{2}) = y_{23} + y_{24} = 5 \\le 7$.\n\nFlow conservation is satisfied at each intermediate node by construction, and source and sink flows match: the total flow value is\n$$\n(x_{13} + y_{23}) + (x_{14} + y_{24}) = 7 + 4 = 11.\n$$\nThis feasible flow attains the upper bound $11$, hence by the foundational principles of maximum flow and capacity constraints, the maximum $s$-$t$ flow in the given node-capacitated network is $11$.",
            "answer": "$$\\boxed{11}$$"
        },
        {
            "introduction": "Many real-world distribution problems, such as routing data from multiple servers to multiple clients, don't fit the simple single-source, single-sink model. This practice  guides you through implementing a solution for these more general networks with multiple sources and sinks. You will apply the standard and elegant reduction technique that uses a \"super-source\" and \"super-sink\" to convert the problem back into a classic max-flow instance that any standard algorithm can solve.",
            "id": "3249859",
            "problem": "You are given the task of computing the maximum value of feasible flow in directed networks that have multiple source vertices and multiple sink vertices. Your program must rely only on fundamental definitions of flows in networks and well-tested algorithmic principles. A flow network is a directed graph with capacities on edges. A feasible flow function must satisfy, for every directed edge, that the flow on that edge is between zero and its capacity, and for every vertex other than the designated sources and sinks, that the net flow is conserved. A cut is any partition of vertices separating all sources from all sinks, and the value of any feasible flow cannot exceed the capacity of any cut.\n\nDerive and implement, from these foundations, a correct and efficient method to compute the maximum flow for networks with a set of sources and a set of sinks. The approach must be grounded in the construction that reduces a network with multiple sources and sinks to a single-source, single-sink instance by augmenting the graph with a super-source and a super-sink connected to original sources and sinks by sufficiently large-capacity edges. The correctness should follow from the conservation and capacity constraints together with the max-flow min-cut theorem, without assuming any shortcut formulas.\n\nYou must implement a complete, runnable program that, for each test case in the test suite below, constructs the corresponding augmented network and computes its maximum flow value. Your algorithmic design must be based on classical principles such as constructing residual networks and searching for augmenting paths via Breadth-First Search (BFS) and Depth-First Search (DFS), for example as realized in the Ford–Fulkerson method with the Edmonds–Karp specialization or the Dinic algorithm. Define any acronyms on first use (for example, Breadth-First Search (BFS), Depth-First Search (DFS)).\n\nAll numbers in this specification are integers and are to be interpreted as dimensionless. There are no physical units.\n\nInput format to be hardcoded in your program:\n- Each test case consists of: the number of vertices $n$ labeled $0$ through $n-1$, a list of directed edges with capacities, a set of source vertices, and a set of sink vertices.\n\nTest suite:\n- Test case $1$ (general case with multiple routes and balanced sinks):\n  - Vertices: $n = 8$, labeled $0,1,2,3,4,5,6,7$.\n  - Sources: $\\{0,1\\}$.\n  - Sinks: $\\{6,7\\}$.\n  - Directed edges with capacities (triples $(u,v,c)$ mean an edge from $u$ to $v$ of capacity $c$):\n    $\\{(0,2,10),(0,3,5),(1,3,15),(1,4,4),(2,5,15),(3,2,4),(3,5,8),(3,4,6),(4,5,10),(5,6,10),(5,7,10),(4,7,5),(2,6,5)\\}$.\n  - The expected maximum flow is to be determined by your algorithm.\n- Test case $2$ (edge case with zero-capacity cut and a disconnected source):\n  - Vertices: $n = 5$, labeled $0,1,2,3,4$.\n  - Sources: $\\{0,1\\}$.\n  - Sinks: $\\{3,4\\}$.\n  - Edges: $\\{(0,2,7),(2,3,0),(2,4,0)\\}$. Note that vertex $1$ has no outgoing edges, and the only paths from $0$ to any sink pass through zero-capacity edges.\n- Test case $3$ (single bottleneck edge dominating the max flow):\n  - Vertices: $n = 6$, labeled $0,1,2,3,4,5$.\n  - Sources: $\\{0,1\\}$.\n  - Sinks: $\\{4,5\\}$.\n  - Edges: $\\{(0,2,100),(1,2,100),(2,3,7),(3,4,100),(3,5,100)\\}$.\n- Test case $4$ (parallel edges and split to multiple sinks):\n  - Vertices: $n = 6$, labeled $0,1,2,3,4,5$.\n  - Sources: $\\{0,1\\}$.\n  - Sinks: $\\{4,5\\}$.\n  - Edges include parallel edges represented as separate triples:\n    $\\{(0,2,5),(0,2,7),(1,2,3),(2,3,4),(2,3,6),(3,4,100),(2,5,1)\\}$.\n\nOutput specification:\n- Your program must compute, for each test case, the integer maximum flow value from the given set of sources to the given set of sinks.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example: $\\texttt{[x\\_1,x\\_2,x\\_3,x\\_4]}$ where $x_i$ is the maximum flow value for test case $i$.\n\nConstraints and clarifications:\n- All capacities are nonnegative integers.\n- When constructing the super-source and super-sink, connect the super-source to each original source and each original sink to the super-sink with capacity at least the sum of all finite capacities in the original graph, which is sufficient to avoid constraining the true maximum flow.\n- No external input is to be read; all test cases are hardcoded as specified.",
            "solution": "The problem requires the computation of the maximum feasible flow in a directed network with multiple source and multiple sink vertices. We must first validate the problem's formulation and then, if valid, derive and implement a solution based on fundamental principles of network flow theory.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Objective**: Compute the maximum value of a feasible flow in a directed graph with a set of source vertices, $S$, and a set of sink vertices, $T$.\n- **Network Definition**: A directed graph $G=(V, E)$ with a non-negative integer capacity function $c(u,v)$ for each edge $(u,v) \\in E$.\n- **Flow Properties**:\n    1.  **Capacity Constraint**: For any edge $(u,v) \\in E$, the flow $f(u,v)$ must satisfy $0 \\le f(u,v) \\le c(u,v)$.\n    2.  **Flow Conservation**: For any vertex $v \\in V \\setminus (S \\cup T)$, the total flow into $v$ must equal the total flow out of $v$: $\\sum_{(u,v) \\in E} f(u,v) = \\sum_{(v,w) \\in E} f(v,w)$.\n- **Methodology**: Reduce the multiple-source, multiple-sink problem to a single-source, single-sink problem by creating an augmented graph. This involves adding a super-source $s'$ connected to all original sources $s \\in S$ and a super-sink $t'$ to which all original sinks $t \\in T$ are connected. The capacity of these new edges must be sufficiently large. The problem suggests a capacity at least the sum of all other finite capacities in the graph. The solution should then be found using a classical max-flow algorithm like Ford-Fulkerson (with Edmonds-Karp) or Dinic, derived from first principles.\n- **Acronyms**: Must be defined on first use, e.g., Breadth-First Search (BFS).\n- **Test Cases**:\n    - **Case 1**: $n=8$ vertices, $S=\\{0,1\\}$, $T=\\{6,7\\}$, and $13$ edges with given capacities.\n    - **Case 2**: $n=5$ vertices, $S=\\{0,1\\}$, $T=\\{3,4\\}$, and $3$ edges, including zero-capacity edges as a key feature.\n    - **Case 3**: $n=6$ vertices, $S=\\{0,1\\}$, $T=\\{4,5\\}$, and $5$ edges, designed to have a single bottleneck.\n    - **Case 4**: $n=6$ vertices, $S=\\{0,1\\}$, $T=\\{4,5\\}$, and $7$ edges, including parallel edges.\n- **Output**: A single line with a comma-separated list of integer maximum flow values for each test case, e.g., `[x_1,x_2,x_3,x_4]`.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated against the validation criteria.\n\n1.  **Scientific or Factual Unsoundness**: The problem is a standard, well-defined problem in graph theory and computer science. The concept of network flow, the max-flow min-cut theorem, and algorithms like Edmonds-Karp are cornerstones of the field. The proposed reduction technique is the standard and mathematically sound method for handling multiple sources and sinks. There are no violations of scientific principles or mathematical logic.\n2.  **Non-Formalizable or Irrelevant**: The problem is rigorously formalizable within the language of graph theory. It is directly on-topic for max-flow algorithms.\n3.  **Incomplete or Contradictory Setup**: All test cases are fully specified with the number of vertices, sets of sources and sinks, and a complete list of edges with their capacities. The instruction for setting the capacity of the new edges is clear and sufficient. There are no contradictions.\n4.  **Unrealistic or Infeasible**: The problem is purely mathematical. All quantities are abstract dimensionless integers. No physical constraints are relevant.\n5.  **Ill-Posed or Poorly Structured**: For a given network, the maximum flow value is unique. The specified reduction and algorithmic approach (e.g., Edmonds-Karp) guarantee finding this unique value. The problem is well-posed.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem requires a correct implementation of a non-trivial graph algorithm. The test cases are thoughtfully constructed to cover general, edge, bottleneck, and multigraph-like scenarios, ensuring the solution must be robust. The problem is not trivial.\n7.  **Outside Scientific Verifiability**: The results are mathematically verifiable. For any computed flow value, one can verify that it is achievable and, by finding a cut of equal capacity, prove that it is maximal.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is scientifically grounded, well-posed, and complete. We proceed with a full solution.\n\n### Derivation and Solution\n\nThe problem of finding the maximum flow from a set of sources $S$ to a set of sinks $T$ in a network $G=(V, E)$ can be solved by transforming it into an equivalent single-source, single-sink max-flow problem. This is a standard construction.\n\n**1. The Augmented Network Construction**\n\nWe construct an augmented network $G'=(V', E')$ from the original network $G=(V, E)$.\n- **Vertices**: Add a new super-source vertex $s'$ and a new super-sink vertex $t'$. The new set of vertices is $V' = V \\cup \\{s', t'\\}$.\n- **Edges**: The new set of edges $E'$ consists of all original edges in $E$, plus new edges from the super-source to each original source, and from each original sink to the super-sink.\n    - $E' = E \\cup \\{ (s', s) \\mid s \\in S \\} \\cup \\{ (t, t') \\mid t \\in T \\}$.\n- **Capacities**: We define a new capacity function $c'$ for $G'$.\n    - For all original edges $(u,v) \\in E$, let their capacity remain the same: $c'(u,v) = c(u,v)$.\n    - For the new edges connecting the super-source, we set their capacity to be effectively infinite, ensuring they do not act as a bottleneck. A safe, finite value is one that is guaranteed to be greater than or equal to the maximum possible flow in the original network. An upper bound on the max flow is the sum of all finite capacities in the original graph, $C_{total} = \\sum_{(u,v) \\in E} c(u,v)$. We set $c'(s', s) = C_{total}$ for all $s \\in S$. An even larger value or true infinity if the type system supports it would also work. For simplicity and correctness, we can set the capacity to the sum of all outgoing capacities from the respective source, $c'(s', s) = \\sum_{(s,u) \\in E} c(s,u)$, but using a global sum $C_{total}$ is simpler to implement and equally correct.\n    - Similarly, for the new edges leading to the super-sink, we set $c'(t, t') = C_{total}$ for all $t \\in T$.\n\n**2. Correctness of the Construction**\n\nWe must show that the maximum flow from $s'$ to $t'$ in $G'$ is equal to the maximum flow from the set $S$ to the set $T$ in $G$. The value of a multi-source, multi-sink flow $|f|$ is defined as the total net flow out of all sources, $|f| = \\sum_{s \\in S} \\left( \\sum_{(s,u) \\in E} f(s,u) - \\sum_{(v,s) \\in E} f(v,s) \\right)$.\n\n- Any feasible flow $f$ in $G$ can be extended to a feasible flow $f'$ in $G'$ of the same value. Define $f'(u,v) = f(u,v)$ for $(u,v) \\in E$. For $s \\in S$, set $f'(s', s)$ to be the net flow leaving $s$ in $G$. For $t \\in T$, set $f'(t, t')$ to be the net flow entering $t$ in $G$. By flow conservation in $G$ for nodes in $V \\setminus (S \\cup T)$, and by construction for nodes in $S$ and $T$, $f'$ satisfies flow conservation in $G'$. The capacity constraints on new edges are met because their capacities are set to a sufficiently large value. The value of the flow $f'$, $|f'| = \\sum_{s \\in S} f'(s', s)$, is exactly the definition of the value of the flow $f$ in $G$. Thus, $\\text{max-flow}(G) \\le \\text{max-flow}(G')$.\n\n- Conversely, any feasible flow $f'$ in $G'$ with value $|f'|$ can be restricted to the edges of $G$ to form a feasible flow $f$ in $G$. The capacity and conservation constraints are trivially met for $f$ on $V \\setminus (S \\cup T)$. The value of this flow is the total net outflow from $S$, which, by conservation at the source nodes in $G'$, is equal to the flow arriving from $s'$, which is $|f'|$. Thus, $\\text{max-flow}(G') \\le \\text{max-flow}(G)$.\n\nCombining these, we have $\\text{max-flow}(G) = \\text{max-flow}(G')$. This establishes the equivalence and validates the reduction method.\n\n**3. Algorithmic Implementation: The Edmonds-Karp Algorithm**\n\nTo find the maximum flow in the single-source, single-sink network $G'$, we will employ the Edmonds-Karp algorithm, which is an implementation of the Ford-Fulkerson method.\n\n- **Ford-Fulkerson Method**: This method is based on the concept of residual networks and augmenting paths. Given a flow network $G$ and a flow $f$, the residual network $G_f$ contains edges representing the remaining capacity for increasing flow. For each edge $(u,v)$ in $G$, the residual network has a forward edge $(u,v)$ with residual capacity $c_f(u,v) = c(u,v) - f(u,v)$ and a backward edge $(v,u)$ with residual capacity $c_f(v,u) = f(u,v)$ (representing the possibility of \"pushing back\" flow). The method repeatedly finds an *augmenting path*—a path from the source to the sink in the residual network with positive capacity on all its edges—and increases the flow along this path. The process terminates when no more augmenting paths can be found.\n\n- **Edmonds-Karp Specialization**: Ford-Fulkerson's method does not specify how to find an augmenting path. The choice of path affects the algorithm's performance. The Edmonds-Karp algorithm specifies that the augmenting path should be the one with the fewest edges, which can be found efficiently using a **Breadth-First Search (BFS)**. This choice guarantees that the algorithm runs in polynomial time, specifically $O(|V| |E|^2)$.\n\nThe overall algorithm is as follows:\n1.  Construct the augmented graph $G'=(V', E')$ with super-source $s'$ and super-sink $t'$, as described above. Represent the network using an adjacency matrix for residual capacities. For graphs with parallel edges, their capacities are summed.\n2.  Initialize the flow to $0$ everywhere. The residual capacity matrix is initialized with the capacities from the augmented graph.\n3.  Initialize the maximum flow value, `max_flow`, to $0$.\n4.  Repeatedly perform the following steps in a loop:\n    a. Find the shortest augmenting path from $s'$ to $t'$ in the current residual graph using BFS. The BFS will also store the path's parent pointers.\n    b. If no such path exists, the algorithm terminates. The current `max_flow` is the maximum possible.\n    c. If a path is found, determine its bottleneck capacity, $\\Delta$, which is the minimum residual capacity of any edge along the path.\n    d. Augment the flow: add $\\Delta$ to the `max_flow` value. Update the residual graph by decreasing the capacity of forward edges along the path by $\\Delta$ and increasing the capacity of backward edges by $\\Delta$.\n5.  Return the final `max_flow` value.\n\nThis procedure correctly computes the maximum flow for each given test case by reducing it to a standard problem and solving it with a proven, efficient algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-source, multi-sink max-flow problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 8,\n            \"sources\": {0, 1},\n            \"sinks\": {6, 7},\n            \"edges\": [\n                (0, 2, 10), (0, 3, 5), (1, 3, 15), (1, 4, 4), (2, 5, 15),\n                (3, 2, 4), (3, 5, 8), (3, 4, 6), (4, 5, 10), (5, 6, 10),\n                (5, 7, 10), (4, 7, 5), (2, 6, 5)\n            ],\n        },\n        {\n            \"n\": 5,\n            \"sources\": {0, 1},\n            \"sinks\": {3, 4},\n            \"edges\": [(0, 2, 7), (2, 3, 0), (2, 4, 0)],\n        },\n        {\n            \"n\": 6,\n            \"sources\": {0, 1},\n            \"sinks\": {4, 5},\n            \"edges\": [\n                (0, 2, 100), (1, 2, 100), (2, 3, 7), (3, 4, 100), (3, 5, 100)\n            ],\n        },\n        {\n            \"n\": 6,\n            \"sources\": {0, 1},\n            \"sinks\": {4, 5},\n            \"edges\": [\n                (0, 2, 5), (0, 2, 7), (1, 2, 3), (2, 3, 4), (2, 3, 6),\n                (3, 4, 100), (2, 5, 1)\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        sources = case[\"sources\"]\n        sinks = case[\"sinks\"]\n        edges = case[\"edges\"]\n\n        # 1. Construct the augmented graph\n        # Super-source will be at index n, super-sink at n+1\n        super_source = n\n        super_sink = n + 1\n        num_vertices_aug = n + 2\n\n        # Adjacency matrix for residual capacities\n        graph = np.zeros((num_vertices_aug, num_vertices_aug), dtype=np.int64)\n\n        total_capacity_sum = 0\n        for u, v, c in edges:\n            graph[u, v] += c\n            total_capacity_sum += c\n        \n        # A sufficiently large capacity for super-edges\n        # Sum of all original capacities is a safe upper bound on the max flow.\n        # If total_capacity_sum is 0, we use 1 to handle disconnected graphs.\n        inf_capacity = total_capacity_sum if total_capacity_sum  0 else 1\n\n        for s in sources:\n            graph[super_source, s] = inf_capacity\n        for t in sinks:\n            graph[t, super_sink] = inf_capacity\n\n        results.append(edmonds_karp(graph, super_source, super_sink))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef bfs(graph, s, t, parent):\n    \"\"\"\n    Breadth-First Search to find an augmenting path in the residual graph.\n    `graph` is the residual capacity matrix.\n    `s` is the source, `t` is the sink.\n    `parent` is an array to store the path.\n    Returns True if a path is found, False otherwise.\n    \"\"\"\n    num_vertices = graph.shape[0]\n    visited = [False] * num_vertices\n    \n    # Use a list as a queue for BFS. For problem constraints, performance is acceptable.\n    queue = []\n    queue.append(s)\n    visited[s] = True\n    parent[s] = -1\n\n    while queue:\n        u = queue.pop(0)\n        for v in range(num_vertices):\n            if not visited[v] and graph[u, v]  0:\n                queue.append(v)\n                visited[v] = True\n                parent[v] = u\n                if v == t:\n                    return True\n    return False\n\ndef edmonds_karp(graph, source, sink):\n    \"\"\"\n    Implements the Edmonds-Karp algorithm to find the maximum flow.\n    `graph` is the initial capacity matrix.\n    `source` and `sink` are the vertices for the flow.\n    \"\"\"\n    num_vertices = graph.shape[0]\n    parent = np.empty(num_vertices, dtype=np.int64)\n    max_flow = 0\n\n    # `residual_graph` will be modified in place\n    residual_graph = np.copy(graph)\n\n    while bfs(residual_graph, source, sink, parent):\n        # Find the bottleneck capacity of the path found by BFS\n        path_flow = np.iinfo(np.int64).max\n        v = sink\n        while v != source:\n            u = parent[v]\n            path_flow = min(path_flow, residual_graph[u, v])\n            v = u\n\n        # Update residual capacities of the edges and reverse edges\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual_graph[u, v] -= path_flow\n            residual_graph[v, u] += path_flow\n            v = u\n\n        # Add path flow to overall flow\n        max_flow += path_flow\n\n    return max_flow\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Beyond simply calculating the maximum possible throughput, we can use flow algorithms as powerful tools for network analysis, such as identifying critical vulnerabilities. This exercise  asks you to determine the \"most vital\" edge in a network—the one whose failure would cause the most significant drop in overall flow capacity. This practice demonstrates how to leverage a max-flow algorithm as a subroutine to assess the robustness and sensitivity of a network's design.",
            "id": "3249860",
            "problem": "You are given a family of directed flow networks. Each network is a directed graph $G=(V,E)$ with a distinguished source vertex $s \\in V$ and sink vertex $t \\in V$. Each directed edge $e \\in E$ has a nonnegative integer capacity $c(e) \\in \\mathbb{Z}_{\\ge 0}$. A feasible flow is a function $f:E \\to \\mathbb{R}_{\\ge 0}$ that satisfies the capacity constraints $0 \\le f(e) \\le c(e)$ for all edges $e \\in E$ and the flow conservation constraints at every vertex $v \\in V \\setminus \\{s,t\\}$ such that the sum of flows into $v$ equals the sum of flows out of $v$. The value of a flow is the net flow sent from $s$ to $t$, which can be computed as the sum of flows on edges leaving $s$ or equivalently the sum of flows on edges entering $t$. A residual network $G_f$ is constructed from $G$ by assigning to each edge $(u,v)$ a residual capacity equal to $c(u,v) - f(u,v)$ and adding a reverse edge $(v,u)$ with capacity equal to $f(u,v)$; an augmenting path is a path from $s$ to $t$ in $G_f$ along which additional flow can be pushed. It is a widely accepted theorem that the maximum flow value equals the capacity of a minimum $s$-$t$ cut, where an $s$-$t$ cut is a partition $(S,T)$ of $V$ with $s \\in S$ and $t \\in T$ and the capacity of the cut is the sum of capacities of all edges going from $S$ to $T$.\n\nDefine a \"most vital\" edge as the edge $e^\\star \\in E$ whose capacity reduction to zero (i.e., removing $e^\\star$ from the network) causes the largest decrease in the maximum flow value between $s$ and $t$. Formally, let $F^\\star$ be the maximum flow value in the original network. For each edge $e_i \\in E$, let $F_i$ be the maximum flow value in the modified network with the capacity of $e_i$ set to $0$. The drop caused by removing $e_i$ is $D_i = F^\\star - F_i$. The most vital edge is any $e^\\star$ that maximizes $D_i$. For ties, select the edge with the smallest index in the given input ordering.\n\nStarting from the core definitions above, write a complete program that, for each network in the provided test suite, computes:\n- the baseline maximum flow value $F^\\star$,\n- the drop values $D_i$ obtained by removing each edge one at a time,\n- the index $i^\\star$ (zero-based, according to the input order) of the most vital edge and the corresponding drop $D_{i^\\star}$.\n\nYour program must implement a correct maximum flow computation grounded in the definitions of residual networks and augmenting paths (for example, an augmenting path algorithm that uses Breadth-First Search, like in the Edmonds-Karp method). The final output must be a single line containing a comma-separated list enclosed in square brackets, where each element is a two-integer list $[i^\\star,D_{i^\\star}]$ for the corresponding test case in the given order. For example, if there are $k$ test cases, the output format is $[[i^\\star_1,D_{i^\\star_1}],\\dots,[i^\\star_k,D_{i^\\star_k}]]$. All capacities are integers, and there are no physical units.\n\nUse the following test suite. In each case, vertices are indexed from $0$ to $n-1$, edges are listed as ordered triples $\\langle u,v,c \\rangle$ with $u$ as the tail, $v$ as the head, and $c$ as the capacity. The edge index is its position in the list, starting at $0$.\n\nTest case $1$:\n- $n = 6$, $s = 0$, $t = 5$,\n- edges:\n  - $\\langle 0,1,10 \\rangle$,\n  - $\\langle 0,2,8 \\rangle$,\n  - $\\langle 1,3,4 \\rangle$,\n  - $\\langle 1,2,2 \\rangle$,\n  - $\\langle 2,3,6 \\rangle$,\n  - $\\langle 3,4,8 \\rangle$,\n  - $\\langle 4,5,10 \\rangle$,\n  - $\\langle 2,4,3 \\rangle$.\n\nTest case $2$:\n- $n = 4$, $s = 0$, $t = 3$,\n- edges:\n  - $\\langle 0,1,5 \\rangle$,\n  - $\\langle 0,2,5 \\rangle$,\n  - $\\langle 1,3,5 \\rangle$,\n  - $\\langle 2,3,5 \\rangle$.\n\nTest case $3$:\n- $n = 5$, $s = 0$, $t = 4$,\n- edges:\n  - $\\langle 0,1,7 \\rangle$,\n  - $\\langle 0,1,3 \\rangle$,\n  - $\\langle 1,2,4 \\rangle$,\n  - $\\langle 2,1,4 \\rangle$,\n  - $\\langle 1,3,6 \\rangle$,\n  - $\\langle 3,4,5 \\rangle$,\n  - $\\langle 2,4,4 \\rangle$.\n\nTest case $4$:\n- $n = 3$, $s = 0$, $t = 2$,\n- edges:\n  - $\\langle 0,1,5 \\rangle$,\n  - $\\langle 1,0,3 \\rangle$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each result encoded as a two-integer list $[i^\\star,D_{i^\\star}]$ in the order of the test cases. For instance, the output must look like $[[i_1,d_1],[i_2,d_2],[i_3,d_3],[i_4,d_4]]$ with no extra whitespace or text.",
            "solution": "The problem is assessed as valid. It is scientifically grounded in the established mathematical theory of network flows, is well-posed with a unique answer guaranteed by the tie-breaking rule, and is expressed in objective, formal language. All necessary data and definitions for a complete solution are provided.\n\nThe problem asks for the identification of a \"most vital edge\" in a flow network. This is defined as the edge whose removal from the network causes the largest decrease in the maximum flow value from a given source $s$ to a sink $t$.\n\nLet the given directed graph be $G=(V, E)$, with source $s \\in V$, sink $t \\in V$, and edge capacities $c(e) \\ge 0$ for all $e \\in E$. Let the list of edges provided in the input be denoted by $L = [e_0, e_1, \\dots, e_{m-1}]$, where $m = |E|$.\n\nThe overall algorithm proceeds as follows:\n$1$. First, compute the maximum flow value, $F^\\star$, in the original network $G$. This is done by constructing a capacity graph from the full list of edges $L$ and running a max-flow algorithm.\n$2$. Then, for each edge $e_i \\in L$ (where $i$ is its zero-based index from $0$ to $m-1$):\n    a. A modified network $G_i$ is constructed by effectively removing the edge $e_i$. This corresponds to creating a graph from the edge list $L \\setminus \\{e_i\\}$.\n    b. The maximum flow value, $F_i$, is computed for this modified network $G_i$.\n    c. The drop in maximum flow is calculated as $D_i = F^\\star - F_i$.\n$3$. After computing all drop values $D_0, D_1, \\dots, D_{m-1}$, we identify the index $i^\\star$ that maximizes this drop. The problem specifies that in case of a tie, the edge with the smallest index $i$ is chosen. Formally, $i^\\star = \\min(\\arg\\max_{i \\in \\{0, \\dots, m-1\\}} D_i)$.\n$4$. The final result for the given network is the pair $[i^\\star, D_{i^\\star}]$.\n\nThe core of this procedure is the computation of the maximum flow. The problem requires a method grounded in residual networks and augmenting paths, such as one driven by Breadth-First Search (BFS). The Edmonds-Karp algorithm is a canonical example of such an approach and will be used for this solution.\n\nThe Edmonds-Karp algorithm operates as follows:\n$1$. Start with zero flow, $f(e) = 0$ for all $e \\in E$. The total flow value is $0$.\n$2$. Construct the residual graph $G_f$. For each edge $(u,v) \\in E$, the residual graph contains a forward edge $(u,v)$ with residual capacity $c_f(u,v) = c(u,v) - f(u,v)$ and a backward edge $(v,u)$ with residual capacity $c_f(v,u) = f(u,v)$. In practice, we can maintain a single residual capacity matrix that is updated iteratively.\n$3$. Repeatedly find an augmenting path from $s$ to $t$ in the residual graph $G_f$ using a Breadth-First Search (BFS). An augmenting path is a path where every edge has a strictly positive residual capacity. BFS is used to find a shortest such path in terms of the number of edges.\n$4$. If a path $p$ is found by BFS:\n    a. Determine the bottleneck capacity $\\delta$ of the path, which is the minimum residual capacity of any edge along $p$. $\\delta = \\min_{(u,v) \\in p} \\{c_f(u,v)\\}$.\n    b. Augment the flow by $\\delta$. This involves increasing the flow by $\\delta$ on all forward edges in $p$ and decreasing it by $\\delta$ on all backward edges. In the residual capacity representation, this means decreasing $c_f(u,v)$ by $\\delta$ and increasing $c_f(v,u)$ by $\\delta$ for each edge $(u,v)$ in $p$.\n    c. Add $\\delta$ to the total flow value.\n$5$. If BFS fails to find a path from $s$ to $t$, the algorithm terminates. The total accumulated flow is the maximum flow value, as per the max-flow min-cut theorem.\n\nThe graph will be represented by an $n \\times n$ capacity matrix, where $n = |V|$. For test cases with multiple edges between the same pair of vertices (a multi-graph, as in test case $3$), the capacities of these parallel edges are summed to form the entry in the capacity matrix. The iterative removal of edges one-by-one is performed on the original list of edges before constructing the capacity matrix for each max-flow computation. This ensures that we are evaluating the vitality of each specific input edge, including individual parallel edges.\nFor example, to compute $F^\\star$, the capacity matrix is built using all edges. To compute $F_i$, the capacity matrix is built from scratch using all edges except $e_i$.\nThe entire process is deterministic and guaranteed to terminate, yielding the desired $[i^\\star, D_{i^\\star}]$ pair for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6, \"s\": 0, \"t\": 5,\n            \"edges\": [\n                (0, 1, 10), (0, 2, 8), (1, 3, 4), (1, 2, 2),\n                (2, 3, 6), (3, 4, 8), (4, 5, 10), (2, 4, 3)\n            ]\n        },\n        {\n            \"n\": 4, \"s\": 0, \"t\": 3,\n            \"edges\": [\n                (0, 1, 5), (0, 2, 5), (1, 3, 5), (2, 3, 5)\n            ]\n        },\n        {\n            \"n\": 5, \"s\": 0, \"t\": 4,\n            \"edges\": [\n                (0, 1, 7), (0, 1, 3), (1, 2, 4), (2, 1, 4),\n                (1, 3, 6), (3, 4, 5), (2, 4, 4)\n            ]\n        },\n        {\n            \"n\": 3, \"s\": 0, \"t\": 2,\n            \"edges\": [\n                (0, 1, 5), (1, 0, 3)\n            ]\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        n, s, t, edges = case[\"n\"], case[\"s\"], case[\"t\"], case[\"edges\"]\n        \n        # 1. Compute baseline maximum flow F_star\n        F_star = edmonds_karp(n, s, t, edges)\n        \n        drops = []\n        # 2. Iterate through each edge, remove it, and compute the new max flow\n        for i in range(len(edges)):\n            # Create a temporary list of edges with the i-th edge removed\n            temp_edges = edges[:i] + edges[i+1:]\n            \n            # Compute max flow F_i for the modified network\n            F_i = edmonds_karp(n, s, t, temp_edges)\n            \n            # Calculate the drop D_i\n            D_i = F_star - F_i\n            drops.append(D_i)\n        \n        # 3. Find the index and value of the maximum drop\n        if not drops:\n            # Handle cases with no edges\n            best_index, max_drop = 0, 0\n        else:\n            max_drop = -1\n            best_index = -1\n            for i, drop in enumerate(drops):\n                if drop  max_drop:\n                    max_drop = drop\n                    best_index = i\n            # If all drops are 0, the first edge (index 0) is chosen due to the tie-breaking rule\n            if best_index == -1:\n                best_index = 0\n                max_drop = 0\n\n        final_results.append([best_index, max_drop])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\".replace(\" \", \"\"))\n\ndef build_capacity_matrix(n, edges):\n    \"\"\"\n    Constructs a capacity matrix from a list of edges.\n    Handles parallel edges by summing their capacities.\n    \"\"\"\n    capacity = np.zeros((n, n), dtype=int)\n    for u, v, c in edges:\n        capacity[u, v] += c\n    return capacity\n\ndef bfs_augmenting_path(n, s, t, residual_graph):\n    \"\"\"\n    Finds an augmenting path from s to t in the residual graph using BFS.\n    Returns the path and its bottleneck capacity.\n    \"\"\"\n    parent = {node: None for node in range(n)}\n    queue = deque([s])\n    visited = {s}\n    \n    while queue:\n        u = queue.popleft()\n        if u == t:\n            break\n        \n        for v in range(n):\n            if v not in visited and residual_graph[u, v]  0:\n                parent[v] = u\n                visited.add(v)\n                queue.append(v)\n        else:\n            continue # Continue if inner loop wasn't broken\n        break # Break outer loop if u == t\n    else: # If while loop finishes without finding t\n       return None, 0\n\n    # Reconstruct path and find bottleneck capacity\n    path = []\n    curr = t\n    path_flow = float('inf')\n    while curr != s:\n        prev = parent[curr]\n        path.append((prev, curr))\n        path_flow = min(path_flow, residual_graph[prev, curr])\n        curr = prev\n    \n    path.reverse()\n    return path, path_flow\n    \ndef edmonds_karp(n, s, t, edges):\n    \"\"\"\n    Computes the maximum flow in a network using the Edmonds-Karp algorithm.\n    \"\"\"\n    # Build capacity matrix from the given edges.\n    capacity_matrix = build_capacity_matrix(n, edges)\n    \n    # Create a copy for the residual graph, which will be modified.\n    residual_graph = capacity_matrix.copy()\n    \n    max_flow = 0\n    while True:\n        path, path_flow = bfs_augmenting_path(n, s, t, residual_graph)\n        \n        if path_flow == 0:\n            break\n            \n        max_flow += path_flow\n        \n        # Update residual capacities\n        for u, v in path:\n            residual_graph[u, v] -= path_flow\n            residual_graph[v, u] += path_flow\n            \n    return max_flow\n\nsolve()\n```"
        }
    ]
}