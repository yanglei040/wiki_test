{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂算法之前，对强连通分量 (Strongly Connected Component, SCC) 的本质建立一个坚实的直观理解至关重要。这个练习剥离了算法的复杂性，要求你从基本定义出发进行思考。通过用最少的边构建一个具有特定 SCC 属性的图，你将对强连通性所需的内部结构以及分量之间必需的隔离性形成深刻的直觉。",
            "id": "3276714",
            "problem": "设 $V$ 是一个偶数正整数，且 $V \\geq 2$。考虑一个有限简单有向图 $G=(\\mathcal{V},\\mathcal{E})$，其顶点数 $|\\mathcal{V}|=V$，图中没有平行边，也没有自环。该图需要恰好有 $V/2$ 个强连通分量 (SCC)，每个分量的大小为 $2$。\n\n仅使用有向图中强连通分量的核心定义——即顶点子集 $C \\subseteq \\mathcal{V}$，对于其中任意一对顶点 $u,v \\in C$，都存在从 $u$ 到 $v$ 和从 $v$ 到 $u$ 的有向路径——确定 $|\\mathcal{E}|$ 的最小可能值，并用关于 $V$ 的封闭表达式表示。你的推理必须包括一个达到此下界的构造，以及一个证明，说明满足要求的图不可能使用更少的边。你可以假设用于计算强连通分量的算法，如 Kosaraju's algorithm 和 Tarjan's algorithm，在线性时间 $O(|\\mathcal{V}|+|\\mathcal{E}|)$ 内运行，但在你的推导中，除了基本的强连通分量定义外，不要使用这些算法的任何其他性质。\n\n请以 $V$ 的单个解析表达式形式提供你的最终答案。无需四舍五入。",
            "solution": "问题要求找到一个简单有向图 $G=(\\mathcal{V},\\mathcal{E})$ 的最小可能边数 $|\\mathcal{E}|$。该图有 $|\\mathcal{V}|=V$ 个顶点，其中 $V$ 是一个偶数正整数 ($V \\geq 2$)，且该图恰好有 $V/2$ 个强连通分量 (SCC)，每个分量的大小为 $2$。推导过程必须仅依赖于强连通分量的基本定义。\n\n设顶点集为 $\\mathcal{V}$。根据条件，图 $G$ 的顶点被划分为 $V/2$ 个不相交的子集 $C_1, C_2, \\dots, C_{V/2}$，这些子集构成了图的强连通分量。每个分量的大小为 $|C_i| = 2$。\n设 $\\mathcal{E}$ 是图中的边集。我们可以将边集 $\\mathcal{E}$ 划分为两个不相交的子集：\n1.  $\\mathcal{E}_{intra}$：两个端点都在同一个强连通分量内的边的集合。\n2.  $\\mathcal{E}_{inter}$：两个端点在不同强连通分量内的边的集合。\n\n总边数为 $|\\mathcal{E}| = |\\mathcal{E}_{intra}| + |\\mathcal{E}_{inter}|$。为了最小化 $|\\mathcal{E}|$，我们必须找到 $|\\mathcal{E}_{intra}|$ 和 $|\\mathcal{E}_{inter}|$ 的最小可能值。\n\n首先，我们确定单个强连通分量内部所需的最小边数。考虑一个任意的强连通分量 $C_k$，其中 $|C_k|=2$。设此分量中的两个顶点为 $u$ 和 $v$，因此 $C_k = \\{u, v\\}$。\n强连通分量的定义要求，对于分量中的每一对顶点，都存在从第一个顶点到第二个顶点的有向路径，反之亦然。\n将此定义应用于 $C_k$：\n- 必须存在一条从 $u$ 到 $v$ 的路径。\n- 必须存在一条从 $v$ 到 $u$ 的路径。\n\n由于图是简单的，没有自环（例如 $(u,u)$）也没有平行边。$u$ 和 $v$ 之间的路径只能涉及 $\\mathcal{V}$ 中的顶点。然而，要使 $C_k$ 成为一个强连通分量，如果我们要将其视为一个最小单元，建立其强连通性的路径必须存在于由 $C_k$ 导出的子图中。更正式地说，如果我们考虑任何从 $u$ 到 $v$ 的路径，该路径涉及一个顶点 $w \\notin C_k$，那么为了使 $C_k$ 保持为一个独立的强连通分量，就不能存在从 $w$ 回到 $u$ 或 $v$ 的路径，这会使结构复杂化。满足该定义最直接的方法是使用完全在 $\\{u,v\\}$ 内部的边。\n\n为了仅使用顶点 $\\{u,v\\}$ 得到一条从 $u$ 到 $v$ 的路径，最短且唯一可能的简单路径就是单条边 $(u,v)$。\n同样，为了仅使用顶点 $\\{u,v\\}$ 得到一条从 $v$ 到 $u$ 的路径，最短的路径就是边 $(v,u)$。\n因此，要使集合 $\\{u,v\\}$ 强连通，我们至少需要这两条边：$(u,v)$ 和 $(v,u)$。如果只有一条边，比如 $(u,v)$，那么从 $v$ 到 $u$ 就没有路径了。因此，对于每个大小为 $2$ 的强连通分量，最少需要 $2$ 条边。\n\n存在 $V/2$ 个这样的不相交的强连通分量。每个分量内部至少需要包含 $2$ 条边。$\\mathcal{E}_{intra}$ 中的总最小边数是每个分量最小边数之和：\n$$|\\mathcal{E}_{intra}|_{min} = \\sum_{i=1}^{V/2} 2 = \\frac{V}{2} \\times 2 = V$$\n\n接下来，我们考虑分量间边的集合 $\\mathcal{E}_{inter}$。这些边连接一个强连通分量 $C_i$ 中的顶点到另一个不同强连通分量 $C_j$ 中的顶点（其中 $i \\neq j$）。\n强连通分量的一个基本性质是“分量图”（其中每个节点代表 $G$ 的一个强连通分量）必须是一个有向无环图 (DAG)。如果分量图中存在一个环（例如，从 $C_i$ 到 $C_j$ 的路径，以及另一条从 $C_j$ 回到 $C_i$ 的路径），那么 $C_i$ 和 $C_j$ 中的所有顶点都将相互可达。这将使它们合并成一个更大的强连通分量，这与问题陈述中 $C_i$ 和 $C_j$ 是不同的强连通分量相矛盾。\n边数 $|\\mathcal{E}_{inter}|$ 必须是非负的，即 $|\\mathcal{E}_{inter}| \\geq 0$。为了最小化总边数 $|\\mathcal{E}|$，我们必须为 $|\\mathcal{E}_{inter}|$ 选择最小可能值，即 $0$。如果 $|\\mathcal{E}_{inter}| = 0$，则任何强连通分量之间都没有边。在这种情况下，分量图没有边，这显然是一个有向无环图。这个选择没有违反问题的任何条件。\n\n结合这些发现，总边数的最小可能值为：\n$$|\\mathcal{E}|_{min} = |\\mathcal{E}_{intra}|_{min} + |\\mathcal{E}_{inter}|_{min} = V + 0 = V$$\n这就为 $|\\mathcal{E}|$ 建立了一个下界 $V$。\n\n为了完成证明，我们必须通过构造一个满足所有给定条件且恰好有 $V$ 条边的图，来证明这个下界是可以达到的。\n设顶点集为 $\\mathcal{V} = \\{v_1, v_2, \\dots, v_V\\}$。\n我们将 $\\mathcal{V}$ 划分为 $V/2$ 个顶点对：$C_i = \\{v_{2i-1}, v_{2i}\\}$，其中 $i=1, 2, \\dots, V/2$。\n我们如下定义边集 $\\mathcal{E}$：对于每个顶点对 $C_i$，我们添加边 $(v_{2i-1}, v_{2i})$ 和 $(v_{2i}, v_{2i-1})$。\n完整的边集为 $\\mathcal{E} = \\bigcup_{i=1}^{V/2} \\{ (v_{2i-1}, v_{2i}), (v_{2i}, v_{2i-1}) \\}$。\n这个构造出的图的总边数为 $|\\mathcal{E}| = \\sum_{i=1}^{V/2} 2 = V$。\n\n现在，我们验证这个图是否满足问题的标准：\n1.  该图有 $V$ 个顶点，并且是简单的（根据构造，没有自环或平行边）。\n2.  对于任何集合 $C_i$，顶点 $v_{2i-1}$ 和 $v_{2i}$ 通过在集合内部构造的边是相互可达的。因此，每个 $C_i$ 都是一个强连通集。\n3.  任何两个不同的集合 $C_i$ 和 $C_j$（其中 $i \\neq j$）之间没有边。因此，$C_i$ 中的顶点无法到达 $C_j$ 中的顶点。这确保了没有强连通分量能比任何一个集合 $C_i$ 更大。\n4.  根据第 2 点和第 3 点，顶点的最大强连通子集恰好是集合 $C_1, C_2, \\dots, C_{V/2}$。\n5.  因此，该图恰好有 $V/2$ 个强连通分量，并且每个分量的大小为 $2$。\n\n该构造是有效的，并且其边数 $|\\mathcal{E}| = V$。既然我们证明了一个 $V$ 的下界，并展示了一个达到该下界的构造，那么 $|\\mathcal{E}|$ 的最小可能值就是 $V$。",
            "answer": "$$\\boxed{V}$$"
        },
        {
            "introduction": "理论的理解是一方面，而亲手实现算法则能将知识固化。这个练习将指导你完成将线性时间 SCC 算法的抽象步骤转化为具体代码的全过程。这项综合性任务不仅要求你编写算法，还要求你证明其正确性，这是理解为什么 Kosaraju 算法的两遍深度优先搜索（DFS）或 Tarjan 算法的堆栈与 low-link 机制能够正确工作的关键。",
            "id": "3205772",
            "problem": "设计并详述一个完整算法，用于计算有向图的所有强连通分量 (SCCs)，并基于图可达性和深度优先搜索 (DFS) 的第一性原理证明其正确性。您必须将该算法实现为一个可运行的程序，该程序针对一组固定的测试图输出规范化的 SCC。您的算法必须是 Kosaraju 算法或 Tarjan 算法之一；您必须做出一个明确的选择，并为其提供完整的伪代码规范。\n\n用作起点的基础和定义：\n- 有向图是一个有序对 $G=(V,E)$，其中 $V$ 是一个有限的顶点集合，顶点由连续整数 $0,\\dots,n-1$ 标记（对于某个整数 $n \\ge 0$），而 $E \\subseteq V \\times V$ 是一个有向边集合。\n- 对于 $u,v \\in V$，如果存在一个顶点序列 $u=x_0,x_1,\\dots,x_k=v$（其中 $k \\ge 0$ 且对于所有 $i \\in \\{0,\\dots,k-1\\}$ 都有 $(x_i,x_{i+1}) \\in E$），则称存在一条从 $u$ 到 $v$ 的路径。\n- 如果对于子集 $C \\subseteq V$ 中的所有 $u,v \\in C$，都存在从 $u$ 到 $v$ 的路径和从 $v$ 到 $u$ 的路径，并且在该属性下 $C$ 对于集合包含关系是极大的，则称 $C$ 是一个强连通分量。\n- 深度优先搜索 (DFS) 通过递归访问未访问过的出邻居来探索路径，在标准的 DFS 分类下，每条边 $(u,v)$ 要么是树边、后向边、前向边，要么是横叉边。顶点的 DFS 完成时间是它被完全探索并被添加到一个完成顺序栈中的时间。转置图 $G^T=(V,E^T)$ 具有 $E^T=\\{(v,u)\\mid (u,v)\\in E\\}$。\n- $G$ 的缩点（分量）图将每个强连通分量收缩为单个顶点，从而产生一个有向无环图 (DAG)。\n\n您的任务：\n1. 从 Kosaraju 算法或 Tarjan 算法中选择一个，并提供精确的、与语言无关的伪代码。该伪代码接受一个以邻接表 $Adj[0 \\dots n-1]$ 形式给出的有向图 $G=(V,E)$ 作为输入，其中 $Adj[u]$ 枚举了所有满足 $(u,v)\\in E$ 的 $v$。所有中间变量、函数名和数字都必须使用 LaTeX 表示法编写。\n2. 从第一性原理推导算法的正确性。从上述基础定义以及关于 DFS 和转置图的久经检验的事实出发，解释为什么该算法能将 $V$ 划分为多个 SCC。您的推理不能依赖任何未经证明的捷径陈述，并且必须清晰地阐述保证正确性的不变量。\n3. 根据 $n=|V|$ 和 $m=|E|$ 分析运行时间，并说明空间使用情况。\n4. 为实现确定性输出的规范化要求：对于每个 SCC $C$，按升序输出其顶点。对于所有 SCC 的集合，按这些已排序顶点列表的字典序对该列表进行排序。对于 $n=0$ 的空图，输出为空列表。\n5. 实现要求：将您选择的算法实现为一个完整的程序，该程序不接受任何输入，而是在以下固定的测试套件上运行（图由 $n$ 和一个邻接表给出）。顶点标记为 $0$ 到 $n-1$。\n- 测试 $1$：$n=8$，边集合 $\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,3),(6,7)\\}$。邻接表：$Adj = [[1],[2],[0,3],[4],[5],[3],[7],[]]$。\n- 测试 $2$：$n=0$，边集合 $\\emptyset$。邻接表：$Adj = []$。\n- 测试 $3$：$n=1$，边集合 $\\emptyset$。邻接表：$Adj = [[]]$。\n- 测试 $4$：$n=1$，边集合 $\\{(0,0)\\}$。邻接表：$Adj = [[0]]$。\n- 测试 $5$：$n=5$，边集合 $\\{(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(3,0),(4,1)\\}$。邻接表：$Adj = [[1,2],[2,3],[3,4],[4,0],[0,1]]$。\n- 测试 $6$：$n=6$，边集合 $\\{(0,1),(1,2),(3,4),(4,5)\\}$。邻接表：$Adj = [[1],[2],[],[4],[5],[]]$。\n\n最终输出格式：\n- 您的程序必须向标准输出生成确切的一行。该行必须是测试 1 到 6 的结果的单个带括号列表，按顺序排列。每个结果本身是一个整数列表的列表，按规定进行规范化。整行必须是形式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$ 的单个字符串，其中每个 $r_i$ 是测试 $i$ 的规范化 SCC 列表。不得打印任何解释性文本。\n- 答案是纯整数列表；不涉及物理单位或角度单位。",
            "solution": "计算有向图的强连通分量 (SCC) 是图论和计算机科学中的一个基本任务。该问题陈述是有效的，因为它基于标准的、定义明确的数学概念，内容自洽，并提出了一个具有客观解标准的适定问题。我将选择 Kosaraju 算法，因为它概念清晰，依赖于两次连续的深度优先搜索 (DFS) 应用。\n\nKosaraju 算法分三个主要阶段运行：\n1.  对输入图 $G=(V,E)$ 执行一次 DFS 遍历，以确定所有顶点的完成时间。顶点按照它们完成的顺序存储在一个数据结构（例如，栈或列表）中。\n2.  计算转置图 $G^T=(V,E^T)$，其中 $E^T = \\{ (v,u) \\mid (u,v) \\in E \\}$。\n3.  在转置图 $G^T$ 上执行第二次 DFS 遍历。本次 DFS 的主循环按第一阶段计算出的顶点完成时间的降序来考虑顶点。最终得到的 DFS 森林中的每棵树都对应一个不同的强连通分量。\n\n现在我将提供形式化伪代码，从第一性原理推导其正确性，并分析其复杂度。\n\n**1. Kosaraju 算法的伪代码**\n\n设输入图为 $G=(V,E)$，其中 $|V|=n$ 且 $|E|=m$，由邻接表 $Adj$ 表示。\n\n主过程是 `KOSARAJU`。它使用两个辅助过程，`DFS_PASS1` 和 `DFS_PASS2`。\n\n`全局变量：`\n- $visited$: 一个大小为 $n$ 的布尔数组，初始化为 $\\text{false}$。\n- $F$: 一个列表或栈，用于按完成顺序存储顶点。\n\n`过程 KOSARAJU(G=(V,E))`:\n1. 对于每个顶点 $u \\in V$:\n2.     $visited[u] \\leftarrow \\text{false}$\n3. $F \\leftarrow \\text{空列表}$\n4. 对于每个顶点 $u \\in V$:\n5.     如果 not $visited[u]$:\n6.         `DFS_PASS1(G, u)`\n7. 根据 $G$ 计算 $G^T$。\n8. 对于每个顶点 $u \\in V$:\n9.     $visited[u] \\leftarrow \\text{false}$\n10. $SCCs \\leftarrow \\text{空的列表的列表}$\n11. 当 $F$ 非空时:\n12.     $u \\leftarrow F.\\text{pop}()$ (获取具有最晚完成时间的顶点)\n13.     如果 not $visited[u]$:\n14.         $component \\leftarrow \\text{空列表}$\n15.         `DFS_PASS2(G^T, u, component)`\n16.         将 $component$ 追加到 $SCCs$。\n17. 返回 $SCCs$。\n\n`过程 DFS_PASS1(G, u)`:\n1. $visited[u] \\leftarrow \\text{true}$\n2. 对于 $G$ 中 $u$ 的每个邻居 $v$:\n3.     如果 not $visited[v]$:\n4.         `DFS_PASS1(G, v)`\n5. 将 $u$ 推入列表 $F$ 的前端。\n\n`过程 DFS_PASS2(G^T, u, component)`:\n1. $visited[u] \\leftarrow \\text{true}$\n2. 将 $u$ 添加到 $component$。\n3. 对于 $G^T$ 中 $u$ 的每个邻居 $v$:\n4.     如果 not $visited[v]$:\n5.         `DFS_PASS2(G^T, v, component)`\n\n**2. 正确性证明**\n\nKosaraju 算法的正确性取决于缩点图和 DFS 完成时间的一个基本性质。缩点图 $G^{SCC}$ 是通过将 $G$ 的每个 SCC 收缩成一个超顶点而形成的。如果在 $G$ 中存在一条从某个顶点 $u \\in C_i$ 到某个顶点 $v \\in C_j$ 的边（其中 $C_i$ 和 $C_j$ 是与 $S_i$ 和 $S_j$ 对应的 SCC），那么在 $G^{SCC}$ 中就存在一条从超顶点 $S_i$ 到 $S_j$ 的边。根据 SCC 的定义，$G^{SCC}$ 是一个有向无环图 (DAG)。\n\n设 $f(u)$ 表示在对 $G$ 进行第一次 DFS 遍历时顶点 $u$ 的完成时间。对于任何 SCC $C \\subseteq V$，设 $f_{\\max}(C) = \\max_{u \\in C} \\{f(u)\\}$。\n\n**核心引理：** 如果 $C_1$ 和 $C_2$ 是 $G$ 中两个不同的 SCC，且存在一条边 $(u,v) \\in E$ 使得 $u \\in C_1$ 且 $v \\in C_2$，则 $f_{\\max}(C_1) > f_{\\max}(C_2)$。\n\n**引理证明：**\n我们考虑对 $G$ 进行第一次 DFS 遍历时的两种情况。\n- **情况1：** DFS 在访问 $C_1$ 中任何顶点之前，首先访问了 $C_2$ 中的一个顶点。设 $x \\in C_2$ 是在 $C_2$ 中被访问的第一个顶点。从 $x$ 开始的 DFS 遍历将探索所有从 $x$ 可达的顶点。由于 $C_2$ 中的所有顶点是相互可达的，它们都将作为以 $x$（或其在 $C_2$ 内的某个后代）为根的 DFS 树的一部分被访问。因为不存在从 $C_2$ 中任何顶点回到 $C_1$ 中任何顶点的路径（否则它们将属于同一个 SCC），所以从 $x$ 开始的 DFS 不会访问 $C_1$ 中的任何顶点。因此，$C_2$ 中的所有顶点都将在包含它们的子树遍历完成之前被探索并完成。具体来说，$C_2$ 中的所有顶点都在 $x$ 完成之前完成。由于此时 $C_1$ 中还没有顶点被访问，所有 $C_1$ 中的顶点将在 $C_2$ 中所有顶点都完成之后才开始和完成。因此，$f_{\\max}(C_1) > f_{\\max}(C_2)$。\n- **情况2：** DFS 在访问 $C_2$ 中任何顶点之前，首先访问了 $C_1$ 中的一个顶点。设 $x \\in C_1$ 是在 $C_1$ 中被访问的第一个顶点。从 $x$ 开始的 DFS 将探索所有从 $x$ 可达的顶点。这包括 $C_1$ 中的所有顶点（根据 SCC 的定义）以及由于边 $(u, v)$ 和 $C_1$ 内部的路径，也包括 $C_2$ 中的所有顶点。因此，整个分量 $C_2$ 将被包含在以 $x$ 为根的 DFS 子树中。在 DFS 中，子树中的任何顶点都在该子树的根完成之前完成。因此，$C_2$ 中所有顶点的完成时间都将小于 $f(x)$。由于 $x \\in C_1$，我们有 $f_{\\max}(C_2)  f(x) \\le f_{\\max}(C_1)$。\n\n在两种情况下，引理都成立。\n\n**主要论证：**\n算法的第二阶段在转置图 $G^T$ 上执行 DFS，按第一次遍历得到的完成时间 $f(u)$ 的降序处理顶点。\n\n设 $s$ 是 $V$ 中所有顶点里完成时间最晚的顶点。设 $C_s$ 是包含 $s$ 的 SCC。根据核心引理，如果 $G$ 中存在从另一个 SCC（比如 $C'$）到 $C_s$ 的边，那就意味着 $f_{\\max}(C') > f_{\\max}(C_s)$。但 $s$ 具有全局最晚的完成时间，所以 $f_{\\max}(C_s)$ 必须是所有 SCC 中最大的。这是一个矛盾。因此，在 $G$ 中不可能有从任何其他 SCC 到 $C_s$ 的边。这意味着 $C_s$ 在缩点图 $G^{SCC}$ 中是一个“汇点分量”。\n\n在转置图 $G^T$ 中，分量之间的所有边都被反转。$G$ 中一条边 $(u,v)$（其中 $u \\in C_i, v \\in C_j$）在 $G^T$ 中变为 $(v,u)$。因此，$G^{SCC}$ 中的汇点分量在 $G^T$ 的缩点图中成为“源点分量”。在 $G^T$ 中，没有从任何其他 SCC *到* $C_s$ 的边。\n\n当第二次 DFS 在 $G^T$ 上从顶点 $s$ 开始时，它可以到达 $C_s$ 中的所有其他顶点，因为它们在 $G$ 中是相互可达的，因此在 $G^T$ 中也是。然而，它无法到达 $C_s$ 之外的任何顶点，因为这将意味着在 $G^T$ 中存在一条从 $C_s$ 中的顶点到另一个分量中顶点的边，而我们刚刚证明了这是不可能的。因此，在第二次遍历中找到的第一个 DFS 树恰好由 SCC $C_s$ 的顶点组成。\n\n在识别出这第一个 SCC 后，其顶点被标记为已访问。然后，算法选择具有最高剩余完成时间的未访问顶点。该顶点属于一个在由剩余未访问顶点诱导的 $G$ 的子图中作为汇点分量的 SCC。同样的论证可以递归地应用。这个过程持续进行，正确地将整个顶点集 $V$ 划分为其强连通分量。在 `KOSARAJU` 的主循环中对 `DFS_PASS2` 的每次调用都恰好识别出一个 SCC。\n\n**3. 复杂度分析**\n\n- **时间复杂度：**\n    1. 第一次 DFS 遍历 (`DFS_PASS1`) 对 $G$ 的每个顶点和每条边恰好访问一次。其运行时间为 $O(n+m)$。\n    2. 计算转置图 $G^T$ 需要遍历 $G$ 的所有边，花费 $O(m)$ 时间来构建新的邻接表，或者 $O(n+m)$ 时间来初始化和构建它。\n    3. 第二次 DFS 遍历 (`DFS_PASS2`) 对 $G^T$ 的每个顶点和每条边恰好访问一次。顶点数为 $n$，边数为 $m$。其运行时间为 $O(n+m)$。\n    总时间复杂度是这些步骤的总和，即 $O(n+m) + O(n+m) + O(n+m) = O(n+m)$。\n\n- **空间复杂度：**\n    1. 以邻接表形式存储图 $G$ 及其转置 $G^T$ 需要 $O(n+m)$ 的空间。\n    2. $visited$ 数组需要 $O(n)$ 的空间。\n    3. 用于存储完成顺序的列表 $F$ 需要 $O(n)$ 的空间。\n    4. DFS 过程的递归栈在最坏情况下（例如，一个路径图）深度可达 $n$，需要 $O(n)$ 的空间。\n    总空间复杂度主要由图的存储决定，结果为 $O(n+m)$。\n\n**4. 规范化**\n\n指定的规范化要求两个层次的排序。\n1.  对于每个已识别的 SCC，其顶点索引列表必须按升序排序。\n2.  最终的所有 SCC 列表必须按字典序排序。这意味着，对于表示为已排序列表的两个 SCC $C_1$ 和 $C_2$，如果 $C_1$ 在字典序上小于 $C_2$，则 $C_1$ 排在 $C_2$ 之前。\n\n这些排序步骤在核心算法识别出分量后应用。排序的复杂度不是主导性的。如果有 $k$ 个 SCC，第 $i$ 个分量的大小为 $|C_i|$，对所有分量排序需要 $\\sum_{i=1}^{k} O(|C_i| \\log |C_i|)$，其上界为 $O(n \\log n)$。对最终的 $k$ 个分量列表进行排序相比之下可以忽略不计。对于典型的图，整体的 $O(n+m)$ 复杂度仍然是主导的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np\n\n# It is good practice to increase the recursion limit for deep graphs in Python DFS.\n# The test cases here are small, but this makes the implementation robust.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main function to run Kosaraju's algorithm on a fixed set of test cases\n    and print the results in the specified canonical format.\n    \"\"\"\n\n    # Test cases defined as tuples of (n, adjacency_list)\n    test_cases = [\n        # Test 1: Two SCCs {0,1,2} and {3,4,5}, and two trivial ones {6}, {7}\n        (8, [[1], [2], [0, 3], [4], [5], [3], [7], []]),\n        # Test 2: Empty graph\n        (0, []),\n        # Test 3: Single vertex, no edges\n        (1, [[]]),\n        # Test 4: Single vertex, self-loop\n        (1, [[0]]),\n        # Test 5: Fully connected component\n        (5, [[1, 2], [2, 3], [3, 4], [4, 0], [0, 1]]),\n        # Test 6: Two disjoint paths, all vertices are trivial SCCs\n        (6, [[1], [2], [], [4], [5], []]),\n    ]\n    \n    final_results = []\n\n    for n, adj in test_cases:\n        if n == 0:\n            final_results.append(\"[]\")\n            continue\n\n        # --- Kosaraju's Algorithm ---\n        \n        # Step 1: First DFS pass on G to compute finishing order\n        visited = [False] * n\n        finish_stack = []\n        \n        def dfs1(u):\n            visited[u] = True\n            for v in adj[u]:\n                if not visited[v]:\n                    dfs1(v)\n            finish_stack.append(u)\n\n        for i in range(n):\n            if not visited[i]:\n                dfs1(i)\n        \n        # Step 2: Compute the transpose graph G^T\n        adj_t = [[] for _ in range(n)]\n        for u in range(n):\n            for v in adj[u]:\n                adj_t[v].append(u)\n\n        # Step 3: Second DFS pass on G^T in decreasing order of finishing times\n        visited = [False] * n\n        sccs = []\n        \n        def dfs2(u, current_scc):\n            visited[u] = True\n            current_scc.append(u)\n            for v in adj_t[u]:\n                if not visited[v]:\n                    dfs2(v, current_scc)\n\n        while finish_stack:\n            u = finish_stack.pop()\n            if not visited[u]:\n                current_scc = []\n                dfs2(u, current_scc)\n                # Canonicalization Step 1: Sort vertices within the SCC\n                current_scc.sort()\n                sccs.append(current_scc)\n        \n        # Canonicalization Step 2: Sort the list of SCCs lexicographically\n        sccs.sort()\n        \n        # Format the result for this test case as a string\n        case_result_str = str(sccs).replace(\" \", \"\")\n        final_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个算法工具的真正威力在于其应用。这个练习提出了一个常见的图论问题：如何通过添加最少的边来增强一个图，以达到一个期望的全局属性——在这里，是使整个图成为强连通的。你将看到，通过将图分解为其 SCC，如何将一个复杂的问题转化为一个在其压缩图（一个有向无环图，Directed Acyclic Graph, DAG）上仅涉及其“源”和“汇”分量的更简单问题，这展示了 SCC 分析作为许多其他图算法的强大预处理步骤的价值。",
            "id": "3276553",
            "problem": "考虑有向图 $G = (V, E)$，其中 $V = \\{1, 2, \\dots, 14\\}$ 且\n$$E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}.$$\n假设 $G$ 是一个有向无环图 (DAG)。仅使用基本定义（例如，强连通性和强连通分量的定义）以及关于强连通分量的线性时间算法（如 Tarjan 算法和 Kosaraju 算法）的公认事实，确定为了使图 $G$ 成为强连通图，必须向其添加的最少有向边数（不移除任何现有边，也不创建平行边或自环）。你的推理应从强连通性的定义和强连通分量的凝聚图的结构开始，并且你可以依据强连通分量可以在 $O(|V| + |E|)$ 时间内计算出来这一事实。\n\n将最终答案表示为单个整数（无单位）。无需四舍五入。",
            "solution": "问题要求为了使给定的有向图 $G=(V,E)$ 变为强连通图，需要添加的最少有向边数。该图由顶点集 $V = \\{1, 2, \\dots, 14\\}$ 和边集 $E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}$ 定义。题目说明 $G$ 是一个有向无环图 (DAG)。\n\n首先，我们回顾一下相关定义。如果对于每对不同的有序顶点 $(u, v)$，都存在一条从 $u$ 到 $v$ 的有向路径，则称该有向图是**强连通**的。有向图的一个**强连通分量 (SCC)** 是一个极大的强连通子图。\n\n任何有向图都可以唯一地划分成其强连通分量。通过将每个 SCC 缩成一个单一的超顶点，我们可以构成**凝聚图** $G_{SCC}$。在 $G_{SCC}$ 中，从超顶点 $C_i$ 到超顶点 $C_j$ 存在一条边，当且仅当在原图 $G$ 中，存在一条从 SCC $C_i$ 中的某个顶点到 SCC $C_j$ 中的某个顶点的边。凝聚图的一个基本性质是它总是一个有向无环图 (DAG)。\n\n为了使原图 $G$ 强连通，我们必须添加边，使得任意两个顶点之间都存在路径。这等价于使凝聚图 $G_{SCC}$ 强连通。由于 $G_{SCC}$ 是一个 DAG，使其强连通意味着将其简化为单个 SCC，这可以通过添加边来创建一个包含 $G_{SCC}$ 所有超顶点的环来实现。\n\n题目说明初始图 $G$ 是一个 DAG。根据定义，DAG 中没有有向环。对于两个或多个顶点要形成一个 SCC，必须有一个包含它们的环。由于 $G$ 没有环，所以 $G$ 中的任何 SCC 都必须由单个顶点组成。因此，对于给定的图 $G$，它的 14 个顶点中的每一个都是其自身的 SCC。\n\n这意味着凝聚图 $G_{SCC}$ 与原图 $G$ 同构。$G_{SCC}$ 的超顶点就是 $G$ 的顶点，$G_{SCC}$ 的边就是 $G$ 的边。因此，问题简化为在给定的 DAG $G$ 中添加最少数量的边，使其成为强连通图。\n\n要使一个具有多个顶点的 DAG 变得强连通，每个顶点必须至少有一条入边和一条出边。设 $S$ 为“源”顶点（入度为 0 的顶点）的数量，设 $T$ 为“汇”顶点（出度为 0 的顶点）的数量。要消除所有源顶点，我们必须至少添加 $S$ 条边，每条边指向一个源顶点。要消除所有汇顶点，我们必须至少添加 $T$ 条边，每条边从一个汇顶点发出。\n\n图论中一个众所周知的结果指出，如果凝聚图不是平凡的（即，有一个以上的顶点），使图强连通所需的最少边数为 $\\max(S, T)$。我们可以通过添加边将汇点“链接”到源点来实现这一点。例如，如果我们有汇点 $\\{t_1, \\dots, t_T\\}$ 和源点 $\\{s_1, \\dots, s_S\\}$，我们可以形成一个包含这些极端分量的环。一个最优构造所需的边数恰好是 $\\max(S, T)$。由于我们的图 $G$ 有 $|V| = 14$ 个顶点，这些顶点作为 SCCs，并且 $14 > 1$，所以这个结果是适用的。\n\n我们现在必须为给定的图 $G$ 计算 $S$ 和 $T$。我们将计算 $V = \\{1, 2, \\dots, 14\\}$ 中每个顶点的入度和出度。\n\n边集为 $E = \\{(1,3), (3,5), (5,7), (2,4), (4,6), (6,8), (6,7), (7,9), (9,12), (12,14), (9,13), (10,11)\\}$。\n\n入度如下：\n- $\\text{入度}(1) = 0$\n- $\\text{入度}(2) = 0$\n- $\\text{入度}(3) = 1$ (来自顶点 $1$)\n- $\\text{入度}(4) = 1$ (来自顶点 $2$)\n- $\\text{入度}(5) = 1$ (来自顶点 $3$)\n- $\\text{入度}(6) = 1$ (来自顶点 $4$)\n- $\\text{入度}(7) = 2$ (来自顶点 $5$ 和 $6$)\n- $\\text{入度}(8) = 1$ (来自顶点 $6$)\n- $\\text{入度}(9) = 1$ (来自顶点 $7$)\n- $\\text{入度}(10) = 0$\n- $\\text{入度}(11) = 1$ (来自顶点 $10$)\n- $\\text{入度}(12) = 1$ (来自顶点 $9$)\n- $\\text{入度}(13) = 1$ (来自顶点 $9$)\n- $\\text{入度}(14) = 1$ (来自顶点 $12$)\n\n源顶点（入度为 0）是 $\\{1, 2, 10\\}$。因此，源顶点的数量为 $S = 3$。\n\n出度如下：\n- $\\text{出度}(1) = 1$ (指向顶点 $3$)\n- $\\text{出度}(2) = 1$ (指向顶点 $4$)\n- $\\text{出度}(3) = 1$ (指向顶点 $5$)\n- $\\text{出度}(4) = 1$ (指向顶点 $6$)\n- $\\text{出度}(5) = 1$ (指向顶点 $7$)\n- $\\text{出度}(6) = 2$ (指向顶点 $7$ 和 $8$)\n- $\\text{出度}(7) = 1$ (指向顶点 $9$)\n- $\\text{出度}(8) = 0$\n- $\\text{出度}(9) = 2$ (指向顶点 $12$ 和 $13$)\n- $\\text{出度}(10) = 1$ (指向顶点 $11$)\n- $\\text{出度}(11) = 0$\n- $\\text{出度}(12) = 1$ (指向顶点 $14$)\n- $\\text{出度}(13) = 0$\n- $\\text{出度}(14) = 0$\n\n汇顶点（出度为 0）是 $\\{8, 11, 13, 14\\}$。因此，汇顶点的数量为 $T = 4$。\n\n必须添加的最少边数为 $\\max(S, T)$。\n代入计算出的值，我们得到：\n$$ \\text{最少边数} = \\max(3, 4) = 4 $$\n因此，至少需要添加 $4$ 条边才能使图 $G$ 强连通。",
            "answer": "$$\n\\boxed{4}\n$$"
        }
    ]
}