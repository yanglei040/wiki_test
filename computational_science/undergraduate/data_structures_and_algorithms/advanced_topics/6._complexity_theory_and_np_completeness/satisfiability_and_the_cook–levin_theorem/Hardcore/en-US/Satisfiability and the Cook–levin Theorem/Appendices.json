{
    "hands_on_practices": [
        {
            "introduction": "The Cook-Levin Theorem establishes SAT as a \"universal\" problem. A powerful way to appreciate this is to perform a reduction yourself, translating a seemingly different problem into the language of Boolean logic. This exercise guides you through the classic reduction from Graph 3-Coloring to SAT, demonstrating how to systematically encode graphical constraints into a CNF formula .",
            "id": "3268206",
            "problem": "Consider the Boolean Satisfiability Problem (SAT) and the Cook-Levin Theorem, which establishes that SAT is complete for nondeterministic polynomial time (**NP**-complete). A classical approach to demonstrate the hardness of combinatorial problems is to reduce them to SAT. The Graph 3-Coloring problem is defined as follows: given an undirected graph $G=(V,E)$, determine whether the vertices in $V$ can be colored using exactly $3$ colors so that no edge in $E$ has both endpoints of the same color. Using only fundamental definitions of SAT, Conjunctive Normal Form (CNF), and Graph 3-Coloring, perform the following reduction for the specific graph instance \n$$\nG=(V,E),\\quad V=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\},\\quad E=\\{(v_{1},v_{2}),(v_{2},v_{3}),(v_{3},v_{4}),(v_{4},v_{5}),(v_{5},v_{1}),(v_{2},v_{5})\\}.\n$$\nConstruct a CNF formula whose satisfying assignments correspond exactly to proper 3-colorings of $G$ by introducing Boolean variables $x_{i,c}$ for each vertex $v_{i}\\in V$ and each color $c\\in\\{1,2,3\\}$, and by encoding:\n- for each vertex, the constraint that it receives at least one color and at most one color, and\n- for each edge, the constraint that its endpoints do not share the same color.\n\nExplicitly enumerate all variables and all CNF clauses generated for each vertex and for each edge in this instance. Then, compute the total number of clauses in the resulting CNF formula. Express the final answer as an exact integer. No rounding is required.",
            "solution": "The problem is valid as it is a well-defined and standard exercise in computational complexity theory, specifically concerning the reduction of the Graph 3-Coloring problem to the Boolean Satisfiability Problem (SAT). All required information, including the specific graph instance and the rules for constructing the Conjunctive Normal Form (CNF) formula, are provided explicitly and are logically consistent.\n\nWe are tasked with constructing a CNF formula $\\Phi$ that is satisfiable if and only if the given graph $G=(V, E)$ is 3-colorable. The graph is defined with the vertex set $V=\\{v_{1},v_{2},v_{3},v_{4},v_{5}\\}$ and the edge set $E=\\{(v_{1},v_{2}),(v_{2},v_{3}),(v_{3},v_{4}),(v_{4},v_{5}),(v_{5},v_{1}),(v_{2},v_{5})\\}$. The number of vertices is $|V|=5$ and the number of edges is $|E|=6$. We will use a set of $3$ colors, which we can label as $\\{1, 2, 3\\}$.\n\nFirst, we define the Boolean variables. For each vertex $v_i \\in V$ and each color $c \\in \\{1, 2, 3\\}$, we introduce a variable $x_{i,c}$. The variable $x_{i,c}$ is assigned the value true if vertex $v_i$ is colored with color $c$, and false otherwise. Since there are $5$ vertices and $3$ colors, we have a total of $5 \\times 3 = 15$ variables:\n$x_{1,1}, x_{1,2}, x_{1,3}, x_{2,1}, x_{2,2}, x_{2,3}, x_{3,1}, x_{3,2}, x_{3,3}, x_{4,1}, x_{4,2}, x_{4,3}, x_{5,1}, x_{5,2}, x_{5,3}$.\n\nThe CNF formula $\\Phi$ is the conjunction of clauses that enforce the three types of constraints described in the problem statement.\n\nConstraint 1: Each vertex must be assigned at least one color.\nFor each vertex $v_i \\in V$, it must be colored with color $1$, or color $2$, or color $3$. This translates to a clause of the form $(x_{i,1} \\lor x_{i,2} \\lor x_{i,3})$. Since there are $|V|=5$ vertices, this constraint generates $5$ clauses:\n1. For $v_1$: $(x_{1,1} \\lor x_{1,2} \\lor x_{1,3})$\n2. For $v_2$: $(x_{2,1} \\lor x_{2,2} \\lor x_{2,3})$\n3. For $v_3$: $(x_{3,1} \\lor x_{3,2} \\lor x_{3,3})$\n4. For $v_4$: $(x_{4,1} \\lor x_{4,2} \\lor x_{4,3})$\n5. For $v_5$: $(x_{5,1} \\lor x_{5,2} \\lor x_{5,3})$\nThe total number of clauses for this constraint is $5$.\n\nConstraint 2: Each vertex must be assigned at most one color.\nFor each vertex $v_i \\in V$ and for each pair of distinct colors $c_1, c_2 \\in \\{1, 2, 3\\}$, vertex $v_i$ cannot be colored with both $c_1$ and $c_2$. This is enforced by the clause $(\\neg x_{i,c_1} \\lor \\neg x_{i,c_2})$. For each vertex, there are $\\binom{3}{2}=3$ pairs of colors: $(1,2)$, $(1,3)$, and $(2,3)$. Since there are $|V|=5$ vertices, this constraint generates $5 \\times 3 = 15$ clauses.\n1. For $v_1$: $(\\neg x_{1,1} \\lor \\neg x_{1,2})$, $(\\neg x_{1,1} \\lor \\neg x_{1,3})$, $(\\neg x_{1,2} \\lor \\neg x_{1,3})$\n2. For $v_2$: $(\\neg x_{2,1} \\lor \\neg x_{2,2})$, $(\\neg x_{2,1} \\lor \\neg x_{2,3})$, $(\\neg x_{2,2} \\lor \\neg x_{2,3})$\n3. For $v_3$: $(\\neg x_{3,1} \\lor \\neg x_{3,2})$, $(\\neg x_{3,1} \\lor \\neg x_{3,3})$, $(\\neg x_{3,2} \\lor \\neg x_{3,3})$\n4. For $v_4$: $(\\neg x_{4,1} \\lor \\neg x_{4,2})$, $(\\neg x_{4,1} \\lor \\neg x_{4,3})$, $(\\neg x_{4,2} \\lor \\neg x_{4,3})$\n5. For $v_5$: $(\\neg x_{5,1} \\lor \\neg x_{5,2})$, $(\\neg x_{5,1} \\lor \\neg x_{5,3})$, $(\\neg x_{5,2} \\lor \\neg x_{5,3})$\nThe total number of clauses for this constraint is $15$.\n\nConstraint 3: No two adjacent vertices share the same color.\nFor each edge $(v_i, v_j) \\in E$ and for each color $c \\in \\{1, 2, 3\\}$, it is not permissible for both $v_i$ and $v_j$ to be colored with $c$. This is captured by the clause $(\\neg x_{i,c} \\lor \\neg x_{j,c})$. The graph has $|E|=6$ edges. For each edge, we must enforce this constraint for all $3$ colors. Therefore, this constraint generates $6 \\times 3 = 18$ clauses.\nThe edges are $E=\\{(v_{1},v_{2}),(v_{2},v_{3}),(v_{3},v_{4}),(v_{4},v_{5}),(v_{5},v_{1}),(v_{2},v_{5})\\}$.\n1. For edge $(v_1, v_2)$: $(\\neg x_{1,1} \\lor \\neg x_{2,1})$, $(\\neg x_{1,2} \\lor \\neg x_{2,2})$, $(\\neg x_{1,3} \\lor \\neg x_{2,3})$\n2. For edge $(v_2, v_3)$: $(\\neg x_{2,1} \\lor \\neg x_{3,1})$, $(\\neg x_{2,2} \\lor \\neg x_{3,2})$, $(\\neg x_{2,3} \\lor \\neg x_{3,3})$\n3. For edge $(v_3, v_4)$: $(\\neg x_{3,1} \\lor \\neg x_{4,1})$, $(\\neg x_{3,2} \\lor \\neg x_{4,2})$, $(\\neg x_{3,3} \\lor \\neg x_{4,3})$\n4. For edge $(v_4, v_5)$: $(\\neg x_{4,1} \\lor \\neg x_{5,1})$, $(\\neg x_{4,2} \\lor \\neg x_{5,2})$, $(\\neg x_{4,3} \\lor \\neg x_{5,3})$\n5. For edge $(v_5, v_1)$: $(\\neg x_{5,1} \\lor \\neg x_{1,1})$, $(\\neg x_{5,2} \\lor \\neg x_{1,2})$, $(\\neg x_{5,3} \\lor \\neg x_{1,3})$\n6. For edge $(v_2, v_5)$: $(\\neg x_{2,1} \\lor \\neg x_{5,1})$, $(\\neg x_{2,2} \\lor \\neg x_{5,2})$, $(\\neg x_{2,3} \\lor \\neg x_{5,3})$\nThe total number of clauses for this constraint is $18$.\n\nFinally, to find the total number of clauses in the resulting CNF formula $\\Phi$, we sum the number of clauses generated by each of the three constraints:\nTotal clauses = (clauses for Constraint 1) + (clauses for Constraint 2) + (clauses for Constraint 3)\nTotal clauses = $5 + 15 + 18 = 38$.\nThus, the CNF formula equivalent to the 3-Coloring problem for the given graph instance consists of $38$ clauses.",
            "answer": "$$\\boxed{38}$$"
        },
        {
            "introduction": "While general SAT is NP-complete, many practical problems map to a special, efficiently solvable version called 2-SAT. This practice challenges you to model a real-world scenario of scheduling constraints as a 2-SAT instance and solve it using its unique properties . By working through this problem, you will learn to identify the structure of 2-SAT and apply the polynomial-time algorithm based on implication graphs to find a satisfying solution.",
            "id": "3268081",
            "problem": "A small workshop is being organized with five potential volunteers: Ada, Bo, Cy, Di, and Emi. For each person, define a Boolean variable $x_A, x_B, x_C, x_D, x_E$ where $x_P = 1$ means person $P$ attends and $x_P = 0$ means person $P$ does not attend. The organizer has gathered the following social dependency statements:\n- Ada and Bo will not both attend.\n- If Cy attends, then Ada attends.\n- Di will attend if and only if Bo attends.\n- Emi refuses to attend unless Cy attends.\n- At least one of Ada or Di attends.\n- Exactly one of Cy or Emi attends.\n- If Ada does not attend, then Bo must attend.\n- If Di attends, then Cy does not attend.\n\nYour tasks are:\n- Formalize these statements as a Two-Satisfiability (2-SAT) instance by translating each statement into clauses of Conjunctive Normal Form (CNF) with exactly two literals per clause. Use the logical connectives $\\lnot$, $\\lor$, and $\\land$.\n- Using the standard polynomial-time reasoning method for Two-Satisfiability (2-SAT) via the implication graph and Strongly Connected Components (SCC), determine whether the instance is satisfiable and deduce the satisfying assignment for $(x_A, x_B, x_C, x_D, x_E)$.\n- Encode the satisfying assignment as a binary number with bit order $[x_A, x_B, x_C, x_D, x_E]$, where $1$ denotes attendance and $0$ denotes absence. Interpret this $5$-bit binary string as a base-$2$ integer and report its value in base-$10$.\n\nBackground context: Boolean Satisfiability is the canonical **NP**-complete problem by the Cook-Levin Theorem, while Two-Satisfiability (2-SAT) is solvable in polynomial time using implication graphs.\n\nExpress the final result as a single integer. No rounding is required.",
            "solution": "The problem requires us to determine if a set of constraints on five volunteers can be satisfied, and if so, to find a valid assignment of attendance. This is an instance of the Two-Satisfiability (2-SAT) problem.\n\nFirst, we validate the problem. The givens are the five volunteers, their corresponding Boolean variables $x_A, x_B, x_C, x_D, x_E$, and eight dependency statements. The problem is well-posed, scientifically grounded within computer science and logic, and all statements are objective. The task is to formalize the problem as a 2-SAT instance, solve it, and report the result in a specified numerical format. The problem is valid.\n\nThe solution proceeds in three stages:\n1.  Formalize the English statements into a Conjunctive Normal Form (CNF) formula where each clause contains exactly two literals (a 2-CNF formula).\n2.  Construct the implication graph for the 2-CNF formula, find its Strongly Connected Components (SCCs), and determine a satisfying assignment.\n3.  Encode the assignment as a binary number and convert it to its decimal representation.\n\nLet $x_P = 1$ denote that person $P$ attends, and $x_P=0$ that they do not. A literal is a variable $x_P$ or its negation $\\lnot x_P$.\n\nStep 1: Formalization into 2-CNF Clauses\n\nWe translate each statement into one or more 2-CNF clauses, which are disjunctions of two literals. The entire formula is a conjunction of these clauses.\n\n1.  \"Ada and Bo will not both attend\": $\\lnot(x_A \\land x_B) \\equiv (\\lnot x_A \\lor \\lnot x_B)$.\n2.  \"If Cy attends, then Ada attends\": $x_C \\implies x_A \\equiv (\\lnot x_C \\lor x_A)$.\n3.  \"Di will attend if and only if Bo attends\": $x_D \\iff x_B \\equiv (x_D \\implies x_B) \\land (x_B \\implies x_D) \\equiv (\\lnot x_D \\lor x_B) \\land (\\lnot x_B \\lor x_D)$.\n4.  \"Emi refuses to attend unless Cy attends\" (If Emi attends, Cy attends): $x_E \\implies x_C \\equiv (\\lnot x_E \\lor x_C)$.\n5.  \"At least one of Ada or Di attends\": $(x_A \\lor x_D)$.\n6.  \"Exactly one of Cy or Emi attends\": $x_C \\oplus x_E \\equiv (x_C \\lor x_E) \\land (\\lnot x_C \\lor \\lnot x_E)$.\n7.  \"If Ada does not attend, then Bo must attend\": $\\lnot x_A \\implies x_B \\equiv (\\lnot(\\lnot x_A) \\lor x_B) \\equiv (x_A \\lor x_B)$.\n8.  \"If Di attends, then Cy does not attend\": $x_D \\implies \\lnot x_C \\equiv (\\lnot x_D \\lor \\lnot x_C)$.\n\nThe complete 2-CNF formula is the conjunction of all these clauses:\n$$\n(\\lnot x_A \\lor \\lnot x_B) \\land (\\lnot x_C \\lor x_A) \\land (\\lnot x_D \\lor x_B) \\land (\\lnot x_B \\lor x_D) \\land (\\lnot x_E \\lor x_C) \\land (x_A \\lor x_D) \\land (x_C \\lor x_E) \\land (\\lnot x_C \\lor \\lnot x_E) \\land (x_A \\lor x_B) \\land (\\lnot x_D \\lor \\lnot x_C)\n$$\n\nStep 2: Implication Graph and Satisfiability\n\nA 2-SAT instance is solvable if and only if no variable and its negation belong to the same Strongly Connected Component (SCC) of the implication graph. Each clause $(L_1 \\lor L_2)$ is equivalent to two implications: $(\\lnot L_1 \\implies L_2)$ and $(\\lnot L_2 \\implies L_1)$. These implications become directed edges in a graph whose vertices are the literals $\\{x_A, \\lnot x_A, \\dots, x_E, \\lnot x_E\\}$.\n\nThe edges are:\n- From $(\\lnot x_A \\lor \\lnot x_B)$: $x_A \\to \\lnot x_B$, $x_B \\to \\lnot x_A$.\n- From $(\\lnot x_C \\lor x_A)$: $x_C \\to x_A$, $\\lnot x_A \\to \\lnot x_C$.\n- From $(\\lnot x_D \\lor x_B)$: $x_D \\to x_B$, $\\lnot x_B \\to \\lnot x_D$.\n- From $(\\lnot x_B \\lor x_D)$: $x_B \\to x_D$, $\\lnot x_D \\to \\lnot x_B$.\n- From $(\\lnot x_E \\lor x_C)$: $x_E \\to x_C$, $\\lnot x_C \\to \\lnot x_E$.\n- From $(x_A \\lor x_D)$: $\\lnot x_A \\to x_D$, $\\lnot x_D \\to x_A$.\n- From $(x_C \\lor x_E)$: $\\lnot x_C \\to x_E$, $\\lnot x_E \\to x_C$.\n- From $(\\lnot x_C \\lor \\lnot x_E)$: $x_C \\to \\lnot x_E$, $x_E \\to \\lnot x_C$.\n- From $(x_A \\lor x_B)$: $\\lnot x_A \\to x_B$, $\\lnot x_B \\to x_A$.\n- From $(\\lnot x_D \\lor \\lnot x_C)$: $x_D \\to \\lnot x_C$, $x_C \\to \\lnot x_D$.\n\nCombining these edges, we find equivalences which define the SCCs:\n- $x_B \\iff x_D$ (from clauses $3$) leads to SCCs $\\{x_B, x_D\\}$ and $\\{\\lnot x_B, \\lnot x_D\\}$.\n- $x_A \\iff \\lnot x_B$ (from clauses $1$ and $7$) leads to SCCs $\\{x_A, \\lnot x_B\\}$ and $\\{\\lnot x_A, x_B\\}$.\n- $x_C \\iff \\lnot x_E$ (from clause $6$) leads to SCCs $\\{x_C, \\lnot x_E\\}$ and $\\{\\lnot x_C, x_E\\}$.\n\nCombining these equivalences reveals larger SCCs:\n- $x_A \\iff \\lnot x_B \\iff \\lnot x_D$. This gives $S_1 = \\{x_A, \\lnot x_B, \\lnot x_D\\}$.\n- The contrapositive gives $\\lnot x_A \\iff x_B \\iff x_D$. This gives $S_2 = \\{\\lnot x_A, x_B, x_D\\}$.\n- $x_C \\iff \\lnot x_E$. This gives $S_3 = \\{x_C, \\lnot x_E\\}$.\n- The contrapositive gives $\\lnot x_C \\iff x_E$. This gives $S_4 = \\{\\lnot x_C, x_E\\}$.\n\nSince no SCC contains both a literal and its negation (e.g., $x_A$ and $\\lnot x_A$), the formula is satisfiable.\n\nTo find a satisfying assignment, we analyze the implications between these SCCs, forming a condensation graph.\n- $x_D \\to \\lnot x_C$ (from clause $8$) implies an edge from $S_2$ to $S_4$.\n- $x_E \\to x_C$ (from clause $4$) implies an edge from $S_4$ to $S_3$.\n- $x_C \\to x_A$ (from clause $2$) implies an edge from $S_3$ to $S_1$.\n\nThe condensation graph has the structure $S_2 \\to S_4 \\to S_3 \\to S_1$. A topological sort of this graph is $(S_2, S_4, S_3, S_1)$. To find a satisfying assignment, we process the SCCs in the reverse topological order: $(S_1, S_3, S_4, S_2)$.\n\n1.  Process $S_1 = \\{x_A, \\lnot x_B, \\lnot x_D\\}$. The variables are not yet assigned. We assign `true` to these literals: $x_A=1$, $\\lnot x_B=1 \\implies x_B=0$, $\\lnot x_D=1 \\implies x_D=0$. This determines the assignment $(x_A, x_B, x_D) = (1, 0, 0)$.\n2.  Process $S_3 = \\{x_C, \\lnot x_E\\}$. The variables are not yet assigned. We assign `true` to these literals: $x_C=1$, $\\lnot x_E=1 \\implies x_E=0$. This determines the assignment $(x_C, x_E) = (1, 0)$.\n3.  Process $S_4$ and $S_2$. The variables in these SCCs have already been assigned by the previous steps.\n\nThe unique satisfying assignment found through this method is $(x_A, x_B, x_C, x_D, x_E) = (1, 0, 1, 0, 0)$.\nWe verify this solution:\n- $x_A=1, x_B=0$: Ada attends, Bo does not. Satisfies $1, 5, 7$.\n- $x_C=1, x_A=1$: Satisfies $2$.\n- $x_D=0, x_B=0$: Satisfies $3$.\n- $x_E=0, x_C=1$: Satisfies $4$.\n- $x_C=1, x_E=0$: Satisfies $6$.\n- $x_D=0, x_C=1 \\implies \\lnot x_C = 0$: Satisfies $8$.\nAll constraints are satisfied.\n\nStep 3: Encode the Result\n\nThe satisfying assignment $(x_A, x_B, x_C, x_D, x_E) = (1, 0, 1, 0, 0)$ is encoded as a binary number with bit order $[x_A, x_B, x_C, x_D, x_E]$. The binary string is $10100_2$.\nConverting this to a base-$10$ integer:\n$$\n10100_2 = 1 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 16 + 0 + 4 + 0 + 0 = 20\n$$\nThe value is $20$.",
            "answer": "$$\\boxed{20}$$"
        },
        {
            "introduction": "The proof of the Cook-Levin Theorem involves encoding the entire computation of a Turing machine into a massive Boolean formula. To understand this principle on a smaller scale, this exercise has you encode a basic arithmetic inequality, $x + y \\lt z$, into a CNF formula . You will follow the process from high-level arithmetic down to the level of individual logic gates and finally into a set of clauses, gaining insight into how complex operations are built from elementary Boolean logic.",
            "id": "3268195",
            "problem": "Consider the canonical reduction perspective underlying the Cook-Levin Theorem, where constraints on finite computations are encoded into Boolean formulas in Conjunctive Normal Form (CNF). Let $x,y,z$ be unsigned $2$-bit integers with bit-vectors $x = (x_{1}, x_{0})$, $y = (y_{1}, y_{0})$, and $z = (z_{1}, z_{0})$, where each bit is a Boolean variable. Define the arithmetic sum bits of $x+y$ via a ripple-carry adder constructed from Boolean gates as follows:\n- Least-significant position: $s_{0} = x_{0} \\oplus y_{0}$ and $c_{1} = x_{0} \\land y_{0}$.\n- Most-significant position: introduce an auxiliary $u = x_{1} \\oplus y_{1}$, then $s_{1} = u \\oplus c_{1}$, and define the carry-out $c_{2}$ using $d = x_{1} \\land y_{1}$, $w = c_{1} \\land u$, and $c_{2} = d \\lor w$.\n\nTo encode the strict inequality $x + y < z$ as a Boolean circuit, compare the $3$-bit sum $(c_{2}, s_{1}, s_{0})$ against the $2$-bit $z$ extended with a leading zero: $(0, z_{1}, z_{0})$. Use a lexicographic comparator constructed from Boolean gates:\n- Prefix-equality at the most significant position: $e_{2} = \\lnot c_{2}$.\n- First less-than detection at the next position: $l_{1} = (e_{2} \\land \\lnot s_{1}) \\land z_{1}$.\n- Propagate equality to the next position: $e_{1} = e_{2} \\land (s_{1} \\leftrightarrow z_{1})$, where $\\leftrightarrow$ denotes logical equivalence (exclusive-or complemented).\n- Final less-than detection at the least-significant position: $l_{0} = (e_{1} \\land \\lnot s_{0}) \\land z_{0}$.\n- Overall strict inequality output: $\\ell = l_{1} \\lor l_{0}$, and enforce the constraint by asserting $\\ell$ to be true.\n\nEncode the entire network into CNF using the Tseitin transformation: introduce a Boolean variable for the output of each gate, and assert gate semantics by equivalences to their inputs. Use the following minimal CNF templates for gate equivalences, each written as clauses over the gateâ€™s output and inputs:\n- Negation: $t \\leftrightarrow \\lnot a$ uses $2$ clauses.\n- Conjunction: $t \\leftrightarrow (a \\land b)$ uses $3$ clauses.\n- Disjunction: $t \\leftrightarrow (a \\lor b)$ uses $3$ clauses.\n- Exclusive-or: $t \\leftrightarrow (a \\oplus b)$ uses $4$ clauses (each clause of size $3$).\n\nFinally, add a unit clause asserting $\\ell$ is true. Using exactly the gate decomposition above and exactly these CNF templates, determine the total number of CNF clauses in the encoding of the constraint $x + y < z$. Provide the exact count as your final answer. No rounding is required.",
            "solution": "The user wants to find the total number of clauses in a Conjunctive Normal Form (CNF) formula that encodes the strict inequality $x + y < z$, where $x$, $y$, and $z$ are $2$-bit unsigned integers. The encoding process follows the Tseitin transformation applied to a specific Boolean circuit implementation of the inequality.\n\nFirst, I must validate the problem statement.\nThe problem provides a complete and self-contained description of the process.\n- **Givens**:\n    - Variables: $x, y, z$ as $2$-bit integers with bit-vectors $x = (x_{1}, x_{0})$, $y = (y_{1}, y_{0})$, and $z = (z_{1}, z_{0})$.\n    - Adder circuit definition:\n        - $s_{0} = x_{0} \\oplus y_{0}$\n        - $c_{1} = x_{0} \\land y_{0}$\n        - $u = x_{1} \\oplus y_{1}$\n        - $s_{1} = u \\oplus c_{1}$\n        - $d = x_{1} \\land y_{1}$\n        - $w = c_{1} \\land u$\n        - $c_{2} = d \\lor w$\n    - Comparator circuit definition for $(c_{2}, s_{1}, s_{0}) < (0, z_{1}, z_{0})$:\n        - $e_{2} = \\lnot c_{2}$\n        - $l_{1} = (e_{2} \\land \\lnot s_{1}) \\land z_{1}$\n        - $e_{1} = e_{2} \\land (s_{1} \\leftrightarrow z_{1})$\n        - $l_{0} = (e_{1} \\land \\lnot s_{0}) \\land z_{0}$\n        - $\\ell = l_{1} \\lor l_{0}$\n    - CNF encoding rules (Tseitin transformation):\n        - A new variable is introduced for each gate's output.\n        - Clause counts for gate equivalences:\n            - $t \\leftrightarrow \\lnot a$: $2$ clauses\n            - $t \\leftrightarrow (a \\land b)$: $3$ clauses\n            - $t \\leftrightarrow (a \\lor b)$: $3$ clauses\n            - $t \\leftrightarrow (a \\oplus b)$: $4$ clauses\n    - Final constraint: A unit clause asserting $\\ell$ is true.\n\n- **Validation**:\n    - The problem is scientifically grounded within theoretical computer science (computational complexity, logic).\n    - It is well-posed, providing a deterministic procedure with all necessary definitions and constraints, leading to a unique numerical answer.\n    - The problem is objective and uses precise, unambiguous language.\n    - No flaws are identified. The problem is valid.\n\nI will now proceed with the solution by systematically counting the clauses generated at each step of the encoding process. The total number of clauses is the sum of clauses from the adder circuit encoding, the comparator circuit encoding, and the final assertion.\n\n**1. Adder Circuit Encoding: $(c_{2}, s_{1}, s_{0}) = x + y$**\nThe adder circuit is constructed from a set of specified gates. For each gate, we introduce a new variable for its output and add clauses to enforce the gate's logical function, according to the provided templates.\n\n- Gate for $s_{0}$: $s_{0} = x_{0} \\oplus y_{0}$. This is one exclusive-or (XOR) gate.\n  Number of clauses for $s_{0} \\leftrightarrow (x_{0} \\oplus y_{0})$ is $4$.\n- Gate for $c_{1}$: $c_{1} = x_{0} \\land y_{0}$. This is one conjunction (AND) gate.\n  Number of clauses for $c_{1} \\leftrightarrow (x_{0} \\land y_{0})$ is $3$.\n- Gate for $u$: $u = x_{1} \\oplus y_{1}$. This is one XOR gate.\n  Number of clauses for $u \\leftrightarrow (x_{1} \\oplus y_{1})$ is $4$.\n- Gate for $s_{1}$: $s_{1} = u \\oplus c_{1}$. This is one XOR gate.\n  Number of clauses for $s_{1} \\leftrightarrow (u \\oplus c_{1})$ is $4$.\n- Gate for $d$: $d = x_{1} \\land y_{1}$. This is one AND gate.\n  Number of clauses for $d \\leftrightarrow (x_{1} \\land y_{1})$ is $3$.\n- Gate for $w$: $w = c_{1} \\land u$. This is one AND gate.\n  Number of clauses for $w \\leftrightarrow (c_{1} \\land u)$ is $3$.\n- Gate for $c_{2}$: $c_{2} = d \\lor w$. This is one disjunction (OR) gate.\n  Number of clauses for $c_{2} \\leftrightarrow (d \\lor w)$ is $3$.\n\nThe total number of clauses for the adder circuit is the sum of clauses for each gate:\nTotal clauses (Adder) = $4 + 3 + 4 + 4 + 3 + 3 + 3 = 24$.\n\n**2. Comparator Circuit Encoding: $(c_{2}, s_{1}, s_{0}) < (0, z_{1}, z_{0})$**\nThe comparator circuit is also defined by a set of logical expressions. We must decompose these expressions into primitive gates and apply the Tseitin transformation.\n\n- Gate for $e_{2}$: $e_{2} = \\lnot c_{2}$. This is one negation (NOT) gate.\n  Number of clauses for $e_{2} \\leftrightarrow \\lnot c_{2}$ is $2$.\n- Gates for $l_{1}$: The expression is $l_{1} = (e_{2} \\land \\lnot s_{1}) \\land z_{1}$. This requires decomposition into a sequence of primitive gates.\n  1. Let $t_{1} = \\lnot s_{1}$. This is one NOT gate, adding $2$ clauses.\n  2. Let $t_{2} = e_{2} \\land t_{1}$. This is one AND gate, adding $3$ clauses.\n  3. Let $l_{1} = t_{2} \\land z_{1}$. This is one AND gate, adding $3$ clauses.\n  Total clauses for $l_{1}$ are $2 + 3 + 3 = 8$.\n- Gates for $e_{1}$: The expression is $e_{1} = e_{2} \\land (s_{1} \\leftrightarrow z_{1})$. The problem defines $s_{1} \\leftrightarrow z_{1}$ as \"exclusive-or complemented,\" which is $\\lnot(s_{1} \\oplus z_{1})$.\n  1. Let $t_{3} = s_{1} \\oplus z_{1}$. This is one XOR gate, adding $4$ clauses.\n  2. Let $t_{4} = \\lnot t_{3}$. This represents the equivalence $(s_{1} \\leftrightarrow z_{1})$. It is one NOT gate, adding $2$ clauses.\n  3. Let $e_{1} = e_{2} \\land t_{4}$. This is one AND gate, adding $3$ clauses.\n  Total clauses for $e_{1}$ are $4 + 2 + 3 = 9$.\n- Gates for $l_{0}$: The expression is $l_{0} = (e_{1} \\land \\lnot s_{0}) \\land z_{0}$. Its structure is identical to that of $l_{1}$.\n  1. Let $t_{5} = \\lnot s_{0}$. This is one NOT gate, adding $2$ clauses.\n  2. Let $t_{6} = e_{1} \\land t_{5}$. This is one AND gate, adding $3$ clauses.\n  3. Let $l_{0} = t_{6} \\land z_{0}$. This is one AND gate, adding $3$ clauses.\n  Total clauses for $l_{0}$ are $2 + 3 + 3 = 8$.\n- Gate for $\\ell$: The final output is $\\ell = l_{1} \\lor l_{0}$. This is one OR gate.\n  Number of clauses for $\\ell \\leftrightarrow (l_{1} \\lor l_{0})$ is $3$.\n\nThe total number of clauses for the comparator circuit is the sum of clauses for each decomposed part:\nTotal clauses (Comparator) = $2 (\\text{for } e_{2}) + 8 (\\text{for } l_{1}) + 9 (\\text{for } e_{1}) + 8 (\\text{for } l_{0}) + 3 (\\text{for } \\ell) = 30$.\n\n**3. Final Assertion**\nThe problem requires enforcing the constraint $x + y < z$ by asserting the final output $\\ell$ to be true. This is done by adding a single unit clause $(\\ell)$.\nNumber of clauses for final assertion = $1$.\n\n**Total Clause Count**\nThe total number of clauses in the final CNF formula is the sum of the clauses from all parts.\nTotal Clauses = Total (Adder) + Total (Comparator) + Final Assertion\nTotal Clauses = $24 + 30 + 1 = 55$.",
            "answer": "$$\\boxed{55}$$"
        }
    ]
}