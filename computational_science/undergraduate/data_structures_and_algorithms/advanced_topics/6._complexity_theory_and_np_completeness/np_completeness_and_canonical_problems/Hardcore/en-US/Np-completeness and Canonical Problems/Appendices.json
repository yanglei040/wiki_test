{
    "hands_on_practices": [
        {
            "introduction": "Polynomial-time reductions are the backbone of NP-completeness theory, allowing us to establish the relative difficulty of problems. This exercise challenges you to play the role of a proof-checker, scrutinizing a hypothetical reduction from 2-SAT to CLIQUE . By identifying the specific input that breaks the reduction's logic, you'll gain a deeper appreciation for the strict \"if and only if\" condition that every valid reduction must satisfy.",
            "id": "3256316",
            "problem": "Consider the decision problem Two-Satisfiability in Conjunctive Normal Form (2-SAT in CNF): an instance is a Boolean formula $F$ that is a conjunction of clauses, each clause being a disjunction of exactly $2$ literals, where a literal is either a variable $x$ or its negation $\\lnot x$. Consider also the CLIQUE decision problem: given an undirected graph $G$ and an integer $k$, determine whether there exists a set of $k$ vertices that are pairwise adjacent (a $k$-clique). A polynomial-time many-one reduction from a decision problem $A$ to a decision problem $B$ is a function $R$ computable in time polynomial in the input size such that for every instance $I$ of $A$, $I$ is a yes-instance of $A$ if and only if $R(I)$ is a yes-instance of $B$.\n\nA hypothetical but incorrect reduction $R$ is proposed from $2$-SAT to CLIQUE as follows. Given a $2$-CNF formula $F$ with $m$ clauses $C_1, C_2, \\dots, C_m$, each clause $C_i$ containing exactly two literals $\\ell_{i,1}$ and $\\ell_{i,2}$, construct a graph $G$ and an integer $k$ by the following steps:\n- For each clause index $i \\in \\{1, \\dots, m\\}$, create two distinct vertices $v_{i,1}$ and $v_{i,2}$, one for each literal occurrence in clause $C_i$.\n- For every pair of distinct clause indices $i \\neq j$, add edges between every vertex of clause $C_i$ and every vertex of clause $C_j$ (that is, add the four edges $(v_{i,a}, v_{j,b})$ for all $a \\in \\{1,2\\}$ and $b \\in \\{1,2\\}$), regardless of whether the corresponding literals are complementary.\n- Set $k \\leftarrow m$.\n\nThe claim is that $F$ is satisfiable if and only if $(G,k)$ is a yes-instance of CLIQUE. Your task is to identify a specific input instance that demonstrates the flaw in this reduction: an input $F$ that is unsatisfiable but for which $R(F)$ nonetheless contains a clique of size $k$.\n\nConsider the following four candidate $2$-CNF formulas, each over variables as indicated:\n- $F_1 = (x \\lor y) \\land (\\lnot x \\lor y) \\land (\\lnot y \\lor z)$ over variables $x,y,z$.\n- $F_2 = (x \\lor y) \\land (\\lnot x \\lor y) \\land (x \\lor \\lnot y) \\land (\\lnot x \\lor \\lnot y)$ over variables $x,y$.\n- $F_3 = (x \\lor x) \\land (\\lnot x \\lor y)$ over variables $x,y$.\n- $F_4 = (x \\lor \\lnot x) \\land (y \\lor \\lnot y)$ over variables $x,y$.\n\nUsing only the foundational definitions given above and logical reasoning from first principles, determine the unique index $i \\in \\{1,2,3,4\\}$ such that $F_i$ is unsatisfiable while $R(F_i)$ produces a graph containing a clique of size $k$. Provide your answer as the single integer $i$. No rounding is required.",
            "solution": "The problem requires us to identify a counterexample to a proposed, but flawed, polynomial-time reduction $R$ from the $2$-Satisfiability problem ($2$-SAT) to the CLIQUE problem. A counterexample, in this context, is a specific $2$-CNF formula $F$ that is unsatisfiable, but for which the reduction $R$ produces a graph $G$ and an integer $k$ that constitute a 'yes-instance' of CLIQUE, meaning $G$ contains a clique of size $k$.\n\nFirst, we must analyze the structure of the graph $G$ and the integer $k$ produced by the hypothetical reduction $R$ for a given $2$-CNF formula $F$. Let the formula be $F = C_1 \\land C_2 \\land \\dots \\land C_m$, where each $C_i = (\\ell_{i,1} \\lor \\ell_{i,2})$ is a clause containing two literals.\n\nAccording to the definition of the reduction $R$:\n1.  The set of vertices $V$ in the graph $G$ is constructed by creating two distinct vertices, $v_{i,1}$ and $v_{i,2}$, for each clause $C_i$ (for $i \\in \\{1, \\dots, m\\}$). These vertices correspond to the two literal occurrences in $C_i$. The total number of vertices is $|V| = 2m$.\n2.  The set of edges $E$ is constructed by connecting vertices from different clauses. For any two distinct clause indices $i, j \\in \\{1, \\dots, m\\}$ with $i \\neq j$, an edge is added between every vertex associated with $C_i$ and every vertex associated with $C_j$. This means the four edges $(v_{i,1}, v_{j,1})$, $(v_{i,1}, v_{j,2})$, $(v_{i,2}, v_{j,1})$, and $(v_{i,2}, v_{j,2})$ are all included in $E$. Importantly, there are no edges between the two vertices $v_{i,1}$ and $v_{i,2}$ that originate from the same clause $C_i$.\n3.  The target clique size is set to $k = m$.\n\nThe graph $G$ is therefore a complete $m$-partite graph, where the vertex set $V$ is partitioned into $m$ disjoint sets $V_1, V_2, \\dots, V_m$, with each partition $V_i = \\{v_{i,1}, v_{i,2}\\}$ having size $2$. An edge exists between two vertices if and only if they belong to different partitions.\n\nThe question is whether this graph $G$ contains a clique of size $k=m$. A clique of size $m$ is a set of $m$ vertices, $S = \\{u_1, u_2, \\dots, u_m\\}$, such that every pair of distinct vertices in $S$ is connected by an edge. Let $u_a \\in V_{i_a}$ and $u_b \\in V_{i_b}$ be two vertices in $S$. For an edge to exist between them, they must belong to different partitions, i.e., $i_a \\neq i_b$. For $S$ to be a clique of size $m$, this condition must hold for all pairs of vertices in $S$. This implies that a clique of size $m$ must be formed by selecting exactly one vertex from each of the $m$ partitions.\n\nWe can always construct such a set. For example, consider the set $S = \\{v_{1,1}, v_{2,1}, \\dots, v_{m,1}\\}$. This set contains exactly $m$ vertices, one from each partition $V_i$. For any two distinct vertices $v_{i,1} \\in S$ and $v_{j,1} \\in S$ (where $i \\neq j$), they belong to different partitions ($V_i$ and $V_j$). By the construction rule of $G$, an edge $(v_{i,1}, v_{j,1})$ exists. Therefore, $S$ is a clique of size $m$.\n\nThis demonstrates that for any $2$-CNF formula $F$ with $m$ clauses, the reduction $R$ will always produce a graph $G$ that contains a clique of size $k=m$. Thus, $R(F)=(G,k)$ is always a 'yes-instance' of the CLIQUE problem.\n\nThe flaw in the reduction is that it violates the intended logic of a SAT-to-CLIQUE reduction. The claim is that $F$ is satisfiable if and only if $R(F)$ is a 'yes-instance' of CLIQUE. A counterexample would be an instance where this equivalence fails. Since we have shown $R(F)$ is always a 'yes-instance', the only way for the equivalence to fail is if there exists a formula $F$ that is unsatisfiable. Such a formula would be an unsatisfiable ('no') instance of $2$-SAT, but would map to a 'yes'-instance of CLIQUE.\n\nOur task is thus simplified to identifying which of the four given formulas, $F_1, F_2, F_3, F_4$, is unsatisfiable.\n\n1.  **Analysis of $F_1 = (x \\lor y) \\land (\\lnot x \\lor y) \\land (\\lnot y \\lor z)$:**\n    This formula has $m=3$ clauses. Let's test for satisfiability. The first two clauses, $(x \\lor y) \\land (\\lnot x \\lor y)$, can be simplified using the distributive law: $(x \\land \\lnot x) \\lor y \\equiv \\text{false} \\lor y \\equiv y$. Thus, for $F_1$ to be true, $y$ must be true. Let's set $y = \\text{true}$. The formula becomes $(x \\lor \\text{true}) \\land (\\lnot x \\lor \\text{true}) \\land (\\lnot \\text{true} \\lor z)$, which simplifies to $\\text{true} \\land \\text{true} \\land (\\text{false} \\lor z)$, which is equivalent to $z$. To satisfy this, we must set $z = \\text{true}$. The value of $x$ is irrelevant. The assignment $(x=\\text{true}, y=\\text{true}, z=\\text{true})$ satisfies $F_1$. Thus, $F_1$ is satisfiable.\n\n2.  **Analysis of $F_2 = (x \\lor y) \\land (\\lnot x \\lor y) \\land (x \\lor \\lnot y) \\land (\\lnot x \\lor \\lnot y)$:**\n    This formula has $m=4$ clauses. As shown for $F_1$, the conjunction of the first two clauses, $(x \\lor y) \\land (\\lnot x \\lor y)$, implies that $y$ must be true for the formula to be satisfied. The conjunction of the last two clauses, $(x \\lor \\lnot y) \\land (\\lnot x \\lor \\lnot y)$, can be similarly simplified: $(x \\land \\lnot x) \\lor \\lnot y \\equiv \\text{false} \\lor \\lnot y \\equiv \\lnot y$. This implies that $\\lnot y$ must be true, or equivalently, $y$ must be false. For the entire formula $F_2$ to be satisfied, $y$ must be simultaneously true and false. This is a contradiction. Therefore, no satisfying assignment exists for $F_2$, and the formula is unsatisfiable.\n\n3.  **Analysis of $F_3 = (x \\lor x) \\land (\\lnot x \\lor y)$:**\n    This formula has $m=2$ clauses. The first clause, $(x \\lor x)$, is logically equivalent to $x$. So the formula $F_3$ is equivalent to $x \\land (\\lnot x \\lor y)$. For this to be true, $x$ must be true. Substituting $x=\\text{true}$ into the second part gives $\\lnot\\text{true} \\lor y$, which is $\\text{false} \\lor y$, equivalent to $y$. Thus, the entire formula is equivalent to $x \\land y$. This is satisfiable by the assignment $(x=\\text{true}, y=\\text{true})$. Therefore, $F_3$ is satisfiable.\n\n4.  **Analysis of $F_4 = (x \\lor \\lnot x) \\land (y \\lor \\lnot y)$:**\n    This formula has $m=2$ clauses. The first clause, $(x \\lor \\lnot x)$, is a tautology (always true). The second clause, $(y \\lor \\lnot y)$, is also a tautology. The conjunction of two tautologies is itself a tautology. Therefore, $F_4$ is true for any assignment of truth values to $x$ and $y$. It is satisfiable.\n\nOut of the four candidates, only $F_2$ is unsatisfiable. Since the reduction $R$ maps any formula to a 'yes-instance' of CLIQUE, $F_2$ is the unique formula among the choices that is unsatisfiable while $R(F_2)$ produces a graph with a clique of the required size. Thus, $F_2$ is the counterexample we seek, and its index is $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While the VERTEX-COVER problem is famously NP-complete on general graphs, its complexity can change dramatically when we restrict the input to specific graph classes. This practice guides you through one of the most classic examples of this phenomenon: solving VERTEX-COVER on trees . You will design a polynomial-time algorithm using dynamic programming, seeing firsthand how exploiting structural properties like optimal substructure can render an otherwise intractable problem efficiently solvable.",
            "id": "3256361",
            "problem": "Consider the canonical decision problem $\\text{VERTEX-COVER}$: given a graph $G = (V,E)$ and an integer $k$, decide whether there exists a subset $S \\subseteq V$ of size at most $k$ such that every edge in $E$ has at least one endpoint in $S$. In general graphs this problem is known to be NP-complete. However, when the input graph is a tree, the problem exhibits structure that enables a polynomial-time solution. Starting from first principles, namely the definitions of vertex cover, tree, and optimal substructure, derive a dynamic programming (DP) algorithm that, given a tree $T = (V,E)$ with $|V| = n$, computes the size of a minimum vertex cover in time polynomial in $n$. Specifically:\n\n1. Formalize the optimal substructure required to support dynamic programming on trees without relying on any pre-stated formulas.\n2. Prove correctness of your approach by arguing that all edges are covered and the solution is minimal via a local-to-global optimality argument over the tree structure.\n3. Analyze the time and space complexity of your algorithm as functions of $n$.\n\nThen apply your algorithm to the following tree instance $T$ with vertex set $V = \\{1,2,3,4,5,6,7,8,9,10,11,12,13,14\\}$ and edge set\n$$\nE = \\{(1,2),(1,3),(1,4),(2,5),(2,6),(3,7),(4,8),(4,9),(7,10),(7,11),(9,12),(10,13),(10,14)\\}.\n$$\nRoot the tree at vertex $1$ and compute the size of a minimum vertex cover for $T$. Express your final answer as a single integer (no units). No rounding is required.",
            "solution": "The problem asks for the derivation and application of a dynamic programming algorithm to find the size of a minimum vertex cover for a given tree. A vertex cover of a graph $G=(V,E)$ is a subset of vertices $S \\subseteq V$ such that for every edge $(u,v) \\in E$, at least one of $u$ or $v$ is in $S$. The minimum vertex cover is a vertex cover of the smallest possible size. The problem is known to be NP-complete for general graphs but is solvable in polynomial time for trees.\n\nWe will first formalize the dynamic programming approach, prove its correctness, analyze its complexity, and then apply it to the specific tree instance provided.\n\n### 1. Optimal Substructure and Dynamic Programming Formulation\n\nTo apply dynamic programming on a tree $T = (V,E)$, we first root it at an arbitrary vertex, which we denote as $r$. For the given instance, we are instructed to use vertex $1$ as the root. This imposes a parent-child structure on the tree. For any node $u \\in V$, let $T_u$ denote the subtree rooted at $u$, which includes $u$ and all its descendants.\n\nThe core idea of the dynamic programming approach is to compute the size of the minimum vertex cover for each subtree $T_u$ in a bottom-up fashion (i.e., via a post-order traversal). A simple state $DP(u)$ representing the size of the minimum vertex cover of $T_u$ is insufficient. The decision of whether to include $u$ in the cover for $T_u$ has implications for its parent, parent$(u)$. Specifically, if $u$ is not included in the cover, parent$(u)$ *must* be included to cover the edge (parent$(u)$, $u$). Therefore, our DP state must distinguish between these two cases.\n\nLet's define two values for each node $u \\in V$:\n- $DP_{in}(u)$: The size of a minimum vertex cover for the subtree $T_u$, with the constraint that the node $u$ *is included* in the vertex cover.\n- $DP_{out}(u)$: The size of a minimum vertex cover for the subtree $T_u$, with the constraint that the node $u$ *is not included* in the vertex cover.\n\nThe optimal substructure property holds: the optimal solution for the subtree $T_u$ can be constructed from the optimal solutions of the subtrees rooted at the children of $u$. Let $Children(u)$ be the set of children of node $u$.\n\nThe recurrence relations are derived as follows:\n\n**Case 1: $u$ is in the vertex cover ($DP_{in}(u)$).**\nIf we include $u$ in the cover, its own cost is $1$. By including $u$, all edges $(u,v)$ for $v \\in Children(u)$ are covered. For each child $v$, we are now free to either include $v$ in the cover for $T_v$ or not. To achieve a minimum size for the cover of $T_u$, we should choose the smaller of the two options for each child's subtree. Thus, for each $v \\in Children(u)$, we add $\\min(DP_{in}(v), DP_{out}(v))$ to the total.\n$$DP_{in}(u) = 1 + \\sum_{v \\in Children(u)} \\min(DP_{in}(v), DP_{out}(v))$$\n\n**Case 2: $u$ is not in the vertex cover ($DP_{out}(u)$).**\nIf we do not include $u$ in the cover, its own cost is $0$. However, to cover the edge $(u,v)$ for each child $v \\in Children(u)$, we are *forced* to include $v$ in the vertex cover for its subtree $T_v$. There is no other choice for covering these edges within the structure of $T_u$ (since $u$ is not in the cover and $v$ is the only other endpoint of the edge $(u,v)$). Therefore, for each child $v$, we must choose the solution where $v$ is included.\n$$DP_{out}(u) = \\sum_{v \\in Children(u)} DP_{in}(v)$$\n\n**Base Cases:**\nThe recursion terminates at the leaves of the tree. For any leaf node $l$, $Children(l) = \\emptyset$.\n- $DP_{in}(l) = 1$: The cover for the subtree $T_l$ (which is just the node $l$) is $\\{l\\}$, of size $1$.\n- $DP_{out}(l) = 0$: The cover for the subtree $T_l$ is $\\emptyset$, of size $0$. Since there are no edges within $T_l$, an empty set is a valid cover.\n\nFinally, after computing these values for all nodes up to the root $r$, the size of the minimum vertex cover for the entire tree $T$ is the minimum of the two possibilities for the root node: $\\min(DP_{in}(r), DP_{out}(r))$.\n\n### 2. Proof of Correctness\n\nWe prove correctness by induction on the structure of the tree, arguing that our algorithm finds a valid and minimal vertex cover for every subtree $T_u$.\n\n**Validity (All Edges Covered):**\n- **Base Case:** For a leaf $l$, the subtree $T_l$ has no edges, so the property holds trivially.\n- **Inductive Hypothesis (I.H.):** Assume for all children $v$ of a node $u$, the values $DP_{in}(v)$ and $DP_{out}(v)$ correspond to valid vertex covers for their respective subtrees $T_v$.\n- **Inductive Step:** Consider the subtree $T_u$. Its edges consist of the set $\\{(u,v) \\mid v \\in Children(u)\\}$ plus all edges within each subtree $T_v$.\n  - If we compute $DP_{in}(u)$, we include $u$ in the cover. This covers all edges $(u,v)$. By the I.H., the sub-solutions chosen for each $T_v$ cover all edges within those subtrees. Thus, all edges in $T_u$ are covered.\n  - If we compute $DP_{out}(u)$, we do not include $u$. The recurrence forces us to choose the $DP_{in}(v)$ solution for each child $v$. This means every $v \\in Children(u)$ is included in the cover, thereby covering all edges $(u,v)$. By the I.H., the $DP_{in}(v)$ solution also covers all edges within $T_v$. Thus, all edges in $T_u$ are covered.\nIn both cases, we produce a valid vertex cover for $T_u$.\n\n**Minimality (Optimality):**\n- **Base Case:** For a leaf $l$, $DP_{in}(l)=1$ and $DP_{out}(l)=0$ are clearly optimal for the respective constraints.\n- **I.H.:** Assume for all children $v$ of a node $u$, $DP_{in}(v)$ and $DP_{out}(v)$ are the sizes of the *minimum* vertex covers for $T_v$ subject to their constraints.\n- **Inductive Step:** Consider an optimal vertex cover $S^*$ for $T_u$.\n  - If $u \\in S^*$, then $S^* \\setminus \\{u\\}$ must cover all edges within the subtrees $T_v$. To do this optimally, for each $T_v$, the part of $S^*$ in $T_v$ must be a minimum vertex cover of $T_v$. The size would be $\\min(|S^*_{v,in}|, |S^*_{v,out}|)$, which by the I.H. is $\\min(DP_{in}(v), DP_{out}(v))$. Summing over all children and adding $1$ for $u$ shows that $|S^*| = DP_{in}(u)$.\n  - If $u \\notin S^*$, then to cover edges $(u,v)$, every child $v$ must be in $S^*$. The remainder of $S^*$ must then be an optimal cover for each $T_v$ given that $v$ is included. By the I.H., the size for each $T_v$ is $DP_{in}(v)$. Summing over all children shows that $|S^*| = DP_{out}(u)$.\nSince any optimal solution for $T_u$ must fall into one of these two categories, the minimum of $DP_{in}(u)$ and $DP_{out}(u)$ gives the size of the minimum vertex cover for $T_u$. This local optimality propagates to the root, ensuring a globally optimal solution.\n\n### 3. Complexity Analysis\n\n- **Time Complexity:** The algorithm computes two values, $DP_{in}(u)$ and $DP_{out}(u)$, for each node $u \\in V$. The computation for node $u$ requires summing over its children. A post-order traversal (e.g., using Depth First Search) ensures that when we compute the values for $u$, the values for all its children are already available. The total computation time is the sum of the work done at each node. The work at node $u$ is proportional to its number of children, $|Children(u)|$.\nThe total time is therefore proportional to $\\sum_{u \\in V} |Children(u)|$. In a tree with $n$ vertices, the sum of the number of children over all nodes is the total number of edges, which is $|E| = n-1$. Thus, the time complexity is $O(n-1) = O(n)$.\n- **Space Complexity:** We need to store the two DP values for each of the $n$ vertices. This requires $O(n)$ space. Additionally, if the algorithm is implemented recursively, the call stack can have a depth of at most $n$ (in the case of a path graph), also contributing $O(n)$ space. Therefore, the total space complexity is $O(n)$.\n\n### 4. Application to the Given Instance\n\nThe tree is $T=(V,E)$ with $V=\\{1, \\dots, 14\\}$ and $E = \\{(1,2),(1,3),(1,4),(2,5),(2,6),(3,7),(4,8),(4,9),(7,10),(7,11),(9,12),(10,13),(10,14)\\}$. We root the tree at vertex $1$. The parent-child relationships are:\n- $Children(1) = \\{2,3,4\\}$\n- $Children(2) = \\{5,6\\}$\n- $Children(3) = \\{7\\}$\n- $Children(4) = \\{8,9\\}$\n- $Children(7) = \\{10,11\\}$\n- $Children(9) = \\{12\\}$\n- $Children(10) = \\{13,14\\}$\n- Vertices $\\{5,6,8,11,12,13,14\\}$ are leaves.\n\nWe compute the DP values in a post-order traversal (bottom-up). For any node $u$, we denote its DP values as a pair $(DP_{in}(u), DP_{out}(u))$.\n\n**Leaves:** For any leaf $l \\in \\{5,6,8,11,12,13,14\\}$:\n- $(DP_{in}(l), DP_{out}(l)) = (1, 0)$\n\n**Node 2:** $Children(2)=\\{5,6\\}$\n- $DP_{in}(2) = 1 + \\min(DP_{in}(5), DP_{out}(5)) + \\min(DP_{in}(6), DP_{out}(6)) = 1 + \\min(1,0) + \\min(1,0) = 1+0+0 = 1$\n- $DP_{out}(2) = DP_{in}(5) + DP_{in}(6) = 1+1 = 2$\n- For node $2$: $(1, 2)$\n\n**Node 10:** $Children(10)=\\{13,14\\}$\n- $DP_{in}(10) = 1 + \\min(1,0) + \\min(1,0) = 1$\n- $DP_{out}(10) = 1+1 = 2$\n- For node $10$: $(1, 2)$\n\n**Node 7:** $Children(7)=\\{10,11\\}$\n- $DP_{in}(7) = 1 + \\min(DP_{in}(10), DP_{out}(10)) + \\min(DP_{in}(11), DP_{out}(11)) = 1 + \\min(1,2) + \\min(1,0) = 1+1+0 = 2$\n- $DP_{out}(7) = DP_{in}(10) + DP_{in}(11) = 1+1 = 2$\n- For node $7$: $(2, 2)$\n\n**Node 3:** $Children(3)=\\{7\\}$\n- $DP_{in}(3) = 1 + \\min(DP_{in}(7), DP_{out}(7)) = 1 + \\min(2,2) = 1+2 = 3$\n- $DP_{out}(3) = DP_{in}(7) = 2$\n- For node $3$: $(3, 2)$\n\n**Node 9:** $Children(9)=\\{12\\}$\n- $DP_{in}(9) = 1 + \\min(DP_{in}(12), DP_{out}(12)) = 1 + \\min(1,0) = 1$\n- $DP_{out}(9) = DP_{in}(12) = 1$\n- For node $9$: $(1, 1)$\n\n**Node 4:** $Children(4)=\\{8,9\\}$\n- $DP_{in}(4) = 1 + \\min(DP_{in}(8), DP_{out}(8)) + \\min(DP_{in}(9), DP_{out}(9)) = 1 + \\min(1,0) + \\min(1,1) = 1+0+1 = 2$\n- $DP_{out}(4) = DP_{in}(8) + DP_{in}(9) = 1+1 = 2$\n- For node $4$: $(2, 2)$\n\n**Root Node 1:** $Children(1)=\\{2,3,4\\}$\n- $DP_{in}(1) = 1 + \\min(DP_{in}(2), DP_{out}(2)) + \\min(DP_{in}(3), DP_{out}(3)) + \\min(DP_{in}(4), DP_{out}(4))$\n  $DP_{in}(1) = 1 + \\min(1,2) + \\min(3,2) + \\min(2,2) = 1 + 1 + 2 + 2 = 6$\n- $DP_{out}(1) = DP_{in}(2) + DP_{in}(3) + DP_{in}(4) = 1 + 3 + 2 = 6$\n- For node $1$: $(6, 6)$\n\nThe size of the minimum vertex cover for the entire tree $T$ is $\\min(DP_{in}(1), DP_{out}(1))$.\nSize = $\\min(6, 6) = 6$.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "A fundamental concept in complexity theory is the relationship between 'decision' problems (e.g., does a clique of size $k$ exist?) and 'search' problems (e.g., find a maximum clique). This exercise demonstrates that for NP-complete problems, the two are polynomially equivalent through a 'search-to-decision' reduction . Using a hypothetical oracle that solves the CLIQUE decision problem in constant time, you will build an algorithm that constructs an actual maximum clique, revealing that the core difficulty truly lies in the decision.",
            "id": "3256391",
            "problem": "You are given access to a hypothetical decision oracle for the canonical Non-deterministic Polynomial-time (NP) problem CLIQUE. The input to the oracle is an undirected graph $G=(V,E)$ and an integer $k \\in \\mathbb{Z}_{\\ge 0}$, and the oracle returns whether there exists a subset $C \\subseteq V$ of size at least $k$ such that every distinct pair of vertices in $C$ is connected by an edge in $E$ (that is, $C$ is a clique of size at least $k$). Assume the oracle answers each query in $O(1)$ time.\n\nStarting only from the core definitions of graphs, cliques, decision versus search versions of problems, and the notion of a polynomial-time Turing reduction, derive from first principles a polynomial-time algorithm that, using the oracle as a subroutine, finds an actual maximum clique in a given graph. Justify correctness by explaining why your procedure always returns a clique of the largest possible size and why the number of oracle queries and all other computations are bounded by a polynomial in $|V|$. You must also fix a deterministic tie-breaking rule: among all maximum cliques, your algorithm must return the lexicographically smallest one when vertices are labeled by integers in ascending order. Here, lexicographic order on a clique $C=\\{v_1,\\dots,v_t\\}$ with $v_1<\\dots<v_t$ means that for two cliques $C$ and $C'$ with sorted sequences $(v_1,\\dots,v_t)$ and $(v'_1,\\dots,v'_t)$, we have $C \\prec C'$ if and only if there exists an index $i$ such that $v_j=v'_j$ for all $j<i$ and $v_i < v'_i$.\n\nImplement your derived algorithm as a complete program that hardcodes the following test suite of graphs. For each graph $G$, compute and output the lexicographically smallest maximum clique as a list of vertex indices in nondecreasing order. Vertices are labeled by consecutive integers starting at $0$. All graphs are simple, undirected, and without self-loops.\n\nTest suite (five graphs):\n- Graph $G_1$: $V=\\{0,1,2,3,4,5\\}$ and\n  $E=\\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4),(0,1),(0,2),(4,5)\\}$.\n- Graph $G_2$: $V=\\{0,1,2,3,4\\}$ and $E=\\{(u,v) \\mid u,v \\in V, u<v\\}$ (that is, the complete graph on $5$ vertices).\n- Graph $G_3$: $V=\\{0,1,2,3\\}$ and $E=\\emptyset$.\n- Graph $G_4$: $V=\\{0,1,2,3,4,5\\}$ and $E=\\{(0,1),(1,2),(0,2),(2,3),(3,4),(2,4)\\}$.\n- Graph $G_5$: $V=\\{0,1,2,3,4,5,6\\}$ and \n  $E=\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(4,5),(5,6),(4,6)\\}$.\n\nYour algorithm must be based solely on calls to the decision oracle and polynomial-time computations around it, using only the foundational facts that define cliques and decision problems. Do not assume any additional structure beyond what is stated. Your program must emulate the oracle internally in any correct manner, but the overall control flow must reflect a polynomial number of oracle calls relative to $|V|$, as justified by your derivation.\n\nAnswer format:\n- For each graph $G_i$, output the lexicographically smallest maximum clique as a list of integers. Aggregate the five answers in order $G_1$ through $G_5$ into a single list.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list, for example: $[[a_1,\\dots],[a_2,\\dots],\\dots]$.\n\nThere are no physical units, angles, or percentages in this problem; all outputs are lists of integers. The outputs must be fully determined by the specified test suite and the lexicographic tie-breaking rule.",
            "solution": "The problem requires the derivation and implementation of a polynomial-time algorithm to find the lexicographically smallest maximum clique in a graph $G=(V, E)$, given access to a decision oracle for the CLIQUE problem. The oracle, hereafter denoted `CLIQUE_ORACLE(G', k)`, returns `True` if graph $G'$ contains a clique of size at least $k$, and `False` otherwise, in $O(1)$ time. The derivation must be from first principles.\n\nLet $|V|=n$. The problem can be divided into two main parts:\n1.  Finding the size of the maximum clique.\n2.  Constructing the specific vertices of the lexicographically smallest maximum clique.\n\nThis is a classic example of a search-to-decision reduction, a fundamental concept in computational complexity theory demonstrating that if a decision problem can be solved efficiently, so can its corresponding search problem.\n\n### Part 1: Determining the Maximum Clique Size\n\nThe size of a maximum clique in $G$, let's call it $k_{max}$, must be an integer in the range $[0, n]$. We can determine $k_{max}$ by making a series of calls to the `CLIQUE_ORACLE`.\n\nA property of cliques is that if a graph has a clique of size $k$, it also has a clique of every size smaller than $k$. This means the function $f(k) = \\text{CLIQUE\\_ORACLE}(G, k)$ is monotonic: for $k \\in \\{0, 1, \\dots, n\\}$, the sequence of outputs $f(0), f(1), \\dots, f(n)$ will be of the form $(\\text{True}, \\dots, \\text{True}, \\text{False}, \\dots, \\text{False})$. We are interested in the largest $k$ for which $f(k)$ is `True`.\n\nThis value can be found efficiently using binary search over the range of possible sizes, $[0, n]$.\nLet the search range be `[low, high]`, initialized to $[0, n]$. In each step, we query the oracle with the midpoint `mid = (low + high) // 2`.\n- If `CLIQUE_ORACLE(G, mid)` returns `True`, we know a clique of size `mid` exists, so the maximum size is at least `mid`. We record `mid` as a potential answer and search for a larger size by setting `low = mid + 1`.\n- If `CLIQUE_ORACLE(G, mid)` returns `False`, no clique of size `mid` exists, so the maximum size must be smaller. We set `high = mid - 1`.\n\nThe binary search terminates when `low > high`, and the last `mid` for which the oracle returned `True` is the maximum clique size, $k_{max}$. This procedure involves $O(\\log n)$ calls to the oracle. Since each oracle call is $O(1)$, this part of the algorithm runs in $O(\\log n)$ time.\n\n### Part 2: Constructing the Lexicographically Smallest Maximum Clique\n\nOnce $k_{max}$ is known, we can construct the clique itself. The problem requires the lexicographically smallest maximum clique, where vertices are labeled by integers $0, 1, \\dots, n-1$. This tie-breaking rule implies a greedy approach. We should try to include vertices with the smallest indices first.\n\nWe will build the clique, let's call it $C$, one vertex at a time. We iterate through all vertices $v \\in V$ in increasing order of their indices, from $0$ to $n-1$. At each step, we decide whether to add vertex $v$ to our clique $C$.\n\nThe greedy choice is as follows: A vertex $v$ is added to $C$ if and only if there exists a maximum clique of size $k_{max}$ that is a superset of $C \\cup \\{v\\}$. This check can be performed using the oracle.\n\nLet's formalize the algorithm for construction:\n1.  Initialize an empty set for the clique, $C = \\emptyset$.\n2.  Let the vertices of $G$ be $v_0, v_1, \\dots, v_{n-1}$ in increasing order of their integer labels.\n3.  For each vertex $v_i$ from $i=0$ to $n-1$:\n    a. Form a potential clique prefix $C_{potential} = C \\cup \\{v_i\\}$.\n    b. A necessary condition for $C_{potential}$ to be part of a larger clique is that $C_{potential}$ must itself be a clique. This means $v_i$ must be adjacent to every vertex already in $C$. If not, we cannot add $v_i$ and continue to the next vertex.\n    c. If $C_{potential}$ is a clique, we must check if it can be extended to a clique of size $k_{max}$. The remaining $k_{needed} = k_{max} - |C_{potential}|$ vertices must be chosen from the set of vertices that are adjacent to *all* vertices in $C_{potential}$. Let this set of candidate vertices be $U = \\{u \\in V \\mid \\forall w \\in C_{potential}, (u, w) \\in E \\}$.\n    d. Let $G_U$ be the subgraph of $G$ induced by the vertex set $U$. The problem reduces to asking if there exists a clique of size $k_{needed}$ within the graph $G_U$. This is precisely what the oracle can answer.\n    e. We call `CLIQUE_ORACLE(G_U, k_needed)`.\n    f. If the oracle returns `True`, it confirms that a maximum clique containing $C_{potential}$ exists. Since we are iterating through vertices in increasing order, adding $v_i$ is the correct greedy choice to maintain the lexicographically smallest property. We permanently add $v_i$ to our solution: $C \\leftarrow C \\cup \\{v_i\\}$.\n    g. If the oracle returns `False`, no maximum clique contains the prefix $C_{potential}$. We do not add $v_i$ to $C$ and proceed to the next vertex.\n4.  Once $|C| = k_{max}$, the clique is complete, and we can terminate. The final set $C$ is the lexicographically smallest maximum clique.\n\n### Correctness and Complexity Analysis\n\n**Correctness:** Let $C^* = \\{c_1, c_2, \\dots, c_{k_{max}}\\}$ be the true lexicographically smallest maximum clique, with $c_1 < c_2 < \\dots < c_{k_{max}}$. The algorithm iterates through vertices $v_0, v_1, \\dots, v_{n-1}$. For any vertex $v_i < c_1$, the algorithm will test if adding it can lead to a $k_{max}$-clique. If it could, we would find a maximum clique lexicographically smaller than $C^*$, a contradiction. Thus, the test must fail for all $v_i < c_1$. When the algorithm reaches $v_{c_1}$, the test will pass because $C^*$ is a valid extension. The algorithm adds $c_1$ to its clique. This reasoning extends inductively: at each step, the algorithm makes the same choice as prescripted by $C^*$, ensuring the final constructed clique is indeed $C^*$.\n\n**Complexity:**\n- **Part 1 (Finding $k_{max}$):** $O(\\log n)$ oracle calls and negligible computation.\n- **Part 2 (Constructing $C$):**\n    - The main loop runs at most $n$ times.\n    - Inside the loop, for each vertex $v_i$:\n        - Compatibility check (step 3b): $O(|C|) = O(n)$.\n        - Identifying the candidate set $U$ (step 3c): For each of the $O(n)$ vertices in $V$, we check adjacency against $O(|C_{potential}|) = O(n)$ vertices. This takes $O(n^2)$ time.\n        - Constructing the subgraph $G_U$ (step 3d): This can take up to $O(n^2)$ time to build an adjacency matrix for a graph with $O(n)$ vertices.\n        - Oracle call (step 3e): $O(1)$.\n    - The total computational work is dominated by the construction of subgraphs inside the loop, leading to a complexity of $O(n \\cdot n^2) = O(n^3)$.\n    - The number of oracle calls in this part is at most $n$.\n\nThe total number of oracle calls is $O(n + \\log n) = O(n)$, and the total computational time is $O(n^3)$. Since both are bounded by a polynomial in $n=|V|$, the algorithm is a polynomial-time Turing reduction.\n\nThis completes the derivation from first principles. The algorithm correctly finds the required clique and respects the polynomial-time constraint relative to the oracle.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm to find the lexicographically smallest maximum clique\n    using a hypothetical decision oracle for the CLIQUE problem.\n    \"\"\"\n\n    # This nested function serves as the emulated oracle for the CLIQUE decision problem.\n    # Its internal implementation uses brute force, which is acceptable because the\n    # problem's focus is on the polynomial-time reduction algorithm that uses the oracle,\n    # not the oracle's own efficiency. A cache is used to memoize results for a given graph,\n    # significantly speeding up the emulation for repeated queries.\n    _oracle_cache = {}\n\n    def get_adj_hash(adj):\n        \"\"\"Returns a hashable representation of a numpy array.\"\"\"\n        return adj.tobytes()\n\n    def clique_oracle(adj, k):\n        \"\"\"\n        Decision oracle for CLIQUE. Returns True if graph `adj` has a clique of size >= `k`.\n        \"\"\"\n        n = adj.shape[0]\n        adj_hash = get_adj_hash(adj)\n\n        if (adj_hash, k) in _oracle_cache:\n            return _oracle_cache[(adj_hash, k)]\n        \n        # Base cases for oracle\n        if k is None or k  0: return True\n        if k == 0: return True\n        if n == 0 and k > 0: return False\n        if k == 1 and n > 0: return True\n        if k > n : return False\n        \n        # Check if the maximum clique size for this graph is already computed.\n        max_k_cache_key = (adj_hash, None)\n        if max_k_cache_key in _oracle_cache:\n            max_k_found = _oracle_cache[max_k_cache_key]\n            result = max_k_found >= k\n            _oracle_cache[(adj_hash, k)] = result\n            return result\n\n        # Brute-force check using itertools.combinations to find max clique size\n        nodes = list(range(n))\n        max_k = 0\n        if n > 0:\n            max_k = 1 # At least a 1-clique (single vertex) exists\n        for size in range(n, 1, -1):\n            found_clique_of_this_size = False\n            for combo in itertools.combinations(nodes, size):\n                is_a_clique = True\n                # Check all pairs in the combination\n                for i1_idx in range(len(combo)):\n                    for i2_idx in range(i1_idx + 1, len(combo)):\n                        u, v = combo[i1_idx], combo[i2_idx]\n                        if not adj[u, v]:\n                            is_a_clique = False\n                            break\n                    if not is_a_clique:\n                        break\n                if is_a_clique:\n                    max_k = size\n                    found_clique_of_this_size = True\n                    break\n            if found_clique_of_this_size:\n                break\n        \n        _oracle_cache[max_k_cache_key] = max_k\n        result = max_k >= k\n        _oracle_cache[(adj_hash, k)] = result\n        return result\n\n    # --- Test Suite Definition ---\n    \n    # G1: V={0..5}, E={(1,2),(1,3),(1,4),(2,3),(2,4),(3,4),(0,1),(0,2),(4,5)}\n    adj1 = np.zeros((6, 6), dtype=bool)\n    for u, v in [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4),(0,1),(0,2),(4,5)]:\n        adj1[u,v] = adj1[v,u] = True\n\n    # G2: K5 on V={0..4}\n    adj2 = np.ones((5, 5), dtype=bool)\n    np.fill_diagonal(adj2, False)\n\n    # G3: V={0..3}, E=empty\n    adj3 = np.zeros((4, 4), dtype=bool)\n\n    # G4: V={0..5}, E={(0,1),(1,2),(0,2),(2,3),(3,4),(2,4)}\n    adj4 = np.zeros((6, 6), dtype=bool)\n    for u, v in [(0,1),(1,2),(0,2),(2,3),(3,4),(2,4)]:\n        adj4[u,v] = adj4[v,u] = True\n\n    # G5: V={0..6}, E={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(4,5),(5,6),(4,6)}\n    adj5 = np.zeros((7, 7), dtype=bool)\n    for u, v in [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(1,4),(2,4),(3,4),(4,5),(5,6),(4,6)]:\n        adj5[u,v] = adj5[v,u] = True\n\n    test_cases = [adj1, adj2, adj3, adj4, adj5]\n    all_results = []\n    \n    for adj in test_cases:\n        _oracle_cache.clear() # Reset cache for each graph\n        n = adj.shape[0]\n\n        # Part 1: Find k_max using binary search on the oracle\n        k_max = 0\n        if n > 0:\n            low, high = 1, n\n            while low = high:\n                mid = (low + high) // 2\n                if mid == 0: # A 0-clique is trivial\n                    low = mid + 1\n                    continue\n                if clique_oracle(adj, mid):\n                    k_max = mid\n                    low = mid + 1\n                else:\n                    high = mid - 1\n\n        # Part 2: Construct the lexicographically smallest max clique\n        clique = []\n        for v_idx in range(n):\n            if len(clique) == k_max:\n                break\n                \n            # Check if current vertex is compatible with the clique being built\n            is_compatible = all(adj[v_idx, c_node] for c_node in clique)\n            if not is_compatible:\n                continue\n\n            # Check if this new potential clique can be extended to a k_max clique\n            potential_clique = clique + [v_idx]\n            k_needed = k_max - len(potential_clique)\n\n            test_result = False\n            if k_needed  0: continue # Should not happen\n            if k_needed == 0:\n                # We found a clique of the desired size\n                test_result = True\n            else:\n                # Find common neighbors of the potential clique among vertices > v_idx\n                common_neighbors = [u for u in range(v_idx + 1, n) if all(adj[u, pc_node] for pc_node in potential_clique)]\n                \n                # If we don't have enough candidates, it's impossible\n                if len(common_neighbors) >= k_needed:\n                    # Construct subgraph for oracle call\n                    sub_n = len(common_neighbors)\n                    sub_adj = np.zeros((sub_n, sub_n), dtype=bool)\n                    map_original_to_sub = {original_idx: sub_idx for sub_idx, original_idx in enumerate(common_neighbors)}\n                    \n                    for i in range(sub_n):\n                        for j in range(i + 1, sub_n):\n                            u1, u2 = common_neighbors[i], common_neighbors[j]\n                            if adj[u1, u2]:\n                                sub_adj[i, j] = sub_adj[j, i] = True\n                    # Ask the oracle if this subgraph can provide the remaining vertices\n                    test_result = clique_oracle(sub_adj, k_needed)\n            \n            if test_result:\n                clique.append(v_idx)\n        \n        all_results.append(clique)\n\n    # Format the final output as specified\n    string_results = [str(r).replace(\" \", \"\") for r in all_results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```"
        }
    ]
}