{
    "hands_on_practices": [
        {
            "introduction": "理论是骨架，实践是血肉。要真正掌握分治策略的精髓，最好的方法莫过于亲手实现它。我们从一个简化但极具启发性的一维问题开始。这个练习  要求我们将最近点对的查找过程，巧妙地融入到归并排序的递归结构中。通过这个练习，你将专注于分治算法的递归思想本身——如何分解问题，以及如何在递归的回溯过程中合并子问题的解，而暂时不必处理高维度下复杂的几何约束。",
            "id": "3252361",
            "problem": "给定一维实数线上的一个有限实值点列表。对于一个大小为 $n$ 的列表 $A$，两点 $x$ 和 $y$ 之间的距离定义为 $|x - y|$，当 $n \\ge 2$ 时，最近点对距离定义为 $d^{\\star} = \\min_{i \\ne j} |A_i - A_j|$。如果 $n  2$，最近点对距离定义为 $+\\infty$。设计并实现一个程序，使用归并排序的分治结构来计算最近点对距离，并达到 $\\mathcal{O}(n \\log n)$ 的时间复杂度。你不能调用任何内置的排序过程；相反，算法必须显式地执行一个基于归并的分治递归，该递归同时进行排序和计算最近点对距离。\n\n对于每个测试用例，你的程序必须返回一个非负实数（最近点对距离），或者在定义指定时返回 $+\\infty$。本问题不涉及任何物理单位。实数上的序关系必须被视为通常的全序关系。\n\n要求的测试套件：\n- 情况 1：输入 $[7,1,5,9,3,2]$。\n- 情况 2：输入 $[1,2,4,8,16]$。\n- 情况 3：输入 $[10,8,6,4,2,0]$。\n- 情况 4：输入 $[5,5,5,5]$。\n- 情况 5：输入 $[-10,-3,0,2,7]$。\n- 情况 6：输入 $[42]$。\n- 情况 7：输入 $[]$。\n- 情况 8：输入 $[-1000000,1000000,-999999]$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），结果的顺序与测试套件的顺序相同。每个结果必须是一个实数（将 $+\\infty$ 打印为浮点无穷大值）。",
            "solution": "该问题要求设计并实现一个算法，用于在一维点列表 $A$ 中找到最近点对的距离。两点 $x$ 和 $y$ 之间的距离定义为 $|x - y|$。对于一个大小为 $n$ 的列表，当 $n \\ge 2$ 时，最近点对距离 $d^{\\star}$ 定义为 $d^{\\star} = \\min_{i \\ne j} |A_i - A_j|$，当 $n  2$ 时，定义为 $d^{\\star} = +\\infty$。该算法必须遵循基于归并排序结构的分治策略，达到 $\\mathcal{O}(n \\log n)$ 的时间复杂度，并且实现时不得使用任何内置排序函数。\n\n问题陈述是有效的。这是一个定义明确的计算问题，基于标准的数学概念（实数、绝对距离、最小值）和算法理论（分治法、时间复杂度）。所有术语都是客观且精确定义的，约束条件是自洽的。\n\n解决这个问题的核心原则是将寻找最小距离的过程整合到归并排序算法的递归结构中。一种朴素的暴力方法会比较每一对点，导致 $\\mathcal{O}(n^2)$ 的时间复杂度，这太慢了。我们将要开发一种更高效的方法，它利用排序过程来减少所需的比较次数。\n\n对于一维情况，一个关键的数学洞见显著简化了问题：如果一个点列表是排序的，那么最近的点对必定在排序后的列表中是相邻的。这可以通过反证法证明。假设最近的点对 $(x, y)$（其中 $x  y$）在排序后的列表中不相邻。这意味着存在至少另一个点 $z$，使得 $x  z  y$。距离 $|z - x| = z - x$ 必然小于距离 $|y - x| = y - x$。这与 $(x, y)$ 是最近点对的假设相矛盾。因此，最近点对必须是相邻的。\n\n这一洞见提出了一个算法：首先在 $\\mathcal{O}(n \\log n)$ 时间内对列表 $A$ 进行排序，然后执行一次线性扫描（$\\mathcal{O}(n)$ 时间）来找到相邻元素之间的最小距离。然而，问题陈述要求一个集成的算法，其中递归过程**同时进行排序和计算**距离。我们可以设计一个递归函数，通过在每一步返回排序后的列表和在该列表中找到的最小距离来实现这一点。\n\n让我们定义一个递归函数 $\\text{RecursiveClosestPair}(A)$，它接受一个大小为 $n$ 的列表 $A$，并返回一个元组 $(A_{\\text{sorted}}, d)$，其中 $A_{\\text{sorted}}$ 是 $A$ 的排序版本，$d$ 是 $A$ 中元素间的最近点对距离。\n\n算法的结构遵循经典的分治范式：\n\n1.  **基本情况**：如果列表 $A$ 的元素少于2个（即 $n=0$ 或 $n=1$），则无法形成点对。根据问题定义，最近点对距离为 $+\\infty$。列表本身已经是有序的。因此，对于 $n \\le 1$，函数返回 $(A, +\\infty)$。\n\n2.  **分解**：如果 $n \\ge 2$，列表 $A$ 被划分为大小大致相等的两半，一个左子列表 $L$ 和一个右子列表 $R$。我们可以选择中点 $m = \\lfloor n/2 \\rfloor$，使得 $L = A[0..m-1]$ 且 $R = A[m..n-1]$。\n\n3.  **解决**：在两个子列表上递归调用该函数：\n    *   $(L_{\\text{sorted}}, d_L) = \\text{RecursiveClosestPair}(L)$\n    *   $(R_{\\text{sorted}}, d_R) = \\text{RecursiveClosestPair}(R)$\n    到这一步结束时，我们得到了两个已排序的子列表 $L_{\\text{sorted}}$ 和 $R_{\\text{sorted}}$，以及它们各自内部的最小距离 $d_L$ 和 $d_R$。\n\n4.  **合并**：此步骤整合子问题的结果，以解决列表 $A$ 的问题。\n    a.  首先，将两个已排序的子列表 $L_{\\text{sorted}}$ 和 $R_{\\text{sorted}}$ 合并成一个单一的排序列表 $A_{\\text{merged}}$。这是归并排序算法中的标准合并过程，耗时 $\\mathcal{O}(n)$。\n    b.  在此阶段，我们有了一个完整的、已排序的列表 $A_{\\text{merged}}$，它包含原始列表 $A$ 的所有元素。根据我们之前的证明， $A$ 中元素的整体最近点对距离必定是 $A_{\\text{merged}}$ 中相邻元素之间的最小距离。我们对 $A_{\\text{merged}}$ 进行一次线性扫描来找到这个最小相邻距离，称之为 $d_{\\text{adj}}$。这次扫描也耗时 $\\mathcal{O}(n)$。\n    c.  列表 $A$ 的真正最小距离必须是左子问题中找到的距离（$d_L$）、右子问题中找到的距离（$d_R$）以及通过检查新排序列表找到的最小距离（$d_{\\text{adj}}$）中的最小值。因此，当前递归层级的结果是 $d = \\min(d_L, d_R, d_{\\text{adj}})$。\n    d.  然后函数返回元组 $(A_{\\text{merged}}, d)$。\n\n初始列表 $A$ 的最终结果是由顶层调用 $\\text{RecursiveClosestPair}(A)$ 返回的元组中的距离部分。\n\n该算法的时间复杂度可以用递推关系 $T(n) = 2T(n/2) + \\mathcal{O}(n)$ 来描述。$2T(n/2)$ 项来自于对两个大小为 $n/2$ 的子问题的递归调用。$\\mathcal{O}(n)$ 项代表了在合并步骤中所做的工作，这部分工作主要由合并两个已排序子列表和随后的线性扫描主导，这两者都与列表大小 $n$ 呈线性关系。根据主定理(Master Theorem)，这个递推关系解为 $T(n) = \\mathcal{O}(n \\log n)$，满足了问题对复杂度的要求。\n\n这个设计正确地实现了一个基于归并的分治递归，它同时对数据进行排序并计算最近点对距离，从而满足了问题的所有约束条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef closest_pair_recursive(arr):\n    \"\"\"\n    Recursively sorts a list and finds the closest-pair distance within it.\n    This function explicitly follows the merge sort divide-and-conquer structure.\n\n    Args:\n        arr (list): A list of real numbers.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: The sorted version of the input list.\n            - float: The minimum distance between any two distinct points in the list.\n    \"\"\"\n    n = len(arr)\n\n    # Base case: If the list has fewer than 2 elements, the distance is defined as infinity.\n    # A list with 0 or 1 elements is trivially sorted.\n    if n = 1:\n        return arr, np.inf\n\n    # Divide: Split the list into two halves.\n    mid = n // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Conquer: Recursively process the left and right halves.\n    # This yields the sorted halves and the minimum distances within each half.\n    left_sorted, d_left = closest_pair_recursive(left_half)\n    right_sorted, d_right = closest_pair_recursive(right_half)\n\n    # Combine: Merge the sorted halves and find the overall minimum distance.\n    # 1. Merge the two sorted lists `left_sorted` and `right_sorted`.\n    merged_arr = []\n    i, j = 0, 0\n    while i  len(left_sorted) and j  len(right_sorted):\n        if left_sorted[i] = right_sorted[j]:\n            merged_arr.append(left_sorted[i])\n            i += 1\n        else:\n            merged_arr.append(right_sorted[j])\n            j += 1\n    \n    # Append any remaining elements from either list.\n    merged_arr.extend(left_sorted[i:])\n    merged_arr.extend(right_sorted[j:])\n\n    # 2. Scan the newly merged and sorted list to find the minimum adjacent distance.\n    # This check implicitly covers pairs where one point was in the original left\n    # half and the other was in the right half.\n    d_adj = np.inf\n    # The loop runs only if there are at least 2 elements to compare.\n    for k in range(len(merged_arr) - 1):\n        dist = merged_arr[k+1] - merged_arr[k]\n        if dist  d_adj:\n            d_adj = dist\n\n    # 3. The minimum distance for the current list is the minimum of the distances\n    # from the left subproblem, the right subproblem, and the adjacent scan.\n    min_dist = min(d_left, d_right, d_adj)\n\n    return merged_arr, min_dist\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [7, 1, 5, 9, 3, 2],\n        [1, 2, 4, 8, 16],\n        [10, 8, 6, 4, 2, 0],\n        [5, 5, 5, 5],\n        [-10, -3, 0, 2, 7],\n        [42],\n        [],\n        [-1000000, 1000000, -999999],\n    ]\n\n    results = []\n    for case in test_cases:\n        # For lists with fewer than 2 elements, the distance is defined as +inf.\n        # This handles the base case at the top level, consistent with the recursion.\n        if len(case)  2:\n            results.append(np.inf)\n        else:\n            # The recursive function returns both the sorted list and the min distance.\n            # We only need the distance for the final result.\n            _, distance = closest_pair_recursive(case)\n            results.append(float(distance))\n\n    # Final print statement in the exact required format.\n    # The representation of np.inf as a string 'inf' is standard.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在通过一维问题掌握了分治的基本框架后，我们现在将挑战升级到更真实、更复杂的三维空间 。这个问题将引导你直面经典最近点对算法的核心难点：高效的“合并”步骤。仅仅递归地解决左右两半是不够的，真正的挑战在于如何处理那些跨越分割线的点对。你需要在著名的“条带”（strip）区域内，设计一个线性的时间复杂度的方案来找到潜在的最近点对，从而确保整个算法达到 $\\mathcal{O}(n \\log n)$ 的效率。完成这个练习将让你深刻理解分治法在解决复杂几何问题上的强大威力。",
            "id": "3205365",
            "problem": "给定三维欧几里得空间中的一个有限点集。设 $P = \\{p_i\\}_{i=1}^n$，其中每个点 $p_i = (x_i,y_i,z_i) \\in \\mathbb{R}^3$。任务是设计并实现一个基于分治范式的算法，以计算任意两个不同点之间的最小欧几里得距离。该算法必须从适用于数据结构与算法领域中算法设计的基本定义和定律出发，包括欧几里得度量性质、递归、渐进复杂度以及问题分解。唯一允许的操作是那些可从这些基础推导出来的操作。该算法必须在科学上是合理的，并且完全基于这些基础进行论证，而不是通过捷径公式或临时提示。每个测试用例的输出应为一个数值，四舍五入到六位小数，不需要物理单位。\n\n基本依据：\n- 两点 $p=(x,y,z)$ 和 $q=(x',y',z')$ 之间的欧几里得距离定义为 $$d(p,q) = \\sqrt{(x-x')^2 + (y-y')^2 + (z-z')^2}.$$ 这源于 $\\mathbb{R}^3$ 上的内积诱导的范数以及勾股定理。\n- 分治范式将一个关于 $n$ 个元素的问题分解为大约 $n/2$ 个元素的子问题，递归地解决它们，然后在必须被证明为 $O(n)$ 的时间内合并它们的解，以达到 $O(n \\log n)$ 的目标复杂度。\n- 渐进复杂度采用标准的朗道符号（Landau notation）来衡量，其中 $O(\\cdot)$ 表示一个直到常数因子的上界。\n\n你的程序必须实现以下内容：\n- 输入是固定的并嵌入在程序中。程序必须使用分治算法为每个测试用例计算最小欧几里得距离 $d^*$，该算法需要：\n  1. 按点的 $x$ 坐标排序。\n  2. 递归地解决左半部分和右半部分的最近点对问题，以获得距离 $d_L$ 和 $d_R$。\n  3. 通过考虑位于以中位数 $x$ 平面为中心、宽度为 $2\\delta$ 的条带内的点来合并两个半区，其中 $\\delta = \\min(d_L,d_R)$，并且仅使用第一性原理的几何约束来限制候选点的比较。其正确性论证必须依赖于以下性质：如果 $d(p,q)  \\delta$，则 $|x-x'|  \\delta$、 $|y-y'|  \\delta$ 和 $|z-z'|  \\delta$，并且落入任何边长为 $\\delta$、点对间距至少为 $\\delta$ 的立方体内的点的数量受一个与维度相关的常数限制，从而确保在固定维度下合并步骤为线性时间。\n  4. 不使用任何绕过这些约束的启发式方法。\n\n需要明确处理的边界情况：\n- 如果两个点相同，最小距离为 $0$，四舍五入后记为 $0.000000$。\n- 如果 $n=2$，最小距离是这两点之间的距离。\n- 点的坐标可能为负数且数值较大；算法必须保持正确性和数值稳定性。\n\n测试套件：\n- 测试用例 1：$[(0,0,0),(10,10,10),(10,10,11),(20,25,30),(5,6,7),(100,-50,25),(-10,12,8)]$\n- 测试用例 2：$[(0,0,0),(1,1,1)]$\n- 测试用例 3：$[(5,-7,2),(5,-7,2),(0,0,0)]$\n- 测试用例 4：$[(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,0,0),(6,0,0),(7,0,0),(8,0,0),(9,0,0)]$\n- 测试用例 5：$[(0,1,1),(0,2,2),(0,3,3),(0,4,4),(0,4,5)]$\n- 测试用例 6：$[(-1000,500,-300),(-999,500,-300),(400,-800,1000),(401,-800,1000)]$\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含上述六个测试用例的结果，形式为方括号括起来的逗号分隔列表。每个结果必须是四舍五入到六位小数的浮点数（例如，$[1.000000,1.732051,0.000000,1.000000,1.000000,1.000000]$）。不应打印任何其他文本。",
            "solution": "该问题要求设计并实现一个分治算法，以找到三维点集 $P = \\{p_i\\}_{i=1}^n \\subset \\mathbb{R}^3$ 中任意两个不同点之间的最小欧几里得距离。解决方案必须从算法设计和复杂度理论的第一性原理推导出来。\n\n### 基于原理的设计\n\n寻找最近点对问题是计算几何中的一个经典问题。暴力方法会检查每对不同点之间的距离，涉及 $\\binom{n}{2} = \\frac{n(n-1)}{2}$ 次比较。这导致时间复杂度为 $O(n^2)$，对于大的 $n$ 来说效率低下。分治范式提供了一种更有效的方法。\n\n分治算法的核心原理是将一个问题分解为更小的、相似的子问题，递归地解决它们，然后合并它们的解来解决原始问题。对于最近点对问题，可以按以下方式构建：\n\n1.  **分解**：将点集 $P$ 划分为两个大小大致相等的子集 $P_L$ 和 $P_R$。\n2.  **解决**：递归地找到 $P_L$ 中的最小距离（设为 $\\delta_L$）和 $P_R$ 中的最小距离（设为 $\\delta_R$）。\n3.  **合并**：整个集合 $P$ 中的最小距离是 $\\delta_L$、$\\delta_R$ 以及一对点 $(p_L, p_R)$（其中 $p_L \\in P_L$ 且 $p_R \\in P_R$）之间最小距离的最小值。令 $\\delta = \\min(\\delta_L, \\delta_R)$。如果存在距离小于 $\\delta$ 的点对 $(p_L, p_R)$，则必须找到这对点。\n\n算法的复杂度分析取决于递推关系 $T(n) = 2T(n/2) + T_{\\text{combine}}(n)$。为达到 $O(n \\log n)$ 的目标复杂度，合并步骤 $T_{\\text{combine}}(n)$ 的复杂度必须为 $O(n)$。\n\n### 详细算法与论证\n\n**1. 预处理：**\n为了方便分解步骤，我们首先根据点的 $x$ 坐标对整个点集 $P$ 进行排序。这将创建一个已排序的列表 $P_x$。这个初始排序需要 $O(n \\log n)$ 的时间。\n\n**2. 递归结构：**\n递归函数（我们称之为 `find_closest(Px)`）作用于一个已经按 $x$ 坐标排序的点列表。\n\n*   **基本情况**：如果点的数量很少（例如 $n \\le 3$），则通过暴力方法计算最小距离。这需要常数时间 $O(1)$。对于 $n  2$ 的情况，距离未定义，我们可以用无穷大表示。\n\n*   **分解步骤**：我们将已排序的列表 $P_x$ 分为两半，$P_L = P_x[0 \\dots n/2-1]$ 和 $P_R = P_x[n/2 \\dots n-1]$。分割线是一个通过中位数 $x$ 坐标 $x_{med} = P_x[n/2].x$ 的垂直平面。由于数组切片，此步骤需要 $O(1)$ 的时间。\n\n*   **解决步骤**：我们进行两次递归调用：$\\delta_L = \\text{find\\_closest}(P_L)$ 和 $\\delta_R = \\text{find\\_closest}(P_R)$。\n\n*   **合并步骤**：这是算法最关键的部分。令 $\\delta = \\min(\\delta_L, \\delta_R)$。如果存在更近的点对，它必须由一个来自 $P_L$ 的点和一个来自 $P_R$ 的点组成。设这样的点对为 $(p_L, p_R)$，其中 $p_L \\in P_L$ 且 $p_R \\in P_R$。要使其距离 $d(p_L, p_R)$ 小于 $\\delta$，它们的坐标差也必须有界：$|x_L - x_R|  \\delta$、 $|y_L - y_R|  \\delta$ 和 $|z_L - z_R|  \\delta$。\n\n    这一观察使我们能够大幅减少搜索空间。我们只需要考虑位于以分割平面 $x = x_{med}$ 为中心、宽度为 $2\\delta$ 的垂直“条带”内的点。设 $S$ 为 $P$ 中 $x$ 坐标在范围 $[x_{med} - \\delta, x_{med} + \\delta]$ 内的点的集合。\n\n    $S$ 中所有点对的朴素比较在最坏情况下仍可能达到 $O(n^2)$。为了确保合并步骤为 $O(n)$，我们必须更有效地利用几何约束。我们可以采用一种基于网格的哈希技术。\n\n    1.  **网格构建**：我们在 $y-z$ 平面上定义一个单元格边长为 $\\delta$ 的二维网格。我们遍历条带 $S$ 中的点。对于每个点 $p=(x,y,z) \\in S$，我们将其映射到一个由 $(\\lfloor y/\\delta \\rfloor, \\lfloor z/\\delta \\rfloor)$ 索引的网格单元。我们使用哈希映射来存储落入每个单元格的点。\n    2.  **邻居搜索**：对于从条带中处理的每个点 $p$，我们只需要检查其周围一个小的有限区域内的邻居。一个点 $q$ 若满足 $d(p, q)  \\delta$，则必须有 $|p.y - q.y|  \\delta$ 和 $|p.z - q.z|  \\delta$。这意味着 $q$ 必须位于 $p$ 自己的网格单元或八个相邻单元之一（一个以 $p$ 所在单元为中心的 $3 \\times 3$ 单元块）。\n    3.  **复杂度论证**：问题陈述正确地指出，在任何边长为 $\\delta$ 的立方体内，两两间距至少为 $\\delta$ 的点的数量受一个常数限制。我们的单元格划分了一个 $2\\delta$ 宽的平板区域。单个单元格对应于一个体积为 $2\\delta \\times \\delta \\times \\delta$ 的空间。任何源自同一半区（$P_L$ 或 $P_R$）且位于此体积内的两点，其间距至少为 $\\delta$。一个堆积论证证明了任何单个单元格中的点的数量都受一个小的常数限制。因此，对于每个点 $p \\in S$，我们只需要检查它与常数个其他点之间的距离。\n    4.  **实现**：我们遍历条带中的点（这些点已按 $x$ 坐标排序）。对于每个点 $p$，我们在网格中检查相关的相邻单元格，寻找那些已经被处理并添加到网格中的点。然后，我们将 $p$ 添加到其对应的网格单元中。这确保了每对点实际上只被检查一次。\n\n这种基于网格处理条带的方法需要 $O(|S|) = O(n)$ 的时间。总的递推关系变为 $T(n) = 2T(n/2) + O(n)$，根据主定理（Master Theorem），其解为 $T(n) = O(n \\log n)$。包括初始排序在内的总时间复杂度为 $O(n \\log n)$。此算法在科学上是合理的，并满足问题的所有要求。如果在任何时候发现距离为 $0$（表示存在相同的点），算法可以立即终止并返回 $0$，因为不可能有更小的非负距离。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef distance(p1, p2):\n    \"\"\"Computes the Euclidean distance between two points in 3D space.\"\"\"\n    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)\n\ndef brute_force_closest_pair(points):\n    \"\"\"\n    Finds the minimum distance in a small set of points by brute force.\n    Assumes len(points) > 1.\n    \"\"\"\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            d = distance(points[i], points[j])\n            if d  min_dist:\n                min_dist = d\n    return min_dist\n\ndef closest_pair_recursive(Px):\n    \"\"\"\n    The recursive core of the divide-and-conquer algorithm.\n    Px is a list of points sorted by x-coordinate.\n    \"\"\"\n    n = len(Px)\n\n    # Base case: for a small number of points, use brute force.\n    if n = 3:\n        # If n  2, there are no pairs, so the distance is infinite.\n        if n  2:\n            return float('inf')\n        return brute_force_closest_pair(Px)\n\n    # Divide step: Split the points into two halves.\n    mid = n // 2\n    median_point = Px[mid]\n    \n    # Create left and right subsets of points sorted by x.\n    Px_left = Px[:mid]\n    Px_right = Px[mid:]\n\n    # Conquer step: Recursively find the closest pair in each half.\n    d_left = closest_pair_recursive(Px_left)\n    d_right = closest_pair_recursive(Px_right)\n\n    delta = min(d_left, d_right)\n\n    # Optimization: if a pair of identical points was found, the distance is 0.\n    # We can't find a smaller non-negative distance, so we can terminate early.\n    if delta == 0:\n        return 0.0\n\n    # Combine step: Check for a closer pair across the two halves.\n    # Such a pair must lie in a \"strip\" of width 2*delta around the median x-plane.\n    strip_points = [p for p in Px if abs(p[0] - median_point[0])  delta]\n    \n    # To achieve an O(n) combine step, we use a grid (hashing) method\n    # on the y-z plane to find candidate pairs in the strip efficiently.\n    grid = {}\n    cell_size = delta\n    min_dist_strip = delta\n\n    for p in strip_points:\n        # Determine the grid cell key for the point p based on its y and z coordinates.\n        key = (int(p[1] / cell_size), int(p[2] / cell_size))\n        \n        # Check neighboring cells for points closer than delta.\n        # We check a 3x3 block of cells in the y-z plane centered at the current point's cell.\n        for dy in range(-1, 2):\n            for dz in range(-1, 2):\n                check_key = (key[0] + dy, key[1] + dz)\n                if check_key in grid:\n                    for neighbor in grid[check_key]:\n                        d = distance(p, neighbor)\n                        if d  min_dist_strip:\n                            min_dist_strip = d\n        \n        # Add the current point to the grid for subsequent points to check against.\n        if key not in grid:\n            grid[key] = []\n        grid[key].append(p)\n        \n    return min_dist_strip\n\n\ndef solve_closest_pair(points):\n    \"\"\"\n    Main function to initiate the closest pair algorithm. It sorts the points\n    by the x-coordinate and calls the recursive helper function.\n    \"\"\"\n    # An initial sort by x-coordinate is required for the divide-and-conquer strategy.\n    # Sorting a list of tuples sorts them element by element, starting with the first (x).\n    sorted_points = sorted(list(points))\n\n    return closest_pair_recursive(sorted_points)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(0,0,0),(10,10,10),(10,10,11),(20,25,30),(5,6,7),(100,-50,25),(-10,12,8)],\n        [(0,0,0),(1,1,1)],\n        [(5,-7,2),(5,-7,2),(0,0,0)],\n        [(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,0,0),(6,0,0),(7,0,0),(8,0,0),(9,0,0)],\n        [(0,1,1),(0,2,2),(0,3,3),(0,4,4),(0,4,5)],\n        [(-1000,500,-300),(-999,500,-300),(400,-800,1000),(401,-800,1000)]\n    ]\n\n    results = []\n    for case in test_cases:\n        if len(case)  2:\n            # Although all given test cases have n>=2, this handles the general case.\n            # The minimum distance between fewer than two points is considered infinite.\n            result = float('inf') \n        else:\n            result = solve_closest_pair(case)\n        \n        # Format the result to six decimal places.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}