{
    "hands_on_practices": [
        {
            "introduction": "To truly understand the power of the Miller-Rabin test, it's essential to work through its mechanics by hand. This exercise guides you through a single iteration of the test on a number that famously fools the simpler Fermat test, demonstrating how Miller-Rabin's reliance on nontrivial square roots of unity provides a more rigorous check for compositeness. By performing these calculations step-by-step, you will gain a concrete understanding of how a composite number is exposed and even how a factor can be revealed in the process .",
            "id": "3088381",
            "problem": "Consider the odd composite integer $n=341$ and the base $a=2$. The Miller–Rabin strong probable prime test proceeds by writing $n-1=2^{r}d$ with $d$ odd, computing the modular power $x_{0}\\equiv a^{d} \\pmod{n}$, and then forming the square chain $x_{j+1}\\equiv x_{j}^{2}\\pmod{n}$ for $j=0,1,\\dots,r-1$. In this framework, a step that witnesses compositeness occurs when $x_{j}\\equiv 1 \\pmod{n}$ for some $j\\geq 1$ while $x_{j-1}\\not\\equiv \\pm 1 \\pmod{n}$, which exhibits a nontrivial square root of $1$ modulo $n$. Using the definitions of modular arithmetic, exponentiation, and the decomposition of $n-1$, execute a complete Miller–Rabin iteration for the given $n$ and $a$: determine $r$ and $d$, compute $x_{0}$ and the subsequent $x_{j}$ values up to $j=r$, identify the earliest step witnessing compositeness, and then use the Greatest Common Divisor (GCD) to extract a nontrivial factor of $n$ from that step.\n\nProvide as your final answer the exact integer value of $\\gcd\\!\\big(x_{j-1}-1,n\\big)$ associated with the first witnessing step. Do not round; express your answer as an exact integer.",
            "solution": "The problem statement is a valid application of the Miller-Rabin primality test, a well-defined algorithm in number theory. All necessary data ($n=341$, $a=2$) and definitions are provided, and the problem is self-contained, objective, and scientifically sound. We may proceed with the solution.\n\nThe objective is to execute one iteration of the Miller–Rabin test for the integer $n=341$ with base $a=2$, identify the step that witnesses its compositeness, and use that information to find a nontrivial factor.\n\nFirst, we must decompose $n-1$ into the form $2^r d$, where $d$ is an odd integer.\nGiven $n=341$, we have $n-1 = 340$.\nWe factor out powers of $2$ from $340$:\n$$340 = 10 \\times 34 = (2 \\times 5) \\times (2 \\times 17) = 4 \\times 85 = 2^2 \\times 85$$\nHere, $d=85$ is odd. Thus, we identify $r=2$ and $d=85$.\n\nThe Miller–Rabin test sequence is defined by $x_0 \\equiv a^d \\pmod{n}$ and $x_{j+1} \\equiv x_j^2 \\pmod{n}$ for $j=0, 1, \\dots, r-1$.\n\nWe begin by computing $x_0$:\n$$x_0 \\equiv a^d \\pmod{n} \\equiv 2^{85} \\pmod{341}$$\nTo compute this modular exponentiation efficiently, we can use binary exponentiation (also known as repeated squaring). A particularly quick method for this specific problem is to first note that $2^{10} = 1024 = 3 \\times 341 + 1$, which implies $2^{10} \\equiv 1 \\pmod{341}$.\nUsing this fact, the calculation becomes simple:\n$$2^{85} = 2^{10 \\times 8 + 5} = (2^{10})^8 \\cdot 2^5 \\equiv 1^8 \\cdot 32 \\equiv 32 \\pmod{341}$$\nSo, $x_0 = 32$.\n\nThe test first checks if $x_0 \\equiv \\pm 1 \\pmod{n}$. Since $32 \\not\\equiv 1 \\pmod{341}$ and $32 \\not\\equiv -1 \\pmod{341}$ (as $-1 \\equiv 340 \\pmod{341}$), the test proceeds to the next step.\n\nNext, we compute the sequence $x_j$ for $j=1, \\dots, r-1$. Since $r=2$, we only need to compute $x_1$.\n$$x_1 \\equiv x_0^2 \\pmod{n} \\equiv 32^2 \\pmod{341}$$\n$$x_1 \\equiv 1024 \\pmod{341}$$\nAs determined earlier, $1024 = 3 \\times 341 + 1$. Therefore:\n$$x_1 \\equiv 1 \\pmod{341}$$\nThe test has found that for $j=1$, we have $x_1 \\equiv 1 \\pmod{341}$. The condition for witnessing compositeness is met because $x_1 \\equiv 1 \\pmod{n}$ while the previous term in the sequence, $x_{1-1}=x_0=32$, is not congruent to $\\pm 1 \\pmod{n}$. This is the first step that witnesses that $n$ is composite.\n\nThe existence of such an $x_0$ means it is a nontrivial square root of $1$ modulo $n$. That is, $x_0^2 \\equiv 1 \\pmod{n}$ but $x_0 \\not\\equiv \\pm 1 \\pmod{n}$. This can be rewritten as $x_0^2 - 1 \\equiv 0 \\pmod{n}$, or $(x_0 - 1)(x_0 + 1) \\equiv 0 \\pmod{n}$.\nThis implies that $n$ divides the product $(x_0 - 1)(x_0 + 1)$. Since $n$ does not divide $x_0-1$ (because $x_0 \\not\\equiv 1 \\pmod n$) and $n$ does not divide $x_0+1$ (because $x_0 \\not\\equiv -1 \\pmod n$), $n$ must share a nontrivial factor with each of $(x_0 - 1)$ and $(x_0 + 1)$.\n\nThe problem asks to extract a nontrivial factor using the Greatest Common Divisor (GCD) from the witnessing step. Specifically, we must calculate $\\gcd(x_{j-1}-1, n)$ where $j=1$ is the first witnessing step.\nThis requires computing $\\gcd(x_0 - 1, n)$.\nSubstituting the values we found:\n$$\\gcd(32 - 1, 341) = \\gcd(31, 341)$$\nTo calculate this GCD, we can use the Euclidean algorithm. Since $31$ is a prime number, we can simply test if $31$ is a divisor of $341$.\n$$341 \\div 31 = 11$$\nThe division is exact. Therefore, $31$ is a divisor of $341$, and the greatest common divisor is $31$.\n$$\\gcd(31, 341) = 31$$\nThis is the nontrivial factor of $n=341$ extracted from the Miller-Rabin test.",
            "answer": "$$\\boxed{31}$$"
        },
        {
            "introduction": "While manual calculations build intuition, the true utility of primality tests is realized through implementation. This practice challenges you to code both the Fermat and Miller-Rabin tests to programmatically discover composite numbers that pass the former but fail the latter. This exercise highlights the crucial distinction between simple pseudoprimes and strong pseudoprimes, providing a clear, practical demonstration of why the Miller-Rabin test is essential for applications requiring reliable primality checking .",
            "id": "3260318",
            "problem": "You are asked to design and implement a complete, runnable program that synthesizes composite integers $n$ which pass the Fermat primality test with base $a=2$, yet are detected as composite by the Miller–Rabin test (MR) with the same base $a=2$. The objective is to probe the structure of such integers and demonstrate why stronger tests are necessary within data structures and algorithms.\n\nBegin from the following foundational facts:\n\n1. Fermat's Little Theorem: For a prime $p$ and any integer $a$ with $\\gcd(a,p)=1$, one has $a^{p-1} \\equiv 1 \\pmod{p}$. This motivates the Fermat test for odd $n>2$: declare $n$ “probably prime” if $a^{n-1} \\equiv 1 \\pmod{n}$ for a chosen base $a$ coprime to $n$.\n2. Miller–Rabin test (MR): For odd $n>2$, write $n-1 = 2^s d$ with $d$ odd. For a chosen base $a$ with $\\gcd(a,n)=1$, compute $x_0 \\equiv a^d \\pmod{n}$ and then square repeatedly, $x_{r+1} \\equiv x_r^2 \\pmod{n}$ for $r = 0,1,\\dots,s-2$. If $x_0 \\equiv 1 \\pmod{n}$ or any $x_r \\equiv -1 \\pmod{n}$, MR declares $n$ “probably prime”; otherwise MR declares $n$ composite.\n\nIn this task, you must:\n\n- Implement a function to check whether an odd integer $n>2$ satisfies $2^{n-1} \\equiv 1 \\pmod{n}$ (Fermat base $a=2$).\n- Implement a Miller–Rabin test specialized to base $a=2$ for odd $n>2$ using the decomposition $n-1=2^s d$ and the above sequence, which returns a boolean indicating whether MR accepts $n$ as “probably prime” (true) or detects $n$ as composite (false).\n- Synthesize integers $n$ that both pass Fermat base $a=2$ (true) and fail MR base $a=2$ (false). Only consider odd $n>2$.\n- Probe their structure by checking Korselt's criterion for Carmichael numbers: an odd composite number $n$ is a Carmichael number if and only if $n$ is squarefree and, for every prime factor $p$ of $n$, one has $(p-1) \\mid (n-1)$. Implement a function that returns a boolean indicating whether a given $n$ satisfies Korselt's criterion.\n\nYour program must, for each provided test case, search odd $n$ in ascending order up to a given limit $L$, collect up to a specified count $K$ of integers $n$ that satisfy $2^{n-1} \\equiv 1 \\pmod{n}$ and fail MR with base $a=2$, and then report for each collected $n$ a pair consisting of the integer $n$ and a boolean indicating whether it satisfies Korselt's criterion. If fewer than $K$ such integers exist up to $L$, report the ones found. If none exist up to $L$, report an empty list.\n\nThere are no physical units or angles in this problem. All outputs are purely numerical and boolean.\n\nTest Suite and Final Output Specification:\n\n- Use the following test suite comprising three cases:\n  1. Case $1$: $L=5000$, $K=10$.\n  2. Case $2$: $L=300$, $K=5$.\n  3. Case $3$: $L=20000$, $K=7$.\n- For each case, produce a list of pairs $[n,c]$ where $n$ is the synthesized integer and $c$ is the boolean indicating whether $n$ satisfies Korselt's criterion.\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets. Each case’s result must itself be a bracket-enclosed comma-separated list of its $[n,c]$ pairs. For example, the output format must be exactly of the form\n  $$[ [n_1,c_1],[n_2,c_2],\\dots ],[ \\dots ],[ \\dots ]$$\n  with no spaces, where the outermost brackets enclose the three case results and each inner bracket encloses the pairs found for that case. Concretely, your program must print something like\n  $$[[n_1,c_1],[n_2,c_2]],[[\\dots]],[[\\dots]]$$\n  except with actual computed values, ensuring there are no spaces anywhere in the line.",
            "solution": "The problem is deemed valid after a thorough analysis. It is scientifically grounded in established number theory, well-posed with clear and consistent requirements, and expressed in objective mathematical language. The core task is to identify and analyze a specific class of composite integers: those that are identified as \"probably prime\" by the Fermat primality test with base $a=2$ but are correctly identified as composite by the stronger Miller-Rabin (MR) test with the same base. These numbers are Fermat pseudoprimes to base $2$ but not strong pseudoprimes to base $2$.\n\nThe problem statement's description of the Miller-Rabin test is slightly ambiguous regarding the range of indices for the check $x_r \\equiv -1 \\pmod{n}$. We will adopt the standard interpretation of the MR test, which is consistent with the problem's intent to contrast it with the weaker Fermat test. The standard MR test for an odd integer $n > 2$ with $n-1 = 2^s d$ (where $d$ is odd) and base $a$ passes if either $a^d \\equiv 1 \\pmod{n}$ or $a^{2^r d} \\equiv -1 \\pmod{n}$ for some $r$ in the range $0 \\le r < s$. A number is declared composite if it fails this test.\n\nThe solution will be constructed by implementing helper functions for each required number-theoretic test, then integrating them into a search algorithm as specified.\n\n### Method and Implementation Steps\n\n**1. Modular Exponentiation**\n\nAt the heart of both the Fermat and Miller-Rabin tests is the efficient computation of $a^b \\pmod{m}$. This is accomplished using the method of exponentiation by squaring, which is available in Python's built-in `pow(base, exp, mod)` function. This function will be used for all modular exponentiation needs.\n\n**2. Fermat Primality Test (Base $a=2$)**\n\nThis test is a direct application of Fermat's Little Theorem. For a given odd integer $n > 2$, we check if it satisfies the congruence $2^{n-1} \\equiv 1 \\pmod{n}$. The problem asks for integers that pass this test.\nThe function `is_fermat_prp(n)` will implement this check. Since the search is over odd $n$, the condition $\\gcd(2, n)=1$ is always met. The function returns `True` if $n$ is a Fermat pseudoprime to base $2$, and `False` otherwise.\n\n`is_fermat_prp(n)`:\n- Compute $2^{n-1} \\pmod{n}$.\n- Return `True` if the result is $1$, `False` otherwise.\n\n**3. Miller-Rabin Test (Base $a=2$)**\n\nThe MR test provides a more rigorous check for primality. For an odd integer $n > 2$, we first decompose $n-1$ into the form $2^s d$, where $d$ is odd. The test then examines the sequence of values $x_r = 2^{2^r d} \\pmod{n}$ for $r = 0, 1, \\dots, s-1$.\nThe function `is_miller_rabin_prp(n)` will return `True` if $n$ is a strong probable prime to base $2$ (passes the test) and `False` if it is definitively composite.\n\n`is_miller_rabin_prp(n)`:\n- Find $s$ and $d$ such that $n-1 = 2^s d$ with $d$ odd. This is done by repeatedly dividing $n-1$ by $2$ until it becomes odd.\n- Compute $x \\equiv 2^d \\pmod{n}$.\n- If $x=1$ or $x=n-1$, $n$ passes the test. Return `True`.\n- Loop $s-1$ times: square $x$ modulo $n$ in each step.\n  - $x \\leftarrow x^2 \\pmod{n}$.\n  - If $x=n-1$, $n$ passes the test. Return `True`.\n- If the loop completes without the condition $x=n-1$ being met, $n$ fails the test. Return `False`.\n\n**4. Structure Probing: Korselt's Criterion**\n\nThe problem requires checking if the synthesized numbers satisfy Korselt's criterion for Carmichael numbers. An odd composite number $n$ satisfies this criterion if it is square-free and for every prime factor $p$ of $n$, it holds that $(p-1) \\mid (n-1)$.\n\n`is_korselt_carmichael(n)`:\n- **Step 4a: Prime Factorization and Square-Free Check**: The function first needs to find all distinct prime factors of $n$. A trial division method is sufficient for the given limits. During factorization, we can simultaneously check if $n$ is square-free. If at any point we find a factor $p$ and $n/p$ is also divisible by $p$, then $n$ is not square-free, and the function can immediately return `False`.\n- **Step 4b: Divisibility Check**: If $n$ is found to be square-free, we iterate through each of its distinct prime factors $p_i$. For each $p_i$, we check if $(p_i-1)$ divides $(n-1)$. If this condition fails for any prime factor, the function returns `False`.\n- If all prime factors satisfy the condition, the function returns `True`.\n\nA helper function `is_prime(k)` using trial division up to $\\sqrt{k}$ is needed to ensure we only search for composite $n$.\n\n**5. Synthesis and Final Output Generation**\n\nThe main program logic iterates through the provided test cases $(L, K)$. For each case, it searches for odd integers $n$ from $3$ to the limit $L$.\n\nMain search loop for a given $(L, K)$:\n- Initialize an empty list `found_numbers`.\n- Iterate $n$ from $3$ to $L$ in steps of $2$.\n- For each $n$:\n  - Check if $n$ is composite using `is_prime(n)`. If it is prime, continue to the next $n$.\n  - Check if `is_fermat_prp(n)` is `True`.\n  - Check if `is_miller_rabin_prp(n)` is `False`.\n  - If both conditions are met, $n$ is a number of interest.\n    - Check if `is_korselt_carmichael(n)`.\n    - Add the pair $[n, \\text{korselt_result}]$ to `found_numbers`.\n    - If the count of numbers found reaches $K$, break the search loop.\n- After the loop, the list `found_numbers` contains the result for the current test case.\n\nFinally, the results for all test cases are formatted into a single string as per the exacting specification: `[[case1_results],[case2_results],[case3_results]]` with no whitespace. This is achieved by generating a string representation for each case's result list and then joining these strings with commas, enclosed in an outer pair of brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It synthesizes composite integers that pass the Fermat test but fail the Miller-Rabin test for base 2,\n    and checks them against Korselt's criterion.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"\n        Checks if a number is prime using trial division.\n        Assumes n is an odd integer > 2 for optimization inside the main loop.\n        \"\"\"\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        # Only need to check odd divisors up to sqrt(n)\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_fermat_prp(n):\n        \"\"\"\n        Checks if n passes the Fermat primality test for base a=2.\n        Returns True if 2^(n-1) === 1 (mod n).\n        \"\"\"\n        return pow(2, n - 1, n) == 1\n\n    def is_miller_rabin_prp(n):\n        \"\"\"\n        Checks if n passes the Miller-Rabin primality test for base a=2.\n        Returns True if n is a strong probable prime to base 2, False if composite.\n        \"\"\"\n        if n <= 2 or n % 2 == 0:\n            return n == 2\n        \n        # Write n-1 as 2^s * d\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        \n        # x = 2^d mod n\n        x = pow(2, d, n)\n        \n        if x == 1 or x == n - 1:\n            return True\n            \n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                return True\n        \n        return False\n\n    def is_korselt_carmichael(n):\n        \"\"\"\n        Checks if n satisfies Korselt's criterion for Carmichael numbers.\n        1. n must be square-free.\n        2. For every prime factor p of n, (p-1) must divide (n-1).\n        This function assumes n is odd and composite.\n        \"\"\"\n        n_minus_1 = n - 1\n        \n        # Factorize n and check for square-free property and divisibility.\n        temp_n = n\n        factors = []\n        \n        # Trial division for factorization\n        d = 3\n        while d * d <= temp_n:\n            if temp_n % d == 0:\n                # Found a prime factor\n                factors.append(d)\n                if n_minus_1 % (d - 1) != 0:\n                    return False\n                \n                temp_n //= d\n                # Check if not square-free\n                if temp_n % d == 0:\n                    return False\n            d += 2\n        \n        # Handle the last factor if it exists\n        if temp_n > 1:\n            factors.append(temp_n)\n            if n_minus_1 % (temp_n - 1) != 0:\n                return False\n\n        # Must be composite, so at least 2 factors. This is guaranteed by the calling context.\n        return True if len(factors) >= 2 else False\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5000, 10),\n        (300, 5),\n        (20000, 7),\n    ]\n\n    overall_results = []\n    for L, K in test_cases:\n        case_results = []\n        # Search odd integers n from 3 up to L\n        for n in range(3, L + 1, 2):\n            if len(case_results) >= K:\n                break\n            \n            # Problem asks for composite integers n\n            if is_prime(n):\n                continue\n            \n            # Condition: Pass Fermat base 2, Fail MR base 2\n            if is_fermat_prp(n) and not is_miller_rabin_prp(n):\n                korselt_result = is_korselt_carmichael(n)\n                case_results.append([n, korselt_result])\n        \n        overall_results.append(case_results)\n\n    # Format the final output string precisely as required, with no spaces.\n    case_strings = []\n    for case_res in overall_results:\n        # Convert each [n, c] pair to a string like \"[n,True]\"\n        pair_strings = [f\"[{item[0]},{item[1]}]\" for item in case_res]\n        # Join pairs into \"[p1,p2,...]\"\n        case_strings.append(f\"[{','.join(pair_strings)}]\")\n    \n    # Join all case strings into \"[c1,c2,c3]\"\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The Miller-Rabin test is probabilistic; a composite number might pass for one base but fail for another. This practice pushes that concept further by tasking you with finding the smallest composite integers that are \"strong pseudoprimes\" to multiple bases at once. By developing an efficient search program, you will gain insight into the diminishing probability of misclassification as more bases are used, reinforcing the core strategy that underpins the reliability of modern primality testing in practice .",
            "id": "3260350",
            "problem": "You are to design and implement a complete, runnable program that, for each given value of $k$, finds the smallest composite integer $n$ that is a strong pseudoprime to the first $k$ prime bases. The educational context is data structures and algorithms at the advanced undergraduate level, and the task requires reasoning from first principles about primality testing derived from foundational facts.\n\nFundamental base for the derivation:\n- Use Fermat’s little theorem: If $p$ is prime and $\\gcd(a,p)=1$, then $a^{p-1} \\equiv 1 \\pmod{p}$.\n- Use the definition of the Miller–Rabin (MR) strong pseudoprime test derived from the decomposition $n-1 = 2^{s} \\cdot d$ with $d$ odd, repeated squaring under modular arithmetic, and the necessity of $\\gcd(a,n)=1$.\n\nFormal definition demanded by the problem:\n- Let $n$ be an odd integer with $n \\geq 3$, and let $a$ be an integer satisfying $1 < a < n$ and $\\gcd(a,n)=1$. Write $n-1 = 2^{s} \\cdot d$ with $d$ odd. The integer $n$ is a strong pseudoprime to base $a$ if either $a^{d} \\equiv 1 \\pmod{n}$, or there exists $r \\in \\{0,1,\\ldots,s-1\\}$ such that $a^{d \\cdot 2^{r}} \\equiv -1 \\pmod{n}$.\n- For this task, \"the first $k$ prime bases\" means the set $\\{p_1, p_2, \\ldots, p_k\\}$ where $p_1=2$, $p_2=3$, $p_3=5$, $p_4=7$, $p_5=11$, $p_6=13$, and so on in increasing order. You must restrict attention to odd $n$ because any even composite $n$ fails immediately at base $2$ due to $\\gcd(2,n) \\neq 1$.\n\nAlgorithmic requirements:\n- Derive from the stated fundamentals an algorithm that, for an input $k$, enumerates candidate odd integers $n \\geq 3$ in increasing order, and tests whether $n$ is a strong pseudoprime to each base in $\\{p_1,\\ldots,p_k\\}$. This testing must be implemented using modular exponentiation and repeated squaring consistent with the factorization $n-1 = 2^{s} \\cdot d$.\n- Your algorithm must verify that the $n$ you return is composite. Use a mathematically sound compositeness check for the search range (for example, deterministic Miller–Rabin (MR) with a sufficiently strong fixed base set for the sizes encountered), and ensure that no prime is returned.\n- Efficiency considerations are part of the design: you should reduce unnecessary work via logical filtering implied by $\\gcd(a,n)=1$ for each base $a$ and by skipping candidates divisible by small primes among $\\{p_1,\\ldots,p_k\\}$ using a modulus wheel built from their product.\n\nInput and output specification:\n- There is no user input. The program must internally run a fixed test suite of $k$ values and print the corresponding minimal composite $n$ values.\n- Test suite parameters:\n  - Case $1$: $k=1$ (only base $2$).\n  - Case $2$: $k=2$ (bases $2$ and $3$).\n  - Case $3$: $k=3$ (bases $2$, $3$, and $5$).\n- Answers for each case must be integers. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, the format should be \"[x1,x2,x3]\" where $x_1$, $x_2$, and $x_3$ are the integer answers for the three cases, in that order.\n\nScientific realism and constraints:\n- All logic is purely mathematical and uses integer arithmetic and modular arithmetic; there are no physical units involved.\n- The program must be self-contained and runnable in any modern environment that supports the specified execution constraints, and it must not read any external input.\n\nYour task is to produce the program, together with a principled solution that explains why the algorithm is correct and how it is derived from the fundamental base above.",
            "solution": "The problem requires the design and implementation of an algorithm to find the smallest composite integer $n$ that is a strong pseudoprime to the first $k$ prime bases, for $k \\in \\{1, 2, 3\\}$. The derivation must be grounded in first principles, namely Fermat's Little Theorem and the definition of a strong pseudoprime.\n\n**1. Fundamental Principles: From Fermat's Little Theorem to the Miller-Rabin Test**\n\nThe foundation of many primality tests is Fermat's Little Theorem, which states that if $p$ is a prime number, then for any integer $a$ not divisible by $p$, we have $a^{p-1} \\equiv 1 \\pmod{p}$. The contrapositive provides a test for compositeness: if an integer $n$ does not satisfy $a^{n-1} \\equiv 1 \\pmod{n}$ for some integer $a$ with $\\gcd(a, n) = 1$, then $n$ must be composite.\n\nHowever, some composite numbers, known as Carmichael numbers, satisfy $a^{n-1} \\equiv 1 \\pmod{n}$ for all $a$ with $\\gcd(a, n) = 1$, rendering this simple test insufficient. The Miller-Rabin test refines this by exploiting a more profound property of prime numbers. If $p$ is prime, the only square roots of $1$ modulo $p$ are $1$ and $-1$. That is, the congruence $x^2 \\equiv 1 \\pmod{p}$ implies $x \\equiv 1 \\pmod{p}$ or $x \\equiv -1 \\pmod{p}$.\n\nThe Miller-Rabin test leverages this fact. For a given odd integer $n > 2$ to be tested, we decompose $n-1$ into the form $2^s \\cdot d$, where $d$ is odd and $s \\ge 1$. We then consider the sequence of modular exponentiations for a base $a$ ($1 < a < n-1$):\n$a^d, a^{2d}, a^{4d}, \\ldots, a^{2^{s-1}d} \\pmod{n}$.\nIf $n$ were prime, the last term, $a^{2^s d} = a^{n-1}$, must be $1 \\pmod{n}$ (by Fermat's Little Theorem, assuming $\\gcd(a,n)=1$). When we look at this sequence, if $n$ is prime, the first term that is $1 \\pmod{n}$ must be preceded by a term equal to $-1 \\pmod{n}$, unless the very first term ($a^d$) is $1 \\pmod{n}$. Any other outcome reveals a non-trivial square root of $1 \\pmod{n}$, proving $n$ is composite.\n\nThis leads to the formal definition of a strong pseudoprime, as stated in the problem: an odd composite integer $n$ is a strong pseudoprime to base $a$ if it satisfies the conditions that a prime number would. That is, with $n-1 = 2^s \\cdot d$ ($d$ odd), one of the following must hold:\n1. $a^d \\equiv 1 \\pmod{n}$\n2. $a^{d \\cdot 2^r} \\equiv -1 \\pmod{n}$ for some $r \\in \\{0, 1, \\ldots, s-1\\}$.\n\nIf a composite number $n$ satisfies this test for a base $a$, then $a$ is called a \"strong liar\" for $n$. Our task is to find the smallest composite $n$ for which the first $k$ prime numbers are all strong liars.\n\n**2. Algorithmic Design**\n\nThe problem requires a constructive search for the smallest such integer. The algorithm will therefore consist of three main components: a systematic search over candidate integers, a robust test for compositeness, and an implementation of the strong pseudoprime test.\n\n**2.1. Candidate Enumeration and Optimization**\nWe must search for an odd composite integer $n$ in increasing order, starting from $n=3$, to guarantee that the first one found is the smallest. A naive search would increment $n$ by $2$ at each step. However, we can apply crucial optimizations based on the problem's constraints.\n\nThe definition of a strong pseudoprime to base $a$ requires $\\gcd(a, n) = 1$. When testing against the first $k$ prime bases $\\{p_1, \\ldots, p_k\\}$, any candidate $n$ must be coprime to all of them. For instance, for $k=3$, the bases are $\\{2, 3, 5\\}$, so we only need to consider candidates $n$ that are not divisible by $2$, $3$, or $5$.\n\nThis naturally leads to a wheel factorization method. A wheel based on the product $M = p_1 \\cdot p_2 \\cdot \\ldots \\cdot p_k$ allows us to skip all multiples of these primes. For $k=3$, $M=30$. We only need to test numbers $n$ such that $\\gcd(n, 30)=1$. These are numbers congruent to $\\{1, 7, 11, 13, 17, 19, 23, 29\\}$ modulo $30$. This reduces the number of candidates to $\\phi(30)/30 = 8/30 \\approx 26.7\\%$ of the integers, a significant efficiency gain.\n\n**2.2. Compositeness Test**\nFor each candidate $n$, we must verify it is composite before checking the strong pseudoprime condition. A computationally efficient and definitive method for the expected range of $n$ (up to $\\approx 2.5 \\times 10^7$) is trial division. We can pre-compute a list of primes up to $\\sqrt{N_{max}}$, where $N_{max}$ is a generous upper bound for our search. For $N_{max} = 3 \\times 10^7$, we need primes up to $\\sqrt{3 \\times 10^7} \\approx 5478$. A sieve can generate these primes. The compositeness test for $n$ then involves checking for divisibility by each pre-computed prime $p$ up to $p^2 \\le n$. If a divisor is found, $n$ is composite. If no such divisor is found, $n$ is prime, and we move to the next candidate.\n\n**2.3. Strong Pseudoprime Test Implementation (`is_spsp`)**\nThis function, say `is_spsp(n, a)`, directly implements the formal definition.\n1. Given $n$ and base $a$, first find $s$ and $d$ such that $n-1 = 2^s \\cdot d$ with $d$ odd. This is achieved by repeatedly dividing $n-1$ by $2$ until it becomes odd.\n2. Compute $x = a^d \\pmod{n}$ using an efficient modular exponentiation algorithm (e.g., binary exponentiation or repeated squaring).\n3. If $x=1$ or $x=n-1$, the condition is met, and $n$ is a strong pseudoprime to base $a$.\n4. Otherwise, for $r$ from $1$ to $s-1$, repeatedly square $x$ modulo $n$ (i.e., $x \\leftarrow x^2 \\pmod n$). If $x=n-1$, the condition is met.\n5. If the loop completes without meeting the condition, $n$ is not a strong pseudoprime to base $a$.\n\n**3. Synthesis of the Final Algorithm**\n\nFor each required value of $k \\in \\{1, 2, 3\\}$:\n1. Generate the set of the first $k$ prime bases, $B = \\{p_1, \\ldots, p_k\\}$.\n2. Pre-compute a list of primes using a sieve, up to a limit sufficient for the compositeness test (e.g., up to $6000$).\n3. Initialize the candidate $n$ and the search progression according to a wheel based on $B$. For $k=1$, start at $n=9$ and increment by $2$. For $k>1$, use a wheel to generate candidates coprime to the bases.\n4. Loop indefinitely:\n    a. Select the next candidate $n$ from the enumeration scheme.\n    b. Verify that $n$ is composite using trial division against the sieved primes. If $n$ is prime, continue to the next candidate.\n    c. Assume $n$ is a potential answer (`is_candidate = True`).\n    d. For each base $a \\in B$:\n        i. If `is_spsp(n, a)` returns `False`, set `is_candidate = False` and break the inner loop.\n    e. If `is_candidate` remains `True` after checking all bases, then $n$ is the smallest composite integer satisfying the conditions. Return $n$ and terminate this search.\n\nThis systematic procedure, combining an optimized search with mathematically sound tests for compositeness and the strong pseudoprime property, guarantees finding the correct minimal integer for each $k$. The results for $k=1$, $k=2$, and $k=3$ are known to be $2047$, $1,373,653$, and $25,326,001$, respectively. The algorithm must be efficient enough to find these within a reasonable time. The use of a wheel for $k=2$ and $k=3$ is critical for performance.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to find the smallest composite strong pseudoprime for k=1, 2, 3.\n    \"\"\"\n\n    # The numpy import is included to conform to the problem's execution environment\n    # specification, but it is not used in the algorithmic logic.\n\n    def is_spsp(n, a):\n        \"\"\"\n        Checks if n is a strong pseudoprime to base a (Miller-Rabin test).\n        Assumes n is an odd integer > 2.\n        \"\"\"\n        if n % a == 0:  # Base a divides n, so gcd(a, n) != 1\n            return False\n\n        # Decompose n-1 into 2^s * d\n        d, s = n - 1, 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n\n        # Compute x = a^d mod n\n        x = pow(a, d, n)\n\n        if x == 1 or x == n - 1:\n            return True\n\n        # Repeatedly square x\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                return True\n\n        return False\n\n    def find_smallest_spsp(k):\n        \"\"\"\n        Finds the smallest composite integer n that is a strong pseudoprime\n        to the first k prime bases.\n        \"\"\"\n        # Generate a list of primes for bases and for compositeness testing\n        max_prime_sieve = 6000  # sqrt(3.6e7) is ~6000, covers up to k=3 answer\n        primes = []\n        is_prime_sieve = [True] * max_prime_sieve\n        is_prime_sieve[0] = is_prime_sieve[1] = False\n        for p in range(2, max_prime_sieve):\n            if is_prime_sieve[p]:\n                primes.append(p)\n                for i in range(p * p, max_prime_sieve, p):\n                    is_prime_sieve[i] = False\n        \n        bases = primes[:k]\n\n        def is_composite(n):\n            \"\"\"\n            Tests if n is composite using trial division with sieved primes.\n            Returns True if composite, False if prime.\n            \"\"\"\n            for p in primes:\n                if p * p > n:\n                    break\n                if n % p == 0:\n                    return True\n            return False\n\n        # Set up search parameters based on k\n        if k == 1: # Bases {2}\n            n = 3\n            increment_gen = (2 for _ in iter(int, 1)) # Generator for odd numbers\n        elif k == 2: # Bases {2, 3}, wheel for mod 6\n            n = 5\n            increments = [2, 4]\n            i_idx = 0\n            def gen_inc():\n                nonlocal i_idx\n                while True:\n                    yield increments[i_idx]\n                    i_idx = (i_idx + 1) % len(increments)\n            increment_gen = gen_inc()\n        elif k == 3: # Bases {2, 3, 5}, wheel for mod 30\n            n = 7\n            increments = [4, 2, 4, 2, 4, 6, 2, 6]\n            i_idx = 0\n            def gen_inc():\n                nonlocal i_idx\n                while True:\n                    yield increments[i_idx]\n                    i_idx = (i_idx + 1) % len(increments)\n            increment_gen = gen_inc()\n        else:\n            # Fallback for k > 3, not required by problem\n            n = 3\n            increment_gen = (2 for _ in iter(int, 1))\n\n        while True:\n            # For k > 1, the wheel generation already filters out multiples of bases.\n            # We add an explicit check for k=1 case (not needed, but for consistency)\n            # and to handle the starting n not being a multiple of a base.\n            \n            # The wheel guarantees n is not divisible by any base in B,\n            # except potentially for the starting n, which we choose carefully.\n            \n            if is_composite(n):\n                is_candidate = True\n                for b in bases:\n                    if not is_spsp(n, b):\n                        is_candidate = False\n                        break\n                if is_candidate:\n                    return n\n            \n            n += next(increment_gen)\n\n\n    test_cases = [1, 2, 3]\n    results = []\n    for k_val in test_cases:\n        result = find_smallest_spsp(k_val)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}