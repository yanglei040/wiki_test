{
    "hands_on_practices": [
        {
            "introduction": "在深入研究量子算法之前，理解它们运行的“舞台”——量子态空间——的巨大规模至关重要。这项练习通过计算经典计算机仅用于存储一个中等数量量子比特（qubit）的状态所需的指数级增长的资源，让您对这一规模有切身的体会。通过这个练习 ，您将清晰地看到经典比特与量子比特在信息容量上的根本差异，这也是驱动我们探索量子计算的根本原因之一。",
            "id": "3242197",
            "problem": "考虑在一台经典计算机上模拟一个 $n$ 量子比特寄存器的纯态。一个纯态是维度为 $2^n$ 的复希尔伯特空间中的单位向量，在计算基下，它可以写成一个由 $2^n$ 个复数概率幅组成的列向量。为了在一台经典机器上精确地存储这个态向量，您将每个复数幅值记录为两个实值浮点数，每个浮点数占用 $b$ 个字节。假设使用双精度，所以 $b = 8$。\n\n您获得一台机器，其随机存取存储器（RAM）容量为 $M = 256 \\times 2^{30}$ 字节（即，以字节表示的 $256$ 吉比字节）。忽略任何额外的开销，并假设内存可以完全用于存储该态向量。\n\n仅从 $n$ 量子比特的态空间维度为 $2^n$ 以及每个复数幅值由两个实数组成这一定义出发，推导：\n\n- 一个关于 $n$ 的表达式，表示存储完整态向量所需的实值浮点数的总数。\n- 使得精确态向量能够装入给定 RAM 的最大量子比特数（整数）$n$。\n\n请将您的最终答案以行矩阵的形式给出，第一个条目是关于 $n$ 的浮点数数量的表达式，第二个条目是在内存限制下的最大 $n$ 值。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是可靠的。它具有科学依据，问题定义明确，客观，并包含推导出唯一解所需的所有必要信息。\n\n该问题要求两个量：首先，一个表达式，表示存储一个 $n$ 量子比特系统的态向量所需的实值浮点数的总数；其次，在给定的内存容量下，可以模拟的最大量子比特数（整数）$n$。\n\n我们首先来推导浮点数数量的表达式。\n一个 $n$ 量子比特寄存器的纯量子态由一个位于复希尔伯特空间 $\\mathcal{H}$ 中的态向量 $|\\psi\\rangle$ 描述。该空间的维度 $D$ 由 $D = 2^n$ 给出。这是因为 $n$ 个量子比特中的每一个都有一个二维的态空间，而复合系统的态空间是各个独立空间的张量积，因此维度是 $2 \\times 2 \\times \\dots \\times 2$（$n$ 次），即 $2^n$。\n\n在计算基中，态向量 $|\\psi\\rangle$ 表示为 $2^n$ 个基向量的线性组合：\n$$|\\psi\\rangle = \\sum_{k=0}^{2^n - 1} c_k |k\\rangle$$\n其中系数 $c_k$ 是被称为概率幅的复数。该状态由这 $2^n$ 个复数幅值的集合完全确定。\n\n要在经典计算机上存储这个态向量，我们必须存储这 $2^n$ 个复数中的每一个。一个复数 $c_k$ 可以写成 $c_k = a_k + i b_k$，其中 $a_k$ 和 $b_k$ 分别是表示实部和虚部的实数。问题陈述中指出，每个复数幅值存储为两个实值浮点数。\n\n设 $N_{fp}(n)$ 为所需的实值浮点数的总数。这个总数是复数幅值的数量与每个复数幅值所需的实数数量的乘积。\n$$N_{fp}(n) = (\\text{复数幅值的数量}) \\times (\\text{每个复数幅值的实数数量})$$\n复数幅值的数量就是态空间的维度，即 $2^n$。每个复数幅值所需的实数数量给定为 $2$。\n因此，作为 $n$ 的函数的浮点数总数的表达式为：\n$$N_{fp}(n) = 2^n \\times 2 = 2^{n+1}$$\n\n接下来，我们确定可以在给定 RAM 中存储的最大量子比特数（整数）$n_{max}$。\n存储态向量所需的总内存大小，我们称之为 $S(n)$，是浮点数的总数乘以每个数字的内存大小。\n问题明确指出每个浮点数的大小为 $b=8$ 字节（双精度）。\n所以，以字节为单位所需的总内存为：\n$$S(n) = N_{fp}(n) \\times b = 2^{n+1} \\times 8$$\n因为 $8 = 2^3$，我们可以将 $S(n)$ 表示为 $2$ 的单一幂：\n$$S(n) = 2^{n+1} \\times 2^3 = 2^{n+4} \\text{ 字节}$$\n可用的 RAM 容量给定为 $M = 256 \\times 2^{30}$ 字节。为了便于比较，我们需要将 $M$ 表示为 $2$ 的幂。数字 $256$ 是 $2^8$。\n$$M = 256 \\times 2^{30} = 2^8 \\times 2^{30} = 2^{38} \\text{ 字节}$$\n为了找到最大量子比特数 $n$，我们必须找到使得所需内存 $S(n)$ 不超过可用内存 $M$ 的最大整数 $n$。这可以表示为不等式：\n$$S(n) \\le M$$\n代入 $S(n)$ 和 $M$ 的表达式：\n$$2^{n+4} \\le 2^{38}$$\n由于指数函数的底数 $2$ 大于 $1$，该不等式对指数也成立：\n$$n+4 \\le 38$$\n解出 $n$：\n$$n \\le 38 - 4$$\n$$n \\le 34$$\n由于 $n$ 必须是整数，因此在给定的内存限制下可以模拟的最大量子比特数是 $n_{max} = 34$。\n\n两个结果是：\n1. 浮点数数量的表达式是 $2^{n+1}$。\n2. 最大量子比特数（整数）是 $34$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2^{n+1} & 34 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在了解了量子态的庞大规模之后，下一步是理解这些状态是如何演化的。这项实践  通过让您为一个小型量子线路构建一个经典模拟器来揭开这个过程的神秘面纱。通过亲手实现像哈达玛门（Hadamard gate）和受控非门（CNOT gate）这样的基本量子门如何作用于状态向量，您将对量子计算背后的底层机制有一个具体而深入的认识。",
            "id": "3242157",
            "problem": "设计并实现一个针对恰好 $3$ 个量子比特的量子电路的经典态矢量模拟器，该模拟器使用对复数态矢量的显式矩阵向量乘法。计算基为 $\\{|000\\rangle, |001\\rangle,\\ldots, |111\\rangle\\}$，一个 $n$ 量子比特上的纯态表示为 $\\mathbb{C}^{2^n}$ 中的一个复数向量，其 $\\ell_2$-范数等于 $1$。一个作用在量子比特索引 $t$ 上的单量子比特门（其中最低有效位是量子比特索引 $0$）由一个 $2\\times 2$ 的酉矩阵 $U$ 表示，该矩阵通过与单位矩阵进行克罗内克积扩展到整个寄存器，并通过矩阵向量乘积作用于状态。一个双量子比特受控非门（控制位 $c$，目标位 $t$）通过一个线性操作来置换振幅，该操作也可以通过适当的索引交换来实现。\n\n使用的基本原理：\n- 状态更新规则是线性的：如果一个矩阵为 $G$ 的门作用在寄存器上，那么新状态为 $G\\psi$，其中 $\\psi\\in\\mathbb{C}^{2^n}$ 是当前状态。\n- 计算基态 $|q_{n-1}\\ldots q_1 q_0\\rangle$ 对应于小端序中的整数索引 $\\sum_{k=0}^{n-1} q_k 2^k$，其中 $q_k\\in\\{0,1\\}$。\n- 单量子比特门作为 $2\\times 2$ 矩阵向量乘法局部作用于仅在目标量子比特上不同的不相交振幅对。\n\n你的任务：\n1. 实现一个模拟器，该模拟器：\n   - 将状态初始化为 $|000\\rangle$。\n   - 应用一个以电路描述形式指定的门序列。支持的门包括作用于指定量子比特的阿达马门 $H=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & 1\\\\ 1 & -1\\end{pmatrix}$，作用于指定量子比特的泡利 $X$ 门 $X=\\begin{pmatrix}0 & 1\\\\ 1 & 0\\end{pmatrix}$，以及作用于指定控制和目标量子比特的受控非门 $(\\mathrm{CNOT}(c \\to t))$。\n   - 对单量子比特门使用显式矩阵向量乘法语义，通过更新每个受影响的双振幅对 $\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}\\mapsto U\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}$。\n   - 对于 $\\mathrm{CNOT}(c \\to t)$，通过交换那些控制位为 $1$ 且目标位为 $0$ 的基索引与其目标位为 $1$ 的对应项来更新振幅。\n2. 根据以下统一成本模型，计算你的实现所执行的基本算术运算次数：\n   - 每次在 $n$ 个量子比特上应用单量子比特门时，计 $4\\cdot 2^{n-1}$ 次复数乘法和 $2\\cdot 2^{n-1}$ 次复数加法。\n   - 每次在 $n$ 个量子比特上应用受控非门时，计因交换产生的 $3\\cdot 2^{n-2}$ 次标量赋值。将每次交换视为 $3$ 次赋值。\n   - 报告在整个电路中累积的这些计数。\n3. 对于下面的每个测试用例，计算从最终状态测量到基态 $|111\\rangle$ 的概率，该概率是索引 $7$ 处（按上述小端序索引）振幅的模的平方。\n\n测试套件：\n- 用例 A（边界情况，空电路）：$n=3$，电路深度 $d=0$，没有门。查询 $|111\\rangle$ 的概率。\n- 用例 B（均匀叠加）：$n=3$，依次在量子比特 $0$、$1$ 和 $2$ 上应用 $H$ 门。查询 $|111\\rangle$ 的概率。\n- 用例 C（纠缠到 Greenberger–Horne–Zeilinger 态）：$n=3$，在量子比特 $0$ 上应用 $H$ 门，然后是 $\\mathrm{CNOT}(0 \\to 1)$，再然后是 $\\mathrm{CNOT}(1 \\to 2)$。查询 $|111\\rangle$ 的概率。\n- 用例 D（通过对合抵消）：$n=3$，在量子比特 $2$ 上应用两次 $X$ 门。查询 $|111\\rangle$ 的概率。\n\n答案规范和最终输出格式：\n- 对于每个测试用例，你的程序必须按此确切顺序生成一个包含六个条目的列表：\n  - $|111\\rangle$ 的概率，以实数形式表示。\n  - 计数的复数乘法总数。\n  - 计数的复数加法总数。\n  - 计数的因交换产生的标量赋值总数。\n  - 使用的量子比特数 $n$。\n  - 电路深度 $d$（电路中的门数）。\n- 将四个用例的列表聚合到一个列表中。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如，形状为 $[\\text{用例A},\\text{用例B},\\text{用例C},\\text{用例D}]$，其中每个用例本身都是如上定义的列表。\n\n你的分析目标：\n- 从第一性原理出发，在所述成本模型下，推导渐近运行时作为量子比特数 $n$ 和电路深度 $d$ 的函数，不假设任何结果。解释每个用例的计数，以证明对于由 $O(1)$ 量子比特门组成的电路，运行时与 $n$ 呈指数依赖关系，与 $d$ 呈线性依赖关系。不要在问题陈述中提供快捷公式；在解决方案中展示你的推理过程。不涉及物理单位或角度。所有角度（如果有）都将以弧度为单位，但此处未使用。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于量子计算的原理，问题提出得当，目标明确，数据充分，并且没有歧义或矛盾。我们可以继续进行解答。\n\n任务是为一个 $3$ 量子比特的量子系统设计一个经典态矢量模拟器，并分析其在特定电路上的性能。模拟通过显式更新代表量子态的复数向量来进行。\n\n一个 $n$ 量子比特的纯量子态由一个维度为 $2^n$ 的复希尔伯特空间中的态矢量 $\\psi$ 表示，即 $\\psi \\in \\mathbb{C}^{2^n}$。该矢量被归一化，使其 $\\ell_2$-范数为 $1$，即 $\\|\\psi\\|_2 = 1$。计算基态用 $|q_{n-1} \\ldots q_1 q_0 \\rangle$ 表示，其中每个 $q_k \\in \\{0, 1\\}$。问题指定了从这些基态到态矢量 $\\psi$ 索引的小端序映射。基态 $|q_{n-1} \\ldots q_1 q_0 \\rangle$ 对应于整数索引 $i = \\sum_{k=0}^{n-1} q_k 2^k$。在我们 $n=3$ 的情况下，态矢量 $\\psi$ 有 $2^3 = 8$ 个复数分量，索引从 $0$ 到 $7$。基态 $|q_2 q_1 q_0 \\rangle$ 映射到索引 $i = 4q_2 + 2q_1 + q_0$。初始状态指定为 $|000\\rangle$，对应于索引 $0$。因此，初始态矢量为 $\\psi_{initial} = [1, 0, 0, 0, 0, 0, 0, 0]^T$。\n\n在一个矩阵表示为 $G$ 的量子门作用下，状态的演化由矩阵向量乘积 $\\psi' = G\\psi$ 给出。对于一个 $n$ 量子比特系统，$G$ 是一个 $2^n \\times 2^n$ 的酉矩阵。我们按规定实现门的应用。\n\n模拟的成本通过根据提供的统一成本模型计算基本算术运算来衡量：\n- 对于 $n$ 量子比特上的单量子比特门：$4 \\cdot 2^{n-1}$ 次复数乘法和 $2 \\cdot 2^{n-1}$ 次复数加法。\n- 对于 $n$ 量子比特上的 $\\mathrm{CNOT}$ 门：$3 \\cdot 2^{n-2}$ 次标量赋值。\n\n测量特定基态（例如 $|111\\rangle$，对应索引 $i=7$）的概率由最终态矢量中相应振幅的模的平方给出：$P(|111\\rangle) = |\\psi_{final}[7]|^2$。\n\n**单量子比特门的应用**\n一个矩阵为 $U = \\begin{pmatrix} U_{00} & U_{01} \\\\ U_{10} & U_{11} \\end{pmatrix}$、作用在量子比特 $t$ 上的单量子比特门由 $2^n \\times 2^n$ 矩阵 $G = I^{\\otimes(n-1-t)} \\otimes U \\otimes I^{\\otimes t}$ 表示。直接应用这个大矩阵是低效的。相反，我们使用指定的局部更新规则。该门只影响那些仅在量子比特 $t$ 上有差异的基态所对应的振幅对。\n对于从 $0$ 到 $2^n-1$ 的每个整数索引 $i$，如果其第 $t$ 位为 $0$，我们找到它的配对索引 $j = i + 2^t$，其中第 $t$ 位为 $1$。这些索引处的振幅 $\\psi_i$ 和 $\\psi_j$ 根据 $2 \\times 2$ 矩阵 $U$进行更新：\n$$\n\\begin{pmatrix} \\psi'_i \\\\ \\psi'_j \\end{pmatrix} = \\begin{pmatrix} U_{00} & U_{01} \\\\ U_{10} & U_{11} \\end{pmatrix} \\begin{pmatrix} \\psi_i \\\\ \\psi_j \\end{pmatrix} = \\begin{pmatrix} U_{00}\\psi_i + U_{01}\\psi_j \\\\ U_{10}\\psi_i + U_{11}\\psi_j \\end{pmatrix}\n$$\n共有 $2^{n-1}$ 个这样的索引对。每对的更新需要 $4$ 次复数乘法和 $2$ 次复数加法。这使得每次应用单量子比特门的总计算量为 $4 \\cdot 2^{n-1}$ 次复数乘法和 $2 \\cdot 2^{n-1}$ 次复数加法，与指定的成本模型完全匹配。对于 $n=3$，这是 $4 \\cdot 2^2 = 16$ 次乘法和 $2 \\cdot 2^2 = 8$ 次加法。\n\n具体的单量子比特门是阿达马门 $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix}$ 和泡利-X门 $X = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}$。\n\n**受控非门（CNOT）的应用**\n$\\mathrm{CNOT}(c \\to t)$ 门当且仅当控制量子比特 $c$ 为 $1$ 时翻转目标量子比特 $t$。在计算基中，这相当于一个置换：$\\mathrm{CNOT} |\\dots q_c \\dots q_t \\dots \\rangle = |\\dots q_c \\dots (q_t \\oplus q_c) \\dots \\rangle$。这仅在 $q_c=1$ 时产生影响。因此，该操作交换基态 $|\\dots 1_c \\dots 0_t \\dots \\rangle$ 和 $|\\dots 1_c \\dots 1_t \\dots \\rangle$ 的振幅。\n在态矢量索引方面，我们必须识别所有第 $c$ 位为 $1$ 且第 $t$ 位为 $0$ 的索引 $i$。对于每个这样的 $i$，对应的索引 $j$ 是 $i + 2^t$。然后模拟器交换振幅 $\\psi_i$ 和 $\\psi_j$。需要交换的此类对的数量是选择剩余 $n-2$ 个比特的方式数，即 $2^{n-2}$。对于 $n=3$，这是 $2^{3-2}=2$ 对。\n成本模型指定一次交换需要 $3$ 次标量赋值。因此，一个 $\\mathrm{CNOT}$ 门的成本是 $3 \\cdot 2^{n-2}$ 次赋值。对于 $n=3$，这是 $3 \\cdot 2^1 = 6$ 次赋值。\n\n**渐近运行时分析**\n态矢量的大小为 $N=2^n$。应用一个单量子比特门的成本是 $O(2^n)$。应用一个双量子比特 $\\mathrm{CNOT}$ 门的成本也是 $O(2^n)$。通常，模拟任何作用于常数个量子比特 $k$ 的门，需要更新 $2^k$ 个振幅的元组，遍历 $2^{n-k}$ 个这样的元组，从而导致计算成本为 $O(2^n)$。\n对于一个深度为 $d$（这里解释为总门数）的电路，总模拟成本是每个门成本的总和。这导致总运行时为 $O(d \\cdot 2^n)$。这证实了对量子比特数 $n$ 的预期指数依赖性和对电路深度 $d$ 的线性依赖性。\n\n**测试用例分析**\n\n**用例 A：空电路**\n- 电路：无。$n=3, d=0$。\n- 初始状态：$\\psi = |000\\rangle = [1, 0, 0, 0, 0, 0, 0, 0]^T$。\n- 最终状态：不变，$\\psi_{final} = [1, 0, 0, 0, 0, 0, 0, 0]^T$。\n- $|111\\rangle$ 的概率：$P(|111\\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$。\n- 操作计数：没有应用任何门。\n  - 复数乘法：$0$。\n  - 复数加法：$0$。\n  - 交换赋值：$0$。\n- 结果：$[0.0, 0, 0, 0, 3, 0]$。\n\n**用例 B：均匀叠加**\n- 电路：在量子比特 $0$ 上应用 $H$ 门，然后在量子比特 $1$ 上应用 $H$ 门，再然后在量子比特 $2$ 上应用 $H$ 门。$n=3, d=3$。\n- 状态演化：\n  - $\\psi_0 = |000\\rangle$。\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |001\\rangle)$。\n  - $\\psi_2 = H_1 \\psi_1 = \\frac{1}{2}(|000\\rangle + |001\\rangle + |010\\rangle + |011\\rangle)$。\n  - $\\psi_{final} = H_2 \\psi_2 = \\frac{1}{2\\sqrt{2}} \\sum_{i=0}^{7} |i\\rangle$。\n- 在最终状态中，所有振幅均为 $\\frac{1}{\\sqrt{8}}$。\n- $|111\\rangle$ 的概率：$P(|111\\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{8}}|^2 = \\frac{1}{8} = 0.125$。\n- 操作计数：应用了 $3$ 个单量子比特门。\n  - 每个门的成本：$16$ 次乘法，$8$ 次加法。\n  - 总乘法次数：$3 \\times 16 = 48$。\n  - 总加法次数：$3 \\times 8 = 24$。\n  - 总交换次数：$0$。\n- 结果：$[0.125, 48, 24, 0, 3, 3]$。\n\n**用例 C：GHZ 态制备**\n- 电路：在量子比特 $0$ 上应用 $H$ 门，然后是 $\\mathrm{CNOT}(0 \\to 1)$，再然后是 $\\mathrm{CNOT}(1 \\to 2)$。$n=3, d=3$。\n- 状态演化：\n  - $\\psi_0 = |000\\rangle$。\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |001\\rangle)$。\n  - $\\psi_2 = \\mathrm{CNOT}(0 \\to 1) \\psi_1 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |011\\rangle)$。这是因为 $|001\\rangle$ 分量的控制位 $0$ 为 $1$，所以目标位 $1$ 被翻转。\n  - $\\psi_{final} = \\mathrm{CNOT}(1 \\to 2) \\psi_2 = \\frac{1}{\\sqrt{2}}(|000\\rangle + |111\\rangle)$。$|000\\rangle$ 分量不变（控制位 $1$ 为 $0$）。$|011\\rangle$ 分量的控制位 $1$ 为 $1$，所以目标位 $2$ 被翻转（$|011\\rangle \\to |111\\rangle$）。\n- 最终态矢量具有非零振幅 $\\psi_{final}[0] = \\frac{1}{\\sqrt{2}}$ 和 $\\psi_{final}[7] = \\frac{1}{\\sqrt{2}}$。\n- $|111\\rangle$ 的概率：$P(|111\\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2} = 0.5$。\n- 操作计数：$1$ 个单量子比特门和 $2$ 个 $\\mathrm{CNOT}$ 门。\n  - $H(0)$：$16$ 次乘法，$8$ 次加法。\n  - $\\mathrm{CNOT}(0 \\to 1)$：$6$ 次交换赋值。\n  - $\\mathrm{CNOT}(1 \\to 2)$：$6$ 次交换赋值。\n  - 总乘法次数：$16$。\n  - 总加法次数：$8$。\n  - 总交换次数：$6 + 6 = 12$。\n- 结果：$[0.5, 16, 8, 12, 3, 3]$。\n\n**用例 D：对合**\n- 电路：在量子比特 $2$ 上应用 $X$ 门，然后再次在量子比特 $2$ 上应用 $X$ 门。$n=3, d=2$。\n- 状态演化：由于 $X^2=I$（单位矩阵），应用两次该门等同于不进行任何操作。\n  - $\\psi_0 = |000\\rangle$。\n  - $\\psi_1 = X_2 \\psi_0 = |100\\rangle$。\n  - $\\psi_{final} = X_2 \\psi_1 = X_2 |100\\rangle = |000\\rangle$。\n- 最终状态是初始状态 $|000\\rangle$。\n- $|111\\rangle$ 的概率：$P(|111\\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$。\n- 操作计数：应用了 $2$ 个单量子比特门。\n  - 每个门的成本：$16$ 次乘法，$8$ 次加法。\n  - 总乘法次数：$2 \\times 16 = 32$。\n  - 总加法次数：$2 \\times 8 = 16$。\n  - 总交换次数：$0$。\n- 结果：$[0.0, 32, 16, 0, 3, 2]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass QuantumCircuitSimulator:\n    \"\"\"\n    A classical state-vector simulator for a multi-qubit quantum circuit.\n    \"\"\"\n    def __init__(self, n: int):\n        \"\"\"\n        Initializes the simulator for n qubits in the |0...0> state.\n        \n        Args:\n            n (int): The number of qubits.\n        \"\"\"\n        if not isinstance(n, int) or n = 0:\n            raise ValueError(\"Number of qubits n must be a positive integer.\")\n        self.n = n\n        self.num_states = 1  n\n        \n        # State vector, initialized to |0...0>\n        self.state_vector = np.zeros(self.num_states, dtype=np.complex128)\n        self.state_vector[0] = 1.0\n\n        # Operation counters\n        self.op_counts = {\n            'complex_mult': 0,\n            'complex_add': 0,\n            'swap_assign': 0\n        }\n\n    def _apply_single_qubit_gate(self, U: np.ndarray, target_qubit: int):\n        \"\"\"\n        Applies a single-qubit gate U to the target qubit.\n        \n        Args:\n            U (np.ndarray): A 2x2 unitary matrix.\n            target_qubit (int): The index of the qubit to act on.\n        \"\"\"\n        U_flat = U.flatten()\n        \n        for i in range(self.num_states):\n            # Process each pair once by only starting from states where the target bit is 0\n            if (i >> target_qubit)  1 == 0:\n                j = i | (1  target_qubit)\n                \n                psi_i = self.state_vector[i]\n                psi_j = self.state_vector[j]\n                \n                self.state_vector[i] = U_flat[0] * psi_i + U_flat[1] * psi_j\n                self.state_vector[j] = U_flat[2] * psi_i + U_flat[3] * psi_j\n        \n        # Update counts based on the problem's cost model\n        self.op_counts['complex_mult'] += 4 * (1  (self.n - 1))\n        self.op_counts['complex_add'] += 2 * (1  (self.n - 1))\n\n    def _apply_cnot_gate(self, control_qubit: int, target_qubit: int):\n        \"\"\"\n        Applies a CNOT gate.\n        \n        Args:\n            control_qubit (int): The index of the control qubit.\n            target_qubit (int): The index of the target qubit.\n        \"\"\"\n        for i in range(self.num_states):\n            is_control_one = ((i >> control_qubit)  1) == 1\n            is_target_zero = ((i >> target_qubit)  1) == 0\n\n            # We only want to perform the swap once per pair. \n            # Processing only when target is 0 ensures this.\n            if is_control_one and is_target_zero:\n                j = i | (1  target_qubit)\n                # Swap amplitudes\n                self.state_vector[i], self.state_vector[j] = self.state_vector[j], self.state_vector[i]\n        \n        # Update counts based on the problem's cost model\n        # For n qubits, there are 2^(n-2) pairs to swap.\n        # Each swap is 3 assignments.\n        if self.n >= 2:\n            self.op_counts['swap_assign'] += 3 * (1  (self.n - 2))\n\n    def h(self, target_qubit: int):\n        \"\"\"Applies a Hadamard gate.\"\"\"\n        H = (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=np.complex128)\n        self._apply_single_qubit_gate(H, target_qubit)\n\n    def x(self, target_qubit: int):\n        \"\"\"Applies a Pauli-X gate.\"\"\"\n        X = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n        self._apply_single_qubit_gate(X, target_qubit)\n\n    def cnot(self, control_qubit: int, target_qubit: int):\n        \"\"\"Applies a CNOT gate.\"\"\"\n        self._apply_cnot_gate(control_qubit, target_qubit)\n\n    def get_prob(self, index: int) -> float:\n        \"\"\"Returns the probability of measuring the state at a given index.\"\"\"\n        amplitude = self.state_vector[index]\n        return np.abs(amplitude)**2\n\n    def get_result(self, prob_index: int, circuit_depth: int) -> list:\n        \"\"\"Formats the result for a given test case.\"\"\"\n        prob = self.get_prob(prob_index)\n        return [\n            prob,\n            self.op_counts['complex_mult'],\n            self.op_counts['complex_add'],\n            self.op_counts['swap_assign'],\n            self.n,\n            circuit_depth\n        ]\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the final result.\n    \"\"\"\n    n_qubits = 3\n    prob_idx_111 = 7  # Index for |111> is 4*1 + 2*1 + 1*1 = 7\n\n    all_results = []\n\n    # Case A: Empty circuit\n    sim_a = QuantumCircuitSimulator(n_qubits)\n    depth_a = 0\n    all_results.append(sim_a.get_result(prob_idx_111, depth_a))\n\n    # Case B: Uniform superposition\n    sim_b = QuantumCircuitSimulator(n_qubits)\n    sim_b.h(0)\n    sim_b.h(1)\n    sim_b.h(2)\n    depth_b = 3\n    all_results.append(sim_b.get_result(prob_idx_111, depth_b))\n\n    # Case C: GHZ state\n    sim_c = QuantumCircuitSimulator(n_qubits)\n    sim_c.h(0)\n    sim_c.cnot(0, 1)\n    sim_c.cnot(1, 2)\n    depth_c = 3\n    all_results.append(sim_c.get_result(prob_idx_111, depth_c))\n\n    # Case D: Involution\n    sim_d = QuantumCircuitSimulator(n_qubits)\n    sim_d.x(2)\n    sim_d.x(2)\n    depth_d = 2\n    all_results.append(sim_d.get_result(prob_idx_111, depth_d))\n    \n    # Format the final list of lists into a single string.\n    results_str_list = []\n    for res in all_results:\n        # Format each inner list without spaces. e.g. [0.0,0,0,0,3,0]\n        inner_str = f\"[{','.join(map(str, res))}]\"\n        results_str_list.append(inner_str)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "量子计算机并非在所有问题上都更快；它们的威力仅限于具有特定结构的问题。这个练习  挑战您批判性地分析不同的搜索场景，并判断量子方法是否比最优的经典方法具有真正的渐进优势。理解这种差异是识别量子算法有前途的应用并避免常见误解的关键，它强调了算法设计中“结构”的重要性。",
            "id": "3242071",
            "problem": "考虑以下搜索模型和数据结构情境。假设所有算法都在查询（预言机）模型中运行，其中成本主要由对代表数据结构访问原语的黑盒函数的查询次数决定，而算术和控制开销与查询相比可以忽略不计。您可以使用的基本知识包括：用于基于比较的算法的决策树模型；黑盒相等性测试和比较的查询复杂度的定义；以及一个经过充分检验的事实，即对有序集合的二分搜索使用比较来将搜索空间减半，以及量子振幅放大可以将无结构搜索中找到一个标记项所需的查询次数实现平方级减少。设 $n$ 表示存储的元素数量。在每种情境中，预言机提供适合所描述数据结构的标准原语。\n\n选择所有正确的陈述。\n\nA. 未经预处理的无序数组成员资格。数据是一个数组 $A[0], A[1], \\dots, A[n-1]$，不保证有序。唯一允许的预言机是相等性测试，即在输入 $i$ 时返回 $A[i]$ 是否等于给定的目标键 $x$。在黑盒模型中，任何经典随机算法，当存在这样一个索引 $i$ 使得 $A[i] = x$ 时，要在最坏情况下找到它，必须进行 $\\Omega(n)$ 次预言机查询（在标记索引服从均匀先验的期望情况下也是如此），而使用振幅放大的量子算法可以用 $O(\\sqrt{n})$ 次预言机查询以恒定的成功概率找到这样的 $i$。\n\nB. 基于比较的有序数组搜索。数据是一个已排序的数组 $A[0] \\leq A[1] \\leq \\dots \\leq A[n-1]$。唯一允许的预言机是比较操作，即在输入 $i$ 时，报告对于给定的查询键 $x$ 是否有 $A[i] \\leq x$（假设需要时可通过两次比较推断相等性）。通过利用索引上的叠加态，量子算法可以实现 $o(\\log n)$ 次比较来确定 $x$ 是否在 $A$ 中，从而在渐进意义上改进了经典的二分搜索。\n\nC. 基于比较的平衡二叉搜索树前驱/成员资格。数据存储在一个平衡二叉搜索树中，其结构是未知的；唯一允许的预言机是比较操作，即在输入一个节点的键 $k$ 时，报告对于给定的查询键 $x$ 是否有 $k \\leq x$。在这个比较决策树模型中，任何量子算法在最坏情况下对成员资格或前驱查询都需要 $\\Theta(\\log n)$ 次比较，这与经典的渐进行为在常数因子内是匹配的。\n\nD. 使用完美哈希的无序集合。数据是一个包含 $n$ 个键的无序集合 $S$，它已被预处理成一个完美哈希表，因此对于任何查询键 $x$，在字-RAM模型中，单次探查可在 $O(1)$ 时间内回答 $x \\in S$ 是否成立，在预言机模型中，单次查询可在 $O(1)$ 内返回成员资格。在这种情况下，量子算法对成员资格查询不提供渐进加速；经典和量子的查询复杂度在最坏情况下都是 $O(1)$。",
            "solution": "问题要求评估关于经典和量子算法在各种搜索问题上的查询复杂度的四个陈述。计算模型是查询（预言机）模型，其中成本由预言机调用的次数来衡量。提供的基本事实是经典决策树模型、查询复杂度的定义、二分搜索的性能为 $O(\\log n)$，以及量子振幅放大为无结构搜索带来的平方级加速。设 $n$ 为元素数量。\n\n**陈述 A：未经预处理的无序数组成员资格。**\n\n该情境描述了典型的无结构搜索问题。我们有一个包含 $n$ 个项的数组 $A$，以及一个预言机，对于给定的索引 $i$，它会检查 $A[i]$ 是否等于目标键 $x$。\n\n*   **经典复杂度：** 对于确定性算法，在最坏情况下，目标元素是最后一个被检查的，或者根本不在数组中。这需要 $n$ 次查询才能保证得到正确答案。对于随机算法，对手可以自适应地决定标记项的位置。为了达到恒定的成功概率 $p$，算法必须查询相当大一部分索引。任何经典随机算法（即使有界错误）的查询次数下界是 $\\Omega(n)$。如果假设单个标记项位于一个均匀随机选择的位置，找到它的期望查询次数是 $\\frac{n+1}{2}$，属于 $\\Omega(n)$。因此，关于任何经典随机算法在最坏情况和期望情况下都需要 $\\Omega(n)$ 次预言机查询的说法是正确的。\n\n*   **量子复杂度：** 这正是 Grover 算法解决的问题，该算法是振幅放大的一个应用。给定一个能在 $n$ 种可能性中识别“标记”项的预言机，Grover 算法可以用 $O(\\sqrt{n})$ 次查询以高概率找到该项。该陈述声称量子算法可以用 $O(\\sqrt{n})$ 次预言机查询以恒定的成功概率找到索引。这是量子计算中的一个基本结果。\n\n*   **结论：** 该陈述准确地将无结构搜索的 $\\Omega(n)$ 经典查询复杂度与 $O(\\sqrt{n})$ 量子查询复杂度进行了对比。该陈述是**正确的**。\n\n**陈述 B：基于比较的有序数组搜索。**\n\n该情境描述了在已排序数组中搜索，这是一个结构化问题。预言机在给定索引 $i$ 时执行一次比较，报告 $A[i] \\leq x$ 是否成立。\n\n*   **经典复杂度：** 最优的经典算法是二分搜索。通过重复查询当前搜索区间的中间位置，它每次比较都将可能性的数量减半。查询次数是 $O(\\log n)$。决策树复杂度的标准结果表明，任何基于比较的经典搜索算法在最坏情况下都需要 $\\Omega(\\log n)$ 次比较。\n\n*   **量子复杂度：** 该陈述声称量子算法可以达到 $o(\\log n)$ 的复杂度，意味着对二分搜索有渐进的改进。这是不正确的。虽然量子算法可以在 $O(\\sqrt{N})$ 时间内搜索一个大小为 $N$ 的无结构列表，但如果天真地将其应用于已排序的数组，会得到 $O(\\sqrt{n})$ 的复杂度，对于大的 $n$ 来说，这在渐进意义上比经典的 $O(\\log n)$ 更差。问题的结构（即有序性）是关键。搜索已排序列表的量子查询复杂度已被证明是 $\\Theta(\\log n)$。这意味着量子计算机对于这个特定问题没有提供渐进加速。量子算法的 $\\Omega(\\log n)$ 下界表明，即使在量子计算环境中，经典的二分搜索在渐进意义上也是最优的。这个问题的结构在本质上是序贯的，这阻碍了 Grover 算法的大规模并行性充分发挥作用。\n\n*   **结论：** 声称存在一个 $o(\\log n)$ 的量子算法是错误的。量子查询复杂度是 $\\Theta(\\log n)$，这并不是对经典 $O(\\log n)$ 的渐进改进。该陈述是**不正确的**。\n\n**陈述 C：基于比较的平衡二叉搜索树前驱/成员资格。**\n\n这种情境涉及在平衡二叉搜索树（BST）中进行搜索，其中树的结构是不透明的，我们只能通过在节点上进行比较来与其交互。这意味着一个指针追逐模型：我们从根节点开始，进行一次比较，并根据结果决定跟随哪个子指针。这个过程重复进行，直到找到一个叶节点或目标。\n\n*   **经典复杂度：** 在一个有 $n$ 个节点的平衡BST中，高度为 $O(\\log n)$。经典的搜索会遍历一条从根节点开始，深度最多为 $O(\\log n)$ 的路径。在路径上的每个节点，都会进行一次比较。因此，经典的查询复杂度是 $O(\\log n)$。决策树下界也是 $\\Omega(\\log n)$。\n\n*   **量子复杂度：** 这个问题涉及序贯决策。第 $k+1$ 步的查询（即下一个要访问哪个节点）完全依赖于第 $k$ 步查询的结果。这种依赖性阻碍了 Grover 式并行性的简单应用。量子算法不能简单地在叠加态中查询所有节点，因为它在没有首先遍历路径的情况下不知道要查询哪些节点。具有这种指针追逐或决策树结构的问题通常对量子加速具有抵抗力。这类问题的下界，包括评估博弈树或遍历特定图，都证实了量子查询复杂度与路径长度相关。对于平衡BST，这意味着量子查询复杂度也是 $\\Omega(\\log n)$。由于一个模拟经典搜索的算法使用 $O(\\log n)$ 次查询，所以复杂度是 $\\Theta(\\log n)$。\n\n*   **结论：** 该陈述正确地断言量子查询复杂度是 $\\Theta(\\log n)$，与经典情况在常数因子内匹配。没有实现渐进加速。该陈述是**正确的**。\n\n**陈述 D：使用完美哈希的无序集合。**\n\n这种情境假定数据已被预处理成一个完美哈希表。这是一个关键细节。完美哈希函数将 $n$ 个键中的每一个映射到表中的一个唯一槽位，对于集合 $S$ 中的键没有碰撞。\n\n*   **预言机模型与复杂度：** 问题陈述，对于任何键 $x$，单次探查（预言机查询）即可回答 $x \\in S$ 是否成立。这就是完美哈希表用于成员资格测试的工作方式的定义。\n*   **经典复杂度：** 给定这个预言机，经典算法进行一次查询来确定成员资格。因此，复杂度是 $O(1)$。\n*   **量子复杂度：** 量子算法也会使用这个预言机。由于问题可以通过单次查询解决，因此不可能在渐进意义上做得更好。任何非平凡问题的最小查询次数是 $\\Omega(1)$。因此，量子查询复杂度也是 $O(1)$。\n*   **加速：** 当量子算法的复杂度，例如 $f_q(n)$，属于 $o(f_c(n))$（其中 $f_c(n)$ 是经典复杂度）时，就出现了渐进加速。在这里，两者都是 $O(1)$。没有渐进加速的空间。\n\n*   **结论：** 基于问题前提中完美的哈希预言机，关于量子算法不提供渐进加速，且经典和量子复杂度均为 $O(1)$ 的陈述是平凡正确的。该陈述是**正确的**。",
            "answer": "$$\\boxed{ACD}$$"
        }
    ]
}