{
    "hands_on_practices": [
        {
            "introduction": "A solid understanding of any data structure begins with its fundamental definition. This exercise challenges you to translate the abstract max-heap property into a concrete algorithm by working directly with the array-based representation of a $d$-ary heap. By determining for which values of the arity $d$ a given sequence forms a valid heap, you will master the critical skill of navigating the tree using index arithmetic, a cornerstone of implementing heap-based algorithms efficiently .",
            "id": "3225715",
            "problem": "You are given several finite sequences of distinct integers. Each sequence represents a permutation and is to be interpreted as the level-order serialization of a rooted tree for a $d$-ary heap, where $d$ is an integer with $d > 1$. A $d$-ary heap is a rooted tree in which each node has at most $d$ children, and the max-heap property requires that for every node, its key is greater than or equal to the keys of all of its children. We work with the standard array representation of a $d$-ary heap using $0$-based indexing: for a node at index $i$, its children occupy indices from $d i + 1$ up to $d i + d$, as long as these indices are within the bounds of the array.\n\nStarting from the foundational definitions of rooted trees, level-order serialization, and the max-heap property, determine, for each given sequence $A$ of length $n$, the set of all integers $d$ such that $2 \\le d \\le n$ and interpreting $A$ as a $d$-ary heap in level-order satisfies the max-heap property throughout the entire tree. The interpretation must use the parent-child relation defined by indices: for each index $i$ with $0 \\le i \\le n-1$, the children indices are $j \\in \\{d i + 1, d i + 2, \\dots, d i + d\\}$ with $j  n$, and the max-heap property requires $A[i] \\ge A[j]$ for all such $j$.\n\nYour program must process the following test suite of sequences, each of which is a permutation of $\\{1,2,\\dots,n\\}$ for its respective $n$:\n\n- Test case 1: $[1, 2, 3, 4, 5, 6, 7]$\n- Test case 2: $[7, 6, 5, 4, 3, 2, 1]$\n- Test case 3: $[9, 1, 8, 7, 2, 3, 4, 5, 6]$\n- Test case 4: $[9, 7, 8, 3, 5, 6, 2, 1, 4]$\n- Test case 5: $[2, 1]$\n- Test case 6: $[8, 5, 7, 4, 6, 3, 2, 1]$\n\nFor each test case, you must return the list of all integers $d$ with $2 \\le d \\le n$ such that the sequence is a valid max $d$-ary heap under the array-to-tree interpretation described above. If no such $d$ exists, return the empty list.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of integers without spaces, in ascending order for each test case (e.g., $[[2,3],[],[5]]$ for three test cases). Concretely, the printed format must be a single line like $[[2,3],[],[5]]$ for three test cases.\n\nNo physical units or angle units apply. All answers are integer lists as specified. The input is fixed; do not read from standard input.",
            "solution": "The problem requires us to determine, for a given sequence of integers $A$ of length $n$, the set of all integers $d$ within the range $2 \\le d \\le n$ for which $A$ constitutes a valid max $d$-ary heap. The validation must adhere to the specific parent-child indexing relationship provided.\n\nLet us begin from first principles. A sequence $A$ is interpreted as the level-order serialization of a rooted tree. In the standard array representation of a $d$-ary heap with $0$-based indexing, a node at index $i$ has its children located at indices $di+1, di+2, \\dots, di+d$. A child at index $j$ is part of the tree structure only if its index is within the bounds of the array, i.e., $j  n$.\n\nThe max-heap property dictates that for any node in the tree, its key must be greater than or equal to the keys of all its children. Translating this to the array representation, for any parent node at index $i$, and for any of its children at a valid index $j$, the condition $A[i] \\ge A[j]$ must be satisfied.\n\nTo solve the problem, we must construct an algorithm that verifies this property for a given sequence $A$ and a given arity $d$. A systematic approach is to iterate through all nodes that could be parents and check the heap property against all their existing children.\n\nFirst, we must identify which nodes in the array can be parents. A node at index $i$ is a parent if it has at least one child within the array bounds. The index of the first child of node $i$ is $di+1$. For this child to exist, we require $di+1  n$. This inequality can be rearranged to $di  n-1$, which implies $i  (n-1)/d$. Since indices must be integers, the largest possible index for a parent node is $\\lfloor (n-2)/d \\rfloor$. Therefore, we only need to check the heap property for nodes with indices $i$ in the range $0 \\le i \\le \\lfloor (n-2)/d \\rfloor$. Nodes with indices greater than this are guaranteed to be leaves, as their first potential child would lie at or beyond index $n$.\n\nThis leads to a direct verification algorithm, let us call it `is_valid_heap(A, d)`. This function will iterate through all potential parent indices $i$ from $0$ to $\\lfloor (n-2)/d \\rfloor$. For each parent $i$, it will then iterate through its potential children. The indices of the children of node $i$ are given by $j = di+k$ for $k=1, 2, \\dots, d$. For each potential child index $j$, we first check if it is within the array bounds ($j  n$). If it is, we then verify the max-heap condition: $A[i] \\ge A[j]$. If at any point we find a pair $(i, j)$ such that $A[i]  A[j]$, the max-heap property is violated, and the sequence $A$ is not a valid max $d$-ary heap. In this case, our function can immediately return `False`. If the loops complete without finding any such violation, it means the property holds for all parent-child pairs, and the function correctly returns `True`. If the array has length $n \\le 1$, it is trivially a valid heap for any $d$, as there are no parent-child relationships to check.\n\nThe main problem is to find all valid values of $d$ for each given sequence $A$. We can achieve this by iterating through every integer $d$ in the specified range, $2 \\le d \\le n$. For each $d$, we invoke our verification function `is_valid_heap(A, d)`. If it returns `True`, we add $d$ to a list of valid arities for sequence $A$. After checking all possible values of $d$, this list will contain the complete solution for that sequence.\n\nThis procedure is repeated for each test case sequence provided in the problem statement. The final output is an aggregation of these results into a single formatted list.\n\nThe overall algorithm is as follows:\n1. For each input sequence $A$:\n2. Let $n$ be the length of $A$.\n3. Initialize an empty list, `valid_ds`, to store the valid arities.\n4. For each integer $d$ from $2$ to $n$ (inclusive):\n5.  a. Assume $A$ is a valid max $d$-ary heap (set a flag, e.g., `is_heap = True`).\n6.  b. Iterate through each potential parent index $i$ from $0$ to $\\lfloor (n-2)/d \\rfloor$.\n7.  c. For each parent $i$, iterate through its child indices $j = di+k$ where $k=1, 2, \\dots, d$.\n8.  d. If a child index $j$ is out of bounds ($j \\ge n$), we can break the inner loop over $k$ since subsequent child indices will also be out of bounds.\n9.  e. If $j  n$ and $A[i]  A[j]$, the heap property is violated. Set `is_heap = False` and break from all loops for the current $d$.\n10. f. After checking all parents for the current $d$, if `is_heap` is still `True`, append $d$ to `valid_ds`.\n11. After iterating through all $d$, the list `valid_ds` contains the result for sequence $A$.\n12. Collect the `valid_ds` lists from all test cases and format them according to the output specification.\nThis method is exhaustive and guarantees correctness by directly checking the definition of a max $d$-ary heap for every possibility.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the d-ary heap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        [1, 2, 3, 4, 5, 6, 7],\n        [7, 6, 5, 4, 3, 2, 1],\n        [9, 1, 8, 7, 2, 3, 4, 5, 6],\n        [9, 7, 8, 3, 5, 6, 2, 1, 4],\n        [2, 1],\n        [8, 5, 7, 4, 6, 3, 2, 1],\n    ]\n\n    def is_d_ary_max_heap(A, d):\n        \"\"\"\n        Checks if a sequence A represents a valid max d-ary heap.\n\n        Args:\n            A (list): The sequence of integers.\n            d (int): The arity to check.\n\n        Returns:\n            bool: True if A is a valid max d-ary heap, False otherwise.\n        \"\"\"\n        n = len(A)\n        if n = 1:\n            return True\n\n        # The last parent node is at index floor((n-2)/d).\n        # We need to iterate i from 0 up to and including this index.\n        # The range is thus 0 to floor((n-2)/d) + 1.\n        num_parents = (n - 2) // d + 1\n\n        for i in range(num_parents):\n            parent_val = A[i]\n            \n            # Iterate through children\n            for k in range(1, d + 1):\n                child_idx = d * i + k\n                \n                if child_idx  n:\n                    child_val = A[child_idx]\n                    if parent_val  child_val:\n                        return False\n                else:\n                    # Since child indices are consecutive, if one is out of bounds,\n                    # the rest will be too. We can break the inner loop.\n                    break\n        \n        return True\n\n    all_results = []\n    for A in test_cases:\n        n = len(A)\n        valid_ds = []\n        # Per the problem, d must be an integer with d > 1.\n        # The search space is given as 2 = d = n.\n        if n > 1:\n            for d in range(2, n + 1):\n                if is_d_ary_max_heap(A, d):\n                    valid_ds.append(d)\n        all_results.append(valid_ds)\n\n    # Format the output string exactly as required, without spaces.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond understanding the static structure of a heap, it is crucial to analyze the efficiency of the algorithms that operate on it. This practice guides you through a rigorous, first-principles derivation of the worst-case cost of the `build_heap` procedure, a classic algorithm for converting an unordered array into a valid heap. By deriving an exact, closed-form expression for the number of comparisons, you will gain a deep appreciation for why this foundational operation achieves its surprising linear time complexity .",
            "id": "3225640",
            "problem": "You are given a $d$-ary max-heap, where $d \\ge 2$, stored in a contiguous array using $0$-based indexing. For each index $i$, its children are the indices $d i + 1, d i + 2, \\ldots, d i + d$ that are still within the array bounds. Consider the bottom-up heap construction procedure (often called Floyd's build-heap): starting from the last internal node down to the root, each node $i$ is subjected to a sift-down that repeatedly replaces the key at $i$ with the larger among its children if that child is larger than the key. The sift-down at a node $i$ proceeds level by level until the key reaches a position where all existing children are smaller or it reaches a leaf. Use the following cost model:\n\n- Each comparison between two keys costs $1$.\n- At any node with $k$ existing children, determining the maximum child costs exactly $k - 1$ comparisons.\n- After selecting the maximum child, comparing the current key against that child costs exactly $1$ comparison.\n\nAssume the input size $n$ equals the number of nodes in a complete $d$-ary tree of height $H \\ge 1$ with the last level completely full, namely \n$$\nn \\;=\\; \\frac{d^{H+1} - 1}{d - 1}.\n$$\nIn the worst case for this build-heap procedure (that is, every sift-down descends to the leaf level), derive from first principles an exact closed-form expression, in terms of $n$ and $d$ only, for the total number of key comparisons performed by the entire build-heap. Your final answer must be a single closed-form analytic expression in $n$ and $d$ (no unevaluated sums or limits). Do not approximate or round.",
            "solution": "The problem asks for the total number of key comparisons in the worst-case scenario of a bottom-up $d$-ary heap construction for a complete $d$-ary tree with $n$ nodes, where the last level is full.\n\nFirst, let's establish the structure of the tree and the algorithm's cost model as specified.\n\nThe tree is a complete $d$-ary tree of height $H \\ge 1$, with the root at level $h=0$ and leaves at level $h=H$. The number of nodes at any level $h$ is $d^h$. The total number of nodes $n$ is the sum of nodes at all levels from $0$ to $H$:\n$$n = \\sum_{h=0}^{H} d^h = \\frac{d^{H+1} - 1}{d - 1}$$\nThis matches the given formula for $n$.\n\nThe build-heap algorithm iterates through all internal nodes, from the last one up to the root. For this problem, the internal nodes are all nodes that are not leaves, which are the nodes at levels $h=0, 1, \\ldots, H-1$. For each internal node, it performs a sift-down operation.\n\nThe cost of a single sift-down operation from a node $i$ is determined by the number of comparisons. The problem defines a worst-case scenario where the key at node $i$ is sifted all the way down to a leaf. The number of levels the key descends is equal to the height of the node $i$. The height of a node at level $h$ is $H-h$.\n\nAt each step of the sift-down, the key at a temporary node is compared with its children. Since the tree is complete and the last level is full, any node on a sift-down path (which is not a leaf) will have exactly $d$ children. The cost model specifies:\n1.  Finding the maximum among the $d$ children costs $d-1$ comparisons.\n2.  Comparing the current key with this maximum child costs $1$ comparison.\n\nThus, each level of descent in a sift-down costs $(d-1) + 1 = d$ comparisons.\nFor a node at level $h$, its height is $H-h$. The worst-case sift-down from this node involves $H-h$ descent steps. The total cost for sifting down one node at level $h$ is therefore $d \\times (H-h)$.\n\nThe total number of comparisons, $C$, for the entire build-heap procedure is the sum of the costs for sifting down all internal nodes.\n$$C = \\sum_{\\text{internal nodes } i} (\\text{cost to sift-down } i)$$\nWe can group the nodes by their level $h$. There are $d^h$ nodes at level $h$. The internal nodes are at levels $h=0, 1, \\ldots, H-1$.\n$$C = \\sum_{h=0}^{H-1} (\\text{number of nodes at level } h) \\times (\\text{cost for a node at level } h)$$\n$$C = \\sum_{h=0}^{H-1} d^h \\cdot [d(H-h)] = d \\sum_{h=0}^{H-1} d^h(H-h)$$\n\nThe sum $\\sum_{h=0}^{H-1} d^h(H-h)$ represents the sum of heights of all internal nodes. Since leaf nodes (at level $H$) have a height of $H-H=0$, this sum is equivalent to the sum of heights of all nodes in the tree. Let this sum be $S_{H}$.\n$$S_H = \\sum_{h=0}^{H} d^h(H-h)$$\nLet's evaluate this sum from first principles. We can split the sum:\n$$S_H = H \\sum_{h=0}^{H} d^h - \\sum_{h=0}^{H} h d^h$$\nThe first term contains a standard geometric series:\n$$H \\sum_{h=0}^{H} d^h = H \\left(\\frac{d^{H+1}-1}{d-1}\\right) = Hn$$\nThe second term is an arithmetic-geometric series, $A_H = \\sum_{h=0}^{H} h d^h = \\sum_{h=1}^{H} h d^h$. We can evaluate this series using a well-known technique involving derivatives of a geometric series. Let $G(x) = \\sum_{h=0}^{H} x^h = \\frac{x^{H+1}-1}{x-1}$.\nThen $\\sum_{h=0}^{H} h x^h = x \\frac{d}{dx}G(x)$.\n$$\\frac{dG(x)}{dx} = \\frac{(H+1)x^H(x-1) - (x^{H+1}-1)(1)}{(x-1)^2} = \\frac{(H+1)x^{H+1} - (H+1)x^H - x^{H+1} + 1}{(x-1)^2} = \\frac{Hx^{H+1} - (H+1)x^H + 1}{(x-1)^2}$$\nMultiplying by $x$ and setting $x=d$:\n$$A_H = \\sum_{h=1}^{H} h d^h = d \\frac{Hd^{H+1} - (H+1)d^H + 1}{(d-1)^2} = \\frac{Hd^{H+2} - (H+1)d^{H+1} + d}{(d-1)^2}$$\nNow, substitute this back into the expression for $S_H$:\n$$S_H = Hn - A_H = H\\frac{d^{H+1}-1}{d-1} - \\frac{Hd^{H+2} - (H+1)d^{H+1} + d}{(d-1)^2}$$\nTo combine these terms, we place them over a common denominator $(d-1)^2$:\n$$S_H = \\frac{H(d^{H+1}-1)(d-1) - [Hd^{H+2} - (H+1)d^{H+1} + d]}{(d-1)^2}$$\nLet's expand the numerator:\n$$\n\\begin{align*}\n\\text{Numerator} = H(d^{H+2} - d^{H+1} - d + 1) - Hd^{H+2} + (H+1)d^{H+1} - d \\\\\n= Hd^{H+2} - Hd^{H+1} - Hd + H - Hd^{H+2} + Hd^{H+1} + d^{H+1} - d \\\\\n= d^{H+1} - Hd + H - d \\\\\n= d^{H+1} - H(d-1) - d\n\\end{align*}\n$$\nSo, the sum of heights is:\n$$S_H = \\frac{d^{H+1} - H(d-1) - d}{(d-1)^2}$$\nWe can simplify this expression by substituting the relation for $n$. From $n = \\frac{d^{H+1}-1}{d-1}$, we have $d^{H+1} = n(d-1)+1$.\n$$S_H = \\frac{(n(d-1)+1) - H(d-1) - d}{(d-1)^2} = \\frac{n(d-1) - H(d-1) - (d-1)}{(d-1)^2} = \\frac{(n - H - 1)(d-1)}{(d-1)^2} = \\frac{n-H-1}{d-1}$$\nThe total number of comparisons is $C = d \\cdot S_H$.\n$$C = d \\left(\\frac{n-H-1}{d-1}\\right)$$\nThe final step is to express $H$ in terms of $n$ and $d$. From $d^{H+1} = n(d-1)+1$, we take the logarithm base $d$ of both sides:\n$$\\log_d(d^{H+1}) = \\log_d(n(d-1)+1)$$\n$$H+1 = \\log_d(n(d-1)+1)$$\n$$H = \\log_d(n(d-1)+1) - 1$$\nSubstituting this expression for $H$ into our formula for $C$:\n$$C = \\frac{d}{d-1} \\left( n - \\left( \\log_d(n(d-1)+1) - 1 \\right) - 1 \\right)$$\n$$C = \\frac{d}{d-1} \\left( n - \\log_d(n(d-1)+1) + 1 - 1 \\right)$$\n$$C = \\frac{d}{d-1} \\left( n - \\log_d(n(d-1)+1) \\right)$$\nThis is the final closed-form expression for the total number of comparisons in terms of $n$ and $d$.",
            "answer": "$$ \\boxed{ \\frac{d\\left(n - \\log_{d}\\left(n(d-1)+1\\right)\\right)}{d-1} } $$"
        },
        {
            "introduction": "The true power of the $d$-ary heap lies in its flexibility, but this introduces an important engineering question: what is the best choice for the arity $d$? This problem moves from pure theory to practical performance modeling, where you will develop a cost function that abstracts machine-specific characteristics and workload patterns. By implementing a program to find the optimal $d$ that minimizes this cost, you will directly engage with the central trade-off of the $d$-ary heap—balancing tree height against the work done at each node—and learn how to tune data structures to meet real-world performance goals .",
            "id": "3225717",
            "problem": "You are to design and implement a complete, runnable program that, given a set of machine-specific cost parameters and workload weights, selects the arity $d$ of a $d$-ary heap that minimizes a worst-case, primitive-operation cost model. The goal is to emulate an empirical study in a controlled, reproducible way by using a principled cost model that abstracts the effects of the Central Processing Unit (CPU), cache hierarchy, and Random Access Memory (RAM) bandwidth into primitive operation costs. Your program must not perform any timing measurements; instead, it must use a derived analytic model grounded in standard definitions to compute the minimizing $d$.\n\nFundamental base to use:\n- A $d$-ary heap is a complete tree stored in an array in level order. The height is the smallest integer $L$ such that a tree with branching factor $d$ and height $L$ can hold at least $n$ nodes. Equivalently, $L$ is the minimal integer satisfying $d^{L} \\ge n$, which implies $L = \\lceil \\log_{d} n \\rceil$ for $n \\ge 1$.\n- The parent of a node at index $i$ (using zero-based indexing) is at index $\\left\\lfloor \\dfrac{i-1}{d} \\right\\rfloor$, and its children are at indices $d\\cdot i + j$ for $j \\in \\{1,2,\\dots,d\\}$ when those indices exist within the array.\n- Operation semantics for the standard priority queue built from a $d$-ary min-heap:\n  - Decrease-key and insert both potentially move a key upward by repeatedly comparing with its parent and swapping until the heap property is restored. In the worst case, the number of upward moves equals the height $L$.\n  - Extract-min removes the root, swaps in a last element, and then restores the heap by repeatedly selecting the smallest child among up to $d$ children and swapping downward until the heap property is restored. In the worst case, the number of downward moves equals the height $L$.\n\nCost model to use:\n- Count only two primitive costs:\n  - $c_{c}$: the cost per key comparison.\n  - $c_{s}$: the cost per swap of two keys (treat a swap as a single primitive with this cost; internal assignments and memory traffic are abstracted into $c_{s}$).\n- Worst-case primitive counts per operation, justified by the operation semantics:\n  - Insert and decrease-key: at most $L$ levels traversed upward, performing at most $L$ comparisons and $L$ swaps.\n  - Extract-min: one fixed swap to remove the root and place the last element at the root, plus at most $L$ levels traversed downward. At each level, selecting the smallest child among up to $d$ children performs at most $d-1$ comparisons, followed by one swap to move the hole downward.\n- Workload model:\n  - Let $w_{\\mathrm{ex}}$, $w_{\\mathrm{in}}$, and $w_{\\mathrm{dec}}$ be nonnegative weights indicating the relative frequency of extract-min, insert, and decrease-key respectively. You may assume $w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} > 0$.\n  - The worst-case weighted cost per operation for a given $d$ is the weighted sum of the corresponding primitive counts times primitive costs.\n\nTasks:\n- Using only the fundamental base above and worst-case reasoning, derive an expression for the worst-case weighted cost per operation as a function of $d$, $n$, $c_{c}$, $c_{s}$, $w_{\\mathrm{ex}}$, $w_{\\mathrm{in}}$, and $w_{\\mathrm{dec}}$. The derivation must proceed from the stated semantics. Do not assume any average-case behavior.\n- Implement a program that:\n  - For each test case, considers all integer $d$ in the inclusive range $[2, d_{\\max}]$.\n  - Computes the heap height $L(d,n) = \\lceil \\log_{d} n \\rceil$ with the convention that $L(d,1) = 0$.\n  - Computes the worst-case weighted cost for that $d$ using your derived counts and the provided primitive costs and weights.\n  - Selects the $d$ that minimizes this cost. In case of a tie, choose the smallest $d$.\n  - Outputs the selected $d$ for each test case.\n- Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nTest suite:\n- Each test case is a tuple $(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$ with the following specific values. All numbers are exact and unitless.\n  - Case 1: $(n=1, w_{ex}=1.0, w_{in}=0.0, w_{dec}=0.0, c_{c}=5.0, c_{s}=10.0, d_{max}=16)$\n  - Case 2: $(n=1000000, w_{ex}=0.6, w_{in}=0.3, w_{dec}=0.1, c_{c}=3.0, c_{s}=8.0, d_{max}=32)$\n  - Case 3: $(n=1000000, w_{ex}=0.8, w_{in}=0.1, w_{dec}=0.1, c_{c}=50.0, c_{s}=5.0, d_{max}=16)$\n  - Case 4: $(n=5000000, w_{ex}=0.2, w_{in}=0.6, w_{dec}=0.2, c_{c}=2.0, c_{s}=40.0, d_{max}=64)$\n  - Case 5: $(n=1000, w_{ex}=1.0, w_{in}=0.0, w_{dec}=0.0, c_{c}=1.0, c_{s}=1.0, d_{max}=2)$\n\nAnswer specification:\n- Your program must compute the minimizing $d$ for each of the five cases above and print them in order as a single line in the exact specified format.",
            "solution": "The user has requested the design of a program to find the optimal arity $d$ for a $d$-ary heap that minimizes a worst-case operational cost model. The process begins with a formal validation of the problem statement, followed by the derivation of the cost function and its implementation.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Heap Structure**: A $d$-ary heap is a complete tree stored in an array.\n*   **Heap Height ($L$)**: $L = \\lceil \\log_{d} n \\rceil$ for $n \\ge 1$. A special convention is given: $L(d, 1) = 0$.\n*   **Parent/Child Indices (0-based)**: Parent of node $i$ is $\\lfloor(i-1)/d\\rfloor$. Children are $d \\cdot i + j$ for $j \\in \\{1, 2, \\dots, d\\}$.\n*   **Operation Semantics (Worst-Case)**:\n    *   `insert` / `decrease-key`: $L$ comparisons and $L$ swaps.\n    *   `extract-min`: $1$ fixed swap, plus $L$ downward steps. Each downward step involves at most $d-1$ comparisons and $1$ swap.\n*   **Cost Primitives**:\n    *   $c_c$: cost per key comparison.\n    *   $c_s$: cost per key swap.\n*   **Workload Model**:\n    *   $w_{\\mathrm{ex}}$, $w_{\\mathrm{in}}$, $w_{\\mathrm{dec}}$: nonnegative weights for `extract-min`, `insert`, and `decrease-key` operations, with $w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} > 0$.\n*   **Objective**: For each test case, find the integer $d \\in [2, d_{\\max}]$ that minimizes the worst-case weighted cost. Ties are broken by choosing the smallest $d$.\n*   **Test Suite**: Five test cases are provided with specific values for $(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is analyzed against the validation criteria.\n\n*   **Scientifically Grounded**: The problem is based on the standard and well-established data structure of a $d$-ary heap. The cost model is a common and valid abstraction used in algorithm analysis to model performance without direct machine timing. It is scientifically and algorithmically sound.\n*   **Well-Posed**: The problem is clearly defined. The objective is to find the minimum of a function over a finite, discrete domain of integers $d \\in [2, d_{\\max}]$. A minimum is guaranteed to exist. The tie-breaking rule (select the smallest $d$) ensures a unique solution.\n*   **Objective**: The language is precise and mathematical. All parameters and constraints are defined quantitatively.\n*   **Completeness and Consistency**: The problem provides all necessary data and definitions to derive the cost function and perform the required search. The convention for $n=1$ is explicitly stated, avoiding ambiguity. There are no contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is self-contained, scientifically grounded, well-posed, and all necessary information for its resolution is provided. The solution process may proceed.\n\n### Derivation of the Worst-Case Weighted Cost Function\n\nThe objective is to derive the total worst-case weighted cost per operation, denoted $C(d)$, as a function of the arity $d$ and the given parameters. This derivation follows directly from the primitive operation costs specified in the problem statement.\n\n1.  **Heap Height**: The height of the heap for $n$ elements and arity $d$ is given by $L(d, n) = \\lceil \\log_{d} n \\rceil$. For the special case $n=1$, $L(d, 1) = \\lceil \\log_{d} 1 \\rceil = \\lceil 0 \\rceil = 0$, which aligns with the provided convention.\n\n2.  **Cost of Individual Operations**: We determine the worst-case cost for each operation type by summing the costs of its constituent primitive operations (comparisons and swaps).\n\n    *   **Insert and Decrease-Key**: The problem states that in the worst case, an element moves up the entire height of the tree. This involves $L(d, n)$ levels. At each level, one comparison with the parent and one swap occurs.\n        The cost for an `insert` operation, $C_{\\mathrm{in}}(d)$, is:\n        $$C_{\\mathrm{in}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n        Similarly, the cost for a `decrease-key` operation, $C_{\\mathrm{dec}}(d)$, is:\n        $$C_{\\mathrm{dec}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n\n    *   **Extract-Min**: This operation consists of two phases. First, the root is replaced by the last element in the heap, costing one swap. Second, the new root element \"sifts down\" to restore the heap property. This downward traversal covers at most $L(d, n)$ levels. At each level, the element is compared with its up to $d$ children to find the minimum, which requires at most $d-1$ comparisons. Then, a single swap is performed with the minimum child.\n        The cost for an `extract-min` operation, $C_{\\mathrm{ex}}(d)$, is the sum of the initial swap and the sift-down process:\n        $$C_{\\mathrm{ex}}(d) = (1 \\cdot c_s) + L(d, n) \\cdot ((d-1) \\cdot c_c + 1 \\cdot c_s)$$\n        $$C_{\\mathrm{ex}}(d) = c_s + L(d, n) ((d-1)c_c + c_s)$$\n\n3.  **Total Weighted Cost Function**: The total worst-case weighted cost, $C(d)$, is the sum of the costs of each operation multiplied by their respective weights.\n    $$C(d) = w_{\\mathrm{ex}} \\cdot C_{\\mathrm{ex}}(d) + w_{\\mathrm{in}} \\cdot C_{\\mathrm{in}}(d) + w_{\\mathrm{dec}} \\cdot C_{\\mathrm{dec}}(d)$$\n    Substituting the expressions derived above:\n    $$ C(d) = w_{\\mathrm{ex}} \\left(c_s + L(d, n) ((d-1)c_c + c_s)\\right) + w_{\\mathrm{in}} \\left(L(d, n) (c_c + c_s)\\right) + w_{\\mathrm{dec}} \\left(L(d, n) (c_c + c_s)\\right) $$\n    We can factor out $L(d, n)$ to simplify the expression:\n    $$ C(d) = w_{\\mathrm{ex}} c_s + L(d, n) \\left[ w_{\\mathrm{ex}} ((d-1)c_c + c_s) + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})(c_c + c_s) \\right] $$\n    Let's expand and group terms by $c_c$ and $c_s$ inside the brackets:\n    $$ \\left[ w_{\\mathrm{ex}}(d-1)c_c + w_{\\mathrm{ex}}c_s + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_c + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_s \\right] $$\n    $$ = c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) $$\n    This yields the final analytic expression for the total worst-case weighted cost:\n    $$ C(d) = w_{\\mathrm{ex}} c_s + \\lceil \\log_{d} n \\rceil \\left[ c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) \\right] $$\n    This function will be evaluated for each integer $d$ in the range $[2, d_{\\max}]$ to find the value of $d$ that minimizes $C(d)$. The `ceil` of the logarithm, $\\lceil \\log_{d} n \\rceil$, can be computed as `ceil(log(n) / log(d))` using any convenient logarithm base (e.g., natural logarithm).\n\n### Minimization Procedure\n\nFor each test case, we will iterate through all possible integer values of $d$ from $2$ to $d_{\\max}$, inclusive. In each iteration, we calculate the cost $C(d)$ using the derived formula. We maintain a record of the minimum cost found so far and the corresponding value of $d$. If a newly computed cost for a given $d$ is strictly less than the current minimum, we update the minimum cost and the optimal $d$. This process inherently respects the tie-breaking rule of choosing the smallest $d$, as smaller values of $d$ are evaluated first.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal arity 'd' for a d-ary heap for a given set of\n    test cases based on a worst-case operational cost model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (n, w_ex, w_in, w_dec, c_c, c_s, d_max)\n    test_cases = [\n        (1, 1.0, 0.0, 0.0, 5.0, 10.0, 16),\n        (1000000, 0.6, 0.3, 0.1, 3.0, 8.0, 32),\n        (1000000, 0.8, 0.1, 0.1, 50.0, 5.0, 16),\n        (5000000, 0.2, 0.6, 0.2, 2.0, 40.0, 64),\n        (1000, 1.0, 0.0, 0.0, 1.0, 1.0, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, w_ex, w_in, w_dec, c_c, c_s, d_max = case\n\n        min_cost = float('inf')\n        best_d = -1\n\n        # Iterate through all possible arities d from 2 to d_max (inclusive).\n        for d in range(2, d_max + 1):\n            # Calculate heap height L(d, n).\n            # L = ceil(log_d(n)).\n            # Per problem spec, L(d, 1) is 0.\n            if n = 1:\n                L = 0\n            else:\n                # Use numpy for safe floating point logarithm calculation.\n                # np.ceil returns a float, so cast to int.\n                L = int(np.ceil(np.log(n) / np.log(d)))\n\n            # From the derivation, the total weighted cost C(d) is:\n            # C(d) = w_ex * c_s + L * [c_c * (w_ex * (d-1) + w_in + w_dec) + c_s * (w_ex + w_in + w_dec)]\n\n            # Pre-calculate terms for clarity.\n            total_weight = w_ex + w_in + w_dec\n            comparison_workload = w_ex * (d - 1) + w_in + w_dec\n            \n            # Cost from comparisons and swaps during sift-up/sift-down.\n            variable_cost_per_level = c_c * comparison_workload + c_s * total_weight\n            \n            # Total cost is the fixed cost of extract-min plus the height-dependent costs.\n            cost = w_ex * c_s + L * variable_cost_per_level\n\n            # Check if this d yields a new minimum cost.\n            # The problem asks to choose the smallest d in case of a tie.\n            # By using '' and iterating d in increasing order, the first d\n            # that achieves the minimum cost will be selected, fulfilling the tie-breaker rule.\n            if cost  min_cost:\n                min_cost = cost\n                best_d = d\n        \n        results.append(best_d)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}