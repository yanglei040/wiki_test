{
    "hands_on_practices": [
        {
            "introduction": "This practice focuses on a classic dynamic connectivity problem, where you will implement a Disjoint-Set Union (DSU) data structure from scratch. By applying the crucial heuristics of union-by-size and path compression, you will simulate the formation of islands on a grid. This exercise is foundational, as it solidifies your understanding of how DSU efficiently tracks the merging of connected components in real-time. ",
            "id": "3228210",
            "problem": "You are to implement a program that simulates the incremental formation of connected components of land in a grid using the Disjoint-Set Union (DSU) data structure with union-by-size and path compression heuristics. The objective is to compute, after each land addition, the current number of connected components (\"islands\") under $4$-neighborhood adjacency.\n\nFundamental base and definitions:\n- A Disjoint-Set Union (DSU) maintains a partition of a finite universe into disjoint sets and supports two operations: $find(x)$, which returns a canonical representative of the set containing element $x$, and $union(x,y)$, which merges the sets containing $x$ and $y$ if they are distinct.\n- In union-by-size, when merging two sets, the root with smaller size is attached to the root with larger size, ensuring that the tree height grows slowly. In path compression, during $find(x)$, each visited node on the path to the root is directly linked to the root, flattening the structure for future queries.\n- The $4$-neighborhood for a cell at coordinates $(i,j)$ consists of $(i-1,j)$, $(i+1,j)$, $(i,j-1)$, and $(i,j+1)$, restricted to valid grid indices. Two land cells are connected if there is a path through land cells via steps in the $4$-neighborhood. This induces an equivalence relation on the set of land cells, and each equivalence class corresponds to one island.\n\nTask:\n- Consider a grid of $r \\times c$ cells with $r \\in \\mathbb{Z}_{\\ge 0}$ and $c \\in \\mathbb{Z}_{\\ge 0}$, indexed by zero-based coordinates $(i,j)$ with $i \\in \\{0,\\dots,r-1\\}$ and $j \\in \\{0,\\dots,c-1\\}$. Initially, all cells are water.\n- You are given an ordered list of $k$ additions $(p_1, p_2, \\dots, p_k)$, where each $p_t = (i_t, j_t)$ specifies turning the cell at row $i_t$ and column $j_t$ into land at step $t$. If a specified cell is already land, the grid state does not change at that step.\n- After each step $t \\in \\{1,\\dots,k\\}$, compute the number of islands present under $4$-neighborhood connectivity.\n\nRequirements:\n- You must implement Disjoint-Set Union (DSU) with both union-by-size and path compression heuristics.\n- Your algorithm must not assume prior knowledge beyond the fundamental DSU definitions and the connectivity definition given above.\n- The program should not read input. Instead, it must internally run on the following test suite of parameter values (each specified as a tuple $(r,c,\\text{additions})$):\n  - Test case $1$: $(r,c) = (3,3)$, additions $\\left[(0,0),(0,1),(1,2),(2,1),(1,1)\\right]$.\n  - Test case $2$: $(r,c) = (1,1)$, additions $\\left[(0,0),(0,0),(0,0)\\right]$.\n  - Test case $3$: $(r,c) = (2,2)$, additions $\\left[(0,0),(1,1),(0,1),(1,0)\\right]$.\n  - Test case $4$: $(r,c) = (2,3)$, additions $\\left[(0,0),(1,1),(0,2),(1,2)\\right]$.\n  - Test case $5$: $(r,c) = (5,5)$, additions $\\left[\\right]$ (the empty list).\n- For each test case, your program must produce a list of integers of length $k$ (possibly length $0$ for the empty list) where the $t$-th integer is the number of islands after processing the $t$-th addition.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and is itself a list of integers for that test case. For example, the output must have the form $\\left[\\text{case}_1,\\text{case}_2,\\dots,\\text{case}_m\\right]$, where each $\\text{case}_i$ is a list like $\\left[a_1,a_2,\\dots,a_k\\right]$.\n- There are no physical units involved in this problem. All angles, if any, are irrelevant to this problem.",
            "solution": "The problem requires simulating the dynamic formation of connected components in a grid. This is a classic application of the Disjoint-Set Union (DSU) data structure, also known as the Union-Find data structure. The core of the problem is to maintain and query connectivity information as elements (grid cells) are added.\n\n**1. Theoretical Foundation: Dynamic Connectivity and Equivalence Relations**\n\nThe concept of \"islands\" or connected components of land cells is based on an equivalence relation. Two land cells are in the same component if there exists a path of adjacent land cells (under $4$-neighborhood adjacency) connecting them. The DSU data structure is explicitly designed to manage the partitions of a set induced by such an equivalence relation.\n\nA DSU structure on a universe of $N$ elements maintains a collection of disjoint sets. It primarily supports two operations:\n-   `find(x)`: Determines the canonical representative (or \"root\") of the set containing element $x$.\n-   `union(x,y)`: Merges the two sets containing elements $x$ and $y$.\n\nTo achieve near-constant time complexity on an amortized basis, two heuristics are crucial:\n-   **Union-by-Size**: When merging two sets, the root of the smaller set (in terms of the number of elements) is made a child of the root of the larger set. This keeps the trees representing the sets from becoming excessively deep.\n-   **Path Compression**: During a `find(x)` operation, every node on the path from $x$ to its root is made a direct child of the root. This flattens the tree structure, dramatically speeding up future `find` operations for elements in that path.\n\nWhen both heuristics are used, a sequence of $m$ operations on a set of $N$ elements takes $O(m \\cdot \\alpha(N))$ time, where $\\alpha(N)$ is the extremely slow-growing inverse Ackermann function. For all practical purposes, $\\alpha(N)$ is a small constant (less than $5$).\n\n**2. Algorithmic Model**\n\nTo apply the DSU data structure to the grid problem, we must map the grid cells to the elements of the DSU's universe.\n\n-   **Universe Mapping**: A grid of dimensions $r \\times c$ contains $r \\cdot c$ cells. We can map each cell at coordinates $(i,j)$, where $i \\in \\{0, \\dots, r-1\\}$ and $j \\in \\{0, \\dots, c-1\\}$, to a unique integer index. A standard row-major mapping is given by the formula: $\\text{index} = i \\cdot c + j$. This creates a universe of elements $\\{0, 1, \\dots, r \\cdot c - 1\\}$.\n\n-   **State Representation**: We need to manage the state of each cell (water or land) and the DSU data. A `parent` array of size $r \\cdot c$ is used for the DSU. We can use a sentinel value, such as $-1$, to indicate that a cell is water. When a cell at index `idx` becomes land, we initialize its DSU entry, e.g., by setting `parent[idx] = idx`. A `size` array of the same dimension stores the size of each set, which is only meaningful at the set's root.\n\n-   **Component Counting**: The number of islands is precisely the number of disjoint sets of land cells. We maintain a counter, `num_components`.\n    -   When a water cell is turned into land, it initially forms a new island of size $1$. Thus, we increment `num_components`.\n    -   When we perform a `union` operation on two cells that belong to different sets, their respective islands merge. This reduces the total number of islands by one. Therefore, we decrement `num_components` for each successful merge.\n\n**3. Step-by-Step Algorithm**\n\nFor each test case with parameters $(r, c, \\text{additions})$:\n\n1.  **Initialization**:\n    -   If $r=0$ or $c=0$, the grid has no cells. The result is an empty list.\n    -   Create a `parent` array of size $r \\cdot c$, and initialize all its elements to $-1$ to represent water.\n    -   Create a `size` array of size $r \\cdot c$, initialized to $1$.\n    -   Initialize `num_components` to $0$.\n    -   Initialize an empty list `results` to store the island count after each step.\n\n2.  **Process Additions**: Iterate through each coordinate pair $(i_t, j_t)$ in the `additions` list for $t=1, \\dots, k$.\n    a.  Calculate the $1$D index: $\\text{idx}_t = i_t \\cdot c + j_t$.\n    b.  **Check for existing land**: If `parent[idx_t]` is not $-1$, the cell is already land. The number of islands does not change. Append the current `num_components` to the `results` list and proceed to the next addition.\n    c.  **Add new land**: If `parent[idx_t]` is $-1$:\n        i.  Initialize the cell as a new component: set `parent[idx_t] = idx_t`.\n        ii. Increment `num_components` by $1$.\n        iii. **Check Neighbors**: For each of the $4$ neighbors $(n_i, n_j)$ of $(i_t, j_t)$:\n            -   Verify that the neighbor's coordinates are within the grid boundaries ($0 \\le n_i < r$ and $0 \\le n_j < c$).\n            -   Calculate the neighbor's index: $\\text{n_idx} = n_i \\cdot c + n_j$.\n            -   If the neighbor is land (i.e., `parent[n_idx] != -1`), perform a `union` operation on $\\text{idx}_t$ and $\\text{n_idx}$.\n            -   The `union` operation involves finding the roots of both elements using `find` with path compression. Let the roots be `root1` and `root2`.\n            -   If `root1 \\neq root2`, a merge occurs. Implement union-by-size: attach the smaller tree to the root of the larger tree and update the size of the larger tree's root. Critically, decrement `num_components` by $1$.\n    d.  After checking all neighbors, append the final `num_components` value for the current step $t$ to the `results` list.\n\n3.  **Final Result**: After processing all additions, the `results` list contains the required sequence of island counts.\n\n**4. Complexity Analysis**\n\n-   **Time Complexity**: $O(k \\cdot \\alpha(r \\cdot c))$, where $k$ is the number of additions. Each addition involves a constant number of DSU operations (one initialization and up to four `union` operations, each with two `find` calls).\n-   **Space Complexity**: $O(r \\cdot c)$ to store the `parent` and `size` arrays for the DSU structure.\n\nThis approach is highly efficient and correctly models the dynamic process of island formation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation on the provided test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 3, [(0, 0), (0, 1), (1, 2), (2, 1), (1, 1)]),\n        (1, 1, [(0, 0), (0, 0), (0, 0)]),\n        (2, 2, [(0, 0), (1, 1), (0, 1), (1, 0)]),\n        (2, 3, [(0, 0), (1, 1), (0, 2), (1, 2)]),\n        (5, 5, []),\n    ]\n\n    all_results = []\n    for r, c, additions in test_cases:\n        result = _calculate_islands(r, c, additions)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # Each case result, being a list, is converted to a string representation\n    # without spaces, e.g., \"[1,2,3]\".\n    # These strings are then joined by commas and enclosed in an outer bracket.\n    formatted_case_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    \n    print(final_output_string)\n\n\ndef _calculate_islands(r, c, additions):\n    \"\"\"\n    Calculates the number of islands after each addition for a single test case.\n    \n    This function implements the Disjoint-Set Union (DSU) data structure with\n    path compression and union-by-size heuristics to solve the dynamic\n    connectivity problem.\n    \"\"\"\n    if r = 0 or c = 0:\n        return []\n\n    num_cells = r * c\n    # The `parent` array serves dual purposes:\n    # 1. For the DSU structure, parent[i] stores the parent of element i.\n    # 2. A value of -1 indicates the cell is water.\n    parent = np.full(num_cells, -1, dtype=int)\n    \n    # The `size` array stores the size of the set for each root element.\n    # It is initialized to 1s, as each new land cell starts as a set of size 1.\n    size = np.ones(num_cells, dtype=int)\n    \n    num_components = 0\n    results_for_case = []\n\n    # The `find` operation with path compression.\n    # It is defined as a nested function to have access to the `parent` array.\n    def find(i):\n        if parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    for row, col in additions:\n        idx = row * c + col\n\n        # If the cell is already land, the number of components does not change.\n        if parent[idx] != -1:\n            results_for_case.append(num_components)\n            continue\n\n        # A new land cell is added, so it initially forms a new island.\n        parent[idx] = idx\n        num_components += 1\n        \n        # Check the 4-directional neighbors.\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            n_row, n_col = row + dr, col + dc\n\n            # Check if the neighbor is within a valid grid range.\n            if 0 = n_row  r and 0 = n_col  c:\n                n_idx = n_row * c + n_col\n                \n                # If the neighbor is also land, attempt to union the two components.\n                if parent[n_idx] != -1:\n                    root1 = find(idx)\n                    root2 = find(n_idx)\n                    \n                    if root1 != root2:\n                        # Union-by-size: attach the smaller tree to the root of the larger tree.\n                        if size[root1]  size[root2]:\n                            root1, root2 = root2, root1\n                        \n                        parent[root2] = root1\n                        size[root1] += size[root2]\n                        \n                        # Merging two components reduces the island count by one.\n                        num_components -= 1\n        \n        results_for_case.append(num_components)\n        \n    return results_for_case\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon the standard DSU, this problem challenges you to augment the data structure to solve a more complex graph property problem. By adding a single piece of information—the parity of the path length from a node to its root—you will develop a powerful tool for dynamically checking if a graph remains bipartite as edges are added. This practice highlights the extensibility of DSU for tracking properties beyond simple connectivity. ",
            "id": "3228343",
            "problem": "You are asked to design and implement an augmented Disjoint-Set Union (DSU) data structure to dynamically enforce a two-coloring constraint during edge insertions, thereby detecting whether a graph remains bipartite as edges are added.\n\nA Disjoint-Set Union (DSU), also known as Union-Find, maintains a partition of a set into disjoint subsets under two operations: find and union. The find operation locates the representative (root) of the subset containing a given element, and the union operation merges two subsets. When enhanced with two heuristics—path compression and union by size or rank—the amortized complexity per operation becomes near-constant.\n\nFundamental base:\n- A graph is bipartite if and only if its vertices can be colored with two colors so that every edge connects vertices of different colors. Equivalently, a graph is bipartite if and only if it contains no cycle of odd length.\n- The DSU maintains disjoint components under edge additions. To use DSU for bipartiteness under dynamics composed of only edge insertions, augment each node with a parity bit that stores the parity (modulo $2$) of the length of the path from the node to its current DSU root. This parity can be interpreted as the node’s color relative to the root.\n- The two DSU heuristics are:\n  - Path compression: update parents along the path to the root to point directly to the root to flatten the DSU trees.\n  - Union by size (or rank): attach the smaller tree under the root of the larger tree to keep trees shallow.\n\nYour task:\n- For each test case, you will be given a number of vertices $n$ and a list of undirected edges $(u, v)$ added one by one to an initially edgeless graph with vertex set $\\{1,2,\\dots,n\\}$.\n- You must determine the earliest edge index $i$ (using $1$-based indexing for the edge sequence) at which the graph becomes non-bipartite, assuming that before inserting edge $i$ the graph was bipartite. If the graph remains bipartite after all insertions, return $0$.\n\nPrecise definitions and constraints:\n- Let $G = (V, E)$ be a simple undirected graph, except that self-loops are allowed in the input for testing purposes. A self-loop $(u, u)$ renders the graph non-bipartite immediately.\n- Maintain a DSU with arrays storing for each node $x$: a parent pointer and a parity bit $p[x]$ that equals the parity (modulo $2$) of the length of the unique path from $x$ to $\\operatorname{root}(x)$ in the current DSU forest. Under path compression, update $p[x]$ so that it remains the parity from $x$ to the new parent after compression.\n- When inserting an edge $(u, v)$:\n  - If $\\operatorname{root}(u) \\ne \\operatorname{root}(v)$, merge the two sets using union by size, and set the parity of the attached root so that the parity constraint that $u$ and $v$ have opposite colors is preserved.\n  - If $\\operatorname{root}(u) = \\operatorname{root}(v)$, check whether the current parities imply that $u$ and $v$ are of opposite colors. If not, then an odd cycle is detected and the graph becomes non-bipartite at this insertion.\n\nRequired output for each test case:\n- An integer equal to the earliest violating edge index $i$ (with $1$-based indexing), or $0$ if no violation occurs.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the order of the test cases, for example: \"[x,y,z]\".\n\nTest suite:\n- For each item below, $n$ is the number of vertices, followed by the sequence of edges added in order. You must output one integer per item, as specified above.\n  - Test case $1$: $n = 5$, edges $[(1,2),(3,4),(2,3),(4,5)]$.\n  - Test case $2$: $n = 4$, edges $[(1,2),(2,3),(3,4),(4,1)]$.\n  - Test case $3$: $n = 3$, edges $[(1,2),(2,3),(1,3)]$.\n  - Test case $4$: $n = 3$, edges $[(1,1)]$.\n  - Test case $5$: $n = 6$, edges $[(1,2),(2,3),(3,1),(4,5),(5,6)]$.\n  - Test case $6$: $n = 7$, edges $[(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(1,7)]$.\n  - Test case $7$: $n = 5$, edges $[]$.\n\nYour program must be a complete, runnable implementation that constructs the described DSU with union by size and path compression, processes each test case, and prints a single line with the results as described above. No user input should be read; all data should be embedded in the program.",
            "solution": "The problem requires designing an augmented Disjoint-Set Union (DSU) data structure to determine, for a sequence of edge insertions into an initially edgeless graph, the first edge that renders the graph non-bipartite.\n\nA graph is bipartite if and only if it contains no cycles of odd length. The task is to detect the formation of the first odd-length cycle as edges are added. A DSU is well-suited for tracking connected components. The augmentation involves storing extra information to check the odd cycle condition.\n\nThe core idea is to maintain a 2-coloring of the graph's components. For each component, we can assign a color (say, $0$ or $1$) to each vertex such that adjacent vertices have different colors. This is equivalent to maintaining the parity of the path length between any two nodes in a component. We augment each node $x$ in the DSU structure with a value, which we denote as a parity bit, representing its color relative to the root of its component.\n\nLet $c(x)$ be the color of vertex $x$, with $c(x) \\in \\{0, 1\\}$. For any edge $(u,v)$, we must have $c(u) \\neq c(v)$. This is equivalent to $(c(u) + c(v)) \\pmod 2 = 1$. In our DSU, we do not store absolute colors, but rather the parity of the distance from a node to its parent in the DSU tree. Let this be $p[x]$. This value represents $c(x) \\oplus c(\\text{parent}[x])$, where $\\oplus$ is the XOR operation, equivalent to addition modulo $2$.\n\nThe DSU will be implemented with path compression and union by size for efficiency. The logic for the augmented operations is as follows:\n\n**State Representation:**\nFor a graph with $n$ vertices, we use three arrays of size $n+1$ to accommodate $1$-based vertex indexing:\n- $\\text{parent}[i]$: Stores the parent of node $i$. The root of a set is a node $r$ where $\\text{parent}[r] = r$.\n- $\\text{size}[i]$: Stores the number of elements in the set if $i$ is a root.\n- $\\text{parity}[i]$: Stores the parity of the path length from node $i$ to its parent, i.e., $c(i) \\oplus c(\\text{parent}[i])$.\n\n**Initialization:**\nFor each vertex $i \\in \\{1, \\dots, n\\}$:\n- $\\text{parent}[i] = i$.\n- $\\text{size}[i] = 1$.\n- $\\text{parity}[i] = 0$, since the distance from a node to itself is $0$.\n\n**Find Operation with Path Compression:**\nThe `find(i)` operation returns the root of the component containing $i$, and also the parity of the path length from $i$ to this root. This path parity is $c(i) \\oplus c(\\text{root}(i))$.\n\nLet's define `find(i)` to return a pair $(\\text{root}, d)$, where $d = c(i) \\oplus c(\\text{root})$.\nIf $i$ is a root ($\\text{parent}[i] = i$), then the path length is $0$, so we return $(i, 0)$.\nOtherwise, we recursively call `find` on its parent: $(\\text{root}, d_{\\text{parent}}) = \\text{find}(\\text{parent}[i])$.\nHere, $d_{\\text{parent}} = c(\\text{parent}[i]) \\oplus c(\\text{root})$.\nThe total parity from $i$ to the root is:\n$$d = (c(i) \\oplus c(\\text{parent}[i])) \\oplus (c(\\text{parent}[i]) \\oplus c(\\text{root})) = \\text{parity}[i] \\oplus d_{\\text{parent}}$$\nDuring path compression, we set $\\text{parent}[i] = \\text{root}$. The value $\\text{parity}[i]$ must be updated to reflect this new parent-child relationship. The new $\\text{parity}[i]$ becomes the total path parity $d$ we just computed.\n\n**Union Operation and Bipartiteness Check:**\nWhen considering adding an edge $(u, v)$:\n1. First, we find the roots and path parities for $u$ and $v$:\n   - $(\\text{root}_u, d_u) = \\text{find}(u)$\n   - $(\\text{root}_v, d_v) = \\text{find}(v)$\n   where $d_u = c(u) \\oplus c(\\text{root}_u)$ and $d_v = c(v) \\oplus c(\\text{root}_v)$.\n\n2. If $\\text{root}_u = \\text{root}_v$, the vertices $u$ and $v$ are already in the same connected component. Adding the edge $(u, v)$ creates a cycle. The graph remains bipartite if and only if this new cycle has even length. This means the path between $u$ and $v$ within the component must have odd length.\n   The colors of $u$ and $v$ relative to their common root are given by their path parities.\n   $c(u) = c(\\text{root}_u) \\oplus d_u$\n   $c(v) = c(\\text{root}_u) \\oplus d_v$\n   The condition for bipartiteness is $c(u) \\neq c(v)$, which implies $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_u) \\oplus d_v$, simplifying to $d_u \\neq d_v$. If we find that $d_u = d_v$, an odd cycle is formed, and the graph becomes non-bipartite. This is a conflict.\n\n3. If $\\text{root}_u \\neq \\text{root}_v$, the vertices are in different components. Adding the edge $(u, v)$ merges these components. The graph remains bipartite. We perform a union operation (by size) and update the parity information.\n   Let's say we attach $\\text{root}_v$'s tree to $\\text{root}_u$'s tree, making $\\text{parent}[\\text{root}_v] = \\text{root}_u$. We must define the new $\\text{parity}[\\text{root}_v]$, which is $c(\\text{root}_v) \\oplus c(\\text{root}_u)$.\n   The edge constraint $c(u) \\neq c(v)$ must hold. Substituting the relations from the `find` operation:\n   $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_v) \\oplus d_v$\n   Rearranging with XOR properties gives:\n   $c(\\text{root}_u) \\oplus c(\\text{root}_v) \\neq d_u \\oplus d_v$\n   The left side is exactly the quantity we need to set for $\\text{parity}[\\text{root}_v]$. For the inequality to hold, we must set $\\text{parity}[\\text{root}_v] = d_u \\oplus d_v \\oplus 1$. In modulo $2$ arithmetic, this is $(\\text{p}_u + \\text{p}_v + 1) \\pmod 2$.\n\nBy applying this logic for each edge in sequence, we can find the index of the first edge that introduces a conflict. If no conflicts arise after all edges are processed, the graph remains bipartite, and the answer is $0$. A self-loop $(u, u)$ is handled correctly by this logic: `find(u)` is called twice, returning identical roots and parities, leading to an immediate conflict since $d_u=d_u$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"\n    An augmented Disjoint-Set Union (DSU) data structure.\n    It supports union by size, path compression, and tracks parity\n    to check for bipartiteness in a dynamic graph.\n    \"\"\"\n    def __init__(self, n):\n        # Vertices are 1-indexed, so we use size n+1\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of the distance from i to its parent.\n        # This represents color(i) XOR color(parent(i)).\n        self.parity = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i, with path compression and parity update.\n        Returns a tuple (root, parity), where parity is the parity of the path from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n\n        # Recursively find the root of the parent\n        root, parent_parity = self.find(self.parent[i])\n\n        # Path compression: point i's parent directly to the root\n        self.parent[i] = root\n        \n        # Update parity: The new parity from i to the root is the XOR sum\n        # of parities along the old path: parity(i-parent) ^ parity(parent-root).\n        self.parity[i] = (self.parity[i] + parent_parity) % 2\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing i and j.\n        Returns True if the merge is consistent with bipartiteness, False otherwise.\n        A return value of False indicates that adding the edge (i,j) creates an odd cycle.\n        \"\"\"\n        root_i, parity_i = self.find(i)\n        root_j, parity_j = self.find(j)\n\n        if root_i != root_j:\n            # Union by size: attach smaller tree to the root of the larger tree\n            if self.size[root_i]  self.size[root_j]:\n                root_i, root_j = root_j, root_i # Ensure root_i is the larger set's root\n\n            self.parent[root_j] = root_i\n            self.size[root_i] += self.size[root_j]\n            \n            # Update parity of the attached root (root_j).\n            # The edge (i, j) requires color(i) != color(j).\n            # path_parity(i-root_i) = parity_i, path_parity(j-root_j) = parity_j.\n            # color(i) and color(j) must differ. Relative to root_i after merge:\n            # color_rel(i) = parity_i\n            # color_rel(j) = path_parity(j-root_j-root_i) = parity_j ^ parity(root_j-root_i)\n            # So, parity_i != parity_j ^ parity(root_j-root_i)\n            # which implies parity(root_j-root_i) = parity_i ^ parity_j ^ 1.\n            self.parity[root_j] = (parity_i + parity_j + 1) % 2\n            \n            return True\n        else:\n            # i and j are already in the same component.\n            # A conflict (odd cycle) occurs if they have the same relative color.\n            # This happens if their path parities to the common root are the same.\n            if parity_i == parity_j:\n                return False # Conflict detected\n            else:\n                return True # Consistent with existing coloring\n\ndef solve_case(n, edges):\n    \"\"\"\n    Processes a single test case to find the first edge that makes the graph non-bipartite.\n    \"\"\"\n    dsu = DSU(n)\n    for i, edge in enumerate(edges):\n        u, v = edge\n        if not dsu.union(u, v):\n            return i + 1  # Return 1-based index of the violating edge\n    return 0 # No violations found\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (5, [(1, 2), (3, 4), (2, 3), (4, 5)]),\n        (4, [(1, 2), (2, 3), (3, 4), (4, 1)]),\n        (3, [(1, 2), (2, 3), (1, 3)]),\n        (3, [(1, 1)]),\n        (6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]),\n        (7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (1, 7)]),\n        (5, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_case(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice demonstrates how DSU serves as a critical component within a larger, multi-stage algorithm. You will use a DSU to drive Kruskal’s algorithm for finding a Minimum Spanning Tree (MST), but with a twist: you'll simultaneously build a \"reconstruction tree\" that mirrors the DSU's merge history. This auxiliary structure, when paired with a Lowest Common Ancestor (LCA) algorithm, elegantly solves queries about the maximum edge weight on any path in the MST, showcasing a powerful synthesis of data structures. ",
            "id": "3228322",
            "problem": "You are given an undirected, weighted graph on $n$ labeled vertices with integer edge weights. The task is to compute a Minimum Spanning Tree (MST) using Kruskal’s algorithm grounded on Disjoint-Set Union (DSU) with union-by-rank and path-compression heuristics, and to augment this process to answer, for any pair of vertices $(u,v)$, the maximum edge weight on the unique path between $u$ and $v$ in the resulting MST. If $u$ and $v$ are not connected in the minimum spanning forest (i.e., the graph is disconnected), the query should return $-1$. If $u=v$, the query should return $0$.\n\nThe fundamental base for this problem is the definition and properties of Disjoint-Set Union (DSU), Kruskal’s algorithm, and the cut property of Minimum Spanning Trees. The cut property states that for any partition of the vertices into two nonempty sets, the minimum-weight edge crossing the cut that connects the two sets is included in every MST. Kruskal’s algorithm maintains a forest of components and repeatedly adds the minimum-weight edge that connects two different components until a spanning forest is formed. DSU supports efficient component membership and merging with union-by-rank and path-compression heuristics to ensure near-linear time complexity.\n\nYou must design the augmentation so that queries for the maximum edge weight on the MST path between $u$ and $v$ can be answered in $O(\\log n)$ per query after an $O(n \\log n)$ preprocessing. The augmentation should be logically derived from these foundations without relying on unproven shortcuts.\n\nYour program must implement the complete pipeline:\n- Construct the MST using Kruskal’s algorithm on top of Disjoint-Set Union (DSU) with union-by-rank and path-compression heuristics.\n- During the construction, build an auxiliary tree structure that enables answering maximum edge queries on MST paths. The augmentation must be justified by properties of Kruskal’s algorithm and DSU, and should support subsequent queries via a principled method that reduces the path maximum query to a tree ancestor query.\n- Preprocess this auxiliary structure to enable answering queries efficiently.\n\nInput is embedded in the program as a fixed test suite. For each test case, the input consists of:\n- An integer $n$ specifying the number of vertices labeled from $0$ to $n-1$.\n- A list of weighted edges $(u,v,w)$ with integer weights $w$.\n- A list of query pairs $(u,v)$.\n\nYour program should produce a single line of output containing the results for all queries across the test cases, flattened into one comma-separated list enclosed in square brackets. Each query’s answer is an integer. If $u$ and $v$ are disconnected, return $-1$. If $u=v$, return $0$.\n\nUse the following test suite:\n- Test case $1$:\n  - $n=6$\n  - Edges: $\\{(1,2,1),(1,3,2),(3,4,2),(0,2,3),(0,1,4),(2,3,4),(3,5,5),(4,5,6)\\}$\n  - Queries: $\\{(0,5),(4,0),(2,3),(1,1),(4,5),(0,4)\\}$\n- Test case $2$:\n  - $n=6$\n  - Edges: $\\{(0,1,2),(1,2,3),(0,2,4),(3,4,1),(4,5,7),(3,5,8)\\}$\n  - Queries: $\\{(0,2),(3,5),(0,5),(1,1)\\}$\n- Test case $3$:\n  - $n=1$\n  - Edges: $\\{\\}$\n  - Queries: $\\{(0,0),(0,0)\\}$\n- Test case $4$:\n  - $n=5$\n  - Edges: $\\{(0,1,1),(1,2,2),(2,3,3),(3,4,4)\\}$\n  - Queries: $\\{(0,4),(1,3),(2,2)\\}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[a_1,a_2,\\dots]$). The answers must strictly correspond to the queries in the order they are listed across all test cases.",
            "solution": "The problem requires us to find the maximum weight edge on the path between two vertices in a Minimum Spanning Tree (MST). A naive approach of first building the MST and then, for each query, traversing the path would be too slow. The specified complexity requirements ($O(\\log n)$ per query) and the hint to use the properties of Kruskal's algorithm point towards a more sophisticated approach involving a preprocessing step.\n\nThe core principle is to build an auxiliary data structure during the execution of Kruskal's algorithm that captures the hierarchical merging of components. This structure, which we will call the **Kruskal Reconstruction Tree**, allows us to answer maximum path weight queries by transforming them into Lowest Common Ancestor (LCA) queries.\n\n**Step 1: Kruskal's Algorithm and the Reconstruction Tree**\n\nKruskal's algorithm constructs an MST by iteratively adding the lowest-weight edge that does not form a cycle. This is equivalent to merging two previously disconnected components. This merging process creates a natural hierarchy: smaller components merge into larger ones, with the weight of the connecting edge marking the \"cost\" of that merge.\n\nWe can explicitly model this hierarchy. The reconstruction tree will have the original $n$ vertices as its leaves. When Kruskal's algorithm uses an edge $(u,v)$ with weight $w$ to merge the component containing $u$ with the component containing $v$, we create a new internal node in our reconstruction tree. This new node becomes the parent of the nodes that represented the two components just before the merge. We crucially associate the weight $w$ with this new internal node.\n\nThe construction proceeds as follows:\n- We use a DSU data structure to keep track of the components.\n- We maintain a mapping from the representative of each set in the DSU to the root of the corresponding subtree in our reconstruction tree.\n- The reconstruction tree will have up to $2n-1$ nodes ( $n$ leaves and at most $n-1$ internal nodes).\n- As we iterate through edges sorted by weight, each time we perform a `union` operation in the DSU for an edge of weight $w$, we create a new internal node in the reconstruction tree, make it the parent of the two subtrees being merged, and assign it the weight $w$.\n\n**Step 2: Path Maximum as a Lowest Common Ancestor (LCA) Query**\n\nThe central insight is that for any two vertices $u$ and $v$ in the final MST, the heaviest edge on the unique path between them is precisely the edge that was added by Kruskal's algorithm to first connect the component containing $u$ with the component containing $v$.\n\nLet's formalize this. In our reconstruction tree, the path from a leaf vertex (e.g., $u$) to the root follows the sequence of merges its component was involved in, with parent nodes having monotonically increasing weights. The Lowest Common Ancestor of $u$ and $v$, denoted `LCA(u,v)`, corresponds to the very first merge event that placed $u$ and $v$ into the same component. The weight stored at this `LCA(u,v)` node is the weight of the edge that caused this merge. By the greedy nature of Kruskal's algorithm, any edge used to form the sub-components containing $u$ and $v$ *before* this merge must have a weight less than or equal to the weight of the merge edge. Therefore, the weight of the `LCA(u,v)` node is the maximum weight on the path between $u$ and $v$ in the MST.\n\nThe problem of finding the maximum edge weight on the path $(u,v)$ is thus elegantly reduced to finding `tree_weight[LCA(u, v)]` in the reconstruction tree.\n\n**Step 3: Efficient LCA Preprocessing and Querying**\n\nTo answer LCA queries in the required $O(\\log n)$ time, we employ the **binary lifting** technique. After the reconstruction tree (or forest, if the graph is disconnected) is built, we preprocess it.\n\n1.  **Depth Calculation**: First, we perform a Depth First Search (DFS) from the root(s) of the forest to compute the depth of each node and the immediate parent of each node.\n2.  **Binary Lifting Tables**: We build a table `up[i][j]`, which stores the $2^j$-th ancestor of node $i$.\n    - The base case is `up[i][0] = parent[i]`, found during the DFS.\n    - The table is filled using the recurrence: `up[i][j] = up[ up[i][j-1] ][j-1]`.\n3.  **LCA Query**: With the `up` table, we can find `LCA(u,v)` in $O(\\log n)$ time. We first bring the deeper node to the same level as the shallower one. Then, we lift both nodes up simultaneously until their parents are identical.\n\n**Step 4: Algorithm Summary**\n\nThe complete algorithm unfolds as follows:\n1.  **Initialization**: Initialize a DSU structure for $n$ vertices. Sort all graph edges by weight in non-decreasing order. Prepare data structures for the reconstruction tree (parent and weight arrays for up to $2n-1$ nodes) and a mapping from DSU roots to tree nodes.\n2.  **Kruskal's and Tree Construction**: Iterate through the sorted edges. For each edge $(u,v,w)$:\n    - If `find(u)` is not equal to `find(v)`, this edge connects two components and is part of the MST.\n    - Perform `union(u,v)`.\n    - Create a new internal node in the reconstruction tree with weight $w$. This new node becomes the parent of the nodes representing the components of $u$ and $v$. Update the DSU root-to-tree-node map.\n3.  **LCA Preprocessing**: Once Kruskal's is complete, traverse the resulting reconstruction forest to compute node depths and the `up[i][0]` values. Then, use dynamic programming to fill the rest of the binary lifting `up` table. This is an $O(n \\log n)$ operation.\n4.  **Query Processing**: For each query $(u,v)$:\n    - If $u=v$, the answer is $0$.\n    - Use the final DSU state to check if `find(u) == find(v)`. If not, they are disconnected, and the answer is $-1$.\n    - If they are connected, use the preprocessed binary lifting table to find `lca_node = LCA(u,v)` in the reconstruction tree. The answer is the weight stored at `lca_node`.\n\nThis integrated approach correctly solves the problem within the specified time complexities and is directly justified by the fundamental properties of the algorithms involved.",
            "answer": "```python\nimport numpy as np\nimport math\nimport sys\n\n# Increase recursion limit for deep trees in large test cases.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"edges\": [(1, 2, 1), (1, 3, 2), (3, 4, 2), (0, 2, 3), (0, 1, 4), (2, 3, 4), (3, 5, 5), (4, 5, 6)],\n            \"queries\": [(0, 5), (4, 0), (2, 3), (1, 1), (4, 5), (0, 4)]\n        },\n        {\n            \"n\": 6,\n            \"edges\": [(0, 1, 2), (1, 2, 3), (0, 2, 4), (3, 4, 1), (4, 5, 7), (3, 5, 8)],\n            \"queries\": [(0, 2), (3, 5), (0, 5), (1, 1)]\n        },\n        {\n            \"n\": 1,\n            \"edges\": [],\n            \"queries\": [(0, 0), (0, 0)]\n        },\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)],\n            \"queries\": [(0, 4), (1, 3), (2, 2)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = _process_case(case['n'], case['edges'], case['queries'])\n        all_results.extend(results)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nclass DSU:\n    \"\"\"Disjoint-Set Union with Union-by-Rank and Path-Compression.\"\"\"\n    def __init__(self, n):\n        self.parent = np.arange(n)\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            if self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_i] = root_j\n                if self.rank[root_i] == self.rank[root_j]:\n                    self.rank[root_j] += 1\n            return True\n        return False\n\ndef _process_case(n, edges, queries):\n    \"\"\"\n    Solves a single test case: builds MST and reconstruction tree,\n    preprocesses for LCA, and answers all queries.\n    \"\"\"\n    if n == 0:\n        return [0] * len(queries)\n\n    # In a graph with n vertices, Kruskal's will create at most n-1 merges.\n    # Total nodes in reconstruction tree = n leaves + (n-1) internal nodes.\n    max_nodes = 2 * n - 1 if n > 0 else 0\n    if max_nodes == 0: max_nodes = 1\n\n    dsu = DSU(n)\n    \n    # Sort edges by weight\n    edges.sort(key=lambda x: x[2])\n\n    # Data structures for the reconstruction tree\n    # Maps a DSU component's root to its corresponding node in the reconstruction tree\n    dsu_root_to_tree_node = np.arange(n)\n    tree_parent = np.full(max_nodes, -1, dtype=int)\n    tree_weight = np.zeros(max_nodes, dtype=int)\n    next_internal_node = n\n\n    # Phase 1: Kruskal's algorithm and reconstruction tree construction\n    for u, v, w in edges:\n        root_u = dsu.find(u)\n        root_v = dsu.find(v)\n\n        if root_u != root_v:\n            # This edge connects two different components\n            tree_node_u = dsu_root_to_tree_node[root_u]\n            tree_node_v = dsu_root_to_tree_node[root_v]\n            \n            # Perform union and get the new root of the merged component\n            # The DSU implementation details determine the new root\n            if dsu.rank[root_u] > dsu.rank[root_v]:\n                new_dsu_root = root_u\n            else:\n                new_dsu_root = root_v\n            \n            dsu.union(u, v)\n\n            # Create a new internal node for the merge\n            p = next_internal_node\n            tree_parent[tree_node_u] = p\n            tree_parent[tree_node_v] = p\n            tree_weight[p] = w\n            \n            # The new component's representative maps to this new internal node\n            dsu_root_to_tree_node[new_dsu_root] = p\n            next_internal_node += 1\n    \n    num_total_nodes = next_internal_node\n    \n    # Phase 2: Preprocessing for LCA (Binary Lifting)\n    if num_total_nodes == 0:\n        return [0 if u == v else -1 for u,v in queries]\n        \n    MAX_LOG = (num_total_nodes).bit_length()\n    up = np.full((num_total_nodes, MAX_LOG), -1, dtype=int)\n    depth = np.full(num_total_nodes, -1, dtype=int)\n    \n    # Build adjacency list from parent array for easier traversal\n    adj = [[] for _ in range(num_total_nodes)]\n    roots = []\n    for i in range(num_total_nodes):\n        if tree_parent[i] != -1:\n            adj[tree_parent[i]].append(i)\n        else:\n            roots.append(i)\n\n    # DFS from each root of the forest to compute depth and up[i][0]\n    for root in roots:\n        stack = [(root, -1, 0)] # (current_node, parent_node, current_depth)\n        while stack:\n            curr, p, d = stack.pop()\n            depth[curr] = d\n            up[curr, 0] = p if p != -1 else curr # Root's parent is itself\n            for neighbor in adj[curr]:\n                stack.append((neighbor, curr, d + 1))\n\n    # Fill the rest of the 'up' table using dynamic programming\n    for j in range(1, MAX_LOG):\n        for i in range(num_total_nodes):\n            if up[i, j-1] != -1:\n                up[i, j] = up[up[i, j-1], j-1]\n\n    # --- LCA Query Function ---\n    def get_lca(u, v):\n        if depth[u]  depth[v]:\n            u, v = v, u\n\n        # Lift u to the same depth as v\n        for j in range(MAX_LOG - 1, -1, -1):\n            if depth[u] - (1  j) >= depth[v]:\n                u = up[u, j]\n\n        if u == v:\n            return u\n\n        # Lift u and v together\n        for j in range(MAX_LOG - 1, -1, -1):\n            if up[u, j] != up[v, j]:\n                u = up[u, j]\n                v = up[v, j]\n        \n        return up[u, 0]\n\n    # Phase 3: Answer queries\n    results = []\n    for u, v in queries:\n        if u == v:\n            results.append(0)\n            continue\n            \n        if dsu.find(u) != dsu.find(v):\n            results.append(-1)\n            continue\n\n        lca_node = get_lca(u, v)\n        results.append(tree_weight[lca_node])\n\n    return results\n\nsolve()\n```"
        }
    ]
}