{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基石。在深入研究 B 树删除操作的复杂实现之前，我们首先通过一个思想实验来理解其操作成本的理论上限。此练习  将引导你推导在最坏情况下，单次密钥删除可能引发的连锁合并次数，这有助于我们从根本上认识到维护 B 树平衡所需付出的潜在代价。",
            "id": "3211412",
            "problem": "B 树是一种平衡多路搜索树，其参数为一个最小度数 $t \\geq 2$。在一个最小度数为 $t$ 的 B 树中，每个内部节点（根节点可能除外）包含 $t-1$ 到 $2t-1$ 个关键字，因此有 $t$ 到 $2t$ 个子节点；根节点包含 $1$ 到 $2t-1$ 个关键字，除非它同时也是一个叶节点，在这种情况下它可以包含 $0$ 个关键字。我们将 B 树的高度 $h$ 定义为从根节点到任意叶节点的最长简单路径上的边数，因此，一个仅由根节点组成的树的高度为 $0$。\n\n考虑 B 树的标准删除操作，该操作基于以下经过充分检验的事实和核心定义：除根节点外，节点不能下溢（关键字数量降至 $t-1$ 以下）；如果在删除过程中子节点发生下溢，算法要么通过父节点从兄弟节点重新分配一个关键字（旋转），要么通过将父节点中的一个分隔关键字移动到合并后的节点中，将该子节点与其相邻的兄弟节点合并。一个单独的合并步骤会将恰好 $2$ 个兄弟节点合并成 $1$ 个节点，并使父节点的关键字数量减少 $1$。\n\n假设你在一个最小度数为 $t$、高度为 $h$（如上定义）的 B 树中执行一次单个关键字删除操作。你需要计算的仅仅是将两个兄弟节点合并为一个节点的节点合并操作的数量；不要计算重新分配（旋转）操作，也不要将用其唯一的子节点替换根节点的最终行为（如果发生）计为一次合并，尽管在该替换之前发生的任何合并都应被计算在内。\n\n在删除操作之前，关键字的排列是“对抗性的”但符合 B 树不变量，那么一次单个关键字删除最多可能导致多少次节点合并？请用 $t$ 和 $h$ 表示。将你的答案表示为变量 $t$ 和 $h$ 的封闭形式解析表达式。无需四舍五入。",
            "solution": "用户希望我确定在最小度数为 $t$、高度为 $h$ 的 B 树中，单次关键字删除所能引起的最大节点合并操作次数。\n\n### 问题验证\n问题陈述提供了 B 树的正确和标准定义，包括最小度数 $t$、节点的关键字数量以及高度 $h$ 的定义。关于 B 树删除算法的描述，特别是通过重新分配（旋转）或合并来处理节点下溢的方式，也是标准的。问题要求在“对抗性但有效的排列”下求最大合并次数，这是算法学中表述最坏情况分析问题的标准方式。该问题是自包含的，在数据结构理论中有科学依据，并且是适定的。因此，问题是有效的，可以推导出解决方案。\n\n### 解题推导\n\n为了确定最大合并操作次数，我们必须构建一个最坏情况。当一个节点的关键字数量降到最小值 $t-1$ 以下，并且无法从相邻兄弟节点重新分配关键字时，就会触发合并操作。这种情况发生在节点下溢到 $t-2$ 个关键字，而其邻居也处于最小状态，即恰好有 $t-1$ 个关键字时。如果一个层级的合并导致其父节点下溢，而父节点的下溢又需要通过合并来解决，如此向上传递，就会发生一连串的合并（级联合并），从而产生最大合并次数。\n\n让我们定义一种能够促成这种最大合并级联的对抗性 B 树结构。\n高度 $h$ 是从根到叶的边数。这意味着有 $h+1$ 个节点层级，我们可以从第 $0$ 层（根）到第 $h$ 层（叶）进行索引。\n最坏情况是一种“瘦”B 树，其中从根到叶的某条特定路径上的所有节点都只填充了最少数量的关键字。\n1.  我们选择一条由节点 $N_0, N_1, \\dots, N_h$ 组成的路径，其中 $N_0$ 是根节点，$N_1$ 是 $N_0$ 的子节点，依此类推，直到叶节点 $N_h$。\n2.  为了让级联完全传播，这条路径上的每个节点 $N_i$（其中 $i \\in \\{0, 1, \\dots, h-1\\}$）都必须拥有其类型所允许的最小关键字数。对于除根节点外的内部节点，最小关键字数为 $t-1$ 个。对于根节点，最小为 $1$ 个关键字。因此，我们假设对于 $i \\in \\{1, \\dots, h-1\\}$，$N_i$ 有 $t-1$ 个关键字，而根节点 $N_0$ 有 $1$ 个关键字。\n3.  将要进行删除的叶节点 $N_h$ 也必须是最小的，包含 $t-1$ 个关键字。\n4.  关键的是，为了在每个层级强制进行合并而非旋转，我们路径上节点的兄弟节点也必须是最小的。也就是说，对于每个将要下溢的节点 $N_i$，其相邻的兄弟节点 $S_i$ 必须恰好有 $t-1$ 个关键字。\n\n在这种 B 树配置下，让我们追踪从叶节点 $N_h$ 删除单个关键字所产生的影响。\n\n**从叶节点删除与初始合并（第 $h$ 层）**\n我们从叶节点 $N_h$ 中删除一个关键字。\n*   $N_h$ 的初始状态：$t-1$ 个关键字。\n*   删除后状态：$t-2$ 个关键字。由于 $t \\geq 2$，所以 $t-2 < t-1$，因此节点 $N_h$ 发生下溢。\n*   为了解决下溢，我们检查 $N_h$ 的一个相邻兄弟节点，称之为 $S_h$。根据我们的对抗性设计，$S_h$ 也是最小的，拥有 $t-1$ 个关键字。无法进行旋转。\n*   执行一次合并操作。节点 $N_h$、其兄弟节点 $S_h$ 以及来自其父节点 $N_{h-1}$ 的分隔关键字被合并成一个新节点。这构成了**第一次合并**。合并后的新节点包含 $(t-2) + (t-1) + 1 = 2t-2$ 个关键字，这是一个有效的关键字数量（因为 $2t-2 \\leq 2t-1$）。\n\n**下溢的传播与合并的级联**\n在第 $h$ 层的合并需要从父节点 $N_{h-1}$ 向下取一个分隔关键字。\n*   $N_{h-1}$ 的初始状态：$t-1$ 个关键字（根据我们的对抗性设计）。\n*   其关键字被取走后的状态：$(t-1)-1 = t-2$ 个关键字。现在，第 $h-1$ 层的节点 $N_{h-1}$ 发生下溢。\n*   为了解决这个下溢，我们检查 $N_{h-1}$ 的一个兄弟节点，比如 $S_{h-1}$。这个兄弟节点也是最小的，有 $t-1$ 个关键字。旋转是不可能的。\n*   在 $N_{h-1}$ 和 $S_{h-1}$ 之间执行一次合并，从它们的父节点 $N_{h-2}$ 向下取一个分隔关键字。这是**第二次合并**。\n\n这个过程继续向上传播到树的更高层。在第 $i$ 层（其中 $1 < i \\leq h$）的合并操作是由该层的下溢引起的。这次合并会消耗掉第 $i-1$ 层父节点的一个关键字，由于父节点也是最小的，这又会导致它下溢。从而在第 $i-1$ 层触发一次合并。\n\n**最后一次合并（第 1 层）**\n级联沿着原始删除节点的祖先路径向上传播。\n*   在第 $1$ 层的节点 $N_1$ 中触发了下溢。\n*   节点 $N_1$ 原有 $t-1$ 个关键字，但第 $2$ 层的合并使其关键字数变为 $t-2$。\n*   它的兄弟节点 $S_1$ 也有 $t-1$ 个关键字。它们必须合并。\n*   这次合并操作从它们的父节点，即根节点 $N_0$ 中取走一个关键字。这是根节点的两个子节点之间的一次合并。\n\n**计算合并次数**\n合并操作在每个层级都会发生，从叶节点层（$h$）开始，一直级联到根节点的子节点层（第 $1$ 层）。\n*   第 1 次合并：发生在第 $h$ 层。\n*   第 2 次合并：发生在第 $h-1$ 层。\n*   ...\n*   第 $i$ 次合并：发生在第 $h-i+1$ 层。\n*   ...\n*   最后一次合并：发生在第 $1$ 层。\n\n合并的总次数是从第 $1$ 层到第 $h$ 层（含）的层级数。总数为 $h - 1 + 1 = h$。\n\n在第 $1$ 层发生最后一次合并后，根节点 $N_0$ 失去一个关键字。在我们的最坏情况设置中，根节点只有一个关键字。这个关键字被向下移入合并后的节点。根节点现在剩下 $0$ 个关键字和一个子节点。B 树结构此时要求移除这个空的根节点，并使其唯一的子节点成为新的根节点。问题陈述明确说明，不要将这最后一步降低树高的操作计为一次合并。因此，合并操作链在第 $1$ 层的合并之后就停止了。\n\n因此，最大合并次数等于此次级联中的合并次数。这个数字恰好是 $h$。这对任何 $t \\geq 2$ 都成立。例如，如果 $h=1$，从一个最小叶节点删除会导致一次与其兄弟节点的合并，根节点失去一个关键字。总共是 $1$ 次合并。如果 $h=0$，树只有一个节点，不可能发生合并，所以次数是 $0$。该公式成立。\n\n最大合并次数仅取决于高度 $h$，而与最小度数 $t$ 无关。参数 $t$ 定义了节点为最小的条件，但潜在级联的长度是由树的高度决定的。\n\n因此，理论上的最大节点合并次数是 $h$。",
            "answer": "$$\n\\boxed{h}\n$$"
        },
        {
            "introduction": "掌握了理论边界后，让我们通过一个具体的例子来剖析 B 树删除操作的微观过程。本练习  要求你在一个给定的 B 树和一个等效的红黑树上执行相同的删除操作，并精确计算其中的“键值比较”次数。通过这种对比，你可以更直观地理解 B 树在节点内部进行搜索的成本，以及它与二叉搜索树在操作上的本质区别。",
            "id": "3211517",
            "problem": "考虑以下两个搜索树，它们构建在同一个由不同整数键组成的有限集合上。设数据集为\n$$\nS=\\{2,5,10,12,15,20,22,25,30,32,35\\}。\n$$\n树 A 是一个最小度为 $t=3$ 的 B 树（因此除了根节点，每个节点存储 $t-1=2$ 到 $2t-1=5$ 个键）。树 A 的高度为 $1$，其确切结构如下：\n- 根节点存储键 $[10,20,30]$。\n- 它有 $4$ 个叶子孩子，从左到右依次为：\n  - 孩子 $0$：$[2,5]$，\n  - 孩子 $1$：$[12,15]$，\n  - 孩子 $2$：$[22,25]$，\n  - 孩子 $3$：$[32,35]$。\n树 B 是一个有效的红黑树（RBT），存储着相同的键集 $S$，其二叉搜索树（BST）形状明确给出如下：\n- 根键为 $20$。\n- $20$ 的左子树根为 $10$；$10$ 的左孩子是 $5$，$5$ 有左孩子 $2$ 但没有右孩子；$10$ 的右孩子是 $15$，$15$ 有左孩子 $12$ 但没有右孩子。\n- $20$ 的右子树根为 $30$；$30$ 的左孩子是 $25$，$25$ 有左孩子 $22$ 但没有右孩子；$30$ 的右孩子是 $32$，$32$ 有右孩子 $35$ 但没有左孩子。\n你需要比较从每棵树中删除单个键 $k=20$ 时所执行的键与键之间的比较次数，比较过程需遵循以下精确的计数模型和算法假设，这些假设基于 B 树和红黑树操作的标准定义：\n- “键比较”仅在算法比较搜索键 $x$ 与存储键 $y$ 以决定相等性或遍历方向时计数；与哨兵指针或节点度的比较不计数。\n- 在 B 树（树 A）中，对于任何包含 $m$ 个键的节点，算法通过从左到右的线性扫描来定位 $x$ 的位置，依次将 $x$ 与节点中的每个键进行比较，直到找到第一个 $\\ge x$ 的键或找到相等的键。每次这样的比较都要计数。使用标准的 B 树删除过程：如果 $x$ 位于一个内部节点，并且其相邻的两个子节点都没有至少 $t$ 个键，则执行与分隔键的合并操作，并递归到合并后的子节点中进行删除。合并过程中的连接/重新分配利用已知的排序顺序，不产生键比较。\n- 在红黑树（树 B）中，删除操作按照标准红黑树的方式进行：首先通过对键进行普通二叉搜索来定位 $x$；如果节点有两个孩子，则用其中序后继替换它，其中序后继通过仅使用指针检查（无键比较）下降到其右子树的最左侧节点来找到，然后移除该后继节点。旋转、重新着色以及任何指针或空孩子检查均不产生键比较；只计算键搜索过程中 $x$ 与节点键之间的比较。\n令 $C_{B}$ 表示从树 A（B 树）中删除键 $k=20$ 所需的键比较总次数，令 $C_{R}$ 表示从树 B（红黑树）中删除键 $k=20$ 所需的键比较总次数。计算单一数值差\n$$\n\\Delta = C_{B}-C_{R}。\n$$\n以单个整数形式提供 $\\Delta$ 的值。无需四舍五入。",
            "solution": "目标是计算差值 $\\Delta = C_{B} - C_{R}$，其中 $C_{B}$ 是从给定的 B 树（树 A）中删除键 $k=20$ 所需的键与键之间的比较次数，而 $C_{R}$ 是从给定的红黑树（树 B）中进行相同删除操作所需的键与键之间的比较次数。题目为计算这些比较次数提供了一套特定的规则。\n\n首先，我们分析从 B 树（树 A）中删除的操作以确定 $C_{B}$。\n\n该 B 树的最小度为 $t=3$。根节点包含键 $[10, 20, 30]$。要删除的键是 $k=20$。根据所提供的规则，删除过程分两个主要阶段进行。\n\n**阶段 1：在 B 树中搜索键。**\n搜索从根节点开始。题目说明在一个节点内的搜索是从左到右的线性扫描。\n1.  我们从包含键 $[10, 20, 30]$ 的根节点开始。\n2.  搜索键 $k=20$ 与节点的第一个键 $10$ 进行比较。由于 $20 > 10$，搜索继续。这是第一次比较。\n3.  搜索键 $k=20$ 与节点的第二个键 $20$ 进行比较。由于 $20 = 20$，键被找到。这是第二次比较。\n在根节点中定位键 $k=20$ 的总比较次数为 $2$。\n\n**阶段 2：执行删除操作。**\n键 $k=20$ 位于一个内部节点（根节点）中。题目指定了一个特定的删除过程：“如果 $x$ 位于一个内部节点，并且其相邻的两个子节点都没有至少 $t$ 个键，则执行与分隔键的合并操作，并递归到合并后的子节点中进行删除。”\n\n1.  键 $k=20$ 作为根节点的孩子 1 和孩子 2 之间的分隔键。\n2.  孩子 1 包含键 $[12, 15]$，所以它有 $2$ 个键。\n3.  孩子 2 包含键 $[22, 25]$，所以它有 $2$ 个键。\n4.  最小度为 $t=3$。条件“至少 $t$ 个键”意味着拥有 $3$ 个或更多的键。\n5.  孩子 1 有 $2$ 个键，不满足至少 $3$ 个。孩子 2 也有 $2$ 个键，不满足至少 $3$ 个。\n6.  条件“相邻的两个子节点都没有至少 $t$ 个键”被满足。因此，执行合并操作。\n7.  孩子 1、分隔键 $k=20$ 和孩子 2 被合并成一个单一的新节点。这个新节点的内容是来自孩子 1 的键、键 $20$ 以及来自孩子 2 的键，结果得到排序列表 $[12, 15, 20, 22, 25]$。\n8.  题目说明这个合并操作不产生键比较。\n9.  合并后，删除算法递归地从这个新形成的节点中删除 $k=20$。\n\n**阶段 3：递归删除步骤。**\n现在的任务是从包含 $[12, 15, 20, 22, 25]$ 的节点中删除键 $k=20$。这个节点是一个叶子节点。从叶子节点删除包括搜索键然后移除它。\n\n1.  使用线性扫描在节点 $[12, 15, 20, 22, 25]$ 中查找 $k=20$。\n2.  比较 $k=20$ 和 $12$。$20 > 12$。这是一次比较。\n3.  比较 $k=20$ 和 $15$。$20 > 15$。这是第二次比较。\n4.  比较 $k=20$ 和 $20$。$20 = 20$。键被找到。这是第三次比较。\n这个递归步骤中的总比较次数为 $3$。\n\nB 树删除的总键比较次数 $C_{B}$ 是初始搜索和递归删除步骤中比较次数的总和。\n$C_{B} = 2 + 3 = 5$。\n\n接下来，我们分析从红黑树（树 B）中删除的操作以确定 $C_{R}$。\n\nRBT 的删除过程同样受题目中规定的特定规则的约束。\n\n**阶段 1：在 RBT 中搜索键。**\n搜索 $k=20$ 使用“对键进行普通二叉搜索”。\n\n1.  搜索从树 B 的根节点开始，该节点包含键 $20$。\n2.  搜索键 $k=20$ 与根键 $20$ 进行比较。它们相等。节点在第一次比较时就被找到。\n定位该键的总比较次数为 $1$。\n\n**阶段 2：执行删除操作。**\n包含 $k=20$ 的节点是根节点，并且有两个孩子（键为 $10$ 和 $30$ 的节点）。\n\n1.  规则是用其中序后继的键替换此节点中的键，然后删除后继的原始节点。\n2.  题目说明中序后继是通过“仅使用指针检查（无键比较）下降到其右子树的最左侧节点”来找到的。因此，找到后继（即键为 $22$ 的节点）花费 $0$ 次比较。\n3.  键 $20$ 被替换为 $22$。问题现在简化为删除后继的原始节点。\n4.  键 $22$ 的原始节点是一个叶子节点（它没有孩子）。删除一个已经被定位的节点不会产生更多的键搜索比较。\n5.  任何后续的 RBT 修复操作（旋转和重新着色）也被指定为不产生键比较。\n\nRBT 删除的总键比较次数 $C_{R}$ 仅来自最初搜索键的过程。\n$C_{R} = 1$。\n\n最后，我们计算所需的差值 $\\Delta$。\n$\\Delta = C_{B} - C_{R}$\n$\\Delta = 5 - 1 = 4$。\n键比较次数的差值为 $4$。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "最终，我们将理论知识和操作细节应用于实际的编程挑战中。本练习  要求你设计并实现一个支持“批量删除”操作的 B 树，并优化其再平衡策略。这不仅是对标准 B 树删除逻辑的考验，更鼓励你思考如何在满足 B 树不变量的前提下，通过优先“借用”而非“合并”来最小化结构调整的开销，这正是数据库系统等真实应用中的核心优化问题。",
            "id": "3211492",
            "problem": "您必须设计并实现一个完整的程序，该程序模拟一个支持“批量删除”操作的B-树，此操作可在一步之内从同一个叶节点中删除 $k$ 个键，然后优化后续的合并与再平衡过程。请使用以下B-树的基本原则作为基础，并从这些原则推导您的算法，而不是使用简便公式。\n\n基本原则与不变量：\n- 一个最小度为 $t$ 的B-树在节点中存储已排序的键，每个非根节点包含 $t-1$ 到 $2t-1$ 个键，每个内部节点包含 $t$ 到 $2t$ 个子节点。如果根节点是内部节点，它可以包含 $1$ 到 $2t-1$ 个键；如果根节点是叶节点，它可以包含 $1$ 到 $2t-1$ 个键，或者在树没有任何键的情况下为空。\n- 所有叶节点都位于同一深度。位于两个相邻父键之间的子节点的子树中的键，必须严格位于由这些父键定义的相应区间内。\n- 当一个节点将要超过 $2t-1$ 个键时，插入操作会进行分裂，将中位数键向上移动。从叶节点删除可能在节点键数少于 $t-1$ 时产生下溢，这时需要尽可能通过父分隔符从兄弟节点进行旋转（借用），或者在借用无法修复不足时，通过父分隔符与兄弟节点合并。合并可能将不足向上传播到父节点，并重复此过程。\n\n任务：\n- 实现一个最小度为 $t$ 的B-树，支持整数键的插入以及一个批量删除操作，该操作仅限于删除位于同一叶节点中的 $k$ 个键。您必须实现一个优化的批量再平衡策略，在从叶节点移除 $k$ 个键后，该策略在合并之前尽可能从兄弟节点执行多次旋转（借用），并根据兄弟节点的剩余容量选择旋转次数，以最小化合并次数。如果旋转无法满足不足，则与一个相邻的兄弟节点执行单次合并，然后递归地修复任何向上传播的不足。对于旋转，应用标准的B-树旋转语义：从左兄弟借用时，用左兄弟的最大键替换父分隔符，并将父分隔符下移到下溢节点中；从右兄弟借用时，用右兄弟的最小键替换父分隔符，并将父分隔符下移到下溢节点中。对于合并，将被合并的两个节点之间的父分隔符下移，并连接键（如果是内部节点，还包括子节点）。\n- 您的程序还必须验证，在批量删除和再平衡之后，B-树的不变量仍然成立：每个节点的键数在界限内，键是排序的，内部节点的子节点数比键数多一，所有叶节点具有相同的深度，并且键的范围得到遵守。\n\n测试套件的接口设计：\n- 程序必须通过插入给定的整数序列来构建初始B-树，然后在包含指定枢轴键的叶节点上执行批量删除。对于批量删除，删除该叶节点中当前最小的 $k$ 个键。一个布尔标志可以请求在批量删除之前，将目标叶节点的两个直接兄弟节点预先减少到最小键数 $t-1$，以测试侧重于合并的行为。\n- 对于每个测试用例，您的程序必须报告以下内容作为一个列表：执行的总合并次数（一个整数）、执行的总旋转次数（一个整数）、B-树的最终高度（一个整数，其中只有一个根节点的树高度为 0），以及一个布尔值，指示所有操作后B-树的不变量是否成立。\n\n测试套件：\n- 用例 1：$t=3$，插入从 $1$ 到 $30$ 的整数，枢轴键为 $11$，从该叶节点删除 $k=3$ 个键，禁用预减少。\n- 用例 2：$t=3$，插入从 $1$ 到 $30$ 的整数，枢轴键为 $11$，从该叶节点删除 $k=4$ 个键，禁用预减少。\n- 用例 3：$t=3$，插入从 $1$ 到 $30$ 的整数，枢轴键为 $11$，从该叶节点删除 $k=4$ 个键，启用预减少（在批量删除前将目标叶节点的两个兄弟节点都减少到 $t-1$ 个键）。\n- 用例 4：$t=2$，插入从 $1$ 到 $10$ 的整数，枢轴键为 $6$，从该叶节点删除 $k=3$ 个键，启用预减少。\n\n要求的输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素对应一个测试用例，并且本身必须是按顺序 $[$合并次数, 旋转次数, 高度, 有效性$]$ 排列的列表。例如：$[[m_1,r_1,h_1,v_1],[m_2,r_2,h_2,v_2],\\dots]$。",
            "solution": "设计必须从最小度为 $t$ 的B-树的核心不变量开始。每个非根节点必须包含至少 $t-1$ 个键和至多 $2t-1$ 个键，并且内部节点必须比键多一个子节点。除非树为空，否则根节点必须至少有 $1$ 个键。所有叶节点都在同一深度，每个子节点的键区间由父分隔符决定。任何删除算法都必须在节点发生下溢时恢复这些界限。\n\n当一次从单个叶节点中删除 $k$ 个键时，第一步是从该叶节点中移除这 $k$ 个键。假设该叶节点最初有 $m$ 个键。删除后，它有 $m-k$ 个键。如果 $m-k \\ge t-1$（并且该叶节点不是根节点），则没有下溢，操作完成。否则，存在一个数量为 $d = (t-1) - (m-k) > 0$ 的不足，必须通过父节点旋转从兄弟节点借用，或者与兄弟节点合并并向上递归修复来纠正。\n\n批量删除后的再平衡优化依赖于在一次局部计算中分析兄弟节点的剩余容量，而不是执行 $k$ 次单独的删除。如果叶节点在父节点中的索引是 $i$，定义左兄弟 $L$（如果子节点索引 $i>0$）和右兄弟 $R$（如果 $i$ 小于父节点中最后一个子节点的索引）。对于一个有 $\\ell_S$ 个键的兄弟节点 $S$，其超过最小值的富余量为 $\\max(0, \\ell_S-(t-1))$。可用于借用的总富余量是左、右富余量之和。每次借用操作对应一次标准的B-树旋转：\n\n- 从左兄弟借用使用父键 `parent.keys[i-1]`：将 `parent.keys[i-1]` 下移到下溢节点中，并在父节点中用左兄弟的最大键替换 `parent.keys[i-1]`；在内部节点的情况下，还要将左兄弟的最右侧子节点指针转移，成为下溢节点新的最左侧子节点。\n- 从右兄弟借用使用父键 `parent.keys[i]`：将 `parent.keys[i]` 下移到下溢节点中，并在父节点中用右兄弟的最小键替换 `parent.keys[i]`；在内部节点的情况下，还要将右兄弟的最左侧子节点指针转移，成为下溢节点新的最右侧子节点。\n\n如果可用富余量之和大于或等于不足量 $d$，那么一个消耗所需键数的多重旋转序列可以在不进行任何合并的情况下将叶节点恢复到最小值。为满足 $d$，首先贪婪地从左兄弟借用（最多借用其富余量），然后从右兄弟借用，因为旋转的成本严格低于合并：一次旋转是局部常数时间操作 $O(1)$，而一次合并会减少父节点的子节点数量，并可能导致父节点下溢，而这必须沿树向上递归修复。\n\n如果总富余量不足以满足 $d$，则与一个相邻的兄弟节点执行单次合并。选择存在的一侧；单次合并以最小的结构变化，最大限度地增加了添加到下溢节点中的键数。合并操作涉及将被合并的两个节点之间的相应父分隔符键下移，并连接键（如果是内部节点，还包括子节点），然后从父节点中移除该分隔符和多余的子节点。合并后，父节点失去一个键和一个子节点；如果父节点现在发生下溢（键数少于 $t-1$ 个，或者如果它是内部根节点则少于 $1$ 个键），我们必须在父节点级别上递归应用相同的借用或合并逻辑。这可以级联到根节点。如果根节点变为空且只有一个子节点，则将根节点收缩为其子节点，使高度减 $1$。\n\n正确性源于在每一步都维护B-树的不变量。旋转保持了节点内部的有序性和全局键区间属性，因为父分隔符保持其作用，并且借用的键通过父节点的移动方式与标准B-树删除完全相同。合并保持了区间属性，因为下移的父分隔符将两个相邻子节点的键正确排序。向上递归确保了任何父节点的下溢都以符合B-树规则的方式被修复。因为所有操作都发生在从根到叶的单一路径上，并可能向上级联，所以一次批量删除的时间复杂度为 $O(h + r + m)$，其中 $h$ 是树的高度，$r$ 是旋转次数，$m$ 是合并次数；通过优化，在兄弟节点富余量的约束下，合并次数被最小化，旋转次数受可用富余量的限制。在结构上，每次旋转和每次合并在单个节点上都是 $O(1)$ 操作，使得在典型的平衡场景中，总工作量为 $O(h)$。\n\n对于测试套件，程序通过插入整数来构建B-树，找到包含指定枢轴键的叶节点，并删除该叶节点内的 $k$ 个最小键。一个标志可以任选地在批量删除之前，将目标叶节点的两个直接兄弟节点都减少到恰好 $t-1$ 个键，以确保无法借用并需要进行合并，从而重点测试向上传播逻辑。在每个用例之后，程序输出合并次数、旋转次数、最终高度（根节点层计为高度 0）以及一个表示有效性的布尔值。最终输出按要求将四个用例的结果汇总成一个单行列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BTreeNode:\n    def __init__(self, t, leaf=False):\n        self.t = t\n        self.keys = []\n        self.children = []\n        self.leaf = leaf\n\n    def __repr__(self):\n        return f\"Node(keys={self.keys}, leaf={self.leaf})\"\n\n\nclass BTree:\n    def __init__(self, t):\n        self.t = t\n        self.root = BTreeNode(t, leaf=True)\n        self.rotations = 0\n        self.merges = 0\n\n    # Standard B-tree insertion (CLRS style)\n    def insert(self, k):\n        root = self.root\n        if len(root.keys) == 2*self.t - 1:\n            s = BTreeNode(self.t, leaf=False)\n            s.children.append(root)\n            self._split_child(s, 0)\n            self.root = s\n            self._insert_nonfull(s, k)\n        else:\n            self._insert_nonfull(root, k)\n\n    def _insert_nonfull(self, x, k):\n        i = len(x.keys) - 1\n        if x.leaf:\n            # insert in sorted order\n            x.keys.append(k)\n            i = len(x.keys) - 2\n            while i >= 0 and x.keys[i] > k:\n                x.keys[i+1] = x.keys[i]\n                i -= 1\n            x.keys[i+1] = k\n        else:\n            while i >= 0 and k  x.keys[i]:\n                i -= 1\n            i += 1\n            if len(x.children[i].keys) == 2*self.t - 1:\n                self._split_child(x, i)\n                if k > x.keys[i]:\n                    i += 1\n            self._insert_nonfull(x.children[i], k)\n\n    def _split_child(self, x, i):\n        t = self.t\n        y = x.children[i]\n        z = BTreeNode(t, leaf=y.leaf)\n        # median key at index t-1\n        median = y.keys[t-1]\n        # distribute keys\n        z.keys = y.keys[t:]\n        y.keys = y.keys[:t-1]\n        if not y.leaf:\n            z.children = y.children[t:]\n            y.children = y.children[:t]\n        x.children.insert(i+1, z)\n        x.keys.insert(i, median)\n\n    # Search returns node containing key or leaf where it would be inserted\n    def search(self, k):\n        return self._search_node(self.root, k)\n\n    def _search_node(self, x, k):\n        i = 0\n        while i  len(x.keys) and k > x.keys[i]:\n            i += 1\n        if i  len(x.keys) and k == x.keys[i]:\n            return x, i\n        if x.leaf:\n            return x, None\n        else:\n            return self._search_node(x.children[i], k)\n\n    # Find parent of a given node and child's index\n    def find_parent(self, current, target):\n        if current.leaf:\n            return None, None\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            if not child.leaf:\n                p, idx = self.find_parent(child, target)\n                if p is not None:\n                    return p, idx\n            else:\n                # continue\n                pass\n        # Try descending anyway based on key ranges to find parent in deeper subtrees\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            p, idx = self.find_parent(child, target)\n            if p is not None:\n                return p, idx\n        return None, None\n\n    # Helpers for rotations\n    def rotate_from_left(self, parent, idx):\n        # Borrow from left sibling into child at idx\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # Move parent separator down into node, replace parent separator with left's max key\n        # Also move child pointer for internal nodes\n        if node.leaf:\n            # insert parent key at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # replace parent key with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        else:\n            # node gains parent.sep at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # node must take left's last child to the front\n            child_to_move = left.children.pop()\n            node.children.insert(0, child_to_move)\n            # parent sep replaced with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        self.rotations += 1\n\n    def rotate_from_right(self, parent, idx):\n        right = parent.children[idx+1]\n        node = parent.children[idx]\n        if node.leaf:\n            # append parent key\n            node.keys.append(parent.keys[idx])\n            # replace parent key with right's first key\n            parent.keys[idx] = right.keys.pop(0)\n        else:\n            node.keys.append(parent.keys[idx])\n            child_to_move = right.children.pop(0)\n            node.children.append(child_to_move)\n            parent.keys[idx] = right.keys.pop(0)\n        self.rotations += 1\n\n    # Merge helpers\n    def merge_with_left(self, parent, idx):\n        # Merge child at idx with left sibling at idx-1\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # move parent separator down\n        left.keys.append(parent.keys[idx-1])\n        # concatenate node\n        left.keys.extend(node.keys)\n        if not left.leaf:\n            left.children.extend(node.children)\n        # remove from parent\n        parent.keys.pop(idx-1)\n        parent.children.pop(idx)\n        self.merges += 1\n        return left  # merged node reference\n\n    def merge_with_right(self, parent, idx):\n        node = parent.children[idx]\n        right = parent.children[idx+1]\n        # move parent separator down\n        node.keys.append(parent.keys[idx])\n        node.keys.extend(right.keys)\n        if not node.leaf:\n            node.children.extend(right.children)\n        parent.keys.pop(idx)\n        parent.children.pop(idx+1)\n        self.merges += 1\n        return node\n\n    # Fix underflow after deletions\n    def fix_underflow(self, node):\n        # If node is root, handle special cases\n        while True:\n            if node is self.root:\n                # If root is internal and empty with one child, collapse\n                if not node.leaf and len(node.keys) == 0 and len(node.children) == 1:\n                    self.root = node.children[0]\n                # Leaf root may be empty if tree emptied; nothing else to do\n                return\n            parent, idx = self.find_parent(self.root, node)\n            if parent is None:\n                # Should not happen\n                return\n            min_keys = (self.t - 1)\n            if len(node.keys) >= min_keys:\n                return\n            deficiency = min_keys - len(node.keys)\n            # calculate available surplus from siblings\n            # Try left\n            if idx - 1 >= 0:\n                left = parent.children[idx-1]\n                avail_left = len(left.keys) - (self.t - 1)\n            else:\n                left = None\n                avail_left = 0\n            # Try right\n            if idx + 1  len(parent.children):\n                right = parent.children[idx+1]\n                avail_right = len(right.keys) - (self.t - 1)\n            else:\n                right = None\n                avail_right = 0\n            # Borrow as much as possible\n            borrow_left = min(deficiency, max(0, avail_left))\n            for _ in range(borrow_left):\n                self.rotate_from_left(parent, idx)\n                deficiency -= 1\n                if deficiency == 0:\n                    break\n            if deficiency > 0:\n                borrow_right = min(deficiency, max(0, avail_right))\n                for _ in range(borrow_right):\n                    self.rotate_from_right(parent, idx)\n                    deficiency -= 1\n                    if deficiency == 0:\n                        break\n            # If still deficient, merge\n            if len(node.keys)  min_keys:\n                if left is not None:\n                    merged = self.merge_with_left(parent, idx)\n                    # After merge, set node to parent to check if parent underflows\n                    node = parent\n                    continue\n                elif right is not None:\n                    merged = self.merge_with_right(parent, idx)\n                    node = parent\n                    continue\n                else:\n                    # No siblings? Should not happen in B-tree except at root\n                    node = parent\n                    continue\n            else:\n                return\n\n    # Batch delete k smallest keys from leaf containing pivot key\n    def batch_delete_from_leaf_by_pivot(self, pivot_key, k, pre_reduce_siblings_to_min=False):\n        # Find leaf containing pivot key\n        node, idx = self.search(pivot_key)\n        # Ensure node is the leaf containing the key\n        # If the found node is internal (unlikely since search returns leaf when not found),\n        # traverse to leaf containing pivot_key\n        if not node.leaf:\n            # descend to the child where pivot would be\n            x = node\n            i = 0\n            while i  len(x.keys) and pivot_key > x.keys[i]:\n                i += 1\n            node = x.children[i]\n            while not node.leaf:\n                i = 0\n                while i  len(node.keys) and pivot_key > node.keys[i]:\n                    i += 1\n                node = node.children[i]\n        # Optionally pre-reduce siblings to minimum keys\n        if pre_reduce_siblings_to_min:\n            parent, child_idx = self.find_parent(self.root, node)\n            if parent is not None:\n                # Reduce left sibling\n                if child_idx - 1 >= 0:\n                    left = parent.children[child_idx-1]\n                    # delete from left to reach t-1 keys\n                    excess = len(left.keys) - (self.t - 1)\n                    if excess > 0:\n                        # delete excess smallest keys in left\n                        to_delete = left.keys[:excess]\n                        for key in to_delete:\n                            # Remove key from left\n                            left.keys.remove(key)\n                        # Fix underflow if created (shouldn't create underflow by removing surplus)\n                        # But if we removed too many due to earlier structure, still fix\n                        self.fix_underflow(left)\n                # Reduce right sibling\n                if child_idx + 1  len(parent.children):\n                    right = parent.children[child_idx+1]\n                    excess = len(right.keys) - (self.t - 1)\n                    if excess > 0:\n                        to_delete = right.keys[:excess]\n                        for key in to_delete:\n                            right.keys.remove(key)\n                        self.fix_underflow(right)\n        # Now delete k smallest keys in the target leaf\n        to_remove = node.keys[:min(k, len(node.keys))]\n        for key in to_remove:\n            # Remove key\n            node.keys.remove(key)\n        # Fix potential underflow\n        self.fix_underflow(node)\n\n    # Validation of B-tree invariants\n    def validate(self):\n        if self.root is None:\n            return True\n        # Check leaf depths\n        leaf_depths = []\n\n        def dfs(node, depth):\n            # keys sorted\n            if any(node.keys[i] >= node.keys[i+1] for i in range(len(node.keys)-1)):\n                return False\n            # bounds\n            if node is self.root:\n                # root can be leaf or internal\n                if node.leaf:\n                    # allow empty root leaf or between 1 and 2t-1 keys\n                    if len(node.keys) > 2*self.t - 1:\n                        return False\n                else:\n                    if len(node.keys)  1 or len(node.keys) > 2*self.t - 1:\n                        return False\n            else:\n                if len(node.keys)  self.t - 1 or len(node.keys) > 2*self.t - 1:\n                    return False\n            if not node.leaf:\n                if len(node.children) != len(node.keys) + 1:\n                    return False\n                for child in node.children:\n                    if child is None:\n                        return False\n            else:\n                leaf_depths.append(depth)\n            # recurse\n            if not node.leaf:\n                for child in node.children:\n                    if not dfs(child, depth+1):\n                        return False\n            return True\n\n        ok = dfs(self.root, 0)\n        if not ok:\n            return False\n        # All leaves same depth\n        if len(leaf_depths) == 0:\n            return True\n        return all(d == leaf_depths[0] for d in leaf_depths)\n\n    def height(self):\n        if self.root is None or not self.root.keys:\n            return 0\n        h = 0\n        node = self.root\n        while not node.leaf:\n            h += 1\n            node = node.children[0]\n        return h\n\n\ndef build_btree_with_range(t, start, end):\n    bt = BTree(t)\n    for k in range(start, end+1):\n        bt.insert(k)\n    return bt\n\n\ndef run_test_case(t, insert_range, pivot, k, pre_reduce=False):\n    bt = build_btree_with_range(t, insert_range[0], insert_range[1])\n    # perform batch deletion\n    bt.batch_delete_from_leaf_by_pivot(pivot, k, pre_reduce_siblings_to_min=pre_reduce)\n    # collect results\n    merges = bt.merges\n    rotations = bt.rotations\n    height = bt.height()\n    valid = bt.validate()\n    return [merges, rotations, height, valid]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: t=3, insert 1..30, pivot 11, k=3, no pre-reduction\n        (3, (1, 30), 11, 3, False),\n        # Case 2: t=3, insert 1..30, pivot 11, k=4, no pre-reduction\n        (3, (1, 30), 11, 4, False),\n        # Case 3: t=3, insert 1..30, pivot 11, k=4, pre-reduction enabled\n        (3, (1, 30), 11, 4, True),\n        # Case 4: t=2, insert 1..10, pivot 6, k=3, pre-reduction enabled\n        (2, (1, 10), 6, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        t, insert_range, pivot, k, pre_reduce = case\n        result = run_test_case(t, insert_range, pivot, k, pre_reduce)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}