{
    "hands_on_practices": [
        {
            "introduction": "Implementing a queue is a fundamental exercise, but doing so efficiently in a persistent manner requires a specific and clever design. This practice guides you through the classic two-list implementation, which achieves amortized $O(1)$ complexity for both enqueue and dequeue operations. By completing this exercise, you will gain a concrete understanding of immutability and structural sharing, which are the cornerstones of persistent data structures. ",
            "id": "3246712",
            "problem": "You are to implement, from first principles, a persistent First-In First-Out (FIFO) queue using singly linked lists, where any operation that conceptually changes the queue returns a new queue and leaves the original queue unmodified. Start from the core definitions: a queue is an abstract data type in which the element added earliest is removed first; a singly linked list consists of nodes, each with a value and a reference to the next node; a persistent data structure returns a new version on update without altering prior versions, enabling structural sharing between versions. You must ensure that no existing node in any prior version of the queue is mutated after its creation. The intended time complexity target is amortized $O(1)$ per enqueue and dequeue.\n\nImplement a complete, runnable program that defines:\n- An immutable singly linked node type for integers.\n- A queue type with operations that do not mutate existing nodes.\n- An operation $\\mathrm{enqueue}(q, x)$ that returns a new queue with the integer $x$ added at the back.\n- An operation $\\mathrm{dequeue}(q)$ that returns a triple $(s, v, q')$ where $s$ is a boolean indicating success, $v$ is the removed integer when $s$ is true, and $q'$ is the new queue. If $q$ is empty, then $s$ is false, $v$ must be $0$, and $q' = q$.\n- A function to compute the size of a queue, returning a nonnegative integer.\n\nYour program must not rely on any user input and must execute the following test suite internally. Each test case is a sequence of operations on persistent queues and must produce quantifiable results as integers or booleans, aggregated in the specified output format.\n\nTest Suite:\n- Test Case $A$ (happy path and persistence check):\n  1. Let $q_0$ be the empty queue.\n  2. Let $q_1 = \\mathrm{enqueue}(q_0, 1)$.\n  3. Let $q_2 = \\mathrm{enqueue}(q_1, 2)$.\n  4. Let $q_3 = \\mathrm{enqueue}(q_2, 3)$.\n  5. Perform $\\mathrm{dequeue}(q_3)$ yielding $(s_1, v_1, q_4)$.\n  6. Perform $\\mathrm{dequeue}(q_4)$ yielding $(s_2, v_2, q_5)$.\n  7. Perform $\\mathrm{dequeue}(q_3)$ yielding $(s_3, v_3, q_6)$.\n  Output for this test case must be the list $[v_1, v_2, v_3]$.\n\n- Test Case $B$ (rear-to-front reorganization edge):\n  1. Let $q_0$ be the empty queue.\n  2. Let $q_1 = \\mathrm{enqueue}(q_0, 10)$.\n  3. Let $q_2 = \\mathrm{enqueue}(q_1, 20)$.\n  4. Let $q_3 = \\mathrm{enqueue}(q_2, 30)$.\n  5. Let $q_4 = \\mathrm{enqueue}(q_3, 40)$.\n  6. Perform $\\mathrm{dequeue}(q_4)$ yielding $(s_4, v_4, q_5)$.\n  7. Perform $\\mathrm{dequeue}(q_5)$ yielding $(s_5, v_5, q_6)$.\n  Output for this test case must be the list $[v_4, v_5]$.\n\n- Test Case $C$ (empty boundary case):\n  1. Let $q_0$ be the empty queue.\n  2. Perform $\\mathrm{dequeue}(q_0)$ yielding $(s_0, v_0, q_1)$ with $s_0$ expected to be false and $v_0$ required to be $0$.\n  3. Let $q_2 = \\mathrm{enqueue}(q_0, 99)$.\n  4. Perform $\\mathrm{dequeue}(q_2)$ yielding $(s_6, v_6, q_3)$.\n  Output for this test case must be the list $[s_0, s_6, v_6]$.\n\nDesign for correctness and persistence: all operations must preserve immutability of existing nodes and return new queue instances as required. Your program should produce a single line of output containing the concatenated results of Test Case $A$, Test Case $B$, and Test Case $C$ as a comma-separated list enclosed in square brackets, in the exact order: $[v_1, v_2, v_3, v_4, v_5, s_0, s_6, v_6]$. No physical units, angles, or percentages are involved; all outputs are pure integers or booleans.",
            "solution": "The problem requires the implementation of a persistent First-In First-Out (FIFO) queue using singly linked lists. The implementation must be from first principles, ensuring that all operations are non-mutating (persistent) and that `enqueue` and `dequeue` operations achieve an amortized time complexity of $O(1)$.\n\nA persistent data structure, by definition, preserves previous versions of itself when modified. Any operation that conceptually alters the structure returns a new, modified instance while leaving the original instance untouched. This allows different versions of the data structure to coexist and share common substructures, which is both memory-efficient and crucial for certain functional programming paradigms and algorithms.\n\nA naive implementation of a queue using a single singly linked list fails to meet the performance requirement. A singly linked list naturally supports efficient, constant-time ($O(1)$) additions and removals at its head. If we use the head for `dequeue`, then `enqueue` must add elements to the tail. Finding the tail of a singly linked list requires traversing it from the head, an operation with linear time complexity, $O(n)$, where $n$ is the number of elements. This would make the `enqueue` operation unacceptably slow.\n\nTo achieve the desired amortized $O(1)$ complexity, the standard and correct approach is to represent the queue using two singly linked lists: a `front` list and a `rear` list.\n\nLet the state of a queue $q$ be represented by the pair of lists $(f, r)$, where $f$ is the `front` list and $r$ is the `rear` list.\n- The `front` list stores elements in the correct order for dequeuing. That is, the head of the `front` list is the oldest element in the queue.\n- The `rear` list stores newly enqueued elements in reverse order (like a stack). The head of the `rear` list is the most recently enqueued element.\n\nThe operations are designed as follows:\n- **`enqueue(q, x)`**: To add an element $x$ to the queue $q = (f, r)$, we create a new node for $x$ and prepend it to the `rear` list. A new queue instance $q' = (f, \\mathrm{cons}(x, r))$ is returned. The `front` list $f$ is shared, and because we only prepend to $r$, the original `rear` list is also shared. This is a purely local modification, creating only one new node, and is therefore an $O(1)$ operation.\n\n- **`dequeue(q)`**: This operation removes the element from the head of the queue. Let the queue be $q = (f, r)$.\n    1.  If the `front` list $f$ is non-empty, its head contains the oldest element. We return this element's value. The new queue state is $(f_{\\mathrm{tail}}, r)$, where $f_{\\mathrm{tail}}$ is the `front` list without its head. This is also an $O(1)$ operation as it only involves pointer manipulation and creating a new queue object that shares the existing list structures.\n    2.  If the `front` list $f$ is empty, it signifies that all elements previously positioned for dequeuing have been consumed. To proceed, we must move the elements from the `rear` list $r$ to the `front` list. Since the `rear` list stores elements in reverse order, we must perform a list reversal. We create a new list, $f'$, which is the reversal of $r$. This new list $f'$ becomes the `front` list of the queue, and the `rear` list becomes empty. This reversal operation has a time complexity of $O(k)$, where $k$ is the number of elements in the `rear` list. After this rebalancing, the queue state is effectively $(f', \\mathrm{empty\\_list})$, and we can proceed as in case $1$ by dequeuing from the head of $f'$.\n\nThe $O(k)$ cost of the reversal operation does not violate the amortized $O(1)$ complexity requirement. The cost of this single expensive `dequeue` operation can be distributed, or \"amortized,\" over the $k$ inexpensive `enqueue` operations that built the `rear` list. Each element in the queue is enqueued exactly once ($O(1)$), moved from the `rear` to the `front` list (i.e., part of a reversal) at most once (average cost $O(1)$), and dequeued exactly once ($O(1)$). Therefore, the average cost per operation remains constant.\n\nA critical aspect of persistence is that the reversal operation must not mutate the existing `rear` list. Instead, it must construct a completely new list of nodes that represent the reversed sequence. This ensures that any prior version of the queue that shares this `rear` list remains valid and unchanged. This property is explicitly tested by Test Case $A$, where `dequeue` is called on the same queue version, $q_3$, twice, requiring the operation to be repeatable and free of side effects.\n\nThe implementation will consist of an immutable `Node` class and a `PersistentQueue` class encapsulating the `front` and `rear` lists and the associated logic for the `enqueue`, `dequeue`, and `size` operations. An empty queue is a special case where both lists are empty. The `dequeue` operation on an empty queue returns a failure status, a placeholder value of $0$, and the original empty queue instance, as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a persistent FIFO queue and runs the specified test suite.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        An immutable singly linked list node for integers.\n        Immutability is by convention; attributes are not privately enforced.\n        \"\"\"\n        __slots__ = ('value', 'next')\n\n        def __init__(self, value: int, next_node=None):\n            self.value = value\n            self.next = next_node\n\n    def _reverse_list(node: Node | None) -> Node | None:\n        \"\"\"\n        Persistently reverses a singly linked list.\n        It creates a new list structure without mutating the original.\n        \"\"\"\n        new_head = None\n        current = node\n        while current:\n            new_head = Node(current.value, new_head)\n            current = current.next\n        return new_head\n\n    class PersistentQueue:\n        \"\"\"\n        A persistent FIFO queue implemented with two singly linked lists.\n        \"\"\"\n        # A cached singleton instance for the empty queue for efficiency.\n        _EMPTY_INSTANCE = None\n\n        def __init__(self, front: Node | None = None, rear: Node | None = None, size: int = 0):\n            \"\"\"\n            Private constructor. Use get_empty_queue() for the initial queue.\n            \"\"\"\n            self.front = front\n            self.rear = rear\n            self._size = size\n\n        @staticmethod\n        def get_empty_queue():\n            \"\"\"Factory method for creating or retrieving the empty queue instance.\"\"\"\n            if PersistentQueue._EMPTY_INSTANCE is None:\n                PersistentQueue._EMPTY_INSTANCE = PersistentQueue()\n            return PersistentQueue._EMPTY_INSTANCE\n        \n        def enqueue(self, value: int):\n            \"\"\"\n            Returns a new queue with the integer value added at the back.\n            Amortized time complexity: O(1).\n            \"\"\"\n            # Creates a new node and prepends it to the rear list.\n            return PersistentQueue(self.front, Node(value, self.rear), self._size + 1)\n\n        def dequeue(self):\n            \"\"\"\n            Returns a triple (success, value, new_queue).\n            If the queue is empty, success is False, value is 0, and a reference\n            to the same empty queue is returned.\n            Amortized time complexity: O(1).\n            \"\"\"\n            if self._size == 0:\n                return (False, 0, self)\n\n            # If the front list is not empty, we can dequeue from it directly.\n            if self.front is not None:\n                value = self.front.value\n                # The new queue shares the rear list.\n                new_queue = PersistentQueue(self.front.next, self.rear, self._size - 1)\n                return (True, value, new_queue)\n            \n            # If the front list is empty, the rear list must be reversed to become\n            # the new front list. This is the expensive step.\n            new_front = _reverse_list(self.rear)\n            value = new_front.value\n            # The new queue's rear list is now empty.\n            new_queue = PersistentQueue(new_front.next, None, self._size - 1)\n            return (True, value, new_queue)\n\n        def get_size(self) -> int:\n            \"\"\"\n            Returns the total number of elements in the queue.\n            Time complexity: O(1).\n            \"\"\"\n            return self._size\n\n    # --- Test Suite Execution ---\n    all_results = []\n\n    # Test Case A (happy path and persistence check)\n    q0_a = PersistentQueue.get_empty_queue()\n    q1_a = q0_a.enqueue(1)\n    q2_a = q1_a.enqueue(2)\n    q3_a = q2_a.enqueue(3)\n    s1, v1, q4_a = q3_a.dequeue()\n    s2, v2, q5_a = q4_a.dequeue()\n    s3, v3, q6_a = q3_a.dequeue() # Re-use q3 to check persistence\n    all_results.extend([v1, v2, v3])\n\n    # Test Case B (rear-to-front reorganization edge)\n    q0_b = PersistentQueue.get_empty_queue()\n    q1_b = q0_b.enqueue(10)\n    q2_b = q1_b.enqueue(20)\n    q3_b = q2_b.enqueue(30)\n    q4_b = q3_b.enqueue(40)\n    s4, v4, q5_b = q4_b.dequeue()\n    s5, v5, q6_b = q5_b.dequeue()\n    all_results.extend([v4, v5])\n\n    # Test Case C (empty boundary case)\n    q0_c = PersistentQueue.get_empty_queue()\n    s0, v0, q1_c = q0_c.dequeue()\n    q2_c = q0_c.enqueue(99)\n    s6, v6, q3_c = q2_c.dequeue()\n    all_results.extend([s0, s6, v6])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from simple lists to array-based structures, this exercise explores how to add persistence to a Fenwick tree, a powerful tool for prefix-sum queries. You will implement partial persistence using the \"fat node\" technique, where each logical node maintains a time-ordered history of its values. This allows you to query the state of the data structure at any point in the past, a common requirement in analytics and version control systems. ",
            "id": "3258634",
            "problem": "Implement from first principles a partially persistent Fenwick tree (also known as a Binary Indexed Tree) that supports historical prefix-sum queries. You must base your design and analysis on core definitions of partial persistence in data structures and the standard structure and invariants of Fenwick trees, without invoking or assuming any prebuilt persistence framework. You will also instrument the number of key comparisons performed by the binary searches used during historical lookups, and report both the numeric prefix sum and the comparison count for each query in a provided test suite.\n\nA partially persistent data structure allows queries to be made on any historical version while restricting updates to the latest version. Consider an array $A$ of length $n$ where version $0$ is initialized to all zeros. An update operation at logical time $t \\in \\{1,2,\\dots\\}$ produces version $t$ from version $t-1$ by applying a point increment to one index $p \\in \\{1,2,\\dots,n\\}$ by an integer offset $\\Delta$. A historical prefix-sum query is parameterized by a version $v$ and a prefix index $i \\in \\{0,1,\\dots,n\\}$, and asks for the sum of $A[1] + A[2] + \\dots + A[i]$ as of version $v$. The prefix index $i=0$ is defined to return the sum $0$.\n\nYou must implement a Fenwick tree of size $n$ where the cell at index $j$ stores the partial sum over the range of indices that are covered by the least significant set bit of $j$. To make it partially persistent, at each Fenwick index $j$ you will maintain a time-ordered sequence of pairs $(t, \\mathrm{val})$, where $t$ is the logical time of the update that last changed the value at that Fenwick index and $\\mathrm{val}$ is the Fenwick cell’s value after that update. Initialize each index with the base pair $(0,0)$ so that queries at version $0$ are well-defined. Each update at time $t$ must visit $O(\\log n)$ Fenwick indices and append one new pair at each visited index with time $t$ and the updated value. A historical prefix-sum query at version $v$ and prefix index $i$ must perform the usual Fenwick traversal from $i$ downward, and at each visited Fenwick index $j$ perform a binary search over its time-ordered sequence to retrieve the most recent value with time $\\le v$. The sum of these retrieved values over the traversal is the answer.\n\nInstrument the binary searches as follows. For each binary search performed at a Fenwick index, count one comparison for each evaluation of a predicate of the form “current time $\\le v$?” during the search. The total comparison count for a query is the sum of these counts over all Fenwick indices visited by that query’s traversal. Report, for each query, a pair $[S,C]$ where $S$ is the integer historical prefix sum and $C$ is the integer total number of time comparisons performed by all binary searches during that query.\n\nYou must implement and run your solution on the following test suite. First, construct a partially persistent Fenwick tree for an array of length $n=8$ and apply the following sequence of $8$ updates in order, producing versions $t=1$ through $t=8$:\n\n- At time $t=1$: add $\\Delta=+5$ at position $p=3$.\n- At time $t=2$: add $\\Delta=-2$ at position $p=5$.\n- At time $t=3$: add $\\Delta=+7$ at position $p=1$.\n- At time $t=4$: add $\\Delta=+4$ at position $p=8$.\n- At time $t=5$: add $\\Delta=+3$ at position $p=3$.\n- At time $t=6$: add $\\Delta=-1$ at position $p=2$.\n- At time $t=7$: add $\\Delta=+6$ at position $p=5$.\n- At time $t=8$: add $\\Delta=+2$ at position $p=7$.\n\nAfter building the versions $t=0,1,\\dots,8$, evaluate the following historical prefix-sum queries $(v,i)$:\n\n- $(v=0,i=8)$\n- $(v=1,i=3)$\n- $(v=5,i=5)$\n- $(v=7,i=5)$\n- $(v=8,i=8)$\n- $(v=8,i=0)$\n- $(v=5,i=3)$\n- $(v=4,i=4)$\n\nYour program must output a single line containing the results in the exact following aggregated format: a single list of the $8$ results, where each result is itself a two-element list $[S,C]$ with no spaces anywhere in the output. For example, the format must be like $[[S_1,C_1],[S_2,C_2],\\dots,[S_8,C_8]]$ with the numbers filled in by your program.\n\nYour implementation and analysis must satisfy the following constraints, derived from core definitions:\n\n- Use the standard Fenwick tree traversal invariants to update and query in $O(\\log n)$ visited indices.\n- Achieve partial persistence by appending versioned values, never mutating historical entries, and selecting historical values via binary search at query time.\n- Count comparisons exactly as one per binary search predicate evaluation; do not approximate.\n\nThe answer for each test case must be a list of integers. The final program must produce the single-line output in the required format with the eight $[S,C]$ pairs computed by your implementation.",
            "solution": "The user requires an implementation of a partially persistent Fenwick tree (also known as a Binary Indexed Tree or BIT). I will first validate the problem statement and then proceed with a detailed, principle-based solution.\n\n### Step 1: Extract Givens\n\n- **Data Structure**: Partially Persistent Fenwick Tree (Binary Indexed Tree).\n- **Array Size `n`**: $8$.\n- **Indexing**: The problem specifies array positions $p \\in \\{1, 2, \\dots, n\\}$ and prefix indices $i \\in \\{0, 1, \\dots, n\\}$. Fenwick trees are naturally implemented with $1$-based indexing for convenience, which aligns with the problem's specification for $p$ and $i > 0$.\n- **Initial State (Version 0)**: An array $A$ of length $n$ initialized to all zeros. This implies the Fenwick tree cells are also all zero at logical time $t=0$.\n- **Update Operation**: At logical time $t$, add an integer offset $\\Delta$ to the element at position $p$. This creates version $t$ from version $t-1$. Updates are restricted to the latest version.\n- **Query Operation**: A historical prefix-sum query $(v, i)$ asks for $\\sum_{k=1}^{i} A[k]$ as of version $v$. For $i=0$, the sum is defined to be $0$.\n- **Persistence Mechanism**: Each Fenwick tree index $j$ must store a time-ordered sequence of pairs $(t, \\text{val})$, representing the value of that tree cell at time $t$. The initial state for each index $j$ is $(0, 0)$. Updates append a new $(t, \\text{val})$ pair to the sequences of affected indices. Queries on version $v$ must find the latest value at or before time $v$ for each required index.\n- **Value Retrieval**: For a query $(v,i)$, the value for each Fenwick index $j$ in the query path is found by performing a binary search on its time-ordered sequence to retrieve the value from the pair $(t, \\text{val})$ with the largest $t \\le v$.\n- **Instrumentation**: For each query, count the total number of comparisons performed during all binary searches. A single comparison is one evaluation of the predicate \"current time $\\le v$?\".\n- **Output Format**: For each query, a pair $[S, C]$ where $S$ is the sum and $C$ is the comparison count. The final output must be a single line containing a list of these pairs, e.g., $[[S_1,C_1],[S_2,C_2],\\dots]$.\n- **Update Sequence**:\n    1. $t=1$: $p=3, \\Delta=+5$\n    2. $t=2$: $p=5, \\Delta=-2$\n    3. $t=3$: $p=1, \\Delta=+7$\n    4. $t=4$: $p=8, \\Delta=+4$\n    5. $t=5$: $p=3, \\Delta=+3$\n    6. $t=6$: $p=2, \\Delta=-1$\n    7. $t=7$: $p=5, \\Delta=+6$\n    8. $t=8$: $p=7, \\Delta=+2$\n- **Query Sequence**:\n    1. $(v=0, i=8)$\n    2. $(v=1, i=3)$\n    3. $(v=5, i=5)$\n    4. $(v=7, i=5)$\n    5. $(v=8, i=8)$\n    6. $(v=8, i=0)$\n    7. $(v=5, i=3)$\n    8. $(v=4, i=4)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation check.\n- **Scientifically Grounded**: Yes. The problem describes a well-known, albeit advanced, data structure that combines the principles of Fenwick trees and partial persistence. These are standard topics in computer science and algorithms.\n- **Well-Posed**: Yes. The initial state, operations, constraints, and desired output are all specified unambiguously. The test suite provides concrete inputs for which a unique, computable solution exists.\n- **Objective**: Yes. The problem is stated in precise, formal language, free of subjectivity or opinion.\n- **Flaw Checklist**: The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, and well-structured. It represents a non-trivial algorithmic challenge.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed.\n\n### Solution Design\n\nThe core of the solution lies in designing a `PartiallyPersistentFenwickTree` class that encapsulates the required state and operations.\n\n**Data Structure**\nA Fenwick tree for an array of size $n$ can be represented by an array (or list) of size $n+1$, using $1$-based indexing. To achieve partial persistence as described, each element of this Fenwick tree array will not be a single value, but a list of versioned values.\n- Let `self.tree` be a list of lists, of size $n+1$.\n- `self.tree[j]` will store a time-ordered list of tuples, `(time, value)`, for the Fenwick tree index $j$.\n- A logical time counter, `self.current_time`, will track the current version number, starting at $0$.\n\n**Initialization**\nThe constructor `__init__(self, size)` will:\n1.  Set the size, `self.n = size`.\n2.  Initialize `self.current_time = 0`.\n3.  Initialize `self.tree` as a list of $n+1$ empty lists. Then, for each index $j$ from $1$ to $n$, populate `self.tree[j]` with an initial entry `(0, 0)`. This establishes the base version $v=0$ where the array is all zeros.\n\n**Update Operation**\nThe method `update(self, p, delta)` will perform a point update at position $p$ with value $\\Delta$:\n1.  Increment the logical time: `self.current_time += 1`.\n2.  Follow the standard Fenwick tree update path. Start with `idx = p`.\n3.  While `idx <= self.n`:\n    a. Retrieve the most recent value for the Fenwick index `idx`. Since updates are always on the latest version, this value is simply the last one in the list `self.tree[idx]`. Let its value be `prev_val`.\n    b. Calculate the new value: `new_val = prev_val + delta`.\n    c. Append the new versioned entry `(self.current_time, new_val)` to the list `self.tree[idx]`.\n    d. Move to the next index in the path: `idx += idx & -idx` (where `&` is the bitwise AND operator).\n\n**Historical Query Operation**\nThe method `query(self, version, i)` will compute the prefix sum up to index $i$ at a specific historical version $v$.\n1.  Handle the base case: if $i = 0$, return a sum of $0$ and $0$ comparisons, as per the problem definition.\n2.  Initialize `total_sum = 0` and `total_comparisons = 0`.\n3.  Follow the standard Fenwick tree query path. Start with `idx = i`.\n4.  While `idx > 0`:\n    a. At the current Fenwick index `idx`, find the correct historical value. This requires a search on `self.tree[idx]` for the entry `(t, val)` with the largest time $t$ such that $t \\le \\text{version}$.\n    b. This search will be implemented as a manual binary search to precisely count comparisons. The binary search will operate on the list `self.tree[idx]`.\n        - Let the list be `history`. Initialize `low = 0`, `high = len(history) - 1`, `ans_idx = 0` (guaranteed to be safe by the `(0,0)` entry), and `comps = 0`.\n        - While `low <= high`:\n            - `mid = low + (high - low) // 2`.\n            - Increment `comps`.\n            - If `history[mid][0] <= version`, it's a candidate. Store its index `ans_idx = mid` and search for a later time: `low = mid + 1`.\n            - Otherwise, `history[mid][0] > version`. The time is too recent. Search earlier: `high = mid - 1`.\n        - The resulting value is `history[ans_idx][1]`.\n    c. Add the found value to `total_sum`.\n    d. Add the number of comparisons from the binary search to `total_comparisons`.\n    e. Move to the next index in the path: `idx -= idx & -idx`.\n5.  Return the pair `[total_sum, total_comparisons]`.\n\nThis design correctly implements the specified logic for a partially persistent Fenwick tree and its instrumentation. The time complexity for an update is $O(\\log n)$ since it appends to $O(\\log n)$ lists. A query has a complexity of $O(\\log n \\cdot \\log M)$, where $M$ is the number of updates, because it performs $O(\\log n)$ binary searches on lists of version entries.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass PartiallyPersistentFenwickTree:\n    \"\"\"\n    Implements a partially persistent Fenwick tree (Binary Indexed Tree).\n    \n    This data structure supports point updates on the latest version and historical\n    prefix-sum queries on any past version.\n    \n    Persistence is achieved by storing a time-ordered list of values at each node\n    of the tree, rather than mutating values in place. Historical queries are\n    resolved by performing a binary search on these lists.\n    \"\"\"\n    def __init__(self, size: int):\n        \"\"\"\n        Initializes the persistent Fenwick tree.\n        \n        Args:\n            size: The size of the conceptual array (n). The tree will be of size n+1\n                  to accommodate 1-based indexing.\n        \"\"\"\n        self.n = size\n        self.current_time = 0\n        \n        # self.tree[j] stores a list of (time, value) pairs for Fenwick index j.\n        # We use 1-based indexing for the tree.\n        self.tree = [[] for _ in range(self.n + 1)]\n        \n        # Initialize version 0: all values are 0.\n        for j in range(1, self.n + 1):\n            self.tree[j].append((0, 0))\n\n    def _find_value_at_version(self, tree_idx: int, version: int) -> tuple[int, int]:\n        \"\"\"\n        Finds the value of a tree node at a specific historical version.\n        \n        This is done by binary searching the time-ordered list of values for the\n        given tree index to find the most recent entry at or before the target version.\n        \n        Args:\n            tree_idx: The 1-based index in the Fenwick tree.\n            version: The historical version (logical time) to query.\n            \n        Returns:\n            A tuple (value, comparisons), where 'value' is the historical value and\n            'comparisons' is the count of comparisons made during the binary search.\n        \"\"\"\n        history = self.tree[tree_idx]\n        low, high = 0, len(history) - 1\n        ans_idx = 0  # The initial (0, 0) entry guarantees a valid answer.\n        comparisons = 0\n        \n        while low <= high:\n            mid = low + (high - low) // 2\n            mid_time, _ = history[mid]\n            \n            comparisons += 1\n            if mid_time <= version:\n                # This is a valid candidate; try to find a more recent one.\n                ans_idx = mid\n                low = mid + 1\n            else:\n                # This entry is too recent; search in the past.\n                high = mid - 1\n                \n        return history[ans_idx][1], comparisons\n\n    def update(self, p: int, delta: int):\n        \"\"\"\n        Applies a point update to the latest version of the array.\n        \n        This creates a new version of the data structure.\n        \n        Args:\n            p: The 1-based position in the conceptual array to update.\n            delta: The value to add at position p.\n        \"\"\"\n        self.current_time += 1\n        idx = p\n        while idx <= self.n:\n            # For a partially persistent structure where updates are only on the\n            # latest version, the previous value is always the last one in the list.\n            _, prev_value = self.tree[idx][-1]\n            new_value = prev_value + delta\n            self.tree[idx].append((self.current_time, new_value))\n            \n            # Move to the parent node in the Fenwick tree.\n            idx += idx & -idx\n\n    def query(self, version: int, i: int) -> list[int]:\n        \"\"\"\n        Performs a historical prefix-sum query.\n        \n        Calculates the sum of the first i elements of the array as of the\n        specified version.\n        \n        Args:\n            version: The historical version (logical time) to query.\n            i: The 0-based prefix index. Sum is A[1] + ... + A[i].\n               If i=0, the sum is 0.\n            \n        Returns:\n            A list [S, C], where S is the prefix sum and C is the total number\n            of comparisons performed during the query's binary searches.\n        \"\"\"\n        if i == 0:\n            return [0, 0]\n        \n        total_sum = 0\n        total_comparisons = 0\n        idx = i\n        while idx > 0:\n            value, comps = self._find_value_at_version(idx, version)\n            total_sum += value\n            total_comparisons += comps\n            \n            # Move to the next node in the Fenwick tree's query path.\n            idx -= idx & -idx\n            \n        return [total_sum, total_comparisons]\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print the results.\n    \"\"\"\n    # Define the problem size, updates, and queries.\n    n = 8\n    updates = [\n        (3, 5),   # t=1\n        (5, -2),  # t=2\n        (1, 7),   # t=3\n        (8, 4),   # t=4\n        (3, 3),   # t=5\n        (2, -1),  # t=6\n        (5, 6),   # t=7\n        (7, 2),   # t=8\n    ]\n    queries = [\n        (0, 8),\n        (1, 3),\n        (5, 5),\n        (7, 5),\n        (8, 8),\n        (8, 0),\n        (5, 3),\n        (4, 4),\n    ]\n\n    # Instantiate and build the persistent Fenwick tree\n    pp_ft = PartiallyPersistentFenwickTree(n)\n    for p, delta in updates:\n        pp_ft.update(p, delta)\n\n    # Execute queries and collect results\n    results = []\n    for v, i in queries:\n        result = pp_ft.query(v, i)\n        results.append(result)\n\n    # Format the output string exactly as required (no spaces).\n    inner_parts = [f\"[{s},{c}]\" for s, c in results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "This advanced practice tackles the challenge of making a highly optimized, imperative algorithm—the Disjoint Set Union (DSU) with path compression—persistent. You will discover that naively applying path compression would violate immutability by altering past versions of the structure. The solution requires a careful design that combines the \"fat node\" approach with a form of path copying, demonstrating how to handle complex, state-altering operations in a purely functional way. ",
            "id": "3258660",
            "problem": "You are asked to design and implement a partially persistent Disjoint Set Union (DSU), also known as Union-Find, that supports path compression and union by rank or size, while preserving previous versions. The persistence must be partial in the sense that any update creates a new version and does not mutate earlier versions. The implementation must be fully functional and must run as a complete program.\n\nFundamental base to use:\n- The DSU maintains a partition of a finite set of elements into disjoint equivalence classes. An equivalence relation satisfies reflexivity, symmetry, and transitivity. Two elements are in the same set if and only if their representatives (roots) are identical.\n- Union by size (or rank) attaches the smaller tree under the larger tree to maintain balanced forests and improve time complexity.\n- Path compression modifies parent pointers along the search path to point directly to the root, reducing future find costs.\n- Partial persistence can be achieved via fat nodes: each array cell stores a history of updates as pairs of version identifiers and values, and queries retrieve the value as of a specified version by searching this history.\n\nDesign constraints:\n- Let the universe be the set of elements indexed by integers from $0$ to $n-1$.\n- Version identifiers are integers, starting at $0$ for the initial version in which every element is a singleton set.\n- A union operation takes a base version $v_{\\text{base}}$ and two elements $a$ and $b$, computes their roots in $v_{\\text{base}}$ with path compression applied in the newly created version $v_{\\text{new}}$, and then unites the two sets by size. In case of equal sizes, attach the larger-indexed root under the smaller-indexed root to ensure determinism. The operation outputs the identifier $v_{\\text{new}}$.\n- A find operation takes a version $v$ and an element $x$ and returns the representative element (root) of $x$ in version $v$.\n- A connectivity query takes a version $v$ and two elements $a$ and $b$ and returns whether $a$ and $b$ have the same representative in version $v$.\n- Path compression must only affect the newly created version; earlier versions must remain unchanged.\n\nInput and output requirements:\n- There is no external input. Your program must construct the data structure and execute the specified sequence of operations.\n- All numeric outputs must be integers or booleans; there are no physical units involved.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nTest suite specification:\n- Initialize the DSU with $n = 8$ elements in version $0$.\n- Perform the following operations, where unions create new versions by incrementing the global version counter:\n    1. $v_1 = \\text{union}(0, 0, 1)$.\n    2. $v_2 = \\text{union}(v_1, 2, 3)$.\n    3. $v_3 = \\text{union}(v_2, 1, 3)$.\n    4. Query $\\text{connected}(v_3, 0, 3)$, record the boolean.\n    5. Query $\\text{connected}(v_2, 0, 3)$, record the boolean.\n    6. $v_4 = \\text{union}(v_3, 4, 5)$.\n    7. $v_5 = \\text{union}(v_4, 5, 6)$.\n    8. $v_6 = \\text{union}(v_5, 6, 7)$.\n    9. Query $\\text{connected}(v_6, 4, 7)$, record the boolean.\n    10. Query $\\text{connected}(v_3, 7, 4)$, record the boolean.\n    11. $v_7 = \\text{union}(v_6, 0, 4)$.\n    12. Query $\\text{connected}(v_7, 2, 7)$, record the boolean.\n    13. Query $\\text{find}(v_7, 7)$, record the integer representative.\n    14. $v_8 = \\text{union}(v_7, 3, 7)$.\n    15. Query $\\text{connected}(v_8, 1, 6)$, record the boolean.\n    16. $v_9 = \\text{union}(v_2, 2, 2)$.\n    17. Query $\\text{connected}(v_2, 2, 2)$, record the boolean.\n    18. Query $\\text{find}(v_2, 3)$, record the integer representative.\n- Your program must output all recorded results aggregated in order as a single list on one line, formatted as, for example, $[\\text{result}_1,\\text{result}_2,\\dots]$.\n\nCorrectness expectations:\n- The design must strictly preserve older versions, meaning any union or path compression performed while creating version $v_{\\text{new}}$ must not alter lookups in any version $v < v_{\\text{new}}$.\n- Union by size with the specified tie-breaking rule must be applied when merging two distinct sets.\n- Finds performed against existing versions must not compress paths in those versions; only union creates compressed paths in the new version via path copying into $v_{\\text{new}}$.\n\nYour implementation must be a complete, runnable program that builds the persistent DSU, executes the operations, and prints the results in the specified format. The output values must be booleans and integers only, and must follow exactly the single-line aggregation format requirement.",
            "solution": "The problem statement is valid. It concerns the design and implementation of a partially persistent Disjoint Set Union (DSU) data structure, a well-defined topic in computer science. The requirements for its functionality, including path compression, union by size, and persistence, are specified clearly and consistently. The problem is self-contained, providing a complete test suite and output format, making it scientifically grounded, well-posed, and objective. There are no contradictions, ambiguities, or violations of scientific principles.\n\nThe solution implements a partially persistent DSU by employing the \"fat node\" technique, as suggested by the problem description. In this model, each property of an element in the DSU is not a single value but a history of values over time. The state of the DSU is defined by a parent array, $parent$, and a size array, $size$. For a universe of $n$ elements indexed $0, \\dots, n-1$, we maintain:\n- $parent$: A list of lists, where $parent[i]$ stores the history of the parent of element $i$.\n- $size$: A list of lists, where $size[i]$ stores the history of the size of the set for which $i$ is the root.\n\nEach history list, for example $parent[i]$, contains tuples of the form $(v, p)$, where $v$ is the version identifier (an integer) and $p$ is the parent of element $i$ starting from version $v$. These history lists are kept sorted by version number. The initial state, version $0$, is constructed by making each element its own parent with a size of $1$: for each element $i \\in \\{0, \\dots, n-1\\}$, $parent[i] = [(0, i)]$ and $size[i] = [(0, 1)]$.\n\nTo retrieve the value of a property (parent or size) for an element $i$ at a specific version $v$, we must find the most recent update recorded at or before version $v$. This is efficiently accomplished using binary search on the corresponding history list. Specifically, we find the index of the rightmost tuple $(v', \\text{val})$ such that $v' \\le v$. The value part of this tuple, $\\text{val}$, is the effective value at version $v$.\n\nThe operations are implemented as follows:\n\n1.  $\\text{find}(v, x)$: This operation determines the representative (root) of element $x$ in version $v$. It is a read-only query that does not alter the state of any version. The implementation iteratively follows the parent pointers from $x$ up to the root. At each step, it retrieves the parent of the current element for the specified version $v$ using the binary search method described above. This process continues until an element is found to be its own parent.\n\n2.  $\\text{connected}(v, a, b)$: This is a straightforward query that returns a boolean indicating whether elements $a$ and $b$ belong to the same set in version $v$. It is implemented by calling $\\text{find}(v, a)$ and $\\text{find}(v, b)$ and checking if their results are identical.\n\n3.  $\\text{union}(v_{\\text{base}}, a, b)$: This is the core update operation. It creates a new version, $v_{\\text{new}}$, which is one greater than the latest existing version. The procedure is as follows:\n    a. The roots of elements $a$ and $b$ are found as they exist in the state of the DSU at $v_{\\text{base}}$. During this root-finding process, the paths from $a$ and $b$ to their respective roots are recorded.\n    b. If the roots are identical, the elements are already in the same set. No merge is necessary, and the operation completes, having simply created a new, but structurally identical, version $v_{\\text{new}}$.\n    c. If the roots are different, a merge is performed. The union-by-size heuristic is applied. The sizes of the two sets (rooted at the found roots) are retrieved from version $v_{\\text{base}}$. The root of the smaller set (the `loser_root`) is attached to the root of the larger set (the `winner_root`). The problem specifies a tie-breaking rule: if the sizes are equal, the root with the larger index is attached to the root with the smaller index.\n    d. Path compression is performed for the new version $v_{\\text{new}}$. All nodes on the paths from $a$ and $b$ to their pre-union roots have their parent pointer updated to point directly to the final `winner_root`. This is recorded by appending a new tuple $(v_{\\text{new}}, \\text{winner\\_root})$ to the parent history of each node on both paths.\n    e. The union is finalized by also setting the parent of the `loser_root` to the `winner_root` in version $v_{\\text{new}}$, again by appending $(v_{\\text{new}}, \\text{winner\\_root})$ to the history of $parent[\\text{loser\\_root}]$.\n    f. Finally, the size of the `winner_root`'s set is updated in version $v_{\\text{new}}$ to be the sum of the two original set sizes. This is recorded by appending $(v_{\\text{new}}, \\text{new\\_size})$ to the history of $size[\\text{winner\\_root}]$.\n    g. The identifier for the new version, $v_{\\text{new}}$, is returned.\n\nThis design strictly adheres to the principles of partial persistence. All updates are recorded for $v_{\\text{new}}$, leaving all prior versions $v < v_{\\text{new}}$ entirely unmodified and accessible.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport bisect\n\nclass PersistentDSU:\n    \"\"\"\n    Implements a partially persistent Disjoint Set Union (DSU) data structure\n    using the \"fat node\" approach, where each node maintains a history of its\n    parent and size across different versions.\n    \"\"\"\n    def __init__(self, n: int):\n        \"\"\"\n        Initializes the DSU with n elements. In version 0, each element\n        is in its own set.\n        \"\"\"\n        self.n = n\n        # Parent history for each element. parent[i] is a list of (version, value).\n        self.parent = [[(0, i)] for i in range(n)]\n        # Size history for each element. Only meaningful for roots.\n        self.size = [[(0, 1)] for i in range(n)]\n        # The latest version number created. Starts at 0.\n        self.latest_version = 0\n\n    def _get_value_at_version(self, history: list, version: int) -> int:\n        \"\"\"\n        Retrieves the value from a history list for a specific version\n        using binary search.\n        \"\"\"\n        # bisect_right finds an insertion point which comes after (to the right of)\n        # any existing entries of (version, ...). idx-1 gives the last entry\n        # with version <= the query version.\n        idx = bisect.bisect_right(history, (version, float('inf')))\n        return history[idx - 1][1]\n\n    def _find_path_and_root(self, version: int, i: int) -> tuple[int, list[int]]:\n        \"\"\"\n        Finds the root of element i at a given version and records the path.\n        This is a helper for both find() and union(). It does not perform mutations.\n        \"\"\"\n        path = []\n        current_node = i\n        while True:\n            parent_node = self._get_value_at_version(self.parent[current_node], version)\n            if current_node == parent_node:\n                break\n            path.append(current_node)\n            current_node = parent_node\n        root = current_node\n        return root, path\n\n    def find(self, version: int, i: int) -> int:\n        \"\"\"\n        Finds the representative (root) of element i at a given version.\n        This is a read-only operation.\n        \"\"\"\n        root, _ = self._find_path_and_root(version, i)\n        return root\n\n    def connected(self, version: int, a: int, b: int) -> bool:\n        \"\"\"\n        Checks if elements a and b are in the same set at a given version.\n        \"\"\"\n        return self.find(version, a) == self.find(version, b)\n\n    def union(self, base_version: int, a: int, b: int) -> int:\n        \"\"\"\n        Performs a union of the sets containing a and b, based on the state at\n        base_version. This creates a new version.\n        \"\"\"\n        new_version = self.latest_version + 1\n        self.latest_version = new_version\n\n        root_a, path_a = self._find_path_and_root(base_version, a)\n        root_b, path_b = self._find_path_and_root(base_version, b)\n\n        if root_a != root_b:\n            size_a = self._get_value_at_version(self.size[root_a], base_version)\n            size_b = self._get_value_at_version(self.size[root_b], base_version)\n\n            if size_a < size_b:\n                winner_root, loser_root = root_b, root_a\n            elif size_b < size_a:\n                winner_root, loser_root = root_a, root_b\n            else:  # Equal sizes, use tie-breaker\n                if root_a < root_b:\n                    winner_root, loser_root = root_a, root_b\n                else:\n                    winner_root, loser_root = root_b, root_a\n\n            # Path compression for the new version: all nodes on the paths point to the final winner root.\n            for node in path_a:\n                self.parent[node].append((new_version, winner_root))\n            for node in path_b:\n                self.parent[node].append((new_version, winner_root))\n\n            # Union: point loser root to winner root in the new version.\n            self.parent[loser_root].append((new_version, winner_root))\n\n            # Update size of the winner root in the new version.\n            self.size[winner_root].append((new_version, size_a + size_b))\n        \n        # A new version is created even if the elements are already in the same set.\n        return new_version\n\ndef solve():\n    \"\"\"\n    Executes the specified test suite for the PersistentDSU.\n    \"\"\"\n    dsu = PersistentDSU(n=8)\n    results = []\n    \n    # The version numbers are returned by union operations and stored in variables\n    # v1, v2, ... corresponding to the problem description.\n    # Version 0 is the initial state.\n    \n    # 1. v1 = union(0, 0, 1)\n    v1 = dsu.union(0, 0, 1)\n    \n    # 2. v2 = union(v1, 2, 3)\n    v2 = dsu.union(v1, 2, 3)\n    \n    # 3. v3 = union(v2, 1, 3)\n    v3 = dsu.union(v2, 1, 3)\n    \n    # 4. Query connected(v3, 0, 3)\n    results.append(dsu.connected(v3, 0, 3))\n    \n    # 5. Query connected(v2, 0, 3)\n    results.append(dsu.connected(v2, 0, 3))\n    \n    # 6. v4 = union(v3, 4, 5)\n    v4 = dsu.union(v3, 4, 5)\n    \n    # 7. v5 = union(v4, 5, 6)\n    v5 = dsu.union(v4, 5, 6)\n    \n    # 8. v6 = union(v5, 6, 7)\n    v6 = dsu.union(v5, 6, 7)\n    \n    # 9. Query connected(v6, 4, 7)\n    results.append(dsu.connected(v6, 4, 7))\n    \n    # 10. Query connected(v3, 7, 4)\n    results.append(dsu.connected(v3, 7, 4))\n    \n    # 11. v7 = union(v6, 0, 4)\n    v7 = dsu.union(v6, 0, 4)\n    \n    # 12. Query connected(v7, 2, 7)\n    results.append(dsu.connected(v7, 2, 7))\n    \n    # 13. Query find(v7, 7)\n    results.append(dsu.find(v7, 7))\n    \n    # 14. v8 = union(v7, 3, 7)\n    v8 = dsu.union(v7, 3, 7)\n    \n    # 15. Query connected(v8, 1, 6)\n    results.append(dsu.connected(v8, 1, 6))\n    \n    # 16. v9 = union(v2, 2, 2)\n    v9 = dsu.union(v2, 2, 2)\n    \n    # 17. Query connected(v2, 2, 2)\n    results.append(dsu.connected(v2, 2, 2))\n    \n    # 18. Query find(v2, 3)\n    results.append(dsu.find(v2, 3))\n\n    # Convert boolean True/False to lowercase \"true\"/\"false\" if needed,\n    # but standard str() gives \"True\"/\"False\" which is also common. Sticking to standard.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}