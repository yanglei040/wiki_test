{
    "hands_on_practices": [
        {
            "introduction": "掌握数据结构不变量的第一步是能够验证它们。本练习将带你深入二叉堆的核心，通过编写一个函数来检查数组是否满足最小堆属性。这个实践不仅能巩固你对堆不变量定义的理解，还能让你思考验证过程的计算效率极限，即为何线性时间 $O(n)$ 是最优的。",
            "id": "3226029",
            "problem": "给定一个长度为 $n$、基于零索引的数组 $A$，它旨在表示一个在全序集上的二叉堆。对于一个二叉最小堆，其堆属性不变量要求：对于每个索引 $i$，若其左子节点索引 $2i+1$ 小于 $n$，则不等式 $A[i] \\le A[2i+1]$ 成立；对于每个索引 $i$，若其右子节点索引 $2i+2$ 小于 $n$，则不等式 $A[i] \\le A[2i+2]$ 成立。使用二叉堆的标准数组表示法（其中索引为 $j$ 的节点的父节点索引为 $\\lfloor (j-1)/2 \\rfloor$），设计并实现一个函数 $\\texttt{is\\_heap}(A)$，该函数在 $O(n)$ 时间内检查 $A$ 是否满足二叉最小堆不变量，其中 $n$ 是 $A$ 的长度。该检查必须对所有实数数组都详尽且正确，不能遗漏任何违规情况；你可以假设 $A$ 的所有元素都是实数，并且没有特殊的非数值。\n\n你的任务是：\n- 从第一性原理出发，推导为什么该检查可以在 $O(n)$ 时间内完成，并从二叉堆不变量的核心定义和基于数组的父子索引关系开始，指定一个达到此时间界限的算法。\n- 依据来自比较计算模型的可靠下界推理，严谨地论证为什么在最坏情况下，没有任何算法能以渐近快于 $O(n)$ 的时间正确地判断此属性。\n\n为了实现和测试，请编写一个完整、可运行的程序，该程序：\n- 定义 $\\texttt{is\\_heap}(A)$ 并返回一个布尔值，指示输入数组 $A$ 是否满足二叉最小堆不变量。\n- 使用基于零的索引，并在相应的子节点索引在边界内时，检查左、右子节点的不等式。\n- 在下面提供的测试套件上运行，并按要求的确切格式生成单行输出。\n\n测试套件（每个 $A$ 是一个整数列表，解释为实数）：\n- 情况 1：$A = []$。\n- 情况 2：$A = [42]$。\n- 情况 3：$A = [1,3,2,7,8,9]$。\n- 情况 4：$A = [1,2,3,4,5,0]$。\n- 情况 5：$A = [2,1,3]$。\n- 情况 6：$A = [0,0,0,0,0]$。\n- 情况 7：$A = [-5,-3,-4,-2,-1]$。\n- 情况 8：$A = [0,1,1,2,2,2,2]$。\n- 情况 9：$A = [0,1,2,3,4,5,6,7,8,9,-1]$。\n- 情况 10：$A = [1,1]$。\n- 情况 11：$A = [1,0]$。\n\n你的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为方括号括起来的逗号分隔列表，例如 \"[$r_1,r_2,\\dots,r_{11}$]\"，其中每个 $r_i$ 是相应的 $\\texttt{True}$ 或 $\\texttt{False}$。此问题不涉及物理单位，也不需要角度单位或百分比格式。最终输出格式必须是精确的一行，没有多余的空格或文本。",
            "solution": "该问题要求设计、分析并实现一个函数，以验证一个给定长度为 $n$ 的数组 $A$ 是否遵循二叉最小堆不变量。\n\n### 1. 问题形式化与第一性原理\n\n二叉堆是一种完全二叉树结构，通常以数组格式存储。对于一个长度为 $n$、基于零索引的数组 $A$，其父子关系定义如下：\n- 索引为 $i$ 的节点的子节点位于索引 $2i+1$（左子节点）和 $2i+2$（右子节点）。\n- 索引为 $j > 0$ 的节点的父节点位于索引 $\\lfloor (j-1)/2 \\rfloor$。\n\n二叉最小堆不变量要求，对于任何节点，其值必须小于或等于其子节点的值。形式上，对于数组中的每个索引 $i$：\n- 如果存在左子节点（即其索引 $2i+1  n$），则不等式 $A[i] \\le A[2i+1]$ 必须成立。\n- 如果存在右子节点（即其索引 $2i+2  n$），则不等式 $A[i] \\le A[2i+2]$ 必须成立。\n\n没有子节点的节点称为叶节点。对于叶节点，堆不变量是空真（vacuously true）的。因此，我们只需要对非叶节点（父节点）进行检查。\n\n### 2. 算法设计与上界分析\n\n我们的目标是设计一个在 $O(n)$ 时间内为所有适用节点验证最小堆不变量的算法。\n\n**识别非叶节点：**\n一个索引为 $i$ 的节点是非叶节点，当且仅当它至少有一个子节点。由于左子节点索引 $2i+1$ 总是小于或等于右子节点索引 $2i+2$，因此如果一个节点 $i$ 的左子节点在数组边界内，那么它就是一个父节点。即 $2i+1  n$。\n这个不等式可以重新整理以找到父节点的索引范围：\n$2i  n-1$\n$i  (n-1)/2$\n由于索引 $i$ 必须是整数，父节点的最大索引是 $\\lfloor (n-2)/2 \\rfloor$。因此，父节点占据了从 $0$ 到 $\\lfloor (n-2)/2 \\rfloor$ 的索引 $i$。\n\n**算法：**\n基于此，我们可以制定一个直接的算法：\n1. 从 $0$ 开始遍历所有可能的父节点索引 $i$，直到（并包括）$\\lfloor (n-2)/2 \\rfloor$。\n2. 对每个索引 $i$：\n   a. 定义左子节点索引为 $l = 2i+1$，右子节点索引为 $r = 2i+2$。\n   b. 检查左子节点：如果 $A[i] > A[l]$，则不变量被违反。算法可以立即终止并返回 `False`。\n   c. 检查右子节点：如果右子节点存在（即 $r  n$）并且 $A[i] > A[r]$，则不变量被违反。终止并返回 `False`。\n3. 如果循环完成而未发现任何违规，则意味着不变量对所有非叶节点都成立。该数组表示一个有效的最小堆，因此返回 `True`。\n4. 特殊情况：如果 $n \\le 1$，数组最多包含一个节点。没有父子关系需要检查，因此根据定义，这样的数组是一个有效的堆。\n\n**时间复杂度分析（上界）：**\n该算法从 $i=0$ 迭代到 $i=\\lfloor (n-2)/2 \\rfloor$。迭代次数为 $\\lfloor (n-2)/2 \\rfloor + 1$。对于 $n>1$，这个数字与 $n$ 成正比。对于 $n=0$ 或 $n=1$，循环体不会进入，这需要常数时间，与分析一致。在循环内部，执行常数数量的操作：两次索引计算，最多两次边界检查，以及最多两次值比较。总操作数与迭代次数成正比，大约是 $n/2$。因此，该算法的时间复杂度是 $O(n)$。\n\n### 3. 下界分析与最优性\n\n我们现在将论证，任何正确确定数组是否为最小堆的基于比较的算法，在最坏情况下都必须花费 $\\Omega(n)$ 的时间。\n\n**对抗论证：**\n该论证通过证明任何以亚线性时间（即 $o(n)$）运行的算法必定在某些输入上失败来展开。一个以 $o(n)$ 时间运行的算法无法检查数组的所有 $n$ 个元素。\n1. 假设存在一个能正确判断堆属性的算法，但对于某个特定的输入数组 $A_1$，它不检查某个索引 $k$ 处的元素。该算法必须根据它所检查的元素返回 `True` 或 `False`。\n2. 让我们构造一个最坏情况。假设对手提供一个输入数组 $A_1$，它是一个有效的最小堆（例如，所有元素都为 $0$）。让该算法在 $A_1$ 上运行。由于 $A_1$ 是一个堆，算法必须返回 `True`。假设在这次运行中，算法没有读取索引 $k$ 处的值，其中 $k>0$。\n3. 节点 $k$ 的父节点位于索引 $p = \\lfloor (k-1)/2 \\rfloor$。在数组 $A_1$ 中，堆属性 $A_1[p] \\le A_1[k]$ 是满足的。\n4. 现在，对手构造一个新数组 $A_2$，它在除 $k$ 之外的所有位置都与 $A_1$ 相同。在索引 $k$ 处，对手设置 $A_2[k] = A_1[p] - 1$。\n5. 在数组 $A_2$ 中，堆不变量被违反，因为 $A_2[p] = A_1[p]$，因此 $A_2[p] > A_2[k]$。所以，$A_2$ 不是一个有效的最小堆。\n6. 当假定的算法在 $A_2$ 上运行时，它将遵循与在 $A_1$ 上完全相同的执行路径。这是因为它比较的所有值在两个数组中都是相同的，因为它从未读取索引 $k$ 处的值，而这是它们唯一不同的位置。\n7. 因此，该算法必须为 $A_2$ 生成与为 $A_1$ 相同的输出，即 `True`。这对于 $A_2$ 来说是一个错误的结果。\n8. 这个矛盾证明了，为了保证正确性，任何算法在最坏情况下都必须读取 $k \\in \\{1, \\dots, n-1\\}$ 的每个元素 $A[k]$。通过对 $k=0$ 的类似论证（通过将其值更改为大于其某个子节点的值），$A[0]$ 也必须被读取。\n9. 因此，任何正确的算法在最坏情况下都必须读取数组的所有 $n$ 个元素。从内存中读取 $n$ 个元素至少需要 $n$ 次操作，因此时间复杂度的下界为 $\\Omega(n)$。\n\n**关于最优性的结论：**\n由于我们有一个上界为 $O(n)$ 的算法，并且我们为该问题建立了一个 $\\Omega(n)$ 的下界，所以我们的算法是渐近最优的。验证最小堆属性的复杂度是 $\\Theta(n)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_heap(A: list[float]) -> bool:\n    \"\"\"\n    Checks if an array A satisfies the binary min-heap invariant.\n    Time complexity: O(n), where n is the length of A.\n    Space complexity: O(1).\n    \"\"\"\n    n = len(A)\n    # An empty or single-element array is trivially a min-heap.\n    if n = 1:\n        return True\n\n    # The last parent node is at index floor((n-2)/2).\n    # We iterate through all parent nodes from the root down to this last parent.\n    # The Python range() function correctly handles the upper bound.\n    last_parent_index = (n - 2) // 2\n    for i in range(last_parent_index + 1):\n        # The index of the left child is 2*i + 1.\n        # This child is guaranteed to be within the array bounds because\n        # i = (n-2)/2 implies 2*i + 1 = n-1.\n        left_child_index = 2 * i + 1\n\n        # Check the min-heap property with the left child.\n        if A[i] > A[left_child_index]:\n            return False\n\n        # The index of the right child is 2*i + 2.\n        # This child may be out of bounds, so we must check.\n        right_child_index = 2 * i + 2\n        if right_child_index  n:\n            # If the right child exists, check the min-heap property with it.\n            if A[i] > A[right_child_index]:\n                return False\n\n    # If the loop completes, no violations were found.\n    return True\n\ndef solve():\n    \"\"\"\n    Runs the is_heap function on a predefined test suite and prints the results.\n    \"\"\"\n    # Test suite as provided in the problem statement.\n    test_cases = [\n        [],                            # Case 1\n        [42],                          # Case 2\n        [1, 3, 2, 7, 8, 9],            # Case 3\n        [1, 2, 3, 4, 5, 0],            # Case 4\n        [2, 1, 3],                     # Case 5\n        [0, 0, 0, 0, 0],               # Case 6\n        [-5, -3, -4, -2, -1],          # Case 7\n        [0, 1, 1, 2, 2, 2, 2],         # Case 8\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1], # Case 9\n        [1, 1],                        # Case 10\n        [1, 0],                        # Case 11\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_heap(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "当不变量被破坏时，我们如何高效地定位并修复问题？这个练习提出了一个巧妙的场景：通过为一个堆结构增加一个辅助不变量（子树元素和），我们可以在对数时间 $O(\\log n)$ 内找到并修复单个被破坏的元素。这项练习挑战你跳出常规的堆操作，利用增强的数据来维护结构的完整性，这是一种在设计健壮系统时非常有用的思想。",
            "id": "3226005",
            "problem": "给定一个以数组表示的二叉最小堆，使用从 $0$ 开始的索引。二叉最小堆的基本不变量规定：对于每个索引为 $i$ 的节点，如果其左子节点的索引为 $\\ell = 2i+1$，右子节点的索引为 $r = 2i+2$，那么当这些子节点索引存在时，键值必须满足 $A[i] \\le A[\\ell]$ 和 $A[i] \\le A[r]$。形状不变量是完全二叉树属性，它确保对于 $n$ 个元素，堆的高度 $h$ 满足 $h = \\lfloor \\log_2 n \\rfloor$，因此任何从根到叶子的路径长度均为 $O(\\log n)$。\n\n除了最小堆不变量，我们为每个索引 $i$ 定义子树和函数 $T(i)$，即以节点 $i$ 为根的子树中所有键值的总和（包括节点 $i$ 本身）。您会收到两个子树和数组：\n- $S^{\\text{orig}}$，原始、正确的堆（损坏前）的可信子树和。\n- $S^{\\text{curr}}$，根据当前、已损坏的堆数组计算出的子树和。\n\n堆数组 $H$ 中只有一个元素的键值被损坏；所有其他位置保持不变。没有发生节点的重新排序。您的任务是利用这些不变量，在 $O(\\log n)$ 时间内通过遍历一条从根到叶子的路径来定位被损坏的索引并恢复其原始键值。在每一步中，您必须使用子树和来决定哪个子节点包含损坏，并在到达被损坏的节点时，通过从其自身的可信子tree sum中减去其子节点的可信子树和来计算其原始键值。形式上，如果被损坏的索引是 $j$，其原始键值 $x_j$ 必须满足\n$$\nx_j = S^{\\text{orig}}[j] \\;-\\; \\left( \\text{child exists? } S^{\\text{orig}}[\\ell] \\text{ else } 0 \\right) \\;-\\; \\left( \\text{child exists? } S^{\\text{orig}}[r] \\text{ else } 0 \\right),\n$$\n其中 $\\ell = 2j+1$ 和 $r = 2j+2$。\n\n实现一个程序，为每个测试案例执行以下操作：\n- 给定 $H$、$S^{\\text{orig}}$ 和 $S^{\\text{curr}}$，从索引 $0$ 开始，重复地向下进入其 $S^{\\text{curr}}$ 值与 $S^{\\text{orig}}$ 值不一致的唯一子节点，从而找到唯一的被损坏索引 $j$（如果在某个节点处两个子节点的值都不存在不一致，那么该节点就是被损坏的索引）。\n- 使用上述公式计算 $x_j$ 并设置 $H[j] := x_j$ 来修复堆。\n\n您不能扫描整个数组；逻辑必须依赖于每层 $O(1)$ 的检查，并且只遍历一条长度为 $O(\\log n)$ 的路径。\n\n测试套件：\n为以下参数集提供解决方案。对于每个案例，数组按普通顺序列出，所有数字均为整数。\n\n- 案例 1：\n  - $H = [3,7,10,12,14,40,25]$\n  - $S^{\\text{orig}} = [88,33,52,12,14,17,25]$\n  - $S^{\\text{curr}} = [111,33,75,12,14,40,25]$\n- 案例 2：\n  - $H = [20,4,3,8,9,7,5]$\n  - $S^{\\text{orig}} = [37,21,15,8,9,7,5]$\n  - $S^{\\text{curr}} = [56,21,15,8,9,7,5]$\n- 案例 3：\n  - $H = [2,4,6,9,10,-1]$\n  - $S^{\\text{orig}} = [43,23,18,9,10,12]$\n  - $S^{\\text{curr}} = [30,23,5,9,10,-1]$\n- 案例 4：\n  - $H = [99]$\n  - $S^{\\text{orig}} = [5]$\n  - $S^{\\text{curr}} = [99]$\n- 案例 5：\n  - $H = [2,6,4,7,8,9,10]$\n  - $S^{\\text{orig}} = [43,18,23,7,8,9,10]$\n  - $S^{\\text{curr}} = [46,21,23,7,8,9,10]$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个结果都必须是修复损坏元素后修正过的堆数组，以 Python 列表语法打印。例如，五个案例的输出应在单行上显示为 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n输出中的所有答案都是纯整数；不涉及物理单位、角度或百分比。",
            "solution": "### 1. 问题分析与核心洞察\n\n问题的核心是利用一个辅助不变量——每个节点的子树和——来高效定位并修复堆中的单个损坏元素。给定原始正确的子树和数组 $S^{\\text{orig}}$ 和当前损坏状态下的子树和数组 $S^{\\text{curr}}$。\n\n关键洞察在于，当堆中仅有一个元素 $H[j]$ 的值被改变时，这个改变只会影响到节点 $j$ 及其所有祖先节点的子树和。对于任何其他节点 $k$（即非 $j$ 的祖先且非 $j$ 本身），其子树不包含节点 $j$，因此其子树和 $S^{\\text{curr}}[k]$ 将与 $S^{\\text{orig}}[k]$ 保持一致。\n\n这个性质意味着，从根节点开始，损坏的元素必定位于其子树和不一致的那个子节点的子树中。这为我们提供了一个从根向下的、对数时间的搜索路径。\n\n### 2. 算法设计\n\n基于上述洞察，我们可以设计一个高效的定位算法：\n\n1.  **定位损坏节点：**\n    a.  从根节点开始，令 `current_idx = 0`。\n    b.  在一个循环中，只要 `current_idx` 仍在数组范围内，就检查其子节点：\n        i.  计算左子节点索引 `l = 2 * current_idx + 1` 和右子节点索引 `r = 2 * current_idx + 2`。\n        ii. 检查左子树：如果左子节点存在（`l  n`）并且 `S_curr[l] != S_orig[l]`，说明损坏发生在左子树中。我们将搜索范围缩小到左子树，更新 `current_idx = l` 并继续循环。\n        iii. 检查右子树：否则，如果右子节点存在（`r  n`）并且 `S_curr[r] != S_orig[r]`，说明损坏发生在右子树中。更新 `current_idx = r` 并继续循环。\n        iv. 如果两个子节点的子树和都与原始值一致（或子节点不存在），则说明损坏的节点就是 `current_idx` 本身。此时，`current_idx` 必定是损坏元素的索引 `j`。跳出循环。\n    c.  循环结束后，`current_idx` 就是我们找到的损坏节点的索引 `j`。\n\n2.  **恢复原始值：**\n    a.  根据子树和的定义：$T(i) = H[i] + (\\text{如果存在则为 } T(\\text{左子节点})) + (\\text{如果存在则为 } T(\\text{右子节点}))$。\n    b.  我们可以推导出节点自身的值：$H[i] = T(i) - T(\\text{左子节点}) - T(\\text{右子节点})$。\n    c.  使用可信的 $S^{\\text{orig}}$ 数组，我们可以计算出节点 $j$ 的原始值 $x_j$：\n        $x_j = S^{\\text{orig}}[j] - (\\text{如果左子节点 } l \\text{ 存在则为 } S^{\\text{orig}}[l] \\text{，否则为 } 0) - (\\text{如果右子节点 } r \\text{ 存在则为 } S^{\\text{orig}}[r] \\text{，否则为 } 0)$。\n    d.  将计算出的原始值 $x_j$ 赋给 $H[j]$，完成修复。\n\n### 3. 复杂度分析\n\n-   **时间复杂度：** 定位算法每次迭代都从父节点移动到其一个子节点，本质上是在堆中沿着一条从根到叶的路径向下遍历。由于堆是完全二叉树，其高度为 $\\lfloor \\log_2 n \\rfloor$。因此，定位损坏节点的时间复杂度为 $O(\\log n)$。恢复值的计算是 $O(1)$ 的操作。总时间复杂度为 $O(\\log n)$。\n-   **空间复杂度：** 该算法只需要少量变量来存储当前索引和子节点索引，因此其辅助空间复杂度为 $O(1)$。\n\n该算法满足了问题的所有要求，即在对数时间内高效地找到并修复损坏的元素。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_and_correct(H, S_orig, S_curr):\n    \"\"\"\n    Finds the single corrupted element in a heap and restores its original value.\n\n    Args:\n        H (list): The corrupted heap array.\n        S_orig (list): The trusted subtree sums of the original heap.\n        S_curr (list): The subtree sums of the current (corrupted) heap.\n\n    Returns:\n        list: The corrected heap array.\n    \"\"\"\n    H_arr = np.array(H)\n    S_orig_arr = np.array(S_orig)\n    S_curr_arr = np.array(S_curr)\n    n = len(H_arr)\n\n    if n == 0:\n        return []\n\n    current_idx = 0\n    while current_idx  n:\n        l_child_idx = 2 * current_idx + 1\n        r_child_idx = 2 * current_idx + 2\n        \n        found_in_child = False\n        \n        # Check if corruption is in the left subtree\n        if l_child_idx  n and S_curr_arr[l_child_idx] != S_orig_arr[l_child_idx]:\n            current_idx = l_child_idx\n            found_in_child = True\n        # If not in left, check if corruption is in the right subtree\n        elif r_child_idx  n and S_curr_arr[r_child_idx] != S_orig_arr[r_child_idx]:\n            current_idx = r_child_idx\n            found_in_child = True\n        \n        # If corruption is in neither child's subtree, it must be the current node\n        if not found_in_child:\n            break\n            \n    corrupted_idx = current_idx\n    \n    # Restore the original value using the trusted subtree sum array\n    l_child_idx = 2 * corrupted_idx + 1\n    r_child_idx = 2 * corrupted_idx + 2\n    \n    s_orig_at_j = S_orig_arr[corrupted_idx]\n    \n    s_orig_of_l_child = 0\n    if l_child_idx  n:\n        s_orig_of_l_child = S_orig_arr[l_child_idx]\n        \n    s_orig_of_r_child = 0\n    if r_child_idx  n:\n        s_orig_of_r_child = S_orig_arr[r_child_idx]\n        \n    original_key = s_orig_at_j - s_orig_of_l_child - s_orig_of_r_child\n    \n    H_arr[corrupted_idx] = int(original_key)\n    \n    return H_arr.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([3,7,10,12,14,40,25], [88,33,52,12,14,17,25], [111,33,75,12,14,40,25]),\n        ([20,4,3,8,9,7,5], [37,21,15,8,9,7,5], [56,21,15,8,9,7,5]),\n        ([2,4,6,9,10,-1], [43,23,18,9,10,12], [30,23,5,9,10,-1]),\n        ([99], [5], [99]),\n        ([2,6,4,7,8,9,10], [43,18,23,7,8,9,10], [46,21,23,7,8,9,10])\n    ]\n\n    results = []\n    for case in test_cases:\n        H, S_orig, S_curr = case\n        corrected_H = find_and_correct(H, S_orig, S_curr)\n        results.append(corrected_H)\n    \n    # Use repr() to get the list's string representation, which matches Python syntax\n    # then join them.\n    results_str = ','.join(map(str, results))\n    print(f'[{results_str}]')\n\nsolve()\n```"
        },
        {
            "introduction": "不变量不仅用于验证和修复，更是设计高效算法的基石。本练习要求你设计一个算法，以在线方式实时计算最长递增子序列的长度，并达到对数级的更新效率 $O(\\log n)$。解决这个经典问题的关键在于发现并维护一个非直观但极其强大的不变量，这个过程将深刻揭示不变量在算法设计中的创造性力量。",
            "id": "3226049",
            "problem": "你的任务是设计并实现一个在线算法，用于维护一个整数流的最长递增子序列（LIS）的长度，并且每次新元素到达时的更新时间为对数级别。该算法必须基于序列和子序列的基本定义，并依赖于一个精确的数据结构不变量来保证其正确性和效率。\n\n从以下基本定义开始：\n- 序列的子序列是通过删除零个或多个元素而不改变其余元素顺序得到的。\n- 递增子序列是其元素严格递增的子序列。\n- 序列的最长递增子序列（LIS）的长度是其所有递增子序列中的最大长度。\n\n设计一个数据结构，在接收到流中的每个新整数时，能在与 $\\log n$ 成正比的时间内更新其内部状态（其中 $n$ 是目前已见元素的数量），并且能在任何时刻报告已见前缀的 LIS 长度。你的设计必须通过一个关于在处理每个元素后维护的内部辅助序列或树的单一、精确的不变量来证明其合理性。该不变量必须足以证明算法的正确性和 $\\log n$ 的更新时间。算法必须将“递增”视为严格递增。\n\n將此設計實現為一個程式，該程式处理一组固定的测试流，并为每个流报告在处理完整个流后的最终 LIS 长度。实现必须反映这种由不变量驱动的设计。\n\n测试流套件：\n- 流 A: $\\left[\\,1,5,2,3,4\\,\\right]$\n- 流 B: $\\left[\\,5,4,3,2,1\\,\\right]$\n- 流 C: $\\left[\\,2,2,2,2\\,\\right]$\n- 流 D: $\\left[\\,\\,\\right]$ (空流)\n- 流 E: $\\left[\\,10,9,2,5,3,7,101,18\\,\\right]$\n- 流 F: $\\left[\\,0,-1,-2,-3\\,\\right]$\n- 流 G: $\\left[\\,1,3,5,4,7\\,\\right]$\n- 流 H: $\\left[\\,1,2,3,4,5\\,\\right]$\n- 流 I: $\\left[\\,3,3,3,3,4\\,\\right]$\n- 流 J: $\\left[\\,3,1,2,1,8,5,6\\,\\right]$\n\n额外要求与说明：\n- LIS 必须是严格递增的；相等的连续值不会增加长度。\n- 所有整数都在标准的 $32$ 位有符号范围内。\n- 不涉及物理单位。\n- 你的算法每次元素的更新必须是 $\\mathcal{O}(\\log n)$，并且只能使用基于数组的二分搜索或由你选择的不变量证明的等效平衡树结构。处理每个流的总时间应为 $\\mathcal{O}(n \\log n)$，最坏情况下的辅助空间为 $\\mathcal{O}(n)$。\n- 必须正确处理边界情况，包括重复值、负数和空流。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含流 A 到 J 的最终 LIS 长度，按顺序排列，形式为用逗号分隔并用方括号括起来的列表，例如 $\\left[\\text{resultA},\\text{resultB},\\dots,\\text{resultJ}\\right]$。",
            "solution": "该问题要求设计并实现一个在线算法，用于寻找整数流的最长递增子序列（LIS）的长度。该算法每个元素的更新时间必须为 $\\mathcal{O}(\\log n)$，其中 $n$ 是已处理的元素数量。这一性能约束要求采用比标准的 $\\mathcal{O}(n^2)$ 动态规划解法更复杂的方法。所要求的算法基于一个特定的数据结构不变量。\n\n设输入流为一个序列 $X = \\left[\\,x_1, x_2, \\dots, x_m\\,\\right]$。我们从 $i=1$ 到 $m$ 逐一处理 $X$ 的元素。为了达到期望的时间复杂度，我们维护一个辅助数组，记为 $T$。这个数组本身不存储 LIS，而是存储能让我们高效确定其长度的信息。\n\n该算法的核心体现在以下不变量中：\n\n**不变量：** 处理完输入流的前 $i$ 个元素后，当前长度为 $L$ 的辅助数组 $T$ 是严格排序的，并且对于从 $0$ 到 $L-1$ 的每个 $k$，$T[k]$ 是在元素 $x_1, \\dots, x_i$ 中，可以构成长度为 $k+1$ 的严格递增子序列的最小结尾值。\n\n因此，前缀 $x_1, \\dots, x_i$ 的 LIS 长度等于 $T$ 的当前长度 $L$。\n\n我们现在演示如何维护这个不变量，以及它如何得出正确的 LIS 长度。\n\n**通过归纳法证明正确性：**\n\n**基本情况：** 在处理任何元素之前（$i=0$），流是空的。我们的辅助数组 $T$ 也是空的。LIS 长度为 $0$，这等于 $T$ 的长度。不变量不言自明地成立。\n\n**归纳步骤：** 假设在处理完前 $i-1$ 个元素后不变量成立。设数组的状态为长度是 $L_{i-1}$ 的 $T_{i-1}$。我们现在处理下一个元素 $x_i$。我们希望在我们的结构中为 $x_i$ 找到一个位置。具体来说，我们想找到一个 $x_i$ 可以扩展的递增子序列。一个长度为 $k$ 的递增子序列以值 $T_{i-1}[k-1]$ 结尾。要让 $x_i$ 扩展这个子序列，我们必须有 $x_i > T_{i-1}[k-1]$。\n\n由于数组 $T_{i-1}$ 是排序的（根据不变量），我们可以使用二分搜索来找到 $T_{i-1}$ 中大于或等于 $x_i$ 的最小元素。这等同于在 $T_{i-1}$ 中找到 $x_i$ 的插入点，以保持其排序顺序。设这个索引为 $j$。形式上，$j$ 是满足 $T_{i-1}[j] \\ge x_i$ 的最小索引。在一个长度为 $L_{i-1}$ 的零索引数组中，$j$ 的取值范围可以从 $0$ 到 $L_{i-1}$。\n\n我们考虑 $j$ 值的两种情况：\n\n**情况1：$x_i$ 大于 $T_{i-1}$ 中的所有元素。**\n在这种情况下，二分搜索将返回一个等于数组当前长度 $L_{i-1}$ 的索引 $j$。这表示 $x_i$ 可以扩展目前为止找到的最长递增子序列。到元素 $x_{i-1}$ 为止的 LIS 长度为 $L_{i-1}$，并以值 $T_{i-1}[L_{i-1}-1]$ 结尾。由于 $x_i > T_{i-1}[L_{i-1}-1]$，我们可以通过附加 $x_i$ 形成一个长度为 $L_{i-1}+1$ 的新的、更长的递增子序列。这个新的子序列是第一个被发现的具有此长度的子序列，所以根据定义，它的结尾元素 $x_i$ 是任何具有这个新长度的递增子序列的最小可能结尾元素。为了维护不变量，我们将 $x_i$ 附加到 $T$。新的数组 $T_i$ 长度为 $L_i = L_{i-1}+1$。LIS 长度增加了 $1$。\n\n**情况2：$x_i$ 不大于 $T_{i-1}$ 中的所有元素。**\n二分搜索返回一个索引 $j  L_{i-1}$。这意味着在 $T_{i-1}$ 中至少有一个元素大于或等于 $x_i$，并且 $T_{i-1}[j]$ 是其中最小的。这告诉我们 $x_i$ 不能扩展已知的最长递增子序列（长度为 $L_{i-1}$）。但是，$x_i$可以用来形成一个长度为 $j+1$ 的递增子序列。\n根据索引 $j$ 的定义，我们有 $T_{i-1}[j-1]  x_i \\le T_{i-1}[j]$（对于 $j>0$）。这意味着 $x_i$可以扩展任何长度为 $j$ 且以小于 $x_i$ 的值结尾的递增子序列（例如以 $T_{i-1}[j-1]$ 结尾的子序列）。通过这样做，我们形成了一个以 $x_i$ 结尾的、长度为 $j+1$ 的递增子序列。根据我们的不变量，$T_{i-1}[j]$ 是任何长度为 $j+1$ 的递增子序列的最小结尾元素。既然我们找到了一个以 $x_i$ 结尾的、长度为 $j+1$ 的新子序列，并且 $x_i \\le T_{i-1}[j]$，我们就找到了一个“更好”的、具有此长度的子序列——一个结尾更小的子序列。一个更小的结尾是更可取的，因为它增加了未来元素扩展此子序列的可能性。\n为了维护不变量，我们通过设置 $T_i[j] = x_i$ 来更新 $T$。$T$ 的长度不变，所以 $L_i = L_{i-1}$。LIS 长度保持不变，但内部状态 $T$ 被更新，以反映长度为 $j+1$ 的子序列的新的、最小的结尾。\n\n在这两种情况下，更新 $T$ 之后，它仍然保持严格排序并维护了不变量。在处理完流中的所有 $m$ 个元素后，$T$ 的最终长度就是整个流的 LIS 长度。\n\n**算法复杂度分析：**\n- **时间复杂度：** 对于输入流中的 $n$ 个元素中的每一个，算法对数组 $T$ 执行一次二分搜索。$T$ 的长度最多为 $n$。一次二分搜索需要 $\\mathcal{O}(\\log k)$ 时间，其中 $k$ 是 $T$ 的长度。因此，处理每个元素的时间以 $\\mathcal{O}(\\log n)$ 为界。处理长度为 $n$ 的流的总时间复杂度为 $\\mathcal{O}(n \\log n)$。\n- **空间复杂度：** 在最坏情况下（一个严格递增的流），辅助数组 $T$ 最多为输入的每个元素存储一个元素。因此，辅助空间复杂度为 $\\mathcal{O}(n)$。\n\n此设计满足题目说明中的所有要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Processes a suite of test streams to find the length of the Longest Increasing Subsequence (LIS) for each.\n    The final results are printed in a single formatted line as specified.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Stream A\n        [1, 5, 2, 3, 4],\n        # Stream B\n        [5, 4, 3, 2, 1],\n        # Stream C\n        [2, 2, 2, 2],\n        # Stream D\n        [],\n        # Stream E\n        [10, 9, 2, 5, 3, 7, 101, 18],\n        # Stream F\n        [0, -1, -2, -3],\n        # Stream G\n        [1, 3, 5, 4, 7],\n        # Stream H\n        [1, 2, 3, 4, 5],\n        # Stream I\n        [3, 3, 3, 3, 4],\n        # Stream J\n        [3, 1, 2, 1, 8, 5, 6],\n    ]\n\n    results = []\n    for stream in test_cases:\n        result = calculate_lis_length(stream)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_lis_length(stream):\n    \"\"\"\n    Calculates the length of the Longest Increasing Subsequence (LIS)\n    of an integer stream using an O(n log n) algorithm.\n\n    The algorithm maintains an auxiliary array, conventionally named 'tails'.\n    The invariant is that 'tails[k]' stores the smallest ending element of all\n    strictly increasing subsequences of length k+1 found so far.\n\n    Args:\n        stream (list[int]): A list of integers representing the stream.\n\n    Returns:\n        int: The length of the LIS.\n    \"\"\"\n    if not stream:\n        return 0\n\n    # 'tails' will store the smallest tail of all increasing subsequences\n    # with length i+1 at tails[i].\n    tails = []\n\n    for num in stream:\n        # We need to find the first element in 'tails' that is >= num.\n        # This is equivalent to finding the insertion point for 'num'\n        # to maintain sorted order. np.searchsorted provides an efficient\n        # binary search implementation for this (lower_bound behavior).\n        # It operates on Python lists as well as numpy arrays.\n        idx = np.searchsorted(tails, num)\n\n        if idx == len(tails):\n            # 'num' is greater than all elements in 'tails'. This means we can\n            # extend the longest subsequence found so far. We append 'num',\n            # which starts a new, longer subsequence of length len(tails)+1.\n            tails.append(num)\n        else:\n            # We found an element tails[idx] >= num. We can form an increasing\n            # subsequence of length idx+1 that ends with 'num', which is smaller\n            # than or equal to the previous best (tails[idx]). A smaller tail is\n            # better as it leaves more room for future elements to extend it.\n            # We replace tails[idx] with 'num' to maintain the invariant.\n            tails[idx] = num\n            \n    return len(tails)\n\n# Execute the main function.\nsolve()\n```"
        }
    ]
}