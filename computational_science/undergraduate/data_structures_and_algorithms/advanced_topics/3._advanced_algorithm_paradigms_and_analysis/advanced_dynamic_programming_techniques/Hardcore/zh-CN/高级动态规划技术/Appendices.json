{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。本节将从树形动态规划（DP）的一个经典问题——树着色——开始。这个问题完美地展示了树形DP的核心思想：将树的递归结构转化为子问题的递归求解。通过解决这个问题 ，你将学习如何定义根植于特定节点的DP状态，并掌握如何通过后序遍历，自底向上地合并子树的解，从而得到整个问题的答案。",
            "id": "3203686",
            "problem": "给定一个有限、简单、连通的无向图，它是一个具有带标签顶点的树。设该树有 $N$ 个顶点，标签从 $1$ 到 $N$，边集为无序对的集合 $\\{(u,v)\\}$，其中 $u \\in \\{1,\\dots,N\\}$ 且 $v \\in \\{1,\\dots,N\\}$，使得该图恰好包含 $N-1$ 条边、是连通的且没有环。另外给定一个整数 $K \\ge 1$，表示可用颜色的数量，颜色索引取为 $\\{0,1,\\dots,K-1\\}$。对于每个顶点 $i$，给定一个允许的颜色集合，该集合被编码为一个非负整数掩码 $M_i$，其中第 $j$ 位（代表颜色 $j$ 的位）为 $1$ 当且仅当颜色 $j$ 在顶点 $i$ 上是允许的，否则为 $0$。顶点着色函数是一个映射 $c:\\{1,\\dots,N\\} \\to \\{0,1,\\dots,K-1\\}$。如果对于每条边 $(u,v)$，属性 $c(u) \\ne c(v)$ 成立，则该着色是正常的；如果对于每个顶点 $i$，属性 $\\left((M_i \\,\\text{bitwise-and}\\, (1 \\ll c(i))) \\ne 0\\right)$ 成立（其中 $\\ll$ 表示左移运算符），则该着色是容许的。您的任务是计算同时满足正常和容许条件的着色方案 $c$ 的数量，计算需在模 $10^9 + 7$（记为 $1000000007$）下进行，并将结果作为整数输出。\n\n此计算的基础是树的定义、正常着色的定义以及独立选择组合的计数原理（即独立因子的乘积）。具体来说，对于一棵有根树，当一个节点的颜色确定后，其子节点的各子树在容许正常着色方面变得相互独立，整个子树的计数是其每个子树在不重复使用父节点颜色的前提下容许选择数的乘积。\n\n请实现一个程序来解决以下测试集中的问题。每个测试用例包含参数 $(N,K,\\text{edges},\\text{masks})$，其中 $\\text{edges}$ 是顶点标签对的列表，$\\text{masks}$ 是 $N$ 个整数 $M_i$ 的列表。所有顶点标签和整数都明确写在下面：\n- 测试用例 1：$N=1$, $K=3$, $\\text{edges}=[\\,]$, $\\text{masks}=[\\,7\\,]$。此处，$7$ 编码了单个顶点允许的颜色 $\\{0,1,2\\}$。\n- 测试用例 2：$N=3$, $K=2$, $\\text{edges}=[\\,(1,2),(2,3)\\,]$, $\\text{masks}=[\\,3,3,3\\,]$。此处，$3$ 编码了每个顶点允许的颜色 $\\{0,1\\}$。\n- 测试用例 3：$N=4$, $K=3$, $\\text{edges}=[\\,(1,2),(1,3),(1,4)\\,]$, $\\text{masks}=[\\,7,7,7,7\\,]$。这是一个以顶点 $1$ 为中心的星形图，所有顶点都允许所有颜色。\n- 测试用例 4：$N=4$, $K=3$, $\\text{edges}=[\\,(1,2),(2,3),(3,4)\\,]$, $\\text{masks}=[\\,3,6,5,7\\,]$。掩码编码了允许的集合：顶点 $1$ 有 $\\{0,1\\}$，顶点 $2$ 有 $\\{1,2\\}$，顶点 $3$ 有 $\\{0,2\\}$，顶点 $4$ 有 $\\{0,1,2\\}$。\n- 测试用例 5：$N=2$, $K=1$, $\\text{edges}=[\\,(1,2)\\,]$, $\\text{masks}=[\\,1,1\\,]$。只有一种颜色可用，且两个顶点都允许使用该颜色。\n- 测试用例 6：$N=5$, $K=4$, $\\text{edges}=[\\,(1,2),(1,3),(3,4),(3,5)\\,]$, $\\text{masks}=[\\,15,10,13,3,12\\,]$。掩码编码了允许的集合：顶点 $1$ 有 $\\{0,1,2,3\\}$，顶点 $2$ 有 $\\{1,3\\}$，顶点 $3$ 有 $\\{0,2,3\\}$，顶点 $4$ 有 $\\{0,1\\}$，顶点 $5$ 有 $\\{2,3\\}$。\n\n您的程序应为每个测试用例计算正常且容许的着色数量，每个计数都对 $1000000007$ 取模。最终输出格式必须是单行，其中包含按顺序排列的测试用例结果，形式为方括号括起来的逗号分隔列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6\\right]$。此问题不涉及物理单位。角度和百分比不适用。每个测试用例的输出必须是一个整数。",
            "solution": "用户需要一个图着色计数问题的解决方案，我必须首先对其进行验证。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n- **图结构**：一个有限、简单、连通的无向图，它是一个有 $N$ 个顶点的树，顶点标签从 $1$ 到 $N$。\n- **颜色数量**：一个整数 $K \\ge 1$，颜色索引从 $0$ 到 $K-1$。\n- **逐顶点颜色约束**：对于每个顶点 $i$，一个整数掩码 $M_i$ 指定了允许的颜色集合。如果颜色 $j$ 对顶点 $i$ 是允许的，则 $M_i$ 的第 $j$ 位为 $1$。\n- **正常着色**：对于任意边 $(u,v)$，分配的颜色必须不同，即 $c(u) \\neq c(v)$。\n- **容许着色**：对于任意顶点 $i$，分配的颜色 $c(i)$ 必须在其允许的集合中，即 $M_i$ 的第 $c(i)$ 位必须为 $1$。\n- **目标**：计算同时满足正常和容许条件的着色总数，结果对 $10^9 + 7$ 取模。\n- **测试用例**：提供了六个 $(N, K, \\text{edges}, \\text{masks})$ 的具体实例，需要对它们进行计算。\n\n**步骤2：使用提取的信息进行验证**\n\n- **科学依据**：该问题植根于图论和离散数学，具体涉及树上的图着色问题。所有概念（树、着色、模算术、位掩码表示）都是标准且数学上合理的。该问题是计算色多项式的一个变体，增加了逐顶点的约束。\n- **适定性**：该问题是适定的。对于有限的树和有限的颜色集，可能的着色数量是有限的。问题要求在清晰、无歧义的约束下计算一个特定的整数数量，确保每个测试用例都有唯一的解。\n- **客观性**：问题陈述使用了精确的数学定义和客观的数值数据，没有歧义或主观语言。\n- **完整性和一致性**：每个测试用例都提供了所有必要的数据（$N, K$, edges, masks）。树的属性（$N-1$ 条边，连通）被明确说明，确保了一致性。\n\n**步骤3：结论与行动**\n\n该问题是 **有效的**。这是一个计算机科学中的标准算法问题，可以使用树形动态规划来解决。\n\n---\n\n### 解法推导\n\n该问题要求计算为一棵树着色的方法数，要求每个顶点的颜色都必须从一个特定的允许颜色集合中选择，并且每条边的两个连接顶点颜色不同。这是一个树形动态规划的经典应用。\n\n**1. 问题形式化**\n设树为 $T=(V, E)$，其中 $V=\\{1, \\dots, N\\}$ 是顶点集，$E$ 是边集。设可用颜色集为 $C = \\{0, 1, \\dots, K-1\\}$。对于每个顶点 $i \\in V$，容许颜色集为 $A_i = \\{j \\in C \\mid (M_i \\gg j) \\ \\ \\ 1 = 1 \\}$。我们寻求函数 $c: V \\to C$ 的数量，使得：\n1.  **容许性**：$\\forall i \\in V, c(i) \\in A_i$。\n2.  **正常性**：$\\forall (u, v) \\in E, c(u) \\neq c(v)$。\n\n**2. 树形动态规划**\n树结构是关键。如果我们在一个任意顶点（比如顶点1）处将树定根，我们就可以在子树上定义子问题。一旦公共父节点的颜色确定，不相交子树的着色选择就变得相互独立。这启发我们使用动态规划方法。\n\n让我们定义 DP 状态。对于每个顶点 $u \\in V$ 和每种颜色 $j \\in C$，令 $dp[u][j]$ 为在顶点 $u$ 被赋予颜色 $j$ 的情况下，对以 $u$ 为根的子树（包括 $u$ 本身）进行着色，使得整个子树的着色是正常且容许的方案数。\n\nDP 值使用后序遍历（从叶节点到根节点）计算。\n\n**3. DP 状态转移**\n\n**基本情况（叶节点）：**\n叶节点 $u$ 没有子节点。其子树只包含它自身。唯一的约束在于 $u$ 的颜色。因此，如果颜色 $j$ 对 $u$ 是容许的，我们恰好有一种方式将 $u$ 染成颜色 $j$。\n$$\ndp[u][j] = \\begin{cases} 1  \\text{if } j \\in A_u \\\\ 0  \\text{if } j \\notin A_u \\end{cases}\n$$\n\n**递归步骤（内部节点）：**\n对于一个内部节点 $u$，设其在有根树中的子节点为 $v_1, v_2, \\dots, v_m$。要计算 $dp[u][j]$，我们首先检查颜色 $j$ 对 $u$ 是否容许。如果 $j \\notin A_u$，则 $dp[u][j] = 0$。\n如果 $j \\in A_u$，我们必须对其子节点的子树进行着色。对于任意子节点 $v_i$，只要颜色 $k \\neq j$，它就必须被染成任何容许的颜色 $k$。在此约束下，对 $v_i$ 的子树进行着色的方案数是所有有效颜色 $k \\neq j$ 对应的 $dp[v_i][k]$ 的总和。\n$$\n\\text{Ways for child } v_i = \\sum_{k \\in C, k \\neq j} dp[v_i][k]\n$$\n由于不同子节点的子树的着色选择在父节点颜色 $j$ 固定的情况下是相互独立的，我们将每个子树的方案数相乘。\n$$\ndp[u][j] = \\prod_{i=1}^{m} \\left( \\sum_{k \\in C, k \\neq j} dp[v_i][k] \\right) \\pmod{1000000007}\n$$\n为了计算效率，总和可以这样计算：\n$$\n\\sum_{k \\in C, k \\neq j} dp[v_i][k] = \\left( \\left(\\sum_{k \\in C} dp[v_i][k]\\right) - dp[v_i][j] \\right) \\pmod{1000000007}\n$$\n这样可以避免为每个子节点和每个父节点颜色都进行一次大小为 $K$ 的循环，从而降低了转移的复杂度。\n\n**4. 最终计算**\n计算可以通过从根节点开始的单次深度优先搜索（DFS）来实现。DFS 函数在处理完一个节点的所有子节点后才处理该节点。一旦 DFS 完成并且所有节点的 DP 表都已填充，整个树的有效着色总数就是根节点在所有可能颜色下的 DP 值的总和。设顶点 $r$ 为根节点。\n$$\n\\text{Total Colorings} = \\sum_{j \\in C} dp[r][j] \\pmod{1000000007}\n$$\n所有算术运算（加法、减法、乘法）都在模 $10^9 + 7$ 下进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Set a higher recursion limit for deep trees, although not strictly necessary for the given test cases.\n    # The default is often 1000, which is sufficient here.\n    sys.setrecursionlimit(2000)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 3, [], [7]),\n        (3, 2, [(1, 2), (2, 3)], [3, 3, 3]),\n        (4, 3, [(1, 2), (1, 3), (1, 4)], [7, 7, 7, 7]),\n        (4, 3, [(1, 2), (2, 3), (3, 4)], [3, 6, 5, 7]),\n        (2, 1, [(1, 2)], [1, 1]),\n        (5, 4, [(1, 2), (1, 3), (3, 4), (3, 5)], [15, 10, 13, 3, 12]),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_colorings(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_colorings(case):\n    \"\"\"\n    Calculates the number of proper, admissible colorings for a single test case.\n    \"\"\"\n    N, K, edges, masks = case\n    MOD = 1000000007\n\n    # Handle the trivial case of a single vertex.\n    if N == 1:\n        mask = masks[0]\n        # Count the number of set bits in the mask, which corresponds to the number of allowed colors.\n        return bin(mask).count('1')\n\n    # Build adjacency list for the tree. Vertices are 1-based in the input,\n    # so we convert them to 0-based indices.\n    adj = [[] for _ in range(N)]\n    for u, v in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n\n    # DP table: dp[u][c] stores the number of ways to color the subtree at u\n    # with color c. Initialize with -1 to mark as uncomputed.\n    dp = np.full((N, K), -1, dtype=np.int64)\n\n    def dfs(u, p):\n        \"\"\"\n        Performs a post-order traversal to compute DP values.\n        u: current vertex (0-indexed)\n        p: parent of u (0-indexed), -1 for root\n        \"\"\"\n        # Memoization check: if already computed for u, return.\n        if dp[u, 0] != -1:\n            return\n\n        # Initialize DP values for u as if it's a leaf.\n        # dp[u][c] = 1 if color c is admissible, 0 otherwise.\n        for c in range(K):\n            if (masks[u] >> c)  1:\n                dp[u, c] = 1\n            else:\n                dp[u, c] = 0\n\n        # Recursively call DFS on children and update DP values for u.\n        for v in adj[u]:\n            if v == p:\n                continue\n            \n            dfs(v, u) # This populates dp[v]\n            \n            # Sum of ways for the child v over all its possible colors.\n            # This sum is used to efficiently calculate the ways for v to avoid parent's color.\n            child_sum = np.sum(dp[v, :]) % MOD\n            \n            # Update dp[u][c_u] by multiplying with the number of ways to color child v's subtree.\n            for c_u in range(K):\n                # If color c_u is not admissible for u, ways are 0.\n                if dp[u, c_u] == 0:\n                    continue\n                \n                # Number of ways to color child v's subtree, given u is colored with c_u.\n                # child_v can take any color except c_u.\n                child_ways = (child_sum - dp[v, c_u]) % MOD\n                # Handle Python's negative result for modulo\n                if child_ways  0:\n                    child_ways += MOD\n                \n                # Since children's colorings are independent, we multiply their counts.\n                dp[u, c_u] = (dp[u, c_u] * child_ways) % MOD\n\n    # Start the DFS from an arbitrary root, here vertex 0.\n    # The parent of the root is marked as -1.\n    dfs(0, -1)\n    \n    # The total number of colorings is the sum of possibilities for the root node over all colors.\n    total_ways = np.sum(dp[0, :]) % MOD\n    return int(total_ways)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的树形DP模式后，让我们来挑战一个状态转移更为复杂的问题。计算一棵树中大小为 $K$ 的连通子图数量，需要我们设计一种更精巧的DP状态合并方式。与简单的独立计数不同，此问题  的状态合并类似于背包问题或多项式乘法，你需要将来自不同子树的解以所有可能的方式组合。这个练习将深化你对树形DP中组合计数的理解，并提升你处理复杂依赖关系的能力。",
            "id": "3203742",
            "problem": "给定一个无向树 $G=(V,E)$，它有 $|V|=N$ 个顶点（编号从 $1$ 到 $N$）和 $|E|=N-1$ 条边。树的定义是连通、无环的图。对于一个整数 $K$，一个大小恰好为 $K$ 的连通子图被定义为一个顶点子集 $S \\subseteq V$，其大小 $|S|=K$，且由 $S$ 诱导的子图是连通的（即，对于 $S$ 中的任意一对顶点，都存在一条完全位于 $S$ 内部的路径连接它们）。任务是计算大小恰好为 $K$ 的不同连通导出子图的数量。所有计数都是没有物理单位的纯整数。\n\n可依赖的基本原则：\n- 树的定义：一个连通、无环的无向图。\n- 树的性质：任意两个顶点之间存在唯一一条简单路径。\n- 导出子图的概念：对于 $S \\subseteq V$，在 $S$ 上的导出子图包含 $S$ 中的所有顶点以及所有满足 $u \\in S$ 和 $v \\in S$ 的边 $(u,v) \\in E$。\n\n您的程序必须为以下每个测试用例计算数量。每个测试用例由 $N$、$K$ 和一个边集合指定。顶点编号从 $1$ 到 $N$。\n\n测试套件：\n1. Case $\\mathrm{A}$: $N=7$, $K=3$，边集合 $\\{(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)\\}$。\n2. Case $\\mathrm{B}$: $N=5$, $K=2$，边集合 $\\{(1,2),(2,3),(3,4),(4,5)\\}$。\n3. Case $\\mathrm{C}$: $N=5$, $K=3$，边集合 $\\{(1,2),(1,3),(1,4),(1,5)\\}$。\n4. Case $\\mathrm{D}$: $N=1$, $K=1$，边集合 $\\{\\}$。\n5. Case $\\mathrm{E}$: $N=3$, $K=0$，边集合 $\\{(1,2),(2,3)\\}$。对于 $K=0$，计数定义为 $0$，因为没有非空连通子图的大小为 $0$。\n6. Case $\\mathrm{F}$: $N=6$, $K=6$，边集合 $\\{(1,2),(2,3),(3,4),(4,5),(5,6)\\}$。\n7. Case $\\mathrm{G}$: $N=4$, $K=5$，边集合 $\\{(1,2),(1,3),(1,4)\\}$。对于 $KN$，计数定义为 $0$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,\\dots]$），其中 $r_i$ 是按上述顺序列出的第 $i$ 个测试用例的整数计数。不应产生任何其他输出。此任务不涉及角度或物理单位。所有输出均为整数。",
            "solution": "所述问题是图论领域一个明确定义的组合计数问题。所有术语都是标准的，测试用例是一致且可验证的。该问题是有效的，可以使用已有的算法技术来解决。\n\n任务是计算给定树 $G=(V, E)$（其中 $|V|=N$）中大小为 $K$ 的不同连通导出子图的数量。对所有 $\\binom{N}{K}$ 个顶点子集进行暴力检查在计算上是不可行的。图的树形结构表明可以采用一种基于树的动态规划方法，通常称为树形 DP。\n\n树 $G$ 内连通子图 $S$ 的一个基本性质是 $S$ 本身也是一棵树。如果我们将主树 $G$ 以任意顶点 $r$ 为根，任何连通子图 $S$ 都将拥有一个唯一的“最高”顶点，即 $S$ 中相对于根 $r$ 而言是 $S$ 中所有其他顶点的祖先的那个顶点。这个唯一的顶点可以被指定为子图 $S$ 的“根”。\n\n这一观察使我们能够根据其唯一的根来划分所有连通子图的集合，从而确保每个子图只被计数一次。总数是对于所有顶点 $u \\in V$，以 $u$ 为根的大小为 $K$ 的连通子图数量的总和。\n\n我们构建一个动态规划状态来计算这些数量。让我们为整个树 $G$ 固定一个任意的根，例如顶点 1。然后我们将从这个根开始执行一次后序遍历（DFS）。对于每个顶点 $u$，我们的 DP 状态将捕获关于以 $u$ 为根的子图的信息。\n\n令 $dp[u][k]$ 表示完全包含在以 $u$ 为根的 $G$ 的子树中、且其本身也以 $u$ 为根的大小为 $k$ 的连通子图的数量。\n\nDP 值通过后序遍历计算：\n\n**基本情况：** 对于任何叶顶点 $u$，在其自身子树内以 $u$ 为根的唯一连通子图是仅由单个顶点 $\\{u\\}$ 组成的子图。因此，$dp[u][1] = 1$，且对于所有 $k  1$，$dp[u][k] = 0$。\n\n**递归步骤：** 对于一个内部顶点 $u$，我们基于只包含其自身的子图来初始化其 DP 表：$dp[u][1] = 1$ 且对于 $k  1$，$dp[u][k] = 0$。然后我们遍历它的每个子节点（比如说 $v_i$），并将来自子节点子树的 DP 信息合并到父节点的 DP 表中。\n\n在处理子节点 $v_i$ 时，我们已经计算了它的 DP 表 $dp[v_i]$。一个新的、更大的以 $u$ 为根的连通子图可以通过将一个已存在的以 $u$ 为根的大小为 $k_1$ 的连通子图（使用 $u$ 及其先前处理过的子节点构建）与一个以 $v_i$ 为根的大小为 $k_2$ 的连通子图组合而成。连接是通过边 $(u, v_i)$ 建立的。生成的子图以 $u$ 为根，其新大小为 $k_1 + k_2$。形成这样一个子图的方法数是 $dp[u][k_1] \\times dp[v_i][k_2]$ 的乘积。\n\n这个组合过程是按顺序为每个子节点执行的。设 $dp_{u, \\text{old}}$ 为合并子节点 $v_i$ 之前 $u$ 的 DP 数组。新的 DP 数组 $dp_{u, \\text{new}}$ 计算如下：\n$dp_{u, \\text{new}}[k] = dp_{u, \\text{old}}[k] + \\sum_{k_1+k_2=k} dp_{u, \\text{old}}[k_1] \\times dp[v_i][k_2]$。\n第一项 $dp_{u, \\text{old}}[k]$ 计算了那些不包含来自 $v_i$ 子树中任何顶点的、以 $u$ 为根的子图。求和项则计算了通过包含来自 $v_i$ 子树的一个连通分量而形成的新子图。\n\n后序遍历完成后，每个顶点 $u$ 的 $dp[u][k]$ 表都最终确定下来。整棵树中大小为 $K$ 的连通子图总数是所有可能的根的计数之和：$\\sum_{u \\in V} dp[u][K]$。\n\n时间复杂度主要由 DP 合并操作决定。在遍历中的每条边 $(u, v)$ 上，我们执行一个类似于两个数组卷积的操作，数组的大小与相应子树的大小成正比。一棵树的所有边上这些子树大小乘积的总和有界于 $O(N^2)$。空间复杂度为 $O(N^2)$，用于存储所有 $N$ 个顶点的 DP 表，其中每个表最多可以有 $N+1$ 个条目。\n\n根据问题陈述，$K=0$ 或 $KN$ 的特殊情况直接处理，其计数为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the small N in the test cases.\nsys.setrecursionlimit(2000)\n\ndef count_connected_subgraphs(N, K, edges):\n    \"\"\"\n    Calculates the number of connected induced subgraphs of size K in a tree.\n\n    Args:\n        N (int): The number of vertices in the tree.\n        K (int): The desired size of the connected subgraphs.\n        edges (list of tuples): A list of edges defining the tree.\n\n    Returns:\n        int: The number of distinct connected subgraphs of size K.\n    \"\"\"\n    if K == 0 or K > N:\n        return 0\n    if N == 0:\n        return 0\n    # A single vertex graph.\n    if not edges:\n        return 1 if N == 1 and K == 1 else 0\n\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # dp[u][k] stores the number of connected subgraphs of size k\n    # in the subtree of u, with u as the root of the subgraph.\n    # We use np.int64 to prevent potential integer overflow with larger N.\n    dp = np.zeros((N + 1, N + 1), dtype=np.int64)\n\n    def dfs(u, p):\n        \"\"\"\n        Performs a post-order traversal to compute the DP tables.\n\n        Args:\n            u (int): The current vertex.\n            p (int): The parent of the current vertex in the DFS traversal.\n\n        Returns:\n            int: The size of the subtree rooted at u.\n        \"\"\"\n        # Base case for the DP: the subgraph with only vertex u.\n        dp[u][1] = 1\n        current_size = 1\n        \n        for v in adj[u]:\n            if v == p:\n                continue\n            \n            child_size = dfs(v, u)\n            \n            # This temporary array holds the new DP values for u after merging child v.\n            # This corresponds to the polynomial multiplication: P_u_new = P_u_old * P_v_merged\n            # where P(x) is the generating function for the DP counts.\n            temp_dp_u = dp[u].copy()\n\n            for k1 in range(1, current_size + 1):\n                if dp[u][k1] == 0:\n                    continue\n                for k2 in range(1, child_size + 1):\n                    if dp[v][k2] == 0:\n                        continue\n                    if k1 + k2 = N:\n                        # Combine a component of size k1 from u's current set\n                        # with a component of size k2 from v's subtree.\n                        temp_dp_u[k1 + k2] += dp[u][k1] * dp[v][k2]\n\n            dp[u] = temp_dp_u\n            current_size += child_size\n        \n        return current_size\n\n    # Start DFS from an arbitrary root (vertex 1), with a dummy parent 0.\n    dfs(1, 0)\n\n    # The total count is the sum of dp[u][K] over all possible subgraph roots u.\n    total_count = np.sum(dp[:, K])\n    \n    return int(total_count)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, printing the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A: N=7, K=3, edges={(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)}\n        (7, 3, [(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)]),\n        # Case B: N=5, K=2, edges={(1,2),(2,3),(3,4),(4,5)}\n        (5, 2, [(1,2),(2,3),(3,4),(4,5)]),\n        # Case C: N=5, K=3, edges={(1,2),(1,3),(1,4),(1,5)}\n        (5, 3, [(1,2),(1,3),(1,4),(1,5)]),\n        # Case D: N=1, K=1, edges={}\n        (1, 1, []),\n        # Case E: N=3, K=0, edges={(1,2),(2,3)}\n        (3, 0, [(1,2),(2,3)]),\n        # Case F: N=6, K=6, edges={(1,2),(2,3),(3,4),(4,5),(5,6)}\n        (6, 6, [(1,2),(2,3),(3,4),(4,5),(5,6)]),\n        # Case G: N=4, K=5, edges={(1,2),(1,3),(1,4)}\n        (4, 5, [(1,2),(1,3),(1,4)])\n    ]\n    \n    results = []\n    for N, K, edges in test_cases:\n        result = count_connected_subgraphs(N, K, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "接下来，我们将注意力从树结构转向顶点数量较少的一般图，并介绍一种强大的技术：状态压缩DP（或称位掩码DP）。当问题规模（如此处的顶点数 $N \\le 22$）允许我们遍历所有子集时，这种方法尤其有效。通过解决最大权匹配问题 ，你将学习如何使用一个整数（位掩码）来表示顶点子集，并构建一个DP状态 $dp[mask]$ 来存储该子图上的最优解。这个练习的核心在于理解如何通过系统地考虑向子集中添加顶点及其可能产生的匹配，来构建从较小子集到较大子集的递推关系。",
            "id": "3203673",
            "problem": "给定一个包含 $N$ 个顶点的有限、简单、无向图，其中 $N \\leq 22$。每条边都有一个整数权重。匹配（matching）是一个边的集合，其中任意两条边都没有公共顶点。最大权匹配是指在所有有效匹配中，边权重之和最大的匹配。您必须设计一个程序，针对几个指定的图，使用一种基于子集动态规划（DP）的方法计算最大权匹配的值，其中子集用位掩码（bitmask）表示。该方法应源于核心定义：给定一个图 $G = (V, E)$，其顶点集为 $V$，边集为 $E$，以及一个整数权重函数 $w: E \\rightarrow \\mathbb{Z}$，匹配是一个子集 $M \\subseteq E$，满足 $M$ 中任意两条边都不共享同一个端点。一个匹配 $M$ 的总权重为 $\\sum_{e \\in M} w(e)$。该算法必须考虑由顶点子集导出的所有有效匹配，以确定最大总权重。\n\n程序不得读取任何输入。相反，它必须评估以下图的测试套件：\n\n- 测试用例 1：$N = 4$。边和权重：\n  - $(0, 1)$ 权重为 $3$，\n  - $(0, 2)$ 权重为 $1$，\n  - $(0, 3)$ 权重为 $4$，\n  - $(1, 2)$ 权重为 $2$，\n  - $(1, 3)$ 权重为 $5$，\n  - $(2, 3)$ 权重为 $7$。\n- 测试用例 2：$N = 3$。边和权重：\n  - $(0, 1)$ 权重为 $-5$，\n  - $(1, 2)$ 权重为 $-1$。\n- 测试用例 3：$N = 5$。边和权重：\n  - $(0, 1)$ 权重为 $8$，\n  - $(0, 2)$ 权重为 $6$，\n  - $(1, 2)$ 权重为 $5$，\n  - $(3, 4)$ 权重为 $9$。\n- 测试用例 4：$N = 0$。没有边。\n- 测试用例 5：$N = 14$。边和权重：\n  - $(0, 1)$ 权重为 $1$，\n  - $(2, 3)$ 权重为 $2$，\n  - $(4, 5)$ 权重为 $3$，\n  - $(6, 7)$ 权重为 $4$，\n  - $(8, 9)$ 权重为 $5$，\n  - $(10, 11)$ 权重为 $6$，\n  - $(12, 13)$ 权重为 $7$。\n- 测试用例 6：$N = 7$。边和权重：\n  - $(0, 1)$ 权重为 $5$，\n  - $(1, 2)$ 权重为 $6$，\n  - $(0, 2)$ 权重为 $7$，\n  - $(3, 4)$ 权重为 $4$，\n  - $(5, 6)$ 权重为 $3$。\n\n所有边的权重都是整数，且图是无向的。不存在的边就是不允许的（不能在匹配中使用）。如果没有选择任何边（例如，所有可用边的权重都为负），则匹配的权重为 $0$。\n\n您的程序应生成单行输出，其中包含为测试套件计算出的最大匹配权重，格式为逗号分隔的列表，用方括号括起来，不含空格，并严格按照上述测试用例的顺序（例如，$[a,b,c,d,e,f]$，其中 $a$ 到 $f$ 分别是测试用例1到6的整数答案）。",
            "solution": "该问题要求在带权重的有限、简单、无向图中找到最大权匹配。顶点数 $N$ 很小，指定为 $N \\le 22$，这表明可以使用一个关于 $N$ 的指数复杂度算法。问题明确要求使用基于子集的动态规划（DP）解决方案，该方案可以使用位掩码（bitmask）高效实现。\n\n首先，我们来形式化地定义问题。给定一个图 $G = (V, E)$，其顶点集为 $V = \\{0, 1, \\dots, N-1\\}$，边集为 $E$。一个权重函数 $w: E \\rightarrow \\mathbb{Z}$ 为每条边赋予一个整数权重。匹配 $M$ 是边的一个子集，$M \\subseteq E$，满足 $M$ 中任意两条边都不共享一个公共顶点。目标是找到一个匹配 $M^*$，使其总权重 $\\sum_{e \\in M^*} w(e)$ 最大化。如果所有可能的匹配的总权重都为负，则最优解是空匹配，其总权重为 $0$。\n\n该解决方案的核心是基于顶点子集的动态规划方法。我们可以使用位掩码来表示一个顶点子集，位掩码是一个长度为 $N$ 位的整数。如果该整数的第 $i$ 位（从右边开始，从第0位算起）设置为 $1$，则顶点 $i$ 在该子集中；否则不在。\n\n我们定义一个 DP 状态 $dp[mask]$，表示由 $mask$ 所代表的顶点集诱导的子图上的最大权匹配。我们的 DP 表大小为 $2^N$，索引从 $0$ 到 $2^N - 1$。我们的目标是计算 $dp[(1 \\ll N) - 1]$，它代表整个顶点集上的最大权匹配。\n\nDP 状态按掩码值的递增顺序计算，这对应于遍历规模递增的子集。\n\n我们递推的基准情况是空顶点集，由 $mask = 0$ 表示。唯一可能的匹配是空匹配，其权重为 $0$。因此：\n$$dp[0] = 0$$\n\n现在，我们为由掩码 $mask  0$ 表示的非空顶点子集建立递推关系。为了计算 $dp[mask]$，我们可以从该子集中选择一个顶点，并考虑它在最优匹配中的两种可能性：\n1. 该顶点不匹配。\n2. 该顶点与同一子集中的另一个顶点匹配。\n\n为确保状态被系统地计算且不重复计数，我们可以始终从子集中选择一个特定的顶点。一个方便的选择是索引最小的顶点，我们称之为 $i$。可以使用位运算从掩码中高效地找到索引 $i$。\n\n给定 $i$，子集 $mask$ 上的最优匹配有两种情况：\n\n情况1：顶点 $i$ 不匹配。\n如果顶点 $i$ 不属于匹配中的任何边，那么子集 $mask$ 的最大权匹配就是不含 $i$ 的顶点子集的最大权匹配。该子集由掩码 $mask \\oplus (1 \\ll i)$ 表示。这种情况下的总权重是 $dp[mask \\oplus (1 \\ll i)]$。\n\n情况2：顶点 $i$ 与另一个顶点 $j$ 匹配。\n顶点 $i$ 与某个也在子集 $mask$ 中的另一个顶点 $j$ 匹配（即 $mask$ 的第 $j$ 位为 $1$）且 $j \\neq i$。要使之成为可能，图中必须存在边 $(i, j)$。如果我们形成这个匹配，边 $(i, j)$ 会将其权重 $w(i, j)$ 贡献给总权重。剩余的顶点 $mask \\setminus \\{i, j\\}$ 必须自身形成一个最大权匹配。这种匹配选择的总权重是 $w(i, j) + dp[mask \\oplus (1 \\ll i) \\oplus (1 \\ll j)]$。我们必须考虑 $i$ 的所有可能的配对顶点 $j$，并选择使该值最大化的一个。\n\n结合这两种情况，我们可以通过取所有可能性的最大值来表示 $dp[mask]$。\n首先，我们考虑 $i$ 不匹配的情况，因此我们可以用 $dp[mask \\oplus (1 \\ll i)]$ 初始化 $dp[mask]$ 的值。然后，我们遍历子集 $mask$ 中的所有其他顶点 $j$（其中 $ji$ 以避免重复考虑点对），如果匹配 $(i, j)$ 产生更好的结果，则更新 $dp[mask]$。\n\n完整的递推关系是：\n$$dp[mask] = \\max \\left( dp[mask \\oplus (1 \\ll i)], \\max_{\\substack{j \\text{ s.t. bit } j \\text{ is in } mask \\\\ j  i \\\\ (i, j) \\in E}} \\{ w(i, j) + dp[mask \\oplus (1 \\ll i) \\oplus (1 \\ll j)] \\} \\right)$$\n其中 $i$ 是 $mask$ 中最低有效位（least significant bit）的索引。如果不存在这样的 $j$，则该值仅由第一项 $dp[mask \\oplus (1 \\ll i)]$ 决定。这种表述正确地处理了问题，包括所有边权重为负的情况，因为不形成任何匹配的选项（通过从较小子问题传播值，最终从 $dp[0]=0$ 传播而来）将导致最大值为 $0$。\n\n该算法按以下步骤进行：\n1. 初始化一个大小为 $2^N$ 的 DP 数组 $dp$，并将所有值设置为 $0$。\n2. 将图的边和权重存储在一个可快速访问的数据结构中，如哈希映射（hash map），为每条边使用一个规范的键（例如，一个元组 $(u, v)$，其中 $u  v$）。\n3. 从 $1$ 到 $2^N - 1$ 遍历 $mask$。\n4. 在循环内部，找到 $mask$ 的最低有效位的索引 $i$。\n5. 设置 $dp[mask] = dp[mask \\oplus (1 \\ll i)]$。\n6. 从 $i+1$ 到 $N-1$ 遍历所有 $j$。\n7. 如果顶点 $j$ 在子集 $mask$ 中且边 $(i, j)$ 存在，则计算潜在的新最大值：$w(i, j) + dp[mask \\oplus (1 \\ll i) \\oplus (1 \\ll j)]$。\n8. 将 $dp[mask]$ 更新为其当前值与这个新的潜在最大值中的较大者。\n9. 循环完成后，最终答案是 $dp[(1 \\ll N) - 1]$。\n\n该算法的时间复杂度由嵌套循环决定。外层循环运行 $2^N$ 次，内层关于 $j$ 的循环运行 $O(N)$ 次。因此，总时间复杂度为 $O(N \\cdot 2^N)$，对于 $N \\le 22$ 是计算上可行的。空间复杂度为 $O(2^N)$，用于存储 DP 表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the maximum weight matching problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (4, [(0, 1, 3), (0, 2, 1), (0, 3, 4), (1, 2, 2), (1, 3, 5), (2, 3, 7)]),\n        (3, [(0, 1, -5), (1, 2, -1)]),\n        (5, [(0, 1, 8), (0, 2, 6), (1, 2, 5), (3, 4, 9)]),\n        (0, []),\n        (14, [(0, 1, 1), (2, 3, 2), (4, 5, 3), (6, 7, 4), (8, 9, 5), (10, 11, 6), (12, 13, 7)]),\n        (7, [(0, 1, 5), (1, 2, 6), (0, 2, 7), (3, 4, 4), (5, 6, 3)])\n    ]\n\n    results = []\n    for N, edges in test_cases:\n        result = _solve_max_weight_matching(N, edges)\n        results.append(int(result))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_max_weight_matching(N, edges):\n    \"\"\"\n    Computes the maximum weight matching for a single graph using bitmask dynamic programming.\n\n    The DP state dp[mask] stores the maximum weight matching for the subgraph\n    induced by the vertices represented in 'mask'.\n    \"\"\"\n    if N == 0:\n        return 0\n\n    # Use a dictionary for sparse edge storage.\n    # The key is a tuple (u, v) with u  v to represent an undirected edge canonically.\n    edge_dict = {}\n    for u, v, w in edges:\n        if u > v:\n            u, v = v, u\n        edge_dict[(u, v)] = w\n\n    # dp[mask] = max weight matching on the subset of vertices 'mask'.\n    # Use 64-bit integers to prevent overflow with large weights.\n    dp = np.zeros(1  N, dtype=np.int64)\n\n    # Iterate through all subsets of vertices, from singleton sets up to the full set.\n    for mask in range(1, 1  N):\n        # Find the index 'i' of the smallest-indexed vertex in the current subset.\n        # This is a standard way to select a pivot vertex to build the recurrence.\n        # The bitwise trick (mask  -mask) isolates the least significant bit.\n        i = (mask  -mask).bit_length() - 1\n\n        # Option 1: Vertex 'i' is unmatched.\n        # In this case, the max weight matching for 'mask' is the same as for the\n        # subproblem without 'i'.\n        dp[mask] = dp[mask ^ (1  i)]\n\n        # Option 2: Vertex 'i' is matched with some other vertex 'j' in the subset.\n        # Iterate through all possible partners 'j' for 'i'.\n        # We only need to check j > i to avoid double-counting pairs.\n        for j in range(i + 1, N):\n            # Check if vertex 'j' is in the current subset 'mask'.\n            if (mask >> j)  1:\n                edge = (i, j)\n                if edge in edge_dict:\n                    weight = edge_dict[edge]\n                    \n                    # The value of this matching choice is the edge weight plus the\n                    # max matching on the remaining vertices.\n                    remaining_mask = mask ^ (1  i) ^ (1  j)\n                    current_value = weight + dp[remaining_mask]\n                    \n                    # Update the DP state for the current mask if this matching is better.\n                    if current_value > dp[mask]:\n                        dp[mask] = current_value\n\n    # The final answer is the max weight matching on the full set of vertices.\n    return dp[(1  N) - 1]\n\nsolve()\n```"
        }
    ]
}