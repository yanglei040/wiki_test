{
    "hands_on_practices": [
        {
            "introduction": "Finding the maximum weight matching is a fundamental problem in graph theory. While complex polynomial-time algorithms exist, this exercise introduces a powerful bitmask dynamic programming approach that is elegant and efficient for graphs with a small number of vertices. You will practice defining a DP state over subsets of vertices and formulating a recurrence by considering the choices for a single pivot vertex, a core pattern in solving many combinatorial optimization problems. ",
            "id": "3203673",
            "problem": "You are given a finite, simple, undirected graph with $N$ vertices, where $N \\leq 22$. Each edge has an integer weight. A matching is a set of edges that share no common vertices. The maximum weight matching is the matching whose sum of edge weights is largest among all valid matchings. You must design a program that, for several specified graphs, computes the value of the maximum weight matching using a method based on Dynamic Programming (DP) over subsets represented as bitmasks. The method should be derived from core definitions: given a graph $G = (V, E)$ with vertex set $V$ and edge set $E$, and an integer weight function $w: E \\rightarrow \\mathbb{Z}$, a matching is a subset $M \\subseteq E$ such that no two edges in $M$ share a common endpoint. The total weight of a matching $M$ is $\\sum_{e \\in M} w(e)$. The algorithm must consider all valid matchings induced by subsets of vertices to determine the maximum total weight.\n\nThe program must not read any input. Instead, it must evaluate the following test suite of graphs:\n\n- Test case $1$: $N = 4$. Edges and weights:\n  - $(0, 1)$ with weight $3$,\n  - $(0, 2)$ with weight $1$,\n  - $(0, 3)$ with weight $4$,\n  - $(1, 2)$ with weight $2$,\n  - $(1, 3)$ with weight $5$,\n  - $(2, 3)$ with weight $7$.\n- Test case $2$: $N = 3$. Edges and weights:\n  - $(0, 1)$ with weight $-5$,\n  - $(1, 2)$ with weight $-1$.\n- Test case $3$: $N = 5$. Edges and weights:\n  - $(0, 1)$ with weight $8$,\n  - $(0, 2)$ with weight $6$,\n  - $(1, 2)$ with weight $5$,\n  - $(3, 4)$ with weight $9$.\n- Test case $4$: $N = 0$. No edges.\n- Test case $5$: $N = 14$. Edges and weights:\n  - $(0, 1)$ with weight $1$,\n  - $(2, 3)$ with weight $2$,\n  - $(4, 5)$ with weight $3$,\n  - $(6, 7)$ with weight $4$,\n  - $(8, 9)$ with weight $5$,\n  - $(10, 11)$ with weight $6$,\n  - $(12, 13)$ with weight $7$.\n- Test case $6$: $N = 7$. Edges and weights:\n  - $(0, 1)$ with weight $5$,\n  - $(1, 2)$ with weight $6$,\n  - $(0, 2)$ with weight $7$,\n  - $(3, 4)$ with weight $4$,\n  - $(5, 6)$ with weight $3$.\n\nAll edge weights are integers and the graphs are undirected. An absent edge is simply disallowed (it cannot be used in a matching). If no edges are selected (for example, all available edges have negative weights), the matching weight is $0$.\n\nYour program should produce a single line of output containing the computed maximum matching weights for the test suite as a comma-separated list enclosed in square brackets with no spaces, in the exact order of the test cases above (for example, $[a,b,c,d,e,f]$ where $a$ through $f$ are integers representing the answers to test cases $1$ through $6$ respectively).",
            "solution": "The problem requires finding the maximum weight matching in a finite, simple, undirected graph with weighted edges. The number of vertices $N$ is small, specified as $N \\le 22$, which suggests an algorithm with exponential complexity in $N$. The problem explicitly mandates a solution based on Dynamic Programming (DP) over subsets, which can be implemented efficiently using bitmasks.\n\nFirst, let's formalize the problem. We are given a graph $G = (V, E)$, with a set of vertices $V = \\{0, 1, \\dots, N-1\\}$ and a set of edges $E$. A weight function $w: E \\rightarrow \\mathbb{Z}$ assigns an integer weight to each edge. A matching $M$ is a subset of edges, $M \\subseteq E$, such that no two edges in $M$ share a common vertex. The goal is to find a matching $M^*$ that maximizes the total weight, $\\sum_{e \\in M^*} w(e)$. If all possible matchings have a negative total weight, the optimal solution is the empty matching, with a total weight of $0$.\n\nThe core of the solution is a dynamic programming approach on the subsets of vertices. We can represent a subset of vertices using a bitmask, which is an integer of length $N$ bits. If the $i$-th bit of the integer (from the right, starting at bit $0$) is set to $1$, vertex $i$ is in the subset; otherwise, it is not.\n\nLet's define a DP state $dp[mask]$ as the maximum weight of a matching on the subgraph induced by the set of vertices represented by $mask$. The size of our DP table will be $2^N$, indexed from $0$ to $2^N - 1$. Our goal is to compute $dp[(1 \\ll N) - 1]$, which represents the maximum weight matching on the entire set of vertices.\n\nThe DP states are computed in increasing order of the mask value, which corresponds to iterating through subsets of increasing size.\n\nThe base case for our recurrence is for the empty set of vertices, represented by $mask = 0$. The only possible matching is the empty matching, which has a weight of $0$. Thus:\n$$dp[0] = 0$$\n\nNow, we establish the recurrence relation for a non-empty subset of vertices represented by a mask $mask > 0$. To compute $dp[mask]$, we can select one vertex from the subset and consider the two possibilities for it in an optimal matching:\n1. The vertex is unmatched.\n2. The vertex is matched with another vertex in the same subset.\n\nTo ensure that states are computed systematically and we do not double-count, we can consistently pick a specific vertex from the subset. A convenient choice is the vertex with the smallest index, let's call it $i$. The index $i$ can be found efficiently from the mask using bitwise operations: `i = (mask  -mask).bit_length() - 1`.\n\nGiven $i$, the two cases for an optimal matching on the subset $mask$ are:\n\nCase 1: Vertex $i$ is left unmatched.\nIf vertex $i$ is not part of any edge in the matching, then the maximum weight matching for the subset $mask$ is simply the maximum weight matching for the subset of vertices without $i$. This subset is represented by the mask $mask \\oplus (1 \\ll i)$. The total weight in this case is $dp[mask \\oplus (1 \\ll i)]$.\n\nCase 2: Vertex $i$ is matched with another vertex $j$.\nVertex $i$ is matched with some other vertex $j$ that is also in the subset represented by $mask$ (i.e., the $j$-th bit of $mask$ is $1$) and where $j \\neq i$. For this to be possible, an edge $(i, j)$ must exist in the graph. If we form this match, the edge $(i, j)$ contributes its weight $w(i, j)$ to the total. The remaining vertices, $mask \\setminus \\{i, j\\}$, must themselves form a maximum weight matching. The total weight for this choice of match is $w(i, j) + dp[mask \\oplus (1 \\ll i) \\oplus (1 \\ll j)]$. We must consider all possible partners $j$ for $i$ and choose the one that maximizes this value.\n\nCombining these two cases, we can express $dp[mask]$ by taking the maximum over all possibilities.\nFirst, we consider the case where $i$ is unmatched, so we can initialize the value of $dp[mask]$ with $dp[mask \\oplus (1 \\ll i)]$. Then, we iterate through all other vertices $j$ in the subset $mask$ (with $j>i$ to avoid considering pairs twice) and update $dp[mask]$ if matching $(i, j)$ yields a better result.\n\nThe complete recurrence relation is:\n$$dp[mask] = \\max \\left( dp[mask \\oplus (1 \\ll i)], \\max_{\\substack{j \\text{ s.t. bit } j \\text{ is in } mask \\\\ j > i \\\\ (i, j) \\in E}} \\{ w(i, j) + dp[mask \\oplus (1 \\ll i) \\oplus (1 \\ll j)] \\} \\right)$$\nwhere $i$ is the index of the least significant bit in $mask$. If no such $j$ exists, the value is determined solely by the first term, $dp[mask \\oplus (1 \\ll i)]$. This formulation correctly handles the problem, including the case where all edge weights are negative, as the option of not forming any match (handled by propagating values from smaller subproblems, ultimately from $dp[0]=0$) will result in a maximum of $0$.\n\nThe algorithm proceeds as follows:\n1. Initialize a DP array $dp$ of size $2^N$ with all values set to $0$.\n2. Store the graph's edges and weights in a quickly accessible data structure, like a hash map, using a canonical key for each edge (e.g., a tuple $(u, v)$ where $u  v$).\n3. Iterate $mask$ from $1$ to $2^N - 1$.\n4. Inside the loop, find the index $i$ of the least significant bit of $mask$.\n5. Set $dp[mask] = dp[mask \\oplus (1 \\ll i)]$.\n6. Iterate through all $j$ from $i+1$ to $N-1$.\n7. If vertex $j$ is in the subset $mask$ and the edge $(i, j)$ exists, calculate the potential new maximum: $w(i, j) + dp[mask \\oplus (1 \\ll i) \\oplus (1 \\ll j)]$.\n8. Update $dp[mask]$ to be the maximum of its current value and this new potential maximum.\n9. After the loops complete, the final answer is $dp[(1 \\ll N) - 1]$.\n\nThe time complexity of this algorithm is dominated by the nested loops. The outer loop runs $2^N$ times, and the inner loop for $j$ runs $O(N)$ times. Therefore, the total time complexity is $O(N \\cdot 2^N)$, which is computationally feasible for $N \\le 22$. The space complexity is $O(2^N)$ for the DP table.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the maximum weight matching problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (4, [(0, 1, 3), (0, 2, 1), (0, 3, 4), (1, 2, 2), (1, 3, 5), (2, 3, 7)]),\n        (3, [(0, 1, -5), (1, 2, -1)]),\n        (5, [(0, 1, 8), (0, 2, 6), (1, 2, 5), (3, 4, 9)]),\n        (0, []),\n        (14, [(0, 1, 1), (2, 3, 2), (4, 5, 3), (6, 7, 4), (8, 9, 5), (10, 11, 6), (12, 13, 7)]),\n        (7, [(0, 1, 5), (1, 2, 6), (0, 2, 7), (3, 4, 4), (5, 6, 3)])\n    ]\n\n    results = []\n    for N, edges in test_cases:\n        result = _solve_max_weight_matching(N, edges)\n        results.append(int(result))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_max_weight_matching(N, edges):\n    \"\"\"\n    Computes the maximum weight matching for a single graph using bitmask dynamic programming.\n\n    The DP state dp[mask] stores the maximum weight matching for the subgraph\n    induced by the vertices represented in 'mask'.\n    \"\"\"\n    if N == 0:\n        return 0\n\n    # Use a dictionary for sparse edge storage.\n    # The key is a tuple (u, v) with u  v to represent an undirected edge canonically.\n    edge_dict = {}\n    for u, v, w in edges:\n        if u  v:\n            u, v = v, u\n        edge_dict[(u, v)] = w\n\n    # dp[mask] = max weight matching on the subset of vertices 'mask'.\n    # Use 64-bit integers to prevent overflow with large weights.\n    dp = np.zeros(1  N, dtype=np.int64)\n\n    # Iterate through all subsets of vertices, from singleton sets up to the full set.\n    for mask in range(1, 1  N):\n        # Find the index 'i' of the smallest-indexed vertex in the current subset.\n        # This is a standard way to select a pivot vertex to build the recurrence.\n        # The bitwise trick (mask  -mask) isolates the least significant bit.\n        i = (mask  -mask).bit_length() - 1\n\n        # Option 1: Vertex 'i' is unmatched.\n        # In this case, the max weight matching for 'mask' is the same as for the\n        # subproblem without 'i'.\n        dp[mask] = dp[mask ^ (1  i)]\n\n        # Option 2: Vertex 'i' is matched with some other vertex 'j' in the subset.\n        # Iterate through all possible partners 'j' for 'i'.\n        # We only need to check j  i to avoid double-counting pairs.\n        for j in range(i + 1, N):\n            # Check if vertex 'j' is in the current subset 'mask'.\n            if (mask  j)  1:\n                edge = (i, j)\n                if edge in edge_dict:\n                    weight = edge_dict[edge]\n                    \n                    # The value of this matching choice is the edge weight plus the\n                    # max matching on the remaining vertices.\n                    remaining_mask = mask ^ (1  i) ^ (1  j)\n                    current_value = weight + dp[remaining_mask]\n                    \n                    # Update the DP state for the current mask if this matching is better.\n                    if current_value  dp[mask]:\n                        dp[mask] = current_value\n\n    # The final answer is the max weight matching on the full set of vertices.\n    return dp[(1  N) - 1]\n\nsolve()\n```"
        },
        {
            "introduction": "This exercise transitions our focus from general graphs to the rich structure of trees, introducing the paradigm of Tree Dynamic Programming. You will learn to count the number of connected subgraphs of a specific size by devising a DP state that avoids overcounting, a common challenge in combinatorial problems. This practice will solidify your understanding of how to process a tree in a post-order traversal, combining solutions from child subtrees to solve the problem for the parent. ",
            "id": "3203742",
            "problem": "You are given an undirected tree $G=(V,E)$ with $|V|=N$ vertices labeled from $1$ to $N$, and $|E|=N-1$ edges. A tree is defined as a connected, acyclic graph. For an integer $K$, a connected subgraph of size exactly $K$ is defined as a subset of vertices $S \\subseteq V$ with $|S|=K$ such that the subgraph induced by $S$ is connected (that is, for every pair of vertices in $S$, there is a path entirely within $S$ connecting them). The task is to count the number of distinct connected induced subgraphs of size exactly $K$. All counts are pure integers with no physical units.\n\nBase principles to rely on:\n- The definition of a tree: a connected, acyclic, undirected graph.\n- The property of trees that between any two vertices there exists a unique simple path.\n- The concept of an induced subgraph: for $S \\subseteq V$, the induced subgraph on $S$ contains all vertices in $S$ and all edges $(u,v) \\in E$ such that $u \\in S$ and $v \\in S$.\n\nYour program must compute the count for each of the following test cases. Each test case is specified by $N$, $K$, and a set of edges. Vertices are labeled from $1$ to $N$.\n\nTest suite:\n1. Case $\\mathrm{A}$: $N=7$, $K=3$, edges $\\{(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)\\}$.\n2. Case $\\mathrm{B}$: $N=5$, $K=2$, edges $\\{(1,2),(2,3),(3,4),(4,5)\\}$.\n3. Case $\\mathrm{C}$: $N=5$, $K=3$, edges $\\{(1,2),(1,3),(1,4),(1,5)\\}$.\n4. Case $\\mathrm{D}$: $N=1$, $K=1$, edges $\\{\\}$.\n5. Case $\\mathrm{E}$: $N=3$, $K=0$, edges $\\{(1,2),(2,3)\\}$. For $K=0$, the count is defined to be $0$ since no non-empty connected subgraph has size $0$.\n6. Case $\\mathrm{F}$: $N=6$, $K=6$, edges $\\{(1,2),(2,3),(3,4),(4,5),(5,6)\\}$.\n7. Case $\\mathrm{G}$: $N=4$, $K=5$, edges $\\{(1,2),(1,3),(1,4)\\}$. For $KN$, the count is defined to be $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,\\dots]$), where $r_i$ is the integer count for the $i$-th test case in the order listed above. No other output should be produced. No angles or physical units are involved in this task. All outputs are integers.",
            "solution": "The problem as stated is a well-defined combinatorial counting problem in the domain of graph theory. All terms are standard, and the test cases are consistent and verifiable. The problem is valid and can be solved using established algorithmic techniques.\n\nThe task is to count the number of distinct connected induced subgraphs of a given size $K$ in a tree $G=(V, E)$, where $|V|=N$. A brute-force check of all $\\binom{N}{K}$ vertex subsets is computationally prohibitive. The tree structure of the graph suggests a dynamic programming approach on the tree, often referred to as Tree DP.\n\nA fundamental property of a connected subgraph $S$ within a tree $G$ is that $S$ is itself a tree. If we root the main tree $G$ at an arbitrary vertex $r$, any connected subgraph $S$ will possess a unique \"highest\" vertex, which is the vertex in $S$ that is an ancestor of all other vertices in $S$ with respect to the root $r$. This unique vertex can be designated as the \"root\" of the subgraph $S$.\n\nThis observation allows us to partition the set of all connected subgraphs based on their unique root, ensuring that each subgraph is counted exactly once. The total count is the sum, over all vertices $u \\in V$, of the number of connected subgraphs of size $K$ that are rooted at $u$.\n\nWe formulate a dynamic programming state to compute these counts. Let's fix an arbitrary root for the entire tree $G$, for instance, vertex $1$. We will then perform a post-order traversal (DFS) from this root. For each vertex $u$, our DP state will capture information about subgraphs rooted at $u$.\n\nLet $dp[u][k]$ denote the number of connected subgraphs of size $k$ that are entirely contained within the subtree of $G$ rooted at $u$ and which themselves are rooted at $u$.\n\nThe DP values are computed via a post-order traversal:\n\n**Base Case:** For any leaf vertex $u$, the only connected subgraph rooted at $u$ within its own subtree is the one consisting of a single vertex, $\\{u\\}$. Therefore, $dp[u][1] = 1$, and $dp[u][k] = 0$ for all $k > 1$.\n\n**Recursive Step:** For an internal vertex $u$, we initialize its DP table based on the subgraph containing only itself: $dp[u][1] = 1$ and $dp[u][k] = 0$ for $k > 1$. We then iterate through each of its children, say $v_i$, and merge the DP information from the child's subtree into the parent's DP table.\n\nWhen processing a child $v_i$, we have already computed its DP table $dp[v_i]$. A new, larger connected subgraph rooted at $u$ can be formed by combining an existing connected subgraph of size $k_1$ rooted at $u$ (constructed using $u$ and its previously processed children) with a connected subgraph of size $k_2$ rooted at $v_i$. The connection is established via the edge $(u, v_i)$. The resulting subgraph is rooted at $u$ and has a new size of $k_1 + k_2$. The number of ways to form such a subgraph is the product $dp[u][k_1] \\times dp[v_i][k_2]$.\n\nThis combination process is performed for each child sequentially. Let $dp_{u, \\text{old}}$ be the DP array for $u$ before merging child $v_i$. The new DP array, $dp_{u, \\text{new}}$, is computed as follows:\n$dp_{u, \\text{new}}[k] = dp_{u, \\text{old}}[k] + \\sum_{k_1+k_2=k} dp_{u, \\text{old}}[k_1] \\times dp_{v_i}[k_2]$.\nThe first term, $dp_{u, \\text{old}}[k]$, accounts for subgraphs rooted at $u$ that do not include any vertices from the subtree of $v_i$. The summation accounts for new subgraphs formed by including a connected component from $v_i$'s subtree.\n\nAfter the post-order traversal completes, the $dp[u][k]$ table is finalized for every vertex $u$. The total number of connected subgraphs of size $K$ in the entire tree is the sum over all possible roots: $\\sum_{u \\in V} dp[u][K]$.\n\nThe time complexity is dominated by the DP merge operations. At each edge $(u, v)$ in the traversal, we perform an operation analogous to a convolution of two arrays of sizes proportional to the respective subtree sizes. The sum of these products of subtree sizes over all edges of a tree is bounded by $O(N^2)$. The space complexity is $O(N^2)$ to store the DP tables for all $N$ vertices, where each table can have up to $N+1$ entries.\n\nSpecial cases where $K=0$ or $K>N$ are handled directly as per the problem statement, with the count being $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the small N in the test cases.\nsys.setrecursionlimit(2000)\n\ndef count_connected_subgraphs(N, K, edges):\n    \"\"\"\n    Calculates the number of connected induced subgraphs of size K in a tree.\n\n    Args:\n        N (int): The number of vertices in the tree.\n        K (int): The desired size of the connected subgraphs.\n        edges (list of tuples): A list of edges defining the tree.\n\n    Returns:\n        int: The number of distinct connected subgraphs of size K.\n    \"\"\"\n    if K == 0 or K  N:\n        return 0\n    if N == 0:\n        return 0\n    # A single vertex graph.\n    if not edges:\n        return 1 if N == 1 and K == 1 else 0\n\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # dp[u][k] stores the number of connected subgraphs of size k\n    # in the subtree of u, with u as the root of the subgraph.\n    # We use np.int64 to prevent potential integer overflow with larger N.\n    dp = np.zeros((N + 1, N + 1), dtype=np.int64)\n\n    def dfs(u, p):\n        \"\"\"\n        Performs a post-order traversal to compute the DP tables.\n\n        Args:\n            u (int): The current vertex.\n            p (int): The parent of the current vertex in the DFS traversal.\n\n        Returns:\n            int: The size of the subtree rooted at u.\n        \"\"\"\n        # Base case for the DP: the subgraph with only vertex u.\n        dp[u][1] = 1\n        current_size = 1\n        \n        for v in adj[u]:\n            if v == p:\n                continue\n            \n            child_size = dfs(v, u)\n            \n            # This temporary array holds the new DP values for u after merging child v.\n            # This corresponds to the polynomial multiplication: P_u_new = P_u_old * (1 + P_v),\n            # where P(x) is the generating function for the DP counts.\n            temp_dp_u = dp[u].copy()\n\n            for k1 in range(1, current_size + 1):\n                if dp[u][k1] == 0:\n                    continue\n                for k2 in range(1, child_size + 1):\n                    if dp[v][k2] == 0:\n                        continue\n                    if k1 + k2 = N:\n                        # Combine a component of size k1 from u's current set\n                        # with a component of size k2 from v's subtree.\n                        temp_dp_u[k1 + k2] += dp[u][k1] * dp[v][k2]\n\n            dp[u] = temp_dp_u\n            current_size += child_size\n        \n        return current_size\n\n    # Start DFS from an arbitrary root (vertex 1), with a dummy parent 0.\n    dfs(1, 0)\n\n    # The total count is the sum of dp[u][K] over all possible subgraph roots u.\n    total_count = np.sum(dp[:, K])\n    \n    return total_count\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, printing the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A: N=7, K=3, edges={(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)}\n        (7, 3, [(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)]),\n        # Case B: N=5, K=2, edges={(1,2),(2,3),(3,4),(4,5)}\n        (5, 2, [(1,2),(2,3),(3,4),(4,5)]),\n        # Case C: N=5, K=3, edges={(1,2),(1,3),(1,4),(1,5)}\n        (5, 3, [(1,2),(1,3),(1,4),(1,5)]),\n        # Case D: N=1, K=1, edges={}\n        (1, 1, []),\n        # Case E: N=3, K=0, edges={(1,2),(2,3)}\n        (3, 0, [(1,2),(2,3)]),\n        # Case F: N=6, K=6, edges={(1,2),(2,3),(3,4),(4,5),(5,6)}\n        (6, 6, [(1,2),(2,3),(3,4),(4,5),(5,6)]),\n        # Case G: N=4, K=5, edges={(1,2),(1,3),(1,4)}\n        (4, 5, [(1,2),(1,3),(1,4)])\n    ]\n    \n    results = []\n    for N, K, edges in test_cases:\n        result = count_connected_subgraphs(N, K, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice problem illustrates a crucial aspect of advanced algorithm design: the synergy between structural insights and dynamic programming. The core challenge of counting pairs with even-length paths is first simplified by applying a fundamental property of trees—their bipartite nature. This exercise will guide you to first transform the problem using this graph-theoretic insight and then apply a bitmask DP to efficiently generalize the solution across all subsets of a given set of vertices. ",
            "id": "3203759",
            "problem": "You are given a connected, undirected tree on a vertex set labeled by consecutive integers. A tree is a connected simple graph with no cycles. For any two vertices, there is exactly one simple path between them. The length of a path is the number of edges it contains. For any ordered pair of distinct vertices, the parity of the path length is either even or odd. The task is to count, for a given tree, the number of unordered pairs of distinct vertices whose unique path has even length.\n\nThe foundational base for this problem is as follows:\n- A tree on a vertex set is a connected, acyclic, simple graph, so any two vertices have exactly one simple path between them.\n- Any tree is bipartite: there exists a partition of the vertex set into two independent sets such that every edge connects one vertex from each part.\n- Dynamic programming on trees refers to computing quantities on subtrees and combining them along the unique parent-child relationships.\n- Bitmask dynamic programming refers to computing values for all subsets of a small set by using recurrence relations on bitmasks that represent subsets.\n\nYour program must compute two related outputs per test tree:\n1. The total number of unordered pairs of distinct vertices whose path length in edges is even, over the entire vertex set.\n2. Given a specified small list of marked vertices of size $m$, for every subset $S$ of these marked vertices (including the empty subset), the number of unordered pairs of distinct vertices in $S$ whose path length in edges is even. Index the subsets $S$ by bitmasks from $0$ to $2^m-1$, where bit $i$ corresponds to including the $i$-th listed marked vertex.\n\nYou must implement a solution based on the above fundamental definitions, not by guessing or using a pre-derived shortcut that is not justified from these principles. The approach must be sound and must argue from the bipartite structure of trees and the definition of dynamic programming. No physical units or angles are involved.\n\nTest Suite and Input Specification:\nThere is no external input. Your program must embed and process the following four test cases. In each case, vertices are labeled from $1$ to $n$, edges are unordered pairs $(u,v)$, and the marked list is an ordered list of distinct vertices. For each case, compute:\n- First, the total count of unordered pairs of distinct vertices whose path is of even length over the entire tree.\n- Second, for the given marked list of size $m$, compute a vector $g$ of length $2^m$ where $g[\\text{mask}]$ is the count of unordered pairs with even path length among the vertices selected by $\\text{mask}$, listed in increasing mask order from $0$ to $2^m-1$.\n\nThe test cases are:\n- Test case $1$: $n=1$, edges $\\{\\}$, marked list $\\{1\\}$.\n- Test case $2$: $n=5$, edges $\\{(1,2),(1,3),(1,4),(1,5)\\}$, marked list $\\{1,2,3\\}$.\n- Test case $3$: $n=6$, edges $\\{(1,2),(2,3),(3,4),(4,5),(5,6)\\}$, marked list $\\{2,3,5,6\\}$.\n- Test case $4$: $n=7$, edges $\\{(1,2),(1,3),(2,4),(2,5),(3,6),(3,7)\\}$, marked list $\\{4,5,6\\}$.\n\nOutput format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be formed by concatenating, for each test case in order from $1$ to $4$:\n- First, the single integer for the entire-tree even-pair count for that case.\n- Then, the $2^m$ integers $g[0], g[1], \\dots, g[2^m-1]$ for that case’s marked list.\n\nThus, the final output is a single flat list of integers of length $L$, where $L$ equals the sum over test cases of $1+2^m$. No additional text should be printed.",
            "solution": "The problem requires us to count the number of unordered pairs of distinct vertices in a tree that are connected by a path of even length. This is to be done first for the entire vertex set, and second, for all subsets of a given list of marked vertices. The solution must be derived from fundamental principles, namely the bipartite nature of trees and dynamic programming.\n\n### Fundamental Principle: Path Parity and Bipartition in a Tree\n\nA key property of any tree, which is a connected acyclic graph, is that it is a bipartite graph. This means that the set of vertices $V$ can be partitioned into two disjoint and non-empty (for any tree with at least two vertices) sets, $V_0$ and $V_1$, such that every edge in the tree connects a vertex in $V_0$ to one in $V_1$. There are no edges connecting two vertices within the same set.\n\nThe distance between two vertices $u$ and $v$, denoted $d(u,v)$, is the length of the unique simple path between them. This bipartition property has a direct consequence on the parity of path lengths. Let us fix an arbitrary root vertex $r$ and assign it to one partition, say $V_0$. Any vertex $v$ is in $V_0$ if its distance from $r$, $d(v,r)$, is even. Conversely, any vertex $v$ is in $V_1$ if $d(v,r)$ is odd. For any two vertices $u, v \\in V$, the parity of the distance $d(u,v)$ is related to the parities of their distances from the root $r$ by the formula:\n$$ d(u,v) \\equiv d(u,r) + d(v,r) \\pmod 2 $$\nThis relation holds because the path from $u$ to $v$ can be constructed from the paths from $u$ to $r$ and $v$ to $r$. The length is $d(u,v) = d(u,r) + d(v,r) - 2 \\cdot d(\\text{lca}(u,v), r)$, where $\\text{lca}(u,v)$ is the lowest common ancestor of $u$ and $v$. The term $2 \\cdot d(\\text{lca}(u,v), r)$ is always even, so it does not affect the parity.\n\nFrom this, it follows that $d(u,v)$ is even if and only if $d(u,r)$ and $d(v,r)$ have the same parity. This is equivalent to saying that $u$ and $v$ belong to the same partition set in the bipartition $(V_0, V_1)$.\n\n### Algorithm for Task 1: Total Even-Path Pairs\n\nBased on the principle above, counting pairs of vertices with an even-length path is equivalent to counting pairs of vertices that lie in the same partition set.\n\n1.  **Bipartitioning the Tree**: We can find the bipartition $(V_0, V_1)$ using a graph traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS). We start from an arbitrary vertex, say $v_{start}$, and assign it to $V_0$. We then traverse the tree: any neighbor of a vertex in $V_0$ is assigned to $V_1$, and any neighbor of a vertex in $V_1$ is assigned to $V_0$. This process is equivalent to a tree dynamic programming approach where the state of a node (its partition) is determined by its parent's state.\n\n2.  **Counting Pairs**: Once the partition is complete, let $n_0 = |V_0|$ and $n_1 = |V_1|$ be the sizes of the two sets. The number of unordered pairs of distinct vertices both in $V_0$ is given by the binomial coefficient $\\binom{n_0}{2}$. Similarly, the number of pairs in $V_1$ is $\\binom{n_1}{2}$. The total number of pairs with an even path length is the sum of these two quantities:\n    $$ \\text{Total Count} = \\binom{n_0}{2} + \\binom{n_1}{2} = \\frac{n_0(n_0-1)}{2} + \\frac{n_1(n_1-1)}{2} $$\n\n### Algorithm for Task 2: Even-Path Pairs in Subsets of Marked Vertices\n\nFor the second task, we are given a list of $m$ marked vertices, $M = [v_0, v_1, \\dots, v_{m-1}]$. We need to compute the count of even-length path pairs for every subset of $M$. Subsets are identified by bitmasks from $0$ to $2^m-1$. A mask represents a subset $S_{\\text{mask}} \\subseteq M$.\n\nThis problem can be solved by applying bitmask dynamic programming.\n\n1.  **Pre-computation**: First, we perform the same bipartitioning of the entire tree as in Task 1 to determine which partition ($V_0$ or $V_1$) each vertex belongs to.\n\n2.  **Bitmask DP State**: For each mask from $0$ to $2^m-1$, we need to calculate the number of vertices in the corresponding subset $S_{\\text{mask}}$ that belong to $V_0$ and $V_1$. Let's define:\n    -   $c_0[\\text{mask}]$: The number of vertices in $S_{\\text{mask}}$ that are in $V_0$.\n    -   $c_1[\\text{mask}]$: The number of vertices in $S_{\\text{mask}}$ that are in $V_1$.\n\n3.  **DP Recurrence**: These counts can be computed efficiently. We initialize $c_0[0] = 0$ and $c_1[0] = 0$. For masks representing single-element subsets (i.e., masks that are powers of $2$), we can set the counts directly. For a mask $2^i$, corresponding to subset $\\{v_i\\}$:\n    -   $c_0[2^i] = 1$ and $c_1[2^i] = 0$ if $v_i \\in V_0$.\n    -   $c_0[2^i] = 0$ and $c_1[2^i] = 1$ if $v_i \\in V_1$.\n\n    For any other mask, we can use a recurrence. If $i$ is the index of the least significant bit of $\\text{mask}$, and $\\text{prev\\_mask} = \\text{mask} \\oplus 2^i$, then:\n    $$ c_0[\\text{mask}] = c_0[\\text{prev\\_mask}] + c_0[2^i] $$\n    $$ c_1[\\text{mask}] = c_1[\\text{prev\\_mask}] + c_1[2^i] $$\n    This allows us to compute $c_0$ and $c_1$ for all masks in $O(2^m)$ time.\n\n4.  **Final Calculation**: Once $c_0[\\text{mask}]$ and $c_1[\\text{mask}]$ are known for all masks, the desired count for each subset $S_{\\text{mask}}$, denoted $g[\\text{mask}]$, is calculated similarly to Task 1:\n    $$ g[\\text{mask}] = \\binom{c_0[\\text{mask}]}{2} + \\binom{c_1[\\text{mask}]}{2} $$\n    This is calculated for each mask from $0$ to $2^m-1$. For masks with $|S_{\\text{mask}}|  2$, this count is correctly $0$.\n\nThe combination of tree traversal for bipartitioning (a form of tree DP) and the systematic calculation over subsets (bitmask DP) provides a complete, principled solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 1,\n            \"edges\": [],\n            \"marked_list\": [1],\n        },\n        {\n            \"n\": 5,\n            \"edges\": [(1, 2), (1, 3), (1, 4), (1, 5)],\n            \"marked_list\": [1, 2, 3],\n        },\n        {\n            \"n\": 6,\n            \"edges\": [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)],\n            \"marked_list\": [2, 3, 5, 6],\n        },\n        {\n            \"n\": 7,\n            \"edges\": [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n            \"marked_list\": [4, 5, 6],\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        total_count, g_vector = solve_case(case[\"n\"], case[\"edges\"], case[\"marked_list\"])\n        final_results.append(total_count)\n        final_results.extend(g_vector)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef solve_case(n, edges, marked_list):\n    \"\"\"\n    Solves the problem for a single test case.\n    \"\"\"\n    if n == 0:\n        m = len(marked_list)\n        return 0, [0] * (1  m)\n\n    # Use 1-based indexing for vertices to match problem statement\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Step 1: Bipartition the tree using BFS\n    # partitions[i] = 0 or 1, representing the partition group of vertex i\n    # -1 indicates unvisited.\n    partitions = [-1] * (n + 1)\n    \n    # Store partition counts for all vertices\n    n_counts = [0, 0]\n\n    # Handle potentially disconnected components, though problem states connected tree\n    for i in range(1, n + 1):\n        if partitions[i] == -1:\n            q = deque([(i, 0)])\n            partitions[i] = 0\n            \n            while q:\n                u, p = q.popleft()\n                n_counts[p] += 1\n                for v in adj[u]:\n                    if partitions[v] == -1:\n                        partitions[v] = 1 - p\n                        q.append((v, 1 - p))\n\n    # Task 1: Count even-path pairs over the entire tree\n    n0, n1 = n_counts[0], n_counts[1]\n    total_even_pairs = (n0 * (n0 - 1) // 2) + (n1 * (n1 - 1) // 2)\n\n    # Task 2: Count even-path pairs for subsets of marked vertices\n    m = len(marked_list)\n    num_masks = 1  m\n    \n    # counts0[mask] / counts1[mask] store the number of marked vertices in the\n    # subset 'mask' that belong to partition 0 / 1.\n    counts0 = np.zeros(num_masks, dtype=int)\n    counts1 = np.zeros(num_masks, dtype=int)\n\n    # Bitmask DP to calculate counts for all subsets\n    for mask in range(1, num_masks):\n        # Find the index of the least significant bit\n        lsb_idx = (mask  -mask).bit_length() - 1\n        prev_mask = mask ^ (1  lsb_idx)\n        \n        # Get the vertex corresponding to this bit\n        vertex = marked_list[lsb_idx]\n        \n        # Determine its partition\n        part = partitions[vertex]\n        \n        # DP recurrence\n        if part == 0:\n            counts0[mask] = counts0[prev_mask] + 1\n            counts1[mask] = counts1[prev_mask]\n        else: # part == 1\n            counts0[mask] = counts0[prev_mask]\n            counts1[mask] = counts1[prev_mask] + 1\n            \n    # Calculate the final counts g[mask] for each subset\n    g = np.zeros(num_masks, dtype=int)\n    for mask in range(num_masks):\n        n0_mask = counts0[mask]\n        n1_mask = counts1[mask]\n        g[mask] = (n0_mask * (n0_mask - 1) // 2) + (n1_mask * (n1_mask - 1) // 2)\n        \n    return total_even_pairs, g.tolist()\n\nsolve()\n```"
        }
    ]
}