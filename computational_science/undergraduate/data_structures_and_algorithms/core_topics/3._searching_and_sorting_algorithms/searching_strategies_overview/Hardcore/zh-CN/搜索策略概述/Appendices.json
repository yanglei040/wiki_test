{
    "hands_on_practices": [
        {
            "introduction": "标准的二分搜索算法依赖于数据的完全有序性。但如果一个本已排序的数组被循环移位，破坏了其整体的单调性，我们该如何高效地查找元素呢？这个练习  引导我们调整二分搜索的逻辑，通过判断中间元素与边界的关系来确定哪个子区间保持了有序，从而在对数时间内解决这一经典问题。",
            "id": "3268840",
            "problem": "给定一个有限整数序列，该序列最初是一个长度为 $n$（$n \\geq 1$）的严格递增数组 $A$，随后通过未知数量 $k$（其中 $k \\in \\{0,1,\\dots,n-1\\}$）的循环右移变换成一个新数组 $B$。形式上，对于每个索引 $i \\in \\{0,1,\\dots,n-1\\}$，变换满足\n$$\nB[i] = A\\big((i - k) \\bmod n\\big).\n$$\n数组 $A$ 中的所有元素都是唯一的，并且 $A$ 是按严格升序排序的，即对于所有索引 $i$（$0 \\leq i  n-1$），我们有 $A[i]  A[i+1]$。你必须基于比较搜索的基本原理设计一个算法，在不重构 $A$ 或 $k$ 且不对 $B$ 重新排序的情况下，确定目标值 $x$ 在 $B$ 中的索引（如果存在）。你的算法的最坏情况时间复杂度必须为 $O(\\log n)$。\n\n推理的基本依据：\n- 论域是具有通常全序关系 $\\leq$ 的整数集。\n- 二分搜索作用于一个在全序序列上单调的谓词，从而能够在每一步通过二分法排除一半的搜索区间。\n- 对一个严格递增数组进行循环右移，会将结果数组 $B$ 分割成两个连续的段，每个段都是严格递增的，它们在 $B$ 的最小元素所在的枢轴索引处分开。\n\n你的程序必须为多个独立的测试用例实现此搜索。对于每个测试用例，将提供一个数组 $B$ 和一个目标值 $x$，你必须返回 $x$ 在 $B$ 中的零基索引（如果存在），如果 $x$ 不在 $B$ 中，则返回 $-1$。每个测试用例的结果必须是一个整数。你不能假设或显式计算移位量 $k$。\n\n测试套件：\n- 情况 1：$B = [7,9,11,1,3,5]$, $x = 3$。\n- 情况 2：$B = [1,2,3,4,5,6]$, $x = 6$。\n- 情况 3：$B = [42]$, $x = 7$。\n- 情况 4：$B = [30,40,50,5,10,20]$, $x = 5$。\n- 情况 5：$B = [12,-10,-5,0,5]$, $x = 12$。\n- 情况 6：$B = [4,5,6,7,0,1,2]$, $x = 0$。\n- 情况 7：$B = [4,5,6,7,0,1,2]$, $x = 3$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，其顺序与测试用例的顺序相同。例如，如果三个用例的结果是 $r_1$、$r_2$ 和 $r_3$，则输出行将是 $[r_1,r_2,r_3]$。",
            "solution": "该问题被评估为**有效**。它自成体系，科学上基于算法设计原理，且定义明确。该问题要求为一种特定的数据结构——循环移位的有序数组——设计一种高效的搜索算法，这是计算机科学中一个公认的问题。其约束和目标清晰且逻辑一致。\n\n任务是在 $O(\\log n)$ 时间内，在一个长度为 $n$ 的循环移位的严格递增数组 $B$ 中找到目标值 $x$。数组 $B$ 是由一个严格递增数组 $A$ 经过未知量 $k \\in \\{0, 1, \\dots, n-1\\}$ 的循环右移形成的。这种结构意味着 $B$ 由两个连续的段组成，每个段都按严格递增顺序排序。这两段的连接点，通常称为枢轴（pivot），是原数组 $A$ 的最大元素后跟其最小元素的位置。\n\n标准的二分搜索算法不能直接应用，因为整个数组 $B$ 不是单调递增的。然而，二分搜索的核心原理——每一步都将搜索空间减半——可以被调整应用。关键在于，在每一步中，识别出数组中保证有序的一个段，然后确定目标值 $x$ 是否可能位于该段内。\n\n设搜索空间由索引 $[low, high]$ 定义，初始化为 $[0, n-1]$。在我们算法的每次迭代中，执行以下步骤：\n\n1.  计算中间索引：$mid = low + \\lfloor(high - low) / 2\\rfloor$。\n2.  将中间索引处的元素 $B[mid]$ 与目标值 $x$ 进行比较。如果 $B[mid] = x$，则找到目标，返回其索引 $mid$。\n3.  如果 $B[mid] \\ne x$，我们必须决定接下来探索当前搜索空间的哪一半，是 $[low, mid-1]$ 还是 $[mid+1, high]$。这个决定基于识别出有序的子段。我们将 $B[mid]$ 与当前搜索区间的一个端点（例如 $B[low]$）进行比较。\n\n    -   **情况 A：$B[low] \\le B[mid]$。** 这个条件意味着从索引 $low$ 到 $mid$ 的子数组是严格递增有序的。枢轴（如果它存在于 $[low, high]$ 范围内）必定在右半部分，即在 $[mid+1, high]$ 中。\n        -   现在我们可以确定目标 $x$ 是否属于这个有序的左半部分。如果 $B[low] \\le x  B[mid]$，那么 $x$ 必定位于区间 $[low, mid-1]$ 内。因此，我们通过设置 $high = mid - 1$ 来更新搜索空间。\n        -   否则，$x$ 必定在右半部分，即 $[mid+1, high]$。我们通过设置 $low = mid + 1$ 来更新搜索空间。\n\n    -   **情况 B：$B[low] > B[mid]$。** 这个条件意味着枢轴位于从索引 $low$ 到 $mid$ 的子数组内。因此，从索引 $mid+1$ 到 $high$ 的右子数组必定是一个单一、连续的有序块。\n        -   我们确定目标 $x$ 是否属于这个有序的右半部分。如果 $B[mid]  x \\le B[high]$，那么 $x$ 必定位于区间 $[mid+1, high]$ 内。我们通过设置 $low = mid + 1$ 来更新搜索空间。\n        -   否则，$x$ 必定在左半部分，即 $[low, mid-1]$。我们通过设置 $high = mid - 1$ 来更新搜索空间。\n\n4.  只要 $low \\le high$，循环就继续。如果循环终止（即 $low > high$），则意味着目标 $x$ 未在数组 $B$ 中找到。在这种情况下，算法返回 $-1$。\n\n这种改进的二分搜索算法在每次迭代中都将搜索空间减半，无论满足哪种情况。比较次数与数组大小 $n$ 成对数关系。因此，该算法在不重构原始数组 $A$、不确定移位量 $k$、也不对 $B$ 进行重新排序的情况下，达到了所要求的最坏情况时间复杂度 $O(\\log n)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n\n    def search_in_rotated_array(B, x):\n        \"\"\"\n        Performs a modified binary search to find a target x in a cyclically\n        shifted sorted array B.\n\n        Args:\n            B (np.ndarray): The cyclically shifted sorted array of integers.\n            x (int): The target value to search for.\n\n        Returns:\n            int: The zero-based index of x if found, otherwise -1.\n        \"\"\"\n        low = 0\n        high = len(B) - 1\n\n        while low = high:\n            mid = low + (high - low) // 2\n\n            if B[mid] == x:\n                return mid\n\n            # Case A: The left half of the search space [low...mid] is sorted.\n            # This is identified by B[low] = B[mid].\n            if B[low] = B[mid]:\n                # Check if the target is within the range of the sorted left half.\n                if B[low] = x  B[mid]:\n                    high = mid - 1\n                else:\n                    # Target must be in the right half.\n                    low = mid + 1\n            # Case B: The right half of the search space [mid+1...high] is sorted.\n            # This is implied if the left half is not sorted.\n            else:\n                # Check if the target is within the range of the sorted right half.\n                if B[mid]  x = B[high]:\n                    low = mid + 1\n                else:\n                    # Target must be in the left half.\n                    high = mid - 1\n        \n        # Target was not found in the array.\n        return -1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([7, 9, 11, 1, 3, 5]), 3),  # Case 1\n        (np.array([1, 2, 3, 4, 5, 6]), 6),  # Case 2\n        (np.array([42]), 7),                # Case 3\n        (np.array([30, 40, 50, 5, 10, 20]), 5), # Case 4\n        (np.array([12, -10, -5, 0, 5]), 12),    # Case 5\n        (np.array([4, 5, 6, 7, 0, 1, 2]), 0),  # Case 6\n        (np.array([4, 5, 6, 7, 0, 1, 2]), 3)   # Case 7\n    ]\n\n    results = []\n    for B, x in test_cases:\n        result = search_in_rotated_array(B, x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在适应性搜索算法的基础上，本练习  提出了一个更复杂的结构：“双峰”数组，其元素先单调递增后单调递减。解决这个问题的关键在于一个两步走的“分而治之”策略：首先定位数组的峰值（最大值），然后在其分割出的两个单调区间内分别进行二分搜索。这个过程展示了如何通过分解问题来应用基本的搜索算法。",
            "id": "3268712",
            "problem": "给定全序数组和严格单调序列的基本定义。一个长度为 $n$ 的数组 $A$ 被称为双调的（bitonic），如果存在一个唯一的索引 $p$（其中 $0  p  n - 1$），使得 $A[0]  A[1]  \\dots  A[p]$ 并且 $A[p] > A[p+1] > \\dots > A[n-1]$。给定一个双调数组 $A$ 和一个目标值 $x$，任务是从第一性原理出发，设计一种仅使用比较操作并利用双调数组结构特性的搜索策略，以找到一个索引 $i$ 使得 $A[i] = x$（如果存在这样的索引），或者报告不存在这样的索引。该策略必须使用严格递增和严格递减序列的性质以及全序关系来推导，并且对于满足双调定义的数组，其时间复杂度必须为 $\\mathcal{O}(\\log n)$。\n\n您的程序必须实现该搜索策略，并将其应用于以下测试套件。以下所有数组都是双调的，具有严格递增和严格递减的段，并且所有索引都是从 0 开始的。对于每对 $(A_j, x_j)$，如果存在一个整数索引 $i_j$ 使得 $A_j[i_j] = x_j$，则返回该索引；如果不存在，则返回 $-1$。\n\n测试套件：\n- 案例 1：$A_1 = [\\,1,3,7,12,14,13,9,5,2\\,]$, $x_1 = 9$。\n- 案例 2：$A_2 = [\\,2,4,8,15,14,10,3\\,]$, $x_2 = 15$。\n- 案例 3：$A_3 = [\\,1,2,3,4,3,1\\,]$, $x_3 = 10$。\n- 案例 4：$A_4 = [\\,1,5,9,11,10,4,2\\,]$, $x_4 = 1$。\n- 案例 5：$A_5 = [\\,0,2,5,7,6,3,1\\,]$, $x_5 = 1$。\n- 案例 6：$A_6 = [\\,1,3,2\\,]$, $x_6 = 2$。\n- 案例 7：$A_7 = [\\,1,4,9,12,11,7,3\\,]$, $x_7 = 4$。\n- 案例 8：$A_8 = [\\,3,8,12,11,10,6,5\\,]$, $x_8 = 6$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\,\\text{result}_1,\\text{result}_2,\\dots\\,]$）。每个结果必须是一个整数索引，如果未找到则为 $-1$。输出必须按陈述的顺序精确地汇总八个案例的答案。",
            "solution": "用户提供的问题陈述已经过验证，被确定为一个定义良好、有科学依据且结构严谨的算法挑战。它没有矛盾、歧义和事实错误。任务是为双调数组设计一个高效的搜索算法，同时遵守指定的复杂度约束，并从第一性原理推导出解决方案。\n\n### 基于第一性原理的搜索策略推导\n\n问题要求设计一个搜索算法，用于在长度为 $n$ 的双调数组 $A$ 中查找目标值 $x$。双调数组由一个唯一的索引 $p \\in (0, n-1)$ 定义，使得子数组 $A[0 \\dots p]$ 严格递增，而子数组 $A[p \\dots n-1]$ 严格递减。这种结构是高效搜索的关键。在有序数据中搜索的基本原理是二分搜索，其运行时间为 $\\mathcal{O}(\\log n)$。然而，标准的二分搜索需要一个单一、统一的单调序列。双调数组由于峰值 $A[p]$ 的存在而违反了这一条件。\n\n我们的策略是将问题分解为可管理的子问题，在这些子问题上可以应用标准的搜索原理。分解的关键在于定位峰值元素，它将数组划分为两个不同的、纯粹单调的序列。\n\n总体策略包括三个主要步骤：\n1.  定位峰值元素 $A[p]$，它是数组中的最大值。\n2.  在严格递增的子数组 $A[0 \\dots p]$ 中搜索目标 $x$。\n3.  如果未找到，则在严格递减的子数组 $A[p \\dots n-1]$ 中搜索目标 $x$。\n\n为了满足 $\\mathcal{O}(\\log n)$ 的总体复杂度要求，每个步骤都必须在对数时间内执行。\n\n#### 步骤 1：寻找双调峰值\n\n峰值索引 $p$ 是数组中最大元素的索引。我们可以使用一种改进的二分搜索算法高效地找到这个索引。该搜索利用了任何给定元素周围斜率的局部属性。对于任何索引 $m$（其中 $0  m  n-1$）：\n- 如果 $A[m-1]  A[m]  A[m+1]$，则索引 $m$ 位于递增段上。峰值必定在 $m$ 的右侧。\n- 如果 $A[m-1] > A[m] > A[m+1]$，则索引 $m$ 位于递减段上。峰值必定在 $m$ 的左侧。\n- 如果 $A[m-1]  A[m]$ 且 $A[m] > A[m+1]$，则 $m$ 就是峰值索引 $p$。\n\n这使我们能够在每一步中舍弃一半的搜索空间。设搜索区间为 $[l, h]$。我们计算中点 $m = l + \\lfloor(h-l)/2\\rfloor$。通过比较 $A[m]$ 和其相邻的 $A[m+1]$，我们决定在何处继续搜索：\n- 如果 $A[m]  A[m+1]$，我们处于上升坡段，因此峰值必定位于区间 $[m+1, h]$ 中。\n- 如果 $A[m] > A[m+1]$，我们位于峰值或下降坡段，因此峰值必定位于区间 $[l, m]$ 中。\n\n重复此过程，直到搜索区间 $[l, h]$ 收敛到单个元素，即 $l=h$。这个最终的索引就是峰值索引 $p$。此搜索的时间复杂度为 $\\mathcal{O}(\\log n)$。\n\n#### 步骤 2：在递增子数组上进行二分搜索\n\n一旦峰值索引 $p$ 已知，我们就得到了一个严格递增的子数组 $A[0 \\dots p]$。这个子数组由关系 $\\le$ 全序化。我们可以应用标准的二分搜索算法在此段中查找 $x$。\n\n在 $A[0 \\dots p-1]$ 上的二分搜索算法操作如下：\n- 设搜索区间为 $[l, h]$，初始化为 $[0, p-1]$。\n- 当 $l \\le h$ 时：\n    - 计算中点 $m = l + \\lfloor(h-l)/2\\rfloor$。\n    - 如果 $A[m] = x$，则在索引 $m$ 处找到元素。\n    - 如果 $A[m]  x$，目标必定在区间的右半部分，所以我们设置 $l = m+1$。\n    - 如果 $A[m] > x$，目标必定在区间的左半部分，所以我们设置 $h = m-1$。\n如果循环完成而没有找到 $x$，则元素不在此段中。此搜索的时间复杂度为 $\\mathcal{O}(\\log p)$，其上界为 $\\mathcal{O}(\\log n)$。我们还必须检查是否 $A[p]=x$。\n\n#### 步骤 3：在递减子数组上进行二分搜索\n\n如果在递增部分没有找到 $x$，我们就在严格递减的子数组 $A[p+1 \\dots n-1]$ 中搜索。这个子数组由关系 $\\ge$ 全序化。可以调整二分搜索以适应这种降序排列。\n\n在 $A[p+1 \\dots n-1]$ 上的二分搜索算法操作如下：\n- 设搜索区间为 $[l, h]$，初始化为 $[p+1, n-1]$。\n- 当 $l \\le h$ 时：\n    - 计算中点 $m = l + \\lfloor(h-l)/2\\rfloor$。\n    - 如果 $A[m] = x$，则在索引 $m$ 处找到元素。\n    - 如果 $A[m]  x$，因为数组是递减的，所以目标（一个更大的值）必定在左半部分。我们设置 $h = m-1$。\n    - 如果 $A[m] > x$，目标（一个更小的值）必定在右半部分。我们设置 $l = m+1$。\n如果循环完成，则 $x$ 不在此段中。此搜索的复杂度为 $\\mathcal{O}(\\log(n-p-1))$，其上界为 $\\mathcal{O}(\\log n)$。\n\n#### 完整算法的综合\n\n完整的算法集成了这三个步骤：\n\n1.  给定双调数组 $A$ 和目标 $x$。处理数组元素少于 3 个的边界情况。\n2.  调用峰值查找算法获取索引 $p$。这需要 $\\mathcal{O}(\\log n)$ 的时间。\n3.  如果 $A[p] = x$，返回 $p$。\n4.  如果 $x > A[p]$，则 $x$ 不可能存在于数组中，因为 $A[p]$ 是最大值。返回 $-1$。\n5.  在区间 $[0, p-1]$ 上执行升序二分搜索。如果在索引 $i$ 处找到 $x$，则返回 $i$。这需要 $\\mathcal{O}(\\log n)$ 的时间。\n6.  如果未找到，则在区间 $[p+1, n-1]$ 上执行降序二分搜索。如果在索引 $j$ 处找到 $x$，则返回 $j$。否则，返回 $-1$。这也需要 $\\mathcal{O}(\\log n)$ 的时间。\n\n总时间复杂度是这些步骤的复杂度之和，即 $\\mathcal{O}(\\log n) + \\mathcal{O}(\\log n) + \\mathcal{O}(\\log n) = \\mathcal{O}(\\log n)$。这满足了问题的要求，并且是从有序集合的基本性质和双调数组的特定结构推导出来的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bitonic array search problem for a given test suite.\n    \"\"\"\n\n    def find_peak(arr):\n        \"\"\"\n        Finds the peak element in a bitonic array in O(log n) time.\n        The array must be bitonic as per the problem definition (n = 3).\n        \"\"\"\n        n = len(arr)\n        low, high = 0, n - 1\n        while low  high:\n            mid = low + (high - low) // 2\n            # Compare mid with its right neighbor to determine the slope\n            if arr[mid]  arr[mid + 1]:\n                # We are on the increasing part, so the peak is to the right\n                low = mid + 1\n            else:\n                # We are at the peak or on the decreasing part, peak is to the left or at mid\n                high = mid\n        # When low == high, we have found the peak\n        return low\n\n    def binary_search_ascending(arr, low, high, x):\n        \"\"\"\n        Performs binary search on a strictly increasing subarray.\n        \"\"\"\n        while low = high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid]  x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def binary_search_descending(arr, low, high, x):\n        \"\"\"\n        Performs binary search on a strictly decreasing subarray.\n        \"\"\"\n        while low = high:\n            mid = low + (high - low) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid]  x:\n                # Since the array is descending, larger values are to the left\n                high = mid - 1\n            else:\n                # Smaller values are to the right\n                low = mid + 1\n        return -1\n\n    def search_bitonic(arr, x):\n        \"\"\"\n        Main function to search for an element in a bitonic array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n        \n        # The problem definition implies n = 3, so peak is not at 0 or n-1.\n        # This implementation of find_peak is robust for n = 1.\n        peak_index = find_peak(arr)\n\n        # Check if the peak element is the target\n        if arr[peak_index] == x:\n            return peak_index\n        \n        # If target is greater than the peak, it cannot be in the array\n        if arr[peak_index]  x:\n            return -1\n\n        # Search in the increasing part (left of the peak)\n        result = binary_search_ascending(arr, 0, peak_index - 1, x)\n        if result != -1:\n            return result\n\n        # If not found, search in the decreasing part (right of the peak)\n        result = binary_search_descending(arr, peak_index + 1, n - 1, x)\n        return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([1, 3, 7, 12, 14, 13, 9, 5, 2]), 9),\n        (np.array([2, 4, 8, 15, 14, 10, 3]), 15),\n        (np.array([1, 2, 3, 4, 3, 1]), 10),\n        (np.array([1, 5, 9, 11, 10, 4, 2]), 1),\n        (np.array([0, 2, 5, 7, 6, 3, 1]), 1),\n        (np.array([1, 3, 2]), 2),\n        (np.array([1, 4, 9, 12, 11, 7, 3]), 4),\n        (np.array([3, 8, 12, 11, 10, 6, 5]), 6),\n    ]\n\n    results = []\n    for arr, x in test_cases:\n        result = search_bitonic(arr, x)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}