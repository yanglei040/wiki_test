{
    "hands_on_practices": [
        {
            "introduction": "我们从一个常见但棘手的场景开始：调试一个有缺陷的二分搜索。许多二分搜索的实现看似正确，却在边界条件下失败，其根源往往在于循环不变量的定义和更新规则的模糊。通过分析和修复一个典型的“差一错误”（off-by-one error），你将深入理解二分搜索正确性的核心，为编写无懈可击的搜索代码打下坚实的基础。",
            "id": "3215041",
            "problem": "给定一个长度为 $n$ 的有序数组 $A$，其元素按照整数上的常规全序关系呈非递减顺序排列。任务是对于每个查询值 $x$，计算满足 $A[i] \\ge x$ 的第一个位置 $i$ 的索引。如果不存在这样的位置，则答案为 $n$。这个函数是数学上的下界，我们将其表示为 $\\text{first\\_geq}(x)$，其形式化定义为\n$$\n\\text{first\\_geq}(x) = \\min\\{\\, i \\in \\{0,1,\\dots,n\\} \\mid i=n \\ \\text{or} \\ A[i] \\ge x \\,\\}.\n$$\n一种常见的有错误的迭代方法尝试在闭区间内进行搜索，循环形式为“当 $l  r$ 时，设置 $m = \\lfloor (l + r)/2 \\rfloor$ 并进行分支判断”，但对于 $\\text{first\\_geq}(x)$ 这个特定任务，它通常使用更新规则“如果 $A[m] \\ge x$ 则 $r = m - 1$，否则 $l = m + 1$”，并最终返回 $l$。您的任务是：\n- 识别导致此方法在所有情况下都无法产生 $\\text{first\\_geq}(x)$ 的差一错误，并重写循环不变量以修复它，从而使算法对所有数组和所有 $x$ 都正确。\n- 除了有错误的迭代版本外，再为 $\\text{first\\_geq}(x)$ 实现两种正确的算法：\n  1. 使用您修复后的不变量的修正版迭代二分搜索。\n  2. 使用您修复后的不变量的修正版递归二分搜索。\n  \n您的推理应基于关于全序集的基本定义以及对于一个非递减数组 $A$，谓词 $P(i) : A[i] \\ge x$ 在 $i$ 上是单调的这一性质。\n\n您的程序必须在没有用户输入的情况下运行，并评估以下测试套件。每个测试用例是一个对 $(A, x)$，其中 $A$ 被明确给出，$x$ 是一个整数。对于每个测试用例，您必须输出一个三元组 $[b,i,r]$，其中：\n- $b$ 是上述有错误的迭代方法返回的索引，\n- $i$ 是您修正后的迭代方法返回的索引，\n- $r$ 是您修正后的递归方法返回的索引。\n\n测试套件（数组以标准列表表示法编写）：\n1. $A = []$, $x = 10$。\n2. $A = [1,3,5]$, $x = 0$。\n3. $A = [1,3,5]$, $x = 6$。\n4. $A = [1,2,2,2,5]$, $x = 2$。\n5. $A = [1,2,2,2,5]$, $x = 4$。\n6. $A = [1,1,1]$, $x = 1$。\n7. $A = [1,2,3,4,5,6,7,8]$, $x = 5$。\n8. $A = [-5,-3,0,0,0,2,9]$, $x = 0$。\n\n最终输出格式：您的程序应生成单行输出，包含测试套件的三元组列表，格式严格为\n“[[b1,i1,r1],[b2,i2,r2],...,[b8,i8,r8]]”\n，不含空格。例如，根据结果，某一行可能看起来像\n“[[0,0,0],[0,0,0],...]”\n。不应打印任何额外文本。",
            "solution": "问题要求分析一个用于在排序数组中查找值下界（lower bound）的有错误的二分搜索算法，并随后实现修正的迭代和递归版本。需要计算的函数是 $\\text{first\\_geq}(x)$，对于一个长度为 $n$ 的非递减数组 $A$，其形式化定义为：\n$$\n\\text{first\\_geq}(x) = \\min\\{\\, i \\in \\{0,1,\\dots,n\\} \\mid i=n \\ \\text{or} \\ A[i] \\ge x \\,\\}\n$$\n这是 $A$ 中第一个大于或等于 $x$ 的元素的索引。如果 $A$ 的所有元素都小于 $x$，则结果为 $n$。\n\n我们为 $i \\in \\{0, 1, \\dots, n-1\\}$ 定义一个谓词 $P(i)$ 为 $P(i): A[i] \\ge x$。由于数组 $A$ 是按非递减顺序排序的，这个谓词是单调的。也就是说，如果 $P(j)$ 对某个索引 $j$ 为真，那么对所有 $k > j$，$P(k)$ 也必定为真。因此，真值序列 $P(0), P(1), \\dots, P(n-1)$ 将由零个或多个 `False` 值后跟零个或多个 `True` 值组成。我们的目标是找到第一个 `True` 值的索引。如果所有值都为 `False`，则答案为 $n$。\n\n### 对错误算法的分析\n\n问题描述了一种有错误的迭代方法，其特点是：\n1.  在一个闭合的索引区间上进行搜索，我们假设其初始化为 $l=0, r=n-1$。这个区间 $[l, r]$ 意在包含解。\n2.  循环条件 `while l  r`。\n3.  基于中点 $m = \\lfloor(l+r)/2\\rfloor$ 的分支逻辑：\n    *   如果 $A[m] \\ge x$，更新为 $r = m-1$。\n    *   如果 $A[m]  x$，更新为 $l = m+1$。\n4.  循环终止时函数返回 $l$。\n\n根本性的缺陷在于处理 $A[m] \\ge x$ 情况的更新规则。当 $A[m] \\ge x$ 时，表示 $P(m)$ 为 `True`。这意味着我们正在寻找的索引（我们称之为 $k$）必须小于或等于 $m$（即 $k \\le m$）。索引 $m$ 本身是解的一个候选者——它可能是满足条件的*第一个*索引。然而，该算法将搜索空间的右边界更新为 $r = m-1$，从而在所有后续迭代中将 $m$ 从区间 $[l, r]$ 中排除。这种对潜在正确答案的过早排除，使得该算法从根本上无法在所有情况下解决问题。\n\n我们用一个反例来说明。考虑数组 $A = [1, 5, 10]$，长度 $n=3$，查询值为 $x=5$。$\\text{first\\_geq}(5)$ 的正确答案是 $1$，因为 $A[1]=5$ 是第一个大于或等于 $5$ 的元素。\n追踪这个有错误的算法：\n1.  初始化 $l=0$, $r=n-1=2$。区间为 $[0, 2]$。\n2.  循环 1: $l  r$ ($0  2$) 为真。\n    *   $m = \\lfloor(0+2)/2\\rfloor = 1$。\n    *   $A[1] = 5$。条件 $A[m] \\ge x$ ($5 \\ge 5$) 为真。\n    *   算法错误地更新 $r = m-1 = 0$。新的搜索区间变为 $[0, 0]$。\n3.  循环 2: $l  r$ ($0  0$) 为假。循环终止。\n4.  函数返回 $l$，其值为 $0$。\n\n算法返回 $0$，但正确答案是 $1$。错误发生的原因是索引 $1$ 处的正确解被丢弃了。\n\n### 修正的二分搜索算法\n\n为了修正该算法，我们必须重新定义搜索区间和循环不变量。对于此类搜索问题（寻找边界），一个稳健的方法是维护一个保证包含答案的区间 $[l, r]$。\n\n让答案的搜索空间为索引集合 $\\{0, 1, \\dots, n\\}$。\n**初始化：** 我们将搜索区间初始化为 $[l, r] = [0, n]$。注意，$r$ 比数组最后一个有效索引大一，这是为了处理答案为 $n$ 的情况。\n**不变量：** 修正算法的核心原则是维持循环不变量，即目标索引 $k = \\text{first\\_geq}(x)$ 始终在当前搜索区间内，即 $l \\le k \\le r$。\n**循环条件：** 只要区间包含多于一种可能性，搜索就继续，这可以表示为 `while l  r`。当 $l=r$ 时，区间已收敛到单个点，根据我们的不变量，这个点必定是解。\n\n**更新逻辑：**\n在循环内部，我们计算中点 $m = l + \\lfloor(r-l)/2\\rfloor$。然后我们检查 $A[m]$：\n1.  如果 $A[m] \\ge x$：这意味着 $P(m)$ 为 `True`。目标索引 $k$ 必须在 $m$ 或 $m$ 之前（即 $k \\le m$）。为了维持不变量 $l \\le k \\le r$，我们必须将区间更新为 $[l, m]$。我们通过设置 $r=m$ 来实现。新的区间 $[l, m]$ 仍然包含答案。\n2.  如果 $A[m]  x$：这意味着 $P(m)$ 为 `False`。目标索引 $k$ 必须在 $m$ 之后（即 $k > m$，或 $k \\ge m+1$）。为了维持不变量，我们必须将区间更新为 $[m+1, r]$。我们通过设置 $l = m+1$ 来实现。新的区间 $[m+1, r]$ 仍然包含答案。\n\n**终止：** 当 $l=r$ 时循环终止。此时，搜索区间已缩小为单个值。由于我们精心维护的不变量，这个值必定是答案，因此函数返回 $l$（或 $r$）。\n\n这个逻辑正确地处理了所有情况，包括空数组和答案为 $n$ 的情况。\n\n### 修正后的实现\n\n这个修正后的逻辑既可以迭代实现，也可以递归实现。\n\n**1. 修正的迭代算法：**\n```python\ndef first_geq_iterative(A, x):\n    n = len(A)\n    l, r = 0, n\n    while l  r:\n        m = l + (r - l) // 2\n        if A[m] >= x:\n            r = m\n        else:\n            l = m + 1\n    return l\n```\n\n**2. 修正的递归算法：**\n递归版本转换了相同的逻辑。一个辅助函数被用来通过递归调用传递搜索区间 $[l, r]$。\n```python\ndef first_geq_recursive_helper(A, x, l, r):\n    if l >= r:\n        return l\n    m = l + (r - l) // 2\n    if A[m] >= x:\n        return first_geq_recursive_helper(A, x, l, m)\n    else:\n        return first_geq_recursive_helper(A, x, m + 1, r)\n\ndef first_geq_recursive(A, x):\n    n = len(A)\n    return first_geq_recursive_helper(A, x, 0, n)\n```\n这两种算法正确地实现了 $\\text{first\\_geq}(x)$ 函数，遵循了在单调谓词上进行二分搜索的原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef buggy_iterative_first_geq(A, x):\n    \"\"\"\n    Implements the buggy iterative binary search described in the problem.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return 0\n    \n    l, r = 0, n - 1\n    \n    # Per the problem description, the buggy loop is `while l  r`\n    # combined with an update rule that prematurely discards the answer.\n    while l  r:\n        m = l + (r - l) // 2\n        if A[m] = x:\n            # This is the core bug: it discards m, which could be the answer.\n            r = m - 1\n        else:\n            l = m + 1\n            \n    # The algorithm returns l after the loop terminates.\n    # It fails on cases like A=[1,3,5], x=3, where it returns 0 instead of 1.\n    # It can also fail on cases like A=[1,3,5], x=6, where it should return 3.\n    # l=0, r=2 -> m=1, A[1]=3, l=2. loop ends, returns 2. Incorrect.\n    # A final check is needed if A[l]  x, but the buggy algorithm omits this.\n    if l >= n or A[l]  x:\n        # A post-correction step might be needed to return n, but the buggy algorithm just returns l.\n        # If we return l, it can be an out-of-bounds or incorrect index.\n        # Let's just return l as the buggy code would.\n        return l\n    return l\n\n\ndef first_geq_iterative(A, x):\n    n = len(A)\n    l, r = 0, n\n    while l  r:\n        m = l + (r - l) // 2\n        if A[m] = x:\n            r = m\n        else:\n            l = m + 1\n    return l\n\ndef first_geq_recursive_helper(A, x, l, r):\n    if l = r:\n        return l\n    m = l + (r - l) // 2\n    if A[m] = x:\n        return first_geq_recursive_helper(A, x, l, m)\n    else:\n        return first_geq_recursive_helper(A, x, m + 1, r)\n\ndef first_geq_recursive(A, x):\n    n = len(A)\n    return first_geq_recursive_helper(A, x, 0, n)\n\ndef solve_problem_1():\n    test_cases = [\n        ([], 10),\n        ([1, 3, 5], 0),\n        ([1, 3, 5], 6),\n        ([1, 2, 2, 2, 5], 2),\n        ([1, 2, 2, 2, 5], 4),\n        ([1, 1, 1], 1),\n        ([1, 2, 3, 4, 5, 6, 7, 8], 5),\n        ([-5, -3, 0, 0, 0, 2, 9], 0),\n    ]\n\n    results = []\n    for A, x in test_cases:\n        A_list = list(A)\n        b = buggy_iterative_first_geq(A_list, x)\n        i = first_geq_iterative(A_list, x)\n        r = first_geq_recursive(A_list, x)\n        results.append(f\"[{b},{i},{r}]\")\n    \n    print(f\"[{','.join(results)}]\")\n\n# Since this file contains multiple problems, we assume only one solve function is called.\n# To allow testing, we call the specific solver for this problem.\nsolve_problem_1()\n```"
        },
        {
            "introduction": "在掌握了正确的不变量逻辑后，我们来挑战实现二分搜索的两个最强大的变体：`lower_bound` 和 `upper_bound`。这两个函数超越了简单地“查找”一个元素，它们能够精确定位满足特定条件的边界，这对于在有序序列中确定插入点或处理重复值至关重要。本练习要求你从第一性原理出发，分别通过迭代和递归的方式实现这两个核心功能。",
            "id": "3215126",
            "problem": "您必须编写一个完整的程序，对于每个由一个已排序数组和一个关键字组成的测试用例，计算两个能保持非递减顺序的插入索引，且不能使用任何库搜索或插入辅助函数。目标是推导并实现迭代和递归两种版本的二分搜索，每种搜索都用于定位一个由单调谓词引出的边界索引。具体来说，给定一个长度为 $n$ 的有限整数序列 $A$（在整数的标准全序关系下按非递减顺序排序）和一个关键字 $x$，您必须计算：\n- 下界索引 $L$，定义为最小的索引 $i \\in \\{0,\\dots,n\\}$，使得在位置 $i$ 插入 $x$ 能保持排序顺序，并且 $x$ 的位置不早于任何已存在的与 $x$ 相等的元素。等价地，$L$是满足 $A[i] \\ge x$ 的最小索引 $i$，并约定当 $i = n$ 时该条件平凡成立。\n- 上界索引 $U$，定义为最小的索引 $i \\in \\{0,\\dots,n\\}$，使得在位置 $i$ 插入 $x$ 能保持排序顺序，并且 $x$ 的位置严格晚于任何已存在的与 $x$ 相等的元素。等价地，$U$是满足 $A[i] > x$ 的最小索引 $i$，并约定当 $i = n$ 时该条件平凡成立。\n\n您必须使用以下基础从第一性原理推导这两个索引：\n- 一个序列 $A$ 是按非递减顺序排序的，当且仅当对于所有满足 $0 \\le i  j  n$ 的索引 $i$ 和 $j$，我们有 $A[i] \\le A[j]$。\n- 对于任意固定的 $x$，在有序性假设下，定义在索引 $i \\in \\{0,\\dots,n-1\\}$ 上并通过 $P(n) = \\text{true}$ 和 $Q(n) = \\text{true}$ 扩展的谓词 $P(i):\\; A[i] \\ge x$ 和 $Q(i):\\; A[i] > x$ 是单调的（即一旦为真，对于所有更大的 $i$ 也为真）。\n\n基于这些，推导出一个二分搜索算法，将其视为在一个索引的半开区间上进行的不变量驱动的搜索，通过不断将区间减半，直到找到满足谓词的最小索引。实现：\n- 一个返回 $L$ 的迭代二分搜索。\n- 一个返回 $U$ 的递归二分搜索。\n\n不允许使用任何直接实现二分搜索或插入计算的标准库函数。特别是，您不能调用任何等价于在标准库中计算下界或上界的函数。\n\n您的程序必须运行以下测试套件。每个测试用例是一个对 $(A, x)$，其中 $A$ 按非递减顺序排序：\n- 用例 $1$：$A = [1,3,3,5,7]$, $x = 3$。\n- 用例 $2$：$A = [2,4,6]$, $x = 1$。\n- 用例 $3$：$A = [2,4,6]$, $x = 9$。\n- 用例 $4$：$A = [5,5,5,5]$, $x = 5$。\n- 用例 $5$：$A = [1,2,4,5]$, $x = 3$。\n- 用例 $6$：$A = []$, $x = 42$。\n- 用例 $7$：$A = [10]$, $x = 10$。\n- 用例 $8$：$A = [10]$, $x = 11$。\n- 用例 $9$：$A = [10]$, $x = 9$。\n\n您的程序必须对每个用例应用迭代算法计算 $L$、应用递归算法计算 $U$，并将结果按顺序汇总到单个输出行中，格式如下：一个单一列表，其中每个元素是一个包含两个整数的列表 $[L,U]$，不含任何额外的空白字符，且全部输出打印在一行上。形式上，如果有 $m$ 个用例，则输出一个编码为 $[[L_1,U_1],[L_2,U_2],\\dots,[L_m,U_m]]$ 的单行。\n\n所有答案均为整数；不涉及任何物理单位或角度。您可以使用大O表示法（Big O）来分析时间复杂度，但最终输出仅为指定的整数对列表。",
            "solution": "该问题是有效的。这是一个来自数据结构和算法领域的、良构的、有科学依据的问题。它不符合任何无效标准，为推導和实现二分搜索算法的两种变体提供了一套完整且一致的定义和要求。\n\n核心任务是在范围 $\\{0, \\dots, n\\}$ 中找到满足单调谓词的最小索引 $i$。如果对于任何索引 $i$ 和 $j$（其中 $i  j$），$P(i) \\implies P(j)$，那么谓词 $P(i)$ 在一个已排序序列上是单调的。这意味着如果谓词对某个索引为真，那么它对所有后续索引也为真。此属性意味着真值序列 `[P(0), P(1), ..., P(n-1)]` 将呈现 `[False, ..., False, True, ..., True]` 的形式。问题就是要找到第一个 `True` 的索引。我们通过将谓词定义为在 $n$ 处平凡为真，将此范围扩展到索引 $n$，从而确保在 $\\{0, \\dots, n\\}$ 范围内总存在一个“第一个真值”。\n\n这种结构非常适合二分搜索。算法维护一个候选索引区间 $[low, high)$，并保证目标索引包含在此区间内。该区间被迭代地减半，直到其大小变为 $1$，此时 $low$ 等于 $high$，并指向满足谓词的第一个索引。\n\n设插入索引的搜索空间为从 $0$到 $n$ 的整数。我们定义一个半开搜索索引区间 $[low, high)$。我们的目标是找到满足给定谓词的最小索引 $k$。我们维护一个不变量，即答案 $k$ 包含在 $[low, high)$ 中。\n\n最初，整个搜索空间即为候选区间，因此我们设置 $low = 0$ 和 $high = n$。注意，索引 $n$ 是一个有效的插入点。只要 $low  high$，循环或递归就继续进行。\n\n在每一步中，我们计算一个中点 $mid = low + \\lfloor \\frac{high - low}{2} \\rfloor$。然后我们评估该索引处的谓词 $P(mid)$。\n- 如果 $P(mid)$ 为真，意味着第一个真值可能在索引 $mid$ 或更早的索引处。因此，我们可以丢弃区间的右半部分 $[mid+1, high)$，并在 $[low, mid]$ 中继续搜索。我们通过设置 $high = mid$ 来实现这一点。\n- 如果 $P(mid)$ 为假，意味着第一个真值必须在一个严格大于 $mid$ 的索引处。因此，我们可以丢弃区间的左半部分 $[low, mid]$，并在 $[mid+1, high)$ 中继续搜索。我们通过设置 $low = mid + 1$ 来实现这一点。\n\n当 $low = high$ 时，过程终止。此时，区间已缩小到一个点。这个值，$low$（或 $high$），就是使 $P(k)$ 为真的最小索引 $k$。\n\n**下界 (L) - 迭代实现**\n下界 $L$ 定义为满足 $A[i] \\ge x$ 的最小索引 $i \\in \\{0, \\dots, n\\}$。这对应于查找第一个大于或等于 $x$ 的元素出现的位置。\n\n谓词是 $P(i):\\; A[i] \\ge x$。对于一个非递减排序的数组 $A$，这个谓词是单调的。我们可以应用上面推导的通用二分搜索算法来找到满足 $P(i)$ 的最小索引 $i$。问题指定了要使用迭代实现。\n\n算法如下：\n1. 初始化 $low = 0$ 和 $high = n$。\n2. 当 $low  high$ 时：\n   a. 计算 $mid = low + (high - low) // 2$。\n   b. 如果 $A[mid] \\ge x$，目标索引在 $[low, mid]$ 内。设置 $high = mid$。\n   c. 如果 $A[mid]  x$，目标索引在 $[mid+1, high]$ 内。设置 $low = mid + 1$。\n3. 返回 $low$。\n\n**上界 (U) - 递归实现**\n上界 $U$ 定义为满足 $A[i] > x$ 的最小索引 $i \\in \\{0, \\dots, n\\}$。这对应于找到严格位于所有等于 $x$ 的元素之后的插入点。\n\n谓词是 $Q(i):\\; A[i] > x$。对于一个非递减排序的数组 $A$，这个谓词也是单调的。我们应用相同的二分搜索逻辑，但按照规定使用递归实现。\n\n递归函数，例如 `search(low, high)`，将是：\n1. 基本情况：如果 $low \\ge high$，区间为空或只有一个点。返回 $low$。\n2. 递归步骤：\n   a. 计算 $mid = low + (high - low) // 2$。\n   b. 如果 $A[mid] > x$，目标索引在 $[low, mid]$ 内。递归调用 `search(low, mid)`。\n   c. 如果 $A[mid] \\le x$，目标索引在 $[mid+1, high]$ 内。递归调用 `search(mid + 1, high)`。\n\n一个包装函数将使用完整区间调用 `search(0, n)` 来启动搜索。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the binary search problem for all test cases.\n    Derives and implements iterative lower_bound and recursive upper_bound.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 3, 3, 5, 7], 3),\n        ([2, 4, 6], 1),\n        ([2, 4, 6], 9),\n        ([5, 5, 5, 5], 5),\n        ([1, 2, 4, 5], 3),\n        ([], 42),\n        ([10], 10),\n        ([10], 11),\n        ([10], 9),\n    ]\n\n    def find_lower_bound_iterative(A, x):\n        \"\"\"\n        Computes the lower bound L, the smallest index i such that A[i] = x.\n        This is an iterative implementation of binary search.\n        The search space is the half-open interval [low, high).\n        \"\"\"\n        n = len(A)\n        low, high = 0, n\n        # Invariant: The answer is in the interval [low, high).\n        # All indices k  low have A[k]  x.\n        while low  high:\n            mid = low + (high - low) // 2\n            # Predicate: A[mid] = x\n            if A[mid] = x:\n                # The element at mid satisfies the condition.\n                # The first occurrence could be at mid or to the left.\n                # Thus, we narrow the search to [low, mid].\n                high = mid\n            else:  # A[mid]  x\n                # The element at mid does not satisfy the condition.\n                # The first occurrence must be to the right of mid.\n                # Thus, we narrow the search to [mid + 1, high).\n                low = mid + 1\n        # When the loop terminates, low == high, which is the first index\n        # where the predicate A[i] = x is true.\n        return low\n\n    def find_upper_bound_recursive(A, x):\n        \"\"\"\n        Wrapper function to compute the upper bound U, the smallest index i\n        such that A[i]  x. It initiates the recursive search.\n        \"\"\"\n        n = len(A)\n        \n        def _search(low, high):\n            \"\"\"\n            Recursive helper function for binary search.\n            \"\"\"\n            # Base case: When the interval is empty or a single point,\n            # low is the answer.\n            if low = high:\n                return low\n            \n            mid = low + (high - low) // 2\n            # Predicate: A[mid]  x\n            if A[mid]  x:\n                # The element at mid satisfies the condition.\n                # The first occurrence could be at mid or to the left.\n                # Recurse on the interval [low, mid].\n                return _search(low, mid)\n            else:  # A[mid] = x\n                # The element at mid does not satisfy the condition.\n                # The first occurrence must be to the right of mid.\n                # Recurse on the interval [mid + 1, high).\n                return _search(mid + 1, high)\n\n        return _search(0, n)\n\n    results = []\n    for A, x in test_cases:\n        # Per problem, compute L iteratively and U recursively.\n        L = find_lower_bound_iterative(A, x)\n        U = find_upper_bound_recursive(A, x)\n        results.append([L, U])\n\n    # Format the final output string to exactly match [[L1,U1],[L2,U2],...]\n    # without any extra whitespace as specified.\n    formatted_pairs = []\n    for pair in results:\n        formatted_pairs.append(f\"[{pair[0]},{pair[1]}]\")\n    \n    final_output = f\"[{','.join(formatted_pairs)}]\"\n    print(final_output)\n\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们将边界查找技术应用于一个实际问题：在含有重复元素的有序数组中，高效地统计一个给定键值 $k$ 的出现次数。这个问题的巧妙解法正是利用我们刚刚练习过的边界思想——通过找到目标元素的第一个和最后一个出现位置，就能立即计算出其总数。这个练习综合了前面的概念，要求你实现两次不同的边界搜索来获得最终答案。",
            "id": "3215120",
            "problem": "给定一个来自全序集的长度为 $n$ 的有限序列 $A$，它以一个非递减排序的数组形式表示。对于一个查询键 $k$，将总出现次数 $\\mathrm{count}(A,k)$ 定义为集合 $\\{ i \\mid 0 \\le i  n \\text{ and } A[i] = k \\}$ 的基数。你的任务是设计并实现一个程序，该程序利用二分搜索的基本原理——即通过利用全序关系的比较来反复将搜索区间减半——为多个测试用例计算 $\\mathrm{count}(A,k)$。实现必须遵循以下所有要求。\n\n- 使用以下基本原理：全序关系对任意一对元素 $x$ 和 $y$ 导出三分性，使得 $x  y$、$x = y$ 或 $x > y$ 中恰好有一个成立；此外，当 $A$ 按非递减顺序排序时，如果 $i  j$，则 $A[i] \\le A[j]$。基于此，二分搜索维护一个索引区间 $[L,R]$，并在中点 $M = \\left\\lfloor \\dfrac{L+R}{2} \\right\\rfloor$ 处将 $A[M]$ 与 $k$ 进行比较，从而丢弃一半的搜索空间，同时保持一个关于 $k$ 可能出现位置的不变式。\n- 实现两个从此基础派生出的子程序：\n  1. 一个迭代式二分搜索，如果存在，则返回第一个满足 $A[i_{\\min}] = k$ 的索引 $i_{\\min}$，否则返回 $-1$。此搜索必须是纯迭代的。\n  2. 一个递归式二分搜索，如果存在，则返回最后一个满足 $A[i_{\\max}] = k$ 的索引 $i_{\\max}$，否则返回 $-1$。此搜索必须是纯递归的。\n- 按如下方式计算 $\\mathrm{count}(A,k)$：如果 $i_{\\min} = -1$，则 $\\mathrm{count}(A,k) = 0$；否则 $\\mathrm{count}(A,k) = i_{\\max} - i_{\\min} + 1$。\n- 程序不得执行任何与 $n$ 成正比的线性扫描来定位边界；它必须依赖二分搜索逻辑来找到两个边界。\n\n你的程序必须作为一个独立的、无输入的脚本运行。它必须为以下测试套件计算结果，并打印一行包含在方括号内的、由逗号分隔的整数列表。对于每个测试用例，输出是对应的 $\\mathrm{count}(A,k)$ 值。\n\n测试套件：\n- 用例 $1$：$A = [1, 1, 2, 2, 2, 3, 4]$, $k = 2$\n- 用例 $2$：$A = [1, 2, 3, 4]$, $k = 5$\n- 用例 $3$：$A = [7, 7, 7, 7, 7]$, $k = 7$\n- 用例 $4$：$A = [10]$, $k = 10$\n- 用例 $5$：$A = [10]$, $k = 9$\n- 用例 $6$：$A = []$（空数组），$k = 1$\n- 用例 $7$：$A = [2, 2, 2, 3, 4, 5]$, $k = 2$\n- 用例 $8$：$A = [1, 1, 3, 4, 4, 4]$, $k = 4$\n- 用例 $9$：$A = [1, 2, 3, 3, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8]$, $k = 3$\n- 用例 $10$：$A = [-5, -3, -3, -3, -1, 0, 0, 1]$, $k = -3$\n\n将对正确性、效率和边界情况处理进行评估。每个测试用例的预期渐近运行时间为每次边界搜索 $\\mathcal{O}(\\log n)$，迭代部分的总额外空间为 $\\mathcal{O}(1)$，递归部分的调用栈深度为 $\\mathcal{O}(\\log n)$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[\\,r_1,r_2,\\dots,r_{10}\\,]$，其中 $r_i$ 是用例 $i$ 的整数结果。",
            "solution": "所述问题是有效的。它构成了一个根植于计算机科学基本原理的、定义明确的算法挑战，特别是关于在排序数据结构上的搜索算法。该问题具有科学依据、内部一致，并包含得出唯一、可验证解所需的所有必要信息。目标是通过使用两种不同形式的二分搜索——一种迭代式，一种递归式——找到键 $k$ 在排序数组 $A$ 中首次和末次出现的索引，从而计算其出现次数。\n\n基本原理是，对于一个排序数组 $A$，对于任意索引 $i  j$，$A[i] \\le A[j]$ 的性质允许进行高效搜索。标准的二分搜索可以找到键的*一个*出现位置，但不一定是第一个或最后一个。要找到一个连续相同元素块的边界，必须修改标准算法。\n\n**1. 迭代搜索首次出现位置 ($i_{\\min}$)**\n\n为了找到第一个满足 $A[i_{\\min}] = k$ 的索引 $i_{\\min}$，我们实现一个迭代式二分搜索。该算法维护一个索引搜索区间 $[L, R]$，其初始值为 $[0, n-1]$，其中 $n$ 是数组 $A$ 的长度。使用一个变量 `first_occurrence_index` 来存储目前找到的最左侧 $k$ 的出现位置的索引，并将其初始化为 $-1$。只要 $L \\le R$，搜索循环就继续。\n\n在每次迭代中，计算中点 $M = \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$。$A[M]$ 与 $k$ 之间的比较决定了如何缩减搜索空间：\n- 如果 $A[M]  k$，$k$ 的任何出现位置都必须位于区间的右半部分。因此，通过设置 $L = M + 1$ 来更新搜索空间。\n- 如果 $A[M] > k$，$k$ 的任何出现位置都必须位于左半部分。通过设置 $R = M - 1$ 来更新搜索空间。\n- 关键的修改发生在 $A[M] = k$ 时。这个索引 $M$ 是首次出现位置的候选。我们通过设置 `first_occurrence_index = M` 来记录它。然而，左边可能存在更早的出现位置。因此，我们通过设置 $R = M - 1$ 来专门在左子区间继续搜索。\n\n这个过程保证了每当我们找到一个 $k$ 的实例时，我们都会积极地搜索一个更小索引处的实例。在循环终止前记录在 `first_occurrence_index` 中的最后一个索引将是 $k$ 的第一个出现位置。如果未找到该键，变量保持为 $-1$。\n\n**2. 递归搜索末次出现位置 ($i_{\\max}$)**\n\n为了找到最后一个满足 $A[i_{\\max}] = k$ 的索引 $i_{\\max}$，指定了使用递归式二分搜索。其逻辑与搜索 $i_{\\min}$ 对称。递归函数在数组的子区间 $[L, R]$ 上操作。\n\n- 递归的基准情况是当 $L > R$ 时。这表示区间为空，其中找不到 $k$ 的出现，因此函数返回 $-1$。\n- 在递归步骤中，我们计算中点 $M = \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$。\n- 如果 $A[M] > k$，末次出现位置（如果存在）必定在左子区间内。函数在 $[L, M-1]$ 上进行递归。\n- 如果 $A[M]  k$，末次出现位置（如果存在）必定在右子区间内。函数在 $[M+1, R]$ 上进行递归。\n- 如果 $A[M] = k$，我们在索引 $M$ 处找到了一个出现。这是末次出现位置的候选。为了确定是否存在更晚的出现，函数在右子区间 $[M+1, R]$ 上递归调用自身。设这次调用的结果为 `result_from_right`。如果 `result_from_right` 不等于 $-1$，意味着找到了一个更晚的出现，那个索引就是应该返回的正确值。如果 `result_from_right` 等于 $-1$，则确认 $M$ 的右侧不存在出现，这使得 $M$ 成为末次出现位置的索引。\n\n**3. $\\mathrm{count}(A,k)$ 的计算**\n\n总次数由两个搜索子程序的结果推导得出。\n首先，执行迭代搜索以找到 $i_{\\min}$。\n- 如果返回值为 $i_{\\min} = -1$，则键 $k$ 不存在于数组 $A$ 中。因此，$\\mathrm{count}(A,k)$ 为 $0$。\n- 如果 $i_{\\min} \\ne -1$，则键存在。然后我们执行递归搜索以找到 $i_{\\max}$。由于键存在，此搜索保证能找到一个有效的索引。总出现次数是闭区间 $[i_{\\min}, i_{\\max}]$ 中元素的数量，计算方式为 $\\mathrm{count}(A,k) = i_{\\max} - i_{\\min} + 1$。\n\n此设计遵循了所有问题约束。每次搜索（寻找 $i_{\\min}$ 和 $i_{\\max}$）的时间复杂度为 $\\mathcal{O}(\\log n)$，因为搜索区间在每一步都被减半。寻找 $i_{\\min}$ 的迭代搜索使用 $\\mathcal{O}(1)$ 的辅助空间。寻找 $i_{\\max}$ 的递归搜索在调用栈上使用 $\\mathcal{O}(\\log n)$ 的辅助空间，这对应于递归的最大深度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_first_iterative(A: np.ndarray, k: int) -> int:\n    \"\"\"\n    Finds the first occurrence of key k in a sorted array A using iterative binary search.\n    Returns the index of the first occurrence, or -1 if not found.\n    \"\"\"\n    n = len(A)\n    low, high = 0, n - 1\n    first_occurrence_index = -1\n\n    while low = high:\n        # Use floor division, though standard in Python 3\n        mid = low + (high - low) // 2\n        \n        if A[mid]  k:\n            low = mid + 1\n        elif A[mid] > k:\n            high = mid - 1\n        else:  # A[mid] == k\n            first_occurrence_index = mid\n            # Try to find an earlier occurrence in the left half\n            high = mid - 1\n            \n    return first_occurrence_index\n\ndef _find_last_recursive_helper(A: np.ndarray, k: int, low: int, high: int) -> int:\n    \"\"\"\n    Helper function for finding the last occurrence of key k recursively.\n    \"\"\"\n    if low > high:\n        return -1\n\n    mid = low + (high - low) // 2\n\n    if A[mid] > k:\n        return _find_last_recursive_helper(A, k, low, mid - 1)\n    elif A[mid]  k:\n        return _find_last_recursive_helper(A, k, mid + 1, high)\n    else:  # A[mid] == k\n        # This is a potential last occurrence. Check if a later one exists.\n        found_later = _find_last_recursive_helper(A, k, mid + 1, high)\n        if found_later != -1:\n            return found_later  # A later occurrence was found\n        else:\n            return mid # This must be the last occurrence\n\ndef find_last_recursive(A: np.ndarray, k: int) -> int:\n    \"\"\"\n    Finds the last occurrence of key k in a sorted array A using recursive binary search.\n    Returns the index of the last occurrence, or -1 if not found.\n    \"\"\"\n    n = len(A)\n    return _find_last_recursive_helper(A, k, 0, n - 1)\n\ndef count_occurrences(A: np.ndarray, k: int) -> int:\n    \"\"\"\n    Computes the total number of occurrences of k in A.\n    \"\"\"\n    i_min = find_first_iterative(A, k)\n    \n    if i_min == -1:\n        return 0\n    \n    # If the key exists, find its last occurrence\n    i_max = find_last_recursive(A, k)\n    \n    return i_max - i_min + 1\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (np.array([1, 1, 2, 2, 2, 3, 4], dtype=int), 2),\n        # Case 2\n        (np.array([1, 2, 3, 4], dtype=int), 5),\n        # Case 3\n        (np.array([7, 7, 7, 7, 7], dtype=int), 7),\n        # Case 4\n        (np.array([10], dtype=int), 10),\n        # Case 5\n        (np.array([10], dtype=int), 9),\n        # Case 6\n        (np.array([], dtype=int), 1),\n        # Case 7\n        (np.array([2, 2, 2, 3, 4, 5], dtype=int), 2),\n        # Case 8\n        (np.array([1, 1, 3, 4, 4, 4], dtype=int), 4),\n        # Case 9\n        (np.array([1, 2, 3, 3, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8], dtype=int), 3),\n        # Case 10\n        (np.array([-5, -3, -3, -3, -1, 0, 0, 1], dtype=int), -3),\n    ]\n\n    results = []\n    for A, k in test_cases:\n        result = count_occurrences(A, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}