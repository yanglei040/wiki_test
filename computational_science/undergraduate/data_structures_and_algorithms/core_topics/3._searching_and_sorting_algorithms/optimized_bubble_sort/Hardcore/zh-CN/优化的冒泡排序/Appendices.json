{
    "hands_on_practices": [
        {
            "introduction": "掌握任何算法的第一步是理解其核心操作。对于冒泡排序，这个核心就是在一轮遍历中比较和交换相邻元素。这个练习旨在通过一个思想实验来巩固这一理解：对于任意一个包含 $n$ 个元素的数组，单次冒泡排序遍历最多能执行多少次交换？通过从第一性原理出发解决这个问题，你将深化对冒泡排序“冒泡”过程力学原理的认识，并为其性能分析打下坚实基础。",
            "id": "3257625",
            "problem": "考虑一个数组 $A$，它是 $n$ 个不同元素的排列。将优化的冒泡排序算法的单次从左到右遍历定义如下：对于从 $1$ 到 $n-1$ 的索引 $i$，比较 $A[i]$ 和 $A[i+1]$，如果 $A[i]  A[i+1]$，则通过交换（swap）来互换它们的位置；如果在整个遍历过程中没有发生任何交换，算法将提前终止，不再执行后续的遍历。假设此遍历按 $i$ 递增的顺序依次执行比较，并且每次比较最多执行一次交换。从排列、相邻比较和交换的形式化定义出发，并且不借助任何关于冒泡排序的既有结论，确定对于任意一个包含 $n$ 个元素的初始排列，在单次遍历中可能发生的最大交换次数。请用一个关于 $n$ 的封闭形式解析表达式来表示你的答案。无需进行舍入。",
            "solution": "当前任务要求确定，对于一个由 $n$ 个不同元素构成的排列作为初始数组 $A$，在优化的冒泡排序算法的单次从左到右遍历中可能发生的最大交换次数。解决方案必须从基本定义推导得出，而不借助任何关于冒泡排序的既有定理。\n\n设数组表示为 $A$，其索引从 $1$ 到 $n$。单次遍历定义为对索引 $i$ 从 $1$ 到 $n-1$ 的一系列操作。对于每个 $i$，比较元素 $A[i]$ 和 $A[i+1]$。如果 $A[i]  A[i+1]$，则通过一次交换操作来互换它们的值。这个过程是顺序的，意味着在索引 $i$ 处的比较是基于在索引 $1, 2, \\dots, i-1$ 处可能已经发生的任何交换之后所形成的数组状态进行的。\n\n我们首先确定交换次数的一个上界。该遍历包含一个循环，其迭代范围为 $i = 1, 2, \\dots, n-1$。在这 $n-1$ 次迭代的每一次中，都执行一次比较。这次比较最多导致一次交换。设 $S_i$ 是一个二进制变量，表示第 $i$ 步比较的结果，如果发生交换则 $S_i=1$，否则 $S_i=0$。单次遍历中的总交换次数 $S$ 是所有步骤中交换次数的总和：\n$$S = \\sum_{i=1}^{n-1} S_i$$\n由于任何 $S_i$ 的最大值为 $1$，我们可以确定 $S$ 的一个上界：\n$$S \\le \\sum_{i=1}^{n-1} 1 = n-1$$\n这表明，无论初始排列如何，单次遍历中发生的交换次数都不会超过 $n-1$ 次。\n\n为了确定 $n-1$ 是否是*可能的最大*交换次数，我们必须证明这个上界是可以達到的。这需要找到至少一个初始排列，使得在该遍历中的每次比较都会导致一次交换。\n\n设这 $n$ 个不同元素的集合为 $\\{e_1, e_2, \\dots, e_n\\}$，其中它们按 $e_1  e_2  \\dots  e_n$ 的顺序排列。我们通过将这些元素按严格降序排列来构造一个初始排列：\n$$A_0 = [e_n, e_{n-1}, e_{n-2}, \\dots, e_2, e_1]$$\n这里，$A_0$ 表示数组的初始状态。设 $A_i$ 表示在索引 $i$ 处进行比较和可能的交换后数组的状态。\n\n现在我们用这个初始排列来追踪遍历过程：\n\n步骤 $i=1$：比较 $A_0[1]$ 和 $A_0[2]$ 处的元素。我们有 $A_0[1] = e_n$ 和 $A_0[2] = e_{n-1}$。由于 $e_n  e_{n-1}$，执行一次交换。交换次数为 $1$。数组状态变为 $A_1 = [e_{n-1}, e_n, e_{n-2}, \\dots, e_1]$。\n\n步骤 $i=2$：比较 $A_1[2]$ 和 $A_1[3]$ 处的元素。我们有 $A_1[2] = e_n$ 和 $A_1[3] = e_{n-2}$。由于 $e_n$ 是集合中的最大元素，我们知道 $e_n  e_{n-2}$。执行一次交换。累积交换次数为 $2$。数组状态变为 $A_2 = [e_{n-1}, e_{n-2}, e_n, \\dots, e_1]$。\n\n一般步骤 $i=k$，其中 $k \\in \\{1, 2, \\dots, n-1\\}$：\n我们可以通过归纳法证明，对于所选的初始排列，每一步都会发生交换。在每个步骤 $j  k$ 中，元素 $e_n$（最大元素）与一个较小的元素进行比较，并向右交换一个位置。经过 $k-1$ 步后，元素 $e_n$ 已经从其初始位置 $1$ “冒泡”到了位置 $k$。原来在位置 $2, 3, \\dots, k$ 上的元素（即 $e_{n-1}, e_{n-2}, \\dots, e_{n-k+1}$）都各自向左移动了一个位置。位置 $k+1$ 处的元素尚未受到 $e_n$ 冒泡的影响，因此它仍然是初始排列中的 $e_{n-k}$。\n因此，在步骤 $k$开始时，要比较的数组元素是：\n$$A_{k-1}[k] = e_n$$\n$$A_{k-1}[k+1] = e_{n-k}$$\n由于 $e_n$ 是整个集合中的最大元素，对于所有 $k \\in \\{1, 2, \\dots, n-1\\}$，条件 $e_n  e_{n-k}$ 都成立。因此，在遍历的每一步 $k$ 中，比较 $A_{k-1}[k]  A_{k-1}[k+1]$ 都为真。\n\n因此，在 $n-1$ 个步骤中的每一步都执行了一次交换。对于这个初始排列，总的交换次数恰好是：\n$$S = \\sum_{i=1}^{n-1} 1 = n-1$$\n\n我们已经证明了交换次数的上限为 $n-1$，并且对于逆序排列可以达到这个上界。因此，在单次遍历中可能发生的最大交换次数是 $n-1$。",
            "answer": "$$\n\\boxed{n-1}\n$$"
        },
        {
            "introduction": "对一个算法的真正掌握体现在能否从不同角度理解其过程，甚至逆向思考。想象一下，你不知道原始数组，但你拥有冒泡排序过程中的每一次交换记录以及最终的排序结果。你能否像侦探一样，通过这些线索“倒放”整个排序过程，重建出最初的无序数组？这个练习挑战你将排序过程视为一系列可逆操作，通过应用置换和逆运算的基本原理，从根本上理解算法的转换本质。",
            "id": "3257578",
            "problem": "给定一个未知整数数组经过优化冒泡排序后所执行的相邻交换的时间顺序记录，以及该数组最终的排序输出。优化的冒泡排序变体在每轮遍历后会缩减比较边界，因为剩余未排序前缀中的最大元素已被移动到末尾，并且如果一轮遍历中没有发生任何交换，它会提前终止。每次记录的交换是当时被交换的相邻对 $\\left(A[i], A[i+1]\\right)$ 的索引 $i$。索引是基于 $0$ 的。所有值都是整数，可能包含重复值。你的任务是重构排序前的原始数组。\n\n使用的基本定义：\n- 冒泡排序（升序）会重复比较相邻对 $\\left(A[i], A[i+1]\\right)$，并在 $A[i]  A[i+1]$ 时交换它们。每轮完整遍历后，算法会将有效范围减一，因为剩余的最大元素已到达其最终位置。当一轮遍历完成且交换次数为零时，优化变体终止。\n- 索引 $i$ 处的相邻交换是交换位置 $i$ 和 $i+1$ 处元素的函数 $t_i$。\n- 按时间顺序排列的交换记录 $S = \\left[i_0, i_1, \\dots, i_{k-1}\\right]$ 对应于在演变中的数组上进行的相邻置换的复合。如果 $A_0$ 表示未知的原始数组，$B$ 表示最终的排序数组，那么存在一个排列 $P$ 使得 $B = P\\left(A_0\\right)$，其中 $P$ 是由交换记录所引发的相邻置换的复合。逆排列 $P^{-1}$ 可以从 $B$ 中恢复 $A_0$。\n\n你的程序必须实现一个算法，在给定以下输入时：\n- 数组长度 $n$、\n- 最终排序后的数组 $B$，\n- 以及由优化冒泡排序生成的按时间顺序排列的交换索引列表 $S$，\n\n返回原始数组 $A_0$，该数组在通过优化冒泡排序后，会产生与给定的交换记录 $S$ 和最终排序数组 $B$ 完全相同的结果。\n\n使用纯粹的数学和逻辑推理，从上述基本定义出发设计你的算法。不要依赖任何快捷公式；从关于排列和相邻置换的第一性原理推导出重构过程。\n\n测试套件与所需输出：\n- 将你的算法应用于以下五个测试用例。每个测试用例提供 $\\left(n, B, S\\right)$ 并期望重构后的原始数组 $A_0$ 作为结果。\n    1. $n = 5$， $B = \\left[1,2,4,5,8\\right]$， $S = \\left[0,1,2,1\\right]$。\n    2. $n = 4$， $B = \\left[1,2,3,4\\right]$， $S = \\left[\\right]$。\n    3. $n = 5$， $B = \\left[1,2,3,4,5\\right]$， $S = \\left[0,1,2,3,0,1,2,0,1,0\\right]$。\n    4. $n = 4$， $B = \\left[1,1,2,3\\right]$， $S = \\left[0,1,2,1\\right]$。\n    5. $n = 1$， $B = \\left[42\\right]$， $S = \\left[\\right]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个测试用例的重构数组。这些数组以逗号分隔的列表形式包含在方括号中，每个数组本身也以方括号括起、逗号分隔的形式打印，且不含空格。例如，输出应类似于 $\\left[\\left[a_{0,0},a_{0,1},\\dots\\right],\\left[a_{1,0},a_{1,1},\\dots\\right],\\dots\\right]$。",
            "solution": "该问题要求根据一个最终排序的数组 $B$ 和一个由优化冒泡排序算法产生的时间顺序交换索引记录 $S$，重构原始的整数数组，记为 $A_0$。任务的核心是逆转排序过程以恢复初始状态 $A_0$。这可以通过将由交换记录定义的排列的逆运算应用于最终数组 $B$ 来完成。\n\n让我们根据所提供的定义来形式化这个过程。原始数组为 $A_0$。排序过程涉及一系列 $k$ 次相邻交换，其中 $k$ 是记录在 $S = [i_0, i_1, \\dots, i_{k-1}]$ 中的总交换次数。令 $t_i$ 表示交换数组中索引 $i$ 和 $i+1$ 处元素的相邻置换算子。\n\n排序过程逐步转换数组。为便于推导，我们使用基于 1 的索引来表示交换序列，令 $A^{(j)}$ 为第 $j$ 次交换后数组的状态（$j$ 从 1 到 $k$）。\n初始状态为 $A^{(0)} = A_0$。\n第一次交换（在索引 $i_0$ 处）后的状态为 $A^{(1)} = t_{i_0}(A^{(0)})$。\n第二次交换（在索引 $i_1$ 处）后的状态为 $A^{(2)} = t_{i_1}(A^{(1)})$。\n这个过程持续 $k$ 次交换。最终排序的数组 $B$ 是最后一次交换后的状态：\n$$B = A^{(k)} = t_{i_{k-1}}(A^{(k-1)})$$\n通过反复代入先前状态的表达式，我们可以将 $B$ 表示为所有置换算子作用于原始数组 $A_0$ 的复合：\n$$B = t_{i_{k-1}}(t_{i_{k-2}}(\\dots(t_{i_0}(A_0))\\dots))$$\n用函数复合的语言来表示，即为：\n$$B = (t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0})(A_0)$$\n我们将整个排序过程产生的总排列 $P$ 定义为这些置换的复合：\n$$P = t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0}$$\n因此，原始数组 $A_0$ 和最终数组 $B$ 之间的关系是 $B = P(A_0)$。\n\n我们的目标是找到 $A_0$。为此，我们必须将逆排列 $P^{-1}$ 应用于等式两边：\n$$P^{-1}(B) = P^{-1}(P(A_0))$$\n$$P^{-1}(B) = (P^{-1} \\circ P)(A_0)$$\n由于 $P^{-1} \\circ P$ 是单位排列，我们得到：\n$$A_0 = P^{-1}(B)$$\n现在，我们必须找到逆排列 $P^{-1}$。复合算子的逆 $(g \\circ f)^{-1}$ 是 $f^{-1} \\circ g^{-1}$。将此规则应用于 $P$：\n$$P^{-1} = (t_{i_{k-1}} \\circ t_{i_{k-2}} \\circ \\dots \\circ t_{i_0})^{-1} = t_{i_0}^{-1} \\circ t_{i_1}^{-1} \\circ \\dots \\circ t_{i_{k-1}}^{-1}$$\n相邻置换 $t_i$ 是交换两个元素的操作。应用两次相同的交换会将元素恢复到其原始位置。因此，任何相邻置换都是其自身的逆：$t_i \\circ t_i = \\text{恒等运算}$，这意味着 $t_i^{-1} = t_i$。\n\n将 $t_i^{-1} = t_i$ 代入 $P^{-1}$ 的表达式，我们得到：\n$$P^{-1} = t_{i_0} \\circ t_{i_1} \\circ \\dots \\circ t_{i_{k-1}}$$\n最后，我们可以将 $A_0$ 的重构表示为：\n$$A_0 = (t_{i_0} \\circ t_{i_1} \\circ \\dots \\circ t_{i_{k-1}})(B)$$\n这种复合关系规定，要获得 $A_0$，我们必须从最终数组 $B$ 开始，并依次应用置换 $t_{i_{k-1}}$、$t_{i_{k-2}}$，依此类推，直到最后的 $t_{i_0}$。这等价于按相反的时间顺序遍历给定的交换记录 $S = [i_0, i_1, \\dots, i_{k-1}]$，并应用每次交换。\n\n重构 $A_0$ 的算法如下：\n1. 创建最终排序数组 $B$ 的一个可变副本。我们称之为 `current_array`。\n2. 从最后一个索引 $k-1$ 到第一个索引 $0$，反向遍历交换索引列表 $S$。\n3. 对于在此反向迭代中遇到的每个交换索引 $i_j$，在 `current_array` 的索引 $i_j$ 处执行一次相邻交换。也就是说，交换元素 `current_array`$[i_j]$ 和 `current_array`$[i_j+1]$。\n4. 循环完成后，`current_array` 将保存原始数组 $A_0$ 的状态。\n\n该算法完全按照要求，从排列及其逆的第一性原理推导得出。它正确地逆转了记录的变换过程，以恢复初始状态。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the array reconstruction problem for a given suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n, B, S)\n    # n: integer, length of the array\n    # B: list, the final sorted array\n    # S: list, the chronological list of swap indices\n    test_cases = [\n        (5, [1, 2, 4, 5, 8], [0, 1, 2, 1]),\n        (4, [1, 2, 3, 4], []),\n        (5, [1, 2, 3, 4, 5], [0, 1, 2, 3, 0, 1, 2, 0, 1, 0]),\n        (4, [1, 1, 2, 3], [0, 1, 2, 1]),\n        (1, [42], [])\n    ]\n\n    def reconstruct_array(n, B, S):\n        \"\"\"\n        Reconstructs the original array A0 from the final sorted array B and\n        the chronological swap record S.\n\n        Args:\n            n (int): The length of the array.\n            B (list): The final sorted array.\n            S (list): The chronological list of swap indices.\n\n        Returns:\n            list: The reconstructed original array A0.\n        \"\"\"\n        # Start with the final sorted array. Use a numpy array for mutability and\n        # to adhere to the specified environment.\n        current_array = np.array(B)\n\n        # To find the original array, we must reverse the sorting process.\n        # This is achieved by applying the swaps in the reverse chronological order\n        # to the final sorted array. The inverse of a swap is the swap itself.\n        for swap_index in reversed(S):\n            # temp = current_array[swap_index]\n            # current_array[swap_index] = current_array[swap_index + 1]\n            # current_array[swap_index + 1] = temp\n            \n            # A more Pythonic way to swap elements\n            current_array[swap_index], current_array[swap_index + 1] = \\\n                current_array[swap_index + 1], current_array[swap_index]\n\n        return current_array.tolist()\n\n    results = []\n    for case in test_cases:\n        n, B, S = case\n        original_array = reconstruct_array(n, B, S)\n        results.append(original_array)\n\n    # Format the results into the exact single-line string specified.\n    # e.g., [[a,b,c],[d,e],...]\n    formatted_results = []\n    for r in results:\n        formatted_results.append(f\"[{','.join(map(str, r))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}