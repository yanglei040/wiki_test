{
    "hands_on_practices": [
        {
            "introduction": "著名的贪心算法，如 Dijkstra 算法，其正确性并非理所当然，而是依赖于问题本身的一个关键属性——边权重非负。这个练习将挑战我们对这一核心原则的理解。通过将路径成本的定义从“和”变为“积”，我们探索了一个类似 Dijkstra 的贪心策略在何种条件下才能保持其正确性，从而揭示贪心选择性质的本质。 ",
            "id": "3237567",
            "problem": "给定一个有向图 $G=(V,E)$，其边权重 $w:E\\to \\mathbb{R}_{>0}$ 均为严格正数。对于从源节点 $s\\in V$ 到目标节点 $t\\in V$ 的任意路径 $P=(e_{1},e_{2},\\dots,e_{k})$，其代价定义为其边权重的乘积\n$$\n\\mathrm{cost}(P) \\;=\\; \\prod_{i=1}^{k} w(e_{i}).\n$$\n考虑一个模仿 Dijkstra 算法的贪心算法：对于每个顶点 $v\\in V$，它维护一个暂定标签 $d(v)$，其值等于从 $s$ 到 $v$ 目前已找到的最小边权重乘积。算法将 $d(s)$ 初始化为 $1$，对所有 $v\\neq s$ 初始化 $d(v)=+\\infty$。然后，它迭代地在未处理的顶点中选择具有最小 $d(x)$ 值的顶点 $x$，将 $x$ 标记为已处理（最终确定），并对它的每条出边 $(x,y)\\in E$ 进行松弛操作，更新 $d(y)\\leftarrow \\min\\{d(y),\\,d(x)\\cdot w(x,y)\\}$。问题在于，这种贪心选择对于最小化乘积是否是安全的，也就是说，一旦一个顶点 $x$ 因其具有最小的暂定乘积 $d(x)$ 而被选中，它的标签 $d(x)$ 是否就等于从 $s$ 到 $x$ 的真实最小乘积。\n\n关于这种类 Dijkstra 的贪心方法何时能正确找到从 $s$ 到每个顶点（并因此到 $t$）的最小乘积路径，以下哪个陈述是正确的？\n\nA. 对于所有 $w(e)>0$ 的图，该算法都无需任何转换即可生效；松弛操作中的乘法保留了贪心选择属性。\n\nB. 对于所有 $w(e)>0$ 的图，如果我们通过 $w'(e)=\\ln w(e)$ 转换边权重，并在带有权重 $w'$ 的图 $(V,E)$ 上运行标准 Dijkstra 算法，该算法就会生效。\n\nC. 当且仅当所有边 $e\\in E$ 的权重 $w(e)\\ge 1$ 时，该算法才生效；如果任何边的权重 $w(e)  1$，贪心选择就可能失败。\n\nD. 即使所有 $w(e)\\ge 1$，该算法也永远无法用于乘积最小化。\n\nE. 只要图没有环，无论 $w(e)0$ 的值如何，该算法都生效。",
            "solution": "用户要求我批判性地分析一个关于改进版 Dijkstra 算法在有向图中寻找最小乘积路径的问题。\n\n### 第一步：提取已知信息\n-   **图：** 一个有向图 $G=(V,E)$。\n-   **边权重：** 一个函数 $w:E\\to \\mathbb{R}_{0}$，其中 $\\mathbb{R}_{0}$ 表示严格正实数。\n-   **路径代价：** 对于路径 $P=(e_{1},e_{2},\\dots,e_{k})$，其代价定义为边权重的乘积：$\\mathrm{cost}(P) = \\prod_{i=1}^{k} w(e_{i})$。\n-   **算法：** 一个类似于 Dijkstra 算法的贪心算法。\n    -   **初始化：** 对于源顶点 $s \\in V$，暂定代价值标签被设置为 $d(s)=1$，对于所有 $v \\in V, v \\neq s$ 设置为 $d(v)=+\\infty$。\n    -   **迭代：** 算法迭代地选择一个未处理的顶点 $x$，其暂定代价值 $d(x)$ 最小，将其标记为已处理，然后松弛其出边。\n    -   **松弛：** 对于每条边 $(x,y) \\in E$，$y$ 的标签通过规则 $d(y) \\leftarrow \\min\\{d(y),\\,d(x)\\cdot w(x,y)\\}$ 进行更新。\n-   **问题：** 在什么条件下，该算法的贪心选择是安全的？一个“安全”的贪心选择意味着，当一个顶点 $x$ 被选择并标记为已处理时，其标签 $d(x)$ 等于从 $s$到 $x$ 的真实最小乘积路径代价。任务是从给定的选项中确定描述这些条件的正确陈述。\n\n### 第二步：使用提取的信息进行验证\n该问题陈述是图算法领域（计算机科学和离散数学的一个子领域）中一个定义明确的问题。\n\n-   **科学上合理：** 问题使用了图论（有向图、边权重、路径）和算法学（贪心算法、松弛）中的标准、形式化定义。这些概念在数学上是严谨的。\n-   **适定性：** 问题明确。算法的行为被清晰地描述。问题要求的是该特定算法在何种条件下是正确的，这是算法理论中一种标准的分析形式。关于这些条件应该存在一个唯一的答案。\n-   **客观性：** 问题以客观、数学的语言表述。没有主观或模棱两可的术语。\n-   **缺陷清单：**\n    1.  **科学/事实上不合理：** 无。设置在数学上是一致的。\n    2.  **不可形式化/不相关：** 无。问题可直接形式化，并且是最短路径问题的经典扩展，与贪心算法的研究高度相关。\n    3.  **不完整/矛盾的设置：** 无。所有必要组件（图、代价函数、算法）均已定义。约束 $w(e)  0$ 是关键的并且已给出。\n    4.  **不切实际/不可行：** 不适用，因为这是一个理论计算机科学问题。\n    5.  **不适定/结构不良：** 无。\n    6.  **伪深刻/琐碎/同义反复：** 无。该问题要求仔细分析 Dijkstra 算法的核心原理，以及它们如何适应乘法代价函数，这是一项不平凡的任务。\n    7.  **超出科学可验证范围：** 无。算法的正确性可以在给定条件下通过数学方法证明或证伪。\n\n### 第三步：结论与行动\n问题陈述是**有效的**。可以继续进行求解过程。\n\n### 基于原理的推导\n最小化正权重乘积的问题，即 $\\min \\prod w(e_i)$，可以通过应用自然对数（一个严格递增函数）转换为一个等价问题。最小化一个值等价于最小化它的对数。\n\n设路径 $P$ 的代价为 $C(P) = \\prod_{e_i \\in P} w(e_i)$。\n代价的对数为 $\\ln(C(P)) = \\ln\\left(\\prod_{e_i \\in P} w(e_i)\\right)$。\n使用对数的性质，这变成了一个加法代价：\n$$\n\\ln(C(P)) = \\sum_{e_i \\in P} \\ln(w(e_i)).\n$$\n因此，寻找最小乘积代价路径的问题等价于在一个转换后的图中寻找最小和代价路径，其中每条边 $e$ 的新权重为 $w'(e) = \\ln(w(e))$。\n\n问题陈述中描述的贪心算法是 Dijkstra 算法的一个乘法版本。让我们在对数空间中分析其操作。\n-   **初始化：** $d(s)=1$ 变为 $\\ln(d(s)) = \\ln(1) = 0$。对于 $v \\neq s$，$d(v)=\\infty$ 变为 $\\ln(d(v)) = \\infty$。这是标准 Dijkstra 算法的初始化。\n-   **选择：** 算法选择具有最小暂定乘积 $d(x)$ 的顶点 $x$。由于 $\\ln(x)$ 是严格递增的，最小化 $d(x)$ 等价于最小化 $\\ln(d(x))$。此选择步骤与在对数转换后的代价上运行的标准 Dijkstra 算法的选择步骤相同。\n-   **松弛：** 更新规则是 $d(y) \\leftarrow \\min\\{d(y), d(x) \\cdot w(x,y)\\}$。在对数空间中，这变为：\n    $$\n    \\ln(d(y)) \\leftarrow \\ln(\\min\\{d(y), d(x) \\cdot w(x,y)\\}) = \\min\\{\\ln(d(y)), \\ln(d(x) \\cdot w(x,y))\\}\n    $$\n    $$\n    \\ln(d(y)) \\leftarrow \\min\\{\\ln(d(y)), \\ln(d(x)) + \\ln(w(x,y))\\}\n    $$\n    这正是在对数转换后的代价 $\\ln(d(\\cdot))$ 和边权重 $w'(e) = \\ln(w(e))$ 上执行的标准 Dijkstra 算法的松弛步骤。\n\n因此，给定的乘法贪心算法在操作上同构于在边权重为 $w'(e) = \\ln(w(e))$ 的图上运行的标准加法 Dijkstra 算法。\n\n标准 Dijkstra 算法保证能够找到从源点到所有其他顶点的最短路径，当且仅当图中所有边权重都是非负的。\n因此，给定的乘法算法是正确的，当且仅当所有转换后的边权重 $w'(e)$ 都是非负的。\n条件是：\n$$\nw'(e) \\ge 0 \\quad \\forall e \\in E\n$$\n$$\n\\ln(w(e)) \\ge 0 \\quad \\forall e \\in E\n$$\n对两边取指数，我们得到：\n$$\nw(e) \\ge e^0 \\quad \\forall e \\in E\n$$\n$$\nw(e) \\ge 1 \\quad \\forall e \\in E\n$$\n这就确定了，要使乘法风格的 Dijkstra 算法正确，其充要条件是所有边权重必须大于或等于 $1$。\n\n如果存在任何权重 $0  w(e)  1$ 的边 $e$，其对应的对数转换权重 $w'(e) = \\ln(w(e))$ 将是负数。标准 Dijkstra 算法在存在负边权重时不能保证正确工作，因此等价的乘法算法也不能保证工作。\n\n让我们为存在权重小于 $1$ 的边的情况构建一个反例。\n考虑一个图，其顶点为 $\\{s, u, y\\}$，边为：\n-   权重为 $w(s,u) = 3$ 的 $(s, u)$。\n-   权重为 $w(s,y) = 4$ 的 $(s, y)$。\n-   权重为 $w(y,u) = 0.5$ 的 $(y, u)$。\n\n1.  **初始化：** $d(s) = 1$, $d(u) = \\infty$, $d(y) = \\infty$。已处理顶点集合为 $S = \\emptyset$。处理 $s$。$S = \\{s\\}$。\n2.  **松弛从 $s$ 出发的边：** $d(u) \\leftarrow \\min(\\infty, d(s) \\cdot w(s,u)) = 1 \\cdot 3 = 3$。$d(y) \\leftarrow \\min(\\infty, d(s) \\cdot w(s,y)) = 1 \\cdot 4 = 4$。\n3.  **选择下一个顶点：** 未处理的顶点是 $u$ 和 $y$。它们的暂定代价是 $d(u)=3$ 和 $d(y)=4$。最小值是 $d(u)=3$。算法选择 $u$。\n4.  **贪心选择：** 算法将从 $s$ 到 $u$ 的代价最终确定为 $d(u)=3$。\n5.  **验证选择：** 这是真实的最小乘积代价吗？路径 $s \\to u$ 的代价是 $3$。然而，存在另一条路径：$s \\to y \\to u$。其代价为 $w(s,y) \\cdot w(y,u) = 4 \\cdot 0.5 = 2$。真实的最小代价是 $2$，但算法的贪心选择导致最终代价为 $3$。贪心选择不是安全的。这个失败证实了权重小于 $1$ 的边的存在会导致算法失败。\n\n### 逐项分析选项\n\n**A. 对于所有 $w(e)0$ 的图，该算法都无需任何转换即可生效；松弛操作中的乘法保留了贪心选择属性。**\n这是不正确的。上面提供的反例（$w(y,u) = 0.5  1$）演示了一个算法失败的情况。如果权重可以小于 $1$，贪心选择通常是不安全的。\n\n**B. 对于所有 $w(e)0$ 的图，如果我们通过 $w'(e)=\\ln w(e)$ 转换边权重，并在带有权重 $w'$ 的图 $(V,E)$ 上运行标准 Dijkstra 算法，该算法就会生效。**\n这是不正确的。该选项描述了一个不同的过程（先转换再运行标准 Dijkstra）。但即使是这个过程也不是普遍正确的。如果任何原始边权重 $w(e)$ 在区间 $(0, 1)$ 内，其转换后的权重 $w'(e) = \\ln(w(e))$ 将是负数。标准 Dijkstra 算法在有负边权重的图上不保证能正确工作。上面反例中的图在转换后，权重将是 $\\ln(3)$、$\\ln(4)$ 和 $\\ln(0.5)  0$。标准 Dijkstra 算法会在这个转换后的图上失败。\n\n**C. 当且仅当所有边 $e\\in E$ 的权重 $w(e)\\ge 1$ 时，该算法才生效；如果任何边的权重 $w(e)  1$，贪心选择就可能失败。**\n这个陈述是正确的。“当且仅当”意味着一个充要条件。\n-   **充分性：** 如果所有 $w(e) \\ge 1$，那么所有对数转换后的权重 $\\ln(w(e)) \\ge 0$。乘法算法同构于在这些非负权重上运行的标准 Dijkstra 算法，因此它是正确的。\n-   **必要性：** 第二部分，“如果任何边的权重 $w(e)  1$，贪心选择就可能失败”，解决了这一点。我们的反例证实了存在权重 $w(e)  1$ 的边确实可能导致算法失败。因此，对于所有 $e$，条件 $w(e) \\ge 1$ 不仅是充分的，而且对于算法在所有图上*保证*正确也是必要的。\n\n**D. 即使所有 $w(e)\\ge 1$，该算法也永远无法用于乘积最小化。**\n这是不正确的。如选项 C 的分析所示，当所有边权重 $w(e) \\ge 1$ 时，该算法保证能正确工作。\n\n**E. 只要图没有环，无论 $w(e)0$ 的值如何，该算法都生效。**\n这是不正确的。上面使用的反例图是一个有向无环图 (DAG)，因为它不包含环。由于边权重 $w(y,u) = 0.5  1$，算法在这个 DAG 上失败了。如果 Dijkstra 风格的贪心方法的基本要求（路径代价非递减，对应于 $w(e) \\ge 1$）被违反，无环的性质也无法挽救它。在 DAG 上的最短路径可以通过基于拓扑排序的算法正确找到，该算法按一定顺序处理顶点，保证无论边权重符号如何（只要是有限的）都能得到正确结果。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在算法设计中，一个看似最合乎逻辑的局部选择，有时却会引导我们偏离全局最优解，最短超字符串问题就是一个经典的例子。这个练习中“每次合并重叠最长的字符串对”的贪心策略极具诱惑力，因为它似乎是最大化压缩效率的最快方式。本题通过一个具体的反例，让我们亲手验证这个直觉的陷阱，并理解为什么局部最优选择可能会阻碍通往全局最优解的道路。 ",
            "id": "3237659",
            "problem": "考虑一个有限字母表上的最短超字符串问题。对于两个字符串 $x$ 和 $y$，定义有向重叠长度 $\\operatorname{ov}(x,y)$ 为满足 $x$ 的长度为 $k$ 的后缀等于 $y$ 的长度为 $k$ 的前缀的最大整数 $k \\geq 0$。贪心策略重复地从当前的多重字符串集合中选择具有最大 $\\operatorname{ov}(x,y)$ 的对 $(x,y)$，并用它们的合并结果替换它们。合并结果定义为以 $x$ 为前缀、以 $y$ 为后缀的唯一最短字符串（通过重叠匹配的后缀和前缀创建）。贪心选择性质要求在每一步选择局部最优的对，能够导向一个全局最优的最短超字符串。\n\n分析贪心策略在以下四个字符串上的表现：\n- $s_A = \\text{PQRSUVWX}$\n- $s_B = \\text{VWXtuUVW}$\n- $s_C = \\text{UVWXYZ}$\n- $s_D = \\text{XYZK}$\n\n任务：\n1. 计算所有有序对 $(s_i,s_j)$ 的重叠长度 $\\operatorname{ov}(s_i,s_j)$，其中 $s_i,s_j \\in \\{s_A,s_B,s_C,s_D\\}$ 且 $i \\neq j$。\n2. 在集合 $\\{s_A,s_B,s_C,s_D\\}$ 上逐步执行贪心算法，显示每一步选择的字符串对以及每次合并后产生的合并字符串的长度。仅当重叠长度相等时，算法可以任意打破平局；在此例中，请确保第一个选择的对是唯一具有严格最大重叠的对。\n3. 展示一个能产生最短超字符串的四个字符串的最优排序，并从第一性原理（即，通过将可行的合并序列视为最大化已实现重叠总和的路径来论证）证明其最优性，并计算这个最优最短超字符串的长度。\n4. 设 $L_{\\text{greedy}}$ 为贪心策略得到的最终长度，$L_{\\text{opt}}$ 为最优最短超字符串的长度。以精确比率 $R = \\frac{L_{\\text{greedy}}}{L_{\\text{opt}}}$ 的形式给出最终答案。无需四舍五入。\n\n你的最终答案必须是一个分数形式的单个数字。",
            "solution": "在尝试解答之前，首先对问题进行验证，以确保其是良构的、有科学依据且客观的。\n\n### 步骤 1：提取已知条件\n-   字符串：$s_A = \\text{PQRSUVWX}$，$s_B = \\text{VWXtuUVW}$，$s_C = \\text{UVWXYZ}$，$s_D = \\text{XYZK}$。\n-   重叠函数：$\\operatorname{ov}(x,y)$ 是满足 $x$ 的长度为 $k$ 的后缀等于 $y$ 的长度为 $k$ 的前缀的最大整数 $k \\geq 0$。\n-   贪心策略：重复合并具有最大 $\\operatorname{ov}(x,y)$ 的对 $(x,y)$。平局任意打破，但初始选择必须是唯一的最大值。\n-   合并操作：$(x,y)$ 的合并是以 $x$ 为前缀、以 $y$ 为后缀的唯一最短字符串。\n-   任务 1：计算所有有序对 $(s_i, s_j)$ 在 $i \\neq j$ 时的重叠长度 $\\operatorname{ov}(s_i,s_j)$。\n-   任务 2：执行贪心算法，并找到结果超字符串的长度 $L_{\\text{greedy}}$。\n-   任务 3：展示一个最优解，证明其最优性，并找到其长度 $L_{\\text{opt}}$。\n-   任务 4：计算比率 $R = \\frac{L_{\\text{greedy}}}{L_{\\text{opt}}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据（关键）**：该问题是算法领域的一个标准示例，具体涉及贪心算法和字符串问题。最短超字符串问题是一个著名的 NP-难问题，对贪心启发式算法性能的分析是一个经典课题。该问题具有科学合理性。\n-   **良构性**：所有术语如“重叠”和“合并”都有精确定义。任务是具体的，并根据所提供的数据和规则导向一个可计算的、唯一的答案。平局打破规则虽然简单，但对于第一步来说是足够的。问题是自包含的。\n-   **客观性（关键）**：问题陈述是事实性的，并使用精确、无偏见的语言。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答\n\n由一系列字符串合并形成的超字符串的长度，等于各个字符串的长度之和减去每步合并中实现的重叠长度之和。为了找到最短超字符串，我们必须找到一个能使总重叠最大化的合并序列。\n\n**任务 1：计算所有有序对的重叠**\n给定的字符串是：\n- $s_A = \\text{PQRSUVWX}$ (长度 $8$)\n- $s_B = \\text{VWXtuUVW}$ (长度 $8$)\n- $s_C = \\text{UVWXYZ}$ (长度 $6$)\n- $s_D = \\text{XYZK}$ (长度 $4$)\n\n我们计算所有 12 个 $i \\neq j$ 的有序对 $(s_i, s_j)$ 的重叠长度 $\\operatorname{ov}(s_i, s_j)$：\n- $\\operatorname{ov}(s_A, s_B)$：$s_A$ 的后缀是 `...VWX`，$s_B$ 的前缀是 `VWX...`。重叠部分是 `VWX`，所以 $\\operatorname{ov}(s_A, s_B) = 3$。\n- $\\operatorname{ov}(s_A, s_C)$：$s_A$ 的后缀是 `...UVWX`，$s_C$ 的前缀是 `UVWX...`。重叠部分是 `UVWX`，所以 $\\operatorname{ov}(s_A, s_C) = 4$。\n- $\\operatorname{ov}(s_A, s_D)$：$s_A$ 的后缀是 `...X`，$s_D$ 的前缀是 `X...`。重叠部分是 `X`，所以 $\\operatorname{ov}(s_A, s_D) = 1$。\n- $\\operatorname{ov}(s_B, s_A)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_B, s_A) = 0$。\n- $\\operatorname{ov}(s_B, s_C)$：$s_B$ 的后缀是 `...UVW`，$s_C$ 的前缀是 `UVW...`。重叠部分是 `UVW`，所以 $\\operatorname{ov}(s_B, s_C) = 3$。\n- $\\operatorname{ov}(s_B, s_D)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_B, s_D) = 0$。\n- $\\operatorname{ov}(s_C, s_A)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_C, s_A) = 0$。\n- $\\operatorname{ov}(s_C, s_B)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_C, s_B) = 0$。\n- $\\operatorname{ov}(s_C, s_D)$：$s_C$ 的后缀是 `...XYZ`，$s_D$ 的前缀是 `XYZ...`。重叠部分是 `XYZ`，所以 $\\operatorname{ov}(s_C, s_D) = 3$。\n- $\\operatorname{ov}(s_D, s_A)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_D, s_A) = 0$。\n- $\\operatorname{ov}(s_D, s_B)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_D, s_B) = 0$。\n- $\\operatorname{ov}(s_D, s_C)$：没有公共的非空后缀/前缀。$\\operatorname{ov}(s_D, s_C) = 0$。\n\n非零重叠为：$\\operatorname{ov}(s_A, s_C) = 4$，$\\operatorname{ov}(s_A, s_B) = 3$，$\\operatorname{ov}(s_B, s_C) = 3$，$\\operatorname{ov}(s_C, s_D) = 3$，以及 $\\operatorname{ov}(s_A, s_D) = 1$。\n\n**任务 2：执行贪心算法**\n初始字符串集合是 $\\{s_A, s_B, s_C, s_D\\}$。长度总和为 $8+8+6+4=26$。\n\n**步骤 1：** 贪心策略选择具有最大重叠的对。唯一的最大重叠是 $\\operatorname{ov}(s_A, s_C) = 4$。\n我们合并 $s_A$ 和 $s_C$：\n- $s_A = \\text{PQRS} \\underline{\\text{UVWX}}$\n- $s_C = \\underline{\\text{UVWX}} \\text{YZ}$\n合并后的字符串是 $s_{AC} = \\text{PQRSUVWXYZ}$。\n这个新字符串的长度是 $|s_A| + |s_C| - \\operatorname{ov}(s_A, s_C) = 8 + 6 - 4 = 10$。\n当前的字符串集合是 $\\{s_{AC}, s_B, s_D\\}$。\n\n**步骤 2：** 我们计算新集合的重叠：\n- $\\operatorname{ov}(s_{AC}, s_B)$：$s_{AC}$ 的后缀是 `...Z`，$s_B$ 的前缀是 `V...`。重叠为 $0$。\n- $\\operatorname{ov}(s_{AC}, s_D)$：$s_{AC}$ 的后缀是 `...XYZ`，$s_D$ 的前缀是 `XYZ...`。重叠是 `XYZ`，所以 $\\operatorname{ov}(s_{AC}, s_D) = 3$。\n- $\\operatorname{ov}(s_B, s_{AC})$：$s_B$ 的后缀是 `...W`，$s_{AC}$ 的前缀是 `P...`。重叠为 $0$。\n- 原始字符串之间剩余的重叠为 $\\operatorname{ov}(s_B, s_D) = 0$ 和 $\\operatorname{ov}(s_D, s_B) = 0$。\n现在的最大重叠是 $\\operatorname{ov}(s_{AC}, s_D) = 3$。\n我们合并 $s_{AC}$ 和 $s_D$：\n- $s_{AC} = \\text{PQRSUVW} \\underline{\\text{XYZ}}$\n- $s_D = \\underline{\\text{XYZ}} \\text{K}$\n合并后的字符串是 $s_{ACD} = \\text{PQRSUVWXYZK}$。\n长度是 $|s_{AC}| + |s_D| - \\operatorname{ov}(s_{AC}, s_D) = 10 + 4 - 3 = 11$。\n当前的字符串集合是 $\\{s_{ACD}, s_B\\}$。\n\n**步骤 3：** 只剩下一对需要合并，即 $(s_{ACD}, s_B)$ 或 $(s_B, s_{ACD})$。\n- $\\operatorname{ov}(s_{ACD}, s_B)$：后缀 `...K`，前缀 `V...`。重叠为 $0$。\n- $\\operatorname{ov}(s_B, s_{ACD})$：后缀 `...W`，前缀 `P...`。重叠为 $0$。\n重叠为 $0$。我们通过拼接来合并它们。我们采用第一种顺序。\n最终的字符串是 $s_{\\text{greedy}} = s_{ACD}s_B = \\text{PQRSUVWXYZKVWXtuUVW}$。\n最终长度是 $|s_{ACD}| + |s_B| - 0 = 11 + 8 = 19$。\n\n贪心算法实现的总重叠是 $4 + 3 + 0 = 7$。\n长度是 $L_{\\text{greedy}} = 26 - 7 = 19$。\n\n**任务 3：展示一个最优解**\n贪心算法不保证得到最优解。选择最大的初始重叠 $\\operatorname{ov}(s_A, s_C) = 4$ 可能会排除掉其他能够产生更大总重叠的合并序列。我们必须寻找一个能够最大化总重叠的 $n-1=3$ 次合并的序列。\n\n让我们考虑一个与路径 $s_A \\to s_B \\to s_C \\to s_D$ 对应的替代合并序列。\n**步骤 1：** 以 $\\operatorname{ov}(s_A, s_B) = 3$ 合并 $s_A$ 和 $s_B$：\n- $s_A = \\text{PQRSU} \\underline{\\text{VWX}}$\n- $s_B = \\underline{\\text{VWX}} \\text{tuUVW}$\n- 合并后的字符串 $s_{AB} = \\text{PQRSUVWXt uUVW}$。长度为 $|s_A|+|s_B|-3 = 8+8-3=13$。\n\n**步骤 2：** 合并 $s_{AB}$ 和 $s_C$。\n- $s_{AB}$ 的后缀是 `...UVW`。$s_C = \\text{UVWXYZ}$ 的前缀是 `UVW...`。\n- 重叠为 $\\operatorname{ov}(s_{AB}, s_C) = 3$。\n- 合并后的字符串 $s_{ABC} = \\text{PQRSUVWXt uUVWXYZ}$。长度为 $|s_{AB}|+|s_C|-3 = 13+6-3=16$。\n\n**步骤 3：** 合并 $s_{ABC}$ 和 $s_D$。\n- $s_{ABC}$ 的后缀是 `...XYZ`。$s_D = \\text{XYZK}$ 的前缀是 `XYZ...`。\n- 重叠为 $\\operatorname{ov}(s_{ABC}, s_D) = 3$。\n- 合并后的字符串 $s_{ABCD} = \\text{PQRSUVWXt uUVWXYZK}$。长度为 $|s_{ABC}|+|s_D|-3 = 16+4-3=17$。\n\n该序列的总重叠为 $3 + 3 + 3 = 9$。\n得到的超字符串长度为 $L_{\\text{opt}} = (8+8+6+4) - 9 = 26 - 9 = 17$。\n\n这个长度 17 比贪心算法得到的结果 19 要短。为了证明其最优性，我们考虑可能的总重叠。可用的重叠为 $\\{4, 3, 3, 3, 1\\}$。我们需要选择 3 次合并。贪心算法选择的重叠总和为 $4+3+0=7$。我们的替代路径选择的重叠总和为 $3+3+3=9$。没有 3 次合并的组合可以产生大于 9 的总和，因为使用重叠 4（来自 $s_A \\to s_C$）使得无法同时使用重叠 $s_A \\to s_B$ 和 $s_B \\to s_C$。来自一个有效的 3 次合并序列的最大重叠总和是 9。因此，长度为 17 的超字符串是最优的。\n\n$L_{\\text{opt}} = 17$。\n\n**任务 4：计算比率**\n我们被要求计算比率 $R = \\frac{L_{\\text{greedy}}}{L_{\\text{opt}}}$。\n$L_{\\text{greedy}} = 19$\n$L_{\\text{opt}} = 17$\n比率是 $R = \\frac{19}{17}$。",
            "answer": "$$\\boxed{\\frac{19}{17}}$$"
        },
        {
            "introduction": "一个固定的贪心规则在不同应用场景下可能会产生天差地别的结果，二叉搜索树的构建过程完美地揭示了这一点。标准的建树插入算法在每一步都遵循简单的局部规则（大则放右，小则放左），这是一种典型的贪心决策。这个练习将引导我们通过构造两种截然不同的输入序列，来亲身体验同样的贪心插入算法如何既能构建出效率极高的平衡树，也能生成性能低下的退化树，从而深刻理解贪心过程对输入顺序的敏感性。 ",
            "id": "3237674",
            "problem": "考虑下列由不同且全序的键组成的集合：$S = \\{2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44\\}$。二叉搜索树（BST）是一种有根二叉树，用于存储键，其性质为：对于每个键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。标准的二叉搜索树插入算法是贪心的：给定一个新键 $k$，算法从根节点开始，将 $k$ 与当前节点的键进行比较，如果 $k$ 较小则移至左子节点，如果 $k$ 较大则移至右子节点，持续这一局部选择，直到找到一个可以插入 $k$ 的空位。\n\n你需要使用贪心插入算法，通过两种不同的插入顺序，在集合 $S$ 上构建两棵二叉搜索树：\n\n1. 一棵退化树，通过选择一个能产生严格右偏树（一条链）的插入顺序来获得。请提供一种这样的插入顺序，并论证为什么贪心插入算法对于该顺序会产生一棵右偏树。\n\n2. 一棵平衡树，通过选择一个能产生完美平衡二叉搜索树（即一棵高度为 $h$、拥有 $2^{h+1}-1$ 个节点且所有层级都已填满的完全二叉树）的插入顺序来获得。请提供一种这样的插入顺序，并论证为什么贪心插入算法对于该顺序会产生一棵完美平衡树。\n\n假设成功搜索在集合 $S$ 中的所有键上是均匀随机的。搜索一个键的成功成本定义为所执行的比较次数，对于深度为 $d$ 的节点（其中根节点深度为 $0$），该成本等于 $d+1$。\n\n计算退化树中成功搜索的平均比较次数与你构建的平衡树中成功搜索的平均比较次数之间的差值。将你的最终答案表示为一个精确的分数。无需四舍五入。",
            "solution": "题目要求从一个包含 $15$ 个键的给定集合 $S = \\{2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44\\}$ 出发，使用贪心插入算法构建两棵不同的二叉搜索树（BST）。然后我们必须计算这两棵树之间成功搜索的平均成本的差值。键的数量为 $N=15$。搜索一个位于深度 $d$ 的键的成功成本为 $d+1$，其中根节点的深度为 $d=0$。假设搜索在所有键上是均匀随机的。\n\n首先，我们分析退化的右偏树的构建和成本。\n要创建一个右偏树，其中每个节点最多只有一个右子节点，那么每个新插入的键都必须大于树中已有的所有键。贪心二叉搜索树插入算法在 $k  x$ 时将键 $k$ 放置在键为 $x$ 的节点的右侧。通过重复进行这种局部选择，为了构建一个由右子节点组成的链，我们必须按严格递增的顺序插入键。排序后的键集合为 $(2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44)$。\n因此，一种这样的插入顺序是：$(2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44)$。\n让我们追踪插入过程：\n1. 插入 $2$：树是一个单节点，即根节点，键为 $2$。\n2. 插入 $5$：因为 $5  2$，所以它被插入为 $2$ 的右子节点。\n3. 插入 $7$：因为 $7  2$，我们移到右子节点（$5$）。因为 $7  5$，所以它被插入为 $5$ 的右子节点。\n这个过程对所有键继续进行。每个新键，作为目前为止最大的键，将总是从根节点遍历最右边的路径，并作为新的最右叶子节点被插入。这将创建一个向右的简单链状退化树。\n\n在这棵右偏树中，各个键位于深度 $d=0, 1, 2, \\ldots, 14$。键 $2$ 在深度 $0$，$5$ 在深度 $1$，依此类推，直到键 $44$ 在深度 $14$。因此，这 $15$ 个键的搜索成本（$d+1$）分别为 $1, 2, 3, \\ldots, 15$。\n由于搜索是均匀分布的，搜索任何特定键的概率是 $\\frac{1}{15}$。成功搜索的平均比较次数 $C_{\\text{degen}}$ 是所有单个搜索成本的总和除以键的数量：\n$$C_{\\text{degen}} = \\frac{1}{15} \\sum_{i=1}^{15} i$$\n使用前 $n$ 个整数求和公式 $\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$：\n$$C_{\\text{degen}} = \\frac{1}{15} \\left( \\frac{15(15+1)}{2} \\right) = \\frac{16}{2} = 8$$\n\n接下来，我们分析完美平衡二叉搜索树的构建和成本。\n题目将完美平衡二叉搜索树定义为一个所有层级都已填满的完全二叉树。这样一个高度为 $h$ 的树的节点数是 $2^{h+1}-1$。我们的集合有 $N=15$ 个键，并且由于 $15 = 2^{3+1}-1$，可以形成一棵高度为 $h=3$ 的完美平衡二叉搜索树。\n\n要使用贪心插入算法构建这棵树，我们必须选择一个能将正确的键放置在正确位置的插入顺序。平衡二叉搜索树的根节点必须是排序后键的中位数。其左、右子树中的键必须以相同的方式递归地组织。这表明插入顺序应遵循目标平衡树的前序遍历。\n排序后的键集合为 $S = (2, 5, 7, 9, 12, 15, 20, 22, 25, 28, 31, 33, 36, 40, 44)$。\n$15$ 个键的中位数是第 $\\frac{15+1}{2} = 8$ 个键，即 $22$。这将是根节点。\n左子树将包含 $7$ 个小于 $22$ 的键：$\\{2, 5, 7, 9, 12, 15, 20\\}$。其根节点将是它们的中位数，即第 $4$ 个键，$9$。\n右子树将包含 $7$ 个大于 $22$ 的键：$\\{25, 28, 31, 33, 36, 40, 44\\}$。其根节点将是它们的中位数，即第 $4$ 个键（$33$）。\n延续这个逻辑，我们推断出每一层的键：\n- 深度 $d=0$：$\\{22\\}$（$1$ 个节点）\n- 深度 $d=1$：$\\{9, 33\\}$（$2$ 个节点）\n- 深度 $d=2$：$\\{5, 15, 28, 40\\}$（$4$ 个节点）\n- 深度 $d=3$：$\\{2, 7, 12, 20, 25, 31, 36, 44\\}$（$8$ 个节点）\n\n一种能创建这棵树的插入顺序是最终树结构的前序遍历：$(22, 9, 5, 2, 7, 15, 12, 20, 33, 28, 25, 31, 40, 36, 44)$。当从这个序列中插入一个键时，贪心算法会将其放置在一个空位。因为我们在插入每个子树的任何子节点之前先插入其根节点，所以算法找到的空位恰好是该键在完美平衡树中的正确位置。\n\n现在我们计算平均搜索成本 $C_{\\text{bal}}$。成本为 $d+1$。\n- 深度 $d=0$：$1$ 个节点，成本 $0+1=1$。总成本：$1 \\times 1 = 1$。\n- 深度 $d=1$：$2$ 个节点，成本 $1+1=2$。总成本：$2 \\times 2 = 4$。\n- 深度 $d=2$：$4$ 个节点，成本 $2+1=3$。总成本：$4 \\times 3 = 12$。\n- 深度 $d=3$：$8$ 个节点，成本 $3+1=4$。总成本：$8 \\times 4 = 32$。\n所有可能的成功搜索的总成本是这些成本之和：$1 + 4 + 12 + 32 = 49$。\n平均搜索成本是总成本除以键的数量 $N=15$：\n$$C_{\\text{bal}} = \\frac{49}{15}$$\n\n最后，我们计算退化树和平衡树中平均比较次数的差值：\n$$\\text{Difference} = C_{\\text{degen}} - C_{\\text{bal}} = 8 - \\frac{49}{15}$$\n为了进行减法，我们找到一个公分母：\n$$\\text{Difference} = \\frac{8 \\times 15}{15} - \\frac{49}{15} = \\frac{120}{15} - \\frac{49}{15} = \\frac{120 - 49}{15} = \\frac{71}{15}$$\n数字 $71$ 是一个素数，不能被 $15$ 整除，所以这个分数是最简形式。",
            "answer": "$$\\boxed{\\frac{71}{15}}$$"
        }
    ]
}