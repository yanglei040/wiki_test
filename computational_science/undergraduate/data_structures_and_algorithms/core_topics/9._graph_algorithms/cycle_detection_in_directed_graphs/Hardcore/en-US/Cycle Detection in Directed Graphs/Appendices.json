{
    "hands_on_practices": [
        {
            "introduction": "Our first practical challenge starts with a common real-world scenario: you are given raw data as a list of connections, not a neatly organized graph structure. This exercise guides you through the essential first step of any graph problem—constructing an efficient representation like an adjacency list from an edge list. Once your graph is built, you will implement the classic Depth-First Search (DFS) with vertex coloring to determine if any cycles exist, a cornerstone skill for analyzing dependencies and workflows. ",
            "id": "3224952",
            "problem": "You are given only a list of directed edges for each test case, without an explicit adjacency list or adjacency matrix. A directed graph is defined as $G = (V, E)$, where $V$ is a finite set of vertices and $E \\subseteq V \\times V$ is a finite set of ordered pairs representing directed edges. A directed path is a finite sequence of vertices $v_0, v_1, \\dots, v_k$ such that $(v_i, v_{i+1}) \\in E$ for all indices $i$ with $0 \\le i  k$. A directed cycle is a directed path of length at least $1$ in which the starting vertex equals the ending vertex, and there is at least one edge traversed; formally, there exist vertices $v_0, v_1, \\dots, v_k$ with $k \\ge 1$ such that $(v_i, v_{i+1}) \\in E$ for all indices $i$ with $0 \\le i  k$ and $v_0 = v_k$. A directed graph is called acyclic if it contains no directed cycle. It is a well-tested fact that a directed graph is acyclic if and only if it admits a topological ordering of its vertices. The vertex set for each test case is the set of all endpoints appearing in that test case’s edge list; vertices with no incident edges are not given and need not be inferred, as they cannot be part of any directed cycle.\n\nYour task is to write a complete, runnable program that, for each test case, constructs any internal representation needed from the provided edge list and decides whether the directed graph contains at least one directed cycle. The output for each test case must be a boolean value: $True$ if a directed cycle exists, and $False$ otherwise. The program must not assume any additional input beyond the given edge lists, and must be robust to the following realistic conditions: duplicate edges, self-loops, disconnected components, and an empty edge list.\n\nUse the following test suite of $7$ test cases, each specified as a list of ordered pairs $(u, v)$ representing a directed edge from vertex $u$ to vertex $v$:\n- Test case $1$: edges $[(1, 2), (2, 3), (3, 4)]$.\n- Test case $2$: edges $[(1, 2), (2, 3), (3, 1)]$.\n- Test case $3$: edges $[(5, 5)]$.\n- Test case $4$: edges $[(10, 11), (11, 12), (12, 10), (20, 21)]$.\n- Test case $5$: edges $[]$.\n- Test case $6$: edges $[(0, 1), (0, 1), (1, 2), (0, 2)]$.\n- Test case $7$: edges $[(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]$.\n\nFinal output format: Your program should produce a single line of output containing the results for these $7$ test cases as a comma-separated list enclosed in square brackets, in the order given above (for example, $[True,False,True,\\dots]$). No other output is permitted.",
            "solution": "The problem requires determining whether a directed graph, specified by a list of edges, contains at least one cycle. The solution must be robust to various graph structures, including disconnected components, self-loops, and duplicate edges. The fundamental approach to this problem is to perform a Depth-First Search (DFS) on the graph while maintaining the state of each vertex to detect back edges, which are indicative of cycles.\n\nThe problem can be decomposed into two main parts: first, constructing a suitable representation of the graph from the given edge list; and second, implementing a cycle detection algorithm on that representation.\n\n### Principle 1: Graph Representation from Edge List\n\nA directed graph is defined as a pair $G = (V, E)$, where $V$ is a set of vertices and $E$ is a set of directed edges. The input is a list of edges, for example, $[(u_1, v_1), (u_2, v_2), \\dots]$. From this, we first need to determine the vertex set $V$ and then structure the edges $E$ for efficient traversal.\n\n1.  **Vertex Set Construction**: The problem specifies that the vertex set $V$ consists of all unique vertices appearing as an endpoint in any edge. We can obtain $V$ by iterating through the edge list and collecting all unique vertex identifiers into a set.\n    For an edge list like $[(1, 2), (2, 3)]$, the vertex set is $V = \\{1, 2, 3\\}$.\n\n2.  **Adjacency List**: For graph traversal algorithms like DFS, an adjacency list is a common and efficient representation. An adjacency list is a mapping from each vertex $u \\in V$ to a collection of vertices $v$ for which an edge $(u, v) \\in E$ exists. A dictionary (or hash map) is an ideal data structure for this, where keys are vertices and values are lists of their adjacent neighbors.\n\n    The process to build the adjacency list is as follows:\n    - Initialize an empty dictionary, say `adj`.\n    - For each vertex $u$ in the determined vertex set $V$, initialize `adj[u] = []`.\n    - Iterate through each edge $(u, v)$ in the input list and append $v$ to the list `adj[u]`.\n\nThis construction naturally handles the specified conditions:\n-   **Duplicate edges**: If an edge $(u, v)$ appears multiple times, $v$ will be appended to `adj[u]` multiple times. This is acceptable; the cycle detection logic remains correct as it is concerned with reachability, not the number of paths.\n-   **Self-loops**: An edge $(u, u)$ will result in $u$ being in its own adjacency list, `adj[u]`.\n-   **Empty edge list**: If $E = \\emptyset$, then $V = \\emptyset$. The adjacency list will be empty, and the algorithm will correctly conclude there are no cycles.\n\n### Principle 2: Cycle Detection Using Depth-First Search\n\nA directed graph contains a cycle if and only if a Depth-First Search (DFS) traversal reveals a \"back edge\". A back edge is an edge from a vertex $u$ to an ancestor $v$ in the DFS tree. To identify back edges, we must track the state of each vertex during the traversal. Each vertex can be in one of three states:\n1.  **Unvisited (White)**: The vertex has not been visited yet.\n2.  **Visiting (Gray)**: The vertex is currently in the recursion stack of the DFS. This means we started exploring from this vertex, but have not yet finished exploring all of its descendants. These are the ancestors of the current node.\n3.  **Visited (Black)**: The vertex and all its descendants have been fully explored.\n\nA cycle is detected when, during the exploration of a vertex $u$, we encounter a neighbor $v$ that is currently in the \"Visiting\" state. This means we have found an edge from $u$ back to one of its ancestors $v$, completing a cycle.\n\nThe algorithm proceeds as follows:\n-   Initialize two sets: `visiting` (for gray vertices) and `visited` (for black vertices).\n-   Iterate through every vertex $u \\in V$.\n-   If $u$ has not been fully `visited` yet, start a DFS traversal from $u$.\n-   If the DFS traversal starting from any vertex returns that a cycle was found, the algorithm can terminate and report `True`.\n-   If the DFS has been run for all unvisited vertices and no cycle has been found, the graph is acyclic, and the result is `False`. This iterative approach ensures that all disconnected components of the graph are checked.\n\nThe recursive DFS function, say `dfs(u)`, works as follows:\n1.  Mark vertex $u$ as \"visiting\" by adding it to the `visiting` set.\n2.  For each neighbor $v$ of $u$:\n    a. If $v$ is in the `visiting` set, a back edge $(u, v)$ has been found. A cycle exists. Return `True`.\n    b. If $v$ is not in the `visited` set (to avoid re-exploring already completed subtrees), recursively call `dfs(v)`. If this recursive call returns `True`, it means a cycle was found downstream, so propagate `True` up the call stack.\n3.  Once all neighbors of $u$ have been processed, the exploration from $u$ is complete. Mark $u$ as \"visited\" by removing it from `visiting` and adding it to `visited`.\n4.  If the function has not returned `True` yet, it means no cycle was found in the subgraph reachable from $u$ (that hasn't been visited before). Return `False`.\n\nLet's illustrate with test case $2$: edges $[(1, 2), (2, 3), (3, 1)]$.\n-   $V = \\{1, 2, 3\\}$. Adjacency list: `adj = {1: [2], 2: [3], 3: [1]}`.\n-   Initialize `visiting = {}`, `visited = {}`.\n-   Start DFS from vertex $1$: call `dfs(1)`.\n    -   Add $1$ to `visiting`. `visiting = {1}`.\n    -   Neighbor of $1$ is $2$. $2$ is not visiting/visited. Call `dfs(2)`.\n        -   Add $2$ to `visiting`. `visiting = {1, 2}`.\n        -   Neighbor of $2$ is $3$. $3$ is not visiting/visited. Call `dfs(3)`.\n            -   Add $3$ to `visiting`. `visiting = {1, 2, 3}`.\n            -   Neighbor of $3$ is $1$. Check status of vertex $1$.\n            -   Vertex $1$ is in the `visiting` set. This is a back edge. Cycle detected.\n            -   `dfs(3)` returns `True`.\n        -   `dfs(2)` receives `True` from `dfs(3)` and returns `True`.\n    -   `dfs(1)` receives `True` from `dfs(2)` and returns `True`.\n-   The main loop receives `True` and concludes that the graph has a cycle. The result is `True`.\n\nThis algorithm is both correct and complete, satisfying all requirements of the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a suite of test cases.\n    \"\"\"\n\n    # Test suite of 7 test cases, each specified as a list of directed edges.\n    test_cases = [\n        # Test case 1: A directed acyclic graph (path).\n        [(1, 2), (2, 3), (3, 4)],\n        # Test case 2: A simple cycle.\n        [(1, 2), (2, 3), (3, 1)],\n        # Test case 3: A self-loop.\n        [(5, 5)],\n        # Test case 4: A disconnected graph with one component having a cycle.\n        [(10, 11), (11, 12), (12, 10), (20, 21)],\n        # Test case 5: An empty graph.\n        [],\n        # Test case 6: A DAG with duplicate edges.\n        [(0, 1), (0, 1), (1, 2), (0, 2)],\n        # Test case 7: A more complex graph with a cycle and a separate path.\n        [(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]\n    ]\n\n    def has_cycle(edges: list[tuple[int, int]]) - bool:\n        \"\"\"\n        Determines if a directed graph contains a cycle using Depth-First Search.\n\n        The graph is defined by a list of edges. The algorithm tracks vertex states\n        (unvisited, visiting, visited) to detect back edges, which indicate a cycle.\n\n        Args:\n            edges: A list of tuples, where each tuple (u, v) represents a\n                   directed edge from vertex u to vertex v.\n\n        Returns:\n            True if the graph contains at least one cycle, False otherwise.\n        \"\"\"\n        if not edges:\n            return False\n\n        # Build the vertex set and adjacency list from the edge list.\n        # The vertex set V is the set of all endpoints appearing in the edge list.\n        vertices = set()\n        adj = {}\n        for u, v in edges:\n            vertices.add(u)\n            vertices.add(v)\n        \n        for vertex in vertices:\n            adj[vertex] = []\n\n        for u, v in edges:\n            adj[u].append(v)\n\n        # `visiting` set tracks nodes in the current recursion stack (gray nodes).\n        # `visited` set tracks nodes that have been fully explored (black nodes).\n        visiting = set()\n        visited = set()\n\n        def _dfs(node):\n            \"\"\"Recursive DFS helper function to detect cycles.\"\"\"\n            visiting.add(node)\n\n            for neighbor in adj.get(node, []):\n                if neighbor in visiting:\n                    # A back edge is found, indicating a cycle.\n                    return True\n                if neighbor not in visited:\n                    if _dfs(neighbor):\n                        return True\n            \n            # All descendants from 'node' are explored.\n            visiting.remove(node)\n            visited.add(node)\n            return False\n\n        # Iterate through all vertices to handle disconnected components.\n        # sorted() is used for deterministic behavior, although not strictly necessary for correctness.\n        for vertex in sorted(list(vertices)):\n            if vertex not in visited:\n                if _dfs(vertex):\n                    return True\n        \n        return False\n\n    results = []\n    for case in test_cases:\n        result = has_cycle(case)\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```"
        },
        {
            "introduction": "Building on the general detection algorithm, this next problem adds a crucial constraint: finding a cycle that passes through a specific, designated vertex. This scenario is vital in applications like debugging deadlocks or analyzing feedback loops involving a particular component. Your task is to adapt the search strategy, focusing the power of DFS to not just find *any* cycle, but to trace a path that originates from and returns to a mandatory point, and to reconstruct that cycle if one is found. ",
            "id": "3225023",
            "problem": "You are given a finite directed graph represented by a finite set of vertices and a finite set of directed edges. A directed graph is a pair $(V,E)$ where $V$ is a finite set of vertices and $E \\subseteq V \\times V$ is a finite set of ordered pairs called directed edges. A directed path is a sequence of vertices $(u_0,u_1,\\dots,u_k)$ such that $(u_i,u_{i+1}) \\in E$ for all $i \\in \\{0,\\dots,k-1\\}$. A directed cycle is a directed path $(u_0,u_1,\\dots,u_k)$ with $k \\ge 1$ and $u_0 = u_k$ in which all intermediate vertices $u_0,u_1,\\dots,u_{k-1}$ are pairwise distinct.\n\nFor a given distinguished vertex $v \\in V$, design and implement an algorithmic procedure that either constructs one simple directed cycle that contains $v$, or correctly determines that no such directed cycle exists. Your implementation must follow these principles, starting from the fundamental definitions above:\n\n- Use only the core definitions and well-tested algorithmic primitives, namely Depth-First Search (DFS) and Breadth-First Search (BFS), without presupposing specialized theorems beyond the definitions of path and cycle.\n- Justify the search strategy by reducing the existence of a directed cycle through $v$ to a necessary and sufficient condition that is directly derived from the definition of a directed cycle.\n\nYour program must be fully self-contained and operate on a fixed test suite specified below. For each test case:\n\n- Input specification for the case is given by the finite vertex set $V = \\{0,1,\\dots,n-1\\}$ for some $n \\in \\mathbb{N}$, a finite edge set $E \\subseteq V \\times V$, and the distinguished vertex $v \\in V$.\n- Output for the case must be a list of integers representing the vertices of one simple directed cycle that contains $v$, written in order starting at $v$ and ending at $v$. If no such cycle exists, output the empty list. For example, if the cycle is $v \\to a \\to b \\to v$, output $[v,a,b,v]$. If the cycle is a self-loop, output $[v,v]$.\n- Determinism requirement to ensure a unique expected answer: when exploring edges, always consider outgoing neighbors in strictly increasing order of their vertex labels. If multiple cycles exist, output the first cycle found by the described deterministic search rule.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the same order as listed below. Each element itself must be a list of integers as described above. For example, a valid overall output may look like $[[0,1,0],[],[3,3]]$.\n\nTest suite covering general behavior and edge cases:\n\n- Test case $1$ (general case with a cycle through the distinguished vertex): $V = \\{0,1,2,3,4,5,6\\}$, $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5)\\}$, $v = 1$.\n- Test case $2$ (graph has a cycle elsewhere but none through the distinguished vertex): $V = \\{0,1,2,3,4,5\\}$, $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$, $v = 5$.\n- Test case $3$ (self-loop at the distinguished vertex): $V = \\{0,1,2,3,4\\}$, $E = \\{(0,1),(1,2),(3,3)\\}$, $v = 3$.\n- Test case $4$ (multiple cycles through the distinguished vertex; deterministic tie-breaking required): $V = \\{0,1,2,3\\}$, $E = \\{(0,1),(1,2),(2,0),(0,3),(3,0)\\}$, $v = 0$.\n- Test case $5$ (directed acyclic graph from the distinguished vertex): $V = \\{0,1,2,3\\}$, $E = \\{(0,1),(1,2),(2,3)\\}$, $v = 0$.\n\nThe final output format must be exactly one line, containing the list of results for the five test cases, with each result being a list of integers, all enclosed in square brackets and separated by commas, with no extraneous whitespace. No physical units or angles appear in this problem, so no unit conventions are required.",
            "solution": "The problem requires finding a simple directed cycle that passes through a specific, distinguished vertex $v$. If such a cycle exists, we must return the sequence of vertices forming the cycle; otherwise, we return an empty list.\n\n### Principle: Reducing the Problem\nThe existence of a simple directed cycle containing vertex $v$ is equivalent to the existence of a **simple path** that starts at $v$ and ends at some vertex $u$, for which there is a direct edge $(u, v)$. The cycle is then the concatenation of this simple path with the final edge back to $v$. A path is simple if it does not repeat any vertices.\n\nFor example, if $v \\to v_1 \\to v_2 \\to \\dots \\to u$ is a simple path and the edge $(u, v)$ exists, then $v \\to v_1 \\to v_2 \\to \\dots \\to u \\to v$ is a simple cycle. This rephrasing of the problem is ideal for a search algorithm that explores paths originating from $v$.\n\n### Algorithmic Strategy: Modified Depth-First Search\nWe can solve this problem by performing a Depth-First Search (DFS) starting from the distinguished vertex $v$. The search is modified to track the current path and look for an edge that leads back to the starting vertex $v$.\n\n1.  **Search Initiation**: The search starts only from the distinguished vertex $v$. There is no need to explore parts of the graph not reachable from $v$, as they cannot be part of a cycle involving $v$.\n\n2.  **Path Tracking**: During the DFS, we maintain the current path from $v$ to the node being visited. A list can store the path vertices in order, and a set can be used for efficient O(1) checking of whether a vertex is already on the current path.\n\n3.  **Search Logic**: The recursive DFS function, say `dfs(current_path)`, explores from the last node on the path. For each neighbor of this last node:\n    -   **Cycle Found**: If a neighbor is the distinguished vertex $v$, a cycle has been found. We append $v$ to the current path to complete the cycle sequence and return this list.\n    -   **Extend Path**: If a neighbor has not yet been visited in the current simple path, we extend the path by adding the neighbor and recurse. If the recursive call finds a cycle, we immediately propagate the result up the call stack.\n    -   **Avoid Internal Cycles**: If a neighbor is already on the current path but is *not* $v$, this represents a cycle that does not (yet) include the start and end point $v$. To ensure the path from $v$ remains simple, we do not traverse this edge.\n\n4.  **Determinism**: The problem requires that if multiple cycles exist, a specific one is chosen based on traversal order. This is achieved by building sorted adjacency lists for each vertex. When exploring neighbors, we always do so in increasing order of their labels. The first cycle found by this deterministic search is the result.\n\n5.  **No Cycle**: If the DFS completes its exploration of all paths starting from $v$ without finding an edge that leads back to $v$, it means no such cycle exists. In this case, we return an empty list.\n\nThis approach correctly and efficiently finds a simple cycle through $v$ if one exists, by directly searching for the structure defined in our problem reduction. It adheres to the constraint of using fundamental DFS principles and satisfies the deterministic output requirement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DirectedCycleFinder:\n    \"\"\"\n    Finds a simple directed cycle containing a distinguished vertex in a directed graph.\n    \"\"\"\n    def __init__(self, n, edges, start_node):\n        \"\"\"\n        Initializes the finder with the graph structure and the start node.\n\n        Args:\n            n (int): The number of vertices, labeled 0 to n-1.\n            edges (list of tuples): The set of directed edges (u, v).\n            start_node (int): The distinguished vertex v.\n        \"\"\"\n        self.n = n\n        self.start_node = start_node\n        self.adj = self._build_adjacency_list(edges)\n\n    def _build_adjacency_list(self, edges):\n        \"\"\"\n        Builds a sorted adjacency list from the edge set.\n        The sorting is critical for the deterministic search requirement.\n        \"\"\"\n        adj = {i: [] for i in range(self.n)}\n        for u, v_neighbor in edges:\n            adj[u].append(v_neighbor)\n        \n        for u in adj:\n            adj[u].sort()\n            \n        return adj\n\n    def find_cycle(self):\n        \"\"\"\n        Public method to initiate the cycle search.\n        \n        Returns:\n            list: A list of vertices forming the cycle, or an empty list if none is found.\n        \"\"\"\n        # The path starts with the distinguished vertex 'v'.\n        initial_path = [self.start_node]\n        # A set is used for efficient checking of vertices already in the current path.\n        path_set = {self.start_node}\n        \n        return self._dfs(initial_path, path_set)\n\n    def _dfs(self, path, path_set):\n        \"\"\"\n        A recursive Depth-First Search to find a simple path back to the start node.\n\n        Args:\n            path (list): The current path of vertices from the start node.\n            path_set (set): The set of vertices in the current path for O(1) lookups.\n\n        Returns:\n            list: The found cycle path, or an empty list to indicate no cycle was found.\n        \"\"\"\n        last_node = path[-1]\n        \n        # Explore neighbors in the pre-sorted order for determinism.\n        neighbors = self.adj.get(last_node, [])\n        for neighbor in neighbors:\n            # Case 1: Cycle found. An edge leads back to the start node.\n            if neighbor == self.start_node:\n                return path + [self.start_node]\n            \n            # Case 2: Extend path. The neighbor is not yet in the current simple path.\n            if neighbor not in path_set:\n                # Add the neighbor to the path and recurse.\n                path.append(neighbor)\n                path_set.add(neighbor)\n                \n                result = self._dfs(path, path_set)\n                \n                # If a cycle was found in the recursive call, propagate the result.\n                if result:\n                    return result\n                \n                # Backtrack: remove the neighbor to explore other branches.\n                path.pop()\n                path_set.remove(neighbor)\n        \n        # If the loop completes, no cycle was found from this path.\n        return []\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: general case with a cycle through the distinguished vertex\n        {\"n\": 7, \"edges\": [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5)], \"v\": 1},\n        # Test case 2: graph has a cycle elsewhere but none through the distinguished vertex\n        {\"n\": 6, \"edges\": [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)], \"v\": 5},\n        # Test case 3: self-loop at the distinguished vertex\n        {\"n\": 5, \"edges\": [(0, 1), (1, 2), (3, 3)], \"v\": 3},\n        # Test case 4: multiple cycles, deterministic tie-breaking required\n        {\"n\": 4, \"edges\": [(0, 1), (1, 2), (2, 0), (0, 3), (3, 0)], \"v\": 0},\n        # Test case 5: directed acyclic graph from the distinguished vertex\n        {\"n\": 4, \"edges\": [(0, 1), (1, 2), (2, 3)], \"v\": 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        finder = DirectedCycleFinder(case[\"n\"], case[\"edges\"], case[\"v\"])\n        result = finder.find_cycle()\n        results.append(result)\n\n    # Format the output string to be exactly as specified, with no extra spaces.\n    # str() on a list adds spaces, so we remove them.\n    # e.g., str([1, 2, 3]) - '[1, 2, 3]', we need '[1,2,3]'\n    results_str = ','.join([str(r).replace(' ', '') for r in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A true master of an algorithm understands not only how it works, but also how it can fail. This final exercise presents you with a slightly modified, and therefore faulty, version of the DFS coloring algorithm. By meticulously tracing its execution on a carefully chosen graph, you will uncover precisely why the standard 'white-gray-black' coloring scheme is so critical, and how seemingly minor changes can lead the algorithm to miss a cycle entirely. ",
            "id": "3224987",
            "problem": "You are given a directed graph $G=(V,E)$ with $V=\\{1,2,3,4\\}$ and $E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$. Adjacency lists are fixed as $\\mathrm{Adj}[1]=[2,4]$, $\\mathrm{Adj}[2]=[4,3]$, $\\mathrm{Adj}[3]=[1]$, $\\mathrm{Adj}[4]=[\\ ]$. A traversal always considers vertices in increasing numerical order and, within each adjacency list, edges are scanned from left to right.\n\nConsider the following faulty cycle-detection procedure, which aims to mimic Depth-First Search (DFS) with the standard white-gray-black coloring but modifies when a vertex becomes black. The procedure maintains a color $\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$ for each $u\\in V$, initialized to white. For each $u$ in increasing order, if $\\mathrm{color}[u]=\\text{white}$, it calls $\\mathrm{Explore}(u)$. The subroutine $\\mathrm{Explore}(u)$ does:\n- Set $\\mathrm{color}[u]\\leftarrow\\text{gray}$.\n- For each $(u,v)\\in E$ in the order given by $\\mathrm{Adj}[u]$:\n  - If $\\mathrm{color}[v]=\\text{white}$, call $\\mathrm{Explore}(v)$.\n  - If $\\mathrm{color}[v]=\\text{gray}$, the algorithm intends to detect a directed cycle (as in correct DFS), but see the next bullet.\n- Faulty blackening rule: While $u$ is gray, as soon as every outgoing neighbor $v$ of $u$ is non-white (that is, $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$), immediately set $\\mathrm{color}[u]\\leftarrow\\text{black}$, even if some such $v$ are still gray (their $\\mathrm{Explore}$ calls have not finished).\nThe algorithm reports “cycle detected” only when it scans an edge $(x,y)$ with $\\mathrm{color}[y]=\\text{gray}$ at that scan moment. Otherwise, if no such scan occurs, it reports “acyclic.”\n\nUse only fundamental definitions for your reasoning: a directed cycle is a sequence of vertices $u_1,u_2,\\dots,u_k$ with $k\\ge 2$ such that $(u_i,u_{i+1})\\in E$ for all $i\\in\\{1,\\dots,k-1\\}$ and $(u_k,u_1)\\in E$; correct DFS with recursion finishes a vertex $u$ (colors it black) only after all descendants reachable via tree edges from $u$ have finished; a back edge is an edge from a vertex to an ancestor on the current recursion stack (gray set), and its presence is equivalent to a directed cycle.\n\nQuestion: Running the faulty algorithm on $G$ with the specified orders, which option best explains the outcome and the precise reason for any failure?\n\nA. The algorithm incorrectly reports “acyclic” by prematurely blackening vertex $1$ once both $(1,2)$ and $(1,4)$ lead to non-white vertices (with $2$ gray and $4$ black) before $(3,1)$ is scanned; later, scanning $(3,1)$ targets a black vertex rather than gray, so the back edge $3\\to 1$ is not recognized and the directed cycle $1\\to 2\\to 3\\to 1$ is missed.\n\nB. The algorithm correctly reports “cyclic” because when scanning $(3,1)$ it encounters a gray neighbor, which is a back edge in DFS, so the cycle $1\\to 2\\to 3\\to 1$ is detected.\n\nC. The algorithm would fail only if the traversal started from vertex $4$ instead of vertex $1$; with the given order starting at $1$, it cannot prematurely blacken an ancestor and therefore still detects the cycle.\n\nD. The algorithm cannot miss cycles but can only raise false positives, because any edge to a previously visited vertex (gray or black) is treated as a back edge; thus it would report “cyclic” here due to $(2,4)$.",
            "solution": "To determine the algorithm's outcome, we must meticulously trace its execution on the given graph $G$. The key is the faulty blackening rule: a gray vertex $u$ is immediately colored black as soon as all its neighbors are non-white (gray or black). We will track the colors of vertices $\\{1,2,3,4\\}$ and the recursion stack. The initial state is all vertices white: $[W, W, W, W]$.\n\n1.  **Initial Call**: The main loop starts with vertex 1. Call `Explore(1)`.\n    -   `color[1]` becomes gray. State: `[G, W, W, W]`.\n\n2.  **Recurse to 2, then 4**: `Explore(1)` considers its first neighbor, 2. Since `color[2]` is white, `Explore(2)` is called.\n    -   `color[2]` becomes gray. State: `[G, G, W, W]`.\n    -   `Explore(2)` considers its first neighbor, 4. Since `color[4]` is white, `Explore(4)` is called.\n    -   `color[4]` becomes gray. State: `[G, G, W, G]`.\n\n3.  **Finish Vertex 4**: `Explore(4)` finds no outgoing edges. The condition for the faulty rule (all outgoing neighbors are non-white) is vacuously true.\n    -   `color[4]` becomes black. `Explore(4)` then finishes and returns. State after return: `[G, G, W, B]`.\n\n4.  **Premature Blackening of Vertex 1**: The change of `color[4]` to black is a critical event. The faulty rule, which states it applies \"as soon as\" the condition is met, implies we must check all currently gray vertices for this condition.\n    -   The gray vertices are 1 and 2.\n    -   For vertex 2 (gray), its neighbors are 4 and 3. `color[4]` is black, but `color[3]` is still white. The condition is not met.\n    -   For vertex 1 (gray), its neighbors are 2 and 4. At this moment, `color[2]` is gray and `color[4]` is black. Both are non-white. The condition is met.\n    -   Vertex 1 is immediately colored black due to the faulty rule. State becomes: `[B, G, W, B]`. This is the crucial error: vertex 1, an ancestor on the recursion stack, is blackened prematurely while its descendant, 2, is still being explored.\n\n5.  **Continue Exploration from 2**: The execution is still inside `Explore(2)`. It proceeds to its next neighbor, 3. Since `color[3]` is white, `Explore(3)` is called.\n    -   `color[3]` becomes gray. State: `[B, G, G, B]`.\n\n6.  **Explore from 3 and Miss the Cycle**: `Explore(3)` considers its only neighbor, 1. It scans the edge $(3,1)$.\n    -   It checks `color[1]`. At this moment, `color[1]` is black.\n    -   The algorithm only reports a cycle if the neighbor is gray. Since vertex 1 is black, the back edge $(3,1)$ is not recognized as such. No cycle is reported.\n    -   `Explore(3)` finishes its loop.\n\n7.  **Termination**: The rest of the exploration completes. All vertices eventually become black. No edge to a gray vertex was ever found. The algorithm incorrectly terminates and reports \"acyclic\".\n\nThis analysis directly supports option **A**. The algorithm's failure stems from the premature blackening of vertex 1. When the back edge $(3,1)$ that completes the cycle $1 \\to 2 \\to 3 \\to 1$ is finally examined, its target vertex 1 is already black, not gray, thus masking the cycle.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}