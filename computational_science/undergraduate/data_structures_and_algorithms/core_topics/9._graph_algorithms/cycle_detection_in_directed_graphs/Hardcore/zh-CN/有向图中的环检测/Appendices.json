{
    "hands_on_practices": [
        {
            "introduction": "我们将从一个基本但至重要的问题开始：如何判断一个有向图中是否存在环？这个练习将引导你实现一个基于深度优先搜索（DFS）的经典算法。通过追踪每个节点的访问状态（未访问、正在访问、已访问），你将学会如何识别“后向边”——即从一个节点指向其在搜索树中祖先的边——这是判断环路存在的关键标志。 这项实践不仅能让你掌握环路检测的核心技术，也为解决更复杂的图论问题奠定了坚实的基础。",
            "id": "3224952",
            "problem": "对于每个测试用例，您只得到一个有向边的列表，而没有明确的邻接表或邻接矩阵。有向图定义为 $G = (V, E)$，其中 $V$ 是一个有限的顶点集合，而 $E \\subseteq V \\times V$ 是一个表示有向边的有序对的有限集合。有向路径是一个有限的顶点序列 $v_0, v_1, \\dots, v_k$，使得对于所有满足 $0 \\le i  k$ 的索引 $i$，都有 $(v_i, v_{i+1}) \\in E$。有向环是一条长度至少为 $1$ 的有向路径，其起始顶点等于结束顶点，并且至少遍历了一条边；形式上，存在顶点 $v_0, v_1, \\dots, v_k$ 且 $k \\ge 1$，使得对于所有满足 $0 \\le i  k$ 的索引 $i$，都有 $(v_i, v_{i+1}) \\in E$ 并且 $v_0 = v_k$。如果一个有向图不包含任何有向环，则称其为无环图。一个经过充分验证的事实是：一个有向图是无环的，当且仅当其顶点存在拓扑排序。每个测试用例的顶点集是该测试用例边列表中出现的所有端点的集合；没有关联边的顶点不会给出，也无需推断，因为它们不可能是任何有向环的一部分。\n\n您的任务是编写一个完整的、可运行的程序，为每个测试用例，根据提供的边列表构建所需的任何内部表示，并判断该有向图是否包含至少一个有向环。每个测试用例的输出必须是一个布尔值：如果存在有向环，则为 $True$，否则为 $False$。程序不得假定除给定边列表之外的任何额外输入，并且必须能稳健地处理以下现实情况：重复边、自环、不连通分量和空边列表。\n\n使用以下包含 $7$ 个测试用例的测试套件，每个测试用例都指定为有序对 $(u, v)$ 的列表，表示从顶点 $u$到顶点 $v$ 的一条有向边：\n- 测试用例 1：边 $[(1, 2), (2, 3), (3, 4)]$。\n- 测试用例 2：边 $[(1, 2), (2, 3), (3, 1)]$。\n- 测试用例 3：边 $[(5, 5)]$。\n- 测试用例 4：边 $[(10, 11), (11, 12), (12, 10), (20, 21)]$。\n- 测试用例 5：边 $[]$。\n- 测试用例 6：边 $[(0, 1), (0, 1), (1, 2), (0, 2)]$。\n- 测试用例 7：边 $[(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含这 $7$ 个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序如上所述（例如，$[True,False,True,\\dots]$）。不允许任何其他输出。",
            "solution": "该问题要求判断一个由边列表指定的有向图是否包含至少一个环。解决方案必须能稳健地处理各种图结构，包括不连通分量、自环和重复边。解决这个问题的基本方法是在图上执行深度优先搜索（DFS），同时维护每个顶点的状态以检测反向边，反向边是存在环的标志。\n\n这个问题可以分解为两个主要部分：首先，从给定的边列表构建一个合适的图表示；其次，在该表示上实现一个环检测算法。\n\n### 原则1：从边列表构建图表示\n\n有向图被定义为一对 $G = (V, E)$，其中 $V$ 是顶点集，E 是有向边集。输入是一个边列表，例如 $[(u_1, v_1), (u_2, v_2), \\dots]$。据此，我们首先需要确定顶点集 $V$，然后构建边集 $E$ 的结构以便进行高效遍历。\n\n1.  **顶点集构建**：问题规定，顶点集 $V$ 由任何边中作为端点出现的所有唯一顶点组成。我们可以通过遍历边列表并将所有唯一的顶点标识符收集到一个集合中来获得 $V$。\n    对于像 $[(1, 2), (2, 3)]$ 这样的边列表，顶点集为 $V = \\{1, 2, 3\\}$。\n\n2.  **邻接表**：对于像 DFS 这样的图遍历算法，邻接表是一种常见且高效的表示方法。邻接表是每个顶点 $u \\in V$ 到一个顶点集合 $v$ 的映射，其中存在边 $(u, v) \\in E$。字典（或哈希表）是实现此目的的理想数据结构，其中键是顶点，值是其相邻邻居的列表。\n\n    构建邻接表的过程如下：\n    - 初始化一个空字典，例如 `adj`。\n    - 对于确定的顶点集 $V$ 中的每个顶点 $u$，初始化 `adj[u] = []`。\n    - 遍历输入列表中的每条边 $(u, v)$，并将 $v$ 追加到列表 `adj[u]` 中。\n\n这种构建方式自然地处理了指定的各种情况：\n-   **重复边**：如果一条边 $(u, v)$ 出现多次，$v$ 将被多次追加到 `adj[u]`。这是可以接受的；环检测逻辑仍然正确，因为它关心的是可达性，而不是路径的数量。\n-   **自环**：一条边 $(u, u)$ 会导致 $u$ 出现在其自身的邻接列表 `adj[u]` 中。\n-   **空边列表**：如果 $E = \\emptyset$，那么 $V = \\emptyset$。邻接表将为空，算法将正确地断定没有环。\n\n### 原则2：使用深度优先搜索进行环检测\n\n当且仅当深度优先搜索（DFS）遍历发现一条“反向边”时，有向图才包含环。反向边是指在 DFS 树中，从一个顶点 $u$ 指向其祖先 $v$ 的边。为了识别反向边，我们必须在遍历过程中跟踪每个顶点的状态。每个顶点可以处于以下三种状态之一：\n1.  **未访问 (白色)**：顶点尚未被访问过。\n2.  **正在访问 (灰色)**：顶点当前位于 DFS 的递归堆栈中。这意味着我们已经开始从该顶点进行探索，但尚未完成对其所有后代的探索。这些是当前节点的祖先。\n3.  **已访问 (黑色)**：顶点及其所有后代都已被完全探索。\n\n当在探索顶点 $u$ 的过程中，我们遇到了一个当前处于“正在访问”状态的邻居 $v$ 时，就检测到了环。这意味着我们找到了一条从 $u$ 回到其某个祖先 $v$ 的边，从而形成了一个环。\n\n算法流程如下：\n-   初始化两个集合：`visiting`（用于灰色顶点）和 `visited`（用于黑色顶点）。\n-   遍历 $V$ 中的每个顶点 $u$。\n-   如果 $u$ 尚未被完全 `visited`，则从 $u$ 开始进行 DFS 遍历。\n-   如果从任何顶点开始的 DFS 遍历返回找到了环，算法可以终止并报告 `True`。\n-   如果已对所有未访问的顶点运行了 DFS 且未发现环，则该图是无环的，结果为 `False`。这种迭代方法确保了图中所有的不连通分量都被检查到。\n\n递归的 DFS 函数，比如 `dfs(u)`，工作方式如下：\n1.  通过将顶点 $u$ 添加到 `visiting` 集合中，将其标记为“正在访问”。\n2.  对于 $u$ 的每个邻居 $v$：\n    a. 如果 $v$ 在 `visiting` 集合中，则找到了一条反向边 $(u, v)$。存在一个环。返回 `True`。\n    b. 如果 $v$ 不在 `visited` 集合中（以避免重新探索已经完成的子树），则递归调用 `dfs(v)`。如果此递归调用返回 `True`，则意味着在下游找到了一个环，因此将 `True` 沿调用栈向上传播。\n3.  一旦 $u$ 的所有邻居都处理完毕，从 $u$ 开始的探索就完成了。将 $u$ 从 `visiting` 中移除并添加到 `visited` 中，将其标记为“已访问”。\n4.  如果函数尚未返回 `True`，则意味着在从 $u$ 可达的（之前未访问过的）子图中没有找到环。返回 `False`。\n\n让我们用测试用例 2 来举例说明：边 $[(1, 2), (2, 3), (3, 1)]$。\n-   $V = \\{1, 2, 3\\}$。邻接表：`adj = {1: [2], 2: [3], 3: [1]}`。\n-   初始化 `visiting = {}`，`visited = {}`。\n-   从顶点 $1$ 开始 DFS：调用 `dfs(1)`。\n    -   将 $1$ 添加到 `visiting`。`visiting = {1}`。\n    -   $1$ 的邻居是 $2$。$2$ 不在 visiting/visited 中。调用 `dfs(2)`。\n        -   将 $2$ 添加到 `visiting`。`visiting = {1, 2}`。\n        -   $2$ 的邻居是 $3$。$3$ 不在 visiting/visited 中。调用 `dfs(3)`。\n            -   将 $3$ 添加到 `visiting`。`visiting = {1, 2, 3}`。\n            -   $3$ 的邻居是 $1$。检查顶点 $1$ 的状态。\n            -   顶点 $1$ 在 `visiting` 集合中。这是一条反向边。检测到环。\n            -   `dfs(3)` 返回 `True`。\n        -   `dfs(2)` 从 `dfs(3)` 接收到 `True` 并返回 `True`。\n    -   `dfs(1)` 从 `dfs(2)` 接收到 `True` 并返回 `True`。\n-   主循环接收到 `True` 并断定图中存在环。结果为 `True`。\n\n该算法既正确又完整，满足了问题的所有要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a suite of test cases.\n    \"\"\"\n\n    # Test suite of 7 test cases, each specified as a list of directed edges.\n    test_cases = [\n        # Test case 1: A directed acyclic graph (path).\n        [(1, 2), (2, 3), (3, 4)],\n        # Test case 2: A simple cycle.\n        [(1, 2), (2, 3), (3, 1)],\n        # Test case 3: A self-loop.\n        [(5, 5)],\n        # Test case 4: A disconnected graph with one component having a cycle.\n        [(10, 11), (11, 12), (12, 10), (20, 21)],\n        # Test case 5: An empty graph.\n        [],\n        # Test case 6: A DAG with duplicate edges.\n        [(0, 1), (0, 1), (1, 2), (0, 2)],\n        # Test case 7: A more complex graph with a cycle and a separate path.\n        [(100, 101), (101, 102), (102, 103), (103, 104), (104, 105), (105, 100), (106, 107)]\n    ]\n\n    def has_cycle(edges: list[tuple[int, int]]) -> bool:\n        \"\"\"\n        Determines if a directed graph contains a cycle using Depth-First Search.\n\n        The graph is defined by a list of edges. The algorithm tracks vertex states\n        (unvisited, visiting, visited) to detect back edges, which indicate a cycle.\n\n        Args:\n            edges: A list of tuples, where each tuple (u, v) represents a\n                   directed edge from vertex u to vertex v.\n\n        Returns:\n            True if the graph contains at least one cycle, False otherwise.\n        \"\"\"\n        if not edges:\n            return False\n\n        # Build the vertex set and adjacency list from the edge list.\n        # The vertex set V is the set of all endpoints appearing in the edge list.\n        vertices = set()\n        adj = {}\n        for u, v in edges:\n            vertices.add(u)\n            vertices.add(v)\n        \n        for vertex in vertices:\n            adj[vertex] = []\n\n        for u, v in edges:\n            adj[u].append(v)\n\n        # `visiting` set tracks nodes in the current recursion stack (gray nodes).\n        # `visited` set tracks nodes that have been fully explored (black nodes).\n        visiting = set()\n        visited = set()\n\n        def _dfs(node):\n            \"\"\"Recursive DFS helper function to detect cycles.\"\"\"\n            visiting.add(node)\n\n            for neighbor in adj.get(node, []):\n                if neighbor in visiting:\n                    # A back edge is found, indicating a cycle.\n                    return True\n                if neighbor not in visited:\n                    if _dfs(neighbor):\n                        return True\n            \n            # All descendants from 'node' are explored.\n            visiting.remove(node)\n            visited.add(node)\n            return False\n\n        # Iterate through all vertices to handle disconnected components.\n        # sorted() is used for deterministic behavior, although not strictly necessary for correctness.\n        for vertex in sorted(list(vertices)):\n            if vertex not in visited:\n                if _dfs(vertex):\n                    return True\n        \n        return False\n\n    results = []\n    for case in test_cases:\n        result = has_cycle(case)\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```"
        },
        {
            "introduction": "掌握了正确的算法之后，一个更深层次的问题是：为什么它必须是那样设计的？这个练习通过分析一个有缺陷的环路检测程序，让你深入理解标准DFS算法中节点着色规则的精妙之处。 你将追踪一个过早地将节点标记为“已完成”（涂黑）的错误算法，并揭示为何这种“抢跑”行为会导致它错过图中存在的环路。这个过程将极大地加深你对DFS状态管理重要性的理解。",
            "id": "3224987",
            "problem": "给定一个有向图 $G=(V,E)$，其中 $V=\\{1,2,3,4\\}$ 且 $E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$。邻接表固定为 $\\mathrm{Adj}[1]=[2,4]$，$\\mathrm{Adj}[2]=[4,3]$，$\\mathrm{Adj}[3]=[1]$，$\\mathrm{Adj}[4]=[\\ ]$。遍历总是按顶点数值递增的顺序进行，并且在每个邻接表内，边按从左到右的顺序扫描。\n\n考虑以下有缺陷的环检测过程，该过程旨在模仿带有标准白-灰-黑着色方案的深度优先搜索 (DFS)，但修改了顶点变黑的时机。该过程为每个顶点 $u\\in V$ 维护一个颜色 $\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$，初始化为白色。对于按递增顺序排列的每个 $u$，如果 $\\mathrm{color}[u]=\\text{white}$，则调用 $\\mathrm{Explore}(u)$。子程序 $\\mathrm{Explore}(u)$ 执行以下操作：\n- 设置 $\\mathrm{color}[u]\\leftarrow\\text{gray}$。\n- 对于 $\\mathrm{Adj}[u]$ 给定顺序中的每条边 $(u,v)\\in E$：\n  - 如果 $\\mathrm{color}[v]=\\text{white}$，则调用 $\\mathrm{Explore}(v)$。\n  - 如果 $\\mathrm{color}[v]=\\text{gray}$，算法意图检测到一个有向环（如在正确的 DFS 中），但请参阅下一条规则。\n- 错误的染黑规则：当 $u$ 为灰色时，一旦其所有出边邻居 $v$ 都变为非白色（即 $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$），立即将 $\\mathrm{color}[u]\\leftarrow\\text{black}$，即使某些这样的 $v$ 仍为灰色（它们的 $\\mathrm{Explore}$ 调用尚未结束）。\n算法仅在扫描到一条边 $(x,y)$ 且在该扫描时刻 $\\mathrm{color}[y]=\\text{gray}$ 时，报告“检测到环”。否则，如果没有发生此类扫描，则报告“无环”。\n\n在你的推理中仅使用基本定义：有向环是一个顶点序列 $u_1,u_2,\\dots,u_k$（其中 $k\\ge 2$），使得对于所有 $i\\in\\{1,\\dots,k-1\\}$ 都有 $(u_i,u_{i+1})\\in E$ 并且 $(u_k,u_1)\\in E$；正确的带递归的 DFS 仅在所有从 $u$ 出发通过树边可达的后代都已完成（染成黑色）后，才完成对顶点 $u$ 的处理（将其染成黑色）；返祖边是一条从一个顶点指向其在当前递归栈上（灰色集合中）的祖先的边，其存在等价于存在有向环。\n\n问题：在指定的顺序下，对图 $G$ 运行这个有缺陷的算法，哪个选项最能解释其结果以及任何失败的精确原因？\n\nA. 算法错误地报告“无环”，因为它在扫描 $(3,1)$ 之前，一旦边 $(1,2)$ 和 $(1,4)$ 都指向非白色顶点（其中 2 为灰色，4 为黑色）时，就过早地将顶点 1 染成黑色；之后，扫描 $(3,1)$ 时目标顶点是黑色而不是灰色，因此返祖边 $3\\to 1$ 未被识别，导致有向环 $1\\to 2\\to 3\\to 1$ 被错过。\n\nB. 算法正确地报告“有环”，因为在扫描 $(3,1)$ 时，它遇到了一个灰色邻居，这在 DFS 中是一条返祖边，因此环 $1\\to 2\\to 3\\to 1$ 被检测到。\n\nC. 算法仅当遍历从顶点 4 而不是顶点 1 开始时才会失败；在给定从 1 开始的顺序下，它不会过早地将一个祖先染成黑色，因此仍然能检测到环。\n\nD. 算法不会错过环，但只会产生假阳性，因为任何指向先前访问过的顶点（灰色或黑色）的边都被视为返祖边；因此，它会因为边 $(2,4)$ 而报告“有环”。",
            "solution": "用户要求对问题陈述进行严格验证，然后详细推导解决方案并评估所有提供的选项。\n\n### 第 1 步：提取给定信息\n\n-   **图**：一个有向图 $G=(V,E)$。\n-   **顶点**：$V=\\{1,2,3,4\\}$。\n-   **边**：$E=\\{(1,2),(1,4),(2,4),(2,3),(3,1)\\}$。\n-   **邻接表**：$\\mathrm{Adj}[1]=[2,4]$，$\\mathrm{Adj}[2]=[4,3]$，$\\mathrm{Adj}[3]=[1]$，$\\mathrm{Adj}[4]=[\\ ]$。\n-   **遍历顺序**：主循环按顶点数值递增的顺序（1, 2, 3, 4）迭代。邻接表按指定的从左到右的顺序扫描。\n-   **算法状态**：每个顶点 $u$ 有一个颜色 $\\mathrm{color}[u]\\in\\{\\text{white},\\text{gray},\\text{black}\\}$，初始化为白色。\n-   **算法主循环**：对于每个 $u \\in \\{1,2,3,4\\}$，如果 $\\mathrm{color}[u]=\\text{white}$，则调用 $\\mathrm{Explore}(u)$。\n-   **子程序 `Explore(u)`**：\n    1.  设置 $\\mathrm{color}[u]\\leftarrow\\text{gray}$。\n    2.  对于 $u$ 的每个邻居 $v$（按 $\\mathrm{Adj}[u]$ 顺序）：\n        -   如果 $\\mathrm{color}[v]=\\text{white}$，则调用 $\\mathrm{Explore}(v)$。\n        -   如果 $\\mathrm{color}[v]=\\text{gray}$，则检测到环（有条件地，见下文）。\n-   **错误的染黑规则**：一个当前为灰色的顶点 $u$，一旦其所有出边邻居 $v$ 都变为非白色（即 $\\mathrm{color}[v]\\in\\{\\text{gray},\\text{black}\\}$），就立即被染成黑色。这可能在对 $u$ 或其后代的 `Explore` 调用过程中发生。\n-   **环报告机制**：算法当且仅当扫描到一条边 $(x,y)$ 且此时 $\\mathrm{color}[y]=\\text{gray}$ 时，报告“检测到环”。否则，报告“无环”。\n\n### 第 2 步：使用提取的信息进行验证\n\n-   **科学性**：该问题属于计算机科学领域，特别是图算法。所有概念，如有向图、深度优先搜索 (DFS)、顶点着色和环检测，都是标准的且定义明确。这个“有缺陷的”过程是对标准算法的修改，这是测试对基本原理深刻理解的常见且有效的方法。该问题在数学和逻辑上是健全的。\n-   **良构性**：图的结构、遍历顺序和算法规则（包括错误的规则）都得到了精确无歧义的规定。这确保了算法的执行是确定性的，会产生唯一的结果。该问题是良构的。\n-   **客观性**：问题以精确、客观的语言陈述，没有任何主观性或歧义。\n\n问题陈述在科学或事实上没有不健全之处，是可形式化的、完整的、计算上可行的、良构的，并且由于错误规则的微妙性而并非微不足道。\n\n### 第 3 步：结论与行动\n\n该问题是**有效的**。可以进行详细分析。\n\n### 解法推导\n\n我们将跟踪指定有缺陷算法在图 $G$ 上的执行过程。颜色缩写为 $W$ (white)、$G$ (gray) 和 $B$ (black)。初始状态为顶点的 $\\mathrm{color} = [W, W, W, W]$，对应顶点 $[1, 2, 3, 4]$。递归栈由 `Explore` 调用的序列表示。\n\n1.  **主循环**：从 $u=1$ 开始。$\\mathrm{color}[1]$ 是 $W$。调用 $\\mathrm{Explore}(1)$。\n    -   **`Explore(1)`**：设置 $\\mathrm{color}[1] \\leftarrow G$。\n        -   状态：$[G, W, W, W]$。栈：`[Explore(1)]`。\n    -   检查 1 的邻居：$\\mathrm{Adj}[1]=[2,4]$。第一个是 $v=2$。\n    -   $\\mathrm{color}[2]$ 是 $W$。调用 $\\mathrm{Explore}(2)$。\n        -   **`Explore(2)`**：设置 $\\mathrm{color}[2] \\leftarrow G$。\n            -   状态：$[G, G, W, W]$。栈：`[Explore(1), Explore(2)]`。\n        -   检查 2 的邻居：$\\mathrm{Adj}[2]=[4,3]$。第一个是 $w=4$。\n        -   $\\mathrm{color}[4]$ 是 $W$。调用 `Explore(4)`。\n            -   **`Explore(4)`**：设置 $\\mathrm{color}[4] \\leftarrow G$。\n                -   状态：$[G, G, W, G]$。栈：`[Explore(1), Explore(2), Explore(4)]`。\n            -   检查 4 的邻居：$\\mathrm{Adj}[4]=[\\ ]$。循环为空。\n            -   **对顶点 4 进行错误规则检查**：将灰色顶点 $u$ 染黑的条件是其所有出边邻居都为非白色。对于顶点 4，其邻居集合为空，因此该条件空真 (vacuously true)。\n            -   立即设置 $\\mathrm{color}[4] \\leftarrow B$。\n                -   状态：$[G, G, W, B]$。\n            -   **错误规则全局检查**：$\\mathrm{color}[4]$ 从 $W$ 变为 $B$（经由 $G$）是一个可能触发其他灰色顶点变黑的事件。短语“一旦…立即”意味着此检查不会延迟。我们必须检查所有当前为灰色的顶点：1 和 2。\n                -   检查顶点 2（灰色）：邻居是 4, 3。$\\mathrm{color}[4]=B$，但 $\\mathrm{color}[3]=W$。条件不满足。\n                -   检查顶点 1（灰色）：邻居是 2, 4。$\\mathrm{color}[2]=G$（非白色）且 $\\mathrm{color}[4]=B$（非白色）。1 的所有邻居现在都是非白色。条件满足。\n                -   立即设置 $\\mathrm{color}[1] \\leftarrow B$。\n                    -   状态：$[B, G, W, B]$。\n            -   `Explore(4)` 调用结束并返回。\n\n        -   回到 `Explore(2)`。当前状态为 $[B, G, W, B]$。调用栈为 `[Explore(1), Explore(2)]`。注意，在我们处于更深层递归时，$\\mathrm{color}[1]$ 变成了黑色。\n        -   继续检查 2 的邻居。下一个是 $w=3$。\n        -   $\\mathrm{color}[3]$ 是 $W$。调用 `Explore(3)`。\n            -   **`Explore(3)`**：设置 $\\mathrm{color}[3] \\leftarrow G$。\n                -   状态：$[B, G, G, B]$。栈：`[Explore(1), Explore(2), Explore(3)]`。\n            -   **错误规则全局检查**：$\\mathrm{color}[3] \\leftarrow G$ 的变化是另一个触发事件。我们检查所有灰色顶点：2 和 3。\n                -   检查顶点 2（灰色）：邻居是 4, 3。$\\mathrm{color}[4]=B$ 且 $\\mathrm{color}[3]=G$。两者都为非白色。条件满足。立即设置 $\\mathrm{color}[2] \\leftarrow B$。\n                    -   状态：$[B, B, G, B]$。\n                -   检查顶点 3（灰色）：邻居是 1。$\\mathrm{color}[1]=B$（非白色）。条件满足。立即设置 $\\mathrm{color}[3] \\leftarrow B$。\n                    -   状态：$[B, B, B, B]$。\n            -   现在，`Explore(3)` 继续执行。状态是 $[B, B, B, B]$。\n            -   检查 3 的邻居：$\\mathrm{Adj}[3]=[1]$。\n            -   扫描边 $(3,1)$。检查 $\\mathrm{color}[1]$。它是 $B$。\n            -   报告环的条件是 $\\mathrm{color}[\\text{邻居}] = G$。由于 $\\mathrm{color}[1]$ 是 $B$，这里不会报告环。\n            -   `Explore(3)` 循环结束。该顶点已经是黑色。它返回。\n\n        -   回到 `Explore(2)`。对其邻居的循环已结束。该顶点已经是黑色。它返回。\n    -   回到 `Explore(1)`。循环继续到它的下一个邻居，$v=4$。\n    -   $\\mathrm{color}[4]$ 是 $B$。不执行任何操作。\n    -   `Adj[1]` 的循环结束。该顶点已经是黑色。`Explore(1)` 返回。\n\n2.  **主循环**：继续。$u=2$，$\\mathrm{color}[2]$ 是 $B$。跳过。$u=3$，$\\mathrm{color}[3]$ 是 $B$。跳过。$u=4$，$\\mathrm{color}[4]$ 是 $B$。跳过。\n3.  **终止**：算法终止。在 $\\mathrm{color}[y]$ 为灰色时，从未扫描过任何边 $(x,y)$。算法报告“无环”。\n\n该算法错误地未能检测到环 $1 \\to 2 \\to 3 \\to 1$。失败的原因是，顶点 1，作为 `Explore(3)` 递归栈上的一个祖先，被过早地染成了黑色。当检查边 $(3,1)$（在正确的 DFS 中是返祖边）时，顶点 1 被看作是黑色而不是灰色，从而掩盖了环的存在。\n\n### 逐项分析选项\n\n**A. 算法错误地报告“无环”，因为它在扫描 $(3,1)$ 之前，一旦边 $(1,2)$ 和 $(1,4)$ 都指向非白色顶点（其中 2 为灰色，4 为黑色）时，就过早地将顶点 1 染成黑色；之后，扫描 $(3,1)$ 时目标顶点是黑色而不是灰色，因此返祖边 $3\\to 1$ 未被识别，导致有向环 $1\\to 2\\to 3\\to 1$ 被错过。**\n-   执行跟踪显示算法报告“无环”，这是不正确的。\n-   执行跟踪显示顶点 1 被过早染黑。\n-   触发这次染黑的原因是它的邻居 2 和 4 变为非白色。触发此事件的具体状态是 `Explore(4)` 结束（使 $\\mathrm{color}[4]=B$）而 `Explore(2)` 仍在运行（因此 $\\mathrm{color}[2]=G$）。这完全符合括号中的描述“（其中 2 为灰色，4 为黑色）”。\n-   顶点 1 的这次染黑发生在 `Explore(3)` 被调用之前，因此远早于边 $(3,1)$ 被扫描。\n-   当最终扫描 $(3,1)$ 时，$\\mathrm{color}[1]$ 确实是黑色，导致环被错过。\n-   这个选项提供了对算法执行及其失败模式的完整而准确的描述。\n-   **结论：正确。**\n\n**B. 算法正确地报告“有环”，因为在扫描 $(3,1)$ 时，它遇到了一个灰色邻居，这在 DFS 中是一条返祖边，因此环 $1\\to 2\\to 3\\to 1$ 被检测到。**\n-   这描述了正确的 DFS 算法的行为。然而，错误的染黑规则改变了执行过程。如执行跟踪所示，当处理边 $(3,1)$ 时，顶点 1 是黑色而不是灰色。因此，算法不会报告有环。\n-   **结论：不正确。**\n\n**C. 算法仅当遍历从顶点 4 而不是顶点 1 开始时才会失败；在给定从 1 开始的顺序下，它不会过早地将一个祖先染成黑色，因此仍然能检测到环。**\n-   第一个分句是错误的；执行跟踪显示从顶点 1 开始算法就会失败。\n-   第二个分句也是错误的；执行跟踪明确显示，作为 DFS 树中祖先的顶点 1 被过早染黑。\n-   因此结论是错误的；环被错过了。\n-   **结论：不正确。**\n\n**D. 算法不会错过环，但只会产生假阳性，因为任何指向先前访问过的顶点（灰色或黑色）的边都被视为返祖边；因此，它会因为边 $(2,4)$ 而报告“有环”。**\n-   前提“算法不会错过环”是错误的，如执行跟踪所示。过早染黑是导致假阴性（错过环）的机制。\n-   给出的理由也是错误的：“任何指向先前访问过的顶点（灰色或黑色）的边都被视为返祖边”。问题明确指出，*仅*在遇到指向灰色顶点的边时才报告环。指向黑色顶点的边被忽略。\n-   给出的例子是错误的：“它会因为 (2,4) 而报告‘有环’”。当处理边 $(2,4)$ 时，$\\mathrm{color}[4]$ 是白色。这会导致递归调用，而不是环检测。边 $(2,4)$ 是一条树边。\n-   **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现在，让我们从判断环路是否存在，转向一个优化问题：如何找到图中长度最短的环？这个问题需要我们转换思路，使用广度优先搜索（BFS）来解决，因为它天然适合在无权图中寻找最短路径。这项练习展示了不同的图问题通常需要不同的算法工具。 你将学习如何巧妙地应用BFS，将每个节点视为潜在的环路起点，并寻找回到该节点的最短路径，从而找到全局最短环。此外，你还将接触到剪枝优化，这是一种在算法设计中提高效率的重要思想。",
            "id": "3225009",
            "problem": "给定一个有限有向图，其包含有限的顶点集和有向边集，边上没有权重。一个有向环是一系列顶点 $\\left(v_0,v_1,\\dots,v_{k-1}\\right)$，满足 $k \\ge 1$，除了 $v_0$ 可能等于 $v_{k-1}$ 之外，每个 $v_i$ 都是不同的，并且对于所有的 $i \\in \\{0,1,\\dots,k-1\\}$，都存在一条从 $v_i$ 到 $v_{(i+1) \\bmod k}$ 的有向边。有向环的长度是环中边的数量，根据此定义，长度等于 $k$。设计并实现一个算法，对于每个测试图，计算其最短有向环的长度（以边数计），其中图是无权的。如果图中不包含有向环，则其最短有向环的长度定义为 $0$。从每个顶点开始使用广度优先搜索（BFS），并结合基于下界的有原则的剪枝策略，以便不完全探索那些无法改进当前已知最优环长的搜索。你还必须证明你的方法的正确性，并分析其最坏情况下的运行时间。\n\n从数据结构和算法的核心定义与性质出发，具体包括：有向图 $G = (V, E)$ 的定义（其中 $|V| = n$ 且 $|E| = m$）、可达性的概念、在无权图上 BFS 按边数计算的最短路径长度的非递减顺序探索顶点的性质，以及有向图的强连通分量（SCC）的概念。不要假设或使用任何预先给定的最短环公式；从这些基本定义中推导出任何必要的关系。\n\n你的程序必须实现该算法，并为以下测试图集生成结果。每个图由顶点数 $n$（顶点标记为 $\\{0,1,\\dots,n-1\\}$）和有向边列表指定，其中有序对 $\\left(u,v\\right)$ 表示一条从 $u$ 到 $v$ 的有向边。\n\n- 测试用例 1：$n = 5$，边集 $\\left[(0,1),(1,2),(2,3),(3,4)\\right]$。\n- 测试用例 2：$n = 3$，边集 $\\left[(0,0),(0,1),(1,2)\\right]$。\n- 测试用例 3：$n = 4$，边集 $\\left[(0,1),(1,0),(2,3)\\right]$。\n- 测试用例 4：$n = 6$，边集 $\\left[(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(5,0)\\right]$。\n- 测试用例 5：$n = 7$，边集 $\\left[(0,1),(1,2),(2,3),(3,0),(4,5),(5,6)\\right]$。\n- 测试用例 6：$n = 1$，边集 $\\left[\\right]$。\n\n科学真实性要求：仅在适用于无权边的情况下应用 BFS。使用源于定义和既有性质的下界，例如：入度为 $0$ 的顶点不可能位于有向环上；大小为 $1$ 且没有自环的 SCC 中的顶点不可能位于任何有向环上；以及当已知全局最优环长 $L^\\star$ 时，任何产生距离 $d$（其中 $d+1 \\ge L^\\star$）的 BFS 层都不可能产生更短的环，因此可以被剪枝。确保你的程序忠实地反映这些约束。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个条目是一个整数，等于相应测试图的最短有向环长度，用 $0$ 表示没有环。此问题不涉及物理单位、角度单位或百分比，所有答案均为整数。",
            "solution": "该问题要求设计一个算法，以找到给定无权有向图中最短有向环的长度。如果图是无环的，则应报告长度为 $0$。该算法必须基于从每个顶点执行广度优先搜索（BFS），并带有特定的剪枝优化。\n\n有向图被正式表示为一对 $G=(V, E)$，其中 $V$ 是顶点的有限集，E 是称为有向边的顶点有序对的集合。令 $n = |V|$ 为顶点数，$m = |E|$ 为边数。顶点标记为 $\\{0, 1, \\dots, n-1\\}$。\n\n一个简单有向环被定义为一个由 $k \\ge 1$ 个不同顶点组成的序列 $(v_0, v_1, \\dots, v_{k-1})$，使得对于所有 $i \\in \\{0, 1, \\dots, k-1\\}$，都存在一条从 $v_i$ 到 $v_{(i+1) \\bmod k}$ 的有向边。此环的长度为 $k$，即它包含的边数。对于 $k=1$，环 $(v_0)$ 意味着存在一条自环边 $(v_0, v_0)$。目标是找到图中所有环中最小的 $k$ 值。\n\n所提出算法的核心原理依赖于 BFS 的性质和环的结构。从源顶点 $s \\in V$ 开始的 BFS 会逐层探索图，保证它能找到从 $s$ 到任何可达顶点的最短路径（以边数计）。一个包含顶点 $s$ 的环可以看作是一条从 $s$ 到某个顶点 $u$ 的路径，后随一条“后向边” $(u, s)$。这样一个环的长度是从 $s$到 $u$ 的路径长度加一。通过为每个可能的顶点 $s$ 系统地搜索最短的此类结构，我们可以找到全局最短的环。\n\n该算法按以下步骤进行：\n1. 初始化一个变量 $L^*$ 来存储上述最短环的长度。一个安全的初始值是 $n+1$，因为在有 $n$ 个顶点的图中，任何简单环的长度都不可能大于 $n$。\n2. 遍历每个顶点 $s \\in V$，将每个顶点都视为最短环中的一个潜在顶点和 BFS 遍历的根节点。\n3. 对每个 $s$ 执行 BFS：\n    a. 初始化一个大小为 $n$ 的距离数组 $d$，其中 $d(s) = 0$，对于所有其他顶点 $v \\in V \\setminus \\{s\\}$，$d(v) = \\infty$。\n    b. 为 BFS 初始化一个队列 $Q$，并将 $s$ 入队。\n    c. 当 $Q$ 不为空时，从队列中取出一个顶点 $u$。\n    d. **剪枝**：在从 $u$ 开始探索之前，检查是否有 $d(u) + 1 \\ge L^*$。量 $d(u)+1$ 代表了通过从 $s$到 $u$ 的路径和一条后向边可能形成的任何环的最小长度。如果这个可能的最小长度不严格小于当前已知的最优环长 $L^*$，那么从 $u$ 扩展搜索就不可能找到更短的环。因此，我们可以剪掉这个搜索分支，并继续处理队列中的下一个顶点。\n    e. 探索 $u$ 的邻居：对于每个顶点 $v$ 使得 $(u, v) \\in E$：\n        i. 如果 $v = s$，则找到了一个环。该环由从 $s$ 到 $u$ 的最短路径（长度为 $d(u)$）和边 $(u, s)$ 组成。其长度为 $d(u) + 1$。更新 $L^* = \\min(L^*, d(u) + 1)$。\n        ii. 如果在当前 BFS 中尚未访问过 $v$（即 $d(v) = \\infty$），则更新其距离 $d(v) = d(u) + 1$ 并将 $v$ 入队。\n4. 遍历所有可能的起始顶点 $s \\in V$ 后，如果 $L^*$ 仍为 $n+1$，则表示没有找到环。在这种情况下，结果为 $0$。否则，结果为 $L^*$ 的最终值。\n\n**正确性证明**\n设 $C = (v_0, v_1, \\dots, v_{k-1}, v_0)$ 是图 $G$ 中的一个最短环，其长度为 $k$。算法最终会选择它的一个顶点，比如 $s=v_0$，作为 BFS 遍历的起始顶点。子序列 $(v_0, v_1, \\dots, v_{k-1})$ 构成了一条从 $v_0$ 到 $v_{k-1}$ 的长度为 $k-1$ 的简单路径。这条路径必须是从 $v_0$ 到 $v_{k-1}$ 的最短路径。如果存在更短的路径，那将意味着图中存在一个更短的环，这与 $C$ 是最短环的假设相矛盾。\n由于 BFS 算法能找到从其源点到所有其他顶点的最短路径，从 $v_0$ 开始的 BFS 将确定到 $v_{k-1}$ 的距离为 $d(v_0, v_{k-1}) = k-1$。当 BFS 处理完最短路径上 $v_{k-1}$ 的前驱节点，并探索 $v_{k-1}$ 的邻居时，它会发现边 $(v_{k-1}, v_0)$。由于 $v_0$ 是起始顶点 $s$，算法会正确识别出一个长度为 $d(v_0, v_{k-1}) + 1 = (k-1) + 1 = k$ 的环。这确保了 $L^*$ 将被更新为至多 $k$。因为该算法考虑了所有可能性，而 $k$ 是可能的最小环长，所以最终结果将恰好是 $k$。剪枝步骤保留了正确性，因为它只舍弃那些不可能导致比已发现的环更短的环的搜索路径。\n\n**最坏情况运行时间分析**\n该算法包含一个主循环，对 $V$ 中的每个顶点迭代一次，共迭代 $n$ 次。在此循环内部，会执行一次 BFS。在用邻接表表示的图上，一次标准的 BFS 需要 $O(n+m)$ 的时间。因此，该算法的总最坏情况时间复杂度为 $n \\times O(n+m) = O(n(n+m))$。最坏情况下的性能出现在无环图或具有非常长环的图上，在这些情况下，剪枝优化提供的益处微乎其微。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve_graph(n, edges):\n    \"\"\"\n    Computes the length of the shortest directed cycle in a graph.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        edges (list of tuple): A list of directed edges (u, v).\n\n    Returns:\n        int: The length of the shortest directed cycle, or 0 if no cycle exists.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        if u  n and v  n:  # Basic validation\n            adj[u].append(v)\n\n    # Initialize shortest cycle length. A simple cycle length is at most n.\n    # We use n + 1 as an indicator for \"infinity\" or \"not found\".\n    min_cycle_len = n + 1\n\n    # Iterate through each vertex, treating it as a potential start of a cycle\n    for s in range(n):\n        # Start a Breadth-First Search (BFS) from vertex s.\n        # We use a numpy array for distances; -1 represents an unvisited vertex.\n        dist = np.full(n, -1, dtype=int)\n        \n        # Queue for BFS. collections.deque is efficient for this purpose.\n        q = deque()\n\n        # Initialize BFS from s\n        dist[s] = 0\n        q.append(s)\n\n        while q:\n            u = q.popleft()\n\n            # Pruning step: if the path to u is already long enough that any\n            # cycle through it cannot be shorter than the current best, we prune.\n            # a cycle found from here would have length at least dist[u] + 1.\n            if dist[u] + 1 >= min_cycle_len:\n                continue\n\n            for v in adj[u]:\n                if v == s:\n                    # Found a cycle back to the starting vertex s.\n                    # Cycle length = path length to u + edge (u, s).\n                    cycle_len = dist[u] + 1\n                    min_cycle_len = min(min_cycle_len, cycle_len)\n                elif dist[v] == -1:\n                    # First time visiting vertex v in this BFS. Record distance and enqueue.\n                    dist[v] = dist[u] + 1\n                    q.append(v)\n                # If dist[v] != -1 and v != s, we have found another path to v.\n                # Since BFS explores layer by layer, this new path cannot be shorter,\n                # so we ignore it.\n\n    # If min_cycle_len was not updated from its initial value, no cycles were found.\n    # As per the problem statement, return 0 in this case.\n    if min_cycle_len == n + 1:\n        return 0\n    else:\n        return min_cycle_len\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Acyclic graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # Test case 2: Self-loop (cycle of length 1)\n        (3, [(0, 0), (0, 1), (1, 2)]),\n        # Test case 3: Simple cycle of length 2\n        (4, [(0, 1), (1, 0), (2, 3)]),\n        # Test case 4: Two disjoint cycles of length 3, plus connecting edges\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3), (2, 3), (5, 0)]),\n        # Test case 5: One cycle of length 4 and a separate path\n        (7, [(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6)]),\n        # Test case 6: A single vertex with no edges\n        (1, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_graph(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}