{
    "hands_on_practices": [
        {
            "introduction": "The best way to truly grasp an algorithm is to implement it from first principles. This practice  guides you through constructing the classic Divide and Conquer solution for the maximum subarray problem. By starting with a simple character-to-integer mapping and incorporating strict tie-breaking rules, this exercise will test your attention to detail and solidify your understanding of the fundamental recursive structure.",
            "id": "3250522",
            "problem": "You are given a finite string over the lowercase English alphabet. Map each character to an integer weight via the correspondence $a \\mapsto 1, b \\mapsto 2, \\ldots, z \\mapsto 26$. Consider the array $A$ of integer weights constructed from the given string in order. A contiguous substring corresponds to a contiguous subarray of $A$. Define the sum of a contiguous subarray $A[i..j]$ to be $S(i,j) = \\sum_{t=i}^{j} A[t]$. The task is to compute, using a Divide and Conquer (D&C) paradigm, the maximum subarray sum and the corresponding substring’s indices with the following tie-breaking policy: if multiple substrings achieve the same maximum sum, choose the one with the smallest starting index $i$, and if there is still a tie, choose the one with the smallest ending index $j$. Indices must be reported using $0$-based indexing. If the string is empty, define the maximum sum to be $0$ and the indices to be $-1$ and $-1$.\n\nStart from fundamental definitions: a contiguous subarray, an arithmetic summation, and the D&C principle that reduces a problem on size $n$ to subproblems on sizes less than $n$ plus a linear-time combination step. Do not use shortcut formulas. Design the algorithm by reasoning that a maximum subarray on $A[i..j]$ must be either entirely in the left half, entirely in the right half, or cross the midpoint. Derive how to compute the crossing case by constructing the maximum suffix of the left half and the maximum prefix of the right half and combining them.\n\nYour program must implement this D&C approach to return, for each test case, a triple $[S,i,j]$ where $S$ is the maximum sum and $i$ and $j$ are the $0$-based start and end indices of the chosen substring under the stated tie-breaking rules.\n\nTest Suite:\n- Case $1$ (general case): the string \"abcxyz\".\n- Case $2$ (boundary case: empty): the empty string \"\".\n- Case $3$ (single-element): the string \"z\".\n- Case $4$ (homogeneous): the string \"aaaaa\".\n- Case $5$ (another general case): the string \"lmnoa\".\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each result itself formatted as $[S,i,j]$ and no spaces. For example, the output should look exactly like \"[[S1,i1,j1],[S2,i2,j2],[S3,i3,j3],[S4,i4,j4],[S5,i5,j5]]\" for the five cases above.",
            "solution": "**Problem Validation**\n\nThe provided problem is a well-defined computational task from the domain of algorithms. It asks for the implementation of a specific paradigm (Divide and Conquer) to solve the maximum subarray sum problem, augmented with a character-to-integer mapping and a clear, hierarchical tie-breaking policy.\n\n1.  **Givens Extracted**:\n    *   **Input**: A finite string over the lowercase English alphabet.\n    *   **Mapping**: $a \\mapsto 1, b \\mapsto 2, \\ldots, z \\mapsto 26$.\n    *   **Array**: An array $A$ of integer weights derived from the string.\n    *   **Target**: Find the contiguous subarray $A[i..j]$ with the maximum sum $S(i,j) = \\sum_{t=i}^{j} A[t]$.\n    *   **Algorithm**: Must use Divide and Conquer (D&C).\n    *   **Tie-Breaking**: If sums are equal, choose the one with the smallest start index $i$. If still tied, choose the one with the smallest end index $j$.\n    *   **Indexing**: $0$-based.\n    *   **Edge Case**: For an empty string, the result is sum $0$ with indices $-1, -1$.\n    *   **Output**: A triple $[S, i, j]$.\n\n2.  **Validation Verdict**:\n    *   **Scientifically Grounded**: The problem is based on established computer science and mathematical principles. The mapping is a simple bijective function.\n    *   **Well-Posed**: The problem is unambiguous. The input, transformation, objective function (maximization), constraints (D&C), and tie-breaking rules are all specified, guaranteeing a unique solution.\n    *   **Objective**: The problem is stated with formal, objective language.\n\nThe problem is **valid**. It is a standard algorithmic exercise with specific constraints that test the understanding of the D&C paradigm and the careful implementation of tie-breaking rules.\n\n**Solution Derivation**\n\nThe problem asks for an algorithm to find the contiguous subarray with the maximum sum within a given array of numbers $A$, derived from a string. The algorithm must follow the Divide and Conquer (D&C) paradigm.\n\nLet the input array be $A$ of size $N$. Let our function operate on a subarray defined by indices `low` and `high`, denoted as $A[low..high]$.\n\n**1. Fundamental Principle: Divide and Conquer**\n\nThe D&C strategy consists of three steps:\n*   **Divide**: Divide the problem instance into two or more smaller, independent subproblems of the same type.\n*   **Conquer**: Solve the subproblems recursively. If the subproblem sizes are small enough, solve them directly (base case).\n*   **Combine**: Combine the solutions of the subproblems to form the solution for the original problem.\n\nFor the maximum subarray problem on $A[low..high]$, we divide the array into two halves at the midpoint, $mid = \\lfloor(low + high) / 2\\rfloor$. The maximum subarray can therefore reside in one of three locations:\n1.  Entirely in the left subarray, $A[low..mid]$.\n2.  Entirely in the right subarray, $A[mid+1..high]$.\n3.  Crossing the midpoint, i.e., a subarray $A[i..j]$ such that $low \\le i \\le mid < j \\le high$.\n\n**2. Recursive Structure and Base Case**\n\nThe D&C approach leads to a recursive function.\n\n*   **Recursive Step**: We solve for the maximum subarray in the left half and the right half by making two recursive calls. We then compute the maximum subarray that crosses the midpoint. Finally, we compare the results of these three cases to find the overall maximum, respecting the tie-breaking rules.\n\n*   **Base Case**: The recursion terminates when the subarray contains only one element, i.e., when $low = high$. For such a subarray $A[i..i]$, the maximum subarray is the element itself. The sum is $A[i]$, the start index is $i$, and the end index is $i$. The result is $[A[i], i, i]$.\n\n**3. The Crossing Subarray Calculation**\n\nThis is the core of the \"Combine\" step. A subarray $A[i..j]$ that crosses the midpoint $mid$ is formed by the concatenation of a suffix of the left half, $A[i..mid]$, and a prefix of the right half, $A[mid+1..j]$.\nThe sum is $S(i,j) = (\\sum_{k=i}^{mid} A[k]) + (\\sum_{k=mid+1}^{j} A[k])$.\n\nTo maximize this sum, we must independently maximize the sum of the left suffix and the sum of the right prefix.\n\n*   **Maximum Suffix of the Left Half**: We need to find an index $i$ in $[low, mid]$ that maximizes $\\sum_{k=i}^{mid} A[k]$. We can compute this by iterating from $k = mid$ down to $low$. We maintain a running sum and track the maximum sum seen so far and the index $i$ that produced it.\n    Let $S_{left\\_cross}$ be the maximum suffix sum and $i_{cross}$ be its starting index. We initialize $S_{left\\_cross}$ to a value smaller than any possible sum (e.g., $-\\infty$) and maintain a `current_sum`.\n    `current_sum = 0`\n    `max_left_sum = -∞`\n    `start_index = -1`\n    For $k$ from $mid$ down to $low$:\n        `current_sum = current_sum + A[k]`\n        If `current_sum >= max_left_sum`:\n            `max_left_sum = current_sum`\n            `start_index = k`\n    The tie-breaking rule requires the smallest start index $i$. By updating the index `k` when `current_sum >= max_left_sum`, we ensure that for a given maximum sum, we select the one with the smallest index (since we are iterating downwards from $mid$ to $low$).\n\n*   **Maximum Prefix of the Right Half**: Similarly, we need to find an index $j$ in $[mid+1, high]$ that maximizes $\\sum_{k=mid+1}^{j} A[k]$. We iterate from $k = mid+1$ up to $high$.\n    Let $S_{right\\_cross}$ be the maximum prefix sum and $j_{cross}$ be its ending index.\n    `current_sum = 0`\n    `max_right_sum = -∞`\n    `end_index = -1`\n    For $k$ from $mid+1$ up to $high$:\n        `current_sum = current_sum + A[k]`\n        If `current_sum > max_right_sum`:\n            `max_right_sum = current_sum`\n            `end_index = k`\n    The tie-breaking rule, in case of a further tie on start index, requires the smallest end index $j$. By only updating the index `k` when `current_sum > max_right_sum`, we ensure that for a given maximum sum, we keep the first (and therefore smallest) index $k$ that achieved it.\n\nThe maximum crossing subarray has sum $S_{cross} = S_{left\\_cross} + S_{right\\_cross}$ and spans from $i_{cross}$ to $j_{cross}$.\n\n**4. Combining and Tie-Breaking**\n\nLet the results from the three cases be:\n*   Left: $[S_{L}, i_{L}, j_{L}]$\n*   Right: $[S_{R}, i_{R}, j_{R}]$\n*   Crossing: $[S_{C}, i_{C}, j_{C}]$\n\nWe must select the \"best\" of these three results. A result $[S_1, i_1, j_1]$ is better than $[S_2, i_2, j_2]$ if:\n*   $S_1 > S_2$, OR\n*   $S_1 = S_2$ AND $i_1 < i_2$, OR\n*   $S_1 = S_2$ AND $i_1 = i_2$ AND $j_1 < j_2$.\n\nThis comparison must be applied sequentially. First, compare the left and right results to find an intermediate best. Then, compare this intermediate best with the crossing result to determine the final winner for the current recursive call.\n\n**5. Initial Call and Edge Case**\n\nThe main function will first handle the special case of an empty input string, returning $[0, -1, -1]$ as specified. Otherwise, it will convert the input string into the integer array $A$. It then initiates the D&C process by calling the recursive function on the entire array: `find_max_subarray(A, 0, N-1)`.\n\nThe character-to-integer mapping is $f(c) = \\text{ord}(c) - \\text{ord}('a') + 1$. Since all characters are lowercase English letters, all weights in $A$ will be positive integers from $1$ to $26$. This implies that the maximum subarray sum will always be positive for a non-empty string.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def get_weight(char):\n        \"\"\"Maps a character to its integer weight.\"\"\"\n        return ord(char) - ord('a') + 1\n\n    def is_better(res1, res2):\n        \"\"\"\n        Determines if result 1 is better than result 2 based on the tie-breaking rules.\n        A result is a list [Sum, start_index, end_index].\n        \"\"\"\n        s1, i1, j1 = res1\n        s2, i2, j2 = res2\n\n        if s1 > s2:\n            return True\n        if s1 < s2:\n            return False\n        \n        # Sums are equal, check start index\n        if i1 < i2:\n            return True\n        if i1 > i2:\n            return False\n            \n        # Sums and start indices are equal, check end index\n        if j1 < j2:\n            return True\n        \n        return False\n\n    def find_max_crossing_subarray(arr, low, mid, high):\n        \"\"\"\n        Finds the maximum subarray that crosses the midpoint.\n        This is the 'combine' step of the Divide and Conquer algorithm.\n        \"\"\"\n        # Find maximum suffix sum in the left part (A[i..mid])\n        # We use '>=' to find the smallest start index 'i' in case of a tie in sum,\n        # as we iterate from mid down to low.\n        left_sum = -math.inf\n        current_sum = 0\n        cross_i = -1\n        for i in range(mid, low - 1, -1):\n            current_sum += arr[i]\n            if current_sum >= left_sum:\n                left_sum = current_sum\n                cross_i = i\n\n        # Find maximum prefix sum in the right part (A[mid+1..j])\n        # We use '>' to find the smallest end index 'j' in case of a tie in sum,\n        # as we iterate from mid+1 up to high.\n        right_sum = -math.inf\n        current_sum = 0\n        cross_j = -1\n        for j in range(mid + 1, high + 1):\n            current_sum += arr[j]\n            if current_sum > right_sum:\n                right_sum = current_sum\n                cross_j = j\n        \n        return [left_sum + right_sum, cross_i, cross_j]\n\n\n    def find_max_subarray_recursive(arr, low, high):\n        \"\"\"\n        Recursively finds the maximum subarray sum using Divide and Conquer.\n        Handles tie-breaking as specified.\n        \"\"\"\n        # Base case: only one element\n        if low == high:\n            return [arr[low], low, high]\n\n        # Recursive step\n        mid = (low + high) // 2\n\n        # 1. Maximum subarray is in the left half\n        left_res = find_max_subarray_recursive(arr, low, mid)\n\n        # 2. Maximum subarray is in the right half\n        right_res = find_max_subarray_recursive(arr, mid + 1, high)\n\n        # 3. Maximum subarray crosses the midpoint\n        cross_res = find_max_crossing_subarray(arr, low, mid, high)\n\n        # Compare the three results and return the best one\n        best_res = left_res\n        if is_better(right_res, best_res):\n            best_res = right_res\n        if is_better(cross_res, best_res):\n            best_res = cross_res\n            \n        return best_res\n\n    def find_max_subarray(s: str):\n        \"\"\"\n        Wrapper function to handle input string, including the empty string case.\n        \"\"\"\n        # Handle the empty string case as per the problem description\n        if not s:\n            return [0, -1, -1]\n\n        # Convert string to array of integer weights\n        arr = [get_weight(char) for char in s]\n        \n        return find_max_subarray_recursive(np.array(arr), 0, len(arr) - 1)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"abcxyz\",  # Case 1\n        \"\",        # Case 2\n        \"z\",       # Case 3\n        \"aaaaa\",   # Case 4\n        \"lmnoa\",   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_subarray(case)\n        # Ensure integer types for S, i, j in the final output.\n        result = [int(r) for r in result]\n        results.append(f\"[{result[0]},{result[1]},{result[2]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A key strength of the Divide and Conquer paradigm is its adaptability to new constraints. This problem  challenges you to modify the standard algorithm to find the maximum subarray that must contain a specific element at a given index $p$. Solving this requires thinking critically about how the constraint affects the logic of the recursive calls and the \"combine\" step, offering a deeper insight into the algorithm's mechanics.",
            "id": "3250662",
            "problem": "You are given an integer array $A$ of length $n$ and an index $p$ with $0 \\le p < n$. For any pair of indices $(i,j)$ with $0 \\le i \\le j < n$, define the contiguous subarray $A[i..j]$ as the sequence of elements from index $i$ through index $j$, inclusive, and define its sum as $\\sum_{k=i}^{j} A[k]$. A constrained maximum subarray with respect to $p$ is any contiguous subarray $A[i..j]$ with $i \\le p \\le j$ whose sum is maximized among all such choices. Your task is to design a program that computes, for each test case, the constrained maximum subarray sum with respect to $p$.\n\nFundamental base and constraints for reasoning:\n- Contiguous subarray sums are additive over adjacent partitions, governed by the associativity and commutativity of integer addition.\n- The divide and conquer (D&C) paradigm partitions a problem over an index $m$ and combines subproblem solutions with a crossing solution that straddles $m$.\n- The goal is to produce a correct program that follows a principled recursive decomposition, without assuming any prepackaged formulas for the target result.\n\nRequirements:\n- Implement a function that, given $A$, $p$, and an interval $[l,r]$ with $0 \\le l \\le p \\le r < n$, returns the constrained maximum subarray sum on $A[l..r]$ that is guaranteed to contain $p$. The base case is when $l=r$, in which case the answer is $A[p]$. For the general case, partition at $m = \\lfloor (l+r)/2 \\rfloor$ and combine solutions obtained from subintervals and the crossing configuration that straddles $m$, ensuring the $p$-containment constraint is preserved.\n- Your implementation must be asymptotically optimal within the D&C family for this task, running in time $T(n)$ satisfying $T(n) = T(\\lfloor n/2 \\rfloor) + \\Theta(n)$.\n- The program must execute deterministically and produce exact integer results.\n\nTest suite:\nProvide outputs for the following $8$ test cases, each a pair $(A,p)$.\n- Case $1$: $A = [2,-1,3,-4,5,-2,2]$, $p = 2$.\n- Case $2$: $A = [-5,-2,-3]$, $p = 1$.\n- Case $3$: $A = [1,-2,3,4]$, $p = 0$.\n- Case $4$: $A = [-1,2,-1,2]$, $p = 3$.\n- Case $5$: $A = [7]$, $p = 0$.\n- Case $6$: $A = [-2,1,-3,4,-1,2,1,-5,4]$, $p = 4$.\n- Case $7$: $A = [0,0,0,0]$, $p = 2$.\n- Case $8$: $A = [-2,-1,10,-3,4,-1,2,-5]$, $p = 6$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite above. Concretely, if the results for the $8$ test cases are $r_1,\\dots,r_8$, print the single line\n$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$.",
            "solution": "We formalize the problem and derive a correct and efficient divide and conquer (D&C) solution from first principles. Let $A$ be an array of length $n$, and let $p$ satisfy $0 \\le p < n$. For any interval $[l,r]$ with $0 \\le l \\le p \\le r < n$, define $F(l,r,p)$ to be the maximum sum over all contiguous subarrays $A[i..j]$ such that $l \\le i \\le p \\le j \\le r$.\n\nBase case:\nIf $l=r$, then the only subarray containing $p$ is $A[p]$, and $F(l,r,p) = A[p]$.\n\nDivide and conquer structure:\nLet $m = \\left\\lfloor \\frac{l+r}{2} \\right\\rfloor$. There are two exhaustive and mutually exclusive categories based on the location of $p$ relative to $m$.\n- Case $p \\le m$: Either\n  1. the optimal subarray lies entirely in $[l,m]$ and contains $p$, yielding the subproblem $F(l,m,p)$, or\n  2. the optimal subarray crosses from the left side into the right side. In this crossing case, the subarray must contain $p$ on the left and extend into $[m+1,r]$ on the right. The crossing sum then equals\n  $$\n  S_{\\text{left,include-}p}(l,m,p) + P_{\\text{right}}(m+1,r),\n  $$\n  where $S_{\\text{left,include-}p}(l,m,p)$ denotes the maximum suffix sum of $A[i..m]$ over all $i$ with $l \\le i \\le p$ (so that $A[i..m]$ contains $p$), and $P_{\\text{right}}(m+1,r)$ denotes the maximum prefix sum of $A[m+1..j]$ over all $j$ with $m+1 \\le j \\le r$. Thus,\n  $$\n  F(l,r,p) = \\max\\left(F(l,m,p),\\ S_{\\text{left,include-}p}(l,m,p) + P_{\\text{right}}(m+1,r)\\right).\n  $$\n- Case $p > m$: Symmetrically, either\n  1. the optimal subarray lies entirely in $[m+1,r]$ and contains $p$, yielding the subproblem $F(m+1,r,p)$, or\n  2. the optimal subarray crosses from the left side into the right side and contains $p$ on the right. Then the crossing sum equals\n  $$\n  S_{\\text{left}}(l,m) + P_{\\text{right,include-}p}(m+1,r,p),\n  $$\n  where $S_{\\text{left}}(l,m)$ denotes the maximum suffix sum of $A[i..m]$ over all $i$ with $l \\le i \\le m$ (no $p$-constraint on the left, since $p$ is on the right), and $P_{\\text{right,include-}p}(m+1,r,p)$ denotes the maximum prefix sum of $A[m+1..j]$ over all $j$ with $p \\le j \\le r$ (ensuring the right prefix contains $p$). Thus,\n  $$\n  F(l,r,p) = \\max\\left(F(m+1,r,p),\\ S_{\\text{left}}(l,m) + P_{\\text{right,include-}p}(m+1,r,p)\\right).\n  $$\n\nComputation of the four needed quantities follows directly from the definition of contiguous sums and associativity of addition:\n- $S_{\\text{left,include-}p}(l,m,p)$ is computed by scanning $i$ from $m$ down to $l$, accumulating a running sum of $A[i..m]$ and maintaining the maximum encountered only after $i \\le p$ (to enforce inclusion of $p$).\n- $P_{\\text{right}}(m+1,r)$ is computed by scanning $j$ from $m+1$ up to $r$, accumulating a running sum of $A[m+1..j]$ and maintaining the maximum.\n- $S_{\\text{left}}(l,m)$ is computed by scanning $i$ from $m$ down to $l$, accumulating and maintaining the maximum of $A[i..m]$ without any additional constraint.\n- $P_{\\text{right,include-}p}(m+1,r,p)$ is computed by scanning $j$ from $m+1$ up to $r$, accumulating a running sum and maintaining the maximum only after $j \\ge p$ (to enforce inclusion of $p$).\n\nCorrectness argument:\nWe prove by strong induction on the interval length $\\ell = r-l+1$ that for all $[l,r]$ containing $p$, $F(l,r,p)$ computed by the recurrence above equals the true constrained maximum subarray sum.\n- Base step $\\ell=1$: Trivial since the only subarray is $A[p]$, so $F(l,r,p)=A[p]$ is correct.\n- Inductive step: Assume the claim holds for all intervals of length less than $\\ell$. Consider an interval $[l,r]$ of length $\\ell > 1$ and midpoint $m$. If $p \\le m$, any optimal subarray containing $p$ either lies entirely in $[l,m]$ or crosses into $[m+1,r]$. The first case is correctly handled by the inductive hypothesis as $F(l,m,p)$. In the crossing case, any valid subarray must comprise a suffix of $[l,m]$ that contains $p$ concatenated with a prefix of $[m+1,r]$. Among all such concatenations, the best sum is exactly $S_{\\text{left,include-}p}(l,m,p) + P_{\\text{right}}(m+1,r)$ by the definitions of maximum suffix and prefix sums with the appropriate constraints. Thus taking the maximum of the two options yields the true optimum. The case $p>m$ is symmetric, with an identical inductive argument using $S_{\\text{left}}(l,m)$ and $P_{\\text{right,include-}p}(m+1,r,p)$. Hence the recurrence computes the exact constrained maximum subarray sum.\nTherefore, by induction, the algorithm is correct.\n\nTime complexity:\nLet $T(\\ell)$ denote the time to compute $F(l,r,p)$ on an interval of length $\\ell$. Each recursion splits into exactly one subproblem of size at most $\\lceil \\ell/2 \\rceil$, plus linear-time scans across the split to compute the relevant suffix and prefix maxima. Therefore,\n$$\nT(\\ell) = T(\\lfloor \\ell/2 \\rfloor) + c \\ell,\n$$\nfor some constant $c > 0$, which solves to $T(\\ell) = \\Theta(\\ell)$ by the Master Theorem. Thus the algorithm runs in $O(n)$ time for a single $(A,p)$ instance and uses $O(\\log n)$ recursion depth.\n\nApplying the method to the test suite gives the following results in order:\n- Case $1$: $5$.\n- Case $2$: $-2$.\n- Case $3$: $6$.\n- Case $4$: $3$.\n- Case $5$: $7$.\n- Case $6$: $6$.\n- Case $7$: $0$.\n- Case $8$: $12$.\n\nHence the program should print the single line\n$[5,-2,6,3,7,6,0,12]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_suffix_including_p(A, l, m, p):\n    \"\"\"Maximum sum of a suffix ending at m whose start index i satisfies i <= p.\"\"\"\n    curr = 0\n    best = -10**18\n    valid = False\n    for i in range(m, l - 1, -1):\n        curr += A[i]\n        if i <= p:\n            valid = True\n        if valid:\n            if curr > best:\n                best = curr\n    return best\n\ndef max_prefix(A, m1, r):\n    \"\"\"Maximum sum of a prefix starting at m1 and ending at some j <= r.\"\"\"\n    curr = 0\n    best = -10**18\n    for j in range(m1, r + 1):\n        curr += A[j]\n        if curr > best:\n            best = curr\n    return best\n\ndef max_suffix(A, l, m):\n    \"\"\"Maximum sum of a suffix ending at m with no additional constraints.\"\"\"\n    curr = 0\n    best = -10**18\n    for i in range(m, l - 1, -1):\n        curr += A[i]\n        if curr > best:\n            best = curr\n    return best\n\ndef max_prefix_including_p(A, m1, r, p):\n    \"\"\"Maximum sum of a prefix starting at m1 whose end index j satisfies j >= p.\"\"\"\n    curr = 0\n    best = -10**18\n    for j in range(m1, r + 1):\n        curr += A[j]\n        if j >= p:\n            if curr > best:\n                best = curr\n    return best\n\ndef constrained_max_subarray(A, l, r, p):\n    \"\"\"Divide-and-conquer maximum subarray sum constrained to contain index p within [l,r].\"\"\"\n    if l == r:\n        return A[p]\n    m = (l + r) // 2\n    if p <= m:\n        left_best = constrained_max_subarray(A, l, m, p)\n        cross_left = max_suffix_including_p(A, l, m, p)\n        cross_right = max_prefix(A, m + 1, r)\n        cross = cross_left + cross_right\n        return left_best if left_best >= cross else cross\n    else:\n        right_best = constrained_max_subarray(A, m + 1, r, p)\n        cross_left = max_suffix(A, l, m)\n        cross_right = max_prefix_including_p(A, m + 1, r, p)\n        cross = cross_left + cross_right\n        return right_best if right_best >= cross else cross\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([2, -1, 3, -4, 5, -2, 2], 2),                 # Case 1\n        ([-5, -2, -3], 1),                              # Case 2\n        ([1, -2, 3, 4], 0),                             # Case 3\n        ([-1, 2, -1, 2], 3),                            # Case 4\n        ([7], 0),                                       # Case 5\n        ([-2, 1, -3, 4, -1, 2, 1, -5, 4], 4),           # Case 6\n        ([0, 0, 0, 0], 2),                              # Case 7\n        ([-2, -1, 10, -3, 4, -1, 2, -5], 6),            # Case 8\n    ]\n\n    results = []\n    for arr, p in test_cases:\n        n = len(arr)\n        # Preconditions: 0 <= p < n\n        res = constrained_max_subarray(arr, 0, n - 1, p)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Many problems, from analyzing time-series data to searching genomic sequences, involve cyclical or repeating patterns. This exercise  extends the maximum subarray problem to circular arrays, where a subarray can \"wrap around\" from the end back to the beginning. The solution showcases an elegant problem-reduction technique, demonstrating how to solve this more complex variation by cleverly reusing the solution to the standard linear case.",
            "id": "3250540",
            "problem": "Given a finite sequence of integers $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ of length $n$ with $n \\geq 1$, define a non-empty contiguous subarray on a linear array as any sequence $\\langle a_i, a_{i+1}, \\dots, a_j \\rangle$ for integers $i$ and $j$ satisfying $0 \\leq i \\leq j \\leq n-1$. For a circular array, index arithmetic is performed modulo $n$, so a non-empty contiguous subarray may wrap around the boundary and is any sequence of the form $\\langle a_k, a_{k+1}, \\dots, a_{n-1}, a_0, a_1, \\dots, a_\\ell \\rangle$ for integers $k$ and $\\ell$ satisfying $0 \\leq k \\leq n-1$, $0 \\leq \\ell \\leq n-1$, and where the sequence contains at least one element. The sum of a subarray is the usual integer addition of its elements. The maximum subarray sum in a circular array is the largest possible sum among all non-empty contiguous subarrays under circular indexing.\n\nStarting only from the fundamental definitions above and the general design principle of Divide and Conquer (D and C), which decomposes a problem into subproblems on disjoint parts, solves them independently, and then combines their solutions to obtain the solution of the original problem, implement a program that computes the maximum subarray sum in a circular array for each test case provided below. Your implementation must employ a bona fide D and C strategy to compute the necessary quantities; do not use greedy scanning or dynamic programming.\n\nTest suite to evaluate your program:\n- Case $1$: $[5, -3, 5]$\n- Case $2$: $[-5, -1, -8]$\n- Case $3$: $[7]$\n- Case $4$: $[-7]$\n- Case $5$: $[2, 2, 2]$\n- Case $6$: $[0, -2, 0, -3]$\n- Case $7$: $[10, -12, 11, -1, 12]$\n- Case $8$: $[-2, 1]$\n\nFor each case, the required output is the maximum subarray sum in the circular interpretation, expressed as an integer.\n\nFinal output format specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\dots]$). The results must correspond to Cases $1$ through $8$ in order. No units are involved, and no additional text should be printed.",
            "solution": "The user wants me to solve the \"Maximum Circular Subarray Sum\" problem.\nThe problem is valid. It is a well-defined computational problem within the domain of algorithms and data structures, founded on standard mathematical definitions. It is self-contained, objective, and its solution is verifiable. The constraint to use a Divide and Conquer (D and C) strategy is a standard algorithmic paradigm, making the problem a non-trivial exercise in algorithmic design rather than a simple application of a known greedy algorithm.\n\nThe problem of finding the maximum subarray sum in a circular array can be decomposed into two distinct cases. Let the input array be $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$. A non-empty contiguous subarray in this circular arrangement is either:\n$1$. A standard linear subarray that does not wrap around the ends of the array.\n$2$. A subarray that does wrap around, composed of a suffix of the array followed by a prefix of the array, e.g., $\\langle a_k, \\dots, a_{n-1}, a_0, \\dots, a_{\\ell} \\rangle$.\n\nThe maximum circular subarray sum is therefore the maximum of the sums found in these two cases.\n\n**Case 1: Maximum Linear Subarray Sum**\n\nThis is the standard Maximum Subarray Problem. As per the problem's constraint, we must solve this using a Divide and Conquer strategy. A linear D and C approach for this problem involves the following steps for an array segment $A[\\text{low} \\dots \\text{high}]$:\n- **Divide**: Split the array into two halves at the midpoint, $m = \\lfloor (\\text{low} + \\text{high}) / 2 \\rfloor$. The two subproblems are on $A[\\text{low} \\dots m]$ and $A[m+1 \\dots \\text{high}]$.\n- **Conquer**: Recursively solve for the two halves.\n- **Combine**: The maximum subarray in $A[\\text{low} \\dots \\text{high}]$ can be located in one of three places:\n    a) Entirely within the left half, $A[\\text{low} \\dots m]$.\n    b) Entirely within the right half, $A[m+1 \\dots \\text{high}]$.\n    c) Crossing the midpoint $m$. A crossing subarray is the sum of the maximum possible suffix sum of the left half and the maximum possible prefix sum of the right half.\n\nTo facilitate the combine step efficiently, our recursive function must return not just the maximum subarray sum for a given segment, but a richer set of information. Specifically, for any array segment, we will compute a tuple of four values:\n$1$. $S_{\\text{total}}$: The sum of all elements in the segment.\n$2$. $S_{\\text{max\\_sub}}$: The maximum subarray sum within the segment.\n$3$. $S_{\\text{max\\_prefix}}$: The maximum sum of any non-empty prefix of the segment.\n$4$. $S_{\\text{max\\_suffix}}$: The maximum sum of any non-empty suffix of the segment.\n\nThe base case for the recursion is a single-element array $\\langle x \\rangle$, for which all four values are simply $x$.\nIn the combine step, given the results from the left half ($L$) and right half ($R$):\n- $S_{\\text{total}} = L.S_{\\text{total}} + R.S_{\\text{total}}$\n- $S_{\\text{max\\_prefix}} = \\max(L.S_{\\text{max\\_prefix}}, L.S_{\\text{total}} + R.S_{\\text{max\\_prefix}})$\n- $S_{\\text{max\\_suffix}} = \\max(R.S_{\\text{max\\_suffix}}, R.S_{\\text{total}} + L.S_{\\text{max\\_suffix}})$\n- $S_{\\text{max\\_sub}} = \\max(L.S_{\\text{max\\_sub}}, R.S_{\\text{max\\_sub}}, L.S_{\\text{max\\_suffix}} + R.S_{\\text{max\\_prefix}})$\n\nThe solution for Case $1$, which we denote $S_{\\text{max\\_linear}}$, is the value $S_{\\text{max\\_sub}}$ returned by this D and C procedure for the entire array $A$.\n\n**Case 2: Maximum Wrapping Subarray Sum**\n\nA wrapping subarray is equivalent to the entire array with a non-wrapping (linear) subarray \"removed\" from the middle. To maximize the sum of the wrapping portion, one must remove a linear subarray with the *minimum* possible sum.\nLet $S_{\\text{total}}$ be the sum of all elements in $A$. The sum of a wrapping subarray is $S_{\\text{total}} - S_{\\text{removed}}$, where $S_{\\text{removed}}$ is the sum of the non-empty linear subarray that is left out.\nMaximizing this expression is equivalent to minimizing $S_{\\text{removed}}$.\nTherefore, the maximum wrapping subarray sum is $S_{\\text{max\\_wrap}} = S_{\\text{total}} - S_{\\text{min\\_linear}}$, where $S_{\\text{min\\_linear}}$ is the minimum linear subarray sum.\n\nThe minimum linear subarray sum can be found using the same D and C machinery. Note the identity: $\\min(X) = -\\max(-X)$. We can find $S_{\\text{min\\_linear}}$ by negating all elements of $A$ to form a new array $A'$, finding the maximum linear subarray sum of $A'$, and then negating the result.\n$S_{\\text{min\\_linear}}(A) = -S_{\\text{max\\_linear}}(-A)$.\n\n**Combining Cases and Handling the Edge Case**\n\nThe final answer is $\\max(S_{\\text{max\\_linear}}, S_{\\text{max\\_wrap}})$. However, a critical edge case exists. The logic for the wrapping sum, $S_{\\text{total}} - S_{\\text{min\\_linear}}$, assumes that the subarray being \"removed\" is a *proper* subarray of $A$. If the minimum linear subarray is the entire array itself, \"removing\" it would leave an empty set, which is not a valid non-empty subarray as per the problem definition.\n\nThis situation occurs if and only if $S_{\\text{min\\_linear}} = S_{\\text{total}}$. This happens, for example, when all elements of the array are non-positive. In this scenario, any wrapping subarray sum would be less than or equal to a non-wrapping one, so the wrapping case is not a valid candidate for the maximum. The answer must be the maximum linear subarray sum, $S_{\\text{max\\_linear}}$.\n\nTherefore, the final algorithm is:\n$1$. For an array $A$ of length $n$: if $n = 1$, the answer is $a_0$.\n$2$. Use the D and C procedure to compute $S_{\\text{total}}$ and $S_{\\text{max\\_linear}}$ for array $A$.\n$3$. Use the D and C procedure on the negated array $-A$ to find $S'_{\\text{max\\_linear}}$, and compute $S_{\\text{min\\_linear}} = -S'_{\\text{max\\_linear}}$.\n$4$. If $S_{\\text{min\\_linear}} = S_{\\text{total}}$, the answer is $S_{\\text{max\\_linear}}$.\n$5$. Otherwise, the answer is $\\max(S_{\\text{max\\_linear}}, S_{\\text{total}} - S_{\\text{min\\_linear}})$.\nThis approach correctly computes the maximum circular subarray sum while strictly adhering to the Divide and Conquer paradigm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the maximum circular subarray sum problem\n    for a suite of test cases using a Divide and Conquer strategy.\n    \"\"\"\n\n    test_cases = [\n        [5, -3, 5],\n        [-5, -1, -8],\n        [7],\n        [-7],\n        [2, 2, 2],\n        [0, -2, 0, -3],\n        [10, -12, 11, -1, 12],\n        [-2, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_circular_subarray_sum(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _dnc_linear_solver(arr: np.ndarray) -> tuple[int, int, int, int]:\n    \"\"\"\n    Computes linear subarray properties using Divide and Conquer.\n\n    Args:\n        arr: A numpy array of integers.\n\n    Returns:\n        A tuple containing:\n        (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n    \"\"\"\n    n = arr.shape[0]\n    if n == 1:\n        val = arr[0]\n        return (val, val, val, val)\n\n    mid = n // 2\n    left_arr, right_arr = arr[:mid], arr[mid:]\n\n    left_total, left_max_sub, left_max_pre, left_max_suf = _dnc_linear_solver(left_arr)\n    right_total, right_max_sub, right_max_pre, right_max_suf = _dnc_linear_solver(right_arr)\n\n    # Combine results\n    total_sum = left_total + right_total\n    \n    # Max prefix of combined array is either max prefix of left, or all of left + max prefix of right.\n    max_prefix_sum = max(left_max_pre, left_total + right_max_pre)\n    \n    # Max suffix of combined array is either max suffix of right, or all of right + max suffix of left.\n    max_suffix_sum = max(right_max_suf, right_total + left_max_suf)\n    \n    # Max subarray is in left, in right, or crosses the middle.\n    crossing_sum = left_max_suf + right_max_pre\n    max_subarray_sum = max(left_max_sub, right_max_sub, crossing_sum)\n\n    return (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n\ndef find_max_circular_subarray_sum(arr: list[int]) -> int:\n    \"\"\"\n    Calculates the maximum circular subarray sum for a given array.\n\n    Args:\n        arr: A list of integers, with length n >= 1.\n\n    Returns:\n        The maximum circular subarray sum.\n    \"\"\"\n    n = len(arr)\n    # The problem statement guarantees n >= 1. The D&C base case handles n = 1.\n    \n    arr_np = np.array(arr, dtype=np.int64)\n\n    # Case 1: Find the maximum subarray sum in the linear (non-wrapping) array.\n    total_sum, max_linear_sum, _, _ = _dnc_linear_solver(arr_np)\n\n    # Case 2: Find the maximum wrapping subarray sum.\n    # This is total_sum - min_linear_subarray_sum.\n    # We find min_linear_subarray_sum by finding the max subarray sum of the negated array.\n    # min_sum(A) = -max_sum(-A)\n    neg_arr_np = -arr_np\n    _, max_sum_of_neg_arr, _, _ = _dnc_linear_solver(neg_arr_np)\n    min_linear_sum = -max_sum_of_neg_arr\n\n    # Edge Case: If the minimum linear subarray is the entire array itself\n    # (which happens when all numbers are non-positive), total_sum == min_linear_sum.\n    # In this case, the wrapping sum corresponds to removing the whole array, leaving an\n    # empty set, which is invalid. So, the answer must be the non-wrapping max sum.\n    # This check correctly handles the all-non-positive (and single element) cases.\n    if total_sum == min_linear_sum and n > 0:\n        return max_linear_sum\n    else:\n        max_wrapping_sum = total_sum - min_linear_sum\n        return max(max_linear_sum, max_wrapping_sum)\n\nsolve()\n```"
        }
    ]
}