{
    "hands_on_practices": [
        {
            "introduction": "掌握红黑树删除操作的关键在于理解其修复（fix-up）机制。本练习将引导你完成最简单的修复场景之一：当被删除的黑色节点由一个红色节点替代时 ()。这个案例清晰地展示了红黑树如何通过一次简单的颜色变换来优雅地吸收“黑高”失衡，是理解复杂修复流程的第一步。",
            "id": "3265805",
            "problem": "考虑一个存储不同整数键的红黑树 (RBT)，该树使用标准的删除算法，即当节点有两个子节点时，通过拼接其后继节点来移除该节点，然后仅根据 RBT 的公理进行标准的修复。所有缺失的子节点都是哨兵叶节点 $\\mathsf{NIL}$，其颜色为黑色。\n\n给定以下 RBT，其中根节点是 $x$，键为 $20$，颜色为黑色。$x$ 的左子树如下：\n- 键为 $10$ 的黑色节点，其左子节点是键为 $5$ 的黑色节点（其两个子节点均为 $\\mathsf{NIL}$），其右子节点是键为 $15$ 的黑色节点（其两个子节点均为 $\\mathsf{NIL}$）。\n\n$x$ 的右子树如下：\n- 键为 $30$ 的黑色节点，其左子节点是键为 $25$ 的黑色节点，其右子节点是键为 $35$ 的黑色节点。\n- 键为 $25$ 的节点，其左子节点为 $\\mathsf{NIL}$，右子节点为键为 $27$ 的红色节点（其两个子节点均为 $\\mathsf{NIL}$）。\n- 键为 $35$ 的节点，其左子节点为 $\\mathsf{NIL}$，右子节点为键为 $37$ 的红色节点（其两个子节点均为 $\\mathsf{NIL}$）。\n\n假设这棵树满足所有红黑树的公理。现在，使用上述标准的红黑树删除过程删除节点 $x$（键为 $20$）。具体来说，当一个节点有两个子节点时，它的中序后继节点 $y$ 被拼接出来并移动到被删除节点的位置，只有当被物理删除的节点是黑色时才执行修复操作。这个场景的构造方式使得 $x$ 的中序后继节点是 $x$ 的一个严格孙代节点，并且将其移动到 $x$ 的位置会导致该孙代节点成为 $x$ 原来子节点的新父节点。\n\n令 $R$ 为删除和所有后续修复步骤中执行的旋转（左旋或右旋）总数，令 $K$ 为删除和所有后续修复步骤中实际改变节点颜色位的重新着色操作总数。定义 $C = R + K$。\n\n计算 $C$。你的答案必须是一个实数值。如果需要四舍五入，请保留四位有效数字；然而，本例中无需四舍五入。",
            "solution": "本问题将通过首先验证其前提条件，然后执行指定的标准红黑树 (RBT) 删除算法来解决。\n\n### 问题验证\n\n问题要求计算从给定的 RBT 中删除一个节点期间的旋转次数和颜色改变次数。\n\n树的初始状态描述如下：\n- 根 `x`：键为 $20$，颜色为黑色。\n- `x` 的左子树：键为 $10$ 的节点（黑色），其左子节点为键 $5$（黑色），右子节点为键 $15$（黑色）。\n- `x` 的右子树：键为 $30$ 的节点（黑色），其左子节点为键 $25$（黑色），右子节点为键 $35$（黑色）。键为 $25$ 的节点有一个右子节点，键为 $27$（红色）。键为 $35$ 的节点有一个右子节点，键为 $37$（红色）。所有其他子节点都是哨兵 `NIL` 节点，颜色为黑色。\n\n在继续之前，我们必须验证这个初始配置是否是一个有效的 RBT。RBT 的公理是：\n1.  每个节点要么是红色，要么是黑色。（根据描述满足）。\n2.  根节点是黑色的。（节点 $20$ 是黑色的，满足）。\n3.  每个叶子节点 (`NIL`) 都是黑色的。（根据描述满足）。\n4.  如果一个节点是红色的，那么它的两个子节点都是黑色的。红色节点是 $27$ 和 $37$。它们的子节点都是 `NIL`（黑色），所以这个条件满足。\n5.  对于每个节点，从该节点到其所有后代叶子节点的简单路径都包含相同数量的黑色节点（黑高）。黑高通常定义为从一个节点（不包括该节点）到叶子节点的路径上的黑色节点数量。我们从根节点 ($20$) 开始验证：\n    - 路径 $20 \\to 10(\\text{B}) \\to 5(\\text{B}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 10(\\text{B}) \\to 15(\\text{B}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to (\\text{左})\\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 25(\\text{B}) \\to 27(\\text{R}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 35(\\text{B}) \\to (\\text{左})\\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n    - 路径 $20 \\to 30(\\text{B}) \\to 35(\\text{B}) \\to 37(\\text{R}) \\to \\mathsf{NIL}(\\text{B})$：黑色节点数为 $3$。\n黑高属性成立。初始树是一个有效的 RBT。\n\n问题指定使用“标准删除算法”，但包含了一段可能存在矛盾的描述：“...将其[后继节点]移动到 x 的位置会导致该孙代节点成为 x 原来子节点的新父节点。”标准算法涉及将后继节点的*数据*复制到要删除的节点中，然后从其原始位置拼接出后继节点。后继*节点*本身并不会移动到被删除节点的位置。我们将遵循“标准”的指示，并将后面的句子视为对该过程的不精确描述。因此，在这种解释下，该问题被认为是有效且可解的。\n\n### 删除过程\n\n设要删除的节点为 $z$。在这里，$z$ 是键为 $20$ 的节点。\n初始树如下：\n$$\n\\begin{array}{c}\n20(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 25(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\setminus \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad 27(\\text{R}) \\quad 37(\\text{R})\n\\end{array}\n$$\n\n1.  **识别用于拼接的节点：** 由于节点 $z$（键为 $20$）有两个子节点，我们必须找到它的中序后继节点，我们称之为 $y$。后继节点是 $z$ 的右子树中键最小的节点。右子树的根是 $30$。通过从 $30$ 开始沿着左子指针查找，可以找到最小键，即键为 $25$ 的节点。因此，$y$ 是键为 $25$ 的节点。\n\n2.  **移植数据：** 标准算法将后继节点 $y$ 的键和卫星数据复制到节点 $z$ 中。$z$ 的颜色不改变。\n    - `z.key = y.key` $\\implies$ 原来键为 $20$ 的节点现在键为 $25$。它仍然是黑色的。\n\n3.  **物理删除：** 从树中物理移除（拼接出）的节点是后继节点 $y$（原来键为 $25$ 的节点）。我们来追踪这个节点 $y$ 的属性：\n    - `$y` 的键是 $25$。\n    - `$y` 的颜色是黑色。\n    - 节点 $y$ 有一个右子节点，我们称之为 `x_fixup`，它是键为 $27$、颜色为红色的节点。$y$ 没有左子节点 (`NIL`)。\n\n4.  **拼接：** 通过将其父节点（节点 $30$）链接到其子节点（`x_fixup`，节点 $27$）来移除节点 $y$。由于 $y$ 是 $30$ 的左子节点，节点 $27$ 成为节点 $30$ 的新左子节点。\n\n拼接操作之后、修复过程开始之前的树结构是：\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{R}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\n\n### 修复过程\n\n被物理移除的节点 $y$（原键为 $25$）是黑色的。这违反了 RBT 的属性 5（黑高），影响了所有经过被移除节点的路径。因此，必须调用一个修复过程。该过程 (`RB-DELETE-FIXUP`) 在替换 $y$ 的节点上被调用，即 `x_fixup`（键为 $27$ 的节点）。\n\n修复的核心思想是 `x_fixup` 的位置现在有了一个“额外的黑色”。标准过程根据 `x_fixup` 的颜色来处理这种情况。\n\n- 节点 `x_fixup`（键为 $27$）是**红色**的。\n- 标准的修复算法（例如，来自 CLRS）首先检查节点 `x_fixup` 本身是否为红色。如果是，修复过程很简单：该节点可以通过被染成黑色来吸收“额外的黑色”。\n- 修复过程的主循环条件是 `while x_fixup != root and x_fixup.color == BLACK`。\n- 在我们的情况下，`x_fixup.color` 是红色的。该条件为假，因此根本不会进入 `while` 循环。\n- 因此，没有执行任何旋转操作。旋转次数 $R$ 为 $0$。\n- 循环结束后，算法执行最后一步：`x_fixup.color = BLACK`。键为 $27$ 的节点，原来是红色的，现在被染成黑色。这是一次颜色改变。\n\n### 计数操作\n\n- **旋转 ($R$)：** 修复的 `while` 循环没有被进入。没有执行任何旋转。\n  $$ R = 0 $$\n- **颜色改变 ($K$)：** 键为 $27$ 的节点的颜色从红色变为黑色。这是唯一改变节点颜色位的操作。\n  $$ K = 1 $$\n\n最终有效的 RBT 是：\n$$\n\\begin{array}{c}\n25(\\text{B}) \\\\\n/ \\quad \\setminus \\\\\n10(\\text{B}) \\quad 30(\\text{B}) \\\\\n/ \\quad \\setminus \\quad / \\quad \\setminus \\\\\n5(\\text{B}) \\quad 15(\\text{B}) \\quad 27(\\text{B}) \\quad 35(\\text{B}) \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad \\setminus \\\\\n\\qquad \\qquad \\qquad \\qquad \\qquad 37(\\text{R})\n\\end{array}\n$$\n在这棵最终的树中，所有 RBT 属性都得到满足。\n\n### 最终计算\n\n问题要求计算 $C = R + K$。\n$$ C = 0 + 1 = 1 $$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在掌握了简单的修复情况后，我们来处理一个更复杂的场景。本练习中的删除操作将触发一个不会立即终止的修复过程 ()。通过这个实例，你将学习到“额外黑色”属性如何沿着树向上传播，并需要一系列的重新着色操作才能最终恢复红黑树的全部属性。",
            "id": "3265764",
            "problem": "给定一个具体的红黑二叉搜索树，其键值为互不相同的整数。所有外部叶子节点（哨兵 $\\mathsf{NIL}$）都是黑色的。该树满足红黑树的性质：根节点是黑色的，每个红色节点的子节点都是黑色的，并且从任一节点到其任意后代 $\\mathsf{NIL}$ 的每条路径都包含相同数量的黑色节点。该树的结构如下（每个节点都用括号标注了其颜色）：\n\n- 根节点：$15$ (黑色)\n  - 左子节点：$9$ (黑色)\n    - 左子节点：$5$ (红色)\n      - 左子节点：$3$ (黑色)\n      - 右子节点：$7$ (黑色)\n    - 右子节点：$12$ (红色)\n      - 左子节点：$11$ (黑色)\n      - 右子节点：$13$ (黑色)\n  - 右子节点：$21$ (黑色)\n    - 左子节点：$18$ (红色)\n      - 左子节点：$17$ (黑色)\n      - 右子节点：$19$ (黑色)\n    - 右子节点：$25$ (红色)\n      - 左子节点：$23$ (黑色)\n      - 右子节点：$27$ (黑色)\n\n任务：\n- 仅使用红黑树的基本定义（二叉搜索树的排序性质、红黑树的着色性质，以及标准的红黑树删除流程，包括后继节点替换、旋转和重新着色），首先找出存储的所有键值的中位数，然后使用标准的红黑树删除算法（如 Cormen–Leiserson–Rivest–Stein 等权威教材中所述）从树中删除该中位数。\n- 在执行完所有必要的结构调整和修复操作（旋转和重新着色）以恢复红黑树的性质后，确定最终红黑树根节点存储的键值。\n\n答案格式：\n- 仅提供最终的根节点键值，形式为单个精确整数。无需四舍五入。不要包含任何单位或额外文本。",
            "solution": "题目要求我们对一个给定的红黑树执行删除操作，并确定新根节点的键值。该过程包括：首先确定树中所有键值的中位数，然后使用标准的红黑树删除算法删除具有该键值的节点，最后报告修改后树的根节点的键值。\n\n首先，我们验证所提供的树结构，以确保它符合红黑树和二叉搜索树的性质。\n键值为：$3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27$。\n树的结构如下：\n- 根节点：$15$ (黑色)\n  - 左子节点：$9$ (黑色)\n    - 左子节点：$5$ (红色) -> 子节点 $3$ (黑色), $7$ (黑色)\n    - 右子节点：$12$ (红色) -> 子节点 $11$ (黑色), $13$ (黑色)\n  - 右子节点：$21$ (黑色)\n    - 左子节点：$18$ (红色) -> 子节点 $17$ (黑色), $19$ (黑色)\n    - 右子节点：$25$ (红色) -> 子节点 $23$ (黑色), $27$ (黑色)\n所有节点都满足二叉搜索树的性质。根节点是黑色的。所有红色节点（$5, 12, 18, 25$）的子节点都是黑色的。黑高（从一个节点（不含自身）到其任一后代叶子节点的任意简单路径上的黑色节点数量）是统一的。对于根节点 $15$，所有路径的黑高都是 $2$（例如，经过 $3$ 的路径：$9(\\text{B}) \\rightarrow 5(\\text{R}) \\rightarrow 3(\\text{B}) \\rightarrow \\mathsf{NIL}$，其中的黑色节点是 $9, 3$）。因此，给定的树是一个有效的红黑树。\n\n第一个任务是找出中位数键值。按升序排列的键值集合是：\n$$S = \\{3, 5, 7, 9, 11, 12, 13, 15, 17, 18, 19, 21, 23, 25, 27\\}$$\n键值的数量为 $|S| = 15$。对于一个有奇数个元素的集合，中位数是位于第 $\\frac{n+1}{2}$ 个位置的元素。在这里，即第 $\\frac{15+1}{2} = 8$ 个元素。\n在排序后的集合中数到第8个键值是 $15$。因此，我们必须删除键值为 $15$ 的节点。\n\n待删除的节点，我们称之为 $z$，是树的根节点。节点 $z$ 有两个子节点（节点 $9$ 和 $21$）。标准的二叉搜索树删除流程规定，对于有两个子节点的节点，需要用它的中序后继节点来替换它，然后从后继节点的原始位置删除该后继节点。\n一个节点的中序后继是其右子树中键值最小的节点。节点 $15$ 的右子树根植于节点 $21$。要找到该子树中的最小键值，我们从节点 $21$ 开始沿着左子节点指针前进：$21 \\rightarrow 18 \\rightarrow 17$。因此，中序后继是键值为 $17$ 的节点。我们称这个后继节点为 $y$。\n\n删除算法按以下步骤进行：\n1.  将后继节点 $y$ 的键值（即 $17$）复制到节点 $z$（根节点）中。根节点的键值现在是 $17$，但其颜色保持为黑色。\n2.  问题现在简化为从树中删除原始的后继节点 $y$（键值为 $17$ 的节点）。\n\n我们来检查要被物理删除的节点 $y$。它的键值为 $17$，颜色为黑色，其父节点是节点 $18$。节点 $17$ 没有子节点（其两个子节点都是 $\\mathsf{NIL}$ 叶子节点）。\n当我们移除节点 $y$ 时，我们用它的一个子节点来替换它。我们可以选择它的右子节点，这是一个 $\\mathsf{NIL}$ 节点。我们称这个替换节点为 $x$。所以，$x$ 是一个 $\\mathsf{NIL}$ 节点。\n被删除节点 $y$ 的原始颜色是黑色。从树中移除一个黑色节点会破坏红黑树的性质5，即从一个节点到其后代叶子节点的所有路径必须包含相同数量的黑色节点。为了恢复这个性质，我们必须对节点 $x$ 运行 `RB-DELETE-FIXUP` 过程。节点 $x$ 被认为带有一重“额外黑色”。\n\n针对 $x$ 的 `RB-DELETE-FIXUP` 过程如下。初始时，$x$ 是替换了节点 $17$ 的 $\\mathsf{NIL}$ 节点。$x$ 的父节点，记为 $p(x)$，是节点 $18$。由于 $x$ 不是根节点且是“双重黑色”的，我们进入一个循环。\n\n**第1轮迭代：**\n-   $x$ 是其父节点 $p(x) = 18$ 的左子节点。\n-   我们确定 $x$ 的兄弟节点，记为 $w$。$w$ 是节点 $18$ 的右子节点，即键值为 $19$ 的节点。\n-   $w$（节点 $19$）的原始颜色是黑色。这对应于 CLRS 删除算法中的情况2、3或4。\n-   我们检查 $w$ 的子节点的颜色。节点 $19$ 的两个子节点都是 $\\mathsf{NIL}$ 叶子节点，它们是黑色的。\n-   这种情况符合**情况2**：兄弟节点 $w$ 是黑色的，并且 $w$ 的两个子节点都是黑色的。\n-   情况2的操作是：\n    1.  将 $w$ 重新着色为红色。因此，节点 $19$ 变为红色。\n    2.  通过设置 $x = p(x)$ 将“额外黑色”沿树向上移动。所以，$x$ 现在指向节点 $18$。\n-   现在为新的 $x$（节点 $18$）重新评估循环条件（`x` 不是根节点且是“双重黑色”）。节点 $18$ 的原始颜色是红色。当“额外黑色”移动到一个红色节点上时，循环终止。这个红黑节点直接变为黑色，吸收了额外的黑色，从而恢复了所有经过它的路径的黑高性质。\n\n-   `RB-DELETE-FIXUP` 过程在循环结束后有一个最终步骤：它将当前节点 $x$ 的颜色设置为黑色。在我们的例子中，循环终止时 $x$ 指向节点 $18$。因此，最初是红色的节点 $18$ 被重新着色为黑色。\n\n我们总结一下对树的更改：\n1.  根节点的键值从 $15$ 更改为 $17$。其颜色保持为黑色。\n2.  键值为 $17$ 的节点被物理删除。\n3.  键值为 $19$ 的节点从黑色重新着色为红色。\n4.  键值为 $18$ 的节点从红色重新着色为黑色。\n没有执行任何旋转操作。\n\n树结构的最终状态是：\n- 根节点：$17$ (黑色)\n  - 左子节点：$9$ (黑色)\n    - 左子节点：$5$ (红色)\n    - 右子节点：$12$ (红色)\n  - 右子节点：$21$ (黑色)\n    - 左子节点：$18$ (黑色)\n      - 右子节点：$19$ (红色)\n    - 右子节点：$25$ (红色)\n\n在新树中，所有红黑树的性质都得到满足。根节点是黑色的。每个红色节点（$5, 12, 19, 25$）都有黑色的子节点。从根节点出发的所有路径的黑高仍然是 $2$。\n\n问题要求的是最终红黑树根节点中存储的键值。经过删除和修复操作后，根节点包含原始中位数的后继节点的键值，即 $17$。",
            "answer": "$$\\boxed{17}$$"
        },
        {
            "introduction": "在完成了具体的删除实例后，最后的这项练习将挑战你像算法设计者一样思考。你不再需要执行删除操作，而是要分析树的结构，找出那些删除后完全不需要任何修复操作的节点 ()。这要求你对触发修复机制的条件有全面的理解，从而巩固前两个练习中学到的核心原理。",
            "id": "3265780",
            "problem": "给定一个包含 $n$ 个内部节点的、基于指针的红黑树，它使用标准模型，带有一个共享的哨兵$\\mathsf{NIL}$叶节点，该叶节点被视为每个缺失子树的黑色叶子节点。每个内部节点存储一个键、指向左右子节点的指针以及一个颜色位，颜色为$\\{\\text{red},\\text{black}\\}$之一。该红黑树满足标准的五个属性：根是黑色的，所有$\\mathsf{NIL}$叶节点都是黑色的，每个红色节点只拥有黑色的子节点，以及所有从根到$\\mathsf{NIL}$的路径都具有相同的黑高。考虑标准的删除算法，该算法在删除一个节点 $x$ 时，会使用通常的中序后继规约，将其简化为至多移除一个非$\\mathsf{NIL}$子节点的情况，然后可能执行由旋转和重新着色组成的修正操作，以恢复红黑属性。\n\n定义一个节点 $x$ 为“零修正可删除”的，如果当标准删除算法应用于删除 $x$ 时，该算法执行零次旋转和零次颜色改变。拼接删除 $x$ 所需的指针重新赋值不计为旋转或颜色改变。\n\n设计一个算法，在给定红黑树的根节点且没有任何预处理或增强元数据的情况下，返回一个指向零修正可删除节点的指针（如果存在的话），或者正确报告不存在这样的节点。你的算法可以检查节点的字段（颜色和子指针）并任意遍历指针。成本模型采用单位成本模型，其中每次字段读取或指针遍历的成本为$1$，循环计数器的算术运算是免费的。从第一性原理、红黑树的定义属性以及标准删除算法出发，为此任务的最佳算法推导其最坏情况运行时间的渐近紧确界，并表示为 $n$ 的函数。\n\n用标准的大Theta表示法，将你的最终答案表示为关于 $n$ 的单个渐近表达式。无需取整。",
            "solution": "问题要求设计一个算法，在给定的红黑树中找到一个“零修正可删除”的节点，并确定该问题的最佳算法的最坏情况复杂度的渐近紧确界。\n\n### 第1步：刻画零修正可删除节点\n\n首先，我们必须精确地刻画什么使一个节点成为“零修正可删除”的。根据定义，这是一个节点，对其使用标准删除算法进行删除时，会涉及零次旋转和零次颜色改变。\n\n针对节点 $x$ 的标准删除算法分两个阶段进行：\n1.  **拼接**：一个节点 $y$ 从树结构中被物理地移除（拼接删除）。如果要删除的节点 $x$ 有两个非$\\mathsf{NIL}$子节点，算法会找到它的中序后继，将后继的数据复制到 $x$ 中，然后删除该后继节点。根据定义，后继没有左子节点。因此，问题被规约到删除一个至多有一个非$\\mathsf{NIL}$子节点的节点 $y$。如果 $x$ 本身就至多有一个非$\\mathsf{NIL}$子节点，那么 $y$ 就是 $x$ 自己。\n2.  **修正**：在 $y$ 被拼接删除后，它的子节点（可以是$\\mathsf{NIL}$）将取代它的位置。当且仅当被拼接删除的节点 $y$ 是黑色时，才会调用修正过程（一系列旋转和重新着色）。\n\n移除一个黑色节点 $y$ 会违反红黑属性，即从任一给定节点到其后代叶节点的所有路径都包含相同数量的黑色节点（属性4）。具体来说，任何曾穿过 $y$ 的路径现在都少了一个黑色节点。修正过程就是为了恢复这个属性而设计的。关键在于，如果被拼接删除的节点 $y$ 是红色的，则不会违反任何红黑属性：\n-   属性1（根是黑色的）：红色节点不可能是根节点。\n-   属性2（$\\mathsf{NIL}$是黑色的）：不受影响。\n-   属性3（红色节点有黑色的子节点）：红色节点 $y$ 的父节点必须是黑色的。替代 $y$ 的子节点也是黑色的（因为红色节点的子节点必须是黑色的），从而为 $y$ 的父节点保持了此属性。\n-   属性4（黑高）：移除一个红色节点不会改变任何路径上的黑色节点数量。\n\n因此，当且仅当物理上被拼接删除的节点 $y$ 是红色时，修正过程才会完全跳过，这意味着发生了零次旋转和零次颜色改变。\n\n让我们定义一个“可移除的红色节点”为一个至多有一个非$\\mathsf{NIL}$子节点的红色节点。这恰好是一个节点既是红色的又是那个被物理拼接删除的节点的条件。\n\n综合这些观察，一个节点 $x$ 是零修正可删除的，当且仅当以下两个条件之一成立：\n1.  $x$ 至多有一个非$\\mathsf{NIL}$子节点，且 $x$ 是红色的。（在这种情况下，$y=x$。）\n2.  $x$ 有两个非$\\mathsf{NIL}$子节点，且它的中序后继 $y$ 是红色的。（后继 $y$ 保证没有左子节点，因此它至多有一个非$\\mathsf{NIL}$子节点。）\n\n在这两种情况下，寻找一个零修正可删除节点 $x$ 的问题都归结为找到一个节点 $x$，该节点要么自身是一个可移除的红色节点，要么它的中序后继是一个可移除的红色节点。\n\n### 第2步：设计最优算法（上界）\n\n任务是找到一个满足所推导条件的节点 $x$。一种朴素的方法是遍历所有 $n$ 个节点，对每个节点 $x$ 检查它是否是零修正可删除的。检查 $x$ 本身是否是一个可移除的红色节点需要 $O(1)$ 时间。然而，如果 $x$ 有两个子节点，我们必须找到它的后继，这在红黑树中可能需要 $O(\\log n)$ 时间（通过遍历右子树的左侧链）。这导致总体最坏情况复杂度为 $O(n \\log n)$。\n\n我们可以设计一个更高效的算法，使其在线性时间内运行。关键是使用单次遍历（例如后序遍历），并增强递归调用以向父节点返回必要的信息。让用于以节点 `curr` 为根的子树的递归函数返回一个元组，包含：\n1.  一个指向零修正可删除节点的指针，如果在子树内找到了一个。\n2.  一个指向子树中键最小的节点的指针。\n3.  一个指向子树中键最大的节点的指针。\n\n该算法过程如下：\n`function find_zfd_postorder(curr)`:\n-   **基本情况**：如果 `curr` 是 $\\mathsf{NIL}$，返回 `(null, null, null)`。\n-   **递归步骤**：\n    1.  在左子节点上递归调用：`(zfd_l, min_l, max_l) = find_zfd_postorder(curr.left)`。\n    2.  如果 `zfd_l` 不是 `null`，说明已经找到了一个节点。立即返回 `(zfd_l, null, null)` 将结果向上传播。\n    3.  在右子节点上递归调用：`(zfd_r, min_r, max_r) = find_zfd_postorder(curr.right)`。\n    4.  如果 `zfd_r` 不是 `null`，返回 `(zfd_r, null, null)`。\n-   **处理 `curr`**：\n    1.  **检查条件1**：`curr` 是否是一个可移除的红色节点？检查 `curr.color == red` 并且 (`curr.left == NIL` 或 `curr.right == NIL`)。如果为真，则找到了一个ZFD节点。返回 `(curr, null, null)`。\n    2.  **检查条件2**：`curr` 的后继是否是一个可移除的红色节点？\n        -   只有当 `curr.right` 不是 $\\mathsf{NIL}$ 时，`curr` 的后继才存在。\n        -   后继是右子树中的最小节点，即递归调用返回的 `min_r`。\n        -   后继 `min_r` 保证有 `min_r.left == NIL`。因此，要成为一个可移除的红色节点，它只需要是红色的 (`min_r.color == red`)。\n        -   如果 `curr.right != NIL` 并且 `min_r.color == red`，那么 `curr` 是一个ZFD节点。返回 `(curr, null, null)`。\n-   **返回信息**：如果在 `curr` 或其下方没有找到ZFD节点，则计算以 `curr` 为根的子树的最小值和最大值，并返回它们。\n    -   `my_min = (curr.left != NIL) ? min_l : curr`\n    -   `my_max = (curr.right != NIL) ? max_r : curr`\n    -   返回 `(null, my_min, my_max)`。\n\n该算法精确地访问每个节点一次。在每个节点上（在其子节点被处理后）所做的工作包括常数次的比较和指针操作。因此，总运行时间是 $O(n)$。这为复杂度建立了一个上界。\n\n### 第3步：推导下界\n\n为了建立一个紧确界，我们必须证明没有算法能在渐近意义上比所描述的算法表现得更好。我们主张一个 $\\Omega(n)$ 的下界。\n\n这个问题本质上是一个搜索问题。为了确定是否存在ZFD节点，算法必须收集关于节点颜色和链接的信息。“零修正可删除”的属性是一个局部或半局部的结构属性，与节点中存储的键不相关。因此，算法不能利用二叉搜索树的性质来“锁定”一个ZFD节点，而不检查其局部邻域。\n\n考虑一个对手论证。假设一个算法 $\\mathcal{A}$ 声称只需检查 $o(n)$ 个节点就能解决问题。这意味着 $\\mathcal{A}$ 留下了线性数量的、即 $\\Theta(n)$ 个节点未被检查。\n对手可以提供两棵不同但均有效的红黑树 $T_1$ 和 $T_2$，这两棵树在算法 $\\mathcal{A}$ 检查的所有节点上都是相同的。\n-   $T_1$ 被构造成没有任何零修正可删除节点。例如，一个足够大的、所有节点都是黑色的完美二叉树是一个有效的红黑树，但没有ZFD节点（因为任何删除都会移除一个黑色节点，触发修正）。\n-   $T_2$ 被构造成在被检查的节点上与 $T_1$ 相同，但在某个未被检查的位置包含一个ZFD节点。虽然红黑树的严格属性使得通过简单的局部更改从 $T_1$ 构造出这样的 $T_2$ 并非易事，但构造具有此属性的有效树对是可能的。\n\n由于算法 $\\mathcal{A}$ 无法根据它探测的 $o(n)$ 个节点来区分 $T_1$ 和 $T_2$，因此它必须对两者给出相同的答案。如果它报告“不存在”，那么对于 $T_2$ 来说是错误的。如果它报告一个ZFD节点，那么对于 $T_1$ 来说是错误的（因为它不可能在它检查的节点中找到一个ZFD节点）。\n\n因此，任何正确的确定性算法在最坏情况下都必须检查 $\\Omega(n)$ 个节点，以区分一棵没有ZFD节点的树和一棵带有一个被对手放置的ZFD节点的树。这就在所需操作数量上建立了一个 $\\Omega(n)$ 的下界。\n\n### 第4步：结论\n\n解决该问题的上界是 $O(n)$，由增强的后序遍历算法确立。下界是 $\\Omega(n)$，因为任何算法在最坏情况下都必须准备检查节点总数的常数比例。由于上界和下界相匹配，所以最佳可能算法的最坏情况运行时间的渐近紧确界是 $\\Theta(n)$。",
            "answer": "$$\\boxed{\\Theta(n)}$$"
        }
    ]
}