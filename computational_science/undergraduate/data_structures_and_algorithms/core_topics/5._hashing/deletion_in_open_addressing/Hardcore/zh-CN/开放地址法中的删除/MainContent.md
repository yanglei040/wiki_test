## 引言
在各种哈希技术中，开放寻址法因其空间效率和缓存友好性而备受青睐。然而，当涉及到动态数据集时，一个看似简单的操作——删除元素——却带来了深刻的挑战，威胁到整个[数据结构](@entry_id:262134)的正确性。简单地清空一个被删除元素的槽位，会意外地中断因[哈希冲突](@entry_id:270739)而形成的探测链，使得后续的元素变得“无法访问”，从而导致数据丢失和查找失败。本文旨在系统性地解决这一知识缺口，深入剖析开放寻址中删除操作的标准解决方案。

读者将通过本文学习到：在“原理与机制”章节中，我们将揭示简单删除的根本缺陷，并引入“墓碑”机制作为解决方案，分析其对性能的微妙影响。接着，在“应用与跨学科连接”章节，我们将探索这一机制在缓存系统、[并发编程](@entry_id:637538)、乃至信息安[全等](@entry_id:273198)真实世界场景中的广泛应用。最后，“动手实践”部分将提供一系列练习，帮助您将理论知识转化为实践能力。让我们首先深入核心，理解保证开放寻址哈希表完整性的原理和机制。

## 原理与机制

在任何开放寻址哈希方案中，删除元素的过程带来了一个微妙但至关重要的挑战。与使用独立链法的方案不同（在独立链法中，从链表中移除一个节点是一个简单的局部操作），从开放寻址表中删除一个元素需要仔细考虑，以维护数据结构的完整性。简单地在删除其键后将槽位标记为空，可能会使其他键变得无法访问，从而违反[哈希表](@entry_id:266620)的根本正确性。本章探讨了解决这一问题的标准方案——使用墓碑——背后的原理和机制，并分析了它们对[哈希表](@entry_id:266620)性能的深远影响。

### [可达性](@entry_id:271693)[不变量](@entry_id:148850)与简单删除的缺陷

任何开放寻址方案的正确性都依赖于一个至关重要的[不变量](@entry_id:148850)：对于存储在表中的任何键 $k$，从其初始哈希位置开始的探测序列必须最终能到达包含 $k$ 的槽位，并且途中不会被一个真正为空的槽位所中断。只有当对一个不在表中的键的搜索遍历其整个探测路径，直到遇到一个从未被占用的槽位时，才能保证其不成功搜索的正确性。

以线性探测为例，思考一个简单的场景。假设我们插入了三个键，$k_1$、$k_2$ 和 $k_3$，它们都恰好哈希到同一个初始索引，比如 $j$。[哈希表](@entry_id:266620)可能看起来是这样，这些键占据了一个连续的块：

... | 槽位 $j$: $k_1$ | 槽位 $j+1$: $k_2$ | 槽位 $j+2$: $k_3$ | 槽位 $j+3$: 空 | ...

现在，假设我们通过简单地将槽位 $j+1$ 标记为“空”来删除键 $k_2$：

... | 槽位 $j$: $k_1$ | 槽位 $j+1$: **空** | 槽位 $j+2$: $k_3$ | 槽位 $j+3$: 空 | ...

现在当我们搜索 $k_3$ 时会发生什么？搜索将从索引 $j$ 开始，发现 $k_1$ 不匹配，然后前进到索引 $j+1$。当发现槽位 $j+1$ 为空时，搜索算法将根据其规则错误地断定 $k_3$ 不在表中。键 $k_3$ 变得无法访问了。这种对[可达性](@entry_id:271693)[不变量](@entry_id:148850)的违反破坏了[数据结构](@entry_id:262134)。

### 墓碑解决方案：维护探测链

为了解决这个问题，我们在“已占用”和“空”之外，为槽位引入了第三种状态。这种特殊状态被称为**墓碑**（tombstone）或**已删除标记**。

墓碑的语义旨在解决[可达性](@entry_id:271693)困境：

1.  **对于搜索操作（成功或不成功）：** 墓碑被当作一个已占用的槽位。当探测序列遇到墓碑时，搜索不会终止。它必须继续探测，以确保任何在探测链中被放置在现已删除的键“之后”的键仍然是可达的。 

2.  **对于插入操作：** 墓碑标记了一个可供重用的槽位。插入算法可以将新键放置在其探测路径上遇到的第一个可用槽位中，这个槽位可以是一个墓碑，也可以是一个真正为空的槽位。重用遇到的第一个墓碑是一种常见的优化，有助于最小化新键的探测长度。

3.  **终止条件：** 因此，一次不成功的搜索或一次插入时的搜索，仅在遇到一个真正**空**的槽位——一个从未被占用的槽位——时才会终止。

回到我们的例子，删除 $k_2$ 现在将涉及在槽位 $j+1$ 放置一个墓碑：

... | 槽位 $j$: $k_1$ | 槽位 $j+1$: **墓碑** | 槽位 $j+2$: $k_3$ | 槽位 $j+3$: 空 | ...

现在，对 $k_3$ 的搜索将正确地越过索引 $j+1$ 处的墓碑，并在索引 $j+2$ 处找到 $k_3$。可达性[不变量](@entry_id:148850)得到了维护。

### 正确性的性能代价：墓碑与性能退化

虽然墓碑解决了正确性问题，但它们也引入了一个显著的性能问题。为了探测的目的，墓碑就像已占用的槽位一样充当了障碍物。它们的存在延长了探测链，并降低了所有[哈希表](@entry_id:266620)操作的性能。

#### 有效[负载因子](@entry_id:637044)

开放寻址的性能通常根据**[负载因子](@entry_id:637044)** $\alpha$（即被占用槽位的比例）来分析。然而，在一个有墓碑的表中，这个指标是不够的。由于在搜索过程中必须跳过已占用槽位和墓碑槽位，因此性能实际上由**有效[负载因子](@entry_id:637044)**决定，即非空槽位的总比例。

设 $\alpha$ 为活动[负载因子](@entry_id:637044)（包含键的槽位比例），$\tau$ 为**墓碑密度**（包含墓碑的槽位比例）。有效[负载因子](@entry_id:637044)，我们记为 $\alpha'$，是：
$$ \alpha' = \alpha + \tau $$

关键的洞见是，对于一次不成功的搜索（它必须持续到找到一个真正的空槽位），一个包含活动键的槽位和一个包含墓碑的槽位之间没有区别。 例如，考虑两个表：表A的活动[负载因子](@entry_id:637044)为 $\alpha=0.5$，墓碑密度为 $\tau=0.4$；表B的活动[负载因子](@entry_id:637044)为 $\alpha=0.9$，墓碑密度为 $\tau=0$。在这两种情况下，有效[负载因子](@entry_id:637044)都是 $\alpha' = 0.9$。对于一次不成功的搜索，在任何一次探测中遇到非空槽位的概率在两个表中都是 $0.9$。因此，在[一致性哈希](@entry_id:634137)假设下，即使表A包含的活动键少得多，两次不成功搜索的预期探测次数也是相同的。

#### 对预期搜索成本的影响

这个原理可以被正式推广。对于像线性探测这样的开放寻址方案，最初由Donald Knuth推导出的预期搜索成本的经典公式是[负载因子](@entry_id:637044)的函数。在存在墓碑的情况下，如果我们用有效[负载因子](@entry_id:637044) $\alpha' = \alpha + \tau$ 替换活动[负载因子](@entry_id:637044) $\alpha$，这些公式仍然有效。

在线性探测和[一致性哈希](@entry_id:634137)假设下，成功（$\mathbb{E}_s$）和不成功（$\mathbb{E}_u$）搜索的近似预期探测次数变为：
$$ \mathbb{E}_s(\alpha, \tau) \approx \frac{1}{2} \left( 1 + \frac{1}{1 - (\alpha + \tau)} \right) $$
$$ \mathbb{E}_u(\alpha, \tau) \approx \frac{1}{2} \left( 1 + \frac{1}{(1 - (\alpha + \tau))^2} \right) $$

这些方程正式表明，与那些墓碑槽位真正为空的状态相比，墓碑必然会增加成功和不成功搜索的预期探测次数。 随着 $\tau$ 的增加，$\alpha'$ 接近 $1$，搜索成本急剧上升。

#### 墓碑聚集与[方差](@entry_id:200758)

墓碑不仅增加了平均搜索长度，它们本身也可能形成连续的簇。在一个独立性模型下的[概率分析](@entry_id:261281)表明，如果你随机选择一个墓碑，它所属的簇的预期长度是 $\frac{1+\tau}{1-\tau}$。 这个尺寸偏差结果表明，长的墓碑簇是一个显著特征，会进一步导致长的探测序列。

此外，墓碑的空间分布影响探测长度的可[变性](@entry_id:165583)（[方差](@entry_id:200758)）。如果墓碑聚集在一起而不是均匀散布，[哈希表](@entry_id:266620)将具有密度非常高的区域和密度较低的区域。这增加了非空单元格运行长度的[方差](@entry_id:200758)。这种变化对不成功搜索的影响比对成功搜索更显著，因为不成功搜索必须遍历整个运行，而成功搜索平均只遍历运行的一半。因此，墓碑的聚集倾向于比成功搜索更多地增加不成功搜索时间的[方差](@entry_id:200758)。

### 高级主题与实践考量

#### 重建（Rehashing）的必然性

这种性能退化的一个直接后果是，在任何有大量删除操作的系统中，墓碑都会累积。如果删除的数量超过插入的数量，墓碑密度 $\tau$ 将会增长，导致有效[负载因子](@entry_id:637044) $\alpha'$ 上升，即使活动键的数量 $\alpha$ 保持很小或减少。如果没有清理墓碑的机制，表的性能将不可避免地崩溃。

这使得**周期性重建**（periodic rehashing 或 rebuilding）成为一项必不可少的维护操作。一次重建涉及创建一个新的、更大的表，并将旧表中的所有活动键插入其中，从而丢弃所有墓碑。这是一项成本高昂的操作，但它将墓碑密度“重置”为零并恢复性能。

*何时*重建的决定涉及一个关键的权衡。过于频繁地重建会产生过多的开销，而等待太久则会让性能下降到不可接受的程度。可以正式地对此权衡进行建模。通过考虑重建的成本与因墓碑导致的较慢操作的累积成本，可以推导出一个最佳的墓碑密度阈值 $\tau_d^{\star}$，在该阈值触发重建以最小化长期摊销的单位操作成本。

相比之下，不需要墓碑的哈希方案，如**[布谷鸟哈希](@entry_id:636374)**（cuckoo hashing），则不会遭受这种性能退化。在[布谷鸟哈希](@entry_id:636374)中，删除是一个简单的 $O(1)$ 操作，即清空一个槽位，使其立即变得可用。在一个删除密集型的工作负载中，[布谷鸟哈希](@entry_id:636374)能保持高而稳定的[吞吐量](@entry_id:271802)，而一个没有重建的、基于墓碑的开放寻址方案则会陷入停滞。

#### 与探测策略的相互作用

墓碑加剧了特定探测策略固有的聚集行为。在**线性探测**中，具有不同初始哈希值的键可以加入同一个连续的簇（这种现象称为**主聚集**），墓碑就像胶水一样，保持了这些簇的连续性并延长了它们。

相比之下，**二次探测**不易受主聚集的影响，因为具有不同初始哈希值的键遵循不同的探测序列。墓碑的存在不会改变这一基本属性；它们不能导致不相交的探测序列合并。 虽然墓碑仍然会通过延长任何给定序列的路径来增加二次探测的搜索成本，但它们不会引入在线性探测中看到的灾难性堆积效应。

#### 删除操作本身的成本

区分删除的算法复杂性与其真实系统成本非常重要。基于墓碑的删除的算法部分包括一次成功的搜索以找到键，然后是一次单一的写入操作以将槽位标记为墓碑。搜索所需的探测次数取决于有效[负载因子](@entry_id:637044) $\alpha'$，但关键是，只要可以通过读取一个小的、固定大小的元数据来检查槽位的状态，它就与存储在表中的值的大小无关。

然而，如果哈希表存储指向大型对象的指针，删除操作还可能涉及释放该对象的内存。内存释放的成本可能取决于对象的大小，这就引入了一个成本组成部分，它在哈希表的探测逻辑之外，但属于删除的整体系统成本。

#### 关于“墓碑感知”优化的警示

墓碑在探测序列上保留“空间”的概念引发了各种巧妙优化的提议。例如，有人可能想在墓碑内存储已删除键的哈希值，并尝试在后续的插入或重定位操作中使用此信息。

然而，这类想法充满了危险，几乎总是错误的。例如，一个将键 `y` 向后移动到其探测路径上“更早”的墓碑中的提议是不安全的。虽然这一移动似乎缩短了 `y` 的路径，但它有可能会破坏另一个键 `w` 的探测链，`w` 可能在 `y` 的原始位置与之发生了冲突。通过清空 `y` 的原始槽位，对 `w` 的搜索现在可能会过早终止，从而找不到 `w`。

核心原则至关重要：表中每个键的每条探测链的完整性都必须得到维护。对插入或删除逻辑的任何修改，无论直觉上多么吸引人，都必须根据这一基本的正确性[不变量](@entry_id:148850)进行严格验证。在墓碑中存储额外的元数据通常不能提供一个安全的方法来规避这一规则；正确性依赖于正在搜索或移动的键的哈希值，而不是先前已删除的键的哈希值。