{
    "hands_on_practices": [
        {
            "introduction": "线性探测法虽然简单，但它存在“主聚集”（primary clustering）的弱点，即相邻的已占用槽会合并成越来越长的簇。本练习将让你通过构造一个“对抗性”的键序列来亲手触发这种最坏情况，并精确计算由此产生的性能损失，从而深刻理解主聚集的成因和影响。",
            "id": "3244644",
            "problem": "考虑一个大小为 $m$ 的哈希表，它使用开放寻址法和线性探测来解决冲突。冲突解决规则如下：当插入或搜索键 $k$ 时，探测表索引序列 $h(k), h(k)+1, h(k)+2, \\dots$（对 $m$ 取模），直到找到一个空槽（在插入操作中）或找到目标键（在成功搜索中）。主哈希函数为 $h(k) = k \\bmod m$。该表初始为空。你将插入 $n$ 个不同的键 $k_1, k_2, \\dots, k_n$（其中 $0  n  m$）。在所有插入操作完成后，将对从集合 $\\{k_1, k_2, \\dots, k_n\\}$ 中均匀随机抽取的一个键执行一次成功搜索。定义负载因子 $\\alpha$ 为 $\\alpha = \\frac{n}{m}$。\n\n你的任务是设计一个对抗性的 $m$ 值和一组不同的键序列 $k_1, \\dots, k_n$，使得线性探测在表中创建一个长度为 $n$ 的单个连续簇，然后量化在上述均匀随机键模型下成功搜索所需的期望探测次数。你必须完成以下任务：\n\n- 指定一个有效的 $m$ 和用 $m$ 表示的 $k_1, \\dots, k_n$ 的选择，以确保在 $h(k) = k \\bmod m$ 哈希函数下，所有键都哈希到相同的初始索引，从而通过线性探测强制形成一个单一的连续簇。论证这些键是不同的，并且最终形成的簇是长度为 $n$ 的连续簇。\n\n- 从开放寻址法、线性探测法以及由 $h(k)$ 导出的探测序列的核心定义出发，推导当查询键从已插入的 $n$ 个键中均匀抽取时，成功搜索所需的期望探测次数。将你的最终答案表示为关于负载因子 $\\alpha$ 和 $m$ 的闭式解析表达式。\n\n不得引用任何快捷公式；必须直接从定义以及对抗性序列对探测序列的结构性影响来推导结果。最终答案必须是单一的闭式解析表达式。无需进行四舍五入。",
            "solution": "问题陈述经核实具有科学依据，提法明确，客观且完整。它描述了哈希中线性探测的一个经典最坏情况，这是算法分析中的一个标准课题。该问题没有任何科学或逻辑上的缺陷。因此，我们可以开始求解。\n\n任务是首先构建一个能产生特定对抗性条件（单个连续簇）的键序列，然后推导在此条件下成功搜索的期望探测次数。\n\n### 第 1 部分：对抗性键序列的构建\n\n目标是选择一个哈希表大小 $m$ 和一个包含 $n$ 个不同键的序列 $k_1, k_2, \\dots, k_n$，使得所有键都哈希到同一个初始表索引，从而通过线性探测生成一个单一的长簇。\n\n设哈希表大小 $m$ 为一个满足 $m > n > 0$ 的整数。\n主哈希函数给定为 $h(k) = k \\bmod m$。\n为确保所有键都哈希到相同的索引，我们必须有 $h(k_1) = h(k_2) = \\dots = h(k_n)$。不失一般性地，我们选择这个公共哈希索引为 $0$。这要求对于所有 $i \\in \\{1, 2, \\dots, n\\}$，都有 $k_i \\bmod m = 0$。这等价于声明每个键 $k_i$ 都必须是 $m$ 的整数倍。\n\n我们还必须确保这些键是不同的。一个同时满足这两个条件的简单选择是，将这些键定义为 $m$ 的连续非零倍数。我们指定键序列为：\n$$k_i = i \\cdot m \\quad \\text{for } i = 1, 2, \\dots, n$$\n\n我们验证这个键的选择满足所需标准：\n1.  **不同性**：设 $i$ 和 $j$ 是集合 $\\{1, 2, \\dots, n\\}$ 中两个不同的索引，即 $i \\neq j$。由于 $m > n > 0$，因此有 $i \\cdot m \\neq j \\cdot m$。所以，键 $k_1, k_2, \\dots, k_n$ 都是不同的。\n2.  **公共哈希索引**：对于序列中的任意键 $k_i = i \\cdot m$，哈希函数产生 $h(k_i) = (i \\cdot m) \\bmod m = 0$。所有键都哈希到初始索引 $0$。\n\n现在，我们分析将这 $n$ 个键按顺序插入一个初始为空的哈希表后的状态。\n-   **插入 $k_1 = 1 \\cdot m$**：哈希索引为 $h(k_1)=0$。索引 $0$ 处的表槽为空，所以 $k_1$ 被放置在索引 $0$ 处。这需要 $1$ 次探测。\n-   **插入 $k_2 = 2 \\cdot m$**：哈希索引为 $h(k_2)=0$。槽 $0$ 此时被 $k_1$ 占用。线性探测继续到下一个索引 $(0+1) \\bmod m = 1$。槽 $1$ 为空，所以 $k_2$ 被放置在索引 $1$ 处。这需要 $2$ 次探测（一次探测槽 $0$，一次探测槽 $1$）。\n-   **插入 $k_3 = 3 \\cdot m$**：哈希索引为 $h(k_3)=0$。槽 $0$ 被占用。探测索引 $1$ 发现它也被占用。探测索引 $(0+2) \\bmod m = 2$ 发现一个空槽。因此，$k_3$ 被放置在索引 $2$ 处。这需要 $3$ 次探测。\n\n我们可以用一个简单的归纳论证来将其形式化。假设在插入键 $k_1, \\dots, k_{j-1}$ 之后，索引为 $0, 1, \\dots, j-2$ 的表槽已被占用。现在，考虑插入键 $k_j = j \\cdot m$。其哈希索引为 $h(k_j)=0$。线性探测序列是 $0, 1, 2, \\dots$。探测将检查槽 $0, 1, \\dots, j-2$，所有这些槽都已被占用。下一次探测是到索引 $j-1$。由于 $j-1  n  m$，该索引在表的边界内，并且根据我们的假设，它是空的。因此，$k_j$ 被放置在索引 $j-1$ 处。插入 $k_j$ 所需的探测次数是 $(j-1) - 0 + 1 = j$。\n\n这个过程对从 $1$ 到 $n$ 的所有 $j$ 都成立。在插入所有 $n$ 个键 $k_1, \\dots, k_n$ 之后，哈希表中索引为 $0, 1, \\dots, n-1$ 的槽被占用。这形成了一个长度为 $n$ 的单一连续簇，符合题目的要求。\n\n### 第 2 部分：成功搜索的期望探测次数\n\n我们要求解成功搜索的期望探测次数，其中待搜索的键是从已插入的 $n$ 个键的集合 $\\{k_1, k_2, \\dots, k_n\\}$ 中均匀随机抽取的。\n\n成功搜索一个键所需的探测次数，与最初插入该键时所需的探测次数相同。设 $C(k)$ 为搜索键 $k$ 的探测次数。根据我们在第 1 部分的分析，插入（并因此找到）键 $k_i$ 所需的探测次数为 $C(k_i) = i$。\n\n待搜索的键是以均匀概率抽取的。这意味着搜索任何特定键 $k_i$ 的概率为 $P(\\text{搜索 } k_i) = \\frac{1}{n}$。\n\n设 $E[C_S]$ 为成功搜索的期望探测次数。根据期望值的定义，我们有：\n$$E[C_S] = \\sum_{i=1}^{n} C(k_i) \\cdot P(\\text{搜索 } k_i)$$\n代入我们求得的值：\n$$E[C_S] = \\sum_{i=1}^{n} i \\cdot \\frac{1}{n}$$\n我们可以将常数 $\\frac{1}{n}$ 从求和式中提出：\n$$E[C_S] = \\frac{1}{n} \\sum_{i=1}^{n} i$$\n该求和是前 $n$ 个正整数的和，其闭式公式是众所周知的：\n$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$\n将此代回期望值的表达式中：\n$$E[C_S] = \\frac{1}{n} \\left( \\frac{n(n+1)}{2} \\right) = \\frac{n+1}{2}$$\n问题要求最终答案用负载因子 $\\alpha = \\frac{n}{m}$ 和表大小 $m$ 来表示。根据负载因子的定义，我们可以将 $n$ 表示为 $n = \\alpha m$。\n\n将 $n = \\alpha m$ 代入我们得到的 $E[C_S]$ 结果中：\n$$E[C_S] = \\frac{(\\alpha m) + 1}{2} = \\frac{\\alpha m + 1}{2}$$\n这就是在指定的对抗性条件下，成功搜索的期望探测次数的最终闭式解析表达式。",
            "answer": "$$\\boxed{\\frac{\\alpha m + 1}{2}}$$"
        },
        {
            "introduction": "理论上的最坏情况分析固然重要，但算法在平均情况下的表现同样关键。本练习将指导你编写一个完整的测试程序，通过枚举所有插入顺序来经验性地比较线性探测、二次探测和双重散列的性能。你将直观地看到插入顺序如何影响聚集形态和探测成本，并验证更高级的探测策略在分散冲突方面的优势。",
            "id": "3244620",
            "problem": "要求你编写一个完整、可运行的程序，为开放定址哈希表构建一个系统性测试工具，并量化地展示在不同探测策略下，插入顺序如何影响簇的形态和探测成本。重点是线性探测、二次探测和双重哈希。\n\n从以下基本概念开始：\n- 一个使用开放定址的哈希表将每个键存储在一个大小为 $m$ 的固定大小数组的恰好一个槽位中。要插入一个键 $k$，我们会考虑一个索引的探测序列，按顺序检查它们，并将 $k$ 放置在遇到的第一个空槽位中。\n- 哈希函数将键映射到模 $m$ 的初始索引。\n- 对于给定的探测方案，键 $k$ 的探测序列由一个关于 $k$ 和探测次数 $t$ 的确定性函数定义，其结果对 $m$ 取模。\n\n本问题中使用的定义：\n- 对每个键 $k$，定义主哈希为 $h(k) = k \\bmod m$。\n- 线性探测：探测序列为 $h(k), h(k)+1, h(k)+2, \\dots$ 模 $m$。\n- 二次探测：探测序列为 $h(k) + c_1 t + c_2 t^2$ 模 $m$，其中常量 $c_1 = 1$ 和 $c_2 = 1$。因此，在第 $t$ 次尝试时的探测索引为 $h(k) + t + t^2 \\pmod m$。如果在 $m$ 次探测内未找到空槽位，则对于该排列，二次探测下的插入操作失败。\n- 双重哈希：定义第二步哈希为 $h_2(k) = 1 + (k \\bmod (m-1))$。探测序列为 $h(k), h(k) + h_2(k), h(k) + 2 h_2(k), \\dots$ 模 $m$。假设 $m$ 是素数，因此 $h_2(k)$ 与 $m$ 互质。\n\n簇度量标准：\n- 考虑在按给定顺序插入给定集合中的所有键后，哈希表的占用情况。一个簇被定义为在长度为 $m$ 的循环数组中，已占用槽位的最大连续序列。将所有这些簇的长度（位于空槽位之间）收集到一个多重集中。表状态的簇签名被定义为这些长度的排序列表。此签名取决于最终的占用模式，但在环形旋转下保持不变。例如，如果 $m=11$ 且已占用槽位形成三个长度分别为 $[4,2,1]$ 的序列，则簇签名为 $[1,2,4]$。\n- 探测成本度量标准：对于一个键的插入，探测次数是指在放置键之前所检查的槽位数量（包括成功放置的槽位）。一个键集合的完整插入顺序的总探测成本是所有插入键的探测次数之和。\n\n你的任务：\n- 对于下面的每个测试用例，考虑相同的键集合，并枚举其插入顺序的所有排列。对于每种探测方案（线性、二次、双重），为每个排列模拟开放定址插入，并计算：\n  1) 对于该方案，在所有成功插入所有键的排列中，观察到的不同簇签名的数量。\n  2) 在所有这些成功排列中的最小总探测成本。\n  3) 在所有这些成功排列中的最大总探测成本。\n- 如果一个排列在二次探测下导致插入失败（即在 $m$ 次探测内未能为某个键找到空槽位），则该排列不计入其方案的所有度量指标；但仍需包括所有其他成功的排列。对于线性探测和双重哈希，在给定参数下，所有排列都将成功。\n\n测试套件：\n- 用例1：表大小 $m = 11$，键 $K = [10,21,32,43,54]$。\n- 用例2：表大小 $m = 13$，键 $K = [0,13,26,39,1,14]$。\n- 用例3：表大小 $m = 17$，键 $K = [16,33,50,67,1,18,35]$。\n\n所有键都是整数，所有 $m$ 都是素数，装载因子小于或等于 $0.5$，以确保真实的开放定址行为。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并按顺序排列。每个条目本身必须是一个包含三个条目的列表，分别对应线性探测、二次探测和双重哈希。对于每种探测方案，输出一个包含三个整数的列表：$[\\text{不同签名数量}, \\text{最小总探测数}, \\text{最大总探测数}]$。\n- 具体来说，最终的单行输出必须如下所示：\n  - $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]],[[d_1,e_1,f_1],[d_2,e_2,f_2],[d_3,e_3,f_3]],[[g_1,h_1,i_1],[g_2,h_2,i_2],[g_3,h_3,i_3]]$，并包含在一个最外层的方括号内。不得有任何其他文本。\n- 格式示例（非实际结果）：$[[1,10,14],[2,9,15],[1,8,12]],[[3,20,28],[2,18,27],[1,16,22]],[[5,24,35],[4,23,34],[2,20,30]]$。\n\n角度单位和物理单位不适用。所有要求的答案都是整数。你的程序必须是完全自包含的，并且不得读取任何输入。它必须计算并打印上述指定的单行最终结果。",
            "solution": "在尝试给出解决方案之前，需对问题进行验证。\n\n### 步骤1：提取已知信息\n-   **哈希表**：一个使用开放定址的哈希表，具有一个大小为 $m$ 的固定大小数组。\n-   **主哈希函数**：$h(k) = k \\bmod m$。\n-   **探测策略**：\n    1.  **线性探测**：在第 $t \\ge 0$ 次尝试时的探测索引为 $(h(k) + t) \\pmod m$。\n    2.  **二次探测**：在第 $t \\ge 0$ 次尝试时的探测索引为 $(h(k) + c_1 t + c_2 t^2) \\pmod m$，其中常量 $c_1 = 1$ 和 $c_2 = 1$。如果在 $m$ 次探测内未找到空槽位，则插入失败。\n    3.  **双重哈希**：在第 $t \\ge 0$ 次尝试时的探测索引为 $(h(k) + t \\cdot h_2(k)) \\pmod m$，其中第二哈希函数为 $h_2(k) = 1 + (k \\bmod (m-1))$。假设 $m$ 是素数。\n-   **度量标准**：\n    1.  **簇签名**：在循环表数组中，所有最大连续已占用槽位序列的长度的排序列表。\n    2.  **总探测成本**：在给定的插入序列中，所有键的探测次数之和。单个键的探测次数是在放置该键之前检查的槽位数量。\n-   **任务**：对于每个测试用例，遍历键的插入顺序的所有排列。对于三种探测方案中的每一种，计算：\n    1.  在所有成功排列中，不同簇签名的数量。\n    2.  在所有成功排列中，最小的总探测成本。\n    3.  在所有成功排列中，最大的总探测成本。\n-   **排除条件**：对于二次探测，任何导致插入失败的排列都将从该方案的度量计算中排除。\n-   **测试套件**：\n    -   用例1：$m = 11$，键 $K = [10, 21, 32, 43, 54]$。\n    -   用例2：$m = 13$，键 $K = [0, 13, 26, 39, 1, 14]$。\n    -   用例3：$m = 17$，键 $K = [16, 33, 50, 67, 1, 18, 35]$。\n-   **输出格式**：一个单行，表示一个嵌套的结果列表：`[[case1_results], [case2_results], [case3_results]]`，其中每个 `case_results` 是 `[[linear_metrics], [quadratic_metrics], [double_hashing_metrics]]`，每个 `metrics` 是 `[distinct_signatures, min_total_probes, max_total_probes]`。\n\n### 步骤2：使用提取的已知信息进行验证\n对问题陈述进行有效性评估。\n1.  **科学依据**：该问题在数据结构和算法的基本原理方面有坚实的基础，特别是关于哈希表和开放定址。线性探测、二次探测和双重哈希的定义是标准的且规定正确。使用素数模数 $m$ 和 $h_2(k)$ 的特定形式是双重哈希的最佳实践，以确保能搜索整个表。\n2.  **适定性**：该问题是适定 (well-posed) 的。输入被清晰定义，所需的计算是确定性的，并且期望的输出有明确的规定。每个键集的排列数量（$5! = 120$， $6! = 720$， $7! = 5040$）是有限且计算上可管理的，确保可以推导出唯一的解。\n3.  **客观性**：该问题以精确、客观和数学化的语言陈述。像“簇签名”和“总探测成本”等度量标准的定义是明确的，没有主观解释的余地。\n4.  **完整性与一致性**：该问题是自包含的。所有必要的参数（$m$, $K$, 探测常量）和定义都已提供。二次探测中失败的条件已明确说明。所述的装载因子（$\\alpha = |K|/m \\le 0.5$）对于开放定址是现实的，并如断言的那样，保证了线性探测和双重哈希的成功。\n\n### 步骤3：结论与行动\n该问题是**有效的**。这是一个计算机科学领域严谨的计算练习，没有任何科学、逻辑或结构上的缺陷。将提供一个完整的解决方案。\n\n### 解决方案\n该解决方案需要对不同条件下的哈希表性能进行系统性的模拟和分析。方法的核心是枚举给定键集的所有可能插入顺序，并对每个顺序，为三种指定的开放定址方案中的每一种模拟插入过程。\n\n**方法论**\n\n1.  **系统性枚举**：对于由表大小 $m$ 和键集 $K$ 定义的每个测试用例，我们生成键的所有 $|K|!$ 个排列。这确保了每一种可能的插入顺序都被检查到。Python 中的 `itertools.permutations` 库函数适用于此任务。\n\n2.  **哈希表模拟**：对于每个排列和每个探测方案，我们模拟将键插入到一个大小为 $m$ 的初始为空的哈希表中。哈希表表示为一个数组，初始化为 null 状态（例如 `None`）。对于要插入的每个键：\n    -   我们根据当前方案（线性、二次或双重哈希）的指定公式生成探测序列。探测尝试计数器 $t$ 从 $0$ 开始。\n    -   探测序列为 $p(k, t) = (h(k) + f(t)) \\pmod m$，其中 $f(t)$ 是探测函数：\n        -   线性：$f(t) = t$。\n        -   二次：$f(t) = t + t^2$。\n        -   双重哈希：$f(t) = t \\cdot h_2(k)$，其中 $h_2(k) = 1 + (k \\bmod (m-1))$。\n    -   我们遍历探测序列，计算探测次数，直到找到一个空槽位。然后将键放入此槽位。\n    -   此键的探测次数被加到当前排列的总数中。\n    -   对于二次探测，如果模拟循环完成了 $m$ 次尝试而没有找到空槽位，则该排列的插入被标记为失败，并且根据问题规则，此排列的数据将从二次探测方案中丢弃。\n\n3.  **度量计算**：在成功插入给定排列的所有键后：\n    -   **总探测成本**：这是该排列中所有键的探测次数的累加和。\n    -   **簇签名**：此度量表征了已占用槽位的最终配置。为了计算它，我们首先将表的占用情况表示为二进制序列（例如，1表示占用，0表示空）。为了处理表的循环特性，我们通过循环移位使其从第一个空槽位开始，从而将序列线性化。这不会改变簇的长度或相对位置。然后，我们按空槽位（'0'）分割此线性化序列，并收集得到的连续已占用槽位块（'1's）的长度。对这些长度进行排序以产生规范的簇签名。\n\n4.  **结果聚合**：在遍历所有排列后，我们为每个探测方案聚合结果：\n    -   我们将所有成功排列中遇到的所有唯一簇签名收集到一个集合中，以计算不同签名的数量。\n    -   我们跟踪在所有成功排列中观察到的最小和最大总探测成本。\n\n这个完整的过程将对三个测试用例中的每一个重复进行。最终结果被组装成所需的嵌套列表结构，并格式化为无空格的单行字符串。所提供的Python实现精确地遵循了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Constructs a test harness for open addressing hash tables to analyze the effect\n    of insertion order on clustering and probing cost for linear probing, quadratic\n    probing, and double hashing.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, K)\n        (11, [10, 21, 32, 43, 54]),\n        (13, [0, 13, 26, 39, 1, 14]),\n        (17, [16, 33, 50, 67, 1, 18, 35]),\n    ]\n\n    all_test_results = []\n\n    for m, K in test_cases:\n        \n        case_results = []\n        probe_types = ['linear', 'quadratic', 'double']\n\n        for probe_type in probe_types:\n            signatures = set()\n            min_probes = float('inf')\n            max_probes = float('-inf')\n            successful_perms = 0\n\n            for p in itertools.permutations(K):\n                table = [None] * m\n                total_probes_for_p = 0\n                is_successful = True\n\n                for key in p:\n                    probes_for_key = 0\n                    inserted = False\n                    for t in range(m):\n                        probes_for_key += 1\n                        h_k = key % m\n                        \n                        if probe_type == 'linear':\n                            idx = (h_k + t) % m\n                        elif probe_type == 'quadratic':\n                            # probe function is h(k) + t + t^2\n                            idx = (h_k + t + t**2) % m\n                        else:  # double\n                            h2_k = 1 + (key % (m - 1))\n                            idx = (h_k + t * h2_k) % m\n                        \n                        if table[idx] is None:\n                            table[idx] = key\n                            total_probes_for_p += probes_for_key\n                            inserted = True\n                            break\n                    \n                    if not inserted:\n                        is_successful = False\n                        break\n                \n                if is_successful:\n                    successful_perms += 1\n                    \n                    # Calculate cluster signature\n                    occupied = [1 if slot is not None else 0 for slot in table]\n                    \n                    if all(occ == 1 for occ in occupied):\n                        cluster_lengths = [m]\n                    elif not any(occ == 1 for occ in occupied):\n                        cluster_lengths = []\n                    else:\n                        occupied_str = \"\".join(map(str, occupied))\n                        first_zero_idx = occupied_str.find('0')\n                        # Linearize the cyclic array by breaking at the first empty slot\n                        linearized_str = occupied_str[first_zero_idx:] + occupied_str[:first_zero_idx]\n                        clusters = linearized_str.split('0')\n                        cluster_lengths = sorted([len(c) for c in clusters if c])\n\n                    # Add the immutable tuple representation to the set\n                    signatures.add(tuple(cluster_lengths))\n                    min_probes = min(min_probes, total_probes_for_p)\n                    max_probes = max(max_probes, total_probes_for_p)\n\n            if successful_perms == 0:\n                # Fallback for the case where no permutations succeed.\n                # Per problem description and analysis, this path is not expected to be taken.\n                scheme_results = [0, 0, 0]\n            else:\n                scheme_results = [len(signatures), min_probes, max_probes]\n            \n            case_results.append(scheme_results)\n            \n        all_test_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The output is a string representation of the list, with all whitespace removed.\n    output_str = str(all_test_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在上一节的编码实践中，你很可能观察到双重散列展现出了优越且稳定的性能。本练习将为你提供解释这一现象的理论武器：你将使用期望线性性这一优雅的概率工具，从第一性原理出发推导理想情况下双重散列的性能。这个推导将精确地量化为何双重散列能够有效避免聚集，并保持高效。",
            "id": "3244529",
            "problem": "一个哈希表使用开放寻址法，表的大小为 $m \\geq 2$，包含 $n$ 个已存储的键，因此负载因子为 $\\alpha = n/m$，其中 $0 \\leq \\alpha  1$。该哈希表使用双重哈希：对于键 $k$ 的探测序列为 $j_t(k) \\equiv h_1(k) + t \\cdot h_2(k) \\pmod m$，$t = 0, 1, 2, \\dots$。其中，$h_1(k)$ 在 $\\{0, 1, \\dots, m-1\\}$ 上均匀分布，$h_2(k)$ 与 $h_1(k)$ 独立，在 $\\{1, 2, \\dots, m-1\\}$ 上均匀分布，并且 $\\gcd(h_2(k), m) = 1$。假设采用均匀哈希分析中标准的理想化模型：对于一次不成功的查询（查询的键不在表中），在给定 $n$ 个已占用槽位的集合的条件下，由双重哈希序列导出的探测顺序是 $m$ 个槽位的一个均匀随机排列，且该排列与具体是哪 $n$ 个槽位被占用无关。\n\n仅从均匀随机排列和期望线性的基本定义出发，推导一次不成功搜索所执行的探测次数的期望值（即在探测顺序中遇到的第一个空槽位的期望索引）的精确表达式，该表达式用 $m$ 和 $n$ 表示。然后，在负载因子 $\\alpha \\in (0, 1)$ 固定的情况下，取大表极限 $m \\to \\infty$，并给出仅用 $\\alpha$ 表示的主阶表达式。只需报告最终以 $\\alpha$ 表示的主阶表达式作为你的答案。不需要进行四舍五入。",
            "solution": "该问题要求在均匀哈希假设下，推导开放寻址哈希表中一次不成功搜索的期望探测次数。\n\n首先，我们验证问题陈述的有效性。\n问题提供了一个清晰且自洽的设定。\n已知条件：\n- 表大小：$m \\geq 2$。\n- 已存储键的数量：$n$。\n- 负载因子：$\\alpha = n/m$，其中 $0 \\leq \\alpha  1$。\n- 哈希方案：开放寻址法与双重哈希，由探测序列 $j_t(k) \\equiv h_1(k) + t \\cdot h_2(k) \\pmod m$ 定义。$h_1(k)$ 和 $h_2(k)$ 的性质已明确。\n- 关键建模假设：一次不成功搜索的探测序列是 $m$ 个槽位的一个均匀随机排列。\n\n该问题具有科学依据，因为它处理的是分析哈希算法的标准（尽管是理想化的）模型。问题提法得当、客观，且没有矛盾或含糊之处。因此，问题是有效的，我们继续进行求解。\n\n设 $X$ 是表示不成功搜索探测次数的随机变量。搜索在找到第一个空槽位时终止。在均匀哈希假设下，探测序列是哈希表中 $m$ 个槽位的一个随机排列。在这 $m$ 个槽位中，有 $n$ 个被占用，$m-n$ 个为空。我们的目标是求 $X$ 的期望值，记为 $E[X]$。\n\n直接计算 $E[X] = \\sum_{k=1}^{m-n+1} k \\cdot P(X=k)$ 是可能的，但过程繁琐。一种更简洁、直接的方法是按题目要求使用期望的线性性质。\n\n让我们定义一个相关的随机变量 $Y$，表示在找到第一个空槽位之前检查的已占用槽位数。总探测次数总是比探测到的已占用槽位数多一，所以 $X = Y + 1$。根据期望的线性性质，$E[X] = E[Y+1] = E[Y] + 1$。因此，我们的任务简化为求 $E[Y]$。\n\n为了求 $E[Y]$，我们可以将 $Y$ 表示为一系列指示随机变量的和。设 $n$ 个已占用槽位的集合为 $\\mathcal{O} = \\{O_1, O_2, \\dots, O_n\\}$。对于每个已占用槽位 $O_j \\in \\mathcal{O}$，我们定义一个指示变量 $I_j$ 如下：\n$$\nI_j =\n\\begin{cases}\n1  \\text{如果槽位 } O_j \\text{ 在任何空槽位之前被探测} \\\\\n0  \\text{否则}\n\\end{cases}\n$$\n在探测到第一个空槽位之前探测到的已占用槽位总数是这些指示变量的和：$Y = \\sum_{j=1}^{n} I_j$。\n\n利用期望的线性性质，我们有：\n$$E[Y] = E\\left[\\sum_{j=1}^{n} I_j\\right] = \\sum_{j=1}^{n} E[I_j]$$\n指示变量的期望等于它所指示事件的概率：\n$$E[I_j] = 1 \\cdot P(I_j=1) + 0 \\cdot P(I_j=0) = P(I_j=1)$$\n所以，我们需要计算特定已占用槽位 $O_j$ 在 $m-n$ 个空槽位中任何一个之前被探测的概率。\n\n设空槽位集合为 $\\mathcal{E}$。该集合的大小为 $|\\mathcal{E}| = m-n$。考虑由特定已占用槽位 $O_j$ 和所有空槽位组成的表槽位子集：$S_j = \\{O_j\\} \\cup \\mathcal{E}$。该集合的大小为 $|S_j| = 1 + (m-n) = m-n+1$。\n\n事件 $I_j=1$ 发生当且仅当在探测序列中，槽位 $O_j$ 出现在来自 $\\mathcal{E}$ 的任何槽位之前。均匀哈希假设指出，整个探测序列是 $m$ 个表槽位的一个均匀随机排列。由此直接得出的推论是，任何槽位子集的相对顺序也是均匀随机的。\n因此，如果我们只考虑集合 $S_j$ 中 $m-n+1$ 个槽位的相对顺序，那么其中每个槽位最先出现的概率是相等的。\n\n$O_j$ 是 $S_j$ 中第一个被探测到的槽位的概率是 $\\frac{1}{|S_j|}$。\n$$P(I_j=1) = \\frac{1}{m-n+1}$$\n因为对于所有已占用的槽位 $O_j$（$j=1, \\dots, n$），这个概率是相同的，所以对于所有的 $j$，我们有 $E[I_j] = \\frac{1}{m-n+1}$。\n\n现在我们可以计算 $E[Y]$：\n$$E[Y] = \\sum_{j=1}^{n} E[I_j] = \\sum_{j=1}^{n} \\frac{1}{m-n+1} = \\frac{n}{m-n+1}$$\n最后，我们可以找到期望探测次数 $E[X]$ 的精确表达式：\n$$E[X] = E[Y] + 1 = \\frac{n}{m-n+1} + 1 = \\frac{n + (m-n+1)}{m-n+1} = \\frac{m+1}{m-n+1}$$\n这就是用 $m$ 和 $n$ 表示的一次不成功搜索的期望探测次数的精确表达式。\n\n问题的第二部分要求在表很大的极限情况下（即 $m \\to \\infty$ 且负载因子 $\\alpha = n/m$ 保持不变）求 $E[X]$ 的主阶表达式。\n我们将 $n = \\alpha m$ 代入 $E[X]$ 的精确表达式中：\n$$E[X] = \\frac{m+1}{m - \\alpha m + 1} = \\frac{m+1}{m(1-\\alpha) + 1}$$\n为了找到 $m$ 很大时的行为，我们将分子和分母同时除以 $m$：\n$$E[X] = \\frac{1 + \\frac{1}{m}}{(1-\\alpha) + \\frac{1}{m}}$$\n现在，我们取 $m \\to \\infty$ 的极限。项 $\\frac{1}{m}$ 趋近于 $0$：\n$$\\lim_{m\\to\\infty} E[X] = \\frac{1 + 0}{(1-\\alpha) + 0} = \\frac{1}{1-\\alpha}$$\n这就是用负载因子 $\\alpha$ 表示的一次不成功搜索的期望探测次数的主阶表达式。",
            "answer": "$$\\boxed{\\frac{1}{1-\\alpha}}$$"
        }
    ]
}