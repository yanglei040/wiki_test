{
    "hands_on_practices": [
        {
            "introduction": "哈希（Hashing）是除法和乘法方法最直接、最普遍的应用之一，它将任意大小的键（key）映射到固定大小的哈希表索引上。这个练习不仅仅是简单地实现算法，更重要的是教会你如何验证算法的正确性和探索其内在属性。通过构建一个白盒测试套件，你将亲手检验不同实现在特定条件（例如模数为 $2$ 的幂时）下的一致性，并揭示乘法散列法对参数选择的敏感性，从而深刻理解理论在实践中的细微差别。",
            "id": "3229012",
            "problem": "要求您仅使用核心数学定义，实现、论证并验证两种哈希表的索引策略，这两种策略通常被称为除法散列法和乘法散列法。然后，您必须构建一个白盒测试套件，该套件能生成对抗性和边界输入（包括形式为 $x = 2^k - 1$ 的键和大小为 $m = 2^k$ 的表），并检查在多种独立实现和参数选择下必须保持的不变量。\n\n使用的基本依据：\n- 对于任意整数 $x$ 和 $m$（其中 $m \\ge 1$），$x$ 除以 $m$ 的余数 $r$ 是满足 $0 \\le r \\le m - 1$ 和 $x = q m + r$（对于某个整数 $q$）的唯一整数。\n- 对于任意实数 $y$，定义底函数 $\\lfloor y \\rfloor$ 为小于或等于 $y$ 的最大整数，并定义小数部分 $\\{y\\} = y - \\lfloor y \\rfloor \\in [0, 1)$。\n\n要实现的任务：\n1. 为除法散列法实现一个索引函数，该函数返回 $x$ 模 $m$ 的余数，结果为一个在 $[0, m-1]$ 区间内的整数。以两种代数上等价的方式实现它，并在所有测试输入上验证它们的结果相等：\n   - 使用标准的余数函数。\n   - 使用恒等式 $x - m \\cdot \\left\\lfloor \\dfrac{x}{m} \\right\\rfloor$。\n2. 当 $m$ 是2的幂时，实现第三种位级别的索引函数，该函数仅使用位运算，并且在这种情况下可证明与除法散列法等价。\n3. 为乘法散列法实现一个索引函数，使用一个固定的实数乘数 $A \\in (0, 1)$：仅使用上述定义计算 $\\left\\lfloor m \\cdot \\{x A\\} \\right\\rfloor$。\n\n您的程序必须检查的白盒不变量：\n- 范围安全性：每个计算出的索引必须在 $[0, m-1]$ 区间内。\n- 同一规范的独立实现之间的等价性：当 $m = 2^k$ 时，对于所有测试的 $x$（包括负整数），除法散列法和位级别方法的结果必须一致。\n- 除法下的等差数列稳定性：对于形式为 $x = t m + r$ 的键（其中 $m$ 和 $r$ 固定），除法散列法必须对所有整数 $t$ 返回 $r$。\n- 乘法散列法对 $A$ 选择的敏感性：当使用一个类无理数斜率（例如，$(0, 1)$ 内的一个高质量常数）时，桶计数的分布应接近均匀；当使用有理数斜率（例如 $A = \\dfrac{1}{2}$）且 $m = 2^k$ 时，应只使用少数几个桶。\n\n必需的测试套件。您的程序必须计算一个包含七个布尔值结果的列表，每个结果对应以下一个测试用例及其不变量。请严格使用下面给出的参数值，不要使用随机性。\n\n- 测试 1（2的幂次等价性与范围）：设 $m = 2^{10}$，测试 $\\{0, 1, \\dots, 4095\\}$ 中的所有整数 $x$。验证两种除法散列法的实现以及位运算的实现结果全部相等且在范围内。\n- 测试 2（素数模下的等差数列）：设 $m = 1019$（素数），$r = 57$，对 $t \\in \\{0, 1, \\dots, 999\\}$ 测试 $x = t m + r$。验证两种除法散列法的实现对所有测试的 $x$ 都返回 $r$。\n- 测试 3（2的幂次模下的负数键）：设 $m = 2^8$。测试 $\\{-300, -299, \\dots, 300\\}$ 中的所有 $x$。验证两种除法散列法的实现结果相等，并且位运算的实现对所有测试的 $x$ 都与它们相等。\n- 测试 4（乘法散列法的近似均匀性）：设 $m = 2^{10}$，$A = \\dfrac{\\sqrt{5} - 1}{2}$，并测试 $x \\in \\{0, 1, \\dots, 65535\\}$。计算所有 $m$ 个桶的桶计数。设 $N = 65536$ 并检查谓词 $\\max\\text{count} - \\min\\text{count} \\le \\lceil 4 \\sqrt{N / m} \\rceil$。返回一个布尔值，指示该条件是否成立。\n- 测试 5（有理数斜率的退化检测）：设 $m = 2^{10}$，$A = \\dfrac{1}{2}$，并测试 $x \\in \\{0, 1, \\dots, 4095\\}$。验证恰好使用了 $2$ 个不同的桶。如果检测到这种退化现象，则返回一个为真的布尔值。\n- 测试 6（等差数列上的跨方法对比）：设 $m = 2^{10}$，$A = \\dfrac{\\sqrt{5} - 1}{2}$，固定 $r = 7$，并对 $t \\in \\{0, 1, \\dots, 2047\\}$ 测试 $x = t m + r$。验证除法散列法恰好使用 $1$ 个桶，而乘法散列法至少使用 $900$ 个不同的桶。\n- 测试 7（2的幂次模下的大整数边界条件）：设 $m = 2^{20}$ 并测试 $x \\in \\{2^{61} - 1, 2^{61}, 2^{61} + 1, -(2^{61} - 1), -2^{61}, -(2^{61} + 1)\\}$。验证两种除法散列法的实现和位运算的实现对所有这些 $x$ 的结果都相等。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由七个布尔值组成的逗号分隔列表，并用方括号括起来，不含空格。例如，一个有效的输出看起来像 \"[True,False,True,True,True,True,True]\"，其中每个值是由编程语言的布尔值到字符串转换生成的 \"True\" 或 \"False\"。\n\n不允许用户输入。不允许访问外部文件或网络。所有数值答案均为无单位的实数或整数，不涉及物理单位或角度。七个测试用例的输出必须各自为一个布尔值。",
            "solution": "用户提供的问题陈述已经过仔细分析，并被确定为 **有效**。它在科学上基于算法和数据结构的既定原则，特别是哈希表索引生成。该问题定义明确，所有参数、定义和约束都清晰无误地指定了。它要求实现和验证标准的哈希方法，并通过一个全面、精心设计的测试套件来检验，该套件旨在探究这些方法的基本数学性质和实际行为。\n\n### 基于原则的解决方案设计\n\n该解决方案涉及实现两种主要的哈希策略——除法散列法和乘法散列法——然后对它们进行一系列严格的白盒测试。设计基于所提供的精确数学定义。\n\n#### 1. 除法散列法\n\n除法散列法通过计算键 $x$ 除以表大小 $m$ 的余数来得到哈希索引。在数学上，这表示为 $h(x) = x \\pmod m$。问题要求以三种不同的方式实现此方法，在指定条件下它们必须等价。\n\n**实现1：标准余数**\n该实现使用编程语言提供的原生余数运算符。在 Python 中，`%` 运算符计算余数。对于正模数 $m > 0$，Python 的 `x % m` 对于任何整数 $x$（正数或负数）都能正确产生一个在区间 $[0, m-1]$ 内的结果，这与问题对余数的定义完全匹配：即满足 $x = qm + r$ 和 $0 \\le r  m$ 的唯一整数 $r$。\n\n**实现2：基于底函数的恒等式**\n该实现基于数学恒等式 $x \\pmod m = x - m \\lfloor \\frac{x}{m} \\rfloor$。对于整数算术，这等价于 `x - m * (x // m)`，其中 `//` 是整数的向下取整除法运算符。该公式在数学上与标准余数等价，并且对于所有整数 $x$ 和正整数 $m$ 必须产生相同的结果。\n\n**实现3：针对2的幂次模数的位运算法**\n当表大小 $m$ 是2的幂时，即 $m = 2^k$（对于某个整数 $k \\ge 1$），运算 $x \\pmod m$ 等价于提取 $x$ 的二进制表示的低 $k$ 位。这是因为任何整数 $x$ 都可以写成 $x = q \\cdot 2^k + r$，其中 $r$ 是由低 $k$ 位表示的整数。因此，余数就是 $r$。这种位级别的提取可以通过与一个掩码进行按位与（AND）运算来高效执行。所需的掩码是 $m-1$，其二进制形式是一串 $k$ 个1。因此，哈希索引计算为 $h(x) = x \\text{ \\ } (m-1)$，其中 `` 表示按位与运算符。在使用二进制补码表示法时（这在现代计算架构中是标准），这种等价性对正整数和负整数都成立。\n\n#### 2. 乘法散列法\n\n乘法散列法通过公式 $h(x) = \\lfloor m \\cdot \\{xA\\} \\rfloor$ 计算哈希索引，其中 $A$ 是一个在 $(0, 1)$ 内选择的常数，而 $\\{y\\} = y - \\lfloor y \\rfloor$ 表示实数 $y$ 的小数部分。\n\n**实现与原理**\n该方法的工作原理是首先将整数键 $x$ 映射到一个实数 $xA$。然后，小数部分 $\\{xA\\}$ 提供一个在区间 $[0, 1)$ 内的值，从而有效地打乱了键的值。乘以 $m$ 将此值缩放到范围 $[0, m)$ 内，最后的底函数运算将其映射到 $[0, m-1]$ 内的一个整数索引。\n\n该方法的有效性对 $A$ 的选择高度敏感。\n- 如果 $A$ 是一个小数部分具有“良好”分布特性的无理数（例如，黄金比例的共轭数 $A = \\frac{\\sqrt{5}-1}{2} \\approx 0.618$），则产生的哈希值倾向于在各个桶之间均匀分布。这对于避免冲突是理想的。\n- 如果 $A$ 是一个简单的有理数，例如 $A = \\frac{p}{q}$（其中 $p, q$ 是小整数），该方法可能会表现出退化行为。例如，如果 $A = 1/2$ 且 $m$ 是2的幂，那么将只会产生两个不同的哈希值，导致性能极差。\n\n该实现将使用标准的双精度浮点运算（例如，`numpy.float64`）来表示 $A$ 并执行中间计算。\n\n#### 3. 测试套件和不变量\n\n这七个测试用例旨在验证所实现的哈希函数的正确性和特定属性。\n\n- **测试 1、3 和 7** 是等价性检查。它们确认除法散列法的三种实现对于一系列输入——正整数（测试1）、负整数（测试3）和测试标准定长整数类型极限的大整数（测试7）——都产生相同的结果。这验证了其底层的数学等价性。\n- **测试 2** 验证了模运算的一个基本性质：对于任何等差数列 $x_t = tm+r$，通过除法散列法得到的哈希值始终是常数余数 $r$。这确保了实现的算术健全性。\n- **测试 4** 对乘法散列法的均匀性进行了定量检查。通过选择一个好的常数 $A$ 和一个大的键集合，它测量了桶占用率的分布情况。条件 $\\max(\\text{count}) - \\min(\\text{count}) \\le \\lceil 4 \\sqrt{N / m} \\rceil$ 是一个启发式方法，用以确认分布接近均匀（计数的范围相对于预期的计数标准差是有界的）。\n- **测试 5** 是测试 4 的对立面。它通过使用一个不佳的 A 值（$A=1/2$）和一个2的幂的表大小，展示了乘法散列法的退化情况，验证了这会导致哈希空间灾难性地塌缩到仅两个桶中。\n- **测试 6** 在相同的输入数据（一个等差数列）上对两种方法进行了直接对比。它确认了除法散列法可预测地将所有键映射到单个桶中，而乘法散列法（使用一个好的常数 $A$）则将键广泛地散布在整个哈希表中，突显了它们对输入模式的不同敏感性。\n\n解决方案将是一个独立的 Python 程序，实现这些函数并执行七个测试，按规定生成一个布尔结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates division and multiplication hashing methods.\n    \"\"\"\n\n    # --------------------------------------------------------------------------\n    # HASH FUNCTION IMPLEMENTATIONS\n    # --------------------------------------------------------------------------\n\n    def division_method_mod(x: int, m: int) - int:\n        \"\"\"\n        Computes the hash index using the canonical remainder operator.\n        Corresponds to x mod m.\n        \"\"\"\n        return x % m\n\n    def division_method_floor(x: int, m: int) - int:\n        \"\"\"\n        Computes the hash index using the identity x - m * floor(x/m).\n        \"\"\"\n        if m == 0:\n            raise ValueError(\"Modulus m must be positive.\")\n        return x - m * (x // m)\n\n    def division_method_bitwise(x: int, m: int) - int:\n        \"\"\"\n        Computes the hash index using bitwise AND for m = 2^k.\n        \"\"\"\n        # This implementation assumes m is a power of 2, but the logic\n        # doesn't strictly require a check as it's only used in contexts\n        # where this is guaranteed.\n        return x  (m - 1)\n\n    def multiplication_method(x: int, m: int, A: float) - int:\n        \"\"\"\n        Computes the hash index using the multiplication method:\n        h(x) = floor(m * {x*A}), where {y} = y - floor(y).\n        \"\"\"\n        if m == 0:\n            raise ValueError(\"Table size m must be positive.\")\n        if not (0  A  1):\n            raise ValueError(\"Constant A must be in (0, 1).\")\n        \n        y = x * A\n        # The fractional part {y} is y - floor(y).\n        frac_part = y - np.floor(y)\n        # Final index calculation\n        index = np.floor(m * frac_part)\n        return int(index)\n\n    # --------------------------------------------------------------------------\n    # WHITE-BOX TEST SUITE\n    # --------------------------------------------------------------------------\n\n    def test1() - bool:\n        \"\"\"\n        Test 1: Power-of-two equivalence and range.\n        m = 2^10, x in {0, ..., 4095}.\n        Verify all three division methods are equal and in range.\n        \"\"\"\n        m = 2**10\n        for x in range(4096):\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3 and 0 = h1  m):\n                return False\n        return True\n\n    def test2() - bool:\n        \"\"\"\n        Test 2: Arithmetic progression under prime modulus.\n        m = 1019, r = 57, x = t*m + r for t in {0, ..., 999}.\n        Verify both division methods return r.\n        \"\"\"\n        m = 1019\n        r = 57\n        for t in range(1000):\n            x = t * m + r\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            if not (h1 == r and h2 == r):\n                return False\n        return True\n\n    def test3() - bool:\n        \"\"\"\n        Test 3: Negative keys under power-of-two modulus.\n        m = 2^8, x in {-300, ..., 300}.\n        Verify all three division methods are equal.\n        \"\"\"\n        m = 2**8\n        for x in range(-300, 301):\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3):\n                return False\n        return True\n\n    def test4() - bool:\n        \"\"\"\n        Test 4: Near-uniformity for multiplication method.\n        m = 2^10, A = (sqrt(5)-1)/2, x in {0, ..., 65535}.\n        Check max(counts) - min(counts) = ceil(4 * sqrt(N/m)).\n        \"\"\"\n        m = 2**10\n        A = (np.sqrt(5) - 1) / 2\n        N = 65536\n        counts = np.zeros(m, dtype=int)\n        \n        for x in range(N):\n            h = multiplication_method(x, m, A)\n            if not (0 = h  m): return False # Implicit range safety check\n            counts[h] += 1\n            \n        max_count = np.max(counts)\n        min_count = np.min(counts)\n        bound = np.ceil(4 * np.sqrt(N / m))\n        \n        return (max_count - min_count) = bound\n\n    def test5() - bool:\n        \"\"\"\n        Test 5: Degeneracy detection for rational slope.\n        m = 2^10, A = 1/2, x in {0, ..., 4095}.\n        Verify exactly 2 distinct buckets are used.\n        \"\"\"\n        m = 2**10\n        A = 0.5\n        buckets = set()\n        for x in range(4096):\n            h = multiplication_method(x, m, A)\n            buckets.add(h)\n        return len(buckets) == 2\n\n    def test6() - bool:\n        \"\"\"\n        Test 6: Cross-method contrast on arithmetic progression.\n        m = 2^10, A = (sqrt(5)-1)/2, r = 7, x = t*m + r for t in {0, ..., 2047}.\n        Verify division method uses 1 bucket, multiplication uses = 900.\n        \"\"\"\n        m = 2**10\n        A = (np.sqrt(5) - 1) / 2\n        r = 7\n        div_buckets = set()\n        mul_buckets = set()\n\n        for t in range(2048):\n            x = t * m + r\n            h_div = division_method_mod(x, m)\n            h_mul = multiplication_method(x, m, A)\n            div_buckets.add(h_div)\n            mul_buckets.add(h_mul)\n            \n        return len(div_buckets) == 1 and len(mul_buckets) = 900\n\n    def test7() - bool:\n        \"\"\"\n        Test 7: Large-integer boundary conditions.\n        m = 2^20, test specific large integers around 2^61.\n        Verify equality of all three division methods.\n        \"\"\"\n        m = 2**20\n        p = 2**61\n        keys = [p - 1, p, p + 1, -(p - 1), -p, -(p + 1)]\n        \n        for x in keys:\n            h1 = division_method_mod(x, m)\n            h2 = division_method_floor(x, m)\n            h3 = division_method_bitwise(x, m)\n            if not (h1 == h2 == h3):\n                return False\n        return True\n\n    # --------------------------------------------------------------------------\n    # EXECUTION\n    # --------------------------------------------------------------------------\n    \n    test_functions = [test1, test2, test3, test4, test5, test6, test7]\n    results = [func() for func in test_functions]\n    \n    # Format the final output string as specified: [True,False,...] without spaces.\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们从处理单个数字转向处理像矩阵这样的复杂结构时，乘法的计算成本会急剧增加。Strassen 算法是分治策略的一个经典范例，它巧妙地减少了子问题的乘法次数，从而在理论上优于传统的 $O(n^3)$ 矩阵乘法。这个实践练习将带你超越简单的渐进符号分析，通过建立一个包含实现开销的精细成本模型，来确定 Strassen 算法在真实世界中超越传统算法的性能交叉点 $n$。这对于任何有志于性能工程领域的学习者来说，都是一项至关重要的技能。",
            "id": "3229040",
            "problem": "给定两种方阵乘法算法：标准的立方时间算法和由 Volker Strassen 提出的分治算法。您的任务是，针对一个特定的机器模型，在考虑所有相关开销的情况下，确定 Strassen 算法比标准 $O(n^3)$ 算法更快的最小矩阵维度 $n$（如果存在）。答案必须通过一个完整、可运行的程序得出，该程序评估该机器模型并报告每个给定测试用例的最小交叉点 $n$。\n\n请从以下基本依据和广泛接受的事实出发：\n- 在乘以两个 $n \\times n$ 矩阵的标准算法中，若忽略循环开销，则恰好有 $n^3$ 个标量乘加对和 $n^2$ 次对输出矩阵的标量写入。将乘加对的成本与标量加法的成本分开处理，并假设有可用的融合乘加原语，其每对操作具有一个时间常数。\n- Strassen 算法将每个输入矩阵划分为四个维度近似为 $\\lceil n/2 \\rceil \\times \\lceil n/2 \\rceil$ 的子矩阵，对该缩减维度执行 $7$ 个矩阵乘法子问题，并使用 $18$ 次维度近似为 $\\lceil n/2 \\rceil \\times \\lceil n/2 \\rceil$ 的矩阵加法或减法来形成中间结果和最终分块。对于非偶数的 $n$，一种标准方法是概念上将其填充至下一个偶数维度，并使用向上取整来计算工作量。\n- 真实机器上的时间成本来自标量算术、内存流量（加载、存储以及打包或复制）以及每次调用或递归节点的固定开销。这些成本以加法方式组合，我们假设它们分别与标量操作的数量或移动元素的数量成线性关系。\n\n您必须基于以上基础推导出算法成本表达式，并阐明每种算法的结构如何导向其总时间（作为 $n$ 和机器常数的函数）。然后，您将实现这些成本计算，并搜索使得 Strassen 算法成本小于或等于经典算法成本的最小 $n$。如果在指定的搜索上限 $N_{\\max}$ 内不存在交叉点，您必须为该测试用例报告 $-1$。\n\n所有时间常数均以纳秒/标量操作或纳秒/次调用的形式给出。将 $n$ 报告为无量纲整数。输出中不需要其他物理单位。\n\n实现要求：\n- 令 $T_{\\text{classic}}(n)$ 表示标准算法的成本，其每次操作的常数在测试用例中提供。使用 $n^3$ 次乘加对和为生成并写入输出所必须发生的 $n^2$ 次内存流量对其进行建模。\n- 令 $T_{\\text{strassen}}(n)$ 表示 Strassen 算法的成本，其递归用 $7$ 个大小为 $\\lceil n/2 \\rceil$ 的子问题替换一个大小为 $n$ 的问题，并加上矩阵加/减法、打包或复制的成本，以及每个递归节点的固定开销。当低于给定的基础阈值 $b$（每个测试用例指定）时，Strassen 例程应切换到基础乘法例程，其每次操作的常数可能与顶层经典算法的不同，以反映一个经过优化的内核。\n- 对于非偶数的 $n$，使用 $\\lceil n/2 \\rceil$ 来确定子问题的维度，并以 $\\lceil n/2 \\rceil \\times \\lceil n/2 \\rceil$ 的粒度计算矩阵加法和打包的次数。您可以假设填充是概念性的，且成本与接触到的标量元素数量成正比。\n- 使用记忆化（memoization）来避免对重复的 $n$ 重新计算 $T_{\\text{strassen}}(n)$，并从 $1$ 搜索到 $N_{\\max}$（含）以找到最小的交叉点（如果存在）。\n- 最终输出必须是一行，其中包含所有测试用例的答案，形式为逗号分隔的列表并用方括号括起来，例如 $[n_1,n_2,n_3]$。\n\n测试套件：\n为以下 $4$ 个机器模型和配置参数提供答案。每个案例提供：\n- $t^{\\text{classic}}_{\\text{fma}}$: 标准算法中每次标量融合乘加对的纳秒数。\n- $t^{\\text{classic}}_{\\text{mem}}$: 标准算法中每个标量元素的内存流量纳秒数，按 $n^2$ 缩放。\n- $t^{\\text{classic}}_{\\text{setup}}$: 标准算法中每次顶层乘法调用的固定纳秒数。\n- $t^{\\text{base}}_{\\text{fma}}$: Strassen 例程使用其基础乘法内核时，每次标量融合乘加对的纳秒数。\n- $t^{\\text{base}}_{\\text{mem}}$: 基础内核中每个标量元素的内存流量纳秒数，按 $n^2$ 缩放。\n- $t^{\\text{base}}_{\\text{setup}}$: 每次基础内核调用的固定纳秒数。\n- $t_{\\text{add}}$: 每次标量矩阵加法或减法的纳秒数。\n- $t_{\\text{pack}}$: 在 Strassen 算法的开销中，每个打包或复制的标量元素的纳秒数。\n- $f_{\\text{pack}}$: 一个无量纲因子，乘以 $\\lceil n/2 \\rceil^2$ 个元素，用于为每个递归节点的总打包或临时移动量建模。\n- $t_{\\text{call}}$: 每个 Strassen 递归节点的固定开销纳秒数。\n- $b$: 基础阈值；当 $n \\le b$ 时，Strassen 例程使用基础内核。\n- $N_{\\max}$: 搜索交叉点的最大维度。\n\n案例 A（均衡开销）：\n- $t^{\\text{classic}}_{\\text{fma}} = 1.1$, $t^{\\text{classic}}_{\\text{mem}} = 0.06$, $t^{\\text{classic}}_{\\text{setup}} = 200000$。\n- $t^{\\text{base}}_{\\text{fma}} = 0.9$, $t^{\\text{base}}_{\\text{mem}} = 0.08$, $t^{\\text{base}}_{\\text{setup}} = 250000$。\n- $t_{\\text{add}} = 0.35$, $t_{\\text{pack}} = 0.07$, $f_{\\text{pack}} = 12.0$, $t_{\\text{call}} = 4000$。\n- $b = 64$, $N_{\\max} = 2048$。\n\n案例 B（高 Strassen 开销，不利情况）：\n- $t^{\\text{classic}}_{\\text{fma}} = 1.0$, $t^{\\text{classic}}_{\\text{mem}} = 0.05$, $t^{\\text{classic}}_{\\text{setup}} = 50000$。\n- $t^{\\text{base}}_{\\text{fma}} = 1.0$, $t^{\\text{base}}_{\\text{mem}} = 0.1$, $t^{\\text{base}}_{\\text{setup}} = 200000$。\n- $t_{\\text{add}} = 0.6$, $t_{\\text{pack}} = 0.2$, $f_{\\text{pack}} = 16.0$, $t_{\\text{call}} = 20000$。\n- $b = 64$, $N_{\\max} = 2048$。\n\n案例 C（对 Strassen 有利）：\n- $t^{\\text{classic}}_{\\text{fma}} = 1.5$, $t^{\\text{classic}}_{\\text{mem}} = 0.08$, $t^{\\text{classic}}_{\\text{setup}} = 300000$。\n- $t^{\\text{base}}_{\\text{fma}} = 0.7$, $t^{\\text{base}}_{\\text{mem}} = 0.06$, $t^{\\text{base}}_{\\text{setup}} = 150000$。\n- $t_{\\text{add}} = 0.25$, $t_{\\text{pack}} = 0.05$, $f_{\\text{pack}} = 8.0$, $t_{\\text{call}} = 1000$。\n- $b = 32$, $N_{\\max} = 1024$。\n\n案例 D（大基础阈值）：\n- $t^{\\text{classic}}_{\\text{fma}} = 1.2$, $t^{\\text{classic}}_{\\text{mem}} = 0.05$, $t^{\\text{classic}}_{\\text{setup}} = 100000$。\n- $t^{\\text{base}}_{\\text{fma}} = 0.95$, $t^{\\text{base}}_{\\text{mem}} = 0.07$, $t^{\\text{base}}_{\\text{setup}} = 120000$。\n- $t_{\\text{add}} = 0.3$, $t_{\\text{pack}} = 0.06$, $f_{\\text{pack}} = 10.0$, $t_{\\text{call}} = 5000$。\n- $b = 128$, $N_{\\max} = 4096$。\n\n您的程序应生成单行输出，其中包含四个交叉点，按 A、B、C、D 的顺序以逗号分隔的列表形式用方括号括起来，例如 $[n_A,n_B,n_C,n_D]$。如果某个案例在 $N_{\\max}$ 内没有交叉点，则在该位置打印 $-1$。不应打印任何额外的文本或行。",
            "solution": "用户提供了有效的问题陈述。我将继续进行解答。\n\n### 问题验证\n\n该问题旨在基于一个详细的成本模型，确定标准立方时间矩阵乘法算法与 Strassen 分治算法之间的性能交叉点。\n\n**1. 提取的已知条件：**\n问题为三种成本模型提供了定义和参数：\n- $T_{\\text{classic}}(n)$: 标准 $n \\times n$ 矩阵乘法的时间。\n- $T_{\\text{base}}(n)$: 优化的基础情形乘法内核的时间。\n- $T_{\\text{strassen}}(n)$: Strassen 递归算法的时间。\n\n成本函数依赖于为四个不同测试用例（A、B、C、D）提供的一组参数：\n- $t^{\\text{classic}}_{\\text{fma}}$, $t^{\\text{classic}}_{\\text{mem}}$, $t^{\\text{classic}}_{\\text{setup}}$: 标准算法的融合乘加（FMA）操作、内存流量和设置开销的时间常数。\n- $t^{\\text{base}}_{\\text{fma}}$, $t^{\\text{base}}_{\\text{mem}}$, $t^{\\text{base}}_{\\text{setup}}$: Strassen 算法用于小矩阵的基础情形内核的时间常数。\n- $t_{\\text{add}}$: Strassen 算法开销中每次标量加/减法的时间。\n- $t_{\\text{pack}}$, $f_{\\text{pack}}$: Strassen 算法开销中每个打包/复制的标量元素的时间和一个用于总数据移动量的无量纲因子。\n- $t_{\\text{call}}$: Strassen 算法中每次递归调用的固定开销。\n- $b$: Strassen 算法切换到基础情形内核的维度阈值（小于等于该值时切换）。\n- $N_{\\max}$: 搜索交叉点的最大矩阵维度。\n\n目标是找到最小的整数 $n \\in [1, N_{\\max}]$，使得 $T_{\\text{strassen}}(n) \\le T_{\\text{classic}}(n)$。\n\n**2. 验证结论：**\n此问题是 **有效** 的。它在科学上基于算法分析和性能建模的原理。问题提法得当，目标明确，并提供了所有必要的数据。定义精确客观，可以得出一个唯一、可验证的解。该问题不违反任何无效标准。\n\n### 算法成本模型\n\n为了找到交叉点，我们首先将每种算法的成本函数形式化为矩阵维度 $n$ 和给定时间常数的函数。\n\n**1. 标准算法成本：$T_{\\text{classic}}(n)$**\n乘以两个 $n \\times n$ 矩阵的标准算法涉及 $n^3$ 次标量乘法和加法，这些被建模为融合乘加（FMA）对。此外，结果矩阵的 $n^2$ 个元素必须被写入内存。还包括一个固定的设置成本。总时间 $T_{\\text{classic}}(n)$ 是这些部分的总和：\n$$T_{\\text{classic}}(n) = t^{\\text{classic}}_{\\text{fma}} \\cdot n^3 + t^{\\text{classic}}_{\\text{mem}} \\cdot n^2 + t^{\\text{classic}}_{\\text{setup}}$$\n其中 $t^{\\text{classic}}_{\\text{fma}}$ 是每次 FMA 的时间， $t^{\\text{classic}}_{\\text{mem}}$ 是每个写入元素的时间， $t^{\\text{classic}}_{\\text{setup}}$ 是每次调用的固定设置成本。\n\n**2. 基础情形内核成本：$T_{\\text{base}}(n)$**\nStrassen 算法对大小为 $n \\le b$ 的子问题利用一个标准的乘法内核。该内核的成本结构与经典算法相同，但可能具有不同的性能常数，以反映一个更专门化的实现。\n$$T_{\\text{base}}(n) = t^{\\text{base}}_{\\text{fma}} \\cdot n^3 + t^{\\text{base}}_{\\text{mem}} \\cdot n^2 + t^{\\text{base}}_{\\text{setup}}$$\n\n**3. Strassen 算法成本：$T_{\\text{strassen}}(n)$**\nStrassen 算法是递归的。其成本 $T_{\\text{strassen}}(n)$ 由一个递推关系定义。对于非偶数维度，子问题的大小取为 $m = \\lceil n/2 \\rceil$。\n\n- **基础情形 ($n \\le b$)：** 如果维度 $n$ 小于或等于阈值 $b$，算法将切换到基础情形内核。\n$$T_{\\text{strassen}}(n) = T_{\\text{base}}(n), \\quad \\text{for } n \\le b$$\n\n- **递归步骤 ($n  b$)：** 对于大于 $b$ 的维度，算法将矩阵划分为大小为 $m = \\lceil n/2 \\rceil$ 的分块并执行：\n    1.  $7$ 次大小为 $m \\times m$ 的递归矩阵乘法。\n    2.  $18$ 次在大小为 $m \\times m$ 的矩阵上的矩阵加法或减法。\n每个递归步骤的开销包括这些加/减法、为临时矩阵进行数据打包/复制的成本，以及一个固定的每次调用开销。总开销成本 $O_{\\text{strassen}}(n)$ 为：\n$$O_{\\text{strassen}}(n) = 18 \\cdot m^2 \\cdot t_{\\text{add}} + f_{\\text{pack}} \\cdot m^2 \\cdot t_{\\text{pack}} + t_{\\text{call}}$$\n对于 $n  b$ 的完整递推关系是：\n$$T_{\\text{strassen}}(n) = 7 \\cdot T_{\\text{strassen}}(\\lceil n/2 \\rceil) + O_{\\text{strassen}}(n)$$\n\n### 求解方法\n\n为找到每个测试用例的交叉点，我们实现了推导出的成本函数并执行线性搜索。\n1.  对每组参数，我们定义函数来计算 $T_{\\text{classic}}(n)$ 和 $T_{\\text{strassen}}(n)$。\n2.  $T_{\\text{strassen}}(n)$ 的函数以递归方式实现。为避免重复计算相同子问题大小的成本，我们使用记忆化（在计算每个 $n$ 的 $T_{\\text{strassen}}(n)$ 时缓存其结果）。\n3.  我们从 1 开始迭代矩阵维度 $n$，直到指定的上限 $N_{\\max}$。\n4.  在每次迭代中，我们计算 $T_{\\text{classic}}(n)$ 和 $T_{\\text{strassen}}(n)$。\n5.  第一个满足条件 $T_{\\text{strassen}}(n) \\le T_{\\text{classic}}(n)$ 的 $n$ 值即为交叉点。记录该值，并终止对该测试用例的搜索。\n6.  如果循环完成仍未找到这样的 $n$，则意味着在搜索限制内没有发生交叉。在这种情况下，我们根据问题规范报告 $-1$。\n7.  收集所有测试用例的最终结果，并格式化为单行输出。\n\n以下程序实现了此方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the crossover point for Strassen's vs. standard matrix multiplication\n    for a series of machine models.\n    \"\"\"\n\n    class CrossoverFinder:\n        \"\"\"\n        Encapsulates the logic and parameters for finding the crossover point\n        for a single machine model.\n        \"\"\"\n        def __init__(self, params):\n            \"\"\"\n            Initializes the finder with a dictionary of parameters for one test case.\n            \n            Args:\n                params (dict): A dictionary containing all time constants and limits.\n            \"\"\"\n            self.p = params\n            self.memo = {}\n\n        def t_classic(self, n):\n            \"\"\"\n            Calculates the cost of the standard cubic-time matrix multiplication.\n            \n            T_classic(n) = t_fma_c * n^3 + t_mem_c * n^2 + t_setup_c\n            \"\"\"\n            return self.p['t_fma_c'] * n**3 + \\\n                   self.p['t_mem_c'] * n**2 + \\\n                   self.p['t_setup_c']\n\n        def t_base(self, n):\n            \"\"\"\n            Calculates the cost of the base-case kernel used by Strassen's algorithm.\n            \n            T_base(n) = t_fma_b * n^3 + t_mem_b * n^2 + t_setup_b\n            \"\"\"\n            return self.p['t_fma_b'] * n**3 + \\\n                   self.p['t_mem_b'] * n**2 + \\\n                   self.p['t_setup_b']\n        \n        def t_strassen(self, n):\n            \"\"\"\n            Calculates the cost of Strassen's algorithm recursively with memoization.\n            \"\"\"\n            if n in self.memo:\n                return self.memo[n]\n            \n            # Base case: if n = b, use the tuned base kernel.\n            if n = self.p['b']:\n                result = self.t_base(n)\n                self.memo[n] = result\n                return result\n            \n            # Recursive step\n            m = int(np.ceil(n / 2))\n            \n            # Overhead at this recursion level: 18 matrix additions/subtractions,\n            # data packing, and a fixed call overhead.\n            overhead = (18 * m**2 * self.p['t_add'] +\n                        self.p['f_pack'] * m**2 * self.p['t_pack'] +\n                        self.p['t_call'])\n            \n            # Recurrence relation: T(n) = 7*T(n/2) + Overhead(n)\n            result = 7 * self.t_strassen(m) + overhead\n            \n            self.memo[n] = result\n            return result\n\n        def find_crossover(self):\n            \"\"\"\n            Searches for the smallest integer n where Strassen's is faster.\n            \"\"\"\n            for n in range(1, self.p['N_max'] + 1):\n                cost_classic = self.t_classic(n)\n                cost_strassen = self.t_strassen(n)\n                \n                if cost_strassen = cost_classic:\n                    return n\n            \n            return -1\n\n    test_cases = [\n        # Case A: balanced overhead\n        {'t_fma_c': 1.1, 't_mem_c': 0.06, 't_setup_c': 200000,\n         't_fma_b': 0.9, 't_mem_b': 0.08, 't_setup_b': 250000,\n         't_add': 0.35, 't_pack': 0.07, 'f_pack': 12.0, 't_call': 4000,\n         'b': 64, 'N_max': 2048},\n        # Case B: high Strassen overhead, unfavorable\n        {'t_fma_c': 1.0, 't_mem_c': 0.05, 't_setup_c': 50000,\n         't_fma_b': 1.0, 't_mem_b': 0.1, 't_setup_b': 200000,\n         't_add': 0.6, 't_pack': 0.2, 'f_pack': 16.0, 't_call': 20000,\n         'b': 64, 'N_max': 2048},\n        # Case C: favorable to Strassen\n        {'t_fma_c': 1.5, 't_mem_c': 0.08, 't_setup_c': 300000,\n         't_fma_b': 0.7, 't_mem_b': 0.06, 't_setup_b': 150000,\n         't_add': 0.25, 't_pack': 0.05, 'f_pack': 8.0, 't_call': 1000,\n         'b': 32, 'N_max': 1024},\n        # Case D: large base threshold\n        {'t_fma_c': 1.2, 't_mem_c': 0.05, 't_setup_c': 100000,\n         't_fma_b': 0.95, 't_mem_b': 0.07, 't_setup_b': 120000,\n         't_add': 0.3, 't_pack': 0.06, 'f_pack': 10.0, 't_call': 5000,\n         'b': 128, 'N_max': 4096}\n    ]\n\n    results = []\n    for params in test_cases:\n        finder = CrossoverFinder(params)\n        crossover_point = finder.find_crossover()\n        results.append(crossover_point)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "分治思想不仅适用于复杂数据结构，在数论计算中同样威力巨大，尤其是在处理大数运算时。本练习旨在解决一个经典问题：计算大数阶乘对素数的模 $n! \\pmod p$。当 $n$ 非常大时，朴素的迭代连乘将变得不可行。我们将采用一种称为“乘积树”（product tree）的分治策略，它将连乘任务分解为平衡的子问题，从而高效地完成计算。这个练习不仅能锻炼你的算法设计能力，还能加深你对模运算和高效算术的理解。",
            "id": "3229157",
            "problem": "要求您设计并实现一个程序，使用分治乘法策略计算阶乘对素数取模。给定非负整数 $n$ 和素数模 $p$，目标是利用快速乘法和乘积树式的分治递归，高效地计算 $n! \\bmod p$ 的值，即使在 $n$ 非常大的情况下也能如此。\n\n设计中需要使用并论证的基础原理：\n- 阶乘的定义：对于整数 $n \\ge 0$， $n! = \\prod_{k=1}^{n} k$，并约定 $0! = 1$。\n- 整数模 $p$ 环中的基本性质：对于素数 $p$，模乘法满足结合律和交换律，并且模 $p$ 约简与乘法兼容，即 $(ab) \\bmod p = \\big((a \\bmod p)(b \\bmod p)\\big) \\bmod p$。\n- 关于整除性的基本观察：如果 $n \\ge p$ 且 $p$ 是素数，那么 $p$ 整除 $n!$，因此 $n! \\equiv 0 \\pmod p$。\n- 平衡的分治乘法通过配对子乘积来保持操作数大小的平衡，从而降低了计算成本，这与快速整数乘法相辅相成。\n\n您的算法任务：\n- 对于输入 $(n, p)$（其中 $p$ 为素数），计算 $n! \\bmod p$。\n- 如果 $n \\ge p$，则根据上述整除性事实直接输出 $0$。\n- 否则，使用分治的区间乘积递归计算乘积 $\\prod_{k=1}^{n} k$ 对 $p$ 取模，该递归将 $[1,n]$ 分成大致相等的两半，将子乘积对 $p$ 取模相乘，并递归直到单个元素。\n\n您的实现约束：\n- 程序必须是一个完整、可运行的程序，在不读取任何输入的情况下，评估以下测试套件并按指定格式打印结果。\n\n测试套件（每个测试用例是一对 $(n, p)$，其中 $p$ 是素数）：\n- 用例 1：$(n, p) = (0, 101)$。\n- 用例 2：$(n, p) = (1, 101)$。\n- 用例 3：$(n, p) = (20, 101)$。\n- 用例 4：$(n, p) = (100, 101)$。\n- 用例 5：$(n, p) = (200, 193)$。\n- 用例 6：$(n, p) = (65536, 65537)$。\n\n所有答案都是整数。不涉及物理单位。不适用角度。不适用百分比。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件相同，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是用例 $i$ 的整数结果。",
            "solution": "对用户提供的问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n- **目标**：计算非负整数 $n$ 和素数模 $p$ 的 $n! \\pmod{p}$。\n- **方法论**：采用分治乘法策略，也称为乘积树。\n- **基本定义与性质**：\n    - 阶乘：对于 $n \\ge 1$， $n! = \\prod_{k=1}^{n} k$；以及 $0! = 1$。\n    - 模算术： $(ab) \\bmod p = \\big((a \\bmod p)(b \\bmod p)\\big) \\bmod p$。\n    - 整除性规则：如果 $n \\ge p$ 且 $p$ 是素数，那么 $p$ 是 $n!$ 的一个因子，这意味着 $n! \\equiv 0 \\pmod{p}$。\n- **算法说明**：\n    - 如果 $n \\ge p$，结果为 $0$。\n    - 如果 $n  p$，则需使用一个将乘法范围 $[1, n]$ 分成两个平衡子范围的递归函数，计算 $\\prod_{k=1}^{n} k$ 对 $p$ 取模。\n- **测试套件**：\n    - 用例 1：$(n, p) = (0, 101)$\n    - 用例 2：$(n, p) = (1, 101)$\n    - 用例 3：$(n, p) = (20, 101)$\n    - 用例 4：$(n, p) = (100, 101)$\n    - 用例 5：$(n, p) = (200, 193)$\n    - 用例 6：$(n, p) = (65536, 65537)$\n- **输出格式**：单行文本：`[r_1,r_2,r_3,r_4,r_5,r_6]`。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题进行评估。\n- **科学依据**：该问题基于数论（模算术、素数性质、阶乘）和计算机科学（分治算法）的基本且正确的原理。提供的素数 $101$、$193$ 和 $65537$（一个费马素数，$F_4$）确实是素数。这些原理并非推测性的。\n- **适定性**：问题是适定的。对于任何有效的输入 $(n, p)$，量 $n! \\pmod{p}$ 是一个唯一的、明确定义的整数。所描述的算法是确定性的，并能得出唯一的解。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观断言。\n- **缺陷分析**：\n    1.  **科学或事实上的不健全**：无。前提在事实上和数学上都是健全的。\n    2.  **不可形式化或不相关**：无。该问题是算法数论中的一个标准练习，可直接形式化。\n    3.  **不完整或矛盾的设置**：无。所有必要的数据、定义和约束都已提供且自洽。\n    4.  **不切实际或不可行**：无。计算完全在标准现代计算机的能力范围之内。\n    5.  **不适定或结构不良**：无。问题结构清晰，并指导采用一种特定、有效的算法方法。\n    6.  **伪深刻、琐碎或同义反复**：无。虽然一些测试用例很简单，但一般性问题和所需的方法并非微不足道。$(65536, 65537)$ 的用例展示了对于大输入，高效算法相比朴素迭代方法的效用。\n    7.  **超出科学可验证性**：无。结果在数学上是可验证的。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原则的解决方案设计\n\n问题是计算一个非负整数 $n$ 的阶乘对一个素数 $p$ 取模，记作 $n! \\pmod{p}$。\n\n首先，我们处理特殊情况。根据定义，$0! = 1$。因此，对于 $n=0$，对于任何模数 $p > 1$，结果都是 $1$。\n\n数论中的一个关键观察简化了许多输入的问题。阶乘 $n!$ 是所有小于等于 $n$ 的正整数的乘积：$n! = 1 \\cdot 2 \\cdot \\dots \\cdot p \\cdot \\dots \\cdot n$。如果 $n \\ge p$，那么素数 $p$ 本身就是这个乘积中的一个因子。因此，$n!$ 可以被 $p$ 整除，用模算术的语言来说就是 $n! \\equiv 0 \\pmod{p}$。这提供了一个我们的算法必须优先执行的高效检查。\n\n更复杂的情况出现在 $n  p$ 时。在这种情况下，整数 $1, 2, \\dots, n$ 中没有一个能被素数 $p$ 整除。因此，它们的乘积 $n!$ 也不能被 $p$ 整除，并且 $n! \\not\\equiv 0 \\pmod{p}$。我们必须计算这个乘积。朴素的迭代乘法虽然正确，但可能效率低下。问题要求使用分治策略，我们将对此进行形式化。\n\n我们定义一个函数 $P(a, b)$，它计算一个范围内的整数乘积：\n$$\nP(a, b) = \\prod_{k=a}^{b} k = a \\cdot (a+1) \\cdot \\dots \\cdot b\n$$\n我们的目标是计算 $P(1, n) \\pmod{p}$。分治方法基于将范围 $[a, b]$ 分成两个子范围。我们选择一个中点 $m = \\lfloor(a+b)/2\\rfloor$。然后乘积可以表示为：\n$$\nP(a, b) = \\left( \\prod_{k=a}^{m} k \\right) \\cdot \\left( \\prod_{k=m+1}^{b} k \\right) = P(a, m) \\cdot P(m+1, b)\n$$\n这个恒等式允许进行递归定义。为了计算 $P(a, b)$，我们递归地计算子范围 $P(a, m)$ 和 $P(m+1, b)$ 的乘积，然后将结果相乘。\n\n至关重要的是，我们关心的是对 $p$ 取模的结果。模算术的性质表明，取模运算可以在乘法上分配：$(X \\cdot Y) \\pmod p = \\big( (X \\pmod p) \\cdot (Y \\pmod p) \\big) \\pmod p$。我们在递归的每一步都应用这个原理，以防止中间数变得过大。模乘积的递归关系是：\n$$\nP(a, b) \\pmod{p} = \\left( \\big(P(a, m) \\pmod{p}\\big) \\cdot \\big(P(m+1, b) \\pmod{p}\\big) \\right) \\pmod{p}\n$$\n递归需要基准情况来终止。当范围 $[a, b]$ 只包含一个元素时，即 $a=b$，乘积就是 $a$。如果范围为空，$a > b$，乘积是乘法单位元，即 $1$。\n\n这种递归结构，通常称为“乘积树”，将 $n-1$ 次乘法组织成一个深度为 $O(\\log n)$ 的平衡二叉树。虽然总乘法次数仍为 $O(n)$，但当使用用于极大整数乘法的高级算法（例如 Karatsuba、Toom-Cook 或基于 FFT 的方法）时，这种结构特别有利，因为它倾向于平衡操作数的大小，从而最大化这些次二次算法的效率。Python 内置的任意精度整数支持可能在内部利用了此类方法。\n\n让我们分析两个重要的测试用例：\n1.  **用例 4：$(n, p) = (100, 101)$**。这里，我们计算 $(p-1)! \\pmod{p}$。威尔逊定理是初等数论的基石，它指出对于任何素数 $p$，都成立 $(p-1)! \\equiv -1 \\pmod{p}$。因此，对于 $p=101$，我们期望 $100! \\equiv -1 \\equiv 100 \\pmod{101}$。\n2.  **用例 6：$(n, p) = (65536, 65537)$**。这是威尔逊定理在更大规模上的另一个实例。模数 $p = 65537$ 是费马素数 $F_4 = 2^{(2^4)} + 1$。我们被要求计算 $(p-1)! \\pmod{p}$。结果必须是 $-1 \\equiv 65536 \\pmod{65537}$。我们的分治算法将通过大约 $65535$ 次模乘法得到这个结果，这些乘法组织在一个深度为 $\\log_2(65536) = 16$ 的递归树中。\n\n最终的算法如下：\n1.  定义一个主函数 `factorial_mod_p(n, p)`。\n2.  如果 $n=0$，返回 $1$。\n3.  如果 $n \\ge p$，返回 $0$。\n4.  否则，调用一个递归辅助函数 `product_range(1, n, p)`。\n5.  `product_range(a, b, p)` 函数实现分治逻辑：\n    - 基准情况：如果 $a > b$，返回 $1$。如果 $a=b$，返回 $a$。\n    - 递归步骤：计算 $m = (a+b)//2$，递归调用 `product_range(a, m, p)` 和 `product_range(m+1, b, p)`，将结果相乘，并对 $p$ 取模。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Computes n! mod p for a set of test cases using a divide-and-conquer\n    multiplication strategy.\n    \"\"\"\n    # Set a higher recursion limit for potentially deep recursions,\n    # although the test cases here do not require it.\n    # The deepest recursion for n=65536 is log2(65536) = 16.\n    sys.setrecursionlimit(2000)\n\n    # The recursive helper function to compute the product of a range modulo p.\n    def _product_range_recursive(a: int, b: int, p: int) - int:\n        \"\"\"\n        Computes (a * (a+1) * ... * b) mod p using a recursive divide-and-conquer\n        approach.\n        \"\"\"\n        # Base case for empty product.\n        if a  b:\n            return 1\n        \n        # Base case for a single-element product.\n        if a == b:\n            return a\n        \n        # Optimization for a small range to reduce recursion overhead.\n        if b - a  4:\n            res = 1\n            for i in range(a, b + 1):\n                res = res * i\n            return res % p\n\n        # Recursive step: split the range, compute sub-products, and combine.\n        mid = (a + b) // 2\n        \n        left_product = _product_range_recursive(a, mid, p)\n        right_product = _product_range_recursive(mid + 1, b, p)\n        \n        return (left_product * right_product) % p\n\n    # The main function to compute n! mod p.\n    def factorial_mod_p(n: int, p: int) - int:\n        \"\"\"\n        Computes n! mod p, handling the special cases and invoking the\n        recursive product function.\n        \"\"\"\n        # By convention, 0! = 1.\n        if n == 0:\n            return 1\n        \n        # If n = p, then n! is divisible by p, so n! === 0 (mod p).\n        if n = p:\n            return 0\n        \n        # For 0  n  p, compute the product 1 * 2 * ... * n mod p.\n        return _product_range_recursive(1, n, p)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 101),     # Case 1\n        (1, 101),     # Case 2\n        (20, 101),    # Case 3\n        (100, 101),   # Case 4\n        (200, 193),   # Case 5\n        (65536, 65537) # Case 6\n    ]\n\n    results = []\n    for n, p in test_cases:\n        result = factorial_mod_p(n, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}