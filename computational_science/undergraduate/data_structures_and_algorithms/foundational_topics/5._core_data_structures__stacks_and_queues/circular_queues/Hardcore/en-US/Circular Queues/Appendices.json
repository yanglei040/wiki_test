{
    "hands_on_practices": [
        {
            "introduction": "To truly master a data structure, you must first understand its internal organization. This exercise challenges you to look \"under the hood\" of a circular queue by implementing a \"peek-ahead\" function. By translating the logical order of elements into their physical positions within the backing array, you will solidify your understanding of the core index mapping that makes a circular queue work .",
            "id": "3221146",
            "problem": "You are given the formal definition of an array-backed circular queue. A circular queue of capacity $C$ is represented by an array $A$ of length $C$, a front index $f$ that identifies the position of the element to be dequeued next, and a size $s$ equal to the current number of elements stored. The rear index $r$ is derived from the invariant $r \\equiv (f + s) \\bmod C$, and all indices always lie in the set $\\{0, 1, \\dots, C-1\\}$. The queue supports the operations enqueue and dequeue subject to the invariants that $0 \\le s \\le C$, that enqueue is defined only when $s \\lt C$, and that dequeue is defined only when $s \\gt 0$. The conceptual queue order is the sequence of elements starting at the logical front and proceeding in the order of future dequeues, independent of the specific arrangement within the array $A$.\n\nDesign and implement a function that, given such a circular queue, returns the next $k$ elements in the conceptual dequeue order without removing any elements from the queue. The function must run in time $\\mathcal{O}(k)$, use constant extra workspace beyond the output list (that is, excluding the space needed to store the returned elements), and must not mutate the queue’s state. If $k$ exceeds the number of available elements $s$, the function must return the longest prefix of length $\\min(k, s)$; if $k = 0$ or the queue is empty ($s = 0$), the function must return the empty list.\n\nImplement your solution as a complete, runnable program that constructs several circular queues and, for each, applies the function to specified values of $k$. Use the following test suite, which covers a general case, wrap-around behavior, boundary conditions, and edge cases:\n\n- Test case $1$: capacity $C = 7$, perform enqueue of the elements $10$, $20$, $30$, $40$; then apply the function with $k = 3$.\n- Test case $2$: capacity $C = 5$, perform enqueue of the elements $1$, $2$, $3$, $4$; perform dequeue three times; perform enqueue of the elements $5$, $6$, $7$; then apply the function with $k = 4$.\n- Test case $3$: capacity $C = 6$, perform enqueue of the elements $9$, $8$; then apply the function with $k = 0$.\n- Test case $4$: capacity $C = 8$, perform enqueue of the elements $100$, $200$, $300$; then apply the function with $k = 3$.\n- Test case $5$: capacity $C = 6$, perform enqueue of the elements $5$, $15$; then apply the function with $k = 5$.\n- Test case $6$: capacity $C = 4$, with no enqueues; apply the function with $k = 2$.\n- Test case $7$: capacity $C = 4$, perform enqueue of the elements $7$, $8$, $9$, $10$; then apply the function with $k = 2$.\n- Test case $8$: capacity $C = 3$, perform enqueue of the elements $1$, $2$, $3$; perform dequeue two times; perform enqueue of the elements $4$, $5$; then apply the function with $k = 3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry itself being the list of elements returned for the corresponding test case, for example $[r_1, r_2, \\dots, r_8]$ where each $r_i$ is a list.",
            "solution": "The problem of designing a function to preview the next $k$ elements of a circular queue without mutation is a well-posed and standard task in data structure implementation. The provided definition of the circular queue is formally sound, using a state representation based on an array $A$ of capacity $C$, a front index $f$, and a size $s$.\n\nThe fundamental principle for solving this problem lies in the mapping between the conceptual order of elements in the queue and their physical positions within the backing array $A$. The conceptual order is the sequence in which elements would be dequeued. The first element to be dequeued is at index $f$ in the array. The second element is at the next physical position, which, due to the circular nature of the queue, is $(f+1) \\pmod C$. Generalizing this, the $i$-th element in the conceptual dequeue order (for $i=0, 1, 2, \\dots, s-1$) is stored at the physical array index given by the expression:\n$$\n\\text{physical\\_index}(i) = (f + i) \\pmod C\n$$\nThis relationship holds for all elements currently in the queue, from the front ($i=0$) to the logical rear ($i=s-1$), and correctly handles the wrap-around behavior where the queue's elements cross the boundary between the end and the beginning of the array.\n\nThe task is to design a function that returns the next $k$ elements in this conceptual order. The function must not alter the queue's state variables ($f$, $s$) or the contents of the array $A$. It must execute in $\\mathcal{O}(k)$ time and use $\\mathcal{O}(1)$ additional memory, excluding the storage for the output list.\n\nThe algorithm can be designed directly from the index mapping principle:\n\n1.  **Determine the Number of Elements to Return**: The problem specifies that if $k$ exceeds the number of available elements $s$, the function should return all available elements. If $k=0$ or the queue is empty ($s=0$), it should return an empty list. This can be unified by calculating the number of elements to return, let's call it $n_{peek}$, as:\n    $$\n    n_{peek} = \\min(k, s)\n    $$\n    This expression correctly yields $s$ when $k  s$, $k$ when $k \\le s$, and $0$ if either $k=0$ or $s=0$.\n\n2.  **Iterate and Collect Elements**: If $n_{peek}  0$, we proceed to collect the elements. We can iterate $n_{peek}$ times, with a loop index $i$ running from $0$ to $n_{peek}-1$. In each iteration, $i$ represents the position in the conceptual dequeue order.\n\n3.  **Calculate Physical Index**: For each value of $i$, we use the core mapping formula to find the physical index $j$ in the array $A$ where the element resides:\n    $$\n    j = (f + i) \\pmod C\n    $$\n\n4.  **Access and Store**: The element at $A[j]$ is accessed and appended to a result list. This operation is purely a read operation and does not mutate the queue's state.\n\n5.  **Return Result**: After the loop completes, the result list contains the first $n_{peek}$ elements in the conceptual order and is returned.\n\nThis algorithm satisfies all the given constraints:\n-   **No Mutation**: The algorithm only reads from the queue's internal state ($f$, $s$, and $A$) and does not perform any write operations. The queue's state remains unchanged.\n-   **Time Complexity**: The main work is a single loop that runs $n_{peek} = \\min(k, s)$ times. Since $s$ can be at most $C$, and $k$ is the input parameter, the number of iterations is bounded by $k$. Each step inside the loop (index calculation, array access, list append) takes constant time, $\\mathcal{O}(1)$. Therefore, the total time complexity is $\\mathcal{O}(\\min(k, s))$, which is consistent with the required $\\mathcal{O}(k)$.\n-   **Space Complexity**: The algorithm uses a few variables for the loop counter and index calculation, which consumes $\\mathcal{O}(1)$ space. The space for the returned list is explicitly excluded from this constraint. Thus, the extra workspace requirement is met.\n\nThe implementation will consist of a class representing the circular queue with methods for `enqueue`, `dequeue`, and the required function to peek at the next $k$ elements, followed by a main routine to execute the specified test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An array-backed circular queue.\n    \"\"\"\n    def __init__(self, capacity: int):\n        if capacity  1:\n            raise ValueError(\"Capacity must be a positive integer.\")\n        self._capacity = capacity\n        # Use dtype=object to store any Python object, including integers.\n        self._data = np.empty(capacity, dtype=object)\n        self._front = 0\n        self._size = 0\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the rear of the queue.\"\"\"\n        if self._size == self._capacity:\n            raise OverflowError(\"Queue is full\")\n        \n        # The rear index is derived from front and size.\n        rear_index = (self._front + self._size) % self._capacity\n        self._data[rear_index] = element\n        self._size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the front element of the queue.\"\"\"\n        if self._size == 0:\n            raise IndexError(\"Dequeue from an empty queue\")\n        \n        element = self._data[self._front]\n        self._data[self._front] = None # Optional: clear the dequeued slot\n        self._front = (self._front + 1) % self._capacity\n        self._size -= 1\n        return element\n\n    def peek_k(self, k: int):\n        \"\"\"\n        Returns the next k elements in the conceptual dequeue order\n        without mutating the queue.\n        \"\"\"\n        num_to_peek = min(k, self._size)\n        if num_to_peek = 0:\n            return []\n        \n        result = []\n        for i in range(num_to_peek):\n            # The i-th element (0-indexed) in conceptual order is at\n            # physical index (front + i) % capacity.\n            physical_index = (self._front + i) % self._capacity\n            result.append(self._data[physical_index])\n            \n        return result\n\ndef solve():\n    \"\"\"\n    Constructs and tests circular queues as per the problem statement.\n    \"\"\"\n    # Test suite definition: (capacity, list_of_operations, k)\n    # Operations: ('e', value) for enqueue, ('d',) for dequeue\n    test_cases = [\n        # Test case 1\n        (7, [('e', 10), ('e', 20), ('e', 30), ('e', 40)], 3),\n        # Test case 2\n        (5, [('e', 1), ('e', 2), ('e', 3), ('e', 4), ('d',), ('d',), ('d',), ('e', 5), ('e', 6), ('e', 7)], 4),\n        # Test case 3\n        (6, [('e', 9), ('e', 8)], 0),\n        # Test case 4\n        (8, [('e', 100), ('e', 200), ('e', 300)], 3),\n        # Test case 5\n        (6, [('e', 5), ('e', 15)], 5),\n        # Test case 6\n        (4, [], 2),\n        # Test case 7\n        (4, [('e', 7), ('e', 8), ('e', 9), ('e', 10)], 2),\n        # Test case 8\n        (3, [('e', 1), ('e', 2), ('e', 3), ('d',), ('d',), ('e', 4), ('e', 5)], 3),\n    ]\n\n    results = []\n    for capacity, operations, k_val in test_cases:\n        queue = CircularQueue(capacity)\n        for op in operations:\n            if op[0] == 'e':\n                queue.enqueue(op[1])\n            elif op[0] == 'd':\n                queue.dequeue()\n        \n        peek_result = queue.peek_k(k_val)\n        results.append(peek_result)\n\n    # The final print statement must produce the specified single-line format.\n    # The default str() for a list includes spaces, which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```"
        },
        {
            "introduction": "Building on the ability to navigate the queue's structure, the next step is to manipulate it efficiently. This practice requires you to reverse the queue's elements directly within the circular array without using significant extra storage . Successfully solving this requires a precise application of index mapping for both reading and writing, demonstrating a deeper command over in-place algorithms on circular buffers.",
            "id": "3221166",
            "problem": "You are given the definition of a circular queue implemented over a fixed-length array. A circular queue is a First-In-First-Out (FIFO) data structure whose contents are maintained in a ring using modular arithmetic. Let the backing array be of capacity $N$, and let the queue's active segment be specified by a head index $H$ and a length $K$. The active element at logical position $i$ (where $0 \\le i \\le K-1$) resides at physical index $(H+i) \\bmod N$. Positions in the array not covered by these $K$ active indices are unused and irrelevant to the logical sequence of the queue.\n\nStarting from the fundamental definition that the logical order of elements in a circular queue is governed by the mapping $i \\mapsto (H+i) \\bmod N$, design an algorithm that reverses the $K$ active elements of the circular queue in-place, using only $O(1)$ additional space, without changing $H$, $K$, or $N$. You must reason from first principles of modular arithmetic and the queue's definition to ensure correctness for all valid parameter values, including boundary cases. The algorithm must run in time $O(K)$ and use at most a constant number of auxiliary variables, independent of $N$ and $K$.\n\nYour program must implement this reversal on the following test suite. Each test case provides concrete values for $N$, $A$, $H$, and $K$, where $A$ is the array content and only the $K$ active positions are to be reversed. After reversal, for each test case, output the logical sequence of the $K$ active elements in order from head to tail as a list of integers.\n\nTest suite:\n- Case $1$: $N=8$, $H=3$, $K=5$, $A=[0,0,0,10,20,30,40,50]$.\n- Case $2$: $N=7$, $H=5$, $K=4$, $A=[3,4,0,0,0,1,2]$.\n- Case $3$: $N=5$, $H=2$, $K=0$, $A=[9,8,7,6,5]$.\n- Case $4$: $N=6$, $H=4$, $K=1$, $A=[0,0,0,0,99,0]$.\n- Case $5$: $N=6$, $H=2$, $K=6$, $A=[11,12,7,8,9,10]$.\n- Case $6$: $N=1$, $H=0$, $K=1$, $A=[42]$.\n\nConstraints:\n- $N$ is an integer with $N \\ge 1$.\n- $H$ is an integer with $0 \\le H \\le N-1$.\n- $K$ is an integer with $0 \\le K \\le N$.\n- $A$ is a list of length $N$; only indices $(H+i) \\bmod N$ for $i \\in \\{0,1,\\dots,K-1\\}$ constitute the active queue contents.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_j$ is itself the list of the $K$ active elements after reversal for the $j$-th test case. There must be no spaces anywhere in the output line. Each $result_j$ is a list of integers. For example, a possible output might look like $[[2,1],[],[9]]$, where $[]$ denotes the empty list. In your output, use $[]$ for the empty list.",
            "solution": "We begin from the core definition of a circular queue over an array of capacity $N$. The logical sequence of $K$ active elements is determined by the mapping\n$$\n\\text{phys}(i) = (H + i) \\bmod N,\\quad \\text{for } i \\in \\{0,1,\\dots,K-1\\}.\n$$\nReversing the logical sequence means that the element at logical position $i$ must be swapped with the element at logical position $(K-1-i)$ for all $i$ in the first half of the sequence. In a standard array reversal, this is achieved by symmetric swaps around the center, and the same principle applies here when indices are interpreted modulo $N$.\n\nPrinciple-based derivation:\n1. The queue’s logical order is fully determined by $H$, $K$, and $N$ via modular arithmetic. To reverse the sequence without changing the representation parameters ($H$, $K$, $N$), we must only permute the values stored at the physical indices corresponding to the active range.\n2. Define a bijection between logical positions and physical positions:\n   $$\n   f(i) = (H+i) \\bmod N,\\quad i \\in \\{0,1,\\dots,K-1\\}.\n   $$\n   This function is injective over the specified domain because $N \\ge 1$ and the domain size is $K \\le N$. The codomain positions are distinct modulo $N$.\n3. Reversal requires transforming sequence $\\langle a_0,a_1,\\dots,a_{K-1} \\rangle$ into $\\langle a_{K-1},\\dots,a_1,a_0 \\rangle$. This can be realized by performing, for each $i$ from $0$ to $\\left\\lfloor\\frac{K}{2}\\right\\rfloor - 1$, the swap\n   $$\n   \\text{swap}\\left(A[f(i)],\\ A[f(K-1-i)]\\right).\n   $$\n   The number of such swaps is $\\left\\lfloor\\frac{K}{2}\\right\\rfloor$, and each swap uses constant additional space (a single temporary variable).\n4. Correctness argument:\n   - For each pair $(i, K-1-i)$, the swap places $a_{K-1-i}$ at physical index $f(i)$ and $a_i$ at physical index $f(K-1-i)$.\n   - Because indices $i$ cover exactly the first half of $\\{0,\\dots,K-1\\}$ and $K-1-i$ cover exactly the second half, after all swaps, the sequence is reversed.\n   - No inactive indices are touched because $f(i)$ is only computed for $i$ in $[0, K-1]$.\n   - The parameters $H$, $K$, $N$ are unchanged, preserving the queue’s representation, and the logical order is now reversed.\n5. Complexity:\n   - Time: The algorithm performs $\\left\\lfloor\\frac{K}{2}\\right\\rfloor$ swaps and $O(1)$ work per swap, so the overall time is $O(K)$.\n   - Space: Apart from a constant number of variables (loop counter, two indices, and a temporary variable for swapping), no additional storage is used, hence $O(1)$ space.\n6. Boundary conditions:\n   - If $K=0$, the loop does not execute, leaving the array unchanged, and the output is the empty list $[]$.\n   - If $K=1$, the loop does not execute, so the single element remains unchanged.\n   - If $K=N$, all positions $\\{0,1,\\dots,N-1\\}$ are active, and the same procedure applies with indices wrapping correctly due to the modulo operation.\n   - Wrap-around cases are handled naturally because $f(i)$ uses $(H+i) \\bmod N$, ensuring that consecutive logical positions map to correct physical positions across array boundaries.\n\nImplementation details for output:\n- After performing the reversal, the logical sequence for output is reconstructed by reading $A[(H+i) \\bmod N]$ for $i=0,1,\\dots,K-1$.\n- For the provided test suite, each result is a list of integers. The program aggregates all six results into a single list and prints it in the specified format with no spaces, ensuring strict adherence to the output requirements.\n\nThis approach follows directly from the foundational mapping between logical positions and modular physical indices and uses the well-tested sequence reversal technique adapted to circular indexing, yielding the required in-place $O(1)$ space reversal with $O(K)$ time complexity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Imported as allowed; not strictly required by the solution.\n\ndef reverse_circular_queue_in_place(A, N, H, K):\n    \"\"\"\n    Reverse the K active elements of a circular queue in-place.\n    Active logical positions i in [0, K-1] map to physical indices (H+i) % N.\n    The reversal maintains H, K, and N unchanged.\n    \"\"\"\n    # Handle trivial cases gracefully.\n    if K = 1:\n        return  # Nothing to do\n\n    # Perform symmetric swaps using modular arithmetic.\n    half = K // 2\n    for i in range(half):\n        left_idx = (H + i) % N\n        right_idx = (H + (K - 1 - i)) % N\n        # Swap A[left_idx] and A[right_idx]\n        A[left_idx], A[right_idx] = A[right_idx], A[left_idx]\n\n\ndef linearize_active(A, N, H, K):\n    \"\"\"\n    Return the logical sequence of active elements as a list:\n    [A[(H+0)%N], A[(H+1)%N], ..., A[(H+K-1)%N]]\n    \"\"\"\n    return [A[(H + i) % N] for i in range(K)]\n\n\ndef format_list_no_spaces(lst):\n    \"\"\"\n    Format a Python list (of ints) as a string without spaces, e.g., [1,2,3].\n    \"\"\"\n    return \"[\" + \",\".join(str(x) for x in lst) + \"]\"\n\n\ndef format_list_of_lists_no_spaces(list_of_lists):\n    \"\"\"\n    Format a list of lists (each inner list contains ints) without spaces.\n    Example: [[1,2],[3],[ ]] -> \"[[1,2],[3],[]]\"\n    \"\"\"\n    inner = \",\".join(format_list_no_spaces(inner_lst) for inner_lst in list_of_lists)\n    return \"[\" + inner + \"]\"\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (N, A, H, K)\n    test_cases = [\n        (8, [0, 0, 0, 10, 20, 30, 40, 50], 3, 5),   # Case 1\n        (7, [3, 4, 0, 0, 0, 1, 2], 5, 4),           # Case 2\n        (5, [9, 8, 7, 6, 5], 2, 0),                 # Case 3 (empty)\n        (6, [0, 0, 0, 0, 99, 0], 4, 1),             # Case 4 (single element)\n        (6, [11, 12, 7, 8, 9, 10], 2, 6),           # Case 5 (full queue)\n        (1, [42], 0, 1),                            # Case 6 (degenerate capacity)\n    ]\n\n    results = []\n    for N, A, H, K in test_cases:\n        # Reverse the active elements in place.\n        reverse_circular_queue_in_place(A, N, H, K)\n        # Collect the logical sequence after reversal.\n        linearized = linearize_active(A, N, H, K)\n        results.append(linearized)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_of_lists_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice showcases how the abstract properties of a circular queue can model and solve complex dynamic processes. By simulating the famous Josephus problem, you will leverage the queue's ability to efficiently rotate elements to solve a classic computational puzzle . This exercise moves beyond simple data storage to highlight the practical power of circular queues in algorithmic simulations.",
            "id": "3221203",
            "problem": "Design and implement a complete program that simulates the Josephus elimination process using a circular queue as the sole data structure to manage the circle of people. The circle initially contains $n$ distinct people labeled $1$ through $n$. Counting begins at a specified starting label $s$. On each elimination round, you count forward through the circle; the person who is the $k$-th counted is eliminated from the circle. The process continues until exactly one person remains, who is the survivor.\n\nUse the following foundational basis and definitions:\n- A queue is an abstract data type with the First-In First-Out (FIFO) property. In the FIFO rule, the element that entered earliest is the element that leaves first.\n- A circular queue is a bounded-capacity array-backed queue with two indices, $front$ and $rear$, and a size counter. Adding at $rear$ and removing from $front$ update indices modulo the capacity. Formally, if the capacity is $C$, then incrementing an index $i$ is performed by $i \\leftarrow (i + 1) \\bmod C$.\n- Rotation of the circle by one position is implemented by removing the current $front$ element and immediately adding it at the $rear$; this preserves relative order and advances the counting position by one without changing the set of elements.\n\nImplement the following operations on the circular queue and use them to simulate the Josephus process:\n- Initialize an empty circular queue of capacity $n$.\n- Enqueue all labels from $1$ to $n$ in increasing order.\n- Align the starting label $s$ by rotating the queue exactly $s-1$ times so that the $front$ equals $s$.\n- Repeat until one element remains:\n  1. Rotate the queue by exactly $k-1$ positions. Use modulo arithmetic to avoid redundant full cycles: if the current size is $m$, rotating by $r$ positions is equivalent to rotating by $(r \\bmod m)$ positions.\n  2. Dequeue the $front$ element; this is the eliminated person for the round.\n- Report the elimination order as a list and the final survivor as an integer.\n\nYour program must produce results for the following test suite, where each test case is provided as a triple $\\langle n,k,s \\rangle$:\n- Test $1$: $\\langle 7,3,1 \\rangle$.\n- Test $2$: $\\langle 5,2,1 \\rangle$.\n- Test $3$: $\\langle 10,1,1 \\rangle$.\n- Test $4$: $\\langle 1,5,1 \\rangle$.\n- Test $5$: $\\langle 6,7,2 \\rangle$.\n- Test $6$: $\\langle 8,100,4 \\rangle$.\n\nFor each test case, your program must compute and return a list consisting of two items: the elimination order (as a list of integers) and the survivor (as a single integer). Aggregate the results for all test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets. Concretely, the final output must be of the form\n$$\n[\\,[\\text{elim\\_order}_1,\\text{survivor}_1],\\,[\\text{elim\\_order}_2,\\text{survivor}_2],\\,\\dots\\,]\n$$\nwhere each $\\text{elim\\_order}_i$ is a list of integers and each $\\text{survivor}_i$ is an integer. No physical units or angles are involved; all outputs are purely integers and lists of integers.",
            "solution": "The problem requires a simulation of the Josephus elimination process using a purpose-built circular queue. The solution will be structured in two main parts: a class implementing the circular queue as specified, and a function that uses this class to run the simulation for given parameters $n$, $k$, and $s$.\n\nFirst, we design the `CircularQueue` class. It will be backed by a NumPy array of a fixed capacity, as this is efficient for storing a homogeneous collection of integer labels. The state of the queue is managed by three attributes: `front`, an index pointing to the first element; `rear`, an index pointing to the next available slot for an element; and `size`, the current number of elements in the queue. All index manipulations will use modulo arithmetic with respect to the queue's capacity, ensuring the circular behavior. The core operations are `enqueue` (add to rear), `dequeue` (remove from front), and `get_size`.\n\nSecond, we design the simulation function, `josephus_simulation(n, k, s)`. This function orchestrates the entire process as outlined in the problem statement.\n1.  **Initialization**: Given $n$, a `CircularQueue` of capacity $n$ is created. The people, represented by their integer labels from $1$ to $n$, are enqueued in order.\n2.  **Starting Alignment**: The count must begin at person $s$. The initial queue has person $1$ at the front. To bring person $s$ to the front, we must rotate the queue $s-1$ times. A rotation is precisely defined as a `dequeue` operation followed by an `enqueue` of the same element. This moves the front element to the back of the queue, advancing the line.\n3.  **Elimination Loop**: The core of the simulation is a loop that continues as long as the number of people in the queue is greater than $1$. In each iteration of the loop:\n    a. The current number of people, $m$, is obtained from the queue's size.\n    b. To find the $k$-th person to eliminate, we must advance the count $k-1$ positions from the current front. This is accomplished by rotating the queue $k-1$ times. The problem correctly notes that for a circle of size $m$, rotating $r$ times is equivalent to rotating $r \\pmod m$ times. Thus, we perform $(k-1) \\pmod m$ rotations.\n    c. After the rotations, the person at the `front` of the queue is the $k$-th person in the count. This person is eliminated by performing a `dequeue` operation. The dequeued label is appended to an `elimination_order` list.\n4.  **Termination**: The loop terminates when only one person remains in the queue. This last person is the survivor. They are removed from the queue via a final `dequeue` operation.\n5.  **Result**: The function returns a list containing the `elimination_order` list and the single integer `survivor`.\n\nThis structured approach directly maps the problem's formal specification into a concrete algorithm, ensuring correctness and adherence to all constraints. The use of a custom `CircularQueue` class is central to meeting the problem's requirements.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An array-backed circular queue with fixed capacity, front and rear pointers,\n    and a size counter, as specified in the problem.\n    \"\"\"\n    def __init__(self, capacity: int):\n        if capacity  0:\n            raise ValueError(\"Capacity cannot be negative\")\n        self.capacity = capacity\n        # Using np.zeros of dtype=int for the underlying array\n        self.data = np.zeros(capacity, dtype=int)\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\n    def is_empty(self) - bool:\n        \"\"\"Returns True if the queue is empty.\"\"\"\n        return self.size == 0\n\n    def is_full(self) - bool:\n        \"\"\"Returns True if the queue is full.\"\"\"\n        return self.size == self.capacity\n\n    def enqueue(self, item: int):\n        \"\"\"Adds an item to the rear of the queue.\"\"\"\n        if self.is_full():\n            # This condition should not be met in the context of this problem\n            # as the queue size only decreases after initial setup.\n            raise OverflowError(\"Queue is full\")\n        self.data[self.rear] = item\n        self.rear = (self.rear + 1) % self.capacity\n        self.size += 1\n\n    def dequeue(self) - int:\n        \"\"\"Removes and returns the item from the front of the queue.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Dequeue from an empty queue\")\n        item = self.data[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return int(item)\n\n    def get_size(self) - int:\n        \"\"\"Returns the current number of items in the queue.\"\"\"\n        return self.size\n\ndef josephus_simulation(n: int, k: int, s: int) - list:\n    \"\"\"\n    Simulates the Josephus problem using a circular queue.\n\n    Args:\n        n: The total number of people.\n        k: The counting step for elimination.\n        s: The starting label for the count.\n\n    Returns:\n        A list containing two elements:\n        1. A list of the eliminated people in order.\n        2. The integer label of the survivor.\n    \"\"\"\n    if n = 0:\n        # Based on problem \"1 through n\", n must be >= 1.\n        # This handles the degenerate case, returning an empty result.\n        return [[], None]\n\n    # Step 1  2: Initialize queue and enqueue all people\n    q = CircularQueue(n)\n    for i in range(1, n + 1):\n        q.enqueue(i)\n\n    # Step 3: Align the queue so the starting person 's' is at the front.\n    # This requires s-1 rotations.\n    for _ in range(s - 1):\n        q.enqueue(q.dequeue())\n\n    elimination_order = []\n    \n    # Step 4: Elimination loop\n    while q.get_size() > 1:\n        current_size = q.get_size()\n        \n        # Determine number of rotations to get to the k-th person.\n        # This is k-1 steps. Use modulo for efficiency.\n        rotations = (k - 1) % current_size\n        \n        # Rotate the queue to bring the k-th person to the front\n        for _ in range(rotations):\n            q.enqueue(q.dequeue())\n            \n        # Dequeue the front element (the one to be eliminated)\n        eliminated = q.dequeue()\n        elimination_order.append(eliminated)\n\n    # Step 5: The last person remaining is the survivor\n    survivor = None\n    if not q.is_empty():\n        survivor = q.dequeue()\n\n    return [elimination_order, survivor]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (7, 3, 1),\n        (5, 2, 1),\n        (10, 1, 1),\n        (1, 5, 1),\n        (6, 7, 2),\n        (8, 100, 4),\n    ]\n\n    results = []\n    for n, k, s in test_cases:\n        result = josephus_simulation(n, k, s)\n        results.append(result)\n\n    # The final print must match the specified format. Using map(str,...)\n    # on lists will generate representations with spaces (e.g., '[1, 2]'),\n    # which is the standard Python behavior and implied by the template.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}