{
    "hands_on_practices": [
        {
            "introduction": "动态内存分配的核心挑战在于如何选择一个合适的空闲内存块来满足分配请求。首次适应（First-Fit）和最佳适应（Best-Fit）是两种基础且经典的分配策略，它们在算法复杂度和内存使用效率之间做出了不同的权衡。通过模拟这两种策略，你将亲手实现并量化它们的性能差异，从而深刻理解不同分配算法对系统碎片化的影响。",
            "id": "3251611",
            "problem": "考虑一个由非负整数容量序列 $S = (s_1, s_2, \\dots, s_n)$ 表示的有限货架集合，以及一个由非负整数尺寸序列 $P = (p_1, p_2, \\dots, p_m)$ 表示的托盘序列。每个货架最多只能容纳一个托盘。一个尺寸为 $p_j$ 的托盘可以放入一个容量为 $s_i$ 的货架中，当且仅当 $s_i \\ge p_j$。一旦一个托盘被放入一个货架，该货架就对任何其他托盘不可用。将托盘 $p_j$ 放入货架 $s_i$ 所产生的内部碎片定义为 $s_i - p_j$。如果没有容量至少为 $p_j$ 的可用货架，则托盘 $p_j$ 的分配失败。\n\n需要比较两种分配策略：\n\n- 首次适应 (First-fit)：对于序列中的每个托盘 $p_j$（$j = 1, 2, \\dots, m$），按递增的索引顺序 $i = 1, 2, \\dots, n$ 扫描货架，并将 $p_j$ 放入第一个满足 $s_i \\ge p_j$ 的可用货架中。\n- 最佳适应 (Best-fit)：对于序列中的每个托盘 $p_j$（$j = 1, 2, \\dots, m$），在所有满足 $s_i \\ge p_j$ 的可用货架中，选择容量 $s_i$ 最小的那个货架；如果容量最小的货架不止一个，则选择索引最小的那个。\n\n从序列处理和确定性选择规则的核心定义出发，且不假设任何已有的专门公式，请推导出一个程序化模拟。对于每个给定的测试用例，该模拟需在相同的输入 $(S, P)$ 上执行这两种策略，并报告每种策略的以下整数指标：\n- 成功分配的托盘数量，记为 $A$。\n- 分配失败的次数，记为 $F$。\n- 总内部碎片，记为 $W$，计算方法为对该策略下所有已分配的配对求和 $\\sum (s_i - p_j)$。\n\n您的程序必须严格按照定义实现这两种策略，其中最佳适应策略在出现多个最小容量相等的货架时，选择索引最小的货架作为平局决胜规则。最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，按顺序 $[A_{\\text{FF}}, F_{\\text{FF}}, W_{\\text{FF}}, A_{\\text{BF}}, F_{\\text{BF}}, W_{\\text{BF}}]$ 追加六个整数，其中下标 $\\text{FF}$ 和 $\\text{BF}$ 分别代表首次适应和最佳适应策略。将所有测试用例的结果连接成一个扁平列表，并保持测试用例的原始顺序。\n\n请使用以下测试套件，其旨在探究分配行为的不同方面：\n- 测试用例 1：$S = [9,8,10]$，$P = [8,10,9]$ （因货架顺序以及平局决胜规则导致策略差异）。\n- 测试用例 2：$S = [5,5,5]$，$P = [5,5,5,5]$ （精确匹配且托盘多于货架的边界情况）。\n- 测试用例 3：$S = [4,4]$，$P = [5,6]$ （所有托盘尺寸都过大）。\n- 测试用例 4：$S = [12,3]$，$P = []$ （托盘序列为空）。\n- 测试用例 5：$S = [5,9,6]$，$P = [6,5,9]$ （因未来可能的精确匹配导致策略差异）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，整数需严格按照指定顺序排列，且不含任何额外文本。",
            "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个定义明确的模拟任务，该任务植根于计算机科学的基本概念，特别是确定性资源分配算法。该问题是自包含的、逻辑一致且无歧义的。\n\n此问题的核心是模拟两种不同的内存分配策略——首次适应和最佳适应，并将其应用于一组离散的资源（货架）和请求（托盘）。我们将为每个模拟过程正式推导其步骤，然后实现这些步骤以计算所需的性能指标。\n\n设货架容量集合由序列 $S = (s_1, s_2, \\dots, s_n)$ 表示，其中 $n$ 是货架数量，$s_i \\in \\mathbb{Z}_{\\ge 0}$ 是第 $i$ 个货架的容量。设托盘尺寸集合为序列 $P = (p_1, p_2, \\dots, p_m)$，其中 $m$ 是托盘数量，$p_j \\in \\mathbb{Z}_{\\ge 0}$ 是第 $j$ 个托盘的尺寸。\n\n系统的状态可以通过一个布尔可用性向量 $U = (u_1, u_2, \\dots, u_n)$ 来跟踪，其中如果货架 $i$ 可用，则 $u_i = 1$，如果已被占用，则 $u_i = 0$。初始时，所有货架都可用，因此对于所有 $i \\in \\{1, 2, \\dots, n\\}$，都有 $u_i = 1$。\n\n对于每种策略，我们将按给定顺序处理托盘，从 $j=1$ 到 $m$。需要为每种策略计算的指标是：\n- $A$：成功分配的托盘总数。\n- $F$：分配失败的总次数。\n- $W$：总内部碎片，定义为所有已分配配对 $(p_j, s_{i^*})$ 的 $(s_{i^*} - p_j)$ 之和，即 $W = \\sum (s_{i^*} - p_j)$。\n\n**1. 首次适应 (FF) 策略**\n\n首次适应算法是一种顺序搜索启发式方法。对于每个托盘 $p_j$，我们从第一个货架到最后一个货架依次扫描，并将托盘放入第一个足够大的货架中。\n\n算法按以下步骤对每个 $j \\in \\{1, 2, \\dots, m\\}$ 进行：\n- 初始化一个标志，`placed_j = false`。\n- 遍历索引从 $1$ 到 $n$ 的货架。\n- 对于每个货架 $i$，检查两个条件：\n    1. 货架可用：$u_i = 1$。\n    2. 货架容量充足：$s_i \\ge p_j$。\n- 如果两个条件都满足，这就是首次适应。我们执行分配：\n    - 将此货架指定为选定的货架：$i^* = i$。\n    - 通过将该货架标记为已占用来更新系统状态：$u_{i^*} \\leftarrow 0$。\n    - 增加已分配托盘计数：$A \\leftarrow A + 1$。\n    - 将产生的内部碎片加到总和中：$W \\leftarrow W + (s_{i^*} - p_j)$。\n    - 设置 `placed_j = true` 并中断关于 $i$ 的内层循环，继续处理下一个托盘 $p_{j+1}$。\n- 如果对所有货架 $i$ 的循环完成，而 `placed_j` 仍然是 `false`，则表示没有找到合适的货架。托盘 $p_j$ 的分配失败。\n- 增加失败计数：$F \\leftarrow F + 1$。\n\n对所有托盘重复此过程。模拟的初始状态为 $A=0$，$F=0$，$W=0$，且对所有 $i$ 都有 $u_i=1$。\n\n**2. 最佳适应 (BF) 策略**\n\n最佳适应算法试图更有效地利用空间。对于每个托盘 $p_j$，它会搜索所有可用的货架，以找到最紧密贴合该托盘的那个，即容量足够大但又是最小的那个。该策略旨在保留容量较大的货架，以供未来可能出现的更大托盘使用。\n\n算法按以下步骤对每个 $j \\in \\{1, 2, \\dots, m\\}$ 进行：\n- 识别所有候选货架的集合 $C_j$，这些货架既可用又具有足够容量：\n$$ C_j = \\{ i \\in \\{1, \\dots, n\\} \\mid u_i = 1 \\land s_i \\ge p_j \\} $$\n- 如果集合 $C_j$ 为空，则无法为托盘 $p_j$ 进行分配。\n    - 增加失败计数：$F \\leftarrow F + 1$。\n- 如果 $C_j$ 非空，则必须选择一个最佳适应的货架。\n    - 首先，在所有候选货架中找到最小容量：\n    $$ s_{\\min} = \\min_{i \\in C_j} \\{s_i\\} $$\n    - 接下来，识别出具有此最小容量的候选子集 $B_j \\subseteq C_j$：\n    $$ B_j = \\{ i \\in C_j \\mid s_i = s_{\\min} \\} $$\n    - 问题提供了平局决胜规则：如果多个货架具有相同的最小容量 $s_{\\min}$，则选择索引最小的那个。\n    $$ i^* = \\min_{i \\in B_j} \\{i\\} $$\n    - 托盘 $p_j$ 被分配到货架 $s_{i^*}$。\n    - 更新系统状态：$u_{i^*} \\leftarrow 0$。\n    - 增加已分配托盘计数：$A \\leftarrow A + 1$。\n    - 将碎片加到总和中：$W \\leftarrow W + (s_{i^*} - p_j)$。\n\n对所有托盘重复此过程，从与首次适应模拟相同的初始状态（$A=0, F=0, W=0, u_i=1$）开始。\n\n**实现设计**\n\n一个程序化解决方案将包含两个独立的函数，每个策略一个。每个函数将接收货架容量 $S$ 和托盘尺寸 $P$ 作为输入。在每个函数内部，将初始化一个与 $U$ 对应的可用性数组。然后，该函数将遍历所有托盘，应用各自的逻辑来寻找货架或声明失败，并更新指标 $A$、$F$ 和 $W$。最后，该函数将返回这三个指标。主程序将对每个测试用例执行这两个函数，并按规定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef first_fit_strategy(shelves, pallets):\n    \"\"\"\n    Simulates the first-fit allocation strategy.\n\n    Args:\n        shelves (list): A list of nonnegative integer shelf capacities.\n        pallets (list): A list of nonnegative integer pallet sizes.\n\n    Returns:\n        tuple: A tuple containing (A, F, W) where A is the number of\n               allocations, F is the number of failures, and W is the\n               total internal fragmentation.\n    \"\"\"\n    num_shelves = len(shelves)\n    available_shelves = np.ones(num_shelves, dtype=bool)\n    \n    allocated_count = 0\n    failed_count = 0\n    total_fragmentation = 0\n\n    for pallet_size in pallets:\n        pallet_placed = False\n        for i in range(num_shelves):\n            if available_shelves[i] and shelves[i] >= pallet_size:\n                # Place the pallet in the first available-and-fitting shelf\n                available_shelves[i] = False\n                allocated_count += 1\n                total_fragmentation += shelves[i] - pallet_size\n                pallet_placed = True\n                break  # Move to the next pallet\n        \n        if not pallet_placed:\n            failed_count += 1\n            \n    return allocated_count, failed_count, total_fragmentation\n\ndef best_fit_strategy(shelves, pallets):\n    \"\"\"\n    Simulates the best-fit allocation strategy.\n\n    Args:\n        shelves (list): A list of nonnegative integer shelf capacities.\n        pallets (list): A list of nonnegative integer pallet sizes.\n\n    Returns:\n        tuple: A tuple containing (A, F, W) where A is the number of\n               allocations, F is the number of failures, and W is the\n               total internal fragmentation.\n    \"\"\"\n    num_shelves = len(shelves)\n    available_shelves = np.ones(num_shelves, dtype=bool)\n\n    allocated_count = 0\n    failed_count = 0\n    total_fragmentation = 0\n\n    for pallet_size in pallets:\n        best_shelf_index = -1\n        # Using a large number for initial minimum capacity\n        min_capacity = float('inf')\n\n        for i in range(num_shelves):\n            if available_shelves[i] and shelves[i] >= pallet_size:\n                # Found a potential shelf. Check if it's a better fit.\n                if shelves[i]  min_capacity:\n                    min_capacity = shelves[i]\n                    best_shelf_index = i\n        \n        if best_shelf_index != -1:\n            # A best-fit shelf was found, place the pallet\n            available_shelves[best_shelf_index] = False\n            allocated_count += 1\n            total_fragmentation += shelves[best_shelf_index] - pallet_size\n        else:\n            # No suitable shelf found\n            failed_count += 1\n\n    return allocated_count, failed_count, total_fragmentation\n\ndef solve():\n    \"\"\"\n    Runs the allocation simulations for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: S = [9,8,10], P = [8,10,9]\n        ([9, 8, 10], [8, 10, 9]),\n        # Test case 2: S = [5,5,5], P = [5,5,5,5]\n        ([5, 5, 5], [5, 5, 5, 5]),\n        # Test case 3: S = [4,4], P = [5,6]\n        ([4, 4], [5, 6]),\n        # Test case 4: S = [12,3], P = []\n        ([12, 3], []),\n        # Test case 5: S = [5,9,6], P = [6,5,9]\n        ([5, 9, 6], [6, 5, 9]),\n    ]\n\n    all_results = []\n    for s_capacities, p_sizes in test_cases:\n        # Each strategy must run on a fresh set of shelves\n        shelves_copy = list(s_capacities)\n        pallets_copy = list(p_sizes)\n        \n        # Run first-fit\n        ff_results = first_fit_strategy(shelves_copy, pallets_copy)\n        all_results.extend(ff_results)\n        \n        # Run best-fit\n        bf_results = best_fit_strategy(shelves_copy, pallets_copy)\n        all_results.extend(bf_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "随着程序运行，反复的内存分配和释放会导致“外部碎片”问题——即总空闲内存充足，但没有足够大的连续空间来满足新的请求。内存整理（Defragmentation）是解决此问题的关键技术，它通过移动内存中的对象来合并小的空闲块。在这个实践中，你将实现一个经典的“双指针”算法来就地（in-place）整理堆内存，这不仅能让你掌握解决内存碎片化的核心方法，还能体会到优化数据移动成本的重要性。",
            "id": "3251644",
            "problem": "给定一个自定义堆，其模型为一个从地址 $0$ 到地址 $L$ 的有限线性地址空间，该空间被划分为多个不重叠的连续段。每个段要么是一个空闲区域，要么是一个活跃的已分配块。每个活跃块都是一个不可分割的连续区域，其大小为正整数，记作 $s_i$。这些块以固定的从左到右的顺序出现。空闲区域的大小为正整数，记作 $f_j$。所有段大小的总和等于 $L$。所有复制成本以字节为单位计量，复制一个大小为 $s_i$ 的块一次的成本为 $s_i$ 字节的移动量。\n\n任务：设计并实现一个原地碎片整理算法，该算法将所有活跃块紧缩成一个从地址 $0$ 开始、中间没有间隙的连续区域，同时保持活跃块原始的从左到右的顺序，并最小化复制的总字节数。该算法必须在不分配与 $L$ 或块数量成比例的辅助数组的情况下运行。该算法应仅使用线性内存布局和连续紧缩的核心定义来推导，并应通过第一性原理进行推理来证明其最小性。\n\n形式上，设从左到右排列的活跃块为 $b_1, b_2, \\dots, b_k$，其大小分别为 $s_1, s_2, \\dots, s_k$。碎片整理后，块 $b_i$ 的预期目标起始地址为\n$$\nt_i = \\sum_{j=1}^{i-1} s_j,\n$$\n使得块 $b_i$ 连续地占据区间 $[t_i, t_i + s_i)$，其中 $i = 1, 2, \\dots, k$。移动的总字节数定义为\n$$\nC = \\sum_{i \\in M} s_i,\n$$\n其中 $M$ 是被算法至少复制一次的块的索引集合。您的解决方案必须推导出一个在上述约束条件下实现最小可能 $C$ 的算法，并且必须分析其作为 $L$ 和 $k$ 的函数的时间和空间复杂度。\n\n程序的输入建模：测试套件中的每个堆都描述为一个段列表。一个活跃的已分配块表示为一个元组 $\\texttt{(\"A\", id, size)}$，其中 $\\texttt{id}$ 是一个用于可读性的唯一整数标签，$\\texttt{size}$ 是一个给出 $s_i$ 的正整数。一个空闲区域表示为一个元组 $\\texttt{(\"F\", size)}$，其中 $\\texttt{size}$ 是一个给出 $f_j$ 的正整数。段按照它们实际的从左到右的顺序出现，每个段的初始起始地址是从地址 $0$ 开始的所有前面段大小的累加和。\n\n对于每个测试堆，您的程序必须计算并输出两项内容：\n- 在保持活跃块原始顺序的稳定紧缩下，移动的最小总字节数 $C$。\n- 碎片整理后活跃块的最终起始地址列表 $[t_1, t_2, \\dots, t_k]$，其顺序与它们在输入中出现的顺序相同。\n\n测试套件：\n- 测试 $1$：堆段 $\\texttt{[(\"A\", 1, 4), (\"A\", 2, 2), (\"A\", 3, 3)]}$。\n- 测试 $2$：堆段 $\\texttt{[(\"A\", 1, 3), (\"F\", 2), (\"A\", 2, 2), (\"F\", 1), (\"A\", 3, 1)]}$。\n- 测试 $3$：堆段 $\\texttt{[(\"F\", 5), (\"A\", 1, 2), (\"A\", 2, 4)]}$。\n- 测试 $4$：堆段 $\\texttt{[(\"A\", 1, 1), (\"F\", 1), (\"A\", 2, 1), (\"F\", 2), (\"A\", 3, 2), (\"F\", 3)]}$。\n- 测试 $5$：堆段 $\\texttt{[(\"F\", 7), (\"A\", 1, 5)]}$。\n- 测试 $6$：堆段 $\\texttt{[(\"F\", 10)]}$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个列表，每个元素对应一个测试堆，并且每个元素本身就是列表 $\\texttt{[C, [t_1, t_2, \\dots, t_k]]}$。该列表必须以逗号分隔且无空格的方式打印，并用方括号括起来。例如，两个测试的输出将类似于 $\\texttt{[[C_1,[t_{1,1},\\dots]],[C_2,[t_{2,1},\\dots]]]}$，其中所有 $C$ 和 $t$ 值都是整数。",
            "solution": "我们从线性堆内存的核心定义开始：一个从 $0$ 到 $L$ 索引的一维地址空间，它被划分为一系列恰好覆盖区间 $[0, L)$ 的连续段。每个段代表一个活跃的已分配块（大小为 $s_i \\in \\mathbb{Z}^+$）或一个空闲区域（大小为 $f_j \\in \\mathbb{Z}^+$）。段的顺序由它们从左到右的排列给出。任何活跃块都不能与另一个活跃块或任何空闲区域重叠，且活跃块是不可分割的，必须作为连续的字节序列来保留。\n\n碎片整理的目标是实现所有活跃块从地址 $0$ 开始的连续排列，并保持其原始顺序，我们称之为稳定紧缩。具体来说，给定 $k$ 个活跃块按顺序的大小 $s_1, s_2, \\dots, s_k$，块 $b_i$ 的预期目标起始地址是\n$$\nt_i = \\sum_{j=1}^{i-1} s_j,\n$$\n从而最终布局占据区间 $[0, T)$，其中\n$$\nT = \\sum_{i=1}^{k} s_i.\n$$\n我们通过计算算法复制的总字节数来衡量数据移动的成本。复制一个大小为 $s_i$ 的块一次的成本是 $s_i$ 字节。如果一个块被多次复制，成本会累加。总成本是\n$$\nC = \\sum_{i \\in M} s_i,\n$$\n其中 $M$ 是被至少复制一次的块的索引集合。\n\n$C$ 的基于原理的下界：对于稳定紧缩，块 $b_i$ 的最终目标位置 $t_i$ 是固定的。考虑块 $b_i$ 的初始起始地址，记作 $a_i$。根据初始配置的定义，$a_i$ 等于所有前面段（包括空闲段和活跃块）大小的总和。对于任何 $i$，如果 $b_i$ 之前至少有一个空闲段，我们必然有 $a_i  t_i$，因为初始前缀和包含了紧缩后目标中不存在的额外空闲空间大小。由于 $a_i \\neq t_i$ 并且块最终必须占据 $[t_i, t_i+s_i)$，块 $b_i$ 不能保持在其初始位置不动。为了保持顺序并防止重叠，$b_i$ 必须被复制到其目标区域。因此，每个前面至少有一个空闲段的块都必须至少移动一次，产生至少 $s_i$ 的成本。设 $P$ 为堆中仅包含活跃块而不含任何空闲段的最大前缀。将 $P$ 中包含的块的索引记为 $i=1,2,\\dots,r$。这些块有 $a_i = t_i$，可以保持不动。所有剩余的块 $i=r+1,\\dots,k$ 前面至少有一个空闲段，因此必须至少移动一次。总成本的下界是\n$$\nC_{\\min} \\ge \\sum_{i=r+1}^{k} s_i.\n$$\n\n达到下界的构造性算法：使用两个指针，对段序列进行单次遍历。维护一个写指针 $w$，它指示下一个活跃块应该被放置的起始地址，以填充任何前面的空闲空间；以及一个读指针 $r$，它指示当前正在扫描的段的起始地址。\n\n算法步骤：\n1. 初始化 $w \\leftarrow 0$ 和 $r \\leftarrow 0$。\n2. 按从左到右的顺序遍历每个段：\n   - 如果段是一个大小为 $f_j$ 的空闲区域，则更新 $r \\leftarrow r + f_j$，不执行其他操作。\n   - 如果段是一个大小为 $s_i$ 的活跃块：\n     - 如果 $r = w$，则没有前面的空闲空间，因此该块已经位于其目标起始地址 $t_i = w$，无需复制。记录最终起始地址 $t_i = w$，并更新 $w \\leftarrow w + s_i$, $r \\leftarrow r + s_i$。\n     - 如果 $r \\neq w$，则有前面的空闲空间。将该块复制到以 $t_i = w$ 为起始的位置，产生 $s_i$ 的成本。记录最终起始地址 $t_i = w$，并更新 $w \\leftarrow w + s_i$, $r \\leftarrow r + s_i$。\n3. 遍历结束后，所有活跃块都被分配了最终起始地址 $t_i$，形成了无间隙的 $[0, T)$，总成本 $C$ 正是那些在处理时 $r \\neq w$ 的块的 $s_i$ 之和。\n\n最小性证明：如前所述，任何前面至少有一个空闲段的块都必须至少移动一次，为成本贡献 $s_i$。该算法恰好移动这些块，并且每个这样的块只移动一次。位于初始最大活跃块前缀中的块不产生移动成本。因此，该算法达到了下界\n$$\nC = \\sum_{i=r+1}^{k} s_i,\n$$\n因此在约束条件下是最优的。\n\n正确性和原地性：该算法保持了活跃块的顺序，因为它从左到右处理它们，并分配按 $s_i$ 递增的连续目标地址。复制操作可以通过使用内存移动来实现，该移动能正确处理重叠（例如，其语义等效于标准的内存移动函数，即使源和目标范围重叠也能安全地复制连续区域）。因为我们只维护常数数量的指针，并且不分配与 $L$ 或 $k$ 成比例的辅助数组，所以该算法是原地的，具有 $O(1)$ 的额外空间。\n\n复杂度分析：设 $L$ 为总堆大小，$k$ 为活跃块的数量。该算法对段序列执行单次遍历，更新 $r$ 和 $w$。每个活跃块最多被复制一次，复制的总字节数等于 $C \\le \\sum_{i=1}^{k} s_i \\le L$。扫描段的时间是 $O(m)$，其中 $m$ 是段的数量，复制数据的时间是 $O(C) \\le O(L)$。因此，当将复制成本衡量为与移动的字节数成正比时，总时间复杂度为 $O(L)$，额外空间复杂度为 $O(1)$。\n\n程序输出：对于每个测试堆，程序计算 $C$ 和列表 $[t_1, t_2, \\dots, t_k]$。最终输出是一行包含一个逗号分隔且无空格的列表，其中每个元素是对应测试的列表 $\\texttt{[C,[t_1,\\dots,t_k]]}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Imported as permitted; not required for core logic.\n\ndef defragment(heap_segments):\n    \"\"\"\n    Perform stable in-place compaction analysis on a custom heap described by segments.\n\n    heap_segments: list of tuples\n      - (\"A\", id, size) for allocated blocks\n      - (\"F\", size) for free regions\n\n    Returns:\n      moved_bytes: int, minimal total bytes moved under stable compaction\n      final_starts: list of ints, target start addresses of live blocks in input order\n    \"\"\"\n    write = 0  # Next target start address for the next live block\n    read = 0   # Current address while scanning segments\n    moved_bytes = 0\n    final_starts = []\n\n    for seg in heap_segments:\n        tag = seg[0]\n        if tag == \"F\":\n            # Free region: advance read pointer by its size\n            size = seg[1]\n            read += size\n        else:\n            # Allocated block: process its placement\n            _, _id, size = seg\n            if read != write:\n                # There is preceding free space; moving this block once costs its size\n                moved_bytes += size\n            # Record final start for this block (stable order, contiguous packing)\n            final_starts.append(write)\n            # Advance pointers by block size\n            write += size\n            read += size\n\n    return moved_bytes, final_starts\n\ndef serialize(obj):\n    \"\"\"\n    Serialize ints and nested lists to a compact string without spaces.\n    \"\"\"\n    if isinstance(obj, int):\n        return str(obj)\n    elif isinstance(obj, list):\n        return \"[\" + \",\".join(serialize(x) for x in obj) + \"]\"\n    else:\n        # Should not occur given our data model; fallback to str without spaces if possible.\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: No free regions; no movement needed.\n        [(\"A\", 1, 4), (\"A\", 2, 2), (\"A\", 3, 3)],\n        # Test 2: Interleaved free and allocated segments; movement after the first free.\n        [(\"A\", 1, 3), (\"F\", 2), (\"A\", 2, 2), (\"F\", 1), (\"A\", 3, 1)],\n        # Test 3: Leading free region; all blocks move.\n        [(\"F\", 5), (\"A\", 1, 2), (\"A\", 2, 4)],\n        # Test 4: Alternating small free and allocated segments.\n        [(\"A\", 1, 1), (\"F\", 1), (\"A\", 2, 1), (\"F\", 2), (\"A\", 3, 2), (\"F\", 3)],\n        # Test 5: Single block after a large free region.\n        [(\"F\", 7), (\"A\", 1, 5)],\n        # Test 6: Entirely free heap; no blocks to move.\n        [(\"F\", 10)],\n    ]\n\n    results = []\n    for heap in test_cases:\n        moved, starts = defragment(heap)\n        results.append([moved, starts])\n\n    # Final print statement in the exact required format: comma-separated, no spaces.\n    print(serialize(results))\n\nsolve()\n```"
        },
        {
            "introduction": "手动管理内存（如 `malloc` 和 `free`）既复杂又容易出错，而自动内存管理，即垃圾回收（Garbage Collection, GC），则极大地简化了编程。本练习将带你进入GC的世界，通过实现一个基于图遍历的“标记-清除”（Mark-and-Sweep）算法来自动识别和回收不再被引用的内存对象。通过解决这个问题，你将理解现代编程语言如何安全地处理包括循环引用在内的复杂数据结构，并从根本上了解内存自动回收的原理。",
            "id": "3251599",
            "problem": "设计并实现一个精确、可运行的程序，该程序为一个简化的类 Lisp 堆模型模拟使用垃圾回收器 (Garbage Collector, GC) 进行的自动内存回收。堆被建模为一个有向图 $G = (V, E)$，其中每个对象是图中的一个节点 $v \\in V$，具有一个非负整数大小 $s(v) \\in \\mathbb{N}$ 和零个或多个指针字段，这些指针字段构成了有向边 $(v, w) \\in E$。一个根集合 $R \\subseteq V$ 表示由执行环境直接引用的对象标识符。一个对象 $u \\in V$ 被定义为可达的，当且仅当在图 $G$ 中存在一条从某个 $r \\in R$ 到 $u$ 的路径。可达节点的集合是满足 $R \\subseteq Reach(R)$ 且每当 $(x,y) \\in E$ 且 $x \\in Reach(R)$ 时，则 $y \\in Reach(R)$ 的最小不动点 $Reach(R)$。不可达节点的集合是 $U = V \\setminus Reach(R)$。一个 GC 周期回收的总内存是所有不可达节点大小的总和，即 $B = \\sum_{u \\in U} s(u)$。\n\n您的任务是实现一个“stop-the-world”标记-清除（mark-and-sweep）垃圾回收器（GC），在给定一个堆和一个根集合的情况下，计算出：\n- 回收的内存单元整数 $B$，\n- 存活对象标识符的排序列表 $S = \\mathrm{sorted}(Reach(R))$，\n- 不可达对象标识符的排序列表 $U = \\mathrm{sorted}(V \\setminus Reach(R))$。\n\nGC 必须正确处理循环数据结构：从 $R$ 可达的循环必须保留，而从 $R$ 不可达的循环必须被完全回收。\n\n您必须用来推导算法设计的基础原理：\n- 使用明确定义的遍历方法，从一组源节点出发的图可达性，\n- 如上所述的可达性的不动点特性，\n- 集合论划分 $V = Reach(R) \\cup U$，其中 $Reach(R) \\cap U = \\varnothing$，\n- 对不相交集合进行求和以进行内存核算。\n\n除了这些基础原理外，避免使用任何更高级别或快捷的公式。从这些原理中推导出您方法的正确性。\n\n程序的输入固定在程序本身内部（无外部输入）。每个堆被指定为：\n- 对象标识符的有限集合 $V = \\{id_1, id_2, \\dots, id_n\\}$，\n- 对于每个 $v \\in V$，一个非负整数大小 $s(v)$ 和一个指向 $V$ 中其他标识符的有限出指针列表，\n- 一个根集合 $R \\subseteq V$。\n\n您的程序必须处理以下测试套件，其中每个案例都指定了 $V$、大小 $s(\\cdot)$、边 $E$ 和根集合 $R$。在每个案例中，所有标识符和大小都是整数，并且所有指针都指向 $V$ 中的有效标识符。\n\n测试用例 1（顺利路径，包含一个可达循环和一个不可达循环）：\n- $V = \\{0,1,2,3,4,5,6,7\\}$，\n- 大小：$s(0)=3$, $s(1)=2$, $s(2)=1$, $s(3)=2$, $s(4)=5$, $s(5)=4$, $s(6)=4$, $s(7)=4$，\n- 边：$0 \\to \\{1,2\\}$, $1 \\to \\{3\\}$, $2 \\to \\{\\}$, $3 \\to \\{1\\}$, $4 \\to \\{\\}$, $5 \\to \\{6\\}$, $6 \\to \\{7\\}$, $7 \\to \\{5\\}$，\n- 根：$R = \\{0\\}$。\n\n测试用例 2（边界情况，根集合为空；所有对象都不可达）：\n- $V = \\{10,11,12\\}$，\n- 大小：$s(10)=2$, $s(11)=2$, $s(12)=2$，\n- 边：$10 \\to \\{\\}$, $11 \\to \\{12\\}$, $12 \\to \\{11\\}$，\n- 根：$R = \\varnothing$。\n\n测试用例 3（所有对象均可达；包含一个可达循环）：\n- $V = \\{20,21,22,23\\}$，\n- 大小：$s(20)=1$, $s(21)=1$, $s(22)=1$, $s(23)=2$，\n- 边：$20 \\to \\{21,23\\}$, $21 \\to \\{22\\}$, $22 \\to \\{21\\}$, $23 \\to \\{\\}$，\n- 根：$R = \\{20\\}$。\n\n测试用例 4（共享子结构；只有一个不可达的叶节点）：\n- $V = \\{30,31,32,33,34\\}$，\n- 大小：$s(30)=3$, $s(31)=4$, $s(32)=5$, $s(33)=6$, $s(34)=7$，\n- 边：$30 \\to \\{31,32\\}$, $31 \\to \\{33\\}$, $32 \\to \\{33\\}$, $33 \\to \\{\\}$, $34 \\to \\{\\}$，\n- 根：$R = \\{30\\}$。\n\n测试用例 5（不可达的自循环）：\n- $V = \\{40\\}$，\n- 大小：$s(40)=9$，\n- 边：$40 \\to \\{40\\}$，\n- 根：$R = \\varnothing$。\n\n测试用例 6（可达的自循环）：\n- $V = \\{50\\}$，\n- 大小：$s(50)=9$，\n- 边：$50 \\to \\{50\\}$，\n- 根：$R = \\{50\\}$。\n\n对于每个测试用例，您的程序必须计算出三元组 $[B, S, U]$，其中 $B$ 是一个整数，$S$ 是存活标识符的排序列表，$U$ 是不可达标识符的排序列表。最终输出格式必须是单行，包含所有测试结果的列表，按顺序排列，形式为用方括号括起来的逗号分隔列表，并且每个测试结果本身也采用方括号表示法。例如，像 $[[b_1, s_1, u_1],[b_2, s_2, u_2],\\dots]$ 这样的行，其中 $b_i$ 是一个整数，$s_i$ 和 $u_i$ 是整数列表。除了生成一行有效的 Python 列表字面量之外，没有额外的文本或空白约束。",
            "solution": "该问题要求设计并实现一个标记-清除（mark-and-sweep）垃圾回收器（GC）。堆被抽象地建模为一个有向图 $G = (V, E)$，其中 $V$ 是内存对象（节点）的集合，$E$ 表示它们之间的指针（边）。每个对象 $v \\in V$都有一个关联的大小 $s(v)$。GC 的任务是从给定的根集合 $R \\subseteq V$ 开始，识别并计算所有不可达对象的总大小。\n\n算法设计直接源自问题陈述中规定的基本原理：图的可达性、其不动点特性、堆的集合论划分以及对已识别集合的求和。该过程分为两个不同阶段：一个用于识别所有可达对象的**标记阶段**（Mark Phase），以及一个用于回收不可达对象并汇总结果的**清除阶段**（Sweep Phase）。\n\n### 算法推导\n\n1.  **标记阶段：计算可达集合**\n\n    问题的核心是计算可达节点的集合 $Reach(R)$。问题将此集合定义为满足两个条件的最小不动点：\n    1.  $R \\subseteq Reach(R)$（基本情况）\n    2.  如果 $x \\in Reach(R)$ 且 $(x, y) \\in E$，那么 $y \\in Reach(R)$（归纳步骤）\n\n    这个不动点定义自然地导出了一个迭代图遍历算法。我们可以通过从根集合开始，并传递性地探索所有可通过指针链访问的对象来计算 $Reach(R)$。\n\n    让我们定义一个“已标记”（即已知可达）对象的集合 $M$。算法过程如下：\n    -   用根集合 $R$ 的内容初始化一个工作列表 $W$。\n    -   将已标记节点的集合 $M$ 初始化为空集 $\\varnothing$。\n    -   算法进行迭代，直到工作列表 $W$ 为空。在每一步中：\n        a.  从 $W$ 中移除一个对象标识符 $u$。\n        b.  如果 $u$ 尚不在 $M$ 中（即 $u \\notin M$），这意味着我们是第一次访问这个可达对象。\n        c.  我们通过将 $u$ 添加到 $M$ 中来标记它，即 $M \\leftarrow M \\cup \\{u\\}$。\n        d.  然后我们找到所有由 $u$ 直接指向的对象 $v$（即，对于所有满足 $(u, v) \\in E$ 的 $v$），并将它们添加到工作列表 $W$ 中。这一步直接实现了不动点定义的归纳部分。\n        e.  如果 $u$ 已经在 $M$ 中，我们什么也不做，因为它的后代节点肯定已经被添加到工作列表或已被处理。这一步对于确保正确性和终止性至关重要，尤其是在存在循环数据结构的情况下。\n\n    当这个迭代过程终止时（当 $W$ 变为空时），集合 $M$ 正是满足条件的最小集合，因此 $M = Reach(R)$。这种遍历可以使用栈（深度优先搜索）或队列（广度优先搜索）来实现工作列表 $W$。\n\n2.  **清除阶段：划分与核算**\n\n    一旦标记阶段完成并且集合 $Reach(R)$ 已被确定，清除阶段就开始了。此阶段使用计算出的集合来划分整个对象集合 $V$ 并计算所需的输出。\n\n    -   **划分**：根据集合论划分原理，所有对象的集合 $V$ 被划分为两个不相交的子集：\n        -   存活对象的集合，这正是可达集合 $S_{set} = Reach(R)$。\n        -   不可达（垃圾）对象的集合 $U$，它是 $Reach(R)$ 相对于 $V$ 的补集，即 $U = V \\setminus Reach(R)$。\n\n    -   **内存回收核算**：回收的总内存量 $B$ 是不可达集合 $U$ 中所有对象大小的总和。这是对不相交集合 $U$ 应用求和原理的直接体现：\n        $$B = \\sum_{u \\in U} s(u)$$\n\n    -   **最终输出构建**：问题要求三个具体输出：\n        1.  回收内存的整数总量 $B$。\n        2.  存活对象标识符的排序列表 $S = \\text{sorted}(S_{set})$。\n        3.  不可达对象标识符的排序列表 $U_{list} = \\text{sorted}(U)$。\n\n    这个完整的程序基于指定的基本原理，正确地实现了一个标记-清除垃圾回收器，能够稳健地处理复杂的堆结构，包括循环和共享子图。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_gc(sizes, edges, roots):\n    \"\"\"\n    Simulates a mark-and-sweep garbage collector for a given heap model.\n\n    Args:\n        sizes (dict): A dictionary mapping object identifiers (int) to their sizes (int).\n        edges (dict): A dictionary representing the graph's adjacency list, mapping\n                      object identifiers (int) to a list of identifiers they point to.\n        roots (set): A set of root object identifiers (int).\n\n    Returns:\n        list: A list containing three elements:\n              - B (int): The total size of reclaimed memory.\n              - S (list): A sorted list of surviving (reachable) object identifiers.\n              - U (list): A sorted list of unreachable object identifiers.\n    \"\"\"\n    all_nodes = set(sizes.keys())\n    \n    # Mark Phase: Find all reachable objects using graph traversal (DFS-style).\n    # The set of reachable_nodes is the smallest fixed point that contains the\n    # roots and is closed under the edge relation.\n    reachable_nodes = set()\n    worklist = list(roots) # The worklist is initialized with the root set.\n    \n    while worklist:\n        node_id = worklist.pop()\n        if node_id not in reachable_nodes:\n            # Mark the node as reachable.\n            reachable_nodes.add(node_id)\n            # Add its children to the worklist to continue the traversal.\n            # This implements the inductive step of the fixed-point definition.\n            # A node must have an entry in `edges` to have children.\n            if node_id in edges:\n                for child_id in edges[node_id]:\n                    worklist.append(child_id)\n\n    # Sweep Phase: Partition objects and calculate results.\n    # The set of all nodes V is partitioned into Reach(R) and U = V \\ Reach(R).\n    unreachable_nodes = all_nodes - reachable_nodes\n    \n    # Calculate total reclaimed memory by summing sizes of unreachable objects.\n    reclaimed_memory = sum(sizes[node_id] for node_id in unreachable_nodes)\n    \n    # Sort the lists of surviving and unreachable identifiers as required.\n    surviving_list = sorted(list(reachable_nodes))\n    unreachable_list = sorted(list(unreachable_nodes))\n    \n    return [reclaimed_memory, surviving_list, unreachable_list]\n\ndef solve():\n    # Define the test suite as specified in the problem statement.\n    # Each case is a tuple: (sizes, edges, roots).\n    # The set V of all nodes is inferred from the keys of the `sizes` dictionary.\n    test_cases = [\n        # Test case 1 (happy path with a reachable cycle and an unreachable cycle)\n        (\n            {0: 3, 1: 2, 2: 1, 3: 2, 4: 5, 5: 4, 6: 4, 7: 4},\n            {0: [1, 2], 1: [3], 2: [], 3: [1], 4: [], 5: [6], 6: [7], 7: [5]},\n            {0}\n        ),\n        # Test case 2 (boundary with empty roots; everything is unreachable)\n        (\n            {10: 2, 11: 2, 12: 2},\n            {10: [], 11: [12], 12: [11]},\n            set()\n        ),\n        # Test case 3 (all objects reachable; includes a reachable cycle)\n        (\n            {20: 1, 21: 1, 22: 1, 23: 2},\n            {20: [21, 23], 21: [22], 22: [21], 23: []},\n            {20}\n        ),\n        # Test case 4 (shared substructure; only one unreachable leaf)\n        (\n            {30: 3, 31: 4, 32: 5, 33: 6, 34: 7},\n            {30: [31, 32], 31: [33], 32: [33], 33: [], 34: []},\n            {30}\n        ),\n        # Test case 5 (self-cycle unreachable)\n        (\n            {40: 9},\n            {40: [40]},\n            set()\n        ),\n        # Test case 6 (self-cycle reachable)\n        (\n            {50: 9},\n            {50: [50]},\n            {50}\n        ),\n    ]\n\n    results = []\n    for sizes, edges, roots in test_cases:\n        result = run_gc(sizes, edges, roots)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output is a string representation of a Python list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}