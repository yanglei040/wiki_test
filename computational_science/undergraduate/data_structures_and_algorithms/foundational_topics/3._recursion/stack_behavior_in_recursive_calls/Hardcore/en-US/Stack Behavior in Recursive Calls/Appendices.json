{
    "hands_on_practices": [
        {
            "introduction": "The call stack is not an abstract theoretical construct; it is a tangible block of memory with a finite size. This practice grounds our understanding of recursion in this physical reality. By calculating the maximum recursion depth based on memory limits, you will learn to perform essential \"back-of-the-envelope\" estimates to determine if a recursive approach is feasible or risks a stack overflow error .",
            "id": "3274462",
            "problem": "Consider a single-threaded program running on an operating system that enforces a fixed stack size limit per thread. A recursive function is compiled without tail-call optimization and, on each invocation, allocates a local object of size $1 \\text{ kilobyte}$ on its stack frame. Assume that there are no other local variables and that any constant per-frame overhead (such as a saved return address and frame pointer) is negligible relative to the allocated object, so that the dominant per-call stack usage is the $1 \\text{ kilobyte}$ object. The stack for this thread is limited to $2 \\text{ megabytes}$ and is otherwise unused.\n\nUsing first principles about stack frame allocation in recursion and the binary definitions $1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$ and $1 \\text{ megabyte} = 2^{20} \\text{ bytes}$, determine the maximum recursion depth (the number of simultaneously active recursive calls) that can be achieved without causing a stack overflow.\n\nProvide your answer as a single integer. No rounding is required.",
            "solution": "The problem asks for the maximum recursion depth of a function given specific constraints on stack usage. We are given the total available stack size and the amount of stack space consumed by each recursive call. The solution requires calculating how many of these stack frames can fit into the total available stack space.\n\nLet $S_{\\text{total}}$ be the total stack size limit for the thread.\nLet $S_{\\text{frame}}$ be the stack space allocated for each recursive function call (i.e., the size of one stack frame).\nLet $D_{\\text{max}}$ be the maximum recursion depth.\n\nFrom the problem statement, we are given:\nThe total stack size is $S_{\\text{total}} = 2 \\text{ megabytes}$.\nThe stack usage per call is dominated by a local object of size $S_{\\text{frame}} = 1 \\text{ kilobyte}$. The problem states to neglect any other overhead.\nThe binary definitions for the units are provided:\n$1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$\n$1 \\text{ megabyte} = 2^{20} \\text{ bytes}$\n\nTo find the maximum recursion depth, we must first express both the total stack size and the per-frame stack usage in the same unit, which we will choose to be bytes.\n\nFirst, we convert the total stack size $S_{\\text{total}}$ to bytes:\n$$S_{\\text{total}} = 2 \\text{ megabytes} = 2 \\times (1 \\text{ megabyte}) = 2 \\times (2^{20} \\text{ bytes})$$\nUsing the property of exponents $a^m \\times a^n = a^{m+n}$, with $a=2$, $m=1$, and $n=20$:\n$$S_{\\text{total}} = 2^1 \\times 2^{20} \\text{ bytes} = 2^{1+20} \\text{ bytes} = 2^{21} \\text{ bytes}$$\n\nNext, we convert the per-frame stack usage $S_{\\text{frame}}$ to bytes:\n$$S_{\\text{frame}} = 1 \\text{ kilobyte} = 1 \\times (1 \\text{ kilobyte}) = 1 \\times (2^{10} \\text{ bytes}) = 2^{10} \\text{ bytes}$$\n\nThe maximum recursion depth, $D_{\\text{max}}$, is the total number of stack frames that can be allocated before the total stack size limit is exceeded. Since the problem specifies that the stack is otherwise unused and per-frame overhead is negligible, we can find $D_{\\text{max}}$ by dividing the total available stack size by the size of a single stack frame.\n$$D_{\\text{max}} = \\frac{S_{\\text{total}}}{S_{\\text{frame}}}$$\n\nSubstituting the values in bytes:\n$$D_{\\text{max}} = \\frac{2^{21} \\text{ bytes}}{2^{10} \\text{ bytes}}$$\n\nUsing the property of exponents $\\frac{a^m}{a^n} = a^{m-n}$, with $a=2$, $m=21$, and $n=10$:\n$$D_{\\text{max}} = 2^{21-10} = 2^{11}$$\n\nFinally, we calculate the integer value of $2^{11}$:\n$$2^{11} = 2 \\times 2^{10} = 2 \\times 1024 = 2048$$\n\nTherefore, the maximum recursion depth that can be achieved without causing a stack overflow is $2048$. This represents the total number of simultaneously active recursive calls.",
            "answer": "$$\\boxed{2048}$$"
        },
        {
            "introduction": "Beyond the physical memory limit, an algorithm's structure is the primary determinant of its stack usage. This exercise explores how the manner in which a problem is broken down recursively affects the maximum stack depth. By analyzing a function that halves its input at each step, you will discover the powerful relationship between divide-and-conquer algorithms and logarithmic stack growth, a key to writing efficient recursive solutions for large-scale problems .",
            "id": "3274586",
            "problem": "Consider a deterministic procedure operating on the set of nonnegative integers that uses the standard Last In, First Out (LIFO) call stack. The runtime system does not perform tail-call optimization, so each procedure call pushes one new activation record (AR) onto the stack, and an AR remains on the stack until its call returns. Define a function $f$ on inputs $x \\in \\mathbb{Z}_{\\ge 0}$ as follows: if $x = 0$ then $f$ immediately returns without making any further calls; if $x > 0$ then $f$ makes exactly one recursive call to $f(\\lfloor x/2 \\rfloor)$ and returns after that call returns. The maximum stack depth is defined to be the greatest number of activation records simultaneously present on the stack during the execution of a single call to $f(x)$, counting both the initial invocation and any recursive invocations, including the base-case frame if it is reached. Starting from the core definitions of integer division, the floor function, and the behavior of a call stack under recursion, determine the exact maximum stack depth for the input $x = 10^{9}$. Give your final answer as a single exact integer. No rounding is required.",
            "solution": "Let $D(x)$ denote the maximum stack depth for a call to the function $f(x)$, where $x \\in \\mathbb{Z}_{\\ge 0}$. The problem defines the behavior of the function $f$ and the call stack.\n\nAccording to the problem description:\n1.  A call to $f(x)$ pushes one new activation record (AR) onto the stack.\n2.  If $x=0$, the function returns. The maximum number of ARs on the stack during this call is $1$ (for $f(0)$ itself). Thus, the base case for the maximum depth is $D(0) = 1$.\n3.  If $x > 0$, the function $f(x)$ makes a single recursive call to $f(\\lfloor x/2 \\rfloor)$. The AR for $f(x)$ remains on the stack while the call to $f(\\lfloor x/2 \\rfloor)$ executes. The maximum stack depth for the execution of $f(x)$ will be the $1$ AR for $f(x)$ itself, plus the maximum depth achieved during the nested call to $f(\\lfloor x/2 \\rfloor)$.\n\nThis gives us the following recurrence relation for the maximum stack depth $D(x)$:\n$$\nD(x) = \\begin{cases}\n1 & \\text{if } x = 0 \\\\\n1 + D(\\lfloor x/2 \\rfloor) & \\text{if } x > 0\n\\end{cases}\n$$\n\nTo find the maximum stack depth for $x = 10^9$, we need to solve this recurrence. We can unroll the recurrence for an arbitrary $x > 0$. Let $x_0 = x$, and define the sequence $x_{i+1} = \\lfloor x_i/2 \\rfloor$ for $i \\ge 0$. Since $x$ is a positive integer, this sequence will strictly decrease until it reaches $0$. Let $m$ be the number of steps required for the argument to become $0$, such that $x_m = 0$ and $x_{m-1} > 0$.\n\nUnrolling the recurrence:\n$$\n\\begin{aligned}\nD(x) &= 1 + D(x_1) \\\\\n&= 1 + (1 + D(x_2)) \\\\\n&= 1 + 1 + (1 + D(x_3)) \\\\\n&\\vdots \\\\\n&= \\underbrace{1 + 1 + \\cdots + 1}_{m \\text{ times}} + D(x_m) \\\\\n&= m + D(0)\n\\end{aligned}\n$$\nUsing the base case $D(0) = 1$, we find:\n$$D(x) = m + 1$$\nHere, $m$ is the number of times we must apply the transformation $n \\to \\lfloor n/2 \\rfloor$ to get from $x$ to $0$.\n\nThe operation $n \\to \\lfloor n/2 \\rfloor$ for an integer $n$ is equivalent to a right bit shift of its binary representation. The number of such operations required to reduce a positive integer $x$ to $0$ is equal to the number of bits in the binary representation of $x$.\n\nFor any positive integer $x$, the number of bits in its binary representation, let's call it $k$, is given by $k = \\lfloor \\log_2(x) \\rfloor + 1$.\nSo, we have $m = k = \\lfloor \\log_2(x) \\rfloor + 1$.\n\nSubstituting this into our expression for $D(x)$:\n$$D(x) = m + 1 = (\\lfloor \\log_2(x) \\rfloor + 1) + 1 = \\lfloor \\log_2(x) \\rfloor + 2$$\nThis formula is valid for any integer $x > 0$.\n\nWe need to calculate the maximum stack depth for the input $x = 10^9$. Using the derived formula:\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2$$\nTo evaluate $\\lfloor \\log_2(10^9) \\rfloor$, we need to find the integer $k$ such that $2^k \\le 10^9 < 2^{k+1}$.\nLet's analyze the powers of $2$ relative to powers of $10$. We know that $2^{10} = 1024$, which is slightly greater than $10^3 = 1000$.\n\nFrom $10^3 < 2^{10}$, we can raise both sides to the power of $3$:\n$$(10^3)^3 < (2^{10})^3$$\n$$10^9 < 2^{30}$$\nTaking the base-$2$ logarithm, we get $\\log_2(10^9) < 30$. This implies that $\\lfloor \\log_2(10^9) \\rfloor \\le 29$.\n\nNow we must check if $\\log_2(10^9)$ is greater than or equal to $29$. This is equivalent to checking if $10^9 \\ge 2^{29}$.\n$$2^{29} = \\frac{2^{30}}{2} = \\frac{(2^{10})^3}{2} = \\frac{(1024)^3}{2}$$\nWe are comparing $10^9$ with $\\frac{1024^3}{2}$. Let's rearrange this comparison:\n$$2 \\cdot 10^9 \\quad \\text{vs} \\quad 1024^3$$\n$$2 \\cdot (1000)^3 \\quad \\text{vs} \\quad (1024)^3$$\nDivide both sides by $(1000)^3$:\n$$2 \\quad \\text{vs} \\quad \\left(\\frac{1024}{1000}\\right)^3$$\n$$2 \\quad \\text{vs} \\quad (1.024)^3$$\nLet's compute $(1.024)^3$:\n$(1.024)^2 = 1.048576$\n$(1.024)^3 = 1.048576 \\times 1.024 = 1.073741824$\nThe comparison is now:\n$$2 \\quad \\text{vs} \\quad 1.073741824$$\nClearly, $2 > 1.073741824$.\nThis implies that $2 \\cdot 10^9 > 1024^3$, which means $10^9 > \\frac{1024^3}{2} = 2^{29}$.\n\nSo we have established the inequality:\n$$2^{29} < 10^9 < 2^{30}$$\nTaking the base-$2$ logarithm of all parts:\n$$\\log_2(2^{29}) < \\log_2(10^9) < \\log_2(2^{30})$$\n$$29 < \\log_2(10^9) < 30$$\nTherefore, the floor of $\\log_2(10^9)$ is $29$:\n$$\\lfloor \\log_2(10^9) \\rfloor = 29$$\nFinally, we can compute the maximum stack depth:\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2 = 29 + 2 = 31$$\nThe exact maximum stack depth for the input $x = 10^9$ is $31$.",
            "answer": "$$\\boxed{31}$$"
        },
        {
            "introduction": "To truly master recursion, one must distinguish between a program's static design and its dynamic behavior. This comprehensive practice challenges you to move from theoretical analysis to empirical measurement by instrumenting code to observe the call stack in action. By comparing different calling patterns—such as tail, binary, and mutual recursion—you will gain a deep, practical understanding of how a static call graph translates into a dynamic stack depth during runtime .",
            "id": "3274453",
            "problem": "You are to write a complete, runnable program that empirically distinguishes the static call graph structure from the dynamic runtime call stack in recursive computations. The goal is to measure the dynamic maximum stack depth $d(n)$ for several recursive and non-recursive calling patterns and relate these measurements to static graph properties. The work must be grounded in the following principles: the call stack is a Last In First Out (LIFO) data structure that holds activation records for active function calls; recursive calls push one activation record per call and pop upon return; the static call graph $G = (V, E)$ contains a node for each function and a directed edge from a caller to a callee indicating a possible call site. The dynamic maximum stack depth $d(n)$ for a run on input size $n$ is the maximum number of simultaneously active activation records at any moment during execution. The static properties to compute are: whether a cycle is reachable from the designated entry function, and the length $L(G)$ of the longest simple path (a path that does not revisit any node) starting at the entry function, measured as the number of distinct nodes visited along the path.\n\nYour program must implement the following experiments, instrumenting each function to track the current and maximum dynamic stack depth $d(n)$ observed during execution, and independently computing static properties from an explicitly provided adjacency list representing the call graph:\n\n- Experiment $1$ (tail recursion): a single function $\\mathsf{T}(n)$ that calls itself until a base case; entry node is $\\mathsf{T}$; adjacency list contains a self-loop at $\\mathsf{T}$.\n- Experiment $2$ (binary recursion): a single function $\\mathsf{B}(n)$ that makes two recursive calls on strictly smaller inputs; entry node is $\\mathsf{B}$; adjacency list contains a self-loop at $\\mathsf{B}$.\n- Experiment $3$ (mutual recursion): two functions $\\mathsf{A}(n)$ and $\\mathsf{B2}(n)$ that call each other alternately on strictly smaller inputs; entry node is $\\mathsf{A}$; adjacency list has edges $\\mathsf{A} \\to \\mathsf{B2}$ and $\\mathsf{B2} \\to \\mathsf{A}$.\n- Experiment $4$ (non-recursive nested calls): three functions $\\mathsf{F}$, $\\mathsf{G}$, and $\\mathsf{H}$, where $\\mathsf{F}$ calls $\\mathsf{G}$, which calls $\\mathsf{H}$; entry node is $\\mathsf{F}$; adjacency list is acyclic with edges $\\mathsf{F} \\to \\mathsf{G}$ and $\\mathsf{G} \\to \\mathsf{H}$.\n- Experiment $5$ (mixed): an entry function $\\mathsf{E}(n)$ that first calls a tail-recursive function $\\mathsf{R}(n)$ and then calls a non-recursive function $\\mathsf{Q}$; entry node is $\\mathsf{E}$; adjacency list has edges $\\mathsf{E} \\to \\mathsf{R}$, $\\mathsf{E} \\to \\mathsf{Q}$, and a self-loop at $\\mathsf{R}$.\n\nFor each experiment, your program must:\n- Instrument the functions so that on every function entry, the current stack depth counter is incremented, and on every function exit, it is decremented, consistent with a LIFO call stack. Track the maximum value reached over the entire run; this maximum is $d(n)$ for the run.\n- Compute the static property $L(G)$ as the length, in number of nodes, of the longest simple path starting at the designated entry node in the provided adjacency list. A path is simple if no node is repeated.\n- Determine whether there exists any cycle that is reachable from the entry node (output as $1$ if a cycle is reachable and $0$ otherwise).\n\nDesign the program so that each experiment has an explicit call graph adjacency list consistent with the implemented call behavior. The adjacency lists must be used to compute static properties independently of the dynamic execution. Your program should implement the following test suite of input sizes $n$ to exercise diverse behaviors and boundaries:\n- Tail recursion with $n = 10$.\n- Tail recursion with $n = 0$.\n- Binary recursion with $n = 7$.\n- Mutual recursion with $n = 6$.\n- Non-recursive nested calls with $n = 5$ (the value is unused by the non-recursive calls but must be passed to preserve a consistent interface).\n- Mixed case with $n = 8$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[d(n), L(G), c]$ for one experiment, with $c \\in \\{0, 1\\}$ indicating whether a cycle is reachable from the entry node. For example, the output format is $[[d_1, L_1, c_1],[d_2, L_2, c_2],\\dots]$. There are no physical units involved in this problem. All outputs are integers.",
            "solution": "The problem requires a program to empirically investigate the relationship between the dynamic behavior of a program's call stack and the static structure of its call graph. Specifically, we must measure the maximum dynamic stack depth, $d(n)$, for a set of recursive and non-recursive calling patterns and compare it to two static properties of the corresponding call graph, $G$: the length of the longest simple path, $L(G)$, from the entry node, and the reachability of a cycle, $c$, from the entry node.\n\nThis analysis is founded on fundamental principles of computer science. The **call stack** is a runtime LIFO (Last-In-First-Out) data structure that manages active subroutine calls. Each time a function is called, an activation record (or stack frame) containing its parameters, local variables, and return address is pushed onto the stack. When the function returns, its frame is popped. The current stack depth is the number of frames on the stack. The maximum stack depth, $d(n)$, for an execution with input size $n$, is the maximum depth observed throughout the run.\n\nIn contrast, the **static call graph**, $G=(V, E)$, is a compile-time abstraction where vertices $v \\in V$ represent functions and a directed edge $(u, v) \\in E$ exists if function $u$ can call function $v$. The static graph represents all possible call paths but does not describe the specific sequence or depth of calls for a particular execution. Recursion appears as a cycle in the static call graph (e.g., a function calling itself forms a self-loop, and mutual recursion forms a cycle of length two or more).\n\nOur methodology involves two independent analyses:\n1.  **Dynamic Analysis**: We instrument the implemented functions to monitor the call stack. A counter tracks the current stack depth, incrementing on function entry and decrementing on exit. The maximum value of this counter is recorded as $d(n)$.\n2.  **Static Analysis**: We operate on an explicit adjacency list representation of the call graph $G$. We implement algorithms to compute:\n    -   **Cycle Reachability ($c$)**: We use a Depth First Search (DFS) starting from the entry node. To detect cycles, we maintain a set of nodes currently in the recursion stack of the DFS traversal. If the traversal encounters a node already in this set, a cycle is found. We report $c=1$ if any such cycle is reachable from the entry point, and $c=0$ otherwise.\n    -   **Longest Simple Path Length ($L(G)$)**: A simple path is one that does not revisit any node. We find the length of the longest simple path (measured as the number of nodes) starting at the entry node. As the graphs are small, this can be solved by a backtracking DFS algorithm that explores all simple paths and records the maximum length encountered.\n\nWe will now analyze each experiment's predicted outcome.\n\n**Experiment 1: Tail Recursion**\n-   Function: $\\mathsf{T}(n)$.\n-   Call pattern: $\\mathsf{T}(n)$ calls $\\mathsf{T}(n-1)$ until a base case $n \\le 0$.\n-   Adjacency List: $\\{\\mathsf{'T'}: [\\mathsf{'T'}]\\}$. Entry: $\\mathsf{'T'}$.\n-   Dynamic Analysis ($n=10$): The call sequence is $\\mathsf{T}(10) \\to \\mathsf{T}(9) \\to \\dots \\to \\mathsf{T}(0)$. The stack will contain frames for all these calls simultaneously, reaching a maximum depth of $10 - 0 + 1 = 11$. Thus, $d(10) = 11$.\n-   Dynamic Analysis ($n=0$): The base case is met immediately, but the function $\\mathsf{T}(0)$ itself is called. The stack depth is $1$. Thus, $d(0) = 1$.\n-   Static Analysis: The graph has one node with a self-loop. A cycle is reachable, so $c=1$. The only simple path starting at $\\mathsf{T}$ is the node itself, as any further step would revisit it. The length is $1$. So, $L(G)=1$.\n\n**Experiment 2: Binary Recursion**\n-   Function: $\\mathsf{B}(n)$.\n-   Call pattern: $\\mathsf{B}(n)$ makes two sequential calls to a recursion on a strictly smaller input, e.g., $\\mathsf{B}(n-1)$. We will use $\\mathsf{B}(n-1)$ twice until base case $n \\le 0$.\n-   Adjacency List: $\\{\\mathsf{'B'}: [\\mathsf{'B'}]\\}$. Entry: $\\mathsf{'B'}$.\n-   Dynamic Analysis ($n=7$): The first recursive call, $\\mathsf{B}(n-1)$, determines the maximum stack depth. The sequence $\\mathsf{B}(7) \\to \\mathsf{B}(6) \\to \\dots \\to \\mathsf{B}(0)$ is executed. This places $7-0+1=8$ frames on the stack. The second branch of recursion does not increase the maximum depth. So, $d(7)=8$.\n-   Static Analysis: The graph is identical to tail recursion: one node with a self-loop. Thus, $c=1$ and $L(G)=1$. This highlights a key distinction: although the static graph is simple, the dynamic execution Trace is complex, but the *stack depth* behavior is still linear, same as tail recursion.\n\n**Experiment 3: Mutual Recursion**\n-   Functions: $\\mathsf{A}(n), \\mathsf{B2}(n)$.\n-   Call pattern: $\\mathsf{A}(n)$ calls $\\mathsf{B2}(n-1)$, which calls $\\mathsf{A}(n-2)$, until $n \\le 0$.\n-   Adjacency List: $\\{\\mathsf{'A'}: [\\mathsf{'B2'}], \\mathsf{'B2'}: [\\mathsf{'A'}]\\}$. Entry: $\\mathsf{'A'}$.\n-   Dynamic Analysis ($n=6$): The call sequence is $\\mathsf{A}(6) \\to \\mathsf{B2}(5) \\to \\mathsf{A}(4) \\to \\dots \\to \\mathsf{A}(0)$. This nesting of calls places $7$ frames on the stack. Thus, $d(6)=7$.\n-   Static Analysis: The graph has a cycle $\\mathsf{A} \\to \\mathsf{B2} \\to \\mathsf{A}$. It is reachable from the entry node $\\mathsf{A}$, so $c=1$. The longest simple path starting from $\\mathsf{A}$ is $\\mathsf{A} \\to \\mathsf{B2}$. We cannot continue to $\\mathsf{A}$ as it would not be a simple path. Path length is $2$ nodes. Thus, $L(G)=2$.\n\n**Experiment 4: Non-recursive Nested Calls**\n-   Functions: $\\mathsf{F}, \\mathsf{G}, \\mathsf{H}$.\n-   Call pattern: $\\mathsf{F}$ calls $\\mathsf{G}$, which calls $\\mathsf{H}$.\n-   Adjacency List: $\\{\\mathsf{'F'}: [\\mathsf{'G'}], \\mathsf{'G'}: [\\mathsf{'H'}], \\mathsf{'H'}: []\\}$. Entry: $\\mathsf{'F'}$.\n-   Dynamic Analysis ($n=5$): The call sequence is $\\mathsf{F}() \\to \\mathsf{G}() \\to \\mathsf{H}()$. The stack will successively hold $[\\mathsf{F}]$, then $[\\mathsf{F}, \\mathsf{G}]$, and finally $[\\mathsf{F}, \\mathsf{G}, \\mathsf{H}]$. The maximum depth is $3$. The input $n$ is unused. So, $d(5)=3$.\n-   Static Analysis: The graph is a directed acyclic graph (DAG). No cycles are reachable, so $c=0$. The longest simple path from $\\mathsf{F}$ is $\\mathsf{F} \\to \\mathsf{G} \\to \\mathsf{H}$. The path length is $3$ nodes. So, $L(G)=3$. In this acyclic case, $d(n)=L(G)$.\n\n**Experiment 5: Mixed**\n-   Functions: $\\mathsf{E}(n), \\mathsf{R}(n), \\mathsf{Q}$.\n-   Call pattern: $\\mathsf{E}(n)$ calls tail-recursive $\\mathsf{R}(n)$, which then returns. Afterwards, $\\mathsf{E}(n)$ calls $\\mathsf{Q}$.\n-   Adjacency List: $\\{\\mathsf{'E'}: [\\mathsf{'R'}, \\mathsf{'Q'}], \\mathsf{'R'}: [\\mathsf{'R'}], \\mathsf{'Q'}: []\\}$. Entry: $\\mathsf{'E'}$.\n-   Dynamic Analysis ($n=8$): Execution begins with $\\mathsf{E}(8)$ on the stack. It calls $\\mathsf{R}(8)$. The stack grows as $\\mathsf{R}(8) \\to \\mathsf{R}(7) \\to \\dots \\to \\mathsf{R}(0)$. The maximum stack state is $[\\mathsf{E}(8), \\mathsf{R}(8), \\dots, \\mathsf{R}(0)]$. This corresponds to $1 + (8-0+1) = 10$ frames. After $\\mathsf{R}$ completes, the stack unwinds to just $[\\mathsf{E}(8)]$. Then $\\mathsf{Q}$ is called, making the stack $[\\mathsf{E}(8), \\mathsf{Q}]$, a depth of $2$. The overall maximum is $10$. So, $d(8)=10$.\n-   Static Analysis: A cycle ($\\mathsf{R} \\to \\mathsf{R}$) is reachable from the entry node $\\mathsf{E}$, so $c=1$. The simple paths from $\\mathsf{E}$ are $\\mathsf{E} \\to \\mathsf{R}$ (length $2$) and $\\mathsf{E} \\to \\mathsf{Q}$ (length $2$). The longest simple path has a length of $2$ nodes. So, $L(G)=2$.\n\nThese experiments demonstrate that while static graph properties like cycle existence indicate the possibility of unbounded call sequences, they do not determine the actual stack depth, which is a dynamic property dependent on the input and termination conditions. The length of the longest simple path, $L(G)$, is particularly dissociated from $d(n)$ in recursive scenarios.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom functools import wraps\n\ndef solve():\n    \"\"\"\n    Main function to run all experiments and print the results.\n    \"\"\"\n\n    class StackMonitor:\n        \"\"\"A class to monitor stack depth during function execution.\"\"\"\n        def __init__(self):\n            self.current_depth = 0\n            self.max_depth = 0\n\n        def enter(self):\n            \"\"\"To be called on function entry.\"\"\"\n            self.current_depth += 1\n            if self.current_depth > self.max_depth:\n                self.max_depth = self.current_depth\n\n        def exit(self):\n            \"\"\"To be called on function exit.\"\"\"\n            self.current_depth -= 1\n\n        def reset(self):\n            \"\"\"Resets the monitor for a new experiment.\"\"\"\n            self.current_depth = 0\n            self.max_depth = 0\n\n        def get_max_depth(self):\n            \"\"\"Returns the maximum depth observed.\"\"\"\n            return self.max_depth\n\n    def instrument(monitor):\n        \"\"\"A decorator factory to instrument a function for stack monitoring.\"\"\"\n        def decorator(func):\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                monitor.enter()\n                try:\n                    result = func(*args, **kwargs)\n                finally:\n                    monitor.exit()\n                return result\n            return wrapper\n        return decorator\n\n    # --- Static Analysis Functions ---\n    def is_cycle_reachable(graph, start_node):\n        \"\"\"\n        Determines if a cycle is reachable from start_node in the graph.\n        Uses a 3-color DFS approach (white, gray, black sets are implicit).\n        'visiting' is the gray set, 'visited' is the black set.\n        \"\"\"\n        path = set()  # Nodes in current recursion path (visiting)\n        visited = set()  # All nodes visited so far in this traversal\n\n        def dfs(node):\n            path.add(node)\n            visited.add(node)\n            for neighbor in graph.get(node, []):\n                if neighbor in path:\n                    return True  # Cycle detected\n                if neighbor not in visited:\n                    if dfs(neighbor):\n                        return True\n            path.remove(node)\n            return False\n\n        # Find all nodes reachable from the start_node first.\n        reachable_nodes = set()\n        q = [start_node]\n        head = 0\n        reachable_nodes.add(start_node)\n        while head  len(q):\n            u = q[head]\n            head += 1\n            for v in graph.get(u, []):\n                if v not in reachable_nodes:\n                    reachable_nodes.add(v)\n                    q.append(v)\n        \n        # Check for cycles starting from any reachable node\n        visited_global = set()\n        for node in reachable_nodes:\n            if node not in visited_global:\n                path_cycle = set()\n                \n                def dfs_cycle_check(u):\n                    path_cycle.add(u)\n                    visited_global.add(u)\n                    for v in graph.get(u,[]):\n                        if v in path_cycle:\n                            return True\n                        if v in reachable_nodes and v not in visited_global:\n                            if dfs_cycle_check(v):\n                                return True\n                    path_cycle.remove(u)\n                    return False\n\n                if dfs_cycle_check(node):\n                    return 1\n\n        return 0\n    \n    def find_longest_simple_path(graph, start_node):\n        \"\"\"\n        Finds the length of the longest simple path (in nodes) starting from start_node.\n        Uses a backtracking DFS approach.\n        \"\"\"\n        max_len = [0]\n        \n        def dfs(node, current_path):\n            current_path.add(node)\n            max_len[0] = max(max_len[0], len(current_path))\n            \n            for neighbor in graph.get(node, []):\n                if neighbor not in current_path:\n                    dfs(neighbor, current_path)\n            \n            current_path.remove(node) # Backtrack\n\n        dfs(start_node, set())\n        return max_len[0]\n\n    # --- Experiment Implementations within a class to handle scoping ---\n    class Experiments:\n        def __init__(self, monitor):\n            self.monitor = monitor\n            # Decorate methods once at initialization\n            self.T = instrument(self.monitor)(self._T)\n            self.B = instrument(self.monitor)(self._B)\n            self.A = instrument(self.monitor)(self._A)\n            self.B2 = instrument(self.monitor)(self._B2)\n            self.F = instrument(self.monitor)(self._F)\n            self.G = instrument(self.monitor)(self._G)\n            self.H = instrument(self.monitor)(self._H)\n            self.E = instrument(self.monitor)(self._E)\n            self.R = instrument(self.monitor)(self._R)\n            self.Q = instrument(self.monitor)(self._Q)\n\n        # Exp 1: Tail Recursion\n        def _T(self, n):\n            if n = 0:\n                return\n            self.T(n - 1)\n\n        # Exp 2: Binary Recursion\n        def _B(self, n):\n            if n = 0:\n                return\n            self.B(n - 1)\n            self.B(n - 1)\n\n        # Exp 3: Mutual Recursion\n        def _A(self, n):\n            if n = 0:\n                return\n            self.B2(n - 1)\n        \n        def _B2(self, n):\n            if n = 0:\n                return\n            self.A(n - 1)\n\n        # Exp 4: Non-recursive Nested Calls\n        def _F(self, n):\n            self.G(n)\n        def _G(self, n):\n            self.H(n)\n        def _H(self, n):\n            return\n\n        # Exp 5: Mixed\n        def _E(self, n):\n            self.R(n)\n            self.Q(n)\n        def _R(self, n):\n            if n = 0:\n                return\n            self.R(n - 1)\n        def _Q(self, n):\n            return\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Exp 1: Tail recursion, n=10\n        {'name': 'Tail Recursion (n=10)', 'n': 10, 'entry_func_name': 'T',\n         'graph': {'T': ['T']}, 'entry_node': 'T'},\n        # Exp 1: Tail recursion, n=0\n        {'name': 'Tail Recursion (n=0)', 'n': 0, 'entry_func_name': 'T',\n         'graph': {'T': ['T']}, 'entry_node': 'T'},\n        # Exp 2: Binary recursion, n=7\n        {'name': 'Binary Recursion (n=7)', 'n': 7, 'entry_func_name': 'B',\n         'graph': {'B': ['B']}, 'entry_node': 'B'},\n        # Exp 3: Mutual recursion, n=6\n        {'name': 'Mutual Recursion (n=6)', 'n': 6, 'entry_func_name': 'A',\n         'graph': {'A': ['B2'], 'B2': ['A']}, 'entry_node': 'A'},\n        # Exp 4: Non-recursive nested calls, n=5\n        {'name': 'Non-recursive Nested (n=5)', 'n': 5, 'entry_func_name': 'F',\n         'graph': {'F': ['G'], 'G': ['H'], 'H': []}, 'entry_node': 'F'},\n        # Exp 5: Mixed case, n=8\n        {'name': 'Mixed (n=8)', 'n': 8, 'entry_func_name': 'E',\n         'graph': {'E': ['R', 'Q'], 'R': ['R'], 'Q': []}, 'entry_node': 'E'},\n    ]\n    \n    results = []\n    monitor = StackMonitor()\n    experiments = Experiments(monitor)\n\n    for case in test_cases:\n        monitor.reset()\n        \n        # Dynamic analysis\n        entry_func = getattr(experiments, case['entry_func_name'])\n        entry_func(case['n'])\n        d_n = monitor.get_max_depth()\n        \n        # Static analysis\n        graph = case['graph']\n        entry_node = case['entry_node']\n        l_g = find_longest_simple_path(graph, entry_node)\n        c = is_cycle_reachable(graph, entry_node)\n        \n        results.append([d_n, l_g, c])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}