{
    "hands_on_practices": [
        {
            "introduction": "在深入研究具体的内存地址计算之前，首先通过一个练习来直观地感受行主序和列主序是如何重新排列矩阵元素的。这个练习借鉴了线性代数中“向量化”的概念，它将矩阵平铺成一个长向量，从而清晰地展示了两种不同存储顺序下元素的排列方式。通过完成这个练习，你将为理解更复杂的地址计算问题建立一个坚实的直观模型。",
            "id": "29608",
            "problem": "在线性代数中，矩阵的向量化是一种将矩阵转换为列向量的线性变换。这个过程在包括矩阵微积分和机器学习在内的许多领域都是基础。向量化一个矩阵有两种常见的方式：行主序和列主序。\n\n**定义：**\n\n1.  **行主序向量化**：对于一个 $m \\times n$ 矩阵 $A$，其行主序向量化（记作 $\\text{vec}_r(A)$）是通过将矩阵的行依次堆叠而得到的 $mn \\times 1$ 列向量。如果 $A = [a_{ij}]$，$\\text{vec}_r(A)$ 的元素按如下顺序排列：\n    $$ \\text{vec}_r(A) = [a_{11}, a_{12}, \\dots, a_{1n}, a_{21}, a_{22}, \\dots, a_{2n}, \\dots, a_{m1}, a_{m2}, \\dots, a_{mn}]^T $$\n\n2.  **列主序向量化**：对于一个 $m \\times n$ 矩阵 $A$，其列主序向量化（记作 $\\text{vec}_c(A)$）是通过将矩阵的列依次堆叠而得到的 $mn \\times 1$ 列向量。如果 $A = [a_{ij}]$，$\\text{vec}_c(A)$ 的元素按如下顺序排列：\n    $$ \\text{vec}_c(A) = [a_{11}, a_{21}, \\dots, a_{m1}, a_{12}, a_{22}, \\dots, a_{m2}, \\dots, a_{1n}, a_{2n}, \\dots, a_{mn}]^T $$\n\n**问题：**\n\n考虑以下带有符号元素的 $2 \\times 3$ 矩阵 $A$：\n$$ A = \\begin{pmatrix} a & b & c \\\\ d & e & f \\end{pmatrix} $$\n令 $\\mathbf{v}_r = \\text{vec}_r(A)$ 和 $\\mathbf{v}_c = \\text{vec}_c(A)$ 分别为 $A$ 的行主序和列主序向量化。\n\n**任务：**\n\n推导标量积（或点积）$S = \\mathbf{v}_r^T \\mathbf{v}_c$ 的简化因式分解表达式。",
            "solution": "问题要求计算给定 $2 \\times 3$ 矩阵 $A$ 的行主序向量化和列主序向量化的标量积。我们将首先确定每种向量化形式，然后计算它们的标量积。\n\n**步骤 1：确定行主序向量化 $\\mathbf{v}_r$。**\n\n矩阵由下式给出：\n$$ A = \\begin{pmatrix} a & b & c \\\\ d & e & f \\end{pmatrix} $$\n根据行主序向量化的定义，我们堆叠矩阵的行。\n第一行是 $[a, b, c]$。\n第二行是 $[d, e, f]$。\n将第二行堆叠在第一行之后，得到列向量 $\\mathbf{v}_r$：\n$$ \\mathbf{v}_r = \\begin{pmatrix} a \\\\ b \\\\ c \\\\ d \\\\ e \\\\ f \\end{pmatrix} $$\n\n**步骤 2：确定列主序向量化 $\\mathbf{v}_c$。**\n\n同样，从矩阵 $A$ 开始：\n$$ A = \\begin{pmatrix} a & b & c \\\\ d & e & f \\end{pmatrix} $$\n根据列主序向量化的定义，我们堆叠矩阵的列。\n第一列是 $\\begin{pmatrix} a \\\\ d \\end{pmatrix}$。\n第二列是 $\\begin{pmatrix} b \\\\ e \\end{pmatrix}$。\n第三列是 $\\begin{pmatrix} c \\\\ f \\end{pmatrix}$。\n按顺序堆叠这些列，得到列向量 $\\mathbf{v}_c$：\n$$ \\mathbf{v}_c = \\begin{pmatrix} a \\\\ d \\\\ b \\\\ e \\\\ c \\\\ f \\end{pmatrix} $$\n\n**步骤 3：计算标量积 $S = \\mathbf{v}_r^T \\mathbf{v}_c$。**\n\n标量积是两个向量对应分量乘积的和。\n$$ S = \\mathbf{v}_r^T \\mathbf{v}_c = \\begin{pmatrix} a & b & c & d & e & f \\end{pmatrix} \\begin{pmatrix} a \\\\ d \\\\ b \\\\ e \\\\ c \\\\ f \\end{pmatrix} $$\n执行矩阵乘法得到：\n$$ S = (a)(a) + (b)(d) + (c)(b) + (d)(e) + (e)(c) + (f)(f) $$\n简化乘积，我们得到：\n$$ S = a^2 + bd + bc + de + ec + f^2 $$\n为了得到一个简化的因式分解表达式，我们可以重新排列各项。我们将平方项和交叉项分组：\n$$ S = a^2 + f^2 + (bc + bd) + (de + ec) $$\n现在，我们可以从括号内的表达式中提取公因式：\n$$ S = a^2 + f^2 + b(c + d) + e(c + d) $$\n最后，我们可以提取公因式 $(c+d)$：\n$$ S = a^2 + f^2 + (b+e)(c+d) $$\n这就是标量积的最终简化和因式分解表达式。",
            "answer": "$$ \\boxed{a^2 + f^2 + (b+e)(c+d)} $$"
        },
        {
            "introduction": "掌握行主序和列主序的核心技能在于能够将二维索引 $(i,j)$ 准确地转换为一维内存偏移量。本练习要求你不再仅仅是记忆公式，而是要从内存连续存储的基本定义出发，亲自推导出两种布局下的索引映射公式。这项实践将帮助你从根本上理解数据在计算机内存中的实际存储方式，这是编写高性能计算代码的关键一步。",
            "id": "3267656",
            "problem": "您的任务是基于数组存储的基本定义，形式化并实现一个感知布局的矩阵索引方案。考虑一个具有 $R$ 行和 $C$ 列的二维（$2$-D）数组（矩阵），它作为单个线性元素序列存储在连续内存中。要使用的核心定义是：连续内存将元素存储为一维序列；有效索引的边界对于行索引 $i$ 和列索引 $j$ 分别为 $0 \\le i  R$ 和 $0 \\le j  C$；布局决定了哪个维度在内存中是连续的。在行主序布局中，整个行是连续的；在列主序布局中，整个列是连续的。没有提供用于将二维索引映射到线性偏移量的公式。\n\n您的任务是仅从上述定义中推导出一个正确的方法，该方法基于参数化的布局标志 $L \\in \\{\\text{RowMajor}, \\text{ColMajor}\\}$，将坐标为 $(i,j)$ 的矩阵元素映射到其线性内存偏移量，并实现一个完整的程序来模拟一个带有布局相关索引的模板类 $\\text{Matrix}\\langle T, R, C, L \\rangle$。该程序必须构建一个类似矩阵的抽象，它：\n- 存储 $R$ 和 $C$ 作为其形状，以及一个布局标志 $L$ 来决定是行连续还是列连续。\n- 为给定的 $(i,j)$ 计算一个线性偏移函数，如果索引在边界内，则返回一个整数偏移量，如果索引越界，则返回哨兵值 $-1$。\n- 提供与索引操作符概念一致的方法，这些方法依赖于此偏移函数，而不依赖任何外部提示或预先推导的公式。\n\n程序不得读取任何输入。相反，它必须执行一个固定的参数值测试套件，并报告计算出的偏移量。使用以下测试套件，其中每个测试用例是一个元组 $(R,C,L,i,j)$：\n- 测试用例 $1$：$(R,C,L,i,j) = (3,4,\\text{RowMajor},2,1)$。\n- 测试用例 $2$：$(R,C,L,i,j) = (3,4,\\text{ColMajor},2,1)$。\n- 测试用例 $3$：$(R,C,L,i,j) = (1,5,\\text{RowMajor},0,3)$。\n- 测试用例 $4$：$(R,C,L,i,j) = (5,1,\\text{ColMajor},4,0)$。\n- 测试用例 $5$：$(R,C,L,i,j) = (3,4,\\text{RowMajor},-1,0)$。\n- 测试用例 $6$：$(R,C,L,i,j) = (3,4,\\text{RowMajor},3,0)$。\n- 测试用例 $7$：$(R,C,L,i,j) = (2,2,\\text{RowMajor},1,1)$。\n- 测试用例 $8$：$(R,C,L,i,j) = (4,3,\\text{ColMajor},3,2)$。\n\n设计您的解决方案以反映不同的方面：\n- 一般情况，其中两个维度都超过 $1$ 并且索引位于内部。\n- 边界条件，包括第一个和最后一个有效元素。\n- 边缘情况，例如单行 ($R=1$) 或单列 ($C=1$)\n- 越界索引，包括负索引和等于维度大小的索引。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表，例如 $\\texttt{[result1,result2,\\dots]}$。结果必须是如上定义的整数，并按与测试套件相同的顺序出现。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于数据结构的基本原理，问题定义良好，有足够的信息得出唯一解，并以客观、正式的语言表达。任务是推导并实现一个从二维数组索引到一维内存偏移量的映射，而不借助预先存在的公式，这是计算机科学中一个标准且有价值的练习。\n\n推导过程从所提供的第一性原理出发。一个 $R$ 行 $C$ 列的二维数组被存储为一个连续的一维内存块。我们寻求一个函数 $\\text{offset}(i, j)$，它将行索引 $i$ 和列索引 $j$（其中 $0 \\le i  R$ 和 $0 \\le j  C$）映射到一个唯一的从 0 开始的线性内存偏移量。该映射由存储布局决定，由参数 $L$ 指定。\n\n首先，一个有效偏移量的必要条件是索引 $(i,j)$ 必须在矩阵定义的边界内。如果 $i  0$、$i \\ge R$、$j  0$ 或 $j \\ge C$ 中任何一个为真，则访问越界。在这种情况下，函数必须返回指定的哨兵值 $-1$。\n\n对于边界内的索引，我们考虑两种可能的布局：$L \\in \\{\\text{RowMajor}, \\text{ColMajor}\\}$。\n\n**行主序布局**\n行主序布局的定义指出，整个行在内存中是连续存储的。这意味着第 $0$ 行的元素后面跟着第 $1$ 行的元素，以此类推。内存被构造为行块的序列：$[\\text{Row}_0, \\text{Row}_1, \\dots, \\text{Row}_{i}, \\dots, \\text{Row}_{R-1}]$。\n要定位在 $(i, j)$ 处的元素，我们必须首先遍历第 $i$ 行之前的所有行。有 $i$ 个这样的行（从第 $0$ 行到第 $i-1$ 行）。每行包含 $C$ 个元素（每列一个）。因此，在这前面的 $i$ 行中的元素数量是 $i \\times C$。这个值构成了到达第 $i$ 行开头的基本偏移量。\n在第 $i$ 行内部，元素按其从 $0$ 到 $C-1$ 的列索引存储。位于第 $j$ 列的元素是此行块内的第 $j$ 个元素（使用从 $0$ 开始的索引）。因此，我们在基本偏移量的基础上再增加一个 $j$ 的偏移量。\n综合这些，行主序布局中位于 $(i,j)$ 的元素的总线性偏移量由前面行的偏移量和当前行内的偏移量之和给出：\n$$\n\\text{offset}_{\\text{row-major}}(i, j) = (i \\times C) + j\n$$\n\n**列主序布局**\n列主序布局的定义指出，整个列是连续存储的。这意味着内存被构造为列块的序列：$[\\text{Col}_0, \\text{Col}_1, \\dots, \\text{Col}_j, \\dots, \\text{Col}_{C-1}]$。\n要定位在 $(i, j)$ 处的元素，我们必须首先遍历第 $j$ 列之前的所有列。有 $j$ 个这样的列（从第 $0$ 列到第 $j-1$ 列）。每列包含 $R$ 个元素（每行一个）。因此，在这前面的 $j$ 列中的元素数量是 $j \\times R$。这个值是到达第 $j$ 列开头的基本偏移量。\n在第 $j$ 列内部，元素按其从 $0$ 到 $R-1$ 的行索引存储。位于第 $i$ 行的元素是此列块内的第 $i$ 个元素（使用从 $0$ 开始的索引）。我们在基本偏移量的基础上再增加一个 $i$ 的偏移量。\n综合这些，列主序布局中位于 $(i,j)$ 的元素的总线性偏移量由下式给出：\n$$\n\\text{offset}_{\\text{col-major}}(i, j) = (j \\times R) + i\n$$\n\n这样就完成了从第一性原理出发的推导。实现将封装这一逻辑，首先执行边界检查，然后根据布局参数 $L$ 应用相应的公式。\n\n问题陈述中的测试用例用于在各种场景下验证此逻辑：\n- **一般情况**：测试用例 $1$ 和 $2$ 使用一个大小为 $3 \\times 4$ 的矩阵和内部索引 $(2,1)$，展示了两种布局之间的根本区别。\n- **最后一个元素**：测试用例 $7$ 和 $8$ 检查内存块中最后一个元素的计算，对于 $2 \\times 2$ 的行主序矩阵是 $(1,1)$，对于 $4 \\times 3$ 的列主序矩阵是 $(3,2)$。\n- **边缘情况**：测试用例 $3$ 和 $4$ 检查实际上是一维向量（单行或单列）的矩阵，以确认公式能正确泛化。\n- **越界索引**：测试用例 $5$ 和 $6$ 验证强制性的边界检查，同时使用了负索引（$-1$）和等于维度大小的索引（对于大小为 $3$ 的维度，索引为 $3$），两者都是无效的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Matrix:\n    \"\"\"\n    Emulates a matrix-like abstraction to compute linear memory offsets\n    based on a parameterized layout (RowMajor or ColMajor).\n    \n    The offset calculation is derived from first principles of data layout.\n    \"\"\"\n    def __init__(self, R: int, C: int, L: str):\n        \"\"\"\n        Initializes the Matrix with its dimensions and layout.\n        \n        Args:\n            R (int): The number of rows.\n            C (int): The number of columns.\n            L (str): The memory layout, \"RowMajor\" or \"ColMajor\".\n        \"\"\"\n        self.R = R\n        self.C = C\n        self.layout = L\n\n    def get_offset(self, i: int, j: int) - int:\n        \"\"\"\n        Computes the linear memory offset for an element at coordinate (i, j).\n        \n        Args:\n            i (int): The row index.\n            j (int): The column index.\n            \n        Returns:\n            int: The 0-based linear offset if indices are valid,\n                 or -1 if indices are out-of-bounds.\n        \"\"\"\n        # Step 1: Validate index bounds as per the problem definition (0 = index  dimension).\n        if not (0 = i  self.R and 0 = j  self.C):\n            return -1\n\n        # Step 2: Apply the derived formula based on the layout.\n        if self.layout == \"RowMajor\":\n            # Formula: offset = (i * C) + j\n            # Derived from skipping 'i' full rows of 'C' elements each,\n            # then moving 'j' elements into the current row.\n            return i * self.C + j\n        elif self.layout == \"ColMajor\":\n            # Formula: offset = (j * R) + i\n            # Derived from skipping 'j' full columns of 'R' elements each,\n            # then moving 'i' elements into the current column.\n            return j * self.R + i\n        else:\n            # This case should not be reached given the problem constraints.\n            # It is included for robustness.\n            raise ValueError(\"Invalid layout specified. Must be 'RowMajor' or 'ColMajor'.\")\n\ndef solve():\n    \"\"\"\n    Executes the fixed test suite and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, C, Layout, i, j)\n    test_cases = [\n        (3, 4, \"RowMajor\", 2, 1),\n        (3, 4, \"ColMajor\", 2, 1),\n        (1, 5, \"RowMajor\", 0, 3),\n        (5, 1, \"ColMajor\", 4, 0),\n        (3, 4, \"RowMajor\", -1, 0),\n        (3, 4, \"RowMajor\", 3, 0),\n        (2, 2, \"RowMajor\", 1, 1),\n        (4, 3, \"ColMajor\", 3, 2),\n    ]\n\n    results = []\n    for R, C, L, i, j in test_cases:\n        # Instantiate the Matrix abstraction for the current test case.\n        matrix = Matrix(R, C, L)\n        # Compute the offset using the derived logic.\n        offset = matrix.get_offset(i, j)\n        results.append(offset)\n\n    # Final print statement in the exact required format: [result1,result2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver function.\nsolve()\n```"
        },
        {
            "introduction": "检验你是否真正理解一个概念的最好方法之一，就是看你是否能逆向运用它。这个问题模拟了一个真实场景：系统程序员需要根据观测到的内存地址来推断数据的存储布局。你需要将之前推导的地址计算公式作为待检验的假设，通过解方程来确定未知的矩阵维度和布局，这将极大地锻炼你的分析和问题解决能力。",
            "id": "3267817",
            "problem": "一个由4字节整数组成的二维数组 $A$ 在内存中连续存储，两个维度都使用从零开始的索引。该数组是矩形的，具有固定的、未知的行数 $R$ 和列数 $C$，并且行与行或列与列之间没有填充。给出了两个观察到的内存地址：$A[2][1]$ 的地址是 $1024$，$A[3][3]$ 的地址是 $1048$，单位为字节，从一个固定的原点开始计算。存储顺序为行主序（逐行排列；同一行内的连续元素在内存中是相邻的）或列主序（逐列排列；同一列内的连续元素在内存中是相邻的）。假设所有地址都是精确的，并且 $R$ 和 $C$ 都是正整数。\n\n仅使用这些基本定义，判断该布局必须是行主序还是列主序，评估在给定假设下此判断是否确定，然后计算 $A[0][0]$ 的基地址 $B$（以字节为单位）。用字节表示最终的基地址。无需四舍五入。",
            "solution": "该问题要求我们根据一个二维数组 $A$ 中两个元素的内存地址，来确定其存储布局（行主序或列主序）和基地址。\n\n让我们正式陈述给定的条件：\n- 数组为 $A[R][C]$，其中 $R$ 是行数，$C$ 是列数。\n- $R$ 和 $C$ 是正整数。\n- 索引从零开始，因此对于元素 $A[i][j]$，行索引 $i$ 的范围是 $0$ 到 $R-1$，列索引 $j$ 的范围是 $0$ 到 $C-1$。\n- 每个元素（一个4字节整数）的大小为 $S = 4$ 字节。\n- 基地址，即第一个元素 $A[0][0]$ 的地址，用 $B$ 表示。\n- 我们有两个给定的数据点：\n  1. $A[2][1]$ 的地址是 $1024$。\n  2. $A[3][3]$ 的地址是 $1048$。\n\n元素 $A[2][1]$ 和 $A[3][3]$ 的存在意味着数组维度必须至少为 $R \\ge 4$ 和 $C \\ge 4$。\n\n我们将分析两个互斥的假设：数组以行主序存储，或者以列主序存储。\n\n**假设1：行主序**\n\n在行主序中，元素 $A[i][j]$ 的地址由以下公式计算：\n$$ \\text{address}(A[i][j]) = B + (i \\cdot C + j) \\cdot S $$\n其中 $i$ 是行索引，$j$ 是列索引，$C$ 是总列数，$S$ 是元素大小。\n\n将给定值代入此公式：\n对于 $A[2][1]$：\n$$ \\text{address}(A[2][1]) = B + (2 \\cdot C + 1) \\cdot 4 = 1024 \\quad (1) $$\n对于 $A[3][3]$：\n$$ \\text{address}(A[3][3]) = B + (3 \\cdot C + 3) \\cdot 4 = 1048 \\quad (2) $$\n\n我们得到一个包含两个未知数 $B$ 和 $C$ 的二元线性方程组。为了求解 $C$，我们可以用方程 $(2)$ 减去方程 $(1)$：\n$$ [B + (3C + 3) \\cdot 4] - [B + (2C + 1) \\cdot 4] = 1048 - 1024 $$\n$$ B + 12C + 12 - B - 8C - 4 = 24 $$\n$$ 4C + 8 = 24 $$\n$$ 4C = 16 $$\n$$ C = 4 $$\n\n结果 $C=4$ 是一个正整数，这与问题的约束条件一致。它也满足从给定索引得出的条件 $C \\ge 4$。\n\n现在，我们可以将 $C=4$ 代回方程 $(1)$ 来求基地址 $B$：\n$$ B + (2 \\cdot 4 + 1) \\cdot 4 = 1024 $$\n$$ B + (8 + 1) \\cdot 4 = 1024 $$\n$$ B + 9 \\cdot 4 = 1024 $$\n$$ B + 36 = 1024 $$\n$$ B = 1024 - 36 $$\n$$ B = 988 $$\n\n因此，行主序的假设得出了一个有效的解：$C=4$ 和 $B=988$ 字节。\n\n**假设2：列主序**\n\n在列主序中，元素 $A[i][j]$ 的地址由以下公式计算：\n$$ \\text{address}(A[i][j]) = B + (j \\cdot R + i) \\cdot S $$\n其中 $i$ 是行索引，$j$ 是列索引，$R$ 是总行数，$S$ 是元素大小。\n\n将给定值代入此公式：\n对于 $A[2][1]$：\n$$ \\text{address}(A[2][1]) = B + (1 \\cdot R + 2) \\cdot 4 = 1024 \\quad (3) $$\n对于 $A[3][3]$：\n$$ \\text{address}(A[3][3]) = B + (3 \\cdot R + 3) \\cdot 4 = 1048 \\quad (4) $$\n\n我们现在得到一个包含两个未知数 $B$ 和 $R$ 的二元线性方程组。为了求解 $R$，我们可以用方程 $(4)$ 减去方程 $(3)$：\n$$ [B + (3R + 3) \\cdot 4] - [B + (R + 2) \\cdot 4] = 1048 - 1024 $$\n$$ B + 12R + 12 - B - 4R - 8 = 24 $$\n$$ 8R + 4 = 24 $$\n$$ 8R = 20 $$\n$$ R = \\frac{20}{8} = \\frac{5}{2} = 2.5 $$\n\n结果 $R=2.5$ 不是一个整数。这与行数 $R$ 必须是正整数的前提相矛盾。因此，列主序的假设是无效的。\n\n**结论**\n\n分析表明，只有行主序布局的假设与给定的信息和约束条件一致。列主序布局导致矛盾。因此，存储顺序为行主序的判断是确定的。从行主序模型推导出的唯一解给出列数为 $C=4$，数组 $A[0][0]$ 的基地址为 $B=988$ 字节。\n\n问题要求 $A[0][0]$ 的基地址 $B$。根据我们确凿的推理，这个值是 $988$。",
            "answer": "$$\\boxed{988}$$"
        }
    ]
}