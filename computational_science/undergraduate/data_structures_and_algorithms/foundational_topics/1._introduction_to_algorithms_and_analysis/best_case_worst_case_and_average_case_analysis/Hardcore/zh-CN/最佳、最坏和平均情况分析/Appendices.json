{
    "hands_on_practices": [
        {
            "introduction": "掌握算法分析的关键在于从理论走向实践。我们将从对一个核心算法——快速选择（Quickselect）——的性能分析开始。这个练习要求你深入剖析其在最好、最坏和平均情况下的表现，从而体会到不同输入如何导致其性能从线性时间 $O(n)$ 到二次时间 $O(n^2)$ 的巨大差异。",
            "id": "3214466",
            "problem": "给定一个包含 $n$ 个不同关键字的数组。考虑使用 Quickselect 算法来查找第 $k$ 小的关键字，其中每次分区操作都会将选定的基准与当前子数组中的所有其他元素精确比较一次，并且每个子问题的基准是从该子问题的元素中均匀随机选择的。假设在随机存取机器（RAM）模型下，成本度量是关键字比较的次数。\n\n从 Quickselect 和期望算子的核心定义出发，完成以下任务：\n\n- 形式化地定义在大小为 $m$ 的子数组上执行一次分区步骤所做的比较次数。\n- 从第一性原理出发，推导 Quickselect 在大小为 $n$ 的数组中找到第 $k$ 小元素所需的最佳情况和最差情况下的比较次数，并表示为 $n$ 的函数（您可以假设 $1 \\leq k \\leq n$ 是固定的）。\n- 令 $A(n)$ 表示当 $k$ 本身是从 $\\{1,2,\\dots,n\\}$ 中均匀随机选择，并且每次递归的基准也是均匀随机选择时，Quickselect 找到第 $k$ 小元素所做的期望比较次数。仅使用基本定义和期望的线性性质，推导 $A(n)$ 的递推关系，并确定当 $n \\to \\infty$ 时，线性渐近式 $A(n) \\sim c n$ 中的首项系数 $c$。\n\n将 $c$ 的值作为您的最终答案。不需要四舍五入，最终答案中也不应包含任何单位。",
            "solution": "Quickselect 的工作原理是选择一个基准，围绕该基准对当前子数组进行分区，然后在可能包含第 $k$ 小元素的那一半中递归地继续。我们只计算关键字的比较次数。我们使用的基本事实是：对于一个大小为 $m$ 的子数组，分区操作会将基准与其余的 $m-1$ 个元素各比较一次，以及用于平均情况分析的期望线性性质。\n\n在大小为 $m$ 的子数组上执行一次分区步骤，会进行恰好 $m-1$ 次比较。这是根据分区例程的定义得出的，该例程会扫描子数组，将每个非基准元素与基准比较一次。\n\n最佳情况分析：对于大小为 $n$ 的输入，最佳情况发生在第一次调用时选择的基准的秩恰好为 $k$。在这种情况下，算法对整个数组执行一次分区，耗费 $n-1$ 次比较，然后停止。因此，最佳情况下的比较次数是 $n-1$。\n\n最差情况分析：最差情况发生在每一步选择的基准相对于目标秩都是最差的，因此递归子问题的规模每次都恰好减少 1（例如，总是从大小为 $m$ 的问题递归到大小为 $m-1$ 的子问题）。总比较次数是所有层级分区成本的总和：\n$$\n\\sum_{m=2}^{n} (m-1) \\;=\\; \\sum_{j=1}^{n-1} j \\;=\\; \\frac{n(n-1)}{2}.\n$$\n因此，最差情况下的比较次数是 $\\frac{n(n-1)}{2}$。\n\n平均情况设置：令 $A(n)$ 为当 $k$ 在 $\\{1,2,\\dots,n\\}$ 中均匀随机，且每次递归中的基准也均匀随机选择时，找到第 $k$ 小元素的期望比较次数。我们使用全期望定律，通过对基准的秩进行条件化来推导 $A(n)$ 的递推关系。\n\n设基准的秩为 $r \\in \\{1,2,\\dots,n\\}$，均匀随机选择。顶层分区的成本为 $n-1$ 次比较，无论 $r$ 或 $k$ 是多少。如果 $r=k$，算法停止。如果 $r  k$，算法在大小为 $n-r$ 的右子数组中递归。如果 $r > k$，算法在大小为 $r-1$ 的左子数组中递归。\n\n我们对基准的秩 $r$ 和目标秩 $k$ 的所有选择取平均。\n$A(n) = n-1 + \\frac{1}{n^2} \\sum_{r=1}^{n} \\sum_{k=1}^{n} E[\\text{成本} | r, k]$\n其中 $E[\\text{成本} | r, k]$ 是在基准秩为 $r$、目标秩为 $k$ 时的递归成本。\n$E[\\text{成本} | r, k] = A(r-1)$ 如果 $k  r$，\n$E[\\text{成本} | r, k] = 0$ 如果 $k = r$，\n$E[\\text{成本} | r, k] = A(n-r)$ 如果 $k > r$。\n因此，\n$$ A(n) = n-1 + \\frac{1}{n^2} \\sum_{r=1}^{n} \\left( \\sum_{k=1}^{r-1} A(r-1) + \\sum_{k=r+1}^{n} A(n-r) \\right) $$\n$$ A(n) = n-1 + \\frac{1}{n^2} \\sum_{r=1}^{n} \\left( (r-1)A(r-1) + (n-r)A(n-r) \\right) $$\n由于求和变量是虚拟的，$\\sum_{r=1}^{n} (n-r)A(n-r)$ 等价于 $\\sum_{j=0}^{n-1} j A(j)$（令 $j=n-r$）。同样，$\\sum_{r=1}^{n} (r-1)A(r-1)$ 也等价于 $\\sum_{j=0}^{n-1} j A(j)$。\n所以递推关系为：\n$$ A(n) = n-1 + \\frac{2}{n^2} \\sum_{j=0}^{n-1} j A(j) $$\n为了求解这个递推关系的首项系数，我们假设 $A(n) \\sim cn$。将这个渐近式代入：\n$$ cn \\approx n-1 + \\frac{2}{n^2} \\sum_{j=1}^{n-1} j(cj) = n-1 + \\frac{2c}{n^2} \\sum_{j=1}^{n-1} j^2 $$\n使用平方和公式 $\\sum_{j=1}^{m} j^2 = \\frac{m(m+1)(2m+1)}{6} \\approx \\frac{m^3}{3}$，我们得到：\n$$ cn \\approx n + \\frac{2c}{n^2} \\cdot \\frac{(n-1)^3}{3} \\approx n + \\frac{2c}{n^2} \\cdot \\frac{n^3}{3} = n + \\frac{2cn}{3} $$\n求解 $c$：\n$$ cn - \\frac{2cn}{3} \\approx n \\implies \\frac{cn}{3} \\approx n \\implies c = 3 $$\n因此，线性渐近式 $A(n) \\sim cn$ 的首项系数是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "理解最坏情况分析的下一步是学会如何主动构造出这样的场景。本练习将挑战你为伸展树（splay tree）设计一个“对抗性”的输入序列，该序列会迫使这种灵活的自适应数据结构退化为最低效的链状形态。通过这个过程，你将能更深刻地理解算法的性能边界以及摊还分析的价值所在。",
            "id": "3214330",
            "problem": "给定一个初始为空的伸展树，它支持插入和搜索操作。操作方式是先执行标准的二叉搜索树（BST）插入，然后使用经典的自底向上伸展操作将访问过或新插入的节点伸展到根节点。这些伸展操作包括：单旋转（zig）、同向双旋转（zig-zig）和异向双旋转（zig-zag）。旋转是标准的局部BST旋转，它能保持BST的有序性。假设采用精确的单位成本模型，其中单次访问（一次搜索操作）的成本是向下查找过程中执行的键值比较总数，加上将访问节点伸展到根节点过程中执行的旋转总数。所有键值都是唯一的。\n\n您的任务是：\n- 设计一个包含 $n$ 个不同键值的明确插入序列，在第 $n$ 次插入及其结尾的伸展操作之后，能得到一个底层BST形态为简单路径（即退化树，结构上等同于一个链表）的伸展树。\n- 证明您的构造确实会产生这样一种退化形态。\n- 使用上述成本模型，计算在第 $n$ 次插入完成后立即访问最小键值的单次操作的精确成本。请用一个关于 $n$ 的封闭形式函数表示您的最终答案。\n\n您的最终答案必须是一个关于 $n$ 的单一封闭形式表达式。无需四舍五入。最终答案中不要包含单位。",
            "solution": "用户要求一个关于伸展树的三部分解答：1) 一个能产生退化树的 $n$ 个键值的插入序列，2) 对该序列的证明，以及 3) 在生成的树中访问最小键值的成本。成本由一个特定的模型定义。\n\n首先，我们设计插入序列。我们建议将键值 $1, 2, 3, \\ldots, n$ 按严格递增的顺序插入一个初始为空的伸展树中。现在我们将证明这个序列会产生一个简单路径的树结构。我们使用数学归纳法来证明。\n\n设 $P(k)$ 为一个命题：在按顺序插入键值 $1, 2, \\ldots, k$ 后，得到的伸展树是一个“左倾链”，其中节点 $k$ 是根节点，节点 $k-1$ 是节点 $k$ 的左孩子，并且通常来说，对于所有 $i \\in \\{2, \\ldots, k\\}$，节点 $i-1$ 是节点 $i$ 的左孩子。这种结构是一条简单路径。\n\n**基础情况：** 对于 $k=1$，我们将键值 $1$ 插入一个空树。得到的树是一个包含键值 $1$ 的单节点树。这是一条长度为 $1$ 的简单路径，因此 $P(1)$ 成立。\n\n**归纳假设：** 假设对于某个整数 $k \\geq 1$，命题 $P(k)$ 为真。也就是说，在按顺序插入键值 $1, 2, \\ldots, k$ 之后，伸展树是一个以 $k$ 为根的左倾链。\n\n**归纳步骤：** 现在我们插入键值 $k+1$。\n$1$. **BST 插入：** 插入过程从当前树的根节点（即节点 $k$）开始。由于待插入的键值 $k+1$ 大于根节点的键值 $k$，算法尝试移至右孩子。根据归纳假设，根节点 $k$ 没有右孩子。因此，创建一个包含键值 $k+1$ 的新节点，并使其成为节点 $k$ 的右孩子。\n$2$. **伸展操作：** 插入后，新添加的节点 $k+1$ 被伸展到根节点。此时，节点 $k+1$ 是根节点 $k$ 的右孩子。由于其父节点是树的根，所以它没有祖父节点。这种情况会触发一次 **zig** 操作。\n$3$. **旋转：** 对右孩子执行的 `zig` 操作包含一次围绕其父节点的左旋。我们在节点 $k$ 上执行一次左旋。这个操作使 $k+1$ 成为树的新根节点。原根节点 $k$ 成为新根节点 $k+1$ 的左孩子。根据归纳假设，$k$ 的原始左子树是左倾链 $1 \\leftarrow 2 \\leftarrow \\dots \\leftarrow (k-1)$，它仍然是节点 $k$ 的左子树。\n$4$. **结果结构：** 最终的树以 $k+1$ 为根。它的左孩子是 $k$，$k$ 的左孩子是 $k-1$，依此类推，直到叶节点 $1$。这种结构是一个左倾链，$1 \\leftarrow 2 \\leftarrow \\dots \\leftarrow (k+1)$。因此，命题 $P(k+1)$ 成立。\n\n根据数学归纳法原理，按递增顺序插入键值 $1, 2, \\ldots, n$ 会得到一个以 $n$ 为根的简单路径（一个左倾链）的伸展树。\n\n接下来，我们计算在该树上访问最小键值 $1$ 的单次操作成本。成本是搜索过程中的键值比较次数与随后的伸展过程中的旋转次数之和。\n\n**1. 键值比较次数：**\n该树是一个以 $n$ 为根的左倾链。为了定位键值 $1$，搜索算法从根节点 $n$ 开始，沿着左孩子指针链一直找到节点 $1$。搜索路径为 $n \\rightarrow (n-1) \\rightarrow (n-2) \\rightarrow \\dots \\rightarrow 2 \\rightarrow 1$。在所有这 $n$ 个节点上都进行了一次键值比较。\n因此，键值比较的次数为 $n$。\n\n**2. 旋转次数：**\n找到节点 $1$ 后，它被伸展到根节点。初始时，节点 $1$ 的深度为 $n-1$。从节点 $1$ 到根节点的路径完全由“是……的左孩子”关系构成。伸展过程包含一系列将节点 $1$ 提升至根节点的步骤。\n设 $x$ 是被伸展的节点（$x=1$），$p$ 是其父节点，$g$ 是其祖父节点。\n-   只要 $x$ 有祖父节点，其结构总是 $x$ 是 $p$ 的左孩子，而 $p$ 是 $g$ 的左孩子。这是 **zig-zig** 情况，涉及两次旋转。每个 `zig-zig` 步骤将 $x$ 向根节点提升两层。这个过程重复 $\\lfloor \\frac{n-1}{2} \\rfloor$ 次。\n-   在一系列的 `zig-zig` 步骤之后，节点 $1$ 要么在根节点位置（如果 $n-1$ 是偶数），要么是根节点的直接孩子（如果 $n-1$ 是奇数）。如果它是根节点的孩子，那么它的父节点就是根节点，因此需要执行最后一次 **zig** 步骤，这涉及一次旋转。\n\n总旋转次数是所有 `zig-zig` 步骤和可能的 `zig` 步骤的旋转次数之和：\n$$ \\text{Number of rotations} = 2 \\times \\left\\lfloor \\frac{n-1}{2} \\right\\rfloor + ((n-1) \\pmod 2) $$\n对于任何整数 $n \\geq 1$，这个表达式是一个标准的恒等式，可以简化为 $n-1$。\n-   如果 $n-1$ 是偶数，设 $n-1 = 2k$（其中 $k$ 为某个整数）。旋转次数为 $2 \\times k + 0 = 2k = n-1$。\n-   如果 $n-1$ 是奇数，设 $n-1 = 2k+1$（其中 $k$ 为某个整数）。旋转次数为 $2 \\times k + 1 = 2k+1 = n-1$。\n因此，在伸展过程中执行的总旋转次数恰好是 $n-1$。\n\n**3. 总成本：**\n访问的总成本是键值比较次数和旋转次数的总和。\n$$ \\text{Cost} = (\\text{Number of Comparisons}) + (\\text{Number of Rotations}) $$\n$$ \\text{Cost} = n + (n-1) $$\n$$ \\text{Cost} = 2n - 1 $$\n这就是所要求的成本关于 $n$ 的封闭形式表达式。",
            "answer": "$$\\boxed{2n-1}$$"
        },
        {
            "introduction": "最坏情况分析不仅限于排序和搜索等经典问题，它在各种实际应用中都至关重要。这个练习将引导你探索 LZW 数据压缩算法的一个“病态”输入。你的任务是设计一个文件，它在压缩后反而会变得更大，这个反直觉的结果揭示了理解算法在所有可能输入下的行为是多么重要。",
            "id": "3214412",
            "problem": "考虑如下为面向字节的文件定义的 Lempel–Ziv–Welch (LZW) 压缩算法。输入字母表是所有字节值的集合，因此字母表大小为 $256$。编码器将其字典初始化为恰好包含 $256$ 个单字节字符串，每个字符串映射到一个唯一的编码。在整个运行过程中，编码器对每个输出编码都使用 $12$ 比特的定长编码。没有特殊的控制码（没有清除码，也没有信息结束码）。在每一步中，编码器输出与当前输入前缀匹配的最长字典短语的编码，然后将该短语与下一个输入符号（如果还有的话）的拼接添加到字典中，并把输入光标移过匹配的短语。\n\n利用数据结构与算法中最坏情况分析的核心定义（即，在给定大小的所有输入中最大的资源使用量），结合上述 LZW 规范，设计一个长度为 $N = 50{,}000$ 字节的文件，使其在 LZW 压缩后变得更大。你的设计必须确保在编码过程中，每一步的最长匹配长度都为 $1$。你可以假设存在字节字母表上的序列，其中所有相邻对都是唯一的；例如，任何枚举不重复的不同相邻对的序列的长度为 $N$ 的前缀都是可接受的。请证明为什么你的设计确实迫使编码器为每个输入字节恰好输出一个编码。然后，计算压缩相对于原始文件大小所产生的确切额外比特数。用比特表示最终的大小差异。无需四舍五入，你必须以单个实数值的形式提供最终答案。",
            "solution": "分析的基本依据是算法分析中最坏情况行为的定义：对于给定的输入大小，最坏情况是指在所有有效输入中的最大成本（此处指最大压缩后大小）。我们还依赖于 Lempel–Ziv–Welch (LZW) 压缩的标准操作，即使用 $12$ 比特的定长编码、包含所有 $256$ 个单字节字符串的初始字典以及贪心最长匹配规则。我们的目标是展示一个输入，其结构迫使编码器以每个输入字节产生最大输出长度的方式运行。\n\n设输入为一个长度为 $N = 50{,}000$ 字节、基于 $256$ 符号字母表的序列 $S$。我们设计 $S$，使得对于 $i \\in \\{1, 2, \\dots, N-1\\}$，每个相邻字节对 $(S[i], S[i+1])$ 都是唯一的；也就是说，在 $S$ 中的任何位置，连续符号的有序对都不会重复。这样的序列是存在的，因为在一个 $256$ 符号字母表上，不同有序对的数量为 $256^{2} = 65{,}536$，这超过了 $N-1 = 49{,}999$，所以我们可以选择一个枚举不重复的不同对的序列的任意长度为 $N$ 的前缀。一个构造性的观点是考虑一个有向多重图，其顶点是 $256$ 个符号，其边代表有序对；一次欧拉遍历可以在不重复的情况下访问所有边，从而产生一个每个对恰好出现一次的循环序列。取该循环的任意长度为 $N$ 的段，即可实现该段内所有相邻对都唯一所需的目标属性。\n\n我们现在证明，在此设计下，LZW 编码器为每个输入字节恰好输出一个编码。编码器开始时，其字典包含所有单字节字符串。在编码开始时，考虑指向 $S$ 中当前位置 $i$ 的指针。由于字典最初只包含单字节短语，在位置 $i$ 处与输入前缀匹配的最长字典短语是单个符号 $S[i]$。编码器输出 $S[i]$ 的编码，然后（根据 LZW 的更新规则）将匹配的短语 $S[i]$ 与下一个符号 $S[i+1]$ 拼接形成的短语，即双字节字符串 $S[i]S[i+1]$，插入字典中，前提是 $i+1 \\le N$。然后编码器前进到下一个位置 $i' = i+1$。\n\n在位置 $i'$，字典现在包含了新添加的双字节短语 $S[i]S[i+1]$。然而，编码器尝试匹配从 $S[i'] = S[i+1]$ 开始的最长短语。从 $i'$ 开始可能匹配的唯一双字节短语是 $S[i+1]S[i+2]$。根据 $S$ 的设计，所有相邻对都是唯一的。因此，除非紧邻其前的字节对 $S[i]S[i+1]$ 恰好等于 $S[i+1]S[i+2]$（在所有字节对都唯一的情况下这是不可能的），否则双字节短语 $S[i+1]S[i+2]$ 尚未在字典中。因此，在位置 $i'$ 的最长匹配长度同样为 $1$，即单字节 $S[i+1]$。编码器输出 $S[i+1]$ 的编码，并将新的双字节短语 $S[i+1]S[i+2]$ 插入字典。这个论证对每个后续位置都成立，因为设计保证了在 $S$ 中没有任何两个相邻对是相等的。通过对从 $1$ 到 $N$ 的 $i$ 进行归纳，每一步的最长匹配长度都为 $1$，并且编码器为每个输入字节恰好输出一个编码。因此，输出编码的总数恰好为 $N$。\n\n鉴于使用定长的 $12$ 比特编码，压缩后的大小 $C$ (以比特为单位) 是\n$$\nC = 12 \\cdot N.\n$$\n原始文件由 $N$ 个字节组成，因此其大小 $O$ (以比特为单位) 是\n$$\nO = 8 \\cdot N.\n$$\n压缩相对于原始文件产生的额外比特数是\n$$\n\\Delta = C - O = 12 \\cdot N - 8 \\cdot N = 4 \\cdot N.\n$$\n代入 $N = 50{,}000$ 得出\n$$\n\\Delta = 4 \\cdot 50{,}000 = 200{,}000.\n$$\n因此，所设计的输入触发了此定长 LZW 变体的最坏情况行为，比原始文件多产生 $200{,}000$ 比特。最终答案，以比特表示，是 $200{,}000$。",
            "answer": "$$\\boxed{200000}$$"
        }
    ]
}