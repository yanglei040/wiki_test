{
    "hands_on_practices": [
        {
            "introduction": "我们从一个简单的系统开始建立对电子定域函数 (ELF) 的直观理解。氦二聚体 ($He_2$) 是一个经典的弱键合范德华斯复合物的例子。这项练习  使用一个简化的原子密度叠加模型来计算沿核间轴的 ELF，帮助我们回答一个基本问题：在这样一个非成键体系中，电子更倾向于定域在原子核附近还是原子之间的区域？",
            "id": "2454950",
            "problem": "要求您实现一个程序，用于计算氦二聚体（表示为 $He_2$）简化模型的电子定域函数 (ELF)。全程使用原子单位。所有距离必须以玻尔 (bohr) 表示，所有密度和能量必须以原子单位表示。ELF 是无量纲的。您的程序必须计算四舍五入到 $6$ 位小数的值，布尔值必须打印为 Python 风格的 $True$ 或 $False$。\n\n考虑两个氦原子，沿 $x$ 轴分开，核间距为 $R$，原子核固定在 $x_A=-R/2$ 和 $x_B=+R/2$ 的位置。每个氦原子通过一个归一化的斯莱特型 (Slater-type) $1s$ 轨道进行建模，该轨道以其原子核为中心，指数为 $\\zeta>0$，\n$$\n\\phi(\\mathbf{r};\\zeta) \\;=\\; \\left(\\frac{\\zeta^3}{\\pi}\\right)^{1/2} \\exp\\!\\big(-\\zeta\\, r\\big),\n$$\n其中 $r$ 是到相应原子核的距离。假设系统为闭壳层、自旋非极化的，每个原子有两个电子，并忽略两个中心之间的轨道重叠和干涉，因此占据的空间轨道严格定域在各自的原子核上。在此独立原子叠加近似下，点 $\\mathbf{r}$ 处的总电子密度为\n$$\n\\rho(\\mathbf{r}) \\;=\\; 2\\,\\phi_A(\\mathbf{r})^2 \\;+\\; 2\\,\\phi_B(\\mathbf{r})^2,\n$$\n其中 $\\phi_A$ 和 $\\phi_B$ 分别是以 $x_A$ 和 $x_B$ 为中心的轨道。\n\n沿核间轴计算所有量。对于坐标为 $x$ 的点，距离为 $r_A = |x - x_A|$ 和 $r_B = |x - x_B|$。对于自旋非极化系统，在三维空间中使用标准的基于轨道的定义：\n- Kohn-Sham 动能密度为\n$$\n\\tau(x) \\;=\\; \\frac{1}{2} \\sum_{i,\\sigma} \\big|\\nabla \\psi_{i\\sigma}(x)\\big|^2,\n$$\n在上述具有两个双占据的定域空间轨道 $\\phi_A$ 和 $\\phi_B$ 的模型下，该式简化为\n$$\n\\tau(x) \\;=\\; \\big|\\nabla \\phi_A(x)\\big|^2 \\;+\\; \\big|\\nabla \\phi_B(x)\\big|^2.\n$$\n对于 $1s$ 斯莱特型轨道，$\\big|\\nabla \\phi\\big|^2 = \\zeta^2\\,\\phi^2$。\n- von Weizsäcker 动能密度为\n$$\n\\tau_W(x) \\;=\\; \\frac{|\\nabla \\rho(x)|^2}{8\\,\\rho(x)}.\n$$\n- 均匀电子气参考动能密度为\n$$\n\\tau_h(x) \\;=\\; \\frac{3}{10}\\,\\big(3\\pi^2\\big)^{2/3}\\,\\rho(x)^{5/3}.\n$$\n\n定义\n$$\nD(x) \\;=\\; \\tau(x) \\;-\\; \\tau_W(x),\n$$\n电子定域函数 (Electron Localization Function) 为\n$$\n\\mathrm{ELF}(x) \\;=\\; \\frac{1}{1 + \\left(\\dfrac{D(x)}{\\tau_h(x)}\\right)^2 }.\n$$\n\n沿核间轴，为每个测试用例计算以下三个 ELF 值：\n- 中点值 $\\mathrm{ELF}_{\\text{mid}} = \\mathrm{ELF}(x=0)$。\n- 近核值，为避免原子核处的方向模糊性，取值点无限趋近于键合区，\n$$\n\\mathrm{ELF}_{\\text{left}} = \\mathrm{ELF}\\!\\big(x = -R/2 + \\varepsilon\\big), \\quad \\mathrm{ELF}_{\\text{right}} = \\mathrm{ELF}\\!\\big(x = +R/2 - \\varepsilon\\big),\n$$\n其中 $\\varepsilon = 10^{-6}$ 玻尔。\n\n对于每个测试用例，还需返回布尔值\n$$\nb \\;=\\; \\left(\\mathrm{ELF}_{\\text{mid}} \\;>\\; \\frac{\\mathrm{ELF}_{\\text{left}} + \\mathrm{ELF}_{\\text{right}}}{2}\\right),\n$$\n该值回答了在此模型中，电子在键中点的定域程度是否高于在原子核芯附近的定域程度。\n\n测试套件（每个用例是一对 $(R,\\zeta)$，单位分别为玻尔和玻尔$^{-1}$）：\n- 用例 1：$R=5.6$, $\\zeta=1.6875$。\n- 用例 2：$R=3.0$, $\\zeta=1.6875$。\n- 用例 3：$R=10.0$, $\\zeta=1.6875$。\n\n您的程序必须输出一行，包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个形式如下的子列表\n$$\n\\big[\\mathrm{ELF}_{\\text{mid}},\\;\\mathrm{ELF}_{\\text{left}},\\;\\mathrm{ELF}_{\\text{right}},\\;b\\big],\n$$\n每个浮点值都四舍五入到 $6$ 位小数。例如，最终输出格式必须为：\n$$\n\\big[ [v_{11},v_{12},v_{13},b_1],\\;[v_{21},v_{22},v_{23},b_2],\\;[v_{31},v_{32},v_{33},b_3] \\big].\n$$",
            "solution": "问题陈述经确认为具有科学依据、阐述清晰且客观。它提出了一个基于密度泛函理论概念的标准计算化学练习。所有必要的参数和定义都已提供，不存在内部矛盾或逻辑缺陷。该模型虽然是简化的，但也是一个有效的原分子近似。问题是可解的。\n\n以下是求解的逐步推理过程。\n\n目标是为氦二聚体 $\\mathrm{He}_2$ 的简化模型计算电子定域函数 (ELF)。两个氦原子核 $A$ 和 $B$ 位于 $x$ 轴上的 $x_A = -R/2$ 和 $x_B = +R/2$ 位置，其中 $R$ 是核间距。所有计算均在原子单位下进行。\n\n首先，我们为核间轴上坐标为 $x$ 的点定义所有量的数学表达式。该点到原子核 $A$ 的距离是 $r_A = |x - x_A| = |x + R/2|$，到原子核 $B$ 的距离是 $r_B = |x - x_B| = |x - R/2|$。\n\n电子结构由两个双占据的、归一化的 $1s$ 斯莱特型轨道 (STO) $\\phi_A$ 和 $\\phi_B$ 近似，它们分别以每个原子核为中心。一个通用的 $1s$ STO 由下式给出：\n$$\n\\phi(\\mathbf{r};\\zeta) = \\left(\\frac{\\zeta^3}{\\pi}\\right)^{1/2} \\exp(-\\zeta r)\n$$\n总电子密度 $\\rho(x)$ 是每个原子密度的叠加：\n$$\n\\rho(x) = 2\\,\\phi_A(x)^2 + 2\\,\\phi_B(x)^2\n$$\n我们将每个原子的分量定义为 $f_A(x) = 2\\,\\phi_A(x)^2$ 和 $f_B(x) = 2\\,\\phi_B(x)^2$。因此，$\\rho(x) = f_A(x) + f_B(x)$。具体表达式为：\n$$\nf_A(x) = 2 \\left(\\frac{\\zeta^3}{\\pi}\\right) \\exp(-2\\zeta r_A) \\quad \\text{和} \\quad f_B(x) = 2 \\left(\\frac{\\zeta^3}{\\pi}\\right) \\exp(-2\\zeta r_B)\n$$\n\n计算 ELF 需要几种动能密度泛函。\n1. Kohn-Sham 动能密度 $\\tau(x)$，对于这个具有两个双占据轨道 $\\phi_A$ 和 $\\phi_B$ 的自旋非极化系统，其表达式为：\n$$\n\\tau(x) = |\\nabla \\phi_A(x)|^2 + |\\nabla \\phi_B(x)|^2\n$$\n对于 $1s$ STO，已知 $|\\nabla \\phi|^2 = \\zeta^2 \\phi^2$。因此，\n$$\n\\tau(x) = \\zeta^2 \\phi_A(x)^2 + \\zeta^2 \\phi_B(x)^2 = \\frac{\\zeta^2}{2} (2\\phi_A(x)^2 + 2\\phi_B(x)^2) = \\frac{\\zeta^2}{2}\\rho(x)\n$$\n\n2. von Weizsäcker 动能密度 $\\tau_W(x)$ 为：\n$$\n\\tau_W(x) = \\frac{|\\nabla \\rho(x)|^2}{8\\,\\rho(x)}\n$$\n我们需要密度沿轴的梯度 $\\frac{d\\rho}{dx}$。对于任意点 $x \\in (-R/2, R/2)$，我们有 $x+R/2 > 0$ 和 $x-R/2  < 0$。其导数为：\n$$\n\\frac{d\\rho}{dx} = \\frac{d}{dx} \\left(f_A(x) + f_B(x)\\right) = -2\\zeta \\cdot \\text{sgn}(x+R/2) \\cdot f_A(x) - 2\\zeta \\cdot \\text{sgn}(x-R/2) \\cdot f_B(x) = -2\\zeta \\left(f_A(x) - f_B(x)\\right)\n$$\n因此， $|\\nabla \\rho(x)|^2 = (\\frac{d\\rho}{dx})^2 = 4\\zeta^2(f_A(x) - f_B(x))^2$。\n\n3. 量 $D(x)$ 定义为差值 $D(x) = \\tau(x) - \\tau_W(x)$。代入 $\\tau$ 和 $\\tau_W$ 的表达式：\n$$\nD(x) = \\frac{\\zeta^2}{2}\\rho(x) - \\frac{4\\zeta^2(f_A(x) - f_B(x))^2}{8\\rho(x)} = \\frac{\\zeta^2}{2\\rho(x)} \\left( \\rho(x)^2 - (f_A(x) - f_B(x))^2 \\right)\n$$\n代入 $\\rho(x) = f_A(x) + f_B(x)$ 并使用代数恒等式 $(a+b)^2 - (a-b)^2 = 4ab$：\n$$\nD(x) = \\frac{\\zeta^2}{2\\rho(x)} \\left( (f_A(x)+f_B(x))^2 - (f_A(x)-f_B(x))^2 \\right) = \\frac{\\zeta^2}{2\\rho(x)} \\left( 4f_A(x)f_B(x) \\right) = \\frac{2\\zeta^2 f_A(x) f_B(x)}{f_A(x) + f_B(x)}\n$$\n这个简化的 $D(x)$ 表达式对原子核之间的所有点都有效。\n\n4. 参考动能密度是均匀电子气的动能密度 $\\tau_h(x)$：\n$$\n\\tau_h(x) = C_h \\rho(x)^{5/3}, \\quad \\text{其中} \\quad C_h = \\frac{3}{10}(3\\pi^2)^{2/3}\n$$\n\n最后，ELF 的计算公式为：\n$$\n\\mathrm{ELF}(x) = \\frac{1}{1 + \\chi(x)^2}, \\quad \\text{其中} \\quad \\chi(x) = \\frac{D(x)}{\\tau_h(x)}\n$$\n\n问题要求对每个测试用例 $(R, \\zeta)$ 在三个特定点进行评估：\n-   键中点：$x_{\\text{mid}} = 0$。\n-   左核附近：$x_{\\text{left}} = -R/2 + \\varepsilon$，其中 $\\varepsilon=10^{-6}$。\n-   右核附近：$x_{\\text{right}} = +R/2 - \\varepsilon$。\n\n由于二聚体的对称性，原子核对称地放置在 $x=0$ 的两侧，系统在反演 $x \\to -x$ 下是对称的。密度 $\\rho(x)$ 是一个偶函数，即 $\\rho(x) = \\rho(-x)$。因此，$D(x)$ 和 $\\tau_h(x)$ 也是偶函数。这意味着 $\\mathrm{ELF}(x)$ 是 $x$ 的一个偶函数。因此，$x_{\\text{right}}$ 处的值与 $x_{\\text{left}}$ 处的值相同：\n$$\n\\mathrm{ELF}_{\\text{right}} = \\mathrm{ELF}(R/2 - \\varepsilon) = \\mathrm{ELF}(-(R/2 - \\varepsilon)) = \\mathrm{ELF}(-R/2 + \\varepsilon) = \\mathrm{ELF}_{\\text{left}}\n$$\n这种对称性简化了计算。布尔条件 $b$ 也得以简化：\n$$\nb = \\left(\\mathrm{ELF}_{\\text{mid}} > \\frac{\\mathrm{ELF}_{\\text{left}} + \\mathrm{ELF}_{\\text{right}}}{2}\\right) \\equiv \\left(\\mathrm{ELF}_{\\text{mid}} > \\mathrm{ELF}_{\\text{left}}\\right)\n$$\n\n每个测试用例 $(R, \\zeta)$ 的总体算法如下：\n1.  定义常数 $\\varepsilon = 10^{-6}$ 和 $C_h = \\frac{3}{10}(3\\pi^2)^{2/3}$。\n2.  实现一个函数 `calculate_elf(x, R, zeta)`，该函数使用推导出的 $\\rho(x)$、 $D(x)$ 和 $\\tau_h(x)$ 公式来计算 $\\mathrm{ELF}(x)$。\n3.  计算 $\\mathrm{ELF}_{\\text{mid}} = \\text{calculate\\_elf}(0, R, \\zeta)$。\n4.  计算 $\\mathrm{ELF}_{\\text{left}} = \\text{calculate\\_elf}(-R/2 + \\varepsilon, R, \\zeta)$。\n5.  设置 $\\mathrm{ELF}_{\\text{right}} = \\mathrm{ELF}_{\\text{left}}$。\n6.  确定布尔值 $b = (\\mathrm{ELF}_{\\text{mid}} > \\mathrm{ELF}_{\\text{left}})$。\n7.  存储四个结果值，按要求将浮点数四舍五入到 $6$ 位小数，以便最终输出格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Electron Localization Function (ELF) for a simplified He2 model\n    at specific points and for given parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (R, zeta)\n    test_cases = [\n        (5.6, 1.6875),\n        (3.0, 1.6875),\n        (10.0, 1.6875),\n    ]\n\n    # Small displacement from the nucleus in bohr\n    epsilon = 1e-6\n    # Constant for homogeneous electron gas kinetic energy density\n    C_h = (3.0 / 10.0) * (3.0 * np.pi**2)**(2.0 / 3.0)\n\n    def calculate_elf(x, R, zeta):\n        \"\"\"\n        Calculates the ELF value at a given point x for a He2 dimer.\n        \n        Args:\n            x (float): The coordinate on the internuclear axis.\n            R (float): The internuclear distance.\n            zeta (float): The exponent of the Slater-type orbital.\n            \n        Returns:\n            float: The ELF value at point x.\n        \"\"\"\n        # Distances from the point x to nuclei A and B\n        r_A = np.abs(x + R / 2.0)\n        r_B = np.abs(x - R / 2.0)\n\n        # Density components from each atom, f_A = 2*phi_A^2, f_B = 2*phi_B^2\n        # The normalization constant is (zeta^3 / pi)\n        norm_factor = 2.0 * (zeta**3 / np.pi)\n        f_A = norm_factor * np.exp(-2.0 * zeta * r_A)\n        f_B = norm_factor * np.exp(-2.0 * zeta * r_B)\n\n        # Total electron density\n        rho = f_A + f_B\n        \n        # Avoid division by zero, although rho should always be positive.\n        if rho == 0:\n            return 0.5 # A neutral value for an undefined case\n\n        # D(x) = tau(x) - tau_W(x), simplified for x between the nuclei\n        D = (2.0 * zeta**2 * f_A * f_B) / rho\n        \n        # Kinetic energy density for a homogeneous electron gas\n        tau_h = C_h * rho**(5.0 / 3.0)\n\n        # Avoid division by zero if tau_h becomes zero.\n        if tau_h == 0:\n            # D must also be zero if rho is zero, so the ratio is ambiguous.\n            # In a region of zero density, ELF is not well-defined.\n            return 0.5 \n\n        # The ELF is defined based on the ratio chi = D/tau_h\n        chi_ratio = D / tau_h\n        elf = 1.0 / (1.0 + chi_ratio**2)\n        \n        return elf\n\n    results_data = []\n    for R, zeta in test_cases:\n        # Define evaluation points\n        x_mid = 0.0\n        x_left = -R / 2.0 + epsilon\n\n        # Compute ELF at the midpoint\n        elf_mid = calculate_elf(x_mid, R, zeta)\n        \n        # Compute ELF near the nucleus\n        elf_left = calculate_elf(x_left, R, zeta)\n        \n        # By symmetry, elf_right is identical to elf_left\n        elf_right = elf_left\n        \n        # Determine if electrons are more localized at the midpoint\n        is_mid_more_localized = elf_mid > elf_left\n\n        results_data.append([elf_mid, elf_left, elf_right, is_mid_more_localized])\n\n    # Format the results into the required single-line string format.\n    # e.g., [[v1,v2,v3,Bool],[v4,v5,v6,Bool]]\n    sub_list_strings = []\n    for res in results_data:\n        # Format floats to 6 decimal places, and booleans as 'True'/'False'\n        s = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{str(res[3])}]\"\n        sub_list_strings.append(s)\n    \n    final_output_string = f\"[{','.join(sub_list_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "电子定域函数 (ELF) 的应用可以扩展到复杂的成键情景，例如在过渡金属二聚体中发现的多重键。这项练习  旨在探讨不同对称性（$\\sigma$, $\\pi$, 和 $\\delta$）的轨道如何在键中点处留下独特的 ELF 特征。通过一个巧妙设计的简化模型，此练习揭示了一个核心原理：键中点的 ELF 值对 $\\sigma$ 和 $\\pi$ 的贡献很敏感，但对 $\\delta$ 的贡献不敏感，从而为理解多重键的空间性质提供了深刻的见解。",
            "id": "2454905",
            "problem": "你需要编写一个完整、可运行的程序，使用电子定域函数（ELF）的定义，在一个简化的过渡金属多重键的第一性原理模型中，评估金属-金属键中点的多个占据的类成键轨道如何影响定域化。考虑一个双原子物种，其核间轴沿 $z$ 轴，键中点位于原点。假设一个单行列式、自旋非极化态，有 $N_p$ 个电子对占据 $N_p$ 个正交归一分子轨道 $\\{\\phi_k(\\mathbf r)\\}$，每个轨道由一个以原点为中心的归一化实数笛卡尔高斯基元表示。通篇使用原子单位。位置 $\\mathbf r$ 处的电子定域函数（ELF）定义为\n$$\\mathrm{ELF}(\\mathbf r) \\equiv \\frac{1}{1 + \\left(\\frac{D(\\mathbf r)}{D_\\mathrm{HEG}(\\mathbf r)}\\right)^2},$$\n其中泡利过剩动能密度为\n$$D(\\mathbf r) = \\tau(\\mathbf r) - \\tau_W(\\mathbf r),$$\n动能密度为\n$$\\tau(\\mathbf r) = 2 \\sum_{k=1}^{N_p} \\left\\lvert \\nabla \\phi_k(\\mathbf r) \\right\\rvert^2,$$\nWeizsäcker 动能密度为\n$$\\tau_W(\\mathbf r) = \\frac{\\left\\lvert \\nabla \\rho(\\mathbf r) \\right\\rvert^2}{8 \\,\\rho(\\mathbf r)},$$\n自旋非极化情况下的参考均匀电子气量为\n$$D_\\mathrm{HEG}(\\mathbf r) = \\tau_\\mathrm{HEG}(\\mathbf r) = \\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\,\\rho(\\mathbf r)^{5/3}。$$\n电子密度为\n$$\\rho(\\mathbf r) = 2 \\sum_{k=1}^{N_p} \\left\\lvert \\phi_k(\\mathbf r) \\right\\rvert^2。$$\n\n每个占据轨道是一个以原点为中心的归一化笛卡尔高斯基元，形式为\n$$\\phi_{lmn}(\\mathbf r;\\alpha) = \\mathcal N_{lmn}(\\alpha)\\, x^l y^m z^n \\, e^{-\\alpha (x^2+y^2+z^2)},$$\n其中 $\\alpha>0$ 是指数，$(l,m,n)$ 是非负整数。归一化常数为\n$$\\mathcal N_{lmn}(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\\sqrt{\\frac{(4\\alpha)^{l+m+n}}{(2l-1)!!\\,(2m-1)!!\\,(2n-1)!!}},$$\n并约定 $(-1)!!=1$。对与沿 $z$ 轴的多重键相关的五个类成键轨道，使用以下对应关系：$\\sigma$ 对应 $(l,m,n)=(0,0,0)$，$\\pi_x$ 对应 $(1,0,0)$，$\\pi_y$ 对应 $(0,1,0)$，$\\delta_{xy}$ 对应 $(1,1,0)$，以及 $\\delta_{x^2-y^2}$ 对应多项式 $(x^2 - y^2)$ 和单个高斯指数 $\\alpha_d$；在键中点，只有在原点处的值和一阶导数是相关的。\n\n你的任务是计算以下五个测试案例在键中点 $\\mathbf r=\\mathbf 0$ 处的 $\\mathrm{ELF}(\\mathbf 0)$ 值。在所有案例中，使用下面给出的指数；没有可调参数，也没有用户输入。使用原子单位，并以无量纲浮点数的形式报告 ELF 值。\n\n- 普适常数和参数：\n  - 除已声明的近似外，使用上述定义，不作任何额外近似。\n  - 使用指数 $\\alpha_s = 0.8$，$\\alpha_p = 0.6$ 和 $\\alpha_d = 0.6$。\n\n- 测试套件（每个案例指定占据的轨道集，每个轨道都被双重占据）：\n  1. 案例 1（单键）：占据集 $\\{\\sigma\\}$。\n  2. 案例 2（部分双键）：占据集 $\\{\\sigma, \\pi_x\\}$。\n  3. 案例 3（三键）：占据集 $\\{\\sigma, \\pi_x, \\pi_y\\}$。\n  4. 案例 4（部分四重键）：占据集 $\\{\\sigma, \\pi_x, \\pi_y, \\delta_{xy}\\}$。\n  5. 案例 5（五重键）：占据集 $\\{\\sigma, \\pi_x, \\pi_y, \\delta_{xy}, \\delta_{x^2-y^2}\\}$。\n\n角度单位不适用。输出中没有物理单位，因为 $\\mathrm{ELF}$ 是无量纲的。\n\n你的程序必须生成单行输出，其中包含五个结果，形式为方括号括起来的逗号分隔列表，顺序与上述测试案例相同，每个数字四舍五入到小数点后恰好六位（例如，$[1.234000,0.000001,0.500000,0.750000,0.125000]$）。",
            "solution": "我们从第一性原理出发，对于自旋非极化的单行列式波函数，电子定域函数（ELF）为\n$$\\mathrm{ELF}(\\mathbf r) = \\frac{1}{1 + \\left(\\frac{D(\\mathbf r)}{D_\\mathrm{HEG}(\\mathbf r)}\\right)^2}, \\quad D(\\mathbf r)=\\tau(\\mathbf r)-\\tau_W(\\mathbf r), \\quad D_\\mathrm{HEG}(\\mathbf r)=\\tau_\\mathrm{HEG}(\\mathbf r),$$\n其中\n$$\\tau(\\mathbf r)=2\\sum_k \\left\\lvert \\nabla \\phi_k(\\mathbf r)\\right\\rvert^2, \\quad \\tau_W(\\mathbf r)=\\frac{\\left\\lvert \\nabla \\rho(\\mathbf r)\\right\\rvert^2}{8\\rho(\\mathbf r)}, \\quad \\rho(\\mathbf r)=2\\sum_k \\left\\lvert \\phi_k(\\mathbf r)\\right\\rvert^2,$$\n并且\n$$\\tau_\\mathrm{HEG}(\\mathbf r)=\\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\rho(\\mathbf r)^{5/3}。$$\n\n每个占据轨道是一个归一化的笛卡尔高斯基元\n$$\\phi_{lmn}(\\mathbf r;\\alpha) = \\mathcal N_{lmn}(\\alpha)\\, x^l y^m z^n\\, e^{-\\alpha r^2}, \\quad r^2 = x^2+y^2+z^2,$$\n其归一化通过强制 $\\int \\lvert \\phi \\rvert^2 \\, d^3 r = 1$ 导出。因为积分在 $x$、$y$ 和 $z$ 上是可分的，使用 $\\int_{-\\infty}^{\\infty} x^{2q} e^{-\\beta x^2} dx = \\frac{(2q-1)!!}{2^q}\\sqrt{\\frac{\\pi}{\\beta^{2q+1}}}$ 和 $(-1)!!=1$，可以得到\n$$\\mathcal N_{lmn}(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\\sqrt{\\frac{(4\\alpha)^{l+m+n}}{(2l-1)!!\\,(2m-1)!!\\,(2n-1)!!}}。$$\n\n我们在键中点 $\\mathbf r=\\mathbf 0$ 处计算所有量。在 $\\mathbf 0$ 点，占据轨道的值和梯度简化如下：\n\n- 对于 $(l,m,n)=(0,0,0)$ 和指数 $\\alpha_s$ 的 $\\sigma$ 轨道，我们有\n$$\\phi_\\sigma(\\mathbf 0)=\\mathcal N_{000}(\\alpha_s)=\\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/4}, \\quad \\nabla \\phi_\\sigma(\\mathbf 0)=\\mathbf 0。$$\n- 对于 $(l,m,n)=(1,0,0)$ 和指数 $\\alpha_p$ 的 $\\pi_x$ 轨道，其在原点的值为零，而梯度有一个有限的 $x$ 分量：\n$$\\phi_{\\pi_x}(\\mathbf 0)=0, \\quad \\frac{\\partial \\phi_{\\pi_x}}{\\partial x}\\bigg\\rvert_{\\mathbf 0}=\\mathcal N_{100}(\\alpha_p), \\quad \\frac{\\partial \\phi_{\\pi_x}}{\\partial y}\\bigg\\rvert_{\\mathbf 0}=0, \\quad \\frac{\\partial \\phi_{\\pi_x}}{\\partial z}\\bigg\\rvert_{\\mathbf 0}=0。$$\n因此 $\\lvert \\nabla \\phi_{\\pi_x}(\\mathbf 0)\\rvert^2=\\mathcal N_{100}(\\alpha_p)^2$。\n根据对称性，$\\pi_y$ 轨道有 $\\lvert \\nabla \\phi_{\\pi_y}(\\mathbf 0)\\rvert^2=\\mathcal N_{010}(\\alpha_p)^2=\\mathcal N_{100}(\\alpha_p)^2$ 并且在原点的值为零。\n- 对于 $(l,m,n)=(1,1,0)$ 的 $\\delta_{xy}$ 轨道以及任何由二阶多项式（如 $\\delta_{x^2-y^2}$）构成的 $\\delta$ 轨道，由于多项式前因子至少包含一个 $x$、$y$ 或 $z$ 因子，其值和所有一阶导数在原点处都为零。因此，这些 $\\delta$ 轨道对 $\\rho(\\mathbf 0)$ 或 $\\tau(\\mathbf 0)$ 没有贡献。\n\n根据这些中点属性，对于从 $\\{\\sigma, \\pi_x, \\pi_y, \\delta_{xy}, \\delta_{x^2-y^2}\\}$ 中抽取的任何占据集，$\\mathbf 0$ 点的密度及其梯度如下：\n- 密度简化为\n$$\\rho(\\mathbf 0)=2\\lvert \\phi_\\sigma(\\mathbf 0)\\rvert^2 = 2\\,\\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/2}。$$\n- 密度梯度 $\\nabla \\rho(\\mathbf 0)=\\mathbf 0$，因为每个贡献都与 $\\phi_k(\\mathbf 0)\\,\\nabla \\phi_k(\\mathbf 0)$ 成正比，而对于每个轨道，在原点处其值或梯度必有一个为零。因此，\n$$\\tau_W(\\mathbf 0)=\\frac{\\lvert \\nabla \\rho(\\mathbf 0)\\rvert^2}{8\\rho(\\mathbf 0)}=0。$$\n- 动能密度为\n$$\\tau(\\mathbf 0) = 2 \\sum_{k \\in \\mathrm{occ}} \\lvert \\nabla \\phi_k(\\mathbf 0)\\rvert^2 = 2\\,N_{\\pi}\\,\\mathcal N_{100}(\\alpha_p)^2,$$\n其中 $N_{\\pi}$ 是集合中占据的 $\\pi$ 轨道的数量（这里为 $0$、$1$ 或 $2$），并且\n$$\\mathcal N_{100}(\\alpha_p)^2 = \\left(\\frac{2\\alpha_p}{\\pi}\\right)^{3/2}\\,(4\\alpha_p)。$$\n\n中点处的均匀电子气参考值为\n$$\\tau_\\mathrm{HEG}(\\mathbf 0) = \\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\,\\rho(\\mathbf 0)^{5/3} = \\frac{3}{10}\\left(3\\pi^2\\right)^{2/3}\\,\\left[2\\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/2}\\right]^{5/3}。$$\n\n因此，中点处的 ELF 为\n$$\\mathrm{ELF}(\\mathbf 0) = \\frac{1}{1+\\left(\\frac{\\tau(\\mathbf 0)}{\\tau_\\mathrm{HEG}(\\mathbf 0)}\\right)^2} = \\frac{1}{1+\\left(\\frac{2 N_{\\pi}\\,\\mathcal N_{100}(\\alpha_p)^2}{\\tau_\\mathrm{HEG}(\\mathbf 0)}\\right)^2}。$$\n\n给定 $\\alpha_s=0.8$ 和 $\\alpha_p=0.6$，我们有\n$$\\mathcal N_{000}(\\alpha_s)^2 = \\left(\\frac{2\\alpha_s}{\\pi}\\right)^{3/2}, \\quad \\mathcal N_{100}(\\alpha_p)^2 = \\left(\\frac{2\\alpha_p}{\\pi}\\right)^{3/2}(4\\alpha_p),$$\n因此 $\\rho(\\mathbf 0)$ 和 $\\tau(\\mathbf 0)$ 可以直接得出。对于五个指定的案例：\n- 案例 1 有 $N_{\\pi}=0$，因此 $\\tau(\\mathbf 0)=0$ 且 $\\mathrm{ELF}(\\mathbf 0)=1$。\n- 案例 2 有 $N_{\\pi}=1$，得到一个有限的 $\\tau(\\mathbf 0)$ 且 $\\mathrm{ELF}(\\mathbf 0)<1$。\n- 案例 3 有 $N_{\\pi}=2$，$\\tau(\\mathbf 0)$ 是案例 2 的两倍，$\\mathrm{ELF}(\\mathbf 0)$ 进一步减小。\n- 案例 4 和 5 包含 $\\delta$ 轨道，但在 $\\mathbf 0$ 点，它们不会改变 $\\rho(\\mathbf 0)$ 或 $\\tau(\\mathbf 0)$，因此在此中点分析中，它们的 $\\mathrm{ELF}(\\mathbf 0)$ 与案例 3 相同。\n\n在数值上，计算上述表达式并将结果四舍五入到小数点后六位，会得到一个单行输出，其中包含按规定顺序排列的五个无量纲浮点数。这些值量化了在这个中点模型中，增加 $\\pi$ 型成键如何降低 $\\mathrm{ELF}(\\mathbf 0)$（由于泡利过剩动能增加导致定域化减弱），而增加 $\\delta$ 型成键在精确的中点处不改变 $\\mathrm{ELF}(\\mathbf 0)$。这说明了要捕捉假定存在的五重键中 $\\delta$ 键的空间特征，必须对电子定域函数（ELF）进行完整的三维分析：$\\delta$ 键的贡献是离轴的，因此在精确的键中心是不可见的，而 $\\sigma$ 和 $\\pi$ 的贡献则分别通过它们的值和梯度影响键中点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef double_factorial(n: int) -> float:\n    if n  1: # Handles n=0 and n=-1 as per problem convention (-1)!!=1\n        return 1.0\n    res = 1.0\n    val = float(n)\n    while val > 1.0:\n        res *= val\n        val -= 2.0\n    return res\n\ndef norm_const_squared(alpha: float, l: int, m: int, n: int) -> float:\n    # N^2 = (2 alpha / pi)^(3/2) * (4 alpha)^(l+m+n) / [(2l-1)!! (2m-1)!! (2n-1)!!]\n    L = l + m + n\n    pref = (2.0 * alpha / np.pi) ** 1.5\n    df = double_factorial(2*l - 1) * double_factorial(2*m - 1) * double_factorial(2*n - 1)\n    return pref * (4.0 * alpha) ** L / df\n\ndef elf_midpoint(occupied: list[str], alpha_s: float, alpha_p: float, alpha_d: float) -> float:\n    # Density at origin: only sigma contributes\n    Ns2 = norm_const_squared(alpha_s, 0, 0, 0) if 's' in occupied else 0.0\n    rho0 = 2.0 * Ns2\n\n    # Kinetic energy density at origin: only pi orbitals contribute via gradient norm\n    Np2 = norm_const_squared(alpha_p, 1, 0, 0)\n    n_pi = (1 if 'px' in occupied else 0) + (1 if 'py' in occupied else 0)\n    tau0 = 2.0 * n_pi * Np2\n\n    # Weizsäcker term is zero at the origin for this orbital set\n    # D0 = tau0 - tau_W0 = tau0\n\n    # Homogeneous electron gas kinetic energy density\n    # Guard against rho0 == 0, though for the specified test cases rho0 > 0 always\n    if rho0 == 0.0:\n        # In the absence of density, ELF is conventionally set to 0.5; however, not needed here.\n        return 0.5\n\n    tau_heg0 = (3.0/10.0) * (3.0 * np.pi**2) ** (2.0/3.0) * rho0 ** (5.0/3.0)\n\n    # For tau_heg0=0, tau0 must also be 0, so chi is 0.\n    if tau_heg0 == 0:\n        return 1.0\n\n    chi = tau0 / tau_heg0\n    elf0 = 1.0 / (1.0 + chi**2)\n    return elf0\n\ndef solve():\n    # Define exponents (atomic units)\n    alpha_s = 0.8\n    alpha_p = 0.6\n    alpha_d = 0.6\n\n    # Define the test cases as lists of occupied orbitals\n    # Mapping: 's' -> sigma, 'px' -> pi_x, 'py' -> pi_y, 'dxy' -> delta_xy, 'dx2y2' -> delta_x2-y2\n    test_cases = [\n        ['s'],                                # Case 1\n        ['s', 'px'],                          # Case 2\n        ['s', 'px', 'py'],                    # Case 3\n        ['s', 'px', 'py', 'dxy'],             # Case 4\n        ['s', 'px', 'py', 'dxy', 'dx2y2'],    # Case 5\n    ]\n\n    results = []\n    for occ in test_cases:\n        val = elf_midpoint(occ, alpha_s, alpha_p, alpha_d)\n        results.append(val)\n\n    # Format to exactly six digits after the decimal point as required\n    formatted = \"[\" + \",\".join(f\"{x:.6f}\" for x in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "计算和可视化 ELF 只是第一步，更深层次的理解来自于定量分析。高 ELF 值的区域构成了所谓的“盆”，这些盆的形状和位置蕴含着丰富的化学信息。这项练习  介绍了一种仅通过分析 ELF 盆的几何特性（如质心位置和形状）来预测键极性的方法，而不是依赖传统的电负性概念。它突显了我们如何将电子密度的拓扑特征转化为直观的化学性质。",
            "id": "2454952",
            "problem": "给定一个仅使用电子局域函数（ELF）盆形（basin）的几何判据来预测键的极性。电子局域函数（ELF）是一个无量纲的标量场，最初根据电子密度和动能密度定义，用于突显局域电子对存在的空间区域。一个 ELF 盆形是空间中 ELF 值超过指定阈值的连通区域。目标是在不参考电负性的情况下，从以单个化学键为中心的 ELF 盆形的几何描述符中计算出一个无量纲的极性分数。\n\n给定位于位置 $\\mathbf{r}_A \\in \\mathbb{R}^3$ 和 $\\mathbf{r}_B \\in \\mathbb{R}^3$（单位为 $\\text{\\AA}$）的两个原子核，定义键矢量 $\\mathbf{R} = \\mathbf{r}_B - \\mathbf{r}_A$，键长 $L = \\lVert \\mathbf{R} \\rVert$（单位为 $\\text{\\AA}$），沿键方向的单位矢量 $\\mathbf{u} = \\mathbf{R}/L$，以及键中点 $\\mathbf{r}_\\text{mid} = (\\mathbf{r}_A + \\mathbf{r}_B)/2$。对于与该键相关的 ELF 盆形，设 $\\mathbf{r}_c \\in \\mathbb{R}^3$（单位为 $\\text{\\AA}$）表示盆形质心，设 $\\mathbf{S} \\in \\mathbb{R}^{3 \\times 3}$（单位为 $\\text{\\AA}^2$）表示盆形空间分布的对称半正定协方差矩阵。定义以下两个无量纲量：\n\n1. 沿键方向的归一化质心位移\n$$\nd = \\frac{2}{L}\\,\\mathbf{u} \\cdot \\left(\\mathbf{r}_c - \\mathbf{r}_\\text{mid}\\right).\n$$\n\n2. 与键方向对齐的方差分数\n$$\na = \\begin{cases}\n\\dfrac{\\mathbf{u}^\\mathsf{T}\\mathbf{S}\\,\\mathbf{u}}{\\mathrm{tr}(\\mathbf{S})},  \\text{若 } \\mathrm{tr}(\\mathbf{S})  0, \\\\\n0,  \\text{若 } \\mathrm{tr}(\\mathbf{S}) = 0,\n\\end{cases}\n$$\n其中 $\\mathrm{tr}(\\mathbf{S})$ 是 $\\mathbf{S}$ 的迹。\n\n将预测的键极性分数定义为\n$$\np = d \\times a.\n$$\n$p$ 的符号编码了沿 $\\mathbf{u}$ 方向的极性方向性，$p$ 的大小反映了盆形形状支持该方向性的程度。该预测仅使用 ELF 盆形的几何形状，不参考电负性。\n\n你的任务是编写一个程序，对下面的每个测试用例，使用上述定义计算 $p$ 并输出结果。所有坐标的单位均为 $\\text{\\AA}$，所有协方差矩阵元素的单位均为 $\\text{\\AA}^2$。要求的输出是无量纲的。将每个最终结果表示为四舍五入到六位小数的浮点数。\n\n测试套件（每个案例提供 $\\mathbf{r}_A$、$\\mathbf{r}_B$、$\\mathbf{r}_c$ 和 $\\mathbf{S}$）：\n\n- 案例 1（对称，类同核）：\n  - $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n  - $\\mathbf{r}_c = (0.5,0,0)$\n  - $\\mathbf{S} = \\mathrm{diag}(0.01, 0.01, 0.01)$\n\n- 案例 2（质心向 $\\mathbf{r}_B$ 移动，沿键方向伸长）：\n  - $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n  - $\\mathbf{r}_c = (0.65,0,0)$\n  - $\\mathbf{S} = \\mathrm{diag}(0.04, 0.01, 0.01)$\n\n- 案例 3（质心向 $\\mathbf{r}_A$ 移动，沿键方向伸长）：\n  - $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n  - $\\mathbf{r}_c = (0.35,0,0)$\n  - $\\mathbf{S} = \\mathrm{diag}(0.04, 0.01, 0.01)$\n\n- 案例 4（质心向 $\\mathbf{r}_B$ 移动，垂直于键方向伸长）：\n  - $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n  - $\\mathbf{r}_c = (0.65,0,0)$\n  - $\\mathbf{S} = \\mathrm{diag}(0.01, 0.04, 0.04)$\n\n- 案例 5（键更长，质心向 $\\mathbf{r}_B$ 移动，沿键方向伸长）：\n  - $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (2,0,0)$\n  - $\\mathbf{r}_c = (1.3,0,0)$\n  - $\\mathbf{S} = \\mathrm{diag}(0.09, 0.01, 0.01)$\n\n最终输出格式要求：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[p1,p2,p3,p4,p5]”），每个 $p_i$ 四舍五入到六位小数，并且没有附加文本。",
            "solution": "所提出的问题是有效的。这是一个定义明确的计算任务，植根于计算量子化学的原理，特别是电子局域函数（ELF）的分析。目标是纯粹基于与化学键相关的 ELF 盆形的几何特性，计算一个无量纲的键极性分数，记为 $p$。问题提供了所有必要的定义和数据。我们将着手进行推导和计算。\n\n极性分数 $p$ 定义为两个无量纲量的乘积：\n$$\np = d \\times a\n$$\n其中 $d$ 是归一化质心位移，$a$ 是与键方向对齐的方差分数。在为每个测试用例计算最终分数之前，我们将分别分析每个分量。\n\n第一个分量 $d$ 是归一化质心位移，定义为：\n$$\nd = \\frac{2}{L}\\,\\mathbf{u} \\cdot \\left(\\mathbf{r}_c - \\mathbf{r}_\\text{mid}\\right)\n$$\n这里，$\\mathbf{r}_A$ 和 $\\mathbf{r}_B$ 是两个原子核的位置，$\\mathbf{R} = \\mathbf{r}_B - \\mathbf{r}_A$ 是键矢量，$L = \\lVert \\mathbf{R} \\rVert$ 是键长，$\\mathbf{u} = \\mathbf{R}/L$ 是沿键轴的单位矢量。点 $\\mathbf{r}_\\text{mid} = (\\mathbf{r}_A + \\mathbf{r}_B)/2$ 是键的几何中心。矢量 $\\mathbf{r}_c - \\mathbf{r}_\\text{mid}$ 表示 ELF 盆形质心 $\\mathbf{r}_c$ 相对于此中点的位移。与 $\\mathbf{u}$ 的点积将此位移投影到键轴上。因子 $2/L$ 用键长的一半来归一化这个投影位移，使得 $d$ 成为无量纲量。$d=+1$ 的值意味着质心位于原子核 $\\mathbf{r}_B$ 处，而 $d=-1$ 意味着它位于原子核 $\\mathbf{r}_A$ 处。如果质心位于键的垂直平分面上，则 $d=0$。因此，$d$ 量化了沿键轴的电荷不对称性。\n\n第二个分量 $a$ 是与键对齐的方差分数，定义为：\n$$\na = \\begin{cases}\n\\dfrac{\\mathbf{u}^\\mathsf{T}\\mathbf{S}\\,\\mathbf{u}}{\\mathrm{tr}(\\mathbf{S})},  \\text{若 } \\mathrm{tr}(\\mathbf{S})  0,\\\\\n0,  \\text{若 } \\mathrm{tr}(\\mathbf{S}) = 0,\n\\end{cases}\n$$\n其中 $\\mathbf{S}$ 是盆形空间分布的协方差矩阵。协方差矩阵的迹 $\\mathrm{tr}(\\mathbf{S}) = \\sigma_x^2 + \\sigma_y^2 + \\sigma_z^2$ 代表了盆形内电子分布的总方差。二次型 $\\mathbf{u}^\\mathsf{T}\\mathbf{S}\\,\\mathbf{u}$ 计算了盆形坐标投影到键矢量 $\\mathbf{u}$ 方向上的方差。因此，$a$ 表示与键轴对齐的总空间方差的分数。$a$ 的值接近 1 表示盆形沿键方向高度伸长，这是共价相互作用的特征。$a$ 的值接近 0 表示盆形在垂直于键的方向上展开。\n\n最终的极性分数 $p = d \\times a$ 结合了这两个几何度量。只有当质心发生位移（$d \\neq 0$）且盆形沿键轴方向表现出显著特征（$a  0$）时，该分数才有意义。项 $a$ 可被解释为一个权重因子，它根据盆形形状的“类键”程度来调节极性分数。\n\n我们现在将为每个提供的测试用例计算分数。所有矢量和矩阵运算都将使用标准线性代数执行。\n\n**案例 1：**\n- $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n- $\\mathbf{r}_c = (0.5,0,0)$\n- $\\mathbf{S} = \\mathrm{diag}(0.01, 0.01, 0.01)$\n\n1. 计算键参数：\n    $\\mathbf{R} = \\mathbf{r}_B - \\mathbf{r}_A = (1,0,0) - (0,0,0) = (1,0,0)$\n    $L = \\lVert \\mathbf{R} \\rVert = 1$\n    $\\mathbf{u} = \\mathbf{R}/L = (1,0,0)$\n    $\\mathbf{r}_\\text{mid} = (\\mathbf{r}_A + \\mathbf{r}_B)/2 = (0.5,0,0)$\n\n2. 计算 $d$：\n    $\\mathbf{r}_c - \\mathbf{r}_\\text{mid} = (0.5,0,0) - (0.5,0,0) = (0,0,0)$\n    $d = \\frac{2}{1} \\mathbf{u} \\cdot (0,0,0) = 0$\n\n3. 由于 $d=0$，因此 $p = 0 \\times a = 0$。\n    $p_1 = 0.0$\n\n**案例 2：**\n- $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n- $\\mathbf{r}_c = (0.65,0,0)$\n- $\\mathbf{S} = \\mathrm{diag}(0.04, 0.01, 0.01)$\n\n1. 键参数与案例 1 相同：$L=1$，$\\mathbf{u}=(1,0,0)$，$\\mathbf{r}_\\text{mid}=(0.5,0,0)$。\n\n2. 计算 $d$：\n    $\\mathbf{r}_c - \\mathbf{r}_\\text{mid} = (0.65,0,0) - (0.5,0,0) = (0.15,0,0)$\n    $d = \\frac{2}{1} (1,0,0) \\cdot (0.15,0,0) = 2 \\times 0.15 = 0.3$\n\n3. 计算 $a$：\n    $\\mathrm{tr}(\\mathbf{S}) = 0.04 + 0.01 + 0.01 = 0.06$\n    $\\mathbf{u}^\\mathsf{T}\\mathbf{S}\\,\\mathbf{u} = (1,0,0) \\begin{pmatrix} 0.04  0  0 \\\\ 0  0.01  0 \\\\ 0  0  0.01 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = 0.04$\n    $a = \\frac{0.04}{0.06} = \\frac{2}{3}$\n\n4. 计算 $p$：\n    $p_2 = d \\times a = 0.3 \\times \\frac{2}{3} = 0.2$\n\n**案例 3：**\n- $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n- $\\mathbf{r}_c = (0.35,0,0)$\n- $\\mathbf{S} = \\mathrm{diag}(0.04, 0.01, 0.01)$\n\n1. 键参数和矩阵 $\\mathbf{S}$ 与案例 2 相同。因此，$a = 2/3$。\n\n2. 计算 $d$：\n    $\\mathbf{r}_c - \\mathbf{r}_\\text{mid} = (0.35,0,0) - (0.5,0,0) = (-0.15,0,0)$\n    $d = \\frac{2}{1} (1,0,0) \\cdot (-0.15,0,0) = 2 \\times (-0.15) = -0.3$\n\n3. 计算 $p$：\n    $p_3 = d \\times a = -0.3 \\times \\frac{2}{3} = -0.2$\n\n**案例 4：**\n- $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (1,0,0)$\n- $\\mathbf{r}_c = (0.65,0,0)$\n- $\\mathbf{S} = \\mathrm{diag}(0.01, 0.04, 0.04)$\n\n1. 键参数和 $\\mathbf{r}_c$ 与案例 2 相同。因此，$d=0.3$。\n\n2. 计算 $a$：\n    $\\mathrm{tr}(\\mathbf{S}) = 0.01 + 0.04 + 0.04 = 0.09$\n    $\\mathbf{u}^\\mathsf{T}\\mathbf{S}\\,\\mathbf{u} = (1,0,0) \\begin{pmatrix} 0.01  0  0 \\\\ 0  0.04  0 \\\\ 0  0  0.04 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = 0.01$\n    $a = \\frac{0.01}{0.09} = \\frac{1}{9}$\n\n3. 计算 $p$：\n    $p_4 = d \\times a = 0.3 \\times \\frac{1}{9} = \\frac{3}{10} \\times \\frac{1}{9} = \\frac{1}{30} \\approx 0.033333$\n\n**案例 5：**\n- $\\mathbf{r}_A = (0,0,0)$, $\\mathbf{r}_B = (2,0,0)$\n- $\\mathbf{r}_c = (1.3,0,0)$\n- $\\mathbf{S} = \\mathrm{diag}(0.09, 0.01, 0.01)$\n\n1. 计算键参数：\n    $\\mathbf{R} = (2,0,0) - (0,0,0) = (2,0,0)$\n    $L = \\lVert \\mathbf{R} \\rVert = 2$\n    $\\mathbf{u} = \\mathbf{R}/L = (1,0,0)$\n    $\\mathbf{r}_\\text{mid} = (\\mathbf{r}_A + \\mathbf{r}_B)/2 = (1,0,0)$\n\n2. 计算 $d$：\n    $\\mathbf{r}_c - \\mathbf{r}_\\text{mid} = (1.3,0,0) - (1,0,0) = (0.3,0,0)$\n    $d = \\frac{2}{2} (1,0,0) \\cdot (0.3,0,0) = 1 \\times 0.3 = 0.3$\n\n3. 计算 $a$：\n    $\\mathrm{tr}(\\mathbf{S}) = 0.09 + 0.01 + 0.01 = 0.11$\n    $\\mathbf{u}^\\mathsf{T}\\mathbf{S}\\,\\mathbf{u} = (1,0,0) \\begin{pmatrix} 0.09  0  0 \\\\ 0  0.01  0 \\\\ 0  0  0.01 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = 0.09$\n    $a = \\frac{0.09}{0.11} = \\frac{9}{11}$\n\n4. 计算 $p$：\n    $p_5 = d \\times a = 0.3 \\times \\frac{9}{11} = \\frac{3}{10} \\times \\frac{9}{11} = \\frac{27}{110} \\approx 0.245455$\n\n所有案例的结果都已根据指定的公式计算得出。实现将基于此分步逻辑进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a geometric bond polarity score based on ELF basin descriptors.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"rA\": np.array([0., 0., 0.]), \"rB\": np.array([1., 0., 0.]),\n            \"rc\": np.array([0.5, 0., 0.]),\n            \"S\": np.diag([0.01, 0.01, 0.01])\n        },\n        {\n            \"rA\": np.array([0., 0., 0.]), \"rB\": np.array([1., 0., 0.]),\n            \"rc\": np.array([0.65, 0., 0.]),\n            \"S\": np.diag([0.04, 0.01, 0.01])\n        },\n        {\n            \"rA\": np.array([0., 0., 0.]), \"rB\": np.array([1., 0., 0.]),\n            \"rc\": np.array([0.35, 0., 0.]),\n            \"S\": np.diag([0.04, 0.01, 0.01])\n        },\n        {\n            \"rA\": np.array([0., 0., 0.]), \"rB\": np.array([1., 0., 0.]),\n            \"rc\": np.array([0.65, 0., 0.]),\n            \"S\": np.diag([0.01, 0.04, 0.04])\n        },\n        {\n            \"rA\": np.array([0., 0., 0.]), \"rB\": np.array([2., 0., 0.]),\n            \"rc\": np.array([1.3, 0., 0.]),\n            \"S\": np.diag([0.09, 0.01, 0.01])\n        }\n    ]\n\n    def compute_polarity_score(rA, rB, rc, S):\n        \"\"\"\n        Calculates the polarity score p for a single bond case.\n\n        Args:\n            rA (np.ndarray): Position vector of nucleus A.\n            rB (np.ndarray): Position vector of nucleus B.\n            rc (np.ndarray): Centroid of the ELF basin.\n            S (np.ndarray): Covariance matrix of the ELF basin.\n\n        Returns:\n            float: The dimensionless polarity score p.\n        \"\"\"\n        # Calculate bond vector and length\n        R_vec = rB - rA\n        L = np.linalg.norm(R_vec)\n        \n        # Check for zero bond length to avoid division by zero\n        if L == 0:\n            return 0.0\n\n        # Calculate unit vector along the bond\n        u_vec = R_vec / L\n\n        # Calculate bond midpoint\n        r_mid = (rA + rB) / 2.0\n\n        # 1. Calculate the normalized centroid displacement, d\n        d = (2.0 / L) * np.dot(u_vec, rc - r_mid)\n\n        # 2. Calculate the fraction of variance aligned with the bond, a\n        tr_S = np.trace(S)\n        if tr_S > 0:\n            # variance_along_bond = u.T @ S @ u\n            variance_along_bond = u_vec.dot(S).dot(u_vec)\n            a = variance_along_bond / tr_S\n        else:\n            # Handle the case of a zero-volume basin (S is null matrix)\n            a = 0.0\n            \n        # Define the predicted bond polarity score, p\n        p = d * a\n        return p\n\n    results = []\n    for case in test_cases:\n        p = compute_polarity_score(case[\"rA\"], case[\"rB\"], case[\"rc\"], case[\"S\"])\n        results.append(f\"{p:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}