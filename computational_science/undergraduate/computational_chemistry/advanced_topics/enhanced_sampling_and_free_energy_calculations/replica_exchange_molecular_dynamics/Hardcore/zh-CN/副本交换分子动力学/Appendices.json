{
    "hands_on_practices": [
        {
            "introduction": "副本交换分子动力学（REMD）成功的关键在于选择合适的温度阶梯，以确保副本能够有效交换构型。要做到这一点，我们需要能够预测交换的接受率。这个练习  为我们提供了一个定量的基础，它要求你基于系统的能量统计数据，并使用常见的高斯近似，来推导和计算这一概率。",
            "id": "2666608",
            "problem": "在副本交换分子动力学 (REMD) 中，两个处于逆温度 $\\beta_1$ 和 $\\beta_2$ 的副本尝试交换温度，其 Metropolis 接受概率为 $\\min\\!\\left(1,\\exp\\!\\left((\\beta_1-\\beta_2)\\,(E_1-E_2)\\right)\\right)$，其中 $E_1$ 和 $E_2$ 是在温度 $T_1$ 和 $T_2$ 下，从各自的正则系综中独立抽样的瞬时势能。考虑两个相邻的温度 $T_1=300\\ \\mathrm{K}$ 和 $T_2=330\\ \\mathrm{K}$。假设在这些温度下测得的能量统计数据（能量以每摩尔为单位表示）近似为高斯分布，其均值分别为 $\\mu_1=-500.0\\ \\mathrm{kJ\\,mol^{-1}}$ 和 $\\mu_2=-440.0\\ \\mathrm{kJ\\,mol^{-1}}$，方差分别为 $\\sigma_1^2=1496.6033\\ \\mathrm{kJ^2\\,mol^{-2}}$ 和 $\\sigma_2^2=1810.8900\\ \\mathrm{kJ^2\\,mol^{-2}}$。假设这两个能量样本是独立的，并且对正则能量分布的高斯近似是有效的。\n\n仅从正则系综的定义、交换的 Metropolis 接受准则以及上述的独立性和高斯假设出发，推导在这些条件下期望交换接受概率的解析表达式，并对其进行数值计算。使用气体常数 $R=0.008314462618\\ \\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$，以使 $\\beta_i = 1/(R T_i)$ 与每摩尔能量单位保持一致。将最终的期望接受概率四舍五入至四位有效数字。最终答案以纯数字形式表示（无单位）。",
            "solution": "所述问题具有科学依据、提法明确且客观。所有必要的数据和明确的假设均已提供。这是分析副本交换分子动力学模拟中的一个标准计算。因此，该问题是有效的，并将提供解答。\n\n目标是计算在逆温度 $\\beta_1$ 和 $\\beta_2$ 下两个副本之间交换的 Metropolis 接受概率的期望值 $\\langle P_{\\text{acc}} \\rangle$。接受概率由下式给出：\n$$\nP_{\\text{acc}}(E_1, E_2) = \\min\\!\\left(1, \\exp\\!\\left((\\beta_1-\\beta_2)(E_1-E_2)\\right)\\right)\n$$\n其中 $E_1$ 和 $E_2$ 是副本的势能。它们是从各自的正则系综中独立抽取的随机变量。问题陈述这些能量分布近似为高斯分布：$E_1 \\sim \\mathcal{N}(\\mu_1, \\sigma_1^2)$ 和 $E_2 \\sim \\mathcal{N}(\\mu_2, \\sigma_2^2)$。\n\n我们定义逆温度差 $\\Delta\\beta = \\beta_1 - \\beta_2$ 和能量差 $\\Delta E = E_1 - E_2$。接受概率简化为 $P_{\\text{acc}}(\\Delta E) = \\min(1, \\exp(\\Delta\\beta \\Delta E))$。由于 $E_1$ 和 $E_2$ 是独立的高斯随机变量，它们的差 $\\Delta E$ 也是一个高斯随机变量。其分布为 $\\Delta E \\sim \\mathcal{N}(\\mu_{\\Delta}, \\sigma_{\\Delta}^2)$，参数为：\n均值：$\\mu_{\\Delta} = \\mathbb{E}[E_1 - E_2] = \\mathbb{E}[E_1] - \\mathbb{E}[E_2] = \\mu_1 - \\mu_2$。\n方差：$\\sigma_{\\Delta}^2 = \\text{Var}(E_1 - E_2) = \\text{Var}(E_1) + \\text{Var}(-E_2) = \\text{Var}(E_1) + (-1)^2\\text{Var}(E_2) = \\sigma_1^2 + \\sigma_2^2$。\n\n期望接受概率通过对 $\\Delta E$ 的概率分布（我们记为 $p_{\\Delta}(x)$）进行积分来求得：\n$$\n\\langle P_{\\text{acc}} \\rangle = \\mathbb{E}[P_{\\text{acc}}(\\Delta E)] = \\int_{-\\infty}^{\\infty} \\min(1, \\exp(\\Delta\\beta x)) p_{\\Delta}(x) dx\n$$\n其中 $p_{\\Delta}(x) = \\frac{1}{\\sqrt{2\\pi\\sigma_{\\Delta}^2}} \\exp\\left(-\\frac{(x - \\mu_{\\Delta})^2}{2\\sigma_{\\Delta}^2}\\right)$。\n\n给定 $T_1 = 300\\ \\mathrm{K}$ 和 $T_2 = 330\\ \\mathrm{K}$，我们有 $T_1  T_2$，这意味着 $\\beta_1 = 1/(RT_1) > 1/(RT_2) = \\beta_2$。因此 $\\Delta\\beta > 0$。这允许我们根据指数参数 $x = \\Delta E$ 的符号来拆分积分：\n- 如果 $x > 0$，则 $\\Delta\\beta x > 0$，所以 $\\exp(\\Delta\\beta x) > 1$，且 $\\min(1, \\exp(\\Delta\\beta x)) = 1$。\n- 如果 $x \\le 0$，则 $\\Delta\\beta x \\le 0$，所以 $\\exp(\\Delta\\beta x) \\le 1$，且 $\\min(1, \\exp(\\Delta\\beta x)) = \\exp(\\Delta\\beta x)$。\n\n因此，期望积分被拆分为两部分：\n$$\n\\langle P_{\\text{acc}} \\rangle = \\int_{0}^{\\infty} 1 \\cdot p_{\\Delta}(x) dx + \\int_{-\\infty}^{0} \\exp(\\Delta\\beta x) p_{\\Delta}(x) dx\n$$\n第一个积分是 $\\Delta E > 0$ 的概率，可以用标准正态分布的累积分布函数 (CDF) 表示，$\\Phi(z) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^z \\exp(-t^2/2) dt$。\n$$\n\\int_{0}^{\\infty} p_{\\Delta}(x) dx = P(\\Delta E > 0) = 1 - P(\\Delta E \\le 0) = 1 - \\Phi\\left(\\frac{0 - \\mu_{\\Delta}}{\\sigma_{\\Delta}}\\right) = 1 - \\Phi\\left(-\\frac{\\mu_{\\Delta}}{\\sigma_{\\Delta}}\\right) = \\Phi\\left(\\frac{\\mu_{\\Delta}}{\\sigma_{\\Delta}}\\right)\n$$\n第二个积分需要我们合并被积函数中的指数项：\n$$\n\\int_{-\\infty}^{0} \\exp(\\Delta\\beta x) \\frac{1}{\\sqrt{2\\pi\\sigma_{\\Delta}^2}} \\exp\\left(-\\frac{(x - \\mu_{\\Delta})^2}{2\\sigma_{\\Delta}^2}\\right) dx\n$$\n总指数的参数为 $\\Delta\\beta x - \\frac{(x - \\mu_{\\Delta})^2}{2\\sigma_{\\Delta}^2}$。我们对 $x$ 进行配方：\n$$\n-\\frac{1}{2\\sigma_{\\Delta}^2} [x^2 - 2x\\mu_{\\Delta} + \\mu_{\\Delta}^2 - 2\\sigma_{\\Delta}^2\\Delta\\beta x] = -\\frac{1}{2\\sigma_{\\Delta}^2} [x^2 - 2x(\\mu_{\\Delta} + \\sigma_{\\Delta}^2\\Delta\\beta) + \\mu_{\\Delta}^2]\n$$\n令 $\\mu' = \\mu_{\\Delta} + \\sigma_{\\Delta}^2\\Delta\\beta$。方括号中的项可重写为：\n$$\n[x - \\mu']^2 - (\\mu')^2 + \\mu_{\\Delta}^2 = [x - \\mu']^2 - (\\mu_{\\Delta}^2 + 2\\mu_{\\Delta}\\sigma_{\\Delta}^2\\Delta\\beta + (\\sigma_{\\Delta}^2\\Delta\\beta)^2) + \\mu_{\\Delta}^2 = [x - \\mu']^2 - 2\\mu_{\\Delta}\\sigma_{\\Delta}^2\\Delta\\beta - \\sigma_{\\Delta}^4(\\Delta\\beta)^2\n$$\n指数项变为：\n$$\n-\\frac{(x - \\mu')^2}{2\\sigma_{\\Delta}^2} + \\frac{2\\mu_{\\Delta}\\sigma_{\\Delta}^2\\Delta\\beta + \\sigma_{\\Delta}^4(\\Delta\\beta)^2}{2\\sigma_{\\Delta}^2} = -\\frac{(x - \\mu')^2}{2\\sigma_{\\Delta}^2} + \\mu_{\\Delta}\\Delta\\beta + \\frac{\\sigma_{\\Delta}^2(\\Delta\\beta)^2}{2}\n$$\n现在第二个积分为：\n$$\n\\int_{-\\infty}^{0} \\exp\\left(\\mu_{\\Delta}\\Delta\\beta + \\frac{\\sigma_{\\Delta}^2(\\Delta\\beta)^2}{2}\\right) \\frac{1}{\\sqrt{2\\pi\\sigma_{\\Delta}^2}} \\exp\\left(-\\frac{(x - \\mu')^2}{2\\sigma_{\\Delta}^2}\\right) dx\n$$\n常数指数因子可以移到积分之外。剩下的积分是高斯变量 $X' \\sim \\mathcal{N}(\\mu', \\sigma_{\\Delta}^2)$ 的概率 $P(X' \\le 0)$。\n$$\nP(X' \\le 0) = \\Phi\\left(\\frac{0 - \\mu'}{\\sigma_{\\Delta}}\\right) = \\Phi\\left(-\\frac{\\mu_{\\Delta} + \\sigma_{\\Delta}^2\\Delta\\beta}{\\sigma_{\\Delta}}\\right)\n$$\n结合所有部分，最终的解析表达式为：\n$$\n\\langle P_{\\text{acc}} \\rangle = \\Phi\\left(\\frac{\\mu_{\\Delta}}{\\sigma_{\\Delta}}\\right) + \\exp\\left(\\mu_{\\Delta}\\Delta\\beta + \\frac{\\sigma_{\\Delta}^2(\\Delta\\beta)^2}{2}\\right) \\Phi\\left(-\\frac{\\mu_{\\Delta} + \\sigma_{\\Delta}^2\\Delta\\beta}{\\sigma_{\\Delta}}\\right)\n$$\n现在，我们代入给定的数值。\n$R = 0.008314462618\\ \\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$。\n温度：$T_1 = 300\\ \\mathrm{K}$，$T_2 = 330\\ \\mathrm{K}$。\n$\\Delta\\beta = \\frac{1}{R}\\left(\\frac{1}{T_1} - \\frac{1}{T_2}\\right) = \\frac{1}{0.008314462618}\\left(\\frac{1}{300} - \\frac{1}{330}\\right) = \\frac{1}{0.008314462618}\\left(\\frac{30}{99000}\\right) \\approx 0.036446164\\ (\\mathrm{kJ\\,mol^{-1}})^{-1}$。\n\n能量统计：\n$\\mu_1 = -500.0\\ \\mathrm{kJ\\,mol^{-1}}$，$\\mu_2 = -440.0\\ \\mathrm{kJ\\,mol^{-1}}$。\n$\\sigma_1^2 = 1496.6033\\ \\mathrm{kJ^2\\,mol^{-2}}$，$\\sigma_2^2 = 1810.8900\\ \\mathrm{kJ^2\\,mol^{-2}}$。\n\n$\\Delta E$ 分布的参数：\n$\\mu_{\\Delta} = \\mu_1 - \\mu_2 = -500.0 - (-440.0) = -60.0\\ \\mathrm{kJ\\,mol^{-1}}$。\n$\\sigma_{\\Delta}^2 = \\sigma_1^2 + \\sigma_2^2 = 1496.6033 + 1810.8900 = 3307.4933\\ \\mathrm{kJ^2\\,mol^{-2}}$。\n$\\sigma_{\\Delta} = \\sqrt{3307.4933} \\approx 57.5108085\\ \\mathrm{kJ\\,mol^{-1}}$。\n\n我们计算解析表达式中函数的参数：\n第一个 $\\Phi$ 函数的参数：$\\frac{\\mu_{\\Delta}}{\\sigma_{\\Delta}} = \\frac{-60.0}{57.5108085} \\approx -1.043282$。\n$\\Phi(-1.043282) \\approx 0.14841$。\n\n指数项的指数：$\\mu_{\\Delta}\\Delta\\beta + \\frac{\\sigma_{\\Delta}^2(\\Delta\\beta)^2}{2}$\n项 1：$\\mu_{\\Delta}\\Delta\\beta = -60.0 \\times 0.036446164 \\approx -2.186770$。\n项 2：$\\frac{\\sigma_{\\Delta}^2(\\Delta\\beta)^2}{2} = \\frac{3307.4933 \\times (0.036446164)^2}{2} \\approx \\frac{4.393433}{2} = 2.196717$。\n指数 = $-2.186770 + 2.196717 = 0.009947$。\n$\\exp(0.009947) \\approx 1.009996$。\n\n第二个 $\\Phi$ 函数的参数：$-\\frac{\\mu_{\\Delta} + \\sigma_{\\Delta}^2\\Delta\\beta}{\\sigma_{\\Delta}}$\n$\\sigma_{\\Delta}^2\\Delta\\beta = 3307.4933 \\times 0.036446164 \\approx 120.5483$。\n参数 $= -\\frac{-60.0 + 120.5483}{57.5108085} = -\\frac{60.5483}{57.5108085} \\approx -1.052816$。\n$\\Phi(-1.052816) \\approx 0.14620$。\n\n最后，我们计算 $\\langle P_{\\text{acc}} \\rangle$：\n$\\langle P_{\\text{acc}} \\rangle \\approx 0.14841 + (1.009996) \\times (0.14620) \\approx 0.14841 + 0.147661 \\approx 0.296071$。\n\n四舍五入到四位有效数字，结果为 $0.2961$。",
            "answer": "$$\n\\boxed{0.2961}\n$$"
        },
        {
            "introduction": "除了掌握公式，对REMD的深入理解还需要我们明晰其各个组成部分如何协同工作。这个思想实验  探讨了一个常见的执行错误——在成功交换后忘记重新设定速度——所带来的后果。通过分析这个错误，你将能更清晰地区分基于势能的交换准则和负责管理动能的恒温器的角色，以及它们如何分别影响算法的正确性和效率。",
            "id": "2461603",
            "problem": "在副本交换分子动力学 (REMD) 中，同一系统的一组副本在不同温度下进行模拟，每个副本使用独立的恒温器。当单独使用时，这些恒温器会在其指定温度下对正则（恒定粒子数、体积和温度）分布进行采样。考虑两个逆温分别为 $\\,\\beta_i\\,$ 和 $\\,\\beta_j\\,$ 的副本，它们根据标准的 REMD 交换规则进行了一次成功的温度交换。交换后，研究人员忘记了重新初始化或重新标度粒子速度以使其与新温度一致；也就是说，每个副本继续使用交换前的速度，但在另一个温度的恒温器下演化。假设每个副本内的后续时间演化由一个恒温器执行，该恒温器以其指定温度下的正则分布作为不变测度，并且交换是根据在副本之间交换温度的常规 REMD 提议间歇性地尝试的。\n\n哪个陈述最能描述这个错误对稳态系综和采样效率的长期后果？\n\nA. 每个温度的稳态构象分布保持正确，因为正则测度是可分解的，并且恒温器会恢复动量分布；然而，交换后的短期动能不匹配会导致额外的弛豫，从而降低跨温度的混合效率，尽管从长远来看交换接受率不受影响。\n\nB. 构象的细致平衡被破坏，因此每个温度下势能的稳态分布会永久性地偏离正则分布。\n\nC. 每个副本中的平均动能无限期地保持在交换前的值，因此温度交换不再提供任何好处，副本实际上保持在固定温度。\n\nD. 只有动能直方图在稳态下有偏差，而构象采样和在温度空间中的扩散在短期和长期内都不受影响。",
            "solution": "问题陈述描述了副本交换分子动力学 (REMD) 中的一个常见场景，其中发生了一个程序性错误。在进行解答之前，我们必须验证问题陈述的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   **方法**：副本交换分子动力学 (REMD)。\n-   **系统**：同一系统的一组副本在不同温度下进行模拟。\n-   **恒温器**：每个副本使用独立的恒温器。当单独使用时，恒温器会在其指定温度下对正则 (NVT) 分布进行采样。\n-   **交换事件**：两个逆温分别为 $\\beta_i$ 和 $\\beta_j$ 的副本根据标准的 REMD 规则进行了一次成功的温度交换。\n-   **程序性错误**：交换后，粒子速度未被重新标度。每个副本的坐标和速度 $(q, p)$ 继续演化，但现在是在*另一个*温度的恒温器下。\n-   **假设 1**：用于副本内动力学的恒温器以其指定温度下的正则分布作为不变测度。\n-   **假设 2**：交换是根据标准的 REMD 提议间歇性地尝试的。\n-   **问题**：这个错误对稳态系综和采样效率的长期后果是什么？\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题在统计力学和计算化学的原理上有充分的依据。REMD、恒温器、正则系综和速度重标度都是标准概念。所描述的错误是一个可能的实现错误。\n-   **良态性**：问题是具体的，并要求说明对明确定义的量（稳态分布、采样效率）的后果。可以从第一性原理推导出一个唯一的答案。\n-   **客观性**：语言技术性强且精确。\n-   **完整性**：问题提供了必要的信息：算法的性质 (REMD)、其组件的属性（恒温器）以及错误的具体性质。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。它在科学上是合理的，问题是良态的，并包含足够的信息来推导出逻辑结论。我们可以继续进行解答。\n\n### 正确答案的推导\n\n在 REMD 中，扩展系综的状态由副本坐标集 $\\{q_k\\}$ 和副本间的温度排列 $\\{\\beta_k\\}$ 描述。构象和温度的目标稳态分布由下式给出：\n$$\n\\mathcal{P}(\\{q_k\\}, \\{\\beta_k\\}) \\propto \\exp\\left(-\\sum_{k=1}^{N} \\beta_k U(q_k)\\right)\n$$\n其中 $N$ 是副本数，$U(q_k)$ 是副本 $k$ 的构象的势能，$\\beta_k$ 是分配给该副本的逆温。请注意，动量没有出现在这个构象系综的表达式中。\n\nREMD 算法包括两个主要步骤：\n1.  **副本内动力学**：每个副本在其当前分配的温度下演化一定的步数。\n2.  **副本间交换**：尝试交换两个副本（比如 $i$ 和 $j$）的温度。\n\n让我们分析这个程序性错误对稳态分布和效率的影响。\n\n**1. 稳态分布**\n\n稳态分布的正确性取决于动力学是否满足相对于目标分布 $\\mathcal{P}$ 的细致平衡条件。\n\n-   **交换步骤**：交换副本 $i$ 和 $j$ 的温度（这等同于交换它们的构象）的标准 REMD 交换规则使用 Metropolis-Hastings 接受概率：\n    $$\n    P_{\\text{accept}} = \\min\\left(1, \\exp\\left[-(\\beta_j - \\beta_i)(U(q_j) - U(q_i))\\right]\\right) = \\min\\left(1, \\exp\\left[(\\beta_i - \\beta_j)(U(q_i) - U(q_j))\\right]\\right)\n    $$\n    这个接受概率**只**取决于被交换的构象的势能 $U(q_i)$ 和 $U(q_j)$ 以及它们各自的逆温 $\\beta_i$ 和 $\\beta_j$。它不依赖于粒子的动能或动量。由于在所描述的场景中该规则得以保留，交换移动本身继续满足*扩展系综构象部分*的细致平衡条件。\n\n-   **副本内动力学步骤**：在交换之间，每个副本在一个恒温器下演化。问题陈述此恒温器“以其指定温度下的正则分布作为不变测度”。这是一个关键陈述。这意味着，对于给定的温度 $T_k$，由恒温器产生的动力学将在足够长的时间内，根据正则分布 $\\rho(q, p) \\propto \\exp(-\\beta_k [K(p) + U(q)])$ 生成构象 $q$ 和动量 $p$，其中 $K(p)$ 是动能。通过对动量进行积分，可以得出这些动力学也将正确地对边际构象分布 $P(q) \\propto \\exp(-\\beta_k U(q))$ 进行采样。\n\n-   **关于稳态分布的结论**：算法的两个组成部分（交换和副本内动力学）都被构建为最终对正确的构象分布进行采样。交换机制确保构象在不同温度间正确分布，而副本内动力学确保在给定温度下的构象空间得到正确探索。关于速度的错误不会改变目标稳态分布的形式正确性，因为交换准则与速度无关。因此，构象的长期稳态分布以及由此产生的势能分布保持正确。同样，恒温器的功能保证了每个温度下的长期、时间平均的动能分布也将是正确的。\n\n**2. 采样效率**\n\n虽然稳态分布在形式上是正确的，但对该分布进行采样的*速率*会受到影响。\n\n-   **动能不匹配**：一次成功的交换后，一个副本的状态是 $(q_k, p_k)$，但它现在耦合到一个新的温度 $T'_k$。动量 $p_k$ 是从对应于旧温度 $T_k$ 的分布中抽取的。因此，动能 $K(p_k)$ 与新温度 $T'_k$ 的期望值不匹配。系统在动能上处于非平衡状态。\n\n-   **恒温器弛豫**：恒温器现在必须工作以将动能恢复到温度 $T'_k$ 的正确平衡值。这个热弛豫过程不是瞬时的，需要有限的时间，这取决于恒温器的耦合强度。\n\n-   **效率降低**：在这个弛豫期间，系统的动力学不能代表在温度 $T'_k$ 下的真正正则采样。例如，如果一个副本从高温移动到低温，其“热”速度将导致其以不符合低温特征的方式运动，直到恒温器将其冷却下来。这段用于动能平衡的时间没有用于高效的构象采样。每次成功交换后产生的这种额外开销，降低了 REMD 模拟的整体效率。它减慢了副本在温度空间中的扩散，而这正是 REMD 增强采样能力的核心。\n\n-   **交换接受率**：长期平均接受率取决于势能分布 $P(U|T_i)$ 和 $P(U|T_j)$ 之间的重叠。由于稳态势能分布最终是正确的，因此长期平均接受率不会受到速度重标度错误的影响。\n\n### 逐项分析\n\n**A. 每个温度的稳态构象分布保持正确，因为正则测度是可分解的，并且恒温器会恢复动量分布；然而，交换后的短期动能不匹配会导致额外的弛豫，从而降低跨温度的混合效率，尽管从长远来看交换接受率不受影响。**\n-   `稳态构象分布保持正确`：**正确**。如上所述，交换规则与动量无关。\n-   `因为正则测度是可分解的，并且恒温器会恢复动量分布`：这给出了正确的物理推理。哈密顿量中动能和势能的分离是关键，而恒温器处理动能部分。\n-   `短期动能不匹配...导致额外的弛豫`：**正确**。这是不重新标度速度的直接后果。\n-   `降低跨温度的混合效率`：**正确**。弛豫时间阻碍了在温度空间中的随机行走。\n-   `从长远来看交换接受率不受影响`：**正确**。这取决于保持正确的稳态势能直方图。\n此选项准确、完整地描述了所有后果。\n**结论：正确。**\n\n**B. 构象的细致平衡被破坏，因此每个温度下势能的稳态分布会永久性地偏离正则分布。**\n-   `构象的细致平衡被破坏`：**不正确**。交换的 Metropolis 规则只依赖于势能，并且根据构造，该规则满足构象系综的细致平衡条件。错误发生在接受/拒绝步骤之后，不会改变规则本身。\n-   `稳态分布...会永久性地偏离`：**不正确**。这是一个错误前提导致的错误结论。\n**结论：不正确。**\n\n**C. 每个副本中的平均动能无限期地保持在交换前的值，因此温度交换不再提供任何好处，副本实际上保持在固定温度。**\n-   `平均动能...无限期地保持在交换前的值`：**不正确**。这与恒温器的既定功能相矛盾，恒温器的功能是通过调节动能来强制执行目标温度。\n-   `温度交换不再提供任何好处`：**不正确**。好处（增强采样）的效率降低了，但没有被消除。交换仍然会发生。\n**结论：不正确。**\n\n**D. 只有动能直方图在稳态下有偏差，而构象采样和在温度空间中的扩散在短期和长期内都不受影响。**\n-   `只有动能直方图在稳态下有偏差`：**不正确**。在稳态（长期平均）下，恒温器确保动能分布是正确的。存在瞬时偏差，但没有永久性偏差。\n-   `在温度空间中的扩散不受影响`：**不正确**。由于每次交换后的弛豫开销，扩散（混合效率）明显降低。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在设置REMD模拟时，最终也是最实际的挑战是设计温度阶梯本身。这个设计问题  将我们从分析带入综合应用的层面。你的任务是创建一个算法，来构建一个优化的、非均匀的温度阶梯，以维持理想的交换率，特别是对于一个具有温度依赖性热容的系统——这在真实世界的研究中非常常见。",
            "id": "2461552",
            "problem": "一个分子系统的正则系综模型在 $310\\,\\mathrm{K}$ 和 $450\\,\\mathrm{K}$ 处表现出两个显著的活化区域。目标是为副本交换分子动力学（REMD）设计一个最优的、非均匀的温度阶梯，该阶梯需跨越一个指定的温度区间，并确保最近邻副本间的交换满足预设的预期接受准则。\n\n本问题使用的建模假设和定义：\n- 在约化单位下进行计算，其中玻尔兹曼常数满足 $k_{\\mathrm{B}} = 1$。所有温度均以 $\\mathrm{K}$ 为单位报告。\n- 定容热容作为温度的函数由下式给出\n$$\nC_{v}(T) = c_{0} + A_{1}\\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{T - 310}{w_{1}}\\right)^{2}\\right) + A_{2}\\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{T - 450}{w_{2}}\\right)^{2}\\right),\n$$\n其中常数 $c_{0} = 100$, $A_{1} = 200$, $w_{1} = 8$, $A_{2} = 150$, $w_{2} = 10$。在这些约化单位中，$C_{v}(T)$ 是无量纲的。\n- 对于温度为 $T$ 的副本，其正则能量涨落被建模为方差如下的高斯分布：\n$$\n\\sigma^{2}(T) = k_{\\mathrm{B}}\\,C_{v}(T)\\,T^{2} = C_{v}(T)\\,T^{2}.\n$$\n- 对于温度分别为 $T_{i}$ 和 $T_{i+1}$ 的两个相邻副本，定义逆温度 $\\beta_{i} = 1/T_{i}$ 和 $\\beta_{i+1} = 1/T_{i+1}$。在评估于中点温度 $T_{m} = \\tfrac{T_{i} + T_{i+1}}{2}$ 的局部等方差高斯近似下，这两个副本之间的预期 Metropolis 交换接受率被建模为\n$$\nA(T_{i}, T_{i+1}) = \\operatorname{erfc}\\!\\left(\\frac{|\\beta_{i+1} - \\beta_{i}|\\,\\sigma(T_{m})}{\\sqrt{2}}\\right),\n$$\n其中 $\\operatorname{erfc}(\\cdot)$ 是互补误差函数。\n\n定义一个递增的温度序列 $\\{T_{0}, T_{1}, \\dots, T_{N}\\}$（其中 $T_{0} = T_{\\min}$ 和 $T_{N} = T_{\\max}$）为可行，如果它满足最近邻接受约束\n$$\nA(T_{i}, T_{i+1}) \\ge a_{\\mathrm{target}} \\quad \\text{for all } i \\in \\{0,1,\\dots,N-1\\}.\n$$\n在所有对于相同 $(T_{\\min}, T_{\\max}, a_{\\mathrm{target}})$ 的可行序列中，如果一个序列具有最小可能长度 $N+1$，则称其为最优序列。\n\n您的任务是为以下测试套件中的每种情况计算一个最优温度阶梯。对于每种情况，输出完整的序列 $\\{T_{0}, T_{1}, \\dots, T_{N}\\}$，单位为 $\\mathrm{K}$，四舍五入到一位小数。\n\n测试套件：\n1. $T_{\\min} = 280\\,\\mathrm{K}$， $T_{\\max} = 500\\,\\mathrm{K}$， $a_{\\mathrm{target}} = 0.3$。\n2. $T_{\\min} = 295\\,\\mathrm{K}$， $T_{\\max} = 330\\,\\mathrm{K}$， $a_{\\mathrm{target}} = 0.3$。\n3. $T_{\\min} = 280\\,\\mathrm{K}$， $T_{\\max} = 500\\,\\mathrm{K}$， $a_{\\mathrm{target}} = 0.4$。\n4. $T_{\\min} = 430\\,\\mathrm{K}$， $T_{\\max} = 470\\,\\mathrm{K}$， $a_{\\mathrm{target}} = 0.3$。\n\n最终输出格式：\n- 您的程序應生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表的每个元素本身是对应测试用例的温度（单位为 $\\mathrm{K}$）列表，也由方括号括起并以逗号分隔。例如：“[[T0_case1,T1_case1,...],[T0_case2,T1_case2,...],...]”。",
            "solution": "该问题要求为副本交换分子动力学（REMD）构建一个最优的温度阶梯 $\\{T_{0}, T_{1}, \\dots, T_{N}\\}$。该阶梯必须跨越给定的温度范围 $[T_{\\min}, T_{\\max}]$，并满足相邻副本交换的最小预期接受概率 $a_{\\mathrm{target}}$。最优阶梯被定义为具有最小可能温度数量（即 $N+1$）的阶梯。\n\n最优性原理指示我们采用一种贪心方法。为了最小化副本的总数，我们必须在从 $T_0 = T_{\\min}$ 开始的每一步 $i$ 中，最大化温度差 $T_{i+1} - T_{i}$。允许的最大步长是将预期接受概率降至其允许的最小值 $a_{\\mathrm{target}}$ 的那一步。因此，在每一步中，我们必须通过求解方程来确定下一个温度 $T_{i+1}$：\n$$\nA(T_{i}, T_{i+1}) = a_{\\mathrm{target}}\n$$\n其中 $A(T_i, T_{i+1})$ 是温度为 $T_i$ 和 $T_{i+1}$ 的副本之间的预期接受概率。\n\n问题为此接受概率提供了一个模型：\n$$\nA(T_{i}, T_{i+1}) = \\operatorname{erfc}\\!\\left(\\frac{|\\beta_{i+1} - \\beta_{i}|\\,\\sigma(T_{m})}{\\sqrt{2}}\\right)\n$$\n此处，$\\beta_{i} = 1/T_{i}$ 是逆温度，$T_{m} = (T_{i} + T_{i+1})/2$ 是中点温度，而 $\\sigma(T_{m})$ 表示在 $T_m$ 时的能量涨落。由于温度序列是严格递增的（$T_{i+1} > T_i$），我们有 $\\beta_{i+1}  \\beta_{i}$，所以 $|\\beta_{i+1} - \\beta_{i}| = \\beta_{i} - \\beta_{i+1}$。\n\n将此代入我们的等式并重新整理，得到我们算法的核心方程。令 $k = \\operatorname{erfcinv}(a_{\\mathrm{target}})$，其中 $\\operatorname{erfcinv}$ 是反互补误差函数。给定 $T_i$ 时，需要为 $T_{i+1}$ 求解的方程是：\n$$\n(\\beta_{i} - \\beta_{i+1})\\,\\sigma(T_{m}) = k\\sqrt{2}\n$$\n代入 $\\beta$ 和 $T_m$ 的定义，我们得到下一个温度的隐式方程，我们将其表示为 $T_{\\text{next}}$：\n$$\n\\left(\\frac{1}{T_{i}} - \\frac{1}{T_{\\text{next}}}\\right) \\sigma\\left(\\frac{T_{i} + T_{\\text{next}}}{2}\\right) - k\\sqrt{2} = 0\n$$\n能量涨落项 $\\sigma(T)$ 由 $\\sigma(T) = T\\sqrt{C_v(T)}$ 给出，其中热容 $C_v(T)$ 定义为：\n$$\nC_{v}(T) = c_{0} + A_{1}\\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{T - 310}{w_{1}}\\right)^{2}\\right) + A_{2}\\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{T - 450}{w_{2}}\\right)^{2}\\right)\n$$\n参数为 $c_{0} = 100$，$A_{1} = 200$，$w_{1} = 8$，$A_{2} = 150$，以及 $w_{2} = 10$。得到的函数 $\\sigma(T)$ 是非平凡的，因此，$T_{\\text{next}}$ 的方程可能没有唯一解或不是单调的。为满足最优性条件，我们必须选择求解该方程的 $T_{\\text{next}} > T_i$ 的最大可能值。\n\n算法步骤如下：\n1. 用起始温度初始化温度列表：$\\mathcal{T} = \\{T_{\\min}\\}$。令当前温度为 $T_{\\text{current}} = T_{\\min}$。\n2. 当 $T_{\\text{current}}  T_{\\max}$ 时：\n    a. 为求根过程定义函数 $g(x)$：\n       $$\n       g(x) = \\left(\\frac{1}{T_{\\text{current}}} - \\frac{1}{x}\\right) \\sigma\\left(\\frac{T_{\\text{current}} + x}{2}\\right) - k\\sqrt{2}\n       $$\n    b. 在区间 $(T_{\\text{current}}, T_{\\max}]$ 内找到方程 $g(x)=0$ 的最大根 $T_{\\text{next}}$。\n    c. 如果存在这样的根且 $T_{\\text{next}}  T_{\\max}$，则将 $T_{\\text{next}}$ 追加到列表 $\\mathcal{T}$ 中，并更新 $T_{\\text{current}} = T_{\\text{next}}$。\n    d. 如果在 $(T_{\\text{current}}, T_{\\max}]$ 内不存在根（当 $g(T_{\\max}) \\le 0$ 时发生），或者找到的根 $T_{\\text{next}} \\ge T_{\\max}$，则过程终止。我们将 $T_{\\max}$ 追加到 $\\mathcal{T}$ 中以完成阶梯。\n3. 最终列表 $\\mathcal{T}$ 代表最优温度阶梯。\n\n为确保找到最大根，仅在固定区间上使用简单的数值求解器是不够的。需要一个稳健的策略。我们实现一种反向搜索来寻找包围根的区间。从 $b=T_{\\max}$ 开始，我们以一个小的增量向后步进，以找到一个区间 $[a, b]$，使得 $g(a) \\le 0$ 且 $g(b) > 0$。这确保了该区间包含 $(T_{\\text{current}}, T_{\\max}]$ 内的最大根。然后在这个区间上应用一个稳定的求根算法，例如 Brent-Dekker 方法。这保证了我们在每一步都采用尽可能大的温度跳跃，从而生成一个副本数量最少的阶梯。最终温度按照要求四舍五入到一位小数。",
            "answer": "```python\n# 完整的、可运行的 Python 3 代码如下。\n# 导入必须符合指定的执行环境。\nimport numpy as np\nfrom scipy.special import erfcinv\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    基于给定的双峰热容模型，计算 REMD 的最优温度阶梯。\n    \"\"\"\n    # 根据问题陈述定义热容模型的常数。\n    c0 = 100.0\n    A1 = 200.0\n    w1 = 8.0\n    T1_peak = 310.0\n    A2 = 150.0\n    w2 = 10.0\n    T2_peak = 450.0\n\n    def Cv(T):\n        \"\"\"\n        根据给定模型计算定容热容 Cv(T)。\n        \"\"\"\n        term1 = A1 * np.exp(-0.5 * ((T - T1_peak) / w1)**2)\n        term2 = A2 * np.exp(-0.5 * ((T - T2_peak) / w2)**2)\n        return c0 + term1 + term2\n\n    def sigma(T):\n        \"\"\"\n        计算能量涨落 sigma(T)，其中 sigma^2 = Cv(T) * T^2。\n        \"\"\"\n        return T * np.sqrt(Cv(T))\n\n    def find_next_temp(T_i, T_max, C):\n        \"\"\"\n        寻找温度阶梯中的下一个温度 T_next，以满足接受准则。\n        此函数识别可能的最大根，以确保阶梯最优（最短）。\n\n        Args:\n            T_i (float): 当前温度。\n            T_max (float): 阶梯的最高温度。\n            C (float): 方程的常数部分，由 a_target 推导得出。\n                       C = erfcinv(a_target) * sqrt(2)。\n        Returns:\n            float: 下一个最优温度。\n        \"\"\"\n        def g(T_next):\n            \"\"\"需求解根的函数：g(T_next) = 0。\"\"\"\n            if T_next = T_i:\n                # 这个区域不是我们关心的。返回一个大的正值以引导求解器。\n                return np.inf\n            Tm = (T_i + T_next) / 2.0\n            beta_diff = (1.0 / T_i) - (1.0 / T_next)\n            return beta_diff * sigma(Tm) - C\n\n        # 如果到 T_max 的步长满足接受率 >= a_target，则阶梯已完成。\n        if g(T_max) = 0:\n            return T_max\n\n        # 为了找到最大的根，我们从 T_max 向后搜索以找到一个区间 [a, b]\n        # 使得 g(a) = 0 且 g(b) > 0。\n        step = 1.0  # 搜索步长，单位为开尔文。\n        b = T_max\n        a = b - step\n        while a > T_i:\n            if g(a) = 0:\n                # 区间 [a, b] 包含最大的根。现在可以求解它。\n                return brentq(g, a, b)\n            b = a\n            a -= step\n        \n        # 如果循环结束，根必须在从 T_i 开始的第一个区间内。\n        return brentq(g, T_i + 1e-9, b)\n\n    def generate_ladder(T_min, T_max, a_target):\n        \"\"\"\n        为给定的参数集生成最优温度阶梯。\n        \"\"\"\n        # 从目标接受率预先计算常数 C。\n        C = erfcinv(a_target) * np.sqrt(2)\n        \n        temps = [T_min]\n        T_current = T_min\n        \n        # 为防止无限循环，设置一个实际的副本数量上限。\n        max_replicas = 2000\n        while T_current  T_max and len(temps)  max_replicas:\n            T_next = find_next_temp(T_current, T_max, C)\n            temps.append(T_next)\n            T_current = T_next\n            \n        if len(temps) >= max_replicas:\n            raise RuntimeError(\"超出最大副本数，请检查参数。\")\n\n        # 将最终列表中的所有温度四舍五入到一位小数。\n        return [round(t, 1) for t in temps]\n\n    # 定义问题陈述中的测试用例。\n    test_cases = [\n        (280.0, 500.0, 0.3),\n        (295.0, 330.0, 0.3),\n        (280.0, 500.0, 0.4),\n        (430.0, 470.0, 0.3),\n    ]\n\n    results = []\n    for T_min, T_max, a_target in test_cases:\n        ladder = generate_ladder(T_min, T_max, a_target)\n        results.append(ladder)\n\n    # 按照问题陈述中指定的格式格式化最终输出字符串。\n    # 格式是一个列表的列表，例如，[[...],[...]]。\n    # str(list) 会为每个内部列表自动创建所需的格式。\n    formatted_results = ','.join(map(str, results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}