{
    "hands_on_practices": [
        {
            "introduction": "Understanding molecular symmetry begins with a precise grasp of the fundamental symmetry operations. This practice solidifies that understanding by translating the geometric definitions of rotations, reflections, and inversions into a computational function that acts on a point's coordinates, making these abstract concepts tangible and quantitative. ",
            "id": "2458763",
            "problem": "Write a complete, runnable program that implements a function applying three-dimensional molecular symmetry operations to a point, following first-principles definitions. The function must take a point $(x, y, z)$ and an operation string, and return the transformed coordinates $(x', y', z')$. All operations act actively on the point in a right-handed Cartesian coordinate system.\n\nOperations to implement and their mathematical definitions:\n- Identity: the string \"E\" represents the identity operation, which leaves the point unchanged. If the input is $(x, y, z)$, then the output is $(x', y', z') = (x, y, z)$.\n- Inversion: the string \"i\" represents inversion through the origin, $(x, y, z) \\mapsto (-x, -y, -z)$.\n- Proper rotation about a coordinate axis: the string \"C\" followed by a positive integer $n$ and an axis letter in $\\{x, y, z\\}$, such as \"C2z\" or \"C3x\". This denotes a rotation by angle $\\theta = \\frac{2\\pi}{n}$ (in radians) about the specified axis, using the right-hand rule. For axis $z$, the rotation acts as\n$$\n\\begin{pmatrix}\nx' \\\\ y' \\\\ z'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\ y \\\\ z\n\\end{pmatrix},\n$$\nwith analogous standard rotation matrices for axes $x$ and $y$.\n- Reflection through a coordinate plane: the string \"sigma_\" followed by a plane name in $\\{\\text{xy}, \\text{xz}, \\text{yz}\\}$, such as \"sigma_xy\". These act as reflections across the named plane, namely\n$\\sigma_{xy}: (x, y, z) \\mapsto (x, y, -z)$,\n$\\sigma_{xz}: (x, y, z) \\mapsto (x, -y, z)$,\n$\\sigma_{yz}: (x, y, z) \\mapsto (-x, y, z)$.\n- Improper rotation about a coordinate axis: the string \"S\" followed by a positive integer $n$ and an axis letter in $\\{x, y, z\\}$, such as \"S4z\". This denotes the composition of a proper rotation by angle $\\theta = \\frac{2\\pi}{n}$ (in radians) about the specified axis, followed by reflection through the plane perpendicular to that axis. For example, \"S4z\" is rotation by $\\frac{\\pi}{2}$ about the $z$-axis followed by reflection through the $xy$-plane.\n\nAngle unit requirement:\n- All angles are to be treated in radians. The parameter $n$ in \"C$n$axis\" or \"S$n$axis\" implies $\\theta = \\frac{2\\pi}{n}$ in radians.\n\nYour program must evaluate the function on the following test suite of input cases. Each case is a pair consisting of a point $(x, y, z)$ and an operation string:\n- Case $1$: point $(1.0, 2.0, 3.0)$ with operation \"C2z\".\n- Case $2$: point $(1.0, 0.0, 0.0)$ with operation \"sigma_yz\".\n- Case $3$: point $(0.0, 1.0, 0.0)$ with operation \"C3x\".\n- Case $4$: point $(0.0, 0.0, 1.0)$ with operation \"S4z\".\n- Case $5$: point $(1.0, 1.0, 1.0)$ with operation \"C4z\".\n- Case $6$: point $(0.0, 0.0, 5.0)$ with operation \"C6z\".\n- Case $7$: point $(3.0, -2.0, 0.0)$ with operation \"sigma_xy\".\n- Case $8$: point $(-1.5, 2.5, -3.5)$ with operation \"i\".\n- Case $9$: point $(2.0, 0.0, 0.0)$ with operation \"E\".\n- Case $10$: point $(1.0, 2.0, 3.0)$ with operation \"C2y\".\n\nNumerical output specifications:\n- For each test case, compute the transformed coordinates $(x', y', z')$ and round each coordinate to exactly six decimal places.\n- Your program must produce a single line of output containing the results as a comma-separated list of coordinate triplets, with each triplet written in square brackets as $[x',y',z']$ and all enclosed in a single pair of square brackets. For example: \"[[a,b,c],[d,e,f],...]\".\n- The output should contain no spaces. All coordinates must be printed with exactly six digits after the decimal point.\n- There are no physical units in this problem, so none should be printed.\n\nDesign for coverage:\n- The provided test suite covers a general case for rotation, reflections across coordinate planes, inversion, identity, multiple axes for rotations, a point on the rotation axis (invariance under proper rotation), and an improper rotation composed of rotation and perpendicular-plane reflection. Each test case’s answer is a list of three floats.",
            "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique, verifiable solution. The problem requires the implementation of fundamental symmetry operations from molecular group theory, which are mathematically represented as linear transformations in a three-dimensional Euclidean space. We will proceed with the solution.\n\nThe core principle is that every symmetry operation can be represented by a $3 \\times 3$ matrix, $M$, that acts on a column vector representing the point's coordinates, $\\vec{v} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$. The transformed point, $\\vec{v}' = \\begin{pmatrix} x' \\\\ y' \\\\ z' \\end{pmatrix}$, is obtained by matrix-vector multiplication: $\\vec{v}' = M \\vec{v}$. We will construct the matrix for each specified operation. The coordinate system is a standard right-handed Cartesian system.\n\n1.  **Identity ($E$)**: This operation leaves the point unchanged. It is represented by the $3 \\times 3$ identity matrix, $I_3$.\n    $$\n    M_E = I_3 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n    $$\n    Thus, $(x', y', z') = (x, y, z)$.\n\n2.  **Inversion ($i$)**: This operation inverts the point through the origin. The matrix is the negative of the identity matrix.\n    $$\n    M_i = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n    $$\n    Thus, $(x', y', z') = (-x, -y, -z)$.\n\n3.  **Reflection ($\\sigma$)**: Reflection across a plane is also a linear transformation.\n    -   Reflection through the $xy$-plane ($\\sigma_{xy}$): The $z$-coordinate is negated.\n        $$\n        M_{\\sigma_{xy}} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n        $$\n    -   Reflection through the $xz$-plane ($\\sigma_{xz}$): The $y$-coordinate is negated.\n        $$\n        M_{\\sigma_{xz}} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n        $$\n    -   Reflection through the $yz$-plane ($\\sigma_{yz}$): The $x$-coordinate is negated.\n        $$\n        M_{\\sigma_{yz}} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n        $$\n\n4.  **Proper Rotation ($C_n$)**: A rotation by an angle $\\theta = \\frac{2\\pi}{n}$ radians about a specified axis. The matrices for active rotation in a right-handed system are as follows:\n    -   Rotation about the $z$-axis, $R_z(\\theta)$:\n        $$\n        M_{C_n(z)} = R_z(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n        $$\n    -   Rotation about the $x$-axis, $R_x(\\theta)$:\n        $$\n        M_{C_n(x)} = R_x(\\theta) = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix}\n        $$\n    -   Rotation about the $y$-axis, $R_y(\\theta)$:\n        $$\n        M_{C_n(y)} = R_y(\\theta) = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix}\n        $$\n\n5.  **Improper Rotation ($S_n$)**: This is a composite operation consisting of a proper rotation ($C_n$) followed by a reflection ($\\sigma_h$) in the plane perpendicular to the rotation axis. The resulting transformation matrix is the product of the individual matrices: $M_{S_n} = M_{\\sigma_h} M_{C_n}$.\n    -   Improper rotation about the $z$-axis, $S_n(z)$: The rotation is $C_n(z)$ and the reflection is $\\sigma_{xy}$.\n        $$\n        M_{S_n(z)} = M_{\\sigma_{xy}} M_{C_n(z)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n        $$\n    -   Improper rotation about the $x$-axis, $S_n(x)$: The rotation is $C_n(x)$ and the reflection is $\\sigma_{yz}$.\n        $$\n        M_{S_n(x)} = M_{\\sigma_{yz}} M_{C_n(x)} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & \\cos\\theta & -\\sin\\theta \\\\ 0 & \\sin\\theta & \\cos\\theta \\end{pmatrix}\n        $$\n    -   Improper rotation about the $y$-axis, $S_n(y)$: The rotation is $C_n(y)$ and the reflection is $\\sigma_{xz}$.\n        $$\n        M_{S_n(y)} = M_{\\sigma_{xz}} M_{C_n(y)} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & -1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & 1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & 0 & \\sin\\theta \\\\ 0 & -1 & 0 \\\\ -\\sin\\theta & 0 & \\cos\\theta \\end{pmatrix}\n        $$\n\nThe algorithm will first parse the input operation string to identify the operation type, order $n$ (if applicable), and axis (if applicable). Based on this information, the corresponding $3 \\times 3$ transformation matrix $M$ is constructed. The input point vector $\\vec{v}$ is then transformed by computing the matrix-vector product $M\\vec{v}$. The resulting vector's components are formatted to the specified precision. This procedure is applied systematically to all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_symmetry_operation(point, op_string):\n    \"\"\"\n    Applies a 3D symmetry operation to a point.\n\n    Args:\n        point (np.ndarray): A 1D numpy array of shape (3,) representing the coordinates (x, y, z).\n        op_string (str): The string representation of the symmetry operation.\n\n    Returns:\n        np.ndarray: The transformed point coordinates.\n    \"\"\"\n    op_type = op_string[0]\n    \n    # Identity\n    if op_type == 'E':\n        return point\n\n    # Inversion\n    if op_type == 'i':\n        M = -np.identity(3)\n        return M @ point\n\n    # Reflection\n    if op_type == 's':  # for \"sigma\"\n        plane = op_string.split('_')[1]\n        M = np.identity(3)\n        if plane == 'xy':\n            M[2, 2] = -1.0\n        elif plane == 'xz':\n            M[1, 1] = -1.0\n        elif plane == 'yz':\n            M[0, 0] = -1.0\n        return M @ point\n\n    # Proper and Improper Rotations\n    if op_type in ('C', 'S'):\n        n = int(op_string[1:-1])\n        axis = op_string[-1]\n        \n        if n <= 0:\n            raise ValueError(\"Rotation order n must be a positive integer.\")\n            \n        theta = (2 * np.pi) / n\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Proper Rotation Matrix (R)\n        if axis == 'z':\n            R = np.array([\n                [cos_theta, -sin_theta, 0],\n                [sin_theta,  cos_theta, 0],\n                [0,          0,         1]\n            ])\n        elif axis == 'x':\n            R = np.array([\n                [1, 0,           0],\n                [0, cos_theta,  -sin_theta],\n                [0, sin_theta,   cos_theta]\n            ])\n        elif axis == 'y':\n            R = np.array([\n                [cos_theta,  0, sin_theta],\n                [0,          1, 0],\n                [-sin_theta, 0, cos_theta]\n            ])\n        else:\n            raise ValueError(f\"Invalid rotation axis: {axis}\")\n\n        # If it's a proper rotation (C)\n        if op_type == 'C':\n            return R @ point\n\n        # If it's an improper rotation (S)\n        if op_type == 'S':\n            # Sigma_h reflection matrix\n            sigma_h = np.identity(3)\n            if axis == 'x':\n                sigma_h[0, 0] = -1.0\n            elif axis == 'y':\n                sigma_h[1, 1] = -1.0\n            elif axis == 'z':\n                sigma_h[2, 2] = -1.0\n            \n            # S_n = sigma_h * C_n\n            M = sigma_h @ R\n            return M @ point\n            \n    raise ValueError(f\"Unknown operation string: {op_string}\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # language: Python\n    # version: 3.12\n    # libraries:\n    #     - name: numpy\n    #       version: 1.23.5\n    test_cases = [\n        ((1.0, 2.0, 3.0), \"C2z\"),\n        ((1.0, 0.0, 0.0), \"sigma_yz\"),\n        ((0.0, 1.0, 0.0), \"C3x\"),\n        ((0.0, 0.0, 1.0), \"S4z\"),\n        ((1.0, 1.0, 1.0), \"C4z\"),\n        ((0.0, 0.0, 5.0), \"C6z\"),\n        ((3.0, -2.0, 0.0), \"sigma_xy\"),\n        ((-1.5, 2.5, -3.5), \"i\"),\n        ((2.0, 0.0, 0.0), \"E\"),\n        ((1.0, 2.0, 3.0), \"C2y\"),\n    ]\n\n    results = []\n    for point_coords, op_string in test_cases:\n        point_vec = np.array(point_coords, dtype=float)\n        \n        transformed_point = apply_symmetry_operation(point_vec, op_string)\n        \n        # Format the result with 6 decimal places and no spaces.\n        formatted_result = f\"[{transformed_point[0]:.6f},{transformed_point[1]:.6f},{transformed_point[2]:.6f}]\"\n        results.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A collection of symmetry operations for a molecule is not just a random set; it must form a mathematical group. This exercise bridges the gap between abstract group theory and computational practice by tasking you with creating a program to verify the four defining axioms of a group—closure, associativity, identity, and inverse—for sets of symmetry operation matrices. ",
            "id": "2458755",
            "problem": "You are given finite sets of real square matrices representing three-dimensional symmetry operations under matrix multiplication, a framework commonly used to model molecular point groups in computational chemistry. A set of matrices forms a mathematical group under matrix multiplication if and only if it satisfies all of the following four axioms for its binary operation:\n\n1. Closure: For all elements $A$ and $B$ in the set $S$, the product $AB$ is also in $S$.\n2. Associativity: For all elements $A$, $B$, and $C$ in the set $S$, $(AB)C = A(BC)$.\n3. Identity: There exists an element $E$ in the set $S$ such that for all $A$ in $S$, $EA = AE = A$.\n4. Inverses: For every element $A$ in the set $S$, there exists an element $B$ in the set $S$ such that $AB = BA = E$, where $E$ is the identity element from axiom $3$.\n\nIn this task, matrix equality must be interpreted numerically with a tolerance: two matrices $X$ and $Y$ are considered equal if $\\max_{i,j} |X_{ij} - Y_{ij}| \\le \\tau$, with $\\tau = 10^{-8}$.\n\nYour program must verify, for each provided test set, the truth values of the four axioms and also report whether the set is a group (the logical conjunction of the four axioms). All multiplications are standard $3 \\times 3$ real matrix multiplications, and matrix entries are real numbers. All angles (when appearing within rotation matrices below) are defined implicitly by their trigonometric values and no explicit angle unit is required in the input because only numeric matrices are provided.\n\nTest suite (each set $S_k$ is a finite subset of $\\mathbb{R}^{3 \\times 3}$):\n\n- Set $S_1$ (the point group $\\mathrm{C}_{2v}$ with principal axis along $z$; the elements are the identity, a $180^\\circ$ rotation about $z$, and two mirror reflections):\n  $$\n  I = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix},\\quad\n  C_{2z} = \\begin{bmatrix} -1 & 0 & 0 \\\\[4pt] 0 & -1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix},\\quad\n  \\sigma_{xz} = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & -1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix},\\quad\n  \\sigma_{yz} = \\begin{bmatrix} -1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}.\n  $$\n  Define $S_1 = \\{ I, C_{2z}, \\sigma_{xz}, \\sigma_{yz} \\}$.\n\n- Set $S_2$ (a non-closed set mixing a rotation and a reflection):\n  $$\n  I = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix},\\quad\n  R_{z,90} = \\begin{bmatrix} 0 & -1 & 0 \\\\[4pt] 1 & 0 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix},\\quad\n  \\sigma_{yz} = \\begin{bmatrix} -1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}.\n  $$\n  Define $S_2 = \\{ I, R_{z,90}, \\sigma_{yz} \\}$.\n\n- Set $S_3$ (a closed set without an identity element):\n  $$\n  O = \\begin{bmatrix} 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\end{bmatrix},\\quad\n  N = \\begin{bmatrix} 0 & 1 & 0 \\\\[4pt] 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\end{bmatrix}.\n  $$\n  Define $S_3 = \\{ O, N \\}$.\n\n- Set $S_4$ (a monoid with identity that lacks inverses for all elements):\n  $$\n  I = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix},\\quad\n  P = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\end{bmatrix}.\n  $$\n  Define $S_4 = \\{ I, P \\}$.\n\n- Set $S_5$ (the cyclic point group $\\mathrm{C}_3$ of rotations about $z$ by $0^\\circ$, $120^\\circ$, and $240^\\circ$):\n  $$\n  R_{z,120} = \\begin{bmatrix}\n  -\\tfrac{1}{2} & -\\tfrac{\\sqrt{3}}{2} & 0 \\\\[6pt]\n  \\tfrac{\\sqrt{3}}{2} & -\\tfrac{1}{2} & 0 \\\\[6pt]\n  0 & 0 & 1\n  \\end{bmatrix},\\quad\n  R_{z,240} = \\begin{bmatrix}\n  -\\tfrac{1}{2} & \\tfrac{\\sqrt{3}}{2} & 0 \\\\[6pt]\n  -\\tfrac{\\sqrt{3}}{2} & -\\tfrac{1}{2} & 0 \\\\[6pt]\n  0 & 0 & 1\n  \\end{bmatrix}.\n  $$\n  Define $S_5 = \\{ I, R_{z,120}, R_{z,240} \\}$, where $I$ is as above.\n\nRequired output for each test set $S_k$:\n\n- For each $S_k$, return a list of five boolean values in the order $[\\text{is\\_group}, \\text{closure}, \\text{associativity}, \\text{identity\\_exists}, \\text{inverses\\_exist}]$, where $\\text{is\\_group}$ is the logical conjunction of the four properties.\n- Your program should produce a single line of output containing the results for $S_1$ through $S_5$ as a comma-separated list of these five-element lists, enclosed in square brackets, for example: $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.\n\nNo user input is provided; all matrices are to be defined internally in the program as specified above. All numerical comparisons of matrices must use the tolerance $\\tau = 10^{-8}$ as defined.",
            "solution": "The problem requires the verification of group-theoretic properties for several finite sets of $3 \\times 3$ real matrices, where the binary operation is standard matrix multiplication. A given set $S$ forms a group if it satisfies four fundamental axioms: closure, associativity, existence of an identity element, and existence of an inverse for each element. The analysis must be performed algorithmically, accounting for numerical precision with a specified tolerance.\n\nThe algorithmic approach to validate each set $S_k$ proceeds by systematically testing each of the four group axioms. A boolean result is determined for each axiom, and the overall determination of whether the set constitutes a group is the logical conjunction of these four results.\n\nMatrix equality must be handled with care due to floating-point arithmetic. Two matrices, $X$ and $Y$, are considered equal if the maximum absolute difference between their corresponding elements is no greater than a tolerance $\\tau = 10^{-8}$. This condition is expressed as $\\max_{i,j} |X_{ij} - Y_{ij}| \\le \\tau$.\n\nThe validation procedure for each axiom is as follows:\n\n1.  **Closure**: To verify closure, one must confirm that for every pair of elements $A, B \\in S$, their product $C = AB$ is also an element of $S$. The algorithm iterates through all ordered pairs $(A, B)$ from the set $S$, computes their product $C$, and then checks if any matrix in $S$ is equal to $C$ within the given tolerance $\\tau$. If any product is found to not be in $S$, the closure property is false. If all products are found to be in $S$, the property is true.\n\n2.  **Associativity**: The associativity of matrix multiplication, $(AB)C = A(BC)$, is a fundamental theorem of linear algebra. It holds for any three matrices for which the products are defined. Since we are dealing with square matrices of the same dimension ($3 \\times 3$), this property is guaranteed to be true for any subset of such matrices. Therefore, a computational check is unnecessary; this axiom is satisfied for all test sets provided. The result for associativity is always true.\n\n3.  **Identity Element**: To verify the existence of an identity element, the algorithm must search for an element $E \\in S$ such that for all elements $A \\in S$, the products $EA = A$ and $AE = A$ hold true. The process involves iterating through each candidate element $E_{\\text{cand}} \\in S$ and testing if it satisfies the identity property with every other element $A \\in S$. If such an element $E$ is found, the property holds, and this unique identity element is stored for use in the inverse check. If the search completes without finding such an element, the property is false.\n\n4.  **Inverse Elements**: The existence of inverses is contingent upon the existence of an identity element, $E$. If no identity element exists, this property is false by definition. If an identity $E$ exists, the algorithm must then verify that for each element $A \\in S$, there exists a corresponding element $B \\in S$ (the inverse of $A$) such that $AB = BA = E$. This is checked by iterating through each $A \\in S$ and, for each $A$, searching for a suitable $B \\in S$ that satisfies the inverse condition. If every element in $S$ has an inverse within $S$, the property is true. If even one element lacks an inverse in $S$, the property is false.\n\nFinally, the property $\\text{is\\_group}$ is true if and only if all four axioms—closure, associativity, identity, and inverses—are simultaneously true.\n\nFor the given test sets:\n-   $S_1 = \\{ I, C_{2z}, \\sigma_{xz}, \\sigma_{yz} \\}$, where $I = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}$, $C_{2z} = \\begin{bmatrix} -1 & 0 & 0 \\\\[4pt] 0 & -1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}$, $\\sigma_{xz} = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & -1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}$, $\\sigma_{yz} = \\begin{bmatrix} -1 & 0 & 0 \\\\[4pt] 0 & 1 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}$. This set represents the point group $\\mathrm{C}_{2v}$ and is expected to be a group.\n-   $S_2 = \\{ I, R_{z,90}, \\sigma_{yz} \\}$, where $R_{z,90} = \\begin{bmatrix} 0 & -1 & 0 \\\\[4pt] 1 & 0 & 0 \\\\[4pt] 0 & 0 & 1 \\end{bmatrix}$. This set is not closed under multiplication (e.g., $R_{z,90} \\cdot \\sigma_{yz}$ is not in $S_2$).\n-   $S_3 = \\{ O, N \\}$, where $O = \\begin{bmatrix} 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\end{bmatrix}$, $N = \\begin{bmatrix} 0 & 1 & 0 \\\\[4pt] 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\end{bmatrix}$. This set is closed but lacks an identity element.\n-   $S_4 = \\{ I, P \\}$, where $P = \\begin{bmatrix} 1 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\\\[4pt] 0 & 0 & 0 \\end{bmatrix}$. This set forms a monoid; it is closed and has an identity, but the projection matrix $P$ is singular and lacks an inverse.\n-   $S_5 = \\{ I, R_{z,120}, R_{z,240} \\}$, where $R_{z,120} = \\begin{bmatrix} -\\tfrac{1}{2} & -\\tfrac{\\sqrt{3}}{2} & 0 \\\\[6pt] \\tfrac{\\sqrt{3}}{2} & -\\tfrac{1}{2} & 0 \\\\[6pt] 0 & 0 & 1 \\end{bmatrix}$ and $R_{z,240} = \\begin{bmatrix} -\\tfrac{1}{2} & \\tfrac{\\sqrt{3}}{2} & 0 \\\\[6pt] -\\tfrac{\\sqrt{3}}{2} & -\\tfrac{1}{2} & 0 \\\\[6pt] 0 & 0 & 1 \\end{bmatrix}$. This represents the cyclic group $\\mathrm{C}_{3}$ and is expected to be a group.\n\nThe implementation will consist of helper functions for each axiom check, which are then orchestrated by a main function that processes each test set and consolidates the results into the required output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute group properties.\n    \"\"\"\n    \n    # Define the tolerance for matrix equality checks.\n    tau = 1e-8\n\n    # Define common matrices used in the test sets.\n    I = np.array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])\n    sigma_yz = np.array([[-1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])\n\n    # Define the test suites as lists of numpy arrays.\n    test_cases = [\n        # Set S1 (point group C2v)\n        [\n            I,\n            np.array([[-1., 0., 0.], [0., -1., 0.], [0., 0., 1.]]), # C2z\n            np.array([[1., 0., 0.], [0., -1., 0.], [0., 0., 1.]]), # sigma_xz\n            sigma_yz,\n        ],\n        # Set S2 (non-closed set)\n        [\n            I,\n            np.array([[0., -1., 0.], [1., 0., 0.], [0., 0., 1.]]), # R_z,90\n            sigma_yz,\n        ],\n        # Set S3 (closed, no identity)\n        [\n            np.array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]), # O\n            np.array([[0., 1., 0.], [0., 0., 0.], [0., 0., 0.]]), # N\n        ],\n        # Set S4 (monoid, lacks inverses)\n        [\n            I,\n            np.array([[1., 0., 0.], [0., 0., 0.], [0., 0., 0.]]), # P\n        ],\n        # Set S5 (point group C3)\n        [\n            I,\n            np.array([[-0.5, -np.sqrt(3)/2, 0.], [np.sqrt(3)/2, -0.5, 0.], [0., 0., 1.]]), # R_z,120\n            np.array([[-0.5, np.sqrt(3)/2, 0.], [-np.sqrt(3)/2, -0.5, 0.], [0., 0., 1.]]), # R_z,240\n        ],\n    ]\n\n    # --- Helper functions for axiom verification ---\n\n    def are_matrices_equal(A, B, tol):\n        \"\"\"Checks if two matrices A and B are equal within a given tolerance.\"\"\"\n        return np.max(np.abs(A - B)) <= tol\n\n    def check_closure(S, tol):\n        \"\"\"Checks if the set S is closed under matrix multiplication.\"\"\"\n        for A in S:\n            for B in S:\n                product = A @ B\n                is_in_set = any(are_matrices_equal(product, C, tol) for C in S)\n                if not is_in_set:\n                    return False\n        return True\n\n    def find_identity_element(S, tol):\n        \"\"\"Finds the identity element in set S, if it exists.\"\"\"\n        for E_cand in S:\n            is_identity = all(\n                are_matrices_equal(E_cand @ A, A, tol) and \n                are_matrices_equal(A @ E_cand, A, tol)\n                for A in S\n            )\n            if is_identity:\n                return E_cand\n        return None\n\n    def check_inverses(S, E, tol):\n        \"\"\"Checks if every element in S has an inverse in S.\"\"\"\n        if E is None:\n            return False\n        for A in S:\n            has_inverse = any(\n                are_matrices_equal(A @ B, E, tol) and \n                are_matrices_equal(B @ A, E, tol)\n                for B in S\n            )\n            if not has_inverse:\n                return False\n        return True\n\n    # --- Main processing loop ---\n\n    results = []\n    for S in test_cases:\n        # Axiom 1: Closure\n        closure = check_closure(S, tau)\n\n        # Axiom 2: Associativity (always true for matrix multiplication)\n        associativity = True\n\n        # Axiom 3: Identity\n        identity_element = find_identity_element(S, tau)\n        identity_exists = identity_element is not None\n        \n        # Axiom 4: Inverses\n        inverses_exist = check_inverses(S, identity_element, tau)\n        \n        # Is it a group? (logical conjunction of all axioms)\n        is_group = closure and associativity and identity_exists and inverses_exist\n\n        results.append([is_group, closure, associativity, identity_exists, inverses_exist])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of group theory in chemistry lies in its ability to predict and simplify complex problems, such as the analysis of molecular vibrations. In this capstone practice, you will apply the full formalism of representation theory to the methane molecule, using its $T_d$ symmetry to decompose its stretching vibrations into fundamental symmetry components, a crucial skill for interpreting vibrational spectra. ",
            "id": "2458793",
            "problem": "Methane has tetrahedral symmetry with point group $T_{d}$. Consider the four $\\mathrm{C-H}$ stretching internal coordinates, one along each $\\mathrm{C-H}$ bond, forming a four-dimensional vector space. Let $\\Gamma_{\\text{stretch}}$ be the reducible representation afforded by these four basis functions under the action of $T_{d}$.\n\nThe order of the group is $h=24$, and the conjugacy classes are $E$, $8C_{3}$, $3C_{2}$, $6S_{4}$, and $6\\sigma_{d}$. The irreducible representations and their characters are:\n- $A_{1}$: $1, 1, 1, 1, 1$\n- $A_{2}$: $1, 1, 1, -1, -1$\n- $E$: $2, -1, 2, 0, 0$\n- $T_{1}$: $3, 0, -1, 1, -1$\n- $T_{2}$: $3, 0, -1, -1, 1$\n\nGeometric facts about $T_{d}$ needed to identify how operations act on the $\\mathrm{C-H}$ bonds: each $C_{3}$ axis passes through one $\\mathrm{C-H}$ bond; each $C_{2}$ and $S_{4}$ axis passes through midpoints of opposite edges; each $\\sigma_{d}$ plane contains the carbon and exactly two hydrogens.\n\nDetermine the multiplicity of each irreducible representation in the decomposition of $\\Gamma_{\\text{stretch}}$ into irreducible components. Express your final answer as a single row matrix giving the multiplicities in the order $\\left(A_{1}, A_{2}, E, T_{1}, T_{2}\\right)$. No rounding is required and no units are to be reported.",
            "solution": "The problem requires the decomposition of a reducible representation, $\\Gamma_{\\text{stretch}}$, based on the four $\\mathrm{C-H}$ stretching coordinates of methane, into its constituent irreducible representations within the $T_{d}$ point group. The problem is scientifically sound, well-posed, and contains all necessary information for a unique solution. Therefore, we proceed with the analysis.\n\nThe first step is to determine the characters, $\\chi_{\\text{stretch}}(R)$, of the reducible representation $\\Gamma_{\\text{stretch}}$ for each conjugacy class $R$ of the $T_{d}$ group. The character of an operation is the number of basis functions—in this case, the four $\\mathrm{C-H}$ bond vectors—that remain unshifted by that operation.\n\nThe basis set consists of four vectors, $r_{1}, r_{2}, r_{3}, r_{4}$, each aligned with a $\\mathrm{C-H}$ bond. We analyze the effect of one representative operation from each class.\n\n1.  **Identity ($E$)**: The identity operation leaves all four $\\mathrm{C-H}$ bonds unchanged. Therefore, the character is $4$.\n    $$\\chi_{\\text{stretch}}(E) = 4$$\n\n2.  **$C_{3}$ rotation ($8C_{3}$)**: Each $C_{3}$ axis passes through the carbon atom and one hydrogen atom, i.e., along one $\\mathrm{C-H}$ bond. This operation leaves the bond lying on the axis invariant while permuting the other three bonds. Thus, only one bond is unshifted.\n    $$\\chi_{\\text{stretch}}(C_{3}) = 1$$\n\n3.  **$C_{2}$ rotation ($3C_{2}$)**: Each $C_{2}$ axis bisects two opposite $\\mathrm{H-C-H}$ angles, passing through the carbon atom but through no hydrogen atoms. For instance, an axis may pass between the $\\mathrm{H}_{1}-\\mathrm{H}_{2}$ pair and the $\\mathrm{H}_{3}-\\mathrm{H}_{4}$ pair. A $C_{2}$ rotation about this axis will exchange $\\mathrm{H}_{1}$ with $\\mathrm{H}_{2}$ and $\\mathrm{H}_{3}$ with $\\mathrm{H}_{4}$. Consequently, all four $\\mathrm{C-H}$ bonds are moved to different positions. No bond is left unshifted.\n    $$\\chi_{\\text{stretch}}(C_{2}) = 0$$\n\n4.  **$S_{4}$ improper rotation ($6S_{4}$)**: The $S_{4}$ axes are coincident with the $C_{2}$ axes. An $S_{4}$ operation consists of a $90^{\\circ}$ rotation followed by a reflection in a plane perpendicular to the axis. This complex operation moves every hydrogen atom to a new position, meaning every $\\mathrm{C-H}$ bond is shifted.\n    $$\\chi_{\\text{stretch}}(S_{4}) = 0$$\n\n5.  **$\\sigma_{d}$ dihedral reflection ($6\\sigma_{d}$)**: Each $\\sigma_{d}$ plane contains the carbon atom and two hydrogen atoms, for example $\\mathrm{H}_{1}$ and $\\mathrm{H}_{2}$. The two $\\mathrm{C-H}$ bonds associated with these atoms ($\\mathrm{C-H}_{1}$ and $\\mathrm{C-H}_{2}$) lie within the plane of reflection and are therefore unshifted. The other two bonds ($\\mathrm{C-H}_{3}$ and $\\mathrm{C-H}_{4}$) are reflected into each other. Thus, exactly two bonds remain invariant.\n    $$\\chi_{\\text{stretch}}(\\sigma_{d}) = 2$$\n\nThe set of characters for the reducible representation $\\Gamma_{\\text{stretch}}$ is thus $\\chi_{\\text{stretch}} = (4, 1, 0, 0, 2)$.\n\nThe next step is to use the great orthogonality theorem's reduction formula to find the multiplicity, $a_{i}$, of each irreducible representation (irrep) $i$ in $\\Gamma_{\\text{stretch}}$:\n$$a_{i} = \\frac{1}{h} \\sum_{R} n(R) \\chi_{i}(R) \\chi_{\\text{stretch}}(R)$$\nHere, $h$ is the order of the group, which is $24$. $n(R)$ is the number of operations in the class $R$, and $\\chi_{i}(R)$ is the character of the irrep $i$ for the class $R$.\n\nWe compute $a_{i}$ for each irrep: $A_{1}$, $A_{2}$, $E$, $T_{1}$, and $T_{2}$.\n\n-   **For $A_{1}$**: $\\chi(A_{1}) = (1, 1, 1, 1, 1)$\n    $$a_{A_{1}} = \\frac{1}{24} [1(4)(1) + 8(1)(1) + 3(0)(1) + 6(0)(1) + 6(2)(1)]$$\n    $$a_{A_{1}} = \\frac{1}{24} [4 + 8 + 0 + 0 + 12] = \\frac{24}{24} = 1$$\n\n-   **For $A_{2}$**: $\\chi(A_{2}) = (1, 1, 1, -1, -1)$\n    $$a_{A_{2}} = \\frac{1}{24} [1(4)(1) + 8(1)(1) + 3(0)(1) + 6(0)(-1) + 6(2)(-1)]$$\n    $$a_{A_{2}} = \\frac{1}{24} [4 + 8 + 0 + 0 - 12] = \\frac{0}{24} = 0$$\n\n-   **For $E$**: $\\chi(E) = (2, -1, 2, 0, 0)$\n    $$a_{E} = \\frac{1}{24} [1(4)(2) + 8(1)(-1) + 3(0)(2) + 6(0)(0) + 6(2)(0)]$$\n    $$a_{E} = \\frac{1}{24} [8 - 8 + 0 + 0 + 0] = \\frac{0}{24} = 0$$\n\n-   **For $T_{1}$**: $\\chi(T_{1}) = (3, 0, -1, 1, -1)$\n    $$a_{T_{1}} = \\frac{1}{24} [1(4)(3) + 8(1)(0) + 3(0)(-1) + 6(0)(1) + 6(2)(-1)]$$\n    $$a_{T_{1}} = \\frac{1}{24} [12 + 0 + 0 + 0 - 12] = \\frac{0}{24} = 0$$\n\n-   **For $T_{2}$**: $\\chi(T_{2}) = (3, 0, -1, -1, 1)$\n    $$a_{T_{2}} = \\frac{1}{24} [1(4)(3) + 8(1)(0) + 3(0)(-1) + 6(0)(-1) + 6(2)(1)]$$\n    $$a_{T_{2}} = \\frac{1}{24} [12 + 0 + 0 + 0 + 12] = \\frac{24}{24} = 1$$\n\nThe decomposition of the reducible representation is therefore:\n$$\\Gamma_{\\text{stretch}} = 1 A_{1} \\oplus 0 A_{2} \\oplus 0 E \\oplus 0 T_{1} \\oplus 1 T_{2} = A_{1} \\oplus T_{2}$$\nThe multiplicities for the irreducible representations in the order $(A_{1}, A_{2}, E, T_{1}, T_{2})$ are $(1, 0, 0, 0, 1)$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 1 & 0 & 0 & 0 & 1 \\end{pmatrix}}$$"
        }
    ]
}