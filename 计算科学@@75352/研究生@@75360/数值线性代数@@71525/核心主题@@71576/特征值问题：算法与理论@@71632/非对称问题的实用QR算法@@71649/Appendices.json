{"hands_on_practices": [{"introduction": "理论上，QR 算法是一个优雅的迭代过程，但其最简单的“无位移”形式在实践中可能会失效，导致收敛停滞。本练习将引导您构建一个特例，其中无位移 QR 算法会陷入循环，然后通过引入威尔金森位移 (Wilkinson shift) 来打破僵局，从而直观地理解为何动态位移策略是保证算法收敛的关键。[@problem_id:3593257]", "problem": "构建一个具体的、自包含的计算实验，以演示无位移正交三角 (QR) 算法在处理实非对称上Hessenberg矩阵时的一种失效模式，以及引入Wilkinson位移如何打破该循环。严格按照精确的数学术语进行，并从基本定义出发实现以下内容。\n\n您只能使用以下基本基础：\n- 实上Hessenberg矩阵的定义：一个方阵 $A \\in \\mathbb{R}^{n \\times n}$，对于所有 $i  j + 1$，都有 $A_{i,j} = 0$。\n- 无位移正交三角 (QR) 步的定义：给定一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，计算其QR分解 $A = Q R$，其中 $Q$ 是正交矩阵，$R$ 是对角元为严格正数的上三角矩阵，然后定义下一个迭代矩阵为 $A^{+} = R Q$。\n- 针对非对称问题的Wilkinson位移的定义：设 $A \\in \\mathbb{R}^{n \\times n}$，构建其尾部 $2 \\times 2$ 主子矩阵 $T = A_{n-1:n, n-1:n}$；设 $\\lambda_1,\\lambda_2 \\in \\mathbb{C}$ 为 $T$ 的特征值；定义位移 $\\mu \\in \\mathbb{C}$ 为 $\\{\\lambda_1,\\lambda_2\\}$ 中使模 $|\\mu - A_{n,n}|$ 最小的那个特征值；移位步通过计算QR分解 $A - \\mu I = Q R$ 并设置 $A^{+} = R Q + \\mu I$ 来完成。\n- 具有正对角元的QR分解的唯一性：如果 $A \\in \\mathbb{R}^{n \\times n}$ 是非奇异矩阵，且 $A = Q R$，其中 $Q$ 是正交矩阵，$R$ 是对角元为严格正数的上三角矩阵，则 $Q$ 和 $R$ 是唯一确定的。\n\n您必须实现以下内容。\n1) 构建一个具体的实非对称正交 $3 \\times 3$ 上Hessenberg矩阵 $H(\\theta_1,\\theta_2)$，作为作用于相邻坐标平面的两个实Givens旋转的乘积：\n   - 定义平面旋转 $G_{12}(\\theta_1) \\in \\mathbb{R}^{3 \\times 3}$ 为\n     $$\n     G_{12}(\\theta_1) =\n     \\begin{bmatrix}\n     \\cos(\\theta_1)  -\\sin(\\theta_1)  0 \\\\\n     \\sin(\\theta_1)  \\cos(\\theta_1)  0 \\\\\n     0  0  1\n     \\end{bmatrix}.\n     $$\n   - 定义平面旋转 $G_{23}(\\theta_2) \\in \\mathbb{R}^{3 \\times 3}$ 为\n     $$\n     G_{23}(\\theta_2) =\n     \\begin{bmatrix}\n     1  0  0 \\\\\n     0  \\cos(\\theta_2)  -\\sin(\\theta_2) \\\\\n     0  \\sin(\\theta_2)  \\cos(\\theta_2)\n     \\end{bmatrix}.\n     $$\n   - 令 $H(\\theta_1,\\theta_2) = G_{12}(\\theta_1)\\, G_{23}(\\theta_2)$。在您的解法中证明，对于一般的 $\\theta_1,\\theta_2$，$H(\\theta_1,\\theta_2)$ 是正交的、上Hessenberg形式的且非对称的。\n\n2) 对任何方阵 $A \\in \\mathbb{C}^{n \\times n}$ 定义次对角线度量\n   $$\n   S(A) \\stackrel{\\mathrm{def}}{=} \\left\\| \\big( A_{2,1}, A_{3,2}, \\dots, A_{n,n-1} \\big) \\right\\|_2.\n   $$\n   这是第一条次对角线的欧几里得范数。在您的代码中，对任何方阵都直接应用此定义，即使它在一次迭代后不再是海森堡矩阵。\n\n3) 按照上述定义，实现一个无位移步和一个Wilkinson移位步。为了消除符号歧义并与唯一性属性保持一致，在计算无位移QR分解 $A = Q R$ 时，您必须翻转 $Q$ 的列和 $R$ 的行的符号，以使 $R$ 的对角元为严格正实数，然后再形成 $A^{+} = R Q$。对于可能为复数的 $\\mu$ 的移位步，则不需要正性约定。\n\n4) 对于每个测试，计算比率\n   $$\n   r_{\\mathrm{unsh}} \\stackrel{\\mathrm{def}}{=} \n   \\begin{cases}\n   \\dfrac{S(A^{+}_{\\mathrm{unsh}})}{S(A_0)}  \\text{if } S(A_0) \\neq 0,\\\\\n   0  \\text{if } S(A_0) = 0,\n   \\end{cases}\n   \\qquad\n   r_{\\mathrm{shift}} \\stackrel{\\mathrm{def}}{=}\n   \\begin{cases}\n   \\dfrac{S(A^{+}_{\\mathrm{shift}})}{S(A_0)}  \\text{if } S(A_0) \\neq 0,\\\\\n   0  \\text{if } S(A_0) = 0,\n   \\end{cases}\n   $$\n   其中 $A_0 = H(\\theta_1,\\theta_2)$，$A^{+}_{\\mathrm{unsh}}$ 是对 $A_0$ 应用单次无位移步的结果，而 $A^{+}_{\\mathrm{shift}}$ 是对 $A_0$ 应用单次Wilkinson移位步的结果。\n\n5) 角度单位要求：将所有角度 $\\theta$ 解释为弧度。\n\n测试套件和答案规范：\n- 使用以下三个测试，每个测试由一对弧度值 $(\\theta_1,\\theta_2)$ 指定。\n  - 测试 $1$ (一般非对称正交上Hessenberg矩阵): $\\theta_1 = 0.4$, $\\theta_2 = -0.7$.\n  - 测试 $2$ (边界情况，已是块上三角矩阵): $\\theta_1 = 0.9$, $\\theta_2 = 0$.\n  - 测试 $3$ (另一个一般非对称正交上Hessenberg矩阵): $\\theta_1 = -1.1$, $\\theta_2 = 0.6$.\n- 对于每个测试，计算如上定义的 $r_{\\mathrm{unsh}}$ 和 $r_{\\mathrm{shift}}$。这些是实值非负浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n  $$\n  \\big[ r_{\\mathrm{unsh}}^{(1)}, r_{\\mathrm{shift}}^{(1)}, r_{\\mathrm{unsh}}^{(2)}, r_{\\mathrm{shift}}^{(2)}, r_{\\mathrm{unsh}}^{(3)}, r_{\\mathrm{shift}}^{(3)} \\big].\n  $$\n  不允许有其他输出。\n\n您的实现对于所提供的测试套件必须是正确的，并且从上述定义来看在科学上是合理的。重点阐述逻辑推理，解释为什么无位移步在这些输入上会循环，以及为什么Wilkinson位移能打破该循环。输出量是指定的浮点数，角度单位为弧度。", "solution": "问题陈述是一个有效的、自包含的数值线性代数计算练习。它要求构建和分析无位移QR算法中的一种特定失效模式，并使用Wilkinson位移解决该问题。\n\n该实验基于一个实非对称正交上Hessenberg矩阵 $H$。我们将首先确定该矩阵的性质，然后分析两种QR算法变体应用于该矩阵时的行为。\n\n### 矩阵 $H(\\theta_1, \\theta_2)$ 的构造和性质\n\n该矩阵被定义为 $\\mathbb{R}^3$ 中两个Givens旋转的乘积：$H(\\theta_1, \\theta_2) = G_{12}(\\theta_1) G_{23}(\\theta_2)$。令 $c_k = \\cos(\\theta_k)$ 且 $s_k = \\sin(\\theta_k)$，对于 $k=1,2$。矩阵如下：\n$$\nG_{12}(\\theta_1) =\n\\begin{bmatrix}\nc_1  -s_1  0 \\\\\ns_1   c_1  0 \\\\\n0  0  1\n\\end{bmatrix},\n\\quad\nG_{23}(\\theta_2) =\n\\begin{bmatrix}\n1  0  0 \\\\\n0  c_2  -s_2 \\\\\n0  s_2   c_2\n\\end{bmatrix}.\n$$\n计算其乘积：\n$$\nH(\\theta_1, \\theta_2) =\n\\begin{bmatrix}\nc_1  -s_1  0 \\\\\ns_1   c_1  0 \\\\\n0  0  1\n\\end{bmatrix}\n\\begin{bmatrix}\n1  0  0 \\\\\n0  c_2  -s_2 \\\\\n0  s_2   c_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nc_1  -s_1 c_2  s_1 s_2 \\\\\ns_1   c_1 c_2  -c_1 s_2 \\\\\n0  s_2  c_2\n\\end{bmatrix}.\n$$\n\n我们现在证明其所需的性质。\n1.  **正交性**：Givens旋转矩阵是正交的。两个正交矩阵的乘积也是正交的。设 $Q_1, Q_2$ 为正交矩阵，因此 $Q_1^T Q_1 = I$ 且 $Q_2^T Q_2 = I$。那么它们的乘积 $Q_1 Q_2$ 满足 $(Q_1 Q_2)^T (Q_1 Q_2) = Q_2^T Q_1^T Q_1 Q_2 = Q_2^T I Q_2 = Q_2^T Q_2 = I$。由于 $G_{12}(\\theta_1)$ 和 $G_{23}(\\theta_2)$ 是正交的，它们的乘积 $H(\\theta_1, \\theta_2)$ 也是一个正交矩阵。\n\n2.  **上Hessenberg形式**：如果对于所有 $i  j+1$ 都有 $A_{i,j}=0$，则矩阵 $A$ 是上Hessenberg矩阵。对于一个 $3 \\times 3$ 的矩阵，这个条件只要求元素 $A_{3,1}$ 为零。从 $H(\\theta_1, \\theta_2)$ 的计算形式可知，元素 $H_{3,1}$ 为 $0$。因此，$H$ 是一个上Hessenberg矩阵。\n\n3.  **非对称性**：如果 $H = H^T$，则矩阵 $H$ 是对称的。$H$ 的转置是：\n    $$\n    H^T =\n    \\begin{bmatrix}\n    c_1  s_1  0 \\\\\n    -s_1 c_2  c_1 c_2  s_2 \\\\\n    s_1 s_2  -c_1 s_2  c_2\n    \\end{bmatrix}.\n    $$\n    为了使 $H = H^T$，我们必须有，例如，$H_{1,2} = H_{2,1}$ 和 $H_{1,3}=H_{3,1}$。\n    -   $H_{1,3} = s_1 s_2$ 且 $H_{3,1} = 0$。要使它们相等，需要 $s_1 s_2 = 0$，这意味着 $\\sin(\\theta_1)=0$ 或 $\\sin(\\theta_2)=0$。\n    -   $H_{1,2} = -s_1 c_2$ 且 $H_{2,1} = s_1$。要使它们相等，需要 $-s_1 c_2 = s_1$，即 $s_1(1+c_2)=0$。\n    因此，对称性要求对 $\\theta_1$ 和 $\\theta_2$ 有限制性条件（例如，是 $\\pi$ 的整数倍）。对于一般角度，例如测试套件中提供的角度，这些条件不被满足，因此矩阵 $H$ 是非对称的。\n\n### 无位移QR算法的失效\n\n无位移QR步定义为 $A_0 = Q_0 R_0$ 和 $A_1 = R_0 Q_0$。一个关键细节是，当 $R_0$ 的对角元被限制为严格正数时，非奇异矩阵 $A_0$ 的QR分解的唯一性。\n\n我们的初始矩阵 $A_0 = H(\\theta_1, \\theta_2)$ 是正交的。考虑将其分解为一个正交矩阵 $Q_0$ 和一个上三角矩阵 $R_0$。一个平凡的分解是 $A_0 = A_0 \\cdot I$，其中 $Q_0 = A_0$ 且 $R_0 = I$。矩阵 $R_0=I$ 是上三角矩阵，其对角元均为 $1$，是严格正数。根据唯一性属性，这必须是所要求的QR分解。\n\n给定 $Q_0 = A_0$ 和 $R_0=I$，无位移QR算法的下一次迭代是：\n$$\nA_1 = R_0 Q_0 = I \\cdot A_0 = A_0.\n$$\n算法立即停滞：对于所有 $k \\ge 0$，$A_{k+1} = A_k$。次对角线上的元素不发生变化。对于一个 $3 \\times 3$ 矩阵 $A$，其次对角范数为 $S(A) = \\sqrt{|A_{2,1}|^2 + |A_{3,2}|^2}$。对于我们的初始矩阵 $A_0=H$，我们有：\n$$\nS(A_0) = \\sqrt{|\\sin(\\theta_1)|^2 + |\\sin(\\theta_2)|^2}.\n$$\n由于 $A_1 = A_0$，我们有 $S(A_1) = S(A_0)$。收敛比为：\n$$\nr_{\\mathrm{unsh}} = \\frac{S(A_1)}{S(A_0)} = 1,\n$$\n前提是 $S(A_0) \\neq 0$。比率为 $1$ 意味着完全没有进展，证明了无位移算法对于此类矩阵的失效。对于任何实正交Hessenberg矩阵，这种失效都是一个已知现象。\n\n### Wilkinson移位QR算法的成功\n\nWilkinson移位步打破了这种停滞。关键在于引入了一个位移 $\\mu \\in \\mathbb{C}$。\n1.  选择位移 $\\mu$ 作为 $A_0$ 尾部 $2 \\times 2$ 子矩阵的一个特征值，特别是更接近角点元素 $A_{0,n,n}$ 的那个。对于我们的 $3 \\times 3$ 矩阵 $H$，该子矩阵是 $T = H_{2:3, 2:3}$。\n2.  然后算法对一个移位后的矩阵进行分解：$A_0 - \\mu I = QR$。\n3.  下一次迭代为 $A_1 = RQ + \\mu I = Q^T A_0 Q$。\n\n关键的区别在于矩阵 $B = A_0 - \\mu I$ 不再是正交的（除非 $\\mu=0$，但这通常不成立）。因此，它的QR分解是非平凡的（$Q \\ne B, R \\ne I$）。由此产生的正交相似变换 $A_1 = Q^T A_0 Q$ 会生成一个通常不同于 $A_0$ 的新矩阵 $A_1$。\n\nWilkinson位移是一个特别有效的选择，因为它源自我们希望实现收敛的矩阵部分（即，将次对角元 $A_{n,n-1}$ 驱向零）。QR算法的理论，特别是隐式Q定理，表明这种位移选择能够导致目标次对角元非常快速的收敛，通常是二次收敛。\n\n因此，我们预期 $A_1$ 的次对角元的大小会显著小于 $A_0$ 的次对角元。这将导致次对角范数比 $r_{\\mathrm{shift}} = S(A_1)/S(A_0)$ 远小于 $1$，表明在收敛方面取得了成功进展。即使在一个次对角元已经为零的特殊情况下（如测试2中，$\\theta_2=0$），Wilkinson位移也能正确适应，有效地对问题进行降阶并处理剩余的子问题，从而仍然促进收敛。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and runs the computational experiment as per the problem description.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.4, -0.7),   # Test 1\n        (0.9, 0),      # Test 2\n        (-1.1, 0.6)    # Test 3\n    ]\n\n    results = []\n    \n    for theta1, theta2 in test_cases:\n        # Step 1: Construct the initial matrix H(theta1, theta2)\n        c1, s1 = np.cos(theta1), np.sin(theta1)\n        c2, s2 = np.cos(theta2), np.sin(theta2)\n        \n        # H = G12 * G23\n        h_matrix = np.array([\n            [c1, -s1 * c2, s1 * s2],\n            [s1, c1 * c2, -c1 * s2],\n            [0, s2, c2]\n        ])\n        \n        a0 = h_matrix\n        \n        # Step 2: Define the subdiagonal measure S(A)\n        def subdiagonal_norm(A):\n            n = A.shape[0]\n            # Get the first subdiagonal elements A[1,0], A[2,1], ...\n            subdiag = np.diagonal(A, offset=-1)\n            # The definition is || (A_2,1, ..., A_n,n-1) ||_2\n            # np.diagonal handles this perfectly.\n            return np.linalg.norm(subdiag)\n\n        # Calculate initial subdiagonal norm\n        s_a0 = subdiagonal_norm(a0)\n\n        # Step 3: Implement one unshifted and one Wilkinson-shifted step\n\n        # Unshifted QR step\n        def unshifted_step(A):\n            # QR factorization with positive diagonal on R\n            q, r = np.linalg.qr(A)\n            \n            # Enforce strictly positive diagonal on R as per the problem.\n            # numpy's qr returns non-negative, which is sufficient for non-singular A.\n            # We implement the sign flip explicitly to adhere to the prompt.\n            d = np.sign(np.diag(r))\n            d[d == 0] = 1  # Handle case of zero on diagonal\n            D = np.diag(d)\n            \n            q_prime = q @ D\n            r_prime = D @ r # D is its own inverse\n            \n            # Next iterate is R'Q'\n            a_plus = r_prime @ q_prime\n            return a_plus\n\n        # Wilkinson-shifted QR step\n        def shifted_step(A):\n            n = A.shape[0]\n            \n            # Form the trailing 2x2 submatrix\n            T = A[n-2:n, n-2:n]\n            \n            # Find its eigenvalues\n            e_vals = np.linalg.eigvals(T)\n            \n            # Define the shift mu as the eigenvalue closer to A[n-1, n-1]\n            a_nn = A[n-1, n-1]\n            dist0 = np.abs(e_vals[0] - a_nn)\n            dist1 = np.abs(e_vals[1] - a_nn)\n            mu = e_vals[0] if dist0 = dist1 else e_vals[1]\n\n            # Form A - mu*I and compute its QR factorization.\n            # This can involve complex numbers.\n            B = A - mu * np.identity(n)\n            q, r = np.linalg.qr(B)\n            \n            # Next iterate is RQ + mu*I\n            a_plus = r @ q + mu * np.identity(n)\n            return a_plus\n\n        # Apply the steps\n        a_plus_unsh = unshifted_step(a0)\n        a_plus_shift = shifted_step(a0)\n\n        # Calculate final subdiagonal norms\n        s_unsh = subdiagonal_norm(a_plus_unsh)\n        s_shift = subdiagonal_norm(a_plus_shift)\n\n        # Step 4: Compute the ratios\n        if s_a0 != 0:\n            r_unsh = s_unsh / s_a0\n            r_shift = s_shift / s_a0\n        else:\n            r_unsh = 0.0\n            r_shift = 0.0\n        \n        results.extend([r_unsh, r_shift])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3593257"}, {"introduction": "在 QR 迭代中，一个关键的实际问题是：如何判断一个子对角线元素足够小，可以安全地“收缩”(deflate) 为零？一个简单的阈值规则在处理非正规矩阵时可能会失效，因为非正规性会放大微小扰动的影响。通过这个练习，您将亲手实现一个更稳健的收缩准则，该准则考虑了非正规放大效应，确保了算法在各种情况下的可靠性。[@problem_id:3593287]", "problem": "您需要为应用于实上Hessenberg矩阵的Francis隐式位移QR迭代设计并实现一个鲁棒的收缩（deflation）测试。在位置 $i$ 的收缩决策考虑由行和列 $i$ 及 $i+1$ 决定的 $2\\times 2$ 尾部主子问题，特别是次对角线元素 $h_{i+1,i}$。经典但朴素的收缩规则在 $|h_{i+1,i}| \\le \\tau \\left(|h_{i,i}| + |h_{i+1,i+1}|\\right)$ 时宣告收缩，其中 $\\tau$ 是一个很小的阈值。在高度非正规（nonnormal）的情况下，此规则可能会失败，因为两个对角块之间的有效耦合与乘积 $|h_{i,i+1}|\\,|h_{i+1,i}|$ 成比例，因此大的 $|h_{i,i+1}|$ 会放大 $|h_{i+1,i}|$ 对谱的影响，从而破坏收缩的安全性。您的任务是创建一个修正的收缩规则，该规则在对角相似性缩放变换下是鲁棒的，并能减轻非正规放大效应。\n\n从以下基本原则出发：\n- 对于一个上Hessenberg矩阵，在位置 $i$ 进行收缩意味着将 $h_{i+1,i}$ 置为零，这在精确算术层面上将矩阵分裂成两个解耦的块。\n- 在遵循电气和电子工程师协会（IEEE）标准的浮点运算中，如果引起的向后误差在 $O(u)$ 范围内（其中 $u$ 是单位舍入误差），则相对于适当局部尺度的微小元素可以被忽略。在实践中，人们使用一个可调阈值 $\\tau$ 来代表 $u$ 乘以一个尺度的适度倍数。\n- 对于一个 $2\\times 2$ 块 $\\begin{bmatrix} a  b \\\\ c  d \\end{bmatrix}$，其特征多项式的判别式是 $(a-d)^2 + 4bc$。将 $c$ 扰动到 $0$ 会使判别式改变 $-4bc$，因此产生的特征值扰动取决于 $bc$ 和分离度 $|a-d|$。\n\n设计一个满足以下标准的修正且实用的收缩测试：\n- 当 $|h_{i,i+1}|$ 与 $|h_{i,i}|+|h_{i+1,i+1}|$ 相当或趋于零时，它简化为朴素测试。\n- 当 $|h_{i,i+1}|$ 相对于 $|h_{i,i}|+|h_{i+1,i+1}|$ 很大时，它会加强朴素测试，以抑制由非正规放大引起的非安全收缩。\n- 它在对位于行和列 $i$ 及 $i+1$ 的 $2\\times 2$ 块进行对角相似性缩放变换时保持不变，即在形如 $D^{-1}\\begin{bmatrix} h_{i,i}  h_{i,i+1} \\\\ h_{i+1,i}  h_{i+1,i+1}\\end{bmatrix}D$ 的变换下不变，其中 $D=\\mathrm{diag}(d_i,d_{i+1})$ 且 $d_i,d_{i+1} \\neq 0$。\n\n您必须完成以下任务。\n1) 从第一性原理出发，提出一个修正规则，该规则仅在朴素界 $|h_{i+1,i}| \\le \\tau \\left(|h_{i,i}| + |h_{i+1,i+1}|\\right)$ 和一个额外的非正规性保护条件同时成立时才宣告收缩。该保护条件必须明确包含乘积 $|h_{i,i+1}|\\,|h_{i+1,i}|$ 和局部尺度 $\\left(|h_{i,i}| + |h_{i+1,i+1}|\\right)^2$。论证必须基于判别式变化与所选尺度的比较，并且不得依赖于所述基本原则之外的任何捷径公式。\n2) 通过分析 $a=d$、$|b|$ 很大但 $|c|$ 极小的 $2\\times 2$ 块 $\\begin{bmatrix} a  b \\\\ c  d\\end{bmatrix}$，解释为什么朴素规则会在非正规示例上失败。证明当 $a=d$ 时，特征值分离度与 $2\\sqrt{bc}$ 成比例，并推导关于 $bc$ 的必要条件，以确保将 $c$ 设置为 $0$ 不会导致相对于局部尺度的 $O(1)$ 级特征值变化。\n3) 实现一个程序，该程序给定一组测试用例，在请求的收缩位置 $i$（使用从零开始的索引）评估朴素规则和您修正的规则。在每个测试用例中，$i$ 表示 $2\\times 2$ 块的左上角索引，因此耦合项是 $h_{i+1,i}$，上非对角线项是 $h_{i,i+1}$，对角线项是 $h_{i,i}$ 和 $h_{i+1,i+1}$。\n\n使用以下测试套件。每个测试用例是一个三元组，包含一个矩阵 $H$、一个索引 $i$ 和一个阈值 $\\tau$：\n- 案例1（一般情况，接近正规）： \n  $H = \\begin{bmatrix} 2  10^{-1} \\\\ 10^{-8}  3 \\end{bmatrix}$，$i=0$，$\\tau = 10^{-6}$。\n- 案例2（非正规放大，其中 $|h_{i,i+1}|$ 巨大）：\n  $H = \\begin{bmatrix} 1  10^{8} \\\\ 10^{-8}  1 \\end{bmatrix}$，$i=0$，$\\tau = 10^{-6}$。\n- 案例3（嵌入式 $3\\times 3$ Hessenberg矩阵，其中 $|h_{i,i+1}|$ 相对于对角线尺度较大）：\n  $H = \\begin{bmatrix} 1  10^{6}  0 \\\\ 0  1  10^{6} \\\\ 0  10^{-10}  1 \\end{bmatrix}$，在 $i=1$ 处测试收缩，$\\tau = 10^{-6}$。\n- 案例4（仅因一个微小耦合项而非上三角的 $2\\times 2$ 矩阵）：\n  $H = \\begin{bmatrix} 2  0 \\\\ 10^{-12}  3 \\end{bmatrix}$，$i=0$，$\\tau = 10^{-6}$。\n- 案例5（朴素规则因次对角线项相对于尺度较大而失败）：\n  $H = \\begin{bmatrix} 1  1 \\\\ 10^{-5}  1 \\end{bmatrix}$，$i=0$，$\\tau = 10^{-6}$。\n\n您的程序必须为每个案例计算两个布尔值：\n- 朴素决策，当且仅当 $|h_{i+1,i}| \\le \\tau \\left(|h_{i,i}| + |h_{i+1,i+1}|\\right)$ 时为真。\n- 修正决策，当且仅当朴素决策为真，并且额外的非正规性保护条件 $|h_{i,i+1}|\\,|h_{i+1,i}| \\le \\tau \\left(|h_{i,i}| + |h_{i+1,i+1}|\\right)^2$ 成立时为真。\n\n生成单行输出，其中包含所有决策，按顺序汇总五个案例，每个案例贡献朴素决策和修正决策。要求的输出格式是单个Python风格的列表，按此顺序包含 $10$ 个布尔条目：\n$[\\text{朴素}_1,\\text{修正}_1,\\text{朴素}_2,\\text{修正}_2,\\dots,\\text{朴素}_5,\\text{修正}_5]$。", "solution": "该问题要求为应用于实上Hessenberg矩阵的Francis QR迭代推导并实现一个鲁棒的收缩测试。这包括分析朴素测试的缺点，并提出一个在存在非正规结构时更安全的修正规则。\n\n### 步骤1：朴素收缩规则及其失效模式分析\n\n在位置 $i$ 对Hessenberg矩阵 $H$ 进行收缩的决策涉及分析位于行和列 $i$ 及 $i+1$ 的 $2 \\times 2$ 主子矩阵。设该块为\n$$\nB = \\begin{bmatrix}\nh_{i,i}  h_{i,i+1} \\\\\nh_{i+1,i}  h_{i+1,i+1}\n\\end{bmatrix} = \\begin{bmatrix} a  b \\\\ c  d \\end{bmatrix}\n$$\n该块的特征值 $\\lambda_{\\pm}$ 由其特征多项式 $\\lambda^2 - (a+d)\\lambda + (ad-bc) = 0$ 的根给出，即：\n$$\n\\lambda_{\\pm} = \\frac{a+d}{2} \\pm \\frac{1}{2}\\sqrt{(a-d)^2 + 4bc}\n$$\n在此位置进行收缩等同于将次对角线元素 $c = h_{i+1,i}$ 置为零。收缩后的矩阵 $\\tilde{B}$ 是上三角矩阵，$\\tilde{B} = \\begin{bmatrix} a  b \\\\ 0  d \\end{bmatrix}$，其特征值就是其对角线元素 $a$ 和 $d$。如果 $B$ 的特征值接近 $a$ 和 $d$，则认为收缩测试是安全的。\n\n朴素收缩规则为 $|c| \\le \\tau(|a|+|d|)$，其中 $\\tau$ 是一个小的容差。这个规则通常是足够的，但在高度非正规的情况下会失败。一个 $2 \\times 2$ 矩阵非正规性的典型例子是当对角线元素接近（$a \\approx d$）且非对角线元素数量级差异巨大时，特别是 $|b|$ 非常大的情况。\n\n让我们按照要求分析 $a=d$ 的特殊情况。$B$ 的特征值变为：\n$$\n\\lambda_{\\pm} = a \\pm \\sqrt{bc}\n$$\n将 $c=0$ 后，特征值变为 $a, a$。特征值扰动的大小为 $|\\sqrt{bc}|$。为保证收缩安全，此扰动必须相对于一个特征局部尺度（例如 $|a|+|d|$）要小。也就是说，我们需要 $|\\sqrt{bc}| \\ll |a|+|d|$。\n\n考虑测试案例 $H = \\begin{bmatrix} 1  10^{8} \\\\ 10^{-8}  1 \\end{bmatrix}$（案例2）。这里，$a=d=1$, $b=10^8$, $c=10^{-8}$。局部尺度为 $|a|+|d|=|1|+|1|=2$。\n朴素规则检查是否 $|c| \\le \\tau(|a|+|d|)$：\n$$\n|10^{-8}| \\le \\tau(2)\n$$\n当 $\\tau=10^{-6}$ 时，这变为 $10^{-8} \\le 2 \\times 10^{-6}$，此式成立。朴素规则会错误地发出收缩信号。\n\n然而，该矩阵的实际特征值是 $\\lambda_{\\pm} = 1 \\pm \\sqrt{10^8 \\cdot 10^{-8}} = 1 \\pm 1$，所以 $\\lambda_1=2$ 和 $\\lambda_2=0$。收缩后，特征值将是 $1, 1$。特征值的变化量级为 $1$，相对于局部尺度 $2$ 这是一个 $O(1)$ 级别的相对变化。这是一个灾难性的错误。失败的原因是朴素规则只限制了 $|c|$，而特征值扰动取决于乘积 $|bc|$。$|b|$ 的巨大数值放大了微小 $|c|$ 的影响，这种现象被称为非正规放大。为确保特征值的变化很小，我们必须控制量 $|bc|$，而不仅仅是 $|c|$。确保扰动很小的条件是 $|\\sqrt{bc}| \\le \\tau(|a|+|d|)$，这意味着 $|bc| \\le \\tau^2(|a|+|d|)^2$。\n\n### 步骤2：修正的鲁棒规则的推导\n\n一个鲁棒的规则必须考虑乘积 $|bc|$。我们从特征多项式的判别式 $\\Delta = (a-d)^2 + 4bc$ 开始。收缩，即将 $c$ 置为零，使判别式改变了 $-4bc$。为了安全起见，这个变化必须是“小的”。对于判别式这个平方量，一个自然的参考尺度是矩阵线性尺度的平方。我们使用 $(|a|+|d|)^2$ 作为这个参考。因此，我们要求判别式变化的幅度相对于这个尺度要小：\n$$\n|4bc| \\le \\epsilon(|a|+|d|)^2\n$$\n其中 $\\epsilon$ 是一个小的无量纲容差。通过将常数 $4$ 吸收到容差中，并使用问题中的阈值 $\\tau$，我们得到非正规性保护条件：\n$$\n|bc| \\le \\tau(|a|+|d|)^2\n$$\n这个条件直接控制了导致非正规放大的项。对于案例2中的失败示例，这个保护条件给出：\n$$\n|10^8 \\cdot 10^{-8}| \\le 10^{-6}(|1|+|1|)^2 \\implies 1 \\le 4 \\times 10^{-6}\n$$\n这个不等式不成立，因此修正后的测试正确地阻止了不安全的收缩。\n\n最终的修正规则，如为实现所规定的，结合了朴素测试和非正规性保护条件。当且仅当两个条件都满足时，才允许收缩：\n1.  **朴素测试**: $|c| \\le \\tau(|a|+|d|)$\n2.  **非正规性保护条件**: $|bc| \\le \\tau(|a|+|d|)^2$\n\n我们检查这个组合规则所需的属性：\n-   **简化为朴素测试**：如果 $|b|$ 与 $|a|+|d|$ 的数量级相同，比如说 $|b| \\approx k(|a|+|d|)$，其中 $k$ 是一个量级为 $1$ 的常数，则保护条件变为 $|c|k(|a|+|d|) \\le \\tau(|a|+|d|)^2$，简化为 $|c| \\le (\\tau/k)(|a|+|d|)$。这本质上与朴素测试的条件相同。\n-   **加强作用**：如果 $|b|$ 很大，即 $|b| \\gg |a|+|d|$，则保护条件施加了 $|c| \\le \\tau \\frac{(|a|+|d|)^2}{|b|}$。由于 $\\frac{|a|+|d|}{|b|} \\ll 1$，这个条件比朴素测试严格得多，正确地收紧了标准。\n-   **对角相似性缩放下的不变性**：使用 $D=\\mathrm{diag}(d_i, d_{i+1})$ 的相似性变换将块转换为 $\\tilde{B} = \\begin{bmatrix} a  b(d_{i+1}/d_i) \\\\ c(d_i/d_{i+1})  d \\end{bmatrix}$。对角线元素 $a, d$ 是不变的。乘积 $\\tilde{b}\\tilde{c} = (b d_{i+1}/d_i)(c d_i/d_{i+1}) = bc$ 也是不变的。因此，非正规性保护条件 $|bc| \\le \\tau(|a|+|d|)^2$ 是不变的。然而，次对角线元素 $c$ 不是不变的。因此，朴素规则 $|c| \\le \\tau(|a|+|d|)$ 不是不变的，所以组合规则也不是严格不变的。这是经典朴素规则的一个已知缺陷。修正规则通过增加一个不变的保护条件，代表了一项重大改进，即使没有实现完全的不变性，也使其更加鲁棒。\n\n### 步骤3：实现与评估\n\n实现将遵循上述推导的逻辑，为五个提供的案例中的每一个计算朴素测试和修正测试的布尔结果。修正测试当且仅当朴素测试为真且非正规性保护条件也为真时才为真。$a, b, c, d$ 的值从由索引 $i$ 定义的 $2 \\times 2$ 子问题中提取。\n\n- **案例 1**: $a=2, d=3, b=10^{-1}, c=10^{-8}, \\tau=10^{-6}$。\n  - 朴素测试: $|10^{-8}| \\le 10^{-6}(|2|+|3|) = 5 \\times 10^{-6}$。(真)\n  - 保护条件: $|10^{-1} \\cdot 10^{-8}| \\le 10^{-6}(|2|+|3|)^2 = 2.5 \\times 10^{-5}$。(真)\n  - 修正测试: 真 $\\land$ 真 $\\implies$ 真。\n\n- **案例 2**: $a=1, d=1, b=10^8, c=10^{-8}, \\tau=10^{-6}$。\n  - 朴素测试: $|10^{-8}| \\le 10^{-6}(|1|+|1|) = 2 \\times 10^{-6}$。(真)\n  - 保护条件: $|10^8 \\cdot 10^{-8}| \\le 10^{-6}(|1|+|1|)^2 = 4 \\times 10^{-6}$。(假)\n  - 修正测试: 真 $\\land$ 假 $\\implies$ 假。\n\n- **案例 3**: 当 $i=1$ 时，我们有 $a=1, d=1, b=10^6, c=10^{-10}, \\tau=10^{-6}$。\n  - 朴素测试: $|10^{-10}| \\le 10^{-6}(|1|+|1|) = 2 \\times 10^{-6}$。(真)\n  - 保护条件: $|10^6 \\cdot 10^{-10}| \\le 10^{-6}(|1|+|1|)^2 = 4 \\times 10^{-6}$。(假)\n  - 修正测试: 真 $\\land$ 假 $\\implies$ 假。\n\n- **案例 4**: $a=2, d=3, b=0, c=10^{-12}, \\tau=10^{-6}$。\n  - 朴素测试: $|10^{-12}| \\le 10^{-6}(|2|+|3|) = 5 \\times 10^{-6}$。(真)\n  - 保护条件: $|0 \\cdot 10^{-12}| \\le 10^{-6}(|2|+|3|)^2 = 2.5 \\times 10^{-5}$。(真)\n  - 修正测试: 真 $\\land$ 真 $\\implies$ 真。\n\n- **案例 5**: $a=1, d=1, b=1, c=10^{-5}, \\tau=10^{-6}$。\n  - 朴素测试: $|10^{-5}| \\le 10^{-6}(|1|+|1|) = 2 \\times 10^{-6}$。(假)\n  - 保护条件: $|1 \\cdot 10^{-5}| \\le 10^{-6}(|1|+|1|)^2 = 4 \\times 10^{-6}$。(假，但这无关紧要，因为朴素测试为假)\n  - 修正测试: 假 $\\land$ 假 $\\implies$ 假。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates naive and corrected deflation rules for the QR algorithm on a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (matrix H, index i, threshold tau)\n    test_cases = [\n        (np.array([[2, 1e-1], [1e-8, 3]]), 0, 1e-6),\n        (np.array([[1, 1e8], [1e-8, 1]]), 0, 1e-6),\n        (np.array([[1, 1e6, 0], [0, 1, 1e6], [0, 1e-10, 1]]), 1, 1e-6),\n        (np.array([[2, 0], [1e-12, 3]]), 0, 1e-6),\n        (np.array([[1, 1], [1e-5, 1]]), 0, 1e-6),\n    ]\n\n    results = []\n    for H, i, tau in test_cases:\n        # Extract the 2x2 block B = [[a, b], [c, d]]\n        # a = h_i,i\n        # b = h_i,i+1\n        # c = h_i+1,i\n        # d = h_i+1,i+1\n        a = H[i, i]\n        b = H[i, i + 1]\n        c = H[i + 1, i]\n        d = H[i + 1, i + 1]\n\n        # Naive deflation rule: |c| = tau * (|a| + |d|)\n        naive_decision = np.abs(c) = tau * (np.abs(a) + np.abs(d))\n        results.append(naive_decision)\n\n        # Nonnormality guard: |b*c| = tau * (|a| + |d|)^2\n        # The problem statement defines the corrected rule as (naive AND guard).\n        guard = np.abs(b * c) = tau * (np.abs(a) + np.abs(d))**2\n        corrected_decision = naive_decision and guard\n        \n        results.append(corrected_decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3593287"}, {"introduction": "为了进一步提升 QR 算法的效率，现代实现采用了一种名为“积极提前收缩”(Aggressive Early Deflation, AED) 的先进技术。它不再被动等待子对角线元素自然变得微不足道，而是主动在一个小的“窗口”子矩阵中搜索已收敛的特征值。在这项实践中，您将模拟 AED 的核心步骤：对尾部窗口进行实舒尔分解，并利用其上方的“尖峰”向量来判断哪些特征值可以被“锁定”并提前从计算中移除，从而具体地理解这一强大的优化技术。[@problem_id:3593260]", "problem": "你的任务是在用于非对称问题的实用位移 Francis-QR 算法中，实现一个玩具版的积极提前收缩（Aggressive Early Deflation, AED）。积极提前收缩（AED）用于在完整的 QR 迭代从数值上解耦特征值之前，通过从一个实上海森堡矩阵的尾部窗口中识别和锁定特征值来加速收敛。你必须从正交相似性和舒尔分解（Schur decomposition）的第一性原理出发。\n\n仅使用实数矩阵和实数算术，并以下列基本原理为基础：\n- 一个实上海森堡矩阵是一个实方阵 $H \\in \\mathbb{R}^{n \\times n}$，其元素满足对于所有 $i  j + 1$，$h_{ij} = 0$。\n- 实方阵 $W \\in \\mathbb{R}^{k \\times k}$ 的实舒尔分解（Real Schur Decomposition）指出，存在一个正交矩阵 $Q \\in \\mathbb{R}^{k \\times k}$ 使得 $Q^{\\mathsf{T}} W Q = T$，其中 $T$ 是一个准上三角矩阵，其对角线上有实数的 $1 \\times 1$ 和 $2 \\times 2$ 块，并且 $\\|Q\\|_2 = 1$。\n- 正交相似性保留特征值和弗罗贝尼乌斯范数（Frobenius norm）。\n\n你的任务是在一个实数 $7 \\times 7$ 上Hessenberg矩阵 $H$ 上实现以下玩具版 AED 过程，使用大小为 $k = 4$ 的尾部窗口：\n1. 按如下方式划分 $H$。设 $n = 7$ 且 $t = n - k + 1 = 4$。提取从行 $t$到 $n$ 和列 $t$ 到 $n$ 索引的尾部窗口 $W = H_{t:n,\\, t:n} \\in \\mathbb{R}^{4 \\times 4}$。提取尖峰行 $x = H_{t-1,\\, t:n} \\in \\mathbb{R}^{1 \\times 4}$，即尾部窗口正上方的那一行。\n2. 计算尾部窗口的实舒尔分解：找到一个正交矩阵 $Q \\in \\mathbb{R}^{4 \\times 4}$ 和一个准上三角矩阵 $T \\in \\mathbb{R}^{4 \\times 4}$，使得 $Q^{\\mathsf{T}} W Q = T$。\n3. 通过相同的正交相似性变换尖峰行：$y = x Q \\in \\mathbb{R}^{1 \\times 4}$。\n4. 通过将与每个对角块关联的 $y$ 的分量与一个尺度敏感的容差进行比较，来确定 $T$ 的可收缩对角块。设 $u$ 表示 IEEE-754 双精度的单位舍入误差，并用 $\\sqrt{u}$ 表示其平方根。设 $\\|T\\|_F$ 表示 $T$ 的弗罗贝尼乌斯范数。\n   - 对于位置 $j$ 处的一个 $1 \\times 1$ 块（因此 $T_{j,j}$ 是实数且 $T_{j+1,j} = 0$），如果满足以下条件，则声明其为可收缩的：\n     $$ |y_j| \\le \\sqrt{u} \\cdot \\max\\left(\\|T\\|_F,\\, |T_{j,j}|\\right). $$\n   - 对于跨越索引 $j, j+1$ 的一个 $2 \\times 2$ 对角块（即 $T_{j+1,j} \\ne 0$），如果满足以下条件，则声明其为可收缩的：\n     $$ \\sqrt{y_j^2 + y_{j+1}^2} \\le \\sqrt{u} \\cdot \\max\\left(\\|T\\|_F,\\, \\|T_{j:j+2,\\, j:j+2}\\|_F\\right). $$\n   在这个玩具问题中，所提供的测试矩阵被构造成使得尾部舒尔形式 $T$ 只有对角线上元素为实数的 $1 \\times 1$ 对角块。\n5. 可以被锁定的特征值是那些通过了上述测试的对角 $1 \\times 1$ 块所对应的特征值。活跃子矩阵的大小会因可收缩特征值的总数 $d$ 而从 $n$ 缩小到 $n - d$。\n\n实现此过程并将其应用于以下三个 $7 \\times 7$ 的实上海森堡矩阵。在每种情况下，使用 $k = 4$（因此 $t = 4$）并遵循上述步骤。所有条目均为精确实数。\n\n测试用例 1:\n- $3 \\times 3$ 的前导海森堡块：\n  $$ A_1 = \\begin{bmatrix}\n  0.0  2.0  -1.0 \\\\\n  3.0  0.5  4.0 \\\\\n  0.0  -2.0  1.5\n  \\end{bmatrix}. $$\n- 尖峰行：\n  $$ x_1 = \\begin{bmatrix} 10^{-12}  10^{-4}  10^{-12}  5 \\cdot 10^{-9} \\end{bmatrix}. $$\n- $4 \\times 4$ 的尾部窗口（已经是上三角矩阵）：\n  $$ W_1 = \\begin{bmatrix}\n  1.0  0.05  0  0 \\\\\n  0  2.0  0.05  0 \\\\\n  0  0  3.0  0.05 \\\\\n  0  0  0  4.0\n  \\end{bmatrix}. $$\n- 通过将 $A_1$ 放置在前导 $3 \\times 3$ 块中，将 $x_1$ 放置在第 $3$ 行第 $4:7$ 列，并将 $W_1$ 放置在第 $4:7$ 行和列中，将所有其他条目设置为 $0$，来组装 $H_1$，确保 $H_1$ 是上海森堡矩阵。\n\n测试用例 2:\n- $3 \\times 3$ 的前导海森堡块：\n  $$ A_2 = \\begin{bmatrix}\n  1.0  -1.0  0.5 \\\\\n  2.0  0.0  -0.3 \\\\\n  0.0  1.2  2.0\n  \\end{bmatrix}. $$\n- 尖峰行：\n  $$ x_2 = \\begin{bmatrix} 10^{-3}  2 \\cdot 10^{-3}  3 \\cdot 10^{-3}  4 \\cdot 10^{-3} \\end{bmatrix}. $$\n- 尾部窗口：\n  $$ W_2 = \\begin{bmatrix}\n  1.0  0.05  0  0 \\\\\n  0  2.0  0.05  0 \\\\\n  0  0  3.0  0.05 \\\\\n  0  0  0  4.0\n  \\end{bmatrix}. $$\n- 类似于测试用例1的方式组装 $H_2$。\n\n测试用例 3:\n- $3 \\times 3$ 的前导海森堡块：\n  $$ A_3 = \\begin{bmatrix}\n  -0.5  0.7  -0.2 \\\\\n  1.1  0.3  0.4 \\\\\n  0.0  -0.9  0.8\n  \\end{bmatrix}. $$\n- 尖峰行：\n  $$ x_3 = \\begin{bmatrix} 10^{-8}  10^{-7}  10^{-9}  10^{-6} \\end{bmatrix}. $$\n- 尾部窗口：\n  $$ W_3 = \\begin{bmatrix}\n  0.7  0.02  0  0 \\\\\n  0  0.9  0.02  0 \\\\\n  0  0  1.1  0.02 \\\\\n  0  0  0  1.3\n  \\end{bmatrix}. $$\n\n对于每个测试用例 $i \\in \\{1,2,3\\}$：\n- 对 $W_i$ 执行实舒尔分解。\n- 使用舒尔分解中的正交因子将 $x_i$ 变换为 $y_i$。\n- 应用上述收缩测试来识别哪些对角 $1 \\times 1$ 块是可收缩的。\n- 报告锁定的特征值列表（可收缩的 $1 \\times 1$ 块的实对角线元素，按其在尾部窗口中从上到下的顺序排列）、锁定的特征值数量 $d_i$ 以及新的活跃子矩阵大小 $n - d_i$。\n\n在你的实现和输出中，请使用以下约定：\n- 全程使用双精度算术；使用 $u = \\text{machine epsilon}$（机器ε）表示双精度，并在收缩测试中使用 $\\sqrt{u}$。\n- 必须使用实舒尔分解来定义收缩测试。\n- 在这些测试用例中，尾部舒尔形式只有 $1 \\times 1$ 块，因此所有锁定的特征值都是实数。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是一个形式为 $[d, m, [\\ell_1, \\ell_2, \\dots]]$ 的列表，其中 $d$ 是锁定的特征值的整数数量，$m$ 是新活跃子矩阵的整数大小，$[\\ell_1, \\ell_2, \\dots]$ 是按其在尾部舒尔形式对角线上出现的非递减索引顺序排列的实数锁定特征值列表。对于这三个测试用例，完整的输出应如下所示：\n  $$ [[d_1,m_1,[\\dots]],[d_2,m_2,[\\dots]],[d_3,m_3,[\\dots]]]. $$", "solution": "该问题要求实现一个简化的积极提前收缩（Aggressive Early Deflation, AED）过程，这是一种用于加速寻找非对称实矩阵特征值的实用 Francis QR 算法收敛的技术。AED的核心原理是在标准QR迭代完全解耦特征值之前，通过分析海森堡矩阵的一个小的尾部子矩阵，来识别并“锁定”那些已接近收敛的特征值。\n\n设 $H \\in \\mathbb{R}^{n \\times n}$ 是一个实上海森堡矩阵。QR算法通过对 $H$ 迭代地应用相似变换，以使其次对角线元素趋于零，从而在一个被称为实舒尔形式的准上三角矩阵中揭示特征值。对于大的 $n$，一次迭代的计算成本很高。AED 针对一个大小为 $k \\times k$ 的尾部子问题（其中 $k \\ll n$），以找到已收敛的特征值并对问题进行收缩，从而减小 $n$ 并降低后续迭代的成本。\n\n根据问题陈述，我们处理一个大小为 $n=7$ 的矩阵和一个大小为 $k=4$ 的尾部窗口。矩阵 $H$ 被划分为：\n$$\nH = \\begin{bmatrix}\nH_{1:t-1,\\, 1:t-1}  H_{1:t-1,\\, t:n} \\\\\nx  W \\\\\n\\boldsymbol{0}  \\boldsymbol{0}\n\\end{bmatrix}\n$$\n其中分区索引为 $t = n - k + 1 = 7 - 4 + 1 = 4$。子矩阵是：\n- $W = H_{t:n,\\, t:n} \\in \\mathbb{R}^{4 \\times 4}$ 是尾部窗口。\n- $x = H_{t-1,\\, t:n} \\in \\mathbb{R}^{1 \\times 4}$ 是“尖峰”行向量，它将矩阵的前导部分与尾部窗口耦合起来。\n\n过程如下：\n\n**步骤1：对窗口进行正交相似变换**\n\n核心思想是分析尾部窗口 $W$ 的特征值。我们寻求一个正交相似变换，将 $W$ 简化为更结构化的形式。实舒尔分解提供了这样的变换。对于矩阵 $W \\in \\mathbb{R}^{k \\times k}$，存在一个正交矩阵 $Q \\in \\mathbb{R}^{k \\times k}$（即 $Q^{\\mathsf{T}}Q = QQ^{\\mathsf{T}} = I$）和一个实准上三角矩阵 $T \\in \\mathbb{R}^{k \\times k}$，使得：\n$$\nQ^{\\mathsf{T}} W Q = T\n$$\n$T$ 的特征值与 $W$ 的特征值相同，它们由 $T$ 对角线上的 $1 \\times 1$ 和 $2 \\times 2$ 块揭示。\n\n为了保持整个矩阵 $H$ 的特征值，这个变换必须作为相似变换应用于 $H$。我们定义一个块对角正交矩阵 $\\mathcal{Q} \\in \\mathbb{R}^{n \\times n}$：\n$$\n\\mathcal{Q} = \\begin{bmatrix}\nI_{n-k}  \\boldsymbol{0} \\\\\n\\boldsymbol{0}  Q\n\\end{bmatrix}\n$$\n其中 $I_{n-k}$ 是 $(n-k) \\times (n-k)$ 的单位矩阵。变换后的海森堡矩阵 $H'$ 是：\n$$\nH' = \\mathcal{Q}^{\\mathsf{T}} H \\mathcal{Q} = \\begin{bmatrix}\nI_{n-k}  \\boldsymbol{0} \\\\\n\\boldsymbol{0}  Q^{\\mathsf{T}}\n\\end{bmatrix}\n\\begin{bmatrix} H_{11}  H_{12} \\\\ x'  W \\end{bmatrix}\n\\begin{bmatrix} I_{n-k}  \\boldsymbol{0} \\\\\n\\boldsymbol{0}  Q\n\\end{bmatrix}\n= \\begin{bmatrix}\nH_{11}  H_{12}Q \\\\\nQ^{\\mathsf{T}}x'  Q^{\\mathsf{T}}WQ\n\\end{bmatrix}\n$$\n注意，为了使 $H$ 的分区与此结构匹配，$x'$ 将是一个列向量。在我们的特定问题中，$H$ 是上海森堡矩阵，相关的尖峰是行 $x = H_{t-1,\\, t:n}$。让我们重新考虑变换对指定分区的影响。变换后的矩阵 $H'$ 的尾部窗口将更新为 $Q^{\\mathsf{T}}WQ=T$。尖峰行 $x$ 被 $Q$ 右乘，成为新的尖峰 $y$：\n$$\ny = x Q\n$$\n元素 $h_{t-1, t-1}$ 保持不变，第 $t-1$ 行中新的非零元素由 $y$ 的分量给出。\n\n**步骤2：收缩准则**\n\n如果 $T$ 中相应的对角块与矩阵的其余部分耦合很弱，则 $W$（以及 $T$）的一个特征值可以被认为是整个矩阵 $H$ 的一个已收敛特征值。这种耦合由变换后的尖峰 $y$ 中相应分量的大小来衡量。如果一个耦合足够小，我们可以将其视为零，从而解耦或“收缩”该特征值。\n\n问题指定测试矩阵的舒尔形式 $T$ 将是上三角矩阵，仅包含 $1 \\times 1$ 的对角块。对于一个 $1 \\times 1$ 块 $T_{j,j}$（其中 $j$ 是 $4 \\times 4$ 窗口内基于0的索引），相应的耦合是变换后的尖峰的第 $j$ 个元素 $y_j$。如果此元素相对于子问题的尺度足够小，则该块被声明为可收缩的。准则是：\n$$\n|y_j| \\le \\sqrt{u} \\cdot \\max\\left(\\|T\\|_F, |T_{j,j}|\\right)\n$$\n这里，$u$ 是双精度浮点运算的机器ε，代表相对误差的上限。项 $\\sqrt{u}$ 是此类“可忽略性”测试的标准选择。尺度由舒尔形式的弗罗贝尼乌斯范数 $\\|T\\|_F$ 和特征值本身的大小 $|T_{j,j}|$ 的最大值确定。与可收缩块对应的特征值被认为是“锁定的”。\n\n**步骤3：计算每个测试用例的结果**\n\n我们将此过程应用于每个测试用例。设 $n=7$ 和 $k=4$。锁定的特征值数量为 $d_i$，新的活跃矩阵大小将为 $m_i = n - d_i = 7 - d_i$。\n\n**测试用例 1：**\n- $x_1 = \\begin{bmatrix} 10^{-12}  10^{-4}  10^{-12}  5 \\cdot 10^{-9} \\end{bmatrix}$\n- $W_1 = \\begin{bmatrix} 1.0  0.05  0  0 \\\\ 0  2.0  0.05  0 \\\\ 0  0  3.0  0.05 \\\\ 0  0  0  4.0 \\end{bmatrix}$\n由于 $W_1$ 是具有不同特征值的上三角矩阵，其真实舒尔分解为 $T_1 = W_1$ 和 $Q_1 = I_4$。\n因此，$y_1 = x_1 Q_1 = x_1$。\n机器ε为 $u \\approx 2.22 \\times 10^{-16}$，所以 $\\sqrt{u} \\approx 1.49 \\times 10^{-8}$。\n$\\|T_1\\|_F = \\|W_1\\|_F = \\sqrt{1^2+0.05^2+2^2+0.05^2+3^2+0.05^2+4^2} \\approx 5.4779$。\n容差尺度为 $\\max(\\|T_1\\|_F, |T_{1,jj}|)$。由于所有 $|T_{1,jj}| \\le 4.0  \\|T_1\\|_F$，所以尺度为 $\\|T_1\\|_F$。\n容差 $\\approx 1.49 \\times 10^{-8} \\cdot 5.4779 \\approx 8.16 \\times 10^{-8}$。\n- $j=0$ (特征值 $1.0$): $|y_1[0]| = 10^{-12} \\le 8.16 \\times 10^{-8}$。**可收缩**。\n- $j=1$ (特征值 $2.0$): $|y_1[1]| = 10^{-4}  8.16 \\times 10^{-8}$。不可收缩。\n- $j=2$ (特征值 $3.0$): $|y_1[2]| = 10^{-12} \\le 8.16 \\times 10^{-8}$。**可收缩**。\n- $j=3$ (特征值 $4.0$): $|y_1[3]| = 5 \\times 10^{-9} \\le 8.16 \\times 10^{-8}$。**可收缩**。\n锁定的特征值：$[1.0, 3.0, 4.0]$。数量 $d_1 = 3$。新大小 $m_1 = 7-3 = 4$。结果：$[3, 4, [1.0, 3.0, 4.0]]$。\n\n**测试用例 2：**\n- $x_2 = \\begin{bmatrix} 10^{-3}  2 \\cdot 10^{-3}  3 \\cdot 10^{-3}  4 \\cdot 10^{-3} \\end{bmatrix}$\n- $W_2$ 与 $W_1$ 相同，所以 $T_2=W_2$，$Q_2=I$，容差约为 $8.16 \\times 10^{-8}$。\n- $y_2 = x_2$。\n- $j=0$: $|y_2[0]| = 10^{-3}  8.16 \\times 10^{-8}$。不可收缩。\n- $j=1$: $|y_2[1]| = 2 \\times 10^{-3}  8.16 \\times 10^{-8}$。不可收缩。\n- $j=2$: $|y_2[2]| = 3 \\times 10^{-3}  8.16 \\times 10^{-8}$。不可收缩。\n- $j=3$: $|y_2[3]| = 4 \\times 10^{-3}  8.16 \\times 10^{-8}$。不可收缩。\n锁定的特征值：$[]$。数量 $d_2 = 0$。新大小 $m_2 = 7-0 = 7$。结果：$[0, 7, []]$。\n\n**测试用例 3：**\n- $x_3 = \\begin{bmatrix} 10^{-8}  10^{-7}  10^{-9}  10^{-6} \\end{bmatrix}$\n- $W_3 = \\begin{bmatrix} 0.7  0.02  0  0 \\\\ 0  0.9  0.02  0 \\\\ 0  0  1.1  0.02 \\\\ 0  0  0  1.3 \\end{bmatrix}$\n同样，$W_3$ 是上三角矩阵，所以 $T_3 = W_3$ 且 $Q_3 = I_4$。因此 $y_3=x_3$。\n$\\|T_3\\|_F = \\sqrt{0.7^2+0.02^2+0.9^2+0.02^2+1.1^2+0.02^2+1.3^2} \\approx 2.0497$。\n- $j=0$ (特征值 $0.7$): 尺度为 $\\max(2.0497, 0.7) = 2.0497$。容差 $\\approx 1.49 \\times 10^{-8} \\cdot 2.0497 \\approx 3.05 \\times 10^{-8}$。$|y_3[0]| = 10^{-8} \\le 3.05 \\times 10^{-8}$。**可收缩**。\n- $j=1$ (特征值 $0.9$): 尺度为 $\\max(2.0497, 0.9) = 2.0497$。容差 $\\approx 3.05 \\times 10^{-8}$。$|y_3[1]| = 10^{-7}  3.05 \\times 10^{-8}$。不可收缩。\n- $j=2$ (特征值 $1.1$): 尺度为 $\\max(2.0497, 1.1) = 2.0497$。容差 $\\approx 3.05 \\times 10^{-8}$。$|y_3[2]| = 10^{-9} \\le 3.05 \\times 10^{-8}$。**可收缩**。\n- $j=3$ (特征值 $1.3$): 尺度为 $\\max(2.0497, 1.3) = 2.0497$。容差 $\\approx 3.05 \\times 10^{-8}$。$|y_3[3]| = 10^{-6}  3.05 \\times 10^{-8}$。不可收缩。\n锁定的特征值：$[0.7, 1.1]$。数量 $d_3 = 2$。新大小 $m_3 = 7-2 = 5$。结果：$[2, 5, [0.7, 1.1]]$。\n\n这些手动计算将由提供的 Python 实现来确认。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements the specified Aggressive Early Deflation (AED) procedure\n    for three test cases and prints the results in the required format.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (W, x), where W is the trailing window and x is the spike.\n    test_cases = [\n        (\n            np.array([\n                [1.0, 0.05, 0.0, 0.0],\n                [0.0, 2.0, 0.05, 0.0],\n                [0.0, 0.0, 3.0, 0.05],\n                [0.0, 0.0, 0.0, 4.0]\n            ]),\n            np.array([1e-12, 1e-4, 1e-12, 5e-9])\n        ),\n        (\n            np.array([\n                [1.0, 0.05, 0.0, 0.0],\n                [0.0, 2.0, 0.05, 0.0],\n                [0.0, 0.0, 3.0, 0.05],\n                [0.0, 0.0, 0.0, 4.0]\n            ]),\n            np.array([1e-3, 2e-3, 3e-3, 4e-3])\n        ),\n        (\n            np.array([\n                [0.7, 0.02, 0.0, 0.0],\n                [0.0, 0.9, 0.02, 0.0],\n                [0.0, 0.0, 1.1, 0.02],\n                [0.0, 0.0, 0.0, 1.3]\n            ]),\n            np.array([1e-8, 1e-7, 1e-9, 1e-6])\n        )\n    ]\n\n    # Global parameters\n    n = 7\n    u = np.finfo(float).eps\n    sqrt_u = np.sqrt(u)\n\n    results = []\n    for W, x in test_cases:\n        # Step 2: Compute the Real Schur Decomposition of the trailing window.\n        # T, Q are returned such that W = Q @ T @ Q.T, which means Q.T @ W @ Q = T.\n        T, Q = linalg.schur(W, output='real')\n\n        # Step 3: Transform the spike by the same orthogonal similarity.\n        y = x @ Q\n\n        # Step 4: Determine deflatable diagonal blocks.\n        norm_T_fro = linalg.norm(T, 'fro')\n        locked_eigenvalues = []\n        \n        # The problem states that T will have only 1x1 blocks.\n        # We iterate through the diagonal elements.\n        for j in range(T.shape[0]):\n            eigenvalue = T[j, j]\n            \n            # Deflation test for a 1x1 block\n            tolerance_scale = max(norm_T_fro, abs(eigenvalue))\n            criterion = sqrt_u * tolerance_scale\n            \n            if abs(y[j]) = criterion:\n                locked_eigenvalues.append(eigenvalue)\n        \n        # Step 5: Report the results for the current test case.\n        d = len(locked_eigenvalues)\n        m = n - d\n        \n        # The output format requires a list wrapping the results for each case.\n        results.append([d, m, locked_eigenvalues])\n\n    # Convert the list of results to the required string format.\n    # The default string representation of lists in Python matches the required format.\n    # e.g., str([3, 4, [1.0, 3.0, 4.0]]) -> '[3, 4, [1.0, 3.0, 4.0]]'\n    final_output_string = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3593260"}]}