{"hands_on_practices": [{"introduction": "要深刻理解将矩阵化为上海森堡形式的过程，最有效的方法之一就是亲手执行其核心操作。此练习 [@problem_id:3572572] 将指导您对一个 $4 \\times 4$ 矩阵符号化地执行一步上海森堡约简。通过为第一列构造豪斯霍尔德反射并将该变换应用于矩阵，您将具体地看到零元素是如何被引入的，从而巩固对豪斯霍尔德变换几何原理及其在算法中代数应用的理解。", "problem": "设 $A \\in \\mathbb{R}^{4 \\times 4}$ 是一个具有一般项 $a_{ij}$ 的实矩阵。考虑使用一个作用于与第 $2$ 行到第 $4$ 行及第 $2$ 列到第 $4$ 列相关的尾部 $3 \\times 3$ 子空间上的豪斯霍尔德反射镜所构建的相似变换，将矩阵 $A$ 约化为上海森堡形式。令 $x \\in \\mathbb{R}^{3}$ 表示由 $A$ 的第一列中 $(1,1)$ 元下方的元素构成的子向量，即 $x = \\begin{pmatrix} a_{21} \\\\ a_{31} \\\\ a_{41} \\end{pmatrix}$。假设 $a_{21}$、$a_{31}$、$a_{41}$ 中至少有一个非零，因此 $x \\neq 0$。\n\n豪斯霍尔德反射镜是一个形如 $H = I - 2 \\dfrac{v v^{\\top}}{v^{\\top} v}$ 的实正交对称矩阵，其中 $v \\in \\mathbb{R}^{m}$ 为某个非零向量，$I$ 是相应维度的单位矩阵。这种反射镜通过关于与 $v$ 正交的超平面的反射，将一个给定向量映射到一个坐标向量的倍数。\n\n构造一个 $3 \\times 3$ 的豪斯霍尔德反射镜 $Q$，它将 $x$ 映射到一个与第一个基向量 $e_{1} \\in \\mathbb{R}^{3}$ 共线的向量。将 $Q$ 提升为一个 $4 \\times 4$ 的正交相似因子 $H_{1} = \\operatorname{diag}(1, Q)$，并构成相似变换 $A^{(1)} = H_{1} A H_{1}^{\\top}$。仅使用豪斯霍尔德反射镜的定义，符号化地推导出 $Q$ 并解释为何 $A^{(1)}$ 的 $(3,1)$ 和 $(4,1)$ 元为零，从而展示第一列更新后的上海森堡模式。\n\n采用数值稳定的符号约定，在从 $x$ 构造反射镜时，选择 $e_{1}$ 的目标倍数以避免相消误差。将下面的最终答案表示为标量 $\\tau$ 的单个闭式解析表达式，其中 $Q = I - \\tau u u^{\\top}$，$u = x - \\alpha e_{1}$，且 $\\alpha$ 根据上述稳定约定选择。您的最终表达式必须仅用 $a_{21}$、$a_{31}$ 和 $a_{41}$ 显式给出。不需要四舍五入。", "solution": "该问题要求推导在将一个 $4 \\times 4$ 矩阵 $A$ 约化为上海森堡形式的第一步中，所使用的豪斯霍尔德反射中的标量 $\\tau$。它还要求解释为什么此变换会在第一列的正确位置引入零。\n\n设 $A \\in \\mathbb{R}^{4 \\times 4}$ 是一个元素为 $a_{ij}$ 的矩阵。目标是找到一个在 $(3,1)$ 和 $(4,1)$ 位置引入零的相似变换。这是创建上海森堡矩阵的第一步，该矩阵在第一副对角线下方为零。变换矩阵构造为 $H_1 = \\begin{pmatrix} 1  0 \\\\ 0  Q \\end{pmatrix}$，其中 $Q \\in \\mathbb{R}^{3 \\times 3}$ 是一个豪斯霍尔德反射镜。\n\n待变换的向量是 $A$ 的第一列中对角线下方的子向量，给定为 $x = \\begin{pmatrix} a_{21} \\\\ a_{31} \\\\ a_{41} \\end{pmatrix} \\in \\mathbb{R}^{3}$。问题假设 $x \\neq 0$。豪斯霍尔德反射镜 $Q$ 必须将 $x$ 映射到一个与第一个标准基向量 $e_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\in \\mathbb{R}^{3}$ 共线的向量。即，$Qx = \\alpha e_1$，其中 $\\alpha \\in \\mathbb{R}$ 是某个标量。\n\n豪斯霍尔德反射镜是一个正交矩阵。正交变换保持欧几里得范数（$L^2$范数）不变。因此，我们必须有 $\\|Qx\\|_2 = \\|x\\|_2$。\n应用此性质：\n$\\|\\alpha e_1\\|_2 = \\|x\\|_2$\n$|\\alpha| \\|e_1\\|_2 = \\|x\\|_2$\n由于 $\\|e_1\\|_2 = 1$，我们得到 $|\\alpha| = \\|x\\|_2$。\n$x$ 的范数由 $\\|x\\|_2 = \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$ 给出。\n因此，$\\alpha = \\pm \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$。\n\n问题指定使用数值稳定的符号约定。反射向量由 $x$ 及其目标 $\\alpha e_1$ 构造。反射向量是 $u = x - \\alpha e_1$。为避免当两个几乎相等的数相减时可能导致精度损失的相消误差，$\\alpha$ 的符号被选择为与 $x$ 的第一个分量 $a_{21}$ 的符号相反。这确保了 $u$ 的第一个分量 $u_1 = a_{21} - \\alpha$ 涉及到同号量的相加（或异号量的相减）。\n$\\alpha$ 的稳定选择是：\n$\\alpha = -\\operatorname{sgn}(a_{21}) \\|x\\|_2 = -\\operatorname{sgn}(a_{21}) \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$。\n此处，$\\operatorname{sgn}(z)$ 是符号函数。如果 $a_{21} = 0$，符号的选择是任意的；一个常见的约定是设置 $\\operatorname{sgn}(0) = 1$。\n\n将 $x$ 映射到 $\\alpha e_1$ 的豪斯霍尔德反射镜 $Q$ 由公式 $Q = I - 2 \\frac{v v^{\\top}}{v^{\\top} v}$ 给出，其中反射向量为 $v = x - \\alpha e_1$。在问题的符号表示中，此向量记为 $u$。因此，我们有 $u = x - \\alpha e_1$。\n问题将 $Q$ 定义为 $Q = I - \\tau u u^{\\top}$。与标准定义比较，我们可以确定 $\\tau = \\frac{2}{u^{\\top} u}$。\n\n我们现在计算 $u^{\\top} u = \\|u\\|_2^2$：\n$u^{\\top} u = (x - \\alpha e_1)^{\\top} (x - \\alpha e_1) = x^{\\top}x - 2\\alpha x^{\\top}e_1 + \\alpha^2 e_1^{\\top}e_1$。\n我们有：\n- $x^{\\top}x = \\|x\\|_2^2 = a_{21}^2 + a_{31}^2 + a_{41}^2$。\n- $x^{\\top}e_1 = a_{21}$。\n- $e_1^{\\top}e_1 = \\|e_1\\|_2^2 = 1$。\n- $\\alpha^2 = (\\|x\\|_2)^2 = \\|x\\|_2^2$。\n\n将这些代入 $u^{\\top} u$ 的表达式中：\n$u^{\\top} u = \\|x\\|_2^2 - 2\\alpha a_{21} + \\|x\\|_2^2 = 2\\|x\\|_2^2 - 2\\alpha a_{21}$。\n现在，我们代入 $\\alpha$ 的表达式：\n$u^{\\top} u = 2\\|x\\|_2^2 - 2(-\\operatorname{sgn}(a_{21}) \\|x\\|_2) a_{21} = 2\\|x\\|_2^2 + 2(\\operatorname{sgn}(a_{21})a_{21}) \\|x\\|_2$。\n由于 $\\operatorname{sgn}(z)z = |z|$，这可以简化为：\n$u^{\\top} u = 2\\|x\\|_2^2 + 2|a_{21}| \\|x\\|_2 = 2\\|x\\|_2 (\\|x\\|_2 + |a_{21}|)$。\n\n现在我们可以找到 $\\tau$：\n$\\tau = \\frac{2}{u^{\\top} u} = \\frac{2}{2\\|x\\|_2 (\\|x\\|_2 + |a_{21}|)} = \\frac{1}{\\|x\\|_2 (\\|x\\|_2 + |a_{21}|)}$。\n\n代入 $\\|x\\|_2 = \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$，我们得到以矩阵元素表示的 $\\tau$ 的最终表达式：\n$\\tau = \\frac{1}{\\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} \\left( \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} + |a_{21}| \\right)}$。\n\n接下来，我们必须解释为什么 $A^{(1)} = H_1 A H_1^{\\top}$ 的 $(3,1)$ 和 $(4,1)$ 元为零。由于 $H_1$ 是基于豪斯霍尔德的矩阵，它是对称的，所以 $H_1^{\\top} = H_1$。因此，$A^{(1)} = H_1 A H_1$。\n我们关注 $A^{(1)}$ 的第一列，它由 $A^{(1)} e_1^{(4)}$ 给出，其中 $e_1^{(4)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n$A^{(1)}$ 的第一列是 $H_1 A H_1 e_1^{(4)}$。\n首先，我们计算 $H_1 e_1^{(4)}$：\n$H_1 e_1^{(4)} = \\begin{pmatrix} 1  0 \\\\ 0  Q \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = e_1^{(4)}$。\n所以，$A^{(1)}$ 的第一列就是 $H_1 (A e_1^{(4)})$。\n$A e_1^{(4)}$ 是 $A$ 的第一列：$A e_1^{(4)} = \\begin{pmatrix} a_{11} \\\\ a_{21} \\\\ a_{31} \\\\ a_{41} \\end{pmatrix} = \\begin{pmatrix} a_{11} \\\\ x \\end{pmatrix}$。\n现在，我们应用 $H_1$：\n$A^{(1)}$ 的第一列 = $H_1 \\begin{pmatrix} a_{11} \\\\ x \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  Q \\end{pmatrix} \\begin{pmatrix} a_{11} \\\\ x \\end{pmatrix} = \\begin{pmatrix} a_{11} \\\\ Qx \\end{pmatrix}$。\n根据构造，反射镜 $Q$ 被设计成使得 $Qx = \\alpha e_1^{(3)}$，其中 $e_1^{(3)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\in \\mathbb{R}^3$。\n因此，变换后矩阵 $A^{(1)}$ 的第一列是：\n$\\begin{pmatrix} a_{11} \\\\ \\alpha e_1^{(3)} \\end{pmatrix} = \\begin{pmatrix} a_{11} \\\\ \\alpha \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n$A^{(1)}$ 的 $(3,1)$ 元是此列向量的第三个元素，为 $0$。\n$A^{(1)}$ 的 $(4,1)$ 元是此列向量的第四个元素，为 $0$。\n这证实了该变换成功地在第一列的副对角线下方引入了零，这正是上海森堡约化这一步的目标。然后将相同的过程应用于对应于第 $3$ 行到第 $4$ 行以及第 $3$ 列到第 $4$ 列的子矩阵，以将 $(4,2)$ 元置零，从而完成对一个 $4 \\times 4$ 矩阵的约化。\n\n最终要求的量是 $\\tau$ 的表达式。\n$\\tau = \\frac{1}{\\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} \\left( \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} + |a_{21}| \\right)}$。", "answer": "$$\n\\boxed{\\frac{1}{\\sqrt{a_{21}^{2} + a_{31}^{2} + a_{41}^{2}} \\left( \\sqrt{a_{21}^{2} + a_{31}^{2} + a_{41}^{2}} + |a_{21}| \\right)}}\n$$", "id": "3572572"}, {"introduction": "在理解了上海森堡约减的单步机制后，下一个关键问题是评估整个算法的计算效率。此练习 [@problem_id:3572651] 要求您通过对算法的每个迭代步骤的浮点运算（flops）成本进行求和，来推导总计算量的主导项。这项分析对于理解为什么上海森堡约减是求解稠密矩阵特征值问题时不可或缺的预处理步骤至关重要，它为该算法的 $O(n^3)$ 复杂度提供了定量的证明。", "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稠密实矩阵。考虑使用 Householder 反射将矩阵约化为上海森堡形式的标准非分块方法，即一个相似变换 $A \\leftarrow H_{n-2} \\cdots H_{2} H_{1} \\, A \\, H_{1} H_{2} \\cdots H_{n-2}$，其中对于每个迭代索引 $k$（$1 \\leq k \\leq n-2$），构造 Householder 反射 $H_{k} = I - \\tau_{k} \\tilde{v}_{k} \\tilde{v}_{k}^{\\mathsf{T}}$ 来零化第一副对角线下方的元素 $A_{k+2:n,\\,k}$，其中 $\\tilde{v}_{k} \\in \\mathbb{R}^{n}$ 是将一个向量 $v_{k} \\in \\mathbb{R}^{n-k}$ 在位置 $k+1$ 到 $n$ 进行零填充得到的。假设采用实数算术，并将一个浮点运算（flop）定义为一次标量加法或乘法；标量平方根和除法不计入渐近三次项。\n\n仅从以下基本事实出发：\n- 一个 $a \\times b$ 稠密矩阵与一个 $b \\times 1$ 向量的矩阵-向量乘积在实数算术中耗费 $2ab$ 次浮点运算。\n- 一个 $a \\times b$ 矩阵经 $u v^{\\mathsf{T}}$ 的秩一更新在实数算术中耗费 $2ab$ 次浮点运算。\n- 在第 $k$ 次迭代中，左乘应用 $A \\leftarrow H_{k} A$ 非平凡地作用于由 $A$ 的第 $k+1$ 行至第 $n$ 行以及第 $k$ 列至第 $n$ 列组成的尾随子矩阵，而右乘应用 $A \\leftarrow A H_{k}$ 非平凡地作用于由第 $k+1$ 列至第 $n$ 列以及所有行组成的尾随列块。\n\n通过对 $k = 1, \\dots, n-2$ 的每次迭代成本求和，推导出这种非分块上海森堡约简总浮点运算数的首项。你的推导过程应明确指出每一步中受影响子矩阵的大小，并仅使用上述给出的运算计数。忽略所有对 $n^{3}$ 的系数没有贡献的低阶项。\n\n请将你的最终答案以 $n$ 的单个闭式表达式形式给出，该表达式等于浮点运算数的首项。最终答案中不要包含大$\\mathcal{O}$符号。无需四舍五入。", "solution": "此题要求我们找到将一个稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 使用 Householder 反射进行非分块约化至上海森堡形式的总浮点运算 (flop) 数的首项。分析过程将计算单次迭代 $k$ 的成本，然后对这些成本从 $k=1$ 到 $n-2$ 求和。一次浮点运算定义为一次标量加法或乘法。\n\n在迭代 $k$（其中 $1 \\le k \\le n-2$）的变换由 $A \\leftarrow H_k A H_k$ 给出，其中 $H_k = I - \\tau_k \\tilde{v}_k \\tilde{v}_k^{\\mathsf{T}}$。向量 $\\tilde{v}_k \\in \\mathbb{R}^n$ 的前 $k$ 个分量为零。令 $v_k \\in \\mathbb{R}^{n-k}$ 表示 $\\tilde{v}_k$ 中从位置 $k+1$ 到 $n$ 的非零项组成的子向量。\n\n迭代 $k$ 的总成本（记为 $C_k$）是左乘（$A \\leftarrow H_k A$）和右乘（$A \\leftarrow A H_k$）的成本之和。\n\n**1. 左乘 $A \\leftarrow H_k A$ 的成本**\n\n左乘 $H_k$ 的操作为 $A \\leftarrow (I - \\tau_k \\tilde{v}_k \\tilde{v}_k^{\\mathsf{T}})A$。此操作仅影响矩阵 $A$ 的第 $k+1$ 行到第 $n$ 行。在迭代 $k$ 开始时，$A$ 的第 $1, \\dots, k-1$ 列已经具有所期望的上海森堡结构，这意味着当 $i > j+1$ 且 $j  k$ 时，元素 $A_{i,j}$ 为零。特别地，对于任意列 $j  k$，子矩阵 $A(k+1:n, j)$ 为零。这些零行的线性组合（这正是 $H_k A$ 对这些列所做的计算）将保持为零。因此，该更新仅非平凡地影响第 $k$ 列到第 $n$ 列。\n\n如问题所述，此操作作用于由 $A$ 的第 $k+1$ 行到第 $n$ 行以及第 $k$ 列到第 $n$ 列组成的子矩阵。我们将此子矩阵记为 $A_{sub,L} = A(k+1:n, k:n)$。$A_{sub,L}$ 的大小为 $(n-k) \\times (n-k+1)$。对此子矩阵的变换是 $A_{sub,L} \\leftarrow (I_{n-k} - \\tau_k v_k v_k^{\\mathsf{T}}) A_{sub,L}$。这可以分两步实现：\na. 计算临时行向量 $w^{\\mathsf{T}} = v_k^{\\mathsf{T}} A_{sub,L}$。这等效于计算列向量 $w = A_{sub,L}^{\\mathsf{T}} v_k$。这是一个矩阵-向量乘积，其中矩阵 $A_{sub,L}^{\\mathsf{T}}$ 的维度为 $(n-k+1) \\times (n-k)$，向量 $v_k$ 的维度为 $(n-k) \\times 1$。根据所给规则（对于一个 $a \\times b$ 矩阵，成本为 $2ab$），成本为 $2(n-k+1)(n-k)$ 次浮点运算。\nb. 执行秩一更新 $A_{sub,L} \\leftarrow A_{sub,L} - (\\tau_k v_k) w^{\\mathsf{T}}$。矩阵 $A_{sub,L}$ 的维度为 $(n-k) \\times (n-k+1)$。根据问题的规则，对一个 $a \\times b$ 矩阵进行秩一更新的成本为 $2ab$ 次浮点运算。此处，$a=n-k$，$b=n-k+1$。成本为 $2(n-k)(n-k+1)$ 次浮点运算。\n\n迭代 $k$ 中左乘的总成本是这些成本之和：\n$C_{k,L} = 2(n-k)(n-k+1) + 2(n-k)(n-k+1) = 4(n-k)(n-k+1)$ 次浮点运算。\n\n**2. 右乘 $A \\leftarrow A H_k$ 的成本**\n\n右乘由 $A \\leftarrow A(I - \\tau_k \\tilde{v}_k \\tilde{v}_k^{\\mathsf{T}}) = A - \\tau_k (A \\tilde{v}_k) \\tilde{v}_k^{\\mathsf{T}}$ 给出。此操作可分解为两个步骤：\na. 计算临时列向量 $y = A \\tilde{v}_k$。由于 $\\tilde{v}_k$ 仅在位置 $k+1$ 到 $n$ 有非零项，此乘积是 $A$ 的第 $k+1$ 列到第 $n$ 列的线性组合。即，$y = A(:, k+1:n) v_k$。这是一个矩阵-向量乘积，其中矩阵 $A(:, k+1:n)$ 的维度为 $n \\times (n-k)$，向量 $v_k$ 的维度为 $(n-k) \\times 1$。使用 $2ab$ 规则，其中 $a=n$ 和 $b=n-k$，浮点运算数为 $2n(n-k)$。\nb. 执行秩一更新 $A \\leftarrow A - (\\tau_k y) \\tilde{v}_k^{\\mathsf{T}}$。由于 $\\tilde{v}_k^{\\mathsf{T}}$ 的稀疏性（非零项在位置 $k+1$ 到 $n$），此更新仅修改 $A$ 的第 $k+1$ 列到第 $n$ 列。这对应于对子矩阵 $A(:,k+1:n)$ 的秩一更新，其维度为 $n \\times (n-k)$。当 $a=n$ 和 $b=n-k$ 时，成本为 $2n(n-k)$ 次浮点运算。\n\n迭代 $k$ 中右乘的总成本是：\n$C_{k,R} = 2n(n-k) + 2n(n-k) = 4n(n-k)$ 次浮点运算。\n\n**3. 总浮点运算数**\n\n迭代 $k$ 的总浮点运算数为 $C_k = C_{k,L} + C_{k,R}$：\n$C_k = 4(n-k)(n-k+1) + 4n(n-k)$。\n\n为求总浮点运算数的首项，我们将 $C_k$ 从 $k=1$ 到 $n-2$ 求和，并仅保留对 $n^3$ 项有贡献的项。为求首项，我们可以做近似 $(n-k+1) \\approx (n-k)$。\n$C_k \\approx 4(n-k)^2 + 4n(n-k) = 4(n^2 - 2nk + k^2) + 4n^2 - 4nk = 8n^2 - 12nk + 4k^2$。\n总浮点运算数 $C_{total}$ 是对 $k$ 的求和：\n$C_{total} = \\sum_{k=1}^{n-2} C_k \\approx \\sum_{k=1}^{n-2} (8n^2 - 12nk + 4k^2)$。\n\n我们计算各项的和：\n- $\\sum_{k=1}^{n-2} 8n^2 = 8n^2(n-2) = 8n^3 - 16n^2$。首项是 $8n^3$。\n- $\\sum_{k=1}^{n-2} (-12nk) = -12n \\sum_{k=1}^{n-2} k = -12n \\frac{(n-2)(n-1)}{2} = -6n(n^2 - 3n + 2) = -6n^3 + 18n^2 - 12n$。首项是 $-6n^3$。\n- $\\sum_{k=1}^{n-2} 4k^2 = 4 \\sum_{k=1}^{n-2} k^2 = 4 \\frac{(n-2)(n-1)(2(n-2)+1)}{6} = \\frac{2}{3}(n-2)(n-1)(2n-3)$。这个关于 $n$ 的多项式的首项是 $\\frac{2}{3}(n)(n)(2n) = \\frac{4}{3}n^3$。\n\n将各部分的首项相加：\n$C_{total} \\approx 8n^3 - 6n^3 + \\frac{4}{3}n^3 = 2n^3 + \\frac{4}{3}n^3 = \\frac{6n^3 + 4n^3}{3} = \\frac{10}{3}n^3$。\n\n非分块上海森堡约简的总浮点运算数的首项是 $\\frac{10}{3}n^3$。", "answer": "$$\n\\boxed{\\frac{10}{3}n^{3}}\n$$", "id": "3572651"}, {"introduction": "理论上的精确计算与计算机上的有限精度实践之间存在着重要差异。这个动手编程练习 [@problem_id:3572579] 旨在弥合这一差距，要求您设计并实现一个程序，以验证一个计算出的矩阵在有限精度下是否“接近”上海森堡形式。您将学习如何根据机器精度设定一个合理的容差，并通过计算本应为零的子对角线下方元素的范数来检验算法的向后稳定性，这对于将数值算法从理论转化为可靠的软件代码是宝贵的实践经验。", "problem": "设计并实现一个程序，在给定一组测试矩阵的情况下，在有限精度算术中通过界定严格位于第一副对角线下方的元素的弗罗贝尼乌斯范数，来验证每个矩阵是否接近上海森堡形式。请使用实数双精度浮点算术进行计算，并通过浮点算术的标准模型来模拟浮点舍入：对于应用于实数的任何基本算术运算，计算结果满足 $\\mathrm{fl}(x \\,\\mathrm{op}\\, y) = (x \\,\\mathrm{op}\\, y)\\,(1+\\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入误差。对于 binary64（双精度），假设 $u = \\tfrac{1}{2}\\,\\mathrm{eps}$，其中 $\\mathrm{eps}$ 是机器 epsilon。一个 $n \\times n$ 的实矩阵 $H$ 是上海森堡矩阵，如果对于所有满足 $i \\ge j + 2$ 的索引 $i,j$，都有 $H_{ij} = 0$。对于任意矩阵 $M \\in \\mathbb{R}^{n \\times n}$，定义矩阵 $L(M)$ 为其位于第一副对角线以下的严格下三角部分，即如果 $i \\ge j + 2$，则 $L(M)_{ij} = M_{ij}$，否则 $L(M)_{ij} = 0$。弗罗贝尼乌斯范数定义为 $\\|X\\|_{F} = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} X_{ij}^{2}}$。待实现的验证测试必须对给定矩阵 $M$ 判断不等式 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立，其中容差规定为\n$$\n\\tau(n,M) = \\gamma \\, n \\, u \\, \\|M\\|_{F},\n$$\n固定常数 $\\gamma = 10$。每个测试用例的输出必须是一个布尔值，指示不等式是否成立。程序必须仅使用实数算术，并且不得假设超出每个测试用例指定范围的任何结构。\n\n您的程序必须实现以下测试套件。所有随机数必须使用具有指定种子和大小的实值标准正态分布 $\\mathcal{N}(0,1)$ 生成，并且每个确定性构造必须严格按照说明进行。对于给定的正整数 $n$，令 $\\mathrm{HessMask}(n)$ 表示索引集 $\\{(i,j): 1 \\le i \\le n,\\, 1 \\le j \\le n,\\, i \\le j+1\\}$，对应于上海森堡矩阵中可能为非零的元素，令 $\\mathrm{LowerMask}(n)$ 表示索引集 $\\{(i,j): i \\ge j+2\\}$。\n\n按顺序构建和评估的测试用例：\n\n1. 正常路径精确上海森堡。令 $n = 6$，种子 $s = 11$。通过为 $\\mathrm{HessMask}(n)$ 中的元素从 $\\mathcal{N}(0,1)$ 中抽取独立样本来构造 $H \\in \\mathbb{R}^{n \\times n}$，并将 $\\mathrm{LowerMask}(n)$ 中的所有元素设置为 $0$。评估 $\\|L(H)\\|_{F} \\le \\tau(n,H)$ 是否成立。\n\n2. 带有微小下部噪声的近似海森堡。令 $n = 10$，种子 $s_H = 13$。使用种子 $s_H$ 按测试用例 $1$ 的方式构造 $H \\in \\mathbb{R}^{n \\times n}$。接下来，令种子 $s_E = 1313$，并仅在 $\\mathrm{LowerMask}(n)$ 上从 $\\mathcal{N}(0,1)$ 中抽取独立样本来生成一个矩阵 $E \\in \\mathbb{R}^{n \\times n}$，其他位置为零。如果 $\\|E\\|_{F} \\ne 0$，则缩放 $E$ 使其 $\\|E\\|_{F}$ 等于目标下部范数 $t = 5\\, n \\, u \\, \\|H\\|_{F}$；如果 $\\|E\\|_{F} = 0$，则保持 $E = 0$。定义 $M = H + E$ 并评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n3. 明显的非海森堡下部扰动。令 $n = 10$，种子 $s_H = 17$。使用种子 $s_H$ 按测试用例 $1$ 的方式构造 $H \\in \\mathbb{R}^{n \\times n}$。接下来，令种子 $s_E = 1717$，并如上所述在 $\\mathrm{LowerMask}(n)$ 上生成仅在该区域有支撑的 $E$。如果 $\\|E\\|_{F} \\ne 0$，则缩放 $E$ 使其 $\\|E\\|_{F}$ 等于目标下部范数 $t = 10^{-8} \\, \\|H\\|_{F}$；如果 $\\|E\\|_{F} = 0$，则保持 $E = 0$。定义 $M = H + E$ 并评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n4. 边界情况 $n=1$。令 $n = 1$，种子 $s = 19$。从 $\\mathcal{N}(0,1)$ 中抽取其单个元素来生成 $M \\in \\mathbb{R}^{1 \\times 1}$。评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n5. 边界情况 $n=2$。令 $n = 2$，种子 $s = 23$。通过从 $\\mathcal{N}(0,1)$ 中独立抽取元素来生成 $M \\in \\mathbb{R}^{2 \\times 2}$。评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n6. 有限精度下的算法化海森堡约简。令 $n = 8$，种子 $s_A = 29$。通过从 $\\mathcal{N}(0,1)$ 中独立抽取元素来生成一个稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$。使用一系列 Householder 反射变换计算相似变换 $\\widetilde{H} = Q^{\\top} A Q$，以将第一副对角线下方的元素置零，该过程在单位舍入误差为 $u$ 的浮点算术中进行。使用标准的无主元 Householder 海森堡约简：对于每个从 $1$ 到 $n-2$ 的 $k$，计算一个作用于第 $k+1$ 到 $n$ 行的 Householder 反射，以将第 $k$ 列中第一副对角线下方的元素置零，并将其从左侧和右侧应用于 $A$ 进行原地更新；将 $\\widetilde{H}$ 设置为最终更新的矩阵。评估 $\\|L(\\widetilde{H})\\|_{F} \\le \\tau(n,\\widetilde{H})$ 是否成立。\n\n7. 缩放不变性合理性检查。重用测试用例 $2$ 的构造方法，使用种子 $s_H = 13$ 和 $s_E = 1313$ 形成 $M \\in \\mathbb{R}^{10 \\times 10}$。定义标量 $s = 10^{6}$ 和缩放后的矩阵 $\\widehat{M} = s\\, M$。评估 $\\|L(\\widehat{M})\\|_{F} \\le \\tau(10,\\widehat{M})$ 是否成立。\n\n实现要求：\n\n- 使用双精度。将 $u$ 计算为 $u = \\tfrac{1}{2}\\,\\mathrm{eps}$，其中 $\\mathrm{eps}$ 是双精度下的机器 epsilon。\n- 所有范数必须是如上定义的弗罗贝尼乌斯范数。\n- 测试用例 6 中的 Householder 约简必须显式实现（不要假设精确算术；使用浮点运算）。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[true_or_false_1,true_or_false_2,...]”），其中每个条目是相应测试用例的布尔结果，按上面列出的顺序排列。\n\n所有测试用例的最终答案都是布尔值。不涉及物理单位或角度；所有计算都是在 $\\mathbb{R}$ 上的纯数值计算，并且必须在指定的有限精度模型中执行。", "solution": "所提供的问题是数值线性代数领域一个定义明确的计算任务。它在科学上是合理的、客观的，并包含获得唯一且可验证解所需的所有信息。该问题的有效性已得到确认，解决方案如下。\n\n### 验证方法的原理\n一个 $n \\times n$ 的实矩阵 $H$ 被定义为上海森堡矩阵，如果其第一副对角线以下的所有元素都为零。也就是说，对于所有满足 $i \\ge j+2$ 的索引 $i,j$，有 $H_{ij} = 0$。在有限精度算术中，由于舍入误差，理论上是上海森堡矩阵的矩阵在这些位置上可能会出现小的非零值。本任务是实现一个测试，以确定一个矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 是否“接近”上海森堡形式。\n\n这是通过量化矩阵中本应为零的部分的“大小”来实现的。我们定义一个矩阵 $L(M)$，它只包含 $M$ 中严格位于第一副对角线下方的元素：\n$$\nL(M)_{ij} = \\begin{cases} M_{ij}  \\text{if } i \\ge j+2 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n这个下部的“大小”使用弗罗贝尼乌斯范数来衡量，对于任何矩阵 $X \\in \\mathbb{R}^{n \\times n}$，其定义为：\n$$\n\\|X\\|_{F} = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} X_{ij}^{2}}\n$$\n问题规定了一个容差 $\\tau(n,M)$，用于与 $\\|L(M)\\|_{F}$ 进行比较。这个容差是数值分析中的一种标准形式，它与矩阵维度 $n$、矩阵的范数 $\\|M\\|_{F}$ 以及单位舍入误差 $u$ 成比例。单位舍入误差 $u$ 表征了浮点算术的精度。对于双精度（binary64），$u = \\frac{1}{2} \\mathrm{eps}$，其中 $\\mathrm{eps}$ 是机器 epsilon，约等于 $2.22 \\times 10^{-16}$。该容差由下式给出：\n$$\n\\tau(n,M) = \\gamma \\, n \\, u \\, \\|M\\|_{F}\n$$\n常数 $\\gamma$ 给定为 $10$。如果以下不等式成立，则认为矩阵 $M$ “接近上海森堡形式”：\n$$\n\\|L(M)\\|_{F} \\le \\tau(n,M)\n$$\n程序将为一系列根据问题规范构建的测试矩阵实现此检查。\n\n### 测试用例实现\n七个测试用例的构建和评估如下：\n\n1.  **精确上海森堡**：构造一个 $6 \\times 6$ 的矩阵 $H$，其第一副对角线及其上方的元素从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取，而第一副对角线下方的所有元素都精确设置为 $0$。对于此矩阵，$L(H)$ 是零矩阵，因此 $\\|L(H)\\|_F = 0$，不等式自然满足。\n\n2.  **近似海森堡**：形成一个 $10 \\times 10$ 的矩阵 $M = H+E$。$H$ 是一个精确的上海森堡矩阵。$E$ 是一个扰动矩阵，其非零元素仅存在于第一副对角线下方，并被缩放以使 $\\|E\\|_F = 5 \\, n \\, u \\, \\|H\\|_F$。由于 $L(M) = E$，测试评估的是 $5 \\, n \\, u \\, \\|H\\|_F \\le 10 \\, n \\, u \\, \\|H+E\\|_F$ 是否成立。由于 $E$ 非常小，$\\|H+E\\|_F \\approx \\|H\\|_F$，因此条件近似为 $5 \\le 10$，该条件成立。\n\n3.  **明显的非海森堡**：与案例 2 类似，但扰动 $E$ 被缩放为 $\\|E\\|_F = 10^{-8} \\|H\\|_F$。测试变为检查 $10^{-8} \\|H\\|_F \\le 10 \\, n \\, u \\, \\|H+E\\|_F$ 是否成立。当 $n=10$ 且 $u \\approx 1.11 \\times 10^{-16}$ 时，右侧约等于 $10 \\cdot 10 \\cdot (1.11 \\times 10^{-16}) \\|H\\|_F \\approx 10^{-14} \\|H\\|_F$。由于 $10^{-8} > 10^{-14}$，不等式不成立。\n\n4.  **边界情况 $n=1$**：对于任何 $1 \\times 1$ 矩阵，条件 $i \\ge j+2$（即 $1 \\ge 1+2$）永远不会满足。因此，$L(M)$ 总是零矩阵，其范数为 $0$，测试通过。\n\n5.  **边界情况 $n=2$**：对于任何 $2 \\times 2$ 矩阵，条件 $i \\ge j+2$ 对任何索引 $(i,j)$ 都不满足。$L(M)$ 是零矩阵，测试通过。\n\n6.  **算法化海森堡约简**：使用 Householder 约简算法的显式实现，将一个稠密的 $8 \\times 8$ 随机矩阵 $A$ 约简为上海森堡形式 $\\widetilde{H}$。该算法迭代地应用 Householder 反射变换 $P_k$，将每列中副对角线以下的元素置零。对于每列 $k=0, \\dots, n-3$：\n    a. 根据子列 $A[k+1:n, k]$ 构造一个 Householder 向量 $v$，以将其从第二个元素开始的条目置零。为避免相消误差，使用了 $v = x + \\operatorname{sign}(x_1)\\|x\\|_2 e_1$ 的选择。\n    b. 高效地应用相似变换 $A \\leftarrow P_k A P_k$，而无需构造稠密的反射矩阵。这通过秩1更新来完成：$A \\leftarrow A - v(2 v^T A)$ 和 $A \\leftarrow A - (2Av)v^T$，其中v是单位向量。\n    Householder 方法的后向稳定性确保了所得矩阵 $\\widetilde{H}$ 在第一副对角线下方的元素非常小，其范数 $\\|L(\\widetilde{H})\\|_F$ 在 $u \\|A\\|_F$ 的量级。容差 $\\tau$ 的设计正是为了适应这种情况，因此预计测试会通过。\n\n7.  **缩放不变性检查**：理论上，测试条件对于用非零标量 $s$ 缩放 $M$ 是不变的，因为 $\\|L(sM)\\|_F = |s|\\|L(M)\\|_F$ 且 $\\tau(n,sM) = |s|\\tau(n,M)$。此测试用例通过重用案例 2 的矩阵并将其缩放 $s=10^6$ 来在计算上验证此属性。结果应与案例 2 的结果相匹配。\n\n该实现使用 `numpy` 进行矩阵运算。所需的弗罗贝尼乌斯范数和矩阵构造使用标准库函数完成，以保证效率和正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem statement\nGAMMA = 10.0\n# Unit roundoff for double precision (binary64)\nU = 0.5 * np.finfo(np.float64).eps\n\ndef check_is_near_hessenberg(M: np.ndarray) - bool:\n    \"\"\"\n    Verifies if a matrix M is close to upper Hessenberg form.\n    Checks if ||L(M)||_F = gamma * n * u * ||M||_F.\n    \"\"\"\n    n = M.shape[0]\n    \n    if n = 2:\n        # For n=1 or n=2, the set of indices i >= j+2 is empty.\n        # Thus L(M) is the zero matrix and its norm is 0.\n        norm_L_M = 0.0\n    else:\n        # Extract elements where i >= j+2 and compute the norm.\n        # np.tril_indices(n, k=-2) gives indices for the lower triangle starting\n        # from the second subdiagonal.\n        rows, cols = np.tril_indices(n, k=-2)\n        lower_elements = M[rows, cols]\n        # The L2 norm of this vector of elements is the Frobenius norm of L(M).\n        norm_L_M = np.linalg.norm(lower_elements)\n\n    norm_M = np.linalg.norm(M, 'fro')\n    \n    # If M is the zero matrix, its norm is 0. L(M) is also zero.\n    # The tolerance is 0, and norm_L_M is 0. The test 0 = 0 passes.\n    if norm_M == 0.0:\n        return True\n\n    tolerance = GAMMA * n * U * norm_M\n    \n    return norm_L_M = tolerance\n\ndef test_case_1():\n    \"\"\"Happy-path exact upper Hessenberg.\"\"\"\n    n = 6\n    seed = 11\n    rng = np.random.default_rng(seed)\n    \n    H = np.zeros((n, n), dtype=np.float64)\n    # HessMask(n) corresponds to i = j+1.\n    rows, cols = np.triu_indices(n, k=-1)\n    H[rows, cols] = rng.normal(size=len(rows))\n    \n    return check_is_near_hessenberg(H)\n\ndef test_case_2_and_7_builder(scale: float):\n    \"\"\"Builder for test cases 2 and 7.\"\"\"\n    n = 10\n    seed_H = 13\n    seed_E = 1313\n    \n    # Construct H (upper Hessenberg part)\n    rng_H = np.random.default_rng(seed_H)\n    H = np.zeros((n, n), dtype=np.float64)\n    rows_h, cols_h = np.triu_indices(n, k=-1)\n    H[rows_h, cols_h] = rng_H.normal(size=len(rows_h))\n    \n    # Construct E (lower perturbation part)\n    rng_E = np.random.default_rng(seed_E)\n    E = np.zeros((n, n), dtype=np.float64)\n    rows_e, cols_e = np.tril_indices(n, k=-2)\n    E[rows_e, cols_e] = rng_E.normal(size=len(rows_e))\n\n    # Scale E\n    norm_H = np.linalg.norm(H, 'fro')\n    norm_E = np.linalg.norm(E, 'fro')\n    \n    target_lower_norm = 5.0 * n * U * norm_H\n\n    E_scaled = np.zeros_like(E)\n    if norm_E != 0.0:\n        E_scaled = E * (target_lower_norm / norm_E)\n        \n    M = H + E_scaled\n    M_final = scale * M\n    \n    return check_is_near_hessenberg(M_final)\n\ndef test_case_3():\n    \"\"\"Clearly non-Hessenberg lower perturbation.\"\"\"\n    n = 10\n    seed_H = 17\n    seed_E = 1717\n    \n    rng_H = np.random.default_rng(seed_H)\n    H = np.zeros((n, n), dtype=np.float64)\n    rows_h, cols_h = np.triu_indices(n, k=-1)\n    H[rows_h, cols_h] = rng_H.normal(size=len(rows_h))\n    \n    rng_E = np.random.default_rng(seed_E)\n    E = np.zeros((n, n), dtype=np.float64)\n    rows_e, cols_e = np.tril_indices(n, k=-2)\n    E[rows_e, cols_e] = rng_E.normal(size=len(rows_e))\n    \n    norm_H = np.linalg.norm(H, 'fro')\n    norm_E = np.linalg.norm(E, 'fro')\n    \n    target_lower_norm = 1e-8 * norm_H\n    \n    E_scaled = np.zeros_like(E)\n    if norm_E != 0:\n        E_scaled = E * (target_lower_norm / norm_E)\n        \n    M = H + E_scaled\n    return check_is_near_hessenberg(M)\n\ndef test_case_4():\n    \"\"\"Boundary case n=1.\"\"\"\n    n = 1\n    seed = 19\n    rng = np.random.default_rng(seed)\n    M = rng.normal(size=(n, n))\n    return check_is_near_hessenberg(M)\n\ndef test_case_5():\n    \"\"\"Boundary case n=2.\"\"\"\n    n = 2\n    seed = 23\n    rng = np.random.default_rng(seed)\n    M = rng.normal(size=(n, n))\n    return check_is_near_hessenberg(M)\n    \ndef householder_hessenberg_reduction(A: np.ndarray) - np.ndarray:\n    \"\"\"Explicitly performs Householder reduction to upper Hessenberg form.\"\"\"\n    M = A.copy()\n    n = M.shape[0]\n    \n    for k in range(n - 2):\n        x = M[k+1:n, k]\n        norm_x = np.linalg.norm(x)\n        \n        s = np.copysign(1.0, x[0] if x[0] != 0 else 1.0)\n        \n        v = x.copy()\n        v[0] += s * norm_x\n        \n        norm_v = np.linalg.norm(v)\n\n        if norm_v > 1e-15: # Safeguard against zero vector\n            v /= norm_v\n            \n            # Left multiplication: M_new = P*M = M - 2*v*(v.T*M)\n            sub_M_left = M[k+1:n, k:n]\n            w_left = 2.0 * (v.T @ sub_M_left)\n            M[k+1:n, k:n] -= np.outer(v, w_left)\n            \n            # Right multiplication: M_new = M*P = M - 2*(M*v)*v.T\n            sub_M_right = M[:, k+1:n]\n            w_right = 2.0 * (sub_M_right @ v)\n            M[:, k+1:n] -= np.outer(w_right, v)\n            \n    return M\n\ndef test_case_6():\n    \"\"\"Algorithmic Hessenberg reduction in finite precision.\"\"\"\n    n = 8\n    seed_A = 29\n    rng = np.random.default_rng(seed_A)\n    A = rng.normal(size=(n, n))\n    \n    H_tilde = householder_hessenberg_reduction(A)\n    \n    return check_is_near_hessenberg(H_tilde)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_functions = [\n        test_case_1,\n        lambda: test_case_2_and_7_builder(scale=1.0),\n        test_case_3,\n        test_case_4,\n        test_case_5,\n        test_case_6,\n        lambda: test_case_2_and_7_builder(scale=1e6),\n    ]\n    \n    results = [str(func()).lower() for func in test_functions]\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3572579"}]}