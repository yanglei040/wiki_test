{"hands_on_practices": [{"introduction": "我们从一个基础应用开始：使用带列主元的QR分解来确定矩阵的秩。这个练习提供了一个具体的例子，展示了该算法如何通过智能地重排各列来揭示矩阵内部的线性相关性。这些相关性最终会以在上三角因子$R$对角线上出现零元素的形式被明确地揭示出来，从而直接得到矩阵的秩。[@problem_id:1057080]", "problem": "考虑矩阵 $A$ 定义如下：\n$$\nA = \\begin{pmatrix}\n1 & 0 & 1 & 0 \\\\\n0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 \\\\\n0 & 1 & 1 & 0\n\\end{pmatrix}\n$$\n对矩阵 $A$ 进行带列主元的QR分解，以确定其数值秩。数值秩是通过分解得到的上三角矩阵 $R$ 中非零对角线元素的个数，计算时使用精确算术（无容差阈值）。报告这个秩。", "solution": "对 $A$ 进行带列主元的QR分解，得到一个上三角矩阵 $R$，其对角线元素为 $ r_{11} = \\sqrt{2} $，$ r_{22} = \\sqrt{2} $，$ r_{33} = 1 $ 和 $ r_{44} = 0 $。数值秩是 $R$ 中非零对角线元素的个数。\n\n- $ r_{11} = \\sqrt{2} \\neq 0 $\n- $ r_{22} = \\sqrt{2} \\neq 0 $\n- $ r_{33} = 1 \\neq 0 $\n- $ r_{44} = 0 $\n\n有3个非零对角线元素。", "answer": "$$\\boxed{3}$$", "id": "1057080"}, {"introduction": "现实世界中的矩阵通常不是精确的秩亏，而是“近似”秩亏，这一特性可能导致严重的数值不稳定性。下一个练习将挑战你深入分析带列主元的QR分解在此类矩阵上的行为，通过追踪$R$矩阵的对角线元素作为小参数$\\epsilon$的函数，你将更深刻地理解该算法如何量化并揭示近似的线性相关性，并将微小的数值差异反映在$R$对角线元素的数量级上。[@problem_id:3549747]", "problem": "考虑近似秩亏矩阵 $A(\\epsilon) \\in \\mathbb{R}^{3 \\times 3}$，其定义为\n$$\nA(\\epsilon) = \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & 1 & 1+\\epsilon \\\\\n1 & 1+\\epsilon & 1\n\\end{bmatrix},\n$$\n其中 $\\epsilon > 0$ 是一个足够小的数。执行带列主元选择的基于Householder变换的正交三角（QR）分解，即寻找正交矩阵 $Q \\in \\mathbb{R}^{3 \\times 3}$、上三角矩阵 $R \\in \\mathbb{R}^{3 \\times 3}$ 和置换矩阵 $P \\in \\mathbb{R}^{3 \\times 3}$，使得\n$$\nQ^{\\top} A(\\epsilon) P = R,\n$$\n每一步的主元选择标准为在剩余（更新后）的列中选取具有最大2-范数的列；如果出现范数完全相等的情况，则选择列索引最小的列来打破僵局。约定 $R$ 的对角线元素为非负。\n\n仅从Householder反射变换的定义和列主元选择标准出发，执行第一步主元决策，然后解析地预测算法产生的对角线元素大小 $|R_{11}|$、$|R_{22}|$ 和 $|R_{33}|$ 的模式，并用 $\\epsilon$ 精确表示。你的最终答案必须是一个单一的闭式解析表达式，其中包含作为 $\\epsilon$ 函数的 $|R_{11}|$、$|R_{22}|$ 和 $|R_{33}|$，并排列成一个行矩阵。不需要进行数值近似或舍入。", "solution": "问题要求计算矩阵 $A(\\epsilon)$ 经过带列主元选择的Householder QR分解后得到的上三角矩阵 $R$ 的对角线元素的大小 $|R_{11}|$、$|R_{22}|$ 和 $|R_{33}|$。该分解的形式为 $Q^{\\top} A(\\epsilon) P = R$，其中 $Q$ 是正交矩阵，$P$ 是置换矩阵，$R$ 是对角线元素为非负的上三角矩阵。\n\n给定的矩阵是：\n$$\nA(\\epsilon) = \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & 1 & 1+\\epsilon \\\\\n1 & 1+\\epsilon & 1\n\\end{bmatrix}\n$$\n设 $A(\\epsilon)$ 的列向量为 $a_1, a_2, a_3$。\n\n**第一步：选择第一个主元**\n列主元策略要求选择具有最大2-范数的列。我们计算 $A(\\epsilon)$ 各列的2-范数的平方：\n$$\n||a_1||_2^2 = 1^2 + 1^2 + 1^2 = 3\n$$\n$$\n||a_2||_2^2 = 1^2 + 1^2 + (1+\\epsilon)^2 = 1 + 1 + 1 + 2\\epsilon + \\epsilon^2 = 3 + 2\\epsilon + \\epsilon^2\n$$\n$$\n||a_3||_2^2 = 1^2 + (1+\\epsilon)^2 + 1^2 = 1 + 1 + 2\\epsilon + \\epsilon^2 + 1 = 3 + 2\\epsilon + \\epsilon^2\n$$\n因为 $\\epsilon > 0$，我们有 $3 + 2\\epsilon + \\epsilon^2 > 3$。因此，$||a_2||_2$ 和 $||a_3||_2$ 都大于 $||a_1||_2$。第2列和第3列的范数相等。打破僵局的规则是选择索引最小的列，因此我们选择第2列 $a_2$ 作为第一个主元。\n\n这需要交换第1列和第2列。置换矩阵为 $P_1 = \\begin{bmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$。第一步中要变换的矩阵是 $A' = A(\\epsilon)P_1$：\n$$\nA' = \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & 1 & 1+\\epsilon \\\\\n1+\\epsilon & 1 & 1\n\\end{bmatrix}\n$$\n$A'$ 的第一列是主元列，即原始的 $a_2$。$R$ 的第一个对角元素，记为 $R_{11}$，是该主元列的2-范数。根据约定，$R_{11} \\ge 0$。\n$$\n|R_{11}| = R_{11} = ||a_2||_2 = \\sqrt{3 + 2\\epsilon + \\epsilon^2}\n$$\n\n**第二步：选择第二个主元**\n将第一个Householder变换 $Q_1^{\\top}$ 应用于 $A'$，得到 $A^{(2)} = Q_1^{\\top} A' = Q_1^{\\top} A(\\epsilon) P_1$。该矩阵具有以下结构：\n$$\nA^{(2)} = \\begin{bmatrix}\nR_{11} & R_{12} & R_{13} \\\\\n0 &  &  \\\\\n0 & \\multicolumn{2}{c}{M_{2\\times2}}\n\\end{bmatrix}\n$$\n其中 $M_{2\\times2}$ 是一个 $2 \\times 2$ 子矩阵，其列向量需要被评估以进行下一步的主元选择。设子矩阵 $M_{2\\times2}$ 的列为 $\\tilde{c}_2$ 和 $\\tilde{c}_3$。它们对应于 $A'$ 的第二列和第三列的更新版本。\n\n这些子列的长度可以在不显式构造Householder矩阵的情况下计算出来。由于变换 $Q_1^{\\top}$ 是正交的，它保持列范数不变。$A'$ 的原始第二列和第三列分别是 $a_1$ 和 $a_3$。变换后，它们变为 $c_2 = Q_1^{\\top} a_1$ 和 $c_3 = Q_1^{\\top} a_3$。我们有 $c_2 = [R_{12}, \\tilde{c}_2^\\top]^\\top$ 和 $c_3 = [R_{13}, \\tilde{c}_3^\\top]^\\top$。根据范数守恒：\n$$\n||\\tilde{c}_2||_2^2 = ||c_2||_2^2 - R_{12}^2 = ||a_1||_2^2 - R_{12}^2\n$$\n$$\n||\\tilde{c}_3||_2^2 = ||c_3||_2^2 - R_{13}^2 = ||a_3||_2^2 - R_{13}^2\n$$\n元素 $R_{12}$ 和 $R_{13}$ 是 $a_1$ 和 $a_3$ 在归一化主元列 $a_2/||a_2||_2$ 上的投影。\n$$\nR_{12} = \\frac{\\langle a_2, a_1 \\rangle}{||a_2||_2} = \\frac{1 \\cdot 1 + 1 \\cdot 1 + (1+\\epsilon) \\cdot 1}{\\sqrt{3+2\\epsilon+\\epsilon^2}} = \\frac{3+\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\n$$\n$$\nR_{13} = \\frac{\\langle a_2, a_3 \\rangle}{||a_2||_2} = \\frac{1 \\cdot 1 + 1 \\cdot (1+\\epsilon) + (1+\\epsilon) \\cdot 1}{\\sqrt{3+2\\epsilon+\\epsilon^2}} = \\frac{1+1+\\epsilon+1+\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}} = \\frac{3+2\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\n$$\n将这些代入范数方程：\n$$\n||\\tilde{c}_2||_2^2 = 3 - \\left(\\frac{3+\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\\right)^2 = \\frac{3(3+2\\epsilon+\\epsilon^2) - (9+6\\epsilon+\\epsilon^2)}{3+2\\epsilon+\\epsilon^2} = \\frac{2\\epsilon^2}{3+2\\epsilon+\\epsilon^2}\n$$\n$$\n||\\tilde{c}_3||_2^2 = (3+2\\epsilon+\\epsilon^2) - \\left(\\frac{3+2\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\\right)^2 = \\frac{(3+2\\epsilon+\\epsilon^2)(3+2\\epsilon+\\epsilon^2) - (3+2\\epsilon)^2}{3+2\\epsilon+\\epsilon^2}\n$$\n对分子使用平方差公式 $u^2-v^2=(u-v)(u+v)$，其中 $u=(3+2\\epsilon+\\epsilon^2)$，$v=3+2\\epsilon$：\n$$\n||\\tilde{c}_3||_2^2 = \\frac{(\\epsilon^2)(6+4\\epsilon+\\epsilon^2)}{3+2\\epsilon+\\epsilon^2}\n$$\n为了选择第二个主元，我们比较 $||\\tilde{c}_2||_2^2$ 和 $||\\tilde{c}_3||_2^2$。由于 $\\epsilon > 0$，我们只需要比较分子 $2\\epsilon^2$ 和 $\\epsilon^2(6+4\\epsilon+\\epsilon^2)$，这简化为比较 $2$ 和 $6+4\\epsilon+\\epsilon^2$。由于 $\\epsilon > 0$，显然有 $6+4\\epsilon+\\epsilon^2 > 2$。\n因此，$||\\tilde{c}_3||_2 > ||\\tilde{c}_2||_2$，第二个主元列是 $\\tilde{c}_3$。这对应于 $A'$ 的第三列，即原始的 $a_3$。因此，$R$ 的第二个对角元素是：\n$$\n|R_{22}| = R_{22} = ||\\tilde{c}_3||_2 = \\sqrt{\\frac{\\epsilon^2(6+4\\epsilon+\\epsilon^2)}{3+2\\epsilon+\\epsilon^2}} = \\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\n$$\n\n**第三步：确定第三个对角元素**\n我们可以利用行列式的性质，在不显式执行第二次Householder变换的情况下确定 $|R_{33}|$。对于分解 $AP=QR$ (或 $Q^\\top AP=R$)，我们有：\n$$\n\\det(A) \\det(P) = \\det(Q) \\det(R)\n$$\n置换矩阵的行列式 $\\det(P)$ 是 $\\pm 1$。正交矩阵的行列式 $\\det(Q)$ 也是 $\\pm 1$。对两边取绝对值，得到：\n$$\n|\\det(A)| = |\\det(R)|\n$$\n上三角矩阵的行列式是对角元素的乘积：$\\det(R) = R_{11}R_{22}R_{33}$。由于我们约定 $R_{ii} \\ge 0$，这意味着 $|\\det(R)| = R_{11}R_{22}R_{33}$。\n我们来计算 $A(\\epsilon)$ 的行列式：\n$$\n\\det(A(\\epsilon)) = \\det \\begin{bmatrix}\n1 & 1 & 1 \\\\\n1 & 1 & 1+\\epsilon \\\\\n1 & 1+\\epsilon & 1\n\\end{bmatrix} = 1(1(1) - (1+\\epsilon)^2) - 1(1(1) - 1(1+\\epsilon)) + 1(1(1+\\epsilon) - 1(1))\n$$\n$$\n= (1 - (1+2\\epsilon+\\epsilon^2)) - (1 - 1 - \\epsilon) + (1+\\epsilon - 1) = (-2\\epsilon - \\epsilon^2) - (-\\epsilon) + \\epsilon = -2\\epsilon - \\epsilon^2 + 2\\epsilon = -\\epsilon^2\n$$\n因此，$|\\det(A(\\epsilon))| = \\epsilon^2$。我们有：\n$$\nR_{11} R_{22} R_{33} = \\epsilon^2\n$$\n所以，$|R_{33}| = R_{33} = \\frac{\\epsilon^2}{R_{11}R_{22}}$。代入 $R_{11}$ 和 $R_{22}$ 的表达式：\n$$\nR_{11} R_{22} = \\left(\\sqrt{3+2\\epsilon+\\epsilon^2}\\right) \\left(\\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\\right) = \\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}\n$$\n最后，\n$$\n|R_{33}| = R_{33} = \\frac{\\epsilon^2}{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}} = \\frac{\\epsilon}{\\sqrt{6+4\\epsilon+\\epsilon^2}}\n$$\n\n对角元素的大小为：\n$|R_{11}| = \\sqrt{3+2\\epsilon+\\epsilon^2}$\n$|R_{22}| = \\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}$\n$|R_{33}| = \\frac{\\epsilon}{\\sqrt{6+4\\epsilon+\\epsilon^2}}$\n按照要求将这些排列成一个行矩阵，即可得到最终结果。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\sqrt{3+2\\epsilon+\\epsilon^2} & \\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}} & \\frac{\\epsilon}{\\sqrt{6+4\\epsilon+\\epsilon^2}} \\end{pmatrix}}\n$$", "id": "3549747"}, {"introduction": "带列主元的QR分解最重要的应用之一是求解线性最小二乘问题，尤其是在设计矩阵是病态（ill-conditioned）的时候。这个最终的动手练习将通过一个计算实验，让你直观地比较该方法与经典的法方程在数值鲁棒性上的巨大差异。通过构建一个含有近似共线列的矩阵，你将亲眼见证为什么秩揭示QR分解是现代科学与工程计算中获得稳定解的首选工具。[@problem_id:3275467]", "problem": "您将实现一个程序，通过构造和测量来演示，当设计矩阵的两列几乎相同时，用于线性最小二乘的正规方程法如何在数值上发生秩亏，而基于列主元 QR 分解的秩揭示分解法则仍能识别正确的数值秩并产生稳定的最小二乘解。请完全使用纯数值线性代数的术语进行操作。\n\n考虑一个超定线性系统的最小二乘问题，即最小化残差的欧几里得范数：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\| A x - b \\|_2,\n$$\n其中合成矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 按如下方式构造。设 $m = 5$ 且 $n = 3$。定义标准基向量 $e_1, e_2, e_3 \\in \\mathbb{R}^5$。对于给定的参数 $\\epsilon \\ge 0$，设置\n$$\nc_1 = e_1, \\quad c_2 = e_1 + \\epsilon\\, e_2, \\quad c_3 = e_3,\n$$\n并组装\n$$\nA(\\epsilon) = \\begin{bmatrix} c_1 & c_2 & c_3 \\end{bmatrix} \\in \\mathbb{R}^{5 \\times 3}.\n$$\n取右侧向量为\n$$\nb = \\begin{bmatrix} 1 \\\\ -3 \\\\ 2 \\\\ 0 \\\\ 0 \\end{bmatrix} \\in \\mathbb{R}^5.\n$$\n\n推导的基本依据：\n- 根据最小二乘法的一阶最优性条件，任何最小化子 $x$ 都满足正规方程\n$$\nA^\\top A \\, x = A^\\top b.\n$$\n- 对于一个满秩矩阵 $M$，其在 $2$-范数下的条件数定义为 $\\kappa_2(M) = \\sigma_{\\max}(M) / \\sigma_{\\min}(M)$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是最大和最小奇异值。\n- 对于任何 $A$，当 $A$ 具有列满秩时，$A^\\top A$ 的奇异值是 $A$ 的奇异值的平方，因此 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$。\n- 带列主元的 QR 分解是一种形式为 $A P = Q R$ 的分解，其中 $P$ 是一个置换矩阵，$Q$ 的列是标准正交的，$R$ 是一个上三角矩阵。将 $R$ 的对角线元素与容差 $\\tau = \\max(m,n)\\,\\varepsilon_{\\mathrm{mach}}\\,\\|A\\|_2$ 进行比较，可以揭示其数值秩 $r$，其中 $\\varepsilon_{\\mathrm{mach}}$ 是浮点运算的机器精度。\n\n您的任务：\n1. 使用修正的 Gram–Schmidt 过程实现一个带列主元的秩揭示 QR 分解，以计算 $Q$、$R$、一个编码 $P$ 的置换，以及通过将 $R$ 的对角线元素与上述容差 $\\tau$ 比较确定的数值秩 $r$。请使用双精度浮点运算。\n2. 对每个指定的 $\\epsilon$ 值，计算以下量：\n   - 通过奇异值分解计算的 $A(\\epsilon)$ 的秩，记为 $\\mathrm{rank}(A)$。\n   - 通过奇异值分解计算的 $A(\\epsilon)^\\top A(\\epsilon)$ 的秩，记为 $\\mathrm{rank}(A^\\top A)$。\n   - 由您的带列主元的 QR 分解所识别的数值秩 $r_{\\mathrm{QR}}$。\n   - $2$-范数条件数 $\\kappa_2(A)$ 和 $\\kappa_2(A^\\top A)$。\n   - 通过显式构造 $G = A^\\top A$ 并使用直接线性求解器求解 $G x = A^\\top b$ 来计算的最小二乘解。如果 $\\mathrm{rank}(G) < n$，则将该系统视为数值奇异且不进行求解；在这种情况下，报告一个如下所述的特殊值。\n   - 通过您的带列主元的 QR 分解计算的最小二乘解。使用数值秩 $r_{\\mathrm{QR}}$ 求解降维后的三角系统 $R_{1:r,1:r} y = (Q^\\top b)_{1:r}$，然后通过置换将其映射回原始变量顺序以获得 $x_{\\mathrm{QR}}$，其余分量设置为零。这将产生一个与检测到的数值秩一致的最小范数最小二乘解。\n3. 对每种情况，报告残差范数和解的范数：\n   - 正规方程解的残差范数，$\\|A x_{\\mathrm{NE}} - b\\|_2$。如果 $\\mathrm{rank}(A^\\top A) < n$，则将此残差报告为浮点数 NaN (非数值)。\n   - QR 解的残差范数，$\\|A x_{\\mathrm{QR}} - b\\|_2$。\n   - QR 解的欧几里得范数，$\\|x_{\\mathrm{QR}}\\|_2$。\n4. 对 $\\epsilon$ 使用以下测试套件：\n   - $\\epsilon = 10^{-8}$，表示两列相差 $10^{-8}$。\n   - $\\epsilon = 0$，表示两列完全相同（真正的秩亏）。\n   - $\\epsilon = 10^{-4}$，表示较温和的近共线性。\n5. 最终输出格式：\n   - 您的程序应生成一行输出，包含一个逗号分隔的包含三个条目的列表，每个条目是按上述测试套件顺序排列的一个测试用例的列表。\n   - 对每个测试用例，输出列表\n     $$\n     [\\mathrm{rank}(A),\\ \\mathrm{rank}(A^\\top A),\\ r_{\\mathrm{QR}},\\ \\kappa_2(A),\\ \\kappa_2(A^\\top A),\\ \\|A x_{\\mathrm{NE}} - b\\|_2,\\ \\|A x_{\\mathrm{QR}} - b\\|_2,\\ \\|x_{\\mathrm{QR}}\\|_2].\n     $$\n   - 如果 $\\mathrm{rank}(A^\\top A) < n$，则如前所述，将正规方程的残差输出为 NaN。所有条目必须是基本的数值类型（整数或浮点数）。整个输出必须是单行上的 Python 风格的列表的列表，例如：[[...],[...],[...]]。\n\n注意：\n- 不涉及角度；不需要角度单位。\n- 没有物理单位；报告纯标量值。\n- 确保您的实现是确定性的，并且除非语言默认指定，否则核心计算仅使用双精度运算。", "solution": "该问题已被验证，并被确定为一个有效的、适定的数值线性代数问题。它具有科学依据，是客观的，并包含所有必要的信息以进行处理。\n\n任务是展示使用带列主元的秩揭示 QR 分解来解决线性最小二乘问题，相比于传统的正规方程法，具有更优的数值稳定性，尤其是在设计矩阵 $A$ 含有近共线列的情况下。\n\n线性最小二乘问题是对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和向量 $b \\in \\mathbb{R}^m$，找到一个 $x \\in \\mathbb{R}^n$ 来最小化残差的欧几里得范数 $\\|Ax - b\\|_2$。\n\n对于 $m=5$ 和 $n=3$，具体的矩阵 $A(\\epsilon)$ 由列向量 $c_1, c_2, c_3 \\in \\mathbb{R}^5$ 构造如下：\n$$\nc_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 1 \\\\ \\epsilon \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nc_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n$$\n矩阵 $A(\\epsilon)$ 由这些列向量构成，$A(\\epsilon) = \\begin{bmatrix} c_1 & c_2 & c_3 \\end{bmatrix}$。右侧向量给定为 $b = [1, -3, 2, 0, 0]^\\top$。\n\n当参数 $\\epsilon$ 接近 $0$ 时，列向量 $c_1$ 和 $c_2$ 变得近似线性相关。这使得矩阵 $A(\\epsilon)$ 变得病态。将对 $\\epsilon \\in \\{10^{-8}, 0, 10^{-4}\\}$ 进行分析。\n\n### 方法论\n\n将实现并比较两种方法。\n\n**1. 正规方程 (NE)**\n最小二乘问题的解必须满足正规方程：\n$$\nA^\\top A x = A^\\top b.\n$$\n该方法涉及显式构造格拉姆矩阵 (Gram matrix) $G = A^\\top A$ 和一个修正的右侧向量 $A^\\top b$，然后求解 $n \\times n$ 的线性系统 $Gx = A^\\top b$。此方法的一个关键问题是 $G$ 的条件数是 $A$ 条件数的平方，即 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$。这种平方运算会导致显著的数值精度损失，并可能使一个计算上满秩的问题表现为奇异。\n\n对于每个 $\\epsilon$，我们首先使用标准的奇异值分解 (SVD) 方法计算 $G = A^\\top A$ 的秩。如果 $\\mathrm{rank}(G) < n$，则该矩阵被认为是数值奇异的，我们不会尝试求解该系统。在这种情况下，残差范数 $\\|A x_{\\mathrm{NE}} - b\\|_2$ 将被报告为非数值 (NaN)。否则，我们求解该系统得到 $x_{\\mathrm{NE}}$ 并计算相应的残差范数。\n\n**2. 带列主元的 QR 分解**\n一种数值上更稳定的方法是使用 $A$ 的 QR 分解。具体来说，我们将使用带列主元的秩揭示 QR 分解，其形式为：\n$$\nAP = QR,\n$$\n其中 $P$ 是一个置换矩阵，$Q$ 是一个列标准正交的矩阵，$R$ 是一个上三角矩阵。最小二乘问题变为 $\\min_x \\|Q R P^\\top x - b\\|_2$。令 $y = P^\\top x$，该问题等价于 $\\min_y \\|Ry - Q^\\top b\\|_2$，因为乘以正交矩阵 $Q^\\top$ 不会改变欧几里得范数。\n\n实现将使用带列主元的修正的 Gram-Schmidt (MGS) 算法。在分解的每一步 $k$，选择剩余欧几里得范数最大的列作为主元，将其交换到第 $k$ 个位置，然后用它来形成 $Q$ 的第 $k$ 列和 $R$ 的第 $k$ 行。\n\n一个关键方面是确定数值秩 $r_{\\mathrm{QR}}$。这是通过将 $R$ 的对角元素的绝对值与一个容差 $\\tau$ 进行比较来完成的：\n$$\n\\tau = \\max(m,n)\\,\\varepsilon_{\\mathrm{mach}}\\,\\|A\\|_2,\n$$\n其中 $\\varepsilon_{\\mathrm{mach}}$ 是双精度浮点运算的机器精度。如果 $|R_{kk}| < \\tau$，则认为矩阵在第 $k$ 步是数值秩亏的，并将数值秩设置为 $r_{\\mathrm{QR}} = k-1$。\n\n一旦找到了 $Q$、$R$、置换 $P$（由索引向量表示）和数值秩 $r_{\\mathrm{QR}}$，就可以计算解 $x_{\\mathrm{QR}}$。我们求解降秩的上三角系统：\n$$\nR_{1:r, 1:r} \\, y_{1:r} = (Q^\\top b)_{1:r},\n$$\n其中 $r=r_{\\mathrm{QR}}$，使用回代法求解。通过将其前 $r$ 个分量设置为 $y_{1:r}$，其余 $n-r$ 个分量设置为零，来构成大小为 $n$ 的解向量 $y$。这对应于找到一个基本解。最后，反转置换以找到原始坐标下的解：$x_{\\mathrm{QR}} = Py$。这是通过根据置换向量将 $y$ 的分量赋给 $x_{\\mathrm{QR}}$ 来实现的。\n\n### 计算量\n对于每个 $\\epsilon$ 值，将计算并报告以下量：\n- $\\mathrm{rank}(A)$：通过 SVD 计算的 $A(\\epsilon)$ 的秩。\n- $\\mathrm{rank}(A^\\top A)$：通过 SVD 计算的 $A(\\epsilon)^\\top A(\\epsilon)$ 的秩。\n- $r_{\\mathrm{QR}}$：由我们的带列主元的 QR 分解实现得到的数值秩。\n- $\\kappa_2(A)$：$A(\\epsilon)$ 的 $2$-范数条件数。\n- $\\kappa_2(A^\\top A)$：$A(\\epsilon)^\\top A(\\epsilon)$ 的 $2$-范数条件数。\n- $\\|A x_{\\mathrm{NE}} - b\\|_2$：正规方程解的残差范数（或 NaN）。\n- $\\|A x_{\\mathrm{QR}} - b\\|_2$：QR 解的残差范数。\n- $\\|x_{\\mathrm{QR}}\\|_2$：QR 解的欧几里得范数。\n\n这种比较分析旨在突显正规方程的数值陷阱以及使用秩揭示 QR 方法解决最小二乘问题的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef qr_pivot_mgs(A):\n    \"\"\"\n    Computes a rank-revealing QR factorization with column pivoting using\n    Modified Gram-Schmidt. The factorization is of the form AP = QR.\n\n    Args:\n        A (np.ndarray): The matrix to factorize, of size m x n.\n\n    Returns:\n        Q (np.ndarray): m x n matrix with orthonormal columns.\n        R (np.ndarray): n x n upper triangular matrix.\n        p (list): Permutation vector of length n. A_permuted[:, k] is A[:, p[k]].\n        rank (int): Numerical rank of the matrix.\n    \"\"\"\n    m, n = A.shape\n    V = A.copy()\n    Q = np.zeros((m, n))\n    R = np.zeros((n, n))\n    p = list(range(n))\n\n    A_norm = np.linalg.norm(A, 2)\n    # Handle the case of a zero matrix for robustness\n    if A_norm == 0:\n        return Q, R, p, 0\n    \n    tol = max(m, n) * np.finfo(float).eps * A_norm\n    \n    numerical_rank = n  # Assume full rank initially\n\n    for k in range(n):\n        # Find the column with the largest 2-norm in the remaining submatrix V[:, k:]\n        col_norms = np.linalg.norm(V[:, k:], axis=0)\n        best_col_idx_local = np.argmax(col_norms)\n        best_col_idx_global = k + best_col_idx_local\n        \n        # Swap columns in V and update the permutation vector p\n        if best_col_idx_global != k:\n            V[:, [k, best_col_idx_global]] = V[:, [best_col_idx_global, k]]\n            p[k], p[best_col_idx_global] = p[best_col_idx_global], p[k]\n            \n        # The diagonal element R[k, k] is the norm of the current pivot column\n        R[k, k] = np.linalg.norm(V[:, k])\n\n        # Check for rank deficiency against the tolerance\n        if R[k, k]  tol:\n            numerical_rank = k\n            break\n\n        # Normalize the k-th column of V to get the k-th column of Q\n        Q[:, k] = V[:, k] / R[k, k]\n\n        # Orthogonalize the remaining columns of V against the new basis vector Q[:, k]\n        for j in range(k + 1, n):\n            R[k, j] = np.dot(Q[:, k], V[:, j])\n            V[:, j] -= R[k, j] * Q[:, k]\n            \n    return Q, R, p, numerical_rank\n\ndef back_substitution(R, c):\n    \"\"\"Solves Rx = c for an upper triangular matrix R.\"\"\"\n    n = R.shape[0]\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        if R[i, i] == 0:\n            # This should ideally not be reached if the system is well-posed.\n            # R is from a rank-revealing QR, so R[i,i] > tol > 0.\n            raise np.linalg.LinAlgError(\"Singular matrix in back substitution.\")\n        dot_product = np.dot(R[i, i+1:], x[i+1:])\n        x[i] = (c[i] - dot_product) / R[i, i]\n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for the specified epsilon values.\n    \"\"\"\n    test_cases = [1e-8, 0.0, 1e-4]\n    m, n = 5, 3\n    b = np.array([1., -3., 2., 0., 0.])\n    \n    results = []\n\n    for epsilon in test_cases:\n        # 1. Construct the matrix A for the given epsilon\n        A = np.zeros((m, n), dtype=float)\n        A[0, 0] = 1.0\n        A[0, 1] = 1.0\n        A[1, 1] = epsilon\n        A[2, 2] = 1.0\n\n        # 2. Compute ranks and condition numbers\n        rank_A = np.linalg.matrix_rank(A)\n        G = A.T @ A\n        rank_G = np.linalg.matrix_rank(G)\n        \n        # Condition number is Inf for singular matrices\n        cond_A = np.linalg.cond(A, 2)\n        cond_G = np.linalg.cond(G, 2)\n      \n        # 3. Solve via Normal Equations\n        if rank_G  n:\n            res_norm_NE = np.nan\n        else:\n            try:\n                x_NE = np.linalg.solve(G, A.T @ b)\n                res_norm_NE = np.linalg.norm(A @ x_NE - b, 2)\n            except np.linalg.LinAlgError:\n                # Fails if G is singular despite rank check, due to floating point limits\n                res_norm_NE = np.nan\n\n        # 4. Solve via QR with column pivoting\n        Q, R, p_indices, r_QR = qr_pivot_mgs(A)\n        \n        c = Q.T @ b\n        \n        y = np.zeros(n)\n        if r_QR > 0:\n            # Solve the reduced upper-triangular system\n            R_r = R[:r_QR, :r_QR]\n            c_r = c[:r_QR]\n            y_r = back_substitution(R_r, c_r)\n            y[:r_QR] = y_r\n        \n        # Un-permute the solution vector y to get x_QR\n        x_QR = np.zeros(n)\n        # Create an inverse permutation map for clarity\n        inv_p = np.empty_like(p_indices)\n        inv_p[p_indices] = np.arange(len(p_indices))\n        x_QR = y[inv_p]\n        \n        res_norm_QR = np.linalg.norm(A @ x_QR - b, 2)\n        sol_norm_QR = np.linalg.norm(x_QR, 2)\n\n        # 5. Assemble and store results for this case\n        case_result = [\n            int(rank_A),\n            int(rank_G),\n            int(r_QR),\n            float(cond_A),\n            float(cond_G),\n            float(res_norm_NE) if not np.isnan(res_norm_NE) else res_norm_NE,\n            float(res_norm_QR),\n            float(sol_norm_QR)\n        ]\n        results.append(case_result)\n        \n    # Print the final list of lists in the required format.\n    # The str() function provides the specified \"Python-style list-of-lists\" format.\n    print(str(results))\n\nsolve()\n```", "id": "3275467"}]}