{"hands_on_practices": [{"introduction": "要掌握任何一种数值方法，首先要从其基本原理入手。本练习将引导你从最小二乘问题的目标函数出发，通过优化理论推导出其核心解法——正规方程。这个过程不仅能加深你对最小二乘解存在的必然性的理解，还能揭示一个理想情况：当矩阵$A$的列向量是标准正交时，正规方程会极大简化，此时$A^{\\top}A = I$，从而直接得到解[@problem_id:3592614]。", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m \\geq n$，考虑线性最小二乘问题，即对于给定的 $b \\in \\mathbb{R}^{m}$，寻找一个 $x \\in \\mathbb{R}^{n}$ 以最小化残差范数的平方 $x \\mapsto \\|A x - b\\|_{2}^{2}$。\n\n(a) 从最小二乘目标的定义以及最小化子必须使目标函数的梯度为零这一事实出发，推导刻画任意最小化子的最优性条件。\n\n(b) 现在假设 $A$ 的列是标准正交的。仅使用你在(a)部分推导出的最优性条件和标准正交性假设，得到以 $A$ 和 $b$ 表示的唯一最小化子的闭式表达式。证明其唯一性。\n\n(c) 考虑以下具体实例：\n$$\nA \\;=\\; \\begin{pmatrix}\n1  0 \\\\\n0  \\tfrac{1}{\\sqrt{2}} \\\\\n0  \\tfrac{1}{\\sqrt{2}}\n\\end{pmatrix} \\in \\mathbb{R}^{3 \\times 2},\n\\qquad\nb \\;=\\; \\begin{pmatrix}\n3 \\\\ 2 \\\\ -1\n\\end{pmatrix} \\in \\mathbb{R}^{3}.\n$$\n验证 $A$ 的列是标准正交的，然后显式计算(b)部分中的最小化子。将你的最终答案表示为行向量。无需四舍五入。", "solution": "该问题是有效的，因为它是数值线性代数中一个适定、有科学依据且客观的问题。它没有任何问题验证指南中列出的使其无效的缺陷。它要求推导和应用线性最小二乘理论中的基本结果。\n\n**(a) 最优性条件的推导**\n\n线性最小二乘问题旨在寻找一个向量 $x \\in \\mathbb{R}^{n}$，以最小化目标函数 $f(x)$，该函数定义为残差向量 $r = Ax - b$ 的欧几里得范数的平方：\n$$f(x) = \\|Ax - b\\|_{2}^{2}$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m \\geq n$，$x \\in \\mathbb{R}^{n}$，$b \\in \\mathbb{R}^{m}$。\n\n范数的平方可以表示为点积，在矩阵表示法中等价于与转置的乘积：\n$$f(x) = (Ax - b)^{T}(Ax - b)$$\n使用矩阵转置的性质 $(P Q)^{T} = Q^{T} P^{T}$ 展开此表达式，我们得到：\n$$f(x) = (x^{T}A^{T} - b^{T})(Ax - b)$$\n分配各项可得：\n$$f(x) = x^{T}A^{T}Ax - x^{T}A^{T}b - b^{T}Ax + b^{T}b$$\n$x^{T}A^{T}b$ 和 $b^{T}Ax$ 这两项是标量。标量等于其自身的转置。我们对第一项取转置：$(x^{T}A^{T}b)^{T} = b^{T}(A^{T})^{T}(x^{T})^{T} = b^{T}Ax$。因此，中间两项是相同的。目标函数化简为：\n$$f(x) = x^{T}(A^{T}A)x - 2b^{T}Ax + b^{T}b$$\n函数 $f(x)$ 是关于 $x$ 的二次型。由于矩阵 $A^{T}A$ 是半正定的（因为 $z^T(A^TA)z = (Az)^T(Az) = \\|Az\\|_2^2 \\ge 0$），函数 $f(x)$ 是凸函数。一个可微凸函数的最小化子 $x$ 必须出现在函数关于 $x$ 的梯度为零向量的点上。我们计算梯度 $\\nabla f(x)$：\n$$\\nabla f(x) = \\nabla_{x} \\left( x^{T}(A^{T}A)x - 2b^{T}Ax + b^{T}b \\right)$$\n使用矩阵微积分的标准法则：\n\\begin{itemize}\n    \\item 二次型 $x^{T}Mx$ 的梯度是 $(M+M^{T})x$。由于 $A^{T}A$ 是对称的，$\\nabla_{x}(x^{T}(A^{T}A)x) = 2(A^{T}A)x$。\n    \\item 线性形式 $c^{T}x$ 的梯度是 $c$。这里，$c^{T} = 2b^{T}A$，所以 $c = (2b^{T}A)^{T} = 2A^{T}b$。因此，$\\nabla_{x}(-2b^{T}Ax) = -2A^{T}b$。\n    \\item 常数项 $b^{T}b$ 的梯度是零向量。\n\\end{itemize}\n结合这些结果，得到梯度：\n$$\\nabla f(x) = 2(A^{T}A)x - 2A^{T}b$$\n通过将梯度设为零来找到最优性条件：\n$$2(A^{T}A)x - 2A^{T}b = 0$$\n两边除以 $2$ 得到著名的**正规方程**：\n$$A^{T}Ax = A^{T}b$$\n这就是 $\\|Ax - b\\|_{2}^{2}$ 的任意最小化子 $x$ 都必须满足的最优性条件。\n\n**(b) 标准正交列的唯一最小化子**\n\n现在给定 $A$ 的列是标准正交的。设 $A$ 的列向量为 $a_{1}, a_{2}, \\ldots, a_{n}$，所以 $A = \\begin{pmatrix} a_{1}  a_{2}  \\cdots  a_{n} \\end{pmatrix}$。标准正交性条件意味着任意两个不同列的点积为零，且每列的范数为一：\n$$a_{i}^{T}a_{j} = \\delta_{ij} = \\begin{cases} 1  \\text{if } i=j \\\\ 0  \\text{if } i \\neq j \\end{cases}$$\n让我们考察矩阵乘积 $A^{T}A$。$A^{T}A$ 的第 $i$ 行第 $j$ 列的元素由 $A^{T}$ 的第 $i$ 行与 $A$ 的第 $j$ 列的乘积给出。$A^{T}$ 的第 $i$ 行恰好是 $A$ 的第 $i$ 列的转置，即 $a_{i}^{T}$。因此：\n$$(A^{T}A)_{ij} = a_{i}^{T}a_{j} = \\delta_{ij}$$\n这表明矩阵 $A^{T}A$ 是 $n \\times n$ 的单位矩阵 $I_{n}$。\n\n将此结果代入(a)部分推导出的最优性条件 $A^{T}Ax = A^{T}b$，我们得到：\n$$I_{n}x = A^{T}b$$\n这立即化简为最小化子 $x$ 的一个闭式表达式：\n$$x = A^{T}b$$\n为证明此最小化子的唯一性，我们注意到线性系统 $(A^{T}A)x = A^{T}b$ 的解是唯一的，当且仅当矩阵 $A^{T}A$ 是可逆的。在本例中，我们已证明 $A^{T}A = I_{n}$。单位矩阵的逆是其自身，即 $(I_{n})^{-1} = I_{n}$，因此它是可逆的。于是，解 $x = (A^{T}A)^{-1}A^{T}b = I_{n}^{-1}A^{T}b = A^{T}b$ 是唯一的最小化子。\n\n**(c) 显式计算**\n\n我们给定具体实例：\n$$\nA = \\begin{pmatrix}\n1  0 \\\\\n0  \\frac{1}{\\sqrt{2}} \\\\\n0  \\frac{1}{\\sqrt{2}}\n\\end{pmatrix},\n\\qquad\nb = \\begin{pmatrix}\n3 \\\\\n2 \\\\\n-1\n\\end{pmatrix}\n$$\n首先，我们验证 $A$ 的列是标准正交的。设列向量为 $a_{1} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$ 和 $a_{2} = \\begin{pmatrix} 0 \\\\ \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{pmatrix}$。\n\n我们计算范数：\n$$\\|a_{1}\\|_{2}^{2} = a_{1}^{T}a_{1} = 1^{2} + 0^{2} + 0^{2} = 1 \\implies \\|a_{1}\\|_{2} = 1$$\n$$\\|a_{2}\\|_{2}^{2} = a_{2}^{T}a_{2} = 0^{2} + \\left(\\frac{1}{\\sqrt{2}}\\right)^{2} + \\left(\\frac{1}{\\sqrt{2}}\\right)^{2} = 0 + \\frac{1}{2} + \\frac{1}{2} = 1 \\implies \\|a_{2}\\|_{2} = 1$$\n这些列具有单位范数。\n\n我们计算它们的点积以检查正交性：\n$$a_{1}^{T}a_{2} = (1)(0) + (0)\\left(\\frac{1}{\\sqrt{2}}\\right) + (0)\\left(\\frac{1}{\\sqrt{2}}\\right) = 0$$\n这些列是正交的。由于它们也具有单位范数，所以 $A$ 的列是标准正交的。\n\n由于 $A$ 的列是标准正交的，我们可以使用(b)部分推导的公式来找到唯一的最小二乘最小化子 $x$：\n$$x = A^{T}b$$\n首先，我们求 $A$ 的转置：\n$$A^{T} = \\begin{pmatrix}\n1  0  0 \\\\\n0  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}\n\\end{pmatrix}$$\n现在，我们执行矩阵向量乘法：\n$$x = \\begin{pmatrix}\n1  0  0 \\\\\n0  \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n\\begin{pmatrix}\n3 \\\\\n2 \\\\\n-1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n(1)(3) + (0)(2) + (0)(-1) \\\\\n(0)(3) + \\left(\\frac{1}{\\sqrt{2}}\\right)(2) + \\left(\\frac{1}{\\sqrt{2}}\\right)(-1)\n\\end{pmatrix}\n$$\n$$x = \\begin{pmatrix}\n3 \\\\\n\\frac{2}{\\sqrt{2}} - \\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n3 \\\\\n\\frac{1}{\\sqrt{2}}\n\\end{pmatrix}$$\n题目要求将答案表示为行向量。因此，最小化子表示为 $[3, \\frac{1}{\\sqrt{2}}]$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3 & \\frac{1}{\\sqrt{2}}\n\\end{pmatrix}\n}\n$$", "id": "3592614"}, {"introduction": "理论上的完美公式在有限精度的计算机上可能表现得非常糟糕，正规方程就是这样一个典型例子。尽管$A^{\\top} A x = A^{\\top} b$在代数上是精确的，但计算$A^{\\top} A$这一步会使问题的条件数平方，即$\\kappa_2(A^{\\top} A) = (\\kappa_2(A))^2$，这对于病态矩阵是致命的。通过这个编程实践，你将亲手构造出导致正规方程法失败的案例，并将其与更稳定的奇异值分解（SVD）方法进行对比，从而直观地感受数值稳定性的重要性[@problem_id:3205220]。", "problem": "您需要设计并实现一个完整的、可运行的程序，以展示算法在解决线性最小二乘问题时的鲁棒性和稳定性。从第一性原理出发，线性最小二乘法旨在寻找一个 $\\ell_{2}$-范数最小化向量 $x \\in \\mathbb{R}^{n}$，该向量能够最小化给定矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和向量 $b \\in \\mathbb{R}^{m}$ 的残差 $\\lVert A x - b \\rVert_{2}$。两种经典方法是：(i) 构建并求解正规方程 $A^{\\top} A x = A^{\\top} b$，以及 (ii) 使用奇异值分解 (SVD) 计算伪逆解，这种解在存在病态条件时数值上更稳定。鲁棒性关注算法在扰动（例如，舍入误差或数据的微小变化）下的行为，而稳定性关注算法对输入条件数的敏感性。\n\n仅从核心定义和经过充分检验的事实（线性最小二乘目标、条件数的概念以及奇异值分解的存在性）出发，构建并测试求解正规方程在数值上不稳定的问题。您的程序必须：\n\n- 为线性最小二乘问题实现两个求解器：\n  1. 一个正规方程求解器，它显式地构建 $A^{\\top} A$ 和 $A^{\\top} b$，并使用直接法求解 $A^{\\top} A x = A^{\\top} b$。\n  2. 一个基于SVD的伪逆求解器。给定紧奇异值分解 $A = U \\Sigma V^{\\top}$，其中奇异值为 $\\sigma_{1} \\ge \\cdots \\ge \\sigma_{n} \\ge 0$，通过丢弃低于某个容差的奇异值并对余下的奇异值求逆来定义伪逆。使用容差 $\\tau_{\\sigma} = u \\cdot \\max(m,n) \\cdot \\sigma_{1}$，其中 $u$ 是双精度浮点数的单位舍入， $u \\approx 2.22 \\times 10^{-16}$。\n\n- 定义成功和失败的标准：\n  - 对于任何候选解 $\\hat{x}$，定义相对残差 $r(\\hat{x}) = \\lVert A \\hat{x} - b \\rVert_{2} / \\lVert b \\rVert_{2}$。\n  - 当真实解 $x^{\\star}$ 已知时，定义相对解误差 $e(\\hat{x}) = \\lVert \\hat{x} - x^{\\star} \\rVert_{2} / \\lVert x^{\\star} \\rVert_{2}$。\n  - 如果 $r(\\hat{x}_{\\mathrm{SVD}}) \\le \\tau_{\\mathrm{res}}$，则声明SVD求解器成功，其中 $\\tau_{\\mathrm{res}} = 10^{-10}$。\n  - 如果正规方程求解器引发奇异性错误，或者当 $x^{\\star}$ 已知时产生的解满足 $e(\\hat{x}_{\\mathrm{NE}}) > \\tau_{\\mathrm{sol}}$，或者当 $x^{\\star}$ 未知时满足 $r(\\hat{x}_{\\mathrm{NE}}) > \\tau_{\\mathrm{res,NE}}$，则声明其失败。使用 $\\tau_{\\mathrm{sol}} = 10^{-2}$ 和 $\\tau_{\\mathrm{res,NE}} = 10^{-6}$。\n\n- 对于每个测试用例，输出一个布尔值，指示正规方程求解是否失败而基于SVD的方法是否成功。具体来说，测试用例的布尔值必须是表达式\n  $\n  \\big(\\text{SVD 成功}\\big) \\land \\big(\\text{正规方程失败}\\big)\n  $\n  的真值。\n\n构建以下包含矩阵 $A$ 和向量 $b$ 的测试套件，每个都有指定的维度和参数。在所有情况下，使用具有固定种子的确定性随机数生成来确保可复现性，并根据 $b = A x^{\\star} + \\eta$ 计算 $b$，其中 $\\eta$ 是指定的噪声向量（如果适用）。\n\n- 测试用例1（良态基准，理想路径）：\n  - 维度：$m = 60$, $n = 20$。\n  - 构造：构建 $A = U \\Sigma V^{\\top}$，其中 $U \\in \\mathbb{R}^{60 \\times 20}$ 和 $V \\in \\mathbb{R}^{20 \\times 20}$ 是标准正交的，奇异值 $\\sigma_{k}$ 在 $1$ 和 $0.5$ 之间线性分布，对于 $k = 1,\\dots,20$。\n  - 真实解：从固定种子中抽取 $x^{\\star} \\in \\mathbb{R}^{20}$，并设置 $\\eta = 0$。\n\n- 测试用例2（极端病态，正规方程稳定性差）：\n  - 维度：$m = 80$, $n = 20$。\n  - 构造：如上构建 $A = U \\Sigma V^{\\top}$，其中 $\\sigma_{k}$ 从 $1$ 到 $10^{-8}$ 按对数间隔分布，使得 $\\kappa_{2}(A)$ 约等于 $10^{8}$。\n  - 真实解：从固定种子中抽取 $x^{\\star} \\in \\mathbb{R}^{20}$，并添加小噪声 $\\eta$，其范数 $\\lVert \\eta \\rVert_{2}$ 被缩放到约等于 $10^{-12} \\cdot \\lVert A x^{\\star} \\rVert_{2}$。\n\n- 测试用例3（经典病态设计，希尔伯特型矩阵）：\n  - 维度：$m = 40$, $n = 15$。\n  - 构造：定义 $A_{ij} = \\dfrac{1}{i + j - 1}$，其中 $i = 1,\\dots,40$ 且 $j = 1,\\dots,15$。\n  - 真实解：从固定种子中抽取 $x^{\\star} \\in \\mathbb{R}^{15}$，并添加噪声 $\\eta$，其范数 $\\lVert \\eta \\rVert_{2}$ 被缩放到约等于 $10^{-10} \\cdot \\lVert A x^{\\star} \\rVert_{2}$。\n\n- 测试用例4（秩亏，奇异的正规方程）：\n  - 维度：$m = 50$, $n = 20$。\n  - 构造：从固定种子中抽取一个随机矩阵 $A \\in \\mathbb{R}^{50 \\times 20}$，并将其第二列精确地设置为与第一列相等，使 $A$ 成为秩亏矩阵。\n  - 真实解：从固定种子中抽取 $x^{\\star} \\in \\mathbb{R}^{20}$，并设置 $\\eta = 0$。\n\n您的程序必须为每个测试用例计算上述布尔值。最终输出必须是单行，包含一个用方括号括起来的、以逗号分隔的布尔值列表，例如 $\\big[ \\text{true}, \\text{false}, \\text{true}, \\text{true} \\big]$，但要使用Python布尔值产生的确切大小写和格式。\n\n不涉及物理单位。不涉及角度。将任何阈值以小数形式数值化表示（不要使用百分号）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，例如 $\\big[ \\text{True}, \\text{False}, \\text{True}, \\text{True} \\big]$。", "solution": "所分配的问题是展示奇异值分解 (SVD) 方法在解决线性最小二乘问题时，相较于正规方程法所具有的优越数值稳定性，尤其是在处理病态或秩亏系统时。问题的核心是找到一个向量 $x \\in \\mathbb{R}^{n}$，以最小化给定矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和向量 $b \\in \\mathbb{R}^{m}$ 的残差的欧几里得范数 $\\lVert A x - b \\rVert_{2}$。我们将实现并比较两种用于此任务的经典算法。\n\n**正规方程法**\n\n优化的第一性原理指出，要使解 $x$ 成为凸函数 $f(x) = \\frac{1}{2} \\lVert Ax - b \\rVert_2^2$ 的最小化子，其梯度必须为零。梯度由 $\\nabla f(x) = A^{\\top}(Ax - b)$ 给出。将梯度设为零可得到著名的正规方程：\n$$\nA^{\\top} A x = A^{\\top} b\n$$\n这将最小二乘问题转化为一个方形线性方程组。如果矩阵 $A$ 是满列秩的，那么格拉姆矩阵 (Gram matrix) $A^{\\top} A \\in \\mathbb{R}^{n \\times n}$ 是对称正定的，并且可以使用标准方法（如 Cholesky 分解或 LU 分解）找到唯一的解 $x$。\n\n该方法的关键缺陷在于其数值稳定性。矩阵的条件数 $\\kappa(M)$ 衡量了 $Mx=y$ 的解对 $y$ 中扰动的敏感性。对于正规方程，相关矩阵是 $A^{\\top} A$。数值线性代数中的一个基本结论是，这个格拉姆矩阵的条件数是原始矩阵 $A$ 条件数的平方：\n$$\n\\kappa_2(A^{\\top} A) = \\big(\\kappa_2(A)\\big)^2\n$$\n如果 $A$ 是病态的（即 $\\kappa_2(A)$ 很大），$\\kappa_2(A^{\\top} A)$ 可能会变得巨大。例如，如果 $\\kappa_2(A) = 10^8$，那么 $\\kappa_2(A^{\\top} A) = 10^{16}$。在具有约16位十进制精度的标准双精度浮点运算中，矩阵 $A^{\\top} A$ 在计算上将与奇异矩阵无法区分。显式地构造 $A^{\\top} A$ 可能导致灾难性的信息损失。\n\n**基于SVD的伪逆方法**\n\n一种数值上更鲁棒的方法是基于奇异值分解 (SVD)。任何矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 都可以分解为：\n$$\nA = U \\Sigma V^{\\top}\n$$\n其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，其对角线上的非负实数称为奇异值，$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{\\min(m,n)} \\ge 0$。对于一个高矩阵（$m \\ge n$）的紧奇异值分解， $U$ 是 $m \\times n$ 维的，$\\Sigma$ 是 $n \\times n$ 维的，而 $V$ 是 $n \\times n$ 维的。\n\n最小二乘问题的解可以用 Moore-Penrose 伪逆 $A^{\\dagger}$ 来表示。最小范数最小二乘解是 $x = A^{\\dagger} b$。SVD 提供了一种计算伪逆的稳定方法：\n$$\nA^{\\dagger} = V \\Sigma^{\\dagger} U^{\\top}\n$$\n其中 $\\Sigma^{\\dagger}$ 是 $\\Sigma$ 的伪逆。它通过对非零奇异值取倒数，然后转置所得矩阵得到。为确保数值稳定性，将非常小（接近于零）的奇异值视为零。这是通过阈值化实现的。任何低于容差 $\\tau_{\\sigma}$ 的奇异值 $\\sigma_i$ 都被视为零。问题指定了一个标准容差：\n$$\n\\tau_{\\sigma} = u \\cdot \\max(m,n) \\cdot \\sigma_{1}\n$$\n其中 $u$ 是机器单位舍入（对于双精度，约等于 $2.22 \\times 10^{-16}$），$\\sigma_1$ 是最大的奇异值。这种方法避免了构造 $A^{\\top} A$，从而绕过了条件数的平方运算，使其具有很高的鲁棒性。\n\n**实现与评估策略**\n\n实现了两个求解器：`solve_normal_equations` 用于构建和求解正规方程，`solve_svd` 用于通过基于SVD的伪逆计算解。\n\n程序在四个旨在揭示正规方程脆弱性的测试用例上评估这些求解器：\n1.  **良态基准**：一个具有小条件数（$\\kappa_2(A)=2$）的矩阵。两种方法预计都会表现良好。\n2.  **极端病态**：一个具有大条件数（$\\kappa_2(A)=10^8$）的矩阵，使得 $\\kappa_2(A^{\\top}A) \\approx 10^{16}$，这达到了双精度算术的极限。\n3.  **希尔伯特型矩阵**：一个在逼近理论中出现的病态矩阵的经典例子。\n4.  **秩亏矩阵**：一个其列向量线性相关的矩阵。在这种情况下，$A^{\\top}A$ 精确地是奇异的，如果使用直接求解器，这保证了正规方程法的失败。\n\n对于每个测试用例，我们确定表达式 $(\\text{SVD 成功}) \\land (\\text{正规方程失败})$ 的布尔值。\n-   SVD成功定义为相对残差 $\\lVert A \\hat{x}_{\\mathrm{SVD}} - b \\rVert_{2} / \\lVert b \\rVert_{2} \\le 10^{-10}$。\n-   正规方程失败定义为求解过程中的奇异性错误，或者当已知真实解 $x^{\\star}$ 时，相对解误差 $\\lVert \\hat{x}_{\\mathrm{NE}} - x^{\\star} \\rVert_{2} / \\lVert x^{\\star} \\rVert_{2} > 10^{-2}$。\n\n最终输出汇总了这些布尔结果，展示了在哪些场景下正规方程法失败而SVD方法保持鲁棒和成功。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    U_EPS = np.finfo(float).eps\n    TAU_RES = 1e-10  # SVD success threshold for relative residual\n    TAU_SOL = 1e-2   # NE failure threshold for relative solution error\n    TAU_RES_NE = 1e-6 # NE failure threshold for relative residual (if x_star is unknown)\n\n    def solve_normal_equations(A, b):\n        \"\"\"\n        Solves min||Ax-b||_2 using the normal equations A.T*A*x = A.T*b.\n        Returns a tuple: (solution vector, singularity_flag).\n        The flag is True if a LinAlgError (singularity) is caught.\n        \"\"\"\n        AtA = A.T @ A\n        Atb = A.T @ b\n        try:\n            x_ne = np.linalg.solve(AtA, Atb)\n            return x_ne, False\n        except np.linalg.LinAlgError:\n            return None, True\n\n    def solve_svd(A, b):\n        \"\"\"\n        Solves min||Ax-b||_2 using SVD-based pseudoinverse.\n        \"\"\"\n        m, n = A.shape\n        U, s, Vt = np.linalg.svd(A, full_matrices=False)\n        \n        sigma_1 = s[0] if s.size > 0 else 0.0\n        tau_sigma = U_EPS * max(m, n) * sigma_1\n        \n        s_pinv = np.zeros_like(s)\n        if s.size > 0:\n            s_pinv[s > tau_sigma] = 1.0 / s[s > tau_sigma]\n        \n        # This computes x = V @ diag(s_pinv) @ U.T @ b efficiently\n        x_svd = Vt.T @ (s_pinv * (U.T @ b))\n        return x_svd\n\n    def evaluate_case(A, b, x_star):\n        \"\"\"\n        Performs the evaluation for a single test case.\n        Returns a boolean for (SVD_success AND NE_failure).\n        \"\"\"\n        # SVD Solver Evaluation\n        x_svd = solve_svd(A, b)\n        norm_b = np.linalg.norm(b)\n        if norm_b > 0:\n            r_svd = np.linalg.norm(A @ x_svd - b) / norm_b\n        else: # Handle b=0 case\n            r_svd = np.linalg.norm(A @ x_svd - b)\n        svd_success = r_svd = TAU_RES\n\n        # Normal Equations Solver Evaluation\n        x_ne, singularity = solve_normal_equations(A, b)\n        ne_failure = singularity\n        if not ne_failure:\n            norm_x_star = np.linalg.norm(x_star)\n            if norm_x_star > 0:\n                e_ne = np.linalg.norm(x_ne - x_star) / norm_x_star\n                if e_ne > TAU_SOL:\n                    ne_failure = True\n            elif np.linalg.norm(x_ne) > 0: # If x_star is zero, any non-zero solution is an error\n                ne_failure = True\n        \n        return svd_success and ne_failure\n\n    # --- Test Case Generation ---\n\n    def generate_case_1():\n        # Well-conditioned benchmark\n        m, n = 60, 20\n        rng = np.random.default_rng(123)\n        U, _ = np.linalg.qr(rng.standard_normal((m, n)))\n        V, _ = np.linalg.qr(rng.standard_normal((n, n)))\n        sigma = np.linspace(1.0, 0.5, n)\n        A = U @ np.diag(sigma) @ V.T\n        x_star = rng.standard_normal(n)\n        b = A @ x_star\n        return A, b, x_star\n\n    def generate_case_2():\n        # Extremely ill-conditioned\n        m, n = 80, 20\n        rng = np.random.default_rng(456)\n        U, _ = np.linalg.qr(rng.standard_normal((m, n)))\n        V, _ = np.linalg.qr(rng.standard_normal((n, n)))\n        sigma = np.logspace(0, -8, n)\n        A = U @ np.diag(sigma) @ V.T\n        x_star = rng.standard_normal(n)\n        b_noiseless = A @ x_star\n        eta_raw = rng.standard_normal(m)\n        norm_eta_raw = np.linalg.norm(eta_raw)\n        if norm_eta_raw > 0:\n            eta = eta_raw * (1e-12 * np.linalg.norm(b_noiseless)) / norm_eta_raw\n        else:\n            eta = np.zeros(m)\n        b = b_noiseless + eta\n        return A, b, x_star\n\n    def generate_case_3():\n        # Hilbert-type matrix\n        m, n = 40, 15\n        rng = np.random.default_rng(789)\n        i = np.arange(1, m + 1)[:, np.newaxis]\n        j = np.arange(1, n + 1)\n        A = 1.0 / (i + j - 1)\n        x_star = rng.standard_normal(n)\n        b_noiseless = A @ x_star\n        eta_raw = rng.standard_normal(m)\n        norm_eta_raw = np.linalg.norm(eta_raw)\n        if norm_eta_raw > 0:\n            eta = eta_raw * (1e-10 * np.linalg.norm(b_noiseless)) / norm_eta_raw\n        else:\n            eta = np.zeros(m)\n        b = b_noiseless + eta\n        return A, b, x_star\n\n    def generate_case_4():\n        # Rank-deficient\n        m, n = 50, 20\n        rng = np.random.default_rng(101)\n        A = rng.standard_normal((m, n))\n        A[:, 1] = A[:, 0]\n        x_star = rng.standard_normal(n)\n        b = A @ x_star\n        return A, b, x_star\n\n    # --- Run Suite and Print Results ---\n    \n    test_generators = [\n        generate_case_1,\n        generate_case_2,\n        generate_case_3,\n        generate_case_4,\n    ]\n\n    results = []\n    for gen_func in test_generators:\n        A, b, x_star = gen_func()\n        result = evaluate_case(A, b, x_star)\n        results.append(result)\n\n    # Format output as specified: [True,False,True,True]\n    formatted_results = [str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3205220"}, {"introduction": "在观察到正规方程会因病态问题而失效后，一个自然的问题是：我们能否预测这种失效？本练习旨在将定性的观察提升到定量的分析。你将从数值分析的第一性原理出发，推导出一个预测不等式，该不等式揭示了矩阵条件数、机器精度和解的误差之间的关键关系。通过编程实现一个数值实验，你将能够绘制出正规方程在单精度和双精度下的“稳定性相图”，精确地验证$\\kappa_2(A)^2 \\epsilon_{\\text{mach}}$何时会超出可容忍的误差范围[@problem_id:3540736]。", "problem": "从纯数学角度考虑超定线性最小二乘问题。设 $A \\in \\mathbb{R}^{m \\times n}$，其中 $m \\ge n$ 且 $A$ 为列满秩矩阵，并设 $b \\in \\mathbb{R}^m$。最小二乘解旨在对 $x \\in \\mathbb{R}^n$ 最小化 $\\|Ax - b\\|_2$。一种经典算法是求解正规方程 $A^\\top A x = A^\\top b$。对于单位舍入（机器 epsilon）为 $\\epsilon_{\\text{mach}}$ 的浮点运算，众所周知，与通过更稳定的方法求解最小二乘问题相比，求解正规方程会遭遇条件数放大的问题。您将构建一个受控的矩阵族，以研究在何种情况下正规方程在单精度和双精度下是可接受的，并将其与一个区分数值稳定区域和不稳定区域的预测不等式联系起来。\n\n从以下基本原理出发：\n- 列满秩矩阵的 $2$-范数条件数定义为 $\\kappa_2(A) = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$，其中 $\\sigma_{\\max}(A)$ 和 $\\sigma_{\\min}(A)$ 分别是 $A$ 的最大和最小奇异值。\n- 正规方程矩阵为 $A^\\top A$，它是一个对称正定矩阵，其 $2$-范数条件数为 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$。\n- 浮点运算中舍入的一阶模型指出，每次基本算术运算都会产生一个相对误差，其界限（一阶近似）为 $\\epsilon_{\\text{mach}}$ 的一个常数倍，并且通过后向稳定方法求解一个良态线性系统时，其前向误差与相应范数下的条件数乘以 $\\epsilon_{\\text{mach}}$ 成正比。\n\n您的任务是：\n1. 构建一个参数化矩阵族 $A(\\gamma) \\in \\mathbb{R}^{m \\times 2}$，其奇异值指定为 $\\sigma_1 = 1$ 和 $\\sigma_2 = 10^{-\\gamma}$，参数 $\\gamma \\ge 0$。确保 $m \\ge 2$ 且矩阵为列满秩。使用一个标准正交基 $U \\in \\mathbb{R}^{m \\times 2}$ 来构成 $A(\\gamma) = U \\operatorname{diag}(\\sigma_1, \\sigma_2)$，使得 $\\kappa_2(A(\\gamma)) = 10^{\\gamma}$。选择一个固定的非零向量 $x_\\star \\in \\mathbb{R}^2$ 并设置 $b(\\gamma) = A(\\gamma) x_\\star$。\n2. 利用上述浮点模型和条件数相关事实，从第一性原理推导出一个预测不等式，该不等式仅基于 $\\kappa_2(A)$、$\\epsilon_{\\text{mach}}$ 和一个容差 $\\tau  0$ 来判断在给定精度下求解正规方程是否应被视为数值上可接受。您的推导必须从求解线性系统的敏感性以及关系式 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$ 开始。将“可接受”精确定义为产生的解 $x$ 的相对误差满足 $\\|x - x_\\star\\|_2 / \\|x_\\star\\|_2 \\le \\tau$。\n3. 实现一个程序，对下述每个测试用例执行以下操作：\n   - 确定性地构造 $A(\\gamma)$ 和 $b(\\gamma)$。\n   - 分别在单精度（$32$ 位浮点数的 $\\epsilon_{\\text{mach}}$）和双精度（$64$ 位浮点数的 $\\epsilon_{\\text{mach}}$）下求解正规方程，以获得 $x^{(32)}(\\gamma)$ 和 $x^{(64)}(\\gamma)$。$A(\\gamma)$ 和 $b(\\gamma)$ 的构造可以在更高精度下进行，但 $A^\\top A$、$A^\\top b$ 的形成以及求解过程必须在目标精度下执行。\n   - 对 $p \\in \\{32,64\\}$，计算测量的相对误差 $e^{(p)}(\\gamma) = \\|x^{(p)}(\\gamma) - x_\\star\\|_2/\\|x_\\star\\|_2$。\n   - 使用您推导的不等式计算每个精度下的预测稳定性分类，该不等式必须用 $\\kappa_2(A(\\gamma))$、相应精度的 $\\epsilon_{\\text{mach}}$ 和 $\\tau$ 来表示。\n   - 将一个“阶段”类别编码为 $\\{0,1,2,3\\}$ 中的一个整数：\n     - $0$ 如果单精度和双精度都可接受，\n     - $1$ 如果单精度不可接受而双精度可接受，\n     - $2$ 如果单精度可接受而双精度不可接受，\n     - $3$ 如果两者都不可接受。\n     您需要生成两次此类别：一次基于预测不等式（“预测类别”），一次基于测量误差（“测量类别”）。\n4. 测试套件必须使用以下固定参数：\n   - $m = 200$, $n = 2$,\n   - $x_\\star = [1,-1]^\\top$,\n   - 容差 $\\tau = 10^{-3}$,\n   - 参数值 $\\gamma \\in \\{0.5,\\, 2.2,\\, 6.0,\\, 6.3,\\, 6.4,\\, 8.0\\}$,\n   - 使用固定的随机种子来构造 $U$，以确保结果是确定性的。\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素对应于给定顺序的一个 $\\gamma$，并且本身是一个双元素整数列表 $[\\text{predicted\\_category},\\text{measured\\_category}]$。例如，一个包含两个测试用例的输出可能看起来像：\"[[0,0],[1,1]]\"。该行中任何位置都不允许有空格。\n\n此问题不涉及物理单位。所有角度（如有）均不存在。所有结果都是无量纲的。最终列表的每个元素都必须是整数。您的代码必须是完全自包含的，并产生确切的最终输出格式。", "solution": "此问题被评估为有效。这是一个适定（well-posed）、有科学依据的数值线性代数问题，内容自洽，没有矛盾或歧义。它要求进行标准的理论推导，然后通过数值实验来阐释一个基本概念：最小二乘问题的正规方程的病态性（ill-conditioning）。\n\n### 1. 预测不等式的推导\n\n目标是推导一个不等式，用于预测正规方程的数值解何时是“可接受的”。“可接受”的定义是计算解 $x$ 的相对误差受容差 $\\tau$ 的限制。\n$$ \\frac{\\|x - x_\\star\\|_2}{\\|x_\\star\\|_2} \\le \\tau $$\n其中 $x_\\star$ 是精确解。\n\n正规方程由 $A^\\top A x = A^\\top b$ 给出。我们可以将其表示为标准线性系统 $Mx = y$，其中矩阵为 $M = A^\\top A$，右侧项为 $y = A^\\top b$。问题陈述中指出，对于所构建的测试用例，$b = A x_\\star$，这意味着 $x_\\star$ 是最小二乘问题以及正规方程的精确解，因为 $A^\\top A x_\\star = A^\\top (A x_\\star) = A^\\top b$。\n\n分析的核心在于浮点运算下求解线性系统 $Mx = y$ 的前向误差。对于后向稳定的线性系统求解器（例如基于 Cholesky 分解的求解器，它适用于对称正定矩阵 $M = A^\\top A$），标准误差分析为计算解 $\\hat{x}$ 的相对误差提供了以下界限：\n$$ \\frac{\\|\\hat{x} - x_\\star\\|_2}{\\|x_\\star\\|_2} \\le c \\cdot \\kappa_2(M) \\cdot \\epsilon_{\\text{mach}} $$\n此处，$\\epsilon_{\\text{mach}}$ 是所用浮点精度的机器 epsilon（单位舍入），$\\kappa_2(M)$ 是矩阵 $M$ 的 $2$-范数条件数，而 $c$ 是一个数量级为 $1$ 的常数，取决于矩阵的维度和算法的细节。这个界限包含了形成系统 $(M, y)$ 和求解该系统的误差。\n\n问题给出了原始矩阵 $A$ 的条件数与正规方程矩阵 $M=A^\\top A$ 的条件数之间的关键关系：\n$$ \\kappa_2(A^\\top A) = \\kappa_2(A)^2 $$\n将此关系代入误差界限，我们得到：\n$$ \\frac{\\|\\hat{x} - x_\\star\\|_2}{\\|x_\\star\\|_2} \\le c \\cdot \\kappa_2(A)^2 \\cdot \\epsilon_{\\text{mach}} $$\n为了按要求创建一个简单的一阶预测器，我们可以通过取常数 $c=1$ 来对行为进行建模。这给出了相对误差的直接估计：\n$$ e_{\\text{pred}} \\approx \\kappa_2(A)^2 \\cdot \\epsilon_{\\text{mach}} $$\n如果测量误差不大于 $\\tau$，则该解被视为“可接受的”。因此，我们可以通过检查我们的估计误差界限是否在此容差范围内来预测其可接受性：\n$$ \\kappa_2(A)^2 \\cdot \\epsilon_{\\text{mach}} \\le \\tau $$\n这就是预测不等式。对于 $\\kappa_2(A(\\gamma)) = 10^{\\gamma}$ 的特定参数化矩阵族 $A(\\gamma)$，该不等式变为：\n$$ (10^\\gamma)^2 \\cdot \\epsilon_{\\text{mach}} \\le \\tau \\quad \\implies \\quad 10^{2\\gamma} \\cdot \\epsilon_{\\text{mach}} \\le \\tau $$\n该不等式将用于对单精度（$\\epsilon_{\\text{mach}} \\approx 1.19 \\times 10^{-7}$）和双精度（$\\epsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16}$）的预测稳定性进行分类。\n\n### 2. 数值实验设计\n\n该实现将系统地测试此预测。对于测试套件 $\\{0.5, 2.2, 6.0, 6.3, 6.4, 8.0\\}$ 中的每个参数 $\\gamma$：\n\n1.  **矩阵构造**：使用一个固定的随机种子生成矩阵 $R \\in \\mathbb{R}^{200 \\times 2}$。对 $R$ 进行 QR 分解，得到一个具有标准正交列的矩阵 $U \\in \\mathbb{R}^{200 \\times 2}$。对于所有测试用例，此 $U$ 都是固定的。然后将矩阵 $A(\\gamma)$ 构造为 $A(\\gamma) = U \\Sigma(\\gamma)$，其中 $\\Sigma(\\gamma) = \\operatorname{diag}(1, 10^{-\\gamma})$。这种构造确保 $A(\\gamma)$ 的奇异值确实是 $1$ 和 $10^{-\\gamma}$，因此 $\\kappa_2(A(\\gamma)) = 10^\\gamma$。向量 $b(\\gamma)$ 设置为 $A(\\gamma)x_\\star$，其中 $x_\\star = [1, -1]^\\top$。这确保了精确解是已知的，并且最小二乘问题的残差为零。\n\n2.  **求解与误差测量**：对每种精度（32 位和 64 位），执行以下步骤：\n    a. 将矩阵 $A(\\gamma)$ 和 $b(\\gamma)$ 转换为目标精度。\n    b. 在该目标精度下使用算术运算形成正规方程矩阵 $A^\\top A$ 和向量 $A^\\top b$。\n    c. 求解线性系统 $(A^\\top A)x = (A^\\top b)$ 以找到精度为 $p \\in \\{32, 64\\}$ 的计算解 $x^{(p)}(\\gamma)$。\n    d. 计算测量的相对误差 $e^{(p)}(\\gamma) = \\|x^{(p)}(\\gamma) - x_\\star\\|_2 / \\|x_\\star\\|_2$。\n\n3.  **分类**：\n    -   **预测类别**：对每种精度 $p$，评估不等式 $10^{2\\gamma} \\cdot \\epsilon_{\\text{mach}}^{(p)} \\le \\tau$。如果不等式成立，则认为该精度是可接受的。\n    -   **测量类别**：对每种精度 $p$，将测量的误差 $e^{(p)}(\\gamma)$ 与容差 $\\tau$ 进行比较。如果 $e^{(p)}(\\gamma) \\le \\tau$，则认为解是可接受的。\n    -   基于对单精度和双精度的这些可接受性检查，根据问题陈述中指定的规则，为预测和测量都分配一个来自 $\\{0, 1, 2, 3\\}$ 的类别。类别 $2$（单精度可接受，双精度不可接受）预计不会出现。\n\n此过程为每个 $\\gamma$ 值生成一对类别 $[\\text{predicted\\_category}, \\text{measured\\_category}]$，然后将其格式化为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem concerning the conditioning of normal equations.\n    \"\"\"\n    # Task 4: Fixed parameters\n    m = 200\n    n = 2\n    x_star = np.array([1.0, -1.0], dtype=np.float64)\n    tau = 1e-3\n    gamma_values = [0.5, 2.2, 6.0, 6.3, 6.4, 8.0]\n    random_seed = 42\n\n    # Machine epsilon for single and double precision\n    eps_32 = np.finfo(np.float32).eps\n    eps_64 = np.finfo(np.float64).eps\n\n    # Generate a fixed orthonormal basis U\n    np.random.seed(random_seed)\n    # Generate a random m x n matrix\n    R = np.random.randn(m, n)\n    # Use QR decomposition to get an orthonormal basis for its column space\n    U, _ = np.linalg.qr(R)\n    U = U.astype(np.float64)\n\n    results = []\n\n    # Helper function for categorization\n    def get_category(single_ok, double_ok):\n        if single_ok and double_ok:\n            return 0  # Both acceptable\n        elif not single_ok and double_ok:\n            return 1  # Single unacceptable, double acceptable\n        elif single_ok and not double_ok:\n            return 2  # Single acceptable, double unacceptable (not expected)\n        else: # not single_ok and not double_ok\n            return 3  # Both unacceptable\n\n    for gamma in gamma_values:\n        # Task 1: Construct matrix A(gamma) and vector b(gamma)\n        # Use high precision (float64) for the \"true\" A and b\n        sigma1 = 1.0\n        sigma2 = 10.0**(-gamma)\n        Sigma = np.diag([sigma1, sigma2]).astype(np.float64)\n        A = U @ Sigma\n        b = A @ x_star\n\n        kappa_A = 10.0**gamma\n\n        # Task 2: Use the derived predictor inequality\n        # Predict acceptability for single precision (32-bit)\n        pred_single_ok = (kappa_A**2 * eps_32) = tau\n        # Predict acceptability for double precision (64-bit)\n        pred_double_ok = (kappa_A**2 * eps_64) = tau\n\n        predicted_category = get_category(pred_single_ok, pred_double_ok)\n\n        # Task 3: Solve normal equations and measure errors\n        # Solve for single precision (float32)\n        A_32 = A.astype(np.float32)\n        b_32 = b.astype(np.float32)\n        AtA_32 = A_32.T @ A_32\n        Atb_32 = A_32.T @ b_32\n        x_32 = np.linalg.solve(AtA_32, Atb_32)\n        err_32 = np.linalg.norm(x_32 - x_star) / np.linalg.norm(x_star)\n        meas_single_ok = err_32 = tau\n\n        # Solve for double precision (float64)\n        A_64 = A.astype(np.float64)\n        b_64 = b.astype(np.float64)\n        AtA_64 = A_64.T @ A_64\n        Atb_64 = A_64.T @ b_64\n        x_64 = np.linalg.solve(AtA_64, Atb_64)\n        err_64 = np.linalg.norm(x_64 - x_star) / np.linalg.norm(x_star)\n        meas_double_ok = err_64 = tau\n\n        measured_category = get_category(meas_single_ok, meas_double_ok)\n\n        results.append([predicted_category, measured_category])\n\n    # Task 5: Final output format\n    # The format \"[p,m]\" must be produced without spaces.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3540736"}]}