{"hands_on_practices": [{"introduction": "低秩矩阵的基本构成单元是秩为1的外积。深刻理解外积 $uv^T$ 的几何结构，对于掌握低秩近似至关重要。本练习将引导你从第一性原理出发，推导秩为1矩阵的列空间和行空间的正交投影算子，从而加深对外积的代数表示与其几何内涵之间联系的理解。[@problem_id:3563738]", "problem": "设 $m,n \\in \\mathbb{N}$，设 $u \\in \\mathbb{R}^{m}$ 和 $v \\in \\mathbb{R}^{n}$ 为非零向量，并设 $A \\in \\mathbb{R}^{m \\times n}$ 是秩为1的外积 $A = u v^{T}$。在 $\\mathbb{R}^{m}$ 和 $\\mathbb{R}^{n}$ 上使用标准的欧几里得内积。在一个有限维内积空间中，到线性子空间 $S$ 上的正交投影算子是唯一的线性映射 $P$，满足 $P^{2} = P$，$P$ 是自伴的，$\\operatorname{range}(P) = S$，并且对于每个 $y$，向量 $Py$ 是 $S$ 中唯一使到 $y$ 的欧几里得距离最小化的元素。\n\n从这些定义和外积的基本性质出发，完成以下任务：\n- 确定 $\\operatorname{col}(A)$ 和 $\\operatorname{row}(A)$，其中 $\\operatorname{col}(A)$ 是 $\\mathbb{R}^{m}$ 中的列空间，$\\operatorname{row}(A)$ 是 $\\mathbb{R}^{n}$ 中的行空间。\n- 通过定义的最小化性质，从第一性原理推导出到这些子空间上的正交投影算子 $P_{\\operatorname{col}(A)} \\in \\mathbb{R}^{m \\times m}$ 和 $P_{\\operatorname{row}(A)} \\in \\mathbb{R}^{n \\times n}$ 的显式公式，并验证每个这样的投影算子都是对称和幂等的。\n- 仅使用这些性质和基本的矩阵恒等式，计算 $P_{\\operatorname{col}(A)}$ 和 $P_{\\operatorname{row}(A)}$ 的秩和迹。\n\n以单行矩阵的形式提供你的最终答案，其中条目按以下顺序排列：\n$[\\operatorname{rank}(P_{\\operatorname{col}(A)}), \\operatorname{tr}(P_{\\operatorname{col}(A)}), \\operatorname{rank}(P_{\\operatorname{row}(A)}), \\operatorname{tr}(P_{\\operatorname{row}(A)})]$.\n\n不需要四舍五入。不要包含任何单位。最终答案必须是如上指定的单行矩阵。", "solution": "该问题是有效的，因为它是数学上明确定义的、自洽的，并且基于线性代数的标准原理。\n\n首先，我们确定矩阵 $A = u v^{T}$ 的列空间 $\\operatorname{col}(A)$ 和行空间 $\\operatorname{row}(A)$，其中 $u \\in \\mathbb{R}^{m}$ 和 $v \\in \\mathbb{R}^{n}$ 是非零向量。\n\n矩阵 $A$ 由外积 $A = u v^{T}$ 给出。将向量 $v$ 用其分量表示，$v = [v_1, v_2, \\dots, v_n]^T$，则矩阵 $A$ 可以表示为：\n$$\nA = u [v_1, v_2, \\dots, v_n] = [v_1 u, v_2 u, \\dots, v_n u]\n$$\nA 的列是 $a_j = v_j u$，$j = 1, \\dots, n$。每一列都是向量 $u$ 的标量倍。列空间 $\\operatorname{col}(A)$ 是这些列的生成空间。$\\operatorname{col}(A)$ 中的任何向量 $x$ 都可以写成 $A$ 的列的线性组合：\n$$\nx = \\sum_{j=1}^{n} c_j (v_j u) = \\left( \\sum_{j=1}^{n} c_j v_j \\right) u\n$$\n这表明 $\\operatorname{col}(A)$ 中的任何向量都是 $u$ 的标量倍。因此，$\\operatorname{col}(A) \\subseteq \\operatorname{span}(u)$。\n由于 $v$ 是非零向量，至少存在一个分量 $v_k \\neq 0$。$A$ 的第 $k$ 列是 $a_k = v_k u$。由于 $u$ 也是非零向量，所以 $a_k$ 是 $\\operatorname{col}(A)$ 中的一个非零向量。我们可以写出 $u = (1/v_k) a_k$，这表明 $u \\in \\operatorname{col}(A)$。因此，$\\operatorname{span}(u) \\subseteq \\operatorname{col}(A)$。结合这两个包含关系，我们得出结论 $\\operatorname{col}(A) = \\operatorname{span}(u)$。\n\n行空间 $\\operatorname{row}(A)$ 是转置矩阵 $A^T$ 的列空间。\n$$\nA^T = (u v^T)^T = (v^T)^T u^T = v u^T\n$$\n通过相同的论证，$A^T$ 的列都是向量 $v$ 的标量倍。由于 $u \\neq 0$，至少有一列是 $v$ 的非零倍。因此，$A^T$ 的列空间是 $v$ 的生成空间。所以，$\\operatorname{row}(A) = \\operatorname{col}(A^T) = \\operatorname{span}(v)$。\n\n接下来，我们从定义的最小化性质推导出正交投影算子 $P_{\\operatorname{col}(A)}$ 和 $P_{\\operatorname{row}(A)}$ 的显式公式。\n\n对于到 $S = \\operatorname{col}(A) = \\operatorname{span}(u)$ 上的投影算子 $P_{\\operatorname{col}(A)} \\in \\mathbb{R}^{m \\times m}$，我们对任意向量 $y \\in \\mathbb{R}^m$ 寻找唯一的向量 $p \\in S$，使得欧几里得距离 $\\|y - p\\|_2$ 最小。$S$ 中的任意向量 $p$ 都可以写成 $p = c u$ 的形式，其中 $c \\in \\mathbb{R}$ 是某个标量。我们希望找到使平方距离 $f(c) = \\|y - c u\\|_2^2$ 最小化的 $c$ 的值。\n使用内积（点积），其中 $\\langle x, z \\rangle = x^T z$：\n$$\nf(c) = \\langle y - c u, y - c u \\rangle = \\langle y, y \\rangle - 2c \\langle u, y \\rangle + c^2 \\langle u, u \\rangle = \\|y\\|_2^2 - 2c (u^T y) + c^2 (u^T u)\n$$\n这是一个关于 $c$ 的二次函数。为了找到最小值，我们对 $c$ 求导并令导数为零：\n$$\n\\frac{df}{dc} = -2(u^T y) + 2c (u^T u) = 0\n$$\n由于 $u \\neq 0$，其范数的平方 $\\|u\\|_2^2 = u^T u$ 是非零的。我们可以解出 $c$：\n$$\nc = \\frac{u^T y}{u^T u}\n$$\n$y$ 在 $S$ 上的投影是 $p = c u = \\left(\\frac{u^T y}{u^T u}\\right)u$。这可以使用矩阵乘法重写为：\n$$\np = u \\left(\\frac{u^T y}{u^T u}\\right) = \\frac{u(u^T y)}{u^T u} = \\frac{(u u^T)y}{u^T u}\n$$\n投影是一个线性变换 $p = P_{\\operatorname{col}(A)} y$。因此，该投影算子的矩阵表示为：\n$$\nP_{\\operatorname{col}(A)} = \\frac{u u^T}{u^T u}\n$$\n对于到 $S' = \\operatorname{row}(A) = \\operatorname{span}(v)$ 上的投影算子 $P_{\\operatorname{row}(A)} \\in \\mathbb{R}^{n \\times n}$ 的类似推导得出：\n$$\nP_{\\operatorname{row}(A)} = \\frac{v v^T}{v^T v}\n$$\n现在，我们验证这些投影算子是对称的（自伴的）和幂等的（$P^2 = P$）。\n对于 $P_{\\operatorname{col}(A)}$：\n对称性： $P_{\\operatorname{col}(A)}^T = \\left(\\frac{u u^T}{u^T u}\\right)^T = \\frac{(u u^T)^T}{u^T u} = \\frac{(u^T)^T u^T}{u^T u} = \\frac{u u^T}{u^T u} = P_{\\operatorname{col}(A)}$。它是对称的。\n幂等性：\n$$\nP_{\\operatorname{col}(A)}^2 = \\left(\\frac{u u^T}{u^T u}\\right) \\left(\\frac{u u^T}{u^T u}\\right) = \\frac{(u u^T)(u u^T)}{(u^T u)^2} = \\frac{u(u^T u)u^T}{(u^T u)^2}\n$$\n由于 $u^T u$ 是一个标量，它可以交换位置，得到：\n$$\nP_{\\operatorname{col}(A)}^2 = \\frac{(u^T u)(u u^T)}{(u^T u)^2} = \\frac{u u^T}{u^T u} = P_{\\operatorname{col}(A)}\n$$\n它是幂等的。对 $P_{\\operatorname{row}(A)}$ 的验证是相同的，只需将 $u$ 替换为 $v$。\n\n最后，我们计算这些投影算子的秩和迹。\n正交投影算子的秩是它所投影到的子空间的维度。\n$$\n\\operatorname{rank}(P_{\\operatorname{col}(A)}) = \\dim(\\operatorname{col}(A)) = \\dim(\\operatorname{span}(u))\n$$\n由于 $u$ 是一个非零向量，集合 $\\{u\\}$ 是其生成空间的一组基。因此，$\\dim(\\operatorname{span}(u)) = 1$。\n所以，$\\operatorname{rank}(P_{\\operatorname{col}(A)}) = 1$。\n类似地，$\\operatorname{rank}(P_{\\operatorname{row}(A)}) = \\dim(\\operatorname{row}(A)) = \\dim(\\operatorname{span}(v)) = 1$，因为 $v \\neq 0$。\n\n矩阵的迹可以使用性质 $\\operatorname{tr}(XY) = \\operatorname{tr}(YX)$ 来计算。对于 $P_{\\operatorname{col}(A)} \\in \\mathbb{R}^{m \\times m}$：\n$$\n\\operatorname{tr}(P_{\\operatorname{col}(A)}) = \\operatorname{tr}\\left(\\frac{u u^T}{u^T u}\\right) = \\frac{1}{u^T u} \\operatorname{tr}(u u^T)\n$$\n利用循环性质，$\\operatorname{tr}(u u^T) = \\operatorname{tr}(u^T u)$。项 $u^T u$ 是一个 $1 \\times 1$ 矩阵（一个标量），所以它的迹就是标量本身，$\\operatorname{tr}(u^T u) = u^T u$。\n$$\n\\operatorname{tr}(P_{\\operatorname{col}(A)}) = \\frac{1}{u^T u} (u^T u) = 1\n$$\n根据同样的推理，对于 $P_{\\operatorname{row}(A)} \\in \\mathbb{R}^{n \\times n}$：\n$$\n\\operatorname{tr}(P_{\\operatorname{row}(A)}) = \\operatorname{tr}\\left(\\frac{v v^T}{v^T v}\\right) = \\frac{1}{v^T v} \\operatorname{tr}(v^T v) = \\frac{1}{v^T v} (v^T v) = 1\n$$\n这证实了对于任何正交投影算子 $P$，其秩等于其迹的一般性质。\n\n所要求的量是：\n$\\operatorname{rank}(P_{\\operatorname{col}(A)}) = 1$\n$\\operatorname{tr}(P_{\\operatorname{col}(A)}) = 1$\n$\\operatorname{rank}(P_{\\operatorname{row}(A)}) = 1$\n$\\operatorname{tr}(P_{\\operatorname{row}(A)}) = 1$\n将这些数组合成一个单行矩阵，得到 $[1, 1, 1, 1]$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  1  1  1 \\end{pmatrix}}\n$$", "id": "3563738"}, {"introduction": "掌握了低秩矩阵的基本性质后，下一步是将其应用于实际计算中。本练习旨在展示低秩表示的核心计算优势——效率。你将通过实现一个高效算法，来计算两个以因子形式表示的低秩矩阵的乘积，该算法通过操作小规模的因子矩阵，避免了生成大规模的稠密矩阵，从而大幅提升计算速度。[@problem_id:3563735]", "problem": "给定两个矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times p}$，它们以低秩分解的形式 $A = U_A V_A^T$ 和 $B = U_B V_B^T$ 给出，其中 $U_A \\in \\mathbb{R}^{m \\times k_A}$，$V_A \\in \\mathbb{R}^{n \\times k_A}$，$U_B \\in \\mathbb{R}^{n \\times k_B}$ 以及 $V_B \\in \\mathbb{R}^{p \\times k_B}$。请设计一个算法，利用矩阵乘法的结合律，通过恒等式 $A B = U_A \\left(V_A^T U_B\\right) V_B^T$ 来计算 $A B$，而无需显式地构造 $A$ 或 $B$。使用矩阵乘法和结合律的定义，从基本原理出发证明其正确性。仅使用秩的次可乘性不等式 $\\operatorname{rank}(X Y) \\le \\min\\{\\operatorname{rank}(X), \\operatorname{rank}(Y)\\}$ 以及矩形矩阵乘积的秩的定义，推导出 $A B$ 的秩关于 $k_A$ 和 $k_B$ 的一个界。提供一个清晰的论证，说明 $\\operatorname{rank}(A B) \\le \\min(k_A, k_B)$。\n\n您的程序必须：\n- 实现该算法，仅使用低秩因子，通过 $U_A \\left(V_A^T U_B\\right) V_B^T$ 计算 $A B$。\n- 为了验证，也通过首先构造 $A = U_A V_A^T$ 和 $B = U_B V_B^T$ 然后将它们相乘的朴素方法计算 $A B$。\n- 计算两种结果之差的弗罗贝尼乌斯范数，即 $\\lVert A B_{\\text{fast}} - A B_{\\text{naive}} \\rVert_F$。\n- 使用奇异值分解计算 $A B$ 的数值秩，容差为 $\\tau = \\max\\{m, p\\} \\, \\epsilon \\, \\sigma_{\\max}$，其中 $\\epsilon$ 是双精度浮点数的机器精度，$\\sigma_{\\max}$ 是 $A B$ 的最大奇异值。数值秩是严格大于 $\\tau$ 的奇异值的数量。\n- 对于每个测试用例，返回一个四元组，包含：弗罗贝尼乌斯误差（浮点数）、$A B$ 的数值秩（整数）、界 $\\min(k_A, k_B)$（整数）以及一个布尔值，指示不等式 $\\operatorname{rank}(A B) \\le \\min(k_A, k_B)$ 是否成立。\n\n您的推导应仅基于：\n- 矩阵乘法和结合律的定义。\n- 将低秩矩阵表示为外积之和。\n- 不等式 $\\operatorname{rank}(X Y) \\le \\min\\{\\operatorname{rank}(X), \\operatorname{rank}(Y)\\}$。\n- 使用奇异值分解的数值秩定义。\n\n您的程序必须是自包含的，并且不使用任何输入。请使用以下测试套件，其中定义了 $U_A, V_A, U_B, V_B$ 的维度和构造方法：\n- 测试用例1（通用情况）：$m=7, n=5, p=6, k_A=3, k_B=2$。使用随机种子 $0$ 构造 $U_A, V_A, U_B, V_B$，其元素为独立的标准正态分布。\n- 测试用例2（秩为1的因子）：$m=8, n=4, p=3, k_A=1, k_B=1$。使用随机种子 $1$ 构造 $U_A, V_A, U_B, V_B$，其元素为独立的标准正态分布。\n- 测试用例3（通过正交性得到零积）：$m=6, n=4, p=5, k_A=2, k_B=2$。使用随机种子 $2$ 构造 $U_A$ 和 $V_B$，其元素为独立的标准正态分布。构造 $U_B \\in \\mathbb{R}^{n \\times k_B}$，其元素为独立的标准正态分布且列满秩。设 $Q \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其前 $k_B$ 列张成 $U_B$ 的列空间（例如，通过完全QR分解得到）。设置 $V_A = Q[:, k_B:(k_B+k_A)]$，从而通过构造使得 $V_A^T U_B = 0$ 且因此 $A B = 0$。\n- 测试用例4（通用情况，$k_A  k_B$）：$m=5, n=5, p=5, k_A=4, k_B=3$。使用随机种子 $3$ 构造 $U_A, V_A, U_B, V_B$，其元素为独立的标准正态分布。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $e_i = \\lVert A B_{\\text{fast}} - A B_{\\text{naive}} \\rVert_F$，\n- $r_i = \\operatorname{rank}_{\\text{num}}(A B)$，在指定的容差下，\n- $b_i = \\min(k_A, k_B)$，\n- $q_i =$ 谓词 $r_i \\le b_i$ 的布尔值。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。\n- 该列表必须是 $[e_1, r_1, b_1, q_1, e_2, r_2, b_2, q_2, e_3, r_3, b_3, q_3, e_4, r_4, b_4, q_4]$ 的拼接。\n- 所有浮点值必须以标准的Python格式打印；不需要特殊舍入。\n- 此问题不涉及物理单位、角度或百分比。", "solution": "该问题要求设计并验证一个高效算法，用于乘以两个以低秩分解形式给出的矩阵 $A$ 和 $B$。我们必须证明算法的正确性，推导乘积矩阵 $A B$ 的秩的界，并实现该算法进行数值验证。\n\n### 算法的正确性\n\n给定两个矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times p}$ 及其各自的低秩分解：\n$$\nA = U_A V_A^T \\quad \\text{其中 } U_A \\in \\mathbb{R}^{m \\times k_A}, V_A \\in \\mathbb{R}^{n \\times k_A}\n$$\n$$\nB = U_B V_B^T \\quad \\text{其中 } U_B \\in \\mathbb{R}^{n \\times k_B}, V_B \\in \\mathbb{R}^{p \\times k_B}\n$$\n通过代入这些分解，乘积 $A B$ 可以写作：\n$$\nA B = (U_A V_A^T) (U_B V_B^T)\n$$\n矩阵乘法是可结合的，这是一个基本性质，它指出对于任意三个可相乘的矩阵 $X, Y, Z$，等式 $(XY)Z = X(YZ)$ 成立。我们可以将此性质应用于四个矩阵的乘积 $U_A V_A^T U_B V_B^T$。我们可以按如下方式对矩阵进行分组：\n$$\nA B = (U_A V_A^T) (U_B V_B^T) = U_A (V_A^T U_B V_B^T) = U_A (V_A^T U_B) V_B^T\n$$\n这证实了所提出算法的正确性，该算法通过首先计算中心的、较小的矩阵乘积 $C = V_A^T U_B$，然后计算 $A B = U_A C V_B^T$ 来得到最终结果。\n\n相关矩阵的维度为：$U_A \\in \\mathbb{R}^{m \\times k_A}$，$V_A^T \\in \\mathbb{R}^{k_A \\times n}$，$U_B \\in \\mathbb{R}^{n \\times k_B}$ 以及 $V_B^T \\in \\mathbb{R}^{k_B \\times p}$。\n朴素方法首先构造完整的矩阵 $A$（需要 $O(mnk_A)$ 次运算）和 $B$（需要 $O(npk_B)$ 次运算），然后将它们相乘（需要 $O(mnp)$ 次运算）。当维度较大时，总复杂度主要由 $O(mnp)$ 决定。\n所提出的“快速”算法计算过程如下：\n$1$. $C = V_A^T U_B$。这是一个 $(k_A \\times n) \\times (n \\times k_B)$ 的乘积，得到一个 $k_A \\times k_B$ 的矩阵，需要 $O(k_A n k_B)$ 次运算。\n$2$. $D = U_A C$。这是一个 $(m \\times k_A) \\times (k_A \\times k_B)$ 的乘积，得到一个 $m \\times k_B$ 的矩阵，需要 $O(m k_A k_B)$ 次运算。\n$3$. $AB = D V_B^T$。这是一个 $(m \\times k_B) \\times (k_B \\times p)$ 的乘积，需要 $O(m k_B p)$ 次运算。\n总复杂度为 $O(k_A n k_B + m k_A k_B + m k_B p)$。当秩 $k_A$ 和 $k_B$ 远小于矩阵维度 $m, n, p$ 时，这种方法比朴素方法效率高得多。\n\n### 秩界的推导\n\n我们的任务是使用秩的次可乘性性质 $\\operatorname{rank}(XY) \\le \\min\\{\\operatorname{rank}(X), \\operatorname{rank}(Y)\\}$ 和秩的定义来证明 $\\operatorname{rank}(A B) \\le \\min(k_A, k_B)$。\n\n矩阵的秩是其列空间的维度。矩阵乘积 $XY$ 的列空间是 $X$ 的列空间的一个子空间，即 $\\operatorname{Col}(XY) \\subseteq \\operatorname{Col}(X)$。这直接意味着 $\\operatorname{rank}(XY) \\le \\operatorname{rank}(X)$。\n\n考虑矩阵 $A = U_A V_A^T$。$A$ 的列是 $U_A$ 的列的线性组合。因此，$A$ 的列空间是 $U_A$ 的列空间的一个子空间。\n$$\n\\operatorname{Col}(A) \\subseteq \\operatorname{Col}(U_A)\n$$\n这意味着 $\\operatorname{Col}(A)$ 的维度最多是 $\\operatorname{Col}(U_A)$ 的维度。\n$$\n\\operatorname{rank}(A) \\le \\operatorname{rank}(U_A)\n$$\n矩阵 $U_A \\in \\mathbb{R}^{m \\times k_A}$ 有 $k_A$ 列。由这些列张成的空间维度最多为 $k_A$。因此，$\\operatorname{rank}(U_A) \\le k_A$。\n结合这些，我们得到：\n$$\n\\operatorname{rank}(A) \\le k_A\n$$\n这也可以通过将 $A$ 视为 $k_A$ 个秩为1的矩阵（外积）之和来理解，即 $A = \\sum_{i=1}^{k_A} u_i v_i^T$，其中 $u_i$ 和 $v_i$ 分别是 $U_A$ 和 $V_A$ 的列。矩阵和的秩最多是它们秩的和，所以 $\\operatorname{rank}(A) \\le \\sum_{i=1}^{k_A} \\operatorname{rank}(u_i v_i^T) = \\sum_{i=1}^{k_A} 1 = k_A$。\n\n对于矩阵 $B = U_B V_B^T$，其中 $U_B \\in \\mathbb{R}^{n \\times k_B}$，通过同样的推理，我们有：\n$$\n\\operatorname{rank}(B) \\le \\operatorname{rank}(U_B) \\le k_B\n$$\n现在，我们将给定的秩的次可乘性不等式应用于乘积 $A B$：\n$$\n\\operatorname{rank}(A B) \\le \\min\\{\\operatorname{rank}(A), \\operatorname{rank}(B)\\}\n$$\n代入我们为 $\\operatorname{rank}(A)$ 和 $\\operatorname{rank}(B)$ 推导出的界：\n$$\n\\operatorname{rank}(A B) \\le \\min\\{k_A, k_B\\}\n$$\n推导至此完成。\n\n### 数值秩的计算\n\n矩阵的数值秩通过其奇异值分解（SVD）确定。对于一个矩阵 $C \\in \\mathbb{R}^{m \\times p}$，其奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$，数值秩是大于指定容差 $\\tau$ 的奇异值的数量。问题将此容差定义为：\n$$\n\\tau = \\max\\{m, p\\} \\cdot \\epsilon \\cdot \\sigma_{\\max}\n$$\n其中 $\\sigma_{\\max} = \\sigma_1$ 是 $C$ 的最大奇异值，$\\epsilon$ 是双精度浮点数的机器精度。数值秩 $r$ 随后被计算为满足 $\\sigma_i  \\tau$ 的索引 $i$ 的数量。这个过程提供了一种在存在浮点误差时稳健估计矩阵有效秩的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _process_case(m, n, p, k_A, k_B, seed, special_case_3=False):\n    \"\"\"\n    Generates matrices for a test case, computes the product AB via two methods,\n    and returns the required analysis quadruple.\n    \n    Args:\n        m, n, p (int): Dimensions of matrices A (m,n) and B (n,p).\n        k_A, k_B (int): Ranks of the low-rank factors.\n        seed (int): Random seed for reproducibility.\n        special_case_3 (bool): Flag to trigger special construction for Test Case 3.\n        \n    Returns:\n        tuple: (error, num_rank, rank_bound, inequality_holds)\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Construct the low-rank factors U_A, V_A, U_B, V_B\n    if not special_case_3:\n        U_A = rng.standard_normal(size=(m, k_A))\n        V_A = rng.standard_normal(size=(n, k_A))\n        U_B = rng.standard_normal(size=(n, k_B))\n        V_B = rng.standard_normal(size=(p, k_B))\n    else:\n        # Special construction for Test Case 3 to ensure V_A.T @ U_B = 0.\n        U_A = rng.standard_normal(size=(m, k_A))\n        V_B = rng.standard_normal(size=(p, k_B))\n        U_B = rng.standard_normal(size=(n, k_B))\n        \n        # Use complete QR decomposition of U_B to find an orthogonal basis for R^n.\n        # np.linalg.qr with mode='complete' returns a square orthogonal matrix Q.\n        # The first k_B columns of Q form an orthonormal basis for Col(U_B).\n        if n  k_B:\n             # This scenario won't occur with test data but is a safeguard.\n             # To perform QR on U_B, U_B needs to be full rank, n>=k_B\n             U_B = U_B[:, :n]\n             \n        Q, _ = np.linalg.qr(U_B, mode='complete')\n        \n        # V_A's columns are chosen from the orthogonal complement of Col(U_B).\n        # This ensures the columns of V_A are orthogonal to columns of U_B.\n        if n  k_B + k_A:\n            # This case should not happen with the given test parameters.\n            raise ValueError(\n                f\"Cannot construct V_A for special case 3: n={n} must be >= k_A+k_B={k_A+k_B}\"\n            )\n        V_A = Q[:, k_B : k_B + k_A]\n\n    # Fast computation: AB_fast = U_A @ (V_A.T @ U_B) @ V_B.T\n    intermediate_product = V_A.T @ U_B\n    AB_fast = U_A @ intermediate_product @ V_B.T\n\n    # Naive computation: AB_naive = (U_A @ V_A.T) @ (U_B @ V_B.T)\n    A = U_A @ V_A.T\n    B = U_B @ V_B.T\n    AB_naive = A @ B\n\n    # 1. Compute Frobenius norm of the difference\n    e = np.linalg.norm(AB_fast - AB_naive, 'fro')\n\n    # 2. Compute the numerical rank of AB\n    singular_values = np.linalg.svd(AB_fast, compute_uv=False)\n    \n    sigma_max = 0.0\n    if singular_values.size > 0:\n        sigma_max = singular_values[0]\n\n    epsilon = np.finfo(float).eps\n    tolerance = max(m, p) * epsilon * sigma_max\n    \n    r = np.sum(singular_values > tolerance)\n\n    # 3. Compute the rank bound\n    b = min(k_A, k_B)\n\n    # 4. Check if the inequality rank(AB) = min(k_A, k_B) holds\n    q = (r = b)\n\n    return e, r, b, q\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (m, n, p, k_A, k_B, seed, special_case_3)\n        (7, 5, 6, 3, 2, 0, False),  # Test case 1\n        (8, 4, 3, 1, 1, 1, False),  # Test case 2\n        (6, 4, 5, 2, 2, 2, True),   # Test case 3\n        (5, 5, 5, 4, 3, 3, False),  # Test case 4\n    ]\n\n    results = []\n    for params in test_cases:\n        m, n, p, k_A, k_B, seed, special = params\n        result_tuple = _process_case(m, n, p, k_A, k_B, seed, special)\n        results.extend(list(result_tuple))\n\n    # Format the final output string as per requirements.\n    # The boolean values are converted to their string representations ('True'/'False').\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3563735"}, {"introduction": "接下来，我们探讨一个更高级也更精妙的主题：低秩近似算法的局限性。虽然奇异值分解（SVD）提供了理论上最优的低秩近似，但在实际应用中，人们常使用更快的贪心启发式算法。本练习通过一个精心设计的思想实验，构造了一个特殊的矩阵，它揭示了为何简单的贪心策略（如最大体积法）可能会导致与最优解相去甚远的近似结果，从而强调了理解算法局限性的重要性。[@problem_id:3563748]", "problem": "考虑以下构造，该构造旨在探讨由最大体积启发式算法驱动的交叉/骨架近似的局限性。令 $n \\geq 3$ 为一个整数，并定义向量 $u \\in \\mathbb{R}^{n}$ 和 $v \\in \\mathbb{R}^{n}$ 如下：\n$$\nu \\;=\\; \\frac{1}{\\sqrt{n-1}}\\begin{pmatrix}0 \\\\ 1 \\\\ \\vdots \\\\ 1\\end{pmatrix}, \n\\qquad\nv \\;=\\; \\frac{1}{\\sqrt{n-1}}\\begin{pmatrix}1 \\\\ \\vdots \\\\ 1 \\\\ 0\\end{pmatrix},\n$$\n使得 $u$ 的第一个分量为零，$v$ 的第 $n$ 个分量为零，所有其他分量等于 $1/\\sqrt{n-1}$。令 $e_{1}, e_{n} \\in \\mathbb{R}^{n}$ 分别表示第一个和第 $n$ 个标准基向量。对于满足以下条件的标量 $s0$ 和 $t0$：\n$$\ns \\;\\; t \\;\\; \\frac{s}{\\,n-1\\,},\n$$\n定义矩阵\n$$\nA \\;=\\; s\\,u\\,v^{\\top} \\;+\\; t\\,e_{1}\\,e_{n}^{\\top} \\;\\in\\; \\mathbb{R}^{n \\times n}.\n$$\n假设通过最大体积启发式算法选择一行和一列来构造一个交叉/骨架秩-1近似，对于 $1 \\times 1$ 子矩阵，该算法简化为选择 $A$ 中绝对值最大的元素。令 $(i^{\\star}, j^{\\star})$ 表示该元素的索引，骨架近似为\n$$\n\\widetilde{A} \\;=\\; A(:, j^{\\star})\\,\\big(A(i^{\\star}, j^{\\star})\\big)^{-1}\\,A(i^{\\star}, :),\n$$\n其中 $A(:, j)$ 表示 $A$ 的第 $j$ 列，$A(i, :)$ 表示 $A$ 的第 $i$ 行。令 $A_{1}$ 表示在算子范数（谱范数）下 $A$ 的最佳秩-1近似，这可以通过奇异值分解（SVD）理论来理解，而无需在问题陈述中使用任何显式公式。\n\n从外积、算子范数和奇异值分解（SVD）的基本定义出发，并仅使用上面提供的构造，确定误差膨胀因子\n$$\n\\mathcal{E}(n,s,t) \\;=\\; \\frac{\\|A - \\widetilde{A}\\|_{2}}{\\|A - A_{1}\\|_{2}},\n$$\n以 $s$ 和 $t$ 的闭式表达式表示。您的最终答案必须是单个解析表达式。最终答案中请勿提供任何不等式或中间方程。不需要四舍五入或数值计算。", "solution": "我们首先分析矩阵 $A = s\\,u\\,v^{\\top} + t\\,e_{1}\\,e_{n}^{\\top}$ 的结构。根据构造，$u$ 和 $e_{1}$ 是正交的，因为 $u$ 的第一个分量为 $0$，而 $e_{1}$ 除了第一个分量外所有分量都为零。类似地，$v$ 和 $e_{n}$ 是正交的，因为 $v$ 的第 $n$ 个分量为 $0$，而 $e_{n}$ 除了第 $n$ 个分量外所有分量都为零。此外，$u$ 和 $v$ 都是单位向量，因为它们各有 $(n-1)$ 个分量等于 $1/\\sqrt{n-1}$，一个分量等于 $0$，所以 $\\|u\\|_{2} = \\|v\\|_{2} = 1$。同样地，$\\|e_{1}\\|_{2} = \\|e_{n}\\|_{2} = 1$。\n\n矩阵 $A$ 因此是两个秩-1外积的和，其左奇异向量是正交的（$u \\perp e_{1}$），右奇异向量也是正交的（$v \\perp e_{n}$）。这种正交性意味着 $A$ 的奇异值恰好是每一项各自的奇异值，即 $s$ 和 $t$，其余 $n-2$ 个奇异值为零。这一点可以通过考虑 $\\mathbb{R}^{n}$ 的左空间和右空间的正交基来证明，这些基分别以 $\\{u, e_{1}\\}$ 和 $\\{v, e_{n}\\}$ 开始，并扩展为完整的正交基。在这些基中，$A$ 的作用如下：\n$$\nA\\,v = s\\,u, \\qquad A\\,e_{n} = t\\,e_{1},\n$$\n并将与 $\\operatorname{span}\\{v, e_{n}\\}$ 正交的向量映射到零向量。因此，$A$ 的两个非零奇异值为 $s$ 和 $t$。\n\n接下来，我们考察用于 $1 \\times 1$ 子矩阵的最大体积启发式算法，该算法选择 $A$ 中绝对值最大的元素。由 $s\\,u\\,v^{\\top}$ 项产生的 $A$ 的元素为\n$$\n(s\\,u\\,v^{\\top})_{ij} \\;=\\; s\\,u_{i}\\,v_{j} \\;=\\; \n\\begin{cases}\n\\displaystyle \\frac{s}{n-1},   \\text{if } i \\geq 2 \\text{ and } j \\leq n-1, \\\\[6pt]\n0,   \\text{if } i = 1 \\text{ or } j = n.\n\\end{cases}\n$$\n由 $t\\,e_{1}\\,e_{n}^{\\top}$ 项产生的 $A$ 的元素，除了在 $(1,n)$ 处 $A_{1n} = t$ 外，其余都为零。因此，只要 $t  s/(n-1)$，$A$ 中绝对值最大的元素就位于 $(1,n)$，这由假设的不等式 $s  t  s/(n-1)$ 所保证。因此，最大体积启发式算法选择 $(i^{\\star}, j^{\\star}) = (1,n)$。\n\n由 $(i^{\\star}, j^{\\star}) = (1,n)$ 构造的骨架近似为\n$$\n\\widetilde{A} \\;=\\; A(:, n)\\,\\big(A(1, n)\\big)^{-1}\\,A(1, :) .\n$$\n我们显式地计算这些因子。由于 $v_{n} = 0$，列 $A(:, n)$ 不受 $s\\,u\\,v^{\\top}$ 的影响，唯一的贡献来自 $t\\,e_{1}\\,e_{n}^{\\top}$：\n$$\nA(:, n) \\;=\\; t\\,e_{1}.\n$$\n类似地，由于 $u_{1} = 0$，行 $A(1, :)$ 不受 $s\\,u\\,v^{\\top}$ 的影响，唯一的贡献来自 $t\\,e_{1}\\,e_{n}^{\\top}$：\n$$\nA(1, :) \\;=\\; t\\,e_{n}^{\\top}.\n$$\n并且，$A(1, n) = t$。因此，\n$$\n\\widetilde{A} \\;=\\; \\big(t\\,e_{1}\\big)\\,\\frac{1}{t}\\,\\big(t\\,e_{n}^{\\top}\\big) \\;=\\; t\\,e_{1}\\,e_{n}^{\\top}.\n$$\n我们看到，交叉/骨架近似精确地复现了尖峰分量 $t\\,e_{1}\\,e_{n}^{\\top}$，而丢弃了占主导地位的低秩分量 $s\\,u\\,v^{\\top}$。因此，近似误差为\n$$\nA - \\widetilde{A} \\;=\\; s\\,u\\,v^{\\top}.\n$$\n其算子范数等于 $s\\,u\\,v^{\\top}$ 的奇异值，即 $s$，因为 $\\|u\\|_{2} = \\|v\\|_{2} = 1$ 且秩-1外积 $s\\,u\\,v^{\\top}$ 的算子范数为 $s$。\n\n现在考虑算子范数下的最佳秩-1近似 $A_{1}$。由于 $A$ 的奇异值为 $s$ 和 $t$ 且 $s  t$，最佳秩-1近似是通过保留奇异值 $s$ 及其对应的奇异向量得到的，并且算子范数下的最优误差等于下一个奇异值，即 $t$。因此，\n$$\n\\|A - A_{1}\\|_{2} \\;=\\; t.\n$$\n最后，误差膨胀因子为\n$$\n\\mathcal{E}(n,s,t) \\;=\\; \\frac{\\|A - \\widetilde{A}\\|_{2}}{\\|A - A_{1}\\|_{2}} \\;=\\; \\frac{s}{t}.\n$$\n通过任意大地选择 $s/t$（受约束 $t  s/(n-1)$ 的限制），这个因子可以变得任意大；例如，对于固定的 $t$，取足够大的 $n$ 允许 $s$ 增长，同时保持 $t  s/(n-1)$。因此，所要求的闭式表达式为 $\\mathcal{E}(n,s,t) = s/t$。", "answer": "$$\\boxed{\\frac{s}{t}}$$", "id": "3563748"}]}