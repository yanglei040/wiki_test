{"hands_on_practices": [{"introduction": "预处理GMRES方法的核心在于Arnoldi过程，该过程为预处理后的算子生成的Krylov子空间构建了一个标准正交基。通过亲手执行该过程的最初几个步骤，你可以深入了解算法的内部机制。这个练习将引导你为一个右预处理系统具体计算基向量和Hessenberg矩阵，从而巩固你对预处理如何改变算子以及投影如何构建的理解。[@problem_id:3593935]", "problem": "考虑应用于线性系统 $A x = b$ 的带右预处理的广义最小残差（GMRES）方法，其中预处理器 $M$ 是非奇异的。右预处理将算子转换为 $\\tilde{A} = A M^{-1}$，未知数转换为 $y = M x$，因此 Krylov 子空间是为 $\\tilde{A}$ 作用于初始残差 $r_0 = b - A x_0$ 而构建的。Arnoldi 过程为 Krylov 子空间 $\\mathcal{K}_k(\\tilde{A}, r_0)$ 构建一个标准正交基 $\\{v_1, v_2, \\dots\\}$，并生成一个上 Hessenberg 矩阵 $\\bar{H}_k \\in \\mathbb{R}^{(k+1) \\times k}$，该矩阵捕捉了 $\\tilde{A}$ 在所生成子空间上的投影。\n\n令\n$$\nA = \\begin{pmatrix}\n2  1  0 \\\\\n0  3  1 \\\\\n0  0  4\n\\end{pmatrix}, \\quad\nM = \\begin{pmatrix}\n1  0  0 \\\\\n0  2  0 \\\\\n0  0  1\n\\end{pmatrix}, \\quad\nb = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nx_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n从 $r_0 = b - A x_0$ 和 $v_1 = r_0 / \\|r_0\\|$ 开始，对右预处理算子 $\\tilde{A} = A M^{-1}$ 执行正好两步 Arnoldi 过程。计算标准正交基向量 $v_1$、$v_2$ 和 $v_3$，以及上 Hessenberg 矩阵\n$$\n\\bar{H}_2 = \\begin{pmatrix}\nh_{11}  h_{12} \\\\\nh_{21}  h_{22} \\\\\n0  h_{32}\n\\end{pmatrix}\n$$\n满足 $\\tilde{A} V_2 = V_3 \\bar{H}_2$，其中 $V_2 = [v_1 \\; v_2]$ 且 $V_3 = [v_1 \\; v_2 \\; v_3]$。\n\n报告次对角线系数 $h_{32}$ 的精确值作为您的最终答案。请精确表达您报告的值；不允许四舍五入。", "solution": "用户提供的问题是数值线性代数中一个适定问题，并被验证为合理且可解。任务是为一个右预处理的线性系统执行两步 Arnoldi 过程，并确定所得到的上 Hessenberg 矩阵中的一个特定元素 $h_{32}$。\n\n首先，我们定义问题的各个组成部分。线性系统为 $A x = b$，带有右预处理器 $M$。GMRES 算法将应用于等价系统 $\\tilde{A} y = b$，其中 $\\tilde{A} = A M^{-1}$ 且 $y = M x$。\n\n给定的矩阵和向量为：\n$$\nA = \\begin{pmatrix}\n2  1  0 \\\\\n0  3  1 \\\\\n0  0  4\n\\end{pmatrix}, \\quad\nM = \\begin{pmatrix}\n1  0  0 \\\\\n0  2  0 \\\\\n0  0  1\n\\end{pmatrix}, \\quad\nb = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nx_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n预处理器 $M$ 是一个对角矩阵，因此其逆矩阵 $M^{-1}$ 可以通过取其对角线元素的倒数得到：\n$$\nM^{-1} = \\begin{pmatrix}\n1^{-1}  0  0 \\\\\n0  2^{-1}  0 \\\\\n0  0  1^{-1}\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  \\frac{1}{2}  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n现在，我们计算预处理后的矩阵 $\\tilde{A} = A M^{-1}$：\n$$\n\\tilde{A} = \\begin{pmatrix}\n2  1  0 \\\\\n0  3  1 \\\\\n0  0  4\n\\end{pmatrix}\n\\begin{pmatrix}\n1  0  0 \\\\\n0  \\frac{1}{2}  0 \\\\\n0  0  1\n\\end{pmatrix} =\n\\begin{pmatrix}\n(2)(1)  (1)(\\frac{1}{2})  (0)(1) \\\\\n(0)(1)  (3)(\\frac{1}{2})  (1)(1) \\\\\n(0)(1)  (0)(\\frac{1}{2})  (4)(1)\n\\end{pmatrix} =\n\\begin{pmatrix}\n2  \\frac{1}{2}  0 \\\\\n0  \\frac{3}{2}  1 \\\\\n0  0  4\n\\end{pmatrix}\n$$\nArnoldi 过程从初始残差 $r_0$ 开始。\n$$\nr_0 = b - A x_0 = b - A \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = b = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}\n$$\n第一个基向量 $v_1$ 是归一化的初始残差。\n$$\n\\|r_0\\|_2 = \\sqrt{1^2 + 1^2 + 1^2} = \\sqrt{3}\n$$\n$$\nv_1 = \\frac{r_0}{\\|r_0\\|_2} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}\n$$\nArnoldi 过程迭代地为 Krylov 子空间 $\\mathcal{K}_k(\\tilde{A}, r_0)$ 构建一个标准正交基 $\\{v_1, v_2, \\dots\\}$ 和一个 Hessenberg 矩阵 $\\bar{H}_k$。它们之间的关系是 $\\tilde{A} V_k = V_{k+1} \\bar{H}_k$。\n\n**Arnoldi 过程第 1 步：**\n我们计算 $w = \\tilde{A} v_1$。\n$$\nw = \\begin{pmatrix}\n2  \\frac{1}{2}  0 \\\\\n0  \\frac{3}{2}  1 \\\\\n0  0  4\n\\end{pmatrix}\n\\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\right)\n= \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 2 + \\frac{1}{2} \\\\ \\frac{3}{2} + 1 \\\\ 4 \\end{pmatrix}\n= \\frac{1}{\\sqrt{3}} \\begin{pmatrix} \\frac{5}{2} \\\\ \\frac{5}{2} \\\\ 4 \\end{pmatrix}\n$$\n接下来，我们将 $w$ 投影到现有的基向量 $v_1$ 上。系数为 $h_{11}$。\n$$\nh_{11} = v_1^T w = \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1  1  1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} \\frac{5}{2} \\\\ \\frac{5}{2} \\\\ 4 \\end{pmatrix} \\right)\n= \\frac{1}{3} \\left( \\frac{5}{2} + \\frac{5}{2} + 4 \\right) = \\frac{1}{3} (5 + 4) = \\frac{9}{3} = 3\n$$\n我们计算 $w$ 正交于 $v_1$ 的分量。令其为 $\\hat{v}_2$。\n$$\n\\hat{v}_2 = w - h_{11} v_1 = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} \\frac{5}{2} \\\\ \\frac{5}{2} \\\\ 4 \\end{pmatrix} - 3 \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\right)\n= \\frac{1}{\\sqrt{3}} \\left( \\begin{pmatrix} \\frac{5}{2} \\\\ \\frac{5}{2} \\\\ 4 \\end{pmatrix} - \\begin{pmatrix} 3 \\\\ 3 \\\\ 3 \\end{pmatrix} \\right)\n= \\frac{1}{\\sqrt{3}} \\begin{pmatrix} -\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix}\n$$\nHessenberg 矩阵的下一个元素是 $h_{21} = \\|\\hat{v}_2\\|_2$。\n$$\nh_{21} = \\left\\| \\frac{1}{\\sqrt{3}} \\begin{pmatrix} -\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix} \\right\\|_2\n= \\frac{1}{\\sqrt{3}} \\sqrt{\\left(-\\frac{1}{2}\\right)^2 + \\left(-\\frac{1}{2}\\right)^2 + 1^2}\n= \\frac{1}{\\sqrt{3}} \\sqrt{\\frac{1}{4} + \\frac{1}{4} + 1} = \\frac{1}{\\sqrt{3}} \\sqrt{\\frac{3}{2}} = \\sqrt{\\frac{1}{2}} = \\frac{1}{\\sqrt{2}}\n$$\n第二个基向量是 $v_2 = \\hat{v}_2 / h_{21}$。\n$$\nv_2 = \\frac{\\frac{1}{\\sqrt{3}} \\begin{pmatrix} -\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix}}{\\frac{1}{\\sqrt{2}}}\n= \\frac{\\sqrt{2}}{\\sqrt{3}} \\begin{pmatrix} -\\frac{1}{2} \\\\ -\\frac{1}{2} \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -1 \\\\ -1 \\\\ 2 \\end{pmatrix}\n$$\n\n**Arnoldi 过程第 2 步：**\n我们计算 $w = \\tilde{A} v_2$。\n$$\nw = \\begin{pmatrix}\n2  \\frac{1}{2}  0 \\\\\n0  \\frac{3}{2}  1 \\\\\n0  0  4\n\\end{pmatrix}\n\\left( \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -1 \\\\ -1 \\\\ 2 \\end{pmatrix} \\right)\n= \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -2 - \\frac{1}{2} \\\\ -\\frac{3}{2} + 2 \\\\ 8 \\end{pmatrix}\n= \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{5}{2} \\\\ \\frac{1}{2} \\\\ 8 \\end{pmatrix}\n$$\n我们将 $w$ 投影到基 $\\{v_1, v_2\\}$ 上以求得 $h_{12}$ 和 $h_{22}$。\n$$\nh_{12} = v_1^T w = \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1  1  1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{5}{2} \\\\ \\frac{1}{2} \\\\ 8 \\end{pmatrix} \\right)\n= \\frac{1}{\\sqrt{18}} \\left( -\\frac{5}{2} + \\frac{1}{2} + 8 \\right) = \\frac{1}{3\\sqrt{2}} (-2 + 8) = \\frac{6}{3\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}\n$$\n$$\nh_{22} = v_2^T w = \\left( \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -1  -1  2 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{5}{2} \\\\ \\frac{1}{2} \\\\ 8 \\end{pmatrix} \\right)\n= \\frac{1}{6} \\left( (-1)(-\\frac{5}{2}) + (-1)(\\frac{1}{2}) + (2)(8) \\right)\n= \\frac{1}{6} \\left( \\frac{5}{2} - \\frac{1}{2} + 16 \\right) = \\frac{1}{6} (2 + 16) = \\frac{18}{6} = 3\n$$\n我们计算 $w$ 正交于 $\\{v_1, v_2\\}$ 生成的子空间的分量。令其为 $\\hat{v}_3$。\n$$\n\\hat{v}_3 = w - h_{12} v_1 - h_{22} v_2\n$$\n$$\n\\hat{v}_3 = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{5}{2} \\\\ \\frac{1}{2} \\\\ 8 \\end{pmatrix} - \\sqrt{2} \\left( \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\right) - 3 \\left( \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -1 \\\\ -1 \\\\ 2 \\end{pmatrix} \\right)\n$$\n为简化计算，我们将所有项写成以 $\\sqrt{6}$ 为公分母。注意 $\\frac{\\sqrt{2}}{\\sqrt{3}} = \\frac{\\sqrt{2}\\sqrt{2}}{\\sqrt{3}\\sqrt{2}} = \\frac{2}{\\sqrt{6}}$。\n$$\n\\hat{v}_3 = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{5}{2} \\\\ \\frac{1}{2} \\\\ 8 \\end{pmatrix} - \\frac{2}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{3}{\\sqrt{6}} \\begin{pmatrix} -1 \\\\ -1 \\\\ 2 \\end{pmatrix}\n$$\n$$\n\\hat{v}_3 = \\frac{1}{\\sqrt{6}} \\left[ \\begin{pmatrix} -\\frac{5}{2} \\\\ \\frac{1}{2} \\\\ 8 \\end{pmatrix} - \\begin{pmatrix} 2 \\\\ 2 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} -3 \\\\ -3 \\\\ 6 \\end{pmatrix} \\right]\n= \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{5}{2} - 2 + 3 \\\\ \\frac{1}{2} - 2 + 3 \\\\ 8 - 2 - 6 \\end{pmatrix}\n= \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{3}{2} \\\\ \\frac{3}{2} \\\\ 0 \\end{pmatrix}\n$$\n问题要求的是 $h_{32}$ 的值，即这个向量的范数。\n$$\nh_{32} = \\|\\hat{v}_3\\|_2 = \\left\\| \\frac{1}{\\sqrt{6}} \\begin{pmatrix} -\\frac{3}{2} \\\\ \\frac{3}{2} \\\\ 0 \\end{pmatrix} \\right\\|_2\n= \\frac{1}{\\sqrt{6}} \\sqrt{\\left(-\\frac{3}{2}\\right)^2 + \\left(\\frac{3}{2}\\right)^2 + 0^2}\n= \\frac{1}{\\sqrt{6}} \\sqrt{\\frac{9}{4} + \\frac{9}{4}}\n= \\frac{1}{\\sqrt{6}} \\sqrt{\\frac{18}{4}}\n= \\frac{1}{\\sqrt{6}} \\frac{\\sqrt{18}}{\\sqrt{4}}\n= \\frac{1}{\\sqrt{6}} \\frac{3\\sqrt{2}}{2}\n= \\frac{3\\sqrt{2}}{2\\sqrt{6}} = \\frac{3\\sqrt{2}}{2\\sqrt{2}\\sqrt{3}}\n= \\frac{3}{2\\sqrt{3}} = \\frac{3\\sqrt{3}}{2 \\cdot 3} = \\frac{\\sqrt{3}}{2}\n$$\n因此，次对角线系数 $h_{32}$ 是 $\\frac{\\sqrt{3}}{2}$。\n经过两步后，Hessenberg 矩阵为\n$$\n\\bar{H}_2 = \\begin{pmatrix} h_{11}  h_{12} \\\\ h_{21}  h_{22} \\\\ 0  h_{32} \\end{pmatrix} = \\begin{pmatrix} 3  \\sqrt{2} \\\\ \\frac{1}{\\sqrt{2}}  3 \\\\ 0  \\frac{\\sqrt{3}}{2} \\end{pmatrix}\n$$\n问题特别要求 $h_{32}$ 的精确值。\n最终值：$h_{32} = \\frac{\\sqrt{3}}{2}$。", "answer": "$$\\boxed{\\frac{\\sqrt{3}}{2}}$$", "id": "3593935"}, {"introduction": "为了控制内存和计算成本，重启是$GMRES(m)$方法在实际应用中不可或缺的一部分，但这并非没有代价，它可能导致算法停滞。本练习旨在揭示重启$GMRES$的一个关键限制。你将构建一个特殊的例子，其中重启的$GMRES(m)$无法收敛，而完全的$GMRES$却可以，这突显了Krylov子空间的维度和可能导致算法停滞的几何条件的重要性。[@problem_id:3593977]", "problem": "你需要构造一个严格的例子，在该例子中，广义最小残差方法 (GMRES) 在重启动下表现出根本不同的行为。该任务涉及数值线性代数中的预处理 GMRES 算法。设预处理为左预处理，因此变换后的系统为 $M^{-1} A x = M^{-1} b$，算法最小化的残差为 $\\lVert M^{-1} (b - A x) \\rVert_2$。构造和分析必须从关于 Krylov 子空间和残差多项式的基本原理出发。\n\n基本定义和事实：\n- 广义最小残差方法 (GMRES) 构造迭代向量 $x_k$，使得预处理残差满足 $r_k = p_k(M^{-1} A) r_0$，其中 $r_0 = b - A x_0$，$p_k$ 是一个次数至多为 $k$ 且满足 $p_k(0) = 1$ 的多项式，并且预处理残差的欧几里得范数在所有此类多项式中被最小化。\n- 由矩阵 $B$ 和向量 $v$ 生成的 Krylov 子空间为 $\\mathcal{K}_k(B, v) = \\operatorname{span}\\{v, B v, B^2 v, \\dots, B^{k-1} v\\}$。\n- 重启动 GMRES($m$) 在连续的循环中应用一个 $m$ 次残差多项式，因此在 $j$ 个循环后，残差为 $r_{jm} = \\left(\\prod_{i=1}^j p_m^{(i)}(M^{-1} A)\\right) r_0$，其中每个 $p_m^{(i)}$ 都是一个满足 $p_m^{(i)}(0) = 1$ 的 $m$ 次多项式，并在该循环中生成的相应 Krylov 子空间上最小化残差。\n\n问题：\n1. 构造一个具体的矩阵 $A \\in \\mathbb{R}^{n \\times n}$、一个左预处理器 $M \\in \\mathbb{R}^{n \\times n}$、一个右端项 $b \\in \\mathbb{R}^n$、一个初始猜测 $x_0 \\in \\mathbb{R}^n$ 和一个重启动长度 $m$，使得重启动 GMRES($m$) 停滞（残差范数在循环中不减小），而未重启动的 GMRES 在至多 $n$ 次迭代内收敛到解。使用残差多项式表征以及关于 Krylov 子空间和正交性的几何论证来证明此行为。\n2. 为了一个科学上合理且可测试的场景，考虑以下使用维度 $n = 4$ 和左预处理的显式测试套件：\n   - 定义 $A$ 为 $\\mathbb{R}^{4 \\times 4}$ 中的循环下移置换矩阵，即 $A e_1 = e_2$，$A e_2 = e_3$，$A e_3 = e_4$，以及 $A e_4 = e_1$，其中 $(e_i)_{i=1}^4$ 是 $\\mathbb{R}^4$ 中的标准基向量。\n   - 定义左预处理器 $M = \\operatorname{diag}(1, 2, 3, 4)$。\n   - 定义 $b = e_1$ 和 $x_0 = 0$。\n   - 使用重启动长度 $m = 1$ 来演示停滞，使用未重启动的 GMRES 来演示收敛。\n   - 同时测试 $m = 2$ 和 $m = 4$ 以探究中间和边界行为，并测试一个修改后的右端项 $b = e_1 + e_2$ 以打破导致停滞的正交性条件。\n3. 你的程序必须在变换后的系统 $M^{-1} A x = M^{-1} b$ 上实现左预处理 GMRES，并测量原始残差范数 $\\lVert b - A x \\rVert_2$ 用于报告。它必须为指定的测试套件计算以下可量化的输出：\n   - 测试 1（停滞，重启动 GMRES($m=1$)）：在使用 $m=1$ 进行 8 个重启动循环后，比值 $\\rho_1 = \\lVert r_{\\text{final}} \\rVert_2 / \\lVert r_{\\text{initial}} \\rVert_2$，其中 $r_{\\text{initial}} = b - A x_0$，$r_{\\text{final}}$ 是最终残差。这是一个浮点数。\n   - 测试 2（未重启动 GMRES 收敛）：在不重启动的情况下，经过至多 $n$ 次迭代后的最终残差范数 $\\rho_2 = \\lVert r_{\\text{final}} \\rVert_2$。这是一个浮点数。\n   - 测试 3（$m = 2$ 时的进展）：一个布尔值，指示使用 $m = 2$ 的重启动 GMRES 在 4 个重启动循环后是否减小了残差范数，即最终范数是否严格小于初始范数。这是一个布尔值。\n   - 测试 4（边界，$m = n$）：在使用 $m = 4$ 的重启动 GMRES 单个循环后的最终残差范数 $\\rho_4 = \\lVert r_{\\text{final}} \\rVert_2$。这是一个浮点数。\n   - 测试 5（通过改变 $b$ 打破停滞）：一个布尔值，指示对于修改后的右端项 $b = e_1 + e_2$，使用 $m = 1$ 的重启动 GMRES 在 8 个循环后是否减小了残差范数。这是一个布尔值。\n4. 角度单位和物理单位不适用于这个纯数学问题。所有范数都是 $\\mathbb{R}^n$ 中的欧几里得范数。矩阵和向量的元素是无单位的实数。\n5. 最终输出格式：你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），其中 result1 和 result2 是浮点数，result3 和 result5 是布尔值，result4 是浮点数。\n\n你的解法必须使用残差多项式表征 $r_k = p_k(M^{-1} A) r_0$（其中 $p_k(0) = 1$）和 Krylov 子空间的几何性质来证明你的构造。代码必须是完整的、可“按原样”运行，并为给定的测试套件生成指定的输出。", "solution": "该问题要求在数值线性代数中构造一个例子，其中重启动广义最小残差方法 (GMRES) 停滞，而未重启动的 GMRES 收敛。分析必须基于 Krylov 子空间和残差多项式的基本原理。\n\nGMRES 算法的核心在于从仿射子空间 $x_0 + \\mathcal{K}_k(B, \\tilde{r}_0)$ 中找到线性系统 $Bx=c$ 的一个近似解 $x_k$。其中 $x_0$ 是初始猜测，$\\mathcal{K}_k(B, \\tilde{r}_0) = \\operatorname{span}\\{\\tilde{r}_0, B\\tilde{r}_0, \\dots, B^{k-1}\\tilde{r}_0\\}$ 是由矩阵 $B$ 和初始残差 $\\tilde{r}_0 = c - Bx_0$ 生成的 $k$ 阶 Krylov 子空间。选择迭代向量 $x_k$ 使其残差 $r_k = c - Bx_k$ 具有最小可能的欧几里得范数 $\\lVert r_k \\rVert_2$。对于左预处理系统 $M^{-1}Ax = M^{-1}b$，我们设 $B = M^{-1}A$ 和 $c = M^{-1}b$。然后 GMRES 最小化预处理残差的范数 $\\lVert M^{-1}(b-Ax_k) \\rVert_2$。\n\nGMRES 的一个关键几何性质是，新的预处理残差 $\\tilde{r}_k = M^{-1}(b - Ax_k)$ 与子空间 $B \\mathcal{K}_k(B, \\tilde{r}_0)$ 正交，其中 $\\tilde{r}_0 = M^{-1}(b - Ax_0)$ 是初始预处理残差。重启动 GMRES($m$) 的停滞发生于算法从一个循环到下一个循环没有取得任何进展时。这在一种特定条件下发生：如果初始预处理残差 $\\tilde{r}_0$ 已经与用于残差更新的搜索空间 $B\\mathcal{K}_m(B, \\tilde{r}_0)$ 正交。在这种情况下，最小化条件由零更新满足，导致 $\\tilde{r}_m = \\tilde{r}_0$。\n\n我们使用指定的参数构造这样一个案例。\n设 $n=4$。系统矩阵是循环下移置换矩阵：\n$$A = \\begin{pmatrix} 0  0  0  1 \\\\ 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n左预处理器是一个对角矩阵：\n$$M = \\operatorname{diag}(1, 2, 3, 4) = \\begin{pmatrix} 1  0  0  0 \\\\ 0  2  0  0 \\\\ 0  0  3  0 \\\\ 0  0  0  4 \\end{pmatrix}$$\n右端向量为 $b = e_1 = (1, 0, 0, 0)^T$，初始猜测为 $x_0 = 0$。\n\n预处理后的矩阵是 $B = M^{-1}A$：\n$$B = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1/2  0  0 \\\\ 0  0  1/3  0 \\\\ 0  0  0  1/4 \\end{pmatrix} \\begin{pmatrix} 0  0  0  1 \\\\ 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  1 \\\\ 1/2  0  0  0 \\\\ 0  1/3  0  0 \\\\ 0  0  1/4  0 \\end{pmatrix}$$\n初始残差是 $r_0 = b - Ax_0 = e_1$。初始预处理残差是 $\\tilde{r}_0 = M^{-1}r_0 = M^{-1}e_1 = e_1$。\n\n**1. 重启动 GMRES(m) 停滞分析 ($m=1, 2, 3$)**\n\n考虑重启动长度 $m \\le 3$ 的 GMRES($m$)。第一个循环从 $\\tilde{r}_0=e_1$ 开始。用于更新的子空间是 $B \\mathcal{K}_m(B, e_1) = \\operatorname{span}\\{B e_1, \\dots, B^m e_1\\}$。通过计算可知：\n$B e_1 = (1/2)e_2$\n$B^2 e_1 = (1/6)e_3$\n$B^3 e_1 = (1/24)e_4$\n因此，对于 $m \\le 3$，$B \\mathcal{K}_m(B, e_1) = \\operatorname{span}\\{e_2, \\dots, e_{m+1}\\}$。\n停滞的关键几何条件是初始预处理残差 $\\tilde{r}_0$ 与子空间 $B\\mathcal{K}_m(B, e_1)$ 正交。在本例中，$\\tilde{r}_0=e_1$。由于 $e_1$ 与该子空间的每个基向量 $e_2, \\dots, e_{m+1}$ 都正交，所以 $\\tilde{r}_0$ 与整个子空间 $B\\mathcal{K}_m(B, e_1)$ 正交。GMRES 条件要求新残差 $\\tilde{r}_m$ 与 $B\\mathcal{K}_m(B, e_1)$ 正交。由于 $\\tilde{r}_0$ 已经满足此正交条件，算法发现最佳选择是 $\\tilde{r}_m = \\tilde{r}_0$，这对应于零校正 $x_m = x_0$。残差范数没有减小。这就是停滞。此推理适用于任何重启动循环，以及任何重启动长度 $m=1, 2, 3$。\n\n从残差多项式的角度看，算法寻找一个次数至多为 $m$ 且满足 $p_m(0)=1$ 的多项式 $p_m(z)$，以最小化 $\\lVert p_m(B) \\tilde{r}_0 \\rVert_2$。此范数为 $\\lVert p_m(B) e_1 \\rVert_2$。因为向量 $e_1, Be_1, \\dots, B^m e_1$ 相互正交，对于 $p_m(z)=\\sum c_j z^j$，我们有 $\\lVert p_m(B) e_1 \\rVert_2^2 = \\sum_{j=0}^m c_j^2 \\lVert B^j e_1 \\rVert_2^2$。在 $c_0=p_m(0)=1$ 的条件下，当所有其他系数为零时，即 $p_m(z)=1$ 时，达到最小值。因此，$\\tilde{r}_m = p_m(B)\\tilde{r}_0 = \\tilde{r}_0$。\n\n**2. 未重启动 GMRES 收敛性分析 ($m=4$)**\n\n对于未重启动的 GMRES，算法最多运行 $n=4$ 次迭代，构建子空间 $\\mathcal{K}_4(B, e_1) = \\operatorname{span}\\{e_1, (1/2)e_2, (1/6)e_3, (1/24)e_4\\} = \\operatorname{span}\\{e_1, e_2, e_3, e_4\\} = \\mathbb{R}^4$。由于 Krylov 子空间是整个解空间，GMRES 保证能找到使残差为零的精确校正量 $z_4 = x_{exact} - x_0$。因此，未重启动的 GMRES（等价于 GMRES($4$) 的一个循环）收敛到精确解，最终的残差范数，无论是预处理的还是原始的，都将为零（或机器精度）。\n\n**3. 打破停滞的分析 ($b = e_1+e_2$)**\n\n我们将右端项改为 $b = e_1 + e_2$。初始残差为 $r_0 = e_1 + e_2$，预处理后的初始残差为 $\\tilde{r}_0 = M^{-1}(e_1 + e_2) = e_1 + (1/2)e_2$。\n现在考虑 GMRES($1$)。Krylov 子空间是 $\\mathcal{K}_1(B, \\tilde{r}_0) = \\operatorname{span}\\{e_1 + (1/2)e_2\\}$。用于残差更新的子空间是 $B\\mathcal{K}_1(B, \\tilde{r}_0) = \\operatorname{span}\\{B(e_1 + (1/2)e_2)\\}$。\n$B(e_1 + (1/2)e_2) = B e_1 + (1/2)B e_2 = (1/2)e_2 + (1/2)M^{-1}Ae_2 = (1/2)e_2 + (1/2)M^{-1}e_3 = (1/2)e_2 + (1/6)e_3$。\n关键的正交性条件通过内积来检验：\n$$ \\tilde{r}_0^T (B \\tilde{r}_0) = (e_1 + (1/2)e_2)^T ((1/2)e_2 + (1/6)e_3) = (1/2)(1/2) = 1/4 \\neq 0 $$\n由于 $\\tilde{r}_0$ 与 $B\\mathcal{K}_1(B, \\tilde{r}_0)$ 不正交，GMRES 的更新将非零。算法会将 $\\tilde{r}_0$ 投影到 $B\\mathcal{K}_1(B, \\tilde{r}_0)$ 的正交补上，产生一个新的残差 $\\tilde{r}_1$，满足 $\\lVert\\tilde{r}_1\\rVert_2  \\lVert\\tilde{r}_0\\rVert_2$。因此，停滞被打破，GMRES($1$) 将在每个循环中取得进展。\n\n这完成了对指定测试案例中观察到的行为的理论证明。所构造的例子巧妙地分离出了导致重启动 GMRES 停滞的几何条件。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse.linalg import gmres\n\ndef solve():\n    \"\"\"\n    Constructs and solves the test cases for GMRES stagnation and convergence.\n    \"\"\"\n    n = 4\n    # Define standard basis vectors\n    e1 = np.zeros(n)\n    e1[0] = 1.0\n    e2 = np.zeros(n)\n    e2[1] = 1.0\n\n    # Define the matrix A as the cyclic down-shift permutation matrix\n    A = np.roll(np.eye(n), 1, axis=0)\n\n    # Define the diagonal preconditioner M\n    M = np.diag(np.arange(1, n + 1).astype(float))\n    \n    # Define the initial guess\n    x0 = np.zeros(n)\n    \n    # Define the inverse of the preconditioner\n    M_inv = np.linalg.inv(M)\n    \n    # Pre-compute the transformed matrix for the left-preconditioned system\n    A_tilde = M_inv @ A\n\n    results = []\n\n    # --- Test 1: Stagnation with m=1 ---\n    # b = e1, m=1, 8 restart cycles\n    b1 = e1\n    r_initial_norm_1 = np.linalg.norm(b1 - A @ x0)\n    b_tilde_1 = M_inv @ b1\n    # For m=1 and 8 cycles, restart=1 and maxiter=8\n    x_final_1, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=1, maxiter=8, atol=1e-12)\n    r_final_1 = b1 - A @ x_final_1\n    rho1 = np.linalg.norm(r_final_1) / r_initial_norm_1\n    results.append(rho1)\n\n    # --- Test 2: Unrestarted GMRES convergence ---\n    # b = e1, unrestarted (m=n=4), max n iterations\n    # For unrestarted GMRES with n=4, restart=4 and maxiter=4\n    x_final_2, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=4, maxiter=4, atol=1e-12)\n    r_final_2 = b1 - A @ x_final_2\n    rho2 = np.linalg.norm(r_final_2)\n    results.append(rho2)\n\n    # --- Test 3: Progress for m=2 ---\n    # b = e1, m=2, 4 restart cycles. Check for any reduction in norm.\n    r_initial_norm_3 = np.linalg.norm(b1 - A @ x0)\n    # For m=2 and 4 cycles, restart=2 and maxiter=8\n    x_final_3, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=2, maxiter=8, atol=1e-12)\n    r_final_norm_3 = np.linalg.norm(b1 - A @ x_final_3)\n    progress_3 = r_final_norm_3  r_initial_norm_3\n    results.append(progress_3)\n\n    # --- Test 4: Boundary case m=n ---\n    # b = e1, m=4, 1 cycle. This is identical to unrestarted GMRES.\n    # For m=4 and 1 cycle, restart=4 and maxiter=4\n    x_final_4, _ = gmres(A_tilde, b_tilde_1, x0=x0, restart=4, maxiter=4, atol=1e-12)\n    r_final_4 = b1 - A @ x_final_4\n    rho4 = np.linalg.norm(r_final_4)\n    results.append(rho4)\n\n    # --- Test 5: Breaking stagnation by changing b ---\n    # b = e1+e2, m=1, 8 cycles. Check for any reduction in norm.\n    b5 = e1 + e2\n    r_initial_norm_5 = np.linalg.norm(b5 - A @ x0)\n    b_tilde_5 = M_inv @ b5\n    # For m=1 and 8 cycles, restart=1 and maxiter=8\n    x_final_5, _ = gmres(A_tilde, b_tilde_5, x0=x0, restart=1, maxiter=8, atol=1e-12)\n    r_final_norm_5 = np.linalg.norm(b5 - A @ x_final_5)\n    progress_5 = r_final_norm_5  r_initial_norm_5\n    results.append(progress_5)\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res in results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res).lower())\n        else:\n            formatted_results.append(f\"{res:.15e}\") # Use scientific notation for precision\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3593977"}, {"introduction": "在理论之外，有限精度算术的现实对算法的性能有重要影响。本练习将探讨一种实用且强大的预处理技术——行均衡（row equilibration），它能有效处理行尺度差异巨大的矩阵。通过实现并比较使用此预处理前后GMRES的性能，你不仅能观察到它对收敛速度的影响，还将直面Arnoldi过程中正交性损失这一实际挑战，这是实现稳健Krylov求解器时需要解决的关键问题。[@problem_id:3593955]", "problem": "考虑使用广义最小残差（GMRES）方法求解线性系统 $A x = b$。广义最小残差（GMRES）方法在Krylov子空间 $K_k(A,r_0)$ 中寻找 $x_k$，以最小化残差范数 $\\|r_k\\|_2$，其中 $r_0 = b - A x_0$，$x_0$ 为初始猜测值。Arnoldi过程生成一个标准正交基 $V_{k+1}$ 和一个上Hessenberg矩阵 $\\bar{H}_k$，使得 $A V_k = V_{k+1} \\bar{H}_k$。在精确算术中，Arnoldi向量是标准正交的，但在使用经典Gram-Schmidt正交化的有限精度算术中，可能会发生正交性损失。左预处理将 $A$ 替换为 $M^{-1} A$，将 $b$ 替换为 $M^{-1} b$，从而改变了Krylov子空间为 $K_k(M^{-1}A, M^{-1}r_0)$ 以及Arnoldi过程所见的算子。一种实用的左预处理器是使用对角矩阵 $M = D = \\operatorname{diag}(d_1,\\dots,d_n)$ 进行行均衡，其中 $d_i = \\|A_{i,:}\\|_\\infty$。这种方法平衡了各行，使得 $M^{-1} A$ 的每一行都具有单位无穷范数，从而减少了缩放差异。\n\n您的任务是，从第一性原理出发，实现一个基于经典Arnoldi过程的有限精度GMRES求解器，该求解器使用单次传递的经典Gram-Schmidt正交化和Givens旋转进行最小二乘更新。您必须支持使用对角矩阵 $M$ 进行左预处理，应用为 $M^{-1} A$ 和 $M^{-1} b$。然后，您必须使用此实现来比较在一组受控测试矩阵上，使用和不使用行均衡时的收敛性和正交性损失。\n\n从以下基本原理开始：\n1. Krylov子空间的定义 $K_k(B, r_0) = \\operatorname{span}\\{r_0, B r_0, \\dots, B^{k-1} r_0\\}$。\n2. Arnoldi关系式 $B V_k = V_{k+1} \\bar{H}_k$，在精确算术中 $V_{k+1}^\\top V_{k+1} = I$。\n3. GMRES迭代 $x_k$ 的最小二乘特性，即作为 $\\|\\beta e_1 - \\bar{H}_k y\\|_2$ 的最小化子，其中 $\\beta = \\|r_0\\|_2$ 且 $x_k = x_0 + V_k y$。\n\n设计并实现以下内容：\n1. 一个生成器，用于生成稠密的、非对称的、行不平衡的矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其构造如下。令 $G \\in \\mathbb{R}^{n \\times n}$ 具有独立的标准正态分布元素。令 $S = \\operatorname{diag}(s^{\\theta_i})$，其中 $\\theta_i$ 是 $[0,1]$ 区间内的 $n$ 个等距点，并设 $A = S (G + \\tau I)$，其中 $\\tau = 10^{-1}$。当 $s \\gg 1$ 时，这种构造会产生一个行不平衡可控的矩阵 $A$。使用 $b = \\mathbf{1} \\in \\mathbb{R}^n$ 和 $x_0 = 0$。\n2. 一个对角左预处理器 $M = D = \\operatorname{diag}(d_1,\\dots,d_n)$，其中 $d_i = \\|A_{i,:}\\|_\\infty$；如果某行为全零，则设置 $d_i = 1$ 以避免除以零。预处理后的算子是 $B = M^{-1} A$，右端项是 $c = M^{-1} b$。\n3. 一个使用单次传递经典Gram-Schmidt和Givens旋转的GMRES实现。当相对残差满足 $\\|r_k\\|_2 / \\|b\\|_2 \\le 10^{-8}$ 时，或当迭代次数达到 $k_{\\max} = \\min(n, 200)$ 时终止；在后一种情况下，将 $k_{\\max}$ 报告为迭代次数。使用 $\\mathbb{R}$ 上的算术，浮点运算采用双精度。\n4. 一个在终止时衡量Arnoldi基正交性损失的量化指标：如果 $V_k \\in \\mathbb{R}^{n \\times k}$ 是计算出的Arnoldi基向量，报告 $\\delta = \\|I_k - V_k^\\top V_k\\|_F$。\n\n测试套件。对于下面的每个参数三元组 $(n, s, \\text{seed})$，使用给定的随机种子如上构造 $A$ 和 $b$，并分别在无预处理（$M = I$）和使用对角行均衡预处理（$M = D$）的情况下运行您的GMRES实现。对于每次运行，记录达到容差所需的迭代次数 $k$（如果未达到则为 $k_{\\max}$）以及终止时的正交性损失度量 $\\delta$。使用以下测试用例：\n- 测试 1：$(n, s, \\text{seed}) = (60, 10^{0}, 1)$。\n- 测试 2：$(n, s, \\text{seed}) = (60, 10^{3}, 2)$。\n- 测试 3：$(n, s, \\text{seed}) = (60, 10^{6}, 3)$。\n- 测试 4：$(n, s, \\text{seed}) = (20, 10^{4}, 4)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于按顺序排列的每个测试用例，输出一个包含四个值的列表 $[k_{\\text{noeq}}, k_{\\text{eq}}, \\delta_{\\text{noeq}}, \\delta_{\\text{eq}}]$，其中 $k_{\\text{noeq}}$ 和 $k_{\\text{eq}}$ 是整数，$\\delta_{\\text{noeq}}$ 和 $\\delta_{\\text{eq}}$ 是浮点数。因此，最后一行应看起来像一个列表的列表，例如 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\dots]$，其中所有条目都是纯数字，没有附加文本。", "solution": "经评估，用户提供的问题是**有效的**。这是一个在数值线性代数领域内定义明确、具有科学依据且可通过计算验证的问题。问题陈述是完整、自洽的，没有任何矛盾或含糊之处。\n\n本文将给出一个详细的、基于原理的解决方案。实现将遵循以下步骤，这些步骤符合问题的规范。\n\n### 1. 问题阐述\n核心任务是求解线性方程组 $A x = b$，其中 $x \\in \\mathbb{R}^n$，$A \\in \\mathbb{R}^{n \\times n}$ 是一个非对称矩阵，$b \\in \\mathbb{R}^n$ 是右端向量。广义最小残差（GMRES）方法是一种迭代的Krylov子空间方法，它在第 $k$ 次迭代时通过最小化残差的欧几里得范数 $\\|r_k\\|_2 = \\|b - A x_k\\|_2$ 来找到近似解 $x_k$。对 $x_k$ 的搜索被限制在仿射Krylov子空间 $x_0 + K_k(A, r_0)$ 中，其中 $x_0$ 是初始猜测值，$r_0 = b - A x_0$ 是初始残差，$K_k(A, r_0) = \\operatorname{span}\\{r_0, A r_0, \\dots, A^{k-1} r_0\\}$ 是第 $k$ 个Krylov子空间。\n\n### 2. 测试矩阵的生成\n为了在行缩放效应受控的条件下测试算法的性能，我们构造了一族稠密的、非对称的、行不平衡的矩阵。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的生成方式如下：\n$$\nA = S (G + \\tau I)\n$$\n这里，$G \\in \\mathbb{R}^{n \\times n}$ 是一个其元素服从标准正态分布 $N(0,1)$ 的矩阵。$I$ 是 $n \\times n$ 的单位矩阵，$\\tau = 10^{-1}$ 是一个小的偏移量，以确保 $A$ 有很大概率是良态且非奇异的。行不平衡由对角缩放矩阵 $S = \\operatorname{diag}(s^{\\theta_1}, s^{\\theta_2}, \\dots, s^{\\theta_n})$ 引入，其中 $s \\ge 1$ 是一个缩放参数，$\\theta_i$（对于 $i=1, \\dots, n$）是区间 $[0, 1]$ 内的 $n$ 个等距点。在本实现中，$\\theta_i = (i-1)/(n-1)$，对于 $i=1, \\dots, n$。当 $s \\gg 1$ 时，$A$ 的各行范数会跨越很大的数量级，从而造成一个病态系统。右端项设为 $b = \\mathbf{1}$（一个全为1的向量），初始猜测值设为 $x_0 = 0$。\n\n### 3. 使用行均衡进行左预处理\n预处理是一种将原线性系统转换为更易于通过迭代方法求解的系统的技术。左预处理将系统 $A x = b$ 修改为 $M^{-1} A x = M^{-1} b$，其中 $M$ 是一个非奇异的预处理器矩阵。然后将GMRES应用于这个新系统。\n\n对于行尺度差异较大的矩阵，一种简单而有效的预处理器是对角缩放，也称为行均衡。预处理器 $M$ 被选为一个对角矩阵 $D = \\operatorname{diag}(d_1, d_2, \\dots, d_n)$，其中每个 $d_i$ 是 $A$ 的第 $i$ 行的 $\\infty$-范数：\n$$\nd_i = \\|A_{i,:}\\|_\\infty = \\max_{1 \\le j \\le n} |A_{ij}|\n$$\n为防止除以零，如果 $A$ 的任何行为全零，则对应的 $d_i$ 设置为 $1$。预处理后的算子是 $B = D^{-1}A$，预处理后的右端项是 $c = D^{-1}b$。根据构造， $B$ 的每一行都具有单位 $\\infty$-范数，这缓解了 $A$ 中存在的缩放问题。\n\n### 4. GMRES算法\nGMRES算法应用于有效系统 $B x = c$，其中 $B$ 要么是原始矩阵 $A$（无预处理，$M=I$），要么是预处理后的矩阵 $D^{-1}A$。\n\n**a. Arnoldi迭代：** GMRES为Krylov子空间 $K_{k+1}(B, r'_0)$ 构建一个标准正交基 $V_{k+1} = [v_1, v_2, \\dots, v_{k+1}]$，其中 $r'_0 = c - B x_0 = c$ 是预处理系统的初始残差。这个过程被称为Arnoldi迭代，它还生成一个上Hessenberg矩阵 $\\bar{H}_k \\in \\mathbb{R}^{(k+1) \\times k}$，满足关系式：\n$$\nB V_k = V_{k+1} \\bar{H}_k\n$$\n其中 $V_k = [v_1, \\dots, v_k]$。基向量是顺序生成的。在第 $j$ 步，新向量 $v_{j+1}$ 是通过将 $B v_j$ 与所有先前的向量 $v_1, \\dots, v_j$ 正交化来计算的。本实现为此使用单次传递的经典Gram-Schmidt（CGS）算法：\n1. 计算 $w = B v_j$。\n2. 对于 $i=1, \\dots, j$：\n   - $h_{ij} = v_i^\\top w$。\n   - $w = w - h_{ij} v_i$。\n3. $h_{j+1,j} = \\|w\\|_2$。\n4. 如果 $h_{j+1,j}=0$，算法找到了一个不变子空间（分解）。\n5. $v_{j+1} = w / h_{j+1,j}$。\n元素 $h_{ij}$ 构成了矩阵 $\\bar{H}_k$。\n\n**b. 最小二乘问题：** GMRES迭代 $x_k$ 表示为 $x_k = x_0 + V_k y_k$。选择向量 $y_k \\in \\mathbb{R}^k$ 以最小化（预处理后的）残差范数：\n$$\n\\min_{y \\in \\mathbb{R}^k} \\|c - B(x_0 + V_k y)\\|_2 = \\min_{y \\in \\mathbb{R}^k} \\|r'_0 - B V_k y\\|_2\n$$\n由于 $r'_0 = \\|r'_0\\|_2 v_1$ 且 $B V_k = V_{k+1} \\bar{H}_k$，这等价于：\n$$\n\\min_{y \\in \\mathbb{R}^k} \\| \\|r'_0\\|_2 v_1 - V_{k+1} \\bar{H}_k y \\|_2 = \\min_{y \\in \\mathbb{R}^k} \\| V_{k+1} (\\|r'_0\\|_2 e_1 - \\bar{H}_k y) \\|_2\n$$\n其中 $e_1 = [1, 0, \\dots, 0]^\\top \\in \\mathbb{R}^{k+1}$。由于 $V_{k+1}$ 的列是标准正交的，这简化为求解以下小型最小二乘问题：\n$$\ny_k = \\arg\\min_{y \\in \\mathbb{R}^k} \\|\\beta e_1 - \\bar{H}_k y\\|_2, \\quad \\text{其中 } \\beta = \\|r'_0\\|_2\n$$\n\n**c. 通过Givens旋转求解：** 这个最小二乘问题可以被迭代地高效求解。在每一步 $k$，使用Givens旋转来更新 $\\bar{H}_k$ 的QR分解。应用一系列旋转 $Q_k = G_k \\dots G_1$ 将 $\\bar{H}_k$ 转换为一个上三角矩阵，并更新右端向量 $g_0 = \\beta e_1$。\n预处理后残差的范数可以在每一步获得，而无需计算 $x_k$，因为它等于变换后右端向量最后一个元素的大小。\n\n**d. 终止准则：** 当*真实*残差的相对范数低于容差 $\\epsilon = 10^{-8}$ 时，迭代终止：\n$$\n\\frac{\\|b - A x_k\\|_2}{\\|b\\|_2} \\le \\epsilon\n$$\n或者当迭代次数达到最大值 $k_{\\max} = \\min(n, 200)$ 时终止。为了检查此准则，必须在每一步显式计算迭代 $x_k$。这通过求解上三角系统 $R_k y_k = \\tilde{g}_k$（来自 $\\bar{H}_k$ 的QR分解）然后形成 $x_k = x_0 + V_k y_k$ 来完成。\n\n### 5. 正交性损失\n众所周知，单次传递的CGS在数值上是不稳定的，会导致计算出的基 $V_k$ 失去正交性。这种退化通过与单位矩阵偏差的Frobenius范数来量化：\n$$\n\\delta = \\|I_k - V_k^\\top V_k\\|_F\n$$\n其中 $V_k$ 是在终止时计算出的Arnoldi向量矩阵。较大的 $\\delta$ 表明更严重的正交性损失。对于预处理和非预处理的运行都计算此度量，以比较它们的数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef generate_matrix(n, s, seed):\n    \"\"\"\n    Generates a dense, nonsymmetric, row-imbalanced matrix A and RHS vector b.\n    A = S * (G + tau*I), where S is a diagonal scaling matrix.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    G = rng.standard_normal(size=(n, n))\n    tau = 1e-1\n    \n    theta = np.linspace(0, 1, n)\n    s_vec = s**theta\n    S = np.diag(s_vec)\n    \n    A = S @ (G + tau * np.eye(n))\n    b = np.ones(n)\n    \n    return A, b\n\ndef get_preconditioner(A):\n    \"\"\"\n    Computes a diagonal row-equilibration preconditioner M=D.\n    d_i = ||A[i,:]||_inf.\n    \"\"\"\n    d = np.linalg.norm(A, ord=np.inf, axis=1)\n    d[d == 0] = 1.0  # Avoid division by zero for zero rows.\n    return d\n\ndef calculate_orth_loss(V):\n    \"\"\"\n    Calculates the loss of orthogonality metric: ||I - V.T @ V||_F.\n    \"\"\"\n    k = V.shape[1]\n    if k == 0:\n        return 0.0\n    I_k = np.eye(k)\n    loss = np.linalg.norm(I_k - V.T @ V, 'fro')\n    return loss\n\ndef gmres_solver(A, b, precon_diag, tol, max_iter):\n    \"\"\"\n    Implements a left-preconditioned GMRES solver from first principles.\n    - Orthogonalization: Classical Gram-Schmidt (single pass).\n    - LS-Update: Givens rotations.\n    - Termination: True relative residual or max_iter.\n    \"\"\"\n    n = A.shape[0]\n    b_norm = np.linalg.norm(b)\n\n    if b_norm == 0.0:\n        return 0, np.zeros((n, 0))\n\n    if precon_diag is None:\n        A_eff = A\n        r0 = b\n    else:\n        precon_inv_diag = 1.0 / precon_diag\n        A_eff = precon_inv_diag[:, np.newaxis] * A\n        r0 = precon_inv_diag * b\n\n    kmax_actual = min(n, max_iter)\n    \n    V = np.zeros((n, kmax_actual + 1), dtype=np.float64)\n    H = np.zeros((kmax_actual + 1, kmax_actual), dtype=np.float64)\n    cs = np.zeros(kmax_actual, dtype=np.float64)\n    sn = np.zeros(kmax_actual, dtype=np.float64)\n    g = np.zeros(kmax_actual + 1, dtype=np.float64)\n\n    r0_norm = np.linalg.norm(r0)\n    V[:, 0] = r0 / r0_norm\n    g[0] = r0_norm\n    \n    num_iterations_performed = kmax_actual\n\n    for k in range(kmax_actual):\n        # --- Arnoldi Step (with CGS) ---\n        w = A_eff @ V[:, k]\n        for j in range(k + 1):\n            H[j, k] = V[:, j].T @ w\n            w -= H[j, k] * V[:, j]\n        \n        H[k + 1, k] = np.linalg.norm(w)\n\n        # --- Givens Rotations ---\n        # Apply previous rotations to the new column of H\n        for j in range(k):\n            h_j_k = H[j, k]\n            h_jp1_k = H[j + 1, k]\n            H[j, k] = cs[j] * h_j_k + sn[j] * h_jp1_k\n            H[j + 1, k] = -sn[j] * h_j_k + cs[j] * h_jp1_k\n\n        # Compute and apply new rotation\n        givens_norm = np.hypot(H[k, k], H[k + 1, k])\n        \n        if givens_norm  1e-16: # Breakdown\n            cs[k] = 1.0\n            sn[k] = 0.0\n        else:\n            cs[k] = H[k, k] / givens_norm\n            sn[k] = H[k + 1, k] / givens_norm\n        \n        H[k, k] = givens_norm\n        \n        # Update RHS vector g\n        g_k = g[k]\n        g[k] = cs[k] * g_k\n        g[k + 1] = -sn[k] * g_k\n\n        # --- Check True Residual for Convergence ---\n        k_current = k + 1\n        y = solve_triangular(H[:k_current, :k_current], g[:k_current])\n        x_k = V[:, :k_current] @ y  # Since x0=0\n        r_true = b - A @ x_k\n        rel_res = np.linalg.norm(r_true) / b_norm\n        \n        if rel_res = tol:\n            num_iterations_performed = k_current\n            break\n\n        if givens_norm  1e-16: # Lucky breakdown check\n            num_iterations_performed = k_current\n            break\n\n        V[:, k_current] = w / H[k_current, k]\n\n    V_final = V[:, :num_iterations_performed]\n    return num_iterations_performed, V_final\n\ndef solve():\n    test_cases = [\n        (60, 10**0, 1),\n        (60, 10**3, 2),\n        (60, 10**6, 3),\n        (20, 10**4, 4),\n    ]\n\n    all_results = []\n    tol = 1e-8\n\n    for n, s, seed in test_cases:\n        A, b = generate_matrix(n, s, seed)\n        kmax = min(n, 200)\n        \n        # Run without preconditioning\n        k_noeq, V_noeq = gmres_solver(A, b, precon_diag=None, tol=tol, max_iter=kmax)\n        delta_noeq = calculate_orth_loss(V_noeq)\n        \n        # Run with row equilibration preconditioning\n        M_diag = get_preconditioner(A)\n        k_eq, V_eq = gmres_solver(A, b, precon_diag=M_diag, tol=tol, max_iter=kmax)\n        delta_eq = calculate_orth_loss(V_eq)\n        \n        all_results.append([k_noeq, k_eq, delta_noeq, delta_eq])\n\n    # Format the final output string to match the requested format exactly.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3593955"}]}