{"hands_on_practices": [{"introduction": "要真正理解CANDECOMP/PARAFAC (CP)分解，关键在于掌握各个因子矩阵如何组合形成完整的张量。本练习提供了一个动手实践的机会，让您根据给定的因子构建一个小的低秩张量。通过执行这些基本计算 ([@problem_id:3533244])，您将为支撑CP模型及其切片表示的多线性结构建立具体的直观认识。", "problem": "考虑一个三维张量的典范分解/平行因子分析 (CANDECOMP/PARAFAC, CP) 模型，及其在交替最小二乘法 (Alternating Least Squares, ALS) 中的应用，其中固定两个因子矩阵，并为剩余的因子求解一个最小二乘子问题。使用一个尺寸为 $I \\times J \\times K$ 的张量的具体秩-$R$ CP 表示，该表示由 $R$ 个秩一外积之和给出。设 $I=J=K=2$ 且 $R=2$。指定因子矩阵\n$$\nA=\\begin{pmatrix}\n1  2\\\\\n3  1\n\\end{pmatrix},\\quad\nB=\\begin{pmatrix}\n0  1\\\\\n2  -1\n\\end{pmatrix},\\quad\nC=\\begin{pmatrix}\n1  0\\\\\n1  2\n\\end{pmatrix},\n$$\n其中每一列对应一个秩一分量。使用 CP 定义，重构的张量 $\\mathcal{X}\\in\\mathbb{R}^{2\\times 2\\times 2}$ 的元素 $x_{i j k}$ 是从这些因子中获得的。\n\n任务：\n- 从定义 CP 的秩一外积结构出发，推导用 $A$、$B$ 和 $C$ 表示的元素 $x_{i j k}$ 的公式，并为指定的 $A$、$B$ 和 $C$ 计算重构张量 $\\mathcal{X}$ 的所有八个元素。\n- 将每个额面切片 $\\mathcal{X}(:,:,k)$ 表示为一个矩阵，该矩阵用 $A$、$B$ 以及由 $C$ 的第 $k$ 行构成的对角矩阵表示，并验证其与计算出的元素的一致性。\n- 计算重构张量的弗罗贝尼乌斯范数 $\\|\\mathcal{X}\\|_{F}$。如果您决定进行近似计算，请将答案四舍五入到四位有效数字；否则，提供精确值。\n\n您最终报告的量必须是弗罗贝尼乌斯范数 $\\|\\mathcal{X}\\|_{F}$，形式为单个实数或单个闭式解析表达式。", "solution": "该问题是有效的，因为它科学地基于多重线性代数的原理，特别是 CANDECOMP/PARAFAC (CP) 分解，并且是适定的，为得到唯一解提供了所有必要信息。\n\n一个秩为 $R$ 的三维张量 $\\mathcal{X} \\in \\mathbb{R}^{I \\times J \\times K}$ 的 CANDECOMP/PARAFAC (CP) 分解由 $R$ 个秩一张量之和给出。每个秩一张量是三个向量的外积。设因子矩阵为 $A \\in \\mathbb{R}^{I \\times R}$，$B \\in \\mathbb{R}^{J \\times R}$ 和 $C \\in \\mathbb{R}^{K \\times R}$。设这些矩阵的列为 $\\mathbf{a}_r, \\mathbf{b}_r, \\mathbf{c}_r$，其中 $r=1, \\dots, R$。则张量 $\\mathcal{X}$ 表示为：\n$$\n\\mathcal{X} = \\sum_{r=1}^{R} \\mathbf{a}_r \\circ \\mathbf{b}_r \\circ \\mathbf{c}_r\n$$\n其中 $\\circ$ 表示外积。\n\n第一个任务是推导张量 $\\mathcal{X}$ 的元素 $x_{ijk}$ 的公式。根据外积的定义，张量 $\\mathbf{a}_r \\circ \\mathbf{b}_r \\circ \\mathbf{c}_r$ 的一个元素 $(i,j,k)$ 由相应向量元素的乘积给出，即 $(a_r)_i (b_r)_j (c_r)_k$。在矩阵表示法中，这些是 $a_{ir}$、$b_{jr}$ 和 $c_{kr}$。因此，张量 $\\mathcal{X}$ 的元素 $x_{ijk}$ 是通过对 $R$ 个分量求和得到的：\n$$\nx_{ijk} = \\sum_{r=1}^{R} a_{ir} b_{jr} c_{kr}\n$$\n在这个问题中，维度为 $I=J=K=2$，秩为 $R=2$。给定的因子矩阵为：\n$$\nA=\\begin{pmatrix} 1  2\\\\ 3  1 \\end{pmatrix},\\quad\nB=\\begin{pmatrix} 0  1\\\\ 2  -1 \\end{pmatrix},\\quad\nC=\\begin{pmatrix} 1  0\\\\ 1  2 \\end{pmatrix}\n$$\n重构张量 $\\mathcal{X} \\in \\mathbb{R}^{2 \\times 2 \\times 2}$ 的元素使用 $R=2$ 的公式计算：\n$$\nx_{ijk} = a_{i1}b_{j1}c_{k1} + a_{i2}b_{j2}c_{k2}\n$$\n我们计算所有 8 个元素，并将其组织成两个额面切片 $\\mathcal{X}(:,:,1)$ 和 $\\mathcal{X}(:,:,2)$。\n\n对于第一个额面切片 ($k=1$)：\n$C$ 的第一行为 $(c_{11}, c_{12}) = (1, 0)$。\n$x_{111} = a_{11}b_{11}c_{11} + a_{12}b_{12}c_{12} = (1)(0)(1) + (2)(1)(0) = 0$\n$x_{121} = a_{11}b_{21}c_{11} + a_{12}b_{22}c_{12} = (1)(2)(1) + (2)(-1)(0) = 2$\n$x_{211} = a_{21}b_{11}c_{11} + a_{22}b_{12}c_{12} = (3)(0)(1) + (1)(1)(0) = 0$\n$x_{221} = a_{21}b_{21}c_{11} + a_{22}b_{22}c_{12} = (3)(2)(1) + (1)(-1)(0) = 6$\n所以，第一个额面切片是矩阵 $\\mathcal{X}(:,:,1) = \\begin{pmatrix} 0  2 \\\\ 0  6 \\end{pmatrix}$。\n\n对于第二个额面切片 ($k=2$)：\n$C$ 的第二行为 $(c_{21}, c_{22}) = (1, 2)$。\n$x_{112} = a_{11}b_{11}c_{21} + a_{12}b_{12}c_{22} = (1)(0)(1) + (2)(1)(2) = 4$\n$x_{122} = a_{11}b_{21}c_{21} + a_{12}b_{22}c_{22} = (1)(2)(1) + (2)(-1)(2) = 2 - 4 = -2$\n$x_{212} = a_{21}b_{11}c_{21} + a_{22}b_{12}c_{22} = (3)(0)(1) + (1)(1)(2) = 2$\n$x_{222} = a_{21}b_{21}c_{21} + a_{22}b_{22}c_{22} = (3)(2)(1) + (1)(-1)(2) = 6 - 2 = 4$\n所以，第二个额面切片是矩阵 $\\mathcal{X}(:,:,2) = \\begin{pmatrix} 4  -2 \\\\ 2  4 \\end{pmatrix}$。\n\n第二个任务是将每个额面切片 $\\mathcal{X}(:,:,k)$（我们将其表示为矩阵 $X_{(k)}$）用 $A$、$B$ 以及由 $C$ 的第 $k$ 行构成的对角矩阵来表示。第 $k$ 个额面切片的公式是 $X_{(k)} = A D_k(C) B^T$，其中 $D_k(C)$ 是一个对角矩阵，其对角元素是 $C$ 的第 $k$ 行的元素，即 $(D_k(C))_{rr} = c_{kr}$。\n让我们通过计算 $A D_k(C) B^T$ 的第 $(i,j)$ 个元素来验证这个公式：\n$$\n(A D_k(C) B^T)_{ij} = \\sum_{r=1}^{R} (A D_k(C))_{ir} (B^T)_{rj} = \\sum_{r=1}^{R} \\left( \\sum_{s=1}^{R} a_{is} (D_k(C))_{sr} \\right) b_{jr}\n$$\n由于 $D_k(C)$ 是对角矩阵，$(D_k(C))_{sr} = c_{kr}\\delta_{sr}$，其中 $\\delta_{sr}$ 是克罗内克 δ 符号。\n$$\n(A D_k(C) B^T)_{ij} = \\sum_{r=1}^{R} \\left( \\sum_{s=1}^{R} a_{is} c_{ks}\\delta_{sr} \\right) b_{jr} = \\sum_{r=1}^{R} a_{ir} c_{kr} b_{jr} = \\sum_{r=1}^{R} a_{ir}b_{jr}c_{kr} = x_{ijk}\n$$\n这证实了切片公式。现在我们用给定的矩阵来验证它。\n\n对于 $k=1$，$C$ 的第一行是 $(1,0)$，所以 $D_1(C) = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}$。\n$$\nX_{(1)} = A D_1(C) B^T = \\begin{pmatrix} 1  2 \\\\ 3  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 2  -1 \\end{pmatrix}^T\n= \\begin{pmatrix} 1  0 \\\\ 3  0 \\end{pmatrix} \\begin{pmatrix} 0  2 \\\\ 1  -1 \\end{pmatrix}\n= \\begin{pmatrix} 0  2 \\\\ 0  6 \\end{pmatrix}\n$$\n这与我们计算的 $\\mathcal{X}(:,:,1)$ 一致。\n\n对于 $k=2$，$C$ 的第二行是 $(1,2)$，所以 $D_2(C) = \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix}$。\n$$\nX_{(2)} = A D_2(C) B^T = \\begin{pmatrix} 1  2 \\\\ 3  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 2  -1 \\end{pmatrix}^T\n= \\begin{pmatrix} 1  4 \\\\ 3  2 \\end{pmatrix} \\begin{pmatrix} 0  2 \\\\ 1  -1 \\end{pmatrix}\n= \\begin{pmatrix} 4  2-4 \\\\ 2  6-2 \\end{pmatrix}\n= \\begin{pmatrix} 4  -2 \\\\ 2  4 \\end{pmatrix}\n$$\n这与我们计算的 $\\mathcal{X}(:,:,2)$ 一致。\n\n第三个任务是计算重构张量的弗罗贝尼乌斯范数 $\\|\\mathcal{X}\\|_{F}$。弗罗贝尼乌斯范数的平方是其所有元素平方的和：\n$$\n\\|\\mathcal{X}\\|_{F}^2 = \\sum_{i=1}^{I} \\sum_{j=1}^{J} \\sum_{k=1}^{K} x_{ijk}^2\n$$\n使用我们计算出的元素：\n$$\n\\|\\mathcal{X}\\|_{F}^2 = \\underbrace{(0^2 + 2^2 + 0^2 + 6^2)}_{\\text{切片 1}} + \\underbrace{(4^2 + (-2)^2 + 2^2 + 4^2)}_{\\text{切片 2}}\n$$\n$$\n\\|\\mathcal{X}\\|_{F}^2 = (0 + 4 + 0 + 36) + (16 + 4 + 4 + 16)\n$$\n$$\n\\|\\mathcal{X}\\|_{F}^2 = 40 + 40 = 80\n$$\n弗罗贝尼乌斯范数是该值的平方根：\n$$\n\\|\\mathcal{X}\\|_{F} = \\sqrt{80} = \\sqrt{16 \\times 5} = 4\\sqrt{5}\n$$\n问题要求提供精确值或四位有效数字的近似值。精确值为 $4\\sqrt{5}$。", "answer": "$$\n\\boxed{4\\sqrt{5}}\n$$", "id": "3533244"}, {"introduction": "任何算法的效率都通过其计算成本来衡量。本实践将引导您详细分析一个完整的交替最小二乘（ALS）扫描所需的浮点运算（flops）和内存需求。掌握此类分析 ([@problem_id:3586499]) 对于预测性能、识别计算瓶颈以及在将张量分解算法扩展到大规模问题时做出明智决策至关重要。", "problem": "考虑一个稠密的$N$阶数据张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times \\cdots \\times I_N}$ 及其秩为$R$的CANDECOMP/PARAFAC (CP) 模型，该模型由因子矩阵 $\\{A^{(n)} \\in \\mathbb{R}^{I_n \\times R}\\}_{n=1}^{N}$ 表示，使得模型近似为 $\\sum_{r=1}^{R} a^{(1)}_{:,r} \\circ \\cdots \\circ a^{(N)}_{:,r}$。一次交替最小二乘 (Alternating Least Squares, ALS) 扫描会遍历每个模 $n \\in \\{1,\\dots,N\\}$，并通过求解一个由模$n$矩阵化$X_{(n)}$和其他因子矩阵的Khatri–Rao积构建的最小二乘子问题来更新$A^{(n)}$。假设采用以下实现和计算规则，您必须使用这些规则作为推导的基础：\n\n- 模$n$的矩阵化张量与Khatri–Rao积的乘积 (Matricized Tensor Times Khatri–Rao Product, MTTKRP) 的计算不显式构建任何Khatri–Rao积。它通过$X_{(n)} \\in \\mathbb{R}^{I_n \\times \\left(\\prod_{m \\neq n} I_m\\right)}$与一个收缩中隐含的$\\left(\\prod_{m \\neq n} I_m\\right) \\times R$操作数之间的稠密矩阵-矩阵乘积来评估。将其计算量记为 $2\\,I_n \\left(\\prod_{m \\neq n} I_m\\right) R$次浮点运算 (flops)。\n- 对于每个模$n$，通过Hadamard (逐元素) 积 $H^{(n)} = \\underset{m \\neq n}{\\bigodot}\\, S^{(m)}$ 形成正规方程系数$H^{(n)} \\in \\mathbb{R}^{R \\times R}$，其中 $S^{(m)} = A^{(m)\\top} A^{(m)} \\in \\mathbb{R}^{R \\times R}$ 是第$m$个因子的Gram矩阵。通过稠密矩阵-矩阵乘法计算每个$S^{(m)}$，并将其计算量记为 $2\\,I_m R^2$ flops。对于每个模，通过链接$(N-1)$个逐元素矩阵乘积来朴素地组装$H^{(n)}$，而不跨模重用，每个模的成本为 $(N-2)R^2$ flops。\n- 通过对$H^{(n)}$进行Cholesky分解，然后进行两次具有$I_n$个右侧向量的三角求解，来求解更新$A^{(n)}$的正规方程 (即，更新$A^{(n)} = M^{(n)} H^{(n)^{-1}}$，其中$M^{(n)}$是MTTKRP的输出)。将一个$R \\times R$对称正定矩阵的Cholesky分解的计算量记为 $\\tfrac{1}{3}R^3$ flops，每次具有$I_n$个右侧向量的三角求解记为 $I_n R^2$ flops，因此两次求解的总计算量为 $2 I_n R^2$ flops。\n- 更新$A^{(n)}$后，重新计算其Gram矩阵$S^{(n)} = A^{(n)\\top} A^{(n)}$，成本为 $2\\,I_n R^2$ flops，以用于同一扫描中后续模的计算。\n- 所有稠密乘法均使用标准成本规则：一个$m \\times k$矩阵与一个$k \\times n$矩阵相乘的成本为 $2 m k n$ flops。\n- 内存模型 (峰值存储，以标量字为单位)：显式存储稠密张量$\\mathcal{X}$、所有因子矩阵$\\{A^{(n)}\\}_{n=1}^{N}$、所有Gram矩阵$\\{S^{(n)}\\}_{n=1}^{N}$、一个用于一次一个模的临时右端项$M^{(n)} \\in \\mathbb{R}^{I_n \\times R}$，以及一个用于$H^{(n)}$的$R \\times R$临时空间。不显式存储任何Khatri–Rao积或张量展开。\n\n仅从这些规则以及CP分解和ALS的定义出发，推导出一个精确的、封闭形式的表达式，用于：\n- 遍历所有$N$个模的一次完整ALS扫描的总flop计数，以及\n- 在指定内存模型下存储的标量字峰值数量，\n\n两者都用$N$、$R$和模大小$\\{I_n\\}_{n=1}^{N}$表示。您的最终答案必须是一个单行矩阵，其第一个条目是flop计数表达式，第二个条目是峰值内存表达式，不带单位。不要使用渐近符号。不要四舍五入或近似。", "solution": "用户提供了一个问题陈述，要求推导CANDECOMP/PARAFAC交替最小二乘 (CP-ALS) 算法的计算成本和内存需求的解析表达式。该问题附有一套特定的计算和内存核算规则。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n- 数据张量：$\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times \\cdots \\times I_N}$。\n- CP秩：$R$。\n- 因子矩阵：$\\{A^{(n)} \\in \\mathbb{R}^{I_n \\times R}\\}_{n=1}^{N}$。\n- ALS扫描：对 $n = 1, \\dots, N$ 更新 $A^{(n)}$ 的一次完整遍历。\n- 模$n$的矩阵化张量与Khatri–Rao积的乘积 (MTTKRP) 的成本：$2\\,I_n \\left(\\prod_{m \\neq n} I_m\\right) R$ flops。\n- 构建正规矩阵 $H^{(n)}$ 的成本：对于每个模 $n$，计算所有 $N-1$ 个Gram矩阵 $S^{(m)} = A^{(m)\\top}A^{(m)}$，每个成本为 $2 I_m R^2$ flops，然后通过 $(N-2)R^2$ flops 的Hadamard积组装 $H^{(n)} = \\underset{m \\neq n}{\\bigodot}\\, S^{(m)}$。这对每个模都朴素地完成。\n- 求解 $A^{(n)}$ 的正规方程的成本：$H^{(n)}$ 的Cholesky分解成本为 $\\tfrac{1}{3}R^3$ flops，随后的两次三角求解总成本为 $2 I_n R^2$ flops。\n- 更新Gram矩阵的成本：更新 $A^{(n)}$ 后，以 $2 I_n R^2$ flops 的成本重新计算 $S^{(n)} = A^{(n)\\top} A^{(n)}$，以用于后续的模更新。\n- 内存模型：存储 $\\mathcal{X}$、所有 $\\{A^{(n)}\\}$、所有 $\\{S^{(n)}\\}$、一个用于最大 $M^{(n)} \\in \\mathbb{R}^{I_n \\times R}$ 的临时空间，以及一个用于 $H^{(n)} \\in \\mathbb{R}^{R \\times R}$ 的临时空间。\n\n**步骤2：使用提取的给定条件进行验证**\n该问题具有科学依据，描述了数值线性代数中的一个标准算法 (CP-ALS)。所提供的成本和内存模型是明确的，尽管经过简化，但并未违反任何数学或科学原理。问题是适定的、客观的、自洽的且内部一致的。关于$H^{(n)}$“朴素”计算的关键模糊之处，已通过指定在一次扫描内重新计算和重用Gram矩阵的规则得以解决，这指向了一种标准的、高效的ALS实现方案。因此，该问题是计算成本分析方面的一个有效练习。\n\n**步骤3：结论与行动**\n问题有效。将推导完整解法。\n\n### 解的推导\n\n让我们推导一次完整ALS扫描的总flop计数和峰值内存使用量，这涉及按顺序更新因子矩阵 $A^{(1)}, A^{(2)}, \\dots, A^{(N)}$。\n\n**第1部分：总Flop计数**\n\n总flop计数 $C_{\\text{total}}$ 是更新每个模 $n \\in \\{1,\\dots,N\\}$ 的成本之和。设 $C_n$ 为更新模 $n$ 的成本。\n$$ C_{\\text{total}} = \\sum_{n=1}^{N} C_n $$\n更新 $A^{(n)}$ 的过程包括几个步骤。我们假设在开始更新 $A^{(n)}$ 时，Gram矩阵 $\\{S^{(k)}\\}_{k=1}^{N}$ 是可用的，反映了因子矩阵的当前状态。\n\n1.  **MTTKRP计算**：计算模$n$的MTTKRP的成本，其结果是一个矩阵 $M^{(n)} \\in \\mathbb{R}^{I_n \\times R}$，给定为 $2\\,I_n \\left(\\prod_{m \\neq n} I_m\\right) R$。这可以简化为 $2R \\prod_{k=1}^{N} I_k$。\n    $$ C_{\\text{MTTKRP}, n} = 2R \\prod_{k=1}^{N} I_k $$\n\n2.  **$H^{(n)}$的构建**：矩阵 $H^{(n)} \\in \\mathbb{R}^{R \\times R}$ 是通过所有 $m \\neq n$ 的预计算Gram矩阵 $S^{(m)}$ 的逐元素乘积形成的。这需要 $N-2$ 次矩阵-矩阵Hadamard积。成本给定为：\n    $$ C_{H, n} = (N-2)R^2 $$\n\n3.  **求解线性系统**：通过求解正规方程来找到 $A^{(n)}$ 的更新。这涉及对 $H^{(n)}$ 进行Cholesky分解和两次三角求解。总成本为：\n    $$ C_{\\text{solve}, n} = \\frac{1}{3}R^3 + 2I_n R^2 $$\n\n4.  **Gram矩阵更新**：更新 $A^{(n)}$ 后，其对应的Gram矩阵 $S^{(n)} = A^{(n)\\top}A^{(n)}$ 被重新计算，以用于同一扫描中后续模的更新。这种稠密矩阵乘法的成本是：\n    $$ C_{S, n} = 2I_n R^2 $$\n\n更新模 $n$ 的总成本是这些部分的总和：\n$$ C_n = C_{\\text{MTTKRP}, n} + C_{H, n} + C_{\\text{solve}, n} + C_{S, n} $$\n$$ C_n = \\left(2R \\prod_{k=1}^{N} I_k\\right) + (N-2)R^2 + \\left(\\frac{1}{3}R^3 + 2I_n R^2\\right) + 2I_n R^2 $$\n$$ C_n = 2R \\prod_{k=1}^{N} I_k + \\frac{1}{3}R^3 + (N-2)R^2 + 4I_n R^2 $$\n\n为了找到一次扫描的总成本，我们将 $C_n$ 对 $n=1, \\dots, N$求和：\n$$ C_{\\text{total}} = \\sum_{n=1}^{N} \\left( 2R \\prod_{k=1}^{N} I_k + \\frac{1}{3}R^3 + (N-2)R^2 + 4I_n R^2 \\right) $$\n$$ C_{\\text{total}} = \\left(\\sum_{n=1}^{N} 2R \\prod_{k=1}^{N} I_k\\right) + \\left(\\sum_{n=1}^{N} \\frac{1}{3}R^3\\right) + \\left(\\sum_{n=1}^{N} (N-2)R^2\\right) + \\left(\\sum_{n=1}^{N} 4I_n R^2\\right) $$\n$$ C_{\\text{total}} = N \\left(2R \\prod_{k=1}^{N} I_k\\right) + N\\frac{1}{3}R^3 + N(N-2)R^2 + 4R^2\\sum_{n=1}^{N} I_n $$\n按 $R$ 的幂次对各项进行分组，总flop计数为：\n$$ C_{\\text{total}} = \\frac{N}{3}R^3 + \\left(N(N-2) + 4\\sum_{k=1}^{N} I_k\\right)R^2 + 2NR\\prod_{k=1}^{N} I_k $$\n\n**第2部分：峰值内存使用量**\n\n峰值内存使用量 $M_{\\text{peak}}$ 是存储所有指定数据结构所需的标量字总数。我们将永久和临时存储部分的大小相加。\n\n1.  **稠密张量 $\\mathcal{X}$**：大小为 $\\prod_{k=1}^{N} I_k$。\n2.  **因子矩阵 $\\{A^{(n)}\\}_{n=1}^{N}$**：每个 $A^{(n)}$ 的大小为 $I_n \\times R$。总大小为 $\\sum_{n=1}^{N} I_n R = R\\sum_{n=1}^{N} I_n$。\n3.  **Gram矩阵 $\\{S^{(n)}\\}_{n=1}^{N}$**：每个 $S^{(n)}$ 的大小为 $R \\times R$。总大小为 $\\sum_{n=1}^{N} R^2 = NR^2$。\n4.  **MTTKRP $M^{(n)}$ 的临时空间**：需要一个用于 $I_n \\times R$ 矩阵 $M^{(n)}$ 的缓冲区。为了适应任何模，其大小必须足以容纳最大的可能 $M^{(n)}$，即 $\\max_{k \\in \\{1,\\dots,N\\}} (I_k R) = R \\max_{k \\in \\{1,\\dots,N\\}} I_k$。\n5.  **$H^{(n)}$ 的临时空间**：需要一个大小为 $R \\times R$ 的缓冲区用于 $H^{(n)}$，对应于 $R^2$ 个标量。\n\n峰值内存是这些部分的总和：\n$$ M_{\\text{peak}} = \\left(\\prod_{k=1}^{N} I_k\\right) + \\left(R\\sum_{k=1}^{N} I_k\\right) + NR^2 + \\left(R \\max_{k \\in \\{1,\\dots,N\\}} I_k\\right) + R^2 $$\n合并各项，总峰值内存使用量为：\n$$ M_{\\text{peak}} = \\prod_{k=1}^{N} I_k + R\\left(\\sum_{k=1}^{N} I_k + \\max_{k \\in \\{1,\\dots,N\\}} I_k\\right) + (N+1)R^2 $$\n\n推导出的总flop计数和峰值内存使用量的两个表达式构成了问题的完整解。", "answer": "$$ \\boxed{\\pmatrix{ 2NR\\prod_{k=1}^{N} I_k + \\left(N(N-2) + 4\\sum_{k=1}^{N} I_k\\right)R^2 + \\frac{N}{3}R^3  \\prod_{k=1}^{N} I_k + R\\left( \\sum_{k=1}^{N} I_k + \\max_{k \\in \\{1,\\dots,N\\}} I_k \\right) + (N+1)R^2 }} $$", "id": "3586499"}, {"introduction": "交替最小二乘算法依赖于重复求解线性最小二乘子问题，而用于这些求解的数值方法会极大地影响最终结果的准确性。本练习比较了两种经典方法——正规方程法和QR分解法——以揭示在处理病态矩阵时可能出现的严重精度损失 ([@problem_id:3533190])。这一分析突显了数值计算中的一个关键原则：算法的选择与数学公式本身同等重要。", "problem": "考虑CANDECOMP/PARAFAC (CP) 分解中的单次交替最小二乘 (ALS) 更新。为更新因子矩阵 $A \\in \\mathbb{R}^{I_{A} \\times R}$，需要逐行求解具有公共设计矩阵 $Z \\in \\mathbb{R}^{(I_{B} I_{C}) \\times R}$ 的超定最小二乘问题。该设计矩阵由 Khatri–Rao 积 $Z = C \\odot B$ 给出，其中 $B \\in \\mathbb{R}^{I_{B} \\times R}$ 且 $C \\in \\mathbb{R}^{I_{C} \\times R}$。右端项通过矩阵化张量与 Khatri–Rao 积的乘积 (MTTKRP) 获得。假设 $Z$ 具有满列秩，并且计算在浮点算术下进行，单位舍入误差为 $u$。使用两种经典方法：\n\n- 正规方程结合 Cholesky 分解：构建 $G = Z^{\\top} Z$ 并通过 Cholesky 分解求解 $G x = Z^{\\top} b$。\n- 正交-三角 (QR) 分解：计算一个瘦 QR 分解 $Z = Q R$（其中 $Q^{\\top} Q = I$），然后求解 $R x = Q^{\\top} b$。\n\n从 2-范数条件数 $\\kappa_{2}(Z) = \\sigma_{\\max}(Z)/\\sigma_{\\min}(Z)$ 的奇异值分解定义、 $Z$ 的奇异值与 $Z^{\\top} Z$ 奇异值之间的关系，以及 Cholesky 和 QR 分解的标准后向稳定性属性出发，比较这两种使用设计矩阵 $Z = C \\odot B$ 求解超定最小二乘问题方法的前向精度。在你的比较中，仅使用以下基本事实：(i) 谱范数是次乘性的，(ii) $Z^{\\top} Z$ 的奇异值是 $Z$ 的奇异值的平方，(iii) 满秩矩阵的 QR 分解是后向稳定的，以及 (iv) 对称正定矩阵的 Cholesky 分解是后向稳定的。你也可以使用 Khatri–Rao 积满足 $Z = C \\odot B$ 并且是 Kronecker 积 $C \\otimes B$ 的一个列子矩阵这一事实，以及关于 Kronecker 积的已知范数恒等式。\n\n用 $u$ 和 $\\kappa_{2}(Z)$ 来量化精度差距，然后在以下具体场景中进行评估：假设 $\\kappa_{2}(B) = 10^{4}$，$\\kappa_{2}(C) = 10^{3}$，并使用 IEEE 双精度（$u \\approx 10^{-16}$）。选择所有正确的陈述。\n\nA. 在浮点运算中，正规方程加 Cholesky 分解的路径对每个右端项产生的最小二乘解的前向相对误差约为 $u \\,\\kappa_{2}(Z)^{2}$ 量级，而正交-三角 (QR) 路径产生的前向相对误差约为 $u \\,\\kappa_{2}(Z)$ 量级。因此，相对于 QR 方法，正规方程方法大约会额外损失 $\\log_{10}\\!\\big(\\kappa_{2}(Z)\\big)$ 个正确的十进制位数。对于给定的数值，我们可以界定 $\\kappa_{2}(Z) \\le \\kappa_{2}(C)\\,\\kappa_{2}(B) = 10^{7}$，因此误差大小约为 $10^{-2}$（正规方程）对 $10^{-9}$（QR），即正规方程方法额外损失了大约 7 个有效数字。\n\nB. 因为 $(C \\odot B)^{\\top} (C \\odot B) = (C^{\\top} C) \\circ (B^{\\top} B)$ 是一个 Hadamard 积，所以正规方程的条件数至多为 $\\max\\{\\kappa_{2}(B)^{2}, \\kappa_{2}(C)^{2}\\}$，这意味着相对于 QR 方法没有渐近精度损失。\n\nC. 如果 $B$ 和 $C$ 的列被缩放到单位范数，那么无论列相关性如何，$\\kappa_{2}(C \\odot B) = 1$，因此两种方法在常数因子内具有可比的精度。\n\nD. 当 $Z$ 是非常高瘦的矩阵，即 $(I_{B} I_{C}) \\gg R$ 时，两种方法实现的前向相对误差都在 $u$ 的量级，且与 $\\kappa_{2}(Z)$ 无关，因此在这种情况下它们之间没有有意义的精度差距。", "solution": "用户要求比较解决在规范多元 (CP) 分解的交替最小二乘 (ALS) 算法中出现的超定最小二乘问题的两种方法的前向精度。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **问题背景**：规范多元 (CP) 分解中因子矩阵 $A \\in \\mathbb{R}^{I_{A} \\times R}$ 的单次 ALS 更新。\n- **任务**：逐行求解超定最小二乘问题 $\\min_{x} \\|Zx-b\\|_{2}$。\n- **设计矩阵**：$Z \\in \\mathbb{R}^{(I_{B} I_{C}) \\times R}$，其中 $Z = C \\odot B$ (Khatri-Rao 积)。\n- **因子矩阵**：$B \\in \\mathbb{R}^{I_{B} \\times R}$ 和 $C \\in \\mathbb{R}^{I_{C} \\times R}$。\n- **右端项**：$b$ 来自矩阵化张量与 Khatri–Rao 积的乘积 (MTTKRP)。\n- **假设**：$Z$ 具有满列秩。计算在浮点算术下进行，单位舍入误差为 $u$。\n- **方法 1 (正规方程)**：构建 $G = Z^{\\top} Z$ 并使用 Cholesky 分解求解 $Gx = Z^{\\top} b$。\n- **方法 2 (QR 分解)**：计算瘦 QR 分解 $Z = QR$ 并求解 $Rx = Q^{\\top}b$。\n- **基本事实**：\n    (i) 谱范数是次乘性的。\n    (ii) $Z^{\\top} Z$ 的奇异值是 $Z$ 的奇异值的平方。\n    (iii) 满秩矩阵的 QR 分解是后向稳定的。\n    (iv) 对称正定矩阵的 Cholesky 分解是后向稳定的。\n- **附加信息**：可以使用 $Z = C \\odot B$ 是 $C \\otimes B$ 的列子矩阵以及 Kronecker 积的已知范数恒等式。\n- **数值场景**：$\\kappa_{2}(B) = 10^{4}$，$\\kappa_{2}(C) = 10^{3}$，$u \\approx 10^{-16}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题陈述在科学上是合理的、适定的和客观的。它提出了一个关于求解最小二乘问题的算法稳定性的数值线性代数标准问题。CP-ALS 的背景是恰当的，因为这些子问题是该算法的核心组成部分。给出的事实是矩阵分析和数值分析的标准结果。假设清晰且足以进行所要求的比较。该问题没有违反任何无效标准。\n\n**步骤 3：结论与行动**\n该问题有效。我将继续进行详细的推导和评估。\n\n### 推导与求解\n\n问题的核心是比较通过正规方程与通过 QR 分解计算的最小二乘解的前向误差。设 $\\min_{x} \\|Zx - b\\|_{2}$ 的精确解为 $x_{LS} = (Z^{\\top}Z)^{-1}Z^{\\top}b$。对于一个计算解 $\\hat{x}$，其相对前向误差由 $\\frac{\\|\\hat{x} - x_{LS}\\|_{2}}{\\|x_{LS}\\|_{2}}$ 给出。\n\n**1. 正规方程 (NE) 方法分析**\n\n此方法包括两个主要步骤：\n1.  构建正规方程矩阵 $G = Z^{\\top}Z$ 和向量 $Z^{\\top}b$。\n2.  使用 Cholesky 分解求解线性系统 $Gx = Z^{\\top}b$。\n\n数值不稳定性的主要来源是 $G = Z^{\\top}Z$ 的构建，这会显式地将问题的条件数平方。\n\n-   设 $Z$ 的奇异值为 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\dots \\ge \\sigma_{R} > 0$。\n-   $Z$ 的 2-范数条件数为 $\\kappa_{2}(Z) = \\frac{\\sigma_{\\max}(Z)}{\\sigma_{\\min}(Z)} = \\frac{\\sigma_{1}}{\\sigma_{R}}$。\n-   根据给定的事实 (ii)，$G = Z^{\\top}Z$ 的奇异值是 $Z$ 的奇异值的平方。对称正定矩阵 $G$ 的特征值就是其奇异值，所以 $\\lambda_{i}(G) = \\sigma_{i}(Z)^{2}$。\n-   因此，$G$ 的条件数为：\n    $$ \\kappa_{2}(G) = \\frac{\\lambda_{\\max}(G)}{\\lambda_{\\min}(G)} = \\frac{\\sigma_{\\max}(Z)^{2}}{\\sigma_{\\min}(Z)^{2}} = \\left(\\frac{\\sigma_{\\max}(Z)}{\\sigma_{\\min}(Z)}\\right)^{2} = \\kappa_{2}(Z)^{2} $$\n-   用于求解 $Gx = Z^{\\top}b$ 的 Cholesky 分解是后向稳定的（事实 (iv)）。这意味着计算出的解 $\\hat{x}_{NE}$ 是一个邻近系统的精确解。求解线性系统 $Ax=b$ 的标准前向误差分析表明，相对前向误差由一个与矩阵条件数成正比的量界定，即 $\\frac{\\|\\delta x\\|_{2}}{\\|x\\|_{2}} \\lesssim u \\kappa_{2}(A)$。\n-   将此应用于系统 $Gx=Z^{\\top}b$，仅求解该系统所产生的误差量级为 $u \\kappa_{2}(G) = u \\kappa_{2}(Z)^{2}$。这甚至还没有考虑构建 $G$ 和 $Z^{\\top}b$ 时的误差。完整的分析证实，NE 方法的前向误差由该项主导。\n-   因此，正规方程方法的相对前向误差约为 $\\mathcal{O}(u \\, \\kappa_{2}(Z)^{2})$。\n\n**2. QR 分解方法分析**\n\n该方法避免了构建 $Z^{\\top}Z$。\n1.  计算瘦 QR 分解 $Z = QR$，其中 $Q \\in \\mathbb{R}^{(I_{B} I_{C}) \\times R}$ 具有标准正交列（$Q^{\\top}Q=I_{R}$），$R \\in \\mathbb{R}^{R \\times R}$ 是上三角矩阵。\n2.  最小二乘问题 $\\min \\|Zx-b\\|_{2}$ 被转换为 $\\min \\|QRx-b\\|_{2}$。由于 $Q$ 是一个正交变换（保持 2-范数），这等价于 $\\min \\|Rx - Q^{\\top}b\\|_{2}$。\n3.  因为 $Z$ 具有满列秩，$R$ 是可逆的，通过求解三角系统 $Rx = Q^{\\top}b$ 即可找到解。\n\n-   满秩矩阵的 QR 分解是后向稳定的（事实 (iii)）。标准分析表明，计算出的解 $\\hat{x}_{QR}$ 是一个涉及 $(Z+\\delta Z)$ 和 $(b+\\delta b)$ 的轻微扰动问题的精确最小二乘解。\n-   QR 方法得到的前向误差界约为 $\\mathcal{O}(u \\, \\kappa_{2}(Z))$，忽略了依赖于残差范数的项（这些项也可能很重要）。对于矩阵条件敏感性的一般比较，这是关键项。\n\n**3. 比较与量化**\n-   **正规方程误差**：$\\approx C_{NE} \\, u \\, \\kappa_{2}(Z)^{2}$\n-   **QR 分解误差**：$\\approx C_{QR} \\, u \\, \\kappa_{2}(Z)$\n-   因子 $\\kappa_{2}(Z)$ 代表了精度差距。如果 $\\kappa_{2}(Z)$ 很大，正规方程方法的精度可能会显著降低。\n-   一个相对误差为 $\\epsilon$ 的结果中正确的十进制位数大约为 $-\\log_{10}(\\epsilon)$。\n-   NE 相对于 QR 额外损失的位数 = $(-\\log_{10}(\\text{Error}_{QR})) - (-\\log_{10}(\\text{Error}_{NE})) \\approx (-\\log_{10}(u \\, \\kappa_{2}(Z))) - (-\\log_{10}(u \\, \\kappa_{2}(Z)^{2})) = \\log_{10}(u \\, \\kappa_{2}(Z)^{2}) - \\log_{10}(u \\, \\kappa_{2}(Z)) = \\log_{10}\\left(\\frac{u \\, \\kappa_{2}(Z)^{2}}{u \\, \\kappa_{2}(Z)}\\right) = \\log_{10}(\\kappa_{2}(Z))$。\n\n**4. 具体场景评估**\n-   给定：$\\kappa_{2}(B) = 10^{4}$，$\\kappa_{2}(C) = 10^{3}$，$u \\approx 10^{-16}$。\n-   问题允许使用关于 Khatri-Rao 积 $Z = C \\odot B$ 与 Kronecker 积 $C \\otimes B$ 相关的属性。一个标准结果是不等式 $\\kappa_{2}(C \\odot B) \\le \\kappa_{2}(C) \\kappa_{2}(B)$。这为 $Z$ 的条件数提供了一个上界。\n-   使用此界限：$\\kappa_{2}(Z) \\le \\kappa_{2}(C)\\kappa_{2}(B) = 10^{3} \\times 10^{4} = 10^{7}$。\n-   我们用这个值进行估计： $\\kappa_{2}(Z) \\approx 10^{7}$。\n-   **NE 误差估计**：$u \\, \\kappa_{2}(Z)^{2} \\approx 10^{-16} \\times (10^{7})^{2} = 10^{-16} \\times 10^{14} = 10^{-2}$。\n-   **QR 误差估计**：$u \\, \\kappa_{2}(Z) \\approx 10^{-16} \\times 10^{7} = 10^{-9}$。\n-   **NE 额外损失的位数**：$\\log_{10}(\\kappa_{2}(Z)) \\approx \\log_{10}(10^{7}) = 7$。\n\n### 逐项分析\n\n**A. 在浮点运算中，正规方程加 Cholesky 分解的路径对每个右端项产生的最小二乘解的前向相对误差约为 $u \\,\\kappa_{2}(Z)^{2}$ 量级，而正交-三角 (QR) 路径产生的前向相对误差约为 $u \\,\\kappa_{2}(Z)$ 量级。因此，相对于 QR 方法，正规方程方法大约会额外损失 $\\log_{10}\\!\\big(\\kappa_{2}(Z)\\big)$ 个正确的十进制位数。对于给定的数值，我们可以界定 $\\kappa_{2}(Z) \\le \\kappa_{2}(C)\\,\\kappa_{2}(B) = 10^{7}$，因此误差大小约为 $10^{-2}$（正规方程）对 $10^{-9}$（QR），即正规方程方法额外损失了大约 7 个有效数字。**\n该陈述与上述推导完全吻合。它正确地指出了两种方法前向误差的数量级，正确地量化了以位数表示的精度损失，正确地应用了 Khatri-Rao 积条件数的标准不等式，并为给定场景正确地计算了估计误差和损失的位数。\n**结论：正确**\n\n**B. 因为 $(C \\odot B)^{\\top} (C \\odot B) = (C^{\\top} C) \\circ (B^{\\top} B)$ 是一个 Hadamard 积，所以正规方程的条件数至多为 $\\max\\{\\kappa_{2}(B)^{2}, \\kappa_{2}(C)^{2}\\}$，这意味着相对于 QR 方法没有渐近精度损失。**\n恒等式 $(C \\odot B)^{\\top} (C \\odot B) = (C^{\\top} C) \\circ (B^{\\top} B)$ 是正确的。然而，后续关于条件数的论断 $\\kappa_{2}((C^{\\top} C) \\circ (B^{\\top} B)) \\le \\max\\{\\kappa_{2}(C^{\\top} C), \\kappa_{2}(B^{\\top} B)\\}$ 是不正确的。矩阵分析中没有通用定理能为两个半正定矩阵的 Hadamard 积的条件数提供如此紧凑的界。Hadamard 积的条件数通常不受单个条件数的最大值限制。实际上，标准界限将其与条件数的乘积相关联，而不是最大值。因此，“没有渐近精度损失”的结论是基于一个错误的前提。\n**结论：不正确**\n\n**C. 如果 $B$ 和 $C$ 的列被缩放到单位范数，那么无论列相关性如何，$\\kappa_{2}(C \\odot B) = 1$，因此两种方法在常数因子内具有可比的精度。**\n如果列 $b_r$ 和 $c_r$ 具有单位范数，那么 $Z = C \\odot B$ 的列（即 $z_r = c_r \\otimes b_r$）也具有单位范数，因为 $\\|z_r\\|_2 = \\|c_r \\otimes b_r\\|_2 = \\|c_r\\|_2 \\|b_r\\|_2 = 1 \\times 1 = 1$。然而，要使 $\\kappa_2(Z)$ 为 1，矩阵 $Z$ 必须具有标准正交列，即 $Z^{\\top}Z = I$。$Z^{\\top}Z$ 的第 $(i,j)$ 个元素是 $(c_i^{\\top}c_j)(b_i^{\\top}b_j)$。对于 $i \\neq j$，该乘积必须为零。这并不能得到保证；如果 $C$ 和 $B$ 内部的列是相关的（即不正交），则该乘积将不为零。短语“无论列相关性如何”使得该陈述绝对错误。即使所有列都已归一化，列之间的高度相关性也可能使 $\\kappa_2(Z)$ 任意大。\n**结论：不正确**\n\n**D. 当 $Z$ 是非常高瘦的矩阵，即 $(I_{B} I_{C}) \\gg R$ 时，两种方法实现的前向相对误差都在 $u$ 的量级，且与 $\\kappa_{2}(Z)$ 无关，因此在这种情况下它们之间没有有意义的精度差距。**\n这是一个错误的论断。对于最小二乘解算器，无论是 NE 还是 QR 方法，其标准的前向误差界都从根本上取决于条件数 $\\kappa_{2}(Z)$。解 $x_{LS}$ 对 $Z$ 和 $b$ 中扰动的敏感性由 $\\kappa_{2}(Z)$ 控制，无论矩阵的维度如何。矩阵“高瘦”的几何形状并不能消除这种固有的敏感性。虽然对于某些随机矩阵系综，条件数可能随着维度的增长而表现良好，但对于一个*给定*的矩阵 $Z$，误差界总是取决于*其*条件数。没有一般性原则能使误差为 $\\mathcal{O}(u)$。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3533190"}]}