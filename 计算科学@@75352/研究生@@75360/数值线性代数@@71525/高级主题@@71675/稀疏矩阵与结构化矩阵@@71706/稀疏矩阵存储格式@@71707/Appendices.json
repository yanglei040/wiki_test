{"hands_on_practices": [{"introduction": "选择稀疏矩阵的存储格式并非任意，它对算法性能有重大影响。本练习将指导你构建一个简单而强大的性能模型（屋顶线模型），用于比较坐标列表（COO）和压缩稀疏行（CSR）这两种格式在执行基本稀疏矩阵向量乘法（SpMV）核心计算时的表现。通过量化内存访问量，这项实践将阐明存储简单性（COO）与性能效率（CSR）之间的权衡。[@problem_id:3271435]", "problem": "您的任务是设计并实现一个程序，用于预测两种常见稀疏存储格式——压缩稀疏行 (CSR) 和坐标列表 (COO)——的稀疏矩阵向量乘法的性能。此任务侧重于基础科学计算原理、计算成本和内存流量建模，以及应用性能模型来估计运行时间。您的程序必须为给定的测试套件计算预测的运行时间，并以单一指定格式输出结果。\n\n从以下基本依据开始：\n\n- 稀疏矩阵向量乘法计算 $y = A x$，其中 $A$ 是稀疏矩阵。对于每个非零元素 $a_{ij}$，计算涉及一次乘法和一次加法，即每个非零元素总共有 $2$ 次浮点运算。\n- 在一个与 roofline 方法一致的简单性能模型中，总时间 $T$ 的估算公式为\n$$\nT = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}}{B_{\\mathrm{peak}}}\\right),\n$$\n其中 $\\text{FLOPs}$ 是浮点运算次数，$P_{\\mathrm{peak}}$ 是以 $\\mathrm{FLOP/s}$ 为单位的峰值浮点吞吐量，$\\text{Bytes}$ 是以字节为单位的总数据流量，$B_{\\mathrm{peak}}$ 是以 $\\mathrm{byte/s}$ 为单位的峰值内存带宽。\n- 对于 CSR 和 COO 格式，在流式和非排序 COO 累加的假设下（由于缓存，向量元素不被重用，并且 COO 对每个非零元直接累加到 $y$ 中），移动的总字节数可以从算法循环和数据结构中推导出来：\n  - CSR 格式存储值、列索引和行指针的数组。其实现遍历各行，在寄存器中累加 $y_i$，并且每行只写一次。移动的字节数建模为\n  $$\n  \\text{Bytes}_{\\mathrm{CSR}} = \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{(n+1) \\cdot i_{\\mathrm{bytes}}}_{\\text{行指针}} + \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{n \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 存储}}.\n  $$\n  - COO 格式存储值、行索引和列索引的数组。其实现对每个非零元直接累加到 $y$ 中，即对每个非零元都读取和写入 $y$。移动的字节数建模为\n  $$\n  \\text{Bytes}_{\\mathrm{COO}} = \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{n n z \\cdot i_{\\mathrm{bytes}}}_{\\text{行索引}} + \\underbrace{n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{2 \\cdot n n z \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 读和写}}.\n  $$\n- $y = A x$ 的浮点运算次数为\n$$\n\\text{FLOPs} = 2 \\cdot n n z.\n$$\n\n在代码中实现上述模型，并为每个测试用例计算 CSR 和 COO 的预测运行时间（以秒为单位），除非另有说明，否则假设值为双精度。\n\n对所有测试用例使用以下硬件参数：\n- 峰值浮点吞吐量 $P_{\\mathrm{peak}} = 100 \\times 10^9$ $\\mathrm{FLOP/s}$。\n- 峰值内存带宽 $B_{\\mathrm{peak}} = 50 \\times 10^9$ $\\mathrm{byte/s}$。\n\n您的程序必须处理以下测试套件，其中每个测试用例是一个元组 $(n, m, n n z, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}})$：\n- 测试 1：$(1000, 1000, 50000, 4, 8)$。\n- 测试 2：$(5, 5, 7, 8, 8)$。\n- 测试 3：$(10000, 10000, 10000, 4, 8)$。\n- 测试 4：$(20000, 2000, 80000, 4, 8)$。\n- 测试 5：$(3000, 3000, 600000, 8, 8)$。\n\n对于每个测试用例：\n- 计算 $\\text{FLOPs}$。\n- 计算 $\\text{Bytes}_{\\mathrm{CSR}}$ 和 $\\text{Bytes}_{\\mathrm{COO}}$。\n- 计算 $T_{\\mathrm{CSR}} = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}_{\\mathrm{CSR}}}{B_{\\mathrm{peak}}}\\right)$ 和 $T_{\\mathrm{COO}} = \\max\\left(\\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}, \\frac{\\text{Bytes}_{\\mathrm{COO}}}{B_{\\mathrm{peak}}}\\right)$。\n\n科学真实性约束：\n- 所有值 $n$、$m$ 和 $n n z$ 都是严格的正整数。\n- 索引大小 $i_{\\mathrm{bytes}}$ 为 $4$ 或 $8$ 字节。\n- 值大小 $v_{\\mathrm{bytes}}$ 为 $4$ 或 $8$ 字节；如果 $v_{\\mathrm{bytes}} = 8$，则将矩阵解释为双精度。\n\n角度单位不适用。除秒之外，不使用其他物理单位。所有运行时间均以秒为单位表示，并四舍五入到六位小数的浮点数。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表，每个测试用例对应一对用方括号括起来的数值 $[T_{\\mathrm{CSR}}, T_{\\mathrm{COO}}]$，并按顺序排列。\n- 例如，输出必须如下所示\n$$\n\\text{[[t_{1,\\mathrm{CSR}},t_{1,\\mathrm{COO}}],[t_{2,\\mathrm{CSR}},t_{2,\\mathrm{COO}}],\\dots]}\n$$\n每个 $t$ 都以秒为单位，四舍五入到六位小数。", "solution": "该问题要求制定并实现一个性能模型，以预测两种不同稀疏矩阵存储格式——压缩稀疏行 (CSR) 和坐标列表 (COO)——的稀疏矩阵向量乘法 (SpMV) 的运行时间。该分析基于一个简化的 roofline 模型，这是高性能计算中的一个基本概念，用于根据硬件的峰值浮点吞吐量和内存带宽来估计算法的性能边界。\n\n该性能模型的核心是估算总执行时间 $T$，即计算所需时间 $T_{\\text{compute}}$ 和内存访问所需时间 $T_{\\text{memory}}$ 的最大值：\n$$T = \\max\\left(T_{\\text{compute}}, T_{\\text{memory}}\\right)$$\n这些分量由浮点运算总数 ($\\text{FLOPs}$)、处理器与主内存之间传输的总数据字节数 ($\\text{Bytes}$) 以及机器的峰值性能特征决定：\n$$T_{\\text{compute}} = \\frac{\\text{FLOPs}}{P_{\\mathrm{peak}}}$$\n$$T_{\\text{memory}} = \\frac{\\text{Bytes}}{B_{\\mathrm{peak}}}$$\n问题提供了以下硬件参数，这些参数在所有测试用例中都是恒定的：\n- 峰值浮点吞吐量: $P_{\\mathrm{peak}} = 100 \\times 10^9$ $\\mathrm{FLOP/s}$。\n- 峰值内存带宽: $B_{\\mathrm{peak}} = 50 \\times 10^9$ $\\mathrm{byte/s}$。\n\nSpMV 运算计算 $y = A x$，其中 $A$ 是一个 $n \\times m$ 的稀疏矩阵，有 $nnz$ 个非零元素。对于每个非零元素 $a_{ij}$，会执行一次乘法 ($a_{ij} \\cdot x_j$) 和一次加法（加到 $y_i$ 的累加器中）。因此，总 FLOP 计数为：\n$$\\text{FLOPs} = 2 \\cdot nnz$$\n\n内存流量模型基于每种格式特定的算法假设。\n对于 CSR 格式，它存储非零值、列索引和一个行指针数组，假定的算法在寄存器中为每行 $y_i$ 累加结果，并且每行只将最终值写入内存一次。总内存流量 $\\text{Bytes}_{\\mathrm{CSR}}$ 是从三个 CSR 数据数组（值、列索引、行指针）读取、从输入向量 $x$ 读取以及向输出向量 $y$ 写入的总和：\n$$\\text{Bytes}_{\\mathrm{CSR}} = \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{(n+1) \\cdot i_{\\mathrm{bytes}}}_{\\text{行指针}} + \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{n \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 存储}}$$\n这里，$v_{\\mathrm{bytes}}$ 是一个值的字节大小，$i_{\\mathrm{bytes}}$ 是一个索引的字节大小。这可以简化为：\n$$\\text{Bytes}_{\\mathrm{CSR}} = nnz \\cdot (2 v_{\\mathrm{bytes}} + i_{\\mathrm{bytes}}) + (n+1)i_{\\mathrm{bytes}} + n \\cdot v_{\\mathrm{bytes}}$$\n\n对于 COO 格式，它在三个独立的数组中存储值、行索引和列索引，假定的算法对每个非零元素在输出向量 $y$ 上执行原子性的读-改-写操作。总内存流量 $\\text{Bytes}_{\\mathrm{COO}}$ 是：\n$$\\text{Bytes}_{\\mathrm{COO}} = \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{值}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{列索引}} + \\underbrace{nnz \\cdot i_{\\mathrm{bytes}}}_{\\text{行索引}} + \\underbrace{nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } x} + \\underbrace{2 \\cdot nnz \\cdot v_{\\mathrm{bytes}}}_{\\text{向量 } y \\text{ 读/写}}$$\n这可以简化为：\n$$\\text{Bytes}_{\\mathrm{COO}} = nnz \\cdot (4 v_{\\mathrm{bytes}} + 2 i_{\\mathrm{bytes}})$$\n\n现在我们将这些模型应用于每个测试用例。所有运行时间均以秒为单位报告，并四舍五入到六位小数。\n\n**测试用例 1：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (1000, 1000, 50000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 50000 = 100000$。\n- $T_{\\text{compute}} = \\frac{100000}{100 \\times 10^9} = 1.0 \\times 10^{-6} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 50000 \\cdot (2 \\cdot 8 + 4) + (1000+1) \\cdot 4 + 1000 \\cdot 8 = 1012004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{1012004}{50 \\times 10^9} \\approx 2.024008 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.0 \\times 10^{-6}, 2.024008 \\times 10^{-5}) \\approx 0.000020 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 50000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 2000000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{2000000}{50 \\times 10^9} = 4.0 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.0 \\times 10^{-6}, 4.0 \\times 10^{-5}) = 0.000040 \\text{ s}$。\n\n**测试用例 2：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (5, 5, 7, 8, 8)$\n- $\\text{FLOPs} = 2 \\cdot 7 = 14$。\n- $T_{\\text{compute}} = \\frac{14}{100 \\times 10^9} = 1.4 \\times 10^{-10} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 7 \\cdot (2 \\cdot 8 + 8) + (5+1) \\cdot 8 + 5 \\cdot 8 = 256$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{256}{50 \\times 10^9} = 5.12 \\times 10^{-9} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.4 \\times 10^{-10}, 5.12 \\times 10^{-9}) \\approx 0.000000 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 7 \\cdot (4 \\cdot 8 + 2 \\cdot 8) = 336$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{336}{50 \\times 10^9} = 6.72 \\times 10^{-9} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.4 \\times 10^{-10}, 6.72 \\times 10^{-9}) \\approx 0.000000 \\text{ s}$。\n\n**测试用例 3：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (10000, 10000, 10000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 10000 = 20000$。\n- $T_{\\text{compute}} = \\frac{20000}{100 \\times 10^9} = 2.0 \\times 10^{-7} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 10000 \\cdot (2 \\cdot 8 + 4) + (10000+1) \\cdot 4 + 10000 \\cdot 8 = 320004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{320004}{50 \\times 10^9} \\approx 6.40008 \\times 10^{-6} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(2.0 \\times 10^{-7}, 6.40008 \\times 10^{-6}) \\approx 0.000006 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 10000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 400000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{400000}{50 \\times 10^9} = 8.0 \\times 10^{-6} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(2.0 \\times 10^{-7}, 8.0 \\times 10^{-6}) = 0.000008 \\text{ s}$。\n\n**测试用例 4：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (20000, 2000, 80000, 4, 8)$\n- $\\text{FLOPs} = 2 \\cdot 80000 = 160000$。\n- $T_{\\text{compute}} = \\frac{160000}{100 \\times 10^9} = 1.6 \\times 10^{-6} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 80000 \\cdot (2 \\cdot 8 + 4) + (20000+1) \\cdot 4 + 20000 \\cdot 8 = 1840004$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{1840004}{50 \\times 10^9} \\approx 3.680008 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.6 \\times 10^{-6}, 3.680008 \\times 10^{-5}) \\approx 0.000037 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 80000 \\cdot (4 \\cdot 8 + 2 \\cdot 4) = 3200000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{3200000}{50 \\times 10^9} = 6.4 \\times 10^{-5} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.6 \\times 10^{-6}, 6.4 \\times 10^{-5}) = 0.000064 \\text{ s}$。\n\n**测试用例 5：** $(n, m, nnz, i_{\\mathrm{bytes}}, v_{\\mathrm{bytes}}) = (3000, 3000, 600000, 8, 8)$\n- $\\text{FLOPs} = 2 \\cdot 600000 = 1200000$。\n- $T_{\\text{compute}} = \\frac{1200000}{100 \\times 10^9} = 1.2 \\times 10^{-5} \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{CSR}} = 600000 \\cdot (2 \\cdot 8 + 8) + (3000+1) \\cdot 8 + 3000 \\cdot 8 = 14448008$ 字节。\n- $T_{\\text{mem, CSR}} = \\frac{14448008}{50 \\times 10^9} \\approx 2.8896016 \\times 10^{-4} \\text{ s}$。\n- $T_{\\mathrm{CSR}} = \\max(1.2 \\times 10^{-5}, 2.8896016 \\times 10^{-4}) \\approx 0.000289 \\text{ s}$。\n- $\\text{Bytes}_{\\mathrm{COO}} = 600000 \\cdot (4 \\cdot 8 + 2 \\cdot 8) = 28800000$ 字节。\n- $T_{\\text{mem, COO}} = \\frac{28800000}{50 \\times 10^9} = 5.76 \\times 10^{-4} \\text{ s}$。\n- $T_{\\mathrm{COO}} = \\max(1.2 \\times 10^{-5}, 5.76 \\times 10^{-4}) = 0.000576 \\text{ s}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes predicted runtimes for sparse matrix-vector multiplication (SpMV)\n    for CSR and COO formats based on a simplified roofline performance model.\n    \"\"\"\n\n    # Define hardware parameters from the problem statement.\n    P_peak = 100e9  # Peak floating point throughput in FLOP/s\n    B_peak = 50e9   # Peak memory bandwidth in byte/s\n\n    # Define the test suite. Each tuple is (n, m, nnz, i_bytes, v_bytes).\n    test_cases = [\n        (1000, 1000, 50000, 4, 8),\n        (5, 5, 7, 8, 8),\n        (10000, 10000, 10000, 4, 8),\n        (20000, 2000, 80000, 4, 8),\n        (3000, 3000, 600000, 8, 8),\n    ]\n\n    # List to store the results for each test case as a [T_csr, T_coo] pair.\n    results = []\n\n    for case in test_cases:\n        n, m, nnz, i_bytes, v_bytes = case\n\n        # 1. Compute FLOPs\n        # Each nonzero element results in one multiplication and one addition.\n        flops = 2 * nnz\n\n        # 2. Compute compute time\n        t_compute = flops / P_peak\n\n        # 3. Compute Bytes transferred for CSR format\n        # Bytes_CSR = (nnz*v_bytes) + (nnz*i_bytes) + ((n+1)*i_bytes) + (nnz*v_bytes) + (n*v_bytes)\n        bytes_csr = nnz * (2 * v_bytes + i_bytes) + (n + 1) * i_bytes + n * v_bytes\n        \n        # 4. Compute Bytes transferred for COO format\n        # Bytes_COO = (nnz*v_bytes) + (nnz*i_bytes) + (nnz*i_bytes) + (nnz*v_bytes) + (2*nnz*v_bytes)\n        bytes_coo = nnz * (4 * v_bytes + 2 * i_bytes)\n\n        # 5. Compute memory-bound times\n        t_mem_csr = bytes_csr / B_peak\n        t_mem_coo = bytes_coo / B_peak\n\n        # 6. Compute final predicted runtimes using the roofline model\n        t_csr = max(t_compute, t_mem_csr)\n        t_coo = max(t_compute, t_mem_coo)\n\n        results.append((t_csr, t_coo))\n\n    # Format the output as specified: [[t_1_csr,t_1_coo],[t_2_csr,t_2_coo],...]\n    # Runtimes are rounded to six decimal places.\n    output_pairs = [f\"[{t_csr:.6f},{t_coo:.6f}]\" for t_csr, t_coo in results]\n    final_output_string = f\"[{','.join(output_pairs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3271435"}, {"introduction": "在理解了CSR和COO格式的基础上，本练习将探讨一个关键且常见的陷阱：从坐标格式转换为压缩格式时的正确性问题。通过一个反例，你将看到为何在转换为CSR格式之前未能对重复元素进行求和会导致计算结果出错。这项练习将加深你对不同格式语义差异的理解，并强调正确数据预处理的重要性。[@problem_id:3580366]", "problem": "考虑一个稀疏矩阵向量乘法 (SpMV)，定义为 $y \\leftarrow A x$，其中 $A \\in \\mathbb{R}^{m \\times n}$，$x \\in \\mathbb{R}^{n}$，以及 $y \\in \\mathbb{R}^{m}$。在坐标列表 (COO) 格式中，矩阵 $A$ 由三元组 $(i_k, j_k, v_k)$（其中 $k = 1, \\ldots, K$）指定，这些三元组表示矩阵元素 $a_{i_k j_k}$。当多个三元组共享相同的索引对 $(i, j)$ 时，这些元素通过求和累加到代数矩阵 $A$ 中。在压缩稀疏行 (CSR) 格式中，矩阵由三个数组表示，它们为每一行 $i$ 编码了一个包含列索引和值的连续段。在结构上，CSR 表示对每个结构位置 $(i, j)$ 只保存一个存储值。\n\n根据第一性原理，SpMV 计算 $y_i = \\sum_{j=1}^{n} a_{ij} x_j$ 对每个 $i \\in \\{1, \\ldots, m\\}$ 成立，其中 $a_{ij}$ 表示通过对重复项求和来聚合所有 COO 三元组后得到的代数矩阵元素。在有限元组装和其他加性离散化方法中，COO 格式中的重复项很常见，必须在形成 CSR 格式之前合并成单个 $a_{ij}$，以反映真实的代数矩阵。\n\n假设一个实现将 COO 转换为 CSR，但没有通过对重复的 $(i, j)$ 对的值求和来显式地合并重复项。相反，它通过按 $(i, j)$ 对三元组进行排序，并对每个 $(i, j)$ 只保留最后一次出现的值（即覆盖先前的值而不是求和）来构造 CSR，这违反了形成正确矩阵所需的代数累加规则。\n\n哪个选项提供了一个具体的反例，证明了这种未能合并重复项的做法会导致不正确的 SpMV 结果，并正确地指出了其结构性原因？\n\nA. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 以 COO 格式由三元组 $(0, 1, 1)$, $(0, 1, -2)$, $(0, 1, 3)$, $(1, 0, 4)$, $(1, 2, 5)$, $(2, 2, -1)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。代数合并矩阵有 $a_{0,1} = 1 + (-2) + 3 = 2$，因此正确的 SpMV 产生 $y = [4, 19, -3]^{\\top}$，因为 $y_0 = 2 \\cdot x_1 = 4$，$y_1 = 4 \\cdot x_0 + 5 \\cdot x_2 = 19$，以及 $y_2 = -1 \\cdot x_2 = -3$。如果通过保留每个 $(i, j)$ 的最后一次出现来形成 CSR，使得 $a_{0,1}$ 被设置为 $3$（丢弃了早期的贡献），则计算出的 SpMV 为 $y = [6, 19, -3]^{\\top}$，这是不正确的。结构性原因：CSR 在行段中为每个结构索引对 $(i, j)$ 精确存储一个值；如果在形成 CSR 之前没有对重复项求和，并且应用了“后来者居上”的覆盖策略，那么为 $(i, j)$ 存储的数值将不等于 COO 组装所要求的代数和，从而改变了 $a_{ij}$，并因此改变了 $y_i = \\sum_j a_{ij} x_j$。\n\nB. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 以 COO 格式由 $(0, 0, 2)$ 和 $(0, 0, 3)$ 给出，并设 $x = [1, 1]^{\\top}$。即使在没有合并重复项的情况下形成 CSR，SpMV 也将是正确的，因为重复项在 CSR 的按行累加中被内在地相加；因此从不需要显式合并。结构性原因：CSR 的行指针保证任何重复项在 SpMV 过程中都会被正确相加，因为它们作为重复条目出现。\n\nC. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 以 COO 格式由 $(0, 1, 1)$ 和 $(0, 1, -1)$ 给出，并设 $x = [2, 5]^{\\top}$。在没有合并的情况下，CSR SpMV 是正确的，因为重复项在乘法过程中相互抵消，得到 $y_0 = (1 + (-1)) \\cdot x_1 = 0$。结构性原因：由于重复项之和为零，未能合并没有影响，CSR 可以安全地忽略早期的条目。\n\nD. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 以 COO 格式由 $(0, 2, 4)$, $(1, 2, -4)$, $(1, 2, 1)$, $(2, 0, 7)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。如果通过计算行出现次数但不合并重复项来形成 CSR，SpMV 会变得数值不稳定，因为行指针会错位，算法会读取错误的列。结构性原因：重复项必然会破坏 CSR 中的行指针结构，使得任何 SpMV 都不正确，无论值如何处理。\n\n选择唯一的正确选项。", "solution": "问题陈述提出了一个关于稀疏矩阵存储格式以及一个特定的、有缺陷的坐标 (COO) 到压缩稀疏行 (CSR) 转换实现所带来的后果的问题。问题的核心在于如何从一个 COO 三元组列表定义矩阵 $A$，这需要对重复的 $(i, j)$ 索引的值进行求和以形成真正的代数矩阵。而有缺陷的实现绕过了这个求和过程，取而代之的是执行“后来者居上”的覆盖操作。\n\n问题在于找出一个反例，它能正确地展示这个有缺陷的实现导致的错误结果，并为该失败给出正确的结构性原因。\n\n首先，让我们形式化给出的定义。\n- 矩阵向量积定义为 $y \\leftarrow Ax$，对每一行 $i$ 计算为 $y_i = \\sum_{j=1}^{n} a_{ij} x_j$。\n- COO 格式是一个三元组列表 $(i_k, j_k, v_k)$。矩阵 $A$ 的代数元素 $a_{ij}$ 是通过对所有其对应索引 $(i_k, j_k)$ 等于 $(i, j)$ 的值 $v_k$ 求和得出：$a_{ij} = \\sum_{k | (i_k, j_k) = (i,j)} v_k$。这个过程被称为合并。\n- CSR 格式在其结构内不能表示重复的 $(i, j)$ 条目；它为每个非零位置存储一个单一的值。\n- 从 COO 到 CSR 的有缺陷的转换按 $(i,j)$ 对三元组进行字典序排序，并对每个唯一的索引对 $(i,j)$，它只存储排序后列表中最后一个三元组的值，从而有效地覆盖了该 $(i,j)$ 的任何先前值。我们将这个有缺陷的过程产生的矩阵表示为 $A'$。\n\n我们必须评估每个选项，看它是否提供了一个有效的反例和正确的解释。\n\n### 逐项分析\n\n**A. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 以 COO 格式由三元组 $(0, 1, 1)$, $(0, 1, -2)$, $(0, 1, 3)$, $(1, 0, 4)$, $(1, 2, 5)$, $(2, 2, -1)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。**\n\n1.  **正确的代数 SpMV：**\n    首先，我们通过合并 COO 三元组求和来确定真实代数矩阵 $A$ 的元素。\n    - 对于索引对 $(0, 1)$，我们有三个三元组：$(0, 1, 1)$, $(0, 1, -2)$ 和 $(0, 1, 3)$。合并后的值为 $a_{0,1} = 1 + (-2) + 3 = 2$。\n    - 对于索引对 $(1, 0)$，我们有一个三元组：$(1, 0, 4)$。因此，$a_{1,0} = 4$。\n    - 对于索引对 $(1, 2)$，我们有一个三元组：$(1, 2, 5)$。因此，$a_{1,2} = 5$。\n    - 对于索引对 $(2, 2)$，我们有一个三元组：$(2, 2, -1)$。因此，$a_{2,2} = -1$。\n    得到的代数矩阵 $A$ 是：\n    $$ A = \\begin{pmatrix} 0  2  0 \\\\ 4  0  5 \\\\ 0  0  -1 \\end{pmatrix} $$\n    现在，我们计算正确的 SpMV 结果，$y = Ax$，其中 $x = [1, 2, 3]^{\\top}$。\n    - $y_0 = (0 \\cdot 1) + (2 \\cdot 2) + (0 \\cdot 3) = 4$。\n    - $y_1 = (4 \\cdot 1) + (0 \\cdot 2) + (5 \\cdot 3) = 4 + 15 = 19$。\n    - $y_2 = (0 \\cdot 1) + (0 \\cdot 2) + (-1 \\cdot 3) = -3$。\n    因此，正确的结果是 $y = [4, 19, -3]^{\\top}$。这与选项中的计算相符。\n\n2.  **从有缺陷的 CSR 转换得到的错误 SpMV：**\n    有缺陷的实现按 $(i, j)$ 对三元组进行排序，并保留每对的最后一个值。对于索引对 $(0, 1)$，三元组是 $(0, 1, 1)$, $(0, 1, -2)$, $(0, 1, 3)$。最后一个值是 $3$。\n    有缺陷的矩阵 $A'$ 的元素是：\n    - $a'_{0,1} = 3$（后来者居上覆盖）。\n    - $a'_{1,0} = 4$（只有一个条目）。\n    - $a'_{1,2} = 5$（只有一个条目）。\n    - $a'_{2,2} = -1$（只有一个条目）。\n    有缺陷的矩阵 $A'$ 是：\n    $$ A' = \\begin{pmatrix} 0  3  0 \\\\ 4  0  5 \\\\ 0  0  -1 \\end{pmatrix} $$\n    现在，我们计算错误的 SpMV 结果，$y' = A'x$。\n    - $y'_0 = (0 \\cdot 1) + (3 \\cdot 2) + (0 \\cdot 3) = 6$。\n    - $y'_1 = (4 \\cdot 1) + (0 \\cdot 2) + (5 \\cdot 3) = 4 + 15 = 19$。\n    - $y'_2 = (0 \\cdot 1) + (0 \\cdot 2) + (-1 \\cdot 3) = -3$。\n    因此，错误的结果是 $y' = [6, 19, -3]^{\\top}$。这也与选项中的计算相符。\n\n3.  **对原因的评估：**\n    正确结果 $y$ 和错误结果 $y'$ 不同，所以这是一个有效的反例。给出的原因是：“CSR 在行段中为每个结构索引对 $(i, j)$ 精确存储一个值... 如果在形成 CSR 之前没有对重复项求和，并且应用了‘后来者居上’的覆盖策略，那么为 $(i, j)$ 存储的数值将不等于 COO 组装所要求的代数和，从而改变了 $a_{ij}$，并因此改变了 $y_i = \\sum_j a_{ij} x_j$。”这个解释是精确和正确的。CSR 的结构约束（每个 $(i, j)$ 只有一个条目）使得必须有一个合并步骤才能正确表示由加性 COO 语义定义的矩阵。有缺陷的“覆盖”方法用不正确的数值填充 CSR 结构，这导致了错误的 SpMV 结果。\n\n**结论：** 正确。\n\n**B. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 以 COO 格式由 $(0, 0, 2)$ 和 $(0, 0, 3)$ 给出，并设 $x = [1, 1]^{\\top}$。**\n\n该选项声称 SpMV 将是正确的，因为“重复项在 CSR 的按行累加中被内在地相加”。这个前提从根本上就是错误的。一个标准的 CSR 格式没有机制来存储重复的条目，更不用说对它们求和了。CSR 的结构由三个数组组成：`row_ptr`, `col_ind` 和 `values`。对于给定的行 $i$，段 `col_ind[row_ptr[i] : row_ptr[i+1]]` 应该包含唯一的列索引。如果创建了一个包含重复列索引的非标准 CSR（例如，行 $0$ 的 `col_ind` 是 `[0, 0]`），则需要一个自定义的 SpMV 核函数来处理它。一个标准的核函数只会简单地迭代并执行两次独立的乘法，实际上是对它们求和，但这依赖于一个格式不正确的 CSR。问题陈述中对 CSR 的定义（“对每个结构位置只保存一个存储值”）以及指定的缺陷（覆盖）与此选项中的逻辑相矛盾。所提供的结构性原因（“CSR 的行指针保证任何重复项都会被正确相加”）是对行指针功能的曲解。\n\n**结论：** 不正确。\n\n**C. 设 $A \\in \\mathbb{R}^{2 \\times 2}$ 以 COO 格式由 $(0, 1, 1)$ 和 $(0, 1, -1)$ 给出，并设 $x = [2, 5]^{\\top}$。**\n\n该选项声称结果是正确的，因为重复项相互抵消。\n1.  **正确的代数 SpMV：**\n    COO 三元组是 $(0, 1, 1)$ 和 $(0, 1, -1)$。合并得到 $a_{0,1} = 1 + (-1) = 0$。\n    正确的 SpMV 结果是 $y_0 = a_{0,1} x_1 = 0 \\cdot 5 = 0$。\n2.  **从有缺陷的 CSR 转换得到的错误 SpMV：**\n    有缺陷的实现取最后一个值。最后一个三元组是 $(0, 1, -1)$，所以 $a'_{0,1} = -1$。\n    错误的 SpMV 结果是 $y'_0 = a'_{0,1} x_1 = -1 \\cdot 5 = -5$。\n由于 $0 \\neq -5$，声称 SpMV 结果正确的断言是错误的。该选项误解了有缺陷的算法；它假设值被求和，而问题明确指出它们被覆盖。这些值求和为零的特殊数值属性与指定的有缺陷算法的结果无关。\n\n**结论：** 不正确。\n\n**D. 设 $A \\in \\mathbb{R}^{3 \\times 3}$ 以 COO 格式由 $(0, 2, 4)$, $(1, 2, -4)$, $(1, 2, 1)$, $(2, 0, 7)$ 给出，并设 $x = [1, 2, 3]^{\\top}$。**\n\n该选项引入了一种缺陷机制（“计算行出现次数但不合并重复项”），这与问题陈述中定义的机制（“只保留最后一次出现”）不同。这使得该选项没有回答问题。此外，其推理是有缺陷的。它声称“行指针会错位”，并且 SpMV 会变得“数值不稳定”。这些是对错误的非精确且不正确的描述。这是一个逻辑错误：表示了错误的矩阵。对于问题中指定的“覆盖”缺陷，生成的 CSR 结构将是完全格式良好的，而不是“被破坏的”，并且 SpMV 将是数值稳定的；它只是简单地计算与错误矩阵 $A'$ 的乘积。“数值不稳定性”这个术语指的是算法对输入数据微小变化（例如舍入误差）的敏感性，这并非此处的问题。给出的结构性原因（“重复项必然会破坏 CSR 中的行指针结构”）对于问题中指定的基于覆盖的缺陷是错误的。\n\n**结论：** 不正确。\n\n基于深入的分析，只有选项 A 提供了一个与问题对有缺陷算法的定义一致的、数值上正确的反例，并且它为由此产生的错误提供了清晰、准确的结构性解释。", "answer": "$$\\boxed{A}$$", "id": "3580366"}, {"introduction": "最后的这项实践将从基本操作转向一个更复杂、也更核心的计算：稀疏矩阵乘法（SpGEMM）。你将挑战其“符号计算阶段”，即确定结果矩阵的非零结构。通过亲手计算一个具体实例，这项练习能让你深入了解如何操作CSR和CSC格式的指针和索引数组来构建新的稀疏结构，这是开发高级稀疏线性代数软件的一项核心技能。[@problem_id:3580363]", "problem": "考虑稀疏通用矩阵-矩阵乘法 (SpGEMM) 中乘积 $C = A B$ 的符号阶段，其中 $A \\in \\mathbb{R}^{m \\times n}$ 以压缩稀疏行 (CSR) 格式存储，而 $B \\in \\mathbb{R}^{n \\times p}$ 以压缩稀疏列 (CSC) 格式存储。回顾其定义：在 CSR 中，其结构由 $\\mathrm{row\\_ptr}_{A} \\in \\mathbb{N}^{m+1}$ 和 $\\mathrm{col\\_ind}_{A} \\in \\mathbb{N}^{\\mathrm{nnz}(A)}$ 给出；在 CSC 中，其结构由 $\\mathrm{col\\_ptr}_{B} \\in \\mathbb{N}^{p+1}$ 和 $\\mathrm{row\\_ind}_{B} \\in \\mathbb{N}^{\\mathrm{nnz}(B)}$ 给出。符号阶段计算 $C$ 的非零模式，而不生成数值。典型做法是，对于 $A$ 的每一行 $i$，形成列索引 $j$ 的并集，其中存在 $k$ 使得 $A_{i,k} \\neq 0$ 且 $B_{k,j} \\neq 0$。一种常用的实现方式是，在扫描贡献结构时，在一个临时数组（长度为 $p$）中标记已访问的列 $j$，这样可以在常数时间内检测到重复项，避免重复插入。\n\n1. 从定义 $C_{i,j} = \\sum_{k=0}^{n-1} A_{i,k} B_{k,j}$ 和上述 CSR 和 CSC 的抽象定义出发（除其 CSC 数组外，不假设任何 $B$ 的预计算行结构），推导一个闭式解析表达式，用于计算一个仅使用 $\\mathrm{row\\_ptr}_{A}$、$\\mathrm{col\\_ind}_{A}$、$\\mathrm{col\\_ptr}_{B}$ 和 $\\mathrm{row\\_ind}_{B}$ 作为输入的逐行、基于标记的符号 SpGEMM 算法所执行的候选列访问的确切次数 $T$。请用在这些指针数组定义的索引区间上求和的形式来表示 $T$，不要使用渐近符号。\n\n2. 对于 $m = 3$、$n = 5$ 和 $p = 4$ 的特定实例，设 $A$ 和 $B$ 的结构如下：\n- $A$ (CSR格式): $\\mathrm{row\\_ptr}_{A} = (\\,0,\\,3,\\,5,\\,7\\,)$ and $\\mathrm{col\\_ind}_{A} = (\\,0,\\,2,\\,4,\\,1,\\,2,\\,0,\\,3\\,)$。\n- $B$ (CSC格式): $\\mathrm{col\\_ptr}_{B} = (\\,0,\\,3,\\,5,\\,8,\\,10\\,)$ and $\\mathrm{row\\_ind}_{B} = (\\,0,\\,1,\\,3,\\,2,\\,3,\\,0,\\,2,\\,4,\\,1,\\,4\\,)$。\n\n仅使用这些数组，计算乘积 $C = A B$ 的 $\\mathrm{row\\_ptr}_{C}$。您的方法必须基于第一性原理：对于 $A$ 的每一行 $i$，通过对出现在该行 $\\mathrm{col\\_ind}_{A}$ 中的每个 $k$，聚合集合 $\\{ j \\mid \\exists\\, t \\in [\\,\\mathrm{col\\_ptr}_{B}[j],\\,\\mathrm{col\\_ptr}_{B}[j+1]\\,),\\ \\mathrm{row\\_ind}_{B}[t] = k \\}$，来推断出 $B$ 的哪些列是可达的，并使用基于标记的逐行并集操作来计算唯一列的数量。然后根据每行的计数生成前缀和 $\\mathrm{row\\_ptr}_{C}$。\n\n答案规范：\n- 使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境，将最终答案表示为单行矩阵。矩阵的第一个条目是您在第 1 部分中推导出的 $T$ 的表达式在第 2 部分给定实例下的数值，其后是该实例下 $\\mathrm{row\\_ptr}_{C}$ 的条目，按 $i = 0, 1, 2, 3$ 的顺序排列。无需四舍五入。无需单位。", "solution": "该问题分为两部分。首先，我们推导候选列访问总数 $T$ 的通用表达式。其次，我们将其应用于一个特定实例，并计算乘积矩阵 $C$ 的结果行指针数组。\n\n**第1部分：$T$ 的表达式推导**\n\n乘积矩阵为 $C = AB$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $B \\in \\mathbb{R}^{n \\times p}$。仅当存在至少一个索引 $k \\in \\{0, \\dots, n-1\\}$ 使得 $A_{i,k}$ 和 $B_{k,j}$ 均为非零时，元素 $C_{i,j}$ 才为非零。SpGEMM 的符号阶段旨在识别所有使得 $C_{i,j}$ 可能为非零的数对 $(i, j)$。\n\n算法被描述为“逐行”的，意味着我们一次计算 $C$ 的一行的非零模式。对于 $C$ 的每一行 $i$，其模式是由 $A$ 的第 $i$ 行的非零元素缩放的 $B$ 的行的非零模式的并集。具体来说，对于 $A$ 的一行 $i \\in \\{0, \\dots, m-1\\}$，其非零模式由列索引集 $K_i = \\{k \\mid A_{i,k} \\neq 0\\}$ 给出。乘积矩阵 $C$ 的第 $i$ 行的非零模式则由以下列索引的并集给出：\n$$ \\mathrm{pattern}(C_{i,:}) = \\bigcup_{k \\in K_i} \\{ j \\mid B_{k,j} \\neq 0 \\} $$\n所描述的算法涉及遍历这些贡献结构。对于 $A$ 的每一行 $i$，我们考虑每个非零元素 $A_{i,k}$。对于每个这样的 $k$，我们接着考虑所有 $B_{k,j} \\neq 0$ 的列索引 $j$。每个这样的 $j$ 构成一次“候选列访问”。大小为 $p$ 的标记数组用于确保每个唯一的列 $j$ 仅对第 $i$ 行的最终非零计数贡献一次，但访问总数 $T$ 包括所有这些（可能重复的）访问。\n\n令 $\\mathrm{nnz}(B_{k,:})$ 表示矩阵 $B$ 的第 $k$ 行中非零元素的数量。对于 $C$ 的单行 $i$，候选列访问的次数是所有贡献的 $B$ 的行中非零元素数量之和：\n$$ T_i = \\sum_{k \\in K_i} \\mathrm{nnz}(B_{k,:}) $$\n候选列访问的总次数 $T$ 是 $T_i$ 在 $A$ 的所有行 $i$ 上的总和：\n$$ T = \\sum_{i=0}^{m-1} T_i = \\sum_{i=0}^{m-1} \\sum_{k \\in K_i} \\mathrm{nnz}(B_{k,:}) $$\n$A$ 的第 $i$ 行中非零元素的列索引集 $K_i$ 由 CSR 结构给出：$K_i = \\{ \\mathrm{col\\_ind}_{A}[l] \\mid l \\in [\\mathrm{row\\_ptr}_{A}[i], \\mathrm{row\\_ptr}_{A}[i+1]-1] \\}$。我们可以将对 $k \\in K_i$ 的求和重写为对 $\\mathrm{col\\_ind}_{A}$ 数组中索引 $l$ 的求和：\n$$ T = \\sum_{i=0}^{m-1} \\sum_{l=\\mathrm{row\\_ptr}_{A}[i]}^{\\mathrm{row\\_ptr}_{A}[i+1]-1} \\mathrm{nnz}(B_{\\mathrm{col\\_ind}_{A}[l],:}) $$\n这可以通过将嵌套和合并为对 $A$ 的所有非零元素的单个和来简化：\n$$ T = \\sum_{l=0}^{\\mathrm{nnz}(A)-1} \\mathrm{nnz}(B_{\\mathrm{col\\_ind}_{A}[l],:}) $$\n问题要求表达式以给定的数组表示。矩阵 $B$ 是 CSC 格式，因此获取一行中非零元素的数量 $\\mathrm{nnz}(B_{k,:})$ 需要扫描 `row_ind_B` 数组。$B$ 的第 $k$ 行中的非零元素数量是索引 $k$ 在 $\\mathrm{row\\_ind}_{B}$ 数组中出现的次数。令 $I(\\cdot)$ 为指示函数，当其参数为真时为 $1$，否则为 $0$。\n$$ \\mathrm{nnz}(B_{k,:}) = \\sum_{q=0}^{\\mathrm{nnz}(B)-1} I(\\mathrm{row\\_ind}_{B}[q] = k) $$\n将此代入 $T$ 的表达式中：\n$$ T = \\sum_{l=0}^{\\mathrm{nnz}(A)-1} \\left( \\sum_{q=0}^{\\mathrm{nnz}(B)-1} I(\\mathrm{row\\_ind}_{B}[q] = \\mathrm{col\\_ind}_{A}[l]) \\right) $$\n这就是候选列访问确切次数的闭式解析表达式。\n\n**第2部分：针对特定实例的计算**\n\n给定数据：\n- $A$: $\\mathrm{row\\_ptr}_{A} = (\\,0,\\,3,\\,5,\\,7\\,)$, $\\mathrm{col\\_ind}_{A} = (\\,0,\\,2,\\,4,\\,1,\\,2,\\,0,\\,3\\,)$。我们有 $\\mathrm{nnz}(A)=7$。\n- $B$: $\\mathrm{col\\_ptr}_{B} = (\\,0,\\,3,\\,5,\\,8,\\,10\\,)$, $\\mathrm{row\\_ind}_{B} = (\\,0,\\,1,\\,3,\\,2,\\,3,\\,0,\\,2,\\,4,\\,1,\\,4\\,)$。我们有 $\\mathrm{nnz}(B)=10$。\n\n**首先，我们计算 $T$ 的数值。**\n我们使用更简单的形式 $T = \\sum_{l=0}^{\\mathrm{nnz}(A)-1} \\mathrm{nnz}(B_{\\mathrm{col\\_ind}_{A}[l],:})$。我们首先需要计算 $B$ 的每一行（$k \\in \\{0, 1, 2, 3, 4\\}$）的非零元素数 $\\mathrm{nnz}(B_{k,:})$。我们通过计算在 $\\mathrm{row\\_ind}_{B}$ 中出现的次数来做到这一点：\n- $\\mathrm{nnz}(B_{0,:})$ = $\\mathrm{row\\_ind}_{B}$ 中 $0$ 的计数 = $2$。\n- $\\mathrm{nnz}(B_{1,:})$ = $\\mathrm{row\\_ind}_{B}$ 中 $1$ 的计数 = $2$。\n- $\\mathrm{nnz}(B_{2,:})$ = $\\mathrm{row\\_ind}_{B}$ 中 $2$ 的计数 = $2$。\n- $\\mathrm{nnz}(B_{3,:})$ = $\\mathrm{row\\_ind}_{B}$ 中 $3$ 的计数 = $2$。\n- $\\mathrm{nnz}(B_{4,:})$ = $\\mathrm{row\\_ind}_{B}$ 中 $4$ 的计数 = $2$。\n\n$A$ 中非零元素的列索引由 $\\mathrm{col\\_ind}_{A} = (\\,0,\\,2,\\,4,\\,1,\\,2,\\,0,\\,3\\,)$ 给出。我们将 $B$ 中相应的行计数相加：\n$$ T = \\mathrm{nnz}(B_{0,:}) + \\mathrm{nnz}(B_{2,:}) + \\mathrm{nnz}(B_{4,:}) + \\mathrm{nnz}(B_{1,:}) + \\mathrm{nnz}(B_{2,:}) + \\mathrm{nnz}(B_{0,:}) + \\mathrm{nnz}(B_{3,:}) $$\n$$ T = 2 + 2 + 2 + 2 + 2 + 2 + 2 = 7 \\times 2 = 14 $$\n\n**其次，我们计算 $\\mathrm{row\\_ptr}_{C}$。**\n我们需要为每一行 $i=0, 1, 2$ 找到 $\\mathrm{nnz}(C_{i,:})$。这需要找到并集 $\\bigcup_{k \\in K_i} \\{ j \\mid B_{k,j} \\neq 0 \\}$ 的大小。\n首先，让我们为 $B$ 的每一行 $k$ 确定列索引集 $J_k = \\{j \\mid B_{k,j} \\neq 0\\}$。我们解码 $B$ 的 CSC 表示：\n- 第 0 列 ($j=0$): $\\mathrm{row\\_ind}_{B}$ 的索引 $0,1,2$ 给出第 $0,1,3$ 行。非零元素：$(0,0), (1,0), (3,0)$。\n- 第 1 列 ($j=1$): $\\mathrm{row\\_ind}_{B}$ 的索引 $3,4$ 给出第 $2,3$ 行。非零元素：$(2,1), (3,1)$。\n- 第 2 列 ($j=2$): $\\mathrm{row\\_ind}_{B}$ 的索引 $5,6,7$ 给出第 $0,2,4$ 行。非零元素：$(0,2), (2,2), (4,2)$。\n- 第 3 列 ($j=3$): $\\mathrm{row\\_ind}_{B}$ 的索引 $8,9$ 给出第 $1,4$ 行。非零元素：$(1,3), (4,3)$。\n\n由此，我们构建集合 $J_k$:\n- $J_0 = \\{0, 2\\}$\n- $J_1 = \\{0, 3\\}$\n- $J_2 = \\{1, 2\\}$\n- $J_3 = \\{0, 1\\}$\n- $J_4 = \\{2, 3\\}$\n\n现在，我们计算 $C$ 的每一行的非零模式：\n- **第 $i=0$ 行**: 此行中 $A$ 的非零列为 $K_0 = \\{\\mathrm{col\\_ind}_{A}[0], \\mathrm{col\\_ind}_{A}[1], \\mathrm{col\\_ind}_{A}[2]\\} = \\{0, 2, 4\\}$。\n $C_{0,:}$ 的模式是 $J_0 \\cup J_2 \\cup J_4 = \\{0, 2\\} \\cup \\{1, 2\\} \\cup \\{2, 3\\} = \\{0, 1, 2, 3\\}$。\n 因此，$\\mathrm{nnz}(C_{0,:}) = 4$。\n\n- **第 $i=1$ 行**: 此行中 $A$ 的非零列为 $K_1 = \\{\\mathrm{col\\_ind}_{A}[3], \\mathrm{col\\_ind}_{A}[4]\\} = \\{1, 2\\}$。\n $C_{1,:}$ 的模式是 $J_1 \\cup J_2 = \\{0, 3\\} \\cup \\{1, 2\\} = \\{0, 1, 2, 3\\}$。\n 因此，$\\mathrm{nnz}(C_{1,:}) = 4$。\n\n- **第 $i=2$ 行**: 此行中 $A$ 的非零列为 $K_2 = \\{\\mathrm{col\\_ind}_{A}[5], \\mathrm{col\\_ind}_{A}[6]\\} = \\{0, 3\\}$。\n $C_{2,:}$ 的模式是 $J_0 \\cup J_3 = \\{0, 2\\} \\cup \\{0, 1\\} = \\{0, 1, 2\\}$。\n 因此，$\\mathrm{nnz}(C_{2,:}) = 3$。\n\n$C$ 每行的非零元素计数为 $(4, 4, 3)$。数组 $\\mathrm{row\\_ptr}_{C}$ 是这些计数的前缀和，从 $0$ 开始。\n- $\\mathrm{row\\_ptr}_{C}[0] = 0$\n- $\\mathrm{row\\_ptr}_{C}[1] = \\mathrm{row\\_ptr}_{C}[0] + \\mathrm{nnz}(C_{0,:}) = 0 + 4 = 4$\n- $\\mathrm{row\\_ptr}_{C}[2] = \\mathrm{row\\_ptr}_{C}[1] + \\mathrm{nnz}(C_{1,:}) = 4 + 4 = 8$\n- $\\mathrm{row\\_ptr}_{C}[3] = \\mathrm{row\\_ptr}_{C}[2] + \\mathrm{nnz}(C_{2,:}) = 8 + 3 = 11$\n因此，$\\mathrm{row\\_ptr}_{C} = (\\,0,\\,4,\\,8,\\,11\\,)$。\n\n最终答案要求是 $T$ 的数值，后跟 $\\mathrm{row\\_ptr}_{C}$ 的元素。\n$T$ 的数值为 $14$。\n$\\mathrm{row\\_ptr}_{C}$ 的元素为 $0$、$4$、$8$、$11$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n14  0  4  8  11\n\\end{pmatrix}\n}\n$$", "id": "3580363"}]}