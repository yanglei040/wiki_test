{"hands_on_practices": [{"introduction": "倒易空间的周期性要求我们在进行布里渊区（BZ）积分时，必须精确地处理边界上的点，以避免对同一个布洛赫态的重复计算。这个实践旨在通过一个编程练习，让你亲手实现一个规范化方案，将任意的k点映射到第一布里渊区的一个唯一代表点上，这是所有k点采样计算的根本前提 [@problem_id:3459456]。", "problem": "考虑一个实空间中具有原胞布拉菲晶格的晶体固体，其倒易晶格由倒易基矢生成，这些基矢作为矩阵 $B \\in \\mathbb{R}^{d \\times d}$ 的列向量，因此任何波矢 $k \\in \\mathbb{R}^d$ 都可以通过 $k = B u$ 写成简约坐标 $u \\in \\mathbb{R}^d$ 的形式。倒易空间在加上倒易晶格矢量后具有周期性，因此对于任何整数矢量 $m \\in \\mathbb{Z}^d$，$k$ 和 $k + B m$ 代表相同的布洛赫态。因此，在对布里渊区（BZ）进行采样以计算k空间积分时，必须避免重复计算通过加上倒易晶格矢量而相关的点。一个标准的解决方法是，通过将简约坐标限制在单个基本区域内（例如半开超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^d$），为每个模倒易晶格的等价类选择一个规范代表。\n\n您需要实现一个程序，对于几个测试用例中的每一个，该程序接受一个由索引元组构成的整数网格，并使用以下设置将每个索引元组映射到一个唯一的模倒易晶格矢量的k点：\n\n1. 对于每个分量 $\\alpha = 1, \\ldots, d$，与索引 $i \\in \\mathbb{Z}^d$ 对应的简约坐标定义为 $u_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2}$，其中 $N \\in \\mathbb{N}^d$ 是网格尺寸，$s \\in [0,1)^d$ 是一个固定的平移矢量。\n2. 如果对于某个 $m \\in \\mathbb{Z}^d$ 有 $u' = u + m$，则两个简约坐标 $u$ 和 $u'$ 代表同一个等价类。\n3. 您的映射必须为每个索引 $i$ 分配一个在半开超立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^d$ 内的规范简约坐标 $u^{\\mathrm{canon}}$，并明确约定：任何恰好位于上边界 $\\tfrac{1}{2}$ 的分量在该分量上被映射到 $-\\tfrac{1}{2}$，以确保代表的唯一性并避免在布里渊区边界上重复计数。\n4. 然后，规范笛卡尔k点为 $k^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}$。\n\n为了实现实际的数值唯一性，请在笛卡尔空间中使用一个容差 $\\varepsilon > 0$ 来确定规范k点的相等性：如果 $\\|k^{\\mathrm{canon}} - (k^{\\mathrm{canon}})'\\|_\\infty \\le \\varepsilon$，则两个规范k点 $k^{\\mathrm{canon}}$ 和 $(k^{\\mathrm{canon}})'$ 被认为是相等的，其中 $\\|\\cdot\\|_\\infty$ 是无穷范数。您的程序必须基于此标准对点进行去重。\n\n对于每个测试用例，在去重后，将每个唯一规范k点的均匀积分权重定义为 $w = \\frac{1}{\\prod_{\\alpha=1}^{d} N_\\alpha}$。为每个用例报告以下内容：\n- 唯一规范k点的整数数量。\n- 一个布尔值，指示唯一规范k点的权重之和是否在 $10^{-12}$ 的绝对容差内等于 $1$。\n- 最大多重性，定义为在您的方案下映射到同一个规范k点的不同索引元组的最大数量。\n\n使用以下测试套件。对于每个用例，$B$ 被明确给出，$N$ 是网格尺寸，$s$ 是平移量，索引集 $I$ 按分量指定，$\\varepsilon$ 是笛卡尔去重容差。\n\n- 测试用例1（一维，边界包含合理性检查）：\n  - $d = 1$\n  - $B = [1.0]$\n  - $N = (4)$\n  - $s = (0.0)$\n  - 索引集 $I = \\{0,1,2,3,4\\}$ （包含 $0$ 和 $N$）\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例2（二维，六方倒易基底，两轴均包含边界）：\n  - $d = 2$\n  - $B = \\begin{bmatrix} 1.0  0.5 \\\\ 0.0  \\tfrac{\\sqrt{3}}{2} \\end{bmatrix}$\n  - $N = (3,3)$\n  - $s = (0.0, 0.0)$\n  - 索引集 $I = \\{0,1,2,3\\} \\times \\{0,1,2,3\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例3（三维，各向异性倒易基底和网格尺寸，包含边界）：\n  - $d = 3$\n  - $B = \\begin{bmatrix} 1.0  0.0  0.5 \\\\ 0.0  2.0  0.5 \\\\ 0.0  0.0  3.0 \\end{bmatrix}$\n  - $N = (2,1,4)$\n  - $s = (0.0, 0.0, 0.0)$\n  - 索引集 $I = \\{0,1,2\\} \\times \\{0,1\\} \\times \\{0,1,2,3,4\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例4（一维，广泛的负到正索引）：\n  - $d = 1$\n  - $B = [1.0]$\n  - $N = (5)$\n  - $s = (0.0)$\n  - 索引集 $I = \\{-5,-4,-3,-2,-1,0,1,2,3,4,5\\}$\n  - $\\varepsilon = 10^{-12}$\n\n- 测试用例5（二维，非正交基底，混合索引范围，带半分量平移）：\n  - $d = 2$\n  - $B = \\begin{bmatrix} 1.0  0.3 \\\\ 0.2  1.1 \\end{bmatrix}$\n  - $N = (2,3)$\n  - $s = (0.5, 0.0)$\n  - 索引集 $I = \\{-2,-1,0,1,2\\} \\times \\{-3,-2,-1,0,1,2,3\\}$\n  - $\\varepsilon = 10^{-12}$\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，形式为方括号括起来的逗号分隔列表。每个测试用例贡献三项内容：唯一计数（整数）、权重和检查（布尔值）和最大多重性（整数）。例如，输出格式应类似于 $[c_1,b_1,m_1,c_2,b_2,m_2,\\ldots,c_5,b_5,m_5]$，不含空格。", "solution": "我们从倒易空间中布洛赫态的周期性开始。令 $L^* = \\{B m : m \\in \\mathbb{Z}^d\\}$ 表示倒易晶格。对于任何晶体动量 $k \\in \\mathbb{R}^d$，布洛赫波函数和能带能量在加上倒易晶格矢量后是周期性的，因此用于布里渊区（BZ）积分的任何被积函数 $F(k)$ 都满足 $F(k) = F(k + G)$，其中 $G \\in L^*$。因此，对k空间的积分可以限制在 $L^*$ 的任何一个基本区域内，并进行适当的归一化。\n\n为了在布里渊区边界实现均匀采样而不重复计数，选择倒易原胞作为简约坐标的基本区域是足够的。令 $u \\in \\mathbb{R}^d$ 表示简约坐标，使得 $k = B u$。对于 $m \\in \\mathbb{Z}^d$，等价关系 $u \\sim u + m$ 将 $\\mathbb{R}^d$ 划分为模 $\\mathbb{Z}^d$ 的等价类。一个规范的代表选择是半开超立方体\n$$\n\\mathcal{C} = \\left[-\\tfrac{1}{2}, \\tfrac{1}{2}\\right)^d,\n$$\n这样每个等价类在 $\\mathcal{C}$ 中都有一个唯一的代表 $u^{\\mathrm{canon}}$，并且上边界的点与相应的下边界点等同，以避免重复计数。\n\n给定一个整数网格索引 $i \\in \\mathbb{Z}^d$、一个网格尺寸矢量 $N \\in \\mathbb{N}^d$ 和一个平移量 $s \\in [0,1)^d$，我们定义简约坐标为\n$$\nu_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2} \\quad \\text{for each} \\quad \\alpha = 1,\\ldots,d.\n$$\n这在考虑周期性等同之前，在简约坐标中定义了一个均匀网格。为了将 $u$ 映射到其在 $\\mathcal{C}$ 中的规范代表，我们使用 $\\mathbb{Z}^d$ 的整数平移。核心原理是，对于任何实数 $x$，表达式 $x - \\lfloor x + \\tfrac{1}{2} \\rfloor$ 位于区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内。这可由向下取整函数的性质得出：\n- 令 $y = x + \\tfrac{1}{2}$。存在一个唯一的整数 $m = \\lfloor y \\rfloor$ 使得 $m \\le y  m + 1$。\n- 那么 $x - m = y - \\tfrac{1}{2} - m \\in [-\\tfrac{1}{2}, \\tfrac{1}{2})$。\n- 如果恰好有 $x = \\tfrac{1}{2}$，那么 $y = 1$，且 $\\lfloor y \\rfloor = 1$，所以 $x - \\lfloor y \\rfloor = \\tfrac{1}{2} - 1 = -\\tfrac{1}{2}$，这强制执行了边界约定。\n\n将此方法逐分量应用，得到规范简约坐标\n$$\nu^{\\mathrm{canon}}_\\alpha = u_\\alpha - \\left\\lfloor u_\\alpha + \\tfrac{1}{2} \\right\\rfloor, \\quad \\alpha = 1,\\ldots,d,\n$$\n并由此得到规范笛卡尔k点\n$$\nk^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}.\n$$\n\n数值实现需要稳健的去重操作。由于浮点数运算可能只能近似表示有理数值，我们使用笛卡尔容差 $\\varepsilon > 0$ 和无穷范数来确定规范k点的数值相等性：\n$$\n\\|k^{\\mathrm{canon}} - (k^{\\mathrm{canon}})'\\|_\\infty \\le \\varepsilon \\quad \\Rightarrow \\quad \\text{equal}.\n$$\n在算法上，我们可以通过将 $k^{\\mathrm{canon}}$ 的每个分量除以 $\\varepsilon$ 并四舍五入到最近的整数来量化，从而形成一个可哈希的键，该键将 $\\varepsilon$ 范围内的点分组。\n\n对于每个测试用例，步骤如下：\n1. 从指定的索引集 $I$ 中枚举所有索引元组 $i$。\n2. 通过 $u_\\alpha = \\frac{i_\\alpha + s_\\alpha}{N_\\alpha} - \\tfrac{1}{2}$ 计算简约坐标 $u$。\n3. 通过 $u^{\\mathrm{canon}}_\\alpha = u_\\alpha - \\left\\lfloor u_\\alpha + \\tfrac{1}{2} \\right\\rfloor$ 进行规范化，在向下取整函数内部使用一个小的正数值偏移来稳定浮点运算下的边界情况，同时保持到 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 的映射。\n4. 计算 $k^{\\mathrm{canon}} = B \\, u^{\\mathrm{canon}}$。\n5. 使用基于 $\\varepsilon$ 的量化键进行去重和计数多重性：维护一个从键到多重性计数的字典。\n6. 唯一规范k点的数量是字典条目的数量。最大多重性是字典计数值中的最大值。\n7. 每个唯一规范点的均匀权重为 $w = \\frac{1}{\\prod_{\\alpha=1}^{d} N_\\alpha}$。权重之和等于 $\\frac{\\text{unique\\_count}}{\\prod_{\\alpha} N_\\alpha}$，如果规范化后恰好有 $\\prod_{\\alpha} N_\\alpha$ 个不同的代表点，则该值应为 $1$。我们检查 $|\\text{sum\\_weights} - 1| \\le 10^{-12}$ 并报告一个布尔值。\n\n正确性论证：\n- 基于向下取整的规范化确保每个分量都位于 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内，并尊重模 $\\mathbb{Z}^d$ 的周期性，从而为每个等价类选择一个唯一的代表，包括将边界 $\\tfrac{1}{2}$ 映射到 $-\\tfrac{1}{2}$ 的处理。\n- 在容差 $\\varepsilon$ 下的去重反映了理想算术中的精确等价；当 $\\varepsilon$ 相对于 $B$ 的大小和网格间距足够小时，可以避免错误的合并。\n- 对于包含上下边界（例如 $\\{0,1,\\ldots,N\\}$）或扩展范围（例如 $\\{-N,\\ldots,N\\}$）的索引集，多个索引会映射到同一个规范代表；字典计数反映了多重性，而唯一计数等于 $\\prod_{\\alpha} N_\\alpha$，前提是所有分量在每个方向上都覆盖了完整的采样周期。\n\n将此程序应用于所提供的测试套件：\n- 测试用例1在一维中同时包含 $0$ 和 $N$，因此 $u = -\\tfrac{1}{2}$ 和 $u = \\tfrac{1}{2}$ 处的点被等同；唯一规范集的大小为 $N = 4$，权重之和为 $1$，边界点的最大多重性为 $2$。\n- 测试用例2覆盖了 $4 \\times 4$ 个索引，而 $N = (3,3)$，因此每个轴都包含两个边界；唯一规范集的大小为 $\\prod N_\\alpha = 9$，权重之和为 $1$，由于二维中的边界等同，角点的多重性为 $4$。\n- 测试用例3的 $N = (2,1,4)$ 且索引包含边界；唯一规范集的大小为 $2 \\cdot 1 \\cdot 4 = 8$，权重之和为 $1$，在所有轴都包含上边界的角点处，最大多重性为 $2 \\cdot 2 \\cdot 2 = 8$。\n- 测试用例4在一维中索引范围从 $-5$ 到 $5$，而 $N=5$，因此在多个周期上进行采样；唯一规范集的大小为 $5$，权重之和为 $1$，最大多重性反映了在扩展范围内有多少个索引落入同一个规范等价类。\n- 测试用例5在非正交基底中混合了负到正的索引和半分量平移；规范化在简约坐标中逐分量进行，产生的唯一计数等于 $\\prod N_\\alpha = 6$，权重之和等于 $1$，最大多重性对应于每个轴上边界重复的乘积。\n\n该程序实现了此逻辑，使用给定的容差进行去重，计算所要求的量，并以所需的单行格式打印汇总结果。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef canonicalize_reduced(u, eps=1e-12):\n    \"\"\"\n    Map reduced coordinates u to the half-open hypercube [-1/2, 1/2)^d\n    componentwise using floor(u + 1/2). A small eps is added to stabilize\n    boundary cases under floating-point arithmetic.\n    \"\"\"\n    return u - np.floor(u + 0.5 + eps)\n\ndef dedup_keys(k_points, tol):\n    \"\"\"\n    Deduplicate a set of Cartesian k-points using an infinity-norm tolerance tol.\n    Returns a dictionary mapping quantized keys to multiplicity counts.\n    The key is constructed by quantizing each component: round(k_i / tol) to int.\n    \"\"\"\n    counts = {}\n    for k in k_points:\n        key = tuple(np.round(k / tol).astype(np.int64).tolist())\n        counts[key] = counts.get(key, 0) + 1\n    return counts\n\ndef process_case(B, N, s, indices, tol):\n    \"\"\"\n    Process a single test case using a provided list of indices.\n    \"\"\"\n    N_arr = np.array(N, dtype=np.int64)\n    s_arr = np.array(s, dtype=np.float64)\n    B_arr = np.array(B, dtype=np.float64)\n    \n    k_points = []\n    for idx in indices:\n        i = np.array(idx, dtype=np.float64)\n        u = (i + s_arr) / N_arr - 0.5\n        u_canon = canonicalize_reduced(u)\n        k = B_arr @ u_canon\n        k_points.append(k)\n\n    counts = dedup_keys(k_points, tol)\n    unique_count = len(counts)\n    max_multiplicity = max(counts.values()) if counts else 0\n    \n    total_grid_points = int(np.prod(N_arr))\n    # In this problem context, weight sum check should be based on unique points from a full BZ grid.\n    # The sum of weights of the *unique* points should be unique_count / prod(N).\n    # The question asks if the sum of weights for the *resulting set* is 1.\n    # This is true if unique_count == prod(N).\n    weight_sum_is_one = abs(unique_count / total_grid_points - 1.0) = 1e-12\n\n    return unique_count, weight_sum_is_one, max_multiplicity\n\ndef solve():\n    sqrt3 = np.sqrt(3.0)\n    \n    # Define test cases as specified in the problem text\n    test_cases_spec = [\n        {\n            \"B\": [[1.0]], \"N\": (4,), \"s\": (0.0,), \"tol\": 1e-12,\n            \"indices\": [(i,) for i in range(5)]\n        },\n        {\n            \"B\": [[1.0, 0.5], [0.0, sqrt3/2.0]], \"N\": (3, 3), \"s\": (0.0, 0.0), \"tol\": 1e-12,\n            \"indices\": list(itertools.product(range(4), repeat=2))\n        },\n        {\n            \"B\": [[1.0, 0.0, 0.5], [0.0, 2.0, 0.5], [0.0, 0.0, 3.0]], \"N\": (2, 1, 4), \"s\": (0.0, 0.0, 0.0), \"tol\": 1e-12,\n            \"indices\": list(itertools.product(range(3), range(2), range(5)))\n        },\n        {\n            \"B\": [[1.0]], \"N\": (5,), \"s\": (0.0,), \"tol\": 1e-12,\n            \"indices\": [(i,) for i in range(-5, 6)]\n        },\n        {\n            \"B\": [[1.0, 0.3], [0.2, 1.1]], \"N\": (2, 3), \"s\": (0.5, 0.0), \"tol\": 1e-12,\n            \"indices\": list(itertools.product(range(-2, 3), range(-3, 4)))\n        },\n    ]\n\n    results = []\n    for case in test_cases_spec:\n        unique_count, weight_ok, max_mult = process_case(\n            B=case[\"B\"],\n            N=case[\"N\"],\n            s=case[\"s\"],\n            indices=case[\"indices\"],\n            tol=case[\"tol\"]\n        )\n        results.extend([unique_count, weight_ok, max_mult])\n\n    # Final print statement in the exact required format: single line list, no spaces.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3459456"}, {"introduction": "在掌握了如何生成一个完备且无冗余的k点网格后，下一步是通过利用晶体对称性来大幅提升计算效率。本练习将指导你针对一个高对称性的立方晶体，设计并实现一个算法，将全布里渊区的k点约化到不可约布里渊区（IBZ）中，并计算出每个不可约k点对应的权重 [@problem_id:3459449]。这个过程是现代电子结构计算软件中的标准核心步骤。", "problem": "给定一个具有完整八面体对称性的简单立方晶体，其点群为 $O_h$。考虑在简约分数倒易坐标中表示的布里渊区，其基本区域为半开立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$，并且周期性边界条件将相差整数个倒易格矢的点视为等同。一个均匀的 $\\mathbf{k}$点网格按如下方式构建：每个分量 $k_{\\alpha}$ 仅限于集合 $\\{-\\tfrac{1}{2}, -\\tfrac{1}{4}, 0, \\tfrac{1}{4}\\}$，从而形成一个包含 $64$ 个点的 $4\\times 4\\times 4$ 网格，我们用集合 $\\mathcal{K}$ 表示。\n\n基本定义：\n- 布里渊区积分利用了晶体对称性。如果存在一个点群操作 $R \\in O_h$ 使得 $\\mathbf{k}' = R \\mathbf{k}$（模一个倒易格矢），那么两个波矢 $\\mathbf{k}$ 和 $\\mathbf{k}'$ 就是对称等价的。对于在点群下不变的标量，对称等价点对布里渊区积分的贡献是相同的。\n- 倒易空间中的完整八面体群 $O_h$ 由所有元素在 $\\{-1,0,1\\}$ 中、每行每列只有一个非零元素的正交 $3\\times 3$ 矩阵表示。该集合包括 $3!$ 种坐标轴置换与 $2^3$ 种独立的符号翻转组合，共产生 $48$ 个对称操作（包括真旋转和非真操作，例如通过反演结合 $180^\\circ$ 旋转实现的反映）。\n- 对于非磁性晶体，时间反演对称性将 $\\mathbf{k}$ 映射到 $-\\mathbf{k}$。在存在反演对称性（已包含在 $O_h$ 中）的情况下，$-\\mathbf{k}$ 已经可以通过一个点群操作生成。尽管如此，我们仍将在算法中明确包含时间反演操作，以演示其处理方式。\n\n算法目标：\n1. 定义群作用。设对称操作集合为\n$$\n\\mathcal{G} = \\{ R \\in \\mathbb{R}^{3\\times 3} \\mid R \\text{ orthogonal}, R_{ij} \\in \\{-1,0,1\\}, \\text{ exactly one nonzero per row and column} \\}.\n$$\n包含时间反演映射 $\\Theta: \\mathbf{k} \\mapsto -\\mathbf{k}$；注意 $-I \\in \\mathcal{G}$，但仍需显式包含它并去重。\n2. 实现一个与半开布里渊区 $[-\\tfrac{1}{2},\\tfrac{1}{2})^3$ 一致的周期性包裹函数。以四分之一整数为单位，令每个分量由一个整数 $n \\in \\{-2,-1,0,1\\}$ 表示，对应于 $n/4$。当对称变换产生分量 $n=2$（对应于 $+\\tfrac{1}{2}$）时，将其包裹至 $n=-2$（对应于 $-\\tfrac{1}{2}$），以确保所有坐标保持在半开区间内。\n3. 对每个 $\\mathbf{k}\\in \\mathcal{K}$，在对称群作用下（含周期性包裹）形成其轨道：\n$$\n\\mathrm{Orbit}(\\mathbf{k}) = \\big\\{ \\operatorname{wrap}(R \\mathbf{k}) \\,\\big|\\, R \\in \\mathcal{G} \\cup \\{-I\\} \\big\\},\n$$\n其中 $\\operatorname{wrap}$ 逐分量地强制使其属于 $[-\\tfrac{1}{2},\\tfrac{1}{2})^3$。\n4. 将轨道的典范代表元定义为以四分之一整数为单位的字典序最小向量：\n$$\n\\mathbf{k}^\\star = \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{k}),\n$$\n使用元组 $(n_x,n_y,n_z)$ 的标准排序，其中每个 $n_{\\alpha}\\in\\{-2,-1,0,1\\}$。\n5. 将不可约布里渊区 (IBZ) 定义为网格上所有此类典范代表元的集合：\n$$\n\\mathrm{IBZ} = \\big\\{ \\mathbf{k}^\\star \\,\\big|\\, \\mathbf{k} \\in \\mathcal{K} \\big\\}.\n$$\n6. 代表元 $\\mathbf{k}^\\star$ 的权重是整个网格中映射到它的点的比例：\n$$\nw(\\mathbf{k}^\\star) = \\frac{|\\{\\mathbf{q} \\in \\mathcal{K} \\mid \\min_{\\text{lex}} \\mathrm{Orbit}(\\mathbf{q}) = \\mathbf{k}^\\star \\}|}{|\\mathcal{K}|}.\n$$\n当对 $\\mathrm{IBZ}$ 中的所有权重求和时，总和必须为 $1$。\n\n实现要求：\n- 将 $O_h$ 中的所有对称操作构建为带符号的置换矩阵，其每行每列只有一个非零元素，且元素在 $\\{-1,0,1\\}$ 中。在去重之前，明确将 $\\Theta$ 作为 $-I$ 包含在内。\n- 以四分之一整数为单位 $n\\in\\{-2,-1,0,1\\}$ 来表示坐标，以确保精确计算。\n- 将 $64$ 个网格点中的每一个映射到其 IBZ 代表元，并按上述定义计算权重。\n\n测试套件：\n- 测试用例 1（一般覆盖性）：计算代表元总数 $|\\mathrm{IBZ}|$（整数）。\n- 测试用例 2（归一化检查）：计算总和 $\\sum_{\\mathbf{k}^\\star \\in \\mathrm{IBZ}} w(\\mathbf{k}^\\star)$（浮点数）。\n- 测试用例 3（高对称点）：计算中心 $\\Gamma$ 点 $\\mathbf{k} = (0,0,0)$ 的权重（浮点数）。\n- 测试用例 4（边界角点）：计算布里渊区角点 $\\mathbf{k} = (-\\tfrac{1}{2}, -\\tfrac{1}{2}, -\\tfrac{1}{2})$ 的权重（浮点数）。\n- 测试用例 5（边界棱点）：计算棱上点 $\\mathbf{k} = (-\\tfrac{1}{2}, 0, 0)$ 的权重（浮点数）。\n- 测试用例 6（含零分量的普通内部点）：计算内部点 $\\mathbf{k} = (-\\tfrac{1}{4}, 0, \\tfrac{1}{4})$ 的权重（浮点数）。\n- 测试用例 7（布尔归一化）：返回一个布尔值，指示归一化检查是否满足 $|\\sum w - 1|  10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序如下：\n$$\n\\big[\\, |\\mathrm{IBZ}|, \\, \\sum w, \\, w(0,0,0), \\, w(-\\tfrac{1}{2},-\\tfrac{1}{2},-\\tfrac{1}{2}), \\, w(-\\tfrac{1}{2},0,0), \\, w(-\\tfrac{1}{4},0,\\tfrac{1}{4}), \\, \\text{boolean} \\,\\big].\n$$\n所有浮点值都应以十进制形式打印；布尔值应打印为 $\\text{True}$ 或 $\\text{False}$。不应打印任何其他文本。", "solution": "问题在于，对于一个简单立方晶体第一布里渊区（BZ）内指定的均匀网格，需要确定不可约 $\\mathbf{k}$ 点集及其相应的权重。这一简化是通过利用晶体的点群对称性（特别是八面体群 $O_h$）并结合时间反演对称性来实现的。该过程涉及将完整网格中的每个点映射到从其对称生成的轨道中选出的一个典范代表元。\n\n### 1. 对称群与k点网格表示\n\n晶体的对称性由八面体点群 $O_h$ 描述。在倒易空间中，该群的 $48$ 个操作由所有 $3\\times 3$ 带符号的置换矩阵集合表示，这些矩阵是正交矩阵，其元素在 $\\{-1, 0, 1\\}$ 中，且每行每列只有一个非零元素。我们将这个矩阵集合表示为 $\\mathcal{G}$。时间反演对称性 $\\Theta: \\mathbf{k} \\mapsto -\\mathbf{k}$ 对应于矩阵 $-I$。用于我们简化的完整对称群是 $\\mathcal{G} \\cup \\{-I\\}$，在移除重复项后（因为 $-I \\in \\mathcal{G}$），该集合恰好包含 $48$ 个唯一的操作。\n\n$\\mathbf{k}$ 点网格 $\\mathcal{K}$ 是一个均匀的 $4\\times 4\\times 4$ 网格。每个分量 $k_{\\alpha}$ 的坐标取自 $\\{-\\tfrac{1}{2}, -\\tfrac{1}{4}, 0, \\tfrac{1}{4}\\}$。为了实现精确的整数运算，我们将其乘以因子 $4$，用整数向量 $(n_x, n_y, n_z)$ 表示网格点，其中每个分量 $n_{\\alpha} \\in \\{-2, -1, 0, 1\\}$。\n\n### 2. 周期性边界条件与包裹\n\n布里渊区被定义为半开立方体 $[-\\tfrac{1}{2}, \\tfrac{1}{2})^3$。在我们的整数坐标系中，这对应于每个分量 $n_{\\alpha}$ 都在集合 $\\{-2, -1, 0, 1\\}$ 中。将对称操作 $R$ 应用于向量 $\\mathbf{k}$ 可能会产生一个分量在此范围之外的向量 $R\\mathbf{k}$。具体来说，对于一个分量为 $k_\\alpha = \\tfrac{1}{4}$（或 $n_\\alpha = 1$）的网格点 $\\mathbf{k}$，一个使其变号并乘以2的操作可能会产生 $-\\tfrac{1}{2}$（$n_\\alpha=-2$）。但对于网格本身，我们关心的是落在布里渊区边界上的情况。当一个操作作用于一个点，例如 `(-2, -1, 0)`，结果可能包含值为 `2` 的分量，根据周期性边界条件，它应被包裹回 `-2`。\n\n### 3. 不可约布里渊区（IBZ）简化算法\n\n任务的核心是将完整网格 $\\mathcal{K}$ 划分为不相交的对称等价点集，即轨道。从每个轨道中，选择一个单一的典范代表元来构成不可约布里渊区（IBZ）。该代表元的权重是其轨道中的点的数量（即轨道大小）除以网格中的总点数。然而，问题定义的权重是映射到该代表元的所有网格点的比例。\n\n算法流程如下：\n1.  **生成对称操作**：构建代表 $O_h$ 操作（包括反演）的 $48$ 个唯一的 $3\\times 3$ 整数矩阵。\n2.  **初始化数据结构**：创建一个字典，用于将网格中的每个点映射到其典范代表元。\n3.  **迭代与映射**：对于网格 $\\mathcal{K}$ 中的每个点 $\\mathbf{k}$（以整数坐标表示）：\n    a.  **生成轨道**：通过对 $\\mathbf{k}$ 应用每一个对称操作 $R$ 并遵循周期性包裹规则（`2` 映射到 `-2`），计算生成的所有唯一点的集合。这个集合是 $\\mathrm{Orbit}(\\mathbf{k})$。\n    b.  **寻找典范代表元**：通过选择 $\\mathrm{Orbit}(\\mathbf{k})$ 中字典序最小的向量，来确定该轨道的代表元 $\\mathbf{k}^\\star$。\n    c.  **存储映射**：记录 $\\mathbf{k}$ 映射到 $\\mathbf{k}^\\star$。\n4.  **计数与加权**：遍历所有64个点的映射后，我们得到一个从每个 `k` 到其 `k_star` 的映射。为了计算权重，我们反转这个过程：\n    a. 创建一个字典 `rep_counts` 来存储每个代表元 `k_star` 的计数。\n    b. 遍历 `k_to_rep` 映射中的所有值（即所有的 `k_star`），并统计每个 `k_star` 出现的次数。\n    c. 唯一代表元的集合 `IBZ` 就是 `rep_counts` 的键集。\n    d. 对于每个 `k_star`，其权重是 `rep_counts[k_star] / 64`。\n\n### 4. 测试用例结果计算\n\n应用此算法可将 $64$ 个网格点分为 $10$ 个不同的轨道，每个轨道由其字典序最小的代表元标识。\n\n-   **测试用例 1 ($|\\mathrm{IBZ}|$)**：共有 $10$ 个唯一的代表元。\n-   **测试用例 2 ($\\sum w$)**：所有权重的总和为 $64/64 = 1.0$。\n-   **测试用例 3 ($w(0,0,0)$)**：点 $(0,0,0)$ 是其自身的代表元。只有一个点映射到它。其权重为 $1/64$。\n-   **测试用例 4 ($w(-\\tfrac{1}{2},-\\tfrac{1}{2},-\\tfrac{1}{2})$)**：点 $(-2,-2,-2)$ 在整数坐标中是其自身的代表元。只有一个点映射到它。其权重为 $1/64$。\n-   **测试用例 5 ($w(-\\tfrac{1}{2},0,0)$)**：点 $(-2,0,0)$ 的代表元是其自身。有3个点（$(-2,0,0), (0,-2,0), (0,0,-2)$）映射到这个代表元。其权重为 $3/64$。\n-   **测试用例 6 ($w(-\\tfrac{1}{4},0,\\tfrac{1}{4})$)**：点 `(-1, 0, 1)`（对应于 $(-\\tfrac{1}{4},0,\\tfrac{1}{4})$）的代表元是 `(-1,-1,0)`。共有12个网格点（` (±1,±1,0)` 的所有排列）映射到 `(-1,-1,0)` 这个代表元。因此，权重是 $12/64$。\n-   **测试用例 7（归一化）**：权重总和恰好为 $1.0$，因此满足条件 $|\\sum w - 1|  10^{-12}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes the irreducible Brillouin zone (IBZ) and weights for a given\n    k-point grid under octahedral group symmetry (O_h).\n    \"\"\"\n\n    # 1. Construct Symmetry Operations for the O_h group\n    # O_h is represented by all 3x3 signed permutation matrices.\n    permutations = list(itertools.permutations([0, 1, 2]))\n    sign_flips = list(itertools.product([-1, 1], repeat=3))\n    \n    op_matrices_set = set()\n    for p in permutations:\n        for s in sign_flips:\n            op = np.zeros((3, 3), dtype=int)\n            op[0, p[0]] = s[0]\n            op[1, p[1]] = s[1]\n            op[2, p[2]] = s[2]\n            op_matrices_set.add(tuple(map(tuple, op)))\n\n    # Explicitly include time-reversal (-I) and deduplicate.\n    # Note: -I is already in the set of signed permutation matrices.\n    neg_I = tuple(map(tuple, -np.identity(3, dtype=int)))\n    op_matrices_set.add(neg_I)\n    \n    # Final list of numpy array representations for the operations.\n    symmetry_ops = [np.array(op, dtype=int) for op in op_matrices_set]\n    \n    # 2. Define the k-point grid and the periodic wrapping function\n    # Coordinates are in integer quarter units: {-2, -1, 0, 1}\n    integer_coords = [-2, -1, 0, 1]\n    k_points = list(itertools.product(integer_coords, repeat=3))\n    total_k_points = len(k_points)\n\n    def wrap_vector(v):\n        \"\"\"Applies periodic wrapping to a k-vector component: 2 -> -2.\"\"\"\n        return tuple(-2 if c == 2 else c for c in v)\n\n    # 3.  4. Find IBZ representatives and count their occurrences\n    k_to_rep = {}\n    \n    # Cache for computed representatives to speed up\n    memoized_reps = {}\n\n    for k_tuple in k_points:\n        if k_tuple in memoized_reps:\n            k_to_rep[k_tuple] = memoized_reps[k_tuple]\n            continue\n            \n        k_vec = np.array(k_tuple)\n        \n        orbit = set()\n        for op in symmetry_ops:\n            # Apply symmetry operation and wrap coordinates\n            transformed_k = op @ k_vec\n            wrapped_k = wrap_vector(transformed_k)\n            orbit.add(wrapped_k)\n        \n        # The canonical representative is the lexicographically smallest in the orbit\n        canonical_rep = min(orbit)\n        k_to_rep[k_tuple] = canonical_rep\n        # All points in the orbit have the same representative\n        for point_in_orbit in orbit:\n            if point_in_orbit in k_points: # Check if the point is actually on our grid\n                memoized_reps[point_in_orbit] = canonical_rep\n        \n    # Count how many k-points from the full grid map to each representative\n    rep_counts = {}\n    for rep in k_to_rep.values():\n        rep_counts[rep] = rep_counts.get(rep, 0) + 1\n\n    # 5. Compute weights for each representative in the IBZ\n    ibz_k_points = rep_counts.keys()\n    weights = {k_star: count / total_k_points for k_star, count in rep_counts.items()}\n\n    # 6. Evaluate the test suite queries\n    # Test case 1: Total number of representatives in the IBZ\n    num_ibz = len(ibz_k_points)\n\n    # Test case 2: Sum of all weights (should be 1.0)\n    sum_of_weights = sum(weights.values())\n\n    # Test case 3: Weight of the Gamma point k = (0, 0, 0)\n    gamma_point_rep = k_to_rep[(0, 0, 0)]\n    w_gamma = weights.get(gamma_point_rep, 0.0)\n\n    # Test case 4: Weight of the corner point k = (-1/2, -1/2, -1/2) -> (-2, -2, -2)\n    corner_point_int = (-2, -2, -2)\n    corner_rep = k_to_rep[corner_point_int]\n    w_corner = weights.get(corner_rep, 0.0)\n\n    # Test case 5: Weight of the edge point k = (-1/2, 0, 0) -> (-2, 0, 0)\n    edge_point_int = (-2, 0, 0)\n    edge_rep = k_to_rep[edge_point_int]\n    w_edge = weights.get(edge_rep, 0.0)\n\n    # Test case 6: Weight of the point k = (-1/4, 0, 1/4) -> (-1, 0, 1)\n    generic_point_int = (-1, 0, 1)\n    generic_rep = k_to_rep[generic_point_int]\n    w_generic = weights.get(generic_rep, 0.0)\n\n    # Test case 7: Boolean check for normalization\n    is_normalized = abs(sum_of_weights - 1.0)  1e-12\n\n    results = [\n        num_ibz,\n        sum_of_weights,\n        w_gamma,\n        w_corner,\n        w_edge,\n        w_generic,\n        is_normalized\n    ]\n\n    # Final print statement in the exact required format.\n    # Convert boolean to string 'True' or 'False'\n    results_str = [str(r) for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3459449"}, {"introduction": "对于某些物理性质，尤其是像电导率这样的各向异性输运性质，标准的均匀k点网格可能收敛很慢且效率低下。本练习将引导你探索一个高级主题：如何根据费米面的形状设计各向异性的k点网格，以加速特定物理量的收敛 [@problem_id:3459479]。通过对比各向同性与各向异性网格的计算误差，你将深刻理解到针对问题调整采样策略的重要性。", "problem": "考虑晶体中布洛赫电子的三维各向异性抛物线能带。在能带极值附近的电子能量色散由 $E(\\mathbf{k}) = \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{\\hbar^2 k_\\alpha^2}{2 m^*_\\alpha}$ 给出，其中 $m^*_\\alpha$ 是与方向相关的有效质量，$\\hbar$ 是约化普朗克常数，$\\mathbf{k} = (k_x, k_y, k_z)$ 是晶体动量。群速度定义为 $v_\\alpha(\\mathbf{k}) = \\frac{1}{\\hbar} \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha}$。在具有恒定散射时间 $\\tau$ 的半经典玻尔兹曼输运理论的弛豫时间近似中，电导率张量元 $\\sigma_{\\alpha\\beta}$ 与在布里渊区上对 $v_\\alpha(\\mathbf{k}) v_\\beta(\\mathbf{k}) \\delta(E(\\mathbf{k}) - E_F)$ 的积分成正比，其中 $E_F$ 是费米能，$\\delta$ 是狄拉克δ函数。\n\n您的任务是设计并实现一个计算实验，通过根据有效质量 $m^*_\\alpha$ 缩放网格轴，来验证在使用与拉长的费米面对齐的各向异性k点网格时，输运张量分量的收敛性得到了改善。在无量纲单位制（$\\hbar = 1$）下进行计算，并将所有物理量视为无量纲量；最终输出必须是无量纲实数。本问题不使用角度。\n\n从上述基本定义出发，实现以下内容：\n\n1. 在以 $\\mathbf{k}=\\mathbf{0}$ 为中心的矩形域上构建两种不同的k点采样策略：\n   - 基准各向同性均匀网格，其中 $N_x = N_y = N_z = N_{\\mathrm{base}}$。\n   - 各向异性网格，其中沿每个轴的点数 $N_\\alpha$ 与该轴方向上费米面的范围成比例缩放，并选择使得总点数 $N_x N_y N_z$ 约等于基准总点数。沿每个轴使用矩形域半宽 $K_{\\max,\\alpha}$，其大小随该方向上的费米波矢范围缩放。具体来说，选择 $K_{\\max,\\alpha} = s \\, k_{F,\\alpha}$，其中安全因子 $s  1$ 以确保能量壳层包含在域内。\n\n2. 使用宽度参数 $\\eta$ 较小的归一化高斯函数 $g_\\eta(E(\\mathbf{k}) - E_F) = \\frac{1}{\\sqrt{2\\pi}\\,\\eta} \\exp\\!\\left(-\\frac{(E(\\mathbf{k}) - E_F)^2}{2 \\eta^2}\\right)$ 来近似狄拉克δ函数 $\\delta(E(\\mathbf{k}) - E_F)$。\n\n3. 对每个网格，计算无量纲输运向量 $\\mathbf{S} = (S_x,S_y,S_z)$ 的对角分量，其中 $S_\\alpha$ 与 $\\int v_\\alpha(\\mathbf{k})^2 \\delta(E(\\mathbf{k}) - E_F) \\, d^3k$ 的离散近似成正比，然后进行归一化以使 $\\sum_{\\alpha} S_\\alpha = 1$。\n\n4. 从第一性原理出发，推导各向异性抛物线能带的归一化对角分量 $\\mathbf{S}^{\\mathrm{exact}}$ 的精确解析参考值，并用它来量化每个网格的误差，误差定义为欧几里得范数 $||\\mathbf{S} - \\mathbf{S}^{\\mathrm{exact}}||_2$。\n\n5. 通过计算每个测试用例的基准各向同性网格误差和各向异性网格误差，并报告各向异性网格是否产生严格更小的误差，来验证收敛性的改善。\n\n使用中点采样（单元中心）和均匀矩形规则进行数值积分。您的域半宽 $K_{\\max,\\alpha}$ 必须足够大以捕获由 $E(\\mathbf{k}) = E_F$ 定义的能量壳层；选择 $K_{\\max,\\alpha} = s \\, k_{F,\\alpha}$，其中 $s = 2.0$。在无量纲单位制中，$\\hbar = 1$，与轴相关的费米波矢 $k_{F,\\alpha}$ 由色散关系所蕴含的恒定能量椭球体沿轴 $\\alpha$ 的半径给出。各向异性网格尺寸 $N_\\alpha$ 必须与 $k_{F,\\alpha}$ 成比例缩放，并进行归一化以使 $N_x N_y N_z \\approx N_{\\mathrm{base}}^3$，同时每个 $N_\\alpha \\geq 3$。\n\n测试套件：\n实现您的程序以运行以下测试用例，每个用例均以上述无量纲约定指定为 $(m^*_x, m^*_y, m^*_z, E_F, N_{\\mathrm{base}}, \\eta)$：\n- 用例 A（常规路径）：$(0.2, 1.0, 5.0, 0.20, 14, 0.010)$。\n- 用例 B（各向同性边界情况）：$(1.0, 1.0, 1.0, 0.20, 14, 0.010)$。\n- 用例 C（强各向异性边缘情况）：$(0.05, 1.2, 25.0, 0.15, 14, 0.007)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的三个测试用例的结果列表。每个测试用例的结果本身必须是一个列表，按顺序包含三个条目：各向同性网格误差（浮点数）、各向异性网格误差（浮点数）以及一个布尔值，指示各向异性网格误差是否严格小于各向同性网格误差。例如，输出必须具有格式 \"[[e_iso_A,e_aniso_A,improved_A],[e_iso_B,e_aniso_B,improved_B],[e_iso_C,e_aniso_C,improved_C]]\"，其中每个 \"e_*\" 都是一个无量纲浮点数。", "solution": "问题陈述已经过评估，并被确定为有效。它在科学上基于固态物理学原理，问题定义明确、客观、自洽且内部一致。它提出了一个既可行又可验证的非平凡计算任务。\n\n### 1. 理论框架与解析解\n\n问题要求我们分析一个与输运相关物理量在各向异性能带结构下的数值收敛性。问题的核心在于计算布里渊区上的一个积分，该积分在弛豫时间近似下与电导率张量的一个分量成正比。\n\n电子能量色散由各向异性抛物线模型给出：\n$$ E(\\mathbf{k}) = \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{\\hbar^2 k_\\alpha^2}{2 m^*_\\alpha} $$\n其中 $m^*_\\alpha$ 是沿主轴 $\\alpha$ 的有效质量，$\\mathbf{k} = (k_x, k_y, k_z)$ 是晶体动量矢量。问题在无量纲单位制中表述，其中约化普朗克常数 $\\hbar = 1$，因此色散简化为：\n$$ E(\\mathbf{k}) = \\sum_{\\alpha} \\frac{k_\\alpha^2}{2 m^*_\\alpha} $$\n电子在态 $\\mathbf{k}$ 的群速度定义为：\n$$ v_\\alpha(\\mathbf{k}) = \\frac{1}{\\hbar} \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha} = \\frac{\\partial E(\\mathbf{k})}{\\partial k_\\alpha} = \\frac{k_\\alpha}{m^*_\\alpha} $$\n我们的任务是计算归一化输运向量 $\\mathbf{S}$ 的对角分量，其中每个分量 $S_\\alpha$ 源自未归一化的积分 $I_\\alpha$：\n$$ I_\\alpha = \\int_{\\text{BZ}} v_\\alpha(\\mathbf{k})^2 \\delta(E(\\mathbf{k}) - E_F) \\, d^3k $$\n此处，$E_F$ 是费米能，$\\delta$ 是狄拉克δ函数，它将积分限制在恒定能量面 $E(\\mathbf{k}) = E_F$ 上，该能量面被称为费米面。\n\n为了推导精确的解析参考值 $\\mathbf{S}^{\\mathrm{exact}}$，我们计算积分 $I_\\alpha$。代入 $v_\\alpha$ 和 $E(\\mathbf{k})$ 的表达式：\n$$ I_\\alpha = \\int \\left(\\frac{k_\\alpha}{m^*_\\alpha}\\right)^2 \\delta\\left(\\sum_{\\beta} \\frac{k_\\beta^2}{2 m^*_\\beta} - E_F\\right) \\, d^3k $$\n为了求解此积分，我们进行变量代换，将椭球形费米面映射到单位球面上。让我们定义一组新坐标 $\\mathbf{q} = (q_x, q_y, q_z)$，使得：\n$$ q_\\beta = \\frac{k_\\beta}{\\sqrt{2 m^*_\\beta E_F}} $$\n这意味着 $k_\\beta = q_\\beta \\sqrt{2 m^*_\\beta E_F}$。此变换对体积元的雅可比行列式为：\n$$ d^3k = \\left(\\frac{\\partial k_x}{\\partial q_x}\\frac{\\partial k_y}{\\partial q_y}\\frac{\\partial k_z}{\\partial q_z}\\right) d^3q = \\left(\\sqrt{2 m^*_x E_F} \\sqrt{2 m^*_y E_F} \\sqrt{2 m^*_z E_F}\\right) d^3q \\\\ = (2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z} \\, d^3q $$\n能量表达式变换为：\n$$ E(\\mathbf{q}) = \\sum_{\\beta} \\frac{(q_\\beta \\sqrt{2 m^*_\\beta E_F})^2}{2 m^*_\\beta} = E_F \\sum_{\\beta} q_\\beta^2 = E_F |\\mathbf{q}|^2 $$\n狄拉克δ函数的宗量变为 $E_F|\\mathbf{q}|^2 - E_F = E_F(|\\mathbf{q}|^2 - 1)$。利用性质 $\\delta(ax) = \\frac{1}{|a|}\\delta(x)$，我们有 $\\delta(E_F(|\\mathbf{q}|^2 - 1)) = \\frac{1}{E_F}\\delta(|\\mathbf{q}|^2 - 1)$。\n\n$v_\\alpha^2 = (k_\\alpha/m^*_\\alpha)^2$ 项变为：\n$$ \\left(\\frac{q_\\alpha \\sqrt{2 m^*_\\alpha E_F}}{m^*_\\alpha}\\right)^2 = \\frac{q_\\alpha^2 (2 m^*_\\alpha E_F)}{(m^*_\\alpha)^2} = \\frac{2 E_F}{m^*_\\alpha} q_\\alpha^2 $$\n将所有变换后的部分代回 $I_\\alpha$ 的积分中：\n$$ I_\\alpha = \\int \\left(\\frac{2 E_F}{m^*_\\alpha} q_\\alpha^2\\right) \\left(\\frac{1}{E_F} \\delta(|\\mathbf{q}|^2 - 1)\\right) \\left((2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z}\\right) d^3q $$\n$$ I_\\alpha = \\frac{2}{m^*_\\alpha} \\left((2E_F)^{3/2} \\sqrt{m^*_x m^*_y m^*_z}\\right) \\int q_\\alpha^2 \\delta(|\\mathbf{q}|^2 - 1) \\, d^3q $$\n积分 $\\int q_\\alpha^2 \\delta(|\\mathbf{q}|^2 - 1) \\, d^3q$ 现在是在 $\\mathbf{q}$ 空间中的单位球面上进行的。根据对称性，对于 $\\alpha=x, y, z$，此积分具有相同的值。设此常数值为 $C_q$。$I_\\alpha$ 表达式中所有其他依赖于材料参数（$m^*_\\alpha$）或 $E_F$ 的项都被提了出来。我们看到，对轴索引 $\\alpha$ 的依赖性仅通过前置因子体现：\n$$ I_\\alpha \\propto \\frac{1}{m^*_\\alpha} $$\n因此，未归一化的输运分量为 $S'_\\alpha = C \\cdot (1/m^*_\\alpha)$，其中 $C$ 是某个常数。为了找到归一化向量 $\\mathbf{S}^{\\mathrm{exact}}$，我们计算：\n$$ S^{\\mathrm{exact}}_\\alpha = \\frac{S'_\\alpha}{\\sum_{\\beta} S'_\\beta} = \\frac{C/m^*_\\alpha}{\\sum_{\\beta} C/m^*_\\beta} = \\frac{1/m^*_\\alpha}{1/m^*_x + 1/m^*_y + 1/m^*_z} $$\n这就是将作为我们参考的精确解析结果。\n\n### 2. 数值积分方案\n\n问题要求对积分 $I_\\alpha$ 进行数值近似。狄拉克δ函数由一个窄高斯函数近似：\n$$ \\delta(E - E_F) \\approx g_\\eta(E - E_F) = \\frac{1}{\\sqrt{2\\pi}\\,\\eta} \\exp\\left(-\\frac{(E(\\mathbf{k}) - E_F)^2}{2 \\eta^2}\\right) $$\n积分在 $\\mathbf{k}$ 空间中的一个有限矩形域上进行，该域由半宽 $K_{\\max,\\alpha} = s \\cdot k_{F,\\alpha}$ 定义，其中安全因子 $s=2.0$。费米波矢 $k_{F,\\alpha}$ 表示费米面沿轴 $\\alpha$ 的范围，通过设置 $E(\\mathbf{k})=E_F$ 和 $k_\\beta=0$（对于 $\\beta \\neq \\alpha$）来找到：\n$$ E_F = \\frac{k_{F,\\alpha}^2}{2 m^*_\\alpha} \\implies k_{F,\\alpha} = \\sqrt{2 m^*_\\alpha E_F} $$\n积分使用矩形网格上的中点法则进行离散化。对于沿每个轴有 $N_\\alpha$ 个点且半宽为 $K_{\\max,\\alpha}$ 的网格，步长为 $\\Delta k_\\alpha = 2K_{\\max,\\alpha}/N_\\alpha$。网格点是积分单元的中心：\n$$ k_{\\alpha,i} = -K_{\\max,\\alpha} + (i + 0.5) \\Delta k_\\alpha, \\quad i = 0, 1, \\dots, N_\\alpha - 1 $$\n$\\mathbf{k}$ 空间中每个单元的体积是 $\\Delta V_k = \\Delta k_x \\Delta k_y \\Delta k_z$。$I_\\alpha$ 的数值近似为：\n$$ I_\\alpha \\approx \\sum_{i,j,l} v_\\alpha(\\mathbf{k}_{ijl})^2 \\, g_\\eta(E(\\mathbf{k}_{ijl}) - E_F) \\, \\Delta V_k $$\n其中求和遍及所有网格点 $\\mathbf{k}_{ijl} = (k_{x,i}, k_{y,j}, k_{z,l})$。计算出未归一化的分量 $S'_\\alpha \\approx I_\\alpha$ 后，将它们归一化以获得数值结果 $\\mathbf{S}$。\n\n### 3. 网格构建\n\n比较了两种不同的采样网格：\n\n- **各向同性网格**：此网格沿每个轴使用相同数量的点，$N_x = N_y = N_z = N_{\\mathrm{base}}$。总点数为 $N_{\\mathrm{base}}^3$。\n\n- **各向异性网格**：此网格使采样密度适应费米面的形状。对于一个拉长的椭球体，沿较长轴分配更多的点。点数 $N_\\alpha$ 与费米波矢范围 $k_{F,\\alpha}$ 成比例缩放：\n$$ N_\\alpha \\propto k_{F,\\alpha} $$\n选择一个归一化常数，使得总点数与各向同性情况大致相同：$N_x N_y N_z \\approx N_{\\mathrm{base}}^3$。这引出了以下缩放规则：\n$$ N_\\alpha = \\text{round}\\left( N_{\\mathrm{base}} \\frac{k_{F,\\alpha}}{(k_{F,x}k_{F,y}k_{F,z})^{1/3}} \\right) $$\n每个 $N_\\alpha$ 被约束为至少为 $3$。该策略旨在使费米面单位表面积上的采样点数量大致恒定，这对于固定的总点数应能带来更高的精度。\n\n### 4. 误差计算\n\n对于每种网格类型（各向同性和各向异性），将计算出的归一化向量 $\\mathbf{S}^{\\mathrm{num}}$ 与解析参考值 $\\mathbf{S}^{\\mathrm{exact}}$ 进行比较。误差使用差分向量的欧几里得范数量化：\n$$ \\text{error} = ||\\mathbf{S}^{\\mathrm{num}} - \\mathbf{S}^{\\mathrm{exact}}||_2 = \\sqrt{\\sum_{\\alpha} (S^{\\mathrm{num}}_\\alpha - S^{\\mathrm{exact}}_\\alpha)^2} $$\n最后一步是比较两种网格的误差，以验证对于各向异性系统，各向异性网格能提供更准确的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational experiment for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: (m*_x, m*_y, m*_z, E_F, N_base, eta)\n        (0.2, 1.0, 5.0, 0.20, 14, 0.010),\n        # Case B\n        (1.0, 1.0, 1.0, 0.20, 14, 0.010),\n        # Case C\n        (0.05, 1.2, 25.0, 0.15, 14, 0.007),\n    ]\n\n    results = []\n    for case in test_cases:\n        m_stars_tuple, E_F, N_base, eta = case[0:3], case[3], case[4], case[5]\n        m_stars = np.array(m_stars_tuple)\n\n        # 1. Derive the exact analytical reference S^exact\n        inv_m_stars = 1.0 / m_stars\n        S_exact = inv_m_stars / np.sum(inv_m_stars)\n\n        # 2. Define integration domain and common parameters\n        s_factor = 2.0\n        kF_vec = np.sqrt(2 * m_stars * E_F)\n        Kmax_vec = s_factor * kF_vec\n\n        # Helper function for the numerical calculation\n        def _calculate_S(m_s, EF, n_eta, N_vec, K_vec):\n            \"\"\"\n            Calculates the normalized transport vector S for a given grid.\n            \"\"\"\n            m_x, m_y, m_z = m_s\n            Nx, Ny, Nz = N_vec\n            Kmax_x, Kmax_y, Kmax_z = K_vec\n\n            # Create k-point coordinates using midpoint rule\n            delta_k = 2 * K_vec / N_vec\n            kx_pts = -Kmax_x + (np.arange(Nx) + 0.5) * delta_k[0]\n            ky_pts = -Kmax_y + (np.arange(Ny) + 0.5) * delta_k[1]\n            kz_pts = -Kmax_z + (np.arange(Nz) + 0.5) * delta_k[2]\n\n            # Create 3D grid\n            Kx, Ky, Kz = np.meshgrid(kx_pts, ky_pts, kz_pts, indexing='ij')\n\n            # Calculate energy and velocity squared on the grid\n            E = Kx**2 / (2 * m_x) + Ky**2 / (2 * m_y) + Kz**2 / (2 * m_z)\n            Vx_sq = (Kx / m_x)**2\n            Vy_sq = (Ky / m_y)**2\n            Vz_sq = (Kz / m_z)**2\n\n            # Approximate Dirac delta with a Gaussian\n            gauss_arg = -(E - EF)**2 / (2 * n_eta**2)\n            gaussian = (1.0 / (np.sqrt(2 * np.pi) * n_eta)) * np.exp(gauss_arg)\n\n            # Numerical integration\n            dV_k = delta_k[0] * delta_k[1] * delta_k[2]\n            S_prime_x = np.sum(Vx_sq * gaussian) * dV_k\n            S_prime_y = np.sum(Vy_sq * gaussian) * dV_k\n            S_prime_z = np.sum(Vz_sq * gaussian) * dV_k\n            \n            S_prime_vec = np.array([S_prime_x, S_prime_y, S_prime_z])\n            total_S_prime = np.sum(S_prime_vec)\n\n            if total_S_prime  1e-15:\n                # Fallback for cases where integral is zero, though unlikely here\n                return np.array([1/3.0, 1/3.0, 1/3.0])\n\n            # Normalize the vector\n            return S_prime_vec / total_S_prime\n\n        # 3. Isotropic grid calculation\n        N_iso = np.array([N_base, N_base, N_base], dtype=int)\n        S_iso = _calculate_S(m_stars, E_F, eta, N_iso, Kmax_vec)\n        error_iso = np.linalg.norm(S_iso - S_exact)\n\n        # 4. Anisotropic grid calculation\n        # Handle case where a kF is zero to avoid division by zero or NaN\n        if np.any(kF_vec  1e-9):\n             kF_geom_mean = 1.0 # Avoid division by zero, will lead to isotropic grid\n             N_aniso_unrounded = np.full(3, N_base) \n        else:\n             kF_geom_mean = np.prod(kF_vec)**(1.0/3.0)\n             N_aniso_unrounded = N_base * kF_vec / kF_geom_mean\n        \n        N_aniso = np.maximum(3, np.round(N_aniso_unrounded)).astype(int)\n        \n        S_aniso = _calculate_S(m_stars, E_F, eta, N_aniso, Kmax_vec)\n        error_aniso = np.linalg.norm(S_aniso - S_exact)\n\n        # 5. Store results for the case\n        improved = error_aniso  error_iso\n        results.append([error_iso, error_aniso, improved])\n\n    # Final output formatting\n    # Example format: [[e_iso_A,e_aniso_A,improved_A],[e_iso_B,e_aniso_B,improved_B],...]\n    case_results_str = []\n    for res in results:\n        # res is [float, float, bool]\n        # str(True) -> 'True', str(False) -> 'False'\n        case_results_str.append(f\"[{res[0]},{res[1]},{str(res[2])}]\")\n    \n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```", "id": "3459479"}]}