{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方式就是动手实践。本节的第一个练习将指导你完成有限元方法中最基础也是最核心的任务：求解泊松方程。通过这个练习 [@problem_id:3502725]，你将学习如何将一个偏微分方程的弱形式转化为一个离散的代数方程组 $KU=F$，并亲手构建刚度矩阵和载荷向量，这对于理解变分原理如何具体应用于计算至关重要。", "problem": "考虑一个二维空间多边形域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量泊松边值问题，其边界为 $\\Gamma = \\overline{\\Gamma}_{\\mathrm{D}} \\cup \\overline{\\Gamma}_{\\mathrm{N}}$ 且 $\\Gamma_{\\mathrm{D}} \\cap \\Gamma_{\\mathrm{N}} = \\emptyset$。设 $u: \\Omega \\to \\mathbb{R}$ 为未知场，$f: \\Omega \\to \\mathbb{R}$ 为体源，$t: \\Gamma_{\\mathrm{N}} \\to \\mathbb{R}$ 为给定的诺伊曼通量，$\\kappa: \\Omega \\to \\mathbb{R}$ 为传导率。控制方程和边界条件的强形式为\n$$\n-\\nabla \\cdot (\\kappa \\nabla u) = f \\quad \\text{in } \\Omega,\\qquad u = u_{\\mathrm{D}} \\quad \\text{on } \\Gamma_{\\mathrm{D}},\\qquad -\\kappa \\nabla u \\cdot \\mathbf{n} = t \\quad \\text{on } \\Gamma_{\\mathrm{N}},\n$$\n其中 $\\mathbf{n}$ 是 $\\Gamma$ 上的外单位法向量，$u_{\\mathrm{D}}$ 是给定的狄利克雷边界值。\n\n以此为基础，推导其弱形式，并使用一阶（线性）三角形单元构建有限元离散化。将测试函数空间定义为 $V_0 = \\{ w \\in H^1(\\Omega) \\mid w = 0 \\text{ on } \\Gamma_{\\mathrm{D}} \\}$，试探函数空间定义为 $V = \\{ v \\in H^1(\\Omega) \\mid v = u_{\\mathrm{D}} \\text{ on } \\Gamma_{\\mathrm{D}} \\}$。将 $u$ 近似为 $u_h(\\mathbf{x}) = \\sum_{a=1}^{N} N_a(\\mathbf{x})\\, U_a$，其中 $N_a$ 是与网格节点相关的形函数，$U_a$ 是节点值。\n\n您的程序必须：\n- 从弱形式中推导出单元级刚度矩阵贡献 $K^{(e)}$ 和单元级载荷向量贡献 $F^{(e)}$。单元 $e$ 的刚度由 $\\nabla N_i \\cdot \\nabla N_j$ 的面积分乘以 $\\kappa$ 给出，载荷向量包括来自 $f$ 的体积部分和来自 $t$ 的边界（诺伊曼）部分。对于线形三角形和常数 $\\kappa$，单元级形函数的梯度在整个单元上是常数，对于常数 $f$，体积载荷贡献简化为单元面积的倍数。对于长度为 $L$、具有常数 $t$ 和线性形函数的边界边，其诺伊曼边界贡献是一致地分布到两个边节点上，且与 $\\int_{\\text{edge}} N_i \\, \\mathrm{d}\\Gamma$ 成正比。\n- 通过对单元贡献求和来组装全局刚度矩阵和载荷向量。通过遍历 $\\Gamma_{\\mathrm{N}}$ 上的边界边，并将它们的贡献加到全局载荷向量中来组装诺伊曼边界积分。\n- 使用标准分区法施加狄利克雷边界条件：将全局系统分解为自由自由度和约束自由度，并从简化系统 $K_{ff} U_f = F_f - K_{fc} U_c$ 中求解自由未知数 $U_f$，其中 $U_c$ 是 $\\Gamma_{\\mathrm{D}}$ 上给定的节点值。\n\n此问题中的所有量均为无量纲；最终输出结果不带物理单位。角度不出现在输出中，也不需要单位。程序必须以浮点值和列表的形式产生数值输出。\n\n为以下测试套件实现计算，其中节点索引从 0 开始，单元由构成线性形函数三角形的节点索引三元组 $(i,j,k)$ 给出：\n\n- 测试用例 1（单个三角形，混合边界）：\n    - 节点：$(0,0)$、$(1,0)$、$(0,1)$。\n    - 单元：$(0,1,2)$。\n    - 传导率：$\\kappa = 1$（常数）。\n    - 体源：$f(\\mathbf{x}) = 1$（常数）。\n    - 狄利克雷边界：节点 $0 \\mapsto 0$、$1 \\mapsto 0$。\n    - 诺伊曼边界边：$(1,2)$，其中 $t = 2$。\n    - 预期的组装行为：由于面积而产生非零的体积载荷，由于诺伊曼边而产生非零的边界载荷。\n\n- 测试用例 2（两个三角形组成单位正方形，仅顶部为诺伊曼边界）：\n    - 节点：$(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$。\n    - 单元：$(0,1,2)$ 和 $(0,2,3)$。\n    - 传导率：$\\kappa = 1$（常数）。\n    - 体源：$f(\\mathbf{x}) = 0$（常数）。\n    - 狄利克雷边界：节点 $0 \\mapsto 0$、$1 \\mapsto 0$、$3 \\mapsto 0$。\n    - 诺伊曼边界边：$(2,3)$，其中 $t = 1$。\n    - 预期的组装行为：体积载荷为零，顶部边产生非零的边界载荷。\n\n- 测试用例 3（两个三角形组成单位正方形，非零狄利克雷和顶部诺伊曼边界）：\n    - 节点：$(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$。\n    - 单元：$(0,1,2)$ 和 $(0,2,3)$。\n    - 传导率：$\\kappa = 1$（常数）。\n    - 体源：$f(\\mathbf{x}) = 1$（常数）。\n    - 狄利克雷边界：节点 $0 \\mapsto 5$、$3 \\mapsto 5$、$1 \\mapsto 0$。\n    - 诺伊曼边界边：$(2,3)$，其中 $t = 3$。\n    - 预期的组装行为：非零的体积载荷和非零的边界载荷。\n\n对于每个测试用例，您的程序应计算：\n- 总体积载荷贡献 $S_{\\mathrm{vol}} = \\sum_{a=1}^{N} F^{\\mathrm{vol}}_a$。\n- 总诺伊曼边界载荷贡献 $S_{\\mathrm{bnd}} = \\sum_{a=1}^{N} F^{\\Gamma}_a$。\n- 在通过分区施加狄利克雷边界条件并求解简化系统以获得自由节点后，汇总得到的已解节点值列表 $[U_0, U_1, \\dots, U_{N-1}]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，其本身也是一个形式为 $[S_{\\mathrm{vol}}, S_{\\mathrm{bnd}}, [U_0, U_1, \\dots]]$ 的列表。例如：$[[S_{\\mathrm{vol}}^{(1)}, S_{\\mathrm{bnd}}^{(1)}, [\\dots]], [S_{\\mathrm{vol}}^{(2)}, S_{\\mathrm{bnd}}^{(2)}, [\\dots]], [S_{\\mathrm{vol}}^{(3)}, S_{\\mathrm{bnd}}^{(3)}, [\\dots]]]$。", "solution": "该问题要求对二维标量泊松边值问题，进行有限元法（FEM）解的公式化和实现。该过程涉及推导控制偏微分方程的弱形式，使用线性三角形单元对其进行离散化，组装全局方程组，并在施加指定的边界条件后进行求解。\n\n### 弱形式推导\n控制方程的强形式为：\n$$\n-\\nabla \\cdot (\\kappa \\nabla u) = f \\quad \\text{in } \\Omega\n$$\n边界条件为 $\\Gamma_{\\mathrm{D}}$ 上的 $u = u_{\\mathrm{D}}$ 和 $\\Gamma_{\\mathrm{N}}$ 上的 $-\\kappa \\nabla u \\cdot \\mathbf{n} = t$。\n\n为推导弱形式，我们将控制方程乘以来自测试空间 $V_0 = \\{ w \\in H^1(\\Omega) \\mid w = 0 \\text{ on } \\Gamma_{\\mathrm{D}} \\}$ 的任意测试函数 $w$，并在域 $\\Omega$ 上进行积分：\n$$\n\\int_{\\Omega} w \\left( -\\nabla \\cdot (\\kappa \\nabla u) \\right) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega\n$$\n对左侧项应用散度定理（多维分部积分法），我们得到：\n$$\n\\int_{\\Omega} \\nabla w \\cdot (\\kappa \\nabla u) \\, \\mathrm{d}\\Omega - \\int_{\\Gamma} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega\n$$\n边界 $\\Gamma = \\overline{\\Gamma}_{\\mathrm{D}} \\cup \\overline{\\Gamma}_{\\mathrm{N}}$ 上的边界积分可以分解为：\n$$\n\\int_{\\Gamma} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma = \\int_{\\Gamma_{\\mathrm{D}}} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma + \\int_{\\Gamma_{\\mathrm{N}}} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma\n$$\n根据测试空间 $V_0$ 的定义，在 $\\Gamma_{\\mathrm{D}}$ 上 $w=0$，因此在 $\\Gamma_{\\mathrm{D}}$ 上的积分为零。在诺伊曼边界 $\\Gamma_{\\mathrm{N}}$ 上，我们有条件 $-\\kappa \\nabla u \\cdot \\mathbf{n} = t$。将此代入 $\\Gamma_{\\mathrm{N}}$ 上的边界积分，得到：\n$$\n\\int_{\\Gamma_{\\mathrm{N}}} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma = \\int_{\\Gamma_{\\mathrm{N}}} w (-t) \\, \\mathrm{d}\\Gamma = -\\int_{\\Gamma_{\\mathrm{N}}} w t \\, \\mathrm{d}\\Gamma\n$$\n将其代回积分方程，得到：\n$$\n\\int_{\\Omega} \\nabla w \\cdot (\\kappa \\nabla u) \\, \\mathrm{d}\\Omega - \\left( -\\int_{\\Gamma_{\\mathrm{N}}} w t \\, \\mathrm{d}\\Gamma \\right) = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega\n$$\n重新整理后，我们得到弱形式：寻找 $u \\in V = \\{ v \\in H^1(\\Omega) \\mid v = u_{\\mathrm{D}} \\text{ on } \\Gamma_{\\mathrm{D}} \\}$，使得对于所有 $w \\in V_0$：\n$$\n\\int_{\\Omega} \\nabla w \\cdot (\\kappa \\nabla u) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{\\mathrm{N}}} w t \\, \\mathrm{d}\\Gamma\n$$\n\n### 有限元离散化\n使用伽辽金法，我们用同一组形函数 $N_a(\\mathbf{x})$ 来近似试探函数 $u$ 和测试函数 $w$：\n$$\nu(\\mathbf{x}) \\approx u_h(\\mathbf{x}) = \\sum_{a=1}^{N} N_a(\\mathbf{x}) U_a \\qquad \\text{and} \\qquad w(\\mathbf{x}) \\approx w_h(\\mathbf{x}) = \\sum_{b=1}^{N} N_b(\\mathbf{x}) W_b\n$$\n其中 $U_a$ 和 $W_b$ 是场的节点值。由于此式必须对任意 $w_h \\in V_0$ 成立，因此它必须对每个对应于自由（非狄利克雷）自由度的基函数 $N_b$ 成立。将近似式代入弱形式，得到矩阵系统 $K U = F$：\n$$\n\\sum_{a=1}^{N} \\left( \\int_{\\Omega} \\kappa (\\nabla N_b \\cdot \\nabla N_a) \\, \\mathrm{d}\\Omega \\right) U_a = \\int_{\\Omega} f N_b \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{\\mathrm{N}}} t N_b \\, \\mathrm{d}\\Gamma\n$$\n因此，全局刚度矩阵 $K$ 和载荷向量 $F$ 的分量为：\n$$\nK_{ba} = \\int_{\\Omega} \\kappa (\\nabla N_b \\cdot \\nabla N_a) \\, \\mathrm{d}\\Omega \\qquad \\text{and} \\qquad F_b = \\int_{\\Omega} f N_b \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{\\mathrm{N}}} t N_b \\, \\mathrm{d}\\Gamma\n$$\n\n### 单元级公式化（线性三角形）\n全局矩阵是通过对每个单元 $\\Omega_e$ 的贡献求和来组装的。对于具有节点 $i, j, k$ 的单个线性三角形单元：\n- **单元刚度矩阵 $K^{(e)}$**：对于单元上为常数的传导率 $\\kappa$，积分得以简化。线性形函数的梯度在单元内是常数。\n$$\nK_{rs}^{(e)} = \\int_{\\Omega_e} \\kappa (\\nabla N_r \\cdot \\nabla N_s) \\, \\mathrm{d}\\Omega = \\kappa A_e (\\nabla N_r \\cdot \\nabla N_s) \\quad \\text{for } r, s \\in \\{i, j, k\\}\n$$\n其中 $A_e$ 是单元的面积。对于按逆时针排列的节点 $(x_i, y_i), (x_j, y_j), (x_k, y_k)$，形函数梯度为 $\\nabla N_r = \\frac{1}{2A_e} [b_r, c_r]^T$，其中 $b_i = y_j - y_k , c_i = x_k - x_j$，索引 $j, k$ 依此类推进行循环置换。这导致 $K_{rs}^{(e)} = \\frac{\\kappa}{4A_e}(b_r b_s + c_r c_s)$。\n\n- **单元体积载荷向量 $F^{\\mathrm{vol},(e)}$**：对于常数源项 $f$，其贡献为：\n$$\nF_r^{\\mathrm{vol},(e)} = \\int_{\\Omega_e} f N_r \\, \\mathrm{d}\\Omega = f \\int_{\\Omega_e} N_r \\, \\mathrm{d}\\Omega\n$$\n线性形函数在其三角形单元上的积分为 $A_e/3$。因此：\n$$\nF_r^{\\mathrm{vol},(e)} = \\frac{f A_e}{3} \\quad \\text{对于单元的每个节点 } r。\n$$\n\n- **诺伊曼边界载荷**：诺伊曼贡献不是基于单元的面积分，而是基于边的长度积分。对于节点 $r$ 和 $s$ 之间长度为 $L$ 且具有恒定通量 $t$ 的边界边，载荷被分布到这两个节点上：\n$$\nF_r^{\\Gamma} = \\int_{L} t N_r \\, \\mathrm{d}\\Gamma = t \\int_0^L (1-\\xi/L) \\, \\mathrm{d}\\xi = \\frac{t L}{2}\n$$\n$$\nF_s^{\\Gamma} = \\int_{L} t N_s \\, \\mathrm{d}\\Gamma = t \\int_0^L (\\xi/L) \\, \\mathrm{d}\\xi = \\frac{t L}{2}\n$$\n其中 $\\xi$ 是沿边的局部坐标。\n\n### 系统组装与求解\n全局刚度矩阵 $K$ 和总载荷向量 $F = F^{\\mathrm{vol}} + F^{\\Gamma}$ 是通过对单元级贡献求和来构建的。通过对系统进行分区来施加狄利克雷边界条件。设自由度（DoF）被分为自由（$f$）和约束（$c$）集。系统 $KU=F$ 重排为：\n$$\n\\begin{pmatrix} K_{ff} & K_{fc} \\\\ K_{cf} & K_{cc} \\end{pmatrix} \\begin{pmatrix} U_f \\\\ U_c \\end{pmatrix} = \\begin{pmatrix} F_f \\\\ F_c \\end{pmatrix}\n$$\n未知自由度 $U_f$ 通过求解从第一行块导出的简化系统来找到：\n$$\nK_{ff} U_f + K_{fc} U_c = F_f \\implies K_{ff} U_f = F_f - K_{fc} U_c\n$$\n求解出 $U_f$ 后，完整的解向量 $U$ 由已知的给定值 $U_c$ 和计算出的值 $U_f$ 组装而成。下面的程序为所提供的测试用例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(nodes, elements, kappa, f, dirichlet_bcs, neumann_bcs):\n    \"\"\"\n    Solves a single 2D Poisson FEM problem case.\n\n    Args:\n        nodes (list of tuples): Nodal coordinates, e.g., [(x0, y0), (x1, y1), ...].\n        elements (list of tuples): Element connectivity, e.g., [(n0, n1, n2), ...].\n        kappa (float): Thermal conductivity.\n        f (float): Volumetric source term.\n        dirichlet_bcs (dict): Prescribed nodal values, e.g., {node_idx: value}.\n        neumann_bcs (list of tuples): Neumann edges and flux, e.g., [((n0, n1), t)].\n\n    Returns:\n        tuple: (S_vol, S_bnd, U_list) where S_vol is total volumetric load,\n               S_bnd is total Neumann boundary load, and U_list is the list of\n               solved nodal values.\n    \"\"\"\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes))\n    F_vol = np.zeros(num_nodes)\n\n    # Assemble element stiffness matrix and volumetric load vector\n    for elem_nodes in elements:\n        # Get nodal coordinates for the current element\n        p_indices = list(elem_nodes)\n        p_coords = [nodes[i] for i in p_indices]\n        \n        # Calculate element area and ensure CCW ordering\n        area = 0.5 * (p_coords[0][0]*(p_coords[1][1]-p_coords[2][1]) + \n                      p_coords[1][0]*(p_coords[2][1]-p_coords[0][1]) + \n                      p_coords[2][0]*(p_coords[0][1]-p_coords[1][1]))\n        if area  0:\n             p_indices[1], p_indices[2] = p_indices[2], p_indices[1]\n             p_coords[1], p_coords[2] = p_coords[2], p_coords[1]\n             area = -area\n\n        # Calculate shape function gradient components (b and c vectors)\n        b = np.array([p_coords[1][1] - p_coords[2][1], \n                      p_coords[2][1] - p_coords[0][1], \n                      p_coords[0][1] - p_coords[1][1]])\n        c = np.array([p_coords[2][0] - p_coords[1][0], \n                      p_coords[0][0] - p_coords[2][0], \n                      p_coords[1][0] - p_coords[0][0]])\n        \n        # Element stiffness matrix\n        Ke = kappa / (4.0 * area) * (np.outer(b, b) + np.outer(c, c))\n        \n        # Assemble Ke into global K\n        for i_local, i_global in enumerate(p_indices):\n            for j_local, j_global in enumerate(p_indices):\n                K[i_global, j_global] += Ke[i_local, j_local]\n\n        # Element volumetric load vector (for constant f)\n        if f != 0:\n            Fe_vol = (f * area / 3.0) * np.ones(3)\n            for i_local, i_global in enumerate(p_indices):\n                F_vol[i_global] += Fe_vol[i_local]\n\n    S_vol = np.sum(F_vol)\n\n    # Assemble boundary load vector from Neumann conditions\n    F_bnd = np.zeros(num_nodes)\n    for edge, t in neumann_bcs:\n        p0_idx, p1_idx = edge\n        p0, p1 = nodes[p0_idx], nodes[p1_idx]\n        \n        length = np.sqrt((p1[0] - p0[0])**2 + (p1[1] - p0[1])**2)\n        \n        load_val = t * length / 2.0\n        F_bnd[p0_idx] += load_val\n        F_bnd[p1_idx] += load_val\n\n    S_bnd = np.sum(F_bnd)\n\n    # Total load vector\n    F = F_vol + F_bnd\n\n    # Apply Dirichlet boundary conditions via partitioning\n    all_dofs = set(range(num_nodes))\n    constrained_dofs = sorted(list(dirichlet_bcs.keys()))\n    free_dofs = sorted(list(all_dofs - set(constrained_dofs)))\n\n    U = np.zeros(num_nodes)\n    \n    # Handle the case where all DoFs are constrained\n    if not free_dofs:\n        for dof, val in dirichlet_bcs.items():\n            U[dof] = val\n        return S_vol, S_bnd, U.tolist()\n\n    U_c = np.array([dirichlet_bcs[i] for i in constrained_dofs])\n    \n    F_f = F[free_dofs]\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    \n    # Calculate right-hand side for the reduced system\n    rhs = F_f\n    if constrained_dofs:\n        K_fc = K[np.ix_(free_dofs, constrained_dofs)]\n        rhs -= K_fc @ U_c\n        \n    # Solve for free DOFs\n    U_f = np.linalg.solve(K_ff, rhs)\n\n    # Assemble full solution vector U\n    for i, dof in enumerate(free_dofs):\n        U[dof] = U_f[i]\n    for i, dof in enumerate(constrained_dofs):\n        U[dof] = U_c[i]\n\n    return S_vol, S_bnd, U.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Test Case 1\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2)],\n            \"kappa\": 1.0,\n            \"f\": 1.0,\n            \"dirichlet_bcs\": {0: 0.0, 1: 0.0},\n            \"neumann_bcs\": [((1, 2), 2.0)]\n        },\n        { # Test Case 2\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"kappa\": 1.0,\n            \"f\": 0.0,\n            \"dirichlet_bcs\": {0: 0.0, 1: 0.0, 3: 0.0},\n            \"neumann_bcs\": [((2, 3), 1.0)]\n        },\n        { # Test Case 3\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"kappa\": 1.0,\n            \"f\": 1.0,\n            \"dirichlet_bcs\": {0: 5.0, 3: 5.0, 1: 0.0},\n            \"neumann_bcs\": [((2, 3), 3.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_vol, s_bnd, u_list = solve_case(\n            case[\"nodes\"], \n            case[\"elements\"], \n            case[\"kappa\"], \n            case[\"f\"], \n            case[\"dirichlet_bcs\"], \n            case[\"neumann_bcs\"]\n        )\n        # Format the list of U values into a string\n        u_str = f\"[{','.join(f'{x:.8f}' for x in u_list)}]\"\n        # Store result for final printing\n        results.append(f\"[{s_vol:.8f},{s_bnd:.8f},{u_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3502725"}, {"introduction": "在掌握了基本流程后，我们来挑战一个更复杂的难题：四阶Cahn-Hilliard方程。直接对四阶偏微分方程使用标准有限元方法需要高阶连续的基函数，这在实现上非常复杂。这个练习 [@problem_id:3502772] 将向你展示如何通过引入辅助变量（即混合公式法），将原问题分解为一组耦合的二阶方程组，从而巧妙地规避了这一难题，并能继续使用简单的 $C^0$ 连续单元进行求解。", "problem": "考虑一个标量浓度场 $c(\\mathbf{x},t)$ 在一维域 $\\Omega=[0,L]$ 上的质量守恒相场演化，该演化由 Cahn–Hilliard 方程控制，其中浓度和化学势均采用齐次 Neumann 边界条件。控制定律为：(i) 质量守恒，即 $\\partial c / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$；(ii) 菲克通量与化学势梯度，$\\mathbf{J} = -\\mathcal{M} \\nabla \\mu$，其中 $\\mathcal{M}$ 是一个常数迁移率，$\\mu$ 是化学势。化学势由一个自由能泛函的变分导数得到，该泛函包含体能量密度 $f(c)$ 和梯度惩罚项 $\\kappa \\lvert \\nabla c \\rvert^2 / 2$，从而得到 $\\mu = f'(c) - \\kappa \\nabla^2 c$。使用双势阱密度 $f(c) = \\tfrac{1}{4}(c^2 - 1)^2$，因此 $f'(c) = c^3 - c$。所有量均为无量纲；不需要物理单位。\n\n您的任务是基于第一性原理：\n- 为质量平衡方程选择检验函数 $w \\in H^1(\\Omega)$，为化学势方程选择检验函数 $v \\in H^1(\\Omega)$，并在齐次 Neumann 边界条件下适当使用分部积分，推导出混合格式的弱形式。\n- 解释引入辅助变量 $\\mu$ 如何允许使用 $C^0$（连续、分段线性）有限元，并避免在试探空间中直接处理四阶空间导数。\n- 使用有限元法 (FEM) 和 $C^0$ 线性 Lagrange 基函数，在具有 $N$ 个单元的均匀网格上对弱形式进行空间离散化。设一致质量矩阵为 $M_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, \\mathrm{d}x$，刚度矩阵为 $K_{ij} = \\int_\\Omega \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}x$。\n- 使用时间步长为 $\\Delta t$ 的后向欧拉法进行时间离散化，并通过在上一时间层 $c^n$ 处计算非线性项 $f'(c)$ 来进行显式处理，从而求解一个关于 $c^{n+1}$ 和 $\\mu^{n+1}$ 的单一线性系统。组装耦合这两个场的最终分块线性系统。\n\n然后，实现一个程序，该程序：\n- 在 $[0,L]$ 上构建具有 $N$ 个均匀单元的一维网格，并组装全局矩阵 $M$ 和 $K$。\n- 通过 $c^n(x) = 0.2 \\cos\\left(2\\pi x / L\\right) + 0.1 \\cos\\left(\\pi x / L\\right)$ 在节点上初始化 $c^n(x)$。\n- 构造并求解线性化的混合系统，以进行单步后向欧拉计算，从而得到 $c^{n+1}$ 和 $\\mu^{n+1}$。\n- 求解后评估三个标量指标：\n  1. 绝对质量变化 $\\left|\\int_\\Omega c^{n+1} \\, \\mathrm{d}x - \\int_\\Omega c^{n} \\, \\mathrm{d}x\\right|$，通过有限元内积 $ \\mathbf{1}^\\top M \\mathbf{c}$ 近似，其中 $\\mathbf{1}$ 是节点值为 1 的向量，$\\mathbf{c}$ 是 $c$ 的节点向量。\n  2. 化学势方程残差的欧几里得范数 $\\left\\| M \\boldsymbol{\\mu}^{n+1} - M \\mathbf{f}'( \\mathbf{c}^{n}) + \\kappa K \\mathbf{c}^{n+1} \\right\\|_2$。\n  3. 质量平衡方程残差的欧几里得范数 $\\left\\| \\frac{1}{\\Delta t} M(\\mathbf{c}^{n+1} - \\mathbf{c}^{n}) + \\mathcal{M} K \\boldsymbol{\\mu}^{n+1} \\right\\|_2$。\n\n使用以下参数集测试套件，每个集合指定为 $(L,N,\\Delta t,\\kappa,\\mathcal{M})$：\n- 情况 A (一般情况): $(1,16,10^{-4},10^{-2},1)$。\n- 情况 B (更粗的网格，更大的步长): $(1,8,10^{-3},10^{-2},1)$。\n- 情况 C (零迁移率边缘情况): $(1,8,10^{-3},10^{-2},0)$。\n\n您的程序应生成一行输出，其中包含九个浮点指标，聚合为一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{A.质量变化},\\text{A.mu-残差},\\text{A.质量-残差},\\text{B.质量变化},\\text{B.mu-残差},\\text{B.质量-残差},\\text{C.质量变化},\\text{C.mu-残差},\\text{C.质量-残差}]$，每个值均以默认 Python 浮点格式打印。如果出现任何三角函数，角度均以弧度为单位。不需要物理单位；所有量都是无量纲的。", "solution": "该问题要求推导并对一维混合格式下的 Cahn–Hilliard 方程进行单时间步的数值求解。我们首先陈述控制方程，然后进行弱形式的推导、离散化以及待求解线性系统的构建。\n\n在域 $\\Omega=[0,L]$ 上的控制方程强形式由两个耦合的偏微分方程组给出：\n1. 质量守恒方程：$\\frac{\\partial c}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$，其中通量 $\\mathbf{J} = -\\mathcal{M} \\nabla \\mu$。两者结合得到 $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (\\mathcal{M} \\nabla \\mu)$。\n2. 化学势 $\\mu$ 的定义：$\\mu = f'(c) - \\kappa \\nabla^2 c$，其中 $f'(c) = c^3 - c$。\n\n两个场都应用齐次 Neumann 边界条件：在 $\\partial\\Omega = \\{0, L\\}$ 上，$\\nabla c \\cdot \\mathbf{n} = 0$ 和 $\\nabla \\mu \\cdot \\mathbf{n} = 0$。\n\n**1. 弱形式的推导**\n\n为推导弱形式，我们分别为质量平衡方程和化学势方程引入两个检验函数，$w \\in H^1(\\Omega)$ 和 $v \\in H^1(\\Omega)$。Sobolev 空间 $H^1(\\Omega)$ 包含平方可积且其一阶导数也平方可积的函数，这是二阶偏微分方程弱形式的自然空间。\n\n对于质量平衡方程，我们乘以检验函数 $w$ 并在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\frac{\\partial c}{\\partial t} w \\, \\mathrm{d}x = \\int_{\\Omega} \\nabla \\cdot (\\mathcal{M} \\nabla \\mu) w \\, \\mathrm{d}x\n$$\n我们对右侧应用分部积分（格林第一恒等式）：\n$$\n\\int_{\\Omega} \\nabla \\cdot (\\mathcal{M} \\nabla \\mu) w \\, \\mathrm{d}x = \\left[ (\\mathcal{M} \\nabla \\mu) w \\right]_{\\partial\\Omega} - \\int_{\\Omega} (\\mathcal{M} \\nabla \\mu) \\cdot \\nabla w \\, \\mathrm{d}x\n$$\n由于 $\\mu$ 的齐次 Neumann 边界条件（即在 $x=0$ 和 $x=L$ 处 $\\nabla \\mu = 0$），边界项 $\\left[ (\\mathcal{M} \\nabla \\mu) w \\right]_{\\partial\\Omega}$ 为零。这得到第一个弱形式方程：\n$$\n\\int_{\\Omega} \\frac{\\partial c}{\\partial t} w \\, \\mathrm{d}x + \\int_{\\Omega} \\mathcal{M} \\nabla \\mu \\cdot \\nabla w \\, \\mathrm{d}x = 0\n$$\n\n对于化学势方程，我们首先将其重新整理为 $\\mu - f'(c) + \\kappa \\nabla^2 c = 0$。然后我们乘以检验函数 $v$ 并在 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x - \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x + \\int_{\\Omega} \\kappa (\\nabla^2 c) v \\, \\mathrm{d}x = 0\n$$\n对包含 $c$ 的二阶导数的项应用分部积分：\n$$\n\\int_{\\Omega} \\kappa (\\nabla^2 c) v \\, \\mathrm{d}x = \\left[ \\kappa (\\nabla c) v \\right]_{\\partial\\Omega} - \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x\n$$\n由于 $c$ 的齐次 Neumann 边界条件，边界项为零。这得到第二个弱形式方程：\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x - \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x - \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x = 0\n$$\n\n完整的弱形式为：求 $c(\\cdot, t) \\in H^1(\\Omega)$ 和 $\\mu(\\cdot, t) \\in H^1(\\Omega)$，使得对于所有检验函数 $w, v \\in H^1(\\Omega)$：\n$$\n\\int_{\\Omega} \\frac{\\partial c}{\\partial t} w \\, \\mathrm{d}x + \\int_{\\Omega} \\mathcal{M} \\nabla \\mu \\cdot \\nabla w \\, \\mathrm{d}x = 0\n$$\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x + \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x = \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x\n$$\n我们将化学势方程重新整理为：\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x + \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x = \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x\n$$\n注意，我们已将 $\\nabla c \\cdot \\nabla v$ 积分项移回左侧，并将其符号从负变为正。\n\n**2. 混合格式的原理**\n\n将 $\\mu$ 代入质量平衡方程得到的原始 Cahn–Hilliard 方程为 $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (\\mathcal{M} \\nabla (f'(c) - \\kappa \\nabla^2 c))$，这是一个关于 $c$ 的四阶偏微分方程。四阶偏微分方程的标准 Galerkin 有限元格式要求试探函数和检验函数都属于 Sobolev 空间 $H^2(\\Omega)$。这对基函数提出了 $C^1$ 连续性要求，意味着函数本身及其一阶导数在单元边界上都必须是连续的。标准的 Lagrange 基函数，如此处使用的分段线性函数，仅具有 $C^0$ 连续性（函数是连续的，但其导数不连续），属于 $H^1(\\Omega)$ 而非 $H^2(\\Omega)$。构造 $C^1$ 连续的单元要复杂得多。\n\n通过引入化学势 $\\mu$ 作为辅助变量，我们将单个四阶偏微分方程分解为一个二阶偏微分方程组。如弱形式推导所示，此过程将任何积分中的最高导数阶数降为一。因此，两个场（$c$ 和 $\\mu$）的试探函数和检验函数都只需要在 $H^1(\\Omega)$ 中即可。这使得我们可以使用简单的、标准的 $C^0$ 有限元基函数，从而大大简化了实现。\n\n**3. 离散化与线性系统**\n\n我们将域 $\\Omega=[0,L]$ 离散为 $N$ 个均匀单元，并使用 $C^0$ 线性 Lagrange 基函数 $\\phi_j(x)$ 来近似场 $c$ 和 $\\mu$：\n$$\nc(x,t) \\approx c_h(x,t) = \\sum_{j=1}^{N_{nodes}} c_j(t) \\phi_j(x) \\quad \\text{和} \\quad \\mu(x,t) \\approx \\mu_h(x,t) = \\sum_{j=1}^{N_{nodes}} \\mu_j(t) \\phi_j(x)\n$$\n其中 $c_j(t)$ 和 $\\mu_j(t)$ 是随时间变化的节点值。Galerkin 方法使用基函数 $\\phi_i(x)$ 作为检验函数，即 $w = \\phi_i$ 和 $v = \\phi_i$。\n\n将这些近似代入弱形式，得到一个常微分方程 (ODE) 组。积分项变为涉及一致质量矩阵 $M_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, \\mathrm{d}x$ 和刚度矩阵 $K_{ij} = \\int_\\Omega \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}x$ 的矩阵向量乘积。非线性项 $\\int_\\Omega f'(c_h) \\phi_i \\, \\mathrm{d}x$ 近似为 $(M \\mathbf{f}'(\\mathbf{c}))_i$，其中 $\\mathbf{f}'(\\mathbf{c})$ 是节点处 $f'(c_j)$ 的向量。半离散系统为：\n$$\nM \\frac{d\\mathbf{c}}{dt} + \\mathcal{M} K \\boldsymbol{\\mu} = \\mathbf{0}\n$$\n$$\nM \\boldsymbol{\\mu} + \\kappa K \\mathbf{c} = M \\mathbf{f}'(\\mathbf{c})\n$$\n\n我们使用后向欧拉方案进行时间离散化，其中变量在新的时间层 $n+1$ 处进行评估，但非线性项除外，该项被显式处理（在上一时间层 $n$ 处评估）以使系统线性化。时间导数近似为 $\\frac{d\\mathbf{c}}{dt} \\approx \\frac{\\mathbf{c}^{n+1} - \\mathbf{c}^n}{\\Delta t}$。待求解的未知向量 $\\mathbf{c}^{n+1}$ 和 $\\boldsymbol{\\mu}^{n+1}$ 的全离散系统为：\n$$\n\\frac{1}{\\Delta t} M (\\mathbf{c}^{n+1} - \\mathbf{c}^n) + \\mathcal{M} K \\boldsymbol{\\mu}^{n+1} = \\mathbf{0}\n$$\n$$\nM \\boldsymbol{\\mu}^{n+1} + \\kappa K \\mathbf{c}^{n+1} = M \\mathbf{f}'(\\mathbf{c}^n)\n$$\n\n将其重新整理为 $\\mathbf{A} \\mathbf{x} = \\mathbf{b}$ 形式的单个分块线性系统：\n$$\n\\begin{bmatrix}\n\\frac{1}{\\Delta t} M  \\mathcal{M} K \\\\\n\\kappa K  M\n\\end{bmatrix}\n\\begin{Bmatrix}\n\\mathbf{c}^{n+1} \\\\\n\\boldsymbol{\\mu}^{n+1}\n\\end{Bmatrix}\n=\n\\begin{Bmatrix}\n\\frac{1}{\\Delta t} M \\mathbf{c}^n \\\\\nM \\mathbf{f}'(\\mathbf{c}^n)\n\\end{Bmatrix}\n$$\n在每个时间步求解此系统，以将解从 $(\\mathbf{c}^n, \\boldsymbol{\\mu}^n)$推进到 $(\\mathbf{c}^{n+1}, \\boldsymbol{\\mu}^{n+1})$。程序将组装并求解此系统以完成单步计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as sp_solve\n\ndef perform_single_step(L, N, dt, kappa, M_val):\n    \"\"\"\n    Performs a single backward Euler step for the mixed Cahn-Hilliard system.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of elements.\n        dt (float): Time step size.\n        kappa (float): Gradient penalty coefficient.\n        M_val (float): Mobility.\n\n    Returns:\n        tuple: A tuple containing the three scalar metrics:\n               (mass_change, mu_residual_norm, mass_residual_norm).\n    \"\"\"\n    N_nodes = N + 1\n    h = L / float(N)\n\n    # 1. Assemble 1D FEM matrices (Mass M and Stiffness K)\n    M = np.zeros((N_nodes, N_nodes))\n    K = np.zeros((N_nodes, N_nodes))\n\n    # Element matrices for linear Lagrange basis functions\n    m_e = (h / 6.0) * np.array([[2.0, 1.0], [1.0, 2.0]])\n    k_e = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    for i in range(N):\n        # Global node indices for element i\n        n1, n2 = i, i + 1\n        nodes = np.array([n1, n2])\n        \n        # Assemble element matrices into global matrices\n        for local_i in range(2):\n            for local_j in range(2):\n                global_i, global_j = nodes[local_i], nodes[local_j]\n                M[global_i, global_j] += m_e[local_i, local_j]\n                K[global_i, global_j] += k_e[local_i, local_j]\n\n    # 2. Set initial condition\n    x_nodes = np.linspace(0.0, L, N_nodes)\n    c_n = 0.2 * np.cos(2 * np.pi * x_nodes / L) + 0.1 * np.cos(np.pi * x_nodes / L)\n\n    # 3. Form the block linear system Ax = b\n    # System size\n    sys_size = 2 * N_nodes\n    A = np.zeros((sys_size, sys_size))\n    b = np.zeros(sys_size)\n\n    # Block matrix A\n    A[:N_nodes, :N_nodes] = (1.0 / dt) * M\n    A[:N_nodes, N_nodes:] = M_val * K\n    A[N_nodes:, :N_nodes] = kappa * K\n    A[N_nodes:, N_nodes:] = M\n\n    # Block vector b\n    f_prime_c_n = c_n**3 - c_n\n    b[:N_nodes] = (1.0 / dt) * (M @ c_n)\n    b[N_nodes:] = M @ f_prime_c_n\n\n    # 4. Solve the linear system\n    solution_vec = sp_solve(A, b)\n    c_np1 = solution_vec[:N_nodes]\n    mu_np1 = solution_vec[N_nodes:]\n\n    # 5. Evaluate the metrics\n    # Metric 1: Absolute mass change\n    ones_vec = np.ones(N_nodes)\n    mass_n = ones_vec @ M @ c_n\n    mass_np1 = ones_vec @ M @ c_np1\n    mass_change = np.abs(mass_np1 - mass_n)\n\n    # Metric 2: Euclidean norm of the chemical potential equation residual\n    res_mu = M @ mu_np1 + kappa * K @ c_np1 - M @ f_prime_c_n\n    mu_residual_norm = np.linalg.norm(res_mu)\n\n    # Metric 3: Euclidean norm of the mass balance residual\n    res_mass = (1.0 / dt) * M @ (c_np1 - c_n) + M_val * K @ mu_np1\n    mass_residual_norm = np.linalg.norm(res_mass)\n\n    return mass_change, mu_residual_norm, mass_residual_norm\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, N, dt, kappa, M_val)\n    test_cases = [\n        (1.0, 16, 1e-4, 1e-2, 1.0),  # Case A\n        (1.0, 8, 1e-3, 1e-2, 1.0),   # Case B\n        (1.0, 8, 1e-3, 1e-2, 0.0),   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, dt, kappa, M_val = case\n        metrics = perform_single_step(L, N, dt, kappa, M_val)\n        results.extend(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3502772"}, {"introduction": "现实世界中的许多问题涉及多种物理场的相互作用，这导致了复杂的耦合非线性方程组。本节的最后一个练习 [@problem_id:3502753] 将带你进入这一前沿领域，处理一个化学-力学耦合问题。你将学习如何通过对弱形式残差进行微分来推导“一致切线矩阵”（即雅可比矩阵），这是使用牛顿法等方法高效求解非线性系统的关键一步。", "problem": "考虑一个无量纲长度为 $L$ 的一维、小应变、线性弹性杆，其中含有一种扩散物质，其无量纲浓度场为 $c(x)$，通过线性本征应变与位移场 $u(x)$ 准静态耦合。在本问题中，所有量均为无量纲；请勿为答案附加任何物理单位。该杆使用下文定义的有限元法 (FEM) 进行离散化。\n\n初始基础和假设：\n- 线性动量守恒，无惯性项，无外部牵引力或体力，以及带有本征应变的线性弹性本构律：柯西应力为 $\\sigma = E\\left(\\varepsilon - \\alpha c\\right)$，其中 $\\varepsilon = \\frac{du}{dx}$，$E > 0$ 是杨氏模量，$\\alpha$ 是一个无量纲耦合系数（Vegard 型本征应变）。\n- 物质守恒，采用隐式欧拉时间积分，从一个已知的前一时刻浓度 $c^{n}$ 开始，时间步长为 $\\Delta t > 0$，迁移率 $M \\ge 0$ 为常数，Fick 型扩散，以及一个与应变成正比的线性产生项：$\\dot{c} + \\frac{d}{dx} J = s$，其中 $J = - M \\frac{dc}{dx}$ 且 $s = \\chi \\frac{du}{dx}$，$\\chi$ 是一个无量纲耦合系数。这种选择避免了高阶空间导数，同时引入了双向化学-力学耦合。\n- 通过将控制方程乘以容许的检验函数并在域上积分，并在适当情况下使用标准分部积分法，来获得弱形式。\n\n令 $\\mathcal{V}_u$ 和 $\\mathcal{V}_c$ 分别表示 $u$ 和 $c$ 的试探空间和检验空间，令 $\\delta u \\in \\mathcal{V}_u$ 和 $\\delta c \\in \\mathcal{V}_c$ 为检验函数。弱形式残差定义如下：\n- 力学残差（虚功原理）：求 $u \\in \\mathcal{V}_u$，使得对于所有 $\\delta u \\in \\mathcal{V}_u$，\n$$\n\\mathcal{R}_u(\\delta u; u, c) = \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{du}{dx} - \\alpha c \\right) \\, dx = 0.\n$$\n- 扩散残差（隐式时间积分和带源项的 Fick 定律）：求 $c \\in \\mathcal{V}_c$，使得对于所有 $\\delta c \\in \\mathcal{V}_c$，\n$$\n\\mathcal{R}_c(\\delta c; u, c) = \\int_0^L \\delta c \\, \\frac{c - c^{n}}{\\Delta t} \\, dx + \\int_0^L \\left( \\frac{d \\delta c}{dx} \\right) M \\left( \\frac{dc}{dx} \\right) dx - \\int_0^L \\delta c \\, \\chi \\left( \\frac{du}{dx} \\right) dx = 0.\n$$\n\n将一致切线块定义为残差关于主场在检验函数方向上的 Fréchet 导数：\n- $K_{uu}[\\delta u, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$，\n- $K_{uc}[\\delta u, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$，\n- $K_{cu}[\\delta c, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$，\n- $K_{cc}[\\delta c, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$。\n\n离散化细节：\n- 在 $[0, L]$ 上使用包含 $N_e$ 个两节点线性单元的均匀网格，得到 $N = N_e + 1$ 个节点。设单元长度为 $h = L / N_e$。\n- 在每个单元上使用标准的 $C^0$ 两节点线性形函数，$N_1(\\xi) = \\frac{1}{2}(1-\\xi)$，$N_2(\\xi) = \\frac{1}{2}(1+\\xi)$，其中 $\\xi \\in [-1, 1]$，通过仿射映射 $dx = \\frac{h}{2} d\\xi$ 映射到物理坐标。\n- 对于力学场 $u$ 和浓度场 $c$，使用相同的形函数。设离散试探函数为 $u^h(x) = \\sum_{a=1}^{N} N_a(x) \\, u_a$ 和 $c^h(x) = \\sum_{a=1}^{N} N_a(x) \\, c_a$，检验函数为 $\\delta u^h(x) = \\sum_{a=1}^{N} N_a(x) \\, \\delta u_a$ 和 $\\delta c^h(x) = \\sum_{a=1}^{N} N_a(x) \\, \\delta c_a$。\n- 使用两节点线性单元的精确单元级矩阵（等效地，使用 $2$ 点高斯积分，这对于此处出现的多项式是精确的）来近似所有积分。\n\n任务：\n1. 从弱形式残差出发，推导单个长度为 $h$ 的单元的一致切线块的离散单元矩阵形式：\n   - 证明力学切线块 $K^{e}_{uu}$、耦合块 $K^{e}_{uc}$、耦合块 $K^{e}_{cu}$ 和扩散切线块 $K^{e}_{cc}$ 可以表示为依赖于 $E$、$\\alpha$、$M$、$\\chi$、$h$ 和 $\\Delta t$ 的单元矩阵。不假设任何边界条件；保留完整的单元矩阵。\n2. 通过标准有限元组装方法，由单元矩阵组装整个网格的大小为 $N \\times N$ 的全局切线块 $K_{uu}$、$K_{uc}$、$K_{cu}$、$K_{cc}$。形成具有以下块结构的、大小为 $2N \\times 2N$ 的完整雅可比矩阵 $J$：\n$$\nJ = \\begin{bmatrix}\nK_{uu}  K_{uc} \\\\\nK_{cu}  K_{cc}\n\\end{bmatrix}.\n$$\n3. 对于下面列出的每个测试用例，计算四个全局块和完整雅可比矩阵的 Frobenius 范数，\n$$\n\\|K_{uu}\\|_F, \\quad \\|K_{uc}\\|_F, \\quad \\|K_{cu}\\|_F, \\quad \\|K_{cc}\\|_F, \\quad \\|J\\|_F,\n$$\n并将每个范数报告为四舍五入到恰好 $8$ 位小数的浮点数。\n4. 所有量均为无量纲；任何地方都不要提供物理单位。\n\n测试套件：\n- 用例 A（通用耦合）：$L = 1$，$N_e = 2$，$E = 10$，$\\alpha = 0.3$，$M = 2$，$\\chi = 0.5$，$\\Delta t = 0.1$。\n- 用例 B（无耦合）：$L = 1$，$N_e = 2$，$E = 10$，$\\alpha = 0$，$M = 2$，$\\chi = 0$，$\\Delta t = 0.1$。\n- 用例 C（刚性瞬态扩散）：$L = 1$，$N_e = 2$，$E = 10$，$\\alpha = 0.3$，$M = 2$，$\\chi = 0.5$，$\\Delta t = 10^{-6}$。\n- 用例 D（弱扩散，强力学）：$L = 1.5$，$N_e = 2$，$E = 50$，$\\alpha = 0.1$，$M = 10^{-6}$，$\\chi = 0.8$，$\\Delta t = 0.2$。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个逗号分隔的列表之列表形式的结果，每个内部列表按 A、B、C、D 的顺序对应一个测试用例，并按任务 $3$ 中指定的顺序包含五个四舍五入后的 Frobenius 范数。例如，格式必须是\n$[\\,[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5],[d_1,d_2,d_3,d_4,d_5]\\,]$\n无任何附加文本。每个 $a_i$、$b_i$、$c_i$、$d_i$ 必须四舍五入到恰好 $8$ 位小数。", "solution": "该问题要求推导和计算一个耦合的一维化学-力学系统的一致切线雅可比矩阵，该系统使用有限元法 (FEM) 进行离散化。求解过程分为两个主要阶段：首先，从给定的弱形式推导单元级切线矩阵；其次，实现一个程序，将这些单元矩阵组装成全局雅可比矩阵，并为一组给定的测试用例计算指定的 Frobenius 范数。\n\n### 任务 1：单元切线矩阵的推导\n\n让我们考虑一个长度为 $h$ 的两节点线性有限元。该单元内的位移场 $u(x)$ 和浓度场 $c(x)$ 使用线性形函数 $N_1(x)$ 和 $N_2(x)$ 进行近似。场及其导数可以用节点值 $(u_1, u_2)$ 和 $(c_1, c_2)$ 表示。\nFEM 近似为 $u^h(x) = \\mathbf{N}(x) \\mathbf{u}^e$ 和 $c^h(x) = \\mathbf{N}(x) \\mathbf{c}^e$，其中 $\\mathbf{N} = [N_1, N_2]$ 是形函数向量，$\\mathbf{u}^e = [u_1, u_2]^T$ 和 $\\mathbf{c}^e = [c_1, c_2]^T$ 是节点自由度向量。形函数的空间导数被收集在矩阵 $\\mathbf{B} = \\frac{d\\mathbf{N}}{dx}$ 中。对于一维线性单元，$\\mathbf{B} = \\frac{1}{h}[-1, 1]$。\n导数的离散近似为 $\\frac{du^h}{dx} = \\mathbf{B} \\mathbf{u}^e$ 和 $\\frac{dc^h}{dx} = \\mathbf{B} \\mathbf{c}^e$。\n\n一致切线块是通过取弱形式残差的 Fréchet 导数来推导的，如问题陈述中所定义。\n\n**1. 力学切线块, $K_{uu}$**\n定义为 $K_{uu}[\\delta u, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$。\n$$\nK_{uu}[\\delta u, \\hat{u}] = \\frac{d}{d\\epsilon} \\left[ \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{d(u + \\epsilon \\hat{u})}{dx} - \\alpha c \\right) \\, dx \\right]_{\\epsilon=0} = \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{d\\hat{u}}{dx} \\right) \\, dx\n$$\n对单个单元进行离散化，并代入 FEM 近似 $\\frac{d\\delta u^h}{dx} = \\mathbf{B} \\delta\\mathbf{u}^e$ 和 $\\frac{d\\hat{u}^h}{dx} = \\mathbf{B} \\hat{\\mathbf{u}}^e$，我们得到单元矩阵 $K_{uu}^e$：\n$$\n(\\delta \\mathbf{u}^e)^T K_{uu}^e \\hat{\\mathbf{u}}^e = \\int_{e} (\\delta \\mathbf{u}^e)^T \\mathbf{B}^T E \\mathbf{B} \\hat{\\mathbf{u}}^e \\, dx = (\\delta \\mathbf{u}^e)^T \\left( E \\int_e \\mathbf{B}^T \\mathbf{B} \\, dx \\right) \\hat{\\mathbf{u}}^e\n$$\n由于 $\\mathbf{B}$ 在单元上是常数，该积分的计算结果为 $\\mathbf{B}^T \\mathbf{B} h$。\n$$\nK_{uu}^e = E h \\mathbf{B}^T \\mathbf{B} = E h \\left( \\frac{1}{h} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\right) \\left( \\frac{1}{h} [-1, 1] \\right) = \\frac{E}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n\n**2. 力学-浓度耦合块, $K_{uc}$**\n定义为 $K_{uc}[\\delta u, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$。\n$$\nK_{uc}[\\delta u, \\hat{c}] = \\frac{d}{d\\epsilon} \\left[ \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{du}{dx} - \\alpha (c + \\epsilon \\hat{c}) \\right) \\, dx \\right]_{\\epsilon=0} = \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E (-\\alpha \\hat{c}) \\, dx\n$$\n对一个单元进行离散化，其中 $\\frac{d\\delta u^h}{dx} = \\mathbf{B} \\delta\\mathbf{u}^e$ 且 $\\hat{c}^h = \\mathbf{N} \\hat{\\mathbf{c}}^e$：\n$$\n(\\delta \\mathbf{u}^e)^T K_{uc}^e \\hat{\\mathbf{c}}^e = \\int_{e} (\\delta \\mathbf{u}^e)^T \\mathbf{B}^T (-E \\alpha) \\mathbf{N} \\hat{\\mathbf{c}}^e \\, dx = (\\delta \\mathbf{u}^e)^T \\left( -E\\alpha \\int_e \\mathbf{B}^T \\mathbf{N} \\, dx \\right) \\hat{\\mathbf{c}}^e\n$$\n该积分在参考坐标系 $\\xi \\in [-1, 1]$ 中计算，其中 $dx = h/2 \\, d\\xi$：\n$$\n\\int_e \\mathbf{B}^T \\mathbf{N} \\, dx = \\frac{1}{h} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\int_{-1}^{1} \\frac{1}{2}[1-\\xi, 1+\\xi] \\, \\frac{h}{2} d\\xi = \\frac{1}{4} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\int_{-1}^{1} [1-\\xi, 1+\\xi] \\, d\\xi = \\frac{1}{4} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} [2, 2] = \\frac{1}{2} \\begin{bmatrix} -1  -1 \\\\ 1  1 \\end{bmatrix}\n$$\n因此，单元矩阵为：\n$$\nK_{uc}^e = -E\\alpha \\left( \\frac{1}{2} \\begin{bmatrix} -1  -1 \\\\ 1  1 \\end{bmatrix} \\right) = \\frac{E\\alpha}{2} \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}\n$$\n\n**3. 浓度-力学耦合块, $K_{cu}$**\n定义为 $K_{cu}[\\delta c, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$。\n$$\nK_{cu}[\\delta c, \\hat{u}] = \\frac{d}{d\\epsilon} \\left[ \\dots - \\int_0^L \\delta c \\, \\chi \\left( \\frac{d(u + \\epsilon \\hat{u})}{dx} \\right) dx \\right]_{\\epsilon=0} = - \\int_0^L \\delta c \\, \\chi \\left( \\frac{d\\hat{u}}{dx} \\right) \\, dx\n$$\n对一个单元进行离散化，其中 $\\delta c^h = \\mathbf{N} \\delta\\mathbf{c}^e$ 且 $\\frac{d\\hat{u}^h}{dx} = \\mathbf{B} \\hat{\\mathbf{u}}^e$：\n$$\n(\\delta \\mathbf{c}^e)^T K_{cu}^e \\hat{\\mathbf{u}}^e = \\int_e (\\delta \\mathbf{c}^e)^T \\mathbf{N}^T (-\\chi) \\mathbf{B} \\hat{\\mathbf{u}}^e \\, dx = (\\delta \\mathbf{c}^e)^T \\left( -\\chi \\int_e \\mathbf{N}^T \\mathbf{B} \\, dx \\right) \\hat{\\mathbf{u}}^e\n$$\n积分部分是 $K_{uc}$ 推导中积分的转置：$\\left( \\frac{1}{2} \\begin{bmatrix} -1  -1 \\\\ 1  1 \\end{bmatrix} \\right)^T = \\frac{1}{2} \\begin{bmatrix} -1  1 \\\\ -1  1 \\end{bmatrix}$。\n因此，单元矩阵为：\n$$\nK_{cu}^e = -\\chi \\left( \\frac{1}{2} \\begin{bmatrix} -1  1 \\\\ -1  1 \\end{bmatrix} \\right) = \\frac{\\chi}{2} \\begin{bmatrix} 1  -1 \\\\ 1  -1 \\end{bmatrix}\n$$\n\n**4. 扩散切线块, $K_{cc}$**\n定义为 $K_{cc}[\\delta c, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$。\n$$\nK_{cc}[\\delta c, \\hat{c}] = \\frac{d}{d\\epsilon} \\left[ \\int_0^L \\delta c \\frac{(c+\\epsilon\\hat{c})-c^n}{\\Delta t} dx + \\int_0^L \\frac{d\\delta c}{dx} M \\frac{d(c+\\epsilon\\hat{c})}{dx} dx - \\dots \\right]_{\\epsilon=0}\n$$\n$$\nK_{cc}[\\delta c, \\hat{c}] = \\int_0^L \\frac{1}{\\Delta t} \\delta c \\hat{c} \\, dx + \\int_0^L M \\frac{d\\delta c}{dx} \\frac{d\\hat{c}}{dx} \\, dx\n$$\n单元矩阵 $K_{cc}^e$ 是两部分贡献的总和：来自时间导数项的类质量矩阵和来自扩散项的类刚度矩阵。\n$$\nK_{cc}^e = \\frac{1}{\\Delta t} \\int_e \\mathbf{N}^T \\mathbf{N} \\, dx + M \\int_e \\mathbf{B}^T \\mathbf{B} \\, dx\n$$\n第一个积分是线性单元的标准一致质量矩阵：\n$$\n\\int_e \\mathbf{N}^T \\mathbf{N} \\, dx = \\int_{-1}^1 \\begin{bmatrix} N_1^2  N_1 N_2 \\\\ N_1 N_2  N_2^2 \\end{bmatrix} \\frac{h}{2} d\\xi = \\frac{h}{2} \\begin{bmatrix} 2/3  1/3 \\\\ 1/3  2/3 \\end{bmatrix} = \\frac{h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n第二个积分是扩散刚度矩阵，其形式与 $K_{uu}^e$ 相同：\n$$\nM \\int_e \\mathbf{B}^T \\mathbf{B} \\, dx = \\frac{M}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n结合这两个贡献，我们得到：\n$$\nK_{cc}^e = \\frac{M}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} + \\frac{h}{6 \\Delta t} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n\n### 任务 2 和 3：组装与计算\n\n推导出的 $2 \\times 2$ 单元矩阵通过标准直接刚度组装程序被组装成全局 $N \\times N$ 矩阵（$N=N_e+1$）。对于一个包含 $N_e$ 个单元的网格，单元 $i$（连接节点 $i$ 和 $i+1$）的单元矩阵被添加到全局矩阵中对应于这些节点的子块中。然后，由四个全局块 $K_{uu}$、$K_{uc}$、$K_{cu}$、$K_{cc}$ 构造完整的 $2N \\times 2N$ 雅可比矩阵 $J$。最后，为四个块和完整的雅可比矩阵计算 Frobenius 范数 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。对每个测试用例实施此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled chemo-mechanical problem by deriving element matrices,\n    assembling the global Jacobian, and computing Frobenius norms for specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general coupled)\n        {'L': 1.0, 'Ne': 2, 'E': 10.0, 'alpha': 0.3, 'M': 2.0, 'chi': 0.5, 'dt': 0.1},\n        # Case B (no coupling)\n        {'L': 1.0, 'Ne': 2, 'E': 10.0, 'alpha': 0.0, 'M': 2.0, 'chi': 0.0, 'dt': 0.1},\n        # Case C (stiff transient diffusion)\n        {'L': 1.0, 'Ne': 2, 'E': 10.0, 'alpha': 0.3, 'M': 2.0, 'chi': 0.5, 'dt': 1e-6},\n        # Case D (weak diffusion, stronger mechanics)\n        {'L': 1.5, 'Ne': 2, 'E': 50.0, 'alpha': 0.1, 'M': 1e-6, 'chi': 0.8, 'dt': 0.2},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case['L']\n        Ne = case['Ne']\n        E = case['E']\n        alpha = case['alpha']\n        M = case['M']\n        chi = case['chi']\n        dt = case['dt']\n\n        N = Ne + 1  # Number of nodes\n        h = L / Ne  # Element length\n\n        # 1. Compute element-level tangent matrices (2x2)\n        \n        # K_uu^e = (E/h) * [[1, -1], [-1, 1]]\n        K_uu_e = (E / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # K_uc^e = (E*alpha/2) * [[1, 1], [-1, -1]]\n        K_uc_e = (E * alpha / 2.0) * np.array([[1.0, 1.0], [-1.0, -1.0]])\n\n        # K_cu^e = (chi/2) * [[1, -1], [1, -1]]\n        K_cu_e = (chi / 2.0) * np.array([[1.0, -1.0], [1.0, -1.0]])\n\n        # K_cc^e = (M/h) * [[1, -1], [-1, 1]] + (h / (6*dt)) * [[2, 1], [1, 2]]\n        K_diff_e = (M / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K_mass_e = (h / (6.0 * dt)) * np.array([[2.0, 1.0], [1.0, 2.0]])\n        K_cc_e = K_diff_e + K_mass_e\n\n        # 2. Assemble global tangent blocks (NxN)\n        K_uu = np.zeros((N, N))\n        K_uc = np.zeros((N, N))\n        K_cu = np.zeros((N, N))\n        K_cc = np.zeros((N, N))\n\n        for e in range(Ne):\n            # Get the degrees of freedom for the current element\n            dof_map = [e, e + 1]\n            # Use np.ix_ to index the submatrices for assembly\n            ix = np.ix_(dof_map, dof_map)\n            \n            K_uu[ix] += K_uu_e\n            K_uc[ix] += K_uc_e\n            K_cu[ix] += K_cu_e\n            K_cc[ix] += K_cc_e\n\n        # Form the full Jacobian (2N x 2N)\n        J = np.zeros((2 * N, 2 * N))\n        J[0:N, 0:N] = K_uu\n        J[0:N, N:2*N] = K_uc\n        J[N:2*N, 0:N] = K_cu\n        J[N:2*N, N:2*N] = K_cc\n\n        # 3. Compute Frobenius norms\n        norm_K_uu = np.linalg.norm(K_uu, 'fro')\n        norm_K_uc = np.linalg.norm(K_uc, 'fro')\n        norm_K_cu = np.linalg.norm(K_cu, 'fro')\n        norm_K_cc = np.linalg.norm(K_cc, 'fro')\n        norm_J = np.linalg.norm(J, 'fro')\n\n        case_results = [norm_K_uu, norm_K_uc, norm_K_cu, norm_K_cc, norm_J]\n        all_results.append(case_results)\n\n    # Final output formatting\n    # Format each number to 8 decimal places\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_nums = [f\"{num:.8f}\" for num in case_res]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3502753"}]}