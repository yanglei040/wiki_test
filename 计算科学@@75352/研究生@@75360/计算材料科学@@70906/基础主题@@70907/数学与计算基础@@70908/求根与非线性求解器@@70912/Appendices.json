{"hands_on_practices": [{"introduction": "本练习从材料热力学中的一个基本问题入手：计算晶体中点缺陷的平衡浓度。我们将物理平衡条件转化为一个单变量非线性方程的求根问题。此实践旨在通过构建一个在极端温度条件下依然稳健的求解器，来加强对物理模型与数值方法之间联系的理解，并探索如何利用物理洞察力（如渐近分析）来提升算法的效率。[@problem_id:3486023]", "problem": "您正在使用一个适用于计算材料科学的最小热力学模型，对晶体固体中理想晶格内的点空位平衡分数进行建模。设在绝对温度 $T$ 下，空位点分数为 $\\phi \\in (0,1)$，空位形成能为 $E_f$。在理想、无相互作用的单组分晶格气体模型中，当空位产生的净驱动力消失时，系统达到平衡。由此产生的平衡可以表述为求解非线性函数的一个根：\n$$\nR(\\phi; E_f, T) \\equiv \\exp\\!\\left(-\\dfrac{E_f}{k_B T}\\right) - \\dfrac{\\phi}{1-\\phi} = 0,\n$$\n其中 $k_B$ 是玻尔兹曼常数。假设 $E_f  0$，$T  0$，并且该模型应用于理想假设合理的范围内。\n\n您的任务是为 $\\phi$ 实现一个鲁棒的求根求解器，该求解器在广泛的温度范围内（包括 $\\exp(-E_f/(k_B T))$ 变得非常小或非常接近于1的极端情况）都能够可靠工作。您的设计必须基于以下原则：\n- 从理想晶格气体中平衡的基本定义以及玻尔兹曼因子 $\\exp(-E_f/(k_B T))$ 出发。\n- 构建一个尊重物理定义域 $\\phi \\in (0,1)$ 的全局收敛数值方法。您必须将基于导数的更新（例如，应用于 $R(\\phi)$ 的牛顿法）与一个保障步相结合，该保障步能保证下一次迭代停留在允许区间内，并在导数步不适用时确保收敛。\n- 在极低 $T$（此时 $\\exp(-E_f/(k_B T))$ 极小）和相对于 $E_f$ 极高 $T$（此时 $\\exp(-E_f/(k_B T))$ 接近于1）的极限情况下，推导平衡状态的渐近标度。利用这些渐近标度构建有原则的初始猜测值 $\\phi_0(E_f,T)$，以便在极端情况下加速收敛，同时不违反定义域约束。\n\n物理和数值单位：\n- $E_f$ 使用电子伏特（eV）。\n- $T$ 使用开尔文（K）。\n- 使用 $k_B = 8.617333262145\\times 10^{-5}\\ \\mathrm{eV/K}$。\n- 空位分数 $\\phi$ 是无量纲的。以无量纲浮点数报告数值结果。\n\n算法要求：\n- 实现一个求解器，该求解器使用 $R(\\phi)$ 及其解析导数的基于导数的迭代，并带有一个保障措施，即如果导数步将离开区间 $(0,1)$ 或未能减小残差，则回退到区间限定步（例如，在所维护的区间内进行二分）。确保该方法对于任何允许的输入 $E_f0$，$T0$ 都是全局收敛的。\n- 选择基于残差 $\\lvert R(\\phi)\\rvert$ 和/或步长的停止准则，其严格程度需足以在整个测试套件中为 $\\phi$ 提供至少10位有效数字的精度。\n\n测试套件：\n按此确切顺序，为以下参数集评估您的求解器：\n1. $(E_f, T) = (0.4\\ \\mathrm{eV}, 3000\\ \\mathrm{K})$，\n2. $(E_f, T) = (1.2\\ \\mathrm{eV}, 300\\ \\mathrm{K})$，\n3. $(E_f, T) = (1.2\\ \\mathrm{eV}, 1200\\ \\mathrm{K})$，\n4. $(E_f, T) = (0.01\\ \\mathrm{eV}, 3000\\ \\mathrm{K})$。\n\n答案规范和输出格式：\n- 对于每种情况，通过求解 $R(\\phi; E_f, T)=0$ 来计算平衡空位分数 $\\phi$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"）。每个结果必须是至少有10位有效数字的浮点数。不应打印额外的文本或空白。", "solution": "该问题要求设计并实现一个鲁棒的数值求解器，以寻找晶体固体中的平衡空位分数 $\\phi$。其控制方程是一个源于基本热力学原理的非线性函数。\n\n**1. 问题建模与物理基础**\n\n在恒定温度和压力下，系统的平衡态由其吉布斯自由能 $G$ 的最小值决定。对于一个包含 $N$ 个总晶格格点和 $n_v$ 个空位的晶体，其吉布斯自由能建模为 $G(n_v) = n_v E_f - T S_{conf}(n_v)$，其中 $E_f$ 是空位形成能，$T$ 是绝对温度，$S_{conf}$ 是构型熵。构型熵源于排列空位的多种方式，由 $S_{conf} = k_B \\ln W$ 给出，其中 $W = N! / (n_v! (N-n_v)!)$，$k_B$ 是玻尔兹曼常数。\n\n使用对于晶体中大量原子而言非常精确的斯特林近似（$\\ln z! \\approx z\\ln z - z$），单位格点的熵 $s_{conf} = S_{conf}/N$ 可以用空位分数 $\\phi = n_v/N$ 表示：\n$$ s_{conf}(\\phi) \\approx -k_B \\left[ \\phi \\ln \\phi + (1-\\phi) \\ln(1-\\phi) \\right] $$\n于是，单位格点的吉布斯自由能为 $g(\\phi) = \\phi E_f + k_B T \\left[ \\phi \\ln \\phi + (1-\\phi) \\ln(1-\\phi) \\right]$。平衡对应于 $g(\\phi)$ 的最小值，通过将其对 $\\phi$ 的导数置零求得：\n$$ \\frac{\\partial g}{\\partial \\phi} = E_f + k_B T \\left( \\ln\\phi + 1 - \\ln(1-\\phi) - 1 \\right) = E_f + k_B T \\ln\\left(\\frac{\\phi}{1-\\phi}\\right) = 0 $$\n整理此条件即可得到待求解的方程：\n$$ \\frac{\\phi}{1-\\phi} = \\exp\\left(-\\frac{E_f}{k_B T}\\right) $$\n这是一个关于函数 $R(\\phi; E_f, T) = 0$ 的求根问题，其中残差 $R(\\phi)$ 定义为：\n$$ R(\\phi) \\equiv \\exp\\left(-\\frac{E_f}{k_B T}\\right) - \\frac{\\phi}{1-\\phi} = 0 $$\n解必须位于具有物理意义的定义域 $\\phi \\in (0,1)$ 内。\n\n**2. 解析解**\n\n为了验证，我们注意到该方程可以解析求解。令 $B = \\exp(-E_f/(k_B T))$。方程 $B = \\phi/(1-\\phi)$ 可以重排为 $\\phi = B(1-\\phi)$，得到 $\\phi(1+B) = B$。因此，精确解为：\n$$ \\phi = \\frac{B}{1+B} = \\frac{\\exp(-E_f/(k_B T))}{1+\\exp(-E_f/(k_B T))} $$\n由于 $E_f  0$ 且 $T  0$，玻尔兹曼因子 $B$ 严格处于区间 $(0, 1)$ 内。因此，$\\phi$ 的精确解总是在区间 $(0, 0.5)$ 内。尽管核心任务仍然是实现指定的数值求解器，但这个解析结果可以作为我们数值方法的完美基准。\n\n**3. 数值求解器：带保障的牛顿法**\n\n我们的任务是构建一个既快速又鲁棒的求解器。混合牛顿-二分法是实现此目标的理想选择。它结合了牛顿法在解附近的快速二次收敛性与二分法保证的全局收敛性。\n\n牛顿法通过迭代 $\\phi_{k+1} = \\phi_k - R(\\phi_k)/R'(\\phi_k)$ 来寻找根。我们首先需要 $R(\\phi)$ 的导数：\n$$ R'(\\phi) = \\frac{d}{d\\phi} \\left( B - \\frac{\\phi}{1-\\phi} \\right) = - \\frac{1 \\cdot (1-\\phi) - \\phi \\cdot (-1)}{(1-\\phi)^2} = -\\frac{1}{(1-\\phi)^2} $$\n函数 $R(\\phi)$ 在其定义域上是严格递减（$R'(\\phi)0$）和凹的（$R''(\\phi)=-2(1-\\phi)^{-3}0$）。这种凹性意味着纯牛顿法可能会过冲根部，并可能产生超出物理定义域 $(0,1)$ 的迭代值，因此需要一个保障措施。\n\n我们的保障措施包括维持一个已知根所在的区间 $[\\phi_a, \\phi_b]$，即 $R(\\phi_a) > 0$ 和 $R(\\phi_b)  0$。鉴于解总是在 $(0,0.5)$ 内，初始区间可以设为 $[0, 0.5]$，这可以通过检查端点来验证：$R(0) = B > 0$ 和 $R(0.5) = B-1  0$。\n\n每次迭代的算法如下：\n1.  根据当前迭代值 $\\phi_k$，计算牛顿步，得到候选解 $\\phi_{newton}$。\n2.  如果 $\\phi_{newton}$ 落在了当前区间 $[\\phi_a, \\phi_b]$ 之外，则拒绝该值。算法回退到二分步，下一次迭代值变为中点 $\\phi_{k+1} = (\\phi_a + \\phi_b)/2$。\n3.  如果 $\\phi_{newton}$ 在区间内，则接受其为下一次迭代值，$\\phi_{k+1} = \\phi_{newton}$。\n4.  通过计算 $R(\\phi_{k+1})$ 的值来更新后续迭代的区间，用 $\\phi_{k+1}$ 替换 $\\phi_a$ 或 $\\phi_b$ 中的一个，以保持符号变化的性质。\n\n此策略确保每一步都在一个缩小的、有保证的区间内向根逼近，从而保证了全局收敛。\n\n**4. 用于优化初始猜测的渐近分析**\n\n通过从一个已经接近真实解的初始猜测 $\\phi_0$ 开始，可以大大提高求解器的效率。我们通过对极限温度情况下解的渐近分析来推导此类猜测，该分析由参数 $x = E_f/(k_B T)$ 表征。\n\n*   **低温极限（$T \\to 0$，因此 $x \\to \\infty$）：** 在此情况下，$B = e^{-x}$ 非常小。解析解 $\\phi = B/(1+B)$ 可以用其一阶泰勒级数项很好地近似：\n    $$ \\phi \\approx B = \\exp\\left(-\\frac{E_f}{k_B T}\\right) $$\n*   **高温极限（$T \\to \\infty$，因此 $x \\to 0$）：** 在此情况下，$B = e^{-x}$ 接近于 $1$。使用泰勒展开 $e^{-x} \\approx 1 - x$，解析解变为：\n    $$ \\phi = \\frac{e^{-x}}{1+e^{-x}} \\approx \\frac{1-x}{1 + (1-x)} = \\frac{1-x}{2-x} $$\n    展开 $(1-x/2)^{-1} \\approx 1+x/2$，我们发现 $\\phi \\approx \\frac{1}{2}(1-x)(1+x/2) \\approx \\frac{1}{2}(1-x/2) = \\frac{1}{2} - \\frac{x}{4}$。这给出了近似式：\n    $$ \\phi \\approx \\frac{1}{2} - \\frac{E_f}{4k_B T} $$\n\n我们采用一个基于 $x=E_f/(k_B T)$ 的简单转换判据。如果 $x  1$，我们使用低温猜测。如果 $x \\le 1$，我们使用高温猜测。这在所有物理条件下都提供了一个高度准确的起始点，从而最大限度地减少了所需的迭代次数。\n\n**5. 收敛判据**\n\n为满足至少10位有效数字精度的要求，当残差的绝对值 $|R(\\phi_k)|$ 小于一个严格的容差（设为 $10^{-16}$）时，迭代过程终止。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_vacancy_fraction(Ef, T, tol=1e-16, max_iter=50):\n    \"\"\"\n    Computes the equilibrium vacancy fraction phi using a safeguarded Newton's method.\n\n    Args:\n        Ef (float): Vacancy formation energy in eV.\n        T (float): Absolute temperature in K.\n        tol (float): Convergence tolerance for the residual.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        float: The equilibrium vacancy fraction phi.\n    \"\"\"\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    if T = 0 or Ef = 0:\n        raise ValueError(\"Temperature and formation energy must be positive.\")\n\n    # Calculate the dimensionless energy term x and the Boltzmann factor B\n    x = Ef / (KB_EV_K * T)\n    \n    # Use np.exp with care for potential underflow\n    B = np.exp(-x) if x  np.log(np.finfo(float).max) else 0.0\n\n    # Define the residual function R(phi) and its derivative R'(phi)\n    # R(phi) = B - phi / (1 - phi)\n    def R(phi):\n        if phi == 1.0:\n            return -np.inf\n        # To avoid catastrophic cancellation when B is close to phi/(1-phi)\n        # we can rewrite R(phi)\n        # return (B * (1 - phi) - phi) / (1 - phi)\n        # However, the direct form is fine for this problem.\n        return B - phi / (1.0 - phi)\n\n    def R_prime(phi):\n        if phi == 1.0:\n            return -np.inf\n        return -1.0 / (1.0 - phi)**2\n\n    # Asymptotic analysis for a principled initial guess\n    if x > 1.0:\n        # Low-temperature regime approximation\n        phi_k = B\n    else:\n        # High-temperature regime approximation\n        phi_k = 0.5 - x / 4.0\n\n    # The analytical solution is always in (0, 0.5), so this is a safe bracket\n    phi_a, phi_b = 0.0, 0.5\n\n    # Check if initial guess is within the bracket; if not, use bisection center\n    if not (phi_a  phi_k  phi_b):\n        phi_k = (phi_a + phi_b) / 2.0\n\n    for _ in range(max_iter):\n        res = R(phi_k)\n\n        # Check for convergence\n        if abs(res)  tol:\n            return phi_k\n\n        # Update the bracket using the sign of the residual\n        if res > 0:\n            phi_a = phi_k\n        else:\n            phi_b = phi_k\n\n        # Newton's method step\n        deriv = R_prime(phi_k)\n        \n        # Avoid division by zero, though unlikely for this function\n        if abs(deriv)  np.finfo(float).eps:\n            phi_next = (phi_a + phi_b) / 2.0\n        else:\n            phi_newton = phi_k - res / deriv\n            # Safeguard: if Newton step is out of bounds, use bisection\n            if phi_newton = phi_a or phi_newton >= phi_b:\n                phi_next = (phi_a + phi_b) / 2.0\n            else:\n                phi_next = phi_newton\n        \n        # Update the iterate\n        if abs(phi_k - phi_next)  tol * abs(phi_k) + tol:\n            # Step size is very small, likely converged\n            return phi_next\n            \n        phi_k = phi_next\n\n    raise RuntimeError(f\"Solver failed to converge for Ef={Ef}, T={T}\")\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.4, 3000.0),  # (Ef in eV, T in K)\n        (1.2, 300.0),\n        (1.2, 1200.0),\n        (0.01, 3000.0)\n    ]\n\n    results = []\n    for Ef_case, T_case in test_cases:\n        # Calculate the equilibrium vacancy fraction for the case\n        phi_eq = solve_vacancy_fraction(Ef_case, T_case)\n        # Format result to ensure sufficient precision\n        results.append(f\"{phi_eq:.15g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3486023"}, {"introduction": "在掌握了单变量问题的求解后，我们转向一个更复杂的场景：非线性连续介质力学中的多变量问题。许多材料现象，如相变和微结构演化，都由非凸能量函数 $W(F)$ 的极小化所主导，这会导致多个可能的平衡态。本练习将引导你推导求解所需的多变量微积分工具（梯度 $\\nabla_F W(F)$ 和雅可比矩阵），并实现一个带线搜索的牛顿法，以探索这种复杂的能量形貌并绘制不同解的吸引盆。[@problem_id:3486017]", "problem": "考虑一个二维材料在有限变形下的弹性势能密度，其表达式为 $W(F) = \\mu \\|F\\|_F^2 + \\lambda (\\det F - 1)^2$，其中 $F \\in \\mathbb{R}^{2 \\times 2}$ 是变形梯度，$\\|F\\|_F$ 是 Frobenius 范数，$\\det F$ 是行列式，$\\mu  0$ 和 $\\lambda  0$ 是材料常数。该能量的驻点满足非线性矩阵方程 $\\nabla_F W(F) = 0$，通过将 F 展平成其元素组成的向量，该问题可以被视为 $\\mathbb{R}^4$ 空间中的一个求根问题。您的任务如下：\n\n- 从行列式的导数满足 $\\frac{\\partial \\det(F)}{\\partial F_{ij}} = \\operatorname{Cof}(F)_{ij}$（其中 $\\operatorname{Cof}(F)$ 是代数余子式矩阵）以及带矩阵参数的标量场的梯度可以逐项计算这些基本微积分事实出发，当 $F = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$ 时，推导梯度 $\\nabla_F W(F)$ 的表达式，以及与非线性系统 $\\nabla_F W(F) = 0$ 相关的雅可比矩阵。不要使用或假设任何预先推导的快捷公式：从 Frobenius 范数、行列式和代数余子式的定义开始进行推导。\n\n- 设计并实现一个牛顿迭代法来求解四维非线性系统 $\\nabla_F W(F) = 0$，使用基于残差范数的评价函数和 Armijo 回溯线搜索来提高鲁棒性。明确地实现一个回溯线搜索，以确保评价函数有充分的下降。通过对收敛的驻点进行分类来绘制吸引盆。使用以下分类方法：如果迭代收敛到平凡驻点（数值上表征为对一个小的容差 $\\varepsilon$ 有 $\\|F\\|_F \\leq \\varepsilon$），则返回 $0$；如果迭代收敛到缩放旋转流形（数值上表征为 $F \\approx \\operatorname{Cof}(F)$ 且 $\\det F \\approx r^\\star$，其中 $r^\\star := 1 - \\mu/\\lambda$），则返回 $1$；否则返回 $2$。应通过沿着秩一方向 $u \\otimes v$ 进行初始化，并观察迭代收敛到哪个吸引盆来探测秩一连通性的存在。\n\n- 对每个测试用例，使用不带线搜索的普通牛顿法进行第二次运行，以揭示在非凸能量形貌上的潜在失效模式。报告普通方法是否收敛（布尔值）。\n\n使用材料参数 $\\mu = 0.5$ 和 $\\lambda = 1.0$。角度必须以弧度表示。构建以下初始变形梯度测试套件：\n1. 靠近缩放旋转流形的一个微扰，其中 $a = \\sqrt{1 - \\mu/\\lambda}$：$F_1 = \\begin{pmatrix} a  10^{-4} \\\\ -10^{-4}  a \\end{pmatrix}$，其中 $a = \\sqrt{0.5}$。\n2. 精确位于零角度的缩放旋转流形上：$F_2 = \\begin{pmatrix} a  0 \\\\ 0  a \\end{pmatrix}$，其中 $a = \\sqrt{0.5}$。\n3. 一个小振幅的秩一初始点：$F_3 = u \\otimes v$，其中 $u = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，$v = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$，并按 $10^{-3}$ 缩放，即 $F_3 = \\begin{pmatrix} 0  10^{-3} \\\\ 0  0 \\end{pmatrix}$。\n4. 一个中等振幅的秩一初始点：$F_4 = \\alpha \\, u \\otimes v$，其中 $\\alpha = 0.2$，$u = \\begin{pmatrix} \\cos(\\pi/4) \\\\ \\sin(\\pi/4) \\end{pmatrix}$，$v = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，即 $F_4 = \\begin{pmatrix} 0.14142136  0 \\\\ 0.14142136  0 \\end{pmatrix}$。\n5. 一个具有负行列式的远初始点：$F_5 = \\begin{pmatrix} -1.5  0.7 \\\\ 0.9  -0.1 \\end{pmatrix}$。\n\n对于每个测试用例，运行两种求解器（普通牛顿法和带回溯线搜索的牛顿法），并为该测试用例生成一个包含三个值的列表作为最终结果：\n- 一个布尔值，指示普通牛顿法是否在容差内收敛，\n- 使用回溯线搜索时收敛解的整数分类（按上文定义的 $0$、$1$ 或 $2$），\n- 一个浮点数，给出线搜索运行的最终残差范数（$\\nabla_F W(F)$ 的欧几里得范数），四舍五入到六位小数。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个由逗号分隔的列表，该列表包含这些三元组列表，并用方括号括起来（例如，\"[[true_or_false,classification,residual],...]\"，其中残差表示为十进制数）。不涉及物理单位；角度必须按规定以弧度表示。", "solution": "该问题要求推导给定弹性势能密度驻点的控制方程，并实现一个数值求解器来找到这些点。我们将首先验证问题，然后给出所需的解析推导，最后详细说明数值算法。\n\n该问题被认为是有效的。它在科学上基于非线性连续介质力学的原理，特别是关于超弹性材料模型。能量泛函 $W(F) = \\mu \\|F\\|_F^2 + \\lambda (\\det F - 1)^2$ 是在 $2 \\times 2$ 矩阵空间上的一个良定义、可微的函数，代表了一个简单的模型，该模型同时惩罚刚性偏差（通过 Frobenius 范数项）和体积变化（通过行列式项）。寻找驻点 $\\nabla_F W(F) = 0$ 的任务是计算力学中的一个标准问题，可通过求根算法解决。该问题是适定的，为数值研究提供了所有必要的定义、材料参数和初始条件。它是客观且无歧义的。\n\n### 1. 梯度和雅可比矩阵的推导\n\n令变形梯度表示为 $F \\in \\mathbb{R}^{2 \\times 2}$，其分量为：\n$$\nF = \\begin{pmatrix} F_{11}  F_{12} \\\\ F_{21}  F_{22} \\end{pmatrix} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}\n$$\n弹性势能密度由下式给出：\n$$\nW(F) = \\mu \\|F\\|_F^2 + \\lambda (\\det F - 1)^2\n$$\n其中 $\\mu  0$ 和 $\\lambda  0$ 是材料常数。\n\n用分量 $\\{a, b, c, d\\}$ 表示，Frobenius 范数的平方是 $\\|F\\|_F^2 = a^2 + b^2 + c^2 + d^2$，行列式是 $\\det F = ad - bc$。能量函数可以写成：\n$$\nW(a,b,c,d) = \\mu (a^2 + b^2 + c^2 + d^2) + \\lambda (ad - bc - 1)^2\n$$\n$W$ 的驻点位于其相对于 $F$ 的梯度为零的地方。梯度 $\\nabla_F W(F)$ 是一个 $2 \\times 2$ 矩阵，其 $(i,j)$ 项是 $\\frac{\\partial W}{\\partial F_{ij}}$。\n\n我们通过应用链式法则来计算梯度。第一项的梯度是：\n$$\n\\nabla_F (\\mu \\|F\\|_F^2) = \\nabla_F \\left(\\mu \\sum_{i,j=1}^2 F_{ij}^2\\right) = 2\\mu F\n$$\n对于第二项，我们使用给定的法则 $\\frac{\\partial \\det(F)}{\\partial F_{ij}} = \\operatorname{Cof}(F)_{ij}$。$F$ 的代数余子式矩阵是：\n$$\n\\operatorname{Cof}(F) = \\begin{pmatrix} d  -c \\\\ -b  a \\end{pmatrix}\n$$\n第二项的梯度是：\n$$\n\\nabla_F (\\lambda(\\det F - 1)^2) = 2\\lambda(\\det F - 1) \\nabla_F(\\det F) = 2\\lambda(\\det F - 1) \\operatorname{Cof}(F)\n$$\n将它们结合起来，能量函数的完整梯度是：\n$$\n\\nabla_F W(F) = 2\\mu F + 2\\lambda(\\det F - 1) \\operatorname{Cof}(F)\n$$\n待解的非线性方程是 $\\nabla_F W(F) = 0$。我们定义残差函数 $G(F) = \\nabla_F W(F)$。为了实现数值求解器，我们将矩阵 $F$ 展平成一个向量 $x = (a, b, c, d)^T \\in \\mathbb{R}^4$。矩阵方程 $G(F)=0$ 变成一个向量方程 $g(x)=0$，其中 $g(x)$ 是 $G(F)$ 的展平版本。\n代入 $F$ 和 $\\operatorname{Cof}(F)$ 的分量表达式，我们得到：\n$$\ng(x) = \\begin{pmatrix} g_1 \\\\ g_2 \\\\ g_3 \\\\ g_4 \\end{pmatrix} = \\begin{pmatrix}\n2\\mu a + 2\\lambda(ad-bc-1)d \\\\\n2\\mu b + 2\\lambda(ad-bc-1)(-c) \\\\\n2\\mu c + 2\\lambda(ad-bc-1)(-b) \\\\\n2\\mu d + 2\\lambda(ad-bc-1)a\n\\end{pmatrix} = \\begin{pmatrix}\n2\\mu a + 2\\lambda(ad-bc-1)d \\\\\n2\\mu b - 2\\lambda(ad-bc-1)c \\\\\n2\\mu c - 2\\lambda(ad-bc-1)b \\\\\n2\\mu d + 2\\lambda(ad-bc-1)a\n\\end{pmatrix}\n$$\n这个系统的雅可比矩阵 $J_g(x)$ 是一个 $4 \\times 4$ 的偏导数矩阵，$J_{ij} = \\frac{\\partial g_i}{\\partial x_j}$，其中 $x = (x_1, x_2, x_3, x_4)^T = (a, b, c, d)^T$。令 $S = ad-bc-1$。\n雅可比矩阵的分量是：\n- 第 1 行 ($g_1 = 2\\mu a + 2\\lambda S d$):\n  - $\\frac{\\partial g_1}{\\partial a} = 2\\mu + 2\\lambda (\\frac{\\partial S}{\\partial a}d) = 2\\mu + 2\\lambda(d)d = 2\\mu + 2\\lambda d^2$\n  - $\\frac{\\partial g_1}{\\partial b} = 2\\lambda (\\frac{\\partial S}{\\partial b}d) = 2\\lambda(-c)d = -2\\lambda cd$\n  - $\\frac{\\partial g_1}{\\partial c} = 2\\lambda (\\frac{\\partial S}{\\partial c}d) = 2\\lambda(-b)d = -2\\lambda bd$\n  - $\\frac{\\partial g_1}{\\partial d} = 2\\lambda(S \\cdot 1 + \\frac{\\partial S}{\\partial d}d) = 2\\lambda(S + ad) = 2\\lambda(ad-bc-1+ad) = 2\\lambda(2ad-bc-1)$\n- 第 2 行 ($g_2 = 2\\mu b - 2\\lambda S c$):\n  - $\\frac{\\partial g_2}{\\partial a} = -2\\lambda(\\frac{\\partial S}{\\partial a}c) = -2\\lambda(d)c = -2\\lambda cd$\n  - $\\frac{\\partial g_2}{\\partial b} = 2\\mu - 2\\lambda(\\frac{\\partial S}{\\partial b}c) = 2\\mu - 2\\lambda(-c)c = 2\\mu + 2\\lambda c^2$\n  - $\\frac{\\partial g_2}{\\partial c} = -2\\lambda(S \\cdot 1 + \\frac{\\partial S}{\\partial c}c) = -2\\lambda(S - bc) = -2\\lambda(ad-2bc-1)$\n  - $\\frac{\\partial g_2}{\\partial d} = -2\\lambda(\\frac{\\partial S}{\\partial d}c) = -2\\lambda(a)c = -2\\lambda ac$\n通过对称性（例如 $\\frac{\\partial g_3}{\\partial a} = \\frac{\\partial g_1}{\\partial c}$ 需要交换 $b \\leftrightarrow c$）或直接计算，我们可以找到其余的行。得到的雅可比矩阵是对称的，因为它是标量势 $W$ 的 Hessian 矩阵。完整的雅可比矩阵是：\n$$\nJ_g(x) = 2 \\begin{pmatrix}\n\\mu + \\lambda d^2   -\\lambda cd   -\\lambda bd   \\lambda(2ad-bc-1) \\\\\n-\\lambda cd   \\mu + \\lambda c^2   -\\lambda(ad-2bc-1)   -\\lambda ac \\\\\n-\\lambda bd   -\\lambda(ad-2bc-1)   \\mu + \\lambda b^2   -\\lambda ab \\\\\n\\lambda(2ad-bc-1)   -\\lambda ac   -\\lambda ab   \\mu + \\lambda a^2\n\\end{pmatrix}\n$$\n\n### 2. 带回溯线搜索的牛顿法\n\n为了求解非线性系统 $g(x) = 0$，我们采用牛顿法。给定一个迭代点 $x_k$，下一个迭代点 $x_{k+1}$ 通过求解步长 $\\Delta x_k$ 的线性化系统得到：\n$$\nJ_g(x_k) \\Delta x_k = -g(x_k)\n$$\n一个普通的牛顿更新将是 $x_{k+1} = x_k + \\Delta x_k$。然而，对于像这样的非凸能量形貌，迭代点很容易被送到局部二次近似很差的区域，导致发散。为了全局化该方法并提高鲁棒性，我们引入一个步长 $\\alpha_k \\in (0, 1]$ 并按 $x_{k+1} = x_k + \\alpha_k \\Delta x_k$ 进行更新。\n\n步长 $\\alpha_k$ 是通过回溯线搜索确定的，以确保评价函数有充分的下降。一个合适的评价函数是 $m(x) = \\frac{1}{2}\\|g(x)\\|_2^2$。牛顿步 $\\Delta x_k$ 是此函数的下降方向。我们寻求满足 Armijo 条件的 $\\alpha_k$：\n$$\nm(x_k + \\alpha_k \\Delta x_k) \\leq m(x_k) + c_1 \\alpha_k \\nabla m(x_k)^T \\Delta x_k\n$$\n其中 $c_1$ 是一个小常数，通常为 $10^{-4}$。注意到 $\\nabla m(x_k)^T \\Delta x_k = g(x_k)^T J_g(x_k) \\Delta x_k = -g(x_k)^T g(x_k) = -\\|g(x_k)\\|_2^2$，该条件变为：\n$$\n\\frac{1}{2}\\|g(x_k + \\alpha_k \\Delta x_k)\\|_2^2 \\leq \\frac{1}{2}\\|g(x_k)\\|_2^2 - c_1 \\alpha_k \\|g(x_k)\\|_2^2\n$$\n线搜索算法从 $\\alpha_k=1$ 开始，并重复地将其乘以一个回溯因子 $\\tau \\in (0, 1)$（例如 $\\tau=0.5$），直到满足此条件。\n\n### 3. 驻点的分类\n\n一旦迭代收敛到解 $F_c$，我们对其进行分类。\n- **类别 0 (平凡)：** 零矩阵 $F=0$ 是一个驻点，因为 $G(0) = 2\\mu(0) + 2\\lambda(0-1)\\operatorname{Cof}(0) = 0$。在数值上，如果对一个小的容差 $\\varepsilon$ 有 $\\|F_c\\|_F \\leq \\varepsilon$，我们则将解分类为平凡解。\n- **类别 1 (缩放旋转流形)：** 此类别代表具有物理意义的非退化解。从条件 $G(F)=0$，我们有 $F = -\\frac{\\lambda}{\\mu}(\\det F - 1)\\operatorname{Cof}(F)$。一个关键的解族满足 $F = k \\, \\operatorname{Cof}(F)$。这意味着 $k = \\pm 1$。如果 $k=1$，则 $F=\\operatorname{Cof}(F)$，这是一个矩阵成为缩放旋转的条件（即，$F_{11}=F_{22}$ 且 $F_{12}=-F_{21}$）。将 $F=\\operatorname{Cof}(F)$ 代入驻点条件，得到 $F = -\\frac{\\lambda}{\\mu}(\\det F - 1)F$，对于 $F \\neq 0$，这意味着 $1 = -\\frac{\\lambda}{\\mu}(\\det F - 1)$，或 $\\det F = 1 - \\mu/\\lambda$。对于给定的参数 $\\mu=0.5, \\lambda=1.0$，这给出 $\\det F = 0.5$。在数值上，如果一个解同时满足 $\\|F_c - \\operatorname{Cof}(F_c)\\|_F \\leq \\varepsilon_{approx}$ 和 $|\\det F_c - (1-\\mu/\\lambda)| \\leq \\varepsilon_{approx}$，我们将其分类为类别 1。\n- **类别 2 (其他)：** 任何不属于类别 0 或类别 1 的收敛解。这可能包括能量泛函的其他驻点或鞍点。\n\n这个框架不仅使我们能够找到解，还能刻画不同类型稳态的吸引盆，这对于理解材料的力学行为至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for stationary points of an elastic energy functional using Newton's method\n    and classifies the basins of attraction.\n    \"\"\"\n    mu = 0.5\n    lmbda = 1.0\n\n    # Define test cases\n    a_sqrt_half = np.sqrt(0.5)\n    test_cases = [\n        np.array([[a_sqrt_half, 1e-4], [-1e-4, a_sqrt_half]]),\n        np.array([[a_sqrt_half, 0.0], [0.0, a_sqrt_half]]),\n        np.array([[0.0, 1e-3], [0.0, 0.0]]),\n        np.array([[0.14142136, 0.0], [0.14142136, 0.0]]),\n        np.array([[-1.5, 0.7], [0.9, -0.1]])\n    ]\n\n    results = []\n    for F_initial in test_cases:\n        x_initial = F_initial.flatten()\n\n        # Run plain Newton's method\n        plain_converged, _ = newton_solver(x_initial, mu, lmbda, use_line_search=False)\n\n        # Run Newton's method with backtracking line search\n        line_search_converged, x_final = newton_solver(x_initial, mu, lmbda, use_line_search=True)\n        \n        F_final = x_final.reshape((2, 2))\n        final_residual_norm = np.linalg.norm(residual_g(x_final, mu, lmbda))\n\n        # Classify the solution from the line search run\n        classification = classify_solution(F_final, mu, lmbda)\n        \n        # Round the residual as required\n        rounded_residual = round(final_residual_norm, 6)\n\n        results.append([plain_converged, classification, rounded_residual])\n\n    # Format and print the final output\n    # Using a custom formatter to avoid trailing zeros for integers\n    def format_item(item):\n        if isinstance(item, bool):\n            return str(item).lower()\n        if isinstance(item, int):\n            return str(item)\n        if isinstance(item, float):\n            return f\"{item:.6f}\"\n        return str(item)\n\n    result_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(map(format_item, r)) + \"]\" for r in results\n    ) + \"]\"\n    print(result_str)\n\ndef residual_g(x, mu, lmbda):\n    \"\"\"Computes the residual vector g(x).\"\"\"\n    a, b, c, d = x\n    det_F = a * d - b * c\n    S = det_F - 1\n    g = np.zeros(4)\n    g[0] = 2 * mu * a + 2 * lmbda * S * d\n    g[1] = 2 * mu * b - 2 * lmbda * S * c\n    g[2] = 2 * mu * c - 2 * lmbda * S * b\n    g[3] = 2 * mu * d + 2 * lmbda * S * a\n    return g\n\ndef jacobian_J(x, mu, lmbda):\n    \"\"\"Computes the Jacobian matrix J(x).\"\"\"\n    a, b, c, d = x\n    det_F = a * d - b * c\n    J = np.zeros((4, 4))\n    \n    # Row 1\n    J[0, 0] = 2 * mu + 2 * lmbda * d**2\n    J[0, 1] = -2 * lmbda * c * d\n    J[0, 2] = -2 * lmbda * b * d\n    J[0, 3] = 2 * lmbda * (2 * a * d - b * c - 1)\n    \n    # Row 2\n    J[1, 0] = -2 * lmbda * c * d\n    J[1, 1] = 2 * mu + 2 * lmbda * c**2\n    J[1, 2] = -2 * lmbda * (a * d - 2 * b * c - 1)\n    J[1, 3] = -2 * lmbda * a * c\n    \n    # Row 3\n    J[2, 0] = -2 * lmbda * b * d\n    J[2, 1] = -2 * lmbda * (a * d - 2 * b * c - 1)\n    J[2, 2] = 2 * mu + 2 * lmbda * b**2\n    J[2, 3] = -2 * lmbda * a * b\n    \n    # Row 4\n    J[3, 0] = 2 * lmbda * (2 * a * d - b * c - 1)\n    J[3, 1] = -2 * lmbda * a * c\n    J[3, 2] = -2 * lmbda * a * b\n    J[3, 3] = 2 * mu + 2 * lmbda * a**2\n    \n    return J\n\ndef newton_solver(x0, mu, lmbda, use_line_search=True, max_iter=100, tol=1e-8, c1=1e-4, tau=0.5):\n    \"\"\"\n    Newton's method solver, with optional backtracking line search.\n    \"\"\"\n    x = np.copy(x0)\n    for _ in range(max_iter):\n        g = residual_g(x, mu, lmbda)\n        if np.linalg.norm(g)  tol:\n            return True, x\n        \n        J = jacobian_J(x, mu, lmbda)\n        \n        try:\n            delta_x = np.linalg.solve(J, -g)\n        except np.linalg.LinAlgError:\n            # Singular Jacobian\n            return False, x\n\n        if use_line_search:\n            alpha = 1.0\n            g_norm_sq = np.dot(g, g)\n            # Armijo condition check\n            while True:\n                x_new = x + alpha * delta_x\n                g_new = residual_g(x_new, mu, lmbda)\n                g_new_norm_sq = np.dot(g_new, g_new)\n                if g_new_norm_sq = g_norm_sq - 2 * c1 * alpha * g_norm_sq:\n                    break\n                alpha *= tau\n                if alpha  1e-8: # Prevent infinite loop\n                    return False, x\n            x += alpha * delta_x\n        else: # Plain Newton\n            x += delta_x\n        \n        # Check for divergence in plain Newton mode for stability\n        if not use_line_search and np.linalg.norm(g) > 1e10:\n             return False, x\n\n    # Check for convergence after max_iter\n    g_final = residual_g(x, mu, lmbda)\n    converged = np.linalg.norm(g_final)  tol\n    return converged, x\n\ndef classify_solution(F, mu, lmbda, tol_trivial=1e-6, tol_approx=1e-6):\n    \"\"\"\n    - 0: trivial stationary point\n    - 1: scaled-rotation manifold\n    - 2: other\n    \"\"\"\n    # Class 0: Trivial solution\n    if np.linalg.norm(F, 'fro') = tol_trivial:\n        return 0\n\n    # Class 1: Scaled-rotation manifold\n    a, b, c, d = F.flatten()\n    Cof_F = np.array([[d, -c], [-b, a]])\n    \n    det_F = a * d - b * c\n    r_star = 1.0 - mu / lmbda\n    \n    is_cof_match = np.linalg.norm(F - Cof_F, 'fro') = tol_approx\n    is_det_match = abs(det_F - r_star) = tol_approx\n    \n    if is_cof_match and is_det_match:\n        return 1\n\n    # Class 2: Other\n    return 2\n\nsolve()\n```", "id": "3486017"}, {"introduction": "最后，我们来应对可扩展性的挑战，这是计算材料科学中的一个核心议题。对于许多现实世界的问题，例如从实验数据中拟合成千上万个位点的参数，构建和求逆牛顿法中的雅可比矩阵在计算上是不可行的。本练习将介绍拟牛顿法，特别是有限内存的布罗伊登方法（L-Broyden），作为一种功能强大的无矩阵替代方案。通过这个实践，你将掌握如何高效地存储和利用历史步长向量对 $(s_k, y_k)$ 来近似雅可比矩阵逆的作用，这是大规模科学计算中的一项关键技术。[@problem_id:3485986]", "problem": "考虑一个源于计算材料科学的大规模参数估计问题，该问题被表述为从观测到的格点占据数中恢复晶体固体中的缺陷能级。对于每个格点索引 $i \\in \\{1,\\dots,N\\}$，在温度 $T$ 和化学势 $\\mu$ 下的占据数 $f_i$ 通过费米-狄拉克分布进行建模，这是统计力学中一个经过充分检验的公式：$$f_i(E_i;\\mu,T) = \\frac{1}{1+\\exp\\left(\\frac{E_i - \\mu}{k_B T}\\right)},$$ 其中 $E_i$ 是格点 $i$ 处的缺陷能级，$k_B$ 是玻尔兹曼常数。给定一个观测占据数向量 $\\mathbf{f}^{\\mathrm{obs}} \\in \\mathbb{R}^N$，参数估计问题在于找到一个能量向量 $\\mathbf{x} \\in \\mathbb{R}^N$，使得 $$F(\\mathbf{x}) = \\left(f_i(x_i;\\mu,T) - f_i^{\\mathrm{obs}}\\right)_{i=1}^N = \\mathbf{0},$$ 从而使模型计算的占据数与观测到的占据数相匹配。能量必须以电子伏特 $\\mathrm{eV}$ 表示，温度以开尔文 $K$ 表示。占据数是无量纲的。\n\n您将实现一个基于有限内存 Broyden 策略（Limited-memory Broyden, L-Broyden）的求根求解器，该求解器适用于高维非线性系统。该求解器的设计应避免构造稠密的雅可比矩阵或逆雅可比矩阵。相反，它必须只维护最近的 $m$ 个向量对 $(s_k, y_k)$，其中 $s_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$ 且 $y_k = F(\\mathbf{x}_{k+1}) - F(\\mathbf{x}_k)$。它必须使用这些存储的向量对和一个初始单位矩阵的标量倍，来计算当前逆雅可比近似在一个任意向量上的作用。从拟牛顿更新的基本割线条件以及在满足割线方程的同时确保对逆算子改动最小的原则出发，推导出在有限内存下高效存储和更新 $(s_k,y_k)$ 所需的结构。您的程序必须包含一个线搜索，以确保评价函数 $$\\phi(\\mathbf{x}) = \\frac{1}{2}\\|F(\\mathbf{x})\\|_2^2,$$ 的单调递减，并且当无穷范数 $\\|F(\\mathbf{x})\\|_\\infty$ 低于指定的容差时必须停止。\n\n按如下方式构建人工合成但科学上合理的测试实例。使用一个确定性能量场 $$E_i^{\\star} = 0.4 + 0.25\\sin\\left(\\frac{2\\pi i}{N}\\right) + 0.15\\cos\\left(\\frac{4\\pi i}{N}\\right) \\quad \\text{for}\\quad i=1,\\dots,N,$$ 单位为 $\\mathrm{eV}$。使用给定的 $T$ 和 $\\mu$ 通过 $f_i^{\\mathrm{obs}} = f_i(E_i^{\\star};\\mu,T)$ 生成观测占据数。在 $\\mathbf{x}_0 = \\mathbf{E}^{\\star} + \\delta\\,\\mathbf{1}$ 处初始化求解器，其中 $\\delta$ 是一个单位为 $\\mathrm{eV}$ 的标量偏移。使用 $k_B = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV}/K$。\n\n实现 L-Broyden 求解器，使其满足：\n- 最多维护 $m$ 个最近的向量对 $(s_k,y_k)$。\n- 通过将当前的有限内存逆雅可比近似应用于 $F(\\mathbf{x}_k)$ 来计算搜索方向，而无需构造任何稠密矩阵。\n- 采用回溯线搜索以确保 $\\phi(\\mathbf{x}_{k+1})  \\phi(\\mathbf{x}_k)$。\n- 当 $\\|F(\\mathbf{x}_k)\\|_\\infty  \\text{tol}$ 或达到最大迭代次数后终止。\n\n您的程序必须运行以下测试套件，并以指定格式报告结果：\n- 测试 1 (一般情况): $N=200$, $m=10$, $\\mu=0.4\\,\\mathrm{eV}$, $T=900\\,K$, $\\delta=0.2\\,\\mathrm{eV}$, $\\text{tol}=10^{-10}$, $\\text{maxiter}=200$。\n- 测试 2 (边界情况，无内存): $N=300$, $m=0$, $\\mu=0.4\\,\\mathrm{eV}$, $T=900\\,K$, $\\delta=0.2\\,\\mathrm{eV}$, $\\text{tol}=10^{-8}$, $\\text{maxiter}=250$。\n- 测试 3 (边缘情况，陡峭非线性): $N=150$, $m=5$, $\\mu=0.1\\,\\mathrm{eV}$, $T=300\\,K$, $\\delta=-0.1\\,\\mathrm{eV}$, $\\text{tol}=10^{-8}$, $\\text{maxiter}=300$。\n\n对于每个测试用例，返回三项内容：一个指示是否达到收敛的布尔值（定义为 $\\|F(\\mathbf{x})\\|_\\infty  \\text{tol}$）、$\\|F(\\mathbf{x})\\|_\\infty$ 的最终值（一个浮点数）以及所用的迭代次数（一个整数）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试 1、2 和 3 的顺序排列结果，例如：$$[\\text{conv}_1,\\|F\\|_{\\infty,1},\\text{iter}_1,\\text{conv}_2,\\|F\\|_{\\infty,2},\\text{iter}_2,\\text{conv}_3,\\|F\\|_{\\infty,3},\\text{iter}_3].$$", "solution": "- **科学依据（关键）**：该问题植根于费米-狄拉克分布，这是统计力学中的一个基本概念。将其应用于材料科学中的缺陷位占据数是一种标准且科学上合理的建模方法。\n- **适定性**：该问题是适定的。对于任何给定的 $\\mu$ 和 $T$，函数 $f_i(E_i)$ 都是单调的，这确保了对于任何物理上合理的占据数 $f_i^{\\mathrm{obs}} \\in (0,1)$，都存在一个唯一的能级 $E_i$。这保证了解向量 $\\mathbf{x}$ 的唯一性。人工数据的生成是确定性的，并提供了所有必要的信息。\n- **客观性（关键）**：该问题以精确的数学和科学语言陈述，没有歧义或主观论断。\n\n该问题被构建为一个教学练习，要求在一个科学上合理的测试案例上实现一个特定的、非平凡的数值算法（L-Broyden）。尽管方程组是对角化的，因此每个分量都可以解析求解，但核心任务是正确实现通用求解器，这在科学计算中是一个有意义的挑战。该系统的解耦性质使其成为一个干净的测试平台，没有引入由强变量间耦合带来的复杂性，这是一种有效的教学简化。\n\n**结论：** 问题是有效的。\n\n### 解法推导\n\n该问题要求解非线性方程组 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{0}$，其中第 $i$ 个分量由下式给出：\n$$F_i(\\mathbf{x}) = \\frac{1}{1+\\exp\\left(\\frac{x_i - \\mu}{k_B T}\\right)} - f_i^{\\mathrm{obs}} = 0$$\n这里，$\\mathbf{x} \\in \\mathbb{R}^N$ 是待求的缺陷能级向量。这是一个求根问题。我们将实现一种有限内存拟牛顿法，具体是问题所要求的“好”Broyden 方法。\n\n拟牛顿法近似雅可比矩阵 $J(\\mathbf{x})$ 或其逆矩阵 $H(\\mathbf{x}) = J(\\mathbf{x})^{-1}$。迭代过程如下：\n$$\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k$$\n其中 $\\mathbf{p}_k$ 是搜索方向，$\\alpha_k$ 是由线搜索确定的步长。搜索方向通过求解线性系统 $B_k \\mathbf{p}_k = -\\mathbf{F}(\\mathbf{x}_k)$ 来计算，或者更直接地通过 $\\mathbf{p}_k = -H_k \\mathbf{F}(\\mathbf{x}_k)$ 计算，其中 $B_k \\approx J(\\mathbf{x}_k)$ 且 $H_k \\approx J(\\mathbf{x}_k)^{-1}$。\n\n逆雅可比近似 $H_k$ 在每一步更新以满足割线方程：\n$$H_{k+1} \\mathbf{y}_k = \\mathbf{s}_k$$\n其中 $\\mathbf{s}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$ 且 $\\mathbf{y}_k = \\mathbf{F}(\\mathbf{x}_{k+1}) - \\mathbf{F}(\\mathbf{x}_k)$。\n\nBroyden 的“好”方法为 $H_k$ 提供了一个更新，该更新满足割线方程并最小化变化的弗罗贝尼乌斯范数 $\\|H_{k+1} - H_k\\|_F$。更新公式为：\n$$H_{k+1} = H_k + \\frac{(\\mathbf{s}_k - H_k \\mathbf{y}_k)\\mathbf{y}_k^T}{\\mathbf{y}_k^T \\mathbf{y}_k}$$\n这是一个秩-1 更新。对于有限内存实现（L-Broyden），我们不构造或存储稠密的 $N \\times N$ 矩阵 $H_k$。相反，我们存储最近的 $m$ 个向量对 $(\\mathbf{s}_j, \\mathbf{y}_j)$，并用它们来计算 $H_k$ 对向量的作用，具体来说是 $\\mathbf{p}_k = -H_k \\mathbf{F}(\\mathbf{x}_k)$。\n\n设存储的向量对为 $(\\mathbf{s}_0, \\mathbf{y}_0), \\dots, (\\mathbf{s}_{m-1}, \\mathbf{y}_{m-1})$，它们代表从初始近似 $H_{\\text{init}}$ 开始的更新。根据问题建议，我们将 $H_{\\text{init}}$ 取为单位矩阵 $I$。$H_k$（经过 $m$ 次更新后我们记为 $H_m$）对向量 $\\mathbf{v}$ 的作用可以通过顺序应用更新来计算。设 $H_i$ 是经过 $i$ 次更新后的近似。\n$$H_{i+1}\\mathbf{v} = H_i\\mathbf{v} + (\\mathbf{s}_i - H_i \\mathbf{y}_i) \\frac{\\mathbf{y}_i^T \\mathbf{v}}{\\mathbf{y}_i^T \\mathbf{y}_i}$$\n为了计算 $H_m\\mathbf{v}$，我们需要 $H_{m-1}\\mathbf{v}$ 和 $H_{m-1}\\mathbf{y}_{m-1}$。这种递归结构可以通过一个避免重复计算的迭代算法来高效实现。\n\n**计算 $H_m \\mathbf{v}$ 的算法：**\n设存储的历史为向量集 $S = \\{\\mathbf{s}_0, \\dots, \\mathbf{s}_{m-1}\\}$ 和 $Y = \\{\\mathbf{y}_0, \\dots, \\mathbf{y}_{m-1}\\}$。\n1.  初始化目标向量 $\\mathbf{p} = H_{\\text{init}}\\mathbf{v} = \\mathbf{v}$。\n2.  初始化一个长度为 $m$ 的辅助向量数组 `gamma`：$\\gamma_j = H_{\\text{init}}\\mathbf{y}_j = \\mathbf{y}_j$，其中 $j=0, \\dots, m-1$。\n3.  对 $i$ 从 $0$ 到 $m-1$进行迭代：\n    a. 向量 $\\gamma_i$ 当前持有 $H_i \\mathbf{y}_i$。\n    b. 计算分母 $\\text{denom} = \\mathbf{y}_i^T \\mathbf{y}_i$。如果 $\\text{denom}$ 接近于零，则此更新不稳定，应跳过。\n    c. 将目标向量 $\\mathbf{p}$（代表 $H_i\\mathbf{v}$）更新为 $H_{i+1}\\mathbf{v}$：\n       $$\\mathbf{p} \\leftarrow \\mathbf{p} + (\\mathbf{s}_i - \\gamma_i) \\frac{\\mathbf{y}_i^T \\mathbf{v}}{\\text{denom}}$$\n    d. 对于所有后续的辅助向量 $\\gamma_j$（$j  i$），将它们从代表 $H_i\\mathbf{y}_j$ 更新为 $H_{i+1}\\mathbf{y}_j$：\n       $$\\gamma_j \\leftarrow \\gamma_j + (\\mathbf{s}_i - \\gamma_i) \\frac{\\mathbf{y}_i^T \\mathbf{y}_j}{\\text{denom}} \\quad \\text{for } j=i+1, \\dots, m-1$$\n循环结束后，$\\mathbf{p}$ 将持有 $H_m\\mathbf{v}$ 的结果。此过程的成本为 $O(m^2)$ 次点积和 $O(m^2)$ 次向量运算（SAXPY），因此当 $m \\ll N$ 时是高效的。\n\n**线搜索：**\n为确保收敛，采用线搜索来寻找一个步长 $\\alpha_k$，以保证评价函数有足够的下降。问题指定了评价函数 $\\phi(\\mathbf{x}) = \\frac{1}{2}\\|\\mathbf{F}(\\mathbf{x})\\|_2^2$ 和条件 $\\phi(\\mathbf{x}_{k+1})  \\phi(\\mathbf{x}_k)$。我们使用一个简单的回溯线搜索：\n1.  从完整步长开始，$\\alpha = 1$。\n2.  计算试验点 $\\mathbf{x}_{\\text{trial}} = \\mathbf{x}_k + \\alpha \\mathbf{p}_k$。\n3.  如果 $\\phi(\\mathbf{x}_{\\text{trial}})  \\phi(\\mathbf{x}_k)$，则接受该步长：$\\alpha_k = \\alpha$，$\\mathbf{x}_{k+1} = \\mathbf{x}_{\\text{trial}}$。\n4.  否则，减小步长，例如 $\\alpha \\leftarrow \\alpha/2$，并从第 2 步重复。\n\n**特殊情况 $m=0$：**\n当内存参数 $m$ 为 0 时，不存储任何历史记录。`apply_H` 算法不会进入循环，搜索方向简化为 $\\mathbf{p}_k = -H_{\\text{init}}\\mathbf{F}(\\mathbf{x}_k) = -\\mathbf{F}(\\mathbf{x}_k)$。这将该方法简化为一个带有线搜索的简单迭代方案，具体来说是针对评价函数 $\\phi(\\mathbf{x})$ 的一种最速下降法。\n\n**L-Broyden 总体算法：**\n1.  **初始化**：选择 $\\mathbf{x}_0$、容差 `tol`、最大迭代次数 `maxiter`、内存 $m$。设置 $k=0$，$S=\\{\\}$，$Y=\\{\\}$。计算 $\\mathbf{F}_0 = \\mathbf{F}(\\mathbf{x}_0)$。\n2.  **迭代**：对于 $k=0, 1, 2, \\dots, \\text{maxiter}-1$：\n    a. 检查收敛性：如果 $\\|\\mathbf{F}_k\\|_\\infty  \\text{tol}$，停止并报告成功。\n    b. 计算搜索方向 $\\mathbf{p}_k = -\\text{apply\\_H}(\\mathbf{F}_k, S, Y)$。\n    c. 执行线搜索找到 $\\alpha_k$ 使得 $\\phi(\\mathbf{x}_k+\\alpha_k \\mathbf{p}_k)  \\phi(\\mathbf{x}_k)$。如果找不到这样的 $\\alpha_k$，停止并报告失败。\n    d. 更新解：$\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k$。\n    e. 计算新残差：$\\mathbf{F}_{k+1} = \\mathbf{F}(\\mathbf{x}_{k+1})$。\n    f. 定义步长向量：$\\mathbf{s}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$，$\\mathbf{y}_k = \\mathbf{F}_{k+1} - \\mathbf{F}_k$。\n    g. 更新历史记录：如果 $\\|\\mathbf{y}_k\\|^2  0$：\n       - 如果 $|S| = m$，从 $S$ 和 $Y$ 中移除最旧的 $(\\mathbf{s}, \\mathbf{y})$ 对。\n       - 将 $\\mathbf{s}_k$ 附加到 $S$ 并将 $\\mathbf{y}_k$ 附加到 $Y$。\n3.  **终止**：如果循环因达到 `maxiter` 而结束，报告未收敛。\n\n这个完整的算法将被实现以解决给定的测试案例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the L-Broyden solver.\n    \"\"\"\n    KB_EV_K = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    test_cases = [\n        # Test 1 (general case)\n        {'N': 200, 'm': 10, 'mu': 0.4, 'T': 900, 'delta': 0.2, 'tol': 1e-10, 'maxiter': 200},\n        # Test 2 (boundary, no memory)\n        {'N': 300, 'm': 0, 'mu': 0.4, 'T': 900, 'delta': 0.2, 'tol': 1e-8, 'maxiter': 250},\n        # Test 3 (edge, steep nonlinearity)\n        {'N': 150, 'm': 5, 'mu': 0.1, 'T': 300, 'delta': -0.1, 'tol': 1e-8, 'maxiter': 300},\n    ]\n\n    results = []\n    for params in test_cases:\n        N = params['N']\n        m = params['m']\n        mu = params['mu']\n        T = params['T']\n        delta = params['delta']\n        \n        # Generate synthetic data\n        i_vec = np.arange(1, N + 1)\n        E_star = 0.4 + 0.25 * np.sin(2 * np.pi * i_vec / N) + 0.15 * np.cos(4 * np.pi * i_vec / N)\n        \n        # Fermi-Dirac function\n        def fermi_dirac(E, mu_val, T_val):\n            return 1.0 / (1.0 + np.exp((E - mu_val) / (KB_EV_K * T_val)))\n\n        f_obs = fermi_dirac(E_star, mu, T)\n\n        # The function F whose root we want to find\n        def F_func(x):\n            return fermi_dirac(x, mu, T) - f_obs\n        \n        # Initial guess\n        x0 = E_star + delta\n\n        # Run the solver\n        converged, final_norm, iterations = l_broyden_solver(\n            F_func, \n            x0, \n            m=m, \n            tol=params['tol'], \n            maxiter=params['maxiter']\n        )\n        \n        results.extend([converged, final_norm, iterations])\n    \n    # Format and print the final output\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\ndef l_broyden_solver(F_func, x0, m, tol, maxiter):\n    \"\"\"\n    Implements a limited-memory Broyden solver for F(x) = 0.\n\n    Args:\n        F_func (callable): The vector-valued function to find the root of.\n        x0 (np.ndarray): The initial guess for the solution vector x.\n        m (int): The number of history vectors (s, y) to store.\n        tol (float): The tolerance for the infinity norm of F(x) for convergence.\n        maxiter (int): The maximum number of iterations.\n\n    Returns:\n        tuple: (converged, final_norm, iterations)\n    \"\"\"\n    x_k = np.copy(x0)\n    F_k = F_func(x_k)\n    norm_F = np.linalg.norm(F_k, np.inf)\n\n    # History vectors s_k = x_{k+1}-x_k and y_k = F_{k+1}-F_k\n    S = []\n    Y = []\n    \n    for k in range(maxiter):\n        if norm_F  tol:\n            return True, norm_F, k\n\n        # Compute search direction p_k = -H_k * F_k\n        p_k = -apply_H(F_k, S, Y)\n        \n        # Backtracking line search for step size alpha\n        alpha = 1.0\n        phi_k = 0.5 * np.dot(F_k, F_k)\n        x_next, F_next = None, None\n        \n        line_search_success = False\n        for _ in range(10): # Max 10 backtracking steps\n            x_next = x_k + alpha * p_k\n            F_next = F_func(x_next)\n            phi_next = 0.5 * np.dot(F_next, F_next)\n            \n            if phi_next  phi_k:\n                line_search_success = True\n                break\n            alpha /= 2.0\n            \n        if not line_search_success:\n            return False, norm_F, k + 1\n\n        s_k = x_next - x_k\n        y_k = F_next - F_k\n\n        # Update history S and Y\n        if m > 0:\n            denom = np.dot(y_k, y_k)\n            if denom > 1e-12: # Avoid unstable updates\n                if len(S) == m:\n                    S.pop(0)\n                    Y.pop(0)\n                S.append(s_k)\n                Y.append(y_k)\n\n        x_k = x_next\n        F_k = F_next\n        norm_F = np.linalg.norm(F_k, np.inf)\n\n    return norm_F  tol, norm_F, maxiter\n\ndef apply_H(v, S, Y):\n    \"\"\"\n    Computes the action of the inverse Jacobian approximation H on a vector v.\n    H is constructed from the history vectors S and Y using the \"good\" Broyden update.\n    The initial approximation H_init is the identity matrix.\n\n    Args:\n        v (np.ndarray): The vector to apply H on.\n        S (list of np.ndarray): History of solution steps (s_k).\n        Y (list of np.ndarray): History of residual changes (y_k).\n\n    Returns:\n        np.ndarray: The result of H * v.\n    \"\"\"\n    m = len(S)\n    if m == 0:\n        return v  # H_init is identity, so H_init * v = v\n\n    # O(m^2) algorithm to compute H_m * v\n    p = np.copy(v)\n    \n    # gamma[j] will store H_j * Y[j]\n    gamma = [np.copy(y) for y in Y]\n    \n    for i in range(m):\n        yi_dot_yi = np.dot(Y[i], Y[i])\n        \n        # Skip update if denominator is too small\n        if yi_dot_yi  1e-12:\n            continue\n\n        # Update p, which represents H_i*v -> H_{i+1}*v\n        c = np.dot(Y[i], v) / yi_dot_yi\n        p += (S[i] - gamma[i]) * c\n\n        # Update gamma vectors for subsequent steps\n        # gamma[j] is updated from H_i*Y[j] to H_{i+1}*Y[j]\n        for j in range(i + 1, m):\n            d_coeff = np.dot(Y[i], Y[j]) / yi_dot_yi\n            gamma[j] += (S[i] - gamma[i]) * d_coeff\n            \n    return p\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3485986"}]}