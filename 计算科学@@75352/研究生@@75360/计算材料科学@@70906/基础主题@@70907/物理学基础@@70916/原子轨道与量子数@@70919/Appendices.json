{"hands_on_practices": [{"introduction": "在计算材料科学中，原子轨道的角向部分通常由复球面谐函数 $Y_{\\ell}^{m}$ 表示。虽然这些函数是球形势场中薛定谔方程的直接解，但对于理解化学键和对称性，诸如 $p_x$ 和 $d_{x^2-y^2}$ 等实值轨道更为直观。本实践旨在弥合这一差距，指导您实现从复数基到实数笛卡尔基的转换，并通过数值方法和对称性原理验证结果 [@problem_id:3433597]。这是解读电子结构计算输出的一项基础技能。", "problem": "在计算材料科学中，电子结构代码通常使用复球谐函数 $Y_{\\ell}^{m}$ 来表示原子角向基函数，其中 $\\ell$ 是轨道角动量量子数，$m$ 是其投影。为了在晶体对称性下进行分析，通常需要将这些复球谐函数转换为与笛卡尔坐标轴对齐的实立方谐函数，例如立方晶体环境中的常见 $p$ 和 $d$ 轨道。从球坐标系下不含时薛定谔方程的变量分离出发（其在单位球面上产生作为球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 的角向解），实现一个后处理工具，该工具将复球谐函数映射到实立方谐函数，并通过在单位球面上再现预期的笛卡尔形状以及展示在立方对称性操作下正确的简并结构来验证此映射。\n\n基本原理：\n- 对于固定的 $\\ell$，复球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 在单位球面上构成一个正交归一基，其中 $m$ 的取值范围为 $- \\ell$ 到 $+\\ell$。\n- 实立方谐函数是通过对给定 $\\ell$ 的复球谐函数进行特定的实线性组合得到的，选择这些组合是为了与单位球面上的笛卡尔坐标多项式形状对齐。\n- 三维空间中的旋转通过变换其自变量来作用于球面上的函数：一个旋转 $R$ 将函数 $f(x,y,z)$ 映射为 $f(R^{-1}\\cdot(x,y,z))$。\n- 在立方对称性下，$\\ell = 2$ 的流形分解为一个二重态和一个三重态子空间，分别对应于二维和三维的不可约表示。\n\n你的程序必须：\n1. 推导并实现从复球谐函数 $Y_{\\ell}^{m}$（其中 $\\ell = 1$ 和 $\\ell = 2$）到与单位球面上的笛卡尔坐标轴对齐的标准实立方谐函数的转换。角度使用弧度制。\n2. 通过计算每个计算出的谐函数 $h$ 与其目标笛卡尔坐标多项式形状 $t$ 之间的相关系数，数值上验证所得的实立方谐函数能够再现限制在单位球面上的预期笛卡尔形状：\n   $$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}},$$\n   其中 $\\Omega_k$ 是在单位球面上均匀分布的 $N$ 个采样点， $N$ 在测试套件中指定。单位球面上的目标形状应取为 $p_x \\sim x$、$p_y \\sim y$、$p_z \\sim z$、$d_{x^2-y^2} \\sim x^2 - y^2$、$d_{xy} \\sim x y$、$d_{xz} \\sim x z$、$d_{yz} \\sim y z$ 以及 $d_{z^2} \\sim 3 z^2 - 1$，所有这些都在单位球面上的 $(x,y,z)$ 处求值。\n3. 通过在 $d$ 轨道基上构建特定立方旋转的表示，并展示出对应于一个二维子空间和一个三维子空间的块结构，来证明 $\\ell = 2$ 集合在立方对称性下的正确简并结构。对于每个旋转 $R$，通过在采样点上使用离散内积将每个旋转后的基函数在原始基中展开，来计算 $5 \\times 5$ 的表示矩阵 $C_R$。验证二维和三维子空间之间的块间混合在数值上可以忽略不计。\n\n测试套件和参数：\n- 使用三组样本大小：\n  - 对于 $\\ell = 1$ 形状验证：$N = 4096$。\n  - 对于 $\\ell = 2$ 形状验证：$N = 8192$。\n  - 对于简并性检查：$N = 6000$。\n- 使用以下立方旋转（角度为弧度）：\n  - $R_z(\\pi/2)$: 绕 $z$ 轴旋转 $\\pi/2$。\n  - $R_x(\\pi/2)$: 绕 $x$ 轴旋转 $\\pi/2$。\n  - $R_y(\\pi/2)$: 绕 $y$ 轴旋转 $\\pi/2$。\n- 对于每次旋转，计算 $C_R$ 中混合二维子空间 $\\{d_{z^2}, d_{x^2-y^2}\\}$ 和三维子空间 $\\{d_{xy}, d_{yz}, d_{xz}\\}$ 的非对角块中系数的最大绝对值，并报告该最大值是否小于容差 $\\epsilon = 10^{-6}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含：\n  - $\\ell = 1$ 的三个相关系数：$[\\mathrm{corr}(p_x), \\mathrm{corr}(p_y), \\mathrm{corr}(p_z)]$，为浮点数。\n  - $\\ell = 2$ 的五个相关系数：$[\\mathrm{corr}(d_{x^2-y^2}), \\mathrm{corr}(d_{xy}), \\mathrm{corr}(d_{xz}), \\mathrm{corr}(d_{yz}), \\mathrm{corr}(d_{z^2})]$，为浮点数。\n  - 三个布尔值，分别指示对于 $R_z(\\pi/2)$、$R_x(\\pi/2)$ 和 $R_y(\\pi/2)$，简并性非对角块混合是否低于 $\\epsilon$。\n- 例如，输出格式应为：$[\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{float},\\text{boolean},\\text{boolean},\\text{boolean}]$。", "solution": "问题陈述在科学上是合理的、定义明确的，并提供了进行求解所需的所有必要信息。它解决的是计算材料科学中一个标准且重要的任务：原子轨道不同表示之间的转换及其性质的验证。\n\n该解决方案分三个阶段实现：首先，推导并实现从复球谐函数到轨道角动量量子数 $\\ell=1$ 和 $\\ell=2$ 的实立方谐函数的转换。其次，数值验证这些计算出的实谐函数与它们在单位球面上的著名笛卡尔坐标多项式形式之间的一致性。第三，展示 $\\ell=2$ 谐函数在立方对称性操作下的变换性质，从而揭示其简并子空间结构。\n\n**1. 从复球谐函数到实立方谐函数**\n\n对于中心势场，不含时薛定谔方程的角向部分由复球谐函数 $Y_{\\ell}^{m}(\\theta, \\phi)$ 求解。对于给定的量子数 $\\ell$，这些函数在球面上构成一个正交归一基，其中磁量子数 $m$ 的取值范围为 $-\\ell$ 到 $+\\ell$。它们由下式给出：\n$$Y_{\\ell}^{m}(\\theta, \\phi) = \\sqrt{\\frac{(2\\ell+1)}{4\\pi}\\frac{(\\ell-m)!}{(\\ell+m)!}} P_{\\ell}^{m}(\\cos\\theta) e^{im\\phi}$$\n其中 $P_{\\ell}^{m}$ 是连带勒让德多项式，相位因子 $e^{im\\phi}$ 使得当 $m \\neq 0$ 时函数为复数。Condon-Shortley 相位约定，即为 $m>0$ 包含一个因子 $(-1)^m$，是常用的约定，并且是 `scipy.special.sph_harm` 中的标准。在此约定下的一个关键性质是 $Y_{\\ell}^{-m} = (-1)^m (Y_{\\ell}^{m})^*$，其中 $*$ 表示复共轭。\n\n虽然 $Y_{\\ell}^{m}$ 是 $L_z$ 算符的本征函数，但它们不便于在笛卡尔空间中可视化电子密度，因为化学键是沿坐标轴排列的。实值谐函数是通过对 $Y_{\\ell}^{m}$ 和 $Y_{\\ell}^{-m}$ 进行线性组合来构造的，以消除虚部。实立方谐函数是这样一组特定的实轨道，它们被选择用来根据立方点群的不可约表示进行变换，从而与人们熟悉的 $p$ 轨道和 $d$ 轨道的形状相匹配。\n\n对于给定的 $\\ell$ 和 $m > 0$，可以形成两个实的、正交归一的函数：\n$$u_{\\ell,m} \\propto \\Re(Y_{\\ell}^{m})$$\n$$v_{\\ell,m} \\propto \\Im(Y_{\\ell}^{m})$$\n对于 $m=0$，$Y_{\\ell}^{0}$ 已经是实数。我们选择特定的组合和符号来匹配常规的笛卡尔坐标多项式形式 $x, y, z, xy, yz, xz, x^2-y^2, 3z^2-1$，这些形式在单位球面（$r=1$）上求值。使用 `scipy` 中 $Y_{\\ell}^{m}$ 的实现，以下定义产生的函数与目标多项式呈正相关：\n对于 $\\ell=1$（$p$ 轨道）：\n- $p_z = Y_1^0 \\propto \\cos\\theta \\equiv z$\n- $p_x = -\\sqrt{2} \\Re(Y_1^1) \\propto \\sin\\theta\\cos\\phi \\equiv x$\n- $p_y = -\\sqrt{2} \\Im(Y_1^1) \\propto \\sin\\theta\\sin\\phi \\equiv y$\n\n对于 $\\ell=2$（$d$ 轨道）：\n- $d_{z^2} = Y_2^0 \\propto 3\\cos^2\\theta-1 \\equiv 3z^2-1$\n- $d_{x^2-y^2} = \\sqrt{2} \\Re(Y_2^2) \\propto \\sin^2\\theta\\cos(2\\phi) \\equiv x^2-y^2$\n- $d_{xy} = \\sqrt{2} \\Im(Y_2^2) \\propto \\sin^2\\theta\\sin(2\\phi) \\equiv 2xy$\n- $d_{xz} = -\\sqrt{2} \\Re(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\cos\\phi \\equiv xz$\n- $d_{yz} = -\\sqrt{2} \\Im(Y_2^1) \\propto \\sin\\theta\\cos\\theta\\sin\\phi \\equiv yz$\n\n**2. 数值形状验证**\n\n为了验证这些构造的函数 $h$ 是否能再现目标笛卡尔坐标多项式形状 $t$，我们在单位球面上均匀分布的一组 $N$ 个采样点 $\\Omega_k$ 上计算它们的相关系数。为实现稳健且确定性的采样，我们采用斐波那契格点。相关系数定义为在采样点上求值的函数值向量之间的余弦相似度：\n$$\\mathrm{corr}(h,t) = \\frac{\\sum_{k=1}^{N} h(\\Omega_k)\\, t(\\Omega_k)}{\\sqrt{\\left(\\sum_{k=1}^{N} h(\\Omega_k)^2\\right)\\left(\\sum_{k=1}^{N} t(\\Omega_k)^2\\right)}}$$\n接近 $1.0$ 的值证实了计算出的谐函数具有正确的形状和方向。此检查对 $p$ 轨道使用 $N=4096$ 个点进行，对 $d$ 轨道使用 $N=8192$ 个点进行。\n\n**3. 立方对称性下的简并结构**\n\n在球对称环境中，五个 $d$ 轨道是简并的，但在晶体的较低对称性下，它们会分裂成不同的简并轨道集。在立方晶体场中，它们分裂成一个二维二重态，标记为 $e_g$（由 $\\{d_{z^2}, d_{x^2-y^2}\\}$ 张成），和一个三维三重态，标记为 $t_{2g}$（由 $\\{d_{xy}, d_{yz}, d_{xz}\\}$ 张成）。这意味着立方体的任何对称操作只会将一个 $e_g$ 轨道转换为其他 $e_g$ 轨道的线性组合，对于 $t_{2g}$ 轨道也是如此。两个子空间之间没有混合。\n\n我们通过计算来验证此性质。一个旋转 $R$ 通过变换其自变量来作用于函数 $f(\\vec{r})$：旋转后的函数为 $f'(\\vec{r}) = f(R^{-1}\\vec{r})$。我们可以将这个旋转后的函数 $f'_j$ 表示为原始基函数 $\\{f_i\\}$ 的线性组合：\n$$f'_j = \\sum_{i} (C_R)_{ij} f_i$$\n矩阵 $C_R$ 是旋转 $R$ 在基 $\\{f_i\\}$ 中的表示。其系数通过在 $N=6000$ 个采样点上使用离散内积将 $f'_j$ 投影到每个 $f_i$ 上来找到：$\\langle g, h \\rangle = \\sum_k g(\\Omega_k)h(\\Omega_k)$。这导出了矩阵方程 $B = G C_R$，其中 $G_{im} = \\langle f_i, f_m \\rangle$ 是格拉姆矩阵，$B_{ij} = \\langle f_i, f'_j \\rangle$。那么表示矩阵就是 $C_R = G^{-1}B$。\n\n对于我们按 $\\{d_{z^2}, d_{x^2-y^2}, d_{xy}, d_{yz}, d_{xz}\\}$ 顺序排列的基，矩阵 $C_R$ 应该是块对角的，其中有一个对应于 $e_g$ 子空间的 $2 \\times 2$ 块和一个对应于 $t_{2g}$ 子空间的 $3 \\times 3$ 块。\n$$ C_R \\approx \\begin{pmatrix}\nC_{e_g} & \\mathbf{0}_{2\\times3} \\\\\n\\mathbf{0}_{3\\times2} & C_{t_{2g}}\n\\end{pmatrix} $$\n我们计算绕 $x, y, z$ 轴旋转 $\\pi/2$ 时的 $C_R$。然后，我们找出非对角块（即 $2 \\times 3$ 和 $3 \\times 2$ 的零块）中元素的最大绝对值，并验证该值在数值上可以忽略（小于容差 $\\epsilon = 10^{-6}$），从而证实预期的简并结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef solve():\n    \"\"\"\n    Main function to perform all calculations and print the finale result.\n    \"\"\"\n    \n    # ------------------ Helper Functions ------------------\n    \n    def get_fibonacci_sphere_points(n_points):\n        \"\"\"\n        Generates uniformly distributed points on a unit sphere using a Fibonacci lattice.\n        \n        Args:\n            n_points (int): The number of points to generate.\n            \n        Returns:\n            tuple: Arrays for (theta, phi, x, y, z) coordinates of the points.\n        \"\"\"\n        indices = np.arange(0, n_points, dtype=float) + 0.5\n        \n        # Golden ratio\n        phi_const = (1 + np.sqrt(5)) / 2\n        \n        # Spherical coordinates\n        theta = np.arccos(1 - 2 * indices / n_points)\n        phi = (2 * np.pi * indices / phi_const) % (2 * np.pi)\n        \n        # Cartesian coordinates\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        \n        return theta, phi, x, y, z\n\n    def get_real_harmonics(l_val, theta, phi):\n        \"\"\"\n        Calculates real cubic harmonics from complex spherical harmonics.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            theta (np.ndarray): Array of polar angles.\n            phi (np.ndarray): Array of azimuthal angles.\n            \n        Returns:\n            dict: A dictionary mapping orbital names to their evaluated values.\n        \"\"\"\n        Y = {}\n        for m_val in range(-l_val, l_val + 1):\n            Y[m_val] = sph_harm(m_val, l_val, phi, theta)\n            \n        real_harmonics = {}\n        if l_val == 1:\n            real_harmonics['px'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['py'] = -np.sqrt(2) * Y[1].imag\n            real_harmonics['pz'] = Y[0].real\n        elif l_val == 2:\n            # Order for correlation check: d_x2-y2, d_xy, d_xz, d_yz, d_z2\n            real_harmonics['d_z2'] = Y[0].real\n            real_harmonics['d_x2-y2'] = np.sqrt(2) * Y[2].real\n            real_harmonics['d_xy'] = np.sqrt(2) * Y[2].imag\n            real_harmonics['d_xz'] = -np.sqrt(2) * Y[1].real\n            real_harmonics['d_yz'] = -np.sqrt(2) * Y[1].imag\n        return real_harmonics\n\n    def get_target_polynomials(l_val, x, y, z):\n        \"\"\"\n        Evaluates the target Cartesian polynomial shapes on the unit sphere.\n        \n        Args:\n            l_val (int): The angular momentum quantum number (1 or 2).\n            x, y, z (np.ndarray): Cartesian coordinates of sample points.\n            \n        Returns:\n            dict: A dictionary mapping target names to their evaluated values.\n        \"\"\"\n        targets = {}\n        if l_val == 1:\n            targets['px'] = x\n            targets['py'] = y\n            targets['pz'] = z\n        elif l_val == 2:\n            targets['d_z2'] = 3 * z**2 - 1\n            targets['d_x2-y2'] = x**2 - y**2\n            targets['d_xy'] = x * y\n            targets['d_xz'] = x * z\n            targets['d_yz'] = y * z\n        return targets\n\n    def calculate_correlation(h, t):\n        \"\"\"\n        Computes the correlation coefficient between two vectors of function values.\n        \n        Args:\n            h (np.ndarray): Values of the computed harmonic.\n            t (np.ndarray): Values of the target polynomial.\n            \n        Returns:\n            float: The correlation coefficient.\n        \"\"\"\n        return np.dot(h, t) / (np.linalg.norm(h) * np.linalg.norm(t))\n\n    def get_rotation_matrix(axis, angle):\n        \"\"\"\n        Constructs a 3D rotation matrix.\n        \n        Args:\n            axis (str): The axis of rotation ('x', 'y', or 'z').\n            angle (float): The angle of rotation in radians.\n        \n        Returns:\n            np.ndarray: The 3x3 rotation matrix.\n        \"\"\"\n        c, s = np.cos(angle), np.sin(angle)\n        if axis == 'x':\n            return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n        elif axis == 'y':\n            return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n        elif axis == 'z':\n            return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def cartesian_to_spherical(x, y, z):\n        \"\"\"\n        Converts Cartesian coordinates to spherical coordinates (ignoring radius).\n        \n        Args:\n            x, y, z (np.ndarray): Cartesian coordinate arrays.\n        \n        Returns:\n            tuple: Arrays for (theta, phi) angles.\n        \"\"\"\n        theta = np.arccos(np.clip(z, -1.0, 1.0))\n        phi = np.arctan2(y, x)\n        return theta, phi\n\n    # ------------------ Main Logic ------------------\n\n    results = []\n    \n    # Part 1: l=1 Shape Verification\n    N1 = 4096\n    theta1, phi1, x1, y1, z1 = get_fibonacci_sphere_points(N1)\n    real_harmonics_l1 = get_real_harmonics(1, theta1, phi1)\n    target_polys_l1 = get_target_polynomials(1, x1, y1, z1)\n    \n    p_orbitals_order = ['px', 'py', 'pz']\n    for orbital in p_orbitals_order:\n        corr = calculate_correlation(real_harmonics_l1[orbital], target_polys_l1[orbital])\n        results.append(corr)\n\n    # Part 2: l=2 Shape Verification\n    N2 = 8192\n    theta2, phi2, x2, y2, z2 = get_fibonacci_sphere_points(N2)\n    real_harmonics_l2 = get_real_harmonics(2, theta2, phi2)\n    target_polys_l2 = get_target_polynomials(2, x2, y2, z2)\n    \n    d_orbitals_corr_order = ['d_x2-y2', 'd_xy', 'd_xz', 'd_yz', 'd_z2']\n    for orbital in d_orbitals_corr_order:\n        corr = calculate_correlation(real_harmonics_l2[orbital], target_polys_l2[orbital])\n        results.append(corr)\n\n    # Part 3: l=2 Degeneracy Structure Verification\n    N3 = 6000\n    TOLERANCE = 1e-6\n    theta3, phi3, x3, y3, z3 = get_fibonacci_sphere_points(N3)\n    \n    # Basis order for degeneracy check: e_g {d_z2, d_x2-y2}, t_2g {d_xy, d_yz, d_xz}\n    d_degen_order = ['d_z2', 'd_x2-y2', 'd_xy', 'd_yz', 'd_xz']\n    harmonics_l2_degen = get_real_harmonics(2, theta3, phi3)\n    \n    f_basis = np.array([harmonics_l2_degen[orb] for orb in d_degen_order]).T\n\n    # Gram matrix G = F^T F\n    G = f_basis.T @ f_basis\n    G_inv = np.linalg.inv(G)\n\n    initial_coords = np.vstack([x3, y3, z3])\n\n    rot_matrices = {\n        'Rz': get_rotation_matrix('z', np.pi/2),\n        'Rx': get_rotation_matrix('x', np.pi/2),\n        'Ry': get_rotation_matrix('y', np.pi/2),\n    }\n\n    for R_matrix in rot_matrices.values():\n        R_inv = R_matrix.T\n        rotated_coords = R_inv @ initial_coords\n        rx, ry, rz = rotated_coords[0,:], rotated_coords[1,:], rotated_coords[2,:]\n        \n        r_theta, r_phi = cartesian_to_spherical(rx, ry, rz)\n        \n        rot_d_harmonics = get_real_harmonics(2, r_theta, r_phi)\n        f_prime_basis = np.array([rot_d_harmonics[orb] for orb in d_degen_order]).T\n\n        # Matrix B = F^T F'\n        B = f_basis.T @ f_prime_basis\n        \n        # Representation matrix C_R = G^-1 B\n        C_R = G_inv @ B\n\n        # Check off-block elements\n        off_block_eg_t2g = C_R[0:2, 2:5]\n        off_block_t2g_eg = C_R[2:5, 0:2]\n\n        max_off_diag = max(np.abs(off_block_eg_t2g).max(), np.abs(off_block_t2g_eg).max())\n        results.append(max_off_diag < TOLERANCE)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3433597"}, {"introduction": "材料中的量子态，尤其是由晶体缺陷引入的量子态，通常是不同角动量特征的复杂叠加。一种强大的分析技术是通过将这些态投影到类原子轨道基上进行分解。在本练习中，您将通过计算一个模型缺陷波函数在 s-like ($\\ell=0$)、p-like ($\\ell=1$) 和 d-like ($\\ell=2$) 通道上的投影来对其进行分析 [@problem_id:3433580]。这项动手任务演示了如何量化电子态的性质，并观察其在静水压力等外部刺激下的演变。", "problem": "在计算材料科学中，宽带隙氧化物中点缺陷附近的局域电子态，可以通过在类原子基组中展开，以其角动量成分来表征。假设一个单粒子 Kohn–Sham (KS) 缺陷态，局域在缺陷位置周围，并在一个以缺陷为中心、半径为 $R$ 的选定球形区域内进行探测。该态的角向依赖性可以用球谐函数基 $Y_{\\ell m}(\\theta,\\phi)$ 来表示，而径向分量则用依赖于压力的衰减函数来建模。利用球谐函数的正交归一性作为基本依据，以及球坐标下不含时薛定谔方程的变量分离法，推导出一个投影方案，以识别球内缺陷态的主要局域 $(\\ell,m)$ 特征，并追踪其在静水压力下的演化。\n\n给定球内一个综合但具有物理动机的模型波函数：\n$$\n\\psi(\\mathbf{r};P) \\equiv \\psi(r,\\theta,\\phi;P) = \\sum_{\\ell=0}^{2} A_{\\ell 0}(P)\\, f_{\\ell}(r;P)\\, Y_{\\ell 0}(\\theta,\\phi),\n$$\n其中仅保留 $m=0$ 的分量，以表示沿 $z$ 轴的对称性保持缺陷。径向函数为\n$$\nf_0(r;P) = N_0(P)\\, e^{-r/a(P)},\\quad\nf_1(r;P) = N_1(P)\\, r\\, e^{-r/a(P)},\\quad\nf_2(r;P) = N_2(P)\\, r^2\\, e^{-r/a(P)},\n$$\n其中，依赖于压力的衰减长度为\n$$\na(P) = \\frac{a_0}{1+\\beta P}.\n$$\n取 $a_0 = 1.5$ 埃（angstrom），$\\beta = 0.02$ 每吉帕斯卡（per gigapascal），因此 $P$ 的单位是吉帕斯卡，$a(P)$ 的单位是埃。归一化常数 $N_{\\ell}(P)$ 的选取使得每个通道的径向测度在全空间上的积分为1，\n$$\n\\int_{0}^{\\infty} r^2\\, f_{\\ell}(r;P)\\, dr = 1,\n$$\n这意味着\n$$\nN_0(P) = \\frac{1}{2\\,a(P)^3},\\quad N_1(P) = \\frac{1}{6\\,a(P)^4},\\quad N_2(P) = \\frac{1}{24\\,a(P)^5}.\n$$\n未归一化的、依赖于压力的角向振幅为\n$$\n\\tilde{A}_{00}(P) = \\cos\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{10}(P) = \\sin\\big(\\theta(P)\\big),\\quad\n\\tilde{A}_{20}(P) = \\gamma \\max(P,0),\n$$\n其中\n$$\n\\theta(P) = \\theta_0 + k P,\\quad \\theta_0 = \\frac{\\pi}{8},\\quad k = \\frac{\\pi}{90},\\quad \\gamma = 0.03,\n$$\n其中角度单位为弧度，压力 $P$ 的单位为吉帕斯卡。然后将振幅归一化为单位范数，\n$$\nA_{\\ell 0}(P) = \\frac{\\tilde{A}_{\\ell 0}(P)}{\\sqrt{\\sum_{\\ell'=0}^{2} \\tilde{A}_{\\ell' 0}(P)^2}}.\n$$\n\n从球谐函数的正交归一性出发，\n$$\n\\int Y_{\\ell m}^{*}(\\theta,\\phi)\\, Y_{\\ell' m'}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{m m'},\n$$\n推导半径为 $R$ 的有限球体内的投影系数表达式，\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 \\sin\\theta\\, d\\theta\\, d\\phi\\, dr,\n$$\n并展示由于角度上的正交归一性，该表达式如何简化为一个角向振幅与一个径向积分的乘积。对于给定的 $f_{\\ell}$，计算径向累积因子\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr,\n$$\n并用它们来评估\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P).\n$$\n将球内的通道权重定义为\n$$\nw_{\\ell 0}(R,P) = \\frac{\\left|C_{\\ell 0}(R,P)\\right|^2}{\\sum_{\\ell'=0}^{2}\\left|C_{\\ell' 0}(R,P)\\right|^2}.\n$$\n你的任务是实现一个程序，对于每个指定的测试用例 $(R,P)$，计算归一化的权重 $w_{00}(R,P)$、$w_{10}(R,P)$、$w_{20}(R,P)$，并通过最大权重识别出占主导地位的 $(\\ell,m)$ 通道。将报告的权重四舍五入到 $6$ 位小数。将占主导地位的数对报告为整数 $(\\ell,m)$。\n\n物理单位：输入压力 $P$ 的单位为吉帕斯卡，半径 $R$ 的单位为埃。计算出的权重是无量纲的。\n\n角度单位：所有三角函数必须使用弧度。\n\n用于覆盖不同条件的测试套件：\n- 情况 1：$R=4.0$ 埃， $P=0$ 吉帕斯卡。\n- 情况 2：$R=4.0$ 埃， $P=10$ 吉帕斯卡。\n- 情况 3：$R=4.0$ 埃， $P=20$ 吉帕斯卡。\n- 情况 4：$R=2.0$ 埃， $P=10$ 吉帕斯卡。\n- 情况 5：$R=4.0$ 埃， $P=-5$ 吉帕斯卡。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个结果是 $[\\ell_{\\mathrm{dom}},m_{\\mathrm{dom}},w_{00},w_{10},w_{20}]$ 形式的列表，权重按 $[\\ell=0,\\ell=1,\\ell=2]$ 的顺序列出。例如，一个有效的输出格式是\n$[[0,0,0.750000,0.200000,0.050000],[\\dots],\\dots]$。", "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且定义明确的。在计算材料科学和量子力学的背景下，所有提供的数据、定义和约束都是一致且具有物理意义的。任务是推导并实现一个投影方案，以分析一个模型缺陷态波函数。\n\n### 投影系数 $C_{\\ell 0}(R,P)$ 的推导\n\n投影系数 $C_{\\ell 0}(R,P)$ 量化了 $(\\ell, m=0)$ 角动量通道在半径为 $R$ 的球体内对总波函数 $\\psi(\\mathbf{r};P)$ 的贡献。它通过波函数与相应球谐函数 $Y_{\\ell 0}(\\theta,\\phi)$ 的内积在球体积上积分来定义。\n\n其定义如下：\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\psi(r,\\theta,\\phi;P)\\, Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\n其中立体角元为 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$。\n\n提供的模型波函数是基函数的线性组合，每个基函数都是径向部分 $f_{\\ell'}(r;P)$ 和角向部分 $Y_{\\ell' 0}(\\theta,\\phi)$ 的乘积：\n$$\n\\psi(r,\\theta,\\phi;P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi)\n$$\n将 $\\psi$ 的这个表达式代入 $C_{\\ell 0}(R,P)$ 的定义中：\n$$\nC_{\\ell 0}(R,P) = \\int_{0}^{R}\\int_{\\Omega} \\left( \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P)\\, f_{\\ell'}(r;P)\\, Y_{\\ell' 0}(\\theta,\\phi) \\right) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, r^2 d\\Omega\\, dr\n$$\n由于积分和求和算符是线性的，它们的顺序可以互换。系数 $A_{\\ell' 0}(P)$ 和径向函数 $f_{\\ell'}(r;P)$ 与角变量 $(\\theta,\\phi)$ 无关，可以从角向积分中提取出来：\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\left( \\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega \\right) dr\n$$\n推导的核心在于球谐函数的正交归一性：\n$$\n\\int_{\\Omega} Y_{\\ell' m'}(\\theta,\\phi) Y_{\\ell m}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\\delta_{mm'}\n$$\n在我们的例子中，$m=m'=0$，因此积分简化为：\n$$\n\\int_{\\Omega} Y_{\\ell' 0}(\\theta,\\phi) Y_{\\ell 0}^{*}(\\theta,\\phi)\\, d\\Omega = \\delta_{\\ell\\ell'}\n$$\n（注意，对于 $m=0$，球谐函数是实数，所以 $Y_{\\ell 0}^{*} = Y_{\\ell 0}$。）\n\n将克罗内克（Kronecker）$\\delta$ 函数 $\\delta_{\\ell\\ell'}$ 代回 $C_{\\ell 0}(R,P)$ 的表达式中：\n$$\nC_{\\ell 0}(R,P) = \\sum_{\\ell'=0}^{2} A_{\\ell' 0}(P) \\int_{0}^{R} f_{\\ell'}(r;P)\\, r^2 \\delta_{\\ell\\ell'} dr\n$$\n克罗内克 $\\delta$ 函数仅在 $\\ell'=\\ell$ 时非零（等于 $1$）。这个性质将对 $\\ell'$ 的求和坍缩为对应于投影的特定 $\\ell$ 的单个项：\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\int_{0}^{R} f_{\\ell}(r;P)\\, r^2 dr\n$$\n剩下的积分恰好是径向累积因子 $S_{\\ell}(R,P)$ 的定义：\n$$\nS_{\\ell}(R,P) \\equiv \\int_{0}^{R} r^2\\, f_{\\ell}(r;P)\\, dr\n$$\n因此，我们得到了投影系数的最终表达式，它分离了角向和径向的贡献：\n$$\nC_{\\ell 0}(R,P) = A_{\\ell 0}(P)\\, S_{\\ell}(R,P)\n$$\n这表明投影操作有效地分离出特定通道的振幅 $A_{\\ell 0}(P)$，并用包含在半径为 $R$ 的球内的径向密度 $r^2|f_\\ell(r;P)|$ 的分数对其进行加权。\n\n### 径向累积因子 $S_{\\ell}(R,P)$ 的推导\n\n必须计算每个通道 $\\ell \\in \\{0, 1, 2\\}$ 的径向累积因子 $S_{\\ell}(R,P)$。径向函数为 $f_0(r;P) = N_0(P) e^{-r/a(P)}$、$f_1(r;P) = N_1(P) r e^{-r/a(P)}$ 和 $f_2(r;P) = N_2(P) r^2 e^{-r/a(P)}$。\n我们引入变量 $x = r/a(P)$，其中 $a(P)$ 是依赖于压力的衰减长度。$S_{\\ell}(R,P)$ 的积分可以用 $x$ 来表示。\n\n对于 $\\ell=0$：\n$$S_0(R,P) = \\int_{0}^{R} r^2 N_0(P) e^{-r/a(P)} dr = N_0(P) \\int_{0}^{R} r^2 e^{-r/a(P)} dr$$\n当 $N_0(P) = 1/(2a(P)^3)$，并代入 $r=xa(P)$, $dr=a(P)dx$：\n$$S_0(R,P) = \\frac{1}{2a(P)^3} \\int_{0}^{R/a(P)} (xa(P))^2 e^{-x} a(P)dx = \\frac{1}{2} \\int_{0}^{R/a(P)} x^2 e^{-x} dx$$\n这个积分与下不完全伽马函数 $\\gamma(s,z) = \\int_0^z t^{s-1}e^{-t}dt$ 相关。在这里，$s=3$ 且 $z=R/a(P)$。该积分为 $\\gamma(3, R/a(P))$。对应的正则化下不完全伽马函数是 $P(s,z) = \\gamma(s,z)/\\Gamma(s)$。由于 $\\Gamma(3)=2! = 2$，我们得到 $S_0(R,P) = P(3, R/a(P))$。\n\n类似地，对于 $\\ell=1$ 和 $\\ell=2$，我们分别对 $r^3$ 和 $r^4$ 进行积分：\n$$S_1(R,P) = \\frac{1}{6} \\int_{0}^{R/a(P)} x^3 e^{-x} dx = \\frac{\\gamma(4, R/a(P))}{\\Gamma(4)} = P(4, R/a(P))$$\n$$S_2(R,P) = \\frac{1}{24} \\int_{0}^{R/a(P)} x^4 e^{-x} dx = \\frac{\\gamma(5, R/a(P))}{\\Gamma(5)} = P(5, R/a(P))$$\n对于整数 $s$，$P(s,z) = 1 - e^{-z}\\sum_{k=0}^{s-1} \\frac{z^k}{k!}$。令 $z=R/a(P)$，我们得到显式公式：\n$$S_0(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2}\\right)$$\n$$S_1(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}\\right)$$\n$$S_2(R,P) = 1 - e^{-z} \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\\right)$$\n这些公式可以直接实现，也可以使用标准库中的正则化不完全伽马函数来计算。\n\n### 计算策略\n\n对于给定的输入对 $(R,P)$，计算通道权重的总体算法如下：\n1.  定义物理常数 $a_0=1.5$、$\\beta=0.02$、$\\theta_0=\\pi/8$、$k=\\pi/90$ 和 $\\gamma=0.03$。\n2.  计算依赖于压力的衰减长度 $a(P) = a_0 / (1+\\beta P)$。\n3.  计算依赖于压力的角度 $\\theta(P) = \\theta_0 + kP$。\n4.  计算未归一化的角向振幅：$\\tilde{A}_{00}(P) = \\cos(\\theta(P))$、$\\tilde{A}_{10}(P) = \\sin(\\theta(P))$ 和 $\\tilde{A}_{20}(P) = \\gamma \\max(P,0)$。\n5.  归一化振幅：$A_{\\ell 0}(P) = \\tilde{A}_{\\ell 0}(P) / \\sqrt{\\sum_{\\ell'} \\tilde{A}_{\\ell' 0}(P)^2}$。\n6.  计算无量纲变量 $z = R/a(P)$。\n7.  使用上面推导的公式（或等效的库函数）计算径向累积因子 $S_0(R,P)$、$S_1(R,P)$ 和 $S_2(R,P)$。\n8.  计算投影系数 $C_{\\ell 0}(R,P) = A_{\\ell 0}(P) \\times S_{\\ell}(R,P)$，其中 $\\ell \\in \\{0, 1, 2\\}$。\n9.  计算系数的模平方 $|C_{\\ell 0}(R,P)|^2$。\n10. 计算通道权重 $w_{\\ell 0}(R,P) = |C_{\\ell 0}(R,P)|^2 / \\sum_{\\ell'} |C_{\\ell' 0}(R,P)|^2$。\n11. 通过找到使权重 $w_{\\ell 0}$ 最大化的索引 $\\ell$ 来确定主导通道 $(\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}})$。磁量子数 $m$ 固定为 $m_{\\mathrm{dom}}=0$。\n12. 按要求格式化结果：$[\\ell_{\\mathrm{dom}}, m_{\\mathrm{dom}}, w_{00}, w_{10}, w_{20}]$，权重四舍五入到6位小数。\n\n将对问题陈述中指定的每个测试用例实施此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammainc\n\ndef solve():\n    \"\"\"\n    Computes and identifies the dominant angular momentum channel for a model\n    defect state under varying pressure and analysis radius.\n    \"\"\"\n    \n    # Define physical constants and parameters from the problem statement.\n    a0 = 1.5      # angstrom\n    beta = 0.02   # per GPa\n    theta0 = np.pi / 8.0\n    k = np.pi / 90.0\n    gamma = 0.03\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R in angstrom, P in gigapascal)\n        (4.0, 0.0),\n        (4.0, 10.0),\n        (4.0, 20.0),\n        (2.0, 10.0),\n        (4.0, -5.0),\n    ]\n\n    results_str = []\n    for R, P in test_cases:\n        # Step 1: Calculate pressure-dependent parameters\n        a_P = a0 / (1.0 + beta * P)\n        theta_P = theta0 + k * P\n\n        # Step 2: Calculate unnormalized angular amplitudes\n        A_tilde_00 = np.cos(theta_P)\n        A_tilde_10 = np.sin(theta_P)\n        A_tilde_20 = gamma * max(P, 0.0)\n        \n        # Step 3: Normalize the angular amplitudes\n        amplitudes_tilde = np.array([A_tilde_00, A_tilde_10, A_tilde_20])\n        norm_A = np.sqrt(np.sum(np.square(amplitudes_tilde)))\n        amplitudes_A = amplitudes_tilde / norm_A if norm_A > 0 else np.zeros(3)\n\n        # Step 4: Calculate radial accumulation factors S_l(R,P)\n        # These are regularized lower incomplete gamma functions P(s, z)\n        # where s = l + n + 1 and z = R/a(P).\n        # For f_l(r) ~ r^l, the integral is over r^2 * f_l(r) ~ r^(l+2).\n        # So we have integrals over r^2, r^3, r^4 corresponding to s=3,4,5.\n        z = R / a_P\n        S_factors = np.array([\n            gammainc(3, z),  # S_0(R,P) for l=0\n            gammainc(4, z),  # S_1(R,P) for l=1\n            gammainc(5, z)   # S_2(R,P) for l=2\n        ])\n\n        # Step 5: Calculate projection coefficients C_l0(R,P)\n        coeffs_C = amplitudes_A * S_factors\n\n        # Step 6: Calculate channel weights w_l0(R,P)\n        squared_C = np.square(coeffs_C)\n        sum_squared_C = np.sum(squared_C)\n        \n        if sum_squared_C > 1e-12: # Avoid division by zero\n            weights = squared_C / sum_squared_C\n        else:\n            weights = np.array([1.0/3.0, 1.0/3.0, 1.0/3.0]) # Degenerate case, e.g. R=0\n\n        w00, w10, w20 = weights\n        \n        # Step 7: Identify the dominant channel\n        l_dom = np.argmax(weights)\n        m_dom = 0\n        \n        # Step 8: Format the output for the current case\n        result_str = f\"[{l_dom},{m_dom},{w00:.6f},{w10:.6f},{w20:.6f}]\"\n        results_str.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3433580"}, {"introduction": "任何实际的模拟都依赖于近似，而电子结构理论中的一个关键近似是用于表示波函数或密度的基组的截断。本实践模拟了每位计算科学家都必须执行的一项至关重要的收敛性测试，以确保其结果的可靠性。您将探索当改变基组中所包含的最大角动量 $l_{\\max}$ 时，计算出的总能量和原子间力如何变化 [@problem_id:3433593]。这个练习让您能够直接洞察计算精度与成本之间的权衡，并解释了误差是如何因忽略高阶多极矩而产生的。", "problem": "在一个球形区域内，一项使用增广基的计算材料科学计算通过一个截断的球谐函数级数来近似全电子密度。考虑一个以原点为中心、半径为 $R$ 的增广球，其局域赝密度被建模为一个有限球谐展开，\n$$\n\\rho(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{L_{\\text{tot}}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi),\n$$\n其中 $r$ 是径向坐标，$\\theta$ 是极角，$\\phi$ 是方位角（所有角度均以弧度为单位）。函数 $Y_{l}^{m}(\\theta,\\phi)$ 表示实值球谐函数，它们由复球谐函数构建而来：当 $m>0$ 时取 $\\sqrt{2}\\,\\mathrm{Re}\\{Y_{l}^{m}\\}$，当 $m<0$ 时取 $\\sqrt{2}\\,\\mathrm{Im}\\{Y_{l}^{|m|}\\}$，当 $m=0$ 时取 $Y_{l}^{0}$。系数 $a_{l m}$ 是实常数。在对增广球的角动量截断 $l_{\\max}$ 进行的收敛性研究中，我们冻结平面波截断和 $\\mathbf{k}$ 点网格，仅改变 $l_{\\max}$，这将密度截断为\n$$\n\\rho^{(l_{\\max})}(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{l_{\\max}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi).\n$$\n\n由外部施加的解析势 $V_{\\text{ext}}(\\mathbf{r})$ 引起的增广球的总能量贡献定义为\n$$\nE\\left[l_{\\max}\\right] \\equiv \\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr,\n$$\n相应的力矢量为\n$$\n\\mathbf{F}\\left[l_{\\max}\\right] \\equiv -\\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, \\nabla V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr.\n$$\n\n你的目标是设计并实现一个收敛性研究，通过冻结所有其他数值参数（平面波截断和 $\\mathbf{k}$ 点网格在概念上是固定的，不进入此计算），来分离增广球的 $l_{\\max}$ 对 $E\\left[l_{\\max}\\right]$ 和 $\\mathbf{F}\\left[l_{\\max}\\right]$ 的影响。将残差解释为源于所选 $l_{\\max}$ 之外缺失的多极矩 $Y_{l}^{m}(\\hat{\\mathbf{r}})$。\n\n对该模型使用以下固定的、科学上合理的参数集：\n- 增广球半径 $R = 1.5$。\n- 径向衰减参数 $\\alpha = 3.0$。\n- 为子集 $\\{(l,m)\\}$ 给出的非零实球谐系数 $a_{l m}$：\n  - $(0,0): a_{00} = 1.0$,\n  - $(1,0): a_{10} = 0.6$, $(1,1): a_{11} = 0.3$,\n  - $(2,0): a_{20} = 0.4$, $(2,2): a_{22} = 0.25$,\n  - $(3,0): a_{30} = 0.35$, $(3,3): a_{33} = 0.20$,\n  - $(4,0): a_{40} = 0.30$,\n  - $(5,0): a_{50} = 0.25$。\n- 外势是立体谐波（笛卡尔坐标 $(x,y,z)$ 的多项式，其中 $x = r\\sin\\theta\\cos\\phi$, $y = r\\sin\\theta\\sin\\phi$, $z = r\\cos\\theta$）的有限组合：\n  $$\n  V_{\\text{ext}}(\\mathbf{r}) = A_{1}\\, z + A_{2}\\, \\left(3 z^{2} - r^{2}\\right) + A_{3}\\, xyz + A_{4}\\, \\left(x^{3} - 3 x y^{2}\\right) + A_{5}\\, \\left(35 z^{4} - 30 z^{2} r^{2} + 3 r^{4}\\right) + A_{6}\\, \\left(x^{5} - 10 x^{3} y^{2} + 5 x y^{4}\\right),\n  $$\n  固定振幅为 $A_{1} = 0.2$, $A_{2} = 0.05$, $A_{3} = 0.01$, $A_{4} = 0.02$, $A_{5} = 0.005$, $A_{6} = 0.003$。\n\n程序必须通过在球上使用可分离求积进行数值积分来计算 $E\\left[l_{\\max}\\right]$ 和 $\\mathbf{F}\\left[l_{\\max}\\right]$：\n- 在 $r \\in [0,R]$ 上的径向积分，使用具有 $N_{r}$ 个点的高斯-勒让德求积。\n- 通过替换 $u = \\cos\\theta \\in [-1,1]$ 进行极向积分，使用具有 $N_{\\theta}$ 个点的高斯-勒让德求积，因此 $r^{2}\\sin\\theta\\, d\\theta$ 变为 $r^{2}\\, du$。\n- 在 $\\phi \\in [0,2\\pi)$ 上的方位角积分，使用均匀的 $N_{\\phi}$ 点梯形法则。\n\n设置 $N_{r} = 48$，$N_{\\theta} = 48$ 和 $N_{\\phi} = 48$。\n\n令完全收敛的参考值对应于 $L_{\\text{tot}} = 5$。对于给定测试套件中的每个 $l_{\\max}$，计算截断能量 $E\\left[l_{\\max}\\right]$ 和力 $\\mathbf{F}\\left[l_{\\max}\\right]$，并报告由以下公式定义的残差\n$$\n\\Delta E\\left[l_{\\max}\\right] \\equiv E\\left[L_{\\text{tot}}\\right] - E\\left[l_{\\max}\\right], \\quad\n\\Delta F\\left[l_{\\max}\\right] \\equiv \\left\\|\\mathbf{F}\\left[L_{\\text{tot}}\\right] - \\mathbf{F}\\left[l_{\\max}\\right]\\right\\|_{2}.\n$$\n\n解释要求：程序设计必须通过选择 $V_{\\text{ext}}(\\mathbf{r})$ 和 $\\rho(r,\\theta,\\phi)$ 的角向结构来明确表明，任何非零的 $\\Delta E\\left[l_{\\max}\\right]$ 和 $\\Delta F\\left[l_{\\max}\\right]$ 都源于 $l > l_{\\max}$ 的被省略的多极分量 $Y_{l}^{m}$，这些分量与 $V_{\\text{ext}}(\\mathbf{r})$ 或其梯度的相应立体谐波分量耦合。\n\n测试套件：\n- 评估 $l_{\\max} \\in \\{0,1,2,3,4,5\\}$ 的残差。\n\n角度单位说明：所有角量均以弧度处理。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例结果是一个包含 $\\Delta E\\left[l_{\\max}\\right]$ 和 $\\Delta F\\left[l_{\\max}\\right]$ 的双元素列表。例如，打印的输出必须如下所示\n$$\n\\left[ [\\Delta E(0), \\Delta F(0)], [\\Delta E(1), \\Delta F(1)], \\dots, [\\Delta E(5), \\Delta F(5)] \\right].\n$$\n无需物理单位；将所有报告值视为无量纲的模型量。", "solution": "用户希望我解决一个计算问题。\n\n### **问题验证**\n\n我将根据要求的协议开始验证问题陈述。\n\n#### **步骤1：提取已知条件**\n\n*   **赝密度模型 ($\\rho$)**:\n    $$\n    \\rho(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{L_{\\text{tot}}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi)\n    $$\n    其中 $L_{\\text{tot}} = 5$。$Y_{l}^{m}$ 是实值球谐函数。\n*   **截断的赝密度 ($\\rho^{(l_{\\max})}$)**:\n    $$\n    \\rho^{(l_{\\max})}(r,\\theta,\\phi) \\equiv \\sum_{l=0}^{l_{\\max}}\\sum_{m} a_{l m}\\, r^{l}\\, \\mathrm{e}^{-\\alpha r}\\, Y_{l}^{m}(\\theta,\\phi)\n    $$\n*   **能量 ($E$) 和力 ($\\mathbf{F}$)**:\n    $$\n    E\\left[l_{\\max}\\right] \\equiv \\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr\n    $$\n    $$\n    \\mathbf{F}\\left[l_{\\max}\\right] \\equiv -\\int_{0}^{R}\\int_{0}^{\\pi}\\int_{0}^{2\\pi} \\rho^{(l_{\\max})}(r,\\theta,\\phi)\\, \\nabla V_{\\text{ext}}(\\mathbf{r})\\, r^{2}\\sin\\theta\\, d\\phi\\, d\\theta\\, dr\n    $$\n*   **残差 ($\\Delta E, \\Delta F$)**:\n    $$\n    \\Delta E\\left[l_{\\max}\\right] \\equiv E\\left[L_{\\text{tot}}\\right] - E\\left[l_{\\max}\\right]\n    $$\n    $$\n    \\Delta F\\left[l_{\\max}\\right] \\equiv \\left\\|\\mathbf{F}\\left[L_{\\text{tot}}\\right] - \\mathbf{F}\\left[l_{\\max}\\right]\\right\\|_{2}\n    $$\n*   **模型参数**:\n    *   增广半径: $R = 1.5$。\n    *   径向衰减参数: $\\alpha = 3.0$。\n    *   非零系数 $a_{l m}$: $\\{(0,0): 1.0; (1,0): 0.6; (1,1): 0.3; (2,0): 0.4; (2,2): 0.25; (3,0): 0.35; (3,3): 0.20; (4,0): 0.30; (5,0): 0.25\\}$。\n*   **外势 ($V_{\\text{ext}}$)**:\n    $$\n    V_{\\text{ext}}(\\mathbf{r}) = A_{1}z + A_{2}(3z^{2}-r^{2}) + A_{3}xyz + A_{4}(x^{3}-3xy^{2}) + A_{5}(35z^{4}-30z^{2}r^{2}+3r^{4}) + A_{6}(x^{5}-10x^{3}y^{2}+5xy^{4})\n    $$\n    *   振幅: $A_{1}=0.2, A_{2}=0.05, A_{3}=0.01, A_{4}=0.02, A_{5}=0.005, A_{6}=0.003$。\n*   **数值积分**:\n    *   径向 ($r \\in [0,R]$)：$N_{r}=48$ 点高斯-勒让德求积。\n    *   极向 ($u=\\cos\\theta \\in [-1,1]$)：$N_{\\theta}=48$ 点高斯-勒让德求积。\n    *   方位角 ($\\phi \\in [0,2\\pi)$)：$N_{\\phi}=48$ 点梯形法则。\n*   **测试套件**: $l_{\\max} \\in \\{0, 1, 2, 3, 4, 5\\}$。\n*   **角度单位**: 弧度。\n\n#### **步骤2：使用提取的已知条件进行验证**\n\n1.  **科学依据**: 该问题植根于计算材料科学的标准方法，特别是像投影缀加波 (PAW) 方法这样的密度泛函理论实现。对电荷密度使用球谐展开和对势使用立体谐波是该领域的基础。这在科学上是合理的。\n2.  **适定性**: 该问题提供了所有必要的函数、参数和数值程序，以得出一个唯一的、可计算的解。任务是数值计算明确定义的定积分。这是适定的。\n3.  **客观性**: 问题陈述使用了精确的数学定义和客观语言，没有主观解释的余地。这是客观的。\n4.  **不完整或矛盾的设置**: 所有常数和函数都已完全指定。实球谐函数的定义已提供，并且是一个标准约定。数值积分方案已明确描述。没有矛盾。\n5.  **不切实际或不可行**: 物理参数的量级是合理的。计算任务，即在 $48 \\times 48 \\times 48$ 网格上的三维数值求积，在计算上是可行的。\n\n#### **步骤3：结论和行动**\n\n问题是有效的。这是一个定义明确、科学合理的计算物理问题，可以通过算法解决。我将继续进行解答。\n\n### **解答设计**\n\n问题的核心是通过对赝密度 $\\rho^{(l_{\\max})}$ 与势 $V_{\\text{ext}}$ 及其梯度 $\\nabla V_{\\text{ext}}$ 的乘积分别在球体积上进行数值积分来计算能量 $E[l_{\\max}]$ 和力 $\\mathbf{F}[l_{\\max}]$。然后分析这些量相对于角动量截断 $l_{\\max}$ 的收敛性。\n\n#### **1. 数学公式**\n\n能量和力的积分在球坐标 $(r, \\theta, \\phi)$ 中定义。体积元是 $d\\tau = r^2 \\sin\\theta \\, dr d\\theta d\\phi$。问题指定了一个可分离的数值求积方案。\n\n*   **径向积分**: 对于在 $[0, R]$ 上的函数 $f(r)$，我们使用高斯-勒让德求积。标准区间是 $[-1, 1]$。对于 $t \\in [-1, 1]$，线性映射 $r(t) = \\frac{R}{2}(t+1)$ 给出 $dr = \\frac{R}{2}dt$。如果 $\\{t_i, w_i^{\\text{GL}}\\}$ 是标准高斯-勒让德点和权重，则积分近似为：\n    $$\n    \\int_0^R f(r) dr \\approx \\sum_{i=1}^{N_r} f\\left(\\frac{R}{2}(t_i+1)\\right) \\frac{R}{2} w_i^{\\text{GL}}\n    $$\n*   **极向积分**: 对于在 $[0, \\pi]$ 上的函数 $g(\\theta)$，指定的代换是 $u = \\cos\\theta$，因此 $du = -\\sin\\theta d\\theta$。积分变为 $\\int_{-1}^{1} g(\\arccos u) du$。这直接适用于高斯-勒让德求积：\n    $$\n    \\int_0^\\pi g(\\theta) \\sin\\theta d\\theta = \\int_{-1}^1 g(\\arccos u) du \\approx \\sum_{j=1}^{N_\\theta} g(\\arccos u_j) w_j^{\\text{GL}}\n    $$\n*   **方位角积分**: 对于在 $[0, 2\\pi]$ 上的函数 $h(\\phi)$，$N_\\phi$ 点梯形法则使用均匀点 $\\phi_k = k \\frac{2\\pi}{N_\\phi}$ (其中 $k=0, \\dots, N_\\phi-1$)，权重为常数 $\\Delta\\phi = \\frac{2\\pi}{N_\\phi}$。\n    $$\n    \\int_0^{2\\pi} h(\\phi) d\\phi \\approx \\sum_{k=0}^{N_\\phi-1} h(\\phi_k) \\Delta\\phi\n    $$\n\n综合这些，一个完整的三维积分变成了一个在网格点 $(r_i, \\theta_j, \\phi_k)$ 上的三重求和，并带有一个复合权重。\n$$\n\\text{Integral} \\approx \\sum_{i,j,k} \\text{Integrand}(r_i, \\theta_j, \\phi_k) \\cdot \\left(r_i^2 \\cdot \\left(\\frac{R}{2} w_i^{\\text{GL}}\\right) \\cdot w_j^{\\text{GL}} \\cdot \\left(\\frac{2\\pi}{N_\\phi}\\right)\\right)\n$$\n\n#### **2. 算法实现**\n\n使用 NumPy 的向量化方法将非常高效。\n\n1.  **网格生成**:\n    *   为每个坐标生成一维数组的求积点和权重：\n        *   `r_pts`, `r_w`: 径向点和权重，来自变换后的高斯-勒让德。\n        *   `u_pts`, `theta_w`: 极向余弦和权重，来自高斯-勒让德。`theta_pts` 是 $\\arccos(u_{pts})$。\n        *   `phi_pts`, `phi_w`: 方位角和权重，来自梯形法则。\n    *   使用 `numpy.meshgrid` 为坐标（`R_grid`, `Theta_grid`, `Phi_grid`）和权重（`Wr_grid`, `Wtheta_grid`, `Wphi_grid`）创建三维网格。\n\n2.  **在网格上进行函数求值**:\n    *   从球坐标网格计算笛卡尔坐标网格 `X`, `Y`, `Z`。\n    *   在笛卡尔网格上计算 $V_{\\text{ext}}$ 及其梯度分量 $(\\partial_x V_{\\text{ext}}, \\partial_y V_{\\text{ext}}, \\partial_z V_{\\text{ext}})$。必须首先解析地推导梯度。\n        $$ \\nabla V_{\\text{ext}} = \\sum_{k=1}^6 A_k \\nabla(\\text{Term}_k) $$\n        这些导数是直接的，尽管有些繁琐的多项式微分。\n    *   使用 `scipy.special.sph_harm` 作为后端，实现一个函数来计算指定的实球谐函数 $Y_l^m(\\theta, \\phi)$。\n    *   对于每个角动量壳层 $l \\in [0, L_{\\text{tot}}]$，在三维网格上计算其对密度的贡献，$\\rho_l(r, \\theta, \\phi) = \\sum_m a_{lm} r^l e^{-\\alpha r} Y_l^m(\\theta, \\phi)$。存储这些贡献。\n\n3.  **主计算循环**:\n    *   遍历 $l_{\\max} \\in \\{0, 1, 2, 3, 4, 5\\}$。\n    *   对于每个 $l_{\\max}$，通过对 $l=0, \\dots, l_{\\max}$ 的预计算贡献 $\\rho_l$ 求和来构建截断密度 $\\rho^{(l_{\\max})}$。\n    *   计算组合的体积元网格 `dV_grid = R_grid**2 * Wr_grid * Wtheta_grid * Wphi_grid`。\n    *   通过向量化求和计算能量 $E[l_{\\max}]$ 和力矢量 $\\mathbf{F}[l_{\\max}]$：\n        $$ E[l_{\\max}] = \\sum_{\\text{grid}} \\rho^{(l_{\\max})} \\cdot V_{\\text{ext}} \\cdot dV $$\n        $$ \\mathbf{F}[l_{\\max}] = -\\sum_{\\text{grid}} \\rho^{(l_{\\max})} \\cdot \\nabla V_{\\text{ext}} \\cdot dV $$\n    *   为每个 $l_{\\max}$ 存储得到的能量（一个标量）和力（一个三维矢量）。\n\n4.  **后处理和输出**:\n    *   在为所有 $l_{\\max}$ 进行计算后，$l_{\\max} = L_{\\text{tot}} = 5$ 的结果作为参考值 $E_{\\text{ref}}$ 和 $\\mathbf{F}_{\\text{ref}}$。\n    *   对于每个 $l_{\\max}$，计算残差 $\\Delta E = E_{\\text{ref}} - E[l_{\\max}]$ 和 $\\Delta F = ||\\mathbf{F}_{\\text{ref}} - \\mathbf{F}[l_{\\max}]||_2$。\n    *   将 $[\\Delta E, \\Delta F]$ 对的列表格式化为指定的字符串格式并打印。\n\n这个设计直接实现了问题陈述，同时利用数值库来提高效率。它正确地解释了多极相互作用的物理学，因为数值结果将表明，只有当包含一个 $l > l_{\\max}$（其密度系数 $a_{lm}$ 和势系数 $C_{lm}$ 均非零）时，误差 $\\Delta E[l_{\\max}]$ 才会显著减小。类似的逻辑也适用于力。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm, roots_legendre\n\n# language: Python\n# version: 3.12\n# libraries:\n#     - name: numpy\n#       version: 1.23.5\n#     - name: scipy\n#       version: 1.11.4\n\ndef solve():\n    \"\"\"\n    Solves the computational materials science problem as specified.\n    \"\"\"\n    # ------------------- GIVENS AND PARAMETERS -------------------\n    R = 1.5\n    ALPHA = 3.0\n    L_TOT = 5\n    TEST_CASES = list(range(L_TOT + 1))\n\n    # Coefficients for the pseudo-density\n    A_COEFFS = {\n        (0, 0): 1.0, (1, 0): 0.6, (1, 1): 0.3, (2, 0): 0.4,\n        (2, 2): 0.25, (3, 0): 0.35, (3, 3): 0.20, (4, 0): 0.30, (5, 0): 0.25\n    }\n\n    # Coefficients for the external potential\n    V_COEFFS = {\n        'A1': 0.2, 'A2': 0.05, 'A3': 0.01,\n        'A4': 0.02, 'A5': 0.005, 'A6': 0.003\n    }\n\n    # Numerical integration grid parameters\n    NR, NTHETA, NPHI = 48, 48, 48\n\n    # ------------------- HELPER FUNCTIONS -------------------\n\n    def real_sph_harm(m, l, phi, theta):\n        \"\"\"\n        Computes real-valued spherical harmonics based on the problem's definition.\n        \"\"\"\n        if m == 0:\n            # sph_harm for m=0 is real, but has a complex dtype.\n            return np.real(sph_harm(0, l, phi, theta))\n        elif m > 0:\n            # Y_{l,m} = sqrt(2) * Re(Y_l^m)\n            return np.sqrt(2.0) * np.real(sph_harm(m, l, phi, theta))\n        else:  # m  0\n            # Y_{l,m} = sqrt(2) * Im(Y_l^|m|)\n            return np.sqrt(2.0) * np.imag(sph_harm(-m, l, phi, theta))\n\n    def get_V_ext(x, y, z, r_sq):\n        \"\"\"Computes the external potential V_ext on a grid.\"\"\"\n        A = V_COEFFS\n        term1 = A['A1'] * z\n        term2 = A['A2'] * (3 * z**2 - r_sq)\n        term3 = A['A3'] * x * y * z\n        term4 = A['A4'] * (x**3 - 3 * x * y**2)\n        term5 = A['A5'] * (35 * z**4 - 30 * z**2 * r_sq + 3 * r_sq**2)\n        term6 = A['A6'] * (x**5 - 10 * x**3 * y**2 + 5 * x * y**4)\n        return term1 + term2 + term3 + term4 + term5 + term6\n\n    def get_grad_V_ext(x, y, z, r_sq):\n        \"\"\"Computes the gradient of V_ext on a grid.\"\"\"\n        A = V_COEFFS\n        # Term 1: grad(A1*z)\n        grad_v1 = (np.zeros_like(x), np.zeros_like(y), A['A1'] * np.ones_like(z))\n        \n        # Term 2: grad(A2*(3*z^2 - r^2)) = grad(A2*(2*z^2 - x^2 - y^2))\n        grad_v2 = (A['A2'] * (-2 * x), A['A2'] * (-2 * y), A['A2'] * (4 * z))\n        \n        # Term 3: grad(A3*x*y*z)\n        grad_v3 = (A['A3'] * y * z, A['A3'] * x * z, A['A3'] * x * y)\n        \n        # Term 4: grad(A4*(x^3 - 3*x*y^2))\n        grad_v4 = (A['A4'] * (3 * x**2 - 3 * y**2), A['A4'] * (-6 * x * y), np.zeros_like(z))\n        \n        # Term 5: grad(A5*(35*z^4 - 30*z^2*r^2 + 3*r^4))\n        grad_v5_x = A['A5'] * x * (12 * r_sq - 60 * z**2)\n        grad_v5_y = A['A5'] * y * (12 * r_sq - 60 * z**2)\n        grad_v5_z = A['A5'] * (140 * z**3 - 60 * z * r_sq - 60 * z**3) # Simplified from 35*4*z^3 - 30*2*z*r^2 + 3*...\n        grad_v5_z = A['A5'] * (80 * z**3 - 60 * z * (x**2+y**2))\n\n        # Re-derivation for grad_v5_z.\n        # V5 = A5 * (35*z^4 - 30*z^2*(x^2+y^2+z^2) + 3*(x^2+y^2+z^2)^2)\n        #    = A5 * (35*z^4 - 30*z^2*x^2 - 30*z^2*y^2 - 30*z^4 + 3*(x^4+y^4+z^4+2x^2y^2+2x^2z^2+2y^2z^2))\n        #    = A5 * (5*z^4 - 30*z^2*x^2 - 30*z^2*y^2 + 3*x^4+3*y^4+3*z^4+6x^2y^2+6x^2z^2+6y^2z^2)\n        #    = A5 * (8*z^4 - 24*z^2*x^2 - 24*z^2*y^2 + 3*x^4+3*y^4+6x^2y^2)\n        # dV5/dz = A5 * (32*z^3 - 48*z*x^2 - 48*z*y^2)\n        grad_v5_z = A['A5'] * (32 * z**3 - 48 * z * (x**2 + y**2))\n        grad_v5 = (grad_v5_x, grad_v5_y, grad_v5_z)\n        \n        # Term 6: grad(A6*(x^5 - 10*x^3*y^2 + 5*x*y^4))\n        grad_v6_x = A['A6'] * (5 * x**4 - 30 * x**2 * y**2 + 5 * y**4)\n        grad_v6_y = A['A6'] * (-20 * x**3 * y + 20 * x * y**3)\n        grad_v6 = (grad_v6_x, grad_v6_y, np.zeros_like(z))\n\n        grad_vx = grad_v1[0] + grad_v2[0] + grad_v3[0] + grad_v4[0] + grad_v5[0] + grad_v6[0]\n        grad_vy = grad_v1[1] + grad_v2[1] + grad_v3[1] + grad_v4[1] + grad_v5[1] + grad_v6[1]\n        grad_vz = grad_v1[2] + grad_v2[2] + grad_v3[2] + grad_v4[2] + grad_v5[2] + grad_v6[2]\n        \n        return grad_vx, grad_vy, grad_vz\n\n    # ------------------- NUMERICAL GRID SETUP -------------------\n    # Radial grid (Gauss-Legendre on [0, R])\n    t_pts, t_w = roots_legendre(NR)\n    r_pts = R * (t_pts + 1.0) / 2.0\n    r_w = R * t_w / 2.0\n\n    # Polar grid (Gauss-Legendre on u=cos(theta) in [-1, 1])\n    u_pts, u_w = roots_legendre(NTHETA)\n    theta_pts = np.arccos(u_pts)\n\n    # Azimuthal grid (Trapezoidal rule on [0, 2pi])\n    phi_pts = np.linspace(0, 2 * np.pi, NPHI, endpoint=False)\n    phi_w = (2 * np.pi / NPHI) * np.ones(NPHI)\n    \n    # Create 3D grids for coordinates and weights\n    R_grid, Theta_grid, Phi_grid = np.meshgrid(r_pts, theta_pts, phi_pts, indexing='ij')\n    Wr_grid, Wtheta_grid, Wphi_grid = np.meshgrid(r_w, u_w, phi_w, indexing='ij')\n    \n    # Cartesian coordinates on the grid\n    X = R_grid * np.sin(Theta_grid) * np.cos(Phi_grid)\n    Y = R_grid * np.sin(Theta_grid) * np.sin(Phi_grid)\n    Z = R_grid * np.cos(Theta_grid)\n    R_sq_grid = R_grid**2\n\n    # ------------------- PRE-COMPUTATION -------------------\n    # Pre-compute potential and its gradient on the grid\n    V_grid = get_V_ext(X, Y, Z, R_sq_grid)\n    grad_Vx_grid, grad_Vy_grid, grad_Vz_grid = get_grad_V_ext(X, Y, Z, R_sq_grid)\n\n    # Pre-compute density contributions for each l-shell\n    rho_l_contributions = {}\n    for l in range(L_TOT + 1):\n        l_contribution = np.zeros_like(R_grid)\n        if any(key[0] == l for key in A_COEFFS):\n            radial_part = (R_grid**l) * np.exp(-ALPHA * R_grid)\n            for m in range(-l, l + 1):\n                if (l, m) in A_COEFFS:\n                    alm = A_COEFFS[(l, m)]\n                    Ylm_grid = real_sph_harm(m, l, Phi_grid, Theta_grid)\n                    l_contribution += alm * radial_part * Ylm_grid\n        rho_l_contributions[l] = l_contribution\n\n    # ------------------- MAIN CALCULATION -------------------\n    all_results = {}\n    current_rho_grid = np.zeros_like(R_grid)\n    \n    # Differential volume element\n    dV_grid = R_sq_grid * Wr_grid * Wtheta_grid * Wphi_grid\n\n    for l_max in TEST_CASES:\n        # Incrementally build the density\n        current_rho_grid += rho_l_contributions[l_max]\n\n        # Calculate Energy\n        E = np.sum(current_rho_grid * V_grid * dV_grid)\n        \n        # Calculate Force\n        Fx = -np.sum(current_rho_grid * grad_Vx_grid * dV_grid)\n        Fy = -np.sum(current_rho_grid * grad_Vy_grid * dV_grid)\n        Fz = -np.sum(current_rho_grid * grad_Vz_grid * dV_grid)\n        F_vec = np.array([Fx, Fy, Fz])\n        \n        all_results[l_max] = {'E': E, 'F': F_vec}\n\n    # ------------------- POST-PROCESSING AND OUTPUT -------------------\n    E_ref = all_results[L_TOT]['E']\n    F_ref = all_results[L_TOT]['F']\n    \n    output_list = []\n    for l_max in TEST_CASES:\n        dE = E_ref - all_results[l_max]['E']\n        dF_vec = F_ref - all_results[l_max]['F']\n        dF_norm = np.linalg.norm(dF_vec)\n        output_list.append([dE, dF_norm])\n        \n    # Format the final output string exactly as requested\n    formatted_results = [f'[{item[0]:.8e}, {item[1]:.8e}]' for item in output_list]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3433593"}]}