{"hands_on_practices": [{"introduction": "描述材料中的原子排布是理解其性质的第一步。本练习将指导你通过两条独立的计算路径来量化位置有序性：直接在倒易空间中计算静态结构因子 $S(k)$，以及通过实空间中的径向分布函数 $g(r)$ 进行计算。通过验证这两种方法的一致性[@problem_id:3486874]，你将深入掌握这两种核心结构表征工具之间的深刻联系，并为分析散射实验数据和模拟结果打下坚实的基础。", "problem": "你需要编写一个完整、可运行的程序，该程序为一个包含 $N$ 个点粒子的三维周期性系统（在一个边长为 $L$ 的立方体盒子中，使用周期性边界条件），通过两种独立的路径计算静态结构因子，记为 $S(\\mathbf{k})$，并通过各向同性比较来验证它们的一致性。所有距离都必须以纳米 (nm) 为单位，所有波矢量都以反纳米 (nm$^{-1}$) 为单位，所有角度都以弧度为单位。最终输出必须是格式完全符合 Python 布尔值列表的单行文本，每个测试用例对应一个布尔值，其中每个布尔值表示是否满足指定的数值验证标准。\n\n使用的基本原理：\n- 对于粒子位置 $\\{\\mathbf{r}_j\\}$，三维微观数密度场定义为 $\\,\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)\\,$。\n- 静态结构因子 $\\,S(\\mathbf{k})\\,$ 是周期性边界条件下倒易空间中密度涨落的傅里叶变换。\n- 对于各向同性系统，径向分布函数 $\\,g(r)\\,$ 由双粒子密度定义，并通过三维各向同性变换与 $\\,S(k)\\,$ 相关联。\n\n你的程序必须：\n- 从这些核心定义出发，推导、实现并数值评估：\n  1. 通过对周期性边界条件下的粒子位置进行离散傅里叶变换（即使用与立方体盒子兼容的倒易晶格波矢量）获得的 $\\,S(k)\\,$ 的角度平均估计。通过将波矢量分箱到宽度为 $\\Delta k$ 的球壳中，并在每个壳层内将 $\\,S(\\mathbf{k})\\,$ 作为 $k = \\lVert \\mathbf{k} \\rVert$ 的函数进行平均，来执行各向同性平均。\n  2. 一个独立的 $\\,S(k)\\,$ 各向同性估计，首先使用最小镜像约定从对距离计算径向分布函数 $\\,g(r)\\,$，然后应用 $\\,S(k)\\,$ 和 $\\,g(r)\\,$ 之间的三维各向同性关系（表示为包含球贝塞尔核的一维变换）。使用宽度为 $\\Delta r$ 的直方图分箱在 $r \\in (0, L/2]$ 上估计 $\\,g(r)\\,$，并对每个感兴趣的 $k$ 值，执行数值稳定的求积来计算积分。\n\n- 使用一致的单位（长度为 nm，波矢量为 nm$^{-1}$），周期性边界条件，并以弧度处理角度变量。确保 $k=0$ 模式被排除在比较之外。在倒易空间中对 $\\,S(\\mathbf{k})\\,$ 进行分箱时，忽略任何包含少于指定最小波矢量数量的 $k$-壳层，以保证有意义的角度平均。\n\n- 实现一个定量验证指标，在一个共同的 $k$ 网格上直接比较两种 $\\,S(k)\\,$ 估计值。具体来说，对于两种估计都有定义的 $k$-分箱中心集合，计算两条曲线之间的相对 $\\ell_2$ 误差，\n  $$\\varepsilon = \\sqrt{\\frac{\\sum_{m} \\left(S_{\\text{DFT}}(k_m) - S_{g}(k_m)\\right)^2}{\\sum_{m} \\left(S_{g}(k_m)\\right)^2}},$$\n  当且仅当 $\\,\\varepsilon \\le \\text{tol}\\,$ 时，宣布测试通过，其中 $\\text{tol}$ 是每个测试用例指定的容差。\n\n- 程序必须产生单行输出，包含一个用方括号括起来的、逗号分隔的结果列表（例如，“[True,False,True]”）。\n\n测试套件：\n实现以下四个测试用例。对于每个用例，按照指定生成粒子构型，然后计算两种各向同性 $\\,S(k)\\,$ 估计值并评估验证指标。使用给定的参数和容差。所有随机数生成必须通过提供的种子使其可复现。\n\n- 用例 A（理想气体，仅有短程无序）：\n  - $N = 512$，$L = 10.0\\,\\text{nm}$，在 $[0,L)^3$ 范围内使用种子 $= 1$ 生成随机均匀位置。\n  - 实空间直方图：$\\Delta r = 0.05\\,\\text{nm}$，对距离最大到 $r_{\\max} = L/2$。\n  - 倒易空间波矢量：所有整数三元组 $\\mathbf{n} \\in \\mathbb{Z}^3$ 映射到 $\\mathbf{k} = (2\\pi/L)\\,\\mathbf{n}$，且满足 $\\lVert \\mathbf{k} \\rVert \\le k_{\\max}$，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$。\n  - $k$-壳层分箱宽度：$\\Delta k = 0.4\\,\\text{nm}^{-1}$，排除 $\\mathbf{k}=\\mathbf{0}$ 模式和任何包含少于 5 个波矢量的壳层。\n  - 容差：$\\text{tol} = 0.18$。\n\n- 用例 B（具有小热位移的简立方晶体，长程有序）：\n  - 在边长 $L = 12.0\\,\\text{nm}$ 的立方体盒子中，构建一个每个方向有 $n_{\\text{cell}} = 6$ 个晶胞的简立方晶格，从而在晶格点上产生 $N = n_{\\text{cell}}^3 = 216$ 个粒子，晶格常数为 $a = L/n_{\\text{cell}}$。\n  - 在每个笛卡尔方向上添加均值为零、标准差为 $\\sigma = 0.05\\,a$ 的独立高斯位移；将位置包装回盒子内；随机种子 $= 2$。\n  - 实空间直方图：$\\Delta r = 0.03\\,\\text{nm}$，对距离最大到 $r_{\\max} = L/2$。\n  - 倒易空间同用例 A，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$ 且 $\\Delta k = 0.4\\,\\text{nm}^{-1}$；排除 $\\mathbf{k}=\\mathbf{0}$ 模式和任何包含少于 5 个波矢量的壳层。\n  - 容差：$\\text{tol} = 0.28$。\n\n- 用例 C（具有排除体积的硬核流体，短程有序）：\n  - $N = 200$，$L = 10.0\\,\\text{nm}$，在周期性边界条件下，通过随机顺序添加生成位置，最小对间距为 $d_{\\min} = 0.8\\,\\text{nm}$；随机种子 $= 3$。\n  - 实空间直方图：$\\Delta r = 0.05\\,\\text{nm}$，最大到 $r_{\\max} = L/2$。\n  - 倒易空间同用例 A，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$ 且 $\\Delta k = 0.4\\,\\text{nm}^{-1}$；排除 $\\mathbf{k}=\\mathbf{0}$ 模式和任何包含少于 5 个波矢量的壳层。\n  - 容差：$\\text{tol} = 0.25$。\n\n- 用例 D（小 $N$ 边缘情况，噪声统计）：\n  - $N = 64$，$L = 10.0\\,\\text{nm}$，在 $[0,L)^3$ 范围内使用种子 $= 4$ 生成随机均匀位置。\n  - 实空间直方图：$\\Delta r = 0.10\\,\\text{nm}$，最大到 $r_{\\max} = L/2$。\n  - 倒易空间，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$，$\\Delta k = 0.5\\,\\text{nm}^{-1}$；排除 $\\mathbf{k}=\\mathbf{0}$ 模式和任何包含少于 5 个波矢量的壳层。\n  - 容差：$\\text{tol} = 0.40$。\n\n实现要求：\n- 对对距离使用最小镜像约定。\n- 对径向分布函数 $\\,g(r)\\,$ 直方图使用一致且正确的归一化。\n- 使用数值稳定的球核函数进行 $\\,g(r)\\,$ 到 $\\,S(k)\\,$ 的三维各向同性变换，确保在 $\\,k \\to 0\\,$ 时的正确行为，并处理有限上限 $\\,r_{\\max} = L/2\\,$。\n- 对于每个测试用例，汇总一个布尔值，指示是否满足相对 $\\ell_2$ 误差标准。您的程序应按 A、B、C、D 的顺序生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，例如：“[True,False,True,True]”。", "solution": "所提供的问题是计算统计物理学中一个有效且定义明确的练习。它要求实现和比较两种计算多粒子系统静态结构因子 $S(k)$ 的基本方法。该问题具有科学依据，形式上明确，并且在计算上是可行的。所有必要的参数和定义都已提供。\n\n解决方案首先按照测试用例中的规定，为几种物理场景生成粒子构型。然后，对于每个构型，通过两条不同的路径计算各向同性平均的静态结构因子 $S(k)$。最后，使用指定的误差度量比较两条路径的结果，以验证其一致性。\n\n### 方法 1：从粒子位置直接计算\n\n第一种方法直接从体积为 $V=L^3$ 的立方体盒子中的粒子位置 $\\{\\mathbf{r}_j\\}_{j=1}^N$ 计算结构因子。对于粒子的单一构型，在特定波矢量 $\\mathbf{k}$ 处的结构因子由下式给出：\n$$S(\\mathbf{k}) = \\frac{1}{N} \\left| \\sum_{j=1}^{N} \\exp(-i\\mathbf{k}\\cdot\\mathbf{r}_j) \\right|^2$$\n其中 $N$ 是粒子数。由于系统施加了周期性边界条件，允许的波矢量 $\\mathbf{k}$ 必须与模拟盒子的倒易晶格兼容。对于边长为 $L$ 的立方体盒子，这些矢量是：\n$$\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}, \\quad \\text{其中} \\quad \\mathbf{n} = (n_x, n_y, n_z) \\in \\mathbb{Z}^3$$\n分析仅限于模长 $k = \\lVert\\mathbf{k}\\rVert$ 直到最大值 $k_{\\max}$ 的波矢量，并排除了 $\\mathbf{k} = \\mathbf{0}$ 的情况，该情况对应于平均密度，通常不属于 $S(k)$ 的一部分。\n\n为了获得各向同性的结构因子 $S(k)$，需要进行角度平均。这在计算上通过将计算出的 $S(\\mathbf{k})$ 值根据其模长 $k = \\lVert\\mathbf{k}\\rVert$ 在倒易空间中分箱到球壳中来实现。对于每个对应于壳层 $[k_m - \\Delta k/2, k_m + \\Delta k/2)$ 的分箱 $m$，平均结构因子 $S_{\\text{DFT}}(k_m)$ 为：\n$$S_{\\text{DFT}}(k_m) = \\frac{1}{C_m} \\sum_{\\mathbf{k} \\in \\text{shell } m} S(\\mathbf{k})$$\n其中 $k_m$ 是分箱的中心，$C_m$ 是落入该壳层的离散 $\\mathbf{k}$ 矢量的数量。计数 $C_m$ 低于指定最小阈值的分箱将被丢弃，以确保统计上有意义的平均。\n\n### 方法 2：通过径向分布函数计算\n\n第二种独立的 $S(k)$ 计算路径首先计算径向分布函数 $g(r)$。对于各向同性系统，$g(r)$ 与在距离参考粒子 $r$ 处找到另一个粒子的概率有关，该概率通过相同密度下理想气体的概率进行归一化。\n\n在数值上，$g(r)$ 的计算步骤如下：\n$1$. 使用最小镜像约定计算所有唯一的对距离 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$，以正确处理周期性边界条件。\n$2$. 将这些距离分箱到宽度为 $\\Delta r$ 的直方图 $H(r)$ 中。\n$3$. 通过在相应球壳体积 $V_{\\text{shell},i}$ 内理想气体中预期的对数，对每个分箱 $i$（中心在 $r_i$）的直方图计数进行归一化。使用的公式是：\n$$g(r_i) = \\frac{H_i}{\\frac{N(N-1)}{2V} V_{\\text{shell},i}} \\quad \\text{其中} \\quad V_{\\text{shell},i} = \\frac{4\\pi}{3}((r_i+\\Delta r/2)^3 - (r_i-\\Delta r/2)^3)$$\n计算执行到距离 $r$ 的截断值 $r_{\\max} = L/2$。\n\n对于三维各向同性系统，$S(k)$ 通过对相关函数 $h(r) = g(r) - 1$ 的傅里叶变换与 $g(r)$ 相关：\n$$S(k) = 1 + \\rho_0 \\int_0^\\infty [g(r)-1] 4\\pi r^2 \\frac{\\sin(kr)}{kr} dr$$\n其中 $\\rho_0 = N/V$ 是平均数密度。项 $\\frac{\\sin(x)}{x}$ 是零阶球贝塞尔函数 $j_0(x)$。该积分使用简单的求积法（矩形法）在计算出的 $g(r_i)$ 值上进行数值计算，直到 $r_{\\max}$：\n$$S_{g}(k_m) \\approx 1 + 4\\pi\\rho_0 \\sum_{i} [g(r_i)-1] r_i^2 \\frac{\\sin(k_m r_i)}{k_m r_i} \\Delta r$$\n这提供了第二个估计值 $S_{g}(k)$，它基于从直接法导出的同一组波矢量模长 $k_m$。\n\n### 验证\n\n最后一步是在通过统计筛选的共同分箱中心集合 $\\{k_m\\}$ 上，定量比较两个估计值 $S_{\\text{DFT}}(k_m)$ 和 $S_{g}(k_m)$。一致性通过相对 $\\ell_2$ 误差进行评估：\n$$\\varepsilon = \\sqrt{\\frac{\\sum_{m} \\left(S_{\\text{DFT}}(k_m) - S_{g}(k_m)\\right)^2}{\\sum_{m} \\left(S_{g}(k_m)\\right)^2}}$$\n如果该误差 $\\varepsilon$ 不超过指定的容差 $\\text{tol}$，则认为测试用例成功（通过）。\n\n所提供的测试用例（理想气体、受扰动的晶体、硬核流体）在具有不同类型结构有序度（从纯无序到准长程有序）以及不同统计条件下的系统中，检验了算法的正确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates the static structure factor S(k) via two routes\n    for multiple test cases as specified in the problem.\n    \"\"\"\n\n    def generate_hard_core_positions(N, L, d_min, seed):\n        \"\"\"\n        Generates particle positions for a hard-core fluid using Random Sequential Addition.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        positions = np.zeros((N, 3))\n        if N == 0:\n            return positions\n        \n        positions[0] = rng.uniform(0, L, 3)\n        n_particles = 1\n        \n        max_total_attempts = N * N * 100 \n        total_attempts = 0\n\n        while n_particles  N:\n            total_attempts += 1\n            if total_attempts > max_total_attempts:\n                raise RuntimeError(\n                    f\"Failed to place all {N} particles for the hard-core case \"\n                    f\"with d_min={d_min}. The packing might be too dense for RSA.\"\n                )\n\n            trial_pos = rng.uniform(0, L, 3)\n            \n            is_valid = True\n            for i in range(n_particles):\n                dist_vec = trial_pos - positions[i]\n                # Minimum Image Convention\n                dist_vec -= L * np.round(dist_vec / L)\n                if np.linalg.norm(dist_vec)  d_min:\n                    is_valid = False\n                    break\n            \n            if is_valid:\n                positions[n_particles] = trial_pos\n                n_particles += 1\n                \n        return positions\n\n    def process_case(N, L, positions, dr, k_max, dk, min_k_count, tol):\n        \"\"\"\n        Performs the full calculation and validation for a single test case.\n        \"\"\"\n        V = L**3\n        rho_0 = N / V if L > 0 else 0\n\n        # --- Method 1: Direct DFT Calculation of S(k) ---\n        n_max = int(np.ceil(L * k_max / (2 * np.pi)))\n        n_vals = np.arange(-n_max, n_max + 1)\n        nx, ny, nz = np.meshgrid(n_vals, n_vals, n_vals, indexing='ij')\n        n_vectors = np.stack([nx.ravel(), ny.ravel(), nz.ravel()], axis=1)\n\n        n_vectors = n_vectors[np.any(n_vectors != 0, axis=1)]\n        k_vectors = (2 * np.pi / L) * n_vectors\n        k_mags = np.linalg.norm(k_vectors, axis=1)\n        \n        valid_k_indices = k_mags = k_max\n        k_vectors = k_vectors[valid_k_indices]\n        k_mags = k_mags[valid_k_indices]\n\n        if N > 0:\n            k_dot_r = positions @ k_vectors.T\n            rho_k = np.sum(np.exp(-1j * k_dot_r), axis=0)\n            S_k_values = (1/N) * np.abs(rho_k)**2\n        else:\n            S_k_values = np.zeros_like(k_mags)\n            \n        k_bins = np.arange(0, k_max + dk, dk)\n        bin_indices = np.digitize(k_mags, k_bins) - 1\n        \n        num_bins = len(k_bins) - 1\n        S_k_sum = np.bincount(bin_indices, weights=S_k_values, minlength=num_bins)\n        k_counts = np.bincount(bin_indices, minlength=num_bins)\n        \n        S_dft_vals = np.zeros_like(S_k_sum, dtype=float)\n        has_counts = k_counts > 0\n        S_dft_vals[has_counts] = S_k_sum[has_counts] / k_counts[has_counts]\n        \n        S_dft_k_centers = k_bins[:-1] + dk / 2\n\n        valid_mask = k_counts >= min_k_count\n        k_common = S_dft_k_centers[valid_mask]\n        S_dft_common = S_dft_vals[valid_mask]\n\n        if k_common.size == 0:\n            return True\n\n        # --- Method 2: S(k) via g(r) ---\n        r_max = L / 2\n        \n        if N > 1:\n            dists = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    diff = positions[i] - positions[j]\n                    diff -= L * np.round(diff / L) # MIC\n                    dists.append(np.linalg.norm(diff))\n            \n            r_bins = np.arange(0, r_max + dr, dr)\n            hist, _ = np.histogram(dists, bins=r_bins)\n            g_r_r_centers = r_bins[:-1] + dr / 2\n            \n            shell_vols = (4/3) * np.pi * (r_bins[1:]**3 - r_bins[:-1]**3)\n            ideal_gas_counts_factor = N * (N - 1) / (2 * V)\n            ideal_gas_counts = ideal_gas_counts_factor * shell_vols\n\n            g_r_vals = np.zeros_like(g_r_r_centers)\n            non_zero_ideal = ideal_gas_counts > 1e-9\n            g_r_vals[non_zero_ideal] = hist[non_zero_ideal] / ideal_gas_counts[non_zero_ideal]\n        else:\n            g_r_vals = np.array([])\n            g_r_r_centers = np.array([])\n        \n        if g_r_r_centers.size > 0:\n            kr_matrix = k_common[:, None] * g_r_r_centers[None, :]\n            j0_matrix = np.sinc(kr_matrix / np.pi)\n            integrand_matrix = (g_r_vals - 1) * (g_r_r_centers**2) * j0_matrix\n            integral_vals = np.sum(integrand_matrix, axis=1) * dr\n            S_g_common = 1 + 4 * np.pi * rho_0 * integral_vals\n        else:\n            S_g_common = np.ones_like(k_common)\n        \n        # --- Validation ---\n        denom = np.sum(S_g_common**2)\n        if denom  1e-12:\n            return np.sum(S_dft_common**2)  1e-12\n\n        numerator = np.sum((S_dft_common - S_g_common)**2)\n        error = np.sqrt(numerator / denom)\n\n        return error = tol\n\n    test_cases = [\n        # Case A: Ideal Gas\n        {'type': 'ideal_gas', 'N': 512, 'L': 10.0, 'seed': 1, 'dr': 0.05, 'k_max': 6.0, 'dk': 0.4, 'min_k_count': 5, 'tol': 0.18},\n        # Case B: Crystal\n        {'type': 'crystal', 'n_cell': 6, 'L': 12.0, 'sigma_frac': 0.05, 'seed': 2, 'dr': 0.03, 'k_max': 6.0, 'dk': 0.4, 'min_k_count': 5, 'tol': 0.28},\n        # Case C: Hard-core Fluid\n        {'type': 'hard_core', 'N': 200, 'L': 10.0, 'd_min': 0.8, 'seed': 3, 'dr': 0.05, 'k_max': 6.0, 'dk': 0.4, 'min_k_count': 5, 'tol': 0.25},\n        # Case D: Small-N Ideal Gas\n        {'type': 'ideal_gas', 'N': 64, 'L': 10.0, 'seed': 4, 'dr': 0.10, 'k_max': 6.0, 'dk': 0.5, 'min_k_count': 5, 'tol': 0.40},\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L = 0, 0\n        if case['type'] == 'ideal_gas':\n            N, L, seed = case['N'], case['L'], case['seed']\n            rng = np.random.default_rng(seed)\n            positions = rng.uniform(0, L, size=(N, 3))\n        elif case['type'] == 'crystal':\n            n_cell, L, sigma_frac, seed = case['n_cell'], case['L'], case['sigma_frac'], case['seed']\n            a = L / n_cell\n            N = n_cell**3\n            ix, iy, iz = np.meshgrid(np.arange(n_cell), np.arange(n_cell), np.arange(n_cell), indexing='ij')\n            lattice_sites = np.stack([ix.ravel(), iy.ravel(), iz.ravel()], axis=1) * a\n            rng = np.random.default_rng(seed)\n            sigma = sigma_frac * a\n            displacements = rng.normal(0, sigma, size=(N, 3))\n            positions = (lattice_sites + displacements) % L\n        elif case['type'] == 'hard_core':\n            N, L, d_min, seed = case['N'], case['L'], case['d_min'], case['seed']\n            positions = generate_hard_core_positions(N, L, d_min, seed)\n\n        validation_passed = process_case(N, L, positions, case['dr'], case['k_max'], case['dk'], case['min_k_count'], case['tol'])\n        results.append(validation_passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486874"}, {"introduction": "除了原子的位置，原子间“键”的朝向同样可以形成有序结构。本练习将引导你探索一个超越传统位置有序性的概念——键合朝向序，并计算其关联函数 $g_6(r)$。通过分析 $g_6(r)$ 的衰减行为[@problem_id:3486855]，你将学习如何区分具有短程序（液态）、准长程序（六方相）和长程序（晶态）的二维系统，从而揭示物态的更丰富层次。", "problem": "给定一个周期性网格上的二维局部键取向角场，角度以弧度为单位。任务是计算六重键取向相关性作为分离距离的函数，并根据其衰减形式，将底层状态分类为类晶体、类六方相或类液体。计算必须基于第一性原理和实空间中相关的定义，并且不得依赖任何预先制表的结​​果。所有步骤的表述方式必须能让通用程序在不使用领域特定库的情况下实现。\n\n定义和基本原理：\n- 考虑一个维度为 $N_x \\times N_y$ 的周期性二维网格，其整数坐标为 $(x,y)$，单位网格间距。令 $\\theta(x,y)$ 表示以弧度为单位的局部键取向角场，其中角度对 $2\\pi$ 取模。\n- 将每个网格点上的复六重局部序参量定义为 $\\psi_6(x,y) = \\exp\\left(i \\cdot 6 \\cdot \\theta(x,y)\\right)$，其中 $i$ 是虚数单位。\n- 对于晶格位移矢量 $\\Delta \\mathbf{r}$，六重键取向两点相关函数定义为 $G_6(\\Delta \\mathbf{r}) = \\langle \\psi_6(\\mathbf{r}) \\psi_6^\\ast(\\mathbf{r} + \\Delta \\mathbf{r}) \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示在周期性边界条件下对 $\\mathbf{r}$ 的空间平均，而 ${}^\\ast$ 表示复共轭。\n- 径向相关是所有欧几里得范数约等于 $r$ 的 $\\Delta \\mathbf{r}$ 上的壳层平均，记为 $g_6(r)$。\n- 短程有序与长程有序通过 $g_6(r)$ 如何依赖于 $r$ 来探测，其中 $r$ 以网格单位（无量纲）度量。角度必须以弧度为单位。\n\n程序任务：\n1. 对于每个测试用例，使用指定的生成模型在周期性 $N_x \\times N_y$ 网格上构建 $\\theta(x,y)$。然后构建 $\\psi_6(x,y)$ 并通过空间平均计算完整的周期性两点相关图 $G_6(\\Delta \\mathbf{r})$。执行径向壳层平均以获得 $r \\in [r_{\\min}, r_{\\max}]$ 范围内的 $g_6(r)$，其中 $r_{\\min} = 2$ 且 $r_{\\max} = \\lfloor \\min(N_x, N_y)/2 \\rfloor$。使用壳层厚度 $\\Delta r = 1$。\n2. 仅使用计算出的 $g_6(r)$，确定以下哪个衰减族最能描述其对 $r$ 的依赖关系：\n   - 相对于 $r$ 为常数（表示长程取向有序）。\n   - 关于 $r$ 的指数衰减（表示短程取向有序）。\n   - 关于 $r$ 的幂律衰减（表示准长程取向有序）。\n   分类必须通过在适当的变换域上使用普通最小二乘法拟合线性模型来执行，并根据基于残差的定量信息准则选择最佳族。角度必须以弧度为单位，距离是无量纲的网格单位。不提供相的外部标签；您必须仅从 $g_6(r)$ 推断类别。\n3. 对于每个测试用例，将识别出的衰减族的整数编码作为单行列表输出。使用以下映射：类晶体（常数）$\\to 2$，类六方相（幂律）$\\to 1$，类液体（指数）$\\to 0$。\n\n测试套件（四个案例），所有随机抽样均使用提供的种子进行，所有网格操作均假定为周期性的。谱合成在指定网格上使用离散傅里叶变换：\n- 案例 A（类晶体平台区）：\n  - 网格：$N_x = 48$，$N_y = 48$。\n  - 角场：$\\theta(x,y) = \\theta_0 + \\varepsilon(x,y)$，其中 $\\theta_0 = 0$，且 $\\varepsilon(x,y)$ 是独立的、均值为零、标准差为 $\\sigma = 0.03$（弧度）的高斯噪声。\n  - 种子：$11$。\n- 案例 B（类六方相，缓慢衰减的相关性）：\n  - 网格：$N_x = 64$，$N_y = 64$。\n  - 通过谱合成得到的角场：在傅里叶空间中，对于离散网格上的每个波矢 $\\mathbf{k} = (k_x, k_y)$，当 $\\lVert \\mathbf{k} \\rVert \\geq 1$ 时，设置复振幅包络 $A(\\mathbf{k}) = \\lVert \\mathbf{k} \\rVert^{-\\gamma}$，且 $A(\\mathbf{0}) = 0$。抽取具有独立标准正态实部和虚部的复高斯系数，乘以 $A(\\mathbf{k})$，然后应用离散傅里叶逆变换以获得实场（如果需要，取实部）。将 $\\theta(x,y)$ 的均值平移至零，并将其标准差缩放至 $\\tau = 0.6$（弧度）。使用 $\\gamma = 2.5$。\n  - 种子：$7$。\n- 案例 C（类液体，短相关长度）：\n  - 网格：$N_x = 64$，$N_y = 64$。\n  - 通过谱合成和洛伦兹谱得到的角场：在傅里叶空间中，设置 $A(\\mathbf{k}) = \\left(\\lVert \\mathbf{k} \\rVert^2 + \\kappa^2 \\right)^{-1}$，且 $A(\\mathbf{0}) = 0$。抽取具有独立标准正态实部和虚部的复高斯系数，乘以 $A(\\mathbf{k})$，然后进行逆变换以获得实场（如果需要，取实部）。将 $\\theta(x,y)$ 的均值平移至零，并将其标准差缩放至 $\\tau = 1.0$（弧度）。使用 $\\kappa = 1.0$。\n  - 种子：$5$。\n- 案例 D（噪声更大的类晶体平台区）：\n  - 网格：$N_x = 48$，$N_y = 48$。\n  - 角场：$\\theta(x,y) = \\theta_0 + \\varepsilon(x,y)$，其中 $\\theta_0 = 0$，且 $\\varepsilon(x,y)$ 是独立的、均值为零、标准差为 $\\sigma = 0.10$（弧度）的高斯噪声。\n  - 种子：$19$。\n\n实现约束和细节：\n- 所有角度都必须以弧度处理。距离 $r$ 以无量纲的网格单位度量。\n- 在整个过程中必须使用周期性边界条件。\n- 为高效计算 $G_6(\\Delta \\mathbf{r})$，您可以使用离散卷积定理：$\\psi_6(\\mathbf{r}) \\psi_6^\\ast(\\mathbf{r} + \\Delta \\mathbf{r})$ 在 $\\mathbf{r}$ 上的空间平均是 $\\psi_6$ 的循环自相关，它可以通过对 $\\psi_6$ 的离散傅里叶变换的模平方进行离散傅里叶逆变换来计算。对自相关进行归一化，使其在每个位移处都等于对 $\\mathbf{r}$ 的空间平均。\n- 径向壳层平均必须排除 $r = 0$ 的区间，并使用厚度为 $\\Delta r = 1$ 的壳层。丢弃位移矢量贡献少于50个的壳层平均值。\n- 对于模型拟合，在每个族的自然域中操作：\n  - 对于常数族，在有效 $r$ 范围内的线性空间中将 $g_6(r)$ 拟合为一个常数。\n  - 对于指数族，在 $g_6(r) > 0$ 的有效 $r$ 范围内，将 $\\ln g_6(r)$ 对 $r$ 的关系拟合为一条直线。\n  - 对于幂律族，在 $g_6(r) > 0$ 的有效 $r$ 范围内，将 $\\ln g_6(r)$ 对 $\\ln r$ 的关系拟合为一条直线。\n  在每个变换域中使用普通最小二乘法。为保证数值稳定性，在取对数时，可以将非正的 $g_6(r)$ 替换为一个小的正数下限，但将这些点从拟合中排除。\n- 使用信息准则来选择最佳族。对于每个族，在相应的域中计算其残差平方和、拟合点数 $n$ 和自由参数数 $k$（常数模型 $k = 1$，直线拟合 $k = 2$）。计算赤池信息量准则（Akaike Information Criterion）为 $\\mathrm{AIC} = n \\cdot \\ln(\\mathrm{SSE}/n) + 2k$，并选择具有最小 $\\mathrm{AIC}$ 的族。约束指数族和幂律族具有负的拟合斜率；如果它们的最佳拟合斜率为非负，则不得选择它们。作为稳健性检查，如果在有效 $r$ 范围内 $g_6(r)$ 的相对标准差小于 0.05，则无论 $\\mathrm{AIC}$ 值如何，都选择常数族。\n- 最终输出格式：您的程序应生成一行输出，其中包含四个测试用例（按 A、B、C、D 的顺序）的整数编码族，形式为用方括号括起来的逗号分隔列表，例如，“[2,1,0,2]”。不应打印额外的空格或文本。\n\n角度单位要求：角度以弧度为单位。输出中不出现其他物理单位。最终输出必须严格符合上述指定的一行格式。", "solution": "该问题要求基于六重键取向相关函数 $g_6(r)$ 的衰减特性，将二维取向有序分为类晶体、类六方相或类液体相。解决方案旨在遵循第一性原理计算方法，包括三个主要阶段：角场的生成、相关函数的计算，以及基于模型的相关性衰减分类。\n\n### 1. 角场 $\\theta(x,y)$ 的生成\n\n初始步骤是为每个测试用例，在周期性 $N_x \\times N_y$ 网格上构建局部角场 $\\theta(x,y)$。指定了两种不同的生成模型：\n\n**a) 直接高斯噪声（类晶体案例 A 和 D）：**\n对于具有长程取向有序（类晶体）的状态，角度围绕一个共同的取向弱波动。这通过向一个恒定的基础角度 $\\theta_0$ 添加独立同分布的高斯噪声 $\\varepsilon(x,y)$ 来建模。每个位点 $(x,y)$ 的角度由下式给出：\n$$\n\\theta(x,y) = \\theta_0 + \\varepsilon(x,y)\n$$\n其中 $\\varepsilon(x,y) \\sim \\mathcal{N}(0, \\sigma^2)$ 是从均值为 $0$、标准差 $\\sigma$ 较小的正态分布中抽取的。对于给定的测试用例，$\\theta_0=0$。\n\n**b) 谱合成（类六方相和类液体案例 B 和 C）：**\n对于具有更复杂相关结构的状态，我们使用谱合成。该方法通过定义其傅里叶谱来构建具有预定空间相关性的实空间场。步骤如下：\n1.  在与实空间网格对应的离散傅里叶（或 $k$）空间中生成一个复高斯随机数网格 $Z(\\mathbf{k})$。每个 $Z(\\mathbf{k})$ 的实部和虚部都是从标准正态分布 $\\mathcal{N}(0,1)$ 中独立抽取的。\n2.  定义一个依赖于波矢的振幅包络 $A(\\mathbf{k})$。这个包络塑造了最终场的功率谱。对于案例 B（类六方相），使用幂律包络 $A(\\mathbf{k}) = \\lVert \\mathbf{k} \\rVert^{-\\gamma}$。对于案例 C（类液体），使用洛伦兹包络 $A(\\mathbf{k}) = (\\lVert \\mathbf{k} \\rVert^2 + \\kappa^2)^{-1}$。在这两种情况下，$A(\\mathbf{0}) = 0$。\n3.  角场的傅里叶表示 $\\hat{\\theta}(\\mathbf{k})$ 通过将噪声乘以包络得到：$\\hat{\\theta}(\\mathbf{k}) = Z(\\mathbf{k}) \\cdot A(\\mathbf{k})$。\n4.  实空间场 $\\theta(x,y)$ 通过对 $\\hat{\\theta}(\\mathbf{k})$ 应用二维离散傅里叶逆变换（IDFT）并取结果的实部获得。\n5.  最后，通过将其均值移至零并将其标准差缩放到目标值 $\\tau$ 来对场进行归一化。\n\n### 2. 相关函数 $g_6(r)$ 的计算\n\n在建立角场 $\\theta(x,y)$ 后，我们计算径向键取向相关函数 $g_6(r)$。\n\n**a) 局部序参量：**\n首先，在每个网格点计算复六重键取向序参量 $\\psi_6(x,y)$：\n$$\n\\psi_6(x,y) = \\exp\\left(i \\cdot 6 \\cdot \\theta(x,y)\\right)\n$$\n其中 $i$ 是虚数单位。\n\n**b) 二维自相关函数 $G_6(\\Delta \\mathbf{r})$：**\n两点相关函数 $G_6(\\Delta \\mathbf{r}) = \\langle \\psi_6(\\mathbf{r}) \\psi_6^\\ast(\\mathbf{r} + \\Delta \\mathbf{r}) \\rangle$ 是 $\\psi_6$ 场的空间自相关。对于周期系统，这可以使用离散卷积定理（维纳-辛钦定理 Wiener-Khinchin theorem 的一种变体）高效计算。自相关是功率谱密度的傅里叶逆变换：\n$$\nG_6(\\Delta \\mathbf{r}) = \\mathcal{F}^{-1}\\left[ |\\mathcal{F}[\\psi_6(\\mathbf{r})]|^2 \\right]\n$$\n这里，$\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 分别表示二维离散傅里叶正变换和逆变换。$|\\cdot|^2$ 运算给出功率谱。需要通过总网格点数 $N_x N_y$ 进行归一化，以匹配空间平均 $\\langle \\cdot \\rangle$ 的定义。\n\n**c) 径向平均得到 $g_6(r)$：**\n通过壳层平均将二维相关图 $G_6(\\Delta \\mathbf{r})$ 简化为一维径向函数 $g_6(r)$。\n1.  计算以 $\\Delta \\mathbf{r} = (0,0)$ 为中心的位移矢量幅度 $r = \\lVert \\Delta \\mathbf{r} \\rVert$ 的网格。\n2.  相关值 $G_6(\\Delta \\mathbf{r})$ 根据其对应的距离 $r$ 进行分箱。我们使用厚度为 $\\Delta r = 1$ 的壳层，因此第 $j$ 个箱对应于距离 $r \\in [j, j+1)$。\n3.  对于给定的壳层（由其整数半径 $j$ 表示），$g_6(r)$ 的值是落入该壳层的所有 $G_6(\\Delta \\mathbf{r})$ 值的平均值。\n4.  分析在 $r$ 从 $r_{\\min}=2$ 到 $r_{\\max} = \\lfloor \\min(N_x, N_y)/2 \\rfloor$ 的范围内进行。包含少于50个数据点的壳层将被丢弃，以确保统计稳健性。\n\n### 3. 衰减形式的分类\n\n最后阶段是分类计算出的 $g_6(r)$ 的衰减情况，以确定系统的相态。这是一个模型选择问题。\n\n**a) 候选模型：**\n三种候选衰减形式对应于三种相态：\n1.  **类晶体（常数）：** $g_6(r) \\approx C$。长程取向有序。\n2.  **类液体（指数）：** $g_6(r) \\propto \\exp(-r/\\xi)$。具有相关长度 $\\xi$ 的短程有序。\n3.  **类六方相（幂律）：** $g_6(r) \\propto r^{-\\eta_6}$。准长程有序。\n\n**b) 通过线性化进行模型拟合：**\n每个模型都使用普通最小二乘法（OLS）回归，在关系为线性的域中拟合数据 $(r, g_6(r))$：\n-   **常数：** 将 $y=C$ 拟合到 $y=g_6(r)$。最佳拟合是均值，$C = \\langle g_6(r) \\rangle$。\n-   **指数：** 将直线 $y = mx+c$ 拟合到变换后的数据 $y = \\ln g_6(r)$ 和 $x=r$。\n-   **幂律：** 将直线 $y = mx+c$ 拟合到变换后的数据 $y = \\ln g_6(r)$ 和 $x=\\ln r$。\n\n对于指数和幂律拟合，仅使用 $g_6(r) > 0$ 的点。此外，施加了一个物理约束：拟合的斜率 $m$ 必须为负，因为相关性不能随距离增加。斜率为非负的模型被视为无效。\n\n**c) 使用 AIC 进行模型选择：**\n使用赤池信息量准则（Akaike Information Criterion, AIC）来定量选择最佳模型。对于每个拟合模型，AIC 计算如下：\n$$\n\\mathrm{AIC} = n \\cdot \\ln\\left(\\frac{\\mathrm{SSE}}{n}\\right) + 2k\n$$\n其中 $n$ 是拟合中使用的数据点数量，$k$ 是模型中的自由参数数量（常数为 $k=1$，线性拟合为 $k=2$），$\\mathrm{SSE}$ 是在其各自变换域中的误差（残差）平方和。选择具有最低 AIC 的模型作为对数据最合理的描述。应用一个初步的稳健性检查：如果 $g_6(r)$ 的相对标准差小于 0.05，则直接选择常数模型。\n\n最后，将选择的模型映射到一个整数代码：常数（类晶体）$\\to 2$，幂律（类六方相）$\\to 1$，指数（类液体）$\\to 0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n\n    def linear_regression(x, y):\n        \"\"\"\n        Performs a simple Ordinary Least Squares regression.\n        Returns: slope, intercept, Sum of Squared Errors (SSE), and number of points.\n        \"\"\"\n        n = x.size\n        # A model with 2 parameters (slope, intercept) needs at least 2 points.\n        if n  2:\n            return np.nan, np.nan, np.inf, n\n\n        x_mean, y_mean = np.mean(x), np.mean(y)\n        S_xy = np.sum((x - x_mean) * (y - y_mean))\n        S_xx = np.sum((x - x_mean)**2)\n\n        # If all x values are identical, slope is undefined.\n        if S_xx  1e-12:\n            return np.nan, np.nan, np.inf, n\n\n        m = S_xy / S_xx\n        c = y_mean - m * x_mean\n        y_pred = m * x + c\n        sse = np.sum((y - y_pred)**2)\n        return m, c, sse, n\n\n    def generate_angles_gaussian(Nx, Ny, sigma, seed):\n        \"\"\"\n        Generates an angle field with white Gaussian noise.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        theta = rng.normal(loc=0.0, scale=sigma, size=(Ny, Nx))\n        return theta\n\n    def generate_angles_spectral(Nx, Ny, kernel_func, tau, seed):\n        \"\"\"\n        Generates an angle field using spectral synthesis.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        noise_k = rng.standard_normal((Ny, Nx)) + 1j * rng.standard_normal((Ny, Nx))\n\n        kx = np.fft.fftfreq(Nx) * Nx\n        ky = np.fft.fftfreq(Ny) * Ny\n        ky_grid, kx_grid = np.meshgrid(ky, kx, indexing='ij')\n        k_norm = np.sqrt(kx_grid**2 + ky_grid**2)\n\n        A_k = kernel_func(k_norm)\n        A_k[0, 0] = 0.0\n\n        theta_k = noise_k * A_k\n        theta_real = np.real(np.fft.ifft2(theta_k))\n\n        theta_real -= np.mean(theta_real)\n        std_dev = np.std(theta_real)\n        if std_dev > 1e-9:\n            theta_real *= (tau / std_dev)\n        return theta_real\n\n    def compute_g6(theta):\n        \"\"\"\n        Computes the radial correlation function g6(r) from the angle field.\n        \"\"\"\n        Ny, Nx = theta.shape\n        psi6 = np.exp(1j * 6 * theta)\n\n        psi6_k = np.fft.fft2(psi6)\n        power_spectrum = np.abs(psi6_k)**2\n        autocorr_map = np.real(np.fft.ifft2(power_spectrum)) / (Nx * Ny)\n        G6_map = np.fft.fftshift(autocorr_map)\n\n        r_min = 2\n        r_max = int(np.floor(min(Nx, Ny) / 2))\n\n        dx = np.fft.fftshift(np.fft.fftfreq(Nx) * Nx)\n        dy = np.fft.fftshift(np.fft.fftfreq(Ny) * Ny)\n        dy_grid, dx_grid = np.meshgrid(dy, dx, indexing='ij')\n        dist_grid = np.sqrt(dx_grid**2 + dy_grid**2)\n\n        r_vals, g6_vals = [], []\n        for r_int in range(r_min, r_max + 1):\n            mask = (dist_grid >= r_int)  (dist_grid  r_int + 1)\n            if np.sum(mask) >= 50:\n                shell_avg = np.mean(G6_map[mask])\n                # Use midpoint of the shell for the radial coordinate\n                r_vals.append(r_int + 0.5)\n                g6_vals.append(shell_avg)\n\n        return np.array(r_vals), np.array(g6_vals)\n\n    def classify_decay(r, g6):\n        \"\"\"\n        Classifies the decay form of g6(r) using model fitting and AIC.\n        Returns integer code: 2 (crystal), 1 (hexatic), 0 (liquid).\n        \"\"\"\n        if r.size  2:\n            return 0  # Default to liquid-like if not enough data points\n\n        g6_mean = np.mean(g6)\n        if g6_mean != 0:\n            rel_std_dev = np.std(g6) / np.abs(g6_mean)\n            if rel_std_dev  0.05:\n                return 2  # Crystal-like by robustness check\n\n        aics = {}\n        \n        # Model 2: Constant (crystal-like)\n        n_const = g6.size\n        k_const = 1\n        sse_const = np.sum((g6 - g6_mean)**2)\n        if sse_const = 1e-12:\n            aics[2] = -np.inf\n        else:\n            aics[2] = n_const * np.log(sse_const / n_const) + 2 * k_const\n        \n        # Filter data for log-based fits\n        pos_mask = g6 > 1e-12\n        r_pos, g6_pos = r[pos_mask], g6[pos_mask]\n\n        if r_pos.size > 0:\n            # Model 0: Exponential (liquid-like)\n            m_exp, _, sse_exp, n_exp = linear_regression(r_pos, np.log(g6_pos))\n            k_exp = 2\n            if n_exp >= k_exp and m_exp  0:\n                if sse_exp = 1e-12:\n                    aics[0] = -np.inf\n                else:\n                    aics[0] = n_exp * np.log(sse_exp / n_exp) + 2 * k_exp\n            else:\n                aics[0] = np.inf\n\n            # Model 1: Power-law (hexatic-like)\n            m_pow, _, sse_pow, n_pow = linear_regression(np.log(r_pos), np.log(g6_pos))\n            k_pow = 2\n            if n_pow >= k_pow and m_pow  0:\n                if sse_pow = 1e-12:\n                    aics[1] = -np.inf\n                else:\n                    aics[1] = n_pow * np.log(sse_pow / n_pow) + 2 * k_pow\n            else:\n                aics[1] = np.inf\n        else: # No positive g6 values\n            aics[0] = np.inf\n            aics[1] = np.inf\n\n        if not aics or all(v == np.inf for v in aics.values()):\n            return 0  # Default if no model is valid\n\n        best_class = min(aics, key=aics.get)\n        return best_class\n\n    test_cases = [\n        # Case A: Crystal-like\n        {'type': 'gaussian', 'Nx': 48, 'Ny': 48, 'params': {'sigma': 0.03, 'seed': 11}},\n        # Case B: Hexatic-like\n        {'type': 'spectral', 'Nx': 64, 'Ny': 64, 'params': {'gamma': 2.5, 'tau': 0.6, 'seed': 7}},\n        # Case C: Liquid-like\n        {'type': 'spectral', 'Nx': 64, 'Ny': 64, 'params': {'kappa': 1.0, 'tau': 1.0, 'seed': 5}},\n        # Case D: Noisier crystal\n        {'type': 'gaussian', 'Nx': 48, 'Ny': 48, 'params': {'sigma': 0.10, 'seed': 19}},\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        params = case['params']\n        \n        if case['type'] == 'gaussian':\n            theta = generate_angles_gaussian(Nx, Ny, params['sigma'], params['seed'])\n        else: # case['type'] == 'spectral'\n            if 'gamma' in params:\n                gamma = params['gamma']\n                kernel = lambda k: np.power(k, -gamma, where=k != 0, out=np.zeros_like(k, dtype=float))\n            else: # 'kappa' in params\n                kappa = params['kappa']\n                kernel = lambda k: 1.0 / (k**2 + kappa**2)\n            theta = generate_angles_spectral(Nx, Ny, kernel, params['tau'], params['seed'])\n        \n        r, g6 = compute_g6(theta)\n        classification = classify_decay(r, g6)\n        results.append(classification)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486855"}, {"introduction": "长程序是如何从短程序涨落中产生的？本练习将带你进入临界现象的核心，利用有限尺寸标度（finite-size scaling）这一强大工具来研究相变过程。你将通过生成并分析模拟数据，学习如何“折叠”不同系统尺寸下的观测量，以揭示普适的标度行为，并量化在有限系统中短程关联如何掩盖真实的长程有序性[@problem_id:3486915]。此练习对于从计算模拟中精确确定相变点和临界指数至关重要。", "problem": "您的任务是设计并评估一种在临界温度附近对热力学可观测量进行的有限尺寸标度分析。您的程序必须根据有限尺寸标度假设的基本原理和基本统计定义来实现以下内容。核心计算任务是：(i) 针对不同系统尺寸和温度，为序参量和磁化率生成类似蒙特卡洛的合成数据；(ii) 使用指定的临界参数估计值进行标度坍缩；(iii) 通过归一化方差度量来量化坍缩的质量；以及 (iv) 通过基于关联长度的准则来量化短程有序在小系统尺寸下的主导程度。\n\n基本定义与假设：\n- 对于临界温度 $T_c$ 附近的标量序参量 $m$ 和磁化率 $\\chi$，有限尺寸标度假设假定存在以标度变量 $u$ 表示的标度不变形式，其中 $u$ 由下式给出\n$$u = (T - T_c)\\,L^{1/\\nu},$$\n以及标度律\n$$m(L,T) = L^{-\\beta/\\nu}\\,f_m(u), \\quad \\chi(L,T) = L^{\\gamma/\\nu}\\,f_\\chi(u),$$\n其中 $L$ 是线性系统尺寸，$T$ 是温度，$\\beta$、$\\nu$ 和 $\\gamma$ 是临界指数，$f_m$ 和 $f_\\chi$ 是标度函数。\n- 有限系统中的短程有序（SRO）与长程有序（LRO）可以通过关联长度 $\\xi(T)$ 来评估，假设其遵循发散关系 $\\xi(T)=\\xi_0\\,|t|^{-\\nu}$，其中约化温度 $t=(T-T_c)/T_c$，并实际上受限于有限的系统范围。当 $\\xi(T)$ 占 $L$ 的一个显著比例时，有限尺寸的圆滑效应会掩盖真实长程有序的缺失。我们通过条件 $\\xi(T) > r_0\\,L$（其中 $r_0$ 是预设的阈值比率）来操作化定义系统尺寸为 $L$ 时的“短程有序主导”。\n\n合成数据模型：\n- 为了专注于算法方面，您将生成与标度假设一致的合成可观测量。对于每个系统尺寸 $L$ 和温度 $T$，定义无量纲标度变量 $u=(T-T_c^{\\text{true}})\\,L^{1/\\nu^{\\text{true}}}$。使用以下平滑、正值的标度函数：\n$$f_m(u)=\\frac{A_m}{1+\\exp\\!\\left(\\frac{u}{w_m}\\right)}, \\qquad f_\\chi(u)=\\frac{A_\\chi}{1+\\left(\\frac{u}{w_\\chi}\\right)^2}.$$\n然后生成带噪声的合成可观测量\n$$m(L,T)=L^{-\\beta^{\\text{true}}/\\nu^{\\text{true}}}\\,f_m(u)+\\epsilon_m, \\qquad \\chi(L,T)=L^{\\gamma^{\\text{true}}/\\nu^{\\text{true}}}\\,f_\\chi(u)+\\epsilon_\\chi,$$\n其中 $\\epsilon_m$ 和 $\\epsilon_\\chi$ 是独立的零均值高斯噪声项，其标准差分别等于 $\\sigma_m \\times \\left(L^{-\\beta^{\\text{true}}/\\nu^{\\text{true}}}\\,f_m(u)\\right)$ 和 $\\sigma_\\chi \\times \\left(L^{\\gamma^{\\text{true}}/\\nu^{\\text{true}}}\\,f_\\chi(u)\\right)$。由噪声产生的任何负值都必须被截断为 $0$。\n- 使用 $A_m=A_\\chi=1$，$w_m=w_\\chi=2$，以及由固定伪随机数生成器设定种子的独立标准正态偏离量，以确保可复现性。\n\n标度坍缩过程：\n- 给定估计参数 $T_c^{\\text{est}}$、$\\beta^{\\text{est}}$、$\\nu^{\\text{est}}$ 和 $\\gamma^{\\text{est}}$，定义标度化变量\n$$x=(T-T_c^{\\text{est}})\\,L^{1/\\nu^{\\text{est}}}, \\quad y_m = m(L,T)\\,L^{\\beta^{\\text{est}}/\\nu^{\\text{est}}}, \\quad y_\\chi = \\chi(L,T)\\,L^{-\\gamma^{\\text{est}}/\\nu^{\\text{est}}}.$$\n- 对于给定的 $L$ 值集合，在所有曲线的 $x$ 范围的重叠区域内，构建一个包含 $K$ 个在 $x$ 上等间距分布的公共网格。使用 $K=50$。\n- 对于每个 $L$，使用线性插值将 $y_m$ 和 $y_\\chi$ 插值到公共 $x$ 网格上。\n- 将每个可观测量的坍缩质量度量定义为跨尺寸的归一化均方偏差：\n$$Q(y)=\\frac{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\left(y_i(x_k)-\\overline{y}(x_k)\\right)^2}{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\overline{y}(x_k)^2+\\varepsilon},$$\n其中 $N_L$ 是系统尺寸的数量，$\\overline{y}(x_k)$ 是在网格点 $x_k$ 处对所有尺寸的算术平均值，$\\varepsilon=10^{-12}$ 用于防止除以零。计算 $Q_m=Q(y_m)$ 和 $Q_\\chi=Q(y_\\chi)$。较小的 $Q$ 值表示更好的坍缩效果。\n\n短程有序主导度量：\n- 对于给定集合中的最小系统尺寸 $L_{\\min}$，计算关联长度\n$$\\xi(T)=\\xi_0\\,|t|^{-\\nu^{\\text{true}}}, \\quad t=\\frac{T-T_c^{\\text{true}}}{T_c^{\\text{true}}},$$\n使用下限 $|t|\\leftarrow \\max(|t|,t_{\\min})$（其中 $t_{\\min}=10^{-12}$）以避免在 $t=0$ 处发散。\n- 短程有序掩蔽分数是指在抽样温度列表中，满足条件 $\\xi(T)>r_0\\,L_{\\min}$ 的温度所占的比例。以 $[0,1]$ 区间内的小数形式报告此值。\n\n测试套件：\n为以下三个测试用例实现上述内容。对于所有用例，使用相同的温度网格，该网格包含从 $T_c^{\\text{true}}-\\Delta T$到 $T_c^{\\text{true}}+\\Delta T$（含两端）线性间隔的 $N_T=81$ 个点，其中 $\\Delta T=0.4$。对于噪声，使用 $\\sigma_m=\\sigma_\\chi=0.02$，并用种子 $12345$ 初始化伪随机数生成器以抽取独立的标准正态样本。对于短程有序准则，使用 $\\xi_0=0.5$，$r_0=0.5$。以下所有常数必须严格按照规定使用。\n\n- 用例 A (理想情况，预期坍缩效果好):\n  - 真实参数: $T_c^{\\text{true}}=2.269185$, $\\beta^{\\text{true}}=0.125$, $\\nu^{\\text{true}}=1.0$, $\\gamma^{\\text{true}}=1.75$。\n  - 估计参数: $T_c^{\\text{est}}=2.269185$, $\\beta^{\\text{est}}=0.125$, $\\nu^{\\text{est}}=1.0$, $\\gamma^{\\text{est}}=1.75$。\n  - 系统尺寸: $L\\in\\{16,32,64\\}$。\n\n- 用例 B (边界情况，小尺寸；预期在最小L处出现短程有序主导):\n  - 真实参数: $T_c^{\\text{true}}=2.269185$, $\\beta^{\\text{true}}=0.125$, $\\nu^{\\text{true}}=1.0$, $\\gamma^{\\text{true}}=1.75$。\n  - 估计参数: $T_c^{\\text{est}}=2.269185$, $\\beta^{\\text{est}}=0.125$, $\\nu^{\\text{est}}=1.0$, $\\gamma^{\\text{est}}=1.75$。\n  - 系统尺寸: $L\\in\\{8,12,16\\}$。\n\n- 用例 C (边缘情况，临界参数指定错误；预期坍缩效果差):\n  - 真实参数: $T_c^{\\text{true}}=2.269185$, $\\beta^{\\text{true}}=0.125$, $\\nu^{\\text{true}}=1.0$, $\\gamma^{\\text{true}}=1.75$。\n  - 估计参数: $T_c^{\\text{est}}=2.24$, $\\beta^{\\text{est}}=0.14$, $\\nu^{\\text{est}}=0.9$, $\\gamma^{\\text{est}}=1.6$。\n  - 系统尺寸: $L\\in\\{24,48,96\\}$。\n\n不涉及角度单位。输出不需要物理单位。\n\n要求的输出：\n- 对于每个用例，计算并返回三元组 $\\left[Q_m,Q_\\chi,\\phi_{\\text{SRO}}\\right]$，其中 $\\phi_{\\text{SRO}}$ 是该用例中最小 $L$ 的短程有序掩蔽分数。\n- 您的程序应生成单行输出，其中包含所有三个三元组，扁平化为一个包含9个浮点数的列表，每个值四舍五入到6位小数，顺序如下： $\\left[Q_m^{(A)},Q_\\chi^{(A)},\\phi_{\\text{SRO}}^{(A)},Q_m^{(B)},Q_\\chi^{(B)},\\phi_{\\text{SRO}}^{(B)},Q_m^{(C)},Q_\\chi^{(C)},\\phi_{\\text{SRO}}^{(C)}\\right]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如， $\\left[\\text{result1},\\text{result2},\\ldots,\\text{result9}\\right]$。", "solution": "用户提供了一个基于计算统计物理学原理的问题，特别是临界现象和有限尺寸标度理论。问题陈述在科学上是合理的，内容自洽，并且在算法上定义明确。所有必需的参数、方程和程序都已指定，从而能够得到一个唯一且可验证的解。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n核心任务是实现并测试一个有限尺寸标度分析流程。这涉及三个主要阶段：生成模拟临界点附近可观测量的合成数据，对该数据进行标度坍缩，以及定量评估此坍缩的质量。一项次要分析是量化小系统尺寸下短程有序效应的主导程度。\n\n### 1. 合成数据生成\n\n此分析的基础是有限尺寸标度假设，它描述了热力学量在有限线性尺寸 $L$ 的系统中，在临界温度 $T_c$ 附近的行为。对于一个标量序参量 $m$ 及其对应的磁化率 $\\chi$，该假设设定：\n$$m(L,T) = L^{-\\beta/\\nu}\\,f_m(u)$$\n$$\\chi(L,T) = L^{\\gamma/\\nu}\\,f_\\chi(u)$$\n其中 $\\beta$、$\\gamma$ 和 $\\nu$ 是普适临界指数，$f_m$ 和 $f_\\chi$ 是标度变量 $u = (T - T_c)\\,L^{1/\\nu}$ 的普适标度函数。\n\n为了测试我们的分析算法，我们首先生成在构造上遵循这些标度律的合成数据。我们使用一组“真实”参数（$T_c^{\\text{true}}$、$\\beta^{\\text{true}}$、$\\nu^{\\text{true}}$、$\\gamma^{\\text{true}}$）和标度函数的具体形式：\n$$f_m(u)=\\frac{A_m}{1+\\exp(u/w_m)}, \\quad f_\\chi(u)=\\frac{A_\\chi}{1+(u/w_\\chi)^2}$$\n其中常数 $A_m=1$，$A_\\chi=1$，$w_m=2$，$w_\\chi=2$。\n\n对于每对系统尺寸 $L$ 和温度 $T$，我们首先计算理想的、无噪声的可观测量。然后，我们引入随机性来模拟蒙特卡洛模拟中固有的统计涨落。这是通过添加高斯噪声来实现的，噪声的标准差与可观测量本身的大小成正比，相对噪声水平为 $\\sigma_m=0.02$ 和 $\\sigma_\\chi=0.02$。带噪声的可观测量为：\n$$m(L,T) = L^{-\\beta^{\\text{true}}/\\nu^{\\text{true}}}\\,f_m(u) + \\epsilon_m$$\n$$\\chi(L,T) = L^{\\gamma^{\\text{true}}/\\nu^{\\text{true}}}\\,f_\\chi(u) + \\epsilon_\\chi$$\n此处，$\\epsilon_m$ 和 $\\epsilon_\\chi$ 从均值为 $0$ 且标准差与理想值成比例的高斯分布中抽取。对于这些物理量而言，任何由此产生的非物理的负值 $m$ 或 $\\chi$ 都将被截断为 $0$。使用固定种子的伪随机数生成器确保了可复现性。\n\n### 2. 标度坍缩与质量度量\n\n有限尺寸标度分析的核心目标是将来自不同系统尺寸 $L$ 的数据“坍缩”到一条单一的普适曲线上。这是通过使用一组*估计*参数（$T_c^{\\text{est}}$、$\\beta^{\\text{est}}$、$\\nu^{\\text{est}}$、$\\gamma^{\\text{est}}$）来反转标度关系实现的。我们定义标度化变量：\n$$x=(T-T_c^{\\text{est}})\\,L^{1/\\nu^{\\text{est}}}$$\n$$y_m = m(L,T)\\,L^{\\beta^{\\text{est}}/\\nu^{\\text{est}}}$$\n$$y_\\chi = \\chi(L,T)\\,L^{-\\gamma^{\\text{est}}/\\nu^{\\text{est}}}$$\n如果估计的参数与真实的底层参数相匹配，那么对于所有不同尺寸 $L$，绘制的 $y_m$ vs. $x$（以及 $y_\\chi$ vs. $x$）曲线应该会重叠，分别形成主曲线 $f_m(x)$ 和 $f_\\chi(x)$。\n\n为了定量评估这种坍缩的质量，我们遵循一个数值程序。首先，由于不同 $L$ 的数据点不共享公共的 $x$ 坐标，我们建立一个公共网格。该网格包含 $K=50$ 个点，在所有系统尺寸共有的 $x$ 值范围内线性间隔分布。然后，我们使用线性插值来获得每个 $L$ 在此公共网格上的 $y_m$ 和 $y_\\chi$ 值。\n\n将数据插值到公共基准上后，我们就可以计算一个质量因子 $Q$。该度量被定义为单个曲线与其均值之间的归一化均方偏差：\n$$Q(y)=\\frac{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\left(y_i(x_k)-\\overline{y}(x_k)\\right)^2}{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\overline{y}(x_k)^2+\\varepsilon}$$\n其中 $y_i(x_k)$ 是第 $i$ 个系统尺寸在第 $k$ 个网格点上的插值，$ \\overline{y}(x_k)$ 是在该网格点上对所有 $N_L$ 个系统尺寸的平均值，而 $\\varepsilon=10^{-12}$ 是一个小的正则化项。较小的 $Q$ 值表示良好的坍缩，表明估计的参数可能接近真实值。我们为序参量（$Q_m$）和磁化率（$Q_\\chi$）都计算这个度量。\n\n### 3. 短程有序（SRO）主导\n\n在无限系统中，关联长度 $\\xi(T)$ 在临界点 $T_c$ 处根据 $\\xi(T) = \\xi_0\\,|t|^{-\\nu}$ 发散，其中 $t = (T-T_c)/T_c$ 是约化温度。在尺寸为 $L$ 的有限系统中，关联不能延伸到系统边界之外。当理论关联长度 $\\xi(T)$ 变得与 $L$ 相当或更大时，系统的行为受其有限范围的支配。这种“有限尺寸圆滑效应”会模糊真实的临界行为，并模拟出有序状态，即使真正的长程有序尚未建立。这个区域可以被描述为由短程有序（SRO）主导。\n\n我们量化了这种效应在给定集合中最小系统尺寸 $L_{\\min}$ 下的普遍程度。我们定义，如果在温度 $T$ 下满足条件 $\\xi(T)  r_0\\,L_{\\min}$，则发生“短程有序主导”，其中使用提供的参数 $\\xi_0=0.5$ 和 $r_0=0.5$。然后，短程有序掩蔽分数 $\\phi_{\\text{SRO}}$ 被计算为模拟温度中满足此条件的温度所占的比例。为避免在 $T=T_c$ 处出现奇点，在计算 $\\xi(T)$ 时，为约化温度 $|t|$ 设置了一个数值下限 $t_{\\min}=10^{-12}$。较高的 $\\phi_{\\text{SRO}}$ 值表明，在 $T_c$ 附近温度范围的很大一部分内，最小系统尺寸的物理行为主要受有限尺寸效应而非真实临界标度行为的主导。\n\n### 4. 测试用例的实现\n\n上述程序应用于三个不同的测试用例。\n- **用例 A** 作为基准，其中用于坍缩的估计参数与用于数据生成的真实参数相同。预期会得到高质量的坍缩（低 $Q$ 值）。\n- **用例 B** 使用正确的参数，但侧重于更小的系统尺寸。预期这将显示出良好的坍缩，但短程有序掩蔽分数会更高，表明在较小的模拟中有限尺寸效应的重要性增加。\n- **用例 C** 使用故意设置不正确的估计参数。预期这将导致数据坍缩效果差，从而产生大的 $Q$ 值，表明该方法对临界参数选择的敏感性。\n\n对于每个用例，算法计算三元组 $[Q_m, Q_\\chi, \\phi_{\\text{SRO}}]$，最终输出是所有三个用例结果的扁平化列表。", "answer": "```python\nimport numpy as np\n\ndef _generate_synthetic_data(L_list, T_grid, true_params, noise_params, rng):\n    \"\"\"Generates synthetic data for m and chi based on scaling laws.\"\"\"\n    data = {'m': {}, 'chi': {}}\n    \n    A_m, w_m = 1.0, 2.0\n    A_chi, w_chi = 1.0, 2.0\n    \n    Tc_true = true_params['Tc']\n    beta_true = true_params['beta']\n    nu_true = true_params['nu']\n    gamma_true = true_params['gamma']\n    \n    sigma_m_rel = noise_params['sigma_m']\n    sigma_chi_rel = noise_params['sigma_chi']\n\n    for L in L_list:\n        u = (T_grid - Tc_true) * (L**(1.0 / nu_true))\n        \n        f_m_u = A_m / (1.0 + np.exp(u / w_m))\n        f_chi_u = A_chi / (1.0 + (u / w_chi)**2)\n        \n        m_true = (L**(-beta_true / nu_true)) * f_m_u\n        chi_true = (L**(gamma_true / nu_true)) * f_chi_u\n        \n        noise_m_std = sigma_m_rel * m_true\n        noise_chi_std = sigma_chi_rel * chi_true\n        \n        epsilon_m = rng.normal(loc=0.0, scale=noise_m_std)\n        epsilon_chi = rng.normal(loc=0.0, scale=noise_chi_std)\n        \n        m_noisy = m_true + epsilon_m\n        chi_noisy = chi_true + epsilon_chi\n        \n        # Clip to 0 for non-physical negative values\n        data['m'][L] = np.maximum(0, m_noisy)\n        data['chi'][L] = np.maximum(0, chi_noisy)\n        \n    return data\n\ndef _calculate_collapse_quality(data_obs, L_list, T_grid, est_params, K=50, epsilon=1e-12):\n    \"\"\"Performs scaling collapse and computes the quality metric Q.\"\"\"\n    \n    Tc_est = est_params['Tc']\n    beta_est = est_params['beta']\n    nu_est = est_params['nu']\n    gamma_est = est_params['gamma']\n    \n    scaled_curves_m = {}\n    scaled_curves_chi = {}\n    x_ranges = []\n\n    for L in L_list:\n        m_L = data_obs['m'][L]\n        chi_L = data_obs['chi'][L]\n        \n        x = (T_grid - Tc_est) * (L**(1.0 / nu_est))\n        y_m = m_L * (L**(beta_est / nu_est))\n        y_chi = chi_L * (L**(-gamma_est / nu_est))\n        \n        scaled_curves_m[L] = {'x': x, 'y': y_m}\n        scaled_curves_chi[L] = {'x': x, 'y': y_chi}\n        x_ranges.append((np.min(x), np.max(x)))\n        \n    # Find common x range for interpolation\n    x_min_common = max(r[0] for r in x_ranges)\n    x_max_common = min(r[1] for r in x_ranges)\n    x_common_grid = np.linspace(x_min_common, x_max_common, K)\n    \n    # Calculate Q for order parameter m\n    N_L = len(L_list)\n    y_m_interp = np.zeros((N_L, K))\n    for i, L in enumerate(L_list):\n        y_m_interp[i, :] = np.interp(x_common_grid, scaled_curves_m[L]['x'], scaled_curves_m[L]['y'])\n    \n    y_m_mean = np.mean(y_m_interp, axis=0)\n    num_m = np.sum((y_m_interp - y_m_mean)**2)\n    den_m = N_L * np.sum(y_m_mean**2) + epsilon\n    Qm = num_m / den_m\n    \n    # Calculate Q for susceptibility chi\n    y_chi_interp = np.zeros((N_L, K))\n    for i, L in enumerate(L_list):\n        y_chi_interp[i, :] = np.interp(x_common_grid, scaled_curves_chi[L]['x'], scaled_curves_chi[L]['y'])\n        \n    y_chi_mean = np.mean(y_chi_interp, axis=0)\n    num_chi = np.sum((y_chi_interp - y_chi_mean)**2)\n    den_chi = N_L * np.sum(y_chi_mean**2) + epsilon\n    Qchi = num_chi / den_chi\n\n    return Qm, Qchi\n\ndef _calculate_sro_fraction(L_min, T_grid, true_params, sro_params):\n    \"\"\"Calculates the SRO-masking fraction for the smallest system size.\"\"\"\n    \n    Tc_true = true_params['Tc']\n    nu_true = true_params['nu']\n    \n    xi_0 = sro_params['xi_0']\n    r_0 = sro_params['r_0']\n    t_min = sro_params['t_min']\n    \n    t = (T_grid - Tc_true) / Tc_true\n    t_abs_floored = np.maximum(np.abs(t), t_min)\n    \n    xi_T = xi_0 * (t_abs_floored**(-nu_true))\n    \n    sro_dominant_count = np.sum(xi_T > r_0 * L_min)\n    \n    sro_fraction = sro_dominant_count / len(T_grid)\n    \n    return sro_fraction\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the finite-size scaling analysis for all test cases.\n    \"\"\"\n    \n    # Define test cases\n    test_cases = [\n        # Case A\n        {\n            \"true_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"est_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"L_list\": [16, 32, 64]\n        },\n        # Case B\n        {\n            \"true_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"est_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"L_list\": [8, 12, 16]\n        },\n        # Case C\n        {\n            \"true_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"est_params\": {'Tc': 2.24, 'beta': 0.14, 'nu': 0.9, 'gamma': 1.6},\n            \"L_list\": [24, 48, 96]\n        }\n    ]\n\n    # Global parameters\n    NT = 81\n    delta_T = 0.4\n    noise_params = {'sigma_m': 0.02, 'sigma_chi': 0.02}\n    sro_params = {'xi_0': 0.5, 'r_0': 0.5, 't_min': 1e-12}\n    K = 50\n    rng = np.random.default_rng(12345)\n    \n    results = []\n\n    for case in test_cases:\n        true_params = case[\"true_params\"]\n        est_params = case[\"est_params\"]\n        L_list = case[\"L_list\"]\n        L_min = min(L_list)\n        \n        # Temperature grid is centered on the true critical temperature\n        T_grid = np.linspace(true_params['Tc'] - delta_T, true_params['Tc'] + delta_T, NT)\n        \n        # Generate synthetic data\n        data = _generate_synthetic_data(L_list, T_grid, true_params, noise_params, rng)\n        \n        # Calculate collapse quality\n        Qm, Qchi = _calculate_collapse_quality(data, L_list, T_grid, est_params, K=K)\n        \n        # Calculate SRO fraction\n        sro_frac = _calculate_sro_fraction(L_min, T_grid, true_params, sro_params)\n        \n        results.extend([Qm, Qchi, sro_frac])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3486915"}]}