{"hands_on_practices": [{"introduction": "本实践探讨了在使用周期性边界条件的分子动力学模拟中的一个基本问题：模拟盒子应该设置多大？我们将通过一个物理模型，学习如何估算位移级联模拟所需的最小盒子尺寸，以避免级联事件与其自身的周期性镜像发生非物理的相互作用 [@problem_id:3484027]。这个练习将级联现象的物理图像（弹道相和热峰相）与模拟设置的实际需求紧密联系起来，是确保模拟结果可靠性的关键一步。", "problem": "我们使用周期性边界条件 (PBC) 对晶体固体中的位移级联进行分子动力学模拟。为避免级联与其周期性镜像之间的虚假相互作用，模拟盒子必须足够大，以确保在整个事件期间，级联引起的原子重新分布区域与其最近的周期性镜像的相应区域不发生重叠。考虑以下基于物理的模型：\n\n- 级联的弹道相瞬间在半径为 $R_{c}$ 的近似球形区域内产生一个位移核心。\n- 在随后持续时间为 $\\tau_{\\mathrm{ts}}$ 的热峰期间，瞬时无序区内的原子进行类液态自扩散，该过程可很好地近似为菲克扩散，其有效自扩散系数为 $D_{\\mathrm{liq}}$，并假定在 $\\tau_{\\mathrm{ts}}$ 期间为常数。\n- 模拟盒子是边长为 $L$ 的立方体，因此最近镜像间距为 $L$。\n\n采用以下非重叠准则：级联的有效径向范围，定义为弹道半径加上热峰期间累积的一个均方根扩散长度，必须严格小于最近镜像间距的一半。从扩散方程和均方位移的定义出发，推导出满足此准则的最小盒子长度 $L_{\\min}$ 的表达式，该表达式用 $R_{c}$、$D_{\\mathrm{liq}}$ 和 $\\tau_{\\mathrm{ts}}$ 表示。然后使用参数 $R_{c} = 4.2 \\ \\text{nm}$，$D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$ 和 $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps}$ 计算 $L_{\\min}$ 的值。以纳米为单位表示最终结果，并将答案四舍五入到三位有效数字。", "solution": "首先验证问题，以确保其科学上合理、问题明确且完整。\n\n### 步骤 1：提取已知条件\n- **系统**：晶体固体中位移级联的分子动力学模拟。\n- **边界条件**：周期性边界条件 (PBC)。\n- **模拟盒子**：边长为 $L$ 的立方体。\n- **最近镜像间距**：$L$。\n- **级联模型**：\n    - 初始弹道相在半径为 $R_{c}$ 的球形核心内产生位移。\n    - 随后发生持续时间为 $\\tau_{\\mathrm{ts}}$ 的热峰相。\n    - 在热峰期间，原子自扩散被建模为菲克扩散，扩散系数 $D_{\\mathrm{liq}}$ 为常数。\n- **非重叠准则**：级联的有效径向范围必须严格小于最近镜像间距的一半。\n- **有效径向范围的定义**：$R_{\\mathrm{eff}} = R_{c} + \\ell_{\\mathrm{rms}}$，其中 $\\ell_{\\mathrm{rms}}$ 是热峰期间累积的一个均方根扩散长度。\n- **任务**：\n    1. 推导出最小盒子长度 $L_{\\min}$ 关于 $R_{c}$、$D_{\\mathrm{liq}}$ 和 $\\tau_{\\mathrm{ts}}$ 的表达式。\n    2. 使用参数 $R_{c} = 4.2 \\ \\text{nm}$，$D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$ 和 $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps}$ 计算 $L_{\\min}$ 的值。\n- **最终结果要求**：以纳米为单位表示最终数值答案，并四舍五入到三位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在计算材料科学和统计物理学原理方面有充分的依据。所描述的模型（弹道相后跟带菲克扩散的热峰）是用于分析位移级联的标准且有物理动机的简化方法。PBC 的使用以及对有限尺寸效应（虚假镜像相互作用）的关注是分子动力学模拟实践的核心。\n- **问题明确**：该问题是明确的。它提供了清晰的定量准则和足够的数据，以推导 $L_{\\min}$ 的唯一表达式，然后计算其数值。\n- **客观性**：该问题使用客观、精确的科学语言陈述。\n- **完整性与一致性**：该问题是自洽的。所有必要的变量和常数都已定义，并为其数值部分提供了值。单位是一致的，尽管最终计算需要进行单位转换。没有矛盾之处。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解题推导\n\n该问题要求基于非重叠准则，推导出最小模拟盒子长度 $L_{\\min}$ 的表达式。\n\n非重叠准则指出，级联的有效径向范围 $R_{\\mathrm{eff}}$ 必须严格小于最近镜像间距的一半，即 $\\frac{L}{2}$。\n$$ R_{\\mathrm{eff}}  \\frac{L}{2} $$\n有效径向范围定义为弹道核心半径 $R_{c}$ 和一个均方根扩散长度 $\\ell_{\\mathrm{rms}}$ 的和。\n$$ R_{\\mathrm{eff}} = R_{c} + \\ell_{\\mathrm{rms}} $$\n将此定义代入准则中可得：\n$$ R_{c} + \\ell_{\\mathrm{rms}}  \\frac{L}{2} $$\n最小盒子长度 $L_{\\min}$ 对应于此条件的边界：\n$$ \\frac{L_{\\min}}{2} = R_{c} + \\ell_{\\mathrm{rms}} $$\n$$ L_{\\min} = 2(R_{c} + \\ell_{\\mathrm{rms}}) $$\n要继续推导，我们必须找到 $\\ell_{\\mathrm{rms}}$ 的表达式。均方根扩散长度是均方位移 (MSD) $\\langle r^{2} \\rangle$ 的平方根。对于在时间 $\\tau_{\\mathrm{ts}}$ 内发生的扩散，我们有：\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{\\langle r^{2}(\\tau_{\\mathrm{ts}}) \\rangle} $$\n问题要求我们从扩散方程出发来确定 MSD。扩散方程，即菲克第二定律，对于扩散粒子浓度 $C(\\mathbf{r}, t)$ 而言为：\n$$ \\frac{\\partial C(\\mathbf{r}, t)}{\\partial t} = D_{\\mathrm{liq}} \\nabla^{2} C(\\mathbf{r}, t) $$\n三维空间中的均方位移定义为位置矢量 $\\mathbf{r}$ 的二阶矩：\n$$ \\langle r^{2}(t) \\rangle = \\int r^{2} C(\\mathbf{r}, t) \\, dV $$\n其中积分遍及整个空间。我们假设浓度分布是归一化的，使得 $\\int C(\\mathbf{r}, t) \\, dV = 1$。为了找到 MSD 的时间演化，我们对时间求导：\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = \\int r^{2} \\frac{\\partial C(\\mathbf{r}, t)}{\\partial t} \\, dV $$\n代入扩散方程：\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = \\int r^{2} (D_{\\mathrm{liq}} \\nabla^{2} C) \\, dV = D_{\\mathrm{liq}} \\int r^{2} (\\nabla \\cdot \\nabla C) \\, dV $$\n我们使用三维分部积分法，其形式为 $\\int u (\\nabla \\cdot \\mathbf{F}) dV = \\oint_{\\partial V} u \\mathbf{F} \\cdot d\\mathbf{S} - \\int (\\nabla u) \\cdot \\mathbf{F} dV$。令 $u = r^{2}$ 和 $\\mathbf{F} = \\nabla C$。积分遍及整个空间，因此边界 $\\partial V$ 在无穷远处。由于对于局域分布，$C$ 及其梯度 $\\nabla C$ 在无穷远处必须为零，因此面积分为零。\n$$ \\int r^{2} (\\nabla \\cdot \\nabla C) \\, dV = - \\int (\\nabla r^{2}) \\cdot (\\nabla C) \\, dV $$\n$r^{2} = x^{2} + y^{2} + z^{2}$ 的梯度为 $\\nabla r^{2} = 2x\\hat{\\mathbf{i}} + 2y\\hat{\\mathbf{j}} + 2z\\hat{\\mathbf{k}} = 2\\mathbf{r}$。\n$$ \\int r^{2} (\\nabla^{2} C) \\, dV = - \\int (2\\mathbf{r}) \\cdot (\\nabla C) \\, dV = -2 \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV $$\n我们对剩余的积分再次应用分部积分法。令 $u=C$ 和 $\\mathbf{F}=\\mathbf{r}$。其形式为 $\\int \\mathbf{F} \\cdot (\\nabla u) dV = \\oint_{\\partial V} u\\mathbf{F} \\cdot d\\mathbf{S} - \\int u(\\nabla \\cdot \\mathbf{F}) dV$。同样，无穷远处的面积分为零。\n$$ \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = - \\int C (\\nabla \\cdot \\mathbf{r}) \\, dV $$\n三维中位置矢量的散度为 $\\nabla \\cdot \\mathbf{r} = \\frac{\\partial x}{\\partial x} + \\frac{\\partial y}{\\partial y} + \\frac{\\partial z}{\\partial z} = 1+1+1 = 3$。\n$$ \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = - \\int C (3) \\, dV = -3 \\int C \\, dV $$\n由于浓度是归一化的，$\\int C \\, dV = 1$。因此，$\\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = -3$。\n将此代回，我们得到：\n$$ \\int r^{2} (\\nabla^{2} C) \\, dV = -2(-3) = 6 $$\n现在我们可以完成 MSD 时间导数的表达式：\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = D_{\\mathrm{liq}} (6) = 6D_{\\mathrm{liq}} $$\n将此常微分方程从 $t=0$ 积分到 $t=\\tau_{\\mathrm{ts}}$，并假设初始位移为零（对于扩散部分 $\\langle r^{2}(0) \\rangle = 0$），我们得到三维中的爱因斯坦-斯莫鲁霍夫斯基关系：\n$$ \\langle r^{2}(\\tau_{\\mathrm{ts}}) \\rangle = 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} $$\n因此，均方根扩散长度为：\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}}} $$\n最后，我们将此表达式代入 $L_{\\min}$ 的方程中：\n$$ L_{\\min} = 2(R_{c} + \\sqrt{6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}}}) $$\n这就是所要求的最小盒子长度的符号表达式。\n\n### 数值计算\n接下来，我们使用给定的参数计算 $L_{\\min}$。首先，我们必须确保所有单位一致。我们将所有量转换为国际单位制（米、秒）。\n\n- $R_{c} = 4.2 \\ \\text{nm} = 4.2 \\times 10^{-9} \\ \\text{m}$\n- $D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$\n- $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps} = 12 \\times 10^{-12} \\ \\text{s}$\n\n首先，我们计算平方根内的数值：\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = 6 \\times (2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}) \\times (12 \\times 10^{-12} \\ \\text{s}) $$\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = (15 \\times 10^{-8}) \\times (12 \\times 10^{-12}) \\ \\text{m}^{2} $$\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = 180 \\times 10^{-20} \\ \\text{m}^{2} = 1.8 \\times 10^{-18} \\ \\text{m}^{2} $$\n现在，我们计算均方根扩散长度 $\\ell_{\\mathrm{rms}}$：\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{1.8 \\times 10^{-18} \\ \\text{m}^{2}} = \\sqrt{1.8} \\times 10^{-9} \\ \\text{m} $$\n$$ \\ell_{\\mathrm{rms}} \\approx 1.34164 \\times 10^{-9} \\ \\text{m} = 1.34164 \\ \\text{nm} $$\n现在我们可以计算 $L_{\\min}$：\n$$ L_{\\min} = 2(R_{c} + \\ell_{\\mathrm{rms}}) = 2(4.2 \\ \\text{nm} + 1.34164 \\ \\text{nm}) $$\n$$ L_{\\min} = 2(5.54164 \\ \\text{nm}) $$\n$$ L_{\\min} \\approx 11.08328 \\ \\text{nm} $$\n问题要求答案四舍五入到三位有效数字。\n$$ L_{\\min} \\approx 11.1 \\ \\text{nm} $$\n最终结果为 $11.1$。", "answer": "$$\n\\boxed{11.1}\n$$", "id": "3484027"}, {"introduction": "真实的级联模拟必须精确地描述能量如何从高能离子传递到材料中，其中一个关键机制是与电子的相互作用，即电子阻止。本实践将指导您从头开始，在一个简化的一维模型中实现并校准一个依赖于速度的电子阻止力 [@problem_id:3484083]。通过这个练习，您将掌握如何将表格化的实验或理论数据（例如 SRIM 数据）转化为一个可在模拟中使用的连续函数，并学会如何在一个存在能量耗散的系统中验证数值积分的能量守恒性。", "problem": "要求您在纯元素中自离子的最小分子动力学（MD）背景下，推导、校准并测试一种与速度成正比的电子阻止力。您将实现一个单一的抛射铁（Fe）原子，在模拟电子阻止的耗散力作用下进行运动，并通过明确地将传递给电子的能量作为耗散变量来分析数值能量守恒。\n\n基本原理和定义：\n- 电子阻止力定义为一种与速度成正比的阻力，形式为 $\\mathbf{F}_{\\mathrm{stop}}=-S_{e}(v)\\,\\hat{\\mathbf{v}}$，其中 $v=\\lVert \\mathbf{v}\\rVert$ 是速率，$\\hat{\\mathbf{v}}=\\mathbf{v}/\\lVert \\mathbf{v}\\rVert$ 是单位速度方向，而 $S_{e}(v)$ 是电子阻止本领。\n- 阻止本领定义为单位路径长度的能量损失，因此对于抛射物动能 $E$，有 $\\mathrm{d}E/\\mathrm{d}x=-S_{e}(v)$。\n- 质量为 $m$、速率为 $v$ 的点粒子的动能是 $E=\\tfrac{1}{2} m v^{2}$。\n- 阻止力做功的速率等于 $\\mathrm{d}E/\\mathrm{d}t=\\mathbf{F}_{\\mathrm{stop}}\\cdot \\mathbf{v}=-S_{e}(v)\\,v$，这意味着 $\\mathrm{d}E/\\mathrm{d}x = (\\mathrm{d}E/\\mathrm{d}t)/(\\mathrm{d}x/\\mathrm{d}t)=-S_{e}(v)$，与定义一致。\n\n单位与数值系统：\n- 能量使用电子伏特（$\\mathrm{eV}$），长度使用埃（$\\mathrm{\\AA}$），时间使用飞秒（$\\mathrm{fs}$）。在这些单位中，质量将以 $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$ 表示。转换因子为 $1\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2} = 1.602176634\\times 10^{-29}\\,\\mathrm{kg}$。铁的质量为 $m_{\\mathrm{Fe}}=55.845\\,\\mathrm{amu}$，其中 $1\\,\\mathrm{amu}=1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$。您必须在程序中将 $m_{\\mathrm{Fe}}$ 转换为 $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$。\n- 所有涉及物理量的答案都必须以上述指定的单位表示。所有角度（如果有）必须以弧度表示。此问题中不出现角度。如果需要分数，请表示为小数。\n\n铁中电子阻止的校准数据（铁中的自离子，合理的数值数据集）：\n- 该表提供了数据对 $\\left(E_{\\mathrm{kin}}, S_{e}\\right)$，其中 $E_{\\mathrm{kin}}$ 是抛射物动能，$S_{e}$ 是电子阻止本领。动能和阻止本领在以下几点给出：\n  - $\\left(1\\,\\mathrm{keV},\\,0.6\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(5\\,\\mathrm{keV},\\,1.8\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(10\\,\\mathrm{keV},\\,2.8\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(20\\,\\mathrm{keV},\\,4.0\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(50\\,\\mathrm{keV},\\,5.5\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(100\\,\\mathrm{keV},\\,6.5\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$。\n- 您必须根据这些数据校准 $S_{e}(v)$，方法是将每个表格中的动能 $E_{\\mathrm{kin}}$ 映射到指定单位下的速率 $v=\\sqrt{2E_{\\mathrm{kin}}/m_{\\mathrm{Fe}}}$，然后为 $S_{e}$ 作为 $v$ 的函数构建一个平滑、正值、保形的插值。为了提高鲁棒性和正定性，在对数-对数空间中构建此插值，即使用保形三次方法拟合 $\\log S_{e}$ 作为 $\\log v$ 的函数，然后定义 $S_{e}(v)=\\exp\\!\\left[\\text{interpolant}(\\log v)\\right]$。在表格速率范围之外，评估 $S_{e}$ 前，需将 $v$ 限制在校准域的边界内。\n\nMD模型和数值任务：\n- 考虑一个单一的Fe抛射物，沿 $x$ 轴在一维空间中运动，初始速率 $v_{0}>0$，初始位置 $x_{0}=0$。唯一的力是电子阻止力 $\\mathbf{F}_{\\mathrm{stop}}=-S_{e}(v)\\,\\hat{\\mathbf{v}}$，在一维情况下，对于 $v\\ge 0$，该力简化为 $F_{\\mathrm{stop}}(v)=-S_{e}(v)$。运动方程为 $\\mathrm{d}v/\\mathrm{d}t=-S_{e}(v)/m_{\\mathrm{Fe}}$ 和 $\\mathrm{d}x/\\mathrm{d}t=v$。\n- 定义电子能量耗散 $E_{\\mathrm{el}}(t)$，使得 $\\mathrm{d}E_{\\mathrm{el}}/\\mathrm{d}t=S_{e}(v)\\,v$ 且 $E_{\\mathrm{el}}(0)=0$。根据构造，在连续方程中，总能量 $E_{\\mathrm{tot}}(t)=E_{\\mathrm{kin}}(t)+E_{\\mathrm{el}}(t)$ 应该是守恒的，其中 $E_{\\mathrm{kin}}(t)=\\tfrac{1}{2}m_{\\mathrm{Fe}} v(t)^{2}$。\n- 使用二阶显式方法（例如，Heun方法）为此系统实现一个时间积分器，该积分器以时间步长 $\\Delta t$ 更新 $x(t)$ 和 $v(t)$，并使用二阶精确求积法（例如，梯形法则）累积 $E_{\\mathrm{el}}$。确保强制执行 $v(t)\\ge 0$，以避免在后期由于数值过冲而出现不符合物理规律的负速率。\n\n测试套件和要求输出：\n- 校准的阻止本领查询：使用您拟合的 $S_{e}(v)$，通过首先将每个能量通过 $v=\\sqrt{2E/m_{\\mathrm{Fe}}}$ 映射到速率，计算以下动能下的 $S_{e}$：\n  - $E=\\{2,15,80\\}\\,\\mathrm{keV}$。以浮点数形式报告这三个阻止本领值，单位为 $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 能量守恒诊断：对于以下每个三元组 $(E_{0},\\Delta t,T_{\\mathrm{end}})$，使用您的积分器从初始动能 $E_{0}$ 开始模拟抛射物，直到时间 $T_{\\mathrm{end}}$。对于每次模拟，计算总能量的最大相对漂移，定义为\n  $$\\max_{0\\le t\\le T_{\\mathrm{end}}}\\frac{\\left|E_{\\mathrm{kin}}(t)+E_{\\mathrm{el}}(t)-E_{0}\\right|}{E_{0}}.$$\n  使用以下案例：\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(10\\,\\mathrm{keV},\\,0.1\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$，\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(20\\,\\mathrm{keV},\\,0.01\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$，\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(50\\,\\mathrm{keV},\\,1.0\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$。\n  以小数形式报告这三个最大相对漂移。\n- 阈值射程：从 $E_{0}=50\\,\\mathrm{keV}$ 和时间步长 $\\Delta t=0.1\\,\\mathrm{fs}$ 开始模拟，直到动能衰减到 $E_{\\mathrm{th}}=1\\,\\mathrm{keV}$ 或达到 $T_{\\max}=50000\\,\\mathrm{fs}$ 的硬上限，以先发生者为准。以浮点数形式报告总行进距离 $R$，单位为 $\\mathrm{\\AA}$。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n  $$\\left[\\;S_{e}(2\\,\\mathrm{keV}),\\;S_{e}(15\\,\\mathrm{keV}),\\;S_{e}(80\\,\\mathrm{keV}),\\;\\delta_{1},\\;\\delta_{2},\\;\\delta_{3},\\;R\\;\\right],$$\n  其中 $\\delta_{i}$ 是三次能量守恒模拟的最大相对能量漂移。所有七个条目都必须是指定单位的数值。\n\n科学真实性约束：\n- 校准和模拟必须使用所提供的数据集、物理质量转换和规定的单位系统。\n- 积分器设计和能量核算必须与上述定义一致。\n- 不要使用任何外部数据或文件。所有内容必须自成一体且可运行。\n\n您的最终程序必须遵循单独说明的执行环境和输出格式要求，并为整个测试套件生成单行结果。不应打印任何额外文本。", "solution": "用户要求在分子动力学（MD）背景下，针对单个Fe抛射物，推导、校准并测试一个与速度成正比的电子阻止力模型。该问题定义明确，具有科学依据，并为唯一解提供了所有必要的数据和约束。因此，该问题被认为是有效的。\n\n解决方案分几个阶段进行：\n1.  **单位系统和常数**：所有物理量都在一个一致的单位系统中处理，能量使用电子伏特（$\\mathrm{eV}$），长度使用埃（$\\mathrm{\\AA}$），时间使用飞秒（$\\mathrm{fs}$）。铁（Fe）原子的质量，给定为 $m_{\\mathrm{Fe}}=55.845\\,\\mathrm{amu}$，被转换为MD质量单位 $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$。\n    -   $1\\,\\mathrm{amu}=1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$\n    -   $m_{\\mathrm{Fe}} = 55.845\\,\\mathrm{amu} \\times (1.66053906660\\times 10^{-27}\\,\\mathrm{kg}/\\mathrm{amu}) \\approx 9.2731\\times 10^{-26}\\,\\mathrm{kg}$。\n    -   质量的转换因子为 $1\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2} = 1.602176634\\times 10^{-29}\\,\\mathrm{kg}$。\n    -   因此，$m_{\\mathrm{Fe}} \\approx \\frac{9.2731\\times 10^{-26}\\,\\mathrm{kg}}{1.602176634\\times 10^{-29}\\,\\mathrm{kg}/(\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2})} \\approx 5787.855\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$。\n\n2.  **电子阻止本领 $S_e(v)$ 的校准**：电子阻止本领 $S_e$ 作为抛射物速率 $v$ 的函数进行校准。所提供的数据集由数据对 $(E_{\\mathrm{kin}}, S_e)$ 组成。\n    -   校准表中的每个动能 $E_{\\mathrm{kin}}$（单位为 $\\mathrm{keV}$）都使用关系式 $v = \\sqrt{2E_{\\mathrm{kin}}/m_{\\mathrm{Fe}}}$ 转换为速率 $v$（单位为 $\\mathrm{\\AA}/\\mathrm{fs}$）。所有能量首先都转换为 $\\mathrm{eV}$。\n    -   问题指定了在对数-对数空间中进行保形三次插值。这是通过使用 `scipy.interpolate.PchipInterpolator` 将 $\\log(S_e)$ 拟合为 $\\log(v)$ 的函数来实现的。该方法确保了单调性并避免了伪振荡。\n    -   生成的插值器被包装在一个函数 $S_e(v)$ 中，该函数计算 $S_e(v) = \\exp\\!\\left[\\text{interpolant}(\\log v)\\right]$。为了数值稳定性和物理真实性，如果 $v \\le 0$，则将 $S_e(v)$ 设置为 $0$。根据问题要求，对于超出校准范围的速率，输入速率 $v$ 在评估前被限制在该范围的边界内。\n\n3.  **运动方程的数值积分**：执行Fe抛射物的一维模拟。唯一的力是电子阻止力，$F_{\\mathrm{stop}}(v)=-S_{e}(v)$（对于 $v \\ge 0$）。运动方程为：\n    $$ \\frac{\\mathrm{d}v}{\\mathrm{d}t} = \\frac{F_{\\mathrm{stop}}(v)}{m_{\\mathrm{Fe}}} = -\\frac{S_{e}(v)}{m_{\\mathrm{Fe}}} $$\n    $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = v $$\n    这些方程使用二阶显式积分器 Heun 方法进行积分。对于系统 $\\mathbf{y}' = \\mathbf{f}(\\mathbf{y})$，更新规则是：\n    $$ \\mathbf{y}_{\\text{pred}} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{f}(\\mathbf{y}_n) $$\n    $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left[ \\mathbf{f}(\\mathbf{y}_n) + \\mathbf{f}(\\mathbf{y}_{\\text{pred}}) \\right] $$\n    对于我们的状态向量 $\\mathbf{y} = [x, v]^T$，这转化为对位置 $x$ 和速度 $v$ 的更新。在每一步都强制执行非负约束 $v \\ge 0$，以防止数值过冲导致不符合物理规律的负速率。\n\n4.  **能量守恒与耗散项**：系统的总能量是抛射物动能 $E_{\\mathrm{kin}}(t) = \\frac{1}{2}m_{\\mathrm{Fe}}v(t)^2$ 与耗散到电子子系统中的能量 $E_{\\mathrm{el}}(t)$ 之和。电子能量耗散的变化率由阻止力耗散的功率给出：\n    $$ \\frac{\\mathrm{d}E_{\\mathrm{el}}}{\\mathrm{d}t} = S_{e}(v)v $$\n    该方程使用二阶梯形法则进行数值积分，与运动方程的 Heun 积分器的阶数一致：\n    $$ E_{\\mathrm{el}}(t_{n+1}) = E_{\\mathrm{el}}(t_n) + \\frac{\\Delta t}{2} \\left[ S_e(v_n)v_n + S_e(v_{n+1})v_{n+1} \\right] $$\n    总能量 $E_{\\mathrm{tot}}(t) = E_{\\mathrm{kin}}(t) + E_{\\mathrm{el}}(t)$ 应该是守恒的。通过监测与初始能量 $E_0$ 的偏差来评估模拟的数值精度。\n\n5.  **执行测试套件**：该实现被用于解决指定的三个任务：\n    -   **$S_e$ 查询**：使用校准的 $S_e(v)$ 函数来查找动能为 $2$、$15$ 和 $80\\,\\mathrm{keV}$ 的抛射物的阻止本领。\n    -   **能量守恒诊断**：使用不同的初始能量 $E_0$ 和时间步长 $\\Delta t$ 运行三次模拟。对每种情况计算总能量的最大相对漂移 $\\max |E_{\\mathrm{tot}}(t) - E_0|/E_0$。\n    -   **射程计算**：从 $E_0=50\\,\\mathrm{keV}$ 开始运行模拟，直到抛射物的能量降至阈值 $E_{\\mathrm{th}}=1\\,\\mathrm{keV}$ 以下。记录总行进距离，即射程 $R$。\n\n最终输出按要求将这三个任务的结果连接成一个单一列表。该实现在一个独立的 Python 脚本中自成一体。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a projectile under electronic stopping,\n    including calibration, integration, and analysis tasks.\n    \"\"\"\n\n    # Define physical constants and conversion factors as per the problem statement.\n    AMU_IN_KG = 1.66053906660e-27\n    EV_FS2_PER_A2_IN_KG = 1.602176634e-29\n    FE_MASS_AMU = 55.845\n\n    # Calculate the mass of an iron atom in the specified MD units (eV*fs^2/A^2).\n    m_Fe_kg = FE_MASS_AMU * AMU_IN_KG\n    m_Fe = m_Fe_kg / EV_FS2_PER_A2_IN_KG\n\n    def calibrate_stopping_power(mass_fe):\n        \"\"\"\n        Calibrates the electronic stopping power S_e as a function of speed v,\n        based on provided (E_kin, S_e) data. The calibration is performed\n        via shape-preserving cubic interpolation in log-log space.\n\n        Args:\n            mass_fe (float): Mass of the projectile in MD units.\n\n        Returns:\n            A function S_e(v) that returns the stopping power.\n        \"\"\"\n        # Calibration data: (E_kin [keV], S_e [eV/A])\n        cal_data = np.array([\n            (1.0, 0.6), (5.0, 1.8), (10.0, 2.8), (20.0, 4.0),\n            (50.0, 5.5), (100.0, 6.5)\n        ], dtype=float)\n\n        E_kin_keV = cal_data[:, 0]\n        Se_cal = cal_data[:, 1]\n\n        # Convert kinetic energy E_kin [keV] to speed v [A/fs]\n        E_kin_eV = E_kin_keV * 1000.0\n        v_cal = np.sqrt(2 * E_kin_eV / mass_fe)\n\n        # Prepare for log-log interpolation\n        log_v_cal = np.log(v_cal)\n        log_Se_cal = np.log(Se_cal)\n\n        # Create the shape-preserving (monotonic) cubic interpolator\n        pchip = PchipInterpolator(log_v_cal, log_Se_cal)\n        min_log_v, max_log_v = log_v_cal[0], log_v_cal[-1]\n\n        def Se_function(v):\n            \"\"\"\n            Computes electronic stopping power S_e for a given speed v.\n            Handles v = 0 and clamps v to the calibration range.\n            \"\"\"\n            if v = 0:\n                return 0.0\n            log_v = np.log(v)\n            clamped_log_v = np.clip(log_v, min_log_v, max_log_v)\n            log_Se = pchip(clamped_log_v)\n            return np.exp(log_Se)\n\n        return Se_function\n\n    def run_simulation(E0_keV, dt_fs, Se_func, mass_fe, t_end_fs=None, E_th_keV=None, t_max_fs=None):\n        \"\"\"\n        Simulates the 1D motion of a projectile under electronic stopping.\n        Can run in two modes:\n        1. Energy conservation check: Runs for a fixed time.\n        2. Range calculation: Runs until energy drops to a threshold or time limit is reached.\n        \"\"\"\n        E0_eV = E0_keV * 1000.0\n        v0 = np.sqrt(2 * E0_eV / mass_fe)\n        E_kin0 = E0_eV\n\n        t, x, v, E_el = 0.0, 0.0, v0, 0.0\n        max_rel_drift = 0.0\n        \n        is_range_calc = (E_th_keV is not None and t_max_fs is not None)\n        \n        t_limit = t_max_fs if is_range_calc else t_end_fs\n        E_th_eV = E_th_keV * 1000.0 if is_range_calc else None\n        \n        num_steps = int(np.ceil(t_limit / dt_fs))\n\n        for _ in range(num_steps):\n            if is_range_calc:\n                current_E_kin = 0.5 * mass_fe * v**2 if v > 0 else 0.0\n                if current_E_kin = E_th_eV:\n                    break\n            \n            # Heun's method for velocity and position\n            v_n = v\n            Se_n = Se_func(v_n)\n            accel_n = -Se_n / mass_fe if v_n > 0 else 0.0\n            \n            v_tilde = v_n + dt_fs * accel_n\n            \n            Se_tilde = Se_func(v_tilde)\n            accel_tilde = -Se_tilde / mass_fe if v_tilde > 0 else 0.0\n            \n            v_next = v_n + 0.5 * dt_fs * (accel_n + accel_tilde)\n            v_next = max(0.0, v_next)\n\n            x_next = x + 0.5 * dt_fs * (v_n + v_next)\n            \n            # Trapezoidal rule for energy sink\n            Se_next = Se_func(v_next)\n            E_el_next = E_el + 0.5 * dt_fs * ((Se_n * v_n) + (Se_next * v_next))\n\n            x, v, E_el = x_next, v_next, E_el_next\n\n            if not is_range_calc:\n                E_kin_next = 0.5 * mass_fe * v**2\n                E_tot_next = E_kin_next + E_el\n                if E_kin0 > 0:\n                    rel_drift = abs(E_tot_next - E_kin0) / E_kin0\n                    max_rel_drift = max(max_rel_drift, rel_drift)\n        \n        return x if is_range_calc else max_rel_drift\n\n    all_results = []\n    \n    Se_func = calibrate_stopping_power(m_Fe)\n\n    # Task 1: Calibrated stopping power queries\n    query_energies_keV = [2.0, 15.0, 80.0]\n    for E_keV in query_energies_keV:\n        E_eV = E_keV * 1000.0\n        v_query = np.sqrt(2 * E_eV / m_Fe)\n        all_results.append(Se_func(v_query))\n\n    # Task 2: Energy conservation diagnostics\n    conservation_cases = [\n        (10.0, 0.1, 2000.0), # (E0_keV, dt_fs, T_end_fs)\n        (20.0, 0.01, 2000.0),\n        (50.0, 1.0, 2000.0)\n    ]\n    for E0, dt, Tend in conservation_cases:\n        drift = run_simulation(E0, dt, Se_func, m_Fe, t_end_fs=Tend)\n        all_results.append(drift)\n    \n    # Task 3: Range-to-threshold\n    final_range = run_simulation(\n        E0_keV=50.0, dt_fs=0.1, Se_func=Se_func, mass_fe=m_Fe,\n        E_th_keV=1.0, t_max_fs=50000.0\n    )\n    all_results.append(final_range)\n    \n    # Final output format: [Se_1, Se_2, Se_3, drift_1, drift_2, drift_3, Range]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3484083"}, {"introduction": "在位移级联模拟的终末阶段，会形成各种由点缺陷构成的复杂团簇。如何从海量的原子坐标中自动识别并表征这些缺陷结构，是连接模拟与理论或实验的关键。本实践将介绍一种基于图论的强大后处理方法，用于对缺陷团簇的形态进行定量分类 [@problem_id:3484085]。通过将缺陷团簇抽象为图，我们能够计算其聚类系数等拓扑不变量，从而客观地区分出它们是更接近于二维的位错环，还是三维的聚集体。", "problem": "您的任务是实现一个完整的、可运行的程序。该程序的功能是：根据位移级联模拟生成的点缺陷簇，构建其图表示，并计算图度量，以在不同的初级离位原子能量和温度下，将团簇形态分类为平面位错环或三维聚集体。该程序必须是完全确定性的，并针对指定的测试套件产生单行的、机器可检查的输出。下面所有的数学定义都必须精确实现，并且所有的物理量和数值量都已标明单位。\n\n基本基础与定义：\n\n- 令一个团簇为一个有限的位置集合 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$，其中 $\\mathbf{x}_i \\in \\mathbb{R}^3$，单位为埃（Angstrom）。\n- 从这些位置通过基于距离的截断构建一个无向简单图 $G = (V,E)$，其节点集为 $V = \\{1,\\dots,N\\}$。对于用户指定的整数 $m \\ge 2$ 和尺度因子 $\\eta  0$，计算每个节点 $i$ 到其第 $m$ 个最近邻的距离 $d_i^{(m)}$，并定义全局截断\n  $$ r_{\\mathrm{c}} = \\eta \\cdot \\mathrm{median}\\left(\\{d_i^{(m)}\\}_{i=1}^{N}\\right). $$\n  邻接矩阵 $A \\in \\{0,1\\}^{N \\times N}$ 定义为\n  $$ A_{ij} = \\begin{cases}1,  0  \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 \\le r_{\\mathrm{c}},\\\\ 0,  \\text{其他情况},\\end{cases} $$\n  其中 $A_{ii} = 0$ 且 $A_{ij} = A_{ji}$。\n- 节点 $i$ 的度为 $k_i = \\sum_{j=1}^{N} A_{ij}$。度分布是多重集 $\\{k_i\\}_{i=1}^{N}$。\n- 对于度 $k_i \\ge 2$ 的节点 $i$，其局部聚类系数（三元闭包）为\n  $$ C_i = \\frac{2 t_i}{k_i (k_i - 1)}, $$\n  其中 $t_i$ 是节点 $i$ 的邻居之间的边数，\n  $$ t_i = \\sum_{1 \\le p  q \\le N} A_{ip} A_{iq} A_{pq}. $$\n  对于 $k_i  2$ 的情况，定义 $C_i = 0$。平均局部聚类系数为\n  $$ \\bar{C} = \\frac{1}{|\\{i \\,:\\, k_i \\ge 2\\}|} \\sum_{i : k_i \\ge 2} C_i, $$\n  约定当 $\\{i : k_i \\ge 2\\} = \\emptyset$ 时，$\\bar{C} = 0$。\n\n分类的科学依据：\n\n- 当边是根据几何邻近规则形成时，所得到的图是一个受嵌入维度约束的随机几何图。对于相当的邻居数量，二维嵌入（平面圆盘）的邻域重叠区域比三维嵌入（球形体积）的要大，这导致二维情况下的 $\\bar{C}$ 大于三维情况下的。这种效应可以从基本几何学角度理解：对于固定的邻居数量（此处由自适应截断控制），成对邻域交集度量与邻域度量之比较低维度中更大，从而提高了形成闭合三元组的概率，因此 $\\bar{C}$ 也更大。\n- 因此，我们使用 $\\bar{C}$ 的一个阈值来对团簇进行分类：\n  $$ \\text{label} = \\begin{cases} 0,  \\bar{C} \\ge C_{\\mathrm{thr}} \\quad \\text{(平面环)},\\\\ 1,  \\bar{C}  C_{\\mathrm{thr}} \\quad \\text{(三维聚集体)}.\\end{cases} $$\n\n用于从初级离位原子能量和温度生成坐标的、基于物理动机的合成团簇生成器：\n\n- 初级离位原子（PKA）能量用 $E_{\\mathrm{PKA}}$ 表示，单位为千电子伏特（kilo-electronvolt），温度用 $T$ 表示，单位为开尔文（Kelvin）。\n- 固定参考能量 $E_{\\mathrm{ref}} = 20$ 千电子伏特，并定义一个尺寸尺度因子 $s_E = (E_{\\mathrm{PKA}}/E_{\\mathrm{ref}})^{1/3}$（无量纲），其动机源于级联中的能量-体积标度关系。\n- 一个温度-能量切换规则决定是生成平面环还是三维团簇：\n  $$ T_{\\mathrm{switch}}(E_{\\mathrm{PKA}}) = T_0 + \\alpha \\left(E_{\\mathrm{PKA}} - E_{\\mathrm{ref}}\\right), $$\n  其中 $T_0 = 800$ 开尔文，$\\alpha = 4$ 开尔文/千电子伏特。如果 $T \\ge T_{\\mathrm{switch}}(E_{\\mathrm{PKA}})$，则生成一个类平面环团簇；否则，生成一个三维团簇。\n- 类平面环团簇合成：在平面 $z=0$ 上，一个半径为 $R_{\\mathrm{loop}} = 12 \\, s_E$ 埃的圆盘内均匀采样 $N$ 个点。径向采样必须使用 $r = R_{\\mathrm{loop}} \\sqrt{U}$，其中 $U \\sim \\mathrm{Uniform}(0,1)$；角度采样必须使用 $\\theta \\sim \\mathrm{Uniform}(0,2\\pi)$，角度单位为弧度。添加小的平面外扰动 $\\delta z \\sim \\mathcal{N}(0,\\sigma_z^2)$，其中 $\\sigma_z = 0.15 \\cdot (T/1000)$ 埃。\n- 三维团簇合成：在一个半径为 $R_{\\mathrm{3D}} = 10 \\, s_E$ 埃的球体内，使用半径分布规律 $r = R_{\\mathrm{3D}} \\, U^{1/3}$（其中 $U \\sim \\mathrm{Uniform}(0,1)$）以及 $\\mathbb{R}^3$ 中均匀随机的方向向量，来均匀采样 $N$ 个点。\n- 使用固定的随机种子 12345，以确保所有坐标都是可复现的。\n\n图构建超参数与分类阈值：\n\n- 对自适应截断，使用 $m = 6$ 和 $\\eta = 1.05$。如果 $N-1  m$，则使用 $m_{\\mathrm{eff}} = N-1$ 代替 $m$。\n- 使用 $C_{\\mathrm{thr}} = 0.50$ 作为分类阈值。\n- 所有距离必须以埃（Angstrom）为单位计算，所有角度必须以弧度为单位计算。\n\n测试套件：\n\n提供以下五个测试用例，格式为有序元组 $(N, E_{\\mathrm{PKA}} \\, [\\mathrm{keV}], T \\, [\\mathrm{K}])$：\n\n- 用例 A（平面理想路径）：$(80, 10, 1000)$。\n- 用例 B（三维理想路径）：$(120, 40, 500)$。\n- 用例 C（位于切换线上）：$(60, 20, 800)$。\n- 用例 D（小团簇边界情况）：$(12, 25, 850)$。\n- 用例 E（接近切换点的三维情况）：$(90, 30, 820)$。\n\n程序要求：\n\n- 精确按照定义实现生成器、图构建、度分布和平均局部聚类系数的计算。\n- 对每个测试用例，构建图并计算度分布 $\\{k_i\\}$ 和 $\\bar{C}$，然后输出形态标签（一个整数），其中 $0$ 表示类环形态，$1$ 表示三维形态。\n- 最终的程序输出必须是单行文本，包含一个由逗号分隔的列表，其中是按给定顺序排列的五个测试用例的标签，并用方括号括起来。例如，输出格式必须与 $[x_1,x_2,x_3,x_4,x_5]$ 完全一样，其中每个 $x_i$ 是一个整数。", "solution": "该问题要求实现一个计算工作流，用于将人工合成的点缺陷簇的形态分类为平面（标签 $0$）或三维（标签 $1$）。这是通过将团簇建模为图，并使用图论度量——平均局部聚类系数——作为判别特征来完成的。由于使用了固定的随机种子，从数据生成到分类的整个过程都是确定性的。\n\n该解决方案分三个主要阶段实现：合成团簇生成、图的构建与分析以及最终分类。\n\n**1. 合成团簇生成**\n\n团簇坐标 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 的生成具有物理动机，模拟了材料中位移级联的结果。其形态由初级离位原子（PKA）能量 $E_{\\mathrm{PKA}}$ 和温度 $T$ 之间的竞争决定。\n\n首先，计算一个尺寸缩放因子 $s_E = (E_{\\mathrm{PKA}}/E_{\\mathrm{ref}})^{1/3}$，其中 $E_{\\mathrm{ref}} = 20$ keV 是一个参考能量。这个 $1/3$ 次幂定律与理论模型一致，在这些模型中，级联影响区域的体积与能量成线性关系。\n\n接下来，计算一个温度阈值 $T_{\\mathrm{switch}}$，它是PKA能量的线性函数：\n$$ T_{\\mathrm{switch}}(E_{\\mathrm{PKA}}) = T_0 + \\alpha (E_{\\mathrm{PKA}} - E_{\\mathrm{ref}}) $$\n其中基础温度 $T_0 = 800$ K，斜率 $\\alpha = 4$ K/keV。如果环境温度 $T$ 大于或等于此阈值（$T \\ge T_{\\mathrm{switch}}(E_{\\mathrm{PKA}})$），则生成一个平面的类环团簇。否则，形成一个三维的类聚集体团簇。该规则模拟了一种物理趋势，即在温度较高、热迁移能力增强时，缺陷倾向于排列成低维结构（位错环）。\n\n- **平面环合成 ($T \\ge T_{\\mathrm{switch}}$)**：在一个半径为 $R_{\\mathrm{loop}} = 12 \\, s_E$ 埃的圆盘内均匀采样 $N$ 个点。为确保空间密度均匀，径向坐标 $r$ 根据 $r = R_{\\mathrm{loop}} \\sqrt{U}$ 进行采样，其中 $U$ 是一个来自 $\\mathrm{Uniform}(0,1)$ 的随机变量。角坐标 $\\theta$ 从 $\\mathrm{Uniform}(0,2\\pi)$ 中采样。在 $z$ 坐标上添加一个小的、与温度相关的高斯噪声，其标准差为 $\\sigma_z = 0.15 \\cdot (T/1000)$ 埃，以模拟热振动和与理想平面的微小偏离。\n\n- **三维聚集体合成 ($T  T_{\\mathrm{switch}}$)**：在一个半径为 $R_{\\mathrm{3D}} = 10 \\, s_E$ 埃的球体内均匀采样 $N$ 个点。均匀体积采样要求径向坐标 $r$ 采样为 $r = R_{\\mathrm{3D}} \\, U^{1/3}$，其中 $U \\sim \\mathrm{Uniform}(0,1)$。方向从单位球面 $\\mathbb{S}^2$ 上均匀采样。\n\n一个用固定种子 12345 初始化的伪随机数生成器，确保整个生成过程是可复现的。\n\n**2. 图构建与度量计算**\n\n给定 $N$ 个坐标的集合，构建一个无向图 $G=(V, E)$。此过程的核心是一个决定连通性的自适应截断半径 $r_{\\mathrm{c}}$。\n\n首先，对于每个点 $\\mathbf{x}_i$，我们找到其到第 $m$ 个最近邻的距离 $d_i^{(m)}$，其中 $m=6$。一个特殊情况处理小团簇，即当其他点的数量小于 $m$ 时：如果 $N-1  m$，我们使用 $m_{\\mathrm{eff}} = N-1$ 代替。然后，全局截断半径定义为：\n$$ r_{\\mathrm{c}} = \\eta \\cdot \\mathrm{median}\\left(\\{d_i^{(m)}\\}_{i=1}^{N}\\right) $$\n其中 $\\eta = 1.05$ 是一个缩放因子。这种自适应方法确保了所生成图中每个节点的连接数对于点云整体密度的变化具有鲁棒性。\n\n图的邻接矩阵 $A$ 基于此截断半径构建。如果节点 $i$ 和 $j$ 之间的欧几里得距离为正且不超过 $r_{\\mathrm{c}}$，则它们之间存在一条边：\n$$ A_{ij} = 1 \\quad \\text{if} \\quad 0  \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 \\le r_{\\mathrm{c}}, \\quad \\text{and} \\quad A_{ij}=0 \\quad \\text{otherwise}. $$\n根据定义，$A_{ii}=0$ 且矩阵是对称的，$A_{ij}=A_{ji}$。\n\n用于分类的主要图度量是平均局部聚类系数 $\\bar{C}$。对于每个节点 $i$，其局部聚类系数 $C_i$ 衡量其直接邻居之间的连接密度。它为度 $k_i = \\sum_{j} A_{ij} \\ge 2$ 的节点定义：\n$$ C_i = \\frac{2 t_i}{k_i (k_i - 1)} $$\n其中 $t_i$ 是包含节点 $i$ 的三角形（由相连节点组成的闭合三元组）的数量。对于度 $k_i  2$ 的节点，$C_i$ 定义为 $0$。三角形数量 $t_i$ 可以通过组合方式计算，但一种计算效率更高的方法利用了矩阵代数：从节点 $i$ 出发回到自身的长度为 3 的路径数量由矩阵立方的第 $i$ 个对角元素 $(A^3)_{ii}$ 给出。由于每个涉及节点 $i$ 的三角形对应于两条这样的路径（一条顺时针，一条逆时针），我们有 $2t_i = (A^3)_{ii}$。\n\n平均局部聚类系数 $\\bar{C}$ 是所有度 $k_i \\ge 2$ 的节点的 $C_i$ 的平均值：\n$$ \\bar{C} = \\frac{1}{|\\{i \\,:\\, k_i \\ge 2\\}|} \\sum_{i : k_i \\ge 2} C_i $$\n如果没有节点的度大于或等于 2，则定义 $\\bar{C}$ 为 $0$。\n\n**3. 形态分类**\n\n使用 $\\bar{C}$ 的科学依据是几何学。对于一个节点平均拥有相似数量邻居的图（由自适应截断保证），嵌入在二维空间中的节点将比嵌入在三维空间中的节点具有更高的 $\\bar{C}$。这是因为邻域（二维中的圆盘，三维中的球体）在较低维度中具有更大的相对交集体积，这增加了节点的两个邻居也互为邻居的概率。\n\n最终分类通过将 $\\bar{C}$ 与一个固定阈值 $C_{\\mathrm{thr}} = 0.50$ 进行比较来执行：\n- 如果 $\\bar{C} \\ge C_{\\mathrm{thr}}$，团簇被分类为平面环（标签 $0$）。\n- 如果 $\\bar{C}  C_{\\mathrm{thr}}$，团簇被分类为三维聚集体（标签 $1$）。\n\n所提供的程序实现了这个完整的流程，处理来自指定套件的每个测试用例，并生成相应的分类标签。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef solve():\n    \"\"\"\n    Main function to run the full simulation and classification pipeline.\n    It orchestrates cluster generation, graph construction, and metric-based\n    classification for a predefined suite of test cases.\n    \"\"\"\n    \n    # Initialize a single random number generator with a fixed seed for reproducibility.\n    # This generator is passed to any function that requires random numbers.\n    rng = np.random.default_rng(12345)\n\n    # Define physical constants and model hyperparameters as specified.\n    E_REF = 20.0  # Reference PKA energy in keV\n    T0 = 800.0    # Base temperature in K\n    ALPHA = 4.0   # Temperature-Energy coupling in K/keV\n    M_PARAM = 6   # Neighbor parameter for adaptive cutoff\n    ETA = 1.05    # Scale factor for adaptive cutoff\n    C_THR = 0.50  # Threshold for classification\n\n    # Define the five test cases as (N, E_pka [keV], T [K]).\n    test_cases = [\n        (80, 10.0, 1000.0),  # Case A: Happy path planar\n        (120, 40.0, 500.0),  # Case B: Happy path volumetric\n        (60, 20.0, 800.0),   # Case C: Boundary at switching line\n        (12, 25.0, 850.0),   # Case D: Small cluster edge case\n        (90, 30.0, 820.0),   # Case E: Near-switch volumetric\n    ]\n\n    results = []\n    for N, E_pka, T in test_cases:\n        # For each case, generate the coordinates based on the physical model.\n        coords = _generate_cluster(N, E_pka, T, E_REF, T0, ALPHA, rng)\n        # Classify the generated cluster using the graph-based method.\n        label = _classify_cluster(coords, M_PARAM, ETA, C_THR)\n        results.append(label)\n\n    # Print the final output in the specified format \"[label1,label2,...]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _generate_cluster(N, E_pka, T, E_ref, T0, alpha, rng):\n    \"\"\"\n    Generates a synthetic point-defect cluster based on PKA energy and temperature.\n    \"\"\"\n    s_E = (E_pka / E_ref)**(1/3.0)\n    T_switch = T0 + alpha * (E_pka - E_ref)\n\n    if T >= T_switch:\n        # Generate a planar, loop-like cluster.\n        R_loop = 12.0 * s_E\n        sigma_z = 0.15 * (T / 1000.0)\n        \n        # Uniform sampling in a disk requires a square-root transformation of the radial uniform variate.\n        u_rad = rng.uniform(0, 1, size=N)\n        radii = R_loop * np.sqrt(u_rad)\n        \n        thetas = rng.uniform(0, 2 * np.pi, size=N)\n        \n        x = radii * np.cos(thetas)\n        y = radii * np.sin(thetas)\n        z = rng.normal(0, sigma_z, size=N)\n        \n        return np.vstack((x, y, z)).T\n    else:\n        # Generate a three-dimensional, aggregate-like cluster.\n        R_3d = 10.0 * s_E\n        \n        # Uniform sampling in a sphere requires a cube-root transformation of the radial uniform variate.\n        u_rad = rng.uniform(0, 1, size=N)\n        radii = R_3d * (u_rad**(1/3.0))\n        \n        # Generate uniformly distributed random direction vectors on the unit sphere.\n        vecs = rng.normal(0, 1, size=(N, 3))\n        norms = np.linalg.norm(vecs, axis=1, keepdims=True)\n        # Avoid division by zero for a zero-vector, though highly improbable.\n        norms[norms == 0] = 1\n        unit_vecs = vecs / norms\n        \n        # Scale unit vectors by the sampled radii.\n        return radii[:, np.newaxis] * unit_vecs\n\ndef _classify_cluster(coords, m_param, eta, C_thr):\n    \"\"\"\n    Classifies a cluster by constructing a graph and computing its mean local clustering coefficient.\n    \"\"\"\n    N = coords.shape[0]\n    \n    # Handle trivial cases (e.g., N = 1) where a graph is ill-defined.\n    if N = 1:\n        return 1  # Cannot form edges, C_bar is 0, classified as 3D.\n\n    # Adjust m for small clusters as per problem spec.\n    m_eff = min(m_param, N - 1)\n    if m_eff  1:\n        return 1 # Not enough neighbors to define m-th nearest.\n\n    # 1. Compute pairwise Euclidean distance matrix.\n    dist_matrix = squareform(pdist(coords, 'euclidean'))\n    \n    # 2. Find m-th nearest neighbor distances for each point.\n    sorted_dist = np.sort(dist_matrix, axis=1)\n    # sorted_dist[:, 0] is always 0 (distance to self).\n    # sorted_dist[:, k] is the k-th nearest neighbor distance.\n    d_m_list = sorted_dist[:, m_eff]\n    \n    # 3. Compute the adaptive cutoff radius.\n    r_c = eta * np.median(d_m_list)\n    \n    # 4. Construct the adjacency matrix.\n    adj_matrix = ((dist_matrix > 0)  (dist_matrix = r_c)).astype(int)\n    \n    # 5. Compute node degrees (k_i).\n    k = adj_matrix.sum(axis=1)\n\n    # 6. Compute mean local clustering coefficient (C_bar).\n    k_ge_2_mask = k >= 2\n    \n    if not np.any(k_ge_2_mask):\n        C_bar = 0.0\n    else:\n        # Efficiently compute number of triangles t_i using matrix exponentiation.\n        # (A^3)_ii = 2 * t_i\n        adj_matrix_cubed = np.linalg.matrix_power(adj_matrix, 3)\n        two_ti = np.diag(adj_matrix_cubed)\n        \n        # Denominators for C_i: k_i * (k_i - 1).\n        denominators = k * (k - 1)\n        \n        # Calculate C_i only for nodes where the denominator is non-zero (k_i >= 2).\n        valid_two_ti = two_ti[k_ge_2_mask]\n        valid_denominators = denominators[k_ge_2_mask]\n        \n        C_i_list = valid_two_ti / valid_denominators\n        C_bar = np.mean(C_i_list)\n        \n    # 7. Classify based on C_bar and the threshold C_thr.\n    label = 1 if C_bar  C_thr else 0\n    \n    return label\n\nsolve()\n```", "id": "3484085"}]}