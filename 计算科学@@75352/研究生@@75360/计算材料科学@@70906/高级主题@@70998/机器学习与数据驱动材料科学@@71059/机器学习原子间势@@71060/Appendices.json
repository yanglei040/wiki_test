{"hands_on_practices": [{"introduction": "机器学习原子间势 (MLIP) 的核心优势在于能够快速准确地从势能面计算原子受力，从而加速分子动力学模拟。本练习旨在让你掌握从一个常见的MLIP函数形式中推导这些力的基础技能，为你连接能量模型与其在模拟中的应用打下坚实的基础。通过这个练习，你将明白势能的解析形式如何直接转化为驱动原子运动的动力学信息 [@problem_id:91015]。", "problem": "在计算材料科学领域，机器学习原子间势（MLIPs）越来越多地被用于加速分子动力学模拟，其通过提供势能面的快速而准确的近似来实现。\n\n一种常见的方法是将包含 $N$ 个原子的体系的总势能 $U$ 表示为各项原子贡献之和，而这些原子贡献本身又取决于局域化学环境。\n\n考虑一个简化的两体 MLIP 模型，其中体系的总势能 $U$ 由所有唯一的原子对之间的对相互作用势之和给出：\n$$\nU = \\sum_{i=1}^{N} \\sum_{j > i}^{N} V(r_{ij})\n$$\n其中 $r_{ij} = |\\mathbf{r}_i - \\mathbf{r}_j|$ 是位于位置 $\\mathbf{r}_i$ 的原子 $i$ 和位于位置 $\\mathbf{r}_j$ 的原子 $j$ 之间的标量距离。\n\n对相互作用势 $V(r)$ 被建模为 $K$ 个固定宽度、以不同半径 $r_k$ 为中心的高斯型径向基函数的线性组合：\n$$\nV(r) = \\sum_{k=1}^{K} c_k \\exp\\left(-\\frac{(r - r_k)^2}{2\\sigma^2}\\right)\n$$\n此处，$\\{c_k\\}_{k=1}^K$ 是在训练过程中确定的线性系数（权重），$\\{r_k\\}_{k=1}^K$ 是高斯函数的固定中心，而 $\\sigma$ 是一个对所有基函数都相同的固定宽度参数。\n\n使用以上定义，推导作用在特定原子 $i$ 上的、由体系中所有其他原子施加的总力 $\\mathbf{F}_i$ 的闭式向量表达式。您的表达式应为原子位置 $\\mathbf{r}_j$、模型参数 $c_k$、$r_k$、$\\sigma$ 以及原子间距离 $r_{ij}$ 的函数。", "solution": "我们有总能量\n$$\nU=\\sum_{i=1}^N\\sum_{j>i}V(r_{ij}),\\quad r_{ij}=|\\mathbf r_i-\\mathbf r_j|.\n$$\n作用在原子 $i$ 上的力是\n$$\n\\mathbf F_i=-\\nabla_{\\mathbf r_i}U=-\\sum_{j\\neq i}\\frac{dV(r_{ij})}{dr_{ij}}\\frac{\\partial r_{ij}}{\\partial\\mathbf r_i}.\n$$\n由于\n$$\n\\frac{\\partial r_{ij}}{\\partial\\mathbf r_i}=\\frac{\\mathbf r_i-\\mathbf r_j}{r_{ij}},\n\\quad\nV(r)=\\sum_{k=1}^K c_k\\exp\\!\\Bigl(-\\tfrac{(r-r_k)^2}{2\\sigma^2}\\Bigr),\n$$\n我们计算\n$$\n\\frac{dV}{dr}\n=\\sum_{k=1}^K c_k\\Bigl(-\\frac{r-r_k}{\\sigma^2}\\Bigr)\\exp\\!\\Bigl(-\\frac{(r-r_k)^2}{2\\sigma^2}\\Bigr)\n=-\\sum_{k=1}^K c_k\\frac{r-r_k}{\\sigma^2}e^{-\\frac{(r-r_k)^2}{2\\sigma^2}}.\n$$\n代入 $\\mathbf F_i$ 可得\n$$\n\\mathbf F_i\n=-\\sum_{j\\ne i}\\Bigl(-\\sum_{k=1}^K c_k\\frac{r_{ij}-r_k}{\\sigma^2}e^{-\\frac{(r_{ij}-r_k)^2}{2\\sigma^2}}\\Bigr)\\frac{\\mathbf r_i-\\mathbf r_j}{r_{ij}}\n=\\sum_{j\\ne i}\\sum_{k=1}^K c_k\\frac{r_{ij}-r_k}{\\sigma^2}e^{-\\frac{(r_{ij}-r_k)^2}{2\\sigma^2}}\\frac{\\mathbf r_i-\\mathbf r_j}{r_{ij}}.\n$$", "answer": "$$\\boxed{\\mathbf F_i=\\sum_{j\\ne i}\\sum_{k=1}^K c_k\\frac{(r_{ij}-r_k)}{\\sigma^2}\\exp\\!\\Bigl(-\\frac{(r_{ij}-r_k)^2}{2\\sigma^2}\\Bigr)\\frac{\\mathbf r_i-\\mathbf r_j}{r_{ij}}}$$", "id": "91015"}, {"introduction": "一个成功的机器学习原子间势必须能够“理解”原子周围的几何环境，并且这种理解不能因观察角度的旋转或同类原子的置换而改变，即满足不变性。本练习将向你介绍Behler-Parrinello对称函数，这是一种为原子环境创建不变量“指纹”的强大工具。通过为一个简单的晶体结构计算对称函数值，你将具体地体会到这个抽象概念的实际应用 [@problem_id:90953]。", "problem": "在机器学习原子间势领域，Behler-Parrinello 对称函数是创建稳健且精确的原子相互作用模型的基石。这些函数以一种对旋转、平移和同类原子的置换保持不变的方式，描述了原子的局部化学环境。\n\n一种常见的径向对称函数，记为 $G^i(\\eta, R_s)$，用于量化中心原子 $i$ 周围相邻原子 $j$ 的径向分布。其定义如下：\n$$\nG^i(\\eta, R_s) = \\sum_{j \\neq i} e^{-\\eta (R_{ij} - R_s)^2} f_c(R_{ij})\n$$\n此处，$R_{ij}$ 是原子 $i$ 和 $j$ 之间的距离。参数 $\\eta$ 控制高斯函数的宽度，而 $R_s$ 定义了高斯函数中心的径向距离。该求和遍及截断半径 $R_c$ 内的所有相邻原子 $j$。该截断由截断函数 $f_c(R_{ij})$ 实现，当相邻原子的距离接近 $R_c$ 时，它会将其贡献平滑地降为零。$f_c(R_{ij})$ 的一个常用形式是余弦截断函数：\n$$\nf_c(R_{ij}) = \\begin{cases}\n\\frac{1}{2} \\left( \\cos\\left(\\frac{\\pi R_{ij}}{R_c}\\right) + 1 \\right)  \\text{若 } R_{ij} \\le R_c \\\\\n0  \\text{若 } R_{ij} > R_c\n\\end{cases}\n$$\n\n考虑一个元素中的单个原子，它排列在一个理想的简单立方（SC）晶格中，晶格常数为 $a$。对于位于该晶格原点的原子，推导径向对称函数 $G^i(\\eta, R_s)$ 值的解析表达式。使用截断半径 $R_c = \\frac{7}{4}a$。您的最终表达式应该用晶格常数 $a$ 和对称函数参数 $\\eta$、$R_s$ 来表示。", "solution": "1. 径向对称函数定义为\n$$\nG^i(\\eta,R_s)=\\sum_{j\\neq i}e^{-\\eta\\bigl(R_{ij}-R_s\\bigr)^2}f_c(R_{ij})\\,,\n$$\n其中余弦截断函数为\n$$\nf_c(R)=\\begin{cases}\n\\frac12\\bigl(\\cos(\\pi R/R_c)+1\\bigr) & \\text{若 } R \\le R_c,\\\\\n0 & \\text{若 } R > R_c.\n\\end{cases}\n$$\n\n2. 在晶格常数为 $a$ 的简单立方晶格中，位于原点的原子 $i$ 的相邻原子位置为 $(n_x,n_y,n_z)a$，其中 $n_x,n_y,n_z\\in\\mathbb Z$ 且不全为零。它们之间的距离为\n$$\nR_{n_x,n_y,n_z}=a\\sqrt{n_x^2+n_y^2+n_z^2}\\,.\n$$\n\n3. 在截断半径 $R_c=\\tfrac74a = 1.75a$ 的情况下，只有满足 $a\\sqrt{n_x^2+n_y^2+n_z^2} \\le 1.75a$ 或 $n_x^2+n_y^2+n_z^2 \\le 1.75^2 = 3.0625$ 的壳层有贡献：\n- $n^2=1$: $( \\pm 1, 0, 0)$ 及其置换，共6个原子，距离 $R=a$。\n- $n^2=2$: $( \\pm 1, \\pm 1, 0)$ 及其置换，共12个原子，距离 $R=a\\sqrt2 \\approx 1.414a$。\n- $n^2=3$: $( \\pm 1, \\pm 1, \\pm 1)$ 及其置换，共8个原子，距离 $R=a\\sqrt3 \\approx 1.732a$。\n所有这些壳层都在截断半径之内。\n\n4. 因此\n$$\nG^i=\\;6\\,e^{-\\eta(a-R_s)^2}f_c(a)\n\\;+\\;12\\,e^{-\\eta(a\\sqrt2-R_s)^2}f_c(a\\sqrt2)\n\\;+\\;8\\,e^{-\\eta(a\\sqrt3-R_s)^2}f_c(a\\sqrt3).\n$$\n\n5. 计算截断因子，利用 $R_c=\\frac{7}{4}a$\n$$\nf_c(a)=\\tfrac12\\bigl(\\cos(\\tfrac{\\pi a}{R_c})+1\\bigr)\n=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi}{7})+1\\bigr),\n$$\n类似地\n$$\nf_c(a\\sqrt2)=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi\\sqrt2}{7})+1\\bigr),\\quad\nf_c(a\\sqrt3)=\\tfrac12\\bigl(\\cos(\\tfrac{4\\pi\\sqrt3}{7})+1\\bigr).\n$$\n\n6. 代入并合并因子 $\\tfrac12$ 可得\n$$\nG^i\n=3\\,e^{-\\eta(a-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi}{7})+1\\bigr)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi\\sqrt2}{7})+1\\bigr)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\bigl(\\cos(\\tfrac{4\\pi\\sqrt3}{7})+1\\bigr).\n$$", "answer": "$$\\boxed{3\\,e^{-\\eta(a-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi}{7}+1\\bigr)\n+6\\,e^{-\\eta(a\\sqrt2-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi\\sqrt2}{7}+1\\bigr)\n+4\\,e^{-\\eta(a\\sqrt3-R_s)^2}\\bigl(\\cos\\!\\tfrac{4\\pi\\sqrt3}{7}+1\\bigr)}$$", "id": "90953"}, {"introduction": "虽然机器学习势功能强大，但如果它们不遵循基本的物理定律，例如原子在极近距离下的强排斥作用，就可能导致灾难性的失败。这个高级练习将演示如何在模型中强制加入此类物理约束，并测试其对分子动力学模拟稳定性的直接影响。这突出了开发稳健势函数的一个关键方面：将物理先验知识融入机器学习模型中是至关重要的 [@problem_id:3462502]。", "problem": "您的任务是为一维成对相互作用系统（采用简化的Lennard-Jones单位）构建和评估两种机器学习原子间势（MLIP）。其目标是展示如何通过一个参数化先验来强制施加硬性短程排斥作用，该先验在原子间距趋近于零时发散，从而提高分子动力学（MD）模拟的稳定性。您必须实现并比较一个无约束模型和一个包含固定势垒项的约束模型，该势垒项在距离趋于零时发散。然后，您必须使用每种模型在简化坐标系中模拟双体正面对撞，以量化它们在短距离下的行为。\n\n从以下基本原理和经过充分检验的定义开始：\n\n- 牛顿第二定律：对于相对坐标 $r(t)$ 和约化质量 $\\mu$，运动方程为 $\\mu \\, d^{2} r / dt^{2} = F(r)$，其中 $F(r)$ 是沿中心连线坐标的力。\n- 势能 $E(r)$ 定义了保守力为 $F(r) = - \\, dE(r)/dr$。\n- 一个监督学习回归模型使用基函数 $\\{\\phi_{j}(r)\\}$ 和参数 $\\{w_{j}\\}$ 来表示一个能量模型 $E_{\\theta}(r)$，该模型通过最小化正则化经验风险进行拟合。\n\n您的任务是：\n\n- 从一个在 $r \\to 0$ 时发散的、物理上合理的参考对势 $E_{\\mathrm{ref}}(r)$ 生成合成训练数据集。使用简化的Lennard-Jones形式，参数为 $\\epsilon = 1$ 和 $\\sigma = 1$，即 $E_{\\mathrm{ref}}(r) = 4 \\left[(\\sigma/r)^{12} - (\\sigma/r)^{6}\\right]$，在训练区间 $r \\in [r_{\\min}, r_{\\max}]$ 上进行评估，其中 $r_{\\min} = 0.9$，$r_{\\max} = 3.0$。使用包含 $N = 120$ 个点的均匀网格进行训练。\n- 定义一个高斯径向基展开 $g(r) = \\sum_{j=1}^{M} w_{j} \\, \\phi_{j}(r)$，其高斯基函数为 $\\phi_{j}(r) = \\exp\\left(-\\frac{(r - c_{j})^{2}}{2 s^{2}}\\right)$。使用 $M = 24$ 个基函数中心 $\\{c_{j}\\}$，其均匀分布在 $[0.8, 3.2]$ 区间内，共享宽度为 $s = 0.25$。在通过最小化二次损失来拟合权重 $\\{w_{j}\\}$ 时，使用系数为 $\\lambda = 10^{-6}$ 的 $\\ell_{2}$ 正则化。\n- 训练两种MLIP：\n  - 无约束模型：$E_{\\mathrm{U}}(r) = g_{\\mathrm{U}}(r)$ 直接拟合训练网格上的参考能量，并对权重进行 $\\ell_{2}$ 正则化。\n  - 带硬性短程势垒先验的约束模型：$E_{\\mathrm{C}}(r) = g_{\\mathrm{C}}(r) + B(r)$，其中 $B(r) = c_{0} / r^{p}$，$c_{0} = 1.0$，$p = 12$。仅使用相同的基和正则化方法，将 $g_{\\mathrm{C}}(r)$ 的权重拟合到修正后的目标 $E_{\\mathrm{ref}}(r) - B(r)$。通过这种构造，当 $r \\to 0$ 时，强制 $E_{\\mathrm{C}}(r) \\to \\infty$。\n- 使用高斯基和势垒项的解析导数，推导并实现相应的力表达式 $F_{\\mathrm{U}}(r) = - \\, dE_{\\mathrm{U}}/dr$ 和 $F_{\\mathrm{C}}(r) = - \\, dE_{\\mathrm{C}}/dr$。\n- 使用 velocity-Verlet 算法，在相对坐标系中实现一维简化双体正面对撞的MD模拟。使用约化质量 $\\mu = 0.5$，初始间距 $r_{0} = 1.5$，以及沿中心连线的初始相对速度 $v_{0}  0$。通过对 $\\mu \\, d^{2}r/dt^{2} = F(r)$ 进行积分，以时间步长 $\\Delta t$ 在固定的持续时间 $t_{\\max} = 3.0$ 内演化标量相对坐标 $r(t)$。在每一步中，记录遇到的最小间距 $r_{\\min}$。如果模拟遇到 $r \\le r_{\\mathrm{floor}}$（其中 $r_{\\mathrm{floor}} = 0.7$，这被解释为易受数值不稳定性或短程处理不佳影响的短程碰撞区域），您必须停止模拟，并使用截至该点遇到的最小 $r$ 作为报告的 $r_{\\min}$。如果发生数值故障并生成了非有限值，您必须在该情况下报告 $r_{\\min} = 0.0$。\n- 所有距离均采用简化的 Lennard-Jones 长度单位，时间也采用简化单位。您必须将输出表示为简化长度单位下的无量纲浮点数。\n\n测试套件：\n\n使用以下四个 MD 案例，每个案例由一对 $(\\Delta t, v_{0})$ 定义，其中负的 $v_{0}$ 表示相互靠近。对于每个案例，运行两个模拟：一个使用无约束模型，另一个使用约束模型。报告每次运行的最小间距 $r_{\\min}$。\n\n- 案例 1：$\\Delta t = 0.005$, $v_{0} = -0.5$。\n- 案例 2：$\\Delta t = 0.010$, $v_{0} = -0.5$。\n- 案例 3：$\\Delta t = 0.020$, $v_{0} = -0.8$。\n- 案例 4：$\\Delta t = 0.040$, $v_{0} = -1.2$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个案例中无约束模型和约束模型的 $r_{\\min}$ 值。具体来说，输出必须是 $[r_{\\min}^{(1,\\mathrm{U})}, r_{\\min}^{(1,\\mathrm{C})}, r_{\\min}^{(2,\\mathrm{U})}, r_{\\min}^{(2,\\mathrm{C})}, r_{\\min}^{(3,\\mathrm{U})}, r_{\\min}^{(3,\\mathrm{C})}, r_{\\min}^{(4,\\mathrm{U})}, r_{\\min}^{(4,\\mathrm{C})}]$，所有值均为简化长度单位下的浮点数。", "solution": "该问题要求为一个一维双体系统构建、训练和评估两种不同的机器学习原子间势（MLIP）。核心目标是展示引入物理先验（特别是硬性短程排斥）对确保分子动力学（MD）模拟稳定性的重要性。\n\n解决方案分为四个主要阶段：(1) 从已知的物理势生成合成训练数据集。(2) 使用高斯基组和线性回归，定义并训练两种 MLIP 模型——一种无约束模型和一种内置排斥势垒的模型。(3) 推导并实现相应的原子间力。(4) 执行和分析正面对撞的 MD 模拟，以比较模型在短原子间距下的行为。\n\n**1. 训练数据生成**\n\n训练 MLIP需要一个物理上合理的参考势 $E_{\\mathrm{ref}}(r)$。问题指定了采用简化单位的 Lennard-Jones (LJ) 势，这是一个用于非键合原子相互作用的标准模型，其参数为 $\\epsilon = 1$ 和 $\\sigma = 1$：\n$$\nE_{\\mathrm{ref}}(r) = 4 \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right] = 4 \\left( \\frac{1}{r^{12}} - \\frac{1}{r^{6}} \\right)\n$$\n该势正确地捕捉了基本的物理特性：由于Pauli不相容原理，在短距离（$r \\to 0$）处存在强排斥核心；由于van der Waals力，在长距离处存在较弱的吸引尾部。我们通过在覆盖区间 $r \\in [0.9, 3.0]$ 的 $N=120$ 个均匀网格点上评估 $E_{\\mathrm{ref}}(r)$ 来生成合成训练数据集。选择此范围是为了覆盖排斥墙、势阱和吸引尾部的起始部分，但它故意排除了势能急剧发散的极短程区域（$r  0.9$）。\n\n**2. MLIP 模型架构与训练**\n\n两种 MLIP 都基于一个使用高斯基函数线性组合的灵活回归模型。每个模型的核心是一个函数 $g(r)$，定义为：\n$$\ng(r) = \\sum_{j=1}^{M} w_{j} \\phi_{j}(r)\n$$\n其中 $\\{w_j\\}$ 是可训练的权重，$\\{\\phi_j(r)\\}$ 是高斯基函数：\n$$\n\\phi_{j}(r) = \\exp\\left(-\\frac{(r - c_{j})^{2}}{2 s^{2}}\\right)\n$$\n问题指定了 $M=24$ 个基函数，其中心 $\\{c_j\\}$ 均匀分布在区间 $[0.8, 3.2]$ 内，共享宽度为 $s=0.25$。这套基函数为近似平滑函数提供了一个灵活的框架。两种模型的权重 $\\{w_j\\}$ 都是通过最小化一个正则化的二次损失函数（Ridge Regression）来确定的，该函数有解析解 $w = (\\Phi^T \\Phi + \\lambda I)^{-1} \\Phi^T y$，其中 $\\Phi$ 是设计矩阵，其元素为 $\\Phi_{ij} = \\phi_j(r_i)$，$y$ 是目标值向量，$\\lambda = 10^{-6}$ 是 Tikhonov 正则化系数。\n\n两种模型是：\n\n*   **无约束模型 ($E_{\\mathrm{U}}$):** 势能由高斯展开直接表示：\n    $$\n    E_{\\mathrm{U}}(r) = g_{\\mathrm{U}}(r) = \\sum_{j=1}^{M} w_{j}^{(\\mathrm{U})} \\phi_{j}(r)\n    $$\n    权重 $\\{w_{j}^{(\\mathrm{U})}\\}$ 通过将 $g_{\\mathrm{U}}(r)$ 拟合到训练网格上的参考能量 $E_{\\mathrm{ref}}(r)$ 来训练。该模型对其在训练域外的行为没有明确约束，特别是在 $r \\to 0$ 时。其短程行为纯粹是外推造成的人为结果。\n\n*   **约束模型 ($E_{\\mathrm{C}}$):** 该模型以固定的硬性排斥势垒项 $B(r)$ 的形式引入了物理先验。总势能为：\n    $$\n    E_{\\mathrm{C}}(r) = g_{\\mathrm{C}}(r) + B(r) = \\left(\\sum_{j=1}^{M} w_{j}^{(\\mathrm{C})} \\phi_{j}(r)\\right) + \\frac{c_{0}}{r^{p}}\n    $$\n    其中 $c_0=1.0$，$p=12$。这个势垒项 $B(r)$ 确保了当 $r \\to 0$ 时 $E_{\\mathrm{C}}(r) \\to \\infty$，而与 $g_{\\mathrm{C}}(r)$ 的行为无关。可训练部分 $g_{\\mathrm{C}}(r)$ 的任务是学习残差，即权重 $\\{w_{j}^{(\\mathrm{C})}\\}$ 通过拟合到修正后的目标 $E_{\\mathrm{ref}}(r) - B(r)$ 来训练。这种策略将一个已知的物理约束直接嵌入到模型函数形式中。\n\n**3. 力的计算**\n\n保守力 $F(r)$ 由势能 $E(r)$ 通过 $F(r) = -dE(r)/dr$ 推导得出。对我们的模型使用解析导数可以确保力与能量的一致性，这对于 MD 中的能量守恒至关重要。\n\n*   **无约束力 ($F_{\\mathrm{U}}$):**\n    $$\n    F_{\\mathrm{U}}(r) = -\\frac{dE_{\\mathrm{U}}}{dr} = -\\sum_{j=1}^{M} w_{j}^{(\\mathrm{U})} \\frac{d\\phi_{j}}{dr} = -\\sum_{j=1}^{M} w_{j}^{(\\mathrm{U})} \\left( -\\frac{r - c_j}{s^2} \\right) \\phi_j(r) = \\frac{1}{s^2} \\sum_{j=1}^{M} w_{j}^{(\\mathrm{U})} (r - c_j) \\phi_j(r)\n    $$\n\n*   **约束力 ($F_{\\mathrm{C}}$):**\n    $$\n    F_{\\mathrm{C}}(r) = -\\frac{dE_{\\mathrm{C}}}{dr} = -\\left( \\frac{dg_{\\mathrm{C}}}{dr} + \\frac{dB}{dr} \\right)\n    $$\n    势垒项的导数为 $\\frac{dB}{dr} = -p c_0 r^{-(p+1)}$。总力为：\n    $$\n    F_{\\mathrm{C}}(r) = \\left( \\frac{1}{s^2} \\sum_{j=1}^{M} w_{j}^{(\\mathrm{C})} (r - c_j) \\phi_j(r) \\right) + \\frac{p c_0}{r^{p+1}}\n    $$\n    第二项提供了一个在短程起主导作用的强解析排斥力，防止粒子对坍缩。\n\n**4. 分子动力学模拟**\n\n为了测试模型的高能碰撞行为，我们在质心坐标系中模拟了两个粒子的一维正面对撞。其动力学由相对坐标 $r(t)$ 的牛顿第二定律决定：\n$$\n\\mu \\frac{d^2r}{dt^2} = F(r)\n$$\n其中 $\\mu=0.5$ 是约化质量。我们使用 velocity-Verlet 算法来积分这个运动方程，这是一种时间可逆的、辛的积分器，非常适合 MD。从 $r(0)=r_0=1.5$ 和初始接近速度 $v(0)=v_0  0$ 开始，系统状态 $(r, v)$ 随时间演化。关键的可观测量是模拟过程中遇到的最小间距 $r_{\\min}$。如果达到时间上限 $t_{\\max}=3.0$，或者间距变得非物理的小（定义为 $r \\le r_{\\mathrm{floor}}=0.7$），模拟将终止。数值故障（生成非有限值）被视为灾难性的模型失败，此时报告 $r_{\\min}$ 为 $0.0$。这种设置直接探究了每种势模型在动态条件下排斥墙的质量。预计约束模型将更加稳健，能够持续产生有限的、物理的转折点（$r_{\\min} > r_{\\mathrm{floor}}$），而无约束模型则预计会失败或预测出非物理的穿透，特别是在高能碰撞（更大的 $|v_0|$）和更大的时间步长（$\\Delta t$）下。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Constructs, trains, and evaluates two machine learning interatomic potentials (MLIPs)\n    for a 1D two-body system to demonstrate the effect of a short-range repulsive prior.\n    \"\"\"\n    # 1. Define constants and parameters\n    # System\n    MU = 0.5\n    # Reference Potential (Lennard-Jones)\n    SIGMA = 1.0\n    # Training Data\n    R_TRAIN_MIN = 0.9\n    R_TRAIN_MAX = 3.0\n    N_TRAIN = 120\n    # Basis Set\n    M_BASIS = 24\n    C_MIN = 0.8\n    C_MAX = 3.2\n    S_WIDTH = 0.25\n    # Regularization\n    LAMBDA = 1e-6\n    # Barrier Prior\n    C0_BARRIER = 1.0\n    P_BARRIER = 12\n    # MD Simulation\n    R0 = 1.5\n    T_MAX = 3.0\n    R_FLOOR = 0.7\n\n    # 2. Generate Training Data\n    r_train = np.linspace(R_TRAIN_MIN, R_TRAIN_MAX, N_TRAIN)\n\n    def E_ref(r):\n        inv_r = SIGMA / r\n        inv_r6 = inv_r**6\n        inv_r12 = inv_r6**2\n        return 4.0 * (inv_r12 - inv_r6)\n\n    E_ref_train = E_ref(r_train)\n\n    # 3. Define Basis Set and Models\n    c_centers = np.linspace(C_MIN, C_MAX, M_BASIS)\n\n    def phi_basis(r_vals, centers, width):\n        r_col = np.atleast_1d(r_vals)[:, np.newaxis]\n        centers_row = np.atleast_1d(centers)[np.newaxis, :]\n        return np.exp(-(r_col - centers_row)**2 / (2 * width**2))\n\n    Phi_matrix = phi_basis(r_train, c_centers, S_WIDTH)\n\n    def train_weights(targets):\n        A = Phi_matrix.T @ Phi_matrix + LAMBDA * np.identity(M_BASIS)\n        b = Phi_matrix.T @ targets\n        weights = np.linalg.solve(A, b)\n        return weights\n\n    # Train Unconstrained Model\n    w_U = train_weights(E_ref_train)\n\n    # Train Constrained Model\n    def B_barrier(r):\n        with np.errstate(over='raise', invalid='raise'):\n            try:\n                return C0_BARRIER / r**P_BARRIER\n            except FloatingPointError:\n                # Handle cases where r is extremely small, causing overflow\n                return np.inf\n\n    target_C = E_ref_train - B_barrier(r_train)\n    w_C = train_weights(target_C)\n\n    # 4. Implement Force Functions\n    def get_force_func(weights, is_constrained):\n        def force(r):\n            # r is a scalar\n            if not np.isfinite(r) or r = 0:\n                raise ValueError(\"Non-physical distance in force calculation.\")\n            \n            # Derivative of Gaussian expansion part\n            phi_vals = np.exp(-(r - c_centers)**2 / (2 * S_WIDTH**2))\n            dphi_vals = -(r - c_centers) / S_WIDTH**2 * phi_vals\n            d_g_dr = np.sum(weights * dphi_vals)\n            \n            d_E_dr = d_g_dr\n            if is_constrained:\n                d_B_dr = -P_BARRIER * C0_BARRIER / r**(P_BARRIER + 1)\n                d_E_dr += d_B_dr\n            \n            return -d_E_dr\n        return force\n\n    force_U = get_force_func(w_U, is_constrained=False)\n    force_C = get_force_func(w_C, is_constrained=True)\n\n    # 5. Implement MD Simulation\n    def run_md(force_func, dt, v0):\n        r = R0\n        v = v0\n        min_r_so_far = r\n        \n        try:\n            a = force_func(r) / MU\n            if not np.isfinite(a): return 0.0\n        except (ValueError, FloatingPointError, ZeroDivisionError):\n            return 0.0\n            \n        num_steps = int(T_MAX / dt)\n        \n        for _ in range(num_steps):\n            v_half = v + 0.5 * a * dt\n            r_new = r + v_half * dt\n            \n            if not np.isfinite(r_new):\n                return 0.0\n            \n            min_r_so_far = min(min_r_so_far, r_new)\n            \n            if r_new = R_FLOOR:\n                return min_r_so_far\n            \n            try:\n                a_new = force_func(r_new) / MU\n                if not np.isfinite(a_new):\n                    return 0.0\n            except (ValueError, FloatingPointError, ZeroDivisionError):\n                return 0.0\n                \n            v_new = v_half + 0.5 * a_new * dt\n            \n            r, v, a = r_new, v_new, a_new\n            \n        return min_r_so_far\n\n    # 6. Run Test Cases and Collect Results\n    test_cases = [\n        (0.005, -0.5),\n        (0.010, -0.5),\n        (0.020, -0.8),\n        (0.040, -1.2)\n    ]\n    \n    results = []\n    \n    for dt, v0 in test_cases:\n        r_min_U = run_md(force_U, dt, v0)\n        results.append(r_min_U)\n        \n        r_min_C = run_md(force_C, dt, v0)\n        results.append(r_min_C)\n        \n    # 7. Format and Print Output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3462502"}]}