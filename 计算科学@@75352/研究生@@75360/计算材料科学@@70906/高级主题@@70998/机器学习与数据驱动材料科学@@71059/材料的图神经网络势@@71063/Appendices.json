{"hands_on_practices": [{"introduction": "图神经网络（GNN）势函数的一个核心设计原则是尊重物理对称性。对于旋转操作，这意味着标量性质的能量必须是*不变的*（在旋转下保持不变），而矢量性质的力则必须是*等变的*（随系统一同旋转）。此练习 [@problem_id:3455845] 提供了一种动手实践的方法，通过比较一个正确设计的旋转不变势和一个有意设计的非不变势，来数值化地验证能量的不变性 ($E(R\\mathbf{r}) = E(\\mathbf{r})$) 和力的等变性 ($\\mathbf{F}(R\\mathbf{r}) = R \\mathbf{F}(\\mathbf{r})$)，从而将抽象的对称性概念具体化。", "problem": "设计并实现一个程序，以经验性地量化材料科学中图神经网络势所使用的两种基于能量的原子间势的旋转等变性与不变性。该程序必须从以下原理出发：标量能量应具有旋转不变性，而作为能量相对于位置的负梯度的力，应像矢量一样变换，即若将旋转 $R \\in \\mathrm{SO}(3)$ 应用于原子位置，则对于旋转不变的势，能量满足 $E(R\\mathbf{r}) = E(\\mathbf{r})$，力满足 $\\mathbf{F}(R\\mathbf{r}) = R \\mathbf{F}(\\mathbf{r})$。所有量均使用无量纲约化单位，角度使用弧度。所有计算必须如下文所述是确定性的。\n\n您必须实现两个能量模型，这两个模型定义在一组包含 $N$ 个原子的集合上，其位置为 $\\mathbf{r} = \\{\\mathbf{r}_i\\}_{i=1}^N$，其中每个 $\\mathbf{r}_i \\in \\mathbb{R}^3$：\n\n- 模型 A（旋转不变对势）：总能量是成对加和 $E_{\\text{pair}}(\\mathbf{r}) = \\sum_{1 \\le i  j \\le N} g(d_{ij})$，其中 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2$，径向函数为\n$$\ng(d) = a_1 e^{-b_1 d} + a_2 e^{-b_2 d^2} + c \\frac{d^3}{1 + d^2}.\n$$\n使用固定常数 $a_1 = 1.5$、$b_1 = 1.1$、$a_2 = -0.9$、$b_2 = 0.7$ 和 $c = 0.04$。力必须根据定义 $\\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} E_{\\text{pair}}(\\mathbf{r})$ 计算，不得引入任何非旋转项。\n\n- 模型 B（有意为之的非不变各向异性能量）：总能量为\n$$\nE_{\\text{ani}}(\\mathbf{r}) = \\sum_{i=1}^N \\left( \\mathbf{w} \\cdot \\mathbf{r}_i \\right) + \\frac{1}{2} \\sum_{i=1}^N \\mathbf{r}_i^\\top A \\mathbf{r}_i,\n$$\n其中 $\\mathbf{w} = [0.3,\\,-0.5,\\,0.2]^\\top$ 且\n$$\nA = \\begin{bmatrix}\n1.2  0.1  0.0 \\\\\n0.1  0.8  0.05 \\\\\n0.0  0.05  0.6\n\\end{bmatrix}.\n$$\n力必须根据 $\\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} E_{\\text{ani}}(\\mathbf{r})$ 计算。\n\n为给定的旋转 $R \\in \\mathrm{SO}(3)$ 和位置 $\\mathbf{r}$ 定义以下误差度量：\n\n- 能量不变性误差：\n$$\n\\Delta_E = \\left| E(R\\mathbf{r}) - E(\\mathbf{r}) \\right|.\n$$\n- 力等变性均方根（RMS）误差：\n$$\n\\Delta_F = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left\\| \\mathbf{F}_i(R\\mathbf{r}) - R \\mathbf{F}_i(\\mathbf{r}) \\right\\|_2^2 }.\n$$\n\n旋转生成必须采用轴角表示法，轴在单位球面上均匀随机选取，角度在 $[0,2\\pi)$ 内均匀采样，并通过罗德里格斯公式构建。给定一个非负整数种子 $s$，确定性地初始化一个伪随机数生成器，并用它按规定生成轴和角度。当需要时，必须明确表示单位旋转。\n\n测试套件。在以下情况下评估度量 $(\\Delta_E,\\Delta_F)$；所有位置均以无量纲单位的三元组 $(x,y,z)$ 列表形式给出：\n\n- 情况 1：模型 A，位置为 $\\left[(0.0,0.0,0.0),(1.1,0.2,-0.3),(-0.4,1.3,0.7)\\right]$，随机旋转，种子为 $7$。\n- 情况 2：模型 A，位置与情况 1 相同，单位旋转。\n- 情况 3：模型 A，位置为 $\\left[(0.5,-0.8,0.9),(1.7,1.1,-0.4),(-1.2,0.3,0.6),(0.2,-1.5,1.3)\\right]$，随机旋转，种子为 $12345$。\n- 情况 4：模型 A，位置为 $\\left[(0.0,0.0,0.0)\\right]$，随机旋转，种子为 $99$。\n- 情况 5：模型 B，位置来自情况 1，随机旋转，种子为 $202$。\n- 情况 6：模型 B，位置为 $\\left[(0.0,0.0,0.0)\\right]$，随机旋转，种子为 $7$。\n\n算法要求和约束：\n\n- 所有计算必须以双精度浮点数进行。处理任何间距 $d_{ij}$ 小于安全阈值（例如 $10^{-12}$）的原子对时，应将其对力方向的贡献排除，以避免除以零，同时保持能量的良定义。\n- 角度单位为弧度。所有单位均为无量纲。不允许使用外部数据或用户输入。\n- 对于每种情况，计算 $(\\Delta_E,\\Delta_F)$ 并将每个值四舍五入到 $10$ 位小数。\n\n最终输出格式。您的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表，按以下展平顺序排列：\n$$\n[\\Delta_{E,1}, \\Delta_{F,1}, \\Delta_{E,2}, \\Delta_{F,2}, \\ldots, \\Delta_{E,6}, \\Delta_{F,6}],\n$$\n其中每个浮点值都按上述要求四舍五入到 $10$ 位小数。", "solution": "该问题是有效的，因为它具有科学依据、问题明确，并包含一套完整且一致的定义和约束。我现在将提供一个完整的解决方案。\n\n目标是经验性地量化两种不同原子间势能模型的旋转对称性质。如果一个物理系统的能量 $E$ 在整个系统被旋转时保持不变，则该能量是旋转不变的。如果在一个系统被旋转后，新的力矢量是原始力矢量经过相同旋转得到的结果，则该力场 $\\mathbf{F}$ 是旋转等变的。对于应用于一组原子位置 $\\mathbf{r} = \\{\\mathbf{r}_i\\}_{i=1}^N$ 的旋转 $R \\in \\mathrm{SO}(3)$，这些基本原理在数学上表示为：\n- 不变性（对于标量能量）：$E(R\\mathbf{r}) = E(\\mathbf{r})$\n- 等变性（对于矢量力）：对每个原子 $i$，$\\mathbf{F}_i(R\\mathbf{r}) = R \\mathbf{F}_i(\\mathbf{r})$。\n\n提供的误差度量 $\\Delta_E = \\left| E(R\\mathbf{r}) - E(\\mathbf{r}) \\right|$ 和 $\\Delta_F = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left\\| \\mathbf{F}_i(R\\mathbf{r}) - R \\mathbf{F}_i(\\mathbf{r}) \\right\\|_2^2 }$，可作为对任何偏离这些理想对称性质的直接计算度量。\n\n**旋转矩阵的生成**\n\n三维欧几里得空间中的旋转可以通过一个旋转轴（由单位向量 $\\mathbf{u} = [u_x, u_y, u_z]^\\top$ 表示）和一个旋转角 $\\theta$ 来指定。问题指定了一个用于生成随机旋转矩阵 $R$ 的确定性过程。首先，用一个种子初始化伪随机数生成器。然后，从单位球面 $S^2$ 上均匀采样一个随机轴 $\\mathbf{u}$，并从 $[0, 2\\pi)$ 中均匀采样一个随机角 $\\theta$。旋转矩阵 $R$ 使用罗德里格斯公式构建：\n$$\nR(\\mathbf{u}, \\theta) = I + (\\sin \\theta) K + (1 - \\cos \\theta) K^2\n$$\n其中 $I$ 是 $3 \\times 3$ 单位矩阵，$K$ 是与 $\\mathbf{u}$ 相关的叉积矩阵：\n$$\nK = \\begin{bmatrix} 0  -u_z  u_y \\\\ u_z  0  -u_x \\\\ -u_y  u_x  0 \\end{bmatrix}\n$$\n对于需要单位旋转的情况，我们只需使用 $R=I$。\n\n**模型 A：旋转不变对势**\n\n模型 A 的能量由下式给出：\n$$\nE_{\\text{pair}}(\\mathbf{r}) = \\sum_{1 \\le i  j \\le N} g(d_{ij}), \\quad \\text{其中 } d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2\n$$\n径向函数为 $g(d) = a_1 e^{-b_1 d} + a_2 e^{-b_2 d^2} + c \\frac{d^3}{1 + d^2}$。\n该势本质上是旋转不变的。刚性旋转会保持所有原子间距离 $d_{ij}$ 不变，因为欧几里得范数在正交变换下是不变的：\n$$\nd_{ij}' = \\|R\\mathbf{r}_i - R\\mathbf{r}_j\\|_2 = \\|R(\\mathbf{r}_i - \\mathbf{r}_j)\\|_2 = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2 = d_{ij}\n$$\n由于 $E_{\\text{pair}}$ 仅依赖于这些距离，所以 $E_{\\text{pair}}(R\\mathbf{r}) = E_{\\text{pair}}(\\mathbf{r})$，我们预期 $\\Delta_E$ 为零（在浮点数数值误差范围内）。\n\n作用在原子 $i$ 上的力是能量相对于其位置 $\\mathbf{r}_i$ 的负梯度：\n$$\n\\mathbf{F}_i(\\mathbf{r}) = -\\nabla_{\\mathbf{r}_i} E_{\\text{pair}}(\\mathbf{r}) = -\\sum_{j \\ne i} \\nabla_{\\mathbf{r}_i} g(d_{ij})\n$$\n使用链式法则，$\\nabla_{\\mathbf{r}_i} g(d_{ij}) = g'(d_{ij}) \\nabla_{\\mathbf{r}_i} d_{ij}$，其中 $g'(d) = \\frac{dg}{dd}$。距离的梯度是 $\\nabla_{\\mathbf{r}_i} d_{ij} = \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{d_{ij}}$。因此，原子 $j$ 施加在原子 $i$ 上的力为：\n$$\n\\mathbf{F}_{ij} = -g'(d_{ij}) \\frac{\\mathbf{r}_i - \\mathbf{r}_j}{d_{ij}}\n$$\n作用在原子 $i$ 上的总力为 $\\mathbf{F}_i = \\sum_{j \\ne i} \\mathbf{F}_{ij}$。径向函数的导数为：\n$$\ng'(d) = -a_1 b_1 e^{-b_1 d} - 2 a_2 b_2 d e^{-b_2 d^2} + c \\frac{d^2(3+d^2)}{(1+d^2)^2}\n$$\n为了数值稳定性，如果 $d_{ij}$ 低于某个阈值（$10^{-12}$），则其对力的贡献将被排除，以避免除以一个接近零的数。能量的贡献仍然被包括在内，因为 $g(d)$ 在 $d=0$ 时是良定义的。由于势是不变的，我们预期力是等变的，因此 $\\Delta_F$ 也应接近于零。\n\n**模型 B：非不变各向异性势**\n\n模型 B 的能量为：\n$$\nE_{\\text{ani}}(\\mathbf{r}) = \\sum_{i=1}^N \\left( \\mathbf{w} \\cdot \\mathbf{r}_i \\right) + \\frac{1}{2} \\sum_{i=1}^N \\mathbf{r}_i^\\top A \\mathbf{r}_i\n$$\n其中常数向量为 $\\mathbf{w}$，常数对称矩阵为 $A$。该势不是旋转不变的。对位置应用旋转 $R$ 后得到：\n$$\nE_{\\text{ani}}(R\\mathbf{r}) = \\sum_{i=1}^N \\left( \\mathbf{w} \\cdot (R\\mathbf{r}_i) \\right) + \\frac{1}{2} \\sum_{i=1}^N (R\\mathbf{r}_i)^\\top A (R\\mathbf{r}_i)\n$$\n利用点积和矩阵转置的性质，这变为：\n$$\nE_{\\text{ani}}(R\\mathbf{r}) = \\sum_{i=1}^N \\left( (R^\\top\\mathbf{w}) \\cdot \\mathbf{r}_i \\right) + \\frac{1}{2} \\sum_{i=1}^N \\mathbf{r}_i^\\top (R^\\top A R) \\mathbf{r}_i\n$$\n该表达式不等于 $E_{\\text{ani}}(\\mathbf{r})$，除非 $R^\\top\\mathbf{w}=\\mathbf{w}$ 且 $R^\\top A R = A$，而对于一般旋转 $R$ 这并不成立。因此，我们预期会有一个非零的能量不变性误差 $\\Delta_E$。\n\n作用在原子 $i$ 上的力通过对 $\\mathbf{r}_i$ 求梯度得到。不同原子的能量项是解耦的。使用标准向量微积分恒等式 $\\nabla_{\\mathbf{v}} (\\mathbf{c} \\cdot \\mathbf{v}) = \\mathbf{c}$ 和 $\\nabla_{\\mathbf{v}} (\\frac{1}{2}\\mathbf{v}^\\top M \\mathbf{v}) = M\\mathbf{v}$（对于对称矩阵 $M$），我们发现：\n$$\n\\nabla_{\\mathbf{r}_i} E_{\\text{ani}}(\\mathbf{r}) = \\mathbf{w} + A\\mathbf{r}_i\n$$\n因此，作用在原子 $i$ 上的力是：\n$$\n\\mathbf{F}_i(\\mathbf{r}) = -(\\mathbf{w} + A\\mathbf{r}_i)\n$$\n在旋转后的系统上的力是 $\\mathbf{F}_i(R\\mathbf{r}) = -(\\mathbf{w} + A R\\mathbf{r}_i)$。变换后的原始力是 $R\\mathbf{F}_i(\\mathbf{r}) = -R(\\mathbf{w} + A\\mathbf{r}_i)$。这两个量通常不相等，所以我们预期会有一个非零的力等变性误差 $\\Delta_F$。\n\n**计算流程**\n\n对于每个测试用例，算法按以下步骤进行：\n1.  确定模型（A 或 B）、原子位置 $\\mathbf{r}$ 和旋转种子。\n2.  生成旋转矩阵 $R$。如果种子是用于单位旋转，则 $R=I$。否则，根据种子确定性地生成一个随机旋转。\n3.  使用相应模型的方程计算初始能量 $E(\\mathbf{r})$ 和力 $\\mathbf{F}(\\mathbf{r})$。\n4.  将旋转应用于位置以获得 $R\\mathbf{r} = \\{R\\mathbf{r}_i\\}$。\n5.  计算旋转后系统的能量 $E(R\\mathbf{r})$ 和力 $\\mathbf{F}(R\\mathbf{r})$。\n6.  将旋转应用于原始力矢量以获得等变性目标 $R\\mathbf{F}(\\mathbf{r}) = \\{R\\mathbf{F}_i(\\mathbf{r})\\}$。\n7.  使用它们的定义计算误差 $\\Delta_E$ 和 $\\Delta_F$。对于模型 A 中单个原子（$N=1$）的奇异情况，能量和力恒为零，导致误差为零。对于模型 B，即使 $N=1$，能量和力也可以是非零的。\n8.  按要求将计算出的误差四舍五入到 10 位小数。然后，将所有情况的结果汇总并格式化为最终的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... is not needed\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Model A constants\n    A1 = 1.5\n    B1 = 1.1\n    A2 = -0.9\n    B2 = 0.7\n    C = 0.04\n\n    # Model B constants\n    W = np.array([0.3, -0.5, 0.2])\n    A_matrix = np.array([[1.2, 0.1, 0.0],\n                         [0.1, 0.8, 0.05],\n                         [0.0, 0.05, 0.6]])\n\n    # Numerical threshold for distance\n    DIST_THRESHOLD = 1e-12\n\n    def generate_rotation_matrix(seed):\n        \"\"\"Generates a 3x3 rotation matrix from a seed.\"\"\"\n        if seed is None:  # Identity rotation\n            return np.identity(3)\n\n        rng = np.random.default_rng(seed)\n        \n        # Generate a random axis uniformly on the unit sphere\n        axis = rng.normal(size=3)\n        norm = np.linalg.norm(axis)\n        if norm  DIST_THRESHOLD:\n            # Fallback for the exceedingly rare case of a zero vector\n            axis = np.array([0.0, 0.0, 1.0])\n        else:\n            axis /= norm\n        \n        # Generate a random angle\n        theta = rng.uniform(0, 2 * np.pi)\n\n        # Rodrigues' formula\n        K = np.array([[0, -axis[2], axis[1]],\n                      [axis[2], 0, -axis[0]],\n                      [-axis[1], axis[0], 0]])\n        \n        R = np.identity(3) + np.sin(theta) * K + (1 - np.cos(theta)) * (K @ K)\n        return R\n\n    def model_a_energy_forces(positions):\n        \"\"\"Calculates energy and forces for Model A.\"\"\"\n        pos = np.asarray(positions, dtype=np.float64)\n        n_atoms = pos.shape[0]\n        if n_atoms = 1:\n            return 0.0, np.zeros((n_atoms, 3))\n\n        total_energy = 0.0\n        forces = np.zeros_like(pos)\n\n        for i in range(n_atoms):\n            for j in range(i + 1, n_atoms):\n                rij_vec = pos[i] - pos[j]\n                d = np.linalg.norm(rij_vec)\n\n                if d  DIST_THRESHOLD:\n                    continue\n\n                # Energy contribution\n                d2 = d * d\n                d3 = d2 * d\n                g_d = A1 * np.exp(-B1 * d) + A2 * np.exp(-B2 * d2) + C * d3 / (1.0 + d2)\n                total_energy += g_d\n\n                # Force contribution\n                g_prime_d = -A1 * B1 * np.exp(-B1 * d) - 2 * A2 * B2 * d * np.exp(-B2 * d2) \\\n                            + C * (d2 * (3 + d2)) / ((1 + d2)**2)\n                \n                force_scalar = -g_prime_d / d\n                force_vec = force_scalar * rij_vec\n                forces[i] += force_vec\n                forces[j] -= force_vec\n        \n        return total_energy, forces\n\n    def model_b_energy_forces(positions):\n        \"\"\"Calculates energy and forces for Model B.\"\"\"\n        pos = np.asarray(positions, dtype=np.float64)\n        n_atoms = pos.shape[0]\n        if n_atoms == 0:\n            return 0.0, np.zeros((0, 3))\n            \n        total_energy = 0.0\n        forces = np.zeros_like(pos)\n        \n        # Term 1: w dot r\n        total_energy += np.sum(pos @ W)\n        \n        # Term 2: 1/2 r^T A r\n        for i in range(n_atoms):\n            total_energy += 0.5 * (pos[i] @ A_matrix @ pos[i])\n        \n        # Forces: F_i = -(w + A*r_i)\n        for i in range(n_atoms):\n            forces[i] = -(W + A_matrix @ pos[i])\n            \n        return total_energy, forces\n\n    def calculate_errors(model_func, positions, rotation_seed):\n        \"\"\"Computes Delta_E and Delta_F for a given model, positions, and rotation.\"\"\"\n        pos = np.asarray(positions, dtype=np.float64)\n        n_atoms = pos.shape[0]\n\n        # 1. Generate rotation\n        R = generate_rotation_matrix(rotation_seed)\n\n        # 2. Calculate initial energy and forces\n        E_orig, F_orig = model_func(pos)\n\n        # 3. Calculate rotated positions\n        pos_rot = (R @ pos.T).T\n\n        # 4. Calculate energy and forces on rotated system\n        E_rot, F_rot = model_func(pos_rot)\n        \n        # 5. Transform original forces\n        F_orig_rot = (R @ F_orig.T).T\n        \n        # 6. Compute errors\n        delta_E = np.abs(E_rot - E_orig)\n        \n        if n_atoms == 0:\n            delta_F = 0.0\n        else:\n            diff_F = F_rot - F_orig_rot\n            sum_sq_diff = np.sum(np.linalg.norm(diff_F, axis=1)**2)\n            delta_F = np.sqrt(sum_sq_diff / n_atoms)\n            \n        return round(delta_E, 10), round(delta_F, 10)\n\n    # Test suite definition\n    test_cases = [\n        # Case 1\n        {'model': 'A', 'pos': [(0.0,0.0,0.0),(1.1,0.2,-0.3),(-0.4,1.3,0.7)], 'seed': 7},\n        # Case 2\n        {'model': 'A', 'pos': [(0.0,0.0,0.0),(1.1,0.2,-0.3),(-0.4,1.3,0.7)], 'seed': None},\n        # Case 3\n        {'model': 'A', 'pos': [(0.5,-0.8,0.9),(1.7,1.1,-0.4),(-1.2,0.3,0.6),(0.2,-1.5,1.3)], 'seed': 12345},\n        # Case 4\n        {'model': 'A', 'pos': [(0.0,0.0,0.0)], 'seed': 99},\n        # Case 5\n        {'model': 'B', 'pos': [(0.0,0.0,0.0),(1.1,0.2,-0.3),(-0.4,1.3,0.7)], 'seed': 202},\n        # Case 6\n        {'model': 'B', 'pos': [(0.0,0.0,0.0)], 'seed': 7},\n    ]\n\n    results = []\n    for case in test_cases:\n        model_function = model_a_energy_forces if case['model'] == 'A' else model_b_energy_forces\n        delta_E, delta_F = calculate_errors(model_function, case['pos'], case['seed'])\n        results.extend([f\"{delta_E:.10f}\", f\"{delta_F:.10f}\"])\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3455845"}, {"introduction": "除了对称性，另一个基本的物理要求是原子间作用力必须是*保守的*，这意味着它可以从一个标量势能函数导出，即 $\\mathbf{F} = -\\nabla E$。这一性质确保了在分子动力学模拟中能量守恒。本练习 [@problem_id:3455790] 介绍了一种检验力场保守性的强大数值方法：计算力场沿闭合路径所做的功 ($\\oint_C \\mathbf{F} \\cdot d\\mathbf{r}$)，对于保守场，该积分必须为零。您将对一个包含保守和非保守部分的代理力场实施此测试，以理解如何检测和量化对保守性的偏离。", "problem": "您的任务是形式化并实现一个数值协议，用以评估基于图神经网络的分子动力学（GNN-MD，其中图神经网络缩写为GNN，分子动力学缩写为MD）所产生力的守恒性。其定义的物理原理是，对于一个守恒力场 $\\mathbf{F} = -\\nabla U$，在一个单连通域中，力场沿任意闭合回路 $C$ 的路径积分 $\\oint_C \\mathbf{F} \\cdot d\\mathbf{r}$ 为零。等价地，对于二维连续可微的矢量场，格林定理指出 $\\oint_C \\mathbf{F} \\cdot d\\mathbf{r} = \\iint_{\\Sigma} (\\nabla \\times \\mathbf{F}) \\cdot \\hat{\\mathbf{z}} \\, dA$，当 $\\nabla \\times \\mathbf{F} = \\mathbf{0}$ 时，该积分为零。在实践中，GNN-MD 在位形空间中生成的是离散轨迹，因此环路积分必须通过采样点来近似计算。\n\n您将实现一个 GNN 预测力场的二维代理模型，该模型在约化的、但具有物理可解释性的单位下，同时包含守恒和非守恒分量。距离单位为埃（Ångström），力单位为电子伏特每埃，路径积分（功）单位为电子伏特。该代理力场定义为\n$$\\mathbf{F}(x,y) = \\mathbf{F}_{\\text{cons}}(x,y) + \\mathbf{F}_{\\text{nc}}(x,y),$$\n其中\n$$U(x,y) = \\tfrac{1}{2} k (x^2 + y^2) + \\alpha \\cos(\\beta x)\\,\\sin(\\gamma y),$$\n$$\\mathbf{F}_{\\text{cons}}(x,y) = -\\nabla U(x,y),$$\n$$\\mathbf{F}_{\\text{nc}}(x,y) = \\varepsilon \\,(-y, x).$$\n非守恒分量是一个平面旋转场，其标量旋度为常数 $(\\nabla \\times \\mathbf{F}_{\\text{nc}}) \\cdot \\hat{\\mathbf{z}} = 2\\varepsilon$。对于任何包围面积 $A$ 的光滑、正向闭合回路 $C$，$\\mathbf{F}_{\\text{nc}}$ 的精确环流量满足\n$$\\oint_C \\mathbf{F}_{\\text{nc}} \\cdot d\\mathbf{r} = 2\\varepsilon A.$$\n\n您的程序必须：\n- 使用中点求积法则，在直线路段上近似计算多段线回路 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$（由 $\\mathbf{r}_N=\\mathbf{r}_0$ 闭合）上的路径积分：\n$$W \\approx \\sum_{i=0}^{N-1} \\mathbf{F}\\!\\left(\\tfrac{\\mathbf{r}_i+\\mathbf{r}_{i+1}}{2}\\right) \\cdot (\\mathbf{r}_{i+1}-\\mathbf{r}_i).$$\n- 使用鞋带公式计算回路所包围的有向面积 $A$，然后取其绝对值 $|A|$ 用于量级比较：\n$$A = \\tfrac{1}{2} \\sum_{i=0}^{N-1} \\left( x_i y_{i+1} - x_{i+1} y_i \\right).$$\n- 通过将 $W$ 与非守恒部分的理论基准 $2\\varepsilon A$ 以及守恒部分的理论基准 $0$ 进行比较，报告检验守恒性的诊断结果。\n\n实现以下五个测试用例，所有回路均指定为逆时针方向。请使用下面给出的精确参数值和回路。所有输出必须以电子伏特表示，并四舍五入到 $8$ 位小数。\n\n- 测试用例 1（纯守恒场；理想情况）：参数 $k=1.0$, $\\alpha=0.4$, $\\beta=1.3$, $\\gamma=2.1$, $\\varepsilon=0.0$。回路是一个顶点为 $(0,0)\\to(1,0)\\to(1,2)\\to(0,2)$ 的矩形，每条边被细分为 $50$ 个相等的线段，并按顺序连接。输出绝对环流量 $|W|$。\n\n- 测试用例 2（纯非守恒场；与面积定律的解析检验）：参数 $k=0.0$, $\\alpha=0.0$, $\\beta=0.0$, $\\gamma=0.0$, $\\varepsilon=0.1$。回路是一个半径为 $R=1.0$ 的圆，在 $N=400$ 个均匀间隔的点上进行采样。输出绝对误差 $|W - 2\\varepsilon A|$。\n\n- 测试用例 3（混合场；守恒部分积分应为零）：参数 $k=0.5$, $\\alpha=0.2$, $\\beta=1.5$, $\\gamma=2.0$, $\\varepsilon=0.05$。回路是一条平滑的“花瓣-椭圆”曲线，通过在 $[0,2\\pi)$ 上均匀间隔的 $\\theta$ 对 $\\mathbf{r}(\\theta) = \\left(a\\cos\\theta + c_3\\cos(3\\theta), \\, b\\sin\\theta\\right)$ 进行采样，生成一个包含 $N=1200$ 个点的多段线，其中 $a=1.2$, $b=0.8$, $c_3=0.2$。输出绝对误差 $|W - 2\\varepsilon A|$。\n\n- 测试用例 4（边缘情况小回路；面积趋于零）：参数 $k=0.0$, $\\alpha=0.0$, $\\beta=0.0$, $\\gamma=0.0$, $\\varepsilon=0.2$。回路是一个半径为 $R=10^{-3}$ 的圆，在 $N=100$ 个点上进行采样。输出绝对环流量 $|W|$。\n\n- 测试用例 5（离散化敏感性；分辨率的边界条件）：参数 $k=0.0$, $\\alpha=0.0$, $\\beta=0.0$, $\\gamma=0.0$, $\\varepsilon=0.3$。回路是一个半径为 $R=1.0$ 的圆。用 $N=12$ 个点计算一个环流量 $W_{\\text{coarse}}$，用 $N=1000$ 个点计算另一个环流量 $W_{\\text{fine}}$。输出绝对差 $|W_{\\text{coarse}} - W_{\\text{fine}}|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 5 的顺序排列结果，每个结果四舍五入到 8 位小数（例如，$[x_1,x_2,x_3,x_4,x_5]$）。", "solution": "该问题要求实现一个数值协议，用以评估给定二维力场的守恒性，该力场可作为图神经网络势产生的力的代理模型。该协议基于矢量微积分和经典力学的一个基本原理：一个力场 $\\mathbf{F}$ 是守恒的，当且仅当它沿任意闭合路径 $C$ 的路径积分为零。这表示为：\n$$W = \\oint_C \\mathbf{F} \\cdot d\\mathbf{r} = 0$$\n对于二维连续可微的矢量场，此条件等价于该场的旋度为零，即 $\\nabla \\times \\mathbf{F} = \\mathbf{0}$，这是由格林定理 $\\oint_C \\mathbf{F} \\cdot d\\mathbf{r} = \\iint_\\Sigma (\\nabla \\times \\mathbf{F}) \\cdot \\hat{\\mathbf{z}} \\, dA$ 所决定的，其中 $\\Sigma$ 是由 $C$ 包围的区域。\n\n提供的力场是守恒分量和非守恒分量之和：$\\mathbf{F}(x,y) = \\mathbf{F}_{\\text{cons}}(x,y) + \\mathbf{F}_{\\text{nc}}(x,y)$。\n\n守恒分量 $\\mathbf{F}_{\\text{cons}}(x,y)$ 定义为一个标量势 $U(x,y)$ 的负梯度，其中\n$$U(x,y) = \\tfrac{1}{2} k (x^2 + y^2) + \\alpha \\cos(\\beta x)\\,\\sin(\\gamma y)$$\n因此，$\\mathbf{F}_{\\text{cons}}(x,y) = -\\nabla U(x,y)$。该力的分量为：\n$$F_{x, \\text{cons}}(x,y) = -\\frac{\\partial U}{\\partial x} = -kx + \\alpha\\beta \\sin(\\beta x)\\sin(\\gamma y)$$\n$$F_{y, \\text{cons}}(x,y) = -\\frac{\\partial U}{\\partial y} = -ky - \\alpha\\gamma \\cos(\\beta x)\\cos(\\gamma y)$$\n根据梯度定理，任何梯度场沿闭合回路的路径积分恒为零：$\\oint_C \\mathbf{F}_{\\text{cons}} \\cdot d\\mathbf{r} = 0$。\n\n非守恒分量是一个平面旋转场，$\\mathbf{F}_{\\text{nc}}(x,y) = \\varepsilon (-y, x)$。其旋度为一个常数：\n$$(\\nabla \\times \\mathbf{F}_{\\text{nc}}) \\cdot \\hat{\\mathbf{z}} = \\frac{\\partial (\\varepsilon x)}{\\partial x} - \\frac{\\partial (-\\varepsilon y)}{\\partial y} = \\varepsilon - (-\\varepsilon) = 2\\varepsilon$$\n对此分量应用格林定理，可以得到其环流量与回路 $C$ 所包围面积 $A$ 之间的直接关系：\n$$\\oint_C \\mathbf{F}_{\\text{nc}} \\cdot d\\mathbf{r} = \\iint_\\Sigma (2\\varepsilon) \\, dA = 2\\varepsilon A$$\n\n综合这些结果，总力场 $\\mathbf{F}$ 沿闭合回路 $C$ 所做的解析功 $W$ 为：\n$$W = \\oint_C \\mathbf{F} \\cdot d\\mathbf{r} = \\oint_C \\mathbf{F}_{\\text{cons}} \\cdot d\\mathbf{r} + \\oint_C \\mathbf{F}_{\\text{nc}} \\cdot d\\mathbf{r} = 0 + 2\\varepsilon A = 2\\varepsilon A$$\n这个解析关系构成了验证数值结果的基础。\n\n数值实现必须针对由顶点 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ 定义的离散多段线回路（通过设置 $\\mathbf{r}_N = \\mathbf{r}_0$ 闭合）来近似连续积分。\n路径积分 $W$ 使用中点求积法则进行近似，该法则在每个线段的中心点评估力：\n$$W \\approx \\sum_{i=0}^{N-1} \\mathbf{F}\\!\\left(\\tfrac{\\mathbf{r}_i+\\mathbf{r}_{i+1}}{2}\\right) \\cdot (\\mathbf{r}_{i+1}-\\mathbf{r}_i)$$\n由顶点定义的多边形面积 $A$ 使用鞋带公式精确计算：\n$$A = \\tfrac{1}{2} \\sum_{i=0}^{N-1} \\left( x_i y_{i+1} - x_{i+1} y_i \\right)$$\n\n算法的流程是首先定义计算力矢量 $\\mathbf{F}(x,y)$、路径积分 $W$ 和多边形面积 $A$ 的函数。对于每个测试用例，生成特定的回路顶点。然后，使用参数（$k, \\alpha, \\beta, \\gamma, \\varepsilon$）计算 $W$ 和 $A$。最后，计算一个特定的诊断量。例如，量 $|W - 2\\varepsilon A|$ 是计算场中守恒部分路径积分的数值误差的度量，因为 $|W_{\\text{numerical}} - 2\\varepsilon A_{\\text{numerical}}| \\approx |W_{\\text{cons, numerical}}|$，其理想值应为零。每个测试用例都旨在探究力场行为的特定方面或数值方法的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a numerical protocol to assess the\n    conservativeness of a 2D surrogate force field. The protocol involves\n    computing line integrals over closed loops and comparing them to\n    theoretical expectations.\n    \"\"\"\n\n    def get_force(pos, k, alpha, beta, gamma, epsilon):\n        \"\"\"\n        Computes the force vector F(x,y) at a given position.\n\n        The force is a sum of a conservative part F_cons = -grad(U) and a\n        non-conservative part F_nc.\n        \"\"\"\n        x, y = pos[0], pos[1]\n        \n        # Conservative force component F_cons = -grad(U)\n        fx_cons = -k * x + alpha * beta * np.sin(beta * x) * np.sin(gamma * y)\n        fy_cons = -k * y - alpha * gamma * np.cos(beta * x) * np.cos(gamma * y)\n        \n        # Non-conservative force component F_nc = epsilon*(-y, x)\n        fx_nc = -epsilon * y\n        fy_nc =  epsilon * x\n        \n        return np.array([fx_cons + fx_nc, fy_cons + fy_nc])\n\n    def calculate_work(loop_points, k, alpha, beta, gamma, epsilon):\n        \"\"\"\n        Approximates the line integral W = oint_C F.dr over the closed \n        polyline loop using the midpoint quadrature rule.\n        'loop_points' must be an array of shape (N+1, 2) where \n        loop_points[N] == loop_points[0].\n        \"\"\"\n        work = 0.0\n        num_segments = loop_points.shape[0] - 1\n        for i in range(num_segments):\n            r_i = loop_points[i]\n            r_i_plus_1 = loop_points[i+1]\n            \n            mid_point = 0.5 * (r_i + r_i_plus_1)\n            displacement = r_i_plus_1 - r_i\n            \n            force_at_midpoint = get_force(mid_point, k, alpha, beta, gamma, epsilon)\n            \n            work += np.dot(force_at_midpoint, displacement)\n        return work\n\n    def calculate_area(loop_points):\n        \"\"\"\n        Calculates the signed area of the polygon defined by loop_points\n        using the shoelace formula.\n        'loop_points' must be an array of shape (N+1, 2) where \n        loop_points[N] == loop_points[0].\n        \"\"\"\n        area = 0.0\n        num_segments = loop_points.shape[0] - 1\n        for i in range(num_segments):\n            x_i, y_i = loop_points[i]\n            x_i_plus_1, y_i_plus_1 = loop_points[i+1]\n            \n            area += (x_i * y_i_plus_1 - x_i_plus_1 * y_i)\n        return 0.5 * area\n\n    results = []\n\n    # Test Case 1: Purely conservative field.\n    k, alpha, beta, gamma, epsilon = 1.0, 0.4, 1.3, 2.1, 0.0\n    num_sub = 50\n    p0, p1, p2, p3 = np.array([0,0]), np.array([1,0]), np.array([1,2]), np.array([0,2])\n    path1 = np.linspace(p0, p1, num_sub + 1, endpoint=True)[:-1]\n    path2 = np.linspace(p1, p2, num_sub + 1, endpoint=True)[:-1]\n    path3 = np.linspace(p2, p3, num_sub + 1, endpoint=True)[:-1]\n    path4 = np.linspace(p3, p0, num_sub + 1, endpoint=True)[:-1]\n    loop1_vertices = np.vstack((path1, path2, path3, path4))\n    loop1_closed = np.vstack((loop1_vertices, loop1_vertices[0]))\n    W1 = calculate_work(loop1_closed, k, alpha, beta, gamma, epsilon)\n    results.append(np.abs(W1))\n\n    # Test Case 2: Purely non-conservative field.\n    k, alpha, beta, gamma, epsilon = 0.0, 0.0, 0.0, 0.0, 0.1\n    R, N_pts = 1.0, 400\n    theta = np.linspace(0, 2 * np.pi, N_pts, endpoint=False)\n    x = R * np.cos(theta)\n    y = R * np.sin(theta)\n    loop2_vertices = np.vstack((x, y)).T\n    loop2_closed = np.vstack((loop2_vertices, loop2_vertices[0]))\n    W2 = calculate_work(loop2_closed, k, alpha, beta, gamma, epsilon)\n    A2 = calculate_area(loop2_closed)\n    results.append(np.abs(W2 - 2 * epsilon * A2))\n\n    # Test Case 3: Mixed field.\n    k, alpha, beta, gamma, epsilon = 0.5, 0.2, 1.5, 2.0, 0.05\n    N_pts, a, b, c3 = 1200, 1.2, 0.8, 0.2\n    theta = np.linspace(0, 2 * np.pi, N_pts, endpoint=False)\n    x = a * np.cos(theta) + c3 * np.cos(3 * theta)\n    y = b * np.sin(theta)\n    loop3_vertices = np.vstack((x, y)).T\n    loop3_closed = np.vstack((loop3_vertices, loop3_vertices[0]))\n    W3 = calculate_work(loop3_closed, k, alpha, beta, gamma, epsilon)\n    A3 = calculate_area(loop3_closed)\n    results.append(np.abs(W3 - 2 * epsilon * A3))\n    \n    # Test Case 4: Small loop edge case.\n    k, alpha, beta, gamma, epsilon = 0.0, 0.0, 0.0, 0.0, 0.2\n    R, N_pts = 1e-3, 100\n    theta = np.linspace(0, 2 * np.pi, N_pts, endpoint=False)\n    x = R * np.cos(theta)\n    y = R * np.sin(theta)\n    loop4_vertices = np.vstack((x, y)).T\n    loop4_closed = np.vstack((loop4_vertices, loop4_vertices[0]))\n    W4 = calculate_work(loop4_closed, k, alpha, beta, gamma, epsilon)\n    results.append(np.abs(W4))\n\n    # Test Case 5: Discretization sensitivity.\n    k, alpha, beta, gamma, epsilon = 0.0, 0.0, 0.0, 0.0, 0.3\n    R = 1.0\n    # Coarse loop\n    N_coarse = 12\n    theta_coarse = np.linspace(0, 2 * np.pi, N_coarse, endpoint=False)\n    x_coarse = R * np.cos(theta_coarse)\n    y_coarse = R * np.sin(theta_coarse)\n    loop5_coarse_v = np.vstack((x_coarse, y_coarse)).T\n    loop5_coarse_c = np.vstack((loop5_coarse_v, loop5_coarse_v[0]))\n    W_coarse = calculate_work(loop5_coarse_c, k, alpha, beta, gamma, epsilon)\n    # Fine loop\n    N_fine = 1000\n    theta_fine = np.linspace(0, 2 * np.pi, N_fine, endpoint=False)\n    x_fine = R * np.cos(theta_fine)\n    y_fine = R * np.sin(theta_fine)\n    loop5_fine_v = np.vstack((x_fine, y_fine)).T\n    loop5_fine_c = np.vstack((loop5_fine_v, loop5_fine_v[0]))\n    W_fine = calculate_work(loop5_fine_c, k, alpha, beta, gamma, epsilon)\n    results.append(np.abs(W_coarse - W_fine))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.8f}' for r in results])}]\")\n\nsolve()\n```", "id": "3455790"}]}