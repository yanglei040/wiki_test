{"hands_on_practices": [{"introduction": "进化算法在探索势能面时，可能会反复生成并评估因旋转、平移或原子置换而等价的结构，这会极大浪费计算资源。本实践旨在解决这一关键的效率问题，通过构建一个对晶体对称性操作不变的结构“指纹”，来唯一地识别每一个候选结构，从而有效避免种群中的冗余，提高搜索效率。[@problem_id:3450460]", "problem": "考虑一个用于计算材料科学中晶体结构预测的基于种群的演化算法（EA）。每个候选结构由一个 Bravais 晶胞及其晶格矢量和在该晶胞内遵循周期性边界条件的一组原子位置来指定。假设以下两个事实为基本依据：(i) 对于固定组分，一个结构的能量 $E(\\{\\mathbf{r}_i\\}, \\{\\mathrm{s}_i\\})$ 仅取决于原子间距和化学特性的集合，并且在刚性平移、晶格点群对称性以及不可区分原子的置换下保持不变；(ii) EA 使用的适应度 $F$ 仅取决于能量 $E$ 和晶胞体积 $V$。基于这些依据，推导为何任意两个对称等价的结构必须具有简并的适应度值，即相同的对称性会保持所有配对距离不变，从而使 $E$ 和 $V$ 不变，因此 $F$ 也不变。然后，为避免演化种群中出现冗余的重复结构，提出一种基于对称不变指纹和容差的有原则的策略，该策略能将在对称性和数值噪声容许范围内几何构型无法区分的结构归并为单一代表。\n\n为使此推导可通过计算进行检验，请在一个完整的程序中实现以下内容：\n\n1) 使用一个玩具但定义明确的能量泛函来实例化 $E$，同时遵循 $E$ 仅是原子间距和化学特性函数的基本依据。设能量为\n$$\nE(\\{\\mathbf{r}_i\\}, \\{\\mathrm{s}_i\\}) \\;=\\; \\sum_{1 \\le i < j \\le N} \\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j} \\, \\exp\\!\\big(-\\alpha\\, d_{ij}\\big),\n$$\n其中 $d_{ij}$ 是周期性正交晶胞中原子 $i$ 和 $j$ 之间的最小镜像距离，$\\alpha$ 是一个正常数，$\\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j}$ 是原子对相互作用系数，且 $\\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j} = \\varepsilon_{\\mathrm{s}_j,\\mathrm{s}_i}$。适应度定义为\n$$\nF \\;=\\; E \\;+\\; \\lambda\\, V,\n$$\n其中 $V$ 是晶胞体积。使用参数值 $\\alpha = 1.0$ (单位 $\\mathrm{\\AA^{-1}}$)，$\\lambda = 0.01$ (单位与 $E$ 和 $V$ 一致)，以及相互作用系数\n$\\varepsilon_{\\mathrm{A},\\mathrm{A}} = -1.0$，$\\varepsilon_{\\mathrm{B},\\mathrm{B}} = -1.0$，$\\varepsilon_{\\mathrm{A},\\mathrm{B}} = -1.5$ (根据对称性 $\\varepsilon_{\\mathrm{B},\\mathrm{A}} = \\varepsilon_{\\mathrm{A},\\mathrm{B}}$)。对于单组分体系 $\\mathrm{X}$，使用 $\\varepsilon_{\\mathrm{X},\\mathrm{X}} = -1.0$。距离 $d_{ij}$ 必须在边长为 $a, b, c$ (单位 $\\mathrm{\\AA}$) 的正交晶胞中使用最小镜像约定计算。体积为 $V = a b c$ (单位 $\\mathrm{\\AA^3}$)。\n\n2) 实现一个对称不变的结构指纹 $g$，它仅取决于原子间的几何构型，并且在刚性平移和不可区分原子的置换下保持不变。将 $g$ 定义为所有配对最小镜像距离 $\\{d_{ij}\\}_{i<j}$ (单位 $\\mathrm{\\AA}$) 的排序列表。如果两个结构的适应度值在容差 $\\tau_F$ 内数值上无法区分，或者它们的指纹在以排序后距离列表之差的欧几里得范数度量的容差 $\\tau_g$ 内数值上无法区分，则认为这两个结构是重复的。使用 $\\tau_F = 10^{-8}$ (单位与 $F$ 相同) 和 $\\tau_g = 2\\times 10^{-2}$ (单位 $\\mathrm{\\AA}$)。\n\n3) 对于下面的每个测试用例，程序必须输出一个布尔值，指示这对结构在第2项提出的策略下是否为重复结构（即，当且仅当 $\\lvert F_1 - F_2\\rvert \\le \\tau_F$ 或 $\\lVert g_1 - g_2\\rVert_2 \\le \\tau_g$ 时，输出 $\\mathrm{True}$）。所有坐标均为晶胞内的分数坐标（无量纲）。所有晶胞长度单位均为 $\\mathrm{\\AA}$。最小镜像约定应在转换为笛卡尔距离之前，将分数坐标差沿每个正交轴包裹到区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内。\n\n测试套件（四个用例）：\n\n- 用例1 (理想路径，全局平移不变性)：结构 A：单组分 $\\mathrm{X}$，晶胞边长 $a=b=c=3.0$，原子位于 $(0.0,0.0,0.0)$ 和 $(0.5,0.5,0.5)$。结构 B：将结构 A 的所有原子平移 $(0.37, 0.41, 0.13)$，并对各分量模1。预期行为：重复。\n\n- 用例2 (边界条件，均匀缩放改变体积和距离)：结构 C：单组分 $\\mathrm{X}$，与结构 A 具有相同的分数坐标，但晶胞边长为 $a=b=c=6.0$。与结构 A 进行比较。预期行为：不重复。\n\n- 用例3 (边缘情况，微小的数值噪声)：结构 D：从用例1中的结构 B 开始，然后对第一个原子添加微小的分数坐标扰动 $\\delta\\mathbf{f}_1=(0.001, -0.001, 0.0005)$，对第二个原子添加 $\\delta\\mathbf{f}_2=(-0.001, 0.001, -0.0005)$，然后模1。与结构 B 进行比较。预期行为：即使 $\\lvert F_1 - F_2\\rvert > \\tau_F$，也因指纹在 $\\tau_g$ 范围内而判定为重复。\n\n- 用例4 (多组分，置换和平移)：结构 E：组分为 $\\{\\mathrm{A}, \\mathrm{A}, \\mathrm{B}, \\mathrm{B}\\}$，位于一个立方晶胞中，边长 $a=b=c=5.0$，分数坐标为 $(0.0,0.0,0.0)$, $(0.0,0.5,0.5)$, $(0.5,0.0,0.5)$, $(0.5,0.5,0.0)$。结构 F：将结构 E 的所有原子平移 $(0.25, 0.25, 0.25)$ 并模1，然后任意重排原子。预期行为：重复。\n\n您的程序必须实现上述定义，评估四个测试用例，并生成单行输出，其中包含一个方括号括起来的、以逗号分隔的布尔值列表的结果，顺序与测试用例1到4相对应（例如， $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$）。程序无需用户输入，也不能读取外部文件。所有计算必须是自包含的。由于输出是布尔值，因此输出中无需打印单位。", "solution": "该问题要求一个两部分的回答：首先，对对称等价晶体结构的适应度简并性进行理论推导；其次，实现一个用于识别此类重复结构的计算策略。\n\n### 理论推导：对称等价结构的适应度简并性\n\n分析从提供的两个基本依据开始：\n(i) 对于固定组分，一个结构的能量 $E(\\{\\mathbf{r}_i\\}, \\{\\mathrm{s}_i\\})$ 仅是所有原子间距的集合 $\\{d_{ij}\\}$ 和原子对的化学特性集合 $\\{(\\mathrm{s}_i, \\mathrm{s}_j)\\}$ 的函数。\n(ii) 适应度 $F$ 仅是能量 $E$ 和晶胞体积 $V$ 的函数，记为 $F(E, V)$。\n\n晶体上的对称操作被定义为一个仿射变换 $(\\mathbf{W}, \\mathbf{w})$，它将晶格映射到其自身，并保持每个位点上原子种类的特性不变。此变换作用于原子位置矢量 $\\mathbf{r}_i$ 上，产生一个新的位置 $\\mathbf{r}'_k = \\mathbf{W}\\mathbf{r}_i + \\mathbf{w}$。矩阵 $\\mathbf{W}$ 是晶格点群的一个成员，$\\mathbf{w}$ 是一个平移矢量。根据定义，这类变换是等距变换，意味着它们保持距离不变。\n\n让我们考虑两个结构，结构1和结构2，其中结构2是通过对结构1应用对称操作得到的。\n\n1.  **原子间距的不变性**：等距变换保持所有点积不变，因此也保持所有欧几里得距离不变。当应用于周期性边界条件下的晶体结构时，对称操作将所有原子位置的集合 $\\{\\mathbf{r}_i\\}$ 映射到一个新的集合 $\\{\\mathbf{r}'_k\\}$。其关键结果是，结构1中所有最小镜像配对距离的集合 $\\{d_{ij}\\}$ 与结构2中配对距离的集合 $\\{d'_{kl}\\}$ 是相同的。整个距离集合是该变换的一个不变量。\n\n2.  **原子种类配对的不变性**：缀饰晶格（带有原子的晶格）的对称操作还要求，种类为 $\\mathrm{s}_i$ 的原子被映射到一个先前由相同种类原子占据的位置上。因此，与每个距离 $d_{ij}$ 相关联的原子种类配对集合 $\\{(\\mathrm{s}_i, \\mathrm{s}_j)\\}$ 在对称操作下也得以保持。不可区分原子的置换是此原则的一个特例。\n\n3.  **能量 ($E$) 的不变性**：基于前提(i)，能量 $E$ 仅仅是集合 $\\{d_{ij}\\}$ 和 $\\{(\\mathrm{s}_i, \\mathrm{s}_j)\\}$ 的函数。由于这两个集合在对称操作下都是不变的，系统的能量也必须是不变的。如果 $E_1$ 和 $E_2$ 分别是结构1和结构2的能量，那么 $E_1 = E_2$。所提供的特定能量泛函 $E = \\sum_{i<j} \\varepsilon_{\\mathrm{s}_i,\\mathrm{s}_j} \\exp(-\\alpha d_{ij})$ 遵循此原则。\n\n4.  **体积 ($V$) 的不变性**：对称操作是体积保持的。晶胞体积 $V = |\\det(\\mathbf{A})|$，其中 $\\mathbf{A}$ 是由晶格矢量组成的矩阵。对称操作将 $\\mathbf{A}$ 变换为 $\\mathbf{A}'=\\mathbf{W}\\mathbf{A}$。由于 $\\mathbf{W}$ 是点群的一个元素，它是一个正交矩阵（对于笛卡尔坐标系）或一个行列式为 $\\pm 1$ 的整数矩阵（对于晶格坐标系）。在任何情况下，体积 $V'=|\\det(\\mathbf{A}')|=|\\det(\\mathbf{W})\\det(\\mathbf{A})|=|\\pm 1|V=V$。因此，$V_1 = V_2$。\n\n5.  **适应度 ($F$) 的不变性**：基于前提(ii)，适应度 $F$ 是 $E$ 和 $V$ 的函数。由于对于对称等价的结构，我们有 $E_1=E_2$ 和 $V_1=V_2$，那么它们的适应度也必须相同，$F(E_1, V_1) = F(E_2, V_2)$。这证明了适应度值是简并的。\n\n### 计算策略\n\n为了在演化算法中避免处理冗余的对称等价结构，我们实现了一种检测重复的策略。\n\n1.  **对称不变指纹**：理想的指纹应在对称操作下保持不变。所提议的指纹 $g$ 是所有唯一配对距离的排序列表 $\\{d_{ij}\\}_{i<j}$。\n    *   **平移不变性**：距离 $d_{ij}$ 是通过矢量差计算的，这自然使其不受公共平移的影响。\n    *   **置换不变性**：通过对距离列表进行排序，指纹变得与原子索引的标记方式无关。这涵盖了对相同种类原子的置换。\n    *   **旋转/镜像不变性**：由于距离本身是标量，它们在旋转或镜像操作下是不变的。因此，由这些距离组成的排序列表也是不变的。\n\n2.  **重复检测逻辑**：当向种群中添加一个新结构时，会将其与所有现有成员进行比较。如果满足以下任一条件，则认为新结构是重复的：\n    *   **适应度匹配**：$|F_{\\text{new}} - F_{\\text{existing}}| \\le \\tau_F$。这捕获了具有（几乎）相同能量和体积的结构，这强烈暗示它们是等价的。\n    *   **几何匹配**：$\\|g_{\\text{new}} - g_{\\text{existing}}\\|_2 \\le \\tau_g$。这直接比较了它们的几何构型。即使由于数值噪声或微小扰动导致适应度略有不同，此条件也能识别出基本上相同的结构。\n\n使用“或”条件是至关重要的。在理想情况下（无数值噪声），对称等价结构会有相同的适应度和相同的指纹。然而，在实践中，数值不精确可能导致能量上出现微小差异。几何指纹对于这种噪声通常更为稳健。因此，如果两个结构的几何形状足够接近（在 $\\tau_g$ 范围内），即使它们的能量计算结果（由于数值问题）略有不同（超出 $\\tau_F$），我们也应将它们视为重复。反之，极不可能出现两个截然不同的几何结构（指纹相差很大）恰好具有相同的适应度，但如果发生了，将它们视为“重复”以进行种群控制也是一种合理的策略，可以防止具有相同适应度值的不同结构同时存在。", "answer": "```python\nimport numpy as np\n\n# A class to represent a crystal structure, simplifying data management.\nclass Structure:\n    \"\"\"Encapsulates the properties of a crystal structure.\"\"\"\n    def __init__(self, cell_dims, frac_coords, species):\n        # Cell dimensions [a, b, c] in Angstroms.\n        self.cell_dims = np.array(cell_dims, dtype=float)\n        # Fractional coordinates of atoms, shape (N, 3).\n        self.frac_coords = np.array(frac_coords, dtype=float)\n        # List of atomic species symbols (e.g., 'A', 'X').\n        self.species = species\n        # Number of atoms in the cell.\n        self.natoms = len(species)\n        # Volume of the orthorhombic cell.\n        self.volume = np.prod(self.cell_dims)\n\ndef min_image_dist(p1_frac, p2_frac, cell_dims):\n    \"\"\"\n    Calculates the minimum image distance between two atoms in a periodic\n    orthorhombic cell.\n    \"\"\"\n    # Calculate the difference in fractional coordinates.\n    delta_frac = p1_frac - p2_frac\n    # Apply the minimum image convention by wrapping the difference vector\n    # to the interval [-0.5, 0.5).\n    # The expression (x + 0.5) % 1.0 - 0.5 correctly maps to this interval.\n    delta_frac = (delta_frac + 0.5) % 1.0 - 0.5\n    # Convert the fractional difference vector to a Cartesian vector.\n    delta_cart = delta_frac * cell_dims\n    # Calculate and return the Euclidean norm (length) of the Cartesian vector.\n    return np.linalg.norm(delta_cart)\n\ndef calculate_fingerprint(structure):\n    \"\"\"\n    Calculates the symmetry-invariant structural fingerprint, defined as the\n    sorted list of all unique pairwise interatomic distances.\n    \"\"\"\n    distances = []\n    # Iterate over all unique pairs of atoms (i  j).\n    for i in range(structure.natoms):\n        for j in range(i + 1, structure.natoms):\n            d = min_image_dist(structure.frac_coords[i],\n                               structure.frac_coords[j],\n                               structure.cell_dims)\n            distances.append(d)\n    # Sort the distances to ensure invariance under atom permutation.\n    return np.array(sorted(distances))\n\ndef calculate_fitness(structure, alpha, lambda_val, eps_map):\n    \"\"\"\n    Calculates the fitness of a structure based on its energy and volume.\n    Energy is a sum of pairwise exponential potentials.\n    \"\"\"\n    energy = 0.0\n    # Iterate over all unique pairs of atoms to calculate total potential energy.\n    for i in range(structure.natoms):\n        for j in range(i + 1, structure.natoms):\n            d = min_image_dist(structure.frac_coords[i],\n                               structure.frac_coords[j],\n                               structure.cell_dims)\n            # Create a canonical key for the species pair (e.g., ('A', 'B')).\n            # This handles both ('A', 'B') and ('B', 'A') with one map entry.\n            s_pair = tuple(sorted((structure.species[i], structure.species[j])))\n            eps = eps_map[s_pair]\n            energy += eps * np.exp(-alpha * d)\n    \n    # Fitness is defined as the total energy plus a volume-dependent term.\n    fitness = energy + lambda_val * structure.volume\n    return fitness\n\ndef get_species_map():\n    \"\"\"Returns the dictionary of species-pair interaction coefficients.\"\"\"\n    return {\n        ('X', 'X'): -1.0,\n        ('A', 'A'): -1.0,\n        ('B', 'B'): -1.0,\n        ('A', 'B'): -1.5,\n    }\n\ndef are_duplicates(struct1, struct2, alpha, lambda_val, eps_map, tau_F, tau_g):\n    \"\"\"\n    Determines if two structures are duplicates based on fitness and fingerprint\n    comparison with given tolerances.\n    \"\"\"\n    # Calculate fitness for both structures.\n    f1 = calculate_fitness(struct1, alpha, lambda_val, eps_map)\n    f2 = calculate_fitness(struct2, alpha, lambda_val, eps_map)\n\n    # Calculate fingerprints for both structures.\n    g1 = calculate_fingerprint(struct1)\n    g2 = calculate_fingerprint(struct2)\n    \n    # Check the fitness condition.\n    fitness_match = abs(f1 - f2) = tau_F\n    \n    # Check the fingerprint condition. Fingerprints must have the same length.\n    if g1.shape != g2.shape:\n        geom_match = False\n    else:\n        # The norm of an empty vector difference is 0. Handle this edge case\n        # for single-atom systems, though not present in test cases.\n        if g1.size == 0:\n            geom_match = True\n        else:\n            geom_match = np.linalg.norm(g1 - g2) = tau_g\n\n    return fitness_match or geom_match\n\ndef solve():\n    \"\"\"Main function to define, run, and report test cases.\"\"\"\n    # Define constants from the problem statement\n    ALPHA = 1.0\n    LAMBDA = 0.01\n    TAU_F = 1e-8\n    TAU_G = 2e-2\n    EPS_MAP = get_species_map()\n\n    # --- Test Case 1: Translation invariance ---\n    cell_A = [3.0, 3.0, 3.0]\n    pos_A = [[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]]\n    species_A = ['X', 'X']\n    struct_A = Structure(cell_A, pos_A, species_A)\n\n    translation = np.array([0.37, 0.41, 0.13])\n    pos_B = (np.array(pos_A) + translation) % 1.0\n    struct_B = Structure(cell_A, pos_B.tolist(), species_A)\n    \n    case1_result = are_duplicates(struct_A, struct_B, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n\n    # --- Test Case 2: Scaling ---\n    cell_C = [6.0, 6.0, 6.0]\n    struct_C = Structure(cell_C, pos_A, species_A)\n    \n    case2_result = are_duplicates(struct_A, struct_C, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n\n    # --- Test Case 3: Small numerical noise ---\n    perturb_1 = np.array([0.001, -0.001, 0.0005])\n    perturb_2 = np.array([-0.001, 0.001, -0.0005])\n    pos_D = np.array([pos_B[0] + perturb_1, pos_B[1] + perturb_2]) % 1.0\n    struct_D = Structure(cell_A, pos_D.tolist(), species_A)\n\n    case3_result = are_duplicates(struct_B, struct_D, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n\n    # --- Test Case 4: Multi-species, permutation, and translation ---\n    cell_E = [5.0, 5.0, 5.0]\n    pos_E = [[0.0, 0.0, 0.0], [0.0, 0.5, 0.5], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0]]\n    species_E = ['A', 'A', 'B', 'B']\n    struct_E = Structure(cell_E, pos_E, species_E)\n\n    translation_F = np.array([0.25, 0.25, 0.25])\n    pos_F_translated = (np.array(pos_E) + translation_F) % 1.0\n    # Arbitrarily reorder positions and species\n    permuted_indices = [3, 0, 2, 1] # e.g., B, A, B, A\n    pos_F = [pos_F_translated[i] for i in permuted_indices]\n    species_F = [species_E[i] for i in permuted_indices]\n    struct_F = Structure(cell_E, pos_F, species_F)\n    \n    case4_result = are_duplicates(struct_E, struct_F, ALPHA, LAMBDA, EPS_MAP, TAU_F, TAU_G)\n    \n    # Collect results and format output\n    results = [case1_result, case2_result, case3_result, case4_result]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3450460"}, {"introduction": "物理上现实的晶体结构必须遵守严格的物理定律，例如离子化合物必须满足电中性原理。本实践将演示如何在进化算法中形式化地表达这类硬性约束，并探讨两种主流处理策略：通过惩罚函数在适应度评估中惩罚违规的候选者，以及通过修复算子直接修正候选者使其满足约束。[@problem_id:3450424]", "problem": "您正在为一种用于晶体结构预测（CSP）的演化算法（EA）设计一个组件，该组件用于生成候选的离子组分。这些组分由非负整数化学计量比表示。您的任务是从静电学原理出发，推导出一个有原则的电中性约束，为违反该约束的行为定义一个数学上合理的惩罚，并实现一个确定性的修复策略，在可能的情况下通过最小化编辑化学计量比来强制实现电中性。\n\n从基本原理开始推导该约束。从以下事实开始：在静电平衡中，周期性体相晶胞内包含的总自由电荷必须为零，且总电荷是所有离子电荷的总和。考虑一个候选组分，由化学计量数向量 $\\mathbf{n} = (n_{1}, n_{2}, \\dots, n_{k})$ 和相关的离子电荷数向量 $\\mathbf{z} = (z_{1}, z_{2}, \\dots, z_{k})$ 指定，其中每个 $z_{i}$ 是以基本电荷单位计量的整数氧化态，每个 $n_{i}$ 是一个非负整数。表达净电荷 $Q(\\mathbf{n};\\mathbf{z})$，并推导出在晶胞中强制实现电中性的精确线性约束。然后，提出：\n\n- 一个非负惩罚函数 $P(\\mathbf{n};\\mathbf{z})$，该函数当且仅当电中性成立时为零，并随电荷违背量值的大小单调增加。该惩罚必须是无量纲的，并应包含一个通过总原子数进行的显式归一化，以避免偏向于更大的超胞。您可以引入一个小的正常数 $\\varepsilon$ 以防止总原子数为零时出现除以零的情况。\n- 一个修复算子，它将给定的 $\\mathbf{n}$ 映射到一个新的整数向量 $\\mathbf{n}^{\\prime} \\ge \\mathbf{0}$，使得只要存在这样的非空修复，中性约束就得到满足。该算子必须被明确定义为一个离散优化问题的解，该问题在满足电中性和非负性约束的条件下，最小化逐元素的 $\\ell_{1}$ 距离 $\\|\\mathbf{n}^{\\prime} - \\mathbf{n}\\|_{1}$。如果存在多个极小值点，则通过选择总原子数 $\\sum_{i} n_{i}^{\\prime}$ 最小的那个来处理并列情况；如果仍然并列，则选择升序排列下字典序最小的 $\\mathbf{n}^{\\prime}$。如果在这些约束下不存在非空的修复，则该算子必须返回一个明确表示不可能的指示。\n\n您的程序必须实现推导出的惩罚函数和修复算子，并在以下测试套件上对它们进行评估。对于每个测试用例，输入由作为整数列表的 $\\mathbf{z}$ 和 $\\mathbf{n}$ 组成。此问题不涉及物理单位。\n\n测试套件：\n- A例（已中性）：$\\mathbf{z} = [\\, +1, -1 \\,]$, $\\mathbf{n} = [\\, 4, 4 \\,]$。\n- B例（二元非化学计量）：$\\mathbf{z} = [\\, +2, -2 \\,]$, $\\mathbf{n} = [\\, 5, 4 \\,]$。\n- C例（二元体系中的类三元价态模式）：$\\mathbf{z} = [\\, +3, -2 \\,]$, $\\mathbf{n} = [\\, 2, 2 \\,]$。\n- D例（所有电荷同号，非平凡）：$\\mathbf{z} = [\\, +1, +2 \\,]$, $\\mathbf{n} = [\\, 1, 1 \\,]$。\n- E例（最小修复需要多次编辑）：$\\mathbf{z} = [\\, +2, -3 \\,]$, $\\mathbf{n} = [\\, 2, 1 \\,]$。\n\n需要实现的定义：\n- 净电荷：$Q(\\mathbf{n};\\mathbf{z}) = \\sum_{i=1}^{k} z_{i} n_{i}$。\n- 电中性约束：$\\sum_{i=1}^{k} z_{i} n_{i} = 0$。\n- 惩罚（无量纲）：$P(\\mathbf{n};\\mathbf{z}) = \\dfrac{Q(\\mathbf{n};\\mathbf{z})^{2}}{\\sum_{i=1}^{k} n_{i} + \\varepsilon}$，固定 $\\varepsilon = 10^{-9}$。\n- 修复算子：找到 $\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}$，它是以下问题的解\n  $$\\min_{\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}} \\left\\| \\mathbf{n}^{\\prime} - \\mathbf{n} \\right\\|_{1} \\quad \\text{s.t.} \\quad \\sum_{i=1}^{k} z_{i} n_{i}^{\\prime} = 0 \\quad \\text{and} \\quad \\sum_{i=1}^{k} n_{i}^{\\prime}  0,$$\n  使用上述的并列处理规则。如果不存在可行的非空 $\\mathbf{n}^{\\prime}$，则返回空列表 $[\\,]$ 作为该情况的修复结果。\n\n您的程序应硬编码上述测试套件，并为每个案例计算：\n- 一个布尔标志，指示原始的 $\\mathbf{n}$ 是否是中性的，\n- 惩罚值 $P(\\mathbf{n};\\mathbf{z})$，四舍五入到六位小数，\n- 修复后的化学计量列表 $\\mathbf{n}^{\\prime}$（如果不可能，则为空列表 $[\\,]$），\n\n并输出一行，其中包含按 A 到 E 顺序排列的每个案例的结果列表，每个案例的结果是列表 $[\\,\\text{neutral\\_flag}, P, \\mathbf{n}^{\\prime}\\,]$。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[\\,\\text{result1},\\text{result2},\\text{result3}\\,]$）。", "solution": "为晶体结构预测生成有效的离子组分是计算材料科学中演化算法的核心组成部分。所提供的任务是形式化电中性约束，为其违规设计一个惩罚函数，并实现一个确定性的修复算子。该问题是有效的，在静电学中有科学依据，并且在算法上是适定的。\n\n### 1. 电中性约束的推导\n\n推导始于应用于周期性固体的静电学基本原理。在稳定的体相晶体材料中，不存在宏观内部电场。根据高斯定律的微分形式 $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$，零电场（$\\mathbf{E}=0$）意味着处处为零的净电荷密度（$\\rho=0$）。\n\n将电荷密度在单个晶胞（代表晶体的重复结构单元）的体积上积分，得到该晶胞内包含的总电荷 $Q_{\\text{cell}}$。为了使晶体在宏观上呈电中性，晶胞本身必须是电中性的。\n\n假设晶体由 $k$ 种不同类型的离子组成。\n- 令 $\\mathbf{n} = (n_{1}, n_{2}, \\dots, n_{k})$ 为化学计量数向量，其中 $n_{i} \\in \\mathbb{Z}_{\\ge 0}$ 是晶胞中第 $i$ 类离子的数量。\n- 令 $\\mathbf{z} = (z_{1}, z_{2}, \\dots, z_{k})$ 为相应的离子电荷数（或氧化态）向量，其中 $z_{i} \\in \\mathbb{Z}$ 是第 $i$ 类离子以基本电荷 $e$ 为单位的电荷。\n\n第 $i$ 类离子贡献的总电荷为 $n_i z_i e$。晶胞中的总电荷是所有离子类型的总和：\n$$Q_{\\text{cell}} = \\sum_{i=1}^{k} n_i z_i e$$\n电中性的条件是 $Q_{\\text{cell}} = 0$。由于基本电荷 $e$ 是一个非零常数，这等价于电荷数之和为零。我们将组分的净电荷数定义为：\n$$Q(\\mathbf{n};\\mathbf{z}) = \\sum_{i=1}^{k} n_{i} z_{i}$$\n因此，强制实现电中性的精确线性约束是一个线性丢番图方程：\n$$\\sum_{i=1}^{k} n_{i} z_{i} = 0$$\n\n### 2. 惩罚函数\n\n在演化算法中，惩罚函数用于惩罚违反硬约束的候选解。一个合适的惩罚函数 $P(\\mathbf{n};\\mathbf{z})$ 应满足以下标准：\n- **非负性**：$P \\ge 0$。\n- **当且仅当中性时为零**：$P = 0 \\iff Q(\\mathbf{n};\\mathbf{z}) = 0$。\n- **单调性**：$P$ 应随电荷违背量值 $|Q|$ 的增加而增加。\n\n提议的函数是：\n$$P(\\mathbf{n};\\mathbf{z}) = \\frac{Q(\\mathbf{n};\\mathbf{z})^{2}}{\\sum_{i=1}^{k} n_{i} + \\varepsilon}$$\n该函数满足这些标准：\n- 将净电荷 $Q$ 平方确保了非负性，并保证了惩罚仅在中性满足时为零。二次形式还提供了平滑的梯度，这对于许多优化方法都是有益的。\n- 分母 $\\sum n_i$ 代表组分中的总原子数。这种归一化使惩罚无量纲化并考虑了系统大小，从而对具有相同绝对电荷不平衡的系统，相比大型系统，更重地惩罚小型系统。\n- 小的正标量 $\\varepsilon = 10^{-9}$ 是一个标准的正则化项，用于防止在空组分（其中 $\\sum n_i = 0$）情况下出现除以零的错误。\n\n### 3. 修复算子\n\n修复算子是一个确定性过程，用于将电荷不平衡的组分 $\\mathbf{n}$ 映射到中性的组分 $\\mathbf{n}^{\\prime}$。修复必须是最小的，以尽可能多地保留原始候选解的信息。这被表述为一个离散优化问题。\n\n**目标**：找到一个新的化学计量向量 $\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}$，它最小化到原始向量 $\\mathbf{n}$ 的 $\\ell_1$ 距离（曼哈顿距离）。$\\ell_1$ 距离对应于单个原子增加或移除的总数。\n$$\\min_{\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}} \\left\\| \\mathbf{n}^{\\prime} - \\mathbf{n} \\right\\|_{1} = \\min_{\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}} \\sum_{i=1}^{k} |n_{i}^{\\prime} - n_{i}|$$\n\n**约束条件**：\n1.  **电中性**：$\\sum_{i=1}^{k} z_{i} n_{i}^{\\prime} = 0$。\n2.  **非负性**：对于所有 $i=1, \\dots, k$，有 $n_{i}^{\\prime} \\ge 0$。\n3.  **非空性**：$\\sum_{i=1}^{k} n_{i}^{\\prime}  0$。这可以防止出现平凡解 $\\mathbf{n}^{\\prime} = \\mathbf{0}$（该解是中性的，但作为晶体在物理上是无趣的）。\n\n**不可能性**：只有当可用的离子电荷集合同时包含正值和负值时，才能形成非空的电中性组分。如果所有的 $z_i$ 都具有相同的符号（或为零），那么在 $n_i' \\ge 0$ 的条件下满足 $\\sum z_i n_i' = 0$ 的唯一方法是，对于所有 $z_i \\ne 0$ 的 $i$，都有 $n_i' = 0$。如果所有 $z_i$ 都非零且同号，这将导致一个空组分；或者导致一个只含有零电荷物种的组分。算子必须能够检测到这种不可能性并发出信号，此时返回一个空列表 `[]`。\n\n**求解算法**：这个优化问题可以使用在化学计量状态空间上的广度优先搜索（BFS）来解决。从起始状态 $\\mathbf{n}$ 的距离是编辑的次数（即 $\\ell_1$ 距离）。\n1.  搜索从距离 $d=0$ 的初始化学计量 $\\mathbf{n}$ 开始。\n2.  搜索分层进行，其中第 $d$ 层包含所有从 $\\mathbf{n}$ 经过恰好 $d$ 次单原子编辑（增加或减少）可达的化学计量。\n3.  通过从前一层取出一个状态并应用一次编辑来生成一个状态（化学计量向量）。维护一个 `visited` 集合以避免冗余计算。\n4.  找到一个或多个满足所有约束的有效化学计量的第一个层级 $d_{\\text{min}}$ 决定了最小的 $\\ell_1$ 距离。\n5.  收集所有在距离 $d_{\\text{min}}$ 处的有效解。\n6.  顺序地对这组解应用并列处理规则以选择一个唯一的修复：\n    a.  选择总原子数 $\\sum n_{i}^{\\prime}$ 最小的解。\n    b.  从剩余的候选中，选择字典序最小的向量 $\\mathbf{n}^{\\prime}$。\n\n这种逐层的广度优先搜索保证能找到具有最小 $\\ell_1$ 距离的解，而严格的并列处理规则确保了结果的唯一性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for crystal composition validation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Already neutral\n        {'z': [1, -1], 'n': [4, 4]},\n        # Case B: Binary off-stoichiometry\n        {'z': [2, -2], 'n': [5, 4]},\n        # Case C: Ternary-like valence pattern in binary\n        {'z': [3, -2], 'n': [2, 2]},\n        # Case D: All charges same sign, nontrivial\n        {'z': [1, 2], 'n': [1, 1]},\n        # Case E: Minimal repair requires more than one edit\n        {'z': [2, -3], 'n': [2, 1]},\n    ]\n    epsilon = 1e-9\n\n    def repair_stoichiometry(z_vec, n_vec):\n        \"\"\"\n        Finds the minimally edited, charge-neutral stoichiometry.\n\n        This function implements a Breadth-First Search (BFS) to find a new\n        stoichiometry vector n' that minimizes the L1 distance to n, subject\n        to charge neutrality and non-negativity.\n        \"\"\"\n        # If already neutral and non-empty, no repair needed.\n        initial_charge = sum(zi * ni for zi, ni in zip(z_vec, n_vec))\n        if initial_charge == 0 and sum(n_vec) > 0:\n            return list(n_vec)\n\n        # Check for impossibility: need both positive and negative valences.\n        has_pos = any(z > 0 for z in z_vec if z != 0)\n        has_neg = any(z  0 for z in z_vec if z != 0)\n        if not (has_pos and has_neg):\n            return []\n\n        # BFS setup: level-by-level search\n        queue = [list(n_vec)]\n        visited = {tuple(n_vec)}\n\n        # Limit search depth to prevent extremely long runs on pathological cases.\n        max_edits = 20  \n        for _ in range(max_edits):\n            next_queue = []\n            solutions = []\n\n            for current_n in queue:\n                # Generate neighbors by one edit (increment/decrement)\n                for i in range(len(z_vec)):\n                    # Increment atom count\n                    next_n_inc = current_n[:]\n                    next_n_inc[i] += 1\n                    if tuple(next_n_inc) not in visited:\n                        visited.add(tuple(next_n_inc))\n                        charge = sum(z * n for z, n in zip(z_vec, next_n_inc))\n                        if charge == 0:  # sum(next_n_inc) is guaranteed > 0\n                            solutions.append(next_n_inc)\n                        next_queue.append(next_n_inc)\n\n                    # Decrement atom count\n                    if current_n[i] > 0:\n                        next_n_dec = current_n[:]\n                        next_n_dec[i] -= 1\n                        if tuple(next_n_dec) not in visited:\n                            visited.add(tuple(next_n_dec))\n                            charge = sum(z * n for z, n in zip(z_vec, next_n_dec))\n                            if charge == 0 and sum(next_n_dec) > 0:\n                                solutions.append(next_n_dec)\n                            next_queue.append(next_n_dec)\n            \n            if solutions:\n                # Apply tie-breaking rules\n                # 1. Minimum total atom count\n                min_atom_count = min(sum(s) for s in solutions)\n                candidates = [s for s in solutions if sum(s) == min_atom_count]\n                \n                # 2. Lexicographically smallest\n                candidates.sort()\n                return candidates[0]\n            \n            queue = next_queue\n            if not queue:\n                break # Search space exhausted\n        \n        return [] # No solution found within search limit\n\n    results = []\n    for case in test_cases:\n        z, n = case['z'], case['n']\n\n        # Calculate net charge and neutrality flag\n        net_charge = sum(zi * ni for zi, ni in zip(z, n))\n        is_neutral = (net_charge == 0)\n\n        # Calculate penalty\n        total_atoms = sum(n)\n        penalty = net_charge**2 / (total_atoms + epsilon) if total_atoms > 0 else float(net_charge**2 / epsilon)\n\n        # Perform repair\n        repaired_n = repair_stoichiometry(z, n)\n        \n        # Format list string without spaces for consistency\n        repaired_n_str = f\"[{','.join(map(str, repaired_n))}]\" if repaired_n else '[]'\n\n        # Format the result string for the current case\n        result_str = f\"[{is_neutral}, {penalty:.6f}, {repaired_n_str}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3450424"}, {"introduction": "进化算法的搜索效率和成功率在很大程度上取决于适应度函数的设计。一个好的适应度函数不仅应引导算法找到低能量结构，还应包含更多的物理化学知识以加速收敛到现实的结构。本实践将超越简单的能量最小化，展示如何通过引入基于元素电负性的惩罚项，来引导算法优先生成化学环境更合理的合金结构。[@problem_id:3450416]", "problem": "您正在为应用于计算材料科学中晶体结构预测的演化算法 (EA) 设计一个适应度函数。其基本原则是，低能量结构应被优先选择，而具有大电负性差异的局部化学环境应受到惩罚，以促进合金中符合物理现实的有序性。请使用以下基本依据，推导出一个数学上一致的、带罚分的候选结构适应度能量，并实现它：\n\n- 需要最小化的基准量是形成能 $E$，单位为电子伏特 (eV)。\n- 泡林电负性 $\\chi$ 是一个经过充分检验的、描述原子吸引电子趋势的描述符。\n- 局部失配应在结构中所有唯一的第一近邻对 $\\langle i,j\\rangle$ 上进行累加。\n- 对一个原子对的罚分应随电负性差异的绝对值增加而增加，并与一个具有能量单位的可调系数 $\\alpha$ 成正比，以确保量纲一致性。\n- 只包括唯一的第一近邻对；不要重复计数或包括自配对。\n\n根据这些原则，推导带罚分的适应度能量的明确表达式，并实现一个程序，为下面的每个测试用例计算该值。所有最终能量均以 eV 表示，并四舍五入到六位小数。\n\n原子种类由符号标记，其泡林电负性如下：\n- 种类 $A$：$\\chi_A = 1.60$\n- 种类 $B$：$\\chi_B = 3.00$\n- 种类 $C$：$\\chi_C = 2.50$\n\n每个测试用例提供：\n- 基准能量 $E$，单位为 eV。\n- 系数 $\\alpha$，单位为 eV。\n- 分配给晶格格点的原子种类列表，索引从 $0$ 开始。\n- 由格点索引给出的唯一无向第一近邻对 $(i,j)$ 的邻接表，其中 $i \\neq j$，且每个无序对仅出现一次。\n\n测试套件：\n- 用例 $1$ (理想情况，方形基序上的二元有序结构):\n  - $E = -0.25$\n  - $\\alpha = 0.05$\n  - 格点 $\\{0,1,2,3\\}$ 上的种类: $[A,B,B,A]$\n  - 第一近邻对: $\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- 用例 $2$ (边界情况，无失配的均匀组分):\n  - $E = -0.10$\n  - $\\alpha = 0.20$\n  - 格点 $\\{0,1,2,3\\}$ 上的种类: $[A,A,A,A]$\n  - 第一近邻对: $\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- 用例 $3$ (边界情况，不施加罚分):\n  - $E = -0.25$\n  - $\\alpha = 0.00$\n  - 格点 $\\{0,1,2,3\\}$ 上的种类: $[A,B,B,A]$\n  - 第一近邻对: $\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- 用例 $4$ (具有不同失配度的三元链):\n  - $E = 0.15$\n  - $\\alpha = 0.10$\n  - 格点 $\\{0,1,2,3\\}$ 上的种类: $[A,C,B,A]$\n  - 第一近邻对: $\\{(0,1),(1,2),(2,3)\\}$\n- 用例 $5$ (边缘情况，近邻列表为空):\n  - $E = -1.00$\n  - $\\alpha = 0.50$\n  - 格点 $\\{0,1\\}$ 上的种类: $[B,C]$\n  - 第一近邻对: $\\{\\}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 是用例 $k$ 的带罚分的适应度能量，单位为 eV，四舍五入到六位小数。", "solution": "用户提供了一个问题，要求推导并实现一个用于晶体结构预测的演化算法的适应度函数。该过程始于对问题陈述的强制性验证。\n\n### 步骤 1：提取已知条件\n\n问题提供了以下定义、常数和数据：\n\n*   **目标**：推导并实现一个带罚分的适应度能量函数。\n*   **基准量**：形成能 $E$，单位为电子伏特 (eV)。\n*   **罚分原则**：具有大电负性差异的局部化学环境应受到惩罚，该差异通过泡林电负性 $\\chi$ 来量化。\n*   **罚分结构**：\n    *   罚分是在所有唯一的第一近邻对 $\\langle i,j\\rangle$ 上累加的。\n    *   单个原子对的罚分与一个可调系数 $\\alpha$（单位为 eV）成正比。\n    *   单个原子对的罚分随电负性差异的绝对值增加而增加。\n    *   只考虑唯一的、无向的第一近邻对 $(i,j)$，其中 $i \\neq j$。\n*   **泡林电负性 ($\\chi$)**：\n    *   种类 $A$：$\\chi_A = 1.60$\n    *   种类 $B$：$\\chi_B = 3.00$\n    *   种类 $C$：$\\chi_C = 2.50$\n*   **测试用例**：\n    *   **用例 1**：$E = -0.25$ eV, $\\alpha = 0.05$ eV, 种类 = $[A,B,B,A]$ 于格点 $\\{0,1,2,3\\}$, 近邻 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n    *   **用例 2**：$E = -0.10$ eV, $\\alpha = 0.20$ eV, 种类 = $[A,A,A,A]$ 于格点 $\\{0,1,2,3\\}$, 近邻 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n    *   **用例 3**：$E = -0.25$ eV, $\\alpha = 0.00$ eV, 种类 = $[A,B,B,A]$ 于格点 $\\{0,1,2,3\\}$, 近邻 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n    *   **用例 4**：$E = 0.15$ eV, $\\alpha = 0.10$ eV, 种类 = $[A,C,B,A]$ 于格点 $\\{0,1,2,3\\}$, 近邻 = $\\{(0,1),(1,2),(2,3)\\}$。\n    *   **用例 5**：$E = -1.00$ eV, $\\alpha = 0.50$ eV, 种类 = $[B,C]$ 于格点 $\\{0,1\\}$, 近邻 = $\\{\\}$。\n*   **输出格式**：一个单行的逗号分隔值列表，`[x_1,x_2,x_3,x_4,x_5]`，每个结果四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据指定的验证标准对问题进行评估。\n\n*   **科学依据**：该问题在计算材料科学中有充分的依据。最小化形成能是晶体结构预测的主要目标。使用电负性来惩罚不利的局部成键环境是合金理论和材料建模中一个标准且具有物理意义的启发式方法。\n*   **适定性**：该问题是适定的。所提供的原则足以推导出适应度函数的唯一数学表达式。在物理模型的背景下，且没有其他说明时，“随……增加”这一术语意味着最简单的线性关系，即正比关系。这种解释导出了一个单一、明确的公式。每个测试用例都提供了所有必要的数据。\n*   **客观性**：语言精确、量化，没有主观或模糊的术语。\n*   **完整性和一致性**：问题是自包含且内部一致的。没有遗漏任何必要信息，也没有相互矛盾的约束。\n*   **现实性和可行性**：提供的能量和电负性数值是现实的。结构基序是局部原子排列的简单但有效的表示。\n\n**结论**：该问题是**有效**的。它科学合理、适定、客观且完整。\n\n### 步骤 3：推导与求解\n\n根据所提供的原则，推导带罚分的适应度能量 $E_{penalized}$ 的数学表达式。\n\n总适应度能量是基准形成能 $E$ 和总罚分项 $P_{total}$ 的和。\n$$E_{penalized} = E + P_{total}$$\n\n总罚分是近邻集合 $\\mathcal{N}$ 中每个唯一的第一近邻对 $\\langle i,j \\rangle$ 的罚分之和。\n$$P_{total} = \\sum_{\\langle i,j \\rangle \\in \\mathcal{N}} P_{ij}$$\n\n单个原子对的罚分 $P_{ij}$ 与系数 $\\alpha$ 以及位于格点 $i$ 和 $j$ 的物种 $S_i$ 和 $S_j$ 之间的电负性差异的绝对值成正比。对此最直接的数学表示是：\n$$P_{ij} = \\alpha \\cdot |\\chi(S_i) - \\chi(S_j)|$$\n其中 $\\chi(S_k)$ 是位于格点 $k$ 的物种的电负性。\n\n将这些部分组合起来，得到带罚分的适应度能量的最终表达式：\n$$E_{penalized} = E + \\alpha \\sum_{\\langle i,j \\rangle \\in \\mathcal{N}} |\\chi(S_i) - \\chi(S_j)|$$\n\n现在将此公式应用于每个测试用例。电负性值为 $\\chi_A = 1.60$，$\\chi_B = 3.00$ 和 $\\chi_C = 2.50$。\n\n**用例 1**：\n$E = -0.25$, $\\alpha = 0.05$, 种类 = $[A,B,B,A]$, 近邻 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n原子对为 $(A,B)$, $(A,B)$, $(B,A)$, $(B,A)$。\n一个 $A-B$ 对的电负性差异为 $|\\chi_A - \\chi_B| = |1.60 - 3.00| = 1.40$。\n差异之和为 $\\sum |\\Delta\\chi| = 1.40 + 1.40 + 1.40 + 1.40 = 4 \\times 1.40 = 5.60$。\n$E_{penalized} = -0.25 + 0.05 \\times 5.60 = -0.25 + 0.28 = 0.03$。\n\n**用例 2**：\n$E = -0.10$, $\\alpha = 0.20$, 种类 = $[A,A,A,A]$, 近邻 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n所有原子对均为 $(A,A)$。电负性差异为 $|\\chi_A - \\chi_A| = |1.60 - 1.60| = 0.00$。\n差异之和为 $\\sum |\\Delta\\chi| = 0$。\n$E_{penalized} = -0.10 + 0.20 \\times 0.00 = -0.10 + 0.00 = -0.10$。\n\n**用例 3**：\n$E = -0.25$, $\\alpha = 0.00$, 种类 = $[A,B,B,A]$, 近邻 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n种类和近邻与用例 1 相同，所以 $\\sum |\\Delta\\chi| = 5.60$。\n罚分系数为 $\\alpha = 0.00$。\n$E_{penalized} = -0.25 + 0.00 \\times 5.60 = -0.25 + 0.00 = -0.25$。\n\n**用例 4**：\n$E = 0.15$, $\\alpha = 0.10$, 种类 = $[A,C,B,A]$, 近邻 = $\\{(0,1),(1,2),(2,3)\\}$。\n原子对为 $(A,C)$, $(C,B)$, $(B,A)$。\n- 对 $(A,C)$: $|\\chi_A - \\chi_C| = |1.60 - 2.50| = 0.90$。\n- 对 $(C,B)$: $|\\chi_C - \\chi_B| = |2.50 - 3.00| = 0.50$。\n- 对 $(B,A)$: $|\\chi_B - \\chi_A| = |3.00 - 1.60| = 1.40$。\n差异之和为 $\\sum |\\Delta\\chi| = 0.90 + 0.50 + 1.40 = 2.80$。\n$E_{penalized} = 0.15 + 0.10 \\times 2.80 = 0.15 + 0.28 = 0.43$。\n\n**用例 5**：\n$E = -1.00$, $\\alpha = 0.50$, 种类 = $[B,C]$, 近邻 = $\\{\\}$。\n近邻集合 $\\mathcal{N}$ 为空。空集上的和为 $0$。\n$\\sum |\\Delta\\chi| = 0$。\n$E_{penalized} = -1.00 + 0.50 \\times 0.00 = -1.00 + 0.00 = -1.00$。\n\n最终结果四舍五入到六位小数为：\n$0.030000$, $-0.100000$, $-0.250000$, $0.430000$, $-1.000000$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a penalized fitness energy for crystal structures\n    based on formation energy and electronegativity mismatch of nearest neighbors.\n    \"\"\"\n\n    # Define the Pauling electronegativity values for each atomic species.\n    # These are dimensionless quantities.\n    CHI_VALS = {\n        'A': 1.60,\n        'B': 3.00,\n        'C': 2.50\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E, alpha, species_list, neighbor_list)\n    # E: baseline formation energy in eV\n    # alpha: tunable penalty coefficient in eV\n    # species_list: list of species symbols at indexed lattice sites\n    # neighbor_list: list of unique, undirected first-neighbor pairs (i, j)\n    test_cases = [\n        # Case 1: happy path, binary ordering on a square motif\n        (-0.25, 0.05, ['A', 'B', 'B', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 2: boundary, uniform composition with no mismatch\n        (-0.10, 0.20, ['A', 'A', 'A', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 3: boundary, no penalty applied (alpha = 0)\n        (-0.25, 0.00, ['A', 'B', 'B', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 4: ternary chain with varied mismatches\n        (0.15, 0.10, ['A', 'C', 'B', 'A'], [(0, 1), (1, 2), (2, 3)]),\n        # Case 5: edge case, empty neighbor list\n        (-1.00, 0.50, ['B', 'C'], [])\n    ]\n\n    results = []\n    for E, alpha, species, neighbors in test_cases:\n        # The penalty term is the sum of electronegativity differences\n        # over all first-neighbor pairs.\n        delta_chi_sum = 0.0\n        for i, j in neighbors:\n            # Retrieve the species at each site of the pair.\n            species_i = species[i]\n            species_j = species[j]\n\n            # Retrieve the corresponding electronegativity values.\n            chi_i = CHI_VALS[species_i]\n            chi_j = CHI_VALS[species_j]\n\n            # The penalty increases with the magnitude of the difference.\n            delta_chi_sum += abs(chi_i - chi_j)\n\n        # The total penalty is the sum of differences scaled by the coefficient alpha.\n        # This ensures dimensional consistency as alpha is in eV.\n        total_penalty = alpha * delta_chi_sum\n\n        # The final penalized energy is the baseline energy plus the total penalty.\n        penalized_energy = E + total_penalty\n\n        # Format the result to six decimal places as required.\n        results.append(f\"{penalized_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3450416"}]}