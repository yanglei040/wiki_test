{"hands_on_practices": [{"introduction": "高通量材料筛选的第一步是界定广阔的化学搜索空间。本练习将复杂的晶体学对称性问题简化为一个具体的组合计数问题[@problem_id:3456708]，通过“隔板法”来估算潜在的结构数量。通过这项实践，你将对催生自动化筛选技术的组合爆炸问题获得直观的理解，并为材料发现的巨大规模建立起基础认知。", "problem": "您将获得用于计算材料科学中高通量材料筛选的原型晶体结构和允许的元素替换集。目标是在自动化工作流程的假设下，通过算法估计在空间群对称性下的不同修饰结构的数量，其中对称等效位置在同一个Wyckoff轨道内被视为不可区分。推导过程必须从群作用的数学概念和轨道的定义开始，而不使用现成的枚举公式。\n\n使用的基本原理：\n- 空间群通过排列对称等效的位点，作用于Wyckoff位置集合。\n- 元素的位点分配可以看作是在此作用下的一个标记。\n- 在对称性下的不同修饰结构对应于该群作用下标记的轨道。\n\n场景：\n- 考虑原型集 $P=\\{\\text{钙钛矿},\\text{尖晶石}\\}$。\n- 对于空间群为 $\\mathrm{Pm}\\bar{3}\\mathrm{m}$ 的 $ABO_3$ 型钙钛矿，假设其 $A$、$B$ 和 $O$ 亚晶格的Wyckoff轨道多重性分别为 $n_A=1$、$n_B=1$、$n_O=3$。\n- 对于空间群为 $\\mathrm{Fd}\\bar{3}\\mathrm{m}$ 的 $AB_2O_4$ 型尖晶石，假设其 $A$、$B$ 和 $O$ 亚晶格的Wyckoff轨道多重性分别为 $n_A=8$、$n_B=16$、$n_O=32$。\n- 对于每个亚晶格 $X\\in\\{A,B,O\\}$，您将获得一个允许的元素替换集 $E_X$，其基数为 $m_X=|E_X|$，这意味着有 $m_X$ 种不同的元素类型可以占据亚晶格 $X$ 上的位点。\n\n假设：\n- 在每个Wyckoff轨道内，空间群对称性使得各位置不可区分，因此仅因轨道内排列不同而产生的标记被视为等价。\n- 不同亚晶格之间的替换被视为独立处理，除了轨道多重性 $n_X$ 外，没有全局的成分约束。\n\n任务：\n- 从提供的基本原理出发，构建一个有原则的算法，该算法对于给定的原型和 $m_A$、$m_B$、$m_O$，通过计算每个轨道上的不等价标记并对亚晶格进行汇总，来估计在空间群对称性下的不同修饰结构集合的基数。\n- 将此算法实现为一个完整的、可运行的程序，将其应用于下面的测试套件，并以指定格式输出结果。\n\n测试套件：\n- 案例1：原型 $=$ 钙钛矿, $m_A=2$, $m_B=3$, $m_O=2$。\n- 案例2：原型 $=$ 钙钛矿, $m_A=1$, $m_B=1$, $m_O=1$。\n- 案例3：原型 $=$ 钙钛矿, $m_A=5$, $m_B=4$, $m_O=3$。\n- 案例4：原型 $=$ 尖晶石, $m_A=2$, $m_B=2$, $m_O=1$。\n- 案例5：原型 $=$ 尖晶石, $m_A=2$, $m_B=3$, $m_O=2$。\n\n答案规格：\n- 对于每个案例，答案是一个整数，给出在空间群对称性下估计的不同修饰结构的数量。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots]$。", "solution": "该问题陈述被评估为有效。它在科学上基于计算材料科学的原理，特别是与晶体学对称性和高通量筛选相关的原理。该问题是适定的，所有必要的参数和假设都已明确定义，从而导向一个唯一且有意义的解。此问题客观且无歧义。\n\n任务是推导并实现一个算法，用于在给定原型结构、其Wyckoff轨道多重性以及每个亚晶格允许的元素替换集的情况下，计算不同修饰晶体结构的数量。推导必须根植于基本原理。\n\n不同修饰结构的总数 $N_{total}$ 是每个独立亚晶格的可能唯一修饰数量的乘积。这是基于不同亚晶格（$A$、$B$ 和 $O$）之间的替换被视为独立处理的假设。\n$$N_{total} = N_A \\cdot N_B \\cdot N_O$$\n其中 $N_X$ 是亚晶格 $X$ 的不同修饰数量。\n\n现在我们必须推导 $N_X$ 的公式。一个亚晶格 $X$ 由一个包含 $n_X$ 个位点的单一Wyckoff轨道定义。我们给定一个包含 $m_X$ 种不同元素类型的集合，这些元素可以放置在这些位点上。关键的假设是：“在每个Wyckoff轨道内，空间群对称性使得各位置不可区分，因此仅因轨道内排列不同而产生的标记被视为等价。”\n\n这个假设显著简化了问题。它意味着我们无需考虑空间群对位点集合的具体作用，而是任何元素在轨道 $n_X$ 个位点上的排列都会产生相同且不可区分的结构。这将问题从一个复杂的群论枚举问题（例如需要针对特定空间群使用伯恩赛德引理或Pólya枚举定理的问题）简化为一个基本的组合问题。\n\n我们实质上是在尝试确定从一个包含 $m_X$ 种元素类型的集合中选择 $n_X$ 个元素（可重复选择）的方法数，其中选择的顺序无关紧要。这是一个从一个包含 $m_X$ 个项目的集合中计算大小为 $n_X$ 的多重集数量的问题。\n\n设 $m_X$ 种元素类型为 $E_1, E_2, \\dots, E_{m_X}$。亚晶格 $X$ 的一个特定修饰由每种元素类型占据的位点数定义。设 $k_i$ 是元素类型 $E_i$ 占据的位点数。由于总共有 $n_X$ 个位点，非负整数集合 $\\{k_1, k_2, \\dots, k_{m_X}\\}$ 必须满足以下条件：\n$$k_1 + k_2 + \\dots + k_{m_X} = n_X, \\quad k_i \\ge 0$$\n因此，不同修饰的数量 $N_X$ 等于该方程的非负整数解的数量。\n\n这是一个经典的组合问题，可以使用“星号和隔板法”来解决。想象我们有 $n_X$ 个不可区分的物品（星号, $*$），希望将它们放入 $m_X$ 个可区分的箱子（元素类型）中。我们可以通过排列 $n_X$ 个星号和 $m_X - 1$ 个隔板（竖线, $|$）来表示这种安排。例如，如果 $n_X=5$ 和 $m_X=4$，排列 `**|*||**` 对应于解 $k_1=2$、$k_2=1$、$k_3=0$ 和 $k_4=2$。\n\n符号（星号和隔板）的总数是 $n_X + (m_X - 1)$。这些符号的任何序列都代表一个唯一的解。唯一序列的数量等同于从总共 $n_X + m_X - 1$ 个可用位置中选择 $n_X$ 个位置来放置星号。这由二项式系数给出：\n$$N_X = \\binom{n_X + m_X - 1}{n_X}$$\n这也可以写成选择 $m_X - 1$ 个隔板的位置：\n$$N_X = \\binom{n_X + m_X - 1}{m_X - 1}$$\n这两个表达式是等价的，因为 $\\binom{n}{k} = \\binom{n}{n-k}$。\n\n结合每个亚晶格的这个结果，不同修饰结构的总数由以下公式给出：\n$$N_{total} = \\binom{n_A + m_A - 1}{n_A} \\cdot \\binom{n_B + m_B - 1}{n_B} \\cdot \\binom{n_O + m_O - 1}{n_O}$$\n\n这个公式将被实现以解决给定的测试案例。\n\n原型的具体参数是：\n- 钙钛矿 ($ABO_3$): $n_A=1$, $n_B=1$, $n_O=3$。\n- 尖晶石 ($AB_2O_4$): $n_A=8$, $n_B=16$, $n_O=32$。\n\n对于任何多重性 $n_X=1$ 的亚晶格，公式简化为：\n$$N_X = \\binom{1 + m_X - 1}{1} = \\binom{m_X}{1} = m_X$$\n这是直观的：只有一个位点，因此有 $m_X$ 种选择来放置元素。\n\n对于任何允许的元素类型数量 $m_X=1$ 的亚晶格，公式简化为：\n$$N_X = \\binom{n_X + 1 - 1}{n_X} = \\binom{n_X}{n_X} = 1$$\n这也是直观的：如果只允许一种元素类型，那么只有一种方法来修饰亚晶格（即用该元素填满所有位点）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the number of distinct decorated crystal structures based on\n    combinatorial principles for high-throughput materials screening.\n    \"\"\"\n\n    # Define the Wyckoff orbit multiplicities for each prototype structure.\n    # n_X is the number of symmetry-equivalent sites for sublattice X.\n    prototype_params = {\n        'perovskite': {'n_A': 1, 'n_B': 1, 'n_O': 3},\n        'spinel': {'n_A': 8, 'n_B': 16, 'n_O': 32},\n    }\n\n    # Test suite provided in the problem statement.\n    # Each case is a tuple: (prototype_name, m_A, m_B, m_O)\n    # m_X is the number of allowed element types for sublattice X.\n    test_cases = [\n        ('perovskite', 2, 3, 2),\n        ('perovskite', 1, 1, 1),\n        ('perovskite', 5, 4, 3),\n        ('spinel', 2, 2, 1),\n        ('spinel', 2, 3, 2),\n    ]\n\n    results = []\n\n    def count_decorations(n, m):\n        \"\"\"\n        Calculates the number of ways to decorate a sublattice with n sites\n        using m element types.\n\n        This is a multiset combination problem, also known as \"stars and bars\".\n        The formula is C(n + m - 1, n).\n\n        Args:\n            n (int): The number of indistinguishable sites (orbit multiplicity).\n            m (int): The number of distinct element types to choose from.\n\n        Returns:\n            int: The number of distinct decorations for the sublattice.\n        \"\"\"\n        # Ensure n and m are non-negative integers.\n        if n  0 or m  0:\n            raise ValueError(\"Number of sites and element types must be non-negative.\")\n        if m == 0 and n > 0:\n            return 0  # Cannot fill sites if no elements are available.\n        if n == 0:\n            return 1 # One way to have an empty decoration.\n        \n        # Using math.comb for robust calculation of binomial coefficients\n        # C(n, k) = n! / (k! * (n-k)!)\n        return math.comb(n + m - 1, n)\n\n    for case in test_cases:\n        prototype_name, m_A, m_B, m_O = case\n        params = prototype_params[prototype_name]\n        n_A, n_B, n_O = params['n_A'], params['n_B'], params['n_O']\n\n        # Calculate the number of distinct decorations for each sublattice.\n        N_A = count_decorations(n_A, m_A)\n        N_B = count_decorations(n_B, m_B)\n        N_O = count_decorations(n_O, m_O)\n\n        # The total number of distinct structures is the product of the\n        # possibilities for each independent sublattice.\n        total_structures = N_A * N_B * N_O\n        results.append(total_structures)\n\n    # Format the final output as a comma-separated list in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456708"}, {"introduction": "高通量计算的结果并非绝对精确，其固有的不确定性必须得到量化。本练习引入了一种强大的统计方法——蒙特卡洛自助法 (Monte Carlo bootstrap)，用于将计算出的生成焓的不确定性传播到相稳定性（凸包之上的能量 $E_{\\mathrm{hull}}$）的最终预测中[@problem_id:3456702]。掌握这项技术对于可靠地解读筛选结果至关重要，它使你能够区分那些被确信稳定的材料和那些稳定性处于临界或不确定状态的材料。", "problem": "您正在设计一个自动化工作流，用于将密度泛函理论 (DFT) 计算的生成焓中的不确定性传播到二元体系的相稳定性评估中，该工作流适用于高通量材料筛选。对于一个由元素 A 和 B 组成的二元体系，考虑一组由 $i$ 索引的中间化合物，其组成为 $x_i \\in (0,1)$（表示 B 的原子分数），每个原子的生成焓为 $H_{f,i}$，单位为电子伏特/原子。根据定义，位于 $x=0$ 和 $x=1$ 的纯元素的 $H_f = 0$。每个中间化合物都有一个独立估计的不确定性，用标准差 $\\sigma_i$ 表示，并且不确定性被建模为独立的高斯分布。\n\n您的任务是实现一个蒙特卡洛自助法，在每个测试用例中，将 $H_{f,i}$ 的不确定性传播到指定目标化合物的高于凸包的能量 $E_{\\mathrm{hull},i}$。所需的步骤和定义如下：\n\n- 基本原理：对于两个分别位于组分 $x_a$ 和 $x_b$、生成焓为 $H_{f,a}$ 和 $H_{f,b}$ 的相，其连接线上的混合物的每原子生成焓由凸组合 $H_{f,\\mathrm{mix}}(x) = \\lambda H_{f,a} + (1-\\lambda) H_{f,b}$ 给出，其中 $\\lambda = \\dfrac{x_b - x}{x_b - x_a}$，适用于 $x \\in [x_a, x_b]$。点集 $\\{(x,H_f)\\}$ 的下凸包络（一维中的凸包）代表了在杠杆定则下能量稳定的混合物集合。组分 $x_i$ 处高于凸包的能量定义为 $E_{\\mathrm{hull},i} = H_{f,i} - H_{\\mathrm{hull}}(x_i)$，其中 $H_{\\mathrm{hull}}(x)$ 是通过在包围 $x$ 的相邻凸包顶点之间进行线性插值，在 $x$ 处计算得到的凸包能量。\n\n- 用于传播不确定性的自助法程序：\n  1. 对于一个给定的用例，构建一个包含纯元素 $(0,0)$ 和 $(1,0)$ 以及所有中间化合物 $(x_i, H_{f,i})$ 的完整点集。纯元素的不确定性为零。\n  2. 对于每次自助法重复 $b \\in \\{1,\\dots,B\\}$，为每个中间化合物独立地抽取一个样本 $H'_{f,i} \\sim \\mathcal{N}(H_{f,i}, \\sigma_i^2)$；保持 $(0,0)$ 和 $(1,0)$ 不变。\n  3. 使用正确的凸性条件计算采样点 $\\{(x_i, H'_{f,i})\\}$ 加上 $(0,0)$ 和 $(1,0)$ 的下凸包：对于三个连续的候选凸包点 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$，且 $x_1  x_2  x_3$，其斜率必须满足 $\\dfrac{y_2 - y_1}{x_2 - x_1} \\le \\dfrac{y_3 - y_2}{x_3 - x_2}$；否则，移除中间点并重新检查，直到满足凸性条件。\n  4. 通过在包围目标组分 $x_t$ 的两个相邻凸包顶点之间进行线性插值，来计算 $H_{\\mathrm{hull}}(x_t)$。\n  5. 为该次自助法重复计算 $E^{(b)}_{\\mathrm{hull}} = \\max\\{0, H'_{f,t} - H_{\\mathrm{hull}}(x_t)\\}$。\n  6. 在 $B$ 次重复之后，通过集合 $\\{E^{(b)}_{\\mathrm{hull}}\\}_{b=1}^B$ 在概率 $0.025$ 和 $0.975$ 处的经验分位数，来估计样本均值和双侧 $95\\%$ 置信区间。\n\n- 您的程序必须使用提供的种子实现上述具有确定性伪随机性的过程。\n\n- 所有能量都必须以电子伏特/原子表示，并且所有输出都必须以电子伏特/原子报告，并四舍五入到 $6$ 位小数。\n\n- 为了数值稳定性，将任何因浮点舍入而产生的 $E_{\\mathrm{hull}}$ 负值视为 $0$。\n\n数学和算法规范：\n\n- 您必须计算增广了 $(0,0)$ 和 $(1,0)$ 的点集 $(x,H_f)$ 的一维下凸包。该凸包是位于所有点之下或与之相等的唯一最小凸函数。一种实用的一维构建方法是按 $x$ 对点进行排序，并如上所述在连续的三元组上迭代地强制执行凸性不等式。\n\n- 在每个测试用例中，您仅需为指定的目标化合物生成结果。对于在某次自助法重复中，组分恰好等于一个凸包顶点的目标，该次重复中的 $E_{\\mathrm{hull}}$ 为 $0$。\n\n- 置信区间定义：如果排序后的 $E_{\\mathrm{hull}}$ 样本为 $e_{(1)} \\le \\dots \\le e_{(B)}$，则下端点是位置在 $\\lceil 0.025 \\times B \\rceil$ 的元素，上端点是位置在 $\\lceil 0.975 \\times B \\rceil$ 的元素，使用标准经验分位数并允许线性插值；使用数值库在概率 $0.025$ 和 $0.975$ 处的的分位数函数是可以接受的。\n\n测试套件涵盖一般情况、边界情况和边缘情况。在以下每个用例中，构建凸包时都应包括不确定性为零的纯元素 $(0,0)$ 和 $(1,0)$；只有列出的中间化合物是不确定的。\n\n- 用例 1（一般的稳定内部相）：\n  - 中间化合物的组分和统计数据： $\\{(x_i, H_{f,i}, \\sigma_i)\\} = \\{(0.25, -0.090, 0.020), (0.50, -0.150, 0.015), (0.75, -0.085, 0.020)\\}$。\n  - 目标索引： $1$ (即组分为 $x = 0.50$ 的化合物)。\n  - 自助法重复次数： $B = 400$。\n  - 种子： $7$。\n\n- 用例 2（不确定性可能跨越凸包的亚稳态近边界相）：\n  - 中间化合物的组分和统计数据： $\\{(x_i, H_{f,i}, \\sigma_i)\\} = \\{(0.20, -0.030, 0.010), (0.33, -0.070, 0.025), (0.60, -0.040, 0.010), (0.80, -0.010, 0.010)\\}$。\n  - 目标索引： $0$ (即组分为 $x = 0.20$ 的化合物)。\n  - 自助法重复次数： $B = 400$。\n  - 种子： $11$。\n\n- 用例 3（测试凸包翻转的近简并内部相）：\n  - 中间化合物的组分和统计数据： $\\{(x_i, H_{f,i}, \\sigma_i)\\} = \\{(0.10, -0.005, 0.004), (0.40, -0.085, 0.012), (0.55, -0.083, 0.012), (0.90, -0.004, 0.004)\\}$。\n  - 目标索引： $2$ (即组分为 $x = 0.55$ 的化合物)。\n  - 自助法重复次数： $B = 600$。\n  - 种子： $13$。\n\n最终输出规范：\n\n- 对于每个用例，为目标化合物计算三个值：$E_{\\mathrm{hull}}$ 的自助法样本均值、经验下0.025分位数和经验上0.975分位数。\n- 将这三个值中的每一个都四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含按用例顺序排列的结果，形式为逗号分隔的列表的列表，每个内部列表的结构为 $[ \\text{均值}, \\text{下界}, \\text{上界} ]$。例如，打印的行应类似于 $[[m_1,\\ell_1,u_1],[m_2,\\ell_2,u_2],[m_3,\\ell_3,u_3]]$，其中每个条目都是一个浮点数，单位为电子伏特/原子，并四舍五入到 6 位小数。", "solution": "该问题已经过验证，并被确定为计算材料科学领域一个定义良好、有科学依据的问题。它提供了一套完整且一致的定义、数据和算法要求，以使用蒙特卡洛自助法对相稳定性进行不确定性量化。所有指定的参数在物理上都是合理的，并且该方法与该领域的标准实践相符。\n\n任务是将在密度泛函理论 (DFT) 中计算的生成焓 $H_{f,i}$ 的不确定性，传播到二元材料体系中高于凸包的能量这一派生量 $E_{\\mathrm{hull},i}$。每个 $H_{f,i}$ 的不确定性由标准差 $\\sigma_i$ 给出，并由独立的高斯分布 $\\mathcal{N}(H_{f,i}, \\sigma_i^2)$ 建模。解决方案需要实现指定的自助法程序。\n\n该方法的核心是为每个测试用例进行 $B$ 次重复的蒙特卡洛模拟。在每次重复中，我们执行以下步骤：\n\n1.  **随机抽样**：对于每个组分为 $x_i$ 且平均生成焓为 $H_{f,i}$ 的中间化合物，从其高斯概率分布中抽取一个新的生成焓样本 $H'_{f,i}$。位于 $x=0$ 和 $x=1$ 的纯元素的生成焓固定为 $H_f=0$，不确定性为零。通过为每个用例指定伪随机数生成器的种子，确保了此随机过程的可复现性。\n\n2.  **凸包构建**：使用所有中间化合物的点集 $\\{(x_i, H'_{f,i})\\}$，并增广纯元素的固定点 $(0,0)$ 和 $(1,0)$，来构建一维下凸包。这是通过使用 Andrew 单调链算法的一个变体来实现的，该算法非常适合这个一维问题。算法过程如下：\n    a. 所有点按其组分（x坐标）排序。\n    b. 遍历这些点，并建立一个候选凸包。对于每个正在考虑的新点 $p_3$，会根据候选凸包上的最后两个点 $p_1$ 和 $p_2$ 对其进行检查。这三个点必须形成“右转”或共线，以维持下凸包的凸性。这对应于线段斜率序列的非递减性：$\\text{slope}(p_1, p_2) \\le \\text{slope}(p_2, p_3)$。\n    c. 如果这些点形成“左转”（即 $\\text{slope}(p_1, p_2)  \\text{slope}(p_2, p_3)$），则中间点 $p_2$ 会引入凹性，并从候选凸包中移除。重复此检查直到满足凸性条件，然后添加新点 $p_3$。\n    d. 此过程产生一个定义下凸包的顶点列表，按组分排序。为了数值稳定性，斜率比较通过使用叉积来实现，从而避免了除法。在给定前一个凸包点 $p_1 = (x_1, y_1)$ 的情况下，当考虑点 $p_3 = (x_3, y_3)$ 时，移除点 $p_2 = (x_2, y_2)$ 的条件是 $(y_2 - y_1)(x_3 - x_2) - (x_2 - x_1)(y_3 - y_2)  0$。\n\n3.  **高于凸包的能量计算**：对于一个指定的目标化合物，其组分为 $x_t$，必须计算其高于凸包的能量 $E_{\\mathrm{hull}}$。\n    a. 首先，确定在目标组分处的凸包能量 $H_{\\mathrm{hull}}(x_t)$。这需要找到计算出的凸包上包围目标组分 $x_t$ 的两个相邻顶点 $(x_a, H_a)$ 和 $(x_b, H_b)$，即 $x_a \\le x_t \\le x_b$。\n    b. 然后通过在这两个顶点之间进行线性插值来计算 $H_{\\mathrm{hull}}(x_t)$：$H_{\\mathrm{hull}}(x_t) = H_a + (H_b - H_a) \\frac{x_t - x_a}{x_b - x_a}$。\n    c. 当前自助法重复中高于凸包的能量 $E^{(b)}_{\\mathrm{hull}}$，是目标化合物的采样焓与其组分处的凸包能量之差：$E^{(b)}_{\\mathrm{hull}} = H'_{f,t} - H_{\\mathrm{hull}}(x_t)$。根据规定，当一个点位于凸包上时，由于浮点不精确性可能产生的任何负值都将被设置为 $0$。\n\n4.  **统计分析**：完成所有 $B$ 次自助法重复后，获得一个 $\\{E^{(b)}_{\\mathrm{hull}}\\}_{b=1}^B$ 值的分布。从此分布中计算出样本均值，它代表了高于凸包能量的最佳估计。该估计的不确定性通过双侧 $95\\%$ 置信区间进行量化，该区间由样本分布在概率 $0.025$ 和 $0.975$ 处的经验分位数确定。\n\n该实现将封装在单个 Python 脚本中。利用 `numpy` 库进行高效的数值运算，特别是用于生成高斯随机数、执行数组操作以及计算最终的统计度量（均值和分位数）。每个用例的最终结果，包括均值、下分位数和上分位数，都将四舍五入到 6 位小数，并按要求格式化为单行输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty propagation problem for DFT formation enthalpies\n    using a Monte Carlo bootstrap method as specified.\n    \"\"\"\n    test_cases = [\n        {\n            \"data\": np.array([\n                [0.25, -0.090, 0.020],\n                [0.50, -0.150, 0.015],\n                [0.75, -0.085, 0.020]\n            ]),\n            \"target_idx\": 1,\n            \"B\": 400,\n            \"seed\": 7\n        },\n        {\n            \"data\": np.array([\n                [0.20, -0.030, 0.010],\n                [0.33, -0.070, 0.025],\n                [0.60, -0.040, 0.010],\n                [0.80, -0.010, 0.010]\n            ]),\n            \"target_idx\": 0,\n            \"B\": 400,\n            \"seed\": 11\n        },\n        {\n            \"data\": np.array([\n                [0.10, -0.005, 0.004],\n                [0.40, -0.085, 0.012],\n                [0.55, -0.083, 0.012],\n                [0.90, -0.004, 0.004]\n            ]),\n            \"target_idx\": 2,\n            \"B\": 600,\n            \"seed\": 13\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        data = case[\"data\"]\n        target_idx = case[\"target_idx\"]\n        B = case[\"B\"]\n        seed = case[\"seed\"]\n\n        x_coords = data[:, 0]\n        h_means = data[:, 1]\n        h_stds = data[:, 2]\n        target_x = x_coords[target_idx]\n\n        rng = np.random.default_rng(seed)\n\n        e_hull_samples = []\n        for _ in range(B):\n            # 1. Sample H_f values for intermediate compounds\n            h_samples = rng.normal(loc=h_means, scale=h_stds)\n            \n            # 2. Form the full set of points including endpoints (0,0) and (1,0)\n            points = [(0.0, 0.0)]\n            for i in range(len(x_coords)):\n                points.append((x_coords[i], h_samples[i]))\n            points.append((1.0, 0.0))\n            \n            # Points are already sorted by x-coordinate based on problem input structure\n            # points.sort(key=lambda p: p[0]) is implicitly handled.\n\n            # 3. Compute the lower convex hull using the monotone chain algorithm\n            lower_hull = []\n            for p3 in points:\n                # p1, p2, p3 must form a \"right turn\" for a lower hull. Pop on \"left turn\".\n                while len(lower_hull) >= 2:\n                    p1 = lower_hull[-2]\n                    p2 = lower_hull[-1]\n                    # Cross product check: (y2-y1)(x3-x2) - (x2-x1)(y3-y2) > 0 -> \"left turn\"\n                    # We pop if the turn is counter-clockwise (left turn), which corresponds\n                    # to a concave corner in the lower hull.\n                    if (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1]) > 0:\n                        lower_hull.pop()\n                    else:\n                        break\n                lower_hull.append(p3)\n\n            # 4. Evaluate H_hull(x_t) by interpolation on the computed hull\n            h_hull_at_target = 0.0\n            for i in range(len(lower_hull) - 1):\n                p_a = lower_hull[i]\n                p_b = lower_hull[i+1]\n                if p_a[0] = target_x = p_b[0]:\n                    xa, ha = p_a\n                    xb, hb = p_b\n                    # Handle cases where target_x is exactly a hull vertex\n                    if abs(target_x - xa)  1e-12:\n                        h_hull_at_target = ha\n                        break\n                    if abs(target_x - xb)  1e-12:\n                        h_hull_at_target = hb\n                        break\n                    # Linear interpolation for x_t between two hull vertices\n                    h_hull_at_target = ha + (hb - ha) * (target_x - xa) / (xb - xa)\n                    break\n            \n            # 5. Compute E_hull for the replicate\n            h_prime_t = h_samples[target_idx]\n            e_hull = h_prime_t - h_hull_at_target\n            e_hull = max(0.0, e_hull)\n            e_hull_samples.append(e_hull)\n\n        # 6. Compute statistics (mean, 95% CI)\n        e_hull_samples = np.array(e_hull_samples)\n        mean_e_hull = np.mean(e_hull_samples)\n        lower_ci = np.quantile(e_hull_samples, 0.025)\n        upper_ci = np.quantile(e_hull_samples, 0.975)\n        \n        all_results.append([\n            round(mean_e_hull, 6),\n            round(lower_ci, 6),\n            round(upper_ci, 6)\n        ])\n\n    result_str = \"[\" + \",\".join([f\"[{m},{l},{u}]\" for m, l, u in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3456702"}, {"introduction": "计算资源总是有限的，这要求我们采用智能的分配策略。本练习将计算预算的分配问题重构为一个经典的 0-1 背包问题[@problem_id:3456745]，其中，“价值”被量化为信息增益，即香农熵的减少量。通过解决这个优化问题，你将学习如何制定数据驱动的决策，以最大化每单位计算成本所能获得的科学知识，这标志着从“蛮力”筛选到智能、自适应工作流设计的转变。", "problem": "一个高通量计算材料筛选工作流必须在一组候选材料中，将有限的计算资源分配给收敛性精化任务。每个候选材料 $x_i$ 有一个不确定的属性，该属性被建模为一个具有高斯先验的潜在均值，并通过计算进行测量，这些计算产生具有已知高斯噪声的条件独立观测值。精化过程包括对候选材料 $i$ 执行 $m_i$ 次额外的独立计算采样，每次采样消耗 $u_i$ 核时，因此候选材料 $i$ 的增量成本为 $c_i = m_i u_i$ 核时。您必须将在总预算 $B$ 核时内决定精化哪些候选材料的问题，构建为一个 $0$-$1$ 背包选择问题，其中选择候选材料 $i$ 的“价值” $v_i$ 是从精化中获得的期望信息增益。\n\n使用以下基本原理：\n- 单变量高斯分布 $\\mathcal{N}(0,\\sigma^2)$ 的香农微分熵 (SDE) 为 $H(\\sigma^2) = \\frac{1}{2}\\ln\\!\\big(2\\pi e\\,\\sigma^2\\big)$，单位为奈特 (nats)。\n- 在正态-正态共轭模型下，对于候选材料 $i$，已知其观测噪声方差为 $\\tau_i^2$ 和先验方差为 $\\sigma_{0,i}^2$，经过 $m_i$ 次独立观测后，后验精度等于先验精度与数据精度之和：$\\sigma_{\\text{post},i}^{-2} = \\sigma_{0,i}^{-2} + m_i \\tau_i^{-2}$，因此 $\\sigma_{\\text{post},i}^{2} = \\big(\\sigma_{0,i}^{-2} + m_i \\tau_i^{-2}\\big)^{-1}$。\n\n基于这些基础，推导出候选材料 $i$ 的信息增益 $v_i$ 为先验与后验之间SDE的减少量，并使用所提供的参数为每个候选材料计算 $v_i$。将选择问题表述为：对于子集 $S \\subset \\{0,1,\\dots,N-1\\}$，最大化 $\\sum_{i \\in S} v_i$，约束条件为 $\\sum_{i \\in S} c_i \\le B$，其中每个物品要么被选中，要么不被选中；不允许分数选择。通过以下规则确定性地解决平局：在所有达到最大总价值的子集中，选择总成本最小的子集；如果仍然存在平局，则选择索引和最小的子集。\n\n您的程序必须实现一个带有上述平局打破规则的精确 $0$-$1$ 背包动态规划算法，为每个测试用例计算所选的索引，并将结果在单行中以逗号分隔并用方括号括起来的列表形式输出。每个结果必须是该测试用例按升序排列的所选索引列表。\n\n物理单位说明：所有计算预算和成本都必须以核时为单位处理，所有熵都必须以奈特 (nats) 为单位。最终输出仅包含整数索引，这些索引是无单位的。\n\n测试套件：\n- 测试用例 1 (正常路径):\n  - $N = 6$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.09, 0.16, 0.25, 0.04, 0.12, 0.20\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.03, 0.04, 0.05, 0.02, 0.06, 0.08\\big]$\n  - 计划采样数 $m$: $\\big[2, 3, 1, 4, 2, 3\\big]$\n  - 单位成本 $u$ (核时/每次采样): $\\big[4, 5, 2, 3, 6, 4\\big]$\n  - 预算 $B = 25$ 核时。\n- 测试用例 2 (边界条件 $B=0$):\n  - $N = 3$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.10, 0.20, 0.30\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.05, 0.10, 0.15\\big]$\n  - 计划采样数 $m$: $\\big[1, 2, 3\\big]$\n  - 单位成本 $u$: $\\big[4, 5, 6\\big]$\n  - 预算 $B = 0$ 核时。\n- 测试用例 3 (精确匹配，唯一最优解):\n  - $N = 5$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.10, 0.08, 0.18, 0.12, 0.05\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.05, 0.04, 0.09, 0.03, 0.05\\big]$\n  - 计划采样数 $m$: $\\big[2, 1, 2, 1, 3\\big]$\n  - 单位成本 $u$: $\\big[3, 6, 4, 5, 2\\big]$\n  - 预算 $B = 19$ 核时。\n- 测试用例 4 (含零价值物品的边缘情况，价值平局由最小索引和解决):\n  - $N = 4$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.15, 0.15, 0.30, 0.10\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.05, 0.05, 0.10, 0.10\\big]$\n  - 计划采样数 $m$: $\\big[0, 2, 1, 3\\big]$\n  - 单位成本 $u$: $\\big[3, 3, 6, 2\\big]$\n  - 预算 $B = 12$ 核时。\n- 测试用例 5 (总价值平局，由最小总成本解决):\n  - $N = 4$\n  - 先验方差 $\\sigma_{0}^2$: $\\big[0.20, 0.10, 0.05, 0.15\\big]$\n  - 噪声方差 $\\tau^2$: $\\big[0.10, 0.05, 0.05, 0.05\\big]$\n  - 计划采样数 $m$: $\\big[1, 2, 3, 1\\big]$\n  - 单位成本 $u$: $\\big[10, 5, 3, 6\\big]$\n  - 预算 $B = 19$ 核时。\n\n最终输出格式要求：您的程序应生成单行输出，包含以逗号分隔并用方括号括起来的列表形式的结果，其中每个测试用例的结果是按升序排列的所选索引列表，例如 $\\big[[0,1,2],[],[0,2,3],[1,2],[1,3]\\big]$。", "solution": "用户提供的问题陈述被评估为 **有效**。它在计算材料科学和信息论方面有科学依据，在数学上被恰当地表述为一个带有确定性平局打破规则的0-1背包问题，并为所有测试用例提供了一套完整且一致的给定条件。\n\n目标是选择一个候选材料子集进行计算精化，以在固定的计算预算 $B$ 内最大化总信息增益。这可以严格地表述为一个 $0$-$1$ 背包问题。\n\n首先，我们必须推导出将每个候选材料 $i$ 包含在精化集 $S$ 中的“价值” $v_i$ 和“成本”（或“重量”） $c_i$。\n\n精化候选材料 $i$ 的成本 $c_i$ 被明确给出为计划计算采样数 $m_i$ 和每次采样的单位成本 $u_i$ (以核时为单位)的乘积：\n$$c_i = m_i u_i$$\n由于在所有测试用例中 $m_i$ 和 $u_i$ 都被指定为整数，所以成本 $c_i$ 是一个整数。\n\n价值 $v_i$ 被定义为期望信息增益，通过属性分布从先验到后验的香农微分熵 (SDE) 的减少量来量化。具有方差 $\\sigma^2$ 的单变量高斯分布的SDE由下式给出：\n$$H(\\sigma^2) = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma^2)$$\n具有先验方差 $\\sigma_{0,i}^2$ 的候选材料 $i$ 的先验熵为：\n$$H_{\\text{prior},i} = H(\\sigma_{0,i}^2) = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{0,i}^2)$$\n在 $m_i$ 次独立观测后（每次观测的噪声方差为 $\\tau_i^2$），后验方差 $\\sigma_{\\text{post},i}^2$ 的贝叶斯更新规则如下：\n$$\\sigma_{\\text{post},i}^2 = \\left(\\sigma_{0,i}^{-2} + m_i \\tau_i^{-2}\\right)^{-1}$$\n那么后验熵为：\n$$H_{\\text{post},i} = H(\\sigma_{\\text{post},i}^2) = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{\\text{post},i}^2)$$\n信息增益 $v_i$ 是其差值：\n$$v_i = H_{\\text{prior},i} - H_{\\text{post},i} = \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{0,i}^2) - \\frac{1}{2}\\ln(2\\pi e\\,\\sigma_{\\text{post},i}^2)$$\n使用对数性质 $\\ln a - \\ln b = \\ln(a/b)$，我们将其简化为：\n$$v_i = \\frac{1}{2}\\ln\\left(\\frac{2\\pi e\\,\\sigma_{0,i}^2}{2\\pi e\\,\\sigma_{\\text{post},i}^2}\\right) = \\frac{1}{2}\\ln\\left(\\frac{\\sigma_{0,i}^2}{\\sigma_{\\text{post},i}^2}\\right)$$\n我们可以使用后验方差公式来表示方差之比：\n$$\\frac{1}{\\sigma_{\\text{post},i}^2} = \\frac{1}{\\sigma_{0,i}^2} + \\frac{m_i}{\\tau_i^2}$$\n两边乘以 $\\sigma_{0,i}^2$：\n$$\\frac{\\sigma_{0,i}^2}{\\sigma_{\\text{post},i}^2} = \\sigma_{0,i}^2 \\left(\\frac{1}{\\sigma_{0,i}^2} + \\frac{m_i}{\\tau_i^2}\\right) = 1 + m_i \\frac{\\sigma_{0,i}^2}{\\tau_i^2}$$\n将此代回 $v_i$ 的表达式中，得到每个物品价值的最终公式：\n$$v_i = \\frac{1}{2}\\ln\\left(1 + m_i \\frac{\\sigma_{0,i}^2}{\\tau_i^2}\\right)$$\n请注意，如果 $m_i=0$，则 $v_i = \\frac{1}{2}\\ln(1) = 0$，这在逻辑上是一致的，因为没有获得新的信息。\n\n选择问题是找到一个索引子集 $S \\subseteq \\{0, 1, \\dots, N-1\\}$，以最大化总价值 $\\sum_{i \\in S} v_i$，同时满足预算约束 $\\sum_{i \\in S} c_i \\le B$。这是一个典型的 $0$-$1$ 背包问题。问题要求通过动态规划得到精确解，并规定了三级平局打破规则：\n1.  最大化总价值 $\\sum v_i$。\n2.  在具有最大价值的解中，最小化总成本 $\\sum c_i$。\n3.  如果仍然平局，最小化所选候选材料的索引之和 $\\sum i$。\n\n为了实现这一点，我们采用动态规划方法。设 $dp[i][w]$ 为使用前 $i$ 个物品（索引为 $0, \\dots, i-1$）在预算为 $w$ 的情况下可达到的最优解。为了处理平局打破规则，每个状态 $dp[i][w]$ 将存储一个元组 $(V, C, I_{\\text{sum}})$，分别代表最大价值、达到该价值的最小成本、以及在该成本下的最小索引和。\n\n大小为 $(N+1) \\times (B+1)$ 的DP表 `dp` 被初始化为 $(0, 0, 0)$。该表被迭代填充。对于每个物品 $i$（从 $1$ 到 $N$）和每个预算容量 $w$（从 $1$ 到 $B$），我们决定是否包含物品 $i-1$（其属性为 $v_{i-1}, c_{i-1}, \\text{index}=i-1$）。\n\n递推关系如下：$dp[i][w]$ 是以下两个候选方案中更优的一个：\n1.  **不包含物品 $i-1$**：解与前 $i-1$ 个物品的解相同，即 $dp[i-1][w]$。\n2.  **包含物品 $i-1$** (如果 $w \\ge c_{i-1}$): 解由选择物品 $i-1$ 并将其加到前 $i-1$ 个物品在剩余预算 $dp[i-1][w-c_{i-1}]$ 下的最优解上形成。新的元组是 $(dp[i-1][w-c_{i-1}].V + v_{i-1}, dp[i-1][w-c_{i-1}].C + c_{i-1}, dp[i-1][w-c_{i-1}].I_{\\text{sum}} + (i-1))$。\n\n根据指定的平局打破规则选择“更优”的候选方案。填充整个表后，$dp[N][B]$ 处的元组代表了最优解的属性。\n\n为了重构所选物品的集合，使用第二个表 `path[i][w]` 来存储在每一步做出的决策。通过从 `path[N][B]` 开始向后追溯这些决策，我们可以识别出最优集中包含的所有物品。然后按要求将得到的索引列表按升序排序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of 0-1 knapsack problems derived from a materials screening\n    workflow, with specific tie-breaking rules.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"N\": 6,\n            \"sig0_sq\": [0.09, 0.16, 0.25, 0.04, 0.12, 0.20],\n            \"tau_sq\": [0.03, 0.04, 0.05, 0.02, 0.06, 0.08],\n            \"m\": [2, 3, 1, 4, 2, 3],\n            \"u\": [4, 5, 2, 3, 6, 4],\n            \"B\": 25,\n        },\n        # Test case 2 (boundary B=0)\n        {\n            \"N\": 3,\n            \"sig0_sq\": [0.10, 0.20, 0.30],\n            \"tau_sq\": [0.05, 0.10, 0.15],\n            \"m\": [1, 2, 3],\n            \"u\": [4, 5, 6],\n            \"B\": 0,\n        },\n        # Test case 3 (exact fit, unique optimum)\n        {\n            \"N\": 5,\n            \"sig0_sq\": [0.10, 0.08, 0.18, 0.12, 0.05],\n            \"tau_sq\": [0.05, 0.04, 0.09, 0.03, 0.05],\n            \"m\": [2, 1, 2, 1, 3],\n            \"u\": [3, 6, 4, 5, 2],\n            \"B\": 19,\n        },\n        # Test case 4 (edge case with zero-value item, tie on value resolved by minimal index sum)\n        {\n            \"N\": 4,\n            \"sig0_sq\": [0.15, 0.15, 0.30, 0.10],\n            \"tau_sq\": [0.05, 0.05, 0.10, 0.10],\n            \"m\": [0, 2, 1, 3],\n            \"u\": [3, 3, 6, 2],\n            \"B\": 12,\n        },\n        # Test case 5 (tie on total value, resolve by minimal total cost)\n        {\n            \"N\": 4,\n            \"sig0_sq\": [0.20, 0.10, 0.05, 0.15],\n            \"tau_sq\": [0.10, 0.05, 0.05, 0.05],\n            \"m\": [1, 2, 3, 1],\n            \"u\": [10, 5, 3, 6],\n            \"B\": 19,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        sig0_sq = case[\"sig0_sq\"]\n        tau_sq = case[\"tau_sq\"]\n        m = case[\"m\"]\n        u = case[\"u\"]\n        B = case[\"B\"]\n\n        items = []\n        for i in range(N):\n            cost = int(m[i] * u[i])\n            if m[i] == 0 or tau_sq[i] == 0:\n                value = 0.0\n            else:\n                value = 0.5 * np.log(1 + m[i] * sig0_sq[i] / tau_sq[i])\n            items.append({'v': value, 'c': cost, 'i': i})\n\n        # dp[i][w] = (max_value, min_cost, min_index_sum)\n        # for items 0..i-1 and budget w\n        dp = [[(0.0, 0, 0) for _ in range(B + 1)] for _ in range(N + 1)]\n        path = [[0 for _ in range(B + 1)] for _ in range(N + 1)]\n\n        for i in range(1, N + 1):\n            item = items[i - 1]\n            v_i, c_i, idx_i = item['v'], item['c'], item['i']\n\n            for w in range(B + 1):\n                # Option 1: Don't include item i-1\n                candidate1 = dp[i - 1][w]\n                dp[i][w] = candidate1\n                path[i][w] = 0\n\n                # Option 2: Include item i-1 (if possible)\n                if w >= c_i:\n                    base_sol_for_2 = dp[i - 1][w - c_i]\n                    candidate2 = (\n                        base_sol_for_2[0] + v_i,\n                        base_sol_for_2[1] + c_i,\n                        base_sol_for_2[2] + idx_i\n                    )\n                    \n                    v1, c1, s1 = candidate1\n                    v2, c2, s2 = candidate2\n\n                    # Compare candidates using the specified tie-breaking rules\n                    # A small tolerance is used for floating-point value comparison\n                    is_candidate2_better = False\n                    if v2 > v1 + 1e-9:\n                        is_candidate2_better = True\n                    elif abs(v2 - v1)  1e-9:\n                        if c2  c1:\n                            is_candidate2_better = True\n                        elif c2 == c1:\n                            if s2  s1:\n                                is_candidate2_better = True\n                    \n                    if is_candidate2_better:\n                        dp[i][w] = candidate2\n                        path[i][w] = 1\n\n        # Backtrack to find the selected items\n        selected_indices = []\n        w = B\n        for i in range(N, 0, -1):\n            if path[i][w] == 1:\n                item_index = items[i - 1]['i']\n                item_cost = items[i - 1]['c']\n                selected_indices.append(item_index)\n                w -= item_cost\n\n        selected_indices.sort()\n        all_results.append(selected_indices)\n\n    # Format the final output string as specified\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str.replace(' ', '')}]\")\n\nsolve()\n```", "id": "3456745"}]}