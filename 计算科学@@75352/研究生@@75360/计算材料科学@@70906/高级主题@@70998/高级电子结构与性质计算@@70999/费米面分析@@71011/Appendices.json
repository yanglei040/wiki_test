{"hands_on_practices": [{"introduction": "量子振荡效应，如德哈斯-范阿尔芬（de Haas-van Alphen, dHvA）效应，是探测金属费米面几何形状的强大实验工具。本练习将通过一个解析模型，具体展示费米面的极端截面积如何直接决定实验中可观测到的磁阻振荡频率 [@problem_id:3451505]。通过这个实践，你将加深对Onsager关系以及回旋有效质量等核心概念的理解。", "problem": "考虑一个具有以下色散关系的准二维单电子能带\n$$\nE(\\mathbf{k}) \\equiv E(k_{x},k_{y},k_{z}) = \\frac{\\hbar^{2}}{2 m} \\left(k_{x}^{2} + k_{y}^{2}\\right) + 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right],\n$$\n其中，$m$ 是面内能带质量，$t_{z}  0$ 是层间跃迁振幅，$c$ 是层间晶格常数，$\\hbar$ 是约化普朗克常数。假设费米能量 $E_{F}$ 为一常数且满足 $E_{F}  4 t_{z}$，因此费米面是一个沿 $\\hat{z}$ 方向的弱波纹圆柱体。施加一个沿 $\\hat{z}$ 方向的均匀磁场，使得回旋运动发生在固定的 $k_{z}$ 平面内。\n\n从磁场中电子轨道的基本半经典量子化理论以及费米面作为满足 $E(\\mathbf{k}) = E_{F}$ 的 $\\mathbf{k}$ 点集合的核心定义出发，完成以下任务：\n\n1. 对于固定的 $k_{z}$，推导 $k_{x}$-$k_{y}$ 平面内的费米波矢 $k_{F}(k_{z})$ 以及该 $k_{z}$ 处费米等高线所包围的相应横截面积 $A(k_{z})$。\n2. 确定 $A(k_{z})$ 相对于 $k_{z}$ 的极值，指明产生最大和最小面积的 $k_{z}$ 值，并以符号形式给出这些面积。\n3. 使用半经典量子化框架，预测与这些极值横截面相关的基本量子振荡（德哈斯-范阿尔芬 (dHvA)）频率，以及在费米能级上这些轨道的相应回旋有效质量。\n\n将最终结果以单个行矩阵的形式给出，按顺序包含两个极值 dHvA 频率（先最大面积，后最小面积）和两个相应的回旋有效质量（先最大面积轨道，后最小面积轨道）。振荡频率以特斯拉为单位，有效质量以千克为单位。无需提供数值；请用 $m$、$E_{F}$、$t_{z}$、$e$ 和 $\\hbar$ 给出闭合形式的解析表达式。在最终的方框答案中不要包含任何单位。", "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 步骤 1：提取给定条件\n- **色散关系**：$E(\\mathbf{k}) \\equiv E(k_{x},k_{y},k_{z}) = \\frac{\\hbar^{2}}{2 m} \\left(k_{x}^{2} + k_{y}^{2}\\right) + 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]$。\n- **参数**：$m$ 是面内能带质量，$t_{z}  0$ 是层间跃迁振幅，$c$ 是层间晶格常数，$\\hbar$ 是约化普朗克常数。元电荷用 $e$ 表示。\n- **条件**：费米能量 $E_{F}$ 是一个满足 $E_{F}  4 t_{z}$ 的常数。\n- **设置**：沿 $\\hat{z}$ 方向施加均匀磁场。回旋运动发生在恒定的 $k_{z}$ 平面内。\n- **任务**：\n  1. 对于固定的 $k_{z}$，推导费米波矢 $k_{F}(k_{z})$ 和横截面积 $A(k_{z})$。\n  2. 确定 $A(k_{z})$ 相对于 $k_{z}$ 的极值、极值点对应的 $k_{z}$ 值以及这些极值面积的符号表达式。\n  3. 预测这些极值轨道的德哈斯-范阿尔芬 (dHvA) 频率和相应的回旋有效质量。\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学依据（关键）**：该问题基于固体中电子动力学的半经典模型和紧束缚近似，这些都是凝聚态物理中标准且完善的理论框架。该色散关系是准二维层状材料的常用模型。量子振荡（dHvA 效应）的分析是一种基本的实验和理论工具。该问题具有科学合理性。\n- **适定性**：问题陈述清晰。条件 $E_{F}  4 t_{z}$ 至关重要，它确保了费米面是一个单一、连续、类似波纹圆柱体的面，在任何 $k_{z}$ 处都不会“夹断”或出现能隙。这保证了明确定义的、非零的最小和最大横截面积的存在，从而得到唯一解。\n- **客观性（关键）**：该问题使用精确的数学语言和客观的物理概念进行表述，没有任何主观或有偏见的陈述。\n\n### 步骤 3：结论与行动\n问题是有效的。它具有科学合理性、适定性和客观性，并包含足够的信息以获得唯一解。开始求解。\n\n---\n\n### 第 1 部分：费米波矢和横截面积\n\n费米面被定义为所有能量 $E(\\mathbf{k})$ 等于费米能量 $E_{F}$ 的波矢 $\\mathbf{k}$ 的集合。\n$$\nE_{F} = \\frac{\\hbar^{2}}{2 m} \\left(k_{x}^{2} + k_{y}^{2}\\right) + 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\n$$\n问题陈述指出，磁场沿 $\\hat{z}$ 方向，导致电子在恒定的 $k_{z}$ 平面内进行回旋运动。对于固定的 $k_{z}$，费米面等高线是 $k_{x}$-$k_{y}$ 平面上的一个圆。令 $k_{\\perp}^{2} = k_{x}^{2} + k_{y}^{2}$。在固定 $k_{z}$ 处，费米面的方程变为：\n$$\n\\frac{\\hbar^{2}}{2 m} k_{\\perp}^{2} = E_{F} - 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\n$$\n平面内的费米波矢 $k_{F}(k_{z})$ 是这个圆形横截面的半径，即在费米能量处计算的 $k_{\\perp}$。\n$$\nk_{F}(k_{z})^{2} = \\frac{2 m}{\\hbar^{2}} \\left(E_{F} - 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\\right)\n$$\n因此，费米波矢为：\n$$\nk_{F}(k_{z}) = \\sqrt{\\frac{2 m}{\\hbar^{2}} \\left(E_{F} - 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\\right)}\n$$\n在恒定 $k_{z}$ 平面内，费米面的横截面积 $A(k_{z})$ 是一个半径为 $k_{F}(k_{z})$ 的圆的面积：\n$$\nA(k_{z}) = \\pi k_{F}(k_{z})^{2}\n$$\n代入 $k_{F}(k_{z})^{2}$ 的表达式：\n$$\nA(k_{z}) = \\frac{2 \\pi m}{\\hbar^{2}} \\left(E_{F} - 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\\right)\n$$\n\n### 第 2 部分：极值横截面积\n\n为了找到 $A(k_{z})$ 的极值，我们必须找到项 $\\cos(k_{z} c)$ 的极值，因为所有其他项都是常数。函数 $\\cos(x)$ 的最大值为 $1$，最小值为 $-1$。\n\n当从 $E_{F}$ 中减去的项最小时，面积 $A(k_{z})$ 达到最大值。这发生在 $1 - \\cos(k_{z} c)$ 取最小值时。$1 - \\cos(k_{z} c)$ 的最小值为 $1 - 1 = 0$，此时 $\\cos(k_{z} c) = 1$。此条件在 $k_{z} c = 2 n \\pi$ 时满足，即对任意整数 $n$，有 $k_{z} = \\frac{2 n \\pi}{c}$。一个主值为 $k_{z}=0$。这个轨道通常被称为“腹”轨道。最大面积 $A_{max}$ 为：\n$$\nA_{max} = A(k_{z}=0) = \\frac{2 \\pi m}{\\hbar^{2}} \\left(E_{F} - 2 t_{z} \\left[1 - 1\\right]\\right) = \\frac{2 \\pi m E_{F}}{\\hbar^{2}}\n$$\n\n当从 $E_{F}$ 中减去的项最大时，面积 $A(k_{z})$ 达到最小值。这发生在 $1 - \\cos(k_{z} c)$ 取最大值时。$1 - \\cos(k_{z} c)$ 的最大值为 $1 - (-1) = 2$，此时 $\\cos(k_{z} c) = -1$。此条件在 $k_z c = (2 n + 1) \\pi$ 时满足，即对任意整数 $n$，有 $k_{z} = \\frac{(2 n + 1) \\pi}{c}$。一个主值为 $k_z = \\pi/c$，这在许多简单情况下对应于布里渊区边界。这个轨道通常被称为“颈”轨道。最小面积 $A_{min}$ 为：\n$$\nA_{min} = A(k_{z}=\\pi/c) = \\frac{2 \\pi m}{\\hbar^{2}} \\left(E_{F} - 2 t_{z} \\left[1 - (-1)\\right]\\right) = \\frac{2 \\pi m}{\\hbar^{2}} \\left(E_{F} - 4 t_{z}\\right)\n$$\n条件 $E_{F}  4 t_{z}$ 确保了 $A_{min}$ 为正值，且费米面没有被“夹断”。\n\n### 第 3 部分：dHvA 频率和回旋质量\n\n德哈斯-范阿尔芬 (dHvA) 振荡频率 $F$（以磁场单位特斯拉计量）通过昂萨格关系与费米面的极值横截面积 $A_{ext}$ 相关：\n$$\nF = \\frac{\\hbar}{2 \\pi e} A_{ext}\n$$\n我们有两个极值面积，$A_{max}$ 和 $A_{min}$，它们产生两个基本频率，$F_{max}$ 和 $F_{min}$。\n\n对于最大面积轨道：\n$$\nF_{max} = \\frac{\\hbar}{2 \\pi e} A_{max} = \\frac{\\hbar}{2 \\pi e} \\left(\\frac{2 \\pi m E_{F}}{\\hbar^{2}}\\right) = \\frac{m E_{F}}{e \\hbar}\n$$\n\n对于最小面积轨道：\n$$\nF_{min} = \\frac{\\hbar}{2 \\pi e} A_{min} = \\frac{\\hbar}{2 \\pi e} \\left(\\frac{2 \\pi m (E_{F} - 4 t_{z})}{\\hbar^{2}}\\right) = \\frac{m (E_{F} - 4 t_{z})}{e \\hbar}\n$$\n\n接下来，我们确定这些轨道的回旋有效质量 $m_{c}$。回旋质量在费米能量处定义为：\n$$\nm_{c}(k_{z}) = \\frac{\\hbar^{2}}{2 \\pi} \\left. \\frac{\\partial A(E, k_{z})}{\\partial E} \\right|_{E=E_{F}}\n$$\n为了计算它，我们首先将面积 $A$ 表示为一般能量 $E$ 和 $k_z$ 的函数：\n$$\nA(E, k_z) = \\frac{2 \\pi m}{\\hbar^{2}} \\left(E - 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\\right)\n$$\n现在，我们对 $E$ 求偏导数：\n$$\n\\frac{\\partial A(E, k_{z})}{\\partial E} = \\frac{\\partial}{\\partial E} \\left[ \\frac{2 \\pi m}{\\hbar^{2}} \\left(E - 2 t_{z} \\left[1 - \\cos\\left(k_{z} c\\right)\\right]\\right) \\right] = \\frac{2 \\pi m}{\\hbar^{2}}\n$$\n这个导数是一个常数，与 $E$ 和 $k_{z}$ 都无关。因此，费米面上所有轨道的回旋质量都是相同的。\n$$\nm_{c} = \\frac{\\hbar^{2}}{2 \\pi} \\left(\\frac{2 \\pi m}{\\hbar^{2}}\\right) = m\n$$\n这个结果证实了最大面积轨道（$m_{c,max}$）和最小面积轨道（$m_{c,min}$）的回旋质量都等于面内能带质量 $m$。\n$$\nm_{c,max} = m_{c,min} = m\n$$\n对于在回旋轨道平面内呈纯抛物线型的色散关系，这是预期的结果。\n\n最终答案要求一个行矩阵，按顺序包含四个计算出的量：$F_{max}$、$F_{min}$、$m_{c,max}$、$m_{c,min}$。", "answer": "$$\n\\boxed{\\pmatrix{ \\frac{m E_{F}}{e \\hbar}  \\frac{m(E_{F} - 4t_{z})}{e \\hbar}  m  m }}\n$$", "id": "3451505"}, {"introduction": "虽然解析模型对于教学很有帮助，但真实的材料研究通常始于来自第一性原理计算（如密度泛函理论）的复杂数据。本练习模拟了一个常见的工作流程：将一个物理意义清晰的紧束缚模型参数化，以重现计算得到的能带结构的关键特征 [@problem_id:3451506]。这项实践将锻炼你在数据分析、线性回归和模型验证方面的实用技能。", "problem": "您将执行一项基于计算材料科学中费米面分析的任务。该任务从一个公认的紧束缚（TB）近似模型出发，该模型描述了二维方格晶格上包含次次近邻跃迁的单能带系统。在此框架下，电子能带能量作为晶体动量 $\\mathbf{k} = (k_x,k_y)$ 的函数，可以表示为一个傅里叶级数，其系数为跃迁振幅。为了构建一个简约而富有表现力的模型，采用以下能量参数形式：\n$$\nE(\\mathbf{k}) \\equiv E(k_x,k_y) = \\epsilon_0 - 2 t_1 \\left(\\cos k_x + \\cos k_y\\right) - 4 t_2 \\cos k_x \\cos k_y - 2 t_3 \\left(\\cos 2 k_x + \\cos 2 k_y\\right),\n$$\n其中 $\\epsilon_0$ 是相对于费米能（设为 $0$）的在位能，而 $t_1$、$t_2$、$t_3$ 是跃迁振幅。所有能量单位必须为电子伏特（eV），所有角度单位必须为弧度。\n\n您的任务是编写一个完整且可运行的程序，该程序能够：\n- 使用已知的基准参数和带有指定伪随机数种子的高斯噪声模型，沿动量空间 $\\mathbf{k}_i$ 中的指定路径生成合成的“第一性原理”能量数据 $E_i$。对于每个测试用例，自变量 $\\mathbf{k}$ 必须沿着两条正交路径进行采样：一条是在固定的 $k_y = k_{y,0}$ 下，改变 $k_x$；另一条是在固定的 $k_x = k_{x,0}$ 下，改变 $k_y$。余弦函数的参数单位是弧度，布里渊区的范围对于 $k_x$ 和 $k_y$ 均为 $[0,\\pi]$。\n- 通过对以下线性形式进行普通最小二乘拟合，来确定TB参数 $\\theta = [\\epsilon_0, t_1, t_2, t_3]^T$：\n$$\nE(\\mathbf{k}) = \\epsilon_0 + t_1 X_1(\\mathbf{k}) + t_2 X_2(\\mathbf{k}) + t_3 X_3(\\mathbf{k}),\n$$\n其中\n$$\nX_1(\\mathbf{k}) = -2 \\left(\\cos k_x + \\cos k_y\\right), \\quad X_2(\\mathbf{k}) = -4 \\cos k_x \\cos k_y, \\quad X_3(\\mathbf{k}) = -2 \\left(\\cos 2 k_x + \\cos 2 k_y\\right).\n$$\n- 报告拟合的均方根误差（RMSE），单位为 eV，定义为\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(E_i - \\widehat{E}_i\\right)^2},\n$$\n并四舍五入到六位小数。\n- 通过以下布尔标准评估拟合参数的物理合理性，所有标准必须同时满足才能判定拟合结果具有物理合理性：\n    1. 最近邻跃迁占主导地位：$\\max\\left(|t_2|,|t_3|\\right) \\leq 0.6\\,|t_1|$。\n    2. 相对于费米能级的在位能偏移较小：$|\\epsilon_0| \\leq 0.1$ eV。\n    3. 根据模型系数估算的能带宽度合理：$W_{\\mathrm{est}} \\equiv 8|t_1| + 16|t_2| + 8|t_3| \\leq 3.0$ eV。\n- 对于每个测试用例，输出一个列表，其中包含RMSE（一个四舍五入到六位小数的浮点数）和合理性判定（一个布尔值）。程序的最终输出必须是包含每个用例结果的单行列表，不含任何额外文本。\n\n请使用以下包含三个用例的测试套件。在所有用例中，使用 $\\pi$ 作为布里渊区边界，并在指定区间内对 $k_x$ 和 $k_y$ 进行线性采样。生成高斯噪声时，使用零均值以及指定的标准差和种子。能量单位必须为 eV，角度单位必须为弧度。\n\n- 用例A（一般情况，轻度噪声）：\n    - 基准参数：$\\epsilon_0 = 0.02$ eV, $t_1 = 0.25$ eV, $t_2 = -0.05$ eV, $t_3 = 0.02$ eV。\n    - 路径：固定 $k_y = \\pi/3$，在 $0$到$\\pi$（含边界）之间采样 $N_x = 41$ 个 $k_x$ 点；固定 $k_x = \\pi/5$，在 $0$到$\\pi$（含边界）之间采样 $N_y = 37$ 个 $k_y$ 点。\n    - 噪声：高斯噪声，标准差 $\\sigma = 0.003$ eV；伪随机数种子 $s = 1$。\n\n- 用例B（仅各向同性最近邻，无噪声）：\n    - 基准参数：$\\epsilon_0 = 0.0$ eV, $t_1 = 0.15$ eV, $t_2 = 0.0$ eV, $t_3 = 0.0$ eV。\n    - 路径：固定 $k_y = \\pi/4$，在 $0$到$\\pi$（含边界）之间采样 $N_x = 25$ 个 $k_x$ 点；固定 $k_x = \\pi/2$，在 $0$到$\\pi$（含边界）之间采样 $N_y = 25$ 个 $k_y$ 点。\n    - 噪声：$\\sigma = 0.0$ eV；伪随机数种子 $s = 2$（种子对于零噪声无关紧要，但仍需设置）。\n\n- 用例C（近简并各向异性，轻度噪声）：\n    - 基准参数：$\\epsilon_0 = 0.0$ eV, $t_1 = 0.08$ eV, $t_2 = 0.06$ eV, $t_3 = 0.0$ eV。\n    - 路径：固定 $k_y = \\pi/6$，在 $0$到$\\pi$（含边界）之间采样 $N_x = 41$ 个 $k_x$ 点；固定 $k_x = \\pi/3$，在 $0$到$\\pi$（含边界）之间采样 $N_y = 41$ 个 $k_y$ 点。\n    - 噪声：高斯噪声，标准差 $\\sigma = 0.002$ eV；伪随机数种子 $s = 3$。\n\n实现要求：\n- 使用特征 $X_1(\\mathbf{k})$、$X_2(\\mathbf{k})$、$X_3(\\mathbf{k})$ 以及用于 $\\epsilon_0$ 的截距项，为每个数据点构建设计矩阵的一行。\n- 使用适合线性回归的数值稳定方法求解最小二乘问题。\n- 对每个用例，计算以 eV 为单位的 RMSE 和如上所述的物理合理性判定。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，格式必须完全如下：\n\"[ [rmse_A,plaus_A], [rmse_B,plaus_B], [rmse_C,plaus_C] ]\"\n其中每个“rmse_X”是四舍五入到六位小数的浮点数，每个“plaus_X”是布尔值。例如，一个结构正确的输出应类似于“[[0.001234,True],[0.000000,True],[0.002345,False]]”，但需使用为指定测试套件计算出的实际值。", "solution": "所提出的问题是计算材料科学领域中一个有效且适定的练习，特别是在电子能带结构参数化方面。它要求使用线性最小二乘法将紧束缚（TB）模型拟合到合成生成的能量数据上。问题陈述的有效性验证过程如下。\n\n给定条件如下：\n1.  **能量模型**：二维方格晶格的电子能带能量 $E(\\mathbf{k})$ 由以下公式给出：\n    $$\n    E(\\mathbf{k}) \\equiv E(k_x,k_y) = \\epsilon_0 - 2 t_1 \\left(\\cos k_x + \\cos k_y\\right) - 4 t_2 \\cos k_x \\cos k_y - 2 t_3 \\left(\\cos 2 k_x + \\cos 2 k_y\\right)\n    $$\n    其中 $\\mathbf{k} = (k_x, k_y)$ 是晶体动量，$\\epsilon_0$ 是相对于费米能级 $0$ 的在位能，而 $t_1, t_2, t_3$ 是跃迁振幅。\n2.  **线性回归形式**：模型将以线性形式 $E(\\mathbf{k}) = \\epsilon_0 + t_1 X_1(\\mathbf{k}) + t_2 X_2(\\mathbf{k}) + t_3 X_3(\\mathbf{k})$ 进行拟合，其系数（参数）为 $\\theta = [\\epsilon_0, t_1, t_2, t_3]^T$，基函数（特征）为：\n    $$\n    X_1(\\mathbf{k}) = -2 \\left(\\cos k_x + \\cos k_y\\right) \\\\\n    X_2(\\mathbf{k}) = -4 \\cos k_x \\cos k_y \\\\\n    X_3(\\mathbf{k}) = -2 \\left(\\cos 2 k_x + \\cos 2 k_y\\right)\n    $$\n3.  **均方根误差 (RMSE)**：拟合质量由 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(E_i - \\widehat{E}_i\\right)^2}$ 来衡量，四舍五入到六位小数，其中 $E_i$ 是“观测”到的能量，$\\widehat{E}_i$ 是拟合得到的能量。\n4.  **物理合理性标准**：一个拟合结果被认为是合理的，当且仅当所有三个条件都满足：\n    - 最近邻跃迁占主导地位：$\\max\\left(|t_2|,|t_3|\\right) \\leq 0.6\\,|t_1|$。\n    - 在位能偏移较小：$|\\epsilon_0| \\leq 0.1$ eV。\n    - 合理的能带宽度估计：$W_{\\mathrm{est}} \\equiv 8|t_1| + 16|t_2| + 8|t_3| \\leq 3.0$ eV。\n5.  **测试用例**：提供了三个具体的用例（A、B、C），包括基准参数、用于数据采样的动量空间路径描述，以及高斯噪声生成规范（标准差 $\\sigma$ 和伪随机数种子 $s$）。\n\n该问题具有科学依据，是适定且客观的。它利用了标准的TB模型和一种常见的参数拟合技术（普通最小二乘法），这在该领域是基础性的。所有组成部分都有明确定义，包括数学模型、数据生成协议、误差度量和评估标准。所提供的数据和约束条件是自洽且物理上合理的。因此，该问题被认为是有效的，并且可以构建一个解决方案。\n\n解决方案的思路是将任务表述为一个线性回归问题。对于一组 $N$ 个数据点 $(\\mathbf{k}_i, E_i)$，我们寻求参数矢量 $\\hat{\\theta} = [\\hat{\\epsilon}_0, \\hat{t}_1, \\hat{t}_2, \\hat{t}_3]^T$ 以最小化残差平方和。这可以用矩阵形式表示为最小化 $\\| \\mathbf{E} - A \\theta \\|_2^2$，其中 $\\mathbf{E}$ 是观测能量的 $N \\times 1$ 矢量，$\\theta$ 是参数的 $4 \\times 1$ 矢量，而 $A$ 是 $N \\times 4$ 的设计矩阵。\n\n设计矩阵 $A$ 的列对应于线性模型的基函数。对于每个数据点 $\\mathbf{k}_i = (k_{x,i}, k_{y,i})$， $A$ 的对应行是：\n$$\nA_i = \\begin{bmatrix} 1  X_1(\\mathbf{k}_i)  X_2(\\mathbf{k}_i)  X_3(\\mathbf{k}_i) \\end{bmatrix}\n$$\n第一列全为1，是截距项 $\\epsilon_0$ 的回归量。前面提到的基函数 $X_1, X_2, X_3$ 构成了其余的列。\n\n每个测试用例的处理流程如下：\n1.  **数据生成**：\n    - 动量矢量 $\\mathbf{k}_i$ 通过创建两个指定的线性点网格（例如，使用 `numpy.linspace`）并将其连接起来而生成。\n    - 对于每个 $\\mathbf{k}_i$，使用该用例给定的基准参数计算真实能量 $E_{\\mathrm{true},i}$。\n    - 播种一个伪随机数生成器，并生成一个具有指定标准差 $\\sigma$ 的高斯噪声矢量。\n    - 最终的“观测”能量计算为 $E_i = E_{\\mathrm{true},i} + \\mathrm{noise}_i$。\n\n2.  **线性回归**：\n    - 根据生成的 $\\mathbf{k}_i$ 矢量构建设计矩阵 $A$。\n    - 求解普通最小二乘问题 $A\\theta = \\mathbf{E}$ 以得到参数矢量 $\\hat{\\theta}$。这是通过使用数值稳定的算法完成的，例如基于 QR 分解或奇异值分解（SVD）的算法，正如在 `numpy.linalg.lstsq` 中实现的那样。\n\n3.  **分析**：\n    - 使用确定的参数预测拟合能量：$\\widehat{\\mathbf{E}} = A\\hat{\\theta}$。\n    - RMSE 计算为 $(E_i - \\widehat{E}_i)^2$ 均值的平方根。\n    - 拟合参数 $\\hat{\\epsilon}_0, \\hat{t}_1, \\hat{t}_2, \\hat{t}_3$ 根据三个指定的物理合理性标准进行评估。总体合理性是各个检查的逻辑与（AND）。\n\n整个过程被封装在一个程序中，该程序遍历三个测试用例并将结果格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Tight-Binding model fitting problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: General, mildly noisy\n        {\n            \"truth_params\": [0.02, 0.25, -0.05, 0.02],  # [eps0, t1, t2, t3]\n            \"cuts\": [\n                {\"fixed_dim\": \"ky\", \"fixed_val\": np.pi / 3, \"var_dim\": \"kx\", \"n_points\": 41},\n                {\"fixed_dim\": \"kx\", \"fixed_val\": np.pi / 5, \"var_dim\": \"ky\", \"n_points\": 37},\n            ],\n            \"noise_sigma\": 0.003,\n            \"seed\": 1,\n        },\n        # Case B: Isotropic nearest-neighbor only, noiseless\n        {\n            \"truth_params\": [0.0, 0.15, 0.0, 0.0],\n            \"cuts\": [\n                {\"fixed_dim\": \"ky\", \"fixed_val\": np.pi / 4, \"var_dim\": \"kx\", \"n_points\": 25},\n                {\"fixed_dim\": \"kx\", \"fixed_val\": np.pi / 2, \"var_dim\": \"ky\", \"n_points\": 25},\n            ],\n            \"noise_sigma\": 0.0,\n            \"seed\": 2,\n        },\n        # Case C: Near-degenerate anisotropy, mildly noisy\n        {\n            \"truth_params\": [0.0, 0.08, 0.06, 0.0],\n            \"cuts\": [\n                {\"fixed_dim\": \"ky\", \"fixed_val\": np.pi / 6, \"var_dim\": \"kx\", \"n_points\": 41},\n                {\"fixed_dim\": \"kx\", \"fixed_val\": np.pi / 3, \"var_dim\": \"ky\", \"n_points\": 41},\n            ],\n            \"noise_sigma\": 0.002,\n            \"seed\": 3,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n    \n    # Format the final output string exactly as required.\n    # Python's str(True) - \"True\", which matches the example.\n    output_parts = [f\"[{res[0]:.6f},{res[1]}]\" for res in results]\n    print(f\"[{','.join(output_parts)}]\")\n\n\ndef energy_model(k_vectors, params):\n    \"\"\"\n    Calculates energy E(k) based on the TB model.\n    k_vectors is an (N, 2) array of (kx, ky) pairs.\n    params is a list or array of [eps0, t1, t2, t3].\n    \"\"\"\n    kx, ky = k_vectors[:, 0], k_vectors[:, 1]\n    eps0, t1, t2, t3 = params\n    \n    E = (eps0\n         - 2 * t1 * (np.cos(kx) + np.cos(ky))\n         - 4 * t2 * np.cos(kx) * np.cos(ky)\n         - 2 * t3 * (np.cos(2 * kx) + np.cos(2 * ky)))\n    return E\n\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case: generates data, fits model, and evaluates.\n    \"\"\"\n    # 1. Generate k-points\n    all_k_vectors = []\n    for cut in case_data[\"cuts\"]:\n        var_coords = np.linspace(0, np.pi, cut[\"n_points\"])\n        if cut[\"var_dim\"] == \"kx\":\n            kx_coords = var_coords\n            ky_coords = np.full_like(kx_coords, cut[\"fixed_val\"])\n        else: # var_dim == \"ky\"\n            ky_coords = var_coords\n            kx_coords = np.full_like(ky_coords, cut[\"fixed_val\"])\n        all_k_vectors.append(np.stack((kx_coords, ky_coords), axis=1))\n    \n    k_vectors = np.concatenate(all_k_vectors, axis=0)\n    \n    # 2. Generate \"ab initio\" energy data with noise\n    E_true = energy_model(k_vectors, case_data[\"truth_params\"])\n    rng = np.random.default_rng(case_data[\"seed\"])\n    noise = rng.normal(loc=0.0, scale=case_data[\"noise_sigma\"], size=E_true.shape[0])\n    E_observed = E_true + noise\n    \n    # 3. Construct the design matrix\n    kx, ky = k_vectors[:, 0], k_vectors[:, 1]\n    N = k_vectors.shape[0]\n    \n    # The model to fit is E = eps0 - t1*(-X1) - t2*(-X2) - t3*(-X3)\n    # The linear regression form is E = C0*1 + C1*X1 + C2*X2 + C3*X3\n    # Where C0=eps0, C1=t1, C2=t2, C3=t3\n    # So we need to define X1, X2, X3 as per the problem.\n    X0 = np.ones(N)  # Intercept for eps0\n    X1_reg = -2 * (np.cos(kx) + np.cos(ky))\n    X2_reg = -4 * np.cos(kx) * np.cos(ky)\n    X3_reg = -2 * (np.cos(2 * kx) + np.cos(2 * ky))\n    \n    # The regression model is E = B0*X0 + B1*X1_reg + B2*X2_reg + B3*X3_reg\n    # We are fitting for [eps0, t1, t2, t3]\n    # E = eps0 + t1*(-2*(coskx+cosky)) + t2*(-4*coskx*cosky) + t3*(-2*(cos2kx+cos2ky))\n    # This structure is incorrect in the problem statement.\n    # The equation is E = eps0 - 2t1(...) - 4t2(...) - 2t3(...)\n    # The linear form given is E = eps0 + t1 X1 + t2 X2 + t3 X3\n    # This implies the fit parameters will be -t1, -t2, -t3.\n    # Let's follow the problem's specified linear form E(k) = eps0 + t1 X1(k) + t2 X2(k) + t3 X3(k)\n    # This means the fit parameters will be [eps0, t1, t2, t3].\n    # But the energy is defined with minus signs. E = eps0 - 2t1(...)\n    # Let's assume the fit is for parameters p0,p1,p2,p3 in E = p0 + p1*X1 + p2*X2 + p3*X3.\n    # Then eps0 = p0, t1=p1, t2=p2, t3=p3.\n    # But E = eps0 - 2t1(...) implies E = eps0 + t1 * (-2*(...)).\n    # The problem has a subtle ambiguity. I will assume the regressors are as defined, and the coefficients are t1, t2, t3.\n    # E_obs = eps0 * 1 + t1 * X1 + t2 * X2 + t3 * X3. This seems to be the intent.\n    \n    A = np.stack([X0, X1_reg, X2_reg, X3_reg], axis=1)\n\n    # 4. Perform linear least-squares fit\n    # The parameters we get are [eps0, t1, t2, t3] directly\n    fitted_params, _, _, _ = np.linalg.lstsq(A, E_observed, rcond=None)\n    \n    # 5. Calculate RMSE\n    E_predicted = A @ fitted_params\n    rmse = np.sqrt(np.mean((E_observed - E_predicted)**2))\n    \n    # 6. Check physical plausibility\n    eps0_fit, t1_fit, t2_fit, t3_fit = fitted_params\n    \n    # Condition 1: Dominant nearest-neighbor hopping\n    if t1_fit == 0: # Avoid division by zero\n        plaus1 = max(abs(t2_fit), abs(t3_fit)) == 0\n    else:\n        plaus1 = max(abs(t2_fit), abs(t3_fit)) = 0.6 * abs(t1_fit)\n    \n    # Condition 2: Small onsite offset\n    plaus2 = abs(eps0_fit) = 0.1\n    \n    # Condition 3: Reasonable bandwidth\n    W_est = 8 * abs(t1_fit) + 16 * abs(t2_fit) + 8 * abs(t3_fit)\n    plaus3 = W_est = 3.0\n    \n    is_plausible = bool(plaus1 and plaus2 and plaus3)\n    \n    return [round(rmse, 6), is_plausible]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3451506"}, {"introduction": "任何基于费米面的数值计算，例如态密度，都必须经过仔细的收敛性测试以确保结果的准确性。本练习旨在解决一项关键任务：确定一个足够密集的k点网格来精确地采样布里渊区 [@problem_id:3451530]。你将学习如何基于目标物理量（态密度 $N(E_F)$）和相关属性（费米速度 $| \\mathbf{v}_F |$）建立一个稳健的收敛标准，这对于处理具有高曲率费米面的体系尤其重要。", "problem": "在简约晶格单位下，给定一个具有高曲率费米面的金属的参数化单带模型。在倒易空间中，布里渊区 (BZ) 是以 $(-\\pi,-\\pi,-\\pi)$ 和 $(\\pi,\\pi,\\pi)$ 为角点的立方体。电子色散由以下紧束缚函数定义：\n$$\nE(\\mathbf{k}) = -2t\\left(\\cos k_x + \\cos k_y + \\alpha \\cos k_z\\right) - 4t_2\\left(\\cos k_x \\cos k_y + \\cos k_y \\cos k_z + \\cos k_z \\cos k_x\\right),\n$$\n其中参数为 $t = 1$，$t_2 = 0.3$，以及 $\\alpha = 0.5$。所有物理量均采用简约晶格单位，其中晶格常数设为 $a=1$，约化普朗克常数设为 $\\hbar = 1$。角度单位为弧度。\n\n您的任务是设计并实现一个程序。该程序在给定费米能级处态密度 $N(E_F)$ 的目标绝对容差和平均费米速度大小变化量的绝对容差后，估算出为满足指定金属的这两个收敛判据所需的最小均匀 k 点网格密度 $n$（每轴点数）。该程序必须是通用的，并基于第一性原理和经过充分检验的定义，且不得假定任何预先计算的常数。\n\n基本依据和定义：\n- 态密度 (DOS) 定义为\n$$\nN(E) = \\frac{1}{(2\\pi)^3} \\int_{\\mathrm{BZ}} \\delta\\!\\left(E - E(\\mathbf{k})\\right)\\, d^3k,\n$$\n其中 $\\delta(\\cdot)$ 是狄拉克 δ 分布。等价地，通过余面积变换，\n$$\nN(E) = \\frac{1}{(2\\pi)^3} \\oint_{E(\\mathbf{k})=E} \\frac{dS}{\\left\\lvert \\nabla_{\\mathbf{k}} E(\\mathbf{k}) \\right\\rvert}.\n$$\n- 费米速度定义为\n$$\n\\mathbf{v}_F(\\mathbf{k}) = \\nabla_{\\mathbf{k}} E(\\mathbf{k}),\n$$\n在所述的简约单位下。\n\n数值公式约束：\n- 使用均匀 Monkhorst-Pack 式网格，在布里渊区的每个轴向上取 $n$ 个点，这些点位于等距子区间的中点。也就是说，每个轴向上的点为 $k_i = -\\pi + \\left(i + \\frac{1}{2}\\right)\\Delta$，其中 $\\Delta = \\frac{2\\pi}{n}$ 且 $i \\in \\{0,1,\\dots,n-1\\}$。\n- 用宽度为 $\\sigma$ 的归一化高斯函数来近似狄拉克 δ 函数：\n$$\ng_{\\sigma}(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right).\n$$\n- 由于在此单位下布里渊区的体积等于 $(2\\pi)^3$，因此对于态密度估算量，黎曼和近似简化为网格上的算术平均值，\n$$\n\\widehat{N}_{n,\\sigma}(E_F) = \\frac{1}{n^3} \\sum_{\\mathbf{k}} g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right).\n$$\n- 为以与态密度采样一致的方式量化费米速度的变化，定义费米能级处的高斯加权平均费米速度大小为\n$$\n\\widehat{V}_{n,\\sigma}(E_F) = \\frac{\\sum_{\\mathbf{k}} \\left\\lvert \\nabla_{\\mathbf{k}} E(\\mathbf{k}) \\right\\rvert g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right)}{\\sum_{\\mathbf{k}} g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right)}.\n$$\n\n收敛协议和目标：\n- 从初始网格 $n_0$ 开始，以固定步长 $\\Delta n$ 递增，确定最小的 $n$ 使得\n$$\n\\left\\lvert \\widehat{N}_{n,\\sigma}(E_F) - \\widehat{N}_{n-\\Delta n,\\sigma}(E_F) \\right\\rvert \\le \\varepsilon_N\n\\quad \\text{和} \\quad\n\\left\\lvert \\widehat{V}_{n,\\sigma}(E_F) - \\widehat{V}_{n-\\Delta n,\\sigma}(E_F) \\right\\rvert \\le \\varepsilon_V\n$$\n同时成立，其中 $\\varepsilon_N$ 是 $N(E_F)$ 的目标绝对容差，$\\varepsilon_V$ 是平均费米速度大小变化的绝对容差。如果在达到指定最大值 $n_{\\max}$ 之前没有 $n$ 能同时满足这两个条件，则该测试用例返回 $n_{\\max}$。\n- 这个基于速度的判据的理由，必须基于费米面积分如何通过 $\\left\\lvert \\nabla_{\\mathbf{k}} E(\\mathbf{k}) \\right\\rvert^{-1}$ 对各项贡献进行加权。这使得对具有大曲率和小 $\\left\\lvert \\nabla_{\\mathbf{k}} E(\\mathbf{k}) \\right\\rvert$ 的区域进行精确采样，对于 $N(E_F)$ 估算的稳定性至关重要。高曲率的费米面会加剧这种敏感性，因此高斯加权平均 $\\left\\lvert \\mathbf{v}_F \\right\\rvert$ 的变化可作为费米面几何形状采样是否稳定的代理指标。\n\n测试套件：\n对下列每组参数集，计算并报告满足两个判据的最小 $n$。所有能量单位与色散关系中的简约单位相同，$\\sigma$ 是高斯宽度，单位与能量单位相同，且容差均为绝对容差。\n- 情况 1：$E_F = 0.0$，$\\sigma = 0.05$，$\\varepsilon_N = 0.003$，$\\varepsilon_V = 0.002$，$n_0 = 8$，$\\Delta n = 4$，$n_{\\max} = 48$。\n- 情况 2：$E_F = 0.5$，$\\sigma = 0.05$，$\\varepsilon_N = 0.001$，$\\varepsilon_V = 0.0015$，$n_0 = 8$，$\\Delta n = 4$，$n_{\\max} = 48$。\n- 情况 3：$E_F = -2.5$，$\\sigma = 0.05$，$\\varepsilon_N = 0.005$，$\\varepsilon_V = 0.003$，$n_0 = 8$，$\\Delta n = 4$，$n_{\\max} = 48$。\n- 情况 4：$E_F = 1.5$，$\\sigma = 0.03$，$\\varepsilon_N = 0.002$，$\\varepsilon_V = 0.002$，$n_0 = 8$，$\\Delta n = 4$，$n_{\\max} = 48$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含四个情况下的最小网格尺寸，形式为方括号括起来的逗号分隔列表，例如 $[n_1,n_2,n_3,n_4]$。条目 $n_1$、$n_2$、$n_3$ 和 $n_4$ 必须是整数。不应打印任何其他文本。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上是合理的、良定的，并且基于计算凝聚态物理的既定原理。它提出了一个清晰、可形式化的任务，并提供了所有必要的参数和定义。因此，我们可以着手解决。\n\n目标是确定所需的最小均匀 k 点网格密度，该密度由每个倒易晶格矢量轴上的点数 $n$ 表示，以使费米能级处的态密度 $N(E_F)$ 和平均费米速度大小 $\\widehat{V}(E_F)$ 两者都达到收敛。收敛由特定的绝对容差定义。\n\n该解决方案是基于以下第一性原理和数值方法构建的。\n\n**1. 电子结构模型**\n\n电子能带结构由第一布里渊区 (BZ) 内的单带紧束缚色散关系 $E(\\mathbf{k})$ 描述，该布里渊区是由 $k_x, k_y, k_z \\in [-\\pi, \\pi]$ 定义的立方体。能量由下式给出：\n$$\nE(\\mathbf{k}) = -2t\\left(\\cos k_x + \\cos k_y + \\alpha \\cos k_z\\right) - 4t_2\\left(\\cos k_x \\cos k_y + \\cos k_y \\cos k_z + \\cos k_z \\cos k_x\\right)\n$$\n参数指定为 $t = 1$，$t_2 = 0.3$ 和 $\\alpha = 0.5$。所有量均采用简约晶格单位，其中晶格常数 $a=1$ 且约化普朗克常数 $\\hbar=1$。\n\n费米速度 $\\mathbf{v}_F(\\mathbf{k})$ 是色散关系相对于波矢 $\\mathbf{k}$ 的梯度：\n$$\n\\mathbf{v}_F(\\mathbf{k}) = \\nabla_{\\mathbf{k}} E(\\mathbf{k}) = \\left(\\frac{\\partial E}{\\partial k_x}, \\frac{\\partial E}{\\partial k_y}, \\frac{\\partial E}{\\partial k_z}\\right)\n$$\n偏导数可解析地计算得出：\n$$\n\\frac{\\partial E}{\\partial k_x} = 2t \\sin k_x + 4t_2 \\sin k_x \\left(\\cos k_y + \\cos k_z\\right)\n$$\n$$\n\\frac{\\partial E}{\\partial k_y} = 2t \\sin k_y + 4t_2 \\sin k_y \\left(\\cos k_x + \\cos k_z\\right)\n$$\n$$\n\\frac{\\partial E}{\\partial k_z} = 2t\\alpha \\sin k_z + 4t_2 \\sin k_z \\left(\\cos k_x + \\cos k_y\\right)\n$$\n我们关心的是此矢量的大小，$\\left\\lvert \\mathbf{v}_F(\\mathbf{k}) \\right\\rvert = \\sqrt{(\\frac{\\partial E}{\\partial k_x})^2 + (\\frac{\\partial E}{\\partial k_y})^2 + (\\frac{\\partial E}{\\partial k_z})^2}$。\n\n**2. 物理量的数值估算**\n\n布里渊区上的连续积分通过在均匀 k 点网格上的离散求和来近似。问题指定了一个 Monkhorst-Pack 式网格，其点位于子区间的中点。对于密度为 $n$ 的网格，沿每个轴 $j \\in \\{x,y,z\\}$ 的坐标为：\n$$\nk_{j,i} = -\\pi + \\left(i + \\frac{1}{2}\\right)\\frac{2\\pi}{n}, \\quad \\text{for } i \\in \\{0, 1, \\dots, n-1\\}\n$$\n这将在布里渊区中生成总共 $n^3$ 个 $\\mathbf{k}$ 点。\n\n能量为 $E$ 处的态密度 (DOS) $N(E)$ 由一个涉及狄拉克 δ 分布 $\\delta(x)$ 的积分定义。为进行数值计算，$\\delta(x)$ 被一个窄的归一化高斯函数 $g_{\\sigma}(x)$ 近似：\n$$\n\\delta(x) \\approx g_{\\sigma}(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\n其中 $\\sigma$ 是展宽参数。然后，用于计算态密度的布里渊区积分通过在 $n^3$ 个离散 k 点上的黎曼和来近似。由于布里渊区的体积为 $(2\\pi)^3$，每个 k 点的体积元为 $(2\\pi/n)^3$，因此费米能级 $E_F$ 处态密度的估算量变为一个简单的算术平均：\n$$\n\\widehat{N}_{n,\\sigma}(E_F) = \\frac{1}{(2\\pi)^3} \\sum_{\\mathbf{k}} g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right) \\left(\\frac{2\\pi}{n}\\right)^3 = \\frac{1}{n^3} \\sum_{\\mathbf{k}} g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right)\n$$\n此公式与问题陈述中提供的公式相符。\n\n在 $E_F$ 处的平均费米速度大小是作为加权平均计算的。每个 k 点的贡献由其与费米面的接近程度加权，该接近程度由相同的高斯函数 $g_{\\sigma}(E(\\mathbf{k}) - E_F)$ 捕获。估算量为：\n$$\n\\widehat{V}_{n,\\sigma}(E_F) = \\frac{\\sum_{\\mathbf{k}} \\left\\lvert \\nabla_{\\mathbf{k}} E(\\mathbf{k}) \\right\\rvert g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right)}{\\sum_{\\mathbf{k}} g_{\\sigma}\\!\\left(E(\\mathbf{k}) - E_F\\right)}\n$$\n分母与态密度估算量成正比，确保了适当归一化的加权平均。\n\n**3. 收敛算法**\n\n任务的核心是找到使计算属性收敛的最小网格密度 $n$。对于每个测试用例，算法按以下步骤进行：\n1.  初始化网格密度扫描，从 $n=n_0$ 开始，以 $\\Delta n$ 为步长增加，直至最大值 $n_{\\max}$。密度序列为 $n_0, n_0+\\Delta n, n_0+2\\Delta n, \\dots$。\n2.  对于初始密度 $n_0$，计算基线值 $\\widehat{N}_{n_0,\\sigma}(E_F)$ 和 $\\widehat{V}_{n_0,\\sigma}(E_F)$。这些值用作首次收敛性检查的参考。\n3.  遍历序列中随后的网格密度 $n  n_0$。在对应于密度 $n$ 的每一步中，计算当前值 $\\widehat{N}_{n,\\sigma}(E_F)$ 和 $\\widehat{V}_{n,\\sigma}(E_F)$。\n4.  将当前值与前一个网格密度 $n-\\Delta n$ 的值进行比较。如果以下两个条件同时满足，则达到收敛：\n    $$\n    \\left\\lvert \\widehat{N}_{n,\\sigma}(E_F) - \\widehat{N}_{n-\\Delta n,\\sigma}(E_F) \\right\\rvert \\le \\varepsilon_N\n    $$\n    $$\n    \\left\\lvert \\widehat{V}_{n,\\sigma}(E_F) - \\widehat{V}_{n-\\Delta n,\\sigma}(E_F) \\right\\rvert \\le \\varepsilon_V\n    $$\n    其中 $\\varepsilon_N$ 和 $\\varepsilon_V$ 是指定的绝对容差。\n5.  满足这两个条件的第一个 $n$ 值即为所需的最小密度。然后终止该测试用例的搜索，并报告此 $n$ 值。\n6.  如果循环完成且没有 $n \\le n_{\\max}$ 满足收敛判据，则该测试用例的结果为 $n_{\\max}$。\n\n对于问题中定义的四个测试用例，将分别实施此迭代过程，得出四个要报告的整数结果。该实现将利用向量化的数值计算以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the Fermi surface analysis problem for all test cases.\n    \"\"\"\n\n    # Model parameters from the problem statement\n    t = 1.0\n    t2 = 0.3\n    alpha = 0.5\n\n    def energy(kx, ky, kz):\n        \"\"\"\n        Calculates the electronic dispersion E(k).\n        Args:\n            kx, ky, kz: NumPy arrays of k-vector components.\n        Returns:\n            NumPy array of energy values.\n        \"\"\"\n        cos_kx = np.cos(kx)\n        cos_ky = np.cos(ky)\n        cos_kz = np.cos(kz)\n        \n        term1 = -2.0 * t * (cos_kx + cos_ky + alpha * cos_kz)\n        term2 = -4.0 * t2 * (cos_kx * cos_ky + cos_ky * cos_kz + cos_kz * cos_kx)\n        \n        return term1 + term2\n\n    def grad_energy_mag(kx, ky, kz):\n        \"\"\"\n        Calculates the magnitude of the Fermi velocity |nabla_k E(k)|.\n        Args:\n            kx, ky, kz: NumPy arrays of k-vector components.\n        Returns:\n            NumPy array of Fermi velocity magnitudes.\n        \"\"\"\n        sin_kx = np.sin(kx)\n        sin_ky = np.sin(ky)\n        sin_kz = np.sin(kz)\n        cos_kx = np.cos(kx)\n        cos_ky = np.cos(ky)\n        cos_kz = np.cos(kz)\n\n        grad_x = 2.0 * t * sin_kx + 4.0 * t2 * sin_kx * (cos_ky + cos_kz)\n        grad_y = 2.0 * t * sin_ky + 4.0 * t2 * sin_ky * (cos_kx + cos_kz)\n        grad_z = 2.0 * t * alpha * sin_kz + 4.0 * t2 * sin_kz * (cos_kx + cos_ky)\n        \n        return np.sqrt(grad_x**2 + grad_y**2 + grad_z**2)\n\n    def calculate_properties(n, E_F, sigma):\n        \"\"\"\n        Calculates the DOS and mean Fermi velocity magnitude for a given mesh density.\n        Args:\n            n: Integer, number of k-points per axis.\n            E_F: Float, Fermi energy.\n            sigma: Float, Gaussian broadening width.\n        Returns:\n            A tuple (dos, avg_v_f) containing the calculated properties.\n        \"\"\"\n        # Generate the k-point mesh\n        delta_k = 2.0 * np.pi / n\n        k_1d = -np.pi + (np.arange(n) + 0.5) * delta_k\n        kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n\n        # Calculate energies and velocity magnitudes on the mesh\n        E_k = energy(kx, ky, kz)\n        v_f_mag_k = grad_energy_mag(kx, ky, kz)\n        \n        # Calculate Gaussian weights\n        x = E_k - E_F\n        gaussian_weights = (1.0 / (sigma * np.sqrt(2.0 * np.pi))) * np.exp(-x**2 / (2.0 * sigma**2))\n        \n        # Calculate DOS estimator\n        dos_estimator = np.mean(gaussian_weights)\n        \n        # Calculate average Fermi velocity magnitude\n        numerator = np.sum(v_f_mag_k * gaussian_weights)\n        denominator = np.sum(gaussian_weights)\n        \n        # Handle case where denominator is zero to avoid division by zero error\n        if denominator == 0:\n            avg_v_f_estimator = 0.0\n        else:\n            avg_v_f_estimator = numerator / denominator\n            \n        return dos_estimator, avg_v_f_estimator\n\n    def find_converged_n(case_params):\n        \"\"\"\n        Finds the minimal mesh density n that satisfies the convergence criteria.\n        Args:\n            case_params: A tuple containing (E_F, sigma, eps_N, eps_V, n0, dn, n_max).\n        Returns:\n            Integer, the minimal converged n.\n        \"\"\"\n        E_F, sigma, eps_N, eps_V, n0, dn, n_max = case_params\n        \n        n_values = range(n0, n_max + 1, dn)\n        \n        # Calculate for the initial mesh n0\n        N_prev, V_prev = calculate_properties(n0, E_F, sigma)\n        \n        if len(n_values) == 1:\n            return n0\n\n        # Iterate from the second mesh size\n        for n in n_values[1:]:\n            N_curr, V_curr = calculate_properties(n, E_F, sigma)\n            \n            # Check for convergence\n            delta_N = abs(N_curr - N_prev)\n            delta_V = abs(V_curr - V_prev)\n            \n            if delta_N = eps_N and delta_V = eps_V:\n                return n\n            \n            # Update previous values for the next iteration\n            N_prev = N_curr\n            V_prev = V_curr\n            \n        # If loop finishes without convergence, return n_max\n        return n_max\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E_F, sigma, eps_N, eps_V, n0, dn, n_max)\n        (0.0, 0.05, 0.003, 0.002, 8, 4, 48),    # Case 1\n        (0.5, 0.05, 0.001, 0.0015, 8, 4, 48),  # Case 2\n        (-2.5, 0.05, 0.005, 0.003, 8, 4, 48),  # Case 3\n        (1.5, 0.03, 0.002, 0.002, 8, 4, 48),    # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_converged_n(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3451530"}]}