{"hands_on_practices": [{"introduction": "此练习是构建任何量子输运模型的基础，因为它关注器件与电极的界面。它将指导你推导一个简单一维紧束缚电极的精确能量依赖自能，并将其与广泛使用的宽带极限（WBL）近似进行比较。通过这个过程，你将能够量化该近似的误差，特别是在能带边缘的范霍夫奇点附近，从而深刻理解宽带近似的适用范围和局限性([@problem_id:3482922])。", "problem": "考虑一个由哈密顿量 $H_\\mathrm{d} = [\\varepsilon_\\mathrm{d}]$ 描述的单点器件，该器件耦合到两个半无限一维紧束缚导线，分别标记为左 ($L$) 和右 ($R$)。每条导线的特征在于其在位能 $\\varepsilon_0$ 和最近邻跃迁参数 $t$，器件通过耦合振幅 $\\tau_L$ 和 $\\tau_R$ 分别耦合到每条导线的末端格点。在非平衡格林函数 (NEGF) 框架内进行分析，从推迟格林函数 $G^r$、超前格林函数 $G^a$、自能 $\\Sigma_\\alpha^r(E)$（其中 $\\alpha \\in \\{L,R\\}$）以及耦合（展宽）函数 $\\Gamma_\\alpha(E)$ 的定义出发。使用 Landauer 方法处理相干输运，并利用 NEGF 形式主义中导出的透射、器件及导线性质之间的关系。\n\n您的任务是：\n- 从基本的 NEGF 定义和定义半无限周期系统导线自能的方程出发，推导半无限一维紧束缚链的精确的、依赖于能量的表面格林函数，并由此获得每条导线的 $\\Sigma_\\alpha^r(E)$ 和 $\\Gamma_\\alpha(E)$。\n- 定义宽带极限 (WBL) 近似，即将依赖于能量的耦合函数 $\\Gamma_\\alpha(E)$ 替换为常数 $\\Gamma_{\\alpha,0}$，该常数通过在参考能量 $E_0$ 处计算精确的 $\\Gamma_\\alpha(E)$ 来选取。在本问题中，设 $E_0 = 0\\,\\mathrm{eV}$。\n- 使用 NEGF 推导通过单点器件的透射函数，用 $G^r$、$G^a$ 和耦合函数表示。分别使用精确的半无限紧束缚自能和使用宽带极限（采用 $\\Gamma_{\\alpha,0}$ 且无能量依赖的实部移动）计算该透射函数。\n- 通过计算每个能量 $E$ 下的误差度量 $\\Delta(E) = \\frac{\\left|T_\\mathrm{WBL}(E) - T_\\mathrm{exact}(E)\\right|}{\\max\\left(T_\\mathrm{exact}(E), \\epsilon_\\mathrm{reg}\\right)}$ 来量化宽带极限在能带边缘附近的误差，此处会出现 van Hove 奇点。正则化常数 $\\epsilon_\\mathrm{reg} = 10^{-12}$。所有能量和耦合均以 $\\mathrm{eV}$ 表示。\n\n将上述内容在一个程序中实现，该程序为以下参数集测试套件计算误差度量 $\\Delta(E)$。该套件探讨了一般情况、趋近能带边缘的 van Hove 奇点、带外情况以及耦合边界条件：\n\n- 情况 1（一般情况，能带中心）：$(E, \\varepsilon_\\mathrm{d}, \\varepsilon_0, t, \\tau_L, \\tau_R) = (0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 1.0\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV})$。\n- 情况 2（近能带边缘）：$(E, \\varepsilon_\\mathrm{d}, \\varepsilon_0, t, \\tau_L, \\tau_R) = (1.8\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 1.0\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV})$。\n- 情况 3（更近能带边缘）：$(E, \\varepsilon_\\mathrm{d}, \\varepsilon_0, t, \\tau_L, \\tau_R) = (1.95\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 1.0\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV})$。\n- 情况 4（趋近 van Hove 奇点）：$(E, \\varepsilon_\\mathrm{d}, \\varepsilon_0, t, \\tau_L, \\tau_R) = (1.999\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 1.0\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV})$。\n- 情况 5（带外）：$(E, \\varepsilon_\\mathrm{d}, \\varepsilon_0, t, \\tau_L, \\tau_R) = (2.1\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 1.0\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV})$。\n- 情况 6（零耦合边界）：$(E, \\varepsilon_\\mathrm{d}, \\varepsilon_0, t, \\tau_L, \\tau_R) = (0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 1.0\\,\\mathrm{eV}, 0.0\\,\\mathrm{eV}, 0.5\\,\\mathrm{eV})$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots,r_6]$），其中每个 $r_i$ 是对应情况的 $\\Delta(E)$ 的浮点值。所有能量和耦合必须以 $\\mathrm{eV}$ 为单位，计算出的透射是无量纲的。本问题不涉及角度。", "solution": "所提出的问题是计算材料科学领域一个有效且适定的练习，具体涉及在非平衡格林函数 (NEGF) 形式主义框架下建模的单点电子器件的量子输运。它要求推导并比较使用精确导线自能与使用宽带极限近似的透射函数。所有提供的参数和定义都是标准的、科学上合理的且自洽的。因此，我们开始进行求解。\n\n首要任务是为一个由哈密顿量 $H_\\mathrm{d} = [\\varepsilon_\\mathrm{d}]$ 描述、耦合到两条半无限一维紧束缚导线的单能级量子点推导其透射函数 $T(E)$。该求解过程包含几个关键步骤：推导导线属性、构建器件的格林函数，然后计算透射。\n\n**1. 一维紧束缚导线的表面格林函数**\n\n一个从格点 $n=0$ 索引到无穷远的半无限一维紧束缚导线，由一个具有在位能 $\\varepsilon_0$ 和最近邻跃迁 $t$ 的哈密顿量描述。需要求解推迟格林函数 $g^r(E) = [(E+i\\eta)I - H_\\mathrm{lead}]^{-1}$（其中 $\\eta \\to 0^+$）。与导线末端格点对应的矩阵元 $g^r_{00}(E)$ 被称为表面格林函数，我们将其表示为 $g^r_{surf}(E)$。\n\n该矩阵元可以通过递归论证求得。格点 $0$ 处的格林函数可以通过戴森方程表示，其中自能项解释了与链上其余部分（格点 $n=1, 2, \\dots$）的耦合：\n$$g^r_{surf}(E) = \\left( E+i\\eta - \\varepsilon_0 - t \\cdot g^r_{surf}(E) \\cdot t \\right)^{-1}$$\n此处，我们利用了这样一个事实：连接到从格点 $1$ 开始的子链的自能是 $t^2 g^r_{surf}(E)$，因为该子链在结构上与原始的半无限链相同。令 $g = g^r_{surf}(E)$ 和 $z = E - \\varepsilon_0 + i\\eta$，方程变为：\n$$t^2 g^2 - z g + 1 = 0$$\n这个关于 $g$ 的二次方程有两个解：\n$$g = \\frac{z \\pm \\sqrt{z^2 - 4t^2}}{2t^2}$$\n为了选择物理上正确的根，我们要求格林函数代表一个进入导线的出射波或衰减波，这对应于当 $\\mathrm{Im}(E) \\to \\infty$ 时衰减的解。这个条件由负号满足。因此，精确的表面格林函数是：\n$$g^r_{surf}(E) = \\frac{(E - \\varepsilon_0) - \\sqrt{(E - \\varepsilon_0)^2 - 4t^2}}{2t^2}$$\n在此表达式中，平方根的分支被选择为使其虚部为负，这与能量 $E$ 中的小正虚部 $i\\eta$ 一致。\n\n**2. 导线自能和展宽函数**\n\n导线 $\\alpha \\in \\{L, R\\}$ 通过跃迁振幅 $\\tau_\\alpha$ 与器件耦合。描述导线对器件影响的推迟自能 $\\Sigma^r_\\alpha(E)$ 由下式给出：\n$$\\Sigma^r_\\alpha(E) = \\tau_\\alpha^2 g^r_{surf}(E) = \\frac{\\tau_\\alpha^2}{2t^2} \\left[ (E - \\varepsilon_0) - \\sqrt{(E - \\varepsilon_0)^2 - 4t^2} \\right]$$\n展宽（或耦合）函数 $\\Gamma_\\alpha(E)$ 通过 $\\Gamma_\\alpha(E) = i[\\Sigma^r_\\alpha(E) - \\Sigma^a_\\alpha(E)]$ 与自能相关。由于超前自能是推迟自能的厄米共轭，即 $\\Sigma^a_\\alpha(E) = (\\Sigma^r_\\alpha(E))^*$，这可简化为：\n$$\\Gamma_\\alpha(E) = -2 \\mathrm{Im}[\\Sigma^r_\\alpha(E)]$$\n$\\Gamma_\\alpha(E)$ 的行为取决于能量 $E$ 是否落在导线的导带内，该导带范围从 $\\varepsilon_0 - 2|t|$到 $\\varepsilon_0 + 2|t|$。\n\n- **带内 ($|E - \\varepsilon_0|  2|t|$):** 项 $(E - \\varepsilon_0)^2 - 4t^2$ 为负。平方根是纯虚数：$\\sqrt{(E - \\varepsilon_0)^2 - 4t^2} = \\pm i\\sqrt{4t^2 - (E - \\varepsilon_0)^2}$。正确的物理根给出了一个负的 $\\Sigma^r_\\alpha(E)$ 虚部，对应于耗散。\n$$\\Sigma^r_\\alpha(E) = \\frac{\\tau_\\alpha^2}{2t^2} \\left[ (E - \\varepsilon_0) - i\\sqrt{4t^2 - (E - \\varepsilon_0)^2} \\right]$$\n虚部为 $\\mathrm{Im}[\\Sigma^r_\\alpha(E)] = -\\frac{\\tau_\\alpha^2}{2t^2}\\sqrt{4t^2 - (E - \\varepsilon_0)^2}$。因此展宽为：\n$$\\Gamma_\\alpha(E) = \\frac{\\tau_\\alpha^2}{t^2}\\sqrt{4t^2 - (E - \\varepsilon_0)^2}$$\n- **带外 ($|E - \\varepsilon_0| > 2|t|$):** 平方根项为实数。在 $\\eta \\to 0^+$ 的极限下，$\\Sigma^r_\\alpha(E)$ 的虚部为零。因此，$\\Gamma_\\alpha(E) = 0$，表明在这些能量下，导线中没有可用于输运的态。\n\n**3. 透射函数：精确 vs. 宽带极限**\n\n单点器件的总推迟格林函数为：\n$$G^r(E) = \\left[ E - \\varepsilon_\\mathrm{d} - \\Sigma^r_L(E) - \\Sigma^r_R(E) \\right]^{-1}$$\n根据 NEGF 框架中的 Landauer-Büttiker 公式，透射函数由下式给出：\n$$T(E) = \\mathrm{Tr}\\left[\\Gamma_L(E) G^r(E) \\Gamma_R(E) G^a(E)\\right]$$\n对于单点器件，这是一个标量表达式，其中 $G^a(E) = (G^r(E))^*$：\n$$T(E) = \\Gamma_L(E) \\Gamma_R(E) |G^r(E)|^2$$\n\n**A. 精确透射，$T_\\mathrm{exact}(E)$**\n为了计算精确透射，我们使用上面推导出的依赖于能量的 $\\Sigma^r_\\alpha(E)$ 和 $\\Gamma_\\alpha(E)$ 表达式。透射仅在导线能带内非零。\n\n**B. 宽带极限 (WBL) 透射，$T_\\mathrm{WBL}(E)$**\nWBL 近似通过假设导线展宽在感兴趣的能量范围内是恒定的来简化问题。依赖于能量的自能 $\\Sigma^r_\\alpha(E)$ 被一个纯虚常数所取代：\n$$\\Sigma^r_\\alpha(E) \\approx \\Sigma^r_{\\alpha, \\mathrm{WBL}} = -i\\frac{\\Gamma_{\\alpha,0}}{2}$$\n其中 $\\Gamma_{\\alpha,0}$ 是在参考能量 $E_0$ 处计算的精确展宽函数的值。问题指定 $E_0 = 0\\,\\mathrm{eV}$。对于给定的导线参数 $\\varepsilon_0 = 0\\,\\mathrm{eV}$ 和 $t=1.0\\,\\mathrm{eV}$，$E_0$ 位于能带中心。\n$$\\Gamma_{\\alpha,0} = \\Gamma_\\alpha(E_0=0) = \\frac{\\tau_\\alpha^2}{t^2}\\sqrt{4t^2 - (0 - 0)^2} = \\frac{2|t|\\tau_\\alpha^2}{t^2} = \\frac{2\\tau_\\alpha^2}{|t|}$$\n在 WBL 下的器件格林函数为：\n$$G^r_\\mathrm{WBL}(E) = \\left[ (E - \\varepsilon_\\mathrm{d}) + i\\frac{\\Gamma_{L,0} + \\Gamma_{R,0}}{2} \\right]^{-1}$$\nWBL 透射则是一个洛伦兹函数：\n$$T_\\mathrm{WBL}(E) = \\frac{\\Gamma_{L,0} \\Gamma_{R,0}}{(E - \\varepsilon_\\mathrm{d})^2 + \\left(\\frac{\\Gamma_{L,0} + \\Gamma_{R,0}}{2}\\right)^2}$$\n值得注意的是，这个近似预测在所有能量下都有非零透射，这是与精确结果的一个关键区别。\n\n**4. 误差度量**\nWBL 近似的误差由度量 $\\Delta(E)$ 量化：\n$$\\Delta(E) = \\frac{\\left|T_\\mathrm{WBL}(E) - T_\\mathrm{exact}(E)\\right|}{\\max\\left(T_\\mathrm{exact}(E), \\epsilon_\\mathrm{reg}\\right)}$$\n正则化常数 $\\epsilon_\\mathrm{reg} = 10^{-12}$ 防止在 $T_\\mathrm{exact}(E)$ 为零的区域（例如导带之外或当导线解耦时）出现除以零的情况。\n\n我们现在将实现这些公式，为指定的测试用例计算 $\\Delta(E)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the error measure Δ(E) for the WBL approximation across several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (E, eps_d, eps_0, t, tau_L, tau_R)\n        (0.0, 0.0, 0.0, 1.0, 0.5, 0.5),   # Case 1: general, band center\n        (1.8, 0.0, 0.0, 1.0, 0.5, 0.5),   # Case 2: near band edge\n        (1.95, 0.0, 0.0, 1.0, 0.5, 0.5),  # Case 3: closer to band edge\n        (1.999, 0.0, 0.0, 1.0, 0.5, 0.5), # Case 4: approaching van Hove singularity\n        (2.1, 0.0, 0.0, 1.0, 0.5, 0.5),   # Case 5: outside the band\n        (0.0, 0.0, 0.0, 1.0, 0.0, 0.5),   # Case 6: zero coupling boundary\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_delta(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_delta(E, eps_d, eps_0, t, tau_L, tau_R):\n    \"\"\"\n    Calculates the error measure Δ(E) for a given set of parameters.\n    \n    Args:\n        E (float): Energy.\n        eps_d (float): Device on-site energy.\n        eps_0 (float): Lead on-site energy.\n        t (float): Lead hopping parameter.\n        tau_L (float): Left lead coupling.\n        tau_R (float): Right lead coupling.\n\n    Returns:\n        float: The calculated error Δ(E).\n    \"\"\"\n    epsilon_reg = 1e-12\n    t_abs = np.abs(t)\n\n    # --- Wide-Band Limit (WBL) Calculation ---\n    # Reference energy for WBL is E0 = 0.0 eV.\n    # The reference energy E0 falls within the band since eps_0=0 and t=1.\n    if t_abs > 0:\n        E0 = 0.0\n        arg_sqrt_wbl = 4 * t**2 - (E0 - eps_0)**2\n        # WBL constant is based on E0 being in the band.\n        if arg_sqrt_wbl >= 0:\n            Gamma_L0 = (tau_L**2 / t**2) * np.sqrt(arg_sqrt_wbl) if t!=0 else 0\n            Gamma_R0 = (tau_R**2 / t**2) * np.sqrt(arg_sqrt_wbl) if t!=0 else 0\n        else: # E0 is outside the band, all WBL couplings are zero.\n            Gamma_L0 = 0.0\n            Gamma_R0 = 0.0\n    else:\n        Gamma_L0 = 0.0\n        Gamma_R0 = 0.0\n\n    Gamma_sum_0 = Gamma_L0 + Gamma_R0\n    denominator_wbl = (E - eps_d)**2 + (Gamma_sum_0 / 2)**2\n    \n    if np.isclose(denominator_wbl, 0.0):\n        # Avoid division by zero, though unlikely for physical parameters.\n        T_wbl = float('inf') if Gamma_L0 * Gamma_R0 != 0 else 0.0\n    else:\n        T_wbl = (Gamma_L0 * Gamma_R0) / denominator_wbl\n    \n    # --- Exact Calculation ---\n    band_half_width = 2 * t_abs\n    is_in_band = np.abs(E - eps_0)  band_half_width\n\n    if not is_in_band or t_abs == 0:\n        T_exact = 0.0\n    else:\n        # Calculate Γ_α(E)\n        arg_sqrt_exact = 4 * t**2 - (E - eps_0)**2\n        Gamma_L = (tau_L**2 / t**2) * np.sqrt(arg_sqrt_exact)\n        Gamma_R = (tau_R**2 / t**2) * np.sqrt(arg_sqrt_exact)\n\n        # Calculate Σ^r_α(E)\n        # Use numpy.lib.scimath.sqrt to handle complex results automatically\n        # for arguments that are negative.\n        sqrt_term_complex = np.lib.scimath.sqrt((E - eps_0)**2 - 4 * t**2)\n        \n        Sigma_r_surf_factor = ((E - eps_0) - sqrt_term_complex) / (2 * t**2)\n        \n        Sigma_r_L = tau_L**2 * Sigma_r_surf_factor\n        Sigma_r_R = tau_R**2 * Sigma_r_surf_factor\n        \n        Sigma_r_total = Sigma_r_L + Sigma_r_R\n\n        # Calculate G^r(E)\n        G_r = 1.0 / (E - eps_d - Sigma_r_total)\n        \n        # Calculate T_exact(E)\n        T_exact = Gamma_L * Gamma_R * np.abs(G_r)**2\n    \n    # --- Error Calculation ---\n    numerator = np.abs(T_wbl - T_exact)\n    denominator = np.maximum(T_exact, epsilon_reg)\n    delta = numerator / denominator\n    \n    return delta\n\nsolve()\n```", "id": "3482922"}, {"introduction": "在掌握了自能等基本概念后，本练习将深入探讨量子输运中的一个基本对称性：微观可逆性。你将通过数值模拟来验证昂萨格-卡西米尔关系 $T_{pq}(B) = T_{qp}(-B)$，该关系描述了在磁场下多端器件的输运特性。更重要的是，通过引入非物理的假设（例如非厄米哈密顿量），你将探索破坏这一关键对称性的条件，从而加深对非平衡格林函数（NEGF）方法理论基础的理解([@problem_id:3482888])。", "problem": "要求您设计并实现一个数值实验，使用非平衡格林函数 (NEGF) 形式来评估多端紧束缚模型器件中相干量子输运的微观可逆性，并探讨由非保守离散化或不对称引线自能实现所引起的偏差。\n\n您必须基于以下固态量子输运的基本原理：\n- 一个开放器件的非平衡格林函数 (NEGF) 推迟格林函数 $G^{r}$ 和超前格林函数 $G^{a}$，由包含引线自能的开放边界哈密顿量的算符逆来定义。\n- 每个半无限长引线对器件哈密顿量贡献一个推迟自能 $\\Sigma_{p}^{r}$，其展宽矩阵为 $\\Gamma_{p} = i \\left(\\Sigma_{p}^{r} - \\left(\\Sigma_{p}^{r}\\right)^{\\dagger}\\right)$。\n- 在能量 $E$ 时，从引线 $q$ 到引线 $p$ 的透射率由 Caroli 公式定义：$T_{pq}(E) = \\mathrm{Tr} \\left[ \\Gamma_{p} G^{r} \\Gamma_{q} G^{a} \\right]$。\n- 对于存在磁场 $B$ 时的无相互作用相干输运，微观可逆性（昂萨格-卡西米尔对称性）指出，在时间反演不变性下，对于所有引线 $p \\neq q$，有 $T_{pq}(B) = T_{qp}(-B)$。\n\n您的任务：\n- 为一个尺寸为 $L_{x} \\times L_{y}$、具有最近邻跃迁的方格器件实现一个相干输运模拟器。使用 Peierls 替代方法，通过每个元胞的无量纲磁通量 $f$（即磁通量子的一个分数）来引入均匀垂直磁场。使用朗道规范，使得 $y$ 方向的跃迁获得一个相位因子 $\\exp\\left(i 2 \\pi f x\\right)$，其中 $x \\in \\{0,1,\\dots,L_{x}-1\\}$ 标记沿 $x$ 方向的晶格坐标。\n- 将四个半无限长引线连接到器件的左、右、底、顶边缘。将每个引线建模为一组解耦的半无限长一维链（每个边缘格点一条），其在位能与器件在位能相等，最近邻跃迁与器件跃迁幅度相等。从每个边缘器件格点到其引线的耦合应等于该边缘处缺失的化学键。对于垂直边缘，在界面处的耦合中包含适当的 Peierls 相位，使得耦合振幅为 $v=-t \\exp\\left(\\pm i 2 \\pi f x\\right)$，符号由向外的法线方向决定，但请注意，$\\Sigma_{p}^{r}$ 取决于 $|v|^{2}$，因此在其保守实现中，其对角元与相位无关。\n- 通过求解表面格林函数的二次不动点方程，计算半无限长一维链的推迟和超前表面格林函数，并根据虚部的符号选择推迟或超前分支。在能量上添加一个正无穷小量 $i \\eta$（其中 $\\eta > 0$）来选择出射边界条件。\n- 构建器件的推迟和超前格林函数，并在单一能量 $E$ 下计算所有 $p \\neq q$ 的透射率 $T_{pq}$。\n\n微观可逆性检查：\n- 对于给定的磁通量 $f$ 及其反向 $-f$，计算透射矩阵 $\\{T_{pq}(f)\\}$ 和 $\\{T_{pq}(-f)\\}$，并返回最大绝对偏差\n$$\\Delta(f) = \\max_{p \\neq q} \\left| T_{pq}(f) - T_{qp}(-f) \\right|.$$\n- 一个正确的保守且对称的实现应该得到数值上接近 $0$ 的 $\\Delta(f)$，误差在舍入误差范围内。\n\n偏差实验：\n- 实现两个受控的偏差：\n  1. 一种非保守离散化，通过使用不对称的前向/后向跃迁 $-t$ 和 $-(t+\\delta)$（其中 $\\delta > 0$），使器件哈密顿量沿 $x$ 方向变为非厄米的，同时保持带有 Peierls 相位的 $y$ 方向是保守的。这应该会虚假地违反微观可逆性并增加 $\\Delta(f)$。\n  2. 一种不对称引线自能实现，其中一个选定的引线使用超前（而非推迟）表面格林函数来构建其自能。这种非物理的选择违反了解析性，并应增加 $\\Delta(f)$。\n\n所有运行中使用的数值和物理参数：\n- 晶格尺寸: $L_{x} = L_{y} = 3$。\n- 最近邻跃迁幅度: $t = 1$。\n- 在位能: $u = 0$。\n- 能量: $E = 0$。\n- 无穷小展宽: $\\eta = 1 \\times 10^{-9}$。\n- 磁通量值: $f \\in \\{0, 0.08\\}$。\n- 非保守离散化的不对称参数: $\\delta = 0.1$。\n\n测试套件：\n- 情况 1 (正常路径，有限场): 保守器件及所有引线使用推迟自能，在 $f = 0.08$ 时。\n- 情况 2 (边界情况，零场): 保守器件及所有引线使用推迟自能，在 $f = 0$ 时。\n- 情况 3 (非保守离散化): 具有不对称 $x$ 方向跃迁（$\\delta = 0.1$）的器件，所有引线使用推迟自能，在 $f = 0.08$ 时。\n- 情况 4 (不对称引线自能): 保守器件，但顶部引线使用其表面格林函数的超前分支（其他引线为推迟），在 $f = 0.08$ 时。\n\n计算和输出内容：\n- 对每种情况，计算上面定义的标量 $\\Delta(f)$。您的程序必须生成单行输出，其中包含这四个标量结果，按情况 1 到 4 的顺序排列，以逗号分隔并用方括号括起来，即 $[\\Delta_{1},\\Delta_{2},\\Delta_{3},\\Delta_{4}]$。\n- 所有量均为无量纲；不需要物理单位。\n- 角度（在适用作相位时）根据复指数的构造，以弧度为单位。\n\n约束条件：\n- 不要为最终的微观可逆性属性硬编码任何快捷表达式。您的实现必须从上面所述的推迟和超前格林函数、自能、展宽和透射公式的定义出发。\n- 通过无穷小量 $i \\eta$ 和对表面格林函数根的显式分支选择，确保数值稳定地选择推迟或超前分支。\n\n您的程序应生成单行输出，其中包含用方括号括起来并以逗号分隔的结果（例如，“[result1,result2,result3,result4]”）。", "solution": "The user has provided a problem that requires a numerical simulation of quantum transport in a mesoscopic device using the Non-Equilibrium Green's Function (NEGF) formalism. The core of the problem is to verify the microreversibility principle, $T_{pq}(B) = T_{qp}(-B)$, for a conservative system and to demonstrate its violation under specific non-physical conditions.\n\n### Step 1: Extract Givens\n\n- **System**: A 2D tight-binding model on a square lattice of size $L_x \\times L_y$ with four semi-infinite leads attached to the edges (left, right, bottom, top).\n- **Physical Parameters**:\n    - Lattice size: $L_x = 3, L_y = 3$.\n    - Nearest-neighbor hopping magnitude: $t = 1$.\n    - Onsite energy: $u = 0$.\n    - Energy for transmission calculation: $E = 0$.\n    - Infinitesimal broadening for Green's functions: $\\eta = 1 \\times 10^{-9}$.\n- **Magnetic Field**: A uniform perpendicular magnetic field is included via a Peierls substitution, represented by a dimensionless flux per plaquette, $f$. In the Landau gauge, the hopping integral in the $+y$ direction from a site at horizontal coordinate $x$ acquires a phase factor $\\exp(i 2 \\pi f x)$.\n- **Lead Model**: Each lead consists of decoupled 1D semi-infinite chains attached to each site on the corresponding device edge. The lead onsite energy and hopping match the device parameters.\n- **NEGF Definitions**:\n    - Retarded/Advanced Green's Functions: $G^{r}, G^{a}$.\n    - Lead Self-Energy: $\\Sigma_{p}^{r}$. Calculated from the surface Green's function of a 1D chain.\n    - Broadening Matrix: $\\Gamma_{p} = i \\left(\\Sigma_{p}^{r} - (\\Sigma_{p}^{r})^{\\dagger}\\right)$.\n    - Transmission Formula (Caroli): $T_{pq}(E) = \\mathrm{Tr} \\left[ \\Gamma_{p} G^{r} \\Gamma_{q} G^{a} \\right]$.\n- **Microreversibility Check**: Compute the maximum deviation $\\Delta(f) = \\max_{p \\neq q} \\left| T_{pq}(f) - T_{qp}(-f) \\right|$.\n- **Deviation Scenarios**:\n    1.  **Non-conservative discretization**: Asymmetric hopping in the x-direction with hopping elements $-t$ and $-(t+\\delta)$, where $\\delta = 0.1$. This makes the device Hamiltonian non-Hermitian.\n    2.  **Asymmetric lead self-energy**: For the top lead, the self-energy is constructed using the advanced surface Green's function, $g_s^a$, instead of the retarded one, $g_s^r$.\n- **Test Cases**:\n    1.  Conservative system ($\\delta=0$, all leads retarded), $f = 0.08$.\n    2.  Conservative system ($\\delta=0$, all leads retarded), $f = 0$.\n    3.  Non-conservative system ($\\delta = 0.1$), $f = 0.08$.\n    4.  Asymmetric top lead self-energy, $f = 0.08$.\n- **Output**: A single line containing the four computed $\\Delta$ values, comma-separated and enclosed in brackets: $[\\Delta_1, \\Delta_2, \\Delta_3, \\Delta_4]$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is a standard, well-defined exercise in computational condensed matter physics.\n- **Scientifically Grounded**: The problem is built upon the established NEGF formalism, tight-binding models, and the Peierls substitution for magnetic fields. These are fundamental concepts in solid-state and mesoscopic physics. The deviation experiments are designed to probe the physical assumptions underlying the theory (e.g., hermiticity, causality/analyticity).\n- **Well-Posed**: All necessary parameters ($L_x, L_y, t, u, E, \\eta, f, \\delta$) and definitions are provided. The objective—calculating $\\Delta(f)$ for four distinct cases—is clear and unambiguous. A unique numerical solution exists for each case.\n- **Objective**: The problem is stated in precise, technical language, free from subjectivity or ambiguity.\n\nThe problem passes all validation criteria. It is not scientifically unsound, incomplete, contradictory, unrealistic, or ill-posed. It represents a conceptually sound and computationally tractable problem.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be developed based on the specified principles and parameters.\n\n### Principle-Based Design\n\nThe solution will be structured into a set of functions, each responsible for a distinct physical or computational step, reflecting the structure of the NEGF formalism.\n\n1.  **System and Site Indexing**: The $L_x \\times L_y = 3 \\times 3$ device has $N=9$ sites. A mapping from 2D lattice coordinates $(i_x, i_y)$ to a 1D matrix index $k$ is established using $k = i_y \\cdot L_x + i_x$.\n\n2.  **Surface Green's Function**: The self-energy of the semi-infinite leads requires the surface Green's function, $g_s$, of a 1D tight-binding chain. This is found by solving the quadratic equation $t^2 g_s^2 - (E - u + i\\eta) g_s + 1 = 0$. The two roots correspond to the retarded ($g_s^r$, with $\\mathrm{Im}(g_s^r)  0$) and advanced ($g_s^a$, with $\\mathrm{Im}(g_s^a)  0$) branches. A function will solve this equation and return both branches.\n\n3.  **Device Hamiltonian Construction**: An $N \\times N$ matrix $H$ is constructed.\n    - **Hopping in x-direction**: For a conservative device ($\\delta=0$), hopping between adjacent sites is $-t$. For the non-conservative case, the hopping from $x$ to $x+1$ is $-(t+\\delta)$ and from $x+1$ to $x$ is $-t$, resulting in a non-Hermitian matrix $H \\neq H^{\\dagger}$.\n    - **Hopping in y-direction**: Hopping from $(i_x, i_y)$ to $(i_x, i_y+1)$ includes the Peierls phase factor, giving a matrix element $-t \\exp(i 2\\pi f i_x)$. The conjugate element ensures this part of the Hamiltonian is Hermitian. The property $H(-f) = H(f)^T$ is crucial for microreversibility.\n\n4.  **Lead Self-Energies**: Four $N \\times N$ self-energy matrices, $\\Sigma_p$, are constructed ($p \\in \\{0,1,2,3\\}$ for left, right, bottom, top). Each is diagonal in the site basis. For a site $k$ at an edge, the self-energy is $\\Sigma_{p,kk} = |v|^2 g_s$, where $|v|^2=t^2$ is the squared coupling strength and $g_s$ is the surface Green's function.\n    - In standard cases, $g_s = g_s^r$.\n    - In Case 4, for the top lead ($p=3$), $g_s=g_s^a$ is used, which violates the analyticity requirement for a retarded self-energy.\n\n5.  **Device Green's Functions**:\n    - The retarded Green's function is computed via matrix inversion: $G^r = [ (E+i\\eta)I - H - \\sum_p \\Sigma_p ]^{-1}$.\n    - The advanced Green's function is its Hermitian conjugate: $G^a = (G^r)^{\\dagger}$. This relation holds by definition and correctly propagates the consequences of any non-physicality in $H$ or $\\Sigma$.\n\n6.  **Broadening and Transmission**:\n    - The broadening matrices are computed using their definition: $\\Gamma_p = i(\\Sigma_p - \\Sigma_p^{\\dagger})$. For a standard retarded self-energy, $\\Gamma_p$ is positive semi-definite. For the unphysical self-energy in Case 4, the corresponding $\\Gamma_3$ becomes negative-definite, representing an unphysical gain of particles.\n    - The transmission $T_{pq}$ is calculated using the Caroli formula, $T_{pq} = \\mathrm{Tr}(\\Gamma_p G^r \\Gamma_q G^a)$. The trace operation yields a real-valued transmission probability.\n\n7.  **Microreversibility Check**: The entire calculation is performed for a given flux $f$ and its reversal $-f$ to obtain the transmission matrices $\\{T_{pq}(f)\\}$ and $\\{T_{pq}(-f)\\}$. The final deviation $\\Delta(f)$ is found by taking the maximum absolute difference $|T_{pq}(f) - T_{qp}(-f)|$ over all pairs of distinct leads $p \\neq q$.\n\nThis step-by-step implementation directly translates the physical definitions from the problem statement into a numerical algorithm, ensuring no shortcuts are taken and the core physics is explicitly modeled. For the \"happy path\" cases (1 and 2), $\\Delta(f)$ is expected to be near machine precision. For the deviation cases (3 and 4), violations of hermiticity or analyticity break the underlying symmetries, leading to a numerically significant, non-zero $\\Delta(f)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Main function to run the NEGF simulation for the four test cases\n    and check microreversibility.\n    \"\"\"\n\n    # --- Physical and numerical parameters from the problem statement ---\n    LX, LY = 3, 3\n    T_HOP = 1.0\n    U_ONSITE = 0.0\n    E_ENERGY = 0.0\n    ETA = 1e-9\n    DELTA = 0.1\n    FLUX_VALUES = {'case1': 0.08, 'case2': 0.0, 'case3': 0.08, 'case4': 0.08}\n\n    def get_surface_green_function(t_hop, E, u, eta):\n        \"\"\"\n        Solves the quadratic equation for the 1D semi-infinite lead's \n        surface Green's function (g_s).\n        \n        The equation is t_hop^2 * g_s^2 - (E - u + i*eta) * g_s + 1 = 0.\n        \n        Returns:\n            (g_r, g_a): Retarded (Im  0) and advanced (Im > 0) solutions.\n        \"\"\"\n        complex_E = E - u + 1j * eta\n        \n        # Coefficients of the quadratic equation a*x^2 + b*x + c = 0\n        a = t_hop**2\n        b = -complex_E\n        c = 1.0\n        \n        discriminant_sqrt = np.sqrt(b**2 - 4 * a * c, dtype=np.complex128)\n        \n        g1 = (-b + discriminant_sqrt) / (2 * a)\n        g2 = (-b - discriminant_sqrt) / (2 * a)\n        \n        # The retarded branch has a negative imaginary part, advanced has a positive one.\n        g_r = g1 if g1.imag  0 else g2\n        g_a = g1 if g1.imag > 0 else g2\n        \n        return g_r, g_a\n\n    def build_hamiltonian(Lx, Ly, t_hop, f, delta):\n        \"\"\"\n        Builds the device Hamiltonian matrix H for a given flux f.\n        The parameter delta introduces non-Hermitian x-hopping if non-zero.\n        \"\"\"\n        N = Lx * Ly\n        H = np.zeros((N, N), dtype=np.complex128)\n        \n        for iy in range(Ly):\n            for ix in range(Lx):\n                k = iy * Lx + ix\n                \n                # Hopping in x-direction (to the right neighbor)\n                if ix  Lx - 1:\n                    k_right = k + 1\n                    H[k, k_right] = -(t_hop + delta)  # Asymmetric hopping\n                    H[k_right, k] = -t_hop\n                \n                # Hopping in y-direction (to the top neighbor) with Peierls phase\n                if iy  Ly - 1:\n                    k_up = k + Lx\n                    phase = np.exp(1j * 2 * np.pi * f * ix)\n                    H[k, k_up] = -t_hop * phase\n                    H[k_up, k] = -t_hop * np.conj(phase)\n        return H\n\n    def build_self_energies(Lx, Ly, t_hop, E, u, eta, asymmetric_lead_idx):\n        \"\"\"\n        Builds the self-energy matrices for the 4 leads.\n        Leads indexed as 0:left, 1:right, 2:bottom, 3:top.\n        If asymmetric_lead_idx is specified, that lead uses g_s^a instead of g_s^r.\n        \"\"\"\n        N = Lx * Ly\n        g_r, g_a = get_surface_green_function(t_hop, E, u, eta)\n        \n        sigmas = [np.zeros((N, N), dtype=np.complex128) for _ in range(4)]\n        v_sq = t_hop**2\n        \n        # Determine which surface Green's function to use for each lead\n        g_s_choices = [g_r] * 4\n        if asymmetric_lead_idx != -1:\n            g_s_choices[asymmetric_lead_idx] = g_a\n\n        # Lead 0 (left edge, x=0)\n        for iy in range(Ly):\n            k = iy * Lx + 0\n            sigmas[0][k, k] = v_sq * g_s_choices[0]\n            \n        # Lead 1 (right edge, x=Lx-1)\n        for iy in range(Ly):\n            k = iy * Lx + (Lx - 1)\n            sigmas[1][k, k] = v_sq * g_s_choices[1]\n            \n        # Lead 2 (bottom edge, y=0)\n        for ix in range(Lx):\n            k = 0 * Lx + ix\n            sigmas[2][k, k] = v_sq * g_s_choices[2]\n            \n        # Lead 3 (top edge, y=Ly-1)\n        for ix in range(Ly):\n            k = (Ly - 1) * Lx + ix\n            sigmas[3][k, k] = v_sq * g_s_choices[3]\n            \n        return sigmas\n\n    def compute_transmission_matrix(f, delta, asymmetric_lead_idx):\n        \"\"\"\n        Computes the full transmission matrix T_pq for a given set of parameters.\n        \"\"\"\n        N = LX * LY\n        \n        H = build_hamiltonian(LX, LY, T_HOP, f, delta)\n        \n        sigmas = build_self_energies(LX, LY, T_HOP, E_ENERGY, U_ONSITE, ETA, asymmetric_lead_idx)\n        sigma_total = sum(sigmas)\n        \n        # Retarded Green's function\n        complex_E = E_ENERGY - U_ONSITE + 1j * ETA\n        G_r = inv(complex_E * np.identity(N) - H - sigma_total)\n        \n        # Advanced Green's function\n        G_a = G_r.conj().T\n        \n        # Broadening matrices\n        gammas = [1j * (s - s.conj().T) for s in sigmas]\n        \n        # Transmission T_pq = Tr(Gamma_p * G_r * Gamma_q * G_a)\n        num_leads = 4\n        T_matrix = np.zeros((num_leads, num_leads))\n        for p in range(num_leads):\n            for q in range(num_leads):\n                if p != q:\n                    # Use @ for matrix multiplication\n                    prod = gammas[p] @ G_r @ gammas[q] @ G_a\n                    T_matrix[p, q] = np.trace(prod).real\n        return T_matrix\n\n    def calculate_delta(f, delta, asymmetric_lead_idx):\n        \"\"\"\n        Calculates the microreversibility deviation Delta(f).\n        \"\"\"\n        T_f_pos = compute_transmission_matrix(f, delta, asymmetric_lead_idx)\n        T_f_neg = compute_transmission_matrix(-f, delta, asymmetric_lead_idx)\n        \n        max_dev = 0.0\n        num_leads = 4\n        for p in range(num_leads):\n            for q in range(num_leads):\n                if p != q:\n                    dev = np.abs(T_f_pos[p, q] - T_f_neg[q, p])\n                    if dev > max_dev:\n                        max_dev = dev\n        return max_dev\n\n    # --- Define and run test cases ---\n    test_cases = [\n        # Case 1 (happy path, finite field): conservative, f = 0.08\n        {'f': FLUX_VALUES['case1'], 'delta': 0.0, 'asym_idx': -1},\n        # Case 2 (boundary, zero field): conservative, f = 0\n        {'f': FLUX_VALUES['case2'], 'delta': 0.0, 'asym_idx': -1},\n        # Case 3 (non-conservative discretization): asymmetric hopping, f = 0.08\n        {'f': FLUX_VALUES['case3'], 'delta': DELTA, 'asym_idx': -1},\n        # Case 4 (asymmetric lead self-energy): top lead uses g_s^a, f = 0.08\n        {'f': FLUX_VALUES['case4'], 'delta': 0.0, 'asym_idx': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_val = calculate_delta(case['f'], case['delta'], case['asym_idx'])\n        results.append(delta_val)\n\n    # --- Final print statement in the exact required format ---\n    # Using scientific notation to handle both small and large values consistently.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3482888"}]}