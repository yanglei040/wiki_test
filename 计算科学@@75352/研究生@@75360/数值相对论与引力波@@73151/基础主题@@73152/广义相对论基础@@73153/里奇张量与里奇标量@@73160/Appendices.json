{"hands_on_practices": [{"introduction": "本实践将曲率的几何定义与广义相对论的物理约束联系起来。您将使用两种不同的方法，在弗里德曼-勒梅特-罗伯逊-沃尔克 (Friedmann-Lemaître-Robertson-Walker, FLRW) 时空切片上计算空间里奇标量 $R^{(3)}$：第一种方法是直接从度规通过其克里斯托费尔符号 (Christoffel symbols) 计算，第二种方法是通过阿诺维特-德泽尔-米斯纳 (Arnowitt-Deser-Misner, ADM) 哈密顿约束间接计算，该约束将曲率与物理能量密度和外部曲率联系起来。比较这两种途径的结果是数值相对论初始数据的一个基本验证测试，以确保所构建的几何结构在物理上是自洽的 [@problem_id:3494863]。", "problem": "给定一个空间均匀且各向同性的初始数据集，该数据集与广义相对论 (GR) 在几何化单位制 ($G=c=1$) 下的 Arnowitt–Deser–Misner (ADM) 分解相符。考虑 Friedmann–Lemaître–Robertson–Walker (FLRW) 几何在球坐标 $(r,\\theta,\\phi)$（其中角度以弧度为单位）下的单个时间切片 $t=\\text{const}$。该切片上的空间度规为\n$$\n\\gamma_{ij}\\,dx^i dx^j = a^2\\left(\\frac{dr^2}{1-k r^2} + r^2\\,d\\theta^2 + r^2 \\sin^2\\theta\\, d\\phi^2\\right),\n$$\n其中曲率参数 $k\\in\\{-1,0,+1\\}$，标度因子 $a0$。对于共动切片，外在曲率由下式指定\n$$\nK_{ij} = -H\\,\\gamma_{ij},\n$$\n其中 $H=\\dot a/a$ 是该切片上的哈勃参数。假设真空宇宙学常数，且没有显式的宇宙学常数项。\n\n你的任务是通过两种独立的途径计算切片上单点 $(r_0,\\theta_0)$ 处的空间里奇标量 $R^{(3)}$，然后报告每个测试案例下两种结果之间的绝对差。\n\n途径 (i)：收缩的克里斯托费尔符号途径。\n- 使用三维里奇张量的定义，\n$$\nR_{ij}=\\partial_k \\Gamma^k_{\\;ij} - \\partial_j \\Gamma^k_{\\;ik} + \\Gamma^k_{\\;ij}\\Gamma^\\ell_{\\;k\\ell} - \\Gamma^k_{\\;i\\ell}\\Gamma^\\ell_{\\;jk},\n$$\n以及 $R^{(3)}=\\gamma^{ij}R_{ij}$，其中 $\\Gamma^i_{\\;jk}$ 是由 $\\gamma_{ij}$ 及其一阶导数构建的克里斯托费尔符号。所有索引 $i,j,k,\\ell$ 的取值范围为空间坐标 $\\{r,\\theta,\\phi\\}$。\n- 根据克里斯托费尔符号由 $\\gamma_{ij}$ 及其一阶导数定义的公式来实现它。\n- 对于 $\\partial_k \\Gamma^k_{\\;ij}$，使用与上标索引 $k$ 对应的坐标方向对齐的中心有限差分。也就是说，在 $(r_0,\\theta_0)$ 处计算 $\\partial_r \\Gamma^r_{\\;ij}$ 时使用关于 $r$ 的中心差分，计算 $\\partial_\\theta \\Gamma^\\theta_{\\;ij}$ 时使用关于 $\\theta$ 的中心差分，而 $\\partial_\\phi \\Gamma^\\phi_{\\;ij}=0$ 因为 $\\gamma_{ij}$ 不依赖于 $\\phi$。类似地，计算 $\\partial_j \\Gamma^k_{\\;ik}$ 时使用坐标方向 $x^j$ 上的中心有限差分；对于 $j=\\phi$，导数为零。\n- 使用以下中心差分步长：$\\Delta r = 10^{-5}$ 和 $\\Delta \\theta = 10^{-5}$ (弧度)。对于该度规，所有关于 $\\phi$ 的导数恒为零。\n\n途径 (ii)：ADM 哈密顿约束途径。\n- 使用三加一形式的哈密顿约束，\n$$\nR^{(3)} = 16\\pi \\rho + K_{ij}K^{ij} - K^2,\n$$\n其中 $\\rho$ 是由法向观测者测量的能量密度，$K=\\gamma^{ij}K_{ij}$，$K^{ij}=\\gamma^{ik}\\gamma^{j\\ell}K_{k\\ell}$。\n\n测试套件和输入。对于每个测试案例，你将获得 $(k,a,H,\\rho,r_0,\\theta_0)$，并且必须使用上述两种途径计算在 $(r_0,\\theta_0)$ 处的绝对差\n$$\n\\Delta \\equiv \\left|R^{(3)}_{\\text{Christoffel}} - R^{(3)}_{\\text{ADM}}\\right|\n$$\n。\n\n- 案例 A (理想情况，闭合切片): $(k,a,H,\\rho,r_0,\\theta_0)=(+1,\\,1.4,\\,0.8,\\,\\frac{3}{8\\pi}\\left(H^2+\\frac{k}{a^2}\\right),\\,0.2,\\,1.0)$。\n- 案例 B (平直切片，非零膨胀): $(k,a,H,\\rho,r_0,\\theta_0)=(0,\\,2.0,\\,0.3,\\,\\frac{3}{8\\pi}H^2,\\,0.2,\\,0.3)$。\n- 案例 C (开放切片): $(k,a,H,\\rho,r_0,\\theta_0)=(-1,\\,0.9,\\,1.3,\\,\\frac{3}{8\\pi}\\left(H^2+\\frac{k}{a^2}\\right),\\,0.7,\\,1.2)$。\n- 案例 D (闵可夫斯基切片): $(k,a,H,\\rho,r_0,\\theta_0)=(0,\\,1.0,\\,0.0,\\,0.0,\\,0.33,\\,1.1)$。\n\n所有角度均以弧度为单位。所有量均使用几何化单位制，其中 $G=c=1$。\n\n程序要求。\n- 你的程序必须精确地按照规定实现这两种途径，并为四个案例中的每一个计算 $\\Delta$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与案例 A、B、C、D 的顺序相同，即该行必须是如下形式\n$$\n[\\Delta_A,\\Delta_B,\\Delta_C,\\Delta_D].\n$$\n- 每个 $\\Delta$ 必须作为浮点数输出。", "solution": "用户提供了一个数值相对论和引力波领域的问题，具体涉及在 Friedmann–Lemaître–Robertson–Walker (FLRW) 时空的空间切片上计算里奇标量。该问题需要通过两种不同的方法解决，并报告它们结果的绝对差。\n\n### 第一步：问题验证\n\n我将首先根据指定标准验证问题陈述。\n\n**提取的已知条件：**\n1.  **度规张量**：在恒定时间切片上的空间度规 $\\gamma_{ij}$ 由下式给出\n    $$ \\gamma_{ij}\\,dx^i dx^j = a^2\\left(\\frac{dr^2}{1-k r^2} + r^2\\,d\\theta^2 + r^2 \\sin^2\\theta\\, d\\phi^2\\right) $$\n    其中曲率参数 $k\\in\\{-1,0,+1\\}$，标度因子 $a0$。\n2.  **外在曲率**：外在曲率为 $K_{ij} = -H\\,\\gamma_{ij}$，其中 $H=\\dot a/a$。\n3.  **单位和常数**：使用几何化单位制，其中 $G=c=1$。\n4.  **途径 (i) - 克里斯托费尔符号法**：使用里奇张量根据克里斯托费尔符号及其导数的定义来计算空间里奇标量 $R^{(3)}$，然后与逆度规 $\\gamma^{ij}$ 进行收缩。\n    $$ R_{ij}=\\partial_k \\Gamma^k_{\\;ij} - \\partial_j \\Gamma^k_{\\;ik} + \\Gamma^k_{\\;ij}\\Gamma^\\ell_{\\;k\\ell} - \\Gamma^k_{\\;i\\ell}\\Gamma^\\ell_{\\;jk} $$\n    $$ R^{(3)} = \\gamma^{ij}R_{ij} $$\n    克里斯托费尔符号 $\\Gamma^i_{\\;jk}$ 的导数需要使用中心有限差分进行数值计算，步长为 $\\Delta r = 10^{-5}$ 和 $\\Delta \\theta = 10^{-5}$。\n5.  **途径 (ii) - ADM 约束法**：使用 ADM 哈密顿约束计算 $R^{(3)}$：\n    $$ R^{(3)} = 16\\pi \\rho + K_{ij}K^{ij} - K^2 $$\n    其中 $K=\\gamma^{ij}K_{ij}$ 且 $K^{ij}=\\gamma^{ik}\\gamma^{j\\ell}K_{k\\ell}$。\n6.  **测试案例**：提供了四组参数 $(k, a, H, \\rho, r_0, \\theta_0)$。\n    - 案例 A: $(+1, 1.4, 0.8, \\dots, 0.2, 1.0)$\n    - 案例 B: $(0, 2.0, 0.3, \\dots, 0.2, 0.3)$\n    - 案例 C: $(-1, 0.9, 1.3, \\dots, 0.7, 1.2)$\n    - 案例 D: $(0, 1.0, 0.0, \\dots, 0.33, 1.1)$\n    能量密度 $\\rho$ 被指定为与弗里德曼方程一致：$\\rho = \\frac{3}{8\\pi}(H^2 + k/a^2)$。\n7.  **任务**：为每个案例计算绝对差 $\\Delta = \\left|R^{(3)}_{\\text{Christoffel}} - R^{(3)}_{\\text{ADM}}\\right|$。\n\n**验证结论：**\n-   **科学上可靠**：该问题是在广义相对论的标准 Arnowitt–Deser–Misner (ADM) 框架内提出的，并使用了公认的 FLRW 度规。里奇张量、克里斯托费尔符号和哈密顿约束的方程都是基础且表述正确的。测试案例的初始数据被构造成满足弗里德曼方程，确保了自洽性。该问题在科学上是合理的。\n-   **适定性**：该问题是适定的。它要求遵循规定的算法（有限差分）进行数值计算，并与解析结果进行比较。对于给定的输入和指定的数值方法，存在一个唯一的、稳定的、有意义的结果（即数值误差）。\n-   **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n-   **其他缺陷**：该问题不是不完整、矛盾、不切实际、不适定、微不足道或无法验证的。这些计算并非无足轻重，是数值相对论中标准的验证测试。\n\n该问题被认定为**有效**。\n\n### 第二步：解决方案设计\n\n解决方案将分两部分实现，对应于指定的两种途径。\n\n**途径 (ii)：ADM 哈密顿约束**\n此途径提供了分析的`基准真相`。哈密顿约束为 $R^{(3)} = 16\\pi\\rho + K_{ij}K^{ij} - K^2$。\n给定 $K_{ij} = -H\\gamma_{ij}$，我们可以计算不变量：\n-   $K = \\gamma^{ij}K_{ij} = \\gamma^{ij}(-H\\gamma_{ij}) = -H\\delta^i_i = -3H$。\n-   $K_{ij}K^{ij} = (-H\\gamma_{ij})(-H\\gamma^{ij}) = H^2\\gamma_{ij}\\gamma^{ij} = H^2\\delta^i_i = 3H^2$。\n将这些代入约束方程得到：\n$R^{(3)} = 16\\pi\\rho + 3H^2 - (-3H)^2 = 16\\pi\\rho - 6H^2$。\n问题陈述初始数据是一致的，意味着弗里德曼方程成立：$H^2 = \\frac{8\\pi G}{3}\\rho - \\frac{k c^2}{a^2}$。在几何化单位制（$G=c=1$）中，即为 $H^2 = \\frac{8\\pi}{3}\\rho - \\frac{k}{a^2}$。\n整理得到 $16\\pi\\rho$ 的表达式：$16\\pi\\rho = 6H^2 + \\frac{6k}{a^2}$。\n将此代入 $R^{(3)}$ 的表达式中：\n$R^{(3)} = \\left(6H^2 + \\frac{6k}{a^2}\\right) - 6H^2 = \\frac{6k}{a^2}$。\n这是 FLRW 切片空间里奇标量的著名结果。它在切片上处处为常数。这个解析结果，$R^{(3)}_{\\text{ADM}} = 6k/a^2$，将被用作基准。\n\n**途径 (i)：克里斯托费尔符号法**\n此途径需要进行数值计算。里奇标量 $R^{(3)} = \\gamma^{ij}R_{ij}$ 是从里奇张量 $R_{ij}$ 计算得出的，而里奇张量又是由克里斯托费尔符号 $\\Gamma^i_{\\;jk}$ 及其导数计算得出。\n\n1.  **度规及其逆**：$\\gamma_{ij}$ 和 $\\gamma^{ij}$ 的非零分量为：\n    $\\gamma_{rr} = \\frac{a^2}{1-kr^2}$, $\\gamma_{\\theta\\theta} = a^2r^2$, $\\gamma_{\\phi\\phi} = a^2r^2\\sin^2\\theta$。\n    $\\gamma^{rr} = \\frac{1-kr^2}{a^2}$, $\\gamma^{\\theta\\theta} = \\frac{1}{a^2r^2}$, $\\gamma^{\\phi\\phi} = \\frac{1}{a^2r^2\\sin^2\\theta}$。\n2.  **克里斯托费尔符号**：克里斯托费尔符号 $\\Gamma^i_{\\;jk} = \\frac{1}{2}\\gamma^{im}(\\partial_j\\gamma_{mk} + \\partial_k\\gamma_{mj} - \\partial_m\\gamma_{jk})$ 是解析计算的。非零分量是：\n    - $\\Gamma^r_{rr} = \\frac{kr}{1-kr^2}$\n    - $\\Gamma^r_{\\theta\\theta} = -r(1-kr^2)$\n    - $\\Gamma^r_{\\phi\\phi} = -r(1-kr^2)\\sin^2\\theta$\n    - $\\Gamma^\\theta_{r\\theta} = \\Gamma^\\theta_{\\theta r} = \\frac{1}{r}$\n    - $\\Gamma^\\theta_{\\phi\\phi} = -\\sin\\theta\\cos\\theta$\n    - $\\Gamma^\\phi_{r\\phi} = \\Gamma^\\phi_{\\phi r} = \\frac{1}{r}$\n    - $\\Gamma^\\phi_{\\theta\\phi} = \\Gamma^\\phi_{\\phi\\theta} = \\cot\\theta$\n3.  **里奇张量**：$R_{ij}$ 的分量使用以下公式计算：\n    $$ R_{ij}=\\partial_k \\Gamma^k_{\\;ij} - \\partial_j \\Gamma^k_{\\;ik} + \\Gamma^k_{\\;ij}\\Gamma^\\ell_{\\;k\\ell} - \\Gamma^k_{\\;i\\ell}\\Gamma^\\ell_{\\;jk} $$\n    导数项将使用二阶中心有限差分进行数值计算，步长为指定的 $\\Delta r = 10^{-5}$ 和 $\\Delta \\theta = 10^{-5}$。对于函数 $f(r,\\theta)$：\n    - $\\partial_r f \\approx \\frac{f(r+\\Delta r, \\theta) - f(r-\\Delta r, \\theta)}{2\\Delta r}$\n    - $\\partial_\\theta f \\approx \\frac{f(r, \\theta+\\Delta\\theta) - f(r, \\theta-\\Delta\\theta)}{2\\Delta\\theta}$\n    问题指定第一项中的导数 $\\partial_k$ 和第二项中的 $\\partial_j$ 是相对于相应坐标索引进行的。由于度规不依赖于 $\\phi$，因此关于 $\\phi$ 的导数为零。\n4.  **里奇标量**：由于度规是对角的，里奇标量是和 $R^{(3)} = \\gamma^{rr}R_{rr} + \\gamma^{\\theta\\theta}R_{\\theta\\theta} + \\gamma^{\\phi\\phi}R_{\\phi\\phi}$。这意味着只需要计算里奇张量的对角分量。\n\n最终的程序将为每个测试案例实现这些步骤，计算绝对差 $\\Delta = |R^{(3)}_{\\text{Christoffel}} - R^{(3)}_{\\text{ADM}}|$，并以所需格式打印结果。差值 $\\Delta$ 量化了有限差分近似的数值误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spatial Ricci scalar R^(3) for an FLRW metric slice\n    by two routes: the ADM Hamiltonian constraint and a direct numerical\n    calculation from Christoffel symbols. It then reports the absolute\n    difference between the two results for a suite of test cases.\n    \"\"\"\n\n    # Define the step sizes for finite differences as per the problem statement.\n    h_r = 1e-5\n    h_theta = 1e-5\n\n    # Define test cases: (k, a, H, r0, theta0)\n    test_cases_params = [\n        (1.0, 1.4, 0.8, 0.2, 1.0),    # Case A\n        (0.0, 2.0, 0.3, 0.2, 0.3),    # Case B\n        (-1.0, 0.9, 1.3, 0.7, 1.2),   # Case C\n        (0.0, 1.0, 0.0, 0.33, 1.1)    # Case D\n    ]\n\n    results = []\n    \n    for k_curv, a, H, r0, theta0 in test_cases_params:\n        \n        # Route (ii): ADM Hamiltonian constraint route (Analytical)\n        # The combination of the Hamiltonian constraint and the Friedmann equation\n        # for an FLRW universe yields R_spatial = 6*k/a^2.\n        R_adm = 6.0 * k_curv / a**2\n\n        # Route (i): Christoffel symbol and Ricci tensor route (Numerical)\n        def get_inverse_metric(r, theta, k_curv_loc, a_loc):\n            g_inv = np.zeros((3, 3))\n            sin_t = np.sin(theta)\n            # Avoid division by zero, although test points are non-singular.\n            if abs(r)  1e-15 or abs(sin_t)  1e-15:\n                # Should not be reached with given test cases\n                return g_inv\n            \n            g_inv[0, 0] = (1.0 - k_curv_loc * r**2) / a_loc**2\n            g_inv[1, 1] = 1.0 / (a_loc**2 * r**2)\n            g_inv[2, 2] = 1.0 / (a_loc**2 * r**2 * sin_t**2)\n            return g_inv\n\n        def get_christoffels(r, theta, k_curv_loc, a_loc):\n            G = np.zeros((3, 3, 3))\n            \n            # Avoid coordinate singularities. Test points are safe.\n            if abs(r)  1e-15: return G\n            sin_t, cos_t = np.sin(theta), np.cos(theta)\n            if abs(sin_t)  1e-15: return G\n            \n            term_k = 1.0 - k_curv_loc * r**2\n            # Avoid metric singularity for k=1.\n            if abs(term_k)  1e-15: return G\n\n            # Pre-compute terms for efficiency\n            inv_r = 1.0 / r\n            cot_t = cos_t / sin_t\n\n            # Non-zero Christoffel symbols Gamma^i_{jk}\n            # i=0 (r), j,k are component indices\n            G[0, 0, 0] = k_curv_loc * r / term_k\n            G[0, 1, 1] = -r * term_k\n            G[0, 2, 2] = -r * term_k * sin_t**2\n\n            # i=1 (theta)\n            G[1, 0, 1] = inv_r\n            G[1, 1, 0] = inv_r\n            G[1, 2, 2] = -sin_t * cos_t\n\n            # i=2 (phi)\n            G[2, 0, 2] = inv_r\n            G[2, 2, 0] = inv_r\n            G[2, 1, 2] = cot_t\n            G[2, 2, 1] = cot_t\n            \n            return G\n\n        def ricci_component(i, j, r_eval, theta_eval, k_curv_loc, a_loc, dr, dtheta):\n            # R_ij = T1 + T2 + T3 + T4\n            # T1 = partial_k Gamma^k_ij\n            # T2 = - partial_j Gamma^k_ik\n            # T3 = Gamma^k_ij * Gamma^l_kl\n            # T4 = - Gamma^k_il * Gamma^l_jk\n\n            # Term 1: partial_k Gamma^k_ij (Numerical derivative)\n            gammas_r_plus = get_christoffels(r_eval + dr, theta_eval, k_curv_loc, a_loc)\n            gammas_r_minus = get_christoffels(r_eval - dr, theta_eval, k_curv_loc, a_loc)\n            dG_dr_k0 = (gammas_r_plus[0, i, j] - gammas_r_minus[0, i, j]) / (2 * dr)\n            \n            gammas_th_plus = get_christoffels(r_eval, theta_eval + dtheta, k_curv_loc, a_loc)\n            gammas_th_minus = get_christoffels(r_eval, theta_eval - dtheta, k_curv_loc, a_loc)\n            dG_dth_k1 = (gammas_th_plus[1, i, j] - gammas_th_minus[1, i, j]) / (2 * dtheta)\n            \n            term1 = dG_dr_k0 + dG_dth_k1\n\n            # Term 2: - partial_j Gamma^k_ik (Numerical derivative)\n            term2 = 0.0\n            if j == 0:  # j=r\n                sum_G_kik_plus = gammas_r_plus[0, i, 0] + gammas_r_plus[1, i, 1] + gammas_r_plus[2, i, 2]\n                sum_G_kik_minus = gammas_r_minus[0, i, 0] + gammas_r_minus[1, i, 1] + gammas_r_minus[2, i, 2]\n                term2 = -(sum_G_kik_plus - sum_G_kik_minus) / (2 * dr)\n            elif j == 1:  # j=theta\n                sum_G_kik_plus = gammas_th_plus[0, i, 0] + gammas_th_plus[1, i, 1] + gammas_th_plus[2, i, 2]\n                sum_G_kik_minus = gammas_th_minus[0, i, 0] + gammas_th_minus[1, i, 1] + gammas_th_minus[2, i, 2]\n                term2 = -(sum_G_kik_plus - sum_G_kik_minus) / (2 * dtheta)\n\n            # Terms 3 and 4 are algebraic, evaluated at the central point (r_eval, theta_eval)\n            G_center = get_christoffels(r_eval, theta_eval, k_curv_loc, a_loc)\n            \n            # Term 3: + Gamma^k_ij * Gamma^l_kl\n            term3 = 0.0\n            for k in range(3):\n                sum_G_lkl = G_center[0, k, 0] + G_center[1, k, 1] + G_center[2, k, 2]\n                term3 += G_center[k, i, j] * sum_G_lkl\n\n            # Term 4: - Gamma^k_il * Gamma^l_jk\n            term4 = 0.0\n            for k in range(3):\n                for l in range(3):\n                    term4 -= G_center[k, i, l] * G_center[l, j, k]\n            \n            return term1 + term2 + term3 + term4\n\n        # Because the metric is diagonal, R = g^ii * R_ii (sum over i)\n        R_diag_components = np.zeros(3)\n        for i in range(3):\n            R_diag_components[i] = ricci_component(i, i, r0, theta0, k_curv, a, h_r, h_theta)\n\n        g_inv_diag = np.diag(get_inverse_metric(r0, theta0, k_curv, a))\n        \n        R_christoffel = np.dot(g_inv_diag, R_diag_components)\n\n        diff = abs(R_christoffel - R_adm)\n        results.append(diff)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3494863"}, {"introduction": "在空间切片分析的基础上，本练习转向了在完整的四维时空中计算曲率。您将实现一个数值程序，直接从度规张量 $g_{\\mu\\nu}$ 出发，经过克里斯托费尔符号和里奇张量，最终根据其基本定义计算里奇标量 $R$。此练习的核心目标是执行收敛性检验，这是数值分析的基石，用以验证您的数值近似解是否随着网格分辨率的提高而趋近于精确的解析解 [@problem_id:3494931]。", "problem": "您的任务是为里奇标量（Ricci scalar）的计算设计并实现一个数值验证器，该计算在数值相对论和引力波建模中至关重要。程序必须为两种具有已知属性的解析时空——Kasner（真空）时空和 Friedmann–Lemaître–Robertson–Walker (FLRW) 时空，在指定事件处计算里奇标量 $R$。目标是，通过使用有限差分从第一性原理数值近似 $R$ 来执行混合时空收敛性检验，然后与每种时空的解析已知值进行比较，以提取经验收敛率。\n\n从以下基本定义和事实出发：\n- 时空由度规张量 $g_{\\mu\\nu}$ 描述，度规符号为 $(-,+,+,+)$，使用自然单位制，其中 $c=1$。\n- 第二类克里斯托费尔符号（Christoffel symbols）定义为\n  $$\\Gamma^{\\alpha}{}_{\\beta\\gamma} = \\frac{1}{2} g^{\\alpha\\delta}\\Big(\\partial_{\\beta} g_{\\gamma\\delta} + \\partial_{\\gamma} g_{\\beta\\delta} - \\partial_{\\delta} g_{\\beta\\gamma}\\Big).$$\n- 里奇张量（Ricci tensor）由克里斯托费尔符号定义为\n  $$R_{\\mu\\nu} = \\partial_{\\lambda} \\Gamma^{\\lambda}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\lambda}{}_{\\mu\\lambda} + \\Gamma^{\\lambda}{}_{\\lambda\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\nu} - \\Gamma^{\\lambda}{}_{\\nu\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\lambda}.$$\n- 里奇标量是其缩并\n  $$R = g^{\\mu\\nu} R_{\\mu\\nu}.$$\n\n待实现的数值方法：\n- 使用中心有限差分法，通过在每个坐标方向上以小步长分隔的相邻点上对 $g_{\\gamma\\delta}$ 进行采样，来近似一阶偏导数 $\\partial_{\\beta} g_{\\gamma\\delta}$。类似地，通过在相邻点上对 $\\Gamma^{\\alpha}{}_{\\beta\\gamma}$ 进行采样，对 $\\partial_{\\lambda}\\Gamma^{\\lambda}{}_{\\mu\\nu}$ 和 $\\partial_{\\nu} \\Gamma^{\\lambda}{}_{\\mu\\lambda}$ 使用中心差分。\n- 使用上述定义和数值导数，在单个事件 $(t_{0},x_{0},y_{0},z_{0})$ 处计算 $R$。\n\n使用的时空和度规：\n- Kasner 时空：一个空间均匀、各向异性的真空解。在类笛卡尔坐标 $(t,x,y,z)$ 中，度规是对角的，其分量为\n  $$g_{\\mu\\nu} = \\mathrm{diag}\\big(-1,\\, t^{2p_{1}},\\, t^{2p_{2}},\\, t^{2p_{3}}\\big),$$\n  其中 $(p_{1},p_{2},p_{3})$ 满足 $p_{1}+p_{2}+p_{3}=1$ 和 $p_{1}^{2}+p_{2}^{2}+p_{3}^{2}=1$。\n- 在各向同性笛卡尔坐标 $(t,x,y,z)$ 中的 Friedmann–Lemaître–Robertson–Walker 时空，具有恒定的空间曲率参数 $k\\in\\{+1,-1\\}$ 和尺度因子 $a(t)$，其空间度规通过一个径向因子与欧几里得度规共形。使用对角度规\n  $$g_{\\mu\\nu} = \\mathrm{diag}\\Big(-1,\\, a(t)^{2} \\, \\frac{4}{\\big(1 + k r^{2}\\big)^{2}},\\, a(t)^{2} \\, \\frac{4}{\\big(1 + k r^{2}\\big)^{2}},\\, a(t)^{2} \\, \\frac{4}{\\big(1 + k r^{2}\\big)^{2}}\\Big),$$\n  其中 $r^{2} = x^{2} + y^{2} + z^{2}$。选择 $a(t) = e^{H t}$，其中常数 $H0$，以确保非平凡的时间依赖性。\n\n测试套件和评估：\n- 对于每个测试用例，使用有限差分法在指定事件处计算数值里奇标量 $R_{\\mathrm{num}}$。与该时空的解析已知里奇标量 $R_{\\mathrm{exact}}$ 进行比较。对粗网格和细网格计算绝对误差 $E = |R_{\\mathrm{num}} - R_{\\mathrm{exact}}|$，其中细网格将时间步长和空间步长都减半。报告由下式估计的观测收敛阶 $p$：\n  $$p \\approx \\frac{\\log\\big(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\big)}{\\log\\big(h_{\\mathrm{coarse}}/h_{\\mathrm{fine}}\\big)},$$\n  其中 $h$ 是一个代表性的网格间距。您必须同时细化时间步长和空间步长，并使用 $h = \\max(\\Delta t, \\Delta x)$。\n- 使用以下测试套件：\n  1. Kasner 时空，参数 $(p_{1},p_{2},p_{3}) = \\big(\\tfrac{2}{3}, -\\tfrac{1}{3}, \\tfrac{2}{3}\\big)$，在 $(t_{0},x_{0},y_{0},z_{0}) = (0.8, 0.1, 0.1, 0.1)$ 处评估，粗略步长 $(\\Delta t, \\Delta x) = (10^{-2}, 10^{-2})$，精细步长 $(\\Delta t, \\Delta x) = (5\\times 10^{-3}, 5\\times 10^{-3})$。\n  2. FLRW 时空，参数 $k=+1, H=0.1$，在 $(t_{0},x_{0},y_{0},z_{0}) = (0.5, 0.2, 0.1, -0.15)$ 处评估，粗略步长 $(\\Delta t, \\Delta x) = (10^{-2}, 10^{-2})$，精细步长 $(\\Delta t, \\Delta x) = (5\\times 10^{-3}, 5\\times 10^{-3})$。\n  3. FLRW 时空，参数 $k=-1, H=0.1$，在 $(t_{0},x_{0},y_{0},z_{0}) = (0.5, 0.3, 0.25, 0.1)$ 处评估，粗略步长 $(\\Delta t, \\Delta x) = (1.25\\times 10^{-2}, 1.25\\times 10^{-2})$，精细步长 $(\\Delta t, \\Delta x) = (6.25\\times 10^{-3}, 6.25\\times 10^{-3})$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的观测收敛阶列表。例如，输出格式必须严格为\n  $$[p_{1},p_{2},p_{3}]$$\n  其中每个 $p_{i}$ 是一个浮点数。不应打印任何其他文本。\n- 这是一个纯数学计算；最终输出中没有物理单位。不存在角度。将所有数值输出表示为浮点数。\n\n科学真实性和约束：\n- 代码中使用的所有公式必须从提供的基本定义推导而来，不得将预先简化的曲率公式直接插入到 $R_{\\mathrm{num}}$ 的数值计算中。用于误差计算的解析值 $R_{\\mathrm{exact}}$ 允许来自独立已知的解，以进行验证。\n- 通过评估内部点来确保数值稳定性，避免坐标奇点。对于 FLRW $k=-1$ 的情况，限制 $r$ 以使 $1 + k r^{2}  0$。", "solution": "该问题是有效的。它在科学上基于广义相对论的原理，问题陈述清晰，目标明确，数据充分，并使用客观、正式的语言。所有提供的公式和时空度规都是该领域的标准。Kasner 度规的测试用例使用的参数 $(p_1, p_2, p_3) = (\\frac{2}{3}, -\\frac{1}{3}, \\frac{2}{3})$ 正确满足真空条件 $p_1+p_2+p_3=1$ 和 $p_1^2+p_2^2+p_3^2=1$。Friedmann–Lemaître–Robertson–Walker (FLRW) 时空的评估点被选择以避免坐标奇点。因此，我们可以着手解决。\n\n任务的核心是在一个特定的时空事件上数值计算里奇标量 $R$。解决方案是通过使用数值微分，从第一性原理分层实现定义方程来构建的。\n\n**1. 验证的解析基础**\n\n为了验证我们的数值结果，我们需要给定两种时空的里奇标量 $R_{\\mathrm{exact}}$ 的精确解析值。\n- **Kasner 时空**：Kasner 度规是真空爱因斯坦场方程的一个解，这意味着其里奇张量恒为零，$R_{\\mu\\nu} = 0$。因此，里奇标量，作为里奇张量的迹 $R = g^{\\mu\\nu}R_{\\mu\\nu}$，也为零。因此，对于第一个测试用例，$R_{\\mathrm{exact}} = 0$。\n- **FLRW 时空**：对于具有尺度因子 $a(t)$ 和空间曲率 $k$ 的一般 FLRW 度规，里奇标量由 $R = 6 \\left( \\frac{\\ddot{a}}{a} + (\\frac{\\dot{a}}{a})^2 + \\frac{k}{a^2} \\right)$ 给出。问题指定了 $a(t) = e^{Ht}$，这描述了一个德西特（de Sitter）宇宙。对于这个尺度因子，我们有 $\\frac{\\dot{a}}{a} = H$ 和 $\\frac{\\ddot{a}}{a} = H^2$。将这些代入 $R$ 的公式中，得到 $R = 6(H^2 + H^2 + k e^{-2Ht}) = 12H^2 + 6ke^{-2Ht}$。这个解析表达式将用于在指定的评估时间 $t_0$ 计算第二个和第三个测试用例的 $R_{\\mathrm{exact}}$。\n\n**2. 数值实现策略**\n\n$R$ 的数值计算直接遵循其定义 $R = g^{\\mu\\nu}R_{\\mu\\nu}$，这需要一个多步骤、自下而上的计算过程。这种层次结构在软件设计中得到了体现。\n\n- **步骤 2a：度规张量**：定义函数来表示 Kasner 和 FLRW 时空的度规张量 $g_{\\mu\\nu}$。这些函数接受一个四维坐标元组 $(t, x, y, z)$，并返回该事件处的 $4 \\times 4$ 度规张量矩阵。由于计算涉及在邻近点多次评估度规，度规函数被包装在一个记忆化装饰器 (`@functools.lru_cache`) 中，以缓存结果并避免重复计算。为每次“运行”（粗网格与细网格）实例化一个新的缓存，确保计算的独立性。\n\n- **步骤 2b：克里斯托费尔符号，$\\Gamma^{\\alpha}{}_{\\beta\\gamma}$**：克里斯托费尔符号通过其定义 $\\Gamma^{\\alpha}{}_{\\beta\\gamma} = \\frac{1}{2} g^{\\alpha\\delta}(\\partial_{\\beta} g_{\\gamma\\delta} + \\partial_{\\gamma} g_{\\beta\\delta} - \\partial_{\\delta} g_{\\beta\\gamma})$ 计算。这需要逆度规 $g^{\\alpha\\delta}$ 和度规分量的一阶偏导数 $\\partial_{\\beta} g_{\\gamma\\delta}$。导数使用二阶中心有限差分格式进行数值近似：$\\partial_{\\beta}f(P) \\approx \\frac{f(P+\\mathbf{h}_{\\beta}) - f(P-\\mathbf{h}_{\\beta})}{2h_{\\beta}}$，其中 $P$ 是评估点，$\\mathbf{h}_{\\beta}$ 是 $\\beta$ 方向上的步长向量。\n\n- **步骤 2c：里奇张量, $R_{\\mu\\nu}$**：里奇张量 $R_{\\mu\\nu} = \\partial_{\\lambda} \\Gamma^{\\lambda}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\lambda}{}_{\\mu\\lambda} + \\Gamma^{\\lambda}{}_{\\lambda\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\nu} - \\Gamma^{\\lambda}{}_{\\nu\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\lambda}$ 是最复杂的部分。它的计算涉及两类项：\n    1.  *二次项*：克里斯托费尔符号的乘积，例如 $\\Gamma^{\\lambda}{}_{\\lambda\\sigma}\\Gamma^{\\sigma}{}_{\\mu\\nu}$，是使用在中心点 $P_0$ 评估的克里斯托费尔符号计算的。\n    2.  *导数项*：像 $\\partial_{\\lambda} \\Gamma^{\\lambda}{}_{\\mu\\nu}$ 这样的项涉及克里斯托费尔符号的导数。这些也使用中心差分计算。这意味着克里斯托费尔符号本身必须在邻近点 $P_0 \\pm \\mathbf{h}_{\\lambda}$ 处进行评估，这反过来又需要在更宽的模板点上评估度规张量。这种有限差分的嵌套应用正确地近似了里奇张量定义中固有的度规张量的二阶导数。\n\n- **步骤 2d：里奇标量, $R$**：最后，通过将在中心点 $P_0$ 处数值获得的里奇张量 $R_{\\mu\\nu}$ 与逆度规 $g^{\\mu\\nu}$ 进行缩并来计算里奇标量：$R = g^{\\mu\\nu}R_{\\mu\\nu} = \\sum_{\\mu,\\nu} g^{\\mu\\nu}(P_0) R_{\\mu\\nu}(P_0)$。\n\n**3. 收敛性分析**\n\n程序对每个测试用例执行两次完整的数值计算：一次使用粗网格间距 ($h_{\\mathrm{coarse}}$)，另一次使用细网格间距 ($h_{\\mathrm{fine}} = h_{\\mathrm{coarse}}/2$)。计算绝对误差 $E_{\\mathrm{coarse}} = |R_{\\mathrm{num, coarse}} - R_{\\mathrm{exact}}|$ 和 $E_{\\mathrm{fine}} = |R_{\\mathrm{num, fine}} - R_{\\mathrm{exact}}|$。然后使用公式估计经验收敛阶 $p$：\n$$p \\approx \\frac{\\log(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}})}{\\log(h_{\\mathrm{coarse}}/h_{\\mathrm{fine}})}$$\n鉴于所有测试用例中 $h_{\\mathrm{coarse}}/h_{\\mathrm{fine}} = 2$，这简化为 $p \\approx \\log_2(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}})$。由于数值格式是基于二阶中心差分的，预期的收敛阶为 $p \\approx 2$。最终输出包含每个测试用例计算出的 $p$ 值。", "answer": "```python\nimport numpy as np\nimport functools\n\ndef get_kasner_metric_factory(p1, p2, p3):\n    \"\"\"Returns a function that computes the Kasner metric tensor.\"\"\"\n    def metric_func(coords):\n        t, x, y, z = coords\n        if t = 0:\n            raise ValueError(\"Time coordinate t must be positive for Kasner metric.\")\n        return np.diag([-1.0, t**(2*p1), t**(2*p2), t**(2*p3)])\n    return metric_func\n\ndef get_flrw_metric_factory(k, H):\n    \"\"\"Returns a function that computes the FLRW metric tensor.\"\"\"\n    def metric_func(coords):\n        t, x, y, z = coords\n        r2 = x**2 + y**2 + z**2\n        a_t = np.exp(H * t)\n        \n        # Check for coordinate singularity\n        denom = 1.0 + k * r2\n        if np.isclose(denom, 0):\n            raise ValueError(\"Evaluation point is at a coordinate singularity.\")\n            \n        conformal_factor = 4.0 / (denom**2)\n        g_spatial = (a_t**2) * conformal_factor\n        return np.diag([-1.0, g_spatial, g_spatial, g_spatial])\n    return metric_func\n\ndef get_christoffel(metric_func, point, steps):\n    \"\"\"Computes Christoffel symbols of the second kind at a given point.\"\"\"\n    point_tuple = tuple(point)\n    g = metric_func(point_tuple)\n    g_inv = np.linalg.inv(g)\n\n    # Compute derivatives of the metric, d_g[deriv_idx, mu, nu]\n    d_g = np.zeros((4, 4, 4))\n    for deriv_idx in range(4):\n        h = steps[deriv_idx]\n        shift = np.zeros(4)\n        shift[deriv_idx] = h\n        \n        g_plus = metric_func(tuple(point + shift))\n        g_minus = metric_func(tuple(point - shift))\n        \n        d_g[deriv_idx, :, :] = (g_plus - g_minus) / (2.0 * h)\n\n    # Compute Christoffel symbols, gamma[alpha, beta, c]\n    gamma = np.zeros((4, 4, 4))\n    for alpha in range(4):\n        for beta in range(4):\n            for c in range(4): # 'c' for gamma to avoid name clash\n                term = 0.0\n                for delta in range(4):\n                    term += g_inv[alpha, delta] * 0.5 * (d_g[beta, c, delta] + d_g[c, beta, delta] - d_g[delta, beta, c])\n                gamma[alpha, beta, c] = term\n    return gamma\n\ndef get_ricci_tensor(metric_func, point, steps):\n    \"\"\"Computes the Ricci tensor at a given point.\"\"\"\n    ricci = np.zeros((4, 4))\n    \n    # Christoffel symbols at the center point\n    gamma_center = get_christoffel(metric_func, point, steps)\n\n    # Derivatives of Christoffel symbols, d_gamma[deriv_idx, alpha, beta, c]\n    d_gamma = np.zeros((4, 4, 4, 4))\n    for deriv_idx in range(4):\n        h = steps[deriv_idx]\n        shift = np.zeros(4)\n        shift[deriv_idx] = h\n        \n        gamma_plus = get_christoffel(metric_func, point + shift, steps)\n        gamma_minus = get_christoffel(metric_func, point - shift, steps)\n        \n        d_gamma[deriv_idx, :, :, :] = (gamma_plus - gamma_minus) / (2.0 * h)\n\n    for mu in range(4):\n        for nu in range(4):\n            # Term 1: partial_lambda Gamma^lambda_{mu nu}\n            term1 = np.trace(d_gamma[:, :, mu, nu])\n            \n            # Term 2: partial_nu Gamma^lambda_{mu lambda}\n            term2 = 0.0\n            for lam in range(4):\n                term2 += d_gamma[nu, lam, mu, lam]\n                \n            # Term 3: Gamma^lambda_{lambda sigma} Gamma^sigma_{mu nu}\n            term3 = 0.0\n            for lam in range(4):\n                for sig in range(4):\n                    term3 += gamma_center[lam, lam, sig] * gamma_center[sig, mu, nu]\n\n            # Term 4: Gamma^lambda_{nu sigma} Gamma^sigma_{mu lambda}\n            term4 = 0.0\n            for lam in range(4):\n                for sig in range(4):\n                    term4 += gamma_center[lam, nu, sig] * gamma_center[sig, mu, lam]\n\n            ricci[mu, nu] = term1 - term2 + term3 - term4\n            \n    return ricci\n\ndef get_ricci_scalar_numerical(metric_factory, point, steps):\n    \"\"\"Computes the Ricci scalar at a point for a given metric factory.\"\"\"\n    # Create a cached version of the metric function for this specific run\n    @functools.lru_cache(maxsize=None)\n    def metric_func(coords_tuple):\n        return metric_factory(coords_tuple)\n\n    g_inv = np.linalg.inv(metric_func(tuple(point)))\n    ricci_tensor = get_ricci_tensor(metric_func, point, steps)\n    \n    scalar = np.sum(g_inv * ricci_tensor)\n    return scalar\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute convergence orders.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Kasner\",\n            \"metric_factory\": get_kasner_metric_factory(p1=2/3, p2=-1/3, p3=2/3),\n            \"point\": np.array([0.8, 0.1, 0.1, 0.1]),\n            \"steps_coarse\": np.array([1e-2, 1e-2, 1e-2, 1e-2]),\n            \"steps_fine\": np.array([5e-3, 5e-3, 5e-3, 5e-3]),\n            \"R_exact_func\": lambda p: 0.0\n        },\n        {\n            \"name\": \"FLRW k=+1\",\n            \"metric_factory\": get_flrw_metric_factory(k=1.0, H=0.1),\n            \"point\": np.array([0.5, 0.2, 0.1, -0.15]),\n            \"steps_coarse\": np.array([1e-2, 1e-2, 1e-2, 1e-2]),\n            \"steps_fine\": np.array([5e-3, 5e-3, 5e-3, 5e-3]),\n            \"R_exact_func\": lambda p: 12*(0.1)**2 + 6*1.0*np.exp(-2*0.1*p[0])\n        },\n        {\n            \"name\": \"FLRW k=-1\",\n            \"metric_factory\": get_flrw_metric_factory(k=-1.0, H=0.1),\n            \"point\": np.array([0.5, 0.3, 0.25, 0.1]),\n            \"steps_coarse\": np.array([1.25e-2, 1.25e-2, 1.25e-2, 1.25e-2]),\n            \"steps_fine\": np.array([6.25e-3, 6.25e-3, 6.25e-3, 6.25e-3]),\n            \"R_exact_func\": lambda p: 12*(0.1)**2 + 6*(-1.0)*np.exp(-2*0.1*p[0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        point = case[\"point\"]\n        \n        # Coarse grid calculation\n        R_coarse = get_ricci_scalar_numerical(case[\"metric_factory\"], point, case[\"steps_coarse\"])\n        \n        # Fine grid calculation\n        R_fine = get_ricci_scalar_numerical(case[\"metric_factory\"], point, case[\"steps_fine\"])\n        \n        R_exact = case[\"R_exact_func\"](point)\n        \n        E_coarse = np.abs(R_coarse - R_exact)\n        E_fine = np.abs(R_fine - R_exact)\n\n        # Avoid division by zero if error is zero (perfect cancellation)\n        if E_coarse == 0 or E_fine == 0:\n            order = np.nan # Or a large number to indicate super-convergence\n        else:\n            h_coarse = np.max(case[\"steps_coarse\"])\n            h_fine = np.max(case[\"steps_fine\"])\n            order = np.log(E_coarse / E_fine) / np.log(h_coarse / h_fine)\n        \n        results.append(order)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3494931"}, {"introduction": "虽然有限差分法是稳健的，但对于像引力波这样的光滑解，高精度的谱方法通常更为优越。本实践将深入探讨如何使用快速傅里叶变换 (Fast Fourier Transform, FFT) 来计算导数，并数值验证横场无迹 (transverse-traceless, TT) 规范下的平面引力波是否为线性化真空爱因斯坦方程的解，这意味着其线性化里奇张量 $R^{(1)}_{\\mu\\nu}$ 应为零。这个练习不仅介绍了一种强大的计算技术，还清晰地、动手实践地展示了数值误差（如谱泄漏）是如何产生的，以及它们如何依赖于网格分辨率 [@problem_id:3494925]。", "problem": "考虑在 Minkowski 背景上的线性化引力，其度规符号为 $(-,+,+,+)$，存在小微扰 $h_{\\mu\\nu}$，使得 $g_{\\mu\\nu} = \\eta_{\\mu\\nu} + h_{\\mu\\nu}$ 且 $\\lVert h_{\\mu\\nu} \\rVert \\ll 1$。在横向无迹 (TT) 规范中，该微扰满足 $h_{0\\mu} = 0$、$\\partial^\\mu h_{\\mu\\nu} = 0$ 和 $h \\equiv \\eta^{\\mu\\nu}h_{\\mu\\nu} = 0$。对于一个沿 $z$ 方向传播的平面引力波，一个标准的正偏振选择是 $h_{xx}(t,z) = h_0 \\cos(k z - \\omega t)$ 和 $h_{yy}(t,z) = -h_{xx}(t,z)$，所有其他分量为零，其中 $h_0$ 是一个常数振幅，$k$ 是空间波数，$\\omega$ 是角频率。\n\n从线性化 Ricci 张量的定义出发，\n$$\nR^{(1)}_{\\mu\\nu} = \\tfrac{1}{2}\\left(\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} + \\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu} - \\Box h_{\\mu\\nu} - \\partial_\\mu \\partial_\\nu h\\right),\n$$\n其中 $\\Box \\equiv \\eta^{\\alpha\\beta} \\partial_\\alpha \\partial_\\beta = -\\partial_t^2 + \\partial_x^2 + \\partial_y^2 + \\partial_z^2$ 且指标由 $\\eta_{\\mu\\nu}$ 升降，推导在 TT 规范下的简化形式，并解释为什么对于遵循色散关系 $\\omega = k$（在光速 $c = 1$ 的单位制下）的真空平面波，我们预期 $R^{(1)}_{\\mu\\nu} = 0$ 逐点成立。\n\n您将使用快速傅里叶变换 (FFT) 在时间和空间的周期性域上实现一个导数的伪谱计算，以数值方式评估上述平面波的线性化 Ricci 张量，并量化由于离散化和表示误差而产生的虚假数值 $R^{(1)}_{\\mu\\nu}$。具体来说，您将：\n- 在时间 $t \\in [0,T)$ 和空间 $z \\in [0,L)$ 的均匀网格上表示该波，分别使用 $N_t$ 和 $N_z$ 个网格点，使用精确场值 $h_{xx}(t,z) = h_0 \\cos(k z - \\omega t)$ 和 $h_{yy}(t,z) = -h_{xx}(t,z)$，且所有其他 $h_{\\mu\\nu}$ 均为零。\n- 使用上述定义所隐含的 TT 规范简化来逐分量计算线性化 Ricci 张量。对于当前的对称性，唯一非零的二阶导数是关于 $t$ 和 $z$ 的，线性化 Ricci 张量简化为达朗贝尔算符作用于非零分量。\n- 使用谱微分：对于在长度为 $L$ 的均匀周期性网格上采样的场 $f(x)$，其 $n$ 阶导数在傅里叶空间中通过将离散傅里叶变换乘以 $(i 2\\pi \\xi)^n$ 来计算，其中 $\\xi$ 是傅里叶网格返回的离散频率，然后再进行逆变换。对于时间，使用周期为 $T$ 的类似构造。\n\n因为对于一个可以在离散傅里叶网格上精确表示的精确周期性平面波（即，当 $k = 2\\pi m/L$ 和 $\\omega = 2\\pi m/T$，$m$ 为整数时），精确的 $R^{(1)}_{\\mu\\nu}$ 为零，所以在谱代码中，对于这种整合模式，人们期望数值抵消能达到机器精度。对于非整合模式（例如，$k$ 或 $\\omega$ 与域周期不成比例），表示误差会导致非零的虚假值，这些值应随着网格的细化而减小。\n\n实现一个程序，该程序：\n- 使用 $h_0 = 10^{-6}$，$L = 1$，和 $T = 1$。\n- 对于每个测试用例，从参数 $m$ 设置 $k = 2\\pi m / L$ 和 $\\omega = 2\\pi m / T$。\n- 通过 TT 规范简化所隐含的定义计算线性化 Ricci 张量分量 $R^{(1)}_{\\mu\\nu}(t,z)$，并返回标量诊断量\n$$\nE(N_t, N_z, m) = \\max_{t,z,\\mu,\\nu} \\left| R^{(1)}_{\\mu\\nu}(t,z) \\right|,\n$$\n即在整个网格和所有分量上的最大绝对值。\n\n测试套件：\n- 使用以下六个测试用例，每个用例以元组 $(N_z,N_t,m)$ 的形式给出，其中 $L=T=1$：\n  1. $(64, 64, 5.0)$，一个整合模式。\n  2. $(8, 8, 1.0)$，一个粗糙但整合的模式。\n  3. $(16, 16, \\sqrt{2})$，一个非整合模式。\n  4. $(32, 32, \\sqrt{2})$，一个细化的非整合模式。\n  5. $(64, 64, \\sqrt{2})$，一个进一步细化的非整合模式。\n  6. $(64, 64, 16.0)$，一个低于奈奎斯特极限的高频整合模式。\n\n答案规范：\n- 对于每个测试用例，计算 $E(N_t, N_z, m)$ 作为一个浮点数。\n- 最终程序输出必须是单行，包含对应于上述六个测试用例的六个浮点数列表，格式为方括号括起来的逗号分隔列表，例如 `[e_1,e_2,e_3,e_4,e_5,e_6]`。\n- 答案中不需要物理单位，因为在所选单位制中所有量都是无量纲的。", "solution": "该问题要求分两部分作答：首先是理论推导，得出在横向无迹 (TT) 规范下简化的线性化 Ricci 张量及其对真空平面波的值；其次是数值实现，为特定的引力波计算该张量并量化数值误差。\n\n### 理论推导\n\n我们从给定的线性化 Ricci 张量 $R^{(1)}_{\\mu\\nu}$ 的表达式开始，该表达式针对 Minkowski 度规 $\\eta_{\\mu\\nu}$ 周围的小微扰 $h_{\\mu\\nu}$：\n$$\nR^{(1)}_{\\mu\\nu} = \\tfrac{1}{2}\\left(\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} + \\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu} - \\Box h_{\\mu\\nu} - \\partial_\\mu \\partial_\\nu h\\right)\n$$\n此处，指标由 $\\eta_{\\mu\\nu}$ 升降，$\\Box \\equiv \\eta^{\\alpha\\beta} \\partial_\\alpha \\partial_\\beta$ 是达朗贝尔算符。度规符号为 $(-,+,+,+)$，因此 $\\eta_{\\mu\\nu} = \\text{diag}(-1, 1, 1, 1)$。\n\n问题在横向无迹 (TT) 规范下指定，该规范对微扰 $h_{\\mu\\nu}$ 施加以下条件：\n1.  **无迹条件**：微扰的迹必须为零，$h \\equiv \\eta^{\\mu\\nu}h_{\\mu\\nu} = 0$。\n2.  **横向条件**：微扰的四维散度必须为零，$\\partial^\\mu h_{\\mu\\nu} = 0$。\n\n将无迹条件 ($h=0$) 应用于 $R^{(1)}_{\\mu\\nu}$ 的表达式，立即消除了最后一项：\n$$\nR^{(1)}_{\\mu\\nu} = \\tfrac{1}{2}\\left(\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} + \\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu} - \\Box h_{\\mu\\nu}\\right)\n$$\n\n接下来，我们应用横向条件。让我们检查 $\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu}$ 项。对 $h_{\\alpha\\nu}$ 的第一个指标进行提升，得到 $h^{\\rho}{}_{\\nu} = \\eta^{\\rho\\alpha} h_{\\alpha\\nu}$。该项变为：\n$$\n\\partial_\\rho \\partial_\\mu h^{\\rho}{}_{\\nu} = \\partial_\\rho \\partial_\\mu (\\eta^{\\rho\\alpha} h_{\\alpha\\nu}) = \\eta^{\\rho\\alpha} \\partial_\\rho \\partial_\\mu h_{\\alpha\\nu}\n$$\n由于偏导数可交换 ($\\partial_\\rho\\partial_\\mu = \\partial_\\mu\\partial_\\rho$) 且度规张量分量是常数，我们可以写出：\n$$\n\\eta^{\\rho\\alpha} \\partial_\\mu \\partial_\\rho h_{\\alpha\\nu} = \\partial_\\mu (\\eta^{\\rho\\alpha} \\partial_\\rho h_{\\alpha\\nu}) = \\partial_\\mu (\\partial^\\alpha h_{\\alpha\\nu})\n$$\n横向条件 $\\partial^\\mu h_{\\mu\\nu} = 0$ 意味着括号中的项为零。因此，$\\partial_\\mu (\\partial^\\alpha h_{\\alpha\\nu}) = \\partial_\\mu(0) = 0$。\n同样，通过对称论证，第二项 $\\partial_\\rho \\partial_\\nu h^{\\rho}{}_{\\mu}$ 也为零。\n\n这使得 TT 规范下线性化 Ricci 张量的表达式大大简化：\n$$\nR^{(1)}_{\\mu\\nu} = -\\frac{1}{2} \\Box h_{\\mu\\nu}\n$$\n\n现在，我们为给定的沿 $z$ 方向传播的正偏振平面引力波计算该表达式。非零分量为 $h_{xx}(t,z) = h_0 \\cos(k z - \\omega t)$ 和 $h_{yy}(t,z) = -h_{xx}(t,z)$。这些分量仅依赖于时间 $t$ 和传播方向 $z$。作用于任何此类函数 $f(t,z)$ 的达朗贝尔算符简化为 $\\Box f = (-\\partial_t^2 + \\partial_z^2)f$。\n\n让我们计算 $h_{xx}$ 的二阶偏导数：\n$$\n\\partial_t h_{xx} = \\partial_t [h_0 \\cos(k z - \\omega t)] = h_0 (-\\sin(k z - \\omega t))(-\\omega) = \\omega h_0 \\sin(k z - \\omega t)\n$$\n$$\n\\partial_t^2 h_{xx} = \\partial_t [\\omega h_0 \\sin(k z - \\omega t)] = \\omega h_0 (\\cos(k z - \\omega t))(-\\omega) = -\\omega^2 h_0 \\cos(k z - \\omega t) = -\\omega^2 h_{xx}\n$$\n同样，对于空间导数：\n$$\n\\partial_z h_{xx} = \\partial_z [h_0 \\cos(k z - \\omega t)] = h_0 (-\\sin(k z - \\omega t))(k) = -k h_0 \\sin(k z - \\omega t)\n$$\n$$\n\\partial_z^2 h_{xx} = \\partial_z [-k h_0 \\sin(k z - \\omega t)] = -k h_0 (\\cos(k z - \\omega t))(k) = -k^2 h_0 \\cos(k z - \\omega t) = -k^2 h_{xx}\n$$\n将达朗贝尔算符应用于 $h_{xx}$：\n$$\n\\Box h_{xx} = (-\\partial_t^2 + \\partial_z^2)h_{xx} = -(-\\omega^2 h_{xx}) + (-k^2 h_{xx}) = (\\omega^2 - k^2)h_{xx}\n$$\n对于真空中的引力波，色散关系为 $\\omega = k$（在 $c=1$ 的几何单位制中）。将此代入方程得到：\n$$\n\\Box h_{xx} = (k^2 - k^2)h_{xx} = 0\n$$\n由于 $\\Box h_{xx}=0$，且所有其他 $h_{\\mu\\nu}$ 要么为零，要么与 $h_{xx}$ 成比例，因此对于所有分量，$\\Box h_{\\mu\\nu} = 0$。因此，线性化 Ricci 张量逐点为零：\n$$\nR^{(1)}_{\\mu\\nu} = -\\frac{1}{2} \\Box h_{\\mu\\nu} = 0\n$$\n这表明给定的引力波是线性化真空爱因斯坦方程的一个解。\n\n### 数值实现\n\n数值任务是使用谱方法计算 $R^{(1)}_{\\mu\\nu}$，并找到其分量的最大绝对值 $E = \\max |R^{(1)}_{\\mu\\nu}|$。基于上述推导，我们将计算 $R^{(1)}_{\\mu\\nu} = -\\frac{1}{2}(-\\partial_t^2 + \\partial_z^2)h_{\\mu\\nu}$。由于精确结果为零，任何非零的 $E$ 值都将是数值误差的度量。\n\n对于每个测试用例 $(N_z, N_t, m)$，算法如下：\n1.  定义物理和数值参数：$h_0 = 10^{-6}$，$L=T=1$，$k=2\\pi m/L$，$\\omega=2\\pi m/T$。\n2.  离散化域：为时间 $t \\in [0,T)$（$N_t$ 个点）和空间 $z \\in [0,L)$（$N_z$ 个点）创建均匀网格。\n3.  在二维网格上评估场 $h_{xx}(t,z)$。注意 $h_{yy} = -h_{xx}$，其他分量为零。\n4.  使用 FFT 计算二阶时间导数 $\\partial_t^2 h_{xx}$。这包括：\n    a. 沿时间轴对 $h_{xx}$ 进行一维 FFT。\n    b. 在傅里叶空间中将结果乘以 $-(\\omega_{\\text{freq}}^k)^2$，其中 $\\omega_{\\text{freq}}^k$ 是离散角频率。\n    c. 进行一维逆 FFT。\n5.  类似地，使用沿空间轴的 FFT 计算二阶空间导数 $\\partial_z^2 h_{xx}$，并乘以 $-(k_{\\text{freq}}^j)^2$。\n6.  组合导数以求得 $\\Box h_{xx} = -\\partial_t^2 h_{xx} + \\partial_z^2 h_{xx}$。\n7.  计算 $R^{(1)}_{xx} = -0.5 \\cdot \\Box h_{xx}$。\n8.  另一个非零分量是 $R^{(1)}_{yy} = -R^{(1)}_{xx}$。所有其他分量都为零。因此，诊断量 $E$ 就是 $R^{(1)}_{xx}$ 在网格上的最大绝对值：$E = \\max |R^{(1)}_{xx}(t,z)|$。\n\n对所有测试用例重复此过程。对于“整合”模式（其中参数 $m$ 是整数），平面波在计算域上是精确周期的。谱方法应该能够以机器精度表示该函数及其导数，从而得到接近零的数值结果 $E$。对于“非整合”模式（其中 $m$ 不是整数，如 $\\sqrt{2}$），波在域上不是周期的。FFT 的周期性隐式假设引入了表示误差（谱泄漏），导致 $E$ 值较大且非零。为非整合模式增加网格分辨率应会减小此误差，展示该方法的谱收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_ricci_error(Nz, Nt, m):\n    \"\"\"\n    Computes the maximum numerical error in the linearized Ricci tensor\n    for a given grid size and wave mode.\n    \n    Args:\n        Nz (int): Number of grid points in the z-direction.\n        Nt (int): Number of grid points in the t-direction.\n        m (float): Mode number parameter for the plane wave.\n\n    Returns:\n        float: The diagnostic E(Nt, Nz, m).\n    \"\"\"\n    # Physical and domain parameters\n    h0 = 1.0e-6\n    L = 1.0\n    T = 1.0\n\n    # Wave parameters\n    # The dispersion relation omega = k is satisfied since L=T\n    k = 2.0 * np.pi * m / L\n    omega = 2.0 * np.pi * m / T\n\n    # Spatial and temporal grids\n    z = np.linspace(0, L, Nz, endpoint=False)\n    t = np.linspace(0, T, Nt, endpoint=False)\n    T_grid, Z_grid = np.meshgrid(t, z, indexing='ij')\n\n    # Gravitational wave perturbation h_xx(t, z)\n    # The other non-zero component is h_yy = -h_xx.\n    hxx = h0 * np.cos(k * Z_grid - omega * T_grid)\n\n    # Compute second time derivative using FFT\n    # Step 1: FFT along the time axis (axis=0)\n    hxx_tilde_t = np.fft.fft(hxx, axis=0)\n    # Step 2: Get angular frequencies and multiply by -(omega_freq)^2\n    dt = T / Nt\n    omega_freqs = 2.0 * np.pi * np.fft.fftfreq(Nt, d=dt)\n    # The frequency array must be broadcastable to the shape of hxx_tilde_t\n    # (Nt,) -> (Nt, 1) to multiply with (Nt, Nz)\n    d2hxx_dt2_tilde = -(omega_freqs**2)[:, np.newaxis] * hxx_tilde_t\n    # Step 3: Inverse FFT\n    d2hxx_dt2 = np.fft.ifft(d2hxx_dt2_tilde, axis=0)\n\n    # Compute second spatial derivative using FFT\n    # Step 1: FFT along the space axis (axis=1)\n    hxx_tilde_z = np.fft.fft(hxx, axis=1)\n    # Step 2: Get spatial wavenumbers and multiply by -(k_freq)^2\n    dz = L / Nz\n    k_freqs = 2.0 * np.pi * np.fft.fftfreq(Nz, d=dz)\n    # The frequency array must be broadcastable to the shape of hxx_tilde_z\n    # (Nz,) -> (1, Nz) to multiply with (Nt, Nz)\n    d2hxx_dz2_tilde = -(k_freqs**2)[np.newaxis, :] * hxx_tilde_z\n    # Step 3: Inverse FFT\n    d2hxx_dz2 = np.fft.ifft(d2hxx_dz2_tilde, axis=1)\n\n    # The real parts are taken to discard imaginary noise from FFT numerics\n    d2hxx_dt2_real = d2hxx_dt2.real\n    d2hxx_dz2_real = d2hxx_dz2.real\n\n    # Compute d'Alembertian: Box h_xx = -d2h/dt2 + d2h/dz2\n    box_hxx = -d2hxx_dt2_real + d2hxx_dz2_real\n\n    # Compute Ricci tensor component: R_xx = -0.5 * Box h_xx\n    R1_xx = -0.5 * box_hxx\n\n    # The diagnostic E is the maximum absolute value over all components and the grid.\n    # Since |R_yy| = |-R_xx| = |R_xx| and other components are zero,\n    # we just need the max absolute value of R_xx.\n    error = np.max(np.abs(R1_xx))\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (Nz, Nt, m).\n    test_cases = [\n        (64, 64, 5.0),\n        (8, 8, 1.0),\n        (16, 16, np.sqrt(2)),\n        (32, 32, np.sqrt(2)),\n        (64, 64, np.sqrt(2)),\n        (64, 64, 16.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nz, Nt, m = case\n        result = compute_ricci_error(Nz, Nt, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```", "id": "3494925"}]}