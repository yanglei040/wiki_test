{"hands_on_practices": [{"introduction": "本节的第一个实践是基础性的。我们将构建一个计算核心，直接从给定的度规张量$g_{\\mu\\nu}$出发，计算诸如克氏符号$\\Gamma^{\\rho}{}_{\\mu\\nu}$和里奇张量$R_{\\mu\\nu}$等关键几何量。通过在已知的爱因斯坦方程解析解（如史瓦西时空）上测试该核心程序，我们可以验证代码的正确性，并加深对这些几何对象定义的理解。这个练习是连接理论与数值实践的重要一步。[@problem_id:3493362]", "problem": "要求您实现一个程序，使用数值相对论中的标准解析度规来测试张量计算核心。核心量是度规张量和线元。在几何化单位制（其中 $G=c=1$）下工作，并将所有量视为无量纲。所有角度必须以弧度为单位。您的程序必须针对多个解析时空、指定的坐标点和位移，计算线元的平方，并通过里奇张量验证真空爱因斯坦方程。您的输出必须将所有测试结果汇总到一行中，以逗号分隔的列表形式打印，并用方括号括起来。\n\n使用的基本公式：\n\n- 线元定义为 $ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$，其中 $g_{\\mu\\nu}$ 是度规张量，$dx^{\\mu}$ 是无穷小坐标位移。\n\n- 对于度规兼容、无挠的联络，其列维-奇维塔联络（克里斯托费尔符号）为\n$$\n\\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right),\n$$\n其中 $g^{\\mu\\nu}$ 是 $g_{\\mu\\nu}$ 的逆。\n\n- 逆度规的导数由 $g^{\\mu\\alpha} g_{\\alpha\\nu} = \\delta^{\\mu}{}_{\\nu}$ 推出：\n$$\n\\partial_{\\lambda} g^{\\mu\\nu} = - \\, g^{\\mu\\alpha} \\, (\\partial_{\\lambda} g_{\\alpha\\beta}) \\, g^{\\beta\\nu}.\n$$\n\n- 里奇张量是黎曼曲率张量的缩并：\n$$\nR_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}.\n$$\n\n您的程序必须实现以下要求：\n\n1. 实现通用例程，给定某点上的度规 $g_{\\mu\\nu}(x^{\\lambda})$ 及其一阶和二阶偏导数 $\\partial_{\\lambda} g_{\\mu\\nu}$ 和 $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$，计算：\n   - 逆度规 $g^{\\mu\\nu}$ 及其一阶导数 $\\partial_{\\lambda} g^{\\mu\\nu}$。\n   - 克里斯托费尔符号 $\\Gamma^{\\rho}{}_{\\mu\\nu}$ 及其一阶导数 $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$。\n   - 根据上述定义计算里奇张量 $R_{\\mu\\nu}$。\n\n2. 以闭合形式提供 $g_{\\mu\\nu}$、$\\partial_{\\lambda} g_{\\mu\\nu}$ 和 $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$，从而实现三个解析度规：\n   - 笛卡尔坐标 $(t,x,y,z)$ 下的闵可夫斯基度规，符号为 $(-,+,+,+)$：\n     $$\n     g_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1).\n     $$\n   - 史瓦西坐标 $(t,r,\\theta,\\phi)$ 下的史瓦西度规，质量参数为 $M$：\n     $$\n     g_{tt} = -(1 - 2M/r), \\quad g_{rr} = (1 - 2M/r)^{-1}, \\quad g_{\\theta\\theta} = r^{2}, \\quad g_{\\phi\\phi} = r^{2} \\sin^{2}\\theta,\n     $$\n     所有非对角分量均为 $0$。\n   - Brinkmann 坐标 $(u,v,x,y)$ 下的平行射线的平面阵前引力波（pp-wave）：\n     $$\n     ds^{2} = -2 \\, du \\, dv + H(u,x,y) \\, du^{2} + dx^{2} + dy^{2},\n     $$\n     其中\n     $$\n     H(u,x,y) = \\sin u \\,(x^{2} - y^{2}).\n     $$\n     非零分量为 $g_{uu} = H$，$g_{uv}=g_{vu}=-1$，$g_{xx}=1$，$g_{yy}=1$。\n\n3. 对每个指定的测试用例，计算：\n   - 对于给定的无穷小位移 $dx^{\\mu}$，计算线元的平方 $ds^{2} = g_{\\mu\\nu} dx^{\\mu} dx^{\\nu}$。\n   - 一个真空检查布尔值，定义为\n     $$\n     \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right),\n     $$\n     使用阈值 $\\varepsilon = 10^{-9}$。\n\n4. 测试套件。请精确使用以下参数值和位移：\n\n   - 测试 A (闵可夫斯基):\n     - 坐标 $(t,x,y,z) = (0,\\,1,\\,2,\\,3)$。\n     - 位移 $dx^{\\mu} = (1,\\,0.5,\\,0,\\,0)$。\n     - 预期的定性行为：平直时空，其中 $R_{\\mu\\nu} = 0$。\n\n   - 测试 B (史瓦西):\n     - 质量 $M = 1$。\n     - 坐标 $(t,r,\\theta,\\phi) = (0,\\,10,\\,\\pi/2,\\,0)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$。\n     - 预期的定性行为：真空区域，其中 $R_{\\mu\\nu} = 0$。\n\n   - 测试 C (史瓦西，近视界):\n     - 质量 $M = 1$。\n     - 坐标 $(t,r,\\theta,\\phi) = (0,\\,2.1,\\,\\pi/2,\\,0)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$。\n     - 预期的定性行为：真空区域，其中 $R_{\\mu\\nu} = 0$；接近视界用于测试数值稳定性。\n\n   - 测试 D (pp-wave，对称横向坐标):\n     - 坐标 $(u,v,x,y) = (0.3,\\,0,\\,1,\\,1)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0.5,\\,-0.5)$。\n     - 预期的定性行为：在该点 $H=0$，因此横向分量在 $ds^{2}$ 中占主导；真空解意味着 $R_{\\mu\\nu}=0$。\n\n   - 测试 E (pp-wave，非平凡剖面):\n     - 坐标 $(u,v,x,y) = (1.0,\\,0,\\,2,\\,1)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$。\n     - 预期的定性行为：$ds^{2} = H(u,x,y)$；真空解意味着 $R_{\\mu\\nu}=0$。\n\n5. 输出格式。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按以下顺序将两项附加到列表中：\n   - 计算出的 $ds^{2}$，为一个浮点数（除了语言默认设置外，没有舍入要求）。\n   - 真空检查布尔值 $\\mathrm{vacuum\\_ok}$。\n\n因此，您的程序必须打印包含十个条目的单行：\n$$\n[\\; ds^{2}_{A},\\ \\mathrm{vacuum\\_ok}_{A},\\ ds^{2}_{B},\\ \\mathrm{vacuum\\_ok}_{B},\\ ds^{2}_{C},\\ \\mathrm{vacuum\\_ok}_{C},\\ ds^{2}_{D},\\ \\mathrm{vacuum\\_ok}_{D},\\ ds^{2}_{E},\\ \\mathrm{vacuum\\_ok}_{E} \\;].\n$$", "solution": "用户问题是数值相对论和张量计算领域中一个适定的计算任务，要求实现广义相对论的核心量，并针对已知的爱因斯坦场方程的解析解进行验证。该问题具有科学依据，形式上明确，并且没有任何使其无效的缺陷。可以遵循系统性的、基于原则的方法来构建完整的解决方案。\n\n解决方案分为两个主要部分：\n1. 一组表示解析时空的类，它们以闭合形式提供度规张量 $g_{\\mu\\nu}$ 及其一阶偏导数 $\\partial_{\\lambda}g_{\\mu\\nu}$ 和二阶偏导数 $\\partial_{\\kappa}\\partial_{\\lambda}g_{\\mu\\nu}$。\n2. 一个通用的张量计算引擎，它在给定某点上的这些导数后，计算所有派生量，包括线元平方 $ds^2$ 和里奇张量 $R_{\\mu\\nu}$。\n\n坐标的索引始终从 $0$ 到 $3$。例如，在史瓦西坐标 $(t,r,\\theta,\\phi)$ 中，$t$ 的索引为 $\\mu=0$，$r$ 为 $\\mu=1$，$\\theta$ 为 $\\mu=2$，$\\phi$ 为 $\\mu=3$。所有数组都遵循此约定，例如，张量 $T_{\\lambda\\mu\\nu}$ 存储在 NumPy 数组 `T` 中，其分量通过 `T[l,m,n]` 访问。\n\n核心计算步骤如下：\n\n1.  **度规及其导数**：对于每个测试用例，实例化相应的度规类。该类提供在指定坐标点上的度规张量 $g_{\\mu\\nu}$、其一阶导数 $\\partial_{\\lambda} g_{\\mu\\nu}$ 和二阶导数 $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ 的数值。这些是所有后续计算的基本输入。\n\n2.  **线元平方 $ds^2$**：根据定义，使用爱因斯坦求和约定，从度规 $g_{\\mu\\nu}$ 和给定的坐标位移矢量 $dx^{\\mu}$ 计算线元平方：\n    $$\n    ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}\n    $$\n    这是一个张量缩并，使用矩阵-向量运算高效实现。\n\n3.  **逆度规 $g^{\\mu\\nu}$ 及其导数 $\\partial_{\\lambda}g^{\\mu\\nu}$**：通过数值上对 $g_{\\mu\\nu}$ 的矩阵表示求逆来计算逆度规 $g^{\\mu\\nu}$。然后，使用从 $\\partial_{\\lambda}(g^{\\mu\\alpha}g_{\\alpha\\nu}) = 0$ 推导出的恒等式，从度规的导数计算逆度规的导数：\n    $$\n    \\partial_{\\lambda} g^{\\mu\\nu} = -g^{\\mu\\alpha} (\\partial_{\\lambda} g_{\\alpha\\beta}) g^{\\beta\\nu}\n    $$\n    该公式使用张量积（具体为 `numpy.einsum`）实现。\n\n4.  **克里斯托费尔符号 $\\Gamma^{\\rho}{}_{\\mu\\nu}$ 及其导数 $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$**：第二类克里斯托费尔符号使用度规兼容、无挠联络的标准公式计算：\n    $$\n    \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    克里斯托费尔符号的导数 $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$ 通过对上述表达式应用乘积法则得到：\n    $$\n    \\partial_{\\lambda} \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} (\\partial_{\\lambda} g^{\\rho\\sigma}) \\left( \\dots \\right) + \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\lambda}\\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\lambda}\\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\lambda}\\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    这些计算依赖于步骤1中计算的度规导数和步骤3中的逆度规导数。所有张量缩并都使用 `numpy.einsum` 以提高效率和清晰度。\n\n5.  **里奇张量 $R_{\\mu\\nu}$**：里奇张量根据其定义由克里斯托费尔符号及其导数组装而成：\n    $$\n    R_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}\n    $$\n    每个项都涉及一个或两个指标的缩并，这些缩并再次使用 `numpy.einsum` 实现，或者在 `einsum` 表示法变得模糊时使用显式循环以求清晰。\n\n6.  **真空检查**：计算出的里奇张量 $R_{\\mu\\nu}$ 用于验证时空在指定点是否为真空解。所有给定的时空（闵可夫斯基时空、质量外部的史瓦西时空以及pp-wave）都是精确的真空解，这意味着它们的里奇张量应该恒等于零，$R_{\\mu\\nu}=0$。由于浮点运算，计算出的分量将接近于零，但不会精确为零。因此，真空条件通过数值方式检查：\n    $$\n    \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right)\n    $$\n    其中阈值给定为 $\\varepsilon = 10^{-9}$。\n\n通过为问题中指定的每个测试用例实施这些步骤，我们生成所需的结果序列：每个测试的线元平方 $ds^2$ 和布尔真空检查状态。然后将结果汇总到单个列表中并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\nclass TensorAnalysis:\n    \"\"\"\n    Performs tensor calculus computations given a metric and its derivatives.\n    \"\"\"\n    def __init__(self, g, dg, ddg):\n        self.dim = g.shape[0]\n        self.g = g          # g_mn\n        self.dg = dg        # d_l g_mn\n        self.ddg = ddg      # d_k d_l g_mn\n\n        # Pre-compute all derived quantities\n        self.g_inv = np.linalg.inv(self.g) # g^rs\n        self.dg_inv = self._compute_dg_inv() # d_l g^mn\n        self.gamma = self._compute_gamma() # Gamma^r_mn\n        self.dgamma = self._compute_dgamma() # d_l Gamma^r_mn\n        self.ricci = self._compute_ricci() # R_mn\n\n    def _compute_dg_inv(self):\n        # d_l g^mn = -g^ma (d_l g_ab) g^bn\n        return -np.einsum('ma,lab,bn-lmn', self.g_inv, self.dg, self.g_inv)\n\n    def _compute_gamma(self):\n        # Gamma^r_mn = 1/2 g^rs (d_m g_sn + d_n g_sm - d_s g_mn)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        # The above is a compact way of writing:\n        # christoffel_part_lower[s,m,n] = dg[m,s,n] + dg[n,s,m] - dg[s,m,n]\n        return 0.5 * np.einsum('rs,smn-rmn', self.g_inv, christoffel_part_lower)\n\n    def _compute_dgamma(self):\n        # d_l Gamma^r_mn = 1/2 (d_l g^rs)(...) + 1/2 g^rs (d_l d_m g_sn + ...)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        term1 = 0.5 * np.einsum('lrs,smn-lrmn', self.dg_inv, christoffel_part_lower)\n\n        christoffel_deriv_part_lower = self.ddg.transpose(0, 2, 1, 3) + self.ddg.transpose(0, 3, 1, 2) - self.ddg.transpose(0, 2, 3, 1)        \n        # Above is equivalent to:\n        # cdpl[l,s,m,n] = ddg[l,m,s,n] + ddg[l,n,s,m] - ddg[l,s,m,n]\n        term2 = 0.5 * np.einsum('rs,lsmn-lrmn', self.g_inv, christoffel_deriv_part_lower)\n        \n        return term1 + term2\n\n    def _compute_ricci(self):\n        # R_mn = d_a G^a_mn - d_n G^a_ma + G^a_ab G^b_mn - G^a_mb G^b_an\n        term1 = np.einsum('aamn-mn', self.dgamma)\n        \n        # term2 = d_n G^a_ma. Loop is clearer than tricky einsum.\n        term2 = np.zeros((self.dim, self.dim))\n        for m in range(self.dim):\n            for n in range(self.dim):\n                for a in range(self.dim):\n                    term2[m, n] += self.dgamma[n, a, m, a]\n\n        term3 = np.einsum('aab,bmn-mn', self.gamma, self.gamma)\n        term4 = np.einsum('amb,ban-mn', self.gamma, self.gamma)\n        return term1 - term2 + term3 - term4\n\n    def compute_ds2(self, dx):\n        # ds^2 = g_mn dx^m dx^n\n        return np.einsum('ij,i,j-', self.g, dx, dx)\n\n    def get_ricci_tensor(self):\n        return self.ricci\n\nclass AnalyticMetric:\n    def __init__(self, dim=4, **kwargs):\n        self.dim = dim\n\n    def get_derivatives(self, coords):\n        raise NotImplementedError\n\nclass MinkowskiMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        g = np.diag([-1.0, 1.0, 1.0, 1.0])\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n        return g, dg, ddg\n\nclass SchwarzschildMetric(AnalyticMetric):\n    def __init__(self, M, dim=4):\n        super().__init__(dim)\n        self.M = M\n\n    def get_derivatives(self, coords):\n        _t, r, th, _p = coords\n        M = self.M\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        f = 1.0 - 2.0 * M / r\n        sin_th = np.sin(th)\n        cos_th = np.cos(th)\n        sin_2th = np.sin(2.0 * th)\n        cos_2th = np.cos(2.0 * th)\n\n        # Metric components (non-zero)\n        g[0, 0] = -f\n        g[1, 1] = 1.0 / f\n        g[2, 2] = r**2\n        g[3, 3] = r**2 * sin_th**2\n\n        # First derivatives (only w.r.t r=1 and th=2 are non-zero)\n        # partial_r\n        df_dr = 2.0 * M / r**2\n        gtt_r = -df_dr\n        grr_r = -1.0 / f**2 * df_dr\n        dg[1, 0, 0] = gtt_r\n        dg[1, 1, 1] = grr_r\n        dg[1, 2, 2] = 2.0 * r\n        dg[1, 3, 3] = 2.0 * r * sin_th**2\n        # partial_theta\n        gpp_th = r**2 * sin_2th\n        dg[2, 3, 3] = gpp_th\n\n        # Second derivatives\n        # partial_r partial_r\n        d2f_dr2 = -4.0 * M / r**3\n        gtt_rr = -d2f_dr2\n        grr_rr = (2.0 / f**3) * df_dr**2 - (1.0 / f**2) * d2f_dr2\n        ddg[1, 1, 0, 0] = gtt_rr\n        ddg[1, 1, 1, 1] = grr_rr\n        ddg[1, 1, 2, 2] = 2.0\n        ddg[1, 1, 3, 3] = 2.0 * sin_th**2\n        # partial_th partial_th\n        gpp_thth = r**2 * 2.0 * cos_2th\n        ddg[2, 2, 3, 3] = gpp_thth\n        # partial_r partial_th (mixed)\n        gpp_rth = 2.0 * r * sin_2th\n        ddg[1, 2, 3, 3] = gpp_rth\n        ddg[2, 1, 3, 3] = gpp_rth\n        \n        return g, dg, ddg\n\nclass PPWaveMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        u, _v, x, y = coords\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        sin_u = np.sin(u)\n        cos_u = np.cos(u)\n        \n        H = sin_u * (x**2 - y**2)\n        \n        # Metric components\n        g[0, 0] = H\n        g[0, 1] = g[1, 0] = -1.0\n        g[2, 2] = 1.0\n        g[3, 3] = 1.0\n\n        # First derivatives (only g_00 depends on coords)\n        dg[0, 0, 0] = cos_u * (x**2 - y**2) # d_u g_uu\n        dg[2, 0, 0] = sin_u * (2.0 * x)     # d_x g_uu\n        dg[3, 0, 0] = sin_u * (-2.0 * y)    # d_y g_uu\n\n        # Second derivatives\n        ddg[0, 0, 0, 0] = -sin_u * (x**2 - y**2) # d_u d_u g_uu\n        ddg[2, 2, 0, 0] = sin_u * 2.0             # d_x d_x g_uu\n        ddg[3, 3, 0, 0] = sin_u * -2.0            # d_y d_y g_uu\n        \n        # Mixed derivatives\n        ddg[0, 2, 0, 0] = ddg[2, 0, 0, 0] = cos_u * (2.0 * x)     # d_u d_x g_uu\n        ddg[0, 3, 0, 0] = ddg[3, 0, 0, 0] = cos_u * (-2.0 * y)    # d_u d_y g_uu\n        # d_x d_y g_uu is zero\n\n        return g, dg, ddg\n\ndef solve():\n    test_cases = [\n        {\n            'name': 'A',\n            'metric_class': MinkowskiMetric,\n            'params': {},\n            'coords': np.array([0.0, 1.0, 2.0, 3.0]),\n            'dx': np.array([1.0, 0.5, 0.0, 0.0]),\n        },\n        {\n            'name': 'B',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 10.0, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'C',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 2.1, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'D',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([0.3, 0.0, 1.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.5, -0.5]),\n        },\n        {\n            'name': 'E',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([1.0, 0.0, 2.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    vacuum_threshold = 1e-9\n\n    for case in test_cases:\n        metric_instance = case['metric_class'](**case['params'])\n        g, dg, ddg = metric_instance.get_derivatives(case['coords'])\n        \n        analysis = TensorAnalysis(g, dg, ddg)\n        \n        ds2 = analysis.compute_ds2(case['dx'])\n        ricci = analysis.get_ricci_tensor()\n        \n        max_abs_ricci = np.max(np.abs(ricci))\n        vacuum_ok = max_abs_ricci  vacuum_threshold\n        \n        results.append(ds2)\n        results.append(vacuum_ok)\n    \n    # Format boolean as lowercase 'true'/'false' for consistency, then join.\n    formatted_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```", "id": "3493362"}, {"introduction": "在数值模拟中，时空度规是动态演化的，数值误差可能导致非物理的结果。本实践关注一项关键的诊断任务：验证一个给定的度规张量是否保持其物理属性。具体来说，我们将检验其是否具有正确的洛伦兹符号$(-,+,+,+)$以及其诱导的三维空间度规是否为正定，这对于保证时空具有明确的因果结构至关重要。[@problem_id:3493424]", "problem": "一个时空度规张量 $g_{\\mu\\nu}$ 在数值相对论模拟中决定了线元 $ds^2 = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$ 以及矢量的因果特性。在与引力波建模相关的物理有效洛伦兹时空中，度规必须具有 $(-,+,+,+)$ 号差，其诱导的 $3\\times 3$ 空间块必须是正定的，并且线元必须一致地对代表性矢量进行分类：在光速 $c=1$ 的单位制下，一个类时矢量 $u^{\\mu}$ 必须产生 $ds^2  0$，而一个类空矢量 $s^{\\mu}$ 必须产生 $ds^2  0$。你的任务是编写一个程序，为给定的度规和矢量测试套件验证这些属性，这对于在模拟中捕获号差或正定性违规是必需的。\n\n使用的基本和核心定义：\n- 度规张量 $g_{\\mu\\nu}$ 是对称的，并为任意切矢量 $v^{\\mu}$ 定义了线元 $ds^2 = g_{\\mu\\nu} \\, v^{\\mu} \\, v^{\\nu}$ 的双线性形式。\n- 根据西尔维斯特惯性定律，如果对称矩阵 $g_{\\mu\\nu}$ 的负、正、零特征值的数量是不变的，并且等于一个负特征值和三个正特征值，且没有零特征值（非简并），那么该度规具有洛伦兹号差 $(-,+,+,+)$。\n- 在 $3+1$ 分解中，诱导空间度规 $\\gamma_{ij} \\equiv g_{ij}$（在坐标 $(t,x,y,z)$ 中，索引 $i,j \\in \\{1,2,3\\}$ 的空间 $3\\times 3$ 块）必须是正定的，即其所有特征值都必须严格为正。\n- 对于 $(-,+,+,+)$ 号差的因果分类：对于一个物理上可实现的类时矢量 $u^{\\mu}$，有 $ds^2 = g_{\\mu\\nu} u^{\\mu} u^{\\nu}  0$；对于一个类空矢量 $s^{\\mu}$，有 $ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu}  0$。\n\n数值分类规则：\n- 为模拟浮点效应，使用容差 $\\epsilon = 10^{-10}$ 对特征值和线元进行分类。如果一个特征值 $ -\\epsilon$，则计为负；如果 $ \\epsilon$，则计为正；如果其绝对值 $\\le \\epsilon$，则计为零（简并）。对于线元分类，要求类时矢量满足 $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$，类空矢量满足 $g_{\\mu\\nu} s^{\\mu} s^{\\nu}  \\epsilon$。\n\n测试套件：\n- 案例 A (闵可夫斯基时空)：$g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1)$，$u^{\\mu}=(1,\\,0,\\,0,\\,0)$，$s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 B (横向无迹 (TT) 正偏振引力波，弱场快照)：$h=10^{-3}$，$g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1+h,\\,1-h,\\,1)$，$u^{\\mu}=(1,\\,0,\\,0,\\,0)$，$s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 C (欧几里得度规，对相对论无效)：$g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1,\\,1,\\,1,\\,1)$，$u^{\\mu}=(1,\\,0,\\,0,\\,0)$，$s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 D (近简并边界情况)：$g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12},\\,1,\\,1,\\,1)$，$u^{\\mu}=(1,\\,0,\\,0,\\,0)$，$s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 E (TT 交叉偏振引力波，带非对角空间项的弱场快照)：$h=0.05$，分量 $g^{(E)}_{00}=-1$，$g^{(E)}_{11}=1$，$g^{(E)}_{22}=1$，$g^{(E)}_{33}=1$，$g^{(E)}_{12}=g^{(E)}_{21}=h$，所有其他分量为零；$u^{\\mu}=(1,\\,0,\\,0,\\,0)$，$s^{\\mu}=(0,\\,1,\\,1,\\,0)$。\n\n程序要求：\n- 对每个案例，计算：\n    1. 完整度规是否在容差 $\\epsilon$ 内具有洛伦兹号差 $(-,+,+,+)$。\n    2. 空间 $3\\times 3$ 块 $g_{ij}$ 是否在容差 $\\epsilon$ 内是正定的。\n    3. $u^{\\mu}$ 和 $s^{\\mu}$ 的线元是否满足 $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$ 和 $g_{\\mu\\nu} s^{\\mu} s^{\\nu}  \\epsilon$。\n- 为每个案例返回一个布尔值，当且仅当该案例的所有三项检查都通过时，该值为真。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是对应于案例 $k \\in \\{A,B,C,D,E\\}$ 的布尔值。", "solution": "该问题要求根据数值相对论和引力波建模中物理相关性所需的一组基本属性，对几个给定的时空度规 $g_{\\mu\\nu}$ 进行验证。如果一个度规同时满足三个特定标准，即具有正确的洛伦兹号差、诱导一个正定的空间度规、并正确分类代表性测试矢量的因果特性，则该度规在给定案例中被视为有效。\n\n每个案例的验证过程通过执行基于所提供定义的三个顺序检查来进行。所有浮点比较均使用数值容差 $\\epsilon = 10^{-10}$。\n\n1.  **洛伦兹号差验证**：一个 $4 \\times 4$ 度规张量 $g_{\\mu\\nu}$ 具有洛伦兹号差 $(-,+,+,+)$ 当且仅当其特征值由一个负值、三个正值且没有零值组成。为验证此点，我们计算 $g_{\\mu\\nu}$ 矩阵表示的特征值。使用指定的容差 $\\epsilon$，如果特征值 $\\lambda  -\\epsilon$，则计为负；如果 $\\lambda  \\epsilon$，则计为正；如果 $|\\lambda| \\le \\epsilon$，则计为零。如果计数结果为一个负、三个正和零个“零”特征值，则该度规是非简并的洛伦兹度规。\n\n2.  **正定空间度规验证**：在时空的 $3+1$ 分解中，诱导空间度规 $\\gamma_{ij}$ 是 $g_{\\mu\\nu}$ 中对应于空间索引 $i, j \\in \\{1, 2, 3\\}$（对于坐标 $(x^0, x^1, x^2, x^3)$）的 $3 \\times 3$ 子矩阵。对于物理上有效的时空，$\\gamma_{ij}$ 必须是正定的，意味着其所有特征值都必须严格为正。我们通过计算 $\\gamma_{ij}$ 的三个特征值并确保每个都大于容差 $\\epsilon$ 来检查这一点。\n\n3.  **因果特性验证**：线元 $ds^2 = g_{\\mu\\nu} v^{\\mu} v^{\\nu}$ 决定了矢量 $v^{\\mu}$ 的因果性质。对于给定的测试矢量，一个类时矢量 $u^{\\mu}$ 必须满足 $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$，一个类空矢量 $s^{\\mu}$ 必须满足 $g_{\\mu\\nu} s^{\\mu} s^{\\nu}  \\epsilon$。这通过矩阵-矢量乘法计算为 $(v)^T g v$。\n\n当且仅当所有这三项检查都成功时，一个案例才通过整体验证。我们现在将此流程应用于每个测试案例。\n\n**案例 A：闵可夫斯基时空**\n-   度规：$g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1, 1, 1)$。\n-   矢量：$u^{\\mu} = (1, 0, 0, 0)$，$s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **号差**：对角矩阵 $g^{(A)}_{\\mu\\nu}$ 的特征值是其对角元素：$\\{-1, 1, 1, 1\\}$。有一个负特征值和三个正特征值。所有值都远在容差区域之外。此项检查**通过**。\n2.  **空间度规**：空间块为 $\\gamma^{(A)}_{ij} = \\mathrm{diag}(1, 1, 1)$。其特征值为 $\\{1, 1, 1\\}$，所有值都大于 $\\epsilon$。此项检查**通过**。\n3.  **因果特性**：\n    -   对于 $u^{\\mu}$，$ds^2 = g_{00} (u^0)^2 = (-1)(1)^2 = -1$。因为 $-1  -\\epsilon$，此项检查**通过**。\n    -   对于 $s^{\\mu}$，$ds^2 = g_{11} (s^1)^2 = (1)(1)^2 = 1$。因为 $1  \\epsilon$，此项检查**通过**。\n\n所有三项检查都通过。案例 A 的结果为**真 (True)**。\n\n**案例 B：TT 正偏振引力波**\n-   度规：$g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1+h, 1-h, 1)$，其中 $h = 10^{-3}$。因此，$g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1.001, 0.999, 1)$。\n-   矢量：$u^{\\mu} = (1, 0, 0, 0)$，$s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **号差**：特征值为 $\\{-1, 1.001, 0.999, 1\\}$。有一个负特征值和三个正特征值。此项检查**通过**。\n2.  **空间度规**：空间块为 $\\gamma^{(B)}_{ij} = \\mathrm{diag}(1.001, 0.999, 1)$。其特征值为 $\\{1.001, 0.999, 1\\}$，均为正。此项检查**通过**。\n3.  **因果特性**：\n    -   对于 $u^{\\mu}$，$ds^2 = g_{00} (u^0)^2 = -1  -\\epsilon$。此项检查**通过**。\n    -   对于 $s^{\\mu}$，$ds^2 = g_{11} (s^1)^2 = (1+h)(1)^2 = 1.001  \\epsilon$。此项检查**通过**。\n\n所有三项检查都通过。案例 B 的结果为**真 (True)**。\n\n**案例 C：欧几里得度规**\n-   度规：$g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1, 1, 1, 1)$。\n-   矢量：$u^{\\mu} = (1, 0, 0, 0)$，$s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **号差**：特征值为 $\\{1, 1, 1, 1\\}$。有零个负特征值和四个正特征值。这违反了 $(-,+,+,+)$ 号差要求。此项检查**失败**。\n\n由于第一项检查失败，该案例的整体结果已确定。案例 C 的结果为**假 (False)**。\n\n**案例 D：近简并度规**\n-   度规：$g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12}, 1, 1, 1)$。\n-   矢量：$u^{\\mu} = (1, 0, 0, 0)$，$s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **号差**：特征值为 $\\{-10^{-12}, 1, 1, 1\\}$。我们检查特征值 $\\lambda_0 = -10^{-12}$ 与容差 $\\epsilon = 10^{-10}$ 的关系。因为 $|\\lambda_0| = 10^{-12} \\le 10^{-10}$，该特征值被分类为零。计数结果为零个负特征值、三个正特征值和一个零特征值。这违反了非简并洛伦兹号差的要求。此项检查**失败**。\n\n该案例无效。为完整起见，我们注意到对 $u^{\\mu}$ 的因果检查也失败了：$ds^2 = g_{00}(u^0)^2 = -10^{-12}$。条件 $ds^2  -\\epsilon$ 变为 $-10^{-12}  -10^{-10}$，这是错误的。案例 D 的结果为**假 (False)**。\n\n**案例 E：TT 交叉偏振引力波**\n-   度规：$g^{(E)}_{\\mu\\nu}$ 的分量为 $g_{00}=-1$，$g_{11}=g_{22}=g_{33}=1$，$g_{12}=g_{21}=h=0.05$。矩阵形式为：\n$$g^{(E)}_{\\mu\\nu} = \\begin{pmatrix} -1  0  0  0 \\\\ 0  1  0.05  0 \\\\ 0  0.05  1  0 \\\\ 0  0  0  1 \\end{pmatrix}$$\n-   矢量：$u^{\\mu} = (1, 0, 0, 0)$，$s^{\\mu} = (0, 1, 1, 0)$。\n\n1.  **号差**：矩阵是块对角的。特征值是各块的特征值：$\\{-1\\}$，$\\{1\\}$，以及子矩阵 $\\begin{pmatrix} 1  0.05 \\\\ 0.05  1 \\end{pmatrix}$。这个 $2 \\times 2$ 子矩阵的特征值是 $\\lambda = 1 \\pm 0.05$，即 $1.05$ 和 $0.95$。$g^{(E)}_{\\mu\\nu}$ 的完整特征值集合是 $\\{-1, 1.05, 0.95, 1\\}$。有一个负特征值和三个正特征值。此项检查**通过**。\n2.  **空间度规**：空间块为 $\\gamma^{(E)}_{ij} = \\begin{pmatrix} 1  0.05  0 \\\\ 0.05  1  0 \\\\ 0  0  1 \\end{pmatrix}$。其特征值为 $\\{1.05, 0.95, 1\\}$，均为正。此项检查**通过**。\n3.  **因果特性**：\n    -   对于 $u^{\\mu}$，$ds^2 = g_{00} (u^0)^2 = -1  -\\epsilon$。此项检查**通过**。\n    -   对于 $s^{\\mu}$，$ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} = g_{11}(s^1)^2 + g_{22}(s^2)^2 + 2g_{12}s^1 s^2 = (1)(1)^2 + (1)(1)^2 + 2(0.05)(1)(1) = 1 + 1 + 0.1 = 2.1$。因为 $2.1  \\epsilon$，此项检查**通过**。\n\n所有三项检查都通过。案例 E 的结果为**真 (True)**。\n\n最终布尔值总结：\n- 案例 A：真\n- 案例 B：真\n- 案例 C：假\n- 案例 D：假\n- 案例 E：真", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a test suite of spacetime metrics against physical criteria.\n\n    For each case, the program checks:\n    1. If the 4x4 metric has Lorentzian signature (-,+,+,+).\n    2. If the 3x3 spatial sub-metric is positive-definite.\n    3. If representative time-like and space-like vectors are correctly classified.\n\n    A case is valid (True) if and only if all three checks pass.\n    \"\"\"\n    \n    # Define the tolerance for floating-point comparisons as per the problem.\n    epsilon = 1e-10\n\n    # Test Case A: Minkowski spacetime\n    g_A = np.diag([-1.0, 1.0, 1.0, 1.0])\n    u_A = np.array([1.0, 0.0, 0.0, 0.0])\n    s_A = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case B: Transverse-Traceless (TT) plus-polarized gravitational wave\n    h_B = 1e-3\n    g_B = np.diag([-1.0, 1.0 + h_B, 1.0 - h_B, 1.0])\n    u_B = np.array([1.0, 0.0, 0.0, 0.0])\n    s_B = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case C: Euclidean metric (invalid for relativity)\n    g_C = np.diag([1.0, 1.0, 1.0, 1.0])\n    u_C = np.array([1.0, 0.0, 0.0, 0.0])\n    s_C = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case D: Near-degenerate boundary case\n    g_D = np.diag([-1e-12, 1.0, 1.0, 1.0])\n    u_D = np.array([1.0, 0.0, 0.0, 0.0])\n    s_D = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case E: TT cross-polarized gravitational wave\n    h_E = 0.05\n    g_E = np.array([\n        [-1.0, 0.0, 0.0, 0.0],\n        [0.0, 1.0, h_E, 0.0],\n        [0.0, h_E, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0]\n    ])\n    u_E = np.array([1.0, 0.0, 0.0, 0.0])\n    s_E = np.array([0.0, 1.0, 1.0, 0.0])\n\n    test_cases = [\n        (g_A, u_A, s_A),\n        (g_B, u_B, s_B),\n        (g_C, u_C, s_C),\n        (g_D, u_D, s_D),\n        (g_E, u_E, s_E),\n    ]\n\n    results = []\n    for g, u, s in test_cases:\n        # Check 1: Lorentzian signature\n        # Use np.linalg.eigvalsh as the metrics are real symmetric matrices.\n        eigs_g = np.linalg.eigvalsh(g)\n        \n        neg_count = np.sum(eigs_g  -epsilon)\n        pos_count = np.sum(eigs_g > epsilon)\n        zero_count = np.sum(np.abs(eigs_g) = epsilon)\n        \n        is_lorentzian = (neg_count == 1 and pos_count == 3 and zero_count == 0)\n\n        # Check 2: Positive-definite spatial metric\n        gamma = g[1:, 1:]\n        eigs_gamma = np.linalg.eigvalsh(gamma)\n        \n        is_spatial_pos_def = np.all(eigs_gamma > epsilon)\n\n        # Check 3: Causal classification\n        # Calculate line elements using matrix multiplication: v.T @ g @ v\n        ds2_u = u @ g @ u\n        ds2_s = s @ g @ s\n        \n        is_causal_correct = (ds2_u  -epsilon and ds2_s > epsilon)\n        \n        # A case is valid if and only if all three checks pass.\n        case_result = is_lorentzian and is_spatial_pos_def and is_causal_correct\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493424"}, {"introduction": "广义协变性原理指出，物理定律与所使用的坐标系无关。本实践将通过关注线元$ds^2$的不变性，来动手展示这一核心原理。我们将利用雅可比矩阵在不同坐标系之间变换度规张量，并数值验证对于同一个物理位移，计算出的$ds^2$值保持不变，从而将抽象的理论概念转化为具体的计算验证。[@problem_id:3493437]", "problem": "考虑一个在横向无迹规范下沿 $+z$ 方向传播的弱场平面引力波。在光速 $c = 1$ 的几何化单位制中，笛卡尔坐标 $(t,x,y,z)$ 下的线元由度规张量的分量 $g_{\\mu\\nu}(t,x,y,z)$ 定义，使得线元满足 $ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu$，其中指标 $\\mu,\\nu \\in \\{0,1,2,3\\}$ 分别对应于 $(t,x,y,z)$。度规的非零分量由 $g_{00} = -1$, $g_{11} = 1 + h_+(u)$, $g_{22} = 1 - h_+(u)$, $g_{33} = 1$ 给出，其中 $u = t - z$，$h_+(u)$ 是一个给定的可微函数，描述了引力波的“+”偏振。在本问题中，取 $h_+(u) = \\varepsilon \\sin(\\omega u)$，其中 $\\varepsilon$ 是一个小的无量纲振幅，$\\omega$ 是角频率，单位为弧度每单位时间。\n\n您将使用基于雅可比矩阵的变换来检验不同坐标片之间的匹配，并验证线元在坐标变换下的不变性。基本的出发点是线元 $ds^2$ 的定义、其在光滑坐标变换下的不变性要求，以及微分的链式法则。您不能假设或使用任何用于变换度规的快捷公式；您必须从 $ds^2$ 的不变性和链式法则中推导出所有必要的关系。\n\n考虑两个坐标片：\n\n1. 一个旋转后的笛卡尔坐标片 $(t',x',y',z')$，由在 $x$–$y$ 平面内旋转角度 $\\alpha$（以弧度为单位）定义，具体为：\n   $$\n   t = t', \\quad z = z', \\quad x = x' \\cos\\alpha - y' \\sin\\alpha, \\quad y = x' \\sin\\alpha + y' \\cos\\alpha.\n   $$\n\n2. 一个球面空间坐标片 $(t,r,\\theta,\\phi)$，其中角度以弧度为单位，由以下关系指定：\n   $$\n   t = t, \\quad x = r \\sin\\theta \\cos\\phi, \\quad y = r \\sin\\theta \\sin\\phi, \\quad z = r \\cos\\theta.\n   $$\n\n对每个坐标片，通过链式法则构建从该坐标片坐标到笛卡尔坐标变换的雅可比矩阵元素，用它们计算出与 $ds^2$ 不变性一致的在该坐标片下的度规分量，然后通过计算在两个坐标系中表示的同一物理位移的 $ds^2$ 来验证线元的不变性。\n\n将给定测试用例的差异定义为在原始笛卡尔坐标中计算的线元与在变换后的坐标片中为同一物理位移计算的线元之间的绝对差。具体来说，给定坐标片中的一个微小位移矢量，使用雅可比矩阵计算其在笛卡尔坐标中对应的位移，在同一事件点计算两个线元，并以浮点数形式报告其绝对差。角度必须以弧度指定。\n\n您的程序必须为以下测试套件实现此验证。在所有情况下，角度均以弧度为单位，您应将差异报告为无量纲的浮点数。\n\n- 测试用例1（旋转笛卡尔，一般情况）：\n  - 参数：$\\varepsilon = 10^{-3}$，$\\omega = 100$，$\\alpha = \\pi/6$。\n  - 旋转坐标系中的事件：$(t',x',y',z') = (0.3, 0.1, -0.2, 0.5)$。\n  - 旋转坐标系中的位移：$(dt', dx', dy', dz') = (10^{-3}, 2\\times 10^{-3}, -10^{-3}, 1.5\\times 10^{-3})$。\n\n- 测试用例2（旋转笛卡尔，近单位旋转边界）：\n  - 参数：$\\varepsilon = 10^{-3}$，$\\omega = 100$，$\\alpha = 10^{-8}$。\n  - 旋转坐标系中的事件：$(t',x',y',z') = (0.3, 0.1, -0.2, 0.5)$。\n  - 旋转坐标系中的位移：$(dt', dx', dy', dz') = (10^{-3}, -10^{-3}, 1.5\\times 10^{-3}, -2\\times 10^{-3})$。\n\n- 测试用例3（球面坐标片，近极轴边界）：\n  - 参数：$\\varepsilon = 10^{-4}$，$\\omega = 250$。\n  - 球面坐标系中的事件：$(t,r,\\theta,\\phi) = (0.25, 1.2, 10^{-6}, 1.0)$。\n  - 球面坐标系中的位移：$(dt, dr, d\\theta, d\\phi) = (10^{-3}, 5\\times 10^{-4}, 10^{-6}, 10^{-3})$。\n\n- 测试用例4（球面坐标片，赤道情况）：\n  - 参数：$\\varepsilon = 10^{-3}$，$\\omega = 50$。\n  - 球面坐标系中的事件：$(t,r,\\theta,\\phi) = (0.1, 2.0, \\pi/2, 2.0)$。\n  - 球面坐标系中的位移：$(dt, dr, d\\theta, d\\phi) = (5\\times 10^{-4}, -10^{-3}, 2\\times 10^{-3}, -10^{-3})$。\n\n您的程序应产生单行输出，其中包含四个测试用例的差异，形式为方括号括起来的逗号分隔列表（例如，$\\,[result_1, result_2, result_3, result_4]$，其中每个 $result_i$ 是一个浮点数）。由于使用了几何化单位制并且差异是无量纲的，因此不需要单位。所有计算中角度都必须按弧度处理。", "solution": "目标是通过从第一性原理出发在新坐标中构建度规，来验证线元 $ds^2$ 在光滑坐标变换下的不变性。基本依据是线元的定义 $ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu$、$ds^2$ 代表相邻事件间不变平方间隔的要求，以及微分的链式法则。\n\n出发点：\n\n1. 笛卡尔坐标 $(t,x,y,z)$ 中的线元由以下度规分量指定：\n   $$\n   g_{00} = -1, \\quad g_{11} = 1 + h_+(u), \\quad g_{22} = 1 - h_+(u), \\quad g_{33} = 1,\n   $$\n   其中 $u = t - z$，$h_+(u) = \\varepsilon \\sin(\\omega u)$，$\\varepsilon$ 和 $\\omega$ 为给定参数。\n\n2. 线元在坐标变换下的不变性表明，如果引入新坐标 $x'^a$（指标 $a \\in \\{0,1,2,3\\}$），那么在带撇坐标中计算的平方间隔等于在同一时空事件点上，在不带撇坐标中计算的平方间隔：\n   $$\n   ds^2 = g_{\\mu\\nu}(x) \\, dx^\\mu \\, dx^\\nu = g'_{ab}(x') \\, dx'^a \\, dx'^b.\n   $$\n   $g'_{ab}(x')$ 是带撇坐标系中的度规张量。\n\n3. 微分的链式法则通过变换 $x^\\mu(x')$ 的雅可比矩阵将两个系统中的坐标微分联系起来：\n   $$\n   dx^\\mu = \\frac{\\partial x^\\mu}{\\partial x'^a} \\, dx'^a.\n   $$\n   将此代入不带撇的 $ds^2$ 表达式中，并与带撇的表达式进行比较，即可得到度规的变换法则：\n   $$\n   ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu = g_{\\mu\\nu} \\left( \\frac{\\partial x^\\mu}{\\partial x'^a} \\, dx'^a \\right) \\left( \\frac{\\partial x^\\nu}{\\partial x'^b} \\, dx'^b \\right) = \\left( \\frac{\\partial x^\\mu}{\\partial x'^a} \\frac{\\partial x^\\nu}{\\partial x'^b} g_{\\mu\\nu} \\right) dx'^a dx'^b,\n   $$\n   这意味着\n   $$\n   g'_{ab}(x') = \\frac{\\partial x^\\mu}{\\partial x'^a} \\frac{\\partial x^\\nu}{\\partial x'^b} g_{\\mu\\nu}(x).\n   $$\n   以矩阵形式表示，如果用 $J$ 表示其元素为 $J^\\mu{}_a = \\partial x^\\mu / \\partial x'^a$ 的雅可比矩阵，用 $g$ 表示其元素为 $g_{\\mu\\nu}$ 的矩阵，那么带撇的度规为 $g' = J^\\top g J$。\n\n基于这些原理，我们为这两个坐标片构建雅可比矩阵，并通过比较在两个坐标系中表示的同一物理位移的线元来数值验证其不变性。\n\n旋转后的笛卡尔坐标片：\n\n- 变换由下式给出\n  $$\n  t = t', \\quad z = z', \\quad x = x' \\cos\\alpha - y' \\sin\\alpha, \\quad y = x' \\sin\\alpha + y' \\cos\\alpha,\n  $$\n  这给出了雅可比矩阵的元素：\n  $$\n  \\frac{\\partial t}{\\partial t'} = 1, \\quad \\frac{\\partial t}{\\partial x'} = \\frac{\\partial t}{\\partial y'} = \\frac{\\partial t}{\\partial z'} = 0,\n  $$\n  $$\n  \\frac{\\partial x}{\\partial x'} = \\cos\\alpha, \\quad \\frac{\\partial x}{\\partial y'} = -\\sin\\alpha, \\quad \\frac{\\partial x}{\\partial z'} = 0, \\quad \\frac{\\partial x}{\\partial t'} = 0,\n  $$\n  $$\n  \\frac{\\partial y}{\\partial x'} = \\sin\\alpha, \\quad \\frac{\\partial y}{\\partial y'} = \\cos\\alpha, \\quad \\frac{\\partial y}{\\partial z'} = 0, \\quad \\frac{\\partial y}{\\partial t'} = 0,\n  $$\n  $$\n  \\frac{\\partial z}{\\partial z'} = 1, \\quad \\frac{\\partial z}{\\partial t'} = \\frac{\\partial z}{\\partial x'} = \\frac{\\partial z}{\\partial y'} = 0.\n  $$\n  因此，雅可比矩阵 $J$ 除了对 $\\alpha$ 的依赖外，相对于 $(x',y',z')$ 是常数。给定一个事件 $(t',x',y',z')$，使用旋转公式将其映射到 $(t,x,y,z)$，计算 $u = t - z$，计算 $h_+(u)$，构建 $g_{\\mu\\nu}(t,x,y,z)$，然后计算 $g'_{ab} = J^\\top g J$。\n\n- 为验证不变性，取一个位移 $dx'^a = (dt',dx',dy',dz')$，通过 $dx^\\mu = J^\\mu{}_a \\, dx'^a$ 计算相应的笛卡尔位移，并构造\n  $$\n  ds'^2 = g'_{ab} \\, dx'^a \\, dx'^b, \\quad ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu.\n  $$\n  报告的差异为 $|ds'^2 - ds^2|$。\n\n球面空间坐标片：\n\n- 变换由下式给出\n  $$\n  t = t, \\quad x = r \\sin\\theta \\cos\\phi, \\quad y = r \\sin\\theta \\sin\\phi, \\quad z = r \\cos\\theta.\n  $$\n  非零的雅可比矩阵元素可由偏导数得出：\n  $$\n  \\frac{\\partial t}{\\partial t} = 1, \\quad \\frac{\\partial t}{\\partial r} = \\frac{\\partial t}{\\partial \\theta} = \\frac{\\partial t}{\\partial \\phi} = 0,\n  $$\n  $$\n  \\frac{\\partial x}{\\partial r} = \\sin\\theta \\cos\\phi, \\quad \\frac{\\partial x}{\\partial \\theta} = r \\cos\\theta \\cos\\phi, \\quad \\frac{\\partial x}{\\partial \\phi} = -r \\sin\\theta \\sin\\phi,\n  $$\n  $$\n  \\frac{\\partial y}{\\partial r} = \\sin\\theta \\sin\\phi, \\quad \\frac{\\partial y}{\\partial \\theta} = r \\cos\\theta \\sin\\phi, \\quad \\frac{\\partial y}{\\partial \\phi} = r \\sin\\theta \\cos\\phi,\n  $$\n  $$\n  \\frac{\\partial z}{\\partial r} = \\cos\\theta, \\quad \\frac{\\partial z}{\\partial \\theta} = -r \\sin\\theta, \\quad \\frac{\\partial z}{\\partial \\phi} = 0.\n  $$\n  利用这些，在事件点 $(t,r,\\theta,\\phi)$ 构造 $J^\\mu{}_a$。该事件通过上述关系映射到笛卡尔坐标，计算 $u = t-z$，求出 $h_+(u)$ 的值，并构成 $g_{\\mu\\nu}$。然后通过 $g'_{ab} = J^\\top g J$ 得到球面坐标下的度规。\n\n- 为验证不变性，对于位移 $dx^a = (dt,dr,d\\theta,d\\phi)$，计算 $dx^\\mu = J^\\mu{}_a \\, dx^a$，构造\n  $$\n  ds'^2 = g'_{ab} \\, dx^a \\, dx^b, \\quad ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu,\n  $$\n  并报告差异 $|ds'^2 - ds^2|$。\n\n数值考虑：\n\n- 由于变换是光滑的，且度规是根据 $ds^2$ 的不变性构建的，所以差异应该在浮点舍入误差的量级上。在坐标奇点附近（例如，$\\theta \\approx 0$），雅可比矩阵可能变得病态，有限精度算术可能会放大误差；尽管如此，对于小位移，不变性应在数值容差范围内成立。\n\n算法设计：\n\n- 实现函数 $h_+(u) = \\varepsilon \\sin(\\omega u)$。\n- 实现一个函数来构建笛卡尔坐标下的 $g_{\\mu\\nu}(t,x,y,z)$。\n- 实现函数来构建旋转笛卡尔坐标片和球面坐标片的雅可比矩阵，并在坐标片和笛卡尔坐标之间映射坐标。\n- 对每个测试用例，计算 $J$，将事件映射到笛卡尔坐标，构建 $g$，计算 $g'$，然后为给定位移在两个坐标系中计算 $ds^2$，并报告绝对差。\n- 将四个差异汇总到指定格式的单行输出中。\n\n所有角度都以弧度处理，所有报告的差异都是无量纲浮点数，与几何化单位制一致。", "answer": "```python\n# Python 3.12 program to verify invariance of the line element across coordinate patches\n# under Jacobian transformations for a weak-field plane gravitational wave metric.\n# Uses numpy 1.23.5; no other external libraries are required.\n\nimport numpy as np\n\ndef h_plus(u, eps, omega):\n    \"\"\"Plus polarization of the gravitational wave: h_+(u) = eps * sin(omega * u).\"\"\"\n    return eps * np.sin(omega * u)\n\ndef metric_cartesian(t, x, y, z, eps, omega):\n    \"\"\"\n    Construct the 4x4 metric tensor in Cartesian coordinates for the plane gravitational wave\n    in transverse-traceless gauge with plus polarization, in geometrized units (c=1).\n    Coordinates: (t, x, y, z) - indices (0,1,2,3).\n    \"\"\"\n    u = t - z\n    hp = h_plus(u, eps, omega)\n    g = np.zeros((4, 4), dtype=float)\n    g[0, 0] = -1.0\n    g[1, 1] = 1.0 + hp\n    g[2, 2] = 1.0 - hp\n    g[3, 3] = 1.0\n    return g\n\ndef jacobian_rotation(alpha):\n    \"\"\"\n    Jacobian J^mu{}_a = ∂x^mu/∂x'^a for rotation in the x-y plane:\n    t = t', z = z', x = x' cos α - y' sin α, y = x' sin α + y' cos α.\n    Coordinates ordering: (t,x,y,z) for mu; (t',x',y',z') for a.\n    \"\"\"\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n    J = np.zeros((4, 4), dtype=float)\n    # t row\n    J[0, 0] = 1.0\n    # x row\n    J[1, 1] = ca\n    J[1, 2] = -sa\n    # y row\n    J[2, 1] = sa\n    J[2, 2] = ca\n    # z row\n    J[3, 3] = 1.0\n    return J\n\ndef map_event_rotation(t_p, x_p, y_p, z_p, alpha):\n    \"\"\"\n    Map event from rotated coordinates (t', x', y', z') to Cartesian (t, x, y, z)\n    using the rotation relations.\n    \"\"\"\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n    t = t_p\n    x = x_p * ca - y_p * sa\n    y = x_p * sa + y_p * ca\n    z = z_p\n    return t, x, y, z\n\ndef jacobian_spherical(t, r, theta, phi):\n    \"\"\"\n    Jacobian J^mu{}_a = ∂x^mu/∂x^a for spherical spatial coordinates:\n    t = t, x = r sinθ cosφ, y = r sinθ sinφ, z = r cosθ.\n    Coordinates ordering: mu=(t,x,y,z), a=(t,r,theta,phi).\n    \"\"\"\n    st = np.sin(theta)\n    ct = np.cos(theta)\n    cf = np.cos(phi)\n    sf = np.sin(phi)\n    J = np.zeros((4, 4), dtype=float)\n    # t row\n    J[0, 0] = 1.0\n    # x row\n    J[1, 1] = st * cf\n    J[1, 2] = r * ct * cf\n    J[1, 3] = -r * st * sf\n    # y row\n    J[2, 1] = st * sf\n    J[2, 2] = r * ct * sf\n    J[2, 3] = r * st * cf\n    # z row\n    J[3, 1] = ct\n    J[3, 2] = -r * st\n    # J[3, 3] remains 0\n    return J\n\ndef map_event_spherical(t_s, r, theta, phi):\n    \"\"\"\n    Map event from spherical coordinates (t, r, theta, phi) to Cartesian (t, x, y, z).\n    \"\"\"\n    st = np.sin(theta)\n    ct = np.cos(theta)\n    cf = np.cos(phi)\n    sf = np.sin(phi)\n    x = r * st * cf\n    y = r * st * sf\n    z = r * ct\n    return t_s, x, y, z\n\ndef ds2_from_metric_and_displacement(g, dx):\n    \"\"\"Compute ds^2 = dx^T g dx.\"\"\"\n    return float(dx.T @ (g @ dx))\n\ndef run_rotation_case(eps, omega, alpha, event_p, disp_p):\n    \"\"\"\n    Compute discrepancy |ds'^2 - ds^2| for rotated Cartesian patch.\n    event_p: (t', x', y', z'), disp_p: (dt', dx', dy', dz').\n    \"\"\"\n    t_p, x_p, y_p, z_p = event_p\n    dt_p, dx_p, dy_p, dz_p = disp_p\n    J = jacobian_rotation(alpha)\n    t, x, y, z = map_event_rotation(t_p, x_p, y_p, z_p, alpha)\n    g = metric_cartesian(t, x, y, z, eps, omega)\n    g_p = J.T @ g @ J\n    dxp = np.array([dt_p, dx_p, dy_p, dz_p], dtype=float)\n    dx = J @ dxp\n    ds2_p = ds2_from_metric_and_displacement(g_p, dxp)\n    ds2 = ds2_from_metric_and_displacement(g, dx)\n    return abs(ds2_p - ds2)\n\ndef run_spherical_case(eps, omega, event_s, disp_s):\n    \"\"\"\n    Compute discrepancy |ds'^2 - ds^2| for spherical spatial patch.\n    event_s: (t, r, theta, phi), disp_s: (dt, dr, dtheta, dphi).\n    \"\"\"\n    t_s, r, theta, phi = event_s\n    dt_s, dr, dtheta, dphi = disp_s\n    J = jacobian_spherical(t_s, r, theta, phi)\n    t, x, y, z = map_event_spherical(t_s, r, theta, phi)\n    g = metric_cartesian(t, x, y, z, eps, omega)\n    g_s = J.T @ g @ J\n    dxs = np.array([dt_s, dr, dtheta, dphi], dtype=float)\n    dx = J @ dxs\n    ds2_s = ds2_from_metric_and_displacement(g_s, dxs)\n    ds2 = ds2_from_metric_and_displacement(g, dx)\n    return abs(ds2_s - ds2)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: rotated Cartesian, general case\n        (\"rotation\", {\"eps\": 1e-3, \"omega\": 100.0, \"alpha\": np.pi / 6,\n                      \"event_p\": (0.3, 0.1, -0.2, 0.5),\n                      \"disp_p\": (1e-3, 2e-3, -1e-3, 1.5e-3)}),\n        # Test Case 2: rotated Cartesian, near-identity rotation boundary\n        (\"rotation\", {\"eps\": 1e-3, \"omega\": 100.0, \"alpha\": 1e-8,\n                      \"event_p\": (0.3, 0.1, -0.2, 0.5),\n                      \"disp_p\": (1e-3, -1e-3, 1.5e-3, -2e-3)}),\n        # Test Case 3: spherical patch, near polar axis boundary\n        (\"spherical\", {\"eps\": 1e-4, \"omega\": 250.0,\n                       \"event_s\": (0.25, 1.2, 1e-6, 1.0),\n                       \"disp_s\": (1e-3, 5e-4, 1e-6, 1e-3)}),\n        # Test Case 4: spherical patch, equatorial case\n        (\"spherical\", {\"eps\": 1e-3, \"omega\": 50.0,\n                       \"event_s\": (0.1, 2.0, np.pi / 2.0, 2.0),\n                       \"disp_s\": (5e-4, -1e-3, 2e-3, -1e-3)}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"rotation\":\n            result = run_rotation_case(params[\"eps\"], params[\"omega\"], params[\"alpha\"],\n                                       params[\"event_p\"], params[\"disp_p\"])\n        elif kind == \"spherical\":\n            result = run_spherical_case(params[\"eps\"], params[\"omega\"],\n                                        params[\"event_s\"], params[\"disp_s\"])\n        else:\n            result = float(\"nan\")\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3493437"}]}