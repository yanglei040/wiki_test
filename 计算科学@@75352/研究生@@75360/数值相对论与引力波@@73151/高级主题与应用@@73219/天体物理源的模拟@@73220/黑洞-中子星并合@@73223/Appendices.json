{"hands_on_practices": [{"introduction": "在深入研究复杂的数值模拟之前，简单的解析模型就能为我们提供强有力的洞察。本练习将探讨一个基本问题：在何种条件下，中子星能够抵抗潮汐力形成吸积盘，而不是直接坠入黑洞？通过比较一个简单的潮汐撕裂半径与黑洞的最内稳定圆轨道（ISCO），你将亲身体验控制并合结果的关键参数。[@problem_id:3466282]", "problem": "考虑一个用于黑洞-中子星并合的半解析碎裂判据，在该判据中，当中子星（NS）的潮汐碎裂半径超过黑洞（BH）的最内稳定圆轨道（ISCO）半径时，中子星会发生潮汐碎裂并留下一个残余的吸积盘，反之则不成立。设潮汐碎裂半径由领头阶牛顿标度律 $R_{\\rm tid} \\sim \\kappa_{\\rm tide}\\, R_{\\rm NS}\\left(M_{\\rm BH}/M_{\\rm NS}\\right)^{1/3}$ 建模，其中 $R_{\\rm NS}$ 是中子星的周长半径，$M_{\\rm BH}$ 是黑洞质量，$M_{\\rm NS}$ 是中子星质量，$\\kappa_{\\rm tide}$ 是一个数量级为1的系数，我们将其设为 $\\kappa_{\\rm tide}=1$ 来定义一个具体的半解析模型。设ISCO半径由克尔时空中的无量纲自旋参数 $a_\\ast$ 得到，并使用 $G$ 和 $c$ 转换为物理长度。决策规则定义如下：当且仅当 $R_{\\rm tid}R_{\\rm ISCO}(a_\\ast)$ 时，形成残余吸积盘；否则，结果为瞬时掉落，几乎没有吸积盘。\n\n从基本原理出发，使用以下基础，不要在问题陈述中引入任何目标公式：\n- 将中子星上的牛顿潮汐加速度与中子星表面的自引力相等，以获得 $R_{\\rm tid}$ 的领头阶标度律。\n- 使用克尔度规中赤道圆测地线的临界稳定条件，以获得以 $M$ 为单位的 $r_{\\rm ISCO}(a_\\ast)$，其中 $M$ 是几何单位下的黑洞质量。\n- 通过 $R_{\\rm ISCO}=r_{\\rm ISCO}\\, G M_{\\rm BH}/c^2$ 将 $r_{\\rm ISCO}$ 转换为物理长度。\n\n所有半径必须以千米为单位计算。质量输入以太阳质量为单位提供，必须通过先转换为千克，再通过因子 $G M_{\\odot}/c^2$ 转换为千米来进行一致转换。无量纲自旋参数 $a_\\ast$ 可以是正的（顺行）或负的（逆行）。\n\n实现一个程序，该程序：\n- 为每个测试用例计算 $R_{\\rm tid}$ 和 $R_{\\rm ISCO}$，\n- 根据 $R_{\\rm tid}R_{\\rm ISCO}$ 是否成立，以布尔值的形式预测半解析结果，\n- 将该预测与提供的数值相对论（NR）结果标签进行比较（其中NR代表数值相对论），\n- 为每个测试用例返回一个布尔值，指示半解析预测是否与NR标签匹配。\n\n使用以下参数元组的测试套件 $(M_{\\rm BH}, a_\\ast, M_{\\rm NS}, R_{\\rm NS}, \\text{NR\\_disk})$，其中 $M_{\\rm BH}$ 和 $M_{\\rm NS}$ 以太阳质量为单位，$R_{\\rm NS}$ 以千米为单位，而 $\\text{NR\\_disk}$ 是预期的NR标签（形成吸积盘为真或假）：\n- A例（理想情况，瞬时掉落）：(7, 0.0, 1.4, 12, \\text{false})。\n- B例（高自旋和较大中子星，碎裂）：(7, 0.95, 1.4, 14, \\text{true})。\n- C例（低黑洞质量和高自旋，碎裂）：(3, 0.9, 1.4, 12, \\text{true})。\n- D例（高黑洞质量，近阈值高自旋，碎裂）：(10, 0.99, 1.4, 12, \\text{true})。\n- E例（致密中子星和中等自旋，瞬时掉落）：(5, 0.5, 1.4, 11, \\text{false})。\n- F例（逆行自旋，瞬时掉落）：(5, -0.5, 1.4, 12, \\text{false})。\n\n您的程序必须根据克尔度规中的临界稳定条件，为任意 $a_\\ast \\in [-1,1]$ 精确实现克尔ISCO，并按照规定实现牛顿领头阶潮汐判据。使用标准常数 $G$ 和 $c$ 以及太阳质量 $M_{\\odot}$，其国际单位制（SI）下的值为：$G=6.67430\\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$，$c=2.99792458\\times 10^{8}$ m s$^{-1}$，以及 $M_{\\odot}=1.98847\\times 10^{30}$ kg。所有中间物理计算必须以一致的方式进行，并且所有半径必须以千米表示。\n\n不使用角度单位。不使用百分比。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，格式为 $\\texttt{[b\\_A,b\\_B,b\\_C,b\\_D,b\\_E,b\\_F]}$，其中每个条目是一个布尔值，当且仅当该用例的半解析预测与NR标签匹配时为真，否则为假。例如，一个有效的输出行可能看起来像 $\\texttt{[True,False,True,True,True,False]}$（这只是一个示例，不是要求的答案）。", "solution": "该问题是有效的，因为它在天体物理学和广义相对论方面有科学依据，问题设定清晰，目标明确，数据充分，且表述客观。任务是实现一个半解析模型，以预测黑洞-中子星（BH-NS）并合的结果，并将此预测与提供的数值相对论（NR）结果进行比较。该模型假设，当且仅当潮汐碎裂半径 $R_{\\rm tid}$ 大于黑洞的最内稳定圆轨道（ISCO）半径 $R_{\\rm ISCO}$ 时，才会形成残余吸积盘。\n\n解决方案要求根据问题陈述中规定的基本原理，推导并实现这两个半径的公式。所有计算都必须使用一致的物理单位进行，最终半径以千米表示。\n\n首先，我们推导潮汐碎裂半径 $R_{\\rm tid}$ 的表达式。在牛顿近似下，当质量为 $M_{\\rm NS}$、半径为 $R_{\\rm NS}$ 的中子星（NS）受到质量为 $M_{\\rm BH}$ 的黑洞（BH）作用时，若黑洞施加于中子星上的引力差超过了中子星自身的自引力，则中子星会被潮汐碎裂。在距离 $R$ 处，黑洞对中子星（特征尺寸为 $R_{\\rm NS}$）施加的潮汐加速度 $a_{\\rm tide}$ 的标度关系为 $a_{\\rm tide} \\approx G M_{\\rm BH} R_{\\rm NS} / R^3$。维持中子星不解体的表面自引力加速度为 $a_{\\rm self} = G M_{\\rm NS} / R_{\\rm NS}^2$。将这两个加速度相等，定义了潮汐碎裂半径 $R_{\\rm tid}$：\n$$\n\\frac{G M_{\\rm BH} R_{\\rm NS}}{R_{\\rm tid}^3} \\sim \\frac{G M_{\\rm NS}}{R_{\\rm NS}^2}\n$$\n求解 $R_{\\rm tid}$ 得到标度关系：\n$$\nR_{\\rm tid} \\sim R_{\\rm NS} \\left(\\frac{M_{\\rm BH}}{M_{\\rm NS}}\\right)^{1/3}\n$$\n问题指定使用此领头阶标度律，并将数量级为1的系数 $\\kappa_{\\rm tide}$ 设为1。因此，要实现的公式正是 $R_{\\rm tid} = R_{\\rm NS} \\left(M_{\\rm BH}/M_{\\rm NS}\\right)^{1/3}$。由于 $M_{\\rm BH}$ 和 $M_{\\rm NS}$ 以相同单位（太阳质量）给出，它们的比值是无量纲的。在 $R_{\\rm NS}$ 以千米为单位的情况下，得到的 $R_{\\rm tid}$ 也以千米为单位。\n\n接下来，我们确定克尔黑洞的ISCO半径 $R_{\\rm ISCO}$。ISCO是有质量粒子可以在黑洞赤道平面上维持稳定圆轨道的最小半径。其半径通过求解克尔度规中赤道圆测地线的临界稳定条件得到，即 $\\frac{d V_{\\rm eff}}{dr} = 0$ 和 $\\frac{d^2 V_{\\rm eff}}{dr^2} = 0$，其中 $V_{\\rm eff}$ 是有效势。这些方程的解给出了以黑洞质量 $M = G M_{\\rm BH}/c^2$ 的几何单位表示的ISCO半径 $r_{\\rm ISCO}$。结果取决于黑洞的无量纲自旋参数 $a_\\ast = a/M$，其中 $a$ 是自旋参数。无量纲ISCO半径 $r'_{\\rm ISCO} = r_{\\rm ISCO}/M$ 的精确公式为：\n$$\nr'_{\\rm ISCO}(a_\\ast) = 3 + Z_2 \\mp \\sqrt{(3-Z_1)(3+Z_1+2Z_2)}\n$$\n其中\n$$\nZ_1 = 1 + (1-|a_\\ast|^2)^{1/3} \\left( (1+|a_\\ast|)^{1/3} + (1-|a_\\ast|)^{1/3} \\right)\n$$\n$$\nZ_2 = \\sqrt{3|a_\\ast|^2 + Z_1^2}\n$$\n符号 $\\mp$ 的选择取决于轨道相对于黑洞自旋的方向：负号（$-$）用于顺行轨道（同向旋转，$a_\\ast \\ge 0$），产生较小的ISCO；正号（$+$）用于逆行轨道（反向旋转，$a_\\ast  0$），产生较大的ISCO。\n\n为了以千米为单位获得物理半径 $R_{\\rm ISCO}$，我们必须首先将黑洞质量 $M_{\\rm BH}$ 从太阳质量（$M_\\odot$）转换为千米。转换因子是一个太阳质量的引力半径：\n$$\nM_{\\odot, \\text{km}} = \\frac{G M_\\odot}{c^2}\n$$\n使用提供的常数 $G = 6.67430 \\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$，$c = 2.99792458 \\times 10^8$ m s$^{-1}$ 和 $M_\\odot = 1.98847 \\times 10^{30}$ kg，该因子约为 $1.4766$ km。那么物理ISCO半径为：\n$$\nR_{\\rm ISCO} = r'_{\\rm ISCO}(a_\\ast) \\times (M_{\\rm BH} \\text{ in } M_\\odot) \\times M_{\\odot, \\text{km}}\n$$\n\n计算步骤如下：\n1. 定义物理常数 $G$、$c$ 和 $M_\\odot$，并计算从太阳质量到千米的转换因子。\n2. 对于每个测试用例 $(M_{\\rm BH}, a_\\ast, M_{\\rm NS}, R_{\\rm NS}, \\text{NR\\_disk})$：\n    a. 使用潮汐半径公式计算 $R_{\\rm tid}$。\n    b. 首先计算给定自旋 $a_\\ast$ 的无量纲半径 $r'_{\\rm ISCO}(a_\\ast)$，然后按以千米为单位的黑洞质量进行缩放，从而计算 $R_{\\rm ISCO}$。\n    c. 应用决策规则：如果 $R_{\\rm tid}  R_{\\rm ISCO}$，则预测有残余吸积盘（`true`），否则预测为瞬时掉落（`false`）。\n    d. 将此布尔预测与提供的NR结果标签 $\\text{NR\\_disk}$ 进行比较。\n    e. 如果预测与标签匹配，则该用例的结果为 `true`，否则为 `false`。\n3. 收集所有测试用例的布尔结果，并将其格式化为指定的输出字符串。这个系统化的过程验证了半解析模型在一组基准模拟下的有效性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates a semi-analytic model for black hole-neutron star\n    merger outcomes against numerical relativity results.\n    \"\"\"\n\n    # Physical constants in SI units\n    G = 6.67430e-11  # Gravitational constant (m^3 kg^-1 s^-2)\n    C = 2.99792458e8   # Speed of light (m s^-1)\n    M_SOLAR_KG = 1.98847e30  # Solar mass (kg)\n\n    # Conversion factor for mass from solar masses to kilometers\n    SOLAR_MASS_IN_KM = (G * M_SOLAR_KG) / (C**2 * 1000)\n\n    # Test cases from the problem statement\n    # Tuple format: (M_BH (M_solar), a_star, M_NS (M_solar), R_NS (km), NR_disk_label (bool))\n    test_cases = [\n        (7.0, 0.0, 1.4, 12.0, False),    # Case A\n        (7.0, 0.95, 1.4, 14.0, True),    # Case B\n        (3.0, 0.9, 1.4, 12.0, True),     # Case C\n        (10.0, 0.99, 1.4, 12.0, True),   # Case D\n        (5.0, 0.5, 1.4, 11.0, False),    # Case E\n        (5.0, -0.5, 1.4, 12.0, False),   # Case F\n    ]\n\n    def calculate_isco_radius_km(m_bh_solar, a_star):\n        \"\"\"\n        Calculates the physical ISCO radius in km for a Kerr black hole.\n        - m_bh_solar: Black hole mass in solar masses.\n        - a_star: Dimensionless black hole spin parameter [-1, 1].\n        \"\"\"\n        a = abs(a_star)\n        \n        # Handle the edge case a=1 to avoid potential numerical issues with (1-a**2)\n        if a  1.0:\n            raise ValueError(\"Spin parameter |a*| cannot exceed 1.\")\n            \n        z1 = 1 + np.cbrt(1 - a**2) * (np.cbrt(1 + a) + np.cbrt(1 - a))\n        z2 = np.sqrt(3 * a**2 + z1**2)\n        \n        # Prograde (a_star = 0) and retrograde (a_star  0) orbits\n        sqrt_term = np.sqrt((3 - z1) * (3 + z1 + 2 * z2))\n        \n        if a_star = 0:\n            # Prograde orbit formula\n            r_isco_dimless = 3 + z2 - sqrt_term\n        else:\n            # Retrograde orbit formula\n            r_isco_dimless = 3 + z2 + sqrt_term\n            \n        r_isco_km = r_isco_dimless * m_bh_solar * SOLAR_MASS_IN_KM\n        return r_isco_km\n\n    def calculate_tidal_radius_km(m_bh_solar, m_ns_solar, r_ns_km):\n        \"\"\"\n        Calculates the tidal disruption radius in km.\n        - m_bh_solar: Black hole mass in solar masses.\n        - m_ns_solar: Neutron star mass in solar masses.\n        - r_ns_km: Neutron star radius in kilometers.\n        \"\"\"\n        mass_ratio = m_bh_solar / m_ns_solar\n        r_tid_km = r_ns_km * np.cbrt(mass_ratio)\n        return r_tid_km\n\n    results = []\n    for case in test_cases:\n        m_bh, a_star, m_ns, r_ns, nr_disk_label = case\n        \n        # Compute the two critical radii\n        r_isco = calculate_isco_radius_km(m_bh, a_star)\n        r_tid = calculate_tidal_radius_km(m_bh, m_ns, r_ns)\n        \n        # Apply the semi-analytic decision rule\n        # A disk forms if the tidal radius is greater than the ISCO radius\n        analytic_prediction = r_tid  r_isco\n        \n        # Compare the prediction with the numerical relativity label\n        match = (analytic_prediction == nr_disk_label)\n        results.append(match)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3466282"}, {"introduction": "来自旋进阶段的引力波携带了关于中子星内部结构的宝贵信息，这些信息被编码在一个称为潮汐形变度（$\\tilde{\\Lambda}$）的参数中。本练习让你扮演引力波天文学家的角色，运用费雪信息矩阵（Fisher information matrix）理论来理解我们能多精确地测量这一效应，以及在数据分析中使用不完美的理论模型会如何引入系统性偏差。[@problem_id:3466318]", "problem": "考虑在数值相对论和引力波数据分析框架下分析的、来自一个无自旋黑洞-中子星双星系统的引力波。要求您在使用忽略潮汐效应的双黑洞模板时，量化有效潮汐形变参数推断中的系统性偏差。在稳相近似（SPA）下，于频域中进行分析，并假设仅考虑旋进阶段，在指定的最高频率处进行锐截止。使用以下科学标准基准和定义：\n\n- 两个频域信号 $a(f)$ 和 $b(f)$ 之间的匹配滤波内积由最优滤波和高斯噪声的法则定义为\n$$\n(a|b) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{a(f)\\,b^{\\ast}(f)}{S_n(f)}\\,df,\n$$\n其中 $S_n(f)$ 是单边噪声功率谱密度（PSD），$f_{\\mathrm{low}}$ 是下限截止频率，$f_{\\mathrm{cut}}$ 是上限截止频率，$\\Re$ 表示实部。\n\n- 网络信噪比（SNR）定义为\n$$\n\\rho = \\sqrt{(h|h)},\n$$\n其中 $h(f)$ 是模板波形。\n\n- 对于高信噪比、线性化机制中的参数估计，由波形模型误差引起的一阶系统性参数偏差使用费雪信息矩阵（FIM）进行估计。对于参数 $\\theta_i$，FIM 为\n$$\n\\Gamma_{ij} = \\left(\\frac{\\partial h}{\\partial \\theta_i} \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right),\n$$\n且领头阶系统性偏差矢量为\n$$\n\\delta \\theta_i \\approx \\sum_j \\left[\\Gamma^{-1}\\right]_{ij}\\,\\left(\\delta h \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right),\n$$\n其中 $\\delta h(f)$ 是真实信号与假定模板族之间的差异。\n\n- 在稳相近似（SPA）下，使用一个简化的频域旋进模板 $h(f)$，其振幅按幂律 $f^{-7/6}$ 缩放，相位包含领头的点质量项和一个与有效潮汐形变性成正比的领头阶潮汐相位修正。将该双星系统视为无自旋且轨道为圆形。所有相位均以弧度为单位。\n\n- 对于黑洞-中子星系统，有效潮汐形变性是进入领头阶潮汐相位的简化参数。对于黑洞质量 $m_1$、中子星质量 $m_2$ 以及中子星的无量纲潮汐形变性 $\\Lambda_{\\mathrm{NS}}$，有效潮汐形变性定义为\n$$\n\\tilde{\\Lambda} = \\frac{16}{13}\\,\\frac{\\left(m_2 + 12 m_1\\right)\\,m_2^4}{\\left(m_1 + m_2\\right)^5}\\,\\Lambda_{\\mathrm{NS}}.\n$$\n该参数封装了质量依赖关系，如果两个天体都是黑洞，则其值为零。\n\n- 在波形相位中采用几何单位制，其中 $G=c=1$，但需确保使用 $M_{\\odot} c^{-3} G \\approx 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ 将质量从太阳质量正确转换为秒，以便当以太阳质量为单位的 $m$ 出现在相位中的 $\\pi M f$ 等组合中时，通过 $m \\times 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ 转换为秒。\n\n- 使用以下常数和模型选择：\n    - 领头阶潮汐相位系数 $K_{\\mathrm{tidal}} = 39/2$。\n    - 功率谱密度（PSD）模型 $S_n(f) = S_0\\left[1 + \\left(\\frac{f_0}{f}\\right)^4\\right]$，其中 $S_0 = 1$ 且 $f_0 = 50\\,\\mathrm{Hz}$。\n    - 下限截止频率 $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$。\n    - 并合时间和相位可被视为冗余参数；在模板中将其基准值设为零，但将它们包含在费雪信息矩阵中。\n    - 频率单位是赫兹（Hertz）。角度单位是弧度（radians）。潮汐形变性参数是无量纲的。\n\n您的任务：\n\n- 从匹配滤波内积、费雪信息矩阵定义和稳相近似假设出发，推导出一个可行的算法以实现以下目标：\n    1. 在频带 $[f_{\\mathrm{low}}, f_{\\mathrm{cut}}]$ 上归一化双黑洞模板的振幅，以达到指定的信噪比 $\\rho$。\n    2. 为参数矢量 $\\{\\tilde{\\Lambda}, \\phi_c, t_c\\}$ 构建费雪信息矩阵，其中 $\\phi_c$ 是并合相位，$t_c$ 是并合时间。\n    3. 当真实信号包含由 $\\tilde{\\Lambda}$ 决定的领头阶潮汐相位时，计算因使用忽略潮汐相位的双黑洞模板而引起的一阶系统性偏差 $\\delta \\tilde{\\Lambda}$。在相同的振幅模型和截止频率下，使用精确差值 $\\delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{template}}(f)$ 进行计算，并对内积进行数值评估。\n    4. 计算高斯统计不确定度 $\\sigma_{\\tilde{\\Lambda}} = \\sqrt{\\left[\\Gamma^{-1}\\right]_{\\tilde{\\Lambda}\\tilde{\\Lambda}}}$。\n    5. 报告相对偏差 $b_{\\mathrm{rel}} = |\\delta \\tilde{\\Lambda}|/\\sigma_{\\tilde{\\Lambda}}}$。\n\n- 科学真实性：将分析限制在仅旋进信号和频域建模。假设在线性化偏差近似在所提供的参数范围内是合适的。\n\n测试套件：\n\n- 假设黑洞质量 $m_1 = 7\\,M_{\\odot}$，中子星质量 $m_2 = 1.4\\,M_{\\odot}$，中子星潮汐形变性为 $\\Lambda_{\\mathrm{NS}} = 200$。对于每个测试用例，指定一个信噪比（SNR）$\\rho$和一个以赫兹为单位的截止频率 $f_{\\mathrm{cut}}$：\n    1. 用例 A：$\\rho = 10$，$f_{\\mathrm{cut}} = 400\\,\\mathrm{Hz}$。\n    2. 用例 B：$\\rho = 25$，$f_{\\mathrm{cut}} = 600\\,\\mathrm{Hz}$。\n    3. 用例 C：$\\rho = 50$，$f_{\\mathrm{cut}} = 800\\,\\mathrm{Hz}$。\n    4. 边界用例 D：$\\rho = 8$，$f_{\\mathrm{cut}} = 350\\,\\mathrm{Hz}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是一个包含两个浮点数 $[\\delta \\tilde{\\Lambda}, b_{\\mathrm{rel}}]$ 的内部列表，每个浮点数四舍五入到小数点后六位，顺序与上述测试套件一致。例如：$[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$。", "solution": "该推导和算法是根据引力波数据分析和线性参数估计的第一性原理构建的，并明确指定了适用于黑洞-中子星旋进的波形模型和参数化方案。\n\n1. 基础建模与内积\n\n我们假设在稳相近似（SPA）下，一个频域旋进波形 $h(f)$ 的振幅按 $f^{-7/6}$ 缩放。适用于高斯噪声的匹配滤波内积为\n$$\n(a|b) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{a(f)\\,b^{\\ast}(f)}{S_n(f)}\\,df,\n$$\n其中单边噪声功率谱密度（PSD）为 $S_n(f) = S_0\\left[1 + \\left(\\frac{f_0}{f}\\right)^4\\right]$，积分边界为 $f_{\\mathrm{low}}$ 和 $f_{\\mathrm{cut}}$。\n\n网络信噪比（SNR）定义为\n$$\n\\rho = \\sqrt{(h|h)}.\n$$\n\n2. 频域旋进模板与潮汐相位\n\n我们采用一个简化的无自旋旋进模板，其振幅为 $A f^{-7/6}$，相位 $\\psi(f)$ 包含牛顿阶的领头点质量项，以及一个与有效潮汐形变性 $\\tilde{\\Lambda}$ 成正比的领头阶潮汐相位修正。并合时间 $t_c$ 和并合相位 $\\phi_c$ 是冗余参数。在几何单位制 $G=c=1$ 中，点质量相位包含由啁啾质量 $M_c$ 表征的牛顿领头阶项，\n$$\n\\psi_{\\mathrm{PM}}(f) = 2\\pi f t_c - \\phi_c + \\frac{3}{128}(\\pi M_c f)^{-5/3}.\n$$\n领头后牛顿阶的潮汐相位模型为\n$$\n\\psi_{\\mathrm{tidal}}(f) = - K_{\\mathrm{tidal}}\\,\\tilde{\\Lambda}\\,(\\pi M f)^{5/3},\n$$\n其中 $K_{\\mathrm{tidal}} = 39/2$，$M = m_1 + m_2$ 是总质量，$M_c = \\eta^{3/5} M$ 是啁啾质量，对称质量比为 $\\eta = \\frac{m_1 m_2}{M^2}$。黑洞-中子星系统的有效潮汐形变性为\n$$\n\\tilde{\\Lambda} = \\frac{16}{13}\\,\\frac{\\left(m_2 + 12 m_1\\right)\\,m_2^4}{\\left(m_1 + m_2\\right)^5}\\,\\Lambda_{\\mathrm{NS}},\n$$\n此公式解释了当黑洞的潮汐形变性为零时的质量依赖关系。所有进入相位的质量都必须通过 $m \\mapsto m \\times 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ 转换为秒，以确保 $(\\pi M f)$ 是以弧度为单位的无量纲量。\n\n真实的黑洞-中子星波形包含潮汐相位；而双黑洞模板忽略了它。因此，\n$$\nh_{\\mathrm{true}}(f) = A f^{-7/6} \\exp\\left[i\\left(\\psi_{\\mathrm{PM}}(f) + \\psi_{\\mathrm{tidal}}(f)\\right)\\right],\n\\quad\nh_{\\mathrm{BBH}}(f) = A f^{-7/6} \\exp\\left[i\\,\\psi_{\\mathrm{PM}}(f)\\right],\n$$\n波形模型误差为\n$$\n\\delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{BBH}}(f) = A f^{-7/6} \\exp\\left[i\\,\\psi_{\\mathrm{PM}}(f)\\right]\\left[\\exp\\left(i\\,\\psi_{\\mathrm{tidal}}(f)\\right)-1\\right].\n$$\n在小失配情况下，$\\exp(i\\,\\psi_{\\mathrm{tidal}})\\approx 1+i\\,\\psi_{\\mathrm{tidal}}$，所以 $\\delta h\\approx i\\,\\psi_{\\mathrm{tidal}}\\,h_{\\mathrm{BBH}}$，但在我们的计算中，我们将使用精确的差值来构成内积，以保持科学真实性。\n\n3. 为达到目标信噪比而进行的振幅归一化\n\n振幅 $A$ 由信噪比要求固定\n$$\n\\rho^2 = (h_{\\mathrm{BBH}}|h_{\\mathrm{BBH}}) = 4\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{A^2 f^{-7/3}}{S_n(f)}\\,df,\n$$\n所以\n$$\nA = \\frac{\\rho}{\\sqrt{4\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{f^{-7/3}}{S_n(f)}\\,df}}.\n$$\n\n4. 关于 $\\{\\tilde{\\Lambda}, \\phi_c, t_c\\}$ 的费雪信息矩阵\n\n在SPA下，模板的参数导数由 $\\partial h / \\partial \\theta = i\\,(\\partial \\psi / \\partial \\theta)\\,h$ 得到。具体来说，\n- 对于有效潮汐形变性，\n$$\n\\frac{\\partial h}{\\partial \\tilde{\\Lambda}}(f) = i\\,\\frac{\\partial \\psi_{\\mathrm{tidal}}}{\\partial \\tilde{\\Lambda}}\\,h_{\\mathrm{BBH}}(f) = -i\\,K_{\\mathrm{tidal}}\\,(\\pi M f)^{5/3}\\,h_{\\mathrm{BBH}}(f).\n$$\n- 对于并合相位，\n$$\n\\frac{\\partial h}{\\partial \\phi_c}(f) = -i\\,h_{\\mathrm{BBH}}(f).\n$$\n- 对于并合时间，\n$$\n\\frac{\\partial h}{\\partial t_c}(f) = i\\,2\\pi f\\,h_{\\mathrm{BBH}}(f).\n$$\n\n费雪信息矩阵的元素为\n$$\n\\Gamma_{ij} = \\left(\\frac{\\partial h}{\\partial \\theta_i} \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{1}{S_n(f)}\\left(\\frac{\\partial h}{\\partial \\theta_i}\\right)\\left(\\frac{\\partial h}{\\partial \\theta_j}\\right)^{\\ast}\\,df.\n$$\n\n5. 因忽略潮汐相位而在 $\\tilde{\\Lambda}$ 中产生的系统性偏差\n\n偏差矢量为\n$$\nb_j \\equiv \\left(\\delta h \\Bigg| \\frac{\\partial h}{\\partial \\theta_j}\\right) = 4\\,\\Re\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{cut}}} \\frac{\\delta h(f)\\,\\left[\\partial h(f)/\\partial \\theta_j\\right]^{\\ast}}{S_n(f)}\\,df.\n$$\n一阶偏差解为\n$$\n\\delta \\theta_i = \\sum_j \\left[\\Gamma^{-1}\\right]_{ij}\\,b_j.\n$$\n鉴于 $\\delta h$ 完全由潮汐相位差生成，它与关于 $\\tilde{\\Lambda}$ 的导数成正比，并且可以代数证明在线性机制下 $b_j = \\tilde{\\Lambda}\\,\\Gamma_{j\\tilde{\\Lambda}}$，这意味着\n$$\n\\delta \\tilde{\\Lambda} = \\tilde{\\Lambda},\n\\quad\n\\delta \\phi_c = 0,\n\\quad\n\\delta t_c = 0,\n$$\n这与振幅归一化和截止频率无关。在数值上，有限频带效应和使用精确的 $\\delta h$ 可以在数值精度范围内保持此结果，从而验证了理论预期。因此，使用忽略潮汐效应的模板的估计器将产生一个大小为真实 $\\tilde{\\Lambda}$ 全部数值的偏差，也就是说，当真实值非零时，它会错误地推断为零。\n\n6. 统计不确定度与相对偏差\n\n关于 $\\tilde{\\Lambda}$ 的高斯统计不确定度可以从费雪矩阵的逆矩阵中读出，\n$$\n\\sigma_{\\tilde{\\Lambda}} = \\sqrt{\\left[\\Gamma^{-1}\\right]_{\\tilde{\\Lambda}\\tilde{\\Lambda}}}.\n$$\n由于费雪信息矩阵与振幅的平方（因此与 $\\rho^2$）成比例缩放，我们有 $\\sigma_{\\tilde{\\Lambda}}\\propto 1/\\rho$。因此，由下式定义的相对偏差\n$$\nb_{\\mathrm{rel}} = \\frac{|\\delta \\tilde{\\Lambda}|}{\\sigma_{\\tilde{\\Lambda}}}\n$$\n与 $\\rho$ 近似线性缩放，并通过由 $f_{\\mathrm{cut}}$ 设定的 $\\Gamma$ 结构依赖于频带。\n\n7. 算法步骤\n\n- 使用 $M_{\\odot} c^{-3} G \\approx 4.92549094830932\\times 10^{-6}\\,\\mathrm{s}$ 将质量 $m_1$ 和 $m_2$ 从太阳质量转换为秒。使用提供的公式和 $\\Lambda_{\\mathrm{NS}}$ 计算 $M$、$\\eta$、$M_c$，然后计算 $\\tilde{\\Lambda}$。\n- 在 $[f_{\\mathrm{low}}, f_{\\mathrm{cut}}]$（单位为赫兹）上构建一个密集的频率网格。\n- 在网格上构建 $S_n(f)$，并通过在频带上积分 $f^{-7/3}/S_n(f)$ 来计算振幅归一化系数 $A$ 以满足目标信噪比 $\\rho$。\n- 形成 $h_{\\mathrm{BBH}}(f)$ 并计算参数导数 $\\partial h/\\partial \\tilde{\\Lambda}$、$\\partial h/\\partial \\phi_c$ 和 $\\partial h/\\partial t_c$。\n- 通过导数的内积组装费雪信息矩阵 $\\Gamma$。\n- 构建包含潮汐相位的 $h_{\\mathrm{true}}(f)$，并计算 $\\delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{BBH}}(f)$。\n- 通过内积 $(\\delta h | \\partial h/\\partial \\theta_j)$ 计算偏差矢量 $b$，并求解 $\\delta \\theta = \\Gamma^{-1} b$。提取 $\\delta \\tilde{\\Lambda}$。\n- 计算 $\\sigma_{\\tilde{\\Lambda}} = \\sqrt{\\left[\\Gamma^{-1}\\right]_{\\tilde{\\Lambda}\\tilde{\\Lambda}}}$ 和 $b_{\\mathrm{rel}}$。\n- 对测试套件中的用例重复以上步骤，并按要求的格式输出结果，四舍五入到小数点后六位。\n\n8. 单位与输出\n\n- 频率 $f$ 的单位是赫兹，角度的单位是弧度，当通过 $\\pi M f$ 进入相位时质量的单位是秒，潮汐形变性是无量纲的。\n- 最终输出必须是单行字符串，包含一个逗号分隔的四个内部列表的列表，每个内部列表对应一个测试用例，其中包含两个浮点数 $[\\delta \\tilde{\\Lambda}, b_{\\mathrm{rel}}]$，四舍五入到小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants\nM_sun_sec = 4.92549094830932e-6  # G*M_sun/c^3 in seconds\nK_tidal = 39.0 / 2.0             # Leading-order tidal phase coefficient\nS0 = 1.0\nf0 = 50.0                        # Hz\nf_low = 20.0                     # Hz\n\ndef psd(f):\n    # One-sided PSD model\n    return S0 * (1.0 + (f0 / f) ** 4)\n\ndef effective_lambda_tilde(m1_solar, m2_solar, Lambda_NS):\n    # Effective tidal deformability tilde{Lambda} for BH-NS\n    m1 = m1_solar\n    m2 = m2_solar\n    M = m1 + m2\n    num = (m2 + 12.0 * m1) * (m2 ** 4)\n    den = M ** 5\n    return (16.0 / 13.0) * (num / den) * Lambda_NS\n\ndef masses_in_seconds(m1_solar, m2_solar):\n    m1_sec = m1_solar * M_sun_sec\n    m2_sec = m2_solar * M_sun_sec\n    M_sec = (m1_solar + m2_solar) * M_sun_sec\n    eta = (m1_solar * m2_solar) / ((m1_solar + m2_solar) ** 2)\n    Mc_sec = (eta ** (3.0 / 5.0)) * M_sec\n    return m1_sec, m2_sec, M_sec, Mc_sec, eta\n\ndef compute_amplitude_for_snr(rho, f_grid, Sn):\n    integrand = (f_grid ** (-7.0 / 3.0)) / Sn\n    norm = 4.0 * np.trapz(integrand, f_grid)\n    A = rho / np.sqrt(norm)\n    return A\n\ndef build_waveform(f_grid, A, Mc_sec, M_sec, tc=0.0, phic=0.0, lambda_tilde=0.0):\n    # Phase terms\n    psi_pm = 2.0 * np.pi * f_grid * tc - phic + (3.0 / 128.0) * (np.pi * Mc_sec * f_grid) ** (-5.0 / 3.0)\n    psi_tidal = - K_tidal * lambda_tilde * (np.pi * M_sec * f_grid) ** (5.0 / 3.0)\n    h = A * f_grid ** (-7.0 / 6.0) * np.exp(1j * (psi_pm + psi_tidal))\n    return h, psi_pm, psi_tidal\n\ndef derivatives(h_bbh, f_grid, M_sec):\n    # Derivatives w.r.t. [lambda_tilde, phi_c, t_c]\n    dpsi_dlambda = - K_tidal * (np.pi * M_sec * f_grid) ** (5.0 / 3.0)\n    dh_dlambda = 1j * dpsi_dlambda * h_bbh\n    dh_dphic = -1j * h_bbh\n    dh_dtc = 1j * 2.0 * np.pi * f_grid * h_bbh\n    return dh_dlambda, dh_dphic, dh_dtc\n\ndef inner_product(a, b, f_grid, Sn):\n    integrand = a * np.conj(b) / Sn\n    val = 4.0 * np.trapz(integrand, f_grid)\n    return np.real(val)\n\ndef fisher_matrix(derivs, f_grid, Sn):\n    n = len(derivs)\n    Gamma = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        for j in range(n):\n            Gamma[i, j] = inner_product(derivs[i], derivs[j], f_grid, Sn)\n    return Gamma\n\ndef bias_vector(delta_h, derivs, f_grid, Sn):\n    b = np.array([inner_product(delta_h, d, f_grid, Sn) for d in derivs], dtype=float)\n    return b\n\ndef solve_case(m1_solar, m2_solar, Lambda_NS, rho, f_cut):\n    # Frequency grid\n    f_grid = np.linspace(f_low, f_cut, 20000)\n    Sn = psd(f_grid)\n\n    # Masses and tidal parameter\n    _, _, M_sec, Mc_sec, _ = masses_in_seconds(m1_solar, m2_solar)\n    lambda_tilde = effective_lambda_tilde(m1_solar, m2_solar, Lambda_NS)\n\n    # Amplitude to meet target SNR using BBH template\n    A = compute_amplitude_for_snr(rho, f_grid, Sn)\n\n    # Build BBH waveform (lambda_tilde=0) and true waveform (with tidal)\n    h_bbh, psi_pm, _ = build_waveform(f_grid, A, Mc_sec, M_sec, tc=0.0, phic=0.0, lambda_tilde=0.0)\n    h_true, _, _ = build_waveform(f_grid, A, Mc_sec, M_sec, tc=0.0, phic=0.0, lambda_tilde=lambda_tilde)\n\n    # Derivatives\n    dh_dlambda, dh_dphic, dh_dtc = derivatives(h_bbh, f_grid, M_sec)\n    derivs = [dh_dlambda, dh_dphic, dh_dtc]\n\n    # Fisher matrix\n    Gamma = fisher_matrix(derivs, f_grid, Sn)\n\n    # Bias vector using exact delta h\n    delta_h = h_true - h_bbh\n    b = bias_vector(delta_h, derivs, f_grid, Sn)\n\n    # Solve for parameter biases\n    try:\n        Gamma_inv = np.linalg.inv(Gamma)\n    except np.linalg.LinAlgError:\n        # Regularize if singular; add small diagonal jitter\n        jitter = 1e-12\n        Gamma_inv = np.linalg.inv(Gamma + jitter * np.eye(Gamma.shape[0]))\n    delta_theta = Gamma_inv @ b\n\n    delta_lambda = float(delta_theta[0])\n    sigma_lambda = float(np.sqrt(Gamma_inv[0, 0]))\n    rel_bias = abs(delta_lambda) / sigma_lambda if sigma_lambda  0 else np.inf\n\n    return delta_lambda, rel_bias\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (rho, f_cut)\n    m1_solar = 7.0\n    m2_solar = 1.4\n    Lambda_NS = 200.0\n\n    test_cases = [\n        (10.0, 400.0),  # Case A\n        (25.0, 600.0),  # Case B\n        (50.0, 800.0),  # Case C\n        (8.0, 350.0),   # Edge Case D\n    ]\n\n    results = []\n    for rho, f_cut in test_cases:\n        delta_lambda, rel_bias = solve_case(m1_solar, m2_solar, Lambda_NS, rho, f_cut)\n        # Round to six decimal places\n        results.append([round(delta_lambda, 6), round(rel_bias, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3466318"}, {"introduction": "当吸积盘形成后，其演化由磁转动不稳定性（MRI）主导，它驱动湍流并为产生千新星的物质抛射提供动力。本练习将带你进入数值模拟的世界，要求你评估其有效性的一个关键方面：网格是否足够精细以解析MRI？你将学会计算MRI品质因子（quality factor），并理解数值分辨率如何直接影响如抛射物质量这样的物理预测。[@problem_id:3466335]", "problem": "您的任务是设计并实现一个收敛性研究，该研究针对黑洞-中子星并合事件中形成的并合后吸积盘的广义相对论磁流体力学 (GRMHD) 模拟。研究重点在于解析磁转动不稳定性 (MRI) 的最快增长模式，并量化其对估算的非束缚质量产生的影响。该研究必须在几何化单位制 ($G=c=1$) 中表达和计算，这意味着质量、长度和时间共享相同的单位，且所有特征速度均为无量纲量。目标是为每个测试配置计算 MRI 最快增长尺度是否被至少 $N$ 个网格单元解析，并根据与 $p$ 阶形式精度方法一致的收敛模型来估算非束缚质量。\n\n推导的基本出发点必须是以下经过充分检验的关系式和定义：\n- 绝热指数为 $\\Gamma$ 的理想流体的比焓为 $h = 1 + \\epsilon + p/\\rho$，其中理想气体的比内能为 $\\epsilon = p / \\left((\\Gamma - 1)\\rho\\right)$，这意味着 $h = 1 + \\dfrac{\\Gamma}{\\Gamma-1} \\dfrac{p}{\\rho}$。\n- 在狭义相对論磁流体力学 (SRMHD) 中，于高斯单位制下广泛使用的相对论性阿尔芬速度为 $v_{A} = \\sqrt{ \\dfrac{B^{2}}{4\\pi \\rho h + B^{2}} }$，其中 $B$ 是磁场强度，$\\rho$ 是静止质量密度，$h$ 是比焓。\n- 对于弱场极限下围绕中心质量为 $M$ 的致密天体的准开普勒盘，在半径 $r$ 处的角频率为 $\\Omega = \\sqrt{\\dfrac{M}{r^{3}}}$。这是在几何化单位制下与薄盘轨道运动一致的领头阶基准。\n\n根据磁转动不稳定性 (MRI) 的线性分析，最快增长的通道模式具有一个特征波长，其大小与阿尔芬速度与轨道频率之比成正比。请采用学界标准的 MRI 最快增长特征波长定义，即阿尔芬速度除以轨道频率的倍数，并从上述基础出发推导出明确的公式。然后，给定网格间距 $\\Delta x$，定义局域 MRI 品质因子 $Q = \\dfrac{\\lambda_{\\mathrm{MRI}}}{\\Delta x}$，并判断 MRI 是否被至少 $N$ 个单元解析，即 $Q \\ge N$ 是否成立。\n\n为量化对非束缚质量 $M_{\\mathrm{ej}}$ 的影响，假设一个与 $p$ 阶形式精度数值方法一致的、有原则的收敛模型：$M_{\\mathrm{ej}}$ 中的相对偏差与品质因子的倒数成幂律关系。校准偏差的幅度，使得在阈值 $Q=N$ 时，相对低估量是渐近收敛值 $M_{\\mathrm{ej},\\infty}$ 的一个指定分数 $\\delta$。一个一致的模型是\n$$\nM_{\\mathrm{ej}}(Q) \\;=\\; M_{\\mathrm{ej},\\infty} \\,\\max\\!\\left(0,\\; 1 - \\delta \\left(\\frac{N}{Q}\\right)^{p} \\right),\n$$\n该模型反映了误差随分辨率的渐近衰减，以及在极端低分辨率情况下质量不低于零的下限。\n\n您的程序必须为每个测试案例计算以下输出：\n- 一个布尔值，指示 MRI 是否在目标水平上得到解析，即 $Q \\ge N$ 是否成立。\n- 达到目标所需的单元尺寸 $\\Delta x_{\\mathrm{req}} = \\dfrac{\\lambda_{\\mathrm{MRI}}}{N}$，单位与输入半径 $r$ 的长度单位相同。\n- 实际的 MRI 品质因子 $Q$。\n- 估算的非束缚质量 $M_{\\mathrm{ej}}$，以太阳质量 $M_{\\odot}$ 为单位。\n\n所有计算都必须在 $G=c=1$ 的几何化单位制下一致地进行。$\\Delta x_{\\mathrm{req}}$ 的表达单位应与输入半径 $r$ 的长度单位相同，$M_{\\mathrm{ej}}$ 应以 $M_{\\odot}$ 为单位。所有浮点数输出均四舍五入至六位小数。本问题不使用角度。最终输出必须是单行文本，包含一个每个测试案例结果的列表，其中每个结果都是 $[\\text{resolved}, \\Delta x_{\\mathrm{req}}, Q, M_{\\mathrm{ej}}]$ 形式的列表。\n\n测试套件。使用以下参数集，每个参数集以元组 $(M, r, \\rho, p, \\Gamma, B, \\Delta x, N, M_{\\mathrm{ej},\\infty}, \\delta, p)$ 的形式提供，其中：\n- $M$ 是中心质量，\n- $r$ 是盘中进行诊断评估的半径，\n- $\\rho$ 是局域静止质量密度，\n- $p$ 是局域气体压力，\n- $\\Gamma$ 是绝热指数，\n- $B$ 是磁场强度（与 $4\\pi$ 一致的高斯单位制），\n- $\\Delta x$ 是网格间距，\n- $N$ 是每个 MRI 最快增长波长的目标单元数，\n- $M_{\\mathrm{ej},\\infty}$ 是以 $M_{\\odot}$ 为单位的渐近收敛非束缚质量，\n- $\\delta$ 是在 $Q=N$ 时的分数低估量，\n- $p$（在此元组位置重用符号）是收敛的形式阶数指数。\n\n使用以下四个科学上合理的测试案例：\n- 案例 1：$(M, r, \\rho, p, \\Gamma, B, \\Delta x, N, M_{\\mathrm{ej},\\infty}, \\delta, p) = (\\,5,\\; 50,\\; 10^{-4},\\; 10^{-6},\\; 4/3,\\; 10^{-3},\\; 2.0,\\; 10,\\; 0.05,\\; 0.2,\\; 2\\,)$。\n- 案例 2：$(\\,5,\\; 50,\\; 10^{-4},\\; 10^{-6},\\; 4/3,\\; 10^{-3},\\; 2.7471,\\; 10,\\; 0.05,\\; 0.2,\\; 2\\,)$。\n- 案例 3：$(\\,5,\\; 50,\\; 10^{-4},\\; 10^{-6},\\; 4/3,\\; 10^{-3},\\; 5.6,\\; 10,\\; 0.05,\\; 0.2,\\; 2\\,)$。\n- 案例 4：$(\\,7,\\; 20,\\; 10^{-6},\\; 10^{-8},\\; 4/3,\\; 10^{-1},\\; 1.0,\\; 20,\\; 0.1,\\; 0.1,\\; 1.5\\,)$。\n\n您的程序应生成单行输出，其中包含一个以方括号括起来的、逗号分隔的列表的列表，例如 $[[\\cdots],[\\cdots],\\ldots]$，其中每个内部列表为 $[\\text{resolved}, \\Delta x_{\\mathrm{req}}, Q, M_{\\mathrm{ej}}]$，浮点数条目四舍五入到六位小数，布尔值作为字面量。不应打印任何其他文本。", "solution": "该问题是有效的。它提出了一个在相对论天体物理学和数值模拟领域内定义明确、有科学依据的计算任务。所有必要的数据和物理关系都已提供，测试案例的参数在物理上是合理的。目标清晰，所需输出定义精确。\n\n解决方案通过为每个测试案例实现分步计算来进行，遵循所描述的物理和数学模型。测试案例参数以元组形式提供：$(M, r, \\rho, p_{\\text{gas}}, \\Gamma, B, \\Delta x, N, M_{\\mathrm{ej},\\infty}, \\delta, p_{\\text{conv}})$。所有计算均在 $G=c=1$ 的几何化单位制中执行。\n\n单个测试案例的计算步骤如下：\n\n1.  **计算比焓 $h$**：给出了相对论性理想流体的比焓。比内能 $\\epsilon$ 为 $\\epsilon = p_{\\text{gas}} / ((\\Gamma - 1)\\rho)$。将其代入定义式 $h = 1 + \\epsilon + p_{\\text{gas}}/\\rho$ 得：\n    $$h = 1 + \\frac{p_{\\text{gas}}}{(\\Gamma - 1)\\rho} + \\frac{p_{\\text{gas}}}{\\rho} = 1 + \\left( \\frac{1}{\\Gamma-1} + 1 \\right) \\frac{p_{\\text{gas}}}{\\rho} = 1 + \\frac{\\Gamma}{\\Gamma-1} \\frac{p_{\\text{gas}}}{\\rho}$$\n    此公式使用所提供的局域静止质量密度 $\\rho$、气体压力 $p_{\\text{gas}}$ 和绝热指数 $\\Gamma$ 进行计算。\n\n2.  **计算相对论性阿尔芬速度 $v_A$**：问题提供了相对论性阿尔芬速度的公式，这在狭义相对论磁流体力学 (SRMHD) 文献中是针对磁场的特定约定下的标准公式：\n    $$v_{A} = \\sqrt{ \\frac{B^{2}}{4\\pi \\rho h + B^{2}} }$$\n    此处，$B$ 是磁场强度。此速度是一个无量纲量，与使用 $c=1$ 的几何化单位制一致。\n\n3.  **计算轨道角频率 $\\Omega$**：对于准开普勒盘，围绕中心质量 $M$、半径为 $r$ 处的角频率由開普勒公式近似给出：\n    $$\\Omega = \\sqrt{\\frac{M}{r^{3}}}$$\n    这是一个在弱场极限下有效的近似，适用于吸积盘的外部区域。\n\n4.  **计算特征 MRI 波长 $\\lambda_{\\mathrm{MRI}}$**：磁转动不稳定性 (MRI) 的最快增长模式具有一个特征波长 $\\lambda_{\\mathrm{MRI}}$。问题要求采用学界标准定义，对于由垂直磁场驱动的通道模式，该定义为：\n    $$\\lambda_{\\mathrm{MRI}} = \\frac{2\\pi v_A}{\\Omega}$$\n    这个波长是一个关键尺度，必须在数值模拟中被解析，以准确捕捉 MRI 的效应。\n\n5.  **计算 MRI 品质因子 $Q$**：品质因子 $Q$ 量化了特征 MRI 波长被数值网格解析的程度。它定义为 MRI 波长与网格单元尺寸 $\\Delta x$ 的比值：\n    $$Q = \\frac{\\lambda_{\\mathrm{MRI}}}{\\Delta x}$$\n\n6.  **确定 MRI 解析状态**：如果品质因子 $Q$ 大于或等于目标单元数 $N$，则认为 MRI 得到了充分解析。输出是一个表示此条件的布尔值：\n    $$\\text{resolved} = (Q \\ge N)$$\n\n7.  **计算所需单元尺寸 $\\Delta x_{\\mathrm{req}}$**：为满足每个 MRI 波长 $N$ 个单元的目标分辨率，所需的网格间距为：\n    $$\\Delta x_{\\mathrm{req}} = \\frac{\\lambda_{\\mathrm{MRI}}}{N}$$\n\n8.  **估算非束缚质量 $M_{\\mathrm{ej}}$**：所提供的收敛模型描述了数值估算的非束缚质量 $M_{\\mathrm{ej}}$ 如何随分辨率 $Q$ 的变化而趋近于渐近收敛值 $M_{\\mathrm{ej},\\infty}$。该模型为：\n    $$M_{\\mathrm{ej}}(Q) = M_{\\mathrm{ej},\\infty} \\max\\left(0, 1 - \\delta \\left(\\frac{N}{Q}\\right)^{p_{\\text{conv}}} \\right)$$\n    其中 $\\delta$ 是分辨率阈值 $Q=N$ 时的分数误差，$p_{\\text{conv}}$ 是数值方法的形式收敛阶数。$\\max(0, \\ldots)$ 函数确保估算质量为非负值，这在物理上是必要的，特别是在分辨率极差、模型可能预测出负值的情况下。\n\n将这些步骤应用于所提供的四个测试案例中的每一个。最终的浮点数结果（$\\Delta x_{\\mathrm{req}}$、$Q$ 和 $M_{\\mathrm{ej}}$）在最终输出时四舍五入到六位小数。然后将所有测试案例的结果收集到一个列表的列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes MRI resolution metrics and estimated unbound mass for a set of\n    GRMHD simulation configurations of post-merger accretion disks.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (M, r, rho, p_gas, Gamma, B, delta_x, N, M_ej_inf, delta, p_conv)\n    test_cases = [\n        # Case 1\n        (5, 50, 1e-4, 1e-6, 4/3, 1e-3, 2.0, 10, 0.05, 0.2, 2),\n        # Case 2\n        (5, 50, 1e-4, 1e-6, 4/3, 1e-3, 2.7471, 10, 0.05, 0.2, 2),\n        # Case 3\n        (5, 50, 1e-4, 1e-6, 4/3, 1e-3, 5.6, 10, 0.05, 0.2, 2),\n        # Case 4\n        (7, 20, 1e-6, 1e-8, 4/3, 1e-1, 1.0, 20, 0.1, 0.1, 1.5)\n    ]\n\n    results = []\n    for case in test_cases:\n        M, r, rho, p_gas, Gamma, B, delta_x, N, M_ej_inf, delta, p_conv = case\n\n        # 1. Calculate specific enthalpy, h\n        h = 1 + (Gamma / (Gamma - 1)) * p_gas / rho\n\n        # 2. Calculate relativistic Alfvén speed, vA\n        vA_sq = (B**2) / (4 * np.pi * rho * h + B**2)\n        vA = np.sqrt(vA_sq)\n\n        # 3. Calculate orbital angular frequency, Omega\n        Omega = np.sqrt(M / r**3)\n\n        # 4. Calculate characteristic MRI wavelength, lambda_mri\n        lambda_mri = (2 * np.pi * vA) / Omega\n\n        # 5. Calculate MRI quality factor, Q\n        # Avoid division by zero, though delta_x is non-zero in test cases.\n        if delta_x  0:\n            Q = lambda_mri / delta_x\n        else:\n            Q = np.inf\n\n        # 6. Determine MRI resolution status\n        resolved = Q = N\n\n        # 7. Calculate required cell size, delta_x_req\n        # N is a positive integer, so no division by zero.\n        delta_x_req = lambda_mri / N\n\n        # 8. Estimate the unbound mass, M_ej\n        # Ensure Q is positive to avoid division by zero or complex numbers.\n        if Q  0:\n            mass_factor = 1 - delta * (N / Q)**p_conv\n        else:\n            # If Q=0, the error is infinite, so mass should be 0.\n            mass_factor = -np.inf\n        \n        M_ej = M_ej_inf * max(0, mass_factor)\n\n        # Append the list of results for this case.\n        # Floating point numbers will be formatted in the final print statement.\n        results.append([resolved, delta_x_req, Q, M_ej])\n\n    # Format the final output string exactly as required.\n    result_strings = []\n    for res in results:\n        # res is [boolean, float, float, float]\n        resolved_str = str(res[0])\n        dx_req_str = f\"{res[1]:.6f}\"\n        q_str = f\"{res[2]:.6f}\"\n        m_ej_str = f\"{res[3]:.6f}\"\n        result_strings.append(f\"[{resolved_str},{dx_req_str},{q_str},{m_ej_str}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3466335"}]}