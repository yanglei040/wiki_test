{"hands_on_practices": [{"introduction": "在数值相对论中应用切除技术的第一个实际步骤是在网格上定义切除区域的边界。在笛卡尔网格上，一个平滑的球面边界会被近似为一个“阶梯状”的表面，这会引入与网格对齐方式相关的离散化误差。这项练习 [@problem_id:3465595] 旨在通过实现和比较球形与立方体形状的切除“掩模”（mask），让您亲手量化这些几何误差。通过在一个已知的解析解（史瓦西黑洞的各向同性坐标解）上计算哈密顿约束的违反程度，您可以直接评估不同掩模几何形状和方向所带来的数值误差，从而为实际模拟中的选择建立重要的直觉。", "problem": "考虑一个在各向同性笛卡尔坐标系中的单个不旋转黑洞的时间对称初始数据切片，其中物理空间度规是共形平坦的，由 $g_{ij} = \\psi^4 \\delta_{ij}$ 给出，对于一个 Schwarzschild 质量 $M$，其共形因子为 $\\psi(\\mathbf{x}) = 1 + \\dfrac{M}{2 r}$，其中 $r = \\sqrt{x^2 + y^2 + z^2}$。在此类切片上，广义相对论的哈密顿约束简化为要求共形度规的里奇标量在源之外为零，对于共形平坦形式，这意味着当 $r>0$ 时，平直空间拉普拉斯方程 $\\nabla^2 \\psi = 0$ 成立。在带有黑洞切除的数值相对论中，为了避免物理奇点，会移除事件视界内部切除掩模内的网格点。在笛卡尔网格上，切除掩模的几何形状和方向可能会在切除边界附近的导数有限差分近似中引入与方向相关的离散化误差。\n\n您的任务是在与事件视界相同接近程度的情况下，定量比较笛卡尔网格上的球形切除掩模与立方体切除掩模，并为每种情况报告两个标量：\n- 一个离散哈密顿约束残差范数，计算为掩模外部所有可用点上离散拉普拉斯算子 $\\nabla^2 \\psi$ 的均方根。\n- 一个与方向相关的度规误差，计算为数值近似的轴向二阶导数 $\\partial^2 \\psi / \\partial x^2$、$\\partial^2 \\psi / \\partial y^2$、$\\partial^2 \\psi / \\partial z^2$ 与其解析值之间不匹配的均方根，且计算范围仅限于与切除边界相邻的点。\n\n使用的基本依据和定义：\n- 共形因子为 $\\psi(\\mathbf{x}) = 1 + \\dfrac{M}{2 r}$，其中 $r = \\sqrt{x^2 + y^2 + z^2}$。\n- 在各向同性坐标系中，事件视界位于半径 $r_h = \\dfrac{M}{2}$ 处。\n- 切除掩模半径定义为 $r_{\\mathrm{ex}} = r_h - \\Delta$，其中 $\\Delta > 0$ 是到视界的指定接近程度。切除区域必须满足 $r_{\\mathrm{ex}} > 0$。\n- 球形掩模：切除所有满足 $r  r_{\\mathrm{ex}}$ 的点。\n- 立方体掩模：切除所有满足 $\\max\\left(|x'|,|y'|,|z'|\\right)  r_{\\mathrm{ex}}$ 的点，其中 $(x',y',z')$ 是坐标围绕 $z$ 轴进行平面内角度 $\\theta$ 旋转后的坐标，由下式给出\n$$\n\\begin{pmatrix}\nx' \\\\ y' \\\\ z'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta  0 \\\\\n-\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\ y \\\\ z\n\\end{pmatrix}.\n$$\n这一选择使得从原点到立方体掩模的最小距离等于 $r_{\\mathrm{ex}}$，与球形情况相匹配，从而确保了与视界的接近程度相同。\n\n用于误差评估的 $\\psi$ 的解析二阶导数可由 $1/r$ 的海森矩阵 (Hessian) 推出，\n$$\n\\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{1}{r}\\right) = \\frac{3 x_i x_j - r^2 \\delta_{ij}}{r^5}, \\quad r \\neq 0,\n$$\n因此\n$$\n\\frac{\\partial^2 \\psi}{\\partial x^2} = \\frac{M}{2}\\,\\frac{3 x^2 - r^2}{r^5}, \\quad\n\\frac{\\partial^2 \\psi}{\\partial y^2} = \\frac{M}{2}\\,\\frac{3 y^2 - r^2}{r^5}, \\quad\n\\frac{\\partial^2 \\psi}{\\partial z^2} = \\frac{M}{2}\\,\\frac{3 z^2 - r^2}{r^5},\n$$\n并且当 $r \\neq 0$ 时，解析拉普拉斯算子 $\\nabla^2 \\psi = 0$。\n\n在间距为 $h$ 的均匀笛卡尔网格上实现的离散化规则：\n- 当沿某一轴的两个直接邻点都可用且未被切除时，使用二阶中心差分近似来计算二阶导数：\n$$\n\\left.\\frac{\\partial^2 \\psi}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{\\psi_{i+1,j,k} - 2 \\psi_{i,j,k} + \\psi_{i-1,j,k}}{h^2},\n$$\n$y$ 和 $z$ 方向同理。\n- 如果沿某一轴的中心邻点被切除或在域外，但该轴另一侧的两个连续点可用且未被切除，则使用单侧二阶近似：\n$$\n\\left.\\frac{\\partial^2 \\psi}{\\partial x^2}\\right|_{i,j,k} \\approx \\frac{\\psi_{i,j,k} - 2 \\psi_{i\\pm 1,j,k} + \\psi_{i\\pm 2,j,k}}{h^2},\n$$\n其中符号 $\\pm$ 根据可用的一侧选择向前 ($+$) 或向后 ($-$) 的方向。如果中心差分模板和单侧差分模板都无法构成，则该点的导数被视为不可用。\n- 某点的离散拉普拉斯算子是三个轴向二阶导数之和，使用上述规则，且仅当所有三个轴向二阶导数都可用时才计算。\n- 如果一个点未被切除，并且沿任意轴至少有一个直接邻点被切除，则将该点定义为“近边界”点。\n\n每个测试用例需要计算和报告的量：\n- 哈密顿约束残差范数，定义为在掩模之外所有三个轴向二阶导数都可用的点上 $\\sqrt{\\dfrac{1}{N}\\sum_{\\mathrm{usable}} \\left(\\nabla^2 \\psi\\right)^2}$ 的计算结果（$N$ 是这类点的数量）。\n- 与方向相关的度规误差，定义为在近边界点上，数值与解析轴向二阶导数之间不匹配的均方根，即\n$$\n\\sqrt{\\dfrac{1}{N_{\\mathrm{axes}}} \\sum_{\\mathrm{near\\,boundary}} \\sum_{a \\in \\{x,y,z\\}} \\left( D_{aa}^{\\mathrm{num}} - D_{aa}^{\\mathrm{analytic}} \\right)^2 },\n$$\n其中 $D_{aa}^{\\mathrm{num}}$ 是数值轴向二阶导数，$D_{aa}^{\\mathrm{analytic}}$ 是对应的解析值；求和仅包括数值导数可用的轴（$N_{\\mathrm{axes}}$ 是此类轴向贡献的数量）。\n\n角度必须以弧度为单位指定。所有计算输出均为无单位的实数。在一个间距为 $h$ 的均匀立方体域 $[-L,L]^3$ 上实现计算。\n\n测试套件：\n- 情况 1：球形掩模，$M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = 0.0$（忽略）。\n- 情况 2：与网格对齐的立方体掩模，$M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = 0.0$。\n- 情况 3：旋转的立方体掩模，$M = 1.0$, $L = 0.6$, $h = 0.02$, $\\Delta = 0.05$, $\\theta = \\pi/4$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的六个结果 $[\\text{C}_1,\\text{E}_1,\\text{C}_2,\\text{E}_2,\\text{C}_3,\\text{E}_3]$，其中 $\\text{C}_i$ 是情况 $i$ 的约束残差范数，$\\text{E}_i$ 是情况 $i$ 的度规误差，结果为逗号分隔的列表，并用方括号括起来（例如 $[0.00123,0.00456,0.00101,0.00480,0.00105,0.00490]$）。所有值都必须是无单位的实数。", "solution": "所提出的问题是数值相对论中一个明确定义的练习，具体涉及在笛卡尔网格上黑洞切除技术的实现和评估。它要求通过计算两个不同的误差度量——哈密顿约束残差范数和与方向相关的度规误差——来定量比较两种常见的切除掩模几何形状（球形和立方体形）。所有物理定义、数学公式和数值规则均已提供且科学上可靠，构成一个自洽且可解的问题。给出的参数值在物理上和计算上都是合理的。因此，该问题被认为是有效的，并随附完整解答。\n\n任务的核心是在三维笛卡尔网格上离散化一个已知的解析解——各向同性坐标系下 Schwarzschild 黑洞的共形因子，应用不同的切除掩模，然后计算在所创建的边界附近由有限差分近似产生的误差。\n\n### 基于原理的解决方案设计\n\n该解决方案围绕一个主函数构建，该函数通过执行一系列源自数值分析和计算物理学原理的步骤来处理每个测试用例。\n\n1.  **网格与场初始化**：在域 $[-L, L]^3$ 上构建一个间距为 $h$ 的均匀三维笛卡尔网格。在此网格上，我们计算解析共形因子 $\\psi(\\mathbf{x}) = 1 + \\frac{M}{2r}$ 及其二阶偏导数 $\\frac{\\partial^2 \\psi}{\\partial x_i^2}$。径向坐标为 $r = \\sqrt{x^2+y^2+z^2}$。为防止在原点 ($r=0$) 处出现除以零的错误，计算中会给 $r$ 加上一个很小的 epsilon 值。这一点无关紧要，因为原点始终位于切除区域内 ($r_{ex} > 0$)，因此在所有后续计算中都被排除。\n\n2.  **切除掩模生成**：对于每个测试用例，都会生成一个布尔掩模 `is_excised`。这个三维数组标识了落入切除区域内、应在导数计算中忽略的网格点。\n    *   **球形掩模**：如果坐标为 $(x, y, z)$ 的点的径向距离 $r = \\sqrt{x^2+y^2+z^2}$ 小于切除半径 $r_{\\mathrm{ex}} = \\frac{M}{2} - \\Delta$，则该点被切除。\n    *   **立方体掩模**：如果坐标为 $(x, y, z)$ 的点在围绕 $z$ 轴旋转角度 $\\theta$ 后，其坐标满足 $\\max(|x'|, |y'|, |z'|)  r_{\\mathrm{ex}}$，则该点被切除。旋转后的坐标由 $x' = x \\cos\\theta + y \\sin\\theta$ 和 $y' = -x \\sin\\theta + y \\cos\\theta$ 给出。\n\n3.  **使用分层模板的数值微分**：关键步骤是使用有限差分近似二阶导数。问题指定了要使用的模板层次结构，这是有限差分方法中处理边界的标准做法。对于每个未被切除的点和每个空间方向，我们应用以下优先顺序：\n    a.  **二阶中心差分**：$\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}$。这是首选模板，只要两个直接邻点都可用（即在网格域内且未被切除），就使用此模板。\n    b.  **单侧差分（向前）**：如果中心差分模板不可用，我们尝试使用单侧模板。根据指定公式，向前模板为 $\\frac{\\psi_i - 2\\psi_{i+1} + \\psi_{i+2}}{h^2}$。如果两个向前的邻点可用，则尝试使用此模板。\n    c.  **单侧差分（向后）**：如果中心模板和向前模板都无法应用，我们尝试使用向后模板 $\\frac{\\psi_i - 2\\psi_{i-1} + \\psi_{i-2}}{h^2}$，前提是两个向后的邻点可用。\n    d.  **不可用导数**：如果这些模板都无法构成，则该点在该轴上的导数被视为不可用，并相应地进行标记（例如，使用 `NaN`）。\n\n    对三个空间导数 $\\frac{\\partial^2 \\psi}{\\partial x^2}$、$\\frac{\\partial^2 \\psi}{\\partial y^2}$ 和 $\\frac{\\partial^2 \\psi}{\\partial z^2}$ 分别实现此逻辑，从而得到三个数值导数值数组。\n\n4.  **误差度量计算**：在计算出解析导数和数值导数后，我们可以评估两个所需的误差度量。\n    *   **哈密顿约束残差范数 ($C$)**：通过对三个数值二阶导数求和，在每个点上计算离散拉普拉斯算子 $\\nabla^2_h \\psi$。只有当一个点的所有三个轴向导数都可用时，该点才对该计算有贡献。然后，范数是所有这些可用点上的拉普拉斯算子值的均方根 (RMS)。由于解析拉普拉斯算子为零，该范数直接衡量了哈密顿约束的离散化误差。\n    *   **与方向相关的度规误差 ($E$)**：此误差专门针对与切除边界相邻的点进行计算。首先，我们识别所有“近边界”点，这些点被定义为具有至少一个直接相邻的被切除邻点的未切除点。然后，对于这个点的子集，我们计算数值二阶导数和解析二阶导数之差的均方根 (RMS)，并在数值导数可用的所有三个轴上求和。该度量旨在捕获由于在切除表面的锯齿状、与网格对齐的表示附近的模板选择而引入的局部、与方向相关的误差。\n\n整个过程被封装并为三个测试用例中的每一个执行，得到的六个标量值被格式化为所需的输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {'type': 'spherical', 'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': 0.0},\n        {'type': 'cubical',   'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': 0.0},\n        {'type': 'cubical',   'M': 1.0, 'L': 0.6, 'h': 0.02, 'Delta': 0.05, 'theta': np.pi/4},\n    ]\n\n    results = []\n    for case in test_cases:\n        C, E = solve_case(case)\n        results.extend([C, E])\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(params):\n    \"\"\"\n    Solves for a single test case configuration.\n    \"\"\"\n    M, L, h, Delta = params['M'], params['L'], params['h'], params['Delta']\n    mask_type, theta = params['type'], params['theta']\n    \n    r_h = M / 2.0\n    r_ex = r_h - Delta\n\n    # 1. Grid and Field Initialization\n    n_pts = int(2 * L / h) + 1\n    coords_1d = np.linspace(-L, L, n_pts)\n    X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n    # Add a small epsilon to avoid division by zero at r=0.\n    # The origin is always excised as r_ex > 0.\n    R = np.sqrt(X**2 + Y**2 + Z**2)\n    R_safe = R + 1e-15 \n\n    psi = 1.0 + M / (2.0 * R_safe)\n    \n    # Analytic second derivatives\n    R5 = R_safe**5\n    d2psi_dx2_an = (M / 2.0) * (3 * X**2 - R_safe**2) / R5\n    d2psi_dy2_an = (M / 2.0) * (3 * Y**2 - R_safe**2) / R5\n    d2psi_dz2_an = (M / 2.0) * (3 * Z**2 - R_safe**2) / R5\n\n    # 2. Excision Mask Generation\n    if mask_type == 'spherical':\n        is_excised = R  r_ex\n    elif mask_type == 'cubical':\n        cos_t, sin_t = np.cos(theta), np.sin(theta)\n        X_prime = X * cos_t + Y * sin_t\n        Y_prime = -X * sin_t + Y * cos_t\n        Z_prime = Z\n        is_excised = np.maximum(np.abs(X_prime), np.maximum(np.abs(Y_prime), np.abs(Z_prime)))  r_ex\n\n    # 3. Numerical Differentiation\n    d2psi_dx2_num, d2psi_dy2_num, d2psi_dz2_num = compute_numerical_derivatives(psi, h, is_excised)\n\n    # 4. Calculation of Error Metrics\n    \n    # Hamiltonian Constraint Residual Norm (C)\n    laplacian_num = np.full_like(psi, np.nan)\n    valid_lap_mask = ~np.isnan(d2psi_dx2_num)  ~np.isnan(d2psi_dy2_num)  ~np.isnan(d2psi_dz2_num)\n    laplacian_num[valid_lap_mask] = d2psi_dx2_num[valid_lap_mask] + d2psi_dy2_num[valid_lap_mask] + d2psi_dz2_num[valid_lap_mask]\n    \n    usable_laplacians = laplacian_num[~np.isnan(laplacian_num)]\n    if len(usable_laplacians)  0:\n        constraint_norm = np.sqrt(np.mean(usable_laplacians**2))\n    else:\n        constraint_norm = 0.0\n\n    # Orientation-Dependent Metric Error (E)\n    is_near_boundary = np.zeros_like(psi, dtype=bool)\n    indices = np.argwhere(~is_excised)\n    for i, j, k in indices:\n        for di, dj, dk in [(-1,0,0), (1,0,0), (0,-1,0), (0,1,0), (0,0,-1), (0,0,1)]:\n            ni, nj, nk = i + di, j + dj, k + dk\n            if 0 = ni  n_pts and 0 = nj  n_pts and 0 = nk  n_pts:\n                if is_excised[ni, nj, nk]:\n                    is_near_boundary[i, j, k] = True\n                    break\n\n    sq_errors = []\n    near_boundary_indices = np.argwhere(is_near_boundary)\n    for i, j, k in near_boundary_indices:\n        if not np.isnan(d2psi_dx2_num[i, j, k]):\n            err = d2psi_dx2_num[i, j, k] - d2psi_dx2_an[i, j, k]\n            sq_errors.append(err**2)\n        if not np.isnan(d2psi_dy2_num[i, j, k]):\n            err = d2psi_dy2_num[i, j, k] - d2psi_dy2_an[i, j, k]\n            sq_errors.append(err**2)\n        if not np.isnan(d2psi_dz2_num[i, j, k]):\n            err = d2psi_dz2_num[i, j, k] - d2psi_dz2_an[i, j, k]\n            sq_errors.append(err**2)\n\n    if len(sq_errors)  0:\n        metric_error = np.sqrt(np.mean(sq_errors))\n    else:\n        metric_error = 0.0\n        \n    return constraint_norm, metric_error\n\n\ndef compute_numerical_derivatives(psi, h, is_excised):\n    \"\"\"\n    Computes all three second partial derivatives using a hierarchical stencil choice.\n    \"\"\"\n    n_pts = psi.shape[0]\n    derivs = []\n    \n    for axis in range(3):  # 0 for x, 1 for y, 2 for z\n        d2psi_d_axis_2 = np.full_like(psi, np.nan)\n        \n        # To handle different axes generically, we transpose the arrays\n        psi_ax = np.transpose(psi, (axis, (axis + 1) % 3, (axis + 2) % 3))\n        is_excised_ax = np.transpose(is_excised, (axis, (axis + 1) % 3, (axis + 2) % 3))\n        \n        indices = np.argwhere(~is_excised_ax)\n        \n        for i, j, k in indices:\n            # Central difference\n            if 0  i  n_pts - 1 and not is_excised_ax[i-1, j, k] and not is_excised_ax[i+1, j, k]:\n                d2psi_d_axis_2[i,j,k] = (psi_ax[i+1, j, k] - 2 * psi_ax[i, j, k] + psi_ax[i-1, j, k]) / h**2\n            # One-sided forward difference\n            elif i  n_pts - 2 and not is_excised_ax[i+1, j, k] and not is_excised_ax[i+2, j, k]:\n                d2psi_d_axis_2[i,j,k] = (psi_ax[i, j, k] - 2 * psi_ax[i+1, j, k] + psi_ax[i+2, j, k]) / h**2\n            # One-sided backward difference\n            elif i  1 and not is_excised_ax[i-1, j, k] and not is_excised_ax[i-2, j, k]:\n                 d2psi_d_axis_2[i,j,k] = (psi_ax[i, j, k] - 2 * psi_ax[i-1, j, k] + psi_ax[i-2, j, k]) / h**2\n        \n        # Transpose back to original orientation\n        d2psi_d_axis_2 = np.transpose(d2psi_d_axis_2, np.argsort((axis, (axis + 1) % 3, (axis + 2) % 3)))\n        derivs.append(d2psi_d_axis_2)\n        \n    return derivs[0], derivs[1], derivs[2]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3465595"}, {"introduction": "简单的静态切除边界虽然常用，但更复杂的动态边界在物理上可能更有启发性。一种更精妙的方法是让切除边界沿着时空的特征方向移动，例如沿着向内的零性测地线。这项练习 [@problem_id:3465528] 将指导您实现一个基于零性测地线的动态切除方案。您将分析模拟的稳定性如何关键地取决于移动边界位于事件视界之内还是之外，从而加深对广义相对论中因果结构与数值稳定性之间深刻联系的理解。", "problem": "考虑一个固定的 Schwarzschild 黑洞背景在一维球对称简化下的情况，该背景在 Kerr–Schild 坐标系中表示。在几何单位制（$G=c=1$）下工作，并以黑洞质量 $M$ 为单位来度量时间和长度，从而使所有物理量都无量纲。您的任务是实现一个基于零测地线的切除方案，其中内边界在 Kerr–Schild 坐标系中沿内行零测地线运动。您将通过演化两个分别沿内行和外行零测地线方向传播的解耦特征场来模拟一个对称双曲系统的主要部分，并评估其稳定性和约束泄漏。\n\n起点和要求从第一性原理进行的推导：\n- 从 Schwarzschild 度规 $g_{\\mu\\nu}$ 的 Kerr–Schild 形式及其具有演化函数 $\\alpha$、移位矢量 $\\beta^i$ 和空间度规 $\\gamma_{ij}$ 的 $3+1$ 分解开始。使用 $3+1$ 分解中的标准性质，即类光信号在径向相对于坐标时间的特征速度由 $-\\beta^r \\pm \\alpha \\sqrt{\\gamma^{rr}}$ 给出。推导出内行和外行零特征线的显式径向坐标速度 $v_{-}(r)$ 和 $v_{+}(r)$，并仅表示为 $r$ 和 $M$ 的函数。\n- 使用零矢量 $l^\\mu$（内行）和 $n^\\mu$（外行），相对于 $g_{\\mu\\nu}$ 进行归一化，使得 $l^\\mu l_\\mu = n^\\mu n_\\mu = 0$ 和 $l^\\mu n_\\mu = -1$。沿着 $l^\\mu$ 和 $n^\\mu$ 进行特征分解，定义两个标量特征变量 $w_l$ 和 $w_n$，它们分别以速度 $v_{-}(r)$ 和 $v_{+}(r)$ 传播。您的演化模型是以下解耦的一阶双曲系统：\n$$\n\\partial_t w_l + v_{-}(r)\\,\\partial_r w_l = 0,\\qquad\n\\partial_t w_n + v_{+}(r)\\,\\partial_r w_n = 0.\n$$\n- 通过使内边界沿内行零测地线移动来实现基于零测地线的切除。在 Kerr–Schild 坐标系中，这意味着内边界半径 $r_{\\mathrm{in}}(t)$ 必须满足\n$$\n\\frac{dr_{\\mathrm{in}}}{dt} = v_{-}(r_{\\mathrm{in}}(t)).\n$$\n- 对于位于 $r=r_{\\max}$ 的外边界，通过规定没有入射的内行零模式来消除入射内容，即设置边界条件使从 $r_{\\max}$ 进入的 $w_l$ 为零。\n\n数值方法要求：\n- 在间距为 $\\Delta r$ 的均匀网格上离散化空间坐标 $r$。通过 Courant–Friedrichs–Lewy (CFL) 条件选择时间步长 $\\Delta t$，使得 $\\max_r |v_{\\pm}(r)|\\,\\Delta t/\\Delta r \\leq \\lambda$，其中 $0  \\lambda  1$ 是给定的 Courant 因子。使用三阶强稳定保持 (SSP) Runge–Kutta 方法进行时间积分。\n- 使用与特征速度局部符号一致的迎风有限差分法计算空间导数。如果内切除边界位于视界或其内部，则它是一个纯流出边界；因此，它不需要为进入计算区域的模式设置边界条件。如果内边界位于视界之外，则在内边界处将存在一个进入计算区域的外行零模式 $w_n$；如果在那里没有提供数据，该方案可能会变得不稳定。\n- 为了评估约束泄漏，定义一个一阶简化约束的代理。根据标量场的特征分解重建一个辅助场 $\\Phi$，\n$$\n\\Phi(r,t) \\equiv \\frac{w_n(r,t) - w_l(r,t)}{2\\,\\sqrt{\\gamma^{rr}(r)}},\n$$\n然后通过从内边界对 $\\Phi$ 进行离散线积分，在网格上构造一个标量势 $\\phi(r,t)$。定义离散约束\n$$\nC(r,t) \\equiv \\left(\\partial_r \\phi\\right)_{\\mathrm{num}} - \\Phi(r,t),\n$$\n其中 $\\left(\\partial_r \\phi\\right)_{\\mathrm{num}}$ 是一个一致的有限差分近似。使用活动计算区域上的 $L^2$-范数来测量最终时刻的无量纲泄漏率\n$$\n\\mathcal{R} \\equiv \\frac{\\|C(\\cdot,T)\\|_{2}}{\\|\\Phi(\\cdot,T)\\|_{2}}.\n$$\n\n初始数据和外边界：\n- 将 $w_n(r,0)$ 设置为一个高斯脉冲，振幅为 $A$，中心在 $r=r_0$，宽度为 $\\sigma$，即 $w_n(r,0) = A \\exp\\left(-\\frac{(r-r_0)^2}{\\sigma^2}\\right)$。\n- 设置 $w_l(r,0)=0$。\n- 在外边界 $r=r_{\\max}$ 处施加条件，不允许内行内容进入计算区域：实施一个与 $w_l=0$ 在计算区域外为零一致的边界条件。\n\n稳定性评估：\n- 令瞬时 $L^2$-范数为 $\\|W(\\cdot,t)\\|_2$，由 $w_l$ 和 $w_n$ 在活动计算区域上计算得出，例如，作为 $w_l^2+w_n^2$ 的积分（用黎曼和近似）的平方根。跟踪增长因子\n$$\nG \\equiv \\frac{\\max_{t\\in[0,T]} \\|W(\\cdot,t)\\|_2}{\\|W(\\cdot,0)\\|_2}.\n$$\n- 定义方案在 $G \\leq 1.3$ 时为稳定，否则为不稳定。\n\n程序中要编码的实现细节：\n- 在 $r\\in[r_{\\min}, r_{\\max}]$ 上使用均匀网格，其中 $r_{\\min}>0$。在每个时间步，根据上述内行零测地线方程推进内切除半径 $r_{\\mathrm{in}}(t)$。时间 $t$ 的活动计算网格是满足 $r \\geq r_{\\mathrm{in}}(t)$ 的点集。\n- 对于 $w_l$，始终使用与 $v_{-}(r)$ 一致的迎风导数。对于 $w_n$，在内部使用与 $v_{+}(r)$ 一致的迎风导数。在外边界，通过与 $w_l=0$ 在外部一致的单边导数来施加无入射 $w_l$ 的条件。在内边界，不提供边界数据；当内边界在视界之外以至于 $v_{+}(r_{\\mathrm{in}})0$ 时，对第一个活动点的 $w_n$ 使用形式上的顺风导数，以反映边界数据的缺失并揭示潜在的不稳定性。\n- 从当前内边界点开始，通过对 $\\Phi$ 进行离散线积分来计算 $\\phi$，然后通过有限差分计算离散梯度 $\\left(\\partial_r \\phi\\right)_{\\mathrm{num}}$。\n\n测试套件：\n为以下三个测试用例运行您的程序。所有量均使用 $M$ 为单位，所有输出均表示为纯数字（无量纲小数）：\n1. 用例 A（允许的切除，预期稳定）：$M=1$, $A=1$, $r_0=12$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=50$, 网格点数 $N=600$, Courant 因子 $\\lambda=0.6$, 最终时间 $T=8$, 内边界初始半径 $r_{\\mathrm{in}}(0)=2.0$。\n2. 用例 B（不允许的切除，预期不稳定）：$M=1$, $A=1$, $r_0=10$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=30$, $N=500$, $\\lambda=0.6$, $T=6$, $r_{\\mathrm{in}}(0)=2.4$。\n3. 用例 C（允许的切除，使用紧凑的 Courant 因子）：$M=1$, $A=1$, $r_0=10$, $\\sigma=1$, $r_{\\min}=0.1$, $r_{\\max}=30$, $N=200$, $\\lambda=0.9$, $T=6$, $r_{\\mathrm{in}}(0)=2.0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个列表的列表，每个内部列表对应一个测试用例，每个内部列表的形式为 $[\\text{stable}, G, \\mathcal{R}]$，其中 $\\text{stable}$ 是一个布尔值，$G$ 是一个浮点数，$\\mathcal{R}$ 是一个浮点数。例如，打印的行必须如下所示\n\"[ [True,1.05,0.0123],[False,3.7,0.45],[True,1.12,0.021] ]\"\n其中包含您计算得到的实际数值。不应打印任何额外的文本。", "solution": "该问题是有效的，因为它提出了一个数值相对论中适定且具有科学依据的任务。它要求推导基本量，实现具有特定边界处理的标准数值方案，以及分析稳定性和误差，所有这些都是计算物理学中的标准实践。\n\n我们的第一步是从球坐标下 Schwarzschild 度规的 Kerr-Schild 形式推导出特征速度。在几何单位制（$G=c=1$）下，线元由下式给出\n$$\nds^2 = -\\left(1 - \\frac{2M}{r}\\right) dt^2 + \\frac{4M}{r} dt dr + \\left(1 + \\frac{2M}{r}\\right) dr^2 + r^2 d\\Omega^2.\n$$\n这对应于一个广义的 3+1 分解线元\n$$\nds^2 = (-\\alpha^2 + \\beta_i \\beta^i) dt^2 + 2\\beta_i dt dx^i + \\gamma_{ij} dx^i dx^j.\n$$\n通过比较一维球对称系统（其中空间坐标仅为 $r$）的度规分量，我们确定了演化函数 $\\alpha$、协变和逆变径向移位分量 $\\beta_r$ 和 $\\beta^r$，以及协变和逆变径向空间度规分量 $\\gamma_{rr}$ 和 $\\gamma^{rr}$。\n从度规中，我们有：\n- 空间度规分量：$\\gamma_{rr} = g_{rr} = 1 + \\frac{2M}{r}$。其逆为 $\\gamma^{rr} = \\left(1 + \\frac{2M}{r}\\right)^{-1} = \\frac{r}{r+2M}$。\n- 协变移位分量：$\\beta_r = g_{tr} = \\frac{2M}{r}$。\n- 逆变移位分量：$\\beta^r = \\gamma^{rr} \\beta_r = \\frac{r}{r+2M} \\cdot \\frac{2M}{r} = \\frac{2M}{r+2M}$。\n- 演化函数：$\\alpha^2 = \\beta_i \\beta^i - g_{tt} = \\beta_r \\beta^r - g_{tt} = \\left(\\frac{2M}{r}\\right)\\left(\\frac{2M}{r+2M}\\right) - \\left(-1 + \\frac{2M}{r}\\right) = \\frac{4M^2}{r(r+2M)} + 1 - \\frac{2M}{r} = \\frac{4M^2 + r(r+2M) - 2M(r+2M)}{r(r+2M)} = \\frac{4M^2 + r^2 + 2Mr - 2Mr - 4M^2}{r(r+2M)} = \\frac{r^2}{r(r+2M)} = \\frac{r}{r+2M}$。因此，$\\alpha = \\sqrt{\\frac{r}{r+2M}}$。\n\n径向特征速度由 $v_{\\pm}(r) = -\\beta^r \\pm \\alpha \\sqrt{\\gamma^{rr}}$ 给出。代入我们推导出的量：\n$$\nv_{\\pm}(r) = -\\frac{2M}{r+2M} \\pm \\sqrt{\\frac{r}{r+2M}} \\sqrt{\\frac{r}{r+2M}} = -\\frac{2M}{r+2M} \\pm \\frac{r}{r+2M} = \\frac{-2M \\pm r}{r+2M}.\n$$\n这给出了内行和外行速度：\n- 内行速度：$v_{-}(r) = \\frac{-2M-r}{r+2M} = -1$。\n- 外行速度：$v_{+}(r) = \\frac{r-2M}{r+2M}$。\n\n$v_{-}(r) = -1$ 这个显著的结果表明，在 Kerr-Schild 坐标系中，内行零测地线具有恒定的坐标速度。内部切除边界的演化方程 $\\frac{dr_{\\mathrm{in}}}{dt} = v_{-}(r_{\\mathrm{in}}(t))$ 简化为 $\\frac{dr_{\\mathrm{in}}}{dt} = -1$，得出轨迹 $r_{\\mathrm{in}}(t) = r_{\\mathrm{in}}(0) - t$。\n\n该模型由两个针对特征场 $w_l$ 和 $w_n$ 的解耦线性平流方程组成：\n$$\n\\partial_t w_l + v_{-}(r)\\,\\partial_r w_l = 0 \\implies \\partial_t w_l - \\partial_r w_l = 0 \\\\\n\\partial_t w_n + v_{+}(r)\\,\\partial_r w_n = 0\n$$\n这些方程在均匀网格 $r \\in [r_{\\min}, r_{\\max}]$ 上求解，网格间距为 $\\Delta r$。CFL 条件要求 $\\Delta t \\le \\lambda \\frac{\\Delta r}{\\max(|v_{-}|, |v_{+}|)}$。由于 $|v_{-}|=1$ 且对于 $r \\ge 0$，$|v_{+}| = |\\frac{r-2M}{r+2M}| \\le 1$，最大速度为 $1$。因此，我们选择 $\\Delta t = \\lambda \\Delta r$。\n\n数值方案采用：\n1.  **时间积分**：使用三阶强稳定保持 Runge-Kutta (SSP-RK3) 方法来推进解的时间演化。\n2.  **空间离散化**：对空间导数 $\\partial_r w_l$ 和 $\\partial_r w_n$ 使用一阶迎风有限差分。\n    - 对于 $w_l$，速度 $v_{-} = -1  0$，信息从较大的 $r$ 传播到较小的 $r$。迎风法需要前向差分：$(\\partial_r w_l)_i \\approx \\frac{(w_l)_{i+1} - (w_l)_i}{\\Delta r}$。\n    - 对于 $w_n$，速度 $v_{+}(r)$ 在事件视界 $r=2M$ 处改变符号。\n        - 如果 $r>2M$，$v_{+}>0$，信息从较小的 $r$ 传播。迎风法需要后向差分：$(\\partial_r w_n)_i \\approx \\frac{(w_n)_i - (w_n)_{i-1}}{\\Delta r}$。\n        - 如果 $r \\le 2M$，$v_{+} \\le 0$，信息从较大的 $r$ 传播。迎风法需要前向差分：$(\\partial_r w_n)_i \\approx \\frac{(w_n)_{i+1} - (w_n)_i}{\\Delta r}$。\n\n**边界与切除处理**：\n- **外边界 ($r=r_{\\max}$)**：通过在计算区域外的虚拟单元中设置 $w_l=0$ 来施加无内行内容入射的条件。对于最后一个网格点 $i=N-1$ 处 $w_l$ 的导数，这给出 $(\\partial_r w_l)_{N-1} \\approx \\frac{0 - (w_l)_{N-1}}{\\Delta r}$。\n- **内部切除边界 ($r_{\\mathrm{in}}(t)$)**：计算区域被限制在 $r_i \\ge r_{\\mathrm{in}}(t)$ 的网格点上。\n    - 方案的稳定性关键取决于 $r_{\\mathrm{in}}(t)$相对于事件视界 $r=2M$ 的位置。\n    - 如果 $r_{\\mathrm{in}}(t) \\le 2M$，边界点的所有特征都指向较小的 $r$（进入切除区域）。因此，边界是一个纯流出边界，不需要数据。迎风格式自然地处理了这种情况。\n    - 如果 $r_{\\mathrm{in}}(t) > 2M$，则 $v_{+}(r_{\\mathrm{in}}) > 0$。$w_n$ 的特征线指向计算区域内部。由于我们不提供边界数据，该方案是不适定的。问题指定在第一个活动网格点对 $w_n$ 使用“形式上的顺风”导数（前向差分）。这种选择虽然允许代码运行，但已知是不稳定的，并预期会导致解的指数增长，如用例 B 所示。\n\n**分析指标**：\n- **稳定性**：增长因子 $G \\equiv \\frac{\\max_{t\\in[0,T]} \\|W(\\cdot,t)\\|_2}{\\|W(\\cdot,0)\\|_2}$ 测量解的总 $L^2$-范数的放大，其中 $\\|W\\|_2^2 = \\int (w_l^2+w_n^2)dr$。$G>1$（允许一个小的容差，此处为 $1.3$）的值表示不稳定。\n- **约束泄漏**：为评估数值误差，定义了一个代理约束 $C(r,t) \\equiv \\left(\\partial_r \\phi\\right)_{\\mathrm{num}} - \\Phi(r,t)$。这里，$\\Phi \\equiv \\frac{w_n - w_l}{2\\sqrt{\\gamma^{rr}}}$ 是一个辅助场，而 $\\phi$ 是它从内边界开始的离散积分。非零的 $C$ 表示数值积分和微分之间的不一致性。泄漏率 $\\mathcal{R} \\equiv \\frac{\\|C(\\cdot,T)\\|_{2}}{\\|\\Phi(\\cdot,T)\\|_{2}}$ 量化了这种误差。\n\n实现遵循这些原则，根据指定的测试用例演化 $w_n$ 的初始高斯脉冲和 $w_l$ 的零场，并报告由此产生的稳定性和误差指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (admissible excision, expected stable)\n        {'M': 1, 'A': 1, 'r0': 12, 'sigma': 1, 'rmin': 0.1, 'rmax': 50, 'N': 600, 'lambda_': 0.6, 'T': 8, 'r_in0': 2.0},\n        # Case B (inadmissible excision, expected unstable)\n        {'M': 1, 'A': 1, 'r0': 10, 'sigma': 1, 'rmin': 0.1, 'rmax': 30, 'N': 500, 'lambda_': 0.6, 'T': 6, 'r_in0': 2.4},\n        # Case C (admissible excision with tight Courant factor)\n        {'M': 1, 'A': 1, 'r0': 10, 'sigma': 1, 'rmin': 0.1, 'rmax': 30, 'N': 200, 'lambda_': 0.9, 'T': 6, 'r_in0': 2.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(**case)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\ndef run_simulation(M, A, r0, sigma, rmin, rmax, N, lambda_, T, r_in0):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    r = np.linspace(rmin, rmax, N)\n    dr = r[1] - r[0]\n\n    def v_plus(r_val, M_val):\n        return np.divide(r_val - 2 * M_val, r_val + 2 * M_val)\n    \n    dt = lambda_ * dr\n\n    w_l = np.zeros(N)\n    w_n = A * np.exp(-(r - r0)**2 / sigma**2)\n\n    t = 0.0\n    r_in = r_in0\n\n    def l2_norm_combined(arr1, arr2, i_start, dr_val):\n        if i_start = len(arr1):\n            return 0.0\n        active_slice = slice(i_start, None)\n        return np.sqrt(np.sum(arr1[active_slice]**2 + arr2[active_slice]**2) * dr_val)\n\n    i_in_initial = np.searchsorted(r, r_in, side='left')\n    initial_norm = l2_norm_combined(w_l, w_n, i_in_initial, dr)\n    if initial_norm == 0: initial_norm = 1.0 # Avoid division by zero\n    max_norm = initial_norm\n\n    def calculate_rhs(wl_in, wn_in, r_grid, dr_val, M_val, i_in_idx):\n        N_pts = len(r_grid)\n        rhs_l = np.zeros(N_pts)\n        rhs_n = np.zeros(N_pts)\n        \n        if i_in_idx = N_pts: # No active points\n            return rhs_l, rhs_n\n\n        # RHS for w_l (v_minus = -1, upwind is forward difference)\n        for i in range(i_in_idx, N_pts - 1):\n             rhs_l[i] = (wl_in[i+1] - wl_in[i]) / dr_val # -v_minus * deriv, where v_minus=-1\n        \n        # Outer boundary for w_l (ghost point wl=0)\n        rhs_l[N_pts - 1] = (0 - wl_in[N_pts-1]) / dr_val\n        \n        # RHS for w_n\n        vp_grid = v_plus(r_grid, M_val)\n        \n        # Inner boundary for w_n (at i_in_idx)\n        if i_in_idx  N_pts - 1:\n            # Per problem spec, use forward difference to reveal instability.\n            # This is upwind if v_p0, and downwind if v_p>0.\n            deriv_n = (wn_in[i_in_idx+1] - wn_in[i_in_idx]) / dr_val\n            rhs_n[i_in_idx] = -vp_grid[i_in_idx] * deriv_n\n        \n        # Interior points for w_n\n        for i in range(i_in_idx + 1, N_pts - 1):\n            if vp_grid[i]  0: # Upwind is backward\n                deriv_n = (wn_in[i] - wn_in[i-1]) / dr_val\n            else: # Upwind is forward\n                deriv_n = (wn_in[i+1] - wn_in[i]) / dr_val\n            rhs_n[i] = -vp_grid[i] * deriv_n\n\n        # Outer boundary for w_n (at N_pts - 1)\n        if N_pts - 1  i_in_idx:\n            i = N_pts - 1\n            if vp_grid[i]  0: # Upwind is backward (normal case)\n                deriv_n = (wn_in[i] - wn_in[i-1]) / dr_val\n                rhs_n[i] = -vp_grid[i] * deriv_n\n            # else: case v_p=0 not expected at r_max for these problems.\n\n        return rhs_l, rhs_n\n\n    while t  T:\n        current_dt = min(dt, T - t)\n        if current_dt  1e-12: break\n        \n        i_in = np.searchsorted(r, r_in, side='left')\n        \n        # SSP-RK3\n        # Stage 1\n        rhs_l_1, rhs_n_1 = calculate_rhs(w_l, w_n, r, dr, M, i_in)\n        w_l_1 = w_l + current_dt * rhs_l_1\n        w_n_1 = w_n + current_dt * rhs_n_1\n        \n        # Stage 2\n        rhs_l_2, rhs_n_2 = calculate_rhs(w_l_1, w_n_1, r, dr, M, i_in)\n        w_l_2 = 0.75 * w_l + 0.25 * (w_l_1 + current_dt * rhs_l_2)\n        w_n_2 = 0.75 * w_n + 0.25 * (w_n_1 + current_dt * rhs_n_2)\n\n        # Stage 3\n        rhs_l_3, rhs_n_3 = calculate_rhs(w_l_2, w_n_2, r, dr, M, i_in)\n        w_l = (1/3) * w_l + (2/3) * (w_l_2 + current_dt * rhs_l_3)\n        w_n = (1/3) * w_n + (2/3) * (w_n_2 + current_dt * rhs_n_3)\n        \n        t += current_dt\n        r_in -= current_dt # dr_in/dt = -1\n\n        i_in_new = np.searchsorted(r, r_in, side='left')\n        current_norm = l2_norm_combined(w_l, w_n, i_in_new, dr)\n        if current_norm  max_norm:\n            max_norm = current_norm\n    \n    G = max_norm / initial_norm\n    stable = G = 1.3\n    \n    i_in_final = np.searchsorted(r, r_in, side='left')\n    \n    # If all points are excised, constraint error is zero.\n    if i_in_final = N or r[i_in_final:].size == 0:\n         return [stable, G, 0.0]\n\n    active_slice = slice(i_in_final, None)\n    active_r = r[active_slice]\n    active_wl = w_l[active_slice]\n    active_wn = w_n[active_slice]\n        \n    sqrt_gamma_rr = np.sqrt(np.divide(active_r, active_r + 2 * M))\n    Phi = np.divide(active_wn - active_wl, 2 * sqrt_gamma_rr, out=np.zeros_like(active_wn), where=(sqrt_gamma_rr  1e-12))\n    \n    phi = np.zeros_like(Phi)\n    # Trapezoidal rule for integration\n    for i in range(1, len(phi)):\n        phi[i] = phi[i-1] + 0.5 * (Phi[i] + Phi[i-1]) * dr\n        \n    d_phi_num = np.zeros_like(phi)\n    if len(phi)  1:\n        d_phi_num[0] = (phi[1] - phi[0]) / dr # Forward difference\n        d_phi_num[-1] = (phi[-1] - phi[-2]) / dr # Backward difference\n        # Centered difference for interior\n        for i in range(1, len(phi) - 1):\n            d_phi_num[i] = (phi[i+1] - phi[i-1]) / (2 * dr)\n    \n    C = d_phi_num - Phi\n    \n    norm_C = np.sqrt(np.sum(C**2) * dr)\n    norm_Phi = np.sqrt(np.sum(Phi**2) * dr)\n    \n    R = 0.0\n    if norm_Phi  1e-12:\n        R = norm_C / norm_Phi\n\n    return [stable, float(G), float(R)]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3465528"}, {"introduction": "在完成一次复杂的数值模拟后，一个至关重要的步骤是验证其输出数据的物理真实性。如果切除边界上的数值处理不完美，可能会导致一部分波被虚假地反射回计算区域，在最终提取的引力波信号中产生非物理的“回声”。这最后一项练习 [@problem_id:3465572] 为您提供了一个强大的信号处理诊断工具——倒谱分析（cepstral analysis）。您将学习如何实现一个算法，用它来探测合成信号中这些微弱的回声，从而能够将数值伪影与黑洞铃振的真实物理过程区分开来。", "problem": "设计并实现一个程序，该程序对一组人工合成的、按模式分解的Weyl标量信号执行基于原理的谱诊断，以判断是否存在由黑洞切除（black hole excision）引入的内边界反射，并估计相应的回波延迟。这些信号代表Weyl标量的方位角傅里叶模式，对于模式索引 $m$，记为 $a_m(t)$。您的任务是基于线性波传播、傅里叶分析和倒谱方法的基本原理，推导、实现并验证一种诊断方法。\n\n从以下与情境相符的基本基础出发：\n- 在固定背景上的线性波传播意味着叠加原理对出射和反射分量均成立。如果内边界以幅度反射系数 $\\rho$ 和往返延迟 $\\tau$ 反射一小部分入射场，则观测到的模式振幅可以建模为一个主分量与一个延迟、缩放的副本之和。\n- 离散傅里叶变换（DFT）通过恒等式 $e^{-i \\omega \\tau}$ 将时域延迟与频域中的周期性调制联系起来，即时域延迟 $\\tau$ 会使傅里叶变换乘以该因子，其中 $\\omega$ 是角频率。频域中的周期性调制会导致间隔为 $\\Delta \\omega = 2\\pi/\\tau$ 的结构。实倒谱是通过对幅度谱的对数进行傅里叶逆变换得到的，它在等于回波延迟 $\\tau$ 的倒频率（quefrency）处表现出峰值。\n- 一个阻尼正弦波 $s(t)=A e^{-\\alpha t}\\cos(2\\pi f_0 t + \\phi) H(t)$，其中 $H(t)$ 是亥维赛德阶跃函数，对应于频域中的单个复极点，并且不会引入谱梳或跨不同 $m$ 模式的通用非零倒谱峰。\n\n问题要求：\n1) 信号模型与合成。对于每个测试用例，您将合成在采样频率 $f_s$ 下持续时间为 $T$ 的时间序列 $a_m(t)$，其中 $m \\in \\{2,3,4\\}$。使用模型\n$$\na_m(t) = A_m e^{-\\alpha t}\\cos\\!\\big(2\\pi f_m t + \\phi_m\\big) H(t)\n+ \\rho\\,A_m e^{-\\alpha (t-\\tau)} \\cos\\!\\big(2\\pi f_m (t-\\tau) + \\phi_m + \\pi\\big) H(t-\\tau) + n_m(t),\n$$\n其中 $A_m$ 是模式振幅， $f_m$ 是模式铃振频率， $\\alpha$ 是阻尼率， $\\phi_m$ 是恒定相位（您可以设置 $\\phi_m=0$），$\\rho \\in [0,1)$ 是反射系数，$\\tau>0$ 是回波延迟，而 $n_m(t)$ 是零均值白高斯噪声。所有时间单位必须是秒，所有频率单位必须是赫兹，最终的延迟估计必须以秒为单位报告。\n\n2) 用于区分伪影和物理准正规模的谱诊断。仅使用线性系统和傅里叶分析的第一性原理：\n- 对每个 $m$，计算 $a_m(t)$ 的幅度谱及其实倒谱。在变换前，在时域上使用Hann窗以减轻谱泄漏。\n- 通过在物理上合理的搜索频带 $[\\tau_{\\min},\\tau_{\\max}]$ 内定位实倒谱中占主导地位的非零倒频率峰，来识别候选回波延迟 $\\hat{\\tau}_m$。\n- 使用在搜索频带内定义的稳健统计量来量化峰的显著性：\n$$\nS_m \\equiv \\frac{C_m(\\hat{\\tau}_m) - \\mathrm{median}\\big(C_m([\\tau_{\\min},\\tau_{\\max}])\\big)}{\\mathrm{MAD}\\big(C_m([\\tau_{\\min},\\tau_{\\max}])\\big)},\n$$\n其中 $C_m(\\cdot)$ 是实倒谱，$\\mathrm{MAD}$ 是中位数绝对偏差。如果 $S_m \\ge 6$，则认为峰是显著的。\n- 通过频域结构独立验证延迟：计算对数幅度谱在频率箱上的自相关，以获得一个主导的间隔 $\\widehat{\\Delta f}_m$（单位赫兹），该间隔被限制在对应于 $[1/\\tau_{\\max}, 1/\\tau_{\\min}]$ 的频带内。回波理论预测 $\\widehat{\\Delta f}_m \\approx 1/\\hat{\\tau}_m$。如果满足以下条件，则声明一致：\n$$\n\\left|\\frac{1/\\hat{\\tau}_m - \\widehat{\\Delta f}_m}{\\widehat{\\Delta f}_m}\\right| \\le 0.25.\n$$\n- 如果三个模式中至少有两个既有显著的倒谱峰，又通过了间隔一致性检查，并且跨模式一致性成立（即 $\\{\\hat{\\tau}_m\\}$ 的四分位距除以其中位数最多为 $0.3$），则断定存在内边界反射伪影。否则，声明无伪影。\n\n3) 估计。当声明存在伪影时，将最终延迟估计 $\\hat{\\tau}$ 报告为各模式中被接受的 $\\hat{\\tau}_m$ 的中位数。如果未检测到伪影，则报告 $\\hat{\\tau}=0$。最终延迟以秒为单位表示。\n\n4) 强制执行的实现细节：\n- 在DFT之前使用Hann窗。使用计算为对数幅度谱的逆实DFT的实倒谱。为避免对零取对数，在取对数之前向幅度谱加上一个小的正则化项 $\\epsilon$，其中 $\\epsilon=10^{-12}$。\n- 搜索频带：设置 $\\tau_{\\min}=8\\times 10^{-4}$ 秒和 $\\tau_{\\max}=3\\times 10^{-2}$ 秒。\n- 使用固定的随机种子以确保可复现性。\n- 内部角度必须使用弧度。如果您使用任何角度，请指明它们；此处相位是固定的，可以设置为零。\n\n测试套件与参数：\n使用以下五个测试用例。对于所有情况，设 $f_s=8192$ 赫兹， $T=1$ 秒， $m\\in\\{2,3,4\\}$，其中 $(f_2,f_3,f_4)=(250,400,550)$ 赫兹， $(A_2,A_3,A_4)=(1.0,0.8,0.6)$ （无量纲）， $\\alpha=100$ s$^{-1}$， $\\phi_m=0$，噪声标准差 $\\sigma=5\\times 10^{-3}$ （无量纲）。\n- 情况 1：$\\rho=0.0$，$\\tau$ 任意（使用 $\\tau=0.01$ s，但由于 $\\rho=0$，此值无关紧要）。预期输出：无伪影，$\\hat{\\tau}=0$ s。\n- 情况 2：$\\rho=0.25$，$\\tau=0.01$ s。\n- 情况 3：$\\rho=0.15$，$\\tau=0.003$ s。\n- 情况 4：$\\rho=0.08$，$\\tau=0.001$ s。\n- 情况 5：$\\rho=0.25$，$\\tau=0.02$ s。\n\n程序要求：\n- 您的程序必须为每种情况合成信号，应用上述诊断方法，并为每种情况生成一对 $[\\mathrm{artifact\\_detected}, \\hat{\\tau}]$，其中 $\\mathrm{artifact\\_detected}$ 是一个布尔值，$\\hat{\\tau}$ 是一个以秒为单位的浮点数。报告 $\\hat{\\tau}$ 时，单位为秒，并至少保留4位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个项目本身是按上述顺序排列的双元素列表。例如，一个有效的输出可能看起来像\n$[[\\mathrm{True},0.010000],[\\mathrm{False},0.000000],\\dots]$。", "solution": "该问题要求设计并实现一种谱诊断算法，用于检测合成引力波信号（特别是按模式分解的Weyl标量 $a_m(t)$）中是否存在人为回波。这些回波可能源于数值伪影，例如黑洞切除方案中内边界的反射。回波延迟 $\\tau$ 的检测和估计必须基于波传播和傅里叶分析的第一性原理。\n\n该问题在科学上基础扎实，算法上定义明确，并且所有必要的参数都已提供。它代表了数值相对论模拟验证领域一个有效且相关的挑战。我们着手解决。\n\n对于每个方位角模式 $m$，观测到的信号的基础模型由主信号、一个反射的延迟副本以及噪声叠加而成。主信号代表黑洞的准正规模（QNM），它是一个阻尼正弦波。\n因此，完整的时域信号 $a_m(t)$ 被建模为：\n$$\na_m(t) = s_m(t) + \\delta s_m(t) + n_m(t)\n$$\n其中 $s_m(t)$ 是主QNM信号，$\\delta s_m(t)$ 是回波，而 $n_m(t)$ 是噪声。具体来说，\n$$\ns_m(t) = A_m e^{-\\alpha t}\\cos\\!\\big(2\\pi f_m t + \\phi_m\\big) H(t)\n$$\n$$\n\\delta s_m(t) = \\rho\\,A_m e^{-\\alpha (t-\\tau)} \\cos\\!\\big(2\\pi f_m (t-\\tau) + \\phi_m + \\pi\\big) H(t-\\tau)\n$$\n此处，$A_m$、$f_m$ 和 $\\phi_m$ 分别是模式的振幅、频率和相位；$\\alpha$ 是阻尼率；$H(t)$ 是亥维赛德阶跃函数；$\\rho$ 是反射系数；$\\tau$ 是回波的往返延迟时间；而 $n_m(t)$ 是零均值白高斯噪声。回波项中的 $\\pi$ 相移（使余弦项等效于 $-\\cos(\\dots)$）是反射的一个常见特征。因此，回波项可以写为 $-\\rho s_m(t-\\tau)$。\n\n检测回波的核心原理在于傅里叶域。设 $S_m(\\omega)$ 是主信号 $s_m(t)$ 的傅里叶变换。根据傅里叶变换的时移性质，回波项 $-\\rho s_m(t-\\tau)$ 的变换是 $-\\rho e^{-i\\omega\\tau} S_m(\\omega)$，其中 $\\omega=2\\pi f$ 是角频率。总无噪声信号的傅里叶变换为：\n$$\nA_m(\\omega) \\approx S_m(\\omega) - \\rho e^{-i\\omega\\tau} S_m(\\omega) = S_m(\\omega) \\left(1 - \\rho e^{-i\\omega\\tau}\\right)\n$$\n因此，频谱的幅度受到一个周期性因子的调制：\n$$\n|A_m(\\omega)| \\approx |S_m(\\omega)| \\left|1 - \\rho e^{-i\\omega\\tau}\\right| = |S_m(\\omega)| \\sqrt{\\left(1 - \\rho\\cos(\\omega\\tau)\\right)^2 + \\left(\\rho\\sin(\\omega\\tau)\\right)^2} = |S_m(\\omega)| \\sqrt{1 - 2\\rho\\cos(\\omega\\tau) + \\rho^2}\n$$\n这个表达式表明，幅度谱 $|A_m(\\omega)|$ 上叠加了一个周期性调制，或称“涟波”，其频率间隔与延迟 $\\tau$ 相关。这种调制的角频率周期是 $\\Delta\\omega = 2\\pi/\\tau$，对应于循环频率周期 $\\Delta f = 1/\\tau$。检测这种周期性结构等同于检测回波。\n\n倒谱分析是检测此类周期性的强大工具。实倒谱 $C_m(q)$ 定义为信号幅度谱对数的傅里叶逆变换。变量 $q$ 被称为“倒频率”（quefrency），单位是时间。\n$$\nC_m(q) = \\mathcal{F}^{-1} \\left\\{ \\log |A_m(\\omega)| \\right\\}\n$$\n取对数将乘性调制转换为加性调制：\n$$\n\\log|A_m(\\omega)| \\approx \\log|S_m(\\omega)| + \\log\\left(\\sqrt{1 - 2\\rho\\cos(\\omega\\tau) + \\rho^2}\\right)\n$$\n对于小反射系数 $\\rho \\ll 1$，可以使用 $\\log(1+x) \\approx x$ 进行近似：\n$$\n\\log\\left(\\sqrt{1 - 2\\rho\\cos(\\omega\\tau) + \\rho^2}\\right) = \\frac{1}{2}\\log\\left(1 - 2\\rho\\cos(\\omega\\tau) + \\rho^2\\right) \\approx -\\rho\\cos(\\omega\\tau)\n$$\n项 $\\cos(\\omega\\tau)$ 可写为 $\\frac{1}{2}(e^{i\\omega\\tau} + e^{-i\\omega\\tau})$。它的傅里叶逆变换由位于倒频率 $q = \\pm\\tau$ 处的两个δ函数组成。因此，倒谱 $C_m(q)$ 预期在等于回波延迟 $q=\\tau$ 的倒频率处呈现一个尖峰。主信号的谱 $\\log|S_m(\\omega)|$ 是一个缓变函数，主要贡献于倒谱的低倒频率部分。\n\n规定的算法将此检测策略形式化为一个稳健的多阶段过程：\n\n1.  **信号合成与预处理**：对每个模式 $m$，生成时间序列 $a_m(t)$。为了最大限度地减少有限信号持续时间造成的谱泄漏（这可能掩盖微弱的谱涟波），在进行离散傅里叶变换（DFT）之前，对 $a_m(t)$ 应用Hann窗。在取对数之前，向幅度谱加上一个小的正则化常数 $\\epsilon=10^{-12}$，以防止对等于或接近零的值进行计算时出现数值问题。\n\n2.  **倒谱分析与峰值检测**：通过对数幅度谱的逆实DFT计算实倒谱。在一个物理上合理的倒频率范围 $[\\tau_{\\min}, \\tau_{\\max}]$（指定为 $[8 \\times 10^{-4}, 3 \\times 10^{-2}]$ 秒）内搜索一个主导峰。该峰的倒频率提供了延迟的估计值 $\\hat{\\tau}_m$。\n\n3.  **显著性检验**：噪声的存在意味着倒谱不会为零。为了区分真实的回波峰和背景波动，计算一个稳健的显著性统计度量 $S_m$。\n    $$\n    S_m \\equiv \\frac{C_m(\\hat{\\tau}_m) - \\mathrm{median}\\big(C_m([\\tau_{\\min},\\tau_{\\max}])\\big)}{\\mathrm{MAD}\\big(C_m([\\tau_{\\min},\\tau_{\\max}])\\big)}\n    $$\n    此处，中位数和中位数绝对偏差（MAD）是在搜索频带内的倒谱值上计算的。这些是稳健的统计量，对离群值不敏感。如果 $S_m \\ge 6$，则认为峰是显著的，这是一个用于高置信度检测的严格阈值。\n\n4.  **频域交叉验证**：为了独立证实这一发现，我们使用自相关直接在对数幅度谱中寻找周期性涟波。对数谱的自相关将在与涟波间距 $\\Delta f$ 相对应的延迟处出现一个峰值。对该峰值间距 $\\widehat{\\Delta f}_m$ 的搜索被限制在频率范围 $[1/\\tau_{\\max}, 1/\\tau_{\\min}]$ 内。成功的检测要求倒谱延迟与谱间距之间的一致性，正如理论所预测的（$\\Delta f = 1/\\tau$）：\n    $$\n    \\left|\\frac{1/\\hat{\\tau}_m - \\widehat{\\Delta f}_m}{\\widehat{\\Delta f}_m}\\right| \\le 0.25\n    $$\n\n5.  **最终决策与估计**：数值伪影对整个计算网格是全局性的，并应在不同的物理模式中以相同的延迟 $\\tau$ 体现出来。因此，最终决策基于跨模式一致性。如果三个模式（$m \\in \\{2,3,4\\}$）中至少有两个同时满足倒谱显著性检验和频域一致性检查，则声明存在伪影。此外，从这些被接受的模式中估计出的延迟 $\\{\\hat{\\tau}_m\\}$ 本身必须是一致的，其量化要求为该集合的四分位距（IQR）除以其中位数最多为 $0.3$。如果所有条件都满足，最终估计值 $\\hat{\\tau}$ 是被接受的延迟的中位数。否则，未检测到伪影，报告 $\\hat{\\tau}$ 为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import rfft, irfft, rfftfreq\nfrom scipy.signal.windows import hann\n\ndef run_analysis(rho, tau_true, fs, T, modes, f_modes, A_modes, alpha, phi_m_val, sigma, tau_min, tau_max):\n    \"\"\"\n    Analyzes a set of synthetic signals for a given case to detect echo artifacts.\n    \"\"\"\n    N = int(T * fs)\n    t = np.arange(N) / fs\n    \n    accepted_taus = []\n\n    for i, m in enumerate(modes):\n        # 1. Synthesize signal a_m(t)\n        A_m, f_m = A_modes[i], f_modes[i]\n        \n        # Primary signal\n        primary_signal = A_m * np.exp(-alpha * t) * np.cos(2 * np.pi * f_m * t + phi_m_val)\n        \n        # Echo signal\n        t_shifted = t - tau_true\n        echo_signal = rho * A_m * np.exp(-alpha * t_shifted) * np.cos(2 * np.pi * f_m * t_shifted + phi_m_val + np.pi)\n        echo_signal[t  tau_true] = 0.0 # Apply Heaviside H(t-tau)\n        \n        # Noise\n        noise = np.random.normal(0, sigma, N)\n        \n        a_m = primary_signal + echo_signal + noise\n\n        # 2. Pre-processing\n        window = hann(N, sym=False)\n        a_m_win = a_m * window\n        \n        # 3. Cepstral analysis\n        fft_vals = rfft(a_m_win)\n        mag_spec = np.abs(fft_vals)\n        freqs = rfftfreq(N, 1/fs)\n        \n        epsilon = 1e-12\n        log_mag_spec = np.log(mag_spec + epsilon)\n        \n        # Ensure irfft output has length N for correct quefrency axis mapping\n        cepstrum = irfft(log_mag_spec, n=N)\n        quefrency = t\n\n        # 4. Peak search in cepstrum\n        idx_min = int(tau_min * fs)\n        idx_max = int(tau_max * fs) + 1 # Use +1 for inclusive slicing\n        \n        cepstrum_search = cepstrum[idx_min:idx_max]\n        quefrency_search = quefrency[idx_min:idx_max]\n\n        if len(cepstrum_search) == 0:\n            continue\n\n        peak_idx_local = np.argmax(cepstrum_search)\n        peak_quefrency = quefrency_search[peak_idx_local]\n        peak_val = cepstrum_search[peak_idx_local]\n        tau_hat_m = peak_quefrency\n        \n        # 5. Significance test\n        median_cep = np.median(cepstrum_search)\n        mad_cep = np.median(np.abs(cepstrum_search - median_cep))\n        \n        S_m = (peak_val - median_cep) / mad_cep if mad_cep  0 else np.inf\n        \n        if S_m  6.0:\n            continue\n\n        # 6. Frequency domain validation via autocorrelation\n        df_res = freqs[1] - freqs[0] # Frequency resolution\n        \n        # Search for ACF peak in lag range corresponding to [1/tau_max, 1/tau_min]\n        lag_min_hz = 1 / tau_max\n        lag_max_hz = 1 / tau_min\n        \n        k_min = int(np.ceil(lag_min_hz / df_res))\n        k_max = int(np.floor(lag_max_hz / df_res))\n\n        log_spec_centered = log_mag_spec - np.mean(log_mag_spec)\n        autocorr = np.correlate(log_spec_centered, log_spec_centered, mode='full')\n        autocorr = autocorr[len(log_spec_centered)-1:] # Keep non-negative lags\n\n        if k_min = k_max or k_max  len(autocorr):\n            continue\n\n        autocorr_search = autocorr[k_min:k_max+1]\n        if len(autocorr_search) == 0:\n            continue\n            \n        peak_lag_local = np.argmax(autocorr_search)\n        peak_lag_global = k_min + peak_lag_local\n        delta_f_hat_m = peak_lag_global * df_res\n        \n        if delta_f_hat_m == 0: # Avoid division by zero\n            continue\n        \n        consistency_check = np.abs((1/tau_hat_m - delta_f_hat_m) / delta_f_hat_m)\n        \n        if consistency_check = 0.25:\n            accepted_taus.append(tau_hat_m)\n\n    # 7. Final decision\n    if len(accepted_taus) = 2:\n        median_tau = np.median(accepted_taus)\n        if median_tau == 0: # Avoid division by zero for IQR test\n             return [False, 0.0]\n        q75, q25 = np.percentile(accepted_taus, [75, 25])\n        iqr = q75 - q25\n        \n        if (iqr / median_tau) = 0.3:\n            return [True, median_tau]\n\n    return [False, 0.0]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    np.random.seed(42) # For reproducibility\n\n    # Shared parameters\n    FS = 8192.0  # Hz\n    T = 1.0  # seconds\n    MODES = [2, 3, 4]\n    F_MODES = [250.0, 400.0, 550.0]  # Hz\n    A_MODES = [1.0, 0.8, 0.6]\n    ALPHA = 100.0  # s^-1\n    PHI_M = 0.0\n    SIGMA = 5e-3\n    TAU_MIN = 8e-4  # seconds\n    TAU_MAX = 3e-2  # seconds\n\n    # Test suite\n    test_cases = [\n        {'rho': 0.0, 'tau': 0.01},   # Case 1\n        {'rho': 0.25, 'tau': 0.01},  # Case 2\n        {'rho': 0.15, 'tau': 0.003}, # Case 3\n        {'rho': 0.08, 'tau': 0.001}, # Case 4\n        {'rho': 0.25, 'tau': 0.02}   # Case 5\n    ]\n\n    all_results = []\n    for case in test_cases:\n        rho = case['rho']\n        tau_true = case['tau']\n        \n        result_pair = run_analysis(\n            rho, tau_true, FS, T, MODES, F_MODES, A_MODES, \n            ALPHA, PHI_M, SIGMA, TAU_MIN, TAU_MAX\n        )\n        all_results.append(result_pair)\n\n    # Format and print the final output string\n    final_strings = []\n    for result_pair in all_results:\n        bool_str = str(result_pair[0])\n        float_str = f\"{result_pair[1]:.6f}\"\n        final_strings.append(f\"[{bool_str},{float_str}]\")\n    print(f\"[{','.join(final_strings)}]\")\n\nsolve()\n```", "id": "3465572"}]}