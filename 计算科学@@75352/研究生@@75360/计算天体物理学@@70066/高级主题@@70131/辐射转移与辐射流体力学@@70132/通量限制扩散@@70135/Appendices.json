{"hands_on_practices": [{"introduction": "我们的第一个实践将通量限制扩散（FLD）应用于一个动态的天体物理环境——膨胀的宇宙。这个练习要求在共动坐标系中推导 FLD 方程，这个过程会因宇宙膨胀而引入一个绝热冷却项。通过实现这个模型，你将迈出关键一步，理解如何将辐射转移与背景流体力学或宇宙学耦合起来。[@problem_id:3511262]", "problem": "考虑在一个膨胀、均匀、各向同性的介质中，辐射的通量限制扩散（Flux-Limited Diffusion, FLD）。该介质经历一个哈勃式流动，其物理速度场由 $v_{\\mathrm{phys}}(\\mathbf{r},t)=H(t)\\,\\mathbf{r}$ 给出，其中 $H(t)$ 是哈勃参数，$\\mathbf{r}$ 是物理位置矢量。设 $a(t)$ 是宇宙学尺度因子，满足 $\\dot{a}(t)=H(t)\\,a(t)$ 和初始条件 $a(0)=a_{0}$。我们在一个一维空间中进行计算，该空间在共动坐标 $x$ 上是周期性的，使得物理坐标为 $r(t)=a(t)\\,x$。单位物理体积的辐射能量密度用 $E(x,t)$ 表示，辐射压力为 $P_{\\mathrm{rad}}(x,t)=E(x,t)/3$。FLD 通量定义为 $F_{\\mathrm{phys}}(x,t)=-D(x,t)\\,\\nabla_{\\mathrm{phys}}E(x,t)$，其中 $\\nabla_{\\mathrm{phys}}$ 是物理空间梯度，扩散系数为 $D(x,t)=\\dfrac{c\\,\\lambda(R)}{\\kappa_{R}}$，其中 $c$ 是光速，$\\kappa_{R}$ 是罗斯兰平均不透明度，$\\lambda(R)$ 是一个通量限制器，依赖于无量纲量 $R=\\dfrac{\\lvert\\nabla_{\\mathrm{phys}}E\\rvert}{\\kappa_{R}\\,E}$。使用 Levermore–Pomraning 通量限制器 $\\lambda(R)=\\dfrac{1}{R}\\left(\\coth R-\\dfrac{1}{R}\\right)$，其极限行为为 $\\lambda(0)=\\dfrac{1}{3}$。\n\n从混合参考系中的辐射能量方程出发，并利用物理导数和共动导数之间的变换，推导包含膨胀效应的共动参考系 FLD 方程的形式。特别地，推导当扩散算符用共动坐标表示时的修正形式，以及由膨胀驱动的绝热项。然后，设计一个稳定的、显式的有限差分算法，在一维周期性共动网格上对推导出的方程进行积分。该算法必须确保在没有扩散时，辐射的绝热红移定律 $E\\propto a^{-4}$ 得以保持，并且必须正确地包含扩散算符的共动标度变换。\n\n您的程序必须实现以下模型假设和数值细节：\n- 共动梯度满足 $\\nabla_{\\mathrm{phys}}=\\dfrac{1}{a(t)}\\,\\nabla_{\\mathrm{com}}$，并且扩散算符的共动散度也相应地进行标度变换。\n- 共动参考系中的辐射能量演化方程包含一个与 $H(t)$ 成正比的绝热功项和一个具有适当 $a(t)$ 标度变换的共动扩散算符。\n- 单元交界面上的数值通量应使用基于从共动梯度计算的局部通量限制器得到的可变扩散系数来计算。\n- 在共动坐标中使用周期性边界条件。\n- 使用算符分裂时间积分器，分别对绝热项和扩散项进行演化。\n- 对扩散部分使用前向时间、中心空间（Forward-Time, Centered-Space）离散化，并选择考虑稳定性的时间步长。\n\n在适用情况下，使用厘米-克-秒（cgs）单位制。然而，所要求的输出是如下指定的无量纲浮点数。\n\n测试套件：\n在一个长度为 $L=\\;10^{5}\\,$cm、离散为 $N=\\;128$ 个单元的一维周期性共动域上实现以下三个测试案例。使用 $a_{0}=\\;1$ 和 $c=\\;3.0\\times 10^{10}\\,$cm/s。对于所有案例，均匀初始化共动坐标网格，并使用恒定的 $H(t)=H_{0}$。\n\n1. 案例 A（均匀场，存在扩散但无梯度）：\n   - 参数：$\\kappa_{R}=\\;10.0\\,$cm$^{-1}$，$H_{0}=\\;0.01\\,$s$^{-1}$，最终时间 $t_{\\mathrm{end}}=\\;0.1\\,$s。\n   - 初始条件：$E(x,0)=E_{0}$，其中 $E_{0}=\\;1.0\\,$erg/cm$^{3}$ 为均匀值。\n   - 要求结果：一个浮点数，等于数值空间平均值 $\\langle E(x,t_{\\mathrm{end}})\\rangle$ 与精确绝热值 $E_{0}\\,\\exp(-4\\,H_{0}\\,t_{\\mathrm{end}})$ 之间的相对误差，计算公式为 $\\left\\lvert \\dfrac{\\langle E\\rangle_{\\mathrm{num}}-E_{0}\\,e^{-4H_{0}t_{\\mathrm{end}}}}{E_{0}\\,e^{-4H_{0}t_{\\mathrm{end}}}}\\right\\rvert$。\n\n2. 案例 B（正弦场，光学厚以致扩散可忽略）：\n   - 参数：$\\kappa_{R}=\\;100.0\\,$cm$^{-1}$，$H_{0}=\\;0.02\\,$s$^{-1}$，最终时间 $t_{\\mathrm{end}}=\\;0.1\\,$s。\n   - 初始条件：$E(x,0)=E_{0}\\left[1+0.1\\,\\sin\\left(\\dfrac{2\\pi x}{L}\\right)\\right]$，其中 $E_{0}=\\;1.0\\,$erg/cm$^{3}$。\n   - 要求结果：一个浮点数，等于数值解 $E(x,t_{\\mathrm{end}})$ 与仅考虑绝热的精确解 $E(x,0)\\,\\exp(-4\\,H_{0}\\,t_{\\mathrm{end}})$ 在整个网格上的平均绝对相对误差，计算公式为在所有网格点上对 $\\left\\lvert \\dfrac{E_{\\mathrm{num}}(x_{i},t_{\\mathrm{end}})-E(x_{i},0)\\,e^{-4H_{0}t_{\\mathrm{end}}}}{E(x_{i},0)\\,e^{-4H_{0}t_{\\mathrm{end}}}}\\right\\rvert$ 求平均。\n\n3. 案例 C（正弦场，有限扩散和膨胀；共动不变量守恒）：\n   - 参数：$\\kappa_{R}=\\;1.0\\,$cm$^{-1}$，$H_{0}=\\;0.01\\,$s$^{-1}$，最终时间 $t_{\\mathrm{end}}=\\;0.2\\,$s。\n   - 初始条件：$E(x,0)=E_{0}\\left[1+0.2\\,\\sin\\left(\\dfrac{4\\pi x}{L}\\right)\\right]$，其中 $E_{0}=\\;1.0\\,$erg/cm$^{3}$。\n   - 要求结果：一个浮点数，等于共动不变量 $a(t)^{4}E(x,t)$ 的空间平均值在初始和最终时刻之间的相对偏差，计算公式为 $\\left\\lvert \\dfrac{\\langle a(t_{\\mathrm{end}})^{4}E(x,t_{\\mathrm{end}})\\rangle-\\langle a(0)^{4}E(x,0)\\rangle}{\\langle a(0)^{4}E(x,0)\\rangle}\\right\\rvert$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个案例的结果，格式为逗号分隔的列表，并用方括号括起来（例如，$\\left[\\mathrm{resultA},\\mathrm{resultB},\\mathrm{resultC}\\right]$）。每个条目必须是如上定义的浮点数，不带单位。", "solution": "该问题陈述清晰，具有科学依据，并为获得唯一解提供了足够的信息。这是一个计算天体物理学中的标准问题，我将继续进行推导和实现。\n\n### 第 1 部分：共动参考系通量限制扩散方程的推导\n\n我们从混合参考系中的辐射能量守恒方程开始，其中流体变量在流体的共动参考系中测量，但导数在实验室（欧拉）参考系中计算。对于以物理速度 $\\mathbf{v}_{\\mathrm{phys}}$ 运动的流体，该方程为：\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla_{\\mathrm{phys}} \\cdot (E \\mathbf{v}_{\\mathrm{phys}}) + \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -P_{\\mathrm{rad}} : \\nabla_{\\mathrm{phys}} \\mathbf{v}_{\\mathrm{phys}}\n$$\n其中 $E$ 是辐射能量密度，$\\mathbf{F}_{\\mathrm{phys}}$ 是辐射通量，$P_{\\mathrm{rad}}$ 是辐射压力张量。对于各向同性辐射场，压力是一个标量 $P_{\\mathrm{rad}} = E/3$，压力张量为 $P_{ij} = P_{\\mathrm{rad}} \\delta_{ij}$。右侧的功项简化为 $-P_{\\mathrm{rad}} (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})$。\n\n展开平流项 $\\nabla_{\\mathrm{phys}} \\cdot (E \\mathbf{v}_{\\mathrm{phys}}) = \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E + E (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})$，方程变为：\n$$\n\\frac{\\partial E}{\\partial t} + \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E + E (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}}) + \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -P_{\\mathrm{rad}} (\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}})\n$$\n识别拉格朗日时间导数 $\\frac{DE}{Dt} = \\frac{\\partial E}{\\partial t} + \\mathbf{v}_{\\mathrm{phys}} \\cdot \\nabla_{\\mathrm{phys}} E$，我们可以重新整理方程：\n$$\n\\frac{DE}{Dt} = -(E + P_{\\mathrm{rad}})(\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}}) - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\n问题指定了一个均匀、各向同性的哈勃式流动，$\\mathbf{v}_{\\mathrm{phys}} = H(t) \\mathbf{r}$，其中 $\\mathbf{r}$ 是物理位置矢量。该速度场的散度是 $\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{v}_{\\mathrm{phys}} = 3H(t)$，代表背景三维空间的体积膨胀率。使用相对论状态方程 $P_{\\mathrm{rad}} = E/3$，我们有 $E + P_{\\mathrm{rad}} = 4E/3$。方程变为：\n$$\n\\frac{DE}{Dt} = -\\frac{4}{3}E (3H(t)) - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = -4H(t)E - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\n该方程描述了随宇宙膨胀运动的流体元的能量密度变化。\n\n接下来，我们变换到共动坐标。物理坐标 $\\mathbf{r}$ 通过尺度因子 $a(t)$ 与共动坐标 $\\mathbf{x}$ 相关：$\\mathbf{r} = a(t) \\mathbf{x}$。具有固定共动坐标的点的速度为 $\\dot{\\mathbf{r}} = \\dot{a}(t) \\mathbf{x} = \\frac{\\dot{a}}{a} (a \\mathbf{x}) = H(t) \\mathbf{r} = \\mathbf{v}_{\\mathrm{phys}}$。这意味着跟主流体的拉格朗日导数等同于固定共动坐标下的偏时间导数：$\\frac{D}{Dt} = \\left. \\frac{\\partial}{\\partial t} \\right|_{\\mathbf{x}}$。\n\n用共动参考系时间导数表示的方程是：\n$$\n\\left. \\frac{\\partial E}{\\partial t} \\right|_{\\mathbf{x}} = -4H(t)E - \\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}}\n$$\n右边的第一项 $-4H(t)E$ 是**绝热冷却项**（或红移项），由宇宙膨胀时辐射压力做功产生。在没有源或汇的情况下，该项正确地导致 $E \\propto a^{-4}$ 的标度关系，因为 $\\frac{dE}{E} = -4H dt = -4 \\frac{da}{a}$，积分得到 $E a^4 = \\mathrm{constant}$。\n\n现在，我们变换扩散项。物理通量由 FLD 近似给出：$\\mathbf{F}_{\\mathrm{phys}} = -D \\nabla_{\\mathrm{phys}} E$。物理梯度 $\\nabla_{\\mathrm{phys}}$ 与共动梯度 $\\nabla_{\\mathrm{com}}$ 的关系为 $\\nabla_{\\mathrm{phys}} = \\frac{1}{a(t)}\\nabla_{\\mathrm{com}}$。通量的散度变为：\n$$\n\\nabla_{\\mathrm{phys}} \\cdot \\mathbf{F}_{\\mathrm{phys}} = \\nabla_{\\mathrm{phys}} \\cdot \\left(-D \\nabla_{\\mathrm{phys}} E\\right) = \\frac{1}{a(t)} \\nabla_{\\mathrm{com}} \\cdot \\left(-D \\frac{1}{a(t)} \\nabla_{\\mathrm{com}} E\\right) = -\\frac{1}{a(t)^2} \\nabla_{\\mathrm{com}} \\cdot \\left(D \\nabla_{\\mathrm{com}} E\\right)\n$$\n将此代入能量方程，我们得到最终的一维共动坐标系下的 FLD 方程：\n$$\n\\frac{\\partial E}{\\partial t} = -4H(t)E + \\frac{1}{a(t)^2} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial E}{\\partial x} \\right)\n$$\n这就是所求的方程。扩散系数 $D = \\frac{c \\lambda(R)}{\\kappa_R}$ 依赖于无量纲量 $R = \\frac{|\\nabla_{\\mathrm{phys}} E|}{\\kappa_R E} = \\frac{1}{a(t) \\kappa_R E} \\left|\\frac{\\partial E}{\\partial x}\\right|$。\n\n### 第 2 部分：数值算法设计\n\n我们将使用算符分裂法实现一个稳定的、显式的有限差分格式来求解推导出的偏微分方程。\n\n**1. 算符分裂**\n演化方程 $\\frac{\\partial E}{\\partial t} = \\mathcal{L}_{\\mathrm{ad}}E + \\mathcal{L}_{\\mathrm{diff}}E$ 在每个时间增量 $\\Delta t$ 内被分裂成两个子步骤。\n1.  **绝热步骤：** 求解 $\\frac{\\partial E}{\\partial t} = -4H(t)E$。对于恒定的哈勃参数 $H(t)=H_0$，其精确解为：\n    $$ E^* = E^n e^{-4H_0 \\Delta t} $$\n    其中 $E^n$ 是时间步开始时的能量密度。\n\n2.  **扩散步骤：** 使用前向时间、中心空间（FTCS）格式求解 $\\frac{\\partial E}{\\partial t} = \\frac{1}{a(t)^2} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial E}{\\partial x} \\right)$，以 $E^*$ 作为初始条件。\n    $$ \\frac{E_i^{n+1} - E_i^*}{\\Delta t} = \\frac{1}{a(t^n)^2} \\left[ \\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} \\right] $$\n    其中 $\\Delta x$ 是共动网格间距，$F_{i+1/2}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。\n\n**2. 空间离散化和通量计算**\n网格由 $N$ 个大小为 $\\Delta x = L/N$ 的单元组成。单元交界面 $x_{i+1/2}$ 处的数值通量为：\n$$\nF_{i+1/2} = -D_{i+1/2} \\left( \\frac{E_{i+1}^* - E_i^*}{\\Delta x} \\right)\n$$\n扩散系数 $D_{i+1/2}$ 在单元交界面处计算。这需要在交界面处计算限制器 $\\lambda(R)$，而 $\\lambda(R)$ 又依赖于交界面中心的梯度和能量密度。\n$$\nE_{i+1/2}^* = \\frac{E_{i+1}^* + E_i^*}{2}\n$$\n$$\nR_{i+1/2} = \\frac{1}{a(t^n) \\kappa_R E_{i+1/2}^*} \\left| \\frac{E_{i+1}^* - E_i^*}{\\Delta x} \\right|\n$$\nLevermore–Pomraning 通量限制器为 $\\lambda(R) = \\frac{1}{R}(\\coth R - \\frac{1}{R})$。为避免小 $R$ 时的数值抵消，当 $R  10^{-4}$ 时，我们使用其泰勒展开 $\\lambda(R) \\approx 1/3 - R^2/45$。\n最后，交界面中心的扩散系数为 $D_{i+1/2} = \\frac{c \\lambda(R_{i+1/2})}{\\kappa_R}$。\n单元 $i$ 的扩散更新为：\n$$\nE_i^{n+1} = E_i^* + \\frac{\\Delta t}{a(t^n)^2 (\\Delta x)^2} \\left[ D_{i+1/2}(E_{i+1}^* - E_i^*) - D_{i-1/2}(E_i^* - E_{i-1}^*) \\right]\n$$\n周期性边界条件通过确保索引回绕来处理，例如 $E_N = E_0$ 和 $E_{-1} = E_{N-1}$。\n\n**3. 时间步稳定性**\n对于扩散方程，显式 FTCS 格式的稳定性要求时间步 $\\Delta t$ 满足 CFL 条件。我们方程中的有效扩散率为 $D_{\\text{eff}} = D/a^2$。稳定性条件是：\n$$\n\\Delta t \\le \\frac{(\\Delta x)^2}{2 \\max(D_{\\text{eff}})} = \\frac{a(t)^2 (\\Delta x)^2}{2 \\max(D)}\n$$\n扩散系数的最大值出现在 $R \\to 0$ 时，此时 $\\lambda(0) = 1/3$，所以 $D_{\\max} = \\frac{c}{3\\kappa_R}$。稳定的时间步为：\n$$\n\\Delta t_{\\mathrm{diff}} = \\eta \\frac{3 \\kappa_R a(t)^2 (\\Delta x)^2}{2c}\n$$\n其中 $\\eta \\le 1$ 是一个安全因子（我们使用 $\\eta=0.5$）。总时间步还受限于膨胀时间尺度 $1/H_0$ 的一小部分，并且不能超过最终时间 $t_{\\mathrm{end}}$。\n\n**4. 守恒性**\n空间积分量 $\\int_0^L a(t)^4 E(x,t) \\, dx$ 是守恒的。对时间求导可得 $\\int_0^L a^2 \\frac{\\partial}{\\partial x} (D \\frac{\\partial E}{\\partial x}) \\, dx$。由于周期性边界条件，该积分为零，从而证实了守恒性。我们的有限差分格式是对通量散度的直接离散化，因此将在机器精度范围内数值上保持该量守恒。这在案例 C 中进行了测试。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the flux-limited diffusion problem in an expanding medium\n    for three test cases and prints the results.\n    \"\"\"\n\n    def lambda_lp(R, R_thresh=1e-4):\n        \"\"\"\n        Computes the Levermore-Pomraning flux limiter.\n        Uses a Taylor expansion for small R to avoid numerical instability.\n        \"\"\"\n        # Ensure R is a numpy array\n        R = np.asanyarray(R)\n        \n        # Initialize result array\n        lambda_val = np.zeros_like(R, dtype=float)\n        \n        # Condition for small R\n        small_R_mask = R  R_thresh\n        \n        # Taylor expansion for small R\n        R_small = R[small_R_mask]\n        lambda_val[small_R_mask] = 1.0 / 3.0 - R_small**2 / 45.0\n        \n        # Full expression for large R\n        R_large = R[~small_R_mask]\n        # Use 1/tanh(R) to avoid overflow issues of coth at R=0\n        # which is already guarded by the mask.\n        lambda_val[~small_R_mask] = (1.0 / np.tanh(R_large) - 1.0 / R_large) / R_large\n        \n        return lambda_val\n\n    def run_simulation(params):\n        \"\"\"\n        Runs a single 1D FLD simulation.\n        \n        Args:\n            params (dict): A dictionary containing all model and simulation parameters.\n            \n        Returns:\n            tuple: Final energy density array E, initial energy E0, scale factor a(t_end).\n        \"\"\"\n        # Unpack parameters\n        L = params['L']\n        N = params['N']\n        k_R = params['k_R']\n        H0 = params['H0']\n        t_end = params['t_end']\n        E_initial_func = params['E_initial_func']\n        a0 = params['a0']\n        c = params['c']\n        \n        # Grid setup\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        # Initial conditions\n        E = E_initial_func(x, L) \n        E_initial = E.copy()\n        \n        t = 0.0\n        a = a0\n        \n        # CFL safety factor\n        cfl_safety_factor = 0.5\n        \n        while t  t_end:\n            # Update scale factor for the start of the step\n            a = a0 * np.exp(H0 * t)\n            \n            # Time step calculation\n            # Diffusion timestep constraint\n            dt_diff = cfl_safety_factor * (3.0 * k_R * a**2 * dx**2) / (2.0 * c)\n            # Expansion timestep constraint\n            dt_exp = 0.01 / H0 if H0 > 0 else t_end\n            \n            dt = min(dt_diff, dt_exp)\n            if t + dt > t_end:\n                dt = t_end - t\n            \n            # --- Operator Splitting ---\n\n            # 1. Adiabatic step (analytically solved)\n            if H0 > 0:\n                E_star = E * np.exp(-4.0 * H0 * dt)\n            else:\n                E_star = E.copy()\n\n            # 2. Diffusion step (FTCS)\n            # Calculate face-centered diffusion coefficients\n            E_plus = np.roll(E_star, -1)\n            E_minus = np.roll(E_star, 1)\n\n            # Face-centered energy and gradient\n            E_face = 0.5 * (E_star + E_plus)\n            # Add a small number to prevent division by zero for uniform fields\n            E_face[E_face == 0] = 1e-99\n            \n            grad_com_E_face = (E_plus - E_star) / dx\n\n            # Dimensionless parameter R at faces\n            R_face = np.abs(grad_com_E_face) / (a * k_R * E_face)\n            \n            # Limiter and diffusion coefficient at forward faces (i+1/2)\n            lambda_face_fwd = lambda_lp(R_face)\n            D_face_fwd = c * lambda_face_fwd / k_R\n            \n            # Diffusion coefficient at backward faces (i-1/2) by rolling\n            D_face_bwd = np.roll(D_face_fwd, 1)\n\n            # Fluxes at forward and backward faces\n            F_fwd = -D_face_fwd * (E_plus - E_star) / dx\n            F_bwd = -D_face_bwd * (E_star - E_minus) / dx\n            \n            # Update energy density using flux divergence\n            E = E_star - (dt / (a**2 * dx)) * (F_fwd - F_bwd)\n            \n            # Advance time\n            t += dt\n\n        a_final = a0 * np.exp(H0 * t_end)\n        return E, E_initial, a_final\n\n    # --- Global and Test Case Parameters ---\n    L_domain = 1.0e5   # cm\n    N_cells = 128\n    a0_val = 1.0\n    c_light = 3.0e10   # cm/s\n    E0_val = 1.0       # erg/cm^3\n\n    test_cases = [\n        { # Case A\n            'k_R': 10.0, 'H0': 0.01, 't_end': 0.1,\n            'E_initial_func': lambda x, L: np.full_like(x, E0_val)\n        },\n        { # Case B\n            'k_R': 100.0, 'H0': 0.02, 't_end': 0.1,\n            'E_initial_func': lambda x, L: E0_val * (1.0 + 0.1 * np.sin(2.0 * np.pi * x / L))\n        },\n        { # Case C\n            'k_R': 1.0, 'H0': 0.01, 't_end': 0.2,\n            'E_initial_func': lambda x, L: E0_val * (1.0 + 0.2 * np.sin(4.0 * np.pi * x / L))\n        }\n    ]\n    \n    results = []\n    \n    # --- Run simulations and compute results ---\n    \n    # Case A\n    params_A = {**test_cases[0], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_A, _, _ = run_simulation(params_A)\n    E_avg_num = np.mean(E_final_A)\n    E_exact_A = E0_val * np.exp(-4.0 * params_A['H0'] * params_A['t_end'])\n    rel_error_A = np.abs((E_avg_num - E_exact_A) / E_exact_A)\n    results.append(rel_error_A)\n    \n    # Case B\n    params_B = {**test_cases[1], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_B, E_initial_B, _ = run_simulation(params_B)\n    E_exact_B = E_initial_B * np.exp(-4.0 * params_B['H0'] * params_B['t_end'])\n    mean_abs_rel_error_B = np.mean(np.abs((E_final_B - E_exact_B) / E_exact_B))\n    results.append(mean_abs_rel_error_B)\n    \n    # Case C\n    params_C = {**test_cases[2], 'L': L_domain, 'N': N_cells, 'a0': a0_val, 'c': c_light}\n    E_final_C, E_initial_C, a_final_C = run_simulation(params_C)\n    invariant_initial = np.mean(a0_val**4 * E_initial_C)\n    invariant_final = np.mean(a_final_C**4 * E_final_C)\n    rel_dev_C = np.abs((invariant_final - invariant_initial) / invariant_initial)\n    results.append(rel_dev_C)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3511262"}, {"introduction": "在基础求解器之上，一个关键挑战是确保解在物理上是合理的，特别是能量密度 $E$ 必须保持非负。本实践将指导你推导并实现一个保证正性的通量限制器，这是创建稳健且稳定的辐射转移代码的一项重要技术，尤其是在处理大时间步长或高对比度不透明度时。[@problem_id:3511282]", "problem": "你需要推导并实现一个一维显式通量限制扩散 (Flux-Limited Diffusion, FLD) 求解器，用于求解灰色辐射能量密度 $E$。该求解器需通过使用局部波速和局部单元含量界限来限制界面通量，从而保证解的非负性。所有物理量均为无量纲。\n\n出发点和定义：\n- 在扩散近似下，灰色辐射能量方程为\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0,\n$$\n其中扩散通量为\n$$\n\\mathbf{F} = - D \\nabla E,\n$$\n$D$ 是扩散系数。在通量限制扩散闭合关系中，\n$$\nD = \\frac{c \\, \\lambda(R)}{\\chi},\n$$\n其中 $c$ 是（无量纲）光速，$\\chi$ 是总输运不透明度，$\\lambda(R)$ 是一个通量限制器。类瑞利数比值 $R$ 为\n$$\nR = \\frac{\\lvert \\nabla E \\rvert}{\\chi \\, E}。\n$$\n- 使用 Levermore-Pomraning 通量限制器\n$$\n\\lambda(R) = \\frac{1}{R}\\left(\\coth R - \\frac{1}{R}\\right),\n$$\n其极限情况为：当 $R \\to 0$ 时 $\\lambda \\to 1/3$，当 $R \\to \\infty$ 时 $\\lambda \\to 1/R$。\n- 总不透明度由下式给出\n$$\n\\chi = \\rho \\, \\kappa_R(\\rho, T),\n$$\n采用 Rosseland 平均不透明度模型\n$$\n\\kappa_R(\\rho, T) = \\kappa_0 \\, \\rho^{a} \\, T^{b},\n$$\n其中 $\\rho$ 是质量密度，$T$ 是温度，通过灰色平衡由辐射能量定义\n$$\nT = \\left(\\frac{E}{a_r}\\right)^{1/4},\n$$\n其中 $a_r$ 是辐射常数。你必须采用 $a_r = 1$ 和 $c = 1$ 以保持在无量纲单位制中。\n- 使用包含 $N$ 个有限体积单元的均匀网格，单元宽度为 $\\Delta x = L/N$，并采用零通量（诺伊曼）边界条件。\n\n半离散有限体积更新：\n- 对于单元索引 $i$，显式更新公式为\n$$\nE_i^{n+1} = E_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是在界面 $i+\\tfrac{1}{2}$ 处与 $F = -D \\nabla E$ 一致的数值通量。\n\n保正限制器目标：\n- 从第一性原理出发，设计一个基于界面的限制器，以保证对所有 $i$ 和 $n$ 都有 $E_i^{n+1} \\ge 0$，而无需 $\\Delta t$ 满足严格的抛物型稳定性约束。你的限制器必须：\n  1. 强制施加一个离散的能量含量界限，以防止单个界面从其相邻单元中移走的辐射能量在一个时间步内导致该单元变为负值。\n  2. 强制施加一个基于物理的速度界限，使用根据扩散系数和网格尺度构建的特征局部波速，并受自由流极限的限制。\n- 你的限制器必须这样构建，使得在每个界面 $i+\\tfrac{1}{2}$ 处，受限通量的大小不超过以下两者：\n  - 一个与相邻单元能量和 $\\Delta x/\\Delta t$ 成正比的能量含量界限，以及\n  - 一个与特征速度和相邻单元能量尺度成正比的速度界限。\n- 清晰地陈述你使用的特征速度，以及它是如何从基本扩散模型及其自由流极限推导出来的。\n\n算法要求：\n- 实现一个一维显式更新，包含：\n  - 单元中心的 $E_i$。\n  - 根据通量限制器 $\\lambda(R)$ 和界面插值的不透明度 $\\chi_{i+\\frac{1}{2}}$ 计算的界面中心的 $D_{i+\\frac{1}{2}}$。\n  - 通过中心差分计算的界面中心梯度。\n  - 使用界面中心梯度和界面中心能量尺度计算的 $R$。\n  - 零通量边界，即 $F_{-\\frac{1}{2}} = 0$ 和 $F_{N-\\frac{1}{2}} = 0$。\n- 在同一个程序中实现两个求解器：\n  - 一个不带保正限制器（但带有通量限制器 $\\lambda$）的基准 FLD 显式求解器。\n  - 你推导的保正限制求解器。\n- 温度必须由 $T = (E/a_r)^{1/4}$（其中 $a_r = 1$）计算得出。为了在基准求解器中数值上检测非物理温度，如果任何单元的 $E0$，则将最低温度报告为带符号的四次方根 $T_{\\min} = -(\\lvert E_{\\min}\\rvert)^{1/4}$，以便负值表示违规。在数值通量计算中所有其他对 $T$ 的使用，应通过使用一个微小的 $\\varepsilon$ 将 $E$ 替换为 $\\max(E, \\varepsilon)$ 来正则化计算，以避免除以零，同时不掩盖所报告的最低温度的符号。\n\n测试套件：\n- 使用三个指定的测试。在所有测试中，使用 $L = 1$，$a_r = 1$，$c = 1$，$N = 256$。令 $\\Delta x = L/N$。时间步长 $\\Delta t$ 必须选择为\n$$\n\\Delta t = \\beta \\, \\frac{\\Delta x^2}{2 \\, \\max D^{(0)}},\n$$\n其中 $\\max D^{(0)}$ 是从初始场计算出的最大初始界面中心扩散系数，$\\beta$ 是为每个测试指定的因子，用以故意违反标准的抛物型稳定性极限。对于每个测试，积分固定的步数 $N_{\\text{steps}}$。\n\n- 测试 1（中度非均匀不透明度）：\n  - $\\kappa_0 = 1$, $a = 1$, $b = -3.5$。\n  - $\\rho(x) = 1 + 0.5 \\sin(4 \\pi x)$。\n  - $E(x,0) = 1 + \\exp\\left(-\\frac{(x-0.5)^2}{0.05^2}\\right)$。\n  - $\\beta = 2$, $N_{\\text{steps}} = 50$。\n\n- 测试 2（具有尖峰的高度非均匀不透明度）：\n  - $\\kappa_0 = 5$, $a = 1$, $b = -3.5$。\n  - $\\rho(x) = 0.1 + 10 \\exp\\left(-\\frac{(x-0.25)^2}{0.02^2}\\right) + 30 \\exp\\left(-\\frac{(x-0.75)^2}{0.01^2}\\right)$。\n  - $E(x,0) = 0.5 + 2 \\exp\\left(-\\frac{(x-0.5)^2}{0.03^2}\\right)$。\n  - $\\beta = 5$, $N_{\\text{steps}} = 30$。\n\n- 测试 3（用于探测自由流极限的近真空区域）：\n  - $\\kappa_0 = 1$, $a = 1$, $b = -3.5$。\n  - 对于所有 $x$，$\\rho(x) = 1 + 0 \\times x$，但在中心区域 $\\lvert x - 0.5 \\rvert  0.05$ 处有一个凹陷 $\\rho(x) = 10^{-4}$。\n  - $E(x,0) = 1 + 0.8 \\tanh\\left(\\frac{0.5 - x}{0.02}\\right)$。\n  - $\\beta = 10$, $N_{\\text{steps}} = 20$。\n\n输出要求：\n- 对于每个测试，在完成所有时间步后，计算四个标量：\n  - $m_E^{\\text{lim}}$：保正限制求解器在所有单元上的 $E$ 的最小值。\n  - $m_E^{\\text{base}}$：基准求解器在所有单元上的 $E$ 的最小值。\n  - $m_T^{\\text{lim}}$：限制求解器在所有单元上的 $T$ 的最小值。\n  - $m_T^{\\text{base}}$：基准求解器在所有单元上的 $T$ 的最小值，按上述描述，在任何单元中 $E0$ 时使用带符号的四次方根计算。\n- 你的程序应生成单行输出，其中包含三个测试的 12 个结果，以逗号分隔的列表形式包含在方括号中，顺序如下\n$$\n\\big[m_E^{\\text{lim}}(1),\\, m_E^{\\text{base}}(1),\\, m_T^{\\text{lim}}(1),\\, m_T^{\\text{base}}(1),\\, m_E^{\\text{lim}}(2),\\, m_E^{\\text{base}}(2),\\, m_T^{\\text{lim}}(2),\\, m_T^{\\text{base}}(2),\\, m_E^{\\text{lim}}(3),\\, m_E^{\\text{base}}(3),\\, m_T^{\\text{lim}}(3),\\, m_T^{\\text{base}}(3)\\big].\n$$\n所有输出均为无量纲实数。\n\n你的任务是：\n- 从基本的 FLD 模型推导出一个保正通量上限，该上限由离散的能量含量界限和恢复抛物型及自由流特征速度的局部波速界限构成，并解释为什么它在显式更新中能保证 $E \\ge 0$。\n- 完全按照描述实现基准 FLD 求解器和你的保正限制求解器，并将它们应用于上述测试。\n- 确保零通量边界条件和指定的无量纲常数。", "solution": "该问题要求为一维灰色通量限制扩散 (FLD) 方程推导并实现一个保正的显式数值格式。该格式的保正性必须通过基于局部能量含量和特征波速来限制界面通量来保证，即使在时间步长违反标准抛物型稳定性条件时也是如此。\n\n辐射能量密度 $E$ 的控制方程由守恒律给出：\n$$\n\\frac{\\partial E}{\\partial t} + \\nabla \\cdot \\mathbf{F} = 0\n$$\n在通量限制扩散近似中，通量 $\\mathbf{F}$ 建模为：\n$$\n\\mathbf{F} = -D \\nabla E\n$$\n其中扩散系数 $D$ 由下式给出：\n$$\nD = \\frac{c \\, \\lambda(R)}{\\chi}\n$$\n这里，$c$ 是光速，$\\chi$ 是不透明度，$\\lambda(R)$ 是 Levermore-Pomraning 通量限制器，它依赖于无量纲比值 $R = |\\nabla E| / (\\chi E)$。\n\n在单元宽度为 $\\Delta x$ 的均匀网格上的半离散有限体积格式给出了单元 $i$ 中单元平均能量 $E_i$ 的显式更新公式：\n$$\nE_i^{n+1} = E_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\n其中 $F_{i+\\frac{1}{2}}^n$ 是在时间步 $n$ 时单元 $i$ 和 $i+1$ 之间界面上的数值通量。为确保对于任何初始状态 $E_i^n \\ge 0$，更新后的能量 $E_i^{n+1}$ 保持非负，我们必须对通量进行约束。\n\n保正条件是 $E_i^{n+1} \\ge 0$，这意味着：\n$$\nE_i^n \\ge \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\n项 $F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n$ 代表从单元 $i$ 的净流出量。如果 $E_i$ 是一个局部最大值 ($E_{i-1}  E_i$ 且 $E_i > E_{i+1}$)，那么 $F_{i+\\frac{1}{2}} > 0$ 且 $F_{i-\\frac{1}{2}}  0$，导致两个界面都有流出。从单元 $i$ 的总流出量为 $\\max(0, F_{i+\\frac{1}{2}}) - \\min(0, F_{i-\\frac{1}{2}})$。为了保证正性，在 $\\Delta t$ 内从单元 $i$ 移走的总能量不能超过初始能量 $E_i^n$。\n一种确保这一点的稳健、局部、基于界面的方法是，将单元能量含量的一半分配给其两个界面中的每一个。也就是说，通过界面 $i+\\frac{1}{2}$ 从单元 $i$ 的流出量不应消耗超过 $E_i^n/2$，对于界面 $i-\\frac{1}{2}$ 也是如此。\n\n这个逻辑引出了界面通量大小的 **能量含量界限** 的推导。考虑单元 $i$ 和 $i+1$ 之间的通量 $F_{i+\\frac{1}{2}}$。流动的方向是从较高的 $E$ 到较低的 $E$。让“迎风”单元是具有较高能量的那个单元，通量源于此。为防止从界面 $i+\\frac{1}{2}$ 的流出导致单元 $i$ 或 $i+1$ 变为负值，我们限制其大小。如果我们将迎风单元含量的一半分配给这个界面，则允许的最大通量大小为：\n$$\n|F_{i+\\frac{1}{2}}| \\le \\frac{E_{\\text{upwind}}^n}{2} \\frac{\\Delta x}{\\Delta t}\n$$\n其中，如果 $E_i^n > E_{i+1}^n$，则 $E_{\\text{upwind}}^n = E_i^n$；如果 $E_{i+1}^n > E_i^n$，则 $E_{\\text{upwind}}^n = E_{i+1}^n$。我们来验证这一点。在单元 $i$ 的最坏情况下（两个界面都有流出），总流出量受限于：\n$$\n\\frac{\\Delta t}{\\Delta x} \\left( |F_{i+\\frac{1}{2}}| + |F_{i-\\frac{1}{2}}| \\right) \\le \\frac{\\Delta t}{\\Delta x} \\left( \\frac{E_i^n \\Delta x}{2 \\Delta t} + \\frac{E_i^n \\Delta x}{2 \\Delta t} \\right) = E_i^n\n$$\n因此，$E_i^{n+1} = E_i^n - (\\text{流出量}) + (\\text{流入量}) \\ge E_i^n - E_i^n + 0 = 0$。这保证了正性。\n\n接下来，我们推导 **速度界限**。FLD 模型必须与辐射的物理速度极限 $c$ 一致。通量大小 $|F|$ 不能超过 $c E$。在自由流极限下 ($R \\to \\infty$)，Levermore-Pomraning 限制器确保 $|F| \\to cE$。此外，在数值扩散格式中，信息以与扩散系数 $D$ 和网格尺度 $\\Delta x$ 相关的特征速度传播，即 $v_{\\text{diff}} \\sim D/\\Delta x$。有效的通量速度不能超过这两者中的任何一个。我们在界面上定义一个特征局部波速：\n$$\nv_{\\text{char}, i+\\frac{1}{2}} = \\min\\left(\\frac{D_{i+\\frac{1}{2}}}{\\Delta x}, c\\right)\n$$\n然后，通量大小受此速度乘以迎风单元能量密度的限制：\n$$\n|F_{i+\\frac{1}{2}}| \\le v_{\\text{char}, i+\\frac{1}{2}} E_{\\text{upwind}}^n\n$$\n\n最终的保正限制器按规定组合了这两个界限。受限通量的大小 $|F^{\\text{lim}}_{i+\\frac{1}{2}}|$，不得超过原始无限制通量的大小 $|F^{\\text{unlim}}_{i+\\frac{1}{2}}|$，也不得超过这两个上限。\n令无限制通量为 $F^{\\text{unlim}}_{i+\\frac{1}{2}} = -D_{i+\\frac{1}{2}} \\frac{E_{i+1}^n - E_i^n}{\\Delta x}$。\n通量大小的上限是：\n$$\nF_{\\text{cap}, i+\\frac{1}{2}} = \\min \\left( \\frac{E_{\\text{upwind}}^n \\Delta x}{2 \\Delta t}, v_{\\text{char}, i+\\frac{1}{2}} E_{\\text{upwind}}^n \\right)\n$$\n其中 $E_{\\text{upwind}}^n = \\max(E_i^n, E_{i+1}^n)$。\n最终的受限通量是通过限制无限制通量的大小来构建的：\n$$\nF^{\\text{lim}}_{i+\\frac{1}{2}} = \\text{sign}\\left(F^{\\text{unlim}}_{i+\\frac{1}{2}}\\right) \\min\\left( \\left|F^{\\text{unlim}}_{i+\\frac{1}{2}}\\right|, F_{\\text{cap}, i+\\frac{1}{2}} \\right)\n$$\n这种公式确保了通量是守恒的，并尊重物理约束，从而保证 $E^{n+1} \\ge 0$。\n\n实现将按以下方式进行。对于每个测试用例，我们运行两个模拟：一个使用无限制通量 $F^{\\text{unlim}}$ 的基准求解器，以及一个使用 $F^{\\text{lim}}$ 的限制求解器。\n所有界面中心的量都是使用相邻单元中心值的算术平均值来计算的。具体对于不透明度 $\\chi = \\rho \\kappa_R = \\kappa_0 \\rho^{a+1} T^b$，我们计算 $T_i = (\\max(E_i, \\varepsilon))^{1/4}$，然后将 $\\rho$ 和 $T$ 平均到界面上以计算 $\\chi_{i+\\frac{1}{2}}$。瑞利数 $R$ 使用界面中心梯度和界面中心能量尺度，$E_{i+\\frac{1}{2}} = (E_i + E_{i+1})/2$。在数值计算通量限制器 $\\lambda(R)$ 时，对 $R=0$ 附近要特别小心，使用渐近极限 $\\lambda(R) \\approx 1/3$ 来避免数值抵消误差。时间步长 $\\Delta t$ 由初始状态的最大扩散系数和一个给定的因子 $\\beta$ 决定，该因子被特意选择以违反简单显式抛物型格式的 CFL 条件，从而突显通量限制器的必要性和有效性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a 1D explicit positivity-preserving\n    Flux-Limited Diffusion (FLD) solver.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"kappa0\": 1.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: 1.0 + 0.5 * np.sin(4 * np.pi * x),\n            \"E_func\": lambda x: 1.0 + np.exp(-((x - 0.5)**2) / 0.05**2),\n            \"beta\": 2.0, \"N_steps\": 50\n        },\n        {\n            \"id\": 2,\n            \"kappa0\": 5.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: 0.1 + 10 * np.exp(-((x - 0.25)**2) / 0.02**2) + 30 * np.exp(-((x - 0.75)**2) / 0.01**2),\n            \"E_func\": lambda x: 0.5 + 2 * np.exp(-((x - 0.5)**2) / 0.03**2),\n            \"beta\": 5.0, \"N_steps\": 30\n        },\n        {\n            \"id\": 3,\n            \"kappa0\": 1.0, \"a\": 1.0, \"b\": -3.5,\n            \"rho_func\": lambda x: np.where(np.abs(x - 0.5)  0.05, 1e-4, 1.0),\n            \"E_func\": lambda x: 1.0 + 0.8 * np.tanh((0.5 - x) / 0.02),\n            \"beta\": 10.0, \"N_steps\": 20\n        }\n    ]\n\n    all_results = []\n    \n    # Global parameters\n    L = 1.0\n    N = 256\n    ar = 1.0\n    c_light = 1.0\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    EPSILON = 1e-100\n\n    def compute_lambda(R):\n        \"\"\"Computes the Levermore-Pomraning flux limiter.\"\"\"\n        R_small_tol = 1e-6\n        lambda_val = np.zeros_like(R)\n        \n        mask_small = R  R_small_tol\n        mask_large = ~mask_small\n\n        R_large = R[mask_large]\n        lambda_val[mask_large] = (1.0 / R_large) * (1.0 / np.tanh(R_large) - 1.0 / R_large)\n        \n        # Taylor expansion for small R: 1/3 - R^2/45 + ...\n        # For simplicity and as per problem, we can use the limit directly.\n        lambda_val[mask_small] = 1.0 / 3.0\n        \n        return lambda_val\n\n    def get_face_properties(E, rho, k0, a, b):\n        \"\"\"Computes all necessary face-centered quantities.\"\"\"\n        # Cell-centered temperatures, regularized for flux computation\n        T_cell = np.power(np.maximum(E, EPSILON), 0.25)\n        \n        # Arithmetic mean for face-centered quantities\n        E_face = (E[:-1] + E[1:]) / 2.0\n        rho_face = (rho[:-1] + rho[1:]) / 2.0\n        T_face = (T_cell[:-1] + T_cell[1:]) / 2.0\n\n        # Face-centered opacity and gradient\n        chi_face = k0 * np.power(rho_face, a + 1.0) * np.power(T_face, b)\n        grad_E_face = (E[1:] - E[:-1]) / dx\n\n        # Rayleigh number R\n        R_face = np.abs(grad_E_face) / (chi_face * E_face + EPSILON)\n\n        # Flux-limiter lambda and diffusion coefficient D\n        lambda_face = compute_lambda(R_face)\n        D_face = c_light * lambda_face / (chi_face + EPSILON)\n        \n        return D_face, grad_E_face\n\n    def run_simulation(E_init, rho, params, limited):\n        \"\"\"Runs a single simulation (baseline or limited).\"\"\"\n        k0, a, b = params[\"kappa0\"], params[\"a\"], params[\"b\"]\n        N_steps, beta = params[\"N_steps\"], params[\"beta\"]\n\n        # Calculate timestep dt based on initial conditions\n        D0_face, _ = get_face_properties(E_init, rho, k0, a, b)\n        max_D0 = np.max(D0_face) if D0_face.size > 0 else 1.0\n        dt = beta * dx**2 / (2.0 * max_D0)\n\n        E = E_init.copy()\n\n        for _ in range(N_steps):\n            D_face, grad_E_face = get_face_properties(E, rho, k0, a, b)\n            \n            # 1. Compute unlimited physical flux\n            F_unlimited = -D_face * grad_E_face\n            \n            F_final = F_unlimited\n            if limited:\n                # 2. Compute positivity-preserving flux caps\n                E_upwind = np.where(E[:-1] > E[1:], E[:-1], E[1:])\n                \n                # Energy content bound\n                F_cap_content = E_upwind * dx / (2.0 * dt)\n                \n                # Characteristic speed and speed bound\n                v_char = np.minimum(D_face / dx, c_light)\n                F_cap_speed = v_char * E_upwind\n                \n                # Combined cap\n                F_cap = np.minimum(F_cap_content, F_cap_speed)\n                \n                # 3. Apply the limiter\n                F_limited = np.sign(F_unlimited) * np.minimum(np.abs(F_unlimited), F_cap)\n                F_final = F_limited\n\n            # 4. Update energy using final fluxes\n            # Flux array with boundary conditions F=0 on both ends\n            F_bnd = np.zeros(N + 1)\n            F_bnd[1:-1] = F_final\n            \n            E -= (dt / dx) * (F_bnd[1:] - F_bnd[:-1])\n\n        # Post-process to find minimums\n        min_E = np.min(E)\n        if not limited and min_E  0:\n            min_T = -np.power(np.abs(min_E), 0.25)\n        else:\n            # For the limited solver, min_E should be >= 0\n            # For the baseline, if min_E happens to be positive\n            min_T = np.power(max(min_E, 0), 0.25)\n            \n        return min_E, min_T\n\n    for case in test_cases:\n        rho_init = case[\"rho_func\"](x)\n        E_init = case[\"E_func\"](x)\n        \n        # Run baseline solver\n        m_E_base, m_T_base = run_simulation(E_init, rho_init, case, limited=False)\n        \n        # Run limited solver\n        m_E_lim, m_T_lim = run_simulation(E_init, rho_init, case, limited=True)\n        \n        all_results.extend([m_E_lim, m_E_base, m_T_lim, m_T_base])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3511282"}, {"introduction": "通量限制器 $\\lambda(R)$ 函数的选择不仅是为了满足物理极限，它还具有显著的数值影响。本练习侧重于限制器数学形式的实际影响，通过比较经典的 Levermore-Pomraning 限制器与一种替代形式，分析它们各自如何解析尖锐的锋面，以及它们的数值扩散如何随网格分辨率而变化。[@problem_id:3511263]", "problem": "考虑在静态、均匀介质中，由通量限制扩散 (FLD) 关系封闭的一维灰色辐射输运的扩散近似。令 $x \\in [0,1]$ 为无量纲空间坐标，$t \\ge 0$ 为无量纲时间。未知量是无量纲辐射能量密度 $E(x,t) \\ge 0$。基本依据包括：(i) 扩散近似下的辐射能量守恒，它产生一个抛物型守恒律；(ii) 带有通量限制器的辐射通量本构关系。具体来说，假设如下：\n\n- 守恒律为\n$$\n\\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(E,\\partial_x E)\\, \\frac{\\partial E}{\\partial x} \\right),\n$$\n其中扩散系数 $D$ 通过一个通量限制器依赖于 $E$ 及其梯度。\n\n- 定义通量限制扩散系数的本构关系是\n$$\nD(E,\\partial_x E) = \\lambda(R),\n\\quad\nR = \\frac{|\\partial_x E|}{\\max(E,\\epsilon)},\n$$\n其中 $\\epsilon  0$ 是一个小的正则化常数，用以避免除以零。通量限制器 $\\lambda(R)$ 必须满足扩散极限约束（当 $R \\to 0$ 时 $\\lambda(R) \\to 1/3$）和自由流动约束（当 $R \\to \\infty$ 时 $\\lambda(R) \\to 1/R$）。\n\n- 将比较两种限制器的选择：\n  1. Levermore–Pomraning 限制器\n  $$\n  \\lambda_{\\mathrm{LP}}(R) = \\frac{1}{R}\\left(\\coth R - \\frac{1}{R}\\right),\n  $$\n  其中 $\\coth R = \\frac{\\cosh R}{\\sinh R}$，并且为了数值稳健性，可以使用小 $R$ 极限展开式，\n  $$\n  \\lambda_{\\mathrm{LP}}(R) \\approx \\frac{1}{3} - \\frac{R^2}{45} \\quad \\text{as } R \\to 0.\n  $$\n  2. 一种为减少阶梯效应同时保持渐近极限而提出的修正限制器，\n  $$\n  \\lambda^\\ast(R) = \\frac{1}{\\sqrt{9 + R^2}},\n  $$\n  满足 $\\lambda^\\ast(0)=1/3$ 并且当 $R \\to \\infty$ 时 $\\lambda^\\ast(R) \\sim 1/R$。\n\n任务是通过测量两种限制器 $\\lambda_{\\mathrm{LP}}(R)$ 和 $\\lambda^\\ast(R)$ 的波前厚度与网格分辨率 $N$ 的关系，来检验由限制器引起的非线性所引入的数值扩散。在具有 $N$ 个单元的均匀网格上，使用零通量边界条件，实现一个守恒的显式有限体积格式。设单元中心的未知量为 $E_i(t)$（$i=0,\\dots,N-1$），网格间距为 $\\Delta x = 1/N$。使用两点梯度和在面上求值的限制器所定义的面心扩散系数来近似面心通量。为保证稳定性，选择一个满足基于最大可能扩散系数的标准扩散限制的时间步长 $\\Delta t$。使用一个恒定的最终时间 $t_{\\mathrm{final}}$，并从下面指定的初始条件开始积分。\n\n初始条件和参数：\n- 初始数据是一个黎曼型波前：\n$$\nE(x,0) = \\begin{cases}\nE_{\\mathrm{L}},  x  1/2, \\\\\nE_{\\mathrm{R}},  x \\ge 1/2,\n\\end{cases}\n$$\n其中 $E_{\\mathrm{L}} = 1$ 且 $E_{\\mathrm{R}} = 10^{-3}$。\n- 在 $x=0$ 和 $x=1$ 处的边界条件为零通量（齐次诺伊曼）。\n- 使用 $t_{\\mathrm{final}} = 2 \\times 10^{-2}$ 和 $\\epsilon = 10^{-12}$。\n\n将给定时间的波前厚度 $w$ 定义为 $E$ 达到阈值\n$$\nE_{0.1} = E_{\\mathrm{R}} + 0.1\\,(E_{\\mathrm{L}} - E_{\\mathrm{R}}), \\quad\nE_{0.9} = E_{\\mathrm{R}} + 0.9\\,(E_{\\mathrm{L}} - E_{\\mathrm{R}}),\n$$\n的两点之间的空间距离，使用相邻单元中心之间的线性插值来定位位置 $x_{0.1}$ 和 $x_{0.9}$，使得 $E(x_{0.1},t_{\\mathrm{final}}) = E_{0.1}$ 和 $E(x_{0.9},t_{\\mathrm{final}}) = E_{0.9}$。于是 $w = |x_{0.9} - x_{0.1}|$。\n\n你的程序必须：\n- 实现显式有限体积更新\n$$\nE_i^{n+1} = E_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n其中数值通量为\n$$\nF_{i+\\frac{1}{2}}^n = - D_{i+\\frac{1}{2}}^n \\left(\\frac{E_{i+1}^n - E_i^n}{\\Delta x}\\right),\n\\quad\nD_{i+\\frac{1}{2}}^n = \\lambda\\!\\left(R_{i+\\frac{1}{2}}^n\\right),\n\\quad\nR_{i+\\frac{1}{2}}^n = \\frac{\\left|E_{i+1}^n - E_i^n\\right|/\\Delta x}{\\max\\!\\big(\\tfrac{1}{2}(E_{i+1}^n + E_i^n),\\,\\epsilon\\big)}.\n$$\n通过设置 $F_{-1/2}^n = 0$ 和 $F_{N-1/2}^n = 0$ 来强制执行零通量边界。\n\n- 使用满足以下条件的时间步长\n$$\n\\Delta t \\le \\frac{\\Delta x^2}{2\\,D_{\\max}},\n$$\n其中 $D_{\\max} = 1/3$，并应用 $0.9$ 的安全因子。\n\n- 对于每种限制器选择 $\\lambda \\in \\{\\lambda_{\\mathrm{LP}}, \\lambda^\\ast\\}$ 和网格分辨率 $N \\in \\{32, 64, 128, 256\\}$，计算在 $t_{\\mathrm{final}}$ 时的波前厚度 $w(N,\\lambda)$。\n\n- 对于每个限制器，通过对四个 $N$ 值的数据 $\\{\\log \\Delta x, \\log w\\}$（其中 $\\Delta x = 1/N$）进行线性拟合，来估计标度指数 $s(\\lambda)$。也就是说，找到 $s(\\lambda)$ 使得\n$$\n\\log w \\approx s(\\lambda)\\, \\log \\Delta x + b(\\lambda).\n$$\n\n- 为了在 $R=0$ 附近的数值稳健性，当 $R  10^{-6}$ 时，使用其小 $R$ 展开式来计算 $\\lambda_{\\mathrm{LP}}(R)$。\n\n测试套件和要求输出：\n- 测试套件包括针对两种限制器在指定的 $N$ 值下进行的八次波前厚度计算，以及两个拟合得到的标度指数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\big[ w(32,\\lambda_{\\mathrm{LP}}),\\, w(64,\\lambda_{\\mathrm{LP}}),\\, w(128,\\lambda_{\\mathrm{LP}}),\\, w(256,\\lambda_{\\mathrm{LP}}),\\, w(32,\\lambda^\\ast),\\, w(64,\\lambda^\\ast),\\, w(128,\\lambda^\\ast),\\, w(256,\\lambda^\\ast),\\, s(\\lambda_{\\mathrm{LP}}),\\, s(\\lambda^\\ast) \\big].\n$$\n所有量都是无量纲实数。程序必须无需任何用户输入即可运行至完成，并按规定精确打印此单行内容。", "solution": "用户提供了一个有效的问题陈述。任务是使用显式有限体积法模拟一维通量限制辐射扩散，比较两种不同的通量限制器，并分析产生的数值扩散。\n\n### 原理与方法\n\n控制方程是关于辐射能量密度 $E(x,t)$ 的非线性抛物型偏微分方程：\n$$\n\\frac{\\partial E}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( D(E,\\partial_x E)\\, \\frac{\\partial E}{\\partial x} \\right) = \\frac{\\partial F}{\\partial x}\n$$\n其中 $F = -D \\frac{\\partial E}{\\partial x}$ 是辐射通量。扩散系数 $D$ 通过其对通量限制器 $\\lambda(R)$ 的依赖性而变为非线性。这种方法是计算天体物理学中用于模拟光学厚（扩散）和光学薄（自由流动）两种区域中辐射转移的标准技术。\n\n关键参数 $R$ 是辐射能量密度的无量纲梯度：\n$$\nR = \\frac{|\\partial_x E|}{\\max(E,\\epsilon)}\n$$\n在具有陡峭梯度的区域（光学薄或波前区域），$R$ 值较大；在平滑区域（光学厚），$R$ 值较小。通量限制器 $\\lambda(R)$ 必须满足两个物理极限：\n1.  **扩散极限 ($R \\to 0$)：** 在光学厚介质中，输运是扩散性的。对于灰色输运，这对应于 $\\lambda(R) \\to 1/3$。\n2.  **自由流动极限 ($R \\to \\infty$)：** 在光学薄介质中，辐射以光速（在我们的无量纲单位中为 $c=1$）流动。通量大小 $|F|$ 不应超过 $cE = E$。由于 $|F| = \\lambda(R) |\\partial_x E| = \\lambda(R) R E$，这要求 $\\lambda(R)R \\le 1$，当 $R \\to \\infty$ 时最优地变为 $\\lambda(R) \\to 1/R$。\n\n问题比较了经典的 Levermore–Pomraning 限制器 $\\lambda_{\\mathrm{LP}}(R)$ 与一种修正形式 $\\lambda^\\ast(R)$，两者都满足这些渐近约束。\n\n### 数值实现\n\n问题指定了一个守恒的有限体积法。计算域 $[0, 1]$ 被离散化为 $N$ 个宽度均匀的单元，$\\Delta x = 1/N$。单元 $i$ 中的单元中心能量密度表示为 $E_i$。时间演化由一个显式前向欧拉格式控制：\n$$\n\\frac{E_i^{n+1} - E_i^n}{\\Delta t} = \\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x}\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。\n\n数值通量定义为：\n$$\nF_{i+1/2}^n = - D_{i+1/2}^n \\left(\\frac{E_{i+1}^n - E_i^n}{\\Delta x}\\right)\n$$\n界面扩散系数 $D_{i+1/2}^n$ 通过使用面心量计算限制器 $\\lambda$ 得到：\n$$\nD_{i+1/2}^n = \\lambda\\left(R_{i+1/2}^n\\right)\n$$\n其中\n$$\nR_{i+1/2}^n = \\frac{|E_{i+1}^n - E_i^n|/\\Delta x}{\\max\\left(\\frac{1}{2}(E_{i+1}^n + E_i^n), \\epsilon\\right)}\n$$\n该格式由问题陈述完全定义，包括零通量边界条件（$F_{-1/2} = F_{N-1/2} = 0$）和基于最大可能扩散系数 $D_{\\max} = 1/3$ 的稳定时间步长 $\\Delta t$。\n\n### 波前厚度和标度分析\n\n模拟以一个阶跃函数（一个黎曼问题）初始化，该函数会演化为一个传播的波前。某些通量限制器（特别是 $\\lambda_{\\mathrm{LP}}$）的一个已知的人为现象是“阶梯效应”，即陡峭的波前被呈现为一系列阶梯。这是一种数值扩散的形式，其中波前宽度与网格分辨率相关联。\n\n为了量化这一点，在固定的时间 $t_{\\mathrm{final}}$ 测量波前厚度 $w$。厚度定义为距离 $|x_{0.9} - x_{0.1}|$，其中 $x_{0.1}$ 和 $x_{0.9}$ 分别是能量密度 $E$ 等于 $E_{\\mathrm{R}} + 0.1(E_{\\mathrm{L}} - E_{\\mathrm{R}})$ 和 $E_{\\mathrm{R}} + 0.9(E_{\\mathrm{L}} - E_{\\mathrm{R}})$ 的位置。这些位置是通过对最终的离散解进行线性插值找到的。\n\n通过对一系列网格分辨率 $N$ 运行模拟，我们得到 $w$ 作为网格间距 $\\Delta x = 1/N$ 的函数。该关系被建模为幂律 $w \\propto (\\Delta x)^s$。标度指数 $s$ 是通过对数空间中的数据进行线性最小二乘拟合确定的：\n$$\n\\log w = s \\log \\Delta x + b\n$$\n$s$ 的值表明了波前宽度依赖于网格的程度。一个理想的限制器将产生一个与 $\\Delta x$ 无关的物理波前宽度，对应于 $s=0$。较大的 $s$ 意味着更大的数值扩散。目标是计算 $\\lambda_{\\mathrm{LP}}$ 和 $\\lambda^\\ast$ 的 $s$ 值并进行比较。\n\n实现将按以下步骤进行：\n1.  一个主循环遍历指定的网格分辨率 $N \\in \\{32, 64, 128, 256\\}$ 和两种限制器函数。\n2.  对于每种情况，调用一个模拟函数 `run_simulation`。它初始化网格和状态，然后在时间上迭代直到 $t_{\\mathrm{final}}$，在每一步计算通量并更新状态向量。\n3.  模拟结束后，`run_simulation` 使用一个插值辅助函数计算波前宽度 $w$。\n4.  收集完所有 $w$ 值后，使用 `numpy.polyfit` 对对数转换后的数据计算标度指数 $s$。\n5.  最后，将收集到的结果格式化为要求的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation, analysis, and output.\n    It encapsulates all helper functions and constants as specified by the problem.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    E_L = 1.0\n    E_R = 1e-3\n    T_FINAL = 2e-2\n    EPSILON = 1e-12\n    D_MAX = 1.0 / 3.0\n    CFL_FACTOR = 0.9\n    R_LP_THRESHOLD = 1e-6\n\n    # --- Helper Functions ---\n\n    def limiter_lp(R):\n        \"\"\"\n        Computes the Levermore-Pomraning flux limiter.\n        This is a vectorized implementation with a small-R Taylor expansion for robustness.\n        \"\"\"\n        R = np.asanyarray(R)\n        result = np.zeros_like(R, dtype=float)\n        \n        small_r_mask = R  R_LP_THRESHOLD\n        large_r_mask = ~small_r_mask\n\n        # Small R expansion: lambda(R) ~ 1/3 - R^2/45\n        r_small = R[small_r_mask]\n        result[small_r_mask] = (1.0/3.0) - (r_small**2 / 45.0)\n\n        # Full expression for larger R: lambda(R) = (1/R) * (coth(R) - 1/R)\n        r_large = R[large_r_mask]\n        with np.errstate(divide='ignore'):\n            coth_r = 1.0 / np.tanh(r_large)\n        \n        val = (1.0 / r_large) * (coth_r - 1.0 / r_large)\n        result[large_r_mask] = val\n        \n        # Explicitly handle R=0 if it appears\n        result[R == 0] = 1.0 / 3.0\n        \n        return result\n\n    def limiter_star(R):\n        \"\"\"\n        Computes the modified flux limiter lambda*.\n        This function is naturally vectorized using numpy operations.\n        \"\"\"\n        R = np.asanyarray(R)\n        return 1.0 / np.sqrt(9.0 + R**2)\n\n    def find_x_interpolated(E, x_centers, dx, E_threshold):\n        \"\"\"\n        Finds the spatial coordinate x where the energy density E equals E_threshold,\n        using linear interpolation between cell centers. E is assumed to be monotonic.\n        \"\"\"\n        # Find indices 'i' where the profile crosses the threshold E_threshold.\n        indices = np.where((E[:-1] >= E_threshold)  (E[1:]  E_threshold))[0]\n\n        if not indices.size:\n            return np.nan # Should not happen in this problem\n\n        i = indices[0]\n        \n        x_i = x_centers[i]\n        E_i = E[i]\n        E_i_plus_1 = E[i+1]\n        \n        # Linear interpolation formula: x = x_i + dx * (E_target - E_i) / (E_{i+1} - E_i)\n        x_interp = x_i + (E_threshold - E_i) * dx / (E_i_plus_1 - E_i)\n        \n        return x_interp\n\n    def run_simulation(N, limiter_func):\n        \"\"\"\n        Runs the 1D FLD simulation for a given grid size N and limiter function.\n        Returns the computed front thickness w.\n        \"\"\"\n        # 1. Grid, Initial Conditions, and Parameters\n        dx = 1.0 / N\n        x_centers = np.linspace(dx / 2.0, 1.0 - dx / 2.0, N)\n        \n        E = np.full(N, E_R)\n        mid_point_idx = int(N / 2)\n        E[:mid_point_idx] = E_L\n        \n        dt = CFL_FACTOR * (dx**2) / (2.0 * D_MAX)\n        t = 0.0\n        \n        # 2. Time Integration Loop\n        while t  T_FINAL:\n            current_dt = min(dt, T_FINAL - t)\n            \n            # 3. Compute fluxes at internal cell faces\n            dE = E[1:] - E[:-1]\n            grad_E = dE / dx\n            E_face = 0.5 * (E[1:] + E[:-1])\n            R_face = np.abs(grad_E) / np.maximum(E_face, EPSILON)\n            D_face = limiter_func(R_face)\n            F_internal = -D_face * grad_E\n            \n            # 4. Update energy density using conservative finite-volume formula\n            F_all = np.zeros(N + 1)\n            F_all[1:-1] = F_internal\n            \n            E -= (current_dt / dx) * (F_all[1:] - F_all[:-1])\n            \n            t += current_dt\n\n        # 5. Compute front thickness at t_final\n        E_01 = E_R + 0.1 * (E_L - E_R)\n        E_09 = E_R + 0.9 * (E_L - E_R)\n\n        x_01 = find_x_interpolated(E, x_centers, dx, E_01)\n        x_09 = find_x_interpolated(E, x_centers, dx, E_09)\n        \n        w = np.abs(x_09 - x_01)\n        \n        return w\n\n    # --- Main Execution Logic ---\n    \n    # Define test suite parameters\n    N_values = np.array([32, 64, 128, 256])\n    limiters = {'lp': limiter_lp, 'star': limiter_star}\n    \n    w_results = {}\n    \n    # Run simulations for each limiter and grid resolution\n    for name, func in limiters.items():\n        w_values = []\n        for N in N_values:\n            w = run_simulation(N, func)\n            w_values.append(w)\n        w_results[name] = w_values\n        \n    # Calculate scaling exponents from a log-log linear fit\n    dx_values = 1.0 / N_values\n    log_dx = np.log(dx_values)\n    \n    log_w_lp = np.log(w_results['lp'])\n    s_lp = np.polyfit(log_dx, log_w_lp, 1)[0]\n    \n    log_w_star = np.log(w_results['star'])\n    s_star = np.polyfit(log_dx, log_w_star, 1)[0]\n    \n    # Format the final output list as specified\n    final_results = w_results['lp'] + w_results['star'] + [s_lp, s_star]\n    \n    print(f\"[{','.join(f'{x:.10f}' for x in final_results)}]\")\n\n\nsolve()\n```", "id": "3511263"}]}