{"hands_on_practices": [{"introduction": "在任何重整化分析中，第一步都是确定理论的哪些部分是发散的，从而需要引入抵消项。这个练习将引导你使用最基本的幂次计数原理，来推导一个图中紫外发散的“表面发散度”。通过这个练习，你将能亲手判断在一个简单的标量场论中，哪些散射振幅在单圈水平上需要重整化。[@problem_id:3530976]", "problem": "考虑一个具有四次自相互作用的实标量场理论，其裸拉格朗日量密度定义为\n$$\n\\mathcal{L}_{0} = \\frac{1}{2} (\\partial_{\\mu} \\phi_{0})(\\partial^{\\mu} \\phi_{0}) - \\frac{1}{2} m_{0}^{2} \\phi_{0}^{2} - \\frac{\\lambda_{0}}{4!} \\phi_{0}^{4}\n$$\n在时空维度 $d = 4 - 2 \\epsilon$ 下，使用维度正规化进行调节。其中 $\\phi_{0}$、$m_{0}$ 和 $\\lambda_{0}$ 是裸量。该理论中的单粒子不可约（1PI）图由动量空间中与 $p^{-2}$ 成比例的传播子和不含导数的点状相互作用顶点构成。\n\n仅使用幂次计数的第一性原理以及连通1PI图中内线、顶点、圈和外腿之间的拓扑关系，推导单圈情况下通用$E$点振幅的表观发散度 $\\omega$，然后显式计算1PI二点（$E=2$）、四点（$E=4$）和六点（$E=6$）振幅的 $\\omega$。根据结果以及在最小减除（MS）方案下维度正规化中抵消项的定义，确定这些振幅中哪些在单圈水平上需要紫外抵消项。\n\n你的最终输出必须是一个 $2 \\times 3$ 的行矩阵。第一行必须包含单圈水平下 $E=2, 4, 6$ 时表观发散度 $\\omega$ 关于 $\\epsilon$ 的表达式，第二行必须包含二进制指示符，用于说明相应振幅在最小减除（MS）方案下是否需要单圈抵消项，其中 $1$ 表示“需要抵消项”，$0$ 表示“不需要抵消项”。", "solution": "问题要求计算标量 $\\phi^4$ 理论中单粒子不可约（1PI）二点（$E=2$）、四点（$E=4$）和六点（$E=6$）振幅在单圈水平下的表观发散度 $\\omega$，并确定其中哪些需要抵消项。分析将基于 $d = 4 - 2\\epsilon$ 时空维度下费曼图的幂次计数和拓扑关系。\n\n一个通用费曼图的表观发散度 $\\omega$ 由以下公式给出：\n$$\n\\omega = Ld - 2I + \\sum_{V} n_V \\delta_V\n$$\n其中 $L$ 是独立圈数，$d$ 是时空维度，$I$ 是内传播子数量，$n_V$ 是类型为 $V$ 的顶点数量，$\\delta_V$ 是与类型 $V$ 顶点相关的动量幂次。\n\n在给定理论中，拉格朗日量密度为 $\\mathcal{L}_{0} = \\frac{1}{2} (\\partial_{\\mu} \\phi_{0})(\\partial^{\\mu} \\phi_{0}) - \\frac{1}{2} m_{0}^{2} \\phi_{0}^{2} - \\frac{\\lambda_{0}}{4!} \\phi_{0}^{4}$。它只有一种类型的相互作用顶点，对应于 $\\phi_{0}^{4}$ 项。该顶点是点状的，不涉及导数，这意味着它不引入任何动量幂次。因此，$\\delta_V = 0$。$\\omega$ 的公式简化为：\n$$\n\\omega = Ld - 2I\n$$\n\n为了将 $\\omega$ 表示为外腿数 $E$ 和圈数 $L$ 的函数，我们使用关于连通图的两个基本拓扑关系。设 $V$ 为总顶点数。\n第一个关系连接了圈数、内线数和顶点数：\n$$\nL = I - V + 1\n$$\n第二个关系说明了线如何连接到顶点。在 $\\phi^4$ 理论中，每个顶点连接四条线。这些线要么是内传播子，要么是外腿。由于每条内线连接两个顶点，所有顶点的线端总数 $4V$ 必须等于外腿数 $E$ 加上内线数 $2I$ 的两倍：\n$$\n4V = E + 2I \\implies V = \\frac{E + 2I}{4}\n$$\n\n我们现在求解这个方程组来找到 $\\omega(E, L, d)$。将 $V$ 的表达式代入圈关系式中：\n$$\nL = I - \\left( \\frac{E + 2I}{4} \\right) + 1\n$$\n$$\n4L = 4I - (E + 2I) + 4\n$$\n$$\n4L = 2I - E + 4\n$$\n求解出现在 $\\omega$ 公式中的 $2I$：\n$$\n2I = 4L + E - 4\n$$\n现在，将这个 $2I$ 的表达式代入 $\\omega$ 的公式中：\n$$\n\\omega = Ld - (4L + E - 4) = Ld - 4L - E + 4\n$$\n$$\n\\omega(E, L, d) = L(d - 4) - E + 4\n$$\n\n问题指定了时空维度 $d = 4 - 2\\epsilon$，并要求计算单圈（$L=1$）振幅。将这些值代入 $\\omega$ 的通用公式中：\n$$\n\\omega(E, L=1) = 1 \\cdot ((4 - 2\\epsilon) - 4) - E + 4\n$$\n$$\n\\omega(E, L=1) = -2\\epsilon - E + 4 = 4 - E - 2\\epsilon\n$$\n这就是该理论中单圈、$E$点1PI振幅的表观发散度。\n\n现在，我们为指定的外腿数计算 $\\omega$：\n1.  对于1PI二点函数（$E=2$）：\n$$\n\\omega(E=2) = 4 - 2 - 2\\epsilon = 2 - 2\\epsilon\n$$\n2.  对于1PI四点函数（$E=4$）：\n$$\n\\omega(E=4) = 4 - 4 - 2\\epsilon = -2\\epsilon\n$$\n3.  对于1PI六点函数（$E=6$）：\n$$\n\\omega(E=6) = 4 - 6 - 2\\epsilon = -2 - 2\\epsilon\n$$\n\n最后一步是确定这些振幅中哪些需要紫外（UV）抵消项。在维度正规化中，如果一个振幅的表观发散度 $\\omega$ 在调节子 $\\epsilon$ 趋于零的极限下为非负数，则该振幅是紫外发散的。一个发散的振幅需要一个抵消项来抵消发散（表现为 $\\epsilon$ 的极点）。\n我们对每种情况考察 $\\epsilon \\to 0$ 的极限：\n1.  对于 $E=2$: $\\lim_{\\epsilon \\to 0} \\omega = \\lim_{\\epsilon \\to 0} (2 - 2\\epsilon) = 2$。由于 $2 > 0$，该振幅是二次发散的。它需要抵消项，特别是质量（$\\delta m$）和波函数重整化（$\\delta_Z$）的抵消项。因此，需要一个抵消项（$1$）。\n2.  对于 $E=4$: $\\lim_{\\epsilon \\to 0} \\omega = \\lim_{\\epsilon \\to 0} (-2\\epsilon) = 0$。由于 $0 \\ge 0$，该振幅是对数发散的。它需要一个耦合常数（$\\delta_\\lambda$）的抵消项。因此，需要一个抵消项（$1$）。\n3.  对于 $E=6$: $\\lim_{\\epsilon \\to 0} \\omega = \\lim_{\\epsilon \\to 0} (-2 - 2\\epsilon) = -2$。由于 $-2  0$，该振幅是紫外有限的。它不需要一个本原的单圈抵消项。因此，不需要抵消项（$0$）。\n\n我们现在可以将最终答案组合成一个 $2 \\times 3$ 的矩阵。第一行包含 $\\omega$ 的表达式，第二行包含表示是否需要抵消项的二进制指示符（$1$ 表示是，$0$ 表示否）。\n第一行是：$\\omega(E=2)=2-2\\epsilon$，$\\omega(E=4)=-2\\epsilon$，$\\omega(E=6)=-2-2\\epsilon$。\n第二行是：$1$，$1$，$0$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 - 2\\epsilon  -2\\epsilon  -2 - 2\\epsilon \\\\\n1  1  0\n\\end{pmatrix}\n}\n$$", "id": "3530976"}, {"introduction": "任何适用于规范场论的有效重整化方案，都必须保证物理可观测量不依赖于人为引入的、非物理的规范固定参数（如 $\\xi$）。本练习通过一个具体的计算任务，让你在量子电动力学（QED）中数值验证这一核心原则。你将看到来自不同圈图（电子自能和顶点修正）的规范依赖项是如何精确抵消的，从而加深对规范不变性如何在实际计算中得以维持的理解。[@problem_id:3531042]", "problem": "考虑一个具有规范参数 $\\xi$ 的一般协变规范下的量子电动力学（QED），将规范固定项添加到拉格朗日密度中，使得自由光子传播子被修正为\n$$\nD_{\\mu\\nu}(k) = \\frac{-i}{k^2 + i0} \\left( g_{\\mu\\nu} - \\xi \\frac{k_\\mu k_\\nu}{k^2} \\right).\n$$\n在单圈水平上，电子自能和电子-光子顶点都得到修正。光子传播子的纵向部分（与 $\\xi$ 成正比）是这些单圈量中显式 $\\xi$ 依赖性的唯一来源。当应用适当的对消项和重整化方案时，重整化的 S 矩阵元必须与规范参数无关。在阿贝尔情形下，Slavnov–Taylor 恒等式简化为 Ward–Takahashi 恒等式，这意味着在单圈水平上电子场重整化常数和顶点重整化常数相等。\n\n从以传播子和相互作用顶点表示的单圈电子自能 $\\Sigma(p)$ 和单圈顶点函数 $\\Gamma_\\mu(p,p')$ 的定义出发，并使用标准的 Feynman 参数化和迹/投影方法，推导以下各项依赖于规范参数的部分的一维积分表示：\n- 电子场重整化常数 $\\delta Z_\\psi(\\xi)$，通过在 $p^2 = m^2$ 处将在壳残数条件下的 $\\partial \\Sigma/\\partial \\not p$ 的 $\\not p$ 分量进行投影得到，以及\n- 在零动量转移时，在壳电荷形状因子中依赖于规范参数的部分 $\\delta F_1^{(\\xi)}(0)$，通过在 $q^2 = 0$ 处将顶点修正投影到 $\\gamma_\\mu$ 结构上提取。\n\n证明这两个依赖于规范参数的部分都可以通过相同的标量积分表示\n$$\nJ(m) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{m^2}{m^2 - x(1-x) m^2}\\right) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{1}{1 - x + x^2}\\right),\n$$\n并且符号相反：\n$$\n\\delta Z_\\psi(\\xi) = \\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m), \\qquad \\delta F_1^{(\\xi)}(0) = -\\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m),\n$$\n其中 $\\alpha$ 是精细结构常数，$m$ 是电子质量。使用这些结果，在零动量转移处的在壳电荷形状因子的重整化振幅，\n$$\nA_R^{(\\xi)} = \\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi),\n$$\n在单圈水平上必须与 $\\xi$ 无关。这在此背景下验证了阿贝尔 Slavnov-Taylor 恒等式（Ward–Takahashi 恒等式），该恒等式意味着对于依赖于规范的部分，在单圈水平上有 $Z_1(\\xi) = Z_\\psi(\\xi)$。\n\n实现两种场重整化方案：\n- 在壳方案 (OS)：在物理极点 $p^2 = m^2$ 处固定质量和电子传播子的残数。\n- 修正的最小减除方案 ($\\overline{\\text{MS}}$)：仅减去紫外发散和与量纲正则化相关的普适常数，保持有限部分不变。\n\n通过数值积分法数值计算 $J(m)$，并为一系列选定的规范参数 $\\xi$ 验证 $A_R^{(\\xi)}$ 的 $\\xi$ 无关性。取精细结构常数 $\\alpha = 1/137$ 和一个以任意一致单位表示的电子质量参数 $m$（最终检查是无量纲的，因此不需要明确的单位输出）。不出现角度。不使用百分比。\n\n你的程序必须实现 $J(m)$ 的积分，计算 $\\delta Z_\\psi(\\xi)$ 和 $\\delta F_1^{(\\xi)}(0)$，并在 OS 和 $\\overline{\\text{MS}}$ 两种方案中验证 $A_R^{(\\xi)}$ 的单圈 $\\xi$ 无关性。此外，通过证明 $\\delta Z_\\psi(\\xi) + \\delta F_1^{(\\xi)}(0) = 0$ 来确认对于依赖规范的部分，恒等式 $Z_1(\\xi) = Z_\\psi(\\xi)$ 成立。\n\n测试套件：\n- 情况 1（正常路径，朗道规范）：$\\xi = 0.0$，方案 OS，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 2（费曼规范）：$\\xi = 1.0$，方案 OS，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 3（大规范参数）：$\\xi = 3.0$，方案 OS，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 4（方案变化）：$\\xi = 1.0$，方案 $\\overline{\\text{MS}}$，$m = 0.511$，$\\alpha = 1/137$。\n- 情况 5（恒等式检验）：对 $\\xi = 2.5$，方案 OS，$m = 0.511$，$\\alpha = 1/137$ 验证 $\\delta Z_\\psi(\\xi) + \\delta F_1^{(\\xi)}(0) \\approx 0$。\n\n对于每种情况，返回一个布尔值，指示相应的检查是否在 $10^{-10}$ 的绝对容差内通过。\n\n最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4,result5]\"）。", "solution": "问题陈述是计算高能物理领域的一个有效练习，要求在单圈水平上对量子电动力学（QED）中规范不变性的一个关键推论进行数值验证。我将首先建立理论背景，然后详细说明数值验证过程。\n\n该问题要求验证在电子与光子相互作用的单圈修正中，依赖于规范参数的项的相消。在 QED 中，为了以协变方式量子化该理论，必须引入一个规范固定项。此过程会在中间计算中引入一个非物理的规范参数，通常用 $\\xi$ 表示，例如在光子传播子 $D_{\\mu\\nu}(k)$ 中：\n$$\nD_{\\mu\\nu}(k) = \\frac{-i}{k^2 + i0} \\left( g_{\\mu\\nu} - \\xi \\frac{k_\\mu k_\\nu}{k^2} \\right)\n$$\n物理可观测量，例如 S 矩阵元，必须与 $\\xi$ 无关。这种无关性由理论的内在规范对称性保证，该对称性通过格林函数之间的关系（称为 Slavnov-Taylor 恒等式）表现出来。对于像 QED 这样的阿贝尔理论，这些恒等式简化为 Ward-Takahashi 恒等式。\n\n在单圈水平上，电子自能 $\\Sigma(p)$ 和电子-光子顶点函数 $\\Gamma_\\mu(p, p')$ 收到依赖于 $\\xi$ 的发散修正。重整化是一个将这些发散吸收到理论的场和参数的重新定义中的过程，例如电子场重整化常数 $Z_\\psi$ 和顶点重整化常数 $Z_1$。QED 的 Ward-Takahashi 恒等式意味着这两个常数之间的一个关键关系：$Z_1 = Z_\\psi$。\n\n该问题侧重于单圈修正中依赖规范的部分。令对消项为 $\\delta Z_\\psi = Z_\\psi - 1$ 和 $\\delta Z_1 = Z_1 - 1$。我们可以将它们分解为一个规范无关部分和一个依赖规范的部分，例如 $\\delta Z_\\psi = \\delta Z_\\psi^{(\\text{inv})} + \\delta Z_\\psi(\\xi)$。Ward-Takahashi 恒等式 $Z_1 = Z_\\psi$ 必须对这两个部分分别成立，因此 $\\delta Z_1(\\xi) = \\delta Z_\\psi(\\xi)$。\n\n在壳顶点函数 $\\Gamma_\\mu$ 由形状因子参数化，主要是电荷形状因子 $F_1(q^2)$，其中 $q=p'-p$。值 $F_1(0)$ 对重整化电荷的定义有贡献。对 $F_1(q^2)$ 的单圈贡献也有一个依赖规范的部分，我们记为 $\\delta F_1^{(\\xi)}(q^2)$。为了使物理电荷与规范无关，在零动量转移处对顶点的完整单圈修正中依赖规范的部分必须为零。此修正由圈图部分 $F_1(0)$ 和对消项部分 $\\delta Z_1$ 组成。因此，它们依赖规范的部分之和必须为零：\n$$\n\\delta F_1^{(\\xi)}(0) + \\delta Z_1(\\xi) = 0\n$$\n使用 Ward-Takahashi 恒等式，这变为：\n$$\n\\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi) = 0\n$$\n这就是要验证的核心恒等式。问题提供了对这些依赖 $\\xi$ 的部分的单圈计算结果：\n$$\n\\delta Z_\\psi(\\xi) = \\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m)\n$$\n$$\n\\delta F_1^{(\\xi)}(0) = -\\frac{\\alpha \\, \\xi}{4\\pi} \\, J(m)\n$$\n其中 $\\alpha$ 是精细结构常数，$J(m)$ 是一个特定的标量积分。在问题中定义的和 $A_R^{(\\xi)} = \\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi)$ 显然为零，这证实了理论预期。\n\n积分 $J(m)$ 给出如下：\n$$\nJ(m) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{m^2}{m^2 - x(1-x) m^2}\\right)\n$$\n该表达式可以通过消去质量参数 $m$ 来简化：\n$$\nJ(m) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{m^2}{m^2(1 - (x-x^2))}\\right) = \\int_0^1 dx \\, \\ln\\!\\left(\\frac{1}{1 - x + x^2}\\right)\n$$\n这表明积分 $J$ 实际上是一个普适常数，与电子质量 $m$ 无关。被积函数的分母 $1-x+x^2$ 对于 $x \\in [0, 1]$ 是严格为正的，因此该积分是良定义的。我们将对这个定积分进行数值计算。\n\n问题提到了两种重整化方案，在壳 (OS) 和修正的最小减除 ($\\overline{\\text{MS}}$)。这些方案在它们定义的对消项的有限、规范**无关**部分有所不同。然而，依赖规范的部分 $\\delta Z_\\psi(\\xi)$ 和 $\\delta F_1^{(\\xi)}(0)$ 仅由规范固定项和理论结构决定，因此与重整化方案的选择无关。因此，在任何有效方案中，对相消关系 $\\delta F_1^{(\\xi)}(0) + \\delta Z_\\psi(\\xi) = 0$ 的验证都是相同的，这是一个通过包含 OS 和 $\\overline{\\text{MS}}$ 两种情况来测试的概念性要点。\n\n数值任务是为测试套件实现计算。对于每种情况，我们将：1. 使用数值积分法数值计算常数 $J = \\int_0^1 \\ln(1 / (1 - x + x^2)) dx$ 的值。2. 使用给定的精细结构常数 $\\alpha = 1/137$ 和规范参数 $\\xi$ 的值。3. 使用提供的公式计算 $\\delta Z_\\psi(\\xi)$ 和 $\\delta F_1^{(\\xi)}(0)$。4. 在 $10^{-10}$ 的数值容差内验证它们的和为零。对于检查“$\\xi$ 无关性”的测试用例，这等价于检查和 $A_R^{(\\xi)}$ 是否为零，因为如果相消成立，该量本身就被构造成零。通过证明 $\\delta Z_\\psi(\\xi) + \\delta F_1^{(\\xi)}(0) = 0$ 来确认恒等式 $Z_1(\\xi) = Z_\\psi(\\xi)$。\n\n实现将使用 `scipy.integrate.quad` 进行精确的数值积分。程序结构将遍历五个测试用例，执行计算，并根据容差检查追加一个布尔结果。所有测试用例都预计会通过，因为它们代表了 QED 的一个基本一致性检验。对于 $\\xi=0$，这些量平凡地为零，而对于其他 $\\xi$ 值，它们会相互抵消，展示了该理论结构的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Numerically verifies the cancellation of gauge-parameter-dependent terms\n    in one-loop QED corrections, as a consequence of the Ward-Takahashi identity.\n    \"\"\"\n\n    # Define the integrand for the scalar integral J.\n    # J = integral from 0 to 1 of ln(1 / (1 - x + x^2)) dx\n    def integrand(x):\n        return np.log(1.0 / (1.0 - x + x**2))\n\n    # Numerically evaluate the integral J. The result is a constant.\n    # The integration error is negligible for this problem's tolerance.\n    J_val, _ = integrate.quad(integrand, 0, 1)\n\n    # Define constants from the problem statement.\n    alpha = 1.0 / 137.0\n    pi = np.pi\n    tolerance = 1e-10\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (xi, scheme, m). Note: scheme and m do not affect the calculation\n    # of the gauge-dependent pieces, as explained in the solution.\n    test_cases = [\n        (0.0, 'OS', 0.511),         # Case 1: Landau gauge\n        (1.0, 'OS', 0.511),         # Case 2: Feynman gauge\n        (3.0, 'OS', 0.511),         # Case 3: Large gauge parameter\n        (1.0, 'MS_bar', 0.511),     # Case 4: Scheme variation (conceptual check)\n        (2.5, 'OS', 0.511)          # Case 5: Explicit identity check\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        xi, scheme, m = case\n\n        # Calculate the gauge-parameter-dependent parts of the electron field\n        # renormalization constant and the charge form factor.\n        # delta Z_psi(xi) = (alpha * xi / (4 * pi)) * J\n        delta_Z_psi_xi = (alpha * xi / (4.0 * pi)) * J_val\n\n        # delta F_1^(xi)(0) = -(alpha * xi / (4 * pi)) * J\n        delta_F1_xi_0 = -(alpha * xi / (4.0 * pi)) * J_val\n\n        # The quantity A_R^(xi) is the sum of these two, which must be independent\n        # of xi, implying it must be zero for the cancellation to hold.\n        # This check is the same for all test cases.\n        # For cases 1-4, we verify xi-independence by checking if the sum is zero.\n        # For case 5, we explicitly check if the sum is approximately zero.\n        # The logic is identical for all five cases.\n        \n        sum_of_gauge_parts = delta_Z_psi_xi + delta_F1_xi_0\n\n        # Check if the absolute value of the sum is within the given tolerance.\n        check_passed = np.abs(sum_of_gauge_parts)  tolerance\n        results.append(check_passed)\n        \n    # Convert numpy.bool_ to standard Python bool for printing \"True\" or \"False\"\n    # and format the output as a comma-separated list in brackets.\n    # str() on a bool gives capitalized 'True'/'False' which is fine, no need for special mapping.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3531042"}, {"introduction": "现代高能物理计算严重依赖于将复杂的重整化过程分解为系统化算法的能力。这个练习通过一个结构虽简化但原理正确的模型，揭示了这一自动化过程的核心逻辑。你将亲手实现一个程序，它能识别发散的子图，执行一个与具体方案无关的极点减除，并将定义方案的有限部分的选择推迟到一个独立的后处理层，从而领会方案无关的抵消项构造与具体方案选择相分离的思想。[@problem_id:3531050]", "problem": "你需要实现一个程序，该程序能自动标记紫外发散子图，构造一个与方案无关的抵消项插入，并将所有有限方案的选择推迟到一个强制执行用户指定重整化条件的后处理层。目标场论是具有四次自相互作用的实标量场。你的设计必须从以下第一性原理和公认定义出发。\n\n从以下基本原则开始。\n\n- 在 $d = 4 - 2\\epsilon$ 维中使用维数正规化，其中 $\\epsilon \\to 0^{+}$。费曼振幅表示为关于 $\\epsilon$ 的洛朗级数，所有紫外 (UV) 发散都表现为 $\\epsilon$ 的极点。\n- 在$d=4$维的标量 $\\phi^{4}$ 理论中，对于具有 $E$ 条外腿的连通子图，其表面发散度为 $\\omega = 4 - E$。因此，具有 $E \\in \\{0,2,4\\}$ 的子图是表面紫外发散的，而具有 $E \\ge 6$ 的子图是表面收敛的。\n- 通过抵消项进行的重整化，通过 Bogoliubov-Parasiuk-Hepp-Zimmermann (BPHZ) 森林公式局域地减去 UV 发散。在维数正规化中，最小减除 (MS) 只移除 $\\epsilon$ 中的极点项，而其他方案则在有限部分上有所不同。一个与方案无关的抵消项表示必须根据局域性和幂次计数保持极点部分固定，而有限部分则作为方案参数，在后处理步骤中通过重整化条件来确定。\n\n为了使任务在计算上确定，同时忠实于上述原则，我们为特定的单圈原初拓扑和复合双圈拓扑的振幅采用以下玩具但结构正确的模型。\n\n- 定义一个原初单圈两点子图（蝌蚪图状修正），其振幅为\n  $$A_{2}^{(1)}(\\lambda, m^{2}) = \\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + f_{2}\\right),$$\n  其中 $\\lambda$ 是四次耦合常数，$m^{2}$ 是一个质量参数，$c_{2} = \\tfrac{1}{2}$ 是一个固定的极点系数，$f_{2}$ 是作为输入数据提供的有限余项。\n- 定义一个原初单圈四点子图（单个气泡图），其振幅为\n  $$A_{4}^{(1)}(\\lambda) = \\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right),$$\n  其中 $c_{4} = 3$ 是一个固定的极点系数，$f_{4}$ 是作为输入数据提供的有限余项。\n- 定义一个复合双圈四点“双气泡”拓扑，其未重整化振幅模型为\n  $$A_{4,\\mathrm{db}}^{(2)}(\\lambda) = \\lambda^{3}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right)^{2}.$$\n  这个复合图包含两个相同的单圈四点子发散。在与方案无关的抵消项插入中，你必须局域地减去每个发散的单圈四点子图，将复合有限余项留作所选有限方案参数的函数。\n\n对于每个输入图实例，你的程序必须执行以下步骤。\n\n1) 标记 UV 发散子图。给定每个子图的外腿数 $E$ 和圈数 $L$，计算 $\\omega = 4 - E$。如果 $\\omega \\ge 0$ 且 $L \\ge 1$，则将该子图标记为 UV 发散。\n\n2) 构建与方案无关的中间表示 (IR)。对于每个标记为 UV 发散的子图，将其抵消项符号化地表示为其极点部分的减法加上一个未确定的有限参数。具体来说，为两点子图引入有限参数 $\\alpha_{m}$，为四点子图引入 $\\alpha_{\\lambda}$，并定义抵消项\n   - 对于单圈两点图：\n   $$\\delta m^{2} = -\\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + \\alpha_{m}\\right).$$\n   - 对于单圈四点图：\n   $$\\delta \\lambda = -\\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + \\alpha_{\\lambda}\\right).$$\n   在这个与方案无关的 IR 中，这些 $\\alpha$ 参数尚未确定。\n\n3) 森林减除和重整化振幅。实现 $R'$-操作，通过在每个标记的子图中插入上述抵消项来减去所有子发散。在这个玩具模型中，这将每个原初单圈子图简化为其有限余项\n   - 单圈两点有限余项：\n   $$F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right).$$\n   - 单圈四点有限余项：\n   $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right).$$\n   对于复合双圈双气泡图，在减去两个子发散后，重整化的有限余项为\n   $$F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2}.$$\n   在这个模型中，一旦所有子发散被减去，就不会留下额外的总体发散；因此，复合图不需要额外的总体抵消项。\n\n4) 用于方案固定的后处理层。在与方案无关的构造之后，根据用户指定的条件选择有限参数 $\\alpha_{m}$ 和 $\\alpha_{\\lambda}$。实现以下三个条件族：\n   - 最小减除 (MS)：设置 $\\alpha_{m} = 0$ 和 $\\alpha_{\\lambda} = 0$。\n   - 自定义有限平移：当指定时，对 $\\alpha_{m}$ 和 $\\alpha_{\\lambda}$ 使用提供的数值；任何未指定的 $\\alpha$ 默认为 $0$。\n   - 单圈四点函数的类动量减除条件 (MOM4\\_ZERO)：要求单圈四点重整化修正在选定的运动学点上为零，此处通过设置 $\\alpha_{\\lambda} = f_{4}$ 实现，并且除非另有说明，否则取 $\\alpha_{m} = 0$。\n\n实现要求。\n\n- 你必须实现：\n  - 一个计算 $\\omega = 4 - E$ 并将 $\\omega \\ge 0$ 和 $L \\ge 1$ 的子图标记为 UV 发散的函数。\n  - 一个与方案无关的 IR 构建器，它将每个标记的子图替换为其抵消项符号 $(\\text{pole} + \\alpha)$ 并推迟选择 $\\alpha$。\n  - 一个后处理层，它根据给定的方案规范，确定 $(\\alpha_{m}, \\alpha_{\\lambda})$ 并计算重整化的有限余项 $F_{2}^{(1)}$、$F_{4}^{(1)}$ 和 $F_{4,\\mathrm{db}}^{(2)}$。\n- 在所有情况下使用固定的极点系数 $c_{2} = \\tfrac{1}{2}$ 和 $c_{4} = 3$。\n- 所有返回的数值答案必须是实数，不需要物理单位。\n\n测试套件。\n\n对于以下每个测试用例，在应用指定的方案条件后，计算指定图形的重整化有限余项。你的程序必须嵌入这些测试用例并以指定格式生成最终输出。\n\n- 测试 A（单圈四点图，MS）：\n  - 图：单圈四点子图，具有 $E = 4$, $L = 1$。\n  - 输入：$\\lambda = 0.1$, $f_{4} = 1.25$。\n  - 方案：最小减除 ($\\alpha_{\\lambda} = 0$)。\n  - 输出：单个数字 $F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right)$。\n- 测试 B（单圈两点图，自定义有限质量平移）：\n  - 图：单圈两点子图，具有 $E = 2$, $L = 1$。\n  - 输入：$\\lambda = 0.2$, $m^{2} = 2.0$, $f_{2} = 0.5$，自定义有限选择 $\\alpha_{m} = 0.75$。\n  - 方案：自定义有限质量平移。\n  - 输出：单个数字 $F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right)$。\n- 测试 C（双圈四点双气泡图，类 MOM 条件）：\n  - 图：双圈四点双气泡图，具有两个相同的单圈四点子发散，总体 $E = 4$, $L = 2$。\n  - 输入：$\\lambda = 0.3$, $f_{4} = 0.8$。\n  - 方案：MOM4\\_ZERO，即选择 $\\alpha_{\\lambda} = f_{4}$。\n  - 输出：单个数字 $F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2}$。\n- 测试 D（单圈四点图，自定义有限耦合平移）：\n  - 图：单圈四点子图，具有 $E = 4$, $L = 1$。\n  - 输入：$\\lambda = 0.5$, $f_{4} = 0.2$，自定义有限选择 $\\alpha_{\\lambda} = -0.5$。\n  - 方案：自定义有限耦合平移。\n  - 输出：单个数字 $F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right)$。\n\n最终输出格式。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表。输出的顺序必须遵循测试 A、B、C、D。例如，一个包含四个结果的输出行应如下所示\n$$[x_{A},x_{B},x_{C},x_{D}].$$\n每个 $x$ 必须是标准记数法（不要求科学记数法，但标准的 Python 格式是可接受的）的浮点小数。", "solution": "目标是设计一种算法和实现，将与方案无关的紫外减除与方案相关的有限选择分离开来。其物理基础是标量 $\\phi^4$ 理论中的发散结构以及维数正规化中重整化的标准实践。我们将逐步解释设计，将原理映射到计算。\n\n基本原理。\n\n- 在维数正规化中，当 $d = 4 - 2\\epsilon$ 时，紫外发散表现为 $\\epsilon$ 的极点。在 $\\epsilon = 0$ 附近的洛朗展开是其标准的解析表示。抵消项必须抵消这些极点以使振幅有限。\n- 在 $\\phi^{4}$ 理论中，幂次计数给出了具有 $E$ 条外腿的连通子图的表面发散度 $\\omega = 4 - E$。这一事实源于圈、内线和顶点之间的一般关系（拓扑恒等式），并且是四维可重整化理论中一个经过充分检验的特征。因此，具有 $E \\in \\{0,2,4\\}$ 的子图可能发散，而 $E \\ge 6$ 的子图是表面收敛的。\n- Bogoliubov-Parasiuk-Hepp-Zimmermann (BPHZ) 森林公式指示我们在减去任何总体发散之前，先减去所有子发散（由发散子图的森林编码）。在维数正规化中，最小减除仅移除极点部分，而其他方案也调整有限部分。因此，一个与方案无关的阶段可以唯一地确定极点部分（通过局域性和幂次计数），而将有限部分作为符号参数留待以后确定。\n\n玩具振幅模型及其理由。\n\n我们将自己限制在一个最小但结构上忠实的图拓扑集合中，并使用已知的单圈系数作为极点项：\n\n- 单圈两点原初图（类蝌蚪图）：\n  $$A_{2}^{(1)}(\\lambda, m^{2}) = \\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + f_{2}\\right),\\quad c_{2} = \\frac{1}{2}.$$\n  系数 $c_{2} = \\tfrac{1}{2}$ 与 $\\lambda \\phi^{4}/4!$ 理论中蝌蚪图积分乘以对称因子的标准归一化是一致的，只是相差一个约定俗成的 $(16\\pi^{2})^{-1}$ 因子，该因子已被我们的单位吸收。有限余项 $f_{2}$ 取决于重整化标度和运动学，我们将其视为提供的输入数值。\n- 单圈四点原初图（单气泡图）：\n  $$A_{4}^{(1)}(\\lambda) = \\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right),\\quad c_{4} = 3.$$\n  因子 $c_{4} = 3$ 包含了对 s、t 和 u 道的求和，这是 $\\phi^{4}$ 理论中单圈四点函数的典型特征，同样采用吸收了普适常数的归一化。有限余项 $f_{4}$ 作为输入提供。\n- 双圈四点双气泡复合图：\n  $$A_{4,\\mathrm{db}}^{(2)}(\\lambda) = \\lambda^{3}\\left(\\frac{c_{4}}{\\epsilon} + f_{4}\\right)^{2}.$$\n  这个复合图包含两个相同的单圈四点子发散子图。在严格的场论计算中，除了子发散之外可能还有总体发散；然而，我们的玩具模型专注于局部子发散减除的算法执行，并将剩余部分视为在所有子发散被移除后是有限的。\n\n与方案无关的抵消项构造。\n\n对于一个标记为 UV 发散的子图，我们引入一个抵消项，它移除其极点和一个未确定的有限部分。与方案无关的抵消项是\n\n- 单圈两点：\n  $$\\delta m^{2} = -\\lambda\\, m^{2}\\left(\\frac{c_{2}}{\\epsilon} + \\alpha_{m}\\right),$$\n  其中 $\\alpha_{m}$ 是一个稍后设置的方案参数。\n- 单圈四点：\n  $$\\delta \\lambda = -\\lambda^{2}\\left(\\frac{c_{4}}{\\epsilon} + \\alpha_{\\lambda}\\right),$$\n  其中 $\\alpha_{\\lambda}$ 是一个稍后设置的方案参数。\n\n减去子发散得到原初图的重整化有限余项：\n\n- 单圈两点重整化有限余项：\n  $$F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right).$$\n- 单圈四点重整化有限余项：\n  $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right).$$\n\n对于双圈双气泡图，减去每个相同的单圈四点子发散得到\n\n$$F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2}.$$\n\n这在我们的模型中实现了针对子发散的 $R'$-操作（森林减除）。\n\n后处理层（方案固定）。\n\n有限参数 $(\\alpha_{m}, \\alpha_{\\lambda})$ 通过后处理条件设置：\n\n- 最小减除 (MS)：只移除极点，因此\n  $$\\alpha_{m} = 0,\\quad \\alpha_{\\lambda} = 0.$$\n- 自定义有限平移：对 $(\\alpha_{m}, \\alpha_{\\lambda})$ 的任何子集使用用户指定的值，并将未指定的默认为 $0$。\n- 单圈四点函数的类动量减除条件 (MOM4\\_ZERO)：通过设置\n  $$\\alpha_{\\lambda} = f_{4},\\quad \\alpha_{m} = 0,$$\n  来强制单圈四点重整化修正在选定的运动学点上为零。\n\n算法步骤。\n\n1) 对于给定的图，识别所有具有 $L \\ge 1$ 和 $E \\in \\{2,4\\}$ 的子图，并使用 $\\omega = 4 - E \\ge 0$ 将它们标记为 UV 发散。\n2) 构建一个中间表示，其中每个标记的子图的振幅表示为一个对偶（极点系数，有限余项）及其类型（$E=2$ 或 $E=4$），并附上相应的有限方案参数 $\\alpha_{m}$ 或 $\\alpha_{\\lambda}$。\n3) 应用 $R'$-操作：将每个原初子图替换为其重整化有限余项 $f - \\alpha$，对于双气泡复合图，使用乘积结构 $\\lambda^{3}(f_{4} - \\alpha_{\\lambda})^{2}$。\n4) 在后处理中，根据所选方案评估 $(\\alpha_{m}, \\alpha_{\\lambda})$ 并计算所得的数值。\n\n在测试套件上进行验证。\n\n- 测试 A:\n  输入：$\\lambda = 0.1$, $f_{4} = 1.25$，MS 方案，因此 $\\alpha_{\\lambda} = 0$。\n  $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right) = (0.1)^{2} \\times (1.25 - 0) = 0.0125.$$\n- 测试 B:\n  输入：$\\lambda = 0.2$, $m^{2} = 2.0$, $f_{2} = 0.5$，自定义 $\\alpha_{m} = 0.75$。\n  $$F_{2}^{(1)} = \\lambda\\, m^{2}\\left(f_{2} - \\alpha_{m}\\right) = 0.2 \\times 2.0 \\times (0.5 - 0.75) = -0.1.$$\n- 测试 C:\n  输入：$\\lambda = 0.3$, $f_{4} = 0.8$，MOM4\\_ZERO 方案，因此 $\\alpha_{\\lambda} = f_{4} = 0.8$。\n  $$F_{4,\\mathrm{db}}^{(2)} = \\lambda^{3}\\left(f_{4} - \\alpha_{\\lambda}\\right)^{2} = (0.3)^{3} \\times 0^{2} = 0.$$\n- 测试 D:\n  输入：$\\lambda = 0.5$, $f_{4} = 0.2$，自定义 $\\alpha_{\\lambda} = -0.5$。\n  $$F_{4}^{(1)} = \\lambda^{2}\\left(f_{4} - \\alpha_{\\lambda}\\right) = (0.5)^{2} \\times (0.2 - (-0.5)) = 0.25 \\times 0.7 = 0.175.$$\n\n因此，程序应生成单行输出：\n$$[0.0125,-0.1,0.0,0.175].$$\n\n下面的实现完成了这些步骤，包括对指定测试的显式标记、中间表示、方案解析和求值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants for pole coefficients in the toy model\nC2 = 0.5  # c2 for one-loop 2-point primitive\nC4 = 3.0  # c4 for one-loop 4-point primitive\n\n# Enumerations for clarity\nE_TWO_POINT = 2\nE_FOUR_POINT = 4\n\nclass Subgraph:\n    \"\"\"\n    Represents a subgraph with given external legs (E),\n    loop order (L), and a type tag for behavior.\n    \"\"\"\n    def __init__(self, E: int, L: int, tag: str):\n        self.E = E\n        self.L = L\n        self.tag = tag  # 'G2_1L', 'G4_1L'\n\n    def superficial_degree(self) - int:\n        # omega = 4 - E in phi^4 theory in 4D\n        return 4 - self.E\n\n    def is_uv_divergent(self) - bool:\n        # UV divergent if omega = 0 and L = 1\n        return (self.superficial_degree() = 0) and (self.L = 1)\n\nclass Graph:\n    \"\"\"\n    Represents a graph topology with possible subdivergences.\n    type_tag: 'G2_1L', 'G4_1L', 'G4_2L_db'\n    subgraphs: list of Subgraph (for tagging)\n    \"\"\"\n    def __init__(self, type_tag: str, subgraphs):\n        self.type_tag = type_tag\n        self.subgraphs = subgraphs\n\n    def tag_uv_subgraphs(self):\n        # Return list of indices (or subgraphs) that are UV-divergent\n        tags = []\n        for sg in self.subgraphs:\n            if sg.is_uv_divergent():\n                tags.append(sg)\n        return tags\n\ndef scheme_postprocess(scheme: str, params: dict) - dict:\n    \"\"\"\n    Given a scheme name and input parameters, determine the finite scheme parameters alpha_m and alpha_lam.\n    - scheme 'MS': alpha_m = 0, alpha_lam = 0\n    - scheme 'CUSTOM': read alpha_m and alpha_lam from params if present, else default 0\n    - scheme 'MOM4_ZERO': alpha_lam = f4, alpha_m = 0 (unless provided)\n    \"\"\"\n    alpha_m = 0.0\n    alpha_lam = 0.0\n    scheme_upper = scheme.upper()\n    if scheme_upper == 'MS':\n        alpha_m = 0.0\n        alpha_lam = 0.0\n    elif scheme_upper == 'CUSTOM':\n        alpha_m = float(params.get('alpha_m', 0.0))\n        alpha_lam = float(params.get('alpha_lam', 0.0))\n    elif scheme_upper == 'MOM4_ZERO':\n        # Enforce one-loop 4-point correction to vanish: alpha_lam = f4\n        if 'f4' not in params:\n            raise ValueError(\"MOM4_ZERO scheme requires parameter 'f4'.\")\n        alpha_lam = float(params['f4'])\n        alpha_m = float(params.get('alpha_m', 0.0))\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n    return {'alpha_m': alpha_m, 'alpha_lam': alpha_lam}\n\ndef evaluate_graph(graph: Graph, params: dict, scheme: str) - float:\n    \"\"\"\n    Evaluate the renormalized finite remainder of the graph under the specified scheme.\n    Uses the toy amplitude model and R'-operation for subdivergences.\n    \"\"\"\n    # Determine finite scheme parameters\n    alphas = scheme_postprocess(scheme, params)\n    alpha_m = alphas['alpha_m']\n    alpha_lam = alphas['alpha_lam']\n\n    # Tagging step (for completeness; not directly used in arithmetic except to validate)\n    uv_tags = graph.tag_uv_subgraphs()\n    # Proceed with evaluation based on topology\n    lam = float(params.get('lambda', 0.0))\n    if graph.type_tag == 'G4_1L':\n        # Requires f4\n        f4 = float(params['f4'])\n        # Finite remainder after counterterm: lam^2 * (f4 - alpha_lam)\n        result = lam**2 * (f4 - alpha_lam)\n        return float(result)\n    elif graph.type_tag == 'G2_1L':\n        # Requires f2 and m2\n        f2 = float(params['f2'])\n        m2 = float(params['m2'])\n        # Finite remainder after counterterm: lam * m2 * (f2 - alpha_m)\n        result = lam * m2 * (f2 - alpha_m)\n        return float(result)\n    elif graph.type_tag == 'G4_2L_db':\n        # Requires f4\n        f4 = float(params['f4'])\n        # Two identical one-loop 4-pt subdivergences, R'-subtracted:\n        # Finite remainder: lam^3 * (f4 - alpha_lam)^2\n        result = lam**3 * (f4 - alpha_lam)**2\n        return float(result)\n    else:\n        raise ValueError(f\"Unknown graph type: {graph.type_tag}\")\n\ndef build_graph(type_tag: str) - Graph:\n    \"\"\"\n    Construct a Graph instance with appropriate subgraphs for tagging purposes.\n    \"\"\"\n    if type_tag == 'G4_1L':\n        # One primitive 4-point one-loop subgraph\n        subgraphs = [Subgraph(E=E_FOUR_POINT, L=1, tag='G4_1L')]\n    elif type_tag == 'G2_1L':\n        # One primitive 2-point one-loop subgraph\n        subgraphs = [Subgraph(E=E_TWO_POINT, L=1, tag='G2_1L')]\n    elif type_tag == 'G4_2L_db':\n        # Two identical one-loop 4-point subdivergences\n        subgraphs = [\n            Subgraph(E=E_FOUR_POINT, L=1, tag='G4_1L'),\n            Subgraph(E=E_FOUR_POINT, L=1, tag='G4_1L'),\n        ]\n    else:\n        subgraphs = []\n    return Graph(type_tag=type_tag, subgraphs=subgraphs)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (graph_type, params dict, scheme string)\n    test_cases = [\n        # Test A: one-loop 4-point, MS\n        ('G4_1L', {'lambda': 0.1, 'f4': 1.25}, 'MS'),\n        # Test B: one-loop 2-point, custom alpha_m\n        ('G2_1L', {'lambda': 0.2, 'm2': 2.0, 'f2': 0.5, 'alpha_m': 0.75}, 'CUSTOM'),\n        # Test C: two-loop 4-point double-bubble, MOM4_ZERO\n        ('G4_2L_db', {'lambda': 0.3, 'f4': 0.8}, 'MOM4_ZERO'),\n        # Test D: one-loop 4-point, custom alpha_lam\n        ('G4_1L', {'lambda': 0.5, 'f4': 0.2, 'alpha_lam': -0.5}, 'CUSTOM'),\n    ]\n\n    results = []\n    for gtype, params, scheme in test_cases:\n        graph = build_graph(gtype)\n        res = evaluate_graph(graph, params, scheme)\n        # Ensure standard float formatting (not scientific) where reasonable\n        # Convert small -0.0 to 0.0\n        if abs(res) == 0.0:\n            res = 0.0\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Join without spaces, Python default str(float) formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3531050"}]}