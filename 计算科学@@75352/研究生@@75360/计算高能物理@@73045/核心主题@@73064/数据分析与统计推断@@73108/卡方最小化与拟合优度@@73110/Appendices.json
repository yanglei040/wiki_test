{"hands_on_practices": [{"introduction": "本练习将指导您从头开始实现一个加权线性最小二乘拟合。您将学习如何估计模型参数，评估拟合优度，以及至关重要的是，如何应用威尔克斯定理（Wilks' theorem）为拟合的参数构建置信区间和置信区域。这项实践构成了许多数据分析任务的基石。[@problem_id:3507420]", "problem": "考虑一系列具有高斯噪声和已知的、逐箱标准差的分箱测量值。设 $y_i$ 表示箱 $i$ 中的观测值，$\\sigma_i$ 表示箱 $i$ 中已知的标准差，$f(x_i;\\boldsymbol{\\theta})$ 是依赖于参数矢量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^k$ 的线性模型预测。在高斯噪声假设下，对数似然与加权最小二乘目标函数仅相差一个加性常数，最小化负对数似然等价于最小化加权残差平方和。将 $\\chi^2$ 目标函数表示为\n$$\n\\chi^2(\\boldsymbol{\\theta}) \\equiv \\sum_{i=1}^{N} \\frac{\\left(y_i - f(x_i;\\boldsymbol{\\theta})\\right)^2}{\\sigma_i^2}.\n$$\n设 $\\hat{\\boldsymbol{\\theta}}$ 是使 $\\chi^2(\\boldsymbol{\\theta})$ 最小化的参数矢量。最小值为 $\\chi^2_{\\min} = \\chi^2(\\hat{\\boldsymbol{\\theta}})$。模型的拟合优度可以通过将 $\\chi^2_{\\min}$ 与一个参考分布进行比较来评估，该参考分布由高斯模型和自由度（DoF）导出，对于具有满秩设计矩阵的线性模型，自由度定义为 $\\nu \\equiv N - k$。此外，威尔克斯定理指出，在标准正则性条件下和渐近情况下，差值\n$$\n\\Delta \\chi^2(\\boldsymbol{\\theta}) \\equiv \\chi^2(\\boldsymbol{\\theta}) - \\chi^2_{\\min}\n$$\n服从一个卡方随机变量分布，其自由度由受约束的参数数量（感兴趣的参数数量）给出，前提是讨厌参数被剖析（最小化）处理。这允许在参数空间中构建由 $\\Delta \\chi^2(\\boldsymbol{\\theta}) \\le q_\\alpha$ 定义的置信区域，其中 $q_\\alpha$ 是对应于置信水平 $\\alpha$ 和适当卡方分布的上尾分位数。\n\n任务。编写一个完整的、自包含的程序，该程序：\n- 实现加权线性最小二乘估计，以获得 $\\hat{\\boldsymbol{\\theta}}$、$\\chi^2_{\\min}$ 以及零假设（即数据由某个真实参数矢量下的模型描述）的拟合优度 $p$ 值，使用 $\\nu = N - k$ 的自由度和卡方参考分布。\n- 实现通过 $\\Delta \\chi^2$ 构建置信区域的威尔克斯定理方法，用于：\n  - 当所有参数都是感兴趣的参数时，在完整参数空间中的联合置信区域。\n  - 当其余参数被视为讨厌参数并进行最小时，为单个感兴趣的参数构建剖析置信区间。\n\n仅使用下面给出的数据集。所有量纲均为无量纲。不涉及角度。所有置信水平表示为 $[0,1]$ 范围内的小数。\n\n数据集和模型：\n- 情况 1（单参数模板拟合）：对于 $i \\in \\{1,\\dots,5\\}$，定义模板矢量 $t_i$ 为 $t = [1,2,3,4,5]$。模型为 $f_i(a) = a\\,t_i$，参数为 $a \\in \\mathbb{R}$。观测数据和不确定性为 $y = [1.1, 2.0, 2.9, 4.1, 4.9]$ 和 $\\sigma = [1,1,1,1,1]$。计算：\n  - 最佳拟合 $\\hat{a}$ 和使用 $\\nu = N - k = 5 - 1 = 4$ 的拟合优度 $p$ 值。\n  - 使用具有一个感兴趣参数的威尔克斯定理，通过检验 $\\Delta \\chi^2(a_0)$ 和 $\\Delta \\chi^2(a_1)$ 是否小于或等于对应于 1 自由度的卡方分位数，来确定固定值 $a_0 = 1.3$ 和 $a_1 = 1.1$ 是否分别位于 $\\alpha = 0.95$ 和 $\\alpha = 0.68$ 的置信区间内。\n- 情况 2（双参数加权线性模型）：设 $x = [-3,-2,-1,0,1,2,3,4]$，模型为 $f_i(a,b) = a + b\\,x_i$，参数为 $(a,b) \\in \\mathbb{R}^2$。观测数据和不确定性为 $y = [-0.7, 0.1, 0.6, 1.1, 1.6, 2.0, 2.7, 3.1]$ 和 $\\sigma = [0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2]$。计算：\n  - 最佳拟合 $(\\hat{a},\\hat{b})$ 和使用 $\\nu = N - k = 8 - 2 = 6$ 的拟合优度 $p$ 值。\n  - 使用具有两个感兴趣参数的威尔克斯定理构建联合区域，通过检验 $\\Delta \\chi^2(a,b)$ 是否小于或等于对应于 2 自由度的卡方分位数，来确定点 $(a,b) = (1.169, 0.527381)$ 和 $(a,b) = (1.209, 0.527381)$ 是否位于 $\\alpha = 0.90$ 的置信区域内。\n  - 使用具有一个感兴趣参数 $a$ 的剖析版威尔克斯定理（将 $b$ 视为待最小化的讨厌参数），通过检验剖析的 $\\Delta \\chi^2_{\\mathrm{prof}}(a)$ 是否小于或等于对应于 1 自由度的卡方分位数，来确定固定值 $a_2 = 1.169$ 和 $a_3 = 1.209$ 是否位于 $\\alpha = 0.95$ 的置信区间内。\n- 情况 3（具有异方差不确定性的单参数模板拟合）：对于 $i \\in \\{1,\\dots,6\\}$，定义模板矢量 $t = [1.0, 0.5, 2.0, 1.5, 3.0, 2.5]$。模型为 $f_i(a) = a\\,t_i$。观测数据和不确定性为 $y = [2.1, 1.0, 4.1, 2.9, 6.2, 5.1]$ 和 $\\sigma = [0.3, 0.2, 0.5, 0.4, 0.6, 0.5]$。计算：\n  - 最佳拟合 $\\hat{a}$ 和使用 $\\nu = N - k = 6 - 1 = 5$ 的拟合优度 $p$ 值。\n  - 使用具有一个感兴趣参数的威尔克斯定理，通过检验 $\\Delta \\chi^2(a)$ 是否小于或等于对应于 1 自由度的卡方分位数，来确定固定值 $a_4 = 2.2$ 和 $a_5 = 2.5$ 是否位于 $\\alpha = 0.99$ 的置信区间内。\n\n算法和统计要求：\n- 从独立分箱的高斯似然和 $\\chi^2(\\boldsymbol{\\theta})$ 的定义出发；推导线性模型的加权正规方程组，并使用带有对角权重矩阵 $W = \\mathrm{diag}(1/\\sigma_i^2)$ 的设计矩阵形式求解 $\\hat{\\boldsymbol{\\theta}}$。\n- 根据 $\\chi^2_{\\min}$ 和 $\\nu$ 自由度的卡方生存函数计算 $\\chi^2_{\\min}$ 和拟合优度 $p$ 值。\n- 对于任何候选参数矢量 $\\boldsymbol{\\theta}_0$，计算 $\\Delta \\chi^2(\\boldsymbol{\\theta}_0)$。对于剖析的单参数检验，通过加权正规方程组所蕴含的线性代数解析地对讨厌参数进行最小化。\n- 通过将 $\\Delta \\chi^2$ 与指定置信水平和自由度的卡方分位数进行比较，确定是否属于置信区域。\n\n测试套件和最终输出规范：\n- 严格使用以上三种情况作为测试套件。\n- 对于每种情况，按顺序返回一个包含以下元素的列表：\n  - 情况 1：$[\\hat{a}, p\\text{-value}, \\text{inside\\_C}0.95\\_a{=}1.3, \\text{inside\\_C}0.68\\_a{=}1.1]$。\n  - 情况 2：$[[\\hat{a}, \\hat{b}], p\\text{-value}, \\text{inside\\_C}0.90\\_{\\text{2D}}(1.169,0.527381), \\text{inside\\_C}0.90\\_{\\text{2D}}(1.209,0.527381), \\text{inside\\_C}0.95\\_{\\text{profile}}\\,a{=}1.169, \\text{inside\\_C}0.95\\_{\\text{profile}}\\,a{=}1.209]$。\n  - 情况 3：$[\\hat{a}, p\\text{-value}, \\text{inside\\_C}0.99\\_a{=}2.2, \\text{inside\\_C}0.99\\_a{=}2.5]$。\n- 将所有浮点数输出四舍五入到 $6$ 位小数。布尔值应为精确的逻辑值。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3]$）。输出行中不允许有额外的文本或空格。", "solution": "用户提供的问题是一个形式良好、关于线性统计建模的练习，具体涉及加权最小二乘估计和应用威尔克斯定理构建置信区域。问题陈述在科学上是合理的、自包含的，并且在算法上是可行的。因此，它被认为是有效的，并提供完整的解决方案。\n\n### 理论框架\n\n问题的核心是针对其参数为线性的模型，最小化卡方($\\chi^2$)目标函数。\n\n给定一组 $N$ 个数据点 $(x_i, y_i)$，其测量值 $y_i$ 的不确定性为 $\\sigma_i$，以及一个在 $k$ 个参数 $\\boldsymbol{\\theta} \\in \\mathbb{R}^k$ 上线性的模型函数 $f(x_i; \\boldsymbol{\\theta})$，我们可以用矩阵形式表示该模型：\n$$\n\\mathbb{E}[\\boldsymbol{y}] = \\boldsymbol{f}(\\boldsymbol{x}; \\boldsymbol{\\theta}) = A \\boldsymbol{\\theta}\n$$\n其中 $\\boldsymbol{y} = (y_1, \\dots, y_N)^T$ 是观测值矢量，$A$ 是 $N \\times k$ 的设计矩阵，$\\boldsymbol{\\theta} = (\\theta_1, \\dots, \\theta_k)^T$ 是参数矢量。设计矩阵的元素 $A_{ij}$ 是模型中第 $i$ 个数据点对应第 $j$ 个参数的系数。\n\n假设不确定性是独立的高斯分布，$\\chi^2$ 目标函数是加权残差平方和：\n$$\n\\chi^2(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left(\\frac{y_i - f(x_i; \\boldsymbol{\\theta})}{\\sigma_i}\\right)^2\n$$\n用矩阵表示法，这变成：\n$$\n\\chi^2(\\boldsymbol{\\theta}) = (\\boldsymbol{y} - A\\boldsymbol{\\theta})^T W (\\boldsymbol{y} - A\\boldsymbol{\\theta})\n$$\n其中 $W$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$。\n\n为了找到最小化 $\\chi^2$ 的参数矢量 $\\hat{\\boldsymbol{\\theta}}$，我们将 $\\chi^2(\\boldsymbol{\\theta})$ 对 $\\boldsymbol{\\theta}$ 的梯度设为零：\n$$\n\\nabla_{\\boldsymbol{\\theta}} \\chi^2(\\boldsymbol{\\theta}) = -2 A^T W \\boldsymbol{y} + 2 A^T W A \\boldsymbol{\\theta} = \\boldsymbol{0}\n$$\n这就得到了**正规方程组**：\n$$\n(A^T W A) \\boldsymbol{\\theta} = A^T W \\boldsymbol{y}\n$$\n假设设计矩阵 $A$ 具有满列秩，则矩阵 $A^T W A$ 是可逆的。$\\boldsymbol{\\theta}$ 的最佳拟合估计量为：\n$$\n\\hat{\\boldsymbol{\\theta}} = (A^T W A)^{-1} (A^T W \\boldsymbol{y})\n$$\n$\\chi^2$ 函数的最小值，记为 $\\chi^2_{\\min}$，是通过将 $\\hat{\\boldsymbol{\\theta}}$ 代回目标函数得到的：\n$$\n\\chi^2_{\\min} = \\chi^2(\\hat{\\boldsymbol{\\theta}}) = (\\boldsymbol{y} - A\\hat{\\boldsymbol{\\theta}})^T W (\\boldsymbol{y} - A\\hat{\\boldsymbol{\\theta}})\n$$\n在零假设（即数据是由模型 $f(x_i; \\boldsymbol{\\theta}_{\\text{true}})$ 为某个真实参数矢量 $\\boldsymbol{\\theta}_{\\text{true}}$ 生成的）下，统计量 $\\chi^2_{\\min}$ 服从自由度为 $\\nu = N - k$ 的卡方分布。拟合优度可以通过 $p$ 值来量化，即获得一个与观测到的 $\\chi^2_{\\min}$ 一样大或更大的值的概率。这可以通过 $\\chi^2(\\nu)$ 分布的生存函数（1 - CDF）来计算：\n$$\np\\text{-value} = P(\\chi^2_\\nu \\ge \\chi^2_{\\min}) = \\text{sf}(\\chi^2_{\\min}, \\nu)\n$$\n\n### 通过威尔克斯定理构建置信区域\n\n威尔克斯定理指出，统计量 $\\Delta\\chi^2(\\boldsymbol{\\theta}) \\equiv \\chi^2(\\boldsymbol{\\theta}) - \\chi^2_{\\min}$ 服从卡方分布。该分布的自由度 $d$ 等于被检验的感兴趣参数的数量。\n\n对于一组 $d$ 个参数，置信水平为 $\\alpha$ 的置信区域是所有满足以下条件的参数点 $\\boldsymbol{\\theta}_0$ 的集合：\n$$\n\\Delta\\chi^2(\\boldsymbol{\\theta}_0) \\le q_\\alpha\n$$\n其中 $q_\\alpha$ 是 $\\chi^2(d)$ 分布的上尾分位数，即 $P(\\chi^2_d \\le q_\\alpha) = \\alpha$。这个临界值可以通过百分点函数（逆CDF）找到。\n\n对于线性模型，可以推导出一个计算效率高的 $\\Delta\\chi^2$ 公式：\n$$\n\\Delta\\chi^2(\\boldsymbol{\\theta}_0) = (\\boldsymbol{\\theta}_0 - \\hat{\\boldsymbol{\\theta}})^T (A^T W A) (\\boldsymbol{\\theta}_0 - \\hat{\\boldsymbol{\\theta}})\n$$\n\n对于单个参数（例如 $\\theta_j$）的剖析置信区间，我们将其余 $k-1$ 个参数视为讨厌参数。对于每个固定的值 $\\theta_j = \\theta_{j,0}$，我们相对于讨厌参数最小化 $\\chi^2$。得到的剖析统计量 $\\Delta\\chi^2_{\\text{prof}}(\\theta_{j,0})$ 服从 $\\chi^2(1)$ 分布。对于线性模型，这可以简化为：\n$$\n\\Delta\\chi^2_{\\text{prof}}(\\theta_{j,0}) = \\frac{(\\theta_{j,0} - \\hat{\\theta}_j)^2}{C_{jj}}\n$$\n其中 $C = (A^T W A)^{-1}$ 是最小二乘估计量的协方差矩阵，而 $C_{jj}$ 是其第 $j$ 个对角元素（$\\hat{\\theta}_j$ 的方差）。\n\n### 算法实现策略\n\n将定义一个通用函数来解决加权线性最小二乘问题。该函数以设计矩阵 $A$、数据矢量 $\\boldsymbol{y}$ 和不确定性矢量 $\\boldsymbol{\\sigma}$ 作为输入。它计算并返回最佳拟合参数 $\\hat{\\boldsymbol{\\theta}}$、最小 $\\chi^2$、协方差矩阵 $C$ 和拟合优度 $p$ 值。然后，针对每种情况的特定函数将使用这些结果来执行所需的置信区域测试。\n\n#### 情况 1：单参数模板拟合\n- 模型：$f_i(a) = a\\,t_i$。\n- 参数：$\\boldsymbol{\\theta} = [a]$。\n- 设计矩阵：$A$ 是一个 $N \\times 1$ 的矩阵（列向量），由模板 $t$ 给出。\n- $N=5$, $k=1$, $\\nu=4$。对于置信区间检验，$d=1$。\n- 不确定性是同方差的（$\\sigma_i=1$），所以 $W=I$。\n\n#### 情况 2：双参数线性模型\n- 模型：$f_i(a,b) = a + b\\,x_i$。\n- 参数：$\\boldsymbol{\\theta} = [a, b]^T$。\n- 设计矩阵：$A$ 是一个 $N \\times 2$ 的矩阵，第一列全为 1，第二列为值 $x_i$。\n- $N=8$, $k=2$, $\\nu=6$。\n- 对于联合置信区域检验，我们使用 $\\Delta\\chi^2(\\boldsymbol{\\theta}_0)$，其中 $d=2$。\n- 对于 $a$ 的剖析置信区间，我们使用 $\\Delta\\chi^2_{\\text{prof}}(a_0)$，其中 $d=1$。\n\n#### 情况 3：异方差模板拟合\n- 模型：$f_i(a) = a\\,t_i$。\n- 参数：$\\boldsymbol{\\theta} = [a]$。\n- 设计矩阵：$A$ 是一个由模板 $t$ 给出的 $N \\times 1$ 矩阵。\n- $N=6$, $k=1$, $\\nu=5$。对于置信区间检验，$d=1$。\n- 不确定性是异方差的，所以权重矩阵 $W$ 是对角矩阵但不是单位矩阵的倍数。需要完整的加权最小二乘形式。\n\n每种情况的计算将使用 `numpy` 进行矩阵运算，并使用 `scipy.stats.chi2` 获取分位数和生存函数。所有浮点数结果将按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve_weighted_least_squares(A, y, sigma):\n    \"\"\"\n    Solves a weighted linear least-squares problem.\n    \n    Args:\n        A (np.ndarray): Design matrix (N x k).\n        y (np.ndarray): Observed data vector (N,).\n        sigma (np.ndarray): Uncertainties vector (N,).\n\n    Returns:\n        tuple: A tuple containing:\n            - theta_hat (np.ndarray): Best-fit parameters (k,).\n            - chi2_min (float): Minimum chi-squared value.\n            - C (np.ndarray): Covariance matrix of parameters (k x k).\n            - p_value (float): Goodness-of-fit p-value.\n    \"\"\"\n    N, k = A.shape\n    W = np.diag(1 / sigma**2)\n\n    # Normal equations: (A^T W A) theta = A^T W y\n    A_T_W_A = A.T @ W @ A\n    A_T_W_y = A.T @ W @ y\n    \n    # Covariance matrix and best-fit parameters\n    C = np.linalg.inv(A_T_W_A)\n    theta_hat = C @ A_T_W_y\n    \n    # Minimum chi-squared\n    residuals = y - A @ theta_hat\n    chi2_min = residuals.T @ W @ residuals\n    \n    # Goodness-of-fit p-value\n    dof = N - k\n    p_value = chi2.sf(chi2_min, df=dof)\n    \n    return theta_hat, chi2_min, C, p_value, A_T_W_A\n\ndef format_results(data):\n    \"\"\"\n    Recursively formats results, rounding floats and leaving booleans.\n    \"\"\"\n    if isinstance(data, list):\n        return [format_results(item) for item in data]\n    if isinstance(data, (float, np.floating)):\n        return round(data, 6)\n    return data\n\ndef solve_case1():\n    \"\"\"Calculates and returns results for Case 1.\"\"\"\n    y = np.array([1.1, 2.0, 2.9, 4.1, 4.9])\n    sigma = np.array([1.0, 1.0, 1.0, 1.0, 1.0])\n    t = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    A = t.reshape(-1, 1)\n\n    a_hat_vec, chi2_min, _, p_value, A_T_W_A = solve_weighted_least_squares(A, y, sigma)\n    a_hat = a_hat_vec[0]\n\n    # Confidence interval tests for a\n    def check_ci(a_test, alpha):\n        theta_test = np.array([a_test])\n        theta_hat = np.array([a_hat])\n        delta_chi2 = (theta_test - theta_hat).T @ A_T_W_A @ (theta_test - theta_hat)\n        q_alpha = chi2.ppf(alpha, df=1)\n        return delta_chi2 = q_alpha\n\n    inside_c095_a13 = check_ci(1.3, 0.95)\n    inside_c068_a11 = check_ci(1.1, 0.68)\n    \n    return [a_hat, p_value, inside_c095_a13, inside_c068_a11]\n\ndef solve_case2():\n    \"\"\"Calculates and returns results for Case 2.\"\"\"\n    x = np.array([-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0])\n    y = np.array([-0.7, 0.1, 0.6, 1.1, 1.6, 2.0, 2.7, 3.1])\n    sigma = np.array([0.2] * 8)\n    A = np.vstack([np.ones_like(x), x]).T\n\n    theta_hat, chi2_min, C, p_value, A_T_W_A = solve_weighted_least_squares(A, y, sigma)\n\n    # Joint confidence region tests (d=2)\n    def check_joint_cr(theta_test, alpha):\n        delta_chi2 = (theta_test - theta_hat).T @ A_T_W_A @ (theta_test - theta_hat)\n        q_alpha = chi2.ppf(alpha, df=2)\n        return delta_chi2 = q_alpha\n\n    pt1 = np.array([1.169, 0.527381])\n    pt2 = np.array([1.209, 0.527381])\n    inside_cr90_pt1 = check_joint_cr(pt1, 0.90)\n    inside_cr90_pt2 = check_joint_cr(pt2, 0.90)\n\n    # Profiled confidence interval tests for a (d=1)\n    def check_profiled_ci(a_test, alpha):\n        delta_chi2_prof = (a_test - theta_hat[0])**2 / C[0, 0]\n        q_alpha = chi2.ppf(alpha, df=1)\n        return delta_chi2_prof = q_alpha\n\n    inside_ci95_a1169 = check_profiled_ci(1.169, 0.95)\n    inside_ci95_a1209 = check_profiled_ci(1.209, 0.95)\n\n    return [list(theta_hat), p_value, inside_cr90_pt1, inside_cr90_pt2, inside_ci95_a1169, inside_ci95_a1209]\n\ndef solve_case3():\n    \"\"\"Calculates and returns results for Case 3.\"\"\"\n    t = np.array([1.0, 0.5, 2.0, 1.5, 3.0, 2.5])\n    y = np.array([2.1, 1.0, 4.1, 2.9, 6.2, 5.1])\n    sigma = np.array([0.3, 0.2, 0.5, 0.4, 0.6, 0.5])\n    A = t.reshape(-1, 1)\n\n    a_hat_vec, chi2_min, _, p_value, A_T_W_A = solve_weighted_least_squares(A, y, sigma)\n    a_hat = a_hat_vec[0]\n\n    # Confidence interval tests for a\n    def check_ci(a_test, alpha):\n        theta_test = np.array([a_test])\n        theta_hat = np.array([a_hat])\n        delta_chi2 = (theta_test - theta_hat).T @ A_T_W_A @ (theta_test - theta_hat)\n        q_alpha = chi2.ppf(alpha, df=1)\n        return delta_chi2 = q_alpha\n\n    inside_c099_a22 = check_ci(2.2, 0.99)\n    inside_c099_a25 = check_ci(2.5, 0.99)\n    \n    return [a_hat, p_value, inside_c099_a22, inside_c099_a25]\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final output.\n    \"\"\"\n    result1 = solve_case1()\n    result2 = solve_case2()\n    result3 = solve_case3()\n\n    all_results = [\n        format_results(result1),\n        format_results(result2),\n        format_results(result3)\n    ]\n    \n    # Use str() to handle nested lists and booleans correctly\n    # and replace spaces for compactness\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3507420"}, {"introduction": "虽然标准的卡方最小化方法在适定问题中表现良好，但许多现实场景（如探测器展开）本质上是不适定的，数据中的微小统计涨落可能导致解出现巨大的、非物理的振荡。本练习将介绍吉洪诺夫正则化（Tikhonov regularization）这一强大技术，它通过增加一个惩罚项来稳定解，使您能够从原本棘手的问题中提取有意义的结果。[@problem_id:3507369]", "problem": "考虑一个在计算高能物理中典型的探测器展开线性反问题，其中一个真实的分箱谱 $t \\in \\mathbb{R}^{M}$ 通过一个已知的响应矩阵 $R \\in \\mathbb{R}^{N \\times M}$ 和加性计数涨落映射到观测到的分箱计数 $d \\in \\mathbb{R}^{N}$。假设测量误差服从高斯分布，其对角协方差已知，为 $V = \\mathrm{diag}(\\sigma_1^2,\\ldots,\\sigma_N^2)$。定义加权数据保真度项\n$$\n\\chi^2_{\\mathrm{data}}(t) = (d - R t)^{\\top} V^{-1} (d - R t).\n$$\n为正则化此潜在的不适定问题，考虑Tikhonov型二次惩罚项\n$$\n\\mathcal{P}_k(t) = \\| L_k t \\|_2^2,\n$$\n其中 $L_k$ 是一个 $k$ 阶离散线性算子 ($k \\in \\{0,1,2\\}$)，定义如下：\n- 对于 $k = 0$：$L_0 = I_M$（$M \\times M$ 单位矩阵）。\n- 对于 $k = 1$：$L_1 \\in \\mathbb{R}^{(M-1) \\times M}$ 是一阶差分算子，其第 $i$ 行在第 $i$ 列的元素为 $-1$，在第 $i+1$ 列的元素为 $+1$，其余元素为零，其中 $i \\in \\{1,\\ldots,M-1\\}$。\n- 对于 $k = 2$：$L_2 \\in \\mathbb{R}^{(M-2) \\times M}$ 是二阶差分算子，其第 $i$ 行在第 $i$ 列的元素为 $+1$，在第 $i+1$ 列的元素为 $-2$，在第 $i+2$ 列的元素为 $+1$，其余元素为零，其中 $i \\in \\{1,\\ldots,M-2\\}$。\n\n对于给定的非负正则化强度 $\\lambda \\ge 0$，定义带惩罚的目标函数\n$$\n\\chi^2_{\\mathrm{reg}}(t;\\lambda,k) = \\chi^2_{\\mathrm{data}}(t) + \\lambda \\, \\mathcal{P}_k(t).\n$$\n\n给定以下实例，其中 $N = 6$ 且 $M = 5$：\n- 响应矩阵 $R \\in \\mathbb{R}^{6 \\times 5}$：\n$$\nR =\n\\begin{pmatrix}\n0.60  0.25  0.05  0.00  0.00 \\\\\n0.30  0.50  0.15  0.02  0.00 \\\\\n0.08  0.20  0.55  0.15  0.02 \\\\\n0.02  0.04  0.20  0.60  0.14 \\\\\n0.00  0.01  0.05  0.18  0.60 \\\\\n0.00  0.00  0.00  0.05  0.24 \\\\\n\\end{pmatrix}.\n$$\n- 观测计数 $d \\in \\mathbb{R}^6$：\n$$\nd = \\begin{pmatrix} 120 \\\\ 150 \\\\ 160 \\\\ 140 \\\\ 90 \\\\ 30 \\end{pmatrix}.\n$$\n- 标准差 $\\sigma \\in \\mathbb{R}^6$（$V$的对角不确定度）：\n$$\n\\sigma = \\begin{pmatrix} 11.0 \\\\ 12.2 \\\\ 12.6 \\\\ 11.8 \\\\ 9.5 \\\\ 5.6 \\end{pmatrix}.\n$$\n\n任务：\n1. 对下述每个指定的测试用例 $(\\lambda, k)$，计算 $\\chi^2_{\\mathrm{reg}}(t;\\lambda,k)$ 在 $t \\in \\mathbb{R}^M$ 上的最小化子 $\\hat{t}(\\lambda,k)$。\n2. 对每个 $\\hat{t}(\\lambda,k)$，计算数据空间残差卡方（不包括惩罚项），\n$$\n\\chi^2_{\\mathrm{data}}(\\hat{t}) = (d - R \\hat{t})^{\\top} V^{-1} (d - R \\hat{t}).\n$$\n3. 对每个 $\\hat{t}(\\lambda,k)$，计算广义有效自由度\n$$\n\\nu_{\\mathrm{eff}}(\\lambda,k) = N - \\mathrm{tr}(S_{\\lambda,k}),\n$$\n其中影响矩阵（也称帽子矩阵）$S_{\\lambda,k}$ 定义为\n$$\nS_{\\lambda,k} = R \\left(R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k\\right)^{-1} R^{\\top} V^{-1}.\n$$\n4. 使用 $\\chi^2_{\\mathrm{data}}(\\hat{t})$ 和 $\\nu_{\\mathrm{eff}}(\\lambda,k)$，在自由度为 $\\nu_{\\mathrm{eff}}(\\lambda,k)$ 的卡方分布下，计算上尾概率（拟合优度p值），\n$$\np = \\mathbb{P}\\left(\\chi^2 \\ge \\chi^2_{\\mathrm{data}}(\\hat{t}) \\, ; \\, \\nu_{\\mathrm{eff}}(\\lambda,k)\\right).\n$$\n将 $\\nu_{\\mathrm{eff}}(\\lambda,k)$ 视为实值自由度参数。\n\n测试套件：\n- 用例 1：$(\\lambda, k) = (0, 2)$。\n- 用例 2：$(\\lambda, k) = (1, 0)$。\n- 用例 3：$(\\lambda, k) = (10, 1)$。\n- 用例 4：$(\\lambda, k) = (10^{3}, 2)$。\n\n您的程序必须：\n- 对指定的 $R$、$d$ 和 $\\sigma$ 精确实现上述计算。\n- 对每个测试用例，输出一个包含三个浮点数的列表 $[\\chi^2_{\\mathrm{data}}(\\hat{t}), \\nu_{\\mathrm{eff}}(\\lambda,k), p]$，每个浮点数四舍五入到6位小数。\n- 将所有测试用例的结果汇总到单行输出中，该输出包含一个Python风格的列表，其中每个元素是对应测试用例的列表，并按测试套件的顺序排列，例如 $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],\\ldots]$。\n\n不涉及物理单位。不出现角度。所有数值答案必须是指定格式的浮点数。", "solution": "用户提供的问题是计算物理学中一个明确定义的任务，特别是在反问题和数据分析领域。它涉及求解一个线性系统的正则化解并评估其统计特性。该问题具有科学依据，是适定、客观和完整的。所有必需的数据、矩阵、向量和公式都已提供，没有内部矛盾或歧义。因此，该问题是有效的，可以推导出解决方案。\n\n问题的核心是对于给定的正则化参数 $\\lambda \\ge 0$ 和正则化阶数 $k \\in \\{0, 1, 2\\}$，找到最小化带惩罚的卡方目标函数的向量 $t \\in \\mathbb{R}^{M}$。目标函数定义为：\n$$\n\\chi^2_{\\mathrm{reg}}(t;\\lambda,k) = \\chi^2_{\\mathrm{data}}(t) + \\lambda \\, \\mathcal{P}_k(t)\n$$\n第一项 $\\chi^2_{\\mathrm{data}}(t)$ 量化了解对观测数据 $d$ 的保真度。其公式为：\n$$\n\\chi^2_{\\mathrm{data}}(t) = (d - R t)^{\\top} V^{-1} (d - R t)\n$$\n这里，$R$ 是响应矩阵，$d$ 是观测计数的向量，$V$ 是测量误差的对角协方差矩阵，其中 $V_{ii} = \\sigma_i^2$。\n\n第二项 $\\mathcal{P}_k(t)$ 是一个Tikhonov型正则化惩罚项，它包含了关于真实向量 $t$ 平滑性的先验信念。其定义为：\n$$\n\\mathcal{P}_k(t) = \\| L_k t \\|_2^2 = t^{\\top} L_k^{\\top} L_k t\n$$\n其中 $L_k$ 是一个近似 $k$ 阶导数的离散线性算子。\n\n为了找到 $\\chi^2_{\\mathrm{reg}}(t)$ 的最小化子 $\\hat{t}$，我们必须找到其关于 $t$ 的梯度为零的点。目标函数可以展开为：\n$$\n\\chi^2_{\\mathrm{reg}}(t) = (d^{\\top} - t^{\\top}R^{\\top}) V^{-1} (d - R t) + \\lambda t^{\\top} L_k^{\\top} L_k t = d^{\\top}V^{-1}d - 2 t^{\\top} R^{\\top} V^{-1} d + t^{\\top} R^{\\top} V^{-1} R t + \\lambda t^{\\top} L_k^{\\top} L_k t\n$$\n关于 $t$ 的梯度是：\n$$\n\\nabla_t \\chi^2_{\\mathrm{reg}}(t) = -2 R^{\\top} V^{-1} d + 2 R^{\\top} V^{-1} R t + 2 \\lambda L_k^{\\top} L_k t\n$$\n将梯度设为零，$\\nabla_t \\chi^2_{\\mathrm{reg}}(\\hat{t}) = 0$，得到线性方程组：\n$$\n(R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k) \\hat{t} = R^{\\top} V^{-1} d\n$$\n这是Tikhonov正则化的标准正规方程组。最小化子 $\\hat{t}(\\lambda,k)$ 可通过求解此方程组得到。令 $A = R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k$ 且 $b = R^{\\top} V^{-1} d$。问题简化为求解 $M \\times M$ 系统 $A \\hat{t} = b$。对于 $\\lambda  0$，或者当 $\\lambda=0$ 且 $R^{\\top}V^{-1}R$ 可逆时（在本问题中成立，因为 $R$ 是列满秩的），该系统有唯一解。\n\n每个测试用例 $(\\lambda, k)$ 的计算步骤如下：\n\n1.  **构造矩阵**：\n    - 问题提供了 $d \\in \\mathbb{R}^6$，$R \\in \\mathbb{R}^{6 \\times 5}$ 和 $\\sigma \\in \\mathbb{R}^6$ 的数值。\n    - 逆协方差矩阵 $V^{-1}$ 是一个对角矩阵，其元素为 $(V^{-1})_{ii} = 1/\\sigma_i^2$。\n    - 矩阵 $L_k \\in \\mathbb{R}^{D \\times M}$（其中 $D$ 取决于 $k$）根据阶数 $k$ 为 $M=5$ 构造：\n        - 对于 $k=0$，$L_0 = I_5$ 是 $5 \\times 5$ 的单位矩阵。\n        - 对于 $k=1$，$L_1$ 是 $4 \\times 5$ 的一阶差分矩阵。\n        - 对于 $k=2$，$L_2$ 是 $3 \\times 5$ 的二阶差分矩阵。\n\n2.  **求解最小化子 $\\hat{t}(\\lambda,k)$**：\n    - 构造矩阵 $A = R^{\\top}V^{-1}R + \\lambda L_k^{\\top}L_k$。\n    - 构造向量 $b = R^{\\top}V^{-1}d$。\n    - 求解线性系统 $A \\hat{t} = b$ 以得到 $\\hat{t}$。\n\n3.  **计算数据空间卡方 $\\chi^2_{\\mathrm{data}}(\\hat{t})$**：\n    - 利用解 $\\hat{t}$，计算残差向量 $r = d - R \\hat{t}$。\n    - 计算 $\\chi^2_{\\mathrm{data}}(\\hat{t}) = r^{\\top} V^{-1} r = \\sum_{i=1}^{N} (r_i^2 / \\sigma_i^2)$。\n\n4.  **计算有效自由度 $\\nu_{\\mathrm{eff}}(\\lambda,k)$**：\n    - 首先，计算影响矩阵 $S_{\\lambda,k}$：\n      $$\n      S_{\\lambda,k} = R \\left(R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k\\right)^{-1} R^{\\top} V^{-1}\n      $$\n    - 有效自由度随后是衡量拟合后数据变化自由程度的指标：\n      $$\n      \\nu_{\\mathrm{eff}}(\\lambda,k) = N - \\mathrm{tr}(S_{\\lambda,k})\n      $$\n      其中 $N=6$ 是数据点的数量，$\\mathrm{tr}(\\cdot)$ 是矩阵的迹。这里，$\\mathrm{tr}(S_{\\lambda,k})$ 是拟合所消耗的有效参数数量。\n\n5.  **计算拟合优度p值**：\n    - $p$值计算为具有 $\\nu_{\\mathrm{eff}}$ 自由度的卡方分布的上尾概率：\n      $$\n      p = \\mathbb{P}\\left(\\chi^2 \\ge \\chi^2_{\\mathrm{data}}(\\hat{t}) \\, ; \\, \\nu_{\\mathrm{eff}}(\\lambda,k)\\right)\n      $$\n    - 这对应于在自由度为 $\\nu_{\\mathrm{eff}}(\\lambda,k)$ 的情况下，在 $\\chi^2_{\\mathrm{data}}(\\hat{t})$ 处求值的 $\\chi^2$ 分布的生存函数（1 - CDF）。\n\n对四个指定的测试用例中的每一个都执行此计算序列。然后将结果 $[\\chi^2_{\\mathrm{data}}(\\hat{t}), \\nu_{\\mathrm{eff}}(\\lambda,k), p]$ 收集并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the Tikhonov-regularized unfolding problem for a series of test cases.\n    \"\"\"\n    \n    # Define the problem data as specified\n    R = np.array([\n        [0.60, 0.25, 0.05, 0.00, 0.00],\n        [0.30, 0.50, 0.15, 0.02, 0.00],\n        [0.08, 0.20, 0.55, 0.15, 0.02],\n        [0.02, 0.04, 0.20, 0.60, 0.14],\n        [0.00, 0.01, 0.05, 0.18, 0.60],\n        [0.00, 0.00, 0.00, 0.05, 0.24]\n    ])\n\n    d = np.array([120., 150., 160., 140., 90., 30.])\n    \n    sigma = np.array([11.0, 12.2, 12.6, 11.8, 9.5, 5.6])\n\n    N, M = R.shape\n\n    # Construct the inverse covariance matrix V^{-1}\n    V_inv = np.diag(1 / sigma**2)\n\n    # Define the test cases\n    test_cases = [\n        (0, 2),\n        (1, 0),\n        (10, 1),\n        (1000, 2),\n    ]\n\n    all_results = []\n\n    for lambda_val, k_val in test_cases:\n        # Step 1: Construct the regularization operator L_k\n        if k_val == 0:\n            # k=0: L_0 = I_M\n            L_k = np.identity(M)\n        elif k_val == 1:\n            # k=1: First-difference operator\n            L_k = np.zeros((M - 1, M))\n            for i in range(M - 1):\n                L_k[i, i] = -1.0\n                L_k[i, i + 1] = 1.0\n        elif k_val == 2:\n            # k=2: Second-difference operator\n            L_k = np.zeros((M - 2, M))\n            for i in range(M - 2):\n                L_k[i, i] = 1.0\n                L_k[i, i + 1] = -2.0\n                L_k[i, i + 2] = 1.0\n        \n        # Pre-compute parts of the normal equations\n        RT_Vinv = R.T @ V_inv\n        RT_Vinv_R = RT_Vinv @ R\n        Lk_T_Lk = L_k.T @ L_k\n\n        # Step 2: Solve for the minimizer t_hat\n        A_matrix = RT_Vinv_R + lambda_val * Lk_T_Lk\n        b_vector = RT_Vinv @ d\n        t_hat = np.linalg.solve(A_matrix, b_vector)\n\n        # Step 3: Compute data-space residual chi-squared\n        residuals = d - R @ t_hat\n        chi2_data = residuals.T @ V_inv @ residuals\n\n        # Step 4: Compute effective degrees of freedom\n        # Note: A_matrix_inv = (R'V^{-1}R + lambda*L'L)^{-1}\n        A_matrix_inv = np.linalg.inv(A_matrix)\n        S_matrix = R @ A_matrix_inv @ RT_Vinv\n        nu_eff = N - np.trace(S_matrix)\n\n        # Step 5: Compute the goodness-of-fit p-value\n        p_value = chi2.sf(chi2_data, nu_eff)\n\n        # Store the results rounded to 6 decimal places\n        case_results = [\n            round(chi2_data, 6),\n            round(nu_eff, 6),\n            round(p_value, 6)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    # Creates strings like '[1.0,2.0,3.0]' for each case\n    results_as_strs = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    \n    # Joins these strings into the final format '[[...],[...]]'\n    final_output = f\"[{','.join(results_as_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3507369"}, {"introduction": "为置信区间构建提供了简洁方法的威尔克斯定理依赖于渐近假设，而这些假设在小样本情况下或当参数接近物理边界时可能会失效。本练习将通过一个实例展示这种失效情况，并教您如何使用“玩具”蒙特卡洛（toy Monte Carlo）模拟来经验性地确定检验统计量的真实分布，从而即使在标准理论不适用时也能构建出统计上可靠的、经过校准的置信区间。[@problem_id:3507406]", "problem": "考虑一个用于分箱截面测量的单参数有效场论（EFT）模板，其不确定度为高斯分布。设第 $i$ 个数据箱的预测均值为 $m_i(\\theta) = b_i + s_i \\,\\theta$，其中数据箱索引为 $i = 1, \\dots, N_{\\mathrm{bins}}$，$\\theta \\ge 0$ 是一个无量纲的EFT耦合系数，其物理边界约束为零，$b_i, s_i$ 分别为已知的各箱的本底和信号模板。观测数据为 $x_i$，建模为独立的、均值为 $m_i(\\theta_{\\mathrm{true}})$、已知标准差为 $\\sigma_i$ 的高斯随机变量。对于给定的 $\\theta$ 和观测值 $x$，定义卡方函数为\n$$\n\\chi^2(\\theta; x) \\;=\\; \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{\\left(x_i - b_i - s_i \\,\\theta\\right)^2}{\\sigma_i^2}.\n$$\n剖析最佳拟合值 $\\hat{\\theta}$ 是在物理边界 $\\theta \\ge 0$ 的约束下，最小化 $\\chi^2(\\theta;x)$ 的值。对于一个零假设参数值 $\\theta_0$，似然比检验统计量是剖析差值\n$$\n\\Delta \\chi^2(\\theta_0; x) \\;=\\; \\chi^2(\\theta_0; x) \\;-\\; \\min_{\\theta \\ge 0} \\chi^2(\\theta; x).\n$$\n在满足正则性条件的渐近情况下，威尔克斯定理指出，对于单个参数，$\\Delta \\chi^2$ 服从自由度为1的卡方分布。然而，在小样本量以及当参数位于物理边界附近时，该渐近预测可能会失效。您的任务是利用“玩具”蒙特卡洛（toy Monte Carlo）方法，经验性地研究威尔克斯定理的有效性，并定义校正后的置信区域。\n\n从第一性原理和核心定义出发，实现以下步骤：\n- 模型设定：使用 $N_{\\mathrm{bins}} = 3$，以及无量纲数组 $b = [10.0,12.0,8.0]$、$s = [4.0,6.0,3.0]$ 和 $\\sigma = [3.2,3.5,3.0]$。这些参数在所有测试中保持不变。\n- 估计：对于任何观测值 $x$，在 $\\theta \\ge 0$ 的范围内最小化 $\\chi^2(\\theta;x)$ 以获得 $\\hat{\\theta}$ 和 $\\chi^2_{\\min}(x) = \\chi^2(\\hat{\\theta}; x)$。\n- 检验统计量：对于给定的 $\\theta_0$，计算 $\\Delta \\chi^2(\\theta_0;x)$。\n- 覆盖率研究（威尔克斯）：对于每种测试情况，通过从均值为 $m_i(\\theta_{\\mathrm{true}})$、标准差为 $\\sigma_i$ 的高斯分布中抽取每个 $x_i^{(t)}$，生成 $N_{\\mathrm{toys}}$ 个独立的“玩具”样本 $x^{(t)}$。为每个“玩具”样本计算 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x^{(t)})$。使用自由度为1的卡方分布的理论95%分位数 $q_{0.95}^{(\\chi^2_1)}$，计算经验覆盖率，即满足 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x^{(t)}) \\le q_{0.95}^{(\\chi^2_1)}$ 的“玩具”样本所占的比例。将覆盖率表示为小数。\n- 拟合优度有效性检查：使用 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x)$ 的“玩具”样本分布，与自由度为1的$\\chi^2$分布的累积分布函数进行柯尔莫哥洛夫-斯米尔诺夫（Kolmogorov–Smirnov，KS）检验。报告KS检验在0.05显著性水平上是否未能拒绝威尔克斯假设；返回一个布尔值。\n- 校正后的置信阈值：将校正后的95%阈值 $q_{0.95}^{\\mathrm{corr}}$ 定义为“玩具”样本 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x)$ 分布的经验95百分位数。\n- 置信区间构建：对于每种测试情况下的单个观测数据集 $\\tilde{x}$，构建基于威尔克斯定理的和校正后的95%置信区间，该区间为满足 $\\chi^2(\\theta; \\tilde{x}) \\le \\chi^2_{\\min}(\\tilde{x}) + q$ 的 $\\theta \\ge 0$ 集合，其中 $q \\in \\{q_{0.95}^{(\\chi^2_1)}, q_{0.95}^{\\mathrm{corr}}\\}$。以无量纲耦合单位的浮点数形式报告区间端点。\n\n使用以下测试套件（每种情况均使用无量纲单位）：\n- 情况1（边界）：$\\theta_{\\mathrm{true}} = 0.0$，$N_{\\mathrm{toys}} = 10000$，“玩具”样本随机种子 $12345$，“观测”数据集种子 $54321$。\n- 情况2（近边界）：$\\theta_{\\mathrm{true}} = 0.05$，$N_{\\mathrm{toys}} = 10000$，“玩具”样本随机种子 $23456$，“观测”数据集种子 $65432$。\n- 情况3（内部）：$\\theta_{\\mathrm{true}} = 0.5$，$N_{\\mathrm{toys}} = 10000$，“玩具”样本随机种子 $34567$，“观测”数据集种子 $76543$。\n\n您的程序应为每种情况计算：\n1. 使用 $q_{0.95}^{(\\chi^2_1)}$ 计算的经验覆盖率（小数值）。\n2. 校正后的阈值 $q_{0.95}^{\\mathrm{corr}}$（浮点数）。\n3. KS检验的决策，以布尔值表示在0.05水平上是否未拒绝威尔克斯假设。\n4. 基于威尔克斯定理的观测数据集置信区间端点 $(\\theta_{\\mathrm{low}}^{\\mathrm{Wilks}}, \\theta_{\\mathrm{high}}^{\\mathrm{Wilks}})$。\n5. 校正后的观测数据集置信区间端点 $(\\theta_{\\mathrm{low}}^{\\mathrm{corr}}, \\theta_{\\mathrm{high}}^{\\mathrm{corr}})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个包含三个内部列表的列表（每个测试用例一个）。每个内部列表必须严格按以下顺序包含七个条目：\n$$\n\\left[\\mathrm{coverage},\\; q_{0.95}^{\\mathrm{corr}},\\; \\mathrm{KS\\_pass},\\; \\theta_{\\mathrm{low}}^{\\mathrm{Wilks}},\\; \\theta_{\\mathrm{high}}^{\\mathrm{Wilks}},\\; \\theta_{\\mathrm{low}}^{\\mathrm{corr}},\\; \\theta_{\\mathrm{high}}^{\\mathrm{corr}}\\right].\n$$\n例如，程序应打印一个形如\n$$\n\\left[ [c_1,q_1,p_1,w\\ell_1,wh_1,cl_1,ch_1], [c_2,q_2,p_2,w\\ell_2,wh_2,cl_2,ch_2], [c_3,q_3,p_3,w\\ell_3,wh_3,cl_3,ch_3] \\right],\n$$\n的字符串，其中数值条目为无量纲单位，KS决策为布尔值。不应打印任何额外文本。", "solution": "该问题要求对一个由单参数有效场论（EFT）模型描述的分箱截面测量进行全面的统计分析。核心任务包括通过卡方最小化进行参数估计，使用“玩具”蒙特卡洛模拟评估威尔克斯定理的有效性，以及构建校正后的置信区间。\n\n### 1. 数学模型与$\\chi^2$函数\n\n第$i$个数据箱中的预测事件数由EFT耦合参数 $\\theta$ 的线性函数给出：\n$$\nm_i(\\theta) = b_i + s_i \\theta\n$$\n其中 $b_i$ 是本底预测，$s_i$ 是来自EFT算符的信号缩放因子，$\\theta$ 是我们感兴趣的参数。施加了物理约束 $\\theta \\ge 0$。假设每个数据箱中的观测数据 $x_i$ 服从独立的、均值为 $m_i(\\theta_{\\mathrm{true}})$、已知标准差为 $\\sigma_i$ 的高斯分布。\n\n$\\chi^2$ 函数在此模型中充当负对数似然（相差一个常数），其定义为：\n$$\n\\chi^2(\\theta; x) = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{\\left(x_i - m_i(\\theta)\\right)^2}{\\sigma_i^2} = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{\\left(x_i - b_i - s_i \\theta\\right)^2}{\\sigma_i^2}\n$$\n该函数是关于 $\\theta$ 的二次函数，可以展开为 $\\chi^2(\\theta) = A\\theta^2 - 2B\\theta + C$ 的形式，其中系数 $A$、$B$ 和 $C$ 是数据 $x$ 和固定模板的函数：\n$$\nA = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{s_i^2}{\\sigma_i^2}\n$$\n$$\nB = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{s_i(x_i - b_i)}{\\sigma_i^2}\n$$\n$$\nC = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{(x_i - b_i)^2}{\\sigma_i^2}\n$$\n由于 $A  0$，该抛物线开口向上，保证了存在唯一的全局最小值。\n\n### 2. 最佳拟合参数估计\n\n为了找到最小化 $\\chi^2(\\theta; x)$ 的 $\\theta$ 值，我们首先通过将其导数设为零来找到无约束的最小值：\n$$\n\\frac{d\\chi^2}{d\\theta} = 2A\\theta - 2B = 0\n$$\n这得到了无约束的最佳拟合值，记为 $\\theta_{\\mathrm{uc}}$：\n$$\n\\theta_{\\mathrm{uc}}(x) = \\frac{B}{A} = \\frac{\\sum_i s_i(x_i - b_i)/\\sigma_i^2}{\\sum_i s_i^2/\\sigma_i^2}\n$$\n然而，问题指定了物理边界 $\\theta \\ge 0$。剖析最佳拟合估计值 $\\hat{\\theta}$ 是在允许区域内使 $\\chi^2$ 最小化的 $\\theta$ 值。其计算方法如下：\n$$\n\\hat{\\theta}(x) = \\max(0, \\theta_{\\mathrm{uc}}(x))\n$$\n如果无约束最小值 $\\theta_{\\mathrm{uc}}$ 是物理的（即非负），那么它就是解。如果 $\\theta_{\\mathrm{uc}}$ 为负，则物理区域 $\\theta \\ge 0$ 内的最小值位于边界上，即 $\\hat{\\theta} = 0$。对于给定的数据集 $x$，$\\chi^2$ 的最小值为 $\\chi^2_{\\min}(x) = \\chi^2(\\hat{\\theta}(x); x)$。\n\n### 3. 似然比检验统计量\n\n对于一个零假设 $\\theta_0$，检验统计量是剖析似然比，表示为 $\\chi^2$ 值的差：\n$$\n\\Delta \\chi^2(\\theta_0; x) = \\chi^2(\\theta_0; x) - \\chi^2_{\\min}(x) = \\chi^2(\\theta_0; x) - \\chi^2(\\hat{\\theta}; x)\n$$\n这可以被高效地计算。通过配方法，我们可以将 $\\chi^2(\\theta)$ 写成 $\\chi^2(\\theta) = A(\\theta - \\theta_{\\mathrm{uc}})^2 + \\chi^2(\\theta_{\\mathrm{uc}})$。将此代入 $\\Delta\\chi^2$ 的定义中，得到：\n$$\n\\Delta \\chi^2(\\theta_0; x) = \\left[A(\\theta_0 - \\theta_{\\mathrm{uc}})^2 + \\chi^2(\\theta_{\\mathrm{uc}})\\right] - \\left[A(\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 + \\chi^2(\\theta_{\\mathrm{uc}})\\right] = A \\left[ (\\theta_0 - \\theta_{\\mathrm{uc}})^2 - (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 \\right]\n$$\n这种形式在计算上是高效的，因为它避免了重新计算完整的 $\\chi^2$ 求和。\n\n### 4. 蒙特卡洛模拟与覆盖率研究\n\n威尔克斯定理指出，在某些正则性条件下，$\\Delta\\chi^2(\\theta_{\\mathrm{true}}; x)$ 统计量渐近服从自由度为1的卡方分布（$\\chi^2_1$）。当真实参数值 $\\theta_{\\mathrm{true}}$ 位于参数空间的边界上时，这些条件不被满足。我们使用“玩具”蒙特卡洛模拟来研究这一点。\n\n对于由 $\\theta_{\\mathrm{true}}$ 定义的每种测试情况：\n1.  通过从高斯分布 $\\mathcal{N}(m_i(\\theta_{\\mathrm{true}}), \\sigma_i^2)$ 中抽取每个数据箱的值 $x_i^{(t)}$，生成 $N_{\\mathrm{toys}}$ 个伪数据集（“玩具”样本）$x^{(t)}$。\n2.  对于每个“玩具”样本 $x^{(t)}$，计算 $\\theta_{\\mathrm{uc}}(x^{(t)})$、$\\hat{\\theta}(x^{(t)})$ 和检验统计量 $\\Delta\\chi^2_t = \\Delta\\chi^2(\\theta_{\\mathrm{true}}; x^{(t)})$。\n3.  这 $N_{\\mathrm{toys}}$ 个 $\\Delta\\chi^2_t$ 值的集合构成了该检验统计量的经验概率分布。\n\n经验覆盖率是指真实参数值被包含在名义95%置信区间内的“玩具”样本所占的比例。这对应于 $\\Delta\\chi^2_t \\le q_{0.95}^{(\\chi^2_1)}$ 的“玩具”样本比例，其中 $q_{0.95}^{(\\chi^2_1)} \\approx 3.841$ 是 $\\chi^2_1$ 分布的第95百分位数。如果威尔克斯定理成立，这个覆盖率应接近0.95。\n\n### 5. 假设检验与校正阈值\n\n为了正式检验威尔克斯定理的有效性，我们执行柯尔莫哥洛夫-斯米尔诺夫（KS）检验。“玩具”样本 $\\Delta\\chi^2_t$ 值的经验累积分布函数（CDF）将与 $\\chi^2_1$ 分布的理论CDF进行比较。如果检验的p值小于显著性水平 $\\alpha=0.05$，我们就拒绝数据服从 $\\chi^2_1$ 分布的原假设。\n\n当威尔克斯定理失效时，名义阈值 $q_{0.95}^{(\\chi^2_1)}$ 是不正确的。一个校正后的阈值 $q_{0.95}^{\\mathrm{corr}}$ 可以通过经验确定为“玩具”样本 $\\Delta\\chi^2_t$ 分布的第95百分位数。这确保了（通过构造）所得到的置信区间将具有正确的覆盖率。\n\n### 6. 置信区间构建\n\n$\\theta$ 的置信区间是通过反转假设检验来构建的。对于一个观测数据集 $\\tilde{x}$，95%置信区间是在5%水平上未被拒绝的 $\\theta$ 值的集合。这个集合是 $\\{\\theta \\ge 0 \\mid \\Delta\\chi^2(\\theta; \\tilde{x}) \\le q \\}$，其中 $q$ 是选定的阈值（对于基于威尔克斯定理的区间为 $q_{0.95}^{(\\chi^2_1)}$，对于校正后的区间为 $q_{0.95}^{\\mathrm{corr}}$）。该条件可以写成：\n$$\n\\chi^2(\\theta; \\tilde{x}) \\le \\chi^2_{\\min}(\\tilde{x}) + q\n$$\n使用表达式 $\\Delta\\chi^2(\\theta; \\tilde{x}) = A [ (\\theta - \\theta_{\\mathrm{uc}})^2 - (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 ]$，不等式变为：\n$$\nA [ (\\theta - \\theta_{\\mathrm{uc}})^2 - (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 ] \\le q\n$$\n$$\n(\\theta - \\theta_{\\mathrm{uc}})^2 \\le (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 + \\frac{q}{A}\n$$\n这个不等式定义了一个围绕 $\\theta_{\\mathrm{uc}}$ 的对称区间：\n$$\n\\theta_{\\mathrm{uc}} - \\delta \\le \\theta \\le \\theta_{\\mathrm{uc}} + \\delta\n$$\n其中 $\\delta = \\sqrt{(\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 + q/A}$。考虑到物理边界 $\\theta \\ge 0$，最终的置信区间是 $[\\theta_{\\mathrm{low}}, \\theta_{\\mathrm{high}}]$：\n$$\n\\theta_{\\mathrm{low}} = \\max\\left(0, \\theta_{\\mathrm{uc}} - \\delta\\right)\n$$\n$$\n\\theta_{\\mathrm{high}} = \\theta_{\\mathrm{uc}} + \\delta\n$$\n此过程将应用于每种测试情况生成的“观测”数据集 $\\tilde{x}$，同时使用威尔克斯阈值和校正阈值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2, kstest\n\ndef solve():\n    \"\"\"\n    Performs a statistical analysis of an EFT model, including chi-squared minimization,\n    coverage studies via toy MC, and confidence interval construction.\n    \"\"\"\n    # Fixed model parameters (dimensionless)\n    b = np.array([10.0, 12.0, 8.0])\n    s = np.array([4.0, 6.0, 3.0])\n    sigma = np.array([3.2, 3.5, 3.0])\n\n    # Pre-calculate the coefficient 'A' of the quadratic chi-squared function,\n    # as it is independent of the data.\n    # chi^2(theta) = A*theta^2 - 2*B*theta + C\n    A = np.sum((s / sigma)**2)\n\n    # Theoretical 95% quantile of the chi-square distribution with 1 d.o.f.\n    # This is the threshold 'q' used for Wilks-based intervals.\n    q_wilks = chi2.ppf(0.95, 1)\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # (theta_true, N_toys, toy_seed, observed_data_seed)\n        (0.0, 10000, 12345, 54321),\n        (0.05, 10000, 23456, 65432),\n        (0.5, 10000, 34567, 76543),\n    ]\n\n    all_results = []\n    \n    for theta_true, N_toys, toy_seed, obs_seed in test_cases:\n        # --- Part 1: Toy Monte Carlo Simulation to study Delta chi^2 distribution ---\n        rng_toy = np.random.default_rng(toy_seed)\n        \n        # Calculate true means for toy generation\n        m_true = b + s * theta_true\n        \n        delta_chi2_toys = np.zeros(N_toys)\n        \n        for t in range(N_toys):\n            # Generate a toy dataset x by sampling from Gaussian distributions\n            x_toy = rng_toy.normal(loc=m_true, scale=sigma)\n            \n            # For the toy data, find the best-fit parameter theta_hat\n            # B_toy is the coefficient of the linear term in the chi-squared function\n            B_toy = np.sum(s * (x_toy - b) / sigma**2)\n            theta_uc_toy = B_toy / A  # Unconstrained best-fit\n            theta_hat_toy = np.maximum(0.0, theta_uc_toy) # Constrained best-fit\n\n            # Calculate the test statistic Delta chi^2(theta_true; x_toy)\n            # Delta_chi2 = chi2(theta_true) - chi2(theta_hat)\n            # This is equivalent to A * ((theta_true - theta_uc)^2 - (theta_hat - theta_uc)^2)\n            delta_chi2 = A * ((theta_true - theta_uc_toy)**2 - (theta_hat_toy - theta_uc_toy)**2)\n            delta_chi2_toys[t] = delta_chi2\n\n        # Filter out any small negative values from floating point inaccuracies\n        delta_chi2_toys = np.maximum(0, delta_chi2_toys)\n\n        # --- Part 2: Analyze the toy distribution ---\n\n        # 1. Empirical Coverage using Wilks' threshold\n        coverage = np.sum(delta_chi2_toys = q_wilks) / N_toys\n        \n        # 2. Corrected 95% Threshold (q_corr)\n        q_corr = np.percentile(delta_chi2_toys, 95)\n        \n        # 3. KS test for Wilks' hypothesis validity\n        # Null hypothesis: the toy delta_chi2 distribution is a chi2 with 1 d.o.f.\n        ks_statistic, p_value = kstest(delta_chi2_toys, 'chi2', args=(1,))\n        ks_pass = p_value > 0.05  # True if we fail to reject the null at alpha=0.05\n\n        # --- Part 3: Confidence Interval for a single \"observed\" dataset ---\n        \n        rng_obs = np.random.default_rng(obs_seed)\n        x_obs = rng_obs.normal(loc=m_true, scale=sigma)\n        \n        # Find best-fit theta for the observed data\n        B_obs = np.sum(s * (x_obs - b) / sigma**2)\n        theta_uc_obs = B_obs / A\n        theta_hat_obs = np.maximum(0.0, theta_uc_obs)\n\n        def get_interval(q_val, theta_uc, theta_hat):\n            \"\"\"Calculates the confidence interval for a given threshold q.\"\"\"\n            # The interval is defined by chi2(theta) = chi2_min + q, which solves to:\n            # |theta - theta_uc|^2 = |theta_hat - theta_uc|^2 + q/A\n            delta = np.sqrt((theta_hat - theta_uc)**2 + q_val / A)\n            low = np.maximum(0.0, theta_uc - delta)\n            high = theta_uc + delta\n            return low, high\n\n        # 4. Wilks-based confidence interval\n        wilks_low, wilks_high = get_interval(q_wilks, theta_uc_obs, theta_hat_obs)\n        \n        # 5. Corrected confidence interval\n        corr_low, corr_high = get_interval(q_corr, theta_uc_obs, theta_hat_obs)\n        \n        # Assemble results for this case in the specified order\n        case_results = [\n            coverage, q_corr, ks_pass, \n            wilks_low, wilks_high, \n            corr_low, corr_high\n        ]\n        all_results.append(case_results)\n\n    # Convert boolean to lower case for consistency if needed, but python default is fine.\n    # Format the final output string as a list of lists.\n    # str([1, 2, True]) -> '[1, 2, True]', which is a valid representation.\n    final_output_str = \"[\" + \",\".join([str(res) for res in all_results]) + \"]\"\n    \n    # Print the final result in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3507406"}]}