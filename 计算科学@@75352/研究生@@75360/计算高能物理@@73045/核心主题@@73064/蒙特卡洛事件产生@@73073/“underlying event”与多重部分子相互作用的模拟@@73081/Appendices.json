{"hands_on_practices": [{"introduction": "在单次质子-质子碰撞中发生多次相互作用的可能性，从根本上与碰撞质子内部分子的横向空间分布有关。本练习将指导您从第一性原理出发，推导有效截面 $\\sigma_{\\mathrm{eff}}$，这是一个封装此几何重叠因子的关键参数。理解此推导过程是掌握包容性单次散射截面如何与双部分子散射率相关联的关键。[@problem_id:3535735]", "problem": "在高能质子-质子对撞中，基础事件包含来自多重部分子相互作用（MPI）的贡献，其中包括双部分子散射（DPS），即在单次强子-强子对撞中发生两次独立的硬散射。考虑两个不同的硬过程，标记为$X$和$Y$，其遍举单散射截面分别为$\\sigma^{X}$和$\\sigma^{Y}$。假设：\n\n- 纵向动量分数根据单个部分子分布函数（PDF）进行因子化，因此纵向和横向自由度是独立的。\n- 两次硬散射在概率上是独立的。\n- 每个强子的横向结构由一个归一化的非负碰撞参数剖面$A(b)$来描述，该剖面仅依赖于两个强子中心之间的横向矢量$b$，并满足$\\int d^{2}b\\,A(b)=1$。\n- 末态$X$和$Y$是不同的，因此不需要对称因子。\n\n从这些假设以及将$\\sigma^{X}$和$\\sigma^{Y}$解释为遍举单散射截面出发，推导遍举双部分子散射截面$\\sigma_{\\mathrm{DPS}}^{XY}$的表达式，用$\\sigma^{X}$、$\\sigma^{Y}$以及一个关于碰撞参数$b$的积分来表示。通过关系式\n$$\n\\sigma_{\\mathrm{DPS}}^{XY}=\\frac{\\sigma^{X}\\,\\sigma^{Y}}{\\sigma_{\\mathrm{eff}}}\\,,\n$$\n定义有效截面$\\sigma_{\\mathrm{eff}}$，并求出用$A(b)$表示的$\\sigma_{\\mathrm{eff}}$。\n\n然后，对于宽度参数为$B>0$的高斯碰撞参数剖面\n$$\nA(b)=\\frac{1}{2\\pi B}\\,\\exp\\!\\left(-\\frac{b^{2}}{2B}\\right),\n$$\n计算由此得到的$\\sigma_{\\mathrm{eff}}$，结果为一个用$B$表示的闭合形式解析表达式。将最终答案表示为单个用$B$表示的解析表达式。无需四舍五入。最终方框内的答案不应包含单位。", "solution": "该问题陈述具有科学依据、提法恰当、客观，并包含足够的信息以获得唯一解。它代表了高能粒子物理领域的一个标准理论推导，特别是在多重部分子相互作用（MPI）的建模方面。因此，该问题是有效的，我们可以着手求解。\n\n推导始于碰撞参数绘景下散射截面的概率性解释。单个硬过程（例如类型$X$）的遍举截面用$\\sigma^{X}$表示。问题指定了一个归一化的非负碰撞参数剖面$A(b)$，它描述了对撞质子内部部分子相互作用的横向空间分布。归一化条件为$\\int d^{2}b\\,A(b)=1$，其中$b$是两个质子中心之间横向分离矢量的模。\n\n在半经典的MPI模型中，单次质子-质子对撞中，在固定碰撞参数$b$下发生的类型为$X$的硬散射的平均次数，记为$\\langle n_{X}(b) \\rangle$，被假定为与单散射截面$\\sigma^{X}$和横向物质重叠函数$A(b)$均成正比。这种关系表示为：\n$$\n\\langle n_{X}(b) \\rangle = \\sigma^{X} A(b)\n$$\n该形式在硬散射是稀有事件的假设下有效，此时相互作用的概率可以很好地用平均相互作用次数来近似。$\\langle n_{X}(b) \\rangle$的无量纲性质得以保持，因为$\\sigma^{X}$的单位是面积，而$A(b)$的单位是面积的倒数。\n\n类似地，对于第二个不同的硬过程$Y$，在碰撞参数$b$下的平均散射次数为：\n$$\n\\langle n_{Y}(b) \\rangle = \\sigma^{Y} A(b)\n$$\n问题指出，两次硬散射$X$和$Y$在概率上是独立的。在固定的碰撞参数$b$下，同时发生双部分子散射（DPS）事件（其中一次散射为类型$X$，另一次为类型$Y$）的平均次数是它们各自平均次数的乘积：\n$$\n\\langle n_{XY}(b) \\rangle = \\langle n_{X}(b) \\rangle \\langle n_{Y}(b) \\rangle\n$$\n没有对称因子$1/2$是因为末态$X$和$Y$被指定为是不同的。如果它们是相同的（例如，过程$X$发生两次），则需要一个因子$1/2$来避免重复计数。\n\n代入$\\langle n_{X}(b) \\rangle$和$\\langle n_{Y}(b) \\rangle$的表达式，我们得到在碰撞参数$b$下$XY$对的平均数：\n$$\n\\langle n_{XY}(b) \\rangle = (\\sigma^{X} A(b)) (\\sigma^{Y} A(b)) = \\sigma^{X}\\sigma^{Y} [A(b)]^{2}\n$$\n双部分子散射过程的遍举截面$\\sigma_{\\mathrm{DPS}}^{XY}$，是通过将这对的平均数对所有可能的碰撞参数进行积分得到的：\n$$\n\\sigma_{\\mathrm{DPS}}^{XY} = \\int d^{2}b \\, \\langle n_{XY}(b) \\rangle = \\int d^{2}b \\, \\sigma^{X}\\sigma^{Y} [A(b)]^{2}\n$$\n由于$\\sigma^{X}$和$\\sigma^{Y}$是关于$b$的积分的常数，它们可以被提出来：\n$$\n\\sigma_{\\mathrm{DPS}}^{XY} = \\sigma^{X}\\sigma^{Y} \\int d^{2}b \\, [A(b)]^{2}\n$$\n这就是所求的遍举DPS截面的表达式。\n\n接下来，我们得到有效截面$\\sigma_{\\mathrm{eff}}$的定义：\n$$\n\\sigma_{\\mathrm{DPS}}^{XY} = \\frac{\\sigma^{X}\\sigma^{Y}}{\\sigma_{\\mathrm{eff}}}\n$$\n通过将这个定义与推导出的$\\sigma_{\\mathrm{DPS}}^{XY}$表达式进行比较，我们可以确定$\\sigma_{\\mathrm{eff}}$的表达式。\n$$\n\\frac{\\sigma^{X}\\sigma^{Y}}{\\sigma_{\\mathrm{eff}}} = \\sigma^{X}\\sigma^{Y} \\int d^{2}b \\, [A(b)]^{2}\n$$\n假设$\\sigma^X > 0$且$\\sigma^Y > 0$，我们可以消去两边的项$\\sigma^{X}\\sigma^{Y}$，得到：\n$$\n\\frac{1}{\\sigma_{\\mathrm{eff}}} = \\int d^{2}b \\, [A(b)]^{2}\n$$\n因此，有效截面是碰撞参数剖面平方的积分的倒数：\n$$\n\\sigma_{\\mathrm{eff}} = \\frac{1}{\\int d^{2}b \\, [A(b)]^{2}}\n$$\n现在，我们必须为高斯碰撞参数剖面的特定情况计算$\\sigma_{\\mathrm{eff}}$：\n$$\nA(b) = \\frac{1}{2\\pi B} \\exp\\left(-\\frac{b^{2}}{2B}\\right)\n$$\n其中$B>0$是宽度参数。我们需要计算积分$\\int d^{2}b \\, [A(b)]^{2}$。首先，我们将函数$A(b)$平方：\n$$\n[A(b)]^{2} = \\left(\\frac{1}{2\\pi B}\\right)^{2} \\exp\\left(-2 \\cdot \\frac{b^{2}}{2B}\\right) = \\frac{1}{4\\pi^{2}B^{2}} \\exp\\left(-\\frac{b^{2}}{B}\\right)\n$$\n积分是在二维横向平面上进行的。在极坐标中计算最为方便，其中面积微元为$d^{2}b = b \\, db \\, d\\phi$。积分范围是$b \\in [0, \\infty)$和$\\phi \\in [0, 2\\pi)$。\n$$\n\\int d^{2}b \\, [A(b)]^{2} = \\int_{0}^{2\\pi} d\\phi \\int_{0}^{\\infty} db \\, b \\, \\left[ \\frac{1}{4\\pi^{2}B^{2}} \\exp\\left(-\\frac{b^{2}}{B}\\right) \\right]\n$$\n被积函数与角度$\\phi$无关，因此角度积分只给出一个因子$2\\pi$：\n$$\n\\int d^{2}b \\, [A(b)]^{2} = 2\\pi \\cdot \\frac{1}{4\\pi^{2}B^{2}} \\int_{0}^{\\infty} b \\, \\exp\\left(-\\frac{b^{2}}{B}\\right) db = \\frac{1}{2\\pi B^{2}} \\int_{0}^{\\infty} b \\, \\exp\\left(-\\frac{b^{2}}{B}\\right) db\n$$\n为了求解剩余的径向积分，我们进行变量代换。令$u = b^{2}/B$。则$du = (2b/B)db$，这意味着$b \\, db = (B/2)du$。$u$的积分限仍然是$0$和$\\infty$。\n$$\n\\int_{0}^{\\infty} b \\, \\exp\\left(-\\frac{b^{2}}{B}\\right) db = \\int_{0}^{\\infty} \\exp(-u) \\left(\\frac{B}{2}\\right) du = \\frac{B}{2} \\int_{0}^{\\infty} \\exp(-u) du\n$$\n从$0$到$\\infty$的$\\exp(-u)$积分是一个标准结果：\n$$\n\\int_{0}^{\\infty} \\exp(-u) du = \\left[-\\exp(-u)\\right]_{0}^{\\infty} = (-\\exp(-\\infty)) - (-\\exp(0)) = 0 - (-1) = 1\n$$\n因此，径向积分的值为$B/2$。将此结果代回：\n$$\n\\int d^{2}b \\, [A(b)]^{2} = \\frac{1}{2\\pi B^{2}} \\left(\\frac{B}{2}\\right) = \\frac{B}{4\\pi B^{2}} = \\frac{1}{4\\pi B}\n$$\n最后，我们使用其定义来计算$\\sigma_{\\mathrm{eff}}$：\n$$\n\\sigma_{\\mathrm{eff}} = \\frac{1}{\\int d^{2}b \\, [A(b)]^{2}} = \\frac{1}{1/(4\\pi B)} = 4\\pi B\n$$\n因此，对于宽度参数为$B$的高斯碰撞参数剖面，有效截面是$4\\pi B$。", "answer": "$$\n\\boxed{4\\pi B}\n$$", "id": "3535735"}, {"introduction": "现代的事件生成器通过动态模拟一系列的发射来构建复杂的末态。本练习介绍 Sudakov 否决算法，这是一种用于生成按横向动量排序的此类发射序列的基石级蒙特卡洛技术。通过为一个交错的 MPI 和初态辐射实现一个玩具模型，您将获得支撑部分子簇射和 MPI 模拟核心逻辑的实践经验。[@problem_id:3535737]", "problem": "实现一个完整的、可运行的程序，该程序使用基于否决的采样器，在多重部分子相互作用 (MPI) 加初态辐射 (ISR) 的玩具模型中模拟一个交错的发射序列，并验证采样得到的横动量谱在统计不确定度范围内与解析积分率相符。横动量必须以吉电子伏特 (GeV) 为单位，所有关于横动量的积分也必须以 GeV 表示。程序不得要求任何输入，并必须按如下规定打印单行输出。\n\n基本原理和定义：\n- 发射序列被建模为一个非齐次泊松过程，其演化变量为横动量 $p_T$，总强度（率密度）$f(p_T)$ 是两个通道强度的和，\n  $$ f(p_T) \\equiv f_1(p_T) + f_2(p_T), $$\n  分别代表多重部分子相互作用 (MPI) 和初态辐射 (ISR)。在本问题中，使用以下具体形式\n  $$ f_1(p_T) = \\frac{A}{p_T + \\lambda_1}, \\quad f_2(p_T) = \\frac{B}{p_T + \\lambda_2}, $$\n  其中 $A$、$B$、$\\lambda_1$ 和 $\\lambda_2$ 是严格为正的常数。\n- 演化按照 $p_T$ 排序进行，从一个初始标度 $Q$ 向下到一个截止标度 $p_{T0}$（两者单位均为 GeV）。在标度 $p_T$ 以上没有发射的概率由 Sudakov 形式因子给出\n  $$ \\Delta_f(p_T \\mid Q) = \\exp\\!\\left(-\\int_{p_T}^{Q} f(t)\\,dt\\right). $$\n- 否决算法是一种用于非齐次泊松过程的拒绝采样方法。为了使用该算法，需要构造一个高估函数 $G(p_T)$，满足对于所有在 $[p_{T0},Q]$ 区间内的 $p_T$ 都有 $G(p_T) \\ge f(p_T)$，并且其积分可以解析地求逆。在本问题中，你必须使用\n  $$ G(p_T) = \\frac{A+B}{p_T + \\lambda_{\\min}}, \\quad \\lambda_{\\min} = \\min(\\lambda_1,\\lambda_2), $$\n  这是一个有效的高估，因为对于所有 $p_T \\ge 0$ 都有 $\\frac{A}{p_T+\\lambda_1} \\le \\frac{A}{p_T+\\lambda_{\\min}}$ 和 $\\frac{B}{p_T+\\lambda_2} \\le \\frac{B}{p_T+\\lambda_{\\min}}$，所以 $f_1(p_T)+f_2(p_T) \\le \\frac{A+B}{p_T+\\lambda_{\\min}}$。\n- 积分强度为\n  $$ I_1 = \\int_{p_{T0}}^{Q} f_1(t)\\,dt = A \\ln\\!\\left(\\frac{Q+\\lambda_1}{p_{T0}+\\lambda_1}\\right), \\quad\n     I_2 = \\int_{p_{T0}}^{Q} f_2(t)\\,dt = B \\ln\\!\\left(\\frac{Q+\\lambda_2}{p_{T0}+\\lambda_2}\\right), $$\n  且 $I = I_1 + I_2$。在 $p_{T0}$ 以上没有发射的解析概率是 $\\Delta_f(p_{T0}\\mid Q) = e^{-I}$，每个事例的平均发射数是 $I$。对于一个包含 $N$ 个独立事例的样本，样本平均发射多重性的标准差为 $\\sqrt{I/N}$，零发射分数的标准差为 $\\sqrt{e^{-I}(1-e^{-I})/N}$（均为无量纲）。\n\n任务要求：\n1. 实现一个基于否决的采样器，为每个事例生成完整的、交错的已接受发射序列，该序列按 $p_T$ 从 $Q$ 向下到 $p_{T0}$ 排序，使用指定的 $G(p_T)$。在每次接受发射时，还要在 $f_1$ 和 $f_2$ 之间进行通道选择，其条件概率与它们在接受的 $p_T$ 处的相对贡献成正比。\n2. 为测试套件中的每个参数点运行一组独立事例的模拟。记录：\n   - 总接受发射数，$M$。\n   - 通道 1 中的接受发射数，$M_1$。\n   - 通道 2 中的接受发射数，$M_2$。\n   - 零发射事例数，$Z$。\n   计算以下可观测量：\n   - 每个事例的样本平均发射多重性，$\\hat{\\mu} = M/N$（无量纲）。\n   - 解析总积分强度 $I$（无量纲），以及比率 $r_{\\text{tot}} = \\hat{\\mu}/I$。\n   - 总均值的 $z$-score，$z_{\\text{tot}} = (\\hat{\\mu} - I)/\\sqrt{I/N}$（无量纲）。\n   - 样本零发射分数，$\\hat{\\Delta} = Z/N$（无量纲），及其与解析值的比率，$r_{0} = \\hat{\\Delta}/e^{-I}$。\n   - 零发射分数的 $z$-score，$z_{0} = (\\hat{\\Delta} - e^{-I})/\\sqrt{e^{-I}(1-e^{-I})/N}$（无量纲）。\n   - 每个通道的样本平均多重性，$\\hat{\\mu}_1 = M_1/N$ 和 $\\hat{\\mu}_2 = M_2/N$（无量纲），以及它们与解析值的比率 $r_1 = \\hat{\\mu}_1/I_1$，$r_2 = \\hat{\\mu}_2/I_2$（无量纲）。\n3. 为了可复现性，使用固定的随机种子 $12345$。\n4. 单位：$p_T$、$Q$、$p_{T0}$、$\\lambda_1$ 和 $\\lambda_2$ 必须以 GeV 为单位；$A$、$B$、$I$ 以及所有比率和 $z$-score 都是无量纲的。\n5. 测试套件：为以下三个参数集运行你的程序，每个参数集包含 $N$ 个事例：\n   - 情况 A (通用)：$A = 0.8$, $B = 0.6$, $\\lambda_1 = 2.0\\,\\mathrm{GeV}$, $\\lambda_2 = 1.0\\,\\mathrm{GeV}$, $Q = 50.0\\,\\mathrm{GeV}$, $p_{T0} = 0.5\\,\\mathrm{GeV}$, $N = 100000$。\n   - 情况 B (低活跃度 / 接近零发射边界)：$A = 0.05$, $B = 0.02$, $\\lambda_1 = 5.0\\,\\mathrm{GeV}$, $\\lambda_2 = 3.0\\,\\mathrm{GeV}$, $Q = 100.0\\,\\mathrm{GeV}$, $p_{T0} = 1.0\\,\\mathrm{GeV}$, $N = 100000$。\n   - 情况 C (高活跃度)：$A = 1.5$, $B = 1.2$, $\\lambda_1 = 1.0\\,\\mathrm{GeV}$, $\\lambda_2 = 0.8\\,\\mathrm{GeV}$, $Q = 30.0\\,\\mathrm{GeV}$, $p_{T0} = 0.4\\,\\mathrm{GeV}$, $N = 100000$。\n6. 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况 A、情况 B、情况 C 的顺序连接结果：\n   - 对于每种情况，输出六个浮点数：$[r_{\\text{tot}}, z_{\\text{tot}}, r_{0}, z_{0}, r_1, r_2]$。\n   因此，最后一行必须包含 18 个用逗号分隔的数值，并置于一对​​方括号内。所有输出均为无量纲。\n\n所有涉及物理量的答案都必须使用指定的单位表示。不使用角度。不得使用百分比；在适用情况下使用小数。程序必须是完全自包含的，并能用给定的随机种子复现。", "solution": "我们将多重部分子相互作用 (MPI) 和初态辐射 (ISR) 中的交错发射序列建模为横动量变量 $p_T$ 上的非齐次泊松过程，从硬标度 $Q$ 向下排序至截止标度 $p_{T0}$。基本出发点是区间上强度为 $f(p_T)$ 的非齐次泊松过程与其由 Sudakov 形式因子给出的无事件概率之间的对应关系。具体来说，给定在 $p_T \\in [p_{T0}, Q]$ 上的强度 $f(p_T)$，在标度 $p_T$ 以上没有发射的概率是\n$$ \\Delta_f(p_T \\mid Q) = \\exp\\!\\left(-\\int_{p_T}^Q f(t)\\, dt\\right), $$\n每个事例的预期发射数是积分\n$$ I = \\int_{p_{T0}}^Q f(t)\\, dt. $$\n这些是非齐次泊松过程的标准结果，并构成了部分子簇射和多重部分子相互作用 (MPI) 模拟中使用的 Sudakov 表示法的基础。\n\n在当前设置中，总强度是两个通道的和，\n$$ f(p_T) = f_1(p_T) + f_2(p_T), \\quad f_1(p_T) = \\frac{A}{p_T + \\lambda_1}, \\quad f_2(p_T) = \\frac{B}{p_T + \\lambda_2}, $$\n其中 $A$、$B$、$\\lambda_1$ 和 $\\lambda_2$ 是正常数，而 $p_T$、$\\lambda_1$、$\\lambda_2$、$Q$、$p_{T0}$ 的单位是吉电子伏特 (GeV)。直接积分可得\n$$ I_1 = \\int_{p_{T0}}^Q \\frac{A}{t + \\lambda_1}\\, dt = A \\ln\\!\\left(\\frac{Q + \\lambda_1}{p_{T0} + \\lambda_1}\\right), \\quad\n   I_2 = \\int_{p_{T0}}^Q \\frac{B}{t + \\lambda_2}\\, dt = B \\ln\\!\\left(\\frac{Q + \\lambda_2}{p_{T0} + \\lambda_2}\\right), $$\n因此\n$$ I = I_1 + I_2, \\quad \\Delta_f(p_{T0}\\mid Q) = e^{-I}. $$\n\n为了生成按 $p_T$ 排序的发射序列，我们使用否决算法。该算法依赖于构造一个高估函数 $G(p_T)$，使得在相关范围内对所有 $p_T$ 都有 $G(p_T) \\ge f(p_T)$，并且 $G(p_T)$ 的积分可以解析地求逆以采样候选点。我们选择\n$$ G(p_T) = \\frac{A+B}{p_T + \\lambda_{\\min}}, \\quad \\lambda_{\\min} \\equiv \\min(\\lambda_1,\\lambda_2). $$\n这满足 $G(p_T) \\ge f(p_T)$ 是因为 $p_T + \\lambda_{\\min} \\le p_T + \\lambda_i$ 意味着 $\\frac{1}{p_T+\\lambda_i} \\le \\frac{1}{p_T+\\lambda_{\\min}}$ 对于 $i \\in \\{1,2\\}$ 成立，因此\n$$ f_1(p_T) + f_2(p_T) = \\frac{A}{p_T+\\lambda_1} + \\frac{B}{p_T+\\lambda_2} \\le \\frac{A}{p_T+\\lambda_{\\min}} + \\frac{B}{p_T+\\lambda_{\\min}} = \\frac{A+B}{p_T+\\lambda_{\\min}} = G(p_T). $$\n\n在两个有序标度 $p_T'  p_T$ 之间 $G(p_T)$ 的积分是\n$$ \\int_{p_T'}^{p_T} G(t)\\, dt = (A+B) \\int_{p_T'}^{p_T} \\frac{dt}{t + \\lambda_{\\min}} = (A+B)\\, \\ln\\!\\left( \\frac{p_T + \\lambda_{\\min}}{p_T' + \\lambda_{\\min}} \\right). $$\n在从 $p_T = Q$ 到 $p_{T0}$ 的后向演化中，非齐次泊松过程的标准抽样法（Lewis-Shedler thinning）等价于 Sudakov 否决算法。从当前标度 $p$ 开始，我们抽取一个均匀随机变量 $U \\in (0,1)$ 并求解\n$$ \\exp\\!\\left( - \\int_{p'}^{p} G(t)\\, dt \\right) = U \\quad \\iff \\quad (A+B)\\, \\ln\\!\\left( \\frac{p + \\lambda_{\\min}}{p' + \\lambda_{\\min}} \\right) = -\\ln U, $$\n这给出了下一个候选标度\n$$ p' = \\left(p + \\lambda_{\\min}\\right)\\, U^{1/(A+B)} - \\lambda_{\\min}. $$\n如果 $p' \\le p_{T0}$，演化停止。否则，以概率\n$$ P_{\\text{acc}}(p') = \\frac{f(p')}{G(p')} = \\frac{\\frac{A}{p' + \\lambda_1} + \\frac{B}{p' + \\lambda_2}}{\\frac{A+B}{p' + \\lambda_{\\min}}} \\in (0,1]. $$\n接受该候选点。如果接受，则在 $p'$ 处记录一次发射，并通过竞争选择发射通道，概率为 $P(\\text{ch}=1\\mid p') = f_1(p')/f(p')$ 和 $P(\\text{ch}=2\\mid p') = f_2(p')/f(p')$。无论候选点被接受还是被否决，演化都从新的当前标度 $p \\leftarrow p'$ 继续，强制执行严格的 $p_T$ 排序，直到 $p \\le p_{T0}$。\n\n统计验证基于非齐次泊松过程经过充分检验的性质：每个事例的总计数服从均值为 $I$ 的泊松分布，因此 $N$ 个事例的样本均值 $\\hat{\\mu}$ 的标准差为 $\\sqrt{I/N}$；零发射指示变量服从均值为 $e^{-I}$ 的伯努利分布，因此零发射分数 $\\hat{\\Delta}$ 的标准差为 $\\sqrt{e^{-I}(1-e^{-I})/N}$。\n\n计算所需可观测量的算法设计：\n1. 对每个测试用例，固定随机种子以确保可复现性。初始化总接受发射数 $M$、各通道发射数 $M_1$、$M_2$ 以及零发射事例数 $Z$ 的计数器。\n2. 对 $N$ 个事例中的每一个，设置 $p \\leftarrow Q$，并使用 $G(p_T)$ 的可逆累积函数重复采样候选标度 $p'$，如前所示。如果 $p' \\le p_{T0}$，则结束该事例。否则，计算 $P_{\\text{acc}}(p')$，抽取一个均匀随机数 $V \\in (0,1)$，如果 $V  P_{\\text{acc}}(p')$ 则接受，更新计数，并根据 $f_i(p')/f(p')$ 选择发射通道。设置 $p \\leftarrow p'$ 并重复。\n3. 在 $N$ 个事例之后，计算 $\\hat{\\mu} = M/N$、$\\hat{\\mu}_1 = M_1/N$、$\\hat{\\mu}_2 = M_2/N$ 和 $\\hat{\\Delta} = Z/N$。计算解析值 $I_1$、$I_2$、$I=I_1+I_2$ 和 $\\Delta = e^{-I}$，以及标准差 $\\sigma_{\\text{tot}} = \\sqrt{I/N}$ 和 $\\sigma_0 = \\sqrt{\\Delta (1-\\Delta)/N}$。构建比率 $r_{\\text{tot}} = \\hat{\\mu}/I$、$r_1 = \\hat{\\mu}_1/I_1$、$r_2 = \\hat{\\mu}_2/I_2$、$r_0 = \\hat{\\Delta}/\\Delta$ 和 $z$-score $z_{\\text{tot}} = (\\hat{\\mu}-I)/\\sigma_{\\text{tot}}$、$z_0 = (\\hat{\\Delta}-\\Delta)/\\sigma_0$。\n4. 为保证数值稳健性，如果由于极端参数（在所提供的测试套件中不会出现这种情况）导致标准差为零，则按惯例将相应的 $z$-score 设置为 0。\n5. 按照情况 A、然后情况 B、然后情况 C 的顺序，将三个情况的结果连接成一个单一列表，并以单行形式输出，顺序为 $[r_{\\text{tot}}, z_{\\text{tot}}, r_0, z_0, r_1, r_2]$。\n\n此过程遵循非齐次泊松过程的基本理论、Sudakov 形式因子和抽样（否决）算法。所选的 $G(p_T)$ 与接受概率 $f/G$ 相结合，保证了采样的精确性，而通道的交错是通过在每次接受发射时与 $f_i(p_T)$ 成正比的竞争概率来实现的。通过接近 1 的比率和数量级为 1 的 $z$-score（在统计涨落范围内）进行的验证表明，采样得到的 $p_T$ 谱在统计不确定度范围内复现了积分解析率。", "answer": "```python\nimport numpy as np\n\ndef simulate_case(A, B, lam1, lam2, Q, pT0, N, rng):\n    \"\"\"\n    Simulate N events of a pT-ordered interleaved sequence using a veto algorithm\n    with overestimate G(pT) = (A+B)/(pT + lam_min). Return (M, M1, M2, Z).\n    \"\"\"\n    lam_min = min(lam1, lam2)\n    AB = A + B\n\n    total_emissions = 0\n    ch1_emissions = 0\n    ch2_emissions = 0\n    zero_events = 0\n\n    for _ in range(N):\n        p = Q\n        accepted_in_event = 0\n\n        while True:\n            # Generate next candidate from G via inversion:\n            U = rng.random()\n            # p' = (p + lam_min) * U^(1/(A+B)) - lam_min\n            p_candidate = (p + lam_min) * (U ** (1.0 / AB)) - lam_min\n\n            if p_candidate = pT0:\n                break\n\n            # Compute f1, f2, f and G at candidate\n            f1 = A / (p_candidate + lam1)\n            f2 = B / (p_candidate + lam2)\n            f_total = f1 + f2\n            g = AB / (p_candidate + lam_min)\n\n            # Accept with probability f_total/g\n            V = rng.random()\n            if V  (f_total / g):\n                # Accepted emission\n                total_emissions += 1\n                accepted_in_event += 1\n                # Channel competition\n                W = rng.random()\n                if W  (f1 / f_total):\n                    ch1_emissions += 1\n                else:\n                    ch2_emissions += 1\n\n            # Continue evolution from candidate scale regardless of accept/reject\n            p = p_candidate\n\n        if accepted_in_event == 0:\n            zero_events += 1\n\n    return total_emissions, ch1_emissions, ch2_emissions, zero_events\n\n\ndef analytics(A, B, lam1, lam2, Q, pT0):\n    \"\"\"\n    Compute analytic integrals I1, I2, I and Delta = exp(-I).\n    \"\"\"\n    I1 = A * np.log((Q + lam1) / (pT0 + lam1))\n    I2 = B * np.log((Q + lam2) / (pT0 + lam2))\n    I = I1 + I2\n    Delta = np.exp(-I)\n    return I1, I2, I, Delta\n\n\ndef summarize_results(A, B, lam1, lam2, Q, pT0, N, rng):\n    M, M1, M2, Z = simulate_case(A, B, lam1, lam2, Q, pT0, N, rng)\n    I1, I2, I, Delta = analytics(A, B, lam1, lam2, Q, pT0)\n\n    # Sample means\n    mu_hat = M / N\n    mu1_hat = M1 / N\n    mu2_hat = M2 / N\n    Delta_hat = Z / N\n\n    # Ratios\n    r_tot = mu_hat / I if I > 0 else 1.0\n    r1 = mu1_hat / I1 if I1 > 0 else 1.0\n    r2 = mu2_hat / I2 if I2 > 0 else 1.0\n    r0 = Delta_hat / Delta if Delta > 0 else 1.0\n\n    # Standard deviations and z-scores\n    sigma_tot = np.sqrt(I / N) if I > 0 else 0.0\n    if sigma_tot > 0:\n        z_tot = (mu_hat - I) / sigma_tot\n    else:\n        z_tot = 0.0\n\n    var0 = Delta * (1.0 - Delta) / N\n    sigma0 = np.sqrt(var0) if var0 > 0 else 0.0\n    if sigma0 > 0:\n        z0 = (Delta_hat - Delta) / sigma0\n    else:\n        z0 = 0.0\n\n    return [r_tot, z_tot, r0, z0, r1, r2]\n\n\ndef solve():\n    rng = np.random.default_rng(12345)\n\n    # Test suite: three cases\n    test_cases = [\n        # Case A: general\n        (0.8, 0.6, 2.0, 1.0, 50.0, 0.5, 100000),\n        # Case B: low activity\n        (0.05, 0.02, 5.0, 3.0, 100.0, 1.0, 100000),\n        # Case C: high activity\n        (1.5, 1.2, 1.0, 0.8, 30.0, 0.4, 100000),\n    ]\n\n    results = []\n    for A, B, lam1, lam2, Q, pT0, N in test_cases:\n        res = summarize_results(A, B, lam1, lam2, Q, pT0, N, rng)\n        results.extend(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3535737"}, {"introduction": "一个真实的 MPI 模拟必须遵守基本的物理定律，其中最重要的是动量守恒。当从单个质子中连续抽取多个部分子时，它们的总动量分数不能超过 1。本练习要求您实现并分析一个“掰棍子”算法，该算法通过其设计来强制执行此动量求和规则，从而揭示此约束如何动态地重塑后续相互作用的运动学特性。[@problem_id:3535724]", "problem": "考虑强子对撞中底层事件的模拟，其中多重部分子相互作用 (MPI) 从一个入射强子中随机抽取连续的纵向动量分数 $x_i \\in (0,1)$。部分子模型动量求和规则要求，对于任意有限次相互作用 $N$，已用总动量必须满足 $\\sum_{i=1}^{N} x_i  1$。假设用于单次相互作用动量分数的基础、无约束的提议是来自 $(0,1)$ 上的独立抽取 $y \\sim \\mathrm{Beta}(a,b)$，其中 $a>0$ 且 $b>0$，旨在捕捉部分子分布典型的小 $x$ 行为。在无约束的情况下，每次相互作用 $i$ 独立地取 $x_i = y_i$。在有约束的情况下，您必须为 $x_i$ 构建一个序贯抽样算法，该算法在设计上保证 $\\sum_{i=1}^{N} x_i  1$，同时使用相同的基础 $\\mathrm{Beta}(a,b)$ 提议作为其原语。\n\n从部分子模型动量求和规则和连续提议 $y_i \\sim \\mathrm{Beta}(a,b)$ 的独立性出发，推导出一个有原则的序贯变换，在每次相互作用后强制执行剩余动量约束。用提议 $y_i$ 和相互作用前的剩余动量 $L_{i-1} \\in (0,1]$ 来表示有约束的 $x_i$，使得 $L_i = L_{i-1} - x_i$ 且对于所有有限的 $N$ 都有 $L_N > 0$，并证明约束 $\\sum_{i=1}^{N} x_i  1$ 确定性地成立。然后，进行数学分析，研究该约束如何相对于无约束情况重塑 $x_i$ 的分布，特别是推导 $x_i$ 的一阶矩和二阶矩作为 $a$、$b$ 和 $i$ 的函数的闭式表达式。\n\n您的程序必须实现：\n- 一个种子为 $12345$ 的确定性伪随机数生成器。\n- 无约束抽样：抽取 $M$ 个事件，每个事件包含 $N$ 个独立的 $y_i \\sim \\mathrm{Beta}(a,b)$，并设置 $x_i = y_i$。\n- 有约束序贯抽样：抽取相同的 $M$ 个提议 $y_i \\sim \\mathrm{Beta}(a,b)$，并使用您推导的算法将它们转换为 $x_i$，该算法逐个事件地强制执行 $\\sum_{i=1}^{N} x_i  1$。\n- 对每个测试用例进行以下经验估计：\n  1. 有约束样本在 $i=1,\\dots,N$ 上的经验均值 $\\bar{x}_i$，以及在您的有约束算法下 $\\mathbb{E}[x_i]$ 的闭式理论预测。报告在 $i$ 上的均方根误差，计算公式为 $$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(\\bar{x}_i - \\mathbb{E}[x_i]\\right)^2}.$$ 该数值必须是单个实数。\n  2. 分布重塑的定量度量：最后一次相互作用 $x_N$ 的有约束经验分布与无约束基础 $\\mathrm{Beta}(a,b)$ 分布之间的 Kullback–Leibler 散度（使用在 $(0,1)$ 上具有 $B$ 个等间距区间的离散近似），$$D_{\\mathrm{KL}}(P\\Vert Q) = \\sum_{k=1}^{B} p_k \\log\\left(\\frac{p_k}{q_k}\\right),$$ 其中 $p_k$ 是 $x_N$ 在区间 $k$ 中的经验概率质量，$q_k$ 是在区间 $k$ 上积分的 $\\mathrm{Beta}(a,b)$ 概率质量。为避免零概率问题，使用平滑参数 $\\epsilon = 10^{-12}$，并在归一化之前替换 $p_k \\leftarrow \\max(p_k,\\epsilon)$ 和 $q_k \\leftarrow \\max(q_k,\\epsilon)$，以确保 $\\sum_k p_k = 1$ 和 $\\sum_k q_k = 1$。\n  3. 有约束算法的经验平均剩余量 $\\bar{L}_N$ 与您推导的闭式 $\\mathbb{E}[L_N]$ 之间的绝对误差，计算公式为 $$\\left|\\bar{L}_N - \\mathbb{E}[L_N]\\right|.$$\n  \n您的代码必须为每个测试用例计算上述三个量，并按下文指定的顺序将它们聚合到一个列表中。所有输出均为无量纲实数。\n\n测试套件：\n- 情况 A (典型的小-$x$ 行为): $N=5$, $a=0.3$, $b=2.5$, $M=50000$, $B=200$。\n- 情况 B (均匀提议基线): $N=3$, $a=b=1.0$, $M=50000$, $B=200$。\n- 情况 C (极陡峭的小-$x$): $N=8$, $a=0.05$, $b=1.5$, $M=50000$, $B=200$。\n- 情况 D (边界，单次相互作用): $N=1$, $a=0.8$, $b=1.2$, $M=50000$, $B=200$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为\n$$[\\mathrm{RMSE}_A, D_{\\mathrm{KL},A}, \\mathrm{ErrL}_A, \\mathrm{RMSE}_B, D_{\\mathrm{KL},B}, \\mathrm{ErrL}_B, \\mathrm{RMSE}_C, D_{\\mathrm{KL},C}, \\mathrm{ErrL}_C, \\mathrm{RMSE}_D, D_{\\mathrm{KL},D}, \\mathrm{ErrL}_D],$$\n其中 $\\mathrm{RMSE}_\\cdot$ 是均值的均方根误差，$D_{\\mathrm{KL},\\cdot}$ 是 $x_N$ 相对于无约束基础的 Kullback–Leibler 散度，而 $\\mathrm{ErrL}_\\cdot$ 是剩余均值的绝对误差，每个都对应于相应的测试用例。不应打印任何其他文本。", "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它提出了一个应用于高能物理建模的计算统计学中的形式化问题。我们开始进行解答。\n\n核心任务是设计一个用于动量分数 $x_i$ 的序贯抽样算法，该算法使用基础提议分布 $y_i \\sim \\mathrm{Beta}(a,b)$ 来强制执行部分子模型求和规则 $\\sum_{i=1}^{N} x_i  1$。该算法的构建必须确保在设计上满足此约束。\n\n**算法推导与约束执行**\n\n令 $L_{i-1}$ 表示在第 $i$ 次部分子相互作用之前，初始强子剩余的动量分数。我们用全部动量初始化该过程，因此 $L_0 = 1$。求和规则规定，对于每次相互作用 $i$，抽样的动量分数 $x_i$ 不得超过可用动量，即 $0  x_i  L_{i-1}$。\n\n实现这一点的一个有原则的方法是，用可用动量 $L_{i-1}$ 来缩放提议抽取值 $y_i \\in (0,1)$。因此，我们将第 $i$ 次相互作用的有约束动量分数 $x_i$ 定义为：\n$$x_i = L_{i-1} y_i$$\n其中 $y_i \\sim \\mathrm{Beta}(a,b)$ 是每次 $i$ 的独立提议。\n\n每次相互作用后，剩余动量会按顺序更新：\n$$L_i = L_{i-1} - x_i = L_{i-1} - L_{i-1} y_i = L_{i-1} (1-y_i)$$\n这个从 $L_0=1$ 开始的递推关系可以通过归纳法求解，从而得出 $i$ 次相互作用后剩余动量的闭式表达式：\n$$L_i = \\prod_{j=1}^{i} (1-y_j)$$\n因此，第 $i$ 次抽样的动量分数的表达式为：\n$$x_i = L_{i-1} y_i = \\left( \\prod_{j=1}^{i-1} (1-y_j) \\right) y_i$$\n其中，对于 $i=1$ 的情况，空积取为 $1$，所以 $x_1 = y_1$。\n\n为了证明动量求和规则 $\\sum_{k=1}^{N} x_k  1$ 是确定性地满足的，我们考虑 $N$ 次相互作用后抽样的总动量。该和是一个伸缩级数：\n$$\\sum_{k=1}^{N} x_k = \\sum_{k=1}^{N} (L_{k-1} - L_k) = (L_0 - L_1) + (L_1 - L_2) + \\dots + (L_{N-1} - L_N) = L_0 - L_N$$\n给定 $L_0=1$，求和规则变为 $1 - L_N  1$，这等价于条件 $L_N > 0$。根据其定义，$L_N = \\prod_{j=1}^{N} (1-y_j)$。由于每个提议 $y_j$ 都是从支撑集在 $(0,1)$ 上的贝塔分布中抽取的，因此 $0  y_j  1$，从而 $0  (1-y_j)  1$。$N$ 个此类项的乘积严格为正且小于一。因此，$L_N > 0$ 得到保证，求和规则根据构造而成立。此过程是“折棍”过程的一种实现。\n\n**有约束变量的统计分析**\n\n我们现在推导有约束变量 $x_i$ 的一阶矩和二阶矩，以及最终剩余动量的期望值 $\\mathbb{E}[L_N]$。提议 $y_i$ 是根据 $y \\sim \\mathrm{Beta}(a,b)$ 独立同分布的。该分布的 k 阶原点矩为 $\\mathbb{E}[y^k] = \\frac{B(a+k, b)}{B(a,b)}$，其中 $B(a,b)$ 是贝塔函数。由此可得前两阶矩为：\n$$\\mathbb{E}[y] = \\frac{a}{a+b} \\quad \\text{and} \\quad \\mathbb{E}[y^2] = \\frac{a(a+1)}{(a+b)(a+b+1)}$$\n根据性质，若 $y \\sim \\mathrm{Beta}(a,b)$，则 $(1-y) \\sim \\mathrm{Beta}(b,a)$，因此 $(1-y)$ 的矩为：\n$$\\mathbb{E}[1-y] = \\frac{b}{a+b} \\quad \\text{and} \\quad \\mathbb{E}[(1-y)^2] = \\frac{b(b+1)}{(a+b)(a+b+1)}$$\n\n$x_i$ 的期望值可以通过对其定义表达式求期望得到。由于提议 $y_j$ 的独立性，乘积的期望等于期望的乘积：\n$$\\mathbb{E}[x_i] = \\mathbb{E}\\left[ \\left( \\prod_{j=1}^{i-1} (1-y_j) \\right) y_i \\right] = \\left( \\prod_{j=1}^{i-1} \\mathbb{E}[1-y_j] \\right) \\mathbb{E}[y_i] = (\\mathbb{E}[1-y])^{i-1} \\mathbb{E}[y]$$\n代入贝塔分布的矩，可得出 $x_i$ 一阶矩的闭式表达式：\n$$\\mathbb{E}[x_i] = \\left( \\frac{b}{a+b} \\right)^{i-1} \\left( \\frac{a}{a+b} \\right)$$\n\n类似地， $x_i$ 的二阶原点矩推导如下：\n$$\\mathbb{E}[x_i^2] = \\mathbb{E}\\left[ \\left( \\prod_{j=1}^{i-1} (1-y_j)^2 \\right) y_i^2 \\right] = \\left( \\prod_{j=1}^{i-1} \\mathbb{E}[(1-y_j)^2] \\right) \\mathbb{E}[y_i^2] = (\\mathbb{E}[(1-y)^2])^{i-1} \\mathbb{E}[y^2]$$\n$$\\mathbb{E}[x_i^2] = \\left( \\frac{b(b+1)}{(a+b)(a+b+1)} \\right)^{i-1} \\left( \\frac{a(a+1)}{(a+b)(a+b+1)} \\right)$$\n这些表达式量化了分布的重塑：随着 $i$ 的增加，$x_i$ 的均值和方差都减小，这反映了后续相互作用可用动量的减少。\n\n最后，$N$ 次相互作用后剩余动量 $L_N$ 的期望值为：\n$$\\mathbb{E}[L_N] = \\mathbb{E}\\left[ \\prod_{j=1}^{N} (1-y_j) \\right] = \\prod_{j=1}^{N} \\mathbb{E}[1-y_j] = (\\mathbb{E}[1-y])^N$$\n$$\\mathbb{E}[L_N] = \\left( \\frac{b}{a+b} \\right)^N$$\n这些推导出的 $\\mathbb{E}[x_i]$ 和 $\\mathbb{E}[L_N]$ 表达式将用作理论预测，与来自模拟的经验估计进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating constrained sequential sampling for MPI\n    and comparing empirical results to theoretical derivations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: typical small-x\n        {'N': 5, 'a': 0.3, 'b': 2.5, 'M': 50000, 'B': 200},\n        # Case B: uniform proposal\n        {'N': 3, 'a': 1.0, 'b': 1.0, 'M': 50000, 'B': 200},\n        # Case C: extremely steep small-x\n        {'N': 8, 'a': 0.05, 'b': 1.5, 'M': 50000, 'B': 200},\n        # Case D: boundary, single interaction\n        {'N': 1, 'a': 0.8, 'b': 1.2, 'M': 50000, 'B': 200},\n    ]\n\n    results = []\n    \n    # Initialize a single deterministic pseudo-random generator for all cases.\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    for case in test_cases:\n        N, a, b, M, B = case['N'], case['a'], case['b'], case['M'], case['B']\n\n        # Generate all proposals y_i ~ Beta(a,b) for M events and N interactions.\n        # Shape: (M, N)\n        proposals = rng.beta(a, b, size=(M, N))\n\n        # --- Constrained Sequential Sampling (vectorized) ---\n        \n        # Calculate leftover momentum AFTER each step i: L_i = (1-y_1)...(1-y_i)\n        # Shape: (M, N)\n        leftover_after_step = np.cumprod(1 - proposals, axis=1)\n\n        # Calculate leftover momentum BEFORE each step i: L_{i-1} for i=1..N\n        # This is L_0, L_1, ..., L_{N-1}. L_0 = 1.\n        # Shape: (M, N)\n        L_before_step_array = np.hstack([np.ones((M, 1)), leftover_after_step[:, :-1]])\n        \n        # Calculate constrained momentum fractions: x_i = L_{i-1} * y_i\n        # Shape: (M, N)\n        constrained_x = L_before_step_array * proposals\n\n        # Final leftover momentum is L_N, which is the value after the N-th step.\n        # Shape: (M,)\n        # Note: If N=1, leftover_after_step is (M,1), so [:, -1] correctly takes the first column.\n        final_leftover_L = leftover_after_step[:, -1]\n        \n        # --- Empirical Estimations and Comparisons ---\n\n        # 1. RMSE between empirical and theoretical means of x_i\n        # Empirical means for each interaction i=1,...,N\n        empirical_means = np.mean(constrained_x, axis=0)\n        \n        # Theoretical means E[x_i] = (a/(a+b)) * (b/(a+b))^(i-1)\n        ab_sum = a + b\n        r = b / ab_sum\n        i_minus_1 = np.arange(N)\n        theoretical_means = (a / ab_sum) * (r**i_minus_1)\n        \n        # RMSE calculation\n        rmse = np.sqrt(np.mean((empirical_means - theoretical_means)**2))\n\n        # 2. Kullback–Leibler divergence for the last interaction x_N\n        # Samples of the last interaction, x_N\n        x_N_samples = constrained_x[:, N - 1]\n        bins = np.linspace(0, 1, B + 1)\n        \n        # Empirical probability mass function p_k\n        p_hist, _ = np.histogram(x_N_samples, bins=bins, density=False)\n        p_k = p_hist / M\n        \n        # Theoretical probability mass function q_k for Beta(a,b)\n        q_k = beta.cdf(bins[1:], a, b) - beta.cdf(bins[:-1], a, b)\n        \n        # Smoothing and normalization to avoid log(0) and ensure sums are 1\n        epsilon = 1e-12\n        p_k_smoothed = np.maximum(p_k, epsilon)\n        q_k_smoothed = np.maximum(q_k, epsilon)\n        \n        p_k_norm = p_k_smoothed / np.sum(p_k_smoothed)\n        q_k_norm = q_k_smoothed / np.sum(q_k_smoothed)\n\n        # Calculate KL Divergence: D_KL(P || Q)\n        kl_div = np.sum(p_k_norm * np.log(p_k_norm / q_k_norm))\n        \n        # 3. Absolute error between empirical and theoretical mean leftover L_N\n        # Empirical mean of final leftover momentum\n        empirical_ln_mean = np.mean(final_leftover_L)\n        \n        # Theoretical mean E[L_N] = (b/(a+b))^N\n        theoretical_ln_mean = r**N\n        \n        # Absolute error calculation\n        err_ln = np.abs(empirical_ln_mean - theoretical_ln_mean)\n        \n        results.extend([rmse, kl_div, err_ln])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3535724"}]}