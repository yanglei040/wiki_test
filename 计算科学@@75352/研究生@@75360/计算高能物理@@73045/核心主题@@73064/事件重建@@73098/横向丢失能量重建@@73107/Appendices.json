{"hands_on_practices": [{"introduction": "在现代强子对撞机中，我们感兴趣的单个事件总是伴随着大量同时发生的、不那么有趣的碰撞，这种现象被称为“堆积”（pileup）。本练习 [@problem_id:3522767] 提供了两种广泛使用的算法——带电强子减除法（CHS）和每粒子堆积识别（PUPPI）——的实践操作，以减轻堆积效应的影响。通过实施这些方案，您将学习如何从原始的粒子流候选者列表中构建一个更稳健的缺失横向能量向量。", "problem": "给定每个事例的一组粒子流（PF）候选体，每个候选体在横向平面上由其横向动量分量、一个电荷标志、一个主顶点关联标志以及一个基于局域形状的权重来表征。您的任务是实现计算高能物理中用于堆积效应缓解和横向缺失能量（MET）重建的两种标准方案：带电强子减除（CHS）和逐粒子堆积识别（PUPPI）。从横向平面上的动量守恒以及 MET 定义为重建的横向动量矢量和的负值出发，对一个小的、明确指定的测试套件，计算两种方案下产生的 MET 矢量。\n\n基本原理：\n- 横向平面上的动量守恒意味着，对于一个由 PF 候选体组成的重建事例，其横向动量 $\\vec{p}_{T}^{(i)} = (p_{x}^{(i)}, p_{y}^{(i)})$ 以 $\\text{GeV}$ 为单位表示，横向缺失能量矢量的定义为横向动量的负矢量和：\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{i} \\vec{p}_{T}^{(i)} = \\left( E_{x}^{\\text{miss}}, E_{y}^{\\text{miss}} \\right) ,\n$$\n其中\n$$\nE_{x}^{\\text{miss}} = - \\sum_{i} p_{x}^{(i)}, \\quad E_{y}^{\\text{miss}} = - \\sum_{i} p_{y}^{(i)} ,\n$$\n其大小为\n$$\n\\left| \\vec{E}_{T}^{\\text{miss}} \\right| = \\sqrt{ \\left( E_{x}^{\\text{miss}} \\right)^{2} + \\left( E_{y}^{\\text{miss}} \\right)^{2} } .\n$$\n\n需要实现的定义：\n- 带电强子减除（CHS）：设每个 PF 候选体由元组 $\\left( p_{x}, p_{y}, q, b, w \\right)$ 定义，其中 $p_{x}$ 和 $p_{y}$ 以 $\\text{GeV}$ 为单位，$q \\in \\{0,1\\}$ 是一个电荷标志，其中 $q = 1$ 表示带电候选体，$q = 0$ 表示中性候选体，$b \\in \\{0,1\\}$ 表示主顶点关联，其中 $b = 1$ 表示与选定的主顶点相关联，$b = 0$ 表示与非主顶点相关联，$w \\in [0,1]$ 是 PUPPI 算法使用的基于局域形状的权重。在 CHS 中，包含所有中性候选体，无论 $b$ 值如何；仅当 $b = 1$ 时包含带电候选体；排除 $b = 0$ 的带电候选体。在 CHS 中，不对包含的候选体应用逐粒子重加权，也就是说，它们贡献其完整的 $\\left( p_{x}, p_{y} \\right)$。\n- 逐粒子堆积识别（PUPPI）：对于带电候选体，如果 $b = 1$，则设置有效权重 $\\alpha$ 等于 $1$；如果 $b = 0$，则设置其等于 $0$。对于中性候选体，设置 $\\alpha = w$。对于任何在区间 $\\left[0,1\\right]$ 之外的给定 $w$，将其限制在区间 $\\left[0,1\\right]$ 内。然后，计入总和的加权横向动量为 $\\alpha \\, \\vec{p}_{T}^{(i)} = \\left( \\alpha \\, p_{x}^{(i)}, \\alpha \\, p_{y}^{(i)} \\right)$。\n\n您的程序必须：\n- 实现使用上述定义的 CHS 和 PUPPI 方案计算 $\\vec{E}_{T}^{\\text{miss}}$。\n- 使用下面的测试套件，并为每个测试用例计算量 $E_{x}^{\\text{miss,CHS}}$、$E_{y}^{\\text{miss,CHS}}$、$\\left| \\vec{E}_{T}^{\\text{miss,CHS}} \\right|$、$E_{x}^{\\text{miss,PUPPI}}$、$E_{y}^{\\text{miss,PUPPI}}$ 和 $\\left| \\vec{E}_{T}^{\\text{miss,PUPPI}} \\right|$。\n- 所有输出均以 $\\text{GeV}$ 为单位，表示为浮点数。此任务不需要计算角度。\n\n测试套件（每个事例是 PF 候选体元组 $\\left( p_{x}, p_{y}, q, b, w \\right)$ 的列表，其中 $p_{x}$ 和 $p_{y}$ 以 $\\text{GeV}$ 为单位）：\n- 测试用例 1 (混合事例):\n  - $\\left( 35, 15, 1, 1, 1 \\right)$\n  - $\\left( -20, 5, 0, 0, 0.8 \\right)$\n  - $\\left( 10, -10, 1, 0, 0 \\right)$\n  - $\\left( -5, -7, 0, 0, 0.1 \\right)$\n  - $\\left( 1, 2, 1, 1, 1 \\right)$\n  - $\\left( -3, 4, 0, 0, 0.95 \\right)$\n- 测试用例 2 (无堆积效应，动量和平衡且有一个零候选体):\n  - $\\left( 10, 0, 1, 1, 1 \\right)$\n  - $\\left( -10, 0, 0, 0, 1 \\right)$\n  - $\\left( 0, 5, 1, 1, 1 \\right)$\n  - $\\left( 0, -5, 0, 0, 1 \\right)$\n  - $\\left( 0, 0, 0, 0, 0.3 \\right)$\n- 测试用例 3 (所有带电粒子均为堆积效应，中性粒子占主导):\n  - $\\left( 50, 0, 1, 0, 0 \\right)$\n  - $\\left( 5, 5, 0, 0, 0.2 \\right)$\n  - $\\left( -3, 7, 0, 0, 0.9 \\right)$\n  - $\\left( -2, -1, 0, 0, 0 \\right)$\n  - $\\left( -10, -10, 1, 0, 0 \\right)$\n- 测试用例 4 (边界权重和带电堆积效应):\n  - $\\left( 1, 0, 0, 0, 1 \\right)$\n  - $\\left( 100, 0, 0, 0, 0 \\right)$\n  - $\\left( -2, 0, 1, 1, 1 \\right)$\n  - $\\left( -3, 4, 1, 0, 0 \\right)$\n- 测试用例 5 (小动量的带电主顶点粒子和零权重中性粒子的数值稳定性):\n  - $\\left( 0.1, -0.1, 1, 1, 1 \\right)$\n  - $\\left( 20, -20, 0, 0, 0 \\right)$\n  - $\\left( -0.2, 0.2, 1, 0, 0 \\right)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是包含六个以 GeV 为单位的浮点数的列表，顺序为 $\\left[ E_{x}^{\\text{miss,CHS}}, E_{y}^{\\text{miss,CHS}}, \\left| \\vec{E}_{T}^{\\text{miss,CHS}} \\right|, E_{x}^{\\text{miss,PUPPI}}, E_{y}^{\\text{miss,PUPPI}}, \\left| \\vec{E}_{T}^{\\text{miss,PUPPI}} \\right| \\right]$，书写时无空格。例如，输出应类似于 $\\left[ [a_{1},b_{1},c_{1},d_{1},e_{1},f_{1}], [a_{2},b_{2},c_{2},d_{2},e_{2},f_{2}], \\dots \\right]$，其中每个 $a_{k}, b_{k}, \\dots, f_{k}$ 是以 GeV 为单位的浮点数。", "solution": "问题陈述已经过验证，被认为是有效的。它科学上基于高能物理中的动量守恒原理，其对带电强子减除（CHS）和逐粒子堆积识别（PUPPI）算法的定义清晰明确且适定，其表述是客观的。所提供的数据和条件是自洽的，足以推导出唯一解。\n\n任务是为一系列事例计算横向缺失能量（$\\vec{E}_{T}^{\\text{miss}}$），每个事例由粒子流（PF）候选体组成。$\\vec{E}_{T}^{\\text{miss}}$ 定义为选定的一组粒子的横向动量（$\\vec{p}_{T}$）的负矢量和。\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in \\text{selected}} \\vec{p}_{T}^{(i)}\n$$\n我们将应用两种不同的选择和加权方案，CHS 和 PUPPI，来确定每个事例中要求和的最终动量矢量集合。\n\n一个 PF 候选体 $i$ 由元组 $\\left( p_{x}^{(i)}, p_{y}^{(i)}, q^{(i)}, b^{(i)}, w^{(i)} \\right)$ 描述，其中 $\\vec{p}_{T}^{(i)} = (p_{x}^{(i)}, p_{y}^{(i)})$ 是横向动量，$q^{(i)}$ 是电荷标志（$1$ 表示带电，$0$ 表示中性），$b^{(i)}$ 是主顶点关联标志（$1$ 表示与主顶点（PV）关联，$0$ 表示不关联），$w^{(i)}$ 是 PUPPI 算法的权重。\n\n**带电强子减除 (CHS)**\n\n在 CHS 方案中，如果一个粒子是中性的，或者它是带电的且与主顶点相关联，那么它就被包含在动量和中。与主顶点不关联的带电粒子（堆积效应）被丢弃。不应用任何权重。\n要包含的粒子索引集合 $S_{\\text{CHS}}$ 定义为：\n$$\nS_{\\text{CHS}} = \\{ i \\mid (q^{(i)} = 0) \\lor (q^{(i)} = 1 \\land b^{(i)} = 1) \\}\n$$\nCHS 的总横向动量矢量为：\n$$\n\\vec{P}_{\\text{CHS}} = \\sum_{i \\in S_{\\text{CHS}}} \\vec{p}_{T}^{(i)} = \\left( \\sum_{i \\in S_{\\text{CHS}}} p_{x}^{(i)}, \\sum_{i \\in S_{\\text{CHS}}} p_{y}^{(i)} \\right)\n$$\n最终的 MET 矢量为 $\\vec{E}_{T}^{\\text{miss,CHS}} = -\\vec{P}_{\\text{CHS}}$。\n\n**逐粒子堆积识别 (PUPPI)**\n\n在 PUPPI 方案中，每个粒子都对总和有贡献，但带有一个特定的权重 $\\alpha^{(i)}$。对于带电粒子，权重是二元的：如果与主顶点关联则为 $1$，否则为 $0$。对于中性粒子，权重取自给定值 $w^{(i)}$，并被限制在区间 $[0, 1]$ 内。\n粒子 $i$ 的权重 $\\alpha^{(i)}$ 定义为：\n$$\n\\alpha^{(i)} =\n\\begin{cases}\n1  \\text{ if } q^{(i)} = 1 \\text{ and } b^{(i)} = 1 \\\\\n0  \\text{ if } q^{(i)} = 1 \\text{ and } b^{(i)} = 0 \\\\\n\\text{clamp}(w^{(i)}, 0, 1)  \\text{ if } q^{(i)} = 0\n\\end{cases}\n$$\nPUPPI 的总加权横向动量矢量为：\n$$\n\\vec{P}_{\\text{PUPPI}} = \\sum_{i} \\alpha^{(i)} \\vec{p}_{T}^{(i)} = \\left( \\sum_{i} \\alpha^{(i)} p_{x}^{(i)}, \\sum_{i} \\alpha^{(i)} p_{y}^{(i)} \\right)\n$$\n最终的 MET 矢量为 $\\vec{E}_{T}^{\\text{miss,PUPPI}} = -\\vec{P}_{\\text{PUPPI}}$。\n\n现在我们将这些算法应用于每个测试用例。\n\n**测试用例 1**\n粒子：$(35, 15, 1, 1, 1)$、$(-20, 5, 0, 0, 0.8)$、$(10, -10, 1, 0, 0)$、$(-5, -7, 0, 0, 0.1)$、$(1, 2, 1, 1, 1)$、$(-3, 4, 0, 0, 0.95)$。\n- **CHS:** 包含粒子 $1, 2, 4, 5, 6$。排除粒子 $3$（带电，非主顶点关联）。\n  $\\vec{P}_{\\text{CHS}} = (35, 15) + (-20, 5) + (-5, -7) + (1, 2) + (-3, 4) = (8, 19)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-8, -19)$。模长 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = \\sqrt{(-8)^2 + (-19)^2} = \\sqrt{64 + 361} = \\sqrt{425} \\approx 20.6155 \\text{ GeV}$。\n- **PUPPI:** 权重 $\\alpha$ 为: $1, 0.8, 0, 0.1, 1, 0.95$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(35, 15) + 0.8(-20, 5) + 0(10, -10) + 0.1(-5, -7) + 1(1, 2) + 0.95(-3, 4) = (35-16-0.5+1-2.85, 15+4-0.7+2+3.8) = (16.65, 24.1)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (-16.65, -24.1)$。模长 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(-16.65)^2 + (-24.1)^2} = \\sqrt{277.2225 + 580.81} = \\sqrt{858.0325} \\approx 29.2922 \\text{ GeV}$。\n\n**测试用例 2**\n粒子：$(10, 0, 1, 1, 1)$、$(-10, 0, 0, 0, 1)$、$(0, 5, 1, 1, 1)$、$(0, -5, 0, 0, 1)$、$(0, 0, 0, 0, 0.3)$。\n- **CHS:** 包含所有粒子（带电粒子与主顶点关联，其他为中性粒子）。\n  $\\vec{P}_{\\text{CHS}} = (10, 0) + (-10, 0) + (0, 5) + (0, -5) + (0, 0) = (0, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (0, 0)$。模长 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 0 \\text{ GeV}$。\n- **PUPPI:** 权重 $\\alpha$ 为: $1, 1, 1, 1, 0.3$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(10, 0) + 1(-10, 0) + 1(0, 5) + 1(0, -5) + 0.3(0, 0) = (0, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (0, 0)$。模长 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = 0 \\text{ GeV}$。\n\n**测试用例 3**\n粒子：$(50, 0, 1, 0, 0)$、$(5, 5, 0, 0, 0.2)$、$(-3, 7, 0, 0, 0.9)$、$(-2, -1, 0, 0, 0)$、$(-10, -10, 1, 0, 0)$。\n- **CHS:** 包含粒子 $2, 3, 4$（均为中性）。排除粒子 $1, 5$（带电，非主顶点关联）。\n  $\\vec{P}_{\\text{CHS}} = (5, 5) + (-3, 7) + (-2, -1) = (0, 11)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (0, -11)$。模长 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 11 \\text{ GeV}$。\n- **PUPPI:** 权重 $\\alpha$ 为: $0, 0.2, 0.9, 0, 0$。\n  $\\vec{P}_{\\text{PUPPI}} = 0.2(5, 5) + 0.9(-3, 7) = (1, 1) + (-2.7, 6.3) = (-1.7, 7.3)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (1.7, -7.3)$。模长 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(1.7)^2 + (-7.3)^2} = \\sqrt{2.89 + 53.29} = \\sqrt{56.18} \\approx 7.4953 \\text{ GeV}$。\n\n**测试用例 4**\n粒子：$(1, 0, 0, 0, 1)$、$(100, 0, 0, 0, 0)$、$(-2, 0, 1, 1, 1)$、$(-3, 4, 1, 0, 0)$。\n- **CHS:** 包含粒子 $1, 2, 3$。排除粒子 $4$（带电，非主顶点关联）。\n  $\\vec{P}_{\\text{CHS}} = (1, 0) + (100, 0) + (-2, 0) = (99, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-99, 0)$。模长 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = 99 \\text{ GeV}$。\n- **PUPPI:** 权重 $\\alpha$ 为: $1, 0, 1, 0$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(1, 0) + 1(-2, 0) = (-1, 0)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (1, 0)$。模长 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = 1 \\text{ GeV}$。\n\n**测试用例 5**\n粒子：$(0.1, -0.1, 1, 1, 1)$、$(20, -20, 0, 0, 0)$、$(-0.2, 0.2, 1, 0, 0)$。\n- **CHS:** 包含粒子 $1, 2$。排除粒子 $3$（带电，非主顶点关联）。\n  $\\vec{P}_{\\text{CHS}} = (0.1, -0.1) + (20, -20) = (20.1, -20.1)$。\n  $\\vec{E}_{T}^{\\text{miss,CHS}} = (-20.1, 20.1)$。模长 $|\\vec{E}_{T}^{\\text{miss,CHS}}| = \\sqrt{(-20.1)^2 + (20.1)^2} = \\sqrt{2 \\cdot 404.01} = 20.1\\sqrt{2} \\approx 28.4255 \\text{ GeV}$。\n- **PUPPI:** 权重 $\\alpha$ 为: $1, 0, 0$。\n  $\\vec{P}_{\\text{PUPPI}} = 1(0.1, -0.1) = (0.1, -0.1)$。\n  $\\vec{E}_{T}^{\\text{miss,PUPPI}} = (-0.1, 0.1)$。模长 $|\\vec{E}_{T}^{\\text{miss,PUPPI}}| = \\sqrt{(-0.1)^2 + (0.1)^2} = \\sqrt{0.02} = 0.1\\sqrt{2} \\approx 0.1414 \\text{ GeV}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Missing Transverse Energy (MET) using CHS and PUPPI schemes for a suite of test cases.\n    \"\"\"\n    # Test suite: each event is a list of PF candidate tuples\n    # (p_x, p_y, q, b, w) where p_x, p_y are in GeV.\n    test_cases = [\n        # Test case 1 (mixed event)\n        [\n            (35, 15, 1, 1, 1.0),\n            (-20, 5, 0, 0, 0.8),\n            (10, -10, 1, 0, 0.0),\n            (-5, -7, 0, 0, 0.1),\n            (1, 2, 1, 1, 1.0),\n            (-3, 4, 0, 0, 0.95),\n        ],\n        # Test case 2 (no pileup, balanced sums and a zero-candidate)\n        [\n            (10, 0, 1, 1, 1.0),\n            (-10, 0, 0, 0, 1.0),\n            (0, 5, 1, 1, 1.0),\n            (0, -5, 0, 0, 1.0),\n            (0, 0, 0, 0, 0.3),\n        ],\n        # Test case 3 (all charged are pileup, neutrals dominate)\n        [\n            (50, 0, 1, 0, 0.0),\n            (5, 5, 0, 0, 0.2),\n            (-3, 7, 0, 0, 0.9),\n            (-2, -1, 0, 0, 0.0),\n            (-10, -10, 1, 0, 0.0),\n        ],\n        # Test case 4 (boundary weights and charged pileup)\n        [\n            (1, 0, 0, 0, 1.0),\n            (100, 0, 0, 0, 0.0),\n            (-2, 0, 1, 1, 1.0),\n            (-3, 4, 1, 0, 0.0),\n        ],\n        # Test case 5 (numerical stability with small charged-PV momenta and zero-weight neutrals)\n        [\n            (0.1, -0.1, 1, 1, 1.0),\n            (20, -20, 0, 0, 0.0),\n            (-0.2, 0.2, 1, 0, 0.0),\n        ],\n    ]\n\n    results = []\n    for event in test_cases:\n        sum_p_chs = np.array([0.0, 0.0])\n        sum_p_puppi = np.array([0.0, 0.0])\n\n        for particle in event:\n            p_x, p_y, q, b, w = particle\n            p_T = np.array([p_x, p_y])\n\n            # Charged Hadron Subtraction (CHS) logic\n            # Include if neutral (q=0) or charged from primary vertex (q=1, b=1)\n            if q == 0 or (q == 1 and b == 1):\n                sum_p_chs += p_T\n\n            # PileUp Per Particle Identification (PUPPI) logic\n            alpha = 0.0\n            if q == 1:  # Charged particle\n                alpha = 1.0 if b == 1 else 0.0\n            else:  # Neutral particle\n                alpha = np.clip(w, 0.0, 1.0)\n            \n            sum_p_puppi += alpha * p_T\n\n        # Calculate MET vector (negative of the momentum sum)\n        met_chs = -sum_p_chs\n        met_puppi = -sum_p_puppi\n\n        # Calculate MET magnitude\n        mag_met_chs = np.linalg.norm(met_chs)\n        mag_met_puppi = np.linalg.norm(met_puppi)\n\n        # Store results for the current event\n        case_result = [\n            met_chs[0], met_chs[1], mag_met_chs,\n            met_puppi[0], met_puppi[1], mag_met_puppi,\n        ]\n        results.append(case_result)\n        \n    # Format the final output string as specified, without spaces in sub-lists.\n    formatted_results = []\n    for res in results:\n        # Manually format each sub-list to avoid spaces from standard list-to-string conversion.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        formatted_results.append(res_str)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3522767"}, {"introduction": "初始的缺失横向能量（MET）计算很少是最终版本，因为它必须通过各种校准来精炼，其中最重要的是喷注能量校准。在每次校准后都简单地重新计算整个 MET 向量，其计算成本非常高。本练习 [@problem_id:3522768] 要求您设计并实现一种高效的增量更新算法，这展示了在真实的高能物理数据分析中用于避免高昂重复计算的关键优化技术。", "problem": "设计并实现一个程序，该程序针对强子对撞机中的单个高能物理事件，在应用I型喷注能量修正时，增量式地更新横向缺失能量（MET）矢量，而无需重新计算可见横向动量的总和。请基于垂直于束流的平面内的动量守恒以及MET的定义来进行推导和算法设计。请从这些原理出发，严格推导增量更新规则，并分析您所用方法的计算复杂度。然后实现该算法，并在指定的测试集上运行。所有能量单位必须是吉电子伏特（GeV），所有方位角单位必须是弧度，输出中的任何角度都必须归一化到区间 $\\left(-\\pi,\\pi\\right]$ 内。输出的浮点数必须四舍五入到六位小数。\n\n使用的基本出发点和定义：\n- 横向缺失能量（MET）矢量，记作 $\\vec{E}_{T}^{\\text{miss}}$，由横向动量守恒条件定义：如果 $\\sum \\vec{p}_{T}^{\\text{vis}}$ 是事件中所有可见横向动量的矢量和，那么\n$$\n\\vec{E}_{T}^{\\text{miss}} + \\sum \\vec{p}_{T}^{\\text{vis}} = \\vec{0},\n$$\n因此\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum \\vec{p}_{T}^{\\text{vis}}.\n$$\n- 一个喷注具有原始横向动量大小 $p_{T,i}^{\\text{raw}}$ 和方位角 $\\phi_{i}$。其原始横向动量矢量为 $\\vec{p}_{T,i}^{\\text{raw}} = p_{T,i}^{\\text{raw}} \\left(\\cos \\phi_{i}, \\sin \\phi_{i}\\right)$。\n- 对喷注 $i$ 的I型喷注修正被建模为一个乘法因子 $c_{i}$，应用于原始喷注横向动量大小，产生修正后的矢量 $\\vec{p}_{T,i}^{\\text{corr}} = c_{i} \\, \\vec{p}_{T,i}^{\\text{raw}}$。相应的修正矢量是差值 $\\Delta \\vec{p}_{T,i} = \\vec{p}_{T,i}^{\\text{corr}} - \\vec{p}_{T,i}^{\\text{raw}} = \\left(c_{i} - 1\\right) \\, \\vec{p}_{T,i}^{\\text{raw}}$。\n- I型修正仅应用于满足筛选条件的喷注，即 $p_{T,i}^{\\text{raw}} \\ge T$ 和 $\\left|\\eta_{i}\\right|  \\eta_{\\max}$，其中 $\\eta_{i}$ 是喷注 $i$ 的赝快度，$T$ 是横向动量阈值，$\\eta_{\\max}$ 是赝快度接收度。\n\n任务要求：\n1. 基于上述原理，推导出一个增量更新规则，用于在应用一组I型修正 $\\left\\{c_{i}\\right\\}$ 时，从给定的原始MET矢量 $\\vec{E}_{T}^{\\text{miss,\\,raw}}$ 得到修正后的MET矢量 $\\vec{E}_{T}^{\\text{miss,\\,corr}}$。然后，推导当一部分喷注修正因子从 $\\left\\{c_{i}^{\\text{old}}\\right\\}$ 更新为 $\\left\\{c_{i}^{\\text{new}}\\right\\}$ 时，如何增量更新 $\\vec{E}_{T}^{\\text{miss}}$，而无需完全重新计算所有喷注的总和。\n2. 分析以下两种策略的时间和空间复杂度：\n   - 一种朴素的重新计算策略：在任何更新时，通过对所有被选中的喷注求和，从头开始重新计算完整的修正后MET。\n   - 一种增量策略：维护每个喷注的状态，并仅使用已更改的喷注来更新MET。请明确说明以喷注总数 $N$ 和一个更新批次中被更新的喷注数 $k$ 为变量的渐近复杂度。讨论三角函数求值的成本以及如何将其最小化。\n3. 将增量算法实现为一个确定性程序。您的程序必须：\n   - 不接受任何输入，也不读取任何文件。\n   - 硬编码以下测试集，每个测试集包含一个初始原始MET矢量 $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right)$（单位GeV），一个包含 $\\left(p_{T,i}^{\\text{raw}}, \\phi_{i}, \\eta_{i}\\right)$ 的喷注列表，一个由 $T$（单位GeV）和 $\\eta_{\\max}$（无量纲）定义的筛选条件，以及一个有序的更新批次列表。每个更新批次是从喷注索引到其新的修正因子 $c_{i}$ 的映射。对于每个测试用例，按顺序应用更新批次，并报告最终修正后的MET矢量及其极坐标表示。\n   - 使用筛选规则 $p_{T,i}^{\\text{raw}} \\ge T$ 和 $\\left|\\eta_{i}\\right|  \\eta_{\\max}$。未通过筛选的喷注在所有修正中都必须被忽略，即使为它们提供了 $c_{i}$ 值。\n   - 预计算并重用 $\\cos \\phi_{i}$ 和 $\\sin \\phi_{i}$ 以最小化三角函数的调用次数。\n   - 对于每个测试用例，计算并返回一个包含四个浮点数的列表：$\\left[E_{x}^{\\text{corr}}, E_{y}^{\\text{corr}}, E_{T}^{\\text{corr}}, \\phi^{\\text{corr}}\\right]$，其中 $E_{x}^{\\text{corr}}$ 和 $E_{y}^{\\text{corr}}$ 是最终修正后MET的分量（单位GeV），$E_{T}^{\\text{corr}} = \\sqrt{\\left(E_{x}^{\\text{corr}}\\right)^{2} + \\left(E_{y}^{\\text{corr}}\\right)^{2}}$ 是其大小（单位GeV），$\\phi^{\\text{corr}} = \\mathrm{atan2}\\!\\left(E_{y}^{\\text{corr}}, E_{x}^{\\text{corr}}\\right)$ 是其方位角（单位弧度），并归一化到 $\\left(-\\pi,\\pi\\right]$。\n   - 将每个浮点数四舍五入到恰好六位小数。\n\n需要实现的测试集：\n- 测试用例1（包含混合修正和一个低于阈值的喷注的通用情况）：\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(-30.0, 20.0\\right)$。\n  - 喷注：索引 $0$: $\\left(p_{T}, \\phi, \\eta\\right) = \\left(50.0, 0.3, 0.5\\right)$; 索引 $1$: $\\left(40.0, -2.5, 1.2\\right)$; 索引 $2$: $\\left(10.0, 1.5, 2.0\\right)$。\n  - 筛选条件：$T = 20.0$, $\\eta_{\\max} = 4.7$。\n  - 更新批次：批次 $1$: $\\{0 \\mapsto 1.10,\\, 1 \\mapsto 0.95,\\, 2 \\mapsto 1.20\\}$。\n- 测试用例2（没有被选中的喷注；MET不变）：\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(5.0, -5.0\\right)$。\n  - 喷注：索引 $0$: $\\left(15.0, 0.2, 0.3\\right)$; 索引 $1$: $\\left(18.0, -1.0, 5.1\\right)$; 索引 $2$: $\\left(35.0, 1.2, 5.5\\right)$。\n  - 筛选条件：$T = 20.0$, $\\eta_{\\max} = 4.7$。\n  - 更新批次：批次 $1$: $\\{0 \\mapsto 1.10,\\, 1 \\mapsto 1.05,\\, 2 \\mapsto 0.90\\}$。\n- 测试用例3（处于阈值边界和一个中性修正）：\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(0.0, 0.0\\right)$。\n  - 喷注：索引 $0$: $\\left(20.0, 0.7853981633974483, 0.0\\right)$; 索引 $1$: $\\left(100.0, -0.7853981633974483, 0.0\\right)$。\n  - 筛选条件：$T = 20.0$, $\\eta_{\\max} = 4.7$。\n  - 更新批次：批次 $1$: $\\{0 \\mapsto 1.05,\\, 1 \\mapsto 1.0\\}$。\n- 测试用例4（多个批次和一个被重复更新的喷注；另有一个被忽略的低于阈值的喷注）：\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(10.0, -12.0\\right)$。\n  - 喷注：索引 $0$: $\\left(45.0, 1.0, 0.3\\right)$; 索引 $1$: $\\left(60.0, -2.0, 2.0\\right)$; 索引 $2$: $\\left(18.0, 0.5, 0.1\\right)$。\n  - 筛选条件：$T = 20.0$, $\\eta_{\\max} = 4.7$。\n  - 更新批次：批次 $1$: $\\{0 \\mapsto 1.10,\\, 1 \\mapsto 0.90\\}$; 批次 $2$: $\\{1 \\mapsto 0.95,\\, 2 \\mapsto 1.50\\}$。\n- 测试用例5（角度在 $\\pm \\pi$ 附近的回绕）：\n  - $\\left(E_{x}^{\\text{raw}}, E_{y}^{\\text{raw}}\\right) = \\left(0.0, 0.0\\right)$。\n  - 喷注：索引 $0$: $\\left(30.0, 3.131592653589793, 0.0\\right)$; 索引 $1$: $\\left(50.0, -3.131592653589793, 0.0\\right)$。\n  - 筛选条件：$T = 20.0$, $\\eta_{\\max} = 4.7$。\n  - 更新批次：批次 $1$: $\\{0 \\mapsto 1.02,\\, 1 \\mapsto 1.02\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为逗号分隔的列表的列表，每个内部列表按 $\\left[E_{x}^{\\text{corr}}, E_{y}^{\\text{corr}}, E_{T}^{\\text{corr}}, \\phi^{\\text{corr}}\\right]$ 顺序排列，所有四个浮点数都四舍五入到六位小数，且不含空格。例如，总体结构必须是\n$[\\,[E_{x,1},E_{y,1},E_{T,1},\\phi_{1}],\\,[E_{x,2},E_{y,2},E_{T,2},\\phi_{2}],\\,\\ldots\\,]$。", "solution": "该问题要求设计并实现一种增量算法，用于在高能物理事件中应用喷注能量修正时更新横向缺失能量（MET）矢量。我们必须首先验证问题，然后从第一性原理推导更新规则，分析其计算复杂度，最后实现它。\n\n### **问题验证**\n\n问题陈述已经过评估，并被确定为 **有效**。\n\n1.  **提取的已知条件：**\n    *   MET的定义：$\\vec{E}_{T}^{\\text{miss}} = - \\sum \\vec{p}_{T}^{\\text{vis}}$。\n    *   原始喷注动量矢量：$\\vec{p}_{T,i}^{\\text{raw}} = p_{T,i}^{\\text{raw}} (\\cos \\phi_{i}, \\sin \\phi_{i})$。\n    *   I型喷注修正：$\\vec{p}_{T,i}^{\\text{corr}} = c_{i} \\, \\vec{p}_{T,i}^{\\text{raw}}$。\n    *   修正矢量：$\\Delta \\vec{p}_{T,i} = (c_{i} - 1) \\, \\vec{p}_{T,i}^{\\text{raw}}$。\n    *   喷注筛选标准：$p_{T,i}^{\\text{raw}} \\ge T$ 和 $|\\eta_{i}|  \\eta_{\\max}$。\n    *   所有必需的测试数据和输出格式规范均已提供。\n\n2.  **验证结论：**\n    *   **科学依据充分：** 该问题基于动量守恒基本原理，并采用了实验粒子物理学中的标准定义和程序（MET、喷注修正）。其内容在事实上是准确的。\n    *   **定义明确：** 所有必要信息，包括定义、初始条件、常数和测试数据，都已提供。任务具体，并能导出一个唯一的、确定性的解。\n    *   **客观性：** 问题使用精确、正式的语言陈述，没有歧义或主观论断。\n\n该问题是一个定义明确的物理学计算任务，适合进行严格求解。\n\n### **1. 增量更新规则的推导**\n\n我们从横向缺失能量矢量 $\\vec{E}_{T}^{\\text{miss}}$ 的基本定义开始，它是事件中所有可见粒子横向动量矢量和的负值。\n$$\n\\vec{E}_{T}^{\\text{miss}} = - \\sum_{\\text{all vis}} \\vec{p}_{T}^{\\text{vis}}\n$$\n所有可见粒子的集合可以划分为喷注和其他对象（例如，轻子、光子和未成簇能量）。根据定义，I型修正仅修改通过特定筛选标准的喷注的动量。设 $S$ 为满足筛选条件 $p_{T,i}^{\\text{raw}} \\ge T$ 和 $|\\eta_{i}|  \\eta_{\\max}$ 的喷注索引集合。\n\n在应用任何修正之前的总可见横向动量（“原始”状态）为：\n$$\n\\sum \\vec{p}_{T}^{\\text{vis, raw}} = \\sum_{i \\in \\text{all jets}} \\vec{p}_{T,i}^{\\text{raw}} + \\sum_{\\text{non-jet}} \\vec{p}_{T}^{\\text{non-jet, raw}}\n$$\n相应的原始MET为 $\\vec{E}_{T}^{\\text{miss, raw}} = - \\sum \\vec{p}_{T}^{\\text{vis, raw}}$。\n\n当应用I型修正时，一组修正因子 $\\{c_i\\}$ 被应用于选定的喷注 $i \\in S$。一个选定喷注的动量变为 $\\vec{p}_{T,i}^{\\text{corr}} = c_{i} \\vec{p}_{T,i}^{\\text{raw}}$。未被选中的喷注和非喷注对象的动量保持不变。新的总可见横向动量为：\n$$\n\\sum \\vec{p}_{T}^{\\text{vis, corr}} = \\sum_{i \\in S} \\vec{p}_{T,i}^{\\text{corr}} + \\sum_{i \\notin S} \\vec{p}_{T,i}^{\\text{raw}} + \\sum_{\\text{non-jet}} \\vec{p}_{T}^{\\text{non-jet, raw}}\n$$\n总可见动量的变化是修正后总和与原始总和之间的差值：\n$$\n\\Delta \\left(\\sum \\vec{p}_{T}^{\\text{vis}}\\right) = \\sum \\vec{p}_{T}^{\\text{vis, corr}} - \\sum \\vec{p}_{T}^{\\text{vis, raw}} = \\sum_{i \\in S} \\left(\\vec{p}_{T,i}^{\\text{corr}} - \\vec{p}_{T,i}^{\\text{raw}}\\right)\n$$\n使用修正矢量的定义，$\\Delta \\vec{p}_{T,i} = \\vec{p}_{T,i}^{\\text{corr}} - \\vec{p}_{T,i}^{\\text{raw}} = (c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}$，上式变为：\n$$\n\\Delta \\left(\\sum \\vec{p}_{T}^{\\text{vis}}\\right) = \\sum_{i \\in S} (c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}\n$$\n修正后的MET为 $\\vec{E}_{T}^{\\text{miss, corr}} = - \\sum \\vec{p}_{T}^{\\text{vis, corr}}$。MET的变化量为 $\\Delta \\vec{E}_{T}^{\\text{miss}} = \\vec{E}_{T}^{\\text{miss, corr}} - \\vec{E}_{T}^{\\text{miss, raw}} = - \\Delta (\\sum \\vec{p}_{T}^{\\text{vis}})$。因此，从原始MET得到修正后MET的第一个更新规则是：\n$$\n\\vec{E}_{T}^{\\text{miss, corr}} = \\vec{E}_{T}^{\\text{miss, raw}} - \\sum_{i \\in S} (c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}\n$$\n在初始步骤中，我们可以认为所有喷注的“旧”修正因子均为 $c_i=1$。\n\n现在，我们推导增量更新的规则。假设我们有一个用一组修正因子 $\\{c_i^{\\text{old}}\\}_{i \\in S}$ 计算出的MET矢量 $\\vec{E}_{T}^{\\text{miss, old}}$。\n$$\n\\vec{E}_{T}^{\\text{miss, old}} = \\vec{E}_{T}^{\\text{miss, raw}} - \\sum_{i \\in S} (c_i^{\\text{old}} - 1)\\vec{p}_{T,i}^{\\text{raw}}\n$$\n一个新的更新到达，针对喷注的子集 $K \\subseteq S$，将其修正因子更改为 $\\{c_i^{\\text{new}}\\}_{i \\in K}$。新的MET矢量 $\\vec{E}_{T}^{\\text{miss, new}}$ 将是：\n$$\n\\vec{E}_{T}^{\\text{miss, new}} = \\vec{E}_{T}^{\\text{miss, raw}} - \\left( \\sum_{i \\in K} (c_i^{\\text{new}} - 1)\\vec{p}_{T,i}^{\\text{raw}} + \\sum_{i \\in S \\setminus K} (c_i^{\\text{old}} - 1)\\vec{p}_{T,i}^{\\text{raw}} \\right)\n$$\nMET的增量变化是 $\\Delta \\vec{E}_{T}^{\\text{miss}} = \\vec{E}_{T}^{\\text{miss, new}} - \\vec{E}_{T}^{\\text{miss, old}}$。将两个表达式相减，我们得到：\n$$\n\\Delta \\vec{E}_{T}^{\\text{miss}} = \\left( - \\sum_{i \\in K} (c_i^{\\text{new}} - 1)\\vec{p}_{T,i}^{\\text{raw}} \\right) - \\left( - \\sum_{i \\in K} (c_i^{\\text{old}} - 1)\\vec{p}_{T,i}^{\\text{raw}} \\right)\n$$\n$$\n\\Delta \\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in K} \\left[ (c_i^{\\text{new}} - 1) - (c_i^{\\text{old}} - 1) \\right] \\vec{p}_{T,i}^{\\text{raw}}\n$$\n$$\n\\Delta \\vec{E}_{T}^{\\text{miss}} = - \\sum_{i \\in K} (c_i^{\\text{new}} - c_i^{\\text{old}}) \\vec{p}_{T,i}^{\\text{raw}}\n$$\n这就导出了MET矢量的最终增量更新规则：\n$$\n\\vec{E}_{T}^{\\text{miss, new}} = \\vec{E}_{T}^{\\text{miss, old}} - \\sum_{i \\in K} (c_i^{\\text{new}} - c_i^{\\text{old}}) \\vec{p}_{T,i}^{\\text{raw}}\n$$\n该规则表明，MET的更新方式是减去每个被更新喷注的动量变化量，该变化量与新旧修正因子之差成正比。\n\n### **2. 复杂度分析**\n\n设 $N$ 为事件中喷注的总数，$k$ 为一个更新批次中喷注的数量（其中 $k \\le N$）。\n\n**朴素的重新计算策略：**\n该策略在每次更新后从头重新计算MET。\n1.  从原始MET $\\vec{E}_{T}^{\\text{miss, raw}}$ 开始。\n2.  遍历所有 $N$ 个喷注。对每个喷注，检查其是否通过筛选标准。\n3.  对于每个选定的喷注 $i$，计算其对MET修正的贡献 $(c_i - 1)\\vec{p}_{T,i}^{\\text{raw}}$，并将其从运行中的MET总和中减去。\n*   **时间复杂度：** 主要操作是遍历所有 $N$ 个喷注。每次更新都必须执行此操作。因此，每次更新的时间复杂度为 $O(N)$。如果三角函数没有被预计算，将会有 $O(N_S)$ 次调用 `cos` 和 `sin` 的额外成本，其中 $N_S$ 是被选中喷注的数量。\n*   **空间复杂度：** 需要存储 $N$ 个喷注的原始属性及其修正因子，导致空间复杂度为 $O(N)$。\n\n**增量策略：**\n该策略维护MET的状态和每个喷注的修正，仅对已更改的喷注应用更新。\n1.  **一次性设置：**\n    a. 遍历所有 $N$ 个喷注以确定哪些被选中。\n    b. 为每个喷注预计算并存储原始横向动量的笛卡尔分量 $\\vec{p}_{T,i}^{\\text{raw}} = (p_{T,i}^{\\text{raw}} \\cos \\phi_i, p_{T,i}^{\\text{raw}} \\sin \\phi_i)$。这需要 $N$ 次三角函数调用。\n    c. 初始化一个当前修正因子数组，对所有 $i$ 设为 $c_i=1.0$。\n    设置成本为 $O(N)$。\n2.  **每次更新（针对 $k$ 个被更新的喷注）：**\n    a. 对于更新批次中的 $k$ 个喷注中的每一个：\n    b. 检查该喷注是否被选中。\n    c. 如果是，则检索其旧的修正因子 $c_i^{\\text{old}}$、新的因子 $c_i^{\\text{new}}$ 以及其预计算的 $\\vec{p}_{T,i}^{\\text{raw}}$。\n    d. 使用推导出的规则计算对MET的改变量：$-\\Delta c_i \\cdot \\vec{p}_{T,i}^{\\text{raw}}$，其中 $\\Delta c_i = c_i^{\\text{new}} - c_i^{\\text{old}}$。\n    e. 将此矢量变化量加到当前的MET矢量上。\n    f. 更新存储的因子：$c_i \\leftarrow c_i^{\\text{new}}$。\n*   **时间复杂度：** 设置成本为 $O(N)$。关键是，每次后续更新的成本仅取决于更新批次的大小 $k$。每次更新的复杂度为 $O(k)$。由于在典型应用中 $k \\ll N$，这是一个显著的改进。三角函数调用从更新循环中被移除，其成本被分摊到一次性设置中。\n*   **空间复杂度：** 需要为所有 $N$ 个喷注存储原始喷注数据、预计算的动量分量和当前的修正因子。空间复杂度为 $O(N)$。\n\n增量策略在每次更新的时间复杂度上提供了显著的性能优势，$O(k)$ 对比 $O(N)$，其代价是空间复杂度略大，但渐近上是相同的 $O(N)$。\n\n### **3. 算法实现**\n\n实现将遵循增量策略。对于每个测试用例，我们将：\n1.  用其原始值初始化MET。\n2.  执行一次性设置：为所有喷注预计算原始动量矢量，确定哪些喷注被选中，并将所有修正因子初始化为 $1.0$。\n3.  顺序处理每个更新批次。对于批次中的每个喷注，如果它被选中，则使用其预计算的原始动量应用增量更新公式。\n4.  处理完所有批次后，计算最终MET的大小和角度。\n5.  按规定格式化结果。\n\n最终的极坐标表示 $(E_{T}^{\\text{corr}}, \\phi^{\\text{corr}})$ 是从最终的笛卡尔分量 $(E_{x}^{\\text{corr}}, E_{y}^{\\text{corr}})$ 计算得出的：\n$$\nE_{T}^{\\text{corr}} = \\sqrt{(E_{x}^{\\text{corr}})^2 + (E_{y}^{\\text{corr}})^2}\n$$\n$$\n\\phi^{\\text{corr}} = \\mathrm{atan2}(E_{y}^{\\text{corr}}, E_{x}^{\\text{corr}})\n$$\n`atan2` 函数能正确处理所有象限，并确保角度在要求的区间 $(-\\pi, \\pi]$ 内。所有最终的浮点数都四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the incremental MET correction problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"raw_met\": (-30.0, 20.0),\n            \"jets\": [\n                (50.0, 0.3, 0.5),    # index 0\n                (40.0, -2.5, 1.2),   # index 1\n                (10.0, 1.5, 2.0),    # index 2\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.10, 1: 0.95, 2: 1.20}],\n        },\n        {\n            \"raw_met\": (5.0, -5.0),\n            \"jets\": [\n                (15.0, 0.2, 0.3),    # index 0\n                (18.0, -1.0, 5.1),   # index 1\n                (35.0, 1.2, 5.5),    # index 2\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.10, 1: 1.05, 2: 0.90}],\n        },\n        {\n            \"raw_met\": (0.0, 0.0),\n            \"jets\": [\n                (20.0, 0.7853981633974483, 0.0), # index 0\n                (100.0, -0.7853981633974483, 0.0),# index 1\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.05, 1: 1.0}],\n        },\n        {\n            \"raw_met\": (10.0, -12.0),\n            \"jets\": [\n                (45.0, 1.0, 0.3),    # index 0\n                (60.0, -2.0, 2.0),   # index 1\n                (18.0, 0.5, 0.1),    # index 2\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [\n                {0: 1.10, 1: 0.90},  # batch 1\n                {1: 0.95, 2: 1.50},  # batch 2\n            ],\n        },\n        {\n            \"raw_met\": (0.0, 0.0),\n            \"jets\": [\n                (30.0, 3.131592653589793, 0.0),  # index 0\n                (50.0, -3.131592653589793, 0.0), # index 1\n            ],\n            \"selection\": {\"T\": 20.0, \"eta_max\": 4.7},\n            \"updates\": [{0: 1.02, 1: 1.02}],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Initialize state for the current test case.\n        current_met_x, current_met_y = case[\"raw_met\"]\n        jets = case[\"jets\"]\n        selection_T = case[\"selection\"][\"T\"]\n        selection_eta_max = case[\"selection\"][\"eta_max\"]\n        num_jets = len(jets)\n\n        # State storage for the incremental algorithm.\n        jet_pT_xy_raw = np.zeros((num_jets, 2))\n        is_selected = [False] * num_jets\n        current_c = [1.0] * num_jets\n\n        # One-time setup: precomputation and initial selection.\n        for i, (pT_raw, phi, eta) in enumerate(jets):\n            # Check if jet passes selection criteria.\n            if pT_raw >= selection_T and abs(eta)  selection_eta_max:\n                is_selected[i] = True\n            \n            # Precompute raw momentum components to avoid repeated trig calls.\n            cos_phi = np.cos(phi)\n            sin_phi = np.sin(phi)\n            jet_pT_xy_raw[i] = [pT_raw * cos_phi, pT_raw * sin_phi]\n\n        # Process all update batches sequentially.\n        for batch in case[\"updates\"]:\n            for jet_idx, c_new in batch.items():\n                if is_selected[jet_idx]:\n                    c_old = current_c[jet_idx]\n                    delta_c = c_new - c_old\n                    \n                    pTx_raw, pTy_raw = jet_pT_xy_raw[jet_idx]\n                    \n                    # Apply the incremental update rule derived from momentum conservation.\n                    # E_miss_new = E_miss_old - (c_new - c_old) * pT_raw_jet\n                    current_met_x -= delta_c * pTx_raw\n                    current_met_y -= delta_c * pTy_raw\n                    \n                    # Update the stored correction factor for the jet.\n                    current_c[jet_idx] = c_new\n        \n        # Calculate final polar coordinates of the corrected MET.\n        corr_met_mag = np.sqrt(current_met_x**2 + current_met_y**2)\n        corr_met_phi = np.arctan2(current_met_y, current_met_x)\n\n        # Round all results to six decimal places and store them.\n        result = [\n            round(current_met_x, 6),\n            round(current_met_y, 6),\n            round(corr_met_mag, 6),\n            round(corr_met_phi, 6)\n        ]\n        all_results.append(result)\n\n    # Format the final output string exactly as specified, with no spaces.\n    results_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3522768"}, {"introduction": "在精确地重建了缺失横向能量（MET）向量之后，关键的下一步是评估其物理意义。一个非零的 MET 可能预示着新物理的存在，也可能仅仅是探测器分辨率和测量误差的结果。本练习 [@problem_id:3522796] 将引导您学习量化观测到的 MET 值显著性的统计框架，利用其协方差矩阵构建一个合适的检验统计量，并确定它由纯背景涨落产生的概率。", "problem": "在一次质子-质子对撞的横向缺失能量（MET）分析中，考虑一个单一事例，其测得的横向缺失能量矢量为 $\\vec{E}_T^{\\text{miss}} = (E_x, E_y)$，其中 $E_x = 36\\,\\text{GeV}$ 且 $E_y = -24\\,\\text{GeV}$。在真实横向缺失能量为零的原假设下，横向平面上探测器响应和重建不确定度的综合效应被建模为一个均值为零的二元高斯分布，其协方差矩阵已知\n$$\n\\mathbf{V} \\;=\\;\n\\begin{pmatrix}\n400  180 \\\\\n180  900\n\\end{pmatrix}\\,\\text{GeV}^2 \\, .\n$$\n从多元高斯似然的定义以及二次型的基本性质出发，推导出一个合适的检验统计量来评估无真实横向缺失能量的原假设，论证其在原假设下于二维空间中的抽样分布，并将对应的显著性 $S$ 定义为一个无量纲的量。然后，假设原假设为真，计算 $S$ 的数值以及观测到一个至少与测得的 $\\vec{E}_T^{\\text{miss}}$ 一样极端的涨落所对应的 $p$ 值。将 $S$ 和 $p$ 值均四舍五入至四位有效数字。将 $p$ 值表示为小数。最终数值中不包含任何单位。", "solution": "该问题要求推导一个用于评估原假设的检验统计量，说明其抽样分布，定义并计算相应的显著性 $S$，以及对于给定的横向缺失能量测量值计算相关的 $p$ 值。\n\n第一步：问题阐述与原假设\n测得的横向缺失能量矢量由 $\\vec{E}_T^{\\text{miss}} = (E_x, E_y)^T$ 给出，其中 $E_x = 36\\,\\text{GeV}$ 且 $E_y = -24\\,\\text{GeV}$。我们可以将此测量值表示为一个列向量 $\\vec{x} = \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}\\,\\text{GeV}$。\n原假设 $H_0$ 是不存在真实的横向缺失能量。在 $H_0$ 下，该测量值的期望值为零向量 $\\vec{\\mu}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\\,\\text{GeV}$。\n问题陈述，在 $H_0$ 下，探测器响应和重建不确定度的综合效应被建模为一个均值为 $\\vec{\\mu}_0$ 的二元高斯分布，且协方差矩阵 $\\mathbf{V}$ 给定如下：\n$$\n\\mathbf{V} =\n\\begin{pmatrix}\n400  180 \\\\\n180  900\n\\end{pmatrix}\\,\\text{GeV}^2\n$$\n因此，在 $H_0$ 下，测量向量 $\\vec{x}$ 是从一个二元正态分布 $\\vec{x} \\sim \\mathcal{N}(\\vec{0}, \\mathbf{V})$ 中抽取的样本。\n\n第二步：检验统计量的推导\n一个 $k$ 维多元正态分布的概率密度函数（PDF）为\n$$\nf(\\vec{x}; \\vec{\\mu}, \\mathbf{V}) = \\frac{1}{\\sqrt{(2\\pi)^k \\det(\\mathbf{V})}} \\exp\\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^T \\mathbf{V}^{-1}(\\vec{x}-\\vec{\\mu})\\right)\n$$\n在原假设 $H_0$ 下，我们有 $k=2$ 和 $\\vec{\\mu}=\\vec{0}$。观测到测量值 $\\vec{x}$ 的似然与在 $H_0$ 下评估的概率密度函数成正比：\n$$\nL(\\vec{x} | H_0) \\propto \\exp\\left(-\\frac{1}{2}\\vec{x}^T \\mathbf{V}^{-1}\\vec{x}\\right)\n$$\n指数中的二次型 $T = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ 是测量值 $\\vec{x}$ 相对于期望均值 $\\vec{0}$ 的马氏距离（Mahalanobis distance）的平方。这个量提供了一个衡量在原假设下观测值有多“极端”或多“不可能”的尺度。较大的 $T$ 值对应于与 $H_0$ 一致性较差的观测结果。因此，$T = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ 是适用于此问题的检验统计量。\n\n第三步：检验统计量的抽样分布\n多元正态分布的一个基本性质是，如果一个随机向量 $\\vec{X}$ 从一个 $k$ 维正态分布 $\\mathcal{N}(\\vec{\\mu}, \\mathbf{V})$ 中抽取，那么二次型 $T = (\\vec{X}-\\vec{\\mu})^T \\mathbf{V}^{-1} (\\vec{X}-\\vec{\\mu})$ 服从一个自由度为 $k$ 的卡方（$\\chi^2$）分布。\n在我们的例子中，在 $H_0$ 下，测量向量被假定为从一个均值为 $\\vec{\\mu}=\\vec{0}$ 的 $k=2$ 维正态分布中抽取。因此，我们的检验统计量 $T = \\vec{x}^T \\mathbf{V}^{-1}\\vec{x}$ 服从一个自由度为 2 的 $\\chi^2$ 分布，记为 $\\chi^2(2)$。\n\n第四步：显著性 $S$ 的定义\n观测值的显著性量化了其与原假设的不相容性。在横向缺失能量重建的背景下，一个常用且方便的显著性 $S$ 的定义是检验统计量 $T$ 的平方根。\n$$\nS \\equiv \\sqrt{T} = \\sqrt{\\vec{x}^T \\mathbf{V}^{-1}\\vec{x}}\n$$\n这个量是无量纲的，因为 $\\vec{x}^T$ 的单位是 $\\text{GeV}$，$\\mathbf{V}^{-1}$ 的单位是 $\\text{GeV}^{-2}$，$\\vec{x}$ 的单位是 $\\text{GeV}$，最终得到一个无量纲的乘积。这个定义在直觉上很有吸引力，因为它类似于一维情况下的标准分数 $Z = (x-\\mu)/\\sigma$，其中 $Z^2 = (x-\\mu)^2/\\sigma^2$ 是一维的 $\\chi^2$ 统计量。\n\n第五步：数值计算\n首先，我们必须计算协方差矩阵 $\\mathbf{V}$ 的逆矩阵。对于一个 $2 \\times 2$ 矩阵 $\\mathbf{A} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$，其逆矩阵为 $\\mathbf{A}^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$。\n对于我们的协方差矩阵 $\\mathbf{V} = \\begin{pmatrix} 400  180 \\\\ 180  900 \\end{pmatrix}$，其行列式为：\n$$\n\\det(\\mathbf{V}) = (400)(900) - (180)(180) = 360000 - 32400 = 327600\\,\\text{GeV}^4\n$$\n逆矩阵为：\n$$\n\\mathbf{V}^{-1} = \\frac{1}{327600}\n\\begin{pmatrix}\n900  -180 \\\\\n-180  400\n\\end{pmatrix}\\,\\text{GeV}^{-2}\n$$\n现在，我们可以为观测到的测量值 $\\vec{x} = \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}$ 计算检验统计量 $T_{obs}$ 的值：\n$$\nT_{obs} = \\vec{x}^T \\mathbf{V}^{-1} \\vec{x} = \\begin{pmatrix} 36  -24 \\end{pmatrix} \\frac{1}{327600} \\begin{pmatrix} 900  -180 \\\\ -180  400 \\end{pmatrix} \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\n\\begin{pmatrix} 900  -180 \\\\ -180  400 \\end{pmatrix} \\begin{pmatrix} 36 \\\\ -24 \\end{pmatrix} = \\begin{pmatrix} 900(36) + (-180)(-24) \\\\ -180(36) + 400(-24) \\end{pmatrix} = \\begin{pmatrix} 32400 + 4320 \\\\ -6480 - 9600 \\end{pmatrix} = \\begin{pmatrix} 36720 \\\\ -16080 \\end{pmatrix}\n$$\n接下来，我们计算最终的点积：\n$$\nT_{obs} = \\frac{1}{327600} \\begin{pmatrix} 36  -24 \\end{pmatrix} \\begin{pmatrix} 36720 \\\\ -16080 \\end{pmatrix} = \\frac{1}{327600} \\left( 36(36720) + (-24)(-16080) \\right)\n$$\n$$\nT_{obs} = \\frac{1321920 + 385920}{327600} = \\frac{1707840}{327600} \\approx 5.2131868\n$$\n现在我们计算显著性 $S$：\n$$\nS = \\sqrt{T_{obs}} \\approx \\sqrt{5.2131868} \\approx 2.2832404\n$$\n四舍五入到四位有效数字，我们得到 $S \\approx 2.283$。\n\n第六步：$p$ 值的计算\n$p$ 值是在假设 $H_0$ 为真的前提下，获得一个至少与观测值一样大的检验统计量值的概率。这对应于 $\\chi^2(2)$ 分布的上尾概率：\n$$\np = P(T \\ge T_{obs} | H_0) = \\int_{T_{obs}}^{\\infty} f_{\\chi^2(2)}(t) \\, dt\n$$\n自由度为 $k=2$ 的 $\\chi^2$ 分布的概率密度函数为 $f(t; 2) = \\frac{1}{2} \\exp(-t/2)$，其中 $t \\ge 0$。积分为：\n$$\np = \\int_{T_{obs}}^{\\infty} \\frac{1}{2} \\exp(-t/2) \\, dt = \\left[ -\\exp(-t/2) \\right]_{T_{obs}}^{\\infty} = 0 - (-\\exp(-T_{obs}/2)) = \\exp(-T_{obs}/2)\n$$\n使用计算出的 $T_{obs}$ 值：\n$$\np \\approx \\exp(-5.2131868 / 2) = \\exp(-2.6065934) \\approx 0.0737875\n$$\n将 $p$ 值四舍五入到四位有效数字，我们得到 $p \\approx 0.07379$。\n\n计算出的显著性为 $S \\approx 2.283$，相关的 $p$ 值为 $p \\approx 0.07379$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.283  0.07379\n\\end{pmatrix}\n}\n$$", "id": "3522796"}]}