{"hands_on_practices": [{"introduction": "在NLO和NNLO计算中，中间步骤的积分常常出现发散。这些发散并非物理上的无穷大，而是具有明确结构的奇点，需要通过分布理论来处理。本练习 [@problem_id:3524457] 聚焦于“加号分布”（plus-distribution），这是正则化部分子分裂函数等场景中出现的端点奇点的核心数学工具。通过从第一性原理出发推导其基本恒等式，您将深刻理解这些奇点是如何在数学上被系统性处理的。", "problem": "在微扰量子色动力学 (QCD) 中，次领头阶 (NLO) 和次次领头阶 (NNLO) 的截面包含端点增强项，这些项最自然地表达为在弹性极限附近有支撑的分布。一个核心例子是由函数 $z \\mapsto \\ln^{n}(1-z)/(1-z)$ 在区间 $z \\in (0,1)$ 上构建的 plus 分布族。考虑在 $[0,1]$ 上的光滑检验函数 $\\varphi$ 的空间。\n\n从分布的定义和通过可积核族 $(1-z)^{-1+\\epsilon}$（其中 $\\epsilon>0$）进行的解析正则化出发，完成以下任务：\n\n(a) 仅使用 plus 规定作为作用于检验函数的线性泛函的基本定义，以及映射 $\\epsilon \\mapsto \\int_{0}^{1} \\mathrm{d}z\\,(1-z)^{-1+\\epsilon}\\,\\varphi(z)$ 关于 $\\epsilon$ 的解析性，推导 $(1-z)^{-1+\\epsilon}$ 关于 $\\epsilon$ 的幂的分布展开式，其系数由 $\\ln^{n}(1-z)/(1-z)$ 生成的 plus 分布序列构成。你的推导必须从 plus 分布的定义开始，即它是一个通过对检验函数做减法来移除端点奇点的唯一分布，并且不得预先假设任何形式的目标恒等式。\n\n(b) 将 (a) 部分得到的一般作用具体化，计算积分\n$$\nI \\equiv \\int_{0}^{1} \\mathrm{d}z\\,\\left[\\frac{\\ln^{2}(1-z)}{1-z}\\right]_{+}\\,p(z),\n$$\n对于多项式检验函数 $p(z)=1+3z-2z^{2}$。将你的最终答案表示为一个精确的实数。无需四舍五入，不涉及单位。", "solution": "该问题分为两部分。(a) 部分要求推导一个在高能物理微扰计算中至关重要的分布恒等式。(b) 部分涉及直接应用此形式体系来计算一个特定的积分。\n\n(a) $(1-z)^{-1+\\epsilon}$ 的分布展开式推导\n\n我们首先考虑函数 $(1-z)^{-1+\\epsilon}$ 在区间 $z \\in [0,1]$ 上对光滑检验函数 $\\varphi(z)$ 的作用。对于 $\\Re(\\epsilon)>0$，该函数是可积的，我们可以定义一个线性泛函 $I(\\epsilon, \\varphi)$ 为\n$$\nI(\\epsilon, \\varphi) = \\int_{0}^{1} \\mathrm{d}z\\,(1-z)^{-1+\\epsilon}\\,\\varphi(z)\n$$\n这个积分在右半平面 $\\Re(\\epsilon)>0$ 上定义了一个关于 $\\epsilon$ 的解析函数。我们的目标是找到它在 $\\epsilon=0$ 附近的洛朗级数展开。在 $\\epsilon=0$ 处的极点源于积分端点 $z=1$ 处的奇点。\n\nplus 规定的基本定义是通过减去检验函数在奇点处的值来正则化此类端点奇点。我们通过在积分内加减 $\\varphi(1)$ 来应用此过程：\n$$\nI(\\epsilon, \\varphi) = \\int_{0}^{1} \\mathrm{d}z\\,(1-z)^{-1+\\epsilon} (\\varphi(z) - \\varphi(1)) + \\int_{0}^{1} \\mathrm{d}z\\,(1-z)^{-1+\\epsilon} \\varphi(1)\n$$\n我们分别分析这两项。\n\n第二项的计算很简单：\n$$\n\\int_{0}^{1} \\mathrm{d}z\\,(1-z)^{-1+\\epsilon} \\varphi(1) = \\varphi(1) \\left[ -\\frac{(1-z)^{\\epsilon}}{\\epsilon} \\right]_{0}^{1} = \\varphi(1) \\left( 0 - \\left(-\\frac{1^{\\epsilon}}{\\epsilon}\\right) \\right) = \\frac{1}{\\epsilon}\\varphi(1)\n$$\n该项包含了特征性的 $1/\\epsilon$ 极点。用分布的语言来说，作用 $\\varphi \\mapsto \\varphi(1)$ 对应于狄拉克 delta 分布 $\\delta(1-z)$，因此该项可以写成 $\\langle \\frac{1}{\\epsilon}\\delta(1-z), \\varphi \\rangle$。\n\n现在，我们分析第一项：\n$$\nI_1(\\epsilon, \\varphi) = \\int_{0}^{1} \\mathrm{d}z\\,(1-z)^{-1+\\epsilon} (\\varphi(z) - \\varphi(1))\n$$\n因为 $\\varphi(z)$ 是一个光滑函数，它在 $z=1$ 处是可微的。根据泰勒定理，在 $z=1$ 附近有 $\\varphi(z) - \\varphi(1) = \\varphi'(1)(z-1) + O((z-1)^2)$。因此，当 $z \\to 1$ 时，项 $(\\varphi(z) - \\varphi(1))$ 至少线性趋于零。被积函数在 $z=1$ 附近的行为是 $(1-z)^{-1+\\epsilon} \\times (-(1-z)\\varphi'(1)) \\sim (1-z)^{\\epsilon}$。这确保了积分 $I_1(\\epsilon, \\varphi)$ 对 $\\epsilon > -1$ 收敛，并且特别地，在 $\\epsilon=0$ 处是有限且正则的。\n\n$I_1(\\epsilon, \\varphi)$ 在 $\\epsilon=0$ 处的正则性允许我们将因子 $(1-z)^{-1+\\epsilon}$ 展开为关于 $\\epsilon$ 的泰勒级数，并逐项积分。我们使用指数函数的展开：\n$$\n(1-z)^{-1+\\epsilon} = \\frac{1}{1-z} (1-z)^{\\epsilon} = \\frac{1}{1-z} \\exp(\\epsilon \\ln(1-z)) = \\frac{1}{1-z} \\sum_{n=0}^{\\infty} \\frac{(\\epsilon \\ln(1-z))^n}{n!} = \\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\frac{\\ln^n(1-z)}{1-z}\n$$\n将此级数代入 $I_1(\\epsilon, \\varphi)$ 并交换求和与积分的顺序（这由 $\\epsilon$ 在 0 的一个小邻域内的一致收敛性所保证）：\n$$\nI_1(\\epsilon, \\varphi) = \\int_{0}^{1} \\mathrm{d}z\\,\\left(\\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\frac{\\ln^n(1-z)}{1-z}\\right) (\\varphi(z) - \\varphi(1)) = \\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\int_{0}^{1} \\mathrm{d}z\\,\\frac{\\ln^n(1-z)}{1-z} (\\varphi(z) - \\varphi(1))\n$$\n此表达式中的积分正是 plus 分布 $\\left[\\frac{\\ln^n(1-z)}{1-z}\\right]_+$ 对检验函数 $\\varphi(z)$ 作用的定义。即，\n$$\n\\left\\langle \\left[\\frac{\\ln^n(1-z)}{1-z}\\right]_+, \\varphi \\right\\rangle \\equiv \\int_{0}^{1} \\mathrm{d}z\\,\\frac{\\ln^n(1-z)}{1-z} (\\varphi(z) - \\varphi(1))\n$$\n因此，第一项可以写成一个关于 $\\epsilon$ 的幂级数，其系数是这些 plus 分布的作用：\n$$\nI_1(\\epsilon, \\varphi) = \\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\left\\langle \\left[\\frac{\\ln^n(1-z)}{1-z}\\right]_+, \\varphi \\right\\rangle\n$$\n结合两部分，完整的作用是：\n$$\nI(\\epsilon, \\varphi) = \\frac{1}{\\epsilon}\\varphi(1) + \\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\left\\langle \\left[\\frac{\\ln^n(1-z)}{1-z}\\right]_+, \\varphi \\right\\rangle\n$$\n这可以完全用分布作用来表示：\n$$\n\\langle (1-z)^{-1+\\epsilon}, \\varphi \\rangle = \\left\\langle \\frac{1}{\\epsilon}\\delta(1-z), \\varphi \\right\\rangle + \\left\\langle \\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\left[\\frac{\\ln^n(1-z)}{1-z}\\right]_+, \\varphi \\right\\rangle\n$$\n由于此等式对所有光滑检验函数 $\\varphi$ 都成立，我们可以在分布的层面上陈述该恒等式：\n$$\n(1-z)^{-1+\\epsilon} = \\frac{1}{\\epsilon}\\delta(1-z) + \\sum_{n=0}^{\\infty} \\frac{\\epsilon^n}{n!} \\left[\\frac{\\ln^n(1-z)}{1-z}\\right]_+\n$$\n这就是所求的分布展开式。\n\n(b) 积分的计算\n\n我们被要求计算积分\n$$\nI = \\int_{0}^{1} \\mathrm{d}z\\,\\left[\\frac{\\ln^{2}(1-z)}{1-z}\\right]_{+}\\,p(z)\n$$\n对于多项式检验函数 $p(z)=1+3z-2z^{2}$。\n\n这个积分是 plus 分布 $\\left[\\frac{\\ln^{2}(1-z)}{1-z}\\right]_+$ 对 $p(z)$ 的作用。根据 (a) 部分中 $n=2$ 时使用的定义，它由下式给出：\n$$\nI = \\int_{0}^{1} \\mathrm{d}z\\,\\frac{\\ln^{2}(1-z)}{1-z} (p(z) - p(1))\n$$\n首先，我们计算减法常数 $p(1)$：\n$$\np(1) = 1 + 3(1) - 2(1)^2 = 1+3-2 = 2\n$$\n接下来，我们构建多项式 $p(z)-p(1)$：\n$$\np(z) - p(1) = (1+3z-2z^2) - 2 = -2z^2+3z-1\n$$\n根据构造要求，该多项式在 $z=1$ 处有一个根。我们可以对其进行因式分解以明确这一点：\n$$\n-2z^2+3z-1 = -(2z^2-3z+1) = -(2z-1)(z-1) = (1-z)(2z-1)\n$$\n将此代回积分中，分母 $(1-z)$ 被消去：\n$$\nI = \\int_{0}^{1} \\mathrm{d}z\\,\\frac{\\ln^{2}(1-z)}{1-z} (1-z)(2z-1) = \\int_{0}^{1} \\mathrm{d}z\\,\\ln^{2}(1-z)(2z-1)\n$$\n为了计算这个正则积分，我们进行变量替换。令 $u=1-z$。则 $\\mathrm{d}u = -\\mathrm{d}z$，且 $z=1-u$。积分限从 $z=0 \\to u=1$ 和 $z=1 \\to u=0$ 变化。项 $(2z-1)$ 变为 $2(1-u)-1 = 2-2u-1 = 1-2u$。\n$$\nI = \\int_{1}^{0} \\ln^{2}(u)(1-2u)(-\\mathrm{d}u) = \\int_{0}^{1} \\ln^{2}(u)(1-2u)\\mathrm{d}u\n$$\n我们可以将其分成两个积分：\n$$\nI = \\int_{0}^{1} \\ln^{2}(u)\\mathrm{d}u - 2\\int_{0}^{1} u\\ln^{2}(u)\\mathrm{d}u\n$$\n我们使用分部积分法计算每个积分。对于第一个积分，令 $f=\\ln^2(u)$ 和 $g'=1$：\n$$\n\\int \\ln^2(u)\\mathrm{d}u = u\\ln^2(u) - \\int u \\cdot 2\\ln(u)\\frac{1}{u}\\mathrm{d}u = u\\ln^2(u) - 2\\int\\ln(u)\\mathrm{d}u\n$$\n$\\ln(u)$ 的积分是 $u\\ln(u)-u$。所以，\n$$\n\\int \\ln^2(u)\\mathrm{d}u = u\\ln^2(u) - 2(u\\ln(u)-u) = u\\ln^2(u) - 2u\\ln(u) + 2u\n$$\n计算定积分：\n$$\n\\int_{0}^{1} \\ln^{2}(u)\\mathrm{d}u = [u\\ln^2(u) - 2u\\ln(u) + 2u]_{0}^{1} = (1(0)^2 - 2(1)(0) + 2(1)) - \\lim_{u\\to 0^+} (u\\ln^2(u) - 2u\\ln(u) + 2u) = 2 - 0 = 2\n$$\n对于第二个积分，我们使用分部积分法，令 $f=\\ln^2(u)$ 和 $g'=u$：\n$$\n\\int u\\ln^2(u)\\mathrm{d}u = \\frac{u^2}{2}\\ln^2(u) - \\int \\frac{u^2}{2} \\cdot 2\\ln(u)\\frac{1}{u}\\mathrm{d}u = \\frac{u^2}{2}\\ln^2(u) - \\int u\\ln(u)\\mathrm{d}u\n$$\n我们对 $u\\ln(u)$ 进行分部积分：$\\int u\\ln(u)\\mathrm{d}u = \\frac{u^2}{2}\\ln(u) - \\int \\frac{u^2}{2}\\frac{1}{u}\\mathrm{d}u = \\frac{u^2}{2}\\ln(u) - \\frac{u^2}{4}$。所以，\n$$\n\\int u\\ln^2(u)\\mathrm{d}u = \\frac{u^2}{2}\\ln^2(u) - \\left(\\frac{u^2}{2}\\ln(u) - \\frac{u^2}{4}\\right) = \\frac{u^2}{2}\\ln^2(u) - \\frac{u^2}{2}\\ln(u) + \\frac{u^2}{4}\n$$\n计算定积分：\n$$\n\\int_{0}^{1} u\\ln^{2}(u)\\mathrm{d}u = \\left[\\frac{u^2}{2}\\ln^2(u) - \\frac{u^2}{2}\\ln(u) + \\frac{u^2}{4}\\right]_{0}^{1} = \\left(\\frac{1}{2}(0) - \\frac{1}{2}(0) + \\frac{1}{4}\\right) - (0) = \\frac{1}{4}\n$$\n最后，我们合并结果以求得 $I$：\n$$\nI = 2 - 2\\left(\\frac{1}{4}\\right) = 2 - \\frac{1}{2} = \\frac{3}{2}\n$$\n该积分的值是一个精确的实数。", "answer": "$$\n\\boxed{\\frac{3}{2}}\n$$", "id": "3524457"}, {"introduction": "掌握了处理奇点的数学工具后，下一步是确保我们计算的物理量是有意义的。一个核心原则是，任何物理预测都不能依赖于计算中引入的任意调节因子，这一性质被称为红外与共线（IRC）安全性。本练习 [@problem_id:3524491] 提供了一个实践性极强的计算任务，通过它您可以亲手验证IRC安全性的重要性，并观察一个不安全的观测量如何导致预测结果依赖于非物理的调节因子。", "problem": "考虑在次次领头阶 (NNLO) 上的质子-质子散射到双喷注的过程。重点关注软-共线极限下的双实发射贡献，在此极限下，相对于它们的母喷注，会发射出两个额外的部分子，其无量纲能量分数为 $z_1$ 和 $z_2$，以及一个描述角间距平方的共线变量 $t$。在量子色动力学 (QCD) 的软-共线因子分解极限中，双实相空间权重正比于 $dz_1\\,dz_2\\,dt$ 乘以普适奇异核 $1/(z_1 z_2 t)$。为了计算方便，引入一个下限调节子 $\\lambda \\in (0,1)$，通过强制要求 $z_1 \\ge \\lambda$、$z_2 \\ge \\lambda$ 和 $t \\ge \\lambda$ 来截断软和共线奇异区域。设 $R \\in (\\lambda,1]$ 是一个喷注半径参数，它通过条件 $t  R$ 来确定一个聚类区域。\n\n通过测量函数 $G(z_1,z_2,t;R)$ 定义一类可观测量，并考虑无量纲的积分双实贡献\n$$\nI(\\lambda,R;G) \\equiv \\int_{\\lambda}^{1} \\int_{\\lambda}^{1} \\int_{\\lambda}^{1} \\frac{dz_1}{z_1} \\frac{dz_2}{z_2} \\frac{dt}{t}\\; G(z_1,z_2,t;R).\n$$\n在软-共线极限下，红外和共线 (IRC) 安全性要求测量函数在任何变量 $z_1$、$z_2$ 或 $t$ 趋于零时适当地为零。为了测试红外 (IR) 安全性并揭示双实极限中对调节子的依赖性，考虑以下人为构造但数学上良定的测量函数，这些函数模拟了聚类区域 $t  R$ 内的测量：\n1. IRC 安全：$G_{\\text{safe}}(z_1,z_2,t;R) = z_1\\,z_2\\,t\\,\\Theta(R-t)$\n2. 共线安全，软不安全：$G_{\\text{s-unsafe}}(z_1,z_2,t;R) = z_1\\,z_2\\,\\Theta(R-t)$\n3. 软安全，共线不安全：$G_{\\text{c-unsafe}}(z_1,z_2,t;R) = t\\,\\Theta(R-t)$\n4. 软和共线均不安全：$G_{\\text{bad}}(z_1,z_2,t;R) = \\Theta(R-t)$\n\n您的任务是编写一个 Python 3 函数 `solve()`，该函数为以下五个测试用例的每个元组 `(lambda, R, type)` 计算积分 $I(\\lambda,R;G)$ 的值，其中 `type` 是字符串 \"safe\"、\"s-unsafe\"、\"c-unsafe\" 或 \"bad\" 之一：\n1. `(1e-12, 0.4, \"safe\")`\n2. `(1e-6, 0.4, \"s-unsafe\")`\n3. `(1e-6, 0.4, \"c-unsafe\")`\n4. `(1e-6, 0.4, \"bad\")`\n5. `(1e-9, 1e-9, \"safe\")`（$R=\\lambda$ 的边界聚类情况）\n\n您的函数必须按顺序打印一个包含五个浮点数结果的列表，用方括号括起来，并用逗号分隔，无任何其他文本。例如：`[result1, result2, result3, result4, result5]`。结果应以标准浮点数表示法格式化，至少有 15 位精度。", "solution": "任务是计算积分\n$$\nI(\\lambda,R;G) \\equiv \\int_{\\lambda}^{1} \\int_{\\lambda}^{1} \\int_{\\lambda}^{1} \\frac{dz_1}{z_1} \\frac{dz_2}{z_2} \\frac{dt}{t}\\; G(z_1,z_2,t;R)\n$$\n针对四种不同的测量函数 $G$。所有四个函数 $G$ 都包含一个亥维赛阶跃函数 $\\Theta(R-t)$，它强制施加喷注聚类条件 $t  R$。如果 $t  R$，该因子为 $1$，否则为 $0$。这个因子的存在有效地修改了变量 $t$ 的积分上下限。原始的积分限是 $[\\lambda, 1]$。条件 $t  R$ 进一步限制了这个域。鉴于问题陈述 $R \\in (\\lambda, 1]$（我们将其解释为 $R \\in [\\lambda, 1]$ 以适应 $R=\\lambda$ 的测试用例），对 $t$ 的积分仅在区间 $[\\lambda, R]$ 上非零。因此，积分的一般形式变为：\n$$\nI(\\lambda,R;G) = \\int_{\\lambda}^{1} \\frac{dz_1}{z_1} \\int_{\\lambda}^{1} \\frac{dz_2}{z_2} \\int_{\\lambda}^{R} \\frac{dt}{t}\\; G_0(z_1,z_2,t)\n$$\n其中 $G_0(z_1,z_2,t)$ 是移除了 $\\Theta(R-t)$ 因子的相应测量函数 $G$。对 $z_1$、$z_2$ 和 $t$ 的积分现在是可分离的。我们将需要以下基本积分：\n$$\n\\int_{\\lambda}^{1} dz = [z]_{\\lambda}^{1} = 1 - \\lambda\n$$\n$$\n\\int_{\\lambda}^{1} \\frac{dz}{z} = [\\ln z]_{\\lambda}^{1} = \\ln(1) - \\ln(\\lambda) = -\\ln(\\lambda) = \\ln\\left(\\frac{1}{\\lambda}\\right)\n$$\n$$\n\\int_{\\lambda}^{R} dt = [t]_{\\lambda}^{R} = R - \\lambda\n$$\n$$\n\\int_{\\lambda}^{R} \\frac{dt}{t} = [\\ln t]_{\\lambda}^{R} = \\ln(R) - \\ln(\\lambda) = \\ln\\left(\\frac{R}{\\lambda}\\right)\n$$\n我们现在为四个指定的函数分别推导 $I(\\lambda,R;G)$ 的表达式。\n\n情况 1：$G_{\\text{safe}}(z_1,z_2,t;R) = z_1\\,z_2\\,t\\,\\Theta(R-t)$\n被积函数，包括相空间权重在内，是 $\\frac{1}{z_1 z_2 t} (z_1 z_2 t) = 1$。积分为：\n$$\nI_{\\text{safe}}(\\lambda, R) = \\int_{\\lambda}^{1} dz_1 \\int_{\\lambda}^{1} dz_2 \\int_{\\lambda}^{R} dt\n$$\n代入基本积分的结果：\n$I_{\\text{safe}}(\\lambda, R) = (1 - \\lambda)^2 (R - \\lambda)$\n在极限 $\\lambda \\to 0$ 下，$I_{\\text{safe}} \\to (1-0)^2 (R-0) = R$。这是一个有限的、与调节子无关的结果，证实了该测量函数的 IRC 安全性质。\n\n情况 2：$G_{\\text{s-unsafe}}(z_1,z_2,t;R) = z_1\\,z_2\\,\\Theta(R-t)$\n被积函数是 $\\frac{1}{z_1 z_2 t} (z_1 z_2) = \\frac{1}{t}$。积分为：\n$$\nI_{\\text{s-unsafe}}(\\lambda, R) = \\int_{\\lambda}^{1} dz_1 \\int_{\\lambda}^{1} dz_2 \\int_{\\lambda}^{R} \\frac{dt}{t}\n$$\n代入结果：\n$I_{\\text{s-unsafe}}(\\lambda, R) = (1 - \\lambda)^2 \\ln\\left(\\frac{R}{\\lambda}\\right)$\n在极限 $\\lambda \\to 0$ 下，$\\ln(R/\\lambda) = \\ln(R) - \\ln(\\lambda)$ 项的存在导致了对数发散。这表明了可观测量在共线 ($t \\to 0$) 极限下未能保持安全的后果。\n\n情况 3：$G_{\\text{c-unsafe}}(z_1,z_2,t;R) = t\\,\\Theta(R-t)$\n被积函数是 $\\frac{1}{z_1 z_2 t} (t) = \\frac{1}{z_1 z_2}$。积分为：\n$$\nI_{\\text{c-unsafe}}(\\lambda, R) = \\int_{\\lambda}^{1} \\frac{dz_1}{z_1} \\int_{\\lambda}^{1} \\frac{dz_2}{z_2} \\int_{\\lambda}^{R} dt\n$$\n代入结果：\n$I_{\\text{c-unsafe}}(\\lambda, R) = \\left(\\ln\\left(\\frac{1}{\\lambda}\\right)\\right)^2 (R - \\lambda)$\n在极限 $\\lambda \\to 0$ 下，$(\\ln(1/\\lambda))^2$ 项导致了更严重的对数发散，这是测量函数在软 ($z_1 \\to 0$ 或 $z_2 \\to 0$) 极限下未能保持安全的后果。\n\n情况 4：$G_{\\text{bad}}(z_1,z_2,t;R) = \\Theta(R-t)$\n被积函数是相空间权重本身，$\\frac{1}{z_1 z_2 t}$。积分为：\n$$\nI_{\\text{bad}}(\\lambda, R) = \\int_{\\lambda}^{1} \\frac{dz_1}{z_1} \\int_{\\lambda}^{1} \\frac{dz_2}{z_2} \\int_{\\lambda}^{R} \\frac{dt}{t}\n$$\n代入结果：\n$I_{\\text{bad}}(\\lambda, R) = \\left(\\ln\\left(\\frac{1}{\\lambda}\\right)\\right)^2 \\ln\\left(\\frac{R}{\\lambda}\\right)$\n该函数表现出软和共线不安全极限的组合发散，导致了最强的调节子依赖性，在 $\\lambda \\to 0$ 时表现为 $(\\ln(1/\\lambda))^3$。\n\n这些解析表达式构成了为给定测试套件求解所需的计算实现的基础。注意，对于任何 $R = \\lambda$ 的情况， $t$ 的积分域变为 $[\\lambda, \\lambda]$，这是一个零测集。因此，对 $t$ 的积分为零，使得总积分 $I(\\lambda,R;G)$ 等于 $0$。我们推导的公式正确地反映了这一点：$R-\\lambda$ 变为 $0$，且 $\\ln(R/\\lambda) = \\ln(1) = 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the integrated double-real contribution I(lambda, R; G) \n    for different measurement functions G based on pre-derived analytic expressions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-12, 0.4, \"safe\"),\n        (1e-6, 0.4, \"s-unsafe\"),\n        (1e-6, 0.4, \"c-unsafe\"),\n        (1e-6, 0.4, \"bad\"),\n        (1e-9, 1e-9, \"safe\"), # R == lam, a boundary clustering case\n    ]\n\n    results = []\n    for lam, R, case_type in test_cases:\n        result = 0.0\n\n        # Special handling for the boundary case R==lam, where all integrals are zero.\n        # The analytic formulas naturally handle this, but explicit check avoids\n        # potential floating point issues with log(1) or R-lam.\n        if R == lam:\n            result = 0.0\n        elif case_type == \"safe\":\n            # Formula: I_safe = (1 - lam)^2 * (R - lam)\n            result = (1 - lam)**2 * (R - lam)\n        elif case_type == \"s-unsafe\":\n            # Formula: I_s-unsafe = (1 - lam)^2 * ln(R / lam)\n            result = (1 - lam)**2 * np.log(R / lam)\n        elif case_type == \"c-unsafe\":\n            # Formula: I_c-unsafe = (ln(1 / lam))^2 * (R - lam)\n            result = (np.log(1 / lam))**2 * (R - lam)\n        elif case_type == \"bad\":\n            # Formula: I_bad = (ln(1 / lam))^2 * ln(R / lam)\n            result = (np.log(1 / lam))**2 * np.log(R / lam)\n            \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard floating point representation.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3524491"}, {"introduction": "在高阶计算中，即使是对于一个IRC安全的观测量，计算过程中的技术选择也可能引入不一致性，一个典型的例子是在维度正则化中如何处理 $\\gamma_5$ 矩阵。最终的物理结果必须满足诸如瓦德等式（Ward identities）之类的基本对称性原理，这通常要求我们引入特定的有限重整化项来修正由正则化方案破坏的对称性。本练习 [@problem_id:3524525] 以 't Hooft–Veltman 和 Larin 两种 $\\gamma_5$ 方案为例，让您亲身体验如何通过有限重整化来确保理论的自洽性与最终结果的方案无关性。", "problem": "要求您实现一个最小的、自洽的计算模型，以追踪在次领头阶 (NLO) 量子色动力学 (QCD) 中，对于质子-质子产生一个中性矢量玻色子并伴随一个反冲射流过程中的宇称奇特可观测量，其轴矢流的方案依赖性。重点在于量纲正则化中手征矩阵 $\\gamma_5$ 的处理，比较 Larin 方案和 ’t Hooft–Veltman (HV) 方案。任务是建立在 $\\mathcal{O}(\\alpha_s)$ 阶的方案依赖性模型，应用非单态轴矢流的有限重整化，并验证由轴矢流的单个插入构成的可观测量满足轴矢 Ward 恒等式，这体现在经过方案修正后的预测值相等。本问题中的的所有量均为无量纲量，不涉及物理单位。\n\n基本背景和定义：\n- 在 $d=4-2\\epsilon$ 维的量纲正则化 QCD 中，对手征矩阵 $\\gamma_5$ 的处理是依赖于方案的。两种标准方案是 Larin 方案和 ’t Hooft–Veltman (HV) 方案。\n- 非单态轴矢流定义为 $J_5^\\mu = \\bar{\\psi}\\gamma^\\mu \\gamma_5 \\psi$。在量纲正则化存在的情况下，Larin 方案需要对非单态轴矢流进行有限重整化以恢复 Ward 恒等式。将有限重整化记为 $Z_5^{\\text{ns}}$，其微扰展开为 $Z_5^{\\text{ns}} = 1 + z_1 a_s + \\mathcal{O}(a_s^2)$，其中 $a_s = \\alpha_s/(4\\pi)$，$ \\alpha_s$ 是强耦合常数。\n- 考虑在 $pp \\to Z+\\text{jet}$ 过程中一个宇称奇特的可观测量 $\\mathcal{O}$，它与中性流到夸克的轴矢耦合呈线性关系。将矢量和轴矢耦合分别记为 $g_V$ 和 $g_A$，运动学原因子记为 $K$，使得玻恩阶贡献为 $\\mathcal{O}_0 = K\\, g_V g_A$。\n- 对该可观测量的 NLO QCD 修正可参数化为 $\\mathcal{O} = \\mathcal{O}_0 \\left(1 + c_1 a_s\\right) + \\delta_{\\text{scheme}}$，其中 $c_1$ 是一个捕捉普适 QCD 修正的方案无关系数，而 $\\delta_{\\text{scheme}}$ 是一个依赖于方案的有限位移，源于单圈水平上 $\\gamma_5$ 的定义。规范不变性和颜色结构意味着，在此阶上，方案依赖性必须与玻恩结构成正比，其颜色因子由基本表示中的二次 Casimir 算符 $C_F$ 给出。\n- 轴矢 Ward 恒等式要求物理可观测量在对非单态轴矢流进行有限重整化后，不依赖于 $\\gamma_5$ 方案。对于一个与轴矢流呈线性关系的可观测量，需要进行一次 $Z_5^{\\text{ns}}$ 的应用。\n\n您的任务：\n1. 实现以下在一阶 $a_s = \\alpha_s/(4\\pi)$ 上的模型化预测：\n   - HV 方案（原始预测）：$\\mathcal{O}^{\\text{HV}}_{\\text{raw}} = \\mathcal{O}_0 \\left(1 + c_1 a_s\\right)$。\n   - Larin 方案（原始预测）：$\\mathcal{O}^{\\text{Larin}}_{\\text{raw}} = \\mathcal{O}_0 \\left(1 + c_1 a_s\\right) + s_1\\, C_F\\, a_s\\, \\mathcal{O}_0$，其中 $s_1$ 是已知的在单圈水平上非单态轴矢流单个插入的方案差异系数。含单个 $\\gamma_5$ 的单圈迹的结构意味着 $s_1 = 4$。\n   - 非单态轴矢流的有限重整化：$Z_5^{\\text{ns}} = 1 + z_1 a_s$，其中 $z_1$ 的确定方式应使轴矢 Ward 恒等式在可觀測量中得以恢复。对于只有一个轴矢流插入的可观测量，在 $\\mathcal{O}(a_s)$ 阶，修正后的 Larin 预测必须为\n     $$\\mathcal{O}^{\\text{Larin}}_{\\text{corr}} = \\mathcal{O}^{\\text{Larin}}_{\\text{raw}} + z_1 a_s\\, \\mathcal{O}_0,$$\n     其中，将 NLO 修正乘以 $z_1 a_s$ 产生的 $\\mathcal{O}(a_s^2)$ 项因在一阶截断而被舍去。\n   - 施加方案无关性要求（轴矢 Ward 恒等式）：$\\mathcal{O}^{\\text{Larin}}_{\\text{corr}} = \\mathcal{O}^{\\text{HV}}_{\\text{raw}}$ 在 $\\mathcal{O}(a_s)$ 阶成立，并由此推导出以 $C_F$ 和 $s_1$ 表示的 $z_1$。\n2. 使用推導出的 $z_1$ 值，实现函数，在给定 $(\\alpha_s, C_F, g_V, g_A, K, c_1)$ 的情况下，计算以下五个量：\n   - $\\mathcal{O}^{\\text{HV}}_{\\text{raw}}$\n   - $\\mathcal{O}^{\\text{Larin}}_{\\text{raw}}$\n   - $\\mathcal{O}^{\\text{Larin}}_{\\text{corr}}$\n   - $Z_5^{\\text{ns}}$\n   - $\\Delta = \\mathcal{O}^{\\text{Larin}}_{\\text{corr}} - \\mathcal{O}^{\\text{HV}}_{\\text{raw}}$\n   所有结果必须截断至 $\\mathcal{O}(a_s)$ 阶。\n3. 测试套件。您的程序必须为以下每个测试用例计算上述五个量，每个用例指定为一个元组 $(\\alpha_s, C_F, g_V, g_A, K, c_1)$。如果存在角度，请以弧度解释。这里没有角度。所有量均为无量纲。\n   - 用例 1（一般正常路径，量子色动力学颜色）：$(0.118, \\tfrac{4}{3}, 0.19, 0.5, 2.0, -1.5)$。\n   - 用例 2（边界情况，强耦合为零）：$(0.0, \\tfrac{4}{3}, 0.3, 0.4, 1.0, 0.7)$。\n   - 用例 3（较大但仍在微扰范围内的耦合，耦合常数符号变化）：$(0.3, \\tfrac{4}{3}, -0.25, 0.6, 0.7, 2.0)$。\n   - 用例 4（不同颜色群测试，例如 $\\text{SU}(2)$ 基本表示）：$(0.118, 0.75, 0.2, 0.5, 1.3, -0.5)$。\n   - 用例 5（边界情况，无轴矢耦合）：$(0.118, \\tfrac{4}{3}, 0.19, 0.0, 2.0, -1.5)$。\n4. 最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表中的每个元素本身都应是包含五个浮点数的列表，顺序如下：$[\\mathcal{O}^{\\text{HV}}_{\\text{raw}}, \\mathcal{O}^{\\text{Larin}}_{\\text{raw}}, \\mathcal{O}^{\\text{Larin}}_{\\text{corr}}, Z_5^{\\text{ns}}, \\Delta]$。例如，输出应如下所示：\n   [[hv1,larin_raw1,larin_corr1,z51,delta1],[hv2,larin_raw2,larin_corr2,z52,delta2],...]\n您的代码不得读取输入。它必须硬编码上述测试套件，并严格按照此格式打印单行结果。\n\n评估标准：\n- 正确识别并实现单轴矢流插入在单圈水平上的方案差异结构。\n- 正确推导并实现单圈水平上的有限重整化常数 $z_1$。\n- 正确截断至 $\\mathcal{O}(a_s)$ 阶。\n- 正确聚合和格式化输出。", "solution": "我们首先形式化在次领头阶微扰量子色动力学背景下，量纲正则化中轴矢流的方案依赖性。轴矢流为 $J_5^\\mu = \\bar{\\psi} \\gamma^\\mu \\gamma_5 \\psi$。在 $d=4-2\\epsilon$ 维中，$\\gamma_5$ 的处理是模糊的。两种常用方案是 Larin 方案和 ’t Hooft–Veltman (HV) 方案。\n\n一个在 $pp \\to Z+\\text{jet}$ 过程中与轴矢流呈线性关系的宇称奇特可观测量 $\\mathcal{O}$，在领头阶可以由 $\\mathcal{O}_0 = K\\, g_V g_A$ 建模，其中 $g_V$ 和 $g_A$ 分别是矢量和轴矢耦合，$K$ 包含了不依赖于 $\\gamma_5$ 方案的运动学依赖关系。在 $\\alpha_s$ 的次领头阶，我们定义 $a_s = \\alpha_s/(4\\pi)$，并将普适的、方案无关的 QCD 修正参数化为 $\\mathcal{O}_0 c_1 a_s$，其中 $c_1$ 是一个不依赖于 $\\gamma_5$ 方案的常数。方案间的剩余差异仅仅源于对含有奇数个 $\\gamma_5$ 矩阵的迹的处理。\n\n方案差异的基于原理的结构：\n- 对于非单态流，在单圈水平上，任意两种自洽的 $\\gamma_5$ 方案之间的差异必须是一个与玻恩阶张量结构成正比的有限项，因为对于轴矢流的单个插入，单圈修正不会引入新的独立洛伦兹结构。规范不变性和颜色结构决定了此项与颜色因子 $C_F$ 成正比。\n- 因此，原始的 Larin 预测可以写为\n$$\n\\mathcal{O}^{\\text{Larin}}_{\\text{raw}} = \\mathcal{O}_0 \\left(1 + c_1 a_s\\right) + s_1\\, C_F\\, a_s\\, \\mathcal{O}_0,\n$$\n其中 $s_1$ 是一个方案预测的数值系数。相比之下，HV 方案可被视为参考方案，其中不存在这种额外的有限位移：\n$$\n\\mathcal{O}^{\\text{HV}}_{\\text{raw}} = \\mathcal{O}_0 \\left(1 + c_1 a_s\\right).\n$$\n\n有限重整化与轴矢 Ward 恒等式：\n- Larin 方案中的非单态轴矢流必须进行有限重整化，以确保物理可观测量满足轴矢 Ward 恒等式。将有限重整化记为 $Z_5^{\\text{ns}} = 1 + z_1 a_s + \\mathcal{O}(a_s^2)$。\n- 只有一个轴矢流插入的可观测量与 $J_5^\\mu$ 呈线性关系，因此在一阶上，$Z_5^{\\text{ns}}$ 的效应对可观测量是加性的：\n$$\n\\mathcal{O}^{\\text{Larin}}_{\\text{corr}} = \\mathcal{O}^{\\text{Larin}}_{\\text{raw}} + z_1 a_s\\, \\mathcal{O}_0,\n$$\n这里我们根据次领头阶精度，通过截断明确舍弃了 $\\mathcal{O}(a_s^2)$ 阶的项。等价地，可以看作是乘以 $Z_5^{\\text{ns}}$ 并展开到一阶：\n$$\n(1 + z_1 a_s) \\left[\\mathcal{O}_0 \\left(1 + c_1 a_s\\right) + s_1 C_F a_s \\mathcal{O}_0\\right] = \\mathcal{O}_0 + a_s \\left[c_1 \\mathcal{O}_0 + s_1 C_F \\mathcal{O}_0 + z_1 \\mathcal{O}_0\\right] + \\mathcal{O}(a_s^2).\n$$\n\n施加方案无关性：\n- 轴矢 Ward 恒等式要求经过方案修正的可观测量在 $\\mathcal{O}(a_s)$ 阶不依赖于 $\\gamma_5$ 方案。因此，\n$$\n\\mathcal{O}^{\\text{Larin}}_{\\text{corr}} = \\mathcal{O}^{\\text{HV}}_{\\text{raw}} \\quad \\text{在} \\quad \\mathcal{O}(a_s) \\text{ 阶}.\n$$\n代入表达式，\n$$\n\\mathcal{O}_0 \\left(1 + c_1 a_s\\right) + s_1 C_F a_s \\mathcal{O}_0 + z_1 a_s \\mathcal{O}_0 = \\mathcal{O}_0 \\left(1 + c_1 a_s\\right).\n$$\n消去公共项并除以 $a_s \\mathcal{O}_0$ 得到约束条件\n$$\ns_1 C_F + z_1 = 0.\n$$\n- 对于 Larin 方案中单个非单态轴矢流插入，单圈方案差异为 $s_1 = 4$。这源于对含单个 $\\gamma_5$ 的单圈夸克形状因子的显式计算，其中 Larin 方案与反交换 $\\gamma_5$ 相容方案之间的有限差异项是 $4 C_F a_s$ 乘以玻恩结构。因此，\n$$\nz_1 = - s_1 C_F = -4 C_F.\n$$\n因此，有限重整化常数为\n$$\nZ_5^{\\text{ns}} = 1 - 4 C_F a_s + \\mathcal{O}(a_s^2), \\quad \\text{其中} \\quad a_s = \\frac{\\alpha_s}{4\\pi}.\n$$\n\n算法设计：\n- 对于每个测试用例，计算 $a_s = \\alpha_s/(4\\pi)$，玻恩阶可观测量 $\\mathcal{O}_0 = K g_V g_A$，并设置 $s_1 = 4$ 和 $z_1 = -4 C_F$。\n- 计算原始 HV 预测 $\\mathcal{O}^{\\text{HV}}_{\\text{raw}} = \\mathcal{O}_0 (1 + c_1 a_s)$。\n- 计算原始 Larin 预测 $\\mathcal{O}^{\\text{Larin}}_{\\text{raw}} = \\mathcal{O}_0 (1 + c_1 a_s) + 4 C_F a_s \\mathcal{O}_0$。\n- 通过在 $\\mathcal{O}(a_s)$ 阶截断计算修正后的 Larin 预测：\n$$\n\\mathcal{O}^{\\text{Larin}}_{\\text{corr}} = \\mathcal{O}^{\\text{Larin}}_{\\text{raw}} + z_1 a_s \\mathcal{O}_0 = \\mathcal{O}_0 (1 + c_1 a_s) + 4 C_F a_s \\mathcal{O}_0 - 4 C_F a_s \\mathcal{O}_0 = \\mathcal{O}_0 (1 + c_1 a_s).\n$$\n因此，在保留的阶数上，$\\mathcal{O}^{\\text{Larin}}_{\\text{corr}} = \\mathcal{O}^{\\text{HV}}_{\\text{raw}}$ 精确成立。\n- 同时计算 $Z_5^{\\text{ns}} = 1 - 4 C_F a_s$ 和差异 $\\Delta = \\mathcal{O}^{\\text{Larin}}_{\\text{corr}} - \\mathcal{O}^{\\text{HV}}_{\\text{raw}}$，其数值上应为零（在浮点运算精度内）。\n\n边界情况与覆盖范围：\n- 用例 2 设置 $\\alpha_s = 0$，因此 $a_s = 0$，故 $Z_5^{\\text{ns}} = 1$，所有方案差异消失。\n- 用例 5 设置 $g_A = 0$，因此 $\\mathcal{O}_0 = 0$，这意味着所有三个可观测量都为零，与方案和重整化选择无关。\n- 用例 4 测试不同的 $C_F$ 值以验证普遍的颜色依赖性。\n- 用例 3 测试在微扰范围内较大的 $\\alpha_s$ 以及耦合常数的符号变化。\n\n输出：\n- 对于每个用例，按 $[\\mathcal{O}^{\\text{HV}}_{\\text{raw}}, \\mathcal{O}^{\\text{Larin}}_{\\text{raw}}, \\mathcal{O}^{\\text{Larin}}_{\\text{corr}}, Z_5^{\\text{ns}}, \\Delta]$ 的顺序收集五个浮点数。\n- 打印一行包含这些五元列表的列表，用逗号分隔，无多余文本。此行为完整的程序输出。\n\n该实现仅使用基本算术和标准库功能，是自包含的，并遵守 $\\mathcal{O}(a_s)$ 截断，以明确地模拟 NLO 效应和有限重整化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5 (not required), scipy 1.11.4 (not required).\n# No external inputs; prints a single line in the exact specified format.\n\nimport math\n\ndef compute_observables(alpha_s, C_F, g_V, g_A, K, c1):\n    \"\"\"\n    Compute the modeled NLO parity-odd observable with one axial current insertion,\n    comparing HV and Larin prescriptions, and applying the non-singlet finite\n    renormalization Z5_ns at O(a_s).\n\n    Returns a tuple:\n    (O_HV_raw, O_Larin_raw, O_Larin_corr, Z5_ns, delta)\n    with all quantities truncated to O(a_s).\n    \"\"\"\n    # Define a_s = alpha_s / (4*pi)\n    a_s = alpha_s / (4.0 * math.pi)\n\n    # Born-level observable, linear in axial current\n    O0 = K * g_V * g_A\n\n    # Scheme-difference coefficient at one loop for a single non-singlet axial insertion\n    s1 = 4.0  # known finite shift coefficient for Larin relative to HV\n\n    # Finite renormalization coefficient z1 determined by Ward identity restoration\n    # z1 = - s1 * C_F = -4 * C_F\n    z1 = -4.0 * C_F\n\n    # HV raw prediction at O(a_s)\n    O_HV_raw = O0 * (1.0 + c1 * a_s)\n\n    # Larin raw prediction at O(a_s)\n    O_Larin_raw = O0 * (1.0 + c1 * a_s) + s1 * C_F * a_s * O0\n\n    # Corrected Larin prediction at O(a_s): add z1 * a_s * O0 (truncate O(a_s^2))\n    O_Larin_corr = O_Larin_raw + z1 * a_s * O0\n\n    # Finite renormalization constant Z5_ns at O(a_s)\n    Z5_ns = 1.0 + z1 * a_s\n\n    # Difference after correction (should be 0 up to floating-point)\n    delta = O_Larin_corr - O_HV_raw\n\n    return O_HV_raw, O_Larin_raw, O_Larin_corr, Z5_ns, delta\n\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each case is (alpha_s, C_F, g_V, g_A, K, c1)\n    test_cases = [\n        (0.118, 4.0/3.0, 0.19, 0.5, 2.0, -1.5),    # Case 1: general SU(3)\n        (0.0,   4.0/3.0, 0.3,  0.4, 1.0,  0.7),    # Case 2: alpha_s = 0 boundary\n        (0.3,   4.0/3.0, -0.25,0.6, 0.7,  2.0),    # Case 3: larger alpha_s, sign variations\n        (0.118, 0.75,    0.2,  0.5, 1.3, -0.5),    # Case 4: different C_F (e.g., SU(2) fundamental)\n        (0.118, 4.0/3.0, 0.19, 0.0, 2.0, -1.5),    # Case 5: g_A = 0 edge case\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_s, C_F, g_V, g_A, K, c1 = case\n        O_HV_raw, O_Larin_raw, O_Larin_corr, Z5_ns, delta = compute_observables(\n            alpha_s, C_F, g_V, g_A, K, c1\n        )\n        results.append([O_HV_raw, O_Larin_raw, O_Larin_corr, Z5_ns, delta])\n\n    # Format as a single line: nested list with comma separators, no spaces\n    def fmt_list(nums):\n        return \"[\" + \",\".join(f\"{x:.12g}\" for x in nums) + \"]\"\n\n    line = \"[\" + \",\".join(fmt_list(row) for row in results) + \"]\"\n    print(line)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3524525"}]}