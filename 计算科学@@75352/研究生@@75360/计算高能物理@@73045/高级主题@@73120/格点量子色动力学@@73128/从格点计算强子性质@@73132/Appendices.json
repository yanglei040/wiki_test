{"hands_on_practices": [{"introduction": "在格点上计算强子性质之前，我们必须首先理解如何从底层的夸克场构建基本的观测量——关联函数。本练习 [@problem_id:3507023] 为此提供了基础实践，引导您完成计算质子两点函数结构所需的威克收缩（Wick contractions）和色代数（color algebra）。掌握这一步是将量子场论中的抽象算符与格点模拟中产生的数值数据联系起来的关键。", "problem": "考虑欧几里得空间中的量子色动力学（QCD），其色群为$3$阶特殊酉群（$SU(3)$）。令$u(x)$和$d(x)$表示格拉斯曼值的上夸克和下夸克场，其色指数为$a,b,c \\in \\{1,2,3\\}$，狄拉克旋量指数已省略。在时空点$x$处，定义标准的局域质子内插算符，\n$$\nO_{p}(x) \\equiv \\epsilon^{abc} \\left( u^{a}(x) \\right)^{T} C \\gamma_{5} d^{b}(x)\\, u^{c}(x),\n$$\n其中$\\epsilon^{abc}$是色空间中的完全反对称列维-奇维塔符号，$\\gamma_{5}$是欧几里得手征矩阵，而$C$是满足$C \\gamma_{\\mu} C^{-1} = - \\gamma_{\\mu}^{T}$和$C^{T} = - C$的电荷共轭矩阵。原点处的伴随算符为\n$$\n\\bar{O}_{p}(0) \\equiv \\epsilon^{a'b'c'}\\, \\bar{u}^{c'}(0)\\, \\bar{d}^{b'}(0)\\, \\gamma_{5} C \\left( \\bar{u}^{a'}(0) \\right)^{T}.\n$$\n零动量欧几里得两点关联函数为\n$$\nC(t) \\equiv \\sum_{\\vec{x}} \\left\\langle O_{p}(\\vec{x},t)\\, \\bar{O}_{p}(\\vec{0},0) \\right\\rangle,\n$$\n其中路径积分平均是对规范场和费米子场进行的，并且通常的费米子Wick收缩产生夸克传播子$S_{f}(x,0) \\equiv \\left\\langle f(x)\\, \\bar{f}(0) \\right\\rangle$，其中味$f \\in \\{u,d\\}$。\n\n从格拉斯曼场的Wick定理和$\\epsilon^{abc}$的反对称性出发，对$O_{p}(\\vec{x},t)$和$\\bar{O}_{p}(\\vec{0},0)$中的场进行Wick收缩，并仔细考虑：\n- 两个相同的上夸克场和两个相同的反上夸克场，它们允许$2!$种不同的配对方式，以及\n- 在实现每种配对时，由费米子反对易产生的置换符号。\n\n然后，执行由收缩产生的列维-奇维塔符号和克罗内克δ乘积所蕴含的色指数代数运算，并对色指数求和。所有狄拉克旋量结构和伽马矩阵都保持不求值；在色指数求和完成后，仅关注乘以旋量空间收缩的净总色系数。\n\n计算最终的净色因子$F_{\\text{color}}$，结果为一个整数。不需要四舍五入，且$F_{\\text{color}}$没有物理单位；将$F_{\\text{color}}$报告为一个纯数。", "solution": "基本依据是格拉斯曼场的Wick定理以及费米子场和列维-奇维塔符号的反对称性质。我们在欧几里得空间中进行计算，并且只执行色代数运算，而将包含$\\gamma_{5}$和$C$的旋量结构保持为隐式。\n\n我们从关联函数内部算符的显式乘积开始，\n$$\nO_{p}(\\vec{x},t)\\, \\bar{O}_{p}(\\vec{0},0) = \\epsilon^{abc}\\, \\epsilon^{a'b'c'} \\left( u^{a} \\right)^{T} C \\gamma_{5} d^{b}\\, u^{c}\\, \\bar{u}^{c'}\\, \\bar{d}^{b'}\\, \\gamma_{5} C \\left( \\bar{u}^{a'} \\right)^{T},\n$$\n其中所有场都在相应的时空点上取值，为简洁起见，我们省略了显式参数。根据格拉斯曼场的Wick定理，关联函数是$u$与$\\bar{u}$以及$d$与$\\bar{d}$所有完全配对的总和，每种配对贡献一项，该项是传播子乘积再乘以一个符号，此符号由将场移动到收缩对所需置换的奇偶性决定。\n\n$d$场只有一种唯一的配对方式：$d^{b}$与$\\bar{d}^{b'}$配对。对于$u$场，有两个相同的上夸克场$u^{a}$和$u^{c}$以及两个对应的反上夸克场$\\bar{u}^{a'}$和$\\bar{u}^{c'}$。因此，存在$2! = 2$种不同的配对方式：\n- 直接配对：$u^{a}$与$\\bar{u}^{a'}$收缩，$u^{c}$与$\\bar{u}^{c'}$收缩。\n- 交换配对：$u^{a}$与$\\bar{u}^{c'}$收缩，$u^{c}$与$\\bar{u}^{a'}$收缩。\n\n每次收缩都会在被收缩场的色指数之间产生一个色空间中的克罗内克δ。对于$d$场，我们得到$\\delta_{bb'}$。对于$u$场，直接配对产生$\\delta_{aa'}\\, \\delta_{cc'}$，而交换配对产生$\\delta_{ac'}\\, \\delta_{ca'}$。\n\n因此，这两种配对的色结构分别是\n$$\n\\text{直接配对：}\\quad \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{aa'}\\, \\delta_{bb'}\\, \\delta_{cc'},\n$$\n和\n$$\n\\text{交换配对：}\\quad \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{ac'}\\, \\delta_{bb'}\\, \\delta_{ca'}.\n$$\n\n现在我们进行色指数求和。对于直接配对，\n$$\n\\sum_{a,b,c,a',b',c'} \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{aa'}\\, \\delta_{bb'}\\, \\delta_{cc'} = \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{abc}.\n$$\n使用标准恒等式\n$$\n\\sum_{a,b,c=1}^{3} \\epsilon^{abc}\\, \\epsilon^{abc} = 3! = 6,\n$$\n我们发现直接配对的色因子等于$6$。\n\n对于交换配对，\n$$\n\\sum_{a,b,c,a',b',c'} \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{ac'}\\, \\delta_{bb'}\\, \\delta_{ca'} = \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{cba}.\n$$\n映射$(a,b,c) \\mapsto (c,b,a)$是一次单一的对换（交换$a$和$c$），是奇置换。因此，\n$$\n\\epsilon^{cba} = -\\, \\epsilon^{abc},\n$$\n所以\n$$\n\\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{cba} = - \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{abc} = - 6.\n$$\n所以来自$\\epsilon$收缩和克罗内克δ的交换色因子是$-6$。\n\n我们还必须考虑实现相同上夸克场交换配对所需置换相关的费米子符号。格拉斯曼场的Wick定理规定，交换相同费米子的配对会在直接配对和交换配对之间引入一个相对负号。因此，相对于直接项，交换项从费米子置换奇偶性中获得一个额外的因子$-1$。\n\n将费米子符号与交换配对的色代数结合起来，得到\n$$\n(+\\text{直接配对的费米子符号}) \\times 6 \\quad\\text{和}\\quad (-\\text{交换配对的费米子符号}) \\times (-6) = +6.\n$$\n因此，两种配对都对净色因子贡献$+6$。将两种配对的贡献相加，\n$$\nF_{\\text{color}} = 6 + 6 = 12.\n$$\n\n这个$F_{\\text{color}}$乘以由$C \\gamma_{5}$插入和传播子的旋量指数产生的任何旋量空间结构；我们已按要求未对这些结构进行求值。最终的净色因子是纯数$12$。", "answer": "$$\\boxed{12}$$", "id": "3507023"}, {"introduction": "计算出强子关联函数后，下一个任务是从时间序列数据中提取物理信息，例如质量。本练习 [@problem_id:3507006] 聚焦于一项关键的分析技术：使用宇称投影算符来分离和提取具有相反宇称的态（例如核子及其负宇称伙伴）的质量。通过一个使用合成数据的编程练习，您将学会如何处理在重子关联函数中常见的前向和后向传播的态。", "problem": "你的任务是为欧几里得格点量子色动力学（Lattice QCD）中的零动量重子两点关联函数，推导、实现并测试一种宇称投影质量提取方法。目标量是以格点单位表示的正宇称和负宇称基态质量。\n\n出发点必须是欧几里得路径积分表述和两点函数的光谱表示，以及欧几里得空间中的狄拉克代数。使用以下基础定律和定义：\n- 欧几里得时间中的零动量重子两点函数定义为旋量矩阵 $C_{\\alpha\\beta}(t) = \\sum_{\\vec{x}} \\langle 0 \\lvert \\mathcal{O}_{\\alpha}(t,\\vec{x}) \\overline{\\mathcal{O}}_{\\beta}(0) \\rvert 0 \\rangle$，其中欧几里得时间维度为 $T$，费米子具有反周期性时间边界条件，时间指标 $t \\in \\{0,1,\\dots,T-1\\}$。\n- 零动量下的宇称通过使用欧几里得 $\\gamma$ 矩阵进行投影来表示。在标准欧几里得约定中，使用 $\\gamma_{4}$ 使得 $\\gamma_{4} = \\mathrm{diag}(1,1,-1,-1)$，并定义正宇称和负宇称投影算符 $P_{\\pm} = \\frac{1 \\pm \\gamma_{4}}{2}$。\n- 零动量下的光谱表示和传输矩阵的存在性，意味着对具有正负宇称的态进行离散求和，并伴随欧几里得时间的指数衰减，这与费米子的反周期性时间边界条件一致。\n\n你的推导和实现必须按以下步骤进行。\n- 使用光谱表示和宇称投影算符证明，在零动量和反周期性时间边界条件下，对于每种宇称的单个主导态，关联函数矩阵可以一致地建模为一个前向传播的正宇称指数项和一个后向传播的负宇称指数项的叠加。明确地，构造一个符合这些原理的人工关联函数：\n  $$C(t) = A_{+}\\, P_{+}\\, e^{-M_{+}\\, t}\\;-\\;A_{-}\\, P_{-}\\, e^{-M_{-}\\, (T - t)},$$\n  其中 $A_{+} \\gt 0$ 和 $A_{-} \\gt 0$ 是交叠振幅，$M_{+} \\gt 0$ 和 $M_{-} \\gt 0$ 是正宇称和负宇称基态质量，$T \\in \\mathbb{Z}_{\\gt 0}$ 是时间维度，$t \\in \\{0,1,\\dots,T-1\\}$。所有量都以格点单位表示。\n- 从第一性原理出发，论证使用 $P_{+}$ 和 $P_{-}$ 的宇称投影如何为每种宇称分离出单指数衰减，而没有来自相反宇称的后向传播贡献的污染。为 $M_{+}$ 和 $M_{-}$ 得出一个实用的、无需拟合的估计量，该估计量仅使用相邻时间片的关联函数值，并且在选定的时间窗口内当单个态占主导时有效。你的估计量必须从投影关联函数推导得出，不得依赖于本问题陈述中提供的任何目标公式。\n- 将你用于质量提取的投影标量关联函数定义为带有宇称投影算符的迹。为了分离出前向衰减的负宇称信号，使用与光谱表示和反周期性边界条件一致的时间反演构造。在你的解中明确指定用于估计量的投影标量关联函数。\n- 对于数值估计，使用在一个平台窗口上对相邻时间估计量的平均值。对于每个时间维度为 $T$ 的测试用例，将窗口索引定义为 $t_{\\mathrm{start}} = \\max(1,\\lfloor T/8 \\rfloor)$ 和 $t_{\\mathrm{end}} = \\min(\\lfloor T/4 \\rfloor, T-2)$，并在此窗口内的所有整数 $t$ 上对逐点估计量进行平均。$M_{+}$ 和 $M_{-}$ 的最终答案必须以格点单位报告，为四舍五入到六位小数的实数。\n\n实现一个程序，该程序：\n- 使用给定参数和上述定义，为每个提供的测试用例构造 $C(t)$。\n- 按照规定从 $\\gamma_{4}$ 构建宇称投影算符 $P_{\\pm}$。\n- 形成投影标量关联函数，并在指定窗口上计算相邻时间的有效质量估计量，从而为每个测试用例生成 $M_{+}$ 和 $M_{-}$ 的单一估计值。\n- 将每个估计的质量四舍五入到六位小数。\n\n测试套件：\n- 使用以下五个测试用例，每个用例以元组 $(T, M_{+}, M_{-}, A_{+}, A_{-})$ 的形式给出：\n  - 用例 1：$(64, 0.5, 0.8, 1.2, 0.9)$\n  - 用例 2：$(48, 0.3, 1.1, 2.0, 0.5)$\n  - 用例 3：$(32, 1.5, 1.6, 1.0, 1.3)$\n  - 用例 4：$(40, 0.7, 0.7, 1.7, 0.4)$\n  - 用例 5：$(16, 0.4, 1.3, 0.8, 1.1)$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。按顺序连接五个用例的结果，每个用例中将正宇称估计值放在第一位，负宇称估计值放在第二位。例如，输出必须具有以下形式\n  $$[M_{+}^{(1)}, M_{-}^{(1)}, M_{+}^{(2)}, M_{-}^{(2)}, M_{+}^{(3)}, M_{-}^{(3)}, M_{+}^{(4)}, M_{-}^{(4)}, M_{+}^{(5)}, M_{-}^{(5)}],$$\n  其中每个条目都四舍五入到六位小数，并以格点单位表示。", "solution": "该问题要求从格点QCD中的人工构造的两点关联函数中，推导并实现一种方法来提取正宇称和负宇称的基态重子质量。此任务将通过首先验证问题陈述的有效性，然后进行所需估计量的原理推导，最后描述数值实现来解决。\n\n问题陈述被确定为**有效**。它在科学上基于格点QCD的原理，提供了一个具有自洽且一致设置的良定且客观的任务。所提供的模型是强子物理学中使用的标准简化，所有参数和过程都已明确定义。\n\n### 质量估计量的理论推导\n\n出发点是为零动量重子两点关联函数矩阵提供的模型，对欧几里得时间片 $t \\in \\{0, 1, \\dots, T-1\\}$ 有效：\n$$\nC(t) = A_{+} P_{+} e^{-M_{+} t} - A_{-} P_{-} e^{-M_{-} (T - t)}\n$$\n这里，$M_{\\pm} > 0$ 是正宇称 ($+$) 和负宇称 ($-$) 态的基态质量，$A_{\\pm} > 0$ 是相应的振幅，$T$ 是格点的时间维度，$P_{\\pm}$ 是宇称投影算符。所有量均以格点单位表示。\n\n宇称投影算符由欧几里得伽马矩阵 $\\gamma_4$ 定义：\n$$\nP_{\\pm} = \\frac{1 \\pm \\gamma_{4}}{2}\n$$\n使用指定的表示 $\\gamma_{4} = \\mathrm{diag}(1,1,-1,-1)$，投影算符成为对角矩阵 $P_{+} = \\mathrm{diag}(1,1,0,0)$ 和 $P_{-} = \\mathrm{diag}(0,0,1,1)$。这些算符满足投影算符的基本性质：它们是幂等的 ($P_{\\pm}^2 = P_{\\pm}$) 和正交的 ($P_{+} P_{-} = P_{-} P_{+} = 0$)，并且它们构成一个完备集 ($P_{+} + P_{-} = I$，其中 $I$ 是单位矩阵)。\n\n任务是使用这些投影算符提取 $M_+$ 和 $M_-$。这通过定义投影标量关联函数并从中推导出有效质量公式来实现。\n\n#### 正宇称质量 ($M_+$) 提取\n\n我们定义正宇称投影标量关联函数 $G_+(t)$，方法是取完整关联函数矩阵 $C(t)$ 乘以正宇称投影算符 $P_+$ 的迹：\n$$\nG_+(t) = \\mathrm{Tr}\\left[P_+ C(t)\\right]\n$$\n代入给定的 $C(t)$ 表达式：\n$$\nG_+(t) = \\mathrm{Tr}\\left[P_+ \\left( A_{+} P_{+} e^{-M_{+} t} - A_{-} P_{-} e^{-M_{-} (T - t)} \\right)\\right]\n$$\n利用迹的线性和投影算符的性质：\n$$\nG_+(t) = A_{+} e^{-M_{+} t} \\mathrm{Tr}[P_+ P_+] - A_{-} e^{-M_{-} (T - t)} \\mathrm{Tr}[P_+ P_-]\n$$\n由于 $P_+ P_+ = P_+$ 且 $P_+ P_- = 0$，表达式简化为：\n$$\nG_+(t) = A_{+} e^{-M_{+} t} \\mathrm{Tr}[P_+]\n$$\n在四维空间中 $P_+$ 的迹是 $\\mathrm{Tr}[\\mathrm{diag}(1,1,0,0)] = 2$。因此，我们分离出了一个纯粹的前向传播指数衰减：\n$$\nG_+(t) = 2 A_{+} e^{-M_{+} t}\n$$\n为了找到 $M_+$ 的一个无需拟合的估计量，我们考虑此关联函数在相邻时间片 $t$ 和 $t+1$ 处的比值：\n$$\n\\frac{G_+(t+1)}{G_+(t)} = \\frac{2 A_{+} e^{-M_{+} (t+1)}}{2 A_{+} e^{-M_{+} t}} = e^{-M_{+}}\n$$\n对两边取自然对数并解出 $M_+$，得到相邻时间有效质量估计量 $M_+(t)$：\n$$\nM_+(t) = -\\ln\\left(\\frac{G_+(t+1)}{G_+(t)}\\right) = \\ln\\left(\\frac{G_+(t)}{G_+(t+1)}\\right)\n$$\n对于给定的理想关联函数形式，$M_+(t)$ 对所有 $t$ 都是常数且等于真实质量 $M_+$。\n\n#### 负宇称质量 ($M_-$) 提取\n\n$C(t)$ 中的负宇称分量是一个后向传播的态，与 $e^{-M_-(T-t)}$ 成正比。为了与正宇称情况对称地处理此问题，我们遵循指令使用“时间反演构造”以获得一个前向衰减的信号。我们定义一个新的标量关联函数 $G_-(t')$，它通过将 $P_-$ 投影算符应用于时间反演的关联函数矩阵 $C(T-t')$ 来构造：\n$$\nG_-(t') = -\\mathrm{Tr}\\left[P_- C(T-t')\\right]\n$$\n前导的负号是按照惯例包含的，以产生一个正定数量，这一点稍后会变得清晰。为了在分析窗口中保持符号上的一致性，我们将时间变量从 $t'$ 重命名回 $t$，我们使用：\n$$\nG_-(t) = -\\mathrm{Tr}\\left[P_- C(T-t)\\right]\n$$\n为了计算这个，我们首先找到 $C(T-t)$：\n$$\nC(T-t) = A_{+} P_{+} e^{-M_{+} (T-t)} - A_{-} P_{-} e^{-M_{-} (T - (T-t))} = A_{+} P_{+} e^{-M_{+} (T-t)} - A_{-} P_{-} e^{-M_{-} t}\n$$\n现在，我们应用投影和迹：\n$$\nG_-(t) = -\\mathrm{Tr}\\left[P_- \\left( A_{+} P_{+} e^{-M_{+} (T-t)} - A_{-} P_{-} e^{-M_{-} t} \\right)\\right]\n$$\n$$\nG_-(t) = -A_{+} e^{-M_{+} (T-t)} \\mathrm{Tr}[P_- P_+] + A_{-} e^{-M_{-} t} \\mathrm{Tr}[P_- P_-]\n$$\n使用 $P_- P_+ = 0$ 和 $P_- P_- = P_-$，这简化为：\n$$\nG_-(t) = A_{-} e^{-M_{-} t} \\mathrm{Tr}[P_-]\n$$\n$P_-$ 的迹是 $\\mathrm{Tr}[\\mathrm{diag}(0,0,1,1)] = 2$。这为负宇称态提供了一个前向传播的指数衰减：\n$$\nG_-(t) = 2 A_{-} e^{-M_{-} t}\n$$\n负宇称态的有效质量估计量 $M_-(t)$ 的推导与正宇称情况完全相同：\n$$\nM_-(t) = \\ln\\left(\\frac{G_-(t)}{G_-(t+1)}\\right)\n$$\n该估计量将对所有 $t$ 给出真实质量 $M_-$。\n\n### 数值估计算法\n\n对于每个测试用例 $(T, M_{+}, M_{-}, A_{+}, A_{-})$，算法流程如下：\n1. 从给定的 $\\gamma_4$ 定义构造宇称投影算符 $P_{+}$ 和 $P_{-}$。\n2. 定义一个函数，使用提供的合成模型计算任意 $t \\in \\{0, 1, \\dots, T-1\\}$ 的关联函数矩阵 $C(t)$。\n3. 确定用于平均有效质量的分析窗口，由 $t_{\\mathrm{start}} = \\max(1,\\lfloor T/8 \\rfloor)$ 和 $t_{\\mathrm{end}} = \\min(\\lfloor T/4 \\rfloor, T-2)$ 定义。\n4. 对于从 $t_{\\mathrm{start}}$ 到 $t_{\\mathrm{end}}$ 的每个整数时间片 $t$，计算逐点有效质量：\n    $$\n    M_+(t) = \\ln\\left( \\frac{\\mathrm{Tr}[P_+ C(t)]}{\\mathrm{Tr}[P_+ C(t+1)]} \\right)\n    $$\n    $$\n    M_-(t) = \\ln\\left( \\frac{-\\mathrm{Tr}[P_- C(T-t)]}{-\\mathrm{Tr}[P_- C(T-(t+1))]} \\right)\n    $$\n5. 通过在分析窗口上对逐点值进行平均，计算 $M_+$ 和 $M_-$ 的最终估计值：\n    $$\n    \\bar{M}_{\\pm} = \\frac{1}{t_{\\mathrm{end}} - t_{\\mathrm{start}} + 1} \\sum_{t=t_{\\mathrm{start}}}^{t_{\\mathrm{end}}} M_{\\pm}(t)\n    $$\n6. 将最终的平均质量 $\\bar{M}_+$ 和 $\\bar{M}_-$ 四舍五入到六位小数。\n\n由于人工构造的数据是无噪声的，并且被单态模型完美描述，逐点有效质量 $M_{\\pm}(t)$ 在分析窗口内将是恒定的。平均步骤，虽然形式上是必需的，但将仅返回该常数值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a parity-projected mass extraction method for baryon\n    two-point correlation functions in Lattice QCD.\n    \"\"\"\n\n    # Test suite: each case is a tuple (T, M_+, M_-, A_+, A_-)\n    test_cases = [\n        (64, 0.5, 0.8, 1.2, 0.9),\n        (48, 0.3, 1.1, 2.0, 0.5),\n        (32, 1.5, 1.6, 1.0, 1.3),\n        (40, 0.7, 0.7, 1.7, 0.4),\n        (16, 0.4, 1.3, 0.8, 1.1),\n    ]\n\n    results = []\n    \n    # Define the Euclidean gamma matrix gamma_4 and projectors P_±.\n    # The matrices are defined as real, as specified in the problem.\n    gamma_4 = np.diag([1.0, 1.0, -1.0, -1.0])\n    identity_4 = np.identity(4)\n    P_plus = 0.5 * (identity_4 + gamma_4)\n    P_minus = 0.5 * (identity_4 - gamma_4)\n\n    for case in test_cases:\n        T, M_plus_true, M_minus_true, A_plus, A_minus = case\n\n        # Correlator construction function based on the provided model\n        def get_C(t, T_val, M_p, M_m, A_p, A_m):\n            \"\"\"\n            Constructs the synthetic correlator matrix C(t).\n            C(t) = A_+ P_+ e^(-M_+ t) - A_- P_- e^(-M_- (T - t))\n            \"\"\"\n            term_plus = A_p * P_plus * np.exp(-M_p * t)\n            term_minus = A_m * P_minus * np.exp(-M_m * (T_val - t))\n            return term_plus - term_minus\n\n        # Define the analysis window [t_start, t_end]\n        t_start = max(1, T // 8)\n        t_end = min(T // 4, T - 2)\n\n        m_eff_plus_values = []\n        m_eff_minus_values = []\n\n        # Iterate over the analysis window to compute pointwise effective masses\n        for t in range(t_start, t_end + 1):\n            # ===== Positive-Parity Effective Mass M_+(t) =====\n            # G_+(t) = Tr[P_+ C(t)]\n            C_t = get_C(t, T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_plus_t = np.trace(P_plus @ C_t)\n            \n            # G_+(t+1) = Tr[P_+ C(t+1)]\n            C_t1 = get_C(t + 1, T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_plus_t1 = np.trace(P_plus @ C_t1)\n            \n            # M_+(t) = ln( G_+(t) / G_+(t+1) )\n            m_eff_plus = np.log(G_plus_t / G_plus_t1)\n            m_eff_plus_values.append(m_eff_plus)\n\n            # ===== Negative-Parity Effective Mass M_-(t) =====\n            # Use time-reversed construction for a forward-decaying signal.\n            # G_-(t) = -Tr[P_- C(T-t)]\n            C_T_minus_t = get_C(T - t, T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_minus_t = -np.trace(P_minus @ C_T_minus_t)\n\n            # G_-(t+1) = -Tr[P_- C(T-(t+1))]\n            C_T_minus_t1 = get_C(T - (t + 1), T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_minus_t1 = -np.trace(P_minus @ C_T_minus_t1)\n\n            # M_-(t) = ln( G_-(t) / G_-(t+1) )\n            m_eff_minus = np.log(G_minus_t / G_minus_t1)\n            m_eff_minus_values.append(m_eff_minus)\n\n        # Average the pointwise masses over the window\n        # For this ideal synthetic data, the average is the same as any point.\n        M_plus_est = np.mean(m_eff_plus_values)\n        M_minus_est = np.mean(m_eff_minus_values)\n\n        # Append rounded results for the current case\n        results.append(round(M_plus_est, 6))\n        results.append(round(M_minus_est, 6))\n\n    # Format the final output as a comma-separated list in brackets\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3507006"}, {"introduction": "格点QCD的计算是在离散的时空格点上进行的，这会引入依赖于格点间距 $a$ 的人为效应。为了获得物理预测，必须将结果外推到连续极限（$a \\to 0$）。本练习 [@problem_id:3507086] 模拟了这关键的最后一步，要求您对使用不同格点作用量生成的核子质量数据进行连续极限外推。您将应用加权最小二乘法拟合，并使用赤池信息量准则（Akaike Information Criterion, AIC）来比较不同的标度模型，这是控制系统误差的标准做法。", "problem": "在格点量子色动力学 (LQCD) 中，Symanzik 有效理论预测，可观测量中的离散化误差会随着格点间距 $a$ 的幂次进行标度。对于 Wilson 费米子，领头阶离散化误差的标度为 $\\mathcal{O}(a)$，而非微扰地调节 Sheikholeslami-Wohlert (SW) 系数 $c_{\\text{SW}}$ 可以消除 $\\mathcal{O}(a)$ 项，剩下 $\\mathcal{O}(a^2)$ 的误差。考虑在几个不同的格点间距下测得的核子质量 $M_N(a)$，单位为吉电子伏特 (GeV)，其统计不确定度假设为高斯分布且不相关。分别地，由 $\\mathcal{O}(a)$ 主导的标度模型和由 $\\mathcal{O}(a^2)$ 主导的标度模型为：$$M_N(a) = M_0 + c_1 a + c_2 a^2$$ 和 $$M_N(a) = M_0 + c_2 a^2,$$ 其中 $M_0$ 是连续极限下的核子质量，$c_1$ 和 $c_2$ 是冗余参数，$a$ 的单位为飞米 (fm)。加权最小二乘估计量（在高斯噪声下等同于最大似然估计）最小化目标函数 $$\\chi^2 = \\sum_i \\frac{\\left[y_i - M_N(a_i)\\right]^2}{\\sigma_i^2},$$ 其中 $y_i$ 是在格点间距 $a_i$ 下测得的质量，其不确定度为 $\\sigma_i$。\n\n从 Symanzik 展开将格点误差组织为 $a$ 的幂级数以及高斯误差模型意味着加权最小二乘法最优性这两个基本出发点，实现以下任务：\n\n1. 对于每个测试用例，使用加权最小二乘法将未改进的测量值（对应于未经非微扰调节 Sheikholeslami-Wohlert (SW) 系数 $c_{\\text{SW}}$ 的 Wilson 作用量）拟合到 $\\mathcal{O}(a)$ 标度模型 $M_N(a) = M_0 + c_1 a + c_2 a^2$，并提取连续极限质量 $M_0$，单位为 GeV。\n2. 对于每个测试用例，使用加权最小二乘法将改进的测量值（对应于对 $c_{\\text{SW}}$ 进行非微扰调节）拟合到 $\\mathcal{O}(a^2)$ 标度模型 $M_N(a) = M_0 + c_2 a^2$，并提取连续极限质量 $M_0$，单位为 GeV。\n3. 对于每个测试用例的改进数据集，使用赤池信息准则 (Akaike Information Criterion, AIC) 定量比较 $\\mathcal{O}(a)$ 模型与 $\\mathcal{O}(a^2)$ 模型。在高斯误差下，使用 $$\\mathrm{AIC}' = \\chi^2 + 2k,$$ 其中 $k$ 是拟合参数的数量。如果在改进数据集上 $\\mathcal{O}(a^2)$ 模型更优（$\\mathrm{AIC}'$ 更小），则报告 $1$，否则报告 $0$。\n4. 对于每个测试用例，计算效应大小，即差值 $\\Delta M_0 = M_{0,\\text{unimproved}} - M_{0,\\text{improved}}$，单位为 GeV，并四舍五入到六位小数。\n\n您的程序必须按以下格式生成单行最终输出：一个由方括号括起来的逗号分隔的扁平列表，按顺序汇总每个测试用例的四个输出，即 $M_{0,\\text{unimproved}}$、$M_{0,\\text{improved}}$、$\\Delta M_0$ 和 AIC 偏好指示符。因此，对于三个测试用例，程序必须按顺序打印十二个值：用例 1（四个值）、用例 2（四个值）、用例 3（四个值）。所有质量都必须以 GeV 表示，并四舍五入到六位小数。AIC 偏好指示符必须是整数（$1$ 或 $0$）。\n\n使用以下测试套件，其中格点间距 $a$ 的单位为飞米 (fm)，质量 $y$ 的单位为吉电子伏特 (GeV)，不确定度 $\\sigma$ 的单位为 GeV：\n\n- 测试用例 1：\n  - 未改进：$a = \\{0.12, 0.09, 0.06, 0.045\\}\\,\\mathrm{fm}$，$y = \\{0.9680, 0.9590, 0.9510, 0.9480\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0040, 0.0035, 0.0030, 0.0030\\}\\,\\mathrm{GeV}$。\n  - 改进：$a = \\{0.12, 0.09, 0.06, 0.045\\}\\,\\mathrm{fm}$，$y = \\{0.9420, 0.9400, 0.9390, 0.9385\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0040, 0.0035, 0.0030, 0.0030\\}\\,\\mathrm{GeV}$。\n- 测试用例 2：\n  - 未改进：$a = \\{0.08, 0.06, 0.04, 0.03\\}\\,\\mathrm{fm}$，$y = \\{0.9530, 0.9490, 0.9450, 0.9440\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0030, 0.0025, 0.0020, 0.0020\\}\\,\\mathrm{GeV}$。\n  - 改进：$a = \\{0.08, 0.06, 0.04, 0.03\\}\\,\\mathrm{fm}$，$y = \\{0.9405, 0.9397, 0.9393, 0.9392\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0030, 0.0025, 0.0020, 0.0020\\}\\,\\mathrm{GeV}$。\n- 测试用例 3：\n  - 未改进：$a = \\{0.15, 0.12, 0.10\\}\\,\\mathrm{fm}$，$y = \\{0.9870, 0.9750, 0.9680\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0050, 0.0040, 0.0040\\}\\,\\mathrm{GeV}$。\n  - 改进：$a = \\{0.15, 0.12, 0.10\\}\\,\\mathrm{fm}$，$y = \\{0.9460, 0.9430, 0.9420\\}\\,\\mathrm{GeV}$，$\\sigma = \\{0.0050, 0.0040, 0.0040\\}\\,\\mathrm{GeV}$。\n\n所有计算都必须以双精度进行。此问题不涉及角度。最终输出必须是形如 $$[x_1,x_2,\\dots,x_{12}],$$ 的单行，其中每个 $x_i$ 是指定的浮点数（单位为 GeV，保留六位小数）或整数（$0$ 或 $1$）之一。", "solution": "该问题要求对在格点量子色动力学 (LQCD) 中模拟的核子质量数据进行连续极限外推。这是一个用于消除离散化误差的标准程序，这些误差源于用离散点格来近似连续时空。Symanzik 有效理论为此提供了一个系统性的框架，它预测对于给定的格点间距 $a$，像核子质量 $M_N(a)$ 这样的可观测量会以 $a$ 的幂级数形式趋近其连续极限值 $M_0$。\n\n问题的核心是使用加权最小二乘法将数值数据拟合到两个不同的理论模型。对于具有已知、不相关高斯不确定度的数据点，该方法在统计上是拟合模型的最佳方法。目标是找到一组模型参数 $\\vec{p}$，以最小化卡方函数 $\\chi^2$：\n$$\n\\chi^2(\\vec{p}) = \\sum_{i=1}^{N} \\frac{\\left[y_i - f(a_i; \\vec{p})\\right]^2}{\\sigma_i^2}\n$$\n其中 $\\{y_i\\}$ 是在相应格点间距 $\\{a_i\\}$ 下的 $N$ 个测量质量值，$\\{\\sigma_i\\}$ 是它们的统计不确定度，$f(a; \\vec{p})$ 是理论模型。\n\n这两个模型在其参数上是线性的，这使我们能够将问题表述为加权线性最小二乘问题。让我们为每个数据点定义权重 $w_i = 1/\\sigma_i$。最小化 $\\chi^2$ 等价于对加权量 $y'_i = y_i w_i$ 和 $f'(a_i; \\vec{p}) = f(a_i; \\vec{p}) w_i$ 求解普通最小二乘问题。\n\n在矩阵形式中，我们希望求解系统 $\\mathbf{A} \\vec{p} \\approx \\vec{Y}$，其中 $\\vec{Y}$ 是加权测量值向量，其元素为 $Y_i = y_i / \\sigma_i$，$\\vec{p}$ 是待确定的参数向量，$\\mathbf{A}$ 是加权设计矩阵。最小化平方范数 $||\\mathbf{A} \\vec{p} - \\vec{Y}||^2$（这正是 $\\chi^2$）的解由正规方程给出：\n$$\n\\vec{p} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\vec{Y}\n$$\n这可以通过线性代数程序（例如 `numpy.linalg.lstsq` 提供的程序）进行数值上稳健的求解，这些程序通常采用奇异值分解 (Singular Value Decomposition, SVD) 等方法。\n\n每个测试用例的四个任务执行如下：\n\n**1. 未改进数据的连续极限外推：**\n“未改进”数据来自 Wilson 型作用量，带有 $\\mathcal{O}(a)$ 的领头阶离散误差，将其拟合到相应的标度模型：\n$$\nM_N(a) = M_0 + c_1 a + c_2 a^2\n$$\n待确定的参数为 $\\vec{p} = (M_0, c_1, c_2)^T$。加权设计矩阵 $\\mathbf{A}_{\\text{unimp}}$ 的行由 $(1/\\sigma_i, a_i/\\sigma_i, a_i^2/\\sigma_i)$ 给出。求解该线性系统得到参数向量，从中我们提取连续极限质量 $M_{0,\\text{unimproved}} = p_0$。\n\n**2. 改进数据的连续极限外推：**\n“改进”数据通过非微扰地调节 Sheikholeslami-Wohlert (SW) 系数 $c_{\\text{SW}}$ 消除了 $\\mathcal{O}(a)$ 误差，预计其领头误差为 $\\mathcal{O}(a^2)$。因此，我们将其拟合到更简单的模型：\n$$\nM_N(a) = M_0 + c_2 a^2\n$$\n此处，参数为 $\\vec{p} = (M_0, c_2)^T$。加权设计矩阵 $\\mathbf{A}_{\\text{imp}}$ 的行为 $(1/\\sigma_i, a_i^2/\\sigma_i)$。求解该系统得到一个新的参数向量，从中我们提取改进后的连续极限质量 $M_{0,\\text{improved}} = p_0$。\n\n**3. 使用 AIC 进行模型比较：**\n为了定量评估对于“改进”数据集，移除 $c_1 a$ 项是否合理，我们使用赤池信息准则 (Akaike Information Criterion, AIC)。一个适用于高斯误差最小二乘拟合的简化版本是 $\\mathrm{AIC}' = \\chi^2_{\\text{min}} + 2k$，其中 $\\chi^2_{\\text{min}}$ 是拟合得到的最小 $\\chi^2$ 值，$k$ 是模型中的参数数量。较小的 AIC' 值表示更好的模型，它平衡了拟合优度和模型的简洁性。\n\n我们对改进数据集进行两次拟合：\n- 拟合到 $\\mathcal{O}(a)$ 模型 ($M_N(a) = M_0 + c_1 a + c_2 a^2$)：参数数量 $k_a = 3$。我们计算其最小卡方值 $\\chi^2_a$，及其 AIC 分数 $\\mathrm{AIC}'_a = \\chi^2_a + 2k_a = \\chi^2_a + 6$。\n- 拟合到 $\\mathcal{O}(a^2)$ 模型 ($M_N(a) = M_0 + c_2 a^2$)：参数数量 $k_{a^2} = 2$。我们计算其最小卡方值 $\\chi^2_{a^2}$，及其 AIC 分数 $\\mathrm{AIC}'_{a^2} = \\chi^2_{a^2} + 2k_{a^2} = \\chi^2_{a^2} + 4$。\n\n问题要求一个指示符，如果 $\\mathcal{O}(a^2)$ 模型更优（即 $\\mathrm{AIC}'_{a^2}  \\mathrm{AIC}'_a$），则为 $1$，否则为 $0$。\n\n**4. 计算效应大小：**\n计算差值 $\\Delta M_0 = M_{0,\\text{unimproved}} - M_{0,\\text{improved}}$。这个量代表了由于格点作用量的改进（即移除了主要的 $\\mathcal{O}(a)$ 离散误差）而导致的连续极限质量测定值的系统性偏移。\n\n该实现将通过构建适当的设计矩阵和响应向量来处理每个测试用例，调用数值最小二乘求解器来找到参数和残差平方和（即 $\\chi^2$），然后使用这些结果计算所需的四个量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lattice QCD continuum extrapolation problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"a\": [0.12, 0.09, 0.06, 0.045],\n            \"unimproved\": {\n                \"y\": [0.9680, 0.9590, 0.9510, 0.9480],\n                \"sigma\": [0.0040, 0.0035, 0.0030, 0.0030]\n            },\n            \"improved\": {\n                \"y\": [0.9420, 0.9400, 0.9390, 0.9385],\n                \"sigma\": [0.0040, 0.0035, 0.0030, 0.0030]\n            }\n        },\n        {\n            \"a\": [0.08, 0.06, 0.04, 0.03],\n            \"unimproved\": {\n                \"y\": [0.9530, 0.9490, 0.9450, 0.9440],\n                \"sigma\": [0.0030, 0.0025, 0.0020, 0.0020]\n            },\n            \"improved\": {\n                \"y\": [0.9405, 0.9397, 0.9393, 0.9392],\n                \"sigma\": [0.0030, 0.0025, 0.0020, 0.0020]\n            }\n        },\n        {\n            \"a\": [0.15, 0.12, 0.10],\n            \"unimproved\": {\n                \"y\": [0.9870, 0.9750, 0.9680],\n                \"sigma\": [0.0050, 0.0040, 0.0040]\n            },\n            \"improved\": {\n                \"y\": [0.9460, 0.9430, 0.9420],\n                \"sigma\": [0.0050, 0.0040, 0.0040]\n            }\n        }\n    ]\n\n    def perform_weighted_fit(a, y, sigma, basis_functions):\n        \"\"\"\n        Performs a weighted linear least-squares fit.\n\n        Args:\n            a (np.ndarray): Independent variable values.\n            y (np.ndarray): Dependent variable values.\n            sigma (np.ndarray): Uncertainties on y.\n            basis_functions (list of callables): Basis functions for the model.\n\n        Returns:\n            tuple: A tuple containing the fitted parameters and the minimum chi-squared.\n        \"\"\"\n        weights = 1.0 / sigma\n        Y_weighted = y * weights\n        \n        A_weighted = np.zeros((len(a), len(basis_functions)))\n        for i, func in enumerate(basis_functions):\n            A_weighted[:, i] = func(a) * weights\n            \n        params, residuals, _, _ = np.linalg.lstsq(A_weighted, Y_weighted, rcond=None)\n        \n        # residuals is an array with one element, the sum of squared residuals,\n        # which is the chi-squared value for the fit.\n        chi_squared = residuals[0] if residuals.size  0 else 0.0\n        \n        return params, chi_squared\n\n    all_results = []\n    \n    # Define the basis functions for the two models\n    o_a_basis = [lambda x: 1.0, lambda x: x, lambda x: x**2]\n    o_a2_basis = [lambda x: 1.0, lambda x: x**2]\n\n    for case in test_cases:\n        a_vals = np.array(case['a'], dtype=np.float64)\n        \n        # --- Task 1: Fit unimproved data with O(a) model ---\n        unimp_y = np.array(case['unimproved']['y'], dtype=np.float64)\n        unimp_sigma = np.array(case['unimproved']['sigma'], dtype=np.float64)\n        params_unimp, _ = perform_weighted_fit(a_vals, unimp_y, unimp_sigma, o_a_basis)\n        m0_unimproved = params_unimp[0]\n\n        # --- Task 2: Fit improved data with O(a^2) model ---\n        imp_y = np.array(case['improved']['y'], dtype=np.float64)\n        imp_sigma = np.array(case['improved']['sigma'], dtype=np.float64)\n        params_imp_a2, chi2_a2_on_imp = perform_weighted_fit(a_vals, imp_y, imp_sigma, o_a2_basis)\n        m0_improved = params_imp_a2[0]\n\n        # --- Task 3: Compare models on improved data using AIC ---\n        # Fit 1: O(a) model on improved data\n        k_a = len(o_a_basis)\n        _, chi2_a_on_imp = perform_weighted_fit(a_vals, imp_y, imp_sigma, o_a_basis)\n        aic_a = chi2_a_on_imp + 2 * k_a\n\n        # Fit 2: O(a^2) model on improved data (already done)\n        k_a2 = len(o_a2_basis)\n        aic_a2 = chi2_a2_on_imp + 2 * k_a2\n        \n        # Report 1 if O(a^2) model is preferred (smaller AIC)\n        aic_indicator = 1 if aic_a2  aic_a else 0\n\n        # --- Task 4: Compute effect size ---\n        delta_m0 = m0_unimproved - m0_improved\n\n        # --- Aggregate and format results for this case ---\n        all_results.extend([\n            f\"{m0_unimproved:.6f}\",\n            f\"{m0_improved:.6f}\",\n            f\"{delta_m0:.6f}\",\n            str(aic_indicator)\n        ])\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3507086"}]}