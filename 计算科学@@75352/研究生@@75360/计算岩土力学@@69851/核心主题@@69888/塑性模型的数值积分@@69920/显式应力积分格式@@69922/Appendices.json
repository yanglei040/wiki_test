{"hands_on_practices": [{"introduction": "弹性预测是任何显式应力积分方案的基础第一步。本练习将引导您从普适的三维各向同性弹性本构律出发，推导在平面应变这一常见且重要的工况下的特定应力映射关系，从而巩固您对这一概念的理解。掌握此推导过程对于理解运动学约束如何影响应力响应以及在二维模拟中正确实现这些模型至关重要。[@problem_id:3523455]", "problem": "考虑一个在平面应变设置下承受小应变的各向同性线弹性地质材料，其中运动学约束强制平面外应变为零。在显式应力积分方案中，弹性预测步将给定的应变增量映射到进行任何塑性修正之前的试探 Cauchy 应力状态。从三维小应变、各向同性线弹性本构定律出发，构建在平面应变条件下，将平面内应变增量向量 $\\Delta\\varepsilon = (\\Delta\\varepsilon_{xx},\\,\\Delta\\varepsilon_{yy},\\,0,\\,\\Delta\\gamma_{xy})$ 映射到试探应力向量 $\\sigma^{tr} = (\\sigma^{tr}_{xx},\\,\\sigma^{tr}_{yy},\\,\\sigma^{tr}_{zz},\\,\\tau^{tr}_{xy})$ 的弹性预测映射。明确指出在弹性预测中，受约束的平面外应变如何对 $\\sigma^{tr}_{zz}$ 产生贡献。\n\n假设材料的杨氏模量 $E = 1200\\,\\text{MPa}$，泊松比 $\\nu = 0.30$。增量应变状态为\n$$\n\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3},\\quad \\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4},\\quad \\Delta\\gamma_{xy} = 2.0\\times 10^{-3}.\n$$\n假设先前的应力状态为零，因此弹性预测的试探应力等于应力增量。使用所构建的映射，计算 $\\sigma^{tr}_{xx}$、$\\sigma^{tr}_{yy}$、$\\sigma^{tr}_{zz}$ 和 $\\tau^{tr}_{xy}$ 的数值。将最终的应力分量以兆帕 (MPa) 为单位表示，并将每个值四舍五入到四位有效数字。", "solution": "该问题是有效的，因为它在科学上基于线弹性理论，具有足够的数据使其成为适定问题，并且是客观陈述的。我们将着手求解。\n\n出发点是针对小应变的三维、各向同性、线弹性本构定律（胡克定律），它将 Cauchy 应力张量 $\\sigma_{ij}$ 与应变张量 $\\varepsilon_{ij}$ 联系起来：\n$$\n\\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_{kk} + 2G \\varepsilon_{ij}\n$$\n此处，$\\delta_{ij}$ 是克罗内克 δ 符号，$\\varepsilon_{kk} = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz}$ 是应变张量的迹（体积应变），$\\lambda$ 和 $G$ 是拉梅参数。它们通过以下公式与杨氏模量 $E$ 和泊松比 $\\nu$ 相关联：\n$$\nG = \\frac{E}{2(1+\\nu)} \\quad \\text{和} \\quad \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n$$\n在显式积分方案中，弹性预测步假设对给定的应变增量 $\\Delta\\varepsilon$ 作出完全弹性响应，从而计算出试探应力增量 $\\Delta\\sigma^{tr}$。当先前的应力状态为零时，试探应力 $\\sigma^{tr}$ 等于应力增量 $\\Delta\\sigma$。本构定律的增量形式为：\n$$\n\\Delta\\sigma_{ij} = \\lambda \\delta_{ij} \\Delta\\varepsilon_{kk} + 2G \\Delta\\varepsilon_{ij}\n$$\n问题指定了平面应变条件，该条件施加了运动学约束，即平面外方向（$z$方向）没有应变。这意味着 $\\Delta\\varepsilon_{zz} = 0$。此外，平面外剪切应变为零，$\\Delta\\gamma_{xz} = 2\\Delta\\varepsilon_{xz} = 0$ 且 $\\Delta\\gamma_{yz} = 2\\Delta\\varepsilon_{yz} = 0$。\n\n应用这些约束，增量体积应变变为 $\\Delta\\varepsilon_{kk} = \\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}$。现在我们可以写出试探应力增量的分量：\n对于平面内正应力：\n$$\n\\sigma^{tr}_{xx} = \\Delta\\sigma_{xx} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{xx} = (\\lambda + 2G)\\Delta\\varepsilon_{xx} + \\lambda\\Delta\\varepsilon_{yy}\n$$\n$$\n\\sigma^{tr}_{yy} = \\Delta\\sigma_{yy} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{yy} = \\lambda\\Delta\\varepsilon_{xx} + (\\lambda + 2G)\\Delta\\varepsilon_{yy}\n$$\n对于平面内剪应力（使用工程剪应变 $\\Delta\\gamma_{xy} = 2\\Delta\\varepsilon_{xy}$）：\n$$\n\\tau^{tr}_{xy} = \\Delta\\sigma_{xy} = 2G\\Delta\\varepsilon_{xy} = G\\Delta\\gamma_{xy}\n$$\n对于平面外正应力：\n$$\n\\sigma^{tr}_{zz} = \\Delta\\sigma_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})\n$$\n由于相应的剪应变为零，平面外剪应力也为零：\n$$\n\\tau^{tr}_{xz} = 0, \\quad \\tau^{tr}_{yz} = 0\n$$\n这组方程构成了平面应变的弹性预测映射。\n\n受约束的平面外应变对 $\\sigma^{tr}_{zz}$ 的贡献由方程 $\\sigma^{tr}_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})$ 解释。在物理上，平面内应变 $\\Delta\\varepsilon_{xx}$ 和 $\\Delta\\varepsilon_{yy}$ 会通过泊松效应引起平面外应变 $\\Delta\\varepsilon_{zz}'$。为了强制执行运动学约束 $\\Delta\\varepsilon_{zz} = 0$，必须产生一个正应力 $\\sigma_{zz}^{tr}$ 来抵消这种趋势。$\\sigma_{zz}^{tr}$ 的一个替代表达式是 $\\sigma_{zz}^{tr} = \\nu(\\sigma_{xx}^{tr} + \\sigma_{yy}^{tr})$。这两个表达式的等价性是平面应变公式的一个标志，可以通过将 $\\sigma_{xx}^{tr}$ 和 $\\sigma_{yy}^{tr}$ 的表达式代入第二种形式并使用 $\\lambda$ 和 $G$ 的定义来验证。\n\n现在，我们计算数值。给定的材料属性为 $E = 1200\\,\\text{MPa}$ 和 $\\nu = 0.30$。\n首先，计算拉梅参数：\n$$\nG = \\frac{1200\\,\\text{MPa}}{2(1+0.30)} = \\frac{1200}{2.6}\\,\\text{MPa} = \\frac{6000}{13}\\,\\text{MPa} \\approx 461.538\\,\\text{MPa}\n$$\n$$\n\\lambda = \\frac{1200\\,\\text{MPa} \\times 0.30}{(1+0.30)(1 - 2 \\times 0.30)} = \\frac{360}{1.3 \\times 0.4}\\,\\text{MPa} = \\frac{360}{0.52}\\,\\text{MPa} = \\frac{9000}{13}\\,\\text{MPa} \\approx 692.308\\,\\text{MPa}\n$$\n平面应变模量为：\n$$\n\\lambda + 2G = \\frac{9000}{13}\\,\\text{MPa} + 2\\left(\\frac{6000}{13}\\right)\\,\\text{MPa} = \\frac{21000}{13}\\,\\text{MPa} \\approx 1615.385\\,\\text{MPa}\n$$\n给定的增量应变分量为：\n$\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3}$\n$\\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4} = -0.5\\times 10^{-3}$\n$\\Delta\\gamma_{xy} = 2.0\\times 10^{-3}$\n\n使用推导出的映射，我们计算试探应力分量：\n$$\n\\sigma^{tr}_{xx} = \\left(\\frac{21000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{9000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(31500 - 4500) = \\frac{27000}{13} \\times 10^{-3} = \\frac{27}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{xx} \\approx 2.076923\\,\\text{MPa}\n$$\n四舍五入到四位有效数字得到 $\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$。\n\n$$\n\\sigma^{tr}_{yy} = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{21000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(13500 - 10500) = \\frac{3000}{13} \\times 10^{-3} = \\frac{3}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{yy} \\approx 0.230769\\,\\text{MPa}\n$$\n四舍五入到四位有效数字得到 $\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$。\n\n$$\n\\sigma^{tr}_{zz} = \\left(\\frac{9000}{13}\\right)(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3} - 0.5 \\times 10^{-3}) = \\left(\\frac{9000}{13}\\right)(1.0 \\times 10^{-3}) = \\frac{9}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{zz} \\approx 0.692307\\,\\text{MPa}\n$$\n四舍五入到四位有效数字得到 $\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$。\n\n$$\n\\tau^{tr}_{xy} = G\\Delta\\gamma_{xy} = \\left(\\frac{6000}{13}\\right)(2.0 \\times 10^{-3}) = \\frac{12000}{13} \\times 10^{-3} = \\frac{12}{13}\\,\\text{MPa}\n$$\n$$\n\\tau^{tr}_{xy} \\approx 0.923076\\,\\text{MPa}\n$$\n四舍五入到四位有效数字得到 $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$。\n\n计算出的试探应力分量，四舍五入到四位有效数字，分别为：$\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$，$\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$，$\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$，以及 $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 2.077  0.2308  0.6923  0.9231 \\end{pmatrix}}\n$$", "id": "3523455"}, {"introduction": "在掌握了预测步之后，我们现在可以构建完整的预测-校正循环。然而，一个朴素的显式实现方案在加载反转过程中会遇到一个被称为“伪塑性”的重大陷阱，即模型错误地预测了塑性变形。本练习将指导您为 Drucker-Prager 模型实现一个完整的显式积分算法，并引入一个稳健的卸载检测机制，以诊断、量化并最终防止这一关键的数值伪影。[@problem_id:3523530]", "problem": "设计并实现一个完整、可运行的程序，该程序对三维小应变、各向同性、弹塑性 Drucker–Prager (DP) 类型材料执行显式应力积分，该积分包含弹性预测和塑性修正步骤。该积分方案必须包含一个基于增量塑性功指标的符号的稳健卸载检测机制。目标是量化在加载每一步都在加载和卸载之间交替的情况下，显式积分所产生的伪塑性。\n\n该程序必须是纯算法的，并使用以下基本原理。\n\n- 小应变、线性、各向同性弹性，表示为二阶应力张量更新\n$$\n\\boldsymbol{\\sigma}_{\\text{trial}} = \\boldsymbol{\\sigma}_n + \\lambda \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon}) \\, \\boldsymbol{I} + 2 G \\, \\Delta\\boldsymbol{\\epsilon},\n$$\n其中 $ \\boldsymbol{\\sigma}_n $ 是增量开始时的应力，$ \\Delta\\boldsymbol{\\epsilon} $ 是应变增量张量，$ \\lambda $ 是第一个 Lamé 参数，$ G $ 是剪切模量，$ \\boldsymbol{I} $ 是单位张量，$ \\mathrm{tr}(\\cdot) $ 表示迹。体积模量 $ K $ 和 $ \\lambda $ 满足 $ K = \\lambda + \\tfrac{2}{3} G $。\n\n- Drucker–Prager 屈服函数，采用相关联流动法则，使用第二偏应力不变量和平均应力在拉为正的符号约定下定义：\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\sqrt{J_2(\\boldsymbol{\\sigma})} + \\eta \\, p(\\boldsymbol{\\sigma}) - \\left(k_0 + H \\kappa \\right),\n$$\n其中 $ \\kappa $ 是一个标量硬化变量，$ H $ 是塑性模量（各向同性硬化斜率），$ k_0 $ 是屈服面的初始大小，$ \\eta $ 是一个无量纲摩擦参数，$ \\boldsymbol{s} = \\boldsymbol{\\sigma} - \\tfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\boldsymbol{I} $ 是偏应力，$ J_2(\\boldsymbol{\\sigma}) = \\tfrac{1}{2} \\, \\boldsymbol{s} : \\boldsymbol{s} $，平均压应力为 $ p(\\boldsymbol{\\sigma}) = -\\tfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) $，因此在压缩状态下 $ p  0 $。相关联流动方向为 $ \\boldsymbol{n} = \\partial f / \\partial \\boldsymbol{\\sigma} $。\n\n- 卸载检测必须基于用弹性预测器计算的增量塑性功指标的符号：\n$$ \\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}  0 \\quad \\Rightarrow \\quad \\text{unloading, bypass plastic corrector} $$\n其中 $ \\mathbb{C} $ 是四阶各向同性弹性张量，$ \\boldsymbol{n}_{\\text{trial}} = \\left. \\partial f / \\partial \\boldsymbol{\\sigma} \\right|_{\\boldsymbol{\\sigma}_{\\text{trial}}} $。当检测到卸载时，应力进行弹性更新，并且不更新塑性变量。\n\n- 当未检测到卸载且试探状态违反屈服条件，即 $ f(\\boldsymbol{\\sigma}_{\\text{trial}}, \\kappa_n)  0 $ 时，应用一个通过对一致性条件 $ f(\\boldsymbol{\\sigma}, \\kappa) = 0 $ 在增量上进行一阶泰勒线性化得到的显式塑性修正。所有应力单位为兆帕 (MPa)，应变为无量纲。\n\n您必须实现一个加载程序，该程序每一步都在加载和卸载之间切换。使用拉为正的符号约定。在以下每个案例中，从 $ \\boldsymbol{\\sigma}_0 = \\boldsymbol{0} $ 和 $ \\kappa_0 = 0 $ 开始。每个案例运行两次模拟：\n1. 一次不带卸载检测的基准显式积分（只要 $ f_{\\text{trial}}  0 $ 就应用塑性修正）。\n2. 带有卸载检测的相同显式积分（只要 $ \\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}  0 $ 就绕过塑性修正）。\n\n将伪塑性量化为模拟结束时累积硬化变量的差异，\n$$\n\\Delta \\kappa_{\\text{spurious}} = \\kappa_{\\text{no-unloading-check}} - \\kappa_{\\text{with-unloading-check}},\n$$\n表示为一个十进制数。\n\n测试套件和单位：\n- 材料参数：$ G $ 单位为 MPa，$ K $ 单位为 MPa，$ \\eta $ 无量纲，$ H $ 单位为 MPa，$ k_0 $ 单位为 MPa。\n- 应变增量是二阶张量 $ \\Delta\\boldsymbol{\\epsilon} $，其分量遵循拉为正的符号约定；应变为无量纲。\n- 不使用角度；不要包含任何角度单位。\n- 程序必须为每个案例计算并报告 $ \\Delta \\kappa_{\\text{spurious}} $，结果为浮点数。\n\n提供以下三个案例作为测试套件：\n\n- 案例 1（偏量切换，典型加载）：$ G = 1000 \\, \\mathrm{MPa}, K = 2000 \\, \\mathrm{MPa}, \\eta = 0.1, H = 100 \\, \\mathrm{MPa}, k_0 = 0.05 \\, \\mathrm{MPa} $。步数 $ N = 200 $。在第 $ k $ 步，施加一个符号交替的纯剪切应变增量：$ \\Delta\\boldsymbol{\\epsilon}_k $，其中 $ \\epsilon_{12} = \\epsilon_{21} = (-1)^k \\, \\varepsilon_s $，所有其他分量为零，且 $ \\varepsilon_s = 5 \\times 10^{-5} $。\n\n- 案例 2（接近零加载的边界情况）：材料参数与案例 1 相同，但 $ N = 50 $ 且 $ \\varepsilon_s = 10^{-8} $。\n\n- 案例 3（体积切换，摩擦主导）：$ G = 1000 \\, \\mathrm{MPa}, K = 2000 \\, \\mathrm{MPa}, \\eta = 0.3, H = 100 \\, \\mathrm{MPa}, k_0 = 0.05 \\, \\mathrm{MPa} $。步数 $ N = 200 $。在第 $ k $ 步，施加一个符号交替的纯体积应变增量：$ \\Delta\\boldsymbol{\\epsilon}_k = \\tfrac{1}{3} (-1)^k \\, \\Delta\\varepsilon_v \\, \\boldsymbol{I} $，且 $ \\Delta\\varepsilon_v = 10^{-4} $。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是相应案例的 $ \\Delta \\kappa_{\\text{spurious}} $，格式为浮点数。所有应力必须在内部以 MPa 为单位进行计算和使用；报告的 $ \\Delta \\kappa_{\\text{spurious}} $ 值为无量纲小数。", "solution": "用户希望设计并实现一个程序，用于 Drucker-Prager 弹塑性材料模型的显式应力积分。核心任务是通过将带有稳健卸载检查的模拟与没有卸载检查的基准模拟进行比较，来量化伪塑性。\n\n### 步骤1：提取给定条件\n\n- **本构模型**：小应变、各向同性、弹塑性。\n- **弹性定律**：线性、各向同性弹性。\n  - 应力更新：$\\boldsymbol{\\sigma}_{\\text{trial}} = \\boldsymbol{\\sigma}_n + \\lambda \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon}) \\, \\boldsymbol{I} + 2 G \\, \\Delta\\boldsymbol{\\epsilon}$\n  - 材料参数：剪切模量 $G$，第一个 Lamé 参数 $\\lambda$。\n  - 与体积模量的关系：$K = \\lambda + \\tfrac{2}{3} G$。\n- **塑性模型**：具有相关联流动和各向同性硬化的 Drucker–Prager (DP) 模型。\n  - 符号约定：拉为正应力。\n  - 平均应力：$p(\\boldsymbol{\\sigma}) = -\\tfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma})$，因此在压缩状态下 $p  0$。\n  - 偏应力：$\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\tfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\boldsymbol{I}$。\n  - 第二偏应力不变量：$J_2(\\boldsymbol{\\sigma}) = \\tfrac{1}{2} \\, \\boldsymbol{s} : \\boldsymbol{s}$。\n  - 屈服函数：$f(\\boldsymbol{\\sigma}, \\kappa) = \\sqrt{J_2(\\boldsymbol{\\sigma})} + \\eta \\, p(\\boldsymbol{\\sigma}) - \\left(k_0 + H \\kappa \\right)$。\n  - 硬化变量：$\\kappa$，一个标量。\n  - 塑性参数：摩擦系数 $\\eta$，塑性模量 $H$，初始屈服面尺寸 $k_0$。\n  - 流动法则：相关联流动，$ \\boldsymbol{n} = \\partial f / \\partial \\boldsymbol{\\sigma} $。\n- **积分方案**：显式弹性预测、塑性修正。\n  - 修正条件：当 $f(\\boldsymbol{\\sigma}_{\\text{trial}}, \\kappa_n)  0$ 时应用。\n  - 修正算法：一致性条件的一阶泰勒线性化。\n- **卸载检测**：\n  - 条件：$\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}  0 \\Rightarrow \\text{卸载}$。\n  - $\\mathbb{C}$ 是四阶各向同性弹性张量。\n  - $\\boldsymbol{n}_{\\text{trial}} = \\left. \\partial f / \\partial \\boldsymbol{\\sigma} \\right|_{\\boldsymbol{\\sigma}_{\\text{trial}}}$。\n  - 措施：如果检测到卸载，绕过塑性修正器（即该步被视为弹性步）。\n- **模拟设置**：\n  - 初始条件：$\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$，$\\kappa_0 = 0$。\n  - 每个案例进行两次模拟：(1) 无卸载检查，(2) 有卸载检查。\n  - 目标：量化伪塑性，即 $\\Delta \\kappa_{\\text{spurious}} = \\kappa_{\\text{no-unloading-check}} - \\kappa_{\\text{with-unloading-check}}$。\n- **测试案例**：\n  - **案例 1**：$G=1000$，$K=2000$，$\\eta=0.1$，$H=100$，$k_0=0.05$（均为 MPa）。$N=200$ 步。$\\Delta\\boldsymbol{\\epsilon}_k$ 为纯剪切，$\\epsilon_{12} = \\epsilon_{21} = (-1)^k \\, (5 \\times 10^{-5})$。\n  - **案例 2**：材料与案例 1 相同。$N=50$ 步。$\\Delta\\boldsymbol{\\epsilon}_k$ 为纯剪切，$\\epsilon_{12} = \\epsilon_{21} = (-1)^k \\, 10^{-8}$。\n  - **案例 3**：$G=1000$，$K=2000$，$\\eta=0.3$，$H=100$，$k_0=0.05$（均为 MPa）。$N=200$ 步。$\\Delta\\boldsymbol{\\epsilon}_k = \\tfrac{1}{3} (-1)^k \\, (10^{-4}) \\, \\boldsymbol{I}$。\n\n### 步骤2：使用提取的给定条件进行验证\n\n- **科学基础**：该问题基于连续介质力学和计算塑性力学的标准原理。Drucker-Prager 模型是压力敏感材料的经典屈服准则，显式应力积分算法（弹性预测/塑性修正）是该领域的一项基本技术。所有方程都是标准且正确的。\n- **适定的**：该问题被构建为一个数值实验。所有材料参数、初始条件和加载历史都被明确定义。两种模拟变体的算法都已指定。这确保了可以获得唯一且有意义的数值结果。\n- **目标**：问题陈述完全是技术性和定量性的，没有主观或模糊的语言。\n- **不完整或矛盾的设置**：该问题是自洽的。所有必要的方程和数据都已提供。应力和压力的符号约定已声明，并且与岩土力学中的标准实践一致。\n- **不切实际或不可行**：材料属性和应变增量在数值模拟的物理合理范围内。小应变假设因应变增量的小量值而合理。\n- **不适定或结构不良**：该问题结构良好，引导用户实现特定算法并量化特定效应。输出有明确定义。\n- **故作高深、琐碎或同义反复**：该问题解决了一个真实且重要的计算塑性力学数值伪影——在载荷反转下显式积分产生的伪塑性。这是一个非平凡的实现任务，需要仔细应用本构理论。\n\n### 步骤3：结论和行动\n该问题是有效的。这是一个适定的、科学上合理的计算力学练习。我将继续进行求解。\n\n### 算法设计与推导\n\n解决方案需要为 Drucker-Prager 材料模型实现一个逐歩的应力积分算法。对于从 $n$ 到 $n+1$ 的每个时间步，给定状态 $(\\boldsymbol{\\sigma}_n, \\kappa_n)$ 和应变增量 $\\Delta\\boldsymbol{\\epsilon}$，我们计算新状态 $(\\boldsymbol{\\sigma}_{n+1}, \\kappa_{n+1})$。\n\n**1. 弹性预测**\n\n首先，假设整个应变增量是弹性的，计算试探应力 $\\boldsymbol{\\sigma}_{\\text{trial}}$。\n$$\n\\boldsymbol{\\sigma}_{\\text{trial}} = \\boldsymbol{\\sigma}_n + \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}\n$$\n使用给定的表达式，其中 Lamé 参数为 $\\lambda = K - \\frac{2}{3}G$ 和 $G$：\n$$\n\\boldsymbol{\\sigma}_{\\text{trial}} = \\boldsymbol{\\sigma}_n + (K - \\tfrac{2}{3}G) \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon}) \\, \\boldsymbol{I} + 2 G \\, \\Delta\\boldsymbol{\\epsilon}\n$$\n\n**2. 屈服条件检查**\n\n在试探状态下评估屈服函数，使用步初的硬化状态 $\\kappa_n$。\n$$\nf_{\\text{trial}} = f(\\boldsymbol{\\sigma}_{\\text{trial}}, \\kappa_n) = \\sqrt{J_{2,\\text{trial}}} + \\eta \\, p_{\\text{trial}} - (k_0 + H \\kappa_n)\n$$\n其中 $p_{\\text{trial}} = -\\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma}_{\\text{trial}})$ 且 $J_{2,\\text{trial}} = \\frac{1}{2}\\boldsymbol{s}_{\\text{trial}}:\\boldsymbol{s}_{\\text{trial}}$，$\\boldsymbol{s}_{\\text{trial}} = \\boldsymbol{\\sigma}_{\\text{trial}} + p_{\\text{trial}}\\boldsymbol{I}$。\n- 如果 $f_{\\text{trial}} \\le 0$，该步是弹性的。状态更新为 $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\text{trial}}$ 和 $\\kappa_{n+1} = \\kappa_n$。\n- 如果 $f_{\\text{trial}}  0$，状态在屈服面之外，表明发生了屈服。可能需要一个塑性修正步骤。\n\n**3. 卸载检查（如适用）**\n\n对于包含卸载检测的模拟变体，当 $f_{\\text{trial}}  0$ 时，我们计算指标 $I_{\\text{unload}} = \\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}$。项 $\\boldsymbol{n}_{\\text{trial}}$ 是在试探应力处评估的屈服函数的梯度：\n$$\n\\boldsymbol{n}_{\\text{trial}} = \\left. \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} \\right|_{\\boldsymbol{\\sigma}_{\\text{trial}}} = \\frac{\\partial \\sqrt{J_2}}{\\partial \\boldsymbol{\\sigma}} + \\eta \\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\boldsymbol{s}_{\\text{trial}}}{2\\sqrt{J_{2,\\text{trial}}}} - \\frac{\\eta}{3}\\boldsymbol{I}\n$$\n必须处理 $J_{2,\\text{trial}} \\to 0$（静水应力状态）的特殊情况，此时梯度的偏量部分为零。卸载指标可以推导为：\n$$\nI_{\\text{unload}} = \\left(\\frac{\\boldsymbol{s}_{\\text{trial}}}{2\\sqrt{J_{2,\\text{trial}}}} - \\frac{\\eta}{3}\\boldsymbol{I}\\right) : (\\lambda \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon}) \\, \\boldsymbol{I} + 2G \\, \\Delta\\boldsymbol{\\epsilon}) = \\frac{G \\, (\\boldsymbol{s}_{\\text{trial}} : \\Delta\\boldsymbol{\\epsilon})}{\\sqrt{J_{2,\\text{trial}}}} - \\eta K \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon})\n$$\n如果 $I_{\\text{unload}}  0$，即使试探应力在屈服面之外，也表示卸载。这是显式前向欧拉积分的伪影。在这种情况下，绕过塑性，并将该步视为弹性：$\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\text{trial}}$ 和 $\\kappa_{n+1} = \\kappa_n$。\n\n**4. 显式塑性修正**\n\n如果 $f_{\\text{trial}}  0$ 且（如果激活）未触发卸载检查，则应用塑性修正。这涉及计算塑性乘子增量 $\\Delta\\gamma$，它控制塑性变形的大小。对于显式方案，$\\Delta\\gamma$ 来自于一致性条件 $f(\\boldsymbol{\\sigma}_{n+1}, \\kappa_{n+1}) = 0$ 围绕试探状态的一阶泰勒展开：\n$$\nf(\\boldsymbol{\\sigma}_{n+1}, \\kappa_{n+1}) \\approx f_{\\text{trial}} + \\boldsymbol{n}_{\\text{trial}} : (\\boldsymbol{\\sigma}_{n+1}-\\boldsymbol{\\sigma}_{\\text{trial}}) + \\frac{\\partial f}{\\partial \\kappa}(\\kappa_{n+1}-\\kappa_n) = 0\n$$\n使用关系式 $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\text{trial}} - \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}^p$, $\\Delta\\boldsymbol{\\epsilon}^p = \\Delta\\gamma \\, \\boldsymbol{n}_{\\text{trial}}$, $\\kappa_{n+1} = \\kappa_n + \\Delta\\gamma$ (假设 $\\Delta\\kappa = \\Delta\\gamma$), 以及 $\\frac{\\partial f}{\\partial \\kappa} = -H$，我们代入并求解 $\\Delta\\gamma$:\n$$\nf_{\\text{trial}} + \\boldsymbol{n}_{\\text{trial}} : (-\\Delta\\gamma \\, (\\mathbb{C}:\\boldsymbol{n}_{\\text{trial}})) - H \\Delta\\gamma = 0 \\implies \\Delta\\gamma = \\frac{f_{\\text{trial}}}{\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\boldsymbol{n}_{\\text{trial}} + H}\n$$\n分母可以显著简化。项 $\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\boldsymbol{n}_{\\text{trial}}$ 展开为：\n$$\n\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\boldsymbol{n}_{\\text{trial}} = G + K\\eta^2\n$$\n这给出了一个非常简单的、对于给定材料属性为常数的分母：\n$$\n\\Delta\\gamma = \\frac{f_{\\text{trial}}}{G + K\\eta^2 + H}\n$$\n计算出 $\\Delta\\gamma$ 后，更新状态变量：\n$$\n\\kappa_{n+1} = \\kappa_n + \\Delta\\gamma\n$$\n将应力修正回屈服面：\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\text{trial}} - \\Delta\\gamma \\, (\\mathbb{C} : \\boldsymbol{n}_{\\text{trial}})\n$$\n项 $\\mathbb{C} : \\boldsymbol{n}_{\\text{trial}}$ 简化为：\n$$\n\\mathbb{C} : \\boldsymbol{n}_{\\text{trial}} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{n}_{\\text{trial}}) \\boldsymbol{I} + 2G \\boldsymbol{n}_{\\text{trial}} = -K\\eta\\boldsymbol{I} + \\frac{G \\boldsymbol{s}_{\\text{trial}}}{\\sqrt{J_{2,\\text{trial}}}}\n$$\n同样，必须通过将偏量部分设置为零来处理 $J_{2,\\text{trial}} \\to 0$ 的情况。\n\n**5. 模拟与伪塑性量化**\n\n上述算法在一个包含 $N$ 步的循环中实现。对于每个测试案例，运行两个完整的模拟：\n1.  **基准**：只要 $f_{\\text{trial}}  0$，就应用塑性修正器。预计此模拟在载荷反转期间会累积伪塑性应变。\n2.  **带卸载检查**：首先检查卸载条件 $I_{\\text{unload}}  0$。如果为真，则绕过塑性修正器。这应能防止伪塑性更新。\n\n记录两个模拟的最终累积硬化变量 $\\kappa_N$。差值 $\\Delta \\kappa_{\\text{spurious}} = \\kappa_{N, \\text{no-check}} - \\kappa_{N, \\text{with-check}}$ 量化了伪塑性。\n\n对于案例3，施加的应变是纯体积应变，仅产生静水应力。加载路径在零应力和拉伸应力状态之间交替。由于平均应力 $p$ 始终为非正值（拉伸），因此屈服条件 $f = \\eta p - (k_0+H\\kappa)  0$ 永远不会满足（因为 $\\eta, k_0 > 0$ 且 $p \\le 0$）。因此，两次模拟都将是纯弹性的，导致累积塑性为零，且 $\\Delta\\kappa_{\\text{spurious}} = 0$。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(G, K, eta, H, k0, N, get_deps_k, use_unloading_check):\n    \"\"\"\n    Performs an explicit stress integration for a Drucker-Prager material.\n\n    Args:\n        G (float): Shear modulus (MPa).\n        K (float): Bulk modulus (MPa).\n        eta (float): Friction parameter.\n        H (float): Hardening modulus (MPa).\n        k0 (float): Initial cohesion (MPa).\n        N (int): Number of steps.\n        get_deps_k (function): Function that returns the strain increment tensor\n                               for a given step k.\n        use_unloading_check (bool): If True, enables the unloading check.\n\n    Returns:\n        float: The final accumulated hardening variable kappa.\n    \"\"\"\n    sigma = np.zeros((3, 3))\n    kappa = 0.0\n    \n    # Pre-compute constants\n    lame_lambda = K - 2.0 / 3.0 * G\n    I = np.identity(3)\n    tol = 1e-12 # Tolerance for floating point comparisons\n    \n    # Denominator for plastic multiplier is constant for this model\n    denom_dgamma = G + K * eta**2 + H\n    \n    for k in range(N):\n        delta_eps = get_deps_k(k)\n        \n        # 1. Elastic predictor\n        tr_delta_eps = np.trace(delta_eps)\n        sigma_trial = sigma + lame_lambda * tr_delta_eps * I + 2 * G * delta_eps\n        \n        # 2. Yield check\n        tr_sigma_trial = np.trace(sigma_trial)\n        p_trial = -tr_sigma_trial / 3.0\n        s_trial = sigma_trial - (tr_sigma_trial / 3.0) * I\n        \n        J2_trial = 0.5 * np.sum(s_trial * s_trial)\n        sqrt_J2_trial = np.sqrt(J2_trial) if J2_trial  0 else 0.0\n        \n        yield_surface_size = k0 + H * kappa\n        f_trial = sqrt_J2_trial + eta * p_trial - yield_surface_size\n        \n        is_plastic = f_trial  tol\n        \n        # 3. Unloading check (if applicable)\n        if is_plastic and use_unloading_check:\n            s_trial_dot_deps = np.sum(s_trial * delta_eps)\n            \n            unload_indicator = -eta * K * tr_delta_eps\n            if sqrt_J2_trial  tol:\n                unload_indicator += G * s_trial_dot_deps / sqrt_J2_trial\n            \n            if unload_indicator  0:\n                is_plastic = False\n\n        # 4. Plastic corrector (if plastic) or elastic update\n        if is_plastic:\n            # Calculate plastic multiplier\n            d_gamma = f_trial / denom_dgamma\n            \n            # Update hardening\n            kappa += d_gamma\n            \n            # Update stress\n            C_n_dev = np.zeros((3, 3))\n            if sqrt_J2_trial  tol:\n                C_n_dev = G * s_trial / sqrt_J2_trial\n            \n            C_n = -K * eta * I + C_n_dev\n            sigma = sigma_trial - d_gamma * C_n\n        else:\n            # Elastic update (or unloading detected)\n            sigma = sigma_trial\n            # kappa remains unchanged\n            \n    return kappa\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute spurious plasticity.\n    \"\"\"\n    # Case 1: Deviatoric toggle, typical loading\n    case1_params = {\n        'G': 1000.0, 'K': 2000.0, 'eta': 0.1, 'H': 100.0, 'k0': 0.05,\n        'N': 200, 'eps_s': 5e-5\n    }\n    def get_deps_c1(k):\n        deps = np.zeros((3, 3))\n        val = ((-1)**k) * case1_params['eps_s']\n        deps[0, 1] = deps[1, 0] = val\n        return deps\n\n    # Case 2: Deviatoric toggle, near zero loading\n    case2_params = {\n        'G': 1000.0, 'K': 2000.0, 'eta': 0.1, 'H': 100.0, 'k0': 0.05,\n        'N': 50, 'eps_s': 1e-8\n    }\n    def get_deps_c2(k):\n        deps = np.zeros((3, 3))\n        val = ((-1)**k) * case2_params['eps_s']\n        deps[0, 1] = deps[1, 0] = val\n        return deps\n\n    # Case 3: Volumetric toggle, friction-dominated\n    case3_params = {\n        'G': 1000.0, 'K': 2000.0, 'eta': 0.3, 'H': 100.0, 'k0': 0.05,\n        'N': 200, 'delta_eps_v': 1e-4\n    }\n    def get_deps_c3(k):\n        val = (1.0/3.0) * ((-1)**k) * case3_params['delta_eps_v']\n        return val * np.identity(3)\n\n    test_cases = [\n        (case1_params, get_deps_c1),\n        (case2_params, get_deps_c2),\n        (case3_params, get_deps_c3),\n    ]\n\n    results = []\n    for params, get_deps_func in test_cases:\n        # Run baseline simulation without unloading check\n        kappa_no_check = run_simulation(\n            params['G'], params['K'], params['eta'], params['H'], params['k0'],\n            params['N'], get_deps_func, use_unloading_check=False\n        )\n        \n        # Run simulation with unloading check\n        kappa_with_check = run_simulation(\n            params['G'], params['K'], params['eta'], params['H'], params['k0'],\n            params['N'], get_deps_func, use_unloading_check=True\n        )\n        \n        delta_kappa_spurious = kappa_no_check - kappa_with_check\n        results.append(delta_kappa_spurious)\n    \n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3523530"}, {"introduction": "显式方法的精度与积分步长的大小内在相关。虽然我们之前的算法是稳健的，但在所有情况下都依赖于一个固定的、保守的小步长是低效的。一个更优雅、更高效的解决方案是根据局部误差自适应地调整步长。本练习旨在让您实现一个自适应子步长算法，该算法能自动细化积分过程，确保试探状态保持在可接受的误差容限内，从而使显式方案兼具准确性和计算效率。[@problem_id:3523495]", "problem": "您的任务是为小应变下的 Drucker–Prager 弹塑性材料实现一个自适应显式应力积分算法。该算法必须使用弹性预测步和随后的显式塑性校正步，并且必须自适应地细分总应变增量，直到试探屈服函数值落入指定的目标范围内，以保证显式校正的准确性。\n\n材料模型为线性各向同性弹性体，具有关联的 Drucker–Prager 屈服函数和线性各向同性硬化。所有量必须在拉为正的符号约定下计算。应力是二阶对称张量，应变是二阶对称张量，并采用小应变假设。所需的单位已明确指定：应力以千帕 (kPa) 表示，应变为无量纲。本问题不涉及角度单位。所有数值输出必须四舍五入到三位小数。\n\n推导该算法必须使用的基本原理和定义：\n- 小应变运动学：总应变增量分解为 $\\Delta\\varepsilon = \\Delta\\varepsilon^{e} + \\Delta\\varepsilon^{p}$，其中 $\\varepsilon$ 表示应变张量，上标 $e$ 和 $p$ 分别表示弹性和塑性部分。\n- 具有拉梅常数 $\\lambda$ 和 $\\mu$ 的线性各向同性弹性：弹性本构关系为 $\\sigma = \\mathbb{C} : \\varepsilon^{e}$，其中 $\\mathbb{C}$ 由 $\\mathbb{C} : A = \\lambda \\,\\mathrm{tr}(A)\\,\\mathbf{I} + 2\\mu\\,A$ 给出（对于任何对称二阶张量 $A$）。体积模量 $K$ 和剪切模量 $G$ 满足 $\\lambda = K - \\tfrac{2}{3}G$ 和 $\\mu = G$。\n- 二阶应力张量 $\\sigma$ 的应力不变量：第一不变量 $I_{1} = \\mathrm{tr}(\\sigma)$ 和第二偏应力不变量 $J_{2} = \\tfrac{1}{2} s : s$，其中 $s = \\sigma - \\tfrac{1}{3}I_{1}\\mathbf{I}$ 是偏应力，而 $:$ 表示双点积。\n- 具有线性各向同性硬化的 Drucker–Prager 屈服函数：$f(\\sigma,\\kappa) = \\alpha I_{1} + \\sqrt{J_{2}} - k(\\kappa)$，其中 $k(\\kappa) = k_{0} + H \\kappa$，$\\alpha  0$ 是一个材料参数，$k_{0}$ 是初始类聚内力参数，$H \\ge 0$ 是硬化模量，$\\kappa$ 是一个标量内变量。关联流动法则使用塑性势 $g(\\sigma,\\kappa) = f(\\sigma,\\kappa)$，因此 $\\Delta\\varepsilon^{p} = \\Delta\\lambda\\,\\partial g/\\partial \\sigma$，其中 $\\Delta\\lambda \\ge 0$ 是塑性乘子增量。\n- 弹性预测步为给定的应变子增量 $\\delta\\varepsilon$ 构建试探应力：$\\sigma^{tr} = \\sigma^{n} + \\mathbb{C} : \\delta\\varepsilon$，其中 $\\sigma^{n}$ 是子步开始时的应力。试探屈服函数为 $f^{tr} = f(\\sigma^{tr},\\kappa^{n})$。\n- 显式塑性校正步基于在子步内线性化屈服函数并冻结模量和流动方向。令 $n = \\partial f/\\partial \\sigma$，在子步开始时进行评估。则显式更新满足 $\\sigma^{n+1} = \\sigma^{tr} - \\left(\\mathbb{C} : n\\right)\\Delta\\lambda$，$\\kappa^{n+1} = \\kappa^{n} + \\Delta\\lambda$，塑性乘子增量由一阶一致性近似得到 $\\Delta\\lambda = \\dfrac{f^{tr}}{n : \\mathbb{C} : n + H}$。所有缩并均在张量索引上进行。在 $J_{2} = 0$ 附近对 $\\sqrt{J_{2}}$ 的导数使用正则化，以避免除以零。\n\n算法要求：\n- 实现一个自适应子步策略，将总应变增量 $\\Delta\\varepsilon$ 细分为 $N$ 个相等的子步 $\\delta\\varepsilon = \\Delta\\varepsilon/N$，从 $N = 1$ 开始，并根据需要将 $N$ 加倍。\n- 对每个子步，计算弹性预测应力 $\\sigma^{tr}$ 和试探屈服值 $f^{tr}$。如果 $f^{tr} \\le 0$，则接受该步为弹性步：对于该子步，设置 $\\sigma^{n+1} = \\sigma^{tr}$ 和 $\\kappa^{n+1} = \\kappa^{n}$。如果 $f^{tr}  0$，则强制执行目标范围条件 $0  f^{tr} \\le \\tau$（给定阈值 $\\tau  0$）；如果在当前 $N$ 下，任何子步的 $f^{tr}  \\tau$，则将 $N$ 增加一倍，并从头重新开始子步序列。持续此过程，直到所有子步都满足条件。\n- 当 $f^{tr}  0$ 且满足 $f^{tr} \\le \\tau$ 时，使用上述定义对该子步执行显式塑性校正。然后继续下一个子步。\n- 当所有子步都处理完毕后停止，并返回最终应力和所使用的子步数 $N$。使用最大上限 $N_{\\max}$ 防止无限循环；如果达到该上限，则按原样返回当前结果。\n\n实现约定：\n- 使用拉为正的符号约定。应力必须以千帕 (kPa) 表示，四舍五入到三位小数。应变为无量纲。\n- 在内部将应力和应变表示为对称的 $3 \\times 3$ 张量。输入的总应变增量以 Voigt 形式 $[\\Delta\\varepsilon_{11}, \\Delta\\varepsilon_{22}, \\Delta\\varepsilon_{33}, \\Delta\\gamma_{23}, \\Delta\\gamma_{13}, \\Delta\\gamma_{12}]$ 指定，其中 $\\Delta\\gamma_{ij} = 2 \\Delta\\varepsilon_{ij}$ 是工程剪切应变。在应用 $\\mathbb{C}$ 之前将其转换为张量形式，并在报告应力分量时转换回 Voigt 形式。\n- 对于导数 $\\partial f/\\partial \\sigma$，使用 $n = \\alpha \\mathbf{I} + \\dfrac{s}{2\\sqrt{J_{2}}}$，并使用正则化 $\\sqrt{J_{2}} \\leftarrow \\max(\\sqrt{J_{2}}, \\epsilon)$（对于一个小的 $\\epsilon  0$）。\n\n测试套件：\n对于所有测试用例，初始应力张量为零，初始硬化变量为 $\\kappa^{0} = 0$。提供以下四个测试用例，每个用例指定为一组参数 $(K, G, \\alpha, H, k_{0}, \\Delta\\varepsilon, \\tau)$，其中 $K$ 和 $G$ 的单位为 kPa，$H$ 和 $k_{0}$ 的单位为 kPa，应变增量为无量纲，$\\tau$ 的单位为 kPa：\n1. $(20000, 10000, 0.12, 800, 100, [2\\times10^{-4}, 0, 0, 0, 0, 1\\times10^{-4}], 5)$\n2. $(20000, 10000, 0.12, 800, 100, [1\\times10^{-7}, 1\\times10^{-7}, 1\\times10^{-7}, 0, 0, 0], 5)$\n3. $(15000, 7000, 0.18, 500, 80, [0, 0, 0, 8\\times10^{-4}, 0, 0], 2)$\n4. $(25000, 12000, 0.10, 1200, 50, [4\\times10^{-4}, 4\\times10^{-4}, 4\\times10^{-4}, 0, 0, 0], 3)$\n\n您的程序必须为每个测试用例计算最终的应力分量（按 Voigt 顺序 $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]$，单位为 kPa，四舍五入到三位小数）和所用的子步数 $N$。最终输出格式必须是包含一个 Python 风格列表的单行，该列表包含四个结果，每个测试用例一个，其中每个结果是一个包含七个值的列表：六个应力分量后跟整数 $N$。例如：“[[s11,s22,s33,s23,s13,s12,N], [...], [...], [...]]”。", "solution": "用户提供了一个在计算岩土力学领域中定义明确的问题。该问题具有科学依据、内容完备且客观。任务是为遵循 Drucker-Prager 模型并带有线性各向同性硬化的弹塑性材料实现一个自适应显式应力积分方案。所提供的方程和算法结构是该领域的标准做法，并且逻辑上是一致的。因此，该问题被认为是有效的。\n\n解决方案的制定首先将所提供的张量方程形式化，然后按照规定构建自适应算法。所有数学实体均遵循强制性的 LaTeX 格式。\n\n### 1. 预备知识：张量和本构关系\n\n材料响应由线性各向同性弹性和 Drucker-Prager 屈服准则控制。\n\n- **弹性**：应力张量 $\\sigma$ 通过胡克定律与弹性应变张量 $\\varepsilon^e$ 相关，即 $\\sigma = \\mathbb{C} : \\varepsilon^e$，其中 $\\mathbb{C}$ 是四阶弹性张量。对于各向同性材料，其表达式为：\n$$\n\\mathbb{C} : A = \\lambda \\,\\mathrm{tr}(A)\\,\\mathbf{I} + 2\\mu\\,A\n$$\n对于任何对称二阶张量 $A$。拉梅参数 $\\lambda$ 和 $\\mu$ 与体积模量 $K$ 和剪切模量 $G$ 的关系为 $\\lambda = K - \\frac{2}{3}G$ 和 $\\mu = G$。\n\n- **Voigt 标记法**：应变以 Voigt 向量形式 $\\Delta\\varepsilon_v = [\\Delta\\varepsilon_{11}, \\Delta\\varepsilon_{22}, \\Delta\\varepsilon_{33}, \\Delta\\gamma_{23}, \\Delta\\gamma_{13}, \\Delta\\gamma_{12}]$ 提供。必须将其转换为 $3 \\times 3$ 的对称张量形式 $\\Delta\\varepsilon$，需注意这里使用的是工程剪切应变，即对于 $i \\neq j$，有 $\\Delta\\gamma_{ij} = 2\\Delta\\varepsilon_{ij}$。\n$$\n\\Delta\\varepsilon =\n\\begin{pmatrix}\n\\Delta\\varepsilon_{11}  \\frac{1}{2}\\Delta\\gamma_{12}  \\frac{1}{2}\\Delta\\gamma_{13} \\\\\n\\frac{1}{2}\\Delta\\gamma_{12}  \\Delta\\varepsilon_{22}  \\frac{1}{2}\\Delta\\gamma_{23} \\\\\n\\frac{1}{2}\\Delta\\gamma_{13}  \\frac{1}{2}\\Delta\\gamma_{23}  \\Delta\\varepsilon_{33}\n\\end{pmatrix}\n$$\n最终计算出的应力张量 $\\sigma$ 会被转换回 Voigt 形式 $[\\sigma_{11}, \\sigma_{22}, \\sigma_{33}, \\sigma_{23}, \\sigma_{13}, \\sigma_{12}]$ 以供输出。\n\n- **Drucker-Prager 模型**：屈服函数 $f$ 定义了弹性域的边界：\n$$\nf(\\sigma, \\kappa) = \\alpha I_1 + \\sqrt{J_2} - k(\\kappa)\n$$\n其中 $I_1 = \\mathrm{tr}(\\sigma)$ 是应力第一不变量，$J_2 = \\frac{1}{2}s:s$ 是偏应力 $s = \\sigma - \\frac{1}{3}I_1\\mathbf{I}$ 的第二不变量，$\\alpha  0$ 是一个材料参数。硬化是线性和各向同性的，定义为 $k(\\kappa) = k_0 + H\\kappa$，其中 $k_0$ 是初始类聚内力参数，$H \\ge 0$ 是硬化模量，$\\kappa$ 是内部硬化变量。$\\kappa$ 的演化由 $\\dot{\\kappa} = \\dot{\\lambda}$ 给出，其中 $\\dot{\\lambda}$ 是塑性乘子的率。\n\n### 2. 自适应显式积分算法\n\n总应变增量 $\\Delta\\varepsilon_{total}$ 在一系列子步中施加。该算法自适应地优化子步数 $N$ 以确保显式塑性校正的准确性。\n\n单个总应变增量的总体流程如下：\n1. 初始化应力 $\\sigma = \\sigma_0$ 和硬化变量 $\\kappa = \\kappa_0$。对于本问题，$\\sigma_0 = \\mathbf{0}$ 且 $\\kappa_0 = 0$。\n2. 从 $N=1$ 个子步开始。设置一个最大值 $N_{max}$ (例如 $2048$) 以防止无限循环。\n3. 进入一个循环，只要 $N \\le N_{max}$ 就继续：\n    a. 将状态重置为总增量开始时的状态：$\\sigma_{current} = \\sigma_0$，$\\kappa_{current} = \\kappa_0$。\n    b. 计算每个子步的应变增量：$\\delta\\varepsilon = \\Delta\\varepsilon_{total} / N$。\n    c. 设置一个标志 `restart_needed = false`。\n    d. 从 $i=1$ 到 $N$ 遍历每个子步：\n        i.   使用当前状态 $(\\sigma_{current}, \\kappa_{current})$ 和应变增量 $\\delta\\varepsilon$ 执行一个积分步。该步骤（详见下文）返回更新后的状态 $(\\sigma_{new}, \\kappa_{new})$ 和一个状态（“ok”或“failure”）。\n        ii.  如果状态是“failure”，则设置 `restart_needed = true` 并中断内部子步循环。\n        iii. 如果状态是“ok”，则为下一个子步更新状态：$\\sigma_{current} = \\sigma_{new}$，$\\kappa_{current} = \\kappa_{new}$。\n    e. 子步循环结束后，如果 `restart_needed` 为 true，则将子步数加倍 ($N \\leftarrow 2N$) 并继续主循环的下一次迭代。\n    f. 如果子步循环成功完成，则积分完成。最终状态为 $(\\sigma_{current}, \\kappa_{current})$。中断主循环。\n4. 报告最终应力张量和子步数 $N$。\n\n### 3. 单个子步积分\n\n对于每个子步，从状态 $(\\sigma^n, \\kappa^n)$ 开始，使用弹性预测-塑性校正方案。\n\n1.  **弹性预测**：假设整个子步应变增量 $\\delta\\varepsilon$ 是弹性的，计算出试探应力 $\\sigma^{tr}$：\n    $$\n    \\sigma^{tr} = \\sigma^n + \\mathbb{C} : \\delta\\varepsilon = \\sigma^n + \\lambda\\,\\mathrm{tr}(\\delta\\varepsilon)\\mathbf{I} + 2\\mu\\,\\delta\\varepsilon\n    $$\n\n2.  **屈服检查**：在试探状态下评估屈服函数，使用子步开始时的硬化状态：\n    $$\n    f^{tr} = f(\\sigma^{tr}, \\kappa^n) = \\alpha I_1^{tr} + \\sqrt{J_2^{tr}} - (k_0 + H\\kappa^n)\n    $$\n    其中 $I_1^{tr} = \\mathrm{tr}(\\sigma^{tr})$，$J_2^{tr}$ 是 $\\sigma^{tr}$ 的第二偏应力不变量。\n\n3.  **状态更新逻辑**：\n    a. **弹性步**：如果 $f^{tr} \\le 0$，则状态是弹性的或位于屈服面上。接受试探状态：\n       $$\n       \\sigma^{n+1} = \\sigma^{tr} \\quad , \\quad \\kappa^{n+1} = \\kappa^n\n       $$\n       该子步成功完成。\n    b. **塑性步检查**：如果 $f^{tr}  0$，则发生塑性变形。$f^{tr}$ 的大小是显式方案中误差的一个指标。\n       - 如果 $f^{tr}  \\tau$（其中 $\\tau$ 是指定的容差），则误差过大。子步尺寸过粗。子步计算失败，触发以更小的子步尺寸（更大的 $N$）重新开始整个过程。\n       - 如果 $0  f^{tr} \\le \\tau$，则误差可以接受。继续进行塑性校正。\n\n4.  **显式塑性校正**：当 $0  f^{tr} \\le \\tau$ 时，将状态返回到屈服面。\n    a. 使用一阶近似计算塑性乘子增量 $\\Delta\\lambda$：\n       $$\n       \\Delta\\lambda = \\frac{f^{tr}}{n^{tr} : \\mathbb{C} : n^{tr} + H}\n       $$\n       其中 $n^{tr} = \\frac{\\partial f}{\\partial \\sigma}\\big|_{\\sigma^{tr}}$ 是在试探应力下评估的流动方向。\n    b. 对于 Drucker-Prager 模型，$n^{tr} = \\alpha\\mathbf{I} + \\frac{s^{tr}}{2\\sqrt{J_2^{tr}}}$。只要 $J_2^{tr} \\neq 0$，分母项就简化为材料常数表达式：\n       $$\n       n^{tr}:\\mathbb{C}:n^{tr} + H = 9K\\alpha^2 + G + H\n       $$\n       为了处理 $J_2^{tr} \\to 0$ 时的顶点奇异性，使用了一个正则化表达式：$A = 9K\\alpha^2 + G \\frac{J_2^{tr}}{\\max(J_2^{tr}, \\epsilon^2)} + H$，对于一个小的容差 $\\epsilon$。然后塑性乘子为 $\\Delta\\lambda = f^{tr}/A$。\n    c. 更新应力和硬化变量：\n       $$\n       \\sigma^{n+1} = \\sigma^{tr} - \\Delta\\lambda (\\mathbb{C}:n^{tr})\n       $$\n       $$\n       \\kappa^{n+1} = \\kappa^n + \\Delta\\lambda\n       $$\n       项 $\\mathbb{C}:n^{tr}$ 展开为 $\\mathbb{C}:n^{tr} = 3K\\alpha\\mathbf{I} + 2G n_{dev}^{tr}$，其中 $n_{dev}^{tr}$ 是 $n^{tr}$ 的偏量部分。在计算 $n_{dev}^{tr}$ 时，通过使用 $\\sqrt{J_2^{tr}} \\leftarrow \\max(\\sqrt{J_2^{tr}}, \\epsilon)$ 对 $\\sqrt{J_2}$ 的导数进行正则化，以避免除以零。然后该子步成功完成。\n\n至此，基于所提供原则的算法设计的详细描述完成。", "answer": "```python\nimport numpy as np\n\ndef voigt_to_tensor(v_strain):\n    \"\"\"Converts a 6x1 Voigt strain vector to a 3x3 strain tensor.\"\"\"\n    eps = np.zeros((3, 3))\n    eps[0, 0] = v_strain[0]\n    eps[1, 1] = v_strain[1]\n    eps[2, 2] = v_strain[2]\n    # Engineering shear strain to tensor shear strain conversion\n    eps[1, 2] = eps[2, 1] = v_strain[3] / 2.0\n    eps[0, 2] = eps[2, 0] = v_strain[4] / 2.0\n    eps[0, 1] = eps[1, 0] = v_strain[5] / 2.0\n    return eps\n\ndef tensor_to_voigt(t_stress):\n    \"\"\"Converts a 3x3 stress tensor to a 6x1 Voigt stress vector.\"\"\"\n    return np.array([\n        t_stress[0, 0],\n        t_stress[1, 1],\n        t_stress[2, 2],\n        t_stress[1, 2],\n        t_stress[0, 2],\n        t_stress[0, 1]\n    ])\n\ndef run_stress_integration(params):\n    \"\"\"\n    Performs adaptive explicit stress integration for a single test case.\n    \"\"\"\n    K, G, alpha, H, k0, delta_eps_voigt, tau = params\n    \n    delta_eps_total_tensor = voigt_to_tensor(delta_eps_voigt)\n    \n    # Lame parameters\n    lambda_lame = K - (2.0 / 3.0) * G\n    mu_lame = G\n\n    # Regularization epsilon\n    epsilon = 1e-12\n\n    # Adaptive substepping loop\n    N = 1\n    N_max = 2048\n    \n    while N = N_max:\n        # State variables at the start of the total increment\n        sigma_current = np.zeros((3, 3))\n        kappa_current = 0.0\n        \n        delta_eps_sub = delta_eps_total_tensor / N\n        \n        restart_needed = False\n        for _ in range(N):\n            # Elastic Predictor\n            tr_delta_eps_sub = np.trace(delta_eps_sub)\n            sigma_tr = sigma_current + lambda_lame * tr_delta_eps_sub * np.eye(3) + 2.0 * mu_lame * delta_eps_sub\n\n            # Yield Check\n            I1_tr = np.trace(sigma_tr)\n            s_tr = sigma_tr - (I1_tr / 3.0) * np.eye(3)\n            J2_tr = 0.5 * np.sum(s_tr * s_tr)\n            \n            # Avoid sqrt of negative J2 from machine precision errors\n            if J2_tr  0: J2_tr = 0\n            sqrt_J2_tr = np.sqrt(J2_tr)\n            \n            k_n = k0 + H * kappa_current\n            f_tr = alpha * I1_tr + sqrt_J2_tr - k_n\n\n            if f_tr = 0:\n                # Elastic step\n                sigma_current = sigma_tr\n                # kappa_current remains unchanged\n            else:\n                if f_tr  tau:\n                    restart_needed = True\n                    break\n                else:\n                    # Explicit Plastic Corrector\n                    denom_A = 9.0 * K * alpha**2 + G * J2_tr / max(J2_tr, epsilon**2) + H\n                    delta_lambda = f_tr / denom_A\n\n                    sqrt_J2_tr_reg = max(sqrt_J2_tr, epsilon)\n                    n_dev_tr = s_tr / (2.0 * sqrt_J2_tr_reg)\n\n                    correction_term = delta_lambda * (3.0 * K * alpha * np.eye(3) + 2.0 * G * n_dev_tr)\n                    \n                    sigma_current = sigma_tr - correction_term\n                    kappa_current = kappa_current + delta_lambda\n\n        if restart_needed:\n            N *= 2\n            continue\n        else:\n            # All substeps successful\n            final_sigma = sigma_current\n            break\n    \n    if N  N_max:\n        # Loop terminated due to N_max, return current result\n        final_sigma = sigma_current\n\n    final_stress_voigt = tensor_to_voigt(final_sigma)\n    rounded_stress = [round(s, 3) for s in final_stress_voigt]\n    \n    return rounded_stress + [N]\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the stress integration for each.\n    \"\"\"\n    test_cases = [\n        (20000, 10000, 0.12, 800, 100, np.array([2e-4, 0, 0, 0, 0, 1e-4]), 5),\n        (20000, 10000, 0.12, 800, 100, np.array([1e-7, 1e-7, 1e-7, 0, 0, 0]), 5),\n        (15000, 7000, 0.18, 500, 80, np.array([0, 0, 0, 8e-4, 0, 0]), 2),\n        (25000, 12000, 0.10, 1200, 50, np.array([4e-4, 4e-4, 4e-4, 0, 0, 0]), 3)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_stress_integration(case)\n        results.append(result)\n\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3523495"}]}