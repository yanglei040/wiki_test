{"hands_on_practices": [{"introduction": "选择合适的非线性求解器需要在每次迭代的计算成本与收敛所需的总迭代次数之间做出关键权衡。本练习提供了一个实用框架，通过建立一个详细的计算成本模型，来比较经典的牛顿-拉夫逊 (Newton-Raphson) 方法与更简单的皮卡 (Picard) 迭代。通过分析残差组装、雅可比矩阵构建和线性求解等环节的贡献，您将对“更快收敛但更昂贵的牛顿法”在何种情况下比“更便宜但更慢的迭代法”更高效有一个定量的理解。", "problem": "考虑一个计算岩土力学中的平面应变多孔弹性的非线性水力-力学有限元模型。全局层面的控制离散平衡由残差向量 $\\mathbf{R}(\\mathbf{x})$ 表示，其雅可比（切线刚度）矩阵为 $\\mathbf{J}(\\mathbf{x}) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{x}}$。考虑两种非线性求解策略：定点 (Picard) 迭代和牛顿-拉夫逊 (Newton-Raphson, NR) 方法。代表性网格是一个矩形上的结构化网格，由四节点四边形单元组成，其中沿水平方向有 $n_x = 80$ 个单元，沿垂直方向有 $n_y = 50$ 个单元。单元总数为 $N_e = n_x n_y$，节点总数为 $N_n = (n_x + 1)(n_y + 1)$，自由度 (DOF) 总数为 $N_d = m N_n$，其中每个节点有 $m = 3$ 个自由度（两个位移和一个孔隙压力）。\n\n假设以下以挂钟时间表示的计算工作模型：\n1. 每次迭代的残差组装主要由局部本构评估和全局向量组装决定，建模为\n$$\nT_R = N_e \\left( N_q \\, t_r + t_{ra} \\right),\n$$\n其中每个单元有 $N_q = 4$ 个高斯点，$t_r = 2.5 \\times 10^{-6} \\ \\text{s}$ 是每个高斯点残差评估的成本，而 $t_{ra} = 1.0 \\times 10^{-6} \\ \\text{s}$ 是每个单元全局残差组装的开销。\n\n2. 每次迭代的雅可比组装建模为\n$$\nT_J = N_e \\left( N_q \\, t_j + t_{ja} \\right),\n$$\n其中 $t_j = 1.0 \\times 10^{-5} \\ \\text{s}$ 是每个高斯点雅可比贡献评估的成本，而 $t_{ja} = 4.0 \\times 10^{-6} \\ \\text{s}$ 是每个单元全局矩阵组装的开销。\n\n3. 线性系统通过 Krylov 方法求解，具体为预条件广义最小残差 (GMRES) 方法。设每行的平均非零元个数为 $s = 70$，因此非零元总数为 $\\mathrm{nnz} = s N_d$。每次 GMRES 迭代的成本建模为\n$$\nT_{\\text{lin,iter}} = \\mathrm{nnz} \\, t_{nz} + N_d \\, t_p,\n$$\n其中对于稀疏矩阵向量乘法，每个非零元的成本为 $t_{nz} = 1.0 \\times 10^{-9} \\ \\text{s}$，对于应用右预条件子，每个自由度的成本为 $t_p = 5.0 \\times 10^{-9} \\ \\text{s}$。每次雅可比组装时构建预条件子的成本为\n$$\nT_b = \\mathrm{nnz} \\, t_b,\n$$\n其中每个非零元的成本为 $t_b = 5.0 \\times 10^{-9} \\ \\text{s}$。\n\n对于 Picard 迭代，全局切线固定为初始线性化形式（在开始时组装一次），并且在每个外迭代中评估 $\\mathbf{R}(\\mathbf{x})$。对于 Picard 求解器，假设有 $K_P = 20$ 次外迭代，每次外迭代有 $L_P = 45$ 次 GMRES 迭代。对于 Newton-Raphson 求解器，在 $K_N = 6$ 次外迭代的每一次中，都会组装 $\\mathbf{R}(\\mathbf{x})$ 和 $\\mathbf{J}(\\mathbf{x})$，构建一个新的预条件子，并执行 $L_N = 30$ 次 GMRES 迭代。\n\n使用上述模型和参数，计算无量纲比率\n$$\n\\mathcal{R} = \\frac{T_{\\text{Picard}}}{T_{\\text{Newton}}},\n$$\n其中 $T_{\\text{Picard}}$ 是 Picard 方法的总时间，$T_{\\text{Newton}}$ 是 Newton-Raphson 方法的总时间，两者都是在其各自的外迭代中累积的。将 $\\mathcal{R}$ 的最终答案四舍五入到四位有效数字。该比率为无量纲；报告时无需单位。", "solution": "该问题已经过验证，被确定为计算力学中一个适定、有科学依据的问题。任务是计算两种标准非线性求解算法的计算时间的无量纲比率。求解过程首先计算模型尺寸，然后计算基本计算任务的成本，最后计算每种算法的总成本以求出它们的比率。\n\n第一步是计算有限元模型离散化的关键参数。\n单元数量由 $N_e = n_x n_y$ 给出。当 $n_x = 80$ 和 $n_y = 50$ 时，其值为：\n$$N_e = 80 \\times 50 = 4000$$\n节点数量为 $N_n = (n_x + 1)(n_y + 1)$：\n$$N_n = (80 + 1)(50 + 1) = 81 \\times 51 = 4131$$\n总自由度 (DOF) 数量为 $N_d = m N_n$，每个节点有 $m = 3$ 个自由度：\n$$N_d = 3 \\times 4131 = 12393$$\n雅可比矩阵中的非零元总数为 $\\mathrm{nnz} = s N_d$，平均每行有 $s = 70$ 个非零元：\n$$\\mathrm{nnz} = 70 \\times 12393 = 867510$$\n\n接下来，我们根据提供的成本模型评估每个基本计算操作的挂钟时间。\n\n1.  每次迭代的残差向量组装成本 $T_R$ 为：\n    $$T_R = N_e \\left( N_q \\, t_r + t_{ra} \\right)$$\n    使用给定值 $N_e = 4000$, $N_q = 4$, $t_r = 2.5 \\times 10^{-6}$ 和 $t_{ra} = 1.0 \\times 10^{-6}$：\n    $$T_R = 4000 \\left( 4 \\times 2.5 \\times 10^{-6} + 1.0 \\times 10^{-6} \\right) = 4000 \\left( 1.0 \\times 10^{-5} + 1.0 \\times 10^{-6} \\right) = 4000 \\left( 1.1 \\times 10^{-5} \\right) = 0.044$$\n\n2.  每次迭代的雅可比矩阵组装成本 $T_J$ 为：\n    $$T_J = N_e \\left( N_q \\, t_j + t_{ja} \\right)$$\n    使用 $t_j = 1.0 \\times 10^{-5}$ 和 $t_{ja} = 4.0 \\times 10^{-6}$：\n    $$T_J = 4000 \\left( 4 \\times 1.0 \\times 10^{-5} + 4.0 \\times 10^{-6} \\right) = 4000 \\left( 4.0 \\times 10^{-5} + 0.4 \\times 10^{-5} \\right) = 4000 \\left( 4.4 \\times 10^{-5} \\right) = 0.176$$\n\n3.  构建预条件子的成本 $T_b$ 为：\n    $$T_b = \\mathrm{nnz} \\, t_b$$\n    使用 $\\mathrm{nnz} = 867510$ 和 $t_b = 5.0 \\times 10^{-9}$：\n    $$T_b = 867510 \\times 5.0 \\times 10^{-9} = 0.00433755$$\n\n4.  GMRES 线性求解器每次迭代的成本 $T_{\\text{lin,iter}}$ 为：\n    $$T_{\\text{lin,iter}} = \\mathrm{nnz} \\, t_{nz} + N_d \\, t_p$$\n    使用 $t_{nz} = 1.0 \\times 10^{-9}$ 和 $t_p = 5.0 \\times 10^{-9}$：\n    $$T_{\\text{lin,iter}} = 867510 \\times 1.0 \\times 10^{-9} + 12393 \\times 5.0 \\times 10^{-9} = 0.00086751 + 0.000061965 = 0.000929475$$\n\n现在，我们可以计算两种非线性求解策略中每一种的总计算时间。\n\n对于 Picard 迭代，总时间 $T_{\\text{Picard}}$ 包括一次性的初始设置成本（雅可比组装和预条件子构建）加上 $K_P = 20$ 次迭代的累积成本。每次迭代包括一次残差组装和一次包含 $L_P = 45$ 次 GMRES 迭代的线性求解。\n$$T_{\\text{Picard}} = (T_J + T_b) + K_P \\left( T_R + L_P T_{\\text{lin,iter}} \\right)$$\n$$T_{\\text{Picard}} = (0.176 + 0.00433755) + 20 \\left( 0.044 + 45 \\times 0.000929475 \\right)$$\n$$T_{\\text{Picard}} = 0.18033755 + 20 \\left( 0.044 + 0.041826375 \\right)$$\n$$T_{\\text{Picard}} = 0.18033755 + 20 \\left( 0.085826375 \\right)$$\n$$T_{\\text{Picard}} = 0.18033755 + 1.7165275 = 1.89686505$$\n\n对于 Newton-Raphson 方法，总时间 $T_{\\text{Newton}}$ 是单次迭代的成本乘以迭代次数 $K_N = 6$。每次迭代都包括组装残差和雅可比矩阵，构建预条件子，以及执行一次包含 $L_N = 30$ 次 GMRES 迭代的线性求解。\n$$T_{\\text{Newton}} = K_N \\left( T_R + T_J + T_b + L_N T_{\\text{lin,iter}} \\right)$$\n$$T_{\\text{Newton}} = 6 \\left( 0.044 + 0.176 + 0.00433755 + 30 \\times 0.000929475 \\right)$$\n$$T_{\\text{Newton}} = 6 \\left( 0.044 + 0.176 + 0.00433755 + 0.02788425 \\right)$$\n$$T_{\\text{Newton}} = 6 \\left( 0.2522218 \\right) = 1.5133308$$\n\n最后，通过将 Picard 方法的总时间除以 Newton-Raphson 方法的总时间，计算出无量纲比率 $\\mathcal{R}$。\n$$\\mathcal{R} = \\frac{T_{\\text{Picard}}}{T_{\\text{Newton}}} = \\frac{1.89686505}{1.5133308} \\approx 1.253434$$\n按要求将结果四舍五入到四位有效数字：\n$$\\mathcal{R} \\approx 1.253$$", "answer": "$$\\boxed{1.253}$$", "id": "3561408"}, {"introduction": "虽然直接 (皮卡) 迭代实现简单，但其缓慢的线性收敛速度可能成为一个显著的瓶颈。安德森加速 (Anderson Acceleration) 是一种强大的“无雅可比”技术，用于加速这类定点迭代的收敛。本问题将引导您推导该方法的原理，在一个简单的案例中应用它，并促使您批判性地思考其与基本皮卡迭代和完全牛顿-拉夫逊方法相比的计算优劣权衡。", "problem": "考虑计算岩土力学中的一个非线性有限元模型，该模型耦合了饱和土中的孔隙压力和变形，其中渗透系数通过一个状态依赖关系取决于孔隙压力。设孔隙压力自由度的离散非线性代数系统被写为一个不动点问题 $x = G(x)$，其中 $x \\in \\mathbb{R}^{n}$ 是孔隙压力的节点向量，而 $G:\\mathbb{R}^{n} \\rightarrow \\mathbb{R}^{n}$ 是通过将在最近一次迭代中评估的渗透系数代入并组装有限元残差而得到的不动点映射。基本的直接迭代为 $x_{k+1} = G(x_{k})$。定义残差 $f(x) = G(x) - x$，并注意 Picard (不动点) 迭代的收敛性要求 $G$ 具有适当的收缩性。\n\n任务1：仅从不动点迭代 $x_{k+1} = G(x_{k})$ 和残差 $f(x) = G(x) - x$ 的定义出发，解释在该岩土力学背景下，用于不动点迭代的 Anderson 加速 (AA) 的思想是形成过去映射迭代点的仿射组合，并推导出确定历史长度为 $m \\geq 1$ 的混合系数的最小二乘问题。您的推导必须从这些定义开始，并逐步构建一个约束最小化问题，该问题产生的系数是在仿射组合约束条件下最小化残差组合的欧几里得范数的系数。使用 Lagrange 乘子推导最优性条件。\n\n任务2：对于 $m = 1$ 的特定情况（使用两个连续的迭代），假设在迭代 $k-1$ 和 $k$ 时的残差在 $\\mathbb{R}^{2}$ 中由 $r_{k-1} = \\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$ 和 $r_{k} = \\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$ 给出。在仿射组合约束 $\\alpha_{k-1} + \\alpha_{k} = 1$ 的条件下，计算与 $r_{k-1}$ 相关联的、在最小二乘意义下最小化残差范数的混合系数 $\\alpha_{k-1}$。最终答案以实数形式表示，四舍五入到四位有效数字。\n\n任务3：讨论对于大規模有限元岩土力学问题，Anderson 加速与 Newton-Raphson 和普通 Picard 迭代相比的存储和计算权衡，重点关注内存和每次迭代的算术运算量如何随自由度数 $n$ 和历史长度 $m$ 而变化。在提及 Newton-Raphson 时，首次使用应写全为 Newton-Raphson (NR)，并基于一个经过充分检验的实践进行比较，即 NR 迭代主要由线性化系统的组装和求解主导，而 AA 通过重复使用残差的小型稠密最小二乘子问题来增强 Picard 迭代。", "solution": "该问题是有效的，因为它在计算岩土力学和数值分析方面有科学依据，每个任务的信息充分、问题适定，并使用了客观、正式的语言。它没有说明中列出的使其无效的缺陷。\n\n### 任务1：Anderson 加速的推导\n目标是加速不动点迭代的收敛，在当前的岩土力学背景下，该迭代用于模拟孔隙压力的非线性系统。\n\n基本的不动点迭代，也称为 Picard 迭代或直接迭代，由下式给出：\n$$ x_{k+1} = G(x_k) $$\n其中 $x_k \\in \\mathbb{R}^n$ 是第 $k$ 次迭代时的节点孔隙压力向量。当 $x^* = G(x^*)$ 时，或者等效地，当残差 $f(x^*) = G(x^*) - x^*$ 为零时，就找到了一个解 $x^*$。\n\nAnderson 加速 (AA) 旨在通过从先前迭代的历史中进行外推，找到一个更好的下一个迭代点 $x_{k+1}$。AA 不仅仅使用最后一个映射点 $G(x_k)$，而是将下一个迭代点构造为最近 $m+1$ 个映射点 $\\{G(x_{k-m}), \\dots, G(x_k)\\}$ 的仿射组合。设历史长度为 $m \\ge 1$，并假设 $k \\ge m$。\n\n新的迭代点 $x_{k+1}$ 定义为：\n$$ x_{k+1} = \\sum_{i=0}^{m} \\gamma_i^{(k)} G(x_{k-i}) $$\n其中系数 $\\gamma_i^{(k)}$ 必须满足仿射组合约束：\n$$ \\sum_{i=0}^{m} \\gamma_i^{(k)} = 1 $$\nAA 的核心思想是以最优方式选择系数 $\\boldsymbol{\\gamma}^{(k)} = (\\gamma_0^{(k)}, \\dots, \\gamma_m^{(k)})^T$。$\\boldsymbol{\\gamma}^{(k)}$ 的理想选择是能够最小化新点处真实残差的范数 $\\|f(x_{k+1})\\|_2 = \\|G(x_{k+1}) - x_{k+1}\\|_2$。然而，计算这个值需要在未知点 $x_{k+1}$ 处对非线性函数 $G$ 进行评估，这在计算上是不可行的。\n\n取而代之，AA 做了一个关键的简化近似。它寻求最小化一个近似残差的范数，该近似残差是通过将相同的仿射组合应用于过去的残差 $\\{r_{k-m}, \\dots, r_k\\}$ 而形成的，其中 $r_j = f(x_j) = G(x_j) - x_j$。这样做的动机是基于假设映射 $G$ 在最近的迭代点集合上是近似线性的。如果 $G$ 是线性的，那么组合的残差将等于残差的组合。\n\n因此，系数的优化问题被表述为一个约束线性最小二乘问题：\n$$ \\min_{\\boldsymbol{\\gamma}^{(k)} \\in \\mathbb{R}^{m+1}} \\left\\| \\sum_{i=0}^{m} \\gamma_i^{(k)} r_{k-i} \\right\\|_2^2 \\quad \\text{subject to} \\quad \\sum_{i=0}^{m} \\gamma_i^{(k)} = 1 $$\n为了将其形式化，设 $\\mathbf{F}_k$ 是一个 $n \\times (m+1)$ 的矩阵，其列向量是过去的残差向量：\n$$ \\mathbf{F}_k = \\begin{pmatrix} r_{k} & r_{k-1} & \\cdots & r_{k-m} \\end{pmatrix} $$\n设 $\\mathbf{1}$ 是一个大小为 $m+1$ 的全1向量。优化问题变为：\n$$ \\min_{\\boldsymbol{\\gamma}^{(k)}} \\| \\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)} \\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{1}^T \\boldsymbol{\\gamma}^{(k)} = 1 $$\n目标函数为 $J(\\boldsymbol{\\gamma}^{(k)}) = (\\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)})^T (\\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)}) = (\\boldsymbol{\\gamma}^{(k)})^T \\mathbf{F}_k^T \\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)}$。\n\n我们使用 Lagrange 乘子法来求解这个约束最小化问题。Lagrange 函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(\\boldsymbol{\\gamma}^{(k)}, \\lambda) = (\\boldsymbol{\\gamma}^{(k)})^T \\mathbf{F}_k^T \\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)} - \\lambda (\\mathbf{1}^T \\boldsymbol{\\gamma}^{(k)} - 1) $$\n通过将关于 $\\boldsymbol{\\gamma}^{(k)}$ 和 $\\lambda$ 的梯度设置为零，可以得到最优性条件。\n$$ \\nabla_{\\boldsymbol{\\gamma}^{(k)}} \\mathcal{L} = 2 \\mathbf{F}_k^T \\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)} - \\lambda \\mathbf{1} = 0 $$\n$$ \\nabla_{\\lambda} \\mathcal{L} = -(\\mathbf{1}^T \\boldsymbol{\\gamma}^{(k)} - 1) = 0 $$\n从第一个条件，我们将 $\\boldsymbol{\\gamma}^{(k)}$ 表示为 $\\lambda$ 的函数：\n$$ 2 \\mathbf{F}_k^T \\mathbf{F}_k \\boldsymbol{\\gamma}^{(k)} = \\lambda \\mathbf{1} $$\n$$ \\boldsymbol{\\gamma}^{(k)} = \\frac{\\lambda}{2} (\\mathbf{F}_k^T \\mathbf{F}_k)^{-1} \\mathbf{1} $$\n这里，我们假设 Gram 矩阵 $\\mathbf{F}_k^T \\mathbf{F}_k$ 是可逆的，如果残差向量 $\\{r_{k-i}\\}$ 是线性无关的，则该假设成立。\n我们将这个表达式代入第二个条件（约束 $\\mathbf{1}^T \\boldsymbol{\\gamma}^{(k)} = 1$）：\n$$ \\mathbf{1}^T \\left( \\frac{\\lambda}{2} (\\mathbf{F}_k^T \\mathbf{F}_k)^{-1} \\mathbf{1} \\right) = 1 $$\n这使我们能够求解包含 Lagrange 乘子的项：\n$$ \\frac{\\lambda}{2} = \\frac{1}{\\mathbf{1}^T (\\mathbf{F}_k^T \\mathbf{F}_k)^{-1} \\mathbf{1}} $$\n将其代回 $\\boldsymbol{\\gamma}^{(k)}$ 的表达式中，得到最优系数的解：\n$$ \\boldsymbol{\\gamma}^{(k)} = \\frac{(\\mathbf{F}_k^T \\mathbf{F}_k)^{-1} \\mathbf{1}}{\\mathbf{1}^T (\\mathbf{F}_k^T \\mathbf{F}_k)^{-1} \\mathbf{1}} $$\n这就提供了能够最小化组合残差的欧几里得范数的系数。然后使用这些最优系数计算下一个迭代点 $x_{k+1}$。\n\n### 任务2：$m=1$ 时的计算\n对于 $m=1$ 的特定情况，我们使用两个连续迭代（例如在步骤 $k-1$ 和 $k$）的历史。残差在 $\\mathbb{R}^2$ 中由 $r_{k-1} = \\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$ 和 $r_{k} = \\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$ 给出。混合系数为 $\\alpha_{k-1}$ 和 $\\alpha_k$，它们必须满足仿射组合约束 $\\alpha_{k-1} + \\alpha_k = 1$。目标是找到 $\\alpha_{k-1}$。\n\n优化问题是最小化组合残差的范数：\n$$ \\min_{\\alpha_{k-1}, \\alpha_k} \\left\\| \\alpha_{k-1} r_{k-1} + \\alpha_k r_k \\right\\|_2^2 \\quad \\text{subject to} \\quad \\alpha_{k-1} + \\alpha_k = 1 $$\n我们将给定的残差向量代入目标函数：\n$$ \\left\\| \\alpha_{k-1} \\begin{pmatrix}1 \\\\ 0\\end{pmatrix} + \\alpha_k \\begin{pmatrix}0 \\\\ 1\\end{pmatrix} \\right\\|_2^2 = \\left\\| \\begin{pmatrix}\\alpha_{k-1} \\\\ \\alpha_k\\end{pmatrix} \\right\\|_2^2 = \\alpha_{k-1}^2 + \\alpha_k^2 $$\n现在，我们使用约束将 $\\alpha_k$ 表示为 $\\alpha_{k-1}$ 的函数：$\\alpha_k = 1 - \\alpha_{k-1}$。将此代入目标函数，得到一个单变量函数 $J(\\alpha_{k-1})$：\n$$ J(\\alpha_{k-1}) = \\alpha_{k-1}^2 + (1 - \\alpha_{k-1})^2 $$\n为了找到最小值，我们计算 $J$ 关于 $\\alpha_{k-1}$ 的导数，并将其设为零：\n$$ \\frac{dJ}{d\\alpha_{k-1}} = 2\\alpha_{k-1} + 2(1 - \\alpha_{k-1})(-1) = 2\\alpha_{k-1} - 2 + 2\\alpha_{k-1} = 4\\alpha_{k-1} - 2 $$\n将导数设为零，得到：\n$$ 4\\alpha_{k-1} - 2 = 0 \\implies \\alpha_{k-1} = \\frac{2}{4} = 0.5 $$\n二阶导数为 $\\frac{d^2J}{d\\alpha_{k-1}^2} = 4 > 0$，证实这是一个最小值。系数 $\\alpha_{k-1}$ 的值为 $0.5$。四舍五入到四位有效数字，即为 $0.5000$。\n\n### 任务3：存储与计算的权衡\n在自由度数 $n$ 很大的大规模有限元岩土力学背景下，非线性求解器的选择涉及内存、每次迭代的计算成本和收敛速度之间的关键权衡。我们比较了普通 Picard 迭代、历史长度为 $m$ 的 Anderson 加速 (AA)以及 Newton-Raphson (NR) 方法。\n\n**Picard 迭代（直接迭代）：**\n- **存储**：这是最节省内存的方法。它主要需要存储当前迭代向量 $x_k$ 和下一个映射向量 $G(x_k)$，两者的大小均为 $n$。因此，其存储复杂度为 $O(n)$。\n- **计算**：每次迭代的成本主要由 $G(x_k)$ 的评估主导，这对应于组装有限元残差向量。对于典型的稀疏网格连接，此组装过程随自由度数呈线性扩展。因此，每次迭代的计算成本为 $O(n)$。虽然每次迭代的成本低，但其线性和通常缓慢的收敛速度可能导致总迭代次数很高、总体求解时间很长，或无法收敛。\n\n**Newton-Raphson (NR) 方法：**\nNR 方法通过迭代求解线性系统 $J_f(x_k) \\delta x_k = -f(x_k)$ 来求解 $f(x)=0$，其中 $J_f(x_k)$ 是 Jacobian 矩阵（在岩土力学中称为切线刚度矩阵）。\n- **存储**：NR 必须存储 Jacobian 矩阵 $J_f$。虽然 $J_f$ 是一个 $n \\times n$ 矩阵，但在有限元模型中它通常是稀疏的。仅存储非零元所需的存储量为 $O(n_z)$，其中 $n_z$ 是非零元的数量，通常与 $n$ 成正比。因此，存储量通常为 $O(n)$。然而，如果使用直接求解器来求解线性系统，内存使用量可能会因分解过程中的填充而显著增加，可能扩展到 $O(n^{1.5})$ 或更差。\n- **计算**：这是每次迭代计算成本最高的方法。成本主要由两个步骤主导：(1) 组装 Jacobian 矩阵 $J_f$，这比组装残差向量的工作量大得多；(2) 求解 $n \\times n$ 线性系统。线性求解的成本是主要瓶颈。对于直接求解器，3D 问题的成本可能是 $O(n^2)$。对于迭代求解器，成本通常为 $O(k_{iter} \\cdot n)$，但如果 Jacobian 矩阵是病态的，$k_{iter}$ 的迭代次数可能会很大。每次迭代的高成本被其二次收敛速度所抵消，如果适用，可以大幅减少所需的总迭代次数。\n\n**Anderson 加速 (AA)：**\nAA 通过增加一个‘无 Jacobian’的外推步骤来增强 Picard 迭代。\n- **存储**：AA 的主要存储缺点是需要保留过去向量的历史记录。在我们推导的公式中，它需要存储最近的 $m+1$ 个映射迭代点 $G(x_{k-i})$（或等效地，迭代点 $x_{k-i}$ 和残差 $r_{k-i}$）。这导致存储需求为 $O(m \\cdot n)$。对于 $n$ 达到数百万的大规模问题，这可能成为一个显著的内存负担，从而限制了历史长度 $m$ 的实际选择（通常 $m \\ll n$）。\n- **计算**：AA 每次迭代的成本包括一个 Picard 步骤（$O(n)$）加上加速步骤的开销。这个开销包括：(1) 通过计算 $O(m)$ 次向量点积来形成 $(m+1) \\times (m+1)$ 的 Gram 矩阵 $\\mathbf{F}_k^T \\mathbf{F}_k$，成本为 $O(m \\cdot n)$；(2) 求解小型的 $(m+1) \\times (m+1)$ 线性系统以获得系数，成本为 $O(m^3)$，可以忽略不计；(3) 通过 $m+1$ 个向量的线性组合形成新的迭代点，成本为 $O(m \\cdot n)$。因此，主要开销为 $O(m \\cdot n)$。\n\n**权衡总结：**\n- **Picard vs. AA**：AA 在 Picard 迭代的基础上增加了 $O(m \\cdot n)$ 的计算成本和 $O(m \\cdot n)$ 的存储成本。这是一个值得的权衡，因为 AA 将收敛速度从线性显著提高到超线性，尽管每次迭代的成本更高，但通常会减少总求解时间。\n- **AA vs. NR**：AA 是一种‘无 Jacobian’的方法。它避免了组装和求解涉及 Jacobian 的大型线性系统的巨大计算成本，而这正是 NR 的主要缺点。AA 每次迭代的成本 $O(m \\cdot n)$ 通常远低于 NR。然而，AA 的存储需求随 $m$ 增加，而 NR 的存储需求很大程度上与其迭代历史无关。此外，NR 的二次收斂速度比 AA 的超线性收敛速度更快。在实践中，对于许多 Jacobian 矩阵昂贵或难以构建的大规模岩土力学问题，一个具有适中历史长度 $m$ 且调整良好的 AA 通常比完整的 NR 方法提供更稳健、更高效的整体求解策略。", "answer": "$$\\boxed{0.5000}$$", "id": "3561419"}, {"introduction": "检验数值方法优劣的真正标准在于其在相关物理问题上的实现和实证表现。在这个综合性练习中，您将实现并比较两种解决非线性多孔介质问题的不同策略：一种是整体式牛顿-拉夫逊求解器，另一种是结合了安德森加速的分块高斯-赛德尔 (Gauss-Seidel) 格式。通过分析它们在不同时间步长下的性能，您将发现，在何种实际条件下，一个设计精巧的分裂算法能够超越经典的牛顿法。", "problem": "考虑 Biot 多孔弹性理论下，流固耦合中单个代表性控制体积的准静态固结。在新的时间步结束时，未知量为孔隙流体压力 $p^{n+1}$ 和体积应变 $e^{n+1}$。该耦合由以下两个代数关系建模，这两个关系源于准静态动量平衡和全隐式质量平衡，并被特化为一个零维（无空间通量）控制体积：\n\n1. 动量平衡，其中排水体积模量 $K>0$，Biot 系数 $\\alpha \\in (0,1]$：\n$$\nK\\,e^{n+1} - \\alpha\\,p^{n+1} = s_m,\n$$\n其中 $s_m$ 是一个给定的体积源，代表外部机械加载的影响。\n\n2. 质量平衡，其中包含非线性储存项 $S(p)$：\n$$\n\\alpha\\,e^{n+1} + S\\!\\left(p^{n+1}\\right) = \\alpha\\,e^{n} + S\\!\\left(p^{n}\\right) + \\Delta t\\,s_f,\n$$\n其中 $s_f$ 是单位时间的给定流体源项，$\\Delta t > 0$ 是时间步长。前一时间步的值 $e^{n}$ 和 $p^{n}$ 是已知的。非线性储存项采用三次多项式\n$$\nS(p) = c_0\\,p + c_1\\,p^2 + c_2\\,p^3,\n$$\n其中 $c_0>0$，$c_1 \\ge 0$，$c_2 \\ge 0$ 确保了储存关系的单调性和物理一致性。\n\n您的任务是在每个时间步中，使用两种非线性策略求解 $\\left(e^{n+1}, p^{n+1}\\right)$ 对，并比较当时间步长 $\\Delta t$ 变化时它们的非线性迭代性能：\n\nA. 应用于耦合系统的整体式 Newton-Raphson 方法\n$$\nF_1(e,p) = K e - \\alpha p - s_m = 0,\\quad\nF_2(e,p) = \\alpha e + S(p) - \\left(\\alpha e^{n} + S(p^{n}) + \\Delta t\\,s_f\\right) = 0,\n$$\n从初始猜测 $e^{0} = e^{n}$ 和 $p^{0} = p^{n}$ 开始，停止准则为残差向量 $\\left(F_1, F_2\\right)$ 的欧几里得范数小于容差 $\\varepsilon$。\n\nB. 使用固定应力分裂的块 Gauss-Seidel Picard 迭代法，其中您按以下方式顺序更新 $e$ 和 $p$：\n- 给定当前的 $p^{k}$，从动量平衡更新 $e^{k+1}$，\n$$\ne^{k+1} = \\frac{s_m + \\alpha\\,p^{k}}{K}.\n$$\n- 通过在 $p^{k}$ 周围对 $S(p)$ 进行 Picard 线性化，从质量平衡更新 $p^{k+1}$，\n$$\nS(p^{k+1}) \\approx \\left(c_0 + c_1\\,p^{k} + c_2\\,(p^{k})^2\\right)\\,p^{k+1},\n$$\n这会产生显式映射\n$$\np^{k+1} = \\frac{\\alpha e^{n} + S(p^{n}) + \\Delta t\\,s_f - \\alpha\\,e^{k+1}}{c_0 + c_1\\,p^{k} + c_2\\,(p^{k})^2}.\n$$\n在标量不动点映射 $p^{k+1} = G(p^{k})$ 上嵌入深度为 2 的 Anderson 加速，以获得加速后的迭代值，\n$$\np^{k+1}_{\\text{AA}} = \\theta\\,G\\!\\left(p^{k-1}\\right) + (1-\\theta)\\,G\\!\\left(p^k\\right),\\quad\n\\theta = \\frac{G(p^{k}) - p^{k}}{G(p^{k}) - p^{k} - \\left(G(p^{k-1}) - p^{k-1}\\right)},\n$$\n当分母非零时使用该公式；否则，使用 $p^{k+1} = G(p^{k})$。在形成 $p^{k+1}_{\\text{AA}}$ 后，使用 $p^{k+1}_{\\text{AA}}$ 从动量平衡更新 $e^{k+1}$。使用与整体式 Newton-Raphson 方法相同的基于残差范数的停止准则。\n\n从计算岩土力学的角度来看，固定应力分裂是一种源于 Biot 方程结构的稳定化技术，其中在求解力学子问题时保持应力固定，同时迭代更新流动子问题。Anderson 加速是一种非线性序列加速方法，它混合过去的不动点迭代值以改善收敛性。\n\n您的任务是实现这两种非线性求解器，并针对下面的每个参数集，通过经验方法找出这样一个最小时间步长 $\\Delta t$（单位：秒）：在该时间步长下，带 Anderson 加速的块 Gauss-Seidel Picard 迭代法达到容差所需的非线性迭代次数严格少于整体式 Newton-Raphson 方法。如果整体式 Newton-Raphson 方法因雅可比矩阵奇异或在规定的最大迭代次数内不收敛，而带 Anderson 加速的块 Gauss-Seidel Picard 迭代法确实收敛，则该阈值定义为所提供集合中发生此情况的最小 $\\Delta t$。如果在所提供的集合中不存在这样的 $\\Delta t$，则报告值 $-1.0$。\n\n在所有测试中使用以下固定的上一步状态和容差：\n- 上一步状态：$e^{n} = 0$（无量纲体积应变），$p^{n} = 0$（单位：帕斯卡）。\n- 容差：$\\varepsilon = 10^{-10}$。\n- 每个求解器的最大非线性迭代次数：$N_{\\max} = 200$。\n\n测试套件：\n对于每种情况，使用以下候选时间步长 $\\Delta t$（单位：秒）列表：$\\left[0.1,\\,0.3,\\,1.0,\\,3.0,\\,10.0,\\,30.0,\\,50.0\\right]$。\n\n- 情况 1 (一般耦合，中等非线性):\n  - $K = 1.0$, $\\alpha = 0.8$, $c_0 = 0.6$, $c_1 = 0.25$, $c_2 = 0.10$, $s_m = 0.0$, $s_f = 1.0$.\n- 情况 2 (整体式系统中接近雅可比矩阵奇异):\n  - $K = 1.0$, $\\alpha = 1.0$, $c_0 = 1.0$, $c_1 = 0.0$, $c_2 = 0.0$, $s_m = 0.0$, $s_f = 1.0$.\n- 情况 3 (在较大压力下强非线性占主导):\n  - $K = 2.0$, $\\alpha = 0.6$, $c_0 = 0.2$, $c_1 = 0.6$, $c_2 = 0.5$, $s_m = 0.0$, $s_f = 0.5$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个情况的结果，格式为方括号内由逗号分隔的浮点数列表，每个数字是按上述顺序列出的一个情况所识别出的阈值时间步长（单位：秒）（例如：\"[dt_case1,dt_case2,dt_case3]\"）。每个条目必须是单个浮点数（单位：秒）。如果在提供的时间步长集合中未找到阈值，则为该情况输出 \"-1.0\"。\n\n所有角度（如有）必须以弧度表示。所有时间步长必须以秒表示。所有百分比（如有）必须以小数表示。", "solution": "该问题被评估为有效。它在科学上基于已建立的 Biot 多孔弹性理论，在数学上是适定的，并且所有参数、初始条件和算法过程都得到了明确的规定。该问题要求进行一个数值实验，比较两种标准的非线性求解方案：整体式 Newton-Raphson 和一种通过 Anderson 加速增强的分裂方法，这在计算力学中是一个合理的研究问题。\n\n该物理模型描述了在准静态条件下，一个代表性控制体积中体积应变 $e$ 和孔隙流体压力 $p$ 的耦合演化。新时间步的未知数 $e^{n+1}$ 和 $p^{n+1}$ 的控制方程构成了一个包含两个非线性代数方程的系统。为简单起见，我们将未知数表示为 $(e, p)$。\n\n第一个方程源于动量平衡，是线性的：\n$$\nF_1(e, p) = K e - \\alpha p - s_m = 0\n$$\n此处，$K$ 是排水体积模量，$\\alpha$ 是 Biot 系数，$s_m$ 是一个力学源项。\n\n第二个方程源于全隐式质量平衡，包含非线性项：\n$$\nF_2(e, p) = \\alpha e + S(p) - C = 0\n$$\n其中 $C = \\alpha e^n + S(p^n) + \\Delta t s_f$ 在该时间步内是一个常数，由前一时间步的已知值 $(e^n, p^n)$、时间步长 $\\Delta t$ 和流体源项 $s_f$ 组成。非线性储存函数为三次多项式 $S(p) = c_0 p + c_1 p^2 + c_2 p^3$。鉴于 $e^n=0$ 和 $p^n=0$，我们有 $S(p^n)=0$，因此常数简化为 $C = \\Delta t s_f$。\n\n任务是使用两种方法求解系统 $\\mathbf{F}(e,p) = [F_1, F_2]^T = \\mathbf{0}$，并通过计算达到残差范数 $\\|\\mathbf{F}\\| < \\varepsilon = 10^{-10}$ 所需的迭代次数来比较它们的性能。\n\n**方法 A：整体式 Newton-Raphson**\n此方法同时求解两个未知数。从初始猜测 $\\mathbf{x}_k = [e_k, p_k]^T$ 开始，通过求解线性系统来找到下一个迭代值 $\\mathbf{x}_{k+1}$：\n$$\nJ(\\mathbf{x}_k) (\\mathbf{x}_{k+1} - \\mathbf{x}_k) = -\\mathbf{F}(\\mathbf{x}_k)\n$$\n其中 $J$ 是系统 $\\mathbf{F}$ 的雅可比矩阵。雅可比矩阵的分量是 $F_1$ 和 $F_2$ 分别对 $e$ 和 $p$ 的偏导数：\n$$\nJ(e,p) = \\begin{pmatrix} \\frac{\\partial F_1}{\\partial e} & \\frac{\\partial F_1}{\\partial p} \\\\ \\frac{\\partial F_2}{\\partial e} & \\frac{\\partial F_2}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} K & -\\alpha \\\\ \\alpha & S'(p) \\end{pmatrix}\n$$\n其中 $S'(p) = \\frac{dS}{dp} = c_0 + 2c_1p + 3c_2p^2$。迭代从前一时间步的值 $\\mathbf{x}_0 = [e^n, p^n]^T = [0, 0]^T$ 开始，并持续进行，直到残差向量 $\\mathbf{F}(\\mathbf{x}_k)$ 的欧几里得范数低于容差 $\\varepsilon$。一个潜在的失败模式是雅可比矩阵的奇异性，即当其行列式 $\\det(J) = K S'(p) + \\alpha^2$ 接近零时。\n\n**方法 B：带 Anderson 加速的块 Gauss-Seidel Picard 迭代法**\n这是一种分裂方法，其中系统按顺序求解 $e$ 和 $p$。具体方案是“固定应力分裂”。由 $k$ 索引的迭代过程如下：\n1.  从动量平衡方程，将 $e$ 表示为当前压力迭代值 $p_k$ 的函数：\n    $$\n    e_{k+1} = \\frac{s_m + \\alpha p_k}{K}\n    $$\n2.  将 $e_{k+1}$ 的这个表达式代入质量平衡方程的线性化形式中，以求解 $p_{k+1}$。问题指定了对 $S(p)$ 的 Picard 线性化，其中 $S(p_{k+1})$ 被近似为 $(c_0 + c_1 p_k + c_2 p_k^2)p_{k+1}$。这导出了一个不动点映射 $p_{k+1} = G(p_k)$：\n    $$\n    G(p_k) = \\frac{\\alpha e^n + S(p^n) + \\Delta t s_f - \\alpha \\left(\\frac{s_m + \\alpha p_k}{K}\\right)}{c_0 + c_1 p_k + c_2 (p_k)^2}\n    $$\n    简单的 Picard 迭代 $p_{k+1} = G(p_k)$ 可能收敛缓慢或发散。为提高性能，应用了深度为 2 的 Anderson 加速。该方法混合当前和之前的不动点函数评估值，以生成一个改进的后续迭代值。给定迭代值 $p_k$ 和 $p_{k-1}$，以及它们对应的函数评估值 $g_k = G(p_k)$ 和 $g_{k-1} = G(p_{k-1})$，加速后的更新为：\n    $$\n    p_{k+1} = \\theta g_{k-1} + (1-\\theta) g_k, \\quad \\text{where} \\quad \\theta = \\frac{g_k - p_k}{(g_k - p_k) - (g_{k-1} - p_{k-1})}\n    $$\n    此加速应用于 $k \\ge 1$。对于第一次迭代（$k=0$），使用标准的 Picard 步 $p_1 = G(p_0)$。在计算出每个新的压力迭代值 $p_{k+1}$ 后，使用动量平衡重新计算相应的应变 $e_{k+1}$ 以保持一致性。停止准则与 Newton-Raphson 方法相同，均基于完整残差向量 $\\mathbf{F}(e_{k+1}, p_{k+1})$ 的范数。\n\n**计算任务**\n目标是实现两种求解器，并对于三个不同的参数集，从给定列表中找到最小的时间步长 $\\Delta t$，使得 Anderson 加速求解器（方法 B）的收敛迭代次数严格少于 Newton-Raphson 求解器（方法 A）。如果方法 A 未能收敛而方法 B 成功收敛，则该 $\\Delta t$ 也满足条件。如果在提供的列表中找不到这样的 $\\Delta t$，结果为 $-1.0$。通过为每个 $\\Delta t$ 运行两种求解器并比较最终的迭代次数来进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants and previous step state\nE_N = 0.0\nP_N = 0.0\nTOL = 1e-10\nMAX_ITER = 200\n\ndef get_S(p, c0, c1, c2):\n    \"\"\"Computes the nonlinear storage term S(p).\"\"\"\n    return c0 * p + c1 * p**2 + c2 * p**3\n\ndef get_dSdp(p, c0, c1, c2):\n    \"\"\"Computes the derivative of the storage term dS/dp.\"\"\"\n    return c0 + 2 * c1 * p + 3 * c2 * p**2\n\ndef solve_newton(params, dt):\n    \"\"\"\n    Solves the system using monolithic Newton-Raphson (Method A).\n    Returns (number of iterations, did_converge).\n    \"\"\"\n    K, alpha, c0, c1, c2, sm, sf = params\n    e_k, p_k = E_N, P_N\n    C = alpha * E_N + get_S(P_N, c0, c1, c2) + dt * sf\n\n    for i in range(MAX_ITER):\n        f1 = K * e_k - alpha * p_k - sm\n        f2 = alpha * e_k + get_S(p_k, c0, c1, c2) - C\n        residual = np.array([f1, f2])\n        \n        if np.linalg.norm(residual)  TOL:\n            return i, True\n\n        dSdp_k = get_dSdp(p_k, c0, c1, c2)\n        J = np.array([[K, -alpha], [alpha, dSdp_k]])\n        \n        if abs(np.linalg.det(J))  1e-14:\n            return i, False # Jacobian is singular\n\n        try:\n            delta_x = np.linalg.solve(J, -residual)\n        except np.linalg.LinAlgError:\n            return i, False\n\n        e_k += delta_x[0]\n        p_k += delta_x[1]\n\n    # Final check after loop\n    f1 = K * e_k - alpha * p_k - sm\n    f2 = alpha * e_k + get_S(p_k, c0, c1, c2) - C\n    if np.linalg.norm(np.array([f1, f2]))  TOL:\n        return MAX_ITER, True\n        \n    return MAX_ITER, False\n\ndef solve_aa(params, dt):\n    \"\"\"\n    Solves the system using block Gauss-Seidel with Anderson Acceleration (Method B).\n    Returns (number of iterations, did_converge).\n    \"\"\"\n    K, alpha, c0, c1, c2, sm, sf = params\n    C = alpha * E_N + get_S(P_N, c0, c1, c2) + dt * sf\n\n    def G(p_in):\n        denom_picard = c0 + c1 * p_in + c2 * p_in**2\n        if abs(denom_picard)  1e-14:\n            return np.nan\n        e_intermediate = (sm + alpha * p_in) / K\n        p_out = (C - alpha * e_intermediate) / denom_picard\n        return p_out\n\n    p_k = P_N\n    p_hist = [None, p_k]\n    g_hist = [None, None]\n\n    for k in range(MAX_ITER):\n        e_k = (sm + alpha * p_k) / K\n        f1 = K * e_k - alpha * p_k - sm\n        f2 = alpha * e_k + get_S(p_k, c0, c1, c2) - C\n        if np.linalg.norm([f1, f2])  TOL:\n            return k, True\n\n        g_k = G(p_k)\n        if np.isnan(g_k):\n            return k, False\n\n        g_hist.append(g_k)\n        g_hist.pop(0)\n\n        if k == 0:\n            p_k_plus_1 = g_k\n        else:\n            p_k_minus_1 = p_hist[0]\n            g_k_minus_1 = g_hist[0]\n            \n            f_k = g_k - p_k\n            f_k_minus_1 = g_k_minus_1 - p_k_minus_1\n            \n            denom_aa = f_k - f_k_minus_1\n            if abs(denom_aa) > 1e-14:\n                theta = f_k / denom_aa\n                p_k_plus_1 = theta * g_k_minus_1 + (1 - theta) * g_k\n            else:\n                p_k_plus_1 = g_k\n\n        p_k = p_k_plus_1\n        p_hist.append(p_k)\n        p_hist.pop(0)\n    \n    e_k = (sm + alpha * p_k) / K\n    f1 = K * e_k - alpha * p_k - sm\n    f2 = alpha * e_k + get_S(p_k, c0, c1, c2) - C\n    if np.linalg.norm([f1, f2])  TOL:\n        return MAX_ITER, True\n\n    return MAX_ITER, False\n\ndef solve():\n    test_cases = [\n        # Case 1: K, alpha, c0, c1, c2, sm, sf\n        (1.0, 0.8, 0.6, 0.25, 0.10, 0.0, 1.0),\n        # Case 2\n        (1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0),\n        # Case 3\n        (2.0, 0.6, 0.2, 0.6, 0.5, 0.0, 0.5),\n    ]\n\n    dt_candidates = [0.1, 0.3, 1.0, 3.0, 10.0, 30.0, 50.0]\n    results = []\n\n    for params in test_cases:\n        threshold_dt = -1.0\n        for dt in dt_candidates:\n            n_nr, conv_nr = solve_newton(params, dt)\n            n_aa, conv_aa = solve_aa(params, dt)\n\n            condition_met = False\n            if conv_aa:\n                if not conv_nr:\n                    condition_met = True\n                elif n_aa  n_nr:\n                    condition_met = True\n\n            if condition_met:\n                threshold_dt = dt\n                break\n        \n        results.append(threshold_dt)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3561443"}]}