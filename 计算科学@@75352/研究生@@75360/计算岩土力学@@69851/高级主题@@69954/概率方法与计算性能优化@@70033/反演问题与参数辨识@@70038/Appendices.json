{"hands_on_practices": [{"introduction": "在深入研究复杂的反演算法之前，首要任务是理解其根本挑战，尤其是解的非唯一性。本练习通过一个理想化的思想实验，探讨一个弹塑性材料问题，揭示了为何不同的材料参数（在此为内聚力）在特定加载条件下会产生完全相同的观测结果。理解这种非唯一性现象，对于设计信息丰富的岩土实验和正确解读参数反演结果至关重要 [@problem_id:3535002]。", "problem": "一个棱柱形土样占据一个宽度为 $W$、高度为 $H$、单位厚度为 $t=1$ 的矩形区域。该材料在屈服前遵循小应变线性弹性规律，其杨氏模量为 $E$，泊松比为 $\\nu$；屈服后遵循弹性理想塑性 Mohr–Coulomb 模型，其摩擦角为零 $\\phi=0$（纯粘性响应）。不存在体力。侧面无面力。底面被固定。顶面承受一个向下的均匀指定竖向位移 $u_0$。假设 Saint-Venant 原理适用，因此在这些边界条件下，内部应力状态可被视为均匀。\n\n考虑两种不同的粘聚力场：\n- 场 A：$c_A(x,y) \\equiv 0.50 \\,\\text{MPa}$，在整个域上为常数。\n- 场 B：$c_B(x,y) = 0.20 \\,\\text{MPa} + 0.05 \\,\\text{MPa}\\,\\cos\\!\\left(\\pi y/H\\right)$，随 $y$ 变化且与 $x$ 无关。\n\n弹性常数和几何尺寸为\n$E=1.00\\times 10^{8}\\,\\text{Pa}$，$\\nu=0.30$，$H=1.00\\,\\text{m}$，$W=1.00\\,\\text{m}$，施加的位移为 $u_0=1.00\\times 10^{-3}\\,\\text{m}$。\n\n仅使用小应变基本运动学、线性弹性本构关系、面力定义以及当应力状态严格位于屈服域内时弹性理想塑性行为简化为纯弹性演化的事实，完成以下任务：\n\n1. 从第一性原理出发，论证在给定边界条件下，内部应力状态可视为单轴应力，其中 $\\sigma_{yy}$ 均匀且 $\\sigma_{xx}=\\sigma_{zz}=0$，并推导出 $\\sigma_{yy}$ 关于 $E$、$u_0$ 和 $H$ 的表达式。\n\n2. 对于 $\\phi=0$ 的 Mohr–Coulomb 模型，使用最大剪应力和主应力之间的标准关系，验证对于粘聚力场 $c_A$ 和 $c_B$，所产生的弹性应力状态在整个试样中都严格位于屈服域内。\n\n3. 判断两种粘聚力场下顶面的边界面力场是否相同，并解释在指定位移 $u_0$ 下，根据测量的边界面力识别粘聚力时出现非唯一性的结构原因。\n\n4. 计算顶部边界上的总竖向反力 $F$（单位：牛顿）。将最终数值答案四舍五入到四位有效数字，并以牛顿表示。", "solution": "在 Saint-Venant's 原理允许将内部应力状态视为均匀的明确假设下，该问题被验证为具有科学依据、提法恰当且自洽。这种简化在工程力学中是标准做法，用以绕过边界处的应力集中。\n\n解答按要求分四部分进行。\n\n1. 内部应力状态及竖向应力分量 $\\sigma_{yy}$ 的推导。\n\n问题指出，内部应力状态可被视为均匀。一个均匀应力场 $\\sigma_{ij}$（其中 $\\sigma_{ij}$ 为常数）在没有体力的情况下自动满足平衡方程 $\\partial_j \\sigma_{ij} = 0$。\n\n侧面（$x=0$ 和 $x=W$ 处）的边界条件是无面力。作用在具有外法线 $\\mathbf{n}$ 的表面上的面力向量由 $\\mathbf{T} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$ 给出。\n对于 $x=W$ 处的面，法线为 $\\mathbf{n} = (1, 0, 0)$。面力分量为：\n$T_x = \\sigma_{xx} n_x = \\sigma_{xx}$\n$T_y = \\sigma_{yx} n_x = \\sigma_{yx}$\n$T_z = \\sigma_{zx} n_x = \\sigma_{zx}$\n由于该面无面力，$\\mathbf{T} = \\mathbf{0}$，这意味着 $\\sigma_{xx} = \\sigma_{yx} = \\sigma_{zx} = 0$。\n对无面力的前面和后面（在 $z$ 方向，法线为 $\\mathbf{n}=(0,0,\\pm 1)$）进行类似分析，可得 $\\sigma_{zz} = \\sigma_{yz} = \\sigma_{xz} = 0$。\n根据应力张量的对称性 $\\sigma_{ij} = \\sigma_{ji}$，我们有 $\\sigma_{xy} = \\sigma_{yx} = 0$，$\\sigma_{xz} = \\sigma_{zx} = 0$，以及 $\\sigma_{yz} = \\sigma_{zy} = 0$。\n唯一可能不为零的应力分量是 $\\sigma_{yy}$。因此，应力张量是单轴的：\n$$\n\\boldsymbol{\\sigma} = \\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & \\sigma_{yy} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n试样在顶面 $y=H$ 处承受均匀竖向位移 $u_y = -u_0$，而底面 $y=0$ 是固定的，即 $u_y=0$。均匀应力状态的假设意味着均匀应变状态。根据小应变运动学，竖向应变 $\\varepsilon_{yy}$ 定义为 $\\varepsilon_{yy} = \\frac{\\Delta L}{L_0}$。\n高度变化为 $\\Delta L = u_y(H) - u_y(0) = -u_0 - 0 = -u_0$。原始高度为 $L_0 = H$。\n因此，均匀竖向应变为：\n$$\n\\varepsilon_{yy} = -\\frac{u_0}{H}\n$$\n材料行为初始为线性弹性。对于单轴应力下的各向同性弹性材料，其本构关系（Hooke's Law）简化为：\n$$\n\\sigma_{yy} = E \\varepsilon_{yy}\n$$\n代入 $\\varepsilon_{yy}$ 的表达式，我们得到竖向应力的表达式：\n$$\n\\sigma_{yy} = E \\!\\left(-\\frac{u_0}{H}\\right) = -\\frac{E u_0}{H}\n$$\n该应力在整个试样中是均匀的，与初始假设一致。\n\n2. 验证两种粘聚力场下应力状态均为弹性。\n\n材料根据 Mohr–Coulomb 准则屈服。当摩擦角 $\\phi=0$ 时，屈服函数简化为 Tresca 准则，即当最大剪应力 $\\tau_{max}$ 达到粘聚力 $c$ 时发生屈服。材料保持在严格弹性域内的条件是：\n$$\n\\tau_{max}  c\n$$\n最大剪应力由 $\\tau_{max} = \\frac{\\sigma_1 - \\sigma_3}{2}$ 给出，其中 $\\sigma_1$ 和 $\\sigma_3$ 分别是最大和最小主应力。\n对于上面推导的单轴应力状态，非零应力为 $\\sigma_{yy}$。我们使用给定的参数计算其值：$E=1.00 \\times 10^8\\,\\text{Pa}$，$u_0=1.00 \\times 10^{-3}\\,\\text{m}$，以及 $H=1.00\\,\\text{m}$。\n$$\n\\sigma_{yy} = -\\frac{(1.00 \\times 10^8\\,\\text{Pa})(1.00 \\times 10^{-3}\\,\\text{m})}{1.00\\,\\text{m}} = -1.00 \\times 10^5\\,\\text{Pa} = -0.100\\,\\text{MPa}\n$$\n应力是压应力，与预期相符。主应力是应力张量的特征值。对于我们找到的对角应力张量，主应力就是对角线上的元素：$\\{\\sigma_{yy}, 0, 0\\}$。\n将其排序，我们得到 $\\sigma_1 = 0$，$\\sigma_2 = 0$，以及 $\\sigma_3 = \\sigma_{yy} = -0.100\\,\\text{MPa}$。\n因此，最大剪应力为：\n$$\n\\tau_{max} = \\frac{\\sigma_1 - \\sigma_3}{2} = \\frac{0 - (-0.100\\,\\text{MPa})}{2} = 0.050\\,\\text{MPa}\n$$\n现在我们必须将这个值与每个场的粘聚力进行核对。\n- 场 A：粘聚力是常数，$c_A(x,y) = 0.50\\,\\text{MPa}$。弹性条件是 $\\tau_{max}  c_A$，即 $0.050\\,\\text{MPa}  0.50\\,\\text{MPa}$。此不等式成立。因此，对于粘聚力场 A，试样保持严格弹性状态。\n- 场 B：粘聚力随深度变化，$c_B(x,y) = 0.20\\,\\text{MPa} + 0.05\\,\\text{MPa}\\,\\cos(\\pi y/H)$。为确保整个试样保持弹性，最大剪应力必须小于域内任何地方的粘聚力最小值。$c_B$ 的最小值出现在 $\\cos(\\pi y/H)$ 取其最小值 $-1$ 时。这发生在 $y=H$ 处。\n$$\nc_{B, \\text{min}} = 0.20\\,\\text{MPa} + 0.05\\,\\text{MPa}\\,(-1) = 0.15\\,\\text{MPa}\n$$\n弹性条件是 $\\tau_{max}  c_{B, \\text{min}}$，即 $0.050\\,\\text{MPa}  0.15\\,\\text{MPa}$。此不等式也成立。因此，对于粘聚力场 B，试样在其整个域内也保持严格弹性状态。\n\n3. 关于边界面力和非唯一性的结论。\n\n顶面（$y=H$）上的边界面力向量由 $\\mathbf{T} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$ 给出，其中从试样指出的外法线为 $\\mathbf{n}=(0, 1, 0)$。\n$$\n\\mathbf{T} = \\begin{pmatrix} 0  0  0 \\\\ 0  \\sigma_{yy}  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\sigma_{yy} \\\\ 0 \\end{pmatrix}\n$$\n面力场是均匀的，并且只有一个竖向分量 $T_y = \\sigma_{yy} = -0.100\\,\\text{MPa}$。\n如我们所证，$\\sigma_{yy}$ 的计算仅取决于弹性模量 $E$ 和应用的运动学参数（$u_0, H$）。结果与粘聚力参数 $c$ 无关。由于材料在场 A 和场 B 下的响应都是纯弹性的，因此两种情况下得到的应力状态 $\\sigma_{yy}$ 是相同的。因此，两种粘聚力场下顶面的边界面力场是相同的。\n\n非唯一性的结构原因是所施加的荷载（一个小的位移 $u_0$）不足以引起塑性变形。从边界面力的测量值中识别粘聚力场 $c(x,y)$ 的问题是一个反问题。在这种情况下，正演模型（材料属性与可观测测量值之间的关系）表明，对于弹性范围内的变形，边界面力仅取决于弹性参数（$E$, $\\nu$）。塑性参数（$c$, $\\phi$）不影响力学响应。因为测量值（边界面力）对我们希望识别的参数（粘聚力）不敏感，所以任何足以防止屈服的粘聚力场（即，处处满足 $c(x,y)  \\tau_{max}$）都会产生完全相同的边界面力。因此，无法通过本实验唯一地确定粘聚力场。\n\n4. 总竖向反力的计算。\n\n顶部边界上的总竖向反力 $F$ 是竖向反作用面力在面面积上的积分。试样施加于加载压板的反作用面力与压板施加于试样的面力大小相等，方向相反。试样施加的力方向向上（$y$ 轴正方向），其大小等于 $|T_y|$ 在面积 $A = W \\times t$ 上的积分。\n给定 $W = 1.00\\,\\text{m}$ 和单位厚度 $t=1$，我们假设 $t = 1.00\\,\\text{m}$。面积为 $A = 1.00\\,\\text{m} \\times 1.00\\,\\text{m} = 1.00\\,\\text{m}^2$。\n竖向面力为 $T_y = \\sigma_{yy} = -1.00 \\times 10^5\\,\\text{Pa}$。这是 $y=H$ 以下的材料对上方材料施加的应力。作用在加载压板上的力方向相反（向上）。\n$$\nF = -T_y \\times A = -(\\sigma_{yy}) \\times (W \\cdot t)\n$$\n代入数值：\n$$\nF = -(-1.00 \\times 10^5\\,\\text{N/m}^2) \\times (1.00\\,\\text{m} \\times 1.00\\,\\text{m}) = 1.00 \\times 10^5\\,\\text{N}\n$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$\nF = 1.000 \\times 10^5\\,\\text{N}\n$$\n这个力对于两种粘聚力场是相同的，因为应力状态是相同的。", "answer": "$$\n\\boxed{1.000 \\times 10^{5}}\n$$", "id": "3535002"}, {"introduction": "认识到反演问题的解可能不唯一后，下一步自然是定量地探索整个解空间。本练习将我们带入一个概率框架，利用稀疏的现场观测数据来确定摩尔-库仑（Mohr-Coulomb）模型中最可能的摩擦角和内聚力参数。您将通过剖面似然分析这一强大的计算技术，亲手诊断和量化由数据不足或冲突引发的后验多峰性 (multimodality)——这是非唯一性在实践中的具体表现 [@problem_id:3534929]。", "problem": "考虑一个基于莫尔-库仑剪切强度准则的颗粒或岩石界面的摩擦失效模型。未知参数为黏聚力 $c$（单位为 $\\mathrm{kPa}$）和摩擦角 $\\varphi$（单位为弧度）。在正应力 $\\sigma_n$ 下的剪切强度模型为 $\\tau_{\\text{str}}(c,\\varphi,\\sigma_n) = c + \\sigma_n \\tan(\\varphi)$。给定在施加的剪应力 $\\tau_i$ 和正应力 $\\sigma_i$ 下的稀疏滑移观测数据，表示为二进制指示符 $y_i \\in \\{0,1\\}$，其中 $y_i = 1$ 表示观测到滑移，$y_i = 0$ 表示未观测到滑移。为了考虑在失效阈值附近的观测和模型不确定性，假设一个概率性滑移发生模型，该模型具有独立的伯努利试验和成功概率\n$$\np_i(c,\\varphi) = \\frac{1}{1 + \\exp\\left(-\\beta \\left(\\tau_i - c - \\sigma_i \\tan(\\varphi)\\right)\\right)},\n$$\n其中 $\\beta$（单位为 $\\mathrm{kPa}^{-1}$）是一个已知的斜率参数，它使逻辑斯蒂函数的参数无量纲化。在物理上允许的矩形区域 $\\mathcal{P} = \\{(c,\\varphi): c \\in [c_{\\min}, c_{\\max}], \\ \\varphi \\in [\\varphi_{\\min}, \\varphi_{\\max}]\\}$ 上采用均匀先验分布时，后验密度与似然成正比。对数似然为\n$$\n\\mathcal{L}(c,\\varphi) = \\sum_{i=1}^{N} \\left[ y_i \\log\\left(p_i(c,\\varphi)\\right) + (1-y_i)\\log\\left(1-p_i(c,\\varphi)\\right) \\right].\n$$\n将最大似然估计 (MLE) $(c^\\star,\\varphi^\\star)$ 定义为 $\\mathcal{L}(c,\\varphi)$ 在 $\\mathcal{P}$ 上的任意最大化子。为识别和量化后验分布中的多峰性，沿参数空间中两个具有物理意义的方向构建一维剖面对数似然，这两个方向均以 $(c^\\star,\\varphi^\\star)$ 为中心：\n\n- 方向 A（在参考正应力下保持剪切强度不变的权衡方向）：选择一个参考正应力 $\\sigma_{\\text{ref}}$（单位为 $\\mathrm{kPa}$）。定义一个曲线参数 $t$（单位为弧度）并设置\n$$\n\\varphi_A(t) = \\varphi^\\star + t, \\quad c_A(t) = c^\\star + \\sigma_{\\text{ref}}\\left(\\tan(\\varphi^\\star) - \\tan(\\varphi^\\star + t)\\right).\n$$\n对于所有 $t$，该方向都能精确地保持在 $\\sigma_{\\text{ref}}$ 处的 $\\tau_{\\text{str}}$ 不变，因为 $c_A(t) + \\sigma_{\\text{ref}}\\tan(\\varphi_A(t)) = c^\\star + \\sigma_{\\text{ref}}\\tan(\\varphi^\\star)$。\n\n- 方向 B（在固定摩擦角下纯黏聚力变化）：定义一个曲线参数 $s$（单位为 $\\mathrm{kPa}$）并设置\n$$\n\\varphi_B(s) = \\varphi^\\star, \\quad c_B(s) = c^\\star + s.\n$$\n\n对于每个方向，通过沿曲线评估 $\\mathcal{L}$ 来计算剖面对数似然，并限制在保持于 $\\mathcal{P}$ 内且满足 $c \\ge 0$ 的物理允许值范围内。通过检测具有最小突显度阈值的峰值来识别每个剖面上的局部最大值，该阈值等于剖面动态范围的一个固定分数。将多峰性量化为沿每个方向检测到的峰值的整数计数。\n\n您的任务是实现一个完整的程序，该程序：\n- 在 $\\mathcal{P}$ 上执行网格搜索以计算 $(c^\\star,\\varphi^\\star)$。\n- 围绕 $(c^\\star,\\varphi^\\star)$ 以指定的采样范围和步长构建两个剖面。\n- 使用固定的突显度规则检测每个剖面上的峰值。\n- 对每个测试用例，输出一个包含两个整数的列表 $[n_A, n_B]$，分别给出沿方向 A 和方向 B 检测到的峰值数量。\n\n使用以下参数边界、采样规范和常数：\n- 参数边界：$c_{\\min} = 0 \\ \\mathrm{kPa}$，$c_{\\max} = 40 \\ \\mathrm{kPa}$，$\\varphi_{\\min} = 0.2$ (弧度)，$\\varphi_{\\max} = 0.9$ (弧度)。\n- 网格搜索分辨率：在 $[c_{\\min}, c_{\\max}]$ 上以 $121$ 个点对 $c$ 进行均匀采样，并在 $[\\varphi_{\\min}, \\varphi_{\\max}]$ 上以 $121$ 个点对 $\\varphi$ 进行均匀采样。\n- 逻辑斯蒂斜率：$\\beta = 0.3 \\ \\mathrm{kPa}^{-1}$。\n- 参考正应力：$\\sigma_{\\text{ref}} = 100 \\ \\mathrm{kPa}$。\n- 方向 A 采样：从 $-0.4$ 到 $+0.4$ (弧度) 均匀采样 $t$，步长为 $0.01$ (弧度)，并且只包含满足 $(c_A(t),\\varphi_A(t)) \\in \\mathcal{P}$ 和 $c_A(t) \\ge 0$ 的点。\n- 方向 B 采样：从 $-20.0$ 到 $+20.0$ (单位为 $\\mathrm{kPa}$) 均匀采样 $s$，步长为 $0.5$ (单位为 $\\mathrm{kPa}$)，并且只包含满足 $(c_B(s),\\varphi_B(s)) \\in \\mathcal{P}$ 和 $c_B(s) \\ge 0$ 的点。\n- 峰值检测：使用等于剖面值动态范围 $0.05$ 倍的最小突显度，其中动态范围定义为沿采样曲线的 $\\max(\\mathcal{L}) - \\min(\\mathcal{L})$。如果动态范围为零，则将突显度设置为 $0$。\n\n包含三个稀疏滑移观测案例的测试套件。在每个案例中，指定 $(\\sigma_i,\\tau_i,y_i)$ 的数组；所有应力必须以 $\\mathrm{kPa}$ 表示，角度以弧度表示，二进制滑移指示符无单位：\n- 案例 1（变化的正应力，一致的滑移）：\n    - $\\sigma = (50, 100, 150)$，\n    - $\\tau = (35, 60, 100)$，\n    - $y = (0, 1, 1)$。\n- 案例 2（两个正应力水平，观测结果冲突以引发潜在的多峰性）：\n    - $\\sigma = (100, 100, 120, 120)$，\n    - $\\tau = (66, 70, 72, 80)$，\n    - $y = (0, 1, 0, 1)$。\n- 案例 3（单一正应力水平，沿方向 A 形成一个脊）：\n    - $\\sigma = (80, 80, 80)$，\n    - $\\tau = (55, 65, 75)$，\n    - $y = (1, 1, 1)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，本身是一个双整数列表 $[n_A,n_B]$。例如，具有三个测试用例的输出应类似于 $[[n_{A,1},n_{B,1}],[n_{A,2},n_{B,2}],[n_{A,3},n_{B,3}]]$，整数以标准十进制数字打印。", "solution": "用户提供的问题陈述已经过分析和验证。它在科学上基于地质力学和统计推断的原理，问题设定良好，指令清晰完整，表述客观。所有必要的数据、模型和常数均已提供，不存在内部矛盾或科学上不合理的要求。该问题是计算地质力学领域内参数辨识和模型分析方面一个有效且有深度的练习。因此，下面提供了完整的解决方案。\n\n该问题要求为一个莫尔-库仑摩擦模型辨识两个参数：黏聚力 $c$ 和摩擦角 $\\varphi$。辨识过程在一个概率框架内进行，其中使用关于滑移发生的稀疏二进制数据来构建一个对数似然函数，然后通过最大化该函数来找到最可能的参数集。分析的核心是通过构建和分析一维剖面对数似然来研究该最大值周围的似然曲面形状，特别是其多峰性的可能性。\n\n**1. 概率模型和对数似然函数**\n\n界面剪切强度 $\\tau_{\\text{str}}$ 由莫尔-库仑准则给出：\n$$\n\\tau_{\\text{str}}(c,\\varphi,\\sigma_n) = c + \\sigma_n \\tan(\\varphi)\n$$\n其中 $\\sigma_n$ 是正应力。在给定的施加应力 $(\\sigma_i, \\tau_i)$ 下，对于观测 $i$ 的滑移概率 $p_i$ 使用逻辑斯蒂函数建模，该函数提供了从无滑移状态到滑移状态的平滑过渡：\n$$\np_i(c,\\varphi) = \\frac{1}{1 + \\exp\\left(-\\beta \\left(\\tau_i - (c + \\sigma_i \\tan(\\varphi))\\right)\\right)}\n$$\n这里，$\\beta$ 是一个给定的参数，控制过渡的陡峭程度。设指数的参数为 $x_i(c,\\varphi) = \\beta (\\tau_i - c - \\sigma_i \\tan(\\varphi))$。则概率为 $p_i = (1 + e^{-x_i})^{-1}$。\n\n假设观测值 $y_i \\in \\{0, 1\\}$ 是成功概率为 $p_i$ 的独立伯努利试验的结果。对于一组 $N$ 个观测值，总对数似然 $\\mathcal{L}(c, \\varphi)$ 是各个对数似然的总和：\n$$\n\\mathcal{L}(c,\\varphi) = \\sum_{i=1}^{N} \\left[ y_i \\log\\left(p_i(c,\\varphi)\\right) + (1-y_i)\\log\\left(1-p_i(c,\\varphi)\\right) \\right]\n$$\n为实现稳健的数值计算，该表达式可以简化。利用逻辑斯蒂函数的性质，其中 $\\log(p_i) = -\\log(1+e^{-x_i})$ 和 $\\log(1-p_i) = -x_i - \\log(1+e^{-x_i})$，单个观测的对数似然变为 $y_i x_i - \\log(1+e^{x_i})$。这种形式在数值上是稳定的，并避免了对极小数取对数时可能出现的问题。总对数似然则为：\n$$\n\\mathcal{L}(c, \\varphi) = \\sum_{i=1}^{N} \\left[ y_i x_i(c,\\varphi) - \\log(1+\\exp(x_i(c,\\varphi))) \\right]\n$$\n\n**2. 最大似然估计 (MLE)**\n\n最大似然估计 $(c^\\star, \\varphi^\\star)$ 是在指定的物理允许参数空间 $\\mathcal{P} = \\{(c,\\varphi): c \\in [c_{\\min}, c_{\\max}], \\ \\varphi \\in [\\varphi_{\\min}, \\varphi_{\\max}]\\}$ 内使 $\\mathcal{L}(c, \\varphi)$ 最大化的参数对。\n$$\n(c^\\star, \\varphi^\\star) = \\arg\\max_{(c,\\varphi)\\in\\mathcal{P}} \\mathcal{L}(c,\\varphi)\n$$\n按照规定，此最大化过程通过网格搜索进行计算。区域 $\\mathcal{P}$ 被离散化为一个 $121 \\times 121$ 点的均匀网格。在网格的每个点上计算对数似然函数 $\\mathcal{L}(c, \\varphi)$。产生最高对数似然值的网格点 $(c_j, \\varphi_k)$ 被作为 MLE $(c^\\star, \\varphi^\\star)$。为提高效率，采用了对网格的矢量化计算。\n\n**3. 剖面对数似然分析**\n\n为了研究多峰性，我们分析对数似然函数在参数空间中特定一维路径上的行为，这是一种称为剖面似然分析的方法。这些路径以 MLE $(c^\\star, \\varphi^\\star)$ 为中心。\n\n**方向 A（剪切强度权衡）：** 这条路径旨在探索 $c$ 和 $\\varphi$ 之间的权衡关系，同时在参考正应力 $\\sigma_{\\text{ref}} = 100 \\ \\mathrm{kPa}$ 下保持剪切强度恒定。该路径由 $t$（单位为弧度）参数化：\n$$\n\\varphi_A(t) = \\varphi^\\star + t\n$$\n$$\nc_A(t) = c^\\star + \\sigma_{\\text{ref}}\\left(\\tan(\\varphi^\\star) - \\tan(\\varphi^\\star + t)\\right)\n$$\n剖面对数似然为 $\\mathcal{L}_A(t) = \\mathcal{L}(c_A(t), \\varphi_A(t))$。此剖面是为 $t$ 在 $-0.4$ 到 $0.4$ 弧度范围内采样计算的，仅包括 $(c_A(t), \\varphi_A(t))$ 保持在允许区域 $\\mathcal{P}$ 内且 $c_A(t) \\ge c_{\\min}=0$ 的点。如果观测到的正应力 $\\sigma_i$ 都接近于 $\\sigma_{\\text{ref}}$，预计该剖面将非常平坦，形成一个高似然值的“脊”，使其对小扰动敏感，从而检验峰值检测的稳健性。\n\n**方向 B（纯黏聚力变化）：** 这条路径探索似然对仅改变黏聚力 $c$ 的敏感性，同时保持摩擦角 $\\varphi$ 在其最优值上固定不变。该路径由 $s$（单位为 $\\mathrm{kPa}$）参数化：\n$$\n\\varphi_B(s) = \\varphi^\\star\n$$\n$$\nc_B(s) = c^\\star + s\n$$\n剖面对数似然为 $\\mathcal{L}_B(s) = \\mathcal{L}(c_B(s), \\varphi_B(s))$。此剖面是为 $s$ 在 $-20.0$ 到 $20.0 \\ \\mathrm{kPa}$ 范围内采样计算的，同样限制在允许区域 $\\mathcal{P}$ 内的点。\n\n**4. 峰值检测与多峰性量化**\n\n多峰性通过计算每个剖面上的局部最大值（峰值）的数量来量化。峰值是剖面上大于其直接邻居的点。为滤除微小的数值噪声，峰值必须表现出最小的突显度。一个峰值的突显度是其与环绕它但不环绕任何更高峰值的最低等高线之间的垂直距离。问题指定了一个突显度阈值，等于剖面动态范围（最大值减最小值）的一个分数（$0.05$）。\n$$\n\\text{突显度阈值} = 0.05 \\times \\left( \\max(\\mathcal{L}_{\\text{profile}}) - \\min(\\mathcal{L}_{\\text{profile}}) \\right)\n$$\n如果动态范围为零（即剖面完全平坦），则突显度设置为零。对于方向 A 和方向 B，分别计数满足此标准的峰值数量 $n_A$ 和 $n_B$。此过程使用 `scipy.signal` 库中的 `find_peaks` 函数实现。每个测试用例的最终输出是整数对 $[n_A, n_B]$。", "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Solves the parameter identification and multimodality analysis problem\n    for the Mohr-Coulomb failure model.\n    \"\"\"\n\n    # --- Problem Constants and Specifications ---\n    C_MIN, C_MAX = 0.0, 40.0\n    PHI_MIN, PHI_MAX = 0.2, 0.9\n    GRID_POINTS = 121\n    BETA = 0.3\n    SIGMA_REF = 100.0\n    PROM_FRAC = 0.05\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"sigma\": np.array([50.0, 100.0, 150.0]),\n            \"tau\": np.array([35.0, 60.0, 100.0]),\n            \"y\": np.array([0, 1, 1])\n        },\n        {\n            \"sigma\": np.array([100.0, 100.0, 120.0, 120.0]),\n            \"tau\": np.array([66.0, 70.0, 72.0, 80.0]),\n            \"y\": np.array([0, 1, 0, 1])\n        },\n        {\n            \"sigma\": np.array([80.0, 80.0, 80.0]),\n            \"tau\": np.array([55.0, 65.0, 75.0]),\n            \"y\": np.array([1, 1, 1])\n        }\n    ]\n\n    def log_likelihood(c, phi, sigma, tau, y, beta):\n        \"\"\"\n        Computes the log-likelihood for given parameters and data.\n        Uses a numerically stable formulation.\n        \"\"\"\n        if np.isscalar(c):\n            c = np.array([c])\n        if np.isscalar(phi):\n            phi = np.array([phi])\n        \n        # Reshape for broadcasting: (params..., data_points)\n        c_reshaped = c[..., np.newaxis]\n        phi_reshaped = phi[..., np.newaxis]\n\n        # x = beta * (tau - (c + sigma * tan(phi)))\n        x = beta * (tau - (c_reshaped + sigma * np.tan(phi_reshaped)))\n        \n        # Log-likelihood terms: y*x - log(1 + exp(x))\n        log_L_terms = y * x - np.log(1 + np.exp(x))\n        \n        # Sum over data points\n        total_log_L = np.sum(log_L_terms, axis=-1)\n        return total_log_L\n\n    all_results = []\n    \n    for case_data in test_cases:\n        sigma_obs, tau_obs, y_obs = case_data[\"sigma\"], case_data[\"tau\"], case_data[\"y\"]\n\n        # --- Part 1: Grid Search for MLE (c*, phi*) ---\n        c_grid_1d = np.linspace(C_MIN, C_MAX, GRID_POINTS)\n        phi_grid_1d = np.linspace(PHI_MIN, PHI_MAX, GRID_POINTS)\n        c_grid, phi_grid = np.meshgrid(c_grid_1d, phi_grid_1d)\n\n        log_L_grid = log_likelihood(c_grid, phi_grid, sigma_obs, tau_obs, y_obs, BETA)\n\n        max_idx_flat = np.argmax(log_L_grid)\n        max_idx_2d = np.unravel_index(max_idx_flat, log_L_grid.shape)\n        \n        c_star = c_grid[max_idx_2d]\n        phi_star = phi_grid[max_idx_2d]\n\n        case_results = []\n        \n        # --- Part 2: Profile Analysis ---\n        \n        # Direction A: Trade-off preserving shear strength\n        t_samples = np.arange(-0.4, 0.401, 0.01)\n        phi_A = phi_star + t_samples\n        c_A = c_star + SIGMA_REF * (np.tan(phi_star) - np.tan(phi_A))\n        \n        # Filter for admissible parameters\n        valid_mask_A = (c_A >= C_MIN)  (c_A = C_MAX)  (phi_A >= PHI_MIN)  (phi_A = PHI_MAX)\n        c_A_valid = c_A[valid_mask_A]\n        phi_A_valid = phi_A[valid_mask_A]\n        \n        if len(c_A_valid) > 0:\n            profile_L_A = log_likelihood(c_A_valid, phi_A_valid, sigma_obs, tau_obs, y_obs, BETA)\n            dynamic_range_A = np.max(profile_L_A) - np.min(profile_L_A)\n            prominence_A = PROM_FRAC * dynamic_range_A if dynamic_range_A > 0 else 0\n            peaks_A, _ = find_peaks(profile_L_A, prominence=prominence_A)\n            num_peaks_A = len(peaks_A)\n        else:\n            num_peaks_A = 0 # No valid points on profile\n        case_results.append(num_peaks_A)\n            \n        # Direction B: Pure cohesion variation\n        s_samples = np.arange(-20.0, 20.01, 0.5)\n        phi_B = np.full_like(s_samples, phi_star)\n        c_B = c_star + s_samples\n\n        # Filter for admissible parameters\n        valid_mask_B = (c_B >= C_MIN)  (c_B = C_MAX)  (phi_B >= PHI_MIN)  (phi_B = PHI_MAX)\n        c_B_valid = c_B[valid_mask_B]\n        phi_B_valid = phi_B[valid_mask_B]\n\n        if len(c_B_valid) > 0:\n            profile_L_B = log_likelihood(c_B_valid, phi_B_valid, sigma_obs, tau_obs, y_obs, BETA)\n            dynamic_range_B = np.max(profile_L_B) - np.min(profile_L_B)\n            prominence_B = PROM_FRAC * dynamic_range_B if dynamic_range_B > 0 else 0\n            peaks_B, _ = find_peaks(profile_L_B, prominence=prominence_B)\n            num_peaks_B = len(peaks_B)\n        else:\n            num_peaks_B = 0 # No valid points on profile\n        case_results.append(num_peaks_B)\n        \n        all_results.append(case_results)\n\n    # Format and print the final output\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3534929"}, {"introduction": "当我们获得参数的最佳估计值后，一个关键的收尾工作是量化我们对这些估计值的置信度。本练习将贝叶斯推断应用于岩土工程中广泛使用的修正剑桥（Modified Cam-Clay）模型，以计算其关键参数的后验不确定性。通过构建和分析后验协方差矩阵，您将学会如何解释参数间的相关性与物理上的权衡关系，并理解实验数据和先验知识是如何共同决定最终参数不确定性的 [@problem_id:3534949]。", "problem": "考虑一个小应变设置下 Modified Cam-Clay 模型的参数辨识问题，其参数向量定义为 $\\boldsymbol{\\theta} = [\\lambda, \\kappa, M, p_{c0}, N]^\\top$。这些符号依次代表孔隙比-平均有效应力自然对数坐标下的原始固结线斜率、卸载-再加载线斜率、三轴压缩下的临界状态应力比、初始先期固结压力以及比体积截距。假设观测模型基于两种标准实验模式：各向同性压缩-再加载实验，给出指定平均有效应力值下的孔隙比；以及临界状态下的排水三轴压缩实验，给出指定平均有效应力值下的偏应力。假设观测噪声为高斯噪声，参数具有高斯先验。使用最大后验 (MAP) 估计处的 Gauss-Newton 近似来逼近后验协方差，并根据参数权衡来解释其相关性结构。\n\n基本原理：\n- 对于高斯先验和加性高斯噪声，在 MAP 处线性化的 Bayes 定理给出了后验的高斯近似。在 MAP 处的负对数后验的 Gauss-Newton Hessian 近似为\n$$\\mathbf{H} \\approx \\mathbf{J}^\\top \\boldsymbol{\\Gamma}_{\\text{n}}^{-1} \\mathbf{J} + \\boldsymbol{\\Gamma}_{\\text{pr}}^{-1},$$\n其中 $\\mathbf{J}$ 是在 MAP 处残差向量关于 $\\boldsymbol{\\theta}$ 的雅可比矩阵，$\\boldsymbol{\\Gamma}_{\\text{n}}$ 是观测噪声协方差，$\\boldsymbol{\\Gamma}_{\\text{pr}}$ 是先验协方差。近似的后验协方差则为\n$$\\boldsymbol{\\Sigma}_{\\text{post}} \\approx \\mathbf{H}^{-1}.$$\n- 各向同性压缩-再加载孔隙比模型由 $e$ 与 $\\ln p'$ 之间的标准分段线性关系近似：\n  - 对于 $p' \\ge p_{c0}$ (正常固结): $e(p';\\boldsymbol{\\theta}) = N - \\lambda \\ln\\!\\left(\\dfrac{p'}{p_{\\text{ref}}}\\right)$。\n  - 对于 $p'  p_{c0}$ (超固结/再加载): $e(p';\\boldsymbol{\\theta}) = N - \\lambda \\ln\\!\\left(\\dfrac{p_{c0}}{p_{\\text{ref}}}\\right) - \\kappa \\ln\\!\\left(\\dfrac{p_{c0}}{p'}\\right)$。\n- 排水三轴临界状态关系为 $q(p';\\boldsymbol{\\theta}) = M\\, p'$。\n\n假设 $p_{\\text{ref}} = 1$ kPa。假设所有孔隙比测量值 $e$ 具有独立同分布的高斯噪声，标准差为 $\\sigma_e$，所有临界状态 $q$ 测量值具有独立同分布的高斯噪声，标准差为 $\\sigma_q$。$\\boldsymbol{\\theta}$ 的先验是具有对角协方差的高斯分布。\n\n在 MAP 估计 $\\boldsymbol{\\theta}^{\\star}$ 处，通过堆叠在 $\\boldsymbol{\\theta}^{\\star}$ 处求值的每个模型预测关于 $\\boldsymbol{\\theta}$ 的偏导数来定义雅可比矩阵 $\\mathbf{J}$，使用以下表达式：\n- 对于每个在 $p'$ 处的孔隙比数据点：\n  - 如果 $p' \\ge p_{c0}^{\\star}$，\n    $$\\frac{\\partial e}{\\partial \\lambda} = -\\ln\\!\\left(\\frac{p'}{p_{\\text{ref}}}\\right),\\quad \\frac{\\partial e}{\\partial \\kappa} = 0,\\quad \\frac{\\partial e}{\\partial M} = 0,\\quad \\frac{\\partial e}{\\partial p_{c0}} = 0,\\quad \\frac{\\partial e}{\\partial N} = 1.$$\n  - 如果 $p'  p_{c0}^{\\star}$，\n    $$\\frac{\\partial e}{\\partial \\lambda} = -\\ln\\!\\left(\\frac{p_{c0}^{\\star}}{p_{\\text{ref}}}\\right),\\quad \\frac{\\partial e}{\\partial \\kappa} = -\\ln\\!\\left(\\frac{p_{c0}^{\\star}}{p'}\\right),\\quad \\frac{\\partial e}{\\partial M} = 0,\\quad \\frac{\\partial e}{\\partial p_{c0}} = -\\frac{\\lambda^{\\star}+\\kappa^{\\star}}{p_{c0}^{\\star}},\\quad \\frac{\\partial e}{\\partial N} = 1.$$\n- 对于每个在 $p'$ 处的临界状态数据点：\n  $$\\frac{\\partial q}{\\partial M} = p',\\quad \\frac{\\partial q}{\\partial \\lambda} = 0,\\quad \\frac{\\partial q}{\\partial \\kappa} = 0,\\quad \\frac{\\partial q}{\\partial p_{c0}} = 0,\\quad \\frac{\\partial q}{\\partial N} = 0.$$\n\n噪声协方差为 $\\boldsymbol{\\Gamma}_{\\text{n}} = \\operatorname{diag}(\\sigma_e^2,\\dots,\\sigma_e^2,\\sigma_q^2,\\dots,\\sigma_q^2)$，与堆叠的残差向量对齐。先验协方差为 $\\boldsymbol{\\Gamma}_{\\text{pr}} = \\operatorname{diag}(s_\\lambda^2, s_\\kappa^2, s_M^2, s_{p_{c0}}^2, s_N^2)$。\n\n你的任务是编写一个程序，为下面定义的每个测试用例执行以下步骤：\n1. 根据提供的观测横坐标和模型定义，在 $\\boldsymbol{\\theta}^{\\star}$ 处构建 $\\mathbf{J}$。\n2. 构建 $\\boldsymbol{\\Gamma}_{\\text{n}}$ 和 $\\boldsymbol{\\Gamma}_{\\text{pr}}$。\n3. 计算 $\\mathbf{H} = \\mathbf{J}^\\top \\boldsymbol{\\Gamma}_{\\text{n}}^{-1} \\mathbf{J} + \\boldsymbol{\\Gamma}_{\\text{pr}}^{-1}$。\n4. 计算 $\\boldsymbol{\\Sigma}_{\\text{post}} = \\mathbf{H}^{-1}$。\n5. 按照指定的输出格式，报告参数 $[\\lambda, \\kappa, M, p_{c0}, N]$ 的后验边际标准差 $\\sqrt{\\Sigma_{ii}}$，以及从 $\\boldsymbol{\\Sigma}_{\\text{post}}$ 计算出的以下相关系数：\n   - $\\rho(N,\\lambda)$,\n   - $\\rho(\\kappa, p_{c0})$,\n   - $\\rho(M,\\lambda)$.\n\n使用以下常量和测试套件。所有压力单位为千帕 (kPa)。所有孔隙比测量值均为无量纲。所有标准差均以绝对值报告，相关系数为无量纲。以 kPa 为单位表示 $p_{c0}$ 的后验标准差。不涉及角度。\n\n所有测试用例的全局常量：\n- 参考压力：$p_{\\text{ref}} = 1$ kPa。\n- 噪声标准差：$\\sigma_e = 0.02$，$\\sigma_q = 10$ kPa。\n- 所有测试用例的 MAP 参数向量：\n  $$\\boldsymbol{\\theta}^{\\star} = [\\lambda^{\\star}, \\kappa^{\\star}, M^{\\star}, p_{c0}^{\\star}, N^{\\star}]^\\top = [0.2, 0.05, 1.2, 150, 2.0]^\\top.$$\n\n测试套件（每个用例指定孔隙比和临界状态测量的 $p'$ 值集合，以及先验标准差 $s$）：\n- 用例 A (平衡数据，中等先验):\n  - 孔隙比横坐标 $p'_e$: $[25, 50, 100, 200, 400]$ kPa。\n  - 临界状态横坐标 $p'_q$: $[50, 100, 200, 400]$ kPa。\n  - 先验标准差 $[s_\\lambda, s_\\kappa, s_M, s_{p_{c0}}, s_N] = [0.05, 0.02, 0.2, 50, 0.2]$。\n- 用例 B (无临界状态数据；先验主导 $M$):\n  - 孔隙比横坐标 $p'_e$: $[25, 50, 100, 200, 400]$ kPa。\n  - 临界状态横坐标 $p'_q$: 空列表 $[\\ ]$。\n  - 先验标准差 $[s_\\lambda, s_\\kappa, s_M, s_{p_{c0}}, s_N] = [0.05, 0.02, 0.2, 50, 0.2]$。\n- 用例 C (所有孔隙比数据均处于正常固结状态；$\\kappa$ 和 $p_{c0}$ 的可辨识性较弱):\n  - 孔隙比横坐标 $p'_e$: $[200, 300, 400, 600, 800]$ kPa。\n  - 临界状态横坐标 $p'_q$: $[50, 100, 200, 400]$ kPa。\n  - 先验标准差 $[s_\\lambda, s_\\kappa, s_M, s_{p_{c0}}, s_N] = [0.05, 0.02, 0.2, 50, 0.2]$。\n\n最终输出格式：\n- 对于每个测试用例，按以下顺序生成一个包含 $8$ 个值的列表：\n  $$[\\text{sd}_\\lambda, \\text{sd}_\\kappa, \\text{sd}_M, \\text{sd}_{p_{c0}}, \\text{sd}_N, \\rho(N,\\lambda), \\rho(\\kappa,p_{c0}), \\rho(M,\\lambda)].$$\n- 你的程序应生成单行输出，其中包含按测试套件顺序汇总到单个列表中的三个用例的结果，格式为方括号括起来的逗号分隔列表。每个内部列表必须包含四舍五入到六位小数的值。例如：\n  $$[[0.001234,0.005678,0.012345,1.234567,0.023456,-0.987654,0.123456,0.000000],[\\dots],[\\dots]].$$\n\n你的解决方案必须是纯算法的，从上述定义出发，且不得假设任何未知量。所有数值和单位必须严格按照提供的方式处理。报告 $\\text{sd}_{p_{c0}}$（单位为 kPa），并将所有其他标准差和相关性作为无量纲量报告，四舍五入到六位小数。", "solution": "目标是根据一组实验数据点和关于参数的先验知识，确定 Modified Cam-Clay 土壤模型参数的后验不确定性。这是一个贝叶斯参数辨识中的经典问题。我们将使用围绕最大后验 (MAP) 估计的线性化近似，这将后验分布简化为多元高斯分布。后验协方差矩阵量化了参数的不确定性和相关性，它被近似为在 MAP 估计处求值的负对数后验函数的 Hessian 矩阵的逆。\n\n参数向量定义为 $\\boldsymbol{\\theta} = [\\lambda, \\kappa, M, p_{c0}, N]^\\top$，包含 Modified Cam-Clay 模型的五个关键参数。问题提供了 MAP 估计 $\\boldsymbol{\\theta}^{\\star}$，任务是使用 Hessian 矩阵的 Gauss-Newton 近似 $\\mathbf{H}$ 来计算后验协方差 $\\boldsymbol{\\Sigma}_{\\text{post}}$。\n\nHessian 矩阵的公式为：\n$$\n\\mathbf{H} \\approx \\mathbf{J}^\\top \\boldsymbol{\\Gamma}_{\\text{n}}^{-1} \\mathbf{J} + \\boldsymbol{\\Gamma}_{\\text{pr}}^{-1}\n$$\n其中 $\\mathbf{J}$ 是模型预测关于参数 $\\boldsymbol{\\theta}$ 的雅可比矩阵，$\\boldsymbol{\\Gamma}_{\\text{n}}$ 是观测噪声的协方差矩阵，$\\boldsymbol{\\Gamma}_{\\text{pr}}$ 是参数高斯先验的协方差矩阵。\n\n解决每个测试用例的步骤如下：\n\n1.  **构建雅可比矩阵 ($\\mathbf{J}$)**：雅可比矩阵的每一行对应一个观测值，每一列对应一个参数。元素 $J_{ij}$ 是第 $i$ 个模型预测值相对于第 $j$ 个参数的偏导数 $\\partial f_i / \\partial \\theta_j$。预测值 $f_i$ 来自两个模型：\n    -   一个关于孔隙比 $e$ 作为平均有效应力 $p'$ 函数的模型，依赖于参数 $\\lambda, \\kappa, p_{c0}, N$。\n    -   一个关于临界状态下偏应力 $q$ 作为 $p'$ 函数的模型，依赖于参数 $M$。\n    \n    问题为这些偏导数提供了显式公式，这些公式在 MAP 估计 $\\boldsymbol{\\theta}^{\\star} = [0.2, 0.05, 1.2, 150, 2.0]^\\top$ 和每次测量给定的压力值处进行计算。雅可比矩阵将有 $m = n_e + n_q$ 行（其中 $n_e$ 和 $n_q$ 分别是孔隙比和临界状态测量的数量）和 5 列。\n\n2.  **构建噪声和先验协方差矩阵**：\n    -   观测噪声被假设为独立的高斯噪声。因此，噪声协方差 $\\boldsymbol{\\Gamma}_{\\text{n}}$ 是一个对角矩阵。对于 $n_e$ 个孔隙比测量，对角线元素是 $\\sigma_e^2 = (0.02)^2$；对于 $n_q$ 个临界状态测量，对角线元素是 $\\sigma_q^2 = (10)^2$。它的逆矩阵 $\\boldsymbol{\\Gamma}_{\\text{n}}^{-1}$ 也是对角矩阵，元素为 $1/\\sigma_e^2$ 和 $1/\\sigma_q^2$。\n    -   参数的先验也是高斯分布，具有对角协方差矩阵 $\\boldsymbol{\\Gamma}_{\\text{pr}}$。对角线元素是先验标准差的平方，即 $[s_\\lambda^2, s_\\kappa^2, s_M^2, s_{p_{c0}}^2, s_N^2]$，这些值在每个测试用例中都已提供。它的逆矩阵 $\\boldsymbol{\\Gamma}_{\\text{pr}}^{-1}$ 是一个对角矩阵，元素为 $1/s_j^2$。\n\n3.  **计算 Hessian 矩阵 ($\\mathbf{H}$)**：构建好 $\\mathbf{J}$、$\\boldsymbol{\\Gamma}_{\\text{n}}^{-1}$ 和 $\\boldsymbol{\\Gamma}_{\\text{pr}}^{-1}$ 后，通过矩阵乘法和加法，使用提供的公式计算 Hessian 矩阵 $\\mathbf{H}$。项 $\\mathbf{J}^\\top \\boldsymbol{\\Gamma}_{\\text{n}}^{-1} \\mathbf{J}$ 代表从数据中获得的信息（似然），而 $\\boldsymbol{\\Gamma}_{\\text{pr}}^{-1}$ 代表从先验中获得的信息。\n\n4.  **计算后验协方差 ($\\boldsymbol{\\Sigma}_{\\text{post}}$)**：近似的后验协方差矩阵是 Hessian 矩阵的逆：\n    $$\n    \\boldsymbol{\\Sigma}_{\\text{post}} \\approx \\mathbf{H}^{-1}\n    $$\n    这个 $5 \\times 5$ 矩阵的对角线是参数的方差，非对角线元素是协方差。\n\n5.  **提取结果**：\n    -   每个参数 $\\theta_i$ 的后验边际标准差是后验协方差矩阵对应对角元素的平方根：$\\text{sd}_i = \\sqrt{(\\boldsymbol{\\Sigma}_{\\text{post}})_{ii}}$。\n    -   两个参数 $\\theta_i$ 和 $\\theta_j$ 之间的相关系数计算如下：\n        $$\n        \\rho(\\theta_i, \\theta_j) = \\frac{(\\boldsymbol{\\Sigma}_{\\text{post}})_{ij}}{\\sqrt{(\\boldsymbol{\\Sigma}_{\\text{post}})_{ii} (\\boldsymbol{\\Sigma}_{\\text{post}})_{jj}}}\n        $$\n    \n    每个测试用例所需的量是五个后验标准差（$\\text{sd}_\\lambda$, $\\text{sd}_\\kappa$, $\\text{sd}_M$, $\\text{sd}_{p_{c0}}$, $\\text{sd}_N$）和三个特定的相关系数（$\\rho(N,\\lambda)$, $\\rho(\\kappa,p_{c0})$, $\\rho(M,\\lambda)$）。\n\n从雅可比矩阵的结构中可以得到一个重要的见解。孔隙比 $e$ 对参数 $M$ 的灵敏度为零。相反，临界状态应力 $q$ 对参数 $\\lambda$、$\\kappa$、$p_{c0}$ 和 $N$ 的灵敏度为零。这种结构上的分离意味着 Hessian 矩阵 $\\mathbf{H}$ 将是块对角矩阵，其中一个块用于参数 $M$，另一个块用于其余四个参数。因此，其逆矩阵 $\\boldsymbol{\\Sigma}_{\\text{post}}$ 也将是块对角的。这意味着 $M$ 的后验估计将与另外四个参数的后验估计在统计上不相关。因此，对于所有测试用例，$\\rho(M,\\lambda)$ 在数学上预期为零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the series of test cases for a parameter identification problem.\n    \"\"\"\n    # Global constants\n    p_ref = 1.0  # kPa\n    sigma_e = 0.02\n    sigma_q = 10.0  # kPa\n    theta_star = np.array([0.2, 0.05, 1.2, 150.0, 2.0])  # [lambda, kappa, M, pc0, N]\n\n    # Test suite\n    test_suite = {\n        \"Case A\": {\n            \"p_e_values\": [25.0, 50.0, 100.0, 200.0, 400.0],\n            \"p_q_values\": [50.0, 100.0, 200.0, 400.0],\n            \"s_prior\": [0.05, 0.02, 0.2, 50.0, 0.2]\n        },\n        \"Case B\": {\n            \"p_e_values\": [25.0, 50.0, 100.0, 200.0, 400.0],\n            \"p_q_values\": [],\n            \"s_prior\": [0.05, 0.02, 0.2, 50.0, 0.2]\n        },\n        \"Case C\": {\n            \"p_e_values\": [200.0, 300.0, 400.0, 600.0, 800.0],\n            \"p_q_values\": [50.0, 100.0, 200.0, 400.0],\n            \"s_prior\": [0.05, 0.02, 0.2, 50.0, 0.2]\n        }\n    }\n    \n    all_results = []\n    \n    for case_name in [\"Case A\", \"Case B\", \"Case C\"]:\n        case_data = test_suite[case_name]\n        result = _calculate_posterior_covariance(\n            p_e_values=case_data[\"p_e_values\"],\n            p_q_values=case_data[\"p_q_values\"],\n            s_prior=case_data[\"s_prior\"],\n            theta_star=theta_star,\n            p_ref=p_ref,\n            sigma_e=sigma_e,\n            sigma_q=sigma_q\n        )\n        all_results.append(result)\n\n    # Format output as specified\n    formatted_results = []\n    for res in all_results:\n        formatted_res = [f\"{x:.6f}\" for x in res]\n        formatted_results.append(f\"[{','.join(formatted_res)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _calculate_posterior_covariance(\n    p_e_values, p_q_values, s_prior, theta_star, p_ref, sigma_e, sigma_q\n):\n    \"\"\"\n    Calculates the posterior covariance matrix and derived quantities for one test case.\n    \"\"\"\n    lambda_star, kappa_star, _, pc0_star, _ = theta_star\n    n_params = 5\n\n    J_rows = []\n    Gamma_n_inv_diag = []\n\n    # Parameter indices: 0:lambda, 1:kappa, 2:M, 3:pc0, 4:N\n    \n    # Process void ratio measurements\n    for p_prime in p_e_values:\n        j_row = np.zeros(n_params)\n        if p_prime >= pc0_star:\n            # Normally consolidated branch\n            j_row[0] = -np.log(p_prime / p_ref)  # d(e)/d(lambda)\n            # j_row[1] = 0 (d(e)/d(kappa)) is zero\n            # j_row[2] = 0 (d(e)/d(M)) is zero\n            # j_row[3] = 0 (d(e)/d(pc0)) is zero\n            j_row[4] = 1.0                      # d(e)/d(N)\n        else:\n            # Overconsolidated branch\n            j_row[0] = -np.log(pc0_star / p_ref) # d(e)/d(lambda)\n            j_row[1] = -np.log(pc0_star / p_prime) # d(e)/d(kappa)\n            # j_row[2] = 0 (d(e)/d(M)) is zero\n            j_row[3] = -(lambda_star + kappa_star) / pc0_star  # d(e)/d(pc0)\n            j_row[4] = 1.0                       # d(e)/d(N)\n        \n        J_rows.append(j_row)\n        Gamma_n_inv_diag.append(1.0 / sigma_e**2)\n\n    # Process critical state measurements\n    for p_prime in p_q_values:\n        j_row = np.zeros(n_params)\n        j_row[2] = p_prime  # d(q)/d(M)\n        J_rows.append(j_row)\n        Gamma_n_inv_diag.append(1.0 / sigma_q**2)\n    \n    # Construct Jacobian and inverse noise covariance matrix\n    if not J_rows:\n        J = np.zeros((0, n_params))\n    else:\n        J = np.array(J_rows)\n    \n    Gamma_n_inv = np.diag(Gamma_n_inv_diag)\n    \n    # Calculate Hessian term from data\n    if J.shape[0] == 0:\n        H_data = np.zeros((n_params, n_params))\n    else:\n        H_data = J.T @ Gamma_n_inv @ J\n\n    # Calculate Hessian term from prior\n    s_prior_sq = np.array(s_prior)**2\n    Gamma_pr_inv_diag = 1.0 / s_prior_sq\n    Gamma_pr_inv = np.diag(Gamma_pr_inv_diag)\n    \n    # Total Hessian of negative log posterior\n    H = H_data + Gamma_pr_inv\n    \n    # Posterior covariance is the inverse of the Hessian\n    Sigma_post = np.linalg.inv(H)\n    \n    # Extract results: standard deviations and correlations\n    post_std_devs = np.sqrt(np.diag(Sigma_post))\n    \n    def get_corr(i, j, sigma_matrix, std_devs):\n        if std_devs[i] == 0 or std_devs[j] == 0:\n            return 0.0\n        return sigma_matrix[i, j] / (std_devs[i] * std_devs[j])\n\n    rho_N_lambda = get_corr(4, 0, Sigma_post, post_std_devs)\n    rho_kappa_pc0 = get_corr(1, 3, Sigma_post, post_std_devs)\n    rho_M_lambda = get_corr(2, 0, Sigma_post, post_std_devs)\n    \n    # sd_lambda, sd_kappa, sd_M, sd_pc0, sd_N\n    result = [\n        post_std_devs[0], \n        post_std_devs[1], \n        post_std_devs[2], \n        post_std_devs[3], \n        post_std_devs[4],\n        rho_N_lambda,\n        rho_kappa_pc0,\n        rho_M_lambda\n    ]\n    \n    return result\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3534949"}]}