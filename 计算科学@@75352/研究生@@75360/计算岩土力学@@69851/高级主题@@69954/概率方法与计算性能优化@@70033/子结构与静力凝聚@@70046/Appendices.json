{"hands_on_practices": [{"introduction": "第一个实践是一项旨在建立直觉的基础练习。通过为一个简单的双单元杆手动推导静态凝聚，您将了解舒尔补 (Schur complement) 是如何从分块消元中自然产生的，以及它的物理意义。此问题 [@problem_id:3565840] 采用了一种非常规的划分方式，以揭示整个结构潜在的静态平衡条件。", "problem": "一根笔直的、等截面的、一维杆被离散为两个线性双节点有限元，它们在一个界面节点上连接。设全局节点从左到右标记为 $\\{1,2,3\\}$，单元 $1$ 连接节点 $\\{1,2\\}$，单元 $2$ 连接节点 $\\{2,3\\}$。两个单元的轴向刚度分别为 $k_1$ 和 $k_2$，其物理单位均为 $\\text{N}/\\text{m}$。将节点轴向位移表示为 $u_1$, $u_2$, $u_3$，外部施加的节点轴向载荷表示为 $f_1$, $f_2$, $f_3$（在正轴向方向上为正）。\n\n假设小应变、线弹性和准静态条件。以(i) 节点的力平衡，(ii) 每个单元的线弹性轴向力-位移关系，以及 (iii) 局部坐标系中标准的双节点杆单元刚度表示为基本依据。\n\n任务：\n1. 从众所周知的双节点杆单元刚度 $\\mathbf{k}_e = k_e \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$（其中对于单元 $1$ 和 $2$，$k_e$ 分别为 $k_1, k_2$）出发，为系统的全局自由度排序 $\\{u_1,u_2,u_3\\}$ 组装全局刚度矩阵 $\\mathbf{K}$。用 $k_1$ 和 $k_2$ 显式写出组装好的 $\\mathbf{K}$。\n\n2. 通过选择界面位移 $u_2$ 作为唯一的“凝聚”自由度，以及两个边界位移 $\\{u_1,u_3\\}$ 作为“消去”自由度，对全局系统 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ 进行分区。即，写出 $\\mathbf{u} = \\begin{pmatrix} \\mathbf{u}_b \\\\ \\mathbf{u}_c \\end{pmatrix}$，其中 $\\mathbf{u}_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$ 和 $\\mathbf{u}_c = \\begin{pmatrix} u_2 \\end{pmatrix}$，并用 $k_1$ 和 $k_2$ 显式写出分块矩阵 $\\mathbf{K}_{bb}$, $\\mathbf{K}_{bc}$, $\\mathbf{K}_{cb}$ 和 $\\mathbf{K}_{cc}$。\n\n3. 使用基于 Schur 补的静态凝聚法，消去 $\\mathbf{u}_b$ 以获得形式为\n$$\nS\\,u_2 \\;=\\; g,\n$$\n的单个标量界面平衡方程，其中 $S$ 是凝聚标量刚度，$g$ 是凝聚标量载荷。用 $k_1$, $k_2$ 以及节点载荷 $f_1$, $f_2$, $f_3$ 显式推导 $S$ 和 $g$。验证分区刚度是对称的，并且 $S$ 和 $g$ 的物理单位分别与刚度和力一致。\n\n以牛顿为单位表示 $g$ 的最终答案。不要进行数值计算；提供精确的代数表达式。仅报告 $g$ 作为您的最终答案。", "solution": "首先验证问题，以确保其科学上合理、内容独立且提法恰当。\n\n### 步骤 1：提取已知条件\n- **系统**：一根笔直的、等截面的、一维杆。\n- **离散化**：两个线性双节点有限元在一个界面节点上连接。\n- **节点**：全局节点标记为 {$1$, $2$, $3$}。单元 $1$ 连接节点 {$1, 2$}；单元 $2$ 连接节点 {$2, 3$}。\n- **刚度**：单元 $1$ 的轴向刚度为 $k_1$。单元 $2$ 的轴向刚度为 $k_2$。单位为 $\\text{N}/\\text{m}$。\n- **自由度 (DOFs)**：节点轴向位移为 $u_1$, $u_2$, $u_3$。\n- **载荷**：外部节点轴向载荷为 $f_1$, $f_2$, $f_3$。\n- **假设**：小应变、线弹性和准静态条件。\n- **控制原理**：(i) 力平衡，(ii) 线弹性力-位移关系，(iii) 标准双节点杆单元刚度矩阵。\n- **单元刚度矩阵**：$\\mathbf{k}_e = k_e \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$，其中 $k_e \\in \\{k_1, k_2\\}$。\n- **任务 1**：为自由度排序 $\\{u_1, u_2, u_3\\}$ 组装全局刚度矩阵 $\\mathbf{K}$。\n- **任务 2**：使用 $\\mathbf{u}_c = u_2$（“凝聚”）和 $\\mathbf{u}_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$（“消去”）对系统 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ 进行分区。确定分块矩阵 $\\mathbf{K}_{bb}$, $\\mathbf{K}_{bc}$, $\\mathbf{K}_{cb}$, $\\mathbf{K}_{cc}$。\n- **任务 3**：使用静态凝聚法消去 $\\mathbf{u}_b$，并推导凝聚系统 $S u_2 = g$。推导标量刚度 $S$ 和标量载荷 $g$ 的表达式。\n- **最终答案**：报告 $g$ 的精确代数表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是有限元法 (FEM) 应用于结构力学的一个标准练习。所有概念，包括单元刚度矩阵、全局组装和静态凝聚（通过 Schur 补），都是计算力学中基本且公认的原理。问题陈述清晰、客观，并为获得唯一解提供了所有必要信息。分区方案虽然不是凝聚法最常见的应用，但在数学上是明确定义的。所需矩阵逆（$\\mathbf{K}_{bb}^{-1}$）存在的条件是满足的，因为物理上要求单元刚度 $k_1, k_2$ 为正值。该问题具有科学依据、提法恰当且客观。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答推导\n\n**1. 全局刚度矩阵 $\\mathbf{K}$ 的组装**\n\n系统由两个单元组成。单元刚度矩阵是根据其各自的局部节点顺序给出的。\n对于单元 $1$（节点 $1, 2$），其刚度矩阵为：\n$$ \\mathbf{k}^{(1)} = k_1 \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\n对于单元 $2$（节点 $2, 3$），其刚度矩阵为：\n$$ \\mathbf{k}^{(2)} = k_2 \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\n全局刚度矩阵 $\\mathbf{K}$ 是通过直接刚度法为全局自由度 $\\{u_1, u_2, u_3\\}$ 组装的。单元矩阵的元素被加到全局矩阵中的相应位置。\n\n$K_{11}$ 取自 $\\mathbf{k}^{(1)}$ 的 $(1,1)$ 项。\n$K_{22}$ 取自 $\\mathbf{k}^{(1)}$ 的 $(2,2)$ 项和 $\\mathbf{k}^{(2)}$ 的 $(1,1)$ 项。\n$K_{33}$ 取自 $\\mathbf{k}^{(2)}$ 的 $(2,2)$ 项。\n非对角项也以类似方式组装。\n\n$$\n\\mathbf{K} =\n\\begin{pmatrix}\nk_1 & -k_1 & 0 \\\\\n-k_1 & k_1 + k_2 & -k_2 \\\\\n0 & -k_2 & k_2\n\\end{pmatrix}\n$$\n全局方程组为 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$，其中 $\\mathbf{u} = \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix}$ 且 $\\mathbf{f} = \\begin{pmatrix} f_1 \\\\ f_2 \\\\ f_3 \\end{pmatrix}$。\n\n**2. 全局系统的分区**\n\n问题指定了一个分区方案，其中“凝聚”（保留）的自由度为 $\\mathbf{u}_c = u_2$，“消去”的自由度为 $\\mathbf{u}_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$。为了符合分块矩阵结构，我们必须为自由度向量 $\\begin{pmatrix} \\mathbf{u}_c \\\\ \\mathbf{u}_b \\end{pmatrix} = \\begin{pmatrix} u_2 \\\\ u_1 \\\\ u_3 \\end{pmatrix}$ 对 方程组进行重新排序。相应的力向量为 $\\begin{pmatrix} \\mathbf{f}_c \\\\ \\mathbf{f}_b \\end{pmatrix} = \\begin{pmatrix} f_2 \\\\ f_1 \\\\ f_3 \\end{pmatrix}$。\n\n重新排序后的刚度矩阵，记作 $\\mathbf{K}'$，是通过对 $\\mathbf{K}$ 的行和列进行置换以匹配新的自由度顺序 $\\{2, 1, 3\\}$ 而得到的。\n$$\n\\mathbf{K}' =\n\\begin{pmatrix}\nK_{22} & K_{21} & K_{23} \\\\\nK_{12} & K_{11} & K_{13} \\\\\nK_{32} & K_{31} & K_{33}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nk_1+k_2 & -k_1 & -k_2 \\\\\n-k_1 & k_1 & 0 \\\\\n-k_2 & 0 & k_2\n\\end{pmatrix}\n$$\n分区后的系统为 $\\mathbf{K}' \\begin{pmatrix} \\mathbf{u}_c \\\\ \\mathbf{u}_b \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f}_c \\\\ \\mathbf{f}_b \\end{pmatrix}$。我们确定各分块如下：\n$$\n\\mathbf{K}' =\n\\left[\n\\begin{array}{c|cc}\n\\mathbf{K}_{cc} & \\mathbf{K}_{cb} \\\\\n\\hline\n\\mathbf{K}_{bc} & \\mathbf{K}_{bb}\n\\end{array}\n\\right]\n$$\n具体分块为：\n- $\\mathbf{K}_{cc} = [k_1+k_2]$ (一个 $1 \\times 1$ 矩阵)\n- $\\mathbf{K}_{cb} = \\begin{pmatrix} -k_1 & -k_2 \\end{pmatrix}$ (一个 $1 \\times 2$ 矩阵)\n- $\\mathbf{K}_{bc} = \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix}$ (一个 $2 \\times 1$ 矩阵)\n- $\\mathbf{K}_{bb} = \\begin{pmatrix} k_1 & 0 \\\\ 0 & k_2 \\end{pmatrix}$ (一个 $2 \\times 2$ 矩阵)\n\n分区后的方程组为：\n$$ \\mathbf{K}_{cc} \\mathbf{u}_c + \\mathbf{K}_{cb} \\mathbf{u}_b = \\mathbf{f}_c $$\n$$ \\mathbf{K}_{bc} \\mathbf{u}_c + \\mathbf{K}_{bb} \\mathbf{u}_b = \\mathbf{f}_b $$\n\n**3. 静态凝聚**\n\n我们按要求消去 $\\mathbf{u}_b$。从第二个方程：\n$$ \\mathbf{K}_{bb} \\mathbf{u}_b = \\mathbf{f}_b - \\mathbf{K}_{bc} \\mathbf{u}_c $$\n为了求解 $\\mathbf{u}_b$，我们必须对 $\\mathbf{K}_{bb}$ 求逆。其行列式为 $\\det(\\mathbf{K}_{bb}) = k_1 k_2$。由于 $k_1$ 和 $k_2$ 代表物理刚度，它们是严格为正的，所以 $\\det(\\mathbf{K}_{bb}) > 0$ 且逆矩阵存在。\n$$ \\mathbf{K}_{bb}^{-1} = \\frac{1}{k_1 k_2} \\begin{pmatrix} k_2 & 0 \\\\ 0 & k_1 \\end{pmatrix} = \\begin{pmatrix} 1/k_1 & 0 \\\\ 0 & 1/k_2 \\end{pmatrix} $$\n因此，\n$$ \\mathbf{u}_b = \\mathbf{K}_{bb}^{-1} (\\mathbf{f}_b - \\mathbf{K}_{bc} \\mathbf{u}_c) $$\n将此代入第一个方程：\n$$ \\mathbf{K}_{cc} \\mathbf{u}_c + \\mathbf{K}_{cb} \\left( \\mathbf{K}_{bb}^{-1} (\\mathbf{f}_b - \\mathbf{K}_{bc} \\mathbf{u}_c) \\right) = \\mathbf{f}_c $$\n重新整理各项以组合 $\\mathbf{u}_c$：\n$$ (\\mathbf{K}_{cc} - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{K}_{bc}) \\mathbf{u}_c = \\mathbf{f}_c - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{f}_b $$\n这就是凝聚系统 $S u_2 = g$，其中 $S$ 是 $\\mathbf{K}_{bb}$ 在 $\\mathbf{K}'$ 中的 Schur 补。\n\n让我们计算 $S$ 和 $g$。\n$$ S = \\mathbf{K}_{cc} - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{K}_{bc} $$\n$$ S = (k_1+k_2) - \\begin{pmatrix} -k_1 & -k_2 \\end{pmatrix} \\begin{pmatrix} 1/k_1 & 0 \\\\ 0 & 1/k_2 \\end{pmatrix} \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix} $$\n$$ S = (k_1+k_2) - \\begin{pmatrix} -1 & -1 \\end{pmatrix} \\begin{pmatrix} -k_1 \\\\ -k_2 \\end{pmatrix} $$\n$$ S = (k_1+k_2) - ((-1)(-k_1) + (-1)(-k_2)) $$\n$$ S = (k_1+k_2) - (k_1+k_2) = 0 $$\n凝聚刚度为 $S=0$。这在物理上对应于无约束杆具有刚体模态，而凝聚过程分离出了静态平衡的条件。$S$ 的单位是 $\\text{N}/\\text{m}$，这是相符的。\n\n现在我们计算凝聚载荷向量 $g$。\n$$ g = \\mathbf{f}_c - \\mathbf{K}_{cb} \\mathbf{K}_{bb}^{-1} \\mathbf{f}_b $$\n回顾 $\\mathbf{f}_c = f_2$ 和 $\\mathbf{f}_b = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}$：\n$$ g = f_2 - \\begin{pmatrix} -k_1 & -k_2 \\end{pmatrix} \\begin{pmatrix} 1/k_1 & 0 \\\\ 0 & 1/k_2 \\end{pmatrix} \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix} $$\n$$ g = f_2 - \\begin{pmatrix} -1 & -1 \\end{pmatrix} \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix} $$\n$$ g = f_2 - ((-1)f_1 + (-1)f_3) $$\n$$ g = f_2 - (-f_1 - f_3) = f_1 + f_2 + f_3 $$\n$g$ 的最终表达式是所有外部节点力之和。凝聚方程为 $0 \\cdot u_2 = f_1 + f_2 + f_3$。这表明，要存在静态解，作用在自由浮动系统上的净外力必须为零，即 $g=0$。$g$ 的物理单位是牛顿 ($\\text{N}$)，因为它是力的总和。\n\n问题要求给出 $g$ 的表达式。\n$$ g = f_1 + f_2 + f_3 $$\n这就是最终推导出的表达式。", "answer": "$$\n\\boxed{f_1 + f_2 + f_3}\n$$", "id": "3565840"}, {"introduction": "在实际应用中，显式地构建全局舒尔补矩阵的计算成本可能高得令人望而却步。此实践 [@problem_id:3565877] 介绍了一项至关重要的计算技术：在不组装完整矩阵的情况下，实现舒尔补算子对向量的“作用”。这种依赖于局部子域求解和“收集-分散”操作的无矩阵方法，是现代区域分解方法的核心基石。", "problem": "本题要求您实现一个由子结构法和静力凝聚产生的界面算子的应用，而无需显式组装全局舒尔补。目标是设计数据结构和组装映射，通过仅在内部自由度（DOF）上进行局部子域求解以及对界面向量进行收集-散发操作，来实现该算子在全局界面向量上的作用。\n\n考虑一组由 $s$ 索引的子域，每个子域的刚度矩阵都按内部和界面自由度进行了分块。其基本依据是，控制线性系统是对称正定的，且源于一个适定的变分形式，并且对内部自由度执行分块高斯消元可以得到一个仅作用于界面自由度的算子。您绝不能显式组装全局算子；相反，您必须通过对内部自由度进行局部线性求解，并通过组装映射对贡献进行求和，来实现其在给定界面向量上的作用。\n\n程序要求：\n- 为每个子域 $s$ 设计一个数据结构，用于存储矩阵 $K_{ii}^{(s)}$、$K_{ib}^{(s)}$、$K_{bi}^{(s)}$、$K_{bb}^{(s)}$ 以及一个将每个局部界面自由度索引 $j$ 映射到全局界面索引 $\\phi^{(s)}(j)$ 的映射 $\\phi^{(s)}$。\n- 实现一个函数，在给定全局界面向量 $x_b \\in \\mathbb{R}^{N_b}$ 的情况下，通过以下步骤计算 $y_b = S x_b$ 而无需组装 $S$：\n  - 使用 $\\phi^{(s)}$ 收集局部切片 $x_b^{(s)}$，\n  - 对每个子域的内部自由度求解一个局部内部系统，\n  - 形成局部界面贡献，\n  - 使用 $\\phi^{(s)}$ 将这些贡献散发并求和回全局界面向量。\n- 您的程序必须对下面给出的一组测试用例应用此操作，并打印结果向量。\n\n定义与约束：\n- 所有矩阵和向量均为实值。\n- 如果一个子域没有内部自由度，则将其内部分块视为空，并跳过内部求解；其贡献仅取决于其界面分块。\n- 所有界面映射都是从局部索引到全局索引的多对一映射，重叠的贡献必须求和。\n- 不涉及角度。不需要物理单位。\n\n测试套件：\n请提供以下三个测试用例的结果。对于每个子域 $s$，给定 $K_{ii}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_i^{(s)}}$、$K_{ib}^{(s)} \\in \\mathbb{R}^{n_i^{(s)} \\times n_b^{(s)}}$、$K_{bi}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_i^{(s)}}$、$K_{bb}^{(s)} \\in \\mathbb{R}^{n_b^{(s)} \\times n_b^{(s)}}$，以及一个局部到全局的界面映射 $\\phi^{(s)}: \\{0,\\ldots,n_b^{(s)}-1\\} \\to \\{0,\\ldots,N_b-1\\}$。全局界面向量 $x_b$ 的长度为 $N_b$。\n\n- 测试用例 A：\n  - 全局界面大小 $N_b = 1$。\n  - 子域：单个子域 $s$，其中\n    $$\n    K_{ii}^{(s)} =\n    \\begin{bmatrix}\n    4 & 1 \\\\\n    1 & 3\n    \\end{bmatrix},\\quad\n    K_{ib}^{(s)} =\n    \\begin{bmatrix}\n    1 \\\\\n    2\n    \\end{bmatrix},\\quad\n    K_{bi}^{(s)} =\n    \\begin{bmatrix}\n    1 & 2\n    \\end{bmatrix},\\quad\n    K_{bb}^{(s)} =\n    \\begin{bmatrix}\n    5\n    \\end{bmatrix}.\n    $$\n    局部到全局映射为 $\\phi^{(s)} = [0]$。\n  - 使用 $x_b = [1.5]$。\n- 测试用例 B：\n  - 全局界面大小 $N_b = 3$。\n  - 子域：两个子域 $s \\in \\{1,2\\}$，具体如下。\n    - 子域 $s=1$：\n      $$\n      K_{ii}^{(1)} =\n      \\begin{bmatrix}\n      3\n      \\end{bmatrix},\\quad\n      K_{ib}^{(1)} =\n      \\begin{bmatrix}\n      1 & -1\n      \\end{bmatrix},\\quad\n      K_{bi}^{(1)} =\n      \\begin{bmatrix}\n      1 \\\\\n      -1\n      \\end{bmatrix},\\quad\n      K_{bb}^{(1)} =\n      \\begin{bmatrix}\n      4 & 0.5 \\\\\n      0.5 & 2\n      \\end{bmatrix}.\n      $$\n      局部到全局映射为 $\\phi^{(1)} = [0, 1]$。\n    - 子域 $s=2$：\n      $$\n      K_{ii}^{(2)} =\n      \\begin{bmatrix}\n      6 & 1 \\\\\n      1 & 4\n      \\end{bmatrix},\\quad\n      K_{ib}^{(2)} =\n      \\begin{bmatrix}\n      2 & 0 \\\\\n      -1 & 3\n      \\end{bmatrix},\\quad\n      K_{bi}^{(2)} =\n      \\begin{bmatrix}\n      2 & -1 \\\\\n      0 & 3\n      \\end{bmatrix},\\quad\n      K_{bb}^{(2)} =\n      \\begin{bmatrix}\n      3 & -0.2 \\\\\n      -0.2 & 5\n      \\end{bmatrix}.\n      $$\n      局部到全局映射为 $\\phi^{(2)} = [1, 2]$。\n  - 使用 $x_b = [1.0,\\,-0.5,\\,2.0]$。\n- 测试用例 C：\n  - 全局界面大小 $N_b = 3$。\n  - 子域：三个子域 $s \\in \\{1,2,3\\}$，具体如下。\n    - 子域 $s=1$（无内部自由度）：\n      $$\n      K_{ii}^{(1)} \\in \\mathbb{R}^{0 \\times 0},\\quad\n      K_{ib}^{(1)} \\in \\mathbbR^{0 \\times 2},\\quad\n      K_{bi}^{(1)} \\in \\mathbb{R}^{2 \\times 0},\\quad\n      K_{bb}^{(1)} =\n      \\begin{bmatrix}\n      2 & 0.3 \\\\\n      0.3 & 1.5\n      \\end{bmatrix}.\n      $$\n      局部到全局映射为 $\\phi^{(1)} = [0, 1]$。\n    - 子域 $s=2$：\n      $$\n      K_{ii}^{(2)} =\n      \\begin{bmatrix}\n      2\n      \\end{bmatrix},\\quad\n      K_{ib}^{(2)} =\n      \\begin{bmatrix}\n      -1 & 0.5\n      \\end{bmatrix},\\quad\n      K_{bi}^{(2)} =\n      \\begin{bmatrix}\n      -1 \\\\\n      0.5\n      \\end{bmatrix},\\quad\n      K_{bb}^{(2)} =\n      \\begin{bmatrix}\n      1 & 0.1 \\\\\n      0.1 & 2\n      \\end{bmatrix}.\n      $$\n      局部到全局映射为 $\\phi^{(2)} = [1, 2]$。\n    - 子域 $s=3$：\n      $$\n      K_{ii}^{(3)} =\n      \\begin{bmatrix}\n      7 & 0 \\\\\n      0 & 8\n      \\end{bmatrix},\\quad\n      K_{ib}^{(3)} =\n      \\begin{bmatrix}\n      1 \\\\\n      2\n      \\end{bmatrix},\\quad\n      K_{bi}^{(3)} =\n      \\begin{bmatrix}\n      1 & 2\n      \\end{bmatrix},\\quad\n      K_{bb}^{(3)} =\n      \\begin{bmatrix}\n      4\n      \\end{bmatrix}.\n      $$\n      局部到全局映射为 $\\phi^{(3)} = [2]$。\n  - 使用 $x_b = [0.2,\\,-1.2,\\,0.7]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。此列表中的每个元素对应一个测试用例，并且其本身必须是一个列表，表示该测试用例的最终全局界面向量 $y_b$。例如，打印的结构必须类似于 $[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,\\ldots\\,]$。\n- 所有浮点数需表示为小数点后 $6$ 位，并使用标准四舍五入。", "solution": "该问题是有效的，因为它在科学上是合理的、适定的，并提供了完整的规范。它描述了计算力学中一个称为静力凝聚的标准数值过程，这是某些区域分解方法（如有限元撕裂与互连（FETI）方法或通用子结构法）的关键组成部分。该问题要求实现全局舒尔补算子与向量的矩阵-向量乘积，而无需显式地构建该算子。\n\n其控制原理基于全局线性方程组的分块，这通常源于有限元方法（FEM）离散化。对于一个划分为内部自由度（DOF）（由索引 $i$ 表示）和界面（或边界）自由度（由索引 $b$ 表示）的系统，单个子域 $s$ 的线性系统可以写为：\n$$\n\\begin{bmatrix} K_{ii}^{(s)} & K_{ib}^{(s)} \\\\ K_{bi}^{(s)} & K_{bb}^{(s)} \\end{bmatrix}\n\\begin{bmatrix} x_i^{(s)} \\\\ x_b^{(s)} \\end{bmatrix}\n=\n\\begin{bmatrix} f_i^{(s)} \\\\ f_b^{(s)} \\end{bmatrix}\n$$\n这里，$K^{(s)}$ 是子域 $s$ 的刚度矩阵，$x^{(s)}$ 是未知位移向量，$f^{(s)}$ 是施加的节点力向量。索引 $i$ 和 $b$ 分别指局部内部和局部界面自由度。\n\n静力凝聚是消除内部自由度 $x_i^{(s)}$ 的过程。假设没有外力施加于内部自由度（即 $f_i^{(s)} = 0$），块系统的第一行给出：\n$$\nK_{ii}^{(s)} x_i^{(s)} + K_{ib}^{(s)} x_b^{(s)} = 0\n$$\n由于问题陈述该系统源于一个适定的公式，矩阵 $K_{ii}^{(s)}$（即边界被“钳制”的子域的刚度）是对称正定的，因此是可逆的。我们可以用界面位移 $x_b^{(s)}$ 来表示内部位移 $x_i^{(s)}$：\n$$\nx_i^{(s)} = -(K_{ii}^{(s)})^{-1} K_{ib}^{(s)} x_b^{(s)}\n$$\n将此代入描述界面自由度上力的块系统第二行，我们得到：\n$$\nf_b^{(s)} = K_{bi}^{(s)} x_i^{(s)} + K_{bb}^{(s)} x_b^{(s)} = K_{bi}^{(s)} \\left( -(K_{ii}^{(s)})^{-1} K_{ib}^{(s)} x_b^{(s)} \\right) + K_{bb}^{(s)} x_b^{(s)}\n$$\n这可以简化为：\n$$\nf_b^{(s)} = \\left( K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)} \\right) x_b^{(s)}\n$$\n括号中的项是局部舒尔补矩阵 $S^{(s)}$：\n$$\nS^{(s)} = K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)}\n$$\n$S^{(s)}$ 将局部界面自由度的位移与作用于其上的力联系起来，此时内部的影响已被“凝聚”掉。\n\n全局界面系统是通过组装所有子域的贡献而形成的。全局舒尔补 $S$ 是投射到全局界面自由度上的局部舒尔补之和。如果 $A^{(s)}$ 表示从全局界面向量到子域 $s$ 的局部界面向量的映射（或收集），那么它的转置 $A^{(s)T}$ 表示从局部到全局的散发（和求和）。全局算子为 $S = \\sum_s A^{(s)T} S^{(s)} A^{(s)}$。\n\n问题要求计算该全局算子在给定全局界面向量 $x_b$ 上的作用，即计算 $y_b = S x_b$，而无需显式地构建 $S$ 或局部的 $S^{(s)}$ 矩阵。计算过程如下：\n$$\ny_b = \\left( \\sum_s A^{(s)T} S^{(s)} A^{(s)} \\right) x_b = \\sum_s A^{(s)T} \\left( S^{(s)} (A^{(s)} x_b) \\right)\n$$\n令 $x_b^{(s)} = A^{(s)} x_b$ 为从 $x_b$ 收集的局部向量。核心任务是为每个子域计算局部乘积 $y_b^{(s)} = S^{(s)} x_b^{(s)}$，然后散发并相加结果：$y_b = \\sum_s A^{(s)T} y_b^{(s)}$。\n\n局部乘积 $y_b^{(s)} = S^{(s)} x_b^{(s)}$ 可以高效地计算如下：\n$$\ny_b^{(s)} = \\left( K_{bb}^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} K_{ib}^{(s)} \\right) x_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} \\left( (K_{ii}^{(s)})^{-1} (K_{ib}^{(s)} x_b^{(s)}) \\right)\n$$\n为了避免形成逆矩阵 $(K_{ii}^{(s)})^{-1}$，此计算分步进行：\n1.  计算内部问题的右端项：$v^{(s)} = K_{ib}^{(s)} x_b^{(s)}$。\n2.  为辅助向量 $u_i^{(s)}$ 求解局部内部系统：$K_{ii}^{(s)} u_i^{(s)} = v^{(s)}$。这就是“对内部自由度的局部求解”。\n3.  计算最终的局部贡献：$y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} u_i^{(s)}$。\n\n如果一个子域 $s$ 没有内部自由度（$n_i^{(s)} = 0$），则矩阵 $K_{ii}^{(s)}$、$K_{ib}^{(s)}$ 和 $K_{bi}^{(s)}$ 为空。涉及逆矩阵的舒尔补项消失，局部贡献简化为 $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)}$。\n\n总体算法如下：\n1.  初始化全局结果向量 $y_b$ 为零，长度为 $N_b$。\n2.  对每个子域 $s$：\n    a.  **收集**：使用映射 $\\phi^{(s)}$ 从全局向量 $x_b$ 中提取局部界面向量 $x_b^{(s)}$。\n    b.  **计算局部贡献**：\n        i. 如果 $n_i^{(s)} > 0$，通过执行上述局部求解来计算 $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)} - K_{bi}^{(s)} (K_{ii}^{(s)})^{-1} (K_{ib}^{(s)} x_b^{(s)})$。\n        ii. 如果 $n_i^{(s)} = 0$，计算 $y_b^{(s)} = K_{bb}^{(s)} x_b^{(s)}$。\n    c.  **散发**：使用映射 $\\phi^{(s)}$ 将局部结果 $y_b^{(s)}$ 的元素加到全局向量 $y_b$ 的相应位置。\n3.  最终的向量 $y_b$ 即为操作 $S x_b$ 的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_schur_operator(Nb, subdomains, xb):\n    \"\"\"\n    Computes the action of the Schur complement operator S on a vector xb.\n\n    This function computes yb = S @ xb without explicitly assembling S.\n    The computation is done subdomain by subdomain using gather-solve-scatter ops.\n\n    Args:\n        Nb (int): The total number of global interface DOFs.\n        subdomains (list): A list of dictionaries, each representing a subdomain's data.\n        xb (np.ndarray): The global interface vector.\n\n    Returns:\n        np.ndarray: The resulting global interface vector yb.\n    \"\"\"\n    yb = np.zeros(Nb, dtype=float)\n\n    for s_data in subdomains:\n        Kii = s_data['Kii']\n        Kib = s_data['Kib']\n        Kbi = s_data['Kbi']\n        Kbb = s_data['Kbb']\n        phi = s_data['phi']\n        ni_s = Kii.shape[0]\n\n        # 1. Gather operation: extract local interface vector from global vector\n        xb_s = xb[phi]\n\n        # 2. Compute local contribution yb_s = S_s * xb_s\n        if ni_s > 0:\n            # S_s = Kbb_s - Kbi_s * inv(Kii_s) * Kib_s\n            # We compute the product yb_s = S_s @ xb_s in steps:\n            # a. Compute intermediate vector v_s = Kib_s @ xb_s\n            v_s = Kib @ xb_s\n            # b. Solve the local interior system: Kii_s * u_i_s = v_s\n            u_i_s = np.linalg.solve(Kii, v_s)\n            # c. Compute local contribution: yb_s = Kbb_s @ xb_s - Kbi_s @ u_i_s\n            yb_s = Kbb @ xb_s - Kbi @ u_i_s\n        else:\n            # If no interior DOFs, S_s = Kbb_s\n            yb_s = Kbb @ xb_s\n        \n        # 3. Scatter operation: add local contribution back to global vector\n        # np.add.at is a vectorized way to perform this scatter-add operation.\n        np.add.at(yb, phi, yb_s)\n\n    return yb\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # Test Case A\n        {\n            \"Nb\": 1,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[4, 1], [1, 3]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[5]]),\n                    \"phi\": np.array([0]),\n                }\n            ],\n            \"xb\": np.array([1.5]),\n        },\n        # Test Case B\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                {\n                    \"Kii\": np.array([[3]]),\n                    \"Kib\": np.array([[1, -1]]),\n                    \"Kbi\": np.array([[1], [-1]]),\n                    \"Kbb\": np.array([[4, 0.5], [0.5, 2]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[6, 1], [1, 4]]),\n                    \"Kib\": np.array([[2, 0], [-1, 3]]),\n                    \"Kbi\": np.array([[2, -1], [0, 3]]),\n                    \"Kbb\": np.array([[3, -0.2], [-0.2, 5]]),\n                    \"phi\": np.array([1, 2]),\n                },\n            ],\n            \"xb\": np.array([1.0, -0.5, 2.0]),\n        },\n        # Test Case C\n        {\n            \"Nb\": 3,\n            \"subdomains\": [\n                { # Subdomain with no interior DOFs\n                    \"Kii\": np.empty((0, 0)),\n                    \"Kib\": np.empty((0, 2)),\n                    \"Kbi\": np.empty((2, 0)),\n                    \"Kbb\": np.array([[2, 0.3], [0.3, 1.5]]),\n                    \"phi\": np.array([0, 1]),\n                },\n                {\n                    \"Kii\": np.array([[2]]),\n                    \"Kib\": np.array([[-1, 0.5]]),\n                    \"Kbi\": np.array([[-1], [0.5]]),\n                    \"Kbb\": np.array([[1, 0.1], [0.1, 2]]),\n                    \"phi\": np.array([1, 2]),\n                },\n                {\n                    \"Kii\": np.array([[7, 0], [0, 8]]),\n                    \"Kib\": np.array([[1], [2]]),\n                    \"Kbi\": np.array([[1, 2]]),\n                    \"Kbb\": np.array([[4]]),\n                    \"phi\": np.array([2]),\n                },\n            ],\n            \"xb\": np.array([0.2, -1.2, 0.7]),\n        },\n    ]\n\n    results_str = []\n    for case in test_cases:\n        Nb = case[\"Nb\"]\n        subdomains = case[\"subdomains\"]\n        xb = case[\"xb\"]\n        \n        yb = apply_schur_operator(Nb, subdomains, xb)\n        \n        # Format the result vector as a string list with 6 decimal places\n        formatted_yb = [f\"{val:.6f}\" for val in yb]\n        results_str.append(f\"[{','.join(formatted_yb)}]\")\n\n    # Print the final output in the required format: [[...],[...],...]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3565877"}, {"introduction": "如果我们修改模型的某一部分，解会如何变化？最后一个实践 [@problem_id:3565864] 以极高的效率解决了这个“情景分析”问题。您将使用 Sherman-Morrison-Woodbury 恒等式，针对内部刚度的低秩变化快速更新凝聚系统，从而避免了昂贵的重复求逆计算，并为强大的灵敏度分析提供了可能。", "problem": "考虑一个有限元土-结构相互作用子结构，其中全局刚度矩阵被划分为边界自由度和内部土体自由度。假设在不考虑惯性的情况下，平衡由线性系统 $K u = f$ 控制，其中 $K$ 是对称正定 (SPD) 刚度矩阵，$u$ 是位移向量，$f$ 是力向量。使用子结构法，将变量划分为 $u = \\begin{bmatrix} u_b \\\\ u_i \\end{bmatrix}$ 和 $f = \\begin{bmatrix} f_b \\\\ f_i \\end{bmatrix}$，并将刚度矩阵划分为\n$$\nK = \\begin{bmatrix}\nK_{bb} & K_{bi} \\\\\nK_{ib} & K_{ii}\n\\end{bmatrix}.\n$$\n静力凝聚消除了内部土体自由度，从而得到一个仅包含边界自由度的简化系统。你需要从第一性原理出发推导这个简化过程，然后实现一个程序，当内部土体刚度 $K_{ii}$ 受到低秩变化 $\\delta K_{ii}$ 的扰动时，对边界位移向量 $u_b$ 进行快速的“情景假设”分析。\n\n你的推导必须基于以下基本事实：\n- 有限元方法中的线性弹性平衡：$K u = f$。\n- 分块线性系统的性质和内部变量的消元。\n- Sherman–Morrison–Woodbury 恒等式 (SMW)，首次出现时定义如下：Sherman–Morrison–Woodbury (SMW) 恒等式指出，对于可逆矩阵 $A$ 和尺寸合适的矩阵 $U$、$C$ 和 $V$，有 $ (A + UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1} + VA^{-1}U)^{-1}VA^{-1} $。\n\n你不能直接使用或引用目标凝聚公式；必须从 $K u = f$ 出发，通过推理得到凝聚系统。然后，使用 SMW 在低秩变化下高效地更新内部刚度块 $K_{ii}$ 的逆，并因此更新凝聚刚度和凝聚的右侧项，而无需从头重新计算任何完整的逆矩阵。\n\n假设使用以下具体矩阵（单位：刚度条目以千牛顿/米 ($\\mathrm{kN/m}$) 为单位）：\n$$\nK_{bb} = \\begin{bmatrix}\n1000 & -200 \\\\\n-200 & 800\n\\end{bmatrix},\\quad\nK_{bi} = \\begin{bmatrix}\n-150 & 100 & 0 \\\\\n50 & -120 & 80\n\\end{bmatrix},\\quad\nK_{ib} = K_{bi}^\\top,\n$$\n$$\nK_{ii} = \\begin{bmatrix}\n3000 & -500 & 0 \\\\\n-500 & 2000 & -400 \\\\\n0 & -400 & 1500\n\\end{bmatrix}.\n$$\n\n你将分析四种“情景假设”案例，每种案例都由对内部刚度的低秩更新 $\\delta K_{ii} = U C U^\\top$ 以及指定的边界和内力来表征。在每种情况下，计算由凝聚系统产生的边界位移向量 $u_b$。将每个位移分量以米 ($\\mathrm{m}$) 为单位表示，并四舍五入到六位小数。\n\n测试套件如下：\n- 案例 1（基线，理想路径）：$\\delta K_{ii} = 0$，$f_b = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$（单位 $\\mathrm{kN}$），$f_i = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$（单位 $\\mathrm{kN}$）。\n- 案例 2（秩-1 正更新）：$U = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$，$C = \\begin{bmatrix} 200 \\end{bmatrix}$（单位 $\\mathrm{kN/m}$），因此 $\\delta K_{ii} = 200 \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}$，$f_b = \\begin{bmatrix} 10 \\\\ -5 \\end{bmatrix}$（单位 $\\mathrm{kN}$），$f_i = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$（单位 $\\mathrm{kN}$）。\n- 案例 3（带内力的秩-2 混合更新）：$U = \\begin{bmatrix} 0 & 0 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$，$C = \\begin{bmatrix} 100 & 0 \\\\ 0 & -50 \\end{bmatrix}$（单位 $\\mathrm{kN/m}$），$f_b = \\begin{bmatrix} 12 \\\\ 8 \\end{bmatrix}$（单位 $\\mathrm{kN}$），$f_i = \\begin{bmatrix} 5 \\\\ -10 \\\\ 15 \\end{bmatrix}$（单位 $\\mathrm{kN}$）。\n- 案例 4（边界情况：边界载荷为零，秩-1 各向同性方向）：$U = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$，$C = \\begin{bmatrix} 300 \\end{bmatrix}$（单位 $\\mathrm{kN/m}$），$f_b = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$（单位 $\\mathrm{kN}$），$f_i = \\begin{bmatrix} 20 \\\\ -5 \\\\ 10 \\end{bmatrix}$（单位 $\\mathrm{kN}$）。\n\n实现要求：\n- 计算一次基线逆矩阵 $K_{ii}^{-1}$。\n- 对于每种情况，使用 Sherman–Morrison–Woodbury 恒等式来获得 $(K_{ii} + \\delta K_{ii})^{-1}$，而无需从头重新计算完整的逆矩阵。\n- 构建凝聚刚度 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$，以及更新下的 $S' = K_{bb} - K_{bi} (K_{ii} + \\delta K_{ii})^{-1} K_{ib}$。\n- 构建凝聚力 $g = f_b - K_{bi} K_{ii}^{-1} f_i$，以及更新下的 $g' = f_b - K_{bi} (K_{ii} + \\delta K_{ii})^{-1} f_i$。\n- 在每种情况下求解 $S' u_b = g'$ 以得到 $u_b$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其分量按案例排序，然后按边界自由度排序。具体来说，输出 $[u_{b,1}^{(1)},u_{b,2}^{(1)},u_{b,1}^{(2)},u_{b,2}^{(2)},u_{b,1}^{(3)},u_{b,2}^{(3)},u_{b,1}^{(4)},u_{b,2}^{(4)}]$，其中每个 $u_{b,j}^{(c)}$ 以米为单位，并四舍五入到六位小数。", "solution": "用户提供了一个关于计算岩土力学中子结构、静力凝聚以及凝聚系统高效更新的有效问题陈述。该问题具有科学依据，提法明确且客观。推导和实现将按要求进行。\n\n出发点是控制有限元模型中静力平衡的线性方程组：\n$$\nK u = f\n$$\n其中 $K$ 是全局刚度矩阵，$u$ 是节点位移向量，$f$ 是节点力向量。矩阵 $K$ 是对称正定 (SPD) 的。\n\n我们将自由度 (DOFs) 划分为边界自由度（用下标 $b$ 表示）和内部自由度（用下标 $i$ 表示）。这在矩阵 $K$ 以及向量 $u$ 和 $f$ 中引入了分块结构：\n$$\n\\begin{bmatrix}\nK_{bb} & K_{bi} \\\\\nK_{ib} & K_{ii}\n\\end{bmatrix}\n\\begin{bmatrix}\nu_b \\\\\nu_i\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_b \\\\\nf_i\n\\end{bmatrix}\n$$\n在这里，$K_{bb}$ 表示边界自由度之间的刚度耦合，$K_{ii}$ 表示内部自由度之间的刚度耦合，而 $K_{bi}$（由于对称性，其转置为 $K_{ib} = K_{bi}^\\top$）表示边界和内部自由度之间的耦合。\n\n这个分块矩阵方程可以展开为两个耦合的向量方程：\n$$\n(1) \\quad K_{bb} u_b + K_{bi} u_i = f_b\n$$\n$$\n(2) \\quad K_{ib} u_b + K_{ii} u_i = f_i\n$$\n静力凝聚的过程旨在消除内部自由度 $u_i$，以获得一个仅关于边界自由度 $u_b$ 的更小的系统。我们通过首先求解方程 (2) 来得到 $u_i$ 来实现这一点。由于 $K$ 是对称正定的，其主子矩阵 $K_{ii}$ 也是对称正定的，因此是可逆的。\n$$\nK_{ii} u_i = f_i - K_{ib} u_b\n$$\n$$\nu_i = K_{ii}^{-1} (f_i - K_{ib} u_b)\n$$\n该表达式给出了内部位移 $u_i$ 关于边界位移 $u_b$和施加载荷的表示。\n\n接下来，我们将这个 $u_i$ 的表达式代入方程 (1)：\n$$\nK_{bb} u_b + K_{bi} \\left( K_{ii}^{-1} (f_i - K_{ib} u_b) \\right) = f_b\n$$\n我们分配 $K_{bi}$ 并将包含 $u_b$ 的项组合在左侧，并将所有其他项（等效力）组合在右侧：\n$$\nK_{bb} u_b - K_{bi} K_{ii}^{-1} K_{ib} u_b = f_b - K_{bi} K_{ii}^{-1} f_i\n$$\n将 $u_b$ 提取出来，得到凝聚方程组：\n$$\n\\left( K_{bb} - K_{bi} K_{ii}^{-1} K_{ib} \\right) u_b = f_b - K_{bi} K_{ii}^{-1} f_i\n$$\n这就是所求的简化系统，可以写成 $S u_b = g$ 的形式，其中：\n- 凝聚刚度矩阵，或称 $K_{ii}$ 在 $K$ 中的舒尔补 (Schur complement)，是 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$。\n- 凝聚力向量是 $g = f_b - K_{bi} K_{ii}^{-1} f_i$。\n\n现在，我们考虑一个“情景假设”场景，其中内部刚度矩阵 $K_{ii}$ 受到低秩更新 $\\delta K_{ii} = U C U^\\top$ 的扰动，其中 $U$ 的维度是 $n_i \\times r$，$C$ 是一个 $r \\times r$ 的可逆矩阵，且 $r$ 很小。新的内部刚度是 $K'_{ii} = K_{ii} + \\delta K_{ii} = K_{ii} + U C U^\\top$。\n\n新的凝聚系统变为 $S' u_b = g'$，其中：\n$$\nS' = K_{bb} - K_{bi} (K'_{ii})^{-1} K_{ib}\n$$\n$$\ng' = f_b - K_{bi} (K'_{ii})^{-1} f_i\n$$\n对每个情景假设都直接对 $K'_{ii}$ 求逆在计算上是昂贵的。取而代之，我们使用 Sherman–Morrison–Woodbury (SMW) 恒等式，它指出对于一个可逆矩阵 $A$ 和尺寸合适的矩阵 $U$、$C$ 和 $V$：$(A + U C V)^{-1} = A^{-1} - A^{-1} U (C^{-1} + V A^{-1} U)^{-1} V A^{-1}$。\n\n我们应用这个恒等式来计算 $(K'_{ii})^{-1} = (K_{ii} + U C U^\\top)^{-1}$，其中 $A=K_{ii}$ 且 $V=U^\\top$：\n$$\n(K'_{ii})^{-1} = K_{ii}^{-1} - K_{ii}^{-1} U \\left(C^{-1} + U^\\top K_{ii}^{-1} U \\right)^{-1} U^\\top K_{ii}^{-1}\n$$\n关键优势在于待求逆的矩阵 $M = C^{-1} + U^\\top K_{ii}^{-1} U$ 的尺寸是 $r \\times r$，远小于 $K_{ii}$ 的尺寸。这使得逆矩阵的更新可以快速进行。\n\n每个情景假设分析的算法如下：\n1.  计算一次基线内部刚度矩阵的逆 $K_{ii}^{-1}$。\n2.  对于每种情况，定义更新矩阵 $U$ 和 $C$，以及力向量 $f_b$ 和 $f_i$。\n3.  如果存在非零更新 ($\\delta K_{ii} \\neq 0$)，则使用 SMW 公式计算扰动后的逆矩阵 $(K'_{ii})^{-1}$。这包括：\n    a. 计算小矩阵 $M = C^{-1} + U^\\top K_{ii}^{-1} U$。\n    b. 对 $M$ 求逆得到 $M^{-1}$。\n    c. 组合更新后的逆矩阵 $(K'_{ii})^{-1} = K_{ii}^{-1} - (K_{ii}^{-1} U) M^{-1} (U^\\top K_{ii}^{-1})$。\n4.  如果没有更新，则设置 $(K'_{ii})^{-1} = K_{ii}^{-1}$。\n5.  构建扰动后的凝聚刚度矩阵 $S' = K_{bb} - K_{bi} (K'_{ii})^{-1} K_{ib}$。\n6.  构建扰动后的凝聚力向量 $g' = f_b - K_{bi} (K'_{ii})^{-1} f_i$。\n7.  求解这个小的 $2 \\times 2$ 线性系统 $S' u_b = g'$ 以得到边界位移向量 $u_b$。\n8.  由于刚度单位为 $\\mathrm{kN/m}$，力单位为 $\\mathrm{kN}$，因此得到的位移单位为米。这些值将被四舍五入到六位小数作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sub-structuring and static condensation problem for four \"what-if\" cases.\n    The solution involves deriving the condensed system, updating it with the\n    Sherman-Morrison-Woodbury identity for low-rank perturbations, and solving for\n    boundary displacements.\n    \"\"\"\n\n    # --- Step 1: Define baseline matrices from the problem statement ---\n    # Units: stiffness entries in kN/m\n    K_bb = np.array([\n        [1000, -200],\n        [-200, 800]\n    ])\n    K_bi = np.array([\n        [-150, 100, 0],\n        [50, -120, 80]\n    ])\n    K_ib = K_bi.T\n    K_ii = np.array([\n        [3000, -500, 0],\n        [-500, 2000, -400],\n        [0, -400, 1500]\n    ])\n\n    # --- Step 2: Define the test suite for the four cases ---\n    # Units: forces in kN, stiffness update in kN/m\n    test_cases = [\n        # Case 1: baseline, happy path\n        {\n            \"U\": None,\n            \"C\": None,\n            \"f_b\": np.array([10, -5]),\n            \"f_i\": np.array([0, 0, 0])\n        },\n        # Case 2: rank-1 positive update\n        {\n            \"U\": np.array([[1], [0], [0]]),\n            \"C\": np.array([[200]]),\n            \"f_b\": np.array([10, -5]),\n            \"f_i\": np.array([0, 0, 0])\n        },\n        # Case 3: rank-2 mixed update with internal loads\n        {\n            \"U\": np.array([[0, 0], [1, 0], [0, 1]]),\n            \"C\": np.array([[100, 0], [0, -50]]),\n            \"f_b\": np.array([12, 8]),\n            \"f_i\": np.array([5, -10, 15])\n        },\n        # Case 4: zero boundary loads, rank-1 isotropic direction\n        {\n            \"U\": np.array([[1], [1], [1]]),\n            \"C\": np.array([[300]]),\n            \"f_b\": np.array([0, 0]),\n            \"f_i\": np.array([20, -5, 10])\n        }\n    ]\n\n    # --- Step 3: Perform calculations ---\n\n    # Compute the baseline inverse of K_ii once.\n    K_ii_inv = np.linalg.inv(K_ii)\n\n    results = []\n    for case in test_cases:\n        U = case[\"U\"]\n        C = case[\"C\"]\n        f_b = case[\"f_b\"]\n        f_i = case[\"f_i\"]\n\n        K_ii_p_inv = None # Perturbed inverse\n        \n        # Check if there is an update\n        if U is None or C is None:\n            # Case 1: No update, use baseline inverse\n            K_ii_p_inv = K_ii_inv\n        else:\n            # Cases 2, 3, 4: Update K_ii_inv using Sherman-Morrison-Woodbury\n            # (K_ii + UCU^T)^-1 = K_ii^-1 - K_ii^-1 U (C^-1 + U^T K_ii^-1 U)^-1 U^T K_ii^-1\n            C_inv = np.linalg.inv(C)\n            M = C_inv + U.T @ K_ii_inv @ U\n            M_inv = np.linalg.inv(M)\n            \n            # Efficiently calculate update term\n            Kii_inv_U = K_ii_inv @ U\n            update_term = Kii_inv_U @ M_inv @ Kii_inv_U.T\n            \n            K_ii_p_inv = K_ii_inv - update_term\n\n        # Form the condensed stiffness matrix S'\n        S_prime = K_bb - K_bi @ K_ii_p_inv @ K_ib\n\n        # Form the condensed force vector g'\n        g_prime = f_b - K_bi @ K_ii_p_inv @ f_i\n\n        # Solve the condensed system S' * u_b = g' for boundary displacements u_b\n        u_b = np.linalg.solve(S_prime, g_prime)\n\n        # Append results, rounded to six decimal places, to the list\n        results.extend(u_b)\n\n    # Format the final output string as required\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3565864"}]}