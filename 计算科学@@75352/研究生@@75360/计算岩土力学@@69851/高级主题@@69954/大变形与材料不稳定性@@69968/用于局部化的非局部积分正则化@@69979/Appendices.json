{"hands_on_practices": [{"introduction": "理论知识的真正掌握始于实践。本节的第一个动手实践将引导您将连续的非局部积分方程转化为计算机可以执行的离散算法。通过完成这个练习 [@problem_id:3546153]，您将亲手实现核心的非局部平均算子，并直观地观察其基本的平滑效应和边界效应，为后续更复杂的分析奠定坚实的数值基础。", "problem": "考虑一个用于计算岩土力学中的一维连续介质模型，该模型通过非局部积分平均来正则化应变局部化。在应变软化材料中，纯局部本构律可能导致不适定边值问题，其中无穷小扰动会在趋近于零的小区域内产生无界的局部化。一种常见的修正是非局部积分正则化：将局部驱动变量（例如，等效应变）替换为其在有限邻域内由核函数加权的积分平均值。从线性动量守恒和标准小应变运动学出发，通过引入一个进入软化律的非局部等效应变来增广本构律。非局部等效应变场 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义为\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\mathrm{d}\\xi},\n$$\n其中 $\\Omega$ 是域，$\\varepsilon_{\\mathrm{eq}}(\\xi)$ 是局部等效应变，$\\alpha(r)$ 是一个正的衰减核函数，它引入了一个内禀长度尺度并用于正则化该问题。您将为一维杆实现该非局部算子的数值离散化。\n\n假设一根一维杆占据区间 $[0,L]$，其长度 $L$ 以米为单位。将该域离散为 $N$ 个等距节点 $\\{x_i\\}_{i=1}^N$，间距为 $h = L/(N-1)$。设核函数为指数函数\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right),\n$$\n其中 $\\ell$ 是以内米为单位的内禀长度尺度。使用复合梯形法则来近似积分，即，使用求积权重 $w_1 = w_N = h/2$ 以及对于 $i=2,\\dots,N-1$ 使用 $w_i = h$。节点 $x_j$ 处的离散非局部平均值为\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}.\n$$\n\n实现一个完整、可运行的程序，该程序：\n- 为给定的 $L$（单位：米）和 $N$ 构建节点 $\\{x_i\\}$ 和梯形权重 $\\{w_i\\}$。\n- 对于给定的内禀长度 $\\ell$（单位：米），根据指定的局部等效应变场 $\\varepsilon_{\\mathrm{eq}}(x)$ 计算所有节点上的离散非局部平均值 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j)$。\n- 使用指定的指数核函数。\n- 为以下测试用例集生成结果。所有应变都是无量纲的。所有长度和内禀长度 $\\ell$ 的单位都是米。\n\n测试用例 A（均匀不变性）：\n- 参数：$L = 1$，$N = 101$，$\\ell = 0.05$。\n- 局部场：对于所有 $x \\in [0,1]$，$\\varepsilon_{\\mathrm{eq}}(x) = 0.01$。\n- 要求输出：最大绝对偏差 $\\max_j \\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) - 0.01 \\rvert$，以浮点数形式输出。\n\n测试用例 B（局部顶帽函数，中心值）：\n- 参数：$L = 1$，$N = 1001$，$\\ell = 0.1$。\n- 局部场：对于 $x \\in [0.4, 0.6]$，$\\varepsilon_{\\mathrm{eq}}(x) = 0.02$，否则 $\\varepsilon_{\\mathrm{eq}}(x) = 0$。\n- 要求输出：$x_c = 0.5$ 处 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_c)$ 的值，以浮点数形式输出。\n\n测试用例 C（大内禀长度，趋近均值）：\n- 参数：$L = 1$，$N = 1001$，$\\ell = 1.0$。\n- 局部场：与测试用例 B 相同。\n- 大 $\\ell$ 时的理论平均值：$\\varepsilon_{\\mathrm{mean}} = 0.02 \\times \\dfrac{0.6 - 0.4}{1} = 0.004$。\n- 要求输出：绝对差 $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.004 \\rvert$，以浮点数形式输出。\n\n测试用例 D（中心点的近局部极限）：\n- 参数：$L = 1$，$N = 1001$，$\\ell = h = L/(N-1)$。\n- 局部场：与测试用例 B 相同。\n- 要求输出：绝对差 $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.02 \\rvert$，以浮点数形式输出。\n\n测试用例 E（梯度的边界效应）：\n- 参数：$L = 1$，$N = 201$，$\\ell = 0.1$。\n- 局部场：对于所有 $x \\in [0,1]$，$\\varepsilon_{\\mathrm{eq}}(x) = x/L$。\n- 要求输出：左边界处 $\\bar{\\varepsilon}_{\\mathrm{eq}}(0)$ 的值，以浮点数形式输出。\n\n您的程序应生成单行输出，其中包含测试用例 A 到 E 的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如 $[r_A,r_B,r_C,r_D,r_E]$）。输出的数字不附带单位，因为所有输出都是无量纲的。程序不得读取任何外部输入。\n\n实现必须在科学上保持一致且在数值上稳健。离散化必须遵循所述的梯形求积法，非局部平均必须使用带有内禀长度尺度的指数核函数。通过离散公式中的分母仔细管理边界归一化，以避免在域边界附近产生人为偏差。", "solution": "该问题要求实现一种数值算法来计算非局部积分平均，这是一种在计算岩土力学中用于正则化材料应变局部化数学模型的技术。解决方案将通过离散化控制积分方程并将其应用于一系列定义明确的测试用例来构建。\n\n连续一维非局部等效应变 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义为局部等效应变场 $\\varepsilon_{\\mathrm{eq}}(\\xi)$ 在域 $\\Omega = [0, L]$ 上的加权平均：\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\mathrm{d}\\xi}\n$$\n核函数 $\\alpha(r)$ 由指数衰减模型给出：\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right)\n$$\n其中 $r = \\lvert x-\\xi\\rvert$ 是距离，$\\ell$ 是特征内禀长度尺度。$\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义中的分母确保权重之和为一，这在积分被截断的域边界附近尤其重要。\n\n为了数值求解此问题，我们首先将域 $\\Omega = [0, L]$ 离散为一组 $N$ 个等距节点 $\\{x_i\\}_{i=1}^N$。节点位于 $x_i = (i-1)h$ 处，其中 $i = 1, \\dots, N$，$h = L/(N-1)$ 是恒定的网格间距。\n\n我们使用复合梯形法则来近似 $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ 定义中的积分。函数 $f(\\xi)$ 在 $[0, L]$ 上的积分近似为：\n$$\n\\int_0^L f(\\xi) \\, \\mathrm{d}\\xi \\approx \\sum_{i=1}^N f(x_i) w_i\n$$\n梯形法则的求积权重 $\\{w_i\\}$ 为 $w_1 = w_N = h/2$ 以及对于所有内部节点 $i=2, \\dots, N-1$ 有 $w_i = h$。\n\n将此数值求积应用于特定节点 $x_j$ 处的非局部平均公式，得到离散近似：\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}\n$$\n必须对每个节点 $j=1, \\dots, N$ 计算此表达式。\n\n为提高计算效率，实现将进行向量化。设 $\\mathbf{x}$ 为节点坐标的列向量，$\\mathbf{w}$ 为梯形权重的向量，$\\boldsymbol{\\varepsilon}_{\\mathrm{eq}}$ 为节点上局部应变值的向量。计算的核心是构建一个大小为 $N \\times N$ 的核矩阵 $\\mathbf{A}$，其中每个元素 $A_{ji}$ 由下式给出：\n$$\nA_{ji} = \\alpha(\\lvert x_j - x_i \\rvert) = \\exp\\left(-\\frac{\\lvert x_j - x_i \\rvert}{\\ell}\\right)\n$$\n然后，非局部等效应变向量 $\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}}$ 按如下方式计算：\n1.  定义节点向量 $\\mathbf{x} = [x_1, \\dots, x_N]^T$。\n2.  定义权重向量 $\\mathbf{w} = [w_1, \\dots, w_N]^T$。\n3.  在节点处评估局部应变场，得到 $\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} = [\\varepsilon_{\\mathrm{eq}}(x_1), \\dots, \\varepsilon_{\\mathrm{eq}}(x_N)]^T$。\n4.  构建距离矩阵 $\\mathbf{D}$，其元素为 $D_{ji} = \\lvert x_j - x_i \\rvert$。\n5.  构建核矩阵 $\\mathbf{A} = \\exp(-\\mathbf{D}/\\ell)$。\n6.  计算分子向量 $\\mathbf{n} = \\mathbf{A} (\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} \\odot \\mathbf{w})$，其中 $\\odot$ 表示逐元素（哈达玛）积。这对应于每个 $j$ 的分子中的求和。\n7.  计算分母向量 $\\mathbf{d} = \\mathbf{A} \\mathbf{w}$。这对应于每个 $j$ 的分母中的求和。\n8.  最终结果通过逐元素除法获得：$\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}} = \\mathbf{n} \\oslash \\mathbf{d}$。\n\n此过程应用于每个指定的测试用例。\n-   **测试用例 A** 验证了非局部算子应保持常数场不变的基本性质。与常数值的偏差应在机器精度的量级。\n-   **测试用例 B** 展示了非局部算子的主要功能：平滑尖锐的不连续性（顶帽函数）。由于与周围的零应变区域进行平均，顶帽函数中心的值将小于局部峰值。\n-   **测试用例 C** 检验了内禀长度 $\\ell$ 远大于域尺寸 $L$ 的极限情况。在此极限下，指数核函数 $\\alpha(r)$ 在整个域上变得近似恒定，非局部平均值应收敛到局部场的简单空间平均值，计算公式为 $\\varepsilon_{\\mathrm{mean}} = \\frac{1}{L}\\int_0^L \\varepsilon_{\\mathrm{eq}}(x) \\mathrm{d}x$。\n-   **测试用例 D** 检验了相反的极限情况，即内禀长度 $\\ell$ 很小，在网格间距 $h$ 的量级。此时核函数变得高度尖锐，近似于狄拉克δ函数，非局部值应收敛到局部值。\n-   **测试用例 E** 旨在探究边界效应。对于靠近边界的点 $x_j$（例如 $x_1=0$），积分被截断。对于像线性梯度 $\\varepsilon_{\\mathrm{eq}}(x) = x/L$ 这样的非常数场，这种截断将导致非局部平均值与局部值显著不同。特别是在 $x=0$ 处，平均值仅包含来自 $\\xi \\ge 0$ 的贡献，因此即使局部应变为 $\\varepsilon_{\\mathrm{eq}}(0)=0$，也会得到一个正值。\n\n该算法使用 NumPy 库在一个 Python 脚本中实现，以进行高效的数组操作，遵循了上面概述的向量化策略。每个测试用例都按顺序执行，并收集结果，然后按指定格式进行格式化。", "answer": "```python\nimport numpy as np\n\ndef compute_nonlocal_average(L, N, ell, local_eps_func):\n    \"\"\"\n    Computes the discrete nonlocal average for a 1D bar.\n\n    Args:\n        L (float): Length of the bar.\n        N (int): Number of discretization nodes.\n        ell (float): Internal length scale.\n        local_eps_func (callable): A function that takes a numpy array of node\n                                   positions `x` and returns the local strain field.\n\n    Returns:\n        tuple: A tuple containing:\n            - x_nodes (np.ndarray): The positions of the domain nodes.\n            - eps_nonlocal (np.ndarray): The computed nonlocal equivalent strain at each node.\n    \"\"\"\n    # 1. Discretize the domain and define grid spacing\n    x_nodes = np.linspace(0, L, N)\n    if N > 1:\n        h = L / (N - 1)\n    else:\n        h = 0.0 # Handle case N=1\n\n    # 2. Define trapezoidal integration weights\n    w_weights = np.full(N, h)\n    if N > 1:\n        w_weights[0] = h / 2.0\n        w_weights[-1] = h / 2.0\n\n    # 3. Evaluate the local strain field at the nodes\n    eps_local = local_eps_func(x_nodes)\n\n    # 4. Construct the kernel matrix from distances\n    # Use broadcasting to create the distance matrix |x_j - x_i| for all j, i\n    dist_matrix = np.abs(x_nodes[:, np.newaxis] - x_nodes)\n    alpha_matrix = np.exp(-dist_matrix / ell)\n\n    # 5. Compute the nonlocal average using vectorized operations\n    # Numerator: sum_i(alpha_ji * eps_i * w_i) for each j\n    numerator = alpha_matrix @ (eps_local * w_weights)\n    \n    # Denominator: sum_i(alpha_ji * w_i) for each j\n    denominator = alpha_matrix @ w_weights\n\n    # Element-wise division to get the nonlocal strain at each node\n    # Add a small epsilon to the denominator to prevent division by zero in pathological cases,\n    # though not strictly necessary for an exponential kernel over a non-zero domain.\n    eps_nonlocal = numerator / (denominator + 1e-18)\n    \n    return x_nodes, eps_nonlocal\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the results in the required format.\n    \"\"\"\n    results = []\n\n    # Test Case A: Uniform invariance\n    L_A, N_A, ell_A = 1.0, 101, 0.05\n    local_eps_A = lambda x: np.full_like(x, 0.01)\n    _, eps_nonlocal_A = compute_nonlocal_average(L_A, N_A, ell_A, local_eps_A)\n    result_A = np.max(np.abs(eps_nonlocal_A - 0.01))\n    results.append(result_A)\n\n    # Test Case B: Localized top-hat, center value\n    L_B, N_B, ell_B = 1.0, 1001, 0.1\n    # Use a small tolerance for floating point comparisons at boundaries\n    local_eps_B = lambda x: 0.02 * ((x >= 0.4 - 1e-9)  (x = 0.6 + 1e-9))\n    x_nodes_B, eps_nonlocal_B = compute_nonlocal_average(L_B, N_B, ell_B, local_eps_B)\n    center_index_B = (N_B - 1) // 2 # N is odd, index corresponds to x=0.5\n    result_B = eps_nonlocal_B[center_index_B]\n    results.append(result_B)\n\n    # Test Case C: Large internal length, approach to mean\n    L_C, N_C, ell_C = 1.0, 1001, 1.0\n    local_eps_C = local_eps_B  # Same local field as B\n    x_nodes_C, eps_nonlocal_C = compute_nonlocal_average(L_C, N_C, ell_C, local_eps_C)\n    center_index_C = (N_C - 1) // 2\n    theoretical_mean = 0.004\n    result_C = np.abs(eps_nonlocal_C[center_index_C] - theoretical_mean)\n    results.append(result_C)\n\n    # Test Case D: Near-local limit at center\n    L_D, N_D = 1.0, 1001\n    h_D = L_D / (N_D - 1)\n    ell_D = h_D\n    local_eps_D = local_eps_B  # Same local field as B\n    x_nodes_D, eps_nonlocal_D = compute_nonlocal_average(L_D, N_D, ell_D, local_eps_D)\n    center_index_D = (N_D - 1) // 2\n    local_center_value_D = 0.02\n    result_D = np.abs(eps_nonlocal_D[center_index_D] - local_center_value_D)\n    results.append(result_D)\n\n    # Test Case E: Boundary effect for a gradient\n    L_E, N_E, ell_E = 1.0, 201, 0.1\n    local_eps_E = lambda x: x / L_E\n    x_nodes_E, eps_nonlocal_E = compute_nonlocal_average(L_E, N_E, ell_E, local_eps_E)\n    result_E = eps_nonlocal_E[0]  # Value at the left boundary, x=0\n    results.append(result_E)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3546153"}, {"introduction": "在实现任何数值模型之后，验证其正确性是至关重要的一步。这个实践 [@problem_id:3546150] 聚焦于收敛性分析，这是一个确保我们计算工具可靠性的核心环节。您将通过系统地细化计算网格，检验数值解是否如预期般逼近精确解，从而深入理解数值离散误差的来源和控制方法。", "problem": "考虑一个占据区间 $\\Omega = [0,L]$ 的一维杆，其中 $L  0$ 的单位为米。设等效应变场为一个局部化的、非均匀的确定性函数 $\\varepsilon(\\xi)$，对于 $\\xi \\in \\Omega$ 定义为\n$$\n\\varepsilon(\\xi) = \\varepsilon_0 \\exp\\!\\left(-\\frac{|\\xi - x_0|}{\\beta}\\right),\n$$\n其中 $\\varepsilon_0  0$ 是一个无量纲的峰值应变，$x_0 \\in (0,L)$ 是局部化带的中心（单位为米），$\\beta  0$ 是一个局部化宽度（单位为米）。为了在计算岩土力学中对应变局部化进行正则化，在点 $x \\in \\Omega$ 处的非局部积分平均 $\\bar{\\varepsilon}(x)$ 定义为截断的、重整化的卷积\n$$\n\\bar{\\varepsilon}(x) = \\frac{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,\\varepsilon(\\xi)\\,d\\xi}{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,d\\xi},\n$$\n其中 $\\alpha(x,\\xi)$ 是一个非负权重函数（核函数），分母在截断域上强制执行精确归一化。使用特征长度为 $\\ell  0$ 的高斯核函数，\n$$\n\\alpha(x,\\xi) = \\exp\\!\\left(-\\frac{(x-\\xi)^2}{2\\ell^2}\\right),\n$$\n其中 $\\ell$ 的单位为米。应变 $\\varepsilon(\\xi)$ 是无量纲的，因此 $\\bar{\\varepsilon}(x)$ 也是无量纲的。\n\n你的任务是研究离散非局部算子在网格细化下的收敛性，该算子基于由 $N$ 个等长单元（其中 $N \\in \\mathbb{N}$）构成的一维网格，通过均匀 Riemann 和来近似上述积分。具体而言，在一个网格间距为 $h = L/N$、单元中心为 $\\xi_i = (i+\\tfrac{1}{2})h$（$i = 0,1,\\dots,N-1$）的网格上定义离散近似：\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)\\,h}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,h}.\n$$\n将上述公式视为同时应用于分子和分母的复合中点法则。对于同一计算点 $x$ 的一个参考（基准）值，使用相同的离散公式和一个由 $N_{\\mathrm{ref}}$ 个单元组成的非常精细的网格来计算 $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$。定义绝对离散误差\n$$\ne_N(x) = \\big|\\bar{\\varepsilon}_N(x) - \\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)\\big|.\n$$\n\n从非局部平均和数值积分（Riemann 和）的核心定义出发，实现一个程序，对下述每个测试用例，使用指定的参数计算绝对误差 $e_N(x)$。所有应变都是无量纲的，因此 $e_N(x)$ 必须报告为一个无量纲的小数。\n\n对所有测试用例使用以下固定参数：\n- $L = 1.0$ 米，\n- $\\varepsilon_0 = 0.02$，\n- $x_0 = 0.5$ 米，\n- $\\beta = 0.01$ 米，\n- $N_{\\mathrm{ref}} = 100000$。\n\n测试套件由以下六个用例组成，每个用例以元组 $(\\ell, N, x)$ 的形式给出，其中 $\\ell$ 的单位为米， $N$ 为单元数量的整数， $x$ 的单位为米：\n1. $(0.05, 20, 0.5)$ 中等核函数和粗糙网格下的内部点计算，\n2. $(0.05, 40, 0.5)$ 中等核函数和加密网格下的内部点计算，\n3. $(0.05, 20, 0.02)$ 靠近边界的计算以测试重整化，\n4. $(0.005, 20, 0.5)$ 网格无法很好解析的小特征长度，\n5. $(0.005, 400, 0.5)$ 通过网格加密可以很好解析的小特征长度，\n6. $(0.05, 40, 0.8)$ 远离局部化中心的计算。\n\n你的程序必须：\n- 如上所述实现非局部平均，对具有 $N$ 个单元的粗糙网格和具有 $N_{\\mathrm{ref}}$ 个单元的参考网格，均在均匀分区上使用复合中点法则，\n- 为每个测试用例计算 $e_N(x)$，\n- 生成单行输出，其中包含按上述测试用例顺序排列的六个结果，格式为方括号括起来的逗号分隔列表。每个结果必须是一个小数（浮点数）。例如，一个有效的输出格式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$。\n\n不涉及角度。由于应变是无量纲的，且误差 $e_N(x)$ 也是无量纲的，因此最终的数值输出中不出现物理单位。数值必须按规定计算，无需进行任何额外的缩放。最终的输出行必须与所要求的格式完全匹配。", "solution": "该问题提法恰当且科学上合理，要求实现并评估一种用于计算力学中应变局部化问题的数值方法。我将开始进行解答。\n\n该问题要求计算一个非局部积分算子的数值近似的离散误差。该算子用于计算岩土力学中，以正则化表现出应变局部化的解，这是一种变形集中在狭窄带内的现象。非局部公式将某一点的局部量（应变）替换为该量在有限邻域内的加权平均值，这在数学上对应于一个卷积积分。\n\n首先，我们定义基本量。局部的、一维的等效应变场 $\\varepsilon(\\xi)$ 由下式给出：\n$$\n\\varepsilon(\\xi) = \\varepsilon_0 \\exp\\!\\left(-\\frac{|\\xi - x_0|}{\\beta}\\right)\n$$\n对于域 $\\Omega = [0, L]$ 中的 $\\xi$。此处，$\\varepsilon_0 = 0.02$ 是无量纲峰值应变，$x_0 = 0.5$ 米是局部化带的中心，$\\beta = 0.01$ 米是该带的特征宽度。域的长度为 $L=1.0$ 米。\n\n在点 $x \\in \\Omega$ 处的非局部平均应变 $\\bar{\\varepsilon}(x)$ 由一个重整化卷积定义：\n$$\n\\bar{\\varepsilon}(x) = \\frac{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,\\varepsilon(\\xi)\\,d\\xi}{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,d\\xi}\n$$\n权重函数 $\\alpha(x,\\xi)$ 是一个特征长度为 $\\ell$ 的高斯核函数：\n$$\n\\alpha(x,\\xi) = \\exp\\!\\left(-\\frac{(x-\\xi)^2}{2\\ell^2}\\right)\n$$\n$\\bar{\\varepsilon}(x)$ 表达式中的分母是一个归一化因子。它确保了即使积分被截断到有限域 $[0, L]$，平均性质也能得以保持。当计算点 $x$ 靠近边界时，这一点尤其重要，因为高斯核函数的支撑集可能有很大一部分落在域外。\n\n问题要求我们使用复合中点法则来近似这些积分。对于一个由 $N$ 个均匀单元组成的网格，域 $[0, L]$ 被划分为 $N$ 个子区间，每个子区间的宽度为 $h = L/N$。第 $i$ 个单元（对于 $i=0, \\dots, N-1$）的中点是 $\\xi_i = (i+\\frac{1}{2})h$。一个通用函数 $f(\\xi)$ 的积分于是可以近似为：\n$$\n\\int_0^L f(\\xi) d\\xi \\approx \\sum_{i=0}^{N-1} f(\\xi_i) h\n$$\n将此数值积分法则同时应用于 $\\bar{\\varepsilon}(x)$ 表达式的分子和分母，得到离散非局部平均 $\\bar{\\varepsilon}_N(x)$：\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)\\,h}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,h}\n$$\n网格间距 $h$ 是分子和分母求和中的一个常数因子，因此可以消去。这将离散公式简化为在单元中心处求值的应变值的加权平均：\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)}\n$$\n任务的核心是基于此公式实现一个函数。该函数将以网格大小 $N$ 和物理参数 $(\\ell, x)$ 作为输入，并返回 $\\bar{\\varepsilon}_N(x)$ 的值。\n\n为了量化此近似的精度，我们定义了绝对离散误差 $e_N(x)$。由于 $\\bar{\\varepsilon}(x)$ 的解析解不易获得，我们采用一种常见的数值分析技术：与一个高度精细化的数值解进行比较。我们使用相同的离散公式，但采用非常大量的单元数（$N_{\\mathrm{ref}} = 100000$）来计算一个参考值 $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$。该值被假定为对真实连续结果的精确近似。误差则定义为：\n$$\ne_N(x) = \\big|\\bar{\\varepsilon}_N(x) - \\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)\\big|\n$$\n针对每个测试用例 $(\\ell, N, x)$ 解决该问题的算法如下：\n1. 定义一个函数 `calculate_nonlocal_average` 来实现 $\\bar{\\varepsilon}_N(x)$ 的公式。该函数将：a. 计算网格间距 $h = L/N$。 b. 生成一个包含 $N$ 个单元中点 $\\xi_i$ 的数组。 c. 对数组中的所有点计算 $\\varepsilon(\\xi_i)$ 和 $\\alpha(x, \\xi_i)$。 d. 计算分子和 $\\sum \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)$ 与分母和 $\\sum \\alpha(x,\\xi_i)$。 e. 返回这两个和的比值。\n2. 对于每个给定的测试用例 $(\\ell, N, x)$：a. 使用指定的 $N$ 调用 `calculate_nonlocal_average` 来计算 $\\bar{\\varepsilon}_N(x)$。 b. 使用 $N_{\\mathrm{ref}}$ 调用 `calculate_nonlocal_average` 来计算参考值 $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$。 c. 计算绝对误差 $e_N(x)$。\n3. 将所有测试用例的误差收集到一个列表中。\n4. 根据指定的输出格式对误差列表进行格式化并打印。对所提供的所有六个测试用例都将重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_nonlocal_average(N, L, x, epsilon_0, x_0, beta, ell):\n    \"\"\"\n    Computes the discrete nonlocal average strain using the composite midpoint rule.\n\n    Args:\n        N (int): Number of elements in the mesh.\n        L (float): Length of the 1D bar.\n        x (float): Evaluation point for the nonlocal average.\n        epsilon_0 (float): Peak strain.\n        x_0 (float): Center of the strain localization band.\n        beta (float): Width of the strain localization band.\n        ell (float): Characteristic length of the Gaussian kernel.\n\n    Returns:\n        float: The calculated discrete nonlocal average strain.\n    \"\"\"\n    # 1. Generate the mesh\n    # Mesh spacing\n    h = L / N\n    # Element centers (midpoints)\n    xi_points = (np.arange(N) + 0.5) * h\n\n    # 2. Evaluate the strain field and the weight function at the mesh points\n    # Local strain field values\n    epsilon_vals = epsilon_0 * np.exp(-np.abs(xi_points - x_0) / beta)\n    \n    # Weight function values\n    alpha_vals = np.exp(-(x - xi_points)**2 / (2 * ell**2))\n\n    # 3. Compute the sums for the numerator and denominator\n    # The term 'h' from the Riemann sum cancels out.\n    numerator = np.sum(alpha_vals * epsilon_vals)\n    denominator = np.sum(alpha_vals)\n\n    # 4. Compute the nonlocal average\n    # The denominator should not be zero for a non-zero domain and Gaussian kernel.\n    # A check is included for numerical robustness.\n    if denominator == 0.0:\n        return 0.0\n\n    return numerator / denominator\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute the discretization errors.\n    \"\"\"\n    # Define the fixed parameters from the problem statement.\n    L = 1.0\n    epsilon_0 = 0.02\n    x_0 = 0.5\n    beta = 0.01\n    N_ref = 100000\n\n    # Define the test cases as tuples of (ell, N, x).\n    test_cases = [\n        (0.05, 20, 0.5),    # 1. Interior evaluation, moderate kernel, coarse mesh\n        (0.05, 40, 0.5),    # 2. Interior evaluation, moderate kernel, refined mesh\n        (0.05, 20, 0.02),   # 3. Near-boundary evaluation\n        (0.005, 20, 0.5),   # 4. Small kernel, poorly resolved\n        (0.005, 400, 0.5),  # 5. Small kernel, well resolved\n        (0.05, 40, 0.8),    # 6. Evaluation away from localization center\n    ]\n\n    results = []\n    for ell, N, x in test_cases:\n        # Calculate the approximate value with N elements\n        eps_bar_N = calculate_nonlocal_average(N, L, x, epsilon_0, x_0, beta, ell)\n        \n        # Calculate the reference value with N_ref elements\n        eps_bar_N_ref = calculate_nonlocal_average(N_ref, L, x, epsilon_0, x_0, beta, ell)\n        \n        # Compute the absolute discretization error\n        error = np.abs(eps_bar_N - eps_bar_N_ref)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3546150"}, {"introduction": "这项高级实践旨在将我们开发的数值工具应用于解决一个实际的岩土力学问题，从而连接理论与应用。在本练习 [@problem_id:3546155] 中，您将利用线性稳定性分析的结论，比较两种不同的正则化模型——积分非局部模型和梯度损伤模型——在预测剪切带宽度等物理现象方面的能力。这不仅能巩固您对非局部理论的理解，还能培养您在不同模型之间进行定量评估和选择的关键技能。", "problem": "考虑一个沿空间坐标 $x \\in \\mathbb{R}$ 的平面应变直剪试验的一维表示，其中剪切应变场用 $\\gamma(x)$ 表示。模型采用一个标量损伤型本构模型，其中应力响应随着一个负切线（软化）斜率 $H0$ 而软化，该过程由一个非局部等效应变 $\\bar{\\gamma}(x)$ 控制，而未损伤剪切模量为 $G0$。考虑了两种正则化方法：一个积分型非局部模型和一个梯度损伤模型。目标是对于给定的材料和加载参数，确定哪种正则化方法能更准确地再现观察到的剪切带宽度，同时控制单位面积断裂能、内禀长度和软化斜率。\n\n基本原理与定义：\n- 在积分型非局部模型中，非局部等效应变通过归一化卷积定义\n$$\n\\bar{\\gamma}(x) = \\int_{-\\infty}^{\\infty} w_n(|x-y|)\\,\\gamma(y)\\,\\mathrm{d}y,\n$$\n其中归一化高斯权重函数为\n$$\nw_n(r) = \\frac{\\exp\\!\\left[-(r/l)^2\\right]}{\\int_{-\\infty}^{\\infty}\\exp\\!\\left[-(s/l)^2\\right]\\mathrm{d}s} = \\frac{1}{\\sqrt{\\pi}\\,l}\\,\\exp\\!\\left[-(r/l)^2\\right],\n$$\n且 $l0$ 是内禀长度尺度。$w_n(r)$ 的傅里叶变换是\n$$\n\\widehat{w_n}(k) = \\int_{-\\infty}^{\\infty} w_n(r)\\,e^{-i k r}\\,\\mathrm{d}r = \\exp\\!\\left[-\\left(\\frac{k\\,l}{2}\\right)^2\\right],\n$$\n其中 $k \\ge 0$ 是谐波扰动 $\\delta\\gamma(x)=A\\,e^{i k x}$ 的波数。\n\n- 在梯度损伤模型中，亥姆霍兹型非局部性在傅里叶空间中由以下关系给出\n$$\n\\widehat{\\bar{\\gamma}}(k) = \\frac{\\widehat{\\gamma}(k)}{1 + l^2 k^2},\n$$\n这是在无穷远处梯度为零的条件下，应用于 $\\gamma(x)$ 的微分算子 $(1 - l^2 \\partial_{xx})^{-1}$ 的傅里叶符号。\n\n局部化的线性稳定性分析：\n- 考虑对一个均匀基态施加无穷小谐波扰动 $\\delta\\gamma(x)=A e^{i k x}$。软化过程中的有效增量剪切模量取决于 $\\delta\\gamma$ 的非局部滤波：\n    - 对于积分型非局部模型，滤波后的扰动为 $\\delta\\bar{\\gamma} = \\widehat{w_n}(k)\\,\\delta\\gamma$，得到有效切线模量\n    $$\n    G_{\\text{eff,int}}(k) = G + H\\,\\widehat{w_n}(k).\n    $$\n    - 对于梯度损伤模型，滤波后的扰动为 $\\delta\\bar{\\gamma} = \\delta\\gamma/(1+l^2 k^2)$，得到有效切线模量\n    $$\n    G_{\\text{eff,grad}}(k) = G + \\frac{H}{1 + l^2 k^2}.\n    $$\n- 当有效切线模量对某个 $k \\ge 0$ 首次达到零时，识别为局部化的开始（椭圆性丧失）。\n    - 积分型非局部模型：求解 $G + H \\exp\\!\\left[-(k l/2)^2\\right] = 0$ 得到 $k$，当 $|H| \\ge G$ 时，得出\n    $$\n    \\exp\\!\\left[-\\left(\\frac{k\\,l}{2}\\right)^2\\right] = \\frac{G}{|H|} \\quad \\Rightarrow \\quad k_{\\text{int}} = \\frac{2}{l}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}.\n    $$\n    如果 $|H|  G$，那么 $k_{\\text{int}}$ 就不是实数，如果 $|H| = G$，则 $k_{\\text{int}} = 0$（无限波长），如果 $|H| > G$，则该解是有效的。梯度模型的分析是类似的。临界波数 $k$ 标志着正弦失稳模式的出现，其波长为 $\\lambda=2\\pi/k$。剪切带宽度 $w$ 被识别为半波长，即 $w = \\lambda/2 = \\pi/k$。\n- 梯度损伤模型：求解 $G + H / (1 + l^2 k^2) = 0$ 得到 $k$，当 $|H| > G$ 时，得出\n    $$\n    1 + l^2 k^2 = \\frac{|H|}{G} \\quad \\Rightarrow \\quad k_{\\text{grad}} = \\frac{1}{l}\\,\\sqrt{\\frac{|H|}{G} - 1}.\n    $$\n如果 $|H| \\le G$，则梯度模型不会预测出有限宽度的局部化。\n\n你的任务是创建一个程序，该程序根据以下标准为每个测试用例确定首选模型（积分型或梯度型）。\n\n一个模型的性能通过两个标准来评估：它预测的剪切带宽度 $w_{\\text{model}}$ 与观测值 $w_{\\text{obs}}$ 的接近程度，以及它所蕴含的断裂能 $G_{f,\\text{pred}}$ 与材料的实际断裂能 $G_f$ 的一致性。\n- 单位体积的局部能量耗散为 $g_{\\text{loc}} = \\frac{1}{2}\\frac{\\tau_p^2}{|H|}$，其中 $\\tau_p$ 是峰值剪切强度。\n- 模型的预测断裂能为 $G_{f,\\text{pred}} = g_{\\text{loc}} \\cdot w_{\\text{model}}$。\n- 相对宽度误差定义为 $e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|$。\n- 相对断裂能误差定义为 $e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|$。\n- 组合误差度量为 $E = e_w + e_g$。\n\n您的程序必须对给定的六个测试用例执行以下决策逻辑：\n1. 对于每个模型，计算预测的剪切带宽度 $w_{\\text{model}}$。如果一个模型没有预测出有限的正宽度（例如，如果 $|H|  G$），则该模型被视为无效。\n2. 如果两个模型都无效，则返回 -1。\n3. 如果只有一个模型有效，则选择该模型（积分模型为0，梯度模型为1）。\n4. 如果两个模型都有效，则计算每个模型的组合误差 $E$。选择误差较小的模型（积分模型为0，梯度模型为1）。\n\n测试套件由六个测试用例组成，每个用例都有一组参数 $(G, H, l, \\tau_p, G_f, w_{\\text{obs}})$，其中所有单位都符合国际单位制（$G$和$H$单位为Pa，$\\tau_p$单位为Pa，$l$和$w_{\\text{obs}}$单位为m，$G_f$单位为J/m²）。\n1. $(1.0\\times 10^{10}, -2.0\\times 10^{10}, 0.01, 5.0\\times 10^7, 5000, 0.025)$\n2. $(1.0\\times 10^{10}, -1.0\\times 10^{10}, 0.02, 6.0\\times 10^7, 4000, 0.03)$\n3. $(1.5\\times 10^{10}, -7.5\\times 10^9, 0.015, 4.0\\times 10^7, 3000, 0.02)$\n4. $(1.0\\times 10^{10}, -5.0\\times 10^{10}, 0.005, 8.0\\times 10^7, 8000, 0.01)$\n5. $(1.0\\times 10^{10}, -3.0\\times 10^{10}, 0.002, 7.0\\times 10^7, 6000, 0.006)$\n6. $(1.0\\times 10^{10}, -2.0\\times 10^{10}, 0.01, 5.0\\times 10^7, 1200, 0.0189)$\n\n您的程序必须生成单行输出，其中包含按顺序排列的六个整数结果（-1、0或1），格式为方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。", "solution": "用户提供的问题经评估有效。其科学基础是连续介质损伤力学和应变局部化原理，特别是使用了非局部正则化技术。所有定义、模型和参数都已提供，使得问题自洽且适定。该任务是两个标准模型之间基于清晰数学标准的客观、定量比较。所提供的物理参数对于岩土力学中的应用是切合实际的。\n\n解决方案通过为每个测试用例实现指定的计算来进行。单个测试用例的总体流程如下，其参数为 $(G, H, l, \\tau_p, G_f, w_{\\text{obs}})$：\n\n1.  **检查局部化**：第一步是评估局部化开始的条件，即 $|H| \\ge G$。参数 $G$ 和 $H$ 分别是弹性剪切模量和软化模量。\n    *   如果 $|H|  G$，则两种模型都不会发生应变局部化。特征波数 $k$ 不是实数，因此剪切带宽度 $w$ 未定义。在实现中，这表示为非数值（$NaN$）。\n    *   如果 $|H| = G$，这是分岔阈值。分析得出两种模型的特征波数均为 $k=0$，对应于无限剪切带宽度 $w = \\infty$。\n    *   如果 $|H| > G$，则发生局部化，具有有限的非零波数 $k > 0$，从而产生有限的剪切带宽度 $w$。\n\n2.  **计算预测的剪切带宽度**：如果预测到有限宽度的局部化（$|H| > G$），则计算积分型非局部模型（$w_{\\text{int}}$）和梯度损伤模型（$w_{\\text{grad}}$）的剪切带宽度。\n    *   积分模型的波数由下式给出\n        $$\n        k_{\\text{int}} = \\frac{2}{l}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}\n        $$\n        相应的宽度为 $w_{\\text{int}} = \\pi/k_{\\text{int}}$。\n    *   梯度模型的波数由下式给出\n        $$\n        k_{\\text{grad}} = \\frac{1}{l}\\,\\sqrt{\\frac{|H|}{G}-1}\n        $$\n        相应的宽度为 $w_{\\text{grad}} = \\pi/k_{\\text{grad}}$。\n\n3.  **评估模型性能**：对于每个产生有限正宽度的模型，计算两个误差度量：相对宽度误差（$e_w$）和相对断裂能误差（$e_g$）。\n    *   相对宽度误差衡量预测宽度 $w_{\\text{model}}$ 与观测宽度 $w_{\\text{obs}}$ 的偏差：\n        $$\n        e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|\n        $$\n    *   断裂能误差将模型预测的断裂能 $G_{f,\\text{pred}}$ 与观测到的断裂能 $G_f$ 进行比较。预测的断裂能通过在带宽度 $w_{\\text{model}}$ 上积分单位体积耗散的局部能量 $g_{\\text{loc}}$ 来计算：\n        $$\n        G_{f,\\text{pred}} = g_{\\text{loc}} \\cdot w_{\\text{model}} = \\left(\\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\right) w_{\\text{model}}\n        $$\n        相对误差则为：\n        $$\n        e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|\n        $$\n    *   一个组合误差度量 $E$ 定义为这两个误差之和：\n        $$\n        E = e_w + e_g\n        $$\n\n4.  **应用决策规则**：根据每个测试用例计算出的宽度和误差作出最终决定。\n    *   如果两个模型都预测为未定义（$NaN$）或无限宽度，则结果为 $-1$。\n    *   如果只有一个模型预测出有限的正宽度，则选择该模型。结果为 $0$ 表示积分模型，为 $1$ 表示梯度模型。\n    *   如果两个模型都预测出有限的正宽度，则选择组合误差 $E$ 较小的模型。返回值同样为 $0$（积分模型）或 $1$（梯度模型）。\n\n将此程序应用于六个测试用例中的每一个，并将结果汇编成一个最终列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(G, H, l, tau_p, G_f, w_obs):\n    \"\"\"\n    Solves a single test case for the nonlocal regularization problem.\n\n    Args:\n        G (float): Shear modulus (Pa).\n        H (float): Softening slope (Pa).\n        l (float): Internal length (m).\n        tau_p (float): Peak shear strength (Pa).\n        G_f (float): Observed fracture energy (J/m^2).\n        w_obs (float): Observed shear band width (m).\n\n    Returns:\n        int: -1 for no unique finite solution, 0 for integral model, 1 for gradient model.\n    \"\"\"\n    abs_H = np.abs(H)\n\n    # Initialize widths to NaN (Not a Number)\n    w_int = np.nan\n    w_grad = np.nan\n\n    # Check localization condition: |H| must be >= G for integral model\n    if abs_H  G:\n        # No localization predicted by integral model\n        w_int = np.nan\n    elif abs_H == G:\n        # Bifurcation threshold, infinite wavelength/width\n        w_int = np.inf\n    else: # abs_H > G, finite width localization\n        # Integral model\n        ratio_int = G / abs_H\n        k_int = (2 / l) * np.sqrt(-np.log(ratio_int))\n        if k_int > 0:\n            w_int = np.pi / k_int\n        else:\n            w_int = np.inf\n            \n    # Check localization condition: |H| must be > G for gradient model\n    if abs_H = G:\n        w_grad = np.nan\n    else: # abs_H > G, finite width localization\n        # Gradient model\n        ratio_grad = abs_H / G\n        k_grad = (1 / l) * np.sqrt(ratio_grad - 1)\n        if k_grad > 0:\n            w_grad = np.pi / k_grad\n        else:\n            w_grad = np.inf\n\n\n    # Check validity of predicted widths\n    is_int_valid = np.isfinite(w_int) and w_int > 0\n    is_grad_valid = np.isfinite(w_grad) and w_grad > 0\n\n    # Apply decision rules\n    if not is_int_valid and not is_grad_valid:\n        return -1\n    elif is_int_valid and not is_grad_valid:\n        return 0\n    elif not is_int_valid and is_grad_valid:\n        return 1\n    else: # Both are valid, compare combined error E\n        # Local energy dissipation per unit volume\n        g_loc = 0.5 * (tau_p**2) / abs_H\n\n        # Errors for integral model\n        G_f_pred_int = g_loc * w_int\n        e_w_int = np.abs(w_int / w_obs - 1)\n        e_g_int = np.abs(G_f_pred_int / G_f - 1)\n        E_int = e_w_int + e_g_int\n\n        # Errors for gradient model\n        G_f_pred_grad = g_loc * w_grad\n        e_w_grad = np.abs(w_grad / w_obs - 1)\n        e_g_grad = np.abs(G_f_pred_grad / G_f - 1)\n        E_grad = e_w_grad + e_g_grad\n        \n        return 0 if E_int = E_grad else 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (G, H, l, tau_p, G_f, w_obs)\n    test_cases = [\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 5000, 0.025),\n        (1.0e10, -1.0e10, 0.02, 6.0e7, 4000, 0.03),\n        (1.5e10, -7.5e9, 0.015, 4.0e7, 3000, 0.02),\n        (1.0e10, -5.0e10, 0.005, 8.0e7, 8000, 0.01),\n        (1.0e10, -3.0e10, 0.002, 7.0e7, 6000, 0.006),\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 1200, 0.0189),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3546155"}]}