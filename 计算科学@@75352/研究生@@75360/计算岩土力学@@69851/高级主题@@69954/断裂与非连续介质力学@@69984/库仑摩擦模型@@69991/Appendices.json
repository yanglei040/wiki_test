{"hands_on_practices": [{"introduction": "在饱和多孔介质中，力学行为与流体压力紧密耦合。本练习将通过一个解析模型，深入探讨有效应力原理在摩擦问题中的应用。通过推导一个饱和界面在固结过程中的临界剪切力，你将亲身体会孔隙水压力消散如何导致摩擦强度随时间增长，即“摩擦强化”现象，这是理解断层和边坡长期稳定性的关键概念 [@problem_id:3512291]。", "problem": "一个面积为 $A$ 的平面、饱和、粗糙的岩土界面对称地嵌入在两个相同的、均质的、各向同性的、完全饱和的多孔半层之间。在时间 $t=0^{+}$ 时，一个压缩法向荷载 $N$ 被均匀地施加到界面上，并保持恒定。界面上的总法向应力为 $\\sigma_{n}=N/A$（以压缩为正）。加载后，界面立即产生不排水超孔隙水压力 $u_{0}$，该压力随后通过在相邻多孔层中的一维固结过程消散，固结系数为 $c_{v}$，到每个排水边界的排水路径长度相等，为 $H_{d}$（双面排水）。假设小应变和准静态条件。\n\n接着，一个切向（剪切）力 $T$ 沿界面单调且准静态地施加，在界面上引起一个均匀的剪切牵引力矢量 $\\boldsymbol{\\tau}$。该界面遵循一个以有效应力表示的率无关、无粘聚力的库仑准则：$\\|\\boldsymbol{\\tau}\\| \\le \\mu\\,p'$，其中 $\\mu$ 是恒定的摩擦系数，$p'$ 是界面上的有效法向应力。有效应力由有效应力原理定义为 $p'=\\sigma_{n}-u$，其中 $u$ 是界面处的孔隙水压力。\n\n将孔隙水压力消散处理为垂直于界面的一维固结，在两侧距离为 $H_{d}$ 的排水边界处超孔隙水压力为零，并且在固结层中具有空间均匀的初始超孔隙水压力 $u(z,0)=u_{0}$。您可以假设，与界面滑动相关的孔隙水压力等于 Terzaghi 一维固结理论中双面排水条件下固结层内的空间平均超孔隙水压力。\n\n仅使用上述基础（有效应力原理、库仑摩擦和一维固结），推导出一个用于描述滑动开始的随时间变化的临界剪切力 $T_{c}(t)$ 的闭式解析表达式（可以表示为收敛级数）。用牛顿表示您最终的 $T_{c}(t)$。然后，根据您的表达式，定性解释增加固结时间 $t$ 如何影响界面的稳定性。\n\n您的最终答案必须是关于 $T_{c}(t)$ 的一个单一闭式解析表达式，用 $N$、$A$、$\\mu$、$u_{0}$、$c_{v}$、$H_{d}$ 和 $t$ 表示。不需要进行数值计算，也不需要四舍五入。此问题不涉及角度。", "solution": "首先根据指定标准对问题进行验证。\n\n**步骤 1：提取已知条件**\n- 界面面积：$A$。\n- 法向荷载：$N$（压缩性），在时间 $t=0^{+}$ 施加并保持恒定。\n- 总法向应力：$\\sigma_{n} = N/A$。\n- 界面初始超孔隙水压力：在 $t=0^{+}$ 时为 $u_{0}$。\n- 固结模型：相邻多孔层中的一维（1D）固结。\n- 固结系数：$c_{v}$。\n- 排水条件：双面排水，到每个排水边界的排水路径长度为 $H_{d}$。\n- 切向力：$T$，引起均匀的剪切牵引力 $\\boldsymbol{\\tau}$。\n- 摩擦定律：率无关、无粘聚力的库仑准则，$\\|\\boldsymbol{\\tau}\\| \\le \\mu\\,p'$。\n- 摩擦系数：$\\mu$。\n- 有效应力原理：$p' = \\sigma_{n} - u$，其中 $u$ 是界面处的孔隙水压力。\n- 固结初始条件：空间均匀的初始超孔隙水压力 $u(z,0) = u_{0}$。\n- 固结边界条件：距离界面 $H_{d}$ 处的超孔隙水压力为零。\n- 核心假设：用于计算滑动的孔隙水压力 $u$ 等于 Terzaghi 一维固结理论中固结层内的空间平均超孔隙水压力。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，利用了有效应力原理、库仑摩擦定律和 Terzaghi 一维固结理论。这些都是岩土力学中基本且公认的原理。该问题提法明确，提供了所有必要的参数（$A, N, \\mu, u_0, c_v, H_d$）、初始和边界条件，以及一个关于计算相关孔隙水压力的清晰（尽管是理想化的）假设。语言客观而精确。该问题是土力学概念的一个标准的、不平凡的综合，不包含任何所列出的缺陷。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解答。\n\n目标是推导引发滑动所需的时间依赖性临界剪切力 $T_{c}(t)$ 的表达式。\n\n临界剪切力 $T_{c}(t)$ 是首先满足滑动条件的切向力 $T$ 的大小。给定在界面面积 $A$ 上的均匀剪切牵引力矢量 $\\boldsymbol{\\tau}$，其大小为 $\\|\\boldsymbol{\\tau}\\| = T/A$。临界剪切力 $T_{c}(t)$ 对应于一个临界剪切牵引力大小，我们将其表示为 $\\tau_{c}(t)$，使得\n$$T_{c}(t) = A \\, \\tau_{c}(t)$$\n\n界面行为由以有效应力表示的无粘聚力库仑摩擦准则控制。当剪切牵引力的大小达到界面的摩擦阻力时，滑动开始：\n$$\\tau_{c}(t) = \\mu \\, p'(t)$$\n其中 $\\mu$ 是摩擦系数，$p'(t)$ 是界面上随时间变化的有效法向应力。\n\n有效应力由有效应力原理定义为：\n$$p'(t) = \\sigma_{n} - u(t)$$\n在此，$\\sigma_{n}$ 是总法向应力，其为常数，由 $\\sigma_{n} = N/A$ 给出。项 $u(t)$ 是时间 $t$ 时界面处的超孔隙水压力。\n\n结合这些方程，我们可以将临界剪切力表示为：\n$$T_{c}(t) = A \\, \\mu \\, p'(t) = A \\, \\mu \\, (\\sigma_{n} - u(t)) = A \\, \\mu \\left(\\frac{N}{A} - u(t)\\right)$$\n$$T_{c}(t) = \\mu (N - A \\, u(t))$$\n为了求得 $T_{c}(t)$，我们必须确定界面处的超孔隙水压力 $u(t)$ 作为时间的函数。\n\n问题指出，孔隙水压力根据 Terzaghi 的一维固结理论消散。几何形状为双面排水，界面位于固结介质的中心，排水边界在两侧距离为 $H_{d}$ 处。因此，固结土的总厚度为 $L = 2H_{d}$。超孔隙水压力 $u(z,t)$ 的控制偏微分方程是扩散方程：\n$$\\frac{\\partial u}{\\partial t} = c_{v} \\frac{\\partial^2 u}{\\partial z^2}$$\n其中 $z$ 是垂直于界面的空间坐标。设界面位于 $z=0$。排水边界位于 $z = \\pm H_{d}$。对于 $t > 0$，边界条件是 $u(\\pm H_{d}, t) = 0$。初始条件是在 $-H_{d}  z  H_{d}$ 范围内，超孔隙水压力均匀为 $u(z, 0) = u_{0}$。\n\n关键的是，问题规定与滑动相关的孔隙水压力 $u(t)$ 应取为时间 $t$ 时整个固结层中超孔隙水压力的*空间平均值*。我们将这个平均压力表示为 $\\bar{u}(t)$。它定义为：\n$$\\bar{u}(t) = \\frac{1}{2H_{d}} \\int_{-H_{d}}^{H_{d}} u(z,t) \\, dz$$\n\n对于这些初始和边界条件，平均超孔隙水压力 $\\bar{u}(t)$ 的解是固结理论中的一个标准结果。它可以表示为傅里叶级数。平均固结度 $U_{av}(t)$ 定义为 $U_{av}(t) = 1 - \\bar{u}(t)/u_{0}$。$U_{av}(t)$ 的解是：\n$$U_{av}(t) = 1 - \\sum_{m=0}^{\\infty} \\frac{8}{(2m+1)^2 \\pi^2} \\exp\\left( - \\frac{(2m+1)^2 \\pi^2 c_{v} t}{4 H_{d}^2} \\right)$$\n由此，我们可以将平均超孔隙水压力 $\\bar{u}(t)$ 写为：\n$$\\bar{u}(t) = u_{0} (1 - U_{av}(t)) = u_{0} \\sum_{m=0}^{\\infty} \\frac{8}{(2m+1)^2 \\pi^2} \\exp\\left( - \\frac{(2m+1)^2 \\pi^2 c_{v} t}{4 H_{d}^2} \\right)$$\n根据问题的假设，我们将用于摩擦计算的界面孔隙水压力设为此平均值：$u(t) = \\bar{u}(t)$。\n\n将这个 $u(t)$ 的表达式代入我们的 $T_{c}(t)$ 方程中：\n$$T_{c}(t) = \\mu \\left( N - A \\, u_{0} \\sum_{m=0}^{\\infty} \\frac{8}{(2m+1)^2 \\pi^2} \\exp\\left(-\\frac{(2m+1)^2 \\pi^2 c_{v} t}{4 H_{d}^2}\\right) \\right)$$\n这就是用于滑动开始的时间依赖性临界剪切力的闭式解析表达式。该级数是收敛的。\n\n为了定性解释增加固结时间 $t$ 如何影响界面的稳定性，我们分析推导出的 $T_{c}(t)$ 表达式。稳定性与 $T_c(t)$ 的大小直接相关：值越高表示抗滑能力越强。\n\n$T_{c}(t)$ 的表达式包含一个求和项。和中的每一项都包含一个指数因子 $\\exp(-k_{m}t)$，其中 $k_{m} = \\frac{(2m+1)^2 \\pi^2 c_{v}}{4 H_{d}^2}$ 是每个模式 $m$ 的正常数。随着时间 $t$ 的增加，每个指数项都衰减至零。因此，代表平均超孔隙水压力 $\\bar{u}(t)$ 的整个求和项随时间单调递减。\n- 在时间 $t=0$ 时，指数项为 $1$。该和的值为 $1$（因为 $\\sum_{m=0}^{\\infty} \\frac{8}{(2m+1)^2\\pi^2} = 1$），所以 $\\bar{u}(0) = u_{0}$。初始临界剪切力为 $T_{c}(0) = \\mu(N - A u_{0})$。\n- 当时间 $t \\to \\infty$ 时，指数项以及整个求和项趋于 $0$。超孔隙水压力完全消散，$\\bar{u}(\\infty) = 0$。长期临界剪切力为 $T_{c}(\\infty) = \\mu N$。\n\n由于平均孔隙水压力 $u(t)$ 随时间从 $u_{0}$ 减小到 $0$，有效法向应力 $p'(t) = N/A - u(t)$ 随时间增加。根据库仑准则，剪切强度 $\\tau_c(t)$ 与 $p'(t)$ 成正比。因此，临界剪切力 $T_{c}(t)$ 随时间从初始值 $\\mu(N - A u_{0})$ 单调增加到最终的完全排水值 $\\mu N$。这个由于孔隙水压力消散而导致界面摩擦强度增加的过程，被称为摩擦强化。因此，增加固结时间可以增强界面抵抗剪切诱发滑动的稳定性。", "answer": "$$\\boxed{\\mu \\left( N - A u_{0} \\sum_{m=0}^{\\infty} \\frac{8}{\\pi^2 (2m+1)^2} \\exp\\left(-\\frac{(2m+1)^2 \\pi^2 c_{v} t}{4 H_{d}^2}\\right) \\right)}$$", "id": "3512291"}, {"introduction": "将非光滑的库仑摩擦定律集成到离散的时间步中，是计算力学模拟的核心挑战。返回映射算法 (Return-Mapping Algorithm, RMA) 是解决此类问题的标准方法，广泛应用于计算塑性力学和接触力学。本练习 [@problem_id:3512367] 将指导你从零开始实现这一基本算法，构建一个能够准确区分弹性“粘滞”和塑性“滑移”的数值模型，为你掌握更高级的岩土力学软件开发打下坚实基础。", "problem": "考虑一个摩擦接触界面，该界面被建模为放置在两个可变形体之间的切向弹簧-滑块。在弹性粘滞状态下，界面的切向行为由一个线性弹性弹簧控制；当弹性试探状态将超过容许的摩擦边界时，则由率无关的库仑滑移控制。设弹性切向位移（存储弹性弹簧伸长量的内变量）为向量 $\\boldsymbol{\\delta}_t \\in \\mathbb{R}^2$，切向牵引力为 $\\boldsymbol{\\tau} \\in \\mathbb{R}^2$，单位面积的标量切向刚度为 $k_t$（单位为 $\\mathrm{Pa/m}$），法向压缩牵引力大小为 $p_n \\ge 0$（单位为 $\\mathrm{Pa}$），摩擦系数为 $\\mu \\ge 0$。在一个时间（或载荷）增量内，运动驱动是施加的相对切向位移增量 $\\Delta \\mathbf{u}_t \\in \\mathbb{R}^2$（单位为 $\\mathrm{m}$），算法必须一致地更新 $\\boldsymbol{\\delta}_t$ 和 $\\boldsymbol{\\tau}$。\n\n使用以下基本法则，您必须将其作为给定条件而无需推导：(i) 切向粘滞状态下的线性弹性接触定律，即 $\\boldsymbol{\\tau} = k_t \\boldsymbol{\\delta}_t$；(ii) 库仑摩擦容许条件，即 $\\|\\boldsymbol{\\tau}\\| \\le \\mu p_n$，其中 $\\|\\cdot\\|$ 表示欧几里得范数。假设小变形和准静态条件，并使用返回映射算法 (RMA) 的标准预测-校正结构，但除了所述的基本法则外，不要假设任何专门的闭式表达式。\n\n您的任务如下，并且每一步都必须严格基于所提供的基本定律和核心定义：\n- 从先前的内状态 $\\boldsymbol{\\delta}_t^{\\mathrm{old}}$ 和给定的增量 $\\Delta \\mathbf{u}_t$ 出发，构建区分弹性粘滞和塑性滑移的逻辑结构。清晰地解释如何通过纯弹性演化获得一个弹性试探状态，以及如何使用从库仑条件导出的适当屈服函数来判断其容许性。\n- 如果试探状态是容许的，则以与弹性粘滞一致的方式更新 $\\boldsymbol{\\delta}_t$ 和 $\\boldsymbol{\\tau}$。如果试探状态违反了容许性，则执行一次返回（投影）到库仑面上的操作，该操作强制 $\\|\\boldsymbol{\\tau}\\| = \\mu p_n$，同时以数学上一致的方式保持驱动状态的方向。展示校正后的 $\\boldsymbol{\\delta}_t$ 和 $\\boldsymbol{\\tau}$ 更新是如何从这一强制条件和线性弹性定律中得出的。\n- 确保该方案对边缘情况具有鲁棒性，包括 $p_n = 0$、$\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\| = 0$ 以及试探状态恰好位于容许面上的边界情况。明确指出哪种情况被视为弹性粘滞，哪种被视为塑性滑移。\n- 将该算法实现为一个完整的程序，对于每个测试用例，该程序返回更新后的牵引力向量和更新后的弹性切向位移向量，以及一个布尔指示符，用于表示该增量结束时是弹性粘滞还是塑性滑移。所有中间物理量均以国际单位制 (SI 单位) 表示。程序不应打印任何单位符号；必须只输出纯数字。\n\n使用以下测试套件，所有量均采用 SI 单位，向量按 $(x,y)$ 顺序给出：\n- 测试用例 1 (常规粘滞路径): $k_t = 1.0\\times 10^9\\,\\mathrm{Pa/m}$, $\\mu = 0.6$, $p_n = 1.0\\times 10^5\\,\\mathrm{Pa}$, $\\boldsymbol{\\delta}_t^{\\mathrm{old}} = [0.0, 0.0]\\,\\mathrm{m}$, $\\Delta \\mathbf{u}_t = [2.0\\times 10^{-5}, 1.0\\times 10^{-5}]\\,\\mathrm{m}$。\n- 测试用例 2 (边界相等情况视为粘滞): $k_t = 1.0\\times 10^9\\,\\mathrm{Pa/m}$, $\\mu = 0.6$, $p_n = 1.0\\times 10^5\\,\\mathrm{Pa}$, $\\boldsymbol{\\delta}_t^{\\mathrm{old}} = [0.0, 0.0]\\,\\mathrm{m}$, $\\Delta \\mathbf{u}_t = [6.0\\times 10^{-5}, 0.0]\\,\\mathrm{m}$。\n- 测试用例 3 (存在非零初始弹性伸长时的塑性滑移): $k_t = 1.0\\times 10^9\\,\\mathrm{Pa/m}$, $\\mu = 0.6$, $p_n = 1.0\\times 10^5\\,\\mathrm{Pa}$, $\\boldsymbol{\\delta}_t^{\\mathrm{old}} = [2.0\\times 10^{-5}, 1.0\\times 10^{-5}]\\,\\mathrm{m}$, $\\Delta \\mathbf{u}_t = [1.0\\times 10^{-4}, -1.0\\times 10^{-5}]\\,\\mathrm{m}$。\n- 测试用例 4 (法向压力为零的边缘情况): $k_t = 1.0\\times 10^9\\,\\mathrm{Pa/m}$, $\\mu = 0.6$, $p_n = 0.0\\,\\mathrm{Pa}$, $\\boldsymbol{\\delta}_t^{\\mathrm{old}} = [0.0, 0.0]\\,\\mathrm{m}$, $\\Delta \\mathbf{u}_t = [1.0\\times 10^{-5}, -1.0\\times 10^{-5}]\\,\\mathrm{m}$。\n- 测试用例 5 (存在初始弹性伸长时的零增量): $k_t = 1.0\\times 10^9\\,\\mathrm{Pa/m}$, $\\mu = 0.6$, $p_n = 1.0\\times 10^5\\,\\mathrm{Pa}$, $\\boldsymbol{\\delta}_t^{\\mathrm{old}} = [3.0\\times 10^{-5}, 0.0]\\,\\mathrm{m}$, $\\Delta \\mathbf{u}_t = [0.0, 0.0]\\,\\mathrm{m}$。\n\n对于每个测试用例，您的程序必须输出一个格式为 $[\\tau_x, \\tau_y, \\delta_{t,x}, \\delta_{t,y}, \\mathrm{is\\_stick}]$ 的列表，其中 $\\tau_x$ 和 $\\tau_y$ 是更新后的牵引力分量（单位为 $\\mathrm{Pa}$），$\\delta_{t,x}$ 和 $\\delta_{t,y}$ 是更新后的弹性切向位移分量（单位为 $\\mathrm{m}$），$\\mathrm{is\\_stick}$ 是一个布尔值：弹性粘滞时为 `True`，塑性滑移时为 `False`。将所有浮点输出四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含所有五个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，其中每个元素是对应一个测试用例的列表（例如，`[[\\cdots],[\\cdots],...]`）。", "solution": "该问题要求为率无关的库仑摩擦模型建立并实现一个返回映射算法。该模型使用弹簧-滑块系统来描述摩擦界面的切向行为。解决方案将遵循计算塑性力学的标准预测-校正框架进行构建。所有物理量均以 SI 单位表示。\n\n核心运动学假设是总相对切向位移增量 $\\Delta \\mathbf{u}_t$ 的加法分解，它被分解为一个弹性部分 $\\Delta \\boldsymbol{\\delta}_t$ 和一个塑性（滑移）部分 $\\Delta \\mathbf{u}_t^p$：\n$$\n\\Delta \\mathbf{u}_t = \\Delta \\boldsymbol{\\delta}_t + \\Delta \\mathbf{u}_t^p\n$$\n增量开始时界面的状态由上一步的弹性切向位移 $\\boldsymbol{\\delta}_t^{\\mathrm{old}}$ 定义。目标是在给定增量 $\\Delta \\mathbf{u}_t$ 和恒定法向压力 $p_n$ 的情况下，计算更新后的状态变量 $\\boldsymbol{\\delta}_t^{\\mathrm{new}}$ 和 $\\boldsymbol{\\tau}^{\\mathrm{new}}$。\n\n### 第一步：弹性预测（试探状态）\n\n返回映射算法的第一步是假设整个增量是纯弹性的。这就是“预测”步骤。在此假设下，塑性滑移增量为零，即 $\\Delta \\mathbf{u}_t^p = \\mathbf{0}$。因此，弹性位移增量等于总施加位移增量。\n\n试探弹性位移 $\\boldsymbol{\\delta}_t^{\\mathrm{trial}}$ 的计算方法是将增量加到先前的状态上：\n$$\n\\boldsymbol{\\delta}_t^{\\mathrm{trial}} = \\boldsymbol{\\delta}_t^{\\mathrm{old}} + \\Delta \\mathbf{u}_t\n$$\n使用给定的线性弹性接触定律 $\\boldsymbol{\\tau} = k_t \\boldsymbol{\\delta}_t$，计算试探切向牵引力 $\\boldsymbol{\\tau}^{\\mathrm{trial}}$：\n$$\n\\boldsymbol{\\tau}^{\\mathrm{trial}} = k_t \\boldsymbol{\\delta}_t^{\\mathrm{trial}}\n$$\n\n### 第二步：容许性检查（屈服条件）\n\n必须根据摩擦容许性准则检查试探状态，该准则规定切向牵引力的大小不能超过与法向压力成比例的极限。这就是库仑摩擦定律：$\\|\\boldsymbol{\\tau}\\| \\le \\mu p_n$。我们可以定义一个屈服函数 $f$ 来形式化这个检查：\n$$\nf(\\boldsymbol{\\tau}, p_n) = \\|\\boldsymbol{\\tau}\\| - \\mu p_n\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数。如果 $f \\le 0$，界面处于弹性粘滞状态；如果 $f > 0$，则发生塑性滑移。\n\n我们在试探状态下评估此函数：\n$$\nf^{\\mathrm{trial}} = f(\\boldsymbol{\\tau}^{\\mathrm{trial}}, p_n) = \\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\| - \\mu p_n\n$$\n$f^{\\mathrm{trial}}$ 的值决定了是否需要一个“校正”步骤。\n\n### 第三步：校正 / 更新\n\n根据容许性检查，会出现两种情况。\n\n**情况 A：弹性粘滞 ($f^{\\mathrm{trial}} \\le 0$)**\n\n如果试探屈服函数小于或等于零，则试探状态是容许的。纯弹性行为的初始假设是正确的。没有发生塑性滑移。试探状态被接受为该增量的最终状态。\n更新后的变量为：\n$$\n\\boldsymbol{\\tau}^{\\mathrm{new}} = \\boldsymbol{\\tau}^{\\mathrm{trial}}\n$$\n$$\n\\boldsymbol{\\delta}_t^{\\mathrm{new}} = \\boldsymbol{\\delta}_t^{\\mathrm{trial}}\n$$\n塑性滑移增量被确认为零：$\\Delta \\mathbf{u}_t^p = \\mathbf{0}$。此增量的过程是弹性粘滞。根据问题陈述，当 $f^{\\mathrm{trial}} = 0$（即试探状态恰好位于容许面上）的边界情况被视为弹性粘滞，因为不需要进行校正。\n\n**情况 B：塑性滑移 ($f^{\\mathrm{trial}} > 0$)**\n\n如果试探屈服函数大于零，则试探状态是不可容许的，并且在物理上是不可能的。纯弹性行为的假设是错误的，必须发生塑性滑移以将牵引力维持在屈服面上。“校正”步骤涉及一个“返回映射”，它将试探牵引力投影回容许边界（即屈服面）上。\n\n对于率无关的库仑摩擦，相关联的流动法则规定，塑性滑移的方向 $\\Delta \\mathbf{u}_t^p$ 在应力空间中垂直于屈服面。在 $\\boldsymbol{\\tau}$ 平面中，屈服面是一个半径为 $\\mu p_n$ 的圆。屈服面上某点 $\\boldsymbol{\\tau}$ 的外法线方向为 $\\boldsymbol{\\tau} / \\|\\boldsymbol{\\tau}\\|$。为保持一致性，返回映射使用试探应力的方向，该方向代表了弹性驱动力的方向。\n\n校正后的牵引力 $\\boldsymbol{\\tau}^{\\mathrm{new}}$ 必须位于屈服面上，这意味着其大小必须恰好为 $\\mu p_n$。其方向保留了试探状态的方向：\n$$\n\\boldsymbol{\\tau}^{\\mathrm{new}} = (\\mu p_n) \\frac{\\boldsymbol{\\tau}^{\\mathrm{trial}}}{\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\|}\n$$\n这是一个到屈服圆的径向返回。根据弹性定律，更新后的弹性位移 $\\boldsymbol{\\delta}_t^{\\mathrm{new}}$ 必须与这个校正后的牵引力保持一致：\n$$\n\\boldsymbol{\\delta}_t^{\\mathrm{new}} = \\frac{\\boldsymbol{\\tau}^{\\mathrm{new}}}{k_t} = \\frac{\\mu p_n}{k_t} \\frac{\\boldsymbol{\\tau}^{\\mathrm{trial}}}{\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\|}\n$$\n此增量的过程是塑性滑移。\n\n### 边缘情况的处理\n\n该算法必须对问题中指出的特定边缘情况具有鲁棒性。\n\n- **$p_n = 0$**: 如果法向压力为零，则摩擦极限 $\\mu p_n$ 为零。\n    - 如果 $\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\| > 0$，则 $f^{\\mathrm{trial}} > 0$，表示发生滑移。返回映射将牵引力投影到一个大小为零的点上：$\\boldsymbol{\\tau}^{\\mathrm{new}} = \\mathbf{0}$。因此，最终的弹性位移也为零：$\\boldsymbol{\\delta}_t^{\\mathrm{new}} = \\mathbf{0}$。这代表无阻力的自由滑移。\n    - 如果 $\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\| = 0$，则 $f^{\\mathrm{trial}} = 0$，表示粘滞。最终状态为 $\\boldsymbol{\\tau}^{\\mathrm{new}} = \\mathbf{0}$ 和 $\\boldsymbol{\\delta}_t^{\\mathrm{new}} = \\boldsymbol{\\delta}_t^{\\mathrm{trial}}$。\n\n- **$\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\| = 0$**: 这种情况只在 $\\boldsymbol{\\delta}_t^{\\mathrm{trial}} = \\mathbf{0}$ 时发生。此时，屈服函数为 $f^{\\mathrm{trial}} = 0 - \\mu p_n$。由于 $\\mu \\ge 0$ 且 $p_n \\ge 0$，因此 $f^{\\mathrm{trial}} \\le 0$。这种情况将始终被归类为弹性粘滞。更新结果为 $\\boldsymbol{\\tau}^{\\mathrm{new}} = \\mathbf{0}$ 和 $\\boldsymbol{\\delta}_t^{\\mathrm{new}} = \\mathbf{0}$，这在物理上是一致的。因此，在这种情况下永远不会遇到除以 $\\|\\boldsymbol{\\tau}^{\\mathrm{trial}}\\|$ 的操作，因为它不会进入滑移分支。\n\n预测、检查和校正步骤的组合构成了一个完整且鲁棒的算法，用于在单个载荷增量上更新摩擦界面的状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Coulomb friction return-mapping algorithm.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path stick\n        {'k_t': 1.0e9, 'mu': 0.6, 'p_n': 1.0e5, 'delta_t_old': np.array([0.0, 0.0]), 'delta_u_t': np.array([2.0e-5, 1.0e-5])},\n        # Case 2: Boundary equality treated as stick\n        {'k_t': 1.0e9, 'mu': 0.6, 'p_n': 1.0e5, 'delta_t_old': np.array([0.0, 0.0]), 'delta_u_t': np.array([6.0e-5, 0.0])},\n        # Case 3: Plastic slip with nonzero prior elastic stretch\n        {'k_t': 1.0e9, 'mu': 0.6, 'p_n': 1.0e5, 'delta_t_old': np.array([2.0e-5, 1.0e-5]), 'delta_u_t': np.array([1.0e-4, -1.0e-5])},\n        # Case 4: Zero normal pressure edge case\n        {'k_t': 1.0e9, 'mu': 0.6, 'p_n': 0.0, 'delta_t_old': np.array([0.0, 0.0]), 'delta_u_t': np.array([1.0e-5, -1.0e-5])},\n        # Case 5: Zero increment with pre-existing elastic stretch\n        {'k_t': 1.0e9, 'mu': 0.6, 'p_n': 1.0e5, 'delta_t_old': np.array([3.0e-5, 0.0]), 'delta_u_t': np.array([0.0, 0.0])},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_return_mapping(**params)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The map(str, results) and join correctly format the output per the problem specification.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\ndef run_return_mapping(k_t, mu, p_n, delta_t_old, delta_u_t):\n    \"\"\"\n    Implements the return-mapping algorithm for rate-independent Coulomb friction.\n\n    Args:\n        k_t (float): Tangential stiffness per unit area (Pa/m).\n        mu (float): Coefficient of friction.\n        p_n (float): Compressive normal traction (Pa).\n        delta_t_old (np.ndarray): Previous elastic tangential displacement vector (m).\n        delta_u_t (np.ndarray): Imposed relative tangential displacement increment vector (m).\n\n    Returns:\n        list: A list containing [tau_x, tau_y, delta_t_x, delta_t_y, is_stick]\n              with floats rounded to 6 decimal places.\n    \"\"\"\n    # Step 1: Elastic Predictor (Trial State)\n    # Assume the entire increment is elastic.\n    delta_t_trial = delta_t_old + delta_u_t\n    tau_trial = k_t * delta_t_trial\n    \n    # Step 2: Admissibility Check (Yield Condition)\n    norm_tau_trial = np.linalg.norm(tau_trial)\n    friction_limit = mu * p_n\n    \n    # Yield function: f = ||tau|| - mu*p_n\n    yield_function = norm_tau_trial - friction_limit\n\n    # Step 3: Corrector / Update\n    # Check if the trial state is admissible (stick) or not (slip).\n    # The condition `yield_function = 0` corresponds to elastic stick.\n    if yield_function = 0:\n        # Case A: Elastic Stick\n        is_stick = True\n        tau_new = tau_trial\n        delta_t_new = delta_t_trial\n    else:\n        # Case B: Plastic Slip\n        is_stick = False\n        # The trial traction magnitude is guaranteed to be non-zero here\n        # because yield_function > 0 implies norm_tau_trial > friction_limit >= 0.\n        # A direct return to the yield surface is performed.\n        \n        # Handle the special case of frictionless sliding where friction_limit is 0.\n        # Return to origin.\n        if friction_limit == 0.0:\n            tau_new = np.array([0.0, 0.0])\n        else:\n            # Radial return: project the trial traction back to the yield surface.\n            tau_new = tau_trial * (friction_limit / norm_tau_trial)\n        \n        # Update elastic displacement to be consistent with the corrected traction.\n        delta_t_new = tau_new / k_t\n\n    # Format the output for the current test case\n    return [\n        round(tau_new[0], 6),\n        round(tau_new[1], 6),\n        round(delta_t_new[0], 6),\n        round(delta_t_new[1], 6),\n        is_stick\n    ]\n\n# Execute the main function.\nsolve()\n```", "id": "3512367"}, {"introduction": "摩擦系统常常表现出复杂的粘滑 (stick-slip) 行为，直接从原始模拟数据中解读这种行为可能非常困难。本练习 [@problem_id:3512299] 旨在解决后处理模拟结果时的实际挑战。你将设计一个稳健的事件检测算法，该算法不仅能对界面的状态（粘滞、滑移或张开）进行分类，还能准确识别关键的状态转换事件，并学习如何利用滞回机制来避免数值“颤振”伪影。", "problem": "设计并实现一个完整的事件检测算法，用于在库仑摩擦下单个节点摩擦界面的时间步模拟中识别粘滑转换。计算基础必须从标准的库仑摩擦定律和法向接触条件出发。您必须推导、论证并实现鲁棒的分类准则和滞后机制以避免颤振，然后检测并报告状态在粘滞和滑动之间切换的索引。程序必须是完全自包含的，并在指定的测试套件上产生所需的输出。\n\n基本基础和使用的定义：\n- 库仑摩擦定律：在接触状态下，切向牵引力大小 $t_t$ 在粘滞时满足\n$$ t_t \\le \\mu\\,p_n $$\n在滑动时满足\n$$ t_t = \\mu\\,p_n, \\quad \\|\\boldsymbol{v}_t\\| > 0, $$\n其中 $\\mu$ 是摩擦系数（无量纲），$p_n$ 是法向压缩牵引力（正标量，单位为兆帕 (MPa)），$\\boldsymbol{v}_t$ 是切向相对速度（单位为米/秒 (m/s)）。符号 $\\|\\boldsymbol{v}_t\\|$ 表示切向速度的欧几里得范数。\n- 法向接触条件：当 $p_n > 0$ 时接触有效；当 $p_n \\le 0$ 时界面张开，摩擦失效。\n- 互补性解释：粘滞意味着 $\\|\\boldsymbol{v}_t\\| = 0$ 且 $t_t  \\mu p_n$，滑动意味着 $\\|\\boldsymbol{v}_t\\| > 0$ 且 $t_t \\approx \\mu p_n$，这与库仑锥一致。\n\n需要设计的鲁棒分类准则：\n- 使用速度容差 $v_{\\mathrm{tol}}$ 来判断 $\\|\\boldsymbol{v}_t\\|$ 是否在数值上为零，并使用牵引力容差 $\\tau_{\\mathrm{tol}}$ 来判断 $t_t$ 是否充分低于或达到摩擦极限。\n- 引入一个滞后因子 $h \\in (0,1)$ 来为进入和退出粘滞或滑动状态创建分离的阈值，以减少在 $t_t \\approx \\mu p_n$ 附近的颤振。\n- 定义一个“活动集”指示器，将每个时间步的状态分类为“粘滞 (stick)”、“滑动 (slip)”或“张开 (open)”。一个事件是“粘滞”和“滑动”之间活动集的改变。涉及“张开”状态的变化不能报告为粘滑事件。\n\n必需的推导目标：\n1. 从库仑定律和法向接触出发，推导基于阈值的条件，将每个时间步的 $\\|\\boldsymbol{v}_t\\|$、$t_t$、$p_n$ 和 $\\mu$ 映射到一个 $\\{\\text{张开}, \\text{粘滞}, \\text{滑动}\\}$ 中的状态。用 $v_{\\mathrm{tol}}$、$\\tau_{\\mathrm{tol}}$ 和 $h$ 来表示最终的分类规则；不要使用超出基本基础的任何捷径公式。\n2. 指定并论证一个滞后结构：从滑动到粘滞的转换应比从粘滞到滑动的转换需要更严格的条件。明确地给出这些条件。\n3. 定义事件检测规则，该规则生成活动集在粘滞和滑动之间切换的时间索引列表，忽略“张开”状态。\n\n单位和数值规范：\n- $\\|\\boldsymbol{v}_t\\|$ 必须以米/秒 (m/s) 为单位处理。\n- $t_t$ 和 $p_n$ 必须以兆帕 (MPa) 为单位处理。\n- 摩擦系数 $\\mu$ 是无量纲的。\n- 使用 $v_{\\mathrm{tol}} = 1\\times 10^{-5}$ m/s, $\\tau_{\\mathrm{tol}} = 1\\times 10^{-3}$ MPa, 以及 $h = 0.05$。\n- 使用“张开”阈值 $p_{\\mathrm{open}} = 1\\times 10^{-9}$ MPa 来判断 $p_n \\le p_{\\mathrm{open}}$ 为张开状态。\n\n测试套件：\n对于每个测试用例，给定长度为 $N$ 的离散时间步上的数组：\n- $\\{\\|\\boldsymbol{v}_t\\|_i\\}_{i=0}^{N-1}$ (单位: m/s)，\n- $\\{t_{t,i}\\}_{i=0}^{N-1}$ (单位: MPa)，\n- $\\{p_{n,i}\\}_{i=0}^{N-1}$ (单位: MPa)，\n以及一个标量 $\\mu$。\n\n您必须应用您的分类和事件检测算法，返回状态在粘滞和滑动之间变化的索引 $i$ 的列表。忽略与张开状态之间的转换。使用以下五个测试用例：\n\n- 测试用例 1 (基线：粘滞到滑动再到粘滞)：\n  - $\\mu = 0.6$，\n  - $N = 12$，\n  - $p_{n,i} = 2.0$ MPa (对所有 $i$)，\n  - $\\|\\boldsymbol{v}_t\\| = [0.0, 2\\times 10^{-6}, 4\\times 10^{-6}, 8\\times 10^{-6}, 2\\times 10^{-4}, 4\\times 10^{-4}, 3\\times 10^{-4}, 1\\times 10^{-4}, 5\\times 10^{-6}, 3\\times 10^{-6}, 1\\times 10^{-6}, 2\\times 10^{-6}]$ m/s，\n  - $t_t = [0.5, 0.8, 1.0, 1.15, 1.1995, 1.18, 1.17, 1.10, 0.9, 0.6, 0.5, 0.4]$ MPa。\n\n- 测试用例 2 (阈值擦边与颤振抑制)：\n  - $\\mu = 0.6$，\n  - $N = 9$，\n  - $p_{n,i} = 1.5$ MPa (对所有 $i$)，\n  - $\\|\\boldsymbol{v}_t\\| = [8\\times 10^{-6}, 1.2\\times 10^{-5}, 9\\times 10^{-6}, 1.1\\times 10^{-5}, 9\\times 10^{-6}, 1.05\\times 10^{-5}, 7\\times 10^{-6}, 6\\times 10^{-6}, 5\\times 10^{-6}]$ m/s，\n  - $t_t = [0.89, 0.905, 0.895, 0.902, 0.897, 0.899, 0.84, 0.83, 0.82]$ MPa。\n\n- 测试用例 3 (接触丢失与恢复；仅计算粘滑转换)：\n  - $\\mu = 0.5$，\n  - $N = 11$，\n  - $p_n = [2.0, 2.0, 2.0, 0.0, 0.0, 0.0, 1.5, 1.5, 1.5, 1.5, 1.5]$ MPa，\n  - $\\|\\boldsymbol{v}_t\\| = [1\\times 10^{-6}, 2\\times 10^{-6}, 3\\times 10^{-6}, 1\\times 10^{-4}, 2\\times 10^{-4}, 1\\times 10^{-4}, 5\\times 10^{-4}, 4\\times 10^{-4}, 3\\times 10^{-4}, 5\\times 10^{-6}, 4\\times 10^{-6}]$ m/s，\n  - $t_t = [0.6, 0.65, 0.70, 0.0, 0.0, 0.0, 0.74, 0.76, 0.72, 0.70, 0.60]$ MPa。\n\n- 测试用例 4 (始终粘滞)：\n  - $\\mu = 0.5$，\n  - $N = 8$，\n  - $p_{n,i} = 2.0$ MPa (对所有 $i$)，\n  - $\\|\\boldsymbol{v}_t\\|_i = 1\\times 10^{-6}$ m/s (对所有 $i$)，\n  - $t_{t,i} = 0.6$ MPa (对所有 $i$)。\n\n- 测试用例 5 (始终滑动)：\n  - $\\mu = 0.7$，\n  - $N = 8$，\n  - $p_{n,i} = 1.5$ MPa (对所有 $i$)，\n  - $\\|\\boldsymbol{v}_t\\|_i = 2\\times 10^{-4}$ m/s (对所有 $i$)，\n  - $t_{t,i} = 1.06$ MPa (对所有 $i$)。\n\n算法输出规范：\n- 对于每个测试用例，返回一个整数列表，指示活动集在“粘滞”和“滑动”之间切换的索引 $i$。索引是从零开始的，并指向给定数组中的时间步索引。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个列表（例如，$[[i_1,i_2],[j_1],[],\\dots]$）。不得打印任何额外文本。\n\n科学真实性约束：\n- 确保分类和转换遵循库仑锥、法向接触激活条件以及上述指定的容差和滞后机制。\n- 不要将与“张开”状态之间的转换计为粘滑事件；只计算“粘滞”到“滑动”或“滑动”到“粘滞”的转换。\n\n您的任务：\n- 从基本基础推导分类和事件准则。\n- 实现该算法，并在上述测试套件上运行它。\n- 严格按照指定格式生成最终输出。", "solution": "该问题要求设计并实现一种算法，用于检测单个节点摩擦界面上的粘滑转换。算法的设计必须严格地从库仑摩擦的基本原理推导出来，并且必须包含数值容差和滞后机制以确保对颤振的鲁棒性。解决方案按要求分为三部分呈现：状态分类准则的推导、滞后结构的论证以及事件检测规则的定义。\n\n### 1. 状态分类准则的推导\n\n在任何给定的时间步 $i$，摩擦界面的状态可分为“张开”(open)、“粘滞”(stick)或“滑动”(slip)。此分类基于法向牵引力 $p_{n,i}$、切向牵引力大小 $t_{t,i}$、切向相对速度大小 $\\|\\boldsymbol{v}_t\\|_i$ 以及摩擦系数 $\\mu$。给定的数值容差 $p_{\\mathrm{open}}$、$v_{\\mathrm{tol}}$、$\\tau_{\\mathrm{tol}}$ 和滞后因子 $h$ 被引入以创建一个鲁棒的数值方案。\n\n**状态定义：**\n分类逻辑建立在三种状态的物理定义之上：\n1.  **张开 (Open)：** 界面未接触，因此不传递摩擦力。这发生在法向压缩牵引力为零或为拉伸时。在数值上，使用容差 $p_{\\mathrm{open}}$ 进行检查。\n    - 如果 $p_{n,i} \\le p_{\\mathrm{open}}$，则状态明确为“张开”。此检查具有最高优先级。\n\n2.  **粘滞 (Stick)：** 界面处于接触状态，但没有相对切向运动。切向牵引力低于摩擦强度。形式化条件为 $\\|\\boldsymbol{v}_t\\| = 0$ 且 $t_t  \\mu p_n$。\n\n3.  **滑动 (Slip)：** 界面处于接触状态，并且存在相对切向运动。切向牵引力等于摩擦强度。形式化条件为 $\\|\\boldsymbol{v}_t\\| > 0$ 且 $t_t = \\mu p_n$。\n\n**滞后分类算法：**\n为了防止系统状态在粘滑转换边界附近时出现数值颤振，采用了滞后逻辑。当前时间步 $i$ 的状态取决于前一时间步 $i-1$ 的状态。令 $S_i = \\mu p_{n,i}$ 表示在时间步 $i$ 的摩擦强度。\n\n**初始状态 ($i=0$)：**\n对于第一个时间步，没有先前的状态。使用非滞后规则来初始化状态。\n1.  如果 $p_{n,0} \\le p_{\\mathrm{open}}$，则 $\\text{State}_0 = \\text{'open'}$。\n2.  否则，如果满足滑动的条件，即 $\\|\\boldsymbol{v}_t\\|_0 > v_{\\mathrm{tol}}$ 且 $t_{t,0} \\ge S_0 - \\tau_{\\mathrm{tol}}$，则 $\\text{State}_0 = \\text{'slip'}$。\n3.  否则，$\\text{State}_0 = \\text{'stick'}$。\n\n**后续状态 ($i > 0$)：**\n对于所有后续时间步，分类取决于 $\\text{State}_{i-1}$。\n\n1.  **张开检查：** 如果 $p_{n,i} \\le p_{\\mathrm{open}}$，则 $\\text{State}_i = \\text{'open'}$。此条件覆盖所有其他条件。\n\n2.  **接触逻辑 (如果 $p_{n,i} > p_{\\mathrm{open}}$):**\n    a.  **如果 $\\text{State}_{i-1}$ 是 'slip'：** 系统当前正在滑动。要转换回 'stick'，必须满足一个严格的条件以确保稳定性。这涉及速度在数值上变为零，并且牵引力显著下降到摩擦极限以下，由滞后因子 $h$ 控制。\n        - **滑动到粘滞的转换条件 (严格)：**\n        $$ (\\|\\boldsymbol{v}_t\\|_i \\le v_{\\mathrm{tol}}) \\land (t_{t,i}  (1-h) S_i) $$\n        如果此条件为真，则 $\\text{State}_i = \\text{'stick'}$。否则，状态保持为 $\\text{State}_i = \\text{'slip'}$。\n\n    b.  **如果 $\\text{State}_{i-1}$ 是 'stick' 或 'open'：** 系统当前未在滑动。要转换到 'slip'，使用一个较宽松的条件，代表一旦速度非零且牵引力达到极限，滑动即开始。\n        - **粘滞到滑动的转换条件 (宽松)：**\n        $$ (\\|\\boldsymbol{v}_t\\|_i > v_{\\mathrm{tol}}) \\land (t_{t,i} \\ge S_i - \\tau_{\\mathrm{tol}}) $$\n        如果此条件为真，则 $\\text{State}_i = \\text{'slip'}$。否则，状态变为或保持为 $\\text{State}_i = \\text{'stick'}$。\n\n这套规则提供了从输入时间序列数据到状态序列的完整且鲁棒的映射。\n\n### 2. 滞后结构的指定和论证\n\n通过使用不同的阈值进入和退出“滑动”状态，滞后机制被明确地构建到状态分类逻辑中。\n\n-   **进入滑动的条件 (从 'stick' 或 'open')：** 如果切向速度超过容差 $v_{\\mathrm{tol}}$ 并且切向牵引力达到摩擦强度 $S_i$（在数值容差 $\\tau_{\\mathrm{tol}}$ 范围内），则发生向“滑动”的转换。牵引力阈值为 $T_{\\text{slip}} = S_i - \\tau_{\\mathrm{tol}}$。\n\n-   **退出滑动的条件 (到 'stick')：** 仅当切向速度降至 $v_{\\mathrm{tol}}$ 以下且切向牵引力大幅降至摩擦强度以下时，才会发生回到“粘滞”的转换。牵引力阈值为 $T_{\\text{stick}} = (1-h) S_i$。\n\n**论证：**\n对于指定的参数 $h=0.05$ 和一个非零的 $S_i$，重新粘滞的牵引力阈值 $T_{\\text{stick}} = (1-h)S_i = 0.95 S_i$ 显著低于滑动阈值 $T_{\\text{slip}} \\approx S_i$。这产生了一个宽度为 $\\Delta T = T_{\\text{slip}} - T_{\\text{stick}} \\approx h S_i + \\tau_{tol}$ 的“滞后间隙”或“死区”。\n\n如果系统变量 $(t_{t,i}, \\|\\boldsymbol{v}_t\\|_i)$ 在滑动边界 $(S_i, v_{\\mathrm{tol}})$ 附近振荡，这个间隙可以防止在“粘滞”和“滑动”状态之间发生快速、非物理的切换（即颤振）。例如，一旦系统进入“滑动”状态，牵引力必须一直下降到 $T_{\\text{stick}}$ 才能重新粘滞。一个使 $t_{t,i}$ 略低于 $S_i$ 的小波动不会导致转换回“粘滞”状态，从而确保对系统状态进行更稳定且具有物理意义的分类。\n\n### 3. 事件检测规则\n\n事件被定义为“粘滞”和“滑动”之间活动集的改变。与“张开”状态之间的转换被忽略。检测这些事件的算法如下：\n\n1.  **状态分类：** 首先，通过将第1部分中描述的滞后分类算法应用于整个输入数据集，生成完整的状态时间序列 $[\\text{State}_0, \\text{State}_1, \\dots, \\text{State}_{N-1}]$。将此数组表示为 $\\mathbf{C}$。\n\n2.  **转换检测：** 从第二个元素开始遍历状态数组，即对于从 $1$ 到 $N-1$ 的 $i$。在每个步骤中，将当前状态 $\\mathbf{C}_i$ 与前一个状态 $\\mathbf{C}_{i-1}$进行比较。\n\n3.  **事件过滤：** 当且仅当状态变化满足以下两个标准之一时，索引 $i$ 被记录为粘滑事件索引：\n    - $(\\mathbf{C}_{i-1} = \\text{'stick'}) \\land (\\mathbf{C}_i = \\text{'slip'})$\n    - $(\\mathbf{C}_{i-1} = \\text{'slip'}) \\land (\\mathbf{C}_i = \\text{'stick'})$\n\n4.  **输出：** 对于给定的测试用例，最终输出是满足事件过滤标准的所有索引 $i$ 的有序列表。如果没有发生此类转换，则输出为空列表。", "answer": "```python\nimport numpy as np\n\ndef detect_stick_slip_events(mu, p_n, v_t, t_t):\n    \"\"\"\n    Detects stick-slip transition events based on Coulomb friction with hysteresis.\n\n    Args:\n        mu (float): Friction coefficient.\n        p_n (np.ndarray): Array of normal tractions (MPa).\n        v_t (np.ndarray): Array of tangential velocity magnitudes (m/s).\n        t_t (np.ndarray): Array of tangential traction magnitudes (MPa).\n\n    Returns:\n        list[int]: A list of zero-based indices where stick-slip transitions occur.\n    \"\"\"\n    # Numerical specifications\n    v_tol = 1e-5  # m/s\n    tau_tol = 1e-3  # MPa\n    h = 0.05\n    p_open = 1e-9  # MPa\n\n    N = len(p_n)\n    if N == 0:\n        return []\n\n    states = [\"\"] * N\n    \n    # --- Step 1: State Classification ---\n\n    # Initial state at i=0 (non-hysteretic rule)\n    if p_n[0] = p_open:\n        states[0] = \"open\"\n    else:\n        s_0 = mu * p_n[0]\n        # Check for slip condition\n        if v_t[0] > v_tol and t_t[0] >= s_0 - tau_tol:\n            states[0] = \"slip\"\n        else:\n            states[0] = \"stick\"\n\n    # Subsequent states from i=1 to N-1 (hysteretic rule)\n    for i in range(1, N):\n        prev_state = states[i-1]\n        \n        # Priority 1: Check for open contact\n        if p_n[i] = p_open:\n            states[i] = \"open\"\n            continue\n\n        s_i = mu * p_n[i]\n        \n        # Hysteretic logic for contact states\n        if prev_state == \"slip\":\n            # Check for transition to stick (strict condition)\n            stick_threshold = (1 - h) * s_i\n            if v_t[i] = v_tol and t_t[i]  stick_threshold:\n                states[i] = \"stick\"\n            else:\n                states[i] = \"slip\"\n        \n        elif prev_state == \"stick\" or prev_state == \"open\":\n            # Check for transition to slip (lenient condition)\n            slip_threshold = s_i - tau_tol\n            if v_t[i] > v_tol and t_t[i] >= slip_threshold:\n                states[i] = \"slip\"\n            else:\n                states[i] = \"stick\"\n\n    # --- Step 2: Event Detection ---\n    events = []\n    for i in range(1, N):\n        prev_state = states[i-1]\n        curr_state = states[i]\n\n        is_stick_to_slip = (prev_state == \"stick\" and curr_state == \"slip\")\n        is_slip_to_stick = (prev_state == \"slip\" and curr_state == \"stick\")\n\n        if is_stick_to_slip or is_slip_to_stick:\n            events.append(i)\n\n    return events\n\n\ndef solve():\n    \"\"\"\n    Runs the stick-slip detection algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"mu\": 0.6,\n            \"p_n\": np.full(12, 2.0),\n            \"v_t\": np.array([0.0, 2e-6, 4e-6, 8e-6, 2e-4, 4e-4, 3e-4, 1e-4, 5e-6, 3e-6, 1e-6, 2e-6]),\n            \"t_t\": np.array([0.5, 0.8, 1.0, 1.15, 1.1995, 1.18, 1.17, 1.10, 0.9, 0.6, 0.5, 0.4])\n        },\n        # Test case 2\n        {\n            \"mu\": 0.6,\n            \"p_n\": np.full(9, 1.5),\n            \"v_t\": np.array([8e-6, 1.2e-5, 9e-6, 1.1e-5, 9e-6, 1.05e-5, 7e-6, 6e-6, 5e-6]),\n            \"t_t\": np.array([0.89, 0.905, 0.895, 0.902, 0.897, 0.899, 0.84, 0.83, 0.82])\n        },\n        # Test case 3\n        {\n            \"mu\": 0.5,\n            \"p_n\": np.array([2.0, 2.0, 2.0, 0.0, 0.0, 0.0, 1.5, 1.5, 1.5, 1.5, 1.5]),\n            \"v_t\": np.array([1e-6, 2e-6, 3e-6, 1e-4, 2e-4, 1e-4, 5e-4, 4e-4, 3e-4, 5e-6, 4e-6]),\n            \"t_t\": np.array([0.6, 0.65, 0.70, 0.0, 0.0, 0.0, 0.74, 0.76, 0.72, 0.70, 0.60])\n        },\n        # Test case 4\n        {\n            \"mu\": 0.5,\n            \"p_n\": np.full(8, 2.0),\n            \"v_t\": np.full(8, 1e-6),\n            \"t_t\": np.full(8, 0.6)\n        },\n        # Test case 5\n        {\n            \"mu\": 0.7,\n            \"p_n\": np.full(8, 1.5),\n            \"v_t\": np.full(8, 2e-4),\n            \"t_t\": np.full(8, 1.06)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = detect_stick_slip_events(case[\"mu\"], case[\"p_n\"], case[\"v_t\"], case[\"t_t\"])\n        all_results.append(str(result))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3512299"}]}