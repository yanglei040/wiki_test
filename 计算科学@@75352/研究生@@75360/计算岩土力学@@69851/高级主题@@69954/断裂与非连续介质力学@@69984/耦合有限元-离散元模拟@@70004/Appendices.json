{"hands_on_practices": [{"introduction": "在任何有限元-离散元（FEM-DEM）耦合模拟中，一个基本步骤是确定给定的离散颗粒位于哪个有限元单元内。这听起来很简单，但浮点运算中固有的数值不精确性可能导致错误的分类，特别是当颗粒靠近单元边界或网格中存在形状不佳（例如，“狭长”的）单元时。本练习 [@problem_id:3512704] 将挑战您超越简单的几何测试，通过基于数值分析推导容差，来实现一个稳健的颗粒定位算法，以确保计算的准确性。", "problem": "考虑在二维空间中将一个离散元法（DEM）粒子耦合到有限元法（FEM）网格上。FEM网格由线性三角形单元组成，每个单元由平面上的三个顶点坐标定义。一个位于位置 $\\mathbf{p} \\in \\mathbb{R}^2$ 的DEM粒子通过识别其所在的FEM单元并计算相对于该单元的重心坐标来定位。使用以下基本原理：相对于三角形顶点 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的重心坐标 $\\lambda_a$、$\\lambda_b$ 和 $\\lambda_c$ 满足 $\\mathbf{p} = \\lambda_a \\mathbf{a} + \\lambda_b \\mathbf{b} + \\lambda_c \\mathbf{c}$ 和 $\\lambda_a + \\lambda_b + \\lambda_c = 1$，并且一个点在三角形内部的充分必要条件是其所有重心坐标均为非负值。在浮点运算中，舍入误差会扰动计算出的重心坐标，可能导致在单元边界附近出现错误分类。请设计一个鲁棒的算法，该算法使用重心坐标在网格内定位 $\\mathbf{p}$，并基于矩阵条件和机器精度推导出一个容差，以避免在边界处发生错误分类。\n\n您的任务是：\n- 通过求解重心坐标的后向误差分析推导出分类容差。设 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 为三角形顶点，设 $\\mathbf{A} = [\\mathbf{b}-\\mathbf{a}, \\mathbf{c}-\\mathbf{a}] \\in \\mathbb{R}^{2 \\times 2}$，并设 $\\mathbf{x} = [\\lambda_b, \\lambda_c]^\\top$。重心坐标由 $\\mathbf{A}\\mathbf{x} = \\mathbf{p}-\\mathbf{a}$ 和 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$ 得出。使用带有单位舍入误差 $u$ 的标准浮点模型，推导出一个界限 $\\tau$，该界限依赖于谱条件数 $\\kappa_2(\\mathbf{A})$、范数 $\\|\\mathbf{A}\\|_2$ 和 $\\|\\mathbf{p}-\\mathbf{a}\\|_2$ 以及 $u$，使得如果一个真实的重心坐标满足 $|\\lambda_i| \\le \\tau$（对于 $i \\in \\{a,b,c\\}$），则计算出的坐标的符号可能被舍入误差破坏，导致简单的符号测试出现错误分类。\n- 实现一个鲁棒的定位器，对于每个三角形，该定位器计算重心坐标，评估推导出的容差 $\\tau$，并在所有坐标都满足 $\\lambda_i \\ge -\\tau$ 且坐标和满足 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le 3\\tau$ 时，将点分类为在该三角形内部。如果由于靠近边界，多个相邻的三角形都满足鲁棒性准则，则选择使最小重心坐标 $\\min(\\lambda_a, \\lambda_b, \\lambda_c)$ 最大化的三角形；若仍有并列，则按最小的三角形索引来选择。\n- 实现一个简单的定位器，仅当所有 $\\lambda_i \\ge 0$ 且 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le \\delta$（其中 $\\delta$ 是一个固定的微小阈值）时，才将点分类为在三角形内部，并选择第一个通过此测试的三角形；否则，不返回任何三角形。\n- 对于提供的测试套件中的每个测试用例，返回鲁棒定位器选择的三角形的整数索引和一个布尔值，该布尔值指示简单定位器相对于鲁棒定位器是否错误分类（即，简单定位器未返回三角形或返回了与鲁棒定位器不同的三角形索引）。\n\n不涉及物理单位；所有量均为无量纲。不使用角度。布尔值表示为字面量 $\\text{True}$ 或 $\\text{False}$，整数为十进制形式，浮点数为十进制形式。\n\n测试套件：\n- 网格 $\\mathcal{M}_1$，包含索引为 $0$ 和 $1$ 的三角形：\n  - 三角形 $0$：顶点 $\\mathbf{a} = (0,0)$、$\\mathbf{b} = (1,0)$、$\\mathbf{c} = (1,1)$。\n  - 三角形 $1$：顶点 $\\mathbf{a} = (0,0)$、$\\mathbf{b} = (1,1)$、$\\mathbf{c} = (0,1)$。\n  - 点 $\\mathbf{p}_1 = (0.7, 0.2)$，一个普通的内部点情况。\n  - 点 $\\mathbf{p}_2 = (0.5, 0.5)$，恰好位于三角形 $0$ 和 $1$ 之间的共享对角线边界上。\n- 网格 $\\mathcal{M}_2$，包含索引为 $0$ 的三角形：\n  - 三角形 $0$：顶点 $\\mathbf{a} = (0,0)$、$\\mathbf{b} = (10^{-8}, 0)$、$\\mathbf{c} = (0, 1)$，一个非常细长的单元。\n  - 点 $\\mathbf{p}_3 = (0, 0.5)$，位于长边 $\\overline{\\mathbf{a}\\mathbf{c}}$ 上。\n  - 点 $\\mathbf{p}_4 = (0, 0)$，恰好在顶点 $\\mathbf{a}$ 处。\n- 网格 $\\mathcal{M}_3$，包含索引为 $0$ 的三角形：\n  - 三角形 $0$：顶点 $\\mathbf{a} = (0,0)$、$\\mathbf{b} = (2, 0)$、$\\mathbf{c} = (2, 2 \\cdot 10^{-12})$，另一个几乎共线的极端细长单元。\n  - 点 $\\mathbf{p}_5 = (1, 10^{-12})$，靠近边 $\\overline{\\mathbf{a}\\mathbf{b}}$。\n\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形如 $[i, b]$ 的子列表，其中 $i$ 是选择的鲁棒三角形索引（一个整数），$b$ 是错误分类的布尔值。对于所描述的五个测试用例，您的输出必须严格遵循以下格式：\n$[[i_1,b_1],[i_2,b_2],[i_3,b_3],[i_4,b_4],[i_5,b_5]]$。", "solution": "用户要求设计并实现一个鲁棒的算法，用于在二维三角形网格中定位一个点，同时考虑到浮点数的不精确性。这涉及到基于后向误差分析为重心坐标分类推导一个容差。\n\n### 问题验证\n\n问题陈述已经过验证，被认为是**有效的**。它在计算几何和数值线性代数方面具有科学依据，是适定的、客观的且自包含的。虽然简单定位器的容差 $\\delta$ 没有给定具体值，但它被描述为一个“固定的微小阈值”，对此使用机器ε是一个标准且合理的选择。鲁棒方法中对重心坐标和的检查 $|\\sum \\lambda_i - 1| \\le 3\\tau$ 比根据指定的 $\\lambda_a$ 计算方法所必需的更为宽松，但这并不构成致命的矛盾，可以按规定实现。\n\n### 第1部分：分类容差 $\\tau$ 的推导\n\n粒子 $\\mathbf{p} \\in \\mathbb{R}^2$ 的位置可以用三角形顶点 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 通过重心坐标 $\\lambda_a$、$\\lambda_b$ 和 $\\lambda_c$ 来表示：\n$$ \\mathbf{p} = \\lambda_a \\mathbf{a} + \\lambda_b \\mathbf{b} + \\lambda_c \\mathbf{c} $$\n并满足约束条件：\n$$ \\lambda_a + \\lambda_b + \\lambda_c = 1 $$\n一个点 $\\mathbf{p}$ 在三角形内部或边界上的充分必要条件是对于 $i \\in \\{a,b,c\\}$，都有 $0 \\le \\lambda_i \\le 1$。\n\n按照规定，我们可以通过求解一个 $2 \\times 2$ 线性系统来找到 $\\lambda_b$ 和 $\\lambda_c$。将 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$ 代入位置方程得：\n$$ \\mathbf{p} = (1 - \\lambda_b - \\lambda_c)\\mathbf{a} + \\lambda_b \\mathbf{b} + \\lambda_c \\mathbf{c} $$\n$$ \\mathbf{p} - \\mathbf{a} = \\lambda_b (\\mathbf{b} - \\mathbf{a}) + \\lambda_c (\\mathbf{c} - \\mathbf{a}) $$\n这可以写成矩阵形式 $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$，其中：\n$$ \\mathbf{A} = \\begin{bmatrix} \\mathbf{b} - \\mathbf{a}  \\mathbf{c} - \\mathbf{a} \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 2}, \\quad \\mathbf{x} = \\begin{bmatrix} \\lambda_b \\\\ \\lambda_c \\end{bmatrix}, \\quad \\mathbf{y} = \\mathbf{p} - \\mathbf{a} $$\n当使用浮点运算求解这个系统时，计算出的真解 $\\mathbf{x}$ 的解 $\\hat{\\mathbf{x}}$ 将包含误差。求解线性系统的标准后向误差分析（例如，使用带部分主元 pivoting 的 LU 分解）指出，计算解 $\\hat{\\mathbf{x}}$ 是一个扰动系统的精确解：\n$$ (\\mathbf{A} + \\mathbf{E})\\hat{\\mathbf{x}} = \\mathbf{y} $$\n其中 $\\mathbf{E}$ 是后向误差矩阵。$\\mathbf{E}$ 的范数的一个标准界限由下式给出：\n$$ \\|\\mathbf{E}\\|_2 \\le C_s u \\|\\mathbf{A}\\|_2 $$\n其中 $u$ 是单位舍入误差（机器ε），$C_s$ 是一个小的常数，取决于维度（$n=2$）和求解器的稳定性（例如，与增长因子相关，对于 $n=2$ 来说很小）。\n\n前向误差 $\\delta\\mathbf{x} = \\hat{\\mathbf{x}} - \\mathbf{x}$ 可以被界定。从 $\\mathbf{x} = \\mathbf{A}^{-1}\\mathbf{y}$ 和 $\\hat{\\mathbf{x}} = (\\mathbf{A}+\\mathbf{E})^{-1}\\mathbf{y}$，我们有：\n$$ \\hat{\\mathbf{x}} - \\mathbf{x} = ((\\mathbf{A}+\\mathbf{E})^{-1} - \\mathbf{A}^{-1})\\mathbf{y} \\approx -\\mathbf{A}^{-1}\\mathbf{E}\\mathbf{A}^{-1}\\mathbf{y} = -\\mathbf{A}^{-1}\\mathbf{E}\\mathbf{x} $$\n取范数，我们得到前向误差的一个界限：\n$$ \\|\\delta\\mathbf{x}\\|_2 = \\|\\hat{\\mathbf{x}} - \\mathbf{x}\\|_2 \\le \\|\\mathbf{A}^{-1}\\|_2 \\|\\mathbf{E}\\|_2 \\|\\mathbf{x}\\|_2 $$\n代入 $\\|\\mathbf{E}\\|_2$ 的界限：\n$$ \\|\\delta\\mathbf{x}\\|_2 \\le \\|\\mathbf{A}^{-1}\\|_2 (C_s u \\|\\mathbf{A}\\|_2) \\|\\mathbf{x}\\|_2 = C_s u (\\|\\mathbf{A}\\|_2 \\|\\mathbf{A}^{-1}\\|_2) \\|\\mathbf{x}\\|_2 $$\n$$ \\|\\delta\\mathbf{x}\\|_2 \\le C_s u \\kappa_2(\\mathbf{A}) \\|\\mathbf{x}\\|_2 $$\n其中 $\\kappa_2(\\mathbf{A}) = \\|\\mathbf{A}\\|_2 \\|\\mathbf{A}^{-1}\\|_2$ 是 $\\mathbf{A}$ 的谱条件数。\n\n$\\mathbf{x}$ 各分量（即 $\\delta\\lambda_b$ 和 $\\delta\\lambda_c$）的误差受误差向量范数的限制：$\\max (|\\delta\\lambda_b|, |\\delta\\lambda_c|) \\le \\|\\delta\\mathbf{x}\\|_2$。\n$\\lambda_a$ 的误差由其定义 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$ 推导。计算值为 $\\hat{\\lambda}_a = 1 - \\hat{\\lambda}_b - \\hat{\\lambda}_c$（在此步骤中为精确计算）。误差为：\n$$ \\delta\\lambda_a = \\hat{\\lambda}_a - \\lambda_a = (1 - \\hat{\\lambda}_b - \\hat{\\lambda}_c) - (1 - \\lambda_b - \\lambda_c) = -(\\hat{\\lambda}_b - \\lambda_b) - (\\hat{\\lambda}_c - \\lambda_c) = -(\\delta\\lambda_b + \\delta\\lambda_c) $$\n此误差的大小有界：\n$$ |\\delta\\lambda_a| \\le |\\delta\\lambda_b| + |\\delta\\lambda_c| \\le \\sqrt{2}\\sqrt{(\\delta\\lambda_b)^2 + (\\delta\\lambda_c)^2} = \\sqrt{2}\\|\\delta\\mathbf{x}\\|_2 $$\n因此，所有三个重心坐标上的最大误差由 $\\sqrt{2}\\|\\delta\\mathbf{x}\\|_2$ 界定。我们将容差 $\\tau$ 定义为此最大误差的一个安全上界：\n$$ \\tau = \\sqrt{2} \\|\\delta\\mathbf{x}\\|_2 \\le \\sqrt{2} C_s u \\kappa_2(\\mathbf{A}) \\|\\mathbf{x}\\|_2 $$\n由于真解 $\\mathbf{x}$ 未知，我们使用计算解 $\\hat{\\mathbf{x}}$ 作为近似，即 $\\|\\mathbf{x}\\|_2 \\approx \\|\\hat{\\mathbf{x}}\\|_2$。我们选择一个相当保守的常数 $C = \\sqrt{2}C_s$。对于一个 $2 \\times 2$ 系统，选择如 $C=6$ 是足够的。这导出了容差 $\\tau$ 的最终公式：\n$$ \\tau = C u \\kappa_2(\\mathbf{A}) \\|\\hat{\\mathbf{x}}\\|_2 = C u \\kappa_2(\\mathbf{A}) \\left\\| \\begin{bmatrix} \\hat{\\lambda}_b \\\\ \\hat{\\lambda}_c \\end{bmatrix} \\right\\|_2 $$\n这个 $\\tau$ 的表达式依赖于单位舍入误差 $u$、条件数 $\\kappa_2(\\mathbf{A})$ 和计算解向量的范数，而后者又依赖于 $\\mathbf{A}$ 和 $\\mathbf{p}-\\mathbf{a}$。这满足了所有要求。\n\n### 第2部分：算法设计\n\n**鲁棒定位器算法：**\n对于网格中的每个三角形：\n1.  构建矩阵 $\\mathbf{A} = [\\mathbf{b}-\\mathbf{a}, \\mathbf{c}-\\mathbf{a}]$ 和向量 $\\mathbf{y} = \\mathbf{p}-\\mathbf{a}$。\n2.  尝试求解 $\\mathbf{A}\\mathbf{x} = \\mathbf{y}$ 以获得 $\\mathbf{x} = [\\lambda_b, \\lambda_c]^\\top$。如果矩阵是奇异的，则该点无法在此三角形中定位。\n3.  计算 $\\lambda_a = 1 - \\lambda_b - \\lambda_c$。\n4.  计算容差 $\\tau = C u \\kappa_2(\\mathbf{A}) \\|\\mathbf{x}\\|_2$，其中 $C=6$，u 是机器ε。\n5.  如果所有重心坐标 $\\lambda_i$ 都满足 $\\lambda_i \\ge -\\tau$ 并且和的条件 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le 3\\tau$ 成立，则将该点分类为“鲁棒地处于内部”。\n6.  维护一个满足此鲁棒性准则的所有三角形的列表。\n7.  如果找到一个或多个候选三角形，则选择使最小重心坐标 $\\min(\\lambda_a, \\lambda_b, \\lambda_c)$ 最大化的那个。通过选择具有最小三角形索引的候选者来打破任何并列。如果没有三角形满足该准则，则返回一个指示未找到三角形的标志（例如，索引-1）。\n\n**简单定位器算法：**\n对于网格中的每个三角形，按索引顺序：\n1.  如上所述计算重心坐标 $(\\lambda_a, \\lambda_b, \\lambda_c)$。\n2.  如果对于所有 $i \\in \\{a, b, c\\}$ 都有 $\\lambda_i \\ge 0$ 并且 $|\\lambda_a + \\lambda_b + \\lambda_c - 1| \\le \\delta$（其中 $\\delta$ 是一个固定的微小阈值，我们使用 $\\delta = u$），则将点分类为内部点。\n3.  返回第一个通过此测试的三角形的索引。\n4.  如果循环完成而没有找到这样的三角形，则返回一个指示未找到三角形的标志。\n\n这一对算法可以直接比较简单的几何测试与数值上鲁棒的测试，突显出对于靠近病态（细长）单元边界的点发生的错误分类。", "answer": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\n# Type definitions for clarity\nPoint = Tuple[float, float]\nTriangle = Tuple[Point, Point, Point]\nMesh = List[Triangle]\n\ndef calculate_barycentric_coords(triangle: Triangle, point: Point):\n    \"\"\"\n    Computes barycentric coordinates of a point w.r.t. a triangle.\n    \n    The coordinates (lambda_a, lambda_b, lambda_c) for a point p and triangle\n    vertices (a,b,c) are found by solving the linear system derived from:\n    p = lambda_a*a + lambda_b*b + lambda_c*c\n    1 = lambda_a + lambda_b + lambda_c\n\n    This leads to A*x = y, where:\n    A = [b-a, c-a]\n    x = [lambda_b, lambda_c]^T\n    y = p-a\n    and lambda_a = 1 - lambda_b - lambda_c.\n\n    Returns:\n        A tuple containing:\n        - np.ndarray: The array of barycentric coordinates [lambda_a, lambda_b, lambda_c].\n        - np.ndarray: The matrix A used in the calculation.\n        - np.ndarray: The solution vector x = [lambda_b, lambda_c].\n        Returns (None, None, None) if the system is not solvable.\n    \"\"\"\n    a, b, c = np.array(triangle[0]), np.array(triangle[1]), np.array(triangle[2])\n    p = np.array(point)\n\n    # Form the linear system A*x = y, with A being a 2x2 matrix\n    mat_a = np.array([b - a, c - a]).T\n    vec_y = p - a\n\n    try:\n        # Solve for x = [lambda_b, lambda_c]\n        x_c = np.linalg.solve(mat_a, vec_y)\n        lambda_b_c = x_c[0]\n        lambda_c_c = x_c[1]\n\n        # Calculate the third coordinate based on the sum-to-one property\n        lambda_a_c = 1.0 - lambda_b_c - lambda_c_c\n        \n        lambdas = np.array([lambda_a_c, lambda_b_c, lambda_c_c])\n        return lambdas, mat_a, x_c\n    except np.linalg.LinAlgError:\n        # Matrix is singular or near-singular. Point cannot be uniquely located in this element.\n        return None, None, None\n\ndef locate_robust(mesh: Mesh, point: Point) -> int:\n    \"\"\"\n    Finds the triangle containing the point using a robust classification method.\n    The method uses a dynamically computed tolerance `tau` based on matrix\n    conditioning to avoid misclassification near element boundaries.\n    \"\"\"\n    candidate_triangles = []\n    u = np.finfo(float).eps\n\n    for i, tri in enumerate(mesh):\n        lambdas, mat_a, x_c = calculate_barycentric_coords(tri, point)\n        \n        if lambdas is None:\n            continue\n\n        # Derived tolerance `tau`\n        # tau = C * u * kappa * ||x_c||\n        # A small integer constant C is chosen based on backward error analysis.\n        C = 6.0\n        kappa = np.linalg.cond(mat_a, 2)\n        norm_x = np.linalg.norm(x_c, 2)\n        tau = C * u * kappa * norm_x\n        \n        # Robustness checks\n        sum_check = abs(np.sum(lambdas) - 1.0) = 3 * tau\n        sign_check = np.all(lambdas >= -tau)\n\n        if sum_check and sign_check:\n            candidate_triangles.append({'index': i, 'min_lambda': np.min(lambdas)})\n            \n    if not candidate_triangles:\n        return -1\n\n    # Select the best candidate based on the problem's criteria:\n    # 1. Maximize the minimum barycentric coordinate.\n    # 2. Break ties by the smallest triangle index.\n    # Sorting ensures this: primary key is -min_lambda (so max comes first),\n    # secondary key is the index.\n    sorted_candidates = sorted(candidate_triangles, key=lambda d: (-d['min_lambda'], d['index']))\n    \n    return sorted_candidates[0]['index']\n\n\ndef locate_naive(mesh: Mesh, point: Point) -> int:\n    \"\"\"\n    Finds the triangle containing the point using a naive classification.\n    The method uses a fixed, small tolerance `delta` and a strict non-negativity test.\n    \"\"\"\n    # Per the problem description, `delta` is a fixed tiny threshold.\n    # We choose machine epsilon as a standard value for this.\n    delta = np.finfo(float).eps\n\n    for i, tri in enumerate(mesh):\n        lambdas, _, _ = calculate_barycentric_coords(tri, point)\n        \n        if lambdas is None:\n            continue\n\n        # Naive checks\n        sum_check = abs(np.sum(lambdas) - 1.0) = delta\n        sign_check = np.all(lambdas >= 0.0)\n\n        if sum_check and sign_check:\n            # \"selects the first triangle that passes this test\"\n            return i\n            \n    return -1\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Mesh M1\n    tri0_m1 = ((0.0, 0.0), (1.0, 0.0), (1.0, 1.0))\n    tri1_m1 = ((0.0, 0.0), (1.0, 1.0), (0.0, 1.0))\n    mesh1 = [tri0_m1, tri1_m1]\n    \n    # Mesh M2\n    tri0_m2 = ((0.0, 0.0), (1e-8, 0.0), (0.0, 1.0))\n    mesh2 = [tri0_m2]\n\n    # Mesh M3\n    tri0_m3 = ((0.0, 0.0), (2.0, 0.0), (2.0, 2e-12))\n    mesh3 = [tri0_m3]\n\n    test_cases = [\n        (mesh1, (0.7, 0.2)),    # Case 1: p1, general inside point in M1\n        (mesh1, (0.5, 0.5)),    # Case 2: p2, exactly on shared boundary in M1\n        (mesh2, (0.0, 0.5)),    # Case 3: p3, on long edge of skinny triangle in M2\n        (mesh2, (0.0, 0.0)),    # Case 4: p4, exactly at a vertex in M2\n        (mesh3, (1.0, 1e-12)),  # Case 5: p5, on edge of extremely skinny triangle in M3\n    ]\n    \n    final_results = []\n    \n    for mesh, point in test_cases:\n        robust_idx = locate_robust(mesh, point)\n        naive_idx = locate_naive(mesh, point)\n        \n        # Misclassification occurs if the naive locator fails to find a triangle\n        # or identifies a different one than the robust locator.\n        misclassified = (robust_idx != naive_idx)\n        final_results.append([robust_idx, misclassified])\n        \n    # Format the final output according to the specified single-line format.\n    result_str_list = [f\"[{res[0]}, {str(res[1])}]\" for res in final_results]\n    print(f\"[{','.join(result_str_list)}]\")\n\nsolve()\n```", "id": "3512704"}, {"introduction": "一旦确定了颗粒相对于有限元网格的位置，下一步就是对界面上的物理相互作用进行建模。在这些相互作用中，摩擦接触是最关键和计算最密集的一种，它控制着从断层滑移到土-结构相互作用等多种地质力学现象。本练习 [@problem_id:3512619] 提供了实现一个依赖历史的预测-校正算法的实践经验，用于模拟库仑粘滑摩擦，这是现代计算接触力学的基石。", "problem": "在计算岩土力学中，考虑一个离散元法 (DEM) 颗粒与一个有限元法 (FEM) 边界之间的单点接触。该接触在切向遵循库仑摩擦定律，在切向也遵循线性弹性定律，并通过一个存储的弹性切向位移具有历史依赖性。设状态变量为局部切平面中的弹性切向位移矢量 $\\boldsymbol{\\delta}_t \\in \\mathbb{R}^d$，切向接触力由胡克定律给出：$\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$，其中 $k_t  0$ 是切向接触刚度。库仑摩擦约束要求切向力的大小满足不等式 $\\|\\mathbf{f}_t\\| \\le \\mu f_n$，其中 $\\mu \\ge 0$ 是摩擦系数，$f_n \\ge 0$ 是法向压缩接触力的大小。一个时间步内的增量切向相对位移为 $\\Delta \\mathbf{u}_t \\in \\mathbb{R}^d$。更新必须是历史依赖的：新的弹性切向位移取决于先前的状态和增量。\n\n从与接触力学相关的基本原理和核心定义出发：\n- 牛顿第二定律，\n- 切向胡克定律 $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$，\n- 由容许集 $\\{\\mathbf{f}_t \\in \\mathbb{R}^d \\mid \\|\\mathbf{f}_t\\| \\le \\mu f_n\\}$ 表示的库仑摩擦定律，\n- 黏着状态下切向位移弹性部分的增量运动学可加性，\n\n推导出一个用于切向接触力的预测-校正增量更新法则，该法则在时间步结束时强制执行 $\\|\\mathbf{f}_t\\| \\le \\mu f_n$。预测器应假设纯弹性黏着行为，而校正器应在库仑约束被违反时（黏滑转换），最小化地调整弹性切向位移以满足该约束。您的更新必须：\n- 使用弹性试探状态来预测 $\\boldsymbol{\\delta}_t^{\\text{trial}}$ 和 $\\mathbf{f}_t^{\\text{trial}}$，\n- 通过检查试探力的库仑容许性来判断黏着还是滑动，\n- 在黏着状态下，接受试探状态，\n- 在滑动状态下，校正弹性切向位移，使更新后的力位于边界 $\\|\\mathbf{f}_t\\| = \\mu f_n$ 上，并与试探状态方向一致，确保恢复容许性所需的改变最小。\n\n实现一个程序，为每个测试用例计算更新后的切向力大小 $\\|\\mathbf{f}_t^{n+1}\\|$（单位为牛顿）和一个黏着指示符（黏着时为整数 $1$，滑动时为 $0$）。程序必须接受每个测试用例的以下参数：先前的弹性切向位移 $\\boldsymbol{\\delta}_t^n$（单位为米），增量 $\\Delta \\mathbf{u}_t$（单位为米），切向刚度 $k_t$（单位为牛顿/米），摩擦系数 $\\mu$（无量纲），以及法向力大小 $f_n$（单位为牛顿）。假设切向空间是二维的，即 $d=2$。\n\n以牛顿为单位表示最终的切向力大小，并以整数表示黏着指示符。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果表示为一个列表 $\\left[\\|\\mathbf{f}_t^{n+1}\\|, s\\right]$，其中 $s \\in \\{0,1\\}$。\n\n使用以下六个参数集的测试套件来检验该更新法则，涵盖一般情况、滑动、边界相等、零法向力、非零历史和混合方向滑动。对于每组，列出参数 $\\left(\\boldsymbol{\\delta}_t^n, \\Delta \\mathbf{u}_t, k_t, \\mu, f_n\\right)$：\n\n- 测试 $1$（一般黏着）：$\\boldsymbol{\\delta}_t^n = [0, 0]$ 米，$\\Delta \\mathbf{u}_t = [0.002, 0]$ 米，$k_t = 100000$ 牛顿/米，$\\mu = 0.6$，$f_n = 1000$ 牛顿。\n- 测试 $2$（一般滑动）：$\\boldsymbol{\\delta}_t^n = [0, 0]$ 米，$\\Delta \\mathbf{u}_t = [0.01, 0]$ 米，$k_t = 100000$ 牛顿/米，$\\mu = 0.6$，$f_n = 1000$ 牛顿。\n- 测试 $3$（边界相等）：$\\boldsymbol{\\delta}_t^n = [0, 0]$ 米，$\\Delta \\mathbf{u}_t = [0.006, 0]$ 米，$k_t = 100000$ 牛顿/米，$\\mu = 0.6$，$f_n = 1000$ 牛顿。\n- 测试 $4$（零法向力）：$\\boldsymbol{\\delta}_t^n = [0, 0]$ 米，$\\Delta \\mathbf{u}_t = [0.01, 0]$ 米，$k_t = 100000$ 牛顿/米，$\\mu = 0.6$，$f_n = 0$ 牛顿。\n- 测试 $5$（导致滑动的非零历史）：$\\boldsymbol{\\delta}_t^n = [0.005, 0]$ 米，$\\Delta \\mathbf{u}_t = [0.003, 0]$ 米，$k_t = 100000$ 牛顿/米，$\\mu = 0.6$，$f_n = 1000$ 牛顿。\n- 测试 $6$（混合方向滑动）：$\\boldsymbol{\\delta}_t^n = [0.002, 0.002]$ 米，$\\Delta \\mathbf{u}_t = [0.004, -0.003]$ 米，$k_t = 100000$ 牛顿/米，$\\mu = 0.6$，$f_n = 1000$ 牛顿。\n\n您的程序必须计算每个测试用例更新后的切向力大小 $\\|\\mathbf{f}_t^{n+1}\\|$（单位为牛顿）和作为整数的黏着指示符。程序必须输出一行，其中包含一个逗号分隔的六个结果列表，格式为 $\\left[ [\\|\\mathbf{f}_t^{n+1}\\|, s], \\ldots \\right]$。", "solution": "该问题陈述是有效的，因为它在计算接触力学领域提出了一个适定的、有科学依据的问题，并为其解决提供了所有必要的数据。任务是推导并实现一个预测-校正算法，也称为返回映射算法，用于在库仑摩擦定律下更新切向接触力。\n\n在一个时间步开始时（由上标 $n$ 表示），接触的状态由弹性切向位移矢量 $\\boldsymbol{\\delta}_t^n$ 表征。目标是给定在该时间步内发生的增量切向相对位移 $\\Delta \\mathbf{u}_t$，计算时间步结束时（$n+1$）的更新状态。控制接触的基本方程是切向力的胡克定律 $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$ 和库仑摩擦约束 $\\|\\mathbf{f}_t\\| \\le \\mu f_n$。\n\n推导过程分三个阶段进行：一个假设弹性行为的预测阶段，一个对照摩擦准则的容许性检查，以及一个在违反准则时强制执行该准则的校正阶段。\n\n**1. 预测器：弹性试探状态**\n\n预测步骤假设接触面“黏着”，意味着增量相对位移 $\\Delta \\mathbf{u}_t$ 完全由弹性切向位移的变化来容纳。时间步结束时的试探弹性切向位移 $\\boldsymbol{\\delta}_t^{\\text{trial}}$，是通过将位移增量加到先前的弹性位移上计算得出的：\n$$\n\\boldsymbol{\\delta}_t^{\\text{trial}} = \\boldsymbol{\\delta}_t^n + \\Delta \\mathbf{u}_t\n$$\n其中 $\\boldsymbol{\\delta}_t^n$ 是时间步开始时的弹性切向位移。\n\n使用胡克定律，相应的试探切向接触力 $\\mathbf{f}_t^{\\text{trial}}$ 为：\n$$\n\\mathbf{f}_t^{\\text{trial}} = k_t \\boldsymbol{\\delta}_t^{\\text{trial}}\n$$\n\n**2. 容许性检查：库仑摩擦定律**\n\n库仑摩擦定律定义了一个容许切向力的凸集。一个切向力 $\\mathbf{f}_t$ 是容许的，当且仅当其大小不超过最大静摩擦力，该力与法向接触力大小 $f_n$ 成正比。设 $f_{t,\\text{max}}$ 为此最大大小：\n$$\nf_{t,\\text{max}} = \\mu f_n\n$$\n其中 $\\mu$ 是摩擦系数。请注意，问题将 $f_n$ 作为当前时间步的法向力大小提供，我们将其解释为 $f_n^{n+1}$。容许性条件为：\n$$\n\\|\\mathbf{f}_t\\| \\le f_{t,\\text{max}}\n$$\n我们对试探力 $\\mathbf{f}_t^{\\text{trial}}$ 评估此条件。\n\n**3. 校正器：状态更新**\n\n更新法则取决于容许性检查的结果。\n\n**情况 A：黏着条件**\n\n如果试探力的大小在容许极限内，即：\n$$\n\\|\\mathbf{f}_t^{\\text{trial}}\\| \\le f_{t,\\text{max}}\n$$\n初始的“黏着”假设被验证。接触不发生滑动。时间步 $n+1$ 结束时的最终状态与试探状态相同。黏着指示符 $s$ 设为 $1$。\n- 更新后的弹性切向位移：$\\boldsymbol{\\delta}_t^{n+1} = \\boldsymbol{\\delta}_t^{\\text{trial}}$\n- 更新后的切向力：$\\mathbf{f}_t^{n+1} = \\mathbf{f}_t^{\\text{trial}}$\n- 更新后的切向力大小：$\\|\\mathbf{f}_t^{n+1}\\| = \\|\\mathbf{f}_t^{\\text{trial}}\\|$\n- 黏着指示符：$s = 1$\n\n这种情况也正确处理了边界条件 $\\|\\mathbf{f}_t^{\\text{trial}}\\| = f_{t,\\text{max}}$。\n\n**情况 B：滑动条件**\n\n如果试探力的大小超过容许极限，即：\n$$\n\\|\\mathbf{f}_t^{\\text{trial}}\\|  f_{t,\\text{max}}\n$$\n“黏着”假设无效。接触必须滑动，并发生塑性（不可逆）变形。更新后的切向力 $\\mathbf{f}_t^{n+1}$ 必须位于容许区域的边界（摩擦圆）上。最小变化原则（或者更正式地说，最大塑性耗散原则）规定，校正是通过将试探力径向返回到摩擦圆上进行的。这意味着最终力矢量 $\\mathbf{f}_t^{n+1}$ 与试探力矢量 $\\mathbf{f}_t^{\\text{trial}}$ 方向相同，但其大小被缩减至 $f_{t,\\text{max}}$。黏着指示符 $s$ 设为 $0$。\n\n更新后的力计算如下：\n$$\n\\mathbf{f}_t^{n+1} = f_{t,\\text{max}} \\frac{\\mathbf{f}_t^{\\text{trial}}}{\\|\\mathbf{f}_t^{\\text{trial}}\\|}\n$$\n这可以用一个缩放因子 $\\gamma$ 来表示：\n$$\n\\gamma = \\frac{f_{t,\\text{max}}}{\\|\\mathbf{f}_t^{\\text{trial}}\\|}\n$$\n其中，对于滑动情况，$0 \\le \\gamma  1$。更新后的状态变量为：\n- 更新后的切向力：$\\mathbf{f}_t^{n+1} = \\gamma \\mathbf{f}_t^{\\text{trial}}$\n- 更新后的弹性切向位移：$\\boldsymbol{\\delta}_t^{n+1} = \\gamma \\boldsymbol{\\delta}_t^{\\text{trial}}$\n- 更新后的切向力大小：$\\|\\mathbf{f}_t^{n+1}\\| = f_{t,\\text{max}} = \\mu f_n$\n- 黏着指示符：$s = 0$\n\n这种径向返回公式确保了唯一且物理上一致的解。它也正确处理了 $f_n = 0$ 的情况，此时意味着 $f_{t,\\text{max}} = 0$。任何非零的试探力都将导致滑动，最终力的大小将被正确更新为 $0$。\n\n实现将针对每个提供的测试用例遵循此算法逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the updated tangential contact force and stick/slip status\n    for a series of test cases based on a predictor-corrector algorithm\n    for Coulomb friction.\n    \"\"\"\n    # Test cases defined as tuples of:\n    # (delta_t_n, delta_u_t, k_t, mu, f_n)\n    # where delta_t_n and delta_u_t are 2D vectors.\n    test_cases = [\n        (np.array([0.0, 0.0]), np.array([0.002, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.01, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.006, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.01, 0.0]), 100000.0, 0.6, 0.0),\n        (np.array([0.005, 0.0]), np.array([0.003, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.002, 0.002]), np.array([0.004, -0.003]), 100000.0, 0.6, 1000.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_t_n, delta_u_t, k_t, mu, f_n = case\n\n        # Step 1: Predictor (Elastic Trial State)\n        # Assume pure stick behavior where the incremental displacement is purely elastic.\n        delta_t_trial = delta_t_n + delta_u_t\n        f_t_trial = k_t * delta_t_trial\n\n        # Step 2: Admissibility Check\n        # Calculate the magnitude of the trial force and the maximum allowable friction force.\n        f_t_trial_norm = np.linalg.norm(f_t_trial)\n        f_t_max = mu * f_n\n\n        # Step 3: Corrector (Update based on stick/slip condition)\n        if f_t_trial_norm = f_t_max:\n            # Case A: Stick condition is met.\n            # The trial state is the final state.\n            f_t_final_norm = f_t_trial_norm\n            stick_indicator = 1\n        else:\n            # Case B: Slip condition.\n            # The force is corrected by scaling it back to the friction circle.\n            # The magnitude of the final force is the maximum allowable friction force.\n            f_t_final_norm = f_t_max\n            stick_indicator = 0\n        \n        results.append([f_t_final_norm, stick_indicator])\n\n    # Format the final output string as a list of lists.\n    # Each inner list is formatted as [force_magnitude, stick_indicator].\n    formatted_results = [f\"[{res[0]}, {res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3512619"}, {"introduction": "在建立了几何映射和局部相互作用法则之后，我们必须验证整个耦合系统是否一致。“斑块测试”（Patch Test）是用于此目的的一个经典而强大的工具，它确保当离散模型承受均匀应变场时，其平均（均质化）应力响应与相应连续体模型的应力响应相匹配。在本练习中 [@problem_id:3512644]，您将实施一个斑块测试来校准和验证耦合模型，这是确保多尺度模拟物理可靠性的关键技能。", "problem": "考虑一个用于耦合有限元法 (FEM) 和离散元法 (DEM) 模拟的二维平面应变斑块检验，该检验在计算岩土力学中进行。一个由粘结的圆形颗粒组成的离散元法 (DEM) 集合体被嵌入在单个方形有限元法 (FEM) 单元内。该域是一个边长为 $h$ (单位：米)、单位厚度 (单位：米) 的正方形，因此体积为 $V = h^2 \\times 1$。这些颗粒形成一个六边形 (三角形) 晶格，其中心距等于颗粒直径 $d$ (单位：米)。每对相邻的颗粒都由一个具有粘性的线性矢量值键连接，该键抵抗相对平移。施加在 FEM 和 DEM 模型上的位移场是均匀小应变场 $u(x) = \\boldsymbol{\\varepsilon}\\, x$，其中平面应变张量 $ \\boldsymbol{\\varepsilon} $ 表示一个工程剪切量值为 $ \\gamma $ 的纯剪切，由下式给出\n$$\n\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0  \\gamma/2 \\\\ \\gamma/2  0 \\end{bmatrix}.\n$$\n\n连接颗粒中心位于 $x_i$ 和 $x_j$ 处的接触 $c$ 上的粘结 DEM 力由线性弹簧定律建模\n$$\n\\boldsymbol{f}_c = k_b \\left( \\boldsymbol{u}(x_j) - \\boldsymbol{u}(x_i) \\right) = k_b \\left( \\boldsymbol{\\varepsilon}\\, \\boldsymbol{l}_c \\right),\n$$\n其中 $k_b$ 是键刚度 (单位：牛顿/米)，分支向量为 $\\boldsymbol{l}_c = x_j - x_i$ (单位：米)。均匀化 DEM 应力使用 Love–Weber 公式\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{1}{V} \\sum_{c} \\boldsymbol{f}_c \\otimes \\boldsymbol{l}_c = \\frac{k_b}{V}\\, \\boldsymbol{\\varepsilon}\\, \\boldsymbol{S}, \\quad \\text{其中} \\quad \\boldsymbol{S} = \\sum_{c} \\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c.\n$$\n\n对于杨氏模量为 $E$ (单位：帕斯卡)、泊松比为 $\\nu$ 的平面应变状态下的各向同性线弹性材料，其 FEM 应力为\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = \\boldsymbol{C} : \\boldsymbol{\\varepsilon} = 2 \\mu\\, \\boldsymbol{\\varepsilon} + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I},\n$$\n其中拉梅参数为 $ \\mu = \\frac{E}{2(1+\\nu)} $ 和 $ \\lambda = \\frac{\\nu E}{(1+\\nu)(1-2\\nu)} $。对于指定的纯剪切 ($\\mathrm{tr}(\\boldsymbol{\\varepsilon}) = 0$)，该式简化为\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu\\, \\boldsymbol{\\varepsilon}.\n$$\n\n为了在剪切作用下将 DEM 集合体与 FEM 材料进行一致性耦合，我们通过 $\\boldsymbol{S}$ 的迹使用 DEM 几何形状来校准 $k_b$，其迹满足 $\\mathrm{tr}(\\boldsymbol{S}) = \\sum_c \\|\\boldsymbol{l}_c\\|^2$，方法是在各向同性极限下强制匹配剪切模量：\n$$\nk_b = \\frac{4 \\mu V}{\\mathrm{tr}(\\boldsymbol{S})}.\n$$\n\n您的任务是实现一个完整的程序，该程序：\n- 构建边长为 $h$、颗粒间距为 $d$ 的方形域内的 DEM 六边形晶格。\n- 在晶格邻居之间建立键，以近似每个内部颗粒的六个方向。\n- 计算 DEM 几何张量 $\\boldsymbol{S}$ 并通过公式 $k_b = \\frac{4 \\mu V}{\\mathrm{tr}(\\boldsymbol{S})}$ 校准 $k_b$。\n- 计算 $\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{k_b}{V}\\, \\boldsymbol{\\varepsilon}\\, \\boldsymbol{S}$ 和 $\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2\\mu\\, \\boldsymbol{\\varepsilon}$。\n- 评估相对 Frobenius 范数误差\n$$\ne_{\\mathrm{rel}} = \\frac{\\| \\boldsymbol{\\sigma}_{\\mathrm{DEM}} - \\boldsymbol{\\sigma}_{\\mathrm{FEM}} \\|_F}{\\| \\boldsymbol{\\sigma}_{\\mathrm{FEM}} \\|_F},\n$$\n并检查 $e_{\\mathrm{rel}}$ 是否小于或等于指定的容差。\n\n物理单位和数值规格：\n- 使用 $E$ (单位：帕斯卡)，$\\nu$ (无量纲)，$h$ 和 $d$ (单位：米)，$\\gamma$ (无量纲)，应力 (单位：帕斯卡)。\n- 误差 $e_{\\mathrm{rel}}$ 必须以小数比率报告，而非百分比。\n\n测试套件：\n为以下参数集提供结果，每个参数均以指定单位表示：\n1. $E = 100\\times 10^{6}$，$\\nu = 0.25$， $h = 0.1$， $d = 0.01$， $\\gamma = 1\\times 10^{-3}$， 容差 $= 0.02$。\n2. $E = 100\\times 10^{6}$，$\\nu = 0.25$， $h = 0.1$， $d = 0.0333333333$， $\\gamma = 1\\times 10^{-3}$， 容差 $= 0.05$。\n3. $E = 100\\times 10^{6}$，$\\nu = 0.25$， $h = 0.05$， $d = 0.01$， $\\gamma = 1\\times 10^{-3}$， 容差 $= 0.03$。\n4. $E = 100\\times 10^{6}$，$\\nu = 0.25$， $h = 0.1$， $d = 0.05$， $\\gamma = 1\\times 10^{-3}$， 容差 $= 0.10$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含以逗号分隔的方括号列表形式的结果 (例如，\"[result1,result2,result3,result4]\")，每个结果都是一个布尔值，指示对于该测试用例，DEM 均匀化应力是否在指定容差内与 FEM 应力匹配。", "solution": "问题陈述经评估有效。它在科学上基于计算连续介质力学和离散力学的原理，问题设定良好，目标明确且确定，并使用精确、客观的语言进行表述。任务是为一个耦合有限元法 (FEM) 和离散元法 (DEM) 模型执行数值斑块检验，这是该领域的标准验证程序。\n\n求解过程如下：首先，建立 FEM 和 DEM 应力计算的理论框架。其次，推导耦合条件和相对误差的解析表达式。第三，详细说明用于构建 DEM 集合体和评估误差的计算算法。\n\n目标是比较在规定的纯剪切变形下，来自 DEM 模拟的均匀化应力张量 $\\boldsymbol{\\sigma}_{\\mathrm{DEM}}$ 与来自连续介质 FEM 公式的相应应力张量 $\\boldsymbol{\\sigma}_{\\mathrm{FEM}}$。\n\n连续介质应力是为处于平面应变状态的线弹性、各向同性材料给出的。本构关系为 $\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu\\, \\boldsymbol{\\varepsilon} + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$，其中 $\\boldsymbol{\\varepsilon}$ 是应变张量，$\\boldsymbol{I}$ 是单位张量，$\\mu$ 和 $\\lambda$ 是拉梅参数。这些参数根据杨氏模量 $E$ 和泊松比 $\\nu$ 定义为 $\\mu = \\frac{E}{2(1+\\nu)}$ 和 $\\lambda = \\frac{\\nu E}{(1+\\nu)(1-2\\nu)}$。问题指定了一个纯剪切应变场，由张量 $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0  \\gamma/2 \\\\ \\gamma/2  0 \\end{bmatrix}$ 给出。由于此应变张量的迹 $\\mathrm{tr}(\\boldsymbol{\\varepsilon})$ 为零，本构定律简化为 $\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu\\, \\boldsymbol{\\varepsilon}$。\n\n离散颗粒集合体由一组排列在边长为 $h$ 的方形域内的六边形晶格中的颗粒中心表示。该域的体积为 $V = h^2$，假设单位厚度为 1 米。相邻颗粒之间的距离等于它们的直径 $d$，它们由线弹性键连接。对于一个规定的均匀位移场 $\\boldsymbol{u}(x) = \\boldsymbol{\\varepsilon}\\, x$，连接位置为 $x_i$ 和 $x_j$ 的颗粒的键力为 $\\boldsymbol{f}_c = k_b (\\boldsymbol{u}(x_j) - \\boldsymbol{u}(x_i))$。使用分支向量 $\\boldsymbol{l}_c = x_j - x_i$，这简化为 $\\boldsymbol{f}_c = k_b \\boldsymbol{\\varepsilon} \\boldsymbol{l}_c$。DEM 集合体的均匀化应力使用 Love-Weber 公式计算：\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{1}{V} \\sum_{c} \\boldsymbol{f}_c \\otimes \\boldsymbol{l}_c\n$$\n其中求和遍及集合体中的所有键 $c$。代入 $\\boldsymbol{f}_c$ 的表达式并使用张量恒等式 $(\\boldsymbol{A}\\boldsymbol{b}) \\otimes \\boldsymbol{c} = \\boldsymbol{A}(\\boldsymbol{b} \\otimes \\boldsymbol{c})$，我们得到：\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{1}{V} \\sum_{c} (k_b \\boldsymbol{\\varepsilon} \\boldsymbol{l}_c) \\otimes \\boldsymbol{l}_c = \\frac{k_b}{V} \\boldsymbol{\\varepsilon} \\left( \\sum_{c} \\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c \\right)\n$$\n这表示为 $\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{k_b}{V} \\boldsymbol{\\varepsilon} \\boldsymbol{S}$，其中 $\\boldsymbol{S} = \\sum_{c} \\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c$ 是 DEM 集合体的几何或组构张量。\n\n为确保两个模型之间的一致性，校准键刚度 $k_b$ 以匹配宏观剪切响应。提供的校准规则 $k_b = \\frac{4 \\mu V}{\\mathrm{tr}(\\boldsymbol{S})}$，是基于在各向同性极限下匹配刚度张量的迹。对于各向同性材料，组构张量将与单位矩阵成比例，即 $\\boldsymbol{S} = c\\boldsymbol{I}$，这意味着 $S_{11}=S_{22}$ 和 $S_{12}=0$。校准的目的是匹配剪切模量 $\\mu$。\n\n两个应力张量之间的差异源于有限的 DEM 集合体（被方形边界截断）并非完全各向同性。组构张量 $\\boldsymbol{S}$ 通常会有 $S_{11} \\neq S_{22}$ 和 $S_{12} \\neq 0$。这种差异的度量是 Frobenius 范数中的相对误差：\n$$\ne_{\\mathrm{rel}} = \\frac{\\| \\boldsymbol{\\sigma}_{\\mathrm{DEM}} - \\boldsymbol{\\sigma}_{\\mathrm{FEM}} \\|_F}{\\| \\boldsymbol{\\sigma}_{\\mathrm{FEM}} \\|_F}\n$$\n我们可以推导出此误差的简化表达式。代入应力表达式和 $k_b$ 的校准公式：\n$$\n\\frac{k_b}{V} = \\frac{4 \\mu}{\\mathrm{tr}(\\boldsymbol{S})} = \\frac{4 \\mu}{S_{11}+S_{22}}\n$$\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{4 \\mu}{S_{11}+S_{22}} \\boldsymbol{\\varepsilon} \\boldsymbol{S} = \\frac{4 \\mu}{S_{11}+S_{22}} \\begin{bmatrix} 0  \\gamma/2 \\\\ \\gamma/2  0 \\end{bmatrix} \\begin{bmatrix} S_{11}  S_{12} \\\\ S_{12}  S_{22} \\end{bmatrix} = \\frac{2 \\mu \\gamma}{S_{11}+S_{22}} \\begin{bmatrix} S_{12}  S_{22} \\\\ S_{11}  S_{12} \\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu \\boldsymbol{\\varepsilon} = \\mu \\gamma \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}\n$$\n误差张量 $\\Delta\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}_{\\mathrm{DEM}} - \\boldsymbol{\\sigma}_{\\mathrm{FEM}}$ 为：\n$$\n\\Delta\\boldsymbol{\\sigma} = \\mu \\gamma \\left( \\frac{2}{S_{11}+S_{22}} \\begin{bmatrix} S_{12}  S_{22} \\\\ S_{11}  S_{12} \\end{bmatrix} - \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix} \\right) = \\frac{\\mu \\gamma}{S_{11}+S_{22}} \\begin{bmatrix} 2S_{12}  S_{22}-S_{11} \\\\ S_{11}-S_{22}  2S_{12} \\end{bmatrix}\n$$\nFEM 应力的 Frobenius 范数为 $\\|\\boldsymbol{\\sigma}_{\\mathrm{FEM}}\\|_F = \\sqrt{(\\mu\\gamma)^2 + (\\mu\\gamma)^2} = \\mu\\gamma\\sqrt{2}$。误差张量的 Frobenius 范数为 $\\|\\Delta\\boldsymbol{\\sigma}\\|_F = \\frac{\\mu\\gamma}{S_{11}+S_{22}} \\sqrt{(2S_{12})^2 + (S_{22}-S_{11})^2 + (S_{11}-S_{22})^2 + (2S_{12})^2} = \\frac{\\mu\\gamma\\sqrt{2}}{S_{11}+S_{22}}\\sqrt{(S_{11}-S_{22})^2 + (2S_{12})^2}$。\n相对误差简化为：\n$$\ne_{\\mathrm{rel}} = \\frac{\\sqrt{(S_{11}-S_{22})^2 + (2S_{12})^2}}{S_{11}+S_{22}}\n$$\n这个关键结果表明，相对误差仅取决于几何张量 $\\boldsymbol{S}$ 的分量。它是 DEM 颗粒组构各向异性的度量，与材料属性 ($E, \\nu$) 和施加的应变大小 ($\\gamma$) 无关。随着比率 $h/d$ 的增加，误差预计会减小，因为边界效应相对于整体变得不那么显著，并且集合体的组构变得更加各向同性。\n\n计算算法如下：\n1. 对于给定的边长 $h$ 和颗粒直径 $d$，生成位于 $[0, h] \\times [0, h]$ 方形域内的六边形晶格中的颗粒位置。该晶格使用基向量 $\\boldsymbol{a}_1 = (d, 0)$ 和 $\\boldsymbol{a}_2 = (d/2, d\\sqrt{3}/2)$ 构建，颗粒中心位于整数组合 $i\\boldsymbol{a}_1+j\\boldsymbol{a}_2$ 处。\n2. 识别所有唯一的键。一个键连接任何两个中心距离约等于 $d$ 的颗粒。\n3. 对于每个键，形成分支向量 $\\boldsymbol{l}_c$。\n4. 将一个 $2 \\times 2$ 矩阵 $\\boldsymbol{S}$ 初始化为零。对所有识别出的键求和外积 $\\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c$ 以计算 $\\boldsymbol{S}$。\n5. 使用推导出的公式计算相对误差 $e_{\\mathrm{rel}}$，该公式仅依赖于 $\\boldsymbol{S}$ 的分量。\n6. 将计算出的误差 $e_{\\mathrm{rel}}$ 与给定的容差进行比较。如果 $e_{\\mathrm{rel}}$ 小于或等于容差，则该参数集的测试通过。\n所提供测试套件的结果是通过实现此算法生成的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {'E': 100e6, 'nu': 0.25, 'h': 0.1, 'd': 0.01, 'gamma': 1e-3, 'tolerance': 0.02},\n        {'E': 100e6, 'nu': 0.25, 'h': 0.1, 'd': 1.0/30.0, 'gamma': 1e-3, 'tolerance': 0.05},\n        {'E': 100e6, 'nu': 0.25, 'h': 0.05, 'd': 0.01, 'gamma': 1e-3, 'tolerance': 0.03},\n        {'E': 100e6, 'nu': 0.25, 'h': 0.1, 'd': 0.05, 'gamma': 1e-3, 'tolerance': 0.10},\n    ]\n\n    results = []\n    for case in test_cases:\n        passes = run_patch_test(**case)\n        results.append(passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(E, nu, h, d, gamma, tolerance):\n    \"\"\"\n    Performs the coupled FEM/DEM patch test for a single set of parameters.\n\n    The function calculates the relative error between the homogenized DEM stress\n    and the analytical FEM stress. As derived in the solution, this error\n    depends only on the geometric tensor S, which is determined by h and d.\n    \"\"\"\n\n    # Step 1: Generate hexagonal lattice points\n    particles = generate_hexagonal_lattice(h, d)\n    \n    # Step 2: Build bonds and compute the geometric tensor S\n    S = compute_geometric_tensor(particles, d)\n\n    # Step 3: Compute the relative error\n    # The error depends only on the anisotropy of the S tensor.\n    # e_rel = ||dev(S_normalized)||_F, where S_normalized = S / tr(S)\n    # The derived formula is used for direct computation.\n    S_11, S_12 = S[0, 0], S[0, 1]\n    S_22 = S[1, 1]\n    \n    trace_S = S_11 + S_22\n\n    if trace_S == 0:\n        # This occurs if no bonds are formed (e.g., h  d). In this case,\n        # DEM stress is zero, FEM stress is non-zero, error is 1.\n        e_rel = 1.0\n    else:\n        numerator = np.sqrt((S_11 - S_22)**2 + (2 * S_12)**2)\n        e_rel = numerator / trace_S\n\n    # Step 4: Check if the error is within tolerance\n    return e_rel = tolerance\n\ndef generate_hexagonal_lattice(h, d):\n    \"\"\"\n    Generates particle coordinates for a hexagonal lattice within a square domain [0, h] x [0, h].\n    \"\"\"\n    particles = []\n    \n    # Basis vectors for the hexagonal lattice\n    a1 = np.array([d, 0.0])\n    a2 = np.array([d / 2.0, d * np.sqrt(3.0) / 2.0])\n\n    # Efficiently determine the range of integer indices j and i\n    j_max = int(np.floor(h / a2[1]))\n    for j in range(j_max + 1):\n        # Determine range for i based on j\n        i_min = int(np.ceil(-j * a2[0] / a1[0]))\n        i_max = int(np.floor((h - j * a2[0]) / a1[0]))\n        \n        for i in range(i_min, i_max + 1):\n            pos = i * a1 + j * a2\n            # Although the loop bounds should guarantee this, a final check is robust.\n            if 0 = pos[0] = h and 0 = pos[1] = h:\n                particles.append(pos)\n                \n    return np.array(particles)\n\ndef compute_geometric_tensor(particles, d):\n    \"\"\"\n    Computes the geometric tensor S by summing the outer product of branch vectors.\n    \"\"\"\n    num_particles = len(particles)\n    S = np.zeros((2, 2))\n    \n    # Iterate over unique pairs of particles\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            p_i = particles[i]\n            p_j = particles[j]\n            \n            # Check if particles are neighbors (distance is d)\n            # np.isclose is used for robust floating point comparison\n            if np.isclose(np.linalg.norm(p_j - p_i), d):\n                l_c = p_j - p_i\n                S += np.outer(l_c, l_c)\n                \n    return S\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3512644"}]}