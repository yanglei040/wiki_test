{"hands_on_practices": [{"introduction": "要验证数值方法的准确性，一个基本步骤是确认它能否精确再现最简单的非平凡解。本实践练习将指导您执行一个线弹性“补丁测试”（patch test），这是计算力学中的一项标准验证程序。通过施加一个线性位移场，您将亲手验证 GIMP 和 CPDI 映射能够精确地计算出恒定应变场，从而证明这些方法具备“线性完备性”，这是确保数值解收敛到正确结果的必要条件 [@problem_id:3541702]。", "problem": "考虑一个在质点法 (MPM) 中使用的结构化、均匀的笛卡尔背景网格上建立的二维小应变线性补丁测试。设均匀网格在两个方向上的间距均为 $h$，节点 $I$ 的坐标为 $(x_I,y_I)$。通过根据线性函数 $u_x(x,y) = a x + b$ 和 $u_y(x,y) = c y + d$ 指定节点位移，在网格节点上施加一个合成运动学场，其中 $a$、$b$、$c$ 和 $d$ 是给定的实数参数，$(x,y)$ 表示空间位置。目标是验证两种域感知MPM映射方法：广义插值质点法 (GIMP) 和对流粒子域插值 (CPDI)，是否能在不同粒子域尺寸和随机粒子-网格偏移的情况下，在所有质点（粒子）上精确地再现恒定的小应变张量 $\\boldsymbol{\\varepsilon}$。此验证应通过以下方式进行：使用每种映射方法从节点位移计算质点处的应变，并将其与施加的线性位移场引起的精确解析应变进行比较。\n\n推导的基本依据是位移梯度和小应变的运动学定义：位移梯度为 $$ \\nabla \\mathbf{u} = \\begin{bmatrix} \\partial u_x/\\partial x & \\partial u_x/\\partial y \\\\ \\partial u_y/\\partial x & \\partial u_y/\\partial y \\end{bmatrix} $$，无穷小应变张量为 $$ \\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^\\top\\right) $$。在补丁测试中，预期的解析应变是恒定的，其分量为 $\\varepsilon_{xx}=a$、$\\varepsilon_{yy}=c$ 和 $\\varepsilon_{xy}=0$。质点处的数值应变是使用MPM映射从节点位移计算得出的，该映射为每个粒子分配了背景网格形函数在粒子域上的平均梯度。在GIMP中，该平均值通过形函数梯度在矩形粒子域上的面积分来定义。在CPDI中，该平均值由粒子域角点一致性地定义，并且当粒子域与网格轴对齐时，对于线性场，其结果与GIMP相同。在此测试中，两种映射方法都应能精确再现线性场。\n\n您的任务是实现一个程序，该程序：\n- 构建一个间距为 $h$ 的均匀方形网格，其尺寸应足够大，以使随机放置的粒子域完全位于网格内部。\n- 生成一组质点，其矩形域在两个方向上的边长均为 $l_p$，使得比率 $l_p/h$ 在每个测试案例中可以变化。粒子中心在内部随机分布，以确保每个粒子域都保持在网格边界内。对于一个测试案例，有意将粒子中心集中在网格线附近，以创建跨越单元边界的情景。\n- 在所有网格节点上施加来自线性场 $u_x=a x + b$、$u_y=c y + d$ 的节点位移。\n- 对每个粒子，使用以下方法计算数值位移梯度 $\\nabla \\mathbf{u}$ 和小应变 $\\boldsymbol{\\varepsilon}$：\n  1. GIMP 定义，基于背景双线性形函数梯度在粒子域上的精确面积平均值（当粒子域与多个网格单元重叠时，通过将其划分为逐单元的子域进行适当处理）。\n  2. CPDI 定义，基于每个重叠单元子域内的角点平均梯度，并在整个粒子域上进行面积加权。\n- 将计算出的粒子应变与精确的解析应变进行比较，并为每个测试案例和每种映射方法报告所有粒子中 $\\boldsymbol{\\varepsilon}$ 的最大绝对误差。由于 $\\boldsymbol{\\varepsilon}$ 是无量纲的，误差也是无量纲的。\n\n使用一个均匀网格，其间距 $h$ 以米为单位，节点坐标也以米为单位。位移 $u_x$ 和 $u_y$ 必须以米为单位。应变 $\\boldsymbol{\\varepsilon}$ 必须视为无量纲，误差度量也必须是无量纲的。\n\n实现以下测试套件，其中每个测试案例定义了 $(a,b,c,d)$、粒子与网格的尺寸比 $l_p/h$、粒子数量 $N_p$ 以及一个用于确定性地生成粒子中心的随机种子：\n1. 理想路径：$a=0.03$，$b=0.0$，$c=-0.02$，$d=0.1$，$l_p/h=0.3$，$N_p=50$，种子 $42$。\n2. 接近单元尺寸的域：$a=0.05$，$b=0.5$，$c=0.04$，$d=-0.3$，$l_p/h=0.99$，$N_p=60$，种子 $123$。\n3. 跨越边界的偏移：$a=-0.01$，$b=0.2$，$c=0.02$，$d=0.0$，$l_p/h=0.6$，$N_p=40$，种子 $2024$；选择靠近网格线的粒子中心，以便许多粒子域跨越单元边界，同时保持在网格内部。\n4. 非常小的域：$a=0.0$，$b=-0.1$，$c=0.0$，$d=0.25$，$l_p/h=0.05$，$N_p=80$，种子 $7$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其顺序为 $[E^{\\mathrm{GIMP}}_1,E^{\\mathrm{CPDI}}_1,E^{\\mathrm{GIMP}}_2,E^{\\mathrm{CPDI}}_2,E^{\\mathrm{GIMP}}_3,E^{\\mathrm{CPDI}}_3,E^{\\mathrm{GIMP}}_4,E^{\\mathrm{CPDI}}_4]$，其中 $E^{\\mathrm{GIMP}}_k$ 和 $E^{\\mathrm{CPDI}}_k$ 分别表示使用GIMP和CPDI映射计算的测试案例 $k$ 中所有粒子应变分量的最大绝对误差。所有输出必须是无量纲实数。不允许有其他输出。", "solution": "该问题陈述经过严格评估后被确定为有效。它构成了一个在计算岩土力学领域中定义明确、具有科学依据的验证问题。具体来说，它描述了质点法（MPM）的线性补丁测试，这是验证数值实现正确性的标准程序。给定的条件是完整、一致且物理上合理的。目标明确，方法（GIMP、CPDI）在MPM的背景下有很好的定义。因此，我们可以着手进行形式化的求解。\n\n所测试的核心原理是广义插值质点法（GIMP）和对流粒子域插值（CPDI）公式能否精确再现恒定应变状态。此特性，即线性完备性，是数值方法在网格细化时能够收敛到正确解的必要条件。\n\n首先，我们建立解析解。给定的位移场为：\n$$\nu_x(x,y) = a x + b \\\\\nu_y(x,y) = c y + d\n$$\n其中 $a, b, c, d$ 是常数。位移梯度张量 $\\nabla \\mathbf{u}$ 通过对位移分量求偏导数得到：\n$$\n\\nabla \\mathbf{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n$$\n无穷小（小）应变张量 $\\boldsymbol{\\varepsilon}$ 是位移梯度的对称部分：\n$$\n\\boldsymbol{\\varepsilon}_{exact} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right) = \\frac{1}{2} \\left(\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n+\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}^\\top\n\\right)\n=\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n$$\n因此，解析应变场在整个域内是恒定的，其分量为 $\\varepsilon_{xx} = a$、$\\varepsilon_{yy} = c$ 和 $\\varepsilon_{xy} = 0$。这是数值方法必须再现的精确解。\n\n在质点法中，位移场 $\\mathbf{u}^h(\\mathbf{x})$ 是使用基于网格的形函数 $S_I(\\mathbf{x})$ 从节点值 $\\mathbf{u}_I$ 插值得到的：\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{I} S_I(\\mathbf{x}) \\mathbf{u}_I\n$$\n问题使用了间距为 $h$ 的均匀笛卡尔网格上的双线性形函数。这些函数的一个关键特性是它们构成单位分解（$\\sum_I S_I(\\mathbf{x}) = 1$）并且是线性完备的（$\\sum_I S_I(\\mathbf{x}) \\mathbf{x}_I = \\mathbf{x}$）。由于规定的位移场是线性的，并且节点位移被设置为节点处的精确值，即 $\\mathbf{u}_I = \\mathbf{u}(\\mathbf{x}_I)$，线性完备性保证了插值场在任何地方都能精确再现线性场：$\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$。\n\n从插值场计算出的位移梯度为：\n$$\n\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\sum_I \\mathbf{u}_I \\otimes \\nabla S_I(\\mathbf{x})\n$$\n由于 $\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$，可以推断出 $\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\nabla \\mathbf{u}(\\mathbf{x})$，我们已经发现这是一个常数矩阵。\n\n在 GIMP 和 CPDI 中，质点 $p$ 处的位移梯度不是在其中心点计算的，而是在该粒子的域 $\\Omega_p$ 上进行平均。粒子平均梯度为：\n$$\n(\\nabla \\mathbf{u})_p = \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla \\mathbf{u}^h(\\mathbf{x}) \\, dA = \\frac{1}{A_p} \\int_{\\Omega_p} \\left( \\sum_I \\mathbf{u}_I \\otimes \\nabla S_I(\\mathbf{x}) \\right) dA = \\sum_I \\mathbf{u}_I \\otimes \\left( \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla S_I(\\mathbf{x}) \\, dA \\right)\n$$\n其中 $A_p = l_p^2$ 是粒子域的面积。我们将粒子平均的形函数梯度定义为 $\\mathbf{G}_{Ip} = \\langle \\nabla S_I \\rangle_p$。因此：\n$$\n(\\nabla \\mathbf{u})_p = \\sum_I \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}\n$$\n其分量计算如下：\n$$\n(\\nabla u_x)_p = \\sum_I u_{x,I} \\mathbf{G}_{Ip} \\quad \\text{和} \\quad (\\nabla u_y)_p = \\sum_I u_{y,I} \\mathbf{G}_{Ip}\n$$\n更具体地：\n$$\n(\\nabla \\mathbf{u})_p = \\begin{bmatrix}\n\\sum_I u_{x,I} G_{Ip,x} & \\sum_I u_{x,I} G_{Ip,y} \\\\\n\\sum_I u_{y,I} G_{Ip,x} & \\sum_I u_{y,I} G_{Ip,y}\n\\end{bmatrix}\n$$\n挑战在于正确计算每个其支集与粒子域 $\\Omega_p$ 相交的节点 $I$ 的 $\\mathbf{G}_{Ip}$ 分量。对于位于 $\\mathbf{x}_I=(x_I, y_I)$ 的节点，标准双线性基函数可以写为 $S_I(x,y) = s\\left(\\frac{x-x_I}{h}\\right) s\\left(\\frac{y-y_I}{h}\\right)$，其中 $s(z) = \\max(0, 1-|z|)$ 是一维帽函数。其导数为 $s'(z) = -\\text{sgn}(z)$ 对于 $|z| \\in (0,1)$，其他情况下为 $0$。\n\n$\\mathbf{G}_{Ip}$ 的分量是可分离积分的结果：\n$$\nG_{Ip,x} = \\frac{1}{A_p} \\int_{y_p-l_p/2}^{y_p+l_p/2} \\int_{x_p-l_p/2}^{x_p+l_p/2} \\frac{\\partial S_I}{\\partial x} \\, dx \\, dy = \\frac{1}{l_p^2 h} \\left[ \\int_{x_p-l_p/2}^{x_p+l_p/2} s'\\left(\\frac{x-x_I}{h}\\right) \\, dx \\right] \\left[ \\int_{y_p-l_p/2}^{y_p+l_p/2} s\\left(\\frac{y-y_I}{h}\\right) \\, dy \\right]\n$$\n根据微积分基本定理，导数 $s'$ 的积分就是 $s$。通过变量代换 ($z=(x-x_I)/h$) 可以简化积分：\n$$\nG_{Ip,x} = \\frac{h}{l_p^2} \\left[ s(z) \\right]_{z_1}^{z_2} \\left[ \\int_{w_1}^{w_2} s(w) \\, dw \\right]\n$$\n同样地，\n$$\nG_{Ip,y} = \\frac{h}{l_p^2} \\left[ \\int_{z_1}^{z_2} s(z) \\, dz \\right] \\left[ s(w) \\right]_{w_1}^{w_2}\n$$\n其中积分限为 $z_1 = (x_p-l_p/2-x_I)/h$, $z_2 = (x_p+l_p/2-x_I)/h$, $w_1 = (y_p-l_p/2-y_I)/h$, and $w_2 = (y_p+l_p/2-y_I)/h$。$s(z)$ 的定积分可以通过考虑其分段定义来解析计算。\n令 $F(z) = \\int_0^z s(t) \\, dt$。那么 $\\int_a^b s(t) \\, dt = F(b) - F(a)$。函数 $F(z)$ 为：\n$$\nF(z) =\n\\begin{cases}\n-0.5 & z \\le -1 \\\\\nz + z^2/2 & -1 < z < 0 \\\\\nz - z^2/2 & 0 \\le z \\le 1 \\\\\n0.5 & z > 1\n\\end{cases}\n$$\n利用这些解析表达式，可以为GIMP计算出达到机器精度的 $\\mathbf{G}_{Ip}$。问题陈述指出，对于轴对齐的矩形粒子域和线性位移场，CPDI公式给出相同的结果。因此，对于两者将使用相同的计算方法，并且两种情况下的预期误差都应接近于零，仅受浮点运算的限制。\n\n对于每个测试案例，算法按以下步骤进行：\n1. 定义一个足够大的网格并设置网格间距 $h$。\n2. 使用指定的随机种子生成 $N_p$ 个粒子中心坐标 $(x_p, y_p)$，确保尺寸为 $l_p \\times l_p$ 的粒子域完全包含在网格内部。对于跨越边界的情况，粒子中心被明确放置在网格线附近。\n3. 对于网格中坐标为 $(x_I, y_I)$ 的每个节点 $I$，计算规定的节点位移 $u_{x,I} = a x_I + b$ 和 $u_{y,I} = c y_I + d$。\n4. 对每个粒子，将其位移梯度张量 $(\\nabla \\mathbf{u})_p$ 初始化为零。\n5. 识别所有形函数支集与粒子域重叠的节点 $I$。$S_I$ 的支集是一个以 $\\mathbf{x}_I$ 为中心、尺寸为 $2h \\times 2h$ 的正方形。\n6. 对于每个这样的活动节点，使用上面推导的精确积分公式计算平均梯度向量 $\\mathbf{G}_{Ip}$。\n7. 累加每个节点对粒子位移梯度的贡献：$(\\nabla \\mathbf{u})_p += \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}$。\n8. 遍历所有活动节点后，计算粒子应变张量 $\\boldsymbol{\\varepsilon}_p = \\frac{1}{2}((\\nabla \\mathbf{u})_p + (\\nabla \\mathbf{u})_p^\\top)$。\n9. 计算粒子的误差，即计算出的应变 $\\boldsymbol{\\varepsilon}_p$ 与解析应变 $\\boldsymbol{\\varepsilon}_{exact}$ 的分量之间的最大绝对差。\n10. 测试案例的结果是所有粒子中发现的最大误差。该值将分别报告给 GIMP 和 CPDI。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef s_hat(z: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the 1D linear B-spline (hat function).\"\"\"\n    z_abs = np.abs(z)\n    return np.where(z_abs  1.0, 1.0 - z_abs, 0.0)\n\ndef integral_s_hat(z: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the analytical integral of the hat function from 0 to z.\"\"\"\n    res = np.zeros_like(z, dtype=float)\n    \n    # z = -1\n    res[z = -1.0] = -0.5\n    \n    # -1  z  0\n    mask = (-1.0  z)  (z  0.0)\n    res[mask] = z[mask] + 0.5 * z[mask]**2\n    \n    # 0 = z = 1\n    mask = (0.0 = z)  (z = 1.0)\n    res[mask] = z[mask] - 0.5 * z[mask]**2\n\n    # z > 1\n    res[z > 1.0] = 0.5\n    \n    return res\n\ndef eval_integral_s_hat(z1: np.ndarray, z2: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the definite integral of the hat function from z1 to z2.\"\"\"\n    return integral_s_hat(z2) - integral_s_hat(z1)\n\ndef run_test_case(a, b, c, d, lp_h_ratio, Np, seed, is_edge_crossing):\n    \"\"\"\n    Runs a single patch test case.\n    \"\"\"\n    h = 1.0\n    lp = lp_h_ratio * h\n    \n    # 1. Grid setup\n    grid_dim = 20  # Number of cells in each direction\n    grid_min, grid_max = 0.0, grid_dim * h\n    \n    # Generate node coordinates and displacements\n    x_coords = np.arange(grid_min, grid_max + h, h)\n    y_coords = np.arange(grid_min, grid_max + h, h)\n    nx, ny = len(x_coords), len(y_coords)\n    nodes_x, nodes_y = np.meshgrid(x_coords, y_coords)\n    \n    u_x_nodal = a * nodes_x + b\n    u_y_nodal = c * nodes_y + d\n    \n    # 2. Particle generation\n    rng = np.random.default_rng(seed)\n    particles_pos = np.zeros((Np, 2))\n    \n    # Ensure particles and their domains are within the grid 'interior'\n    # Use a margin of 1 cell from the boundary to avoid edge cases\n    margin = h\n    p_min = grid_min + margin + lp / 2.0\n    p_max = grid_max - margin - lp / 2.0\n\n    if is_edge_crossing:\n        # Concentrate particles near grid lines\n        grid_lines_x_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        grid_lines_y_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        \n        base_x = grid_lines_x_idx * h\n        base_y = grid_lines_y_idx * h\n\n        # Offset by a small amount, ensuring cell crossing\n        offset_mag = 0.4 * lp # Small enough to be near line, large enough to guarantee crossing if lp > h\n        offsets_x = rng.uniform(-offset_mag, offset_mag, size=Np)\n        offsets_y = rng.uniform(-offset_mag, offset_mag, size=Np)\n        \n        particles_pos[:, 0] = np.clip(base_x + offsets_x, p_min, p_max)\n        particles_pos[:, 1] = np.clip(base_y + offsets_y, p_min, p_max)\n    else:\n        particles_pos = rng.uniform(low=p_min, high=p_max, size=(Np, 2))\n\n    max_err = 0.0\n    analytical_strain = np.array([[a, 0.0], [0.0, c]])\n\n    # 3. Process each particle\n    for p_idx in range(Np):\n        xp, yp = particles_pos[p_idx]\n        grad_u_p = np.zeros((2, 2))\n        \n        # Identify active nodes\n        x_min_infl = xp - lp / 2.0 - h\n        x_max_infl = xp + lp / 2.0 + h\n        y_min_infl = yp - lp / 2.0 - h\n        y_max_infl = yp + lp / 2.0 + h\n\n        # Find indices of nodes within the influence region\n        min_i = int(np.floor(x_min_infl / h))\n        max_i = int(np.ceil(x_max_infl / h))\n        min_j = int(np.floor(y_min_infl / h))\n        max_j = int(np.ceil(y_max_infl / h))\n\n        min_i = max(0, min_i)\n        max_i = min(nx-1, max_i)\n        min_j = max(0, min_j)\n        max_j = min(ny-1, max_j)\n\n        for j in range(min_j, max_j + 1):\n            for i in range(min_i, max_i + 1):\n                xi, yi = x_coords[i], y_coords[j]\n\n                # Calculate particle-averaged shape function gradients (G_ip)\n                z1 = (xp - lp / 2.0 - xi) / h\n                z2 = (xp + lp / 2.0 - xi) / h\n                w1 = (yp - lp / 2.0 - yi) / h\n                w2 = (yp + lp / 2.0 - yi) / h\n                \n                term_z_s = s_hat(z2) - s_hat(z1)\n                term_w_s = s_hat(w2) - s_hat(w1)\n                \n                term_z_int_s = eval_integral_s_hat(z1, z2)\n                term_w_int_s = eval_integral_s_hat(w1, w2)\n                \n                if abs(term_z_s)  1e-15 and abs(term_w_s)  1e-15 and \\\n                   abs(term_z_int_s)  1e-15 and abs(term_w_int_s)  1e-15:\n                    continue\n\n                common_factor = h / (lp**2)\n                G_ip_x = common_factor * term_z_s * term_w_int_s\n                G_ip_y = common_factor * term_z_int_s * term_w_s\n                \n                # Accumulate displacement gradient\n                grad_u_p[0, 0] += u_x_nodal[j, i] * G_ip_x\n                grad_u_p[0, 1] += u_x_nodal[j, i] * G_ip_y\n                grad_u_p[1, 0] += u_y_nodal[j, i] * G_ip_x\n                grad_u_p[1, 1] += u_y_nodal[j, i] * G_ip_y\n        \n        # Calculate strain and error\n        strain_p = 0.5 * (grad_u_p + grad_u_p.T)\n        err_matrix = np.abs(strain_p - analytical_strain)\n        \n        if np.max(err_matrix) > max_err:\n            max_err = np.max(err_matrix)\n            \n    return max_err\n\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # a, b, c, d, lp/h, Np, seed, is_edge_crossing\n        (0.03, 0.0, -0.02, 0.1, 0.3, 50, 42, False),\n        (0.05, 0.5, 0.04, -0.3, 0.99, 60, 123, False),\n        (-0.01, 0.2, 0.02, 0.0, 0.6, 40, 2024, True),\n        (0.0, -0.1, 0.0, 0.25, 0.05, 80, 7, False),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_test_case(*params)\n        # For this linear patch test with axis-aligned domains, GIMP and CPDI yield identical results.\n        results.append(f\"{error:.15e}\")\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3541702"}, {"introduction": "一个稳健的数值方法不应在物体仅作刚体运动（即没有变形）时产生虚假的内应力或应变。本练习旨在通过模拟一个刚性旋转场来检验 GIMP 和 CPDI 映射的物理一致性。您将学习如何通过验证零应变率、守恒的动能以及零虚假应力来确保数值实现满足“刚体运动不变性” [@problem_id:3541699]。这个练习突出了粒子-网格映射中权函数与其梯度在重建场量（如速度）和场量梯度（如速度梯度）时的不同作用。", "problem": "考虑一个用于材料点法 (MPM) 的二维均匀笛卡尔背景网格。设域为边长单位为米的正方形 $\\Omega = [-0.5,0.5] \\times [-0.5,0.5]$。该网格由 $N \\times N$ 个节点组成，节点间距均匀，为 $h = 1/(N-1)$ 米。定义了一组共 $n_p$ 个材料点（粒子），每个粒子 $p$ 具有中心 $\\mathbf{x}_p = (x_p,y_p)$、矩形域半长 $(\\ell_x,\\ell_y)$（单位：米）、密度 $\\rho$（单位：$\\mathrm{kg/m^3}$）、厚度 $t$（单位：米）以及质量 $m_p = \\rho t A_p$，其中 $A_p = 4 \\ell_x \\ell_y$ 是其面积。不存在外力。预设的刚体运动由 $\\mathbf{u}(\\mathbf{x}) = \\boldsymbol{\\Omega} \\times \\mathbf{x}$ 给出，速度 $\\mathbf{v}(\\mathbf{x}) = \\dot{\\mathbf{u}}(\\mathbf{x}) = \\boldsymbol{\\Omega} \\times \\mathbf{x}$，其中 $\\boldsymbol{\\Omega} = (0,0,\\omega)$ 是一个恒定的角速度矢量，$\\omega$ 的单位是弧度/秒，从而得到 $\\mathbf{v}(\\mathbf{x}) = (-\\omega y, \\omega x)$，单位是米/秒。目标是测试在粒子穿越网格单元时，广义插值材料点 (GIMP) 映射和对流粒子域插值 (CPDI) 映射下的刚体运动不变性。\n\n基本原理：\n- 运动学：速度梯度为 $\\mathbf{L}(\\mathbf{x}) = \\nabla \\mathbf{v}(\\mathbf{x})$，对称应变率张量为 $\\mathbf{D}(\\mathbf{x}) = \\tfrac{1}{2}\\left(\\mathbf{L} + \\mathbf{L}^\\mathsf{T}\\right)$，对于刚体旋转，$\\mathbf{D}(\\mathbf{x}) = \\mathbf{0}$。\n- 能量学：动能为 $T = \\tfrac{1}{2} \\int_{\\Omega} \\rho \\|\\mathbf{v}(\\mathbf{x})\\|^2 \\, \\mathrm{d}V$，当仅在粒子和网格之间传递场（无动力学过程）时，动能必须保持恒定。\n- 平面应变的线性弹性（仅用于评估伪应力）：$\\boldsymbol{\\sigma} = \\lambda\\, \\mathrm{tr}(\\boldsymbol{\\varepsilon})\\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon}$ 是应变（此处使用速度梯度的对称部分作为其代理，$\\boldsymbol{\\varepsilon} \\equiv \\mathbf{D}\\,\\Delta t$，并取单位时间步进行测试），以及 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$，$\\mu = \\frac{E}{2(1+\\nu)}$。对于刚性旋转，$\\boldsymbol{\\varepsilon}=\\mathbf{0}$，因此 $\\boldsymbol{\\sigma}=\\mathbf{0}$。\n\n网格插值基函数：\n- 锚定在节点 $X_I$ 处的一维标准帽函数（帐篷函数）为 $N^{1\\mathrm{D}}(x) = \\max\\left(0, 1 - \\frac{|x - X_I|}{h}\\right)$，其关于 $x$ 的导数为 $\\partial N^{1\\mathrm{D}}/\\partial x = -\\frac{\\mathrm{sign}(x-X_I)}{h}$（当 $|x-X_I|h$ 时）。", "solution": "用户提供了一个定义明确的计算力学问题，需要进行验证和求解。\n\n### 步骤1：提取给定条件\n- **域**：正方形 $\\Omega = [-0.5,0.5] \\times [-0.5,0.5]$ 米。\n- **网格**：$N \\times N$ 均匀笛卡尔网格，其中 $N=17$。间距 $h = 1/(N-1)$ 米。节点位置为 $(X_I, Y_J)$。\n- **粒子**：一组共 $n_p$ 个粒子，每个粒子具有中心 $\\mathbf{x}_p = (x_p,y_p)$、矩形域半长 $(\\ell_x, \\ell_y)$ 米、密度 $\\rho = 2000\\ \\mathrm{kg/m^3}$ 和厚度 $t = 1\\ \\mathrm{m}$。\n- **粒子质量**：$m_p = \\rho t A_p$，其中 $A_p = 4 \\ell_x \\ell_y$。\n- **刚体运动**：预设速度场 $\\mathbf{v}(\\mathbf{x}) = \\boldsymbol{\\Omega} \\times \\mathbf{x}$，其中 $\\boldsymbol{\\Omega} = (0,0,\\omega)$，得到 $\\mathbf{v}(\\mathbf{x}) = (-\\omega y, \\omega x)$ m/s。节点速度被指定为 $\\mathbf{v}_{IJ} = (-\\omega Y_J, \\omega X_I)$。\n- **弹性**：平面应变线性弹性，杨氏模量 $E = 10^7$ 帕斯卡，泊松比 $\\nu = 0.3$。应力 $\\boldsymbol{\\sigma} = \\lambda\\, \\mathrm{tr}(\\boldsymbol{\\varepsilon})\\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon}$，其中应变代理为 $\\boldsymbol{\\varepsilon} \\equiv \\mathbf{D}\\,\\Delta t$，且 $\\Delta t=1\\,\\mathrm{s}$。\n- **基函数**：标准的二维张量积帽函数 $N_{IJ}(x,y)$ 及其梯度 $\\nabla N_{IJ}$。\n- **映射方案**：\n    1.  **GIMP (广义插值材料点)**：粒子到节点的权重 $W_{IJ}^{\\mathrm{GIMP}}$ 及其梯度 $\\nabla W_{IJ}^{\\mathrm{GIMP}}$ 通过一维平滑帽函数 $S^{1\\mathrm{D}}_{\\mathrm{GIMP}}$ 及其导数的张量积定义，公式已提供。\n    2.  **CPDI (对流粒子域插值)**：粒子到节点的权重 $W_{IJ}^{\\mathrm{CPDI}}$ 及其梯度 $\\nabla W_{IJ}^{\\mathrm{CPDI}}$ 定义为标准网格基函数及其梯度在粒子域 $\\mathcal{P}_p$ 上的面积平均值。问题指定使用均匀张量积求积法进行近似。\n- **重构**：粒子速度 $\\mathbf{v}_p^{\\mathrm{rec}} = \\sum_{I,J} W_{IJ}(\\mathbf{x}_p)\\ \\mathbf{v}_{IJ}$ 和速度梯度 $\\mathbf{L}_p^{\\mathrm{rec}} = \\sum_{I,J} \\mathbf{v}_{IJ} \\otimes \\nabla W_{IJ}(\\mathbf{x}_p)$。应变率为 $\\mathbf{D}_p^{\\mathrm{rec}} = \\tfrac{1}{2}(\\mathbf{L}_p^{\\mathrm{rec}} + (\\mathbf{L}_p^{\\mathrm{rec}})^\\mathsf{T})$。\n- **测试用例**：\n    - **案例 A**：GIMP，$\\omega=25$，9个粒子，$(\\ell_x, \\ell_y)=(0.4h, 0.45h)$。\n    - **案例 B**：CPDI，$\\omega=40$，9个粒子，$(\\ell_x, \\ell_y)=(0.8h, 0.6h)$，$5\\times 5$ 求积法。\n    - **案例 C**：GIMP，$\\omega=1000$，4个粒子，$(\\ell_x, \\ell_y)=(0.45h, 0.45h)$。\n    - **案例 D**：CPDI，$\\omega=0$，4个粒子，$(\\ell_x, \\ell_y)=(1.2h, 1.8h)$，$7\\times 7$ 求积法。\n- **验证标准与容差**：\n    1.  **无应变率**：$\\mathrm{strain\\_zero} \\iff \\max_p \\|\\mathbf{D}_p^{\\mathrm{rec}}\\|_F \\le \\tau_D$，其中 $\\tau_D = 10^{-8} \\max(1,|\\omega|)\\ \\mathrm{s^{-1}}$。\n    2.  **动能守恒**：$\\mathrm{KE\\_constant} \\iff |T_{\\mathrm{rec}} - T_{\\mathrm{initial}}| \\le \\tau_T$，其中 $T_{\\mathrm{rec}} = \\sum_p \\tfrac{1}{2} m_p \\|\\mathbf{v}_p^{\\mathrm{rec}}\\|^2$, $T_{\\mathrm{initial}} = \\sum_p \\tfrac{1}{2} m_p \\|\\mathbf{v}(\\mathbf{x}_p)\\|^2$，以及 $\\tau_T = 10^{-10}\\, \\max(T_{\\mathrm{initial}}, 1)$ 焦耳。\n    3.  **无应力**：$\\mathrm{stress\\_zero} \\iff \\max_p \\|\\boldsymbol{\\sigma}_p\\|_F \\le \\tau_\\sigma$，其中 $\\tau_\\sigma = 10^{-2}$ 帕斯卡。\n- **输出格式**：一个布尔值列表的列表，例如 `[[True,True,True],[False,True,True],...]`。\n\n### 步骤2：使用提取的给定条件进行验证\n对问题进行严格验证。\n- **科学基础**：该问题牢固地植根于计算力学理论，特别是材料点法 (MPM)。GIMP 和 CPDI 公式是缓解 MPM 中数值误差的标准且有据可查的方法。所有物理和数学公式（刚体运动学、线性弹性、基函数）都是正确和标准的。\n- **适定性**：该问题是适定的。它要求根据一套完整的输入数据和数值方案计算特定量。目标被明确定义为与数值容差的比较。该过程是确定性的，可导出一个唯一的、可计算的结果。\n- **客观性**：问题以精确、客观和数学化的语言陈述，没有任何主观或模棱两可的术语。\n- **完整性与一致性**：为四个测试用例中的每一个都提供了所有必要的参数、公式和条件。设置中没有明显的矛盾。为 CPDI 使用数值求积法的指令是明确的，解决了其实现中的任何潜在歧义。\n- **可行性**：参数在数值模拟的合理范围内。案例 C 中的高角速度是对数值方案的有效压力测试。该问题在计算上是可行的。\n\n### 步骤3：结论与行动\n该问题被认定为有效。这是一个在数值方法开发和验证中常见的标准数值验证测试。现在开始求解过程。\n\n### 求解\n\n任务是实现一个数值实验，以验证 GIMP 和 CPDI 映射方案在材料点法框架下的刚体运动不变性。对于一个完美的数值方案，刚体旋转不应引起任何内部变形（应变）或应力，并且在粒子与网格表示之间的映射过程中，动能应保持守恒。\n\n每个测试用例的总体流程如下：\n1.  **系统初始化**：\n    - 在域 $\\Omega = [-0.5, 0.5] \\times [-0.5, 0.5]$ 上建立一个均匀的笛卡尔网格，有 $N=17$ 个节点，从而得到网格间距 $h = 1/(17-1) = 1/16$ 米。确定每个网格节点的坐标 $(X_I, Y_J)$。\n    - 对于每个节点，根据刚体旋转场指定速度 $\\mathbf{v}_{IJ} = (-\\omega Y_J, \\omega X_I)$。\n    - 定义特定测试用例的材料点（粒子），包括其位置 $\\mathbf{x}_p$、域半长 $(\\ell_x, \\ell_y)$ 和质量 $m_p$，质量由给定的密度 $\\rho$、厚度 $t$ 和粒子面积 $A_p = 4 \\ell_x \\ell_y$ 计算得出。\n\n2.  **场传递与重构**：\n    问题的核心在于从网格重构粒子位置处的场。这通过遍历每个粒子，并对每个粒子求和所有有影响的网格节点的贡献来完成。\n    - 对于位于 $\\mathbf{x}_p$ 的粒子 $p$，我们必须为每个邻近节点 $(I,J)$ 计算插值权重 $W_{IJ}(\\mathbf{x}_p)$ 及其梯度 $\\nabla W_{IJ}(\\mathbf{x}_p)$。此计算取决于映射方案（GIMP 或 CPDI）。\n\n    - **GIMP 方案**：GIMP 权重函数是一维平滑函数的张量积：$W_{IJ}^{\\mathrm{GIMP}}(\\mathbf{x}_p) = S^{1\\mathrm{D}}_{\\mathrm{GIMP}}(x_p) S^{1\\mathrm{D}}_{\\mathrm{GIMP}}(y_p)$。所需的一维函数 $S^{1\\mathrm{D}}_{\\mathrm{GIMP}}$ 及其空间导数 $\\partial S^{1\\mathrm{D}}_{\\mathrm{GIMP}}/\\partial x$ 作为归一化距离 $\\xi = (x_p - X_I)/h$ 和粒子尺寸与网格尺寸比 $r = \\ell_x/h$ 的分段函数给出。二维梯度 $\\nabla W_{IJ}^{\\mathrm{GIMP}}$ 使用乘法法则求得。\n\n    - **CPDI 方案**：CPDI 权重 $W_{IJ}^{\\mathrm{CPDI}}$ 及其梯度 $\\nabla W_{IJ}^{\\mathrm{CPDI}}$ 定义为标准帐篷基函数 $N_{IJ}$ 及其梯度 $\\nabla N_{IJ}$ 在粒子域 $\\mathcal{P}_p$ 上的积分。问题指定这些积分通过均匀张量积数值求积法来近似。对于一个 $n \\times n$ 的求积规则，我们在粒子域内的 $n^2$ 个点 $(\\mathbf{x}_q)$ 处评估被积函数，并计算加权和：\n    $$ W_{IJ}^{\\mathrm{CPDI}} \\approx \\frac{1}{n^2} \\sum_{q=1}^{n^2} N_{IJ}(\\mathbf{x}_q) $$\n    $$ \\nabla W_{IJ}^{\\mathrm{CPDI}} \\approx \\frac{1}{n^2} \\sum_{q=1}^{n^2} \\nabla N_{IJ}(\\mathbf{x}_q) $$\n\n    - 一旦权重和梯度已知，粒子的速度和速度梯度就被重构出来：\n    $$ \\mathbf{v}_p^{\\mathrm{rec}} = \\sum_{I,J} W_{IJ}(\\mathbf{x}_p)\\ \\mathbf{v}_{IJ} $$\n    $$ \\mathbf{L}_p^{\\mathrm{rec}} = \\sum_{I,J} \\mathbf{v}_{IJ} \\otimes \\nabla W_{IJ}(\\mathbf{x}_p) $$\n    张量 $\\mathbf{L}_p^{\\mathrm{rec}}$ 是一个 $2 \\times 2$ 矩阵。其对称部分给出了应变率张量，$\\mathbf{D}_p^{\\mathrm{rec}} = \\frac{1}{2}\\left(\\mathbf{L}_p^{\\mathrm{rec}} + (\\mathbf{L}_p^{\\mathrm{rec}})^\\mathsf{T}\\right)$。\n\n3.  **验证指标的评估**：\n    处理完一个测试用例中的所有粒子后，我们评估三个指定的标准。\n    - **应变率不变性**：对每个粒子，计算重构应变率张量的弗罗贝尼乌斯范数，$\\|\\mathbf{D}_p^{\\mathrm{rec}}\\|_F = \\sqrt{\\sum_{i,j} (D_{p,ij}^{\\mathrm{rec}})^2}$。如果所有粒子中这些范数的最大值小于或等于容差 $\\tau_D = 10^{-8} \\max(1,|\\omega|)$，则满足此标准。\n    - **动能守恒**：使用精确的解析速度场计算初始总动能 $T_{\\mathrm{initial}} = \\sum_p \\frac{1}{2} m_p \\|\\mathbf{v}(\\mathbf{x}_p)\\|^2$。使用重构的粒子速度计算重构的总动能 $T_{\\mathrm{rec}} = \\sum_p \\frac{1}{2} m_p \\|\\mathbf{v}_p^{\\mathrm{rec}}\\|^2$。如果绝对差 $|T_{\\mathrm{rec}} - T_{\\mathrm{initial}}|$ 小于或等于容差 $\\tau_T = 10^{-10}\\, \\max(T_{\\mathrm{initial}}, 1)$，则满足此标准。\n    - **无应力状态**：使用提供的平面应变线性弹性本构模型，从 $\\mathbf{D}_p^{\\mathrm{rec}}$ 计算每个粒子的应力张量 $\\boldsymbol{\\sigma}_p$：$\\boldsymbol{\\sigma}_p = \\lambda\\, \\mathrm{tr}(\\mathbf{D}_p^{\\mathrm{rec}})\\, \\mathbf{I} + 2 \\mu \\mathbf{D}_p^{\\mathrm{rec}}$。拉梅参数为 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\frac{E}{2(1+\\nu)}$。如果应力张量的最大弗罗贝尼乌斯范数 $\\max_p \\|\\boldsymbol{\\sigma}_p\\|_F$ 小于或等于容差 $\\tau_\\sigma = 10^{-2}$ Pa，则满足此标准。\n\n记录下四个测试用例中每一个的这三项检查的布尔结果。然后将包含这些布尔值的最终列表的列表格式化以供输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # No scipy functions were needed for this implementation.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for MPM rigid-body motion invariance\n    and produce the final output.\n    \"\"\"\n\n    # Helper functions for 1D basis functions and their derivatives\n    def N_1d(x, x_node, h):\n        \"\"\"Standard 1D linear hat (tent) function.\"\"\"\n        val = 1.0 - np.abs(x - x_node) / h\n        return np.maximum(0.0, val)\n\n    def dN_1d_dx(x, x_node, h):\n        \"\"\"Derivative of the 1D linear hat function w.r.t. x.\"\"\"\n        if np.abs(x - x_node)  h:\n            return -np.sign(x - x_node) / h\n        return 0.0\n\n    # Helper functions for GIMP 1D shape functions and their derivatives\n    def S_gimp_1d(xp, x_node, h, l):\n        \"\"\"GIMP 1D shape function value.\"\"\"\n        if l == 0: return 0.0\n        r = l / h\n        xi = (xp - x_node) / h\n        abs_xi = np.abs(xi)\n        \n        if abs_xi = 1.0 - r:\n            return 1.0 - abs_xi\n        elif abs_xi = 1.0 + r:\n            return (1.0 + r - abs_xi)**2 / (4.0 * r)\n        else:\n            return 0.0\n\n    def dS_gimp_1d_dx(xp, x_node, h, l):\n        \"\"\"GIMP 1D shape function derivative w.r.t. xp.\"\"\"\n        if l == 0: return 0.0\n        r = l / h\n        xi = (xp - x_node) / h\n        abs_xi = np.abs(xi)\n        sign_xi = np.sign(xi)\n\n        if abs_xi = 1.0 - r:\n            return -sign_xi / h\n        elif abs_xi = 1.0 + r:\n            return -(1.0 + r - abs_xi) / (2.0 * r * h) * sign_xi\n        else:\n            return 0.0\n\n    test_cases_def = [\n        {\n            'name': 'A', 'map_type': 'GIMP', 'omega': 25.0,\n            'particles': {\n                'centers': np.array([\n                    (0,0), (0.25,0), (-0.25,0), (0,0.25), (0,-0.25), \n                    (0.25,0.25), (-0.25,0.25), (0.25,-0.25), (-0.25,-0.25)\n                ]),\n                'l_xy_factor': (0.4, 0.45),\n            },\n            'quad_points': 0 \n        },\n        {\n            'name': 'B', 'map_type': 'CPDI', 'omega': 40.0,\n            'particles': {\n                'centers': np.array([\n                    (0,0), (0.25,0), (-0.25,0), (0,0.25), (0,-0.25), \n                    (0.25,0.25), (-0.25,0.25), (0.25,-0.25), (-0.25,-0.25)\n                ]),\n                'l_xy_factor': (0.8, 0.6),\n            },\n            'quad_points': 5\n        },\n        {\n            'name': 'C', 'map_type': 'GIMP', 'omega': 1000.0,\n            'particles': {\n                'centers': np.array([\n                    (0.5*(1/16.), 0.0), (1.5*(1/16.), 0.25), \n                    (-2.5*(1/16.), -0.25), (-0.5*(1/16.), 0.25)\n                ]),\n                'l_xy_factor': (0.45, 0.45),\n            },\n            'quad_points': 0 \n        },\n        {\n            'name': 'D', 'map_type': 'CPDI', 'omega': 0.0,\n            'particles': {\n                'centers': np.array([\n                    (0.3, 0.3), (-0.3, 0.3), (0.3, -0.3), (-0.3, -0.3)\n                ]),\n                'l_xy_factor': (1.2, 1.8),\n            },\n            'quad_points': 7\n        },\n    ]\n\n    all_results = []\n    for case in test_cases_def:\n        # --- System Parameters ---\n        N = 17\n        E = 1.0e7\n        nu = 0.3\n        rho = 2000.0\n        t = 1.0\n        h = 1.0 / (N - 1)\n        domain_min = -0.5\n        \n        map_type = case['map_type']\n        omega = case['omega']\n        particle_centers = case['particles']['centers']\n        lx_factor, ly_factor = case['particles']['l_xy_factor']\n        lx, ly = lx_factor * h, ly_factor * h\n        n_p = len(particle_centers)\n        \n        # --- Grid Setup ---\n        grid_coords_1d = np.linspace(domain_min, -domain_min, N)\n        grid_x, grid_y = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n        \n        v_nodes = np.zeros((N, N, 2))\n        v_nodes[:, :, 0] = -omega * grid_y\n        v_nodes[:, :, 1] = omega * grid_x\n\n        # --- Material Properties ---\n        lamb = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n\n        # --- Metric Initialization ---\n        total_ke_initial = 0.0\n        total_ke_reconstructed = 0.0\n        max_D_norm = 0.0\n        max_sigma_norm = 0.0\n        \n        for p_idx in range(n_p):\n            xp, yp = particle_centers[p_idx]\n            Ap = 4 * lx * ly\n            mp = rho * t * Ap\n\n            v_initial = np.array([-omega * yp, omega * xp])\n            ke_initial = 0.5 * mp * np.dot(v_initial, v_initial)\n            total_ke_initial += ke_initial\n\n            vp_rec = np.zeros(2)\n            Lp_rec = np.zeros((2, 2))\n\n            # Determine influential nodes based on the mapping scheme's support\n            if map_type == 'GIMP':\n                support_radius_x = (1.0 + lx / h) * h\n                support_radius_y = (1.0 + ly / h) * h\n            else: # CPDI\n                support_radius_x = lx + h\n                support_radius_y = ly + h\n            \n            min_I = max(0, int(np.floor((xp - support_radius_x - domain_min) / h)))\n            max_I = min(N, int(np.ceil((xp + support_radius_x - domain_min) / h)) + 1)\n            min_J = max(0, int(np.floor((yp - support_radius_y - domain_min) / h)))\n            max_J = min(N, int(np.ceil((yp + support_radius_y - domain_min) / h)) + 1)\n            \n            for I in range(min_I, max_I):\n                for J in range(min_J, max_J):\n                    x_node, y_node = grid_x[I, J], grid_y[I, J]\n                    W_ij, grad_W_ij = 0.0, np.zeros(2)\n\n                    if map_type == 'GIMP':\n                        Sx = S_gimp_1d(xp, x_node, h, lx)\n                        Sy = S_gimp_1d(yp, y_node, h, ly)\n                        if Sx > 0 and Sy > 0:\n                            dSx_dx = dS_gimp_1d_dx(xp, x_node, h, lx)\n                            dSy_dy = dS_gimp_1d_dx(yp, y_node, h, ly)\n                            W_ij = Sx * Sy\n                            grad_W_ij[0] = dSx_dx * Sy\n                            grad_W_ij[1] = Sx * dSy_dy\n                        \n                    elif map_type == 'CPDI':\n                        nq = case['quad_points']\n                        quad_pts_1d = np.linspace(-1.0, 1.0, nq)\n                        xq_pts = xp + lx * quad_pts_1d\n                        yq_pts = yp + ly * quad_pts_1d\n                        weight = 1.0 / (nq * nq)\n                        \n                        W_ij_sum, grad_W_ij_x_sum, grad_W_ij_y_sum = 0.0, 0.0, 0.0\n                        for xq in xq_pts:\n                            for yq in yq_pts:\n                                Nx = N_1d(xq, x_node, h)\n                                Ny = N_1d(yq, y_node, h)\n                                if Nx > 0 and Ny > 0:\n                                    dNx_dx = dN_1d_dx(xq, x_node, h)\n                                    dNy_dy = dN_1d_dx(yq, y_node, h)\n                                    W_ij_sum += Nx * Ny\n                                    grad_W_ij_x_sum += dNx_dx * Ny\n                                    grad_W_ij_y_sum += Nx * dNy_dy\n                        \n                        W_ij = weight * W_ij_sum\n                        grad_W_ij = weight * np.array([grad_W_ij_x_sum, grad_W_ij_y_sum])\n\n                    if W_ij > 1e-15:\n                        v_node = v_nodes[I, J, :]\n                        vp_rec += W_ij * v_node\n                        Lp_rec += np.outer(v_node, grad_W_ij)\n            \n            ke_reconstructed = 0.5 * mp * np.dot(vp_rec, vp_rec)\n            total_ke_reconstructed += ke_reconstructed\n\n            Dp_rec = 0.5 * (Lp_rec + Lp_rec.T)\n            Dp_norm = np.linalg.norm(Dp_rec, 'fro')\n            max_D_norm = max(max_D_norm, Dp_norm)\n            \n            trace_D = np.trace(Dp_rec)\n            sigma_p = lamb * trace_D * np.identity(2) + 2 * mu * Dp_rec\n            sigma_norm = np.linalg.norm(sigma_p, 'fro')\n            max_sigma_norm = max(max_sigma_norm, sigma_norm)\n\n        # --- Final Validation ---\n        tau_D = 1e-8 * max(1.0, abs(omega))\n        tau_T = 1e-10 * max(1.0, total_ke_initial)\n        tau_sigma = 1e-2\n\n        strain_zero = bool(max_D_norm = tau_D)\n        ke_constant = bool(abs(total_ke_reconstructed - total_ke_initial) = tau_T)\n        stress_zero = bool(max_sigma_norm = tau_sigma)\n        \n        all_results.append([strain_zero, ke_constant, stress_zero])\n\n    # --- Format and Print Final Output ---\n    result_strings = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3541699"}, {"introduction": "在解决了基本验证之后，我们来探讨一个更高级且精细的主题：角动量守恒。许多标准的物质点法公式在离散化后会引入非物理性的“虚假力矩”，这可能导致计算不稳定。本实践将引导您深入分析这一现象，通过对比一个简化的映射方法与先进的 CPDI 映射，您将定量地理解为何后者能够更好地保持角动量守恒，并学会如何通过后处理校正来消除这些数值误差 [@problem_id:3541779]。", "problem": "考虑在均匀笛卡尔网格上针对计算地质力学问题的二维物质点法，其中单个物质点（粒子）通过映射算子与网格节点相互作用。目标是分析由均匀、对称的柯西应力引起的内力所对应的离散角动量平衡，并量化在两种粒子到网格映射下的映射诱导扭矩：一种是作为朴素广义插值物质点法（GIMP）近似的角点平均梯度映射，另一种是随动粒子域插值（CPDI）映射。然后，您将实现一个对称校正，该校正在保持线动量的同时消除伪扭矩。\n\n从以下基本原理开始：\n\n- 物质子域的连续介质线动量平衡：内力密度由柯西应力的散度给出，由粒子离散化产生的节点内力是应力散度相对于网格形函数梯度的积分。\n- 连续介质角动量平衡要求柯西应力是对称的，并意味着在没有外力偶的情况下，净内力偶（扭矩）为零。\n- 在离散网格公式中，由于面积为 $V_p$、柯西应力为 $\\boldsymbol{\\sigma}_p$ 的粒子 $p$ 在网格节点 $i$ 处的内部节点力组装为\n$$\n\\mathbf{f}^{\\text{int}}_i \\;=\\; -\\sum_{p} V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\nabla S_{ip},\n$$\n其中 $\\nabla S_{ip}$ 是与节点 $i$ 和粒子 $p$ 相关联的映射梯度权重。关于原点的离散内扭矩为\n$$\n\\tau_z \\;=\\; \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z,\n$$\n其中 $\\mathbf{x}_i$ 是节点 $i$ 的位置，$\\times$ 是三维叉积，$\\mathbf{e}_z$ 是平面外的单位向量。\n\n本问题中使用的定义和假设：\n\n- 使用间距 $h = 1$ 米的均匀笛卡尔网格。网格节点位于 $(i\\,h, j\\,h)$，其中 $i$ 和 $j$ 为整数。\n- 在任何网格单元内，使用标准的双线性有限元基函数。对于左下角位于 $(x_0, y_0)$ 的单元，局部坐标为 $\\xi = (x-x_0)/h$ 和 $\\eta = (y-y_0)/h$，附加在四个单元顶点上的形函数为\n  - $N_{00} = (1-\\xi)(1-\\eta)$, $N_{10} = \\xi (1-\\eta)$, $N_{01} = (1-\\xi)\\eta$, $N_{11} = \\xi \\eta$,\n  相应的物理梯度为\n  $$\n  \\nabla N_{00} = \\left[-\\frac{1-\\eta}{h}, -\\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{10} = \\left[ \\frac{1-\\eta}{h}, -\\frac{\\xi}{h}\\right],\\;\n  \\nabla N_{01} = \\left[-\\frac{\\eta}{h}, \\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{11} = \\left[ \\frac{\\eta}{h}, \\frac{\\xi}{h}\\right].\n  $$\n- 粒子 $p$ 的中心为 $\\mathbf{x}_p \\in \\mathbb{R}^2$，轴对齐半维为 $a = L_x/2$，$b = L_y/2$（单位：米），平面内旋转角度为 $\\theta$（单位：弧度）。其四个角点为\n$$\n\\mathbf{x}_p^{(c)} \\;=\\; \\mathbf{x}_p + \\mathbf{R}(\\theta)\\,\\mathbf{q}^{(c)},\\quad \\text{其中}\\quad \\mathbf{q}^{(c)} \\in \\{(\\pm a, \\pm b)\\},\n$$\n按逆时针排序，$\\mathbf{R}(\\theta)$ 是平面旋转矩阵，面积为 $A_p = L_x L_y$。\n- 柯西应力是均匀且各向同性的，$\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$，其中 $p$ 的单位是帕斯卡，$\\mathbf{I}$ 是单位张量。没有体力偶，网格节点上没有外力；只考虑内力。\n- 将比较三种粒子到网格的梯度映射 $\\nabla S_{ip}$：\n  1. 朴素角点平均梯度映射（作为朴素广义插值物质点法方法的代理）：\n     $$\n     \\nabla S_{ip}^{\\text{naive}} \\;=\\; \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right),\n     $$\n     其中每个角点 $\\mathbf{x}_p^{(c)}$ 在其所在的单元中进行评估，并对该单元的四个节点产生贡献。\n  2. 随动粒子域插值（CPDI-1）映射：\n     $$\n     \\nabla S_{ip}^{\\text{CPDI}} \\;=\\; \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)},\n     $$\n     其中角点向量为\n     $$\n     \\mathbf{r}^{(c)} \\;=\\; \\frac{1}{2}\\,\\begin{bmatrix}\n     y_p^{(c+1)} - y_p^{(c-1)} \\\\\n     -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right)\n     \\end{bmatrix},\n     $$\n     对角点使用循环索引。这是针对凸四边形粒子域的标准基于边界积分的 CPDI-1 梯度。\n  3. 一种后验应用的对称校正，应用于任何组装好的内部节点力 $\\{\\mathbf{f}^{\\text{int}}_i\\}$，以在保持净内力的同时消除净内扭矩。设支撑节点位置的算术平均值为 $\\bar{\\mathbf{x}} = \\frac{1}{n}\\sum_i \\mathbf{x}_i$，并设 $J$ 是平面内 $\\pi/2$ 旋转，$J[x, y]^T = [-y, x]^T$。定义\n     $$\n     \\lambda \\;=\\; -\\,\\frac{\\tau_z}{\\sum_i \\|\\mathbf{x}_i - \\bar{\\mathbf{x}}\\|^2},\\qquad\n     \\delta\\mathbf{f}_i \\;=\\; \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right),\n     $$\n     校正后的力为 $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$。这种构造保留了 $\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$ 并强制净内扭矩为零。\n\n您的任务：\n\n- 在任何查询点所在的网格单元内，根据上述网格和基函数，实现双线性形函数及其梯度的评估。\n- 对于给定的粒子，使用上述每种映射 $\\nabla S_{ip}$ 组装内部节点力 $\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\nabla S_{ip}$。包括所有作为包含至少一个粒子角点的任何单元之顶点的节点。\n- 计算标量平面外扭矩（单位：牛顿·米），\n$$\n\\tau_z \\;=\\; \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right),\n$$\n分别针对朴素角点平均映射、CPDI映射，以及应用于朴素映射的对称校正力。将输出四舍五入到合理的浮点表示；单位必须是牛顿·米。\n\n设计一个包含三个案例的测试套件，用以探究映射引起的扭矩的不同方面：\n\n- 案例 A（理想情况，粒子完全位于一个单元内）：$\\mathbf{x}_p = (0.5,\\,0.5)$ 米，$(L_x, L_y) = (0.4,\\,0.4)$ 米，$\\theta = 0$ 弧度。\n- 案例 B（边界情况，粒子域跨越多个单元）：$\\mathbf{x}_p = (0.75,\\,0.5)$ 米，$(L_x, L_y) = (1.2,\\,0.6)$ 米，$\\theta = 0$ 弧度。\n- 案例 C（旋转情况，粒子域跨越多个单元）：$\\mathbf{x}_p = (0.5,\\,0.5)$ 米，$(L_x, L_y) = (1.2,\\,0.6)$ 米，$\\theta = \\pi/6$ 弧度。\n\n使用 $h = 1$ 米，$p = 1000$ 帕斯卡，以及 $V_p = A_p = L_x L_y$ 平方米。角度必须以弧度为单位。所有扭矩答案必须以牛顿·米为单位表示为浮点数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，包含一个由方括号括起来的、按如下顺序排列的逗号分隔的9个结果列表：\n$$\n[\\tau^{\\text{naive}}_{\\text{A}},\\;\\tau^{\\text{CPDI}}_{\\text{A}},\\;\\tau^{\\text{corr}}_{\\text{A}},\\;\\tau^{\\text{naive}}_{\\text{B}},\\;\\tau^{\\text{CPDI}}_{\\text{B}},\\;\\tau^{\\text{corr}}_{\\text{B}},\\;\\tau^{\\text{naive}}_{\\text{C}},\\;\\tau^{\\text{CPDI}}_{\\text{C}},\\;\\tau^{\\text{corr}}_{\\text{C}}].\n$$\n不应打印任何其他文本。所有值必须以牛顿·米为单位。", "solution": "本问题要求在二维均匀笛卡尔网格上，对物质点法（MPM）中由映射引起的伪扭矩进行分析。我们将实现并比较三种计算内部节点力及其产生的净内扭矩的方法，该计算针对承受均匀各向同性应力状态的单个粒子：一种朴素的角点平均梯度映射（作为朴素GIMP的代理）、随动粒子域插值（CPDI）映射，以及一种应用于朴素映射的对称后验校正。\n\n基本原理是线动量和角动量的平衡。在连续介质中，对于一个承受对称柯西应力张量 $\\boldsymbol{\\sigma}$ 且没有体力偶的物体，其净内扭矩为零。在离散的MPM公式中，此属性不一定能保持，从而导致数值误差。来自体积为 $V_p$、应力为 $\\boldsymbol{\\sigma}_p$ 的粒子 $p$ 在网格节点 $i$ 上的离散内力由下式给出：\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\nabla S_{ip}\n$$\n其中 $\\nabla S_{ip}$ 是网格基函数 $S_i$ 的粒子到网格的映射梯度。鉴于问题指定了均匀各向同性应力 $\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$，其中 $p$ 为恒定压力，$\\mathbf{I}$ 为单位张量，上式可简化为：\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\nabla S_{ip}\n$$\n关于原点的总内扭矩是这些节点力力矩的总和：\n$$\n\\tau_z = \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z = \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right)\n$$\n其中 $\\mathbf{x}_i = [x_i, y_i]^T$ 是节点 $i$ 的位置，$\\mathbf{f}^{\\text{int}}_i = [f^{\\text{int}}_{i,x}, f^{\\text{int}}_{i,y}]^T$。问题设置在二维空间中，网格间距 $h=1$ 米。考虑单个粒子，其体积 $V_p$ 取为其面积 $A_p = L_x L_y$。压力给定为 $p=1000$ 帕斯卡。\n\n我们的计算流程如下：\n首先，我们建立几何和有限元工具。对于任意点 $\\mathbf{x} \\in \\mathbb{R}^2$，我们必须确定其所在的网格单元，并评估与该单元四个顶点相关的双线性形函数 $N_i(\\mathbf{x})$ 及其梯度 $\\nabla N_i(\\mathbf{x})$。在局部坐标 $\\xi, \\eta$ 下，给定的 $N_i$ 和 $\\nabla N_i$ 公式被实现。\n\n其次，对于三个测试案例中的每一个，我们定义粒子的几何形状。给定其中心 $\\mathbf{x}_p$、尺寸 $(L_x, L_y)$ 和旋转角 $\\theta$，我们计算其四个角点 $\\mathbf{x}_p^{(c)}$ 的世界坐标及其面积 $A_p$。\n\n第三，我们实现三种不同的方法来计算节点力和扭矩。\n\n1.  **朴素角点平均映射**：\n    梯度权重是在粒子四个角点处评估的标准有限元形函数梯度的平均值：\n    $$\n    \\nabla S_{ip}^{\\text{naive}} = \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\n    $$\n    我们确定所有唯一网格节点的集合，这些节点是任何包含一个或多个粒子角点的单元的顶点。对于每个这样的节点 $i$，我们对来自每个角点的梯度贡献求和，然后取平均值。然后计算内力 $\\mathbf{f}^{\\text{int}}_i$，并对总扭矩 $\\tau_z^{\\text{naive}}$ 求和。这种方法通常不保守角动量，当粒子与网格不对称排列时，我们预计会产生非零扭矩。\n\n2.  **随动粒子域插值（CPDI）映射**：\n    CPDI梯度映射被设计为变分一致的，并且已知即使对于一般的四边形粒子域，在均匀应力状态下也能精确地保守线动量和角动量。梯度定义为：\n    $$\n    \\nabla S_{ip}^{\\text{CPDI}} = \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)}\n    $$\n    其中 $\\mathbf{r}^{(c)}$ 是从粒子角点坐标派生出的几何向量：\n    $$\n    \\mathbf{r}^{(c)} = \\frac{1}{2}\\,\\begin{bmatrix} y_p^{(c+1)} - y_p^{(c-1)} \\\\ -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right) \\end{bmatrix}\n    $$\n    该过程首先涉及使用角点的循环索引计算四个向量 $\\mathbf{r}^{(c)}$。然后，对于每个角点，我们在其位置评估形函数 $N_i$，并累加加权和以得到 $\\nabla S_{ip}^{\\text{CPDI}}$。然后计算力及其产生的扭矩 $\\tau_z^{\\text{CPDI}}$。理论上，我们预期所有测试案例的 $\\tau_z^{\\text{CPDI}} = 0$。\n\n3.  **对称校正**：\n    该方法提供了一种后验强制角动量平衡的方法。从一组产生非零扭矩 $\\tau_z$ 的内力 $\\{\\mathbf{f}^{\\text{int}}_i\\}$（在我们的例子中，是来自朴素映射的力）开始，我们计算一组校正节点力 $\\{\\delta\\mathbf{f}_i\\}$，其合力为零，但净扭矩为 $-\\tau_z$。校正定义为：\n    $$\n    \\delta\\mathbf{f}_i = \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right) \\quad \\text{其中} \\quad \\lambda = -\\,\\frac{\\tau_z}{\\sum_j \\|\\mathbf{x}_j - \\bar{\\mathbf{x}}\\|^2}\n    $$\n    这里，$\\bar{\\mathbf{x}}$ 是支撑节点位置的形心，$J$ 是 $\\pi/2$ 旋转的算子。校正后的力为 $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$。根据构造，$\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$（如果存在线动量平衡，则予以保持），并且新的总扭矩 $\\tau_z^{\\text{corr}}$ 为零（在浮点精度范围内）。\n\n我们将此三步分析应用于每个测试案例（A、B 和 C），并收集九个最终的扭矩值作为最终输出。计算使用双精度浮点算术进行。\n-   **案例 A**：一个小的、未旋转的粒子完全位于一个单元内。由于完全对称，我们预计所有三种方法都将产生零扭矩。\n-   **案例 B**：一个较大的、未旋转的粒子跨越单元边界。这种不对称性预计会为朴素映射产生非零扭矩。\n-   **案例 C**：一个大的、旋转的粒子，中心位于一个单元内但跨越多个单元。这种复杂的几何形状也预计会在朴素映射中引起伪扭矩。\n\n对于CPDI和校正方法，扭矩的理论结果均为 $0$。考虑到浮点运算的限制，实现应产生非常接近零的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculations for all test cases.\n    \"\"\"\n    H = 1.0  # Grid spacing\n    P = 1000.0  # Pressure\n\n    # (center, (Lx, Ly), theta)\n    test_cases = [\n        # Case A\n        ((0.5, 0.5), (0.4, 0.4), 0.0),\n        # Case B\n        ((0.75, 0.5), (1.2, 0.6), 0.0),\n        # Case C\n        ((0.5, 0.5), (1.2, 0.6), np.pi / 6.0),\n    ]\n\n    results = []\n    for xp, L, theta in test_cases:\n        particle = Particle(xp, L, theta)\n\n        # 1. Naive corner-averaged mapping\n        naive_forces = calculate_naive_forces(particle, P, H)\n        tau_naive = calculate_torque(naive_forces)\n\n        # 2. CPDI mapping\n        cpdi_forces = calculate_cpdi_forces(particle, P, H)\n        tau_cpdi = calculate_torque(cpdi_forces)\n\n        # 3. Symmetric correction on naive forces\n        _, tau_corr = apply_correction(naive_forces, tau_naive)\n\n        results.extend([tau_naive, tau_cpdi, tau_corr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_shape_info(point, h=1.0):\n    \"\"\"\n    Calculates shape functions and gradients for a point in a Cartesian grid.\n\n    Args:\n        point (np.ndarray): The (x, y) coordinates of the query point.\n        h (float): The grid cell spacing.\n\n    Returns:\n        dict: A dictionary mapping node coordinates (tuples) to their\n              shape function values ('N') and gradients ('gradN').\n    \"\"\"\n    x, y = point\n    x0 = np.floor(x / h) * h\n    y0 = np.floor(y / h) * h\n\n    xi = (x - x0) / h\n    eta = (y - y0) / h\n\n    # Node coordinates for the cell, ordered to match N00, N10, N01, N11\n    nodes_coords = [\n        (x0, y0),          # For N00\n        (x0 + h, y0),      # For N10\n        (x0, y0 + h),      # For N01\n        (x0 + h, y0 + h),  # For N11\n    ]\n\n    # Shape function values\n    N_vals = [\n        (1 - xi) * (1 - eta),  # N00\n        xi * (1 - eta),        # N10\n        (1 - xi) * eta,        # N01\n        xi * eta,              # N11\n    ]\n\n    # Shape function gradients\n    grad_N_vals = [\n        np.array([-(1 - eta) / h, -(1 - xi) / h]),  # gradN00\n        np.array([(1 - eta) / h, -xi / h]),         # gradN10\n        np.array([-eta / h, (1 - xi) / h]),        # gradN01\n        np.array([eta / h, xi / h]),               # gradN11\n    ]\n\n    info = {}\n    for i in range(4):\n        info[nodes_coords[i]] = {'N': N_vals[i], 'gradN': grad_N_vals[i]}\n    return info\n\nclass Particle:\n    \"\"\"\n    Represents a 2D rectangular material point (particle).\n    \"\"\"\n\n    def __init__(self, xp, L, theta):\n        \"\"\"\n        Initializes the particle's geometry.\n\n        Args:\n            xp (tuple): Center coordinates (x, y).\n            L (tuple): Dimensions (Lx, Ly).\n            theta (float): Rotation angle in radians.\n        \"\"\"\n        self.xp = np.array(xp)\n        self.Lx, self.Ly = L\n        self.theta = theta\n        self.Ap = self.Lx * self.Ly\n\n        a = self.Lx / 2.0\n        b = self.Ly / 2.0\n\n        # Local corner coordinates, ordered CCW for r_c calculation\n        q_local = [\n            np.array([a, -b]),\n            np.array([a, b]),\n            np.array([-a, b]),\n            np.array([-a, -b]),\n        ]\n\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n\n        self.corners = [self.xp + R @ qc for qc in q_local]\n\ndef calculate_naive_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the naive corner-averaged mapping.\n    \"\"\"\n    grad_S = {}\n    \n    for c_idx in range(4):\n        corner_pos = particle.corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_S:\n                grad_S[node_coord] = np.zeros(2)\n            grad_S[node_coord] += info['gradN']\n            \n    forces = {}\n    for node_coord, summed_grad in grad_S.items():\n        avg_grad = summed_grad / 4.0\n        # Force is -Vp*p*gradS; problem states Vp = Ap\n        forces[node_coord] = -particle.Ap * p * avg_grad\n\n    return forces\n\ndef calculate_cpdi_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the CPDI mapping.\n    \"\"\"\n    corners = particle.corners\n    r_c = []\n    for c_idx in range(4):\n        c_prev = (c_idx - 1 + 4) % 4\n        c_next = (c_idx + 1) % 4\n        \n        xp_prev, yp_prev = corners[c_prev]\n        xp_next, yp_next = corners[c_next]\n        \n        r_vec = 0.5 * np.array([yp_next - yp_prev, -(xp_next - xp_prev)])\n        r_c.append(r_vec)\n        \n    grad_S = {}\n    for c_idx in range(4):\n        corner_pos = corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        r_vec = r_c[c_idx]\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_S:\n                grad_S[node_coord] = np.zeros(2, dtype=float)\n            grad_S[node_coord] += info['N'] * r_vec\n            \n    forces = {}\n    for node_coord, summed_N_r in grad_S.items():\n        grad = summed_N_r / particle.Ap\n        # Force is -Vp*sigma.gradS = -Vp*p*gradS; Vp=Ap\n        forces[node_coord] = -particle.Ap * p * grad\n\n    return forces\n\ndef calculate_torque(forces):\n    \"\"\"\n    Computes the total 2D torque about the origin from a set of nodal forces.\n    \"\"\"\n    tau_z = 0.0\n    for node_coord, f_int in forces.items():\n        x_i, y_i = node_coord\n        f_x, f_y = f_int\n        tau_z += x_i * f_y - y_i * f_x\n    return tau_z\n\ndef apply_correction(forces, tau_z):\n    \"\"\"\n    Applies the symmetric correction to a set of forces to nullify torque.\n    \"\"\"\n    if np.isclose(tau_z, 0.0):\n        return forces, 0.0\n        \n    node_coords_list = list(forces.keys())\n    node_coords = np.array(node_coords_list)\n    \n    if len(node_coords)  2:\n        return forces, tau_z\n\n    x_bar = np.mean(node_coords, axis=0)\n    \n    sum_sq_dist = np.sum((node_coords - x_bar)**2)\n        \n    if np.isclose(sum_sq_dist, 0.0):\n        return forces, tau_z\n\n    lambda_corr = -tau_z / sum_sq_dist\n    \n    corr_forces = {}\n    for node_coord_tuple in node_coords_list:\n        node_coord = np.array(node_coord_tuple)\n        d_i = node_coord - x_bar\n        # delta_f_i = lambda * J(d_i) where J(d_i) = [-d_i_y, d_i_x]\n        delta_f_i = lambda_corr * np.array([-d_i[1], d_i[0]])\n        corr_forces[node_coord_tuple] = forces[node_coord_tuple] + delta_f_i\n        \n    new_tau = calculate_torque(corr_forces)\n    \n    return corr_forces, new_tau\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3541779"}]}