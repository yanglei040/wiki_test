{"hands_on_practices": [{"introduction": "深入理解连续介质力学中的守恒定律，始于对基本方程的分析应用。[@problem_id:3507715] 这个练习旨在巩固你对欧拉框架下质量守恒方程（即连续性方程）的理解。通过一个给定的密度和速度场，你将直接推导速度场的散度如何受密度场时空变化的制约，从而在数学上具体把握这一核心物理原理。", "problem": "在一个变形地质层内，可压缩的孔隙流体在欧拉框架下通过一个密度场来建模，该密度场由 $\\rho(\\mathbf{x},t)=\\rho_{0}\\exp(-\\kappa t)\\left(1+\\epsilon x\\right)$ 给出，其中 $\\rho_{0}$、$\\kappa$ 和 $\\epsilon$ 是常数，且 $\\kappa>0$，以及 $|\\epsilon x|\\ll 1$。速度场具有已知的 $x$ 分量 $v_{x}(\\mathbf{x},t)=\\gamma t$，其中 $\\gamma$ 是一个常数，而其余分量未指定。假设场是光滑的，并且 $\\epsilon$ 是一个无量纲的小参数。从质量守恒的欧拉形式出发，并保留到 $\\epsilon$ 的一阶项，确定为使质量守恒成立所需的速度散度 $\\nabla\\cdot\\mathbf{v}$。\n\n请用 $\\kappa$、$\\gamma$、$\\epsilon$ 和 $t$ 表示您的最终答案，形式为一个闭式解析表达式。忽略所有 $\\epsilon^{2}$ 阶及更高阶的项。不需要四舍五入，最终表达式中不应包含任何单位。", "solution": "首先对问题进行验证，以确保其具有科学依据、良定性及客观性。\n\n**步骤 1：提取已知条件**\n-   欧拉框架下的流体密度场由 $\\rho(\\mathbf{x},t)=\\rho_{0}\\exp(-\\kappa t)\\left(1+\\epsilon x\\right)$ 给出。\n-   常数为 $\\rho_{0}$、$\\kappa$、$\\epsilon$ 和 $\\gamma$。\n-   约束和条件为 $\\kappa>0$ 和 $|\\epsilon x|\\ll 1$。\n-   速度场的 $x$ 分量为 $v_{x}(\\mathbf{x},t)=\\gamma t$。\n-   问题需从质量守恒的欧拉形式出发求解。\n-   解必须只保留到无量纲小参数 $\\epsilon$ 的一阶项。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于连续介质力学中的质量守恒原理，这是物理学和工程学（包括计算地质力学）中的一个基本概念。指定的密度和速度形式是简化的数学模型，但对于变形介质中流体流动的一阶分析而言，它们在物理上是合理的。该问题具有科学合理性。\n-   **良定性**：问题要求计算速度场的散度 $\\nabla\\cdot\\mathbf{v}$。质量守恒方程提供了密度 $\\rho$ 和速度场 $\\mathbf{v}$ 之间的一个标量关系。给定 $\\rho(\\mathbf{x}, t)$ 的显式函数形式，其导数可以计算出来。质量守恒方程随后成为一个关于 $\\nabla\\cdot\\mathbf{v}$ 的代数方程。所有必要的信息都已提供，可以唯一地确定 $\\nabla\\cdot\\mathbf{v}$ 到所需的近似阶数。\n-   **客观性**：问题使用精确的数学语言陈述，具有明确定义的变量和目标，没有任何主观或模糊的术语。\n\n**步骤 3：结论与行动**\n该问题被认为是有效的。将推导解答。\n\n出发点是质量守恒的欧拉形式，也称为连续性方程：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) = 0\n$$\n使用标量-矢量乘积散度的乘法法则，$\\nabla \\cdot (\\rho \\mathbf{v}) = (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v})$，方程变为：\n$$\n\\frac{\\partial \\rho}{\\partial t} + (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0\n$$\n我们可以重新整理这个方程来求解速度场的散度 $\\nabla \\cdot \\mathbf{v}$：\n$$\n\\nabla \\cdot \\mathbf{v} = -\\frac{1}{\\rho} \\left( \\frac{\\partial \\rho}{\\partial t} + (\\nabla \\rho) \\cdot \\mathbf{v} \\right)\n$$\n为了继续，我们必须根据给定的密度场 $\\rho(\\mathbf{x},t)=\\rho_{0}\\exp(-\\kappa t)(1+\\epsilon x)$ 计算 $\\frac{\\partial \\rho}{\\partial t}$ 和 $\\nabla \\rho$ 这两项。\n\n首先，密度对时间 $t$ 的偏导数为：\n$$\n\\frac{\\partial \\rho}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\rho_{0}\\exp(-\\kappa t)(1+\\epsilon x) \\right] = \\rho_{0}(1+\\epsilon x) \\frac{d}{dt}\\left(\\exp(-\\kappa t)\\right) = -\\kappa \\rho_{0}\\exp(-\\kappa t)(1+\\epsilon x)\n$$\n注意到 $\\rho = \\rho_{0}\\exp(-\\kappa t)(1+\\epsilon x)$，这可以简化为：\n$$\n\\frac{\\partial \\rho}{\\partial t} = -\\kappa \\rho\n$$\n接下来，我们计算密度的梯度 $\\nabla \\rho$。密度场 $\\rho(\\mathbf{x},t)$ 在空间上仅依赖于坐标 $x$。因此，对 $y$ 和 $z$ 的偏导数为零。\n$$\n\\nabla \\rho = \\mathbf{i} \\frac{\\partial \\rho}{\\partial x} + \\mathbf{j} \\frac{\\partial \\rho}{\\partial y} + \\mathbf{k} \\frac{\\partial \\rho}{\\partial z} = \\mathbf{i} \\frac{\\partial}{\\partial x} \\left[ \\rho_{0}\\exp(-\\kappa t)(1+\\epsilon x) \\right]\n$$\n$$\n\\frac{\\partial \\rho}{\\partial x} = \\rho_{0}\\exp(-\\kappa t) \\frac{\\partial}{\\partial x}(1+\\epsilon x) = \\rho_{0}\\exp(-\\kappa t)\\epsilon\n$$\n所以梯度是：\n$$\n\\nabla \\rho = \\epsilon \\rho_{0}\\exp(-\\kappa t) \\mathbf{i}\n$$\n现在我们计算点积 $(\\nabla \\rho) \\cdot \\mathbf{v}$。速度矢量为 $\\mathbf{v} = v_x \\mathbf{i} + v_y \\mathbf{j} + v_z \\mathbf{k}$。我们已知 $v_x = \\gamma t$。\n$$\n(\\nabla \\rho) \\cdot \\mathbf{v} = \\left( \\epsilon \\rho_{0}\\exp(-\\kappa t) \\mathbf{i} \\right) \\cdot \\left( (\\gamma t) \\mathbf{i} + v_y \\mathbf{j} + v_z \\mathbf{k} \\right) = \\epsilon \\gamma t \\rho_{0}\\exp(-\\kappa t)\n$$\n注意，未指定的速度分量 $v_y$ 和 $v_z$ 对此项没有贡献。\n\n将 $\\frac{\\partial \\rho}{\\partial t}$ 和 $(\\nabla \\rho) \\cdot \\mathbf{v}$ 的表达式代入 $\\nabla \\cdot \\mathbf{v}$ 的方程中：\n$$\n\\nabla \\cdot \\mathbf{v} = -\\frac{1}{\\rho} \\left( -\\kappa \\rho + \\epsilon \\gamma t \\rho_{0}\\exp(-\\kappa t) \\right)\n$$\n$$\n\\nabla \\cdot \\mathbf{v} = \\kappa - \\frac{\\epsilon \\gamma t \\rho_{0}\\exp(-\\kappa t)}{\\rho}\n$$\n现在，代入 $\\rho$ 的完整表达式：\n$$\n\\nabla \\cdot \\mathbf{v} = \\kappa - \\frac{\\epsilon \\gamma t \\rho_{0}\\exp(-\\kappa t)}{\\rho_{0}\\exp(-\\kappa t)(1+\\epsilon x)}\n$$\n消去公因子 $\\rho_{0}\\exp(-\\kappa t)$：\n$$\n\\nabla \\cdot \\mathbf{v} = \\kappa - \\frac{\\epsilon \\gamma t}{1+\\epsilon x}\n$$\n问题要求保留到 $\\epsilon$ 的一阶项。我们对 $(1+\\epsilon x)^{-1}$ 这一项使用几何级数展开。对于小参数 $u$，$(1+u)^{-1} = 1 - u + u^2 - \\dots$。鉴于 $|\\epsilon x| \\ll 1$，我们可以近似为：\n$$\n\\frac{1}{1+\\epsilon x} \\approx 1 - \\epsilon x\n$$\n将此近似值代入 $\\nabla \\cdot \\mathbf{v}$ 的表达式中：\n$$\n\\nabla \\cdot \\mathbf{v} \\approx \\kappa - \\epsilon \\gamma t (1 - \\epsilon x)\n$$\n$$\n\\nabla \\cdot \\mathbf{v} \\approx \\kappa - \\epsilon \\gamma t + \\epsilon^{2} \\gamma t x\n$$\n问题陈述要求忽略所有 $\\epsilon^{2}$ 阶及更高阶的项。项 $\\epsilon^{2} \\gamma t x$ 是 $\\epsilon$ 的二阶项，必须舍弃。这样就得到了散度的最终表达式，它在 $\\epsilon$ 的一阶上有效：\n$$\n\\nabla \\cdot \\mathbf{v} = \\kappa - \\epsilon \\gamma t\n$$", "answer": "$$\\boxed{\\kappa - \\epsilon \\gamma t}$$", "id": "3507715"}, {"introduction": "在掌握了基本原理之后，我们将质量守恒的概念拓展到一个更真实、更复杂的情景：一个饱和、可变形且发生化学反应的多孔介质。[@problem_id:3507660] 这个练习将引导你推导宏观属性（如孔隙度 $\\phi$ 和整体密度 $\\rho$）如何因潜在的物理过程（如塑性应变 $\\dot{\\varepsilon}_v^p$ 和化学反应 $\\dot{m}_s^r$）而演化。通过编程验证你的推导，你将体验到如何将连续介质理论转化为可执行的岩土力学计算模型，这是计算岩土力学中的关键一步。", "problem": "考虑一个由固体骨架和孔隙填充流体组成的饱和多孔地质材料。设其宏观质量密度由基于本征相密度和孔隙度的混合法则定义。假设小应变运动学和一个明确定义的孔隙度场。采用以下定义和假设来构建您的推导和算法。\n\n定义：\n- 孔隙度用 $\\phi$ 表示，其中 $0 \\le \\phi \\le 1$，固体体积分数为 $1-\\phi$。\n- 本征固体质量密度为 $\\rho_s$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$；本征流体质量密度为 $\\rho_f$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n- 宏观质量密度为 $\\rho$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n- 塑性体积应变率为 $\\dot{\\varepsilon}_v^p$，单位为 $\\mathrm{s}^{-1}$，定义为当骨架膨胀（体积增加）时为正。\n- 单位宏观体积的固相反应质量去除率为 $\\dot{m}_s^r$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$（对于溶解从宏观体积中去除固体质量的情况为正）。\n- 本征固体密度变化率为 $\\dot{\\rho}_s$，单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n- 假设在所考虑的时间尺度上，流体是不可压缩或密度不变的，因此 $\\dot{\\rho}_f = 0$。\n\n基本出发点：\n- 宏观质量密度的混合法则：$\\rho = (1-\\phi)\\rho_s + \\phi \\rho_f$。\n- 小应变下由于固体骨架的塑性体积变化和固体质量的反应性溶解引起的孔隙度变化的定义：通过结合固体分数的运动学体积变化以及使用本征固体密度 $\\rho_s$ 将单位宏观体积的固体质量去除率转换为等效的固体体积分数变化，从第一性原理推导 $\\dot{\\phi}$。\n\n任务：\n1. 基于上述基本原理，推导一个同时考虑塑性体积应变和反应性溶解的 $\\dot{\\phi}$ 表达式，该表达式用 $\\phi$、$\\dot{\\varepsilon}_v^p$、$\\dot{m}_s^r$ 和 $\\rho_s$ 表示。\n2. 从混合法则出发，通过应用与上述假设一致的链式法则，推导宏观质量密度的时间变化率 $\\dot{\\rho}$。将此变化率表示为两种数学上等价的分解形式：一种是基于链式法则作用于 $\\rho = (1-\\phi)\\rho_s + \\phi \\rho_f$ 的形式，另一种是基于与 $\\phi$ 和 $\\rho_s$ 变化相关的分项贡献形式，同时应用假设 $\\dot{\\rho}_f = 0$。证明对于任何允许的 $(\\phi, \\rho_s, \\rho_f, \\dot{\\phi}, \\dot{\\rho}_s)$，这两种分解是相同的。\n3. 实现一个程序，对于每个测试用例，计算任务1中的 $\\dot{\\phi}$，评估任务2中 $\\dot{\\rho}$ 的两种分解形式，并返回一个布尔值，指示它们的差值是否小于规定的容差。使用绝对容差 $\\tau = 10^{-12}$（无量纲）来判断相等。如果绝对差小于或等于 $\\tau$，则布尔值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n单位和数据要求：\n- 使用无量纲的 $\\phi$。\n- 使用单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 的 $\\rho_s$ 和 $\\rho_f$。\n- 使用单位为 $\\mathrm{s}^{-1}$ 的 $\\dot{\\varepsilon}_v^p$。\n- 使用单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$ 的 $\\dot{m}_s^r$。\n- 使用单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$ 的 $\\dot{\\rho}_s$。\n\n测试套件：\n提供一个程序，评估以下五个涵盖典型、边缘和混合场景的案例：\n- 案例A（典型）：$\\phi = 0.25$, $\\rho_s = 2700\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_f = 1000\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\dot{\\varepsilon}_v^p = 2\\times 10^{-6}\\,\\mathrm{s}^{-1}$, $\\dot{m}_s^r = 1\\times 10^{-3}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$, $\\dot{\\rho}_s = 0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n- 案例B（近乎固体，沉淀和压实）：$\\phi = 0.01$, $\\rho_s = 2650\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_f = 1000\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\dot{\\varepsilon}_v^p = 1\\times 10^{-5}\\,\\mathrm{s}^{-1}$, $\\dot{m}_s^r = -1\\times 10^{-3}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$, $\\dot{\\rho}_s = 1\\times 10^{-3}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n- 案例C（近乎流体，伴随溶解的膨胀）：$\\phi = 0.99$, $\\rho_s = 2700\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_f = 1000\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\dot{\\varepsilon}_v^p = 5\\times 10^{-5}\\,\\mathrm{s}^{-1}$, $\\dot{m}_s^r = 2\\times 10^{-4}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$, $\\dot{\\rho}_s = 0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n- 案例D（无反应的压实，固体可压缩性）：$\\phi = 0.40$, $\\rho_s = 2700\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_f = 1000\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\dot{\\varepsilon}_v^p = -3\\times 10^{-6}\\,\\mathrm{s}^{-1}$, $\\dot{m}_s^r = 0\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$, $\\dot{\\rho}_s = 9\\times 10^{-4}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n- 案例E（混合岩性和盐水，伴随密度降低的强膨胀和溶解）：$\\phi = 0.60$, $\\rho_s = 2200\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_f = 1020\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\dot{\\varepsilon}_v^p = 1\\times 10^{-4}\\,\\mathrm{s}^{-1}$, $\\dot{m}_s^r = 5\\times 10^{-3}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$, $\\dot{\\rho}_s = -2\\times 10^{-3}\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$）。对于上述五个案例，预期的输出列表包含按所列顺序（案例A到案例E）的五个布尔条目。", "solution": "用户提供了一个计算地质力学领域内科学上有效且定义明确的问题。该问题要求在饱和多孔介质中推导孔隙度和宏观密度的关键演化方程，然后对推导出的表达式进行数值验证。推导将基于连续介质力学和混合物理论的基本原理，并遵循指定的假设。\n\n### 任务1：孔隙度变化率 ($\\dot{\\phi}$) 的推导\n\n孔隙度 $\\phi$ 定义为孔隙体积 $V_p$ 与总宏观体积 $V_b$ 之比，即 $\\phi = V_p / V_b$。孔隙度的变化率 $\\dot{\\phi}$ 源于问题中指定的两个不同的物理过程：固体骨架的塑性变形和固相的反应性溶解或沉淀。我们在小应变假设下分别推导每个过程的贡献，然后将它们组合起来。\n\n1.  **塑性体积应变 ($\\dot{\\varepsilon}_v^p$) 的贡献**：塑性体积应变率 $\\dot{\\varepsilon}_v^p$ 定义为归因于固体颗粒塑性重排的宏观体积变化率。对于此变形过程，假设固体材料不可压缩。因此，由塑性变形引起的任何宏观体积变化必须等于孔隙体积的变化，即 $\\dot{V}_b^p = \\dot{V}_p^p$。塑性体积应变率通过 $\\dot{\\varepsilon}_v^p = \\dot{V}_b^p / V_b$ 与宏观体积变化相关。孔隙度的时间导数由商法则给出：\n    $$\n    \\dot{\\phi} = \\frac{d}{dt}\\left(\\frac{V_p}{V_b}\\right) = \\frac{\\dot{V}_p V_b - V_p \\dot{V}_b}{V_b^2} = \\frac{\\dot{V}_p}{V_b} - \\phi \\frac{\\dot{V}_b}{V_b}\n    $$\n    仅考虑塑性变形引起的变化，我们代入 $\\dot{V}_p = \\dot{V}_p^p$ 和 $\\dot{V}_b = \\dot{V}_b^p$：\n    $$\n    \\dot{\\phi}_{\\text{deform}} = \\frac{\\dot{V}_b^p}{V_b} - \\phi \\frac{\\dot{V}_b^p}{V_b} = \\dot{\\varepsilon}_v^p - \\phi \\dot{\\varepsilon}_v^p = (1-\\phi)\\dot{\\varepsilon}_v^p\n    $$\n    正的 $\\dot{\\varepsilon}_v^p$（膨胀）正确地导致孔隙度增加。\n\n2.  **反应性质量传递 ($\\dot{m}_s^r$) 的贡献**：项 $\\dot{m}_s^r$ 表示单位宏观体积的固体质量去除率（$\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$）。除以本征固体密度 $\\rho_s$，得到单位宏观体积的固体体积变化率：$\\dot{V}_s^r / V_b = -\\dot{m}_s^r/\\rho_s$。负号表示正的 $\\dot{m}_s^r$（溶解）会减少固体体积。在此过程中，被移除的固体体积被孔隙流体所取代，因此孔隙体积的变化与固体体积的变化大小相等、方向相反，即 $\\dot{V}_p^r = -\\dot{V}_s^r$。假设在此化学过程中宏观体积保持不变，因此 $\\dot{V}_b^r = 0$。由此产生的孔隙度变化率为：\n    $$\n    \\dot{\\phi}_{\\text{react}} = \\frac{\\dot{V}_p^r}{V_b} - \\phi \\frac{\\dot{V}_b^r}{V_b} = \\frac{-\\dot{V}_s^r}{V_b} - 0 = \\frac{\\dot{m}_s^r}{\\rho_s}\n    $$\n\n3.  **总孔隙度变化率**：总孔隙度变化率是两个独立过程变化率的总和：\n    $$\n    \\dot{\\phi} = \\dot{\\phi}_{\\text{deform}} + \\dot{\\phi}_{\\text{react}} = (1-\\phi)\\dot{\\varepsilon}_v^p + \\frac{\\dot{m}_s^r}{\\rho_s}\n    $$\n    这是孔隙度变化率的最终表达式。\n\n### 任务2：宏观密度变化率 ($\\dot{\\rho}$) 的推导\n\n宏观质量密度 $\\rho$ 由混合法则给出：\n$$\n\\rho = (1-\\phi)\\rho_s + \\phi \\rho_f\n$$\n我们被要求以两种等价形式推导其时间变化率 $\\dot{\\rho}$，并假设流体不可压缩（$\\dot{\\rho}_f = 0$）。\n\n**分解1：逐项乘积法则**\n\n我们将宏观密度视为两个乘积之和，$\\rho = [(1-\\phi)\\rho_s] + [\\phi\\rho_f]$，并对每一项应用乘积求导法则：\n$$\n\\dot{\\rho} = \\frac{d}{dt}[(1-\\phi)\\rho_s] + \\frac{d}{dt}[\\phi\\rho_f]\n$$\n$$\n\\dot{\\rho} = \\left[\\frac{d(1-\\phi)}{dt}\\rho_s + (1-\\phi)\\frac{d\\rho_s}{dt}\\right] + \\left[\\frac{d\\phi}{dt}\\rho_f + \\phi\\frac{d\\rho_f}{dt}\\right]\n$$\n代入变化率符号和假设 $\\dot{\\rho}_f = 0$：\n$$\n\\dot{\\rho}_1 = [-\\dot{\\phi}\\rho_s + (1-\\phi)\\dot{\\rho}_s] + [\\dot{\\phi}\\rho_f + \\phi \\cdot 0]\n$$\n$$\n\\dot{\\rho}_1 = -\\dot{\\phi}\\rho_s + (1-\\phi)\\dot{\\rho}_s + \\dot{\\phi}\\rho_f\n$$\n\n**分解2：多元链式法则**\n\n我们将宏观密度 $\\rho$ 视为随时间变化的变量 $\\phi$、$\\rho_s$ 和 $\\rho_f$ 的函数，即 $\\rho(\\phi, \\rho_s, \\rho_f)$。全时间导数由多元链式法则给出：\n$$\n\\dot{\\rho} = \\frac{\\partial \\rho}{\\partial \\phi}\\dot{\\phi} + \\frac{\\partial \\rho}{\\partial \\rho_s}\\dot{\\rho}_s + \\frac{\\partial \\rho}{\\partial \\rho_f}\\dot{\\rho}_f\n$$\n我们根据 $\\rho$ 的定义计算偏导数：\n$$\n\\frac{\\partial \\rho}{\\partial \\phi} = \\frac{\\partial}{\\partial \\phi}((1-\\phi)\\rho_s + \\phi\\rho_f) = -\\rho_s + \\rho_f = -(\\rho_s - \\rho_f)\n$$\n$$\n\\frac{\\partial \\rho}{\\partial \\rho_s} = \\frac{\\partial}{\\partial \\rho_s}((1-\\phi)\\rho_s + \\phi\\rho_f) = 1-\\phi\n$$\n$$\n\\frac{\\partial \\rho}{\\partial \\rho_f} = \\frac{\\partial}{\\partial \\rho_f}((1-\\phi)\\rho_s + \\phi\\rho_f) = \\phi\n$$\n将这些偏导数代入链式法则表达式，并应用条件 $\\dot{\\rho}_f=0$：\n$$\n\\dot{\\rho}_2 = -(\\rho_s - \\rho_f)\\dot{\\phi} + (1-\\phi)\\dot{\\rho}_s + \\phi \\cdot 0\n$$\n$$\n\\dot{\\rho}_2 = (\\rho_f - \\rho_s)\\dot{\\phi} + (1-\\phi)\\dot{\\rho}_s\n$$\n\n**分解的等价性**\n\n为了证明两种分解是相同的，我们重新排列 $\\dot{\\rho}_1$ 的各项：\n$$\n\\dot{\\rho}_1 = -\\dot{\\phi}\\rho_s + (1-\\phi)\\dot{\\rho}_s + \\dot{\\phi}\\rho_f = \\dot{\\phi}(\\rho_f - \\rho_s) + (1-\\phi)\\dot{\\rho}_s\n$$\n这恰好是 $\\dot{\\rho}_2$ 的表达式。因此，$\\dot{\\rho}_1 \\equiv \\dot{\\rho}_2$，证明了对于任何允许的参数集，它们在数学上是等价的。\n\n### 任务3：算法实现\n\n所提供的Python代码将为给定的测试用例实现这些推导出的公式。对于每个案例，算法将：\n1.  使用任务1中推导的表达式计算孔隙度变化率 $\\dot{\\phi}$。\n2.  使用任务2中推导的分解1 ($\\dot{\\rho}_1$) 和分解2 ($\\dot{\\rho}_2$) 计算宏观密度变化率。\n3.  评估布尔条件 $|\\dot{\\rho}_1 - \\dot{\\rho}_2| \\le \\tau$，其中容差 $\\tau$ 为 $10^{-12}$。\n4.  收集所有测试用例的布尔结果，并以指定的列表格式打印。此检查在数值上确认了两种分解的代数恒等性，同时考虑了潜在的浮点表示差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geomechanics problem by deriving and comparing expressions for bulk density rate.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (phi, rho_s, rho_f, dot_eps_vp, dot_ms_r, dot_rho_s)\n    # Units:\n    # phi: dimensionless\n    # rho_s, rho_f: kg/m^3\n    # dot_eps_vp: 1/s\n    # dot_ms_r: kg/m^3/s\n    # dot_rho_s: kg/m^3/s\n    test_cases = [\n        # Case A\n        (0.25, 2700.0, 1000.0, 2e-6, 1e-3, 0.0),\n        # Case B\n        (0.01, 2650.0, 1000.0, 1e-5, -1e-3, 1e-3),\n        # Case C\n        (0.99, 2700.0, 1000.0, 5e-5, 2e-4, 0.0),\n        # Case D\n        (0.40, 2700.0, 1000.0, -3e-6, 0.0, 9e-4),\n        # Case E\n        (0.60, 2200.0, 1020.0, 1e-4, 5e-3, -2e-3),\n    ]\n\n    # Prescribed tolerance for equality check\n    tolerance = 1e-12\n\n    results = []\n    for case in test_cases:\n        phi, rho_s, rho_f, dot_eps_vp, dot_ms_r, dot_rho_s = case\n\n        # Task 1: Calculate the rate of change of porosity, dot_phi\n        dot_phi = (1.0 - phi) * dot_eps_vp + dot_ms_r / rho_s\n\n        # Task 2: Calculate the rate of change of bulk density, dot_rho, using two decompositions.\n        # The assumption dot_rho_f = 0 is used.\n        \n        # Decomposition 1: Term-by-term product rule\n        # dot_rho = d/dt[(1-phi)*rho_s] + d/dt[phi*rho_f]\n        #         = [-dot_phi*rho_s + (1-phi)*dot_rho_s] + [dot_phi*rho_f + phi*dot_rho_f]\n        dot_rho_d1 = -dot_phi * rho_s + (1.0 - phi) * dot_rho_s + dot_phi * rho_f\n\n        # Decomposition 2: Multivariate chain rule\n        # dot_rho = (d_rho/d_phi)*dot_phi + (d_rho/d_rho_s)*dot_rho_s + (d_rho/d_rho_f)*dot_rho_f\n        #         = (rho_f - rho_s)*dot_phi + (1-phi)*dot_rho_s\n        dot_rho_d2 = (rho_f - rho_s) * dot_phi + (1.0 - phi) * dot_rho_s\n        \n        # Task 3: Compare the results of the two decompositions\n        # The two forms are algebraically identical, so any difference is due to\n        # floating point arithmetic. A tolerance check is appropriate.\n        is_equal = np.abs(dot_rho_d1 - dot_rho_d2) = tolerance\n        results.append(is_equal)\n\n    # Final print statement in the exact required format.\n    # np.bool_ is converted to Python's native bool for standard string representation.\n    print(f\"[{','.join(map(lambda x: str(bool(x)), results))}]\")\n\nsolve()\n```", "id": "3507660"}, {"introduction": "将守恒定律应用于实际问题的最后一步是其数值实现。本练习聚焦于质量守恒方程的核心——散度算子 $\\nabla \\cdot$ 的离散化。[@problem_id:3507675] 你将通过一个精确的“人造解”，在一个模拟岩土变形的非正交网格上，对比有限体积法（FVM）和混合有限元法（MFE）这两种常用数值方法的表现。通过这个过程，你将量化“局部守恒误差”的概念，并深刻理解为何离散格式的选择对模拟的精度和物理保真度至关重要。", "problem": "您的任务是，从连续介质力学的基本原理出发，实现一个数值实验，以比较在计算地质力学中用于可变形多孔骨架中稳态渗流的两种局部散度算子离散化方法。从流体饱和变形多孔介质中的局部流体质量守恒开始，代表性单元体积 (REV) 上的液相质量平衡可表示为 $$\\frac{\\partial (n \\rho)}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{w}) = \\rho q_m,$$ 其中，$n$ 是孔隙度，$\\rho$ 是流体密度，$\\mathbf{w}$ 是达西速度，$q_m$ 是单位体积的体积质量源。在不可压缩流体（$\\rho$ 恒定）、稳态条件以及每个控制体积内孔隙度不随时间变化的假设下，该方程简化为局部体积守恒表达式 $$\\nabla \\cdot \\mathbf{w} = q,$$ 其中，$q$ 是单位体积的体积源项。物理单位为：$\\mathbf{w}$ 的单位是米/秒 ($\\mathrm{m/s}$)，$\\nabla \\cdot \\mathbf{w}$ 的单位是秒的倒数 ($\\mathrm{s}^{-1}$)，$q$ 的单位是秒的倒数 ($\\mathrm{s}^{-1}$)。本数值实验将逐单元地量化在由运动学可变形骨架映射引起的网格各向异性下，$\\nabla \\cdot \\mathbf{w} = q$ 的局部守恒误差。\n\n您将使用一个制造解，该解给出的达西速度场 $\\mathbf{w}(x,y)$ 和体积源 $q(x,y)$ 在连续介质设定下精确满足 $\\nabla \\cdot \\mathbf{w} = q$。该制造速度场由多项式分量定义\n$$w_x(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,$$\n$$w_y(x,y) = g x^2 + h x y + i y^2 + j x + k y + \\ell,$$\n其常数系数的选择应使其对于渗流速度具有物理上的合理性。具体来说，使用以下常数（其量级与国际单位制 (SI) 一致）：\n$$a = 10^{-8},\\quad b = 2\\cdot 10^{-8},\\quad c = 0,\\quad d = 10^{-7},\\quad e = 0,\\quad f = 0,$$\n$$g = 0,\\quad h = -10^{-8},\\quad i = -1.5\\cdot 10^{-8},\\quad j = 0,\\quad k = -5\\cdot 10^{-8},\\quad \\ell = 10^{-7}.$$\n由此可得精确的源项\n$$q(x,y) = \\frac{\\partial w_x}{\\partial x} + \\frac{\\partial w_y}{\\partial y} = \\alpha x + \\beta y + \\gamma,$$\n其系数为\n$$\\alpha = 10^{-8},\\quad \\beta = -10^{-8},\\quad \\gamma = 5\\cdot 10^{-8}.$$\n\n计算域是一个尺寸为 $[0,L_x]\\times[0,L_y]$ 米的矩形，被离散化为一个结构化网格，其在 $x$ 方向有 $N_x$ 个单元，在 $y$ 方向有 $N_y$ 个单元。为了模拟可变形骨架并引入网格的各向异性和非正交性，对网格节点应用以下运动学仿射映射：\n$$X' = s_x X + k_{\\text{sh}} Y,\\qquad Y' = s_y Y,$$\n其中 $(X,Y)$ 是原始坐标，$(X',Y')$ 是变形后的坐标，$s_x$ 和 $s_y$ 是沿各轴的拉伸因子，$k_{\\text{sh}}$ 是一个剪切因子。变形后的网格单元是凸四边形。\n\n对于变形网格中的每个单元，计算面积平均散度 $\\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}$ 的两种离散近似，并量化相对于精确源项的单元平均值 $\\langle q \\rangle_{\\Omega_c}$ 的局部守恒误差：\n\n1. 有限体积法 (FVM) 中点通量散度。对于一个面积为 $A_c$，边为 $e$，边的外向单位法向量为 $\\mathbf{n}_e$，长度为 $L_e$ 的单元，通过在边的中点 $(x_m,y_m)$ 处计算 $\\mathbf{w}$ 来近似穿过每条边的通量：\n$$\\Phi_e^{\\mathrm{FVM}} \\approx \\left(\\mathbf{w}(x_m,y_m)\\cdot \\mathbf{n}_e\\right) L_e.$$\n那么，离散的面积平均散度为\n$$\\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{FVM}} = \\frac{1}{A_c} \\sum_{e\\in \\partial \\Omega_c} \\Phi_e^{\\mathrm{FVM}}.$$\n\n2. 类混合有限元 (MFE) 的高斯通量散度。通过使用三点高斯-勒让德求积方法沿每条直边 $e$ 积分法向通量，来模拟最低阶 Raviart–Thomas (RT0) 单元的局部法向通量处理方式。该求积方法对于边上最高五次的多项式被积函数是精确的。设边上的参数坐标为 $t\\in[0,1]$，求积点为 $t_i$，权重为 $w_i$，计算\n$$\\Phi_e^{\\mathrm{MFE}} \\approx L_e \\sum_{i=1}^{3} w_i \\left(\\mathbf{w}(x(t_i),y(t_i))\\cdot \\mathbf{n}_e\\right),$$\n以及离散的面积平均散度\n$$\\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{MFE}} = \\frac{1}{A_c} \\sum_{e\\in \\partial \\Omega_c} \\Phi_e^{\\mathrm{MFE}}.$$\n\n对于源项的精确单元平均值，使用线性函数在多边形上的恒等式：设多边形面积为 $A_c$，其面积质心为 $(\\bar{x}_c,\\bar{y}_c)$，则精确的单元平均值为\n$$\\langle q \\rangle_{\\Omega_c} = \\frac{1}{A_c}\\int_{\\Omega_c} q(x,y)\\, \\mathrm{d}A = \\alpha \\bar{x}_c + \\beta \\bar{y}_c + \\gamma.$$\n\n将每个单元的局部守恒误差（单位为 $\\mathrm{s}^{-1}$）定义为\n$$\\varepsilon_c^{\\mathrm{FVM}} = \\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{FVM}} - \\langle q \\rangle_{\\Omega_c},\\qquad \\varepsilon_c^{\\mathrm{MFE}} = \\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{MFE}} - \\langle q \\rangle_{\\Omega_c}.$$\n\n您的程序必须：\n- 根据给定参数构建变形后的网格。\n- 对每个单元，计算其面积 $A_c$、边长 $L_e$、外向法向量 $\\mathbf{n}_e$（与逆时针顶点顺序一致）以及质心 $(\\bar{x}_c,\\bar{y}_c)$。\n- 为所有单元计算 $\\varepsilon_c^{\\mathrm{FVM}}$ 和 $\\varepsilon_c^{\\mathrm{MFE}}$。\n- 在每个测试案例中，对每种方法，汇总所有单元中的最大绝对局部守恒误差：\n$$E_{\\max}^{\\mathrm{FVM}} = \\max_c |\\varepsilon_c^{\\mathrm{FVM}}|,\\qquad E_{\\max}^{\\mathrm{MFE}} = \\max_c |\\varepsilon_c^{\\mathrm{MFE}}|.$$\n\n测试套件：\n- 案例1（理想路径各向异性）：$L_x = 10$ $\\mathrm{m}$，$L_y = 6$ $\\mathrm{m}$，$N_x = 12$，$N_y = 8$，$s_x = 1.0$，$s_y = 3.0$，$k_{\\text{sh}} = 0.0$。\n- 案例2（高各向异性拉伸）：$L_x = 20$ $\\mathrm{m}$，$L_y = 5$ $\\mathrm{m}$，$N_x = 20$，$N_y = 6$，$s_x = 0.5$，$s_y = 10.0$，$k_{\\text{sh}} = 0.0$。\n- 案例3（非正交剪切，粗网格边缘情况）：$L_x = 5$ $\\mathrm{m}$，$L_y = 5$ $\\mathrm{m}$，$N_x = 2$，$N_y = 2$，$s_x = 1.0$，$s_y = 1.0$，$k_{\\text{sh}} = 0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_{\\max}^{\\mathrm{FVM}}(\\text{案例 1}),E_{\\max}^{\\mathrm{MFE}}(\\text{案例 1}),E_{\\max}^{\\mathrm{FVM}}(\\text{案例 2}),E_{\\max}^{\\mathrm{MFE}}(\\text{案例 2}),E_{\\max}^{\\mathrm{FVM}}(\\text{案例 3}),E_{\\max}^{\\mathrm{MFE}}(\\text{案例 3})]$。每个值都必须是浮点数，单位为秒的倒数 ($\\mathrm{s}^{-1}$)。输出中不允许包含任何其他文本。", "solution": "该问题陈述是计算连续介质力学中一个有效且定义良好的练习。它要求实现并比较两种用于散度算子的数值方案，这是模拟守恒律的基石。该方法论基于有限体积法 (FVM) 的既定原理以及一种受混合有限元 (MFE) 方法启发的通量评估方案。使用制造解为量化离散误差提供了一个清晰客观的基准。\n\n解决方案按以下步骤进行：首先，我们建立数学和物理框架。其次，我们详细说明通用四边形网格所需的几何计算。第三，我们形式化地描述两种离散化方案的算法实现。最后，我们概述误差的量化方法。\n\n在指定的稳态、不可压缩流体在多孔介质中流动的假设下，控制方程是代表局部质量守恒的连续性方程：\n$$\n\\nabla \\cdot \\mathbf{w} = q\n$$\n此处，$\\mathbf{w}$ 是达西速度场，单位为 $\\mathrm{m/s}$；$q$ 是体积源项，单位为 $\\mathrm{s}^{-1}$。我们给定了一个用于速度场 $\\mathbf{w}(x,y)$ 的制造解，它是一个二次多项式，其分量 $w_x(x,y)$ 和 $w_y(x,y)$ 为：\n$$\nw_x(x,y) = a x^2 + b x y + c y^2 + d x + e y + f\n$$\n$$\nw_y(x,y) = g x^2 + h x y + i y^2 + j x + k y + \\ell\n$$\n常数 $a, b, \\dots, \\ell$ 已给出。通过直接求导，该场的散度可得出精确的源项 $q(x,y) = \\frac{\\partial w_x}{\\partial x} + \\frac{\\partial w_y}{\\partial y}$，这是一个关于 $x$ 和 $y$ 的线性函数：\n$$\nq(x,y) = (2a+h)x + (b+2i)y + (d+k) = \\alpha x + \\beta y + \\gamma\n$$\n问题给出了系数 $\\alpha$、$\\beta$ 和 $\\gamma$ 的值，这些值与给定的 $\\mathbf{w}$ 的系数是一致的。\n\n问题的核心是评估一个面积为 $A_c$ 的四边形单元 $\\Omega_c$ 上的面积平均散度。散度定理指出，散度在单元面积上的积分等于穿过其边界 $\\partial\\Omega_c$ 的净通量：\n$$\n\\int_{\\Omega_c} \\nabla \\cdot \\mathbf{w} \\, \\mathrm{d}A = \\oint_{\\partial\\Omega_c} \\mathbf{w} \\cdot \\mathbf{n} \\, \\mathrm{d}s\n$$\n其中 $\\mathbf{n}$ 是边界的外向单位法向量。因此，面积平均散度为：\n$$\n\\langle \\nabla \\cdot \\mathbf{w} \\rangle_{\\Omega_c} = \\frac{1}{A_c} \\oint_{\\partial\\Omega_c} \\mathbf{w} \\cdot \\mathbf{n} \\, \\mathrm{d}s = \\frac{1}{A_c} \\sum_{e \\in \\partial\\Omega_c} \\int_{e} \\mathbf{w} \\cdot \\mathbf{n}_e \\, \\mathrm{d}s\n$$\nFVM 和 MFE 这两种方法是对边界积分 $\\oint \\mathbf{w} \\cdot \\mathbf{n} \\, \\mathrm{d}s$ 的不同数值近似。\n\n首先在域 $[0, L_x]\\times[0, L_y]$ 中生成一个 $N_x \\times N_y$ 的矩形单元结构化网格。然后对节点坐标 $(X,Y)$ 进行仿射映射，得到变形后的坐标 $(X',Y')$，以模拟运动学上变形的多孔骨架：\n$$\nX' = s_x X + k_{\\text{sh}} Y, \\qquad Y' = s_y Y\n$$\n这将生成一个由通用凸四边形组成的网格。对于每个由其四个顶点 $V_0, V_1, V_2, V_3$ 按逆时针 (CCW) 顺序定义的四边形单元 $\\Omega_c$，我们必须计算其几何属性。该单元被分解为两个三角形，例如 $T_1 = (V_0, V_1, V_2)$ 和 $T_2 = (V_0, V_2, V_3)$。一个由顶点 $P_a, P_b, P_c$ 构成的三角形的面积是两条边向量叉积大小的一半，例如 $A_{triangle} = \\frac{1}{2} | (P_b - P_a) \\times (P_c - P_a) |$。总单元面积为 $A_c = A_{T_1} + A_{T_2}$。三角形的质心是其顶点的平均值。四边形的质心 $(\\bar{x}_c, \\bar{y}_c)$ 是 $T_1$ 和 $T_2$ 质心的面积加权平均值。\n\n在确定几何形状后，我们计算两种散度近似值：\n\n1.  **有限体积法 (FVM) 散度**：该方法使用中点法则来近似每条边 $e$ （从顶点 $V_a$到 $V_b$）上的通量积分。通量在边的中点 $(x_m, y_m) = (V_a+V_b)/2$ 处被计算，并乘以边长 $L_e$。\n    $$\n    \\Phi_e^{\\mathrm{FVM}} \\approx (\\mathbf{w}(x_m,y_m)\\cdot \\mathbf{n}_e) L_e = \\mathbf{w}(x_m,y_m) \\cdot \\vec{n}_e\n    $$\n    其中 $\\vec{n}_e = L_e \\mathbf{n}_e$ 是未缩放的法向量，对于一个逆时针排序的单元，其计算方式为 $(V_{b,y} - V_{a,y}, V_{a,x} - V_{b,x})$。总通量是四条边上的通量之和，散度为 $\\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{FVM}} = \\frac{1}{A_c} \\sum_{e} \\Phi_e^{\\mathrm{FVM}}$。该方法对于光滑函数在规则网格上通常具有二阶精度，但在扭曲或各向异性的网格上其精度会下降。\n\n2.  **类混合有限元 (MFE) 散度**：该方法使用更高阶的求积法则来近似每条边上的通量积分，模拟了 RT0 单元的局部通量守恒特性。对于由 $t \\in [0,1]$ 参数化的边，通量积分为 $\\int_e \\mathbf{w} \\cdot \\mathbf{n}_e \\, \\mathrm{d}s = \\int_{0}^{1} (\\mathbf{w}(P(t)) \\cdot \\vec{n}_e) \\, \\mathrm{d}t$。我们使用一个三点高斯-勒让德求积来近似该积分，该方法对于最高次数为 $2 \\times 3 - 1 = 5$ 的多项式被积函数是精确的。\n    $$\n    \\Phi_e^{\\mathrm{MFE}} = \\int_{e} \\mathbf{w} \\cdot \\mathbf{n}_e \\, \\mathrm{d}s \\approx \\sum_{i=1}^{3} w_i (\\mathbf{w}(P(t_i)) \\cdot \\vec{n}_e)\n    $$\n    其中 $t_i$ 和 $w_i$ 是区间 $[0,1]$ 上的高斯点和权重。由于速度场 $\\mathbf{w}$ 是二次的，而边的参数化 $P(t)$ 是线性的，因此被积函数 $\\mathbf{w}(P(t)) \\cdot \\vec{n}_e$ 是一个关于 $t$ 的二次多项式。三点高斯求积将能精确地对其进行积分。因此，$\\Phi_e^{\\mathrm{MFE}}$ 不是一个近似值，而是边通量的精确计算值。散度为 $\\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{MFE}} = \\frac{1}{A_c} \\sum_{e} \\Phi_e^{\\mathrm{MFE}}$。\n\n用于比较的基准是精确的单元平均源项 $\\langle q \\rangle_{\\Omega_c}$。对于一个线性函数 $q(x,y) = \\alpha x + \\beta y + \\gamma$，其在多边形 $\\Omega_c$ 上的积分恰好是 $q(\\bar{x}_c, \\bar{y}_c) A_c$。因此：\n$$\n\\langle q \\rangle_{\\Omega_c} = \\frac{1}{A_c} \\int_{\\Omega_c} q(x,y) \\, \\mathrm{d}A = \\alpha \\bar{x}_c + \\beta \\bar{y}_c + \\gamma\n$$\n每种方法的局部守恒误差是计算出的散度与此精确值之间的差值：\n$$\n\\varepsilon_c^{\\mathrm{FVM}} = \\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{FVM}} - \\langle q \\rangle_{\\Omega_c}\n$$\n$$\n\\varepsilon_c^{\\mathrm{MFE}} = \\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{MFE}} - \\langle q \\rangle_{\\Omega_c}\n$$\n由于类 MFE 的通量积分是精确的，根据散度定理，$\\sum_e \\Phi_e^{\\mathrm{MFE}} = \\int_{\\Omega_c} \\nabla\\cdot\\mathbf{w} \\, \\mathrm{d}A = \\int_{\\Omega_c} q \\, \\mathrm{d}A$。因此，$\\langle \\nabla\\cdot \\mathbf{w} \\rangle_{\\Omega_c}^{\\mathrm{MFE}}$ 将精确等于 $\\langle q \\rangle_{\\Omega_c}$。因此，误差 $\\varepsilon_c^{\\mathrm{MFE}}$ 预计在机器浮点精度范围内为零。这为几何和数值实现的正确性提供了一个鲁棒的内部验证。FVM 的误差 $\\varepsilon_c^{\\mathrm{FVM}}$ 将不为零，其大小，聚合为 $E_{\\max}^{\\mathrm{FVM}} = \\max_c |\\varepsilon_c^{\\mathrm{FVM}}|$，将量化该方法在网格变形下的局部守恒误差。\n\n程序将被构建为对每个测试案例执行这些计算，计算并存储每个案例的最大绝对误差 $E_{\\max}^{\\mathrm{FVM}}$ 和 $E_{\\max}^{\\mathrm{MFE}}$，并以指定格式呈现它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Problem Constants ---\n# Velocity field coefficients (w_x = a*x^2 + b*x*y + ... , w_y = g*x^2 + h*x*y + ...)\nVEL_COEFFS = {\n    'a': 1e-8, 'b': 2e-8, 'c': 0.0, 'd': 1e-7, 'e': 0.0, 'f': 0.0,\n    'g': 0.0, 'h': -1e-8, 'i': -1.5e-8, 'j': 0.0, 'k': -5e-8, 'l': 1e-7,\n}\n\n# Source term coefficients (q = alpha*x + beta*y + gamma)\nSRC_COEFFS = {\n    'alpha': 1e-8,  # 2*a + h\n    'beta': -1e-8,  # b + 2*i\n    'gamma': 5e-8,  # d + k\n}\n\n# 3-point Gauss-Legendre quadrature for interval [0, 1]\n_p = np.sqrt(3.0 / 5.0)\nGL_POINTS = np.array([(1.0 - _p) / 2.0, 0.5, (1.0 + _p) / 2.0])\nGL_WEIGHTS = np.array([5.0 / 18.0, 8.0 / 18.0, 5.0 / 18.0])\n\ndef w_field(x, y):\n    \"\"\"Computes the manufactured velocity vector (wx, wy) at point (x, y).\"\"\"\n    C = VEL_COEFFS\n    wx = C['a']*x**2 + C['b']*x*y + C['c']*y**2 + C['d']*x + C['e']*y + C['f']\n    wy = C['g']*x**2 + C['h']*x*y + C['i']*y**2 + C['j']*x + C['k']*y + C['l']\n    return np.array([wx, wy])\n\ndef get_quad_geometry(v0, v1, v2, v3):\n    \"\"\"\n    Computes area and centroid of a convex quadrilateral.\n    Vertices v0, v1, v2, v3 must be in counter-clockwise order.\n    \"\"\"\n    # Decompose into two triangles: (v0, v1, v2) and (v0, v2, v3)\n    # Area of T1 = 0.5 * |(v1-v0) x (v2-v0)|\n    area1 = 0.5 * np.abs(np.cross(v1 - v0, v2 - v0))\n    # Area of T2 = 0.5 * |(v2-v0) x (v3-v0)|\n    area2 = 0.5 * np.abs(np.cross(v2 - v0, v3 - v0))\n    \n    total_area = area1 + area2\n\n    if total_area  1e-15: # Avoid division by zero for degenerate quads\n        return 0, v0\n\n    # Centroid of T1 is the average of its vertices\n    centroid1 = (v0 + v1 + v2) / 3.0\n    # Centroid of T2\n    centroid2 = (v0 + v2 + v3) / 3.0\n\n    # Centroid of quad is the area-weighted average of triangle centroids\n    quad_centroid = (centroid1 * area1 + centroid2 * area2) / total_area\n    \n    return total_area, quad_centroid\n\ndef run_case(Lx, Ly, Nx, Ny, sx, sy, k_sh):\n    \"\"\"\n    Runs a single numerical experiment case.\n    \"\"\"\n    # 1. Generate the deformed mesh\n    x_nodes = np.linspace(0, Lx, Nx + 1)\n    y_nodes = np.linspace(0, Ly, Ny + 1)\n    XX_orig, YY_orig = np.meshgrid(x_nodes, y_nodes)\n\n    XX_deformed = sx * XX_orig + k_sh * YY_orig\n    YY_deformed = sy * YY_orig\n\n    errors_fvm = []\n    errors_mfe = []\n\n    # 2. Loop over each cell in the mesh\n    for j in range(Ny):\n        for i in range(Nx):\n            # Get cell vertices in CCW order\n            v0 = np.array([XX_deformed[j, i], YY_deformed[j, i]])\n            v1 = np.array([XX_deformed[j, i+1], YY_deformed[j, i+1]])\n            v2 = np.array([XX_deformed[j+1, i+1], YY_deformed[j+1, i+1]])\n            v3 = np.array([XX_deformed[j+1, i], YY_deformed[j+1, i]])\n            \n            # 3. Compute cell geometric properties\n            area, centroid = get_quad_geometry(v0, v1, v2, v3)\n            \n            # 4. Compute exact cell-averaged source term\n            q_avg_exact = (SRC_COEFFS['alpha'] * centroid[0] +\n                           SRC_COEFFS['beta'] * centroid[1] +\n                           SRC_COEFFS['gamma'])\n\n            vertices = [v0, v1, v2, v3]\n            total_flux_fvm = 0.0\n            total_flux_mfe = 0.0\n\n            # 5. Loop over the 4 edges of the cell\n            for k in range(4):\n                p_start = vertices[k]\n                p_end = vertices[(k + 1) % 4]\n                \n                # Outward-pointing unscaled normal vector (from CCW vertices)\n                normal_vec = np.array([p_end[1] - p_start[1], p_start[0] - p_end[0]])\n\n                # --- FVM Flux (Midpoint Rule) ---\n                midpoint = (p_start + p_end) / 2.0\n                w_mid = w_field(midpoint[0], midpoint[1])\n                flux_fvm = np.dot(w_mid, normal_vec)\n                total_flux_fvm += flux_fvm\n\n                # --- MFE Flux (3-point Gauss-Legendre) ---\n                edge_vec = p_end - p_start\n                flux_mfe = 0.0\n                for pt_idx in range(len(GL_POINTS)):\n                    t = GL_POINTS[pt_idx]\n                    weight = GL_WEIGHTS[pt_idx]\n                    gauss_pt = p_start + t * edge_vec\n                    w_gauss = w_field(gauss_pt[0], gauss_pt[1])\n                    flux_mfe += weight * np.dot(w_gauss, normal_vec)\n                total_flux_mfe += flux_mfe\n\n            # 6. Compute area-averaged divergences\n            div_fvm = total_flux_fvm / area\n            div_mfe = total_flux_mfe / area\n            \n            # 7. Compute and store local conservation errors\n            errors_fvm.append(div_fvm - q_avg_exact)\n            errors_mfe.append(div_mfe - q_avg_exact)\n\n    # 8. Find the maximum absolute error over all cells\n    E_max_fvm = np.max(np.abs(errors_fvm))\n    E_max_mfe = np.max(np.abs(errors_mfe))\n\n    return E_max_fvm, E_max_mfe\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (Lx, Ly, Nx, Ny, sx, sy, k_sh)\n        (10.0, 6.0, 12, 8, 1.0, 3.0, 0.0),      # Case 1\n        (20.0, 5.0, 20, 6, 0.5, 10.0, 0.0),     # Case 2\n        (5.0, 5.0, 2, 2, 1.0, 1.0, 0.5),        # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        E_max_fvm, E_max_mfe = run_case(*case)\n        results.extend([E_max_fvm, E_max_mfe])\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3507675"}]}