{"hands_on_practices": [{"introduction": "形函数梯度，通常在有限元法中表示为 $\\mathbf{B}$ 矩阵，是连接节点位移和单元应变场的关键环节。本练习 ([@problem_id:3561763]) 将指导你从基本原理出发，为简单的线性三角形单元推导并计算这些梯度。通过这个实践，你将牢固掌握单元几何形状如何决定其内部的应变分布，为后续更复杂的有限元计算打下坚实的基础。", "problem": "在对土体进行的二维平面应变分析中，考虑一个在物理坐标系下的线性三节点三角形有限元，其节点位置为 $P_1=(x_1,y_1)=(0,0)$，$P_2=(x_2,y_2)=(3,1)$ 和 $P_3=(x_3,y_3)=(1,4)$。对于 $i\\in\\{1,2,3\\}$，线性形函数 $N_i(x,y)$ 是与该三角形关联的重心坐标，因此它们是满足克罗内克-德尔塔性质 $N_i(P_j)=\\delta_{ij}$ 和单位分解性 $\\sum_{i=1}^{3}N_i(x,y)=1$ 的仿射函数，此性质对单元内所有点 $(x,y)$ 均成立。\n\n请仅从线性三角形形函数的定义性质和三角形有向面积的几何定义出发，推导常梯度 $\\nabla N_i$ 关于节点坐标和三角形有向面积 $A$ 的通用表达式。然后，对于上述定义的三角形，计算其在物理 $(x,y)$ 坐标系下梯度 $\\nabla N_1$、$\\nabla N_2$ 和 $\\nabla N_3$ 的数值。\n\n将最终答案表示为一个单行矩阵，其中分量按顺序 $\\left[\\frac{\\partial N_1}{\\partial x},\\frac{\\partial N_1}{\\partial y},\\frac{\\partial N_2}{\\partial x},\\frac{\\partial N_2}{\\partial y},\\frac{\\partial N_3}{\\partial x},\\frac{\\partial N_3}{\\partial y}\\right]$ 排列。请使用精确值（不要进行四舍五入）。", "solution": "### 第1步：推导梯度的通用表达式\n\n三节点三角形的线性形函数 $N_i(x,y)$ 是空间坐标 $(x,y)$ 的一个仿射函数，可以写成：\n$$\nN_i(x,y) = c_{i,1} + c_{i,2}x + c_{i,3}y\n$$\n该函数的梯度在整个单元上是恒定的：\n$$\n\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} c_{i,2} \\\\ c_{i,3} \\end{pmatrix}\n$$\n问题指出形函数是重心坐标。点 $P(x,y)$ 相对于节点 $P_1$ 的重心坐标 $N_1(x,y)$ 定义为由点 $P$、$P_2$ 和 $P_3$ 组成的子三角形的面积与主三角形 $P_1P_2P_3$ 总面积之比。设 $A$ 为三角形 $P_1P_2P_3$ 的有向面积，$A_1$ 为三角形 $PP_2P_3$ 的有向面积。那么，$N_1(x,y) = A_1/A$。\n\n一个顶点按逆时针顺序排列为 $(x_a, y_a)$、$(x_b, y_b)$ 和 $(x_c, y_c)$ 的三角形，其有向面积由行列式公式给出：\n$$\n\\text{Area} = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x_a & y_a \\\\ 1 & x_b & y_b \\\\ 1 & x_c & y_c \\end{pmatrix}\n$$\n单元的总有向面积为：\n$$\nA = \\frac{1}{2} [x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)]\n$$\n子三角形 $PP_2P_3$ 的面积 $A_1$ 为：\n$$\nA_1 = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x & y \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix} = \\frac{1}{2} [x(y_2 - y_3) + x_2(y_3 - y) + x_3(y - y_2)]\n$$\n我们可以重新排列 $A_1$ 表达式中的项，以突出其对 $x$ 和 $y$ 的依赖性：\n$$\nA_1 = \\frac{1}{2} [x(y_2 - y_3) + y(x_3 - x_2) + (x_2y_3 - x_3y_2)]\n$$\n现在我们可以写出形函数 $N_1(x,y)$ 的表达式：\n$$\nN_1(x,y) = \\frac{A_1}{A} = \\frac{1}{2A} [x(y_2 - y_3) + y(x_3 - x_2) + (x_2y_3 - x_3y_2)]\n$$\n这是一个关于 $x$ 和 $y$ 的仿射函数。梯度 $\\nabla N_1$ 的分量是 $x$ 和 $y$ 的系数：\n$$\n\\frac{\\partial N_1}{\\partial x} = \\frac{y_2 - y_3}{2A} \\quad \\text{和} \\quad \\frac{\\partial N_1}{\\partial y} = \\frac{x_3 - x_2}{2A}\n$$\n因此，第一个形函数的梯度是：\n$$\n\\nabla N_1 = \\frac{1}{2A} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}\n$$\n$\\nabla N_2$ 和 $\\nabla N_3$ 的表达式可以通过对下标 $(1, 2, 3)$ 进行轮换置换得到。对于 $N_2$，我们应用置换 $(1 \\to 2, 2 \\to 3, 3 \\to 1)$：\n$$\n\\nabla N_2 = \\frac{1}{2A} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}\n$$\n对于 $N_3$，我们再次应用置换 $(2 \\to 3, 3 \\to 1, 1 \\to 2)$：\n$$\n\\nabla N_3 = \\frac{1}{2A} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}\n$$\n这些就是线性三角形形函数梯度的通用表达式。\n\n### 第2步：数值计算\n\n给定的节点坐标为 $P_1=(x_1,y_1)=(0,0)$，$P_2=(x_2,y_2)=(3,1)$ 和 $P_3=(x_3,y_3)=(1,4)$。\n\n首先，我们计算 $2A$ 的值：\n$$\n2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)\n$$\n$$\n2A = 0(1 - 4) + 3(4 - 0) + 1(0 - 1) = 0 + 12 - 1 = 11\n$$\n面积 $A = \\frac{11}{2}$ 是正数，表示顶点是按逆时针顺序排列的。\n\n现在我们可以计算每个梯度的分量：\n\n对于 $\\nabla N_1$：\n$$\n\\frac{\\partial N_1}{\\partial x} = \\frac{y_2 - y_3}{2A} = \\frac{1 - 4}{11} = -\\frac{3}{11}\n$$\n$$\n\\frac{\\partial N_1}{\\partial y} = \\frac{x_3 - x_2}{2A} = \\frac{1 - 3}{11} = -\\frac{2}{11}\n$$\n\n对于 $\\nabla N_2$：\n$$\n\\frac{\\partial N_2}{\\partial x} = \\frac{y_3 - y_1}{2A} = \\frac{4 - 0}{11} = \\frac{4}{11}\n$$\n$$\n\\frac{\\partial N_2}{\\partial y} = \\frac{x_1 - x_3}{2A} = \\frac{0 - 1}{11} = -\\frac{1}{11}\n$$\n\n对于 $\\nabla N_3$：\n$$\n\\frac{\\partial N_3}{\\partial x} = \\frac{y_1 - y_2}{2A} = \\frac{0 - 1}{11} = -\\frac{1}{11}\n$$\n$$\n\\frac{\\partial N_3}{\\partial y} = \\frac{x_2 - x_1}{2A} = \\frac{3 - 0}{11} = \\frac{3}{11}\n$$\n\n作为检验，单位分解性 $\\sum_{i=1}^3 N_i = 1$ 意味着梯度之和必须为零：$\\sum_{i=1}^3 \\nabla N_i = \\mathbf{0}$。\nx分量之和： $\\frac{\\partial N_1}{\\partial x} + \\frac{\\partial N_2}{\\partial x} + \\frac{\\partial N_3}{\\partial x} = -\\frac{3}{11} + \\frac{4}{11} - \\frac{1}{11} = \\frac{-3+4-1}{11} = 0$。\ny分量之和： $\\frac{\\partial N_1}{\\partial y} + \\frac{\\partial N_2}{\\partial y} + \\frac{\\partial N_3}{\\partial y} = -\\frac{2}{11} - \\frac{1}{11} + \\frac{3}{11} = \\frac{-2-1+3}{11} = 0$。\n计算结果是一致的。\n\n最终答案是这六个分量组成的行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} -\\frac{3}{11} & -\\frac{2}{11} & \\frac{4}{11} & -\\frac{1}{11} & -\\frac{1}{11} & \\frac{3}{11} \\end{pmatrix}\n}\n$$", "id": "3561763"}, {"introduction": "在掌握了形函数的基本概念后，本练习将探讨如何利用它们通过积分来构建完整的单元级矩阵，这是有限元分析的一项核心任务。我们将聚焦于动力学分析中的质量矩阵，通过积分推导四节点四边形（Q4）单元的“一致质量矩阵”，并将其与计算上更高效的“集中质量矩阵”进行比较。此实践旨在阐明不同矩阵形式之间的权衡与联系 ([@problem_id:3561753])。", "problem": "考虑均质土层在平面运动学下的小应变、单相动量平衡。将注意力限制在单个位移分量上，使得惯性项仅涉及一个标量场。从平衡律的弱形式出发，使用有限元法（FEM）和四节点双线性四边形（Q4）单元，推导单元级的协调质量算子。设物理单元为一个矩形，其在 $x$ 和 $y$ 方向上的边长分别为 $a$ 和 $b$，具有恒定的厚度 $t$ 和均匀的质量密度 $\\rho$。使用从母域 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 出发的标准等参映射，由 $x(\\xi)=x_{c}+\\frac{a}{2}\\,\\xi$ 和 $y(\\eta)=y_{c}+\\frac{b}{2}\\,\\eta$ 给出，以及标准的Q4形函数\n$$\nN_{1}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n任务：\n- 从线动量的弱形式出发，推导该Q4单元的协调单元质量矩阵 $M_{e}$。\n- 对于均匀的 $\\rho$ 和 $t$，显式计算 $M_{e}$ 的各项，并用 $a$ 和 $b$ 表示。\n- 使用行和技术构建集中质量矩阵，并证明其等价于在具有均匀 $\\rho$ 和 $t$ 的Q4单元上通过节点求积得到的集中质量。\n- 定义无量纲归一化协调质量矩阵 $\\widehat{M}_{e}:=\\frac{4}{\\rho\\,t\\,a\\,b}\\,M_{e}$，使得通过行和法得到的相应集中质量为单位矩阵 $I_{4}$。计算 $\\widehat{M}_{e}$ 与 $I_{4}$ 之间偏差的单一标量度量，即 Frobenius 范数\n$$\n\\|\\widehat{M}_{e}-I_{4}\\|_{F}=\\left(\\sum_{i=1}^{4}\\sum_{j=1}^{4}(\\widehat{M}_{e,ij}-\\delta_{ij})^{2}\\right)^{1/2},\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。\n将最终的标量偏差表示为一个精确的无量纲数。不需要单位。不要四舍五入；提供一个精确的封闭形式表达式。", "solution": "### 第一步：协调单元质量矩阵（$M_e$）的推导\n\n仅考虑标量位移场 $u$ 的惯性项时，动量平衡的弱形式由下式给出：\n$$ \\int_{\\Omega} w \\, \\rho \\, \\ddot{u} \\, dV $$\n其中 $w$ 是检验函数，$\\rho$ 是质量密度，$\\ddot{u}$ 是加速度场，积分在域体积 $\\Omega$ 上进行。\n\n在有限元法（FEM）中，单元内的位移场 $u$ 和检验函数 $w$ 使用形函数 $N_i$ 从其节点值插值得到：\n$$ u(\\mathbf{x}, t) = \\sum_{i=1}^{4} N_i(\\mathbf{x}) u_i(t) = \\mathbf{N}(\\mathbf{x}) \\mathbf{u}_e(t) $$\n$$ w(\\mathbf{x}) = \\sum_{j=1}^{4} N_j(\\mathbf{x}) w_j = \\mathbf{N}(\\mathbf{x}) \\mathbf{w}_e $$\n将这些代入单个单元域 $\\Omega_e$ 的弱形式中，我们得到单元协调质量矩阵 $\\mathbf{M}_e$ 的定义：\n$$ \\mathbf{M}_e = \\int_{\\Omega_e} \\rho \\mathbf{N}^T \\mathbf{N} dV $$\n对于厚度为常数 $t$ 的单元，体积积分变为面积积分：\n$$ \\mathbf{M}_e = \\rho t \\int_{A_e} \\mathbf{N}^T \\mathbf{N} dA $$\n积分在母域 $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ 上使用等参映射进行。对于给定的矩形单元，雅可比行列式是常数：$|\\det(\\mathbf{J})| = \\frac{ab}{4}$。质量矩阵的分量为：\n$$ M_{e,ij} = \\rho t \\int_{-1}^{1} \\int_{-1}^{1} N_i(\\xi, \\eta) N_j(\\xi, \\eta) \\left(\\frac{ab}{4}\\right) d\\xi d\\eta $$\n\n### 第二步：$M_e$ 各项的显式计算\n\n由于形函数是可分离的，$M_{e,ij}$ 的积分可以被分解。我们计算基本的一维积分：\n$$ \\int_{-1}^{1} (1-z)^2 dz = \\frac{8}{3}, \\quad \\int_{-1}^{1} (1+z)^2 dz = \\frac{8}{3}, \\quad \\int_{-1}^{1} (1-z)(1+z) dz = \\frac{4}{3} $$\n利用这些积分，我们可以计算出矩阵的各项。例如：\n$$ M_{e,11} = \\rho t \\frac{ab}{64} \\left( \\int_{-1}^{1} (1-\\xi)^2 d\\xi \\right) \\left( \\int_{-1}^{1} (1-\\eta)^2 d\\eta \\right) = \\rho t \\frac{ab}{64} \\left(\\frac{8}{3}\\right)\\left(\\frac{8}{3}\\right) = \\rho t \\frac{ab}{9} $$\n$$ M_{e,12} = \\rho t \\frac{ab}{64} \\left( \\int_{-1}^{1} (1-\\xi)(1+\\xi) d\\xi \\right) \\left( \\int_{-1}^{1} (1-\\eta)^2 d\\eta \\right) = \\rho t \\frac{ab}{18} $$\n$$ M_{e,13} = \\rho t \\frac{ab}{64} \\left( \\int_{-1}^{1} (1-\\xi)(1+\\xi) d\\xi \\right) \\left( \\int_{-1}^{1} (1-\\eta)(1+\\eta) d\\eta \\right) = \\rho t \\frac{ab}{36} $$\n通过对称性，完整的协调质量矩阵为：\n$$ \\mathbf{M}_e = \\frac{\\rho t a b}{36} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} $$\n\n### 第三步：集中质量矩阵及其等价性\n\n集中质量矩阵 $\\mathbf{M}_e^L$ 通过行和技术获得，即将每行的元素相加并放置在对角线上。\n$$ M_{e,ii}^L = \\sum_{j=1}^{4} M_{e,ij} = \\frac{\\rho t a b}{36} (4 + 2 + 1 + 2) = \\frac{9\\rho t a b}{36} = \\frac{\\rho t a b}{4} $$\n由于对称性，所有对角线元素都相同，因此集中质量矩阵为：\n$$ \\mathbf{M}_e^L = \\frac{\\rho t a b}{4} \\mathbf{I}_4 $$\n这等价于将单元的总质量 $M_{total} = \\rho t a b$ 平均分配到四个节点上。这也与在四个节点上使用权重为 $W_k = ab/4$ 的节点求积所得到的结果相同。\n\n### 第四步：归一化协调质量矩阵（$\\widehat{\\mathbf{M}}_e$）\n\n归一化矩阵定义为 $\\widehat{\\mathbf{M}}_e = \\frac{4}{\\rho t a b} \\mathbf{M}_e$。\n$$ \\widehat{\\mathbf{M}}_e = \\frac{4}{\\rho t a b} \\left( \\frac{\\rho t a b}{36} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} \\right) = \\frac{1}{9} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} $$\n该矩阵的行和为 $\\frac{1}{9}(4+2+1+2) = 1$，证实了其集中版本为单位矩阵 $\\mathbf{I}_4$。\n\n### 第五步：Frobenius 范数计算\n\n我们计算偏差矩阵 $\\mathbf{D} = \\widehat{\\mathbf{M}}_e - \\mathbf{I}_4$ 的 Frobenius 范数：\n$$ \\mathbf{D} = \\frac{1}{9} \\begin{pmatrix} 4 & 2 & 1 & 2 \\\\ 2 & 4 & 2 & 1 \\\\ 1 & 2 & 4 & 2 \\\\ 2 & 1 & 2 & 4 \\end{pmatrix} - \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} = \\frac{1}{9} \\begin{pmatrix} -5 & 2 & 1 & 2 \\\\ 2 & -5 & 2 & 1 \\\\ 1 & 2 & -5 & 2 \\\\ 2 & 1 & 2 & -5 \\end{pmatrix} $$\nFrobenius 范数的平方为 $\\|\\mathbf{D}\\|_F^2 = \\sum_{i,j} D_{ij}^2$。\n$$ \\|\\mathbf{D}\\|_F^2 = \\left(\\frac{1}{9}\\right)^2 \\left( 4 \\times (-5)^2 + 8 \\times 2^2 + 4 \\times 1^2 \\right) = \\frac{1}{81} (100 + 32 + 4) = \\frac{136}{81} $$\nFrobenius 范数是其平方根：\n$$ \\|\\mathbf{D}\\|_F = \\sqrt{\\frac{136}{81}} = \\frac{\\sqrt{136}}{\\sqrt{81}} = \\frac{\\sqrt{4 \\times 34}}{9} = \\frac{2\\sqrt{34}}{9} $$\n这就是最终的无量纲标量偏差度量。", "answer": "$$\n\\boxed{\\frac{2\\sqrt{34}}{9}}\n$$", "id": "3561753"}, {"introduction": "一个稳健的有限元程序需要经过严格的验证。本练习将指导你实现“面片检验”（Patch Test），这是一个验证单元公式正确性的基本程序 ([@problem_id:3561821])。通过施加一个已知的线性位移场，并检查计算出的应变和节点反力是否精确，你将能够验证线性三角形（T3）和双线性四边形（Q4）单元的正确性与可靠性。", "problem": "考虑在平面应变条件下，二维小应变线性弹性问题中基于位移的有限元的补丁测试。补丁测试是一个必要的一致性条件：当一个单元族承受一个施加的线性位移场时，所得到的有限元解必须能精确地再现一个恒定的应变状态，并且在约束边界上的节点反力在以节点形式表示时，必须与精确的边界牵引力相匹配。\n\n从虚功基本原理和小应变运动学出发：\n- 线性动量平衡（无体力）：在$\\Omega$内$\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$，边界牵引力为$\\boldsymbol{t} = \\boldsymbol{\\sigma} \\, \\boldsymbol{n}$ on $\\partial \\Omega$。\n- 运动学：$\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{T})$。\n- 线性弹性（各向同性，平面应变）：$\\boldsymbol{\\sigma} = \\mathbb{D} \\, \\boldsymbol{\\varepsilon}$，其中Lamé参数为$\\lambda$和$\\mu$，且$\\lambda = \\dfrac{E \\, \\nu}{(1+\\nu)(1-2\\nu)}$，$\\mu = \\dfrac{E}{2(1+\\nu)}$。\n\n使用基于位移的有限元方法和$C^{0}$连续形函数，一致单元刚度由虚功叙述导出。在补丁测试设置中，施加一个线性位移场\n$\\boldsymbol{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix}$，其中\n$u(x,y) = a_{0} + a_{1} x + a_{2} y$ 且 $v(x,y) = b_{0} + b_{1} x + b_{2} y$，会产生一个恒定的应变状态：\n$\\varepsilon_{xx} = a_{1}$，$\\varepsilon_{yy} = b_{2}$，以及工程剪切应变 $\\gamma_{xy} = a_{2} + b_{1}$，从而导致一个恒定的应力$\\boldsymbol{\\sigma}$。\n\n你的任务是实现一个程序，该程序：\n1. 使用以下单元为二维线性弹性（平面应变）问题组装全局刚度矩阵：\n   - 线性三节点三角形单元（通常简称为$T3$），使用面积坐标。\n   - 双线性四节点四边形单元（通常简称为$Q4$），使用标准等参映射和$2 \\times 2$高斯积分。\n2. 在所有网格节点上施加给定的线性位移场$\\boldsymbol{u}(x,y)$（即在各处施加狄利克雷边界条件）。\n3. 计算：\n   - 单元应变（对于$T3$单元在单元层面计算，对于$Q4$单元在$2 \\times 2$高斯点上计算）以及与精确恒定应变分量$\\left[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\right]^{T}$的最大绝对偏差。\n   - 节点反力$\\boldsymbol{r} = \\mathbf{K}\\boldsymbol{u}$，并将其与精确的节点边界力向量进行比较。该精确向量通过沿域边界积分精确边界牵引力$\\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n}$，并将一致的节点线荷载分配到每个边界边上来获得。使用线性边插值，使得每个两节点边界边对其每个端点贡献$\\tfrac{L}{2}\\boldsymbol{t}$，其中$L$是边长，$\\boldsymbol{t}$因$\\boldsymbol{\\sigma}$恒定而沿边恒定。\n4. 为每个测试案例报告两个浮点误差度量：\n   - $e_{\\varepsilon} =$ 所有评估点和分量上的最大绝对应变误差。\n   - $e_{r} =$ 反力误差的相对$\\ell^{2}$范数，计算公式为$\\dfrac{\\lVert \\boldsymbol{r} - \\boldsymbol{f}_{\\text{exact}} \\rVert_{2}}{\\max(\\lVert \\boldsymbol{f}_{\\text{exact}} \\rVert_{2}, 1)}$。\n\n使用以下材料参数和施加的位移系数（平面应变）：\n- 杨氏模量 $E = 3.0 \\times 10^{7}$，泊松比 $\\nu = 0.25$。\n- 系数：$a_{0} = 0.01$，$a_{1} = 0.2$，$a_{2} = -0.1$，$b_{0} = -0.02$，$b_{1} = 0.05$，$b_{2} = 0.15$。\n\n定义由施加场隐含的精确应变和应力：\n- 精确工程应变向量 $\\boldsymbol{\\varepsilon}_{\\text{exact}} = \\begin{bmatrix} a_{1} \\\\ b_{2} \\\\ a_{2} + b_{1} \\end{bmatrix}$。\n- 平面应变下的精确应力分量：\n  - $\\sigma_{xx} = (\\lambda + 2\\mu) a_{1} + \\lambda b_{2}$，\n  - $\\sigma_{yy} = \\lambda a_{1} + (\\lambda + 2\\mu) b_{2}$，\n  - $\\sigma_{xy} = \\mu (a_{2} + b_{1})$。\n\n测试套件。实现以下三个测试案例：\n- 案例1（三角形网格，规则补丁）：域为$\\left[0,1\\right] \\times \\left[0,1\\right]$，网格包含$2 \\times 2$个方形单元，每个单元分裂成两个$T3$单元（总共$8$个三角形，$9$个节点）。报告$e_{\\varepsilon}$和$e_{r}$。\n- 案例2（四边形网格，规则$Q4$）：域为$\\left[0,2\\right] \\times \\left[0,1\\right]$，网格包含$2 \\times 1$个$Q4$单元（总共$2$个四边形，$6$个节点）。使用$2 \\times 2$高斯积分。报告$e_{\\varepsilon}$和$e_{r}$。\n- 案例3（三角形网格，狭长单元）：域为$\\left[0,2\\right] \\times \\left[0,0.2\\right]$，网格包含$2 \\times 1$个矩形单元，每个单元分裂成两个$T3$单元（总共$4$个三角形，$6$个节点）。报告$e_{\\varepsilon}$和$e_{r}$。\n\n所有结果都应为无量纲浮点数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：$\\left[e_{\\varepsilon}^{(1)}, e_{r}^{(1)}, e_{\\varepsilon}^{(2)}, e_{r}^{(2)}, e_{\\varepsilon}^{(3)}, e_{r}^{(3)}\\right]$。\n\n角度单位不适用。输出中不需要物理单位，因为所要求的误差度量是无量纲的。", "solution": "### 1. 理论与实现框架\n\n补丁测试（Patch Test）通过验证有限元单元是否能精确再现一个已知的常应变状态，来检验其一致性。这是保证收敛性的一个必要条件。本问题的实现遵循以下步骤：\n\n1.  **设置**：定义材料参数（$E, \\nu$）、施加的线性位移场系数（$a_i, b_i$）、以及各个测试案例的几何与网格信息。根据这些参数，计算出精确的常应变向量 $\\boldsymbol{\\varepsilon}_{\\text{exact}}$ 和常应力张量 $\\boldsymbol{\\sigma}_{\\text{exact}}$。\n\n2.  **网格生成与位移施加**：为每个案例生成节点坐标和单元连接性。根据给定的线性位移场公式，计算并存储每个节点的位移，形成全局位移向量 $\\boldsymbol{u}_{\\text{global}}$。\n\n3.  **刚度矩阵组装与应变计算**：\n    *   遍历每个单元，根据其类型（T3或Q4）计算单元刚度矩阵 $\\mathbf{k}^e$。\n    *   **对于T3单元**：应变-位移矩阵 $\\mathbf{B}$ 是恒定的。$\\mathbf{k}^e$ 通过公式 $\\mathbf{k}^e = A \\, \\mathbf{B}^T \\mathbb{D} \\mathbf{B}$（其中 $A$ 是单元面积）直接计算。计算出的单元应变 $\\boldsymbol{\\varepsilon}^e = \\mathbf{B} \\boldsymbol{d}^e$ 也与精确应变进行比较。\n    *   **对于Q4单元**：$\\mathbf{k}^e$ 通过在 $2 \\times 2$ 高斯点上进行数值积分得到。在每个高斯点，计算雅可比矩阵 $\\mathbf{J}$、$\\det(\\mathbf{J})$ 以及应变-位移矩阵 $\\mathbf{B}_{gp}$。在每个高斯点上计算的应变 $\\boldsymbol{\\varepsilon}_{gp} = \\mathbf{B}_{gp} \\boldsymbol{d}^e$ 都与精确应变进行比较。\n    *   将所有单元刚度矩阵 $\\mathbf{k}^e$ 组装成全局刚度矩阵 $\\mathbf{K}$。\n\n4.  **误差计算**：\n    *   **应变误差 $e_{\\varepsilon}$**：在刚度矩阵组装过程中，跟踪所有评估点（T3单元的中心，Q4单元的各高斯点）上计算出的应变与精确应变之间的最大绝对差值。\n    *   **反力误差 $e_{r}$**：\n        *   **数值反力**：通过矩阵-向量乘法 $\\boldsymbol{r} = \\mathbf{K} \\boldsymbol{u}_{\\text{global}}$ 计算出与施加位移场对应的节点反力。\n        *   **精确节点力**：通过识别域的边界边，计算出由精确边界牵引力 $\\boldsymbol{t} = \\boldsymbol{\\sigma}_{\\text{exact}} \\boldsymbol{n}$ 产生的等效节点力。对于每个长度为 $L$ 的边界边，其两个节点各贡献 $\\frac{L}{2}\\boldsymbol{t}$ 的力。将所有边界边的贡献相加得到精确的全局节点力向量 $\\boldsymbol{f}_{\\text{exact}}$。\n        *   **相对误差**：使用给定的公式计算 $\\boldsymbol{r}$ 和 $\\boldsymbol{f}_{\\text{exact}}$ 之间的相对 $\\ell^2$ 范数。\n\n由于T3和Q4单元都能精确表示线性位移场，它们应能通过补丁测试，即所有误差应为零或接近机器精度。\n\n### 2. Python 实现\n\n以下Python代码实现了上述补丁测试程序。\n\n```python\nimport numpy as np\nfrom collections import Counter\n\ndef get_plane_strain_d_matrix(E, nu):\n    \"\"\"Computes the plane strain material stiffness matrix D.\"\"\"\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    d11 = lmbda + 2 * mu\n    d12 = lmbda\n    d33 = mu\n    return np.array([\n        [d11, d12, 0],\n        [d12, d11, 0],\n        [0,   0,   d33]\n    ])\n\ndef get_t3_b_matrix(coords):\n    \"\"\"Computes the constant strain-displacement matrix B for a T3 element.\"\"\"\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    \n    area = 0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    if area = 0:\n        raise ValueError(\"Element has zero or negative area, check node ordering.\")\n    \n    b = np.zeros((3, 6))\n    b[0, 0] = y2 - y3\n    b[0, 2] = y3 - y1\n    b[0, 4] = y1 - y2\n    b[1, 1] = x3 - x2\n    b[1, 3] = x1 - x3\n    b[1, 5] = x2 - x1\n    b[2, 0] = x3 - x2\n    b[2, 1] = y2 - y3\n    b[2, 2] = x1 - x3\n    b[2, 3] = y3 - y1\n    b[2, 4] = x2 - x1\n    b[2, 5] = y1 - y2\n    \n    return b / (2 * area), area\n\ndef get_q4_gauss_points():\n    \"\"\"Returns 2x2 Gauss quadrature points and weights.\"\"\"\n    p = 1.0 / np.sqrt(3.0)\n    points = [(-p, -p), (p, -p), (p, p), (-p, p)]\n    weights = [1.0, 1.0, 1.0, 1.0]\n    return points, weights\n\ndef get_q4_shape_functions_derivs(xi, eta):\n    \"\"\"Derivatives of Q4 shape functions wrt natural coords (xi, eta).\"\"\"\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return dN_dxi, dN_deta\n\ndef generate_mesh(domain_dims, grid_dims, elem_type):\n    \"\"\"Generates a structured mesh of T3 or Q4 elements.\"\"\"\n    lx, ly = domain_dims\n    nx, ny = grid_dims\n    \n    x_coords = np.linspace(0, lx, nx + 1)\n    y_coords = np.linspace(0, ly, ny + 1)\n    \n    nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n    \n    elements = []\n    if elem_type == 'Q4':\n        for j in range(ny):\n            for i in range(nx):\n                n1 = j * (nx + 1) + i\n                n2 = n1 + 1\n                n3 = (j + 1) * (nx + 1) + i + 1\n                n4 = n3 - 1\n                elements.append([n1, n2, n3, n4])\n    elif elem_type == 'T3':\n        for j in range(ny):\n            for i in range(nx):\n                n1 = j * (nx + 1) + i\n                n2 = n1 + 1\n                n3 = (j + 1) * (nx + 1) + i + 1\n                n4 = n3 - 1\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n    \n    return nodes, np.array(elements)\n\ndef run_patch_test(E, nu, coeffs, case_params):\n    \"\"\"Runs a single patch test case.\"\"\"\n    d_matrix = get_plane_strain_d_matrix(E, nu)\n    a0, a1, a2 = coeffs['a0'], coeffs['a1'], coeffs['a2']\n    b0, b1, b2 = coeffs['b0'], coeffs['b1'], coeffs['b2']\n    exact_strain = np.array([a1, b2, a2 + b1])\n    exact_stress_vec = d_matrix @ exact_strain\n    exact_stress_tensor = np.array([[exact_stress_vec[0], exact_stress_vec[2]], [exact_stress_vec[2], exact_stress_vec[1]]])\n    nodes, elements = generate_mesh(case_params['domain'], case_params['grid'], case_params['type'])\n    num_nodes, num_dofs = len(nodes), 2 * len(nodes)\n    u_global = np.zeros(num_dofs)\n    for i, (x, y) in enumerate(nodes):\n        u_global[2*i] = a0 + a1 * x + a2 * y\n        u_global[2*i+1] = b0 + b1 * x + b2 * y\n    \n    K_global = np.zeros((num_dofs, num_dofs))\n    max_strain_error = 0.0\n\n    if case_params['type'] == 'T3':\n        for el_nodes in elements:\n            coords = nodes[el_nodes]\n            B, area = get_t3_b_matrix(coords)\n            k_e = area * B.T @ d_matrix @ B\n            dofs = np.ravel([[2*n, 2*n+1] for n in el_nodes])\n            K_global[np.ix_(dofs, dofs)] += k_e\n            u_e = u_global[dofs]\n            strain = B @ u_e\n            max_strain_error = max(max_strain_error, np.max(np.abs(strain - exact_strain)))\n    elif case_params['type'] == 'Q4':\n        gauss_points, gauss_weights = get_q4_gauss_points()\n        for el_nodes in elements:\n            coords = nodes[el_nodes]\n            k_e = np.zeros((8, 8))\n            for gp, weight in zip(gauss_points, gauss_weights):\n                xi, eta = gp\n                dN_dxi, dN_deta = get_q4_shape_functions_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ coords\n                detJ = np.linalg.det(J)\n                if detJ = 0: raise ValueError(\"Invalid Jacobian.\")\n                dN_dxy = np.linalg.inv(J) @ np.vstack((dN_dxi, dN_deta))\n                B_gp = np.zeros((3, 8)); B_gp[0, 0::2] = dN_dxy[0, :]; B_gp[1, 1::2] = dN_dxy[1, :]; B_gp[2, 0::2] = dN_dxy[1, :]; B_gp[2, 1::2] = dN_dxy[0, :]\n                k_e += weight * (B_gp.T @ d_matrix @ B_gp) * detJ\n                dofs = np.ravel([[2*n, 2*n+1] for n in el_nodes])\n                u_e = u_global[dofs]\n                strain = B_gp @ u_e\n                max_strain_error = max(max_strain_error, np.max(np.abs(strain - exact_strain)))\n            dofs = np.ravel([[2*n, 2*n+1] for n in el_nodes])\n            K_global[np.ix_(dofs, dofs)] += k_e\n\n    r_numerical = K_global @ u_global\n    f_exact = np.zeros(num_dofs)\n    all_edges = [tuple(sorted((el_nodes[i], el_nodes[(i + 1) % len(el_nodes)]))) for el_nodes in elements for i in range(len(el_nodes))]\n    edge_counts = Counter(all_edges)\n    boundary_edges = {edge for edge, count in edge_counts.items() if count == 1}\n\n    for el_nodes in elements:\n        for i in range(len(el_nodes)):\n            n1, n2 = el_nodes[i], el_nodes[(i + 1) % len(el_nodes)]\n            if tuple(sorted((n1,n2))) in boundary_edges:\n                p1, p2 = nodes[n1], nodes[n2]\n                dx, dy = p2 - p1\n                edge_len = np.sqrt(dx**2 + dy**2)\n                normal = np.array([dy, -dx]) / edge_len\n                traction = exact_stress_tensor @ normal\n                force_contrib = 0.5 * edge_len * traction\n                f_exact[2*n1:2*n1+2] += force_contrib\n                f_exact[2*n2:2*n2+2] += force_contrib\n    \n    e_eps = max_strain_error\n    norm_f_exact = np.linalg.norm(f_exact)\n    e_r = np.linalg.norm(r_numerical - f_exact) / max(norm_f_exact, 1.0)\n    \n    return e_eps, e_r\n```", "answer": "[8.326672684688674e-17,3.738127395048682e-15,0.0,4.095066928812683e-15,1.6653345369377348e-16,1.554030737035656e-15]", "id": "3561821"}]}