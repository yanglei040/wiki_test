{"hands_on_practices": [{"introduction": "本练习将引导你运用Gillespie算法——计算系统生物学中的一个核心工具——来验证积分涨落定理 (Integral Fluctuation Theorem, IFT)。IFT断言，对于在有限时间内演化的系统，总熵产生 $\\Delta s_{\\mathrm{tot}}$ 的指数期望值为1，即 $\\langle \\exp(-\\Delta s_{\\mathrm{tot}}) \\rangle = 1$。通过对一个由ATP驱动的简单酶促循环进行随机模拟，你将亲手验证这一基本原理，从而将抽象的理论与具体的生物模型联系起来。[@problem_id:3308563]", "problem": "您的任务是基于 Gillespie 算法实现一个随机模拟，以模拟一个由三磷酸腺苷 (ATP) 驱动的酶循环，并利用置信区间经验性地验证关于轨迹总熵产生的积分涨落定理 (IFT)。该设定是一个连续时间、时齐的有限状态马尔可夫跳跃过程，适用于研究生高阶水平的计算系统生物学。\n\n基本基础和情景：\n- 考虑一个具有状态 $0$、$1$ 和 $2$ 的三态循环生化网络。生化循环 $0 \\to 1 \\to 2 \\to 0$ 代表 ATP 水解驱动的进程；逆向循环 $0 \\leftarrow 1 \\leftarrow 2 \\leftarrow 0$ 代表 ATP 合成驱动的进程。\n- 该系统是一个马尔可夫跳跃过程，其中每个状态有两个出向跃迁，一个正向（顺时针）和一个逆向（逆时针），并且该过程在有限的时间范围内进行观察。\n- 假设速率与时间无关，且满足与热力学一致的局域细致平衡。设无量纲的 ATP 化学亲和势为 $A = \\Delta \\mu_{\\mathrm{ATP}} / (k_{\\mathrm{B}} T)$，其中 $\\Delta \\mu_{\\mathrm{ATP}}$ 是 ATP 水解的自由能差， $k_{\\mathrm{B}}$ 是玻尔兹曼常数， $T$ 是绝对温度。循环亲和势 $A$ 在三条边上均等分配。对于基础速率 $k_0$（单位为 $\\mathrm{s}^{-1}$），将特定边的速率定义如下。对于 $\\{0 \\to 1, 1 \\to 2, 2 \\to 0\\}$ 中的每个顺时针边 $i \\to j$，设置正向速率 $k_{ij} = k_0 \\exp\\left(\\frac{A}{6}\\right)$；对于逆向边 $j \\to i$，设置逆向速率 $k_{ji} = k_0 \\exp\\left(-\\frac{A}{6}\\right)$。这得到 $\\ln\\left(\\frac{k_{ij}}{k_{ji}}\\right) = \\frac{A}{3}$，以及对于一个完整的顺时针循环，净循环亲和势为 $A$。\n- 对于这种对称结构，稳态分布在各个状态上是均匀的，且沿轨迹的系统熵变为零。因此，轨迹总熵产生 $\\Delta s_{\\mathrm{tot}}$ 等于介质的熵产生（以 $k_{\\mathrm{B}}$ 为单位），其对于一次跳跃 $i \\to j$ 的增量为 $\\ln\\left(\\frac{k_{ij}}{k_{ji}}\\right)$。\n\n任务：\n1. 为这个三态网络实现一个 Gillespie 模拟。对于给定的时间范围 $T$（单位为 $\\mathrm{s}$）、独立轨迹数 $M$、基础速率 $k_0$（单位为 $\\mathrm{s}^{-1}$）和亲和势 $A$（无量纲），从稳态分布开始模拟 $M$ 条独立轨迹。对于每条轨迹，计算总熵产生 $\\Delta s_{\\mathrm{tot}}$，其值为在 $[0, T]$ 内所有实际发生跳跃的 $\\ln\\left(\\frac{k_{ij}}{k_{ji}}\\right)$ 之和。然后计算这 $M$ 条轨迹的 $e^{-\\Delta s_{\\mathrm{tot}}}$ 样本。\n2. 估计 $X = e^{-\\Delta s_{\\mathrm{tot}}}$ 的样本均值 $\\bar{m}$，并使用正态近似构建一个置信水平为 $95$ 的双边置信区间，即 $\\bar{m} \\pm z \\cdot \\frac{s}{\\sqrt{M}}$，其中 $z = 1.96$，$s$ 是 $X$ 的样本标准差。\n3. 通过检查数值 $1$ 是否位于上述计算的 $95$ 置信区间内，来验证总熵产生的积分涨落定理。报告均值、区间的下界和上界，以及一个布尔值，用以表明定理在此意义上是否得到验证。\n\n数值和物理单位：\n- 时间 $T$ 必须以 $\\mathrm{s}$ 为单位提供，速率 $k_0$ 必须以 $\\mathrm{s}^{-1}$ 为单位。\n- 熵产生 $\\Delta s_{\\mathrm{tot}}$ 是无量纲的，并以 $k_{\\mathrm{B}}$ 为单位进行度量。\n- 本问题中不使用角度。\n- 任何比例或分数都应以小数形式报告。\n\n测试套件：\n实现程序以运行以下测试用例，并使用固定的随机种子以保证可复现性。对每个用例，按指定设置随机种子，并生成所述的输出。\n\n- 用例 $1$（标准情况）：$A = 6$, $k_0 = 1\\,\\mathrm{s}^{-1}$, $T = 20\\,\\mathrm{s}$, $M = 10000$, 随机种子 $1$。\n- 用例 $2$（平衡边界）：$A = 0$, $k_0 = 1\\,\\mathrm{s}^{-1}$, $T = 20\\,\\mathrm{s}$, $M = 5000$, 随机种子 $2$。\n- 用例 $3$（更强驱动，更短时程）：$A = 8$, $k_0 = 1\\,\\mathrm{s}^{-1}$, $T = 10\\,\\mathrm{s}$, $M = 10000$, 随机种子 $3$。\n- 用例 $4$（小样本边缘情况）：$A = 6$, $k_0 = 1\\,\\mathrm{s}^{-1}$, $T = 5\\,\\mathrm{s}$, $M = 200$, 随机种子 $4$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个包含四个元素的列表，顺序为 $[\\bar{m}, \\text{CI}_{\\mathrm{low}}, \\text{CI}_{\\mathrm{high}}, \\text{verified}]$，其中 $\\bar{m}$、$\\text{CI}_{\\mathrm{low}}$ 和 $\\text{CI}_{\\mathrm{high}}$ 是浮点数，$\\text{verified}$ 是布尔值。例如，最终输出应类似于 $[[m_1, \\ell_1, u_1, \\mathrm{True}], [m_2, \\ell_2, u_2, \\mathrm{True}], [m_3, \\ell_3, u_3, \\mathrm{False}], [m_4, \\ell_4, u_4, \\mathrm{True}]]$，其中的值为您的程序计算出的数值。", "solution": "任务是对一个三态酶循环进行随机模拟，以经验性地验证总熵产生的积分涨落定理 (IFT)。对于一个在有限时间范围内演化的系统，IFT 指出，指数化的负总熵产生的系综平均值恰好为 1：$\\langle e^{-\\Delta s_{\\mathrm{tot}}} \\rangle = 1$。我们将使用 Gillespie 算法生成一个轨迹系综，计算相关量，并进行统计分析，以检查理论值 $1$ 是否落在这个平均值的估计 $95\\%$ 置信区间内。\n\n该系统被建模为一个在三个状态集合 $S = \\{0, 1, 2\\}$ 上的连续时间马尔可夫跳跃过程。跃迁形成一个循环，正向（顺时针）跃迁代表一个 ATP 驱动的过程，而逆向（逆时针）跃迁代表相反的过程。其动力学由满足局域细致平衡的、不随时间变化的跃迁速率决定。\n\n给定一个基础速率 $k_0$ 和一个无量纲的化学亲和势 $A$，跃迁速率定义如下：\n对于任何正向跃迁 $i \\to j$（其中 $j = (i+1) \\pmod 3$），速率为 $k_{ij} = k_f = k_0 \\exp\\left(\\frac{A}{6}\\right)$。\n对于任何逆向跃迁 $j \\to i$（其中 $i = (j-1) \\pmod 3$），速率为 $k_{ji} = k_r = k_0 \\exp\\left(-\\frac{A}{6}\\right)$。\n这种对称结构确保了稳态分布 $\\pi_{\\text{ss}}$ 在三个状态上是均匀的，即对于 $i \\in \\{0, 1, 2\\}$，有 $\\pi_{\\text{ss}}(i) = 1/3$。\n\n总熵产生 $\\Delta s_{\\mathrm{tot}}$ 以玻尔兹曼常数 $k_B$ 为单位度量，是沿一条轨迹的环境熵变之和。对于从状态 $i$ 到状态 $j$ 的单次跳跃，熵产生增量由该跃迁的正向速率与逆向速率之比的对数给出：$\\Delta s_{\\text{jump}} = \\ln\\left(\\frac{k_{ij}}{k_{ji}}\\right)$。\n对于一次正向跳跃，增量为 $\\Delta s_{\\text{fwd}} = \\ln\\left(\\frac{k_f}{k_r}\\right) = \\ln\\left(\\frac{k_0 e^{A/6}}{k_0 e^{-A/6}}\\right) = \\ln\\left(e^{A/3}\\right) = \\frac{A}{3}$。\n对于一次逆向跳跃，增量为 $\\Delta s_{\\text{rev}} = \\ln\\left(\\frac{k_r}{k_f}\\right) = -\\frac{A}{3}$。\n时长为 $T$ 的轨迹的总熵产生是在时间区间 $[0, T]$ 内发生的所有跳跃的这些增量之和。\n\n轨迹的模拟使用 Gillespie 算法进行：\n1.  初始化：在时间 $t=0$ 时，系统被置于从均匀稳态分布中抽取的初始状态 $X_0$。总熵产生 $\\Delta s_{\\mathrm{tot}}$ 初始化为 $0$。\n2.  迭代：算法通过确定下一次跳跃的时间和类型来推进。\n    -   离开任何状态的总速率是恒定的，$R_{\\text{tot}} = k_f + k_r$。到下一次跳跃的时间 $\\Delta t$ 是一个从速率为 $R_{\\text{tot}}$ 的指数分布中抽取的随机变量，可以生成为 $\\Delta t = -(\\ln u_1) / R_{\\text{tot}}$，其中 $u_1$ 是来自均匀分布 $U(0,1)$ 的一个随机数。\n    -   如果当前时间 $t + \\Delta t$ 超过总模拟时间 $T$，则轨迹结束。\n    -   否则，时间推进 $t \\leftarrow t + \\Delta t$。\n    -   跳跃的类型（正向或逆向）通过抽取另一个均匀随机数 $u_2 \\sim U(0,1)$ 来确定。如果 $u_2  p_{\\text{fwd}}$，则发生正向跳跃，其中 $p_{\\text{fwd}} = k_f / R_{\\text{tot}}$；否则，发生逆向跳跃。\n    -   系统状态更新到新状态，并将相应的熵增量（$\\frac{A}{3}$ 或 $-\\frac{A}{3}$）加到 $\\Delta s_{\\mathrm{tot}}$ 上。\n3.  终止：重复此过程，直到时间 $t$ 达到 $T$。\n\n为了验证 IFT，我们模拟 $M$ 条独立轨迹。对于每条轨迹 $k \\in \\{1, \\dots, M\\}$，我们计算总熵产生 $\\Delta s_{\\mathrm{tot}, k}$，然后计算量 $X_k = e^{-\\Delta s_{\\mathrm{tot}, k}}$。这提供了一个样本 $\\{X_1, X_2, \\dots, X_M\\}$。\nIFT，即 $\\langle e^{-\\Delta s_{\\mathrm{tot}}} \\rangle = 1$，通过统计方法进行检验。我们计算样本均值 $\\bar{m} = \\frac{1}{M}\\sum_{k=1}^{M} X_k$ 和样本标准差 $s = \\sqrt{\\frac{1}{M-1}\\sum_{k=1}^{M} (X_k - \\bar{m})^2}$。\n使用正态近似构建真实均值的双边 $95\\%$ 置信区间：\n$$ \\text{CI} = \\left[ \\bar{m} - z \\frac{s}{\\sqrt{M}}, \\bar{m} + z \\frac{s}{\\sqrt{M}} \\right] $$\n其中 $z=1.96$ 是 $95\\%$ 置信水平的临界值。如果理论值 $1$ 包含在该区间内，即 $\\text{CI}_{\\text{low}} \\le 1 \\le \\text{CI}_{\\text{high}}$，则该定理被认为是经验性验证的。\n\nPython 实现使用了 `numpy` 库来进行高效的数值计算和使用其随机数生成器，该生成器被设定种子以确保在指定测试用例中的可复现性。代码遍历每个用例，运行 $M$ 次模拟，计算统计数据，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_gillespie_trajectory(A, k0, T, rng):\n    \"\"\"\n    Simulates a single trajectory of the 3-state enzymatic cycle.\n\n    Args:\n        A (float): Dimensionless chemical affinity.\n        k0 (float): Base rate in s^-1.\n        T (float): Time horizon in s.\n        rng (numpy.random.Generator): Random number generator instance.\n\n    Returns:\n        float: The total entropy production for the trajectory.\n    \"\"\"\n    # Special case for equilibrium where all entropy changes are zero.\n    if A == 0.0:\n        return 0.0\n\n    # Calculate forward and reverse rates\n    k_f = k0 * np.exp(A / 6.0)\n    k_r = k0 * np.exp(-A / 6.0)\n    R_tot = k_f + k_r\n    \n    # Pre-calculate entropy increments for forward and reverse jumps\n    delta_s_fwd = A / 3.0\n    delta_s_rev = -A / 3.0\n\n    # Initialization\n    t = 0.0\n    total_entropy_production = 0.0\n    # Initial state is drawn from the uniform stationary distribution\n    current_state = rng.integers(0, 3)\n\n    # Probability of a forward jump\n    p_fwd = k_f / R_tot\n\n    while t  T:\n        # Time to next event is drawn from an exponential distribution\n        dt = rng.exponential(scale=1.0/R_tot)\n\n        # If next event is beyond the time horizon, end the trajectory\n        if t + dt  T:\n            break\n        \n        t += dt\n\n        # Determine the type of jump (forward or reverse)\n        if rng.random()  p_fwd:\n            # Forward jump: i - (i+1)%3\n            total_entropy_production += delta_s_fwd\n            current_state = (current_state + 1) % 3\n        else:\n            # Reverse jump: i - (i-1)%3\n            total_entropy_production += delta_s_rev\n            current_state = (current_state - 1 + 3) % 3\n    \n    return total_entropy_production\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and verify the Integral Fluctuation Theorem.\n    \"\"\"\n    test_cases = [\n        {'A': 6.0, 'k0': 1.0, 'T': 20.0, 'M': 10000, 'seed': 1},\n        {'A': 0.0, 'k0': 1.0, 'T': 20.0, 'M': 5000, 'seed': 2},\n        {'A': 8.0, 'k0': 1.0, 'T': 10.0, 'M': 10000, 'seed': 3},\n        {'A': 6.0, 'k0': 1.0, 'T': 5.0, 'M': 200, 'seed': 4},\n    ]\n\n    results = []\n    z_score = 1.96\n\n    for case in test_cases:\n        A, k0, T, M, seed = case['A'], case['k0'], case['T'], case['M'], case['seed']\n        \n        # Initialize a random number generator with a specific seed for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Array to store the values of X = exp(-entropy_production)\n        X_samples = np.zeros(M)\n        \n        for i in range(M):\n            s_tot = run_gillespie_trajectory(A, k0, T, rng)\n            X_samples[i] = np.exp(-s_tot)\n            \n        # Compute sample mean and standard deviation\n        m_bar = np.mean(X_samples)\n        # Use ddof=1 for sample standard deviation\n        s = np.std(X_samples, ddof=1)\n        \n        # Construct the 95% confidence interval\n        # Handle cases where M=1 (not in test suite) or s=0 (for A=0 case)\n        if M  1 and s  0:\n            margin_of_error = z_score * s / np.sqrt(M)\n            ci_low = m_bar - margin_of_error\n            ci_high = m_bar + margin_of_error\n        else:\n            ci_low = m_bar\n            ci_high = m_bar\n\n        # Verify if 1.0 is within the confidence interval\n        verified = (ci_low = 1.0) and (1.0 = ci_high)\n        \n        results.append([m_bar, ci_low, ci_high, verified])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3308563"}, {"introduction": "在验证了基本定理之后，我们转向一个更具实践性的挑战：估算稳态熵产生率 (entropy production rate, EPR)，这是一个衡量系统非平衡程度和能量耗散的关键物理量。本练习要求你实现并比较多种估算方法，包括基于循环亲和势、轨迹平均管家热以及热力学不确定性关系 (Thermodynamic Uncertainty Relation, TUR) 的方法。通过这个过程，你将深入理解不同估算量的理论基础、数据需求及其在有限数据下的表现。[@problem_id:3308568]", "problem": "您将实现并比较一个合成生化反应网络中稳态熵产生率的三种估计量，该网络被建模为连续时间马尔可夫跳跃过程，并用精确的基准值对它们进行验证。这些估计量基于：(i) 循环亲和势表示法，(ii) 轨迹平均的管家热，以及 (iii) 源自热力学不确定性关系 (TUR) 的一个下界。您的程序必须模拟其动力学过程，计算所有估计量，并生成一行输出，汇总所有测试用例的结果。\n\n假设一个在有限状态集上的连续时间马尔可夫跳跃过程，其生成元矩阵为 $Q$，其中对于 $i \\neq j$，非对角线元素满足 $Q_{ij} = k_{ij} \\ge 0$，对角线元素为 $Q_{ii} = -\\sum_{j \\neq i} k_{ij}$。令 $\\boldsymbol{\\pi}$ 为满足 $\\boldsymbol{\\pi}^\\top Q = \\boldsymbol{0}$ 和 $\\sum_i \\pi_i = 1$ 的唯一稳态分布。在 $k_{\\mathrm{B}} T = 1$ 的单位制下，所有量均为无量纲量，因此跃迁速率的对数比值可解释为物理亲和势和热量子。不涉及角度。不要使用百分号；任何比率都应以小数形式返回。\n\n您的实现必须遵循以下原则。\n\n- 基本定义：\n  - 状态 $i$ 和 $j$ 之间的稳态边通量为 $J_{ij} = \\pi_i k_{ij} - \\pi_j k_{ji}$，且 $J_{ij} = -J_{ji}$。\n  - 精确的稳态熵产生率为\n    $$\\sigma_{\\mathrm{true}} = \\frac{1}{2} \\sum_{i \\neq j} J_{ij} \\,\\ln\\!\\left(\\frac{\\pi_i k_{ij}}{\\pi_j k_{ji}}\\right)。$$\n  - 对于一个包含边 $(i \\to j)$ 的有向基本环 $\\mathcal{C}$，其循环亲和势为\n    $$\\mathcal{A}_{\\mathcal{C}} = \\sum_{(i \\to j) \\in \\mathcal{C}} \\ln\\!\\left(\\frac{k_{ij}}{k_{ji}}\\right)。$$\n\n- 在长度为 $T$ 的时间窗口内的轨迹可观测量：\n  - 令 $Y_T$ 为有向边 $(a \\to b)$ 的时间积分流，定义为在 $[0,T]$ 期间沿 $(a \\to b)$ 的净跳跃次数（沿 $(a \\to b)$ 的跳跃次数减去沿 $(b \\to a)$ 的跳跃次数）。\n  - 沿一条轨迹累积的管家热为\n    $$Q_{\\mathrm{hk}}(T) = \\sum_{\\text{jumps } i \\to j \\text{ in } [0,T]} \\ln\\!\\left(\\frac{\\pi_i k_{ij}}{\\pi_j k_{ji}}\\right)。$$\n  - 在非平衡稳态下，当使用真实的稳态分布 $\\boldsymbol{\\pi}$ 计算时，$T^{-1} \\,\\mathbb{E}[Q_{\\mathrm{hk}}(T)]$ 等于稳态熵产生率。\n\n- 需要实现的估计量：\n  - 在三态环 $(1 \\to 2 \\to 3 \\to 1)$ 上的循环亲和势估计量：\n    $$\\widehat{\\sigma}_{\\mathrm{cycle}} = \\widehat{J}_{\\mathrm{cycle}} \\,\\mathcal{A}, \\quad \\widehat{J}_{\\mathrm{cycle}} = \\frac{\\mathbb{E}[Y_T]}{T}, \\quad \\mathcal{A} = \\ln\\!\\left(\\frac{k_{12} k_{23} k_{31}}{k_{21} k_{32} k_{13}}\\right)。$$\n    此处，通过对独立轨迹的 $Y_T$ 进行平均来经验性地估计 $\\mathbb{E}[Y_T]$；使用 $(a,b) = (1,2)$ 来定义 $Y_T$。\n  - 管家热估计量：\n    $$\\widehat{\\sigma}_{\\mathrm{hk}} = \\frac{\\mathbb{E}[Q_{\\mathrm{hk}}(T)]}{T},$$\n    其中，期望值通过对独立轨迹的 $Q_{\\mathrm{hk}}(T)$ 进行平均来近似，计算时使用从 $Q$ 计算出的真实稳态分布 $\\boldsymbol{\\pi}$。\n  - 基于边的经验稳态估计量：通过在所有模拟轨迹的拼接上每个状态所花费的时间分数来估计稳态分布 $\\widehat{\\boldsymbol{\\pi}}$，并通过 $\\widehat{J}_{ij} = \\widehat{\\lambda}_{ij} - \\widehat{\\lambda}_{ji}$ 来估计经验通量，其中 $\\widehat{\\lambda}_{ij}$ 是观察到的单位时间内的跃迁次数。然后计算\n    $$\\widehat{\\sigma}_{\\mathrm{edge}} = \\frac{1}{2} \\sum_{i \\neq j} \\widehat{J}_{ij} \\,\\ln\\!\\left(\\frac{k_{ij} \\widehat{\\pi}_i}{k_{ji} \\widehat{\\pi}_j}\\right)。$$\n  - 热力学不确定性关系 (TUR) 下界：对于积分流 $Y_T$，热力学不确定性关系 (TUR) 表明 $\\mathrm{Var}[Y_T] / \\mathbb{E}[Y_T]^2 \\ge 2/(\\sigma T)$，因此\n    $$\\sigma \\ge \\widehat{\\sigma}_{\\mathrm{TUR}} = \\frac{2 \\left(\\overline{Y}_T\\right)^2}{T \\,\\widehat{\\mathrm{Var}}[Y_T]},$$\n    其中 $\\overline{Y}_T$ 和 $\\widehat{\\mathrm{Var}}[Y_T]$ 分别是 $Y_T$ 在独立轨迹上的样本均值和样本方差。如果样本方差在数值上为零，则定义 $\\widehat{\\sigma}_{\\mathrm{TUR}} = 0$。\n\n- 模拟协议：\n  - 对每次重复实验，使用 Gillespie 算法模拟连续时间马尔可夫跳跃过程，时间范围固定为 $T$。\n  - 对于每次重复实验，通过从真实的稳态分布 $\\boldsymbol{\\pi}$ 中抽样来初始化状态，以避免瞬态过程。\n  - 收集每个状态所花费的时间、沿每条有向边的跃迁次数、沿 $(1 \\to 2)$ 的有向流 $Y_T$，以及沿轨迹的管家热 $Q_{\\mathrm{hk}}(T)$。\n  - 重复进行 $M$ 次独立的重复实验，并使用汇总数据来构建上述估计量。使用固定的伪随机种子以确保可复现性。\n\n- 基准值计算：\n  - 通过求解 $\\boldsymbol{\\pi}^\\top Q = \\boldsymbol{0}$ 并归一化 $\\sum_i \\pi_i = 1$ 来获得稳态分布 $\\boldsymbol{\\pi}$，然后根据上述定义精确计算基准值 $\\sigma_{\\mathrm{true}}$。\n\n测试套件和参数：\n- 考虑一个包含3个状态的环形网络，其边为 $(1 \\leftrightarrow 2)$、$(2 \\leftrightarrow 3)$ 和 $(3 \\leftrightarrow 1)$。三个测试用例的非对角线跃迁速率 $k_{ij}$ 如下：\n  1. 用例 A (细致平衡): $k_{12} = k_{23} = k_{31} = 1.0$, $k_{21} = k_{32} = k_{13} = 1.0$。\n  2. 用例 B (弱驱动): $k_{12} = k_{23} = k_{31} = 1.0$, $k_{21} = k_{32} = k_{13} = 0.9$。\n  3. 用例 C (强驱动): $k_{12} = k_{23} = k_{31} = 3.0$, $k_{21} = k_{32} = k_{13} = 0.3$。\n- 对于所有用例，每次重复实验的模拟时间范围为 $T = 50.0$，重复次数为 $M = 200$。伪随机数生成器使用固定的种子 $42$。\n\n要求的输出：\n- 对于每个测试用例，您的程序必须计算并返回一个包含5个浮点数的列表\n  $$\\big[\\sigma_{\\mathrm{true}},\\, \\widehat{\\sigma}_{\\mathrm{edge}},\\, \\widehat{\\sigma}_{\\mathrm{cycle}},\\, \\widehat{\\sigma}_{\\mathrm{hk}},\\, \\widehat{\\sigma}_{\\mathrm{TUR}}\\big],$$\n  每个数四舍五入到6位小数。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，格式为一个由三个列表组成的逗号分隔列表，并用方括号括起来。示例格式（仅为说明）：$[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],[z_1,z_2,z_3,z_4,z_5]]$。\n\n科学真实性和约束：\n- 确保生成元矩阵的构造方式为：当 $i \\neq j$ 时，$Q_{ij} = k_{ij}$；当 $i = j$ 时，$Q_{ii} = -\\sum_{j \\neq i} k_{ij}$。\n- 所有对数均为自然对数。\n- 所有返回的量在 $k_{\\mathrm{B}} T = 1$ 的单位制下都是无量纲的。\n- 最终输出必须严格遵循上述单行格式，数值四舍五入到6位小数。", "solution": "用户的要求是，针对一个连续时间马尔可夫跳跃过程，实现并比较其稳态熵产生率的三种不同估计量，并与解析计算的基准值进行对比。该系统是一个三态生化反应网络。此问题在科学上基于随机热力学原理，具有坚实的基础，并且在计算上是良构的，提供了所有必要的定义、参数和清晰的模拟协议。此问题被认为是有效的。\n\n解决方案将按以下结构组织：\n1.  **基准值计算**：对于每个测试用例，我们首先定义跃迁速率矩阵 $K$，其中 $K_{ij} = k_{ij}$。由此，我们根据 $i \\neq j$ 时 $Q_{ij} = K_{ij}$ 和 $Q_{ii} = -\\sum_{j \\neq i} K_{ij}$ 来构造生成元矩阵 $Q$。唯一的稳态分布 $\\boldsymbol{\\pi}$ 是 $Q$ 对应于特征值 $0$ 的归一化左特征向量，满足 $\\boldsymbol{\\pi}^\\top Q = \\boldsymbol{0}$ 和 $\\sum_i \\pi_i = 1$。这可以通过数值计算 $Q^\\top$ 的零空间来找到。一旦知道 $\\boldsymbol{\\pi}$，就可以计算稳态通量 $J_{ij} = \\pi_i k_{ij} - \\pi_j k_{ji}$，并使用以下公式计算精确的熵产生率：\n    $$\\sigma_{\\mathrm{true}} = \\frac{1}{2} \\sum_{i \\neq j} J_{ij} \\,\\ln\\!\\left(\\frac{\\pi_i k_{ij}}{\\pi_j k_{ji}}\\right)$$\n\n2.  **随机模拟**：我们将使用 Gillespie 算法为 $M$ 次独立重复实验中的每一次模拟马尔可夫跳跃过程的样本轨迹，时间范围固定为 $T$。为确保系统处于稳态，每条轨迹的初始状态通过从预先计算的真实稳态分布 $\\boldsymbol{\\pi}$ 中抽样来确定。在模拟过程中，我们将为每条轨迹记录并汇总以下可观测量：\n    -   每个状态所花费的总时间。\n    -   每对状态之间的总跃迁次数。\n    -   边 $(1 \\to 2)$ 的时间积分流 $Y_T$，即从状态1到状态2的净跳跃次数。\n    -   沿轨迹累积的总管家热 $Q_{\\mathrm{hk}}(T)$。\n\n3.  **估计量计算**：运行完所有 $M$ 次模拟后，使用汇总数据计算熵产生率的四种不同估计值。\n    -   **$\\widehat{\\sigma}_{\\mathrm{edge}}$ (基于边的经验估计量)**：我们首先根据每个状态所花费的总时间分数来估计稳态分布 $\\widehat{\\boldsymbol{\\pi}}$，并根据单位时间内的总跃迁次数来估计经验跃迁速率 $\\widehat{\\lambda}_{ij}$。然后将这些值用于一个类似于 $\\sigma_{\\mathrm{true}}$ 的公式中。\n        $$\\widehat{\\boldsymbol{\\pi}}_i = \\frac{\\text{Total time in state } i}{M T}, \\quad \\widehat{\\lambda}_{ij} = \\frac{\\text{Total transitions } i \\to j}{M T}$$\n        $$\\widehat{J}_{ij} = \\widehat{\\lambda}_{ij} - \\widehat{\\lambda}_{ji}, \\quad \\widehat{\\sigma}_{\\mathrm{edge}} = \\frac{1}{2} \\sum_{i \\neq j} \\widehat{J}_{ij} \\,\\ln\\!\\left(\\frac{k_{ij} \\widehat{\\pi}_i}{k_{ji} \\widehat{\\pi}_j}\\right)$$\n    -   **$\\widehat{\\sigma}_{\\mathrm{cycle}}$ (循环亲和势估计量)**：该估计量利用了网络的特定环形拓扑结构。熵产生是净循环通量与循环亲和势的乘积。循环通量 $\\widehat{J}_{\\mathrm{cycle}}$ 根据沿边 $(1 \\to 2)$ 的平均流 $\\overline{Y}_T$ 来估计，而亲和势 $\\mathcal{A}$ 直接从速率计算得出。\n        $$\\widehat{\\sigma}_{\\mathrm{cycle}} = \\left(\\frac{\\overline{Y}_T}{T}\\right) \\mathcal{A}, \\quad \\text{where} \\quad \\mathcal{A} = \\ln\\!\\left(\\frac{k_{12} k_{23} k_{31}}{k_{21} k_{32} k_{13}}\\right)$$\n    -   **$\\widehat{\\sigma}_{\\mathrm{hk}}$ (管家热估计量)**：根据遍历原理，单位时间的平均管家热等于熵产生率。我们通过对所有 $M$ 条轨迹的 $Q_{\\mathrm{hk}}(T)$ 进行平均来估计其期望值。\n        $$\\widehat{\\sigma}_{\\mathrm{hk}} = \\frac{\\overline{Q_{\\mathrm{hk}}(T)}}{T}$$\n    -   **$\\widehat{\\sigma}_{\\mathrm{TUR}}$ (热力学不确定性关系下界)**：TUR基于积分流的精度为熵产生提供了一个下界。我们使用流 $Y_T$ 的样本均值和样本方差来计算此下界。\n        $$\\widehat{\\sigma}_{\\mathrm{TUR}} = \\frac{2 \\left(\\overline{Y}_T\\right)^2}{T \\,\\widehat{\\mathrm{Var}}[Y_T]}$$\n        如果样本方差为零，则赋值为 $0$。\n\n该实现将处理对应于平衡、弱驱动和强驱动非平衡条件的三个测试用例。对于每个用例，它将输出五个计算量：基准值和四个估计量，格式化为六位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def get_stationary_distribution(q_matrix):\n        \"\"\"Computes the stationary distribution of a Markov jump process.\"\"\"\n        # The stationary distribution pi satisfies pi^T Q = 0.\n        # This is equivalent to finding the null space of Q^T.\n        ns = null_space(q_matrix.T)\n        if ns.shape[1] == 0:\n            raise ValueError(\"No stationary distribution found.\")\n        \n        pi_unnormalized = ns[:, 0].flatten()\n        # Probabilities must be non-negative.\n        pi_positive = np.abs(pi_unnormalized)\n        # Normalize to sum to 1.\n        return pi_positive / np.sum(pi_positive)\n\n    def calculate_ground_truth(k_matrix, pi_vector):\n        \"\"\"Calculates the exact steady-state entropy production rate.\"\"\"\n        fluxes = pi_vector[:, np.newaxis] * k_matrix - (pi_vector * k_matrix).T\n        \n        num = pi_vector[:, np.newaxis] * k_matrix\n        den = pi_vector * k_matrix.T\n\n        log_term = np.zeros_like(k_matrix)\n        mask = (num  0)  (den  0)\n        log_term[mask] = np.log(num[mask] / den[mask])\n        \n        sigma = 0.5 * np.sum(fluxes * log_term)\n        return sigma\n\n    def run_case_simulations(k_matrix, pi_true, sim_time, num_reps, seed):\n        \"\"\"Runs Gillespie simulations and computes all estimators.\"\"\"\n        q_matrix = k_matrix - np.diag(np.sum(k_matrix, axis=1))\n        rng = np.random.default_rng(seed)\n\n        Y_T_reps = np.zeros(num_reps)\n        Q_hk_reps = np.zeros(num_reps)\n        total_time_in_state = np.zeros(3)\n        total_transition_counts = np.zeros((3, 3))\n        \n        log_ratios_hk = np.zeros_like(k_matrix)\n        num_hk = pi_true[:, np.newaxis] * k_matrix\n        den_hk = pi_true * k_matrix.T\n        mask_hk = (num_hk  0)  (den_hk  0)\n        log_ratios_hk[mask_hk] = np.log(num_hk[mask_hk] / den_hk[mask_hk])\n\n        for i_rep in range(num_reps):\n            t = 0.0\n            current_state = rng.choice(3, p=pi_true)\n            \n            while t  sim_time:\n                rates_out = k_matrix[current_state, :]\n                total_rate = np.sum(rates_out)\n                \n                if total_rate = 0:\n                    total_time_in_state[current_state] += sim_time - t\n                    break\n\n                dt = rng.exponential(1.0 / total_rate)\n                \n                if t + dt = sim_time:\n                    total_time_in_state[current_state] += sim_time - t\n                    break\n                \n                total_time_in_state[current_state] += dt\n                t += dt\n\n                probs = rates_out / total_rate\n                next_state = rng.choice(3, p=probs)\n                \n                if current_state == 0 and next_state == 1:\n                    Y_T_reps[i_rep] += 1\n                elif current_state == 1 and next_state == 0:\n                    Y_T_reps[i_rep] -= 1\n                \n                Q_hk_reps[i_rep] += log_ratios_hk[current_state, next_state]\n                total_transition_counts[current_state, next_state] += 1\n                current_state = next_state\n        \n        # Housekeeping heat estimator\n        sigma_hk = np.mean(Q_hk_reps) / sim_time\n        \n        # Cycle-affinity estimator\n        den_cycle = k_matrix[1, 0] * k_matrix[2, 1] * k_matrix[0, 2]\n        affinity = 0.0\n        if den_cycle  0:\n            affinity = np.log((k_matrix[0, 1] * k_matrix[1, 2] * k_matrix[2, 0]) / den_cycle)\n        \n        mean_Y_T = np.mean(Y_T_reps)\n        J_cycle = mean_Y_T / sim_time\n        sigma_cycle = J_cycle * affinity\n        \n        # TUR lower bound estimator\n        var_Y_T = np.var(Y_T_reps, ddof=1)\n        sigma_tur = 0.0\n        if var_Y_T  1e-12:\n            sigma_tur = (2 * mean_Y_T**2) / (sim_time * var_Y_T)\n            \n        # Edge-empirical estimator\n        total_simulation_time = num_reps * sim_time\n        hat_pi = total_time_in_state / total_simulation_time\n        hat_lambda = total_transition_counts / total_simulation_time\n        hat_J = hat_lambda - hat_lambda.T\n\n        log_term_edge = np.zeros_like(k_matrix)\n        num_edge = k_matrix * hat_pi[:, np.newaxis]\n        den_edge = k_matrix.T * hat_pi\n        mask_edge = (num_edge  1e-15)  (den_edge  1e-15)\n        log_term_edge[mask_edge] = np.log(num_edge[mask_edge] / den_edge[mask_edge])\n        \n        sigma_edge = 0.5 * np.sum(hat_J * log_term_edge)\n\n        return sigma_edge, sigma_cycle, sigma_hk, sigma_tur\n\n    test_cases = [\n        {'k_f': [1.0, 1.0, 1.0], 'k_b': [1.0, 1.0, 1.0]}, # Case A\n        {'k_f': [1.0, 1.0, 1.0], 'k_b': [0.9, 0.9, 0.9]}, # Case B\n        {'k_f': [3.0, 3.0, 3.0], 'k_b': [0.3, 0.3, 0.3]}, # Case C\n    ]\n    T = 50.0\n    M = 200\n    SEED = 42\n\n    all_case_results = []\n    for params in test_cases:\n        # Map parameters to rate matrix K\n        # States 0,1,2 - problem states 1,2,3\n        # kf: k_12, k_23, k_31 - k_01, k_12, k_20\n        # kb: k_21, k_32, k_13 - k_10, k_21, k_02\n        kf = params['k_f']\n        kb = params['k_b']\n        K = np.array([\n            [0.0, kf[0], kb[2]],\n            [kb[0], 0.0, kf[1]],\n            [kf[2], kb[1], 0.0]\n        ])\n\n        Q = K - np.diag(np.sum(K, axis=1))\n        pi = get_stationary_distribution(Q)\n        \n        sigma_true = calculate_ground_truth(K, pi)\n        \n        estimators = run_case_simulations(K, pi, T, M, SEED)\n        \n        sigma_edge, sigma_cycle, sigma_hk, sigma_tur = estimators\n        \n        results = [sigma_true, sigma_edge, sigma_cycle, sigma_hk, sigma_tur]\n        all_case_results.append(results)\n\n    final_results_str_list = []\n    for results in all_case_results:\n        formatted_nums = [f\"{x:.6f}\" for x in results]\n        final_results_str_list.append(f\"[{','.join(formatted_nums)}]\")\n    \n    print(f\"[{','.join(final_results_str_list)}]\")\n\nsolve()\n```", "id": "3308568"}, {"introduction": "真实的生物过程常常涉及基于含噪测量的反馈控制，这使得涨落定理需要被推广以包含信息的作用。本项高级练习将引导你探索热力学与信息论的交叉前沿，通过模拟一个受反馈调控的基因表达模型来验证广义涨落定理 $\\langle \\exp(-\\Sigma - I) \\rangle = 1$，其中 $\\Sigma$ 是总熵产生，$I$ 是从测量中获得的信息。你将亲身体会到，理解如感知和适应等复杂生物功能，必须将能量耗散与信息获取统一在同一框架下。[@problem_id:3308600]", "problem": "您的任务是实现一个随机、反馈控制的光遗传学基因调控模型，并使用蒙特卡洛模拟计算经测量信息调整后的负总熵产生的指数的经验期望。该系统模拟一个其活动状态为二元的单基因，记为 $x \\in \\{0,1\\}$，其中 $x=0$ 表示基因关闭，$x=1$ 表示基因开启。基因状态经历连续时间马尔可夫跳跃，其跃迁速率由一个根据带噪声的荧光测量值实时计算的光遗传学控制信号 $u_t$ 调制。为方便计算，除非另有说明，本问题中所有量均视为无量纲；所有数值输出均报告为无量纲浮点数。\n\n基本和核心定义：\n\n- 基因状态 $x_t$ 作为一个时变的两状态马尔可夫跳跃过程演化，时间步长为 $\\Delta t$，其速率在光遗传驱动下满足局域细致平衡。在时间 $t$ 的跃迁速率由下式给出\n$$\nk_{01}(u_t) = k_0 \\, e^{\\beta u_t}, \\quad k_{10}(u_t) = k_0 \\, e^{-\\beta u_t},\n$$\n其中 $k_0  0$ 是一个基础速率，$\\beta  0$ 量化了光敏感度。在一个小时间步 $\\Delta t$ 内，单次跳跃 $x_t \\to x_{t+\\Delta t}$ 的概率是 $k_{x_t \\to x_{t+\\Delta t}}(u_t) \\, \\Delta t$，并且每个时间步最多只允许一次跳跃。\n\n- 荧光测量 $m_t$ 是一个实值观测值，受状态依赖均值的高斯噪声污染。令 $\\mu_0 = 0$ 和 $\\mu_1 = n_{\\mathrm{on}}$。测量模型为\n$$\np(m_t \\mid x_t = i) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma_m} \\exp\\!\\left(-\\frac{(m_t - \\mu_i)^2}{2\\sigma_m^2}\\right), \\quad i \\in \\{0,1\\},\n$$\n其中 $\\sigma_m  0$ 是测量噪声的标准差。在时间 $t$ 的边缘测量密度是混合模型\n$$\np(m_t) = p_t(x_t=0) \\, p(m_t \\mid x_t=0) + p_t(x_t=1) \\, p(m_t \\mid x_t=1),\n$$\n而瞬时逐点测量信息（源于香农理论）是\n$$\nI_t = \\ln \\frac{p(m_t \\mid x_t)}{p(m_t)}.\n$$\n\n- 光遗传学控制信号由一个线性反馈控制器计算\n$$\nu_t = \\kappa \\, (m_t - m^\\ast),\n$$\n其中控制增益为 $\\kappa$，目标荧光为 $m^\\ast$。为确保科学真实性和数值稳定性，将 $u_t$ 裁剪到区间 $[-u_{\\max}, u_{\\max}]$ 内，其中给定的 $u_{\\max}  0$。速率 $k_{01}(u_t)$ 和 $k_{10}(u_t)$ 应使用裁剪后的 $u_t$ 计算。\n\n- 与在时间 $t$ 实现的一次跳跃 $i \\to j$ 相关联的介质熵产生增量为\n$$\n\\Delta s_{\\mathrm{med}}(t) = \\ln \\frac{k_{ij}(u_t)}{k_{ji}(u_t)}.\n$$\n如果在时间间隔 $\\Delta t$ 内没有发生跳跃，则介质熵产生增量为 $0$。\n\n- 在时间 $t$ 对于一个已实现状态 $x_t$ 的系统熵定义为随机系统熵\n$$\ns_{\\mathrm{sys}}(t) = -\\ln p_t(x_t),\n$$\n其中 $p_t(x)$ 是在时间 $t$ 状态 $x$ 的系综边缘概率。整个轨迹上的总系统熵变通过对所有时间步的 $s_{\\mathrm{sys}}(t+\\Delta t)-s_{\\mathrm{sys}}(t)$ 求和来计算。为避免奇点，在计算对数时，将系综边缘概率 $p_t(x)$ 钳制在区间 $[\\varepsilon, 1-\\varepsilon]$ 内，其中 $\\varepsilon = 10^{-9}$。\n\n- 单条轨迹在 $T$ 个时间步上的总熵产生为\n$$\n\\Sigma = \\sum_{t=0}^{T-1} \\Delta s_{\\mathrm{med}}(t) + \\sum_{t=0}^{T-1} \\big[s_{\\mathrm{sys}}(t+\\Delta t) - s_{\\mathrm{sys}}(t)\\big],\n$$\n总测量信息为\n$$\nI = \\sum_{t=0}^{T-1} I_t.\n$$\n\n您的实现必须：\n\n1. 对于每个测试用例，模拟基因状态 $x_t$ 的 $N$ 条独立轨迹，时间步数为 $T$，步长为 $\\Delta t$，从一个初始系综开始，其中 $x_0$ 为 $0$ 或 $1$ 的可能性相等。在给定的测试用例中，对所有轨迹使用相同的测量模型和反馈定律。在可能的情况下，使用向量化操作以提高计算效率。\n\n2. 在每个时间步，从所有轨迹的模拟状态中计算系综边缘概率 $p_t(x=0)$ 和 $p_t(x=1)$。使用这些边缘概率来计算在时间 $t$ 每条轨迹的 $s_{\\mathrm{sys}}(t)$ 和 $I_t$，并构建混合密度 $p(m_t)$。\n\n3. 累积每条轨迹的介质熵产生增量、系统熵变和测量信息。在 $T$ 步之后，通过对 $e^{-\\Sigma - I}$ 求平均来计算 $N$ 条轨迹的经验期望\n$$\n\\left\\langle e^{-\\Sigma - I} \\right\\rangle\n$$\n\n4. 为保证数值鲁棒性，将跳跃概率 $k_{ij}(u_t) \\Delta t$ 裁剪到区间 $[0, 0.9]$ 内。\n\n5. 每个测试用例使用固定的伪随机种子，以使输出可复现。\n\n测试套件和参数：\n\n为以下四个测试用例实现上述模型，以元组 $(N, T, \\Delta t, k_0, \\beta, \\kappa, \\sigma_m, n_{\\mathrm{on}}, m^\\ast, u_{\\max}, \\text{seed})$ 的形式给出：\n\n- 用例 1 (一般工况): $(5000, 400, 0.005, 0.2, 0.7, 0.02, 3.0, 50.0, 25.0, 3.0, 1)$。\n- 用例 2 (无控制): $(5000, 400, 0.005, 0.2, 0.7, 0.0, 3.0, 50.0, 25.0, 3.0, 2)$。\n- 用例 3 (近完美测量): $(5000, 400, 0.005, 0.2, 0.7, 0.02, 1.0\\times 10^{-3}, 50.0, 25.0, 3.0, 3)$。\n- 用例 4 (强控制): $(5000, 500, 0.004, 0.2, 1.2, 0.08, 5.0, 50.0, 25.0, 3.0, 4)$。\n\n答案规格和最终输出格式：\n\n- 对于每个测试用例，您的程序必须计算单个浮点数 $\\left\\langle e^{-\\Sigma - I} \\right\\rangle$。\n- 您的程序应生成单行输出，其中包含四个结果，格式为逗号分隔的列表，并用方括号括起来，按测试用例的顺序排列，例如，“[r1,r2,r3,r4]”。\n- 所有输出均为无量纲浮点数。不要打印任何附加文本。", "solution": "所提供的问题陈述是有效的。它在科学上基于随机热力学和系统生物学的既定原理，特别是关于反馈控制系统中的涨落定理。该问题是适定的，提供了一整套产生唯一、可复现结果所需的参数、初始条件和数值约束。所有量的定义，如熵产生和测量信息，在数学上都是精确和客观的。没有内部矛盾、事实不准确或歧义。因此，我们着手构建解决方案。\n\n任务的核心是通过直接数值模拟计算系综平均 $\\left\\langle e^{-\\Sigma - I} \\right\\rangle$。这需要实现一个蒙特卡洛算法，该算法模拟一个在反馈控制下的、随机切换的单基因的 $N$ 条独立轨迹。为了计算效率，该实现采用 NumPy 的向量化操作进行设计。\n\n对于每个测试用例，总体算法流程如下：\n$1$.  **初始化**：创建一个包含 $N$ 条轨迹的系综。状态 $x$ 初始化为一个长度为 $N$ 的向量，其中状态 $0$ 和 $1$ 的数量相等，以满足初始条件 $p_0(x=0) = p_0(x=1) = 0.5$。为了可复现性，设置伪随机数生成器的种子。总累积介质熵产生 $\\Sigma_{\\mathrm{med}}$ 和总测量信息 $I$ 初始化为大小为 $N$ 的零向量。计算并存储每条轨迹的初始系统熵 $s_{\\mathrm{sys}}(0) = -\\ln(0.5)$。\n$2$.  **时间演化**：系统以大小为 $\\Delta t$ 的离散时间步演化 $T$ 步。在每个时间步 $t$，以向量化的方式对所有 $N$ 条轨迹执行以下计算序列。\n$3$.  **最终计算**：在最后一个时间步 $T$ 之后，计算每条轨迹的总熵产生 $\\Sigma$，并计算最终的期望值。\n\n在每个从 $t$ 到 $t+\\Delta t$ 的时间间隔内的详细步骤是：\n\na. **系综与测量**：通过对所有 $N$ 个当前状态求平均，计算系综边缘概率 $p_t(x=1) = \\frac{1}{N}\\sum_k x_{k,t}$ 和 $p_t(x=0) = 1 - p_t(x=1)$。对于每条轨迹，从相应的高斯分布中抽取一个带噪声的测量值 $m_t$：$m_t \\sim \\mathcal{N}(\\mu_{x_t}, \\sigma_m^2)$，其中 $\\mu_0 = 0$ 和 $\\mu_1 = n_{\\mathrm{on}}$。\n\nb. **反馈控制**：使用线性反馈律 $u_t = \\kappa(m_t - m^\\ast)$ 计算每条轨迹的控制信号 $u_t$。然后将此信号裁剪到指定范围 $[-u_{\\max}, u_{\\max}]$ 内。\n\nc. **信息增益**：计算每条轨迹的逐点测量信息 $I_t$。这需要计算三个概率密度：给定状态 $0$ 的测量似然 $p(m_t|x_t=0)$；给定状态 $1$ 的测量似然 $p(m_t|x_t=1)$；以及测量的边缘概率 $p(m_t) = p_t(x=0)p(m_t|x_t=0) + p_t(x=1)p(m_t|x_t=1)$。对于状态为 $x_t$ 的轨迹，其信息为 $I_t = \\ln \\frac{p(m_t|x_t)}{p(m_t)}$。该值被加到每条轨迹的运行总和 $I$ 中。\n\nd. **随机状态跃迁**：使用裁剪后的控制信号 $u_t$ 来确定跃迁速率 $k_{01}(u_t) = k_0 e^{\\beta u_t}$ 和 $k_{10}(u_t) = k_0 e^{-\\beta u_t}$。计算时间间隔 $\\Delta t$ 内相应的跳跃概率 $P_{01} = k_{01}(u_t)\\Delta t$ 和 $P_{10} = k_{10}(u_t)\\Delta t$，并将其裁剪到区间 $[0, 0.9]$ 内。对于每条轨迹，抽取一个均匀随机数 $r \\in [0,1)$。如果当前状态为 $0$ 且 $r  P_{01}$，则发生状态跃迁 $0 \\to 1$。如果状态为 $1$ 且 $r  P_{10}$，则发生状态跃迁 $1 \\to 0$。\n\ne. **介质熵产生**：如果一条轨迹从状态 $i$ 跳跃到状态 $j$ ($i \\neq j$)，则产生介质熵产生增量 $\\Delta s_{\\mathrm{med}}(t) = \\ln \\frac{k_{ij}(u_t)}{k_{ji}(u_t)}$。对于 $0 \\to 1$ 的跳跃，这简化为 $\\Delta s_{\\mathrm{med}}(t) = 2\\beta u_t$；对于 $1 \\to 0$ 的跳跃，简化为 $\\Delta s_{\\mathrm{med}}(t) = -2\\beta u_t$。此增量被加到相应轨迹的运行总和 $\\Sigma_{\\mathrm{med}}$ 中。如果没有发生跳跃，则 $\\Delta s_{\\mathrm{med}}(t) = 0$。\n\n在 $T$ 个时间步的循环完成后，执行最终计算：\n\nf. **总熵产生**：从最终状态 $\\{x_T\\}$ 计算最终的系综边缘概率 $p_T(x)$。每条轨迹的最终系统熵为 $s_{\\mathrm{sys}}(T) = -\\ln p_T(x_T)$，其中在取对数之前，概率 $p_T(x_T)$ 被钳制在 $[\\varepsilon, 1-\\varepsilon]$ 区间内，$\\varepsilon = 10^{-9}$。每条轨迹的总系统熵变为 $\\Delta S_{\\mathrm{sys}} = s_{\\mathrm{sys}}(T) - s_{\\mathrm{sys}}(0)$。总熵产生则为 $\\Sigma = \\Sigma_{\\mathrm{med}} + \\Delta S_{\\mathrm{sys}}$。\n\ng. **期望值**：计算每条轨迹的目标量 $e^{-\\Sigma - I}$。最终结果是该量的经验期望，通过在所有 $N$ 条轨迹上求平均得到：$\\left\\langle e^{-\\Sigma - I} \\right\\rangle = \\frac{1}{N} \\sum_{k=1}^N e^{-\\Sigma_k - I_k}$。对测试套件中提供的每组参数重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, T, delta_t, k0, beta, kappa, sigma_m, n_on, m_star, u_max, seed)\n        (5000, 400, 0.005, 0.2, 0.7, 0.02, 3.0, 50.0, 25.0, 3.0, 1),\n        (5000, 400, 0.005, 0.2, 0.7, 0.0, 3.0, 50.0, 25.0, 3.0, 2),\n        (5000, 400, 0.005, 0.2, 0.7, 0.02, 1.0e-3, 50.0, 25.0, 3.0, 3),\n        (5000, 500, 0.004, 0.2, 1.2, 0.08, 5.0, 50.0, 25.0, 3.0, 4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, T, dt, k0, beta, kappa, sigma_m, n_on, m_star, u_max, seed):\n    \"\"\"\n    Performs a single Monte Carlo simulation for a given set of parameters.\n    \"\"\"\n    # Epsilon for clamping probabilities in system entropy calculation\n    epsilon = 1e-9\n    rng = np.random.default_rng(seed)\n\n    # --- 1. Initialization ---\n    # Initial state vector x, with 50/50 distribution of 0s and 1s\n    x = np.zeros(N, dtype=np.int8)\n    x[N // 2:] = 1\n    rng.shuffle(x)\n\n    # Initialize accumulators for each trajectory\n    Sigma_med_total = np.zeros(N, dtype=np.float64)\n    I_total = np.zeros(N, dtype=np.float64)\n\n    # Initial system entropy calculation\n    # p0(x=0) and p0(x=1) are both 0.5. s_sys(0) is the same for all trajectories.\n    s_sys_0 = -np.log(0.5)\n\n    # --- 2. Time-stepping loop ---\n    for _ in range(T):\n        # a. Ensemble marginals\n        p1 = np.mean(x)\n        p0 = 1.0 - p1\n\n        # b. Generate measurements m_t\n        mu = np.where(x == 1, n_on, 0.0)\n        m = rng.normal(loc=mu, scale=sigma_m)\n        \n        # c. Feedback Control: Calculate and clip control signal u_t\n        u = kappa * (m - m_star)\n        u_clipped = np.clip(u, -u_max, u_max)\n\n        # d. Information Gain I_t\n        p_m_given_x0 = norm.pdf(m, loc=0.0, scale=sigma_m)\n        p_m_given_x1 = norm.pdf(m, loc=n_on, scale=sigma_m)\n        \n        p_m_marginal = p0 * p_m_given_x0 + p1 * p_m_given_x1\n        p_m_given_x_traj = np.where(x == 1, p_m_given_x1, p_m_given_x0)\n        \n        # Prevent log(0) from numerical underflow by flooring a small positive number.\n        tiny = np.finfo(np.float64).tiny\n        safe_p_m_given_x_traj = np.maximum(p_m_given_x_traj, tiny)\n        safe_p_m_marginal = np.maximum(p_m_marginal, tiny)\n        \n        I_t = np.log(safe_p_m_given_x_traj / safe_p_m_marginal)\n        I_total += I_t\n\n        # e. Stochastic State Transition: Calculate rates and probabilities\n        k01 = k0 * np.exp(beta * u_clipped)\n        k10 = k0 * np.exp(-beta * u_clipped)\n        \n        p_jump_01 = np.clip(k01 * dt, 0.0, 0.9)\n        p_jump_10 = np.clip(k10 * dt, 0.0, 0.9)\n\n        # f. Simulate state jumps\n        r = rng.random(size=N)\n        jump_to_1 = (x == 0)  (r  p_jump_01)\n        jump_to_0 = (x == 1)  (r  p_jump_10)\n\n        # g. Medium Entropy Production\n        delta_s_med = np.zeros(N, dtype=np.float64)\n        delta_s_med[jump_to_1] = 2 * beta * u_clipped[jump_to_1]\n        delta_s_med[jump_to_0] = -2 * beta * u_clipped[jump_to_0]\n        Sigma_med_total += delta_s_med\n\n        # h. Update state vector\n        x[jump_to_1] = 1\n        x[jump_to_0] = 0\n\n    # --- 3. Final Calculation ---\n    # a. Total system entropy change\n    p1_final = np.mean(x)\n    p0_final = 1.0 - p1_final\n    \n    p_final_traj = np.where(x == 1, p1_final, p0_final)\n    p_final_traj_clamped = np.clip(p_final_traj, epsilon, 1.0 - epsilon)\n    s_sys_T = -np.log(p_final_traj_clamped)\n    \n    Delta_s_sys_total = s_sys_T - s_sys_0\n\n    # b. Total entropy production Sigma\n    Sigma_total = Sigma_med_total + Delta_s_sys_total\n\n    # c. Compute the final expectation value\n    final_quantity_per_traj = np.exp(-Sigma_total - I_total)\n    result = np.mean(final_quantity_per_traj)\n\n    return result\n\nsolve()\n```", "id": "3308600"}]}