{"hands_on_practices": [{"introduction": "在分析空间转录组学数据时，首要任务是理解每个空间位置上 UMI 计数的统计特性。此练习将引导您探索泊松分布和负二项分布，这两种模型是描述计数数据的基石。通过在不同的模型假设下推导期望和方差，您将深入理解“过离散”（overdispersion）这一关键概念，这是真实测序数据中普遍存在的现象，它直接影响后续统计方法的选择 [@problem_id:3350175]。", "problem": "考虑一项基于斑点的空间转录组学检测，该检测测量组织切片上的唯一分子标识符（UMI）。假设组织具有均匀的细胞密度 $\\lambda$（单位面积内的细胞数），并且每个斑点的面积为 $A$。设每个斑点的细胞数由空间泊松点过程建模，因此斑点水平的细胞计数 $N$ 满足 $\\mathbb{E}[N]=\\lambda A$。在每个细胞内，转录分子的数量被建模为一个均值为 $\\mu$ 的独立泊松随机变量，并且每个转录分子以概率 $\\eta$（捕获效率）被独立捕获，从而每个细胞的期望捕获计数为 $\\eta \\mu$。令 $Y$ 表示每个斑点捕获的 UMI 总数。\n\n(a) 仅使用期望的线性性和捕获过程的独立性，根据上述假设推导 $\\mathbb{E}[Y]$。\n\n(b) 在 $Y$ 服从泊松分布，其均值等于 (a) 部分推导出的期望值的建模假设下，计算 $\\operatorname{Var}(Y)$。\n\n(c) 现在通过伽马-泊松混合引入斑点水平的异质性：设潜在的捕获前斑点水平转录强度为 $\\Lambda \\sim \\mathrm{Gamma}(\\kappa,\\theta)$，其中形状参数 $\\kappa0$，尺度参数 $\\theta$ 的选择使得 $\\mathbb{E}[\\Lambda]=\\lambda A \\mu$。在给定 $\\Lambda$ 的条件下，假设 $Y \\mid \\Lambda \\sim \\mathrm{Poisson}(\\eta \\Lambda)$。使用全期望定律和全方差定律，计算在此伽马-泊松混合模型下的 $\\mathbb{E}[Y]$ 和 $\\operatorname{Var}(Y)$。用 $\\eta$、$\\lambda$、$A$、$\\mu$ 和 $\\kappa$ 的符号表示您的最终答案。\n\n将最终答案以单行向量的形式给出，按顺序包含：均值 $\\mathbb{E}[Y]$、泊松假设下的方差以及伽马-泊松（负二项）假设下的方差。无需四舍五入，最终表达式中不应包含任何物理单位。", "solution": "用户提供的问题经评估有效。该问题具有科学依据，提法明确，客观且内部一致，是计算系统生物学中统计建模的标准练习。因此，我们可以进行完整解答。\n\n问题分为三个部分。我们将依次解决每个部分，以找到最终答案所需的量。所需的量是每个斑点的总 UMI 计数的期望值 $\\mathbb{E}[Y]$、简单泊松假设下的 $Y$ 的方差，以及更复杂的伽马-泊松混合模型下的 $Y$ 的方差。\n\n(a) 使用期望的线性推导 $\\mathbb{E}[Y]$。\n\n令 $N$ 为一个斑点中的细胞数。我们已知 $N$ 服从空间泊松点过程，其期望为 $\\mathbb{E}[N] = \\lambda A$，其中 $\\lambda$ 是细胞密度，$A$ 是斑点面积。\n令 $X_i$ 为从细胞 $i$ 捕获的 UMI 数量，其中 $i = 1, \\dots, N$。\n每个斑点捕获的 UMI 总数 $Y$ 是该斑点中所有细胞计数之和：\n$$Y = \\sum_{i=1}^{N} X_i$$\n这是一个随机数量的随机变量之和。我们可以使用全期望定律（在此情境下也称为瓦尔德恒等式）来求其期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[\\mathbb{E}[Y \\mid N]]$$\n首先，我们求在给定细胞数 $N$ 的情况下 $Y$ 的条件期望。对于固定的细胞数 $N=n$，$Y = \\sum_{i=1}^{n} X_i$。根据期望的线性：\n$$\\mathbb{E}[Y \\mid N=n] = \\mathbb{E}\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} \\mathbb{E}[X_i]$$\n我们需要确定 $\\mathbb{E}[X_i]$。问题陈述，细胞中转录分子的数量是一个均值为 $\\mu$ 的泊松随机变量。然后，每个分子以独立的概率 $\\eta$ 被捕获。这个过程被称为泊松分布的稀疏化。如果一个随机变量 $K \\sim \\mathrm{Poisson}(\\mu)$，并且 $K$ 个项目中的每一个都以概率 $\\eta$ 被保留，那么得到的保留项目计数 $X_i$ 服从均值为 $\\eta\\mu$ 的泊松分布。\n因此，每个细胞捕获的 UMI 的期望数量是 $\\mathbb{E}[X_i] = \\eta\\mu$。\n由于每个细胞的过程都相同，所有 $X_i$ 都是独立同分布的。所以：\n$$\\mathbb{E}[Y \\mid N=n] = \\sum_{i=1}^{n} (\\eta\\mu) = n\\eta\\mu$$\n这表明条件期望 $\\mathbb{E}[Y \\mid N]$ 是随机变量 $N\\eta\\mu$。\n现在，我们对 $N$ 取期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[N\\eta\\mu]$$\n再次使用期望的线性：\n$$\\mathbb{E}[Y] = \\eta\\mu \\mathbb{E}[N]$$\n代入给定的 $\\mathbb{E}[N] = \\lambda A$：\n$$\\mathbb{E}[Y] = \\lambda A \\eta \\mu$$\n\n(b) 在简单泊松模型下计算 $\\operatorname{Var}(Y)$。\n\n对于这部分，我们被要求假设总 UMI 计数 $Y$ 服从泊松分布，其均值等于 (a) 部分推导出的期望。令此泊松分布的参数为 $\\nu = \\mathbb{E}[Y]$。从 (a) 部分我们得到：\n$$\\nu = \\lambda A \\eta \\mu$$\n所以，我们假设 $Y \\sim \\mathrm{Poisson}(\\nu) = \\mathrm{Poisson}(\\lambda A \\eta \\mu)$。\n泊松分布的一个基本性质是其方差等于其均值。\n因此，在此假设下 $Y$ 的方差是：\n$$\\operatorname{Var}(Y) = \\nu = \\lambda A \\eta \\mu$$\n\n(c) 在伽马-泊松混合模型下计算 $\\mathbb{E}[Y]$ 和 $\\operatorname{Var}(Y)$。\n\n在这个模型中，总 UMI 计数 $Y$ 是分层建模的。首先，一个潜在变量 $\\Lambda$，代表斑点中捕获前的总转录强度，从伽马分布中抽取：\n$$\\Lambda \\sim \\mathrm{Gamma}(\\kappa, \\theta)$$\n其中 $\\kappa  0$ 是形状参数，$\\theta$ 是尺度参数。\n尺度参数 $\\theta$ 由对 $\\Lambda$ 的期望的约束指定：\n$$\\mathbb{E}[\\Lambda] = \\lambda A \\mu$$\n一个 $\\mathrm{Gamma}(\\kappa, \\theta)$ 分布的期望是 $\\mathbb{E}[\\Lambda] = \\kappa\\theta$。将其与约束相等可得：\n$$\\kappa\\theta = \\lambda A \\mu \\implies \\theta = \\frac{\\lambda A \\mu}{\\kappa}$$\n在给定此潜在强度 $\\Lambda$ 的条件下，观测到的 UMI 计数 $Y$ 服从均值为 $\\eta\\Lambda$ 的泊松分布：\n$$Y \\mid \\Lambda \\sim \\mathrm{Poisson}(\\eta\\Lambda)$$\n这种分层结构是一个伽马-泊松混合，导致 $Y$ 服从负二项分布。我们被要求使用全期望定律和全方差定律来计算 $\\mathbb{E}[Y]$ 和 $\\operatorname{Var}(Y)$。\n\n首先，是 $Y$ 的期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[\\mathbb{E}[Y \\mid \\Lambda]]$$\n内部的期望是条件泊松分布的均值：\n$$\\mathbb{E}[Y \\mid \\Lambda] = \\eta\\Lambda$$\n现在，对 $\\Lambda$ 取期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[\\eta\\Lambda] = \\eta\\mathbb{E}[\\Lambda]$$\n使用给定的约束 $\\mathbb{E}[\\Lambda] = \\lambda A \\mu$：\n$$\\mathbb{E}[Y] = \\eta(\\lambda A \\mu) = \\lambda A \\eta \\mu$$\n这个结果与 (a) 部分得到的结果一致。\n\n接下来，是 $Y$ 的方差：\n全方差定律表明：\n$$\\operatorname{Var}(Y) = \\mathbb{E}[\\operatorname{Var}(Y \\mid \\Lambda)] + \\operatorname{Var}(\\mathbb{E}[Y \\mid \\Lambda])$$\n我们分别计算每一项。\n第一项是期望的条件方差。条件泊松分布 $Y \\mid \\Lambda \\sim \\mathrm{Poisson}(\\eta\\Lambda)$ 的方差等于其均值：\n$$\\operatorname{Var}(Y \\mid \\Lambda) = \\eta\\Lambda$$\n对此量关于 $\\Lambda$ 取期望：\n$$\\mathbb{E}[\\operatorname{Var}(Y \\mid \\Lambda)] = \\mathbb{E}[\\eta\\Lambda] = \\eta\\mathbb{E}[\\Lambda] = \\eta(\\lambda A \\mu) = \\lambda A \\eta \\mu$$\n第二项是条件期望的方差。我们已经找到了条件期望：\n$$\\mathbb{E}[Y \\mid \\Lambda] = \\eta\\Lambda$$\n此量的方差是：\n$$\\operatorname{Var}(\\mathbb{E}[Y \\mid \\Lambda]) = \\operatorname{Var}(\\eta\\Lambda) = \\eta^2 \\operatorname{Var}(\\Lambda)$$\n我们需要 $\\operatorname{Var}(\\Lambda)$。对于一个 $\\mathrm{Gamma}(\\kappa, \\theta)$ 分布，方差是 $\\operatorname{Var}(\\Lambda) = \\kappa\\theta^2$。代入 $\\theta = \\frac{\\lambda A \\mu}{\\kappa}$：\n$$\\operatorname{Var}(\\Lambda) = \\kappa \\left(\\frac{\\lambda A \\mu}{\\kappa}\\right)^2 = \\kappa \\frac{(\\lambda A \\mu)^2}{\\kappa^2} = \\frac{(\\lambda A \\mu)^2}{\\kappa}$$\n因此，第二项是：\n$$\\operatorname{Var}(\\mathbb{E}[Y \\mid \\Lambda]) = \\eta^2 \\left(\\frac{(\\lambda A \\mu)^2}{\\kappa}\\right) = \\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$$\n最后，我们将两项相加得到总方差：\n$$\\operatorname{Var}(Y) = \\lambda A \\eta \\mu + \\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$$\n这个表达式表明，在伽马-泊松模型下，方差大于均值（$\\lambda A \\eta \\mu$），这一现象被称为过度离散。项 $\\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$ 量化了这部分额外的方差。\n\n结果总结：\n1.  $Y$ 的均值：$\\mathbb{E}[Y] = \\lambda A \\eta \\mu$。\n2.  泊松假设下 $Y$ 的方差：$\\operatorname{Var}(Y) = \\lambda A \\eta \\mu$。\n3.  伽马-泊松假设下 $Y$ 的方差：$\\operatorname{Var}(Y) = \\lambda A \\eta \\mu + \\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$。\n\n这三个表达式将构成最终的行向量。", "answer": "$$\\boxed{\\begin{pmatrix} \\lambda A \\eta \\mu  \\lambda A \\eta \\mu  \\lambda A \\eta \\mu + \\frac{\\eta^{2} (\\lambda A \\mu)^{2}}{\\kappa} \\end{pmatrix}}$$", "id": "3350175"}, {"introduction": "要识别基因表达的空间模式，我们必须首先将观测点之间的空间邻近关系进行数学化描述。本练习介绍了一种核心方法：将空间位置抽象为图的节点，并用加权边来表示它们之间的邻近程度。通过亲手构建图拉普拉斯矩阵 (graph Laplacian matrix)，您将掌握一种在谱图论中至关重要的计算工具，它构成了许多高级空间分析算法（如空间聚类和空间可变基因识别）的基础 [@problem_id:3350213]。", "problem": "考虑一个空间转录组学场景，其中空间点在二维平面中表示，邻近点之间的关系被建模为无向加权图。对于一个有 $n$ 个节点（标记为 $\\{0,1,\\dots,n-1\\}$）的图，设 $W \\in \\mathbb{R}^{n \\times n}$ 是一个对称加权邻接矩阵，其元素 $w_{ij}$ 满足对所有 $i$ 都有 $w_{ii} = 0$。对于一组指定的无向邻居对 $\\mathcal{E} \\subset \\{(i,j) \\mid i \\neq j\\}$ 以及每个节点的坐标 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$，定义欧几里得距离 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。对于 $(i,j) \\in \\mathcal{E}$，权重由径向基函数 $w_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma^2}\\right)$ 定义，否则设置 $w_{ij} = 0$。设 $D \\in \\mathbb{R}^{n \\times n}$ 为对角度矩阵，其元素为 $D_{ii} = \\sum_{j=0}^{n-1} w_{ij}$。定义未归一化图拉普拉斯算子 $L = D - W$。定义对称归一化拉普拉斯算子 $L_{\\text{sym}} = I - D^{-1/2} W D^{-1/2}$，其中 $I$ 是 $n \\times n$ 单位矩阵，且 $D^{-1/2}$ 的定义为若 $d_i = D_{ii}  0$，则 $(D^{-1/2})_{ii} = d_i^{-1/2}$；若 $d_i = 0$，则 $(D^{-1/2})_{ii} = 0$。\n\n根据加权图和网络扩散的基本原理，$L$ 和 $L_{\\text{sym}}$ 的谱特性包括所有特征值的非负性，以及对于 $L_{\\text{sym}}$，特征值上限为 $2$。$L$ 和 $L_{\\text{sym}}$ 的零特征值的重数等于图的连通分量数。$L$ 的特征值之和等于 $\\operatorname{trace}(L)$。\n\n您的任务是实现一个完整的程序，该程序：\n- 对于 $(i,j) \\in \\mathcal{E}$，使用 $w_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma^2}\\right)$ 构建 $W$，并满足 $w_{ij} = w_{ji}$ 和 $w_{ii} = 0$。\n- 计算 $D$、$L = D - W$ 和 $L_{\\text{sym}} = I - D^{-1/2} W D^{-1/2}$，其中 $D^{-1/2}$ 在 $D_{ii} = 0$ 时遵循所述约定。\n- 计算 $L$ 和 $L_{\\text{sym}}$ 的完整特征值谱。\n- 对每个测试用例验证以下内容：\n  1. $L$ 谱的非负性：$L$ 的所有特征值 $\\lambda$ 在数值容差 $\\varepsilon = 10^{-8}$ 内满足 $\\lambda \\geq 0$。\n  2. $L_{\\text{sym}}$ 谱的非负性：$L_{\\text{sym}}$ 的所有特征值 $\\lambda$ 在容差 $\\varepsilon$ 内满足 $\\lambda \\geq 0$。\n  3. $L_{\\text{sym}}$ 谱的上限：$L_{\\text{sym}}$ 的最大特征值 $\\lambda_{\\max}$ 在容差 $\\varepsilon$ 内满足 $\\lambda_{\\max} \\leq 2$。\n  4. $L$ 的零特征值重数：在容差 $\\varepsilon$ 内，$L$ 的特征值等于 $0$ 的数量（这是一个需要报告的整数输出）。\n  5. $L_{\\text{sym}}$ 的零特征值重数：在容差 $\\varepsilon$ 内，$L_{\\text{sym}}$ 的特征值等于 $0$ 的数量（这是一个需要报告的整数输出）。\n  6. $L$ 的迹-特征值相等性：验证 $\\left|\\sum_{i=1}^{n} \\lambda_i(L) - \\operatorname{trace}(L)\\right| \\leq \\varepsilon$ 是否成立，并相应地输出一个布尔值。\n\n使用以下测试套件。对于每个用例，都指定了坐标、邻居对 $\\mathcal{E}$ 和 $\\sigma$。必须根据坐标为 $\\mathcal{E}$ 中的每一对计算距离 $d_{ij}$。\n\n测试用例 1（连通链；理想情况）：\n- $n = 4$\n- 坐标：$(0,0)$, $(1,0)$, $(2,0)$, $(3,0)$\n- 邻居对 $\\mathcal{E}$：$(0,1)$, $(1,2)$, $(2,3)$\n- $\\sigma = 1.0$\n\n测试用例 2（两个不连通的分量）：\n- $n = 6$\n- 坐标：$(0,0)$, $(1,0)$, $(2,0)$, $(10,0)$, $(11,0)$, $(12,0)$\n- 邻居对 $\\mathcal{E}$：$(0,1)$, $(1,2)$, $(3,4)$, $(4,5)$\n- $\\sigma = 0.5$\n\n测试用例 3（三角形加孤立节点；零度处理）：\n- $n = 4$\n- 坐标：$(0,0)$, $(1,0)$, $(0,1)$, $(5,5)$\n- 邻居对 $\\mathcal{E}$：$(0,1)$, $(0,2)$, $(1,2)$\n- $\\sigma = 2.0$\n\n测试用例 4（$2 \\times 2$ 网格；大平滑尺度）：\n- $n = 4$\n- 坐标：$(0,0)$, $(0,1)$, $(1,0)$, $(1,1)$\n- 邻居对 $\\mathcal{E}$：$(0,1)$, $(0,2)$, $(1,3)$, $(2,3)$\n- $\\sigma = 10.0$\n\n数值容差为 $\\varepsilon = 10^{-8}$。本问题不涉及角度，也没有物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的串联结果，形式为逗号分隔的列表，并用方括号括起来。\n- 对于每个测试用例，按此顺序将以下六个值附加到输出列表中：\n  1. $z_L$：在容差 $\\varepsilon$ 内，$L$ 的特征值等于 $0$ 的整数计数。\n  2. $z_{L_{\\text{sym}}}$：在容差 $\\varepsilon$ 内，$L_{\\text{sym}}$ 的特征值等于 $0$ 的整数计数。\n  3. $b_{L,\\text{nonneg}}$：一个布尔值，指示 $L$ 的所有特征值是否在容差内 $\\geq 0$。\n  4. $b_{L_{\\text{sym}},\\text{nonneg}}$：一个布尔值，指示 $L_{\\text{sym}}$ 的所有特征值是否在容差内 $\\geq 0$。\n  5. $b_{L_{\\text{sym}},\\max \\le 2}$：一个布尔值，指示 $\\max \\lambda(L_{\\text{sym}})$ 是否在容差内 $\\leq 2$。\n  6. $b_{\\text{trace-eigs}}$：一个布尔值，指示 $\\left|\\sum_{i=1}^{n} \\lambda_i(L) - \\operatorname{trace}(L)\\right| \\leq \\varepsilon$ 是否成立。\n- 因此，对于 $4$ 个测试用例，输出列表必须总共包含 $24$ 个条目，按测试用例 1 到 4 的顺序排列。\n\n您的程序必须明确实现所有计算，并产生上述单行输出。", "solution": "该问题要求实现一个算法，以构建和分析源自空间数据的图拉普拉斯矩阵，这是计算系统生物学中分析空间转录组学数据集的一项常见任务。该解决方案涉及构建两种类型的图拉普拉斯算子，即未归一化的拉普拉斯算子 $L$ 和对称归一化的拉普拉斯算子 $L_{\\text{sym}}$，计算它们的特征值谱，并根据谱图理论的既定定理验证这些谱的几个基本性质。\n\n对几个测试用例执行该过程，每个测试用例由一组具有二维坐标 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$ 的节点、一组邻居对 $\\mathcal{E}$ 和一个长度尺度参数 $\\sigma$ 定义。\n\n**步骤 1：构建加权邻接矩阵 $W$**\n\n图由一个 $n \\times n$ 的加权邻接矩阵 $W$ 表示。该矩阵的元素 $w_{ij}$ 量化了节点 $i$ 和 $j$ 之间连接的强度。\n- 该图是无向的，因此 $W$ 是对称的，即 $w_{ij} = w_{ji}$。\n- 按照惯例，没有自环，因此对角线元素为零：对于所有 $i \\in \\{0, \\dots, n-1\\}$，$w_{ii} = 0$。\n- 对于邻居集合 $\\mathcal{E}$ 中指定的节点对 $(i,j)$，权重 $w_{ij}$ 使用径向基函数（高斯核）计算，该函数取决于节点间的欧几里得距离 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$：\n$$ w_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma^2}\\right) $$\n此函数确保较近的节点具有更强的连接（更大的权重），参数 $\\sigma$ 控制影响的空间尺度。\n- 如果一对节点 $(i,j)$ 不在 $\\mathcal{E}$ 中，则它们之间没有直接的边，其权重设置为零：$w_{ij} = 0$。\n\n**步骤 2：构建图拉普拉斯算子 $L$ 和 $L_{\\text{sym}}$**\n\n从邻接矩阵 $W$ 推导出两个拉普拉斯矩阵。\n\n- **度矩阵 $D$**：首先，我们定义度矩阵 $D$，它是一个对角矩阵。每个对角元素 $D_{ii}$ 是节点 $i$ 的度，定义为连接到它的所有边的权重之和：\n$$ D_{ii} = d_i = \\sum_{j=0}^{n-1} w_{ij} $$\n- **未归一化图拉普拉斯算子 $L$**：该拉普拉斯算子定义为度矩阵和邻接矩阵之差：\n$$ L = D - W $$\n由于 $D$ 是对角的而 $W$ 是对称的，矩阵 $L$ 保证是实对称矩阵。\n\n- **对称归一化图拉普拉斯算子 $L_{\\text{sym}}$**：该拉普拉斯算子是 $L$ 的一个归一化版本，它考虑了节点度的差异。其定义为：\n$$ L_{\\text{sym}} = I - D^{-1/2} W D^{-1/2} $$\n其中 $I$ 是 $n \\times n$ 单位矩阵。矩阵 $D^{-1/2}$ 是一个对角矩阵，其元素由以下公式给出：\n$$ (D^{-1/2})_{ii} = \\begin{cases} d_i^{-1/2}  \\text{若 } d_i  0 \\\\ 0  \\text{若 } d_i = 0 \\end{cases} $$\n对度为零（$d_i=0$）的节点进行这种特殊处理至关重要。这些是孤立节点，此定义确保它们在数学框架中得到妥善处理，有效地将它们解耦，并得到一个良定义的 $L_{\\text{sym}}$。与 $L$ 一样，$L_{\\text{sym}}$ 也是实对称矩阵。\n\n**步骤 3：谱分析与性质验证**\n\n任务的核心是计算 $L$ 和 $L_{\\text{sym}}$ 的特征值，并验证它们的理论性质。由于这两个矩阵都是实对称的，它们的特征值都是实数。`numpy.linalg.eigh` 函数非常适合此任务，因为它针对厄米特（实对称）矩阵进行了优化，并保证了实值结果。设 $\\lambda_k(M)$ 表示矩阵 $M$ 的第 $k$ 个特征值。使用数值容差 $\\varepsilon = 10^{-8}$，对每个测试用例验证以下六个性质。\n\n1.  **$L$ 的零特征值重数 ($z_L$)**：计算满足 $|\\lambda_k(L)| \\leq \\varepsilon$ 的特征值 $\\lambda_k(L)$ 的数量。\n2.  **$L_{\\text{sym}}$ 的零特征值重数 ($z_{L_{\\text{sym}}}$)**：计算满足 $|\\lambda_k(L_{\\text{sym}})| \\leq \\varepsilon$ 的特征值 $\\lambda_k(L_{\\text{sym}})$ 的数量。\n    - *理论原理*：谱图理论的一个基本定理指出，对于 $L$ 和 $L_{\\text{sym}}$，特征值 $0$ 的重数等于图中连通分量的数量。因此，这两个输出预期是对应于此计数的整数。\n3.  **$L$ 谱的非负性 ($b_{L,\\text{nonneg}}$)**：此布尔检查验证 $L$ 的所有特征值是否为非负，即 $\\min_k(\\lambda_k(L)) \\geq -\\varepsilon$。\n4.  **$L_{\\text{sym}}$ 谱的非负性 ($b_{L_{\\text{sym}},\\text{nonneg}}$)**：此布尔检查验证 $L_{\\text{sym}}$ 的所有特征值是否为非负，即 $\\min_k(\\lambda_k(L_{\\text{sym}})) \\geq -\\varepsilon$。\n    - *理论原理*：对于任何具有非负边权重 $w_{ij} \\geq 0$ 的图，$L$ 和 $L_{\\text{sym}}$ 都是半正定矩阵。此性质在数学上意味着它们的所有特征值必须是实数且非负。\n5.  **$L_{\\text{sym}}$ 谱的上限 ($b_{L_{\\text{sym}},\\max \\le 2}$)**：此布尔检查验证 $L_{\\text{sym}}$ 的最大特征值是否最多为 $2$，即 $\\max_k(\\lambda_k(L_{\\text{sym}})) \\leq 2 + \\varepsilon$。\n    - *理论原理*：这是另一个已确立的结果，即对于任何具有非负权重的图，$L_{\\text{sym}}$ 的所有特征值都以 $2$ 为上界。\n6.  **$L$ 的迹-特征值和相等性 ($b_{\\text{trace-eigs}}$)**：此布尔检查验证 $L$ 的特征值之和是否等于其迹，即 $|\\sum_{k=0}^{n-1} \\lambda_k(L) - \\operatorname{trace}(L)| \\leq \\varepsilon$。\n    - *理论原理*：这是任何方阵的一般性质。矩阵的迹在基变换下是不变的，并且总是等于其特征值之和。这可作为特征值计算的数值健全性检查。\n\n该算法被系统地应用于每个测试用例，得到的六个值（$z_L$，$z_{L_{\\text{sym}}}$ 和四个布尔值）被连接成一个单一列表作为最终输出。\n\n```python\nimport numpy as np\n\ndef solve_problem_2():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It defines the test cases, processes each one, and returns the final formatted result string.\n    \"\"\"\n    \n    epsilon = 1e-8\n\n    test_cases = [\n        {\n            \"n\": 4,\n            \"coords\": np.array([(0, 0), (1, 0), (2, 0), (3, 0)]),\n            \"neighbor_pairs\": [(0, 1), (1, 2), (2, 3)],\n            \"sigma\": 1.0,\n        },\n        {\n            \"n\": 6,\n            \"coords\": np.array([(0, 0), (1, 0), (2, 0), (10, 0), (11, 0), (12, 0)]),\n            \"neighbor_pairs\": [(0, 1), (1, 2), (3, 4), (4, 5)],\n            \"sigma\": 0.5,\n        },\n        {\n            \"n\": 4,\n            \"coords\": np.array([(0, 0), (1, 0), (0, 1), (5, 5)]),\n            \"neighbor_pairs\": [(0, 1), (0, 2), (1, 2)],\n            \"sigma\": 2.0,\n        },\n        {\n            \"n\": 4,\n            \"coords\": np.array([(0, 0), (0, 1), (1, 0), (1, 1)]),\n            \"neighbor_pairs\": [(0, 1), (0, 2), (1, 3), (2, 3)],\n            \"sigma\": 10.0,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = process_case(case['n'], case['coords'], case['neighbor_pairs'], case['sigma'], epsilon)\n        all_results.extend(results)\n\n    return f\"[{','.join(map(str, all_results))}]\"\n\ndef process_case(n, coords, neighbor_pairs, sigma, epsilon):\n    \"\"\"\n    Processes a single test case to compute and verify graph Laplacian properties.\n    \"\"\"\n    \n    W = np.zeros((n, n), dtype=np.float64)\n    sigma_sq = sigma**2\n    for i, j in neighbor_pairs:\n        dist_sq = np.sum((coords[i] - coords[j])**2)\n        weight = np.exp(-dist_sq / sigma_sq)\n        W[i, j] = weight\n        W[j, i] = weight\n\n    d_vec = np.sum(W, axis=1)\n    D = np.diag(d_vec)\n    L = D - W\n\n    d_inv_sqrt_vec = np.zeros(n, dtype=np.float64)\n    positive_degree_indices = d_vec > 0\n    d_inv_sqrt_vec[positive_degree_indices] = d_vec[positive_degree_indices]**(-0.5)\n    D_inv_sqrt = np.diag(d_inv_sqrt_vec)\n    \n    I = np.identity(n)\n    L_sym = I - D_inv_sqrt @ W @ D_inv_sqrt\n\n    eigs_L = np.linalg.eigh(L)[0]\n    eigs_L_sym = np.linalg.eigh(L_sym)[0]\n\n    z_L = int(np.sum(np.abs(eigs_L) = epsilon))\n    z_L_sym = int(np.sum(np.abs(eigs_L_sym) = epsilon))\n    b_L_nonneg = bool(eigs_L[0] >= -epsilon)\n    b_L_sym_nonneg = bool(eigs_L_sym[0] >= -epsilon)\n    b_L_sym_max_le_2 = bool(eigs_L_sym[-1] = 2 + epsilon)\n    trace_L = np.trace(L)\n    sum_eigs_L = np.sum(eigs_L)\n    b_trace_eigs = bool(np.abs(sum_eigs_L - trace_L) = epsilon)\n\n    return [z_L, z_L_sym, str(b_L_nonneg).lower(), str(b_L_sym_nonneg).lower(), str(b_L_sym_max_le_2).lower(), str(b_trace_eigs).lower()]\n\n# This is a helper function to generate the answer. The final XML does not contain the execution call.\n# print(solve_problem_2())\n```", "answer": "[1,1,true,true,true,true,2,2,true,true,true,true,2,2,true,true,true,true,1,1,true,true,true,true]", "id": "3350213"}, {"introduction": "空间转录组学实验的设计常常需要在空间点的数量（空间分辨率）和每个点的测序深度（表达量化精度）之间做出权衡，且通常受到总预算的限制。本练习将统计功效分析应用于一个真实的优化问题，在一个广义线性模型 (GLM) 框架下进行。通过寻找最优的资源分配方案，您将学会如何将理论统计模型转化为具体的实验策略，从而在有限的条件下最大化研究的科学价值 [@problem_id:3350152]。", "problem": "您正在设计一项空间转录组学研究，其中总成本需要在空间点数量和每个点的测序深度之间进行权衡。设 $n$ 为空间点的数量，$s$ 为每个点的测序深度。总成本建模为 $C = c_n n + c_s n s$，其中 $c_n$ 是每个点的设置成本，$c_s$ 是每个读长（或每个深度单位）的成本。您必须选择整数 $n$ 和整数 $s$，使其满足固定预算 $C \\le C_{\\max}$以及最小可行性约束 $n \\ge n_{\\min}$ 和 $s \\ge s_{\\min}$。\n\n建模假设与定义：\n- 对于指定基因集 $\\mathcal{G}$ 中的每个基因 $g$，每个点的计数遵循负二项 (NB) 分布，其均值为 $\\mu_{g i}$，方差为 $\\mu_{g i} + \\phi_g \\mu_{g i}^2$，其中 $\\phi_g \\ge 0$ 是基因特异性离散度。\n- 使用带有对数连接函数的广义线性模型 (GLM) 通过单个标准化空间对比度 $z_i$ 来检测跨越 $n$ 个空间点的空间信号，该对比度满足 $\\sum_{i=1}^{n} z_i = 0$ 和 $\\sum_{i=1}^{n} z_i^2 = n$。均值参数化为 $\\log \\mu_{g i} = \\log(s m_g) + \\theta_g z_i$，其中 $m_g$ 是基因的基线丰度，$\\theta_g$ 是其真实的空间效应大小。\n- 在 GLM 框架内，对每个基因的检测使用显著性水平为 $\\alpha$ 的双边 Wald 检验。原假设为 $H_0: \\theta_g = 0$，备择假设为 $H_1: \\theta_g \\ne 0$。利用 GLM 理论和负二项分布方差设定所隐含的标准大样本正态近似，推导作为 $n$ 和 $s$ 函数的期望功效。推导必须从这些定义出发，而不是从任何简便公式出发。\n\n目标：\n- 对于每个给定的测试用例，计算整数分配 $(n^\\star, s^\\star)$，该分配在满足 $c_n n + c_s n s \\le C_{\\max}$、$n \\ge n_{\\min}$ 和 $s \\ge s_{\\min}$ 的约束条件下，最大化指定基因集 $\\mathcal{G}$ 的平均期望功效。\n- 如果多个分配在数值容差范围内达到相同的最大平均期望功效，则选择最大的 $n$ 来打破平局；如果仍然平局，则选择最大的 $s$。\n- 如果没有可行的分配，则该测试用例返回 $[0,0,0.0]$。\n\n测试套件：\n- 对于每个测试用例，您将获得 $(C_{\\max}, c_n, c_s, n_{\\min}, s_{\\min}, \\alpha, \\mathcal{G})$，其中 $\\mathcal{G}$ 以三元组 $(m_g, \\phi_g, \\theta_g)$ 列表的形式提供。\n- 使用以下四个测试用例：\n  1. 测试用例 1：\n     - $C_{\\max} = 12000$，$c_n = 100$，$c_s = 1$，$n_{\\min} = 50$，$s_{\\min} = 10$，$\\alpha = 0.05$。\n     - $\\mathcal{G} = \\{(0.02, 0.05, 0.30), (0.05, 0.10, 0.25), (0.10, 0.20, 0.20), (0.20, 0.20, 0.15), (0.50, 0.30, 0.12), (1.00, 0.40, 0.10)\\}$。\n  2. 测试用例 2：\n     - $C_{\\max} = 12000$，$c_n = 500$，$c_s = 1$，$n_{\\min} = 10$，$s_{\\min} = 10$，$\\alpha = 0.05$。\n     - $\\mathcal{G} = \\{(0.02, 0.05, 0.30), (0.05, 0.10, 0.25), (0.10, 0.20, 0.20), (0.20, 0.20, 0.15), (0.50, 0.30, 0.12), (1.00, 0.40, 0.10)\\}$。\n  3. 测试用例 3：\n     - $C_{\\max} = 12000$，$c_n = 100$，$c_s = 5$，$n_{\\min} = 30$，$s_{\\min} = 5$，$\\alpha = 0.05$。\n     - $\\mathcal{G} = \\{(0.05, 0.20, 0.20), (0.10, 0.30, 0.15), (0.20, 0.30, 0.12), (0.30, 0.40, 0.10)\\}$。\n  4. 测试用例 4（边界可行性）：\n     - $C_{\\max} = 4400$，$c_n = 200$，$c_s = 2$，$n_{\\min} = 20$，$s_{\\min} = 10$，$\\alpha = 0.01$。\n     - $\\mathcal{G} = \\{(0.10, 0.40, 0.25), (0.20, 0.50, 0.20), (0.40, 0.60, 0.15)\\}$。\n\n程序要求：\n- 您的程序必须为每个测试用例计算最优的 $(n^\\star, s^\\star)$ 以及在双边显著性水平 $\\alpha$ 下，基因集 $\\mathcal{G}$ 对应的平均期望功效。\n- 每个基因的期望功效必须根据第一性原理，使用上述的 GLM 和负二项分布假设、对数连接函数以及标准化空间对比度进行计算，并依赖于大样本 Wald 检验近似和正态分布累积分布函数 (CDF) 的标准性质。在您的推理中，不要假设任何预先推导出的简便公式；请从给定的定义中推导出您需要的内容。\n- 最终输出格式必须是单行，包含一个逗号分隔的结果列表，其中每个结果都是一个三元组 $[n^\\star,s^\\star,\\overline{p}]$，$\\overline{p}$ 等于基因集 $\\mathcal{G}$ 的平均期望功效，并四舍五入到恰好 $6$ 位小数。整行不应包含空格。例如，它应如下所示：$[[n_1,s_1,p_1],[n_2,s_2,p_2],[n_3,s_3,p_3],[n_4,s_4,p_4]]$。", "solution": "我们从负二项 (NB) 分布和广义线性模型 (GLM) 框架开始。对于每个基因 $g$，在空间点 $i$ 的计数 $Y_{g i}$ 的均值为 $\\mu_{g i}$，方差为 $\\operatorname{Var}(Y_{g i}) = \\mu_{g i} + \\phi_g \\mu_{g i}^2$，其中 $\\phi_g \\ge 0$。我们使用对数连接函数和单个标准化空间对比度 $z_i$，该对比度跨越 $n$ 个空间点并满足 $\\sum_{i=1}^{n} z_i = 0$ 和 $\\sum_{i=1}^{n} z_i^2 = n$。均值结构为\n$$\n\\log \\mu_{g i} = \\log(s m_g) + \\theta_g z_i,\n$$\n因此 $\\mu_{g i} = s m_g \\exp(\\theta_g z_i)$。为了在备择假设下获得推断功效，我们考虑在显著性水平 $\\alpha$ 下，对 $H_0: \\theta_g = 0$ 与 $H_1: \\theta_g \\ne 0$ 进行双边 Wald 检验。\n\n根据具有正则连接函数和大样本近似的 GLM 理论，单个参数的 Wald 统计量使用 $\\theta_g$ 的费雪信息 (Fisher information)。在 $\\theta_g$ 的一阶近似下（对于小到中等效应大小），我们在 $H_0$ 下将 $\\mu_{g i}$ 近似为 $\\mu_{g i} \\approx s m_g$，该值在所有空间点上是恒定的。对于对数连接函数，均值对 $\\theta_g$ 的导数为\n$$\n\\frac{\\partial \\mu_{g i}}{\\partial \\theta_g} = \\mu_{g i} z_i \\approx (s m_g) z_i.\n$$\n在 NB 分布的拟似然或均值-方差设定下，方差函数为 $V(\\mu) = \\mu + \\phi_g \\mu^2 = \\mu (1 + \\phi_g \\mu)$。根据标准的 GLM 推导，在 $H_0$ 下，每个点对 $\\theta_g$ 的费雪信息的贡献为\n$$\nI_{g i} = \\frac{\\left(\\frac{\\partial \\mu_{g i}}{\\partial \\theta_g}\\right)^2}{\\operatorname{Var}(Y_{g i})}\n\\approx \\frac{(s m_g)^2 z_i^2}{s m_g + \\phi_g (s m_g)^2}\n= \\frac{(s m_g) z_i^2}{1 + \\phi_g (s m_g)}.\n$$\n对 $i = 1,\\dots,n$ 求和，并使用 $\\sum_{i=1}^{n} z_i^2 = n$，可得出费雪信息\n$$\nI_g(n,s) \\approx \\sum_{i=1}^{n} I_{g i}\n= \\frac{n \\, s \\, m_g}{1 + \\phi_g \\, s \\, m_g}.\n$$\n\nWald 检验统计量可以写为 $Z_g = \\widehat{\\theta}_g \\sqrt{I_g}$，在 $H_0$ 下，它近似服从标准正态分布。在真实效应 $\\theta_g \\ne 0$ 下，$\\widehat{\\theta}_g$ 近似服从均值为 $\\theta_g$、方差为 $1/I_g$ 的正态分布，因此 $Z_g$ 近似服从均值为 $\\theta_g \\sqrt{I_g}$、单位方差的正态分布。定义非中心化参数\n$$\n\\lambda_g(n,s) = \\theta_g^2 \\, I_g(n,s) = \\theta_g^2 \\, \\frac{n \\, s \\, m_g}{1 + \\phi_g \\, s \\, m_g}.\n$$\n设 $z_{1-\\alpha/2}$ 为标准正态分布的 $(1-\\alpha/2)$ 分位数，并设 $\\Phi(\\cdot)$ 表示标准正态累积分布函数 (CDF)。基因 $g$ 的双边功效为\n$$\n\\operatorname{power}_g(n,s)\n= \\Pr\\big(|Z_g|  z_{1-\\alpha/2}\\big)\n= \\Phi\\big(-z_{1-\\alpha/2} - \\sqrt{\\lambda_g(n,s)}\\big)\n+ 1 - \\Phi\\big(z_{1-\\alpha/2} - \\sqrt{\\lambda_g(n,s)}\\big).\n$$\n基因集 $\\mathcal{G}$ 的平均功效为\n$$\n\\overline{P}(n,s) = \\frac{1}{|\\mathcal{G}|} \\sum_{g \\in \\mathcal{G}} \\operatorname{power}_g(n,s).\n$$\n\n我们必须在预算和可行性约束条件 $c_n n + c_s n s \\le C_{\\max}$、$n \\ge n_{\\min}$ 和 $s \\ge s_{\\min}$ 下，最大化 $\\overline{P}(n,s)$，其中 $n$ 和 $s$ 为整数。对于固定的 $n$，费雪信息 $I_g(n,s)$ 在 $s$ 上是严格递增的，因为\n$$\n\\frac{d}{ds} \\left( \\frac{s m_g}{1 + \\phi_g s m_g} \\right)\n= \\frac{m_g}{\\big(1 + \\phi_g s m_g\\big)^2}  0,\n$$\n所以对于任何固定的 $n$，将 $s$ 设置为预算允许的最大整数是最佳选择：$s \\le \\left\\lfloor \\frac{C_{\\max} - c_n n}{c_s n} \\right\\rfloor$。因此，我们可以在可行范围 $n_{\\min} \\le n \\le \\left\\lfloor \\frac{C_{\\max}}{c_n + c_s s_{\\min}} \\right\\rfloor$ 内搜索 $n$，计算 $s_{\\max}(n) = \\left\\lfloor \\frac{C_{\\max} - c_n n}{c_s n} \\right\\rfloor$，如果 $s_{\\max}(n)  s_{\\min}$ 则舍弃该 $n$，否则计算 $\\overline{P}(n,s_{\\max}(n))$。在所有可行的配对中，选择具有最大 $\\overline{P}$ 的一个；对于数值容差范围内的平局，选择最大的 $n$，如果仍然平局，则选择最大的 $s$。\n\n每个测试用例的算法步骤：\n1. 枚举从 $n_{\\min}$ 到 $\\left\\lfloor \\frac{C_{\\max}}{c_n + c_s s_{\\min}} \\right\\rfloor$ 的整数 $n$。\n2. 对于每个 $n$，计算 $s_{\\max}(n) = \\left\\lfloor \\frac{C_{\\max} - c_n n}{c_s n} \\right\\rfloor$；如果 $s_{\\max}(n)  s_{\\min}$，则跳过。\n3. 使用上述公式，结合 $\\lambda_g(n,s)$ 和显著性水平为 $\\alpha$ 的正态 CDF，计算 $\\overline{P}(n,s_{\\max}(n))$。\n4. 追踪具有最大 $\\overline{P}$ 的最佳 $(n,s)$；通过选择最大的 $n$ 来解决平局，然后是最大的 $s$。\n5. 如果不存在可行的 $(n,s)$，则该测试返回 $[0,0,0.0]$。\n6. 将最佳平均功效四舍五入到恰好 $6$ 位小数以供输出。\n\n将此方法应用于提供的测试套件，可以得到一组确定的最优整数分配及其四舍五入后的平均期望功效。最终程序打印单行，包含四个结果，格式为 $[[n_1^\\star,s_1^\\star,\\overline{p}_1],[n_2^\\star,s_2^\\star,\\overline{p}_2],[n_3^\\star,s_3^\\star,\\overline{p}_3],[n_4^\\star,s_4^\\star,\\overline{p}_4]]$，不含空格。\n```python\nimport numpy as np\nfrom math import floor, sqrt, isclose\nfrom scipy.stats import norm\n\ndef solve_problem_3():\n    \"\"\"\n    Main function to solve the problem for all test cases and format the output.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"Cmax\": 12000, \"c_n\": 100, \"c_s\": 1, \"n_min\": 50, \"s_min\": 10, \"alpha\": 0.05,\n            \"genes\": [\n                (0.02, 0.05, 0.30), (0.05, 0.10, 0.25), (0.10, 0.20, 0.20),\n                (0.20, 0.20, 0.15), (0.50, 0.30, 0.12), (1.00, 0.40, 0.10),\n            ]\n        },\n        # Test case 2\n        {\n            \"Cmax\": 12000, \"c_n\": 500, \"c_s\": 1, \"n_min\": 10, \"s_min\": 10, \"alpha\": 0.05,\n            \"genes\": [\n                (0.02, 0.05, 0.30), (0.05, 0.10, 0.25), (0.10, 0.20, 0.20),\n                (0.20, 0.20, 0.15), (0.50, 0.30, 0.12), (1.00, 0.40, 0.10),\n            ]\n        },\n        # Test case 3\n        {\n            \"Cmax\": 12000, \"c_n\": 100, \"c_s\": 5, \"n_min\": 30, \"s_min\": 5, \"alpha\": 0.05,\n            \"genes\": [\n                (0.05, 0.20, 0.20), (0.10, 0.30, 0.15),\n                (0.20, 0.30, 0.12), (0.30, 0.40, 0.10),\n            ]\n        },\n        # Test case 4\n        {\n            \"Cmax\": 4400, \"c_n\": 200, \"c_s\": 2, \"n_min\": 20, \"s_min\": 10, \"alpha\": 0.01,\n            \"genes\": [\n                (0.10, 0.40, 0.25), (0.20, 0.50, 0.20), (0.40, 0.60, 0.15),\n            ]\n        },\n    ]\n\n    results_str_parts = []\n    for case in test_cases:\n        n_star, s_star, avg_power_star = optimize_allocation(\n            Cmax=case[\"Cmax\"], c_n=case[\"c_n\"], c_s=case[\"c_s\"],\n            n_min=case[\"n_min\"], s_min=case[\"s_min\"], alpha=case[\"alpha\"], genes=case[\"genes\"]\n        )\n        avg_str = f\"{avg_power_star:.6f}\"\n        results_str_parts.append(f\"[{n_star},{s_star},{avg_str}]\")\n\n    return \"[\" + \",\".join(results_str_parts) + \"]\"\n\ndef fisher_information_nbinom(n, s, m, phi):\n    mu = s * m\n    denom = 1.0 + phi * mu\n    if denom == 0: return 0.0\n    return n * mu / denom\n\ndef gene_power(n, s, m, phi, theta, alpha):\n    I = fisher_information_nbinom(n, s, m, phi)\n    lam = (theta * theta) * I\n    delta = sqrt(lam) if lam > 0.0 else 0.0\n    zthr = norm.ppf(1.0 - alpha / 2.0)\n    return norm.cdf(-zthr - delta) + (1.0 - norm.cdf(zthr - delta))\n\ndef average_power(n, s, genes, alpha):\n    if n = 0 or s = 0: return 0.0\n    powers = [gene_power(n, s, m, phi, theta, alpha) for (m, phi, theta) in genes]\n    return float(np.mean(powers)) if powers else 0.0\n\ndef optimize_allocation(Cmax, c_n, c_s, n_min, s_min, alpha, genes, tie_tol=1e-12):\n    n_cost_at_min_s = c_n + c_s * s_min\n    if n_cost_at_min_s = 0: return (0, 0, 0.0)\n    n_upper = Cmax // n_cost_at_min_s\n    if n_upper  n_min: return (0, 0, 0.0)\n\n    best_n, best_s, best_power = 0, 0, -1.0\n    for n in range(n_min, int(n_upper) + 1):\n        s_denom = c_s * n\n        if s_denom = 0: continue\n        s_max = (Cmax - c_n * n) // s_denom\n        if s_max  s_min: continue\n        s = int(s_max)\n        avg_p = average_power(n, s, genes, alpha)\n\n        if avg_p > best_power + tie_tol:\n            best_n, best_s, best_power = n, s, avg_p\n        elif isclose(avg_p, best_power, rel_tol=0.0, abs_tol=tie_tol):\n            if n > best_n or (n == best_n and s > best_s):\n                best_n, best_s, best_power = n, s, avg_p\n\n    if best_power  0.0: return (0, 0, 0.0)\n    return (best_n, best_s, best_power)\n\n# This is a helper function to generate the answer. The final XML does not contain the execution call.\n# print(solve_problem_3())\n```", "answer": "[[98,22,0.612040],[22,90,0.611598],[75,12,0.518600],[20,10,0.485984]]", "id": "3350152"}]}