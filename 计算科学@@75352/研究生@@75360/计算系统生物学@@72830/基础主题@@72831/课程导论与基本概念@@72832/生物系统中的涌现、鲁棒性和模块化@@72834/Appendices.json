{"hands_on_practices": [{"introduction": "理解噪声的来源是分析生物系统鲁棒性的基础。本练习将帮助您区分基因表达中的内在噪声（源于生化反应的随机性）和外在噪声（源于细胞间的差异）。通过为一个“脉冲式”基因表达模型推导法诺因子（Fano factor），您将学习如何将分子参数与可观测的噪声特性进行定量关联 [@problem_id:3305386]。", "problem": "考虑一个信使核糖核酸（mRNA）的单基因表达模块，其中合成以随机脉冲形式发生，降解为一级反应。脉冲以速率 $k$（单位时间内的脉冲数）的齐次泊松过程到达。一个脉冲会增加随机数量 $M$ 的 mRNA 分子，其中 $M$ 在不同脉冲之间是独立同分布的，并服从支撑集为 $\\{0,1,2,\\dots\\}$、概率质量函数为 $\\Pr(M=m)=p(1-p)^{m}$ 的几何分布；每个 mRNA 分子的降解独立发生，速率为 $\\gamma$（每个分子）。定义法诺因子 $F$ 为 $F=\\frac{\\operatorname{Var}(n)}{\\mathbb{E}[n]}$，其中 $n$ 是稳态下的 mRNA 拷贝数。几何脉冲大小分布的均值为 $\\mathbb{E}[M]=\\frac{1-p}{p}$，方差为 $\\operatorname{Var}(M)=\\frac{1-p}{p^{2}}$，因此平均脉冲大小 $b$ 满足 $b=\\frac{1-p}{p}$。\n\n您的任务是：\n- 利用全方差定律和对在细胞群体中波动的环境或参数变量进行条件化，精确区分基因表达中的内在噪声和外在噪声。\n- 从化学主方程（CME）和跳跃过程下期望的生成元公式出发，推导该脉冲生灭模型的稳态 $\\mathbb{E}[n]$ 和 $\\operatorname{Var}(n)$ 的闭式表达式，然后计算法诺因子 $F$。\n\n将您的最终答案表示为仅包含 $b$ 的单个闭式解析表达式。不需要数值近似，由于 $F$ 是无量纲的，因此也不需要单位。", "solution": "该问题提出了两个任务：首先，在一个正式的统计框架下，区分基因表达背景下的内在噪声和外在噪声；其次，为一个特定的 mRNA 表达随机模型推导法诺因子。\n\n一个分子种类在细胞群体中拷贝数 $n$ 的总噪声或变异性，可以通过其方差 $\\operatorname{Var}(n)$ 来量化。通过应用全方差定律，这个总方差可以分解为两个不同的组成部分，分别称为内在噪声和外在噪声。令 $\\mathbf{Z}$ 为一个随机变量向量，代表细胞环境或背景的状态，该状态在不同细胞间波动。这些变量可能包括聚合酶、核糖体、代谢酶的浓度、细胞体积或细胞周期阶段。全方差定律表述为：\n$$\n\\operatorname{Var}(n) = \\mathbb{E}[\\operatorname{Var}(n | \\mathbf{Z})] + \\operatorname{Var}(\\mathbb{E}[n | \\mathbf{Z}])\n$$\n右侧的两项分别对应内在噪声和外在噪声。\n\n$1$. **内在噪声**：项 $\\mathbb{E}[\\operatorname{Var}(n | \\mathbf{Z})]$ 量化了内在噪声。条件方差 $\\operatorname{Var}(n | \\mathbf{Z}=\\mathbf{z})$ 表示在具有完全相同外在状态 $\\mathbf{z}$ 的细胞亚群中，拷贝数 $n$ 的变异性。这种变异性源于基因表达生化反应（例如，转录起始、mRNA降解）固有的随机性，即使在完全恒定的环境中，单个反应事件发生的时间也是一个随机过程。内在噪声是这个条件方差的期望值，是对群体中存在的所有可能的外在状态 $\\mathbf{Z}$ 进行平均得到的。\n\n$2$. **外在噪声**：项 $\\operatorname{Var}(\\mathbb{E}[n | \\mathbf{Z})]$ 量化了外在噪声。条件期望 $\\mathbb{E}[n | \\mathbf{Z}=\\mathbf{z}]$ 是处于特定外在状态 $\\mathbf{z}$ 的细胞中 $n$ 的平均拷贝数。这个平均水平可能依赖于状态 $\\mathbf{z}$。外在噪声是这个条件均值的方差，它捕捉了当外在状态 $\\mathbf{Z}$ 在细胞群体中变化时，平均表达水平本身如何波动。它是由细胞间在细胞机制和环境上的差异对总方差的贡献。\n\n接下来，我们为给定的模型推导法诺因子。该模型包含两个控制 mRNA 拷贝数 $n$ 的过程：\n- **脉冲式生成**：新的 mRNA 分子以脉冲形式产生，以速率 $k$ 的泊松过程到达。每个脉冲增加 $M$ 个分子，其中 $M$ 是一个服从几何分布的随机变量，对于 $m \\in \\{0, 1, 2, \\dots\\}$，有 $\\Pr(M=m) = p(1-p)^m$。这些脉冲是独立同分布的。\n- **一级降解**：每个 mRNA 分子以速率常数 $\\gamma$ 独立降解。对于 $n$ 个分子，总降解速率为 $\\gamma n$。\n\n状态的任意函数 $f(n)$ 的期望值的时间演化可以从化学主方程（CME）使用生成元方法推导出来。$\\mathbb{E}[f(n)]$ 的变化率由 $\\frac{d\\mathbb{E}[f(n)]}{dt} = \\mathbb{E}[\\mathcal{L}f(n)]$ 给出，其中 $\\mathcal{L}$ 是该过程的生成元。对于此模型，作用于 $f(n)$ 的生成元是：\n$$\n\\mathcal{L}f(n) = \\gamma n [f(n-1) - f(n)] + k \\sum_{m=0}^{\\infty} \\Pr(M=m)[f(n+m) - f(n)]\n$$\n为了找到稳态矩，我们令 $\\frac{d\\mathbb{E}[f(n)]}{dt} = 0$。\n\n首先，通过设 $f(n)=n$，我们推导稳态均值 $\\mathbb{E}[n]$。\n$$\n\\frac{d\\mathbb{E}[n]}{dt} = \\mathbb{E}[\\gamma n ((n-1) - n) + k \\sum_{m=0}^{\\infty} \\Pr(M=m)((n+m) - n)]\n$$\n$$\n\\frac{d\\mathbb{E}[n]}{dt} = \\mathbb{E}[-\\gamma n + k \\sum_{m=0}^{\\infty} m \\Pr(M=m)]\n$$\n求和项是脉冲大小期望值 $\\mathbb{E}[M]$ 的定义。\n$$\n\\frac{d\\mathbb{E}[n]}{dt} = -\\gamma \\mathbb{E}[n] + k \\mathbb{E}[M]\n$$\n在稳态时，$\\frac{d\\mathbb{E}[n]}{dt}=0$，得到稳态均值为：\n$$\n\\mathbb{E}[n] = \\frac{k}{\\gamma} \\mathbb{E}[M]\n$$\n\n接下来，通过设 $f(n)=n^2$，我们推导稳态二阶矩 $\\mathbb{E}[n^2]$。\n$$\n\\frac{d\\mathbb{E}[n^2]}{dt} = \\mathbb{E}[\\gamma n ((n-1)^2 - n^2) + k \\sum_{m=0}^{\\infty} \\Pr(M=m)((n+m)^2 - n^2)]\n$$\n我们计算方括号内的项：\n- 降解：$\\gamma n(n^2-2n+1-n^2) = \\gamma n(-2n+1) = -2\\gamma n^2 + \\gamma n$。\n- 生成：$k \\sum_{m=0}^{\\infty} \\Pr(M=m)(n^2+2nm+m^2-n^2) = k \\sum_{m=0}^{\\infty} \\Pr(M=m)(2nm+m^2) = k (2n \\sum_{m=0}^{\\infty} m \\Pr(M=m) + \\sum_{m=0}^{\\infty} m^2 \\Pr(M=m)) = k(2n\\mathbb{E}[M] + \\mathbb{E}[M^2])$。\n取期望值得到 $\\mathbb{E}[n^2]$ 的演化方程：\n$$\n\\frac{d\\mathbb{E}[n^2]}{dt} = \\mathbb{E}[-2\\gamma n^2 + \\gamma n + k(2n\\mathbb{E}[M] + \\mathbb{E}[M^2])]\n$$\n$$\n\\frac{d\\mathbb{E}[n^2]}{dt} = -2\\gamma \\mathbb{E}[n^2] + \\gamma \\mathbb{E}[n] + 2k\\mathbb{E}[M]\\mathbb{E}[n] + k\\mathbb{E}[M^2]\n$$\n在稳态时，$\\frac{d\\mathbb{E}[n^2]}{dt}=0$。我们使用稳态关系 $k\\mathbb{E}[M] = \\gamma \\mathbb{E}[n]$ 并代入 $\\mathbb{E}[n^2] = \\operatorname{Var}(n) + (\\mathbb{E}[n])^2$：\n$$\n0 = -2\\gamma (\\operatorname{Var}(n) + (\\mathbb{E}[n])^2) + \\gamma \\mathbb{E}[n] + 2(\\gamma\\mathbb{E}[n])\\mathbb{E}[n] + k\\mathbb{E}[M^2]\n$$\n$$\n0 = -2\\gamma\\operatorname{Var}(n) - 2\\gamma(\\mathbb{E}[n])^2 + \\gamma\\mathbb{E}[n] + 2\\gamma(\\mathbb{E}[n])^2 + k\\mathbb{E}[M^2]\n$$\n包含 $(\\mathbb{E}[n])^2$ 的项相互抵消，方程简化为：\n$$\n2\\gamma\\operatorname{Var}(n) = \\gamma\\mathbb{E}[n] + k\\mathbb{E}[M^2]\n$$\n求解方差 $\\operatorname{Var}(n)$：\n$$\n\\operatorname{Var}(n) = \\frac{1}{2}\\mathbb{E}[n] + \\frac{k}{2\\gamma}\\mathbb{E}[M^2]\n$$\n法诺因子 $F$ 定义为 $F = \\frac{\\operatorname{Var}(n)}{\\mathbb{E}[n]}$。代入均值和方差的表达式：\n$$\nF = \\frac{\\frac{1}{2}\\mathbb{E}[n] + \\frac{k}{2\\gamma}\\mathbb{E}[M^2]}{\\mathbb{E}[n]} = \\frac{1}{2} + \\frac{k\\mathbb{E}[M^2]}{2\\gamma\\mathbb{E}[n]}\n$$\n现在，将 $\\mathbb{E}[n] = \\frac{k}{\\gamma}\\mathbb{E}[M]$ 代入法诺因子的表达式：\n$$\nF = \\frac{1}{2} + \\frac{k\\mathbb{E}[M^2]}{2\\gamma(\\frac{k}{\\gamma}\\mathbb{E}[M])} = \\frac{1}{2} + \\frac{\\mathbb{E}[M^2]}{2\\mathbb{E}[M]}\n$$\n这是一个对任何脉冲大小分布都成立的通用结果。该问题指定了一个几何分布，其平均脉冲大小为 $b=\\mathbb{E}[M]=\\frac{1-p}{p}$，方差为 $\\operatorname{Var}(M)=\\frac{1-p}{p^2}$。我们必须只用 $b$ 来表示 $F$。\n首先，我们用 $b$ 来表示 $\\operatorname{Var}(M)$。由 $b=\\frac{1-p}{p}=\\frac{1}{p}-1$ 可得 $\\frac{1}{p}=b+1$。\n$$\n\\operatorname{Var}(M) = \\frac{1-p}{p^2} = \\left(\\frac{1-p}{p}\\right)\\frac{1}{p} = b(b+1)\n$$\n接下来，我们使用关系式 $\\operatorname{Var}(M) = \\mathbb{E}[M^2] - (\\mathbb{E}[M])^2$ 来求 $\\mathbb{E}[M^2]$：\n$$\n\\mathbb{E}[M^2] = \\operatorname{Var}(M) + (\\mathbb{E}[M])^2 = b(b+1) + b^2 = b^2+b+b^2 = 2b^2+b\n$$\n最后，我们将 $\\mathbb{E}[M]=b$ 和 $\\mathbb{E}[M^2]=2b^2+b$ 代入 $F$ 的表达式中：\n$$\nF = \\frac{1}{2} + \\frac{2b^2+b}{2b}\n$$\n假设是一个非平凡过程，其中 $b>0$，我们可以简化为：\n$$\nF = \\frac{1}{2} + \\frac{b(2b+1)}{2b} = \\frac{1}{2} + \\frac{2b+1}{2} = \\frac{1}{2} + b + \\frac{1}{2} = 1+b\n$$\n这个结果表明，法诺因子（一种相对于均值的噪声度量）由一个泊松分量（$1$）和一个与平均脉冲大小（$b$）成线性比例的项组成。", "answer": "$$\n\\boxed{1+b}\n$$", "id": "3305386"}, {"introduction": "生物系统中的噪声动态本身蕴含着关于系统稳定性的重要信息。本练习将带您探索临界点（如分岔点）附近的“临界慢化”现象，此时系统从扰动中恢复的能力会急剧下降 [@problem_id:3305415]。通过分析系统状态的方差和自相关性如何随参数变化而改变，您可以学习识别系统即将发生突变（即丧失鲁棒性）的早期预警信号。", "problem": "考虑一个鞍-节分岔附近的单基因调控模块，其稳定平衡点周围的线性化动力学由一个带加性白噪声的随机微分方程（SDE）建模：$$\\mathrm{d}x(t) = -k(\\mu)\\, x(t)\\,\\mathrm{d}t + \\sigma\\, \\mathrm{d}W_t,$$ 其中 $x(t)$ 是与平衡点的偏差，$W_t$ 是一个标准维纳过程（布朗运动），$\\sigma > 0$ 是噪声振幅，$k(\\mu) = k_0\\left(\\mu_c - \\mu\\right)$ 是恢复速率，它线性地依赖于与临界参数值 $\\mu_c$ 的距离，其中 $k_0 > 0$ 且 $\\mu < \\mu_c$ 以确保稳定性。在计算系统生物学中，这是一个用于研究临界慢化和早期预警信号的典范模型，其中涌现性和稳健性通过动力系统和随机过程进行研究。\n\n从这个SDE和白噪声驱动的线性系统的平稳性定义出发，根据参数 $k(\\mu)$、$\\sigma$ 和采样间隔 $\\Delta t$，推导平稳自协方差函数、在采样间隔 $\\Delta t$ 处的滞后-1自相关（定义为滞后 $\\Delta t$ 的自协方差除以零滞后自协方差）以及平稳方差。展示当 $\\mu \\to \\mu_c^{-}$（等价于 $k(\\mu) \\to 0^{+}$）时这些量如何变化，并解释为什么它们的行为构成了生物系统中脆弱性、稳健性及模块性丧失的早期预警信号。\n\n实现一个程序，利用推导出的表达式，为以下每个参数集计算滞后-1自相关和平稳方差。时间和状态使用无量纲单位。然后，仅使用前三种情况，通过对 $\\log$-方差与 $\\log k(\\mu)$ 的关系进行直线拟合（通过最小二乘法）并返回斜率，来计算标度指数。此外，仅使用按 $\\mu$ 递增排序的前三种情况，如果滞后-1自相关和平稳方差都随着 $\\mu$ 接近 $\\mu_c$（即随着 $k(\\mu)$ 减小）而单调增加，则返回布尔值 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n测试套件（每个案例为 $(\\mu, \\mu_c, k_0, \\sigma, \\Delta t)$）：\n- 案例 1：$(0.2, 1.0, 1.0, 0.5, 0.1)$\n- 案例 2：$(0.99, 1.0, 1.0, 0.5, 0.1)$\n- 案例 3：$(0.0, 1.0, 1.0, 0.5, 0.1)$\n- 案例 4：$(0.99, 1.0, 1.0, 0.0, 0.1)$\n- 案例 5：$(0.99, 1.0, 1.0, 0.5, 10.0)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含：对于五个案例中的每一个，首先是滞后-1自相关，然后是平稳方差；接着是仅使用案例1-3估计的标度指数；最后是仅使用按 $\\mu$ 递增排序的案例1-3计算的早期预警布尔值。例如，格式应为 $$[\\rho_1^{(1)}, \\operatorname{Var}^{(1)}, \\rho_1^{(2)}, \\operatorname{Var}^{(2)}, \\rho_1^{(3)}, \\operatorname{Var}^{(3)}, \\rho_1^{(4)}, \\operatorname{Var}^{(4)}, \\rho_1^{(5)}, \\operatorname{Var}^{(5)}, s, \\mathrm{EWS}],$$ 其中每个 $\\rho_1^{(i)}$ 和 $\\operatorname{Var}^{(i)}$ 是一个浮点数，$s$ 是一个浮点数，而 $\\mathrm{EWS}$ 是一个布尔值。不允许有其他输出。", "solution": "该问题的核心在于分析一个由Ornstein-Uhlenbeck过程描述的随机微分方程（SDE）：\n$$\n\\mathrm{d}x(t) = -k(\\mu)\\, x(t)\\,\\mathrm{d}t + \\sigma\\, \\mathrm{d}W_t\n$$\n其中 $k(\\mu) = k_0(\\mu_c - \\mu) > 0$ 是恢复速率。这是一个线性SDE，其解是高斯过程。\n\n**1. 平稳方差 $\\operatorname{Var}(x)$**\n\n为了找到平稳方差，我们可以使用伊藤引理（Itô's lemma）来分析二阶矩 $\\mathbb{E}[x^2(t)]$ 的动态。对于函数 $f(x)=x^2$，伊藤引理给出：\n$$\n\\mathrm{d}(x^2) = \\frac{\\partial(x^2)}{\\partial x} \\mathrm{d}x + \\frac{1}{2} \\frac{\\partial^2(x^2)}{\\partial x^2} (\\mathrm{d}x)^2\n$$\n其中 $\\mathrm{d}x = -k x \\mathrm{d}t + \\sigma \\mathrm{d}W_t$。导数项为 $\\frac{\\partial(x^2)}{\\partial x} = 2x$ 和 $\\frac{\\partial^2(x^2)}{\\partial x^2} = 2$。根据伊藤等距性质，$(\\mathrm{d}W_t)^2 = \\mathrm{d}t$。因此，$(\\mathrm{d}x)^2 = (\\sigma \\mathrm{d}W_t)^2 = \\sigma^2 \\mathrm{d}t$（忽略高阶 $\\mathrm{d}t$ 项）。\n\n代入可得：\n$$\n\\mathrm{d}(x^2) = 2x(-k x \\mathrm{d}t + \\sigma \\mathrm{d}W_t) + \\frac{1}{2}(2)(\\sigma^2 \\mathrm{d}t) = (-2kx^2 + \\sigma^2)\\mathrm{d}t + 2\\sigma x \\mathrm{d}W_t\n$$\n对上式取期望，由于随机积分项的期望为零（$\\mathbb{E}[x \\mathrm{d}W_t]=0$），我们得到 $\\mathbb{E}[x^2]$ 的常微分方程：\n$$\n\\frac{\\mathrm{d}\\mathbb{E}[x^2]}{\\mathrm{d}t} = -2k \\mathbb{E}[x^2] + \\sigma^2\n$$\n在平稳状态下，$\\frac{\\mathrm{d}\\mathbb{E}[x^2]}{\\mathrm{d}t} = 0$，解得：\n$$\n\\mathbb{E}[x^2] = \\frac{\\sigma^2}{2k}\n$$\n由于系统关于 $x=0$ 对称，平稳均值为 $\\mathbb{E}[x]=0$。因此，平稳方差为 $\\operatorname{Var}(x) = \\mathbb{E}[x^2] - (\\mathbb{E}[x])^2 = \\frac{\\sigma^2}{2k(\\mu)}$。\n\n**2. 自协方差函数 $C(\\tau)$ 和滞后-1自相关 $\\rho_1$**\n\nOrnstein-Uhlenbeck过程的自协方差函数是众所周知的，对于滞后时间 $\\tau \\ge 0$，其形式为：\n$$\nC(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)] = \\operatorname{Var}(x) e^{-k\\tau} = \\frac{\\sigma^2}{2k(\\mu)} e^{-k(\\mu)\\tau}\n$$\n滞后-1自相关是滞后时间为 $\\Delta t$ 时的自相关系数，定义为 $C(\\Delta t)$ 除以 $C(0) = \\operatorname{Var}(x)$：\n$$\n\\rho_1 = \\frac{C(\\Delta t)}{C(0)} = \\frac{\\operatorname{Var}(x) e^{-k(\\mu)\\Delta t}}{\\operatorname{Var}(x)} = e^{-k(\\mu)\\Delta t}\n$$\n\n**3. 临界慢化与早期预警信号**\n\n当系统接近临界点 $\\mu_c$ 时（从 $\\mu < \\mu_c$ 逼近），恢复速率 $k(\\mu) = k_0(\\mu_c - \\mu)$ 趋向于零（$k(\\mu) \\to 0^+$）。此时：\n-   **方差**：$\\operatorname{Var}(x) = \\frac{\\sigma^2}{2k(\\mu)} \\to \\infty$。系统状态的波动幅度急剧增大。\n-   **自相关**：$\\rho_1 = e^{-k(\\mu)\\Delta t} \\to e^0 = 1$。系统状态的时间序列变得高度相关，意味着系统从扰动中恢复得非常缓慢。\n\n这种恢复速率的减慢被称为“临界慢化”。方差和自相关性的同时增加是系统即将失去稳定性（即鲁棒性丧失）的通用早期预警信号。在模块化系统中，如果一个关键模块接近这样的分岔点，其内部动力学的临界慢化可能通过模块间耦合传播，危及整个系统的功能。因此，监测这些统计量可以为预测系统层面的突变提供线索。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and calculating early-warning signals\n    for a single-gene regulatory module near a saddle-node bifurcation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (mu, mu_c, k0, sigma, delta_t)\n    test_cases = [\n        (0.2, 1.0, 1.0, 0.5, 0.1),  # Case 1\n        (0.99, 1.0, 1.0, 0.5, 0.1), # Case 2\n        (0.0, 1.0, 1.0, 0.5, 0.1),  # Case 3\n        (0.99, 1.0, 1.0, 0.0, 0.1), # Case 4\n        (0.99, 1.0, 1.0, 0.5, 10.0),# Case 5\n    ]\n\n    all_results = []\n    case_data = {}  # Dictionary to store results for post-processing\n\n    # Process all five cases\n    for i, case in enumerate(test_cases, 1):\n        mu, mu_c, k0, sigma, delta_t = case\n        \n        # Calculate the restoring rate k(mu)\n        k_val = k0 * (mu_c - mu)\n\n        # Calculate stationary variance: Var = sigma^2 / (2*k)\n        # This holds for k > 0. If sigma is 0, Var is 0.\n        if k_val > 0:\n            variance = (sigma**2) / (2 * k_val)\n        else:\n            # Handle the case k_val = 0. Not expected by problem constraints (mu  mu_c)\n            # but included for robustness.\n            variance = float('inf') if sigma != 0 else 0\n\n        # Calculate lag-1 autocorrelation: rho_1 = exp(-k * delta_t)\n        lag1_autocorr = np.exp(-k_val * delta_t)\n\n        all_results.extend([lag1_autocorr, variance])\n        \n        # Store results for later use in scaling and monotonicity checks\n        case_data[i] = {\n            'mu': mu,\n            'k': k_val,\n            'var': variance,\n            'rho1': lag1_autocorr\n        }\n\n    # Part 2: Compute the scaling exponent using Cases 1, 2, and 3\n    # The theoretical relationship is Var = C * k^(-1), so log(Var) = log(C) - 1*log(k).\n    # The slope of log(Var) vs log(k) should be -1.\n    k_vals_fit = [case_data[1]['k'], case_data[2]['k'], case_data[3]['k']]\n    var_vals_fit = [case_data[1]['var'], case_data[2]['var'], case_data[3]['var']]\n\n    log_k = np.log(k_vals_fit)\n    log_var = np.log(var_vals_fit)\n\n    # Perform a linear fit (degree 1 polynomial) to find the slope\n    slope, _ = np.polyfit(log_k, log_var, 1)\n    scaling_exponent = slope\n    all_results.append(scaling_exponent)\n\n    # Part 3: Compute the early-warning signal (EWS) boolean\n    # Check if both variance and lag-1 autocorrelation increase monotonically\n    # as mu approaches mu_c for Cases 1, 2, 3.\n    # Order cases by increasing mu: Case 3 (mu=0.0), Case 1 (mu=0.2), Case 2 (mu=0.99)\n    ordered_indices = sorted([1, 2, 3], key=lambda i: case_data[i]['mu'])\n    \n    variances_ordered = [case_data[i]['var'] for i in ordered_indices]\n    rhos_ordered = [case_data[i]['rho1'] for i in ordered_indices]\n    \n    # Check for strict monotonicity\n    var_is_monotonic = all(variances_ordered[j]  variances_ordered[j+1] for j in range(len(variances_ordered) - 1))\n    rho_is_monotonic = all(rhos_ordered[j]  rhos_ordered[j+1] for j in range(len(rhos_ordered) - 1))\n\n    ews_boolean = var_is_monotonic and rho_is_monotonic\n    all_results.append(ews_boolean)\n\n    # Final print statement in the exact required format.\n    # The boolean `True` will be converted to the string 'True'.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3305415"}, {"introduction": "模块化是生物系统构建复杂且鲁棒功能的核心设计原则。本练习提供了一个计算平台，让您亲手检验这一原则的力量 [@problem_id:3305370]。您将模拟一个由两个模块构成的基因调控网络，并量化一个“绝缘”模块如何减弱模块间的非预期相互作用（即“反作用性”），从而增强系统的动态鲁棒性和功能模块的独立性。", "problem": "考虑一个由两个模块组成的四基因调控网络。模块 $\\mathcal{A}$ 包含基因 $1$ 和基因 $2$，模块 $\\mathcal{B}$ 包含基因 $3$ 和基因 $4$。调控结构如下：基因 $1$ 激活基因 $2$，基因 $2$ 抑制基因 $3$，基因 $3$ 激活基因 $4$。基因 $1$ 是组成性表达的。该动力学通过常微分方程在无量纲单位下建模，并对启动子占有率采用准稳态近似。由转录因子调控的目标基因的启动子占有率遵循带有协同性的质量作用定律。\n\n基本原理和定义：\n\n- 具有协同性 $h$ 和质量作用结合/解离的启动子占有率由动力学方程给出\n$$\n\\frac{dO}{dt} = k_{\\text{on}}^{\\text{eff}} f^h (1 - O) - k_{\\text{off}} O,\n$$\n其中 $O \\in [0,1]$ 是占有率分数，$f$ 是调控子浓度，$k_{\\text{on}}^{\\text{eff}}$ 是有效结合速率，$k_{\\text{off}}$ 是解离速率，$h \\geq 1$ 是希尔协同指数。在启动子结合的准稳态近似下，占有率为\n$$\nO = \\frac{k_{\\text{on}}^{\\text{eff}} f^h}{k_{\\text{on}}^{\\text{eff}} f^h + k_{\\text{off}}}.\n$$\n\n- “反向活性”（Retroactivity）被建模为调控子的隔离，由于调控子在多个下游靶点之间分配，从而降低了有效结合速率。对于一个受到由无量纲反向活性 $r \\ge 0$ 量化的下游负载影响的调控子，其有效结合速率为\n$$\nk_{\\text{on}}^{\\text{eff}} = \\frac{k_{\\text{on}}}{1 + r}.\n$$\n一个效率为 $0 \\le \\eta \\le 1$ 的绝缘模块将反向活性降低为 $r_{\\text{eff}} = r(1 - \\eta)$，从而得到\n$$\nk_{\\text{on}}^{\\text{eff}}(\\eta) = \\frac{k_{\\text{on}}}{1 + r(1 - \\eta)}.\n$$\n\n- 每个基因 $i \\in \\{1,2,3,4\\}$ 的基因表达动力学建模为\n$$\n\\frac{dx_i}{dt} = \\alpha_i \\, F_i(x) - \\delta_i x_i,\n$$\n其中 $x_i$ 是基因 $i$ 产物的浓度，$\\alpha_i$ 是生产规模，$\\delta_i$ 是降解速率，$F_i(x)$ 是根据相应调控子对其启动子的占有率导出的调控输入函数：\n    - 基因 1：$F_1(x) = p_1$（组成性）。\n    - 基因 2（由 $x_1$ 激活）：$F_2(x) = b_2 + s_2 O_{21}(x_1)$。\n    - 基因 3（由 $x_2$ 抑制）：$F_3(x) = b_3 + s_3 (1 - O_{32}(x_2))$。\n    - 基因 4（由 $x_3$ 激活）：$F_4(x) = b_4 + s_4 O_{43}(x_3)$。\n这里 $b_i \\in [0,1]$ 是基础表达分数，$s_i \\in [0,1]$ 是最大受调控贡献，使得 $b_i + s_i \\le 1$，$O_{ij}(x_j)$ 是靶基因 $i$ 受调控子 $j$ 调控的启动子占有率函数，使用上述质量作用准稳态形式。\n\n- 我们将反向活性建模为仅影响模块间的调控链接 $2 \\to 3$，这与连接模块会给上游模块带来下游负载的概念一致。因此，有效结合速率为\n$$\nk_{\\text{on},21}^{\\text{eff}} = k_{\\text{on}}, \\quad\nk_{\\text{on},32}^{\\text{eff}} = \\frac{k_{\\text{on}}}{1 + r(1 - \\eta)}, \\quad\nk_{\\text{on},43}^{\\text{eff}} = k_{\\text{on}}.\n$$\n\n- 对于固定的模块划分 $\\{\\{1,2\\}, \\{3,4\\}\\}$，网络的模块化分数 $Q$ 使用加权无向网络的 Newman–Girvan 模块化方法计算。构建一个加权邻接矩阵 $W \\in \\mathbb{R}^{4 \\times 4}$，其元素是稳态 $x^\\star$ 下生产输入对其调控子的绝对灵敏度：\n$$\nW_{21} = s_2 \\left|\\frac{dO_{21}}{dx_1}\\Big|_{x^\\star}\\right|, \\quad\nW_{32} = s_3 \\left|\\frac{d(1 - O_{32})}{dx_2}\\Big|_{x^\\star}\\right| = s_3 \\left|\\frac{dO_{32}}{dx_2}\\Big|_{x^\\star}\\right|, \\quad\nW_{43} = s_4 \\left|\\frac{dO_{43}}{dx_3}\\Big|_{x^\\star}\\right|.\n$$\n所有其他元素为零。将 $W$ 对称化为 $A = (W + W^\\top)/2$。令 $k_i = \\sum_j A_{ij}$ 且 $2m = \\sum_i k_i$。对于划分 $c_1 = c_2 = 0$ 和 $c_3 = c_4 = 1$，模块化分数为\n$$\nQ = \\frac{1}{2m} \\sum_{i=1}^4 \\sum_{j=1}^4 \\left[A_{ij} - \\frac{k_i k_j}{2m}\\right]\\mathbf{1}(c_i = c_j),\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数。\n\n- 吸引子的鲁棒性被量化为在参数扰动下，稳态吸引子的定性特性保持不变的比例（表示为 $[0,1]$ 内的小数）。通过稳态下模块输出之差的符号来定义吸引子特性，$\\sigma = \\operatorname{sign}(x_2^\\star - x_4^\\star) \\in \\{-1, 0, +1\\}$，如果扰动后和基线均为零，则零被视为未翻转。对于每种配置（无绝缘 $\\eta = 0$ 和有绝缘 $\\eta  0$），计算基线 $\\sigma$，然后抽样 $N$ 个扰动，每个扰动都从区间 $[0.9, 1.1]$ 中为 $k_{\\text{on}}$、$k_{\\text{off}}$ 和 $\\alpha$ 抽取独立的乘法因子。鲁棒性是这 $N$ 次扰动模拟中产生与基线相同 $\\sigma$ 的比例。\n\n你的任务：\n\n1. 实现上述模型，通过对常微分方程进行数值积分来计算稳态 $x^\\star$（以无量纲单位表示）。\n\n2. 对每种配置，使用在 $x^\\star$ 处评估的基于灵敏度的权重计算 $Q$。\n\n3. 对每种配置，计算所定义的鲁棒性分数。\n\n4. 对于相同的反向活性 $r$，比较无绝缘配置（设置 $\\eta = 0$）和有绝缘配置（对每个测试用例使用指定的 $\\eta$）。\n\n对所有测试用例使用以下固定参数：$p_1 = 1.0$, $b_2 = 0.05$, $s_2 = 0.95$, $b_3 = 0.20$, $s_3 = 0.80$, $b_4 = 0.05$, $s_4 = 0.95$, $\\alpha_1 = \\alpha$, $\\alpha_2 = \\alpha$, $\\alpha_3 = \\alpha$, $\\alpha_4 = \\alpha$，以及对所有 $i$ 均有 $\\delta_i = \\delta$。除非另有说明，使用 $h = 2$，并将所有变量和参数视为无量纲。\n\n测试套件：\n\n- 情况1（一般情况）：$(k_{\\text{on}} = 1.0, k_{\\text{off}} = 0.5, \\alpha = 3.0, h = 2, \\delta = 1.0, r = 1.0, \\eta = 0.7)$。\n- 情况2（高反向活性负载）：$(k_{\\text{on}} = 1.0, k_{\\text{off}} = 0.5, \\alpha = 3.0, h = 2, \\delta = 1.0, r = 5.0, \\eta = 0.7)$。\n- 情况3（无反向活性基线）：$(k_{\\text{on}} = 1.0, k_{\\text{off}} = 0.5, \\alpha = 3.0, h = 2, \\delta = 1.0, r = 0.0, \\eta = 0.7)$。\n\n数值要求：\n\n- 使用合适的刚性求解器积分至稳态，并使用足够的时长和容差以确保所有测试用例都能达到收敛。\n- 对于鲁棒性，使用 $N=24$ 个扰动，其中 $k_{\\text{on}}$、$k_{\\text{off}}$ 和 $\\alpha$ 的乘法因子在 $[0.9, 1.1]$ 内。将鲁棒性表示为小数。\n\n最终输出格式：\n\n你的程序应生成单行输出，包含一个每个案例结果的列表，其中每个案例结果本身是四个浮点数的列表：$[Q_{\\text{no}}, Q_{\\text{with}}, R_{\\text{no}}, R_{\\text{with}}]$，其中 $Q_{\\text{no}}$ 是无绝缘时的模块化分数，$Q_{\\text{with}}$ 是有绝缘时的模块化分数，$R_{\\text{no}}$ 是无绝缘时的鲁棒性，$R_{\\text{with}}$ 是有绝缘时的鲁棒性。例如，打印为\n$$\n[[Q_{\\text{no},1}, Q_{\\text{with},1}, R_{\\text{no},1}, R_{\\text{with},1}],[Q_{\\text{no},2}, Q_{\\text{with},2}, R_{\\text{no},2}, R_{\\text{with},2}], [Q_{\\text{no},3}, Q_{\\text{with},3}, R_{\\text{no},3}, R_{\\text{with},3}]].\n$$\n所有值都是无量纲的，应打印为不带单位的原始浮点数。", "solution": "该问题的解决方案涉及数值模拟和分析一个四基因调控网络，以比较有无“绝缘模块”时系统的模块化和鲁棒性。以下是求解的详细步骤。\n\n**1. 模型实现**\n\n首先，我们实现描述系统动力学的常微分方程（ODE）组。该系统包含四个变量 $x_1, x_2, x_3, x_4$。\n\n- **ODE 系统**:\n  $$\n  \\frac{dx_i}{dt} = \\alpha_i \\, F_i(x) - \\delta_i x_i\n  $$\n  其中调控函数 $F_i(x)$ 和启动子占有率 $O_{ij}(x_j)$ 根据问题描述中给出的公式定义。关键在于正确实现受反向活性和绝缘效率 $\\eta$ 影响的项，即 $k_{\\text{on},32}^{\\text{eff}}(\\eta) = \\frac{k_{\\text{on}}}{1 + r(1 - \\eta)}$，这会影响 $O_{32}(x_2)$ 的计算。\n\n**2. 计算稳态 ($x^\\star$)**\n\n为计算模块化和鲁棒性，我们首先需要找到系统的稳态浓度 $x^\\star$。\n\n- **数值积分**: 由于方程的非线性，我们通过对ODE系统进行数值积分来找到稳态。我们选择一个刚性ODE求解器（如Python `scipy.integrate.solve_ivp` 中的 `LSODA` 方法），从初始条件 $x_i(0)=0$ 开始，积分足够长的时间（例如 $t_{end}=500$），以确保系统达到平衡。积分终点的解 $x(t_{end})$ 即为稳态 $x^\\star$。\n\n**3. 计算模块化分数 ($Q$)**\n\n在得到稳态 $x^\\star$ 后，我们根据Newman-Girvan方法计算模块化分数 $Q$。\n\n1.  **计算权重**: 根据问题中定义的公式，计算在 $x^\\star$ 处的相互作用权重 $W_{21}$, $W_{32}$, 和 $W_{43}$。这需要计算启动子占有率函数对调控子浓度的导数，并在 $x^\\star$ 处求值。\n2.  **构建邻接矩阵**: 使用权重构建对称邻接矩阵 $A = (W + W^\\top)/2$。\n3.  **计算 $Q$ 值**: 利用给定的模块划分（$c_1=c_2=0$, $c_3=c_4=1$）和模块化公式，计算 $Q$ 值。这需要计算每个节点的度 $k_i$ 和总权重 $2m$。\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left[A_{ij} - \\frac{k_i k_j}{2m}\\right]\\mathbf{1}(c_i = c_j)\n$$\n\n**4. 计算鲁棒性 ($R$)**\n\n鲁棒性 $R$ 被量化为在参数扰动下，系统吸引子定性特性保持不变的频率。\n\n1.  **确定基线特性**: 对于给定的参数配置（包括 $\\eta$），计算基线稳态 $x_{base}^\\star$，并确定基线吸引子特性 $\\sigma_{base} = \\operatorname{sign}(x_{2,base}^\\star - x_{4,base}^\\star)$。\n2.  **生成扰动**: 生成 $N=24$ 组独立的乘法扰动因子 $(\\gamma_{k_{\\text{on}}}, \\gamma_{k_{\\text{off}}}, \\gamma_{\\alpha})$，每个因子都从均匀分布 $U[0.9, 1.1]$ 中抽取。\n3.  **循环模拟**:\n    - 对于每一组扰动因子，创建一个新的扰动参数集（例如 $k_{\\text{on,pert}} = k_{\\text{on}} \\cdot \\gamma_{k_{\\text{on}}}$）。\n    - 使用这个扰动参数集计算新的稳态 $x_{pert}^\\star$。\n    - 计算新的吸引子特性 $\\sigma_{pert} = \\operatorname{sign}(x_{2,pert}^\\star - x_{4,pert}^\\star)$。\n    - 比较 $\\sigma_{pert}$ 和 $\\sigma_{base}$。如果它们相等（将符号为0的情况视为相等），则记为一次成功。\n4.  **计算比例**: 鲁棒性 $R$ 是成功次数除以总扰动次数 $N$。\n\n**5. 最终比较**\n\n对于每个测试用例，上述整个过程将执行两次：\n- **无绝缘**: 设置 $\\eta=0$，计算 $Q_{\\text{no}}$ 和 $R_{\\text{no}}$。\n- **有绝缘**: 使用题目中指定的 $\\eta > 0$ 值，计算 $Q_{\\text{with}}$ 和 $R_{\\text{with}}$。\n\n为了确保公平比较，在计算 $R_{\\text{no}}$ 和 $R_{\\text{with}}$ 时，应使用同一组预先生成的 $N=24$ 个扰动因子。最后，将结果按照指定格式输出。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom typing import List, Dict, Any, Tuple\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    # Use a fixed seed for reproducibility of robustness calculations\n    np.random.seed(0)\n\n    # Fixed parameters for all test cases\n    base_params = {\n        'p1': 1.0, 'b2': 0.05, 's2': 0.95, 'b3': 0.20, 's3': 0.80, \n        'b4': 0.05, 's4': 0.95\n    }\n\n    test_cases = [\n        # Case 1: general case\n        {'kon': 1.0, 'koff': 0.5, 'alpha': 3.0, 'h': 2.0, 'delta': 1.0, 'r': 1.0, 'eta_val': 0.7},\n        # Case 2: high retroactivity load\n        {'kon': 1.0, 'koff': 0.5, 'alpha': 3.0, 'h': 2.0, 'delta': 1.0, 'r': 5.0, 'eta_val': 0.7},\n        # Case 3: no retroactivity baseline\n        {'kon': 1.0, 'koff': 0.5, 'alpha': 3.0, 'h': 2.0, 'delta': 1.0, 'r': 0.0, 'eta_val': 0.7}\n    ]\n\n    N_robustness = 24\n    all_results = []\n\n    for case_params in test_cases:\n        params = {**base_params, **case_params}\n        \n        # Pre-generate perturbations for this case to ensure fair comparison\n        # between no-insulation and with-insulation scenarios.\n        perturbation_factors = np.random.uniform(0.9, 1.1, size=(N_robustness, 3))\n\n        # --- No Insulation ---\n        params_no_ins = params.copy()\n        params_no_ins['eta'] = 0.0\n        x_star_no = find_steady_state(params_no_ins)\n        Q_no = calculate_modularity(x_star_no, params_no_ins)\n        R_no = calculate_robustness(params_no_ins, perturbation_factors, N_robustness)\n\n        # --- With Insulation ---\n        params_with_ins = params.copy()\n        params_with_ins['eta'] = params['eta_val']\n        x_star_with = find_steady_state(params_with_ins)\n        Q_with = calculate_modularity(x_star_with, params_with_ins)\n        R_with = calculate_robustness(params_with_ins, perturbation_factors, N_robustness)\n        \n        all_results.append([Q_no, Q_with, R_no, R_with])\n\n    # Format output as specified\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_string = f\"[{','.join(inner_strings)}]\"\n    print(final_string)\n\ndef odes(t: float, x: np.ndarray, p: Dict[str, Any]) - List[float]:\n    \"\"\"Defines the system of ODEs.\"\"\"\n    x1, x2, x3, x4 = x\n    \n    # Effective association rates\n    kon_21_eff = p['kon']\n    kon_32_eff = p['kon'] / (1.0 + p['r'] * (1.0 - p['eta']))\n    kon_43_eff = p['kon']\n\n    # Effective dissociation constants (K^h)\n    Kh_21 = p['koff'] / kon_21_eff\n    Kh_32 = p['koff'] / kon_32_eff\n    Kh_43 = p['koff'] / kon_43_eff\n\n    # Promoter occupancies (handle potential x0 from solver)\n    x1h = np.power(max(0, x1), p['h'])\n    x2h = np.power(max(0, x2), p['h'])\n    x3h = np.power(max(0, x3), p['h'])\n\n    O_21 = x1h / (Kh_21 + x1h) if (Kh_21 + x1h)  0 else 0\n    O_32 = x2h / (Kh_32 + x2h) if (Kh_32 + x2h)  0 else 0\n    O_43 = x3h / (Kh_43 + x3h) if (Kh_43 + x3h)  0 else 0\n\n    # Regulatory inputs\n    F1 = p['p1']\n    F2 = p['b2'] + p['s2'] * O_21\n    F3 = p['b3'] + p['s3'] * (1.0 - O_32)\n    F4 = p['b4'] + p['s4'] * O_43\n\n    # ODEs\n    dx1dt = p['alpha'] * F1 - p['delta'] * x1\n    dx2dt = p['alpha'] * F2 - p['delta'] * x2\n    dx3dt = p['alpha'] * F3 - p['delta'] * x3\n    dx4dt = p['alpha'] * F4 - p['delta'] * x4\n    \n    return [dx1dt, dx2dt, dx3dt, dx4dt]\n\ndef find_steady_state(p: Dict[str, Any]) - np.ndarray:\n    \"\"\"Finds the steady state by integrating the ODEs.\"\"\"\n    x0 = [0.0, 0.0, 0.0, 0.0]\n    t_span = [0, 500] # Long integration time to ensure convergence\n    sol = solve_ivp(\n        fun=odes,\n        t_span=t_span,\n        y0=x0,\n        method='LSODA',\n        args=(p,),\n        dense_output=True,\n        atol=1e-8,\n        rtol=1e-8\n    )\n    return sol.y[:, -1]\n\ndef calculate_modularity(x_star: np.ndarray, p: Dict[str, Any]) - float:\n    \"\"\"Calculates the Newman-Girvan modularity score Q.\"\"\"\n    x1, x2, x3, _ = x_star\n    h = p['h']\n\n    # Effective association rates\n    kon_21_eff = p['kon']\n    kon_32_eff = p['kon'] / (1.0 + p['r'] * (1.0 - p['eta']))\n    kon_43_eff = p['kon']\n\n    # Effective dissociation constants (K^h)\n    Kh_21 = p['koff'] / kon_21_eff\n    Kh_32 = p['koff'] / kon_32_eff\n    Kh_43 = p['koff'] / kon_43_eff\n\n    # Derivatives of occupancy functions at steady state\n    dO_21_dx1 = (h * Kh_21 * np.power(max(0, x1), h - 1)) / np.power(Kh_21 + np.power(max(0, x1), h), 2)\n    dO_32_dx2 = (h * Kh_32 * np.power(max(0, x2), h - 1)) / np.power(Kh_32 + np.power(max(0, x2), h), 2)\n    dO_43_dx3 = (h * Kh_43 * np.power(max(0, x3), h - 1)) / np.power(Kh_43 + np.power(max(0, x3), h), 2)\n\n    # Weights of the interaction graph\n    W21 = p['s2'] * abs(dO_21_dx1)\n    W32 = p['s3'] * abs(dO_32_dx2)\n    W43 = p['s4'] * abs(dO_43_dx3)\n\n    if W21 + W32 + W43 == 0:\n        return 0.0 # No edges, modularity is ill-defined but 0 is a sensible value.\n\n    # Modularity calculation using the community formula\n    m_total = (W21 + W32 + W43) / 2.0\n    \n    # Module A: {1, 2}\n    L_A = W21 / 2.0\n    K_A = W21 + W32 / 2.0\n    Q_A = (L_A / m_total) - (K_A / (2 * m_total))**2\n    \n    # Module B: {3, 4}\n    L_B = W43 / 2.0\n    K_B = W43 + W32 / 2.0\n    Q_B = (L_B / m_total) - (K_B / (2 * m_total))**2\n    \n    return Q_A + Q_B\n\ndef calculate_robustness(base_p: Dict[str, Any], perturbations: np.ndarray, N: int) - float:\n    \"\"\"Calculates the attractor robustness.\"\"\"\n    x_star_base = find_steady_state(base_p)\n    sigma_base = np.sign(x_star_base[1] - x_star_base[3])\n    \n    success_count = 0\n    for i in range(N):\n        gamma_kon, gamma_koff, gamma_alpha = perturbations[i]\n        \n        p_pert = base_p.copy()\n        p_pert['kon'] *= gamma_kon\n        p_pert['koff'] *= gamma_koff\n        p_pert['alpha'] *= gamma_alpha\n        \n        x_star_pert = find_steady_state(p_pert)\n        sigma_pert = np.sign(x_star_pert[1] - x_star_pert[3])\n        \n        if sigma_pert == sigma_base:\n            success_count += 1\n            \n    return success_count / N\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3305370"}]}