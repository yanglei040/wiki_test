{"hands_on_practices": [{"introduction": "本练习旨在构建您执行通量平衡分析（FBA）的核心能力。您将学习如何将一个给定的代谢网络转化为一个线性规划问题，以预测其最优生长速率。此外，本练习还解决了一个在基因组重建中常见的现实挑战——模型不完整；您将通过实现一个“补洞”（gap-filling）算法，系统性地添加缺失的反应以恢复模型的生物学功能，从而掌握代谢模型修复的一项基本技能 ([@problem_id:3312957])。", "problem": "给定一个小型的稳态代谢网络，您需要执行流平衡分析（Flux Balance Analysis, FBA）来计算一个最优通量分布，该分布在满足质量平衡约束和通量边界的条件下最大化生物量。如果需要，您还必须通过添加一组最少的候选反应来进行缺口填充，以使目标生物量产量超过给定阈值。此任务的基础是稳态下的化学计量质量平衡，其约束为 $S v = 0$，其中 $S$ 是化学计量矩阵，$v$ 是通量向量，同时反应通量还需满足边界条件 $l \\le v \\le u$。流平衡分析（FBA）是一种线性优化方法，用于在这些约束下最大化生物量通量，而缺口填充是在这些约束下通过添加反应来恢复模型功能的过程。\n\n定义和假设：\n- 化学计量矩阵 $S$ 的行对应内部代谢物，列对应反应。每个反应列包含代谢物的化学计量系数，消耗为负，产生为正。\n- 代谢物摄取的交换反应表示为列向量，其中内部代谢物的化学计量系数为负（例如，$EX\\_A$ 中代谢物 $A$ 的系数为 $-1$，其余为 $0$），通量边界设置为允许摄取为负通量：下界 $\\le 0$ 且上界 $= 0$。\n- 生物量反应表示为一个消耗生物量前体的列。对于下面的微型网络，生物量反应消耗代谢物 $C$，其对 $C$ 的化学计量系数为 $-1$。\n- 所有通量必须以毫摩尔/克干重/小时（缩写为 $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$）表示。您的输出应四舍五入到四位小数。\n- 反应索引使用从 $0$ 开始的编号。\n\n您必须实现一个程序，为每个测试用例执行以下操作：\n1. 通过添加最少数量的候选反应（如果需要）来进行缺口填充，以实现生物量产量超过阈值 $\\tau$。\n2. 使用线性规划，在 $S v = 0$ 和边界 $l \\le v \\le u$ 的约束下，通过最大化生物量反应通量来计算最优通量分布 $v^*$。\n3. 验证并返回布尔值，指明 $S v^* = 0$ 是否在容差范围内满足，以及边界约束是否满足。\n4. 为每个测试用例返回一个包含四个条目的列表：最优生物量通量（四舍五入到四位小数，单位为 $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$）、质量平衡一致性的布尔值、边界一致性的布尔值，以及添加的候选反应的索引列表（使用从 $0$ 开始的索引）。\n\n测试套件规范：\n所有代谢物均为 $A$、$B$、$C$（三种内部代谢物）。对于每个用例，基础网络包含一组具有指定化学计量和边界的反应。在缺口填充期间可以添加候选反应。在每个测试用例中，生物量反应索引始终是最后一个基础反应的索引。\n\n- 用例 $1$（已功能完整的网络）：\n  - 基础反应（$S$ 的列）和边界：\n    - $EX\\_A$：化学计量 $[-1, 0, 0]$，边界 $[-3, 0]$。\n    - $R1$：化学计量 $[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $R2$：化学计量 $[0, -1, +1]$，边界 $[0, 1000]$。\n    - $Biomass$：化学计量 $[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：\n    - $R\\_{alt}$：化学计量 $[-1, 0, +1]$，边界 $[0, 1000]$。\n  - 生物量反应索引：$3$。\n  - 阈值 $\\tau$：$2.0$。\n\n- 用例 $2$（缺少一个必须添加的反应）：\n  - 基础反应：\n    - $EX\\_A$：$[-1, 0, 0]$，边界 $[-2, 0]$。\n    - $R1$：$[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $Biomass$：$[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：\n    - $R2$：$[0, -1, +1]$，边界 $[0, 1000]$。\n  - 生物量反应索引：$2$。\n  - 阈值 $\\tau$：$1.5$。\n\n- 用例 $3$（需要添加两个反应）：\n  - 基础反应：\n    - $EX\\_A$：$[-1, 0, 0]$，边界 $[-1.5, 0]$。\n    - $Biomass$：$[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：\n    - $R1$：$[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $R2$：$[0, -1, +1]$，边界 $[0, 1000]$。\n  - 生物量反应索引：$1$。\n  - 阈值 $\\tau$：$1.0$。\n\n- 用例 $4$（边界情况，不允许摄取；无法生长）：\n  - 基础反应：\n    - $EX\\_A$：$[-1, 0, 0]$，边界 $[0, 0]$。\n    - $R1$：$[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $R2$：$[0, -1, +1]$，边界 $[0, 1000]$。\n    - $Biomass$：$[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：无。\n  - 生物量反应索引：$3$。\n  - 阈值 $\\tau$：$0.1$。\n\n算法要求：\n- 将FBA表述为一个线性规划问题，在 $S v = 0$ 和 $l \\le v \\le u$ 的约束下最大化生物量通量。除线性规划外，不得使用任何捷径，并必须确保数值稳定性。\n- 对于缺口填充，应按基数递增的顺序搜索候选反应的子集，以找到能使最优生物量通量严格大于阈值 $\\tau$ 的最小集合。如果多个相同基数的子集满足阈值，选择能产生最高最优生物量通量的那个。如果没有任何子集满足阈值，则选择空子集，并仅为基础网络计算最优通量分布。\n- 通过计算质量平衡残差的无穷范数 $||S v^*||_\\infty$ 并检查其是否低于 $10^{-8}$ 的容差来验证与约束的一致性。同时验证所有边界是否在 $10^{-8}$ 的容差内得到满足。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也编码为一个列表：$[biomass,mb\\_ok,bounds\\_ok,[added\\_indices]]$。例如：$[[3.0000,True,True,[]],[2.0000,True,True,[0]],...]$。所有通量值必须以 $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$ 为单位，并四舍五入到四位小数。布尔值必须是精确的逻辑值。添加的索引列表必须使用从 $0$ 开始的索引。", "solution": "该问题要求在计算系统生物学中实现两种基本算法：流平衡分析（FBA）和模型缺口填充。目标是确定给定网络的最优代谢通量分布，以最大化生物量产量，这可能需要在满足指定产量阈值后，从候选池中增补一组最少的反应来增强网络。\n\n### 原理一：质量平衡与稳态\n\nFBA的核心是质量守恒原理。对于一个在稳态下运行的代谢网络，每种内部代谢物的浓度保持不变。这意味着对于每种代谢物，其总产生速率必须等于其总消耗速率。这个约束可以用一个线性方程组来数学化地表达：\n$$\nS v = 0\n$$\n其中 $S$ 是大小为 $m \\times n$（$m$ 种代谢物，$n$ 个反应）的化学计量矩阵， $v$ 是大小为 $n \\times 1$ 的反应通量（速率）向量。矩阵中的每个元素 $S_{ij}$ 代表代谢物 $i$ 在反应 $j$ 中的化学计量系数。按照惯例，负系数（$S_{ij} < 0$）表示消耗，正系数（$S_{ij} > 0$）表示产生。向量方程 $S v = 0$ 确保了没有任何内部代谢物的净积累或耗尽。\n\n### 原理二：作为线性规划的流平衡分析（FBA）\n\n虽然稳态假设约束了可能的通量分布，但它通常不能定义一个唯一的解。满足 $S v = 0$ 的可行通量向量空间进一步受到热力学和容量限制的约束，这些限制表示为单个通量的下界和上界：\n$$\nl \\le v \\le u\n$$\n其中 $l$ 和 $u$ 分别是下界和上界向量。例如，一个不可逆反应的下界为 $0$。一个允许从环境中摄取营养物质的交换反应将有一个负的下界（例如，$v_{\\text{uptake}} \\in [-10, 0]$）。\n\nFBA使用线性规划（LP）从可行集中找到一个特定的、具有生物学意义的通量分布。这是通过优化一个目标函数来实现的，该目标函数通常是“生物量反应”的通量。这个反应是一个建模构件，通过消耗按实验测量比例得出的前体代谢物来模拟细胞生物量的产生。最大化其通量被认为等同于最大化生物体的生长速率。\n\n因此，FBA问题被表述为以下LP问题：\n$$\n\\begin{align*}\n\\text{最大化} \\quad & c^T v \\\\\n\\text{约束于} \\quad & S v = 0 \\\\\n& l \\le v \\le u\n\\end{align*}\n$$\n这里， $c$ 是目标向量，在对应于生物量反应的位置上为 $1$，其他位置为 $0$。\n\n### 原理三：模型缺口填充\n\n从基因组数据重建的代谢网络通常是不完整的，含有“缺口”（缺失的反应），这会妨碍模型模拟已知的生物学功能，例如产生生物量。缺口填充是一个计算过程，旨在从一个通用数据库（或指定的候选池）中识别出一组最少的反应，并将其添加到模型中以恢复所需功能。\n\n这个问题可以被构建为一个组合优化问题。我们寻求候选反应的最小子集，当添加到基础模型中时，能使生物量通量超过给定的阈值 $\\tau$。问题中指定的算法方法是基于简约性（最小性）原理的系统性搜索：\n\n1.  从 $k=0$ 开始，对添加的反应集基数 $k$ 进行搜索。\n2.  对于给定的 $k$，测试来自候选池中所有可能的 $k$ 个反应的组合。\n3.  对于每种组合，用所选反应扩充基础模型，并执行FBA以计算最大生物量通量。\n4.  如果任何组合的生物量通量超过 $\\tau$，则 $k$ 是最小基数。搜索停止，在所有大小为 $k$ 的成功组合中，选择产生最高生物量通量的那个。\n5.  如果在任何 $k$ 值下都没有组合满足条件，则使用原始的、未扩充的基础模型。\n\n### 算法实现\n\n解决方案通过将这些原理组合成一个连贯的算法来实现。\n\n1.  **FBA求解器**：创建一个核心函数来求解FBA线性规划问题。它接受一个化学计量矩阵 $S$、边界向量 $l$ 和 $u$，以及生物量反应的索引作为输入。利用 `scipy.optimize.linprog` 库函数，它构建并求解LP问题。目标函数被设置为最小化 $-v_{\\text{biomass}}$ 以实现最大化。该函数返回最优生物量通量和相应的完整通量向量 $v^*$。\n\n2.  **缺口填充过程**：对每个测试用例，执行缺口填充逻辑。\n    - 算法首先分析基础网络（基数 $k=0$）。它运行FBA求解器并存储产生的生物量通量和通量向量。\n    - 它检查这个基础情况下的生物量通量是否大于阈值 $\\tau$。如果是，问题就解决了，因为添加的最小反应集是空集。\n    - 如果未达到阈值，算法继续搜索最小的非空集合。它遍历基数 $k=1, 2, \\dots$ 直到候选反应的总数。对于每个 $k$，使用 `itertools.combinations` 生成该大小的所有唯一候选反应子集。\n    - 对于每个子集，通过使用所选候选反应的 $S$ 矩阵和边界向量来扩充基础模型，从而构建一个临时的模型。然后在这个临时模型上调用FBA求解器。\n    - 如果产生的生物量通量超过 $\\tau$，则存储结果（生物量值、通量向量和添加的反应索引）。\n    - 在测试完给定 $k$ 的所有组合后，如果其中有任何组合满足了阈值，则选择产生最大生物量的那个作为最终解，并终止搜索。这遵循了先满足最小基数，再满足最大化目标的双重标准。\n    - 如果对所有 $k$ 的搜索完成但没有找到解决方案，则保留基础网络的初始结果作为最终答案。\n\n3.  **验证与输出**：一旦确定了最优配置（基础或缺口填充）及其对应的通量向量 $v^*$，就按要求执行两次验证检查。\n    - 通过计算残差向量 $Sv^*$ 并检查其无穷范数 $||Sv^*||_\\infty$ 是否小于容差 $10^{-8}$ 来验证质量平衡约束。\n    - 通过检查每个通量 $v_i^*$ 是否位于其相应的边界 $[l_i, u_i]$ 内（允许相同的数值容差 $10^{-8}$）来验证边界约束。\n    - 收集每个用例的最终结果，包括四舍五入的最优生物量、两个布尔验证标志以及排序后的添加候选索引列表。最终输出被格式化为指定的字符串表示形式。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\nclass FormattedFloat:\n    \"\"\"A wrapper for floats to control their string representation for printing.\"\"\"\n    def __init__(self, value, precision=4):\n        self.value = value\n        self.precision = precision\n\n    def __repr__(self):\n        return f\"{self.value:.{self.precision}f}\"\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and format the results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Functional network\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n                \"bounds\": [(-3, 0), (0, 1000), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[-1], [0], [1]],\n                \"bounds\": [(0, 1000)]\n            },\n            \"biomass_idx\": 3,\n            \"tau\": 2.0\n        },\n        # Case 2: Missing one reaction\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0], [0, 1, 0], [0, 0, -1]],\n                \"bounds\": [(-2, 0), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[0], [-1], [1]],\n                \"bounds\": [(0, 1000)]\n            },\n            \"biomass_idx\": 2,\n            \"tau\": 1.5\n        },\n        # Case 3: Requires two reactions\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, 0], [0, 0], [0, -1]],\n                \"bounds\": [(-1.5, 0), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[-1, 0], [1, -1], [0, 1]],\n                \"bounds\": [(0, 1000), (0, 1000)]\n            },\n            \"biomass_idx\": 1,\n            \"tau\": 1.0\n        },\n        # Case 4: No uptake, no growth\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n                \"bounds\": [(0, 0), (0, 1000), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": None,\n            \"biomass_idx\": 3,\n            \"tau\": 0.1\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        # Use FormattedFloat for custom number formatting within the list structure\n        r[0] = FormattedFloat(r[0])\n        result_strings.append(str(r).replace(\"'\", \"\").replace(\" \", \"\"))\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef _run_fba(S, bounds, obj_idx):\n    \"\"\"Performs Flux Balance Analysis using linear programming.\"\"\"\n    num_rxns = S.shape[1]\n    # Objective: maximize flux through obj_idx, which is min(-flux)\n    c = np.zeros(num_rxns)\n    c[obj_idx] = -1\n    \n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n    \n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if res.success:\n        # Return positive biomass flux and the full flux vector\n        return -res.fun, res.x\n    else:\n        # If optimization fails, assume zero flux\n        return 0.0, np.zeros(num_rxns)\n\ndef _process_case(case_data):\n    \"\"\"\n    Handles gap-filling and FBA for a single test case.\n    \"\"\"\n    base_stoichiometry = np.array(case_data[\"base_reactions\"][\"stoichiometry\"], dtype=float)\n    base_bounds = case_data[\"base_reactions\"][\"bounds\"]\n    \n    if case_data[\"candidate_reactions\"]:\n        candidate_stoichiometry = np.array(case_data[\"candidate_reactions\"][\"stoichiometry\"], dtype=float)\n        candidate_bounds = case_data[\"candidate_reactions\"][\"bounds\"]\n        num_candidates = candidate_stoichiometry.shape[1]\n    else:\n        candidate_stoichiometry = np.empty((base_stoichiometry.shape[0], 0))\n        candidate_bounds = []\n        num_candidates = 0\n\n    biomass_idx = case_data[\"biomass_idx\"]\n    tau = case_data[\"tau\"]\n    \n    # 1. Analyze the base network (k=0)\n    base_biomass, base_v = _run_fba(base_stoichiometry, base_bounds, biomass_idx)\n    \n    best_result = {\n        \"biomass\": base_biomass,\n        \"v\": base_v,\n        \"added_indices\": [],\n        \"S\": base_stoichiometry,\n        \"bounds\": base_bounds\n    }\n\n    # If base network is sufficient, we are done with gap-filling\n    if base_biomass > tau + 1e-9:\n        pass\n    else:\n        # 2. Perform gap-filling for k=1, 2, ...\n        for k in range(1, num_candidates + 1):\n            candidate_indices_combinations = combinations(range(num_candidates), k)\n            solutions_at_k = []\n            \n            for combo_indices in candidate_indices_combinations:\n                added_S = candidate_stoichiometry[:, combo_indices]\n                added_bounds = [candidate_bounds[i] for i in combo_indices]\n                \n                S_new = np.hstack((base_stoichiometry, added_S))\n                bounds_new = base_bounds + added_bounds\n                \n                # Biomass index is unchanged as candidates are appended\n                biomass, v = _run_fba(S_new, bounds_new, biomass_idx)\n                \n                if biomass > tau + 1e-9:\n                    solutions_at_k.append({\n                        \"biomass\": biomass,\n                        \"v\": v,\n                        \"added_indices\": list(combo_indices),\n                        \"S\": S_new,\n                        \"bounds\": bounds_new\n                    })\n            \n            if solutions_at_k:\n                # Minimal set size k found. Select the best among them.\n                best_at_k = max(solutions_at_k, key=lambda x: x[\"biomass\"])\n                best_result = best_at_k\n                break  # Exit search since minimal k is found\n    \n    # 3. Verification of the final chosen solution\n    final_S = best_result[\"S\"]\n    final_v = best_result[\"v\"]\n    final_bounds = best_result[\"bounds\"]\n    \n    # Mass balance check: ||S*v||_inf  tol\n    mass_balance_residual = final_S @ final_v\n    mb_ok = np.all(np.abs(mass_balance_residual)  1e-8)\n    \n    # Bounds check: l - tol = v = u + tol\n    bounds_ok = True\n    for i, flux in enumerate(final_v):\n        lb, ub = final_bounds[i]\n        if lb is not None and flux  lb - 1e-8:\n            bounds_ok = False\n            break\n        if ub is not None and flux > ub + 1e-8:\n            bounds_ok = False\n            break\n    \n    # 4. Format and return the result for this case\n    return [\n        best_result[\"biomass\"],\n        mb_ok,\n        bounds_ok,\n        sorted(best_result[\"added_indices\"])\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3312957"}, {"introduction": "一个标准的FBA模型若仅基于质量守恒，有时会产生物理上不可能的预测，例如无中生有地产生能量。本练习聚焦于这样一种被称为“无效循环”（futile cycle）的人为产物，这在热力学上是不可行的。您将探索这些循环是如何在没有底物摄取的情况下由可逆反应产生的，并学习如何通过施加额外的热力学约束来消除它们，从而确保您的模型预测具有生物学意义 ([@problem_id:3308950])。", "problem": "给定一个小型、自洽的通量平衡分析（FBA）模型，该模型由于完全可逆的内部反应和零吸收而表现出热力学上不可行的三磷酸腺苷（ATP）生成循环。从基本的稳态质量平衡出发，任务是构建并求解一个线性优化问题，以证明在没有外部底物的情况下存在正的ATP产生，然后添加强制无环（热力学可行性）的约束，以消除不可行的循环，并量化由此导致的目标变化。\n\n基本原理：\n- 代谢物的稳态质量平衡：$$S v = 0,$$ 其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v \\in \\mathbb{R}^{n}$ 是反应通量，$m$ 是代谢物的数量，$n$ 是反应的数量。\n- 通量界限代表反应可逆性：$$l_i \\le v_i \\le u_i,$$ 其中 $l_i$ 和 $u_i$ 是反应 $i$ 的下界和上界，而 $l_i  0  u_i$ 表示可逆性。\n- 待最大化的线性目标：$$\\max_{v} \\; c_{\\text{ATP}}^\\top v,$$ 其中 $c_{\\text{ATP}}$ 选择与ATP相关的反应以衡量ATP的生产能力。\n\n模型定义：\n- 代谢物：三磷酸腺苷（ATP）、二磷酸腺苷（ADP）、无机磷酸盐（Pi）、胞质质子（$\\mathrm{H_c}$）和胞外质子（$\\mathrm{H_e}$）。\n- $S$中的反应和化学计量列：\n    1. ATP水解（可逆）：ATP $\\rightleftharpoons$ ADP + Pi。化学计量列 $S_{\\cdot,1}$ 对于 [ATP, ADP, Pi, $\\mathrm{H_c}$, $\\mathrm{H_e}$] 的条目为 $[-1, +1, +1, 0, 0]^\\top$。\n    2. ATP合酶（可逆，质子耦合）：ADP + Pi + $4\\,\\mathrm{H_e}$ $\\rightleftharpoons$ ATP + $4\\,\\mathrm{H_c}$。化学计量列 $S_{\\cdot,2}$ 的条目为 $[+1, -1, -1, +4, -4]^\\top$。\n    3. 质子泵/泄漏（可逆）：$\\mathrm{H_c}$ $\\rightleftharpoons$ $\\mathrm{H_e}$。化学计量列 $S_{\\cdot,3}$ 的条目为 $[0, 0, 0, -1, +1]^\\top$。\n\n目标定义：\n- 令 $c_{\\text{ATP}}$ 选择ATP水解反应，以衡量循环下的ATP合成能力。定义 $$c_{\\text{ATP}} = [-1, 0, 0]^\\top,$$ 这样最大化 $c_{\\text{ATP}}^\\top v$ 会促使 $v_1$（ATP水解）为负，这对应于通过循环合成ATP。\n\n无环（热力学可行性）约束：\n- 为了恢复热力学可行性并消除能量生成循环，通过约束强制反应方向性与生物学正向的负反应自由能一致\n  $$v_1 \\ge 0, \\quad v_2 \\ge 0, \\quad v_3 \\ge 0,$$\n  从而禁止该模型中能够产生不可行ATP生成循环的逆向反应。\n\n程序要求：\n- 为每个测试案例实现两个线性规划程序：\n    1. 无约束可逆情况：在约束 $S v = 0$ 和界限 $l_i \\le v_i \\le u_i$（其中 $l_i  0  u_i$）下最大化 $c_{\\text{ATP}}^\\top v$。\n    2. 无环约束情况：在约束 $S v = 0$ 和修改后的界限 $0 \\le v_i \\le u_i$（对所有 $i$）下最大化 $c_{\\text{ATP}}^\\top v$。\n- 对于每种情况，报告浮点数三元组 $[\\text{obj}_{\\text{rev}}, \\text{obj}_{\\text{loopless}}, \\Delta]$，其中 $\\text{obj}_{\\text{rev}}$ 是具有可逆界限时 $c_{\\text{ATP}}^\\top v$ 的最优值，$\\text{obj}_{\\text{loopless}}$ 是添加无环约束后的最优值，而 $\\Delta = \\text{obj}_{\\text{rev}} - \\text{obj}_{\\text{loopless}}$ 量化了因恢复热力学可行性而导致的目标损失。\n\n测试套件：\n提供以下四个测试案例，每个案例指定 $(v_1, v_2, v_3)$ 的下界 $l$ 和上界 $u$：\n\n- 案例1（理想情况，充分可逆）：$l = [-10, -10, -100]$, $u = [10, 10, 100]$。\n- 案例2（紧凑的可逆界限）：$l = [-1, -1, -4]$, $u = [1, 1, 4]$。\n- 案例3（边界情况，一个反应在正向上不可逆）：$l = [0, -10, -100]$, $u = [0, 10, 100]$。\n- 案例4（边缘情况，质子泵受限并约束循环）：$l = [-10, -10, -30]$, $u = [10, 10, 30]$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例的结果本身是一个包含三个浮点数的列表，顺序为 $[\\text{obj}_{\\text{rev}}, \\text{obj}_{\\text{loopless}}, \\Delta]$。例如：“[[v11,v12,v13],[v21,v22,v23],[v31,v32,v33],[v41,v42,v43]]”。不使用物理单位；所有通量和目标值均为纯浮点数。", "solution": "问题陈述已经过严格验证，被认为是有效的。这是一个在计算系统生物学领域，特别是通量平衡分析（FBA）领域中，具有科学依据、定义明确且客观的问题。该问题是自洽的，提供了所有必要的定义、数据和约束，以便为四个测试案例中的每一个构建和求解两个不同的线性优化问题。该模型虽然简化，但正确地代表了代谢建模中的一个已知伪影——热力学上不可行的能量生成循环——以及消除它们的标准方法。\n\n任务是为一个给定的代谢模型求解两个线性规划（LP）问题。该模型包含 $m=5$ 种代谢物和 $n=3$ 个反应。代谢物浓度与反应通量 $v \\in \\mathbb{R}^3$ 之间的关系由稳态质量平衡方程 $S v = 0$ 控制，其中 $S \\in \\mathbb{R}^{5 \\times 3}$ 是化学计量矩阵。\n\n反应如下：\n1. $v_1$: $\\text{ATP} \\rightleftharpoons \\text{ADP} + \\text{Pi}$\n2. $v_2$: $\\text{ADP} + \\text{Pi} + 4\\,\\mathrm{H_e} \\rightleftharpoons \\text{ATP} + 4\\,\\mathrm{H_c}$\n3. $v_3$: $\\mathrm{H_c} \\rightleftharpoons \\mathrm{H_e}$\n\n化学计量矩阵 $S$ 是基于这些反应构建的，其列对应于反应 $v_1, v_2, v_3$，行对应于代谢物 ATP, ADP, Pi, $\\mathrm{H_c}$ 和 $\\mathrm{H_e}$：\n$$\nS = \\begin{pmatrix}\n-1   1   0 \\\\\n 1  -1   0 \\\\\n 1  -1   0 \\\\\n 0   4  -1 \\\\\n 0  -4   1\n\\end{pmatrix}\n$$\n\n稳态条件 $S v = 0$ 定义了 $S$ 的零空间。零空间包含所有导致代谢物浓度无净变化的可行通量分布。$S$ 的分析显示其秩为 $2$。其零空间的维数为 $n - \\text{rank}(S) = 3 - 2 = 1$。找到零空间的一个基向量为 $[1, 1, 4]^\\top$。因此，任何稳态通量向量 $v$ 都必须是此基向量的标量倍数：\n$$v = k \\begin{pmatrix} 1 \\\\ 1 \\\\ 4 \\end{pmatrix}$$\n对于某个标量 $k \\in \\mathbb{R}$。这种关系描述了一组形成循环的耦合反应。一个正的 $k$ 对应于一个循环，其中ATP被水解（$v_10$）、合成（$v_20$）并且质子被泵出（$v_30$），导致一个没有净ATP产生的无效循环。一个负的 $k$ 对应于循环反向运行，正如问题所描述的，这可能导致虚假的ATP生成。\n\n目标是最大化ATP合成能力，其公式为最大化 $-v_1$。这等同于最小化 $v_1$。\n$$\\max_{v} \\ c_{\\text{ATP}}^\\top v \\quad \\text{其中} \\quad c_{\\text{ATP}} = [-1, 0, 0]^\\top$$\n这等同于最小化的标准LP形式：\n$$\\min_{v} \\ (-c_{\\text{ATP}})^\\top v = \\min_{v} \\ [1, 0, 0]^\\top v = \\min_{v} \\ v_1$$\n该问题在每个测试案例的两组约束条件下求解。\n\n**1. 无约束可逆情况**\n通量向量 $v$ 受稳态约束 $S v = 0$ 和可逆性界限 $l_i \\le v_i \\le u_i$ 的限制。将 $v = k [1, 1, 4]^\\top$ 代入界限，得到对 $k$ 的约束：\n$$l_1 \\le k \\le u_1$$\n$$l_2 \\le k \\le u_2$$\n$$l_3 \\le 4k \\le u_3 \\implies \\frac{l_3}{4} \\le k \\le \\frac{u_3}{4}$$\n为了使 $k$ 可行，它必须同时满足所有这些条件。因此，$k$ 的可行范围是：\n$$k \\in \\left[ \\max\\left(l_1, l_2, \\frac{l_3}{4}\\right), \\min\\left(u_1, u_2, \\frac{u_3}{4}\\right) \\right]$$\n目标是最小化 $v_1 = k$。最小值 $k_{\\text{min}}$ 是该区间的下界：\n$$k_{\\text{min}} = \\max\\left(l_1, l_2, \\frac{l_3}{4}\\right)$$\n最小化问题的最优目标值为 $v_{1,\\text{opt}} = k_{\\text{min}}$。问题要求最大化 $-v_1$，因此结果为 $\\text{obj}_{\\text{rev}} = -v_{1,\\text{opt}} = -k_{\\text{min}}$。\n$$\\text{obj}_{\\text{rev}} = -\\max\\left(l_1, l_2, \\frac{l_3}{4}\\right)$$\n如果下界 $l_i$ 为负，$k_{\\text{min}}$ 可以为负，导致 $v_1  0$（净ATP合成）和正的目标值，从而证明了热力学上不可行的能量生成循环。\n\n**2. 无环约束情况**\n为了强制热力学可行性，反应被约束为在其生物学正向上不可逆（$v_i \\ge 0$）。新的界限是 $0 \\le v_i \\le u_i$。这转化为对 $k$ 的以下约束：\n$$0 \\le k \\le u_1$$\n$$0 \\le k \\le u_2$$\n$$0 \\le 4k \\le u_3 \\implies 0 \\le k \\le \\frac{u_3}{4}$$\n$k$ 的可行范围变为：\n$$k \\in \\left[ 0, \\min\\left(u_1, u_2, \\frac{u_3}{4}\\right) \\right]$$\n目标是最小化 $v_1 = k$。在此范围内，$k$ 的最小值显然是 $k_{\\text{min}} = 0$。\n因此，$v_{1,\\text{opt}} = 0$，最优目标值为 $\\text{obj}_{\\text{loopless}} = -v_{1,\\text{opt}} = 0$。\n通过阻止循环反向运行（$k  0$），虚假的ATP生成被消除。唯一满足无环约束且可以被优化的稳态解是平凡解 $v = [0, 0, 0]^\\top$。\n\n目标值的变化 $\\Delta$ 仅为 $\\text{obj}_{\\text{rev}} - \\text{obj}_{\\text{loopless}} = \\text{obj}_{\\text{rev}} - 0 = \\text{obj}_{\\text{rev}}$。\n\n实现将使用 `scipy.optimize.linprog` 对每个测试案例进行数值求解这些线性规划问题，以验证分析结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of Flux Balance Analysis problems to demonstrate and then correct\n    a thermodynamically infeasible ATP-generating cycle.\n    \"\"\"\n\n    # Stoichiometric matrix S for the model.\n    # Rows: ATP, ADP, Pi, Hc, He\n    # Columns: v1 (ATP hydrolysis), v2 (ATP synthase), v3 (Proton pump)\n    S = np.array([\n        [-1,  1,  0],\n        [ 1, -1,  0],\n        [ 1, -1,  0],\n        [ 0,  4, -1],\n        [ 0, -4,  1]\n    ])\n\n    # Objective function vector c. We want to maximize -v1, which is equivalent\n    # to minimizing v1. scipy.optimize.linprog performs minimization.\n    # c_lp^T * v = 1*v1 + 0*v2 + 0*v3\n    c_lp = np.array([1, 0, 0])\n\n    # The steady-state constraint is Sv = 0.\n    b_eq = np.zeros(S.shape[0])\n\n    # Test cases defined by lower (l) and upper (u) flux bounds.\n    test_cases = [\n        # Case 1 (happy path, ample reversibility)\n        {'l': [-10, -10, -100], 'u': [10, 10, 100]},\n        # Case 2 (tight reversible bounds)\n        {'l': [-1, -1, -4], 'u': [1, 1, 4]},\n        # Case 3 (boundary, one reaction irreversible)\n        {'l': [0, -10, -100], 'u': [0, 10, 100]},\n        # Case 4 (edge, proton pump limited)\n        {'l': [-10, -10, -30], 'u': [10, 10, 30]},\n    ]\n\n    results = []\n    for case in test_cases:\n        l_bounds = case['l']\n        u_bounds = case['u']\n\n        # 1. Solve the unconstrained reversible case.\n        bounds_rev = list(zip(l_bounds, u_bounds))\n        res_rev = linprog(c=c_lp, A_eq=S, b_eq=b_eq, bounds=bounds_rev, method='highs')\n        \n        # The objective is max(-v1) = -min(v1). res.fun is min(v1).\n        # Handle potential infeasibility, though not expected for these cases.\n        obj_rev = -res_rev.fun if res_rev.success else float('nan')\n\n        # 2. Solve the loopless constrained case.\n        # Lower bounds are set to 0 to enforce forward-only reactions.\n        l_bounds_loopless = [0, 0, 0]\n        bounds_loopless = list(zip(l_bounds_loopless, u_bounds))\n        res_loopless = linprog(c=c_lp, A_eq=S, b_eq=b_eq, bounds=bounds_loopless, method='highs')\n        \n        obj_loopless = -res_loopless.fun if res_loopless.success else float('nan')\n\n        # 3. Calculate the difference.\n        delta = obj_rev - obj_loopless\n        \n        results.append([obj_rev, obj_loopless, delta])\n\n    # Format the final output string exactly as specified, without spaces.\n    outer_list_str = []\n    for res_list in results:\n        # Convert each float to a string; round to handle potential minor float inaccuracies.\n        # This also ensures a consistent \".0\" for integer-valued floats.\n        inner_list_str = f\"[{res_list[0]:.1f},{res_list[1]:.1f},{res_list[2]:.1f}]\"\n        # The problem cases result in .0 or .5, so .1f is clean and sufficient.\n        # A simple str() may produce more decimal places.\n        # Let's use `g` for general formatting to avoid trailing zeros for integers\n        inner_list_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        # The analytical results are simple floats. Let's trust python's default float-to-string conversion\n        # requested_floats = [float(x) for x in res_list]\n        inner_list_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n\n        outer_list_str.append(inner_list_str)\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    print(final_output.replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3308950"}, {"introduction": "最大化单一目标（如生物量）往往会得到一个宽泛的最优通量分布范围，而非一个唯一的解。本练习将向您介绍一种强大的方法——字典序优化（lexicographic optimization）——来精炼这些结果。您将实现一个序列化的FBA工作流程，该流程按优先级排列多个生物学目标：首先最大化生物量，然后是一种有价值的副产品，最后最小化总代谢投入，以此来确定一个唯一的、简约且更符合生物学现实的通量状态 ([@problem_id:3308964])。", "problem": "考虑一个通过流平衡分析 (FBA) 进行分析的稳态代谢网络。其基本原理是稳态下的质量守恒以及对反应速率的线性热力学约束。设 $S \\in \\mathbb{R}^{m \\times n}$ 为化学计量矩阵，连接 $m$ 种细胞内代谢物与 $n$ 个反应；设 $v \\in \\mathbb{R}^n$ 为反应通量向量。稳态质量平衡要求 $S v = 0$，其中每个 $v_i$ 都受到反映反应可逆性和容量的上下界约束，$L_i \\le v_i \\le U_i$。通量以 $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$ (毫摩尔每克干重每小时) 为单位；报告所有数值输出时，请使用这些单位，但不要显式打印单位字符串。目标是进行字典序多目标优化：首先最大化生物质生成速率，然后在保持先前达到的生物质最优值的同时最大化指定的产物分泌速率，最后通过最小化 $\\ell_1$ 范数 $\\sum_{i=1}^n |v_i|$ 来最小化总通量大小，以获得一个简约且生物学上合理的解。每个阶段都构建为一个线性规划 (LP) 问题。\n\n使用以下包含 $m=3$ 种代谢物和 $n=7$ 个反应的虚拟但科学上合理的网络。代谢物 $\\{X, Y, Z\\}$ 均在细胞内。反应如下：\n1. 吸收 $U$：外部来源 $\\rightarrow X$，\n2. 转化 $R2$：$X \\rightarrow Y$，\n3. 生物质 $BM$：$Y \\rightarrow$ 生物质 (伪代谢物)，\n4. 产物 $PR$：$Y \\rightarrow$ 产物 (输出)，\n5. 维持 $M$：$X \\rightarrow$ 维持消耗 (伪代谢物)，\n6. 无效循环正向 $Y2Z$：$Y \\rightarrow Z$，\n7. 无效循环逆向 $Z2Y$：$Z \\rightarrow Y$。\n\n设化学计量矩阵 $S$ 为\n$$\nS = \\begin{bmatrix}\n+1  -1  0  0  -1  0  0 \\\\\n0  +1  -1  -1  0  -1  +1 \\\\\n0  0  0  0  0  +1  -1\n\\end{bmatrix},\n$$\n按反应 $\\{U, R2, BM, PR, M, Y2Z, Z2Y\\}$ 的顺序列出。边界是反应特定的：对于每个反应 $i$，$L_i \\le v_i \\le U_i$。生物质目标向量为 $c_{\\text{bio}} \\in \\mathbb{R}^n$，其中 $c_{\\text{bio}} = (0,0,1,0,0,0,0)$；产物目标向量为 $c_{\\text{prod}} \\in \\mathbb{R}^n$，其中 $c_{\\text{prod}} = (0,0,0,1,0,0,0)$。\n\n为每个测试用例实现以下步骤：\n1. 求解线性规划以最大化 $c_{\\text{bio}}^\\top v$，约束条件为 $S v = 0$ 和边界。将最优生物质值记为 $z_1$，一个对应的最优通量记为 $v^{(1)}$。\n2. 添加等式约束 $c_{\\text{bio}}^\\top v = z_1$，然后求解线性规划以最大化 $c_{\\text{prod}}^\\top v$，约束条件为 $S v = 0$、边界和新增的等式。将最优产物值记为 $z_2$，一个对应的最优通量记为 $v^{(2)}$。\n3. 添加等式约束 $c_{\\text{bio}}^\\top v = z_1$ 和 $c_{\\text{prod}}^\\top v = z_2$，然后求解线性规划以最小化 $\\sum_{i=1}^n |v_i|$，约束条件为 $S v = 0$、边界和这两个等式。通过引入辅助变量 $s_i \\ge 0$ 并附加约束 $v_i - s_i \\le 0$ 和 $-v_i - s_i \\le 0$，将此问题构建为线性规划，并最小化 $\\sum_i s_i$。将得到的简约通量记为 $v^\\star$，其 $\\ell_1$ 范数记为 $\\|v^\\star\\|_1 = \\sum_i |v^\\star_i|$。\n\n测试套件。为确保覆盖率，通过改变部分边界来求解四个测试用例。在所有用例中，除非另有说明，反应边界为：\n- $0 \\le v_{R2} \\le 1000$，$0 \\le v_{BM} \\le 1000$，$0 \\le v_{PR} \\le 1000$，$0 \\le v_{Y2Z} \\le 1000$，$0 \\le v_{Z2Y} \\le 1000$。\n各用例特定边界：\n- 用例 1 (理想情况，生物质主导)：$0 \\le v_U \\le 10$，$2 \\le v_M \\le 1000$，$0 \\le v_{BM} \\le 1000$，$0 \\le v_{PR} \\le 1000$。\n- 用例 2 (生物质有上限；产物填充剩余容量)：$0 \\le v_U \\le 12$，$2 \\le v_M \\le 1000$，$0 \\le v_{BM} \\le 8$，$0 \\le v_{PR} \\le 1000$。\n- 用例 3 (产物被阻断)：$0 \\le v_U \\le 12$，$2 \\le v_M \\le 1000$，$0 \\le v_{BM} \\le 1000$，$0 \\le v_{PR} \\le 0$。\n- 用例 4 (无吸收，无维持)：$0 \\le v_U \\le 0$，$0 \\le v_M \\le 1000$，$0 \\le v_{BM} \\le 1000$，$0 \\le v_{PR} \\le 1000$。\n\n要求的最终输出格式。你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。其中每个内部列表对应一个测试用例，并包含最终的简约通量向量 $v^\\star$，其顺序为 $(v_U, v_{R2}, v_{BM}, v_{PR}, v_M, v_{Y2Z}, v_{Z2Y})$。通量以 $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$ 为单位表示，并将每个条目四舍五入到六位小数。例如： \"[[vU,vR2,vBM,vPR,vM,vY2Z,vZ2Y],[...],...]”。所有数值答案均为浮点数。", "solution": "用户指定了一个系统生物学领域的计算问题，具体是流平衡分析 (FBA)。任务是使用字典序多目标优化方法，为给定的虚拟网络在多种条件下确定最优的代谢通量分布。该解决方案要求为每种条件求解一系列的三个线性规划 (LP) 问题。\n\n首先对问题的科学合理性、完整性和清晰性进行验证。\n- **科学依据**：该问题基于流平衡分析，这是计算系统生物学中一种标准且成熟的方法。核心方程 $S v = 0$ 代表了稳态下的质量守恒定律。使用线性规划来优化生物学目标（例如生物质生产）是 FBA 的基本技术。字典序优化和最后的简约步骤（最小化通量的 $\\ell_1$-范数）是处理多目标和寻找生物学上真实、高效解的常用且有效的扩展方法。这个虚拟网络虽然简单，但包含了合理的反应类型。因此，该问题具有科学依据。\n- **良定性**：该问题被构建为一系列线性规划任务。给定一个非空、有界的可行域（由质量平衡和通量边界定义的多胞体），LP 保证有解。所有必要的组成部分——化学计量矩阵 $S$、目标向量 $c_{\\text{bio}}$ 和 $c_{\\text{prod}}$，以及四个不同测试用例的反应边界——都已明确提供。优化步骤的顺序也已清晰定义。该问题是自包含的、明确的且良定的。\n- **客观性**：该问题以精确的数学和科学语言陈述，没有主观论断或偏见。\n\n该问题被认为是有效的，可以构建解决方案。\n\n通过对由不同反应边界定义的四个测试用例中的每一个应用三阶段字典序优化程序来实施解决方案。\n\n**阶段 1：最大化生物质生产**\n主要目标是最大化通过生物质反应的通量 $v_{BM}$。这可以构建为以下线性规划问题：\n$$\n\\begin{array}{ll}\n\\text{maximize}   z_1 = c_{\\text{bio}}^\\top v \\\\\n\\text{subject to}  S v = 0 \\\\\n L \\le v \\le U\n\\end{array}\n$$\n其中 $v \\in \\mathbb{R}^n$ 是反应通量向量，$S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$c_{\\text{bio}} = (0,0,1,0,0,0,0)^\\top$ 是生物质的目标向量，而 $L$ 和 $U$ 分别是通量的下界和上界向量。具体的边界是为每个测试用例定义的。求解此 LP 以找到最大可能的生物质生产速率 $z_1$。\n\n**阶段 2：最大化产物分泌**\n第二个目标是在生物质生产速率保持其最优值 $z_1$ 的条件下，最大化通过产物分泌反应的通量 $v_{PR}$。这是一个新的 LP，它继承了阶段 1 的所有约束，并增加了一个额外的等式约束：\n$$\n\\begin{array}{ll}\n\\text{maximize}   z_2 = c_{\\text{prod}}^\\top v \\\\\n\\text{subject to}  S v = 0 \\\\\n c_{\\text{bio}}^\\top v = z_1 \\\\\n L \\le v \\le U\n\\end{array}\n$$\n其中 $c_{\\text{prod}} = (0,0,0,1,0,0,0)^\\top$ 是产物的目标向量。此 LP 找到了在不牺牲最大生物质生产的情况下可实现的最大产物分泌速率 $z_2$。\n\n**阶段 3：最小化总通量（简约 FBA）**\n解空间可能仍然允许多个满足最优值 $z_1$ 和 $z_2$ 的通量分布。选择单一、具有生物学意义的解的一个常用方法是找到一个能最小化总代谢耗费的解，这通过所有通量大小之和（即 $v$ 的 $\\ell_1$-范数）来近似。这被称为简约流平衡分析 (pFBA)。目标是最小化 $\\sum_{i=1}^n |v_i|$。这个非线性目标可以通过为每个通量 $v_i$ 引入辅助变量 $s_i \\ge 0$ 来转化为线性目标，其中 $s_i \\ge |v_i|$。这通过两个线性不等式强制执行：$v_i \\le s_i$ 和 $-v_i \\le s_i$。最终的 LP 是：\n$$\n\\begin{array}{ll}\n\\text{minimize}  \\sum_{i=1}^n s_i \\\\\n\\text{subject to}  S v = 0 \\\\\n c_{\\text{bio}}^\\top v = z_1 \\\\\n c_{\\text{prod}}^\\top v = z_2 \\\\\n v - s \\le 0 \\\\\n -v - s \\le 0 \\\\\n L \\le v \\le U \\\\\n s \\ge 0\n\\end{array}\n$$\n该 LP 的优化变量是增广向量 $(v^\\top, s^\\top)^\\top \\in \\mathbb{R}^{2n}$。从这最后阶段得到的通量向量 $v^\\star$ 是唯一的、简约的解，它依次最大化生物质、然后是产物，最后最小化总通量大小。系统地应用此过程，以获得所提供的四个测试用例中每一个的解。该实现利用 `scipy.optimize.linprog` 函数来求解每个 LP。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the Flux Balance Analysis for all test cases.\n    \"\"\"\n    \n    # Stoichiometric matrix S for metabolites {X, Y, Z} and reactions {U, R2, BM, PR, M, Y2Z, Z2Y}\n    S = np.array([\n        [1, -1, 0, 0, -1, 0, 0],   # Metabolite X\n        [0, 1, -1, -1, 0, -1, 1],   # Metabolite Y\n        [0, 0, 0, 0, 0, 1, -1]    # Metabolite Z\n    ])\n    \n    m, n = S.shape\n\n    # General bounds for reactions unless specified otherwise in a test case.\n    # U, R2, BM, PR, M, Y2Z, Z2Y\n    general_bounds = {\n        'R2': (0, 1000), 'BM': (0, 1000), 'PR': (0, 1000),\n        'Y2Z': (0, 1000), 'Z2Y': (0, 1000)\n    }\n\n    # Define the four test cases by their specific bounds\n    test_cases = [\n        # Case 1: Happy path, biomass dominates\n        {**general_bounds, 'U': (0, 10), 'M': (2, 1000)},\n        # Case 2: Biomass capped; product fills remaining capacity\n        {**general_bounds, 'U': (0, 12), 'M': (2, 1000), 'BM': (0, 8)},\n        # Case 3: Product blocked\n        {**general_bounds, 'U': (0, 12), 'M': (2, 1000), 'PR': (0, 0)},\n        # Case 4: No uptake, no maintenance\n        {**general_bounds, 'U': (0, 0), 'M': (0, 1000)}\n    ]\n    \n    # Order of reactions for constructing the bounds list\n    reaction_order = ['U', 'R2', 'BM', 'PR', 'M', 'Y2Z', 'Z2Y']\n\n    results = []\n    for case_bounds_dict in test_cases:\n        bounds = [case_bounds_dict[reac] for reac in reaction_order]\n        v_star = solve_fba_case(S, bounds, n, m)\n        # Round to six decimal places and format for output\n        rounded_v = [f\"{val:.6f}\" for val in v_star]\n        results.append(f\"[{','.join(rounded_v)}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_fba_case(S, bounds, n, m):\n    \"\"\"\n    Solves the 3-stage lexicographic FBA for a given set of bounds.\n    \"\"\"\n    b_eq = np.zeros(m)\n    c_bio_max = np.array([0, 0, -1, 0, 0, 0, 0]) # maximize v_BM\n    c_prod_max = np.array([0, 0, 0, -1, 0, 0, 0]) # maximize v_PR\n\n    # Stage 1: Maximize biomass\n    res1 = linprog(c=c_bio_max, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n    if not res1.success:\n        # If infeasible (e.g., negative growth), optimal is 0\n        z1 = 0.0\n    else:\n        z1 = -res1.fun # LP minimizes, so we negate to get the maximum\n\n    # Stage 2: Maximize product, fixing biomass\n    c_bio_objective_row = np.array([0, 0, 1, 0, 0, 0, 0])\n    A_eq2 = np.vstack([S, c_bio_objective_row])\n    b_eq2 = np.hstack([b_eq, z1])\n    \n    res2 = linprog(c=c_prod_max, A_eq=A_eq2, b_eq=b_eq2, bounds=bounds, method='highs')\n    if not res2.success:\n        z2 = 0.0\n    else:\n        z2 = -res2.fun\n        \n    # Stage 3: Minimize L1 norm of fluxes (parsimonious FBA)\n    # Variables: [v_1, ..., v_n, s_1, ..., s_n]\n    c3 = np.hstack([np.zeros(n), np.ones(n)])\n    \n    # Equality constraints: Sv=0, c_bio^T v = z1, c_prod^T v = z2\n    c_prod_objective_row = np.array([0, 0, 0, 1, 0, 0, 0])\n    A_eq3_template = np.vstack([S, c_bio_objective_row, c_prod_objective_row])\n    A_eq3 = np.hstack([A_eq3_template, np.zeros((m + 2, n))])\n    b_eq3 = np.hstack([b_eq, z1, z2])\n    \n    # Inequality constraints for L1 norm: v-s = 0, -v-s = 0\n    I_n = np.identity(n)\n    A_ub3 = np.vstack([\n        np.hstack([I_n, -I_n]),\n        np.hstack([-I_n, -I_n])\n    ])\n    b_ub3 = np.zeros(2 * n)\n    \n    # Bounds for augmented variables\n    bounds3 = bounds + [(0, None) for _ in range(n)]\n\n    res3 = linprog(c=c3, A_ub=A_ub3, b_ub=b_ub3, A_eq=A_eq3, b_eq=b_eq3, bounds=bounds3, method='highs')\n\n    if not res3.success:\n        # In case of numerical issues or if no solution exists, return zeros.\n        # This shouldn't happen with the given valid problem setup.\n        return np.zeros(n)\n        \n    v_star = res3.x[:n]\n    # Clean up small numerical errors close to zero\n    v_star[np.isclose(v_star, 0)] = 0\n    \n    return v_star\n\nsolve()\n```", "id": "3308964"}]}