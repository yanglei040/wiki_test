{"hands_on_practices": [{"introduction": "在真实的生物网络中，分子间的相互作用强度并非完全相同，这使得简单的无权网络模型在很多情况下显得力不从心。为了更精确地描述网络中节点的局部聚集程度，我们需要使用加权聚集系数。本练习将指导你计算两种广泛应用的加权局部聚集系数——由 Barrat 等人提出的系数和由 Onnela 等人提出的系数，通过一个具体的例子来揭示不同数学定义如何捕捉和反映边权重的异质性，从而加深你对加权网络分析的理解。[@problem_id:3295345]", "problem": "考虑一个小型无向加权相互作用网络，该网络模拟了蛋白质-蛋白质相互作用（PPI）网络中的一个局部邻域。设焦点蛋白质为节点 $i$，其有四个邻居节点 $j$、$k$、$l$ 和 $m$。假设节点 $i$ 的邻居之间具有以下拓扑结构：仅存在邻居-邻居边 $(j,k)$、$(k,l)$ 和 $(l,m)$，因此三元组 $(i,j,k)$、$(i,k,l)$ 和 $(i,l,m)$ 构成了唯一涉及节点 $i$ 的三角形。所有其他邻居-邻居对之间均无边。设与节点 $i$ 相连的边以及其邻居之间的边的权重是异构的，具体规定如下\n$$\nw_{ij} = 8,\\quad w_{ik} = 1,\\quad w_{il} = 8,\\quad w_{im} = 1,\n$$\n和\n$$\nw_{jk} = 1,\\quad w_{kl} = 8,\\quad w_{lm} = 1.\n$$\n在这个导出子图中不存在其他边。\n\n在计算系统生物学中，节点周围的加权聚集用于量化其局部邻域内三元相互作用的强度。两种广泛使用的加权局部聚集系数是由 Barrat 和 Onnela 提出的。对于 Barrat 的系数，使用基于每个闭合三元组中与 $i$ 相连的两条边的算术平均值的原始强度归一化定义。对于 Onnela 的系数，使用基于几何平均值的强度，并进行归一化 $\\hat{w}_{uv} = w_{uv}/W_{\\max}$，其中 $W_{\\max}$ 是整个网络中的最大边权重。将 $i$ 的局部加权聚集定义为 $i$ 的所有无序邻居对上的平均强度（即，除以 $k_i(k_i-1)/2$）。\n\n从度、强度、连通三元组和加权三角形强度的核心定义出发，以精确形式计算节点 $i$ 的加权局部聚集系数 $C_i^{\\mathrm{Barrat}}$ 和 $C_i^{\\mathrm{Onnela}}$。然后，（在你的推导过程中定性地）解释边权重的异构性如何不同地影响这两个系数的大小。将最终的数值答案表示为精确分数。无需四舍五入。这些系数是无量纲的。", "solution": "该问题陈述清晰，具有坚实的网络理论科学基础，并提供了计算所要求的聚集系数所需的所有信息。所有数据均一致，其定义虽以通俗方式描述，但与文献中的标准公式相符。因此，该问题是有效的。\n\n我们首先正式定义焦点节点 $i$ 周围局部网络的属性。\n\n节点 $i$ 的邻居集合是 $\\{ j, k, l, m \\}$。\n节点 $i$ 的度是其邻居的数量，因此 $k_i = 4$。\n与节点 $i$ 相连的边的权重给定为 $w_{ij} = 8$、$w_{ik} = 1$、$w_{il} = 8$ 和 $w_{im} = 1$。\n节点 $i$ 的强度 $s_i$ 是与其相连的边的权重之和：\n$$s_i = \\sum_{v \\in \\{j,k,l,m\\}} w_{iv} = w_{ij} + w_{ik} + w_{il} + w_{im} = 8 + 1 + 8 + 1 = 18.$$\n问题陈述指出，在 $i$ 的邻居之间仅存在边 $(j,k)$、$(k,l)$ 和 $(l,m)$。这意味着恰好有三个涉及节点 $i$ 的闭合三角形：$T_1 = (i,j,k)$、$T_2 = (i,k,l)$ 和 $T_3 = (i,l,m)$。闭合这些三角形的边的权重给定为 $w_{jk} = 1$、$w_{kl} = 8$ 和 $w_{lm} = 1$。\n\n我们现在将计算节点 $i$ 的两个指定的加权局部聚集系数。\n\n**1. Barrat 的加权局部聚集系数 ($C_i^{\\mathrm{Barrat}}$)**\n\n节点 $i$ 的 Barrat 系数的定义由下式给出：\n$$C_i^{\\mathrm{Barrat}} = \\frac{1}{s_i (k_i - 1)} \\sum_{u, v} \\frac{w_{iu} + w_{iv}}{2} a_{iu} a_{iv} a_{uv},$$\n其中，求和遍及所有不同于 $i$ 的节点对 $(u,v)$，$a_{xy}$ 是邻接矩阵的一个元素（如果 $x$ 和 $y$ 之间存在边，则 $a_{xy}=1$，否则为 $0$）。仅当节点 $i, u, v$ 形成一个三角形时，乘积 $a_{iu} a_{iv} a_{uv}$ 才为 $1$。问题指定每个三角形的贡献是“与 $i$ 相连的两条边的算术平均值”，这对应于项 $(w_{iu} + w_{iv})/2$。\n\n分母是 $s_i(k_i - 1) = 18 \\times (4 - 1) = 18 \\times 3 = 54$。\n\n分子是来自三个三角形中每一个的贡献之和：\n- 对于三角形 $T_1 = (i,j,k)$：贡献为 $\\frac{w_{ij} + w_{ik}}{2} = \\frac{8 + 1}{2} = \\frac{9}{2}$。\n- 对于三角形 $T_2 = (i,k,l)$：贡献为 $\\frac{w_{ik} + w_{il}}{2} = \\frac{1 + 8}{2} = \\frac{9}{2}$。\n- 对于三角形 $T_3 = (i,l,m)$：贡献为 $\\frac{w_{il} + w_{im}}{2} = \\frac{8 + 1}{2} = \\frac{9}{2}$。\n\n分子的总和是 $\\frac{9}{2} + \\frac{9}{2} + \\frac{9}{2} = 3 \\times \\frac{9}{2} = \\frac{27}{2}$。\n\n因此，Barrat 的系数是：\n$$C_i^{\\mathrm{Barrat}} = \\frac{27/2}{54} = \\frac{27}{2 \\times 54} = \\frac{27}{108} = \\frac{1}{4}.$$\n\n**2. Onnela 的加权局部聚集系数 ($C_i^{\\mathrm{Onnela}}$)**\n\nOnnela 的系数定义为 $i$ 的所有无序邻居对上的平均强度。一个潜在三角形 $(i,u,v)$ 的强度是其归一化边权重的几何平均值。归一化公式为 $\\hat{w}_{uv} = w_{uv} / W_{\\max}$。\n其公式为：\n$$C_i^{\\mathrm{Onnela}} = \\frac{1}{\\binom{k_i}{2}} \\sum_{u,v} (\\hat{w}_{iu} \\hat{w}_{uv} \\hat{w}_{vi})^{1/3},$$\n其中，求和遍及 $i$ 的所有无序邻居对 $\\{u,v\\}$。如果某条边不存在，其权重为 $0$，则该对的项为 $0$。\n\n首先，我们确定最大权重 $W_{\\max}$。所有边权重的集合是 $\\{8, 1, 8, 1, 1, 8, 1\\}$。因此，$W_{\\max} = 8$。\n接下来，我们用 $W_{\\max}$ 对所有权重进行归一化：\n- $\\hat{w}_{ij} = w_{ij}/8 = 8/8 = 1$。\n- $\\hat{w}_{ik} = w_{ik}/8 = 1/8$。\n- $\\hat{w}_{il} = w_{il}/8 = 8/8 = 1$。\n- $\\hat{w}_{im} = w_{im}/8 = 1/8$。\n- $\\hat{w}_{jk} = w_{jk}/8 = 1/8$。\n- $\\hat{w}_{kl} = w_{kl}/8 = 8/8 = 1$。\n- $\\hat{w}_{lm} = w_{lm}/8 = 1/8$。\n\n分母中的归一化因子是邻居对的总数：$\\binom{k_i}{2} = \\binom{4}{2} = \\frac{4 \\times 3}{2} = 6$。\n\n分子是 $6$ 个邻居对中每一对的强度之和。只有形成三角形的 $3$ 对才会有非零贡献。\n- 对于三角形 $T_1 = (i,j,k)$：强度为 $(\\hat{w}_{ij} \\hat{w}_{jk} \\hat{w}_{ki})^{1/3} = (1 \\times \\frac{1}{8} \\times \\frac{1}{8})^{1/3} = (\\frac{1}{64})^{1/3} = \\frac{1}{4}$。\n- 对于三角形 $T_2 = (i,k,l)$：强度为 $(\\hat{w}_{ik} \\hat{w}_{kl} \\hat{w}_{li})^{1/3} = (\\frac{1}{8} \\times 1 \\times 1)^{1/3} = (\\frac{1}{8})^{1/3} = \\frac{1}{2}$。\n- 对于三角形 $T_3 = (i,l,m)$：强度为 $(\\hat{w}_{il} \\hat{w}_{lm} \\hat{w}_{mi})^{1/3} = (1 \\times \\frac{1}{8} \\times \\frac{1}{8})^{1/3} = (\\frac{1}{64})^{1/3} = \\frac{1}{4}$。\n另外三对邻居 $(j,l)$、$(j,m)$ 和 $(k,m)$ 没有连接边，因此它们的三角形强度为 $0$。\n\n分子的总和是 $\\frac{1}{4} + \\frac{1}{2} + \\frac{1}{4} = 1$。\n\n因此，Onnela 的系数是：\n$$C_i^{\\mathrm{Onnela}} = \\frac{1}{6}.$$\n\n**3. 权重异构性效应的解释**\n\n我们得到 $C_i^{\\mathrm{Barrat}} = 1/4 = 0.25$ 和 $C_i^{\\mathrm{Onnela}} = 1/6 \\approx 0.167$。由于对边权重的处理方式不同，这两个系数对局部聚集的评估也不同。\n\nBarrat 的系数 $C_i^{\\mathrm{Barrat}}$ 只考虑与焦点节点 $i$ 相连的边的权重（三角形的“辐条”），即 $w_{iu}$ 和 $w_{iv}$。它使用它们的算术平均值 $(w_{iu}+w_{iv})/2$。在这个问题中，三个三角形的辐条权重对分别为 $(8,1)$、$(1,8)$ 和 $(8,1)$。由于算术平均值是可交换的，每个三角形在归一化前对分子总和的贡献量相同，均为 $(8+1)/2 = 4.5$。因此，该系数对三角形“闭合”边（例如 $w_{jk}$）的权重不敏感，并且只要和相同，它对不同三角形辐条之间的权重分布也不敏感。\n\nOnnela 的系数 $C_i^{\\mathrm{Onnela}}$ 通过几何平均值 $(\\hat{w}_{iu}\\hat{w}_{uv}\\hat{w}_{vi})^{1/3}$ 包含了三角形所有三条边的权重。几何平均值对小值高度敏感；一条权重非常小的边会急剧降低三角形的总强度。\n- 三角形 $T_2=(i,k,l)$ 的归一化边权重为 $(\\frac{1}{8}, 1, 1)$。其强度为 $(\\frac{1}{8})^{1/3} = \\frac{1}{2}$。两条强边补偿了一条弱边。\n- 三角形 $T_1=(i,j,k)$ 和 $T_3=(i,l,m)$ 的归一化边权重为 $(1, \\frac{1}{8}, \\frac{1}{8})$。其强度为 $(\\frac{1}{64})^{1/3}=\\frac{1}{4}$。两条弱边的存在严重降低了其强度。\n\n总而言之，边权重的异构性对 Onnela 系数的影响更为深远。它区分了“大部分为强边”的三角形 $T_2$ 和“大部分为弱边”的三角形 $T_1$ 与 $T_3$。Barrat 的系数忽略了闭合边的权重，并对辐条使用算术平均值，因此将所有三个三角形视为等价，未能捕捉到这种拓扑和权重上的细微差别。这导致 $C_i^{\\mathrm{Onnela}}$ 的总体值较低，因为它被两个低强度三角形拉低了。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{4}  \\frac{1}{6} \\end{pmatrix}}$$", "id": "3295345"}, {"introduction": "准确解读网络度量指标的前提是深刻理解它们各自衡量的是什么，以及它们的局限性。一个常见的混淆点在于局部聚集（通过传递性或全局聚集系数衡量）与社区结构（通过模块度 $Q$ 衡量）之间的关系。本练习通过一个巧妙的思维实验，构建了两个模块度相同但聚集程度截然不同的网络，以此清晰地证明高模块度并不意味着高聚集，反之亦然。这有助于你辨析这两个核心概念，并更准确地利用它们来解读生物网络的功能组织。[@problem_id:3295266]", "problem": "一个包含$8$个蛋白质的蛋白质-蛋白质相互作用网络被假设包含两个对应于蛋白质复合物的生物模块。设节点集为$\\{1,2,3,4,5,6,7,8\\}$，并固定模块分配（划分）$\\mathcal{P}=\\{\\{1,2,3,4\\},\\{5,6,7,8\\}\\}$。你需要比较模块度 $Q$（相对于 $\\mathcal{P}$，使用针对无向简单图的标准 Newman–Girvan 定义）和全局聚集系数（传递性）$T$（定义为三倍的三角形数量除以连通三元组的数量）。不要使用问题陈述中任何预先推导的公式，而是依赖这些标准定义作为基本依据。\n\n选择一个选项，该选项在给定的顶点集上正确构造了一对无向简单图 $G_{\\mathrm{A}}$ 和 $G_{\\mathrm{B}}$，两者都相对于固定的划分 $\\mathcal{P}$ 进行评估，使得 $Q(G_{\\mathrm{A}};\\mathcal{P})=Q(G_{\\mathrm{B}};\\mathcal{P})$ 而 $T(G_{\\mathrm{A}})\\neq T(G_{\\mathrm{B}})$，并且提供一个有效的、基于原理的论证，解释为什么高模块度不意味着高聚集性，高聚集性也不意味着高模块度。\n\nA. 通过在每个模块内部放置一个4-环并添加两条模块间边来定义 $G_{\\mathrm{A}}$：\n- $\\{1,2,3,4\\}$ 中的模块内边：$\\{1,2\\},\\{2,3\\},\\{3,4\\},\\{4,1\\}$。\n- $\\{5,6,7,8\\}$ 中的模块内边：$\\{5,6\\},\\{6,7\\},\\{7,8\\},\\{8,5\\}$。\n- 模块间边：$\\{1,5\\},\\{3,7\\}$。\n定义 $G_{\\mathrm{B}}$，使其每个模块的模块内边和模块间边的总数与 $G_{\\mathrm{A}}$ 相同，度序列也相同，但在每个模块内部进行重连，以在每个模块中创建一个三角形：\n- $\\{1,2,3,4\\}$ 中的模块内边：$\\{1,2\\},\\{2,3\\},\\{1,3\\},\\{3,4\\}$。\n- $\\{5,6,7,8\\}$ 中的模块内边：$\\{5,6\\},\\{6,7\\},\\{5,7\\},\\{7,8\\}$。\n- 模块间边：$\\{1,5\\},\\{4,8\\}$。\n主张：相对于 $\\mathcal{P}$，两个图具有相同的模块度 $Q$，因为它们每个模块的模块内边数量相同，度的总和也相同，但它们的全局聚集系数 $T$ 不同，因为 $G_{\\mathrm{A}}$ 没有三角形，而 $G_{\\mathrm{B}}$ 有两个三角形（每个模块一个）。这表明高模块度不意味着高聚集性，反之亦然，因为模块度取决于相对于基于度的零模型的模块内边数量，而 $T$ 取决于闭合三元组的普遍性，这可以通过重连内部边来改变，而无需改变模块内/间边的数量或每个模块的度总和。\n\nB. 将 $G_{\\mathrm{C}}$ 定义为与选项A中的 $G_{\\mathrm{A}}$ 完全相同。通过在 $G_{\\mathrm{C}}$ 中删除模块内边 $\\{4,1\\}$ 和 $\\{8,5\\}$ 并添加模块间边 $\\{4,6\\}$ 和 $\\{2,8\\}$ 来定义 $G_{\\mathrm{D}}$。主张：$Q(G_{\\mathrm{C}};\\mathcal{P})=Q(G_{\\mathrm{D}};\\mathcal{P})$ 而 $T$ 不同，表明模块度和聚集性之间没有蕴涵关系。\n\nC. 定义 $G_{\\mathrm{E}}$，通过取选项A中的 $G_{\\mathrm{A}}$ 并将节点2重新标记为4，节点4重新标记为2（模块内的一种对称性），其他所有边保持不变；设 $G_{\\mathrm{F}}=G_{\\mathrm{A}}$。主张：$Q(G_{\\mathrm{E}};\\mathcal{P})=Q(G_{\\mathrm{F}};\\mathcal{P})$ 但 $T(G_{\\mathrm{E}})\\neq T(G_{\\mathrm{F}})$，表明在相同模块度下具有不同的聚集性。\n\nD. 使用将所有节点放入一个模块的平凡划分 $\\mathcal{P}_{\\mathrm{all}}=\\{\\{1,2,3,4,5,6,7,8\\}\\}$。设 $G_{\\mathrm{G}}$ 是任何具有许多三角形的图（例如，两个共享一条边的4-团的并集），而 $G_{\\mathrm{H}}$ 是任何没有三角形的图（例如，一个8-环）。主张：$Q(G_{\\mathrm{G}};\\mathcal{P}_{\\mathrm{all}})=Q(G_{\\mathrm{H}};\\mathcal{P}_{\\mathrm{all}})$ 且 $G_{\\mathrm{G}}$ 中的高 $T$ 意味着高 $Q$，因此高聚集性意味着高模块度；类似地，低 $T$ 意味着低 $Q$。", "solution": "问题陈述已经过验证且合理。它要求找出一个选项，该选项在顶点集 $V=\\{1,2,3,4,5,6,7,8\\}$ 上，使用固定的划分 $\\mathcal{P}=\\{\\{1,2,3,4\\},\\{5,6,7,8\\}\\}$，构造了两个图 $G_{\\mathrm{A}}$ 和 $G_{\\mathrm{B}}$，使得它们的模块度相等，$Q(G_{\\mathrm{A}};\\mathcal{P})=Q(G_{\\mathrm{B}};\\mathcal{P})$，但它们的全局聚集系数（传递性）不相等，$T(G_{\\mathrm{A}})\\neq T(G_{\\mathrm{B}})$。该选项还必须为此现象提供一个正确的、基于原理的解释。\n\n首先，我们为一个无向简单图 $G=(V, E)$ 建立基本定义，该图具有邻接矩阵 $A$，$n=|V|$ 个顶点和 $m=|E|$ 条边。\n\n对于一个划分 $\\mathcal{P}=\\{C_1, \\dots, C_r\\}$，模块度 $Q$ 由以下公式给出：\n$$Q = \\sum_{s=1}^{r} \\left( \\frac{e_s}{m} - \\left(\\frac{d_s}{2m}\\right)^2 \\right)$$\n其中 $e_s$ 是社群 $C_s$ 中的模块内边数，而 $d_s = \\sum_{i \\in C_s} k_i$ 是社群 $C_s$ 中顶点的度之和。在本问题中，划分为两个模块，$C_1 = \\{1,2,3,4\\}$ 和 $C_2 = \\{5,6,7,8\\}$。\n\n全局聚集系数，或称传递性 $T$，定义为：\n$$T = \\frac{3 \\times (\\text{三角形的数量})}{(\\text{连通三元组的数量})}$$\n三角形的数量 $\\tau_3$ 是满足 $\\{i,j\\},\\{j,k\\},\\{k,i\\} \\in E$ 的三顶点集合 $\\{i,j,k\\}$ 的数量。连通三元组的数量是长度为2的路径数量，可以计算为 $\\sum_{i \\in V} \\binom{k_i}{2}$，其中 $k_i$ 是顶点 $i$ 的度。\n\n我们现在将根据这些定义来评估每个选项。\n\n### 选项 A\n\n**图 $G_{\\mathrm{A}}$：**\n-   模块内边：$\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}$（$C_1$ 中的一个4-环）和 $\\{5,6\\}, \\{6,7\\}, \\{7,8\\}, \\{8,5\\}$（$C_2$ 中的一个4-环）。\n-   模块间边：$\\{1,5\\}, \\{3,7\\}$。\n-   总边数：$m_{\\mathrm{A}} = 4 + 4 + 2 = 10$。\n-   每个模块的模块内边数：$e_{1,\\mathrm{A}}=4$, $e_{2,\\mathrm{A}}=4$。\n-   度：\n    -   $k_1=3$, $k_2=2$, $k_3=3$, $k_4=2$。$C_1$ 的总和：$d_{1,\\mathrm{A}} = 3+2+3+2=10$。\n    -   $k_5=3$, $k_6=2$, $k_7=3$, $k_8=2$。$C_2$ 的总和：$d_{2,\\mathrm{A}} = 3+2+3+2=10$。\n-   模块度 $Q(G_{\\mathrm{A}};\\mathcal{P})$：\n    $$Q(G_{\\mathrm{A}};\\mathcal{P}) = \\left(\\frac{4}{10} - \\left(\\frac{10}{2 \\cdot 10}\\right)^2\\right) + \\left(\\frac{4}{10} - \\left(\\frac{10}{2 \\cdot 10}\\right)^2\\right) = 2 \\left(\\frac{2}{5} - \\frac{1}{4}\\right) = 2 \\left(\\frac{8-5}{20}\\right) = \\frac{3}{10}.$$\n-   $G_{\\mathrm{A}}$ 中的三角形：该图由两个通过两条边连接的4-环组成。没有3-环（三角形）。因此，三角形的数量 $\\tau_{3,\\mathrm{A}}=0$。\n-   传递性 $T(G_{\\mathrm{A}})$：由于 $\\tau_{3,\\mathrm{A}}=0$，我们有 $T(G_{\\mathrm{A}}) = 0$。\n\n**图 $G_{\\mathrm{B}}$：**\n-   模块内边：$\\{1,2\\}, \\{2,3\\}, \\{1,3\\}, \\{3,4\\}$（$C_1$ 中的三角形 $\\{1,2,3\\}$ 加边 $\\{3,4\\}$）和 $\\{5,6\\}, \\{6,7\\}, \\{5,7\\}, \\{7,8\\}$（$C_2$ 中的三角形 $\\{5,6,7\\}$ 加边 $\\{7,8\\}$）。\n-   模块间边：$\\{1,5\\}, \\{4,8\\}$。\n-   总边数：$m_{\\mathrm{B}} = 4 + 4 + 2 = 10$。\n-   每个模块的模块内边数：$e_{1,\\mathrm{B}}=4$, $e_{2,\\mathrm{B}}=4$。\n-   度：\n    -   $k_1=3$, $k_2=2$, $k_3=3$, $k_4=2$。$C_1$ 的总和：$d_{1,\\mathrm{B}} = 3+2+3+2=10$。\n    -   $k_5=3$, $k_6=2$, $k_7=3$, $k_8=2$。$C_2$ 的总和：$d_{2,\\mathrm{B}} = 3+2+3+2=10$。\n-   模块度 $Q(G_{\\mathrm{B}};\\mathcal{P})$：$m$, $e_1$, $e_2$, $d_1$, 和 $d_2$ 的值与 $G_{\\mathrm{A}}$ 的相同。\n    $$Q(G_{\\mathrm{B}};\\mathcal{P}) = \\left(\\frac{4}{10} - \\left(\\frac{10}{20}\\right)^2\\right) + \\left(\\frac{4}{10} - \\left(\\frac{10}{20}\\right)^2\\right) = \\frac{3}{10}.$$\n    因此，$Q(G_{\\mathrm{A}};\\mathcal{P}) = Q(G_{\\mathrm{B}};\\mathcal{P})$。\n-   $G_{\\mathrm{B}}$ 中的三角形：根据构造，每个模块中有一个三角形：$\\{1,2,3\\}$ 和 $\\{5,6,7\\}$。没有其他三角形。因此，$\\tau_{3,\\mathrm{B}}=2$。\n-   传递性 $T(G_{\\mathrm{B}})$：度序列为 $(3,2,3,2,3,2,3,2)$，与 $G_{\\mathrm{A}}$ 相同。\n    连通三元组的数量 = $\\sum_i \\binom{k_i}{2} = 4 \\times \\binom{3}{2} + 4 \\times \\binom{2}{2} = 4 \\times 3 + 4 \\times 1 = 16$。\n    $$T(G_{\\mathrm{B}}) = \\frac{3 \\times \\tau_{3,\\mathrm{B}}}{16} = \\frac{3 \\times 2}{16} = \\frac{6}{16} = \\frac{3}{8}.$$\n    显然，$T(G_{\\mathrm{A}}) = 0 \\neq T(G_{\\mathrm{B}}) = 3/8$。\n\n这个构造是有效的。附带的解释也是正确的：模块度取决于模块之间和模块内部的边分布（一个粗粒度属性），而传递性取决于产生三角形的精确局部连接方式。这个例子表明，可以保持与模块度相关的参数（$m$, $e_s$, $d_s$）不变，同时通过改变局部拓扑来改变三角形的数量，从而使 $Q$ 和 $T$ 解耦。\n\n结论：**正确**。\n\n### 选项 B\n\n该选项定义 $G_{\\mathrm{C}} = G_{\\mathrm{A}}$。因此，$Q(G_{\\mathrm{C}};\\mathcal{P}) = 3/10$。图 $G_{\\mathrm{D}}$ 是通过从 $G_{\\mathrm{C}}$ 中删除两条模块内边（$\\{4,1\\}$ 和 $\\{8,5\\}$）并添加两条模块间边（$\\{4,6\\}$ 和 $\\{2,8\\}$）创建的。\n-   $G_{\\mathrm{D}}$ 中的模块内边数变为 $e_{1,\\mathrm{D}}=3$ 和 $e_{2,\\mathrm{D}}=3$。\n-   总边数保持为 $m_{\\mathrm{D}}=10$。\n-   节点度被重新配置，但每个模块的度之和保持不变：$d_{1,\\mathrm{D}}=10$ 和 $d_{2,\\mathrm{D}}=10$。\n-   $G_{\\mathrm{D}}$ 的模块度为：\n    $$Q(G_{\\mathrm{D}};\\mathcal{P}) = \\left(\\frac{3}{10} - \\left(\\frac{10}{20}\\right)^2\\right) + \\left(\\frac{3}{10} - \\left(\\frac{10}{20}\\right)^2\\right) = 2 \\left(\\frac{3}{10} - \\frac{1}{4}\\right) = 2 \\left(\\frac{6-5}{20}\\right) = \\frac{1}{10}.$$\n$Q(G_{\\mathrm{C}};\\mathcal{P}) = Q(G_{\\mathrm{D}};\\mathcal{P})$ 的主张是错误的，因为 $3/10 \\neq 1/10$。模块内边数量的变化直接影响模块度得分。\n\n结论：**错误**。\n\n### 选项 C\n\n该选项定义 $G_{\\mathrm{F}}=G_{\\mathrm{A}}$。图 $G_{\\mathrm{E}}$ 是通过在 $G_{\\mathrm{A}}$ 中重新标记节点2和4而形成的。$G_{\\mathrm{A}}$ 在第一个模块内的边形成一个4-环 $1-2-3-4-1$。交换节点2和4的标签会得到边 $\\{1,4\\}, \\{4,3\\}, \\{3,2\\}, \\{2,1\\}$，这仍然是同一个环 $1-4-3-2-1$。模块间边 $\\{1,5\\}$ 和 $\\{3,7\\}$ 连接到节点1和3，这些节点不受重新标记的影响。因此，$G_{\\mathrm{E}}$ 中的边集与 $G_{\\mathrm{F}}=G_{\\mathrm{A}}$ 中的边集相同。图 $G_{\\mathrm{E}}$ 和 $G_{\\mathrm{F}}$ 是相同的。\n由于图是相同的，它们的所有属性也必须相同。这意味着 $Q(G_{\\mathrm{E}};\\mathcal{P})=Q(G_{\\mathrm{F}};\\mathcal{P})$ 且 $T(G_{\\mathrm{E}})=T(G_{\\mathrm{F}})$。该选项声称 $T(G_{\\mathrm{E}})\\neq T(G_{\\mathrm{F}})$，这是错误的。\n\n结论：**错误**。\n\n### 选项 D\n\n该选项建议使用平凡划分 $\\mathcal{P}_{\\mathrm{all}}=\\{\\{1,2,3,4,5,6,7,8\\}\\}$，将所有节点放入一个社群。这与问题的前提“使用固定的划分 $\\mathcal{P}=\\{\\{1,2,3,4\\},\\{5,6,7,8\\}\\}$”相矛盾。\n对于任何有 $m$ 条边的图 $G$，相对于平凡划分的模块度总是零：\n$$Q(G;\\mathcal{P}_{\\mathrm{all}}) = \\frac{m}{m} - \\left(\\frac{2m}{2m}\\right)^2 = 1-1=0.$$\n因此，虽然对于任意两个图 $G_{\\mathrm{G}}$ 和 $G_{\\mathrm{H}}$，$Q(G_{\\mathrm{G}};\\mathcal{P}_{\\mathrm{all}}) = Q(G_{\\mathrm{H}};\\mathcal{P}_{\\mathrm{all}})=0$ 是正确的，但所提供的论证是“$G_{\\mathrm{G}}$ 中的高 $T$ 意味着高 $Q$”。这与例子直接矛盾，其中 $G_G$ 可以有很高的 $T$ 但 $Q=0$。这个推理是谬误的且内部不一致。\n\n结论：**错误**。\n\n根据详细分析，只有选项A正确地构造了所需的图，并提供了有效的、基于原理的解释。", "answer": "$$\\boxed{A}$$", "id": "3295266"}, {"introduction": "将理论应用于大规模真实生物网络时，计算效率成为一个关键问题。对于包含数万个节点的蛋白质相互作用网络，暴力枚举所有节点三元组来计算聚集系数是不可行的。本练习将引导你从理论走向实践，要求你设计并实现一个基于节点排序和集合求交的高效算法来完成三角形计数这一核心计算任务。通过应用简并度排序 (degeneracy ordering) 这一重要技巧，你将掌握一种在现代网络科学软件中广泛使用的、性能优越的实用方法。[@problem_id:3295327]", "problem": "给定一个由稀疏邻接表表示的简单、无向、无自环图族。每个图 $G = (V,E)$ 的顶点标记为整数 $0,1,\\dots,n-1$，并有一个邻接表，该表为每个顶点 $i$ 编码了其邻居集合 $N(i) \\subseteq V \\setminus \\{i\\}$，使得对于任意 $i \\neq j$，$(i,j) \\in E$ 当且仅当 $j \\in N(i)$ 且 $i \\in N(j)$。令 $k_i = |N(i)|$ 表示顶点 $i$ 的度。三角形是一个 3-团 $\\{i,j,\\ell\\}$，其中 $(i,j),(j,\\ell),(\\ell,i) \\in E$。与顶点 $i$ 相关联的三角形数量为 $t_i$。顶点 $i$ 的局部聚集系数定义为：如果 $k_i  2$，则 $C_i = 0$；如果 $k_i \\ge 2$，则 $C_i = \\dfrac{2 t_i}{k_i(k_i - 1)}$。全局传递性（也称为全局聚集系数）定义为 $G = \\dfrac{3 T}{\\sum_{i \\in V} \\binom{k_i}{2}}$，其中 $T$ 是 $G$ 中不同三角形的总数；如果分母为 $0$，则按惯例取 $G = 0$。\n\n设计并实现一个算法，该算法在给定 $G$ 的稀疏邻接表的情况下，使用节点排序和前向邻域的集合交集来计算三角形，并计算 $t_i$、$C_i$ 和 $G$。该算法必须：\n- 选择一个顶点的排序 $\\pi: V \\to \\{0,1,\\dots,n-1\\}$，并将每条无向边 $(i,j)$ 从排序较小的端点定向到排序较大的端点，从而产生前向邻域 $N^+(i) = \\{ j \\in N(i) : \\pi(i)  \\pi(j) \\}$。\n- 通过对前向邻域求交集来计算三角形，即通过枚举满足 $j \\in N^+(i)$ 的点对 $(i,j)$ 并累加 $|N^+(i) \\cap N^+(j)|$。\n- 从第一性原理出发，论证为何集合交集的工作量导致运行时间有界于 $O\\!\\left( \\sum_{i \\in V} |N^+(i)|^2 \\right)$，以及为何简并度排序（按核数非递减排序）能得出对所有 $i$ 都有 $|N^+(i)| \\le \\kappa$，其中 $\\kappa$ 是图的简并度，这意味着一个 $O(m \\kappa)$ 的界，其中 $m = |E|$。\n\n您必须通过从剩余顶点的导出子图中反复移除当前度最小的顶点来实现简并度排序，以获得一个核数非递减的排序 $\\pi$。使用此排序来定义前向邻域，并执行集合交集来计算三角形，然后根据上述定义计算 $t_i$，接着计算 $C_i$ 和 $G$。\n\n测试套件。将您的实现应用于以下图（每个图由其邻接表描述；对于每个节点 $i$，我们列出其邻居 $N(i)$）：\n\n- 图 $\\mathcal{G}_1$ ($n = 3$)：$N(0) = \\{1,2\\}$, $N(1) = \\{0,2\\}$, $N(2) = \\{0,1\\}$。\n- 图 $\\mathcal{G}_2$ ($n = 4$)：$N(0) = \\{1\\}$, $N(1) = \\{0,2\\}$, $N(2) = \\{1,3\\}$, $N(3) = \\{2\\}$。\n- 图 $\\mathcal{G}_3$ ($n = 4$)：$N(0) = \\{1,3\\}$, $N(1) = \\{0,2,3\\}$, $N(2) = \\{1,3\\}$, $N(3) = \\{0,1,2\\}$。\n- 图 $\\mathcal{G}_4$ ($n = 7$)：$N(0) = \\{1,2,3,4,5,6\\}$, $N(1) = \\{0\\}$, $N(2) = \\{0\\}$, $N(3) = \\{0\\}$, $N(4) = \\{0\\}$, $N(5) = \\{0\\}$, $N(6) = \\{0\\}$。\n- 图 $\\mathcal{G}_5$ ($n = 4$)：$N(0) = \\{1,2,3\\}$, $N(1) = \\{0,2,3\\}$, $N(2) = \\{0,1,3\\}$, $N(3) = \\{0,1,2\\}$。\n- 图 $\\mathcal{G}_6$ ($n = 7$)：$N(0) = \\{1,2\\}$, $N(1) = \\{0,2,3\\}$, $N(2) = \\{0,1,3,4\\}$, $N(3) = \\{1,2,4\\}$, $N(4) = \\{2,3\\}$, $N(5) = \\{6\\}$, $N(6) = \\{5\\}$。\n\n对于每个图，计算：\n- 总三角形数 $T$，为整数。\n- 局部聚集系数列表 $[C_0, C_1, \\dots, C_{n-1}]$，为实数，四舍五入到 $6$ 位小数。\n- 全局传递性 $G$，为实数，四舍五入到 $6$ 位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有测试图的结果列表，顺序为 $\\mathcal{G}_1$ 到 $\\mathcal{G}_6$。每个图的结果是一个形如 $[T, [C_0, \\dots, C_{n-1}], G]$ 的列表。所有实数必须呈现为四舍五入到 $6$ 位的小数。例如，单行输出的结构应为\n$[[T_1,[C_{1,0},\\dots],G_1],[T_2,[C_{2,0},\\dots],G_2],\\dots,[T_6,[C_{6,0},\\dots],G_6]]$。", "solution": "该问题被评估为有效。它在科学上基于标准图论，问题陈述清晰，定义精确，目标明确，并且没有任何问题验证清单中列出的可能使其无效的缺陷。局部聚集系数、全局传递性和简并度排序的所有定义在网络科学和算法学中都是标准的。指定的任务是实现一个著名的三角形计数算法，并将其应用于给定的测试套件。\n\n### 基于原理的设计与论证\n\n问题的核心是在无向图 $G=(V, E)$ 中高效地计算三角形。检查每个顶点三元组的暴力方法复杂度为 $O(n^3)$，对于大图来说太慢。一个更好的方法是遍历每个顶点 $v$，并检查其任意一对邻居之间是否存在边，该方法的复杂度为 $O(\\sum_{v \\in V} k_v^2)$，其中 $k_v$ 是顶点 $v$ 的度。问题陈述中指定的基于顶点排序的算法是一种精密的方法，旨在进一步降低这种复杂性，特别是对于稀疏图。\n\n#### 1. 使用顶点排序进行三角形计数\n\n该算法首先建立一个顶点的全序 $\\pi: V \\to \\{0, 1, \\dots, n-1\\}$。这个排序用于定向每条无向边 $(i, j) \\in E$。边从排序较低的顶点定向到排序较高的顶点，即如果 $\\pi(i)  \\pi(j)$，则为 $i \\to j$。这将无向图 $G$ 转换为有向无环图（DAG）。在这个有向无环图中，我们将顶点 $i$ 的“前向邻域”定义为 $N^+(i) = \\{j \\in N(i) : \\pi(i)  \\pi(j)\\}$。\n\n考虑原始图中的任意三角形 $\\{i, j, \\ell\\}$。在排序 $\\pi$ 下，其顶点有一个唯一的序关系，比如 $\\pi(i)  \\pi(j)  \\pi(\\ell)$。在有向图中，这个三角形表现为一个独特的有向结构：$i \\to j$，$i \\to \\ell$，以及 $j \\to \\ell$。这意味着 $j \\in N^+(i)$，$\\ell \\in N^+(i)$，且 $\\ell \\in N^+(j)$。\n\n这种结构使我们能够不重复地计算三角形。该算法遍历每条有向边 $i \\to j$（即，对于每个顶点 $i$，遍历所有 $j \\in N^+(i)$）。对于每条这样的边，它寻找第三个顶点 $\\ell$，使得 $i \\to \\ell$ 和 $j \\to \\ell$。这样的顶点 $\\ell$ 必须同时属于 $N^+(i)$ 和 $N^+(j)$。因此，涉及边 $i \\to j$ 的三角形集合由它们前向邻域中的公共邻居给出，即 $N^+(i) \\cap N^+(j)$。\n\n通过遍历所有顶点 $i$ 和所有 $j \\in N^+(i)$，并对每对顶点累加其交集的大小 $|N^+(i) \\cap N^+(j)|$，我们可以将每个三角形恰好计数一次。具体来说，具有 $\\pi(i)  \\pi(j)  \\pi(\\ell)$ 的三角形 $\\{i, j, \\ell\\}$ 将在算法处理边 $i \\to j$ 并在 $N^+(i)$ 和 $N^+(j)$ 的交集中找到 $\\ell$ 时被精确地计数一次。在处理 $i \\to \\ell$（因为 $j \\notin N^+(\\ell)$）或 $j \\to \\ell$（因为 $i \\notin N^+(j)$ 或 $N^+(\\ell)$）时，它不会被计数。\n\n因此，三角形的总数 $T$ 由下式给出：\n$$ T = \\sum_{i \\in V} \\sum_{j \\in N^+(i)} |N^+(i) \\cap N^+(j)| $$\n在此过程中，对于找到的每个三角形 $\\{i, j, \\ell\\}$，我们增加局部三角形计数 $t_i, t_j$ 和 $t_\\ell$。遍历所有边之后，总三角形数为 $T = (\\sum_{v \\in V} t_v) / 3$。\n\n#### 2. 复杂度分析\n\n该算法的运行时间主要由嵌套循环和集合交集操作决定。算法结构如下：\n1. 对于每个顶点 $i \\in V$：\n2.  对于每个前向邻居 $j \\in N^+(i)$：\n3.   计算交集 $N^+(i) \\cap N^+(j)$。\n\n让我们分析所做的工作。两个大小分别为 $s_1$ 和 $s_2$ 的集合求交集的成本取决于数据结构。如果前向邻域存储为排序列表，则交集操作需要 $O(s_1 + s_2)$ 时间。如果将其中一个转换为哈希集，则所需时间与另一个集合的大小成正比。假设一个简单的实现，即对于一个集合中的每个元素，我们检查它是否存在于另一个集合中（例如，通过哈希数据结构），则 $N^+(i)$ 和 $N^+(j)$ 的交集成本可以界定为 $O(|N^+(i)|)$ 或 $O(|N^+(j)|)$。计算交集 $N^+(i) \\cap N^+(j)$ 成本的一个简单（尽管悲观）的界是 $O(|N^+(i)|)$。\n\n总工作量是所有边 $i \\to j$ 的这些成本之和：\n$$ \\text{Work} \\approx \\sum_{i \\in V} \\sum_{j \\in N^+(i)} O(|N^+(i)|) = O\\left(\\sum_{i \\in V} |N^+(i)| \\cdot |N^+(i)|\\right) = O\\left(\\sum_{i \\in V} |N^+(i)|^2\\right) $$\n这论证了所要求的运行时间界为 $O\\!\\left( \\sum_{i \\in V} |N^+(i)|^2 \\right)$。\n\n#### 3. 简并度排序与 $O(m \\kappa)$ 界\n\n该算法的效率关键取决于所选的顶点排序 $\\pi$。最小化前向邻域大小的排序将带来更好的性能。简并度排序是实现此目的的有效启发式方法。\n\n图的简并度 $\\kappa$ 是最小的整数，使得每个导出子图都至少有一个度最多为 $\\kappa$ 的顶点。简并度排序是通过从当前剩余的图中反复移除度最小的顶点来构建的。在第 $k$ 步移除的顶点被赋予排序值 $k$。\n\n让我们证明，使用简并度排序，对所有 $i \\in V$ 都有 $|N^+(i)| \\le \\kappa$。根据排序的构造方法，当选择一个顶点 $i$ 进行移除时，它在尚未移除的顶点集合所导出的图中具有最小度。令该导出子图为 $G'$。$G'$ 中 $i$ 的所有邻居恰好是其前向邻居 $N^+(i)$，因为这些邻居将在 $i$ 之后被移除（即具有更高的排序值）。因此，$G'$ 中 $i$ 的度 $d_{G'}(i)$ 等于 $|N^+(i)|$。根据简并度的定义，任何导出子图（包括 $G'$）的最小度最多为 $\\kappa$。因此，$d_{G'}(i) = |N^+(i)| \\le \\kappa$。\n\n利用这个性质，我们可以进一步细化复杂度界：\n$$ O\\left(\\sum_{i \\in V} |N^+(i)|^2\\right) = O\\left(\\sum_{i \\in V} |N^+(i)| \\cdot |N^+(i)|\\right) \\le O\\left(\\sum_{i \\in V} |N^+(i)| \\cdot \\kappa\\right) $$\n项 $\\sum_{i \\in V} |N^+(i)|$ 是有向图中所有出度的总和。由于 $m$ 条无向边中的每一条都恰好变成一条有向边，所以这个总和等于边的总数 $m$。\n$$ \\text{Work} \\le O\\left(\\kappa \\sum_{i \\in V} |N^+(i)|\\right) = O(\\kappa m) $$\n这表明使用简b并度排序将三角形计数复杂度限制在 $O(m \\kappa)$ 以内。\n\n### 实现计划\n\n对于每个输入图，实现将遵循以下步骤：\n1.  **解析邻接表**：读取输入图并以合适的格式存储，如列表的列表或集合。\n2.  **计算简并度排序**：一个函数实现简化的 $O(n^2)$ 简并度排序算法。它在未移除的顶点中反复查找当前度最小的顶点，在排序 $\\pi$ 中为其分配下一个序值，并更新其邻居的度。\n3.  **构造前向邻域**：基于计算出的排序 $\\pi$，为每个顶点 $i$ 创建前向邻域 $N^+(i)$ 的新邻接表。将它们存储为集合对于交集步骤是高效的。\n4.  **计数三角形**：算法遍历每个顶点 $i$ 及其每个前向邻居 $j \\in N^+(i)$。它计算交集 $N^+(i) \\cap N^+(j)$。对于交集中的每个顶点 $\\ell$，就找到了一个三角形 $\\{i, j, \\ell\\}$，并且三角形计数 $t_i, t_j, t_\\ell$ 会增加。\n5.  **计算最终指标**：\n    *   总三角形数 $T$ 计算为 $(\\sum t_i) / 3$。\n    *   局部聚集系数 $\\{C_i\\}$ 使用公式 $C_i = 2t_i / (k_i(k_i-1))$（对于 $k_i \\ge 2$）计算，否则 $C_i=0$，其中 $k_i$ 是原始度数。\n    *   全局传递性 $G$ 计算为 $3T / \\sum_i \\binom{k_i}{2}$。\n6.  **格式化输出**：收集计算出的值（$T$、$C_i$ 列表和 $G$），将浮点数四舍五入到 6 位小数，并格式化为所需的字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Graph G1: 3-clique\n        [[1, 2], [0, 2], [0, 1]],\n        # Graph G2: Path graph P4\n        [[1], [0, 2], [1, 3], [2]],\n        # Graph G3: Diamond graph\n        [[1, 3], [0, 2, 3], [1, 3], [0, 1, 2]],\n        # Graph G4: Star graph\n        [[1, 2, 3, 4, 5, 6], [0], [0], [0], [0], [0], [0]],\n        # Graph G5: 4-clique\n        [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]],\n        # Graph G6: Two components\n        [[1, 2], [0, 2, 3], [0, 1, 3, 4], [1, 2, 4], [2, 3], [6], [5]],\n    ]\n    \n    results = []\n    for adj in test_cases:\n        result = compute_metrics(adj)\n        # Format floats in the inner list\n        formatted_c = [f\"{x:.6f}\" for x in result[1]]\n        # Need to reconstruct string to avoid quotes on list items\n        result_str = f\"[{result[0]},[{','.join(formatted_c)}],{result[2]:.6f}]\"\n        results.append(result_str)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef get_degeneracy_ordering(adj):\n    \"\"\"\n    Computes the degeneracy ordering of a graph.\n    This implementation is a simple O(n^2) version, sufficient for small N.\n    \"\"\"\n    n = len(adj)\n    # Using a dictionary for degrees of remaining nodes\n    degrees = {i: len(adj[i]) for i in range(n)}\n    pi = {}  # map vertex - rank\n    \n    for rank in range(n):\n        # Find vertex with minimum degree among remaining nodes\n        min_deg = float('inf')\n        min_v = -1\n        for v, d in degrees.items():\n            if d  min_deg:\n                min_deg = d\n                min_v = v\n        \n        pi[min_v] = rank\n        \n        # \"Remove\" vertex min_v and update degrees of its neighbors\n        del degrees[min_v]\n        for neighbor in adj[min_v]:\n            if neighbor in degrees:\n                degrees[neighbor] -= 1\n                \n    return pi\n\ndef compute_metrics(adj):\n    \"\"\"\n    Computes triangle count, local clustering coefficients, and global transitivity.\n    \"\"\"\n    n = len(adj)\n    if n == 0:\n        return [0, [], 0.0]\n\n    # 1. Compute degeneracy ordering\n    pi = get_degeneracy_ordering(adj)\n    \n    # 2. Construct forward neighborhoods\n    N_plus = [set() for _ in range(n)]\n    for i in range(n):\n        for j in adj[i]:\n            if pi[i]  pi[j]:\n                N_plus[i].add(j)\n    \n    # 3. Count triangles and t_i\n    triangles_per_vertex = [0] * n\n    for i in range(n):\n        # The problem statement describes iterating through pairs (i,j) with j in N^+(i)\n        # and accumulating |N^+(i) intersect N^+(j)|. This counts each triangle once.\n        # We need t_i, so we must increment counts for all 3 vertices of a triangle.\n        for j in N_plus[i]:\n            # Now we have an edge i-j. Find common neighbors l with i-l and j-l\n            common_neighbors = N_plus[i].intersection(N_plus[j])\n            for l in common_neighbors:\n                # Triangle {i, j, l} found.\n                triangles_per_vertex[i] += 1\n                triangles_per_vertex[j] += 1\n                triangles_per_vertex[l] += 1\n                \n    # Each triangle {i,j,l} is counted when we find it, contributing to t_i, t_j, t_l.\n    # The sum of t_i is 3 times the total number of triangles.\n    total_triangles = sum(triangles_per_vertex) // 3\n    \n    # 4. Compute local clustering coefficients\n    degrees = [len(neighbors) for neighbors in adj]\n    local_coeffs = []\n    for i in range(n):\n        k = degrees[i]\n        t = triangles_per_vertex[i]\n        c = 0.0\n        if k = 2:\n            c = (2 * t) / (k * (k - 1))\n        local_coeffs.append(c)\n        \n    # 5. Compute global transitivity\n    denom_G = sum(k * (k - 1) for k in degrees) # This is 2 * sum(binom(k_i, 2))\n    global_transitivity = 0.0\n    if denom_G  0:\n        # G = 3T / sum(binom(k,2)) = 6T / sum(k(k-1))\n        global_transitivity = (6 * total_triangles) / denom_G\n        \n    return [total_triangles, local_coeffs, global_transitivity]\n\nsolve()\n```", "id": "3295327"}]}