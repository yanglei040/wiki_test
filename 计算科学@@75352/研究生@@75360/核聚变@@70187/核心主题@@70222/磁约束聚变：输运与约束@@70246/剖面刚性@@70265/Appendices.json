{"hands_on_practices": [{"introduction": "从第一性原理出发，解析地求解输运模型是理解剖面刚性物理机制的基石。本练习将引导你推导一个具有临界梯度的简化等离子体模型中的稳态温度剖面，从而加深对输运刚性如何影响等离子体芯部和边界行为的理解。通过求解此问题[@problem_id:3715651]，你将实践处理分段函数和在不同输运区域之间进行解匹配的关键数学技巧。", "problem": "考虑一个磁约束聚变等离子体核心的一维板状模型，其中稳态温度剖面依赖于一个表现出剖面刚性和弹性的通量驱动输运定律。令径向向外的热通量表示为 $Q(r)$，局部刚性控制参数为梯度变量 $\\kappa(r)$，定义为 $\\kappa(r) = -\\frac{dT}{dr}$，因此较大的 $\\kappa(r)$ 对应于更陡的温度梯度。假设该板状模型的范围为 $r \\in [0,a]$，具有固定的边界温度 $T(a) = T_a$ 和一个对称性条件，该条件将中心处的向外通量设置为零，$Q(0) = 0$。\n\n对于体加热 $S(r)$，稳态能量平衡由能量守恒定律 $\\nabla \\cdot \\mathbf{q} = S(r)$ 给出，其中 $\\mathbf{q}$ 是热通量密度。在这个一维板状模型中，该方程简化为 $\\frac{dQ}{dr} = S(r)$。加热源被指定为空间均匀的，$S(r) = S_0$，其中 $S_0 > 0$。\n\n剖面刚性通过一个分段的通量-梯度关系引入：\n- 对于 $\\kappa  \\kappa_c$，输运是基线扩散，其关系为 $Q(\\kappa) = \\chi_0 \\kappa$。\n- 对于 $\\kappa \\ge \\kappa_c$，输运发生刚化，其模型为 $Q(\\kappa) = \\chi_0 \\kappa + \\alpha (\\kappa - \\kappa_c)^n$。\n\n取指数 $n$ 为 $n = 2$，参数 $\\chi_0 > 0$，$\\alpha > 0$，以及 $\\kappa_c > 0$。假设 $\\chi_0 \\kappa_c  S_0 a$，以确保加热驱动足够强，使得在 $r \\in (0,a)$ 的某个位置超过阈值。\n\n从能量平衡和上述通量-梯度关系出发，推导稳态温度剖面，然后计算中心温度 $T(0)$，用 $T_a$、$a$、$S_0$、$\\chi_0$、$\\alpha$ 和 $\\kappa_c$ 表示。将你的最终答案表示为单个闭式解析表达式。不要近似或四舍五入；不需要进行数值评估，最终表达式中也无需报告单位。", "solution": "该问题经评估是有效的。它在科学上基于热输运和能量守恒原理，在数学上是适定的，具有唯一解的充分条件，并且陈述客观。剖面刚性模型是等离子体物理学中使用的标准（尽管是简化的）表示方法。所有参数都已明确定义，且约束条件是自洽的。\n\n出发点是一维板状模型中的稳态能量平衡方程，表示为 $\\frac{dQ(r)}{dr} = S(r)$。体加热源 $S(r)$ 是均匀的，$S(r) = S_0$，其中 $S_0 > 0$。因此方程为：\n$$\n\\frac{dQ}{dr} = S_0\n$$\n对径向坐标 $r$ 积分，得到热通量剖面：\n$$\nQ(r) = S_0 r + C\n$$\n其中 $C$ 是一个积分常数。根据板中心处的对称性条件 $Q(0) = 0$，可知 $C=0$。因此，热通量由下式给出：\n$$\nQ(r) = S_0 r\n$$\n问题基于温度梯度 $\\kappa(r) = -\\frac{dT}{dr}$ 定义了一个分段的通量-梯度关系。输运机制的转变发生在一个临界梯度 $\\kappa_c$ 处。输运定律在此阈值处是连续的：\n- 对于 $\\kappa  \\kappa_c$：$Q(\\kappa) = \\chi_0 \\kappa$。\n- 对于 $\\kappa \\ge \\kappa_c$：$Q(\\kappa) = \\chi_0 \\kappa + \\alpha (\\kappa - \\kappa_c)^2$。\n\n在转变点 $\\kappa = \\kappa_c$ 处，通量为 $Q(\\kappa_c) = \\chi_0 \\kappa_c$。由于通量 $Q(r)$ 随 $r$ 增加，而梯度 $\\kappa(r)$ 是 $Q(r)$ 的单调递增函数，因此 $\\kappa(r)$ 也是 $r$ 的单调递增函数。在中心附近，通量较低，等离子体处于基线输运区；在半径较大处，通量较高，等离子体进入刚性输运区。转变发生在一个特定的半径 $r_c$ 处，该处满足 $\\kappa(r_c) = \\kappa_c$。我们可以通过令通量表达式相等来求出 $r_c$：\n$$\nQ(r_c) = S_0 r_c = \\chi_0 \\kappa_c\n$$\n解出 $r_c$ 得：\n$$\nr_c = \\frac{\\chi_0 \\kappa_c}{S_0}\n$$\n问题给出的条件 $\\chi_0 \\kappa_c  S_0 a$ 意味着 $r_c  a$。由于所有参数均为正，因此 $r_c > 0$。这证实了转变发生在板内，从而定义了两个不同的区域：\n1.  内部区域（基线输运）：$0 \\le r \\le r_c$，其中 $\\kappa(r) \\le \\kappa_c$。\n2.  外部区域（刚性输运）：$r_c  r \\le a$，其中 $\\kappa(r) > \\kappa_c$。\n\n为了求得中心温度 $T(0)$，我们将温度梯度 $\\kappa(r) = -\\frac{dT}{dr}$ 从边界 $r=a$ 积分到中心 $r=0$：\n$$\nT(0) - T(a) = \\int_{a}^{0} \\frac{dT}{dr} dr = \\int_{0}^{a} \\left(-\\frac{dT}{dr}\\right) dr = \\int_{0}^{a} \\kappa(r) dr\n$$\n$$\nT(0) = T_a + \\int_{0}^{a} \\kappa(r) dr\n$$\n该积分被分成两个区域进行计算：\n$$\nT(0) = T_a + \\int_{0}^{r_c} \\kappa(r) dr + \\int_{r_c}^{a} \\kappa(r) dr\n$$\n首先，我们通过反转通量-梯度关系来求出每个区域中的 $\\kappa(r)$。\n\n在内部区域（$0 \\le r \\le r_c$）：\n$$\nQ(r) = \\chi_0 \\kappa(r) \\implies S_0 r = \\chi_0 \\kappa(r)\n$$\n$$\n\\kappa(r) = \\frac{S_0}{\\chi_0} r\n$$\n该区域的积分为：\n$$\n\\int_{0}^{r_c} \\frac{S_0}{\\chi_0} r \\, dr = \\frac{S_0}{2\\chi_0} [r^2]_0^{r_c} = \\frac{S_0}{2\\chi_0} r_c^2 = \\frac{S_0}{2\\chi_0} \\left( \\frac{\\chi_0 \\kappa_c}{S_0} \\right)^2 = \\frac{\\chi_0 \\kappa_c^2}{2S_0}\n$$\n在外部区域（$r_c  r \\le a$）：\n$$\nQ(r) = S_0 r = \\chi_0 \\kappa(r) + \\alpha (\\kappa(r) - \\kappa_c)^2\n$$\n这是一个关于 $\\kappa(r)$ 的二次方程。令 $y = \\kappa(r) - \\kappa_c$。方程变为 $S_0 r = \\chi_0(y + \\kappa_c) + \\alpha y^2$，整理后得到：\n$$\n\\alpha y^2 + \\chi_0 y + (\\chi_0 \\kappa_c - S_0 r) = 0\n$$\n使用二次公式求解 $y$：\n$$\ny = \\frac{-\\chi_0 \\pm \\sqrt{\\chi_0^2 - 4\\alpha(\\chi_0 \\kappa_c - S_0 r)}}{2\\alpha}\n$$\n在该区域中，$\\kappa(r) > \\kappa_c$，所以 $y > 0$。对于 $r>r_c$，我们有 $S_0 r > S_0 r_c = \\chi_0 \\kappa_c$，这意味着 $S_0 r - \\chi_0 \\kappa_c > 0$。平方根内的参数为 $\\chi_0^2 - 4\\alpha\\chi_0\\kappa_c + 4\\alpha S_0 r > \\chi_0^2$。因此 $\\sqrt{\\dots} > \\chi_0$，所以我们必须选择 `+` 号来确保 $y > 0$。\n$$\n\\kappa(r) - \\kappa_c = \\frac{-\\chi_0 + \\sqrt{\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 r}}{2\\alpha}\n$$\n$$\n\\kappa(r) = \\kappa_c - \\frac{\\chi_0}{2\\alpha} + \\frac{1}{2\\alpha}\\sqrt{\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 r}\n$$\n现在我们计算这个外部区域的积分：\n$$\n\\int_{r_c}^{a} \\kappa(r) dr = \\int_{r_c}^{a} \\left( \\kappa_c - \\frac{\\chi_0}{2\\alpha} \\right) dr + \\frac{1}{2\\alpha} \\int_{r_c}^{a} \\sqrt{\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 r} \\, dr\n$$\n第一部分是：\n$$\n\\left[ \\left( \\kappa_c - \\frac{\\chi_0}{2\\alpha} \\right) r \\right]_{r_c}^a = \\left( \\kappa_c - \\frac{\\chi_0}{2\\alpha} \\right) (a-r_c)\n$$\n对于积分的第二部分，令 $u = \\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 r$，则 $du = 4\\alpha S_0 dr$。\n$$\n\\frac{1}{2\\alpha} \\int \\sqrt{u} \\frac{du}{4\\alpha S_0} = \\frac{1}{8\\alpha^2 S_0} \\int u^{1/2} du = \\frac{1}{8\\alpha^2 S_0} \\frac{2}{3} u^{3/2} = \\frac{1}{12\\alpha^2 S_0} u^{3/2}\n$$\n计算从 $r_c$到 $a$ 的定积分：\n$$\n\\frac{1}{12\\alpha^2 S_0} \\left[ (\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 r)^{3/2} \\right]_{r_c}^a\n$$\n在 $r=r_c=\\frac{\\chi_0 \\kappa_c}{S_0}$ 处的下限值为：\n$$\n\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 \\left(\\frac{\\chi_0 \\kappa_c}{S_0}\\right) = \\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha\\chi_0 \\kappa_c = \\chi_0^2\n$$\n所以第二部分积分的结果是：\n$$\n\\frac{1}{12\\alpha^2 S_0} \\left[ (\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 a)^{3/2} - (\\chi_0^2)^{3/2} \\right] = \\frac{(\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 a)^{3/2} - \\chi_0^3}{12\\alpha^2 S_0}\n$$\n将所有部分组合起来得到 $T(0)$：\n$$\nT(0) = T_a + \\frac{\\chi_0 \\kappa_c^2}{2S_0} + \\left( \\kappa_c - \\frac{\\chi_0}{2\\alpha} \\right) (a-r_c) + \\frac{(\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 a)^{3/2} - \\chi_0^3}{12\\alpha^2 S_0}\n$$\n代入 $r_c = \\frac{\\chi_0 \\kappa_c}{S_0}$：\n$$\nT(0) = T_a + \\frac{\\chi_0 \\kappa_c^2}{2S_0} + \\left( \\kappa_c - \\frac{\\chi_0}{2\\alpha} \\right) \\left(a-\\frac{\\chi_0 \\kappa_c}{S_0}\\right) + \\frac{(\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 a)^{3/2} - \\chi_0^3}{12\\alpha^2 S_0}\n$$\n展开乘积项：\n$$\n\\left( \\kappa_c - \\frac{\\chi_0}{2\\alpha} \\right) \\left(a-\\frac{\\chi_0 \\kappa_c}{S_0}\\right) = a\\kappa_c - \\frac{\\chi_0 \\kappa_c^2}{S_0} - \\frac{a\\chi_0}{2\\alpha} + \\frac{\\chi_0^2 \\kappa_c}{2\\alpha S_0}\n$$\n将其与内部区域的结果相加：\n$$\n\\frac{\\chi_0 \\kappa_c^2}{2S_0} + a\\kappa_c - \\frac{\\chi_0 \\kappa_c^2}{S_0} - \\frac{a\\chi_0}{2\\alpha} + \\frac{\\chi_0^2 \\kappa_c}{2\\alpha S_0} = a\\kappa_c - \\frac{a\\chi_0}{2\\alpha} - \\frac{\\chi_0 \\kappa_c^2}{2S_0} + \\frac{\\chi_0^2 \\kappa_c}{2\\alpha S_0}\n$$\n将所有项求和，得到中心温度的最终表达式：\n$$\nT(0) = T_a + a\\kappa_c - \\frac{a\\chi_0}{2\\alpha} - \\frac{\\chi_0 \\kappa_c^2}{2S_0} + \\frac{\\chi_0^2 \\kappa_c}{2\\alpha S_0} + \\frac{(\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 a)^{3/2} - \\chi_0^3}{12\\alpha^2 S_0}\n$$\n这就是完整且精确的解析解。", "answer": "$$\n\\boxed{T_a + a\\kappa_c - \\frac{a\\chi_0}{2\\alpha} - \\frac{\\chi_0 \\kappa_c^2}{2S_0} + \\frac{\\chi_0^2 \\kappa_c}{2\\alpha S_0} + \\frac{(\\chi_0^2 - 4\\alpha\\chi_0 \\kappa_c + 4\\alpha S_0 a)^{3/2} - \\chi_0^3}{12\\alpha^2 S_0}}\n$$", "id": "3715651"}, {"introduction": "除了理论推导，计算模拟是直观感受剖面刚性现象的有力工具。本练习[@problem_id:3715628]要求你实现一个简化的热输运“代理模型”，通过改变加热功率来直接观察芯部温度梯度的“钉扎”效应。这个实践将帮助你清晰地看到，当输运变得“刚性”时，增加的功率主要如何被等离子体边界而不是芯部梯度所吸收。", "problem": "考虑一个用于磁约束聚变等离子体中热输运的一维平板代理模型，旨在模拟通量驱动条件下核心温度梯度的剖面弹性和刚度。空间坐标为 $x \\in [0,L]$，其中 $x=0$ 表示磁轴，$x=L$ 表示等离子体边界。稳态热平衡由守恒定律 $dq/dx = s(x)$ 定义，其中 $q(x)$ 是向外的热通量（单位 $\\mathrm{MW}/\\mathrm{m}^2$），$s(x)$ 是体积加热源密度（单位 $\\mathrm{MW}/\\mathrm{m}^3$）。核心温度剖面 $T(x)$（单位 $\\mathrm{keV}$）是单调的，满足 $-dT/dx \\ge 0$。边界通过一个线性排热边界条件 $q(L) = h \\left(T(L) - T_\\mathrm{wall}\\right)$ 与一个散热汇耦合，其中 $h$ 是边界排热系数（单位 $\\mathrm{MW}/(\\mathrm{m}^2\\cdot\\mathrm{keV})$），$T_\\mathrm{wall}$ 是参考壁面的边界温度（单位 $\\mathrm{keV}$）。\n\n为了模拟湍流引起的刚度，采用一种分段线性的“临界梯度”代理模型来表示局域通量-梯度关系，这代表了当超过临界梯度时强湍流输运的开始。定义局域梯度大小为 $g(x) = -dT/dx \\ge 0$（单位 $\\mathrm{keV}/\\mathrm{m}$）。通量-梯度关系为\n$$\nq\\big(g(x)\\big) = \n\\begin{cases}\n\\kappa_\\mathrm{low}\\,g(x),  g(x) \\le g_c,\\\\\n\\kappa_\\mathrm{low}\\,g_c + \\kappa_\\mathrm{high}\\,\\big(g(x) - g_c\\big),  g(x) > g_c,\n\\end{cases}\n$$\n其中 $\\kappa_\\mathrm{low}$ 和 $\\kappa_\\mathrm{high}$ 分别是低输运系数和高输运系数（单位 $\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})$），$g_c$ 是临界梯度（单位 $\\mathrm{keV}/\\mathrm{m}$）。该代理模型强制实现了弹性：一旦 $g(x)$ 达到 $g_c$，热通量的进一步增加主要由一个大的 $\\kappa_\\mathrm{high}$ 承载，而不是通过 $g(x)$ 的进一步增加，从而将核心梯度“钉扎”在 $g_c$ 附近。\n\n假设在 $x \\in [0,L]$ 上有一个均匀源 $s(x) = s_0$，其中 $s_0$ 是常数（单位 $\\mathrm{MW}/\\mathrm{m}^3$）。在 $dq/dx = s_0$ 和对称性条件 $q(0)=0$ 下，通量为 $q(x) = s_0\\,x$，边界通量为 $q(L) = s_0\\,L$。边界温度可由边界条件得出：$T(L) = T_\\mathrm{wall} + q(L)/h$。温度剖面可以通过从边界向内积分 $g(x)$ 来恢复：\n$$\nT(x) = T(L) + \\int_x^L g(\\xi)\\,d\\xi.\n$$\n您的任务是实现这个代理模型，通过在一系列 $s_0$ 递增的情况下，计算代表性核心位置 $x_\\mathrm{core}$ 处的梯度和产生的边界温度，来展示增加输入功率仅改变边界温度，而核心梯度保持在 $g_c$ 附近。\n\n使用以下固定参数，这些参数对于一个代理模型是科学上合理的，并且在单位上是自洽的：\n- 区域长度 $L = 0.5\\,\\mathrm{m}$。\n- 边界排热系数 $h = 40\\,\\mathrm{MW}/(\\mathrm{m}^2\\cdot\\mathrm{keV})$。\n- 参考壁面的边界温度 $T_\\mathrm{wall} = 0.1\\,\\mathrm{keV}$。\n- 低输运系数 $\\kappa_\\mathrm{low} = 0.5\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})$。\n- 高输运系数 $\\kappa_\\mathrm{high} = 50\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})$。\n- 临界梯度 $g_c = 5.0\\,\\mathrm{keV}/\\mathrm{m}$。\n- 核心评估点 $x_\\mathrm{core} = 0.25\\,\\mathrm{m}$。\n\n实现一个程序，为每个测试用例计算：\n- 核心梯度大小 $g(x_\\mathrm{core})$，单位 $\\mathrm{keV}/\\mathrm{m}$，四舍五入到3位小数。\n- 边界温度 $T(L)$，单位 $\\mathrm{keV}$，四舍五入到3位小数。\n\n设计程序以评估以下源强度 $s_0$ 的测试套件：\n- 情况1：$s_0 = 2.0\\,\\mathrm{MW}/\\mathrm{m}^3$（在核心评估点附近低于阈值）。\n- 情况2：$s_0 = 10.0\\,\\mathrm{MW}/\\mathrm{m}^3$（在阈值附近及略高于阈值）。\n- 情况3：$s_0 = 50.0\\,\\mathrm{MW}/\\mathrm{m}^3$（远高于阈值）。\n\n对于每种情况，计算 $q(x) = s_0\\,x$，反转通量-梯度关系以获得 $g(x_\\mathrm{core})$，计算 $q(L) = s_0\\,L$，然后计算 $T(L) = T_\\mathrm{wall} + q(L)/h$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个案例一个子列表，形式为 $[[g_1,T_1],[g_2,T_2],[g_3,T_3]]$。", "solution": "用户提供了一个有效的问题陈述。该问题在科学上基于一个简化但标准的等离子体热输运模型，问题设定良好，有唯一解，并且客观地表述了所有必要的参数。我现在将提供一个完整的解决方案。\n\n问题要求我们计算一维等离子体平板模型的磁芯温度梯度大小 $g(x_\\mathrm{core})$ 和边界温度 $T(L)$。该模型具有“刚性”输运特性，即热导率在超过临界温度梯度 $g_c$ 时会急剧增加。我们将针对三种不同级别的均匀加热源强度 $s_0$ 评估这些量。\n\n分析从所给定的控制方程和参数开始。\n模型的固定参数如下：\n- 区域长度：$L = 0.5\\,\\mathrm{m}$\n- 边界排热系数：$h = 40\\,\\mathrm{MW}/(\\mathrm{m}^2\\cdot\\mathrm{keV})$\n- 参考壁面的边界温度：$T_\\mathrm{wall} = 0.1\\,\\mathrm{keV}$\n- 低输运系数：$\\kappa_\\mathrm{low} = 0.5\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})$\n- 高输运系数：$\\kappa_\\mathrm{high} = 50\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})$\n- 临界梯度：$g_c = 5.0\\,\\mathrm{keV}/\\mathrm{m}$\n- 核心评估点：$x_\\mathrm{core} = 0.25\\,\\mathrm{m}$\n\n热源是均匀的，$s(x)=s_0$。对热平衡方程 $dq/dx = s_0$ 进行积分，并应用对称性条件 $q(0)=0$，得到热通量剖面：\n$$q(x) = s_0 x$$\n\n对于每个 $s_0$ 测试用例，需要进行的计算是：\n1.  边界温度 $T(L)$。\n2.  核心梯度大小 $g(x_\\mathrm{core}) = -dT/dx|_{x=x_\\mathrm{core}}$。\n\n首先，我们建立边界温度 $T(L)$ 的公式。它由排热边界条件决定：\n$$q(L) = h \\left(T(L) - T_\\mathrm{wall}\\right)$$\n边界处的热通量为 $q(L) = s_0 L$。将其代入边界条件并求解 $T(L)$ 得：\n$$s_0 L = h \\left(T(L) - T_\\mathrm{wall}\\right)$$\n$$T(L) = T_\\mathrm{wall} + \\frac{s_0 L}{h}$$\n这个方程允许对任何给定的 $s_0$ 直接计算 $T(L)$。\n\n第二，我们确定核心梯度大小 $g(x_\\mathrm{core})$。这需要使用分段的通量-梯度关系：\n$$\nq(g) = \n\\begin{cases}\n\\kappa_\\mathrm{low}\\,g,  g \\le g_c, \\\\\n\\kappa_\\mathrm{low}\\,g_c + \\kappa_\\mathrm{high}\\,(g - g_c),  g > g_c.\n\\end{cases}\n$$\n为了从局域热通量 $q(x_\\mathrm{core}) = s_0 x_\\mathrm{core}$ 中求出梯度 $g(x_\\mathrm{core})$，我们必须反转这个关系，将 $g$ 表示为 $q$ 的函数。\n\n让我们找出与临界梯度 $g_c$ 对应的临界热通量 $q_c$。这是低输运和高输运区间之间的转换点上的通量值：\n$$q_c = \\kappa_\\mathrm{low}\\,g_c$$\n对于给定的参数，$q_c = (0.5\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})) \\times (5.0\\,\\mathrm{keV}/\\mathrm{m}) = 2.5\\,\\mathrm{MW}/\\mathrm{m}^2$。\n\n现在我们可以写出反函数 $g(q)$：\n- 如果 $q \\le q_c$，我们处于低输运区。我们反转 $q = \\kappa_\\mathrm{low}\\,g$：\n$$g(q) = \\frac{q}{\\kappa_\\mathrm{low}}$$\n- 如果 $q > q_c$，我们处于高输运（刚性）区。我们反转 $q = \\kappa_\\mathrm{low}\\,g_c + \\kappa_\\mathrm{high}\\,(g - g_c)$：\n$$q - \\kappa_\\mathrm{low}\\,g_c = \\kappa_\\mathrm{high}\\,(g - g_c)$$\n$$\\frac{q - \\kappa_\\mathrm{low}\\,g_c}{\\kappa_\\mathrm{high}} = g - g_c$$\n$$g(q) = g_c + \\frac{q - \\kappa_\\mathrm{low}\\,g_c}{\\kappa_\\mathrm{high}}$$\n认识到 $\\kappa_\\mathrm{low}\\,g_c = q_c$，这可以简化为：\n$$g(q) = g_c + \\frac{q - q_c}{\\kappa_\\mathrm{high}}$$\n所以，完整的反函数关系是：\n$$\ng(q) = \n\\begin{cases}\nq/\\kappa_\\mathrm{low},  q \\le q_c, \\\\\ng_c + (q - q_c)/\\kappa_\\mathrm{high},  q > q_c.\n\\end{cases}\n$$\n我们将把这些公式应用于三个测试用例。\n\n**情况1：$s_0 = 2.0\\,\\mathrm{MW}/\\mathrm{m}^3$**\n1.  计算热通量：\n    - 在核心处：$q(x_\\mathrm{core}) = s_0 x_\\mathrm{core} = (2.0\\,\\mathrm{MW}/\\mathrm{m}^3) \\times (0.25\\,\\mathrm{m}) = 0.5\\,\\mathrm{MW}/\\mathrm{m}^2$。\n    - 在边界处：$q(L) = s_0 L = (2.0\\,\\mathrm{MW}/\\mathrm{m}^3) \\times (0.5\\,\\mathrm{m}) = 1.0\\,\\mathrm{MW}/\\mathrm{m}^2$。\n2.  计算边界温度 $T(L)$：\n    - $T(L) = T_\\mathrm{wall} + \\frac{q(L)}{h} = 0.1\\,\\mathrm{keV} + \\frac{1.0\\,\\mathrm{MW}/\\mathrm{m}^2}{40\\,\\mathrm{MW}/(\\mathrm{m}^2\\cdot\\mathrm{keV})} = 0.1 + 0.025 = 0.125\\,\\mathrm{keV}$。\n3.  计算核心梯度 $g(x_\\mathrm{core})$：\n    - 核心通量为 $q(x_\\mathrm{core}) = 0.5\\,\\mathrm{MW}/\\mathrm{m}^2$，小于 $q_c = 2.5\\,\\mathrm{MW}/\\mathrm{m}^2$。我们使用低输运公式。\n    - $g(x_\\mathrm{core}) = \\frac{q(x_\\mathrm{core})}{\\kappa_\\mathrm{low}} = \\frac{0.5\\,\\mathrm{MW}/\\mathrm{m}^2}{0.5\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})} = 1.0\\,\\mathrm{keV}/\\mathrm{m}$。\n4.  情况1的结果：$[g(x_\\mathrm{core}), T(L)] = [1.000\\,\\mathrm{keV}/\\mathrm{m}, 0.125\\,\\mathrm{keV}]$。\n\n**情况2：$s_0 = 10.0\\,\\mathrm{MW}/\\mathrm{m}^3$**\n1.  计算热通量：\n    - 在核心处：$q(x_\\mathrm{core}) = s_0 x_\\mathrm{core} = (10.0\\,\\mathrm{MW}/\\mathrm{m}^3) \\times (0.25\\,\\mathrm{m}) = 2.5\\,\\mathrm{MW}/\\mathrm{m}^2$。\n    - 在边界处：$q(L) = s_0 L = (10.0\\,\\mathrm{MW}/\\mathrm{m}^3) \\times (0.5\\,\\mathrm{m}) = 5.0\\,\\mathrm{MW}/\\mathrm{m}^2$。\n2.  计算边界温度 $T(L)$：\n    - $T(L) = T_\\mathrm{wall} + \\frac{q(L)}{h} = 0.1\\,\\mathrm{keV} + \\frac{5.0\\,\\mathrm{MW}/\\mathrm{m}^2}{40\\,\\mathrm{MW}/(\\mathrm{m}^2\\cdot\\mathrm{keV})} = 0.1 + 0.125 = 0.225\\,\\mathrm{keV}$。\n3.  计算核心梯度 $g(x_\\mathrm{core})$：\n    - 核心通量为 $q(x_\\mathrm{core}) = 2.5\\,\\mathrm{MW}/\\mathrm{m}^2$，正好等于 $q_c$。我们处于阈值上。使用第一个公式：\n    - $g(x_\\mathrm{core}) = \\frac{q(x_\\mathrm{core})}{\\kappa_\\mathrm{low}} = \\frac{2.5\\,\\mathrm{MW}/\\mathrm{m}^2}{0.5\\,\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})} = 5.0\\,\\mathrm{keV}/\\mathrm{m}$，这正好是 $g_c$。\n4.  情况2的结果：$[g(x_\\mathrm{core}), T(L)] = [5.000\\,\\mathrm{keV}/\\mathrm{m}, 0.225\\,\\mathrm{keV}]$。\n\n**情况3：$s_0 = 50.0\\,\\mathrm{MW}/\\mathrm{m}^3$**\n1.  计算热通量：\n    - 在核心处：$q(x_\\mathrm{core}) = s_0 x_\\mathrm{core} = (50.0\\,\\mathrm{MW}/\\mathrm{m}^3) \\times (0.25\\,\\mathrm{m}) = 12.5\\,\\mathrm{MW}/\\mathrm{m}^2$。\n    - 在边界处：$q(L) = s_0 L = (50.0\\,\\mathrm{MW}/\\mathrm{m}^3) \\times (0.5\\,\\mathrm{m}) = 25.0\\,\\mathrm{MW}/\\mathrm{m}^2$。\n2.  计算边界温度 $T(L)$：\n    - $T(L) = T_\\mathrm{wall} + \\frac{q(L)}{h} = 0.1\\,\\mathrm{keV} + \\frac{25.0\\,\\mathrm{MW}/\\mathrm{m}^2}{40\\,\\mathrm{MW}/(\\mathrm{m}^2\\cdot\\mathrm{keV})} = 0.1 + 0.625 = 0.725\\,\\mathrm{keV}$。\n3.  计算核心梯度 $g(x_\\mathrm{core})$：\n    - 核心通量为 $q(x_\\mathrm{core}) = 12.5\\,\\mathrm{MW}/\\mathrm{m}^2$，大于 $q_c = 2.5\\,\\mathrm{MW}/\\mathrm{m}^2$。我们使用高输运公式。\n    - $g(x_\\mathrm{core}) = g_c + \\frac{q(x_\\mathrm{core}) - q_c}{\\kappa_\\mathrm{high}} = 5.0\\,\\mathrm{keV}/\\mathrm{m} + \\frac{12.5 - 2.5}{50} \\frac{\\mathrm{MW}/\\mathrm{m}^2}{\\mathrm{MW}/(\\mathrm{m}\\cdot\\mathrm{keV})} = 5.0 + \\frac{10.0}{50} = 5.0 + 0.2 = 5.2\\,\\mathrm{keV}/\\mathrm{m}$。\n4.  情况3的结果：$[g(x_\\mathrm{core}), T(L)] = [5.200\\,\\mathrm{keV}/\\mathrm{m}, 0.725\\,\\mathrm{keV}]$。\n\n结果展示了剖面刚度现象。当加热功率 $s_0$ 从 $10.0$ 增加五倍到 $50.0\\,\\mathrm{MW}/\\mathrm{m}^3$ 时，核心梯度 $g(x_\\mathrm{core})$ 仅增加了少量，从 $5.000\\,\\mathrm{keV}/\\mathrm{m}$ 增加到 $5.200\\,\\mathrm{keV}/\\mathrm{m}$，保持“钉扎”在临界值 $g_c=5.0$ 附近。增加的大部分加热功率被边界温度 $T(L)$ 的大幅升高（从 $0.225\\,\\mathrm{keV}$ 到 $0.725\\,\\mathrm{keV}$）所容纳，而不是通过核心温度剖面梯度的陡峭化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the core gradient and edge temperature for a stiff heat transport\n    model in a fusion plasma surrogate.\n    \"\"\"\n    # Fixed parameters\n    L = 0.5            # Domain length [m]\n    h = 40.0           # Edge exhaust coefficient [MW/(m^2*keV)]\n    T_wall = 0.1       # Wall-referenced edge temperature [keV]\n    kappa_low = 0.5    # Low transport coefficient [MW/(m*keV)]\n    kappa_high = 50.0  # High transport coefficient [MW/(m*keV)]\n    g_c = 5.0          # Critical gradient [keV/m]\n    x_core = 0.25      # Core evaluation point [m]\n\n    # Test cases for source strength\n    test_cases = [\n        2.0,   # s0 [MW/m^3] - Case 1\n        10.0,  # s0 [MW/m^3] - Case 2\n        50.0   # s0 [MW/m^3] - Case 3\n    ]\n\n    results = []\n\n    # Calculate the critical heat flux q_c\n    q_c = kappa_low * g_c\n\n    for s0 in test_cases:\n        # 1. Calculate heat flux at core and edge\n        q_at_core = s0 * x_core\n        q_at_L = s0 * L\n\n        # 2. Calculate edge temperature T(L)\n        T_L = T_wall + q_at_L / h\n\n        # 3. Calculate core gradient g(x_core)\n        if q_at_core = q_c:\n            # Low-transport regime\n            g_at_core = q_at_core / kappa_low\n        else:\n            # High-transport (stiff) regime\n            g_at_core = g_c + (q_at_core - q_c) / kappa_high\n\n        # 4. Round results to 3 decimal places\n        g_rounded = round(g_at_core, 3)\n        T_L_rounded = round(T_L, 3)\n        \n        results.append((g_rounded, T_L_rounded))\n\n    # 5. Format the output string as specified\n    sublist_strings = [f\"[{g:.3f},{T:.3f}]\" for g, T in results]\n    final_output = f\"[[{','.join(sublist_strings)}]]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3715628"}, {"introduction": "聚变科学中的一个核心任务是从实验数据中验证输运模型并确定其关键参数。这个高级练习[@problem_id:3715593]将带你进入模型推断的前沿，使用贝叶斯方法从合成数据中估计刚性模型的参数，例如基线扩散系数和刚性强度。通过此练习，你不仅能掌握一种强大的数据分析技术，还能深入理解参数识别性和不确定性量化在模型验证中的重要性。", "problem": "考虑一个磁约束聚变等离子体中剖面刚性（profile resilience）和刚度（stiffness）的简化一维输运表示，其中稳态向外热通量通过一个基线扩散通道和一个在梯度超过临界阈值时出现的刚度增强项，来响应局域归一化温度梯度。设实验索引为 $i$ 的标量可观测量为热通量 $ \\phi_i $，其模型为\n$$\n\\phi_i = D_0\\, g_i + K\\, \\max(0, g_i - g_c) + \\epsilon_i,\n$$\n其中 $ D_0 $ 是未知的基线扩散率参数，$ K $ 是未知的刚度幅值参数，$ g_i $ 是实验 $ i $ 施加的归一化温度梯度驱动（无量纲），$ g_c $ 是一个已知的临界梯度（无量纲），$ \\epsilon_i $ 是测量噪声。假设 $ \\epsilon_i $ 是独立同分布（IID）的零均值高斯噪声，其方差为 $ \\sigma^2 $，即 $ \\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2) $。\n\n在核聚变等离子体中，湍流表现出一种刚性（resilience），倾向于使剖面保持在边缘稳定性附近；增强项 $ K\\, \\max(0, g_i - g_c) $ 模拟了当梯度超过临界阈值 $ g_c $ 时增加热通量的输运刚度。这个程式化模型与菲克定律（Fick’s law）的基线标度和临界梯度驱动的刚度增强相一致。\n\n给定一些合成数据集，其中 $ \\phi_i $ 是根据已知的基准实况参数 $ (D_0^{\\star}, K^{\\star}) $、已知的 $ g_c $、指定的 $ g_i $ 和确定性的噪声实现生成的。将 $ \\phi_i $ 视为用于推断的测量可观测量。使用贝叶斯推断，为 $ D_0 $ 和 $ K $ 设置独立的伽马先验，并使用由噪声模型所蕴含的高斯似然。具体而言，设\n- $ D_0 \\sim \\operatorname{Gamma}(k_D, \\theta_D) $,\n- $ K \\sim \\operatorname{Gamma}(k_K, \\theta_K) $,\n其中伽马分布的参数化为形状参数 $ k $ 和尺度参数 $ \\theta $。其概率密度函数（PDF）为 $ f(x; k, \\theta) = \\frac{1}{\\Gamma(k)\\,\\theta^k} x^{k-1} e^{-x/\\theta} $，对于 $ x>0 $。\n\n从贝叶斯法则 $ p(D_0,K \\mid \\{\\phi_i\\}) \\propto p(\\{\\phi_i\\} \\mid D_0,K)\\, p(D_0)\\, p(K) $ 出发，在参数空间中使用一个均匀矩形网格来数值近似后验分布。根据后验分布，计算 $ D_0 $ 和 $ K $ 的边缘后验均值，以及每个参数的等尾 $ 0.95 $ 置信区间。然后，使用一个基于后验收缩和相关性的明确量化准则来评估可辨识性：\n- 根据 $ D_0 $ 和 $ K $ 的伽马先验，计算它们的先验 $ 0.95 $ 等尾区间宽度。\n- 根据边缘后验分布，计算后验 $ 0.95 $ 等尾区间宽度。\n- 定义收缩比 $ S_{D_0} = \\frac{w_{D_0,\\text{post}}}{w_{D_0,\\text{prior}}} $ 和 $ S_{K} = \\frac{w_{K,\\text{post}}}{w_{K,\\text{prior}}} $，其中 $ w $ 表示区间宽度。\n- 根据归一化的联合后验分布，计算 $ D_0 $ 和 $ K $ 之间的后验相关性 $ \\rho = \\frac{\\operatorname{Cov}(D_0,K)}{\\sqrt{\\operatorname{Var}(D_0)\\operatorname{Var}(K)}} $。\n- 如果 $ S_{D_0}  0.6 $，$ S_{K}  0.6 $，且 $ |\\rho|  0.95 $，则声明参数集是可辨识的。否则，声明其为不可辨识的。\n\n所有量均为无量纲，因此不需要物理单位。问题不涉及角度。您的算法必须使用与矩形网格间距一致的数值积分方法，在网格上实现后验分布的归一化，并且必须通过对另一个参数积分来计算边缘密度。置信区间必须是等尾的，且总后验质量为 $ 0.95 $。\n\n使用以下合成案例的测试套件。在每个案例中，$ \\phi_i $ 根据给定的 $ \\eta_i $ 计算得出，公式为 $ \\phi_i = D_0^{\\star} g_i + K^{\\star} \\max(0, g_i - g_c) + \\eta_i $，并且后验分布使用指定的高斯似然标准差 $ \\sigma $：\n- 案例 $ 1 $ （混合梯度，信息丰富）：\n  - $ g_c = 3.5 $,\n  - $ g_i $ 列表: $ [2.0, 3.0, 3.5, 3.8, 4.2, 4.8, 3.2, 5.0] $,\n  - 基准实况 $ (D_0^{\\star}, K^{\\star}) = (1.5, 4.0) $,\n  - 噪声实现 $ \\eta_i $ 列表: $ [0.05, -0.02, 0.03, -0.04, 0.00, 0.01, -0.03, 0.02] $,\n  - 似然标准差 $ \\sigma = 0.05 $。\n- 案例 $ 2 $ （所有梯度低于 $ g_c $，刚度未被激发）：\n  - $ g_c = 3.5 $,\n  - $ g_i $ 列表: $ [2.0, 2.5, 3.0, 3.2, 3.4] $,\n  - 基准实况 $ (D_0^{\\star}, K^{\\star}) = (1.5, 4.0) $,\n  - 噪声实现 $ \\eta_i $ 列表: $ [0.04, -0.03, 0.05, -0.02, 0.01] $,\n  - 似然标准差 $ \\sigma = 0.05 $。\n- 案例 $ 3 $ （高噪声，刚度部分被激发）：\n  - $ g_c = 3.5 $,\n  - $ g_i $ 列表: $ [4.0, 4.5, 5.0, 5.5, 6.0] $,\n  - 基准实况 $ (D_0^{\\star}, K^{\\star}) = (1.5, 2.0) $,\n  - 噪声实现 $ \\eta_i $ 列表: $ [0.30, -0.25, 0.40, -0.35, 0.20] $,\n  - 似然标准差 $ \\sigma = 0.30 $。\n\n对所有案例使用相同的独立伽马先验：\n- $ D_0 $ 的先验：$ k_D = 3.0 $，$ \\theta_D = 0.8 $,\n- $ K $ 的先验：$ k_K = 3.0 $，$ \\theta_K = 1.5 $。\n\n对所有案例使用以下共同的网格规格：\n- $ D_0 $ 网格从 $ 0.0 $ 到 $ 5.0 $（含边界），均匀步长为 $ 0.01 $,\n- $ K $ 网格从 $ 0.0 $ 到 $ 8.0 $（含边界），均匀步长为 $ 0.02 $。\n\n您的程序必须：\n- 针对每个案例，根据给定的 $ g_i $、$ g_c $、基准实况 $ (D_0^{\\star}, K^{\\star}) $ 和 $ \\eta_i $ 生成 $ \\phi_i $。\n- 在矩形网格上计算归一化的联合后验分布。\n- 计算 $ D_0 $ 和 $ K $ 的边缘后验均值，以及每个参数的等尾 $ 0.95 $ 置信区间。\n- 计算 $ D_0 $ 和 $ K $ 的先验等尾 $ 0.95 $ 置信区间以及收缩比 $ S_{D_0} $ 和 $ S_{K} $。\n- 计算后验相关性 $ \\rho $。\n- 使用上述准则确定可辨识性布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个含三个列表的列表，每个子列表对应一个案例。每个案例列表按以下顺序包含七个条目：$ D_0 $ 的后验均值，$ D_0 $ 的 $ 0.95 $ 置信区间的下界，$ D_0 $ 的 $ 0.95 $ 置信区间的上界，$ K $ 的后验均值，$ K $ 的 $ 0.95 $ 置信区间的下界，$ K $ 的 $ 0.95 $ 置信区间的上界，以及可辨识性布尔值。所有数值条目必须是十进制浮点数。例如，一个有效的输出形状为 $ [[d_1,\\ell_{d,1},u_{d,1},k_1,\\ell_{k,1},u_{k,1},b_1],[d_2,\\ell_{d,2},u_{d,2},k_2,\\ell_{k,2},u_{k,2},b_2],[d_3,\\ell_{d,3},u_{d,3},k_3,\\ell_{k,3},u_{k,3},b_3]] $。", "solution": "The user has provided a well-defined Bayesian inference problem concerning a simplified model of heat transport in a fusion plasma. The problem is scientifically grounded, mathematically consistent, and all necessary parameters, data, and criteria are explicitly stated. Therefore, the problem is deemed valid.\n\nThe solution proceeds by implementing the specified Bayesian analysis for each of the three test cases. The core of the method involves computing the joint posterior probability distribution for the parameters $D_0$ (baseline diffusivity) and $K$ (stiffness amplitude) on a discrete grid, and then deriving various statistical measures from this posterior.\n\nThe model for the measured heat flux $\\phi_i$ is given by:\n$$\n\\phi_i = D_0\\, g_i + K\\, \\max(0, g_i - g_c) + \\epsilon_i\n$$\nwhere $g_i$ is the temperature gradient, $g_c$ is the critical gradient, and $\\epsilon_i$ is Gaussian noise, $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$.\n\nAccording to Bayes' theorem, the posterior probability of the parameters $(D_0, K)$ given the data $\\{\\phi_i\\}$ is proportional to the product of the likelihood and the prior probability:\n$$\np(D_0, K \\mid \\{\\phi_i\\}) \\propto p(\\{\\phi_i\\} \\mid D_0, K) \\, p(D_0, K)\n$$\nGiven that the parameters are a priori independent, $p(D_0, K) = p(D_0) p(K)$.\n\n1.  **Prior Distributions**:\n    The priors for $D_0$ and $K$ are given as Gamma distributions:\n    $$\n    D_0 \\sim \\operatorname{Gamma}(k_D, \\theta_D) \\quad \\text{with } k_D=3.0, \\theta_D=0.8\n    $$\n    $$\n    K \\sim \\operatorname{Gamma}(k_K, \\theta_K) \\quad \\text{with } k_K=3.0, \\theta_K=1.5\n    $$\n    The probability density function (PDF) for a Gamma distribution with shape $k$ and scale $\\theta$ is $f(x; k, \\theta) = \\frac{1}{\\Gamma(k)\\theta^k} x^{k-1} e^{-x/\\theta}$. Since the grid includes $D_0=0$ and $K=0$, we note that the Gamma PDF is zero for $x \\le 0$, which will correctly yield a posterior probability of zero at these boundaries.\n\n2.  **Likelihood Function**:\n    The noise $\\epsilon_i$ is Independent and Identically Distributed (IID) from $\\mathcal{N}(0,\\sigma^2)$. The likelihood of observing the entire dataset $\\{\\phi_i\\}$ is the product of the probabilities of each individual observation:\n    $$\n    p(\\{\\phi_i\\} \\mid D_0, K) = \\prod_{i=1}^N \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left( -\\frac{(\\phi_i - \\mu_i(D_0, K))^2}{2\\sigma^2} \\right)\n    $$\n    where $\\mu_i(D_0, K) = D_0 g_i + K \\max(0, g_i - g_c)$. For numerical stability, we work with the log-likelihood:\n    $$\n    \\ln p(\\{\\phi_i\\} \\mid D_0, K) = -\\frac{N}{2}\\ln(2\\pi\\sigma^2) - \\frac{1}{2\\sigma^2} \\sum_{i=1}^N (\\phi_i - \\mu_i(D_0, K))^2\n    $$\n\n3.  **Numerical Computation of the Posterior**:\n    We discretize the parameter space $(D_0, K)$ into a uniform rectangular grid as specified.\n    - $D_0 \\in [0.0, 5.0]$ with step $\\Delta D_0 = 0.01$.\n    - $K \\in [0.0, 8.0]$ with step $\\Delta K = 0.02$.\n    \n    At each grid point $(D_{0,j}, K_l)$, we compute the unnormalized log-posterior:\n    $$\n    \\ln P_{\\text{un}}(D_{0,j}, K_l) = \\ln p(\\{\\phi_i\\} \\mid D_{0,j}, K_l) + \\ln p(D_{0,j}) + \\ln p(K_l)\n    $$\n    The unnormalized posterior is then $P_{\\text{un}}(D_{0,j}, K_l) = \\exp(\\ln P_{\\text{un}}(D_{0,j}, K_l))$. To avoid numerical underflow or overflow, we use the log-sum-exp trick for normalization. The normalization constant (evidence) is approximated by a Riemann sum over the grid:\n    $$\n    Z = \\iint P_{\\text{un}}(D_0, K) \\,dD_0 \\,dK \\approx \\sum_{j,l} P_{\\text{un}}(D_{0,j}, K_l) \\Delta D_0 \\Delta K\n    $$\n    The normalized posterior PDF on the grid is $P_{\\text{norm}}(D_{0,j}, K_l) = P_{\\text{un}}(D_{0,j}, K_l) / Z$.\n\n4.  **Posterior Statistics**:\n    - **Marginal Distributions**: The marginal PDFs are computed by integrating (summing) the joint posterior over the other parameter's domain:\n      $$\n      p(D_{0,j} \\mid \\{\\phi_i\\}) = \\sum_l P_{\\text{norm}}(D_{0,j}, K_l) \\Delta K\n      $$\n      $$\n      p(K_l \\mid \\{\\phi_i\\}) = \\sum_j P_{\\text{norm}}(D_{0,j}, K_l) \\Delta D_0\n      $$\n    - **Posterior Means**: The means are the expectation values calculated from the marginals:\n      $$\n      E[D_0] = \\sum_j D_{0,j} \\, p(D_{0,j} \\mid \\{\\phi_i\\}) \\, \\Delta D_0\n      $$\n      $$\n      E[K] = \\sum_l K_l \\, p(K_l \\mid \\{\\phi_i\\}) \\, \\Delta K\n      $$\n    - **Credible Intervals**: The equal-tailed $0.95$ credible interval for each parameter is found by identifying the $0.025$ and $0.975$ quantiles of its marginal posterior distribution. This is done by first computing the cumulative distribution function (CDF) from the marginal PDF and then using linear interpolation to find the parameter values corresponding to probabilities $0.025$ and $0.975$.\n\n5.  **Identifiability Analysis**:\n    - **Prior Interval Widths**: The $0.95$ equal-tailed credible intervals for the Gamma priors are calculated using the inverse CDF (percent-point function) of the theoretical Gamma distribution.\n    - **Shrinkage Ratios**: The shrinkage ratio for each parameter is the ratio of its posterior credible interval width to its prior credible interval width: $S = w_{\\text{post}} / w_{\\text{prior}}$.\n    - **Posterior Correlation**: The correlation coefficient $\\rho$ is computed from the normalized joint posterior:\n      $$\n      \\rho = \\frac{\\operatorname{Cov}(D_0, K)}{\\sqrt{\\operatorname{Var}(D_0)\\operatorname{Var}(K)}}\n      $$\n      where variances and the covariance are numerical calculated from the posterior distributions, e.g., $\\operatorname{Cov}(D_0,K) = E[D_0 K] - E[D_0]E[K]$.\n    - **Criterion**: The parameter set is 'identifiable' if $S_{D_0}  0.6$, $S_{K}  0.6$, and $|\\rho|  0.95$.\n\nFor each test case, we first generate the synthetic data $\\phi_i$ using the provided ground-truth parameters $(D_0^{\\star}, K^{\\star})$ and noise realizations $\\eta_i$. Then, the above procedure is executed to compute the required posterior statistics and determine identifiability.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import gamma\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Main function to run the Bayesian inference for all test cases.\n    \"\"\"\n    \n    # Define common priors and grid specifications for all cases.\n    priors = {\n        'D0': {'k': 3.0, 'theta': 0.8},\n        'K': {'k': 3.0, 'theta': 1.5}\n    }\n    \n    grid_spec = {\n        'D0': {'min': 0.0, 'max': 5.0, 'step': 0.01},\n        'K': {'min': 0.0, 'max': 8.0, 'step': 0.02}\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        # Case 1 (mixed gradients, informative)\n        {\n            \"g_c\": 3.5,\n            \"g_i\": [2.0, 3.0, 3.5, 3.8, 4.2, 4.8, 3.2, 5.0],\n            \"ground_truth\": (1.5, 4.0),\n            \"eta_i\": [0.05, -0.02, 0.03, -0.04, 0.00, 0.01, -0.03, 0.02],\n            \"sigma\": 0.05\n        },\n        # Case 2 (all gradients below gc, stiffness unexcited)\n        {\n            \"g_c\": 3.5,\n            \"g_i\": [2.0, 2.5, 3.0, 3.2, 3.4],\n            \"ground_truth\": (1.5, 4.0),\n            \"eta_i\": [0.04, -0.03, 0.05, -0.02, 0.01],\n            \"sigma\": 0.05\n        },\n        # Case 3 (high noise, stiffness partially excited)\n        {\n            \"g_c\": 3.5,\n            \"g_i\": [4.0, 4.5, 5.0, 5.5, 6.0],\n            \"ground_truth\": (1.5, 2.0),\n            \"eta_i\": [0.30, -0.25, 0.40, -0.35, 0.20],\n            \"sigma\": 0.30\n        }\n    ]\n\n    all_results = []\n    for case_data in test_cases_data:\n        result = process_case(case_data, priors, grid_spec)\n        all_results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([\n        \"[\" + \",\".join(map(str, res)) + \"]\" for res in all_results\n    ]) + \"]\"\n    \n    print(output_str)\n\n\ndef process_case(case_data, priors, grid_spec):\n    \"\"\"\n    Performs the full Bayesian analysis for a single case.\n    \"\"\"\n    g_c = case_data[\"g_c\"]\n    g_i = np.array(case_data[\"g_i\"])\n    D0_star, K_star = case_data[\"ground_truth\"]\n    eta_i = np.array(case_data[\"eta_i\"])\n    sigma_like = case_data[\"sigma\"]\n    \n    # 1. Generate observable data phi_i\n    phi_i = D0_star * g_i + K_star * np.maximum(0, g_i - g_c) + eta_i\n    \n    # 2. Setup grid\n    num_D0 = int(round((grid_spec['D0']['max'] - grid_spec['D0']['min']) / grid_spec['D0']['step'])) + 1\n    num_K = int(round((grid_spec['K']['max'] - grid_spec['K']['min']) / grid_spec['K']['step'])) + 1\n    D0_grid = np.linspace(grid_spec['D0']['min'], grid_spec['D0']['max'], num_D0)\n    K_grid = np.linspace(grid_spec['K']['min'], grid_spec['K']['max'], num_K)\n    dD0 = D0_grid[1] - D0_grid[0]\n    dK = K_grid[1] - K_grid[0]\n    \n    # 3. Calculate posterior on the grid\n    D0_mesh, K_mesh = np.meshgrid(D0_grid, K_grid, indexing='ij')\n    \n    # Log-prior. scipy.stats.gamma.logpdf handles x=0 correctly (returns -inf)\n    log_prior_D0 = gamma.logpdf(D0_mesh, a=priors['D0']['k'], scale=priors['D0']['theta'])\n    log_prior_K = gamma.logpdf(K_mesh, a=priors['K']['k'], scale=priors['K']['theta'])\n    log_prior = log_prior_D0 + log_prior_K\n    \n    # Log-likelihood using broadcasting\n    model_phi = (D0_mesh[..., np.newaxis] * g_i +\n                 K_mesh[..., np.newaxis] * np.maximum(0, g_i - g_c))\n    residuals = phi_i - model_phi\n    sum_sq_residuals = np.sum(residuals**2, axis=2)\n    log_likelihood = -0.5 * sum_sq_residuals / (sigma_like**2)\n    \n    # Unnormalized log posterior\n    log_posterior_un = log_prior + log_likelihood\n    \n    # 4. Normalize posterior\n    log_norm_const = logsumexp(log_posterior_un) + np.log(dD0 * dK)\n    log_posterior_norm = log_posterior_un - log_norm_const\n    posterior_norm = np.exp(log_posterior_norm)\n    \n    # 5. Calculate Marginals\n    marginal_D0_pdf = np.sum(posterior_norm, axis=1) * dK\n    marginal_K_pdf = np.sum(posterior_norm, axis=0) * dD0\n    \n    # 6. Calculate Posterior Means\n    mean_D0 = np.sum(D0_grid * marginal_D0_pdf) * dD0\n    mean_K = np.sum(K_grid * marginal_K_pdf) * dK\n    \n    # 7. Calculate Posterior Credible Intervals\n    cdf_D0 = np.cumsum(marginal_D0_pdf * dD0)\n    cdf_D0[-1] = 1.0  # Ensure CDF ends at 1 to handle potential float precision issues\n    lower_D0 = np.interp(0.025, cdf_D0, D0_grid)\n    upper_D0 = np.interp(0.975, cdf_D0, D0_grid)\n    \n    cdf_K = np.cumsum(marginal_K_pdf * dK)\n    cdf_K[-1] = 1.0\n    lower_K = np.interp(0.025, cdf_K, K_grid)\n    upper_K = np.interp(0.975, cdf_K, K_grid)\n    \n    # 8. Calculate Prior Credible Intervals and Shrinkage\n    prior_lower_D0 = gamma.ppf(0.025, a=priors['D0']['k'], scale=priors['D0']['theta'])\n    prior_upper_D0 = gamma.ppf(0.975, a=priors['D0']['k'], scale=priors['D0']['theta'])\n    prior_width_D0 = prior_upper_D0 - prior_lower_D0\n    post_width_D0 = upper_D0 - lower_D0\n    S_D0 = post_width_D0 / prior_width_D0 if prior_width_D0 > 0 else np.inf\n    \n    prior_lower_K = gamma.ppf(0.025, a=priors['K']['k'], scale=priors['K']['theta'])\n    prior_upper_K = gamma.ppf(0.975, a=priors['K']['k'], scale=priors['K']['theta'])\n    prior_width_K = prior_upper_K - prior_lower_K\n    post_width_K = upper_K - lower_K\n    S_K = post_width_K / prior_width_K if prior_width_K > 0 else np.inf\n    \n    # 9. Calculate Posterior Correlation\n    mean_D0_sq = np.sum(D0_grid**2 * marginal_D0_pdf) * dD0\n    var_D0 = mean_D0_sq - mean_D0**2\n    mean_K_sq = np.sum(K_grid**2 * marginal_K_pdf) * dK\n    var_K = mean_K_sq - mean_K**2\n    \n    mean_D0K = np.sum(D0_mesh * K_mesh * posterior_norm) * dD0 * dK\n    cov_D0K = mean_D0K - mean_D0 * mean_K\n    \n    # Add epsilon to prevent division by zero for perfectly determined parameters (var=0)\n    rho = cov_D0K / (np.sqrt(var_D0 * var_K) + 1e-15)\n    \n    # 10. Determine Identifiability\n    identifiable = (S_D0  0.6) and (S_K  0.6) and (abs(rho)  0.95)\n    \n    return [\n        mean_D0, lower_D0, upper_D0,\n        mean_K, lower_K, upper_K,\n        identifiable\n    ]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3715593"}]}