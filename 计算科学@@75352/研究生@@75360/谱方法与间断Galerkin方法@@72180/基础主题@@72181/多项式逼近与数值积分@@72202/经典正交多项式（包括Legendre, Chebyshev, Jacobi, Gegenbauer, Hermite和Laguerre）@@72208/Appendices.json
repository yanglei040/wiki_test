{"hands_on_practices": [{"introduction": "掌握正交多项式的一个基石是理解它们的归一化。本练习将引导你计算雅可比多项式的平方范数，这是模态谱展开中的一个基本量。通过运用罗德里格斯公式和分部积分法，你将对这些函数的解析结构及其与伽马函数 ($\\Gamma$ 函数) 的联系有更深刻的理解。[@problem_id:3370701]", "problem": "标量守恒律在参考区间 $[-1,1]$ 上的一个模态谱展开通常使用雅可比多项式族 $P_{n}^{(\\alpha,\\beta)}(x)$，其雅可比权重为 $w(x)=(1-x)^{\\alpha}(1+x)^{\\beta}$，其中 $\\alpha>-1$ 且 $\\beta>-1$。在间断伽辽金（DG）方法中，参考单元上的质量矩阵项由带权内积 $\\langle f,g \\rangle_{w}=\\int_{-1}^{1} f(x)\\,g(x)\\,w(x)\\,\\mathrm{d}x$ 产生。雅可比多项式 $P_{n}^{(\\alpha,\\beta)}(x)$ 由 Rodrigues 公式定义\n$$\nP_{n}^{(\\alpha,\\beta)}(x)=\\frac{(-1)^{n}}{2^{n} n!}\\,(1-x)^{-\\alpha}(1+x)^{-\\beta}\\,\\frac{\\mathrm{d}^{n}}{\\mathrm{d}x^{n}}\\Big[(1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\Big].\n$$\n假设 $\\alpha>-1$，$ \\beta>-1$ 且 $n\\in\\mathbb{N}$。仅使用上述定义以及分部积分的标准性质和欧拉 Beta 函数 $B(u,v)=\\int_{0}^{1} t^{u-1}(1-t)^{v-1}\\,\\mathrm{d}t=\\frac{\\Gamma(u)\\Gamma(v)}{\\Gamma(u+v)}$，计算带权内积 \n$$\n\\int_{-1}^{1} (1-x)^{\\alpha}(1+x)^{\\beta}\\,\\Big(P_{n}^{(\\alpha,\\beta)}(x)\\Big)^{2}\\,\\mathrm{d}x\n$$\n的精确值，其形式为关于 $n$、$\\alpha$ 和 $\\beta$ 的闭式解。你的最终答案必须是单一的解析表达式。", "solution": "问题是计算雅可比多项式 $P_{n}^{(\\alpha,\\beta)}(x)$ 关于相关联的雅可比权函数 $w(x)=(1-x)^{\\alpha}(1+x)^{\\beta}$ 的平方范数。需要计算的量是积分\n$$\nI_{n} = \\int_{-1}^{1} (1-x)^{\\alpha}(1+x)^{\\beta}\\,\\Big(P_{n}^{(\\alpha,\\beta)}(x)\\Big)^{2}\\,\\mathrm{d}x,\n$$\n其中 $\\alpha>-1$，$\\beta>-1$，且 $n$ 是一个非负整数。雅可比多项式 $P_{n}^{(\\alpha,\\beta)}(x)$ 由 Rodrigues 公式给出：\n$$\nP_{n}^{(\\alpha,\\beta)}(x)=\\frac{(-1)^{n}}{2^{n} n!}\\,(1-x)^{-\\alpha}(1+x)^{-\\beta}\\,\\frac{\\mathrm{d}^{n}}{\\mathrm{d}x^{n}}\\Big[(1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\Big].\n$$\n该公式表明 $P_{n}^{(\\alpha,\\beta)}(x)$ 是一个 $n$ 次多项式。我们将其首项系数记为 $k_n$。于是我们可以将 $P_{n}^{(\\alpha,\\beta)}(x)$ 写为\n$$\nP_{n}^{(\\alpha,\\beta)}(x) = k_{n} x^{n} + q_{n-1}(x),\n$$\n其中 $q_{n-1}(x)$ 是一个次数至多为 $n-1$ 的多项式。将此代入积分 $I_{n}$：\n$$\nI_{n} = \\int_{-1}^{1} w(x)\\,P_{n}^{(\\alpha,\\beta)}(x)\\,(k_{n} x^{n} + q_{n-1}(x))\\,\\mathrm{d}x = k_{n} \\int_{-1}^{1} w(x)\\,P_{n}^{(\\alpha,\\beta)}(x)\\,x^{n}\\,\\mathrm{d}x + \\int_{-1}^{1} w(x)\\,P_{n}^{(\\alpha,\\beta)}(x)\\,q_{n-1}(x)\\,\\mathrm{d}x.\n$$\n从 Rodrigues 公式可以推导出雅可比多项式的一个基本性质，即它们关于权函数 $w(x)$ 的正交性。具体来说，$P_{n}^{(\\alpha,\\beta)}(x)$ 与任何次数小于 $n$ 的多项式正交。由于 $q_{n-1}(x)$ 是 $m  n$ 的单项式 $x^m$ 的线性组合，第二个积分为零：\n$$\n\\int_{-1}^{1} w(x)\\,P_{n}^{(\\alpha,\\beta)}(x)\\,q_{n-1}(x)\\,\\mathrm{d}x = 0.\n$$\n因此，$I_{n}$ 的表达式简化为\n$$\nI_{n} = k_{n} \\int_{-1}^{1} x^{n}\\, P_{n}^{(\\alpha,\\beta)}(x)\\,w(x)\\,\\mathrm{d}x.\n$$\n现在，我们将 $P_{n}^{(\\alpha,\\beta)}(x)$ 的 Rodrigues 公式代入这个简化后的表达式。权函数 $w(x)=(1-x)^{\\alpha}(1+x)^{\\beta}$ 与公式中的 $(1-x)^{-\\alpha}(1+x)^{-\\beta}$ 项相消：\n$$\nI_{n} = k_{n} \\int_{-1}^{1} x^{n} \\left(\\frac{(-1)^{n}}{2^{n} n!}\\,\\frac{\\mathrm{d}^{n}}{\\mathrm{d}x^{n}}\\Big[(1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\Big]\\right) \\mathrm{d}x.\n$$\n我们通过进行 $n$ 次分部积分来继续。在每一步中，我们对 $x^n$ 求导，并对 $n$ 阶导数项积分。每一步的边界项都为零。这是因为 $(1-x)^{\\alpha+n}(1+x)^{\\beta+n}$ 的阶数 $j  n$ 的导数包含因子 $(1-x)^{\\alpha+n-j}$ 和 $(1+x)^{\\beta+n-j}$。由于 $\\alpha-1$ 且 $\\beta-1$，对于 $j \\le n-1$，我们有 $\\alpha+n-j  n-j-1 \\ge 0$ 和 $\\beta+n-j  n-j-1 \\ge 0$，这确保了边界项在 $x=\\pm 1$ 处为零。经过 $n$ 次分部积分后，我们得到：\n$$\nI_{n} = k_{n} \\frac{(-1)^{n}}{2^{n} n!} \\int_{-1}^{1} \\Big[(1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\Big] \\left( (-1)^{n} \\frac{\\mathrm{d}^{n}}{\\mathrm{d}x^{n}} x^{n} \\right) \\mathrm{d}x.\n$$\n由于 $\\frac{\\mathrm{d}^{n}}{\\mathrm{d}x^{n}} x^{n} = n!$ 且 $(-1)^{n}(-1)^{n} = 1$，表达式进一步简化为：\n$$\nI_{n} = k_{n} \\frac{1}{2^{n} n!} (n!) \\int_{-1}^{1} (1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\,\\mathrm{d}x = \\frac{k_{n}}{2^{n}} \\int_{-1}^{1} (1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\,\\mathrm{d}x.\n$$\n下一步是确定首项系数 $k_{n}$。从 Rodrigues 公式可以推导出，$P_{n}^{(\\alpha,\\beta)}(x)$ 的首项（$x^n$ 的系数）为：\n$$\nk_{n} = \\frac{\\Gamma(2n+\\alpha+\\beta+1)}{2^{n} n! \\Gamma(n+\\alpha+\\beta+1)}.\n$$\n最后一部分是积分项，可以使用欧拉 Beta 函数 $B(u,v) = \\int_0^1 t^{u-1}(1-t)^{v-1}\\,\\mathrm{d}t$ 来计算。令 $x=2t-1$，则 $\\mathrm{d}x=2\\,\\mathrm{d}t$：\n\\begin{align*} \\int_{-1}^{1} (1-x)^{\\alpha+n}(1+x)^{\\beta+n}\\,\\mathrm{d}x = \\int_{0}^{1} (2(1-t))^{\\alpha+n}(2t)^{\\beta+n}\\,(2\\,\\mathrm{d}t) \\\\ = 2^{\\alpha+n} 2^{\\beta+n} 2 \\int_{0}^{1} (1-t)^{\\alpha+n} t^{\\beta+n}\\,\\mathrm{d}t \\\\ = 2^{\\alpha+\\beta+2n+1} B(\\beta+n+1, \\alpha+n+1) \\\\ = 2^{\\alpha+\\beta+2n+1} \\frac{\\Gamma(\\beta+n+1)\\Gamma(\\alpha+n+1)}{\\Gamma(\\alpha+\\beta+2n+2)}. \\end{align*}\n将 $k_n$ 和积分的表达式代回 $I_n$ 的公式中：\n$$\nI_{n} = \\frac{1}{2^{n}} \\left( \\frac{\\Gamma(2n+\\alpha+\\beta+1)}{2^{n} n! \\Gamma(n+\\alpha+\\beta+1)} \\right) \\left( 2^{\\alpha+\\beta+2n+1} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{\\Gamma(2n+\\alpha+\\beta+2)} \\right).\n$$\n我们可以通过合并 $2$ 的幂次并使用性质 $\\Gamma(z+1)=z\\Gamma(z)$ 来简化此表达式：\n\\begin{align*} I_{n} = \\frac{2^{\\alpha+\\beta+2n+1}}{2^{2n} n!} \\frac{\\Gamma(2n+\\alpha+\\beta+1)}{\\Gamma(n+\\alpha+\\beta+1)} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{\\Gamma(2n+\\alpha+\\beta+2)} \\\\ = \\frac{2^{\\alpha+\\beta+1}}{n!} \\frac{\\Gamma(2n+\\alpha+\\beta+1)}{\\Gamma(n+\\alpha+\\beta+1)} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{(2n+\\alpha+\\beta+1)\\Gamma(2n+\\alpha+\\beta+1)} \\\\ = \\frac{2^{\\alpha+\\beta+1}}{n! (2n+\\alpha+\\beta+1)} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{\\Gamma(n+\\alpha+\\beta+1)}. \\end{align*}\n这就是该积分的最终闭式表达式。", "answer": "$$\n\\boxed{\\frac{2^{\\alpha+\\beta+1}}{n! (2n+\\alpha+\\beta+1)} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{\\Gamma(n+\\alpha+\\beta+1)}}\n$$", "id": "3370701"}, {"introduction": "尽管正交多项式在简单区域上提供了优雅的基，但实际应用常常涉及弯曲的几何形状。本练习探讨了等参映射如何破坏勒让德基的理想正交性，从而导致非对角质量矩阵。通过显式计算一个非对角项，你将对模态耦合这一在复杂网格上实现谱方法的关键挑战获得具体的认识。[@problem_id:3370740]", "problem": "考虑一维守恒律在单个参考单元 $\\xi \\in [-1,1]$ 上的间断 Galerkin (DG) 离散，其中到物理空间的映射是等参的，由 $x(\\xi) = \\xi + \\varepsilon \\,\\xi^{2}$ 给出，其中 $\\varepsilon \\in \\mathbb{R}$ 是一个微小但任意的曲率参数。基函数为 $[-1,1]$ 上的经典 Legendre 多项式 $\\{P_{k}(\\xi)\\}_{k=0}^{\\infty}$。由该映射导出的物理体积内积由 Jacobian 因子 $J(\\xi) = \\frac{dx}{d\\xi}$ 定义，因此 DG 质量矩阵的各项为\n$$\nM_{mn} = \\int_{-1}^{1} P_{m}(\\xi)\\,P_{n}(\\xi)\\,J(\\xi)\\,d\\xi.\n$$\n从积分中的变量替换、$[-1,1]$ 上 Legendre 多项式的 $L^{2}$-正交性，以及从其定义微分方程和 Rodrigues' 公式推导出的 Legendre 多项式的结构关系等核心定义出发，完成以下任务：\n- 解释为什么非恒定的 Jacobian $J(\\xi)$ 会改变物理空间中 Legendre 基的正交性，以及当积分由有限阶求积法则近似时，这如何导致模态耦合和潜在的混叠。\n- 在等参映射下，为实现 DG 中的自由流保持（即精确保持常数解），推导所需的离散度量恒等式，并清楚地陈述使该恒等式对于上述使用 Legendre 模态基的映射 $x(\\xi)$ 成立的多项式表示和微分上的一致性条件。\n\n然后，显式计算相邻模态的非对角质量矩阵项，\n$$\nM_{n,n+1} = \\int_{-1}^{1} P_{n}(\\xi)\\,P_{n+1}(\\xi)\\,J(\\xi)\\,d\\xi,\n$$\n将其表示为 $\\varepsilon$ 和整数阶 $n \\geq 0$ 的闭式解析函数。无需四舍五入。仅报告 $M_{n,n+1}$ 的最终闭式表达式作为您的答案。", "solution": "该问题需要分三部分回答：解释几何引起的模态耦合，推导自由流保持恒等式，以及显式计算一个特定的非对角质量矩阵项。\n\n首先，我们建立几何背景。从参考单元 $\\xi \\in [-1,1]$ 到物理单元 $x \\in [x(-1), x(1)]$ 的映射由 $x(\\xi) = \\xi + \\varepsilon \\xi^{2}$ 给出。该变换的 Jacobian 是 $J(\\xi) = \\frac{dx}{d\\xi} = 1 + 2\\varepsilon \\xi$。由于映射是关于 $\\xi$ 的二次函数，因此 Jacobian 是关于 $\\xi$ 的线性函数。\n\n**第一部分：改变的正交性、模态耦合与混叠**\n\nLegendre 多项式 $\\{P_k(\\xi)\\}_{k=0}^\\infty$ 在区间 $[-1,1]$ 上关于权重函数为1的标准（无权）$L^2$ 内积构成一个正交基。这种正交性表示为：\n$$\n\\langle P_m, P_n \\rangle = \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) \\,d\\xi = \\frac{2}{2n+1} \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是 Kronecker delta。\n\nDG 质量矩阵 $M_{mn}$ 是使用物理体积内积构造的，该内积包含 Jacobian $J(\\xi)$ 作为权重函数。其各项由下式给出：\n$$\nM_{mn} = \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) J(\\xi) \\,d\\xi\n$$\n代入给定的 Jacobian $J(\\xi) = 1 + 2\\varepsilon\\xi$，我们得到：\n$$\nM_{mn} = \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) (1 + 2\\varepsilon\\xi) \\,d\\xi = \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) \\,d\\xi + 2\\varepsilon \\int_{-1}^{1} \\xi P_m(\\xi) P_n(\\xi) \\,d\\xi\n$$\n第一项对应于由正交性常数缩放的标准对角质量矩阵。第二项 $2\\varepsilon \\int_{-1}^{1} \\xi P_m(\\xi) P_n(\\xi) \\,d\\xi$ 使得基函数关于这个新的加权内积不再正交。具体来说，当 $m \\neq n$ 时（例如，当 $|m-n|=1$ 时），这个积分通常非零，导致质量矩阵中出现非零的非对角项，即当 $m \\neq n$ 时 $M_{mn} \\neq 0$。\n\n这种现象被称为**模态耦合**。非恒定的 Jacobian $J(\\xi)$ 在不同模态（基函数）之间引入了耦合，而在 $J$ 为常数的典则仿射单元上，这些模态是解耦（正交）的。质量矩阵不再是对角的，这意味着其逆矩阵 $\\mathbf{M}^{-1}$ 是稠密的。这具有显著的计算影响，因为在具有显式时间积分器的 DG 格式中更新解需要乘以 $\\mathbf{M}^{-1}$。\n\n关于**混叠**，数值 DG 方法使用求积法则（如 Gauss-Legendre 求积）来近似积分。一个具有 $N_q$ 个点的求积法则对最高为 $2N_q-1$ 次的多项式是精确的。质量矩阵项 $M_{mn}$ 的被积函数是 $P_m(\\xi) P_n(\\xi) J(\\xi)$。如果基函数是最高为 $N$ 次的多项式，则此乘积的最高次数在 $m=n=N$ 时出现。$P_N(\\xi) P_N(\\xi) J(\\xi)$ 的次数是 $N+N+1 = 2N+1$。为了精确计算所有质量矩阵项，求积法则必须对至少 $2N+1$ 次的多项式精确，这要求 $2N_q - 1 \\ge 2N+1$，即 $N_q \\ge N+2$。如果使用点数较少的求积法则（一种为提高效率而常用的“非精确积分”或“欠积分”策略），积分将不会被精确计算。这种近似中的误差，称为混叠误差，实际上将能量从求积法则无法分辨的更高阶多项式模态投射到多项式空间 $\\mathbb{P}_N$ 内的现有模态上，从而破坏了解。\n\n**第二部分：自由流保持与离散度量恒等式**\n\n自由流保持要求用于守恒律 $\\partial_t u + \\partial_x f(u) = 0$ 的 DG 格式能够精确地保持常数状态 $u(x,t) = c$。在物理单元 $K$ 上的弱形式中，这意味着对于 $u=c$，空间残差必须为零。对于一个检验函数 $v_h$，空间残差为：\n$$\nR_{sp}(v_h, u_h) = \\int_K v_h \\frac{\\partial f(u_h)}{\\partial x} \\,dx\n$$\n使用 $\\partial_x = \\frac{1}{J(\\xi)} \\partial_\\xi$ 和 $dx=J(\\xi)d\\xi$ 变换到参考单元 $\\xi \\in [-1,1]$：\n$$\nR_{sp}(v_h, u_h) = \\int_{-1}^{1} v_h(\\xi) \\left( \\frac{1}{J(\\xi)} \\frac{\\partial f(u_h(\\xi))}{\\partial \\xi} \\right) J(\\xi) \\,d\\xi = \\int_{-1}^{1} v_h(\\xi) \\frac{\\partial f(u_h(\\xi))}{\\partial \\xi} \\,d\\xi\n$$\n一个关键的观察是 Jacobian 因子 $J(\\xi)$ 和 $1/J(\\xi)$ 解析地相互抵消。这就是**度量恒等式**。通过分部积分得到标准的 DG 弱形式：\n$$\nR_{sp}(v_h, u_h) = \\left[ v_h(\\xi) f(u_h(\\xi)) \\right]_{-1}^{1} - \\int_{-1}^{1} \\frac{\\partial v_h(\\xi)}{\\partial \\xi} f(u_h(\\xi)) \\,d\\xi\n$$\n如果解是常数自由流 $u_h = c$，那么 $f(u_h)=f(c)$ 也是常数。残差变为：\n$$\nR_{sp}(v_h, c) = f(c) \\left[ v_h(\\xi) \\right]_{-1}^{1} - f(c) \\int_{-1}^{1} \\frac{\\partial v_h(\\xi)}{\\partial \\xi} \\,d\\xi\n$$\n根据微积分基本定理，$\\int_{-1}^{1} \\frac{\\partial v_h}{\\partial \\xi} d\\xi = v_h(1) - v_h(-1)$。因此，\n$$\nR_{sp}(v_h, c) = f(c) (v_h(1) - v_h(-1)) - f(c) (v_h(1) - v_h(-1)) = 0\n$$\n这表明，对于常数状态，对空间残差的体积分贡献恒等于零。如果边界上的数值通量也取自由流值，即 $f(u_h^*) = f(c)$，则实现了自由流保持。\n\n度量恒等式的“离散”方面涉及确保这种抵消在数值实现中得以保持的**一致性条件**：\n1.  **格式一致性**：微分算子的弱形式必须被表述为 $\\int v_h(\\xi) (\\partial_\\xi u_h(\\xi)) d\\xi$，从而嵌入几何项的解析抵消。它决不能以需要将 $1/J(\\xi)$ 近似为多项式的方式来表述，因为这会破坏完美的抵消。对于给定的映射，如上所示，这是直接的。\n2.  **求积一致性**：所得积分必须被精确计算。如果 $v_h, u_h \\in \\mathbb{P}_N$，则来自刚度矩阵的项 $\\int v_h (\\partial_\\xi u_h) d\\xi$ 涉及一个最高为 $N + (N-1) = 2N-1$ 次的多项式。这需要一个至少有 $N$ 个点的 Gauss 求积法则。如前所述，质量矩阵积分需要一个对 $2N+1$ 次多项式精确的求积法则。如果使用这些求积法则，对常数状态的空间算子的离散计算将为零，从而保持自由流。\n\n**第三部分：$M_{n,n+1}$ 的计算**\n\n相邻模态 $n$ 和 $n+1$ ($n \\geq 0$) 的非对角质量矩阵项由下式给出：\n$$\nM_{n,n+1} = \\int_{-1}^{1} P_n(\\xi) P_{n+1}(\\xi) J(\\xi) \\,d\\xi = \\int_{-1}^{1} P_n(\\xi) P_{n+1}(\\xi) (1 + 2\\varepsilon\\xi) \\,d\\xi\n$$\n这可以分成两个积分：\n$$\nM_{n,n+1} = \\int_{-1}^{1} P_n(\\xi) P_{n+1}(\\xi) \\,d\\xi + 2\\varepsilon \\int_{-1}^{1} \\xi P_n(\\xi) P_{n+1}(\\xi) \\,d\\xi\n$$\n由于 Legendre 多项式对不同阶数的正交性，第一个积分为零。因此，我们只需要计算第二个积分：\n$$\nM_{n,n+1} = 2\\varepsilon \\int_{-1}^{1} \\xi P_n(\\xi) P_{n+1}(\\xi) \\,d\\xi\n$$\n为了计算这个积分，我们使用 Legendre 多项式的三项递推关系：\n$$\n(k+1)P_{k+1}(x) = (2k+1)x P_k(x) - k P_{k-1}(x)\n$$\n重新整理得到 $x P_k(x)$ 项：\n$$\nx P_k(x) = \\frac{k+1}{2k+1} P_{k+1}(x) + \\frac{k}{2k+1} P_{k-1}(x)\n$$\n令 $k=n$ 和 $x=\\xi$。将此代入我们的积分中：\n$$\nM_{n,n+1} = 2\\varepsilon \\int_{-1}^{1} \\left( \\frac{n+1}{2n+1} P_{n+1}(\\xi) + \\frac{n}{2n+1} P_{n-1}(\\xi) \\right) P_{n+1}(\\xi) \\,d\\xi\n$$\n将 $P_{n+1}(\\xi)$ 分配到各项中：\n$$\nM_{n,n+1} = 2\\varepsilon \\left( \\frac{n+1}{2n+1} \\int_{-1}^{1} P_{n+1}(\\xi)^2 \\,d\\xi + \\frac{n}{2n+1} \\int_{-1}^{1} P_{n-1}(\\xi) P_{n+1}(\\xi) \\,d\\xi \\right)\n$$\n再次地，根据正交性，第二个积分 $\\int_{-1}^{1} P_{n-1}(\\xi) P_{n+1}(\\xi) \\,d\\xi$ 对所有 $n \\geq 0$ 都为零（如果 $n=0$，该项乘以 $n=0$；如果 $n \\geq 1$，指数相差为 2）。第一个积分是归一化常数：\n$$\n\\int_{-1}^{1} P_{n+1}(\\xi)^2 \\,d\\xi = \\frac{2}{2(n+1)+1} = \\frac{2}{2n+3}\n$$\n将此结果代回：\n$$\nM_{n,n+1} = 2\\varepsilon \\left( \\frac{n+1}{2n+1} \\cdot \\frac{2}{2n+3} + 0 \\right) = \\frac{4\\varepsilon(n+1)}{(2n+1)(2n+3)}\n$$\n该公式提供了指定非对角质量矩阵项的闭式解析表达式，其是关于曲率参数 $\\varepsilon$ 和模态指数 $n \\geq 0$ 的函数。", "answer": "$$\\boxed{\\frac{4\\varepsilon(n+1)}{(2n+1)(2n+3)}}$$", "id": "3370740"}, {"introduction": "正交多项式的理论性质直接影响着基于它们构建的数值格式的精度。这项基于编程的练习要求你使用不同的勒让德基点集，为平流方程构建一个间断伽辽金谱元法 (DGSEM) 算子。通过进行色散和耗散分析，你将亲眼看到节点（源于勒让德多项式及其导数的零点）的选择如何影响一个前沿数值方法的性能。[@problem_id:3370734]", "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，其中常数速度 $a0$，定义在一个周期性域上。该域被划分为大小为 $h$ 的均匀网格单元。在每次数为 $p$ 的间断 Galerkin 谱元法 (DGSEM) 中，我们使用参考单元 $\\xi \\in [-1,1]$ 中的 $p+1$ 个插值点和一个由配置求积诱导的对角质量矩阵，将 $u$ 表示为次数为 $p$ 的节点多项式。插值点的两种典型选择是 Legendre-Gauss (LG) 点和 Legendre-Gauss-Lobatto (LGL) 点。强形式的 DGSEM 可以由以下内容构建：\n\n- 关于经典正交多项式的基本事实：Legendre 多项式 $P_n(x)$ 在 $[-1,1]$ 上关于权重 $1$ 是正交的，满足 $P_n(1)=1$ 和 $P_n(-1)=(-1)^n$，并且在端点处的导数有简单的恒等式。LG 点是 $P_{p+1}(x)$ 的 $p+1$ 个根，而 LGL 点是 $(1-x^2)P_p'(x)$ 的 $p+1$ 个根，包括端点 $x=\\pm 1$。Jacobi 多项式 $P_n^{(\\alpha,\\beta)}(x)$ 通过 $P_p'(x)$ 与导数相联系，其在 $(-1,1)$ 内的零点与 $P_{p-1}^{(1,1)}(x)$ 相同。LG 和 LGL 的求积权重是已知的，并定义了对角质量矩阵。\n\n- 当微分算子由与配置节点相关的 Lagrange 基的微分构建，并且表面项通过数值通量添加时，DGSEM 中实现的分部求和 (SBP) 性质。用于平流的强形式半离散算子结合了体积导数项和由单元交界面上的通量决定的提升的表面修正项。\n\n您将通过对均匀周期性网格的块循环算子进行半离散 Fourier 分析，来量化 LG 和 LGL 点的 DGSEM 的色散（相速度）和耗散（振幅衰减）。在整个过程中，假设 $a=1$ 和 $h=1$，角度必须以弧度处理。\n\n从上述基本基础开始：\n\n1. 对于每种节点选择（LG 和 LGL），使用从以配置节点为根的多项式 $L(x)$ 推导出的 Lagrange 基微分公式，构建 $[-1,1]$ 上的节点微分矩阵。具体来说，使用恒等式，即 Lagrange 基 $l_j(x)$ 可以表示为 $l_j(x) = \\dfrac{L(x)}{(x-x_j)L'(x_j)}$，因此微分矩阵的项为 $D_{ij} = \\dfrac{1/L'(x_j)}{(1/L'(x_i))\\,(x_i - x_j)}$（对于 $i\\neq j$）和 $D_{ii} = -\\sum_{j\\neq i} D_{ij}$。对于 LG，$L(x) = P_{p+1}(x)$；对于 LGL，$L(x) = (1-x^2)P_p'(x)$，其中 $L'(x)$ 使用标准 Legendre 多项式导数恒等式进行计算。求积权重定义了对角质量矩阵 $M$。\n\n2. 定义边界求值向量 $r_L$ 和 $r_R$，它们通过在 $x=-1$ 和 $x=1$ 处计算 Lagrange 基，将节点值映射到左、右面值。使用由权重 $1/L'(x_j)$ 诱导的重心坐标求值来稳定地计算 LG 和 LGL 的 $r_L$ 和 $r_R$（注意，在 LGL 端点，相应的基函数等于 $1$，其他为 $0$）。\n\n3. 对于给定测试集中的每个无量纲波数 $\\theta = k h$，为 $a0$ 的迎风数值通量构建半离散 DGSEM 强形式算子的 $p+1 \\times p+1$ Fourier 符号 $A(\\theta)$。在均匀网格上使用 Bloch 拟设，使得左邻单元的右面值贡献一个因子 $z^{-1}$，其中 $z = e^{i\\theta}$。强形式的符号矩阵为\n$$\nA(\\theta) = -\\frac{2}{h}\\,a\\,D \\;-\\;\\frac{2}{h}\\,a\\,M^{-1}\\,r_L\\left(z^{-1}r_R^\\top - r_L^\\top\\right).\n$$\n当 $a=1$ 和 $h=1$ 时，此式得到适当简化。\n\n4. 对于每个 $\\theta$，计算 $A(\\theta)$ 的所有特征值 $\\lambda(\\theta)$，并定义复角频率 $\\omega(\\theta) = i\\,\\lambda(\\theta)$。相速度为 $c_p(\\theta) = \\dfrac{\\mathrm{Re}(\\omega(\\theta))}{k} = -\\dfrac{\\mathrm{Im}(\\lambda(\\theta))}{\\theta}$，耗散为 $d(\\theta) = -\\mathrm{Im}(\\omega(\\theta)) = -\\mathrm{Re}(\\lambda(\\theta))$，群速度为 $c_g(\\theta) = \\dfrac{d}{dk}\\mathrm{Re}(\\omega(\\theta))$，您应在给定的 $\\theta$ 值网格上，通过 $\\mathrm{Re}(\\omega(\\theta))$ 相对于 $k=\\theta/h$ 的有限差分来近似该值。\n\n5. 通过在测试集中的最小 $\\theta$ 处，选择其相速度 $c_p(\\theta)$ 最接近精确速度 $a$ 的特征值，来为每种方法识别物理分支。对于后续的 $\\theta$，通过在该 $\\theta$ 处的特征值中选择其相速度最接近先前选定的分支相速度的那个，来延续该分支。\n\n6. 对于每种方法和每个 $p$，在给定的 $\\theta$ 网格上计算最大绝对相速度误差 $\\max_{\\theta} |c_p(\\theta)-a|$、在定义了中心差分的内部 $\\theta$ 值上的最大绝对群速度误差，以及最大耗散 $\\max_{\\theta} d(\\theta)$。\n\n您的程序必须实现以上所有步骤，除了陈述的基本恒等式之外，不使用任何快捷公式。角度必须是弧度。除弧度外，不涉及其他物理单位。\n\n测试套件：\n- 使用 $a=1$ 和 $h=1$。\n- 使用多项式次数 $p \\in \\{1,3,6\\}$。\n- 对于每个 $p$，比较两种节点选择：LG 和 LGL。\n- 使用 $\\theta$ 网格 $\\{\\theta_m\\}_{m=1}^9$，其中 $\\theta_m = \\frac{\\pi}{16} m$，对于 $m=1,2,\\dots,9$（即从 $\\pi/16$ 到 $9\\pi/16$）。这测试了低到中等波数，确保覆盖光滑和色散区域，同时避免了平凡的 $\\theta=0$ 情况。\n- 对于每个 $(p,\\text{nodes})$ 组合，生成三个浮点数：最大绝对相速度误差、最大绝对群速度误差（仅在内点上通过中心差分计算）和最大耗散。\n\n最终输出格式：\n- 按固定顺序汇总六个比较的结果：对于 $p=1$，先 LGL 后 LG；对于 $p=3$，先 LGL 后 LG；对于 $p=6$，先 LGL 后 LG。\n- 对于每次比较，按上述顺序输出三个浮点数。\n- 您的程序应生成单行输出，包含十八个浮点数，形式为逗号分隔的列表，并用方括号括起来。例如：\"[f1,f2,...,f18]\"。", "solution": "此问题的目标是为周期域上的一维线性平流方程 $u_t + a\\,u_x = 0$ 的间断 Galerkin 谱元法 (DGSEM) 进行色散和耗散分析。该分析是在单元大小为 $h$、多项式近似次数为 $p$ 的均匀网格上，采用半离散 Fourier 方法进行的。我们的任务是比较两种常见的单元内配置点选择：Legendre-Gauss (LG) 点和 Legendre-Gauss-Lobatto (LGL) 点。分析需要构建强形式的 DGSEM 算子，然后检查其 Fourier 符号的特征值，以确定相速度、群速度和耗散等关键属性。在整个分析过程中，平流速度设为 $a=1$，单元大小设为 $h=1$。\n\n求解方法结构如下：\n1.  **节点集和基的构建**：对于给定的多项式次数 $p$，我们首先确定参考单元 $\\xi \\in [-1, 1]$ 内 LG 和 LGL 集的 $p+1$ 个节点。然后，我们构建节点微分矩阵 $D$ 和对角质量矩阵 $M$。\n2.  **半离散算子符号**：我们定义边界求值向量 $r_L$ 和 $r_R$，并用它们来构建带有迎风通量的强形式 DGSEM 算子的 Fourier 符号 $A(\\theta)$。\n3.  **色散与耗散分析**：对于无量纲波数 $\\theta = kh$ 的网格，我们计算 $A(\\theta)$ 的特征值。从这些特征值中，我们推导出数值相速度 $c_p(\\theta)$、耗散 $d(\\theta)$ 和群速度 $c_g(\\theta)$。在整个波数谱中识别并跟踪一个物理模式。\n4.  **误差量化**：最后，我们为每种配置（$p$ 和节点类型）计算三个误差指标：最大绝对相速度误差 $|c_p(\\theta) - a|$、最大绝对群速度误差 $|c_g(\\theta) - a|$ 和最大耗散 $d(\\theta)$。\n\n### 步骤 1：节点集、微分和质量矩阵\n\n节点 DGSEM 的基础是每个单元内的配置点集。\n对于次数为 $p$ 的多项式，我们使用 $p+1$ 个点。设 $N=p+1$。\n-   **Legendre-Gauss (LG) 节点**：这些是 Legendre 多项式 $P_N(\\xi)$ 的 $N$ 个根。这些点严格位于区间 $(-1, 1)$ 内。\n-   **Legendre-Gauss-Lobatto (LGL) 节点**：这些是多项式 $(1-\\xi^2)P_p'(\\xi)$ 的 $N$ 个根。这些点包括端点 $\\xi = \\pm 1$ 和 $P_p'(\\xi)$ 的 $p-1$ 个根，这些根与 Jacobi 多项式 $P_{p-1}^{(1,1)}(\\xi)$ 的根相同。\n\n微分矩阵 $D$ 由 Lagrange 基多项式 $l_j(\\xi)$ 在节点 $\\xi_i$ 处的导数构建而成。项 $D_{ij} = l_j'(\\xi_i)$ 使用从以配置节点为根的多项式 $L(\\xi)$ 推导出的公式计算：\n$$\nD_{ij} = \\begin{cases} \\dfrac{L'(\\xi_i)}{(\\xi_i - \\xi_j)L'(\\xi_j)}  i \\neq j \\\\ -\\sum_{k\\neq i} D_{ik}  i=j \\end{cases}\n$$\n$L(\\xi)$ 的选择取决于节点集：\n-   对于 LG 节点，$L(\\xi)$ 与 $P_{p+1}(\\xi)$ 成比例。\n-   对于 LGL 节点，$L(\\xi)$ 与 $(1-\\xi^2)P_p'(\\xi)$ 成比例。\n节点处 $L'(\\xi_j)$ 的值使用 Legendre 多项式及其导数的标准恒等式计算。\n\n配置格式的质量矩阵 $M$ 是对角矩阵，其对角项 $M_{jj}$ 是与节点 $\\xi_j$ 相关联的求积权重 $w_j$。对于 LG 和 LGL 点，这些权重都是众所周知的：\n-   对于 LG 求积，权重由 $w_j = \\frac{2}{(1-\\xi_j^2)[P_{p+1}'(\\xi_j)]^2}$ 给出。\n-   对于 LGL 求积，在端点 $\\xi_j=\\pm 1$ 处的权重为 $w_j = \\frac{2}{p(p+1)}$，在内部节点处的权重为 $w_j = \\frac{2}{p(p+1)[P_p(\\xi_j)]^2}$。\n\n### 步骤 2：边界向量和算子符号\n\n强形式 DG 算子需要在单元边界 $\\xi = -1$ 和 $\\xi = 1$ 处评估解。这通过边界求值向量 $r_L$ 和 $r_R$ 实现，其项分别是 Lagrange 基函数在左、右边界的值：$(r_L)_j = l_j(-1)$ 和 $(r_R)_j = l_j(1)$。\n-   对于 LGL 节点，由于 $\\xi_0 = -1$ 和 $\\xi_p = 1$（假设节点已排序），基函数具有属性 $l_j(\\pm 1) = \\delta_{j,0 \\text{ or } p}$。这使 $r_L$ 和 $r_R$ 简化为标准基向量，例如 $r_L = [1, 0, \\dots, 0]^\\top$。\n-   对于 LG 节点，它们都在单元内部，值 $l_j(\\pm 1)$ 不为零，并使用 Lagrange 基的定义进行计算。\n\n有了这些组件，带有迎风通量的线性平流方程的半离散算子的 Fourier 符号 $A(\\theta)$ 由下式给出：\n$$\nA(\\theta) = -\\frac{2a}{h}D - \\frac{2a}{h}M^{-1} r_L \\left( z^{-1}r_R^\\top - r_L^\\top \\right)\n$$\n其中 $z = e^{i\\theta}$，$i = \\sqrt{-1}$，$\\theta=kh$ 是无量纲波数。带 $D$ 的项代表体积导数，而第二项代表提升的表面通量修正。\n\n### 步骤 3：基于特征值的分析\n\n波数为 $k$ 的 Fourier 模式的时间演化由符号矩阵 $A(\\theta)$ 的特征值 $\\lambda(\\theta)$ 控制。对于每个 $\\theta$，我们计算 $p+1$ 个特征值。数值复角频率定义为 $\\omega(\\theta) = i\\lambda(\\theta)$。由此，我们定义：\n-   **相速度**：$c_p(\\theta) = \\dfrac{\\mathrm{Re}(\\omega(\\theta))}{k} = -\\dfrac{\\mathrm{Im}(\\lambda(\\theta))}{\\theta}$。这代表单个 Fourier 模式的传播速度。精确相速度为 $a$。\n-   **耗散**：$d(\\theta) = -\\mathrm{Im}(\\omega(\\theta)) = -\\mathrm{Re}(\\lambda(\\theta))$。这代表模式振幅的指数衰减率。对于精确方程，耗散为零。\n-   **群速度**：$c_g(\\theta) = \\dfrac{d}{dk}\\mathrm{Re}(\\omega(\\theta))$。这代表波包的传播速度。精确群速度为 $a$。我们使用 $\\theta$ 值网格上的中心有限差分来近似这个值。\n\n一个关键步骤是识别特征值的“物理分支”，它对应于正确逼近物理波传播的模式。从最小的非零 $\\theta$ 开始，我们选择其相速度 $c_p$ 最接近精确速度 $a=1$ 的特征值。对于后续的 $\\theta$ 值，我们通过选择其相速度最接近先前选择的物理模式的相速度的特征值来保持连续性。\n\n### 步骤 4：误差计算\n\n在指定 $\\theta$ 值网格上识别出物理分支的属性后，我们通过计算三个指标来量化每种格式（$p$，节点类型）的性能：\n1.  最大绝对相速度误差，$\\max_{\\theta} |c_p(\\theta) - a|$。\n2.  最大绝对群速度误差，$\\max_{\\theta_{\\text{int}}} |c_g(\\theta) - a|$，在定义了中心差分的 $\\theta$ 网格内点上计算。\n3.  最大耗散，$\\max_{\\theta} d(\\theta)$。\n\n这些指标简明地总结了格式在波传播和振幅保持方面的准确性。以下程序实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\nfrom scipy.special import eval_legendre, roots_legendre, roots_jacobi\n\ndef get_nodes_weights_Lprime(p, node_type):\n    \"\"\"\n    Computes the nodes, quadrature weights, and values of L'(x_j) for LG and LGL points.\n    L(x) is the polynomial whose roots are the collocation nodes.\n    \"\"\"\n    N = p + 1\n    if node_type == 'LG':\n        nodes, weights = roots_legendre(N)\n        # For LG, L(x) is proportional to P_N(x).\n        # We need values of L'(x_j) which are proportional to P_N'(x_j) at nodes x_j.\n        # Identity at roots of P_N(x): (1-x_j^2)P_N'(x_j) = N*P_{N-1}(x_j).\n        L_prime_vals = N * eval_legendre(N - 1, nodes) / (1 - nodes**2)\n        return nodes, weights, L_prime_vals\n\n    elif node_type == 'LGL':\n        if p == 0:\n            nodes = np.array([0.0])\n        elif p == 1:\n            internal_nodes = np.array([])\n        else: # p > 1\n            internal_nodes, _ = roots_jacobi(p - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], np.sort(internal_nodes), [1.0]))\n        \n        # Weights for LGL\n        weights = np.zeros(N)\n        weights[0] = weights[-1] = 2.0 / (p * (p + 1))\n        if p > 1:\n            weights[1:-1] = 2.0 / (p * (p + 1) * eval_legendre(p, internal_nodes)**2)\n            \n        # For LGL, L(x) is proportional to (1-x^2)P_p'(x).\n        # We need L'(x_j) at the nodes x_j.\n        L_prime_vals = np.zeros(N)\n        # At x_j = -1: L'(-1) = 2*P_p'(-1) = 2*(-1)^(p-1)*p(p+1)/2 = (-1)^(p-1)*p(p+1)\n        L_prime_vals[0] = (-1.0)**(p - 1) * p * (p + 1)\n        # At x_j = +1: L'(1) = -2*P_p'(1) = -2*p(p+1)/2 = -p(p+1)\n        L_prime_vals[-1] = -p * (p + 1)\n        # At internal nodes, P_p'(x_j)=0. L'(x_j) = (1-x_j^2)P_p''(x_j) = -p(p+1)P_p(x_j)\n        if p > 1:\n             L_prime_vals[1:-1] = -p * (p + 1) * eval_legendre(p, internal_nodes)\n             \n        return nodes, weights, L_prime_vals\n\ndef get_diff_matrix(nodes, L_prime_vals):\n    \"\"\"Constructs the nodal differentiation matrix D.\"\"\"\n    N = len(nodes)\n    D = np.zeros((N, N))\n    # Use broadcasting for efficient computation of off-diagonal elements\n    nodes_col = nodes[:, np.newaxis]\n    nodes_row = nodes[np.newaxis, :]\n    L_prime_col = L_prime_vals[:, np.newaxis]\n    L_prime_row = L_prime_vals[np.newaxis, :]\n    \n    # Temporarily disable division by zero warnings for the diagonal\n    with np.errstate(divide='ignore', invalid='ignore'):\n         D = L_prime_col / (L_prime_row * (nodes_col - nodes_row))\n    \n    np.fill_diagonal(D, 0)\n    # Diagonal entries are sum of off-diagonals in the row\n    D_diag = -np.sum(D, axis=1)\n    np.fill_diagonal(D, D_diag)\n    return D\n\ndef get_boundary_vectors(p, nodes, L_prime_vals, node_type):\n    \"\"\"Constructs boundary evaluation vectors r_L and r_R.\"\"\"\n    N = p + 1\n    r_L = np.zeros(N)\n    r_R = np.zeros(N)\n    \n    if node_type == 'LGL':\n        r_L[0] = 1.0\n        r_R[-1] = 1.0\n    elif node_type == 'LG':\n        # For LG, L(x) is proportional to P_N(x).\n        # l_j(x) = L(x) / ((x - x_j) * L'(x_j))\n        L_at_1 = 1.0  # P_N(1) = 1\n        L_at_minus_1 = (-1.0)**N \n        \n        r_R = L_at_1 / ((1.0 - nodes) * L_prime_vals)\n        r_L = L_at_minus_1 / ((-1.0 - nodes) * L_prime_vals)\n        \n    return r_L, r_R\n\ndef analyze_scheme(p, node_type, a, h, thetas):\n    \"\"\"Performs the full dispersion/dissipation analysis for a given scheme.\"\"\"\n    nodes, weights, L_prime_vals = get_nodes_weights_Lprime(p, node_type)\n    \n    D = get_diff_matrix(nodes, L_prime_vals)\n    M_inv = np.diag(1.0 / weights)\n    r_L, r_R = get_boundary_vectors(p, nodes, L_prime_vals, node_type)\n    \n    physical_branch_cp = []\n    physical_branch_d = []\n    physical_branch_omega_re = []\n    prev_cp = a # Start tracking from the exact speed\n    \n    for theta in thetas:\n        z = np.exp(1j * theta)\n        \n        A_theta = (-2*a/h * D) - (2*a/h * M_inv @ (r_L[:, np.newaxis] @ (z**(-1) * r_R[np.newaxis, :] - r_L[np.newaxis, :])))\n        \n        lambdas, _ = linalg.eig(A_theta)\n        \n        k = theta / h\n        \n        cps = -lambdas.imag / k if k != 0 else np.zeros_like(lambdas)\n        ds = -lambdas.real\n        \n        # Branch tracking\n        idx = np.argmin(np.abs(cps - prev_cp))\n        current_cp = cps[idx]\n        current_d = ds[idx]\n        current_omega_re = -lambdas[idx].imag\n        \n        physical_branch_cp.append(current_cp)\n        physical_branch_d.append(current_d)\n        physical_branch_omega_re.append(current_omega_re)\n        \n        prev_cp = current_cp\n        \n    physical_branch_cp = np.array(physical_branch_cp)\n    physical_branch_d = np.array(physical_branch_d)\n    physical_branch_omega_re = np.array(physical_branch_omega_re)\n\n    max_phase_speed_error = np.max(np.abs(physical_branch_cp - a))\n    max_dissipation = np.max(physical_branch_d)\n\n    # Group velocity on interior points of the theta grid\n    group_velocities = []\n    if len(thetas) > 2:\n        for i in range(1, len(thetas) - 1):\n            omega_re_plus = physical_branch_omega_re[i+1]\n            omega_re_minus = physical_branch_omega_re[i-1]\n            k_plus = thetas[i+1] / h\n            k_minus = thetas[i-1] / h\n            cg = (omega_re_plus - omega_re_minus) / (k_plus - k_minus)\n            group_velocities.append(cg)\n    \n    max_group_velocity_error = np.max(np.abs(np.array(group_velocities) - a)) if group_velocities else 0.0\n\n    return max_phase_speed_error, max_group_velocity_error, max_dissipation\n\ndef solve():\n    # Define the test cases from the problem statement.\n    a = 1.0\n    h = 1.0\n    ps = [1, 3, 6]\n    node_types = ['LGL', 'LG']\n    \n    thetas = np.array([m * np.pi / 16.0 for m in range(1, 10)])\n\n    results = []\n    for p_val in ps:\n        for node_type_val in node_types:\n            errors = analyze_scheme(p_val, node_type_val, a, h, thetas)\n            results.extend(errors)\n\n    # Final print statement in the exact required format.\n    # The problem asks for 12 floats, but p={1,3,6} x nodes={LGL,LG} x errors=3 gives 18 floats.\n    # The example output format suggests \"f1,f2,...,f12\". I'll assume the example was illustrative and output all 18 results.\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\nsolve()\n```", "id": "3370734"}]}