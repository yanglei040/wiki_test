{"hands_on_practices": [{"introduction": "为了建立对勒贝格常数的直观理解，我们从一个具体的低阶计算示例开始。这个练习将向您展示在谱方法中因近似几何项而产生的误差，以及勒贝格常数如何为这种“几何混淆”效应提供一个定量的度量。通过亲手计算，您可以清晰地看到勒贝格常数和函数属性是如何共同影响数值精度的。", "problem": "考虑参考区间 $[-1,1]$ 上的一个一维曲线谱元，其光滑、保向的映射 $x(\\xi)$ 由 $x(\\xi) = \\xi + \\alpha \\xi^{4}$ 给出，其中 $\\alpha \\in \\mathbb{R}$ 满足 $|\\alpha|  \\frac{1}{4}$ 以确保雅可比行列式为正。令雅可比行列式（度量项）为 $J(\\xi) = \\frac{dx}{d\\xi} = 1 + 4\\alpha\\xi^{3}$。假设在 Legendre–Gauss–Lobatto (LGL) 节点上使用 $p=2$ 次的节点多项式近似。定义勒贝格常数 $\\Lambda_{p}$ 为与 $p$ 次 LGL 节点相关的勒贝格函数的 $L^{\\infty}$ 范数，并定义几何混叠界为 $E_{\\mathrm{geo}} := \\|J - I_{p}J\\|_{L^{\\infty}([-1,1])}$，其中 $I_{p}$ 表示 LGL 节点上的 $p$ 次 Lagrange 插值算子。\n\n在一个非连续 Galerkin (DG) 或节点谱配置公式中，微分前将节点场与插值后的度量项相乘，由几何形状引起的主阶节点场扰动可由乘积 $\\Lambda_{p}E_{\\mathrm{geo}}$ 作为上界。在 LGL 节点上使用 $p=2$ 次，并仅利用上述定义以及多项式在 $[-1,1]$ 上的基本性质，计算\n$$\nC(\\alpha) := \\Lambda_{2}\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}\n$$\n作为 $\\alpha$ 的显式函数的闭式表达式。\n\n你的最终答案必须是 $C(\\alpha)$ 的一个简化的解析表达式，不含不等号。无需四舍五入。最终答案无需单位。", "solution": "题目要求计算量 $C(\\alpha) = \\Lambda_{2} \\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}$，其中 $J(\\xi) = 1 + 4\\alpha\\xi^3$ 是坐标变换的雅可比行列式，$I_{2}$ 是 Legendre–Gauss–Lobatto (LGL) 节点上的 2 次 Lagrange 插值算子，$\\Lambda_{2}$ 是相应的勒贝格常数。\n\n计算可分为两个主要部分：确定勒贝格常数 $\\Lambda_{2}$，以及计算插值误差范数 $\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}$。\n\n**第 1 部分：计算勒贝格常数 $\\Lambda_{2}$**\n\n$p$ 次 LGL 节点是方程 $(1-\\xi^2)P'_{p}(\\xi) = 0$ 的根，其中 $P_p(\\xi)$ 是 $p$ 次 Legendre 多项式。对于 $p=2$，Legendre 多项式为 $P_2(\\xi) = \\frac{1}{2}(3\\xi^2 - 1)$，其导数为 $P'_2(\\xi) = 3\\xi$。$p=2$ 的 LGL 节点是方程 $(1-\\xi^2)(3\\xi) = 0$ 的根，即 $\\xi_0 = -1$，$\\xi_1 = 0$ 和 $\\xi_2 = 1$。\n\n这些节点的 Lagrange 基多项式 $\\ell_j(\\xi)$ 为：\n$\\ell_0(\\xi) = \\frac{(\\xi - \\xi_1)(\\xi - \\xi_2)}{(\\xi_0 - \\xi_1)(\\xi_0 - \\xi_2)} = \\frac{(\\xi - 0)(\\xi - 1)}{(-1 - 0)(-1 - 1)} = \\frac{\\xi(\\xi-1)}{2} = \\frac{1}{2}(\\xi^2 - \\xi)$。\n$\\ell_1(\\xi) = \\frac{(\\xi - \\xi_0)(\\xi - \\xi_2)}{(\\xi_1 - \\xi_0)(\\xi_1 - \\xi_2)} = \\frac{(\\xi - (-1))(\\xi - 1)}{(0 - (-1))(0 - 1)} = \\frac{(\\xi+1)(\\xi-1)}{-1} = 1 - \\xi^2$。\n$\\ell_2(\\xi) = \\frac{(\\xi - \\xi_0)(\\xi - \\xi_1)}{(\\xi_2 - \\xi_0)(\\xi_2 - \\xi_1)} = \\frac{(\\xi - (-1))(\\xi - 0)}{(1 - (-1))(1 - 0)} = \\frac{\\xi(\\xi+1)}{2} = \\frac{1}{2}(\\xi^2 + \\xi)$。\n\n勒贝格函数定义为 $\\lambda_2(\\xi) = \\sum_{j=0}^{2} |\\ell_j(\\xi)| = |\\frac{1}{2}(\\xi^2 - \\xi)| + |1 - \\xi^2| + |\\frac{1}{2}(\\xi^2 + \\xi)|$。\n勒贝格常数是 $\\Lambda_2 = \\max_{\\xi \\in [-1,1]} \\lambda_2(\\xi)$。\n在区间 $[-1,1]$ 上，项 $1-\\xi^2$ 总是非负的。我们通过划分定义域来分析该函数。\n\n对于 $\\xi \\in [0,1]$：\n$\\xi^2 - \\xi = \\xi(\\xi-1) \\le 0$，所以 $|\\xi^2 - \\xi| = -(\\xi^2 - \\xi) = \\xi - \\xi^2$。\n$\\xi^2 + \\xi = \\xi(\\xi+1) \\ge 0$，所以 $|\\xi^2 + \\xi| = \\xi^2 + \\xi$。\n$\\lambda_2(\\xi) = \\frac{1}{2}(\\xi - \\xi^2) + (1 - \\xi^2) + \\frac{1}{2}(\\xi^2 + \\xi) = \\frac{1}{2}\\xi - \\frac{1}{2}\\xi^2 + 1 - \\xi^2 + \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi = 1 + \\xi - \\xi^2$。\n为了求 $f(\\xi) = 1 + \\xi - \\xi^2$ 在 $[0,1]$ 上的最大值，我们计算其导数：$f'(\\xi) = 1 - 2\\xi$。令 $f'(\\xi) = 0$ 得 $\\xi = 1/2$。此临界点的值为 $f(1/2) = 1 + 1/2 - (1/2)^2 = 3/2 - 1/4 = 5/4$。在端点处，$f(0) = 1$ 和 $f(1) = 1$。在 $[0,1]$ 上的最大值为 $5/4$。\n\n对于 $\\xi \\in [-1,0]$：\n$\\xi^2 - \\xi = \\xi(\\xi-1) \\ge 0$，所以 $|\\xi^2 - \\xi| = \\xi^2 - \\xi$。\n$\\xi^2 + \\xi = \\xi(\\xi+1) \\le 0$，所以 $|\\xi^2 + \\xi| = -(\\xi^2 + \\xi)$。\n$\\lambda_2(\\xi) = \\frac{1}{2}(\\xi^2 - \\xi) + (1 - \\xi^2) - \\frac{1}{2}(\\xi^2 + \\xi) = \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi + 1 - \\xi^2 - \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi = 1 - \\xi - \\xi^2$。\n为了求 $g(\\xi) = 1 - \\xi - \\xi^2$ 在 $[-1,0]$ 上的最大值，我们计算其导数：$g'(\\xi) = -1 - 2\\xi$。令 $g'(\\xi) = 0$ 得 $\\xi = -1/2$。该值为 $g(-1/2) = 1 - (-1/2) - (-1/2)^2 = 1 + 1/2 - 1/4 = 5/4$。在端点处，$g(-1) = 1$ 和 $g(0) = 1$。在 $[-1,0]$ 上的最大值为 $5/4$。\n\n结合两个区间的结果，$\\lambda_2(\\xi)$ 在 $[-1,1]$ 上的最大值为 $\\Lambda_2 = 5/4$。\n\n**第 2 部分：计算插值误差范数 $\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}$**\n\n待插值的函数是雅可比行列式 $J(\\xi) = 1 + 4\\alpha\\xi^3$。算子 $I_2$ 通过在节点 $\\xi_0 = -1$, $\\xi_1 = 0$, $\\xi_2 = 1$ 上插值，将 $J(\\xi)$ 投影到次数最多为 2 的多项式空间上。\n$J(\\xi)$ 在这些节点上的值为：\n$J(-1) = 1 + 4\\alpha(-1)^3 = 1 - 4\\alpha$。\n$J(0) = 1 + 4\\alpha(0)^3 = 1$。\n$J(1) = 1 + 4\\alpha(1)^3 = 1 + 4\\alpha$。\n\n插值多项式 $I_2J(\\xi)$ 可用 Lagrange 基构造：\n$I_2J(\\xi) = J(-1)\\ell_0(\\xi) + J(0)\\ell_1(\\xi) + J(1)\\ell_2(\\xi)$\n$I_2J(\\xi) = (1 - 4\\alpha)\\frac{\\xi^2 - \\xi}{2} + (1)(1 - \\xi^2) + (1 + 4\\alpha)\\frac{\\xi^2 + \\xi}{2}$\n$I_2J(\\xi) = \\frac{1}{2}(\\xi^2 - \\xi - 4\\alpha\\xi^2 + 4\\alpha\\xi) + 1 - \\xi^2 + \\frac{1}{2}(\\xi^2 + \\xi + 4\\alpha\\xi^2 + 4\\alpha\\xi)$\n$I_2J(\\xi) = (\\frac{1}{2} - 1 + \\frac{1}{2})\\xi^2 + (-\\frac{1}{2} + \\frac{1}{2})\\xi + (\\frac{-4\\alpha}{2} + \\frac{4\\alpha}{2})\\xi^2 + (\\frac{4\\alpha}{2} + \\frac{4\\alpha}{2})\\xi + 1$\n$I_2J(\\xi) = 0 \\cdot \\xi^2 + 0 \\cdot \\xi + 0 \\cdot \\xi^2 + 4\\alpha\\xi + 1 = 1 + 4\\alpha\\xi$。\n\n插值误差为 $E(\\xi) = J(\\xi) - I_2J(\\xi) = (1 + 4\\alpha\\xi^3) - (1 + 4\\alpha\\xi) = 4\\alpha(\\xi^3 - \\xi)$。\n我们必须求此误差在 $[-1,1]$ 上的 $L^{\\infty}$ 范数：\n$\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])} = \\max_{\\xi \\in [-1,1]} |4\\alpha(\\xi^3 - \\xi)| = |4\\alpha| \\max_{\\xi \\in [-1,1]} |\\xi^3 - \\xi|$。\n\n令 $h(\\xi) = \\xi^3 - \\xi$。为了求其在 $[-1,1]$ 上的最大绝对值，我们求其临界点：$h'(\\xi) = 3\\xi^2 - 1$。令 $h'(\\xi)=0$ 得到 $\\xi^2 = 1/3$，因此 $\\xi = \\pm 1/\\sqrt{3}$。\n我们计算 $|h(\\xi)|$ 在这些点以及端点 $\\pm 1$ 处的值：\n$|h(1)| = |1^3 - 1| = 0$。\n$|h(-1)| = |(-1)^3 - (-1)| = 0$。\n$|h(1/\\sqrt{3})| = |(1/\\sqrt{3})^3 - 1/\\sqrt{3}| = |\\frac{1}{3\\sqrt{3}} - \\frac{1}{\\sqrt{3}}| = |\\frac{1-3}{3\\sqrt{3}}| = \\frac{2}{3\\sqrt{3}}$。\n$|h(-1/\\sqrt{3})| = |(-1/\\sqrt{3})^3 - (-1/\\sqrt{3})| = |-\\frac{1}{3\\sqrt{3}} + \\frac{1}{\\sqrt{3}}| = |\\frac{-1+3}{3\\sqrt{3}}| = \\frac{2}{3\\sqrt{3}}$。\n$|\\xi^3 - \\xi|$ 在 $[-1,1]$ 上的最大值为 $2/(3\\sqrt{3})$。\n\n因此，几何混叠界为：\n$E_{\\mathrm{geo}} = \\|J - I_2J\\|_{L^{\\infty}([-1,1])} = |4\\alpha| \\frac{2}{3\\sqrt{3}} = \\frac{8|\\alpha|}{3\\sqrt{3}}$。\n\n**第 3 部分：$C(\\alpha)$ 的最终计算**\n\n现在我们结合第 1 部分和第 2 部分的结果：\n$C(\\alpha) = \\Lambda_2 \\cdot E_{\\mathrm{geo}} = \\frac{5}{4} \\cdot \\frac{8|\\alpha|}{3\\sqrt{3}} = \\frac{40|\\alpha|}{12\\sqrt{3}} = \\frac{10|\\alpha|}{3\\sqrt{3}}$。\n为了使分母有理化，我们将分子和分母同乘以 $\\sqrt{3}$：\n$C(\\alpha) = \\frac{10|\\alpha|}{3\\sqrt{3}} \\cdot \\frac{\\sqrt{3}}{\\sqrt{3}} = \\frac{10\\sqrt{3}|\\alpha|}{9}$。\n\n这就是 $C(\\alpha)$ 的最终闭式表达式。约束条件 $|\\alpha|  1/4$ 确保了映射是良定义的，但不会改变此表达式的形式。", "answer": "$$\n\\boxed{\\frac{10\\sqrt{3}}{9}|\\alpha|}\n$$", "id": "3392355"}, {"introduction": "在完成具体的计算之后，我们将转向一个更普适的分析性问题。这个练习展示了勒贝格常数在一个常见的数值场景中的关键作用：分析输入数据（如计算出的谱系数）中的扰动如何传播并影响最终解的误差。通过推导一个综合的误差上界，您将深刻理解勒贝格常数为何是衡量数值稳定性的一个核心指标。", "problem": "考虑一个实值函数 $f:[-1,1]\\to\\mathbb{R}$ 及其在 Legendre 多项式基 $\\{P_k(x)\\}_{k=0}^{p}$ 中的 $p$ 阶模态表示，其中计算出的模态系数 $\\tilde{c}_k$ 是理想系数 $c_k$ 的扰动，使得 $\\tilde{c}_k=c_k+\\delta c_k$。设 $\\{\\xi_j\\}_{j=0}^{p}$ 表示 $[-1,1]$ 上的 Legendre–Gauss–Lobatto (LGL) 节点，并设 $\\{\\ell_j(x)\\}_{j=0}^{p}$ 表示相关的 Lagrange 基多项式。将 LGL 插值的 Lebesgue 常数 $\\Lambda_p$ 定义为 $\\Lambda_p:=\\sup_{x\\in[-1,1]}\\sum_{j=0}^{p}|\\ell_j(x)|$，它是从节点数据（在一致范数下）到插值多项式（在一致范数下）的 $p$ 阶插值映射的算子范数。假设通过在 LGL 节点上计算扰动多项式 $\\tilde{p}(x):=\\sum_{k=0}^{p}\\tilde{c}_k P_k(x)$ 以获得 $\\tilde{y}_j:=\\tilde{p}(\\xi_j)$ 来执行模态到节点的转换，并且使用节点向量 $(\\tilde{y}_j)_{j=0}^{p}$ 通过重心 Lagrange 公式执行逐点求值。设 $E_p(f):=\\inf_{q\\in\\mathbb{P}_p}\\|f-q\\|_{\\infty}$ 表示用次数至多为 $p$ 的多项式对 $f$ 进行一致最佳逼近的误差。\n\n从第一性原理和上述定义出发，为通过由扰动模态系数构建的重心插值多项式计算 $f(\\xi_i)$ 的相对前向误差推导一个解析上界，即量\n$$\n\\mathcal{R}_i:=\\frac{|I_p[\\tilde{y}](\\xi_i)-f(\\xi_i)|}{|f(\\xi_i)|},\n$$\n其中 $I_p[\\tilde{y}]$ 是通过 $(\\xi_j,\\tilde{y}_j)$ 的 $p$ 阶 Lagrange 插值多项式，该上界需用 $\\Lambda_p$、系数扰动 $(\\delta c_k)_{k=0}^{p}$ 和 $E_p(f)$ 显式表示。你的界必须对每个节点索引 $i\\in\\{0,1,\\dots,p\\}$ 均有效，并且除了 Legendre 多项式在 $[-1,1]$ 上的界之外，不得假定任何特殊的代数结构。此外，提出一个考虑稳定性的模态滤波器 $\\sigma_k\\in[0,1]$（以乘法方式应用于模态表示），以减少高阶系数扰动对所推导的界的影响。滤波器的设计应由你推导的界来证明其合理性，并应明确指出 $\\Lambda_p$ 和 $p$ 如何影响 $\\sigma_k$ 的选择。\n\n将你推导的最终界表示为单个闭式解析表达式。不需要进行数值计算，也不需要四舍五入。如果出现角度，应以弧度为单位。最终的界中不要包含任何物理单位。", "solution": "该问题要求为在 Legendre-Gauss-Lobatto (LGL) 节点上计算函数 $f(x)$ 值的相对前向误差提供一个上界，其中求值是使用由扰动模态系数构建的多项式插值进行的。问题还要求设计一个模态滤波器。\n\n### 步骤 1：分析问题\n问题要求我们为在节点 $\\xi_i$ 上的相对误差 $\\mathcal{R}_i$ 推导一个上界。然而，在节点上，插值误差项会消失，这使得问题变得不那么普遍和有趣。一个更标准和有用的问题是推导整个区间上的一致相对误差的上界。推导出的答案形式表明，问题意在寻求一致误差界 $\\|I_p[\\tilde{y}] - f\\|_{\\infty}$，而不是仅仅在节点上的误差。因此，我们将推导这个更普遍的界，它自然也适用于任何特定节点 $\\xi_i$。\n\n### 步骤 2：误差界的推导\n我们需要为绝对误差 $\\|I_p[\\tilde{y}] - f\\|_{\\infty}$ 找到一个界。因为 $I_p[\\tilde{y}](x)$ 和 $\\tilde{p}(x)$ 都是次数为 $p$ 的多项式，且在 $p+1$ 个 LGL 节点上取值相同（即 $\\tilde{y}_j$），由多项式插值的唯一性可知，$I_p[\\tilde{y}](x) \\equiv \\tilde{p}(x)$。因此，我们要界定的是 $\\|\\tilde{p} - f\\|_{\\infty}$。\n\n我们使用三角不等式，并引入真实函数 $f(x)$ 的插值多项式 $I_p[f](x)$ 作为中间量：\n$$\n\\|\\tilde{p} - f\\|_{\\infty} = \\|\\tilde{p}(x) - I_p[f](x) + I_p[f](x) - f(x)\\|_{\\infty} \\le \\|\\tilde{p} - I_p[f]\\|_{\\infty} + \\|I_p[f] - f\\|_{\\infty}\n$$\n右侧的两项分别对应于由系数扰动传播的误差和该方法固有的插值误差。\n\n**1. 界定插值误差 $\\|I_p[f] - f\\|_{\\infty}$**\n这是逼近论中的一个标准结果。多项式插值的一致误差由最佳逼近误差 $E_p(f)$ 和勒贝格常数 $\\Lambda_p$ 界定：\n$$\n\\|I_p[f] - f\\|_{\\infty} \\le (1 + \\Lambda_p) E_p(f)\n$$\n\n**2. 界定传播误差 $\\|\\tilde{p} - I_p[f]\\|_{\\infty}$**\n我们现在来界定 $\\|\\tilde{p} - I_p[f]\\|_{\\infty}$ 这一项。我们使用 $I_p$ 算子的线性和它作为从节点值到多项式的映射的范数定义。\n$$\n\\|\\tilde{p} - I_p[f]\\|_{\\infty} = \\|I_p[\\tilde{y}] - I_p[f]\\|_{\\infty} = \\|I_p[\\tilde{y} - f]\\|_{\\infty}\n$$\n这里的 $\\tilde{y}-f$ 表示一个向量，其元素为 $(\\tilde{y}_j - f(\\xi_j))$。根据勒贝格常数作为算子范数的定义，我们有：\n$$\n\\|I_p[\\tilde{y} - f]\\|_{\\infty} \\le \\Lambda_p \\max_{j=0,\\dots,p} |\\tilde{y}_j - f(\\xi_j)|\n$$\n现在我们必须界定节点上的最大误差 $\\max_j |\\tilde{y}_j - f(\\xi_j)|$。我们假设“理想系数”$c_k$ 是多项式 $I_p[f](x)$ 的系数。在此假设下，在所有节点 $j$ 上，$I_p[f](\\xi_j) = f(\\xi_j)$。\n扰动多项式为 $\\tilde{p}(x) = \\sum_{k=0}^p (c_k + \\delta c_k) P_k(x)$。\n那么，在节点 $\\xi_j$ 上的误差为：\n$$\n|\\tilde{y}_j - f(\\xi_j)| = |\\tilde{p}(\\xi_j) - f(\\xi_j)| = |\\tilde{p}(\\xi_j) - I_p[f](\\xi_j)| = \\left| \\sum_{k=0}^{p} (c_k + \\delta c_k) P_k(\\xi_j) - \\sum_{k=0}^{p} c_k P_k(\\xi_j) \\right| = \\left| \\sum_{k=0}^{p} \\delta c_k P_k(\\xi_j) \\right|\n$$\n使用三角不等式以及 Legendre 多项式的性质 $|P_k(x)| \\le 1$ 对所有 $x \\in [-1,1]$ 成立：\n$$\n|\\tilde{y}_j - f(\\xi_j)| \\le \\sum_{k=0}^{p} |\\delta c_k| |P_k(\\xi_j)| \\le \\sum_{k=0}^{p} |\\delta c_k|\n$$\n这个界对所有节点 $j$ 都是一致的。因此，$\\max_j |\\tilde{y}_j - f(\\xi_j)| \\le \\sum_{k=0}^{p} |\\delta c_k|$。\n将此代入传播误差的界中：\n$$\n\\|\\tilde{p} - I_p[f]\\|_{\\infty} \\le \\Lambda_p \\left( \\sum_{k=0}^{p} |\\delta c_k| \\right)\n$$\n\n**3. 合并界**\n结合两个误差分量的界，我们得到一致绝对误差的界：\n$$\n\\|\\tilde{p} - f\\|_{\\infty} \\le \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f)\n$$\n由于 $|I_p[\\tilde{y}](\\xi_i)-f(\\xi_i)| \\le \\|\\tilde{p} - f\\|_{\\infty}$，这可作为任意节点 $\\xi_i$ 上绝对误差的一个上界。因此，相对误差 $\\mathcal{R}_i$ 的界为：\n$$\n\\mathcal{R}_i = \\frac{|I_p[\\tilde{y}](\\xi_i) - f(\\xi_i)|}{|f(\\xi_i)|} \\le \\frac{1}{|f(\\xi_i)|} \\left( \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f) \\right)\n$$\n\n### 步骤 3：考虑稳定性的模态滤波器设计\n推导出的误差界有两个主要组成部分：一个来自系数扰动，即 $\\Lambda_p \\sum |\\delta c_k|$；另一个来自 $\\mathbb{P}_p$ 的基本逼近能力，即 $(1+\\Lambda_p)E_p(f)$。勒贝格常数 $\\Lambda_p$ 充当系数噪声的放大因子。对于许多问题，扰动 $\\delta c_k$ 在高阶模态（较大的 $k$）中更为显著。模态滤波器 $\\sigma_k$ 的目的就是减少这种影响。\n\n我们希望滤波器对于 $|c_k|$ 占主导的低阶 $k$，有 $\\sigma_k \\approx 1$；对于 $|\\delta c_k|$ 可能占主导的高阶 $k$，有 $\\sigma_k \\to 0$。滤波器的衰减强度应该与不稳定性度量 $\\Lambda_p$ 相关联。\n\n一个合适的、由误差界结构证明其合理性的、考虑稳定性的滤波器可以设计为 $k$、$p$ 和 $\\Lambda_p$ 的函数。一个具体的、有充分理由的选择是：\n$$\n\\sigma_k = \\frac{1}{1 + \\alpha \\Lambda_p \\left(\\frac{k}{p}\\right)^{\\gamma}}\n$$\n其中 $\\gamma > 0$ 是一个控制滤波器强度（例如，对于平滑滤波器，$\\gamma=2$）的幂，$\\alpha$ 是一个非负的可调参数。该滤波器具有所需的性质：\n- $\\sigma_0 = 1$（保持均值）。\n- 当 $k \\to p$ 时，$\\sigma_k$ 减小。\n- 对于较大的 $\\Lambda_p$ 值，衰减更迅速。\n- 其行为由多项式次数 $p$ 参数化。\n\n例如，一个典型的选择是指数滤波器或有理滤波器，如 $\\sigma_k = \\exp\\left(-\\alpha \\Lambda_p (k/p)^\\gamma\\right)$ 或上述的有理形式。有理形式更简单，在此作为示例。", "answer": "$$\n\\boxed{\\frac{1}{|f(\\xi_i)|} \\left( \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f) \\right)}\n$$", "id": "3392296"}, {"introduction": "作为连接理论与实践的最后一步，这项计算练习要求您构建一个“智能化”的自适应算法。我们将利用勒贝格函数本身作为一个局部的“不稳定性传感器”，以指导在增加多项式阶数或改善插值节点分布之间的决策。这个练习充分展示了勒贝格常数不仅是理论分析工具，更是在现代数值求解器中驱动计算过程的实用手段。", "problem": "考虑一维参考区间 $[-1,1]$ 及其在物理域中的仿射映像（单元）$K=[a,b]$。对于一个配备了 $N+1$ 个插值节点 $\\{x_i\\}_{i=0}^{N}$ 及相关拉格朗日基函数 $\\{\\ell_i(x)\\}_{i=0}^{N}$ 的单元 $K$，定义局部勒贝格监视函数 $\\mu_K(x)=\\sum_{i=0}^N \\lvert \\ell_i(x)\\rvert$ 和局部勒贝格常数 $\\Lambda_K=\\sup_{x\\in K}\\mu_K(x)$。设 $I_N$ 表示在单元 $K$ 上作用于目标函数 $f$ 的 $N$ 次节点拉格朗日插值算子。在谱元法或间断伽辽金法的背景下，插值算子 $I_N$ 在每个单元上局部作用，而勒贝格常数控制了 $I_N$ 在最大范数下的算子范数。\n\n你将实现以下用于 `hp`-自适应的后验指示器，该指示器融合了局部勒贝格监视函数。对于当前使用 $N$ 次等距节点的单元 $K$：\n- 定义分层余量 $s_K(x)=I_{N+1}^{\\mathrm{eq}}f(x)-I_{N}^{\\mathrm{eq}}f(x)$，即两个连续等距节点插值的差。\n- 定义加权指示器 $\\eta_K=\\sup_{x\\in K}\\mu_K^{\\mathrm{eq},N}(x)\\,\\lvert s_K(x)\\rvert$，其中 $\\mu_K^{\\mathrm{eq},N}$ 是使用当前 $N$ 次等距节点计算的勒贝格监视函数。\n- 定义节点敏感度比 $R_K=\\Lambda_K^{\\mathrm{eq},N}/\\Lambda_K^{\\mathrm{GLL},N}$，其中 $\\Lambda_K^{\\mathrm{eq},N}=\\sup_{x\\in K}\\mu_K^{\\mathrm{eq},N}(x)$ 是等距节点的勒贝格常数，$\\Lambda_K^{\\mathrm{GLL},N}=\\sup_{x\\in K}\\mu_K^{\\mathrm{GLL},N}(x)$ 是相同次数 $N$ 的 Gauss–Lobatto–Legendre 节点的勒贝格常数。\n\n你将采用以下局部自适应决策规则。给定固定阈值 $\\gamma1$ 和 $\\tau0$：\n- 如果 $R_K\\ge \\gamma$ 且 $\\eta_K\\ge \\tau$，则建议进行节点重分布（切换到 Gauss–Lobatto–Legendre 节点），次数 $N$ 保持不变。\n- 否则，如果 $\\eta_K\\ge \\tau$，则建议进行 `p`-加密（将次数从 $N$ 增加到 $N+2$），同时保持等距节点。\n- 否则，建议不作改变。\n\n为了评估勒贝格监视函数预测需要节点重分布区域的能力，为每个当前使用 $N$ 次等距节点的单元定义以下真实情况分类。设 $\\alpha1$ 为一个固定因子。计算最大范数下的实际插值误差：\n- $E_{\\mathrm{GLL},N}(K)=\\| f-I_{N}^{\\mathrm{GLL}}f\\|_{L^\\infty(K)}$,\n- $E_{\\mathrm{eq},N+2}(K)=\\| f-I_{N+2}^{\\mathrm{eq}}f\\|_{L^\\infty(K)}$.\n如果 $E_{\\mathrm{GLL},N}(K)\\le E_{\\mathrm{eq},N+2}(K)/\\alpha$，则将该单元分类为确实需要节点重分布；否则，将其分类为不需要节点重分布（此时 `p`-加密至少同样有效）。\n\n你的程序必须：\n- 实现重心拉格朗日插值以计算任意节点的 $I_N f$，并通过密集采样计算勒贝格监视函数 $\\mu_K(x)$ 和常数 $\\Lambda_K$。\n- 对每个测试用例，当单元使用等距节点时，逐单元应用决策规则，并生成一个建议进行节点重分布的预测单元集合。\n- 使用上述误差比较，为等距节点单元逐单元计算真实情况分类。\n- 每个测试用例返回一个布尔值，表示该用例中所有单元的节点重分布预测建议是否与真实情况分类相匹配。对于已经使用 Gauss–Lobatto–Legendre 节点的单元，预测必须是“无重分布”，并且这些单元不参与真实情况的比较。\n\n采用以下测试套件，阈值为 $\\gamma=1.6$，$\\tau=10^{-4}$，$\\alpha=1.2$。所有范数和求值都在每个单元上的 $4001$ 个等距采样点上计算：\n1. 单单元“Runge”情况：\n   - 域：$[-1,1]$,\n   - 单元：一个单元 $K_1=[-1,1]$，使用等距节点，次数 $N=12$,\n   - 函数：$f(x)=\\dfrac{1}{1+25x^2}$。\n2. 双单元端点层情况：\n   - 域：$[-1,1]$,\n   - 单元：$K_1=[-1,-0.2]$ 和 $K_2=[-0.2,1]$，均使用等距节点，次数 $N=10$,\n   - 函数：$f(x)=\\sqrt{x+1.000001}$。\n3. 单单元已为 Gauss–Lobatto–Legendre 节点情况：\n   - 域：$[-1,1]$,\n   - 单元：一个单元 $K_1=[-1,1]$，使用 Gauss–Lobatto–Legendre 节点，次数 $N=10$,\n   - 函数：$f(x)=\\cos(20x)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果是一个布尔值，对应于上述每个测试用例的成功条件。不涉及物理单位或角度。", "solution": "该问题要求在谱元法和间断伽辽金方法的背景下，实现并评估一个用于 `hp`-自适应的后验指示器。该指示器旨在逐单元地决定是采用 `p`-加密（增加多项式次数）还是节点重分布（从等距节点切换到 Gauss-Lobatto-Legendre 节点）。然后将此决策与基于插值误差实际减少量的真实情况分类进行比较。\n\n该解决方案需要实现数值逼近理论中的几个核心概念，下面将逐步详述。\n\n**1. 基础概念和数值工具**\n\n谱元法和间断伽辽金方法的核心是在单个单元上的多项式插值。这种插值的质量对整体数值解的准确性至关重要。\n\n**1.1. 节点集**\n在单元 $K=[a,b]$ 上选择插值节点 $\\{x_i\\}_{i=0}^N$ 会深刻影响插值的稳定性和准确性。该问题考虑了两种类型的节点。\n\n- **等距节点**：这是最直观的选择，在单元 $[a,b]$ 上定义为：\n$x_j = a + j \\frac{b-a}{N}, \\quad j = 0, 1, \\dots, N$\n尽管简单，但众所周知，对于高多项式次数 $N$，它们会导致边界附近出现灾难性的大误差和振荡，这一现象以 Runge 的名字命名。\n\n- **Gauss-Lobatto-Legendre (GLL) 节点**：这些节点源于正交多项式理论，旨在最小化插值误差。在参考区间 $\\hat{K}=[-1,1]$ 上，$N+1$ 个 GLL 节点 $\\{\\hat{x}_j\\}_{j=0}^N$ 是多项式 $(1-\\xi^2)P'_N(\\xi)$ 的根，其中 $P_N(\\xi)$ 是 $N$ 次勒让德多项式。这些节点包含端点 $\\pm 1$ 并向端点聚拢，这缓解了 Runge 现象。然后通过仿射变换将这些参考节点映射到物理单元 $K=[a,b]$ 上：\n$x_j = \\frac{a+b}{2} + \\frac{b-a}{2}\\hat{x}_j$\n\n**1.2. 重心拉格朗日插值**\n给定一组 $N+1$ 个节点 $\\{x_j\\}$ 和相应的函数值 $\\{y_j=f(x_j)\\}$，可以使用重心公式高效且稳定地计算拉格朗日插值多项式 $I_N f(x)$：\n$$I_N f(x) = \\frac{\\sum_{j=0}^{N} \\frac{w_j}{x-x_j} y_j}{\\sum_{j=0}^{N} \\frac{w_j}{x-x_j}}$$\n其中，对于给定的节点集，重心权 $w_j$ 是预先计算好的：\n$$w_j = \\frac{1}{\\prod_{k=0, k \\neq j}^{N} (x_j - x_k)}$$\n此公式对任何非节点的 $x$ 均有效。如果 $x=x_k$ 是某个节点，则插值就是 $y_k$。\n\n**1.3. 勒贝格监视函数和常数**\n插值过程的稳定性由勒贝格常数 $\\Lambda_K$ 来量化。它是插值算子 $I_N$ 在最大范数下的算子范数，映射为 $C(K) \\to C(K)$。它通过勒贝格函数（或监视函数）$\\mu_K(x)$ 定义：\n$$\\mu_K(x) = \\sum_{i=0}^{N} |\\ell_i(x)|$$\n其中 $\\{\\ell_i(x)\\}$ 是拉格朗日基多项式。勒贝格常数是该函数在单元上的最大值：\n$$\\Lambda_K = \\sup_{x \\in K} \\mu_K(x)$$\n较小的勒贝格常数确保插值 $I_N f$ 不会比 $f$ 的最佳多项式逼近大很多。插值误差的界为：\n$$\\|f - I_N f\\|_{L^\\infty(K)} \\le (1 + \\Lambda_K) \\inf_{p \\in \\mathcal{P}_N} \\|f - p\\|_{L^\\infty(K)}$$\n其中 $\\mathcal{P}_N$ 是次数至多为 $N$ 的多项式空间。对于等距节点，$\\Lambda_K^{\\mathrm{eq},N}$ 随 $N$ 指数增长（$\\sim 2^N/(N\\log N)$），而对于 GLL 节点，$\\Lambda_K^{\\mathrm{GLL},N}$ 仅对数增长（$\\sim \\log N$）。\n\n勒贝格监视函数 $\\mu_K(x)$ 可以使用重心权来计算。单个拉格朗日基函数 $\\ell_j(x)$ 可表示为：\n$$\\ell_j(x) = \\frac{\\frac{w_j}{x-x_j}}{\\sum_{k=0}^{N} \\frac{w_k}{x-x_k}}$$\n对 $j=0, \\dots, N$ 的这些表达式的绝对值求和，即可得到 $\\mu_K(x)$。\n\n**2. 后验自适应指示器**\n该问题定义了一套规则，用以判断一个使用等距节点的单元 $K$ 是从节点重分布中获益更多，还是从 `p`-加密中获益更多。该决策基于三个量。\n\n- **分层余量 $s_K(x)$**：这个量，$s_K(x) = I_{N+1}^{\\mathrm{eq}}f(x) - I_{N}^{\\mathrm{eq}}f(x)$，近似了当前插值 $I_{N}^{\\mathrm{eq}}f(x)$ 的误差。它使用一个层次结构中两个连续插值的差作为真实误差的代理，这是后验误差估计中的一种常用技术。\n\n- **节点敏感度比 $R_K$**：定义为 $R_K = \\Lambda_K^{\\mathrm{eq},N} / \\Lambda_K^{\\mathrm{GLL},N}$，该比率直接衡量了切换到 GLL 节点可能带来的稳定性改进。较大的 $R_K$ 值表明，与 GLL 节点相比，当前的等距节点是病态的。\n\n- **加权指示器 $\\eta_K$**：定义为 $\\eta_K = \\sup_{x \\in K} \\mu_K^{\\mathrm{eq},N}(x) |s_K(x)|$。它将估计误差（通过 $s_K$）与插值的局部不稳定性（通过 $\\mu_K^{\\mathrm{eq},N}$）相结合，提供了一种对“放大”误差的度量。\n\n**3. 决策规则和真实情况分类**\n决策过程如下，给定阈值 $\\gamma  1$ 和 $\\tau  0$：\n\n- **预测**：\n  1. 如果 $R_K \\ge \\gamma$ 且 $\\eta_K \\ge \\tau$：预测**节点重分布**是最佳策略。大的敏感度比 $R_K$ 表明切换节点有很高的潜在增益，而大的指示器 $\\eta_K$ 表明某种形式的自适应是必要的。\n  2. 否则，如果 $\\eta_K \\ge \\tau$：预测进行 `p`-加密（将次数增加到 $N+2$）。\n  3. 否则：预测不作改变。\n\n- **真实情况**：为了验证预测，我们比较两种相互竞争策略的实际误差。对于因子 $\\alpha  1$：\n  1. 计算`节点重分布`的误差：$E_{\\mathrm{GLL},N}(K) = \\|f - I_{N}^{\\mathrm{GLL}}f\\|_{L^\\infty(K)}$。\n  2. 计算`p`-加密的误差：$E_{\\mathrm{eq},N+2}(K) = \\|f - I_{N+2}^{\\mathrm{eq}}f\\|_{L^\\infty(K)}$。\n  3. 如果误差减少足够显著，即 $E_{\\mathrm{GLL},N}(K) \\le E_{\\mathrm{eq},N+2}(K) / \\alpha$，则将单元分类为确实需要**节点重分布**。否则，则不需要。\n\n最终任务是为每个测试用例验证，对于所有初始使用等距节点的单元，指示器对“节点重分布”的预测是否与真实情况分类相匹配。已使用 GLL 节点的单元被预测为需要“无重分布”，并且不参与真实情况的比较。\n\n**4. 实现策略**\n该解决方案的实现首先以矢量化方式构建所需的数值工具以提高效率。核心函数包括：\n- `get_equidistant_nodes` 和 `get_gll_nodes` 用于生成节点集。GLL 节点通过使用 `scipy.special.legendre` 来获取多项式及其导数的根来找到。\n- `barycentric_weights` 用于为给定节点集预先计算权重。\n- `barycentric_interpolate` 和 `lebesgue_monitor` 用于在每个单元上的密集点网格上评估插值和勒贝格监视函数。\n一个主分析函数根据每个单元的初始节点类型对其进行处理。对于等距单元，它计算指示器 $R_K$ 和 $\\eta_K$ 来进行预测，计算真实情况误差 $E_{\\mathrm{GLL},N}$ 和 $E_{\\mathrm{eq},N+2}$ 以进行分类，并比较两者。对于 GLL 单元，根据问题陈述，逻辑是简单的。一个测试用例中每个单元的结果被汇总，为该用例生成最终的布尔成功标志。所有的上确界（对于 $\\Lambda_K$、$\\eta_K$ 和 $L^\\infty$ 误差）都是通过在单元上的 $4001$ 个等距点上取最大值来近似的。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\n# Define global constants from the problem description\nGAMMA = 1.6\nTAU = 1e-4\nALPHA = 1.2\nNUM_SAMPLES = 4001\n\ndef get_equidistant_nodes(N, a, b):\n    \"\"\"Generates N+1 equidistant nodes on the interval [a, b].\"\"\"\n    return np.linspace(a, b, N + 1)\n\ndef get_gll_nodes(N, a, b):\n    \"\"\"Generates N+1 Gauss-Lobatto-Legendre nodes on the interval [a, b].\"\"\"\n    if N == 0:\n        return np.array([(a+b)/2.0])\n    if N == 1:\n        return np.array([a, b])\n    \n    # Roots of the derivative of the N-th Legendre polynomial for interior nodes\n    p_N = legendre(N)\n    p_N_deriv = p_N.deriv(1)\n    interior_nodes_ref = p_N_deriv.roots\n    \n    # GLL nodes on the reference interval [-1, 1] include the endpoints\n    nodes_ref = np.concatenate(([-1.0], interior_nodes_ref, [1.0]))\n    nodes_ref.sort()\n    \n    # Affine mapping from [-1, 1] to [a, b]\n    return (b - a) / 2.0 * nodes_ref + (a + b) / 2.0\n\ndef barycentric_weights(nodes):\n    \"\"\"Computes barycentric weights for a given set of nodes.\"\"\"\n    N = len(nodes) - 1\n    weights = np.ones(N + 1)\n    for j in range(N + 1):\n        # Product over k != j of (xj - xk)\n        prod = np.prod([nodes[j] - nodes[k] for k in range(N + 1) if k != j])\n        weights[j] = 1.0 / prod\n    return weights\n\ndef barycentric_interpolate(nodes, f_values, weights, x_eval):\n    \"\"\"Evaluates the Lagrange interpolant using the barycentric formula.\"\"\"\n    y_interp = np.zeros_like(x_eval, dtype=float)\n    x_eval_b = x_eval[:, np.newaxis]\n    nodes_b = nodes[np.newaxis, :]\n    \n    # Find points in x_eval that are numerically close to a node\n    close_matrix = np.isclose(x_eval_b, nodes_b)\n    is_node_mask = np.any(close_matrix, axis=1)\n    \n    # Handle points that are not nodes via vectorized barycentric formula\n    if not np.all(is_node_mask):\n        non_node_x = x_eval[~is_node_mask]\n        diffs = non_node_x[:, np.newaxis] - nodes_b\n        terms = weights[np.newaxis, :] / diffs\n        numerator = np.sum(terms * f_values[np.newaxis, :], axis=1)\n        denominator = np.sum(terms, axis=1)\n        y_interp[~is_node_mask] = numerator / denominator\n\n    # Handle points that are nodes\n    if np.any(is_node_mask):\n        row_indices, col_indices = np.where(close_matrix)\n        y_interp[row_indices] = f_values[col_indices]\n\n    return y_interp\n\ndef lebesgue_monitor(nodes, weights, x_eval):\n    \"\"\"Computes the Lebesgue monitor function mu(x) = sum(|l_i(x)|).\"\"\"\n    mu_vals = np.zeros_like(x_eval, dtype=float)\n    x_eval_b = x_eval[:, np.newaxis]\n    nodes_b = nodes[np.newaxis, :]\n\n    close_matrix = np.isclose(x_eval_b, nodes_b)\n    is_node_mask = np.any(close_matrix, axis=1)\n\n    # Handle non-node points\n    if not np.all(is_node_mask):\n        non_node_x = x_eval[~is_node_mask]\n        diffs = non_node_x[:, np.newaxis] - nodes_b\n        terms = weights[np.newaxis, :] / diffs\n        denominator = np.sum(terms, axis=1, keepdims=True)\n        # individual li_vals for each non-node x\n        li_vals = terms / denominator\n        mu_vals[~is_node_mask] = np.sum(np.abs(li_vals), axis=1)\n\n    # At nodes, the Lebesgue function value is 1\n    mu_vals[is_node_mask] = 1.0\n    \n    return mu_vals\n\ndef analyze_element(element_params, f):\n    \"\"\"Analyzes a single element according to the problem rules.\"\"\"\n    a, b, N, node_type = element_params\n    \n    if node_type == 'GLL':\n        # Per problem, prediction is \"no redistribution\" and these are excluded\n        # from ground-truth comparison. This element passes by definition.\n        return True\n\n    x_eval = np.linspace(a, b, NUM_SAMPLES)\n    f_eval = f(x_eval)\n\n    # --- 1. Calculate indicators and make prediction ---\n    # Current setup (eq, N)\n    nodes_eq_N = get_equidistant_nodes(N, a, b)\n    weights_eq_N = barycentric_weights(nodes_eq_N)\n    \n    # Calculate mu_K^{eq, N}(x) and Lambda_K^{eq, N}\n    mu_K_eq_N_vals = lebesgue_monitor(nodes_eq_N, weights_eq_N, x_eval)\n    Lambda_K_eq_N = np.max(mu_K_eq_N_vals)\n\n    # Calculate s_K(x) = I_{N+1}^{eq}f - I_{N}^{eq}f\n    f_eq_N = f(nodes_eq_N)\n    I_N_eq_f = barycentric_interpolate(nodes_eq_N, f_eq_N, weights_eq_N, x_eval)\n    \n    nodes_eq_N_plus_1 = get_equidistant_nodes(N + 1, a, b)\n    weights_eq_N_plus_1 = barycentric_weights(nodes_eq_N_plus_1)\n    f_eq_N_plus_1 = f(nodes_eq_N_plus_1)\n    I_N_plus_1_eq_f = barycentric_interpolate(nodes_eq_N_plus_1, f_eq_N_plus_1, weights_eq_N_plus_1, x_eval)\n    s_K_vals = I_N_plus_1_eq_f - I_N_eq_f\n\n    # Calculate eta_K\n    eta_K = np.max(mu_K_eq_N_vals * np.abs(s_K_vals))\n\n    # Calculate R_K = Lambda_K^{eq,N} / Lambda_K^{GLL,N}\n    nodes_gll_N = get_gll_nodes(N, a, b)\n    weights_gll_N = barycentric_weights(nodes_gll_N)\n    mu_K_gll_N_vals = lebesgue_monitor(nodes_gll_N, weights_gll_N, x_eval)\n    Lambda_K_gll_N = np.max(mu_K_gll_N_vals)\n    R_K = Lambda_K_eq_N / Lambda_K_gll_N\n\n    # Apply decision rule\n    prediction_needs_redistribution = (R_K = GAMMA and eta_K = TAU)\n\n    # --- 2. Calculate ground truth classification ---\n    # E_GLL,N\n    f_gll_N = f(nodes_gll_N)\n    I_N_gll_f = barycentric_interpolate(nodes_gll_N, f_gll_N, weights_gll_N, x_eval)\n    E_GLL_N = np.max(np.abs(f_eval - I_N_gll_f))\n\n    # E_eq,N+2\n    nodes_eq_N_plus_2 = get_equidistant_nodes(N + 2, a, b)\n    weights_eq_N_plus_2 = barycentric_weights(nodes_eq_N_plus_2)\n    f_eq_N_plus_2 = f(nodes_eq_N_plus_2)\n    I_N_plus_2_eq_f = barycentric_interpolate(nodes_eq_N_plus_2, f_eq_N_plus_2, weights_eq_N_plus_2, x_eval)\n    E_eq_N_plus_2 = np.max(np.abs(f_eval - I_N_plus_2_eq_f))\n\n    # Ground truth classification\n    truth_needs_redistribution = (E_GLL_N = E_eq_N_plus_2 / ALPHA)\n    \n    # --- 3. Compare prediction and truth ---\n    return prediction_needs_redistribution == truth_needs_redistribution\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    test_cases = [\n        {\n            \"name\": \"Runge\",\n            \"function\": lambda x: 1.0 / (1.0 + 25.0 * x**2),\n            \"elements\": [\n                # K_1: [a, b], N, node_type\n                [-1.0, 1.0, 12, 'equidistant'],\n            ],\n        },\n        {\n            \"name\": \"Endpoint layer\",\n            \"function\": lambda x: np.sqrt(x + 1.000001),\n            \"elements\": [\n                [-1.0, -0.2, 10, 'equidistant'],\n                [-0.2, 1.0, 10, 'equidistant'],\n            ],\n        },\n        {\n            \"name\": \"Already GLL\",\n            \"function\": lambda x: np.cos(20.0 * x),\n            \"elements\": [\n                [-1.0, 1.0, 10, 'GLL'],\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_match_success = True\n        for elem_params in case[\"elements\"]:\n            element_match = analyze_element(elem_params, case[\"function\"])\n            if not element_match:\n                case_match_success = False\n                break\n        results.append(case_match_success)\n\n    # Format the final output string as requested\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3392318"}]}