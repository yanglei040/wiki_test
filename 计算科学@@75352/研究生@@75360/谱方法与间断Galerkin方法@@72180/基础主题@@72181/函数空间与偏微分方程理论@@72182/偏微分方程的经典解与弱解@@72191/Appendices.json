{"hands_on_practices": [{"introduction": "偏微分方程的经典解要求函数具有足够的连续性和可微性，但在许多物理和工程问题中，由于材料属性的突变或源项的奇异性，这一要求无法被满足。本练习通过一个看似简单的一维椭圆边值问题，引导你构建一个在系数不连续情况下的解。你将亲手推导，为何经典解在此失效，以及如何通过弱形式的定义，找到一个在索伯列夫空间 $H_0^1$ 中存在且唯一的弱解，从而深刻理解弱解概念的必要性与精髓。", "problem": "设 $\\Omega=(0,1)$，考虑一个函数 $u:\\Omega\\to\\mathbb{R}$ 的标量二阶椭圆边值问题，\n$$\n-(a(x)\\,u'(x))'=f(x)\\quad\\text{in }\\Omega,\\qquad u(0)=0,\\quad u(1)=0,\n$$\n其系数为 $a:\\Omega\\to\\mathbb{R}$，右端项为 $f:\\Omega\\to\\mathbb{R}$。从Sobolev空间 $H_0^1(0,1)$ 中的弱解、分布导数以及通过分部积分推导出的标准变分形式的定义出发。取\n$$\na(x)=\\begin{cases} 1,  x\\in(0,\\frac{1}{2}) \\\\ 2,  x\\in(\\frac{1}{2},1) \\end{cases}\n\\qquad f(x)\\equiv 1,\n$$\n因此 $a\\in L^{\\infty}(0,1)$ 且 $f\\in L^2(0,1)$。仅使用这些基本原理，推导弱形式，并通过在子区间上求解并强制施加由弱形式所隐含且与间断Galerkin (DG) 方法中处理内部界面的方式一致的界面条件，来显式构造唯一的弱解 $u\\in H_0^1(0,1)$。证明所得的 $u$ 在 $(0,1)$ 上不是二次连续可微的。\n\n当 $u'$ 在 $x=\\tfrac{1}{2}$ 处有跳跃时，将内部界面 $x=\\tfrac{1}{2}$ 处的经典可微性缺陷定义为分布二阶导数 $u''$ 中狄拉克测度 $\\delta_{1/2}$ 的系数。将此缺陷精确计算为一个有理数。不需要四舍五入，也不涉及单位。", "solution": "我们通过几个步骤来构造弱解并计算所需的量。\n\n**1. 推导弱形式**\n\n首先，我们将强形式方程乘以一个检验函数 $v \\in H_0^1(0,1)$，并在定义域 $\\Omega=(0,1)$ 上积分：\n$$ -\\int_0^1 (a(x)u'(x))' v(x) \\,dx = \\int_0^1 f(x)v(x) \\,dx $$\n对左侧进行分部积分，我们得到：\n$$ \\int_0^1 a(x)u'(x)v'(x) \\,dx - [a(x)u'(x)v(x)]_0^1 = \\int_0^1 f(x)v(x) \\,dx $$\n由于检验函数 $v$ 属于 $H_0^1(0,1)$，它满足 $v(0)=v(1)=0$。因此，边界项 $[a(x)u'(x)v(x)]_0^1$ 为零。\n弱形式即为：寻找 $u \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$，都有\n$$ \\int_0^1 a(x)u'(x)v'(x) \\,dx = \\int_0^1 f(x)v(x) \\,dx $$\n这个形式隐含了两个界面条件：(1) 解 $u$ 在整个定义域上是连续的（这是 $H^1$ 空间的要求）；(2) 通量 $a(x)u'(x)$ 在界面上是连续的。\n\n**2. 在子区间上求解**\n\n由于系数 $a(x)$ 是分段常数，我们在两个子区间上分别求解常微分方程：\n- 在 $x \\in (0, 1/2)$ 上，方程为 $-(1 \\cdot u_1')' = 1$，即 $u_1''(x) = -1$。\n- 在 $x \\in (1/2, 1)$ 上，方程为 $-(2 \\cdot u_2')' = 1$，即 $u_2''(x) = -1/2$。\n\n对以上方程积分两次，得到解的一般形式：\n- $u_1'(x) = -x + C_1 \\implies u_1(x) = -\\frac{x^2}{2} + C_1x + C_2$\n- $u_2'(x) = -\\frac{x}{2} + C_3 \\implies u_2(x) = -\\frac{x^2}{4} + C_3x + C_4$\n\n**3. 应用边界条件和界面条件**\n\n我们使用四个条件来确定四个待定常数 $C_1, C_2, C_3, C_4$：\n- **边界条件**:\n  1.  $u(0)=0 \\implies u_1(0) = C_2 = 0$\n  2.  $u(1)=0 \\implies u_2(1) = -1/4 + C_3 + C_4 = 0$\n- **界面条件** (在 $x=1/2$ 处):\n  3.  **解的连续性** $u_1(1/2) = u_2(1/2)$:\n      $$ -\\frac{(1/2)^2}{2} + C_1(1/2) = -\\frac{(1/2)^2}{4} + C_3(1/2) + C_4 \\implies -\\frac{1}{8} + \\frac{C_1}{2} = -\\frac{1}{16} + \\frac{C_3}{2} + C_4 $$\n  4.  **通量的连续性** $a(1/2^-)u_1'(1/2) = a(1/2^+)u_2'(1/2)$:\n      $$ 1 \\cdot (-1/2 + C_1) = 2 \\cdot (-1/4 + C_3) \\implies -1/2 + C_1 = -1/2 + 2C_3 \\implies C_1 = 2C_3 $$\n\n**4. 求解常数**\n\n将 $C_1 = 2C_3$ 代入条件3，并将 $C_4 = 1/4 - C_3$ (来自条件2) 代入，得到：\n$$ -\\frac{1}{8} + \\frac{2C_3}{2} = -\\frac{1}{16} + \\frac{C_3}{2} + \\left(\\frac{1}{4} - C_3\\right) $$\n$$ -\\frac{1}{8} + C_3 = -\\frac{1}{16} + \\frac{1}{4} - \\frac{C_3}{2} $$\n将方程两边乘以 16:\n$$ -2 + 16C_3 = -1 + 4 - 8C_3 \\implies -2 + 16C_3 = 3 - 8C_3 $$\n$$ 24C_3 = 5 \\implies C_3 = \\frac{5}{24} $$\n由此可得其他常数：\n- $C_1 = 2C_3 = 2 \\cdot \\frac{5}{24} = \\frac{5}{12}$\n- $C_4 = \\frac{1}{4} - C_3 = \\frac{6}{24} - \\frac{5}{24} = \\frac{1}{24}$\n- $C_2 = 0$\n\n所以，弱解为：\n$$ u(x) = \\begin{cases} -\\frac{1}{2}x^2 + \\frac{5}{12}x,  x\\in[0, \\frac{1}{2}] \\\\ -\\frac{1}{4}x^2 + \\frac{5}{24}x + \\frac{1}{24},  x\\in(\\frac{1}{2}, 1] \\end{cases} $$\n\n**5. 证明非二次连续可微性**\n\n解的二阶导数在两个子区间内分别为：\n- $u_1''(x) = -1$\n- $u_2''(x) = -1/2$\n由于 $u_1''(1/2) = -1 \\neq -1/2 = u_2''(1/2)$，二阶导数在 $x=1/2$ 处不连续。因此，解 $u$ 在 $(0,1)$ 上不是二次连续可微的（即 $u \\notin C^2(0,1)$）。\n\n**6. 计算分布导数中的狄拉克测度系数**\n\n在分布意义下，函数 $u'(x)$ 的导数 $u''(x)$ 包含一个狄拉克 $\\delta$ 函数项，其系数等于 $u'(x)$ 在间断点处的跳跃值 $[u']_{x=1/2} = u_2'(1/2) - u_1'(1/2)$。\n- $u_1'(x) = -x + \\frac{5}{12} \\implies u_1'(1/2) = -1/2 + 5/12 = -1/12$\n- $u_2'(x) = -x/2 + \\frac{5}{24} \\implies u_2'(1/2) = -1/4 + 5/24 = -1/24$\n\n跳跃值为：\n$$ [u']_{1/2} = u_2'(1/2) - u_1'(1/2) = \\left(-\\frac{1}{24}\\right) - \\left(-\\frac{1}{12}\\right) = -\\frac{1}{24} + \\frac{2}{24} = \\frac{1}{24} $$\n因此，$u''$ 中 $\\delta_{1/2}$ 的系数是 $\\frac{1}{24}$。", "answer": "$$\n\\boxed{\\frac{1}{24}}\n$$", "id": "3370443"}, {"introduction": "对于双曲守恒律，即使初始条件是光滑的，其解也可能在有限时间内发展出激波等不连续性。此时，弱解不仅是必要的，而且可能不唯一，需要额外的熵条件来筛选出物理上有意义的解。本练习探讨了在间断伽辽金（DG）方法中，如何通过引入基于残差的人工粘性来保证数值解收敛到正确的熵解。这不仅是一个计算任务，更是一次深入理解“消失粘性法”思想的实践，揭示了数值格式如何模拟物理正则化过程来捕捉激波。", "problem": "考虑一维空间中的标量守恒律，\n$$\n\\partial_t u + \\partial_x f(u) = 0,\n$$\n该方程定义在一个有界区间上，具有适当的边界条件和初始数据。在区域剖分上应用的间断 Galerkin (DG) 方法在每个尺寸为 $h$ 的单元内用 $p$ 次多项式来近似 $u$，并在单元交界面处使用数值通量。众所周知，解中可能会出现激波，且经典解可能不会全局存在；物理上相关的解是熵弱解，它由分布意义下的熵不等式所刻画。\n\n一种稳定 DG 并强制其收敛到熵弱解的常用方法是添加一项基于残差的人工粘性项，从而使 DG 近似解满足以下形式的修正方程\n$$\n\\partial_t u + \\partial_x f(u) = \\partial_x\\!\\big(\\nu\\,\\partial_x u\\big),\n$$\n其中，粘性 $\\nu$ 在每个单元上是分片常数，并取决于局部残差和多项式次数。设给定单元内的局部特征速度为 $a = \\max_{u} |f'(u)|$，单位为米/秒（$m/s$）。设局部残差度量为 $R$，单位为 $1/s$，局部振幅尺度为 $T$，其单位与 $u$ 匹配（在此设定中为无量纲）。定义基于残差的指示器\n$$\nS = \\min\\!\\left\\{\\,1,\\;\\max\\!\\left\\{\\,0,\\;\\frac{h}{p}\\,\\frac{R}{a\\,T + \\varepsilon}\\,\\right\\}\\right\\},\n$$\n其中 $\\varepsilon$ 是一个小的正数，其单位为 $m/s$ 乘以 $u$ 的单位，仅用于防止除以零。所提出的人工粘性为\n$$\n\\nu \\;=\\; C_{\\mathrm{av}}\\,a\\,\\frac{h}{p}\\,S,\n$$\n其中 $C_{\\mathrm{av}}$ 是一个无量纲的校准常数。项 $\\partial_x(\\nu\\,\\partial_x u)$ 的单位与左侧的 $\\partial_t u$ 一致。\n\n任务：\n1. 从消失粘性法和熵弱解的定义出发，推导当 $h \\to 0$ 和/或 $p \\to \\infty$ 且保持 $h/p \\to 0$ 时，确保 DG 解收敛到熵弱解的粘性 $\\nu$ 关于多项式次数 $p$ 和网格尺寸 $h$ 的标度关系。您的推导必须独立于任何特定的通量函数，仅依赖于 $a = \\max |f'(u)|$、量纲一致性、激波厚度匹配论证以及熵不等式框架。明确论证 $\\nu$ 对 $a$ 和 $h/p$ 的线性依赖关系，以及使用无量纲指示器 $S$ 的合理性，该指示器在光滑区域消失并在激波附近饱和。\n\n2. 实现一个程序，对于给定的若干测试用例的 $(a,h,p,R,T)$ 和固定的 $C_{\\mathrm{av}}$，根据上述公式计算人工粘性 $\\nu$，并以平方米/秒（$m^2/s$）为单位输出结果。\n\n在您的程序中使用以下固定参数：\n- $C_{\\mathrm{av}} = 0.5$（无量纲），\n- $\\varepsilon = 10^{-12}$（单位为 $m/s$ 乘以 $u$ 的单位，数值上视为标量正则化项）。\n\n测试套件：\n为以下六个测试用例计算 $\\nu$，这些用例涵盖了光滑区域、激波主导区域和临界情景。所有量必须按其指定单位处理。\n- 用例 1：$a = 1.0$ $m/s$, $h = 0.1$ $m$, $p = 4$, $R = 0.01$ $1/s$, $T = 1.0$.\n- 用例 2：$a = 1.0$ $m/s$, $h = 0.1$ $m$, $p = 4$, $R = 100.0$ $1/s$, $T = 1.0$.\n- 用例 3：$a = 1.0$ $m/s$, $h = 0.1$ $m$, $p = 8$, $R = 100.0$ $1/s$, $T = 1.0$.\n- 用例 4：$a = 2.0$ $m/s$, $h = 0.02$ $m$, $p = 2$, $R = 50.0$ $1/s$, $T = 0.5$.\n- 用例 5：$a = 3.0$ $m/s$, $h = 0.05$ $m$, $p = 3$, $R = 0.0$ $1/s$, $T = 2.0$.\n- 用例 6：$a = 1.5$ $m/s$, $h = 0.1$ $m$, $p = 4$, $R = 0.02$ $1/s$, $T = 10^{-6}$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用逗号分隔的 Python 列表，内含按测试用例顺序排列的六个粘性值（每个都是浮点数，单位为 $m^2/s$），并用方括号括起来，例如 $[v_1,v_2,v_3,v_4,v_5,v_6]$。不应打印任何额外文本。", "solution": "该问题提出了两项任务：第一，为间断 Galerkin (DG) 方法推导基于残差的人工粘性的标度关系和形式；第二，实现一个程序来为一组测试用例计算该粘性。\n\n### 第 1 部分：人工粘性公式的推导\n\n目标是通过添加人工粘性项来稳定求解标量守恒律 $\\partial_t u + \\partial_x f(u) = 0$ 的 DG 方法，从而使数值解收敛到物理相关的熵弱解。使 DG 解 $u_h$ 近似于以下粘性正则化方程的解：\n$$\n\\partial_t u + \\partial_x f(u) = \\partial_x(\\nu\\,\\partial_x u)\n$$\n其中，随着离散化的加密（即单元尺寸 $h \\to 0$ 和/或多项式次数 $p \\to \\infty$），粘性系数 $\\nu$ 必须趋于零。\n\n此推导过程结合了偏微分方程理论（消失粘性和激波结构）、量纲分析以及 DG 方法的性质等原理。\n\n**1. 消失粘性法与激波结构**\n\n熵弱解的概念源于消失粘性法。我们考虑抛物型方程 $\\partial_t u_\\nu + \\partial_x f(u_\\nu) = \\nu \\partial_{xx} u_\\nu$ 的一族光滑解 $u_\\nu$。原始守恒律的唯一物理相关弱解被定义为极限 $u = \\lim_{\\nu \\to 0^+} u_\\nu$。\n\n双曲守恒律的一个关键特征是激波的形成。粘性方程中以速度 $s$ 传播的行进激波解可以写为 $u_\\nu(x,t) = U(\\xi)$，其中 $\\xi = x-st$。将此代入粘性方程，得到关于激波剖面 $U(\\xi)$ 的常微分方程：\n$$\n-s U' + (f(U))' = \\nu U''\n$$\n从 $-\\infty$ 到 $\\xi$ 对其积分，并应用边界条件 $U(-\\infty)=u_L$ 和 $U'(-\\infty)=0$，我们得到：\n$$\n-s(U(\\xi)-u_L) + (f(U(\\xi))-f(u_L)) = \\nu U'(\\xi)\n$$\n通过取极限 $\\xi \\to +\\infty$，可以恢复 Rankine-Hugoniot 条件 $s(u_R-u_L) = f(u_R)-f(u_L)$。\n\n这个激波层的厚度 $\\delta$ 是解从左状态 $u_L$ 过渡到右状态 $u_R$ 的特征长度尺度。从该常微分方程可知，最大梯度的标度关系为 $|U'| \\sim |u_R-u_L|/\\delta$。方程左侧的项可以由 $|f'(U)| |U-u_L| \\sim a |u_R-u_L|$ 界定，其中 $a = \\max|f'(u)|$ 是特征传播速度。因此，我们得到一个标度关系：\n$$\na |u_R-u_L| \\sim \\nu \\frac{|u_R-u_L|}{\\delta}\n$$\n这就得出了粘性 $\\nu$、特征速度 $a$ 和物理激波厚度 $\\delta$ 之间的基本关系：\n$$\n\\delta \\sim \\frac{\\nu}{a} \\quad \\implies \\quad \\nu \\sim a\\,\\delta\n$$\n这意味着所需的粘性量与特征速度和期望的激波层厚度成正比。\n\n**2. 数值分辨率与最大粘性**\n\n在数值方法中，间断必须在一个有限区域内被表示或“捕捉”。对于在尺寸为 $h$ 的单元上使用 $p$ 次多项式的 DG 方法，可以分辨的最小空间特征具有与有效网格尺寸成比例的长度尺度。这个有效分辨率通常取为 $\\delta_{num} \\sim h/p$。\n\n为确保数值格式正确地模拟物理上的消失粘性过程，其引入的人工粘性 $\\nu$ 必须使得产生的数值激波厚度与网格的最小可分辨尺度相匹配。通过令物理激波厚度约等于数值激波厚度，即 $\\delta \\approx \\delta_{num}$，我们获得了激波附近所需粘性的标度关系：\n$$\n\\frac{\\nu_{max}}{a} \\sim \\frac{h}{p} \\quad \\implies \\quad \\nu_{max} \\sim a \\frac{h}{p}\n$$\n这表明，在强激波存在时应施加的最大粘性，必须与特征波速 $a$ 和有效网格尺寸 $h/p$ 成正比。问题中给出的公式 $\\nu = C_{\\mathrm{av}}\\,a\\,\\frac{h}{p}\\,S$ 正好反映了这种标度关系。无量纲常数 $C_{\\mathrm{av}}$ 是一个量级为 1 的校准参数，而指示器 $S$ 被设计为在激波附近 $S \\approx 1$，从而激活这个最大粘性。\n\n**3. 通过基于残差的指示器进行选择性施加**\n\n高阶激波捕捉格式的一个关键要求是，人工粘性应仅在必要时（即在激波或其他非光滑特征附近）激活，而在解的光滑区域应可忽略不计。在所有地方都添加粘性会将格式的精度降低到一阶，并涂抹所有特征，而不仅仅是激波。\n\n偏微分方程残差 $\\mathcal{R}(u) = \\partial_t u + \\partial_x f(u)$ 是一个天然的指示器，用于标识数值解未能满足守恒律的区域。在光滑区域，DG 解 $u_h$ 是精确解的高度精确近似，此时残差将非常小。对于一个 $p+1$ 阶的 DG 方法，光滑区域的残差标度为 $R \\sim O(h^{p+1})$。然而，在激波附近，会出现 Gibbs 振荡，数值解无法满足偏微分方程，导致一个大的、不消失的残差，通常为 $R \\sim O(1)$。\n\n因此，粘性 $\\nu$ 的大小应由局部残差 $R$ 的大小来控制。这是通过无量纲指示器 $S$ 实现的。\n\n**4. 指示器 $S$ 的结构**\n\n指示器的公式如下：\n$$\nS = \\min\\!\\left\\{\\,1,\\;\\max\\!\\left\\{\\,0,\\;\\frac{h}{p}\\,\\frac{R}{a\\,T + \\varepsilon}\\,\\right\\}\\right\\}\n$$\n我们来分析它的组成部分：\n-   **核心项**：量 $Q = \\frac{h}{p}\\,\\frac{R}{a\\,T + \\varepsilon}$ 决定了指示器的激活程度。\n-   **量纲一致性**：正如在问题验证中所确立的，所有量的定义都使得 $Q$ 是无量纲的。$R$ 的单位是 $1/s$。分母 $a\\,T$ 是一个特征通量尺度，其中 $a$ 的单位是 $m/s$，$T$ 是一个无量纲的振幅尺度。为了使 $R$ 无量纲化，我们必须用一个特征频率来对其进行归一化。项 $aT/h$（特征速度乘以振幅，再除以单元尺寸）的单位是 $(m/s)/m = 1/s$。因此，无量纲的残差度量是 $R/(aT/h) = Rh/(aT)$。$Q$ 的表达式包含了这个组合，并额外乘以一个因子 $1/p$。项 $\\varepsilon$ 是一个小的正则化参数，用于在 $a$ 或 $T$ 接近零时防止除以零。\n-   **在光滑区域的行为**：在此处，$R \\sim O(h^{p+1})$，所以 $Q \\sim \\frac{h}{p} \\frac{h^{p+1}}{aT} \\sim \\frac{h^{p+2}}{p}$。当 $h \\to 0$ 时，$Q$ 会非常迅速地趋于 0。这使得 $S \\to 0$，从而正确地关闭了人工粘性，并保持了 DG 方法的高阶精度。\n-   **在激波附近的行为**：在此处，$R \\sim O(1)$。项 $Q$ 变得显著。因子 $h/p$ 意味着对于更高阶的单元（更大的 $p$）或更密的网格（更小的 $h$），需要一个更大的残差 $R$ 才能产生相同水平的粘性。这是合理的，因为更高阶的方法本身耗散性较小。\n-   **通过 $\\min\\{1, \\dots\\}$ 实现饱和**：如果残差足够大以至于 $Q  1$，指示器将在 $S=1$ 处饱和。这将粘性上限限制在 $\\nu_{max} = C_{\\mathrm{av}} a \\frac{h}{p}$，这恰好是根据我们的激波厚度论证得出的、在单个有效网格单元上解析激波所需的量。这可以防止添加过度的、不符合物理的耗散。\n-   **通过 $\\max\\{0, \\dots\\}$ 保证正性**：这确保了粘性是非负的，这是耗散的一个物理要求。\n\n**5. 向熵解的收敛**\n$\\nu$ 的整体方案确保了随着离散化的加密（特别是当 $h/p \\to 0$ 时），粘性在所有地方都趋于零：\n-   在光滑区域，$\\nu \\sim S \\to 0$ 非常快。\n-   在激波附近，$\\nu \\sim O(h/p) \\to 0$。\n\n由于当网格加密时 $\\nu \\to 0$，该方法与消失粘性法是一致的。DG 方法通过其构造保证了守恒性。增加的粘性项提供了必要的熵耗散机制，以防止形成不符合物理的膨胀激波，并确保如果数值解收敛，它们将收敛到唯一的熵弱解。至此，完成了对给定公式的论证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the artificial viscosity for several test cases based on a\n    residual-based sensor for Discontinuous Galerkin methods.\n    \"\"\"\n\n    # Fixed parameters from the problem statement\n    C_av = 0.5  # Dimensionless calibration constant\n    epsilon = 1.0e-12  # Regularization parameter in m/s (as u is dimensionless)\n\n    # Test suite from the problem statement\n    # Each tuple contains: (a, h, p, R, T)\n    # a: characteristic speed (m/s)\n    # h: cell size (m)\n    # p: polynomial degree (dimensionless)\n    # R: local residual measure (1/s)\n    # T: local amplitude scale (dimensionless)\n    test_cases = [\n        (1.0, 0.1, 4, 0.01, 1.0),\n        (1.0, 0.1, 4, 100.0, 1.0),\n        (1.0, 0.1, 8, 100.0, 1.0),\n        (2.0, 0.02, 2, 50.0, 0.5),\n        (3.0, 0.05, 3, 0.0, 2.0),\n        (1.5, 0.1, 4, 0.02, 1.0e-6),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        a, h, p, R, T = case\n\n        # Ensure polynomial degree is not zero to avoid division by zero\n        if p == 0:\n            # A p=0 DG scheme is a finite volume method. The formula might\n            # be interpreted differently, but for p > 0 it is well-defined.\n            # Assuming p is a positive integer as is standard for DG.\n            # For this problem, all p > 0.\n            pass\n\n        # Step 1: Compute the dimensionless sensor S\n        # S = min(1, max(0, (h/p) * R / (a*T + epsilon)))\n        \n        # Denominator of the sensor's argument\n        denominator = a * T + epsilon\n        \n        # Argument of the max function\n        sensor_arg = (h / p) * (R / denominator)\n        \n        # The sensor S is bounded between 0 and 1\n        S = min(1.0, max(0.0, sensor_arg))\n        \n        # Step 2: Compute the artificial viscosity nu\n        # nu = C_av * a * (h/p) * S\n        # The units are (m/s) * m = m^2/s, as expected for kinematic viscosity.\n        nu = C_av * a * (h / p) * S\n        \n        results.append(nu)\n\n    # Final print statement in the exact required format.\n    # The output is a list of floats representing nu in m^2/s.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3370432"}, {"introduction": "当我们用光滑的函数（如多项式或三角函数）去逼近一个非光滑的弱解时，会发生什么？经典的逐点误差可能会因为吉布斯现象（Gibbs phenomenon）而表现出误导性的行为。本练习要求你通过傅里叶谱方法，对一个包含间断的函数进行逼近，并对比逐点误差 $E_{\\infty}$ 和一种弱误差范数 $E_{-1}$ 的表现。你将通过计算发现，即使逐点误差在间断点附近不收敛，弱范数下的误差依然能很好地度量逼近的质量，这对于理解和评估求解弱解的数值方法的收敛性至关重要。", "problem": "考虑周期区间 $[0,2\\pi)$ 和一个实值分段光滑函数 $u(x)$，该函数至多有有限个跳跃间断点。设 $\\{e^{\\mathrm{i}k x}\\}_{k\\in\\mathbb{Z}}$ 表示 $[0,2\\pi)$ 上的复傅里叶基，并设 $u$ 的傅里叶系数为 $c_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} u(x)\\,e^{-\\mathrm{i}k x}\\,\\mathrm{d}x$。$N$ 阶模态截断谱近似是部分和 $u_N(x) = \\sum_{|k|\\le N} c_k e^{\\mathrm{i}k x}$。对于分段光滑的 $u$，经典的逐点收敛在跳跃点处失效（吉布斯现象），尽管 $u_N \\to u$ 在 $L^2$ 范数意义下收敛。谱方法和间断伽辽金（DG）方法中一种标准的稳定化方法是模态滤波：在重构前，通过一个滤波器 $\\varphi(k)$ 对模态系数进行衰减。\n\n本任务的基础知识：\n- $[0,2\\pi)$ 上的傅里叶系数 $c_k$ 和截断傅里叶级数 $u_N(x)$ 的定义。\n- 弱解的概念：与光滑测试函数配对的广义函数；弱范数（如负索伯列夫范数）用于量化弱意义下的收敛性。\n- $H^{-1}$ 型弱范数由与 $H^1$ 测试函数的对偶配对导出，并且可以通过傅里叶系数和权重 $1/|k|$（对于 $k\\neq 0$）来计算。\n\n您的任务是针对几个测试用例，实现以下经典误差和弱相容性误差之间的定量比较，并展示模态滤波的效果。当使用模态基（例如，勒让德或傅里叶模态）时，模态滤波是DG方法中的标准做法，用以抑制间断点周围的伪高频振荡：\n\n1. 域和采样。在周期域 $[0,2\\pi)$ 上工作，角度单位为弧度。使用一个包含 $G$ 个点的均匀网格，其中 $G=65536$，即在 $x_j = \\frac{2\\pi j}{G}$（$j=0,1,\\dots,G-1$）处进行采样。\n\n2. 模态近似。对于每个测试用例，通过网格上的离散傅里叶变换，使用复合梯形法则数值逼近傅里叶系数 $c_k$。通过将模态截断至 $|k|\\le N$ 来构造 $u_N(x)$。\n\n3. 模态滤波。定义一个模态滤波器 $\\varphi(k) = \\exp\\!\\big(-\\alpha \\, (|k|/N)^s\\big)$（对于 $|k|\\le N$）和 $\\varphi(k)=0$（对于 $|k|N$），其中 $\\alpha0$ 是滤波器强度，$s$ 是滤波器阶数。在重构之前，将此 $\\varphi(k)$ 应用于离散傅里叶系数，以获得滤波后的近似 $u_N^{\\mathrm{f}}(x)$。\n\n4. 需要量化的误差。\n   - 经典逐点误差（网格上的上确界范数）：$E_{\\infty}(u_N) = \\max_j |u_N(x_j) - u(x_j)|$ 和 $E_{\\infty}(u_N^{\\mathrm{f}}) = \\max_j |u_N^{\\mathrm{f}}(x_j) - u(x_j)|$。\n   - 由 $H^{-1}$ 型范数编码的弱相容性误差，该范数由离散傅里叶系数计算得出。如果 $e(x)=u_{\\star}(x)-u(x)$ 表示误差，设 $\\widehat{e}_k$ 表示 $e$ 的离散傅里叶系数，用以逼近连续的 $c_k$；然后计算\n     $$\\|e\\|_{H^{-1}} \\approx \\left(\\sum_{k\\in\\mathbb{Z}\\setminus\\{0\\}} \\frac{|\\widehat{e}_k|^2}{k^2}\\right)^{1/2}.$$\n     报告以此方式计算的 $E_{-1}(u_N)$ 和 $E_{-1}(u_N^{\\mathrm{f}})$。这是广义函数意义下的弱误差，因为它通过 $1/|k|$ 降低了高频内容的权重，并对应于对光滑函数的梯度进行测试，这反映了DG方法中的弱形式。\n\n5. 测试套件。实现以下四个测试用例，每个都在同一个包含 $G=65536$ 个点的网格上执行：\n   - 测试用例 1：$u_1(x) = \\sin(x) + H(x-\\pi)$，其中当 $y0$ 时 $H(y)=0$，当 $y\\ge 0$ 时 $H(y)=1$；参数为 $N=8$, $s=8$, $\\alpha=36$。\n   - 测试用例 2：$u_1(x)$ 同上；参数为 $N=64$, $s=8$, $\\alpha=36$。\n   - 测试用例 3：$u_2(x) = |\\sin(x)|$；参数为 $N=16$, $s=8$, $\\alpha=36$。\n   - 测试用例 4：$u_3(x) = \\begin{cases}-1, x\\in[0,\\pi)\\\\ 1, x\\in[\\pi,2\\pi)\\end{cases}$；参数为 $N=32$, $s=8$, $\\alpha=36$。\n\n6. 输出规格。对于每个测试用例，按顺序计算四个浮点数\n   $[E_{\\infty}(u_N),\\, E_{\\infty}(u_N^{\\mathrm{f}}),\\, E_{-1}(u_N),\\, E_{-1}(u_N^{\\mathrm{f}})]$。\n   您的程序应生成单行输出，其中包含所有四个测试用例的结果，形式为这些列表的逗号分隔列表，并用方括号括起来。例如，输出格式必须与\n   $[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}],[d_{1},d_{2},d_{3},d_{4}]]$\n   完全一样，不得包含任何额外文本。所有数值均为无量纲实数。\n\n本题的意图是从基本定义出发进行推理：傅里叶展开和截断定义了谱近似；DG风格的模态滤波在此通过衰减高阶模态系数来实现；弱相容性误差通过负索伯列夫范数来量化，该范数对应于广义函数测试，这与表现出吉布斯振荡的经典逐点误差形成对比。请确保您的实现严格遵守上述给出的采样、滤波和误差定义，并使用指定的网格和参数值作为测试套件，以进行客观评估。解决方案应具有普适性且纯粹是数学上的，无需物理单位。", "solution": "该问题陈述是一个有效的、适定的数值分析练习，特别是在处理带间断函数的谱方法背景下。它要求实现并比较两种误差度量——一种是经典的，另一种是弱的——用于截断和滤波后的傅里叶级数近似。所有提供的定义、参数和函数在数学上都是合理的，并且在计算上是可行的。因此，我们可以着手提供完整的解决方案。\n\n这个问题的核心在于，当逼近非光滑函数时，不同误差范数的行为形成对比。经典的逐点上确界范数，记为 $E_{\\infty}$，对局部现象（如跳跃间断点处的吉布斯过冲）高度敏感。相比之下，弱范数，如记为 $E_{-1}$ 的 $H^{-1}$ 型范数，是在一种“平滑化”或广义函数的意义上测量误差，这使其对高频振荡不那么敏感，更能反映近似作为弱解的质量。\n\n我们的目标是通过遵循一个精确的计算程序，为几个测试函数量化这种对比。\n\n**1. 离散化与傅里叶分析**\n\n我们在周期域 $[0, 2\\pi)$ 上工作。连续函数 $u(x)$ 在一个包含 $G=65536$ 个点的均匀网格上进行采样，即 $x_j = \\frac{2\\pi j}{G}$，其中 $j=0, 1, \\dots, G-1$。傅里叶系数 $c_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} u(x) e^{-\\mathrm{i}kx} \\mathrm{d}x$ 使用离散傅里叶变换（DFT）进行数值逼近。对于均匀网格上的周期函数，该积分的复合梯形法则具有谱精度，并对应于计算采样值的DFT：\n$$\n\\widehat{c}_k = \\frac{1}{G} \\sum_{j=0}^{G-1} u(x_j) e^{-\\mathrm{i} k x_j} = \\frac{1}{G} \\sum_{j=0}^{G-1} u(x_j) e^{-2\\pi\\mathrm{i}kj/G}\n$$\n这些离散系数 $\\widehat{c}_k$ 可以使用快速傅里叶变换（FFT）算法高效计算。整数波数 $k$ 的管理方式使其对应于模态 $\\{e^{\\mathrm{i}kx}\\}_{k \\in \\mathbb{Z}}$。在我们的实现中，我们将使用 `numpy.fft.fft` 计算总和，然后除以 $G$，并使用 `numpy.fft.fftfreq` 和 `numpy.fft.fftshift` 将系数 $\\widehat{c}_k$ 及其对应的波数 $k$ 按从 $-G/2+1$ 到 $G/2$ 的单调递增顺序排列。\n\n**2. 谱近似的构造**\n\n给定精确解 $u(x)$ 的离散傅里叶系数 $\\widehat{c}_k$，我们构造两种近似。\n\n首先，标准的 $N$ 阶模态截断谱近似 $u_N(x)$ 是通过仅保留 $|k| \\le N$ 的模态形成的。其傅里叶系数 $\\widehat{(u_N)}_k$ 为：\n$$\n\\widehat{(u_N)}_k = \\begin{cases} \\widehat{c}_k   \\text{if } |k| \\le N \\\\ 0   \\text{if } |k|  N \\end{cases}\n$$\n这代表了频域中的一个急剧截断，或称“箱式”滤波器。其在网格上的空间表示 $u_N(x_j)$ 是通过对系数集 $\\{\\widehat{(u_N)}_k\\}$ 应用逆离散傅里叶变换（通过IFFT算法）恢复的。\n\n其次，为了减轻吉布斯现象，我们构造了滤波后的近似 $u_N^{\\mathrm{f}}(x)$。这是通过在重构前对 $u_N(x)$ 的系数应用一个光滑的指数滤波器来实现的：\n$$\n\\varphi(k) = \\exp\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^s\\right) \\quad \\text{for } |k| \\le N\n$$\n滤波后近似的傅里叶系数 $\\widehat{(u_N^{\\mathrm{f}})}_k$ 为：\n$$\n\\widehat{(u_N^{\\mathrm{f}})}_k = \\varphi(k) \\widehat{(u_N)}_k = \\begin{cases} \\widehat{c}_k \\exp\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^s\\right)   \\text{if } |k| \\le N \\\\ 0   \\text{if } |k|  N \\end{cases}\n$$\n该滤波器平滑地衰减了接近截断频率 $N$ 的高频模态，这已知可以减少空间域中伪振荡的幅度。然后通过逆离散傅里叶变换恢复其空间表示 $u_N^{\\mathrm{f}}(x_j)$。\n\n**3. 误差量化**\n\n我们为每种近似计算两种不同的误差度量。\n\n逐点误差在网格上的离散上确界范数中测量：\n$$\nE_{\\infty}(u_{\\star}) = \\max_{j} |u_{\\star}(x_j) - u(x_j)|\n$$\n其中 $u_{\\star}$ 是 $u_N$ 或 $u_N^{\\mathrm{f}}$。该范数捕捉了单一的最差偏差，因此由间断点附近吉布斯振荡的峰值主导。\n\n弱相容性误差在离散的 $H^{-1}$ 型范数中测量，该范数由误差函数 $e(x) = u_{\\star}(x) - u(x)$ 的傅里叶系数计算得出。设 $\\widehat{e}_k$ 是误差的系数。范数定义为：\n$$\nE_{-1}(u_{\\star}) = \\|e\\|_{H^{-1}} \\approx \\left(\\sum_{k\\in\\mathbb{Z}\\setminus\\{0\\}} \\frac{|\\widehat{e}_k|^2}{k^2}\\right)^{1/2}\n$$\n因子 $1/k^2$ 严重惩罚低频误差，同时降低了高频差异的权重。这个范数对应于索伯列夫空间 $H^1$ 的对偶空间，用此范数测量误差类似于对光滑函数的导数进行测试，这是弱解理论和有限元/间断伽辽金元方法中的一个基本概念。\n\n为了计算这个范数，我们首先需要误差的傅里叶系数。\n对于截断误差 $e(x) = u_N(x) - u(x)$，其系数为：\n$$\n\\widehat{e}_k = \\widehat{(u_N)}_k - \\widehat{c}_k = \\begin{cases} 0   \\text{if } |k| \\le N \\\\ -\\widehat{c}_k   \\text{if } |k|  N \\end{cases}\n$$\n因此，其 $H^{-1}$ 范数的求和是在 $|k|N$ 的范围上进行的：\n$$\nE_{-1}(u_N) = \\left(\\sum_{|k|N} \\frac{|-\\widehat{c}_k|^2}{k^2}\\right)^{1/2}\n$$\n对于滤波误差 $e^{\\mathrm{f}}(x) = u_N^{\\mathrm{f}}(x) - u(x)$，其系数为：\n$$\n\\widehat{e^{\\mathrm{f}}}_k = \\widehat{(u_N^{\\mathrm{f}})}_k - \\widehat{c}_k = \\begin{cases} (\\varphi(k) - 1)\\widehat{c}_k   \\text{if } |k| \\le N \\\\ -\\widehat{c}_k   \\text{if } |k|  N \\end{cases}\n$$\n相应的 $H^{-1}$ 范数涉及两个不同区域的求和：\n$$\nE_{-1}(u_N^{\\mathrm{f}}) = \\left(\\sum_{0|k|\\le N} \\frac{|(\\varphi(k)-1)\\widehat{c}_k|^2}{k^2} + \\sum_{|k|N} \\frac{|-\\widehat{c}_k|^2}{k^2}\\right)^{1/2}\n$$\n第一项代表滤波器在保留模态上引入的误差，而第二项是截断误差，与 $u_N$ 的截断误差相同。这个公式揭示了一个关键的权衡：滤波减少了逐点的吉布斯振荡（降低了 $E_{\\infty}$），但在保留的模态中引入了额外的误差，这可能会增加弱范数 $E_{-1}$。\n\n实现将通过对四个指定的测试用例执行这些步骤来进行，为每个用例收集四个产生的误差值 $[E_{\\infty}(u_N), E_{\\infty}(u_N^{\\mathrm{f}}), E_{-1}(u_N), E_{-1}(u_N^{\\mathrm{f}})]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares classical pointwise and weak consistency errors for\n    spectral approximations of piecewise smooth functions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (case_id, N, s, alpha)\n        (1, 8, 8, 36),\n        (1, 64, 8, 36),\n        (2, 16, 8, 36),\n        (3, 32, 8, 36),\n    ]\n\n    G = 65536\n    # Define the computational grid on [0, 2*pi)\n    x = (2 * np.pi / G) * np.arange(G)\n\n    # Define the test functions\n    def u1(x_grid):\n        # u(x) = sin(x) + H(x-pi), where H is the Heaviside step function.\n        # H(y) = 1 for y >= 0.\n        return np.sin(x_grid) + (x_grid >= np.pi).astype(float)\n\n    def u2(x_grid):\n        # u(x) = |sin(x)|\n        return np.abs(np.sin(x_grid))\n\n    def u3(x_grid):\n        # u(x) = -1 for x in [0, pi), 1 for x in [pi, 2pi)\n        # On the grid, x=pi corresponds to index j=G/2.\n        # j  G/2 corresponds to x  pi.\n        res = np.ones_like(x_grid)\n        res[:G // 2] = -1.0\n        return res\n\n    u_funcs = {1: u1, 2: u2, 3: u3}\n    \n    all_results = []\n\n    for case_id, N, s, alpha in test_cases:\n        # 1. Sample the exact function on the grid\n        u_func = u_funcs[case_id]\n        u_grid = u_func(x)\n\n        # 2. Compute discrete Fourier coefficients (c_k) via FFT\n        # c_k = (1/G) * sum(u_j * exp(-i*k*x_j))\n        c_hat = np.fft.fft(u_grid) / G\n        \n        # Get integer wavenumbers k corresponding to FFT output\n        k_vec = np.fft.fftfreq(G) * G\n\n        # For easier indexing and filtering, shift frequencies to be monotonic\n        k_shifted = np.fft.fftshift(k_vec)\n        c_hat_shifted = np.fft.fftshift(c_hat)\n\n        # 3. Construct the truncated approximation u_N(x)\n        mask_le_N = np.abs(k_shifted) = N\n        c_N_shifted = np.zeros_like(c_hat_shifted, dtype=complex)\n        c_N_shifted[mask_le_N] = c_hat_shifted[mask_le_N]\n        \n        # Inverse shift and inverse FFT to get spatial representation\n        c_N = np.fft.ifftshift(c_N_shifted)\n        # The result must be real since input u(x) is real and spectrum is conjugate symmetric\n        u_N_grid = np.real(np.fft.ifft(c_N * G))\n\n        # 4. Construct the filtered approximation u_N^f(x)\n        # The filter is applied to the truncated coefficient set\n        phi_filter_values = np.exp(-alpha * (np.abs(k_shifted[mask_le_N]) / N)**s)\n        c_N_f_shifted = np.copy(c_N_shifted)\n        c_N_f_shifted[mask_le_N] *= phi_filter_values\n        \n        # Inverse shift and inverse FFT\n        c_N_f = np.fft.ifftshift(c_N_f_shifted)\n        u_N_f_grid = np.real(np.fft.ifft(c_N_f * G))\n\n        # 5. Compute the four specified error metrics\n        \n        # 5a. Pointwise supremum error (E_infinity)\n        e_inf_uN = np.max(np.abs(u_N_grid - u_grid))\n        e_inf_uNf = np.max(np.abs(u_N_f_grid - u_grid))\n        \n        # 5b. Weak H^-1-type error (E_-1)\n        # Isolate non-zero wavenumbers for the sum\n        nonzero_k_mask = k_shifted != 0\n        k_nonzero = k_shifted[nonzero_k_mask]\n        c_hat_nonzero = c_hat_shifted[nonzero_k_mask]\n\n        # Squared terms for the norm calculation: |c_k|^2 / k^2\n        sq_terms_H_minus_1 = (np.abs(c_hat_nonzero)**2) / (k_nonzero**2)\n\n        # E_-1 for the truncated approximation u_N\n        # Error coefficients are -c_k for |k|>N\n        mask_gt_N_in_nonzero = np.abs(k_nonzero) > N\n        e_minus1_uN_sq = np.sum(sq_terms_H_minus_1[mask_gt_N_in_nonzero])\n        e_minus1_uN = np.sqrt(e_minus1_uN_sq)\n\n        # E_-1 for the filtered approximation u_N^f\n        # The error has two parts\n        # Part 1: Error from filtering on |k| = N. Coefficients are (phi(k)-1)*c_k\n        mask_le_N_in_nonzero = np.abs(k_nonzero) = N\n        \n        k_part1 = k_nonzero[mask_le_N_in_nonzero]\n        c_hat_part1 = c_hat_nonzero[mask_le_N_in_nonzero]\n        phi_part1 = np.exp(-alpha * (np.abs(k_part1) / N)**s)\n        \n        terms_part1 = (np.abs((phi_part1 - 1) * c_hat_part1)**2) / (k_part1**2)\n        sum1_sq = np.sum(terms_part1)\n\n        # Part 2: Error from truncation |k| > N. Same as for u_N.\n        sum2_sq = e_minus1_uN_sq\n        \n        e_minus1_uNf = np.sqrt(sum1_sq + sum2_sq)\n\n        all_results.append([e_inf_uN, e_inf_uNf, e_minus1_uN, e_minus1_uNf])\n\n    # Final print statement in the exact required format.\n    # The repr().replace() trick generates a space-free list-of-lists string.\n    print(repr(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3370457"}]}