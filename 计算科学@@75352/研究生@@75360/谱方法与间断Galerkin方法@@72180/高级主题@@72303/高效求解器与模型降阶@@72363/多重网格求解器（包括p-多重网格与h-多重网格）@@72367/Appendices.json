{"hands_on_practices": [{"introduction": "本实践探讨了 $p$-多重网格方法的核心：粗网格算子的构建。我们将比较定义限制算子 $R$ 的两种方法，该算子用于将残差从细网格转移到粗网格。通过对比理论上最优的“相容”公式与计算上更高效的“质量集中”近似，您将量化粗网格校正精度与计算成本之间的权衡，这是多重网格设计中的一个中心主题。[@problem_id:3401559]", "problem": "考虑参考区间 $[-1,1]$ 上的一个一维对称正定椭圆模型问题，该问题具有齐次狄利克雷边界条件。令 $p$ 表示多项式次数，试验空间为勒让德-高斯-洛巴托（LGL）点上的节点拉格朗日基。谱元法（SEM）的刚度算子 $A$ 由双线性形式 $a(u,v) = \\int_{-1}^{1} u'(x) v'(x) \\, dx$ 定义，该形式通过使用LGL求积（及其权重）和由LGL节点导出的微分矩阵进行精确计算。令 $M$ 表示一致质量算子，它由双线性形式 $m(u,v) = \\int_{-1}^{1} u(x) v(x) \\, dx$ 定义，该形式通过使用具有足够多点的高斯-勒让德求积进行精确计算，以精确积分次数为 $2p$ 的多项式。间断伽辽金（DG）法和谱元法（SEM）在单元算子上共享此伽辽金基础；为清晰起见，本问题使用具有齐次狄利克雷边界条件的单个谱元。\n\n在 $p$-多重网格中，令细空间的次数为 $p_f$，粗空间的次数为 $p_c  p_f$。将延拓算子 $P$ 定义为从粗空间内部自由度到细空间内部自由度的节点插值映射，该映射由在细空间内部LGL节点上求值的粗空间拉格朗日基导出。考虑两种限制算子的定义，对应两种粗空间内积：\n- 一致 $L^2$ 限制算子 $R_{\\mathrm{cons}}$ 由 $L^2$ 投影定义，$R_{\\mathrm{cons}} = M_c^{-1} P^{\\top} M_f$，其中 $M_f$ 和 $M_c$ 是限制在内部自由度上的一致细、粗质量算子。\n- 质量集中粗空间限制算子 $R_{\\mathrm{lump}}$ 使用欧几里得内积，其中粗质量矩阵近似为单位阵，$M_c \\approx I$，从而得到 $R_{\\mathrm{lump}} = P^{\\top}$。\n\n对于每种限制算子的选择，通过标准的伽辽金构造 $A_c = R A_f P$ 定义粗算子，其中 $A_f$ 是限制在内部自由度上的细空间刚度算子，$A_c$ 是相应的粗算子。定义两网格粗校正误差传播算子\n$$\nE = I - P A_c^{-1} R A_f,\n$$\n其中 $I$ 是细空间内部自由度上的单位算子。通过由 $A_f$ 导出的能量范数中的收缩因子来量化粗校正的有效性，该收缩因子定义为\n$$\n\\| E \\|_{A_f} = \\sup_{x \\neq 0} \\sqrt{\\frac{x^{\\top} E^{\\top} A_f E x}{x^{\\top} A_f x}}.\n$$\n该量是矩阵对 $\\left(E^{\\top} A_f E, A_f\\right)$ 的最大广义特征值的平方根。\n\n任务：通过设置 $M_c \\approx I$ 以使 $R_{\\mathrm{lump}} = P^{\\top}$，来提出并实现质量集中粗空间。然后，通过为每个测试案例计算比率，量化相对于一致粗质量 $M_c$ 的粗校正精度损失\n$$\n\\rho = \\frac{\\| E_{\\mathrm{lump}} \\|_{A_f}}{\\| E_{\\mathrm{cons}} \\|_{A_f}},\n$$\n其中 $E_{\\mathrm{lump}}$ 和 $E_{\\mathrm{cons}}$ 分别是由 $R_{\\mathrm{lump}}$ 和 $R_{\\mathrm{cons}}$ 构建的误差传播算子。$\\rho \\geq 1$ 的值表示由于质量集中导致粗校正有效性下降。\n\n使用以下多项式次数对 $(p_f, p_c)$ 的测试套件：\n- 案例1（一般情况）：$(8, 4)$。\n- 案例2（近最小粗空间）：$(3, 2)$。\n- 案例3（激进粗化）：$(10, 2)$。\n- 案例4（近恒等粗化）：$(12, 11)$。\n\n对于所有计算：\n- 在参考区间 $[-1,1]$ 上进行计算。\n- 通过限制到内部自由度来施加齐次狄利克雷边界条件（即，从代数算子中省略边界LGL节点）。\n- 在此配置点设置下，使用勒让德-高斯-洛巴托节点通过精确求积来构建微分矩阵和刚度算子。\n- 使用具有 $p+1$ 个点的高斯-勒让德求积来精确组装一致质量算子。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个条目是上面列出的相应测试案例的 $\\rho$ 的浮点值。此计算不涉及物理单位或角度，因此不需要单位说明。", "solution": "## 问题验证\n\n### 第1步：提取已知条件\n- **模型问题**：在区间 $[-1,1]$ 上的一维对称正定椭圆模型问题，具有齐次狄利克雷边界条件。\n- **离散化方法**：使用单个单元的谱元法（SEM）。\n- **试验空间**：对于给定的多项式次数 $p$，在勒让德-高斯-洛巴托（LGL）点上的节点拉格朗日基。\n- **刚度算子 $A$**：由 $a(u,v) = \\int_{-1}^{1} u'(x) v'(x) \\, dx$ 定义，使用LGL求积进行精确计算。\n- **一致质量算子 $M$**：由 $m(u,v) = \\int_{-1}^{1} u(x) v(x) \\, dx$ 定义，使用具有 $p+1$ 个点的高斯-勒让德求积进行精确计算。\n- **边界条件**：齐次狄利克雷，通过将所有算子限制在内部自由度上施加。\n- **$p$-多重网格空间**：一个多项式次数为 $p_f$ 的细空间和一个次数为 $p_c  p_f$ 的粗空间。\n- **延拓算子 $P$**：从粗空间内部自由度到细空间内部自由度的节点插值。\n- **限制算子**：\n    - 一致限制算子 $R_{\\mathrm{cons}} = M_c^{-1} P^{\\top} M_f$，其中 $M_f$ 和 $M_c$ 是在内部自由度上的一致细、粗质量算子。\n    - 质量集中限制算子 $R_{\\mathrm{lump}} = P^{\\top}$，对应于将粗质量矩阵 $M_c$ 近似为单位阵 $I$。\n- **粗算子 $A_c$**：由伽辽金投影 $A_c = R A_f P$ 定义，其中 $A_f$ 是在内部自由度上的细空间刚度算子。\n- **两网格误差传播算子 $E$**：$E = I - P A_c^{-1} R A_f$，其中 $I$ 是细内部空间上的单位算子。\n- **收缩因子 $\\|E\\|_{A_f}$**：误差传播算子的能量范数，定义为 $\\| E \\|_{A_f} = \\sup_{x \\neq 0} \\sqrt{\\frac{x^{\\top} E^{\\top} A_f E x}{x^{\\top} A_f x}}$。这是矩阵对 $(E^{\\top} A_f E, A_f)$ 的最大广义特征值的平方根。\n- **任务**：为给定的测试案例计算比率 $\\rho = \\frac{\\| E_{\\mathrm{lump}} \\|_{A_f}}{\\| E_{\\mathrm{cons}} \\|_{A_f}}$。\n- **测试案例**：$(p_f, p_c)$ 对：$(8, 4)$、$(3, 2)$、$(10, 2)$ 和 $(12, 11)$。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该问题牢固地植根于偏微分方程数值分析的既定理论，特别是谱元离散化的 $p$-多重网格方法。所有定义——算子、范数和网格间传递——都是该领域的标准定义。\n- **适定性**：该问题在数学上是适定的。它要求一个特定的、可计算的量 $\\rho$，该量由标准矩阵运算和广义特征值问题导出。椭圆问题的底层刚度矩阵是对称正定的，这确保了它们的逆和后续计算是明确定义的。\n- **客观性**：问题陈述是精确、定量的，没有任何主观或模糊的语言。\n- **完整性和一致性**：提供了所有必要的定义、方程和参数。所定义算子的矩阵维度是一致的，确保了像 $A_c = R A_f P$ 这样的复合运算的有效性。\n\n没有违反科学原则，没有缺失信息，没有矛盾，也没有歧义。该问题是计算数学中一个标准但复杂的数值实验。\n\n### 第3步：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n---\n\n## 基于原理的设计\n\n该解决方案需要实现一维谱元法的 $p$-型两网格求解器的组件，然后分析两种不同粗网格公式的收敛特性。任务的核心是构建指定的矩阵和算子，然后计算生成的两网格误差传播算子的能量范数。\n\n### 1. 节点基和求积法则\n谱元法的基础是基函数和求积法则的选择。\n- **勒让德-高斯-洛巴托（LGL）点**：对于多项式次数 $p$，我们在 $[-1,1]$ 上使用 $p+1$ 个 LGL 点。这些点是 $(1-x^2)P_p'(x)$ 的根，其中 $P_p(x)$ 是 $p$ 次勒让德多项式。内部 LGL 节点是 Jacobi 多项式 $P_{p-1}^{(1,1)}(x)$ 的根。基函数是与这些节点相关的拉格朗日多项式 $\\{l_j(x)\\}_{j=0}^p$。\n- **LGL 求积**：该求积法则使用 LGL 节点作为横坐标，并具有相关的权重 $w_j = \\frac{2}{p(p+1)[P_p(x_j)]^2}$。它可以精确地积分最高次数为 $2p-1$ 的多项式。\n- **高斯-勒让德（GL）求积**：该法则使用 $k$ 个点，可以精确地积分最高次数为 $2k-1$ 的多项式。\n\n### 2. 算子组装\n刚度算子和质量算子是使用适当的求积法则构建的。所有算子最初都是为全套 $p+1$ 个自由度组装的。\n- **刚度算子 $A_p$**：双线性形式为 $a(l_j, l_i) = \\int_{-1}^1 l_i'(x) l_j'(x) dx$。这使用 LGL 求积进行计算。使用微分矩阵 $D$，其中 $D_{ij} = l_j'(x_i)$，刚度矩阵由 $A_p = D^T W D$ 给出，其中 $W$ 是 LGL 权重的对角矩阵。由于被积函数 $l_i'(x)l_j'(x)$ 是一个次数为 $2(p-1)$ 的多项式，而 LGL 求积对于最高次数为 $2p-1$ 的多项式是精确的，因此该求积是精确的。\n- **一致质量算子 $M_p$**：双线性形式为 $m(l_j, l_i) = \\int_{-1}^1 l_i(x) l_j(x) dx$。被积函数是一个次数为 $2p$ 的多项式。为了精确积分，我们需要一个对次数为 $2p$ 的多项式精确的求积法则。具有 $k$ 个点的高斯-勒让德求积对次数最高为 $2k-1$ 的多项式是精确的，因此我们需要 $2k-1 \\geq 2p$，这意味着 $k \\geq p+1/2$。如题目所指定，选择 $k=p+1$ 个 GL 点是足够的。质量矩阵组装为 $M_p = V^T \\Omega V$，其中 $\\Omega$ 是 GL 权重的对角矩阵，而 $V$ 是一个“类范德蒙”矩阵，其元素为 $V_{ki} = l_i(y_k)$，即在第 $k$ 个 GL 节点 $y_k$ 上计算 LGL 拉格朗日基函数 $l_i$ 的值。\n\n### 3. 边界条件和内部子空间\n通过将问题限制在由内部基函数张成的子空间中，来施加齐次狄利克雷边界条件（$u(-1)=u(1)=0$）。在代数上，这是通过取 $A_p$ 和 $M_p$ 对应于内部节点（即，排除第一行和最后一行以及第一列和最后一列）的子矩阵来实现的。得到的矩阵 $A_f$、$M_f$ 和 $M_c$ 作用于内部自由度的向量。\n\n### 4. 网格间传递算子\n- **延拓算子 $P$**：该算子将向量从粗内部空间映射到细内部空间。它是通过在细空间内部节点上计算粗空间基函数的值来构建的。粗内部空间的基由与粗*内部*节点相关的拉格朗日多项式 $\\{l_{c,j}\\}_{j=1}^{p_c-1}$ 组成。这些基函数本身是使用全套 $p_c+1$ 个粗 LGL 节点定义的。因此，矩阵元素 $P_{ij}$ 是第 $j$ 个粗内部基函数在第 $i$ 个细内部节点上的求值。重心插值是进行此计算的有效方法。\n- **限制算子 $R$**：限制算子将向量从细空间映射到粗空间。\n    - $R_{\\mathrm{lump}} = P^T$：这是延拓算子的转置，它对应于值的简单注入，并且等效于在粗空间上使用平凡（单位）内积。\n    - $R_{\\mathrm{cons}} = M_c^{-1} P^T M_f$：这是 $P$ 关于由质量矩阵 $M_f$ 和 $M_c$ 表示的 $L^2$ 内积的伴随算子。它是 $L^2$-正交投影的理论上最优选择。\n\n### 5. 两网格分析\n对于每种限制算子选择（$R_{\\mathrm{cons}}$ 和 $R_{\\mathrm{lump}}$），执行以下步骤：\n1.  **粗网格算子 $A_c$**：形成伽辽金粗算子 $A_c = R A_f P$。\n2.  **误差传播算子 $E$**：构建两网格误差传播算子 $E = I - P A_c^{-1} R A_f$。该算子描述了误差在一次粗网格校正循环中的变换方式（在此定义中省略了前平滑，这在仅分析粗校正步骤时很常见）。\n3.  **能量范数计算**：粗校正的有效性由 $E$ 的 $A_f$-范数衡量。该范数计算为矩阵对 $(E^T A_f E, A_f)$ 的最大广义特征值 $\\lambda_{\\max}$ 的平方根。此特征值问题使用针对对称定对的数值稳定算法求解。\n4.  **比率 $\\rho$**：最后一步是计算比率 $\\rho = \\|E_{\\mathrm{lump}}\\|_{A_f} / \\|E_{\\mathrm{cons}}\\|_{A_f}$，以量化由于粗空间内积中的质量集中而导致的性能下降。\n\n对测试套件中指定的每个 $(p_f, p_c)$ 对执行此结构化过程。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\nfrom scipy.linalg import eigh, inv\nfrom scipy.interpolate import BarycentricInterpolator\nfrom numpy.polynomial.legendre import leggauss\n\ndef lgl_nodes_weights(p):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto (LGL) nodes and weights for a given\n    polynomial degree p. Total number of points is p+1.\n    \"\"\"\n    if p == 0:\n        return np.array([-1.0]), np.array([2.0])\n    if p == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n    \n    # Interior nodes are roots of the Jacobi polynomial P_{p-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(p - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights are computed using the formula involving P_p(x_j)\n    P_p_at_nodes = eval_legendre(p, nodes)\n    weights = 2.0 / (p * (p + 1) * P_p_at_nodes**2)\n    \n    return nodes, weights\n\ndef lgl_diff_matrix(p, nodes):\n    \"\"\"\n    Computes the (p+1)x(p+1) differentiation matrix for LGL nodes.\n    \"\"\"\n    N = p\n    N_plus_1 = N + 1\n    D = np.zeros((N_plus_1, N_plus_1))\n    \n    if p == 0:\n        return np.array([[0.0]])\n        \n    P_N_at_nodes = eval_legendre(N, nodes)\n    \n    # Off-diagonal entries\n    for i in range(N_plus_1):\n        for j in range(N_plus_1):\n            if i != j:\n                D[i, j] = P_N_at_nodes[i] / (P_N_at_nodes[j] * (nodes[i] - nodes[j]))\n    \n    # Diagonal entries\n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    \n    return D\n\ndef stiffness_matrix(weights, diff_matrix):\n    \"\"\"\n    Computes the stiffness matrix A = D^T W D.\n    \"\"\"\n    W = np.diag(weights)\n    return diff_matrix.T @ W @ diff_matrix\n\ndef mass_matrix(p, lgl_nodes):\n    \"\"\"\n    Computes the consistent mass matrix M using Gauss-Legendre quadrature\n    with p+1 points for exactness.\n    \"\"\"\n    p_lgl = p\n    num_lgl_nodes = p_lgl + 1\n    \n    # Use k=p+1 GL points for exactness of degree 2p polynomial integration\n    k = p_lgl + 1\n    gl_nodes, gl_weights = leggauss(k)\n    \n    # Create Vandermonde-like matrix V_{ij} = l_j(gl_node_i) where l_j is the\n    # Lagrange polynomial for the j-th LGL node.\n    V = np.zeros((k, num_lgl_nodes))\n    interp = BarycentricInterpolator(lgl_nodes)\n    \n    for j in range(num_lgl_nodes):\n        y = np.zeros(num_lgl_nodes)\n        y[j] = 1.0\n        interp.set_yi(y)\n        V[:, j] = interp(gl_nodes)\n        \n    Omega = np.diag(gl_weights)\n    M = V.T @ Omega @ V\n    return M\n\ndef prolongation_matrix(p_c, nodes_c, nodes_f_int):\n    \"\"\"\n    Computes the prolongation matrix P, which interpolates from coarse\n    interior DoFs to fine interior DoFs.\n    \"\"\"\n    num_fine_int = len(nodes_f_int)\n    num_coarse_int = p_c - 1\n    \n    if num_coarse_int == 0:\n        return np.zeros((num_fine_int, 0))\n\n    P = np.zeros((num_fine_int, num_coarse_int))\n    # Interpolation is based on the full set of coarse nodes\n    interp = BarycentricInterpolator(nodes_c)\n    \n    # Iterate through coarse interior basis functions\n    for j in range(num_coarse_int):\n        coarse_node_idx_full = j + 1\n        y = np.zeros(p_c + 1)\n        y[coarse_node_idx_full] = 1.0\n        interp.set_yi(y)\n        P[:, j] = interp(nodes_f_int)\n\n    return P\n\ndef calculate_energy_norm(E, A_f):\n    \"\"\"\n    Calculates the energy norm ||E||_Af.\n    \"\"\"\n    # We need to solve the generalized eigenvalue problem (E^T A_f E) v = lambda A_f v\n    op = E.T @ A_f @ E\n    # Use eigh for symmetric-definite generalized eigenvalue problems\n    eigvals, _ = eigh(op, A_f)\n    # The norm squared is the largest eigenvalue. Eigenvalues are real.\n    return np.sqrt(np.max(eigvals))\n\n\ndef calculate_rho(p_f, p_c):\n    \"\"\"\n    Calculates the performance ratio rho for a given (p_f, p_c) pair.\n    \"\"\"\n    # 1. Fine grid setup\n    nodes_f, weights_f = lgl_nodes_weights(p_f)\n    D_f = lgl_diff_matrix(p_f, nodes_f)\n    A_f_full = stiffness_matrix(weights_f, D_f)\n    if p_f > 0:\n        M_f_full = mass_matrix(p_f, nodes_f)\n    else: # Should not happen based on problem constraints\n        M_f_full = np.array([[]])\n\n    \n    # 2. Coarse grid setup\n    nodes_c, _ = lgl_nodes_weights(p_c)\n    if p_c > 0:\n        M_c_full = mass_matrix(p_c, nodes_c)\n    else: # Should not happen\n        M_c_full = np.array([[]])\n    \n    # 3. Apply BCs by restricting to interior DoFs\n    nodes_f_int = nodes_f[1:-1]\n    A_f = A_f_full[1:-1, 1:-1]\n    M_f = M_f_full[1:-1, 1:-1]\n    M_c = M_c_full[1:-1, 1:-1]\n    \n    # 4. Prolongation operator\n    P = prolongation_matrix(p_c, nodes_c, nodes_f_int)\n    \n    num_fine_int = p_f - 1\n    I_f = np.eye(num_fine_int)\n    \n    # 5. Consistent case\n    R_cons = inv(M_c) @ P.T @ M_f\n    A_c_cons = R_cons @ A_f @ P\n    E_cons = I_f - P @ inv(A_c_cons) @ R_cons @ A_f\n    norm_cons = calculate_energy_norm(E_cons, A_f)\n\n    # 6. Mass-lumped case\n    R_lump = P.T\n    A_c_lump = R_lump @ A_f @ P\n    E_lump = I_f - P @ inv(A_c_lump) @ R_lump @ A_f\n    norm_lump = calculate_energy_norm(E_lump, A_f)\n    \n    # 7. Ratio\n    if norm_cons == 0:\n        # If consistent correction is exact, ratio is 1 if lumped is also exact, else inf.\n        return 1.0 if norm_lump == 0 else np.inf\n      \n    return norm_lump / norm_cons\n\ndef solve():\n    \"\"\"\n    Main solver function to execute the computation for all test cases.\n    \"\"\"\n    test_cases = [\n        (8, 4),    # general\n        (3, 2),    # near-minimal coarse space\n        (10, 2),   # aggressive coarsening\n        (12, 11),  # near-identity coarsening\n    ]\n\n    results = []\n    for p_f, p_c in test_cases:\n        rho = calculate_rho(p_f, p_c)\n        results.append(rho)\n\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3401559"}, {"introduction": "在算子构建原理的基础上，本练习深入探讨一个至关重要的实践细节：数值求积的影响。多重网格求解器的精度取决于粗网格问题在多大程度上能代表细网格误差，而不精确的求积会引入“混叠”误差，从而破坏这种表示。通过本实践，您将研究不同的求积策略如何影响粗网格残差的准确性，从而深入了解为何在稳健的光谱元多重网格方法中，通常需要过积分或专门的求积规则。[@problem_id:3401628]", "problem": "您需要研究一维谱元法中的多项式阶数粗化如何与多重网格中粗网格残差构造时的求积混叠相互作用。请完全在一维区间 $[-1,1]$ 上进行研究，使用单个谱元，其 Lagrange 基函数定义在 Gauss–Lobatto–Legendre (GLL) 节点上。考虑具有齐次自然 (Neumann) 边界条件的弱形式扩散模型问题：寻找一个足够光滑的函数 $u$，使得对于所有检验函数 $v$，\n$$\n\\int_{-1}^{1} a(x)\\, u'(x)\\, v'(x)\\, dx = \\int_{-1}^{1} f(x)\\, v(x)\\, dx.\n$$\n成立。使用系数和精确解\n$$\na(x) = 1 + 0.3\\cos(7x), \\quad u(x) = \\bigl(1-x^2\\bigr)^2,\n$$\n从而有 $u'(x) = -4x\\bigl(1-x^2\\bigr)$ 以及 $u''(x) = -4 + 12x^2$。源项通过代入强形式 $- \\bigl(a(x) u'(x)\\bigr)' = f(x)$ 来定义，即\n$$\nf(x) = -\\Big(a'(x)\\, u'(x) + a(x)\\, u''(x)\\Big), \\quad a'(x) = -2.1\\sin(7x).\n$$\n对于选定的多项式阶数 $p$，有 $N=p+1$ 个 GLL 节点 $\\{x_i\\}_{i=0}^{N-1}$ 及相关的 Lagrange 基 $\\{\\phi_i(x)\\}_{i=0}^{N-1}$，通过求积定义离散刚度矩阵和载荷向量为\n$$\nK_{ij} \\approx \\sum_{q=1}^{Q} w_q\\, a(x_q)\\, \\phi_i'(x_q)\\, \\phi_j'(x_q), \\qquad\nf_i \\approx \\sum_{q=1}^{Q} w_q\\, f(x_q)\\, \\phi_i(x_q),\n$$\n其中求积节点为 $\\{x_q\\}$，权重为 $\\{w_q\\}$。对于固定的系数和在 GLL 节点上插值的固定函数 $u$，粗网格残差为\n$$\nr = f - K\\, u_h, \\quad \\text{其中} \\quad u_h = \\bigl(u(x_0),\\dots,u(x_{N-1})\\bigr)^{\\top}.\n$$\n您必须实现三种求积策略来构造 $K$ 和 $f$：\n- 单个元素上的 GLL 配置（粗糙 $p$）：取 $Q=N$，节点等于 GLL 节点 $\\{x_i\\}$，权重等于 GLL 求积权重。这会表现出求积混叠，因为具有 $N$ 个节点的 GLL 求积仅能精确积分最高为 $2N-3=2p-1$ 次的多项式。\n- 使用 GLL 的复合子划分：将 $[-1,1]$ 划分成 $s$ 个相等的子区间，并在每个子区间上应用 $N$ 点 GLL 求积，通过仿射变换进行映射并求和。这为粗有限维空间保留了相同的 GLL 节点集，但使用复合求积来减轻混叠效应。\n- 过积分参考：在 $[-1,1]$ 上使用 $Q_{\\mathrm{ref}}=200$ 点的 Gauss–Legendre 求积来近似 $K$ 和 $f$ 中的精确积分；将得到的残差记为 $r_{\\mathrm{ref}}$。这将作为近乎精确的基准。\n\n为了分离求积混叠效应，在所有三种构造中使用相同的试验向量 $u_h$ 并比较残差。通过欧几里得范数来衡量两种粗糙构造的粗残差精度\n$$\nE_{\\mathrm{GLL}} = \\lVert r_{\\mathrm{GLL}} - r_{\\mathrm{ref}} \\rVert_2, \\qquad\nE_{\\mathrm{comp}} = \\lVert r_{\\mathrm{comp}} - r_{\\mathrm{ref}} \\rVert_2,\n$$\n其中 $r_{\\mathrm{GLL}}$ 来自单元素 GLL 求积，而 $r_{\\mathrm{comp}}$ 来自 $s$ 个子区间上的复合 GLL 求积。\n\n实现要求：\n- 对给定的 $N=p+1$，使用标准的 GLL 节点和权重。$N$ 个 GLL 节点是端点 $\\pm 1$ 以及 $(N-1)$ 阶 Legendre 多项式导数的 $(N-2)$ 个内部根。GLL 权重由下式给出\n$$\nw_i = \\frac{2}{N(N-1)\\,\\bigl(P_{N-1}(x_i)\\bigr)^2},\n$$\n其中 $P_{N-1}$ 是 $(N-1)$ 阶 Legendre 多项式。\n- 使用重心 Lagrange 插值在任意求积点 $x$ 处计算基函数 $\\phi_i(x)$ 及其导数 $\\phi_i'(x)$，并仔细处理求积点与节点重合时的极限情况。\n- 通过上述求积规则组装 $K$ 和 $f$。无需进行边界条件消除，因为弱形式使用自然边界条件，且所选的 $u$ 满足 $u'(\\pm 1)=0$。\n\n测试套件：\n对以下 $(p,s)$ 参数集评估 $(E_{\\mathrm{GLL}}, E_{\\mathrm{comp}})$ 对：\n- $(p,s)=(2,1)$，\n- $(p,s)=(2,4)$，\n- $(p,s)=(4,1)$，\n- $(p,s)=(4,4)$，\n- $(p,s)=(8,1)$，\n- $(p,s)=(8,4)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的对列表，不含空格。每个对按上列顺序对应一个测试用例，并包含两个浮点数值 $E_{\\mathrm{GLL}}$ 和 $E_{\\mathrm{comp}}$，采用科学记数法，小数点后保留八位数字。例如，一个包含两个假设测试用例的有效输出行如下所示\n$$\n[\\,[1.23456789\\mathrm{e}{-04},9.87654321\\mathrm{e}{-06}],[2.46800000\\mathrm{e}{-03},1.23500000\\mathrm{e}{-04}]\\,].\n$$\n角度以弧度为单位。不涉及物理单位。", "solution": "该问题是有效的。这是一个在偏微分方程数值分析领域中，特别是在谱元法和多重网格技术方面，提法恰当且有科学依据的问题。所有必要的数据和定义都已提供，不存在内部矛盾或违反科学原理的情况。\n\n问题的核心是研究一维谱元法中，求积混叠对粗网格残差的影响。残差 $r = f - K u_h$ 是多重网格方法中将信息从细网格传递到粗网格的关键组成部分。其精度直接影响多重网格求解器的收敛性。当用于计算离散刚度矩阵 $K$ 和载荷向量 $f$ 的求积法则不足以精确积分基函数（及其导数）与问题系数的乘积时，就会出现混叠误差。\n\n我们将基于谱元法的原理，在占据域 $[-1, 1]$ 的单个元素上实现一个解。\n\n### 1. 谱离散化与基函数\n\n解 $u(x)$ 由一个 $p$ 次多项式 $u_p(x)$ 近似。该近似在一个由 $N=p+1$ 个 Lagrange 多项式 $\\{\\phi_j(x)\\}_{j=0}^p$ 构成的基中表示，这些多项式是相对于 $N$ 个 Gauss-Lobatto-Legendre (GLL) 节点 $\\{x_j\\}_{j=0}^p$ 定义的。这些节点是 $(1-x^2)P_p'(x)$ 的零点，其中 $P_p(x)$ 是 $p$ 阶 Legendre 多项式。Lagrange 基具有性质 $\\phi_j(x_i) = \\delta_{ij}$，其中 $\\delta_{ij}$ 是 Kronecker delta。\n\n离散解由其在 GLL 节点上的值构成的向量表示，即 $u_h = [u(x_0), u(x_1), \\dots, u(x_p)]^\\top$。对此问题，使用精确解 $u(x) = (1-x^2)^2$ 来构造此向量。\n\n### 2. 弱形式与求积\n\n模型问题的弱形式由下式给出：\n$$\n\\int_{-1}^{1} a(x)\\, u'(x)\\, v'(x)\\, dx = \\int_{-1}^{1} f(x)\\, v(x)\\, dx\n$$\n代入谱近似 $u(x) \\approx \\sum_j u_j \\phi_j(x)$ 并使用检验函数 $v(x) = \\phi_i(x)$，我们得到离散系统 $K u_h = f$。刚度矩阵 $K$ 和载荷向量 $f$ 的项为：\n$$\nK_{ij} = \\int_{-1}^{1} a(x)\\, \\phi_i'(x)\\, \\phi_j'(x)\\, dx\n$$\n$$\nf_i = \\int_{-1}^{1} f(x)\\, \\phi_i(x)\\, dx\n$$\n这些积分使用具有 $Q$ 个点 $\\{x_q\\}$ 和权重 $\\{w_q\\}$ 的求积法则进行数值计算：\n$$\nK_{ij} \\approx \\sum_{q=1}^{Q} w_q\\, a(x_q)\\, \\phi_i'(x_q)\\, \\phi_j'(x_q)\n$$\n$$\nf_i \\approx \\sum_{q=1}^{Q} w_q\\, f(x_q)\\, \\phi_i(x_q)\n$$\n\n### 3. 求积策略与混叠\n\n$K$ 和 $f$ 的精度取决于所选的求积法则。$K_{ij}$ 的被积函数包含基函数导数的乘积 $\\phi_i'(x)\\phi_j'(x)$（这是一个 $2p-2$ 次多项式），再乘以非多项式系数 $a(x)$。\n\n比较了三种求积策略：\n\n1.  **参考求积 ($r_{\\mathrm{ref}}$)**：使用一个高阶的 $Q_{\\mathrm{ref}}=200$ 点 Gauss-Legendre 法则。此求积足够精确，可被视为对积分的“近乎精确”的计算，从而提供一个基准残差 $r_{\\mathrm{ref}}$。\n\n2.  **GLL 配置 ($r_{\\mathrm{GLL}}$)**：将 $N=p+1$ 个 GLL 节点本身用作求积点。此法则能精确积分最高为 $2N-3 = 2p-1$ 次的多项式。由于 $K$ 和 $f$ 的被积函数涉及非多项式函数 $a(x)$ 和 $f(x)$，该求积是不精确的，并会引入混叠误差。对于这种特定的求积，由于性质 $\\phi_i(x_j) = \\delta_{ij}$，载荷向量简化为 $f_i = w_i f(x_i)$。刚度矩阵使用 GLL 微分矩阵 $D$（其中 $D_{ij} = \\phi'_j(x_i)$）组装为 $K_{\\mathrm{GLL}} = D^\\top W A D$，其中 $W$ 和 $A$ 分别是在 GLL 节点上求值的 GLL 权重和系数 $a(x)$ 的对角矩阵。\n\n3.  **复合 GLL 求积 ($r_{\\mathrm{comp}}$)**：为了在局部使用相同 GLL 点的同时减轻混叠效应，将域 $[-1,1]$ 划分为 $s$ 个子区间。在每个子区间上，通过仿射变换应用 $N$ 点 GLL 求积法则。这产生了一个总共有 $s \\times N$ 个求积点的复合法则，显著提高了精度并减少了混叠。\n\n后两种方法因混叠引起的误差，通过其计算出的残差与参考残差之差的欧几里得范数来衡量：$E_{\\mathrm{GLL}} = \\lVert r_{\\mathrm{GLL}} - r_{\\mathrm{ref}} \\rVert_2$ 和 $E_{\\mathrm{comp}} = \\lVert r_{\\mathrm{comp}} - r_{\\mathrm{ref}} \\rVert_2$。\n\n### 4. 基函数及其导数的实现\n\n一个关键的实现细节是在任意求积点 $x_q$ 处稳定而精确地计算基函数 $\\phi_j(x)$ 及其导数 $\\phi_j'(x)$。\n\n-   **GLL 节点和权重**：对于给定的阶数 $p$，$p+1$ 个节点被找作 $(1-x^2)P'_p(x)$ 的根，而权重则由包含 $P_p(x)$ 的标准公式计算得出。\n-   **节点处的导数**：对于 GLL 求积的情况，其中求积点与基节点重合，导数从 GLL 微分矩阵 $D$ 的项中获得，该矩阵是使用已有的稳定性和精度公式构造的。\n-   **任意点处的导数**：对于参考求积和复合求积，求积点 $x_q$ 通常不与 GLL 节点 $\\{x_j\\}$ 重合。在这些情况下，我们采用一个公式来计算 Lagrange 多项式 $\\phi_j(x)$ 在任意点 $x \\ne x_j$ 的导数：\n    $$\n    \\phi_j'(x) = \\frac{l'(x)}{l'(x_j)(x-x_j)} - \\frac{\\phi_j(x)}{x-x_j}\n    $$\n    其中 $l(x) = C(1-x^2)P_p'(x)$ 是以 GLL 节点为根的多项式。这需要计算 $P_p(x)$ 及其最高二阶的导数，这可以通过使用它们的三项递推关系来高效完成。这种方法避免了 $\\phi_j'(x)$ 的朴素乘积法则定义可能带来的不稳定性。\n\n遵循此程序，我们可以系统地为每种求积策略组装所需的矩阵和向量，计算残差，并为每个测试用例评估指定的误差范数。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating quadrature aliasing effects on coarse-grid residuals\n    in a 1D spectral element method.\n    \"\"\"\n    \n    test_cases = [\n        (2, 1),\n        (2, 4),\n        (4, 1),\n        (4, 4),\n        (8, 1),\n        (8, 4),\n    ]\n\n    _gll_cache = {}\n    def get_gll_nodes_weights(p):\n        \"\"\"\n        Computes Gauss-Lobatto-Legendre nodes and weights for a given polynomial degree p.\n        Nodes are roots of (1-x^2)P'_p(x).\n        \"\"\"\n        if p in _gll_cache:\n            return _gll_cache[p]\n\n        N = p + 1\n        if p == 0:\n            nodes = np.array([-1.0])\n            weights = np.array([2.0])\n            _gll_cache[p] = (nodes, weights)\n            return nodes, weights\n        if p == 1:\n            nodes = np.array([-1.0, 1.0])\n            weights = np.array([1.0, 1.0])\n            _gll_cache[p] = (nodes, weights)\n            return nodes, weights\n\n        # Interior nodes are roots of P'_p(x)\n        leg_poly = Legendre.basis(p)\n        leg_poly_deriv = leg_poly.deriv(1)\n        interior_nodes = leg_poly_deriv.roots()\n        \n        nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n        \n        # Weights formula: w_i = 2 / (p*(p+1) * (P_p(x_i))^2)\n        P_p_at_nodes = leg_poly(nodes)\n        weights = 2.0 / (p * (p + 1) * P_p_at_nodes**2)\n        \n        _gll_cache[p] = (nodes, weights)\n        return nodes, weights\n\n    def get_diff_matrix(p, nodes):\n        \"\"\"\n        Computes the GLL differentiation matrix D, where D_ij = phi'_j(x_i).\n        \"\"\"\n        N = p + 1\n        D = np.zeros((N, N))\n        leg_poly = Legendre.basis(p)\n        P_p_at_nodes = leg_poly(nodes)\n\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    D[i, j] = (P_p_at_nodes[i] / P_p_at_nodes[j]) * (1.0 / (nodes[i] - nodes[j]))\n        \n        D[0, 0] = -p * (p + 1) / 4.0\n        D[N - 1, N - 1] = p * (p + 1) / 4.0\n        # for i > 0 and i  N-1, D[i,i] is 0 based on Hesthaven text,\n        # but summing off-diagonals is more general.\n        for i in range(1, N - 1):\n             D[i,i] = 0.0 # Standard formula for interior nodes\n        \n        return D\n\n    def legendre_poly_and_derivs(p, x):\n        \"\"\"\n        Computes P_p(x), P'_p(x), P''_p(x) using recurrence relations.\n        \"\"\"\n        if p == 0:\n            return 1.0, 0.0, 0.0\n        \n        p_k_minus_2, p_k_minus_1 = 1.0, x\n        pp_k_minus_2, pp_k_minus_1 = 0.0, 1.0\n        ppp_k_minus_2, ppp_k_minus_1 = 0.0, 0.0\n\n        for k in range(1, p):\n            p_k = ((2 * k + 1) * x * p_k_minus_1 - k * p_k_minus_2) / (k + 1)\n            pp_k = ((2 * k + 1) * (p_k_minus_1 + x * pp_k_minus_1) - k * pp_k_minus_2) / (k + 1)\n            ppp_k = ((2 * k + 1) * (2 * pp_k_minus_1 + x * ppp_k_minus_1) - k * ppp_k_minus_2) / (k + 1)\n            \n            p_k_minus_2, p_k_minus_1 = p_k_minus_1, p_k\n            pp_k_minus_2, pp_k_minus_1 = pp_k_minus_1, pp_k\n            ppp_k_minus_2, ppp_k_minus_1 = ppp_k_minus_1, ppp_k\n\n        return p_k_minus_1, pp_k_minus_1, ppp_k_minus_1\n\n    # Problem-specific functions\n    a = lambda x: 1.0 + 0.3 * np.cos(7.0 * x)\n    a_prime = lambda x: -2.1 * np.sin(7.0 * x)\n    u_exact = lambda x: (1.0 - x**2)**2\n    u_prime = lambda x: -4.0 * x * (1.0 - x**2)\n    u_double_prime = lambda x: -4.0 + 12.0 * x**2\n    f_source = lambda x: -(a_prime(x) * u_prime(x) + a(x) * u_double_prime(x))\n\n    results = []\n    \n    for p, s in test_cases:\n        N = p + 1\n        \n        gll_nodes, gll_weights = get_gll_nodes_weights(p)\n        D = get_diff_matrix(p, gll_nodes)\n        \n        u_h = u_exact(gll_nodes)\n        \n        # Precompute l'(x_j) for arbitrary point derivative evaluation\n        l_prime_at_nodes = np.zeros(N)\n        for j in range(N):\n            xj = gll_nodes[j]\n            _, Pp_prime, Pp_double_prime = legendre_poly_and_derivs(p, xj)\n            l_prime_at_nodes[j] = (1 - xj**2) * Pp_double_prime - 2 * xj * Pp_prime\n            \n        def eval_basis_functions(xq, p_deg, base_nodes, diff_matrix):\n            # Check if xq is one of the base_nodes\n            match_indices = np.where(np.isclose(xq, base_nodes))[0]\n            if len(match_indices) > 0:\n                k = match_indices[0]\n                phis = np.zeros(p_deg + 1)\n                phis[k] = 1.0\n                phi_primes = diff_matrix[k, :]\n                return phis, phi_primes\n            \n            # If xq is not a node, use arbitrary point evaluation formulas\n            phis = np.zeros(p_deg + 1)\n            phi_primes = np.zeros(p_deg + 1)\n\n            _, Pp_prime_xq, Pp_double_prime_xq = legendre_poly_and_derivs(p_deg, xq)\n            l_xq = (1 - xq**2) * Pp_prime_xq\n            l_prime_xq = (1 - xq**2) * Pp_double_prime_xq - 2 * xq * Pp_prime_xq\n\n            for j in range(p_deg + 1):\n                xj = base_nodes[j]\n                phis[j] = l_xq / ((xq - xj) * l_prime_at_nodes[j])\n                phi_primes[j] = (l_prime_xq / (l_prime_at_nodes[j] * (xq - xj))) - (phis[j] / (xq - xj))\n\n            return phis, phi_primes\n\n        # 1. Reference residual (Over-integration)\n        Q_ref = 200\n        xq_ref, wq_ref = np.polynomial.legendre.leggauss(Q_ref)\n        K_ref = np.zeros((N, N))\n        f_ref = np.zeros(N)\n        for xq, wq in zip(xq_ref, wq_ref):\n            phis, phi_primes = eval_basis_functions(xq, p, gll_nodes, D)\n            K_ref += wq * a(xq) * np.outer(phi_primes, phi_primes)\n            f_ref += wq * f_source(xq) * phis\n        r_ref = f_ref - K_ref @ u_h\n\n        # 2. GLL residual (Collocation)\n        K_gll = D.T @ np.diag(gll_weights * a(gll_nodes)) @ D\n        f_gll = gll_weights * f_source(gll_nodes)\n        r_gll = f_gll - K_gll @ u_h\n\n        # 3. Composite GLL residual\n        K_comp = np.zeros((N, N))\n        f_comp = np.zeros(N)\n        sub_interval_bps = np.linspace(-1, 1, s + 1)\n        for i in range(s):\n            a_sub, b_sub = sub_interval_bps[i], sub_interval_bps[i+1]\n            jacobian = (b_sub - a_sub) / 2.0\n            xq_sub = jacobian * gll_nodes + (a_sub + b_sub) / 2.0\n            wq_sub = jacobian * gll_weights\n            \n            for k in range(N):\n                xk = xq_sub[k]\n                wk = wq_sub[k]\n                phis, phi_primes = eval_basis_functions(xk, p, gll_nodes, D)\n                K_comp += wk * a(xk) * np.outer(phi_primes, phi_primes)\n                f_comp += wk * f_source(xk) * phis\n        r_comp = f_comp - K_comp @ u_h\n        \n        e_gll = np.linalg.norm(r_gll - r_ref)\n        e_comp = np.linalg.norm(r_comp - r_ref)\n        results.append([e_gll, e_comp])\n\n    formatted_pairs = [f\"[{e[0]:1.8e},{e[1]:1.8e}]\" for e in results]\n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```", "id": "3401628"}, {"introduction": "最后的这个实践处理非连续伽辽金 (DG) 方法中一个独特的挑战：在多重网格层次结构中弱施加边界条件。我们将使用 Nitsche 方法，其中罚参数 $\\sigma$ 对稳定性和准确性至关重要。您将探索在细网格和粗网格之间使用不一致的罚参数缩放所带来的后果，并量化由此导致的粗网格算子误差。本练习突出了 DG 公式与多重网格分量之间精妙的相互作用，这是为现代高阶方法开发高效求解器时的关键考虑因素。[@problem_id:3401554]", "problem": "考虑单位区间上的标量泊松边值问题，其具有齐次狄利克雷边界条件，并在单个单元上采用间断伽辽金 (DG) 格式，通过对称 Nitsche 方法弱施加边界条件。具体来说，令 $u:[0,1]\\to\\mathbb{R}$ 满足\n$$\n- u''(x) = f(x)\\quad \\text{for } x\\in (0,1),\\qquad u(0)=0,\\quad u(1)=0,\n$$\n并考虑在单个 DG 单元（无内部面）上对称 Nitsche 方法的双线性形式：\n$$\na(u,v) \\;=\\; \\int_{0}^{1} u'(x)\\,v'(x)\\,dx \\;-\\; u'(1)\\,v(1) \\;+\\; u'(0)\\,v(0)\\;-\\; v'(1)\\,u(1) \\;+\\; v'(0)\\,u(0)\\;+\\; \\sigma\\left(u(1)\\,v(1)+u(0)\\,v(0)\\right),\n$$\n其中 $\\sigma$ 是一个罚参数，用于弱施加边界条件。\n\n您将研究在使用 Nitsche 方法时，在多项式多重网格 (p-多重网格) 设置下粗网格边界条件施加的影响，并量化由跨层级的罚项缩放不匹配所引入的误差。请使用以下设置和要求。\n\n1) 多项式空间和基。在单个单元 $[0,1]$ 上，使用映射的勒让德基 $\\{\\phi_k\\}_{k=0}^{p}$，其中\n$$\n\\phi_k(x) = L_k(\\xi), \\quad \\xi = 2x - 1,\\quad x\\in[0,1],\n$$\n其中 $L_k$ 表示 $[-1,1]$ 上的 $k$ 次勒让德多项式。导数映射为 $\\dfrac{d}{dx} = 2\\dfrac{d}{d\\xi}$。您可以假定基函数及其导数的以下边界值：\n$$\n\\phi_k(1) = L_k(1)=1,\\quad \\phi_k(0) = L_k(-1) = (-1)^k,\n$$\n$$\n\\phi_k'(1) = 2\\,L_k'(1)=k(k+1),\\quad \\phi_k'(0) = 2\\,L_k'(-1)=(-1)^{k+1}\\,k(k+1).\n$$\n\n2) 离散算子。对于给定的多项式阶数 $p$，通过 $A_{ij} = a(\\phi_j,\\phi_i)$ 定义离散刚度矩阵 $A(p;\\sigma)$，其中体积项通过精确或足够精确的高斯-勒让德求积进行组装，边界项通过上述显式端点公式进行组装。\n\n3) Nitsche 罚项缩放。令 $h=1$。将 Nitsche 罚项定义为\n$$\n\\sigma \\;=\\; \\gamma\\,\\frac{p_{\\text{scale}}^2}{h} \\;=\\; \\gamma\\,p_{\\text{scale}}^2,\n$$\n其中 $\\gamma0$ 是一个用户指定的参数，而 $p_{\\text{scale}}$ 是一个用于缩放的选定多项式阶数。在具有细层级阶数 $p_f$ 和粗层级阶数 $p_c  p_f$ 的 p-多重网格层次结构中，用于缩放的阶数 $p_{\\text{scale}}$ 有两种自然的选择：\n- **一致缩放**：在粗层级使用细层级的阶数进行缩放，$p_{\\text{scale}} = p_f$。\n- **不一致缩放**：在粗层级使用粗层级自身的阶数进行缩放，$p_{\\text{scale}} = p_c$。\n\n您的任务是为给定的测试用例，将通过伽辽金方法得到的粗算子 $A_c^G$（即细算子 $A_f=A(p_f; \\gamma p_f^2)$ 的前导 $(p_c+1)\\times(p_c+1)$ 子矩阵）与使用上述特定 $p_{\\text{scale}}$ 重新组装的粗算子 $A_c^{\\text{ass}}(p_{\\text{scale}})$ 进行比较。通过以下指标量化差异：\n- **相对算子范数误差**：$E_{\\text{op}} = \\lVert \\Delta \\rVert_2 / \\lVert A_c^G \\rVert_2$，其中 $\\Delta = A_c^{\\text{ass}} - A_c^G$。\n- **能量瑞利不匹配**：$E_v = |v^\\top \\Delta v| / |v^\\top A_c^G v|$，其中 $v$ 是精确解 $u(x) = x(1-x)$ 在 $p_c$ 阶多项式空间上的 $L^2$ 投影的系数向量。\n- **对称正定性 (SPD) 指示符**：一个布尔值，如果组装的粗算子的对称部分 $\\frac{1}{2}(A_c^{\\text{ass}} + (A_c^{\\text{ass}})^\\top)$ 是对称正定的，则为 `True`，否则为 `False`。\n\n测试用例：\n对以下 $(p_f, p_c, \\gamma, p_{\\text{scale}})$ 组合进行评估：\n- 案例1：$(6, 2, 10, p_c)$\n- 案例2：$(8, 4, 0.01, p_c)$\n- 案例3：$(4, 3, 10, p_f)$\n- 案例4：$(6, 0, 10, p_c)$\n- 案例5：$(10, 2, 100, p_c)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的列表。列表中的每个条目都是一个包含三个值的列表 `[E_op, E_v, is_spd]`，对应于上述测试案例。浮点数应四舍五入到八位小数。例如：`[[0.12345678,0.98765432,True],[...]]`", "solution": "此问题经评估为有效。它在科学上基于间断伽辽金 (DG) 方法的数值分析，问题是良定的，具有一组清晰完整的定义，并以客观、正式的语言表述。解决此问题不存在矛盾、歧义或未满足的先决条件。\n\n解决方案的流程是，首先根据所提供的双线性形式和多项式基构建离散算子，然后使用这些算子为每个测试用例计算指定的误差度量。\n\n### 1. 多项式基函数\n问题指定了在单元 $[0,1]$ 上的一个基，该基通过仿射映射 $\\xi = 2x - 1$ 从 $[-1,1]$ 上的标准勒让德多项式 $L_k(\\xi)$ 导出。基函数为 $\\phi_k(x) = L_k(2x-1)$，其中 $k \\in \\{0, 1, \\dots, p\\}$。导数通过链式法则关联：$\\frac{d\\phi_k}{dx} = \\frac{dL_k}{d\\xi}\\frac{d\\xi}{dx} = 2L_k'(\\xi)$。给定的 $\\phi_k$ 和 $\\phi_k'$ 的边界值与此映射下的标准勒让德多项式性质一致。为了进行数值计算，勒让德多项式及其导数可通过其三项递推关系高效计算：\n$$\n(k+1)L_{k+1}(\\xi) = (2k+1)\\xi L_k(\\xi) - k L_{k-1}(\\xi)\n$$\n$$\nL'_{k+1}(\\xi) = (2k+1)L_k(\\xi) + L'_{k-1}(\\xi)\n$$\n初始条件为 $L_0(\\xi)=1$, $L_1(\\xi)=\\xi$ 及 $L'_0(\\xi)=0$, $L'_1(\\xi)=1$。\n\n### 2. DG 矩阵组装\n对于一个阶数为 $p$ 的多项式空间和一个罚参数 $\\sigma$，组装一个大小为 $(p+1) \\times (p+1)$ 的离散刚度矩阵 $A(p;\\sigma)$。其元素由 $A_{ij} = a(\\phi_j, \\phi_i)$ 给出，其中 $a(\\cdot, \\cdot)$ 是指定的对称 Nitsche 双线性形式。\n$$\na(u,v) = \\int_{0}^{1} u'v'dx - u'(1)v(1) + u'(0)v(0) - v'(1)u(1) + v'(0)u(0) + \\sigma(u(1)v(1)+u(0)v(0))\n$$\n组装过程分为体积项和边界项：$A_{ij} = A_{ij}^{\\text{vol}} + A_{ij}^{\\text{bnd}}$。\n\n**体积项**：该积分使用高斯-勒让德求积法计算。\n$$\nA_{ij}^{\\text{vol}} = \\int_0^1 \\phi_i'(x) \\phi_j'(x) dx = \\int_{-1}^1 (2L_i'(\\xi))(2L_j'(\\xi)) \\frac{1}{2}d\\xi = 2\\int_{-1}^1 L_i'(\\xi) L_j'(\\xi) d\\xi\n$$\n使用一个具有点 $\\xi_q$ 和权重 $w_q$ 的 $N_q$ 点求积法则，上式变为：\n$$\nA_{ij}^{\\text{vol}} \\approx 2 \\sum_{q=0}^{N_q-1} w_q L_i'(\\xi_q) L_j'(\\xi_q)\n$$\n为确保精确积分最高达到 $2p$ 次的多项式乘积，一个 $p+1$ 阶的求积法则（即 $N_q = p+1$）就足够了。我们按照建议保守地选择 $N_q = p+2$。\n\n**边界项**：此项使用所提供的基函数及其在边界 $x=0$（$\\xi=-1$）和 $x=1$（$\\xi=1$）处的导数公式进行解析计算。\n$$\nA_{ij}^{\\text{bnd}} = -\\phi_j'(1)\\phi_i(1) + \\phi_j'(0)\\phi_i(0) - \\phi_i'(1)\\phi_j(1) + \\phi_i'(0)\\phi_j(0) + \\sigma(\\phi_j(1)\\phi_i(1) + \\phi_j(0)\\phi_i(0))\n$$\n代入给定值 $\\phi_k(1)=1$, $\\phi_k(0)=(-1)^k$, $\\phi_k'(1)=k(k+1)$ 和 $\\phi_k'(0)=(-1)^{k+1}k(k+1)$：\n$$\nA_{ij}^{\\text{bnd}} = -j(j+1) + (-1)^{i+j+1}j(j+1) - i(i+1) + (-1)^{i+j+1}i(i+1) + \\sigma(1+(-1)^{i+j})\n$$\n$$\nA_{ij}^{\\text{bnd}} = (i(i+1)+j(j+1))((-1)^{i+j+1}-1) + \\sigma(1+(-1)^{i+j})\n$$\n\n### 3. p-多重网格算子\n对于一个细层级阶数 $p_f$ 和一个粗层级阶数 $p_c  p_f$：\n- **细层级算子**为 $A_f = A(p_f; \\gamma p_f^2)$。\n- **伽辽金粗算子** $A_c^G$ 是通过将 $A_f$ 投影到粗空间上得到的。由于基是分层的（一个 $p_c$ 阶的勒让德基是 $p_f$ 阶勒让德基的子集），延拓算子 $P$ 是一个典范注入。因此，$A_c^G = P^T A_f P$ 对应于取 $A_f$ 的前导 $(p_c+1) \\times (p_c+1)$ 子矩阵。\n- **组装的粗算子**为 $A_c^{\\text{ass}}(p_{\\text{scale}}) = A(p_c; \\gamma p_{\\text{scale}}^2)$，其中 $p_{\\text{scale}}$ 可以是 $p_c$ 或 $p_f$。\n\n**不匹配算子**是差值 $\\Delta = A_c^{\\text{ass}} - A_c^G$。\n\n### 4. 误差度量\n- **相对算子范数误差**：$E_{\\text{op}} = \\|\\Delta\\|_2 / \\|A_c^G\\|_2$。谱范数 $\\|\\cdot\\|_2$ 使用标准数值线性代数程序计算。\n- **能量瑞利不匹配**：$E_v = |v^T \\Delta v| / |v^T A_c^G v|$。向量 $v$ 包含 $u(x)=x(1-x)$ 到阶数为 $p_c$ 的粗多项式空间上的 $L^2$-投影的系数。该投影通过求解 $Mc=b$ 得到，其中 $M_{ij}=\\int_0^1 \\phi_i\\phi_j dx$ 且 $b_i=\\int_0^1 u(x)\\phi_i(x) dx$。由于勒让德多项式的正交性，质量矩阵 $M$ 是对角的，其元素为 $M_{ii}=\\frac{1}{2i+1}$。载荷向量 $b$ 只有两个非零项，$b_0=1/6$ 和 $b_2=-1/30$。这给出了系数 $c_0=1/6$，$c_2=-1/6$，以及对于 $k\\neq 0,2$ 的 $c_k=0$。因此，向量 $v$ 是由这些系数构建的，最高阶数到 $p_c$。\n- **对称正定性 (SPD) 指示符**：如果组装粗算子的对称部分 $\\frac{1}{2}(A_c^{\\text{ass}} + (A_c^{\\text{ass}})^\\top)$ 的所有特征值都严格为正，则为 `True`，否则为 `False`。这通过计算特征值并验证它们都大于一个小的数值容差来检查。\n\n每个测试用例的计算都遵循这些步骤执行。浮点数结果按要求四舍五入到八位小数。", "answer": "```python\nimport numpy as np\n\ndef legendre_and_deriv_values(p_max, xi):\n    \"\"\"\n    Computes values of Legendre polynomials L_k and derivatives L_k'\n    for k = 0 to p_max at given points xi in [-1, 1].\n    Uses stable recurrence relations.\n    \"\"\"\n    if p_max  0:\n        return np.array([[]]), np.array([[]])\n\n    xi = np.asarray(xi)\n    n_pts = len(xi) if xi.ndim > 0 else 1\n    xi = xi.reshape(n_pts)\n\n    L = np.zeros((n_pts, p_max + 1))\n    Lp = np.zeros((n_pts, p_max + 1))\n\n    L[:, 0] = 1.0\n    # Lp[:, 0] is already 0.0\n\n    if p_max > 0:\n        L[:, 1] = xi\n        Lp[:, 1] = 1.0\n\n    for k in range(1, p_max):\n        # Recurrence for L_k\n        L[:, k + 1] = ((2 * k + 1) * xi * L[:, k] - k * L[:, k - 1]) / (k + 1)\n        # Recurrence for L_k'\n        Lp[:, k + 1] = (2 * k + 1) * L[:, k] + Lp[:, k - 1]\n\n    return L, Lp\n\ndef assemble_matrix(p, sigma):\n    \"\"\"\n    Assembles the DG matrix A(p; sigma) for the 1D Poisson problem.\n    \"\"\"\n    n_dof = p + 1\n    A = np.zeros((n_dof, n_dof))\n\n    # Volume term assembly using Gauss-Legendre quadrature\n    if p >= 0:\n        n_quad = p + 2\n        xi_q, w_q = np.polynomial.legendre.leggauss(n_quad)\n        _, Lp_vals = legendre_and_deriv_values(p, xi_q)\n        A_vol = 2 * (Lp_vals.T * w_q) @ Lp_vals\n        A += A_vol\n\n    # Boundary term assembly\n    if p >= 0:\n        iv, jv = np.ogrid[0:n_dof, 0:n_dof]\n        i_plus_j = iv + jv\n        \n        term1_factor = (iv * (iv + 1) + jv * (jv + 1))\n        term1 = term1_factor * (np.power(-1.0, i_plus_j + 1) - 1)\n        \n        term2 = sigma * (1 + np.power(-1.0, i_plus_j))\n        \n        A_bnd = term1 + term2\n        A += A_bnd\n            \n    return A\n\ndef project_u(p_c):\n    \"\"\"\n    Computes the L2 projection of u(x)=x(1-x) onto the polynomial space of degree p_c.\n    Returns the coefficient vector v.\n    \"\"\"\n    n_dof = p_c + 1\n    c = np.zeros(n_dof)\n    if p_c >= 0:\n        c[0] = 1.0 / 6.0\n    if p_c >= 2:\n        c[2] = -1.0 / 6.0\n    return c\n\ndef solve():\n    test_cases = [\n        (6, 2, 10, \"pc\"),\n        (8, 4, 0.01, \"pc\"),\n        (4, 3, 10, \"pf\"),\n        (6, 0, 10, \"pc\"),\n        (10, 2, 100, \"pc\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        pf, pc, gamma, pscale_choice = case\n\n        # 1. Fine operator\n        sigma_f = gamma * pf**2\n        A_f = assemble_matrix(pf, sigma_f)\n\n        # 2. Galerkin coarse operator\n        Ac_G = A_f[0:pc + 1, 0:pc + 1]\n\n        # 3. Assembled coarse operator\n        if pscale_choice == \"pc\":\n            pscale = pc\n        else: # \"pf\"\n            pscale = pf\n        \n        sigma_c = gamma * pscale**2\n        Ac_ass = assemble_matrix(pc, sigma_c)\n\n        # 4. Mismatch operator\n        Delta = Ac_ass - Ac_G\n\n        # 5. Compute E_op\n        norm_Delta = np.linalg.norm(Delta, ord=2)\n        norm_Ac_G = np.linalg.norm(Ac_G, ord=2)\n        E_op = norm_Delta / norm_Ac_G if norm_Ac_G > 1e-14 else 0.0\n\n        # 6. Compute E_v\n        v = project_u(pc)\n        num_Ev = np.abs(v @ Delta @ v)\n        den_Ev = np.abs(v @ Ac_G @ v)\n        E_v = num_Ev / den_Ev if den_Ev > 1e-14 else 0.0\n        \n        # 7. Compute SPD indicator\n        is_spd = False\n        if Ac_ass.shape[0] > 0:\n            A_sym = 0.5 * (Ac_ass + Ac_ass.T)\n            try:\n                eigenvalues = np.linalg.eigvalsh(A_sym)\n                # Check if all eigenvalues are strictly positive\n                if np.all(eigenvalues > 1e-14):\n                    is_spd = True\n            except np.linalg.LinAlgError:\n                is_spd = False\n\n        result_tuple = [round(E_op, 8), round(E_v, 8), is_spd]\n        results.append(result_tuple)\n\n    # Format the final output string\n    # Using str() on a list is consistent and sufficient\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n    print(final_output_str.replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3401554"}]}