{"hands_on_practices": [{"introduction": "在为非线性偏微分方程构建降阶模型时，一个核心挑战是如何稳定地处理非线性项。本实践将通过经典的伯格斯方程（Burgers' equation）探讨伽辽金投影（Galerkin projection）中出现的混叠（aliasing）误差问题。你将亲手实现并对比标准投影与采用反混叠（anti-aliasing）技术的投影，从而深刻理解后者对于确保降阶模型长期稳定性的重要性。[@problem_id:3412065]", "problem": "考虑具有参数相关黏度的一维黏性伯格斯方程，\n$$\nu_t(x,t;\\mu) + u(x,t;\\mu)\\,u_x(x,t;\\mu) = \\nu(\\mu)\\,u_{xx}(x,t;\\mu), \\quad x \\in [0,2\\pi], \\quad t \\geq 0,\n$$\n该方程满足周期性边界条件和一个光滑的周期性初始条件。域是周期性的，周期为 $2\\pi$。黏度由仿射映射 $\\nu(\\mu) = 0.01 + 0.04\\,\\mu$ 给出，其中参数 $\\mu \\in [0,1]$。所有角度均以弧度为单位。除了隐式采用的无量纲长度尺度外，没有其他物理单位。\n\n目标是研究和量化多项式混叠误差对由谱配置快照构建的降阶模型（ROM）稳定性的影响，并实施一种抗混叠 ROM 投影来减轻这些误差。研究应从第一性原理出发，并且仅使用谱方法和模型降阶领域公认的数值实践。\n\n使用的基本基础和定义：\n- 在 $[0,2\\pi]$ 上的 $N$ 个点的均匀网格上，使用三角多项式进行周期性谱配置。导数通过傅里叶微分计算，即将傅里叶系数乘以 $i k$ 以求一阶导数，乘以 $-k^2$ 以求二阶导数，其中 $k$ 表示与周期域相关的整数波数。\n- 对流项的守恒形式：$u_t + \\tfrac{1}{2}\\partial_x(u^2) = \\nu u_{xx}$，在无黏情况下，若离散化无混叠误差，则该形式是能量守恒的。\n- $L^2$ 内积 $\\langle f, g \\rangle = \\int_0^{2\\pi} f(x)g(x)\\,dx$，在均匀网格上通过梯形法则近似，该方法对于周期性光滑函数具有谱精度。\n- 使用离散 $L^2$ 内积的本征正交分解（POD），通过对由求积权重平方根加权的快照矩阵进行奇异值分解（SVD）获得。\n- 针对二次非线性项的 $3/2$ 规则去混叠策略：在一个具有 $N_{\\text{pad}} = \\tfrac{3}{2}N$ 个配置点的填充网格上（通过在傅里叶空间中进行零填充）计算乘积，在那里计算非线性项，然后截断回原始分辨率。\n\n构建任务：\n1. 全阶快照生成：\n   - 使用具有 $N=64$ 个网格点的傅里叶谱配置方法，将全阶模型从 $t=0$ 演化到 $t=T_{\\text{train}}=0.5$，时间步长为 $\\Delta t = 10^{-3}$。\n   - 使用一阶隐式-显式（IMEX）时间离散化：在傅里叶空间中，显式处理 $\\tfrac{1}{2}\\partial_x(u^2)$，隐式处理扩散项 $\\nu u_{xx}$。使用 $3/2$ 规则去混叠计算守恒形式的非线性对流项。\n   - 使用初始条件 $u(x,0) = \\sin(x) + \\tfrac{1}{2}\\sin(2x)$。\n   - 为一小组参数值 $\\mu \\in \\{0.2, 0.8\\}$ 生成训练快照。在每次训练参数的积分过程中，以均匀的时间间隔存储快照。\n\n2. 通过本征正交分解（POD）获得降阶基：\n   - 从所有训练快照中组装快照矩阵 $S \\in \\mathbb{R}^{N \\times m}$。\n   - 令 $W = \\Delta x\\,I$ 为梯形法则的对角质量矩阵，其中 $\\Delta x = 2\\pi/N$。\n   - 形成加权快照矩阵 $S_w = W^{1/2} S = \\sqrt{\\Delta x}\\,S$，计算其奇异值分解 $S_w = U \\Sigma V^\\top$，并将（关于离散 $L^2$ 内积的）标准正交基设为 $\\Phi = W^{-1/2}U = \\tfrac{1}{\\sqrt{\\Delta x}} U$。\n   - 根据每个测试用例的需要，使用 $\\Phi$ 的前 $r$ 列来定义维度为 $r$ 的降阶基。\n\n3. ROM 算子和混叠：\n   - 对于一个降阶基 $\\{\\phi_j(x)\\}_{j=1}^r$（$\\Phi$ 的列），定义线性扩散算子 $K \\in \\mathbb{R}^{r \\times r}$，其元素为 $K_{ij} = \\langle \\phi_i, \\partial_{xx}\\phi_j \\rangle$。\n   - 定义一个三阶张量 $T \\in \\mathbb{R}^{r \\times r \\times r}$，它以守恒形式编码二次非线性，其元素为\n     $$\n     T_{ijk} = \\langle \\phi_i, \\partial_x(\\phi_j \\phi_k) \\rangle.\n     $$\n   - 构建 $T$ 的两个版本：\n     - 混叠张量 $T^{\\text{alias}}$：通过在原始 $N$ 点网格上计算乘积 $\\phi_j \\phi_k$ 及其空间导数来得到，不进行填充。\n     - 抗混叠张量 $T^{\\text{deal}}$：通过在大小为 $N_{\\text{pad}} = \\tfrac{3}{2}N$ 的零填充网格上，使用傅里叶零填充和填充网格上的梯形法则来计算 $\\phi_j \\phi_k$ 及其导数，然后使用这些值计算内积。\n\n4. 参数相关的 ROM：\n   - 对于给定的参数 $\\mu$，定义黏度 $\\nu(\\mu) = 0.01 + 0.04\\mu$。\n   - 降阶状态为 $a(t) \\in \\mathbb{R}^r$，初始条件为 $a(0) = \\Phi^\\top W u_0$，其中 $u_0(x)$ 是上面定义的初始条件。\n   - ROM 常微分方程为\n     $$\n     \\dot{a}_i(t;\\mu) = -\\tfrac{1}{2}\\sum_{j=1}^r \\sum_{k=1}^r T_{ijk} a_j(t;\\mu)a_k(t;\\mu) + \\nu(\\mu)\\sum_{j=1}^r K_{ij} a_j(t;\\mu), \\quad i=1,\\dots,r.\n     $$\n   - 使用经典的显式四阶龙格-库塔方法，以固定的时间步长 $\\Delta t_{\\text{rom}} = 10^{-3}$，将 ROM 从 $t=0$ 积分到 $t=T_{\\text{rom}}=0.5$。\n\n5. 稳定性度量：\n   - 由于 $\\Phi$ 在离散 $L^2$ 内积中是标准正交的，因此降阶动能为 $E(t) = \\tfrac{1}{2}\\|a(t)\\|_2^2$。\n   - 对于每次 ROM 积分，计算能量增长因子\n     $$\n     G = \\max_{0 \\le t \\le T_{\\text{rom}}} \\frac{E(t)}{E(0)}.\n     $$\n   - 对于相同的参数和初始条件，使用 $T^{\\text{alias}}$ 计算 $G^{\\text{alias}}$，使用 $T^{\\text{deal}}$ 计算 $G^{\\text{deal}}$，并报告两者以及差值 $G^{\\text{alias}} - G^{\\text{deal}}$。\n\n测试套件和要求的输出：\n- 使用以下测试用例，每个测试用例是一个对 $(\\mu, r)$：\n  1. $(0.0, 6)$\n  2. $(0.5, 6)$\n  3. $(1.0, 6)$\n  4. $(0.2, 4)$\n- 对于每个测试用例，按此顺序计算并返回三个浮点数：$G^{\\text{alias}}$、$G^{\\text{deal}}$ 和 $G^{\\text{alias}} - G^{\\text{deal}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3,...]”）。该列表必须按照上面给出的顺序连接每个测试用例的三个浮点数。\n\n所有数值必须由您的程序计算。角度以弧度为单位。没有其他单位需要报告。最终输出格式必须与指定的单行方括号逗号分隔列表完全匹配。", "solution": "该问题经过验证，被认为是科学上合理、适定且客观的。它概述了为参数化偏微分方程（PDE）构建和评估降阶模型（ROM）的标准流程，特别关注由谱方法中的混叠误差引起的数值稳定性问题。所有定义和任务都是形式化的，并且在计算上是可验证的。关于要存储的快照数量的一个次要模糊之处，通过做出标准假设，即在全阶模型（FOM）模拟的每个时间步都存储一个快照来解决，这是对“以均匀的时间间隔”存储快照这一指令的合理解释。\n\n解决方案通过实施指定的数值工作流程来推进。这包括四个主要阶段：\n1.  使用全阶模型（FOM）生成高保真快照数据。\n2.  使用本征正交分解（POD）构建低维基。\n3.  将控制方程投影到降阶基上以创建 ROM 算子，包括使用和不使用抗混叠策略的两种情况。\n4.  对得到的 ROM 进行时间积分并评估其稳定性。\n\n**1. 用于快照生成的全阶模型（FOM）模拟**\n\n控制方程是在周期域 $x \\in [0, 2\\pi]$ 上的守恒形式的黏性伯格斯方程：\n$$\nu_t + \\frac{1}{2}\\frac{\\partial}{\\partial x}(u^2) = \\nu(\\mu) u_{xx}\n$$\n其中黏度 $\\nu(\\mu) = 0.01 + 0.04\\mu$ 取决于参数 $\\mu \\in [0, 1]$。我们使用傅里叶谱配置方法在 $N=64$ 个点的均匀网格上对该方程进行空间离散化，网格间距为 $\\Delta x = 2\\pi/N$。空间导数在傅里叶空间中高效计算。设 $\\mathcal{F}$ 表示快速傅里叶变换（FFT），$\\mathcal{F}^{-1}$ 表示其逆变换。网格函数 $f(x)$ 的一阶和二阶导数计算如下：\n$$\nf_x(x) = \\mathcal{F}^{-1}\\{ ik \\cdot \\mathcal{F}\\{f(x)\\} \\}\n$$\n$$\nf_{xx}(x) = \\mathcal{F}^{-1}\\{ -k^2 \\cdot \\mathcal{F}\\{f(x)\\} \\}\n$$\n其中 $k$ 是对应于网格的整数波数，$k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$。\n\n时间积分使用一阶隐式-显式（IMEX）欧拉格式，从 $t=0$ 到 $T_{\\text{train}}=0.5$，时间步长为 $\\Delta t = 10^{-3}$。非线性对流项 $\\mathcal{N}(u) = -\\frac{1}{2}\\partial_x(u^2)$ 被显式处理，而线性扩散项 $\\mathcal{L}(u) = \\nu(\\mu)u_{xx}$ 被隐式处理。傅里叶空间中系数 $\\hat{u}(k,t)$ 的半离散化方程为：\n$$\n\\frac{d\\hat{u}}{dt} = \\hat{\\mathcal{N}}(u) - \\nu(\\mu)k^2\\hat{u}\n$$\nIMEX-欧拉更新规则是：\n$$\n\\frac{\\hat{u}^{n+1} - \\hat{u}^n}{\\Delta t} = \\hat{\\mathcal{N}}(u^n) - \\nu(\\mu)k^2\\hat{u}^{n+1}\n$$\n解出 $\\hat{u}^{n+1}$ 得到稳定且高效的更新公式：\n$$\n\\hat{u}^{n+1} = \\frac{\\hat{u}^n + \\Delta t \\cdot \\hat{\\mathcal{N}}(u^n)}{1 + \\Delta t \\cdot \\nu(\\mu)k^2}\n$$\n为防止二次非线性项 $u^2$ 产生混叠误差，项 $\\mathcal{N}(u^n)$ 使用 $3/2$ 规则计算。这涉及将傅里叶系数 $\\hat{u}^n$ 零填充到一个更大的网格尺寸 $N_{\\text{pad}} = \\frac{3}{2}N = 96$，变换到填充后的物理空间，计算乘积 $u^2$，再变换回填充后的傅里叶空间，计算导数，最后将得到的傅里叶系数截断回原始尺寸 $N$。\n\n对于两个训练参数 $\\mu \\in \\{0.2, 0.8\\}$，从初始条件 $u(x,0) = \\sin(x) + \\frac{1}{2}\\sin(2x)$ 开始，在每个时间步收集解 $u(x, t_i)$ 的快照。这总共产生 $m = 2 \\times (T_{\\text{train}}/\\Delta t + 1) = 1002$ 个快照，它们被组装成一个单一的快照矩阵 $S \\in \\mathbb{R}^{N \\times m}$。\n\n**2. 通过本征正交分解（POD）获得降阶基**\n\nPOD 的目标是找到一个最优的低维基，以捕获快照集中的最大能量（方差）。基向量 $\\{\\phi_j\\}$ 需要相对于离散 $L^2$ 内积是标准正交的，该内积在周期域上通过谱精度的梯形法则近似：$\\langle f, g \\rangle \\approx \\sum_{i=0}^{N-1} f(x_i)g(x_i)\\Delta x = g^T W f$，其中 $W = \\Delta x \\cdot I$ 是质量矩阵。\n\n为了找到这个基，我们对加权快照矩阵 $S_w = W^{1/2}S = \\sqrt{\\Delta x}S$ 进行奇异值分解（SVD）：\n$$\nS_w = U\\Sigma V^T\n$$\n$U$ 的列在标准欧几里得内积下是标准正交的。所期望的 POD 基 $\\Phi$ 则由 $\\Phi = W^{-1/2}U = \\frac{1}{\\sqrt{\\Delta x}}U$ 给出。$\\Phi$ 的列相对于 $W$ 加权内积是标准正交的，即 $\\Phi^T W \\Phi = I$。基向量按奇异值排序，因此 $\\Phi$ 的前 $r$ 列构成了最优的秩-$r$ 基，记为 $\\Phi_r \\in \\mathbb{R}^{N \\times r}$。\n\n**3. 降阶模型（ROM）构建**\n\nROM 是通过将解近似为前 $r$ 个基向量的线性组合 $u(x,t) \\approx u_{\\text{rom}}(x,t) = \\sum_{j=1}^r a_j(t)\\phi_j(x) = \\Phi_r a(t)$，并应用伽辽金投影到该基所张成的空间上来推导的。这将 PDE 转换为一个关于系数 $a(t)$ 的 $r$ 个常微分方程（ODE）系统：\n$$\n\\dot{a}_i(t) = \\langle \\phi_i, -\\tfrac{1}{2}\\partial_x(u_{\\text{rom}}^2) + \\nu u_{\\text{rom,xx}} \\rangle, \\quad i=1,\\dots,r.\n$$\n代入 $u_{\\text{rom}} = \\Phi_r a$ 并利用线性性质，得到 ROM 系统：\n$$\n\\dot{a}_i(t) = -\\frac{1}{2} \\sum_{j=1}^r \\sum_{k=1}^r T_{ijk} a_j(t)a_k(t) + \\nu \\sum_{j=1}^r K_{ij} a_j(t)\n$$\n常系数张量（算子）是预先计算的：\n-   **线性（扩散）算子 $K \\in \\mathbb{R}^{r \\times r}$：** $K_{ij} = \\langle \\phi_i, \\partial_{xx}\\phi_j \\rangle = \\phi_i^T W (\\partial_{xx}\\phi_j)$。这是通过对每个基向量 $\\phi_j$ 应用谱二阶导数，然后与每个 $\\phi_i$ 取离散内积来计算的。\n-   **非线性（对流）算子 $T \\in \\mathbb{R}^{r \\times r \\times r}$：** $T_{ijk} = \\langle \\phi_i, \\partial_x(\\phi_j \\phi_k) \\rangle$。我们构建这个张量的两个版本：\n    1.  **混叠张量 ($T^{\\text{alias}}$)：** 乘积 $\\phi_j(x)\\phi_k(x)$ 及其导数直接在大小为 $N=64$ 的粗网格上计算。内积也在此网格上评估。此过程引入了混叠误差，可能人为地向系统注入能量并导致不稳定。\n    2.  **抗混叠张量 ($T^{\\text{deal}}$)：** 为减轻混叠，乘积和导数使用 $3/2$ 规则计算。对于每对 $(\\phi_j, \\phi_k)$，它们在大小为 $N_{\\text{pad}}=96$ 的填充网格上对应的函数通过在傅里叶空间中进行零填充来计算。乘积 $\\phi_j\\phi_k$ 及其导数 $\\partial_x(\\phi_j\\phi_k)$ 在此填充网格上计算。然后，与 $\\phi_i$（也在填充网格上表示）的内积使用填充网格上的梯形法则计算。此过程正确地捕捉了非线性相互作用而没有混叠。\n\n**4. ROM 模拟和稳定性分析**\n\n对于每个测试用例 $(\\mu, r)$，我们使用显式四阶龙格-库塔（RK4）格式，以时间步长 $\\Delta t_{\\text{rom}} = 10^{-3}$，将相应的 ROM ODE 系统从 $t=0$ 求解到 $T_{\\text{rom}}=0.5$。ROM 的初始条件是通过将全阶初始条件投影到基上获得的：$a(0) = \\Phi_r^T W u_0$。\n\n为量化混叠 ROM 与抗混叠 ROM 的稳定性，我们监控离散动能的演变，$E(t) = \\frac{1}{2}\\|a(t)\\|_2^2$。稳定性度量是能量增长因子 $G$，定义为模拟期间达到的最大能量与初始能量之比：\n$$\nG = \\frac{\\max_{0 \\le t \\le T_{\\text{rom}}} E(t)}{E(0)}\n$$\n我们使用带张量 $T^{\\text{alias}}$ 的 ROM 计算 $G^{\\text{alias}}$，使用带张量 $T^{\\text{deal}}$ 的 ROM 计算 $G^{\\text{deal}}$。差值 $G^{\\text{alias}} - G^{\\text{deal}}$ 衡量了混叠误差的失稳效应。对所有指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the entire ROM creation and evaluation process.\n    \"\"\"\n\n    # -- 1. Full-Order Model (FOM) Snapshot Generation --\n\n    # Simulation parameters\n    N = 64\n    T_train = 0.5\n    dt = 1e-3\n    x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    k = np.fft.fftfreq(N) * N\n\n    # Fourier derivative operators\n    D1_k = 1j * k\n    D2_k = -k**2\n\n    # Dealiasing parameters\n    N_pad = int(1.5 * N)\n    k_pad = np.fft.fftfreq(N_pad) * N_pad\n    D1_k_pad = 1j * k_pad\n    \n    def pad_fft(f_hat, N, N_pad):\n        f_hat_padded = np.zeros(N_pad, dtype=np.complex128)\n        N_half = N // 2\n        f_hat_padded[0:N_half] = f_hat[0:N_half]\n        f_hat_padded[-N_half:] = f_hat[-N_half:]\n        return f_hat_padded\n\n    def truncate_fft(f_hat_padded, N, N_pad):\n        f_hat_trunc = np.zeros(N, dtype=np.complex128)\n        N_half = N // 2\n        f_hat_trunc[0:N_half] = f_hat_padded[0:N_half]\n        f_hat_trunc[-N_half:] = f_hat_padded[-N_half:]\n        return f_hat_trunc\n\n    def fom_nonlinear_term(u, N, N_pad, D1_k_pad):\n        u_hat = np.fft.fft(u)\n        u_hat_padded = pad_fft(u_hat, N, N_pad)\n        u_padded = np.fft.ifft(u_hat_padded)\n        \n        u2_padded = u_padded**2\n        u2_hat_padded = np.fft.fft(u2_padded)\n        \n        du2_hat_padded = D1_k_pad * u2_hat_padded\n        \n        # Conservative form: -0.5 * d/dx(u^2)\n        F_hat_padded = -0.5 * du2_hat_padded\n        \n        # Truncate back to original size\n        F_hat = truncate_fft(F_hat_padded, N, N_pad)\n        return F_hat\n\n    # Initial condition\n    u0 = np.sin(x) + 0.5 * np.sin(2 * x)\n\n    snapshots = []\n    mu_train_set = [0.2, 0.8]\n    n_steps = int(T_train / dt)\n\n    for mu_train in mu_train_set:\n        nu = 0.01 + 0.04 * mu_train\n        u = u0.copy()\n        \n        u_hat = np.fft.fft(u)\n        snapshots.append(u.copy())\n        \n        imex_denominator = 1.0 - dt * nu * D2_k\n\n        for _ in range(n_steps):\n            F_hat = fom_nonlinear_term(u, N, N_pad, D1_k_pad)\n            u_hat_new = (u_hat + dt * F_hat) / imex_denominator\n            u_hat = u_hat_new\n            u = np.real(np.fft.ifft(u_hat))\n            snapshots.append(u.copy())\n\n    S = np.array(snapshots).T  # Shape: (N, m)\n\n    # -- 2. Reduced Basis via Proper Orthogonal Decomposition (POD) --\n    \n    dx = 2 * np.pi / N\n    S_w = np.sqrt(dx) * S\n    U, _, _ = svd(S_w, full_matrices=False)\n    Phi = U / np.sqrt(dx)\n\n    # -- 3. ROM Operator Construction --\n\n    # Shared across testcases, precompute for max r needed\n    r_max = 6\n    Phi_r_max = Phi[:, :r_max]\n\n    # Linear operator K\n    Phi_r_max_hat = np.fft.fft(Phi_r_max, axis=0)\n    d2Phi_r_max_hat = D2_k[:, np.newaxis] * Phi_r_max_hat\n    d2Phi_r_max = np.real(np.fft.ifft(d2Phi_r_max_hat, axis=0))\n    K_max = dx * Phi_r_max.T @ d2Phi_r_max\n\n    # Nonlinear tensors T_alias and T_deal\n    \n    # Precompute padded basis functions for T_deal\n    Phi_r_max_hat_padded = np.zeros((N_pad, r_max), dtype=np.complex128)\n    for i in range(r_max):\n        Phi_r_max_hat_padded[:, i] = pad_fft(Phi_r_max_hat[:, i], N, N_pad)\n    Phi_r_max_pad = np.real(np.fft.ifft(Phi_r_max_hat_padded, axis=0))\n    dx_pad = 2 * np.pi / N_pad\n    \n    T_alias_max = np.zeros((r_max, r_max, r_max))\n    T_deal_max = np.zeros((r_max, r_max, r_max))\n\n    for j in range(r_max):\n        for k in range(j, r_max):\n            phi_j = Phi_r_max[:, j]\n            phi_k = Phi_r_max[:, k]\n\n            # Aliased tensor\n            prod_alias = phi_j * phi_k\n            d_prod_alias_hat = D1_k * np.fft.fft(prod_alias)\n            d_prod_alias = np.real(np.fft.ifft(d_prod_alias_hat))\n            T_col_alias = dx * Phi_r_max.T @ d_prod_alias\n            T_alias_max[:, j, k] = T_col_alias\n            T_alias_max[:, k, j] = T_col_alias\n            \n            # Dealiased tensor\n            phi_j_pad = Phi_r_max_pad[:, j]\n            phi_k_pad = Phi_r_max_pad[:, k]\n            prod_deal = phi_j_pad * phi_k_pad\n            d_prod_deal_hat = D1_k_pad * np.fft.fft(prod_deal)\n            d_prod_deal = np.real(np.fft.ifft(d_prod_deal_hat))\n            T_col_deal = dx_pad * Phi_r_max_pad.T @ d_prod_deal\n            T_deal_max[:, j, k] = T_col_deal\n            T_deal_max[:, k, j] = T_col_deal\n            \n    # -- 4. ROM Simulation and Stability Metric Calculation --\n\n    def rom_rhs(a, K, T, nu):\n        nonlinear_term = -0.5 * np.einsum('ijk,j,k->i', T, a, a)\n        linear_term = nu * (K @ a)\n        return nonlinear_term + linear_term\n\n    def run_rom_simulation(a0, K, T, nu, T_rom, dt_rom):\n        a = a0.copy()\n        \n        E0 = 0.5 * np.sum(a**2)\n        if E0 == 0: return 1.0 # Avoid division by zero\n        max_E = E0\n        \n        n_steps_rom = int(T_rom / dt_rom)\n        \n        for _ in range(n_steps_rom):\n            # RK4 integrator\n            k1 = rom_rhs(a, K, T, nu)\n            k2 = rom_rhs(a + 0.5 * dt_rom * k1, K, T, nu)\n            k3 = rom_rhs(a + 0.5 * dt_rom * k2, K, T, nu)\n            k4 = rom_rhs(a + dt_rom * k3, K, T, nu)\n            a += (dt_rom / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n            \n            E_current = 0.5 * np.sum(a**2)\n            if E_current > max_E:\n                max_E = E_current\n        \n        return max_E / E0\n\n    test_cases = [\n        (0.0, 6),\n        (0.5, 6),\n        (1.0, 6),\n        (0.2, 4),\n    ]\n    \n    T_rom = 0.5\n    dt_rom = 1e-3\n    results = []\n\n    for mu, r in test_cases:\n        Phi_r = Phi_r_max[:, :r]\n        K = K_max[:r, :r]\n        T_alias = T_alias_max[:r, :r, :r]\n        T_deal = T_deal_max[:r, :r, :r]\n\n        a0 = dx * Phi_r.T @ u0\n        nu_test = 0.01 + 0.04 * mu\n\n        G_alias = run_rom_simulation(a0, K, T_alias, nu_test, T_rom, dt_rom)\n        G_deal = run_rom_simulation(a0, K, T_deal, nu_test, T_rom, dt_rom)\n\n        results.append(G_alias)\n        results.append(G_deal)\n        results.append(G_alias - G_deal)\n\n    print(f\"[{','.join(f'{val:.8f}' for val in results)}]\")\n\nsolve()\n```", "id": "3412065"}, {"introduction": "一个高效的降阶模型很大程度上依赖于其降阶基的质量，而这又取决于我们如何选择用于生成快照的训练参数。本实践将引导你设计一个基于后验误差估计的自适应采样算法。你将实现一个“贪心”策略，它能自动识别并加密误差较大的参数区域，从而用最少的计算资源构建出一个在整个参数域上都足够精确的降阶基。[@problem_id:3412109]", "problem": "考虑在区间 $[0,1]$ 上带齐次狄利克雷边界条件的参数化边值问题：对于参数 $\\mu \\in [\\mu_{\\min}, \\mu_{\\max}]$，求 $u(\\cdot;\\mu)$ 使得\n$$\n-a(\\mu)\\,\\frac{d^2 u}{dx^2} + b(\\mu)\\,u = f(x), \\quad x \\in (0,1), \\quad u(0;\\mu)=u(1;\\mu)=0,\n$$\n其中 $a(\\mu)$ 和 $b(\\mu)$ 是参数 $\\mu$ 的正标量函数，而 $f(x)$ 是给定的确定性强迫函数。其弱（变分）形式为：求 $u(\\cdot;\\mu) \\in H_0^1(0,1)$ 使得对于所有测试函数 $v \\in H_0^1(0,1)$，\n$$\na(\\mu)\\int_0^1 \\frac{du}{dx}\\frac{dv}{dx}\\,dx + b(\\mu)\\int_0^1 u\\,v\\,dx = \\int_0^1 f\\,v\\,dx.\n$$\n\n使用傅里叶正弦基 $\\{\\phi_k(x)\\}_{k=1}^N$（其中 $\\phi_k(x) = \\sin(k\\pi x)$）的谱伽辽金近似产生一个截断级数表示\n$$\nu_N(x;\\mu) = \\sum_{k=1}^N c_k(\\mu)\\,\\phi_k(x).\n$$\n由于正交性 $\\int_0^1 \\phi_i'(x)\\,\\phi_j'(x)\\,dx = \\frac{(i\\pi)^2}{2}\\,\\delta_{ij}$ 和 $\\int_0^1 \\phi_i(x)\\,\\phi_j(x)\\,dx = \\frac{1}{2}\\,\\delta_{ij}$（其中 $\\delta_{ij}$ 是克罗内克δ），伽辽金方程解耦。记 $S_{ij} = \\int_0^1 \\phi_i'(x)\\,\\phi_j'(x)\\,dx$ 和 $M_{ij} = \\int_0^1 \\phi_i(x)\\,\\phi_j(x)\\,dx$，离散算子为\n$$\nK(\\mu) = a(\\mu)\\,S + b(\\mu)\\,M,\n$$\n该算子是对角阵，其对角元为 $K_{kk}(\\mu) = \\frac{a(\\mu)\\,(k\\pi)^2 + b(\\mu)}{2}$。载荷系数 $f_k = \\int_0^1 f(x)\\,\\phi_k(x)\\,dx$ 定义了谱坐标系下的右端项。\n\n对于降阶建模，我们考虑降阶基（RB）方法。令 $\\mathcal{T} \\subset [\\mu_{\\min}, \\mu_{\\max}]$ 为一个参数训练集。对于每个 $\\mu_i \\in \\mathcal{T}$，通过求解 $K(\\mu_i)\\,u_N(\\mu_i) = f$ 计算谱真值系数 $u_N(\\mu_i)$。收集这些快照向量并构建一个RB空间 $V_r = \\mathrm{span}\\{u_N(\\mu_i): \\mu_i \\in \\mathcal{T}\\}$，该空间在一个内积（为具体起见，采用 $\\mathbb{R}^N$ 上的欧几里得内积）下是正交规范化的。对于一个新参数 $\\mu$，RB近似解 $u_r(\\mu) \\in V_r$ 通过求解降阶系统得到\n$$\nK_r(\\mu)\\,c_r(\\mu) = f_r, \\quad \\text{其中 } K_r(\\mu) = V^\\top K(\\mu)\\,V, \\quad f_r = V^\\top f,\n$$\n并通过提升 $u_r(\\mu) = V\\,c_r(\\mu)$ 得到，其中 $V \\in \\mathbb{R}^{N \\times r}$ 的列是构成 $V_r$ 的正交规范基。\n\n可以从残差 $r(\\mu) = f - K(\\mu)\\,u_r(\\mu)$ 推导出一个后验误差估计器。使用由与 $K(\\mu)$ 相关的能量内积导出的对偶范数，该估计器为\n$$\n\\eta(\\mu) = \\|r(\\mu)\\|_{K(\\mu)^{-1}} = \\sqrt{r(\\mu)^\\top K(\\mu)^{-1} r(\\mu)},\n$$\n由于 $K(\\mu)$ 是对称正定的，该式是可计算的。对于这里考虑的对角阵 $K(\\mu)$，$K(\\mu)^{-1}$ 是对角的，估计器简化为\n$$\n\\eta(\\mu) = \\sqrt{\\sum_{k=1}^N \\frac{r_k(\\mu)^2}{K_{kk}(\\mu)}}.\n$$\n\n您的任务是设计并实现一个自适应采样策略，该策略基于误差估计驱动的参数区域聚类来优化训练集 $\\mathcal{T}$，这些区域的估计误差较大。具体来说，实现以下算法：\n- 固定参数域 $[\\mu_{\\min}, \\mu_{\\max}]$ 和该区间内的一个候选评估参数集 $\\Xi$。\n- 给定初始训练集 $\\mathcal{T}_0$ 和容差 $\\varepsilon > 0$，根据在 $\\mathcal{T}_0$ 处的真值快照构建初始RB空间 $V_r$，并计算最大估计误差 $\\max_{\\mu \\in \\Xi} \\eta(\\mu)$。\n- 如果 $\\max_{\\mu \\in \\Xi} \\eta(\\mu) \\leq \\varepsilon$，则终止。否则，在 $\\Xi$ 上形成一个布尔掩码 $\\mathbb{I}(\\mu) = \\mathbf{1}\\{\\eta(\\mu) > \\varepsilon\\}$，并将参数区间分割成掩码为真的连续簇（根据在 $\\Xi$ 中的索引）。在每个簇内，选择使 $\\eta(\\mu)$ 最大化的参数 $\\mu^\\star$，并将其添加到训练集中，即 $\\mathcal{T} \\leftarrow \\mathcal{T} \\cup \\{\\mu^\\star\\}$。重建RB空间并重复此过程，直到收敛或达到预设的最大RB维度。\n- 聚类必须在有序候选集 $\\Xi$ 上由掩码导出的连续片段上执行，这是对一维空间中基于区域的优化的一个科学上合理的代理。\n\n使用以下科学上一致的数据：\n- 系数 $a(\\mu) = 1 + \\mu$， $b(\\mu) = \\mu^2$。\n- 强迫函数 $f(x) = \\sum_{k=1}^{K_f} \\frac{1}{k}\\,\\sin(k\\pi x)$，其中 $K_f = 10$，因此当 $1 \\leq k \\leq K_f$ 时 $f_k = \\frac{1}{k}$，当 $k > K_f$ 时 $f_k=0$。\n- 谱截断维度 $N = 30$。\n\n请将您的程序设计为完全确定性的，并精确地按照所述实现自适应算法，使用谱真值模型和基于残差的估计器。代码必须能处理以下测试套件，每个套件指定为一个元组 $(\\mu_{\\min}, \\mu_{\\max}, \\varepsilon, \\mathcal{T}_0, r_{\\max}, |\\Xi|)$：\n- 测试用例 1：$(0.1, 3.0, 10^{-5}, [0.15, 2.70], 20, 200)$。\n- 测试用例 2：$(0.1, 3.0, 10^{-9}, [0.10], 30, 300)$。\n- 测试用例 3：$(0.1, 3.0, 10^{-3}, [0.10, 1.00, 2.00], 8, 100)$。\n\n您的程序必须为每个测试用例返回一个对 $[\\text{final\\_training\\_size}, \\text{final\\_max\\_error}]$，其中 $\\text{final\\_training\\_size}$ 是终止时训练集的整数基数，而 $\\text{final\\_max\\_error}$ 是终止时 $\\max_{\\mu \\in \\Xi} \\eta(\\mu)$ 的浮点数值。将所有测试用例的结果汇总到一行输出中，该行包含一个按测试套件顺序排列的这些对的列表，例如 $[[n_1, e_1],[n_2, e_2],[n_3, e_3]]$。\n\n此问题中不出现角度。输出不需要物理单位。所有返回的量必须是无单位的数值。确保使用所描述的谱伽辽金方法和基于估计器的自适应采样策略的基础来处理和解决问题，并避免使用任何未从所提供基础推导出的捷径公式。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于偏微分方程数值方法和降阶建模的理论，问题设定良好，算法清晰且确定，表述客观。所有必要的数据和条件都已提供，以得出一个唯一的、可验证的解。\n\n任务是实现一种自适应采样算法，用于为参数化边值问题构建降阶基（RB）。该算法通过识别高估计误差区域来迭代地优化参数训练集。以下各节详细介绍了数学框架和算法步骤。\n\n### 1. 全阶模型（FOM）：谱伽辽金方法\n\n控制方程是一个一维反应扩散方程：\n$$\n-a(\\mu)\\,\\frac{d^2 u}{dx^2} + b(\\mu)\\,u = f(x), \\quad x \\in (0,1)\n$$\n带有齐次狄利克雷边界条件 $u(0;\\mu)=u(1;\\mu)=0$。系数由 $a(\\mu) = 1 + \\mu$ 和 $b(\\mu) = \\mu^2$ 给出。\n\n我们使用谱伽辽金方法来近似解 $u(x;\\mu)$，基函数为 $N=30$ 个傅里叶正弦函数，$\\phi_k(x) = \\sin(k\\pi x)$，其中 $k \\in \\{1, 2, \\dots, N\\}$。近似解为\n$$\nu_N(x;\\mu) = \\sum_{k=1}^N c_k(\\mu)\\,\\phi_k(x)\n$$\n其中 $c(\\mu) = [c_1(\\mu), \\dots, c_N(\\mu)]^\\top$ 是未知谱系数的向量。\n\n将此代入弱形式，并使用测试函数 $v = \\phi_j(x)$（其中 $j \\in \\{1, \\dots, N\\}$）可得到一个线性方程组 $K(\\mu)c(\\mu) = f$。所选基函数的主要优点是其正交性：\n$$\n\\int_0^1 \\phi_i'(x)\\,\\phi_j'(x)\\,dx = \\frac{(i\\pi)^2}{2}\\,\\delta_{ij}, \\quad \\int_0^1 \\phi_i(x)\\,\\phi_j(x)\\,dx = \\frac{1}{2}\\,\\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ。这些关系意味着刚度矩阵 $S$（来自二阶导数项）和质量矩阵 $M$（来自零阶项）是对角的。因此，系统矩阵 $K(\\mu) = a(\\mu)S + b(\\mu)M$ 也是对角的。其对角元由下式给出：\n$$\nK_{kk}(\\mu) = a(\\mu)\\left(\\frac{(k\\pi)^2}{2}\\right) + b(\\mu)\\left(\\frac{1}{2}\\right) = \\frac{(1+\\mu)(k\\pi)^2 + \\mu^2}{2}\n$$\n右端项向量 $f$ 的元素为 $f_k = \\int_0^1 f(x)\\phi_k(x)dx$。强迫函数通过其傅里叶正弦系数指定：$f(x) = \\sum_{k=1}^{K_f} \\frac{1}{k}\\,\\sin(k\\pi x)$，其中 $K_f = 10$。这直接给出\n$$\nf_k = \\begin{cases} \\frac{1}{2k}  \\text{ if } 1 \\le k \\le 10 \\\\ 0  \\text{ if } 10  k \\le N \\end{cases}\n$$\n由于 $K(\\mu)$ 是对角的，求解FOM系统 $K(\\mu)c(\\mu) = f$ 非常简单。FOM解的系数（也称为“真值”解）为：\n$$\nc_k(\\mu) = \\frac{f_k}{K_{kk}(\\mu)} = \\frac{2f_k}{(1+\\mu)(k\\pi)^2 + \\mu^2}\n$$\n\n### 2. 降阶模型（ROM）：降阶基方法\n\nRB方法从一组FOM解（称为快照）构建一个低维近似空间 $V_r$。\n1.  **快照**：对于一个参数训练集 $\\mathcal{T} = \\{\\mu_1, \\dots, \\mu_r\\} \\subset [\\mu_{\\min}, \\mu_{\\max}]$，我们计算相应的FOM解向量 $u_N(\\mu_i) = [c_1(\\mu_i), \\dots, c_N(\\mu_i)]^\\top$。\n2.  **基生成**：RB空间 $V_r$ 是这些快照的张成空间。我们为该空间构建一个正交规范基，其向量构成矩阵 $V \\in \\mathbb{R}^{N \\times r}$ 的列。这在数值上通过对快照矩阵 $[u_N(\\mu_1), \\dots, u_N(\\mu_r)]$ 进行奇异值分解（SVD）来实现。该矩阵的左奇异向量提供了所期望的正交规范基 $V$。\n3.  **伽辽金投影**：对于一个新参数 $\\mu$，在空间 $V_r$ 中寻找RB近似解 $u_r(\\mu)$，即对于某个降阶系数向量 $c_r(\\mu) \\in \\mathbb{R}^r$，$u_r(\\mu) = V c_r(\\mu)$。将FOM方程伽辽金投影到空间 $V_r$ 上，得到降阶系统：\n$$\nK_r(\\mu) c_r(\\mu) = f_r\n$$\n其中 $K_r(\\mu) = V^\\top K(\\mu) V \\in \\mathbb{R}^{r \\times r}$ 且 $f_r = V^\\top f \\in \\mathbb{R}^r$。由于 $r \\ll N$，该系统的求解成本远低于FOM。\n\n### 3. 后验误差估计\n\n为了指导训练参数的自适应选择，我们采用一个可靠的后验误差估计器。该估计器基于RB解的残差 $r(\\mu) = f - K(\\mu)u_r(\\mu)$。能量范数下的误差可以通过残差的对偶范数来界定：\n$$\n\\eta(\\mu) = \\|r(\\mu)\\|_{K(\\mu)^{-1}} = \\sqrt{r(\\mu)^\\top K(\\mu)^{-1} r(\\mu)}\n$$\n由于 $K(\\mu)$ 及其逆 $K(\\mu)^{-1}$ 是对角的，此计算非常高效：\n$$\n\\eta(\\mu) = \\sqrt{\\sum_{k=1}^N \\frac{r_k(\\mu)^2}{K_{kk}(\\mu)}}\n$$\n一旦RB空间 $V$ 建立，这个估计器 $\\eta(\\mu)$ 就可以对任何参数 $\\mu$ 进行快速评估，而无需求解昂贵的FOM。\n\n### 4. 自适应采样算法\n\n任务的核心是实现一个特定的贪心算法，以自适应地构建训练集 $\\mathcal{T}$ 和相关的RB空间 $V_r$。\n\n**初始化：**\n-   从测试用例参数开始：$(\\mu_{\\min}, \\mu_{\\max}, \\varepsilon, \\mathcal{T}_0, r_{\\max}, |\\Xi|)$。\n-   生成一个均匀的候选参数网格 $\\Xi = \\{\\mu_j\\}_{j=1}^{|\\Xi|} \\subset [\\mu_{\\min}, \\mu_{\\max}]$。\n-   初始化训练集 $\\mathcal{T} = \\mathcal{T}_0$。\n\n**迭代优化：**\n算法在一个循环中进行，直到满足终止条件。\n1.  **构建/更新RB空间**：给定当前训练集 $\\mathcal{T}$，为每个 $\\mu_i \\in \\mathcal{T}$ 计算快照向量 $u_N(\\mu_i)$。组合快照矩阵并计算其SVD以获得正交规范基矩阵 $V$。$V$ 的列数 $r$ 是降阶基的当前大小。\n2.  **评估误差估计器**：对候选集 $\\Xi$ 中的每个参数 $\\mu_j$，计算RB解 $u_r(\\mu_j)$ 和相应的误差估计 $\\eta(\\mu_j)$。\n3.  **检查终止条件**：找到候选集上的最大估计误差 $\\eta_{\\max} = \\max_{\\mu_j \\in \\Xi} \\eta(\\mu_j)$。\n    -   如果 $\\eta_{\\max} \\le \\varepsilon$，则RB模型在整个参数域上已足够精确。算法终止。\n    -   如果训练集的大小 $|\\mathcal{T}|$ 已达到预设的最大值 $r_{\\max}$，算法终止。\n4.  **识别优化候选**：如果两个终止条件都未满足，则识别 $\\Xi$ 中所有估计误差超过容差的参数，即构建集合 $\\{\\mu \\in \\Xi \\mid \\eta(\\mu)  \\varepsilon\\}$。\n5.  **聚类和选择**：$\\Xi$ 的有序性导出了具有高误差的参数的连续片段（簇）。对于每个这样的连续簇，找到使误差估计器 $\\eta(\\mu)$ 最大化的单个参数 $\\mu^\\star$。\n6.  **更新训练集**：将在上一步中找到的所有唯一的最大化参数 $\\{\\mu^\\star\\}$ 添加到训练集中：$\\mathcal{T} \\leftarrow \\mathcal{T} \\cup \\{\\mu^\\star\\}$。然后算法返回到第1步。\n\n**输出：**\n终止时，算法报告训练集的最终大小 $|\\mathcal{T}|$ 和在最后一次迭代中计算的最终最大误差 $\\eta_{\\max}$。\n\n这个系统化的过程确保了新基向量被添加到参数域中近似最差的区域，以丰富RB空间，从而高效地构建一个精确的ROM。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive sampling algorithm for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (mu_min, mu_max, epsilon, T0, r_max, Xi_size)\n        (0.1, 3.0, 1e-5, [0.15, 2.70], 20, 200),\n        (0.1, 3.0, 1e-9, [0.10], 30, 300),\n        (0.1, 3.0, 1e-3, [0.10, 1.00, 2.00], 8, 100),\n    ]\n\n    # Correction: The problem statement has a slight ambiguity in the derivation\n    # of the forcing coefficients `f_k`. Given the basis `phi_k(x) = sin(k*pi*x)`, the\n    # integral for `f_k` should be `Integral(f(x)*phi_k(x), {x, 0, 1})`.\n    # With `f(x) = Sum(1/m * sin(m*pi*x))`, the orthogonality of sine functions\n    # `Integral(sin(m*pi*x)*sin(k*pi*x), {x, 0, 1}) = 0.5 * delta_mk`\n    # implies `f_k = (1/k) * 0.5`. This correction is applied for scientific accuracy.\n    f_k_correction_factor = 0.5\n    \n    results = []\n    for case in test_cases:\n        result = run_adaptive_sampler(*case, f_k_correction_factor)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(output_str)\n\n\ndef run_adaptive_sampler(mu_min, mu_max, epsilon, T0, r_max, Xi_size, f_k_correction_factor):\n    \"\"\"\n    Implements the estimator-driven adaptive sampling algorithm.\n    \"\"\"\n    # --- 1. Setup ---\n    N = 30\n    Kf = 10\n    pi = np.pi\n\n    # Candidate parameter set\n    Xi = np.linspace(mu_min, mu_max, Xi_size)\n\n    # Training set, starting with a copy of the initial set\n    T = list(T0)\n\n    # Pre-compute constant terms for the Full-Order Model (FOM)\n    k = np.arange(1, N + 1)\n    # Forcing vector f_k, applying the correction based on orthogonality\n    f = np.zeros(N)\n    f[:Kf] = (1.0 / k[:Kf]) * f_k_correction_factor\n\n    # Diagonal entries of stiffness (S) and mass (M) matrices from weak form\n    S_diag = (k * pi)**2 / 2.0\n    M_diag = np.full(N, 0.5)\n\n    max_error = float('inf')\n\n    # --- 2. Main Adaptive Loop ---\n    while True:\n        # --- 3. Build Reduced Basis (RB) space ---\n        r = len(T)\n        snapshots = np.zeros((N, r))\n        for i, mu in enumerate(T):\n            a_mu = 1.0 + mu\n            b_mu = mu**2\n            K_diag_mu = a_mu * S_diag + b_mu * M_diag\n            # Truth solution (snapshot) computed from diagonal FOM system\n            snapshots[:, i] = f / (K_diag_mu + 1e-40)\n\n        # Orthonormalize snapshots using SVD to get the basis V\n        try:\n            U, s, _ = np.linalg.svd(snapshots, full_matrices=False)\n            rank = np.sum(s > 1e-12 * s[0]) if s.size > 0 else 0\n            V = U[:, :rank]\n        except np.linalg.LinAlgError:\n            V = np.zeros((N, 0))\n\n        # --- 4. Evaluate error estimator over the candidate set Xi ---\n        errors = np.zeros(Xi_size)\n        if V.shape[1] > 0:\n            fr = V.T @ f\n            for i, mu in enumerate(Xi):\n                a_mu = 1.0 + mu\n                b_mu = mu**2\n                K_diag_mu = a_mu * S_diag + b_mu * M_diag\n\n                K_V = K_diag_mu[:, np.newaxis] * V\n                Kr = V.T @ K_V\n\n                try:\n                    c_r = np.linalg.solve(Kr, fr)\n                    u_r = V @ c_r\n                    residual = f - K_diag_mu * u_r\n                    errors[i] = np.sqrt(np.sum((residual**2) / (K_diag_mu + 1e-40)))\n                except np.linalg.LinAlgError:\n                    errors[i] = float('inf')\n        else:\n            errors.fill(float('inf'))\n\n        max_error = np.max(errors) if errors.size > 0 else 0.0\n\n        # --- 5. Check for termination ---\n        if max_error = epsilon or len(T) >= r_max:\n            break\n\n        # --- 6. Find and add new samples ---\n        mask = errors > epsilon\n        diff = np.diff(np.concatenate(([False], mask, [False])).astype(int))\n        starts = np.where(diff == 1)[0]\n        ends = np.where(diff == -1)[0]\n\n        new_mus_to_add = set()\n        for start, end in zip(starts, ends):\n            cluster_indices = np.arange(start, end)\n            if len(cluster_indices) > 0:\n                idx_in_cluster = np.argmax(errors[cluster_indices])\n                best_idx_in_Xi = cluster_indices[idx_in_cluster]\n                new_mus_to_add.add(Xi[best_idx_in_Xi])\n\n        unique_new_mus = [mu for mu in new_mus_to_add if mu not in T]\n        if not unique_new_mus:\n            break\n        \n        T.extend(sorted(list(unique_new_mus))) # sorted for deterministic behavior\n    \n    return [len(T), max_error]\n\n# The provided solution code had a minor scientific inaccuracy. The original problem stated `f_k = 1/k`.\n# However, given `f(x) = Sum(1/m * sin(m*pi*x))` and basis `phi_k(x) = sin(k*pi*x)`, the coefficient\n# `f_k = Integral(f(x)*phi_k(x), {x,0,1})` becomes `1/k * Integral(sin(k*pi*x)^2, {x,0,1}) = 1/(2k)`.\n# The provided solution script in the answer section is corrected to reflect this.\n# This correction is necessary for scientific consistency.\nsolve()\n```", "id": "3412109"}, {"introduction": "当参数偏微分方程的解流形在某些参数点附近表现出剧烈变化（例如共振）时，标准的贪心算法可能效率不高。本实践将带你应对亥姆霍兹方程（Helmholtz equation）中的共振挑战，你将实现一个更高级的、带有“信赖域”策略的贪心算法。通过在检测到准奇异性的区域内进行局部搜索，该方法能够更精确地捕捉解的局部特征，是处理复杂参数依赖问题的一种强大技术。[@problem_id:3412063]", "problem": "考虑区间 $[0,1]$ 上带有齐次狄利克雷边界条件的一维亥姆霍兹边值问题：求解 $u(x;\\mu)$ 使得\n$$\n- \\frac{d^2 u}{dx^2}(x;\\mu) - \\mu\\, u(x;\\mu) = f(x), \\quad x \\in (0,1), \\quad u(0;\\mu) = u(1;\\mu) = 0,\n$$\n其中 $\\mu \\in \\mathbb{R}$ 是一个标量参数。当参数值 $\\mu$ 接近某些波数的平方时，亥姆霍兹算子可能表现出近奇异性，在使用谱方法和间断 Galerkin 等高阶方法时，这在离散系统中表现为共振。\n\n使用谱 Galerkin 方法，其采用正交归一的正弦基 $\\{\\varphi_n(x)\\}_{n=1}^{N}$，其中 $\\varphi_n(x) = \\sqrt{2}\\,\\sin(n\\pi x)$。该基通过构造满足齐次狄利克雷边界条件。对于固定的 $N \\in \\mathbb{N}$，谱 Galerkin 离散化定义了一个参数化的线性系统族\n$$\nA(\\mu) u(\\mu) = f,\n$$\n其中 $u(\\mu) \\in \\mathbb{R}^N$ 是谱系数向量，$f \\in \\mathbb{R}^N$ 包含强迫项的谱系数。算子 $A(\\mu)$ 可以从弱形式和谱基的正交性中导出。在此基下，质量矩阵是单位矩阵，刚度矩阵是对角矩阵。当 $\\mu$ 接近刚度矩阵的对角元时，会发生共振，导致 $A(\\mu)$ 变得近奇异。\n\n你的任务是设计一个降阶模型 (ROM)，该模型使用关于 $\\mu$ 的局部贪心扩展和信赖域策略，在离散算子 $A(\\mu)$ 表现出近奇异性的参数值附近自适应地加密降阶基。你的 ROM 必须通过解快照构建，并使用一个基于残差范数和从离散算子导出的矫顽性代理的后验误差指示器。在你的设计中，请使用以下基本原理和经过充分检验的计算事实：\n\n- 带参数 $\\mu$ 的亥姆霍兹方程的变分形式。\n- $L^2(0,1)$ 中正弦基的正交归一性以及由此产生的谱刚度矩阵的对角结构。\n- 使用基于残差的误差指示器生成降阶基的贪心算法。\n- 在算子病态的参数附近，使用信赖域策略来局部化贪心加密。\n\n具体来说，在你的程序中实现以下步骤：\n\n1. 基于谱 Galerkin 离散化和正交归一的正弦基，推导出系数空间中的离散算子 $A(\\mu)$ 和相应的全阶解 $u(\\mu)$。强迫项系数 $f_n$ 的选择必须在物理上合理且随 $n$ 衰减，例如 $f_n = 1/n^2$。\n\n2. 通过在自适应选择的参数点上对全阶解进行快照，构建一个降阶基 $V \\in \\mathbb{R}^{N \\times r}$。参数的初始种子集必须覆盖整个参数域，并且基向量必须被正交归一化。\n\n3. 为候选参数 $\\mu$ 定义一个后验误差指示器，该指示器由残差范数 $\\|f - A(\\mu) \\widehat{u}_R(\\mu)\\|_2$ 除以 $A(\\mu)$ 矫顽性（或稳定性裕度）的一个可计算下界构成。其中，$\\widehat{u}_R(\\mu) = V y(\\mu)$ 是降阶系统 $V^\\top A(\\mu) V y(\\mu) = V^\\top f$ 的解。\n\n4. 结合信赖域策略进行局部贪心加密：当矫顽性代理指示在贪心选择的参数 $\\mu^\\star$ 处存在近奇异性时，通过考虑指定半径内的候选参数，将贪心扩展限制在 $\\mu^\\star$ 周围的一个邻域（信赖域）内，并从该局部集合中添加具有最大误差指示器的快照。在近奇异区域之外，则继续进行全局贪心选择。\n\n5. 当已添加的基向量达到最大数量，或候选集上的最大误差指示器低于某个容差时，终止贪心训练。\n\n训练结束后，在一组参数值的测试套件上评估 ROM，并报告 ROM 解与全阶解之间的相对误差。使用谱系数的欧几里得范数来定义每个测试用例的相对误差：\n$$\n\\mathrm{rel\\_err}(\\mu) = \\frac{\\|u(\\mu) - \\widehat{u}_R(\\mu)\\|_2}{\\|u(\\mu)\\|_2},\n$$\n其中 $u(\\mu)$ 是全阶解，$\\widehat{u}_R(\\mu)$ 是 ROM 解。此任务不涉及物理单位或角度单位。\n\n训练后，使用以下参数值测试套件来评估您的 ROM：\n- 远离共振的一般情况：$\\mu = 5.0$。\n- 接近第一个共振点：$\\mu = \\pi^2 - 0.01$。\n- 略高于第二个共振点：$\\mu = (2\\pi)^2 + 0.5$。\n- 远离低阶共振点：$\\mu = 400.0$。\n- 参数域左边界：$\\mu = 1.0$。\n- 参数域右边界：$\\mu = 1000.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试套件一致，例如“[r1,r2,r3,r4,r5,r6]”。每个条目必须是浮点数。使用 $N=60$ 个谱模态，用覆盖参数域的三个种子参数初始化贪心方法，并选择合理的信赖域参数。程序必须是自包含的，且无需用户输入。", "solution": "该问题是有效的，因为它在计算科学和降阶建模领域提出了一个适定的、有科学依据的任务。它自包含、无矛盾，并且要求将成熟的数值方法应用于一个标准模型问题（亥姆霍兹方程），这是一项具有挑战性但可行的工作。\n\n### 1. 高保真或全阶模型 (FOM)\n\n问题始于域 $x \\in [0,1]$ 上带有齐次狄利克雷边界条件的一维参数化亥姆霍兹方程：\n$$\n- \\frac{d^2 u}{dx^2}(x;\\mu) - \\mu\\, u(x;\\mu) = f(x), \\quad u(0;\\mu) = u(1;\\mu) = 0.\n$$\n参数 $\\mu \\in \\mathbb{R}$ 影响解 $u(x;\\mu)$。我们采用谱 Galerkin 方法来离散化此偏微分方程。解被近似为一个有限级数展开：\n$$\nu_N(x;\\mu) = \\sum_{n=1}^{N} c_n(\\mu) \\varphi_n(x),\n$$\n其中 $\\{\\varphi_n(x) = \\sqrt{2}\\sin(n\\pi x)\\}_{n=1}^{N}$ 是一组在 $L^2(0,1)$ 上正交归一且满足边界条件的基函数。\n\n该偏微分方程的弱形式是寻找 $u \\in H_0^1(0,1)$，使得对于所有测试函数 $v \\in H_0^1(0,1)$：\n$$\n\\int_0^1 \\frac{du}{dx} \\frac{dv}{dx} \\,dx - \\mu \\int_0^1 u v \\,dx = \\int_0^1 f v \\,dx.\n$$\n通过代入 $u_N$ 的展开式并选择测试函数 $v = \\varphi_m(x)$（其中 $m=1, \\dots, N$），我们得到了关于未知系数 $c(\\mu) = [c_1(\\mu), \\dots, c_N(\\mu)]^\\top$ 的线性系统。系统矩阵的第 $(m,n)$ 个元素由双线性形式导出：\n$$\n\\int_0^1 \\frac{d\\varphi_n}{dx} \\frac{d\\varphi_m}{dx} \\,dx - \\mu \\int_0^1 \\varphi_n \\varphi_m \\,dx.\n$$\n由于选择了正弦基，质量矩阵和刚度矩阵都是对角的。\n质量矩阵的元素为 $M_{mn} = \\int_0^1 \\varphi_n(x) \\varphi_m(x) \\,dx = \\delta_{mn}$，因此 $M=I_N$（$N \\times N$ 的单位矩阵）。\n刚度矩阵的元素为 $K_{mn} = \\int_0^1 \\varphi_n'(x)\\varphi_m'(x) \\,dx = (n\\pi)^2 \\delta_{mn}$，因此 $K = \\mathrm{diag}((1\\pi)^2, (2\\pi)^2, \\dots, (N\\pi)^2)$。\n\n右端向量由强迫项的谱系数组成，$f_{coeffs, m} = \\int_0^1 f(x) \\varphi_m(x) \\,dx$。问题指定 $f_{coeffs, n} = 1/n^2$。\n\n由此得到的关于系数向量 $c(\\mu)$ 的 $N \\times N$ 线性系统为：\n$$\n(K - \\mu I_N) c(\\mu) = f_{coeffs}.\n$$\n我们将参数化矩阵记为 $A(\\mu) = K - \\mu I_N$。由于 $A(\\mu)$ 是对角矩阵，全阶解可以通过逐元素除法轻易求得：\n$$\nc_n(\\mu) = \\frac{f_n}{(n\\pi)^2 - \\mu}, \\quad n = 1, \\dots, N.\n$$\n这是我们的高保真“真”解，或称 FOM。每当 $\\mu$ 接近算子 $-\\frac{d^2}{dx^2}$ 的一个特征值 $(n\\pi)^2$ 时，系统就变得奇异，从而导致共振。\n\n### 2. 降阶模型 (ROM) 与贪心训练\n\nROM 的目标是找到 $c(\\mu)$ 的一个精确近似 $\\widehat{c}_R(\\mu)$，而其计算成本更低。我们构建一个由正交归一基 $V \\in \\mathbb{R}^{N \\times r}$（其中 $r \\ll N$）张成的低维子空间，该子空间能够捕获解流形 $\\{c(\\mu) : \\mu \\in \\mathcal{P}\\}$。基向量是在选定参数值下 FOM 解 $c(\\mu)$ 的快照。\n\nROM 近似为 $\\widehat{c}_R(\\mu) = V y(\\mu)$，其中 $y(\\mu) \\in \\mathbb{R}^r$ 是降阶坐标向量。将此代入 FOM 系统并投影到由 $V$ 张成的子空间上（一个 Galerkin 投影），得到降阶系统：\n$$\nV^\\top A(\\mu) V y(\\mu) = V^\\top f_{coeffs}.\n$$\n这是一个小的 $r \\times r$ 线性系统，可以快速求解 $y(\\mu)$。然后通过 $\\widehat{c}_R(\\mu) = V y(\\mu)$ 恢复全空间 ROM 解。\n\n关键任务是选择在哪些参数点上采集快照以构建一个高效的基 $V$。我们使用一个带后验误差指示器的弱贪心算法。\n\n**后验误差指示器：**\n一个好的误差指示器应当是可靠的（与真实误差相关）且计算高效。ROM 解的残差范数 $R(\\mu) = f_{coeffs} - A(\\mu) \\widehat{c}_R(\\mu)$ 是一个很好的出发点。然而，其大小取决于 $A(\\mu)$ 的条件数。一个更好的指示器是用系统稳定性的度量来对残差进行归一化。稳定性常数与 $A(\\mu)$ 的最小奇异值 $\\sigma_{\\min}(A(\\mu))$ 相关。对于我们的对称对角矩阵 $A(\\mu)$，这个值是 $\\sigma_{\\min}(A(\\mu)) = \\min_{n=1,\\dots,N} |(n\\pi)^2 - \\mu|$。我们的误差指示器是：\n$$\n\\eta(\\mu) = \\frac{\\| R(\\mu) \\|_2}{\\sigma_{\\min}(A(\\mu))}.\n$$\n\n**带信赖域策略的贪心算法：**\n1.  **初始化**：定义一个参数训练集 $\\Xi_{train}$。选择一个小的初始参数集 $\\mu_{seed}$（例如，参数域的边界点和中点），计算相应的 FOM 快照 $c(\\mu_{seed})$，并将它们正交归一化以形成初始基 $V$。\n2.  **迭代**：\n    a. **误差估计**：对于每个候选参数 $\\mu \\in \\Xi_{train}$，计算 ROM 解 $\\widehat{c}_R(\\mu)$ 和误差指示器 $\\eta(\\mu)$。\n    b. **全局搜索**：找到使误差指示器最大化的参数 $\\mu^\\star$：$\\mu^\\star = \\arg\\max_{\\mu \\in \\Xi_{train}} \\eta(\\mu)$。\n    c. **信赖域逻辑**：参数 $\\mu^\\star$ 通常位于共振点附近，此时 $\\sigma_{\\min}(A(\\mu^\\star))$ 很小。直接添加快照 $c(\\mu^\\star)$ 可能是有效的，但解在这些区域变化非常迅速。信赖域策略有助于集中加密工作。\n        - 如果 $\\sigma_{\\min}(A(\\mu^\\star))$ 低于某个阈值 `coerc_thresh`，我们便声明 $\\mu^\\star$ 处于近奇异区域。\n        - 然后我们在 $\\mu^\\star$ 周围定义一个信赖域（一个小区间），并重新搜索最大误差指示器，但搜索范围仅限于此局部区域。在此局部搜索中找到的参数 $\\mu_{local}^\\star$ 将被选为下一个快照点。\n        - 如果 $\\sigma_{\\min}(A(\\mu^\\star))$ 高于该阈值，我们执行标准的“全局”贪心步骤，并选择 $\\mu^\\star$ 本身。\n    d. **基富集**：为选定的参数 $\\mu_{new}$（$\\mu^\\star$ 或 $\\mu_{local}^\\star$）计算 FOM 快照 $c(\\mu_{new})$。将这个新快照与现有基 $V$ 进行正交归一化，并将其作为新的一列附加到 $V$ 中，从而增加基的大小 $r$。\n3.  **终止**：循环继续，直到 $\\Xi_{train}$ 上的最大误差指示器低于指定的容差 $\\epsilon_{tol}$，或基的大小达到预设的最大值 $r_{max}$。\n\n### 3. 评估\n训练阶段结束后，使用最终的降阶基 $V$ 在一个单独的参数测试集 $\\Xi_{test}$ 上评估 ROM 的准确性。对于每个 $\\mu_{test} \\in \\Xi_{test}$，我们计算 ROM 解 $\\widehat{c}_R(\\mu_{test})$ 和 FOM 解 $c(\\mu_{test})$。性能通过欧几里得范数下的相对误差来衡量：\n$$\n\\mathrm{rel\\_err}(\\mu) = \\frac{\\|c(\\mu_{test}) - \\widehat{c}_R(\\mu_{test})\\|_2}{\\|c(\\mu_{test})\\|_2}.\n$$\n这个过程对 ROM 在整个参数域（尤其是在具有挑战性的共振区域附近）逼近真实解的能力提供了一个定量评估。预计信赖域贪心算法将构建一个紧凑的基，该基在解析这些共振方面特别有效。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements a trust-region based greedy algorithm for building a Reduced Order Model (ROM)\n    for a 1D parametric Helmholtz equation, and evaluates its accuracy.\n    \"\"\"\n    \n    # 1. Model and Training Parameters\n    N = 60  # Number of spectral modes (FOM dimension)\n    param_domain = [1.0, 1000.0]\n    \n    # Training parameters\n    max_basis_size = 20\n    greedy_tol = 1e-8\n    coerc_thresh = 0.1  # Threshold for triggering trust-region\n    trust_region_radius = 2.0\n    \n    # Training set for the greedy algorithm\n    P_train = np.linspace(param_domain[0], param_domain[1], 501)\n    \n    # Test cases for final evaluation\n    test_cases = [\n        5.0,\n        np.pi**2 - 0.01,\n        (2 * np.pi)**2 + 0.5,\n        400.0,\n        1.0,\n        1000.0\n    ]\n\n    # 2. Setup Full-Order Model (FOM)\n    n_modes = np.arange(1, N + 1)\n    # Stiffness matrix diagonal K_nn = (n*pi)^2\n    K_diag = (n_modes * np.pi)**2\n    # Forcing vector coefficients f_n = 1/n^2\n    f_coeffs = 1.0 / (n_modes**2)\n\n    def solve_fom(mu):\n        \"\"\"Solves the full-order model for a given parameter mu.\"\"\"\n        if any(np.isclose(K_diag, mu)):\n            return np.full(N, np.inf)\n        A_mu_diag = K_diag - mu\n        return f_coeffs / A_mu_diag\n\n    def get_coercivity_surrogate(mu):\n        \"\"\"Computes the stability factor surrogate min(|(n*pi)^2 - mu|).\"\"\"\n        return np.min(np.abs(K_diag - mu))\n\n    # 3. Greedy algorithm with Trust-Region for ROM basis generation\n    \n    # -- Initialization\n    initial_params = [param_domain[0], np.mean(param_domain), param_domain[1]]\n    \n    snapshots = np.array([solve_fom(mu) for mu in initial_params]).T\n    V, _ = linalg.qr(snapshots, mode='economic') # Orthonormalize initial snapshots\n    \n    training_params_set = set(P_train)\n    selected_params = set(initial_params)\n\n    # -- Greedy loop\n    for r in range(V.shape[1], max_basis_size):\n        errors = []\n        param_candidates = []\n        \n        current_P_train = sorted(list(training_params_set - selected_params))\n        if not current_P_train:\n            break\n            \n        for mu in current_P_train:\n            A_mu_diag = K_diag - mu\n            \n            A_R = V.T @ (A_mu_diag[:, np.newaxis] * V)\n            f_R = V.T @ f_coeffs\n            try:\n                y = linalg.solve(A_R, f_R, assume_a='sym')\n            except linalg.LinAlgError:\n                errors.append(np.inf)\n                param_candidates.append(mu)\n                continue\n\n            c_R = V @ y\n            \n            res = f_coeffs - A_mu_diag * c_R\n            res_norm = np.linalg.norm(res)\n            stab_const = get_coercivity_surrogate(mu)\n            \n            if stab_const  1e-12:\n                error_indicator = np.inf\n            else:\n                error_indicator = res_norm / stab_const\n            \n            errors.append(error_indicator)\n            param_candidates.append(mu)\n\n        if not errors:\n            break\n\n        max_error_idx = np.argmax(errors)\n        max_error = errors[max_error_idx]\n        mu_star = param_candidates[max_error_idx]\n        \n        if max_error  greedy_tol:\n            break\n\n        # -- Trust-region logic\n        mu_new = mu_star\n        stab_at_mu_star = get_coercivity_surrogate(mu_star)\n\n        if stab_at_mu_star  coerc_thresh:\n            tr_min = mu_star - trust_region_radius\n            tr_max = mu_star + trust_region_radius\n            \n            local_errors = []\n            local_params = []\n            \n            for i, p in enumerate(param_candidates):\n                if tr_min = p = tr_max:\n                    local_errors.append(errors[i])\n                    local_params.append(p)\n            \n            if local_errors:\n                local_max_idx = np.argmax(local_errors)\n                mu_new = local_params[local_max_idx]\n\n        # -- Basis enrichment\n        if mu_new in selected_params:\n            break # Avoid adding the same parameter again, causing stagnation\n        selected_params.add(mu_new)\n        new_snapshot = solve_fom(mu_new)\n        \n        w = new_snapshot - V @ (V.T @ new_snapshot)\n        norm_w = np.linalg.norm(w)\n        \n        if norm_w > 1e-10:\n            v_new = w / norm_w\n            V = np.hstack((V, v_new[:, np.newaxis]))\n\n    # 4. Evaluate ROM on the test suite\n    results = []\n    for mu in test_cases:\n        c_fom = solve_fom(mu)\n        norm_c_fom = np.linalg.norm(c_fom)\n\n        A_mu_diag = K_diag - mu\n        A_R = V.T @ (A_mu_diag[:, np.newaxis] * V)\n        f_R = V.T @ f_coeffs\n        \n        try:\n            y = linalg.solve(A_R, f_R, assume_a='sym')\n            c_rom = V @ y\n            \n            if norm_c_fom > 1e-12:\n                rel_err = np.linalg.norm(c_fom - c_rom) / norm_c_fom\n            else: # Handle zero solution case\n                rel_err = np.linalg.norm(c_fom - c_rom)\n        except linalg.LinAlgError:\n            rel_err = np.inf\n            \n        results.append(rel_err)\n\n    # 5. Print final results in the required format\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3412063"}]}