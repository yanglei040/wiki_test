{"hands_on_practices": [{"introduction": "在处理具有多个随机变量的问题时，一个关键挑战是所谓的“维度灾难”，即所需配置点的数量会随着维度的增加而呈指数级增长。稀疏网格是一种优雅而强大的解决方案，它通过巧妙地组合低阶张量积法则来构建一个高效的多维求积规则。本练习将指导您动手构建一个稀疏网格，让您通过计算其多指标集和节点总数，深入理解Smolyak算法的核心思想及其在削减计算成本方面的优势。", "problem": "考虑一个用于$3$维参数化输入向量 $\\boldsymbol{\\xi} = (\\xi_1,\\xi_2,\\xi_3)$ 的非侵入式随机配置法 (SCM)，该向量的分量相互独立且在区间 $[-1,1]$ 上均匀分布。您将基于 Smolyak 算子 $\\mathcal{A}(q,d)$（其中 $q=3$，$d=3$）并使用嵌套的一维 Clenshaw–Curtis 配置规则，为插值构建一个稀疏网格节点集。\n\n使用以下基本定义：\n\n- 一维层级-$\\ell$ 配置规则具有一个嵌套节点集 $\\mathcal{X}_\\ell$，其基数为 $N_\\ell$，其中 $N_1 = 1$，$N_2 = 3$，$N_3 = 5$，并且对于 $\\ell \\geq 2$，$N_\\ell = 2^{\\ell-1} + 1$。定义层级增量集为 $\\Delta \\mathcal{X}_1 := \\mathcal{X}_1$，并且对于 $\\ell \\geq 2$，$\\Delta \\mathcal{X}_\\ell := \\mathcal{X}_\\ell \\setminus \\mathcal{X}_{\\ell-1}$，其增量基数为 $M_\\ell := |\\Delta \\mathcal{X}_\\ell|$。根据定义，$M_1 = 1$，$M_2 = 2$，并且对于 $\\ell \\geq 3$，$M_\\ell = N_\\ell - N_{\\ell-1} = 2^{\\ell-2}$。\n\n- 带有嵌套规则的 Smolyak 插值算子由张量积层级增量构成。其多重指标集为\n$$\n\\mathcal{I}(q,d) := \\left\\{ \\boldsymbol{i} = (i_1,i_2,i_3) \\in \\mathbb{N}^3 \\;:\\; \\sum_{k=1}^3 i_k \\leq q + d - 1,\\;\\; i_k \\geq 1 \\right\\}.\n$$\n相关的稀疏网格节点集是张量积增量集的不交并，\n$$\n\\mathcal{S}(q,d) := \\bigcup_{\\boldsymbol{i} \\in \\mathcal{I}(q,d)} \\left( \\Delta \\mathcal{X}_{i_1} \\times \\Delta \\mathcal{X}_{i_2} \\times \\Delta \\mathcal{X}_{i_3} \\right),\n$$\n其不同节点的总数为\n$$\n|\\mathcal{S}(q,d)| = \\sum_{\\boldsymbol{i} \\in \\mathcal{I}(q,d)} \\prod_{k=1}^3 M_{i_k}.\n$$\n\n任务：\n1. 列出所有对 Smolyak 算子有贡献的多重指标组合 $\\boldsymbol{i} \\in \\mathcal{I}(q=3,d=3)$。\n2. 使用上述定义，计算稀疏网格 $\\mathcal{S}(3,3)$ 中不同配置节点的总数。\n\n您的最终答案必须是等于 $|\\mathcal{S}(3,3)|$ 的单个整数。", "solution": "问题陈述已经过验证，并且被认为是合理的。这是一个基于数值分析领域（特别是稀疏网格方法）标准定义的适定数学问题。所有必要的数据和定义都已提供，内部一致且没有歧义。\n\n目标是计算使用 Smolyak 算子构建的稀疏网格中不同配置节点的总数，记为 $|\\mathcal{S}(q,d)|$。给定的参数是等级-精度参数 $q=3$ 和输入维度 $d=3$。\n\n节点的总数由以下公式给出：\n$$\n|\\mathcal{S}(q,d)| = \\sum_{\\boldsymbol{i} \\in \\mathcal{I}(q,d)} \\prod_{k=1}^d M_{i_k}\n$$\n对于本问题，$d=3$，因此公式为：\n$$\n|\\mathcal{S}(3,3)| = \\sum_{\\boldsymbol{i} \\in \\mathcal{I}(3,3)} M_{i_1} M_{i_2} M_{i_3}\n$$\n\n第一步是确定多重指标集 $\\mathcal{I}(q,d)$。提供的定义是：\n$$\n\\mathcal{I}(q,d) := \\left\\{ \\boldsymbol{i} = (i_1, \\dots, i_d) \\in \\mathbb{N}^d \\;:\\; \\sum_{k=1}^d i_k \\leq q + d - 1,\\;\\; i_k \\geq 1 \\right\\}\n$$\n当 $q=3$ 和 $d=3$ 时，指标和的条件变为：\n$$\n\\sum_{k=1}^3 i_k \\leq 3 + 3 - 1 = 5\n$$\n因此，我们必须找到所有和小于或等于 $5$ 的正整数三元组 $\\boldsymbol{i} = (i_1, i_2, i_3)$。我们可以根据它们的和 $|\\boldsymbol{i}|_1 = i_1+i_2+i_3$ 将这些多重指标分组枚举。\n\n任务1：列出所有多重指标组合 $\\boldsymbol{i} \\in \\mathcal{I}(3,3)$。\n\n-   情况 $|\\boldsymbol{i}|_1 = 3$：\n    三个正整数之和为 $3$ 的唯一组合是 $(1,1,1)$。\n    多重指标：$(1,1,1)$。\n\n-   情况 $|\\boldsymbol{i}|_1 = 4$：\n    我们需要三个正整数之和为 $4$ 的组合。$4$ 分成三部分的唯一划分是 $2+1+1$。$(2,1,1)$ 的排列是：\n    多重指标：$(2,1,1)$、$(1,2,1)$、$(1,1,2)$。\n\n-   情况 $|\\boldsymbol{i}|_1 = 5$：\n    我们需要三个正整数之和为 $5$ 的组合。$5$ 分成三部分的划分是 $3+1+1$ 和 $2+2+1$。\n    $(3,1,1)$ 的排列：$(3,1,1)$、$(1,3,1)$、$(1,1,3)$。\n    $(2,2,1)$ 的排列：$(2,2,1)$、$(2,1,2)$、$(1,2,2)$。\n\n总的来说，集合 $\\mathcal{I}(3,3)$ 包含 $1+3+3+3 = 10$ 个多重指标：\n$$\n\\mathcal{I}(3,3) = \\{ (1,1,1), (2,1,1), (1,2,1), (1,1,2), (3,1,1), (1,3,1), (1,1,3), (2,2,1), (2,1,2), (1,2,2) \\}\n$$\n\n任务2：计算不同配置节点的总数 $|\\mathcal{S}(3,3)|$。\n\n接下来，我们需要出现在 $\\mathcal{I}(3,3)$ 中的指标（即 $\\ell \\in \\{1,2,3\\}$）所对应的增量基数 $M_\\ell = |\\Delta\\mathcal{X}_\\ell|$ 的值。\n根据问题陈述：\n-   $M_1 = 1$\n-   $M_2 = 2$\n-   对于 $\\ell \\geq 3$，$M_\\ell = 2^{\\ell-2}$。对于 $\\ell=3$，这给出 $M_3 = 2^{3-2} = 2^1 = 2$。\n\n现在我们可以计算总和 $\\sum_{\\boldsymbol{i} \\in \\mathcal{I}(3,3)} M_{i_1} M_{i_2} M_{i_3}$。我们可以根据多重指标 $\\boldsymbol{i}$ 的结构对各项进行分组：\n\n-   对于 $\\boldsymbol{i} = (1,1,1)$：\n    只有一个这样的指标。其贡献为 $M_1 M_1 M_1 = 1 \\cdot 1 \\cdot 1 = 1$。\n\n-   对于 $(2,1,1)$ 的排列：\n    有 $3$ 个这样的指标：$(2,1,1)$、$(1,2,1)$ 和 $(1,1,2)$。对于每一个，基数的乘积是 $M_2 M_1 M_1 = 2 \\cdot 1 \\cdot 1 = 2$。\n    这一组的总贡献是 $3 \\times 2 = 6$。\n\n-   对于 $(3,1,1)$ 的排列：\n    有 $3$ 个这样的指标：$(3,1,1)$、$(1,3,1)$ 和 $(1,1,3)$。对于每一个，基数的乘积是 $M_3 M_1 M_1 = 2 \\cdot 1 \\cdot 1 = 2$。\n    这一组的总贡献是 $3 \\times 2 = 6$。\n\n-   对于 $(2,2,1)$ 的排列：\n    有 $3$ 个这样的指标：$(2,2,1)$、$(2,1,2)$ 和 $(1,2,2)$。对于每一个，基数的乘积是 $M_2 M_2 M_1 = 2 \\cdot 2 \\cdot 1 = 4$。\n    这一组的总贡献是 $3 \\times 4 = 12$。\n\n最后，节点的总数是这些贡献的总和：\n$$\n|\\mathcal{S}(3,3)| = 1 + 6 + 6 + 12 = 25\n$$\n因此，稀疏网格 $\\mathcal{S}(3,3)$ 中不同配置节点的总数是 $25$。", "answer": "$$\\boxed{25}$$", "id": "3403649"}, {"introduction": "理解了如何选择配置点后，下一步是将其应用于求解随机偏微分方程。本实践将引导您为一个由Discontinuous Galerkin（DG）方法离散化的随机泊松方程实现完整的非侵入式配置（NISC）工作流。您将通过在每个配置点上求解确定性问题，并利用投影公式来计算解的广义多项式混沌（gPC）系数 [@problem_id:3403649]。通过将您的结果与侵入式gPC方法的结果进行比较，您不仅可以验证您的代码，还能深入理解NISC方法的精确性及其与问题参数依赖性的关系。", "problem": "考虑空间域 $[0,1]$ 上未知场 $u(x,\\boldsymbol{\\xi})$ 的一维边值问题，其中 $\\xi \\in [-1,1]$ 是一个标量随机变量，其均匀概率密度为 $\\rho(\\xi)=\\frac{1}{2}$：\n$$\n-\\frac{d^2}{dx^2} u(x,\\xi) = f(x,\\xi), \\quad u(0,\\xi)=0, \\quad u(1,\\xi)=0,\n$$\n其中 $f(x,\\xi)=f_0(x)+\\xi f_1(x)$ 是 $\\xi$ 的仿射函数，且空间算子是确定性的（不依赖于 $\\xi$）。空间离散化方法为对称内罚间断Galerkin (SIPG) 方法，使用分片线性基函数，建立在包含 $N$ 个单元的均匀网格上，罚参数为 $\\sigma>0$。假设SIPG双线性形式中的单元项和面项均被精确积分，并使用与算子 $-\\frac{d^2}{dx^2}$ 的SIPG方法一致的精确公式计算体积和面的贡献，齐次Dirichlet边界条件通过罚函数弱施加。\n\n广义多项式混沌 (gPC) 基由前三个在 $[-1,1]$ 上关于权函数 $\\rho(\\xi)=\\frac{1}{2}$ 标准正交的勒让德多项式构成：\n$$\n\\psi_0(\\xi)=1,\\quad \\psi_1(\\xi)=\\sqrt{3}\\,\\xi,\\quad \\psi_2(\\xi)=\\frac{\\sqrt{5}}{2}\\,(3\\xi^2-1).\n$$\n设 $u$ 的截断至总阶数 $2$ 的gPC展开为\n$$\nu(x,\\xi) \\approx \\sum_{n=0}^{2} u_n(x)\\,\\psi_n(\\xi),\n$$\n其系数场 $u_n(x)$ 将通过随机配置和投影进行非侵入式计算。具体来说，使用总阶数 $2$ 的最小配置节点集，即 $[-1,1]$ 上的 $3$ 点高斯-勒让德节点 $\\{\\xi_k\\}_{k=1}^3$ 及其权重 $\\{w_k\\}_{k=1}^3$，并为每个节点 $\\xi_k$ 计算确定性的DG解 $u(x,\\xi_k)$。然后通过投影获得gPC系数：\n$$\nu_n(x) \\approx \\sum_{k=1}^{3} \\left(\\frac{w_k}{2}\\right) u(x,\\xi_k)\\,\\psi_n(\\xi_k), \\quad n=0,1,2,\n$$\n其中因子 $\\frac{w_k}{2}$ 考虑了概率密度 $\\rho(\\xi)=\\frac{1}{2}$。\n\n为了比较，按如下方式计算侵入式gPC系数。对于算子是确定性的且仅有右端项是仿射的情况，随机维度上的Galerkin系统是解耦的：\n$$\nK\\,u_n = b_n, \\quad n=0,1,2,\n$$\n其中 $K$ 是确定性SIPG刚度矩阵，$b_n$ 是投影载荷\n$$\nb_n = \\int_{-1}^{1} \\left( f_0(x) + \\xi f_1(x) \\right)\\psi_n(\\xi)\\,\\rho(\\xi)\\,d\\xi \\quad \\text{作用于空间中的DG检验函数}。\n$$\n对于算子通过标量扩散因子 $a(\\xi)=a_0+a_1\\xi>0$ 仿射地依赖于 $\\xi$ 的情况，使得离散双线性形式被 $a(\\xi)$ 缩放，侵入式gPC满足随机空间中的耦合块系统：\n$$\n\\sum_{m=0}^{2} \\mathbb{E}\\!\\left[a(\\xi)\\psi_n(\\xi)\\psi_m(\\xi)\\right]\\,K\\,u_m = \\mathbb{E}\\!\\left[\\psi_n(\\xi)\\right]\\,f_0, \\quad n=0,1,2,\n$$\n其中 $f_0$ 不依赖于 $\\xi$，$\\mathbb{E}[\\cdot]=\\int_{-1}^{1}(\\cdot)\\rho(\\xi)\\,d\\xi$，$K$ 是SIPG刚度矩阵。这可以紧凑地写为\n$$\n\\left( \\mathbf{M}_a \\otimes K \\right)\\,\\mathbf{u} = \\mathbf{e}_0 \\otimes f_0,\n$$\n其中 $\\mathbf{M}_a \\in \\mathbb{R}^{3\\times 3}$ 的元素为 $(\\mathbf{M}_a)_{nm}=\\mathbb{E}[a(\\xi)\\psi_n(\\xi)\\psi_m(\\xi)]$，$\\mathbf{e}_0=(1,0,0)^\\top$，$\\mathbf{u}$ 堆叠了空间系数向量 $u_0,u_1,u_2$。\n\n从间断Galerkin方法的双线性形式、线性形式以及gPC基的正交性出发，推导非侵入式投影公式和两种场景下的侵入式系统。然后实现一个程序，该程序：\n- 为给定的 $f_0(x)$ 和 $f_1(x)$ 组装SIPG刚度矩阵 $K$ 和载荷向量。\n- 在 $3$ 个高斯-勒让德节点上计算 $u(x,\\xi_k)$，并通过投影得到 $u_0,u_1,u_2$。\n- 对于算子不依赖于 $\\xi$ 且 $f(x,\\xi)=f_0(x)+\\xi f_1(x)$ 的情况，计算侵入式gPC系数 $u_0,u_1,u_2$。\n- 对于算子为 $a(\\xi)K$ 且力项为 $f_0(x)$（载荷中不含 $\\xi$）的情况，计算非侵入式和侵入式gPC系数。\n- 通过报告拼接系数向量差的相对2-范数来比较这些系数。\n\n使用以下测试套件（所有函数均为无量纲；无需角度）：\n1. 理想情况：$N=8$，$\\sigma=20$，$f_0(x)=\\sin(\\pi x)$，$f_1(x)=\\cos(2\\pi x)$。算子不依赖于 $\\xi$。计算非侵入式和侵入式系数之间差值的相对2-范数。\n2. 仿射算子缩放：$N=8$，$\\sigma=20$，$a(\\xi)=1+0.5\\,\\xi$，$f_0(x)=\\sin(\\pi x)$，$f_1(x)=0$。将非侵入式投影系数与来自耦合系统的侵入式系数进行比较，并报告相对2-范数差值。\n3. 确定性边界情况：$N=8$，$\\sigma=20$，$f_0(x)=\\sin(\\pi x)$，$f_1(x)=0$。算子不依赖于 $\\xi$。报告非侵入式和侵入式系数之间的相对2-范数差值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"）。每个结果必须是一个浮点数。忠实地实现SIPG组装，包括内部面一致性项和罚项，以及通过罚函数弱施加的齐次Dirichlet边界。并使用精确的 $3$ 点高斯-勒让德节点和权重进行随机配置和投影，同时对期望值使用正确的密度因子 $\\frac{1}{2}$。", "solution": "该问题要求推导求解随机边值问题的数值方法，然后通过一个实现来在特定测试用例上比较这些方法。核心数值方法是用于空间离散化的对称内罚间断Galerkin (SIPG) 方法和用于随机维度的广义多项式混沌 (gPC) 展开，通过非侵入式和侵入式两种途径处理。\n\n### 理论推导\n\n#### 1. SIPG离散化\n问题是在 $\\Omega=[0,1]$ 上的一维泊松方程 $-\\frac{d^2u}{dx^2} = f$，边界条件为齐次Dirichlet条件 $u(0)=u(1)=0$。区域被划分为 $N$ 个长度为 $h=1/N$ 的单元 $K_j=[x_j, x_{j+1}]$。近似解 $u_h$ 在次数为 $p=1$ 的分片多项式空间 $V_h$ 中寻找。\n\nSIPG弱形式为：寻找 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$：\n$$B_h(u_h, v_h) = L_h(v_h)$$\n双线性形式 $B_h(u,v)$ 和线性形式 $L_h(v)$ 定义如下：\n$$B_h(u,v) = \\sum_{j=1}^{N} \\int_{K_j} u'v' dx - \\sum_{F \\in \\mathcal{F}_I} \\int_F \\left( \\{u'\\} [v] + \\{v'\\} [u] \\right) ds + \\sum_{F \\in \\mathcal{F}_I} \\int_F \\frac{\\sigma}{h} [u][v] ds + B_{BC}(u,v)$$\n$$L_h(v) = \\int_0^1 f(x)v(x) dx$$\n这里，$\\mathcal{F}_I$ 是内部面（单元边界）的集合，$[u]=u_L-u_R$ 是跳跃项，$\\{u'\\}=(u'_L+u'_R)/2$ 是平均项。罚参数为 $\\sigma>0$。边界条件项 $B_{BC}(u,v)$ 弱施加 $u(0)=u(1)=0$：\n$$B_{BC}(u,v) = \\left( -u'v + \\frac{\\sigma}{h}uv \\right)\\Big|_{x=0} + \\left( u'v + \\frac{\\sigma}{h}uv \\right)\\Big|_{x=1}$$\n在 $V_h$ 的一个基中展开 $u_h$ 和 $v_h$，该公式导出一个矩阵系统 $K\\mathbf{u} = \\mathbf{b}$，其中 $K$ 是从 $B_h(\\cdot,\\cdot)$ 推导出的SIPG刚度矩阵，$\\mathbf{b}$ 是从 $L_h(\\cdot)$ 推导出的载荷向量。\n\n#### 2. 非侵入式随机配置 (NISC)\n解 $u(x,\\xi)$ 通过截断的gPC展开 $u(x,\\xi) \\approx \\sum_{n=0}^{2} u_n(x)\\psi_n(\\xi)$ 来近似。系数 $u_n(x)$ 通过投影确定：\n$$u_n(x) = \\mathbb{E}[u(x,\\xi)\\psi_n(\\xi)] = \\int_{-1}^{1} u(x,\\xi)\\psi_n(\\xi) \\rho(\\xi) d\\xi$$\n其中 $\\rho(\\xi)=1/2$ 是均匀概率密度。该积分使用求积法则进行近似。对于给定问题，要求对最高 $2$ 次多项式达到精确，因此选择 $3$ 点高斯-勒让德求积。节点 $\\{\\xi_k\\}_{k=1}^3$ 是勒让德多项式 $P_3(\\xi)$ 的根，而 $\\{w_k\\}_{k=1}^3$ 是在 $[-1,1]$ 上对权函数为 $1$ 的积分所对应的权重。投影公式变为：\n$$u_n(x) \\approx \\frac{1}{2} \\int_{-1}^{1} u(x,\\xi)\\psi_n(\\xi) d\\xi \\approx \\frac{1}{2} \\sum_{k=1}^{3} w_k u(x, \\xi_k) \\psi_n(\\xi_k)$$\n这与问题陈述中指定的公式相符。该算法是非侵入式的，因为它将确定性求解器视为一个黑箱：\n1.  对每个配置节点 $\\xi_k$，求解确定性DG问题 $K\\mathbf{u}(\\xi_k) = \\mathbf{b}(\\xi_k)$ 以找到解向量 $\\mathbf{u}(\\xi_k)$。\n2.  使用求积公式计算系数向量 $\\mathbf{u}_n$：$\\mathbf{u}_n = \\frac{1}{2} \\sum_{k=1}^{3} w_k \\mathbf{u}(\\xi_k) \\psi_n(\\xi_k)$。\n\n#### 3. 侵入式Galerkin投影\n\n侵入式方法在随机空间中应用Galerkin投影。弱形式为 $\\mathbb{E}[B_h(u, v\\psi_m)] = \\mathbb{E}[L_h(v\\psi_m)]$，其中 $m=0,1,2$。\n\n**情况1：确定性算子，随机右端项**\n算子是确定性的，因此 $B_h(u,v;\\xi) = B_h(u,v)$。右端项是 $f(x,\\xi)=f_0(x)+\\xi f_1(x)$。\n将gPC展开 $u=\\sum_n u_n\\psi_n$ 代入弱形式：\n$$\\sum_{n=0}^{2} B_h(u_n, v) \\mathbb{E}[\\psi_n\\psi_m] = \\mathbb{E}[L_h(f_0+\\xi f_1, v)\\psi_m]$$\n根据标准正交性，$\\mathbb{E}[\\psi_n\\psi_m]=\\delta_{nm}$，因此系统解耦：\n$$B_h(u_m, v) = \\mathbb{E}[(L_h(f_0,v) + \\xi L_h(f_1,v))\\psi_m] = L_h(f_0,v)\\mathbb{E}[\\psi_m] + L_h(f_1,v)\\mathbb{E}[\\xi\\psi_m]$$\n我们计算期望值：$\\mathbb{E}[\\psi_0]=1$, $\\mathbb{E}[\\psi_1]=0$, $\\mathbb{E}[\\psi_2]=0$。使用恒等式 $\\xi = \\psi_1/\\sqrt{3}$，我们发现 $\\mathbb{E}[\\xi\\psi_0]=0$, $\\mathbb{E}[\\xi\\psi_1]=\\mathbb{E}[\\psi_1^2/\\sqrt{3}]=1/\\sqrt{3}$，以及 $\\mathbb{E}[\\xi\\psi_2]=0$。\n这导致了如下解耦的系统：\n- 对于 $m=0$：$B_h(u_0, v) = L_h(f_0,v) \\implies K\\mathbf{u}_0 = \\mathbf{b}_0$。\n- 对于 $m=1$：$B_h(u_1, v) = L_h(f_1,v)/\\sqrt{3} \\implies K\\mathbf{u}_1 = \\mathbf{b}_1/\\sqrt{3}$。\n- 对于 $m=2$：$B_h(u_2, v) = 0 \\implies K\\mathbf{u}_2 = \\mathbf{0}$。\n\n**情况2：随机算子，确定性右端项**\n方程为 $-\\frac{d}{dx}(a(\\xi)u') = f_0(x)$，其中 $a(\\xi)=a_0+a_1\\xi$。双线性形式为 $B_h(u,v;\\xi) = a(\\xi)B_h^{det}(u,v)$，其中 $B_h^{det}$ 是确定性形式。弱形式为：\n$$\\sum_{n=0}^{2} B_h^{det}(u_n, v) \\mathbb{E}[a(\\xi)\\psi_n\\psi_m] = L_h(f_0,v)\\mathbb{E}[\\psi_m]$$\n右端项仅在 $m=0$ 时非零，此时为 $L_h(f_0,v)$。以矩阵形式表示，这产生了一个耦合块系统：\n$$\\sum_{n=0}^{2} (\\mathbf{M}_a)_{mn} K \\mathbf{u}_n = \\delta_{m0} \\mathbf{f}_0$$\n其中 $K$ 是来自 $B_h^{det}$ 的矩阵，$\\mathbf{f}_0$ 来自 $L_h(f_0,v)$，且 $(\\mathbf{M}_a)_{mn} = \\mathbb{E}[a(\\xi)\\psi_n\\psi_m]$。这等价于克罗内克积形式 $(\\mathbf{M}_a \\otimes K)\\mathbf{U} = \\mathbf{e}_0 \\otimes \\mathbf{f}_0$。\n\n### 实现计划\n实现将按以下步骤进行：\n1.  **SIPG组装**：一个函数将为给定的函数 $f$ 组装稀疏SIPG刚度矩阵 $K$ 和载荷向量 $\\mathbf{b}$。载荷向量的积分将使用高精度数值求积（`scipy.integrate.quad`）来满足“精确积分”的假设。\n2.  **测试用例1**：\n    -   *侵入式*：求解三个解耦系统以获得 $\\mathbf{u}_0, \\mathbf{u}_1, \\mathbf{u}_2$。\n    -   *非侵入式*：在三个高斯-勒让德节点 $\\{\\xi_k\\}$ 处求解确定性DG问题，并投影解以获得 $\\mathbf{u}_0, \\mathbf{u}_1, \\mathbf{u}_2$。\n    -   计算拼接解向量之间差值的相对2-范数。由于精确解 $u(x,\\xi)$ 是 $\\xi$ 的仿射函数，并且gPC展开在足够高的阶数处截断，所以 $3$ 点配置方法是精确的，差异应接近机器精度。\n3.  **测试用例2**：\n    -   *侵入式*：组装耦合矩阵 $\\mathbf{M}_a$ 和全局块矩阵 $\\mathbf{M}_a \\otimes K$。求解耦合系统以获得系数的堆叠向量 $\\mathbf{U}$。\n    -   *非侵入式*：在每个配置节点 $\\xi_k$ 处，组装缩放后的刚度矩阵 $a(\\xi_k)K$ 并求解确定性问题。投影结果。\n    -   计算相对2-范数差值。在这里，真实解是 $\\xi$ 的有理函数，因此NISC方法不是精确的，预计会有非零差异。\n4.  **测试用例3**：\n    -   这是一个确定性问题（$f_1=0$），用作健全性检查。侵入式和非侵入式方法都应得出 $\\mathbf{u}_1=\\mathbf{0}$ 和 $\\mathbf{u}_2=\\mathbf{0}$，其中 $\\mathbf{u}_0$ 是标准的确定性DG解。差异应接近于零。\n\n三个测试用例的结果将被收集并以指定格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, kron\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.integrate import quad\n\ndef assemble_sipg_stiffness(N, sigma):\n    \"\"\"\n    Assembles the SIPG stiffness matrix for the 1D negative Laplacian.\n    \"\"\"\n    h = 1.0 / N\n    num_dofs = 2 * N\n    K = lil_matrix((num_dofs, num_dofs))\n\n    # Volume term: integral of u' v' over each element\n    local_K_vol = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    for j in range(N):\n        dof1, dof2 = 2 * j, 2 * j + 1\n        K[dof1:dof2 + 1, dof1:dof2 + 1] += local_K_vol\n\n    # Interior face terms\n    for j in range(1, N):\n        dof_L2 = 2 * (j - 1) + 1\n        dof_R1 = 2 * j\n        \n        # Diagonal contributions\n        K[dof_L2, dof_L2] += -1.0 / h + sigma / h\n        K[dof_R1, dof_R1] += -1.0 / h + sigma / h\n        \n        # Off-diagonal contributions\n        K[dof_L2, dof_R1] += 1.0 / h - sigma / h\n        K[dof_R1, dof_L2] += 1.0 / h - sigma / h\n\n    # Boundary face terms (homogeneous Dirichlet)\n    # At x=0\n    K[0, 0] += 1.0 / h + sigma / h\n    # At x=1\n    K[num_dofs - 1, num_dofs - 1] += 1.0 / h + sigma / h\n\n    return K.tocsc()\n\ndef assemble_load_vector(N, f_func):\n    \"\"\"\n    Assembles the load vector using high-precision numerical quadrature.\n    \"\"\"\n    h = 1.0 / N\n    num_dofs = 2 * N\n    b = np.zeros(num_dofs)\n    for j in range(N):\n        x_j, x_jp1 = j * h, (j + 1) * h\n        \n        # Contribution to the first basis function of element j\n        integrand1 = lambda x: f_func(x) * (x_jp1 - x) / h\n        b[2 * j], _ = quad(integrand1, x_j, x_jp1, epsabs=1e-12, epsrel=1e-12)\n        \n        # Contribution to the second basis function of element j\n        integrand2 = lambda x: f_func(x) * (x - x_j) / h\n        b[2 * j + 1], _ = quad(integrand2, x_j, x_jp1, epsabs=1e-12, epsrel=1e-12)\n        \n    return b\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three test cases.\n    \"\"\"\n    test_cases = [\n        {'type': 1, 'N': 8, 'sigma': 20, 'f0': lambda x: np.sin(np.pi * x), 'f1': lambda x: np.cos(2 * np.pi * x)},\n        {'type': 2, 'N': 8, 'sigma': 20, 'a_func': lambda xi: 1.0 + 0.5 * xi, 'f0': lambda x: np.sin(np.pi * x)},\n        {'type': 3, 'N': 8, 'sigma': 20, 'f0': lambda x: np.sin(np.pi * x), 'f1': lambda x: 0.0}\n    ]\n\n    results = []\n\n    # gPC and Collocation setup\n    sqrt3 = np.sqrt(3.0)\n    sqrt5 = np.sqrt(5.0)\n    psi = [\n        lambda xi: 1.0,\n        lambda xi: sqrt3 * xi,\n        lambda xi: (sqrt5 / 2.0) * (3.0 * xi**2 - 1.0)\n    ]\n    \n    # 3-point Gauss-Legendre nodes and weights on [-1, 1]\n    xi_k = np.array([-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)])\n    w_k = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n    \n    # Pre-evaluate psi_n(xi_k)\n    psi_vals = np.array([[p(x) for x in xi_k] for p in psi])\n\n    for case in test_cases:\n        N = case['N']\n        sigma = case['sigma']\n        num_dofs = 2 * N\n        \n        K_det = assemble_sipg_stiffness(N, sigma)\n\n        if case['type'] == 1 or case['type'] == 3:\n            f0, f1 = case['f0'], case['f1']\n            b0 = assemble_load_vector(N, f0)\n            b1 = assemble_load_vector(N, f1)\n\n            # Intrusive solution\n            u0_intr = spsolve(K_det, b0)\n            u1_intr = spsolve(K_det, b1 / sqrt3)\n            u2_intr = np.zeros(num_dofs)\n            u_intr = np.concatenate([u0_intr, u1_intr, u2_intr])\n            \n            # Nonintrusive solution\n            u_at_nodes = []\n            for xi in xi_k:\n                f_k = lambda x: f0(x) + xi * f1(x)\n                b_k = assemble_load_vector(N, f_k)\n                u_k = spsolve(K_det, b_k)\n                u_at_nodes.append(u_k)\n            u_at_nodes = np.array(u_at_nodes)\n            \n            u_nisc_coeffs = []\n            for n in range(3):\n                u_n = np.sum(0.5 * w_k * psi_vals[n] * u_at_nodes.T, axis=1)\n                u_nisc_coeffs.append(u_n)\n            u_nisc = np.concatenate(u_nisc_coeffs)\n            \n        elif case['type'] == 2:\n            a_func = case['a_func']\n            f0 = case['f0']\n            f0_vec = assemble_load_vector(N, f0)\n\n            # Intrusive solution\n            a0, a1 = 1.0, 0.5\n            sqrt15 = np.sqrt(15.0)\n            C = np.array([\n                [0.0, 1.0/sqrt3, 0.0],\n                [1.0/sqrt3, 0.0, 2.0/sqrt15],\n                [0.0, 2.0/sqrt15, 0.0]\n            ])\n            M_a = a0 * np.eye(3) + a1 * C\n            \n            M_a_kron_K = kron(M_a, K_det)\n            \n            rhs_stacked = np.zeros(3 * num_dofs)\n            rhs_stacked[:num_dofs] = f0_vec\n            \n            u_intr = spsolve(M_a_kron_K, rhs_stacked)\n\n            # Nonintrusive solution\n            u_at_nodes = []\n            for xi in xi_k:\n                a_k = a_func(xi)\n                K_k = a_k * K_det\n                u_k = spsolve(K_k, f0_vec)\n                u_at_nodes.append(u_k)\n            u_at_nodes = np.array(u_at_nodes)\n\n            u_nisc_coeffs = []\n            for n in range(3):\n                u_n = np.sum(0.5 * w_k * psi_vals[n] * u_at_nodes.T, axis=1)\n                u_nisc_coeffs.append(u_n)\n            u_nisc = np.concatenate(u_nisc_coeffs)\n\n        # Comparison\n        norm_intr = np.linalg.norm(u_intr)\n        if norm_intr == 0:\n            rel_diff = np.linalg.norm(u_nisc - u_intr)\n        else:\n            rel_diff = np.linalg.norm(u_nisc - u_intr) / norm_intr\n            \n        results.append(rel_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3403720"}, {"introduction": "基于多项式的标准配置方法在解对随机参数的依赖关系是光滑时表现最佳。然而，在许多实际问题中，例如涉及激波或相变的系统，这种光滑性假设并不成立。本练习将带您探索一个更具挑战性的场景——带有随机初值的无粘性Burgers方程，其解在参数空间中会产生不连续性。通过对比全局配置方法与更先进的分区（多单元）配置方法，您将亲手验证自适应地划分参数空间如何能够显著提高计算精度，并掌握处理非光滑问题的前沿技术。", "problem": "考虑在周期性空间域 $[0,1]$ 和时间 $t \\ge 0$ 上的无粘性标量守恒律，即伯格斯方程（Burgers equation），\n$$\n\\partial_t u(x,t;\\xi) + \\partial_x \\left( \\tfrac{1}{2} u(x,t;\\xi)^2 \\right) = 0,\n$$\n其初始条件为\n$$\nu(x,0;\\xi) = \\xi \\sin(2\\pi x),\n$$\n其中 $\\xi$ 是一个标量参数，被建模为一个在 $[0,1]$ 上均匀分布的随机变量。对于固定的空间位置 $x^\\star \\in [0,1]$ 和固定的时间 $t>0$，我们关注的量是参数到解的映射 $\\xi \\mapsto u(x^\\star,t;\\xi)$ 以及期望\n$$\n\\mathbb{E}[u(x^\\star,t)] = \\int_0^1 u(x^\\star,t;\\xi) \\, d\\xi.\n$$\n\n无粘性伯格斯方程的基本理论表明，激波在第一时间 $t_s(\\xi)$ 形成，其值为\n$$\nt_s(\\xi) = -\\frac{1}{\\min_{x \\in [0,1]} \\partial_x u(x,0;\\xi)} = \\frac{1}{2\\pi \\xi},\n$$\n该时间由特征线法得到，其中解的梯度演化遵循 $\\partial_x u(x(t),t) = \\frac{\\partial_x u(x_0,0)}{1 + t \\, \\partial_x u(x_0,0)}$，当 $1 + t \\, \\partial_x u(x_0,0) = 0$ 时会发生爆破。对于任意固定的 $t>0$，定义临界阈值\n$$\n\\xi_c(t) = \\min\\left\\{1, \\frac{1}{2\\pi t}\\right\\}.\n$$\n那么，对于 $\\xi \\in [0,\\xi_c(t)]$，解在时间 $t$ 是光滑的；而对于 $\\xi \\in (\\xi_c(t),1]$，解在时间 $t$ 之前已经形成了激波。因此，映射 $\\xi \\mapsto u(x^\\star,t;\\xi)$ 在 $\\xi=\\xi_c(t)$ 处表现出正则性降低。\n\n非侵入式随机配置法（Nonintrusive stochastic collocation）通过在参数空间中的求积点上计算确定性解 $u(x^\\star,t;\\xi)$，并与相应的权重求和来近似 $\\mathbb{E}[u(x^\\star,t)]$。当参数映射非光滑时，在 $[0,1]$ 上的全局多项式配置会遭遇精度下降的问题。一种补救方法是将参数空间划分为两个单元，\n$$\n\\mathcal{E}_1 = [0,\\xi_c(t)], \\quad \\mathcal{E}_2 = (\\xi_c(t),1],\n$$\n并在每个单元上分别执行局部配置，然后将贡献相加以获得期望。\n\n您的任务是实现并比较以下两种用于计算 $\\mathbb{E}[u(x^\\star,t)]$ 的非侵入式随机配置估计器：\n\n1. 在 $[0,1]$ 上使用 $N_g$ 个点的全局高斯-勒让德（Gauss–Legendre）配置：\n$$\n\\mathbb{E}_{\\mathrm{global}}[u(x^\\star,t)] \\approx \\sum_{j=1}^{N_g} w_j^{(g)} \\, u(x^\\star,t;\\xi_j^{(g)}),\n$$\n其中 $\\{(\\xi_j^{(g)}, w_j^{(g)})\\}_{j=1}^{N_g}$ 是从 $[-1,1]$ 映射到 $[0,1]$ 的高斯-勒让德节点和权重。\n\n2. 在 $\\mathcal{E}_1$ 上使用 $N_1$ 个点、在 $\\mathcal{E}_2$ 上使用 $N_2$ 个点的双单元分区高斯-勒让德配置：\n$$\n\\mathbb{E}_{\\mathrm{local}}[u(x^\\star,t)] \\approx \\sum_{j=1}^{N_1} w_j^{(1)} \\, u(x^\\star,t;\\xi_j^{(1)}) + \\sum_{k=1}^{N_2} w_k^{(2)} \\, u(x^\\star,t;\\xi_k^{(2)}),\n$$\n其中 $\\{(\\xi_j^{(1)}, w_j^{(1)})\\}_{j=1}^{N_1}$ 和 $\\{(\\xi_k^{(2)}, w_k^{(2)})\\}_{k=1}^{N_2}$ 分别是映射到子区间 $\\mathcal{E}_1$ 和 $\\mathcal{E}_2$ 的高斯-勒让德节点和权重。在 $\\xi_c(t) \\le 0$ 或 $\\xi_c(t) \\ge 1$ 的退化情况下，按显而易见的方式解释分区（即一个单元的测度为零）。\n\n对于每个在配置点 $\\xi$ 处所需的计算 $u(x^\\star,t;\\xi)$，您必须使用守恒型有限体积法将确定性伯格斯方程求解至时间 $t$，该方法采用周期性边界条件、Rusanov 数值通量\n$$\n\\widehat{f}(u_L,u_R) = \\frac{1}{2}\\left(\\tfrac{1}{2}u_L^2 + \\tfrac{1}{2}u_R^2\\right) - \\frac{1}{2} a_{\\max} (u_R - u_L), \\quad a_{\\max} = \\max\\{|u_L|,|u_R|\\},\n$$\n并使用二阶总变差不增（total variation diminishing）龙格-库塔（Runge–Kutta）法进行时间积分。使用一个 Courant–Friedrichs–Lewy 数 $C \\in (0,1)$ 来根据下式自适应地设置时间步长\n$$\n\\Delta t = C \\frac{\\Delta x}{\\max_i |u_i|},\n$$\n并设置一个合适的上限，以避免在 $\\max_i |u_i|$ 很小时步长过大。使用 $u(x,0;\\xi)$ 在均匀单元中心的单元平均值进行初始化，并演化至时间 $t$。最终值 $u(x^\\star,t;\\xi)$ 应通过在最接近 $x^\\star$ 的网格点上进行最近单元求值来获得。所有量都是无量纲的；不需要物理单位。\n\n通过在 $[0,1]$ 上使用 $N_{\\mathrm{ref}}$ 个点的高阶高斯-勒让德求积，并使用相同的确定性求解器，来定义参考值 $\\mathbb{E}_{\\mathrm{ref}}[u(x^\\star,t)]$。\n\n测试套件。使用以下四个测试用例，每个用例指定为一个元组 $(t, N_x, N_g, N_1, N_2)$：\n- 用例 1：$(0.4, 256, 8, 4, 4)$\n- 用例 2：$(0.4, 256, 12, 6, 6)$\n- 用例 3：$(0.1, 256, 8, 4, 4)$\n- 用例 4：$(1.5, 256, 8, 4, 4)$\n\n在所有情况下，设置 $x^\\star = 0.25$，$C = 0.4$，以及 $N_{\\mathrm{ref}} = 64$。对于每个用例，计算绝对误差\n$$\ne_{\\mathrm{global}} = \\left| \\mathbb{E}_{\\mathrm{global}}[u(x^\\star,t)] - \\mathbb{E}_{\\mathrm{ref}}[u(x^\\star,t)] \\right|, \\quad\ne_{\\mathrm{local}}  = \\left| \\mathbb{E}_{\\mathrm{local}}[u(x^\\star,t)] - \\mathbb{E}_{\\mathrm{ref}}[u(x^\\star,t)] \\right|.\n$$\n对于每个用例，如果 $e_{\\mathrm{local}}  e_{\\mathrm{global}}$，则输出整数 $1$，否则输出 $0$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[1,0,1,1]”）。", "solution": "问题陈述经评估有效。这是一个适定、有科学依据且客观的数值实验。该问题要求比较两种非侵入式随机配置方案，用于计算与具有随机初始条件的无粘性伯格斯方程相关的关注量的期望值。其底层数学模型（伯格斯方程）、激波形成现象、通过随机配置进行不确定性量化的原理，以及指定的数值方法（有限体积法、Rusanov 通量、TVD-RK2）在计算流体动力学和科学计算领域都是标准且成熟的。参数和测试用例定义清晰，任务在计算上是可行的。不存在矛盾、模糊之处或事实性错误。\n\n这个问题的核心在于计算一个依赖于参数的偏微分方程（PDE）解的泛函的期望：\n$$\n\\mathbb{E}[u(x^\\star,t)] = \\int_0^1 u(x^\\star,t;\\xi) \\rho(\\xi) \\, d\\xi,\n$$\n其中 $\\xi$ 是一个概率密度函数为 $\\rho(\\xi)$ 的随机变量。对于本问题，$\\xi$ 在 $[0,1]$ 上均匀分布，因此 $\\rho(\\xi) = 1$。该积分变成了一个关于参数到解的映射 $g(\\xi) = u(x^\\star,t;\\xi)$ 的标准定积分。\n\n非侵入式随机配置法使用数值求积法则来近似这个积分：\n$$\n\\mathbb{E}[g(\\xi)] \\approx \\sum_{j=1}^{N} w_j g(\\xi_j),\n$$\n其中 $\\{\\xi_j\\}_{j=1}^N$ 是配置点（或求积节点），$\\{w_j\\}_{j=1}^N$ 是相应的求积权重。术语“非侵入式”意味着该方法将确定性 PDE 求解器视为一个黑箱，仅需要在指定的点 $\\xi_j$ 上对其进行求值。\n\n这种近似的精度关键取决于被积函数 $g(\\xi)$ 的光滑性。对于基于多项式的求积方案，例如指定的高斯-勒让德求积，如果 $g(\\xi)$ 是解析的或至少是 $C^\\infty$ 的，就可以实现快速（谱）收敛。然而，问题陈述正确地指出，被积函数 $g(\\xi) = u(x^\\star,t;\\xi)$ 并非全局光滑。无粘性伯格斯方程的解会在一个取决于参数 $\\xi$ 的时间 $t_s(\\xi)$ 产生激波。具体来说，$t_s(\\xi) = (2\\pi\\xi)^{-1}$。对于一个固定的时间 $t$，解的定性行为在一个临界参数值 $\\xi_c(t) = (2\\pi t)^{-1}$ 处发生改变。对于 $\\xi  \\xi_c(t)$，解在时间 $t$ 是光滑的；而对于 $\\xi > \\xi_c(t)$，激波已经形成。这种转变在映射 $\\xi \\mapsto u(x^\\star,t;\\xi)$ 中于 $\\xi = \\xi_c(t)$ 处引入了一个“扭结”（一个 C1 间断点，或更差的情况）。\n\n在`global`估计器中使用的全局多项式近似难以精确表示具有此类扭结的函数。这导致求积误差收敛缓慢，这一现象类似于傅里叶级数中的吉布斯现象。`local`或“多单元”配置法旨在克服这个问题。通过在非光滑点 $\\xi_c(t)$ 处将参数域 $[0,1]$ 划分为两个子域 $\\mathcal{E}_1 = [0, \\xi_c(t)]$ 和 $\\mathcal{E}_2 = (\\xi_c(t), 1]$，积分被拆分为：\n$$\n\\int_0^1 g(\\xi) \\, d\\xi = \\int_0^{\\xi_c(t)} g(\\xi) \\, d\\xi + \\int_{\\xi_c(t)}^1 g(\\xi) \\, d\\xi.\n$$\n被积函数 $g(\\xi)$ 在每个子域内都是光滑的。对每个积分分别应用高斯-勒让德求积并将结果相加，可以规避全局非光滑性问题，从而恢复求积的高阶精度。本问题旨在证明，当函数求值总次数保持不变或相近时，这种分区方法的精度更高。\n\n为了计算 $g(\\xi_j) = u(x^\\star, t; \\xi_j)$，需要一个用于确定性伯格斯方程的数值求解器。问题指定了一个守恒型有限体积法，这对于允许不连续（激波）解的双曲守恒律来说是一个合适的选择。该方法对解的单元平均值进行操作。空间算子使用 Rusanov 数值通量进行离散化，这是一种简单而稳健的通量，能提供必要的数值耗散来捕捉激波而无虚假振荡。时间积分使用二阶总变差不增（TVD）龙格-库塔格式，这是一种强稳定性保持（SSP）方法，旨在离散化双曲 PDE 时保持稳定性和非振荡性。时间步长 $\\Delta t$ 基于 Courant-Friedrichs-Lewy（CFL）条件自适应选择，以确保数值稳定性。\n\n总体算法如下：\n1.  实现一个函数，用于生成映射到任意区间 $[a,b]$ 的高斯-勒让德节点和权重。\n2.  实现伯格斯方程的确定性有限体积求解器，该求解器以 $\\xi$ 和 $t$ 作为输入，并返回在 $x^\\star$ 处的解。\n3.  对每个测试用例，计算临界参数 $\\xi_c(t)$。\n4.  使用 $[0,1]$ 上的大量求积点计算一个高精度的参考解 $\\mathbb{E}_{\\mathrm{ref}}$。\n5.  使用 $[0,1]$ 上的 $N_g$ 个点计算全局估计 $\\mathbb{E}_{\\mathrm{global}}$。\n6.  通过在 $[0, \\xi_c(t)]$ 上应用 $N_1$ 个点的求积和在 $[\\xi_c(t), 1]$ 上应用 $N_2$ 个点的求积，并将结果相加，来计算局部估计 $\\mathbb{E}_{\\mathrm{local}}$。对于 $\\xi_c(t) \\ge 1$（即对于任何 $\\xi \\in [0,1]$ 都没有激波）的退化情况，通过在 $[0,1]$ 上执行单个求积来处理。\n7.  计算相对于 $\\mathbb{E}_{\\mathrm{ref}}$ 的绝对误差 $e_{\\mathrm{global}}$ 和 $e_{\\mathrm{local}}$，并确定是否 $e_{\\mathrm{local}}  e_{\\mathrm{global}}$。\n\n这个数值实验将展示在随机配置方法中，当底层模型响应非光滑时，自适应地划分参数空间的有效性。", "answer": "```python\nimport numpy as np\nimport math\n\ndef get_gauss_quadrature(N, interval):\n    \"\"\"\n    Computes Gauss-Legendre nodes and weights on a given interval.\n    \n    Args:\n        N (int): Number of quadrature points.\n        interval (list or tuple): The interval [a, b].\n    \n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The quadrature nodes.\n            - np.ndarray: The quadrature weights.\n    \"\"\"\n    if N == 0:\n        return np.array([]), np.array([])\n    a, b = interval\n    # Get standard nodes and weights on [-1, 1]\n    z, w_hat = np.polynomial.legendre.leggauss(N)\n    # Map nodes to [a, b]\n    nodes = 0.5 * (b - a) * z + 0.5 * (a + b)\n    # Map weights to [a, b]\n    weights = 0.5 * (b - a) * w_hat\n    return nodes, weights\n\ndef compute_rhs(u, dx):\n    \"\"\"\n    Computes the right-hand side of the semi-discretized Burgers' equation,\n    L(u) = - (f_{i+1/2} - f_{i-1/2}) / dx, using Rusanov flux.\n    \"\"\"\n    # Periodic boundary conditions by rolling the array\n    u_L = u\n    u_R = np.roll(u, -1)\n\n    # Physical flux F(u) = 0.5 * u^2\n    flux_phys_L = 0.5 * u_L**2\n    flux_phys_R = 0.5 * u_R**2\n\n    # Rusanov flux: F_hat(u_L, u_R)\n    a_max = np.maximum(np.abs(u_L), np.abs(u_R))\n    flux_num_iph = 0.5 * (flux_phys_L + flux_phys_R) - 0.5 * a_max * (u_R - u_L)\n\n    # Flux at i-1/2 by rolling the i+1/2 flux array\n    flux_num_imh = np.roll(flux_num_iph, 1)\n\n    # RHS_i = -(flux_{i+1/2} - flux_{i-1/2}) / dx\n    rhs = -(flux_num_iph - flux_num_imh) / dx\n    return rhs\n\ndef solve_burgers_fv(xi, t_final, Nx, C, x_star):\n    \"\"\"\n    Solves the deterministic 1D Burgers' equation using a finite volume method.\n    \"\"\"\n    dx = 1.0 / Nx\n    x_centers = dx * (np.arange(Nx) + 0.5)\n\n    # Initial condition: u(x,0) = xi * sin(2*pi*x) at cell centers\n    u = xi * np.sin(2.0 * math.pi * x_centers)\n    t_curr = 0.0\n\n    # TVD-RK2 time integration\n    while t_curr  t_final:\n        max_abs_u = np.max(np.abs(u))\n        # Prevent division by zero and excessively large dt\n        dt_cfl = C * dx / max(max_abs_u, 1e-9)\n        dt = min(dt_cfl, t_final - t_curr)\n\n        # Stage 1\n        rhs1 = compute_rhs(u, dx)\n        u1 = u + dt * rhs1\n\n        # Stage 2\n        rhs2 = compute_rhs(u1, dx)\n        u = 0.5 * u + 0.5 * u1 + 0.5 * dt * rhs2\n\n        t_curr += dt\n\n    # Find the value at the cell closest to x_star\n    idx_star = int(round(x_star / dx - 0.5))\n    return u[idx_star]\n\ndef compute_expectation(nodes, weights, t_final, Nx, C, x_star):\n    \"\"\"\n    Computes the expectation by summing up solutions at given collocation points.\n    \"\"\"\n    expectation = 0.0\n    for xi_j, w_j in zip(nodes, weights):\n        u_val = solve_burgers_fv(xi_j, t_final, Nx, C, x_star)\n        expectation += w_j * u_val\n    return expectation\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compare collocation methods.\n    \"\"\"\n    test_cases = [\n        # (t, Nx, Ng, N1, N2)\n        (0.4, 256, 8, 4, 4),\n        (0.4, 256, 12, 6, 6),\n        (0.1, 256, 8, 4, 4),\n        (1.5, 256, 8, 4, 4),\n    ]\n\n    x_star = 0.25\n    C = 0.4\n    N_ref = 64\n\n    results = []\n\n    for case in test_cases:\n        t, Nx, Ng, N1, N2 = case\n\n        # --- Reference expectation ---\n        ref_nodes, ref_weights = get_gauss_quadrature(N_ref, [0.0, 1.0])\n        E_ref = compute_expectation(ref_nodes, ref_weights, t, Nx, C, x_star)\n\n        # --- Global collocation ---\n        global_nodes, global_weights = get_gauss_quadrature(Ng, [0.0, 1.0])\n        E_global = compute_expectation(global_nodes, global_weights, t, Nx, C, x_star)\n\n        # --- Local (partitioned) collocation ---\n        xi_c = min(1.0, 1.0 / (2.0 * math.pi * t))\n        \n        E_local = 0.0\n        # If xi_c >= 1, the function is smooth on [0,1]. E2 is empty.\n        if xi_c >= 1.0:\n            nodes1, weights1 = get_gauss_quadrature(N1, [0.0, 1.0])\n            E_local = compute_expectation(nodes1, weights1, t, Nx, C, x_star)\n        # If xi_c  1 and t > 0, the kink is inside (0,1).\n        else:\n            # Element 1: [0, xi_c]\n            nodes1, weights1 = get_gauss_quadrature(N1, [0.0, xi_c])\n            E1 = compute_expectation(nodes1, weights1, t, Nx, C, x_star)\n            \n            # Element 2: [xi_c, 1]\n            nodes2, weights2 = get_gauss_quadrature(N2, [xi_c, 1.0])\n            E2 = compute_expectation(nodes2, weights2, t, Nx, C, x_star)\n\n            E_local = E1 + E2\n\n        # --- Compare errors ---\n        e_global = abs(E_global - E_ref)\n        e_local = abs(E_local - E_ref)\n\n        results.append(1 if e_local  e_global else 0)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3403658"}]}