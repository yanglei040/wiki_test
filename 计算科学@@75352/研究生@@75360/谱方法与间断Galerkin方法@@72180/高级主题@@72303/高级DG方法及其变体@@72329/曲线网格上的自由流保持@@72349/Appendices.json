{"hands_on_practices": [{"introduction": "这第一个实践聚焦于静止网格上自由流保持的核心：离散几何守恒律（GCL）。你将亲手实现谱方法的基本构建模块——高斯-洛巴托-勒让德（GLL）节点和微分矩阵——来数值验证一个关键的度量恒等式 [@problem_id:3388173]。本练习将展示，当使用可交换的张量积微分算子来一致地定义度量项时，几何通量的离散散度将恒等于零，这为精确的曲线坐标系模拟奠定了基础。", "problem": "构建一个独立的程序，在单个参考四边形上，为曲线映射实现 Vinokur 离散度量定义，并验证与分部求和（SBP）兼容的离散度量恒等式。当每个坐标方向使用相同的张量积 SBP 算子时，该恒等式保证了自由流守恒。工作完全在二维空间中进行。设参考单元为 $[-1,1]^2$，计算坐标为 $(\\xi,\\eta) \\in [-1,1]^2$，并存在一个到物理空间的光滑映射 $(x(\\xi,\\eta),y(\\xi,\\eta))$。使用一个基于节点的谱配置分部求和（SBP）算子，该算子由每个坐标上多项式次数为 $p$ 的 Gauss–Lobatto–Legendre (GLL) 节点构建，并采用规范对角 SBP 范数。一维节点必须包含端点，微分矩阵必须是这些节点上的标准重心拉格朗日微分矩阵。二维算子由张量积形成。\n\n需要实现的定义：\n- GLL 节点上的一维 SBP 微分矩阵 $D \\in \\mathbb{R}^{(p+1)\\times(p+1)}$ 必须使用这些节点上的重心权重来构建。张量网格上的二维算子为 $D_\\xi = D \\otimes I$ 和 $D_\\eta = I \\otimes D$，其中 $I$ 是大小为 $p+1$ 的单位矩阵，$\\otimes$ 表示克罗内克积。\n- 在两个方向上使用相同的 SBP 算子，在节点网格上定义 Vinokur 离散度量分量：\n  $G_{11} = y_\\eta$，$G_{21} = -x_\\eta$，$G_{12} = -y_\\xi$，以及 $G_{22} = x_\\xi$，\n  其中下标表示通过张量积作用，使用 $D_\\xi$ 和 $D_\\eta$ 进行的离散求导。\n- 需要验证的与 SBP 兼容的离散度量恒等式是，每个逆变列的离散散度为零：\n  $r_x = D_\\xi G_{11} + D_\\eta G_{12}$ 和 $r_y = D_\\xi G_{21} + D_\\eta G_{22}$，\n  如果在两个方向上一致地使用相同的 SBP 算子，这两个表达式的计算结果应为零向量（在浮点舍入误差范围内）。\n\n您必须：\n- 对于给定的整多项式次数 $p \\ge 1$，使用 Newton 迭代法找到 $P_p'(\\xi)$ 的零点，从而构建一维 Gauss–Lobatto–Legendre (GLL) 节点和权重，其中 $P_p$ 是 $p$ 次勒让德多项式。在这些节点上构建重心拉格朗日微分矩阵 $D$。\n- 构建二维张量网格，并通过沿每个坐标方向的矩阵乘法应用离散导数。\n- 为 $(x(\\xi,\\eta),y(\\xi,\\eta))$ 实现两个映射族：\n  1. 一个由标量 $a$ 和 $b$ 参数化的正弦曲线映射：\n     $x(\\xi,\\eta) = \\xi + a \\sin(\\pi \\xi)\\sin(\\pi \\eta)$ 和 $y(\\xi,\\eta) = \\eta + b \\cos(\\pi \\xi)\\sin(\\pi \\eta)$，其中角度以弧度为单位。\n  2. 一个具有矩阵 $A \\in \\mathbb{R}^{2\\times 2}$ 和零平移的线性仿射映射：$\\begin{bmatrix} x \\\\ y \\end{bmatrix} = A \\begin{bmatrix} \\xi \\\\ \\eta \\end{bmatrix}$。\n\n对于下面的每个测试用例，计算最大无穷范数残差\n$r_{\\max} = \\max\\left(\\|r_x\\|_\\infty,\\|r_y\\|_\\infty\\right)$\n并将其报告为浮点数。\n\n测试套件：\n- 测试 1 (理想路径): $p = 5$，正弦映射，参数为 $a = 0.2$ 和 $b = -0.1$。\n- 测试 2 (边界次数): $p = 1$，正弦映射，参数为 $a = 0.7$ 和 $b = 0.3$。\n- 测试 3 (强曲率): $p = 8$，正弦映射，参数为 $a = 0.9$ 和 $b = 0.7$。\n- 测试 4 (仿射线性映射): $p = 3$，仿射映射，参数为 $A = \\begin{bmatrix} 1.2 & -0.3 \\\\ 0.5 & 0.8 \\end{bmatrix}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中按顺序包含测试 1 到测试 4 的 $r_{\\max}$ 值，格式为方括号内以逗号分隔的列表。例如，它应该看起来像“[v1,v2,v3,v4]”。角度必须以弧度为单位，并且没有物理单位。报告的值必须是浮点数。", "solution": "用户提供的问题是有效的。它在科学上基于偏微分方程数值方法领域，特别是关于高阶谱方法和间断 Galerkin 方法。该问题是适定的、客观的，并包含了获得唯一解所需的所有信息。问题的核心是数值验证离散几何守恒律，也称为自由流守恒性质，该性质依赖于张量积网格上离散微分算子的交换性。\n\n该性质的解析基础是 Clairaut 关于混合偏导数相等的定理，即 $\\frac{\\partial^2 f}{\\partial\\xi\\partial\\eta} = \\frac{\\partial^2 f}{\\partial\\eta\\partial\\xi}$。问题要求验证该定理对于特定算子的离散模拟。关于计算坐标 $\\xi$ 和 $\\eta$ 的偏微分的离散算子由一维微分矩阵 $D$ 和单位矩阵 $I$ 的克罗内克积给出：$D_\\xi = D \\otimes I$ 和 $D_\\eta = I \\otimes D$。交换性直接源于克罗内克积的性质：\n$$\nD_\\xi D_\\eta = (D \\otimes I)(I \\otimes D) = (D \\cdot I) \\otimes (I \\cdot D) = D \\otimes D\n$$\n$$\nD_\\eta D_\\xi = (I \\otimes D)(D \\otimes I) = (I \\cdot D) \\otimes (D \\cdot I) = D \\otimes D\n$$\n因此，$D_\\xi D_\\eta = D_\\eta D_\\xi$，这意味着 $(D_\\xi D_\\eta - D_\\eta D_\\xi) = 0$。\n\nVinokur 离散度量分量定义如下：\n$G_{11} = y_\\eta = D_\\eta y$\n$G_{12} = -y_\\xi = -D_\\xi y$\n$G_{21} = -x_\\eta = -D_\\eta x$\n$G_{22} = x_\\xi = D_\\xi x$\n\n待验证的离散度量恒等式是残差 $r_x$ 和 $r_y$：\n$$\nr_x = D_\\xi G_{11} + D_\\eta G_{12} = D_\\xi (D_\\eta y) + D_\\eta (-D_\\xi y) = (D_\\xi D_\\eta - D_\\eta D_\\xi) y\n$$\n$$\nr_y = D_\\xi G_{21} + D_\\eta G_{22} = D_\\xi (-D_\\eta x) + D_\\eta (D_\\xi x) = (-D_\\xi D_\\eta + D_\\eta D_\\xi) x\n$$\n由于算子是可交换的， $r_x$ 和 $r_y$ 在解析上都应为零。数值实现将产生接近零的值，受浮点精度限制。目标是实现必要的组件并计算这些残差的最大无穷范数。\n\n实现步骤如下：\n1.  **Gauss–Lobatto–Legendre (GLL) 节点**：对于给定的多项式次数 $p$，计算 $p+1$ 个 GLL 节点。这些节点是端点 $[-1, 1]$ 以及 $p$ 次勒让德多项式一阶导数 $P_p'(\\xi)$ 的 $p-1$ 个根。这些根是使用 Newton 法数值求解的，这需要计算 $P_p'(\\xi)$ 和 $P_p''(\\xi)$。这些多项式值及其导数通过标准递推关系获得。\n\n2.  **重心微分矩阵**：在 $p+1$ 个 GLL 节点集合上，构建微分矩阵 $D$。该矩阵的元素由重心插值公式确定，该公式提供了一种数值稳定的方法来计算节点上拉格朗日插值多项式的导数。\n\n3.  **张量积网格和算子**：从一维 GLL 节点形成二维张量积网格。使用指定的曲线或仿射映射计算网格点的物理坐标 $(x, y)$。此网格上的函数值使用列主元扁平化方案存储在一维数组（向量）中。对于正确应用通过克罗内克积构建的二维微分算子 $D_\\xi = D \\otimes I$ 和 $D_\\eta = I \\otimes D$ 而言，这种存储约定至关重要。\n\n4.  **验证**：通过将 $D_\\xi$ 和 $D_\\eta$ 应用于物理坐标的扁平化向量来计算离散度量分量。然后计算残差 $r_x$ 和 $r_y$。最后，为问题中指定的每个测试用例确定最大无穷范数 $r_{\\max} = \\max(\\|r_x\\|_\\infty, \\|r_y\\|_\\infty)$。$r_{\\max}$ 的预期结果是一个与机器精度同量级的小数，从而证实所实现方案的自由流守恒性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs discrete operators and verifies the free stream preservation\n    metric identity for various curvilinear mappings and polynomial degrees.\n    \"\"\"\n\n    def get_legendre_poly_and_derivs(degree, x):\n        \"\"\"\n        Computes P_d(x), P'_d(x), and P''_d(x) for a given degree d.\n        Uses stable recurrence relations.\n        \"\"\"\n        if degree == 0:\n            return 1.0, 0.0, 0.0\n\n        p_k_minus_1 = 1.0  # P_0(x)\n        p_k = x          # P_1(x)\n\n        for k in range(1, degree):\n            p_k_plus_1 = ((2.0 * k + 1.0) * x * p_k - k * p_k_minus_1) / (k + 1.0)\n            p_k_minus_1 = p_k\n            p_k = p_k_plus_1\n        \n        # p_k is P_d(x), p_k_minus_1 is P_{d-1}(x)\n\n        if abs(1.0 - x**2)  1e-14:\n            pd_k = 0.5 * degree * (degree + 1.0)\n            if x  0:\n                pd_k *= (-1.0)**(degree + 1.0)\n            \n            pdd_k = (degree * (degree + 1.0) - 2.0) * pd_k / 4.0\n            if x  0:\n               pdd_k *= -1.0 # Sign follows from P'_d parity\n        else:\n            pd_k = degree * (p_k_minus_1 - x * p_k) / (1.0 - x**2)\n            pdd_k = (2.0 * x * pd_k - degree * (degree + 1.0) * p_k) / (1.0 - x**2)\n            \n        return p_k, pd_k, pdd_k\n\n    def get_gll_nodes(p):\n        \"\"\"\n        Computes the (p+1) GLL nodes, which are the roots of (1-x^2)P'_p(x).\n        \"\"\"\n        if p == 0:\n            return np.array([0.0])\n        if p == 1:\n            return np.array([-1.0, 1.0])\n        \n        nodes = np.zeros(p + 1)\n        nodes[0], nodes[-1] = -1.0, 1.0\n        \n        initial_guesses = np.cos(np.arange(1, p) * np.pi / p)\n\n        for i, x0 in enumerate(initial_guesses):\n            x = x0\n            for _ in range(10): # Newton's method for roots of P'_p(x)\n                _, p_prime, p_second_prime = get_legendre_poly_and_derivs(p, x)\n                \n                if abs(p_second_prime)  1e-14: break\n                \n                delta = p_prime / p_second_prime\n                x -= delta\n                \n                if abs(delta)  1e-15: break\n            nodes[i + 1] = x\n        \n        nodes.sort()\n        return nodes\n\n    def get_barycentric_diff_matrix(nodes):\n        \"\"\"\n        Constructs the differentiation matrix D for a given set of nodes.\n        \"\"\"\n        n_pts = len(nodes)\n        D = np.zeros((n_pts, n_pts))\n        \n        weights = np.ones(n_pts)\n        for j in range(n_pts):\n            for k in range(n_pts):\n                if j != k:\n                    weights[j] *= (nodes[j] - nodes[k])\n        weights = 1.0 / weights\n        \n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = (weights[j] / weights[i]) / (nodes[i] - nodes[j])\n\n        for i in range(n_pts):\n            D[i, i] = -np.sum(D[i, :])\n            \n        return D\n    \n    test_cases = [\n        {'p': 5, 'type': 'sinusoidal', 'params': {'a': 0.2, 'b': -0.1}},\n        {'p': 1, 'type': 'sinusoidal', 'params': {'a': 0.7, 'b': 0.3}},\n        {'p': 8, 'type': 'sinusoidal', 'params': {'a': 0.9, 'b': 0.7}},\n        {'p': 3, 'type': 'affine', 'params': {'A': np.array([[1.2, -0.3], [0.5, 0.8]])}},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p = case['p']\n        n_pts = p + 1\n        \n        # 1. 1D operators and nodes\n        xi_1d = get_gll_nodes(p)\n        D = get_barycentric_diff_matrix(xi_1d)\n        \n        # 2. 2D tensor-product setup\n        I = np.identity(n_pts)\n        D_xi = np.kron(D, I)\n        D_eta = np.kron(I, D)\n        \n        # Grid and mapping\n        # `indexing='xy'` with `flatten('F')` creates a data layout where\n        # eta is the fast index and xi is the slow index. This is consistent\n        # with the problem's Kronecker product definitions.\n        xi_grid, eta_grid = np.meshgrid(xi_1d, xi_1d, indexing='xy')\n        xi_flat = xi_grid.flatten('F')\n        eta_flat = eta_grid.flatten('F')\n        \n        if case['type'] == 'sinusoidal':\n            a = case['params']['a']\n            b = case['params']['b']\n            x_flat = xi_flat + a * np.sin(np.pi * xi_flat) * np.sin(np.pi * eta_flat)\n            y_flat = eta_flat + b * np.cos(np.pi * xi_flat) * np.sin(np.pi * eta_flat)\n        elif case['type'] == 'affine':\n            A = case['params']['A']\n            x_flat = A[0, 0] * xi_flat + A[0, 1] * eta_flat\n            y_flat = A[1, 0] * xi_flat + A[1, 1] * eta_flat\n        \n        # Discrete derivatives of coordinates\n        x_xi = D_xi @ x_flat\n        y_xi = D_xi @ y_flat\n        x_eta = D_eta @ x_flat\n        y_eta = D_eta @ y_flat\n        \n        # Vinokur discrete metric components\n        G11 = y_eta\n        G21 = -x_eta\n        G12 = -y_xi\n        G22 = x_xi\n        \n        # Residuals of metric identities\n        rx = D_xi @ G11 + D_eta @ G12\n        ry = D_xi @ G21 + D_eta @ G22\n        \n        # Maximum-infinity-norm residual\n        r_max = max(np.max(np.abs(rx)), np.max(np.abs(ry)))\n        results.append(r_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3388173"}, {"introduction": "从单元内部转向其边界，本练习探讨了间断伽辽金（DG）方法的一个关键方面。你将研究对于非多项式映射，面元法向的计算方式如何影响自由流的保持 [@problem_id:3388203]。这个实践揭示了一个微妙但至关重要的原则：确保离散边界积分为零需要几何上的一致性，而这可以通过使用从解的节点派生的面元几何多项式近似来实现，而不是使用精确几何配合一个不精确的求积法则。", "problem": "考虑一个在单个曲线四边形单元上的二维线性平流方程，该方程使用带有勒让德-高斯-洛巴托 (LGL) 节点的高阶间断伽辽金 (DG) 方法进行离散。其控制偏微分方程为 $u_t + \\mathbf{a}\\cdot\\nabla u = 0$，其中 $\\mathbf{a}\\in\\mathbb{R}^2$ 是一个恒定的平流速度。对于一个常数自由流 $u(x,y,t)\\equiv u_0$，当几何诱导的度量项和数值通量被一致处理时，自由流保持性 (FSP) 要求半离散 DG 残差恒等于零。\n\n将从参考正方形 $(\\xi,\\eta)\\in[-1,1]^2$ 到物理坐标 $(x,y)$ 的曲线映射定义为\n$$x(\\xi,\\eta) = \\xi + \\alpha_c\\,\\xi\\eta + \\alpha_s \\sin(\\pi \\xi),\\qquad y(\\xi,\\eta) = \\eta + \\beta_q\\,\\xi^2 + \\beta_s \\sin(\\pi \\eta),$$\n其中参数 $\\alpha_c,\\alpha_s,\\beta_q,\\beta_s\\in\\mathbb{R}$ 选择得足够小，以使映射保持一一对应。设恒定平流向量为 $\\mathbf{a}=(a_x,a_y)$，恒定自由流为 $u_0$。\n\n对于单个单元，使用线性平流方程的迎风数值通量和一个常数状态 $u_0$，在每个面点上产生一个面贡献 $\\hat{f} = u_0\\,\\mathbf{a}\\cdot \\mathbf{n}$，其中 $\\mathbf{n}$ 是向外的单位法向量，而 $ds$ 是面线元。因此，单元上的半离散 DG 残差简化为边界积分\n$$R = u_0 \\oint_{\\partial \\Omega_e} \\mathbf{a}\\cdot \\mathbf{n}\\,ds.$$\n根据散度定理，并且由于对于恒定的 $\\mathbf{a}$ 有 $\\nabla\\cdot\\mathbf{a} = 0$，连续残差等于 $R=0$。然而，其离散对应形式取决于如何在求积节点上计算 $\\mathbf{n}\\,ds$。\n\n您必须比较两种面法向量的计算方法：\n- 精确几何法向量：使用 $\\mathbf{X}(\\xi,\\eta)=(x(\\xi,\\eta),y(\\xi,\\eta))$ 的精确参数导数计算每个面上的切向量 $\\mathbf{t}$；然后使用恒等式 $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t})\\,d\\lambda$，其中 $\\mathcal{R}_{-90}([t_x,t_y])=[t_y,-t_x]$ 且 $d\\lambda$ 是参考面参数微分，并利用 LGL 求积法近似该积分。\n- 多项式逼近：沿着每个面，用一个次数为 $N-1$ 的多项式在 $N$ 个 LGL 节点上插值物理坐标 $\\mathbf{X}$，使用重心微分矩阵对该多项式进行微分，从而获得节点上切向量 $\\mathbf{t}$ 的多项式逼近，通过 $\\mathcal{R}_{-90}$ 构造 $\\mathbf{n}\\,ds$，并利用 LGL 求积法近似该积分。\n\n实现这两种计算，并以布尔条件 $|R|\\le \\varepsilon$ 的形式数值化地评估 FSP，其中 $\\varepsilon$ 为指定的容差。使用以下映射的解析导数：\n$$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha_c\\,\\eta + \\alpha_s \\pi \\cos(\\pi \\xi),\\quad \\frac{\\partial x}{\\partial \\eta} = \\alpha_c\\,\\xi,$$\n$$\\frac{\\partial y}{\\partial \\xi} = 2\\beta_q\\,\\xi,\\quad \\frac{\\partial y}{\\partial \\eta} = 1 + \\beta_s \\pi \\cos(\\pi \\eta).$$\n沿逆时针方向遍历单元边界。对于底面，使用 $\\eta=-1$ 并增加 $\\xi$；对于右面，使用 $\\xi=+1$ 并增加 $\\eta$；对于顶面，使用 $\\eta=+1$ 并减小 $\\xi$；对于左面，使用 $\\xi=-1$ 并减小 $\\eta$。在沿着一个面的每个 LGL 节点 $s\\in[-1,1]$ 处，外法向量乘以测度向量为 $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t}(s))\\,ds$，而求积法则将 $\\int_{-1}^{1}$ 近似为 $\\sum_{i=1}^N w_i(\\cdot)$。\n\n您的程序必须：\n- 构建每个面有 $N$ 个点的勒让德-高斯-洛巴托节点和权重；权重必须满足对最高次数为 $2N-3$ 的多项式进行积分的 LGL 公式。\n- 构建 LGL 节点上的重心微分矩阵，以便为多项式法向量方法对面插值多项式进行微分。\n- 对于下方的每个测试用例，计算两个布尔结果，分别表示精确法向量方法和多项式法向量方法是否满足 FSP（即 $|R|\\le \\varepsilon$）。\n\n使用以下参数值的测试套件，涵盖一个典型情况、一个边界条件和一些边缘情况：\n- 情况 1：$N=5$, $\\alpha_c=0.3$, $\\alpha_s=0.2$, $\\beta_q=0.1$, $\\beta_s=0.2$, $\\mathbf{a}=(1.0,0.3)$, $u_0=1$, $\\varepsilon=10^{-10}$。\n- 情况 2：$N=3$, $\\alpha_c=0$, $\\alpha_s=0$, $\\beta_q=0$, $\\beta_s=0$, $\\mathbf{a}=(0.7,-0.4)$, $u_0=1$, $\\varepsilon=10^{-12}$。\n- 情况 3：$N=5$, $\\alpha_c=0.5$, $\\alpha_s=0.5$, $\\beta_q=0.3$, $\\beta_s=0.5$, $\\mathbf{a}=(1.0,1.0)$, $u_0=1$, $\\varepsilon=10^{-10}$。\n- 情况 4：$N=4$, $\\alpha_c=0.3$, $\\alpha_s=0.4$, $\\beta_q=0.0$, $\\beta_s=0.6$, $\\mathbf{a}=(0.0,1.0)$, $u_0=1$, $\\varepsilon=10^{-10}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中结果按每个测试用例成对排序：首先是精确法向量方法的布尔值，然后是多项式法向量方法的布尔值。不涉及物理单位，角度应理解为三角函数的无量纲参数。最终输出必须是布尔值。", "solution": "我们从二维线性平流方程 $u_t + \\mathbf{a}\\cdot\\nabla u = 0$ 开始，其中 $\\mathbf{a}=(a_x,a_y)$ 是一个常数向量。在守恒形式下，通量为 $\\mathbf{f}(u) = u\\,\\mathbf{a}$，而单个曲边单元上的间断伽辽金 (DG) 离散使用数值通量 $\\hat{f}$ 的边界积分。对于常数自由流 $u(x,y,t)\\equiv u_0$，迎风通量值在面的两侧是相同的，得到 $\\hat{f}=u_0\\,\\mathbf{a}\\cdot \\mathbf{n}$，其中 $\\mathbf{n}$ 是向外的单位法向量，ds 是面线元。因此，半离散 DG 残差简化为\n$$R = u_0 \\oint_{\\partial \\Omega_e} \\mathbf{a}\\cdot \\mathbf{n}\\,ds.$$\n根据散度定理，$\\oint_{\\partial \\Omega_e} \\mathbf{a}\\cdot \\mathbf{n}\\,ds = \\iint_{\\Omega_e} \\nabla\\cdot\\mathbf{a}\\,dA$，且由于对于常数 $\\mathbf{a}$ 有 $\\nabla\\cdot\\mathbf{a}=0$，连续残差满足 $R=0$。在半离散设置中，自由流保持性 (FSP) 要求包括几何和求积在内的离散格式在 $u=u_0$ 为常数时能重现 $R=0$。\n\n为了数值计算 $R$，我们用参考坐标 $s\\in[-1,1]$ 对每个面进行参数化，并沿逆时针方向遍历边界。令 $\\mathbf{X}(\\xi,\\eta)=[x(\\xi,\\eta),y(\\xi,\\eta)]$ 为从参考坐标 $(\\xi,\\eta)$ 出发的物理映射，其中\n$$x(\\xi,\\eta)=\\xi+\\alpha_c\\,\\xi\\eta+\\alpha_s\\sin(\\pi\\xi),\\qquad y(\\xi,\\eta)=\\eta+\\beta_q\\,\\xi^2+\\beta_s\\sin(\\pi\\eta).$$\n我们使用解析的映射导数\n$$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha_c\\,\\eta + \\alpha_s \\pi \\cos(\\pi \\xi),\\quad \\frac{\\partial x}{\\partial \\eta} = \\alpha_c\\,\\xi,$$\n$$\\frac{\\partial y}{\\partial \\xi} = 2\\beta_q\\,\\xi,\\quad \\frac{\\partial y}{\\partial \\eta} = 1 + \\beta_s \\pi \\cos(\\pi \\eta).$$\n在一个面上，切向量 $\\mathbf{t}$ 等于 $\\partial\\mathbf{X}/\\partial \\xi$（当面由 $\\xi$ 参数化时）或 $\\partial\\mathbf{X}/\\partial \\eta$（当面由 $\\eta$ 参数化时）。外法向量乘以测度向量 $\\mathbf{n}\\,ds$ 是通过将切向量旋转 $-90^\\circ$ 得到的：$\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t})\\,d\\lambda$，其中 $\\mathcal{R}_{-90}([t_x,t_y])=[t_y,-t_x]$，而 $d\\lambda$ 是参考线微分（我们将其吸收到 LGL 求积权重中）。边界积分变为\n$$R \\approx u_0 \\sum_{\\text{faces}} \\sum_{i=1}^{N} w_i \\left( \\mathbf{a}\\cdot \\mathcal{R}_{-90}(\\mathbf{t}(s_i)) \\right)\\sigma_{\\text{face}},$$\n其中 $s_i$ 和 $w_i$ 是 $[-1,1]$ 上的 LGL 节点和权重，$N$ 是每个面的求积节点数，而 $\\sigma_{\\text{face}}\\in\\{+1,-1\\}$ 表示方向（底面和右面使用 $+1$；顶面和左面使用 $-1$，以实现一致的逆时针遍历）。\n\n我们比较两种计算 $\\mathbf{t}(s_i)$ 进而计算 $\\mathbf{n}\\,ds$ 的方法：\n\n1.  精确几何法向量：在面点上使用 $\\mathbf{X}$ 的解析导数计算 $\\mathbf{t}$，然后构成 $\\mathbf{n}\\,ds = \\mathcal{R}_{-90}(\\mathbf{t})$，并评估 LGL 求积。由于映射包含非多项式项 $\\sin(\\pi\\xi)$ 和 $\\sin(\\pi\\eta)$，给定面上的被积函数是面参数 $s$ 的光滑非多项式函数。LGL 求积法仅对次数最高为 $2N-3$ 的多项式是精确的，因此即使精确的连续积分为零，离散积分通常也会表现出非零的混叠误差。因此，离散残差可能不为零，从而可能违反 FSP。\n\n2.  曲面多项式逼近：在每个面上，用一个次数为 $N-1$ 的多项式在 $N$ 个 LGL 节点上插值物理坐标 $\\mathbf{X}$。令此插值函数为 $\\mathbf{X}_{\\text{poly}}(s)$，并通过使用在相同 LGL 节点上构建的重心微分矩阵对插值函数进行微分来计算切向量 $\\mathbf{t}_{\\text{poly}}(s_i)$。然后通过 $\\mathcal{R}_{-90}(\\mathbf{t}_{\\text{poly}})$ 构造 $\\mathbf{n}\\,ds$ 并评估 LGL 求积。一个关键性质是，使用 LGL 求積法对多项式插值函数的导数进行积分，会得到每个面的精确端点差值。具体来说，对于每个面，\n    $$\\sum_{i=1}^{N} w_i \\,\\mathbf{t}_{\\text{poly}}(s_i) = \\mathbf{X}_{\\text{poly}}(1) - \\mathbf{X}_{\\text{poly}}(-1),$$\n    是分量式成立的，因为 $\\mathbf{t}_{\\text{poly}}$ 的次数最多为 $N-2$，这在 LGL 求积的精确度范围内。沿闭合边界对这些贡献求和会发生伸缩相消：在逆时针遍历下，端点贡献在共享角点处相互抵消。因此，\n    $$\\sum_{\\text{faces}} \\sum_{i=1}^{N} w_i \\,\\mathcal{R}_{-90}(\\mathbf{t}_{\\text{poly}}(s_i))\\,\\sigma_{\\text{face}} = \\mathbf{0},$$\n    因此离散残差 $R$ 精确为零（在浮点舍入误差范围内）。这是离散几何守恒律 (GCL) 的一个实例，它确保了度量一致性，从而保证了常数状态下的自由流保持性 (FSP)。\n\n程序中实现的算法步骤：\n- 使用 $N-1$ 次勒让德多项式的导数根和标准权重公式 $w_i = \\dfrac{2}{N(N-1)\\,P_{N-1}(s_i)^2}$（其中 $P_{N-1}$ 是在 $s_i$ 处求值的 $N-1$ 次勒让德多项式）构建 $[-1,1]$ 上的 $N$ 个 LGL 节点 $s_i$ 和权重 $w_i$。\n- 使用重心权重 $\\lambda_i = \\prod_{j\\ne i}(s_i - s_j)^{-1}$ 构建 LGL 节点上的重心微分矩阵 $D$，其中当 $i\\ne j$ 时 $D_{ij} = \\dfrac{\\lambda_j}{\\lambda_i (s_i - s_j)}$，且 $D_{ii} = -\\sum_{j\\ne i} D_{ij}$。\n- 对每个面和每种方法：\n  - 精确法向量：在面点上评估解析导数 $\\partial\\mathbf{X}/\\partial \\xi$ 或 $\\partial\\mathbf{X}/\\partial \\eta$ 以获得 $\\mathbf{t}$；计算 $\\mathbf{n}\\,ds=\\mathcal{R}_{-90}(\\mathbf{t})$；用 LGL 权重和方向 $\\sigma_{\\text{face}}$ 对 $\\mathbf{a}\\cdot\\mathbf{n}\\,ds$ 求和。\n  - 多项式法向量：在 LGL 节点上插值面映射 $\\mathbf{X}(s)$；分量式地计算 $\\mathbf{t}_{\\text{poly}} = D\\,\\mathbf{X}$；计算 $\\mathbf{n}\\,ds=\\mathcal{R}_{-90}(\\mathbf{t}_{\\text{poly}})$；用 LGL 权重和方向对 $\\mathbf{a}\\cdot\\mathbf{n}\\,ds$ 求和。\n- 聚合四个面上的贡献。离散残差是 $R = u_0$ 乘以总边界积分。如果 $|R|\\le \\varepsilon$，则声明 FSP 得以保持，其中 $\\varepsilon$ 是特定于用例的容差。\n\n测试套件涵盖：\n- 一个一般曲边情况（情况 1），以观察由于求积混叠，精确法向量可能无法保持 FSP，而多项式法向量则可以。\n- 一个边界条件（情况 2），其中映射是仿射的（$\\alpha_c=\\alpha_s=\\beta_q=\\beta_s=0$），因此两种方法都应能精确保持 FSP（在舍入误差范围内）。\n- 一个强弯曲情况（情况 3），放大了非多项式几何效应。\n- 一个边缘情况（情况 4），其中各向异性曲率仅影响一个坐标的正弦曲线，测试对平流方向的敏感性。\n\n最终程序输出一行布尔值列表，按以下顺序排列：对于每个用例，首先是精确法向量方法的结果，然后是多项式法向量方法的结果。无需物理单位，所有三角函数参数均为无量纲。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_lobatto_nodes_weights(N):\n    \"\"\"\n    Compute Legendre-Gauss-Lobatto (LGL) nodes and weights on [-1,1] with N nodes.\n    Nodes are [-1] + roots of P_{N-1}' + [1]. Weights use the standard formula.\n    \"\"\"\n    from numpy.polynomial.legendre import Legendre\n    p = N - 1\n    P = Legendre.basis(p)\n    dP = P.deriv()\n    interior = dP.roots()\n    # Sort interior roots to be in ascending order\n    interior.sort()\n    x = np.empty(N)\n    x[0] = -1.0\n    x[-1] = 1.0\n    if N > 2:\n        x[1:-1] = interior\n    # Weights: w_i = 2 / (N*(N-1)) * 1 / (P_{N-1}(x_i)^2)\n    P_vals = P(x)\n    w = 2.0 / (N * (N - 1)) / (P_vals ** 2)\n    return x, w\n\ndef barycentric_diff_matrix(x):\n    \"\"\"\n    Construct the barycentric differentiation matrix D for nodes x.\n    D_ij = lambda_j / (lambda_i * (x_i - x_j)) for i != j,\n    D_ii = -sum_{j != i} D_ij.\n    \"\"\"\n    N = len(x)\n    # Compute barycentric weights lambda_i = 1 / prod_{j != i} (x_i - x_j)\n    lam = np.ones(N)\n    for i in range(N):\n        diff = x[i] - np.delete(x, i)\n        lam[i] = 1.0 / np.prod(diff)\n    D = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                D[i, j] = lam[j] / (lam[i] * (x[i] - x[j]))\n    D[np.diag_indices(N)] = -np.sum(D, axis=1)\n    return D\n\ndef mapping_and_derivs(xi, eta, params):\n    \"\"\"\n    Compute physical coordinates X = (x,y) and analytic derivatives:\n    dx/dxi, dx/deta, dy/dxi, dy/deta\n    for the mapping:\n      x = xi + alpha_c * xi * eta + alpha_s * sin(pi * xi)\n      y = eta + beta_q * xi**2 + beta_s * sin(pi * eta)\n    \"\"\"\n    alpha_c, alpha_s, beta_q, beta_s = params\n    x = xi + alpha_c * xi * eta + alpha_s * np.sin(np.pi * xi)\n    y = eta + beta_q * xi**2 + beta_s * np.sin(np.pi * eta)\n    dx_dxi = 1.0 + alpha_c * eta + alpha_s * np.pi * np.cos(np.pi * xi)\n    dx_deta = alpha_c * xi\n    dy_dxi = 2.0 * beta_q * xi\n    dy_deta = 1.0 + beta_s * np.pi * np.cos(np.pi * eta)\n    return x, y, dx_dxi, dx_deta, dy_dxi, dy_deta\n\ndef rotate_minus_90(t):\n    \"\"\"\n    Rotate 2D tangent vector(s) t by -90 degrees: [tx, ty] -> [ty, -tx]\n    t can be shape (N, 2); returns same shape.\n    \"\"\"\n    return np.stack((t[:, 1], -t[:, 0]), axis=1)\n\ndef boundary_flux_exact(N, params, a):\n    \"\"\"\n    Compute boundary integral of a · n ds using exact analytic derivatives\n    and LGL quadrature with N nodes per face, traversing counterclockwise.\n    \"\"\"\n    s, w = legendre_lobatto_nodes_weights(N)\n    ax, ay = a\n    total = 0.0\n\n    # Bottom face: eta = -1, param by xi = s, orientation +1\n    eta = -1.0 * np.ones_like(s)\n    xi = s\n    _, _, dx_dxi, _, dy_dxi, _ = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_dxi, dy_dxi), axis=1)\n    n_ds = rotate_minus_90(t)  # incorporates ds via tangent magnitude in param measure\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib  # orientation +1\n\n    # Right face: xi = +1, param by eta = s, orientation +1\n    xi = 1.0 * np.ones_like(s)\n    eta = s\n    _, _, _, dx_deta, _, dy_deta = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_deta, dy_deta), axis=1)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib  # orientation +1\n\n    # Top face: eta = +1, param by xi = s, but orientation is reversed (-1)\n    eta = 1.0 * np.ones_like(s)\n    xi = s\n    _, _, dx_dxi, _, dy_dxi, _ = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_dxi, dy_dxi), axis=1)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib  # orientation -1\n\n    # Left face: xi = -1, param by eta = s, orientation -1\n    xi = -1.0 * np.ones_like(s)\n    eta = s\n    _, _, _, dx_deta, _, dy_deta = mapping_and_derivs(xi, eta, params)\n    t = np.stack((dx_deta, dy_deta), axis=1)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib  # orientation -1\n\n    return total\n\ndef boundary_flux_poly(N, params, a):\n    \"\"\"\n    Compute boundary integral of a · n ds using polynomial interpolation\n    of the face mapping and barycentric differentiation to obtain tangents,\n    then LGL quadrature with N nodes per face, traversing counterclockwise.\n    \"\"\"\n    s, w = legendre_lobatto_nodes_weights(N)\n    D = barycentric_diff_matrix(s)\n    ax, ay = a\n    total = 0.0\n\n    # Helper to interpolate X along a face and compute tangent via D\n    def face_tangent_x_y(xi_vals, eta_vals):\n        x, y, _, _, _, _ = mapping_and_derivs(xi_vals, eta_vals, params)\n        dxds = D @ x\n        dyds = D @ y\n        return np.stack((dxds, dyds), axis=1)\n\n    # Bottom face: eta = -1, xi = s, orientation +1\n    xi = s\n    eta = -1.0 * np.ones_like(s)\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib\n\n    # Right face: xi = +1, eta = s, orientation +1\n    xi = 1.0 * np.ones_like(s)\n    eta = s\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total += contrib\n\n    # Top face: eta = +1, xi = s, orientation -1\n    xi = s\n    eta = 1.0 * np.ones_like(s)\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib\n\n    # Left face: xi = -1, eta = s, orientation -1\n    xi = -1.0 * np.ones_like(s)\n    eta = s\n    t = face_tangent_x_y(xi, eta)\n    n_ds = rotate_minus_90(t)\n    contrib = np.sum(w * (ax * n_ds[:, 0] + ay * n_ds[:, 1]))\n    total -= contrib\n\n    return total\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, alpha_c, alpha_s, beta_q, beta_s, ax, ay, u0, epsilon)\n    test_cases = [\n        (5, 0.3, 0.2, 0.1, 0.2, 1.0, 0.3, 1.0, 1e-10),  # Case 1\n        (3, 0.0, 0.0, 0.0, 0.0, 0.7, -0.4, 1.0, 1e-12), # Case 2\n        (5, 0.5, 0.5, 0.3, 0.5, 1.0, 1.0, 1.0, 1e-10),  # Case 3\n        (4, 0.3, 0.4, 0.0, 0.6, 0.0, 1.0, 1.0, 1e-10),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, alpha_c, alpha_s, beta_q, beta_s, ax, ay, u0, eps = case\n        params = (alpha_c, alpha_s, beta_q, beta_s)\n        a = (ax, ay)\n        # Exact normals method\n        I_exact = boundary_flux_exact(N, params, a)\n        R_exact = u0 * I_exact\n        preserved_exact = abs(R_exact) = eps\n        results.append(preserved_exact)\n        # Polynomial normals method\n        I_poly = boundary_flux_poly(N, params, a)\n        R_poly = u0 * I_poly\n        preserved_poly = abs(R_poly) = eps\n        results.append(preserved_poly)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3388203"}, {"introduction": "我们最后的实践将守恒的概念从单个单元扩展到具有不同多项式阶数（$p$-自适应）的多单元区域，这是高级模拟中的常见场景。你将诊断为何在阶数不同的单元之间的界面上，简单的耦合会破坏自由流保持性质，然后实现一个标准的修正程序 [@problem_id:3388222]。这项动手任务展示了通过将局部数据投影到公共空间，在非协调界面上定义单一、一致的数值通量的必要性，从而恢复全局守恒。", "problem": "考虑在时不变曲线坐标映射中的二维守恒线性平流方程，该方程在每个单元上使用勒让德-高斯-洛巴托配置，并通过谱元法 (SEM) 或间断伽辽金 (DG) 方法进行离散化。物理空间映射由一个从参考正方形到弯曲四边形的光滑双射定义。研究的核心性质是当每个单元的多项式阶数不同时（也称为 $p$-自适应性），在曲线网格上的自由流保持（常数状态不变性）。我们研究由几何守恒律和度量恒等式所蕴含的离散条件，以及未能强制执行度量项的界面一致性如何破坏自由流保持。\n\n基本原理包括：多元微积分中的变量替换、映射的连续性和可微性、光滑函数的混合偏导数相等性，以及通过勒让德-高斯-洛巴托配置的分部求和 (SBP) 结构实现的散度守恒性质。参考域被分割成两个相邻的单元，它们共享一个垂直的内部界面。\n\n设 $\\boldsymbol{x} = (x,y)$ 为在全局坐标 $(S,T)$ 上定义的光滑物理映射，其中每个单元使用局部配置坐标 $(\\xi,\\eta)$ 和一个仿射关系 $(S,T) = (\\xi + s_0, \\eta)$（其中常数位移 $s_0 \\in \\{-1, +1\\}$）来铺砌全局域 $S \\in [-2,2]$，$T \\in [-1,1]$。物理映射指定为\n$$\nx(S,T) = S + a \\cos\\left(\\frac{\\pi T}{2}\\right), \\quad\ny(S,T) = T + a \\sin\\left(\\frac{\\pi S}{2}\\right)\\cos\\left(\\frac{\\pi T}{2}\\right),\n$$\n其中 $a$ 是一个非负曲率振幅，所有三角函数均使用弧度制角。设自由流平流速度为常数 $\\boldsymbol{v} = (u_0, v_0)$。\n\n对于一个常数标量状态 $U \\equiv U_0$，在某个配置点上的映射逆变平流通量分量由物理导数和速度定义，\n$$\nc^{\\xi} = u_0\\,y_{\\eta} - v_0\\,x_{\\eta}, \\qquad\nc^{\\eta} = -u_0\\,y_{\\xi} + v_0\\,x_{\\xi},\n$$\n其中偏导数是关于局部配置坐标 $(\\xi,\\eta)$ 求得的。在精确微积分中，度量恒等式强制 $\\partial_{\\xi} c^{\\xi} + \\partial_{\\eta} c^{\\eta} = 0$。在离散层面，使用勒让德-高斯-洛巴托配置和分部求和算子，离散散度的单元积分等于通过边求积计算出的穿过单元边界的净通量。如果相邻单元使用不同的多项式阶数，那么在共享内部边上，由各方在其自身的边节点和权重上计算出的通量可能无法精确抵消，这会破坏自由流保持。\n\n您的任务是实现一个程序，该程序对每个测试用例执行以下操作：\n- 使用分别为 $p_L$ 和 $p_R$ 阶的局部勒让德-高斯-洛巴托节点，在全局条带上构建两个相邻单元（左单元和右单元），应用上述带有曲率振幅 $a$ 的映射，并通过张量积运算使用一维勒让德-高斯-洛巴托微分矩阵计算 $x_{\\xi}$、$x_{\\eta}$、$y_{\\xi}$、$y_{\\eta}$。\n- 使用各自的边节点和边权重，计算两个单元沿共享垂直边的内部界面外向通量贡献，即在左单元右边上通过对 $c^{\\xi}$ 进行边求积得到的 $\\xi$-通量线积分，以及在右单元左边上的外向（符号相反）$\\xi$-通量线积分。令这两个贡献的绝对值之和为投影前失配误差 $E_{\\text{before}}$。\n- 通过将边通量投影到次数为 $\\max(p_L,p_R)$ 的公共界面多项式上，来强制执行界面处的度量恒等式一致性：将左边和右边的边通量样本插值到公共的勒让德-高斯-洛巴托界面节点（在 $\\eta$ 方向上），并将公共界面通量定义为两个插值结果的平均值。使用这个公共界面通量和公共边权重重新计算两个外向贡献；其绝对值之和定义了投影后失配误差 $E_{\\text{after}}$。\n- 报告每个测试用例的配对 $(E_{\\text{before}}, E_{\\text{after}})$。\n\n角度单位是弧度。不涉及物理单位，所有结果都是无量纲的浮点数。\n\n要求的输出格式是单行，包含一个用方括号括起来的逗号分隔列表，按测试用例排序，每个用例依次贡献两个浮点数 $[E_{\\text{before}}, E_{\\text{after}}]$：\n$$\n[\\;E_{\\text{before}}^{(1)}, E_{\\text{after}}^{(1)}, E_{\\text{before}}^{(2)}, E_{\\text{after}}^{(2)}, \\ldots\\;].\n$$\n\n在以下涵盖鲁棒性不同方面的测试套件下实现您的解决方案：\n\n- 情况 1（中等阶数不匹配，中等曲率）：$p_L = 3$, $p_R = 5$, $a = 0.25$, $u_0 = 1.0$, $v_0 = 0.3$。\n- 情况 2（低阶数匹配，零曲率边界情况）：$p_L = 2$, $p_R = 2$, $a = 0.0$, $u_0 = 1.0$, $v_0 = 0.3$。\n- 情况 3（高对比度阶数不匹配，强曲率）：$p_L = 6$, $p_R = 3$, $a = 0.5$, $u_0 = 1.0$, $v_0 = -0.4$。\n- 情况 4（极端不匹配）：$p_L = 1$, $p_R = 8$, $a = 0.4$, $u_0 = -0.7$, $v_0 = 0.9$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$，其中所有 $r_i$ 均为浮点数）。", "solution": "该问题要求研究高阶谱元法 (SEM) 或间断伽辽金 (DG) 方法在曲线网格上对线性平流方程进行离散化后的自由流保持性质。具体来说，它检验了两个具有不同多项式阶数（$p$-自适应性）的单元之间界面上的通量失配，并演示了如何恢复守恒性。\n\n首先，我们建立理论背景。对于标量 $U$ 和常数速度场 $\\boldsymbol{v} = (u_0, v_0)$，二维线性平流方程为 $\\partial_t U + \\boldsymbol{v} \\cdot \\nabla U = 0$。其守恒形式为 $\\partial_t U + \\nabla \\cdot (U\\boldsymbol{v}) = 0$。对于常数（“自由流”）状态 $U \\equiv U_0$，方程简化为 $\\nabla \\cdot (U_0\\boldsymbol{v}) = U_0 (\\nabla \\cdot \\boldsymbol{v}) = 0$，由于 $\\boldsymbol{v}$ 是常数，此式自然成立。\n\n当方程从物理坐标 $\\boldsymbol{x}=(x,y)$ 转换到参考坐标 $\\boldsymbol{\\xi}=(\\xi,\\eta)$ 时，守恒律变为 $\\partial_t (JU) + \\partial_{\\xi}(JUc^{\\xi}) + \\partial_{\\eta}(JUc^{\\eta}) = 0$，其中 $J$ 是映射的雅可比行列式，$c^{\\xi}, c^{\\eta}$ 是逆变速度分量。对于常数状态 $U_0$，这简化为几何守恒律 (GCL)：\n$$\n\\partial_{\\xi}(J U_0 c^{\\xi}) + \\partial_{\\eta}(J U_0 c^{\\eta}) = U_0 (\\partial_{\\xi}(Jc^{\\xi}) + \\partial_{\\eta}(Jc^{\\eta})) = 0\n$$\n$Jc^{\\xi}$ 和 $Jc^{\\eta}$ 这两个量可以写成映射导数（度量项）的形式：\n$$\nJc^{\\xi} = u_0 y_{\\eta} - v_0 x_{\\eta}\n$$\n$$\nJc^{\\eta} = -u_0 y_{\\xi} + v_0 x_{\\xi}\n$$\n（注意：问题陈述将 $c^\\xi, c^\\eta$ 定义为通常所说的未缩放的逆变通量，等价于 $Jc^\\xi, Jc^\\eta$。我们将采纳问题中的记法。）我们将问题中的定义称为 $\\tilde{c}^\\xi=Jc^\\xi$ 和 $\\tilde{c}^\\eta=Jc^\\eta$。GCL 是 $\\partial_\\xi \\tilde{c}^\\xi + \\partial_\\eta \\tilde{c}^\\eta = 0$。如果映射是光滑的，由于混合偏导数相等（Clairaut 定理），例如 $\\partial_\\xi y_\\eta = \\partial_\\eta y_\\xi$，该恒等式在解析上成立。\n\n在离散层面，在勒让德-高斯-洛巴托 (LGL) 点上使用节点型 DG 或 SEM 方法时，导数被替换为与微分矩阵 $D$ 的矩阵向量乘积。GCL 不再保证精确成立，即 $\\partial_\\xi^{\\text{discrete}} \\tilde{c}^\\xi + \\partial_\\eta^{\\text{discrete}} \\tilde{c}^\\eta \\neq 0$。然而，LGL 微分和求积法则的分部求和 (SBP) 性质确保了单元上散度的离散积分精确等于其边界上的数值通量积分。对于常数状态，如果两个单元（例如 $K_L$ 和 $K_R$）之间界面上的数值通量相互抵消，则自由流保持得以维持。\n\n穿过共享界面的总外向通量必须为零。从左单元 $K_L$ 穿过其右边界（$\\xi=1$）的外向通量是 $\\int \\tilde{c}^\\xi|_L d\\eta$。从右单元 $K_R$ 穿过其左边界（$\\xi=-1$）的外向通量是 $-\\int \\tilde{c}^\\xi|_R d\\eta$。自由流保持要求 $\\int \\tilde{c}^\\xi|_L d\\eta - \\int \\tilde{c}^\\xi|_R d\\eta = 0$。\n\n问题的核心在于，当 $p_L \\neq p_R$ 时，界面通量的离散表示是不一致的。\n1.  每个单元沿界面的 LGL 节点和求积权重是不同的。\n2.  度量项 ($x_\\eta, y_\\eta$) 是通过对坐标场进行微分计算的，而坐标场在每个单元中被表示为不同阶数（$p_L$ 和 $p_R$）的多项式。\n这导致了通量的两种不同多项式表示，$\\tilde{c}^\\xi|_L$ 和 $\\tilde{c}^\\xi|_R$。数值求积 $\\sum_j (\\tilde{c}^\\xi|_L)_j w_j^L$ 和 $\\sum_j (\\tilde{c}^\\xi|_R)_j w_j^R$ 通常不相等。失配量 $E_{\\text{before}} = |\\sum (\\tilde{c}^\\xi|_L)_j w_j^L - \\sum (\\tilde{c}^\\xi|_R)_j w_j^R|$ 量化了这种守恒性的失效。\n\n为了恢复守恒性，必须在界面上定义一个单值的数值通量。这通过将两个局部通量表示投影到一个公共函数空间来实现。\n1.  基于多项式阶数 $p_I = \\max(p_L, p_R)$ 的 LGL 节点选择一个公共界面网格。\n2.  来自左单元的通量值 $(\\tilde{c}^\\xi|_L)_j$（在 $p_L+1$ 个节点上）被插值到 $p_I+1$ 个公共节点上，得到 $\\tilde{c}^\\xi_{L \\to I}$。\n3.  类似地，来自右单元的通量值被插值到公共节点上，得到 $\\tilde{c}^\\xi_{R \\to I}$。\n4.  定义一个公共的、守恒的数值通量，通常取平均值：$\\hat{c}^\\xi = \\frac{1}{2}(\\tilde{c}^\\xi_{L \\to I} + \\tilde{c}^\\xi_{R \\to I})$。\n5.  现在使用这个公共通量 $\\hat{c}^\\xi$ 和阶数为 $p_I$ 的公共求积法则重新计算两边的通量积分贡献。从左边流出的外向通量为 $F'_L = \\sum_j \\hat{c}^\\xi_j w_j^I$。从右边流出的外向通量为 $-F'_R = -\\sum_j \\hat{c}^\\xi_j w_j^I$。\n6.  新的总失配为 $E_{\\text{after}} = |F'_L - F'_R|$。根据构造，由于两个积分都是从相同的公共通量数据和权重计算的，因此 $F'_L = F'_R$，所以 $E_{\\text{after}}$ 将在浮点精度范围内为零。\n\n要实现的算法如下：\n对于每个测试用例（$p_L, p_R, a, u_0, v_0$）：\n1.  为阶数 $p_L$ 和 $p_R$ 生成 LGL 节点、权重和微分矩阵。\n2.  对于左单元，通过中间映射 $(S,T) = (\\xi-1, \\eta)$ 定义从局部坐标 $(\\xi, \\eta) \\in [-1,1]^2$ 到物理坐标 $(x,y)$ 的映射。在 $p_L+1 \\times p_L+1$ 的 LGL 网格上评估物理坐标 $(x_{ij}, y_{ij})$。\n3.  使用 $p_L$ 阶微分矩阵 $D_L$ 在网格上计算离散度量导数 $x_\\eta, y_\\eta$。\n4.  提取右边（$\\xi=1$）上的 $x_\\eta, y_\\eta$ 值，并计算通量值 $\\tilde{c}^\\xi_L$。\n5.  使用 $p_L$ 阶 LGL 求积法则计算积分通量 $F_L$。\n6.  对右单元重复步骤 2-5，使用阶数 $p_R$ 和映射 $(S,T) = (\\xi+1, \\eta)$。从左边（$\\xi=-1$）提取度量项以计算 $\\tilde{c}^\\xi_R$ 和积分通量 $F_R$。\n7.  计算投影前失配误差：$E_{\\text{before}} = |F_L - F_R|$。\n8.  定义阶数为 $p_I = \\max(p_L, p_R)$ 的公共界面基。\n9.  将通量数组 $\\tilde{c}^\\xi_L$（来自 $p_L+1$ 个节点）和 $\\tilde{c}^\\xi_R$（来自 $p_R+1$ 个节点）插值到公共的 $p_I+1$ 个界面节点上。\n10. 通过对两个插值后的通量数组求平均来计算公共通量 $\\hat{c}^\\xi$。\n11. 使用公共求积法则计算新的通量积分 $F' = \\sum_j \\hat{c}^\\xi_j w_j^I$。\n12. 计算投影后失配误差：$E_{\\text{after}} = |F' - F'| = 0$。\n13. 存储配对 $(E_{\\text{before}}, E_{\\text{after}})$。\n\n此过程将对每个提供的测试用例执行，并以指定格式报告结果。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\nlgl_cache = {}\n\ndef get_lgl(p):\n    \"\"\"\n    Computes and caches Legendre-Gauss-Lobatto nodes, weights, and differentiation matrix.\n    Args:\n        p (int): Polynomial order, p >= 1.\n    Returns:\n        tuple: (nodes, weights, differentiation_matrix)\n    \"\"\"\n    if p in lgl_cache:\n        return lgl_cache[p]\n\n    if p  1:\n        raise ValueError(\"Polynomial order p must be >= 1.\")\n\n    # Nodes\n    # Interior nodes are roots of P'_p(xi)\n    leg_poly = Legendre.basis(p)\n    # The derivative of the Legendre polynomial P_p is a polynomial of degree p-1\n    # For p=1, its derivative is a constant, with no roots.\n    if p > 1:\n        leg_poly_deriv = leg_poly.deriv(1)\n        interior_nodes = leg_poly_deriv.roots()\n    else: # p=1\n        interior_nodes = np.array([])\n    \n    nodes = np.concatenate(([-1.0], np.sort(np.real_if_close(interior_nodes)), [1.0]))\n\n    # Weights\n    leg_poly_vals_at_nodes = leg_poly(nodes)\n    weights = 2.0 / (p * (p + 1) * leg_poly_vals_at_nodes**2)\n    \n    # Differentiation Matrix\n    D = np.zeros((p + 1, p + 1))\n    # Off-diagonal\n    for i in range(p + 1):\n        for j in range(p + 1):\n            if i != j:\n                D[i, j] = leg_poly_vals_at_nodes[i] / (leg_poly_vals_at_nodes[j] * (nodes[i] - nodes[j]))\n    \n    # Diagonal\n    D[0, 0] = -p * (p + 1) / 4.0\n    D[p, p] = p * (p + 1) / 4.0\n\n    lgl_cache[p] = (nodes, weights, D)\n    return nodes, weights, D\n\ndef lagrange_interp_matrix(nodes_from, nodes_to):\n    \"\"\"\n    Computes the matrix for Lagrange interpolation between two sets of 1D nodes.\n    \"\"\"\n    n_from = len(nodes_from)\n    n_to = len(nodes_to)\n    I = np.zeros((n_to, n_from))\n    \n    for j in range(n_from):\n        den = np.prod([nodes_from[j] - nodes_from[k] for k in range(n_from) if k != j])\n        if abs(den)  1e-20:\n             # This handles case where a node in nodes_from is also in nodes_to\n             # The basis function will be 1 at that node and 0 at others\n             for i in range(n_to):\n                 if abs(nodes_to[i] - nodes_from[j])  1e-15:\n                     I[i,j] = 1.0\n             continue\n\n        for i in range(n_to):\n            num = np.prod([nodes_to[i] - nodes_from[k] for k in range(n_from) if k != j])\n            I[i, j] = num / den\n            \n    return I\n\ndef physical_mapping(S, T, a):\n    \"\"\"\n    Computes physical coordinates (x, y) from intermediate (S, T) coordinates.\n    \"\"\"\n    x = S + a * np.cos(np.pi * T / 2.0)\n    y = T + a * np.sin(np.pi * S / 2.0) * np.cos(np.pi * T / 2.0)\n    return x, y\n\ndef solve_case(p_L, p_R, a, u0, v0):\n    \"\"\"\n    Calculates the pre- and post-projection mismatch errors for a single test case.\n    \"\"\"\n    # Get LGL data for left, right, and interface elements\n    nodes_L, weights_L, D_L = get_lgl(p_L)\n    nodes_R, weights_R, D_R = get_lgl(p_R)\n    \n    # --- Left Element ---\n    xi_L, eta_L = np.meshgrid(nodes_L, nodes_L)\n    S_L, T_L = xi_L - 1.0, eta_L\n    x_L, y_L = physical_mapping(S_L, T_L, a)\n    \n    # Differentiate along eta (rows)\n    x_eta_L = D_L @ x_L\n    y_eta_L = D_L @ y_L\n\n    # Extract interface data (right edge, xi=1, last column)\n    x_eta_edge_L = x_eta_L[:, -1]\n    y_eta_edge_L = y_eta_L[:, -1]\n\n    # Compute flux and its integral\n    c_xi_L = u0 * y_eta_edge_L - v0 * x_eta_edge_L\n    F_L = np.dot(weights_L, c_xi_L)\n    \n    # --- Right Element ---\n    xi_R, eta_R = np.meshgrid(nodes_R, nodes_R)\n    S_R, T_R = xi_R + 1.0, eta_R\n    x_R, y_R = physical_mapping(S_R, T_R, a)\n    \n    # Differentiate along eta (rows)\n    x_eta_R = D_R @ x_R\n    y_eta_R = D_R @ y_R\n    \n    # Extract interface data (left edge, xi=-1, first column)\n    x_eta_edge_R = x_eta_R[:, 0]\n    y_eta_edge_R = y_eta_R[:, 0]\n    \n    # Compute flux and its integral\n    c_xi_R = u0 * y_eta_edge_R - v0 * x_eta_edge_R\n    F_R = np.dot(weights_R, c_xi_R)\n    \n    # --- Error Before Projection ---\n    # The total outward flux is F_L (out of Left) + (-F_R) (out of Right)\n    # The mismatch is their sum, or abs(F_L - F_R)\n    E_before = np.abs(F_L - F_R)\n\n    # --- Error After Projection ---\n    p_I = max(p_L, p_R)\n    nodes_I, weights_I, _ = get_lgl(p_I)\n    \n    # Interpolate fluxes to common interface nodes\n    interp_L_to_I = lagrange_interp_matrix(nodes_L, nodes_I)\n    c_xi_L_interp = interp_L_to_I @ c_xi_L\n    \n    interp_R_to_I = lagrange_interp_matrix(nodes_R, nodes_I)\n    c_xi_R_interp = interp_R_to_I @ c_xi_R\n    \n    # Define common flux\n    c_xi_common = 0.5 * (c_xi_L_interp + c_xi_R_interp)\n\n    # Recompute flux integral using common flux and weights\n    F_common = np.dot(weights_I, c_xi_common)\n    \n    # The sum of outward contributions is |F_common - F_common|\n    E_after = np.abs(F_common - F_common) # This is zero by construction\n    \n    return E_before, E_after\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (p_L, p_R, a, u0, v0)\n        (3, 5, 0.25, 1.0, 0.3),\n        (2, 2, 0.0, 1.0, 0.3),\n        (6, 3, 0.5, 1.0, -0.4),\n        (1, 8, 0.4, -0.7, 0.9),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_before, E_after = solve_case(*case)\n        results.extend([E_before, E_after])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3388222"}]}