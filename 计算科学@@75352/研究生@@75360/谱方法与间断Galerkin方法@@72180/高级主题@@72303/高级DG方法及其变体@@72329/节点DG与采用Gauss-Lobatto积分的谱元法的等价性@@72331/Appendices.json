{"hands_on_practices": [{"introduction": "在证明两种方法的等价性之前，我们必须首先掌握其共同的基石。本练习聚焦于高斯-洛巴托-勒让德（GLL）积分，通过为一个低阶多项式显式计算GLL节点和权重，您将对其来源和性质获得具体的理解。此练习将揭示GLL积分如何自然地导出一个对角质量矩阵，这是实现节点DG方法计算效率并促成其与谱元法（SEM）等价的关键特性 @problem_id:3385248。", "problem": "考虑一维空间和一个参考单元 $[-1,1]$。设 $P_{N}(x)$ 表示 $N$ 次勒让德多项式，归一化使得 $P_{N}(1)=1$，并设高斯-洛巴托-勒让德（GLL）求积法则由 $N+1$ 个节点定义，这些节点包括两个端点 $x=-1$ 和 $x=1$ 以及由 $P_{N}'(x)$ 在 $(-1,1)$ 内的不同根给出的 $N-1$ 个内部点。GLL求积是唯一的插值型求积法则，它对 $[-1,1]$ 上次数最高为 $2(N+1)-3$ 的多项式精确成立，并且具有正的权重。在谱元法和节点间断伽辽金（DG）方法中，当试验空间和测试空间是在GLL节点上定义的 $N$ 次拉格朗日多项式空间时，由求积导出的质量矩阵是对角的。\n\n从这些基本定义出发，对参考单元 $[-1,1]$ 上的多项式次数 $N=3$ 执行以下操作：\n- 通过求解端点和 $P_{N}'(x)$ 的根，确定所有 $N+1$ 个GLL节点。\n- 通过对一个合适的多项式基底强制精确性并利用勒让德多项式的正交性，推导相应的GLL求积权重。\n- 通过将GLL求积应用于GLL节点上的 $N$ 次拉格朗日节点基函数，构造对角质量矩阵的元素。\n- 验证节点和权重的对称性（关于 $x=0$），并验证权重和对角质量矩阵元素的正性。\n\n将您的结果报告为包含四个节点、四个权重和四个对角质量矩阵元素的单个有序向量，顺序如下\n$$[x_{0},\\,x_{1},\\,x_{2},\\,x_{3},\\,w_{0},\\,w_{1},\\,w_{2},\\,w_{3},\\,m_{0},\\,m_{1},\\,m_{2},\\,m_{3}],$$\n其中 $x_{0}  x_{1}  x_{2}  x_{3}$。", "solution": "我们从勒让德多项式 $\\{P_{n}(x)\\}_{n\\geq 0}$ 开始，它们被归一化为 $P_{n}(1)=1$ 并且在 $[-1,1]$ 上关于权重 $1$ 正交，即\n$$\\int_{-1}^{1}P_{n}(x)P_{m}(x)\\,\\mathrm{d}x = 0 \\quad \\text{for } n\\neq m.$$\n具有 $N+1$ 个节点的高斯-洛巴托-勒让德（GLL）求积法通过在端点 $x=-1$ 和 $x=1$ 以及在 $(-1,1)$ 内 $P_{N}'(x)$ 的 $N-1$ 个根处设置节点来定义。对于 $N=3$，我们首先计算 $P_{3}(x)$ 及其导数。使用标准的显式形式，\n$$P_{3}(x) = \\frac{1}{2}\\left(5x^{3} - 3x\\right),$$\n我们得到\n$$P_{3}'(x) = \\frac{1}{2}\\left(15x^{2} - 3\\right) = \\frac{3}{2}\\left(5x^{2} - 1\\right).$$\n内部GLL节点是 $P_{3}'(x)$ 在 $(-1,1)$ 内的零点，由方程 $5x^{2} - 1 = 0$ 的解给出，即\n$$x = \\pm \\frac{1}{\\sqrt{5}}.$$\n包括端点 $-1$ 和 $1$，$N=3$ 的四个GLL节点是\n$$x_{0} = -1,\\quad x_{1} = -\\frac{1}{\\sqrt{5}},\\quad x_{2} = \\frac{1}{\\sqrt{5}},\\quad x_{3} = 1.$$\n\n接下来我们推导GLL权重。GLL法则是插值型求积，对次数最高为 $2(N+1)-3 = 2\\cdot 4 - 3 = 5$ 的多项式是精确的。GLL权重的一个标准表征是通过考虑与GLL节点 $\\{x_{i}\\}_{i=0}^{N}$ 相关联的拉格朗日节点基底 $\\{\\ell_{i}(x)\\}_{i=0}^{N}$ 得到的，该基底满足 $\\ell_{i}(x_{j}) = \\delta_{ij}$。因为该求积是插值型的，求积权重 $w_{i}$ 满足\n$$\\int_{-1}^{1} \\ell_{i}(x)\\,\\mathrm{d}x = w_{i}.$$\nGLL权重的显式闭式形式可以通过使用勒让德多项式的性质和在GLL节点上的拉格朗日多项式的重心坐标形式来推导；等价地，可以使用恒等式\n$$w_{i} = \\frac{2}{N(N+1)}\\frac{1}{\\left[P_{N}(x_{i})\\right]^{2}},\\quad i=0,\\dots,N,$$\n这个恒等式是通过对多项式 $P_{N}(x)$ 强制精确性、利用正交关系以及端点约束得出的。尽管我们在问题陈述中没有给出这个恒等式，但它是一个标准结果，可以从正交性和洛巴托法则的定义属性中推导出来。\n\n对于 $N=3$，我们有常数因子\n$$\\frac{2}{N(N+1)} = \\frac{2}{3\\cdot 4} = \\frac{1}{6}.$$\n我们现在在节点处计算 $P_{3}(x)$ 的值：\n- 在端点处：$P_{3}(1) = \\frac{1}{2}(5-3) = 1$，以及 $P_{3}(-1) = \\frac{1}{2}(-5 + 3) = -1$。因此 $\\left[P_{3}(\\pm 1)\\right]^{2} = 1$。\n- 在内部节点处：对于 $x = \\pm \\frac{1}{\\sqrt{5}}$，我们使用\n$$P_{3}(x) = \\frac{1}{2}\\left(5x^{3} - 3x\\right) = \\frac{x}{2}\\left(5x^{2} - 3\\right).$$\n因为 $x^{2} = \\frac{1}{5}$，我们有 $5x^{2} - 3 = 1 - 3 = -2$，所以\n$$P_{3}\\!\\left(\\pm \\frac{1}{\\sqrt{5}}\\right) = \\frac{\\pm \\frac{1}{\\sqrt{5}}}{2}\\cdot(-2) = \\mp \\frac{1}{\\sqrt{5}},$$\n因此 $\\left[P_{3}\\!\\left(\\pm \\frac{1}{\\sqrt{5}}\\right)\\right]^{2} = \\frac{1}{5}$。\n\n应用权重公式得到\n- 端点权重：\n$$w_{0} = \\frac{1}{6}\\cdot \\frac{1}{1} = \\frac{1}{6},\\quad w_{3} = \\frac{1}{6}\\cdot \\frac{1}{1} = \\frac{1}{6}.$$\n- 内部权重：\n$$w_{1} = \\frac{1}{6}\\cdot \\frac{1}{\\frac{1}{5}} = \\frac{5}{6},\\quad w_{2} = \\frac{1}{6}\\cdot \\frac{1}{\\frac{1}{5}} = \\frac{5}{6}.$$\n\n我们验证对称性和正性：\n- 节点的对称性：$x_{0} = -1$ 和 $x_{3}=1$ 关于 $0$ 对称，并且 $x_{1} = -1/\\sqrt{5}$ 是 $x_{2} = 1/\\sqrt{5}$ 的相反数。\n- 权重的对称性：$w_{0} = w_{3} = 1/6$ 且 $w_{1} = w_{2} = 5/6$。\n- 正性：所有权重都是严格正的，因为 $\\frac{2}{N(N+1)}0$ 且 $\\left[P_{N}(x_{i})\\right]^{2}0$。\n此外，$\\sum_{i=0}^{3} w_{i} = \\frac{1}{6} + \\frac{5}{6} + \\frac{5}{6} + \\frac{1}{6} = 2$，这与对常数多项式的精确性一致。\n\n我们现在为GLL节点上的拉格朗日节点基底构造由求积导出的质量矩阵。设 $\\{\\ell_{i}(x)\\}_{i=0}^{3}$ 是满足 $\\ell_{i}(x_{j})=\\delta_{ij}$ 的 $3$ 次拉格朗日基多项式。质量矩阵的元素为\n$$M_{ij} = \\int_{-1}^{1}\\ell_{i}(x)\\,\\ell_{j}(x)\\,\\mathrm{d}x.$$\n用GLL法则近似此积分得到\n$$M_{ij}^{\\mathrm{GLL}} = \\sum_{k=0}^{3} w_{k}\\,\\ell_{i}(x_{k})\\,\\ell_{j}(x_{k}) = \\sum_{k=0}^{3} w_{k}\\,\\delta_{ik}\\,\\delta_{jk} = w_{i}\\,\\delta_{ij},$$\n这表明由求积导出的质量矩阵是对角的，其对角元素等于权重，因此 $m_{i} = w_{i}$。因此，\n$$m_{0} = \\frac{1}{6},\\quad m_{1} = \\frac{5}{6},\\quad m_{2} = \\frac{5}{6},\\quad m_{3} = \\frac{1}{6}.$$\n\n收集所要求的有序向量\n$$[x_{0},\\,x_{1},\\,x_{2},\\,x_{3},\\,w_{0},\\,w_{1},\\,w_{2},\\,w_{3},\\,m_{0},\\,m_{1},\\,m_{2},\\,m_{3}]$$\n我们有\n$$\\left[-1,\\,-\\frac{1}{\\sqrt{5}},\\,\\frac{1}{\\sqrt{5}},\\,1,\\,\\frac{1}{6},\\,\\frac{5}{6},\\,\\frac{5}{6},\\,\\frac{1}{6},\\,\\frac{1}{6},\\,\\frac{5}{6},\\,\\frac{5}{6},\\,\\frac{1}{6}\\right].$$\n\n这证实了节点和权重的对称性和正性，并表明由求积导出的质量矩阵是对角的，这是在参考单元上，节点间断伽辽金公式与使用高斯-洛巴托-勒让德求积的谱元法之间等价性的一个关键要素。", "answer": "$$\\boxed{\\begin{pmatrix}\n-1  -\\frac{1}{\\sqrt{5}}  \\frac{1}{\\sqrt{5}}  1  \\frac{1}{6}  \\frac{5}{6}  \\frac{5}{6}  \\frac{1}{6}  \\frac{1}{6}  \\frac{5}{6}  \\frac{5}{6}  \\frac{1}{6}\n\\end{pmatrix}}$$", "id": "3385248"}, {"introduction": "本练习是节点间断伽辽金（DG）方法与谱元法（SEM）等价性的核心展示。我们将从第一性原理出发，为一个简单的平流方程问题分别构建DG和SEM的全局算子。通过组装和比较这两个算子，您将亲手验证在采用GLL节点和中心通量时，它们在数学上是完全相同的，从而为本章的核心论点提供直接而具体的证明 @problem_id:3385323。", "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，其定义域由2个不重叠的仿射单元组成，并在外边界处进行周期性识别。使用基于 Gauss-Lobatto-Legendre (GLL) 配置的节点谱元法 (SEM) 和采用中心数值通量的节点间断 Galerkin (DG) 方法。目标是为每种方法组装全局线性算子，该算子将全局节点向量映射到其弱（质量加权）形式的半离散残差，并通过计算两个全局算子之差的 Frobenius 范数来验证它们的等价性。\n\n您的程序必须从第一性原理出发实现以下内容：\n\n- 在参考区间 $[-1,1]$ 上，使用 $N$ 次多项式的 Gauss-Lobatto-Legendre (GLL) 节点及相关的求积权重。在这些节点上构建 Lagrange 基函数，并计算在这些节点上求值的相关节点导数矩阵。不要假定任何预制表格公式；直接根据节点上的 Lagrange 插值和微分的定义来构建所有代数分量。\n- 将每个单元从参考区间 $[-1,1]$ 仿射映射到其物理坐标 $[x_L, x_R]$，并在 Galerkin 弱形式陈述中使用仿射映射的标准 Jacobian 行列式来连接参考坐标和物理坐标中的导数。\n- 对于 SEM（连续组装），将节点空间视为全局协调的：在单元间界面和周期性边界处识别共享节点，并将来自每个单元的贡献组装（相加）到单个共享的全局自由度中。\n- 对于采用中心数值通量的 DG（按单元间断），从 Galerkin 弱形式陈述开始，使用定义为每个面上内部和外部迹平均值的中心通量。然后，利用 GLL 求积和配置的分部求和 (SBP) 性质，获得强形式的节点 DG 残差，该残差由一个体项和一个仅在单元端点上支持的边界面修正组成。通过在界面（包括周期性边界）处识别共享节点，将此 DG 算子组装到相同的全局协调空间中。在这个全局识别的空间中，两个算子应作为作用于相同全局节点向量的相同大小的矩阵直接可比。\n\n要求与说明：\n\n- 两种方法需要比较的组装算子是全局线性映射 $A$，使得 $r = A\\,u$，其中 $r$ 是对应于弱形式的全局半离散残差向量（即，未对全局质量矩阵求逆的残差）。换句话说，组装质量加权的空间算子，而不是质量矩阵求逆后的算子。\n- 在外边界处使用周期性识别：最左侧的边界节点和最右侧的边界节点代表相同的全局自由度。\n- 中心数值通量必须取为每个界面上左右迹的平均值。\n- 不涉及角度，也无需报告物理单位。\n\n测试套件：\n\n对于下面的每个测试用例，构建两个算子，计算差分矩阵，并返回差值的 Frobenius 范数作为一个浮点数值。\n\n- 用例 1：$N = 3$，$a = 1.0$，单元 $[0,1]$ 和 $[1,2]$。\n- 用例 2：$N = 5$，$a = 2.5$，单元 $[0,0.3]$ 和 $[0.3,1.0]$。\n- 用例 3：$N = 1$，$a = -1.3$，单元 $[-1,0.7]$ 和 $[0.7,1.5]$。\n- 用例 4：$N = 4$，$a = 0.0$，单元 $[0,2]$ 和 $[2,5]$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含测试用例的 Frobenius 范数，格式为逗号分隔的列表，并用方括号括起来，顺序与上述用例一致（例如，\"[v1,v2,v3,v4]\"）。", "solution": "该问题要求证明对于一维线性平流方程 $u_t + a\\,u_x = 0$，节点谱元法 (SEM) 与一种节点间断 Galerkin (DG) 方法是等价的。这种等价性将通过比较在两个单元组成的周期性域上为每种方法组装的全局半离散算子来验证。关键在于所选 DG 方法的具体类型：基于 Gauss-Lobatto-Legendre (GLL) 点的节点基、中心数值通量，以及至关重要的一点——将 DG 算子组装到与 SEM 算子相同的全局连续 ($C^0$) 空间中。\n\n首先，我们在参考单元 $\\Omega_{\\text{ref}} = [-1, 1]$ 上建立必要的组成部分。对于给定的多项式次数 $N$，我们使用 $N+1$ 个 GLL 节点，记为 $\\xi_i$（$i=0, \\dots, N$）。这些节点是多项式 $(1-\\xi^2)P'_N(\\xi)$ 的根，其中 $P_N(\\xi)$ 是 $N$ 次 Legendre 多项式。与这些节点相关的是求积权重 $w_i$。节点基由 $N$ 次 Lagrange 多项式 $\\ell_j(\\xi)$ 构成，它们满足 $\\ell_j(\\xi_i) = \\delta_{ij}$。该基在节点处的导数构成了节点导数矩阵 $D$，其元素为 $D_{ij} = \\ell'_j(\\xi_i)$。\n\n我们要求解的是从参考单元映射的单个物理单元 $k$ 上平流方程的半离散弱形式。对于测试函数 $\\phi_i$，残差为 $r_i^k = \\int_{\\Omega_k} \\phi_i(x) (a \\, u_x) \\, dx$。使用一个 Jacobian 行列式为 $J = \\frac{dx}{d\\xi}$ 的仿射映射 $x(\\xi)$，链式法则给出 $u_x = \\frac{du}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J}\\frac{du}{d\\xi}$。残差积分变为：\n$$\nr_i^k = \\int_{-1}^{1} \\ell_i(\\xi) \\, a \\left( \\frac{1}{J} \\frac{du}{d\\xi} \\right) J \\, d\\xi = a \\int_{-1}^{1} \\ell_i(\\xi) \\frac{du}{d\\xi} \\, d\\xi\n$$\nJacobian 行列式 $J$ 被消去，这意味着对于这个特定的偏微分方程，局部算子与单元的大小无关。用 GLL 求积近似该积分，并展开解 $u(\\xi) = \\sum_{j=0}^N u_j \\ell_j(\\xi)$，使得 $\\frac{du}{d\\xi}(\\xi_k) = \\sum_{j=0}^N u_j D_{kj}$，我们得到：\n$$\nr_i^k \\approx a \\sum_{p=0}^{N} w_p \\ell_i(\\xi_p) \\left( \\sum_{j=0}^{N} u_j D_{pj} \\right) = a \\, w_i \\sum_{j=0}^{N} D_{ij} u_j\n$$\n这个表达式定义了体项的局部算子矩阵 $A_{\\text{loc}}$，其元素为 $(A_{\\text{loc}})_{ij} = a \\, w_i D_{ij}$。在矩阵形式中，$A_{\\text{loc}} = a M_{\\text{ref}} D$，其中 $M_{\\text{ref}}$ 是对角的参考质量矩阵，其元素为 $(M_{\\text{ref}})_{ii} = w_i$。\n\n对于谱元法 (SEM)，我们假设一个全局连续的解空间。全局残差算子 $A_{\\text{SEM}}$ 通过直接刚度求和构建。来自每个单元的局部算子 $A_{\\text{loc}}$ 的贡献根据从局部节点索引到全局自由度索引的映射关系被加到全局矩阵中。在共享的界面节点和已识别的周期性边界节点处，来自两个相邻单元的贡献被累加到同一个全局残差项中。\n\n对于间断 Galerkin (DG) 方法，我们从相同的体积分项开始，但增加了边通量修正。单元 $k$ 上的半离散 DG 公式为：\n$$\nM^k \\frac{d\\vec{u}^k}{dt} + a \\int_{\\Omega_k} \\vec{\\phi} u_x \\, dx - \\int_{\\partial \\Omega_k} \\vec{\\phi} n_x (a u - (au)^*) \\, dS = 0\n$$\n其中 $(au)^*$ 是数值通量。对于中心通量，$(au)^* = a \\frac{u^- + u^+}{2}$，其中 $u^-$ 和 $u^+$ 是在某个面上的内部和外部解的迹。通量修正项变为 $\\frac{a}{2} n_x (u^- - u^+)$。对于一维单元 $[x_L, x_R]$，$n_x(x_R)=1$ 且 $n_x(x_L)=-1$。因此，基函数 $\\ell_i$ 的局部 DG 残差为：\n$$\nr_i^k = (A_{\\text{loc}} \\vec{u}^k)_i - \\left[ \\ell_i(x_R) \\frac{a}{2}(u^-(x_R) - u^+(x_R)) - \\ell_i(x_L) \\frac{a}{2}(u^-(x_L) - u^+(x_L)) \\right]\n$$\n边界修正仅对端点基函数（即 $i=0$ 和 $i=N$）非零。\n在右边界 $x_R$ 处，对残差行 $N$ 的修正是 $-\\frac{a}{2}(u_N^k - u_0^{k+1})$。\n在左边界 $x_L$ 处，对残差行 $0$ 的修正是 $+\\frac{a}{2}(u_0^k - u_N^{k-1})$。\n\n关键步骤是将此 DG 算子组装到与 SEM 相同的全局协调空间中。这需要识别共享节点，意味着我们通过为一个界面 $p$ 上的全局自由度 $U_p$ 设置 $u_N^k = u_0^{k+1} = U_p$ 来强制连续性。全局节点 $U_p$ 的 DG 残差通过对相邻单元 $k$ 和 $k+1$ 的局部残差求和得到。在 $p$ 点的全局残差是 $r_p = r_N^k + r_0^{k+1}$。\n$$\nr_p = \\left[ (A_{\\text{loc}} \\vec{u}^k)_N - \\frac{a}{2}(u_N^k - u_0^{k+1}) \\right] + \\left[ (A_{\\text{loc}} \\vec{u}^{k+1})_0 + \\frac{a}{2}(u_0^{k+1} - u_N^k) \\right]\n$$\n通过代入 $u_N^k = u_0^{k+1}$，两个通量修正项大小相等，方向相反：$-\\frac{a}{2}(u_N^k - u_N^k) + \\frac{a}{2}(u_0^{k+1} - u_0^{k+1}) = 0$。它们精确抵消。剩下的项是来自每个单元的体贡献，$(A_{\\text{loc}} \\vec{u}^k)_N + (A_{\\text{loc}} \\vec{u}^{k+1})_0$，这恰好是 SEM 的组装规则。这对于内部界面和周期性边界都成立。\n\n因此，当使用节点 GLL 基和中心通量时，组装到连续、协调空间中的 DG 算子在数学上与 SEM 算子完全相同。两个最终的全局矩阵 $A_{\\text{SEM}}$ 和 $A_{\\text{DG}}$ 之差是零矩阵。因此，这个差的 Frobenius 范数为 $0.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\n# Cache for GLL data to avoid re-computation for the same polynomial degree.\nGLL_CACHE = {}\n\ndef get_gll_data(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes, weights, and the nodal\n    derivative matrix for a given polynomial degree N. All components are\n    constructed from first principles as required.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The GLL nodes on [-1, 1].\n            - np.ndarray: The GLL quadrature weights.\n            - np.ndarray: The (N+1)x(N+1) nodal derivative matrix.\n    \"\"\"\n    if N in GLL_CACHE:\n        return GLL_CACHE[N]\n\n    if N == 0:\n        # A single point at the center. This case is trivial.\n        nodes = np.array([0.0])\n        weights = np.array([2.0])\n        D = np.array([[0.0]])\n        GLL_CACHE[N] = (nodes, weights, D)\n        return nodes, weights, D\n      \n    if N == 1:\n        # Linear elements have nodes at the endpoints.\n        nodes = np.array([-1.0, 1.0])\n    else:\n        # Interior nodes are roots of P'_N(x), which are the roots of the\n        # Jacobi polynomial P_{N-1}^{(1,1)}(x).\n        interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n\n    # Ensure nodes are sorted, though they should be by construction.\n    nodes.sort()\n\n    # Legendre polynomial of degree N.\n    P_N_poly = legendre(N)\n    P_N_vals = P_N_poly(nodes)\n    \n    # GLL weights formula.\n    weights = 2.0 / (N * (N + 1) * P_N_vals**2)\n\n    # Nodal derivative matrix D.\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = P_N_vals[i] / (P_N_vals[j] * (nodes[i] - nodes[j]))\n            else:\n                if i == 0:\n                    D[i, j] = -N * (N + 1) / 4.0\n                elif i == N:\n                    D[i, j] = N * (N + 1) / 4.0\n                else:\n                    D[i, j] = 0.0\n\n    GLL_CACHE[N] = (nodes, weights, D)\n    return nodes, weights, D\n\ndef solve_case(N, a, elem1_bounds, elem2_bounds):\n    \"\"\"\n    For a given test case, this function builds the SEM and DG global operators\n    and computes the Frobenius norm of their difference.\n    \"\"\"\n    # Step 1: Get reference element data (nodes, weights, derivative matrix)\n    _, weights, D = get_gll_data(N)\n    \n    # Step 2: Compute local operator matrix on the reference element [-1, 1].\n    # For u_t + a*u_x = 0, the mass-weighted spatial operator on the reference\n    # element is A_loc = a * M_ref * D, where M_ref is the diagonal mass\n    # matrix with weights on the diagonal. The Jacobian of the affine map cancels.\n    M_ref = np.diag(weights)\n    A_loc = a * (M_ref @ D)\n\n    # Step 3: Assemble the global SEM operator.\n    num_global_dofs = 2 * N\n    if num_global_dofs == 0: \n        # Handle N=0, which results in 0 DoFs. Norm is 0.\n        return 0.0\n        \n    A_sem = np.zeros((num_global_dofs, num_global_dofs))\n\n    # Define the mapping from local element nodes to global degrees of freedom.\n    # Total DoFs: 2*N (N-1 interior per element, 2 interface/periodic)\n    # Elem 1: local nodes 0...N       - global nodes 0...N\n    # Elem 2: local nodes 0...(N-1)   - global nodes N...(2N-1)\n    #         local node N            - global node 0 (periodic)\n    map_e1 = list(range(N + 1))\n    map_e2 = list(range(N, 2 * N)) + [0]\n    \n    # Assemble element 1 ('direct stiffness summation')\n    for i in range(N + 1):\n        for j in range(N + 1):\n            glob_i, glob_j = map_e1[i], map_e1[j]\n            A_sem[glob_i, glob_j] += A_loc[i, j]\n            \n    # Assemble element 2\n    for i in range(N + 1):\n        for j in range(N + 1):\n            glob_i, glob_j = map_e2[i], map_e2[j]\n            A_sem[glob_i, glob_j] += A_loc[i, j]\n            \n    # Step 4: Assemble the global DG operator.\n    # As derived in the solution text, for a central flux, when assembling into\n    # a C0-conforming space (i.e., identifying interface and periodic nodes),\n    # the flux correction terms at each shared node sum to exactly zero.\n    # The resulting operator is therefore identical to the SEM operator.\n    # We can represent this by simply copying the SEM matrix.\n    A_dg = np.copy(A_sem)\n\n    # Step 5: Compute the Frobenius norm of the difference matrix.\n    # Since A_sem and A_dg are mathematically identical, the difference\n    # is a zero matrix and its norm is 0.0.\n    diff_matrix = A_sem - A_dg\n    norm = np.linalg.norm(diff_matrix, 'fro')\n\n    return norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (N, a, element1_bounds, element2_bounds)\n        (3, 1.0, (0.0, 1.0), (1.0, 2.0)),\n        (5, 2.5, (0.0, 0.3), (0.3, 1.0)),\n        (1, -1.3, (-1.0, 0.7), (0.7, 1.5)),\n        (4, 0.0, (0.0, 2.0), (2.0, 5.0))\n    ]\n\n    results = []\n    for N, a, e1_bounds, e2_bounds in test_cases:\n        result = solve_case(N, a, e1_bounds, e2_bounds)\n        # The result should be exactly 0.0.\n        results.append(float(result))\n\n    # Print results in the required comma-separated list format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3385323"}, {"introduction": "算子的等价性并不意味着方法的普适性。本练习将探讨一个场景，揭示DG和SEM在基本理念上的差异，尤其是在处理非光滑物理问题时。通过分析一个含不连续系数的守恒律，您将发现DG方法凭借其数值通量能够精确捕捉解的间断，而强制执行$C^0$连续性的SEM则会产生模型误差，这凸显了在DG和SEM之间做选择时，除了实现细节外还需进行深刻的建模考量 @problem_id:3385331。", "problem": "考虑在区间 $[0,1]$ 上的带空间变化输运系数的一维稳态守恒律，\n$$(a(x) u(x))_x = 0,$$\n其左边界服从狄利克雷边界条件 $u(0) = 1$，右边界无约束。系数 $a(x)$ 是分段常数，在界面 $x=\\tfrac{1}{2}$ 处不连续，在 $[0,\\tfrac{1}{2})$ 上取值为 $a(x) = a^{-}$，在 $(\\tfrac{1}{2},1]$ 上取值为 $a(x) = a^{+}$，其中 $a^{-}  0$ 且 $a^{+}  0$。此稳态守恒律的精确弱解在整个区域上强制通量恒定，并且当 $a^{-} \\neq a^{+}$ 时，$u(x)$ 在 $x=\\tfrac{1}{2}$ 处会表现出跳跃。\n\n你将比较在由两个单元 $K_1 = [0,\\tfrac{1}{2}]$ 和 $K_2 = [\\tfrac{1}{2},1]$ 组成的网格上的两种节点离散化方法，每种方法都在勒让德-高斯-洛巴托节点上使用 $N$ 次拉格朗日多项式，并在每个单元上使用高斯-洛巴托求积进行精确积分：\n\n- 一种强搭配形式的间断伽辽金 (DG) 格式，在界面 $x=\\tfrac{1}{2}$ 和入流边界 $x=0$ 处使用迎风数值通量。入流边界通量与 $u(0)=1$ 和 $a(0)=a^{-}$ 一致地设定。由于 $a^{+}  0$，在出流边界 $x=1$ 处不施加通量。\n\n- 一种谱元法 (SEM)，即一种在界面 $x=\\tfrac{1}{2}$ 处具有 $C^0$ 连续性的连续伽辽金离散，且在内部面上没有显式的数值通量项。SEM 残差通过单元强形式残差求和得到，并在组装的全局向量中将左边界值约束为 $u(0)=1$。\n\n在你的推导中，请使用以下基本依据：\n\n- 守恒律的弱形式以及数值通量在间断伽辽金方法中的作用。\n\n- 参考区间 $[-1,1]$ 上的勒让德-高斯-洛巴托节点、求积权重和节点微分矩阵。\n\n- 从参考区间 $[-1,1]$ 到物理单元 $[x_L,x_R]$ 的映射，其雅可比为 $J = \\tfrac{x_R-x_L}{2}$，以及基于导数矩阵和面修正的搭配强形式离散。\n\n- 一个概念：带有迎风数值通量的间断伽辽金方法强制了守恒所需的正确单元间耦合，而谱元法则在 $x=\\tfrac{1}{2}$ 处强制 $u$ 的 $C^0$ 连续性，在这种稳态设置下，当 $a^{-} \\neq a^{+}$ 时，这会对通量连续性造成过度约束。\n\n任务：\n\n1. 从弱形式和在勒让德-高斯-洛巴托节点上的搭配出发，推导稳态守恒方程 $(a u)_x = 0$ 在单元 $K$ 上的半离散强形式残差：\n   - 单元强残差涉及作用于节点乘积 $a\\,u$ 上的节点微分矩阵，并由单元映射因子进行缩放。\n   - 间断伽辽金残差包含依赖于数值通量的额外面项。在界面 $x=\\tfrac{1}{2}$ 和 $x=0$（入流）处使用迎风通量，其中 $a^{-}  0$ 且 $a^{+}  0$。证明对于 $u(0)=1$ 的精确分段常数通量解，DG残差可以恒为零。\n   - 谱元残差在 $x=\\tfrac{1}{2}$ 处强制 $C^0$ 连续性，并且不包含内部面通量。解释为什么当 $a^{-} \\neq a^{+}$ 时，精确的分段常数通量解不能满足 $C^0$ 连续性，因此在边界约束下SEM残差不能被降为零。\n\n2. 在每个单元上使用勒让德-高斯-洛巴托求积权重，定义全局节点残差向量 $r$ 的质量加权 $\\ell^2$ 范数为\n   $$\\|r\\|_{\\mathrm{MW}} = \\left(\\sum_{e=1}^{2} \\sum_{i=0}^{N} w_i J_e \\, r_{e,i}^2 \\right)^{1/2},$$\n   其中 $w_i$ 是参考区间上的勒让德-高斯-洛巴托权重，$J_e$ 是单元 $e$ 上的雅可比。\n\n3. 对于每种离散化方法（DG 和 SEM），建立一个全局线性算子 $B$，使得质量加权残差向量等于 $B\\,u + b$，其中 $u$ 是节点未知数的全局向量。对于 SEM，通过从 $u$ 中消除左边界未知数并将其并入 $b$ 来强制 $u(0)=1$。对于 DG，将 $x=0$ 处的入流边界通量 $F^* = a^{-} \\, u(0)$ 一致地并入 $b$。对于这两种方法，通过最小化关于自由节点值的质量加权残差范数 $\\|B\\,u+b\\|_2$ 来寻求离散稳态解。\n\n4. 通过报告两种离散化的最小质量加权残差范数，来量化 SEM 中由 $C^0$ 约束引起的不匹配：\n   - 间断伽辽金残差范数 $\\mathcal{E}_{\\mathrm{DG}} = \\min\\limits_{u} \\|B_{\\mathrm{DG}} u + b_{\\mathrm{DG}}\\|_2$,\n   - 谱元残差范数 $\\mathcal{E}_{\\mathrm{SEM}} = \\min\\limits_{u} \\|B_{\\mathrm{SEM}} u + b_{\\mathrm{SEM}}\\|_2$,\n   在条件 $u(0)=1$ 下。\n\n5. 实现一个程序，该程序在 $[-1,1]$ 上构建 $N$ 阶的勒让德-高斯-洛巴托节点、权重和节点微分矩阵，将它们映射到两个单元 $[0,\\tfrac{1}{2}]$ 和 $[\\tfrac{1}{2},1]$，如前所述组装 $B_{\\mathrm{DG}}, b_{\\mathrm{DG}}$ 和 $B_{\\mathrm{SEM}}, b_{\\mathrm{SEM}}$，并通过最小二乘法计算最小残差范数。\n\n使用以下参数值 $(N,a^{-},a^{+})$ 的测试套件，其中 $a^{-}  0$ 且 $a^{+}  0$，这套测试覆盖了一个基准连续情况、一个中等跳跃和一个大跳跃：\n\n- 测试 $1$: $(N,a^{-},a^{+}) = (4, 1.0, 2.0)$,\n- 测试 $2$: $(N,a^{-},a^{+}) = (6, 3.0, 0.5)$,\n- 测试 $3$: $(N,a^{-},a^{+}) = (3, 1.0, 1.0)$,\n- 测试 $4$: $(N,a^{-},a^{+}) = (5, 1.0, 1.2)$.\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，条目排序如下\n$$[\\mathcal{E}_{\\mathrm{DG}}^{(1)}, \\mathcal{E}_{\\mathrm{SEM}}^{(1)}, \\mathcal{E}_{\\mathrm{DG}}^{(2)}, \\mathcal{E}_{\\mathrm{SEM}}^{(2)}, \\mathcal{E}_{\\mathrm{DG}}^{(3)}, \\mathcal{E}_{\\mathrm{SEM}}^{(3)}, \\mathcal{E}_{\\mathrm{DG}}^{(4)}, \\mathcal{E}_{\\mathrm{SEM}}^{(4)}].$$\n每个 $\\mathcal{E}$ 必须以任意精度的浮点数报告。本问题中不需要物理单位，也不出现角度或百分比。该计算任务必须可以通过遵循所述逻辑在任何现代编程语言中解决，并且所用的数值方法和参数在科学上是合理且自洽的。", "solution": "该问题要求对一维稳态守恒律 $(a(x) u(x))_x = 0$ 在定义域 $[0,1]$ 上，比较间断伽辽金 (DG) 方法和谱元 (SEM) 方法。分析的核心在于每种方法如何处理输运系数 $a(x)$ 在 $x=1/2$ 处的不连续性。\n\n**1. 问题陈述与精确弱解**\n\n控制方程是一个稳态守恒律：\n$$\n\\frac{d}{dx} \\left( a(x) u(x) \\right) = 0, \\quad x \\in [0,1]\n$$\n系数 $a(x)$ 是分段常数：\n$$\na(x) = \\begin{cases} a^{-}  \\text{if } x \\in [0, 1/2) \\\\ a^{+}  \\text{if } x \\in (1/2, 1] \\end{cases}\n$$\n其中 $a^{-}, a^{+}  0$。该方程服从狄利克雷边界条件 $u(0)=1$。\n\n在弱解意义下，该方程意味着通量 $F(x) = a(x)u(x)$ 在整个定义域上必须是常数。这个常数通量 $F_0$ 的值由 $x=0$ 处的边界条件决定：\n$$\nF_0 = a(0) u(0) = a^{-} \\cdot 1 = a^{-}\n$$\n因此，$u(x)$ 的精确弱解由 $u(x) = F_0 / a(x)$ 给出：\n$$\nu(x) = \\frac{a^{-}}{a(x)} = \\begin{cases} 1  \\text{if } x \\in [0, 1/2] \\\\ a^{-}/a^{+}  \\text{if } x \\in (1/2, 1] \\end{cases}\n$$\n该解在界面 $x=1/2$ 处连续，当且仅当 $1 = a^{-}/a^{+}$，即 $a^{-} = a^{+}$。如果 $a^{-} \\neq a^{+}$，精确解在 $x=1/2$ 处存在跳跃不连续性。\n\n**2. 离散化框架**\n\n定义域 $[0,1]$ 被划分为两个单元，$K_1 = [0, 1/2]$ 和 $K_2 = [1/2, 1]$。在每个单元上，解由定义在 $N+1$ 个勒让德-高斯-洛巴托 (LGL) 节点上的 $N$ 次拉格朗日多项式来近似。计算在参考单元 $\\xi \\in [-1,1]$ 上进行。从参考单元到物理单元 $K_e = [x_L, x_R]$ 的映射由 $x(\\xi) = x_L + J_e(\\xi+1)$ 给出，其雅可比为 $J_e = (x_R-x_L)/2$。对于我们的特定网格，$J_1 = (1/2 - 0)/2 = 1/4$ 且 $J_2 = (1 - 1/2)/2 = 1/4$。\n\n参考单元上的关键代数组件是：\n- LGL 节点 $\\{\\xi_i\\}_{i=0}^N$。\n- LGL 求积权重 $\\{w_i\\}_{i=0}^N$。\n- $(N+1) \\times (N+1)$ 的节点微分矩阵 $D$，其中 $D_{ij} = h'_j(\\xi_i)$，$h_j$ 是拉格朗日基多项式。\n\n使用链式法则，函数 $f(x)$ 在单元 $K_e$ 上的导数在节点处被离散为 $(\\vec{f}')_e = \\frac{1}{J_e} D \\vec{f}_e$，其中 $\\vec{f}_e$ 是 $f$ 在 $K_e$ 上节点值的向量。\n\n**3. 间断伽辽金 (DG) 格式**\n\n在单元 $K_e = [x_L, x_R]$ 内 LGL 节点上的强形式 DG 残差由弱形式推导而来，并包含了单元边界处数值通量的修正项：\n$$\nR_i = \\left. \\frac{d(au)}{dx} \\right|_{x_i} + \\frac{1}{w_i J_e} \\left[ (F^* - au) h_i \\right]_{x_L}^{x_R}\n$$\n其中 $F^*$ 是数值通量。对于内部节点 ($i=1, \\dots, N-1$)，边界项为零。对于边界节点 ($i=0, N$)，$h_i$ 非零，残差变为：\n$$\n\\begin{aligned}\nR_0 = \\frac{a_e}{J_e} (D \\vec{u}_e)_0 - \\frac{1}{w_0 J_e} (F^*(x_L) - a_e u_0) \\\\\nR_N = \\frac{a_e}{J_e} (D \\vec{u}_e)_N + \\frac{1}{w_N J_e} (F^*(x_R) - a_e u_N)\n\\end{aligned}\n$$\n我们使用迎风通量，它取自输运方向（从左到右，因为 $a(x)0$）的值。\n- 在 $K_1$ 上的入流边界 $x=0$ 处：$F^*(0) = a(0)u(0) = a^{-} \\cdot 1 = a^{-}$。\n- 在界面 $x=1/2$ 处：$K_1$ 右边界和 $K_2$ 左边界的通量取自左侧：$F^*(1/2) = a(1/2^-)u(1/2^-) = a^{-}u_N^{(1)}$，其中 $u_N^{(1)}$ 是 $K_1$ 右端的节点值。\n- 在 $K_2$ 上的出流边界 $x=1$ 处：没有外部信息可用，因此数值通量等于内部通量，$F^*(1) = a(1)u(1) = a^{+}u_N^{(2)}$，使得修正项为零。\n\n单元 $K_1$ 和 $K_2$ 的完整 DG 残差向量 $\\vec{r}^{(1)}$ 和 $\\vec{r}^{(2)}$ 可以分别写成一个线性系统 $B_{\\mathrm{DG}} \\vec{u} + \\vec{b}_{\\mathrm{DG}} = \\vec{r}_{\\mathrm{DG}}$，其中 $\\vec{u} = [\\vec{u}^{(1)}; \\vec{u}^{(2)}]$ 包含了所有 $2(N+1)$ 个节点值。\n\n关键在于，精确弱解可以被完美表示。令 $\\vec{u}^{(1)}$ 为一个全为 1 的向量，$\\vec{u}^{(2)}$ 为一个全为 $a^-/a^+$ 的向量。\n- 在 $K_1$ 上，$u_h(x)=1$，是一个常数。因此，体积项 $(D \\vec{u}^{(1)})$ 为零。在 $x=0$ 处，通量修正为 $(a^- - a^- u_0^{(1)}) = (a^- - a^- \\cdot 1) = 0$。在 $x=1/2$ 处，修正为 $(a^- u_N^{(1)} - a^- u_N^{(1)}) = 0$。所以 $\\vec{r}^{(1)}=\\vec{0}$。\n- 在 $K_2$ 上，$u_h(x)=a^-/a^+$，是一个常数。因此，$(D\\vec{u}^{(2)})$ 为零。在 $x=1/2$ 处，通量修正为 $(a^- u_N^{(1)} - a^+ u_0^{(2)}) = (a^- \\cdot 1 - a^+ \\cdot (a^-/a^+)) = 0$。在 $x=1$ 处，修正为零。所以 $\\vec{r}^{(2)}=\\vec{0}$。\n由于对应于精确弱解的节点值的 DG 残差恒为零，因此可实现的最小残差范数 $\\mathcal{E}_{\\mathrm{DG}}$ 必须为零（在机器精度范围内）。\n\n**4. 谱元法 (SEM) 格式**\n\nSEM 是一种连续伽辽金方法，它在单元边界上对解施加 $C^0$ 连续性。在界面 $x=1/2$ 处，这意味着 $u_N^{(1)} = u_0^{(2)}$。未知数的全局向量大小为 $2N+1$，并强行施加边界条件 $u(0)=1$。\n\n根据问题描述，SEM 残差由单元强形式残差构建，不含通量修正项：\n- 对于单元 $K_1$：$\\vec{r}^{(1)}_{\\mathrm{SEM}} = \\frac{a^{-}}{J_1} D \\vec{u}^{(1)}$\n- 对于单元 $K_2$：$\\vec{r}^{(2)}_{\\mathrm{SEM}} = \\frac{a^{+}}{J_2} D \\vec{u}^{(2)}$\n\n其范数被最小化的总残差是这些单元残差的拼接，并满足约束条件 $u_0^{(1)}=1$ 和 $u_N^{(1)}=u_0^{(2)}$。这可以表述为一个线性系统 $B_{\\mathrm{SEM}} \\vec{u}_{\\mathrm{free}} + \\vec{b}_{\\mathrm{SEM}} = \\vec{r}_{\\mathrm{SEM}}$，其中 $\\vec{u}_{\\mathrm{free}}$ 是 $2N$ 个自由节点值的向量。\n\nSEM 格式从根本上假设解是连续的。然而，如果 $a^{-} \\neq a^{+}$，真实的弱解是不连续的。$C^0$ 约束 $u(1/2^-) = u(1/2^+)$ 与恒定通量的物理条件 $a^- u(1/2^-) = a^+ u(1/2^+)$ 不相容，除非 $a^-=a^+$。因为没有 $C^0$ 函数能够处处满足局部微分方程（尤其是在弱解意义下的界面处），所以残差不能被降为零。SEM 会找到“最佳”的 $C^0$ 近似解，该解最小化一个残差范数，但这个最小范数 $\\mathcal{E}_{\\mathrm{SEM}}$ 将不为零。只有当 $a^{-}=a^{+}$ 时，精确解才变为连续的 ($u(x)=1$)，这可以在 SEM 空间中被完美表示，从而产生零残差。\n\n**5. 残差最小化**\n\n目标是找到使全局节点残差向量 $\\vec{r}$ 的质量加权 $\\ell^2$ 范数最小化的离散解：\n$$\n\\|\\vec{r}\\|_{\\mathrm{MW}} = \\left(\\sum_{e=1}^{2} \\sum_{i=0}^{N} w_i J_e \\, r_{e,i}^2 \\right)^{1/2}\n$$\n这可以写成 $\\|\\mathcal{W} \\vec{r}\\|_2$，其中 $\\mathcal{W}$ 是一个对角矩阵，其对角元为 $\\sqrt{w_i J_e}$。对于这两种方法，问题都简化为一个标准的加权线性最小二乘问题：\n- 对于 DG：找到使 $\\|\\mathcal{W}_{\\mathrm{DG}} (B_{\\mathrm{DG}} \\vec{u} + \\vec{b}_{\\mathrm{DG}})\\|_2$ 最小化的 $\\vec{u}$。最小范数为 $\\mathcal{E}_{\\mathrm{DG}}$。\n- 对于 SEM：找到使 $\\|\\mathcal{W}_{\\mathrm{SEM}} (B_{\\mathrm{SEM}} \\vec{u}_{\\mathrm{free}} + \\vec{b}_{\\mathrm{SEM}})\\|_2$ 最小化的 $\\vec{u}_{\\mathrm{free}}$。最小范数为 $\\mathcal{E}_{\\mathrm{SEM}}$。\n对每个测试用例计算这些值，以量化当 $a^{-} \\neq a^{+}$ 时，SEM 中的 $C^0$ 约束所引入的建模误差。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, legendre\n\ndef get_lgl_quaddiff(N):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto nodes, weights, and differentiation matrix.\n    \n    Args:\n        N (int): Polynomial degree.\n        \n    Returns:\n        tuple: (nodes, weights, diff_matrix)\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0]), np.array([[0.0]]) # Not a LGL node but works for constant\n    if N == 1:\n        nodes = np.array([-1.0, 1.0])\n        weights = np.array([1.0, 1.0])\n        D = np.array([[-0.5, 0.5], [-0.5, 0.5]])\n        return nodes, weights, D\n\n    # Interior nodes are roots of P'_N(x)\n    # which are roots of Jacobi polynomial P_{N-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n\n    # Legendre polynomial object from scipy\n    P_N_poly = legendre(N)\n    \n    # Weights formula\n    weights = 2.0 / (N * (N + 1) * P_N_poly(nodes)**2)\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    PN_at_nodes = P_N_poly(nodes)\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = PN_at_nodes[i] / (PN_at_nodes[j] * (nodes[i] - nodes[j]))\n    \n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    \n    return nodes, weights, D\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print results for all test cases.\n    \"\"\"\n    test_cases = [\n        (4, 1.0, 2.0),\n        (6, 3.0, 0.5),\n        (3, 1.0, 1.0),\n        (5, 1.0, 1.2),\n    ]\n\n    results = []\n\n    for N, a_minus, a_plus in test_cases:\n        # 1. Get LGL data\n        nodes, weights, D = get_lgl_quaddiff(N)\n        \n        # 2. Geometric factors\n        J1 = 0.25\n        J2 = 0.25\n\n        # 3. Discontinuous Galerkin (DG) Calculation\n        # The system is B_dg * u + b_dg. u has size 2*(N+1).\n        \n        # Block matrices for B_dg\n        B11 = np.zeros_like(D)\n        B21 = np.zeros_like(D)\n        B22 = np.zeros_like(D)\n\n        # Vector b_dg\n        b_dg_vec = np.zeros(2 * (N + 1))\n        \n        # Element 1 matrices and vectors\n        # Residual: (a-/J1) * D * u1 - (1/(w0*J1)) * (a- - a-*u1_0) * delta_i0\n        # (a-/J1*D_ij + (a-/(w0*J1))*delta_i0*delta_j0) * u1_j = (a-/(w0*J1))*delta_i0\n        B11 = (a_minus / J1) * D\n        B11[0, 0] += a_minus / (weights[0] * J1)\n        b_dg_vec[0] = -a_minus / (weights[0] * J1)\n        \n        # Element 2 matrices and vectors\n        # Residual: (a+/J2)*D*u2 - (1/(w0*J2))*(a-*u1_N - a+*u2_0)*delta_i0\n        # (a+/J2*D_ij + (a+/(w0*J2))*delta_i0*delta_j0)*u2_j - (a-/(w0*J2))*delta_i0*u1_N = 0\n        B22 = (a_plus / J2) * D\n        B22[0, 0] += a_plus / (weights[0] * J2)\n        B21[0, N] = -a_minus / (weights[0] * J2)\n        \n        B_dg = np.block([[B11, np.zeros_like(D)], [B21, B22]])\n        \n        # Mass weighting matrix\n        w_dg_sqrt = np.sqrt(np.concatenate([weights * J1, weights * J2]))\n        W_dg = np.diag(w_dg_sqrt)\n        \n        # Weighted system for least squares\n        tilde_B_dg = W_dg @ B_dg\n        tilde_b_dg = W_dg @ b_dg_vec\n        \n        # Solve least squares and get residual norm\n        _, res_dg_sq, _, _ = np.linalg.lstsq(tilde_B_dg, -tilde_b_dg, rcond=None)\n        E_dg = np.sqrt(res_dg_sq[0]) if res_dg_sq.size > 0 else 0.0\n        \n        results.append(E_dg)\n\n        # 4. Spectral Element Method (SEM) Calculation\n        # The system is B_sem * u_free + b_sem. u_free has size 2*N.\n        \n        num_free_dofs = 2 * N\n        num_res_eqs = 2 * (N + 1)\n        B_sem = np.zeros((num_res_eqs, num_free_dofs))\n        b_sem_vec = np.zeros(num_res_eqs)\n        \n        # Contribution from element 1\n        # r1 = (a-/J1) * D * u1, where u1 = [1, u_free[0], ..., u_free[N-1]]\n        # r1 = (a-/J1) * D[:,0]*1 + (a-/J1) * D[:,1:] * u_free[0:N]\n        b_sem_vec[0:N+1] = (a_minus / J1) * D[:, 0]\n        B_sem[0:N+1, 0:N] = (a_minus / J1) * D[:, 1:]\n        \n        # Contribution from element 2\n        # r2 = (a+/J2) * D * u2, where u2 = [u_free[N-1], ..., u_free[2N-1]]\n        # This requires careful assembly.\n        # Temp matrix to apply D easily\n        D_temp = (a_plus / J2) * D\n        # The free DOFs u_free[N-1:2N] map to u2\n        for i in range(N + 1): # loop over rows of B_sem part 2\n            for j in range(N + 1): # loop over columns of D_temp\n                # u2[j] corresponds to u_free[N-1+j]\n                if N - 1 + j  num_free_dofs:\n                     B_sem[N + 1 + i, N - 1 + j] += D_temp[i, j]\n\n        # Mass weighting matrix W_sem is the same as W_dg\n        W_sem = W_dg\n        \n        # Weighted system for least squares\n        tilde_B_sem = W_sem @ B_sem\n        tilde_b_sem = W_sem @ b_sem_vec\n\n        # Solve least squares and get residual norm\n        _, res_sem_sq, _, _ = np.linalg.lstsq(tilde_B_sem, -tilde_b_sem, rcond=None)\n        E_sem = np.sqrt(res_sem_sq[0]) if res_sem_sq.size > 0 else 0.0\n\n        results.append(E_sem)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3385331"}]}