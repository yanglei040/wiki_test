{"hands_on_practices": [{"introduction": "在深入研究WENO限制器复杂的非线性行为之前，理解其底层高阶间断Galerkin (DG) 格式的基本属性至关重要。本练习将重点关注光滑解这一“理想”场景，在此场景下限制器应保持非激活状态。我们将通过傅里叶分析来量化该格式固有的数值色散与耗散，这是评估其精度的关键指标。[@problem_id:3429573]", "problem": "考虑一维线性平流方程 $u_t + a u_x = 0$，其具有周期性边界条件，在一个宽度为 $h$ 的均匀单元网格上，使用多项式次数为 $p=3$ 的间断伽辽金 (DG) 方法和迎风数值通量进行离散化。假设任何非线性限制器，例如加权基本无振荡 (WENO) 限制器或总变差有界 (TVB) 限制器，在光滑区域内不被激活，因此线性化半离散算子与底层的 DG 算子一致。在参考单元 $r \\in [-1,1]$ 上，使用勒让德多项式 $\\{\\phi_n(r)\\}_{n=0}^3$ 的模态基，通过 $x = x_j + \\tfrac{h}{2} r$ 映射到每个单元，并用精确求积来近似所有内积。\n\n从线性平流的 DG 弱形式和迎风数值通量出发，推导针对无量纲波数 $\\kappa = k h \\in [0,\\pi]$ 的傅里叶模的半离散算子符号，即一个 $4 \\times 4$ 矩阵 $S(\\kappa)$，使得对于傅里叶模 $c_j(t) = v(t) \\mathrm{e}^{i \\kappa j}$，单元模态系数向量 $c_j \\in \\mathbb{C}^4$ 满足 $c_j'(t) = S(\\kappa) c_j(t)$。从 $S(\\kappa)$ 定义：\n- 修正波数 $k^\\star(\\kappa)$，由 $k^\\star(\\kappa) = -\\mathrm{Im}(\\lambda^\\text{phys}(\\kappa))/a$ 定义，其中 $\\lambda^\\text{phys}(\\kappa)$ 是 $S(\\kappa)$ 的特征值，其虚部在小 $\\kappa$ 时与 $-a k$ 最接近（物理分支）。\n- 耗散率 $\\mathcal{D}(\\kappa)$，由 $\\mathcal{D}(\\kappa) = \\mathrm{Re}(\\lambda^\\text{phys}(\\kappa))/a$ 定义。\n- 色散误差 $\\mathcal{E}(\\kappa)$，由 $\\mathcal{E}(\\kappa) = k^\\star(\\kappa) - k$ 定义，其中 $k = \\kappa/h$。\n\n对于采用3阶强保稳龙格库塔 (SSP-RK3) 的全离散格式，通过 $G(\\kappa,\\nu) = R\\!\\left(\\Delta t\\, S(\\kappa)\\right)$ 定义放大矩阵 $G(\\kappa,\\nu)$，其中稳定多项式为 $R(z) = 1 + z + \\tfrac{1}{2} z^2 + \\tfrac{1}{6} z^3$，Courant–Friedrichs–Lewy (CFL) 数为 $\\nu = a \\Delta t/h$。在光滑区域，假设限制于 WENO 的 DG 和限制于 TVB 的 DG 都简化为相同的线性算子 $S(\\kappa)$；因此，它们的放大矩阵是相同的。\n\n你的任务是：\n1. 在参考单元上，使用 $\\phi_n(r) = P_n(r)$（即 $n$ 次勒让德多项式）推导矩阵 $M$ 和 $K$，其元素为\n   $$M_{mn} = \\int_{-1}^1 \\phi_m(r)\\,\\phi_n(r)\\, \\mathrm{d}r,\\quad K_{mn} = \\int_{-1}^1 \\phi'_m(r)\\,\\phi_n(r)\\, \\mathrm{d}r.$$\n   令 $\\Phi(\\pm 1)$ 表示在边界上基函数的求值向量，并定义\n   $$F_R = \\Phi(1)\\,\\Phi(1)^\\top,\\quad G = \\Phi(-1)\\,\\Phi(1)^\\top.$$\n   证明在线性平流、迎风通量的情况下，半离散 DG 算子可以写为\n   $$c_j'(t) = \\frac{2a}{h} M^{-1}\\Big[ K\\,c_j - F_R\\,c_j + G\\, c_{j-1}\\Big],$$\n   从而得到符号\n   $$S(\\kappa) = \\frac{2a}{h} M^{-1}\\Big[ K - F_R + \\mathrm{e}^{-i\\kappa} G \\Big].$$\n2. 使用符号 $S(\\kappa)$，通过选择虚部与 $-a k$（其中 $k=\\kappa/h$）最接近的特征值来计算 $\\lambda^\\text{phys}(\\kappa)$。\n3. 对选定的 $\\kappa$ 计算色散误差 $\\mathcal{E}(\\kappa)$ 和耗散率 $\\mathcal{D}(\\kappa)$。\n4. 对于 SSP-RK3 和 CFL 值 $\\nu$，在 $\\kappa \\in [0,\\pi]$ 的密集网格上计算 $G(\\kappa,\\nu)$ 的谱半径，并报告在 $\\kappa$ 上的最大谱半径。在光滑解线性化假设下，比较限制于 WENO 的 DG 和限制于 TVB 的 DG 的结果。\n\n使用 $a=1$ 和 $h=1$。$\\kappa$ 的角度是无量纲的，单位为弧度。无需报告物理单位。\n\n测试套件：\n- 波数 $\\kappa \\in \\{0.0,\\ 0.5,\\ 2.5,\\ \\pi\\}$。\n- CFL 值 $\\nu \\in \\{0.05,\\ 0.10,\\ 0.20,\\ 0.30\\}$。\n- 对于全离散谱半径，在 $[0,\\pi]$ 内至少有 $200$ 个点的均匀网格上评估其最大值。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  1. 对于上述顺序中的每个测试 $\\kappa$，依次为色散误差 $\\mathcal{E}(\\kappa)$ 和耗散率 $\\mathcal{D}(\\kappa)$（浮点数）。\n  2. 对于上述顺序中的每个 CFL 值 $\\nu$，在 $\\kappa \\in [0,\\pi]$ 上的最大谱半径 $\\rho_{\\max}(G(\\kappa,\\nu))$（浮点数）。\n  3. 对于每个 CFL 值 $\\nu$，一个布尔值，指示在 $10^{-12}$ 的绝对容差内，限制于 WENO 的 DG 的最大谱半径是否等于限制于 TVB 的 DG 的最大谱半径（布尔值）。\n\n例如，输出应如下所示\n$$[\\mathcal{E}(0.0),\\ \\mathcal{D}(0.0),\\ \\mathcal{E}(0.5),\\ \\mathcal{D}(0.5),\\ \\ldots,\\ \\rho_{\\max}(\\nu=0.05),\\ \\rho_{\\max}(\\nu=0.10),\\ \\rho_{\\max}(\\nu=0.20),\\ \\rho_{\\max}(\\nu=0.30),\\ \\text{flag}_{0.05},\\ \\text{flag}_{0.10},\\ \\text{flag}_{0.20},\\ \\text{flag}_{0.30}].$$\n\n程序必须完全自包含，无需任何输入即可生成这些值。所有计算出的答案必须是数值（浮点数或布尔值），并完全按照指定方式聚合到单行打印的列表中。", "solution": "用户提供的问题经评估在科学上是合理的、适定的、客观且完整的。所有给出的定义、方程和任务在偏微分方程数值分析领域，特别是间断伽辽金 (DG) 方法的研究中，都是标准的。因此，该问题被视为**有效**，下面提供了完整的解答。\n\n### 任务 1：半离散算子及其符号的推导\n\n我们从一维线性平流方程 $u_t + a u_x = 0$ 开始。间断伽辽金弱形式是通过将偏微分方程乘以一个检验函数 $\\phi_m$（取自基函数集）并在一个单元 $I_j = [x_{j-1/2}, x_{j+1/2}]$ 上积分得到的。\n\n$$\n\\int_{I_j} \\frac{\\partial u_h}{\\partial t} \\phi_m \\,dx + \\int_{I_j} a \\frac{\\partial u_h}{\\partial x} \\phi_m \\,dx = 0\n$$\n\n这里，$u_h(x,t)$ 是近似解，在每个单元内是一个 $p=3$ 次多项式。在单元 $I_j$上，解通过映射 $x(r) = x_j + \\frac{h}{2}r$ 在参考单元 $r \\in [-1,1]$ 上的勒让德多项式模态基 $\\{\\phi_n(r)\\}_{n=0}^3$ 中展开：\n\n$$\nu_h(x(r), t) = \\sum_{n=0}^{p} c_{jn}(t) \\phi_n(r)\n$$\n\n对弱形式中的空间项使用分部积分法，得到：\n\n$$\n\\int_{I_j} \\frac{\\partial u_h}{\\partial t} \\phi_m \\,dx - a \\int_{I_j} u_h \\frac{\\partial \\phi_m}{\\partial x} \\,dx + [a \\, u_h \\phi_m]_{x_{j-1/2}}^{x_{j+1/2}} = 0\n$$\n\n边界项 $[a \\, u_h \\phi_m]_{x_{j-1/2}}^{x_{j+1/2}}$ 被数值通量所替代。对于波速 $a>0$ 的迎风通量，界面处的通量由迎风（左侧）单元的值确定。设 $\\hat{u}(x_{j+1/2})$ 为单元 $I_j$ 右边界上的数值通量值。\n$\\hat{u}(x_{j+1/2}) = u_h(x_{j+1/2}^-)$，即来自单元 $I_j$ 内部的值。\n$\\hat{u}(x_{j-1/2}) = u_h(x_{j-1/2}^-)$，即来自单元 $I_{j-1}$ 的值。\n通量项变为：\n\n$$\na \\, \\hat{u}(x_{j+1/2}) \\phi_m(x_{j+1/2}) - a \\, \\hat{u}(x_{j-1/2}) \\phi_m(x_{j-1/2}) = a \\, u_h(x_{j+1/2}^-) \\phi_m(x_{j+1/2}) - a \\, u_h(x_{j-1/2}^-) \\phi_m(x_{j-1/2})\n$$\n\n使用 $dx = \\frac{h}{2}dr$ 和 $\\frac{\\partial}{\\partial x} = \\frac{2}{h}\\frac{\\partial}{\\partial r}$ 变换到参考单元 $r \\in [-1,1]$：\n\n$$\n\\frac{h}{2} \\int_{-1}^1 \\left(\\sum_n \\frac{dc_{jn}}{dt} \\phi_n\\right) \\phi_m \\,dr - a \\int_{-1}^1 \\left(\\sum_n c_{jn} \\phi_n\\right) \\left(\\frac{2}{h}\\phi'_m\\right) \\frac{h}{2} \\,dr + a \\left(\\sum_n c_{jn} \\phi_n(1)\\right)\\phi_m(1) - a \\left(\\sum_n c_{j-1,n} \\phi_n(1)\\right)\\phi_m(-1) = 0\n$$\n\n该方程对每个基函数 $\\phi_m$ ($m=0, \\dots, p$) 都成立。以矩阵形式表示，其中 $c_j = [c_{j0}, \\dots, c_{jp}]^T$：\n\n$$\n\\frac{h}{2} M c'_j(t) = a K c_j(t) - a \\left(\\Phi(1)\\Phi(1)^T\\right) c_j(t) + a \\left(\\Phi(-1)\\Phi(1)^T\\right) c_{j-1}(t)\n$$\n\n其中矩阵 $M$、$K$ 和向量 $\\Phi(r)$ 在参考单元上定义：\n$M_{mn} = \\int_{-1}^1 \\phi_m(r) \\phi_n(r) dr$，$K_{mn} = \\int_{-1}^1 \\phi'_m(r) \\phi_n(r) dr$，以及 $\\Phi(r) = [\\phi_0(r), \\dots, \\phi_p(r)]^T$。\n整理后得到问题中所述的半离散形式：\n\n$$\nc'_j(t) = \\frac{2a}{h} M^{-1} \\left[ K c_j(t) - (\\Phi(1)\\Phi(1)^T) c_j(t) + (\\Phi(-1)\\Phi(1)^T) c_{j-1}(t) \\right]\n$$\n\n对于单个傅里叶模 $c_j(t) = v(t) e^{i\\kappa j}$，我们有 $c_{j-1}(t) = v(t) e^{i\\kappa(j-1)} = e^{-i\\kappa} c_j(t)$。将其代入半离散形式，并注意到根据定义有 $c'_j(t) = S(\\kappa) c_j(t)$，我们得到符号 $S(\\kappa)$：\n\n$$\nS(\\kappa) = \\frac{2a}{h} M^{-1} \\left[ K - \\Phi(1)\\Phi(1)^T + e^{-i\\kappa} \\Phi(-1)\\Phi(1)^T \\right] = \\frac{2a}{h} M^{-1} \\left[ K - F_R + e^{-i\\kappa} G \\right]\n$$\n这验证了问题中给出的表达式。\n\n对于 $p=3$，基函数为勒让德多项式 $\\phi_n(r) = P_n(r)$：\n$\\phi_0(r) = 1$, $\\phi_1(r) = r$, $\\phi_2(r) = \\frac{1}{2}(3r^2 - 1)$, $\\phi_3(r) = \\frac{1}{2}(5r^3 - 3r)$。\n所需的矩阵计算如下：\n- 质量矩阵 $M$：利用正交性 $\\int_{-1}^1 P_m(r)P_n(r) dr = \\frac{2}{2n+1}\\delta_{mn}$，$M$ 是对角矩阵：\n  $$M = \\text{diag}\\left(2, \\frac{2}{3}, \\frac{2}{5}, \\frac{2}{7}\\right)$$\n- 刚度矩阵 $K$：其元素为 $K_{mn} = \\int_{-1}^1 \\phi'_m(r)\\phi_n(r) dr$。利用当 $n  m$ 且 $m-n$ 为奇数时该积分为 $2$，否则为 $0$ 的性质：\n  $$K = \\begin{pmatrix} 0  0  0  0 \\\\ 2  0  0  0 \\\\ 0  2  0  0 \\\\ 2  0  2  0 \\end{pmatrix}$$\n- 边界求值向量 $\\Phi(\\pm 1)$：利用 $P_n(1)=1$ 和 $P_n(-1)=(-1)^n$：\n  $\\Phi(1) = [1, 1, 1, 1]^T$ 和 $\\Phi(-1) = [1, -1, 1, -1]^T$。\n- 边界矩阵 $F_R$ 和 $G$：\n  $F_R = \\Phi(1)\\Phi(1)^T = \\begin{pmatrix} 1  1  1  1 \\\\ 1  1  1  1 \\\\ 1  1  1  1 \\\\ 1  1  1  1 \\end{pmatrix}$，以及 $G = \\Phi(-1)\\Phi(1)^T = \\begin{pmatrix} 1  1  1  1 \\\\ -1  -1  -1  -1 \\\\ 1  1  1  1 \\\\ -1  -1  -1  -1 \\end{pmatrix}$。\n\n### 任务 2 和 3：物理特征值、色散和耗散\n\n定义了矩阵并给定常数 $a=1, h=1$ 后，对于每个无量纲波数 $\\kappa$，符号 $S(\\kappa)$ 是一个 $4\\times 4$ 的复数矩阵。我们计算其四个特征值 $\\{\\lambda_j(\\kappa)\\}_{j=0}^3$。偏微分方程的解析解具有随 $e^{-iak t} = e^{-i\\kappa t}$ 演化的模态。物理特征值分支 $\\lambda^{\\text{phys}}(\\kappa)$ 是其虚部与此行为最接近的那个。我们选择使 $|\\text{Im}(\\lambda_j(\\kappa)) - (-a\\kappa/h)| = |\\text{Im}(\\lambda_j(\\kappa)) + \\kappa|$ 最小化的特征值。\n\n从 $\\lambda^{\\text{phys}}(\\kappa)$ 可以计算出以下量：\n- **修正波数：** $k^\\star(\\kappa) = -\\mathrm{Im}(\\lambda^\\text{phys}(\\kappa))/a$。这是数值格式的有效波数。\n- **耗散率：** $\\mathcal{D}(\\kappa) = \\mathrm{Re}(\\lambda^\\text{phys}(\\kappa))/a$。负值表示数值耗散（振幅衰减），而正值表示振幅增长（不稳定性）。\n- **色散误差：** $\\mathcal{E}(\\kappa) = k^\\star(\\kappa) - k = k^\\star(\\kappa) - \\kappa/h$。这衡量了格式的相位误差。\n\n对于 $\\kappa=0$，解在空间上是常数，应被精确传播。我们期望 $\\lambda^{\\text{phys}}(0)=0$，从而得到 $\\mathcal{D}(0)=0$ 和 $\\mathcal{E}(0)=0$。对于其他 $\\kappa$，预计会出现非零误差。\n\n### 任务 4：全离散分析与限制器比较\n\n该格式使用三阶段强保稳龙格库塔方法 (SSP-RK3) 进行时间推进。一个傅里叶模在一个时间步长 $\\Delta t$ 内的演化由 $c_j(t+\\Delta t) = G(\\kappa, \\nu) c_j(t)$ 给出，其中 $G(\\kappa, \\nu)$ 是放大矩阵。它是通过将 SSP-RK3 稳定多项式 $R(z)=1+z+\\frac{1}{2}z^2+\\frac{1}{6}z^3$ 应用于矩阵 $Z = \\Delta t S(\\kappa)$ 来定义的：\n\n$$ G(\\kappa, \\nu) = R(\\Delta t S(\\kappa)) = I + \\Delta t S(\\kappa) + \\frac{(\\Delta t S(\\kappa))^2}{2} + \\frac{(\\Delta t S(\\kappa))^3}{6} $$\n\n这里，$\\nu = a\\Delta t/h$ 是 CFL 数。为了保证稳定性，$G$ 的谱半径 $\\rho(G) = \\max_j|\\lambda_j(G)|$ 必须小于或等于 $1$。我们为每个给定的 CFL 数 $\\nu$ 计算在波数 $\\kappa \\in [0, \\pi]$ 的密集网格上的最大谱半径。\n\n问题要求比较限制于 WENO 的 DG 和限制于 TVB 的 DG 的结果。关键在于，它假设在解的光滑区域，限制器不被激活，两种格式都简化为相同的底层线性 DG 算子。因此，它们的半离散符号 $S(\\kappa)$ 相同，它们的放大矩阵 $G(\\kappa, \\nu)$ 相同，并且它们的最大谱半径也相同。因此，在问题的假设下，比较是平凡的，相等标志将为 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DG-p=3 linear advection analysis problem.\n    \"\"\"\n    # Problem parameters\n    p = 3\n    a = 1.0\n    h = 1.0\n\n    # Test cases from the problem statement\n    kappas_test = [0.0, 0.5, 2.5, np.pi]\n    nus_test = [0.05, 0.10, 0.20, 0.30]\n    kappa_grid_points = 201\n\n    # --- Part 1: Construct matrices for p=3 DG ---\n    \n    # Inverse of the mass matrix M\n    # M_mn = integral(P_m * P_n) = 2/(2n+1) * delta_mn\n    # M_inv_nn = (2n+1)/2\n    M_inv = np.diag([(2 * n + 1) / 2.0 for n in range(p + 1)])\n\n    # Stiffness matrix K\n    # K_mn = integral(P'_m * P_n)\n    # This is 2 if n  m and m-n is odd, 0 otherwise.\n    K = np.zeros((p + 1, p + 1))\n    for m in range(p + 1):\n        for n in range(m):\n            if (m - n) % 2 != 0:\n                K[m, n] = 2.0\n\n    # Face evaluation vectors and matrices\n    # Phi(1) = [1, 1, 1, 1]^T\n    # Phi(-1) = [1, -1, 1, -1]^T\n    phi_1 = np.ones(p + 1)\n    phi_m1 = np.array([(-1)**n for n in range(p + 1)])\n    \n    FR = np.outer(phi_1, phi_1)\n    G_face = np.outer(phi_m1, phi_1)\n\n    results = []\n\n    # --- Part 2  3: Dispersion and Dissipation Analysis ---\n    for kappa in kappas_test:\n        # Construct the symbol matrix S(kappa)\n        # S(k) = (2a/h) * M^-1 * [K - FR + exp(-i*k) * G]\n        A_kappa = K - FR + np.exp(-1j * kappa) * G_face\n        S_kappa = (2 * a / h) * M_inv @ A_kappa\n\n        # Find the physical eigenvalue\n        eigvals = np.linalg.eigvals(S_kappa)\n        target_imag = -a * kappa / h\n        phys_eig_idx = np.argmin(np.abs(np.imag(eigvals) - target_imag))\n        lambda_phys = eigvals[phys_eig_idx]\n\n        # Calculate dispersion and dissipation\n        # Dissipation rate D(k) = Re(lambda_phys)/a\n        dissipation_rate = np.real(lambda_phys) / a\n        \n        # Modified wavenumber k*(k) = -Im(lambda_phys)/a\n        k_star = -np.imag(lambda_phys) / a\n\n        # Dispersion error E(k) = k* - k\n        k = kappa / h\n        dispersion_error = k_star - k\n\n        results.extend([dispersion_error, dissipation_rate])\n\n    # --- Part 4: Fully discrete spectral radius analysis (SSP-RK3) ---\n    rho_max_results = []\n    kappa_grid = np.linspace(0, np.pi, kappa_grid_points)\n    I = np.identity(p + 1)\n\n    for nu in nus_test:\n        max_rho = 0.0\n        delta_t = nu * h / a\n\n        for kappa in kappa_grid:\n            # Construct S(kappa)\n            A_kappa = K - FR + np.exp(-1j * kappa) * G_face\n            S_kappa = (2 * a / h) * M_inv @ A_kappa\n\n            # Construct amplification matrix G(kappa, nu)\n            # G = R(delta_t * S) with R(z) = 1 + z + z^2/2 + z^3/6\n            Z = delta_t * S_kappa\n            Z2 = Z @ Z\n            Z3 = Z2 @ Z\n            G_amp = I + Z + 0.5 * Z2 + (1/6.0) * Z3\n            \n            # Spectral radius\n            rho = np.max(np.abs(np.linalg.eigvals(G_amp)))\n            if rho > max_rho:\n                max_rho = rho\n        \n        rho_max_results.append(max_rho)\n\n    results.extend(rho_max_results)\n\n    # --- Part 5: WENO vs TVB comparison ---\n    flag_results = []\n    for _ in nus_test:\n        # Per problem statement, in smooth regions, the limited schemes\n        # reduce to the same linear operator. Thus, their spectral\n        # radii are identical. The difference is 0, which is  1e-12.\n        flag_results.append(True)\n    \n    results.extend(flag_results)\n    \n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{x:.12f}' if isinstance(x, float) else str(x).lower() for x in results)}]\")\n\nsolve()\n```", "id": "3429573"}, {"introduction": "从线性分析过渡到非线性机制，WENO方法的核心在于其依赖光滑度指示因子的非线性权值。本练习旨在探讨一个关键的实现细节：当使用数值积分计算这些光滑度指示因子时所引入的数值误差。我们将量化这些微小的积分误差如何被非线性权值公式放大，从而影响整体格式的精度。[@problem_id:3429520]", "problem": "考虑在参考单元 $I=[-1,1]$ 上的一个一维非连续伽辽金(DG)表示，其多项式次数为 $p\\in\\mathbb{N}$。令 $\\{L_k(x)\\}_{k=0}^p$ 表示 $[-1,1]$ 上的勒让德多项式，其归一化满足 $\\int_{-1}^{1} L_m(x)L_n(x)\\,dx=\\frac{2}{2n+1}\\delta_{mn}$。对于给定的光滑函数 $u(x)$，将其在次数 $\\le p$ 的多项式空间上的 $L^2$ 投影定义为 $u_p(x)=\\sum_{k=0}^p a_k L_k(x)$，其中模态系数 $a_k$ 由 $a_k=\\frac{2k+1}{2}\\int_{-1}^1 u(x)L_k(x)\\,dx$ 确定。\n\n定义一个单参数WENO型模态限制器，该限制器保持平均模态不变，并用一个非线性权重统一缩放所有更高阶的模态。具体来说，令光滑度指示器为 $\\beta=\\int_{-1}^{1} \\left(u_p'(x)\\right)^2\\,dx$。该限制器通过 $\\tilde{a}_0=a_0$ 和对所有 $k\\in\\{1,\\dots,p\\}$ 的 $\\tilde{a}_k=\\omega\\,a_k$ 构造一个受限模态向量 $\\tilde{a}=(\\tilde{a}_0,\\tilde{a}_1,\\dots,\\tilde{a}_p)$，其中非线性权重 $\\omega\\in(0,1)$ 由双候选的 Jiang–Shu 形式定义\n$$\n\\alpha_{\\text{keep}}=\\frac{d_{\\text{keep}}}{(\\epsilon+\\beta)^r},\\qquad\n\\alpha_{\\text{zero}}=d_{\\text{zero}},\\qquad\n\\omega=\\frac{\\alpha_{\\text{keep}}}{\\alpha_{\\text{keep}}+\\alpha_{\\text{zero}}}.\n$$\n此处，$d_{\\text{keep}}\\in(0,1)$ 和 $d_{\\text{zero}}\\in(0,1)$ 是满足 $d_{\\text{keep}}+d_{\\text{zero}}=1$ 的固定线性权重，$\\epsilon0$ 是一个防止除以零的小参数，而 $r\\ge 1$ 是一个正整数。在实践中，光滑度指示器积分通过具有 $q$ 个点的高斯-勒让德求积进行近似，\n$$\n\\beta_q=\\sum_{i=1}^{q} w_i\\left(u_p'(x_i)\\right)^2,\n$$\n其中 $\\{(x_i,w_i)\\}_{i=1}^q$ 是 $[-1,1]$ 上的高斯-勒让德节点和权重。相应的权重记作 $\\omega_q$，相应的受限系数记作 $\\tilde{a}^{(q)}$。定义一个高精度基准 $\\beta_\\star$，它通过具有 $q_\\star$ 个点的高斯-勒让德求积计算得出，其中 $q_\\star$ 足够大（取 $q_\\star=200$），并具有关联的 $\\omega_\\star$ 和 $\\tilde{a}^{(\\star)}$。\n\n您的目标是：\n- 仅从 $L^2$ 投影、勒让德正交性和高斯-勒让德求积的定义出发，量化因使用 $\\beta_q$ 代替 $\\beta_\\star$ 而在将非线性WENO权重应用于模态系数时引入的混叠误差。使用系数空间欧几里得误差\n$$\n\\mathcal{E}(p,q,\\epsilon,r,u)=\\left\\|\\tilde{a}^{(q)}-\\tilde{a}^{(\\star)}\\right\\|_2.\n$$\n- 提出并实现一个使用 $q\\ge 2p$ 个高斯-勒让德点的求积法则，以在存在非线性模态限制的情况下保持DG的设计阶，并与更小和更大的 $q$ 值进行数值比较。\n- 测试 $\\mathcal{E}$ 对非线性权重中参数 $\\epsilon$ 的敏感性。\n\n使用以下基本理论基础：\n- 在 $L^2([-1,1])$ 上到多项式子空间的正交投影。\n- $[-1,1]$ 上勒让德多项式的正交性和完备性。\n- 阶数为 $q$ 的高斯-勒让德求积对于次数 $\\le 2q-1$ 的被积函数的多项式精确性。\n\n算法要求：\n- 使用具有 $q_\\text{proj}$ 个点的高斯-勒让德求积，通过数值计算 $\\int_{-1}^{1} u(x)L_k(x)\\,dx$ 来计算模态系数 $a_k$，其中 $q_\\text{proj}$ 足够大，以至于对于所选的光滑函数 $u(x)$ 而言，计算结果实际上是精确的（取 $q_\\text{proj}=200$）。\n- 通过勒让德基操作构造 $u_p(x)=\\sum_{k=0}^p a_k L_k(x)$ 及其导数 $u_p'(x)$。\n- 计算给定 $q$ 的 $\\beta_q$ 和 $q_\\star=200$ 的 $\\beta_\\star$；然后计算 $\\omega_q$ 和 $\\omega_\\star$ 以及相应的受限向量 $\\tilde{a}^{(q)}$ 和 $\\tilde{a}^{(\\star)}$。\n- 对每个测试，将 $\\mathcal{E}(p,q,\\epsilon,r,u)$ 报告为一个浮点数。\n\n用于 $u(x)$ 的函数：\n- $u_1(x)=\\sin(\\pi x)$.\n- $u_2(x)=\\exp(x)$.\n\n对所有测试，固定 $d_{\\text{keep}}=0.99$，$d_{\\text{zero}}=0.01$ 和 $r=2$。\n\n测试组：\n- 情况1：$p=3$, $q=6$, $\\epsilon=10^{-6}$, $u=u_1$。\n- 情况2：$p=3$, $q=3$, $\\epsilon=10^{-6}$, $u=u_1$。\n- 情况3：$p=3$, $q=9$, $\\epsilon=10^{-6}$, $u=u_1$。\n- 情况4：$p=4$, $q=8$, $\\epsilon=10^{-12}$, $u=u_2$。\n- 情况5：$p=4$, $q=8$, $\\epsilon=10^{-3}$, $u=u_2$。\n- 情况6：$p=1$, $q=2$, $\\epsilon=10^{-6}$, $u=u_1$。\n\n角度单位不适用。不涉及物理单位。每个测试必须返回一个等于 $\\mathcal{E}(p,q,\\epsilon,r,u)$ 的单一实数。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试组相同，例如 $[\\mathcal{E}_1,\\mathcal{E}_2,\\dots,\\mathcal{E}_6]$。", "solution": "该问题要求分析一种用于非连续伽辽金(DG)方法的加权基本无振荡(WENO)型模态限制器中引入的数值误差。所研究的误差来源是，使用具有有限个点 $q$ 的数值求积来计算光滑度指示器 $\\beta$，而 $\\beta$ 进而决定了一个非线性限制权重 $\\omega$。误差通过用 $q$ 个点计算的受限模态系数向量 $\\tilde{a}^{(q)}$ 与用大量点 $q_\\star$ 计算的高精度基准向量 $\\tilde{a}^{(\\star)}$ 之差的欧几里得范数来衡量。\n\n求解过程分几步进行：\n1.  函数及其投影的表示。\n2.  光滑度指示器的构造及其数值评估。\n3.  光滑度指示器精确求积的条件分析。\n4.  受限模态系数和误差度量的计算。\n\n**1. L2投影与多项式表示**\n\n对于参考区间 $I = [-1, 1]$ 上的一个光滑函数 $u(x)$，其在次数至多为 $p$ 的多项式空间 $\\mathbb{P}_p$ 上的 $L^2$ 投影由下式给出\n$$\nu_p(x) = \\sum_{k=0}^{p} a_k L_k(x)\n$$\n其中 $\\{L_k(x)\\}_{k=0}^p$ 是勒让德多项式。通过利用勒让德多项式的正交性 $\\int_{-1}^{1} L_m(x)L_n(x)\\,dx=\\frac{2}{2n+1}\\delta_{mn}$ 来确定模态系数 $a_k$：\n$$\n\\int_{-1}^{1} u(x) L_k(x) \\,dx = \\sum_{j=0}^{p} a_j \\int_{-1}^{1} L_j(x) L_k(x) \\,dx = a_k \\frac{2}{2k+1}\n$$\n这给出了精确模态系数的公式：\n$$\na_k = \\frac{2k+1}{2} \\int_{-1}^{1} u(x) L_k(x) \\,dx\n$$\n在本问题中，该积分使用具有足够多点（$q_{\\text{proj}}=200$）的高斯-勒让德求积进行数值计算，以确保高精度。令求积节点和权重为 $\\{(x_j^{\\text{proj}}, w_j^{\\text{proj}})\\}_{j=1}^{q_{\\text{proj}}}$。计算出的系数为：\n$$\na_k \\approx \\hat{a}_k = \\frac{2k+1}{2} \\sum_{j=1}^{q_{\\text{proj}}} w_j^{\\text{proj}} u(x_j^{\\text{proj}}) L_k(x_j^{\\text{proj}})\n$$\n在本分析的其余部分，我们将使用多项式 $\\hat{u}_p(x) = \\sum_{k=0}^p \\hat{a}_k L_k(x)$，它是由这些数值计算出的系数构建的。\n\n**2. 光滑度指示器与数值求积**\n\nWENO限制器的行为由光滑度指示器 $\\beta$ 控制，其定义为多项式近似导数的 $L^2$ 范数的平方：\n$$\n\\beta = \\int_{-1}^{1} (\\hat{u}_p'(x))^2 \\,dx\n$$\n导数 $\\hat{u}_p'(x)$ 通过对多项式逐项求导形成：\n$$\n\\hat{u}_p'(x) = \\sum_{k=0}^{p} \\hat{a}_k L_k'(x) = \\sum_{k=1}^{p} \\hat{a}_k L_k'(x) \\quad (\\text{因为 } L_0'(x)=0)\n$$\n由于 $L_k'(x)$ 是一个 $k-1$ 次多项式，$\\hat{u}_p'(x)$ 是一个次数至多为 $p-1$ 的多项式。因此，被积函数 $(\\hat{u}_p'(x))^2$ 是一个次数至多为 $2(p-1)$ 的多项式。\n\n具有 $q$ 个点的高斯-勒让德求积对于次数高达 $2q-1$ 的任何多项式被积函数都是精确的。为了精确计算 $\\beta$（在浮点精度内），我们必须选择 $q$ 使得：\n$$\n2q - 1 \\ge 2(p-1) \\implies 2q \\ge 2p - 1 \\implies q \\ge p - \\frac{1}{2}\n$$\n由于 $q$ 必须是整数，任何 $q \\ge p$ 的选择都将导致对 $\\beta$ 的积分进行精确评估。\n\n问题要求将用 $q$ 个点计算的 $\\beta_q$ 与用 $q_\\star = 200$ 个点计算的基准 $\\beta_\\star$ 进行比较。鉴于所有测试用例中 $p \\ll 200$，基准 $\\beta_\\star$ 可被视为积分的精确值。对于任何 $q \\ge p$ 的测试用例，理论表明 $\\beta_q$ 也应该是精确的，因此 $\\beta_q = \\beta_\\star$。\n\n**3. 非线性限制与误差分析**\n\n受限模态系数 $\\tilde{a}_k$ 按如下方式计算：\n$$\n\\tilde{a}_0 = \\hat{a}_0, \\qquad \\tilde{a}_k = \\omega \\cdot \\hat{a}_k \\quad \\text{for } k \\in \\{1, \\dots, p\\}\n$$\n非线性权重 $\\omega$ 是 $\\beta$ 的函数：\n$$\n\\omega(\\beta) = \\frac{\\alpha_{\\text{keep}}}{\\alpha_{\\text{keep}}+\\alpha_{\\text{zero}}} = \\frac{d_{\\text{keep}}/(\\epsilon+\\beta)^r}{d_{\\text{keep}}/(\\epsilon+\\beta)^r + d_{\\text{zero}}}\n$$\n误差度量是系数向量 $\\tilde{a}^{(q)}$ (使用 $\\omega_q = \\omega(\\beta_q)$) 与基准向量 $\\tilde{a}^{(\\star)}$ (使用 $\\omega_\\star = \\omega(\\beta_\\star)$) 之间的欧几里得距离：\n$$\n\\mathcal{E} = \\left\\|\\tilde{a}^{(q)}-\\tilde{a}^{(\\star)}\\right\\|_2 = \\sqrt{\\sum_{k=0}^p (\\tilde{a}_k^{(q)} - \\tilde{a}_k^{(\\star)})^2}\n$$\n由于 $\\tilde{a}_0^{(q)} = \\tilde{a}_0^{(\\star)} = \\hat{a}_0$，求和从 $k=1$ 开始：\n$$\n\\mathcal{E}^2 = \\sum_{k=1}^p (\\omega_q \\hat{a}_k - \\omega_\\star \\hat{a}_k)^2 = (\\omega_q - \\omega_\\star)^2 \\sum_{k=1}^p \\hat{a}_k^2\n$$\n$$\n\\mathcal{E} = |\\omega_q - \\omega_\\star| \\sqrt{\\sum_{k=1}^p \\hat{a}_k^2}\n$$\n仅当 $\\omega_q \\ne \\omega_\\star$ 时，误差 $\\mathcal{E}$ 才非零，这意味着 $\\beta_q \\ne \\beta_\\star$。如前所述，对于 $q \\ge p$，$\\beta_q$ 和 $\\beta_\\star$ 都应该是同一积分的精确评估。然而，它们是使用不同的求积节点和权重集计算的，这导致了不同的浮点运算序列。由于舍入误差，计算值 $\\beta_q^{\\text{float}}$ 和 $\\beta_\\star^{\\text{float}}$ 可能会有微小差异。\n$$\n\\beta_q^{\\text{float}} - \\beta_\\star^{\\text{float}} \\approx O(\\epsilon_{\\text{machine}})\n$$\n这个微小的差异可能会被非线性函数 $\\omega(\\beta)$ 显著放大，特别是当其导数 $\\frac{d\\omega}{d\\beta}$ 很大时。该导数为：\n$$\n\\frac{d\\omega}{d\\beta} = \\frac{-r \\, d_{\\text{keep}} \\, d_{\\text{zero}}}{(\\epsilon+\\beta)^{r+1} \\left( d_{\\text{keep}}(\\epsilon+\\beta)^{-r} + d_{\\text{zero}} \\right)^2}\n$$\n当光滑度参数 $\\epsilon$ 非常小时，这个导数可能会变得非常大，特别是对于小的 $\\beta$。这解释了误差 $\\mathcal{E}$ 对 $\\epsilon$ 的敏感性。因此，该问题是对限制器公式的数值稳定性的研究，其中在精确算术中本应为零的误差，在有限精度算术中表现为非零误差，其大小取决于具体的求积法则($q$)和参数($\\epsilon$) 。\n\n问题描述中 $q \\ge 2p$ 的建议，虽然对于此特定指示器公式中的多项式精确性并非严格必要，但它代表了一个在DG方法中常用于非线性通量项的更保守的经验法则，以在更一般的情况下确保鲁棒性和控制混叠误差。测试组允许我们通过数值方式探索这种保守选择在此处是否能提供更好的数值稳定性。\n\n**4. 计算步骤**\n\n对于由 $(p, q, \\epsilon, u)$ 指定的每个测试用例：\n1.  设置固定参数：$r=2$, $d_\\text{keep}=0.99$, $d_\\text{zero}=0.01$, $q_\\text{proj}=200$, $q_\\star=200$。\n2.  通过使用 $q_\\text{proj}$ 个高斯-勒让德点对 $u(x)$ 进行数值投影，计算 $k=0, \\dots, p$ 的模态系数 $\\hat{a}_k$。\n3.  构造导数的多项式表示 $\\hat{u}_p'(x) = \\sum_{k=1}^p \\hat{a}_k L_k'(x)$。\n4.  使用 $q$ 个高斯-勒让德点积分 $(\\hat{u}_p'(x))^2$ 来计算光滑度指示器 $\\beta_q$。\n5.  使用 $q_\\star=200$ 个高斯-勒让德点积分 $(\\hat{u}_p'(x))^2$ 来计算参考光滑度指示器 $\\beta_\\star$。\n6.  使用提供的公式计算相应的非线性权重 $\\omega_q = \\omega(\\beta_q)$ 和 $\\omega_\\star = \\omega(\\beta_\\star)$。\n7.  构造受限系数向量 $\\tilde{a}^{(q)}$ 和 $\\tilde{a}^{(\\star)}$。\n8.  计算并报告误差 $\\mathcal{E} = \\|\\tilde{a}^{(q)} - \\tilde{a}^{(\\star)}\\|_2$。\n\n为每个测试用例实施此过程以生成最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef compute_error(p, q, epsilon, r, u_func, d_keep, d_zero):\n    \"\"\"\n    Computes the aliasing error for the WENO modal limiter.\n\n    Args:\n        p (int): Polynomial degree.\n        q (int): Number of quadrature points for the test indicator.\n        epsilon (float): Regularization parameter for the WENO weight.\n        r (int): Exponent for the WENO weight.\n        u_func (callable): The smooth function u(x).\n        d_keep (float): Linear weight for the 'keep' stencil.\n        d_zero (float): Linear weight for the 'zero' stencil.\n\n    Returns:\n        float: The coefficient-space Euclidean error E.\n    \"\"\"\n    q_proj = 200\n    q_star = 200\n\n    # 1. Compute modal coefficients a_k by numerical projection\n    x_proj, w_proj = np.polynomial.legendre.leggauss(q_proj)\n    u_vals_proj = u_func(x_proj)\n    a = np.zeros(p + 1)\n    for k in range(p + 1):\n        L_k_poly = legendre(k)\n        L_k_vals_proj = L_k_poly(x_proj)\n        integral = np.sum(w_proj * u_vals_proj * L_k_vals_proj)\n        a[k] = (2 * k + 1) / 2.0 * integral\n\n    # 2. Form the derivative polynomial u_p'(x)\n    # This creates a callable polynomial object for u_p'(x)\n    up_prime_poly = np.poly1d([0.0])\n    if p > 0:\n        for k in range(1, p + 1):\n            if np.abs(a[k]) > 1e-40: # Avoid adding zero polynomials\n                L_k_poly = legendre(k)\n                L_k_prime_poly = L_k_poly.deriv(1)\n                up_prime_poly += a[k] * L_k_prime_poly\n\n    # 3. Compute beta_q and beta_star\n    # Function to compute beta for a given number of quadrature points\n    def calculate_beta(num_points):\n        if num_points == 0:\n            return 0.0\n        x_quad, w_quad = np.polynomial.legendre.leggauss(num_points)\n        up_prime_vals = up_prime_poly(x_quad)\n        beta_val = np.sum(w_quad * up_prime_vals**2)\n        return beta_val\n\n    beta_q = calculate_beta(q)\n    beta_star = calculate_beta(q_star)\n\n    # 4. Compute omega weights\n    def calculate_omega(beta):\n        alpha_keep = d_keep / (epsilon + beta)**r\n        alpha_zero = d_zero\n        # Handle potential division by zero if both are zero.\n        if alpha_keep + alpha_zero == 0:\n            return 0.0\n        return alpha_keep / (alpha_keep + alpha_zero)\n\n    omega_q = calculate_omega(beta_q)\n    omega_star = calculate_omega(beta_star)\n    \n    # 5. Construct limited coefficient vectors\n    a_tilde_q = np.copy(a)\n    a_tilde_star = np.copy(a)\n    \n    a_tilde_q[1:] *= omega_q\n    a_tilde_star[1:] *= omega_star\n\n    # 6. Compute the Euclidean error\n    error = np.linalg.norm(a_tilde_q - a_tilde_star)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results.\n    \"\"\"\n    # Define functions for u(x)\n    u1 = lambda x: np.sin(np.pi * x)\n    u2 = lambda x: np.exp(x)\n\n    # Fixed parameters for all tests\n    d_keep = 0.99\n    d_zero = 0.01\n    r = 2\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (p, q, epsilon, u_func)\n        (3, 6, 1e-6, u1),   # Case 1\n        (3, 3, 1e-6, u1),   # Case 2\n        (3, 9, 1e-6, u1),   # Case 3\n        (4, 8, 1e-12, u2),  # Case 4\n        (4, 8, 1e-3, u2),   # Case 5\n        (1, 2, 1e-6, u1),   # Case 6\n    ]\n\n    results = []\n    for p, q, eps, u_f in test_cases:\n        error_val = compute_error(p, q, eps, r, u_f, d_keep, d_zero)\n        results.append(error_val)\n    \n    # Format the output exactly as required\n    print(f\"[{','.join(f'{res:.10e}' for res in results)}]\")\n\nsolve()\n```", "id": "3429520"}, {"introduction": "在结构化网格上，WENO重构的模板选择相对直接。本练习将挑战一个更高级的实际应用：如何在非结构化网格上实施WENO重构，这在真实世界的模拟中十分常见。我们将实现一个基于图论的算法，来自适应地选择重构模板，旨在平衡模板尺寸需求与避开梯度剧变或间断区域的目标。[@problem_id:3429522]", "problem": "您的任务是为非结构化网格上的间断伽辽金 (DG) 方法中的加权基本无振荡 (WENO) 重构设计和评估一种基于图距离的模板自适应策略。底层网格表示为一个无向图。对于每个网格单元，目标是通过在基于图距离的 $k$-环内选择邻居来构建 WENO 重构模板，并根据局部光滑度指示器调整模板，以模拟感知光滑度的模板应避免跨越间断的理念。您的程序必须实现该选择策略，量化计算复杂性，并在简化的图形处理单元 (GPU) 执行模型下估算并行可扩展性。\n\n基本基础：\n- 使用无向图 $G = (V, E)$ 的定义，其中 $V$ 是顶点（单元）的集合，$E$ 是无向边（邻接关系）的集合，图距离 $d(i,j)$ 是 $i$ 和 $j$ 之间最短路径的长度（以边数计算）。\n- 在使用 WENO 重构的 DG 方法中，每个单元的重构模板从其邻居中选择，以在间断附近实现无振荡行为。此选择由从标量场计算的局部光滑度指示器指导。\n- $k$-环邻居的计算依赖于广度优先搜索 (BFS) 层。限制在 $k$ 层的 BFS 会访问所有满足 $d(i,j) \\le k$ 的节点 $j$。\n\n定义和要求：\n- 对于每个具有图邻居 $\\mathcal{N}(i)$ 的单元 $i \\in V$，将 $k$-环邻域定义为 $\\{ j \\in V \\setminus \\{i\\} \\mid d(i,j) \\le k \\}$。\n- 给定一个标量场 $u: V \\to \\mathbb{R}$，定义 $i$ 和 $j$ 之间的边光滑度指示器为\n$$\nS(i,j) = \\frac{|u(j) - u(i)|}{|u(j)| + |u(i)| + \\varepsilon},\n$$\n其中 $\\varepsilon  0$ 是一个小的正则化常数。\n- 对于每个单元 $i$，自适应模板 $S_i$ 的构建方法是：将环半径 $r$ 从 $r = 1$ 增加到 $r = k_i$（其中 $k_i$ 是单元 $i$ 的最大环）。在每个环 $r$ 处，考虑所有已发现的满足 $d(i,j) \\le r$ 的候选者的并集，并接受其中满足 $S(i,j) \\le \\tau$ 的候选者，其中 $\\tau  0$ 是一个阈值。一旦 $|S_i| \\ge s_{\\min}$ 或 $r = k_i$，就停止增加 $r$。如果到最后 $|S_i|  s_{\\min}$，则通过添加最近的剩余候选者（按 $d(i,j)$ 递增排序；若距离相同则按较小的 $S(i,j)$ 排序）来填充 $S_i$，这些候选者来自 $d(i,j) \\le k_i$ 的范围内，忽略阈值，直到 $|S_i| = s_{\\min}$ 或没有更多候选者为止。\n- 必须对每个单元按递增的 $r$ 进行 BFS，以便如果模板在达到 $k_i$ 之前已达到大小 $s_{\\min}$，就可以提前停止，从而使计算工作量适应局部光滑度。\n- 复杂度度量：\n  - 计算所有单元在 BFS 过程中访问的单位边检查总数。每次算法在 BFS 队列中检查一个弹出节点的邻居时，计为一次边检查。\n  - 计算所有单元的光滑度指示器评估总数。每次为单元 $i$ 首次发现候选邻居 $j$ 并计算 $S(i,j)$ 时，此计数加一。\n- GPU 上的并行可扩展性模型：\n  - 假设每个单元一个线程，这些线程被分组为大小为 $w = 32$ 的线程束 (warp)。\n  - 设单元 $i$ 的成本为 $c_i = i \\text{ 的边检查次数} + i \\text{ 的指示器评估次数}$。\n  - 将单元划分为大小为 $w$ 的连续线程束，即索引 $0$ 到 $w-1$ 在线程束 $0$ 中， $w$ 到 $2w-1$ 在线程束 $1$ 中，依此类推。对于最后一个线程束，如果剩余的单元少于 $w$ 个，则它形成一个部分线程束。\n  - 一个线程束的时间是其包含的所有单元中最大的 $c_i$（模拟锁步执行和分歧）。\n  - 预测的并行时间是每个线程束时间的总和。基准串行时间是 $\\sum_i c_i$。\n  - 将预测的并行效率定义为\n  $$\n  \\eta = \\frac{\\sum_i c_i}{\\sum_{\\text{warps } \\omega} \\max_{i \\in \\omega} c_i},\n  $$\n  将预测的加速比定义为\n  $$\n  \\text{speedup} = \\frac{\\sum_i c_i}{\\sum_{\\text{warps } \\omega} \\max_{i \\in \\omega} c_i}。\n  $$\n  在此模型下，加速比等于效率，因为基准时间和并行时间由相同的成本度量进行归一化。\n\n您的程序必须：\n- 按照规定实现自适应模板选择。\n- 对于下面的每个测试用例，输出：\n  - 所有单元 $i$ 的最终模板大小 $|S_i|$ 的列表，按索引顺序排列。\n  - 边检查总数（一个整数）。\n  - 指示器评估总数（一个整数）。\n  - 预测的并行效率（一个浮点数）。\n  - 预测的加速比（一个浮点数）。\n- 最终程序输出必须是单行，包含所有提供的测试用例的结果，格式为逗号分隔的每个测试用例结果列表，每个测试用例结果按上述顺序格式化为列表。\n\n测试套件：\n- 测试用例 1（正常路径，度数近似均匀）：\n  - 具有 $N = 9$ 个顶点（索引 0 到 8）的图，表示一个具有 4-连通性的 $3 \\times 3$ 网格。邻接表（对于每个索引 $i$，列表包含 $i$ 的邻居）：\n    - $0 : [1, 3]$\n    - $1 : [0, 2, 4]$\n    - $2 : [1, 5]$\n    - $3 : [0, 4, 6]$\n    - $4 : [1, 3, 5, 7]$\n    - $5 : [2, 4, 8]$\n    - $6 : [3, 7]$\n    - $7 : [4, 6, 8]$\n    - $8 : [5, 7]$\n  - 场值 $u = [0, 1, 2, 1, 2, 3, 2, 3, 4]$。\n  - 对所有 $i$，环限制 $k_i = 2$。\n  - 阈值 $\\tau = 0.2$，目标模板大小 $s_{\\min} = 3$，以及 $\\varepsilon = 10^{-12}$。\n\n- 测试用例 2（边界情况，带中心辐射型结构和强光滑度剪枝）：\n  - 具有 $N = 11$ 个顶点的图：\n    - $0 : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$\n    - $1 : [0]$\n    - $2 : [0]$\n    - $3 : [0]$\n    - $4 : [0]$\n    - $5 : [0]$\n    - $6 : [0]$\n    - $7 : [0]$\n    - $8 : [0]$\n    - $9 : [0]$\n    - $10 : [0]$\n  - 场值 $u = [0, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10]$。\n  - 对所有 $i$，环限制 $k_i = 1$。\n  - 阈值 $\\tau = 0.05$，目标模板大小 $s_{\\min} = 4$，以及 $\\varepsilon = 10^{-12}$。\n\n- 测试用例 3（不规则度数，带局部间断）：\n  - 具有 $N = 12$ 个顶点的图：\n    - $0 : [1, 2]$\n    - $1 : [0, 3, 4]$\n    - $2 : [0, 4, 5]$\n    - $3 : [1, 6]$\n    - $4 : [1, 2, 7]$\n    - $5 : [2, 8]$\n    - $6 : [3, 7, 9]$\n    - $7 : [4, 6, 10]$\n    - $8 : [5, 10, 11]$\n    - $9 : [6, 10]$\n    - $10 : [7, 8, 9, 11]$\n    - $11 : [8, 10]$\n  - 场值 $u = [0.0, 0.1, 0.2, 0.15, 0.25, 0.3, 2.0, 2.1, 0.35, 2.05, 2.2, 0.4]$。\n  - 环限制 $k_i = [2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2]$。\n  - 阈值 $\\tau = 0.2$，目标模板大小 $s_{\\min} = 3$，以及 $\\varepsilon = 10^{-12}$。\n\n角度单位不适用。物理单位不适用。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含所有结果，格式为逗号分隔的每个测试用例结果列表，每个结果的格式为：\n  - $[\\text{stencil\\_sizes\\_list}, \\text{total\\_edge\\_examinations}, \\text{total\\_indicator\\_evaluations}, \\text{predicted\\_efficiency}, \\text{predicted\\_speedup}]$\n- 整个输出必须是单行，形式如下：\n  - $[[\\ldots], [\\ldots], [\\ldots]]$\n其中每个 $[\\ldots]$ 对应于按上述顺序指定的一个测试用例。", "solution": "该问题要求为非结构化网格上的间断伽辽金 (DG) 框架内的加权基本无振荡 (WENO) 重构设计并实现一种基于图距离的自适应模板选择策略。解决方案涉及开发一种为每个网格单元构建模板的算法，量化其计算复杂性，并在简化的 GPU 模型上估算其并行性能。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n\n1.  **图表示**：一个无向图 $G = (V, E)$，其中 $V$ 是网格单元（顶点）的集合，$E$ 表示邻接关系（边）。图距离 $d(i,j)$ 是单元 $i$ 和 $j$ 之间最短路径的边长。\n2.  **$k$-环邻域**：对于一个单元 $i$，其 $k$-环邻域为 $\\{ j \\in V \\setminus \\{i\\} \\mid d(i,j) \\le k \\}$。\n3.  **标量场**：在单元上定义了一个标量场 $u: V \\to \\mathbb{R}$。\n4.  **光滑度指示器**：单元 $i$ 和 $j$ 之间的边光滑度指示器由下式给出\n    $$\n    S(i,j) = \\frac{|u(j) - u(i)|}{|u(j)| + |u(i)| + \\varepsilon}\n    $$\n    其中 $\\varepsilon > 0$ 是一个小的正则化常数。\n5.  **自适应模板构建**：对于每个单元 $i$，通过将环半径 $r$ 从 $1$ 迭代到指定的上限 $k_i$ 来构建模板 $S_i$。在每个半径 $r$ 处，考虑满足 $d(i,j) \\le r$ 的候选邻居 $j$。如果候选者 $j$ 的光滑度指示器 $S(i,j)$ 小于或等于阈值 $\\tau > 0$，则将其添加到 $S_i$ 中。一旦模板大小 $|S_i|$ 达到或超过目标最小尺寸 $s_{\\min}$，或当 $r$ 达到 $k_i$ 时，停止增加 $r$ 的过程。\n6.  **回退机制**：如果在检查了所有达到 $k_i$ 的环后，模板大小 $|S_i|$ 仍然小于 $s_{\\min}$，则通过添加最近的剩余候选者（即因光滑度检查而被拒绝的候选者）来填充模板，直到 $|S_i| = s_{\\min}$ 或 $k_i$-环内的所有候选者都已用尽。距离相同的情况下，通过较小的 $S(i,j)$ 值来打破平局。\n7.  **复杂度度量**：\n    *   **边检查总数**：在所有单元的广度优先搜索 (BFS) 遍历过程中，邻居检查的总次数。\n    *   **指示器评估总数**：在所有单元中，为新发现的候选邻居计算 $S(i,j)$ 的总次数。\n8.  **并行性能模型**：\n    *   每个单元一个线程，线程被分组为大小为 $w=32$ 的线程束 (warp)。\n    *   单元 $i$ 的成本：$c_i = (\\text{单元 } i \\text{ 的边检查次数}) + (\\text{单元 } i \\text{ 的指示器评估次数})$。\n    *   线程束时间：对于一个线程束 $\\omega$，其时间为 $\\max_{i \\in \\omega} c_i$。\n    *   总并行时间：$T_{\\text{parallel}} = \\sum_{\\text{warps } \\omega} \\max_{i \\in \\omega} c_i$。\n    *   总串行时间：$T_{\\text{serial}} = \\sum_{i \\in V} c_i$。\n    *   预测的并行效率和加速比：\n    $$\n    \\eta = \\text{speedup} = \\frac{\\sum_i c_i}{\\sum_{\\omega} \\max_{i \\in \\omega} c_i}\n    $$\n9.  **测试用例**：提供了三个具体的测试用例，每个都包含图结构（邻接表）、标量场 $u$、逐单元的环限制 $k_i$ 以及全局参数 $\\tau$、 $s_{\\min}$ 和 $\\varepsilon$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n\n*   **科学依据**：该问题植根于偏微分方程数值方法领域，特别是 WENO-DG 方法。模板、光滑度指示器和基于图的邻域选择等概念都是标准且科学合理的。GPU 性能模型虽然简化，但抓住了线程束分歧这一并行性能的关键因素。\n*   **适定性**：模板构建算法的描述是确定性的。环半径的迭代增加、接受候选者的条件、停止准则以及回退机制都被明确规定，确保可以为每个单元构建唯一的模板。回退机制的平局打破规则进一步确保了唯一性。\n*   **客观性**：问题使用精确的数学定义和客观标准进行陈述。所有术语都得到了正式定义。\n\n该问题未表现出任何无效性标志。它具有科学合理性、可形式化、完整性、可行性、适定性和非平凡性。\n\n**步骤 3：结论与行动**\n\n问题被判定为**有效**。将制定并实施解决方案。\n\n### **算法设计与解决方案**\n\n任务的核心是为每个单元 $i \\in V$ 实现自适应模板选择算法。“一旦 $|S_i| \\ge s_{\\min}$ 就停止增加 $r$”这一要求表明，需要一种分层探索图的算法，而不是执行完整的 BFS 来预计算所有距离。分层 BFS 方法是满足此条件的最有效方式。\n\n对于每个单元 $i \\in V$，执行以下过程：\n\n1.  **初始化**：\n    *   为模板初始化一个空集，$S_i = \\emptyset$。\n    *   初始化一个空列表 `rejected_candidates`，用于存储未通过光滑度测试的邻居 $j$ 的元组 $(d, S, j)$。\n    *   为此单元的成本初始化计数器：`edge_examinations_i = 0` 和 `indicator_evaluations_i = 0`。\n    *   从单元 $i$ 开始初始化一个分层 BFS。设 `current_layer_nodes` 是一个仅包含 $i$ 的列表，`visited_bfs` 是一个仅包含 $i$ 的集合。设置初始距离 `dist = 0`。\n\n2.  **分层 BFS 和模板构建**：\n    *   进入一个循环，只要当前距离 `dist` 小于单元 $i$ 的最大环限制 $k_i$，该循环就继续。如果模板大小 $|S_i|$ 达到或超过目标最小尺寸 $s_{\\min}$，则循环提前终止。\n    *   在循环内部，增加距离：`dist` $\\leftarrow$ `dist` $+ 1$。\n    *   为下一层识别所有新邻居。遍历 `current_layer_nodes` 中的每个节点 $u$。对于图中邻接表中 $u$ 的每个邻居 $v$：\n        *   增加 `edge_examinations_i`。\n        *   如果 $v$ 尚未被访问（即 $v \\notin \\text{visited\\_bfs}$），则将其标记为已访问，并将其添加到 `next_layer_nodes` 列表和一个 `candidates_at_this_dist` 集合中。\n    *   处理新发现的候选者。对于 `candidates_at_this_dist` 中的每个唯一候选者 $j$（为确保确定性，按节点索引排序）：\n        *   增加 `indicator_evaluations_i`。\n        *   使用给定的标量场 $u$ 和正则化 $\\varepsilon$ 计算光滑度指示器 $S(i, j)$。\n        *   如果 $S(i, j) \\le \\tau$，将 $j$ 添加到模板 $S_i$ 中。\n        *   否则，将元组 $(dist, S(i,j), j)$ 添加到 `rejected_candidates` 列表中。\n    *   为下一次迭代将 `current_layer_nodes` 更新为 `next_layer_nodes`。如果 `next_layer_nodes` 为空，则无法到达更远的单元，因此可以终止循环。\n\n3.  **回退机制**：\n    *   循环终止后，检查 $|S_i|  s_{\\min}$ 是否成立。\n    *   如果模板太小，则对 `rejected_candidates` 列表进行排序。主排序键是距离 `dist`，次排序键是光滑度值 $S$。\n    *   遍历已排序的 `rejected_candidates`，并将其对应的节点添加到 $S_i$ 中，直到 $|S_i| = s_{\\min}$ 或被拒绝的候选者列表已用尽。\n\n4.  **复杂度和性能指标聚合**：\n    *   处理完所有单元 $i \\in V$ 后，收集最终的模板大小 $|S_i|$。\n    *   通过对单个计数求和来计算总边检查次数和总指示器评估次数：$\\sum_i \\text{edge\\_examinations}_i$ 和 $\\sum_i \\text{indicator\\_evaluations}_i$。\n    *   为每个 $i$ 计算单位成本 $c_i = \\text{edge\\_examinations}_i + \\text{indicator\\_evaluations}_i$。\n    *   预测的串行时间为 $T_{\\text{serial}} = \\sum_i c_i$。\n    *   将单元划分为大小为 $w=32$ 的线程束。每个线程束 $\\omega$ 的时间为 $T_{\\omega} = \\max_{i \\in \\omega} c_i$。\n    *   预测的并行时间为 $T_{\\text{parallel}} = \\sum_{\\omega} T_{\\omega}$。\n    *   并行效率和加速比计算为 $\\eta = \\text{speedup} = T_{\\text{serial}} / T_{\\text{parallel}}$。\n\n这个详细的、基于原则的算法正确地实现了问题陈述的所有要求，包括模板搜索的自适应性质以及指定的复杂度和性能模型。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"N\": 9,\n            \"adj\": {\n                0: [1, 3], 1: [0, 2, 4], 2: [1, 5], 3: [0, 4, 6],\n                4: [1, 3, 5, 7], 5: [2, 4, 8], 6: [3, 7], 7: [4, 6, 8], 8: [5, 7]\n            },\n            \"u\": np.array([0, 1, 2, 1, 2, 3, 2, 3, 4], dtype=float),\n            \"k\": np.full(9, 2),\n            \"tau\": 0.2, \"s_min\": 3, \"eps\": 1e-12, \"w\": 32\n        },\n        {\n            \"N\": 11,\n            \"adj\": {\n                0: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1: [0], 2: [0], 3: [0],\n                4: [0], 5: [0], 6: [0], 7: [0], 8: [0], 9: [0], 10: [0]\n            },\n            \"u\": np.array([0, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10], dtype=float),\n            \"k\": np.full(11, 1),\n            \"tau\": 0.05, \"s_min\": 4, \"eps\": 1e-12, \"w\": 32\n        },\n        {\n            \"N\": 12,\n            \"adj\": {\n                0: [1, 2], 1: [0, 3, 4], 2: [0, 4, 5], 3: [1, 6],\n                4: [1, 2, 7], 5: [2, 8], 6: [3, 7, 9], 7: [4, 6, 10],\n                8: [5, 10, 11], 9: [6, 10], 10: [7, 8, 9, 11], 11: [8, 10]\n            },\n            \"u\": np.array([0.0, 0.1, 0.2, 0.15, 0.25, 0.3, 2.0, 2.1, 0.35, 2.05, 2.2, 0.4], dtype=float),\n            \"k\": np.array([2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2]),\n            \"tau\": 0.2, \"s_min\": 3, \"eps\": 1e-12, \"w\": 32\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, adj, u, k, tau, s_min, eps, w = case.values()\n        \n        stencil_sizes = []\n        total_edge_examinations = 0\n        total_indicator_evaluations = 0\n        element_costs = []\n\n        for i in range(N):\n            size, edge_exams, ind_evals = build_adaptive_stencil(i, N, adj, u, k, tau, s_min, eps)\n            stencil_sizes.append(size)\n            total_edge_examinations += edge_exams\n            total_indicator_evaluations += ind_evals\n            element_costs.append(edge_exams + ind_evals)\n\n        serial_time = float(sum(element_costs))\n        parallel_time = 0.0\n        \n        num_warps = (N + w - 1) // w\n        for warp_idx in range(num_warps):\n            start_idx = warp_idx * w\n            end_idx = min((warp_idx + 1) * w, N)\n            warp_costs = element_costs[start_idx:end_idx]\n            if warp_costs:\n                parallel_time += max(warp_costs)\n\n        if parallel_time > 0:\n            efficiency = serial_time / parallel_time\n            speedup = efficiency\n        else:\n            efficiency = 0.0 \n            speedup = 0.0\n\n        all_results.append(\n            f\"[[{','.join(map(str, stencil_sizes))}],{total_edge_examinations},{total_indicator_evaluations},{efficiency:.6f},{speedup:.6f}]\"\n        )\n        \n    print(f\"[{','.join(all_results)}]\")\n\ndef smoothness_indicator(ui, uj, eps):\n    \"\"\"Computes the smoothness indicator S(i,j).\"\"\"\n    numerator = abs(uj - ui)\n    denominator = abs(uj) + abs(ui) + eps\n    return numerator / denominator\n\ndef build_adaptive_stencil(i, N, adj, u, k, tau, s_min, eps):\n    \"\"\"\n    Implements the adaptive stencil selection for a single element i.\n    Uses a layered BFS approach.\n    \"\"\"\n    S_i = set()\n    rejected_candidates = []\n    \n    edge_examinations = 0\n    indicator_evaluations = 0\n    \n    visited_bfs = {i}\n    current_layer_nodes = [i]\n    dist = 0\n    max_k = k[i]\n\n    while dist  max_k:\n        if len(S_i) >= s_min:\n            break\n        \n        dist += 1\n        next_layer_nodes = []\n        candidates_at_this_dist = set()\n        \n        for node_u in current_layer_nodes:\n            for node_v in adj.get(node_u, []):\n                edge_examinations += 1\n                if node_v not in visited_bfs:\n                    visited_bfs.add(node_v)\n                    next_layer_nodes.append(node_v)\n                    candidates_at_this_dist.add(node_v)\n        \n        # Process newly discovered candidates for this layer\n        # Sort for deterministic behavior\n        for cand_node in sorted(list(candidates_at_this_dist)):\n            indicator_evaluations += 1\n            s_val = smoothness_indicator(u[i], u[cand_node], eps)\n            if s_val = tau:\n                S_i.add(cand_node)\n            else:\n                rejected_candidates.append((dist, s_val, cand_node))\n        \n        if not next_layer_nodes:\n            break\n        current_layer_nodes = next_layer_nodes\n\n    # Fallback mechanism\n    if len(S_i)  s_min:\n        rejected_candidates.sort() # Sorts by distance, then s_val, then node_id\n        needed = s_min - len(S_i)\n        \n        added_count = 0\n        for _, _, node in rejected_candidates:\n            if added_count >= needed:\n                break\n            if node not in S_i:\n              S_i.add(node)\n              added_count += 1\n    \n    return len(S_i), edge_examinations, indicator_evaluations\n\nsolve()\n```", "id": "3429522"}]}