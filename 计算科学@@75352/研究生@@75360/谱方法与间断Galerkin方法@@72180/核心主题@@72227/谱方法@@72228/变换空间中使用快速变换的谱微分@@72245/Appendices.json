{"hands_on_practices": [{"introduction": "理论的真正力量在于其应用。本章提供了一系列动手实践，旨在将谱微分的理论概念转化为具体的计算技能。第一个练习 [@problem_id:3417201] 是实现谱微分的基础。通过使用快速傅里叶变换 (FFT)，你将学习如何将物理空间中的微分操作转换为傅里叶空间中简单的乘法，从而亲身体验该方法的核心优势——高效与高精度。", "problem": "要求您设计并实现一个程序，该程序使用谱微分法，在变换空间中借助快速傅里叶变换 (FFT) 来计算周期函数的一阶导数。其基本原理是，物理域中的微分对应于傅里叶域中乘以虚数单位和角波数。所有角度都必须以弧度为单位。\n\n使用的基本原理如下。考虑一个在长度为 $L$ 的周期区间内的均匀网格上采样的周期函数。设网格为 $x_j = j\\Delta x$，其中 $j = 0, 1, \\dots, N-1$ 且 $\\Delta x = L/N$。离散傅里叶变换 (DFT) 及其逆变换（取决于库约定所选择的归一化常数）定义为\n$$\nU_k = \\sum_{j=0}^{N-1} u_j \\, e^{-i \\kappa_k x_j}, \\quad\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k \\, e^{i \\kappa_k x_j},\n$$\n其中 $u_j = u(x_j)$，$\\kappa_k$ 是对应于由 $k$ 索引的整数傅里叶模式的角波数。对于长度为 $L$ 的周期域，连续傅里叶模式为 $e^{i m (2\\pi/L) x}$，其中 $m$ 为整数，因此角波数为 $\\kappa = (2\\pi/L) m$。\n\n要使用的关键且经过充分检验的事实是，对于每个傅里叶模式 $e^{i \\kappa x}$，其导数满足\n$$\n\\frac{d}{dx} \\left( e^{i \\kappa x} \\right) = i \\kappa \\, e^{i \\kappa x}.\n$$\n因此，在傅里叶域中的微分对应于乘以 $i \\kappa$。\n\n通过将 DFT 索引映射到与周期网格一致的整数来构建角波数数组。对于偶数 $N$，整数波数的排序通常遵循所用 FFT 库的约定，例如 $0, 1, \\dots, N/2-1, -N/2, \\dots, -1$。对应的角波数是 $\\kappa_k = (2\\pi/L) \\, m_k$，其中 $m_k$ 遵循指定的排序。$m = N/2$ 处的奈奎斯特模式仅在 $N$ 为偶数时出现；谱微分中的常规选择是将奈奎斯特系数的微分乘子设为零，以确保对于实数输入数据，物理导数保持为实数值。\n\n您的实现必须遵循以下逻辑步骤，严格遵守上述原则，不使用任何未经证明的快捷公式：\n1. 在 $[0, L)$ 上用 $N$ 个点对函数 $u(x)$ 在等间距网格 $x_j$ 上进行采样。\n2. 使用快速傅里叶变换 (FFT) 计算 DFT 系数 $U_k$。\n3. 根据给定的 $L$ 和 $N$，从 DFT 频率箱构建角波数数组 $\\kappa_k$，确保负频率的排序正确。对于偶数 $N$，将奈奎斯特指数处的微分乘子设为零。\n4. 构成微分后的频谱 $\\widehat{u'}_k = i \\, \\kappa_k \\, U_k$。\n5. 计算 $\\widehat{u'}_k$ 的逆 DFT，以获得物理域中的微分值 $u'_j$。请一致地使用您的 FFT 库的约定。\n6. 提取 $u'_j$ 的实部，并按要求报告误差或诊断值。\n\n测试套件。您的程序必须计算并汇总以下测试用例，每个用例产生一个实数。除非另有说明，否则使用 $N = 16$，角度以弧度为单位。\n\n- 案例 A（理想路径，精确可解）：设 $L = 2\\pi$。定义 $u(x) = \\sin(3x) + 0.5 \\cos(5x)$。计算谱导数和解析导数 $u'(x) = 3 \\cos(3x) - 2.5 \\sin(5x)$。报告最大绝对误差 $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$，结果为浮点数。\n\n- 案例 B（奈奎斯特模式处理）：设 $L = 2\\pi$。定义 $u(x) = \\cos\\!\\big((N/2) x\\big) = \\cos(8x)$。计算谱导数，该导数在采样网格上应恒为零，因为其导数与 $\\sin\\!\\big((N/2) x\\big)$ 成正比，而在 $x_j = 2\\pi j/N$ 处求值时，该导数消失。报告 $\\max_j |u'_j|$，结果为浮点数。\n\n- 案例 C（超出奈奎斯特频率的混叠）：设 $L = 2\\pi$。定义 $u(x) = \\sin(9x)$。在 $N=16$ 的离散网格上，这会混叠成 $-\\sin(7x)$。谱方法将返回与混叠表示一致的导数，即在网格上约等于 $-7 \\cos(7x)$。报告谱导数与混叠导数之间的最大绝对误差，\n$$\n\\max_j \\left| u'_j - \\left( -7 \\cos(7 x_j) \\right) \\right|,\n$$\n结果为浮点数。\n\n- 案例 D（非单位域长度缩放）：设 $L = 4\\pi$。定义\n$$\nu(x) = \\sin\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) + 0.5 \\cos\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\n解析导数为\n$$\nu'(x) = \\left(3 \\cdot \\frac{2\\pi}{L}\\right) \\cos\\!\\left( 3 \\cdot \\frac{2\\pi}{L} x \\right) - 0.5 \\left(5 \\cdot \\frac{2\\pi}{L}\\right) \\sin\\!\\left( 5 \\cdot \\frac{2\\pi}{L} x \\right).\n$$\n报告最大绝对误差 $\\max_j |u'_j - u'_{\\text{analytic}}(x_j)|$，结果为浮点数。\n\n最终输出格式。您的程序应生成单行输出，其中包含按 [案例 A, 案例 B, 案例 C, 案例 D] 顺序排列、用方括号括起来的逗号分隔列表形式的结果。例如，形如“[resultA,resultB,resultC,resultD]”的一行。", "solution": "问题陈述已经过严格验证，并被确定是合理的。它具有科学依据、问题提法得当、客观，并为实现谱微分算法提供了一套完整且一致的要求。该问题是数值谱方法中的一个标准练习，与指定主题直接相关。因此，我们可以进行正式的求解。\n\n对长度为 $L$ 的域上的周期函数 $u(x)$ 进行谱微分的核心原理基于其傅里叶级数表示。任何足够平滑的周期函数都可以表示为复指数的和：\n$$\nu(x) = \\sum_{m=-\\infty}^{\\infty} \\hat{u}_m e^{i \\kappa_m x}\n$$\n其中 $\\hat{u}_m$ 是傅里叶系数，$\\kappa_m = m \\frac{2\\pi}{L}$ 是整数模式 $m$ 的角波数。傅里叶基的一个关键性质是，微分在此基下是对角化的。对级数逐项微分可得：\n$$\n\\frac{d u(x)}{dx} = \\sum_{m=-\\infty}^{\\infty} (i \\kappa_m) \\hat{u}_m e^{i \\kappa_m x}\n$$\n这表明，在傅里叶域中，函数 $u(x)$ 的微分对应于其傅里叶系数 $\\hat{u}_m$ 乘以因子 $i\\kappa_m$。\n\n对于计算实现，我们处理的是函数的离散版本。函数 $u(x)$ 在一个包含 $N$ 个点的均匀网格 $x_j = j \\Delta x$ 上采样，其中 $j = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。离散函数值为 $u_j = u(x_j)$。连续傅里叶级数被离散傅里叶变换 (DFT) 取代，它将物理空间值 $u_j$ 与一组 $N$ 个离散傅里叶系数 $U_k$ 联系起来。在像 `numpy` 这样的标准数值库中实现的正向和反向 DFT 对定义为：\n$$\nU_k = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi j k / N} \\quad (\\text{FFT})\n$$\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} U_k e^{i 2\\pi j k / N} \\quad (\\text{iFFT})\n$$\n此处，索引 $k$ 的范围从 $0$ 到 $N-1$，代表离散的频率箱。为了应用微分原理，我们必须将这些索引映射到正确的物理角波数 $\\kappa_k$。在一个 $N$ 点网格上可以唯一表示的整数波数集合 $m$ 包含了从负到正的值。对于偶数点数 $N$，标准约定将对应于 DFT 索引 $k=0, 1, \\dots, N-1$ 的整数模式 $m_k$ 排列为 $m_k \\in \\{0, 1, \\dots, N/2-1, -N/2, -N/2+1, \\dots, -1\\}$。与每个 DFT 索引 $k$ 相关联的物理角波数则由下式给出：\n$$\n\\kappa_k = m_k \\frac{2\\pi}{L}\n$$\n这个波数数组可以通过算法生成。谱微分的一个关键方面是处理奈奎斯特频率，对于偶数 $N$ 来说，它对应于整数模式 $|m| = N/2$。按照规定，奈奎斯特模式系数的微分乘子被设为零。这种做法确保了实值函数的计算导数保持为实值，并有助于稳定数值方案。虽然问题陈述描述了一个包含 $+N/2$ 的整数波数集，但标准的 FFT 库将奈奎斯特索引与 $-N/2$ 关联。这种区别无关紧要，因为将相应的微分乘子 $i\\kappa_{N/2}$ 设为 0 的指令使得符号变得无关紧要。\n\n谱微分的完整算法如下：\n1.  **离散化**：给定函数 $u(x)$、域长度 $L$ 和点数 $N$，生成网格值 $u_j = u(x_j)$，其中 $x_j = j L/N$，$j=0, \\dots, N-1$。\n2.  **正向变换**：使用快速傅里叶变换 (FFT) 算法计算离散信号 $u_j$ 的 DFT 系数 $U_k$：$U_k = \\text{FFT}(u_j)$。\n3.  **构建波数**：构建与 FFT 频率箱对应的角波数数组 $\\kappa_k$。对于每个索引 $k \\in \\{0, \\dots, N-1\\}$，计算 $\\kappa_k$。如果 $N$ 是偶数，则强制执行条件 $\\kappa_{N/2} = 0$。\n4.  **傅里叶空间微分**：将傅里叶系数 $U_k$ 乘以 $i\\kappa_k$ 以获得导数的系数，$\\widehat{u'}_k = i \\kappa_k U_k$。\n5.  **逆变换**：计算微分后系数 $\\widehat{u'}_k$ 的逆 FFT，以变换回物理空间，从而得到导数的离散值：$u'_j = \\text{iFFT}(\\widehat{u'}_k)$。\n6.  **最终结果**：对于实值输入函数 $u(x)$，计算出的导数 $u'_j$ 应该是实数。由于有限精度算术，可能会出现可忽略的虚部，通过取结果的实部将其丢弃。\n\n该过程应用于每个测试用例。\n-   **案例 A** 和 **案例 D** 测试该方法对于良好分辨函数（即频率远低于奈奎斯特极限的函数）的准确性，其中案例 D 特别测试了实现对非标准域长度 $L$ 的处理。对于此类函数，谱导数预计能达到机器精度。\n-   **案例 B** 测试对奈奎斯特频率的指定处理方式。在 $N=16$ 和 $L=2\\pi$ 的网格上，函数 $u(x) = \\cos(8x)$ 恰好对应于奈奎斯特频率。该算法必须产生零导数，因为其解析导数 $-8\\sin(8x)$ 在所有网格点 $x_j=j\\pi/8$ 处均为零。\n-   **案例 C** 测试混叠现象。对于 $N=16$，函数 $u(x) = \\sin(9x)$ 的频率高于奈奎斯特极限。在离散网格上，它与低频函数 $-\\sin(7x)$ 无法区分（即混叠为该函数）。谱方法作用于网格数据，正确地计算了这个混叠表示的导数，即 $-7\\cos(7x)$。", "answer": "```python\nimport numpy as np\n\ndef spectral_derivative(u: np.ndarray, L: float) -> np.ndarray:\n    \"\"\"\n    Computes the first derivative of a periodic function u on a domain of length L\n    using the Fourier spectral method.\n\n    Args:\n        u: A numpy array of function values sampled on a uniform grid.\n        L: The length of the periodic domain.\n\n    Returns:\n        A numpy array containing the values of the spectral derivative on the grid.\n    \"\"\"\n    N = len(u)\n    \n    # 1. Construct the angular wavenumber array.\n    # The sample spacing is d = L/N. np.fft.fftfreq returns frequencies in\n    # cycles per unit of d. Here, this is cycles/distance.\n    # The angular wavenumber is kappa = 2*pi*frequency.\n    # The fftfreq function correctly orders positive and negative frequencies\n    # for the DFT output.\n    freq = np.fft.fftfreq(N, d=L/N)\n    kappa = 2 * np.pi * freq\n\n    # 2. Handle the Nyquist frequency for even N.\n    # As per the problem specification, the derivative multiplier for the Nyquist\n    # coefficient must be zeroed out. This corresponds to the FFT index N//2.\n    if N % 2 == 0:\n        kappa[N//2] = 0.0\n\n    # 3. Compute the FFT of the function.\n    U = np.fft.fft(u)\n\n    # 4. Multiply by i*kappa in Fourier space to perform differentiation.\n    U_prime = 1j * kappa * U\n\n    # 5. Compute the Inverse FFT to return to physical space.\n    u_prime = np.fft.ifft(U_prime)\n\n    # 6. For a real input, the derivative is real. Return the real part\n    # to discard any imaginary noise from floating-point inaccuracies.\n    return u_prime.real\n\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the spectral differentiation algorithm and\n    prints the results in the specified format.\n    \"\"\"\n    # Globally specified parameter for test cases\n    N_global = 16\n\n    results = []\n\n    # Case A: Happy path, exact resolvability\n    L_A = 2.0 * np.pi\n    x_A = np.arange(N_global) * L_A / N_global\n    u_A = np.sin(3.0 * x_A) + 0.5 * np.cos(5.0 * x_A)\n    u_prime_analytic_A = 3.0 * np.cos(3.0 * x_A) - 2.5 * np.sin(5.0 * x_A)\n    u_prime_spectral_A = spectral_derivative(u_A, L_A)\n    error_A = np.max(np.abs(u_prime_spectral_A - u_prime_analytic_A))\n    results.append(error_A)\n\n    # Case B: Nyquist mode handling\n    L_B = 2.0 * np.pi\n    x_B = np.arange(N_global) * L_B / N_global\n    u_B = np.cos((N_global / 2.0) * x_B)\n    u_prime_spectral_B = spectral_derivative(u_B, L_B)\n    # The spectral derivative should be identically zero due to Nyquist handling.\n    # We report the maximum absolute value of the computed derivative.\n    error_B = np.max(np.abs(u_prime_spectral_B))\n    results.append(error_B)\n\n    # Case C: Aliasing beyond Nyquist\n    L_C = 2.0 * np.pi\n    x_C = np.arange(N_global) * L_C / N_global\n    u_C = np.sin(9.0 * x_C)\n    # On the grid, sin(9x) aliases to -sin(7x). The spectral method\n    # differentiates this aliased representation, yielding -7*cos(7x).\n    u_aliased_deriv_C = -7.0 * np.cos(7.0 * x_C)\n    u_prime_spectral_C = spectral_derivative(u_C, L_C)\n    error_C = np.max(np.abs(u_prime_spectral_C - u_aliased_deriv_C))\n    results.append(error_C)\n\n    # Case D: Non-unit domain length scaling\n    L_D = 4.0 * np.pi\n    x_D = np.arange(N_global) * L_D / N_global\n    # Fundamental wavenumber for this domain\n    k0_D = 2.0 * np.pi / L_D\n    u_D = np.sin(3.0 * k0_D * x_D) + 0.5 * np.cos(5.0 * k0_D * x_D)\n    u_prime_analytic_D = \\\n        (3.0 * k0_D) * np.cos(3.0 * k0_D * x_D) - \\\n        0.5 * (5.0 * k0_D) * np.sin(5.0 * k0_D * x_D)\n    u_prime_spectral_D = spectral_derivative(u_D, L_D)\n    error_D = np.max(np.abs(u_prime_spectral_D - u_prime_analytic_D))\n    results.append(error_D)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3417201"}, {"introduction": "在掌握了基本微分方法之后，我们来解决一个在应用中（尤其是在非线性问题中）普遍存在的挑战：混叠误差。当计算函数乘积的导数时，高频分量可能会被错误地表示为低频分量，从而污染计算结果。这个练习 [@problem_id:3417276] 将指导你实现一种关键的去混叠技术——“三分之二规则”，让你学会如何通过补零来精确计算非线性项的导数。", "problem": "考虑在区间 $[0,2\\pi)$ 上一个包含 $N$ 个点的均匀周期网格上采样的 $2\\pi$ 周期函数 $u(x)=\\sin(ax)$ 和 $v(x)=\\cos(bx)$，其中 $x_j=\\frac{2\\pi j}{N}$，$j=0,1,\\dots,N-1$，角度以弧度为单位。目标是使用谱方法，在变换空间中通过快速傅里叶变换 (FFT) 计算空间导数 $\\partial_x(uv)$。计算将分两种情况进行：不进行去混叠，以及通过 $3/2$ 补零实现的“三分之二规则”去混叠。然后，通过与从第一性原理得到的精确解析导数进行比较，来量化混叠误差。\n\n从以下基本原理出发：\n- $2\\pi$ 周期函数 $f(x)$ 的傅里叶级数表示，以及通过快速傅里叶变换 (FFT) 计算的离散傅里叶变换 (DFT)。\n- 变换空间中的导数恒等式：对于每个傅里叶模式 $e^{\\mathrm{i}kx}$，恒有 $\\partial_x e^{\\mathrm{i}kx}=\\mathrm{i}k e^{\\mathrm{i}kx}$。\n- 乘积法则 $\\partial_x(uv)=u_x v + u v_x$。\n\n设计一个程序，对下述每个测试用例执行以下任务：\n1. 在 $N$ 个网格点上计算 $w(x)=u(x)v(x)$，然后将 $w$ 变换到傅里叶空间，乘以 $\\mathrm{i}k$，再变换回原空间，从而在这些点上计算 $\\partial_x w$。使用与 $[0,2\\pi)$ 域一致的角波数 $k$。这是不进行去混叠的计算。\n2. 使用通过 $3/2$ 补零实现的“三分之二规则”进行去混叠来计算 $\\partial_x w$：将 $u$ 和 $v$ 的离散傅里叶变换从长度 $N$ 补零到长度 $M=\\frac{3N}{2}$（确保系数被正确缩放，以使逆变换在更精细的网格上计算出相同的连续傅里叶内容），逆变换到 $M$ 点网格，在 $M$ 点网格上逐点形成乘积 $w$，将 $w$ 变换回傅里叶空间，在分辨率为 $M$ 的情况下乘以 $\\mathrm{i}k$，将结果谱截断回长度 $N$（使用逆向缩放以保留低频内容），然后逆变换到原始的 $N$ 点网格。\n3. 使用乘积法则以及 $u$ 和 $v$ 的定义，计算精确的解析导数 $\\partial_x(uv)$，并在 $N$ 个网格点上求值。\n4. 对非去混叠和去混叠两种计算方法，量化其混叠误差。误差定义为相对于精确解析导数的相对离散 $\\ell^2$ 误差：\n$$\nE_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是在 $N$ 个采样网格点上的欧几里得范数。\n\n你的程序必须实现基于 FFT 的谱微分，其中使用根据采样间距 $\\Delta x = \\frac{2\\pi}{N}$ 从 DFT 频率数组构造的适当角波数 $k$，以确保角波数为整数。它还必须实现 $3/2$ 补零程序，并在补零和截断谱时进行一致的缩放，以保留低频傅里叶模式的振幅。\n\n测试套件：\n使用以下五个测试用例来检验不同的混叠情况。每个测试用例是一个元组 $(N,a,b)$，角度单位为弧度：\n- 用例 1（无混叠，低波数）：$(16,3,4)$。\n- 用例 2（强混叠，输入为高但可分辨的波数，其乘积激发出高于奈奎斯特频率的模式）：$(16,7,7)$。\n- 用例 3（在较高分辨率下无混叠）：$(32,12,13)$。\n- 用例 4（在分辨率极限附近发生混叠）：$(32,15,17)$。\n- 用例 5（在中等分辨率下发生混叠）：$(24,8,10)$。\n\n答案规格：\n对于每个测试用例，计算相对 $\\ell^2$ 误差对 $[E_{\\ell^2}^{\\text{no-dealias}}, E_{\\ell^2}^{\\text{dealias}}]$。将所有五个用例的结果汇总成单行输出，其中包含一个由五个此类误差对组成的列表。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内每个元素本身也是一个用方括号括起来的逗号分隔列表，并且没有空格。例如：\"[[e11,e12],[e21,e22],[e31,e32],[e41,e42],[e51,e52]]\"。所有角度都必须以弧度处理。不涉及除弧度外的其他物理单位，也无需进行转换。", "solution": "用户希望我解决一个问题，该问题涉及使用谱方法计算两个三角函数乘积的导数，并量化混叠误差。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n\n- **函数**：$u(x) = \\sin(ax)$ 和 $v(x) = \\cos(bx)$ 是 $2\\pi$ 周期的。\n- **域**：在 $[0, 2\\pi)$ 上的均匀网格，有 $N$ 个点，$x_j = \\frac{2\\pi j}{N}$，$j=0, 1, \\dots, N-1$。\n- **任务**：计算空间导数 $\\partial_x(uv)$。\n- **方法 1 (无去混叠)**：在物理空间中计算乘积 $w=uv$，使用 FFT 变换到傅里叶空间，将每个模式 $\\hat{w}(k)$ 乘以 $\\mathrm{i}k$，然后使用 IFFT 变换回来。\n- **方法 2 (通过三分之二规则去混叠)**：\n    1. 将 $u$ 和 $v$ 的傅里叶变换从长度 $N$ 补零到 $M = \\frac{3N}{2}$。\n    2. 对补零后的谱应用缩放。\n    3. 逆变换到 $M$ 点网格。\n    4. 在 $M$ 点网格上计算乘积 $w=uv$。\n    5. 将 $w$ 变换到 $M$ 维傅里叶空间。\n    6. 将每个模式 $\\hat{w}(k)$ 乘以 $\\mathrm{i}k$（使用 $M$ 点网格的波数）。\n    7. 将结果谱截断回长度 $N$。\n    8. 应用逆向缩放。\n    9. 逆变换到原始的 $N$ 点网格。\n- **方法 3 (精确解析导数)**：使用乘积法则计算 $\\partial_x(uv)$：$\\partial_x(uv) = (\\partial_x u)v + u(\\partial_x v)$。\n- **误差度量**：相对离散 $\\ell^2$ 误差，$E_{\\ell^2} = \\frac{\\left\\| \\partial_x w_{\\text{computed}} - \\partial_x w_{\\text{exact}} \\right\\|_2}{\\left\\| \\partial_x w_{\\text{exact}} \\right\\|_2}$，其中 $\\|\\cdot\\|_2$ 是 $N$ 个网格点上的欧几里得范数。\n- **波数**：角波数 $k$ 必须是与域一致的整数。\n- **测试套件**：\n    - 用例 1：$(N, a, b) = (16, 3, 4)$\n    - 用例 2：$(N, a, b) = (16, 7, 7)$\n    - 用例 3：$(N, a, b) = (32, 12, 13)$\n    - 用例 4：$(N, a, b) = (32, 15, 17)$\n    - 用例 5：$(N, a, b) = (24, 8, 10)$\n- **输出格式**：一个包含五个对的列表的单行字符串表示：`[[e1_no_dealias,e1_dealias], [e2_no_dealias,e2_dealias], ...]`。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题是数值分析中的一个标准练习，特别是在谱方法领域。它正确地利用傅里叶变换进行微分，并解决了众所周知的混叠现象。所提出的去混叠方法（通过补零实现的“三分之二规则”）是一种经典技术。所有原理都是合理的。\n- **适定性**：问题定义清晰，具有具体、明确的算法步骤。测试套件中提供了所有必需的参数。误差度量是一个标准的数学定义。所有测试用例都使用偶数 $N$，因此 $M=3N/2$ 是整数，确保了补零过程是明确定义的。每个测试用例都存在唯一的、确定性的数值结果。\n- **客观性**：问题使用精确的数学和算法语言陈述，没有任何主观性或模糊性。\n\n该问题不违反任何无效性标准。它在科学上是合理的，适定的，客观的，完整的，并且对指定主题提出了一个非平凡的挑战。\n\n**步骤 3：结论与行动**\n\n该问题是 **有效的**。将提供完整的解决方案。\n\n### **解决方案制定**\n\n这个问题的核心在于理解傅里叶空间中如何处理微分和乘法，以及离散网格的有限分辨率如何导致混叠误差。\n\n**1. 谱微分**\n\n一个 $2\\pi$ 周期函数 $f(x)$ 可以表示为傅里叶级数：\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} c_k e^{\\mathrm{i}kx}\n$$\n其中 $k$ 是整数角波数，$c_k$ 是复傅里叶系数。逐项微分得到：\n$$\n\\partial_x f(x) = \\sum_{k=-\\infty}^{\\infty} (\\mathrm{i}k) c_k e^{\\mathrm{i}kx}\n$$\n这表明物理空间中的微分对应于傅里叶空间中乘以 $\\mathrm{i}k$。\n\n在 $N$ 个点 $x_j = 2\\pi j/N$ 的离散网格上，我们使用离散傅里叶变换 (DFT)，并通过快速傅里叶变换 (FFT) 高效计算。其步骤如下：\n1. 计算采样函数 $f(x_j)$ 的 DFT，以获得其离散谱 $\\hat{f}_k$。\n2. 确定与 DFT 数组中每个元素对应的整数波数 $k$。对于长度为 $2\\pi$ 的域，对于偶数 $N$，波数为 $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。\n3. 将每个 $\\hat{f}_k$ 乘以 $\\mathrm{i}k$。\n4. 计算所得谱的逆离散傅里叶变换 (IDFT)，以获得导数样本 $\\partial_x f(x_j)$。\n\n**2. 乘积中的混叠**\n\n两个函数 $w(x) = u(x)v(x)$ 的乘积，在傅里叶空间中对应于它们谱的卷积。如果 $u(x)$ 中的最高波数是 $k_u$，$v(x)$ 中的最高波数是 $k_v$，则乘积 $w(x)$ 将包含高达 $k_u + k_v$ 的波数。\n\n在一个大小为 $N$ 的网格上，可以无歧义表示的最高波数是奈奎斯特波数，$k_{Nyquist} = N/2$。如果 $k_u + k_v > k_{Nyquist}$，乘积的高频内容就会“混叠”，这意味着它在网格上被错误地表示为一个较低频率的模式。对于波数 $k > k_{Nyquist}$ 的模式，它在网格上的混叠将是 $k' = k - mN$，其中某个整数 $m$ 将 $k'$ 带入可分辨范围 $[ -N/2, N/2-1 ]$。这会破坏数值结果。\n\n**3. 使用三分之二规则去混叠**\n\n为了无混叠地计算乘积 $uv$，我们必须在足够精细的网格上执行乘法，以表示所有产生的波数。“三分之二规则”指出，如果我们将初始谱限制在波数 $|k|  N/3$ 的范围内，则乘积的最高模式将小于 $2N/3$。这可以在一个大小为 $M$ 的补零网格上得到解决，只要其奈奎斯特极限满足 $M/2 > 2N/3$，这对于通常的选择 $M = 3N/2$ 是成立的。\n\n该问题指定了一个实现此思想的算法：\n- 将 $u$ 和 $v$ 变换到傅里叶空间。\n- 将它们的谱补零到更大的尺寸 $M=3N/2$。这等同于将函数插值到更精细的网格上。\n- 一个关键步骤是缩放谱。为了在从 $N$ 点 IFFT 移动到 $M$ 点 IFFT 时保持函数值不变，傅里叶系数必须按因子 $M/N$ 进行缩放。\n- 在精细网格上，逐点乘以函数值：$w_{padded} = u_{padded} v_{padded}$。如果原始波数足够低，则此乘积没有混叠。\n- 将 $w_{padded}$ 变换到 $M$ 维傅里叶空间，通过乘以 $\\mathrm{i}k$（使用 $M$ 网格的波数）进行微分，然后将结果谱截断回大小为 $N$。\n- 此截断需要一个 $N/M$ 的逆向缩放因子，以在 $N$ 点 DFT 约定中正确表示连续傅里叶振幅。\n- 最终的 IFFT 得到原始网格上的去混叠导数。\n\n**4. 解析导数**\n\n精确导数为误差分析提供了基准。使用乘积法则：\n$$\nw(x) = \\sin(ax)\\cos(bx)\n$$\n$$\n\\partial_x w(x) = \\frac{d}{dx}(\\sin(ax))\\cos(bx) + \\sin(ax)\\frac{d}{dx}(\\cos(bx))\n$$\n$$\n\\partial_x w(x) = a\\cos(ax)\\cos(bx) - b\\sin(ax)\\sin(bx)\n$$\n在网格点 $x_j$ 上评估此表达式，以获得精确的参考解。\n\n**5. 实现步骤**\n\n程序将遍历每个测试用例 $(N, a, b)$ 并执行以下计算：\n1. **网格和函数**：定义 $N$ 点网格 `x` 和样本数组 `u` 和 `v`。\n2. **非去混叠导数**：计算 `w = u * v`，进行 FFT 得到 `w_hat`，乘以 `1j * k`，然后进行 IFFT 得到 `dw_dx_no_dealias`。使用此结果的实部。\n3. **去混叠导数**：\n    - 对 `u` 和 `v` 进行 FFT 得到 `u_hat` 和 `v_hat`。\n    - 创建大小为 $M=3N/2$ 的零数组 `u_hat_padded` 和 `v_hat_padded`。\n    - 将原始谱中的频率分量复制到补零谱中，保持其波数位置。\n    - 将补零谱按 $M/N$ 进行缩放。\n    - 进行 IFFT 得到精细网格上的 `u_padded` 和 `v_padded`。\n    - 计算乘积 `w_padded = u_padded * v_padded`。\n    - 进行 FFT 得到 `w_padded_hat`。\n    - 通过乘以 `1j * k_padded` 进行微分。\n    - 将结果谱截断回大小为 $N$。\n    - 将截断后的谱按 $N/M$ 进行缩放。\n    - 进行 IFFT 得到 `dw_dx_dealias`。使用此结果的实部。\n4. **精确导数**：在网格 `x` 上评估 $\\partial_x w(x)$ 的解析公式。\n5. **误差计算**：对于两种数值方法，计算数值导数与精确导数之差的相对 $\\ell^2$ 范数。结果存储为一对 `[error_no_dealias, error_dealias]`。\n最后，收集所有对并以指定的字符串格式打印。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral differentiation problem for a suite of test cases.\n    \"\"\"\n\n    def compute_errors(N, a, b):\n        \"\"\"\n        Computes the derivative of u(x)v(x) and its error for a given (N, a, b).\n\n        Args:\n            N (int): Number of grid points.\n            a (int): Wavenumber for sin(ax).\n            b (int): Wavenumber for cos(bx).\n\n        Returns:\n            list: A pair of floats [error_no_dealias, error_dealias].\n        \"\"\"\n        # 1. Grid, functions, and analytical derivative\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(a * x)\n        v = np.cos(b * x)\n        \n        # Exact analytical derivative evaluated on the grid\n        dw_dx_exact = a * np.cos(a * x) * np.cos(b * x) - b * np.sin(a * x) * np.sin(b * x)\n        norm_exact = np.linalg.norm(dw_dx_exact)\n\n        # Handle case where the exact derivative is zero to avoid division by zero.\n        if norm_exact  1e-15:\n            # If the exact derivative is zero, the absolute error is the norm of the computed one.\n            # Relative error is not well-defined, but we can check if the computed is also zero.\n            # For this problem's test cases, norm_exact is never zero.\n            pass\n\n        # 2. Method 1: No De-aliasing\n        w = u * v\n        k_N = np.fft.fftfreq(N) * N\n        dw_dx_hat_no_dealias = 1j * k_N * np.fft.fft(w)\n        dw_dx_no_dealias = np.fft.ifft(dw_dx_hat_no_dealias)\n\n        error_no_dealias = np.linalg.norm(dw_dx_no_dealias.real - dw_dx_exact) / norm_exact\n\n        # 3. Method 2: De-aliasing with 3/2 zero-padding\n        M = 3 * N // 2\n        \n        u_hat = np.fft.fft(u)\n        v_hat = np.fft.fft(v)\n        \n        # Padded spectra\n        u_hat_padded = np.zeros(M, dtype=np.complex128)\n        v_hat_padded = np.zeros(M, dtype=np.complex128)\n        \n        # Slicing indices for even N\n        # Positive frequencies (and zero) go at the beginning.\n        # Negative frequencies (including Nyquist) go at the end.\n        n_pos_freqs = N // 2\n        \n        # Copy positive frequencies\n        u_hat_padded[:n_pos_freqs] = u_hat[:n_pos_freqs]\n        v_hat_padded[:n_pos_freqs] = v_hat[:n_pos_freqs]\n\n        # Copy negative frequencies\n        u_hat_padded[M - (N - n_pos_freqs):] = u_hat[n_pos_freqs:]\n        v_hat_padded[M - (N - n_pos_freqs):] = v_hat[n_pos_freqs:]\n        \n        # Scale for IFFT to finer grid\n        u_hat_padded *= M / N\n        v_hat_padded *= M / N\n        \n        # Transform to fine grid, multiply, and transform back\n        u_padded = np.fft.ifft(u_hat_padded)\n        v_padded = np.fft.ifft(v_hat_padded)\n        w_padded = u_padded * v_padded\n        w_padded_hat = np.fft.fft(w_padded)\n        \n        # Differentiate in padded Fourier space\n        k_M = np.fft.fftfreq(M) * M\n        dw_dx_padded_hat = 1j * k_M * w_padded_hat\n        \n        # Truncate spectrum back to size N\n        dw_dx_hat_dealias = np.zeros(N, dtype=np.complex128)\n        dw_dx_hat_dealias[:n_pos_freqs] = dw_dx_padded_hat[:n_pos_freqs]\n        dw_dx_hat_dealias[n_pos_freqs:] = dw_dx_padded_hat[M - (N - n_pos_freqs):]\n\n        # Scale for IFFT to original grid\n        dw_dx_hat_dealias *= N / M\n        \n        dw_dx_dealias = np.fft.ifft(dw_dx_hat_dealias)\n        \n        error_dealias = np.linalg.norm(dw_dx_dealias.real - dw_dx_exact) / norm_exact\n        \n        return [error_no_dealias, error_dealias]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 3, 4),   # Case 1\n        (16, 7, 7),   # Case 2\n        (32, 12, 13), # Case 3\n        (32, 15, 17), # Case 4\n        (24, 8, 10),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b = case\n        errors = compute_errors(N, a, b)\n        results.append(errors)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is very close.\n    # We just need to remove spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3417276"}, {"introduction": "谱方法在处理平滑函数时表现出色，但当函数存在不连续或尖锐梯度时会发生什么呢？这个练习 [@problem_id:3417221] 探讨了谱方法在处理非光滑函数时遇到的吉布斯现象——一种在不连续点附近产生的振荡伪影。你将学习如何应用模态滤波器来抑制这些振荡，从而在保留谱方法高精度优势的同时，提高其在更广泛问题上的适用性和鲁棒性。", "problem": "考虑周期区间 $[0,2\\pi)$，其中角度以弧度为单位。设 $f(x)$ 是在 $x=\\pi$ 处有单跳跃的分段常数函数，定义为\n$$\nf(x)=\\begin{cases}\n1,  x\\in[0,\\pi),\\\\\n0,  x\\in[\\pi,2\\pi).\n\\end{cases}\n$$\n在一个由 $N$ 个等距点 $x_j=\\frac{2\\pi j}{N}$（$j=0,1,\\dots,N-1$）组成的网格上，您将使用通过快速傅里叶变换 (FFT) 计算的离散傅里叶变换来近似 $f$ 的谱导数，利用物理空间中的微分对应于变换空间中乘以波数的基本性质。具体来说，实现以下两种变体。\n1. 一种未滤波的谱导数，通过将 $f$ 变换到傅里叶空间，将每个模态系数乘以与对 $x$ 微分相对应的波数因子，然后变换回物理空间得到。\n2. 一种滤波后的谱导数，通过在傅里叶空间中对微分后的模态系数应用指数模态滤波器得到。该滤波器定义为\n$$\n\\sigma(k) = \\exp\\left(-\\left(\\alpha \\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)\\right),\n$$\n其中 $k$ 是整数波数，$k_{\\max}=\\frac{N}{2}$，$p$ 是一个正偶数（滤波器阶数），$\\alpha0$ 是用户指定的常数。在微分步骤中，将奈奎斯特模（即当 $N$ 为偶数时 $|k|=k_{\\max}$ 的模）设置为零，以避免在该网格上表示该模的导数时出现歧义。\n\n将点 $x$ 到跳跃位置 $x=\\pi$ 的周期距离定义为\n$$\nd(x,\\pi) = \\min\\left(|x-\\pi|,\\, 2\\pi-|x-\\pi|\\right).\n$$\n对于给定的排除半宽 $\\varepsilon\\in(0,\\pi)$，定义外部网格点集\n$$\nS_\\varepsilon = \\left\\{x_j:\\ d(x_j,\\pi)\\ge \\varepsilon\\right\\}.\n$$\n通过以下两个在 $S_\\varepsilon$ 上计算的度量来量化远离跳跃点的吉布斯型过冲幅度和近似导数的 $L^2$ 范数：\n- 过冲幅度 $O = \\max_{x_j\\in S_\\varepsilon}\\left|g(x_j)\\right|$，其中 $g$ 是近似导数。\n- 离散 $L^2$ 范数 $E = \\left(\\sum_{x_j\\in S_\\varepsilon} |g(x_j)|^2\\,\\Delta x\\right)^{1/2}$，其中 $\\Delta x=\\frac{2\\pi}{N}$。\n\n对于下面的每个测试用例，计算：\n- 过冲减小比 $R = \\dfrac{O_{\\mathrm{filtered}}}{O_{\\mathrm{unfiltered}}}$。\n- 在 $S_\\varepsilon$ 上的未滤波 $L^2$ 范数 $E_{\\mathrm{unfiltered}}$。\n- 在 $S_\\varepsilon$ 上的滤波后 $L^2$ 范数 $E_{\\mathrm{filtered}}$。\n\n使用以下参数测试套件 $(N,p,\\alpha,\\varepsilon)$:\n- $(N,p,\\alpha,\\varepsilon)=(32,8,36,0.3)$，\n- $(N,p,\\alpha,\\varepsilon)=(128,8,36,0.2)$，\n- $(N,p,\\alpha,\\varepsilon)=(256,16,36,0.15)$，\n- $(N,p,\\alpha,\\varepsilon)=(256,4,18,0.15)$。\n\n您的程序必须：\n- 为每个 $N$ 在网格上构造 $f$。\n- 使用上述傅里叶微分性质和指定的指数滤波器计算未滤波和滤波后的谱导数。\n- 对每个测试用例，使用上述定义计算 $R$、$E_{\\mathrm{unfiltered}}$ 和 $E_{\\mathrm{filtered}}$，所有角度均以弧度为单位。\n- 生成单行输出，其中包含一个浮点结果的扁平列表，顺序如下\n$$\n\\left[R_1,\\,E_{\\mathrm{unfiltered},1},\\,E_{\\mathrm{filtered},1},\\,R_2,\\,E_{\\mathrm{unfiltered},2},\\,E_{\\mathrm{filtered},2},\\,R_3,\\,E_{\\mathrm{unfiltered},3},\\,E_{\\mathrm{filtered},3},\\,R_4,\\,E_{\\mathrm{unfiltered},4},\\,E_{\\mathrm{filtered},4}\\right].\n$$\n该行必须严格格式化为 Python 列表，使用逗号分隔值并用方括号括起来。所有答案都是无量纲的，并且必须以浮点数形式报告。\n\n该测试套件旨在涵盖一个低分辨率情况 ($N=32$)、两个较高分辨率情况 ($N=128$ 和 $N=256$)，以及一个较强与较弱滤波器（不同的 $p$ 和 $\\alpha$）的比较，以评估过冲减小情况和远离跳跃点的 $L^2$ 收敛性。", "solution": "其基本原理是周期函数的傅里叶表示，以及一个经过充分检验的性质，即物理空间中的微分对应于傅里叶空间中乘以虚数单位和波数。设 $f(x)$ 是 $2\\pi$ 周期的，其傅里叶级数为 $f(x)=\\sum_{k\\in\\mathbb{Z}} c_k e^{i k x}$，$x\\in[0,2\\pi)$。那么其导数为 $f'(x)=\\sum_{k\\in\\mathbb{Z}} (i k) c_k e^{i k x}$。对于等距节点 $x_j=\\frac{2\\pi j}{N}$，对傅里叶级数进行采样并应用离散傅里叶变换 (DFT)，可将样本 $\\{f(x_j)\\}$ 映射到与 $\\{c_k\\}$ 成比例的模态系数，而逆 DFT 则将模态系数映射回节点值。因此，网格上的谱微分算法按以下步骤进行：\n1. 使用快速傅里叶变换 (FFT) 算法计算 $\\{f(x_j)\\}$ 的 DFT $\\{F_k\\}$。\n2. 将每个模态乘以因子 $i k$ 以表示对 $x$ 的微分（按照惯例，对于偶数 $N$，奈奎斯特模 $|k|=k_{\\max}=\\frac{N}{2}$ 的导数设为零，以避免在其网格上表示时产生歧义）。\n3. 应用逆 DFT 返回到物理空间值 $\\{g(x_j)\\}$，这些值以谱方法近似 $f'(x)$。\n\n因为给定的函数 $f$ 是具有单个跳跃不连续点的分段常数函数，所以在分布意义上，其精确导数是在跳跃位置 $x=\\pi$ 处的狄拉克δ函数（按跳跃幅度缩放），在其他地方为 0。狄拉克δ函数不属于平方可积空间 $L^2([0,2\\pi])$，因此在整个域上，$g$ 对 $f'$ 的经典全局 $L^2$ 收敛是没有意义的。然而，在远离跳跃点的地方，其中 $f$ 是光滑的（实际上是常数），谱微分应该近似于精确导数 0，因此在任何排除跳跃点邻域的固定子域上，其 $L^2$ 范数应该收敛到 0。为了衡量这一点，我们定义了一个围绕 $x=\\pi$ 的半宽为 $\\varepsilon$ 的排除区域，并在其补集 $S_\\varepsilon$ 上评估 $g$ 的离散 $L^2$ 范数。\n\n吉布斯型振荡是由于跳跃点引起的，并表现为谱导数在远离跳跃点处的非零振荡行为。模态滤波通过衰减高波数模态来减少这些振荡。一个阶数为 $p$、强度为 $\\alpha$ 的指数滤波器应用于微分后的模态系数 $\\{D_k\\}$，即\n$$\n\\sigma(k)=\\exp\\left(-\\left(\\alpha\\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)\\right),\\qquad D^{(\\mathrm{filtered})}_k=\\sigma(k) D_k,\\qquad k_{\\max}=\\frac{N}{2}.\n$$\n这保留了低阶模态，同时指数衰减了主要引起吉布斯振荡的高阶模态，从而减少了过冲和远离跳跃点的 $L^2$ 范数。\n\n算法设计：\n- 网格与函数：对于每个 $N$，构造 $x_j=\\frac{2\\pi j}{N}$（$j=0,\\dots,N-1$），并设置 $f(x_j)=1$（对于 $x_j\\in[0,\\pi)$）和 $f(x_j)=0$（对于 $x_j\\in[\\pi,2\\pi)$）。\n- 波数：使用频率实用工具提供的标准 DFT 波数排序 $k\\in\\{0,1,\\dots,\\frac{N}{2},-\\frac{N}{2}+1,\\dots,-1\\}$，或等效地通过将归一化 DFT 频率乘以 $N$ 得到。将奈奎斯特模 $k=\\pm \\frac{N}{2}$ 的微分因子设为 0。\n- 未滤波的导数：计算 $F_k=\\mathrm{FFT}(f)$，形成 $D_k=(i k)F_k$（并如上处理奈奎斯特模），然后设置 $g_{\\mathrm{unfiltered}}(x_j)=\\mathrm{Re}\\left(\\mathrm{IFFT}(D_k)\\right)$。\n- 滤波后的导数：将指数滤波器 $\\sigma(k)$ 应用于 $D_k$ 得到 $D^{(\\mathrm{filtered})}_k=\\sigma(k) D_k$，然后计算 $g_{\\mathrm{filtered}}(x_j)=\\mathrm{Re}\\left(\\mathrm{IFFT}(D^{(\\mathrm{filtered})}_k)\\right)$。\n- 远离跳跃点的度量：定义周期距离 $d(x,\\pi)=\\min(|x-\\pi|,2\\pi-|x-\\pi|)$ 和外部集 $S_\\varepsilon=\\{x_j:\\ d(x_j,\\pi)\\ge \\varepsilon\\}$。设 $\\Delta x=\\frac{2\\pi}{N}$，计算：\n  - $O_{\\mathrm{unfiltered}}=\\max_{x_j\\in S_\\varepsilon} |g_{\\mathrm{unfiltered}}(x_j)|$,\n  - $O_{\\mathrm{filtered}}=\\max_{x_j\\in S_\\varepsilon} |g_{\\mathrm{filtered}}(x_j)|$,\n  - $E_{\\mathrm{unfiltered}}=\\left(\\sum_{x_j\\in S_\\varepsilon} |g_{\\mathrm{unfiltered}}(x_j)|^2\\,\\Delta x\\right)^{1/2}$,\n  - $E_{\\mathrm{filtered}}=\\left(\\sum_{x_j\\in S_\\varepsilon} |g_{\\mathrm{filtered}}(x_j)|^2\\,\\Delta x\\right)^{1/2}$,\n  - $R=\\frac{O_{\\mathrm{filtered}}}{O_{\\mathrm{unfiltered}}}$ (如果 $O_{\\mathrm{unfiltered}}=0$，则定义 $R=0$)。\n- 数值复杂度：每次 FFT 和逆 FFT 的复杂度为 $\\mathcal{O}(N\\log N)$，并且这些操作是向量化的。对于该测试套件，总计算成本适中。\n\n预期行为：\n- 对于固定的 $\\varepsilon$，随着 $N$ 的增加，$S_\\varepsilon$ 上的 $E_{\\mathrm{unfiltered}}$ 和 $E_{\\mathrm{filtered}}$ 都应该减小，因为谱导数能更好地解析远离跳跃点的常数区域。滤波版本通常比未滤波版本获得更小的过冲和 $L^2$ 误差，因此 $R$ 应小于 1，且在大多数情况下 $E_{\\mathrm{filtered}}  E_{\\mathrm{unfiltered}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef periodic_distance(x, a, L=2*np.pi):\n    # Compute periodic distance on [0,L)\n    d = np.abs(x - a)\n    return np.minimum(d, L - d)\n\ndef spectral_derivative(values):\n    \"\"\"\n    Compute unfiltered spectral derivative on equispaced grid over [0, 2pi).\n    values: array of f(x_j) samples, length N.\n    Returns real-valued derivative approximation g(x_j).\n    \"\"\"\n    N = values.size\n    F = np.fft.fft(values)\n    # Integer wavenumbers in FFT ordering\n    k = np.fft.fftfreq(N) * N  # yields [0,1,2,...,N/2,-N/2+1,...,-1]\n    # Handle Nyquist mode for even N by zeroing its derivative\n    k = k.astype(float)\n    if N % 2 == 0:\n        k[int(N//2)] = 0.0\n    D = 1j * k * F\n    g = np.fft.ifft(D).real\n    return g\n\ndef filtered_spectral_derivative(values, p, alpha):\n    \"\"\"\n    Compute filtered spectral derivative using an exponential modal filter\n    applied to the differentiated modal coefficients.\n    p: even integer filter order\n    alpha: positive filter strength\n    \"\"\"\n    N = values.size\n    F = np.fft.fft(values)\n    k = np.fft.fftfreq(N) * N\n    k = k.astype(float)\n    if N % 2 == 0:\n        k[int(N//2)] = 0.0\n    # Differentiate in spectral space\n    D = 1j * k * F\n    # Exponential filter\n    kmax = N / 2.0\n    # Avoid division by zero at k=0\n    ksi = np.abs(k) / kmax\n    sigma = np.exp(- (alpha * (ksi ** p)))\n    # Ensure exact preservation of mean mode\n    sigma[0] = 1.0\n    Df = sigma * D\n    g = np.fft.ifft(Df).real\n    return g\n\ndef compute_metrics(N, p, alpha, eps):\n    \"\"\"\n    For given parameters, build f, compute unfiltered and filtered derivatives,\n    and compute overshoot reduction ratio and L2 norms over S_eps.\n    Returns (R, E_unf, E_fil).\n    \"\"\"\n    # Grid\n    x = np.linspace(0.0, 2*np.pi, N, endpoint=False)\n    dx = 2*np.pi / N\n    # Piecewise constant f\n    f = np.where(x  np.pi, 1.0, 0.0)\n    # Derivatives\n    g_unf = spectral_derivative(f)\n    g_fil = filtered_spectral_derivative(f, p=p, alpha=alpha)\n    # Exterior set S_eps\n    dist = periodic_distance(x, np.pi, L=2*np.pi)\n    mask = dist >= eps\n    if not np.any(mask):\n        # Degenerate case: no points outside exclusion\n        return (0.0, 0.0, 0.0)\n    # Overshoot amplitudes\n    O_unf = float(np.max(np.abs(g_unf[mask])))\n    O_fil = float(np.max(np.abs(g_fil[mask])))\n    R = 0.0 if O_unf == 0.0 else (O_fil / O_unf)\n    # Discrete L2 norms over S_eps\n    E_unf = float(np.sqrt(np.sum(np.abs(g_unf[mask])**2) * dx))\n    E_fil = float(np.sqrt(np.sum(np.abs(g_fil[mask])**2) * dx))\n    return (R, E_unf, E_fil)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, p, alpha, epsilon)\n    test_cases = [\n        (32, 8, 36.0, 0.3),\n        (128, 8, 36.0, 0.2),\n        (256, 16, 36.0, 0.15),\n        (256, 4, 18.0, 0.15),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p, alpha, eps = case\n        R, E_unf, E_fil = compute_metrics(N, p, alpha, eps)\n        results.extend([R, E_unf, E_fil])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3417221"}]}