{"hands_on_practices": [{"introduction": "我们从一个基础但至关重要的练习开始：验证间断Galerkin (DG) 方法的离散守恒性。这个实践的核心是利用勒让德-高斯-洛巴托 (Legendre-Gauss-Lobatto, LGL) 节点所固有的分部求和 (Summation-By-Parts, SBP) 特性，证明对于线性平流方程，配合中心通量所构造的强形式DG残差能够精确地保持解的离散积分守恒。通过数值方式验证这一理论属性 ([@problem_id:3377756])，是构建和调试任何DG求解器的第一步，它能确保我们对基本算子（如微分和积分）的实现是正确可靠的。", "problem": "考虑一个周期性一维域上的线性平流初值问题，\n$$\nu_t + a\\,u_x = 0 \\quad \\text{on} \\quad x \\in [0,L],\n$$\n其边界条件为周期性，平流速度 $a$ 为一个无量纲常数。目标是构建一个不连续伽辽金（DG）验证测试，以表明当使用中心数值通量时，$u$ 的离散积分在 DG 残差作用下随时间保持不变。\n\n在节点配置设置下使用勒让德-高斯-洛巴托（LGL）节点进行计算。设每个单元是参考区间 $r \\in [-1,1]$ 到长度均匀的物理单元 $x \\in [x_{e}, x_{e+1}]$ 的仿射映射，其雅可比行列式为 $J_e = L_e/2$。在每个单元内，使用拉格朗日插值在 $N+1$ 个 LGL 节点 $\\{r_i\\}_{i=0}^N$ 上表示 $u(r,t)$，并使用 LGL 求积权重 $\\{w_i\\}_{i=0}^N$。令 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 为微分矩阵，其定义为在 LGL 节点处求值的拉格朗日基多项式的导数。\n\n将单元 $e$ 和节点 $i$ 上标量平流通量 $f(u) = a\\,u$ 的强形式 DG 残差定义为\n$$\nR_i^{(e)} = -\\frac{2}{L_e}\\sum_{j=0}^N D_{ij}\\,f\\!\\left(u_j^{(e)}\\right) \\;+\\; \\frac{2}{L_e\\,w_i}\n\\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f(u_N^{(e)})\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f(u_0^{(e)})\\big) \\Big),\n$$\n其中 $f^{*}_{\\text{left}}$ 和 $f^{*}_{\\text{right}}$ 分别是单元 $e$ 左右界面上的一致性数值通量，$\\delta_{i,k}$ 是克罗内克 delta。使用中心数值通量\n$$\nf^{*} = \\frac{1}{2}\\Big(f(u^{-}) + f(u^{+})\\Big) = \\frac{a}{2}\\Big(u^{-} + u^{+}\\Big),\n$$\n其中 $u^{-}$ 和 $u^{+}$ 表示界面处的内部和外部迹。通过从网格的另一端取值作为域边界处的外部迹来强制施加周期性。\n\n将 DG 场 $u$ 的离散积分（使用 LGL 求积）定义为\n$$\nI[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, u_i^{(e)}.\n$$\n您的任务是实现一个程序，该程序：\n1. 为任意多项式次数 $N \\geq 1$ 构建 LGL 节点、LGL 权重和拉格朗日微分矩阵 $D$。\n2. 在 $[0,L]$ 上构建一个包含 $E$ 个单元的周期性网格，单元大小均匀，为 $L_e = L/E$。\n3. 使用中心数值通量组装 DG 强形式残差 $R_i^{(e)}$，并将积分的离散时间导数计算为\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}.\n$$\n4. 通过检查 $\\left|\\frac{d}{dt}I[u]\\right|$ 是否在多个测试用例中低于预设容差来验证离散积分的不变性。\n\n所有量均被视为无量纲。此问题不涉及角度。使用以下测试套件，其中规定了网格、多项式阶数、域长度、平流速度和初始条件。对于每个用例，通过在 LGL 节点的物理坐标处计算给定的初始条件来构建节点值 $u_i^{(e)}$。\n\n测试套件：\n- 用例 1（平滑的“理想路径”）：$E=4$，$N=3$，$L=1$，$a=1$，$u(x)=\\sin(2\\pi x/L)$。\n- 用例 2（不连续剖面，负速度）：$E=3$，$N=2$，$L=2$，$a=-0.7$，$u(x)=\\begin{cases} 1  \\text{若 } x  L/2 \\\\ 0  \\text{其他} \\end{cases}$。", "solution": "该问题要求验证应用于一维线性平流方程 $u_t + a\\,u_x = 0$ 的节点式不连续伽辽金（DG）方法的守恒性质。具体来说，我们必须证明，当使用规定的强形式 DG 残差和中心数值通量时，解的空间离散积分 $I[u]$ 随时间保持不变。离散积分的时间导数由下式给出\n$$\n\\frac{d}{dt} I[u] \\;=\\; \\sum_{e=1}^{E} \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}\n$$\n我们将首先从解析上证明该量在机器精度范围内为零，然后实现一个数值测试，以对所提供的测试用例验证此结论。\n\n**积分不变性的理论验证**\n\n验证的核心在于对周期域中所有单元的残差贡献进行仔细求和。离散积分 $I[u]$ 的时间导数由每个单元内变化的总和给出。让我们分析单个单元 $e$ 的贡献。该贡献为 $Q^{(e)} = \\sum_{i=0}^{N} J_e\\, w_i\\, R_i^{(e)}$。\n\n代入给定的强形式残差 $R_i^{(e)}$ 的定义：\n$$\nR_i^{(e)} = -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}\\big(f^{*}_{\\text{right}} - f_N^{(e)}\\big) \\;-\\; \\delta_{i,0}\\big(f^{*}_{\\text{left}} - f_0^{(e)}\\big) \\Big),\n$$\n这里我们使用符号 $f_j^{(e)} = f(u_j^{(e)})$ 并已代入 $J_e = L_e/2$。$Q^{(e)}$ 的贡献变为：\n$$\nQ^{(e)} = \\sum_{i=0}^{N} J_e w_i \\left[ -\\frac{1}{J_e}\\sum_{j=0}^N D_{ij}\\,f_j^{(e)} \\;+\\; \\frac{1}{J_e\\,w_i} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big) \\right]\n$$\n雅可比行列式 $J_e$ 在两项中都消掉了：\n$$\nQ^{(e)} = -\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} \\;+\\; \\sum_{i=0}^{N} \\Big( \\delta_{i,N}(f^{*}_{\\text{right}} - f_N^{(e)}) - \\delta_{i,0}(f^{*}_{\\text{left}} - f_0^{(e)}) \\Big)\n$$\n第二项由于克罗内克 delta $\\delta_{i,k}$ 而简化，当 $i=k$ 时其值为 1，否则为 0。对 $i$ 的求和会收缩，只剩下 $i=0$ 和 $i=N$ 的项：\n$$\n\\sum_{i=0}^{N} \\Big( \\dots \\Big) = (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\n第一项涉及微分矩阵 $D$ 和求积权重 $w$。对于基于勒让德-高斯-洛巴托（LGL）节点和相应求积权重的微分矩阵，它们满足分部求和（SBP）性质。具体来说，对于任意代表阶数至多为 $N$ 的多项式的节点值向量 $\\mathbf{g} = [g_0, \\dots, g_N]^T$，其导数的离散积分是精确的：\n$$\n\\sum_{i=0}^{N} w_i (D\\mathbf{g})_i = \\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij} g_j = g_N - g_0\n$$\n将此 SBP 性质应用于我们的通量向量 $\\mathbf{f}^{(e)}$，由于 $f(u)=a\\,u$ 是线性的，它代表一个 $N$ 阶多项式，我们得到：\n$$\n\\sum_{i=0}^{N} w_i \\sum_{j=0}^{N} D_{ij}\\,f_j^{(e)} = f_N^{(e)} - f_0^{(e)}\n$$\n将这些结果代回 $Q^{(e)}$ 的表达式中：\n$$\nQ^{(e)} = -(f_N^{(e)} - f_0^{(e)}) + (f^{*}_{\\text{right}} - f_N^{(e)}) - (f^{*}_{\\text{left}} - f_0^{(e)})\n$$\n这可以重新排列为：\n$$\nQ^{(e)} = (f_0^{(e)} - f^{*}_{\\text{left}}) - (f_N^{(e)} - f^{*}_{\\text{right}})\n$$\n现在，我们引入中心数值通量的定义，$f^{*} = \\frac{1}{2}(f(u^{-}) + f(u^{+}))$。在单元 $e$ 的左界面处，内部迹是 $u^{-} = u_0^{(e)}$，外部迹 $u^{+}$ 是来自左边相邻单元右边界的解值，我们记为 $u_N^{(e-1)}$。因此，\n$$\nf^{*}_{\\text{left}} = f^{*}_{e-1/2} = \\frac{1}{2}\\Big(f(u_0^{(e)}) + f(u_N^{(e-1)})\\Big) = \\frac{1}{2}\\Big(f_0^{(e)} + f_N^{(e-1)}\\Big)\n$$\n类似地，在单元 $e$ 的右界面处，内部迹是 $u^{-} = u_N^{(e)}$，外部迹是 $u^{+} = u_0^{(e+1)}$。因此，\n$$\nf^{*}_{\\text{right}} = f^{*}_{e+1/2} = \\frac{1}{2}\\Big(f(u_N^{(e)}) + f(u_0^{(e+1)})\\Big) = \\frac{1}{2}\\Big(f_N^{(e)} + f_0^{(e+1)}\\Big)\n$$\n将这些代入 $Q^{(e)}$ 的表达式中：\n$$\nQ^{(e)} = \\left(f_0^{(e)} - \\frac{1}{2}(f_0^{(e)} + f_N^{(e-1)})\\right) - \\left(f_N^{(e)} - \\frac{1}{2}(f_N^{(e)} + f_0^{(e+1)})\\right)\n$$\n$$\nQ^{(e)} = \\frac{1}{2}\\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\frac{1}{2}\\Big(f_N^{(e)} - f_0^{(e+1)}\\Big)\n$$\n总变化率是所有单元的总和，$\\frac{d}{dt}I[u] = \\sum_{e=1}^{E} Q^{(e)}$。由于是周期域，单元索引按 $E$ 取模。\n$$\n\\frac{d}{dt}I[u] = \\frac{1}{2} \\sum_{e=1}^{E} \\left[ \\Big(f_0^{(e)} - f_N^{(e-1)}\\Big) - \\Big(f_N^{(e)} - f_0^{(e+1)}\\Big) \\right]\n$$\n让我们检查这个求和中的各项。项 $\\frac{1}{2}(f_0^{(e)} - f_N^{(e-1)})$ 与单元 $e-1$ 和 $e$ 之间的界面相关。项 $-\\frac{1}{2}(f_N^{(e)} - f_0^{(e+1)})$ 与单元 $e$ 和 $e+1$ 之间的界面相关。当我们对所有的 $e$ 求和时，每个界面都被访问两次。对于单元 $k$ 和 $k+1$ 之间的界面，我们从 $Q^{(k)}$ 和 $Q^{(k+1)}$ 得到贡献：\n- 来自 $Q^{(k)}$（作为右界面）：$-\\frac{1}{2}(f_N^{(k)} - f_0^{(k+1)})$\n- 来自 $Q^{(k+1)}$（作为左界面）：$+\\frac{1}{2}(f_0^{(k+1)} - f_N^{(k)})$\n这两项大小相等，方向相反，总和为零。这种抵消发生在域内的每个界面上。由于周期性，单元 $E$ 和单元 1 之间的界面也表现出这种抵消。因此，整个和是一个求值为精确零的伸缩和（裂项相消求和）。\n\n这证明了对于给定的使用中心通量的 DG 公式，无论初始数据如何，离散积分都是守恒的。数值实现应证实这一点，任何非零结果都可归因于浮点运算误差。\n\n**算法实现**\n\n数值验证过程如下：\n1. **LGL 工具**：对于每个所需的多项式次数 $N$，我们生成 $N+1$ 个勒让德-高斯-洛巴托（LGL）节点 $\\{r_i\\}$、求积权重 $\\{w_i\\}$ 和微分矩阵 $D$。\n    - 节点 $r_i$ 是 $(1-r^2)L'_N(r)$ 的根，其中 $L_N$ 是 $N$ 阶勒让德多项式。外部节点总是 $r_0=-1$ 和 $r_N=1$。内部节点是 $L'_N(r)$ 的根。\n    - 权重由公式 $w_i = \\frac{2}{N(N+1)L_N(r_i)^2}$ 给出。\n    - 微分矩阵的非对角线项为 $D_{ij} = \\frac{L_N(r_i)}{L_N(r_j)(r_i-r_j)}$（当 $i \\neq j$ 时）。对角线项为 $D_{00} = -\\frac{N(N+1)}{4}$，$D_{NN} = \\frac{N(N+1)}{4}$，以及 $D_{ii}=0$（当 $i \\in \\{1,\\dots,N-1\\}$ 时）。\n2. **网格和状态初始化**：在 $[0, L]$ 上创建一个包含 $E$ 个单元的均匀周期性网格。所有 LGL 节点的物理坐标通过仿射映射 $x_i^{(e)} = x_e + (r_i+1)J_e$ 确定，其中 $J_e = L_e/2 = L/(2E)$。通过在这些物理坐标上计算指定的初始条件函数来初始化节点解值 $u_i^{(e)}$。对于随机情况，使用具有固定种子的伪随机数生成器来填充这些值。\n3. **残差和积分评估**：程序遍历每个单元 $e=1, \\dots, E$，以计算其对 $\\frac{d}{dt}I[u]$ 的贡献。\n    - 对于每个单元 $e$，使用节点解向量 $\\mathbf{u}^{(e)}$ 形成通量向量 $\\mathbf{f}^{(e)} = a\\,\\mathbf{u}^{(e)}$。\n    - 确定内部迹 $u_0^{(e)}$ 和 $u_N^{(e)}$。外部迹值 $u_N^{(e-1)}$ 和 $u_0^{(e+1)}$ 从相邻单元中检索，同时遵守网格的周期性。\n    - 使用中心通量公式计算左、右数值通量 $f^{*}_{\\text{left}}$ 和 $f^{*}_{\\text{right}}$。\n    - 根据所提供的方程组装强形式残差向量 $\\mathbf{R}^{(e)}$。\n    - 计算该单元对积分时间导数的贡献 $Q^{(e)} = J_e \\mathbf{w}^T \\mathbf{R}^{(e)}$，并将其加到一个运行总和中。\n4. **验证**：在对所有单元的贡献求和后，将总和 $\\frac{d}{dt}I[u]$ 的绝对值与指定的容差 $\\varepsilon = 5 \\times 10^{-12}$ 进行比较。每个测试用例的结果是一个布尔值，指示计算值是否在此容差范围内。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_lgl_basis(N):\n    \"\"\"\n    Computes LGL nodes, weights, and differentiation matrix for a given degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0]), np.array([[0.0]])\n    \n    # Nodes are roots of (1-x^2) * L_N'(x)\n    # Interior nodes are roots of L_N'(x)\n    p_N = legendre(N)\n    p_N_prime_roots = p_N.deriv().roots\n    nodes = np.concatenate(([-1.0], np.sort(p_N_prime_roots), [1.0]))\n\n    # Weights\n    weights = 2.0 / (N * (N + 1) * (p_N(nodes)**2))\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_N(nodes[i]) / (p_N(nodes[j]) * (nodes[i] - nodes[j]))\n    \n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    \n    return nodes, weights, D\n\n# Cache for LGL basis to avoid recomputation\nLGL_CACHE = {}\n\ndef get_cached_lgl_basis(N):\n    if N not in LGL_CACHE:\n        LGL_CACHE[N] = get_lgl_basis(N)\n    return LGL_CACHE[N]\n\ndef calculate_dIdt(E, N, L, a, u_func, is_random=False, rng=None):\n    \"\"\"\n    Calculates the discrete time derivative of the integral I[u] for a given test case.\n    \"\"\"\n    # 1. Construct LGL basis\n    r, w, D = get_cached_lgl_basis(N)\n    \n    # 2. Build periodic mesh and initialize solution\n    Le = L / E\n    Je = Le / 2.0\n    \n    # Element boundaries\n    x_bounds = np.linspace(0, L, E + 1)\n    \n    # Store all nodal values for easy access to neighbors\n    u_all = np.zeros((E, N + 1))\n    \n    if is_random:\n        u_all = rng.random((E, N + 1))\n    else:\n        for e in range(E):\n            x_e_start = x_bounds[e]\n            # Map reference nodes to physical nodes for this element\n            x_nodes_e = x_e_start + (r + 1) * Je\n            u_all[e, :] = u_func(x_nodes_e, L)\n\n    # 3. Assemble residual and evaluate discrete time derivative of the integral\n    dIdt = 0.0\n    \n    for e in range(E):\n        u_e = u_all[e, :]\n        f_e = a * u_e\n        \n        # Volume term contribution to the residual\n        R_vol = -(1.0 / Je) * (D @ f_e)\n        \n        # Surface term contribution (flux corrections)\n        \n        # Left interface of element e\n        u_minus_left = u_e[0]\n        # Find left neighbor (periodic)\n        e_left = (e - 1 + E) % E\n        u_plus_left = u_all[e_left, N]\n        f_star_left = (a / 2.0) * (u_minus_left + u_plus_left)\n        \n        # Right interface of element e\n        u_minus_right = u_e[N]\n        # Find right neighbor (periodic)\n        e_right = (e + 1) % E\n        u_plus_right = u_all[e_right, 0]\n        f_star_right = (a / 2.0) * (u_minus_right + u_plus_right)\n        \n        # Complete residual R for element e\n        R_e = np.copy(R_vol)\n        R_e[N] += (1.0 / (Je * w[N])) * (f_star_right - f_e[N])\n        R_e[0] -= (1.0 / (Je * w[0])) * (f_star_left - f_e[0])\n        \n        # Add element's contribution to dI/dt\n        # This is sum_{i=0 to N} J_e * w_i * R_i^(e)\n        dIdt += Je * np.dot(w, R_e)\n        \n    return dIdt\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (smooth “happy path”)\n        {'E': 4, 'N': 3, 'L': 1.0, 'a': 1.0, 'u_func': lambda x, L: np.sin(2 * np.pi * x / L)},\n        # Case 2 (discontinuous profile, negative speed)\n        {'E': 3, 'N': 2, 'L': 2.0, 'a': -0.7, 'u_func': lambda x, L: np.where(x  L / 2.0, 1.0, 0.0)},\n        # Case 3 (single element, higher order, random nodal values)\n        {'E': 1, 'N': 5, 'L': 1.0, 'a': 0.3, 'u_func': None, 'is_random': True, 'seed': 42},\n        # Case 4 (many elements, lowest order)\n        {'E': 8, 'N': 1, 'L': 1.0, 'a': 3.0, 'u_func': None, 'is_random': True, 'seed': 123},\n         # Case 5 (smooth with different domain length)\n        {'E': 5, 'N': 4, 'L': np.pi, 'a': 2.0, 'u_func': lambda x, L: np.cos(x)},\n    ]\n    \n    tolerance = 5e-12\n    results = []\n\n    for case in test_cases:\n        rng = None\n        if case.get('is_random', False):\n            rng = np.random.default_rng(seed=case['seed'])\n            \n        dIdt_val = calculate_dIdt(\n            E=case['E'], \n            N=case['N'], \n            L=case['L'], \n            a=case['a'], \n            u_func=case['u_func'],\n            is_random=case.get('is_random', False),\n            rng=rng\n        )\n        \n        results.append(abs(dIdt_val) = tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3377756"}, {"introduction": "在掌握了线性问题之后，我们将注意力转向更普遍的非线性问题，这时会遇到新的挑战。本练习通过一个精心设计的具有无散通量的二维守恒律，来揭示单元界面积分中求积阶数的重要性。即使连续通量的散度为零，如果不使用足够高阶的求积规则来精确计算界面上的通量积分，离散守恒性也会被破坏 ([@problem_id:3377711])。这个实践旨在训练一项关键技能：分析通量函数中各项的多项式次数，并据此选择合适的求积阶数，这对于在复杂的物理模拟中避免引入虚假的源或汇至关重要。", "problem": "考虑一个以散度形式表示的二维守恒律，其通过非连续伽辽金(DG)方法进行离散。设空间域为单位正方形$\\Omega = [0,1]\\times[0,1]$，其被划分为一个笛卡尔网格，在$x$方向有$N_x$个矩形单元，在$y$方向有$N_y$个矩形单元。每个单元$K$都带有一个总次数为$p$的局部多项式逼近空间，记作$P_p$。设精确状态为定义在$\\Omega$上的一个总次数为$p$的全局光滑多项式解$u \\in P_p$。定义非线性通量场\n$$\n\\mathbf{F}(u,\\nabla u) = \\left(\\Psi'(u)\\,\\partial_{y}u,\\; -\\,\\Psi'(u)\\,\\partial_{x}u\\right),\n$$\n其中 $\\Psi(u) = u^{m}$，整数$m \\ge 2$，因此$\\Psi'(u) = m\\,u^{m-1}$。根据混合偏导数的相等性，该通量的连续散度满足\n$$\n\\nabla\\cdot\\mathbf{F}(u,\\nabla u) = \\partial_x\\left(\\Psi'(u)\\,\\partial_y u\\right) + \\partial_y\\left(-\\,\\Psi'(u)\\,\\partial_x u\\right) = \\partial_x\\partial_y \\Psi(u) - \\partial_y\\partial_x \\Psi(u) = 0.\n$$\n因此，对于此通量，$u$的任何单元平均值的精确连续时间导数均为零。\n\n在守恒律的半离散DG格式中，对于常数测试函数$\\phi \\equiv 1$，单元$K$的残差简化为纯粹的边贡献，\n$$\nR_K = \\sum_{f \\subset \\partial K} \\int_{f} \\widehat{\\mathbf{F}}(u,\\nabla u)\\cdot \\mathbf{n}_K \\,\\mathrm{d}s,\n$$\n其中$\\widehat{\\mathbf{F}}$是一个相容的数值通量，$\\mathbf{n}_K$是$K$每个边上的外向单位法向量。对于一个在内部边上没有跳跃的光滑多项式$u$和中心通量，$\\widehat{\\mathbf{F}}$在所有边上都等于物理通量$\\mathbf{F}$。由于$\\nabla\\cdot\\mathbf{F}=0$，对于所有$K$，$R_K$的精确连续值都为零。然而，在实践中，边积分由阶为$q_f$的一维高斯求积近似，并且被积函数$\\mathbf{F}\\cdot \\mathbf{n}_K$在每个直边上是一个次数为\n$$\nd = (m-1)\\,p + (p-1),\n$$\n的多项式。一个$q_f$阶的高斯-勒让德求积可以精确地积分次数最高为$2q_f - 1$的任何多项式。因此，除非$2q_f - 1 \\ge d$，DG残差$R_K$将会因积分不足而产生误差，并且计算出的单元平均守恒性将被破坏，即使真实的连续残差为零。\n\n任务：实现一个程序，对于给定的通量$\\mathbf{F}$和一个多项式$u \\in P_p$，使用阶为$q_f$的边高斯求积来组装带有中心通量的DG残差$R_K$。通过计算绝对全局守恒缺陷来量化守恒误差\n$$\nE(q_f) = \\left| \\sum_{K} R_K \\right|,\n$$\n针对几个测试用例。函数$u(x,y)$被定义为一个总次数为$p$的固定多项式，其系数是确定性的：\n$$\nu(x,y) = \\sum_{a=0}^{p}\\sum_{b=0}^{p-a} c_{a,b}\\, x^{a} y^{b}, \\quad c_{a,b} = \\frac{1}{a+b+1}.\n$$\n在通量中使用$\\partial_x u$和$\\partial_y u$的精确解析偏导数。网格是均匀的，单元尺寸为$h_x = 1/N_x$和$h_y = 1/N_y$，边上的外向法向量与笛卡尔坐标轴对齐。边积分必须通过沿相应的一维边段使用阶为$q_f$的高斯-勒让德求积来计算。不需要进行体积求积，因为对于此通量，测试函数$\\phi \\equiv 1$消除了体积项。\n\n定义以下参数元组$(p,m,N_x,N_y,q_f)$的测试套件：\n- 测试1（严重积分不足）：$(3,3,4,4,1)$\n- 测试2（接近阈值的积分不足）：$(3,3,4,4,4)$\n- 测试3（阈值阶）：$(3,3,4,4,5)$\n- 测试4（过积分）：$(3,3,4,4,7)$\n- 测试5（更简单的多项式，过积分）：$(2,2,3,3,3)$\n\n对于每个测试，将$E(q_f)$计算为浮点数。程序应生成单行输出，其中包含所有五个结果，格式为逗号分隔的列表并用方括号括起来，顺序与上述测试一致，例如$\\texttt{[r_1,r_2,r_3,r_4,r_5]}$，其中每个$r_i$是测试$i$的$E(q_f)$值。\n\n本问题不涉及物理单位。所有出现的角度（若有）均应以弧度为单位。最终输出为浮点数。\n\n您的实现必须是一个使用现代编程语言编写的、完整的、可运行的程序，并且不得需要任何外部输入。它必须基于指定的多项式$u$数值地组装边贡献，使用所选的边求积阶计算DG残差，并以确切指定的输出格式报告该测试套件的守恒缺陷。", "solution": "用户提供了有效的问题陈述。\n\n**问题建模与分析**\n\n该问题要求计算一个特定的二维守恒律的非连续伽辽金(DG)离散化的全局守恒缺陷。该守恒律由$\\partial_t u + \\nabla \\cdot \\mathbf{F}(u, \\nabla u) = 0$给出，其中通量函数为$\\mathbf{F} = (\\Psi'(u)\\,\\partial_{y}u, -\\Psi'(u)\\,\\partial_{x}u)$，且$\\Psi(u) = u^m$。该通量的一个关键特性是其散度恒为零，即$\\nabla \\cdot \\mathbf{F} = 0$，对于任何足够光滑的解$u$均成立。这是混合偏导数相等的结果：\n$$\n\\nabla \\cdot \\mathbf{F} = \\partial_x(\\Psi'(u)\\,\\partial_y u) + \\partial_y(-\\Psi'(u)\\,\\partial_x u) = \\partial_x\\partial_y\\Psi(u) - \\partial_y\\partial_x\\Psi(u) = 0.\n$$\n\n单元$K$的半离散DG格式是通过将偏微分方程乘以一个测试函数$\\phi \\in P_p$，在$K$上积分，并应用散度定理得到的：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_K u_h \\phi \\, \\mathrm{d}V = \\int_K \\mathbf{F}(u_h, \\nabla u_h) \\cdot \\nabla \\phi \\, \\mathrm{d}V - \\int_{\\partial K} \\widehat{\\mathbf{F}}(u_h, \\nabla u_h) \\cdot \\mathbf{n}_K \\phi \\, \\mathrm{d}s.\n$$\n此处，$u_h$是$u$的多项式逼近，$\\widehat{\\mathbf{F}}$是数值通量，$\\mathbf{n}_K$是边界$\\partial K$的外向单位法向量。\n\n问题指定使用常数测试函数$\\phi \\equiv 1$。对于此选择，$\\nabla \\phi = \\mathbf{0}$，这消除了体积积分项。单元平均值的残差$R_K$简化为边积分之和：\n$$\nR_K = \\int_{\\partial K} \\widehat{\\mathbf{F}}(u_h, \\nabla u_h) \\cdot \\mathbf{n}_K \\, \\mathrm{d}s = \\sum_{f \\subset \\partial K} \\int_{f} \\widehat{\\mathbf{F}} \\cdot \\mathbf{n}_K \\, \\mathrm{d}s.\n$$\n问题陈述精确解$u$是一个总次数为$p$的全局光滑多项式。DG逼近$u_h$被取为这个精确解。因为$u_h$是光滑的，单元界面上没有跳跃。问题指定了中心数值通量，对于连续解，该通量简化为物理通量，即$\\widehat{\\mathbf{F}} = \\mathbf{F}$。\n\n任务是计算全局守恒缺陷$E(q_f) = |\\sum_K R_K|$。关键的是，网格中所有单元$K$的残差之和呈现出伸缩求和的特性。对于由两个单元$K_L$和$K_R$共享的任何内部边$f$，我们有$\\mathbf{n}_{K_L} = -\\mathbf{n}_{K_R}$。该边对总和的贡献是：\n$$\n\\int_f \\mathbf{F} \\cdot \\mathbf{n}_{K_L} \\, \\mathrm{d}s + \\int_f \\mathbf{F} \\cdot \\mathbf{n}_{K_R} \\, \\mathrm{d}s = \\int_f \\mathbf{F} \\cdot (\\mathbf{n}_{K_L} - \\mathbf{n}_{K_L}) \\, \\mathrm{d}s = 0.\n$$\n这种抵消是完美的，即使积分由数值求积近似也是如此，因为相同的求积规则应用于大小相等、方向相反的被积函数。因此，所有内部边的贡献都抵消了，全局总和简化为整个域$\\Omega$边界上的边积分之和：\n$$\n\\sum_K R_K = \\sum_{f \\subset \\partial\\Omega} \\int_f \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s \\equiv \\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s.\n$$\n这极大地简化了计算，因为我们只需要考虑单位正方形$[0,1] \\times [0,1]$的四个边界段。网格参数$N_x$和$N_y$与最终值无关，因为它们只影响被抵消的内部边的数量。\n\n由于散度定理和通量的无散度性质，连续边界积分也为零：$\\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, \\mathrm{d}s = \\iint_\\Omega \\nabla \\cdot \\mathbf{F} \\, \\mathrm{d}V = \\iint_\\Omega 0 \\, \\mathrm{d}V = 0$。\n只有当用于近似边界积分的数值求积对被积函数不是精确时，守恒缺陷$E(q_f)$才会非零。\n\n任何边上的被积函数是$\\mathbf{F} = (m u^{m-1} \\partial_y u, -m u^{m-1} \\partial_x u)$的一个分量。由于$u$是总次数为$p$的多项式，其导数$\\partial_x u, \\partial_y u$是总次数为$p-1$的多项式。项$u^{m-1}$是总次数为$(m-1)p$的多项式。因此，被积函数是一个次数为$d = (m-1)p + (p-1)$的多项式。具有$q_f$个点的高斯-勒让德求积规则对次数最高为$2q_f - 1$的多项式是精确的。因此，如果$2q_f - 1 \\ge d$，数值求积将是精确的，计算出的边界积分将为零（在机器精度范围内），并且$E(q_f)$将为零。如果$2q_f - 1  d$，则会发生求积误差，导致非零的$E(q_f)$。\n\n**算法**\n\n1.  **定义测试用例**：使用提供的五个参数元组$(p,m,N_x,N_y,q_f)$。\n2.  **遍历测试用例**：对于每个用例：\n    a. **准备多项式**：构建多项式$u(x,y) = \\sum_{a=0}^{p}\\sum_{b=0}^{p-a} \\frac{1}{a+b+1} x^a y^b$的表示，以及用于评估它及其偏导数$\\partial_x u$和$\\partial_y u$的函数。\n    b. **获取求积规则**：获取阶为$q_f$的高斯-勒让德点$\\xi_k$和权重$w_k$。这些点和权重定义在区间$[-1,1]$上。\n    c. **初始化总积分**：将一个运行总和`total_integral`设置为$0$。\n    d. **计算边界积分**：对单位正方形的四个边界段的贡献求和。对于区间$[a,b]$，求积点映射为$z_k = a + \\frac{b-a}{2}(1+\\xi_k)$，积分近似为$\\frac{b-a}{2}\\sum_k w_k f(z_k)$。在这里，每个边界段的长度为$1$，因此因子是$0.5$。\n        i. **底部边界**（$y=0$, $x \\in [0,1]$, $\\mathbf{n}=(0,-1)$）：将$\\int_0^1 (-F_y) \\, \\mathrm{d}x = \\int_0^1 m u^{m-1} \\partial_x u \\, \\mathrm{d}x$加到`total_integral`。\n        ii. **右侧边界**（$x=1$, $y \\in [0,1]$, $\\mathbf{n}=(1,0)$）：将$\\int_0^1 F_x \\, \\mathrm{d}y = \\int_0^1 m u^{m-1} \\partial_y u \\, \\mathrm{d}y$加到`total_integral`。\n        iii. **顶部边界**（$y=1$, $x \\in [0,1]$, $\\mathbf{n}=(0,1)$）：将$\\int_0^1 F_y \\, \\mathrm{d}x = \\int_0^1 -m u^{m-1} \\partial_x u \\, \\mathrm{d}x$加到`total_integral`。\n        iv. **左侧边界**（$x=0$, $y \\in [0,1]$, $\\mathbf{n}=(-1,0)$）：将$\\int_0^1 (-F_x) \\, \\mathrm{d}y = \\int_0^1 -m u^{m-1} \\partial_y u \\, \\mathrm{d}y$加到`total_integral`。\n    e. **计算缺陷**：当前测试用例的缺陷是$|\\text{total\\_integral}|$。\n3.  **存储并格式化结果**为方括号内的逗号分隔列表。\n\n此方法通过利用DG格式的数学特性，高效地正确实现了所需的计算。", "answer": "```python\nimport numpy as np\n\ndef generate_poly_coeffs(p):\n    \"\"\"\n    Generates coefficients for the polynomial u(x,y) up to total degree p.\n    u(x,y) = sum_{a=0 to p} sum_{b=0 to p-a} c_ab * x^a * y^b\n    c_ab = 1 / (a + b + 1)\n    \n    Returns a list of dictionaries, where each dict represents a term {'a': a, 'b': b, 'c': c_ab}.\n    \"\"\"\n    coeffs = []\n    for a in range(p + 1):\n        for b in range(p - a + 1):\n            c_ab = 1.0 / (a + b + 1)\n            coeffs.append({'a': a, 'b': b, 'c': c_ab})\n    return coeffs\n\ndef evaluate_poly_and_grads(x, y, coeffs):\n    \"\"\"\n    Evaluates the polynomial u and its partial derivatives du/dx, du/dy\n    at a point (x, y) given the coefficient representation.\n    \"\"\"\n    u_val = 0.0\n    du_dx = 0.0\n    du_dy = 0.0\n    for term in coeffs:\n        a, b, c = term['a'], term['b'], term['c']\n        \n        # u(x,y) term. Note: x**0 is 1, even if x is 0.\n        u_val += c * (x**a) * (y**b)\n        \n        # du/dx term\n        if a > 0:\n            du_dx += c * a * (x**(a - 1)) * (y**b)\n        \n        # du/dy term\n        if b > 0:\n            du_dy += c * b * (x**a) * (y**(b - 1))\n            \n    return u_val, du_dx, du_dy\n\ndef compute_conservation_defect(p, m, q_f):\n    \"\"\"\n    Computes the global conservation defect E(q_f) for a given set of parameters.\n    The calculation simplifies to the sum of flux integrals over the domain boundary.\n    \"\"\"\n    poly_coeffs = generate_poly_coeffs(p)\n    xi, w = np.polynomial.legendre.leggauss(q_f)\n    \n    # Quadrature points and weights mapped to the interval [0, 1]\n    # The Jacobian of the transformation from [-1, 1] to [0, 1] is 0.5.\n    quad_pts = 0.5 * (1.0 + xi)\n    quad_w = 0.5 * w\n    \n    total_integral = 0.0\n    \n    # 1. Bottom boundary: y=0, n=(0,-1). Integral of -F_y = m*u^(m-1)*du_dx\n    for x_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(x_q, 0.0, poly_coeffs)\n        integrand = m * (u**(m - 1)) * du_dx\n        total_integral += w_q * integrand\n        \n    # 2. Right boundary: x=1, n=(1,0). Integral of F_x = m*u^(m-1)*du_dy\n    for y_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(1.0, y_q, poly_coeffs)\n        integrand = m * (u**(m - 1)) * du_dy\n        total_integral += w_q * integrand\n        \n    # 3. Top boundary: y=1, n=(0,1). Integral of F_y = -m*u^(m-1)*du_dx\n    for x_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(x_q, 1.0, poly_coeffs)\n        integrand = -m * (u**(m - 1)) * du_dx\n        total_integral += w_q * integrand\n        \n    # 4. Left boundary: x=0, n=(-1,0). Integral of -F_x = -m*u^(m-1)*du_dy\n    for y_q, w_q in zip(quad_pts, quad_w):\n        u, du_dx, du_dy = evaluate_poly_and_grads(0.0, y_q, poly_coeffs)\n        integrand = -m * (u**(m - 1)) * du_dy\n        total_integral += w_q * integrand\n        \n    return abs(total_integral)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (p, m, N_x, N_y, q_f)\n        (3, 3, 4, 4, 1),  # Test 1\n        (3, 3, 4, 4, 4),  # Test 2\n        (3, 3, 4, 4, 5),  # Test 3\n        (3, 3, 4, 4, 7),  # Test 4\n        (2, 2, 3, 3, 3),  # Test 5\n    ]\n    \n    results = []\n    for case in test_cases:\n        p, m, _, _, q_f = case\n        # N_x and N_y are not needed due to the telescoping sum of residuals.\n        defect = compute_conservation_defect(p, m, q_f)\n        results.append(defect)\n        \n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "3377711"}, {"introduction": "在确保了算子构建的正确性后，我们最后来关注其计算效率，这是现代科学计算的一个核心议题。高阶DG方法的一大优势在于其计算效率，尤其是在张量积单元上。本练习将介绍“和因子分解” (sum-factorization) 这一关键技术，它能将高维算子的应用分解为一系列高效的一维操作 ([@problem_id:3377759])。通过一个简化的性能模型，我们将量化分析体积积分（通常是计算密集型）与界面积分（通常是访存密集型）之间的计算成本权衡，这为理解和优化现代DG代码的性能提供了深刻见解。", "problem": "考虑一个在间断 Galerkin (DG) 方法中的标量平流问题，其中 DG 代表 Discontinuous Galerkin（间断 Galerkin），该问题定义在参考超立方体 $\\Omega = [-1,1]^d$ 上。设 $\\boldsymbol{a} \\in \\mathbb{R}^d$ 为一个常数平流速度。使用张量积多项式基 $P_p$，其节点由一维的 Legendre-Gauss-Lobatto 节点给出，并通过张量化扩展到 $d$ 维。每个轴上的节点数为 $n = p+1$，每个单元的总自由度为 $n^d$。\n\n从标准的强形式平流体积项（即通量 $f(u) = \\boldsymbol{a}\\,u$ 的散度）出发，节点上的体积残差在参考坐标系下简化为计算 $\\boldsymbol{a}\\cdot\\nabla u$。使用和因子分解法 (sum-factorization) 为体积残差构建一个无矩阵的张量积算子。具体而言：\n\n- 首先找到 $n$ 个 Legendre-Gauss-Lobatto 节点 $\\{x_i\\}_{i=0}^{p}$（端点为 $-1$ 和 $1$，以及 $P_p'(x)$ 的 $p-1$ 个内部根），然后通过重心权重 (barycentric weights) 构建一维 Lagrange 插值微分矩阵 $D \\in \\mathbb{R}^{n \\times n}$。对于具有重心权重 $\\{w_i\\}$ 的不同节点 $\\{x_i\\}$，定义 $D_{ij} = \\dfrac{w_j}{w_i (x_i - x_j)}$（当 $i \\neq j$ 时）以及 $D_{ii} = -\\sum_{j\\neq i} D_{ij}$。\n- 使用和因子分解法，通过沿每个轴连续进行 $D$ 的一维收缩来计算 $\\nabla u$。对于每个轴 $k \\in \\{1,\\dots,d\\}$，将 $D$ 沿第 $k$ 轴应用于张量 $u \\in \\mathbb{R}^{n\\times \\cdots \\times n}$，以获得节点上的分量 $\\partial_{\\xi_k} u$，然后组合这些分量形成体积残差 $r_{\\text{vol}} = \\boldsymbol{a}\\cdot\\nabla u$。\n- 在以下假设下，使用第一性原理计数 (first-principles counts) 对每个单元的算术功和内存流量进行建模：\n  1. 沿一个轴的每次矩阵-向量收缩，每行需要 $2 n^2$ 次浮点运算（flops）（每个条目计为一次乘法和一次加法），每个轴有 $n^{d-1}$ 条这样的行。因此，计算所有梯度分量需要 $2 d n^{d+1}$ 次 flops。\n  2. 在所有节点上形成 $\\boldsymbol{a}\\cdot\\nabla u$ 需要额外的 $d n^d$ 次乘法和 $(d-1) n^d$ 次加法，总计 $2 d n^d$ 次 flops。\n  3. 读取输入场 $u$ 和写入输出残差 $r_{\\text{vol}}$ 是内存流量的主要部分，对于体积核，每个单元产生 $16 n^d$ 字节的流量。\n  4. 对于在轴对齐面 (axis-aligned faces) 上使用常数 $\\boldsymbol{a}$ 和迎风数值通量 (upwind numerical flux) 的面残差评估，假设每个节点组合内部和相邻迹线 (traces) 的成本为 $c_{\\text{flux}}$ flops。由于每个单元有 $2d$ 个面，每个面有 $n^{d-1}$ 个节点，因此面的 flops 为 $2 d n^{d-1} c_{\\text{flux}}$，每个单元的内存流量（读取内部值和相邻值，写入内部残差）为 $2 d n^{d-1} \\cdot 24$ 字节。\n- 使用 roofline 模型来确定体积核和面核每个单元所需的时间。设 $F$ 为以每秒千兆浮点运算次数 (GF/s) 为单位的峰值浮点运算速率， $B$ 为以每秒千兆字节 (GB/s) 为单位的峰值内存带宽。通过乘以 $10^9$ 将其转换为每秒浮点运算次数和每秒字节数。每个单元的时间估计为\n$$\nt_{\\text{vol}} = \\max\\left(\\frac{\\text{flops}_{\\text{vol}}}{F \\cdot 10^9}, \\frac{\\text{bytes}_{\\text{vol}}}{B \\cdot 10^9}\\right), \\quad\nt_{\\text{face}} = \\max\\left(\\frac{\\text{flops}_{\\text{face}}}{F \\cdot 10^9}, \\frac{\\text{bytes}_{\\text{face}}}{B \\cdot 10^9}\\right).\n$$\n\n你的程序必须：\n- 从第一性原理实现 $D$ 的构建，并将和因子分解的体积算子应用于随机场 $u$ 以生成 $r_{\\text{vol}}$，用于内部验证。\n- 使用上述模型，在 $c_{\\text{flux}} = 8$ 的情况下，为每个测试用例计算比率 $\\rho = t_{\\text{face}} / t_{\\text{vol}}$。比率 $\\rho > 1$ 意味着面残差评估在时间上主导体积积分，而 $\\rho  1$ 意味着体积积分占主导地位。\n\n测试套件：\n- 情况 1：$d=2$, $p=1$, $\\boldsymbol{a} = (1,1)$, $F=100$ GF/s, $B=50$ GB/s。\n- 情况 2：$d=3$, $p=5$, $\\boldsymbol{a} = (1,1,1)$, $F=100$ GF/s, $B=50$ GB/s。\n- 情况 3：$d=3$, $p=5$, $\\boldsymbol{a} = (1,1,1)$, $F=100$ GF/s, $B=10$ GB/s。\n- 情况 4：$d=2$, $p=7$, $\\boldsymbol{a} = (1,1)$, $F=100$ GF/s, $B=200$ GB/s。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含案例 1 到 4 的四个比率 $\\rho$，格式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”）。不应打印任何其他文本。", "solution": "该问题要求在间断 Galerkin (DG) 方法中，对一个标量平流问题的体积和面积分核的计算性能进行分析。性能将使用一个简单的 roofline 模型进行评估，该模型根据浮点运算 (flops) 和内存流量（字节）之间的平衡来估计执行时间。主要输出是比率 $\\rho = t_{\\text{face}} / t_{\\text{vol}}$，其中 $t_{\\text{face}}$ 和 $t_{\\text{vol}}$ 分别是面核和体积核的估计时间。\n\n问题被设定在 $d$ 维参考超立方体 $\\Omega = [-1,1]^d$ 上，使用 $p$ 次多项式的张量积基。节点是 $n=p+1$ 个一维 Legendre-Gauss-Lobatto (LGL) 节点的张量积。\n\n解决方案分为两个主要部分：首先，概述体积残差算子的数值构造；其次，将所提供的性能模型应用于测试用例。\n\n**1. 体积残差算子：和因子分解法**\n\n对于具有恒定速度 $\\boldsymbol{a}$ 的平流方程 $\\nabla \\cdot (\\boldsymbol{a} u) = 0$，其体积残差为 $r_{\\text{vol}} = \\boldsymbol{a} \\cdot \\nabla u$。核心任务是计算一个单元的 $n^d$ 个节点上解场 $u$ 的梯度 $\\nabla u$。这可以通过一种称为和因子分解法 (sum-factorization) 的技术高效实现。\n\n梯度 $\\nabla u$ 有 $d$ 个分量，$\\nabla u = (\\partial_{\\xi_1} u, \\dots, \\partial_{\\xi_d} u)$。每个分量 $\\partial_{\\xi_k} u$ 都是通过仅沿第 $k$ 轴对 $u$ 进行微分来计算的。由于节点和基的张量积结构，这种微分可以作为一系列一维微分来执行。\n\n一维微分由与 $n \\times n$ 微分矩阵 $D$ 的矩阵-向量乘法表示。要构造 $D$，我们首先需要区间 $[-1,1]$ 上的 $n=p+1$ 个 LGL 节点 $\\{x_i\\}_{i=0}^p$。这些节点是端点 $x_0 = -1$，$x_p = 1$，以及 $P_p'(x)$ 的 $p-1$ 个根，其中 $P_p(x)$ 是 $p$ 次 Legendre 多项式。$P_p'(x)$ 的根等价于 Jacobi 多项式 $P_{p-1}^{(1,1)}(x)$ 的根。\n\n根据问题描述，微分矩阵 $D$ 是使用重心权重形成的。对于一组不同的节点 $\\{x_i\\}$，重心权重可以定义为 $w_j = \\left(\\prod_{k \\neq j} (x_j - x_k)\\right)^{-1}$。然后微分矩阵的元素由以下公式给出：\n$$\nD_{ij} = \\frac{w_j}{w_i (x_i - x_j)} \\quad \\text{for } i \\neq j\n$$\n对角线元素由常数的导数必须为零的性质确定，这意味着 $D$ 的行和必须为零：\n$$\nD_{ii} = -\\sum_{j=0, j \\neq i}^{p} D_{ij}\n$$\n这种构造在数值上等同于其他用于基于 LGL 的微分矩阵的标准公式，例如当 $i \\neq j$ 时，$D_{ij} = \\frac{P_p(x_i)}{P_p(x_j)(x_i-x_j)}$。\n\n在建立矩阵 $D$ 后，通过将 $D$ 沿表示节点解值的 $d$ 维张量 $u$ 的第 $k$ 轴应用，来计算梯度的第 $k$ 个分量 $\\partial_{\\xi_k} u$。此操作是一个张量收缩。对于每个轴 $k \\in \\{1,\\dots,d\\}$，我们计算一个张量 $G_k$，其中 $(G_k)_{i_1 \\dots i_d} = \\sum_{j=1}^n D_{i_k, j} u_{i_1 \\dots j \\dots i_d}$。\n\n最后，通过在每个节点上与平流速度 $\\boldsymbol{a}$ 进行点积来组装体积残差张量 $r_{\\text{vol}}$：\n$$\nr_{\\text{vol}} = \\sum_{k=1}^d a_k G_k\n$$\n\n**2. 性能建模与比率计算**\n\n问题为体积核和面核的计算成本提供了一个第一性原理模型。\n\n对于**体积核**：\nflop 计数是梯度计算和点积的 flops 之和：\n$$\n\\text{flops}_{\\text{vol}} = 2 d n^{d+1} + 2 d n^d\n$$\n内存流量主要由读取解张量 $u$ 和写入残差张量 $r_{\\text{vol}}$ 决定，假设使用双精度浮点数（每个值 8 字节）：\n$$\n\\text{bytes}_{\\text{vol}} = (n^d_{\\text{read}} + n^d_{\\text{write}}) \\times 8 \\frac{\\text{bytes}}{\\text{value}} = 16 n^d \\text{ bytes}\n$$\n\n对于**面核**：\nflop 计数基于在单元的 $2d$ 个面上的每个节点应用数值通量计算：\n$$\n\\text{flops}_{\\text{face}} = (2d \\text{ faces}) \\times (n^{d-1} \\frac{\\text{nodes}}{\\text{face}}) \\times (c_{\\text{flux}} \\frac{\\text{flops}}{\\text{node}}) = 2 d n^{d-1} c_{\\text{flux}}\n$$\n其中 $c_{\\text{flux}} = 8$。内存流量涉及读取内部和相邻的迹线值，并写入残差累加器（每个节点 3 个值）：\n$$\n\\text{bytes}_{\\text{face}} = (2d \\text{ faces}) \\times (n^{d-1} \\frac{\\text{nodes}}{\\text{face}}) \\times (3 \\frac{\\text{values}}{\\text{node}}) \\times (8 \\frac{\\text{bytes}}{\\text{value}}) = 48 d n^{d-1} \\text{ bytes}\n$$\n注意，问题中给出的 $2 d n^{d-1} \\cdot 24$ 是等效的。\n\n每个核的执行时间使用 roofline 模型进行估计，其时间受限于机器的峰值 flop 速率 $F$（单位 GF/s）或其峰值内存带宽 $B$（单位 GB/s）：\n$$\nt_{\\text{kernel}} = \\max\\left(\\frac{\\text{flops}_{\\text{kernel}}}{F \\cdot 10^9}, \\frac{\\text{bytes}_{\\text{kernel}}}{B \\cdot 10^9}\\right)\n$$\n\n最终的比率是 $\\rho = t_{\\text{face}} / t_{\\text{vol}}$。\n\n让我们以情况 1 为例进行演示：$d=2$, $p=1$, $F=100$ GF/s, $B=50$ GB/s。\n这里，$n=p+1=2$。\n$\\text{flops}_{\\text{vol}} = 2(2)(2^{2+1}) + 2(2)(2^2) = 4 \\cdot 8 + 4 \\cdot 4 = 32 + 16 = 48$ flops。\n$\\text{bytes}_{\\text{vol}} = 16 \\cdot 2^2 = 64$ 字节。\n$\\text{flops}_{\\text{face}} = 2(2)(2^{2-1})(8) = 4 \\cdot 2 \\cdot 8 = 64$ flops。\n$\\text{bytes}_{\\text{face}} = 48(2)(2^{2-1}) = 96 \\cdot 2 = 192$ 字节。\n\n时间为：\n$t_{\\text{vol}} = \\max\\left(\\frac{48}{100 \\cdot 10^9}, \\frac{64}{50 \\cdot 10^9}\\right) = \\max(0.48, 1.28) \\cdot 10^{-9} = 1.28 \\cdot 10^{-9}$ s。\n$t_{\\text{face}} = \\max\\left(\\frac{64}{100 \\cdot 10^9}, \\frac{192}{50 \\cdot 10^9}\\right) = \\max(0.64, 3.84) \\cdot 10^{-9} = 3.84 \\cdot 10^{-9}$ s。\n\n比率为 $\\rho_1 = \\frac{3.84 \\cdot 10^{-9}}{1.28 \\cdot 10^{-9}} = 3.0$。\n\n对所有测试用例重复此过程。根据要求，为了完整性，数值算子的实现已包含在最终代码中，但最终输出仅取决于性能模型。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\n\ndef get_lgl_diff_matrix(p: int):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes and the corresponding\n    1D differentiation matrix D.\n\n    Args:\n        p: The polynomial degree.\n\n    Returns:\n        A tuple (D, x) where D is the (p+1)x(p+1) differentiation matrix\n        and x is the array of p+1 LGL nodes.\n    \"\"\"\n    n = p + 1\n    if p == 0:\n        return np.array([[0.]]), np.array([0.])\n    \n    # Get LGL nodes: endpoints and roots of P_p'(x)\n    if p > 1:\n        # Roots of P_p'(x) are roots of Jacobi polynomial P_{p-1}^{(1,1)}(x)\n        interior_nodes, _ = roots_jacobi(p - 1, 1, 1)\n        x = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    else: # p == 1\n        x = np.array([-1.0, 1.0])\n    \n    # As per the problem, construct D via barycentric weights.\n    # This is numerically equivalent to other standard formulas for LGL D-matrix.\n    # w_j = 1 / product(x_j - x_k) for k!=j\n    w = np.zeros(n)\n    for j in range(n):\n        prod = np.prod(x[j] - x[np.arange(n) != j])\n        w[j] = 1.0 / prod\n\n    D = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (w[j] / w[i]) / (x[i] - x[j])\n\n    for i in range(n):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D, x\n\ndef apply_vol_op(u_tensor: np.ndarray, a_vec: np.ndarray, D: np.ndarray):\n    \"\"\"\n    Applies the sum-factorized volume operator for advection.\n    Computes r_vol = a . grad(u) at the nodal points.\n\n    Args:\n        u_tensor: The solution field, a d-dimensional numpy array of shape (n, n, ...).\n        a_vec: The constant advection velocity vector.\n        D: The 1D differentiation matrix.\n\n    Returns:\n        The volume residual tensor, r_vol.\n    \"\"\"\n    d = u_tensor.ndim\n    n = u_tensor.shape[0]\n    \n    r_vol = np.zeros_like(u_tensor)\n    \n    # Compute gradient components using sum-factorization\n    for k in range(d):\n        # grad_k_component = D applied along axis k of u_tensor\n        # This is done via tensor contraction.\n        # np.tensordot(D, u_tensor, axes=([1], [k])) computes sum_j D[i,j] * u[...,j,...]\n        # where j is in axis k. The result has the new 'i' axis first.\n        grad_k_derivative_axis_first = np.tensordot(D, u_tensor, axes=([1], [k]))\n        # We move the new axis to its correct position k.\n        grad_k_component = np.moveaxis(grad_k_derivative_axis_first, 0, k)\n        \n        r_vol += a_vec[k] * grad_k_component\n        \n    return r_vol\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # d, p, a, F_gflops, B_gbps\n        (2, 1, np.array([1.0, 1.0]), 100.0, 50.0),\n        (3, 5, np.array([1.0, 1.0, 1.0]), 100.0, 50.0),\n        (3, 5, np.array([1.0, 1.0, 1.0]), 100.0, 10.0),\n        (2, 7, np.array([1.0, 1.0]), 100.0, 200.0),\n    ]\n\n    # Internal validation part: as requested, implement and apply the operators\n    # This part's output is not used in the final result, but its implementation is required.\n    p_val, d_val = 3, 2\n    n_val = p_val + 1\n    D_val, _ = get_lgl_diff_matrix(p_val)\n    u_rand = np.random.rand(*([n_val] * d_val))\n    a_val = np.random.rand(d_val)\n    # The following line executes the volume operator for internal validation\n    r_vol_val = apply_vol_op(u_rand, a_val, D_val)\n\n    results = []\n    c_flux = 8.0\n\n    for case in test_cases:\n        d, p, a, F_gflops, B_gbps = case\n        n = p + 1\n\n        F_sec = F_gflops * 1e9\n        B_sec = B_gbps * 1e9\n\n        # Volume kernel costs\n        flops_vol = float(2 * d * n**(d + 1) + 2 * d * n**d)\n        bytes_vol = float(16 * n**d)\n        \n        # Face kernel costs\n        flops_face = float(2 * d * n**(d - 1) * c_flux)\n        bytes_face = float(2 * d * n**(d - 1) * 24)\n\n        # Roofline model time estimates\n        t_vol = max(flops_vol / F_sec, bytes_vol / B_sec)\n        t_face = max(flops_face / F_sec, bytes_face / B_sec)\n\n        # Ratio\n        rho = t_face / t_vol if t_vol > 0 else 0.0\n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16g}' for r in results)}]\")\n\nsolve()\n```", "id": "3377759"}]}