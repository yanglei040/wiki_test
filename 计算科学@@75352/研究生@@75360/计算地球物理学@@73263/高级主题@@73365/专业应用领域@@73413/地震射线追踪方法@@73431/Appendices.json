{"hands_on_practices": [{"introduction": "地震波在均匀各向同性介质中的传播速度与方向无关。然而，当我们在离散的网格上对程函方程进行数值求解时，计算方法本身可能会引入一种人为的、依赖于传播方向的误差，即“数值各向异性”。本练习旨在让您亲手实现两种基础的网格类地震波走时计算方法——戴克斯特拉（Dijkstra）最短路径算法和快速行进法（Fast Marching Method），并定量地分析和比较它们在均匀介质中的数值各向异性。通过这个实践，您将深刻理解数值算法的内在属性及其对计算精度的影响，这是进行可靠地球物理建模的关键一步。[@problem_id:3614039]", "problem": "给定一个大小为 $N \\times N$ 的二维笛卡尔网格，其空间步长为 $h$（单位：米），以及一个均匀慢度场 $s(\\mathbf{x}) \\equiv s_0$（单位：秒/米）。点源位于网格中心。在平滑变化的各向同性介质中，地震射线的首波走时场 $T(\\mathbf{x})$ 由程函方程 $|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})$ 控制。在计算地球物理学中，两种广泛使用的数值方法是：\n\n1. 在网格图上使用 Dijkstra 算法的基于图的最短路径方法，其中边连接网格邻居，每条边的代价等于慢度沿该边的路径积分。\n2. 快速行进法 (FMM)，这是一种求解程函方程的单调、迎风有限差分方法。\n\n你的任务是为均匀慢度场 $s(\\mathbf{x}) = s_0$ 实现这两种方法，并量化每种数值模板引入的方向偏差。从基本原理出发：Fermat 原理指出，地震射线遵循平稳走时路径；而程函方程是波动方程的高频极限。在网格上，Dijkstra 算法最小化边代价的离散和，而 FMM 则通过耦合正交方向的局部更新来强制执行程函关系的迎风离散化。你必须：\n\n- 在 $4$-邻居网格图（边仅沿笛卡尔坐标轴）上实现 Dijkstra 算法，边代价等于慢度与几何边长的乘积。使用中心点作为源点，其 $T=0$。\n- 在相同网格上实现快速行进法 (FMM)，对各向同性程函方程使用一阶单调迎风离散化，通过按 $T$ 值增序接受节点来确保因果性。\n\n定义数值模板在给定物理半径 $r$（单位：米）处的各向异性指数 $\\mathcal{A}$：在 $[0, 2\\pi)$ 上均匀采样方向 $\\theta_k$（单位：弧度），将每个方向映射到目标半径处最近的网格节点，并计算视慢度 $s_{\\mathrm{app}}(\\theta_k) = T_{\\mathrm{num}}(\\theta_k)/d(\\theta_k)$，其中 $d(\\theta_k)$ 是从源点到采样网格节点的欧几里得距离（单位：米）。各向异性指数为\n$$\n\\mathcal{A} = \\frac{\\max_k s_{\\mathrm{app}}(\\theta_k)}{\\min_k s_{\\mathrm{app}}(\\theta_k)} - 1,\n$$\n该值为无量纲。这个量捕捉了方向偏差：对于均匀介质中的完全各向同性离散化，$s_{\\mathrm{app}}(\\theta)$ 将是常数，$\\mathcal{A}$ 将为 $0$。\n\n角度单位必须是弧度。走时必须以秒为单位计算。距离必须以米为单位计算。你必须将报告的每个各向异性指数四舍五入到六位小数。\n\n测试套件：\n- 案例1 (正常路径): $N=101$, $h=10$ 米, $s_0 = 0.0005$ 秒/米, $r=200$ 米, $K=36$ 个角度。\n- 案例2 (近源边界条件): $N=101$, $h=10$ 米, $s_0 = 0.0005$ 秒/米, $r=10$ 米, $K=36$ 个角度。\n- 案例3 (更大区域，更大半径): $N=201$, $h=10$ 米, $s_0 = 0.0005$ 秒/米, $r=700$ 米, $K=72$ 个角度。\n\n对于每个案例，计算两个数：Dijkstra $4$-邻居方法的各向异性指数和快速行进法的各向异性指数。最终输出为一行，包含一个由三个案例结果组成的逗号分隔列表，其中每个案例结果本身是一个按 $[\\mathcal{A}_{\\text{Dijkstra}},\\mathcal{A}_{\\text{FMM}}]$ 顺序排列的双元素列表。确切的输出格式必须是\n$$\n\\texttt{[[a\\_11,a\\_12],[a\\_21,a\\_22],[a\\_31,a\\_32]]}\n$$\n不含空格，且每个 $a\\_{ij}$ 都四舍五入到六位小数。", "solution": "用户希望量化在网格上求解程函方程的两种常用方法所产生的数值各向异性：Dijkstra 算法和快速行进法 (FMM)。\n\n### 基于原理的设计\n\n这个问题处于波传播物理学和数值分析的交叉领域。其核心原理是程函方程 $|\\nabla T| = s$ 描述了波前在慢度为 $s$ 的介质中的走时 $T$。在均匀介质 ($s(\\mathbf{x}) = s_0$) 中，点源的解为 $T(\\mathbf{x}) = s_0 d(\\mathbf{x}, \\mathbf{x}_{\\text{source}})$，其中 $d$ 是欧几里得距离。走时等值线（等时线）是完美的圆形。\n\n在笛卡尔网格上的数值方法不可避免地会引入误差，这些误差依赖于传播方向与网格轴的相对关系。这种方向依赖性被称为数值各向异性。我们的任务是实现两种标准算法并测量这种效应。\n\n#### 1. 在 4-邻居图上的 Dijkstra 算法\n\n**基本原理**：Dijkstra 算法在具有非负边权重的图中找到从源点到所有其他节点的最短路径。通过将网格建模为图（其中节点是网格点，边连接邻居），我们可以近似计算走时。这里的平稳时间原理（Fermat 原理）被离散路径最小化所取代。\n\n**算法设计**：\n-   **图表示**：$N \\times N$ 的网格点是图的顶点。边连接每个点 $(i, j)$ 与其四个基本邻居：$(i\\pm1, j)$ 和 $(i, j\\pm1)$。\n-   **边代价**：沿边的走时是慢度 $s_0$ 与路径长度的乘积。由于相邻网格点之间的距离是网格间距 $h$，因此每条边的代价是统一的：$w = s_0 h$。\n-   **实现**：Dijkstra 算法的标准实现使用一个最小优先队列来高效地按走时递增的顺序探索节点。\n    1.  初始化一个大小为 $N \\times N$ 的走时数组 $T$ 为无穷大，并在源节点处设置 $T=0$。\n    2.  将源节点 `(time=0, index)` 添加到优先队列中。\n    3.  当队列不为空时，提取时间最小的节点。\n    4.  如果此节点已最终确定，则跳过。否则，将其标记为已最终确定。\n    5.  对于其四个邻居中的每一个，计算潜在的新走时。如果此时间小于邻居当前记录的时间，则在 $T$ 数组中更新邻居的时间，并将其添加到优先队列中。\n\n**预期各向异性**：此方法将路径限制在网格线上。两点之间的最短路径是“曼哈顿”路径。相对于源点，点 $(i, j)$ 的走时为 $T_{\\text{Dijkstra}} = s_0 h (|i| + |j|)$。视慢度为 $s_{\\text{app}} = T / d = s_0 h (|i|+|j|) / (h\\sqrt{i^2+j^2}) = s_0 (|i|+|j|)/\\sqrt{i^2+j^2}$。该值沿网格轴最小（为 $s_0$），沿网格对角线最大（为 $\\sqrt{2} s_0$），导致理论各向异性指数为 $\\mathcal{A}_{\\text{Dijkstra}} = \\sqrt{2} - 1 \\approx 0.414$。\n\n#### 2. 一阶快速行进法 (FMM)\n\n**基本原理**：FMM 是一种更复杂的基于网格的方法，它直接求解程函方程的有限差分近似。它通过从源点向外传播解来遵循因果性，类似于波的传播方式。与 Dijkstra 算法一样，它使用优先队列来选择下一个要最终确定的节点。\n\n**算法设计**：\n-   **离散化**：梯度算子 $\\nabla T$ 使用迎风有限差分进行近似。对于各向同性程函方程 $|\\nabla T|^2 = s_0^2$，在网格点 $(i,j)$ 处的一阶格式为：\n    $$ \\left( \\frac{T_{i,j} - T_x}{h} \\right)^2 + \\left( \\frac{T_{i,j} - T_y}{h} \\right)^2 = s_0^2 $$\n    其中，$T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 是已计算邻居的走时。\n-   **更新规则**：为计算新节点的时间 $T_{i,j}$，我们求解上述二次方程。设 $a$ 和 $b$ 是 x 和 y 方向上迎风邻居的已知走时。方程为 $(T-a)^2 + (T-b)^2 = (s_0 h)^2$。为确保因果性（$T > a$ 和 $T > b$），我们必须取较大的根：\n    $$ T = \\frac{a+b + \\sqrt{2(s_0 h)^2 - (a-b)^2}}{2} $$\n    此公式仅在平方根下的项为非负时有效。如果为负，则意味着特征方向与其中一个坐标轴对齐，更新简化为一维传播：$T = \\min(a,b) + s_0 h$。\n-   **实现**：整体结构与 Dijkstra 算法相似。节点分为 KNOWN（已确定时间）、TRIAL（在优先队列中）和 FAR（未访问）三类。算法系统地将节点从 TRIAL 移动到 KNOWN，并更新它们的 FAR 邻居，将其变为 TRIAL 节点。\n\n**预期各向异性**：该方法在其更新规则中耦合了空间维度，产生了比 4-邻居 Dijkstra 算法更准确且更各向同性的波前。然而，作为一种一阶格式，它仍然表现出一些网格各向异性。分析表明，视慢度沿坐标轴最小（为 $s_0$），沿对角线最大，值为 $s_0(1/\\sqrt{2}+1/2)$。这导致的理论各向异性指数为 $\\mathcal{A}_{\\text{FMM}} = 1/\\sqrt{2} - 1/2 \\approx 0.207$。\n\n#### 3. 各向异性指数计算\n\n各向异性指数 $\\mathcal{A}$ 是方向误差的定量度量。\n$$\n\\mathcal{A} = \\frac{\\max_k s_{\\mathrm{app}}(\\theta_k)}{\\min_k s_{\\mathrm{app}}(\\theta_k)} - 1\n$$\n-   **步骤**：我们在以源点为中心、物理半径为 $r$ 的圆上采样 $K$ 个点。对于每个角度 $\\theta_k$，我们找到最近的网格节点。\n-   **视慢度**：对于每个采样的网格节点，我们计算视慢度 $s_{\\text{app}} = T_{\\text{num}} / d$，其中 $T_{\\text{num}}$ 是由数值方法计算的走时，而 $d$ 是从源点到该特定网格节点的真实欧几里得距离。\n-   **解释**：在完全各向同性的模拟中，$s_{\\text{app}}$ 将是常数且等于 $s_0$，从而得出 $\\mathcal{A}=0$。一个非零的 $\\mathcal{A}$ 揭示了数值误差的方向依赖性程度。\n\n该实现将包含三个主要函数：一个用于 Dijkstra 算法，一个用于 FMM，还有一个用于从产生的走时场计算各向异性指数。将为每个测试案例调用这些函数以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # --- State Constants for FMM ---\n    _FAR = 0\n    _TRIAL = 1\n    _KNOWN = 2\n\n    def dijkstra_4n(N, h, s0):\n        \"\"\"\n        Computes first-arrival times using Dijkstra's algorithm on a 4-neighbor graph.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        source = (center_idx, center_idx)\n\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        times[source] = 0.0\n\n        pq = [(0.0, source[0], source[1])]\n        visited = np.zeros((N, N), dtype=bool)\n        edge_cost = s0 * h\n\n        while pq:\n            time, r, c = heapq.heappop(pq)\n\n            if visited[r, c]:\n                continue\n            \n            visited[r, c] = True\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n\n                if 0 <= nr < N and 0 <= nc < N:\n                    new_time = time + edge_cost\n                    if new_time < times[nr, nc]:\n                        times[nr, nc] = new_time\n                        heapq.heappush(pq, (new_time, nr, nc))\n        \n        return times\n\n    def fmm_1st_order(N, h, s0):\n        \"\"\"\n        Computes first-arrival times using the first-order Fast Marching Method.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        source = (center_idx, center_idx)\n\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        states = np.full((N, N), _FAR, dtype=np.int8)\n        \n        times[source] = 0.0\n        \n        pq = [(0.0, source[0], source[1])] # The 'TRIAL' set\n        states[source] = _TRIAL\n        \n        c_sq = (s0 * h)**2\n\n        while pq:\n            time, r, c = heapq.heappop(pq)\n            \n            if states[r, c] == _KNOWN:\n                continue\n            \n            states[r, c] = _KNOWN\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                \n                if not (0 <= nr < N and 0 <= nc < N) or states[nr, nc] == _KNOWN:\n                    continue\n\n                # Find minimum times of KNOWN neighbors in x and y directions\n                t_x_min = np.inf\n                if nr > 0 and states[nr - 1, nc] == _KNOWN:\n                    t_x_min = min(t_x_min, times[nr - 1, nc])\n                if nr < N - 1 and states[nr + 1, nc] == _KNOWN:\n                    t_x_min = min(t_x_min, times[nr + 1, nc])\n\n                t_y_min = np.inf\n                if nc > 0 and states[nr, nc - 1] == _KNOWN:\n                    t_y_min = min(t_y_min, times[nr, nc - 1])\n                if nc < N - 1 and states[nr, nc + 1] == _KNOWN:\n                    t_y_min = min(t_y_min, times[nr, nc + 1])\n                \n                # Solve for new time at (nr, nc)\n                new_time_cand = np.inf\n                has_x = t_x_min != np.inf\n                has_y = t_y_min != np.inf\n                \n                if has_x and has_y:\n                    diff_sq = (t_x_min - t_y_min)**2\n                    if c_sq * 2.0 >= diff_sq:\n                        term_sqrt = np.sqrt(c_sq * 2.0 - diff_sq)\n                        new_time_cand = (t_x_min + t_y_min + term_sqrt) / 2.0\n                    else:\n                        new_time_cand = min(t_x_min, t_y_min) + s0 * h\n                elif has_x:\n                    new_time_cand = t_x_min + s0 * h\n                elif has_y:\n                    new_time_cand = t_y_min + s0 * h\n                \n                if new_time_cand < times[nr, nc]:\n                    times[nr, nc] = new_time_cand\n                    heapq.heappush(pq, (new_time_cand, nr, nc))\n                    states[nr, nc] = _TRIAL\n                    \n        return times\n\n    def compute_anisotropy(times_field, N, h, r, K):\n        \"\"\"\n        Computes the anisotropy index for a given travel time field.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        y_c = center_idx * h # physical y-coord of source (row)\n        x_c = center_idx * h # physical x-coord of source (col)\n        \n        thetas = np.linspace(0, 2 * np.pi, K, endpoint=False)\n        \n        s_app_list = []\n        \n        for theta in thetas:\n            # Target coordinates on the geometric circle\n            x_target = x_c + r * np.cos(theta)\n            y_target = y_c + r * np.sin(theta)\n            \n            # Find nearest grid node, mapping physical (x,y) to grid (j,i)\n            j_target = np.round(x_target / h).astype(int)\n            i_target = np.round(y_target / h).astype(int)\n            \n            # Clamp to grid bounds\n            i_target = max(0, min(N - 1, i_target))\n            j_target = max(0, min(N - 1, j_target))\n            \n            t_num = times_field[i_target, j_target]\n            \n            # Physical coordinates of the sampled node\n            x_node = j_target * h\n            y_node = i_target * h\n            \n            dist = np.sqrt((x_node - x_c)**2 + (y_node - y_c)**2)\n            \n            if dist > 1e-9:\n                s_app = t_num / dist\n                s_app_list.append(s_app)\n        \n        if not s_app_list or len(s_app_list) < 2:\n            return 0.0\n            \n        min_s_app = np.min(s_app_list)\n        max_s_app = np.max(s_app_list)\n\n        if min_s_app < 1e-9:\n            return np.inf\n\n        anisotropy = max_s_app / min_s_app - 1.0\n        return anisotropy\n\n    test_cases = [\n        # (N, h, s0, r, K)\n        (101, 10.0, 0.0005, 200.0, 36),\n        (101, 10.0, 0.0005, 10.0, 36),\n        (201, 10.0, 0.0005, 700.0, 72),\n    ]\n\n    results = []\n    for N, h, s0, r, K in test_cases:\n        # Dijkstra's method\n        times_dijkstra = dijkstra_4n(N, h, s0)\n        anisotropy_dijkstra = compute_anisotropy(times_dijkstra, N, h, r, K)\n        \n        # Fast Marching Method\n        times_fmm = fmm_1st_order(N, h, s0)\n        anisotropy_fmm = compute_anisotropy(times_fmm, N, h, r, K)\n        \n        results.append([anisotropy_dijkstra, anisotropy_fmm])\n\n    case_strings = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3614039"}, {"introduction": "在地震波场模拟中，一个常见的工作流程是首先计算全场的走时，然后利用走时场的梯度信息来追踪射线路径。本练习将引导您探索这一流程的内在自洽性。您将通过快速行进法（FMM）计算一个包含高慢度透镜体的复杂介质中的走时场，然后从接收点出发，沿着走时场的负梯度方向反向追踪射线，并通过对射线路径上的慢度进行积分来累积走时。通过比较积分走时与直接从走时场插值得到的走时，您可以定量评估整个数值工作流程中累积的误差，这对于理解和验证复杂模型中的射线追踪结果至关重要。[@problem_id:3614052]", "problem": "设计并实现一个完整的程序，该程序针对一个慢度在空间上变化的二维各向同性介质，通过在指定的接收点位置比较两个独立计算的量来量化初至走时的数值误差：(i) 由偏微分方程 $|\\nabla T| = s(\\mathbf{x})$ 定义的程函走时场的插值解，以及 (ii) 沿着通过追随走时场局部梯度而数值追踪出的射线的慢度线积分。您的实现必须从计算地球物理学中地震射线追踪方法的基本原理出发，即费马原理（Fermat’s principle）和程函方程的哈密顿-雅可比（Hamilton–Jacobi）形式。不得假定超出这些基础的任何快捷公式；所有算法步骤必须由因果性和迎风格式一致性来证明其合理性。您必须解决以下要求。\n\n- 物理和数学设置：\n  - 考虑一个二维笛卡尔域 $\\Omega = \\{(x,z): 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$，其在 $x$ 和 $z$ 方向上的均匀网格间距均为 $h = 0.02 \\ \\text{km}$。\n  - 定义背景速度为 $v_0 = 3.0 \\ \\text{km/s}$，因此背景慢度为 $s_0 = 1/v_0 \\ \\text{s/km}$。\n  - 叠加一个以 $(x_c,z_c) = (2.0 \\ \\text{km}, 1.0 \\ \\text{km})$ 为中心、相对振幅 $A = 0.5$、标准差 $\\sigma = 0.3 \\ \\text{km}$ 的聚焦高斯慢透镜（较高慢度），使得慢度场为\n    $$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) \\ \\text{s/km}. $$\n  - 在 $(x_s,z_s) = (0.2 \\ \\text{km}, 1.0 \\ \\text{km})$ 处放置一个点源。\n\n- 基本原理和要实现的算法任务：\n  - 根据费马原理，沿参数化路径 $\\gamma(\\ell)$（其中 $\\ell$ 为弧长参数）累积的走时是泛函\n    $$ \\mathcal{T}[\\gamma] = \\int_{\\ell_0}^{\\ell_1} s(\\gamma(\\ell)) \\, d\\ell \\ \\text{s}. $$\n    初至走时场 $T(\\mathbf{x})$ 是哈密顿-雅可比程函方程的粘性解\n    $$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}). $$\n  - 实现一个一阶、单调、迎风的快速行进方法（Fast Marching Method），该方法在给定慢度 $s(x,z)$ 的情况下，在网格上计算离散走时场 $T_h$，并遵循因果性。除了从迎风格式一致性和离散哈密顿-雅可比结构所蕴含的局部二次求解中得出的更新外，不要假定任何闭式更新。在最接近 $(x_s,z_s)$ 的网格节点处将 $T_h$ 初始化为 $T = 0 \\ \\text{s}$。\n  - 实现从接收点位置 $\\mathbf{x}_r$ 到震源的射线反向追踪，方法是沿着计算出的 $T_h$ 的归一化负梯度（即特征曲线）进行，使用弧长步长 $\\Delta \\ell$ 以及在离网格点处对 $T_h$ 和 $s$ 进行双线性插值。需要积分的常微分方程是\n    $$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|}, $$\n    当 $\\|\\mathbf{x} - \\mathbf{x}_s\\|$ 在一个网格间距内时终止。累加线积分\n    $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_0^{L(\\mathbf{x}_r)} s(\\mathbf{x}(\\ell)) \\, d\\ell \\ \\text{s}, $$\n    其中 $L(\\mathbf{x}_r)$ 是追踪到震源的路径长度。同时通过在 $\\mathbf{x}_r$ 处对 $T_h$ 进行双线性插值来计算插值程函时间 $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$。\n  - 对每个接收点，报告带符号的失配值\n    $$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) \\ \\text{s}. $$\n\n- 单位和数值：\n  - 所有距离单位必须是千米，所有走时单位必须是秒，所有慢度值单位必须是秒/千米。不需要角度。在积分射线时，使用恒定的弧长步长 $\\Delta \\ell = 0.005 \\ \\text{km}$，并在到 $(x_s,z_s)$ 的欧几里得距离小于 $0.02 \\ \\text{km}$ 或达到最大步数 $10000$ 步时终止，以先发生者为准。对离网格点的场样本使用双线性插值。\n\n- 测试套件：\n  - 使用以下接收点坐标（单位为千米）来测试正常传播、沿光轴的近焦散聚焦、离轴近焦散行为、穿过透镜以及远场边界情况：\n    - $\\mathbf{x}_{r,1} = (0.5, 1.0)$\n    - $\\mathbf{x}_{r,2} = (3.5, 1.0)$\n    - $\\mathbf{x}_{r,3} = (3.5, 0.8)$\n    - $\\mathbf{x}_{r,4} = (2.0, 1.0)$\n    - $\\mathbf{x}_{r,5} = (3.9, 1.0)$\n\n- 所需输出：\n  - 您的程序必须生成单行输出，其中包含上述接收点的带符号失配值列表（单位为秒），顺序与接收点顺序相同，格式为小数点后六位的小数浮点数，用方括号括起并用逗号分隔（例如，$[0.000123,-0.000456,\\dots]$）。以秒为单位表示最终值，并保留符号。\n\n您的设计必须是完全自包含和确定性的，程序不得读取任何输入或需要任何外部文件或网络访问。程序必须根据上述描述从第一性原理实现数值方法，并按指定格式生成所需输出。", "solution": "该问题要求设计并实现一个数值实验，以量化地震走时计算中的自洽性误差。这通过比较源自同一底层数值结构的两​​个量来完成：(i) 通过对程函方程的解进行插值获得的接收点位置的走时 $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$，以及 (ii) 通过沿程函解场中追踪出的射线路径对慢度场进行积分计算出的走时 $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$。整个过程基于费马原理（Fermat's principle），该原理指出，地震波在两点之间所走的路径是走时平稳（对于初至波而言是最小）的路径。\n\n这一原理的数学表述导出了哈密顿-雅可比程函方程（Hamilton-Jacobi eikonal equation），这是地球物理学中的一个基本偏微分方程：\n$$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}) $$\n其中 $T(\\mathbf{x})$ 是来自震源的初至走时场，$s(\\mathbf{x})$ 是介质在位置 $\\mathbf{x}$ 处的慢度（速度的倒数）。射线路径是该方程的特征线。\n\n求解过程分为两个主要阶段：首先，在网格上计算离散走时场 $T_h$；其次，使用该场追踪射线并积分走时。\n\n**1. 物理和计算域设置**\n\n问题设定在一个二维笛卡尔域 $\\Omega = \\{(x,z) \\mid 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$ 中。该域被离散化为一个均匀网格，网格间距为 $h = 0.02 \\ \\text{km}$。这产生了一个 $N_x \\times N_z$ 的网格节点，其中 $N_x = 4/0.02 + 1 = 201$，$N_z = 2/0.02 + 1 = 101$。\n\n慢度场 $s(x,z)$ 由一个恒定的背景慢度 $s_0 = 1/v_0 = 1/3.0 \\ \\text{s/km}$ 叠加一个高斯异常来定义：\n$$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) $$\n参数为 $A = 0.5$、$(x_c, z_c) = (2.0, 1.0) \\ \\text{km}$ 和 $\\sigma = 0.3 \\ \\text{km}$。该慢度函数在每个网格节点 $(x_i, z_j)$ 上求值，以创建一个离散慢度场 $s_{i,j}$。\n\n**2. 通过快速行进方法（FMM）求解程函方程**\n\n离散走时场 $T_h$ 使用一阶快速行进方法（Fast Marching Method, FMM）计算。FMM 是一种高效的基于网格的算法，它通过系统地推进波前并遵循因果性来求解程函方程。这类似于惠更斯原理（Huygens' principle）。该算法使用一个最小优先队列来确保网格点按走时递增的顺序进行处理。\n\n每个网格节点的状态分为三类：\n- `KNOWN`：走时已确定。\n- `TRIAL`：存在走时估计值；该节点是待确定值的候选节点。这些节点构成了窄带或波前。\n- `FAR`：节点未被触及。\n\nFMM 算法流程如下：\n- **初始化**：将所有节点的走时数组 $T_h$ 初始化为无穷大。将最接近震源 $(x_s, z_s) = (0.2, 1.0) \\ \\text{km}$ 的网格节点 $(i_s, j_s)$ 赋值为 $T_{i_s, j_s} = 0$。此节点被添加到一个最小优先队列中，其状态设置为 `TRIAL`。\n- **迭代**：算法的主循环重复地从优先队列中提取具有最小走时的 `TRIAL` 节点。该节点的状态变为 `KNOWN`。对于其每个非 `KNOWN` 的邻居节点，计算一个新的走时。\n- **迎风有限差分更新**：节点 $(i,j)$ 的走时根据其邻居的已确定（`KNOWN`）值进行更新。这种迎风格式识别到信息从震源向外流动。设 $T_x$ 和 $T_z$ 分别是节点 $(i,j)$ 沿 $x$ 和 $z$ 轴的 `KNOWN` 邻居的最小走时。设 $s_{i,j}$ 是该节点的慢度。更新后的时间 $T'_{i,j}$ 由 Godunov 格式确定：\n  1.  如果只有一个迎风邻居可用（例如，$T_x$ 是有限的，$T_z$ 是无限的），或者如果波从一个方向到达得早得多，则使用一维更新。这发生在 $|\\min(T_x,T_z) + h s_{i,j}| \\le \\max(T_x,T_z)$ 的情况下。更新公式为 $T'_{i,j} = \\min(T_x, T_z) + h s_{i,j}$。\n  2.  否则，波前由来自两个轴的贡献构成。更新通过求解从离散化程函方程 $(\\frac{T' - T_x}{h})^2 + (\\frac{T' - T_z}{h})^2 = s_{i,j}^2$ 导出的二次方程来找到。正确的因果解是 $T'_{i,j} = \\frac{T_x + T_z + \\sqrt{2(h s_{i,j})^2 - (T_x-T_z)^2}}{2}$。\n- 如果新计算出的时间 $T'_{i,j}$ 小于存储在节点 $(i,j)$ 上的当前时间，则更新该值，将节点状态设置为 `TRIAL`，并将其添加到优先队列中。当优先队列为空时，算法终止。\n\n最后，通过对最终的离散走时场 $T_h$ 进行双线性插值，可以获得任意接收点位置 $\\mathbf{x}_r$ 处的走时，记为 $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$。\n\n**3. 射线追踪与走时积分**\n\n地震射线是程函方程的特征曲线，其方向沿着走时场 $\\nabla T$ 的梯度。为了从接收点 $\\mathbf{x}_r$ 反向追踪射线到震源 $\\mathbf{x}_s$，我们对由弧长 $\\ell$ 参数化的射线路径 $\\mathbf{x}(\\ell)$ 的常微分方程（ODE）进行积分：\n$$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|} $$\n负号表示向震源的反向传播。该常微分方程被数值求解。\n\n- **数值积分**：使用常数弧长步长 $\\Delta \\ell = 0.005 \\ \\text{km}$ 的前向欧拉法（forward Euler method）：\n  $$ \\mathbf{x}_{k+1} = \\mathbf{x}_k - \\Delta\\ell \\frac{\\nabla T_h(\\mathbf{x}_k)}{|\\nabla T_h(\\mathbf{x}_k)|} $$\n  其中 $\\mathbf{x}_k$ 是第 $k$ 步的位置。在每一步都需要计算场的梯度 $\\nabla T_h(\\mathbf{x}_k)$。由于 $\\mathbf{x}_k$ 通常不在网格节点上，其值是通过首先使用二阶有限差分在整个网格上计算 $T_h$ 的梯度，然后使用双线性插值来评估 $\\mathbf{x}_k$ 处的梯度分量来找到的。范数 $|\\nabla T_h(\\mathbf{x}_k)|$ 是从这个插值梯度向量计算出来的。\n- **走时累积**：沿射线的总走时 $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$ 是慢度场沿追踪路径的线积分。该积分通过求和（一个简单的矩形求积法则）来近似：\n  $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_{0}^{L} s(\\mathbf{x}(\\ell)) \\, d\\ell \\approx \\sum_{k} s(\\mathbf{x}_k) \\Delta\\ell $$\n  每个离网格点处的慢度 $s(\\mathbf{x}_k)$ 也通过对离散慢度场 $s_{i,j}$ 进行双线性插值获得。\n- **终止**：对于给定的接收点，当其到震源 $(x_s, z_s)$ 的欧几里得距离小于一个网格间距（$h = 0.02 \\ \\text{km}$）时，或者如果达到了最大步数 $10000$ 步，射线追踪过程终止。\n\n**4. 误差量化**\n\n核心任务是为每个指定的接收点 $\\mathbf{x}_r$ 计算带符号的失配值 $\\Delta(\\mathbf{x}_r)$。该值定义为：\n$$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) $$\n预计会得到一个非零的 $\\Delta(\\mathbf{x}_r)$，它代表了从多个来源累积的数值误差：FMM 的一阶精度、有限差分梯度估计的不准确性、用于射线积分的欧拉法的一阶精度，以及重复双线性插值带来的误差。该度量可作为所实现数值方法自洽性的一种衡量标准。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes numerical error in seismic travel times by comparing an FMM eikonal solution\n    with line integrals along traced rays.\n    \"\"\"\n    # 1. Physical and mathematical setting\n    W, H = 4.0, 2.0  # Domain size in km\n    h = 0.02  # Grid spacing in km\n    v0 = 3.0  # Background velocity in km/s\n    s0 = 1.0 / v0  # Background slowness in s/km\n\n    # Gaussian lens parameters\n    xc, zc = 2.0, 1.0  # Center in km\n    A = 0.5  # Relative amplitude (dimensionless)\n    sigma = 0.3  # Standard deviation in km\n\n    # Source and receiver locations\n    xs, zs = 0.2, 1.0  # Source in km\n    source_pos_np = np.array([xs, zs])\n    receivers = [\n        (0.5, 1.0),\n        (3.5, 1.0),\n        (3.5, 0.8),\n        (2.0, 1.0),\n        (3.9, 1.0),\n    ]\n\n    # Numerical parameters for ray tracing\n    delta_l = 0.005  # Arclength step in km\n    max_ray_steps = 10000\n    termination_dist = h\n\n    # 2. Grid and slowness field setup\n    nx = int(W / h) + 1\n    nz = int(H / h) + 1\n    x_ax = np.linspace(0, W, nx)\n    z_ax = np.linspace(0, H, nz)\n    X, Z = np.meshgrid(x_ax, z_ax)\n\n    s_field = s0 * (1.0 + A * np.exp(-((X - xc)**2 + (Z - zc)**2) / (2.0 * sigma**2)))\n\n    # 3. Fast Marching Method (FMM)\n    T = np.full((nz, nx), np.inf)\n    FAR, TRIAL, KNOWN = 0, 1, 2\n    states = np.zeros((nz, nx), dtype=np.int8)\n    pq = []\n\n    # Initialize source\n    isrc = int(np.round(xs / h))\n    jsrc = int(np.round(zs / h))\n    \n    T[jsrc, isrc] = 0.0\n    states[jsrc, isrc] = TRIAL\n    heapq.heappush(pq, (0.0, jsrc, isrc))\n\n    # FMM main loop\n    while pq:\n        time, j, i = heapq.heappop(pq)\n\n        if states[j, i] == KNOWN:\n            continue\n        states[j, i] = KNOWN\n\n        # Process neighbors\n        for dj, di in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            jn, i_n = j + dj, i + di\n\n            if not (0 <= jn < nz and 0 <= i_n < nx):\n                continue\n            if states[jn, i_n] == KNOWN:\n                continue\n\n            # Get minimum times from known neighbors of the target node (jn, i_n)\n            tx_min = np.inf\n            if i_n > 0 and states[jn, i_n - 1] == KNOWN:\n                tx_min = T[jn, i_n - 1]\n            if i_n < nx - 1 and states[jn, i_n + 1] == KNOWN:\n                tx_min = min(tx_min, T[jn, i_n + 1])\n\n            tz_min = np.inf\n            if jn > 0 and states[jn - 1, i_n] == KNOWN:\n                tz_min = T[jn - 1, i_n]\n            if jn < nz - 1 and states[jn + 1, i_n] == KNOWN:\n                tz_min = min(tz_min, T[jn + 1, i_n])\n\n            if tx_min == np.inf and tz_min == np.inf:\n                continue\n\n            # Godunov upwind update\n            t_cand = sorted([tx_min, tz_min])\n            t1, t2 = t_cand[0], t_cand[1]\n            s_val = s_field[jn, i_n]\n            h_s = h * s_val\n            t_new = np.inf\n\n            if t1 + h_s <= t2 or t2 == np.inf:  # 1D update\n                t_new = t1 + h_s\n            else:  # 2D update\n                # Solve: (t-t1)^2 + (t-t2)^2 = (h*s)^2\n                a, b, c = 2.0, -2.0 * (t1 + t2), t1**2 + t2**2 - h_s**2\n                discriminant = b**2 - 4 * a * c\n                if discriminant >= 0:\n                    t_new = (-b + np.sqrt(discriminant)) / (2.0 * a)\n\n            if t_new < T[jn, i_n]:\n                T[jn, i_n] = t_new\n                states[jn, i_n] = TRIAL\n                heapq.heappush(pq, (t_new, jn, i_n))\n\n    # 4. Ray Tracing setup\n    # Create interpolators for T, s, and gradients\n    # Note: RegularGridInterpolator expects points in (z, x) order\n    interp_T = RegularGridInterpolator((z_ax, x_ax), T, bounds_error=False, fill_value=None)\n    interp_s = RegularGridInterpolator((z_ax, x_ax), s_field, bounds_error=False, fill_value=None)\n\n    # Gradients of T: dT/dz, dT/dx\n    gz, gx = np.gradient(T, h, h)\n    interp_dTdx = RegularGridInterpolator((z_ax, x_ax), gx, bounds_error=False, fill_value=None)\n    interp_dTdz = RegularGridInterpolator((z_ax, x_ax), gz, bounds_error=False, fill_value=None)\n    \n    results = []\n    \n    # 5. Compute mismatch for each receiver\n    for xr, zr in receivers:\n        # (i) Get interpolated eikonal travel time\n        T_eik = interp_T([zr, xr])[0]\n\n        # (ii) Trace ray and integrate slowness\n        current_pos = np.array([xr, zr])\n        ray_time = 0.0\n\n        for _ in range(max_ray_steps):\n            if np.linalg.norm(current_pos - source_pos_np) <= termination_dist:\n                break\n            \n            # Interpolator expects (z, x) point format\n            pos_for_interp = [current_pos[1], current_pos[0]] \n\n            s_val = interp_s(pos_for_interp)[0]\n            grad_T_x = interp_dTdx(pos_for_interp)[0]\n            grad_T_z = interp_dTdz(pos_for_interp)[0]\n            grad_T = np.array([grad_T_x, grad_T_z])\n            grad_T_norm = np.linalg.norm(grad_T)\n\n            if grad_T_norm < 1e-12: # Avoid division by zero\n                break\n\n            # Euler step for ray path ODE\n            direction = -grad_T / grad_T_norm\n            current_pos += direction * delta_l\n\n            # Accumulate time via line integral (simple quadrature)\n            ray_time += s_val * delta_l\n        \n        delta = ray_time - T_eik\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3614052"}, {"introduction": "连接特定震源和接收点的“两点射线追踪”是地震学中的一个核心边界值问题，对于地震成像、层析反演和偏移等应用至关重要。本高级练习旨在对比解决这一问题的两种经典数值策略：打靶法（Shooting Method）和基于牛顿法的两点边值求解器。打靶法通过优化初始出射角来“命中”目标，而牛顿法利用射线状态对初始参数的敏感度信息（通过变分方程求解）实现更快的收敛。掌握这些技术不仅能加深您对射线动力学系统的理解，也为开发更高级的地球物理反演算法奠定了坚实的基础。[@problem_id:3614051]", "problem": "你的任务是实现并比较两种数值策略，用于解决二维、各向同性、速度平滑变化的介质中的两点地震射线靶向问题。目标是确定震源的出射方向和走时，使得由射线常微分方程（ODE）控制的射线能够到达指定的接收点位置。你的程序必须输出一个列表，该列表汇总了多个测试案例的定量比较指标。\n\n从地震学和哈密顿力学的以下基本基础开始：\n\n- 根据费马原理，射线路径是走时的平稳曲线。\n- 程函方程将走时场的梯度与慢度的大小联系起来，在各向同性介质中，可以采用射线的哈密顿表示。\n- 在速度场为 $c(\\mathbf{x})$（其中 $\\mathbf{x} = (x,z)$）的各向同性介质中，走时参数 $t$ 可用于射线参数化。将慢度矢量的水平和垂直分量分别定义为 $p = \\partial T / \\partial x$ 和 $q = \\partial T / \\partial z$。使用哈密顿量 $H(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2} c(\\mathbf{x})^2 \\lVert \\mathbf{p} \\rVert^2 - \\tfrac{1}{2}$（其中 $\\mathbf{p} = (p,q)$），哈密顿方程可以推导出一个关于状态 $\\mathbf{y} = (x,z,p,q)$ 的常微分方程系统，该系统由走时 $t$ 参数化。\n\n你的任务是：\n\n$1.$ 从上述基本基础出发，对于垂直分层速度 $c(x,z) = c(z)$，使用走时参数化的哈密顿方程，推导形式为 $\\dfrac{d \\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 的射线常微分方程系统。将你的推导特化到线性速度梯度模型\n$$\nc(z) = c_0 + g z,\n$$\n其中 $c_0$ 和 $g$ 是常数，$c_0 > 0$ 且 $g \\ge 0$。\n\n$2.$ 推导相关的关于状态对初始出射角 $\\theta$ 的偏导数的一阶变分（敏感性）方程。在震源深度 $z = z_S$ 处，初始慢度矢量的大小为 $1/c(z_S)$，方向 $\\theta$ 为与正 $x$ 轴的夹角（以弧度为单位）。具体地，令 $\\mathbf{y}_\\theta = \\partial \\mathbf{y} / \\partial \\theta$。推导线性时变系统\n$$\n\\frac{d}{dt} \\mathbf{y}_\\theta = \\mathbf{A}(t) \\, \\mathbf{y}_\\theta,\n$$\n其中 $\\mathbf{A}(t) = \\dfrac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}\\big\\rvert_{\\mathbf{y}(t)}$，并提供 $\\mathbf{y}_\\theta$ 关于 $\\theta$ 和 $c(z_S)$ 的初始条件。\n\n$3.$ 实现两种数值策略，用于从震源位置 $\\mathbf{x}_S = (x_S, z_S)$ 靶向接收点位置 $\\mathbf{x}_R = (x_R, z_R)$：\n\n$3.1.$ 打靶法（无导数优化）：构建并数值最小化失配\n$$\n\\Phi(\\theta, t_f) = \\left\\| \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R \\right\\|_2^2,\n$$\n该失配是关于出射角 $\\theta$ 和最终走时 $t_f$ 的函数，并受制于将 $(\\theta, t_f)$ 映射到最终位置 $\\mathbf{x}(\\theta, t_f)$ 的射线常微分方程约束。使用一个稳健的无导数方法来找到近似最小化 $\\Phi$ 的 $(\\hat{\\theta}_{\\mathrm{shoot}}, \\hat{t}_{\\mathrm{shoot}})$。确保在搜索过程中 $t_f$ 保持严格为正。\n\n$3.2.$ 两点边值牛顿法：将边值问题描述为求解 $(\\theta, t_f)$ 使得\n$$\n\\mathbf{F}(\\theta, t_f) = \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R = \\mathbf{0}.\n$$\n成立。推导并实现牛顿迭代\n$$\n\\begin{bmatrix}\n\\theta \\\\\nt_f\n\\end{bmatrix}_{k+1}\n=\n\\begin{bmatrix}\n\\theta \\\\\nt_f\n\\end{bmatrix}_{k}\n-\n\\mathbf{J}(\\theta_k, t_{f,k})^{-1}\n\\mathbf{F}(\\theta_k, t_{f,k}),\n$$\n其中雅可比矩阵 $\\mathbf{J} \\in \\mathbb{R}^{2 \\times 2}$ 的列为 $\\partial \\mathbf{x}/\\partial \\theta$ 和 $\\partial \\mathbf{x}/\\partial t_f$。用 $t_f$ 时刻的射线状态解析地表示第二列，并通过积分任务 $2$ 中的变分方程来计算第一列。如果需要，使用合适的步长阻尼策略以确保收敛。\n\n$4.$ 数值实现要求：\n\n$4.1.$ 介质：使用线性速度模型 $c(z) = c_0 + g z$。\n\n$4.2.$ 单位：位置使用米，速度使用米/秒，时间使用秒。出射角必须以弧度为单位。\n\n$4.3.$ 积分：为射线常微分方程和耦合的变分方程实现一个固定步长的显式四阶龙格-库塔方法。通过选择一个合理的、作为 $t_f$ 函数的步数，来确保稳定性和准确性。\n\n$4.4.$ 初始猜测：对于两种方法，均使用直线几何猜测\n$$\n\\theta_0 = \\operatorname{atan2}(z_R - z_S, x_R - x_S), \\quad\nt_{0} = \\frac{\\sqrt{(x_R - x_S)^2 + (z_R - z_S)^2}}{\\bar{c}},\n$$\n其中 $\\bar{c} = c_0 + g \\, (z_S + z_R)/2$。\n\n$5.$ 测试套件和输出：\n\n实现你的程序以运行以下三个测试案例，并生成单行输出，该输出包含一个由方括号括起来的逗号分隔列表，每个测试案例按顺序包含三个浮点数。对于每个测试案例，生成：\n\n- 两种方法得到的出射角绝对差， $|\\hat{\\theta}_{\\mathrm{shoot}} - \\hat{\\theta}_{\\mathrm{Newton}}|$，单位为弧度。\n- 两种方法得到的最终走时绝对差， $|\\hat{t}_{\\mathrm{shoot}} - \\hat{t}_{\\mathrm{Newton}}|$，单位为秒。\n- 两点边值方法的最终残差范数， $\\left\\| \\mathbf{F}(\\hat{\\theta}_{\\mathrm{Newton}}, \\hat{t}_{\\mathrm{Newton}}) \\right\\|_2$，单位为米。\n\n将所有测试案例的结果按案例顺序汇总到一个扁平列表中。\n\n使用以下测试套件：\n\n- 案例 $1$ (happy path)：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (3000, 1500)$ m。\n- 案例 $2$ (boundary case: constant velocity)：$c_0 = 2000$ m/s, $g = 0.0$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (4000, 1000)$ m。\n- 案例 $3$ (edge targeting with shallow depth and long range)：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (6000, 500)$ m。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，并严格遵循此顺序：\n$[$案例$1$角度差, 案例$1$时间差, 案例$1$残差, 案例$2$角度差, 案例$2$时间差, 案例$2$残差, 案例$3$角度差, 案例$3$时间差, 案例$3$残差$]$。所有值都必须是浮点数，并使用上述指定单位。不允许有其他额外输出。", "solution": "我们从各向同性介质中的程函方程开始，该方程用走时场 $T(\\mathbf{x})$ 表示为 $\\lVert \\nabla T \\rVert = 1/c(\\mathbf{x})$，其中 $c(\\mathbf{x})$ 是波速。引入慢度矢量 $\\mathbf{p} = \\nabla T$，其分量为 $p = \\partial T / \\partial x$ 和 $q = \\partial T / \\partial z$，我们采用哈密顿量\n$$\nH(\\mathbf{x}, \\mathbf{p}) = \\frac{1}{2} c(\\mathbf{x})^2 \\lVert \\mathbf{p} \\rVert^2 - \\frac{1}{2},\n$$\n它在物理射线上强制执行程函约束 $H = 0$。用走时 $t$ 对射线进行参数化，哈密顿方程给出\n$$\n\\frac{d \\mathbf{x}}{dt} = \\frac{\\partial H}{\\partial \\mathbf{p}}, \\qquad\n\\frac{d \\mathbf{p}}{dt} = - \\frac{\\partial H}{\\partial \\mathbf{x}}.\n$$\n写作 $\\mathbf{x} = (x,z)$ 和 $\\mathbf{p} = (p,q)$，我们计算\n$$\n\\frac{dx}{dt} = \\frac{\\partial H}{\\partial p} = c(\\mathbf{x})^2 \\, p, \\qquad\n\\frac{dz}{dt} = \\frac{\\partial H}{\\partial q} = c(\\mathbf{x})^2 \\, q,\n$$\n以及\n$$\n\\frac{dp}{dt} = - \\frac{\\partial H}{\\partial x} = - \\frac{1}{2} \\frac{\\partial (c^2)}{\\partial x} \\, (p^2 + q^2), \\qquad\n\\frac{dq}{dt} = - \\frac{\\partial H}{\\partial z} = - \\frac{1}{2} \\frac{\\partial (c^2)}{\\partial z} \\, (p^2 + q^2).\n$$\n对于垂直分层介质 $c(\\mathbf{x}) = c(z)$，我们有 $\\partial (c^2)/\\partial x = 0$，因此\n$$\n\\frac{dp}{dt} = 0, \\qquad\n\\frac{dq}{dt} = - \\frac{1}{2} \\frac{d (c^2)}{dz} (p^2+q^2).\n$$\n特化到线性梯度模型\n$$\nc(z) = c_0 + g z,\n$$\n其中 $c_0 > 0$ 且 $g \\ge 0$，我们有\n$$\n\\frac{d (c^2)}{dz} = \\frac{d}{dz} \\big( (c_0 + g z)^2 \\big) = 2 (c_0 + g z) g = 2 c g.\n$$\n因此，射线常微分方程系统变为\n$$\n\\frac{dx}{dt} = c^2 p, \\qquad\n\\frac{dz}{dt} = c^2 q, \\qquad\n\\frac{dp}{dt} = 0, \\qquad\n\\frac{dq}{dt} = - c g \\, (p^2 + q^2),\n$$\n其中 $c = c(z) = c_0 + g z$。注意，沿着射线，$H = 0$ 意味着 $c^2(p^2+q^2) = 1$，因此 $p^2+q^2 = 1/c^2$，但我们不在常微分方程的右端项中显式地强制执行此恒等式，以保持一致的变分形式。\n\n震源 $\\mathbf{x}_S = (x_S, z_S)$ 处的初始条件由一个出射角 $\\theta$ 定义，该角度是以弧度为单位从正 $x$ 轴测量的。初始慢度大小为 $1/c(z_S)$，所以\n$$\nx(0) = x_S, \\quad z(0) = z_S, \\quad p(0) = \\frac{\\cos \\theta}{c(z_S)}, \\quad q(0) = \\frac{\\sin \\theta}{c(z_S)}.\n$$\n\n对于关于 $\\theta$ 的变分方程，令 $\\mathbf{y} = (x,z,p,q)^\\top$ 且 $\\mathbf{y}_\\theta = \\partial \\mathbf{y}/\\partial \\theta$。线性化的动力学方程为\n$$\n\\frac{d}{dt} \\mathbf{y}_\\theta = \\mathbf{A}(t) \\, \\mathbf{y}_\\theta,\n$$\n其中 $\\mathbf{A}(t) = \\partial \\mathbf{f} / \\partial \\mathbf{y}$ 是沿射线计算的射线方程右端项的雅可比矩阵。记 $c = c(z)$ 和 $c^2 = c^2(z)$，\n$$\n\\mathbf{f}(\\mathbf{y}) =\n\\begin{bmatrix}\nc^2 p \\\\\nc^2 q \\\\\n0 \\\\\n- \\tfrac{1}{2} \\, \\frac{d (c^2)}{dz} \\, (p^2 + q^2)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nc^2 p \\\\\nc^2 q \\\\\n0 \\\\\n- c g \\, (p^2 + q^2)\n\\end{bmatrix}.\n$$\n雅可比矩阵的元素通过偏导数计算。使用 $\\frac{d (c^2)}{dz} = 2 c g$ 和 $\\frac{d^2 (c^2)}{dz^2} = 2 g^2$，我们得到\n$$\n\\frac{\\partial f_1}{\\partial x} = 0, \\quad\n\\frac{\\partial f_1}{\\partial z} = \\frac{d (c^2)}{dz} \\, p = 2 c g \\, p, \\quad\n\\frac{\\partial f_1}{\\partial p} = c^2, \\quad\n\\frac{\\partial f_1}{\\partial q} = 0,\n$$\n$$\n\\frac{\\partial f_2}{\\partial x} = 0, \\quad\n\\frac{\\partial f_2}{\\partial z} = \\frac{d (c^2)}{dz} \\, q = 2 c g \\, q, \\quad\n\\frac{\\partial f_2}{\\partial p} = 0, \\quad\n\\frac{\\partial f_2}{\\partial q} = c^2,\n$$\n$$\n\\frac{\\partial f_3}{\\partial x} = 0, \\quad\n\\frac{\\partial f_3}{\\partial z} = 0, \\quad\n\\frac{\\partial f_3}{\\partial p} = 0, \\quad\n\\frac{\\partial f_3}{\\partial q} = 0,\n$$\n$$\n\\frac{\\partial f_4}{\\partial x} = 0, \\quad\n\\frac{\\partial f_4}{\\partial z} = - \\frac{1}{2} \\frac{d^2 (c^2)}{dz^2} (p^2 + q^2) = - g^2 (p^2 + q^2), \\quad\n\\frac{\\partial f_4}{\\partial p} = - \\frac{d (c^2)}{dz} \\, p = - 2 c g \\, p, \\quad\n\\frac{\\partial f_4}{\\partial q} = - \\frac{d (c^2)}{dz} \\, q = - 2 c g \\, q.\n$$\n因此 $\\mathbf{A}(t)$ 是填入这些元素的 $4 \\times 4$ 矩阵。\n\n变分状态 $\\mathbf{y}_\\theta$ 的初始条件通过对初始状态关于 $\\theta$ 求导得出：\n$$\n\\left. \\frac{\\partial x}{\\partial \\theta} \\right|_{t=0} = 0, \\quad\n\\left. \\frac{\\partial z}{\\partial \\theta} \\right|_{t=0} = 0, \\quad\n\\left. \\frac{\\partial p}{\\partial \\theta} \\right|_{t=0} = - \\frac{\\sin \\theta}{c(z_S)}, \\quad\n\\left. \\frac{\\partial q}{\\partial \\theta} \\right|_{t=0} = \\frac{\\cos \\theta}{c(z_S)}.\n$$\n\n现在我们概述两种数值策略。\n\n对于打靶法，我们定义一个失配函数\n$$\n\\Phi(\\theta, t_f) = \\left\\| \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R \\right\\|_2^2,\n$$\n其中 $\\mathbf{x}(\\theta, t_f)$ 是通过将射线常微分方程从 $t = 0$ 积分到 $t = t_f$（初始条件由 $\\theta$ 设定）得到的。采用对 $(\\theta, t_f)$ 的无导数搜索来最小化 $\\Phi$，通过惩罚来强制 $t_f > 0$。通过合理的初始猜测和对 $t_f$ 的边界约束来增强稳健性。\n\n对于两点边值牛顿法，我们求解 $\\mathbf{F}(\\theta, t_f) = \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R = \\mathbf{0}$。牛顿步长为\n$$\n\\begin{bmatrix}\n\\delta \\theta \\\\\n\\delta t_f\n\\end{bmatrix}\n=\n\\mathbf{J}(\\theta, t_f)^{-1}\n\\left( - \\mathbf{F}(\\theta, t_f) \\right),\n$$\n更新方式为 $(\\theta, t_f) \\leftarrow (\\theta, t_f) + \\alpha \\, (\\delta \\theta, \\delta t_f)$，使用一个阻尼因子 $\\alpha \\in (0,1]$，该因子通过回溯法选择，以减小 $\\lVert \\mathbf{F} \\rVert_2$。雅可比矩阵的列是\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial \\theta} (t_f) = \\begin{bmatrix} \\partial x / \\partial \\theta \\\\ \\partial z / \\partial \\theta \\end{bmatrix}(t_f),\n\\quad\n\\frac{\\partial \\mathbf{x}}{\\partial t_f} (t_f) = \\frac{d \\mathbf{x}}{dt} (t_f) = \\begin{bmatrix} c(t_f)^2 p(t_f) \\\\ c(t_f)^2 q(t_f) \\end{bmatrix}.\n$$\n第一列通过将变分方程与射线常微分方程同时积分来计算，从上面给出的初始条件开始。第二列是时间 $t_f$ 时的射线速度。\n\n对于数值积分，我们对射线状态和变分状态都应用了固定步长的显式四阶龙格-库塔方案。通过选择与 $t_f$ 成比例的步数并强制一个最小步数来控制精度。\n\n我们采用直线初始猜测\n$$\n\\theta_0 = \\operatorname{atan2}(z_R - z_S, x_R - x_S), \\quad\nt_0 = \\frac{\\sqrt{(x_R - x_S)^2 + (z_R - z_S)^2}}{\\bar{c}},\n\\quad \\bar{c} = c_0 + g \\, \\frac{z_S + z_R}{2},\n$$\n这对于速度平滑变化的介质是合理的。\n\n每个测试案例的输出包括出射角绝对差 $|\\hat{\\theta}_{\\mathrm{shoot}} - \\hat{\\theta}_{\\mathrm{Newton}}|$（弧度）、时间绝对差 $|\\hat{t}_{\\mathrm{shoot}} - \\hat{t}_{\\mathrm{Newton}}|$（秒）以及最终牛顿法残差 $\\lVert \\mathbf{F}(\\hat{\\theta}_{\\mathrm{Newton}}, \\hat{t}_{\\mathrm{Newton}}) \\rVert_2$（米）。对于 $g = 0$ 的恒速情况，射线是一条直线；因此两种方法的结果应在数值公差范围内一致，产生非常小的差异和残差。\n\n最后，我们实现三个测试案例：\n\n- 案例 $1$：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (3000,1500)$ m。\n- 案例 $2$：$c_0 = 2000$ m/s, $g = 0.0$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (4000,1000)$ m。\n- 案例 $3$：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (6000,500)$ m。\n\n一个具有足够步长分辨率和牛顿更新中带有阻尼的稳健实现，对所有三个案例都会产生两种方法之间的微小差异和接近零的残差。程序会按规定顺序生成包含 9 个聚合浮点数的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Ray ODEs in 2D isotropic medium with linear vertical velocity gradient c(z) = c0 + g*z.\n# State y = [x, z, p, q], where p=Tx, q=Tz are slowness components. Parametrized by traveltime t.\n\ndef c_and_derivs(z, c0, g):\n    c = c0 + g * z\n    c2 = c * c\n    dc2_dz = 2.0 * c * g\n    d2c2_dz2 = 2.0 * g * g\n    return c, c2, dc2_dz, d2c2_dz2\n\ndef ray_rhs(y, c0, g):\n    x, z, p, q = y\n    c, c2, dc2_dz, _ = c_and_derivs(z, c0, g)\n    dxdt = c2 * p\n    dzdt = c2 * q\n    dpdt = 0.0\n    dqdt = -0.5 * dc2_dz * (p*p + q*q)  # = -c*g*(p^2+q^2)\n    return np.array([dxdt, dzdt, dpdt, dqdt], dtype=float)\n\ndef jacobian_A(y, c0, g):\n    # Jacobian of ray_rhs with respect to state y = [x,z,p,q]\n    x, z, p, q = y\n    c, c2, dc2_dz, d2c2_dz2 = c_and_derivs(z, c0, g)\n    # Initialize 4x4 zero matrix\n    A = np.zeros((4,4), dtype=float)\n    # df1/dz = (dc2/dz)*p, df1/dp = c2\n    A[0,1] = dc2_dz * p\n    A[0,2] = c2\n    # df2/dz = (dc2/dz)*q, df2/dq = c2\n    A[1,1] = dc2_dz * q\n    A[1,3] = c2\n    # df3 all zeros\n    # df4/dz = -0.5 * d2c2/dz2 * (p^2+q^2)\n    A[3,1] = -0.5 * d2c2_dz2 * (p*p + q*q)\n    # df4/dp = - (dc2/dz) * p\n    A[3,2] = - dc2_dz * p\n    # df4/dq = - (dc2/dz) * q\n    A[3,3] = - dc2_dz * q\n    return A\n\ndef rk4_step(y, dt, func, *fargs):\n    k1 = func(y, *fargs)\n    k2 = func(y + 0.5*dt*k1, *fargs)\n    k3 = func(y + 0.5*dt*k2, *fargs)\n    k4 = func(y + dt*k3, *fargs)\n    return y + (dt/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=False):\n    # Initial conditions\n    cS = c0 + g * zS\n    p0 = np.cos(theta) / cS\n    q0 = np.sin(theta) / cS\n    y = np.array([xS, zS, p0, q0], dtype=float)\n\n    # Sensitivity initial condition dy/dtheta at t=0\n    if with_sensitivity:\n        dxdth = 0.0\n        dzdth = 0.0\n        dpdth = -np.sin(theta) / cS\n        dqdth =  np.cos(theta) / cS\n        Yth = np.array([dxdth, dzdth, dpdth, dqdth], dtype=float)\n    else:\n        Yth = None\n\n    # Time stepping\n    t_end = tf\n    # Ensure minimum steps for stability and accuracy\n    nsteps = max(400, int(np.ceil(200.0 * t_end))) if t_end > 0 else 400\n    dt = t_end / nsteps if nsteps > 0 else 0.0\n\n    if dt == 0.0:\n        if with_sensitivity:\n            return y, Yth\n        else:\n            return y\n\n    for _ in range(nsteps):\n        # Standard RK4 for state\n        y = rk4_step(y, dt, ray_rhs, c0, g)\n        if with_sensitivity:\n            # Variational equation: dYth/dt = A(t) * Yth\n            def var_rhs(Y, c0_, g_):\n                A = jacobian_A(y, c0_, g_)\n                return A @ Y\n            Yth = rk4_step(Yth, dt, var_rhs, c0, g)\n\n    if with_sensitivity:\n        return y, Yth\n    else:\n        return y\n\ndef straight_line_guess(xS, zS, xR, zR, c0, g):\n    dx = xR - xS\n    dz = zR - zS\n    theta0 = np.arctan2(dz, dx)\n    dist = np.hypot(dx, dz)\n    cbar = c0 + g * 0.5 * (zS + zR)\n    # Prevent division by zero\n    cbar = max(cbar, 1e-6)\n    t0 = dist / cbar\n    # Ensure positive time\n    t0 = max(t0, 1e-3)\n    return theta0, t0\n\ndef shooting_method(xS, zS, xR, zR, c0, g):\n    theta0, t0 = straight_line_guess(xS, zS, xR, zR, c0, g)\n\n    def phi(vars_):\n        th, tf = vars_\n        # Penalize non-positive time\n        if tf <= 0.0 or tf > 50.0:\n            return 1e20 + (abs(tf) + 1.0) * 1e20\n        y = integrate_ray(th, tf, c0, g, xS, zS, with_sensitivity=False)\n        xr, zr = y[0], y[1]\n        dx = xr - xR\n        dz = zr - zR\n        return dx*dx + dz*dz\n\n    x0 = np.array([theta0, t0], dtype=float)\n    res = minimize(phi, x0, method='Nelder-Mead', options=dict(maxiter=400, xatol=1e-8, fatol=1e-12, disp=False))\n    th_opt, tf_opt = res.x\n    # Clamp final time\n    tf_opt = max(tf_opt, 1e-6)\n    return th_opt, tf_opt\n\ndef newton_two_point(xS, zS, xR, zR, c0, g, max_iter=30, tol=1e-8):\n    theta, tf = straight_line_guess(xS, zS, xR, zR, c0, g)\n    # Newton iterations with backtracking\n    for _ in range(max_iter):\n        # Integrate ray and sensitivity\n        y, Yth = integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=True)\n        x_tf, z_tf, p_tf, q_tf = y\n        # Residual F = x(tf) - xR, z(tf) - zR\n        F = np.array([x_tf - xR, z_tf - zR], dtype=float)\n        res_norm = np.linalg.norm(F)\n        if res_norm < tol:\n            return theta, tf, res_norm\n        # Jacobian columns\n        # Column 1: d x / d theta, d z / d theta from Yth\n        J_col1 = np.array([Yth[0], Yth[1]], dtype=float)\n        # Column 2: d x / d tf = dx/dt, d z / d tf = dz/dt\n        c_tf, c2_tf, _, _ = c_and_derivs(z_tf, c0, g)\n        J_col2 = np.array([c2_tf * p_tf, c2_tf * q_tf], dtype=float)\n        J = np.column_stack([J_col1, J_col2])\n\n        # Solve for Newton step via least squares (in case of near-singularity)\n        try:\n            delta, *_ = np.linalg.lstsq(J, -F, rcond=None)\n        except np.linalg.LinAlgError:\n            # Fallback small perturbation\n            delta = np.array([0.0, 0.0])\n\n        dtheta, dtf = delta\n\n        # Backtracking line search\n        alpha = 1.0\n        improved = False\n        for _ls in range(12):\n            th_try = theta + alpha * dtheta\n            tf_try = tf + alpha * dtf\n            if tf_try <= 0.0:\n                alpha *= 0.5\n                continue\n            y_try = integrate_ray(th_try, tf_try, c0, g, xS, zS, with_sensitivity=False)\n            F_try = np.array([y_try[0] - xR, y_try[1] - zR], dtype=float)\n            if np.linalg.norm(F_try) < res_norm:\n                theta = th_try\n                tf = tf_try\n                improved = True\n                break\n            alpha *= 0.5\n        if not improved:\n            # Could not improve; terminate\n            break\n    # Final residual\n    y = integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=False)\n    F = np.array([y[0] - xR, y[1] - zR], dtype=float)\n    res_norm = np.linalg.norm(F)\n    return theta, tf, res_norm\n\ndef run_case(c0, g, xS, zS, xR, zR):\n    # Shooting method\n    th_shoot, tf_shoot = shooting_method(xS, zS, xR, zR, c0, g)\n    # Newton two-point boundary method\n    th_newt, tf_newt, res_newt = newton_two_point(xS, zS, xR, zR, c0, g)\n\n    dtheta = abs(th_shoot - th_newt)\n    dt = abs(tf_shoot - tf_newt)\n    return float(dtheta), float(dt), float(res_newt)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: c0=2000 m/s, g=0.5 s^-1, S=(0,0) m, R=(3000,1500) m\n    # Case 2: c0=2000 m/s, g=0.0 s^-1, S=(0,0) m, R=(4000,1000) m\n    # Case 3: c0=2000 m/s, g=0.5 s^-1, S=(0,0) m, R=(6000,500) m\n    test_cases = [\n        (2000.0, 0.5, 0.0, 0.0, 3000.0, 1500.0),\n        (2000.0, 0.0, 0.0, 0.0, 4000.0, 1000.0),\n        (2000.0, 0.5, 0.0, 0.0, 6000.0, 500.0),\n    ]\n\n    results = []\n    for c0, g, xS, zS, xR, zR in test_cases:\n        dtheta, dt, res = run_case(c0, g, xS, zS, xR, zR)\n        results.extend([dtheta, dt, res])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3614051"}]}