{"hands_on_practices": [{"introduction": "Crank-Nicolson 格式虽然具有二阶时间和空间精度，但在处理不连续或非光滑初始条件（例如地球物理学中的岩脉侵入）时，会产生非物理性的数值振荡。本练习将指导您实现并比较三种常见的启动策略，以抑制这些振荡，从而加深您对 Crank-Nicolson 格式实际局限性及其解决方案的理解。通过量化过冲和误差，您将获得选择最合适数值方案的实践经验 [@problem_id:3616320]。", "problem": "考虑一维热传导方程（计算地球物理学中一种典型的抛物型偏微分方程），该方程建立在一个表示对称岩脉冷却基准问题的有限线段上。在无量纲设定下进行研究，其中热扩散率、空间、时间和温度均为无量纲。该问题定义在空间域 $x \\in [-L,L]$ 上，其狄利克雷边界条件为 $u(-L,t)=T_c$ 和 $u(L,t)=T_c$，并具有一个不连续的初始条件，表示嵌入冷宿主岩中的热岩脉：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}, \\quad u(x,0) = \\begin{cases}\nT_h,  & |x|\\le a,\\\\\nT_c,  & |x|>a,\n\\end{cases}\n\\quad u(-L,t)=T_c,\\; u(L,t)=T_c.\n$$\n此处，$u(x,t)$ 是无量纲温度，$\\kappa$ 是无量纲热扩散率，$T_h$ 是无量纲高温，$T_c$ 是无量纲低温，$a$ 是岩脉的无量纲半宽度。由于 $u(x,0)$ 是不连续的，已知某些时间离散化方法会产生非物理的类吉布斯振荡（Gibbs-like oscillations），特别是梯形法则（亦称为 Crank–Nicolson 方法）。您的任务是研究 Crank–Nicolson 方法在早期时间的三种启动策略，并根据 $L^{\\infty}$ 过冲和 $L^2$ 误差来定量比较它们的行为。\n\n您必须在空间上使用间距为 $\\Delta x$ 的均匀网格，在时间上使用均匀的时间步长 $\\Delta t$。请考虑以下三种策略：\n- 纯 Crank–Nicolson (CN) 方法：从 $t=0$ 开始的所有时间步都应用 Crank–Nicolson 格式。\n- 后向欧拉至 Crank–Nicolson (BE$\\rightarrow$CN) 方法：使用后向欧拉法进行指定数量 $m$ 的启动步骤，然后切换到 Crank–Nicolson 法完成剩余步骤。这种方法在数值分析文献中有时被称为 Rannacher 启动。\n- 带时间滤波器的 Crank–Nicolson (CN+TF) 方法：在每个时间步 $n \\ge 1$，计算出 Crank–Nicolson 更新值 $u^{n+1}$ 后，对内部网格点值应用一个三层时间滤波器：\n$$\nu^{n+1} \\leftarrow u^{n+1} + \\alpha\\left(u^{n} - 2u^{n+1} + u^{n-1}\\right),\n$$\n其中 $\\alpha$ 是给定的滤波强度。在 $n=0$ 时，如果需要，使用 $u^{-1}=u^{0}$ 进行滤波。\n\n您必须在早期时间窗口 $t \\in [0,T_{\\mathrm{end}}]$ 内计算两个定量诊断指标：\n- 整个早期时间演化过程中的 $L^{\\infty}$ 过冲幅度，定义为\n$$\n\\max_{0\\le n\\le N}\\left(\\max_x u^n(x) - \\max_x u^0(x),\\,0\\right),\n$$\n该值测量任何超过初始最大值的正向偏移。请将其报告为一个非负标量。\n- 在 $t=T_{\\mathrm{end}}$ 时，与给定不连续初始条件的无限域解析解计算的 $L^2$ 误差：\n$$\nu_{\\mathrm{exact}}(x,t) = T_c + \\frac{T_h - T_c}{2}\\left[\\operatorname{erf}\\!\\left(\\frac{x+a}{2\\sqrt{\\kappa t}}\\right) - \\operatorname{erf}\\!\\left(\\frac{x-a}{2\\sqrt{\\kappa t}}\\right)\\right],\n$$\n使用在整个网格（包括端点）上、权重为 $\\Delta x$ 的离散 $L^2$ 范数：\n$$\n\\|u(\\cdot,T_{\\mathrm{end}})-u_{\\mathrm{exact}}(\\cdot,T_{\\mathrm{end}})\\|_{2} = \\left(\\Delta x \\sum_j \\left[u(x_j,T_{\\mathrm{end}})-u_{\\mathrm{exact}}(x_j,T_{\\mathrm{end}})\\right]^2\\right)^{1/2}.\n$$\n此处 $\\operatorname{erf}(\\cdot)$ 表示高斯误差函数。假设边界足够远，使得在指定的早期时间窗口内，无限域解是有效的参考解。\n\n您的空间离散化必须对内部节点使用标准的二阶中心有限差分来近似拉普拉斯算子，并在端点处使用狄利克雷边界条件。您的时间离散化必须实现全隐式后向欧拉格式和由其标准两层公式定义的 Crank–Nicolson 格式。所有量都是无量纲的，因此不需要物理单位。\n\n测试套件。对于下面的每个参数集，运行所有三种策略，并为每种策略计算由 $t \\in [0,T_{\\mathrm{end}}]$ 上的 $L^{\\infty}$ 过冲和 $t=T_{\\mathrm{end}}$ 时的 $L^2$ 误差组成的数值对。空间网格应为 $x_j = -L + j \\Delta x$，其中 $j=0,1,\\dots,N_x-1$，并假设 $N_x = 2L/\\Delta x + 1$ 为整数。时间网格应为 $t^n = n\\Delta t$，其中 $n=0,1,\\dots,N$，并假设 $N=T_{\\mathrm{end}}/\\Delta t$ 为整数。使用以下三种情况：\n- 情况 A（为引发振荡的粗糙时间步）：$L=5$, $a=1$, $\\kappa=1$, $\\Delta x=0.02$, $\\Delta t=0.02$, $T_{\\mathrm{end}}=0.1$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$。\n- 情况 B（中等时间步）：$L=5$, $a=0.5$, $\\kappa=1$, $\\Delta x=0.02$, $\\Delta t=0.002$, $T_{\\mathrm{end}}=0.04$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$。\n- 情况 C（精细分辨率）：$L=5$, $a=0.5$, $\\kappa=1$, $\\Delta x=0.01$, $\\Delta t=0.0001$, $T_{\\mathrm{end}}=0.01$, $T_h=1$, $T_c=0$, $m=2$, $\\alpha=0.1$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按以下顺序串联每个情况的六个浮点数结果：\n$$\n[\\text{overshoot}_{\\mathrm{CN}},\\; \\|e\\|_{2,\\mathrm{CN}},\\; \\text{overshoot}_{\\mathrm{BE\\rightarrow CN}},\\; \\|e\\|_{2,\\mathrm{BE\\rightarrow CN}},\\; \\text{overshoot}_{\\mathrm{CN+TF}},\\; \\|e\\|_{2,\\mathrm{CN+TF}}],\n$$\n然后先列出情况 A，再列出情况 B，最后列出情况 C，最终形成一个包含 18 个数字的扁平列表：\n$$\n[\\text{A}_{1},\\text{A}_{2},\\dots,\\text{A}_{6},\\text{B}_{1},\\dots,\\text{B}_{6},\\text{C}_{1},\\dots,\\text{C}_{6}].\n$$\n不应打印任何附加文本。所有计算和输出均为上述指定的无量纲标量。", "solution": "该问题要求对给定不连续初始条件的一维热传导方程（一种抛物型偏微分方程，PDE）进行数值求解。我们将研究三种旨在处理由此类初始数据引起的类吉布斯振荡的数值策略，特别是针对 Crank-Nicolson 方法。解决方案的开发将首先在空间和时间上对 PDE 进行离散化，然后实现指定的数值格式，最后计算所需的诊断指标。\n\n控制偏微分方程为：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}\n$$\n定义域为 $x \\in [-L, L]$ 和 $t \\ge 0$。初始条件是一个阶跃函数：\n$$\nu(x,0) = \\begin{cases}\nT_h,  & |x|\\le a,\\\\\nT_c,  & |x|>a,\n\\end{cases}\n$$\n狄利克雷边界条件为 $u(-L,t)=T_c$ 和 $u(L,t)=T_c$。\n\n首先，我们将空间域离散化为一个包含 $N_x$ 个点的均匀网格 $x_j = -L + j \\Delta x$，其中 $j=0, 1, \\dots, N_x-1$ 且 $\\Delta x = 2L / (N_x-1)$。时间域离散化为 $t^n = n \\Delta t$，其中 $n=0, 1, \\dots, N$ 且 $\\Delta t = T_{\\mathrm{end}}/N$。令 $u_j^n$ 表示 $u(x_j, t^n)$ 的数值近似。\n\n对于内部网格点（$j=1, \\dots, N_x-2$），空间二阶导数使用二阶中心有限差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t^n} \\approx \\frac{u_{j-1}^n - 2u_j^n + u_{j+1}^n}{(\\Delta x)^2}\n$$\n将此近似代入 PDE，得到一个常微分方程组（ODEs），这种方法称为直线法：\n$$\n\\frac{du_j}{dt} = \\frac{\\kappa}{(\\Delta x)^2} (u_{j-1} - 2u_j + u_{j+1})\n$$\n我们可以使用一个通用的 $\\theta$-格式来表示时间演化：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\kappa}{(\\Delta x)^2} \\left[ \\theta(u_{j-1}^{n+1} - 2u_j^{n+1} + u_{j+1}^{n+1}) + (1-\\theta)(u_{j-1}^n - 2u_j^n + u_{j+1}^n) \\right]\n$$\n其中 $\\theta=0$ 得到前向欧拉法，$\\theta=1$ 得到后向欧拉法，$\\theta=1/2$ 得到 Crank-Nicolson 方法。令 $\\lambda = \\frac{\\kappa \\Delta t}{(\\Delta x)^2}$ 为无量纲扩散数。重新整理方程，将时间层 $n+1$ 的项放在左侧（LHS），时间层 $n$ 的项放在右侧（RHS），得到：\n$$\n-\\theta\\lambda u_{j-1}^{n+1} + (1+2\\theta\\lambda)u_j^{n+1} - \\theta\\lambda u_{j+1}^{n+1} = (1-\\theta)\\lambda u_{j-1}^n + (1-2(1-\\theta)\\lambda)u_j^n + (1-\\theta)\\lambda u_{j+1}^n\n$$\n这表示一个关于内部网格点未知值 $u_j^{n+1}$ 的三对角线性方程组。\n\n三种策略的实现如下：\n\n1.  **纯 Crank–Nicolson (CN) 方法**：这对应于 $\\theta = 1/2$。该格式应用于每个时间步。内部节点的系统变为：\n    $$\n    -\\frac{\\lambda}{2} u_{j-1}^{n+1} + (1+\\lambda) u_j^{n+1} - \\frac{\\lambda}{2} u_{j+1}^{n+1} = \\frac{\\lambda}{2} u_{j-1}^{n} + (1-\\lambda) u_j^{n} + \\frac{\\lambda}{2} u_{j+1}^{n}\n    $$\n    该方法无条件稳定且时间上二阶精确，但当应用于具有非光滑初始数据的问题时，已知会产生伪振荡，因为该格式对高频模式的阻尼趋近于零。\n\n2.  **后向欧拉至 Crank–Nicolson (BE$\\rightarrow$CN) 方法**：该策略在前 $m$ 个时间步使用后向欧拉（BE）格式，然后切换到 Crank-Nicolson。BE 格式对应于 $\\theta=1$：\n    $$\n    -\\lambda u_{j-1}^{n+1} + (1+2\\lambda) u_j^{n+1} - \\lambda u_{j+1}^{n+1} = u_j^n\n    $$\n    BE 法在时间上是一阶的，并且是强耗散的（L-稳定），这能有效抑制由初始不连续性引起的高频振荡。经过几个初始 BE 步骤后，数值解变得平滑，之后可以切换到更精确的 CN 格式进行余下的模拟。\n\n3.  **带时间滤波器的 Crank–Nicolson (CN+TF) 方法**：该方法在每个标准 CN 步骤后应用一个滤波器来抑制振荡。在每个时间步 $n$，我们首先使用 CN 格式计算一个临时解 $\\tilde{u}^{n+1}$。然后，对内部节点应用一个三层滤波器：\n    $$\n    u^{n+1} \\leftarrow \\tilde{u}^{n+1} + \\alpha(u^{n} - 2\\tilde{u}^{n+1} + u^{n-1})\n    $$\n    滤波强度由 $\\alpha$ 给出。对于第一步（$n=0$），我们需要 $t^{-1} = -\\Delta t$ 处的值。根据规定，我们设置 $u^{-1} = u^0$，这将第一步的滤波器简化为 $u^1 \\leftarrow (1-2\\alpha)\\tilde{u}^1 + 2\\alpha u^0$。\n\n对于所有策略，每个时间步都使用高效的算法（如 `scipy.linalg.solve_banded`）来求解内部节点的三对角方程组。边界条件 $u_0^{n+1} = T_c$ 和 $u_{N_x-1}^{n+1} = T_c$ 被并入线性系统的第一个和最后一个方程中。由于测试用例中 $T_c=0$，这些边界项直接变为零。\n\n诊断指标的计算如下：\n-   **$L^{\\infty}$ 过冲**：在每个时间步 $n$ 跟踪最大温度。在步骤 $n$ 的过冲是 $\\max_j u_j^n - \\max_j u_j^0$。最终报告的值是该量在所有时间步 $n \\in [0, N]$ 上的最大值，且不小于 0。\n-   **$L^2$ 误差**：在最终时间 $T_{\\mathrm{end}}$，根据给定的无限域解析解计算误差：\n    $$\n    u_{\\mathrm{exact}}(x,t) = T_c + \\frac{T_h - T_c}{2}\\left[\\operatorname{erf}\\!\\left(\\frac{x+a}{2\\sqrt{\\kappa t}}\\right) - \\operatorname{erf}\\!\\left(\\frac{x-a}{2\\sqrt{\\kappa t}}\\right)\\right]\n    $$\n    然后在所有网格点（包括边界）上计算离散 $L^2$ 范数：\n    $$\n    \\|e\\|_{2} = \\left(\\Delta x \\sum_{j=0}^{N_x-1} \\left[u_j^N - u_{\\mathrm{exact}}(x_j, T_{\\mathrm{end}})\\right]^2\\right)^{1/2}\n    $$\n总体实现涉及一个主函数，该函数遍历所提供的测试用例。对于每个用例，它设置网格和初始条件，然后为三种策略中的每一种运行模拟。每个模拟执行时间步进循环，在每一步求解线性系统，并应用任何所需的滤波。模拟结束后，计算并收集诊断数据以用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef setup_simulation(params):\n    \"\"\"Sets up grid and initial conditions.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    \n    # Grid setup\n    Nx = int(round(2 * L / dx)) + 1\n    x = np.linspace(-L, L, Nx)\n    Nt = int(round(T_end / dt))\n    \n    # Nondimensional diffusion number\n    lambda_ = kappa * dt / (dx**2)\n    \n    # Initial Condition\n    u0 = np.full(Nx, Tc)\n    u0[np.abs(x) = a] = Th\n    \n    return x, Nx, Nt, lambda_, u0, Tc\n\ndef get_analytical_solution(x, t, params):\n    \"\"\"Computes the analytical solution.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    if t == 0:\n        # Handle t=0 case separately to avoid division by zero\n        u_exact = np.full_like(x, Tc)\n        u_exact[np.abs(x) = a] = Th\n        return u_exact\n    \n    denom = 2.0 * np.sqrt(kappa * t)\n    arg1 = (x + a) / denom\n    arg2 = (x - a) / denom\n    u_exact = Tc + (Th - Tc) / 2.0 * (erf(arg1) - erf(arg2))\n    return u_exact\n\ndef run_simulation(params, strategy):\n    \"\"\"Runs a single simulation for a given strategy.\"\"\"\n    L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha = params\n    x, Nx, Nt, lambda_, u0, Tc = setup_simulation(params)\n    \n    u_curr = u0.copy()\n    max_initial_temp = np.max(u0)\n    max_overshoot = 0.0\n    \n    num_interior_nodes = Nx - 2\n\n    # --- Strategy-specific setup ---\n    \n    # Pure CN\n    if strategy == 'CN' or strategy == 'CN_TF' or (strategy == 'BE_CN' and Nt > m):\n        ab_cn = np.zeros((3, num_interior_nodes))\n        ab_cn[0, 1:] = -lambda_ / 2.0\n        ab_cn[1, :] = 1.0 + lambda_\n        ab_cn[2, :-1] = -lambda_ / 2.0\n    \n    # BE\n    if strategy == 'BE_CN':\n        if m > 0:\n            ab_be = np.zeros((3, num_interior_nodes))\n            ab_be[0, 1:] = -lambda_\n            ab_be[1, :] = 1.0 + 2.0 * lambda_\n            ab_be[2, :-1] = -lambda_\n    \n    # CN+TF\n    if strategy == 'CN_TF':\n        u_prev = u0.copy()\n\n    # --- Time-stepping loop ---\n    for n in range(Nt):\n        # Select scheme for BE->CN\n        if strategy == 'BE_CN' and n  m:\n            ab = ab_be\n            rhs = u_curr[1:-1]\n        else: # CN for all other cases\n            ab = ab_cn\n            rhs = (lambda_ / 2.0) * (u_curr[:-2] + u_curr[2:]) + (1.0 - lambda_) * u_curr[1:-1]\n\n        # Solve for interior nodes\n        u_next_interior = solve_banded((1, 1), ab, rhs)\n        \n        u_next = np.empty(Nx)\n        u_next[0], u_next[-1] = Tc, Tc\n        u_next[1:-1] = u_next_interior\n        \n        # Apply Time Filter if required\n        if strategy == 'CN_TF':\n            u_tilde = u_next.copy()\n            # The filter expression u_new = u_tilde + alpha*(u_curr - 2*u_tilde + u_prev)\n            # rearranged is u_new = (1-2*alpha)*u_tilde + alpha*u_curr + alpha*u_prev\n            u_next[1:-1] = (1.0 - 2.0 * alpha) * u_tilde[1:-1] + alpha * (u_curr[1:-1] + u_prev[1:-1])\n            u_prev[:] = u_curr\n        \n        # Update solution for next step\n        u_curr[:] = u_next\n        \n        # Update overshoot diagnostic\n        current_max = np.max(u_curr)\n        overshoot = current_max - max_initial_temp\n        if overshoot > max_overshoot:\n            max_overshoot = overshoot\n\n    # --- Final diagnostics ---\n    u_final = u_curr\n    u_exact = get_analytical_solution(x, T_end, params)\n    \n    # L2 Error\n    error_vec = u_final - u_exact\n    l2_error = np.sqrt(dx * np.sum(error_vec**2))\n    \n    return max_overshoot, l2_error\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case A (L, a, kappa, dx, dt, T_end, Th, Tc, m, alpha)\n        (5.0, 1.0, 1.0, 0.02, 0.02, 0.1, 1.0, 0.0, 2, 0.1),\n        # Case B\n        (5.0, 0.5, 1.0, 0.02, 0.002, 0.04, 1.0, 0.0, 2, 0.1),\n        # Case C\n        (5.0, 0.5, 1.0, 0.01, 0.0001, 0.01, 1.0, 0.0, 2, 0.1)\n    ]\n    \n    strategies = ['CN', 'BE_CN', 'CN_TF']\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        for strategy in strategies:\n            overshoot, l2_error = run_simulation(case_params, strategy)\n            all_results.append(overshoot)\n            all_results.append(l2_error)\n            \n    # Format results for printing\n    result_str = \",\".join(f\"{res:.8f}\" for res in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3616320"}, {"introduction": "一个高效数值方案的设计不仅在于实现，更在于对误差的精确控制。本练习将引导您从理论层面深入分析 Crank-Nicolson 格式的精度，通过对离散算子最差模式的分析，设计一个基于精度的自适应时间步长控制器。您将学习如何根据给定的幅度和相位误差容限，推导出最优的无量纲时间步长参数 $r$，从而将数值分析理论与实际的模拟参数选择紧密联系起来 [@problem_id:3616370]。", "problem": "你的任务是为应用于岩石圈冷却背景下抛物线方程的 Crank-Nicolson 格式设计并实现一个基于精度的时间步长控制器。其基础物理模型是一维热扩散方程，用于描述代表岩石圈片段的有限厚板中的温度演化，\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2},\n$$\n该方程定义在区间 $x \\in [0,L]$ 上，并带有齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(L,t) = 0$。这里，$u(x,t)$ 是温度，$\\kappa$ 是热扩散系数，$L$ 是厚板的厚度。空间上的离散化使用一个包含 $N$ 个内部点的均匀网格，网格间距为 $\\Delta x = L/(N+1)$，由此产生半离散系统\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{\\Delta x^2} \\mathbf{L}\\,\\mathbf{u},\n$$\n其中 $\\mathbf{L}$ 是带有齐次狄利克雷条件的经典二阶差分矩阵。时间积分使用 Crank-Nicolson 方法，其无量纲参数为 $r = \\kappa\\,\\Delta t/\\Delta x^2$，其中 $\\Delta t$ 是时间步长。\n\n你的任务是校准无量纲参数 $r$，以控制半离散算子 $\\mathbf{L}$ 的衰减本征模的数值误差，重点关注谱中的最差情况模态。校准必须强制执行两个精度要求：\n\n1. 振幅误差控制：对于 $\\mathbf{L}$ 的具有本征值 $\\mu_{\\max}  0$ 的最差情况离散本征模，定义每步无量纲衰减 $s = r|\\mu_{\\max}|$，并设精确的半离散每步振幅为 $A_{\\mathrm{exact}}(s) = e^{-s}$。定义 Crank-Nicolson 每步放大因子 $A_{\\mathrm{CN}}(s)$，并设每步相对振幅误差为\n$$\nE_{\\mathrm{amp}}(s) = \\frac{|A_{\\mathrm{CN}}(s) - A_{\\mathrm{exact}}(s)|}{A_{\\mathrm{exact}}(s)}.\n$$\n你必须选择 $r$，使得对于最差情况模态，$E_{\\mathrm{amp}}(s) \\le \\varepsilon_{\\mathrm{amp}}$，其中 $\\varepsilon_{\\mathrm{amp}}$ 是给定的容差。此条件必须在每个时间步都强制执行。\n\n2. 相位误差控制：由于热扩散产生无振荡的单调衰减，因此离散的每步放大因子对于最差情况模态必须保持非负，以避免非物理的符号反转。将每步“相位”定义为放大因子以弧度度量的辐角。控制器必须确保对于最差情况模态，此相位等于 $0$，这等价于要求一个非负的放大因子。用弧度表示相位要求，并将其作为布尔约束来强制执行。\n\n你必须推导均匀网格和齐次狄利克雷边界条件下二阶差分矩阵 $\\mathbf{L}$ 的离散最差模态本征值 $|\\mu_{\\max}|$，并用它来构建一个算法，该算法选择满足振幅误差约束和非负性（零相位）约束的最大 $r$。一旦选定 $r$，你必须确定覆盖目标模拟时域 $T$ 所需的时间步数 $M$。这通过使用一个均匀的时间步长 $\\Delta t$ 来实现，使得 $\\Delta t \\le \\Delta t_{\\max}$，其中 $\\Delta t_{\\max}$ 由选定的 $r$ 和网格间距隐含，且\n$$\n\\Delta t_{\\max} = \\frac{r\\,\\Delta x^2}{\\kappa}.\n$$\n使用 $M = \\lceil T / \\Delta t_{\\max} \\rceil$，然后设置实际的 $\\Delta t = T/M$ 以精确覆盖 $T$。模拟中使用的最终无量纲参数是\n$$\nr_{\\mathrm{final}} = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\n对于下面的每个测试用例，计算并报告：\n- $r_{\\mathrm{final}}$ (浮点数)，\n- $M$ (整数)，\n- 最差模态每步相对振幅误差 $E_{\\mathrm{amp}}(r_{\\mathrm{final}}|\\mu_{\\max}|)$ (浮点数)，\n- 一个指示相位约束是否满足的布尔值（最差模态每步放大因子为非负），\n- 一个指示振幅约束是否满足的布尔值（每步 $E_{\\mathrm{amp}} \\le \\varepsilon_{\\mathrm{amp}}$）。\n\n所有物理量必须使用国际单位制（SI单位）处理：$\\kappa$ 单位为 $\\mathrm{m}^2/\\mathrm{s}$，$L$ 单位为 $\\mathrm{m}$，$T$ 单位为 $\\mathrm{s}$。相位必须以弧度度量。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[[r1,M1,err1,phase_ok1,amp_ok1],[r2,M2,err2,phase_ok2,amp_ok2]]\"）。\n\n测试套件：\n- 情况 1 (理想情况): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 100$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-3}$。\n- 情况 2 (严格振幅控制): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 100$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-6}$。\n- 情况 3 (粗网格，中等振幅控制): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 10$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 1.0\\times 10^{-2}$。\n- 情况 4 (宽松振幅控制，受相位限制): $\\kappa = 1.0\\times 10^{-6}\\ \\mathrm{m}^2/\\mathrm{s}$, $L = 1.0\\times 10^{5}\\ \\mathrm{m}$, $N = 100$, $T = 1.0\\times 10^{12}\\ \\mathrm{s}$, $\\varepsilon_{\\mathrm{amp}} = 5.0\\times 10^{-1}$。\n\n你的实现必须具有通用性，并适用于形式相同的任意测试参数。最终输出必须严格遵循上述单行、方括号括起来的逗号分隔列表格式。", "solution": "该问题要求为应用于一维热方程 $\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}$ 的 Crank-Nicolson 格式设计一个时间步长控制器。该控制器必须选择无量纲时间步长参数 $r = \\kappa \\Delta t / \\Delta x^2$，以满足对空间离散化系统的最差情况本征模的数值振幅和相位误差的约束。\n\n### 1. 空间离散化的本征值\n空间域 $x \\in [0, L]$ 用 $N$ 个内部点进行离散化，得到网格间距为 $\\Delta x = L/(N+1)$。半离散系统为 $\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{\\Delta x^2} \\mathbf{L}\\,\\mathbf{u}$，其中 $\\mathbf{L}$ 是用于齐次狄利克雷边界条件的 $N \\times N$ 二阶差分矩阵。$\\mathbf{L}$ 的本征值是众所周知的，由下式给出：\n$$\n\\mu_j = -4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right), \\quad \\text{for } j = 1, 2, \\dots, N\n$$\n所有本征值 $\\mu_j$ 都是实数且为负。对于稳定性和精度而言，“最差情况”模态是衰减最快的模态，对应于具有最大绝对值的本征值。绝对值为 $|\\mu_j| = 4 \\sin^2\\left(\\frac{j\\pi}{2(N+1)}\\right)$，当 $j$ 取最大值，即 $j=N$ 时，该值最大。因此，问题中表示为 $\\mu_{\\max}$ 的最差情况本征值是 $\\mu_N$。其绝对值为：\n$$\n|\\mu_{\\max}| = |\\mu_N| = 4 \\sin^2\\left(\\frac{N\\pi}{2(N+1)}\\right) = 4 \\cos^2\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\n\n### 2. Crank-Nicolson 放大因子\n将 Crank-Nicolson 方法应用于标量常微分方程 $\\frac{du}{dt} = \\lambda u$ 会得到放大因子 $A = \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2}$。对于半离散系统，矩阵算子的本征值为 $\\lambda_j = \\frac{\\kappa}{\\Delta x^2}\\mu_j$。第 $j$ 个本征模的放大因子为：\n$$\nA_j = \\frac{1 + \\frac{1}{2}\\frac{\\kappa \\mu_j \\Delta t}{\\Delta x^2}}{1 - \\frac{1}{2}\\frac{\\kappa \\mu_j \\Delta t}{\\Delta x^2}} = \\frac{1 + \\frac{1}{2} r \\mu_j}{1 - \\frac{1}{2} r \\mu_j}\n$$\n对于最差情况模态，我们使用 $\\mu_{\\max}$。引入问题中的无量纲衰减参数 $s = r|\\mu_{\\max}| = -r\\mu_{\\max}$，我们可以将最差模态的放大因子 $A_{\\mathrm{CN}}$ 写为：\n$$\nA_{\\mathrm{CN}}(s) = \\frac{1 - s/2}{1 + s/2}\n$$\n\n### 3. 约束分析\n必须通过选择尽可能大的 $r$ 来满足两个约束。\n\n**相位误差约束：** 放大因子必须为非负以防止非物理振荡。\n$$\nA_{\\mathrm{CN}}(s) = \\frac{1 - s/2}{1 + s/2} \\ge 0\n$$\n由于 $s0$，分母 $1+s/2$ 总是正的。因此，约束简化为 $1-s/2 \\ge 0$，这意味着 $s \\le 2$。这为 $s$ 提供了一个上界，并因此也为 $r$ 提供了上界：\n$$\ns \\le 2 \\implies r|\\mu_{\\max}| \\le 2 \\implies r \\le \\frac{2}{|\\mu_{\\max}|}\n$$\n令此极限为 $r_{\\text{phase}} = 2/|\\mu_{\\max}|$.\n\n**振幅误差约束：** 最差情况模态的每步相对振幅误差必须由容差 $\\varepsilon_{\\mathrm{amp}}$ 界定。一个时间步内的精确放大因子是 $A_{\\mathrm{exact}} = e^{\\lambda_{\\max} \\Delta t} = e^{\\frac{\\kappa\\mu_{\\max}\\Delta t}{\\Delta x^2}} = e^{r\\mu_{\\max}} = e^{-s}$。相对误差为：\n$$\nE_{\\mathrm{amp}}(s) = \\frac{|A_{\\mathrm{CN}}(s) - A_{\\mathrm{exact}}(s)|}{A_{\\mathrm{exact}}(s)} \\le \\varepsilon_{\\mathrm{amp}}\n$$\n代入放大因子的表达式，我们有：\n$$\n\\left| \\frac{\\frac{1-s/2}{1+s/2} - e^{-s}}{e^{-s}} \\right| = \\left| \\frac{e^s(1-s/2)}{1+s/2} - 1 \\right| \\le \\varepsilon_{\\mathrm{amp}}\n$$\n对于 $s \\in (0, 2]$，可以证明 $A_{\\mathrm{CN}}(s)  A_{\\mathrm{exact}}(s)$，这意味着数值格式比精确解的耗散性稍强。因此，绝对值内的量是负的，误差为：\n$$\nE_{\\mathrm{amp}}(s) = 1 - \\frac{e^s(1-s/2)}{1+s/2}\n$$\n对于 $s  0$，此误差函数 $E_{\\mathrm{amp}}(s)$ 是单调递增的。我们必须找到最大的 $s$（记为 $s_{\\text{amp}}$），使得 $E_{\\mathrm{amp}}(s_{\\text{amp}}) \\le \\varepsilon_{\\mathrm{amp}}$。由于 $E_{\\mathrm{amp}}$ 是单调的，这等价于求解方程 $E_{\\mathrm{amp}}(s) = \\varepsilon_{\\mathrm{amp}}$ 以得到 $s$。这个超越方程没有简单的解析解，必须通过数值方法求解，例如使用像二分法或 Brent 法这样的求根算法。这个解 $s_{\\text{amp}}$ 给出了由振幅限制的 $r$ 值，即 $r_{\\text{amp}} = s_{\\text{amp}}/|\\mu_{\\max}|$。\n\n### 4. 时间步长选择算法\n对于每个测试用例，算法如下：\n1.  计算网格间距 $\\Delta x = L/(N+1)$。\n2.  计算最差情况本征值的绝对值 $|\\mu_{\\max}| = 4 \\cos^2(\\frac{\\pi}{2(N+1)})$。\n3.  根据相位约束确定 $s$ 的最大允许值，$s_{\\text{phase}} = 2$。\n4.  在区间 $(0, 2]$ 内数值求解方程 $1 - \\frac{e^s(1-s/2)}{1+s/2} = \\varepsilon_{\\mathrm{amp}}$，以找到 $s_{\\text{amp}}$。\n5.  选择最严格的 $s_{\\max} = \\min(s_{\\text{phase}}, s_{\\text{amp}})$。\n6.  计算最大允许的无量纲参数 $r_{\\max} = s_{\\max} / |\\mu_{\\max}|$。\n7.  计算相应的最大物理时间步长 $\\Delta t_{\\max} = \\frac{r_{\\max} \\Delta x^2}{\\kappa}$。\n8.  确定覆盖模拟时域 $T$ 所需的步数 $M$：$M = \\lceil T / \\Delta t_{\\max} \\rceil$。\n9.  计算精确匹配时域 $T$ 的实际时间步长：$\\Delta t = T / M$。\n10. 计算模拟中使用的最终无量纲参数：$r_{\\mathrm{final}} = \\frac{\\kappa \\Delta t}{\\Delta x^2}$。\n11. 使用此 $r_{\\mathrm{final}}$，计算最终的有效衰减参数 $s_{\\mathrm{final}} = r_{\\mathrm{final}} |\\mu_{\\max}|$。\n12. 使用 $s_{\\mathrm{final}}$，计算最终的每步相对振幅误差 $E_{\\mathrm{amp,final}} = 1 - \\frac{e^{s_{\\mathrm{final}}}(1-s_{\\mathrm{final}}/2)}{1+s_{\\mathrm{final}}/2}$。\n13. 验证约束：\n    - 如果 $s_{\\mathrm{final}} \\le 2$，则相位约束得到满足。\n    - 如果 $E_{\\mathrm{amp,final}} \\le \\varepsilon_{\\mathrm{amp}}$，则振幅约束得到满足。由于选择的 $\\Delta t \\le \\Delta t_{\\max}$，两个约束在数学上都将得到满足。布尔检查用作验证。\n14. 报告元组 $(r_{\\mathrm{final}}, M, E_{\\mathrm{amp,final}}, \\text{phase\\_ok}, \\text{amp\\_ok})$。\n\n此过程通过控制最具挑战性的模态的行为，保证了数值模拟对所有可分辨的模态都满足精度和非振荡行为的标准。", "answer": "```python\n# 完整且可运行的 Python 3 代码如下。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the Crank-Nicolson time-step calibration problem for several test cases.\n    \"\"\"\n    \n    # Test cases from the problem statement.\n    test_cases = [\n        # (kappa, L, N, T, eps_amp)\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-3), # Case 1: happy path\n        (1.0e-6, 1.0e5, 100, 1.0e12, 1.0e-6), # Case 2: tight amplitude control\n        (1.0e-6, 1.0e5, 10,  1.0e12, 1.0e-2), # Case 3: coarse grid, moderate amplitude control\n        (1.0e-6, 1.0e5, 100, 1.0e12, 5.0e-1), # Case 4: loose amplitude control, phase-limited\n    ]\n\n    results = []\n    \n    def amplitude_error_func(s, eps_amp):\n        \"\"\"\n        Error function E_amp(s) - eps_amp = 0 to be solved for s.\n        E_amp(s) = 1 - (e^s * (1 - s/2)) / (1 + s/2)\n        \"\"\"\n        # Handle s=0 case to avoid division by zero if ever used, although s>0 is expected.\n        if s == 0:\n            return -eps_amp\n        # The equation to solve is E_amp(s) = eps_amp\n        return 1.0 - (np.exp(s) * (1.0 - s / 2.0)) / (1.0 + s / 2.0) - eps_amp\n\n    for case in test_cases:\n        kappa, L, N, T, eps_amp = case\n        \n        # 1. Calculate grid spacing\n        delta_x = L / (N + 1.0)\n        \n        # 2. Calculate the worst-mode eigenvalue magnitude\n        mu_max_mag = 4.0 * np.cos(np.pi / (2.0 * (N + 1.0)))**2\n        \n        # 3. Phase constraint: s_phase_limit = 2\n        s_phase_limit = 2.0\n        \n        # 4. Amplitude constraint: solve for s_amp_limit\n        # The root must be in (0, 2]. Using a small positive number for the lower bound.\n        # If eps_amp is large (>=1), a root might not exist in (0, 2).\n        # E_amp at s=2 is 1. For eps_amp  1, a root exists in (0, 2).\n        if eps_amp >= 1.0:\n            # The error can never reach this value below the phase limit\n            s_amp_limit = s_phase_limit\n        else:\n            # Use brentq to find the root of amplitude_error_func\n            s_amp_limit = optimize.brentq(amplitude_error_func, 1e-12, s_phase_limit, args=(eps_amp,))\n            \n        # 5. The most restrictive s is the minimum of the two limits\n        s_max = min(s_phase_limit, s_amp_limit)\n        \n        # 6. Calculate max allowed r\n        r_max = s_max / mu_max_mag\n        \n        # 7. Compute max physical time step\n        delta_t_max = (r_max * delta_x**2) / kappa\n        \n        # 8. Determine number of steps M\n        if delta_t_max = 0: # Avoid division by zero if T is large and dt_max is tiny/zero\n             M = int(1e18) # A huge number, effectively not stepping.\n        else:\n             M = int(np.ceil(T / delta_t_max))\n\n        # 9. Calculate actual time step dt\n        delta_t = T / M\n        \n        # 10. Compute final non-dimensional parameter\n        r_final = (kappa * delta_t) / delta_x**2\n        \n        # 11. Calculate final decay parameter s_final\n        s_final = r_final * mu_max_mag\n        \n        # 12. Compute final amplitude error\n        # Use amplitude_error_func(s_final, 0) which is just E_amp(s_final)\n        E_amp_final = amplitude_error_func(s_final, 0)\n        \n        # 13. Verify constraints\n        phase_ok = (s_final = 2.0)\n        # Add a small tolerance for floating point comparison\n        amp_ok = (E_amp_final = eps_amp * (1.0 + 1e-9))\n        \n        # 14. Store results\n        # Format: r_final (float), M (integer), E_amp_final (float), phase_ok (bool), amp_ok (bool)\n        results.append([r_final, M, E_amp_final, phase_ok, amp_ok])\n\n    # Format the final output string exactly as specified.\n    # e.g., '[[r1,M1,E1,P1,A1],[r2,M2,E2,P2,A2]]'\n    sub_results_str = [f\"[{r},{m},{e},{str(p).lower()},{str(a).lower()}]\" for r, m, e, p, a in results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3616345"}, {"introduction": "在许多地球物理模拟中，系统演化在不同阶段具有不同的时间尺度，因此使用固定的时间步长效率低下。本练习要求您将标准的 Crank-Nicolson 格式推广到可变时间步长，同时通过广义梯形法则保持其二阶精度。您将通过模拟构造冷却过程中的一个突变事件来实践此高级技术，并通过步长加倍测试来验证方法的收敛阶 [@problem_id:3616345]。", "problem": "考虑一个与岩石圈构造冷却相关的一维热传导问题，该问题由以下抛物线型偏微分方程（PDE）控制：\n$$\n\\frac{\\partial T}{\\partial t}(z,t) \\;=\\; \\kappa \\,\\frac{\\partial^2 T}{\\partial z^2}(z,t) \\;+\\; \\frac{q(z,t)}{\\rho\\,c_p},\n$$\n该方程定义在有限域 $z \\in [0,L]$ 上，具有狄利克雷边界条件 $T(0,t) = T_s$ 和 $T(L,t) = T_b$，以及初始条件 $T(z,0) = T_{\\mathrm{init}}$。其中，$T$ 是温度，单位为 $\\mathrm{K}$；$\\kappa$ 是热扩散率，单位为 $\\mathrm{m}^2/\\mathrm{s}$；$q$ 是体积生热率，单位为 $\\mathrm{W}/\\mathrm{m}^3$；$\\rho$ 是密度，单位为 $\\mathrm{kg}/\\mathrm{m}^3$；$c_p$ 是比热容，单位为 $\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$。假定生热率 $q(z,t)$ 在深度上是分段常数，并在时间 $t_{\\mathrm{jump}}$ 发生突变：在上地壳层 $0 \\le z \\le z_h$ 中，当 $t  t_{\\mathrm{jump}}$ 时，$q(z,t) = q_0$；当 $t \\ge t_{\\mathrm{jump}}$ 时，$q(z,t) = q_1$。而在 $z > z_h$ 时，$q(z,t) = 0$。\n\n您的任务是：\n- 推导并实现一个可变时间步长的 Crank-Nicolson (CN) 格式。该格式在时间上使用广义梯形法则，以便在非均匀时间步长下仍能保持二阶时间精度。通过在每个时间间隔的两端计算 $q(z,t)$ 并取平均值来显式处理源项，并确保任何可能跨越 $t_{\\mathrm{jump}}$ 处不连续点的时间步都被分割，使得不连续点恰好位于一个时间节点上。\n- 使用二阶中心有限差分在具有 $M$ 个节点、间距为 $\\Delta z = L/(M-1)$ 的均匀网格上对空间算子进行离散化，并直接在 $z=0$ 和 $z=L$ 处施加狄利克雷边界条件。\n- 通过步长加倍检验来验证观测到的时间精度阶。对于每个测试用例，使用非均匀时间步长方案执行三次运行至最终时间 $t_{\\mathrm{final}}$。该方案的基础步长在 $t  t_{\\mathrm{jump}}$ 时为 $\\Delta t_{\\mathrm{pre}}$，在 $t \\ge t_{\\mathrm{jump}}$ 时为 $\\Delta t_{\\mathrm{post}}$，然后分别按比例因子 $1$、$1/2$ 和 $1/4$ 进行缩放。构建步长时间表的方法是：使用适用的基础步长向前推进，当下一步将超过 $t_{\\mathrm{jump}}$ 或 $t_{\\mathrm{final}}$ 时，缩短该步长以精确地落在断点上。计算在 $t_{\\mathrm{final}}$ 时的温度场 $U_{\\Delta t}$、$U_{\\Delta t/2}$ 和 $U_{\\Delta t/4}$，并估计观测到的阶数：\n$$\np \\;=\\; \\frac{\\log\\!\\left(\\frac{\\|U_{\\Delta t} - U_{\\Delta t/2}\\|_2}{\\|U_{\\Delta t/2} - U_{\\Delta t/4}\\|_2}\\right)}{\\log(2)},\n$$\n其中 $\\|\\cdot\\|_2$ 表示在所有网格节点上的离散欧几里得范数。\n\n您必须编写一个完整、可运行的程序，对以下三个科学上合理的测试用例执行上述操作（所有物理量在内部必须使用国际单位制；年份必须使用 $1\\,\\mathrm{yr} = 365.25 \\times 24 \\times 3600\\,\\mathrm{s}$ 转换为秒）：\n\n- 测试用例 A（正常情况，非均匀时间步长，跳变点与基础步长不对齐）：\n    - $L = 40000\\,\\mathrm{m}$，$M = 101$，$\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$，$c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$，\n      $T_s = 273\\,\\mathrm{K}$，$T_b = 1300\\,\\mathrm{K}$，$T_{\\mathrm{init}} = 1300\\,\\mathrm{K}$，\n      $z_h = 15000\\,\\mathrm{m}$，$q_0 = 1.0 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，$q_1 = 0.3 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，\n      $t_{\\mathrm{jump}} = 3.0\\,\\mathrm{Myr}$，$t_{\\mathrm{final}} = 10.0\\,\\mathrm{Myr}$，\n      $\\Delta t_{\\mathrm{pre}} = 0.7\\,\\mathrm{Myr}$，$\\Delta t_{\\mathrm{post}} = 1.3\\,\\mathrm{Myr}$。\n\n- 测试用例 B（边界情况：早期跳变，较小的定义域时间，不同的非均匀步长）：\n    - $L = 50000\\,\\mathrm{m}$，$M = 121$，$\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$，$c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$，\n      $T_s = 273\\,\\mathrm{K}$，$T_b = 1200\\,\\mathrm{K}$，$T_{\\mathrm{init}} = 1200\\,\\mathrm{K}$，\n      $z_h = 20000\\,\\mathrm{m}$，$q_0 = 1.5 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，$q_1 = 0.0\\,\\mathrm{W}/\\mathrm{m}^3$，\n      $t_{\\mathrm{jump}} = 0.2\\,\\mathrm{Myr}$，$t_{\\mathrm{final}} = 5.0\\,\\mathrm{Myr}$，\n      $\\Delta t_{\\mathrm{pre}} = 0.3\\,\\mathrm{Myr}$，$\\Delta t_{\\mathrm{post}} = 0.8\\,\\mathrm{Myr}$。\n\n- 测试用例 C（边缘情况：大幅度变化和更长的演化时间）：\n    - $L = 60000\\,\\mathrm{m}$，$M = 151$，$\\kappa = 1.0 \\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，\n      $\\rho = 2700\\,\\mathrm{kg}/\\mathrm{m}^3$，$c_p = 1000\\,\\mathrm{J}/(\\mathrm{kg}\\cdot\\mathrm{K})$，\n      $T_s = 273\\,\\mathrm{K}$，$T_b = 1300\\,\\mathrm{K}$，$T_{\\mathrm{init}} = 1300\\,\\mathrm{K}$，\n      $z_h = 25000\\,\\mathrm{m}$，$q_0 = 2.0 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，$q_1 = 0.2 \\times 10^{-6}\\,\\mathrm{W}/\\mathrm{m}^3$，\n      $t_{\\mathrm{jump}} = 8.0\\,\\mathrm{Myr}$，$t_{\\mathrm{final}} = 20.0\\,\\mathrm{Myr}$，\n      $\\Delta t_{\\mathrm{pre}} = 1.1\\,\\mathrm{Myr}$，$\\Delta t_{\\mathrm{post}} = 2.0\\,\\mathrm{Myr}$。\n\n对于每个测试用例，按所述方法计算观测到的阶数 $p$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[p_A,p_B,p_C]$。输出 $p_A$、$p_B$ 和 $p_C$ 必须是实数（浮点数），不带单位。计算中的所有中间量必须以国际单位制处理，此问题不涉及角度。最终输出是无量纲的。", "solution": "该问题要求推导并实现一种可变时间步长的 Crank-Nicolson 方法来解决一维热传导问题，然后对其时间精度阶进行数值验证。\n\n### 1. 问题描述\n\n控制方程是带源项的一维热方程：\n$$\n\\frac{\\partial T}{\\partial t}(z,t) \\;=\\; \\kappa \\,\\frac{\\partial^2 T}{\\partial z^2}(z,t) \\;+\\; S(z,t)\n$$\n其中 $S(z,t) = q(z,t)/(\\rho c_p)$ 是归一化的体积生热率。问题定义在区域 $z \\in [0,L]$ 上，时间范围为 $t \\in [0, t_{\\mathrm{final}}]$。边界条件为狄利克雷类型：$T(0,t) = T_s$ 和 $T(L,t) = T_b$。初始条件为 $T(z,0) = T_{\\mathrm{init}}$。\n\n源项 $q(z,t)$ 在空间和时间上都是分段常数：\n$$\nq(z,t) =\n\\begin{cases}\nq_0   \\text{当 } 0 \\le z \\le z_h \\text{ 且 } t  t_{\\mathrm{jump}} \\\\\nq_1   \\text{当 } 0 \\le z \\le z_h \\text{ 且 } t \\ge t_{\\mathrm{jump}} \\\\\n0     \\text{当 } z > z_h\n\\end{cases}\n$$\n\n### 2. 数值离散化\n\n我们在均匀的空间网格和非均匀的时间网格上对问题进行离散化。\n令 $T_j^n \\approx T(z_j, t_n)$，其中 $z_j = j \\Delta z$（$j=0, 1, \\dots, M-1$，$\\Delta z = L/(M-1)$），$t_n$ 是第 $n$ 步的时间。\n\n#### 2.1. 空间离散化\n\n对于内部节点（$j=1, 2, \\dots, M-2$），空间二阶导数使用二阶中心有限差分格式进行近似：\n$$\n\\left. \\frac{\\partial^2 T}{\\partial z^2} \\right|_{z_j, t_n} \\approx \\frac{T_{j-1}^n - 2T_j^n + T_{j+1}^n}{(\\Delta z)^2}\n$$\n令 $\\mathbf{U}(t)$ 为 $N_{int} = M-2$ 个内部节点上的温度向量，即 $\\mathbf{U}_j(t) = T_{j+1}(t)$（$j=0, \\dots, N_{int}-1$）。半离散化的常微分方程组（ODEs）可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{U}}{dt} = \\frac{\\kappa}{(\\Delta z)^2} \\mathbf{A} \\mathbf{U} + \\frac{\\kappa}{(\\Delta z)^2} \\mathbf{b} + \\mathbf{S}(t)\n$$\n这里，$\\mathbf{A}$ 是一个 $N_{int} \\times N_{int}$ 的三对角矩阵，表示内部节点的离散拉普拉斯算子：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-2   1   0   \\dots   0 \\\\\n1   -2   1   \\dots   0 \\\\\n0   \\ddots   \\ddots   \\ddots   0 \\\\\n0   \\dots   1   -2   1 \\\\\n0   \\dots   0   1   -2\n\\end{pmatrix}\n$$\n向量 $\\mathbf{b}$ 包含了恒定的狄利克雷边界条件：\n$$\n\\mathbf{b} = [T_s, 0, \\dots, 0, T_b]^T\n$$\n而 $\\mathbf{S}(t)$ 是在内部网格点上计算的源项向量。\n\n#### 2.2. 时间离散化\n\n为了在非均匀时间步长 $\\Delta t_n = t_{n+1} - t_n$ 下保持二阶精度，我们对半离散系统应用梯形法则（Crank-Nicolson 方法）。将 ODE 系统从 $t_n$ 积分到 $t_{n+1}$：\n$$\n\\mathbf{U}^{n+1} - \\mathbf{U}^n = \\int_{t_n}^{t_{n+1}} \\left( \\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}(t) + \\mathbf{b}) + \\mathbf{S}(t) \\right) dt\n$$\n对积分应用梯形法则得到：\n$$\n\\frac{\\mathbf{U}^{n+1} - \\mathbf{U}^n}{\\Delta t_n} = \\frac{1}{2} \\left[ \\left(\\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}^{n+1} + \\mathbf{b}) + \\mathbf{S}^{n+1}\\right) + \\left(\\frac{\\kappa}{(\\Delta z)^2} (\\mathbf{A} \\mathbf{U}^{n} + \\mathbf{b}) + \\mathbf{S}^{n}\\right) \\right]\n$$\n该格式是无条件稳定的，并且具有二阶时间精度。重新整理各项以求解未知状态 $\\mathbf{U}^{n+1}$：\n$$\n\\left(\\mathbf{I} - \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2} \\mathbf{A}\\right) \\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2} \\mathbf{A}\\right) \\mathbf{U}^{n} + \\frac{\\kappa \\Delta t_n}{(\\Delta z)^2} \\mathbf{b} + \\frac{\\Delta t_n}{2} (\\mathbf{S}^{n+1} + \\mathbf{S}^{n})\n$$\n令 $\\mu = \\frac{\\kappa \\Delta t_n}{2(\\Delta z)^2}$，方程变为线性系统 $\\mathbf{L} \\mathbf{U}^{n+1} = \\mathbf{R}$ 的形式，其中：\n$$\n\\mathbf{L} = \\mathbf{I} - \\mu \\mathbf{A}\n$$\n$$\n\\mathbf{R} = (\\mathbf{I} + \\mu \\mathbf{A})\\mathbf{U}^{n} + 2\\mu \\mathbf{b} + \\frac{\\Delta t_n}{2} (\\mathbf{S}^{n+1} + \\mathbf{S}^{n})\n$$\n矩阵 $\\mathbf{L}$ 是三对角的，这使得可以使用如托马斯算法等高效算法在 $O(M)$ 时间内求解该线性系统。\n\n### 3. 时间步进与源项管理\n\n必须构建时间步进方案，以确保一个时间节点与 $t_{\\mathrm{jump}}$ 处的不连续点重合。从 $t=0$ 开始，根据当前时间是在 $t_{\\mathrm{jump}}$ 之前还是之后来选择时间步长 $\\Delta t$。如果该步长会跨过 $t_{\\mathrm{jump}}$ 或 $t_{\\mathrm{final}}$，则将其缩短。具体来说，对于当前时间 $t_{curr}$，下一步的步长为 $\\Delta t_{actual} = \\min(\\Delta t_{base}, t_{break} - t_{curr})$，其中 $t_{break}$ 是下一个重要时间点（$t_{\\mathrm{jump}}$ 或 $t_{\\mathrm{final}}$）。源向量 $\\mathbf{S}(t)$ 是根据空间节点上 $q(z,t)$ 的值在每个时间点计算的。\n\n### 4. 精度验证\n\n观测到的精度阶 $p$ 是通过步长加倍检验（一种理查森外推法）确定的。模拟将运行到 $t_{\\mathrm{final}}$ 三次，分别使用基础时间步长 $(\\Delta t_{\\mathrm{pre}}, \\Delta t_{\\mathrm{post}})$ 乘以比例因子 $1$、$1/2$ 和 $1/4$，得到解 $U_{\\Delta t}$、$U_{\\Delta t/2}$ 和 $U_{\\Delta t/4}$。然后通过以下公式估算阶数 $p$：\n$$\np \\;=\\; \\frac{\\log\\!\\left(\\frac{\\|U_{\\Delta t} - U_{\\Delta t/2}\\|_2}{\\|U_{\\Delta t/2} - U_{\\Delta t/4}\\|_2}\\right)}{\\log(2)}\n$$\n其中 $\\|\\cdot\\|_2$ 是在所有空间网格节点上计算的欧几里得范数。对于二阶格式，我们期望 $p \\approx 2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the observed order of accuracy 'p' for each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Test Case A\n            'L': 40000.0, 'M': 101, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1300.0, 'T_init': 1300.0, 'zh': 15000.0,\n            'q0': 1.0e-6, 'q1': 0.3e-6, 't_jump': 3.0, 't_final': 10.0,\n            'dt_pre': 0.7, 'dt_post': 1.3\n        },\n        { # Test Case B\n            'L': 50000.0, 'M': 121, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1200.0, 'T_init': 1200.0, 'zh': 20000.0,\n            'q0': 1.5e-6, 'q1': 0.0, 't_jump': 0.2, 't_final': 5.0,\n            'dt_pre': 0.3, 'dt_post': 0.8\n        },\n        { # Test Case C\n            'L': 60000.0, 'M': 151, 'kappa': 1.0e-6, 'rho': 2700.0, 'cp': 1000.0,\n            'Ts': 273.0, 'Tb': 1300.0, 'T_init': 1300.0, 'zh': 25000.0,\n            'q0': 2.0e-6, 'q1': 0.2e-6, 't_jump': 8.0, 't_final': 20.0,\n            'dt_pre': 1.1, 'dt_post': 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = compute_p_for_case(case)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef compute_p_for_case(case_params):\n    \"\"\"\n    Computes the observed order of accuracy 'p' for a single test case.\n    \"\"\"\n    dt_pre_base = case_params['dt_pre']\n    dt_post_base = case_params['dt_post']\n    \n    # Run 1: Base time steps\n    T1 = run_simulation(case_params, dt_pre_base, dt_post_base)\n    # Run 2: Time steps halved\n    T2 = run_simulation(case_params, dt_pre_base / 2.0, dt_post_base / 2.0)\n    # Run 3: Time steps quartered\n    T3 = run_simulation(case_params, dt_pre_base / 4.0, dt_post_base / 4.0)\n\n    # Compute the L2 norms of the differences between solutions.\n    norm12 = np.linalg.norm(T1 - T2)\n    norm23 = np.linalg.norm(T2 - T3)\n\n    # Calculate the observed order of accuracy 'p'.\n    if norm23 == 0.0:\n        return np.nan if norm12 > 0.0 else 2.0 # Converged solution\n    \n    p = np.log(norm12 / norm23) / np.log(2.0)\n    return p\n\ndef run_simulation(params, dt_pre_myr, dt_post_myr):\n    \"\"\"\n    Performs a single heat conduction simulation for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    L, M, kappa, rho, cp = params['L'], params['M'], params['kappa'], params['rho'], params['cp']\n    Ts, Tb, T_init, zh = params['Ts'], params['Tb'], params['T_init'], params['zh']\n    q0, q1 = params['q0'], params['q1']\n    t_jump_myr, t_final_myr = params['t_jump'], params['t_final']\n\n    # Unit conversions (Myr -> s)\n    s_per_yr = 365.25 * 24.0 * 3600.0\n    t_jump = t_jump_myr * 1e6 * s_per_yr\n    t_final = t_final_myr * 1e6 * s_per_yr\n    dt_pre = dt_pre_myr * 1e6 * s_per_yr\n    dt_post = dt_post_myr * 1e6 * s_per_yr\n\n    # Spatial grid setup\n    dz = L / (M - 1)\n    z_nodes = np.linspace(0, L, M)\n    num_interior_nodes = M - 2\n    \n    # Initial condition\n    T_initial = np.full(M, T_init)\n    T_initial[0], T_initial[-1] = Ts, Tb\n    U = T_initial[1:-1].copy()\n\n    # Pre-calculate constants and source term configuration\n    alpha_const = kappa / (dz * dz)\n    interior_z = z_nodes[1:-1]\n    source_indices = np.where(interior_z = zh)[0]\n    \n    def get_S_vector(t_s):\n        q_val = q0 if t_s  t_jump else q1\n        s_val = q_val / (rho * cp)\n        S_vec = np.zeros(num_interior_nodes)\n        if s_val != 0.0 and len(source_indices) > 0:\n            S_vec[source_indices] = s_val\n        return S_vec\n\n    def generate_time_steps(tf, tj, dtp, dtpo):\n        current_t = 0.0\n        while current_t  tf * (1. - 1e-12):\n            dt_base = dtp if current_t  tj else dtpo\n            dt_to_jump = tj - current_t if current_t  tj else float('inf')\n            dt_to_final = tf - current_t\n            \n            dt = min(dt_base, dt_to_jump, dt_to_final)\n            if dt = 1e-9: break\n            \n            next_t = current_t + dt\n            yield current_t, next_t\n            current_t = next_t\n\n    # --- Time-stepping loop ---\n    for t_curr, t_next in generate_time_steps(t_final, t_jump, dt_pre, dt_post):\n        dt = t_next - t_curr\n        mu = 0.5 * dt * alpha_const\n\n        # --- Assemble RHS vector ---\n        # 1. (I + mu*A_hat) * U_n term\n        rhs = (1.0 - 2.0 * mu) * U\n        if num_interior_nodes > 1:\n            rhs[1:] += mu * U[:-1]\n            rhs[:-1] += mu * U[1:]\n\n        # 2. Boundary condition contribution: 2*mu*b\n        if num_interior_nodes > 0:\n            rhs[0] += 2.0 * mu * Ts\n            rhs[-1] += 2.0 * mu * Tb\n        \n        # 3. Source term contribution\n        S_n = get_S_vector(t_curr)\n        S_n_1 = get_S_vector(t_next)\n        rhs += 0.5 * dt * (S_n + S_n_1)\n\n        # --- Solve the linear system ---\n        if num_interior_nodes > 0:\n            l_and_u = 1\n            ab = np.zeros((3, num_interior_nodes))\n            ab[0, 1:] = -mu\n            ab[1, :] = 1.0 + 2.0 * mu\n            ab[2, :-1] = -mu\n            U = solve_banded((l_and_u, l_and_u), ab, rhs, overwrite_ab=True, overwrite_b=True)\n\n    # Reconstruct full temperature vector at t_final\n    T_final = np.empty(M)\n    T_final[0], T_final[-1] = Ts, Tb\n    if num_interior_nodes > 0:\n        T_final[1:-1] = U\n    \n    return T_final\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3616370"}]}