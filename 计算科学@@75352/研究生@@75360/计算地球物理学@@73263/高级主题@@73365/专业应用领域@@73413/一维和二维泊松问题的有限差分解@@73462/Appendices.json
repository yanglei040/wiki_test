{"hands_on_practices": [{"introduction": "在计算科学中，验证代码的正确性是与开发算法本身同等重要的一步。本实践将指导你完成一个核心的验证任务：使用“人造解方法”（Method of Manufactured Solutions, MMS）来检验二维泊松方程有限差分求解器的收敛阶。通过构建一个已知的精确解，并反算出对应的源项，你将能够量化数值解的误差，并通过网格加密研究来实证性地确认该格式是否达到了理论上的二阶精度([@problem_id:3593749])。", "problem": "考虑在单位正方形域上的带齐次狄利克雷边界条件的泊松偏微分方程（PDE）。设域为 $$\\Omega = (0,1)\\times(0,1),$$ 并考虑边值问题\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega,\\qquad u = g \\quad \\text{on } \\partial\\Omega,\n$$\n其中 $\\Delta$ 表示拉普拉斯算子。通过选择精确解\n$$\nu(x,y) = \\sin(\\pi x)\\sin(\\pi y),\n$$\n来使用人造解方法，使得在 $\\partial\\Omega$ 上 $g = u|_{\\partial\\Omega} = 0$，并构造由该偏微分方程所对应的源项 $f$。\n\n在一个具有 $N_x$ 和 $N_y$ 个分别沿 $x$ 和 $y$ 方向的内部点的均匀笛卡尔网格上，使用标准的五点中心差分有限差分格式对问题进行离散化。设网格间距为 $$h_x = \\frac{1}{N_x+1}, \\qquad h_y = \\frac{1}{N_y+1}。$$ 将内部网格点表示为 $x_i = i\\,h_x$（对于 $i\\in\\{1,\\dots,N_x\\}$）和 $y_j = j\\,h_y$（对于 $j\\in\\{1,\\dots,N_y\\}$）。使用逼近 $-\\Delta$ 的离散算子为内部未知数构建线性系统：\n$$\n(-\\Delta_h u)_{i,j} = \\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right) u_{i,j} - \\frac{1}{h_x^2}\\left(u_{i-1,j} + u_{i+1,j}\\right) - \\frac{1}{h_y^2}\\left(u_{i,j-1} + u_{i,j+1}\\right),\n$$\n其中通过将虚拟位置的边界值赋为精确边界数据 $g=0$ 来应用齐次狄利克雷边界条件。对于每个网格，求解该线性系统以获得内部节点上的数值解 $u_h$。\n\n将网格上误差 $e_h = u_h - u_{\\text{exact}}$ 的离散勒贝格 $L^2$ 范数定义为\n$$\n\\|e_h\\|_{L^2(\\Omega)} \\approx \\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(e_h(x_i,y_j)\\right)^2\\, h_x h_y\\right)^{1/2}.\n$$\n设代表性网格尺寸为 $h = \\max(h_x,h_y)$。在每个坐标方向上使用系数为 $2$ 的网格加密，通过对所有加密级别的 $\\log\\|e_h\\|_{L^2}$ 与 $\\log h$ 进行最小二乘拟合，计算经验收敛阶 $p$，其中预期的行为是 $\\|e_h\\|_{L^2} \\approx C h^p$，对于某个与 $h$ 无关的常数 $C$。\n\n对你的程序的要求：\n- 根据所选的精确解 $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 构造 $f$，并通过计算网格加密在 $L^2$ 范数下（如上定义）的经验收敛阶 $p$ 来验证二维格式的二阶收敛性。\n- 使用与五点模板一致的稀疏矩阵组装，并使用稀疏直接求解器将得到的线性系统精确求解至机器精度。\n- 对于下面测试套件中的每个参数集，通过从指定的基准网格同时将 $N_x$ 和 $N_y$ 加倍来进行逐次加密，收集所有加密级别的离散 $L^2$ 误差，并通过对 $\\log\\|e_h\\|_{L^2}$ 关于 $\\log h$ 的最小二乘回归计算单个经验阶 $p$。\n- 报告每个经验阶 $p$，四舍五入到三位小数。\n\n测试套件：\n- 测试用例 1：$N_{x,0} = 8$，$N_{y,0} = 8$，加密级别数 $L = 4$（即 $(N_x,N_y)\\in\\{(8,8),(16,16),(32,32),(64,64)\\}$）。\n- 测试用例 2：$N_{x,0} = 12$，$N_{y,0} = 18$，加密级别数 $L = 4$（即 $(N_x,N_y)\\in\\{(12,18),(24,36),(48,72),(96,144)\\}$）。\n- 测试用例 3：$N_{x,0} = 10$，$N_{y,0} = 14$，加密级别数 $L = 4$（即 $(N_x,N_y)\\in\\{(10,14),(20,28),(40,56),(80,112)\\}$）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个条目是对应测试用例的经验阶 $p$，四舍五入到三位小数（例如，“[2.000,1.995,2.003]”）。", "solution": "问题陈述已经过分析并被确定为有效。这是一个数值分析中适定的问题，基于偏微分方程有限差分方法的标准理论。所有需要的数据和定义均已提供，任务在科学上是合理且可验证的。\n\n求解过程分为四个主要步骤：\n1.  使用人造解方法推导源项 $f(x,y)$。\n2.  使用五点有限差分格式对泊松方程进行离散化，得到一个线性系统。\n3.  组装并求解稀疏线性系统，以获得网格上 $u(x,y)$ 的数值近似解。\n4.  通过网格加密研究计算数值误差并确定经验收敛阶。\n\n**第 1 步：源项的构建**\n\n问题是在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上求解泊松方程 $-\\Delta u = f$，并带有齐次狄利克雷边界条件 $u=0$ on the boundary $\\partial\\Omega$。采用了人造解方法，从一个满足边界条件的选定精确解开始。\n\n给定的精确解是\n$$\nu(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\n当 $x=0$、$x=1$、$y=0$ 或 $y=1$ 时，此函数为零，因此满足在 $\\partial\\Omega$ 上的齐次狄利克雷边界条件。\n\n源项 $f(x,y)$ 是通过将负拉普拉斯算子应用于精确解 $u(x,y)$ 来推导的。拉普拉斯算子为 $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。我们计算 $u(x,y)$ 的二阶偏导数：\n$$\n\\frac{\\partial u}{\\partial x} = \\pi \\cos(\\pi x)\\sin(\\pi y) \\implies \\frac{\\partial^2 u}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\n$$\n\\frac{\\partial u}{\\partial y} = \\pi \\sin(\\pi x)\\cos(\\pi y) \\implies \\frac{\\partial^2 u}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\n将它们相加得到 $u$ 的拉普拉斯：\n$$\n\\Delta u(x,y) = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y) - \\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\n因此，源项 $f$ 为\n$$\nf(x,y) = -\\Delta u(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\n\n**第 2 步：有限差分离散化**\n\n域 $\\Omega$ 使用均匀笛卡尔网格进行离散化，该网格在 $x$ 方向有 $N_x$ 个内部点，在 $y$ 方向有 $N_y$ 个内部点。网格点为 $(x_i, y_j)$，其中 $x_i = i h_x$ 对于 $i \\in \\{1, \\dots, N_x\\}$ 且 $y_j = j h_y$ 对于 $j \\in \\{1, \\dots, N_y\\}$。网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。\n\n在每个内部网格点 $(x_i, y_j)$，负拉普拉斯算子 $-\\Delta$ 由五点中心差分算子 $-\\Delta_h$ 近似：\n$$\n(-\\Delta u)(x_i, y_j) \\approx (-\\Delta_h u)_{i,j} = \\frac{-u_{i-1,j} + 2u_{i,j} - u_{i+1,j}}{h_x^2} + \\frac{-u_{i,j-1} + 2u_{i,j} - u_{i,j+1}}{h_y^2}.\n$$\n整理各项，我们得到问题陈述中给出的表达式：\n$$\n(-\\Delta_h u)_{i,j} = \\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right) u_{i,j} - \\frac{1}{h_x^2}\\left(u_{i-1,j} + u_{i+1,j}\\right) - \\frac{1}{h_y^2}\\left(u_{i,j-1} + u_{i,j+1}\\right).\n$$\n对于所有 $i \\in \\{1, \\dots, N_x\\}$ 和 $j \\in \\{1, \\dots, N_y\\}$，将此离散算子等于源项 $f(x_i, y_j)$，会得到一个关于数值解未知值 $u_{i,j}$ 的 $N = N_x \\times N_y$ 个线性方程组。\n\n边界条件 $u=0$ 通过设置 $u_{0,j}=0$、$u_{N_x+1,j}=0$、$u_{i,0}=0$ 和 $u_{i,N_y+1}=0$ 来并入，只要这些项出现在邻近边界的点的模板方程中。\n\n**第 3 步：线性系统组装与求解**\n\n该方程组可以写成矩阵形式 $A \\mathbf{u}_h = \\mathbf{f}$。\n未知数向量 $\\mathbf{u}_h \\in \\mathbb{R}^N$ 由按字典序（逐行）排列的值 $u_{i,j}$ 组成。网格位置 $(i,j)$ 处的未知数 $u_{i,j}$ 对应于 $\\mathbf{u}_h$ 中的条目 $k = (j-1)N_x + (i-1)$（使用基于 0 的向量索引）。\n右端向量 $\\mathbf{f} \\in \\mathbb{R}^N$ 包含在内部网格点上计算的源项，$f_k = f(x_i, y_j)$。\n\n矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是一个稀疏、对称、正定矩阵。其结构由五点模板决定：\n-   在 $(x_i, y_j)$ 处方程的主对角线元素是 $\\frac{2}{h_x^2} + \\frac{2}{h_y^2}$。\n-   连接到水平邻居 $(x_{i\\pm 1}, y_j)$ 的非对角线元素是 $-\\frac{1}{h_x^2}$。在矩阵中，这些元素出现在主对角线偏移 $\\pm 1$ 的位置，但在块边界处除外。\n-   连接到垂直邻居 $(x_i, y_{j\\pm 1})$ 的非对角线元素是 $-\\frac{1}{h_y^2}$。在矩阵中，这些元素出现在主对角线偏移 $\\pm N_x$ 的位置。\n\n该矩阵被构建为一个稀疏矩阵，通常采用压缩稀疏行（CSR）格式，以实现高效的存储和计算。然后使用稀疏直接求解器求解得到的线性系统 $A \\mathbf{u}_h = \\mathbf{f}$，以找到达到机器精度的数值解 $\\mathbf{u}_h$。\n\n**第 4 步：收敛性分析**\n\n在获得数值解向量 $\\mathbf{u}_h$ 后，我们评估其准确性。\n误差定义为在每个内部网格点上的 $e_h = u_h - u_{\\text{exact}}$。精确解值的向量 $\\mathbf{u}_{\\text{exact}}$ 是通过在所有内部点上计算 $u(x_i,y_j) = \\sin(\\pi x_i)\\sin(\\pi y_j)$ 来构建的。然后误差向量为 $\\mathbf{e}_h = \\mathbf{u}_h - \\mathbf{u}_{\\text{exact}}$。\n\n误差的离散 $L^2$ 范数计算如下：\n$$\n\\|e_h\\|_{L^2(\\Omega)} \\approx \\left(\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(e_h(x_i,y_j)\\right)^2 h_x h_y\\right)^{1/2}.\n$$\n这里使用的中心差分格式的截断误差为 $\\mathcal{O}(h_x^2) + \\mathcal{O}(h_y^2)$。对于光滑的人造解，数值解收敛到精确解的阶数预计为二阶。误差范数与代表性网格尺寸 $h = \\max(h_x, h_y)$ 之间的关系由下式给出：\n$$\n\\|e_h\\|_{L^2} \\approx C h^p,\n$$\n其中 $C$ 是一个常数，$p$ 是收敛阶。我们期望 $p \\approx 2$。\n\n为了找到经验阶 $p$，我们对两边取对数：\n$$\n\\log(\\|e_h\\|_{L^2}) \\approx \\log(C) + p \\log(h).\n$$\n这揭示了 $\\log(\\|e_h\\|_{L^2})$ 和 $\\log(h)$ 之间的线性关系。通过为一系列加密网格（$h$ 递减）计算误差，我们得到一组数据点 $(\\log(h^{(l)}), \\log(\\|e_h\\|_{L^2}^{(l)}))$，其中 $l$ 是加密级别。然后，经验阶 $p$ 被确定为通过这些点的最佳拟合线的斜率，该斜率通过线性最小二乘回归计算得出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson problem using a finite difference method,\n    and computes the empirical order of convergence for several test cases.\n    \"\"\"\n    \n    # Define the exact solution u(x,y) and the source term f(x,y).\n    # u(x,y) = sin(pi*x) * sin(pi*y)\n    # f(x,y) = -Delta u = 2*pi^2 * sin(pi*x) * sin(pi*y)\n    u_exact_func = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    f_func = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx_base, Ny_base, num_levels)\n        (8, 8, 4),\n        (12, 18, 4),\n        (10, 14, 4),\n    ]\n\n    results = []\n    \n    for nx_base, ny_base, num_levels in test_cases:\n        log_h_values = []\n        log_error_values = []\n\n        for level in range(num_levels):\n            # 1. Setup grid parameters for the current refinement level\n            nx = nx_base * (2**level)\n            ny = ny_base * (2**level)\n            \n            hx = 1.0 / (nx + 1)\n            hy = 1.0 / (ny + 1)\n            h = max(hx, hy)\n            \n            # Total number of interior unknowns\n            N = nx * ny\n\n            # 2. Assemble the sparse matrix A for the 5-point stencil\n            # Main diagonal\n            main_diag = (2.0 / hx**2 + 2.0 / hy**2) * np.ones(N)\n            \n            # Off-diagonals for x-derivatives\n            x_diag = (-1.0 / hx**2) * np.ones(N - 1)\n            # Zero out entries that wrap around grid rows\n            x_diag[nx-1::nx] = 0\n            \n            # Off-diagonals for y-derivatives\n            y_diag = (-1.0 / hy**2) * np.ones(N - nx)\n            \n            diagonals = [main_diag, x_diag, x_diag, y_diag, y_diag]\n            offsets = [0, -1, 1, -nx, nx]\n            \n            A = sparse.diags(diagonals, offsets, shape=(N, N), format='csr')\n\n            # 3. Assemble the right-hand side vector f\n            # Create grid coordinates for interior points\n            x_pts = np.linspace(hx, 1.0 - hx, nx)\n            y_pts = np.linspace(hy, 1.0 - hy, ny)\n            X, Y = np.meshgrid(x_pts, y_pts)\n            \n            # Evaluate source term f at grid points and flatten\n            f_vec = f_func(X, Y).flatten()\n\n            # 4. Solve the linear system A * u_h = f\n            u_h_vec = spsolve(A, f_vec)\n            \n            # 5. Compute the error\n            # Evaluate exact solution at grid points and flatten\n            u_exact_vec = u_exact_func(X, Y).flatten()\n            \n            # Calculate error vector\n            error_vec = u_h_vec - u_exact_vec\n            \n            # Compute discrete L2 norm of the error\n            l2_error = np.sqrt(np.sum(error_vec**2) * hx * hy)\n            \n            # 6. Store log(h) and log(error) for regression\n            log_h_values.append(np.log(h))\n            log_error_values.append(np.log(l2_error))\n\n        # 7. Compute the empirical order of convergence 'p'\n        # Perform linear regression on log(error) vs log(h)\n        # log(error) = p * log(h) + log(C)\n        p, _ = np.polyfit(log_h_values, log_error_values, 1)\n        \n        results.append(round(p, 3))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3593749"}, {"introduction": "将偏微分方程离散化后，我们得到一个大型线性方程组 $A\\mathbf{u} = \\mathbf{f}$，但求解这个系统的效率很大程度上取决于矩阵 $A$ 的谱特性（即其特征值分布）。本实践将深入剖析一维离散拉普拉斯算子的谱结构，并揭示其特征值如何直接决定经典迭代法（如雅可比法和高斯-赛德尔法）的收敛因子。通过这个练习，你将建立起连接离散化理论与迭代求解器性能的关键桥梁([@problem_id:3593804])。", "problem": "考虑在开区间 $\\left(0,1\\right)$ 上带齐次狄利克雷边界条件的一维泊松算子。该连续算子将一个足够光滑的函数 $u\\left(x\\right)$ 映射到 $-\\dfrac{d^2 u}{dx^2}$，其带有齐次狄利克雷边界条件的特征值问题具有一组完备的特征对。在计算地球物理学中，标准的做法是在均匀网格上近似该算子，并使用定常迭代法求解所得到的线性系统。您的任务是推导、实现和评估离散近似的谱性质，以及它们如何影响经典定常方法的收敛因子。\n\n从以下基础出发：\n\n- 在 $\\left(0,1\\right)$ 上带齐次狄利克雷条件的一维泊松算子的连续特征值问题是适定的，并具有特征对 $\\left(\\lambda_k^{\\mathrm{cont}}, u_k^{\\mathrm{cont}}\\right)$，其中 $k \\in \\mathbb{N}$。\n- 在 $\\left(0,1\\right)$ 上由 $n$ 个内部点组成的均匀网格，其网格间距为 $h = \\dfrac{1}{n+1}$，网格点索引为 $i = 1,2,\\dots,n$。\n- 在该网格上，对带有齐次狄利克雷边界条件的二阶导数 $-\\dfrac{d^2 u}{dx^2}$ 进行标准的二阶中心有限差分近似，会得到一个线性算子 $A_h \\in \\mathbb{R}^{n \\times n}$。该算子是对称正定的，其模板耦合了最近邻点并包含一个对角项。\n\n您的目标如下，且必须在不使用任何预先记忆的快捷公式的情况下完成：\n\n1. 从第一性原理出发，推导 $A_h$ 的离散特征对 $\\left(\\lambda_k^{h}, v_k^{h}\\right)$。具体而言，需假设一个与齐次狄利克雷边界条件一致的可分离模态形状，在内部点上施加离散算子关系，并求解容许的模态参数及相应的特征值。推导过程必须是自洽的，且必须清楚地论证离散网格上的容许波数及其关联的特征值。\n\n2. 从迭代分裂的定义出发，为以下方法建立依赖于特征值的收敛因子：\n   - 由 $A_h$ 的对角部分构成的 Jacobi 方法。\n   - 由 $A_h$ 的下三角加对角部分构成的 Gauss-Seidel 方法。\n   精确推导 $A_h$ 的特征值如何映射到每个迭代矩阵的特征值。不要假设任何先验恒等式；相反，应从算子分裂的定义开始，并展示每种方法的谱映射。\n\n3. 通过以下方式逐个模态地比较离散谱与连续谱：\n   - 对于每个容许的模态指数 $k$，量化相对特征值误差为 $\\left|\\lambda_k^{h} - \\lambda_k^{\\mathrm{cont}}\\right| / \\lambda_k^{\\mathrm{cont}}$。\n   - 量化在 Jacobi 和 Gauss-Seidel 方法的谱映射公式中用 $\\lambda_k^{\\mathrm{cont}}$ 替代 $\\lambda_k^{h}$ 的影响。通过将您推导出的精确谱映射公式应用于 $\\lambda_k^{\\mathrm{cont}}$（而非 $\\lambda_k^{h}$），为每种方法定义一个“连续模型预测因子”。然后，为每种方法，在选定的容许模态子集上定义谱半径，并计算实际离散谱半径与连续模型预测谱半径之间的绝对差。\n\n4. 实现一个完整的程序，该程序针对一组测试用例，完全按照规定执行以下计算：\n   - 对于给定的数对 $\\left(n, \\alpha\\right)$，构建具有 $n$ 个内部点的均匀网格，网格间距为 $h = \\dfrac{1}{n+1}$，并定义容许的模态指数 $k = 1,2,\\dots,\\left\\lfloor \\alpha n \\right\\rfloor$。参数 $\\alpha \\in \\left(0,1\\right]$ 指定了分析中要包含的容许谱的比例。如果 $\\left\\lfloor \\alpha n \\right\\rfloor  1$，则使用 $k = 1$。\n   - 对于每个包含的模态指数 $k$，计算连续特征值 $\\lambda_k^{\\mathrm{cont}}$、在目标 1 中推导出的 $A_h$ 的离散特征值 $\\lambda_k^{h}$，以及相对特征值误差。在所有包含的模态上，计算最大相对特征值误差。\n   - 使用目标 2 中的精确谱映射公式，为每个包含的模态计算：\n     - 模态 $k$ 的实际离散 Jacobi 因子。\n     - 通过在 Jacobi 谱映射公式中用 $\\lambda_k^{\\mathrm{cont}}$ 替代 $\\lambda_k^{h}$ 而得到的模态 $k$ 的连续模型预测 Jacobi 因子。\n     - 模态 $k$ 的实际离散 Gauss-Seidel 因子。\n     - 通过在 Gauss-Seidel 谱映射公式中用 $\\lambda_k^{\\mathrm{cont}}$ 替代 $\\lambda_k^{h}$ 而得到的模态 $k$ 的连续模型预测 Gauss-Seidel 因子。\n     对于每种方法，将包含模态上的谱半径计算为相应因子的最大绝对值。然后，为每种方法计算实际离散谱半径与连续模型预测谱半径之间的绝对差。\n   - 对于该测试用例，返回一个包含三个实数的列表：$\\left[\\text{最大相对特征值误差}, \\text{Jacobi谱半径差异}, \\text{Gauss-Seidel谱半径差异}\\right]$。\n\n您的程序使用的测试套件必须包括以下参数对 $\\left(n, \\alpha\\right)$：\n\n- $\\left(7, 1.0\\right)$: 一个包含所有容许模态的中等大小网格。\n- $\\left(1, 1.0\\right)$: 一个包含所有容许模态的最小非平凡网格。\n- $\\left(32, 1.0\\right)$: 一个包含所有容许模态的较大网格。\n- $\\left(64, 0.1\\right)$: 一个仅关注最低频模态子集的较大网格。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个按上述顺序排列的列表。例如，输出结构必须是 $\\left[\\left[r_1^{(1)}, r_2^{(1)}, r_3^{(1)}\\right],\\left[r_1^{(2)}, r_2^{(2)}, r_3^{(2)}\\right],\\dots\\right]$ 的形式。输出中的所有量都是没有物理单位的纯数字，并且必须表示为标准浮点字面量。", "solution": "该问题是有效的，因为它具有科学依据、是适定的、客观且自洽的。它提出了一个数值分析中标准但严谨的练习，适合计算科学课程。\n\n### 目标 1：离散特征对的推导\n\n在区间 $\\left(0,1\\right)$ 上带齐次狄利克雷边界条件的一维泊松方程由下式给出：\n$$-\\frac{d^2 u}{dx^2} = f(x), \\quad u(0) = 0, \\quad u(1) = 0$$\n我们使用一个包含 $n$ 个内部点 $x_i = ih$（其中 $i=1, 2, \\dots, n$）的均匀网格来离散化区间 $\\left(0,1\\right)$。网格间距为 $h = \\frac{1}{n+1}$。边界点为 $x_0 = 0$ 和 $x_{n+1}=1$。此网格上的离散函数由一个向量 $v \\in \\mathbb{R}^n$ 表示，其中 $v_i \\approx u(x_i)$。\n\n在内部点 $x_i$ 处的二阶导数 $-\\frac{d^2 u}{dx^2}$ 使用二阶中心有限差分公式近似为：\n$$-\\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx -\\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{1}{h^2}(-v_{i-1} + 2v_i - v_{i+1})$$\n齐次狄利克雷边界条件意味着 $v_0 = u(x_0)=0$ 和 $v_{n+1}=u(x_{n+1})=0$。\n\n对每个内部点 $i=1, \\dots, n$ 应用此近似，得到一个线性方程组 $A_h v = f_h$，其中 $A_h$ 是离散算子。矩阵向量乘积 $A_h v$ 的第 $i$ 行是 $\\frac{1}{h^2}(-v_{i-1} + 2v_i - v_{i+1})$。这定义了 $n \\times n$ 矩阵 $A_h$ 为：\n$$A_h = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -1 \\\\\n0  0  \\cdots  -1  2\n\\end{pmatrix}$$\n离散特征值问题是 $A_h v_k^h = \\lambda_k^h v_k^h$，其中 $(\\lambda_k^h, v_k^h)$ 是一个离散特征对。对于特征向量 $v_k^h$ 的第 $i$ 个分量 $(v_k^h)_i$，该方程可写为：\n$$\\frac{1}{h^2} \\left[ -(v_k^h)_{i-1} + 2(v_k^h)_i - (v_k^h)_{i+1} \\right] = \\lambda_k^h (v_k^h)_i$$\n边界条件为 $(v_k^h)_0 = 0$ 和 $(v_k^h)_{n+1} = 0$。\n\n受连续特征函数 $u_k^{\\mathrm{cont}}(x) = \\sin(k\\pi x)$ 的启发，我们假设特征向量分量具有离散正弦形式：\n$(v_k^h)_i = \\sin(p x_i) = \\sin(p i h)$\n其中 $p$ 是某个参数。我们施加边界条件：\n条件 $(v_k^h)_0 = \\sin(p \\cdot 0 \\cdot h) = 0$ 自动满足。\n条件 $(v_k^h)_{n+1} = \\sin(p (n+1) h) = 0$ 必须成立。由于 $h = \\frac{1}{n+1}$，这意味着 $\\sin(p)=0$。\n这将 $p$ 约束为 $\\pi$ 的整数倍，即 $p = k\\pi$，其中 $k$ 为某个整数。因此，特征向量分量的形式为：\n$$(v_k^h)_i = \\sin(k\\pi i h) = \\sin\\left(\\frac{k\\pi i}{n+1}\\right)$$\n为了找到一组 $n$ 个线性无关的特征向量，我们考虑 $k$ 的取值范围。当 $k=0$ 或 $k=n+1$ 时，向量为零向量。对于 $k = 1, 2, \\dots, n$，可以获得一组唯一的、非平凡的特征向量。\n\n现在，我们将此形式代入离散特征值方程：\n$$\\frac{1}{h^2} \\left[ -\\sin\\left(\\frac{k\\pi(i-1)}{n+1}\\right) + 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) - \\sin\\left(\\frac{k\\pi(i+1)}{n+1}\\right) \\right] = \\lambda_k^h \\sin\\left(\\frac{k\\pi i}{n+1}\\right)$$\n使用三角恒等式 $\\sin(A-B) + \\sin(A+B) = 2\\sin(A)\\cos(B)$，方括号中的项变为：\n$$2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) - \\left[ \\sin\\left(\\frac{k\\pi(i-1)}{n+1}\\right) + \\sin\\left(\\frac{k\\pi(i+1)}{n+1}\\right) \\right]$$\n$$= 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) - 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right)$$\n$$= 2\\sin\\left(\\frac{k\\pi i}{n+1}\\right) \\left[ 1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right]$$\n将此代回特征值方程：\n$$\\frac{2}{h^2} \\left[ 1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right] \\sin\\left(\\frac{k\\pi i}{n+1}\\right) = \\lambda_k^h \\sin\\left(\\frac{k\\pi i}{n+1}\\right)$$\n由于此式必须对所有 $i=1,\\dots,n$ 成立，并且特征向量是非平凡的，我们可以令系数相等：\n$$\\lambda_k^h = \\frac{2}{h^2} \\left[ 1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\right]$$\n使用半角公式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\\lambda_k^h = \\frac{2}{h^2} \\left[ 2\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) \\right] = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)$$\n回顾 $h = \\frac{1}{n+1}$，此式也可以写成 $\\lambda_k^h = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi h}{2}\\right)$。\n\n$A_h$ 的离散特征对 $(\\lambda_k^h, v_k^h)$（对于 $k=1, \\dots, n$）是：\n-   特征值：$\\lambda_k^h = \\dfrac{4}{h^2}\\sin^2\\left(\\dfrac{k\\pi}{2(n+1)}\\right)$\n-   特征向量：$v_k^h$，其分量为 $(v_k^h)_i = \\sin\\left(\\dfrac{k\\pi i}{n+1}\\right)$，其中 $i=1, \\dots, n$。\n\n### 目标 2：收敛因子的推导\n\n求解 $A_h u = b$ 的定常迭代法基于分裂 $A_h = M - N$，它定义了迭代 $Mu^{(j+1)} = Nu^{(j)} + b$。误差 $e^{(j)} = u^{(j)}-u$ 按照 $e^{(j+1)} = M^{-1}Ne^{(j)}$ 传播。矩阵 $G = M^{-1}N = I - M^{-1}A_h$ 是迭代矩阵，其谱半径 $\\rho(G)$ 控制着渐近收敛率。\n\n**Jacobi 方法：**\n该分裂通过取 $A_h$ 的对角部分作为 $M$ 来定义。设 $A_h = D - L - U$，其中 $D$ 是对角矩阵，$-L$ 是严格下三角矩阵，$-U$ 是严格上三角矩阵。对于 Jacobi 方法，$M_J = D$。\n从 $A_h$ 的结构可知，其对角线是常数：$D = \\frac{2}{h^2}I$，其中 $I$ 是单位矩阵。\nJacobi 迭代矩阵是 $G_J = I - D^{-1}A_h = I - \\left(\\frac{h^2}{2}I\\right)A_h = I - \\frac{h^2}{2}A_h$。\n$G_J$ 的特征值 $\\mu_k^J$ 与 $A_h$ 的特征值 $\\lambda_k^h$ 直接相关。如果 $v_k^h$ 是 $A_h$ 的一个特征向量，其特征值为 $\\lambda_k^h$，那么：\n$$G_J v_k^h = \\left(I - \\frac{h^2}{2}A_h\\right)v_k^h = v_k^h - \\frac{h^2}{2}(A_h v_k^h) = v_k^h - \\frac{h^2}{2}\\lambda_k^h v_k^h = \\left(1 - \\frac{h^2}{2}\\lambda_k^h\\right)v_k^h$$\n因此，$G_J$ 的特征值为 $\\mu_k^J = 1 - \\frac{h^2}{2}\\lambda_k^h$。\n代入 $\\lambda_k^h$ 的表达式：\n$$\\mu_k^J = 1 - \\frac{h^2}{2} \\left[ \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) \\right] = 1 - 2\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)$$\n使用恒等式 $\\cos(2\\theta) = 1 - 2\\sin^2(\\theta)$，我们得到 Jacobi 特征值：\n$$\\mu_k^J = \\cos\\left(\\frac{k\\pi}{n+1}\\right) \\quad \\text{for } k=1, \\dots, n$$\n收敛因子是谱半径 $\\rho(G_J) = \\max_{k=1,\\dots,n} |\\mu_k^J| = \\max_{k=1,\\dots,n} \\left|\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right| = \\cos\\left(\\frac{\\pi}{n+1}\\right)$。\n\n**Gauss-Seidel 方法：**\n该分裂定义为 $M_{GS} = D-L$。迭代矩阵是 $G_{GS} = I - (D-L)^{-1}A_h = (D-L)^{-1}U$。\n为了找到谱映射，我们利用数值线性代数中的一个基本结果。矩阵 $A_h$ 是一个三对角矩阵。所有三对角矩阵都是“协调序的”(consistently ordered)，这是一个关联 Jacobi 和 Gauss-Seidel 迭代矩阵谱的性质。对于任何协调序的矩阵，Gauss-Seidel 矩阵的特征值 $\\mu^{GS}$ 是 Jacobi 矩阵特征值 $\\mu^J$ 的平方：$\\mu_k^{GS} = (\\mu_k^J)^2$。\n应用这个在迭代方法理论中从第一性原理推导出的性质，可以得到所需的谱映射。\n$$\\mu_k^{GS} = (\\mu_k^J)^2 = \\left(\\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)^2 = \\cos^2\\left(\\frac{k\\pi}{n+1}\\right) \\quad \\text{for } k=1, \\dots, n$$\n这个公式将模态指数 $k$ 映射到 Gauss-Seidel 特征值。从 $A_h$ 的特征值 $\\lambda_k^h$ 出发的映射是：\n$$\\mu_k^{GS} = \\left(1 - \\frac{h^2}{2}\\lambda_k^h\\right)^2$$\n收敛因子是 $\\rho(G_{GS}) = \\max_{k=1,\\dots,n} |\\mu_k^{GS}| = \\max_{k=1,\\dots,n} \\cos^2\\left(\\frac{k\\pi}{n+1}\\right) = \\cos^2\\left(\\frac{\\pi}{n+1}\\right)$。\n\n### 目标 3：离散谱与连续谱的比较\n\n在 $(0,1)$ 上带有 $u(0)=u(1)=0$ 的连续特征值问题 $-\\frac{d^2u}{dx^2} = \\lambda u$ 具有由下式给出的精确特征对 $(\\lambda_k^{\\mathrm{cont}}, u_k^{\\mathrm{cont}})$：\n-   特征值：$\\lambda_k^{\\mathrm{cont}} = (k\\pi)^2$，其中 $k=1, 2, \\dots$\n-   特征函数：$u_k^{\\mathrm{cont}}(x) = \\sin(k\\pi x)$\n\n**相对特征值误差：**\n第 $k$ 个特征值的相对误差是：\n$$\\text{err}_k = \\frac{|\\lambda_k^h - \\lambda_k^{\\mathrm{cont}}|}{\\lambda_k^{\\mathrm{cont}}} = \\left| \\frac{\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi h}{2}\\right) - (k\\pi)^2}{(k\\pi)^2} \\right| = \\left| \\left(\\frac{\\sin(k\\pi h/2)}{k\\pi h/2}\\right)^2 - 1 \\right|$$\n当 $h \\to 0$ 时，参数 $k\\pi h/2 \\to 0$。由于对于小的 $x$，有 $\\frac{\\sin(x)}{x} \\approx 1 - \\frac{x^2}{6}$，因此有限差分特征值 $\\lambda_k^h$ 是 $\\lambda_k^{\\mathrm{cont}}$ 的一个二阶近似。\n\n**对收敛因子的影响：**\n我们通过将连续特征值 $\\lambda_k^{\\mathrm{cont}}$ 代入目标 2 中推导的谱映射公式，来定义一个“连续模型预测因子”。\n\n对于一组包含的模态 $k \\in \\{1, 2, \\dots, K\\}$，其中 $K = \\max(1, \\lfloor \\alpha n \\rfloor)$。\n\n**Jacobi 方法：**\n-   模态 $k$ 的实际离散因子：$\\mu_k^J = 1 - \\frac{h^2}{2}\\lambda_k^h = \\cos\\left(\\frac{k\\pi}{n+1}\\right)$\n-   模态 $k$ 的连续模型预测因子：$\\tilde{\\mu}_k^J = 1 - \\frac{h^2}{2}\\lambda_k^{\\mathrm{cont}} = 1 - \\frac{h^2(k\\pi)^2}{2}$\n-   实际离散谱半径：$\\rho_h^J = \\max_{k=1,\\dots,K} |\\mu_k^J| = \\cos\\left(\\frac{\\pi}{n+1}\\right)$\n-   连续模型预测谱半径：$\\tilde{\\rho}_c^J = \\max_{k=1,\\dots,K} |\\tilde{\\mu}_k^J| = \\max_{k=1,\\dots,K} \\left|1 - \\frac{(k\\pi h)^2}{2}\\right|$\n-   差异：$|\\rho_h^J - \\tilde{\\rho}_c^J|$\n\n**Gauss-Seidel 方法：**\n-   模态 $k$ 的实际离散因子：$\\mu_k^{GS} = \\left(1 - \\frac{h^2}{2}\\lambda_k^h\\right)^2 = \\cos^2\\left(\\frac{k\\pi}{n+1}\\right)$\n-   模态 $k$ 的连续模型预测因子：$\\tilde{\\mu}_k^{GS} = \\left(1 - \\frac{h^2}{2}\\lambda_k^{\\mathrm{cont}}\\right)^2 = \\left(1 - \\frac{h^2(k\\pi)^2}{2}\\right)^2$\n-   实际离散谱半径：$\\rho_h^{GS} = \\max_{k=1,\\dots,K} |\\mu_k^{GS}| = \\cos^2\\left(\\frac{\\pi}{n+1}\\right)$\n-   连续模型预测谱半径：$\\tilde{\\rho}_c^{GS} = \\max_{k=1,\\dots,K} |\\tilde{\\mu}_k^{GS}| = \\max_{k=1,\\dots,K} \\left(1 - \\frac{(k\\pi h)^2}{2}\\right)^2$\n-   差异：$|\\rho_h^{GS} - \\tilde{\\rho}_c^{GS}|$\n\n这些量将在最后一步中通过编程计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs the derivations and computations specified in the problem statement\n    for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (7, 1.0),   # a moderate grid including all admissible modes.\n        (1, 1.0),   # the smallest nontrivial grid including all admissible modes.\n        (32, 1.0),  # a larger grid including all admissible modes.\n        (64, 0.1),  # a larger grid focusing only on the lowest-frequency subset of modes.\n    ]\n\n    results = []\n    for n, alpha in test_cases:\n        # Form the grid and define admissible modes\n        h = 1.0 / (n + 1)\n        k_max = int(alpha * n)\n        if k_max  1:\n            k_max = 1\n        \n        k_values = np.arange(1, k_max + 1)\n\n        # Initialize storage for quantities for each mode\n        relative_eigenvalue_errors = []\n        \n        discrete_jacobi_factors = []\n        continuous_jacobi_factors = []\n        \n        discrete_gs_factors = []\n        continuous_gs_factors = []\n\n        # Loop over each included mode index k\n        for k in k_values:\n            # Continuous eigenvalue\n            lambda_k_cont = (k * np.pi)**2\n            \n            # Discrete eigenvalue (Objective 1)\n            # Use the derived formula: lambda_k_h = (4/h^2) * sin^2(k*pi*h/2)\n            arg_sin = k * np.pi * h / 2.0\n            lambda_k_h = (4.0 / h**2) * (np.sin(arg_sin))**2\n            \n            # Relative eigenvalue error (Objective 3)\n            rel_err = np.abs(lambda_k_h - lambda_k_cont) / lambda_k_cont\n            relative_eigenvalue_errors.append(rel_err)\n            \n            # Jacobi factors (Objective 2  3)\n            # Actual discrete factor\n            # Use derived spectral mapping: mu_k^J = 1 - (h^2/2) * lambda_k_h\n            # This simplifies to cos(k*pi*h), which we can use as a check.\n            mu_k_J_h = 1.0 - (h**2 / 2.0) * lambda_k_h\n            # Check: mu_k_J_h_simple = np.cos(k * np.pi * h)\n            # assert np.isclose(mu_k_J_h, mu_k_J_h_simple)\n            discrete_jacobi_factors.append(mu_k_J_h)\n            \n            # Continuous-model predicted factor\n            mu_k_J_c = 1.0 - (h**2 / 2.0) * lambda_k_cont\n            continuous_jacobi_factors.append(mu_k_J_c)\n            \n            # Gauss-Seidel factors (Objective 2  3)\n            # Actual discrete factor\n            # Use derived spectral mapping: mu_k^GS = (mu_k^J)^2\n            mu_k_GS_h = mu_k_J_h**2\n            discrete_gs_factors.append(mu_k_GS_h)\n            \n            # Continuous-model predicted factor\n            mu_k_GS_c = mu_k_J_c**2\n            continuous_gs_factors.append(mu_k_GS_c)\n            \n        # Compute maximum relative eigenvalue error\n        max_relative_eigenvalue_error = np.max(relative_eigenvalue_errors)\n        \n        # Compute spectral radii and their differences\n        # Jacobi\n        rho_h_J = np.max(np.abs(discrete_jacobi_factors))\n        rho_c_J = np.max(np.abs(continuous_jacobi_factors))\n        jacobi_spectral_radius_difference = np.abs(rho_h_J - rho_c_J)\n        \n        # Gauss-Seidel\n        rho_h_GS = np.max(np.abs(discrete_gs_factors))\n        rho_c_GS = np.max(np.abs(continuous_gs_factors))\n        gauss_seidel_spectral_radius_difference = np.abs(rho_h_GS - rho_c_GS)\n        \n        # Store results for the current test case\n        case_result = [\n            max_relative_eigenvalue_error,\n            jacobi_spectral_radius_difference,\n            gauss_seidel_spectral_radius_difference\n        ]\n        results.append(case_result)\n\n    # Format the final output string as specified\n    # Example: [[r1_1, r2_1, r3_1],[r1_2, r2_2, r3_2],...]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3593804"}, {"introduction": "一个优秀的数值格式，其性能不应仅仅通过形式上的收敛阶来衡量，还应考虑其是否能公正地处理所有空间方向。本实践将探讨一个更微妙但至关重要的性质——旋转不变性（isotropy），即离散算子对物理现象的模拟是否依赖于网格的朝向。你将通过对比标准的五点格式和九点（Mehrstellen）拉普拉斯算子对不同方向平面波的响应，来量化和评估它们的各向异性误差，从而深化对离散格式质量的理解([@problem_id:3593766])。", "problem": "您的任务是通过将两个二维拉普拉斯算子的有限差分近似应用于一个光滑平面波解，并在固定的网格间距下测量与角度相关的离散误差，从而以编程方式评估它们的旋转不变性。\n\n连续模型是二维空间中的 Poisson 算子，对于光滑函数 $u(x,y)$，即为拉普拉斯算子 $\\Delta u = u_{xx} + u_{yy}$。考虑测试函数 $u(x,y) = \\sin(\\alpha x + \\beta y)$，其中 $\\alpha = k \\cos(\\theta)$ 和 $\\beta = k \\sin(\\theta)$ 分别对应波数大小 $k$ 和方向角 $\\theta$。精确的连续拉普拉斯算子为 $\\Delta u = -(\\alpha^2 + \\beta^2) u = -k^2 u$。在间距为 $h$ 的均匀笛卡尔网格上，$\\Delta u$ 的有限差分近似可以通过在模板上进行局部加权求和来构成。对于固定的 $k h$，离散拉普拉斯算子产生与角度无关的近似误差的程度，量化了其旋转不变性。\n\n您的任务：\n\n1. 在正方形 $[0,1]\\times[0,1]$ 上构建一个均匀网格，每个方向有 $N$ 个点，其中 $N = 129$，$h = 1/(N-1)$。角度必须以弧度为单位。\n\n2. 实现以下两种离散拉普拉斯算子，每种仅应用于内部网格点：\n   - 标准的$5$点二阶拉普拉斯算子：\n     $$\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j}}{h^2}.$$\n   - 经典的$9$点四阶 Mehrstellen 拉普拉斯算子：\n     $$\\left(L_9 u\\right)_{i,j} = \\frac{-20\\,u_{i,j} + 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) + \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)}{6 h^2}.$$\n\n3. 对于给定的 $k$ 和指定集合中的每个角度 $\\theta$，定义 $\\alpha = k \\cos(\\theta)$ 和 $\\beta = k \\sin(\\theta)$，在网格上采样 $u(x,y) = \\sin(\\alpha x + \\beta y)$，在所有内部点上计算离散拉普拉斯算子，并通过相对内部 $\\ell^2$ 误差将离散结果与这些内部点上的连续值 $-k^2 u$ 进行比较：\n   $$\\varepsilon_{\\ell^2}(L_\\star; k,\\theta) = \\frac{\\left\\| L_\\star u + k^2 u \\right\\|_2}{\\left\\| k^2 u \\right\\|_2},$$\n   其中 $L_\\star$ 代表 $L_5$ 或 $L_9$，范数仅对内部网格点计算。这为每个算子、$k$ 和 $\\theta$ 定义了一个无量纲的标量误差。\n\n4. 对于每个 $k$，计算在角度集合 $\\Theta = \\{\\theta_m\\}_{m=0}^{M-1}$ 上的最大 $\\varepsilon_{\\ell^2}$，其中 $M = 25$ 且 $\\theta_m = m \\frac{\\pi}{2(M-1)}$，使得 $\\theta$ 从 $0$ 到 $\\pi/2$（含两端）均匀变化。分别报告 $L_5$ 和 $L_9$ 的最大值。\n\n测试套件和要求输出：\n\n使用上面定义的固定网格间距（因此 $h$ 是固定的），并评估三个不同的波数大小 $k$：\n- 测试 $1$：$k = 2\\pi$（良好解析）。\n- 测试 $2$：$k = 10\\pi$（中等解析）。\n- 测试 $3$：$k = 0.7 \\frac{\\pi}{h}$（高频，接近奈奎斯特极限但严格低于它）。\n\n对于这三个测试中的每一个，计算 $L_5$ 和 $L_9$ 在 $\\Theta$ 上的最大相对内部 $\\ell^2$ 误差。然后，您的程序必须按以下顺序汇总这六个标量结果：\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_5; k_1,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_9; k_1,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_5; k_2,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_9; k_2,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_5; k_3,\\theta)$,\n- $\\max_{\\theta \\in \\Theta} \\varepsilon_{\\ell^2}(L_9; k_3,\\theta)$,\n\n其中 $k_1 = 2\\pi$，$k_2 = 10\\pi$，$k_3 = 0.7 \\pi / h$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含六个浮点数结果，以逗号分隔并用方括号括起来（例如，“[r1,r2,r3,r4,r5,r6]”）。角度必须以弧度为单位。不应打印任何其他文本。", "solution": "该问题是有效的。其科学基础在于偏微分方程数值分析的原理，特别是有限差分法。该问题是适定的，所有必要的参数、定义和约束都已明确指定。其客观性和形式化结构使得可以获得唯一且可验证的数值解。这项任务是计算科学中评估数值模板质量（特别是其各向同性，即旋转不变性）的一个标准练习。\n\n此处提供一个详细的解决方案，从基本原理开始，直至算法实现。\n\n### 基于原理的设计\n\n核心任务是评估二维拉普拉斯算子 $\\Delta$ 的两种有限差分近似的旋转不变性。这是通过分析将这些近似应用于方向可变的平面波函数时产生的离散误差来完成的。\n\n**1. 连续模型与测试函数**\n\n连续算子是二维拉普拉斯算子，由下式给出：\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} $$\n我们采用平面波测试函数 $u(x,y)$，这是对微分算子进行傅里叶分析时的标准选择：\n$$ u(x,y) = \\sin(\\alpha x + \\beta y) $$\n参数 $\\alpha$ 和 $\\beta$ 是波矢量 $\\vec{k} = (\\alpha, \\beta)$ 的分量，可以用极坐标表示为大小 $k$ 和方向角 $\\theta$：\n$$ \\alpha = k \\cos(\\theta), \\quad \\beta = k \\sin(\\theta) $$\n将连续拉普拉斯算子应用于此测试函数可得到一个解析结果。二阶偏导数为：\n$$ u_{xx} = \\frac{\\partial^2}{\\partial x^2} \\sin(\\alpha x + \\beta y) = -\\alpha^2 \\sin(\\alpha x + \\beta y) = -\\alpha^2 u(x,y) $$\n$$ u_{yy} = \\frac{\\partial^2}{\\partial y^2} \\sin(\\alpha x + \\beta y) = -\\beta^2 \\sin(\\alpha x + \\beta y) = -\\beta^2 u(x,y) $$\n因此，精确的拉普拉斯算子是：\n$$ \\Delta u = u_{xx} + u_{yy} = -(\\alpha^2 + \\beta^2) u = -k^2 u(x,y) $$\n这个结果提供了用于与数值近似进行比较的基准真相。\n\n**2. 数值离散化与网格设置**\n\n该问题在单位正方形域 $[0,1] \\times [0,1]$ 上定义的均匀笛卡尔网格上进行离散化。该网格在每个方向上有 $N=129$ 个点，网格间距为 $h = 1/(N-1)$。网格点 $(i,j)$ 的坐标为 $(x_i, y_j) = (i h, j h)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。\n\n将要测试两种离散拉普拉斯算子 $L_\\star$：\n\n- **标准5点拉普拉斯算子 ($L_5$)**：这是一个从中心差分导出的二阶精度模板。\n$$ \\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4 u_{i,j}}{h^2} $$\n- **Mehrstellen 9点拉普拉斯算子 ($L_9$)**：这是一个四阶精度的紧凑模板，旨在与5点模板相比具有更好的各向同性。\n$$ \\left(L_9 u\\right)_{i,j} = \\frac{-20\\,u_{i,j} + 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) + \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)}{6 h^2} $$\n这些算子应用于内部网格点，其中 $i,j \\in \\{1, 2, \\dots, N-2\\}$。这意味着模板可以居中放置，而无需引用网格外的点。\n\n**3. 误差量化**\n\n对于给定的算子 $L_\\star$、波数 $k$ 和角度 $\\theta$，离散误差是离散近似与精确连续结果之间的差。对于我们的测试函数，即为 $L_\\star u - \\Delta u = L_\\star u - (-k^2 u) = L_\\star u + k^2 u$。\n\n为将此误差量化为单个标量值，我们使用相对内部 $\\ell^2$ 误差度量：\n$$ \\varepsilon_{\\ell^2}(L_\\star; k,\\theta) = \\frac{\\left\\| L_\\star u + k^2 u \\right\\|_2}{\\left\\| k^2 u \\right\\|_2} $$\n此处，$\\ell^2$ 范数（用 $\\|\\cdot\\|_2$ 表示）是元素平方和的平方根。对于一个大小为 $n \\times m$ 的二维数组（矩阵）$A$，它是 Frobenius 范数：$\\|A\\|_2 = \\sqrt{\\sum_{i=1}^n \\sum_{j=1}^m A_{ij}^2}$。范数是在所有内部网格点的集合上计算的。一个完全各向同性的算子对于固定的 $k$ 会产生一个与角度 $\\theta$ 无关的误差 $\\varepsilon_{\\ell^2}$。\n\n**4. 算法步骤**\n\n总体算法流程如下：\n\n1.  **初始化**：定义网格大小 $N=129$，计算网格间距 $h=1/(N-1)$，并定义角度数量 $M=25$。构建波数集合 $k \\in \\{2\\pi, 10\\pi, 0.7\\pi/h\\}$ 和角度集合 $\\Theta = \\{\\theta_m = m \\frac{\\pi}{2(M-1)} \\mid m=0, \\dots, M-1\\}$。生成网格坐标矩阵 $X$ 和 $Y$。\n\n2.  **外层循环（波数）**：遍历三个指定的 $k$ 值。对于每个 $k$，初始化变量以存储为 $L_5$ 和 $L_9$ 找到的最大误差，例如 $\\max\\_err_{L5} = 0$ 和 $\\max\\_err_{L9} = 0$。\n\n3.  **内层循环（角度）**：对于当前的 $k$，遍历集合 $\\Theta$ 中的每个角度 $\\theta$。\n    a.  在 $N \\times N$ 网格上采样测试函数 $u(x,y) = \\sin((k \\cos\\theta)x + (k \\sin\\theta)y)$。\n    b.  选取 $u$ 在内部点的值，形成一个 $(N-2) \\times (N-2)$ 的数组 $u_{interior}$。\n    c.  在内部网格上计算精确的拉普拉斯算子：$(\\Delta u)_{interior} = -k^2 u_{interior}$。\n    d.  将 $L_5$ 和 $L_9$ 模板应用于完整的网格数据 $u$，以在 $(N-2) \\times (N-2)$ 的内部网格上获得离散拉普拉斯算子的值 $(L_5 u)$ 和 $(L_9 u)$。这可以通过使用数组切片来高效完成。\n    e.  计算两个算子的误差数组：$E_{L5} = L_5 u + k^2 u_{interior}$ 和 $E_{L9} = L_9 u + k^2 u_{interior}$。\n    f.  计算误差度量所需的 $\\ell^2$ 范数：$\\|E_{L5}\\|_2$、$\\|E_{L9}\\|_2$ 和 $\\|k^2 u_{interior}\\|_2$。\n    g.  计算相对误差 $\\varepsilon_{\\ell^2}(L_5; k, \\theta)$ 和 $\\varepsilon_{\\ell^2}(L_9; k, \\theta)$。\n    h.  更新最大误差变量：$\\max\\_err_{L5} = \\max(\\max\\_err_{L5}, \\varepsilon_{\\ell^2}(L_5; k, \\theta))$ 和 $\\max\\_err_{L9} = \\max(\\max\\_err_{L9}, \\varepsilon_{\\ell^2}(L_9; k, \\theta))$。\n\n4.  **结果汇总**：内层循环完成后，将当前 $k$ 计算出的 $\\max\\_err_{L5}$ 和 $\\max\\_err_{L9}$ 附加到结果列表中。\n\n5.  **最终输出**：外层循环结束后，将包含六个汇总结果的列表格式化为指定的字符串格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum rotational error for 5-point and 9-point Laplacian stencils\n    across a range of wavenumbers.\n    \"\"\"\n    \n    # 1. Define constants and grid parameters from the problem statement.\n    N = 129\n    h = 1.0 / (N - 1)\n    M = 25\n    \n    # Define the three test cases for wavenumber k.\n    k_cases = [\n        2 * np.pi,\n        10 * np.pi,\n        0.7 * np.pi / h\n    ]\n    \n    # 2. Set up grid coordinates and the set of angles.\n    x = np.linspace(0.0, 1.0, N, dtype=np.float64)\n    y = np.linspace(0.0, 1.0, N, dtype=np.float64)\n    X, Y = np.meshgrid(x, y)\n    \n    # Angles range from 0 to pi/2 inclusive.\n    thetas = np.linspace(0.0, np.pi / 2, M, dtype=np.float64)\n    \n    # List to store the final six results.\n    results = []\n    \n    # 3. Main loop over the wavenumber test cases.\n    for k in k_cases:\n        max_err_l5 = 0.0\n        max_err_l9 = 0.0\n        \n        # 4. Inner loop over the angles to find the maximum error.\n        for theta in thetas:\n            # a. Define the plane wave test function and its exact Laplacian.\n            alpha = k * np.cos(theta)\n            beta = k * np.sin(theta)\n            u = np.sin(alpha * X + beta * Y)\n            \n            # b. Isolate the interior part of the grid for error calculation.\n            # Grid indices for interior points are 1 to N-2.\n            u_interior = u[1:-1, 1:-1]\n            k2_u_interior = k**2 * u_interior\n            \n            # c. Apply the 5-point discrete Laplacian stencil.\n            # Slicing is used for efficient stencil application over the interior.\n            l5_u = (u[2:, 1:-1] + u[:-2, 1:-1] + u[1:-1, 2:] + u[1:-1, :-2] - 4 * u_interior) / h**2\n            \n            # d. Apply the 9-point discrete Laplacian stencil.\n            sum_axial = u[2:, 1:-1] + u[:-2, 1:-1] + u[1:-1, 2:] + u[1:-1, :-2]\n            sum_diag  = u[2:, 2:] + u[:-2, 2:] + u[2:, :-2] + u[:-2, :-2]\n            l9_u = (-20 * u_interior + 4 * sum_axial + sum_diag) / (6 * h**2)\n            \n            # e. Calculate relative interior l2 error for both operators.\n            # The error is ||L_approx * u + k^2 * u|| / ||k^2 * u||.\n            err_num_l5 = l5_u + k2_u_interior\n            err_num_l9 = l9_u + k2_u_interior\n            \n            # The denominator is the norm of the exact Laplacian on the interior.\n            norm_denominator = np.linalg.norm(k2_u_interior)\n            \n            # In this problem, the norm of the denominator will not be zero for k>0.\n            if norm_denominator > 0:\n                rel_err_l5 = np.linalg.norm(err_num_l5) / norm_denominator\n                rel_err_l9 = np.linalg.norm(err_num_l9) / norm_denominator\n            else:\n                # This case should not be reached. Define error as 0 if signal is 0.\n                rel_err_l5 = 0.0 if np.linalg.norm(err_num_l5) == 0.0 else np.inf\n                rel_err_l9 = 0.0 if np.linalg.norm(err_num_l9) == 0.0 else np.inf\n\n            # f. Update the maximum error found so far for the current k.\n            if rel_err_l5 > max_err_l5:\n                max_err_l5 = rel_err_l5\n            if rel_err_l9 > max_err_l9:\n                max_err_l9 = rel_err_l9\n\n        # 5. After checking all angles, store the maximum errors for this k.\n        results.append(max_err_l5)\n        results.append(max_err_l9)\n\n    # 6. Print the final aggregated results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3593766"}]}