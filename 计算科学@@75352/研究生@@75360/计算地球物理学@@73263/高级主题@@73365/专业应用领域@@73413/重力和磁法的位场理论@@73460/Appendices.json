{"hands_on_practices": [{"introduction": "掌握从第一性原理推导简单几何体重力与磁异常表达式是位场理论的基石。本练习将指导你推导无限长水平圆柱体的重力及磁异常，这一过程将加深你对位场源与场响应之间关系的理解，并为你分析更复杂的模型打下坚实的解析基础。[@problem_id:3613236]", "problem": "一个半径为 $a$ 的无限长、直的、水平的圆柱体埋藏在一个均匀半空间中。圆柱体的轴线平行于 $y$ 轴，其中心位于 $(x,z)=(0,z_{0})$，其中 $z$ 轴正方向朝下，观测面位于 $z=0$。假设 $z_{0}>a$，因此观测点位于圆柱体外部。考虑两种独立的物理性质差异：\n\n1. 重力：圆柱体与围岩之间存在恒定的密度差 $\\Delta \\rho$。\n2. 磁学：圆柱体具有均匀磁化矢量 $\\mathbf{M}$，该矢量限制在 $x$–$z$ 平面内，即 $\\mathbf{M} = M_{x}\\,\\hat{\\mathbf{x}} + M_{z}\\,\\hat{\\mathbf{z}}$，且沿圆柱体轴线方向没有分量。\n\n仅从以下基本原理出发：\n\n- 国际单位制 (SI) 中的牛顿引力理论：引力场 $\\mathbf{g}$ 为 $\\mathbf{g}(\\mathbf{r}) = -\\nabla \\Phi(\\mathbf{r})$，其中引力势 $\\Phi$ 满足 $\\nabla^{2}\\Phi = 4\\pi G \\rho$， $G$ 为引力常数，$\\rho$ 为质量密度。\n- 自由空间中的静磁学（观测区域内无传导电流）：在磁化强度为零的区域，磁场强度 $\\mathbf{H}$ 可由标量势 $U$ 导出，即 $\\mathbf{H} = -\\nabla U$，且 $U$ 在物体外部满足拉普拉斯方程 $\\nabla^{2}U = 0$。物体的均匀磁化强度 $\\mathbf{M}$ 产生一个等效的单位长度偶极矩，其大小等于横截面积乘以 $\\mathbf{M}$。\n\n沿地表剖面推导以下物理量的闭合形式表达式：\n\n- 仅由该圆柱体引起的重力加速度异常的向下（$z$ 轴正方向）分量 $g_{z}(x)$。\n- 仅由该圆柱体引起的自由空间中磁感应强度异常的向下（$z$ 轴正方向）分量 $B_{z}(x)$，使用 $B_{z} = \\mu_{0} H_{z}$ 计算，其中 $\\mu_{0}$ 为自由空间磁导率。\n\n你的推导必须考虑所有几何因素，包括沿剖面相对于圆柱体轴线上方垂直线的水平偏移 $x$ 和埋藏深度 $z_{0}$。将最终结果表示为 $x$、$a$、$z_{0}$、$\\Delta \\rho$、$G$、$\\mu_{0}$、$M_{x}$ 和 $M_{z}$ 的显式函数。假设观测是在空气中 $z=0$ 的位置进行。提供：\n\n- $g_{z}(x)$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-2}$。\n- $B_{z}(x)$，单位为 $\\mathrm{T}$。\n\n无需进行数值计算；将每个结果以闭合解析形式给出。最终答案必须是单个解析表达式，将 $g_{z}(x)$ 和 $B_{z}(x)$ 合并为一个二元行矩阵，且仅用指定的符号表示。", "solution": "该问题被评估为有效，因为它在科学上基于牛顿引力理论和静磁学，是适定的、客观的，并包含足够的信息以获得唯一解。\n\n该问题要求推导由无限长水平圆柱体产生的重力异常和磁异常的向下垂直分量 $g_z(x)$ 和 $B_z(x)$。由于圆柱体沿 $y$ 轴无限延伸，该问题可简化为 $x$-$z$ 平面内的二维问题。\n\n**第一部分：重力异常 $g_z(x)$**\n\n问题给出了重力的基本原理：引力场 $\\mathbf{g}$ 是势 $\\Phi$ 的负梯度，即 $\\mathbf{g} = -\\nabla \\Phi$，其中 $\\Phi$ 满足泊松方程 $\\nabla^2\\Phi = 4\\pi G \\rho$。\n\n由于质量分布的圆柱对称性，对于圆柱体外的任何观测点，其引力场等同于一个位于圆柱体轴线上、具有相同单位长度质量的无限长线质量源所产生的引力场。这是牛顿壳层定理在圆柱几何中的推广，可由引力高斯定律推导得出。\n\n圆柱体半径为 $a$，与围岩介质存在恒定的密度差 $\\Delta \\rho$。圆柱体的横截面积为 $A_{cyl} = \\pi a^2$。异常质量的单位长度质量（线质量密度）为 $\\lambda = \\Delta \\rho A_{cyl} = \\pi \\Delta \\rho a^2$。\n\n圆柱体的轴线位于 $(x,z) = (0,z_0)$，观测沿地表剖面 $z=0$ 进行。因此，我们可以将源模拟为位于 $(0, z_0)$ 的无限长线质量 $\\lambda$。\n\n为求得观测点 $\\mathbf{r}_{obs} = (x,0,0)$ 处的引力加速度 $\\mathbf{g}$，我们对位于 $\\mathbf{r}_{src} = (0, y', z_0)$ 的线源上每个质量元 $dm = \\lambda dy'$ 的贡献进行积分。从源元到观测点的矢量为 $\\mathbf{R} = \\mathbf{r}_{obs} - \\mathbf{r}_{src} = (x, -y', -z_0)$。引力场是吸引场，因此其方向从观测点指向源，即 $-\\mathbf{R} = (-x, y', z_0)$ 方向。\n\n来自质量元 $dm$ 的场贡献由牛顿万有引力定律给出：\n$$\nd\\mathbf{g} = G \\frac{dm}{|\\mathbf{R}|^2} \\frac{-\\mathbf{R}}{|\\mathbf{R}|} = -G \\lambda dy' \\frac{(x, -y', -z_0)}{(x^2 + y'^2 + z_0^2)^{3/2}}\n$$\n我们将此表达式对 $y'$ 从 $-\\infty$ 到 $\\infty$ 积分，以求得总场 $\\mathbf{g}$。根据对称性，场的 $y$ 分量为零。我们关心的是 $z$ 分量，其定义为向下为正。\n$$\ng_z(x) = \\int_{-\\infty}^{\\infty} -G \\lambda \\frac{-z_0}{(x^2 + y'^2 + z_0^2)^{3/2}} dy' = G \\lambda z_0 \\int_{-\\infty}^{\\infty} \\frac{dy'}{(x^2 + y'^2 + z_0^2)^{3/2}}\n$$\n令 $r_p^2 = x^2+z_0^2$。该积分为标准形式：\n$$\n\\int_{-\\infty}^{\\infty} \\frac{dy'}{(r_p^2 + y'^2)^{3/2}} = \\left[ \\frac{y'}{r_p^2 \\sqrt{r_p^2 + y'^2}} \\right]_{-\\infty}^{\\infty} = \\frac{2}{r_p^2} = \\frac{2}{x^2+z_0^2}\n$$\n将此结果代回 $g_z(x)$ 的表达式中：\n$$\ng_z(x) = G \\lambda z_0 \\left(\\frac{2}{x^2+z_0^2}\\right) = \\frac{2G\\lambda z_0}{x^2+z_0^2}\n$$\n最后，我们代入线质量密度的表达式 $\\lambda = \\pi \\Delta \\rho a^2$：\n$$\ng_z(x) = \\frac{2G(\\pi \\Delta \\rho a^2) z_0}{x^2+z_0^2} = \\frac{2\\pi G \\Delta\\rho a^2 z_0}{x^2+z_0^2}\n$$\n\n**第二部分：磁异常 $B_z(x)$**\n\n问题指出，在磁化体外部，磁场强度 $\\mathbf{H}$ 可以表示为标量势 $U$ 的负梯度，即 $\\mathbf{H} = -\\nabla U$，其中 $U$ 满足拉普拉斯方程 $\\nabla^2 U = 0$。圆柱体具有均匀磁化强度 $\\mathbf{M} = M_x \\hat{\\mathbf{x}} + M_z \\hat{\\mathbf{z}}$。其等效单位长度偶极矩为 $\\mathbf{m} = A_{cyl} \\mathbf{M} = \\pi a^2 \\mathbf{M}$。\n\n均匀磁化圆柱体的外部势等效于位于其中心的磁偶极线所产生的势。我们首先推导二维线偶极子的势。三维点偶极子 $\\mathbf{p}$ 的磁标势为 $U_{3D}(\\mathbf{r}) = -\\frac{1}{4\\pi} \\frac{\\mathbf{p} \\cdot \\mathbf{r}}{r^3}$，其中 $\\mathbf{r}$ 是从偶极子到观测点的矢量。\n\n为求得单位长度磁矩为 $\\mathbf{m}$ 的无限长偶极线的势，我们将三维势沿无限长线源进行积分。在问题的坐标系中，观测点位于 $x-z$ 平面（即 $y=0$），源线平行于 $y$ 轴并穿过点 $(0, z_0)$。从位于 $(0, y', z_0)$ 的源元 $d\\mathbf{p} = \\mathbf{m} dy'$ 到观测点 $(x, 0, z)$ 的矢量为 $\\mathbf{R} = (x, -y', z-z_0)$。\n$$\nU(x,z) = \\int_{-\\infty}^{\\infty} -\\frac{1}{4\\pi} \\frac{(\\mathbf{m}dy') \\cdot (x, -y', z-z_0)}{ (x^2 + y'^2 + (z-z_0)^2)^{3/2} }\n$$\n由于 $\\mathbf{m}$ 在 $x-z$ 平面内，所以 $\\mathbf{m} \\cdot (x, -y', z-z_0) = m_x x + m_z (z-z_0)$。\n$$\nU(x,z) = -\\frac{m_x x + m_z(z-z_0)}{4\\pi} \\int_{-\\infty}^{\\infty} \\frac{dy'}{(x^2 + (z-z_0)^2 + y'^2)^{3/2}}\n$$\n使用与重力情况相同的积分结果，其中 $r_p^2 = x^2+(z-z_0)^2$：\n$$\nU(x,z) = -\\frac{m_x x + m_z(z-z_0)}{4\\pi} \\left( \\frac{2}{x^2+(z-z_0)^2} \\right) = -\\frac{1}{2\\pi} \\frac{m_x x + m_z(z-z_0)}{x^2+(z-z_0)^2}\n$$\n代入 $\\mathbf{m} = \\pi a^2 \\mathbf{M} = \\pi a^2 (M_x \\hat{\\mathbf{x}} + M_z \\hat{\\mathbf{z}})$：\n$$\nU(x,z) = -\\frac{\\pi a^2}{2\\pi} \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2} = -\\frac{a^2}{2} \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2}\n$$\n磁场强度的向下分量为 $H_z = -\\frac{\\partial U}{\\partial z}$。\n$$\nH_z(x,z) = -\\frac{\\partial}{\\partial z} \\left( -\\frac{a^2}{2} \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2} \\right) = \\frac{a^2}{2} \\frac{\\partial}{\\partial z} \\left( \\frac{M_x x + M_z(z-z_0)}{x^2+(z-z_0)^2} \\right)\n$$\n使用商法则，我们得到：\n$$\nH_z(x,z) = \\frac{a^2}{2} \\frac{ M_z(x^2+(z-z_0)^2) - (M_x x + M_z(z-z_0))(2(z-z_0)) }{ (x^2+(z-z_0)^2)^2 }\n$$\n$$\nH_z(x,z) = \\frac{a^2}{2} \\frac{ M_z x^2 + M_z(z-z_0)^2 - 2M_x x (z-z_0) - 2M_z(z-z_0)^2 }{ (x^2+(z-z_0)^2)^2 }\n$$\n$$\nH_z(x,z) = \\frac{a^2}{2} \\frac{ M_z(x^2 - (z-z_0)^2) - 2M_x x (z-z_0) }{ (x^2+(z-z_0)^2)^2 }\n$$\n我们在观测面 $z=0$ 上计算此表达式的值：\n$$\nH_z(x) = \\frac{a^2}{2} \\frac{ M_z(x^2 - (-z_0)^2) - 2M_x x (-z_0) }{ (x^2+(-z_0)^2)^2 } = \\frac{a^2}{2} \\frac{ M_z(x^2-z_0^2) + 2M_x x z_0 }{ (x^2+z_0^2)^2 }\n$$\n问题要求的是磁感应强度异常 $B_z(x) = \\mu_0 H_z(x)$。\n$$\nB_z(x) = \\frac{\\mu_0 a^2}{2} \\frac{2M_x x z_0 + M_z(x^2-z_0^2)}{(x^2+z_0^2)^2}\n$$\n推导出的 $g_z(x)$ 和 $B_z(x)$ 表达式以所要求的矩阵格式提供。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2\\pi G \\Delta\\rho a^2 z_0}{x^2+z_0^2} & \\frac{\\mu_0 a^2}{2} \\frac{2 M_x x z_0 + M_z(x^2-z_0^2)}{(x^2+z_0^2)^2} \\end{pmatrix}}\n$$", "id": "3613236"}, {"introduction": "位场理论中的许多问题可以归结为求解给定边界条件下的拉普拉斯方程。本练习将理论与计算实践相结合，要求你首先推导泊松积分公式，然后通过编程实现从边界数据重建内部位场，并探索不同采样策略对重建精度的影响。[@problem_id:3613251] 通过这个练习，你将深入理解边界值问题的数值解法及其在地球物理中的实际意义。", "problem": "考虑一个用于静磁学的二维无源区域，该区域处于均匀、单连通介质中，其中磁场为无旋场，存在磁标势 $U$ 且满足拉普拉斯方程 $\\nabla^2 U = 0$。在一个圆形域（单位圆盘）中，若其边界（单位圆）上的 $U$ 的测量值可用，则可以通过求解相应的狄利克雷边值问题，从这些边界测量值重建内部场。从控制方程 $\\nabla^2 U = 0$ 和位场理论的基本原理（包括格林恒等式和在极坐标系下的分离变量法）出发，推导在单位圆盘上从边界值重建 $U$ 所需的边界到内部的表示核。然后，实现一个数值模拟，以评估当边界测量值采用不同角向采样模式进行采样时，重建的质量。\n\n您的任务是：\n\n1) 对于单位圆盘内的一个调和函数 $u(r,\\phi)$，根据其在单位圆上的边界值 $f(\\theta)$，推导其边界到内部的重建公式。从位场理论的基础开始：\n- 在无源、无电流区域中的静磁学：在单连通域中磁场是无旋的，并且存在一个磁标势 $U$。\n- 在无源区域中，标势 $U$ 满足 $\\nabla^2 U = 0$。\n- 根据需要使用格林恒等式和在极坐标下的分离变量法，推导 $u(r,\\phi)$ 关于边界上 $f(\\theta)$ 的边界积分表示。\n不要预设目标公式；请逐步明确地推导所需的核表示。\n\n2) 实现一个程序，该程序：\n- 通过将单位圆上的边界值指定为有限傅里叶级数，构建单位圆盘内的基准真值调和标势 $u_{\\text{true}}(r,\\phi)$。具体使用\n$$\nf(\\theta) = a_3 \\cos(3\\theta) + b_5 \\sin(5\\theta) + a_7 \\cos(7\\theta) + a_{20} \\cos(20\\theta),\n$$\n其中系数为 $a_3 = 1.0$，$b_5 = 0.5$，$a_7 = -0.3$，$a_{20} = 0.2$。相应的调和内部场为\n$$\nu_{\\text{true}}(r,\\phi) = a_3 r^3 \\cos(3\\phi) + b_5 r^5 \\sin(5\\phi) + a_7 r^7 \\cos(7\\phi) + a_{20} r^{20} \\cos(20\\phi).\n$$\n所有角度必须以弧度为单位，所有报告的误差均为无量纲。\n\n- 通过对任务1中得到的边界积分进行数值近似，从 $f(\\theta)$ 的边界样本重建内部势 $u_{\\text{rec}}(r,\\phi)$。使用带有权重向量的边界样本离散和来实现积分近似。权重必须满足一致性条件，即它们近似于在 $[0,2\\pi)$ 上的角向积分除以 $2\\pi$；对于非均匀节点，在周期区间上使用梯形法则权重；对于均匀节点，使用等权重。\n\n- 在一组内部评估点上评估并报告均方根（RMS）重建误差：\n  - 半径 $r \\in \\{0.2, 0.5, 0.95\\}$。\n  - 角度 $\\phi$ 在一个从 $0$（包含）到 $2\\pi$（不包含）的 $361$ 个点的等间距网格上，以弧度为单位。\n  - RMS 误差定义：\n  $$\n  \\text{RMS} = \\sqrt{\\frac{1}{N_r N_\\phi} \\sum_{k=1}^{N_r} \\sum_{j=1}^{N_\\phi} \\left(u_{\\text{rec}}(r_k,\\phi_j) - u_{\\text{true}}(r_k,\\phi_j)\\right)^2}.\n  $$\n\n3) 测试套件和覆盖范围。实现以下四个测试用例，以评估采样模式对重建的影响：\n- 用例1（均匀，足够的分辨率）：$N = 256$ 个边界样本，采用均匀角向采样 $\\theta_i = 2\\pi i / N$（$i = 0,1,\\dots,N-1$），并使用等权重（对于均匀节点，这与梯形法则一致）。\n- 用例2（非均匀，朴素的等权重）：$N = 256$ 个边界样本，采用非均匀角向采样 $\\theta_i = 2\\pi (i/N)^4$（$i = 0,1,\\dots,N-1$），并使用等权重（这对于非均匀节点是故意设置的错误）。\n- 用例3（非均匀，正确的求积）：与用例2相同的非均匀节点，但使用周期性梯形法则权重 $w_i = \\frac{1}{2}\\left(\\Delta\\theta_{i-1} + \\Delta\\theta_i\\right)/(2\\pi)$，其中 $\\Delta\\theta_i$ 是前向角间距，并且角度在 $[0,2\\pi)$ 上被周期性处理。\n- 用例4（均匀，粗分辨率）：$N = 24$ 个边界样本，采用均匀角向采样和等权重。\n\n对于每个用例，按上述方法计算RMS误差。所有角度必须以弧度为单位。所有结果均为无量纲。最终的程序输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中包含按用例1到4顺序排列的四个RMS误差，例如 $[x_1,x_2,x_3,x_4]$。每个 $x_i$ 都必须是十进制或科学记数法表示的浮点数，不带单位。\n\n您的程序必须是完全自包含的，不需要用户输入，并严格遵循指定的输出格式。", "solution": "该问题被评估为有效。它在科学上基于位场理论，作为一个针对拉普拉斯方程的狄利克雷问题是适定的，并为推导和数值实现提供了一套完整、一致且可形式化的任务。\n\n### 第1部分：边界到内部表示的推导\n\n目标是推导一个积分公式，该公式能够从单位圆盘边界（单位圆）上的值 $f(\\theta)$ 重建其内部的调和函数 $U(r,\\phi)$。控制方程是拉普拉斯方程，在二维极坐标系 $(r,\\phi)$ 中表示为：\n$$\n\\nabla^2 U = \\frac{1}{r}\\frac{\\partial}{\\partial r}\\left(r\\frac{\\partial U}{\\partial r}\\right) + \\frac{1}{r^2}\\frac{\\partial^2 U}{\\partial \\phi^2} = 0\n$$\n我们寻求在单位圆盘内部 $r  1$ 的一个解，该解在边界上（$r \\le 1$）连续，并在 $r=1$ 处匹配指定值 $f(\\phi)$。\n\n我们采用分离变量法，假设解的形式为 $U(r,\\phi) = R(r)\\Phi(\\phi)$。将此形式代入拉普拉斯方程并整理各项以分离变量，得到：\n$$\n\\frac{r}{R(r)}\\frac{d}{dr}\\left(r\\frac{dR(r)}{dr}\\right) = -\\frac{1}{\\Phi(\\phi)}\\frac{d^2\\Phi(\\phi)}{d\\phi^2}\n$$\n由于左侧仅依赖于 $r$，右侧仅依赖于 $\\phi$，因此两边必须等于一个常数，我们记为 $\\lambda$。这导出了两个常微分方程：\n$$\n\\frac{d^2\\Phi}{d\\phi^2} + \\lambda\\Phi = 0 \\quad \\quad (1)\n$$\n$$\nr^2\\frac{d^2R}{dr^2} + r\\frac{dR}{dr} - \\lambda R = 0 \\quad \\quad (2)\n$$\n\n对于角向方程(1)，势函数必须是单值的这一物理要求决定了其解必须是关于 $\\phi$ 的周期函数，周期为 $2\\pi$，即 $\\Phi(\\phi+2\\pi) = \\Phi(\\phi)$。这个条件将分离常数 $\\lambda$ 限制为非负。如果 $\\lambda = 0$，解为 $\\Phi(\\phi) = C_1\\phi + C_2$。周期性要求 $C_1=0$，因此 $\\Phi(\\phi)$ 是一个常数。如果 $\\lambda > 0$，我们设 $\\lambda = n^2$，其中 $n$ 是一个正实数。通解为 $\\Phi(\\phi) = A\\cos(n\\phi) + B\\sin(n\\phi)$。周期性要求 $n$ 必须是整数，即 $n \\in \\{1, 2, 3, \\ldots\\}$。\n\n对于径向方程(2)，当 $\\lambda = n^2$ 时，我们得到欧拉-柯西方程：\n$$\nr^2R'' + rR' - n^2R = 0\n$$\n对于 $n>0$，通解为 $R(r) = C_n r^n + D_n r^{-n}$。为了使解在圆盘中心（$r=0$）处具有物理意义（即有界），必须排除在 $r=0$ 处奇异的 $r^{-n}$ 项。因此，我们对所有 $n \\ge 1$ 设 $D_n=0$。\n对于 $n=0$（$\\lambda=0$）的情况，径向方程变为 $rR''+R' = 0$，其通解为 $R(r) = C_0 + D_0\\ln(r)$。同样，为了在 $r=0$ 处有界，必须移除奇异的对数项，因此 $D_0=0$。\n\n结合 $R(r)$ 和 $\\Phi(\\phi)$ 的有效解，并利用叠加原理，我们构建出圆盘内部 $U(r,\\phi)$ 的通解，其形式为一个傅里叶级数：\n$$\nU(r,\\phi) = \\frac{A_0}{2} + \\sum_{n=1}^\\infty r^n \\left( A_n \\cos(n\\phi) + B_n \\sin(n\\phi) \\right)\n$$\n系数 $A_n$ 和 $B_n$ 通过施加边界条件 $U(1, \\phi) = f(\\phi)$ 来确定：\n$$\nf(\\phi) = \\frac{A_0}{2} + \\sum_{n=1}^\\infty \\left( A_n \\cos(n\\phi) + B_n \\sin(n\\phi) \\right)\n$$\n这是边界函数 $f(\\phi)$ 的傅里叶级数表示。利用三角函数在区间 $[0, 2\\pi]$ 上的正交性可以求出这些系数：\n$$\nA_n = \\frac{1}{\\pi} \\int_0^{2\\pi} f(\\phi') \\cos(n\\phi') d\\phi' \\quad (n \\ge 0)\n$$\n$$\nB_n = \\frac{1}{\\pi} \\int_0^{2\\pi} f(\\phi') \\sin(n\\phi') d\\phi' \\quad (n \\ge 1)\n$$\n将这些系数的积分表示代回到 $U(r,\\phi)$ 的通解中：\n$$\nU(r,\\phi) = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(\\phi') d\\phi' + \\sum_{n=1}^\\infty r^n \\left[ \\left(\\frac{1}{\\pi} \\int_0^{2\\pi} f(\\phi')\\cos(n\\phi')d\\phi'\\right)\\cos(n\\phi) + \\left(\\frac{1}{\\pi} \\int_0^{2\\pi} f(\\phi')\\sin(n\\phi')d\\phi'\\right)\\sin(n\\phi) \\right]\n$$\n假设一致收敛，我们可以交换求和与积分的顺序：\n$$\nU(r,\\phi) = \\frac{1}{\\pi} \\int_0^{2\\pi} f(\\phi') \\left[ \\frac{1}{2} + \\sum_{n=1}^\\infty r^n (\\cos(n\\phi')\\cos(n\\phi) + \\sin(n\\phi')\\sin(n\\phi)) \\right] d\\phi'\n$$\n使用三角恒等式 $\\cos(a-b) = \\cos(a)\\cos(b) + \\sin(a)\\sin(b)$，表达式简化为：\n$$\nU(r,\\phi) = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(\\phi') \\left[ 1 + 2\\sum_{n=1}^\\infty r^n \\cos(n(\\phi-\\phi')) \\right] d\\phi'\n$$\n方括号中的项是边界到内部的表示核，称为单位圆盘的泊松核。令 $P(r, \\theta)$ 表示此核，其中 $\\theta = \\phi-\\phi'$。我们可以通过将求和项视为一个复数几何级数的实部来找到它的闭式表达式。对于 $|z|1$，有 $\\sum_{n=1}^\\infty z^n = z/(1-z)$。\n$$\n1 + 2\\sum_{n=1}^\\infty r^n \\cos(n\\theta) = 1 + 2 \\text{Re} \\left( \\sum_{n=1}^\\infty (r e^{i\\theta})^n \\right) = \\text{Re} \\left( 1 + 2\\frac{re^{i\\theta}}{1-re^{i\\theta}} \\right)\n$$\n$$\n= \\text{Re} \\left( \\frac{1-re^{i\\theta} + 2re^{i\\theta}}{1-re^{i\\theta}} \\right) = \\text{Re} \\left( \\frac{1+re^{i\\theta}}{1-re^{i\\theta}} \\right)\n$$\n为了求实部，我们将分子和分母同乘以分母的复共轭：\n$$\n\\frac{1+re^{i\\theta}}{1-re^{i\\theta}} = \\frac{(1+r\\cos\\theta + ir\\sin\\theta)}{(1-r\\cos\\theta - ir\\sin\\theta)} \\times \\frac{(1-r\\cos\\theta + ir\\sin\\theta)}{(1-r\\cos\\theta + ir\\sin\\theta)} = \\frac{1-r^2+2ir\\sin\\theta}{1-2r\\cos\\theta+r^2}\n$$\n此表达式的实部就是所求的闭式核：\n$$\nP(r, \\phi-\\phi') = \\frac{1-r^2}{1-2r\\cos(\\phi-\\phi') + r^2}\n$$\n最后，将其代回，得到单位圆盘的泊松积分公式：\n$$\nU(r,\\phi) = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(\\phi') \\frac{1-r^2}{1 - 2r\\cos(\\phi-\\phi') + r^2} d\\phi'\n$$\n这个公式给出了任意内部点 $(r, \\phi)$ 处调和函数 $U$ 的值，该值是其边界值 $f(\\phi')$ 的加权平均。\n\n### 第2部分：数值实现与分析\n\n数值任务是针对不同的边界采样方案近似此积分，并计算重建误差。该积分的形式为 $\\frac{1}{2\\pi}\\int_0^{2\\pi} G(\\phi')d\\phi'$，其中 $G(\\phi') = f(\\phi')P(r, \\phi-\\phi')$。我们使用离散边界采样点 $\\theta_i$ 上的加权和来近似此积分：\n$$\nu_{\\text{rec}}(r, \\phi) \\approx \\sum_{i=0}^{N-1} w_i \\left[ f(\\theta_i) \\frac{1-r^2}{1-2r\\cos(\\phi-\\theta_i)+r^2} \\right]\n$$\n所提供的权重 $w_i$ 被定义为近似被积函数在 $[0, 2\\pi)$ 上的平均值。对于均匀采样，$w_i = 1/N$ 是合适的。对于非均匀采样，必须使用周期梯形法则来确保准确性，其中节点 $i$ 的权重为 $w_i = \\frac{1}{4\\pi}(\\theta_{i+1} - \\theta_{i-1})$，并考虑了周期性。所提供的基准真值势是一个有限傅里叶级数，这确保了它的调和性。这四个测试用例旨在探究关于采样密度（奈奎斯特准则）和求积法则正确性的数值准确度。用例1（密集、均匀采样，正确权重）应该具有很高的准确度。用例2（密集、非均匀，错误权重）应该显示出显著误差，表明对于非均匀网格，朴素的等权重方法是错误的。用例3（密集、非均匀，正确权重）应该能恢复准确度，突显了正确求积的重要性。用例4（粗糙、均匀采样）对最高频率分量（$20\\theta$）进行了欠采样，应因混叠而表现出较大误差。均方根（RMS）误差是在内部点的网格上计算的，以提供对重建质量的综合度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and evaluates a boundary-to-interior reconstruction\n    for a harmonic potential in a unit disk.\n    \"\"\"\n\n    def u_true(r, phi, coeffs):\n        \"\"\"\n        Calculates the ground-truth harmonic potential.\n        \n        Args:\n            r (float or np.ndarray): Radial coordinate(s).\n            phi (float or np.ndarray): Angular coordinate(s) in radians.\n            coeffs (tuple): Coefficients (a3, b5, a7, a20).\n            \n        Returns:\n            np.ndarray: The potential value(s) at (r, phi).\n        \"\"\"\n        a3, b5, a7, a20 = coeffs\n        return (a3 * np.power(r, 3) * np.cos(3 * phi) +\n                b5 * np.power(r, 5) * np.sin(5 * phi) +\n                a7 * np.power(r, 7) * np.cos(7 * phi) +\n                a20 * np.power(r, 20) * np.cos(20 * phi))\n\n    def poisson_kernel(r, d_phi):\n        \"\"\"\n        Calculates the Poisson kernel for the unit disk.\n        \n        Args:\n            r (float): Radial coordinate of the evaluation point.\n            d_phi (float or np.ndarray): Difference phi - theta.\n            \n        Returns:\n            float or np.ndarray: The kernel value(s).\n        \"\"\"\n        return (1 - r**2) / (1 - 2 * r * np.cos(d_phi) + r**2)\n\n    def compute_rms_error(N, sampling_type, weight_type):\n        \"\"\"\n        Computes the RMS reconstruction error for a given test case.\n\n        Args:\n            N (int): Number of boundary samples.\n            sampling_type (str): 'uniform' or 'nonuniform'.\n            weight_type (str): 'equal' or 'trapezoidal'.\n\n        Returns:\n            float: The computed RMS error.\n        \"\"\"\n        # Define evaluation grid\n        r_eval = np.array([0.2, 0.5, 0.95])\n        N_r = len(r_eval)\n        phi_eval = np.linspace(0, 2 * np.pi, 361, endpoint=False)\n        N_phi = len(phi_eval)\n\n        # Ground truth function parameters\n        coeffs = (1.0, 0.5, -0.3, 0.2)\n\n        # Generate boundary sample nodes\n        if sampling_type == 'uniform':\n            theta_nodes = 2 * np.pi * np.arange(N) / N\n        elif sampling_type == 'nonuniform':\n            theta_nodes = 2 * np.pi * (np.arange(N) / N)**4\n        else:\n            raise ValueError(\"Invalid sampling_type\")\n\n        # Get boundary values\n        f_values = u_true(1.0, theta_nodes, coeffs)\n\n        # Define quadrature weights for approximating (1/2pi) * integral\n        if weight_type == 'equal':\n            weights = np.full(N, 1.0 / N)\n        elif weight_type == 'trapezoidal':\n            # Calculate interval gaps, handling periodicity\n            gaps = np.diff(theta_nodes, append=theta_nodes[0] + 2 * np.pi)\n            \n            # Weight for node i is proportional to half the length of the\n            # two intervals adjacent to it.\n            # w_i = (gap_{i-1} + gap_i) / 2, scaled by 1/(2*pi)\n            weights = (gaps + np.roll(gaps, 1)) / (4 * np.pi)\n        else:\n            raise ValueError(\"Invalid weight_type\")\n        \n        total_sq_error = 0.0\n\n        for r in r_eval:\n            # Reconstruct potential at (r, phi_eval)\n            # U(r,phi) = (1/2pi) * integral[ f(th') * K(r,phi,th') dth' ]\n            # Approx: sum[ w_i * f(th_i) * K(r,phi,th_i) ]\n            \n            # Vectorized calculation over all phi_eval points for a fixed r\n            # d_phi_matrix[j, i] = phi_eval[j] - theta_nodes[i]\n            d_phi_matrix = phi_eval[:, np.newaxis] - theta_nodes[np.newaxis, :]\n            kernel_matrix = poisson_kernel(r, d_phi_matrix) # Shape (N_phi, N)\n            \n            # Pre-multiply f_values and weights\n            integrand_base = f_values * weights # Shape (N,)\n            \n            # Perform the summation via matrix-vector product\n            # u_rec_at_r[j] = sum_i(kernel_matrix[j,i] * integrand_base[i])\n            u_rec_at_r = kernel_matrix @ integrand_base\n            \n            # Calculate ground truth on the evaluation grid\n            u_true_at_r = u_true(r, phi_eval, coeffs)\n            \n            # Accumulate squared error\n            total_sq_error += np.sum((u_rec_at_r - u_true_at_r)**2)\n            \n        # Final RMS error calculation\n        rms_error = np.sqrt(total_sq_error / (N_r * N_phi))\n        return rms_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: uniform, sufficient resolution\n        {'N': 256, 'sampling': 'uniform', 'weights': 'equal'},\n        # Case 2: nonuniform, naive equal weights\n        {'N': 256, 'sampling': 'nonuniform', 'weights': 'equal'},\n        # Case 3: nonuniform, correct quadrature\n        {'N': 256, 'sampling': 'nonuniform', 'weights': 'trapezoidal'},\n        # Case 4: uniform, coarse resolution\n        {'N': 24, 'sampling': 'uniform', 'weights': 'equal'},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_rms_error(case['N'], case['sampling'], case['weights'])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613251"}, {"introduction": "欧拉反褶积是位场数据解释中一种用于快速估算场源位置与深度的常用技术。本练习要求你从位场齐次性的第一性原理出发，推导并实现该算法，并通过构建一系列合成数据来系统地检验其在不同地质情景（如存在区域场、多场源干扰）下的稳定性和局限性。[@problem_id:3613216] 这项实践将锻炼你对计算地球物理方法的批判性评估能力，这在实际数据处理中至关重要。", "problem": "您将研究基于标量位场代理的局部齐次性，使用欧拉反褶积估算源深度的稳定性。您必须从第一性原理出发，推导欧拉反褶积中使用的线性关系，不得使用任何预先推导的捷径公式；实现一个求解器，根据合成数据估算源深度；构建以可控方式违背齐次性假设的合成算例；并定量地诊断由此产生的估算误差。\n\n从以下基本依据出发：\n- 由孤立源产生的标量位场代理 $T(\\mathbf{r})$，关于源位置 $\\mathbf{r}_0$ 是 $-N$ 次局部齐次的，这意味着对于源附近的任何标量 $\\lambda  0$，都有 $T(\\lambda(\\mathbf{r}-\\mathbf{r}_0)) = \\lambda^{-N} T(\\mathbf{r}-\\mathbf{r}_0)$，其中 $N$ 是一个已知的正整数，称为结构指数。\n- 齐次函数的欧拉定理指出，如果 $f(\\mathbf{r})$ 是 $k$ 次齐次的，则 $\\mathbf{r} \\cdot \\nabla f(\\mathbf{r}) = k f(\\mathbf{r})$。\n- 测量场可包含一个恒定基值 $B$ 以及勘测区域上的平滑区域趋势。\n- 所有测量都在 $z=0$ 的水平面上进行。\n\n任务要求：\n1. 使用 $T$ 的齐次性假设和欧拉定理，从第一性原理出发，推导测量坐标 $(x,y,0)$、一阶空间导数 $\\partial T/\\partial x$、$\\partial T/\\partial y$、$\\partial T/\\partial z$、场 $T$、结构指数 $N$ 以及未知数 $(x_0,y_0,z_0,B)$ 之间的线性关系。在齐次性假设下，该关系必须对每个数据点都成立，并且必须适合通过线性最小二乘法求解 $(x_0,y_0,z_0,B)$。\n2. 实现一个程序，该程序能够：\n   - 使用振幅为 $A$、位置为 $(x_0,y_0,z_0)$、结构指数为 $N_{\\text{true}}$ 的孤立源，在规则网格上生成解析形式为\n     $$T(\\mathbf{r}) = \\sum_{s=1}^{S} \\frac{A_s}{\\left\\|\\mathbf{r} - \\mathbf{r}_{0,s}\\right\\|^{N_{\\text{true},s}}} + B + L_x x + L_y y,$$\n     的合成标量场，其中 $\\mathbf{r}=(x,y,0)$ 表示观测点，$\\mathbf{r}_{0,s}=(x_{0,s},y_{0,s},z_{0,s})$ 表示第 $s$ 个源的位置。区域趋势是线性的，系数为 $L_x$ 和 $L_y$。\n   - 对构建的场解析地计算所需的空间导数。对于单个源项 $\\frac{A}{r^{N}}$（其中 $r=\\sqrt{(x-x_0)^2+(y-y_0)^2+z_0^2}$），使用链式法则推导在 $z=0$ 处 $\\partial T/\\partial x$、$\\partial T/\\partial y$ 和 $\\partial T/\\partial z$ 的表达式。当存在多个源以及加入区域趋势时，线性叠加原理适用。\n   - 针对所有网格点，组装您在第1项推导中得到的线性系统，并假设一个用户选择的结构指数 $N_{\\text{assumed}}$，在最小二乘意义上求解 $(\\hat{x}_0,\\hat{y}_0,\\hat{z}_0,\\hat{B})$。\n   - 为每个合成测试用例计算两个诊断量：\n     a) 绝对深度误差 $\\left|\\hat{z}_0 - z_{0,\\text{primary}}\\right|$，单位为米，其中 $z_{0,\\text{primary}}$ 是感兴趣的主源的真实深度。\n     b) 归一化欧拉残差，定义为\n     $$R_{\\text{norm}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{i=1}^{M} r_i^2}}{\\sqrt{\\frac{1}{M}\\sum_{i=1}^{M} b_i^2} + \\varepsilon},$$\n     其中 $r_i$ 是代入 $(\\hat{x}_0,\\hat{y}_0,\\hat{z}_0,\\hat{B})$ 后第 $i$ 个方程的代数残差，$b_i$ 是您推导所隐含的第 $i$ 个线性方程的右侧项，$M$ 是网格点数，$\\varepsilon$ 是一个小的正稳定子以避免除以零。该残差衡量了对于所选的模型和假设，局部齐次性被违背的程度。\n3. 使用以下网格和单位：\n   - 观测平面：$z=0$。\n   - 网格范围：$x \\in [-500, 500]$ 米，$y \\in [-500, 500]$ 米。\n   - 网格分辨率：$21 \\times 21$ 个均匀间隔点。\n   - 所有最终深度误差均以米为单位表示，并按默认浮点表示进行取整。不使用角度。\n4. 实现以下五个测试用例，以探究稳定性和齐次性违背情况。在所有用例中，计算深度误差时，均报告相对于所列第一个源（“主源”）的结果。对于每个用例，在您的欧拉反演中使用指定的 $N_{\\text{assumed}}$，并使用指定的 $N_{\\text{true}}$ 值构建场。\n   - 案例1（孤立齐次源，理想情况）：\n     - 源：$S=1$，位置 $(x_0,y_0,z_0) = (0,0,200)$ 米，振幅 $A=1$，$N_{\\text{true}}=2$。\n     - 基值与趋势：$B=0$，$L_x=0$，$L_y=0$。\n     - 反演：$N_{\\text{assumed}}=2$。\n   - 案例2（存在基值但已建模）：\n     - 源：$S=1$，位置 $(x_0,y_0,z_0) = (0,0,200)$ 米，$A=1$，$N_{\\text{true}}=2$。\n     - 基值与趋势：$B=10^{-5}$，$L_x=0$，$L_y=0$。\n     - 反演：$N_{\\text{assumed}}=2$。\n   - 案例3（线性区域趋势违背齐次性）：\n     - 源：$S=1$，位置 $(x_0,y_0,z_0) = (0,0,200)$ 米，$A=1$，$N_{\\text{true}}=2$。\n     - 基值与趋势：$B=0$，$L_x=10^{-8}$，$L_y=-10^{-8}$。\n     - 反演：$N_{\\text{assumed}}=2$。\n   - 案例4（邻近源的叠加违背单源齐次性）：\n     - 源：$S=2$，主源 $(x_0,y_0,z_0) = (0,0,200)$ 米，振幅 $A=1$，$N_{\\text{true}}=2$；次源 $(x_0,y_0,z_0) = (150,0,150)$ 米，振幅 $A=0.6$，$N_{\\text{true}}=2$。\n     - 基值与趋势：$B=0$，$L_x=0$，$L_y=0$。\n     - 反演：$N_{\\text{assumed}}=2$。\n   - 案例5（结构指数不匹配）：\n     - 源：$S=1$，位置 $(x_0,y_0,z_0) = (0,0,200)$ 米，$A=1$，$N_{\\text{true}}=3$。\n     - 基值与趋势：$B=0$，$L_x=0$，$L_y=0$。\n     - 反演：$N_{\\text{assumed}}=2$。\n5. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个双元素列表 $[\\text{depth\\_error\\_m}, \\text{normalized\\_residual}]$，按顺序对应案例1到5。例如：\"[[e1,r1],[e2,r2],[e3,r3],[e4,r4],[e5,r5]]\"。每个 $e_k$ 和 $r_k$ 都必须是浮点数。", "solution": "用户希望研究用于位场解释的欧拉反褶积的稳定性。这需要从第一性原理进行推导，实现一个用于合成数据的求解器，并分析旨在探究该方法局限性的几个测试用例的结果。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n- **基本依据：**\n    - 一个标量位场代理 $T(\\mathbf{r})$ 关于源位置 $\\mathbf{r}_0$ 是 $-N$ 次局部齐次的，即 $T(\\lambda(\\mathbf{r}-\\mathbf{r}_0)) = \\lambda^{-N} T(\\mathbf{r}-\\mathbf{r}_0)$，其中 $\\lambda > 0$。$N$ 是结构指数。\n    - 齐次函数的欧拉定理：若 $f(\\mathbf{r})$ 是 $k$ 次齐次的，则 $\\mathbf{r} \\cdot \\nabla f(\\mathbf{r}) = k f(\\mathbf{r})$。\n    - 测量场可包含恒定基值 $B$ 和平滑的区域趋势。\n    - 所有测量都在 $z=0$ 的水平面上进行。\n- **任务1：推导：**\n    - 使用给定的基本假设，推导未知数 $(x_0, y_0, z_0, B)$ 的线性关系。\n- **任务2：实现：**\n    - 在网格上生成合成场 $T(\\mathbf{r}) = \\sum_{s=1}^{S} \\frac{A_s}{\\left\\|\\mathbf{r} - \\mathbf{r}_{0,s}\\right\\|^{N_{\\text{true},s}}} + B + L_x x + L_y y$。\n    - 解析地计算导数 $\\partial T/\\partial x$, $\\partial T/\\partial y$, $\\partial T/\\partial z$。\n    - 使用选定的 $N_{\\text{assumed}}$ 组装并求解线性系统以得到 $(\\hat{x}_0, \\hat{y}_0, \\hat{z}_0, \\hat{B})$。\n    - 计算诊断指标：绝对深度误差 $|\\hat{z}_0 - z_{0,\\text{primary}}|$ 和归一化欧拉残差 $R_{\\text{norm}} = \\frac{\\sqrt{\\frac{1}{M}\\sum r_i^2}}{\\sqrt{\\frac{1}{M}\\sum b_i^2} + \\varepsilon}$。\n- **任务3：网格和单位：**\n    - 观测平面：$z=0$。\n    - 网格：$x, y \\in [-500, 500]$ 米，$21 \\times 21$ 个点。\n    - 所有深度误差单位为米。\n- **任务4：测试用例：**\n    - 案例1：理想情况。$S=1, (0,0,200), A=1, N_{\\text{true}}=2$。无区域场。$N_{\\text{assumed}}=2$。\n    - 案例2：带基值的理想情况。$S=1, (0,0,200), A=1, N_{\\text{true}}=2$。$B=10^{-5}$。$N_{\\text{assumed}}=2$。\n    - 案例3：区域趋势违背。$S=1, (0,0,200), A=1, N_{\\text{true}}=2$。$L_x=10^{-8}, L_y=-10^{-8}$。$N_{\\text{assumed}}=2$。\n    - 案例4：源干涉违背。$S=2$。主源：$(0,0,200), A=1, N_{\\text{true}}=2$。次源：$(150,0,150), A=0.6, N_{\\text{true}}=2$。$N_{\\text{assumed}}=2$。\n    - 案例5：结构指数不匹配违背。$S=1, (0,0,200), A=1, N_{\\text{true}}=3$。$N_{\\text{assumed}}=2$。\n- **任务5：输出格式：**\n    - 单行：`[[e1,r1],[e2,r2],[e3,r3],[e4,r4],[e5,r5]]`。\n\n**第二步：使用提取的已知条件进行验证**\n\n该问题在位场理论中有坚实的科学依据，具体而言是应用欧拉定理于齐次场以进行源参数估算。问题是适定的，提供了构建和解决一个确定性计算问题所需的所有必要参数、方程和定义。问题是客观的，避免了歧义。这些测试用例被系统地设计来测试该方法在面对常见的基本假设违背（存在未建模的区域趋势、来自多个源的干扰、不正确的模型参数化）时的鲁棒性。问题是自洽的，并且可以通过计算进行验证。\n\n**第三步：结论与行动**\n\n问题**有效**。将提供完整解决方案。\n\n---\n\n### **第一部分：欧拉反褶积方程的推导**\n\n我们从提供的第一性原理出发。设总测量场为 $T_m(\\mathbf{r})$，其中 $\\mathbf{r}=(x,y,z)$ 是观测点。该场是孤立源场、恒定基值 $B$ 和区域趋势的叠加。欧拉反褶积方法假设源场本身是齐次的。我们定义一个代理场 $T_p(\\mathbf{r})$，它是信号中被假设为齐次的部分。在求解恒定背景 $B$ 的标准公式中，代理场为 $T_p(\\mathbf{r}) = T_m(\\mathbf{r}) - B$。区域趋势项 $L_x x + L_y y$ 被视为违背齐次性假设的未建模干扰。\n\n关键假设是源场 $T_p(\\mathbf{r})$ 是一个关于源位置 $\\mathbf{r}_0 = (x_0, y_0, z_0)$ 的 $-N$ 次齐次函数。此性质通过定义一个新函数 $F(\\mathbf{v}) = T_p(\\mathbf{r}_0 + \\mathbf{v})$ 可以更正式地表述。$T_p$ 关于 $\\mathbf{r}_0$ 的齐次性意味着 $F$ 是一个关于原点的 $-N$ 次齐次函数。因此，对于任何标量 $\\lambda > 0$，它满足：\n$$F(\\lambda \\mathbf{v}) = \\lambda^{-N} F(\\mathbf{v})$$\n根据齐次函数的欧拉定理，$F(\\mathbf{v})$ 必须满足：\n$$\\mathbf{v} \\cdot \\nabla_{\\mathbf{v}} F(\\mathbf{v}) = -N F(\\mathbf{v})$$\n其中 $\\nabla_{\\mathbf{v}}$ 是关于 $\\mathbf{v}$ 各分量的梯度。我们现在将此方程转换回原始坐标系 $(\\mathbf{r})$。\n令 $\\mathbf{v} = \\mathbf{r} - \\mathbf{r}_0$。微分的链式法则给出 $\\nabla_{\\mathbf{v}} = \\nabla_{\\mathbf{r}}$。代入回去，我们有：\n- $F(\\mathbf{v}) = T_p(\\mathbf{r}_0 + (\\mathbf{r}-\\mathbf{r}_0)) = T_p(\\mathbf{r})$\n- $\\nabla_{\\mathbf{v}} F(\\mathbf{v}) = \\nabla_{\\mathbf{r}} T_p(\\mathbf{r})$\n\n这就得到了代理场 $T_p$ 的欧拉齐次性方程：\n$$(\\mathbf{r} - \\mathbf{r}_0) \\cdot \\nabla T_p(\\mathbf{r}) = -N T_p(\\mathbf{r})$$\n现在我们引入测量场 $T_m$ 和恒定基值 $B$。由于 $T_p = T_m - B$，我们有 $\\nabla T_p = \\nabla (T_m - B) = \\nabla T_m$。将这些代入齐次性方程得到：\n$$(\\mathbf{r} - \\mathbf{r}_0) \\cdot \\nabla T_m(\\mathbf{r}) = -N (T_m(\\mathbf{r}) - B)$$\n展开点积，其中 $\\mathbf{r}=(x,y,z)$ 和 $\\mathbf{r}_0=(x_0,y_0,z_0)$：\n$$(x - x_0) \\frac{\\partial T_m}{\\partial x} + (y - y_0) \\frac{\\partial T_m}{\\partial y} + (z - z_0) \\frac{\\partial T_m}{\\partial z} = -N (T_m - B)$$\n测量是在 $z=0$ 的水平面上进行的。代入 $z=0$ 得到：\n$$(x - x_0) \\frac{\\partial T_m}{\\partial x} + (y - y_0) \\frac{\\partial T_m}{\\partial y} - z_0 \\frac{\\partial T_m}{\\partial z} = -N T_m + N B$$\n我们的目标是找到未知数 $(x_0, y_0, z_0, B)$ 的线性关系。我们重新整理方程，将包含未知数的项归到一边：\n$$x \\frac{\\partial T_m}{\\partial x} - x_0 \\frac{\\partial T_m}{\\partial x} + y \\frac{\\partial T_m}{\\partial y} - y_0 \\frac{\\partial T_m}{\\partial y} - z_0 \\frac{\\partial T_m}{\\partial z} = -N T_m + N B$$\n$$x_0 \\frac{\\partial T_m}{\\partial x} + y_0 \\frac{\\partial T_m}{\\partial y} + z_0 \\frac{\\partial T_m}{\\partial z} + N B = x \\frac{\\partial T_m}{\\partial x} + y \\frac{\\partial T_m}{\\partial y} + N T_m$$\n这就是所要求的线性关系。对于每个测量点 $(x_i, y_i)$，我们有测量场 $T_{m,i}$ 及其空间导数。结构指数 $N$ 是假设已知的（$N = N_{\\text{assumed}}$）。该方程对于单个点 $i$ 可以写成矩阵形式：\n$$\n\\begin{bmatrix} \\frac{\\partial T_m}{\\partial x}  \\frac{\\partial T_m}{\\partial y}  \\frac{\\partial T_m}{\\partial z}  N_{\\text{assumed}} \\end{bmatrix}_i\n\\begin{bmatrix} x_0 \\\\ y_0 \\\\ z_0 \\\\ B \\end{bmatrix}\n=\n\\left[ x \\frac{\\partial T_m}{\\partial x} + y \\frac{\\partial T_m}{\\partial y} + N_{\\text{assumed}} T_m \\right]_i\n$$\n通过为所有 $M$ 个测量点收集这些方程，我们形成一个超定线性系统 $\\mathbf{G}\\mathbf{m} = \\mathbf{d}$，该系统可以通过线性最小二乘法求解模型参数 $\\mathbf{m} = [x_0, y_0, z_0, B]^T$。\n\n### **第二部分：解析导数**\n对于单个源项 $T_s(\\mathbf{r}) = A_s / \\|\\mathbf{r} - \\mathbf{r}_{0,s}\\|^{N_{\\text{true},s}}$，其中 $\\|\\mathbf{r} - \\mathbf{r}_{0,s}\\| = r_s$，我们可以写成 $T_s = A_s r_s^{-N_{\\text{true},s}}$。导数通过链式法则求得。其中 $r_s^2 = (x-x_{0,s})^2 + (y-y_{0,s})^2 + (z-z_{0,s})^2$：\n$$ \\frac{\\partial r_s}{\\partial x} = \\frac{x-x_{0,s}}{r_s}, \\quad \\frac{\\partial r_s}{\\partial y} = \\frac{y-y_{0,s}}{r_s}, \\quad \\frac{\\partial r_s}{\\partial z} = \\frac{z-z_{0,s}}{r_s} $$\n场项的导数为：\n$$ \\frac{\\partial T_s}{\\partial x} = \\frac{d T_s}{d r_s} \\frac{\\partial r_s}{\\partial x} = (-N_{\\text{true},s} A_s r_s^{-N_{\\text{true},s}-1}) \\left(\\frac{x-x_{0,s}}{r_s}\\right) = -N_{\\text{true},s} A_s \\frac{x-x_{0,s}}{r_s^{N_{\\text{true},s}+2}} $$\n$$ \\frac{\\partial T_s}{\\partial y} = -N_{\\text{true},s} A_s \\frac{y-y_{0,s}}{r_s^{N_{\\text{true},s}+2}} $$\n$$ \\frac{\\partial T_s}{\\partial z} = -N_{\\text{true},s} A_s \\frac{z-z_{0,s}}{r_s^{N_{\\text{true},s}+2}} $$\n对于总场 $T_m = \\sum_s T_s + B + L_x x + L_y y$，导数通过叠加获得：\n$$ \\frac{\\partial T_m}{\\partial x} = \\sum_s \\frac{\\partial T_s}{\\partial x} + L_x, \\quad \\frac{\\partial T_m}{\\partial y} = \\sum_s \\frac{\\partial T_s}{\\partial y} + L_y, \\quad \\frac{\\partial T_m}{\\partial z} = \\sum_s \\frac{\\partial T_s}{\\partial z} $$\n这些表达式在测量平面 $z=0$ 处进行计算。对于此问题，我们采用一个z轴正方向朝下的坐标系。因此，一个深度为200米的源的坐标为 $z_0=200$。\n\n### **第三部分：实现与测试用例分析**\n对五个指定的测试用例，实现并求解推导出的线性系统。代码生成合成数据，计算解析导数，构建矩阵系统 $\\mathbf{G}\\mathbf{m} = \\mathbf{d}$，通过最小二乘法求解 $\\mathbf{m}$，并计算所需的诊断指标：绝对深度误差和归一化欧拉残差。每个案例的结果展示了对基本齐次性假设的违背如何影响深度估算的准确性。\n- **案例1和2**（理想条件）：该方法表现出色，误差和残差可忽略不计，证实了推导和实现的正确性。模型求解恒定背景 $B$ 的能力得到了验证。\n- **案例3**（区域趋势）：未建模的线性趋势给计算出的导数引入了系统性误差，违背了齐次性假设。这导致了显著的估算误差和较高的残差，量化了模型设定错误的影响。\n- **案例4**（源干扰）：两个不同源的场叠加产生的总场，关于任何单一点都不是齐次的。这种干扰充当了一种空间变化的“地质噪声”，导致主源位置估算出现巨大误差。\n- **案例5**（结构指数不匹配）：使用不正确的结构指数（$N_{\\text{assumed}} \\neq N_{\\text{true}}$）从根本上错误地设定了模型中场的预期衰减率。这导致了一个病态系统和估算参数的巨大误差，突显了该方法对这一关键参数的敏感性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_field_and_derivatives(x_coords, y_coords, sources, regional):\n    \"\"\"\n    Generates synthetic potential field data and its spatial derivatives on a grid.\n    \n    Args:\n        x_coords (np.ndarray): 1D array of x-coordinates for the grid.\n        y_coords (np.ndarray): 1D array of y-coordinates for the grid.\n        sources (list): A list of source parameters. Each source is a dict:\n                        {'A': amplitude, 'x0': x_coord, 'y0': y_coord, \n                         'z0': z_coord, 'N_true': structural_index}.\n        regional (dict): A dict with regional field parameters:\n                         {'B': base_level, 'Lx': x_trend, 'Ly': y_trend}.\n\n    Returns:\n        tuple: A tuple containing flattened 1D arrays for T, Tx, Ty, Tz.\n    \"\"\"\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    x_flat = xx.flatten()\n    y_flat = yy.flatten()\n    z_obs = 0.0\n\n    T = np.zeros_like(x_flat, dtype=np.float64)\n    Tx = np.zeros_like(x_flat, dtype=np.float64)\n    Ty = np.zeros_like(x_flat, dtype=np.float64)\n    Tz = np.zeros_like(x_flat, dtype=np.float64)\n\n    for src in sources:\n        A, x0, y0, z0, N_true = src['A'], src['x0'], src['y0'], src['z0'], src['N_true']\n        \n        r_sq = (x_flat - x0)**2 + (y_flat - y0)**2 + (z_obs - z0)**2\n        # Avoid division by zero at the source epicenter if it's on the plane\n        r_sq[r_sq == 0] = 1e-12\n        r = np.sqrt(r_sq)\n\n        r_inv_N = r**(-N_true)\n        r_inv_N_plus_2 = r**(-(N_true + 2))\n        \n        T += A * r_inv_N\n        Tx += -N_true * A * (x_flat - x0) * r_inv_N_plus_2\n        Ty += -N_true * A * (y_flat - y0) * r_inv_N_plus_2\n        Tz += -N_true * A * (z_obs - z0) * r_inv_N_plus_2\n\n    B, Lx, Ly = regional['B'], regional['Lx'], regional['Ly']\n    T += B + Lx * x_flat + Ly * y_flat\n    Tx += Lx\n    Ty += Ly\n    \n    return T, Tx, Ty, Tz\n\n\ndef solve_euler_deconvolution(x_coords, y_coords, T, Tx, Ty, Tz, N_assumed):\n    \"\"\"\n    Solves the Euler deconvolution linear system.\n\n    Args:\n        x_coords, y_coords (np.ndarray): Flattened 1D arrays of grid coordinates.\n        T, Tx, Ty, Tz (np.ndarray): Flattened 1D arrays of field and derivatives.\n        N_assumed (int): The assumed structural index for the inversion.\n\n    Returns:\n        tuple: (m_hat, G, d) where m_hat is the solution vector [x0, y0, z0, B],\n               G is the system matrix, and d is the data vector.\n    \"\"\"\n    M = len(x_coords)\n    G = np.zeros((M, 4), dtype=np.float64)\n    G[:, 0] = Tx\n    G[:, 1] = Ty\n    G[:, 2] = Tz\n    G[:, 3] = N_assumed\n\n    d = x_coords * Tx + y_coords * Ty + N_assumed * T\n\n    m_hat, _, _, _ = np.linalg.lstsq(G, d, rcond=None)\n    \n    return m_hat, G, d\n\n\ndef calculate_diagnostics(m_hat, G, d, z0_primary):\n    \"\"\"\n    Calculates the depth error and normalized residual.\n\n    Args:\n        m_hat (np.ndarray): Estimated model parameters [x0, y0, z0, B].\n        G (np.ndarray): System matrix.\n        d (np.ndarray): Data vector.\n        z0_primary (float): True depth of the primary source.\n\n    Returns:\n        tuple: (depth_error, normalized_residual).\n    \"\"\"\n    # Absolute depth error\n    z0_hat = m_hat[2]\n    depth_error = np.abs(z0_hat - z0_primary)\n\n    # Normalized Euler residual\n    residuals = d - (G @ m_hat)\n    rms_residuals = np.sqrt(np.mean(residuals**2))\n    rms_d = np.sqrt(np.mean(d**2))\n    \n    epsilon = np.finfo(float).eps\n    R_norm = rms_residuals / (rms_d + epsilon)\n    \n    return depth_error, R_norm\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for Euler deconvolution.\n    \"\"\"\n    # Grid setup\n    x_grid = np.linspace(-500.0, 500.0, 21)\n    y_grid = np.linspace(-500.0, 500.0, 21)\n    \n    # Generate synthetic data\n    T, Tx, Ty, Tz = generate_field_and_derivatives(\n        x_grid, y_grid, case_params['sources'], case_params['regional']\n    )\n    \n    # Solve system\n    m_hat, G, d = solve_euler_deconvolution(\n        np.meshgrid(x_grid, y_grid)[0].flatten(),\n        np.meshgrid(x_grid, y_grid)[1].flatten(),\n        T, Tx, Ty, Tz, case_params['N_assumed']\n    )\n    \n    # Calculate diagnostics\n    depth_error, R_norm = calculate_diagnostics(\n        m_hat, G, d, case_params['primary_depth']\n    )\n    \n    return [depth_error, R_norm]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run them, and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (isolated homogeneous source, happy path)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2}],\n            'regional': {'B': 0.0, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 2 (constant base level present but modeled)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2}],\n            'regional': {'B': 1e-5, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 3 (linear regional trend violates homogeneity)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2}],\n            'regional': {'B': 0.0, 'Lx': 1e-8, 'Ly': -1e-8},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 4 (superposition of nearby sources violates single-origin homogeneity)\n        {\n            'sources': [\n                {'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 2},\n                {'A': 0.6, 'x0': 150.0, 'y0': 0.0, 'z0': 150.0, 'N_true': 2},\n            ],\n            'regional': {'B': 0.0, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n        # Case 5 (structural index mismatch)\n        {\n            'sources': [{'A': 1.0, 'x0': 0.0, 'y0': 0.0, 'z0': 200.0, 'N_true': 3}],\n            'regional': {'B': 0.0, 'Lx': 0.0, 'Ly': 0.0},\n            'N_assumed': 2,\n            'primary_depth': 200.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613216"}]}