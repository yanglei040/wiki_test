{"hands_on_practices": [{"introduction": "椭圆型偏微分方程，如泊松方程，描述了地球物理学中的许多稳态现象，从引力位到稳态热流。准确地施加边界条件是获得物理上有效解的关键。本练习 [@problem_id:3578589] 将指导你使用“鬼点法”处理单元中心网格上的狄利克雷边界条件，这是一种在保持格式整体二阶精度的同时施加边界条件的强大技术。", "problem": "考虑二维空间开放单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 上的椭圆偏微分方程 (PDE) 泊松问题：\n$$\n-\\,\\Delta u = f \\quad \\text{in } \\Omega,\n$$\n附带狄利克雷边界数据\n$$\nu=g \\quad \\text{on } \\partial\\Omega.\n$$\n要求您推导并实现一个二阶精确的鬼点有限差分格式，该格式在边界附近施加狄利克雷数据，同时保持格式的整体二阶精度。\n\n您的推导必须从微积分基本原理和泰勒展开出发，并遵循计算地球物理学中用于有限体积或单元中心有限差分公式的以下标准建模假设：\n- 未知量 $u$ 在一个均匀笛卡尔网格的单元中心上表示，该网格有 $N\\times N$ 个单元，网格间距为 $h=1/N$，对于整数 $i,j\\in\\{0,1,\\ldots,N-1\\}$，单元中心坐标为 $x_i=(i+\\tfrac{1}{2})h$，$y_j=(j+\\tfrac{1}{2})h$。\n- 五点离散拉普拉斯算子内部格式通过均匀网格上的标准中心差分来近似单元中心的 $-\\Delta u$。\n- 在边界面（例如 $x=0$）附近，您将在反射的单元中心位置（例如 $x=-\\tfrac{h}{2}$）引入一个鬼值，并使用沿外法线方向的局部一维论证在边界面位置施加狄利克雷边界条件。您的推导必须使用泰勒展开来证明鬼值关系及其相对于由光滑解 $u$ 和边界数据 $g$ 所隐含的精确鬼值的精度阶。\n\n任务：\n1. 在一维空间中，推导一个鬼点关系式，用于在单元中心网格上施加边界面 $x=0$ 处的狄利克雷数据 $u(0)=g(0)$，其中未知量位于 $x_{-1}=-\\tfrac{h}{2}$、$x_0=\\tfrac{h}{2}$、$x_1=\\tfrac{3h}{2}$。从边界面或附近单元中心的泰勒展开出发，展示如何用边界数据和相邻的内部值来表示鬼值，并明确说明该关系与精确鬼值的一致性阶。然后，写出邻近边界面得到的法向离散二阶导数格式，并将其与切向差分结合，得到第一层内部单元中心处 $-\\,\\Delta u=f$ 的二维近边格式。\n2. 解释为什么即使边界附近的局部截断误差比内部差（例如，在 $\\partial\\Omega$ 旁一个宽度为 $\\mathcal{O}(h)$ 的单元中心集合上为 $\\mathcal{O}(h)$ 或 $\\mathcal{O}(1)$），对于光滑解 $u$ 和数据 $f,g$，网格加权的离散 $L^2$ 范数下的整体全局误差仍然可以是 $\\mathcal{O}(h^2)$。您的解释应基于椭圆算子的稳定性和平滑特性，以及一个以椭圆偏微分方程的成熟事实为基础的离散能量估计论证。\n3. 在 $\\Omega$ 上使用单元中心网格实现完整的二维格式，并使用鬼值在所有四个边上施加狄利克雷数据。组装大小为 $N^2$ 的未知向量的线性系统，并使用任何直接稀疏求解器求解。对于下面的每个问题实例，计算网格加权的离散 $L^2$ 误差\n$$\n\\|e_h\\|_{2,h} \\;=\\; \\left(h^2 \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\left(u_{ij}^{\\text{num}}-u(x_i,y_j)\\right)^2\\right)^{1/2},\n$$\n和观测到的精度阶\n$$\np \\;=\\; \\log_2\\!\\left(\\frac{\\|e_h\\|_{2,h}}{\\|e_{h/2}\\|_{2,h/2}}\\right).\n$$\n\n测试套件：\n- 案例 A（齐次狄利克雷；光滑非平凡源）：精确解 $u(x,y)=\\sin(2\\pi x)\\sin(3\\pi y)$，因此 $f(x,y)=\\left((2\\pi)^2+(3\\pi)^2\\right)\\sin(2\\pi x)\\sin(3\\pi y)$，$g$ 是 $u$ 在 $\\partial\\Omega$ 上的迹。使用 $N\\in\\{16,32,64\\}$。\n- 案例 B（非齐次狄利克雷；非零源）：精确解 $u(x,y)=\\exp(x+y)$，因此 $f(x,y)=-2\\exp(x+y)$，$g$ 是 $u$ 在 $\\partial\\Omega$ 上的迹。使用 $N\\in\\{16,32,64\\}$。\n- 案例 C（拉普拉斯方程；非齐次边界）：精确解 $u(x,y)=\\cosh(x)\\cos(y)$，因此 $f(x,y)=0$，$g$ 是 $u$ 在 $\\partial\\Omega$ 上的迹。使用 $N\\in\\{16,32,64\\}$。\n\n要求的最终输出：\n- 您的程序必须使用最大的两个网格计算观测阶 $p$（即，比较 $N=32$ 和 $N=64$），并生成一行输出，其中包含三个结果，格式为逗号分隔的列表并用方括号括起来，例如 $[p_A,p_B,p_C]$。\n- 每个 $p$ 必须打印为四舍五入到三位小数的浮点数。\n- 此问题不涉及物理单位。三角函数中出现的角度以弧度为单位。\n\n您的最终答案必须是一个完整的、可运行的程序，该程序完全按照规定执行这些计算，并以要求的单行格式打印最终输出。", "solution": "用户提供的问题被评估为有效，因为它具有科学依据、良定、客观，并包含一个用于标准数值分析任务的完整且一致的设置。该方法学涉及推导、分析和实现泊松方程的有限差分格式。\n\n### 任务 1：鬼点格式的推导\n\n我们需要为单位正方形 $\\Omega=(0,1)\\times(0,1)$ 上的泊松问题 $-\\Delta u = f$（附带狄利克雷边界条件 $u=g$ on $\\partial\\Omega$）推导一个二阶精确的有限差分格式。该格式使用单元中心网格，其中未知量 $u_{ij}$ 表示解在单元中心 $(x_i, y_j) = ((i+\\frac{1}{2})h, (j+\\frac{1}{2})h)$ 处的值，其中 $i,j \\in \\{0, 1, \\ldots, N-1\\}$，网格间距为 $h=1/N$。\n\n首先，我们考虑在边界 $x=0$ 附近的一维问题。第一个内部单元中心位于 $x_0=h/2$。我们在 $x_{-1}=-h/2$ 处引入一个“鬼”单元中心。该鬼点处的解值 $u_{-1}$ 通过施加边界条件 $u(0)=g(0)$ 来确定。\n\n施加此条件的一种二阶精确方法是假设边界值是两个相邻单元中心值的平均值：\n$$\n\\frac{u_0 + u_{-1}}{2} = g(0)\n$$\n这等同于中心插值。为了验证其精度，我们使用精确解 $u(x)$ 在 $x=0$ 处的泰勒级数展开：\n$$\nu(h/2) = u(0) + \\frac{h}{2} u'(0) + \\frac{h^2}{8} u''(0) + O(h^3)\n$$\n$$\nu(-h/2) = u(0) - \\frac{h}{2} u'(0) + \\frac{h^2}{8} u''(0) - O(h^3)\n$$\n将它们相加并除以 2 得到：\n$$\n\\frac{u(h/2) + u(-h/2)}{2} = u(0) + \\frac{h^2}{8} u''(0) + O(h^4)\n$$\n因此，设置 $\\frac{u_0+u_{-1}}{2} = g(0)$ 施加边界条件的误差为 $O(h^2)$。从这个关系中，我们将鬼值 $u_{-1}$ 表示为：\n$$\nu_{-1} = 2g(0) - u_0\n$$\n为了验证这个计算出的鬼值与精确值 $u_{exact}(-h/2)$ 的一致性，我们计算其差值：\n$$\nu_{-1} - u_{exact}(-h/2) = (2g(0) - u_0) - u(-h/2)\n$$\n将 $u_0=u(h/2)$ 和 $g(0)=u(0)$ 在 $x=-h/2$ 附近进行泰勒展开代入，或者更简单地像上面那样在 $x=0$ 附近展开所有项，我们发现：\n$$\nu_{-1} - u_{exact}(-h/2) = \\left(2u(0) - \\left(u(0)+\\frac{h}{2}u'(0)+\\frac{h^2}{8}u''(0)\\right)\\right) - \\left(u(0)-\\frac{h}{2}u'(0)+\\frac{h^2}{8}u''(0)\\right) + O(h^3)\n$$\n$$\n= -\\frac{h^2}{4}u''(0) + O(h^3)\n$$\n因此，计算出的鬼值与精确值在 $O(h^2)$ 阶上是一致的。\n\n接下来，我们为第一个内部点 $x_0=h/2$ 处的 $-u_{xx}$ 构建离散二阶导数格式。我们使用标准的中心差分公式，它涉及点 $x_0-h = -h/2$ 和 $x_0+h = 3h/2$。对应的网格索引是 $-1$ 和 $1$。\n$$\n-u_{xx}(x_0) \\approx -\\frac{u_1 - 2u_0 + u_{-1}}{h^2}\n$$\n代入我们的鬼值表达式 $u_{-1}$：\n$$\n-u_{xx}(x_0) \\approx -\\frac{u_1 - 2u_0 + (2g(0) - u_0)}{h^2} = \\frac{3u_0 - u_1 - 2g(0)}{h^2}\n$$\n这就是所要求的法向二阶导数的近边格式。\n\n最后，我们为邻近左边界 $x=0$ 的网格点 $(x_0, y_j)$ 组装 $-\\Delta u = f$ 的完整二维格式。\n$$\n-\\Delta u(x_0, y_j) = -u_{xx}(x_0, y_j) - u_{yy}(x_0, y_j) = f(x_0, y_j)\n$$\n我们对 $-u_{xx}$ 使用我们推导的格式，对 $-u_{yy}$ 使用标准的中心差分格式：\n$$\n\\frac{3u_{0j} - u_{1j} - 2g(0, y_j)}{h^2} + \\frac{2u_{0j} - u_{0,j-1} - u_{0,j+1}}{h^2} \\approx f_{0j}\n$$\n将所有未知项移到左侧，得到在 $(x_0, y_j)$ 处的最终离散方程：\n$$\n\\frac{5u_{0j} - u_{1j} - u_{0,j-1} - u_{0,j+1}}{h^2} = f_{0j} + \\frac{2g(0, y_j)}{h^2}\n$$\n该方程，连同其他三个边界的类似方程以及内部的标准 5 点格式，构成了待解的未知量 $\\{u_{ij}\\}$ 的线性方程组。\n\n### 任务 2：使用低阶局部误差实现全局精度\n\n对任务 1 中推导的近边格式的局部截断误差 (LTE) 进行直接分析，表明其为 $O(h)$。例如，在 $(x_0, y_j)$ 处，LTE 为 $\\tau_{0j} = (-\\Delta u - L_h u)|_{(x_0,y_j)}$。切向部分 $-u_{yy} - L_h^y u$ 是 $O(h^2)$，但法向部分 $-u_{xx}-L_h^x u$ 的 LTE 为 $-\\frac{1}{4}u_{xx}(0, y_j) + O(h)$。因此，在邻近边界的网格点上，总的 LTE 是 $O(h)$。\n\n人们可能会直观地认为，在 $O(N) = O(1/h)$ 个网格点上的 $O(h)$ LTE 会将全局精度降低到 $O(h)$。然而，对于椭圆问题，离散 $L^2$ 范数下的全局误差通常保持为 $O(h^2)$，这种现象有时被称为超收敛。其解释基于椭圆算子及其离散对应物的稳定性和平滑特性。\n\n设 $A_h$ 是表示离散拉普拉斯算子的矩阵，$e_h$ 是网格点上的全局误差向量，$\\tau_h$ 是 LTE 向量。误差满足方程 $A_h e_h = \\tau_h$。一个基本的稳定性估计表明 $\\|e_h\\|_{2,h} \\le \\|A_h^{-1}\\|_{2,h} \\|\\tau_h\\|_{2,h}$。对于一个稳定的格式，矩阵范数 $\\|A_h^{-1}\\|_{2,h}$ 的界与 $h$ 无关。LTE 向量的范数为 $\\|\\tau_h\\|_{2,h} = \\left(h^2 \\sum_{i,j} \\tau_{ij}^2\\right)^{1/2}$。这个和由大约 $(N-2)^2$ 个内部项（其中 $\\tau_{ij} = O(h^2)$）和大约 $4(N-2)$ 个邻近边界的项（其中 $\\tau_{ij}=O(h)$）组成。\n得到的范数估计为：\n$$\n\\|\\tau_h\\|_{2,h}^2 = h^2 \\left( O(N^2) \\cdot (O(h^2))^2 + O(N) \\cdot (O(h))^2 \\right) = h^2 \\left( O(h^{-2}) \\cdot O(h^4) + O(h^{-1}) \\cdot O(h^2) \\right) = O(h^4) + O(h^3)\n$$\n这表明 $\\|\\tau_h\\|_{2,h} = O(h^{3/2})$，从而导致全局误差为 $\\|e_h\\|_{2,h}=O(h^{3/2})$。虽然比 $O(h)$ 好，但这个简单的分析仍然过于悲观。\n\n需要一个更精细的分析，基于离散形式的格林恒等式或离散格林函数的性质。逆算子 $A_h^{-1}$ 具有平滑特性：它将一个“粗糙”的强迫项（比如我们的 $\\tau_h$，它在边界层有急剧跳跃）映射到一个“更平滑”的解 $e_h$。集中在边界处的较大误差源的影响被抑制，并迅速向区域内部衰减。这类似于力学中的 Saint-Venant 原理。严格的证明（例如，使用 Bramble's Lemma 或 GKS 理论）表明，余维为一的边界集上的 $O(h)$ LTE 对全局 $L^2$ 误差的贡献与主体中的 $O(h^2)$ LTE 的贡献是同阶的。因此，内部和边界的 LTE 都对全局误差产生 $O(h^2)$ 的贡献，从而对于光滑解，观测到的整体精度为 $O(h^2)$。\n\n### 任务 3：实现\n\n数值实现涉及构建和求解由有限差分格式导出的 $N^2 \\times N^2$ 线性系统 $A \\vec{u} = \\vec{b}$。对于一个通用点 $(i,j)$，方程是：\n$$\nc_{ij} u_{ij} - \\sum_{(i',j') \\in \\mathcal{N}_{ij}} u_{i'j'} = h^2 f_{ij} + (\\text{边界项})\n$$\n- **内部点：** $c_{ij}=4$。\n- **边点（非角点）：** $c_{ij}=5$。\n- **角点：** $c_{ij}=6$。\n\n矩阵 $A$ 是稀疏、对称且正定的，使其适用于专门的求解器。下面的 Python 实现使用 `scipy.sparse` 来高效地构建矩阵，并使用 `scipy.sparse.linalg.spsolve` 来求解系统。然后，它计算三个测试用例的离散 $L^2$ 误差和收敛阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef compute_order_of_accuracy(u_exact_func, f_func, N_values):\n    \"\"\"\n    Computes the observed order of accuracy for the Poisson solver.\n\n    Args:\n        u_exact_func: Lambda function for the exact solution u(x, y).\n        f_func: Lambda function for the source term f(x, y).\n        N_values: A list of grid sizes [N_coarse, N_fine].\n\n    Returns:\n        The computed order of accuracy p.\n    \"\"\"\n    errors = []\n    g_func = u_exact_func # Boundary data g is the trace of u\n\n    for N in N_values:\n        h = 1.0 / N\n        \n        # Create grid with cell centers\n        x = (np.arange(N) + 0.5) * h\n        y = (np.arange(N) + 0.5) * h\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        # Assemble the linear system A*u = b\n        # Using row-major mapping: k = i * N + j\n        num_unknowns = N * N\n        mat_A = sparse.lil_matrix((num_unknowns, num_unknowns))\n        vec_b = np.zeros(num_unknowns)\n\n        for i in range(N):\n            for j in range(N):\n                k = i * N + j\n                \n                # Diagonal coefficient is 4 for interior, 5 for edge, 6 for corner\n                diag_coeff = 4.0\n                \n                # Source term\n                b_val = f_func(X[i, j], Y[i, j])\n\n                # Left neighbor / boundary\n                if i > 0:\n                    mat_A[k, (i - 1) * N + j] = -1.0\n                else:\n                    diag_coeff += 1.0\n                    b_val += 2.0 / h**2 * g_func(0.0, Y[i, j])\n\n                # Right neighbor / boundary\n                if i  N - 1:\n                    mat_A[k, (i + 1) * N + j] = -1.0\n                else:\n                    diag_coeff += 1.0\n                    b_val += 2.0 / h**2 * g_func(1.0, Y[i, j])\n\n                # Bottom neighbor / boundary\n                if j > 0:\n                    mat_A[k, i * N + (j - 1)] = -1.0\n                else:\n                    diag_coeff += 1.0\n                    b_val += 2.0 / h**2 * g_func(X[i, j], 0.0)\n                \n                # Top neighbor / boundary\n                if j  N - 1:\n                    mat_A[k, i * N + (j + 1)] = -1.0\n                else:\n                    diag_coeff += 1.0\n                    b_val += 2.0 / h**2 * g_func(X[i, j], 1.0)\n                \n                mat_A[k, k] = diag_coeff\n                vec_b[k] = b_val\n        \n        mat_A = mat_A / h**2\n        \n        # Solve the sparse linear system\n        mat_A_csr = mat_A.tocsr()\n        u_vec = linalg.spsolve(mat_A_csr, vec_b)\n        \n        # Reshape solution vector to grid\n        u_numerical = u_vec.reshape((N, N))\n        \n        # Compute error\n        u_exact_grid = u_exact_func(X, Y)\n        error_grid = u_numerical - u_exact_grid\n        l2_error = np.sqrt(h**2 * np.sum(error_grid**2))\n        errors.append(l2_error)\n        \n    # Calculate observed order of accuracy p\n    # p = log2(error_coarse / error_fine)\n    p = np.log2(errors[0] / errors[1])\n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    N_list_full = [16, 32, 64]\n    \n    # We compare the two largest grids, N=32 and N=64\n    N_list_for_order = [32, 64]\n\n    # Test Case A\n    u_A = lambda x, y: np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    f_A = lambda x, y: ((2 * np.pi)**2 + (3 * np.pi)**2) * u_A(x, y)\n    p_A = compute_order_of_accuracy(u_A, f_A, N_list_for_order)\n\n    # Test Case B\n    u_B = lambda x, y: np.exp(x + y)\n    f_B = lambda x, y: -2 * np.exp(x + y)\n    p_B = compute_order_of_accuracy(u_B, f_B, N_list_for_order)\n\n    # Test Case C\n    u_C = lambda x, y: np.cosh(x) * np.cos(y)\n    f_C = lambda x, y: 0.0 * x * y # Zero function\n    p_C = compute_order_of_accuracy(u_C, f_C, N_list_for_order)\n\n    results = [p_A, p_B, p_C]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```", "id": "3578589"}, {"introduction": "从稳态问题过渡到时域问题，数值稳定性成为显式时间步进格式的首要问题。对于像声波方程这样的双曲型方程，显式格式必须满足特定的稳定性准则，以防止计算结果无界增长。本练习 [@problem_id:3578541] 引导你推导著名的 Courant–Friedrichs–Lewy (CFL) 条件，这是连接时间步长 $\\Delta t$、网格间距 $\\Delta x$ 和物理波速 $c$ 的基本约束。", "problem": "考虑线性声波在占据一个 $d$ 维矩形域 $\\Omega = [0,L]^{d}$ 的均匀、各向同性介质中传播，其波速 $c$ 为常数。该问题具有齐次狄利克雷边界条件 $u(\\mathbf{x},t) = 0$（对所有 $\\mathbf{x} \\in \\partial \\Omega$ 和 $t \\ge 0$ 成立），以及光滑初始条件 $u(\\mathbf{x},0) = f(\\mathbf{x})$ 和 $u_{t}(\\mathbf{x},0) = g(\\mathbf{x})$。其控制偏微分方程是二阶双曲型波动方程 $u_{tt}(\\mathbf{x},t) = c^{2} \\nabla^{2} u(\\mathbf{x},t)$。\n\n在一个均匀笛卡尔网格上，每个坐标方向的网格间距均为 $\\Delta x$。使用标准的二阶中心有限差分拉普拉斯算子对空间进行离散，并使用标准的二阶中心三层显式更新格式对时间进行离散。对于内部网格指标 $\\mathbf{j} = (j_{1},\\dots,j_{d})$ 和时间层 $t^{n} = n \\Delta t$，该格式表示为\n$$\nu_{\\mathbf{j}}^{n+1} \\;=\\; 2 u_{\\mathbf{j}}^{n} \\;-\\; u_{\\mathbf{j}}^{n-1} \\;+\\; c^{2} \\Delta t^{2} \\sum_{m=1}^{d} \\frac{u_{\\mathbf{j}+\\mathbf{e}_{m}}^{n} \\;-\\; 2 u_{\\mathbf{j}}^{n} \\;+\\; u_{\\mathbf{j}-\\mathbf{e}_{m}}^{n}}{\\Delta x^{2}},\n$$\n其中 $\\mathbf{e}_{m}$ 是第 $m$ 个坐标方向上的单位指标向量。在所有时间层上施加齐次狄利克雷边界条件：对于离散边界上的 $\\mathbf{j}$，有 $u_{\\mathbf{j}}^{n} = 0$。\n\n从控制方程和此显式格式出发，通过分析格式的放大因子在所有允许的离散波数上的有界性，推导 Courant–Friedrichs–Lewy (CFL) 稳定性条件，该条件用 $c$、$\\Delta x$ 和 $d$ 来约束时间步长 $\\Delta t$。然后，使用基于算子谱或离散能量的论证，解释为什么齐次狄利克雷边界的存在不允许使用比内部格式所决定的约束更大的 $\\Delta t$。请将您的最终结果表示为最大允许时间步长 $\\Delta t$ 关于 $c$、$\\Delta x$ 和 $d$ 的单个闭式解析表达式。在最终的方框表达式中不要包含单位。", "solution": "基本方程是线性声波方程 $u_{tt} = c^{2} \\nabla^{2} u$，该方程是双曲型的，并容许特征速度为 $c$ 的行波解。一个标准的二阶精度显式有限差分方法结合了时间上和空间上的中心差分。在每个方向网格间距均为 $\\Delta x$ 的均匀笛卡尔网格上，作用在网格函数 $v_{\\mathbf{j}}$ 上的离散拉普拉斯算子 $\\Delta_{h}$ 为\n$$\n\\Delta_{h} v_{\\mathbf{j}} \\;=\\; \\sum_{m=1}^{d} \\frac{v_{\\mathbf{j}+\\mathbf{e}_{m}} \\;-\\; 2 v_{\\mathbf{j}} \\;+\\; v_{\\mathbf{j}-\\mathbf{e}_{m}}}{\\Delta x^{2}}.\n$$\n波动方程的显式三层更新格式为\n$$\nu_{\\mathbf{j}}^{n+1} \\;=\\; 2 u_{\\mathbf{j}}^{n} \\;-\\; u_{\\mathbf{j}}^{n-1} \\;+\\; c^{2} \\Delta t^{2} \\,\\Delta_{h} u_{\\mathbf{j}}^{n}.\n$$\n\n为推导 Courant–Friedrichs–Lewy (CFL) 稳定性条件，我们进行 von Neumann 分析。对于线性常系数格式，该分析评估离散平面波的放大因子。尽管物理问题具有齐次狄利克雷边界条件，但显式局域格式的 CFL 约束源于内部更新格式；因此分析局部类似于平面波的模态就足够了。考虑离散傅里叶模态\n$$\nu_{\\mathbf{j}}^{n} \\;=\\; \\rho^{n} \\exp\\!\\Big( i \\sum_{m=1}^{d} j_{m} \\theta_{m} \\Big),\n$$\n其中相位角 $\\theta_{m} \\in [0,\\pi]$ 捕捉了网格能分辨的最高频率。利用线性和可分离性，将此试探解代入更新格式，得到\n$$\n\\rho^{n+1} \\exp\\!\\Big( i \\sum_{m} j_{m} \\theta_{m} \\Big) \\;-\\; 2 \\rho^{n} \\exp\\!\\Big( i \\sum_{m} j_{m} \\theta_{m} \\Big) \\;+\\; \\rho^{n-1} \\exp\\!\\Big( i \\sum_{m} j_{m} \\theta_{m} \\Big)\n$$\n$$\n=\\; c^{2} \\Delta t^{2} \\sum_{m=1}^{d} \\frac{\\exp\\!\\big( i (j_{m}+1) \\theta_{m} \\big) + \\exp\\!\\big( i (j_{m}-1) \\theta_{m} \\big) - 2 \\exp\\!\\big( i j_{m} \\theta_{m} \\big)}{\\Delta x^{2}} \\prod_{k \\neq m} \\exp\\!\\big( i j_{k} \\theta_{k} \\big) \\,\\rho^{n}.\n$$\n消去公因子 $\\exp\\!\\big( i \\sum_{m} j_{m} \\theta_{m} \\big) \\rho^{n}$ 并使用 $\\exp(i \\theta) + \\exp(-i \\theta) - 2 = 2 (\\cos \\theta - 1) = -4 \\sin^{2}(\\theta/2)$, 我们得到放大因子 $\\rho$ 的标量递推关系：\n$$\n\\rho^{2} \\;-\\; 2 \\rho \\;+\\; 1 \\;=\\; -\\, 4 \\rho \\, \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big),\n$$\n其中 $\\lambda := \\frac{c \\Delta t}{\\Delta x}$ 是当间距均匀时每个坐标的无量纲 Courant 数。重新整理得\n$$\n\\rho^{2} \\;+\\; \\rho \\Big( 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big) \\;-\\; 2 \\Big) \\;+\\; 1 \\;=\\; 0.\n$$\n令 $z := \\rho$ 并两边除以 $z$ 得到\n$$\nz \\;+\\; \\frac{1}{z} \\;=\\; 2 \\;-\\; 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big).\n$$\n对于守恒型双曲方程的二阶中心格式，为保证稳定性，放大因子必须是单位模的，即 $|z| = 1$，因此我们可以设 $z = \\exp(i \\Omega \\Delta t)$，其中 $\\Omega$ 为某个实离散频率。于是 $z + z^{-1} = 2 \\cos(\\Omega \\Delta t)$，这意味着\n$$\n2 \\cos(\\Omega \\Delta t) \\;=\\; 2 \\;-\\; 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big).\n$$\n对于所有允许的 $\\theta_{m}$，$\\Omega$ 均为实数的充要条件是，右端项对所有 $\\theta_{m}$ 均位于区间 $[-2,2]$ 内。因此，\n$$\n\\Big| \\, 2 \\;-\\; 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big) \\, \\Big| \\;\\le\\; 2\n\\quad \\Longleftrightarrow \\quad\n0 \\;\\le\\; \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big) \\;\\le\\; 1.\n$$\n因为 $\\sin^{2}(\\cdot)$ 的上界是 $1$，所以在所有可分辨的网格波数下的最坏情况在每个 $\\sin^{2}(\\theta_{m}/2)$ 都趋近于 $1$ 时达到。因此，一个充分且紧致的界是\n$$\n\\sum_{m=1}^{d} \\lambda^{2} \\;\\le\\; 1.\n$$\n由于所有方向上的间距均匀，每个 $m$ 的 $\\lambda$ 都相同，得到\n$$\nd \\lambda^{2} \\;\\le\\; 1\n\\quad \\Longrightarrow \\quad\n\\lambda \\;\\le\\; \\frac{1}{\\sqrt{d}}\n\\quad \\Longrightarrow \\quad\n\\Delta t \\;\\le\\; \\frac{\\Delta x}{c \\sqrt{d}}.\n$$\n这就是在 $d$ 维均匀网格上，波动方程的显式二阶精度中心格式的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n现在我们解释为什么齐次狄利克雷边界不会放宽这个内部时间步长的约束。有两个基于第一性原理的互补观点：\n\n1. 谱的观点。带有齐次狄利克雷边界条件的离散拉普拉斯算子是一个对称负定矩阵，其特征向量是正弦函数的张量积，其特征值为\n$$\n\\mu_{\\mathbf{k}} \\;=\\; \\frac{2}{\\Delta x^{2}} \\sum_{m=1}^{d} \\big( \\cos(\\theta_{m}) - 1 \\big)\n\\;=\\; -\\, \\frac{4}{\\Delta x^{2}} \\sum_{m=1}^{d} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big),\n$$\n其中离散角 $\\theta_{m}$ 由网格和边界决定。其谱半径 $|\\mu_{\\max}|$ 的上界为 $\\frac{4}{\\Delta x^{2}} \\sum_{m=1}^{d} 1 = \\frac{4 d}{\\Delta x^{2}}$，与周期性内部格式的界相同。随着网格加密，允许的最大 $\\sin^{2}$ 值趋近于 $1$，因此狄利克雷谱渐近地达到与内部平面波分析相同的界。显式更新将该谱乘以 $c^{2} \\Delta t^{2}$，而上面推导的三层稳定性要求仅取决于 $\\sum_{m} \\sin^{2}(\\theta_{m}/2)$ 的上确界，狄利克雷边界条件不能使其超过 $1$；因此它们不允许更大的 $\\Delta t$。\n\n2. 局域能量观点。CFL 约束反映了这样一个要求：相对于特征速度 $c$，数值信息在每个时间步内传播的距离不能超过一个网格单元。这种局域性由内部格式的宽度和波速控制，且与边界条件无关。齐次狄利克雷边界限制了全局模态的形状，但不改变内部更新中的局域耦合。因此，最具限制性的局域模态——对应于网格尺度的振荡——仍然决定了稳定性极限，而边界条件的施加并不会放宽内部的时间步长约束。\n\n因此，为保证这个在 $d$ 维均匀网格上的显式二阶精度格式的稳定性，最大允许时间步长为\n$$\n\\Delta t_{\\max} \\;=\\; \\frac{\\Delta x}{c \\sqrt{d}}.\n$$", "answer": "$$\\boxed{\\frac{\\Delta x}{c \\sqrt{d}}}$$", "id": "3578541"}, {"introduction": "在波动理论的高频极限下，程函方程控制着波的走时，这在地震成像中至关重要。本练习 [@problem_id:3578554] 要求你实现快速行进法（Fast Marching Method），这是一种求解该非线性方程的高效算法。通过这个练习，你将探索不同问题提法（初值问题与边值问题）以及焦散等物理现象带来的数值挑战。", "problem": "考虑非均匀介质中的声波方程 $c(\\mathbf{x})^{-2}\\,\\partial_{t}^{2} u(\\mathbf{x},t) - \\nabla^{2} u(\\mathbf{x},t) = 0$，其中 $u(\\mathbf{x},t)$ 是压力场，$c(\\mathbf{x})$ 是以 $\\mathrm{m/s}$ 表示的与位置相关的波速。在高频极限下，根据 Wentzel–Kramers–Brillouin (WKB) 拟设，领头阶相位 $T(\\mathbf{x})$ 满足程函方程 $|\\nabla T(\\mathbf{x})| = 1/c(\\mathbf{x})$，其中 $T(\\mathbf{x})$ 是以 $\\mathrm{s}$ 为单位的走时，$\\mathbf{x}\\in\\Omega$ 表示在以 $\\mathrm{m}$ 为单位测量的域 $\\Omega\\subset\\mathbb{R}^{2}$ 中的位置。在计算地球物理学中，求解程函方程通常有两种提法：边值问题和初值问题。\n\n在边值问题提法中，我们在边界 $\\Gamma\\subset\\partial\\Omega$ 上指定狄利克雷数据 $T|_{\\Gamma} = 0$，将 $T(\\mathbf{x})$ 建模为从边界到 $\\mathbf{x}$ 的最小走时。在点源的初值问题提法中，我们在源点位置 $\\mathbf{x}_{s}\\in\\Omega$ 指定 $T(\\mathbf{x}_{s}) = 0$，并计算 $T(\\mathbf{x})$ 作为从 $\\mathbf{x}_{s}$ 到 $\\mathbf{x}$ 的最小走时。两种提法都可能出现几何奇点，即射线相交或存在多条测地线的地方，通常称为焦散。在焦散附近，由于 $T(\\mathbf{x})$ 的不可微性，数值方法可能会产生较大的误差。\n\n从声波方程和导出程函方程的高频近似这一基本基础出发，推导并实现一个数值求解器，用于求解方形域 $\\Omega = [0,1]^{2}$（单位 $\\mathrm{m}\\times\\mathrm{m}$）上的方程 $|\\nabla T| = 1/c(\\mathbf{x})$。求解器应使用网格间距为 $h$（单位 $\\mathrm{m}$）的迎风离散化方法，并结合快速行进法 (FMM)。该实现必须符合因果性和比较原理。定义慢度 $s(\\mathbf{x}) = 1/c(\\mathbf{x})$（单位 $\\mathrm{s/m}$），并在更新规则中局部使用它。两个坐标方向使用相同的各向同性局部模板间距 $h$。\n\n对于边值问题提法，在外边界 $\\Gamma = \\partial\\Omega$ 上施加狄利克雷条件 $T|_{\\Gamma} = 0$。对于初值问题提法，在距离 $\\mathbf{x}_{s}$ 最近的单个网格点上施加 $T(\\mathbf{x}_{s}) = 0$。\n\n您必须在指定的测试用例下，量化两种提法在焦散附近的数值误差。当有解析参考解时，使用它；否则，构建一个高分辨率的数值参考解，并将粗分辨率结果限制在近似焦散区域的掩码内进行比较。具体来说，在每边有 $N_{\\text{coarse}}$ 个点的粗网格和每边有 $N_{\\text{fine}}$ 个点的细网格上计算 $T(\\mathbf{x})$，其均匀间距分别为 $h_{\\text{coarse}} = 1/(N_{\\text{coarse}}-1)$ 和 $h_{\\text{fine}} = 1/(N_{\\text{fine}}-1)$（单位 $\\mathrm{m}$）。对于没有解析解的情况，通过最近邻采样将细网格解降采样到粗网格上。\n\n定义以下具有物理和数值上合理参数的测试套件：\n\n测试用例 A（边值问题，恒定速度）：\n- 域 $\\Omega = [0,1]^{2}$（单位 $\\mathrm{m}$）。波速 $c(\\mathbf{x}) = c_{0}$，其中 $c_{0} = 1500$（单位 $\\mathrm{m/s}$）。粗网格尺寸 $N_{\\text{coarse}} = 101$，细网格尺寸 $N_{\\text{fine}} = 401$。解析解为 $T_{\\text{exact}}(\\mathbf{x}) = \\min\\{x, 1-x, y, 1-y\\}/c_{0}$（单位 $\\mathrm{s}$）。焦散集由沿 $x = 1/2$ 和 $y = 1/2$ 的不可微性来表征。在这些线周围定义一个半宽度为 $\\delta = 2 h_{\\text{coarse}}$（单位 $\\mathrm{m}$）的焦散带，并计算粗网格数值解与限制在该带内的 $T_{\\text{exact}}(\\mathbf{x})$ 之间的最大绝对误差（单位 $\\mathrm{s}$）。\n\n测试用例 B（初值问题，透镜速度）：\n- 域 $\\Omega = [0,1]^{2}$（单位 $\\mathrm{m}$）。波速 $c(\\mathbf{x}) = c_{0}\\left(1 - \\alpha \\exp\\left(-\\left(\\frac{(x-0.5)^{2}}{\\sigma_{x}^{2}} + \\frac{(y-0.5)^{2}}{\\sigma_{y}^{2}}\\right)\\right)\\right)$（单位 $\\mathrm{m/s}$），其中 $c_{0} = 1500$，$\\alpha = 0.4$，$\\sigma_{x} = 0.15$，$\\sigma_{y} = 0.25$（除 $c_{0}$ 单位为 $\\mathrm{m/s}$ 外均为无量纲）；这种选择会产生一个较慢的中心区域，使射线向内弯曲并产生聚焦。源点位置 $\\mathbf{x}_{s} = (0.2, 0.5)$（单位 $\\mathrm{m}$）。粗网格尺寸 $N_{\\text{coarse}} = 101$，细网格尺寸 $N_{\\text{fine}} = 401$。通过在每个内部网格点 $(i,j)$ 计算量 $a = \\min\\{T_{i-1,j}, T_{i+1,j}\\}$ 和 $b = \\min\\{T_{i,j-1}, T_{i,j+1}\\}$，并选择满足 $|a-b| \\leq \\tau$（其中 $\\tau = 1.5\\, h_{\\text{coarse}}\\, s_{\\max}$，单位 $\\mathrm{s}$，$s_{\\max} = \\max_{\\mathbf{x}\\in\\Omega} s(\\mathbf{x})$，单位 $\\mathrm{s/m}$）的点，在粗网格上构建一个焦散指示掩码。使用降采样到粗网格的细网格解作为参考解，并计算此掩码内的最大绝对误差（单位 $\\mathrm{s}$）。\n\n测试用例 C（边值问题，透镜速度）：\n- 与测试用例 B 相同的透镜速度和网格尺寸。边界条件 $T|_{\\Gamma} = 0$ 施加在 $\\Gamma = \\partial\\Omega$ 上。与测试用例 B 一样，基于粗网格解构建相同的焦散指示掩码，并使用降采样的细网格解作为参考解，计算此掩码内的最大绝对误差（单位 $\\mathrm{s}$）。\n\n您的程序必须：\n1. 实现一个与程函方程 $|\\nabla T| = s(\\mathbf{x})$ 一致的、保持因果性的迎风离散化，在每个网格点使用网格间距为 $h$（单位 $\\mathrm{m}$）和慢度为 $s(\\mathbf{x})$（单位 $\\mathrm{s/m}$）进行局部二次求解。\n2. 使用快速行进法 (FMM) 实现从指定的边界或点源种子开始的高效前沿传播。\n3. 分别为测试用例 A、B 和 C 生成三个浮点数输出，对应于指定焦散掩码内的最大绝对误差（单位 $\\mathrm{s}$）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如 `[r_{A}, r_{B}, r_{C}]$），其中每个 $r_{*}$ 是一个以 $\\mathrm{s}$ 为单位的浮点数。\n\n角度单位不适用。所有物理量必须使用一致的国际单位制 (SI 单位)。程序不得接受任何外部输入，并且必须可直接运行。", "solution": "所提出的问题是计算地球物理学中一个有效且适定的练习。它要求使用快速行进法 (FMM) 对程函方程进行数值求解，并随后在焦散附近区域进行误差分析。所有参数、方程和方法都是该领域的标准方法，并且给出了足够的细节和科学严谨性。\n\n问题的核心是求解程函方程，该方程模拟了高频波的走时 $T(\\mathbf{x})$。方程如下：\n$$\n|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})\n$$\n其中 $\\mathbf{x} = (x,y)$ 是二维域 $\\Omega$ 中的空间位置，$\\nabla T$ 是走时场的梯度，$s(\\mathbf{x}) = 1/c(\\mathbf{x})$ 是介质的慢度，而 $c(\\mathbf{x})$ 是波速。将两边平方，得到其更常见的非线性偏微分方程 (PDE) 形式：\n$$\n(\\partial_x T)^2 + (\\partial_y T)^2 = s(x,y)^2\n$$\n该方程属于 Hamilton-Jacobi 类型。其解可能会出现奇点（波前的角点和尖点），这些奇点对应于走时场 $T(\\mathbf{x})$ 中的不可微点。标准的有限差分格式在这些点会失效。一种稳健的方法是使用迎风离散化，该方法遵循波传播的物理原理，即信息仅从源点向外流动，从走时较小的区域流向走时较大的区域。\n\n我们将域 $\\Omega = [0,1]^2$ 离散化为一个间距为 $h$ 的均匀网格。设 $T_{i,j}$ 是 $T(ih, jh)$ 的数值近似。一个一阶迎风、保持因果性的有限差分格式可以写成：\n$$\n\\left( \\max(D_{ix}^{-}T, -D_{ix}^{+}T, 0) \\right)^2 + \\left( \\max(D_{jy}^{-}T, -D_{jy}^{+}T, 0) \\right)^2 = s_{i,j}^2\n$$\n例如，其中 $D_{ix}^{-}T = (T_{i,j} - T_{i-1,j})/h$ 是后向差分算子。当根据邻近点求解 $T_{i,j}$ 时，这个看似复杂的公式会得到简化。假设波前从走时已知且最小的方向传播到点 $(i,j)$，令 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 分别为 $x$ 和 $y$ 方向上邻近点的最小已知走时。那么 $T_{i,j}$ 的更新由以下二次方程控制：\n$$\n\\left( \\frac{T_{i,j} - T_x}{h} \\right)^2 + \\left( \\frac{T_{i,j} - T_y}{h} \\right)^2 = s_{i,j}^2\n$$\n这个方程仅在两项都有贡献时有效，即当 $T_{i,j}  T_x$ 且 $T_{i,j}  T_y$ 时。重新整理后得到关于 $T \\equiv T_{i,j}$ 的二次方程：$aT^2 + bT + c = 0$，其中 $a=2$，$b=-2(T_x+T_y)$，$c=T_x^2+T_y^2 - (hs_{i,j})^2$。我们取较大的根，它对应于扩张的波前：\n$$\nT = \\frac{T_x + T_y + \\sqrt{2(hs_{i,j})^2 - (T_x-T_y)^2}}{2}\n$$\n此更新仅在判别式为非负且得到的 $T$ 大于 $T_x$ 和 $T_y$ 时有效。如果这些条件不满足，则意味着特征方向与某个坐标轴对齐，更新简化为从走时最小的邻近点进行的一维传播。假设 $T_x \\le T_y$，则更新变为 $T = T_x + hs_{i,j}$。\n\n快速行进法 (FMM) 是一种高效的算法，它以正确的顺序求解离散化的程函方程，模拟波前的物理传播过程。它使用一个最小优先队列来系统地推进前沿。网格点被分为三类：\n1.  **冰冻（或已接受）(Frozen / Accepted):** 走时 $T$ 已被最终确定的点。\n2.  **窄带（或试验）(Narrow Band / Trial):** 冰冻点的邻近点，其走时已被初步计算。\n3.  **远方 (Far Away):** 所有其他点，其走时为 $T = \\infty$。\n\nFMM 算法流程如下：\n1.  **初始化:** 将所有点的走时 $T$ 初始化为 $\\infty$，但源点（在边界 $\\Gamma$ 上或在源位置 $\\mathbf{x}_s$）除外，其走时设为 $T=0$。所有非无穷大的点都被添加到最小优先队列（窄带）中。\n2.  **迭代:**\n    a. 从优先队列中提取具有最小走时的点 $(i,j)$。\n    b. 将此点标记为“冰冻”。\n    c. 对于 $(i,j)$ 的每个非“冰冻”的邻近点 $(ni, nj)$：\n        i.  使用上述二次更新规则，利用“冰冻”邻近点的值（包括新近冰冻的点 $(i,j)$）计算一个新的初步走时。\n        ii. 如果这个新时间小于该邻近点当前的时间，则更新该邻近点的时间，并在优先队列中添加/更新它。\n3.  **终止:** 当优先队列为空时，算法终止。\n\n这个过程确保了点是按照走时递增的顺序处理的，从而正确地捕捉到程函方程的粘性解。\n\n解决方案将以单个 Python 脚本的形式实现。一个核心函数 `fmm_solver` 将实现 FMM 算法。对于每个测试用例，将使用适当的网格尺寸（$N_{\\text{coarse}} = 101$，$N_{\\text{fine}} = 401$）和慢度模型调用此函数。\n\n**测试用例 A（边值问题，恒定速度）：**\n在粗网格上运行 FMM，速度为 $c(\\mathbf{x}) = 1500$ m/s（慢度 $s = 1/1500$ s/m），边界条件为 $T|_{\\partial\\Omega}=0$。将得到的数值解 $T_{\\text{num}}$ 与解析解 $T_{\\text{exact}}(\\mathbf{x}) = \\min\\{x, 1-x, y, 1-y\\}/c_{0}$ 进行比较。在围绕直线 $x=1/2$ 和 $y=1/2$ 的半宽度为 $\\delta = 2 h_{\\text{coarse}}$ 的焦散带内计算误差。\n\n**测试用例 B（初值问题，透镜速度）：**\n引入一个透镜状的速度异常。在粗网格和细网格上运行 FMM，源点为 $\\mathbf{x}_s=(0.2, 0.5)$。细网格解 $T_{\\text{fine}}$ 被降采样以作为高保真度的参考解 $T_{\\text{ref}}$。通过识别粗网格上波前从水平和垂直方向几乎同时到达的点来算法化地生成焦散掩码，即满足 $|\\min(T_{i-1,j}, T_{i+1,j}) - \\min(T_{i,j-1}, T_{i,j+1})| \\le \\tau$ 的点，其中 $\\tau$ 是一个小阈值。然后在此掩码内计算最大绝对误差 $|T_{\\text{coarse}} - T_{\\text{ref}}|$。\n\n**测试用例 C（边值问题，透镜速度）：**\n此用例与测试用例 B 类似，但使用边界条件 $T|_{\\partial\\Omega}=0$ 而非点源。生成粗、细网格解，从粗网格解构建焦散掩码，以及计算误差的程序与测试用例 B 完全相同。\n\n最终输出将是一个列表，包含为每个测试用例计算出的三个最大绝对误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def fmm_solver(slowness_grid, h, seeds):\n        \"\"\"\n        Solves the eikonal equation using the Fast Marching Method.\n\n        Args:\n            slowness_grid (np.ndarray): 2D array of slowness values s(x,y).\n            h (float): Grid spacing.\n            seeds (list): A list of tuples (i, j, value) for initial points.\n\n        Returns:\n            np.ndarray: 2D array of travel times T(x,y).\n        \"\"\"\n        n = slowness_grid.shape[0]\n        travel_times = np.full((n, n), np.inf, dtype=np.float64)\n        # States: 0=Far, 1=Trial, 2=Accepted\n        states = np.zeros((n, n), dtype=np.int8)\n        pq = []\n\n        for i, j, val in seeds:\n            travel_times[i, j] = val\n            states[i, j] = 1  # Trial\n            heapq.heappush(pq, (val, i, j))\n\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            \n            if states[i, j] == 2:\n                continue\n            \n            states[i, j] = 2  # Accepted\n\n            # Process neighbors\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 = ni  n and 0 = nj  n and states[ni, nj] != 2:\n                    \n                    # Find min travel times from accepted neighbors in each direction\n                    tx_min = np.inf\n                    if ni > 0 and states[ni - 1, nj] == 2:\n                        tx_min = min(tx_min, travel_times[ni - 1, nj])\n                    if ni  n - 1 and states[ni + 1, nj] == 2:\n                        tx_min = min(tx_min, travel_times[ni + 1, nj])\n\n                    ty_min = np.inf\n                    if nj > 0 and states[ni, nj - 1] == 2:\n                        ty_min = min(ty_min, travel_times[ni, nj - 1])\n                    if nj  n - 1 and states[ni, nj + 1] == 2:\n                        ty_min = min(ty_min, travel_times[ni, nj + 1])\n                    \n                    # Solve for updated time\n                    s_val = slowness_grid[ni, nj]\n                    t_neighbors = sorted([v for v in [tx_min, ty_min] if v != np.inf])\n\n                    if not t_neighbors:\n                        continue \n                    \n                    t_new = np.inf\n                    if len(t_neighbors) == 1:\n                        t1 = t_neighbors[0]\n                        t_new = t1 + h * s_val\n                    else: # len == 2\n                        t1, t2 = t_neighbors[0], t_neighbors[1]\n                        \n                        # Quadratic solver for 2D update\n                        a = 2.0\n                        b = -2.0 * (t1 + t2)\n                        c = t1**2 + t2**2 - (h * s_val)**2\n                        \n                        discriminant = b**2 - 4 * a * c\n                        \n                        if discriminant >= 0:\n                            t_quad = (-b + np.sqrt(discriminant)) / (2.0 * a)\n                            if t_quad > t2:\n                                t_new = t_quad\n                            else:\n                                # Fallback to 1D update\n                                t_new = t1 + h * s_val\n                        else:\n                            # Fallback to 1D update\n                            t_new = t1 + h * s_val\n\n                    if t_new  travel_times[ni, nj]:\n                        travel_times[ni, nj] = t_new\n                        states[ni, nj] = 1 # Trial\n                        heapq.heappush(pq, (t_new, ni, nj))\n\n        return travel_times\n\n    def run_case_a():\n        N_coarse = 101\n        c0 = 1500.0\n        s0 = 1.0 / c0\n        h_coarse = 1.0 / (N_coarse - 1)\n\n        slowness = np.full((N_coarse, N_coarse), s0, dtype=np.float64)\n        \n        seeds = []\n        for i in range(N_coarse):\n            seeds.append((i, 0, 0.0))\n            seeds.append((i, N_coarse - 1, 0.0))\n        for j in range(1, N_coarse - 1):\n            seeds.append((0, j, 0.0))\n            seeds.append((N_coarse - 1, j, 0.0))\n        \n        t_numerical = fmm_solver(slowness, h_coarse, seeds)\n\n        x = np.linspace(0, 1, N_coarse)\n        y = np.linspace(0, 1, N_coarse)\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n        \n        t_exact = np.minimum(np.minimum(xx, 1-xx), np.minimum(yy, 1-yy)) * s0\n        \n        delta = 2 * h_coarse\n        caustic_mask = (np.abs(xx - 0.5) = delta) | (np.abs(yy - 0.5) = delta)\n        \n        error = np.abs(t_numerical - t_exact)\n        max_error_in_mask = np.max(error[caustic_mask])\n        \n        return max_error_in_mask\n\n    def run_case_b():\n        N_coarse, N_fine = 101, 401\n        h_coarse, h_fine = 1.0 / (N_coarse - 1), 1.0 / (N_fine - 1)\n\n        c0, alpha, sx, sy = 1500.0, 0.4, 0.15, 0.25\n        source_loc = (0.2, 0.5)\n\n        def speed_func(x, y):\n            return c0 * (1 - alpha * np.exp(-((x - 0.5)**2 / sx**2 + (y - 0.5)**2 / sy**2)))\n\n        # Coarse grid run\n        x_c = np.linspace(0, 1, N_coarse)\n        y_c = np.linspace(0, 1, N_coarse)\n        xx_c, yy_c = np.meshgrid(x_c, y_c, indexing='ij')\n        s_coarse = 1.0 / speed_func(xx_c, yy_c)\n        \n        source_idx_c = (np.abs(x_c - source_loc[0])).argmin(), (np.abs(y_c - source_loc[1])).argmin()\n        t_coarse = fmm_solver(s_coarse, h_coarse, [(source_idx_c[0], source_idx_c[1], 0.0)])\n        \n        # Fine grid run (reference)\n        x_f = np.linspace(0, 1, N_fine)\n        y_f = np.linspace(0, 1, N_fine)\n        xx_f, yy_f = np.meshgrid(x_f, y_f, indexing='ij')\n        s_fine = 1.0 / speed_func(xx_f, yy_f)\n        \n        source_idx_f = (np.abs(x_f - source_loc[0])).argmin(), (np.abs(y_f - source_loc[1])).argmin()\n        t_fine = fmm_solver(s_fine, h_fine, [(source_idx_f[0], source_idx_f[1], 0.0)])\n        \n        # Downsample fine to coarse\n        scale = (N_fine - 1) // (N_coarse - 1)\n        t_ref = np.zeros_like(t_coarse)\n        for i in range(N_coarse):\n            for j in range(N_coarse):\n                t_ref[i, j] = t_fine[i * scale, j * scale]\n\n        # Caustic mask on coarse grid\n        s_max = np.max(s_coarse)\n        tau = 1.5 * h_coarse * s_max\n        caustic_mask = np.zeros((N_coarse, N_coarse), dtype=bool)\n        for i in range(1, N_coarse - 1):\n            for j in range(1, N_coarse - 1):\n                a = min(t_coarse[i - 1, j], t_coarse[i + 1, j])\n                b = min(t_coarse[i, j - 1], t_coarse[i, j + 1])\n                if abs(a - b) = tau:\n                    caustic_mask[i, j] = True\n        \n        error = np.abs(t_coarse - t_ref)\n        if np.any(caustic_mask):\n            max_error_in_mask = np.max(error[caustic_mask])\n        else: # If mask is empty, problem implies there should be a result.\n            max_error_in_mask = 0.0\n\n        return max_error_in_mask\n\n    def run_case_c():\n        N_coarse, N_fine = 101, 401\n        h_coarse, h_fine = 1.0 / (N_coarse - 1), 1.0 / (N_fine - 1)\n\n        c0, alpha, sx, sy = 1500.0, 0.4, 0.15, 0.25\n\n        def speed_func(x, y):\n            return c0 * (1 - alpha * np.exp(-((x - 0.5)**2 / sx**2 + (y - 0.5)**2 / sy**2)))\n\n        # Coarse grid run\n        x_c = np.linspace(0, 1, N_coarse)\n        y_c = np.linspace(0, 1, N_coarse)\n        xx_c, yy_c = np.meshgrid(x_c, y_c, indexing='ij')\n        s_coarse = 1.0 / speed_func(xx_c, yy_c)\n        \n        seeds_c = []\n        for i in range(N_coarse):\n            seeds_c.extend([(i, 0, 0.0), (i, N_coarse - 1, 0.0)])\n        for j in range(1, N_coarse - 1):\n            seeds_c.extend([(0, j, 0.0), (N_coarse - 1, j, 0.0)])\n        t_coarse = fmm_solver(s_coarse, h_coarse, seeds_c)\n        \n        # Fine grid run (reference)\n        x_f = np.linspace(0, 1, N_fine)\n        y_f = np.linspace(0, 1, N_fine)\n        xx_f, yy_f = np.meshgrid(x_f, y_f, indexing='ij')\n        s_fine = 1.0 / speed_func(xx_f, yy_f)\n        \n        seeds_f = []\n        for i in range(N_fine):\n            seeds_f.extend([(i, 0, 0.0), (i, N_fine - 1, 0.0)])\n        for j in range(1, N_fine - 1):\n            seeds_f.extend([(0, j, 0.0), (N_fine - 1, j, 0.0)])\n        t_fine = fmm_solver(s_fine, h_fine, seeds_f)\n        \n        # Downsample fine to coarse\n        scale = (N_fine - 1) // (N_coarse - 1)\n        t_ref = np.zeros_like(t_coarse)\n        for i in range(N_coarse):\n            for j in range(N_coarse):\n                t_ref[i, j] = t_fine[i * scale, j * scale]\n\n        # Caustic mask on coarse grid\n        s_max = np.max(s_coarse)\n        tau = 1.5 * h_coarse * s_max\n        caustic_mask = np.zeros((N_coarse, N_coarse), dtype=bool)\n        for i in range(1, N_coarse - 1):\n            for j in range(1, N_coarse - 1):\n                a = min(t_coarse[i - 1, j], t_coarse[i + 1, j])\n                b = min(t_coarse[i, j - 1], t_coarse[i, j + 1])\n                if abs(a - b) = tau:\n                    caustic_mask[i, j] = True\n        \n        error = np.abs(t_coarse - t_ref)\n        if np.any(caustic_mask):\n            max_error_in_mask = np.max(error[caustic_mask])\n        else:\n            max_error_in_mask = 0.0\n\n        return max_error_in_mask\n\n    result_a = run_case_a()\n    result_b = run_case_b()\n    result_c = run_case_c()\n    \n    results = [result_a, result_b, result_c]\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3578554"}]}