{"hands_on_practices": [{"introduction": "本练习将引导您一步步地将一个连续的诺伊曼（Neumann）边界条件转化为有限元模拟中的离散载荷向量。您将学习如何处理单元边界上的积分，并将给定的通量正确地分配到相应的节点上，其中还包括了处理非连续通量这一重要情形。[@problem_id:3578899]", "problem": "考虑单位正方形域 $[0,1] \\times [0,1]$ 上的二维标量扩散模型，由以下偏微分方程控制：\n$$\n- \\nabla \\cdot \\left( k \\nabla u \\right) = f \\quad \\text{in } \\Omega,\n$$\n该方程具有混合边界条件：在 $\\Gamma_D$ 上为狄利克雷（Dirichlet）边界条件 $u = u_D$，在 $\\Gamma_N$ 上为诺伊曼（Neumann）边界条件 $k \\nabla u \\cdot n = g$，其中 $\\Gamma_D \\cup \\Gamma_N = \\partial \\Omega$ 且 $\\Gamma_D \\cap \\Gamma_N = \\varnothing$。在弱形式中，经过分部积分并施加诺伊曼条件后，对于检验函数 $v$ 的右侧边界贡献项为\n$$\n\\int_{\\Gamma_N} g \\, v \\, ds.\n$$\n当在 $\\Omega$ 的三角剖分上使用分段线性拉格朗日（Lagrange）基函数 $\\{ \\phi_i \\}$ 进行有限元方法（FEM）计算时，离散的诺伊曼载荷向量分量为\n$$\nr_i = \\int_{\\Gamma_N} g \\, \\phi_i \\, ds.\n$$\n您的任务是从第一性原理出发，推导如何通过使用适当的边界求积法计算上述边界积分，从而得到离散诺伊曼载荷向量的分量 $r_i$，并实现一个程序来为结构化三角网格组装这些分量。您必须解决如何处理沿 $\\Gamma_N$ 不连续的分段常数通量 $g$ 的问题。\n\n假设以下场景：\n- 域是单位正方形 $\\Omega = [0,1] \\times [0,1]$。\n- 使用一个均匀的结构化三角网格，该网格通过将正方形细分为 $N_x \\times N_y$ 个矩形，并将每个矩形沿对角线分割成两个直角三角形而获得。令 $(x_i, y_j) = \\left( \\frac{i}{N_x}, \\frac{j}{N_y} \\right)$ 表示网格点，其中 $i = 0, 1, \\dots, N_x$ 且 $j = 0, 1, \\dots, N_y$。\n- 令诺伊曼边界为右边界 $\\Gamma_N = \\{ (x,y) \\in \\partial \\Omega \\mid x = 1, \\, y \\in [0,1] \\}$。\n- 通量沿 $\\Gamma_N$ 是分段常数：\n$$\ng(y) = \n\\begin{cases}\ng_{\\text{low}}, & y  y_\\star, \\\\\ng_{\\text{up}},  y \\ge y_\\star.\n\\end{cases}\n$$\n- 在每个边界边 $e = [(1, y_1), (1, y_2)]$（其中 $y_1  y_2$）上，将与该边端点相关的线性基函数限制在边上。来自该边的对 $r_i$ 和 $r_j$ 的贡献通过沿该边积分 $g(y) \\, \\phi_i(y)$ 和 $g(y) \\, \\phi_j(y)$ 来计算。在 $g$ 为常数的每个子段上使用单点高斯求积（中点法则）。如果 $y_\\star$ 严格位于边内部，则在 $y_\\star$ 处分割该边，并在每个子段上使用相应常数值的 $g$ 应用中点求积法则。\n\n在此设置中，将分段线性基函数限制在直的边界边上时，它们是边参数 $y$ 的线性函数（因为 $x$ 固定为 $x = 1$）。对于端点为 $y_1  y_2$ 的边，其长度为 $L = y_2 - y_1$，限制后的函数满足\n$$\n\\phi_i(y) = \\frac{y_2 - y}{L}, \n\\quad\n\\phi_j(y) = \\frac{y - y_1}{L},\n\\quad \\text{for } y \\in [y_1, y_2].\n$$\n对于子区间 $[a,b] \\subset [y_1,y_2]$ 上的分段常数 $g$，使用中点为 $y_m = \\frac{a+b}{2}$ 的中点法则，来自此子段对载荷分量的贡献为\n$$\n\\Delta r_i = g \\, \\phi_i(y_m) \\, (b - a),\n\\quad\n\\Delta r_j = g \\, \\phi_j(y_m) \\, (b - a),\n$$\n这个结果是精确的，因为被积函数是常数 $g$ 与线性函数 $\\phi$ 的乘积，而中点法则能够精确地对线性函数进行积分。\n\n您必须实现一个程序，对于每个给定的测试用例，构建遍历诺伊曼边界边所需的网格元数据，在必要时在 $y_\\star$ 处进行边分割并应用上述求积法则，组装全局诺伊曼载荷向量 $r$，并返回与 $\\Gamma_N$ 上的边界节点相关的 $r$ 的分量（按 $y$ 坐标升序排列）。\n\n在此计算中不需要物理单位；将所有量视为无量纲。\n\n测试套件：\n提供您的程序以处理以下三个测试用例，每个用例指定为元组 $(N_x, N_y, g_{\\text{low}}, g_{\\text{up}}, y_\\star)$:\n1. $(2, 4, 5.0, 11.0, 0.35)$: 一个中等规模的网格，其中 $y_\\star$ 严格位于一个边界边内部，测试边的分割和累加。\n2. $(3, 2, 7.0, 13.0, 0.5)$: 不连续点恰好位于一个边界节点上，测试端点对齐且不分割的情况。\n3. $(4, 4, 4.0, 4.0, 0.2)$: 均匀通量，无有效不连续点，测试常数 $g$ 的情况。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个项目对应一个测试用例，并且本身是边界节点诺伊曼载荷分量按 $y$ 升序排列的列表。例如，您的输出必须是以下形式：\n$$\n[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list}]\n$$\n其中每个 $\\text{caseX\\_list}$ 显示为Python风格的浮点数列表。", "solution": "该问题提法恰当，有科学依据，并提供了一套完整且一致的已知条件。它描述了有限元方法（FEM）中为具有分段常数通量的诺伊曼边界条件组装载荷向量的标准数值程序。关于数值求积的指令是精确的，并且适用于所要积分的函数。因此，该问题是有效的，我们着手求解。\n\n目标是计算标量扩散问题的诺伊曼边界载荷向量 $r$ 的分量。对于有限元网格中的每个节点 $i$，其对应的分量 $r_i$ 由给定通量 $g$ 乘以基函数 $\\phi_i$ 在边界的诺伊曼部分 $\\Gamma_N$ 上的积分给出：\n$$\nr_i = \\int_{\\Gamma_N} g \\, \\phi_i \\, ds.\n$$\n在此问题中，域是单位正方形 $\\Omega = [0,1] \\times [0,1]$，诺伊曼边界是其右边 $\\Gamma_N = \\{ (1, y) \\mid y \\in [0,1] \\}$。此边界上的网格由 $N_y$ 个直线段（边）组成，连接位于坐标 $(1, y_j)$ 处的 $N_y+1$ 个节点，其中 $y_j = j/N_y$，$j=0, 1, \\dots, N_y$。\n\n$r_i$ 的全局积分是由 $\\Gamma_N$ 上每条边的贡献组装而成。一个基函数 $\\phi_i$ 仅在连接到节点 $i$ 的边上非零。由于我们使用的是分段线性拉格朗日基函数，$\\phi_i$ 仅在节点 $i$ 本身及其紧邻的邻居上非零。对于边界 $\\Gamma_N$ 上的一个节点 $j$，其基函数 $\\phi_j$ 在与其相邻的两条边上非零（如果是域的端点，则为一条边）。因此，特定分量 $r_j$ 的积分可以写成在与节点 $j$ 相邻的边上的积分之和：\n$$\nr_j = \\sum_{e \\in \\text{edges adjacent to node } j} \\int_e g \\, \\phi_j \\, ds.\n$$\n让我们考虑 $\\Gamma_N$ 上的一条边 $e_k$，它连接位于 $(1, y_j)$ 的节点 $j$ 和位于 $(1, y_{j+1})$ 的节点 $j+1$。这条边的长度是 $L = y_{j+1} - y_j = 1/N_y$。与节点 $j$ 和 $j+1$ 相关联的基函数，当限制在这条边上时，是坐标 $y$ 的线性函数：\n$$\n\\phi_j(y) = \\frac{y_{j+1} - y}{L}, \\quad \\phi_{j+1}(y) = \\frac{y - y_j}{L}, \\quad \\text{for } y \\in [y_j, y_{j+1}].\n$$\n这条边对载荷向量分量 $r_j$ 和 $r_{j+1}$ 的贡献是：\n$$\n\\Delta r_j = \\int_{y_j}^{y_{j+1}} g(y) \\phi_j(y) dy, \\quad \\Delta r_{j+1} = \\int_{y_j}^{y_{j+1}} g(y) \\phi_{j+1}(y) dy.\n$$\n通量 $g(y)$ 是分段常数，在 $y=y_\\star$ 处有不连续点：\n$$\ng(y) = \n\\begin{cases}\ng_{\\text{low}},  y  y_\\star, \\\\\ng_{\\text{up}},  y \\ge y_\\star.\n\\end{cases}\n$$\n为了计算这些积分，我们必须考虑不连续点 $y_\\star$ 是否落在积分区间 $[y_j, y_{j+1}]$ 内。\n\n**情况1：边不分割 ($y_\\star \\le y_j$ 或 $y_\\star \\ge y_{j+1}$)**\n如果不连续点不严格位于边内部，那么 $g(y)$ 在区间 $(y_j, y_{j+1})$ 上是常数。这个常数值 $g_{\\text{edge}}$ 可通过在该区间内的任意一点（例如中点 $y_m = (y_j+y_{j+1})/2$）计算 $g(y)$ 来确定。问题指定使用单点高斯求积（中点法则）来计算积分。该法则将函数 $f(y)$ 在区间 $[a,b]$ 上的积分近似为 $f((a+b)/2) \\cdot (b-a)$。对于一个常数与线性函数乘积的被积函数，此法则是精确的。\n贡献为：\n$$\n\\Delta r_j = g_{\\text{edge}} \\, \\phi_j(y_m) \\, L = g_{\\text{edge}} \\cdot \\left(\\frac{y_{j+1} - y_m}{L}\\right) \\cdot L = g_{\\text{edge}} \\left(\\frac{L/2}{L}\\right) L = \\frac{g_{\\text{edge}} L}{2}.\n$$\n$$\n\\Delta r_{j+1} = g_{\\text{edge}} \\, \\phi_{j+1}(y_m) \\, L = g_{\\text{edge}} \\cdot \\left(\\frac{y_m - y_j}{L}\\right) \\cdot L = g_{\\text{edge}} \\left(\\frac{L/2}{L}\\right) L = \\frac{g_{\\text{edge}} L}{2}.\n$$\n这对应于将边上的总通量 $g_{\\text{edge}} L$ 平均分配给两个节点。\n\n**情况2：边分割 ($y_j  y_\\star  y_{j+1}$)**\n如果不连续点严格位于边内部，则积分被分为两部分：\n$$\n\\int_{y_j}^{y_{j+1}} (\\cdot) dy = \\int_{y_j}^{y_\\star} (\\cdot) dy + \\int_{y_\\star}^{y_{j+1}} (\\cdot) dy.\n$$\n我们对每个子积分应用中点法则。\n\n在子段 $[y_j, y_\\star]$ 上：\n通量为 $g=g_{\\text{low}}$。段长为 $L_1 = y_\\star - y_j$。中点为 $y_{m1} = (y_j + y_\\star)/2$。贡献为：\n$$\n\\Delta r_{j,1} = g_{\\text{low}} \\cdot \\phi_j(y_{m1}) \\cdot L_1, \\quad \\Delta r_{j+1,1} = g_{\\text{low}} \\cdot \\phi_{j+1}(y_{m1}) \\cdot L_1.\n$$\n\n在子段 $[y_\\star, y_{j+1}]$ 上：\n通量为 $g=g_{\\text{up}}$。段长为 $L_2 = y_{j+1} - y_\\star$。中点为 $y_{m2} = (y_\\star + y_{j+1})/2$。贡献为：\n$$\n\\Delta r_{j,2} = g_{\\text{up}} \\cdot \\phi_j(y_{m2}) \\cdot L_2, \\quad \\Delta r_{j+1,2} = g_{\\text{up}} \\cdot \\phi_{j+1}(y_{m2}) \\cdot L_2.\n$$\n\n从此分割边对载荷向量分量的总贡献是各子段贡献之和：\n$$\n\\Delta r_j = \\Delta r_{j,1} + \\Delta r_{j,2}, \\quad \\Delta r_{j+1} = \\Delta r_{j+1,1} + \\Delta r_{j+1,2}.\n$$\n$\\Gamma_N$ 上的 $N_y+1$ 个节点的全局载荷向量通过将其初始化为零，然后遍历 $N_y$ 条边中的每一条，计算边的贡献（$\\Delta r_j$, $\\Delta r_{j+1}$），并将其加到全局向量的相应分量中来组装。一个内部节点 $j$ 会从两条边 $[y_{j-1}, y_j]$ 和 $[y_j, y_{j+1}]$ 获得贡献，而端点节点 $j=0$ 和 $j=N_y$ 则各自只从一条边获得贡献。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_neumann_load_vector(Ny, g_low, g_up, y_star):\n    \"\"\"\n    Assembles the Neumann load vector for the right boundary of the unit square.\n\n    Args:\n        Ny (int): The number of subdivisions in the y-direction.\n        g_low (float): The flux value for y  y_star.\n        g_up (float): The flux value for y >= y_star.\n        y_star (float): The y-coordinate of the flux discontinuity.\n\n    Returns:\n        list: A list of the load vector entries for the nodes on the Neumann boundary,\n              ordered by increasing y-coordinate.\n    \"\"\"\n    # Generate the y-coordinates of the nodes on the Neumann boundary.\n    # There are Ny+1 nodes, from y=0 to y=1.\n    y_nodes = np.linspace(0.0, 1.0, Ny + 1)\n    \n    # Initialize the load vector for the Ny+1 boundary nodes.\n    r_boundary = np.zeros(Ny + 1)\n    \n    # The length of each edge on the uniform mesh.\n    L_total = 1.0 / Ny\n\n    # Iterate over each of the Ny edges on the Neumann boundary.\n    # The j-th edge connects node j and node j+1.\n    for j in range(Ny):\n        y1 = y_nodes[j]\n        y2 = y_nodes[j+1]\n\n        # Define the restricted linear basis functions for the current edge [y1, y2].\n        # phi_node_j is the basis function for the node at y1.\n        # phi_node_j1 is the basis function for the node at y2.\n        phi_node_j = lambda y: (y2 - y) / L_total\n        phi_node_j1 = lambda y: (y - y1) / L_total\n\n        #\n        # Validate if the discontinuity y_star lies strictly inside the current edge.\n        #\n        if y1  y_star  y2:\n            # Case 1: Split the edge into two subsegments for integration.\n            \n            # Subsegment 1: [y1, y_star] where g(y) = g_low\n            g1 = g_low\n            L_seg1 = y_star - y1\n            y_m1 = (y1 + y_star) / 2.0\n            \n            # Use midpoint rule: g * phi(midpoint) * length\n            dr_j_seg1 = g1 * phi_node_j(y_m1) * L_seg1\n            dr_j1_seg1 = g1 * phi_node_j1(y_m1) * L_seg1\n            \n            # Subsegment 2: [y_star, y2] where g(y) = g_up\n            g2 = g_up\n            L_seg2 = y2 - y_star\n            y_m2 = (y_star + y2) / 2.0\n            \n            # Use midpoint rule: g * phi(midpoint) * length\n            dr_j_seg2 = g2 * phi_node_j(y_m2) * L_seg2\n            dr_j1_seg2 = g2 * phi_node_j1(y_m2) * L_seg2\n            \n            # Accumulate the total contributions from this split edge.\n            r_boundary[j] += dr_j_seg1 + dr_j_seg2\n            r_boundary[j+1] += dr_j1_seg1 + dr_j1_seg2\n\n        else:\n            # Case 2: No split. The flux g(y) is constant across the edge.\n            # Determine the constant value of g by checking the midpoint.\n            y_mid = (y1 + y2) / 2.0\n            if y_mid  y_star:\n                g_edge = g_low\n            else:\n                g_edge = g_up\n            \n            # The midpoint rule on the full edge is exact and simplifies to\n            # distributing half of the total edge flux to each node.\n            # Basis function values at the midpoint are both 0.5.\n            # dr = g_edge * 0.5 * L_total\n            dr = g_edge * L_total / 2.0\n            \n            # Accumulate contributions.\n            r_boundary[j] += dr\n            r_boundary[j+1] += dr\n\n    return list(r_boundary)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, g_low, g_up, y_star)\n        (2, 4, 5.0, 11.0, 0.35),\n        (3, 2, 7.0, 13.0, 0.5),\n        (4, 4, 4.0, 4.0, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        # The parameter Nx is specified but not needed for this boundary calculation.\n        Nx_val, Ny_val, g_low_val, g_up_val, y_star_val = case\n        \n        # Calculate the load vector for the current test case.\n        result_vector = assemble_neumann_load_vector(Ny_val, g_low_val, g_up_val, y_star_val)\n        \n        # Append the string representation of the list to the results.\n        results.append(str(result_vector))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3578899"}, {"introduction": "真实世界的几何形状很少与坐标轴对齐。本练习将介绍强大的等参元（isoparametric）概念，它允许我们通过从一个简单的参考单元进行映射，来处理复杂的曲线单元形状。您将推导边界积分的变量变换关系并计算必要的几何因子，这是任何通用有限元程序的核心技术。[@problem_id:3578897]", "problem": "考虑一个二维标量扩散问题的有限元法（FEM）分析，其中自然（Neumann型）边界条件通过形如 $\\int_{\\Gamma_{e}} g \\, \\phi \\, ds$ 的边界积分进入弱形式，其中 $g$ 是给定的边界通量，$\\phi$ 是检验函数或形函数。在一个四边形单元上使用等参格式，该单元具有从参考正方形 $[-1,1] \\times [-1,1]$ 到物理单元的映射 $\\boldsymbol{x}(\\xi,\\eta)$，其中 $\\xi$ 和 $\\eta$ 是参考坐标。该映射的雅可比矩阵为 $\\boldsymbol{J}(\\xi,\\eta) = \\begin{bmatrix} \\partial x / \\partial \\xi  \\partial x / \\partial \\eta \\\\ \\partial y / \\partial \\xi  \\partial y / \\partial \\eta \\end{bmatrix}$，逆变基向量为 $\\boldsymbol{a}_{\\xi} = \\partial \\boldsymbol{x}/\\partial \\xi$ 和 $\\boldsymbol{a}_{\\eta} = \\partial \\boldsymbol{x}/\\partial \\eta$。\n\n任务：\n1) 从曲线积分的变量替换定理和等参映射的定义出发，推导一个表达式，将单个单元边界 $\\Gamma_{e}$ 上的积分 $\\int_{\\Gamma_{e}} g \\, \\phi \\, ds$ 映射到相应参考边界 $\\widehat{\\Gamma}$ 上的积分，并根据情况用 $\\boldsymbol{a}_{\\xi}$ 或 $\\boldsymbol{a}_{\\eta}$ 明确表示出一维尺度因子。\n\n2) 对于通过固定 $\\xi = \\xi^{\\star}$ 或 $\\eta = \\eta^{\\star}$ 参数化的一般直边或曲边，解释如何用 $\\boldsymbol{a}_{\\xi}$ 和 $\\boldsymbol{a}_{\\eta}$ 计算物理边界上的单位外法向量 $\\boldsymbol{n}$。你的回答应仅使用从等参映射导出的量，并应阐明方向的选择。\n\n3) 现在特化到一个双线性四边形单元，其节点的物理坐标为 $(x_{1},y_{1}) = (0,0)$、$(x_{2},y_{2}) = (2,0)$、$(x_{3},y_{3}) = (2,1)$ 和 $(x_{4},y_{4}) = (0,1)$，并使用在 $[-1,1] \\times [-1,1]$ 上的标准双线性形函数。考虑顶边，它对应于 $\\eta = 1$，其外法线方向为 $+y$ 方向。设边界通量为无量纲函数 $g(x,y) = x$，并取 $\\phi$ 为与节点3相关的形函数。使用你推导出的映射，精确计算边界积分\n$$\nI \\equiv \\int_{\\Gamma_{e}} g \\, \\phi \\, ds\n$$\n。假设所有量都已无量纲化；将结果报告为一个纯数。提供精确值（不要四舍五入）。", "solution": "该问题陈述是关于将等参有限元法应用于边界积分的一个良态练习。它在科学上基于向量微积分和数值分析的原理，其各组成部分是自洽且逻辑一致的。没有发现任何缺陷。我们开始求解。\n\n问题分为三个部分。我们将依次解决每个部分。\n\n### 第1部分：边界积分的映射\n\n我们从物理单元边界 $\\Gamma_e$ 上的边界积分开始：\n$$\n\\int_{\\Gamma_{e}} g \\, \\phi \\, ds\n$$\n其中 $g$ 是一个给定的函数，$\\phi$ 是一个检验函数或形函数，$ds$ 是物理域 $\\boldsymbol{x} = (x, y)$ 中的微分弧长。\n\n等参格式的核心是从一个参考单元（通常是坐标为 $(\\xi, \\eta)$ 的正方形 $\\widehat{\\Omega} = [-1,1] \\times [-1,1]$）到物理单元的映射。该映射由下式给出：\n$$\n\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\n其中 $N_i$ 是在参考单元上定义的形函数，$\\boldsymbol{x}_i$ 是单元节点的物理坐标。\n\n物理单元的一条边界 $\\Gamma_e$ 对应于参考正方形的一条边界 $\\widehat{\\Gamma}$，在参考边界上，其中一个参考坐标保持不变。我们考虑一条 $\\eta = \\eta^{\\star} = \\text{常数}$ 的边界（例如 $\\eta^{\\star} = \\pm 1$）。沿着这条边界，物理坐标仅依赖于 $\\xi$：$\\boldsymbol{x} = \\boldsymbol{x}(\\xi, \\eta^{\\star})$。变量 $\\xi$ 充当沿曲线 $\\Gamma_e$ 的参数，通常从 -1 变化到 1。\n\n微分弧长 $ds$ 通过曲线积分的变量替换定理与参数 $\\xi$ 的微分变化相关联：\n$$\nds = \\left\\| \\frac{d\\boldsymbol{x}}{d\\xi} \\right\\| d\\xi\n$$\n向量 $\\frac{d\\boldsymbol{x}}{d\\xi}$ 是曲线 $\\Gamma_e$ 的切向量。由于 $\\eta$ 是常数，该导数恰好是关于 $\\xi$ 的偏导数，它被定义为逆变基向量 $\\boldsymbol{a}_{\\xi}$：\n$$\n\\frac{d\\boldsymbol{x}}{d\\xi} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}(\\xi, \\eta^{\\star}) = \\boldsymbol{a}_{\\xi}(\\xi, \\eta^{\\star})\n$$\n因此，微分弧长为：\n$$\nds = \\| \\boldsymbol{a}_{\\xi} \\| d\\xi\n$$\n项 $\\| \\boldsymbol{a}_{\\xi} \\|$ 是这条边界上的一维尺度因子，或称变换的雅可比。\n\n通过将此代入原始积分并将函数 $g$ 和 $\\phi$ 变换到参考坐标系，我们得到映射后的积分。沿标准参考边界对 $\\xi$ 的积分限为 -1 到 1。\n$$\n\\int_{\\Gamma_{e}} g(\\boldsymbol{x}) \\, \\phi(\\boldsymbol{x}) \\, ds = \\int_{-1}^{1} g(\\boldsymbol{x}(\\xi, \\eta^{\\star})) \\, \\phi(\\boldsymbol{x}(\\xi, \\eta^{\\star})) \\, \\| \\boldsymbol{a}_{\\xi}(\\xi, \\eta^{\\star}) \\| \\, d\\xi\n$$\n类似地，对于一条 $\\xi = \\xi^{\\star} = \\text{常数}$ 的边界，参数是 $\\eta$，切向量是 $\\boldsymbol{a}_{\\eta} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}$，微分弧长是 $ds = \\| \\boldsymbol{a}_{\\eta} \\| d\\eta$。积分变为：\n$$\n\\int_{\\Gamma_{e}} g(\\boldsymbol{x}) \\, \\phi(\\boldsymbol{x}) \\, ds = \\int_{-1}^{1} g(\\boldsymbol{x}(\\xi^{\\star}, \\eta)) \\, \\phi(\\boldsymbol{x}(\\xi^{\\star}, \\eta)) \\, \\| \\boldsymbol{a}_{\\eta}(\\xi^{\\star}, \\eta) \\| \\, d\\eta\n$$\n总之，通过引入一个一维尺度因子，该积分被映射到参考边界 $\\widehat{\\Gamma}$（例如，区间 $[-1,1]$）上。该因子是与边界相切的逆变基向量的模，对于常数 $\\eta$ 的边界，它是 $\\| \\boldsymbol{a}_{\\xi} \\|$；对于常数 $\\xi$ 的边界，它是 $\\| \\boldsymbol{a}_{\\eta} \\|$。\n\n### 第2部分：外法向量的计算\n\n让我们确定物理单元边界的单位外法向量 $\\boldsymbol{n}$。这需要为“向外”方向建立一个约定。标准约定假设映射具有正的雅可比行列式 $\\det(\\boldsymbol{J})  0$，这会保持定向。这意味着参考正方形边界的逆时针遍历会映射到物理单元边界的逆时针遍历。\n\n考虑一条由常数 $\\eta = \\eta^{\\star}$ 参数化的边界。如前所述，切向量为 $\\boldsymbol{t} = \\boldsymbol{a}_{\\xi} = (\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi})$。在二维笛卡尔坐标系中，可以通过将 $\\boldsymbol{t}$ 旋转 $\\pm 90^{\\circ}$ 来找到一个法向量。其中一个法向量是 $\\boldsymbol{v} = (-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi})$。注意 $\\|\\boldsymbol{v}\\| = \\|\\boldsymbol{a}_{\\xi}\\|$。\n\n为了确定 $\\boldsymbol{v}$ 是指向内部还是外部，我们将其方向与另一个坐标 $\\eta$ 的方向进行比较。向量 $\\boldsymbol{a}_{\\eta} = (\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta})$ 指向 $\\eta$ 增大的方向。我们计算点积：\n$$\n\\boldsymbol{v} \\cdot \\boldsymbol{a}_{\\eta} = \\left(-\\frac{\\partial y}{\\partial \\xi}\\right)\\left(\\frac{\\partial x}{\\partial \\eta}\\right) + \\left(\\frac{\\partial x}{\\partial \\xi}\\right)\\left(\\frac{\\partial y}{\\partial \\eta}\\right) = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi} = \\det(\\boldsymbol{J})\n$$\n因为我们假设 $\\det(\\boldsymbol{J})  0$，所以向量 $\\boldsymbol{v}$ 在 $\\boldsymbol{a}_{\\eta}$ 上的投影为正，这意味着它指向 $\\eta$ 增大的大致方向。\n- 对于“顶”边（$\\eta^{\\star} = 1$），向外的方向是 $\\eta$ 增大的方向。因此，$\\boldsymbol{v}$ 是一个外法向量。单位外法向量是 $\\boldsymbol{n} = \\boldsymbol{v} / \\|\\boldsymbol{v}\\| = \\frac{1}{\\|\\boldsymbol{a}_{\\xi}\\|} (-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi})$。\n- 对于“底”边（$\\eta^{\\star} = -1$），向外的方向是 $\\eta$ 减小的方向。因此，$\\boldsymbol{v}$ 是一个内法向量。单位外法向量是 $\\boldsymbol{n} = -\\boldsymbol{v} / \\|\\boldsymbol{v}\\| = -\\frac{1}{\\|\\boldsymbol{a}_{\\xi}\\|} (-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi})$。\n\n类似的分析适用于常数 $\\xi = \\xi^{\\star}$ 的边界。切向量是 $\\boldsymbol{t}' = \\boldsymbol{a}_{\\eta}$，一个法向量是 $\\boldsymbol{v}' = (-\\frac{\\partial y}{\\partial \\eta}, \\frac{\\partial x}{\\partial \\eta})$。与 $\\boldsymbol{a}_{\\xi}$ 的点积为 $\\boldsymbol{v}' \\cdot \\boldsymbol{a}_{\\xi} = -\\det(\\boldsymbol{J})$。因为这个值为负，所以 $\\boldsymbol{v}'$ 指向 $\\xi$ 增大方向的相反方向。\n- 对于“右”边（$\\xi^{\\star} = 1$），$\\boldsymbol{v}'$ 指向内部。单位外法向量是 $\\boldsymbol{n} = -\\boldsymbol{v}' / \\|\\boldsymbol{v}'\\| = \\frac{1}{\\|\\boldsymbol{a}_{\\eta}\\|} (\\frac{\\partial y}{\\partial \\eta}, -\\frac{\\partial x}{\\partial \\eta})$。\n- 对于“左”边（$\\xi^{\\star} = -1$），$\\boldsymbol{v}'$ 指向外部。单位外法向量是 $\\boldsymbol{n} = \\boldsymbol{v}' / \\|\\boldsymbol{v}'\\| = \\frac{1}{\\|\\boldsymbol{a}_{\\eta}\\|} (-\\frac{\\partial y}{\\partial \\eta}, \\frac{\\partial x}{\\partial \\eta})$。\n\n### 第3部分：特定积分的计算\n\n给定一个双线性四边形，其节点为 $\\boldsymbol{x}_1=(0,0)$、$\\boldsymbol{x}_2=(2,0)$、$\\boldsymbol{x}_3=(2,1)$ 和 $\\boldsymbol{x}_4=(0,1)$。标准的双线性形函数 $N_i(\\xi, \\eta)$ 将参考正方形的节点 $(-1,-1), (1,-1), (1,1), (-1,1)$ 分别映射到物理节点 $1,2,3,4$。等参映射 $\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\boldsymbol{x}_i$ 为：\n$$\nx(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)x_2 + \\frac{1}{4}(1+\\xi)(1+\\eta)x_3 = \\frac{1}{4}(1+\\xi)(1-\\eta)(2) + \\frac{1}{4}(1+\\xi)(1+\\eta)(2) = \\frac{1}{2}(1+\\xi)[(1-\\eta)+(1+\\eta)] = 1+\\xi\n$$\n$$\ny(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)y_3 + \\frac{1}{4}(1-\\xi)(1+\\eta)y_4 = \\frac{1}{4}(1+\\xi)(1+\\eta)(1) + \\frac{1}{4}(1-\\xi)(1+\\eta)(1) = \\frac{1}{4}(1+\\eta)[(1+\\xi)+(1-\\xi)] = \\frac{1}{2}(1+\\eta)\n$$\n这个线性映射将参考正方形 $[-1,1]\\times[-1,1]$ 变换为物理矩形 $[0,2]\\times[0,1]$。\n\n积分 $I = \\int_{\\Gamma_{e}} g \\, \\phi \\, ds$ 需要在顶边上进行计算，该边对应于 $\\eta=1$。在这条边上，参数是 $\\xi$，其范围从 -1（节点4）到 1（节点3）。我们使用第1部分中的公式。\n\n首先，我们确定参考坐标系中的被积函数 $g \\phi$。\n- 边界通量为 $g(x,y) = x$。在边 $\\eta=1$ 上，$x=1+\\xi$。因此，$g = 1+\\xi$。\n- 形函数 $\\phi$ 是节点3的形函数，所以 $\\phi = N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$。在边 $\\eta=1$ 上，这变为 $\\phi = \\frac{1}{4}(1+\\xi)(1+1) = \\frac{1}{2}(1+\\xi)$。\n\n接下来，我们计算一维尺度因子 $\\| \\boldsymbol{a}_{\\xi} \\|$。\n$$\n\\boldsymbol{a}_{\\xi} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\left(\\frac{\\partial}{\\partial \\xi}(1+\\xi), \\frac{\\partial}{\\partial \\xi}\\left(\\frac{1}{2}(1+\\eta)\\right)\\right) = (1, 0)\n$$\n其模为常数：\n$$\n\\| \\boldsymbol{a}_{\\xi} \\| = \\sqrt{1^2 + 0^2} = 1\n$$\n这是符合预期的，因为在水平线上的 $ds$ 就是 $dx$，并且从映射关系可知 $dx=d\\xi$。\n\n现在，我们组合并计算在参考边界上的积分，其中 $\\xi$ 从 -1 变化到 1：\n$$\nI = \\int_{-1}^{1} g(\\xi, 1) \\, \\phi(\\xi, 1) \\, \\| \\boldsymbol{a}_{\\xi}(\\xi, 1) \\| \\, d\\xi\n$$\n$$\nI = \\int_{-1}^{1} (1+\\xi) \\left( \\frac{1}{2}(1+\\xi) \\right) (1) \\, d\\xi = \\frac{1}{2} \\int_{-1}^{1} (1+\\xi)^2 \\, d\\xi\n$$\n$$\nI = \\frac{1}{2} \\int_{-1}^{1} (1 + 2\\xi + \\xi^2) \\, d\\xi\n$$\n我们逐项积分：\n$$\nI = \\frac{1}{2} \\left[ \\xi + \\xi^2 + \\frac{\\xi^3}{3} \\right]_{-1}^{1}\n$$\n$$\nI = \\frac{1}{2} \\left( \\left( 1 + (1)^2 + \\frac{(1)^3}{3} \\right) - \\left( -1 + (-1)^2 + \\frac{(-1)^3}{3} \\right) \\right)\n$$\n$$\nI = \\frac{1}{2} \\left( \\left( 1 + 1 + \\frac{1}{3} \\right) - \\left( -1 + 1 - \\frac{1}{3} \\right) \\right)\n$$\n$$\nI = \\frac{1}{2} \\left( \\left( 2 + \\frac{1}{3} \\right) - \\left( -\\frac{1}{3} \\right) \\right) = \\frac{1}{2} \\left( \\frac{7}{3} + \\frac{1}{3} \\right) = \\frac{1}{2} \\left( \\frac{8}{3} \\right)\n$$\n$$\nI = \\frac{4}{3}\n$$\n边界积分的值恰好是 $\\frac{4}{3}$。", "answer": "$$\\boxed{\\frac{4}{3}}$$", "id": "3578897"}, {"introduction": "当一个物理系统“漂浮”在空间中，没有足够的约束来产生唯一解时，我们该如何处理？这个高级练习通过引入拉格朗日乘子（Lagrange multipliers）来施加积分约束，从而解决线性弹性问题中的刚体模态问题。您将通过约束物体的平均位移和旋转来实现一个确保解唯一性的方法，这是在地球物理学和工程学中为无约束系统建模的一项关键技能。[@problem_id:3578906]", "problem": "考虑一个定义在单连通域 $\\Omega \\subset \\mathbb{R}^2$ 上的二维、小应变、各向同性、线弹性边值问题，其单位外法线为 $\\mathbf{n}$，边界 $\\partial \\Omega$ 为无牵引力边界。在没有本质（狄利克雷）条件的情况下，静力平衡的弱形式要求对于任意运动学容许的虚位移 $\\mathbf{v}$，双线性形式和线性形式满足\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, d\\Omega \\;=\\; \\int_{\\Omega} \\mathbf{f} \\cdot \\mathbf{v} \\, d\\Omega \\;+\\; \\int_{\\partial \\Omega} \\mathbf{t} \\cdot \\mathbf{v} \\, ds,\n$$\n其中 $\\mathbf{u}$ 是位移，$\\boldsymbol{\\varepsilon}(\\mathbf{u})$ 是 $\\mathbf{u}$ 的对称梯度，$\\mathbb{C}$ 是四阶弹性张量，$\\mathbf{f}$ 是体力密度，$\\mathbf{t}$ 是边界牵引力。对于无牵引力边界（即在 $\\partial \\Omega$ 上 $\\mathbf{t} = \\mathbf{0}$），由于刚体模态的存在，连续问题允许多个非唯一解。在计算地球物理学中，当无牵引力边界普遍存在时，可以通过施加边界积分约束来移除刚体模态，从而利用拉格朗日乘子恢复解的唯一性。具体来说，考虑边界积分约束，强制边界上的平均位移为零，并可选地强制绕选定点 $(x_c, y_c)$ 的平均刚体转动为零：\n$$\n\\int_{\\partial \\Omega} u_x \\, ds \\;=\\; 0, \\quad \\int_{\\partial \\Omega} u_y \\, ds \\;=\\; 0, \\quad \\int_{\\partial \\Omega} \\big((x - x_c) u_y - (y - y_c) u_x\\big) \\, ds \\;=\\; 0.\n$$\n使用一阶（线性）三角形有限元在结构化网格上离散化域 $\\Omega = [0,1] \\times [0,1]$，该网格在 $x$ 方向有 $N_x$ 个单元，在 $y$ 方向有 $N_y$ 个单元，节点位于 $(N_x+1)\\times(N_y+1)$ 个点的均匀格点上。对于平面应变情况下的本构模型，\n$$\n\\mathbb{C} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix},\n$$\n其中 $\\mu = \\frac{E}{2(1+\\nu)}$ 和 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$，$E$ 是杨氏模量，$\\nu$ 是泊松比。通过标准有限元方法，使用分段线性形函数和在每个单元形心处的单点求积来计算体力，从而组装全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$。在域内模拟一个均匀体力 $\\mathbf{f} = (0, -b)$。\n\n通过构造一个矩形约束矩阵 $\\mathbf{B}$ 来使用拉格朗日乘子施加边界积分约束，该矩阵的行对应于线性泛函\n$$\nc_x(\\mathbf{u}) = \\int_{\\partial \\Omega} u_x \\, ds, \\quad c_y(\\mathbf{u}) = \\int_{\\partial \\Omega} u_y \\, ds, \\quad c_r(\\mathbf{u}) = \\int_{\\partial \\Omega} \\big((x - x_c) u_y - (y - y_c) u_x\\big) \\, ds.\n$$\n通过对与坐标为 $(x_i,y_i)$ 的边界节点 $i$ 相关联的每个节点自由度进行近似，来将这些边界积分与有限元空间一致地离散化，其贡献为\n$$\n\\int_{\\partial \\Omega} N_i \\, ds \\approx w_i, \\quad \\int_{\\partial \\Omega} (x - x_c) N_i \\, ds \\approx w_i (x_i - x_c), \\quad \\int_{\\partial \\Omega} (y - y_c) N_i \\, ds \\approx w_i (y_i - y_c),\n$$\n其中 $N_i$ 是节点形函数，$w_i$ 是集总边界权重，通过对与节点 $i$ 相关联的每个长度为 $L_e$ 的边界边求和贡献 $L_e/2$ 来获得。设拉格朗日乘子集合在 $\\boldsymbol{\\lambda}$ 中。得到的离散鞍点系统是\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{B}^{\\top} \\\\\n\\mathbf{B}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\ \\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\ \\mathbf{0}\n\\end{bmatrix}.\n$$\n\n您的任务是实现一个完整的程序，该程序：\n- 使用上述关于平面应变和线性三角形单元的定义，生成网格并组装 $\\mathbf{K}$ 和 $\\mathbf{f}$。\n- 为以下两种配置构建边界积分约束矩阵 $\\mathbf{B}$：\n  - 仅平移约束：施加 $c_x(\\mathbf{u})=0$ 和 $c_y(\\mathbf{u})=0$（两个约束）。\n  - 平移和旋转约束：施加 $c_x(\\mathbf{u})=0$、$c_y(\\mathbf{u})=0$ 和 $c_r(\\mathbf{u})=0$，其中 $(x_c,y_c)=(\\frac{1}{2},\\frac{1}{2})$（三个约束）。\n- 对于仅平移约束，不要尝试求解鞍点系统。而是评估对称鞍点矩阵的最小绝对值特征值，以诊断未解决的刚体旋转模态。\n- 对于平移和旋转约束，求解鞍点系统以获得位移向量 $\\mathbf{u}$。\n\n所有量都是无量纲的；报告纯数字，不带物理单位。\n\n测试套件：\n在 $\\Omega=[0,1]\\times[0,1]$ 上使用以下四个测试用例，参数为 $N_x = 2$，$N_y = 2$，$b = 1$ 和 $(x_c,y_c)=(\\frac{1}{2},\\frac{1}{2})$。\n- 测试用例1：$E=1.0$，$\\nu=0.25$，仅平移约束。输出鞍点矩阵的最小绝对值特征值，格式为浮点数。\n- 测试用例2：$E=1.0$，$\\nu=0.25$，平移和旋转约束。输出欧几里得范数 $\\|\\mathbf{u}\\|_2$，格式为浮点数。\n- 测试用例3：$E=2.0$，$\\nu=0.25$，平移和旋转约束。输出欧几里得范数 $\\|\\mathbf{u}\\|_2$，格式为浮点数。\n- 测试用例4：$E=1.0$，$\\nu=0.49$，平移和旋转约束。输出欧几里得范数 $\\|\\mathbf{u}\\|_2$，格式为浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，格式为逗号分隔的列表，并用方括号括起来，例如 $[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3,\\text{结果}_4]$。每个条目必须是浮点数。不应打印任何其他文本。", "solution": "此问题已根据既定标准进行验证。\n\n### 步骤1：提取已知条件\n- **控制方程**：二维、小应变、各向同性、线弹性。\n- **域**：$\\Omega = [0,1] \\times [0,1]$。\n- **边界条件**：在 $\\partial \\Omega$ 上无牵引力，即 $\\mathbf{t} = \\mathbf{0}$。\n- **弱形式**：$\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, d\\Omega = \\int_{\\Omega} \\mathbf{f} \\cdot \\mathbf{v} \\, d\\Omega$。\n- **体力**：均匀体力，$\\mathbf{f} = (0, -b)$。\n- **离散化**：\n    - 一阶（线性）三角形有限元。\n    - 具有 $N_x$ 和 $N_y$ 个单元的结构化网格。\n    - $(N_x+1)\\times(N_y+1)$ 个节点。\n- **本构模型（平面应变）**：$\\mathbf{C} = \\begin{bmatrix} \\lambda + 2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda + 2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix}$，拉梅参数为 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\frac{E}{2(1+\\nu)}$。\n- **数值积分**：体力项在单元形心处采用单点求积。\n- **约束**：\n    - 平移：$\\int_{\\partial \\Omega} u_x \\, ds = 0$ 和 $\\int_{\\partial \\Omega} u_y \\, ds = 0$。\n    - 旋转：$\\int_{\\partial \\Omega} \\big((x - x_c) u_y - (y - y_c) u_x\\big) \\, ds = 0$。\n- **离散约束**：\n    - 边界积分使用集总边界权重 $w_i$ 进行近似，其中 $w_i$ 是与节点 $i$ 相关联的边界边长度一半之和。\n- **方程组**：一个鞍点系统 $\\begin{bmatrix} \\mathbf{K}  \\mathbf{B}^{\\top} \\\\ \\mathbf{B}  \\mathbf{0} \\end{bmatrix} \\begin{bmatrix} \\mathbf{u} \\\\ \\boldsymbol{\\lambda} \\end{bmatrix} = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix}$。\n- **测试套件参数**：$N_x = 2$，$N_y = 2$，$b = 1$，$(x_c,y_c)=(\\frac{1}{2},\\frac{1}{2})$。\n    - 用例1：$E=1.0$，$\\nu=0.25$，仅平移约束。任务：找到鞍点矩阵的最小绝对值特征值。\n    - 用例2：$E=1.0$，$\\nu=0.25$，平移和旋转约束。任务：找到 $\\|\\mathbf{u}\\|_2$。\n    - 用例3：$E=2.0$，$\\nu=0.25$，平移和旋转约束。任务：找到 $\\|\\mathbf{u}\\|_2$。\n    - 用例4：$E=1.0$，$\\nu=0.49$，平移和旋转约束。任务：找到 $\\|\\mathbf{u}\\|_2$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于线弹性标准理论及其通过有限元法（FEM）的数值解。使用拉格朗日乘子对浮动体施加积分约束是计算力学中一种成熟且正确的技术。所有提供的方程和定义都是标准的。该问题在科学上是合理的。\n- **适定性**：具有纯诺伊曼（牵引力）条件的初始边值问题被正确地识别为因刚体模态而病态。问题的核心是通过添加约束来强制适定性。对于仅平移约束，问题正确地预见了一个未解决的旋转模态，并要求通过特征值分析进行诊断，这是一项有意义的任务。对于平移和旋转约束，问题变得适定，允许唯一解。参数，包括 $\\nu=0.49$，都在有效的物理和数值范围内。\n- **客观性**：问题使用精确、明确的数学和工程术语陈述。任务是定量的，没有主观性。\n- **结论**：该问题不违反任何无效标准。这是一个完整、一致且在科学上合理的计算力学问题。\n\n### 步骤3：裁定与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n解决此问题需要二维线弹性有限元法的标准实现。过程如下：\n\n**1. 网格生成**\n将域 $\\Omega = [0,1] \\times [0,1]$ 离散化为 $N_x \\times N_y$ 个单元的结构化网格。当 $N_x=2$ 且 $N_y=2$ 时，我们有 $4$ 个正方形单元。每个正方形单元被细分为两个一阶三角形单元，总共产生 $N_{el} = 2 N_x N_y = 8$ 个单元。节点数为 $N_{nodes} = (N_x+1)(N_y+1) = 9$。生成从 $0$ 到 $8$ 索引的节点 $k$ 的坐标。每个节点有两个自由度（DOF），$u_x$ 和 $u_y$，从而系统中总共有 $N_{dof} = 2 N_{nodes} = 18$ 个自由度。\n\n**2. 有限元组装：刚度矩阵和力向量**\n通过遍历所有单元来组装全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$。对于每个面积为 $A_e$ 的三角形单元 $e$：\n\n- **单元刚度矩阵 $\\mathbf{k}_e$**：单元刚度矩阵由积分 $\\mathbf{k}_e = \\int_{A_e} \\mathbf{B}_e^\\top \\mathbf{C} \\mathbf{B}_e \\, dA$ 给出。对于线性三角形单元，应变-位移矩阵 $\\mathbf{B}_e$ 在整个单元上是常数。因此，积分简化为 $\\mathbf{k}_e = A_e \\mathbf{B}_e^\\top \\mathbf{C} \\mathbf{B}_e$。\n    - 平面应变的材料本构矩阵 $\\mathbf{C}$ 使用杨氏模量 $E$ 和泊松比 $\\nu$ 定义：\n    $$ \\mathbf{C} = \\begin{bmatrix} \\lambda + 2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda + 2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix}, \\quad \\mu = \\frac{E}{2(1+\\nu)}, \\quad \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)} $$\n    - 应变-位移矩阵 $\\mathbf{B}_e$ 将单元的 $6$ 个节点位移映射到应变的 $3$ 个分量 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^\\top$。它由线性形函数 $N_i$ 的空间导数导出：\n    $$ \\mathbf{B}_e = \\begin{bmatrix} \\frac{\\partial N_1}{\\partial x}  0  \\frac{\\partial N_2}{\\partial x}  0  \\frac{\\partial N_3}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_1}{\\partial y}  0  \\frac{\\partial N_2}{\\partial y}  0  \\frac{\\partial N_3}{\\partial y} \\\\ \\frac{\\partial N_1}{\\partial y}  \\frac{\\partial N_1}{\\partial x}  \\frac{\\partial N_2}{\\partial y}  \\frac{\\partial N_2}{\\partial x}  \\frac{\\partial N_3}{\\partial y}  \\frac{\\partial N_3}{\\partial x} \\end{bmatrix} $$\n\n- **单元力向量 $\\mathbf{f}_e$**：由体力 $\\mathbf{f}_b = (0, -b)^\\top$ 产生的单元力向量为 $\\mathbf{f}_e = \\int_{A_e} \\mathbf{N}_e^\\top \\mathbf{f}_b \\, dA$，其中 $\\mathbf{N}_e$ 是形函数矩阵。在单元形心处使用单点求积，其中 $N_1=N_2=N_3=1/3$，这简化为 $\\mathbf{f}_e = A_e \\mathbf{N}_e(\\text{centroid})^\\top \\mathbf{f}_b$。这将总单元力 $(0, -b A_e)$ 平均分配给三个节点。\n\n然后根据每个单元的自由度（DOF）连通性，将单元矩阵 $\\mathbf{k}_e$ 和向量 $\\mathbf{f}_e$ 组装到全局系统 $\\mathbf{K}$ 和 $\\mathbf{f}$ 中。\n\n**3. 约束矩阵构建**\n约束矩阵 $\\mathbf{B}$ 实现边界积分约束。\n首先，我们识别边界节点并计算它们的集总权重 $w_i$。对于边界上的节点 $i$，$w_i = \\sum_{e \\in E_i} L_e/2$，其中 $E_i$ 是与节点 $i$ 相关联的边界边集合，$L_e$ 是边 $e$ 的长度。对于指定的 $2 \\times 2$ 网格，边长为 $0.5$，每个边界节点都有一个关联的权重 $w_i = 0.5$。\n\n$\\mathbf{B}$ 的行对应于离散化的约束：\n- **$x$方向平移**：约束 $\\sum_{i \\in \\partial\\Omega} w_i u_{ix} = 0$ 对应于 $\\mathbf{B}$ 中的一行，其中每个边界节点 $i$ 的 $x$-自由度条目为 $w_i$。\n- **$y$方向平移**：约束 $\\sum_{i \\in \\partial\\Omega} w_i u_{iy} = 0$ 对应于一行，其中每个边界节点 $i$ 的 $y$-自由度条目为 $w_i$。\n- **旋转**：约束 $\\sum_{i \\in \\partial\\Omega} (w_i (x_i-x_c) u_{iy} - w_i (y_i-y_c) u_{ix}) = 0$ 对应于一行，其中对于每个边界节点 $i$，$x$-自由度的条目为 $-w_i(y_i-y_c)$，$y$-自由度的条目为 $w_i(x_i-x_c)$。\n\n**4. 求解鞍点系统**\n完整系统被构建为一个对称鞍点矩阵 $\\mathbf{M}$ 和一个相应的右侧向量 $\\mathbf{RHS}$：\n$$ \\mathbf{M} = \\begin{bmatrix} \\mathbf{K}  \\mathbf{B}^{\\top} \\\\ \\mathbf{B}  \\mathbf{0} \\end{bmatrix}, \\quad \\mathbf{RHS} = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix} $$\n- **测试用例1（仅平移约束）**：矩阵 $\\mathbf{B}$ 是 $2 \\times 18$ 的。由于未约束的刚体旋转，得到的矩阵 $\\mathbf{M}$ 是奇异的。通过计算对称矩阵 $\\mathbf{M}$ 的特征值并找到绝对值最小的一个来诊断奇异性，该特征值预计在数值上接近于零。\n- **测试用例2、3、4（平移和旋转约束）**：矩阵 $\\mathbf{B}$ 是 $3 \\times 18$ 的。在所有三个刚体模态都被约束的情况下，$\\mathbf{M}$ 是非奇异的。求解线性系统 $\\mathbf{M} \\mathbf{x} = \\mathbf{RHS}$ 以获得解向量 $\\mathbf{x} = [\\mathbf{u}^\\top, \\boldsymbol{\\lambda}^\\top]^\\top$。从 $\\mathbf{x}$ 的前 $N_{dof}$ 个分量中提取位移向量 $\\mathbf{u}$，并计算其欧几里得范数 $\\|\\mathbf{u}\\|_2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the elasticity problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {'E': 1.0, 'nu': 0.25, 'constraints': 'translation'},\n        {'E': 1.0, 'nu': 0.25, 'constraints': 'translation_rotation'},\n        {'E': 2.0, 'nu': 0.25, 'constraints': 'translation_rotation'},\n        {'E': 1.0, 'nu': 0.49, 'constraints': 'translation_rotation'}\n    ]\n\n    results = []\n    for params in test_cases:\n        E = params['E']\n        nu = params['nu']\n        constraint_type = params['constraints']\n\n        # Shared parameters\n        Nx, Ny = 2, 2\n        b = 1.0\n        xc, yc = 0.5, 0.5\n        \n        # 1. Generate Mesh\n        nodes, elements = generate_mesh(Nx, Ny)\n        n_nodes = len(nodes)\n        n_dofs = 2 * n_nodes\n\n        # 2. Assemble Stiffness Matrix and Force Vector\n        K, f = assemble_stiffness_and_force(nodes, elements, E, nu, b)\n\n        # 3. Assemble Constraint Matrix\n        B = assemble_constraint_matrix(nodes, Nx, Ny, constraint_type, xc, yc)\n        n_constraints = B.shape[0]\n\n        # 4. Form and solve the saddle-point system\n        M = np.zeros((n_dofs + n_constraints, n_dofs + n_constraints))\n        M[0:n_dofs, 0:n_dofs] = K\n        M[0:n_dofs, n_dofs:] = B.T\n        M[n_dofs:, 0:n_dofs] = B\n        \n        if constraint_type == 'translation':\n            # For translation-only, find the smallest absolute eigenvalue\n            eigenvalues = np.linalg.eigvalsh(M)\n            result = np.min(np.abs(eigenvalues))\n        else:\n            # For full constraints, solve the system\n            RHS = np.zeros(n_dofs + n_constraints)\n            RHS[0:n_dofs] = f\n            \n            # Solve for displacements and Lagrange multipliers\n            solution = np.linalg.solve(M, RHS)\n            u = solution[0:n_dofs]\n            result = np.linalg.norm(u)\n        \n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_mesh(Nx, Ny):\n    \"\"\"Generates node coordinates and element connectivity for a structured triangular mesh.\"\"\"\n    n_nodes = (Nx + 1) * (Ny + 1)\n    nodes = np.zeros((n_nodes, 2))\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            node_idx = i + j * (Nx + 1)\n            nodes[node_idx] = [i / Nx, j / Ny]\n    \n    n_elements = 2 * Nx * Ny\n    elements = np.zeros((n_elements, 3), dtype=int)\n    el_idx = 0\n    for j in range(Ny):\n        for i in range(Nx):\n            # Node indices of the square cell\n            n1 = i + j * (Nx + 1)\n            n2 = (i + 1) + j * (Nx + 1)\n            n3 = i + (j + 1) * (Nx + 1)\n            n4 = (i + 1) + (j + 1) * (Nx + 1)\n            \n            # Create two triangles from the cell\n            elements[el_idx] = [n1, n2, n3]\n            elements[el_idx + 1] = [n4, n3, n2]\n            el_idx += 2\n    return nodes, elements\n\ndef assemble_stiffness_and_force(nodes, elements, E, nu, b):\n    \"\"\"Assembles the global stiffness matrix K and force vector f.\"\"\"\n    n_nodes = len(nodes)\n    n_dofs = 2 * n_nodes\n    K = np.zeros((n_dofs, n_dofs))\n    f = np.zeros(n_dofs)\n\n    # Material properties (plane strain)\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    C = np.array([[lmbda + 2 * mu, lmbda, 0],\n                  [lmbda, lmbda + 2 * mu, 0],\n                  [0, 0, mu]])\n\n    for el_nodes in elements:\n        # Element node coordinates\n        coords = nodes[el_nodes]\n        x1, y1 = coords[0]\n        x2, y2 = coords[1]\n        x3, y3 = coords[2]\n\n        # Element area\n        area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n\n        # Strain-displacement matrix B\n        # B = [B1, B2, B3] where Bi is 3x2\n        # dN/dx, dN/dy for linear triangle\n        # dNi/dx = (1/2A) * (y_j - y_k)\n        # dNi/dy = (1/2A) * (x_k - x_j)\n        y23, y31, y12 = y2 - y3, y3 - y1, y1 - y2\n        x32, x13, x21 = x3 - x2, x1 - x3, x2 - x1\n        \n        B_mat = (1 / (2 * area)) * np.array([\n            [y23, 0,   y31, 0,   y12, 0  ],\n            [0,   x32, 0,   x13, 0,   x21],\n            [x32, y23, x13, y31, x21, y12]\n        ])\n\n        # Element stiffness matrix\n        ke = area * B_mat.T @ C @ B_mat\n        \n        # Element force vector (body force)\n        fe = np.array([0, -b * area / 3, 0, -b * area / 3, 0, -b * area / 3])\n\n        # Assemble into global matrices\n        dof_indices = []\n        for node_idx in el_nodes:\n            dof_indices.extend([2 * node_idx, 2 * node_idx + 1])\n        \n        for i in range(6):\n            f[dof_indices[i]] += fe[i]\n            for j in range(6):\n                K[dof_indices[i], dof_indices[j]] += ke[i, j]\n                \n    return K, f\n\ndef assemble_constraint_matrix(nodes, Nx, Ny, constraint_type, xc, yc):\n    \"\"\"Assembles the Lagrange multiplier constraint matrix B.\"\"\"\n    n_nodes = len(nodes)\n    n_dofs = 2 * n_nodes\n    \n    # Identify boundary nodes and calculate weights\n    boundary_nodes = set()\n    weights = np.zeros(n_nodes)\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n\n    # Bottom and Top edges\n    for i in range(Nx):\n        n1 = i; boundary_nodes.add(n1)\n        n2 = i+1; boundary_nodes.add(n2)\n        weights[n1] += hx / 2\n        weights[n2] += hx / 2\n        \n        n1 = i + Ny*(Nx+1); boundary_nodes.add(n1)\n        n2 = i+1 + Ny*(Nx+1); boundary_nodes.add(n2)\n        weights[n1] += hx / 2\n        weights[n2] += hx / 2\n\n    # Left and Right edges\n    for j in range(Ny):\n        n1 = j*(Nx+1); boundary_nodes.add(n1)\n        n2 = (j+1)*(Nx+1); boundary_nodes.add(n2)\n        weights[n1] += hy / 2\n        weights[n2] += hy / 2\n\n        n1 = (Nx) + j*(Nx+1); boundary_nodes.add(n1)\n        n2 = (Nx) + (j+1)*(Nx+1); boundary_nodes.add(n2)\n        weights[n1] += hy / 2\n        weights[n2] += hy / 2\n        \n    sorted_boundary_nodes = sorted(list(boundary_nodes))\n\n    if constraint_type == 'translation':\n        n_constraints = 2\n        B = np.zeros((n_constraints, n_dofs))\n        for i in sorted_boundary_nodes:\n            w_i = weights[i]\n            # Constraint for sum(u_x) = 0\n            B[0, 2 * i] = w_i\n            # Constraint for sum(u_y) = 0\n            B[1, 2 * i + 1] = w_i\n    else: # translation_rotation\n        n_constraints = 3\n        B = np.zeros((n_constraints, n_dofs))\n        for i in sorted_boundary_nodes:\n            w_i = weights[i]\n            x_i, y_i = nodes[i]\n            # Constraint for sum(u_x) = 0\n            B[0, 2 * i] = w_i\n            # Constraint for sum(u_y) = 0\n            B[1, 2 * i + 1] = w_i\n            # Constraint for sum((x-xc)uy - (y-yc)ux) = 0\n            B[2, 2 * i] = -w_i * (y_i - yc) # u_x component\n            B[2, 2 * i + 1] = w_i * (x_i - xc) # u_y component\n    \n    return B\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3578906"}]}