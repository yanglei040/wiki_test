{"hands_on_practices": [{"introduction": "本节的实践练习将理论付诸实践。我们从一个基础但至关重要的问题开始：在一个经典的二次逆问题中施加一个线性等式约束。这类问题在地球科学的数据同化等领域非常普遍，例如，当总质量或总能量等某个物理量需要被精确守恒时。通过运用拉格朗日乘子法推导卡罗需-库恩-塔克（KKT）最优性条件，您将练习构建拉格朗日函数并求解得到的线性系统，从而获得对解和拉格朗日乘子本身的解析洞察。[@problem_id:3395254]", "problem": "考虑一个在数据同化框架中提出的线性反问题，其中状态向量 $m \\in \\mathbb{R}^{n}$ 通过线性正演算子 $F \\in \\mathbb{R}^{p \\times n}$ 从观测值 $d \\in \\mathbb{R}^{p}$ 中估计得出。假设存在一个正定的数据精度矩阵 $W \\in \\mathbb{R}^{p \\times p}$ 和一个正定的背景协方差矩阵 $B \\in \\mathbb{R}^{n \\times n}$，其背景态为 $m_{b} \\in \\mathbb{R}^{n}$。在高斯假设下，$m$ 的最大后验 (MAP) 估计量通过最小化二次目标函数得到\n$$\nJ(m) = \\frac{1}{2} (F m - d)^{T} W (F m - d) + \\frac{1}{2} (m - m_{b})^{T} B^{-1} (m - m_{b}),\n$$\n该最小化问题受线性不变约束 $s^{T} m = c$ 的限制，其中 $s \\in \\mathbb{R}^{n}$ 是一个给定的非零向量，$c \\in \\mathbb{R}$ 是一个指定的标量。\n\n从约束优化的核心定义和等式约束问题的 Karush–Kuhn–Tucker (KKT) 条件出发，推导出刻画该约束化 MAP 解的一阶最优性系统。然后，解析地求出与约束 $s^{T} m = c$ 相关的拉格朗日乘子的闭式解，该解应以 $F$、$W$、$B$、$d$、$m_{b}$、$s$ 和 $c$ 表示。明确说明保证该乘子唯一性所需的任何假设。你的最终答案必须是该乘子的单个闭式解析表达式。无需进行四舍五入，也不涉及任何物理单位。", "solution": "所述问题是在变分数据同化背景下出现的经典约束二次优化问题。我们将首先验证该问题陈述的有效性。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 待估计的状态向量：$m \\in \\mathbb{R}^{n}$。\n- 观测向量：$d \\in \\mathbb{R}^{p}$。\n- 线性正演算子：$F \\in \\mathbb{R}^{p \\times n}$。\n- 数据精度矩阵：$W \\in \\mathbb{R}^{p \\times p}$，正定。\n- 背景协方差矩阵：$B \\in \\mathbb{R}^{n \\times n}$，正定。\n- 背景态向量：$m_{b} \\in \\mathbb{R}^{n}$。\n- 目标函数：$J(m) = \\frac{1}{2} (F m - d)^{T} W (F m - d) + \\frac{1}{2} (m - m_{b})^{T} B^{-1} (m - m_{b})$。\n- 线性约束：$s^{T} m = c$，其中 $s \\in \\mathbb{R}^{n}$ 为给定非零向量，$c \\in \\mathbb{R}$ 为指定标量。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据充分：** 该问题代表了在高斯假设下贝叶斯推断中求解最大后验 (MAP) 估计的标准形式，在地球科学中通常称为 3D-Var 或 4D-Var。目标函数 $J(m)$ 与后验概率密度的负对数成正比。这是反问题和数据同化领域一个基础且成熟的方法。\n- **适定的：** 目标函数 $J(m)$ 是 $m$ 的二次函数。其 Hessian 矩阵为 $\\nabla_m^2 J(m) = F^T W F + B^{-1}$。由于 $B$ 是正定的，其逆矩阵 $B^{-1}$ 也是正定的。矩阵 $W$ 是正定的，这意味着对于任何向量 $v \\in \\mathbb{R}^n$，二次型 $v^T (F^T W F) v = (Fv)^T W (Fv) \\ge 0$，因此 $F^T W F$ 是半正定的。一个正定矩阵 ($B^{-1}$) 和一个半正定矩阵 ($F^T W F$) 的和是一个正定矩阵。因此，$J(m)$ 的 Hessian 矩阵是正定的，这使得 $J(m)$ 成为一个严格凸函数。约束 $s^T m = c$ 定义了一个凸集（一个仿射超平面）。在一个凸集上最小化一个严格凸函数存在唯一解。因此，该问题是适定的。\n- **客观的：** 该问题使用来自线性代数和优化理论的精确、无歧义的数学语言和标准记法来表述。\n- **完备性和一致性：** 所有必要的组成部分（变量、矩阵、它们的性质、目标函数和约束）都得到了明确的定义。该设定中不存在矛盾。\n\n**第3步：结论与行动**\n该问题是有效的，因为它科学依据充分、适定、客观且自洽。我们可以继续进行求解。\n\n### 解的推导\n\n问题在于找到向量 $m$，使其在满足等式约束 $g(m) = s^T m - c = 0$ 的条件下最小化目标函数 $J(m)$。这个约束优化问题可以使用拉格朗日乘子法来解决。\n\n我们定义拉格朗日函数 $\\mathcal{L}(m, \\lambda)$，它将约束条件包含在内，其中 $\\lambda \\in \\mathbb{R}$ 是拉格朗日乘子：\n$$\n\\mathcal{L}(m, \\lambda) = J(m) + \\lambda (s^T m - c)\n$$\n代入 $J(m)$ 的表达式：\n$$\n\\mathcal{L}(m, \\lambda) = \\frac{1}{2} (F m - d)^{T} W (F m - d) + \\frac{1}{2} (m - m_{b})^{T} B^{-1} (m - m_{b}) + \\lambda (s^{T} m - c)\n$$\n一阶最优性必要条件（对于等式约束的 Karush-Kuhn-Tucker 条件）指出，在最优点 $(m^*, \\lambda^*)$ 处，拉格朗日函数关于 $m$ 和 $\\lambda$ 的梯度必须为零。\n\n第一个条件是关于 $m$ 的平稳性条件：$\\nabla_m \\mathcal{L}(m, \\lambda) = 0$。我们逐项计算梯度：\n$$\n\\nabla_m \\left( \\frac{1}{2} (F m - d)^{T} W (F m - d) \\right) = F^T W (Fm - d)\n$$\n$$\n\\nabla_m \\left( \\frac{1}{2} (m - m_{b})^{T} B^{-1} (m - m_{b}) \\right) = B^{-1} (m - m_b)\n$$\n$$\n\\nabla_m \\left( \\lambda (s^T m - c) \\right) = \\lambda s\n$$\n将这些项组合起来，平稳性条件为：\n$$\n\\nabla_m \\mathcal{L}(m, \\lambda) = F^T W (Fm - d) + B^{-1} (m - m_b) + \\lambda s = 0\n$$\n第二个条件 $\\nabla_\\lambda \\mathcal{L}(m, \\lambda) = 0$ 仅是恢复了原始约束：\n$$\ns^T m - c = 0\n$$\n这对方程构成了约束化 MAP 解 $(m, \\lambda)$ 的一阶最优性系统：\n1. $(F^T W F + B^{-1}) m + \\lambda s = F^T W d + B^{-1} m_b$\n2. $s^T m = c$\n\n为了求解拉格朗日乘子 $\\lambda$，我们首先从第一个方程中解出 $m$。我们定义 Hessian 矩阵 $H = F^T W F + B^{-1}$ 和向量 $g = F^T W d + B^{-1} m_b$。该系统变为：\n1. $H m + \\lambda s = g$\n2. $s^T m = c$\n\n正如在验证部分所确立的，矩阵 $H$ 是正定的，因此是可逆的。从方程 (1) 中，我们可以将 $m$ 表示为 $\\lambda$ 的函数：\n$$\nH m = g - \\lambda s\n$$\n$$\nm = H^{-1} (g - \\lambda s)\n$$\n现在，将这个 $m$ 的表达式代入约束方程 (2)：\n$$\ns^T \\left( H^{-1} (g - \\lambda s) \\right) = c\n$$\n展开转置：\n$$\ns^T H^{-1} g - \\lambda s^T H^{-1} s = c\n$$\n现在我们可以分离并求解 $\\lambda$。重新整理各项：\n$$\n\\lambda (s^T H^{-1} s) = s^T H^{-1} g - c\n$$\n$\\lambda$ 的唯一解存在的充要条件是标量系数 $s^T H^{-1} s \\neq 0$。由于 $H$ 是正定的，其逆矩阵 $H^{-1}$ 也是正定的。问题陈述 $s$ 是一个非零向量。对于任何正定矩阵 $A$ 和任何非零向量 $x$，二次型 $x^T A x$ 都是严格为正的。因此，$s^T H^{-1} s > 0$，这保证了乘子 $\\lambda$ 的唯一性。\n$$\n\\lambda = \\frac{s^T H^{-1} g - c}{s^T H^{-1} s}\n$$\n最后，我们将 $H$ 和 $g$ 的定义代回此表达式，以获得用原始问题数据表示的拉格朗日乘子的闭式解：\n$$\n\\lambda = \\frac{s^{T} (F^{T} W F + B^{-1})^{-1} (F^{T} W d + B^{-1} m_{b}) - c}{s^{T} (F^{T} W F + B^{-1})^{-1} s}\n$$\n这就是与该约束相关的拉格朗日乘子的解析表达式。", "answer": "$$\n\\boxed{\\frac{s^{T} (F^{T} W F + B^{-1})^{-1} (F^{T} W d + B^{-1} m_{b}) - c}{s^{T} (F^{T} W F + B^{-1})^{-1} s}}\n$$", "id": "3395254"}, {"introduction": "在第一个练习的基础上，我们现在来处理一个更普遍且更具挑战性的场景，该场景同时包含等式和不等式约束。现实世界中的问题常常涉及物理边界或参数范围的限制，这些最好用不等式来表达。本练习将引导您应用完整的KKT条件，特别是包括“互补松弛性”条件，它是不等式约束优化的核心。通过实现一个算法来探索不同的“有效集”，您将获得处理不等式约束所带来的组合复杂性的第一手经验，并将理论知识转化为数值求解器的构建逻辑。[@problem_id:3395272]", "problem": "考虑带线性等式和不等式约束的二次逆问题。设 $m \\in \\mathbb{R}^n$ 表示模型参数，设 $A \\in \\mathbb{R}^{p \\times n}$ 和 $d \\in \\mathbb{R}^p$ 定义了最小二乘数据失配 $J(m) = \\tfrac{1}{2}\\lVert A m - d \\rVert_2^2$。设 $B \\in \\mathbb{R}^{r \\times n}$ 和 $b \\in \\mathbb{R}^r$ 定义了线性不等式约束 $B m - b \\le 0$（分量形式），设 $C \\in \\mathbb{R}^{q \\times n}$ 和 $c \\in \\mathbb{R}^q$ 定义了线性等式约束 $C m - c = 0$。使用拉格朗日乘子法和 Karush-Kuhn-Tucker (KKT) 条件，该凸问题的最优解 $m^\\star \\in \\mathbb{R}^n$ 满足一个耦合方程组，该方程组涉及原始变量 $m$、不等式乘子 $\\lambda \\in \\mathbb{R}^r$ 和等式乘子 $\\nu \\in \\mathbb{R}^q$。\n\n任务1（推导）：从拉格朗日函数 $\\mathcal{L}(m,\\lambda,\\nu) = \\tfrac{1}{2}\\lVert A m - d \\rVert_2^2 + \\lambda^\\top (B m - b) + \\nu^\\top (C m - c)$ 的定义出发，推导该凸问题的一阶必要且充分最优性条件，即 Karush-Kuhn-Tucker (KKT) 条件，包括：\n- 关于 $m$ 的平稳性，\n- 不等式和等式的原始可行性，\n- 关于 $\\lambda$ 的对偶可行性，\n- 将 $\\lambda$ 与不等式残差耦合的互补松弛性。\n\n然后，通过对称半正定矩阵 $H = A^\\top A$ 和向量 $g = A^\\top d$ 来表示二次项的梯度，将这些条件明确地写成块矩阵形式的线性系统。您的块系统必须明确以 $H$、$B$、$C$、$g$、$b$ 和 $c$ 表示，并且必须能适应任意的活动不等式约束集 $\\mathcal{I}$（即那些使得 $(B m^\\star - b)_i = 0$ 的索引 $i$）。\n\n任务2（算法与实现）：实现一个算法，在给定数值实例 $(A,B,C,d,b,c)$ 的情况下，确定满足 KKT 条件的最优解 $m^\\star$、活动集 $\\mathcal{A} = \\{ i \\in \\{0,\\dots,r-1\\} : \\lvert (B m^\\star - b)_i \\rvert \\le \\tau \\}$ 以及相应的拉格朗日乘子 $(\\lambda^\\star,\\nu^\\star)$。您的程序必须：\n- 仅使用线性代数和基本定义；不调用预封装的二次规划求解器。\n- 枚举候选活动集 $\\mathcal{I} \\subseteq \\{0,\\dots,r-1\\}$，并对每个候选集求解相关的 KKT 线性系统，该系统强制执行 $B_{\\mathcal{I}} m = b_{\\mathcal{I}}$ 和 $C m = c$ 以及平稳性条件，以获得 $(m,\\lambda_{\\mathcal{I}},\\nu)$。\n- 如果候选解是原始可行的（即 $B m - b \\le \\tau \\mathbf{1}$ 且 $\\lVert C m - c \\rVert_2 \\le \\tau$），满足强制乘子的对偶可行性（即 $\\lambda_{\\mathcal{I}} \\ge -\\tau \\mathbf{1}$ 分量形式），并且在所有可接受的候选解中最小化目标函数 $J(m)$，则接受该候选解。\n- 为可行性和活动性测试定义数值容差为 $\\tau = 10^{-8}$。\n\n任务3（测试套件与输出）：您的程序必须解决以下三个测试用例。对于每个用例，它必须返回：\n- 最优模型 $m^\\star$，作为浮点数列表，\n- 活动集 $\\mathcal{A}$，作为从零开始的整数索引列表，\n- 完整的不等式乘子向量 $\\lambda^\\star \\in \\mathbb{R}^r$（非活动约束对应的值为零），\n- 等式乘子向量 $\\nu^\\star \\in \\mathbb{R}^q$，\n- 最优目标值 $J(m^\\star)$，\n所有浮点数四舍五入到六位小数。\n\n使用以下实例：\n\n- 测试用例1：\n  - $n = 2$, $p = 2$, $r = 2$, $q = 1$。\n  - $A = \\begin{bmatrix} 1  0 \\\\ 0  2 \\end{bmatrix}$， $d = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$。\n  - $B = \\begin{bmatrix} -1  0 \\\\ 0  1 \\end{bmatrix}$， $b = \\begin{bmatrix} 0 \\\\ 0.5 \\end{bmatrix}$。\n  - $C = \\begin{bmatrix} 1  1 \\end{bmatrix}$， $c = \\begin{bmatrix} 1 \\end{bmatrix}$。\n\n- 测试用例2：\n  - $n = 2$, $p = 2$, $r = 4$, $q = 0$。\n  - $A = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$， $d = \\begin{bmatrix} 2 \\\\ -1 \\end{bmatrix}$。\n  - $B = \\begin{bmatrix} -1  0 \\\\ 0  -1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}$， $b = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n  - $C$ 没有行，$c$ 没有条目。\n\n- 测试用例3：\n  - $n = 3$, $p = 3$, $r = 3$, $q = 1$。\n  - $A = \\begin{bmatrix} 1  0  0 \\\\ 0  2  0 \\\\ 0  0  3 \\end{bmatrix}$， $d = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n  - $B = \\begin{bmatrix} -1  0  0 \\\\ 0  -1  0 \\\\ 0  0  -1 \\end{bmatrix}$，$b = \\begin{bmatrix} 0 \\\\ 0 \\\\ -0.4 \\end{bmatrix}$，这编码了 $m_1 \\ge 0$，$m_2 \\ge 0$ 和 $m_3 \\ge 0.4$。\n  - $C = \\begin{bmatrix} 1  1  1 \\end{bmatrix}$， $c = \\begin{bmatrix} 1 \\end{bmatrix}$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个形式为 $[m^\\star, \\mathcal{A}, \\lambda^\\star, \\nu^\\star, J(m^\\star)]$ 的列表。\n- 所有浮点数在打印输出时必须四舍五入到六位小数。\n- 示例结构格式（仅作说明）：$[[[m\\_1,m\\_2], [i\\_1,i\\_2], [\\lambda\\_1,\\dots], [\\nu\\_1,\\dots], J], \\dots]$。", "solution": "用户提供了一个定义明确的约束二次优化问题，并要求基于 Karush-Kuhn-Tucker (KKT) 条件，通过活动集枚举算法实现求解。\n\n### 问题陈述验证\n\n根据所需标准对问题进行严格验证。\n\n**步骤1：提取的已知条件**\n- **目标函数**：最小化 $J(m) = \\tfrac{1}{2}\\lVert A m - d \\rVert_2^2$，其中 $m \\in \\mathbb{R}^n$，$A \\in \\mathbb{R}^{p \\times n}$，$d \\in \\mathbb{R}^p$。\n- **不等式约束**：$B m - b \\le 0$，其中 $B \\in \\mathbb{R}^{r \\times n}$，$b \\in \\mathbb{R}^r$。\n- **等式约束**：$C m - c = 0$，其中 $C \\in \\mathbb{R}^{q \\times n}$，$c \\in \\mathbb{R}^q$。\n- **拉格朗日函数**：$\\mathcal{L}(m,\\lambda,\\nu) = \\tfrac{1}{2}\\lVert A m - d \\rVert_2^2 + \\lambda^\\top (B m - b) + \\nu^\\top (C m - c)$，其中乘子为 $\\lambda \\in \\mathbb{R}^r$ 和 $\\nu \\in \\mathbb{R}^q$。\n- **任务1**：推导 KKT 条件，并将其表示为给定活动集 $\\mathcal{I}$ 的块矩阵线性系统。\n- **任务2**：实现一个活动集枚举算法，通过为每个候选活动集求解 KKT 系统来找到最优解 $(m^\\star, \\lambda^\\star, \\nu^\\star)$，并选择最佳可行解。数值容差定义为 $\\tau = 10^{-8}$。\n- **任务3**：解决三个特定的数值实例，并按指定格式提供结果。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是一个标准的二次规划（QP）问题，是凸优化和逆问题中的一个基本课题。使用拉格朗日乘子和 KKT 条件是解决此类问题的标准理论方法。该问题在科学和数学上是合理的。\n- **适定性**：该问题是适定的。目标函数是凸的，约束是线性的，定义了一个凸可行集。因此，只要真实活动集的 KKT 系统是非奇异的，就存在唯一的全局最小值。\n- **客观性**：问题使用精确、客观的数学语言陈述。\n- **完整性与一致性**：问题是自洽的。所有必需的矩阵、向量、函数和任务都已明确定义。所提供的测试用例在维度上是一致的。所规定的算法，虽然对于大的 $r$ 来说计算量很大，但对于解决该问题是一种有效的方法，并且对于给定的测试用例是可行的。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将提供一个完整的、有理有据的解决方案。\n\n### 任务1：KKT 条件的推导\n\n优化问题是最小化一个受线性约束的凸二次函数：\n$$\n\\min_{m \\in \\mathbb{R}^n} \\quad J(m) = \\frac{1}{2} \\lVert A m - d \\rVert_2^2 \\\\\n\\text{subject to} \\quad B m - b \\le 0 \\\\\n\\text{and} \\quad C m - c = 0\n$$\n该问题的拉格朗日函数为：\n$$\n\\mathcal{L}(m, \\lambda, \\nu) = J(m) + \\lambda^\\top (B m - b) + \\nu^\\top (C m - c)\n$$\n其中 $\\lambda \\in \\mathbb{R}^r$ 是不等式约束的拉格朗日乘子，$\\nu \\in \\mathbb{R}^q$ 是等式约束的乘子。\n\n对于一个凸问题，Karush-Kuhn-Tucker (KKT) 条件是其最优性的必要且充分条件。一个点 $m^\\star$ 是最优解，当且仅当存在乘子 $\\lambda^\\star$ 和 $\\nu^\\star$ 使得以下五个条件成立：\n\n1.  **平稳性**：拉格朗日函数关于原始变量 $m$ 的梯度在最优点处必须为零：$\\nabla_m \\mathcal{L}(m^\\star, \\lambda^\\star, \\nu^\\star) = 0$。\n    目标函数的梯度为 $\\nabla_m J(m) = A^\\top(A m - d) = (A^\\top A)m - A^\\top d$。设 $H = A^\\top A$（一个对称半正定矩阵）和 $g = A^\\top d$。则 $\\nabla_m J(m) = H m - g$。\n    约束项的梯度为 $\\nabla_m(\\lambda^\\top B m) = B^\\top \\lambda$ 和 $\\nabla_m(\\nu^\\top C m) = C^\\top \\nu$。\n    因此，平稳性条件为：\n    $$H m^\\star + B^\\top \\lambda^\\star + C^\\top \\nu^\\star - g = 0$$\n\n2.  **原始可行性（不等式）**：最优解必须满足不等式约束。\n    $$B m^\\star - b \\le 0$$\n\n3.  **原始可行性（等式）**：最优解必须满足等式约束。\n    $$C m^\\star - c = 0$$\n\n4.  **对偶可行性**：对应于不等式约束的乘子必须是非负的。\n    $$\\lambda^\\star \\ge 0 \\quad (\\text{分量形式})$$\n\n5.  **互补松弛性**：对于每个不等式约束，要么该约束以等式形式成立（即“活动的”），要么其对应的乘子为零。对于每个分量 $i \\in \\{0, \\dots, r-1\\}$，这表示为：\n    $$\\lambda_i^\\star (B m^\\star - b)_i = 0$$\n\n为了为一个候选活动集 $\\mathcal{I} \\subseteq \\{0, ..., r-1\\}$ 构建线性系统，我们强制将相应的不等式约束作为等式处理。对于任何 $i \\in \\mathcal{I}$，我们设 $(B m - b)_i = 0$。对于任何 $i \\notin \\mathcal{I}$，互补松弛性条件意味着 $\\lambda_i=0$。\n\n设 $k = |\\mathcal{I}|$ 为活动不等式约束的数量。设 $B_{\\mathcal{I}} \\in \\mathbb{R}^{k \\times n}$ 和 $b_{\\mathcal{I}} \\in \\mathbb{R}^k$ 分别是 $B$ 和 $b$ 中对应于 $\\mathcal{I}$ 中索引的行和条目。类似地，设 $\\lambda_{\\mathcal{I}} \\in \\mathbb{R}^k$ 为活动乘子向量。由于所有其他的 $\\lambda_i$ 都为零，平稳性条件简化为 $H m + B_{\\mathcal{I}}^\\top \\lambda_{\\mathcal{I}} + C^\\top \\nu = g$。\n\n将修改后的平稳性方程与活动不等式约束和等式约束相结合，我们得到一个关于未知数 $(m, \\lambda_{\\mathcal{I}}, \\nu)$ 的耦合线性系统：\n$$\n\\begin{cases}\nH m + B_{\\mathcal{I}}^\\top \\lambda_{\\mathcal{I}} + C^\\top \\nu = g \\\\\nB_{\\mathcal{I}} m = b_{\\mathcal{I}} \\\\\nC m = c\n\\end{cases}\n$$\n这可以写成块矩阵形式：\n$$\n\\begin{bmatrix}\nH  B_{\\mathcal{I}}^\\top  C^\\top \\\\\nB_{\\mathcal{I}}  0  0 \\\\\nC  0  0\n\\end{bmatrix}\n\\begin{bmatrix}\nm \\\\\n\\lambda_{\\mathcal{I}} \\\\\n\\nu\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ng \\\\\nb_{\\mathcal{I}} \\\\\nc\n\\end{bmatrix}\n$$\n其中的零块是适当维度的矩阵。这是一个对称不定的鞍点系统。\n\n### 任务2：算法设计\n\n所实现的算法遵循用户的规范。它对所有 $2^r$ 个可能的活动集 $\\mathcal{I} \\subseteq \\{0, \\dots, r-1\\}$ 进行穷举搜索。对于每个候选集 $\\mathcal{I}$：\n1.  构建 KKT 块矩阵系统。特别注意活动集 $\\mathcal{I}$ 为空（$k=0$）或没有等式约束（$q=0$）的情况。\n2.  求解该线性系统以得到 $(m, \\lambda_{\\mathcal{I}}, \\nu)$。如果系统是奇异的，则丢弃该候选集。\n3.  检查所得解的完全 KKT 可行性：\n    - 原始可行性：$B m - b \\le \\tau \\mathbf{1}$ 且 $\\lVert C m - c \\rVert_2 \\le \\tau$。\n    - 对偶可行性：$\\lambda_{\\mathcal{I}} \\ge -\\tau \\mathbf{1}$。\n4.  如果解是可行的，计算其目标值 $J(m)$。\n5.  算法追踪产生最小目标值的可行解。对于一个凸问题，这个解是一个 KKT 点，因此是全局最优解。\n6.  最后，通过识别所有满足 $|(B m^\\star - b)_i| \\le \\tau$ 的不等式约束 $i$，从最优解 $m^\\star$ 中确定真实的活动集 $\\mathcal{A}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import chain, combinations\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases for the constrained quadratic inverse problem.\n    \"\"\"\n    \n    # Numerical tolerance for feasibility and active set checks.\n    tau = 1e-8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            'A': np.array([[1., 0.], [0., 2.]]),\n            'd': np.array([1., 2.]),\n            'B': np.array([[-1., 0.], [0., 1.]]),\n            'b': np.array([0., 0.5]),\n            'C': np.array([[1., 1.]]),\n            'c': np.array([1.])\n        },\n        # Test case 2\n        {\n            'A': np.array([[1., 0.], [0., 1.]]),\n            'd': np.array([2., -1.]),\n            'B': np.array([[-1., 0.], [0., -1.], [1., 0.], [0., 1.]]),\n            'b': np.array([0., 0., 1., 1.]),\n            'C': np.empty((0, 2)),\n            'c': np.empty((0,))\n        },\n        # Test case 3\n        {\n            'A': np.array([[1., 0., 0.], [0., 2., 0.], [0., 0., 3.]]),\n            'd': np.array([1., 1., 1.]),\n            'B': np.array([[-1., 0., 0.], [0., -1., 0.], [0., 0., -1.]]),\n            'b': np.array([0., 0., -0.4]),\n            'C': np.array([[1., 1., 1.]]),\n            'c': np.array([1.])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        solution = solve_qp_by_enumeration(case['A'], case['d'], case['B'], case['b'], case['C'], case['c'], tau)\n        \n        # Format the results as specified\n        m_star = solution['m']\n        lambda_star = solution['lambda']\n        nu_star = solution['nu']\n        J_star = solution['J']\n        \n        # Determine final active set from the optimal solution m_star\n        if m_star is not None and case['B'].shape[0] > 0:\n            final_residuals = case['B'] @ m_star - case['b']\n            active_set = np.where(np.abs(final_residuals) = tau)[0]\n        else:\n            active_set = []\n\n        # Convert to lists with specified rounding\n        m_list = [round(x, 6) for x in m_star] if m_star is not None else []\n        active_set_list = [int(i) for i in active_set]\n        lambda_list = [round(x, 6) for x in lambda_star] if lambda_star is not None else []\n        nu_list = [round(x, 6) for x in nu_star] if nu_star is not None else []\n        J_val = round(J_star, 6) if J_star is not None else float('inf')\n\n        results.append([m_list, active_set_list, lambda_list, nu_list, J_val])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_qp_by_enumeration(A, d, B, b, C, c, tau):\n    \"\"\"\n    Solves a constrained quadratic program by enumerating all possible active sets.\n    \"\"\"\n    n = A.shape[1]\n    r = B.shape[0] if B.ndim > 1 else 0\n    q = C.shape[0] if C.ndim > 1 else 0\n\n    H = A.T @ A\n    g = A.T @ d\n\n    best_solution = {\n        'm': None,\n        'lambda': None,\n        'nu': None,\n        'J': float('inf')\n    }\n\n    indices = range(r)\n    powerset = chain.from_iterable(combinations(indices, k) for k in range(r + 1))\n\n    for I_tuple in powerset:\n        I = list(I_tuple)\n        k = len(I)\n\n        B_I = B[I, :] if k > 0 else np.empty((0, n))\n        b_I = b[I] if k > 0 else np.empty(0)\n\n        # Build KKT system K z = f, where z = [m, lambda_I, nu]^T\n        K_blocks = []\n        top_row = [H]\n        if k > 0: top_row.append(B_I.T)\n        if q > 0: top_row.append(C.T)\n        K_blocks.append(top_row)\n        \n        if k > 0:\n            mid_row = [B_I, np.zeros((k, k))]\n            if q > 0: mid_row.append(np.zeros((k, q)))\n            K_blocks.append(mid_row)\n        \n        if q > 0:\n            bot_row = [C]\n            if k > 0: bot_row.append(np.zeros((q, k)))\n            bot_row.append(np.zeros((q, q)))\n            K_blocks.append(bot_row)\n        \n        K = np.block(K_blocks)\n        if K.shape[0] == 0: continue # Should not happen unless n=0\n\n        f_parts = [g]\n        if k > 0: f_parts.append(b_I)\n        if q > 0: f_parts.append(c)\n        f = np.concatenate(f_parts)\n\n        try:\n            z = np.linalg.solve(K, f)\n        except np.linalg.LinAlgError:\n            continue  # Singular matrix, this active set is not valid.\n\n        m_sol = z[:n]\n        lambda_I_sol = z[n:n+k]\n        nu_sol = z[n+k:]\n\n        # --- Check Feasibility of the Candidate Solution ---\n        # 1. Primal feasibility for all inequality constraints\n        if r > 0 and not np.all(B @ m_sol - b = tau):\n            continue\n        \n        # 2. Primal feasibility for equality constraints (should be guaranteed by solver)\n        if q > 0 and np.linalg.norm(C @ m_sol - c) > tau:\n            continue\n        \n        # 3. Dual feasibility for active inequality multipliers\n        if k > 0 and not np.all(lambda_I_sol >= -tau):\n            continue\n        \n        # --- If feasible, check if it's a better solution ---\n        J_val = 0.5 * np.linalg.norm(A @ m_sol - d)**2\n        \n        if J_val  best_solution['J']:\n            full_lambda = np.zeros(r)\n            if k > 0:\n                full_lambda[I] = lambda_I_sol\n            \n            best_solution['m'] = m_sol\n            best_solution['lambda'] = full_lambda\n            best_solution['nu'] = nu_sol\n            best_solution['J'] = J_val\n            \n    return best_solution\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3395272"}, {"introduction": "最后的练习将经典理论与一种强大的现代优化算法——交替方向乘子法（ADMM）联系起来。ADMM广泛用于求解大规模逆问题，特别是那些涉及如$\\ell_{1}$范数（用于促进稀疏性）等不可微正则化项的问题。这个练习的核心是“增广拉格朗日函数”，它将经典拉格朗日函数与一个二次惩罚项相结合。通过从头推导ADMM的迭代步骤，您将揭开这个重要算法的神秘面纱，并理解其与拉格朗日乘子法的深刻联系，展示了如何调整核心概念来为当代难题创建高效、实用的求解方法。[@problem_id:3395284]", "problem": "考虑一个有限维约束逆问题，该问题通过最小化目标函数来从数据 $d \\in \\mathbb{R}^{p}$ 估计参数向量 $m \\in \\mathbb{R}^{n}$ 和辅助变量 $z \\in \\mathbb{R}^{q}$：\n$$\n\\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\alpha \\|z\\|_{1}\n$$\n其线性一致性约束条件为\n$$\nW m - z = 0,\n$$\n其中 $A \\in \\mathbb{R}^{p \\times n}$ 和 $W \\in \\mathbb{R}^{q \\times n}$ 是已知矩阵，$\\alpha  0$ 是给定的正则化权重。请使用拉格朗日乘子法和带有惩罚参数 $\\rho  0$ 的增广拉格朗日构造，从第一性原理出发，推导交替方向乘子法（ADMM）的缩放形式迭代过程。该迭代过程在关于 $m$ 的最小化、关于 $z$ 的最小化以及更新缩放对偶变量之间交替进行。您的推导必须从等式约束优化的经典拉格朗日量和增广拉格朗日量的定义开始，援引一阶最优性条件，并使用 $\\ell_{1}$ 范数的近端算子定义。假设存在确保 $m$-更新步骤具有唯一解的条件，例如对于所选的 $\\rho  0$，$A^{\\top}A + \\rho W^{\\top}W$ 具有正定性。\n\n明确求出：\n- 定义 $m$-更新步骤的线性系统，\n- 以软阈值映射表示的 $z$-更新步骤的逐元素闭式表达式，\n- 缩放对偶变量的更新步骤，\n然后将缩放对偶变量与经典拉格朗日乘子关联起来。\n\n最后，作为您的最终答案，报告一个关于第 $k+1$ 次迭代时经典拉格朗日乘子的单一闭式解析表达式，该表达式应完全用第 $k+1$ 次迭代时的缩放对偶变量和惩罚参数表示。您的最终答案中不要包含等号。不需要进行数值计算，也不涉及单位。如果出现角度，请以弧度表示。最终答案必须是单个表达式，而不是等式或不等式。", "solution": "问题在于推导交替方向乘子法（ADMM），用于通过求解以下约束优化问题来估计参数向量 $m \\in \\mathbb{R}^{n}$ 和辅助变量 $z \\in \\mathbb{R}^{q}$：\n$$\n\\min_{m,z} \\left( \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\alpha \\|z\\|_{1} \\right) \\quad \\text{subject to} \\quad W m - z = 0\n$$\n其中 $A \\in \\mathbb{R}^{p \\times n}$、$W \\in \\mathbb{R}^{q \\times n}$、$d \\in \\mathbb{R}^{p}$ 是给定的，$\\alpha  0$ 是一个正则化参数。\n\n通过辨识 $x=m$、$f(m) = \\frac{1}{2}\\|A m - d\\|_{2}^{2}$、$g(z) = \\alpha \\|z\\|_{1}$、$E=W$、$F=-I$（大小为 $q \\times q$ 的单位矩阵）以及 $c=0$，该问题符合 ADMM 的标准形式 $\\min_{x,z} f(x) + g(z)$，约束条件为 $Ex + Fz = c$。\n\n推导过程首先构造增广拉格朗日量，然后推导原始变量和对偶变量的迭代更新。\n\n对于该问题，其经典拉格朗日量为（其中 $\\lambda \\in \\mathbb{R}^{q}$ 是等式约束的拉格朗日乘子）：\n$$\n\\mathcal{L}(m, z, \\lambda) = \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\alpha \\|z\\|_{1} + \\lambda^{\\top}(W m - z)\n$$\n通过为约束添加一个二次惩罚项（惩罚参数为 $\\rho  0$）来构造增广拉格朗日量：\n$$\n\\mathcal{L}_{\\rho}(m, z, \\lambda) = \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\alpha \\|z\\|_{1} + \\lambda^{\\top}(W m - z) + \\frac{\\rho}{2}\\|W m - z\\|_{2}^{2}\n$$\n为简化表达式，我们使用 ADMM 的缩放形式。我们引入一个缩放对偶变量 $u \\in \\mathbb{R}^{q}$，其定义关系为 $\\lambda = \\rho u$。将其代入增广拉格朗日量得到：\n$$\n\\mathcal{L}_{\\rho}(m, z, u) = \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\alpha \\|z\\|_{1} + (\\rho u)^{\\top}(W m - z) + \\frac{\\rho}{2}\\|W m - z\\|_{2}^{2}\n$$\n通过对包含对偶变量和约束的项进行配方，我们可以将拉格朗日量重写为更紧凑的形式：\n\\begin{align*}\n(\\rho u)^{\\top}(W m - z) + \\frac{\\rho}{2}\\|W m - z\\|_{2}^{2} = \\frac{\\rho}{2} \\left( 2u^{\\top}(W m - z) + \\|W m - z\\|_{2}^{2} \\right) \\\\\n= \\frac{\\rho}{2} \\left( \\|W m - z\\|_{2}^{2} + 2u^{\\top}(W m - z) + \\|u\\|_{2}^{2} - \\|u\\|_{2}^{2} \\right) \\\\\n= \\frac{\\rho}{2} \\left( \\|(W m - z) + u\\|_{2}^{2} - \\|u\\|_{2}^{2} \\right)\n\\end{align*}\n因此，缩放的增广拉格朗日量为：\n$$\n\\mathcal{L}_{\\rho}(m, z, u) = \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\alpha \\|z\\|_{1} + \\frac{\\rho}{2}\\|W m - z + u\\|_{2}^{2} - \\frac{\\rho}{2}\\|u\\|_{2}^{2}\n$$\nADMM 算法执行关于 $m$ 和 $z$ 的交替最小化，然后更新对偶变量 $u$。在第 $k+1$ 次迭代时，从已知值 $(z^k, u^k)$ 开始，步骤如下：\n\n1. $m$-更新步骤：\n$m^{k+1}$ 通过最小化 $\\mathcal{L}_{\\rho}(m, z^k, u^k)$（关于 $m$）来找到。我们可以舍去所有关于 $m$ 的常数项：\n$$\nm^{k+1} = \\arg\\min_{m} \\left( \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\frac{\\rho}{2}\\|W m - z^k + u^k\\|_{2}^{2} \\right)\n$$\n这是一个无约束的二次最小化问题。通过将目标函数关于 $m$ 的梯度设为零来找到解：\n$$\n\\nabla_{m} \\left( \\frac{1}{2}\\|A m - d\\|_{2}^{2} + \\frac{\\rho}{2}\\|W m - z^k + u^k\\|_{2}^{2} \\right) = 0\n$$\n$$\nA^{\\top}(A m - d) + \\rho W^{\\top}(W m - z^k + u^k) = 0\n$$\n将包含 $m$ 的项组合到一边，得到关于 $m^{k+1}$ 的线性系统：\n$$\n(A^{\\top}A + \\rho W^{\\top}W) m^{k+1} = A^{\\top}d + \\rho W^{\\top}(z^k - u^k)\n$$\n问题陈述中假设矩阵 $(A^{\\top}A + \\rho W^{\\top}W)$ 是正定的，这保证了该线性系统对于 $m^{k+1}$ 有唯一解。\n\n2. $z$-更新步骤：\n使用新计算出的 $m^{k+1}$，通过最小化 $\\mathcal{L}_{\\rho}(m^{k+1}, z, u^k)$（关于 $z$）来找到 $z^{k+1}$。同样，我们舍去常数项：\n$$\nz^{k+1} = \\arg\\min_{z} \\left( \\alpha \\|z\\|_{1} + \\frac{\\rho}{2}\\|W m^{k+1} - z + u^k\\|_{2}^{2} \\right)\n$$\n令向量 $v = W m^{k+1} + u^k$。该最小化问题可以写为：\n$$\nz^{k+1} = \\arg\\min_{z} \\left( \\alpha \\|z\\|_{1} + \\frac{\\rho}{2}\\|z - v\\|_{2}^{2} \\right)\n$$\n这等价于：\n$$\nz^{k+1} = \\arg\\min_{z} \\left( \\frac{\\alpha}{\\rho}\\|z\\|_{1} + \\frac{1}{2}\\|z - v\\|_{2}^{2} \\right)\n$$\n这是函数 $h(z) = (\\alpha/\\rho)\\|z\\|_{1}$ 在 $v$ 处求值的近端算子的定义。$\\ell_1$-范数的近端算子是软阈值算子 $S_{\\kappa}(\\cdot)$，其中阈值为 $\\kappa = \\alpha/\\rho$。该算子逐元素应用。因此，$z$-更新步骤的闭式表达式为：\n$$\nz^{k+1} = S_{\\alpha/\\rho}(W m^{k+1} + u^k)\n$$\n其中对于每个分量 $i$，$(S_{\\kappa}(x))_i = \\text{sign}(x_i) \\max(|x_i| - \\kappa, 0)$。\n\n3. 缩放对偶变量更新步骤：\n经典拉格朗日乘子 $\\lambda$ 的更新遵循对偶上升步骤：\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho(W m^{k+1} - z^{k+1})\n$$\n使用缩放关系 $\\lambda = \\rho u$，我们代入 $\\lambda^k = \\rho u^k$ 和 $\\lambda^{k+1} = \\rho u^{k+1}$：\n$$\n\\rho u^{k+1} = \\rho u^k + \\rho(W m^{k+1} - z^{k+1})\n$$\n由于 $\\rho > 0$，我们可以两边同除以 $\\rho$ 来获得缩放对偶变量的更新公式：\n$$\nu^{k+1} = u^k + (W m^{k+1} - z^{k+1})\n$$\n项 $W m^{k+1} - z^{k+1}$ 是第 $k+1$ 次迭代时的原始残差。\n\n最后，经典拉格朗日乘子 $\\lambda^{k+1}$ 与缩放对偶变量 $u^{k+1}$ 之间的关系由缩放本身的定义给出。对第 $k+1$ 次迭代重新整理 $\\lambda = \\rho u$ 可得：\n$$\n\\lambda^{k+1} = \\rho u^{k+1}\n$$\n这就提供了第 $k+1$ 次迭代时经典拉格朗日乘子关于相应缩放对偶变量和惩罚参数的表达式。", "answer": "$$\n\\boxed{\\rho u^{k+1}}\n$$", "id": "3395284"}]}