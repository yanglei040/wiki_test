{"hands_on_practices": [{"introduction": "在求解线性逆问题时，截断奇异值分解（TSVD）是一种核心的正则化技术。它通过舍弃与小奇异值相关的分量来抑制噪声放大，但这会引入截断偏差。此练习将引导您亲手推导TSVD估计器的期望均方误差（MSE），并让您通过一个具体案例[@problem_id:3401167]计算出在偏差和方差之间取得最佳平衡的最优截断参数$k$。这个过程将加深您对正则化中基本权衡思想的理解。", "problem": "考虑一个线性逆问题，其正向算子为 $A \\in \\mathbb{R}^{m \\times n}$，观测值为 $y \\in \\mathbb{R}^{m}$，由 $y = A x^{\\dagger} + \\eta$ 给出，其中 $x^{\\dagger} \\in \\mathbb{R}^{n}$ 是未知状态，$\\eta \\in \\mathbb{R}^{m}$ 是零均值随机噪声。设 $A$ 的奇异值分解 (SVD) 为 $A = U \\Sigma V^{\\top}$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是对角矩阵，其非负对角元为 $\\sigma_{1} \\geq \\sigma_{2} \\geq \\dots \\geq \\sigma_{n} \\geq 0$。定义秩为 $k$ 的截断奇异值分解 (TSVD) 估计量，记为 $x_{k} \\in \\mathbb{R}^{n}$，其表达式为 $x_{k} = \\sum_{i=1}^{k} \\frac{u_{i}^{\\top} y}{\\sigma_{i}} v_{i}$，其中 $u_{i}$ 和 $v_{i}$ 是对应于 $\\sigma_{i}$ 的左右奇异向量。设期望均方误差 (MSE) 为 $\\mathbb{E}\\|x_{k} - x^{\\dagger}\\|^{2}$，其中期望是关于 $\\eta$ 的分布计算的。假设一个模态相关的噪声水平模型 $\\mathbb{E}|u_{i}^{\\top} \\eta|^{2} = \\phi_{i}$（对于 $i = 1, \\dots, n$），并将在右奇异向量基下的 $x^{\\dagger}$ 的真实系数写作 $\\alpha_{i} = v_{i}^{\\top} x^{\\dagger}$。\n\n从以上定义出发，且不使用任何快捷公式，推导出一个用 $(\\sigma_{i})$、$(\\phi_{i})$ 和 $(\\alpha_{i})$ 表示 $\\mathbb{E}\\|x_{k} - x^{\\dagger}\\|^{2}$ 的公式，然后构建用于选择使期望误差最小化的 $k$ 的离散优化问题。\n\n现在，考虑一个具体情况：$n = 8$，奇异值为 $\\sigma_{i} = 16 \\cdot 2^{-(i-1)}$（对于 $i = 1, \\dots, 8$），白噪声模型为 $\\phi_{i} = 1$（对于所有 $i$），真实系数为 $\\alpha_{i} = \\frac{1}{i}$（对于 $i = 1, \\dots, 8$）。计算期望均方误差的最小化子 $k^{\\star} \\in \\{0, 1, \\dots, 8\\}$。你的最终答案必须是 $k^{\\star}$ 的值，形式为单个整数。不需要四舍五入。", "solution": "该问题陈述被评估为有效，它具有科学依据、良定且自洽。它是在线性逆问题正则化方法分析中的一个标准练习。\n\n主要目标是找到整数 $k^{\\star} \\in \\{0, 1, \\dots, 8\\}$，以最小化截断奇异值分解 (TSVD) 估计量的期望均方误差 (MSE)。首先，我们推导 MSE 的通用公式，然后将其应用于给定的具体情况。\n\n设误差向量为 $e_k = x_k - x^{\\dagger}$。MSE 定义为 $\\mathbb{E}\\|e_k\\|^2 = \\mathbb{E}\\|x_k - x^{\\dagger}\\|^2$。右奇异向量集合 $\\{v_i\\}_{i=1}^n$ 构成了 $\\mathbb{R}^n$ 的一个标准正交基。因此，误差向量的平方范数可以表示为它在该基下的分量的平方和：\n$$\n\\|x_k - x^{\\dagger}\\|^2 = \\sum_{i=1}^{n} \\left(v_i^{\\top}(x_k - x^{\\dagger})\\right)^2\n$$\n这些分量是 $v_i^{\\top}x_k - v_i^{\\top}x^{\\dagger}$。根据定义，我们有 $\\alpha_i = v_i^{\\top}x^{\\dagger}$。\n\n为了计算 $v_i^{\\top}x_k$，我们使用 TSVD 估计量的定义 $x_k = \\sum_{j=1}^{k} \\frac{u_j^{\\top} y}{\\sigma_j} v_j$：\n$$\nv_i^{\\top}x_k = v_i^{\\top}\\left(\\sum_{j=1}^{k} \\frac{u_j^{\\top} y}{\\sigma_j} v_j\\right) = \\sum_{j=1}^{k} \\frac{u_j^{\\top} y}{\\sigma_j} (v_i^{\\top}v_j)\n$$\n由于右奇异向量的正交规范性 ($v_i^{\\top}v_j = \\delta_{ij}$)，上式简化为：\n$$\nv_i^{\\top}x_k = \\begin{cases} \\frac{u_i^{\\top} y}{\\sigma_i} & \\text{ 如果 } 1 \\leq i \\leq k \\\\ 0 & \\text{ 如果 } i > k \\end{cases}\n$$\n接下来，我们使用线性模型 $y = Ax^{\\dagger} + \\eta$ 和 $A$ 的 SVD 分解 $A = \\sum_{j=1}^n \\sigma_j u_j v_j^{\\top}$ 来展开投影数据项 $u_i^{\\top}y$：\n$$\nu_i^{\\top}y = u_i^{\\top}(Ax^{\\dagger} + \\eta) = u_i^{\\top}A x^{\\dagger} + u_i^{\\top}\\eta\n$$\n项 $u_i^{\\top}A x^{\\dagger}$ 变为：\n$$\nu_i^{\\top}A x^{\\dagger} = u_i^{\\top}\\left(\\sum_{j=1}^n \\sigma_j u_j v_j^{\\top}\\right)x^{\\dagger} = \\sum_{j=1}^n \\sigma_j (u_i^{\\top}u_j)(v_j^{\\top}x^{\\dagger})\n$$\n利用左奇异向量的正交规范性 ($u_i^{\\top}u_j = \\delta_{ij}$) 和定义 $\\alpha_j = v_j^{\\top}x^{\\dagger}$，我们得到：\n$$\nu_i^{\\top}A x^{\\dagger} = \\sigma_i \\alpha_i\n$$\n因此，投影数据为 $u_i^{\\top}y = \\sigma_i \\alpha_i + u_i^{\\top}\\eta$。\n\n我们现在可以表示误差向量的分量。\n对于 $1 \\leq i \\leq k$：\n$$\nv_i^{\\top}(x_k - x^{\\dagger}) = \\frac{u_i^{\\top}y}{\\sigma_i} - \\alpha_i = \\frac{\\sigma_i \\alpha_i + u_i^{\\top}\\eta}{\\sigma_i} - \\alpha_i = \\frac{u_i^{\\top}\\eta}{\\sigma_i}\n$$\n对于 $i > k$：\n$$\nv_i^{\\top}(x_k - x^{\\dagger}) = 0 - \\alpha_i = -\\alpha_i\n$$\n将这些代回到平方范数的表达式中：\n$$\n\\|x_k - x^{\\dagger}\\|^2 = \\sum_{i=1}^{k} \\left(\\frac{u_i^{\\top}\\eta}{\\sigma_i}\\right)^2 + \\sum_{i=k+1}^{n} (-\\alpha_i)^2 = \\sum_{i=1}^{k} \\frac{|u_i^{\\top}\\eta|^2}{\\sigma_i^2} + \\sum_{i=k+1}^{n} \\alpha_i^2\n$$\nMSE 是此量关于噪声分布的期望。由于期望算子是线性的，并且项 $\\alpha_i, \\sigma_i$ 是确定性的：\n$$\n\\mathbb{E}\\|x_k - x^{\\dagger}\\|^2 = \\sum_{i=1}^{k} \\frac{\\mathbb{E}|u_i^{\\top}\\eta|^2}{\\sigma_i^2} + \\sum_{i=k+1}^{n} \\alpha_i^2\n$$\n使用给定的噪声模型 $\\mathbb{E}|u_i^{\\top}\\eta|^2 = \\phi_i$，作为 $k$ 的函数的 MSE 为：\n$$\n\\text{MSE}(k) = \\sum_{i=1}^{k} \\frac{\\phi_i}{\\sigma_i^2} + \\sum_{i=k+1}^{n} \\alpha_i^2\n$$\n第一项是由于噪声传播引起的方差，第二项是由于截断引起的偏差平方。优化问题是找到 $k^{\\star} = \\arg\\min_{k \\in \\{0, 1, \\dots, n\\}} \\text{MSE}(k)$。\n\n现在我们求解具体情况：$n=8$、$\\sigma_i = 16 \\cdot 2^{-(i-1)}$、$\\phi_i=1$ 且 $\\alpha_i = \\frac{1}{i}$。令 $f(k) = \\text{MSE}(k)$。我们希望找到 $k^{\\star} = \\arg\\min_{k \\in \\{0, \\dots, 8\\}} f(k)$。\n为了找到最小值，我们分析当 $k \\in \\{1, \\dots, 8\\}$ 时，增量 $f(k) - f(k-1)$：\n$$\nf(k) - f(k-1) = \\left(\\sum_{i=1}^{k} \\frac{1}{\\sigma_i^2} + \\sum_{i=k+1}^{8} \\alpha_i^2\\right) - \\left(\\sum_{i=1}^{k-1} \\frac{1}{\\sigma_i^2} + \\sum_{i=k}^{8} \\alpha_i^2\\right)\n$$\n$$\nf(k) - f(k-1) = \\frac{1}{\\sigma_k^2} - \\alpha_k^2\n$$\n如果这个增量为负，即 $\\frac{1}{\\sigma_k^2}  \\alpha_k^2$，则 MSE 从 $k-1$ 减小到 $k$。最小值将在函数递减的最后一个 $k$ 值处达到。我们寻找增量变为正的转折点。这发生在 $\\frac{1}{\\sigma_k^2} > \\alpha_k^2$ 时。最优截断水平 $k^{\\star}$ 将是这个转折点之前的索引。\n\n我们来检验条件 $\\frac{1}{\\sigma_i^2}  \\alpha_i^2$，这等价于 $\\sigma_i^2 > \\frac{1}{\\alpha_i^2} = i^2$。\n奇异值为 $\\sigma_i = 16 \\cdot 2^{-(i-1)} = 2^{4} \\cdot 2^{-i+1} = 2^{5-i}$。\n因此，$\\sigma_i^2 = (2^{5-i})^2 = 2^{10-2i}$。\n对于每个 $i \\in \\{1, \\dots, 8\\}$，要检查的条件是 $2^{10-2i} > i^2$。\n- 对于 $i=1$：$2^{10-2} = 2^8 = 256$。$1^2 = 1$。$256 > 1$ 成立。$f(1)  f(0)$。\n- 对于 $i=2$：$2^{10-4} = 2^6 = 64$。$2^2 = 4$。$64 > 4$ 成立。$f(2)  f(1)$。\n- 对于 $i=3$：$2^{10-6} = 2^4 = 16$。$3^2 = 9$。$16 > 9$ 成立。$f(3)  f(2)$。\n- 对于 $i=4$：$2^{10-8} = 2^2 = 4$。$4^2 = 16$。$4 > 16$ 不成立。$f(4) > f(3)$。\n\n增量 $f(k) - f(k-1)$ 在 $k=1, 2, 3$ 时为负，在 $k=4$ 时变为正。这意味着 MSE 值的序列在 $k=3$ 之前递减，然后开始递增：\n$f(0) > f(1) > f(2) > f(3)  f(4)$。\n当 $k>4$ 时，函数 $f(k)$ 继续增加，因为奇异值 $\\sigma_k$ 迅速减小，使得方差项 $1/\\sigma_k^2$ 增长非常快，而偏差项 $\\alpha_k^2 = 1/k^2$ 减小得更慢。\n因此，期望均方误差的最小值在 $k^{\\star}=3$ 时达到。", "answer": "$$\\boxed{3}$$", "id": "3401167"}, {"introduction": "在理想化的场景下评估反演方法，其性能可能看起来很完美，但这往往掩盖了在现实世界中模型不完美所带来的挑战。一个常见的陷阱是“反演犯罪”（inverse crime），即使用同一个模型来生成合成数据并进行反演，这会导致对算法性能的评估过于乐观。本练习将通过一个编码任务[@problem_id:3401148]模拟这一现象，并向您展示如何使用交叉验证作为一种有效的诊断工具，来揭示模型失配（model mismatch）并更真实地评估解的泛化能力。", "problem": "考虑一个线性逆问题，其中未知向量 $x \\in \\mathbb{R}^{n}$ 是从由正向算子 $A \\in \\mathbb{R}^{m \\times n}$ 控制的线性观测 $b \\in \\mathbb{R}^{m}$ 中推断出来的。假设 $m \\ge n$。数据生成方式为 $b = A x_{\\mathrm{true}} + \\eta$，其中 $x_{\\mathrm{true}} \\in \\mathbb{R}^{n}$ 是一个固定但未知的向量，$\\eta \\in \\mathbb{R}^{m}$ 代表加性噪声。设矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的奇异值分解（SVD）表示为 $A = U \\Sigma V^{\\top}$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是对角矩阵，其非负对角元为 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\cdots \\ge \\sigma_{n} \\ge 0$。右奇异向量是 $V$ 的列向量，左奇异向量是 $U$ 的列向量。截断SVD估计量（截断参数为 $k \\in \\{1,\\dots,n\\}$）的定义为：将问题投影到训练算子的前 $k$ 个右奇异向量张成的空间上，并对相应的非零奇异值进行求逆。\n\n您的任务是阐释逆问题中通常被称为“逆问题犯罪”的现象：即使用一个正向算子构造合成数据，然后用相同的算子和基进行反演，这可能导致过于乐观的重构结果。您还必须实现使用交叉验证和不同测试算子的实用诊断方法，以检测这种过度乐观的情况。\n\n请基于以下基本定义和事实进行推理：\n- 任何实矩阵 $A$ 都存在奇异值分解（SVD），并提供左、右奇异向量的标准正交基。\n- 截断SVD解 $x_{k}$ 是通过将反演限制在训练算子的 $k$ 个最大奇异值及其对应的奇异向量上得到的。\n- 正交变换保持欧几里得范数不变。\n- 欧几里得范数定义为 $\\|z\\|_{2} = \\sqrt{z^{\\top} z}$，矩阵 $M$ 的弗罗贝尼乌斯范数定义为 $\\|M\\|_{F} = \\sqrt{\\sum_{i,j} M_{ij}^{2}}$。\n\n通过直接组装其SVD因子来构造训练和测试算子，以控制它们的谱内容，并引入不同程度的训练与测试之间的不匹配。在所有情况下，请使用以下确定性协议：\n- 维度：$m = 40$，$n = 30$。\n- 奇异值分布：对于衰减指数 $p > 0$，设置 $\\sigma_{i} = (i)^{-p}$，其中 $i = 1,\\dots,n$。\n- 构造一个 $d \\times d$ 的正交矩阵：抽取一个具有独立标准正态分布元素的稠密矩阵，并从简约Householder-QR分解中计算其 $Q$ 因子；调整列的符号以使 $R$ 的对角线为非负。使用此方法构造 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$。\n- 通过 $A = U_{:,1:n} \\operatorname{diag}(\\sigma) V_{:,1:n}^{\\top}$ 组装 $A$。\n- 对每种情况，通过指定其SVD因子来定义训练算子 $A_{\\mathrm{tr}}$ 和测试算子 $A_{\\mathrm{te}}$。当需要“小旋转”时，通过 $U_{\\mathrm{tr}} + \\varepsilon \\tilde{U}$ 的 $Q$ 因子形成 $U_{\\mathrm{te}}$，其中 $\\tilde{U}$ 是一个独立抽取的正交矩阵，对 $V_{\\mathrm{te}}$ 也类似操作。当奇异值受扰动时，设置 $\\sigma^{(\\mathrm{te})}_{i} = \\sigma_{i}(1+\\delta_{i})$，其中 $\\delta_{i}$ 在一个宽度与 $\\varepsilon$ 成比例的对称区间内独立且均匀分布。\n- 构造 $x_{\\mathrm{true}}$：抽取一个具有独立标准正态分布元素的向量 $w \\in \\mathbb{R}^{n}$，将其分量设置为 $w_{i}/i$（其中 $i=1,\\dots,n$），然后归一化为单位欧几里得范数。\n- 对于选定的相对噪声水平 $\\alpha > 0$，设置 $b_{\\mathrm{tr}} = A_{\\mathrm{tr}} x_{\\mathrm{true}} + \\eta_{\\mathrm{tr}}$ 和 $b_{\\mathrm{te}} = A_{\\mathrm{te}} x_{\\mathrm{true}} + \\eta_{\\mathrm{te}}$，其中 $\\|\\eta_{\\mathrm{tr}}\\|_{2} = \\alpha \\|A_{\\mathrm{tr}} x_{\\mathrm{true}}\\|_{2}$ 和 $\\|\\eta_{\\mathrm{te}}\\|_{2} = \\alpha \\|A_{\\mathrm{te}} x_{\\mathrm{true}}\\|_{2}$，噪声方向在各自的球面上均匀随机抽样。\n\n给定 $A_{\\mathrm{tr}}$ 和 $b_{\\mathrm{tr}}$，仅使用 $A_{\\mathrm{tr}}$ 的前 $k$ 个奇异值三元组计算截断SVD估计 $x_{k}$。然后评估以下诊断指标：\n1. 交叉验证间隙比 $\\rho = \\|A_{\\mathrm{te}} x_{k} - b_{\\mathrm{te}}\\|_{2} \\big/ \\|A_{\\mathrm{tr}} x_{k} - b_{\\mathrm{tr}}\\|_{2}$。\n2. 低可观测性能量分数 $f_{\\mathrm{low}}$，其定义为：将 $x_{k}$ 在 $A_{\\mathrm{te}}$ 的右奇异基中表示，并报告其系数平方和中位于与小于最大测试奇异值的固定分数 $\\tau$ 的奇异值相关联的子空间中的部分，即阈值为 $\\tau = 10^{-2}$：\n$$\nf_{\\mathrm{low}} = \\frac{\\sum_{i:\\ \\sigma^{(\\mathrm{te})}_{i}  \\tau \\sigma^{(\\mathrm{te})}_{1}} c_{i}^{2}}{\\sum_{i=1}^{n} c_{i}^{2}},\n$$\n其中 $x_{k} = \\sum_{i=1}^{n} c_{i} v^{(\\mathrm{te})}_{i}$，$v^{(\\mathrm{te})}_{i}$ 是 $A_{\\mathrm{te}}$ 的右奇异向量。\n3. 相对算子差异 $d_{A} = \\|A_{\\mathrm{te}} - A_{\\mathrm{tr}}\\|_{F} \\big/ \\|A_{\\mathrm{tr}}\\|_{F}$。\n\n实现以下四个测试案例。在所有案例中，设置 $p = 1$ 和 $\\tau = 10^{-2}$。为保证确定性，每个案例使用一个基础整数种子 $S$，并通过添加指定的固定偏移量来派生子源。具体来说，对于标有种子“$S + c$”的项目，使用整数种子 $S + c$ 初始化一个新的独立随机数生成器。\n\n- 案例1（逆问题犯罪）：$S = 31415$，$\\alpha = 0.02$，$k = 10$。使用种子 $S+1$ 和 $S+2$ 为 $U_{\\mathrm{tr}}$ 和 $V_{\\mathrm{tr}}$ 构造正交因子，从而构造 $A_{\\mathrm{tr}}$。设置 $A_{\\mathrm{te}} = A_{\\mathrm{tr}}$。使用种子 $S+40$ 抽取 $x_{\\mathrm{true}}$。使用种子 $S+50$ 和 $S+60$ 抽取 $\\eta_{\\mathrm{tr}}$ 和 $\\eta_{\\mathrm{te}}$。\n- 案例2（轻度不匹配）：$S = 27182$，$\\alpha = 0.02$，$k = 10$。如案例1所示，使用种子 $S+1$ 和 $S+2$ 构造 $A_{\\mathrm{tr}}$。使用 $\\varepsilon = 0.2$ 和种子 $S+10$ 及 $S+20$ 构造小旋转，以构建 $\\tilde{U}$ 和 $\\tilde{V}$；重新正交化以得到 $U_{\\mathrm{te}}$ 和 $V_{\\mathrm{te}}$。使用种子 $S+30$ 从 $[-0.02, 0.02]$ 均匀抽取 $\\delta_{i}$ 来扰动奇异值。使用 $U_{\\mathrm{te}}$、$V_{\\mathrm{te}}$ 和受扰动的奇异值组装 $A_{\\mathrm{te}}$。使用种子 $S+40$、$S+50$、$S+60$ 生成 $x_{\\mathrm{true}}$、$\\eta_{\\mathrm{tr}}$、$\\eta_{\\mathrm{te}}$。\n- 案例3（严重不匹配）：$S = 14142$，$\\alpha = 0.02$，$k = 10$。使用种子 $S+1$ 和 $S+2$ 构造 $A_{\\mathrm{tr}}$。使用种子 $S+1001$ 和 $S+1002$ 独立构造 $A_{\\mathrm{te}}$，并使用相同的奇异值分布（无扰动）。使用种子 $S+40$、$S+50$、$S+60$ 生成 $x_{\\mathrm{true}}$、$\\eta_{\\mathrm{tr}}$、$\\eta_{\\mathrm{te}}$。\n- 案例4（不匹配与激进截断）：$S = 17321$，$\\alpha = 0.02$，$k = 25$。使用种子 $S+1$ 和 $S+2$ 构造 $A_{\\mathrm{tr}}$。如案例2所示，使用相同的 $\\varepsilon = 0.2$ 以及种子 $S+10$、$S+20$、$S+30$ 构造小旋转和受扰动的奇异值。使用种子 $S+40$、$S+50$、$S+60$ 生成 $x_{\\mathrm{true}}$、$\\eta_{\\mathrm{tr}}$、$\\eta_{\\mathrm{te}}$。\n\n您的程序必须：\n- 按规定构造所有矩阵和向量。\n- 根据指定的截断参数 $k$，通过 $A_{\\mathrm{tr}}$ 的SVD计算 $x_{k}$。\n- 为每个案例计算并报告三个实值诊断指标 $(\\rho, f_{\\mathrm{low}}, d_{A})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，顺序如下：\n$[\\rho_{1}, f_{\\mathrm{low},1}, d_{A,1}, \\rho_{2}, f_{\\mathrm{low},2}, d_{A,2}, \\rho_{3}, f_{\\mathrm{low},3}, d_{A,3}, \\rho_{4}, f_{\\mathrm{low},4}, d_{A,4}]$,\n每个浮点数格式化为六位小数。", "solution": "对问题陈述的严格验证证实了其有效性。该问题是适定的，在线性逆问题的既定框架内具有科学依据，并为所有计算提供了完整、确定性的协议。所有术语都有正式定义，设置没有矛盾或模糊之处。具体而言，该问题提供了明确的维度（$m=40, n=30$），构造所有算子（$A_{\\mathrm{tr}}, A_{\\mathrm{te}}$）和向量（$x_{\\mathrm{true}}, \\eta$）的确定性方法，所有必需诊断指标（$\\rho, f_{\\mathrm{low}}, d_{A}$）的精确公式，以及四个不同测试案例的明确参数和随机种子。该任务是一个标准的数值实验，旨在阐释数据同化和逆理论中的一个关键概念。因此，我们可以着手求解。\n\n该问题要求调查“逆问题犯罪”现象。当同一个正向算子 $A$ 同时用于生成合成观测数据（$b = A x_{\\mathrm{true}} + \\eta$）和从 $b$ 反演估计 $x$ 时，就会发生这种情况。此过程隐含地假设了一个完美模型，因为模型误差 $A_{\\mathrm{te}} - A_{\\mathrm{tr}}$ 为零。由此产生的重构误差可能低得不切实际，从而对反演方法产生错误的自信感。一种更稳健的评估方法论涉及交叉验证，其中用于反演的算子 $A_{\\mathrm{tr}}$ 与描述测试数据的算子 $A_{\\mathrm{te}}$ 是不同的。\n\n正向模型是一个线性系统 $b = Ax + \\eta$，我们旨在从观测值 $b \\in \\mathbb{R}^{m}$ 中确定 $x \\in \\mathbb{R}^{n}$。算子 $A$ 是病态的，其奇异值 $\\sigma_i$ 会衰减至零。这使得朴素解 $x = (A^{\\top}A)^{-1}A^{\\top}b$ 极易受到噪声放大的影响。截断奇异值分解（TSVD）是一种解决此问题的正则化方法。给定训练算子的SVD，$A_{\\mathrm{tr}} = U_{\\mathrm{tr}} \\Sigma_{\\mathrm{tr}} V_{\\mathrm{tr}}^{\\top}$，TSVD估计 $x_k$ 是通过仅保留与最大奇异值相对应的前 $k$ 个分量来形成的：\n$$\nx_k = \\sum_{i=1}^{k} \\frac{u_{\\mathrm{tr},i}^{\\top} b_{\\mathrm{tr}}}{\\sigma_{\\mathrm{tr},i}} v_{\\mathrm{tr},i}\n$$\n其中 $u_{\\mathrm{tr},i}$ 和 $v_{\\mathrm{tr},i}$ 分别是 $A_{\\mathrm{tr}}$ 的第 $i$ 个左、右奇异向量，$k$ 是截断参数。这有效地滤除了与小奇异值相关的高度噪声敏感模式的贡献。\n\n为了评估 $x_k$，我们计算三个诊断指标：\n\n1.  **交叉验证间隙比 $\\rho$**：这是测试残差范数与训练残差范数之比，$\\rho = \\|A_{\\mathrm{te}} x_{k} - b_{\\mathrm{te}}\\|_{2} / \\|A_{\\mathrm{tr}} x_{k} - b_{\\mathrm{tr}}\\|_{2}$。在 $A_{\\mathrm{te}} = A_{\\mathrm{tr}}$ 的“逆问题犯罪”情景中，我们预期 $\\rho \\approx 1$，因为残差是由相似量级的噪声驱动的。当 $A_{\\mathrm{te}} \\neq A_{\\mathrm{tr}}$ 时，模型不匹配会在测试残差中引入一个额外的误差项，通常导致 $\\rho > 1$。一个大的 $\\rho$ 值表明解 $x_k$ 对 $A_{\\mathrm{tr}}$ 的特定属性过拟合，并且泛化能力不佳。\n\n2.  **相对算子差异 $d_{A}$**：这是测试算子和训练算子之差的弗罗贝尼乌斯范数，由训练算子的范数归一化，$d_{A} = \\|A_{\\mathrm{te}} - A_{\\mathrm{tr}}\\|_{F} / \\|A_{\\mathrm{tr}}\\|_{F}$。它提供了模型不匹配的直接量化。\n\n3.  **低可观测性能量分数 $f_{\\mathrm{low}}$**：该诊断指标量化了解的能量中有多少位于*测试*算子 $A_{\\mathrm{te}}$ 难以观测到的子空间中。解 $x_k$ 在 $A_{\\mathrm{te}}$ 的右奇异向量基中展开，$x_{k} = \\sum_{i=1}^{n} c_{i} v^{(\\mathrm{te})}_{i}$。计算与奇异值 $\\sigma_i^{(\\mathrm{te})}$ 低于阈值 $\\tau \\sigma_1^{(\\mathrm{te})}$ 相对应的能量（系数平方和）的分数。一个高的 $f_{\\mathrm{low}}$ 值将表明，从 $A_{\\mathrm{tr}}$ 导出的解 $x_k$ 严重依赖于那些几乎在 $A_{\\mathrm{te}}$ 零空间中的分量，这表示算子之间存在显著的结构性不匹配。对于给定的参数（$p=1$, $\\tau=10^{-2}$），奇异值为 $\\sigma_i \\approx 1/i$。最小的奇异值是 $\\sigma_{30} \\approx 1/30 \\approx 0.0333$。阈值是 $\\tau \\sigma_1 \\approx 10^{-2} \\times 1 = 0.01$。由于所构造算子的所有奇异值都大于此阈值，低可观测性子空间是空的，因此我们正确地预期所有测试案例的 $f_{\\mathrm{low}} = 0$。这是指定参数化的一个有效结果。\n\n计算过程涉及四个案例，每个案例由一组种子和参数定义。\n- **案例1（逆问题犯罪）**：此处，$A_{\\mathrm{te}} = A_{\\mathrm{tr}}$，代表了理想化但不切实际的情景。我们预期 $\\rho \\approx 1$ 且 $d_A=0$。\n- **案例2（轻度不匹配）**：$A_{\\mathrm{te}}$ 是 $A_{\\mathrm{tr}}$ 的一个小扰动。这模拟了一个现实情景，即模型是对现实的一个良好但不完美的近似。我们预期 $\\rho > 1$ 且有一个小的 $d_A > 0$。\n- **案例3（严重不匹配）**：$A_{\\mathrm{te}}$ 独立于 $A_{\\mathrm{tr}}$ 构造，但具有相同的谱分布。这代表了一个差的模型。我们预期有一个大的间隙比 $\\rho \\gg 1$ 和一个大的 $d_A$。\n- **案例4（不匹配与激进截断）**：这与案例2相似，但截断参数 $k=25$ 大得多。通过在反演中包含更多病态模式，解对噪声和模型误差都变得更加敏感。我们预期这将加剧交叉验证间隙，导致比案例2更大的 $\\rho$。\n\n该实现将使用指定的种子确定性地构造所有矩阵和向量，为每个案例计算TSVD解 $x_k$，然后计算三个诊断指标 $(\\rho, d_A, f_{\\mathrm{low}})$。所有随机正交矩阵都是通过对具有标准正态分布元素的矩阵进行QR分解来构造的，并调整列符号以确保Q因子的唯一性，从而保证可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef construct_orthogonal_matrix(d, seed):\n    \"\"\"\n    Constructs a d x d orthogonal matrix deterministically using QR factorization.\n    The QR decomposition is made unique by enforcing a non-negative diagonal on R.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    G = rng.standard_normal(size=(d, d))\n    Q, R = linalg.qr(G, mode='full')\n    s = np.diag(np.sign(np.diag(R)))\n    Q = Q @ s\n    return Q\n\ndef construct_true_solution(n, seed):\n    \"\"\"\n    Constructs the true solution vector x_true of size n.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    w = rng.standard_normal(n)\n    x_unscaled = w / np.arange(1, n + 1)\n    x_true = x_unscaled / np.linalg.norm(x_unscaled)\n    return x_true\n\ndef construct_noise_vector(A, x_true, alpha, seed):\n    \"\"\"\n    Constructs a noise vector eta with a specified relative norm.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    m = A.shape[0]\n    signal = A @ x_true\n    signal_norm = np.linalg.norm(signal)\n    target_norm = alpha * signal_norm\n    \n    z = rng.standard_normal(m)\n    eta = target_norm * z / np.linalg.norm(z)\n    return eta\n\ndef build_A_and_factors(m, n, p, U_seed, V_seed):\n    \"\"\"\n    Assembles a matrix A from its SVD components constructed deterministically.\n    \"\"\"\n    U_full = construct_orthogonal_matrix(m, U_seed)\n    V_full = construct_orthogonal_matrix(n, V_seed)\n    sigma = np.power(np.arange(1, n + 1, dtype=float), -p)\n    A = U_full[:, :n] @ np.diag(sigma) @ V_full.T\n    return A, U_full, V_full, sigma\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and compute diagnostics.\n    \"\"\"\n    test_cases = [\n        {'S': 31415, 'alpha': 0.02, 'k': 10, 'type': 'crime'},\n        {'S': 27182, 'alpha': 0.02, 'k': 10, 'type': 'mild'},\n        {'S': 14142, 'alpha': 0.02, 'k': 10, 'type': 'severe'},\n        {'S': 17321, 'alpha': 0.02, 'k': 25, 'type': 'aggressive'}\n    ]\n    \n    m, n = 40, 30\n    p = 1.0\n    tau = 1e-2\n    \n    results = []\n\n    for case in test_cases:\n        S, alpha, k = case['S'], case['alpha'], case['k']\n        \n        # --- Operator and Data Construction ---\n        A_tr, U_tr_full, V_tr_full, sigma_base = build_A_and_factors(m, n, p, S + 1, S + 2)\n\n        if case['type'] == 'crime':\n            A_te = A_tr\n        elif case['type'] in ['mild', 'aggressive']:\n            eps_rot = 0.2\n            eps_sv = 0.02\n            \n            U_tilde = construct_orthogonal_matrix(m, S + 10)\n            U_te_unorth = U_tr_full + eps_rot * U_tilde\n            U_te_full, R_u = linalg.qr(U_te_unorth, mode='full')\n            U_te_full = U_te_full @ np.diag(np.sign(np.diag(R_u)))\n\n            V_tilde = construct_orthogonal_matrix(n, S + 20)\n            V_te_unorth = V_tr_full + eps_rot * V_tilde\n            V_te_full, R_v = linalg.qr(V_te_unorth, mode='full')\n            V_te_full = V_te_full @ np.diag(np.sign(np.diag(R_v)))\n            \n            rng_sv = np.random.default_rng(S + 30)\n            delta = rng_sv.uniform(-eps_sv, eps_sv, n)\n            sigma_te = sigma_base * (1 + delta)\n            \n            A_te = U_te_full[:, :n] @ np.diag(sigma_te) @ V_te_full.T\n        elif case['type'] == 'severe':\n            A_te, _, _, _ = build_A_and_factors(m, n, p, S + 1001, S + 1002)\n\n        x_true = construct_true_solution(n, S + 40)\n        \n        eta_tr = construct_noise_vector(A_tr, x_true, alpha, S + 50)\n        eta_te = construct_noise_vector(A_te, x_true, alpha, S + 60)\n        \n        b_tr = A_tr @ x_true + eta_tr\n        b_te = A_te @ x_true + eta_te\n        \n        # --- SVD Inversion ---\n        U_tr_svd, s_tr_svd, Vt_tr_svd = linalg.svd(A_tr, full_matrices=False)\n        \n        U_k = U_tr_svd[:, :k]\n        s_k_inv = 1.0 / s_tr_svd[:k]\n        V_k = Vt_tr_svd[:k, :].T\n        \n        x_k = V_k @ (np.diag(s_k_inv) @ (U_k.T @ b_tr))\n        \n        # --- Diagnostics Calculation ---\n        \n        # 1. Cross-validation gap ratio (rho)\n        resid_te_norm = np.linalg.norm(A_te @ x_k - b_te)\n        resid_tr_norm = np.linalg.norm(A_tr @ x_k - b_tr)\n        rho = resid_te_norm / resid_tr_norm if resid_tr_norm > 0 else np.inf\n        \n        # 2. Low-observability energy fraction (f_low)\n        _, s_te_svd, Vt_te_svd = linalg.svd(A_te, full_matrices=False)\n        V_te_svd = Vt_te_svd.T\n        \n        c = V_te_svd.T @ x_k \n        \n        threshold = tau * s_te_svd[0]\n        low_obs_indices = np.where(s_te_svd  threshold)[0]\n        \n        num = np.sum(c[low_obs_indices]**2)\n        den = np.sum(c**2)\n        f_low = num / den if den > 0 else 0.0\n\n        # 3. Relative operator discrepancy (d_A)\n        d_A = np.linalg.norm(A_te - A_tr, 'fro') / np.linalg.norm(A_tr, 'fro')\n        \n        results.extend([rho, f_low, d_A])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3401148"}, {"introduction": "奇异值分解为我们提供了一组描述系统可观测性的有序正交基（即奇异向量）。然而，当奇异值出现重合（或“退化”）时，对应的奇异向量子空间内的任何一组正交基都是有效的，这意味着分析方向并非唯一。本练习[@problem_id:3401170]通过一个精巧的数值实验，向您展示微小的模型扰动如何打破这种对称性，并从退化的子空间中“选择”出特定的方向。理解这一点对于正确解释SVD模式的物理意义至关重要。", "problem": "考虑一个线性反问题，其确定性观测算子由一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 表示。在反问题和数据同化的背景下，通常通过奇异值分解 (SVD) 来检验分析方向，即分解式 $A = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是对角矩阵，其对角线上的元素（奇异值）为非负。当奇异值重复出现时，相应的奇异向量在退化子空间内不是唯一的，这对主导分析方向的解释具有影响。\n\n你需要构建并分析一个表现出重复奇异值的特定实例，然后探究微小扰动如何打破对称性并改变分析方向。完全在 $\\mathbb{R}^{3 \\times 3}$ 空间中进行，并使用以下具有重复奇异值的基准矩阵：\n$$\nA = \\operatorname{diag}(2, 2, 1).\n$$\n该矩阵的奇异值为 $2$、$2$ 和 $1$，因此存在一个重复的奇异值 $2$，其对应的右奇异子空间是一个二维子空间（由前两个坐标轴张成）。定义扰动 $E^{(k)}$ 并考虑受扰矩阵 $A^{(k)} = A + E^{(k)}$。对每个 $A^{(k)}$，通过奇异值分解 (SVD) 计算其分析方向。研究这些方向如何响应扰动，并量化其几何变化。\n\n使用以下扰动测试集：\n- 测试用例 $1$（零扰动）：$E^{(1)} = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$。\n- 测试用例 $2$（小对称混合）：$E^{(2)} = \\begin{bmatrix} 0  \\delta_s  0 \\\\ \\delta_s  0  0 \\\\ 0  0  0 \\end{bmatrix}$，其中 $\\delta_s = 10^{-8}$。\n- 测试用例 $3$（中等对称混合）：$E^{(3)} = \\begin{bmatrix} 0  \\delta_m  0 \\\\ \\delta_m  0  0 \\\\ 0  0  0 \\end{bmatrix}$，其中 $\\delta_m = 10^{-2}$。\n- 测试用例 $4$（对角偏置）：$E^{(4)} = \\begin{bmatrix} \\epsilon  0  0 \\\\ 0  -\\epsilon  0 \\\\ 0  0  0 \\end{bmatrix}$，其中 $\\epsilon = 10^{-3}$。\n\n对每个测试用例 $k \\in \\{1,2,3,4\\}$：\n1. 计算 $A^{(k)}$ 的 SVD，得到 $A^{(k)} = U^{(k)} \\Sigma^{(k)} (V^{(k)})^\\top$，其中奇异值按非增顺序排列。\n2. 定义原始的退化右奇异子空间 $S = \\operatorname{span}\\{e_1, e_2\\}$，其中 $e_1 = (1,0,0)^\\top$ 且 $e_2 = (0,1,0)^\\top$。\n3. 设 $W^{(k)} = \\operatorname{span}\\{v^{(k)}_1, v^{(k)}_2\\}$，其中 $v^{(k)}_1$ 和 $v^{(k)}_2$ 是 $V^{(k)}$ 的前两列。计算 $S$ 和 $W^{(k)}$ 之间的两个主角，并以弧度为单位报告。\n4. 量化首个右奇异向量 $v^{(k)}_1$ 相对于两个参考方向的朝向：\n   - 相对于 $e_1$ 轴的角度 $\\phi^{(k)}_{e_1} = \\arccos(|\\langle v^{(k)}_1, e_1 \\rangle|)$。\n   - 相对于对角方向 $d = \\frac{1}{\\sqrt{2}} (1, 1, 0)^\\top$ 的角度 $\\phi^{(k)}_{\\text{diag}} = \\arccos(|\\langle v^{(k)}_1, d \\rangle|)$。\n   两个角度都必须以弧度表示。\n5. 确定 $A^{(k)}$ 的前两个奇异值是否在数值阈值 $\\tau = 10^{-7}$ 之外是不同的，即如果 $|\\sigma^{(k)}_1 - \\sigma^{(k)}_2|  \\tau$，则报告布尔值 $\\text{distinct}^{(k)}$ 为 $\\text{True}$，否则为 $\\text{False}$。\n\n你的程序必须为每个测试用例计算以下结果元组：\n- 布尔值 $\\text{distinct}^{(k)}$。\n- 一个包含 $S$ 和 $W^{(k)}$ 之间两个主角（以弧度为单位）的列表。\n- 浮点数角度 $\\phi^{(k)}_{e_1}$（以弧度为单位）。\n- 浮点数角度 $\\phi^{(k)}_{\\text{diag}}$（以弧度为单位）。\n\n所有角度必须以弧度为单位。不涉及任何物理单位。你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个按上述顺序排列的列表。例如，输出的形式应为 $[r_1, r_2, r_3, r_4]$，其中每个 $r_k$ 是一个列表 $[\\text{distinct}^{(k)}, [\\theta^{(k)}_1, \\theta^{(k)}_2], \\phi^{(k)}_{e_1}, \\phi^{(k)}_{\\text{diag}}]$。", "solution": "问题陈述已经过严格评估，并被确定为 **有效**。它在科学上基于线性代数的原理，特别是奇异值分解 (SVD) 及其在扰动分析中的应用。该问题是适定的，所有矩阵、参数和计算过程都得到了明确且无歧义的定义。它提出了一个标准的、有指导意义的数值实验，用以探索扰动对退化系统的影响，这是反问题和数据同化中的一个关键概念。所要求的计算是可形式化的，并且在计算上是可行的。\n\n该问题研究了当奇异值谱中的退化被微小扰动打破时，分析方向（由观测算子 $A$ 的右奇异向量表示）的行为。基准矩阵是 $A = \\operatorname{diag}(2, 2, 1)$，一个 $3 \\times 3$ 的实矩阵。\n$$\nA = \\begin{pmatrix} 2  0  0 \\\\ 0  2  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n它的奇异值为 $\\sigma_1 = 2$，$\\sigma_2 = 2$ 和 $\\sigma_3 = 1$。重复的奇异值 $\\sigma=2$ 对应一个二维的右奇异子空间 $S = \\text{span}\\{e_1, e_2\\}$，其中 $e_1 = (1, 0, 0)^\\top$ 和 $e_2 = (0, 1, 0)^\\top$ 是标准基向量。在此子空间内，任何一对正交归一的向量都构成了对应于奇异值 $2$ 的一组有效奇异向量。\n\n我们分析一系列扰动 $E^{(k)}$ 下的受扰矩阵 $A^{(k)} = A + E^{(k)}$。对每个 $A^{(k)}$，我们执行 SVD 分解，$A^{(k)} = U^{(k)} \\Sigma^{(k)} (V^{(k)})^\\top$，其中 $\\Sigma^{(k)}$ 对角线上的奇异值按非增序排列。然后我们分析由此产生的奇异值 $\\sigma_i^{(k)}$ 和右奇异向量 $v_i^{(k)}$（$V^{(k)}$ 的列向量）。\n\n分析包括两个主要部分：\n1.  **子空间稳定性**：我们评估受扰动的主导二维右奇异子空间 $W^{(k)} = \\operatorname{span}\\{v_1^{(k)}, v_2^{(k)}\\}$ 是否偏离了原始的退化子空间 $S$。这通过 $S$ 和 $W^{(k)}$ 之间主角来量化。主角的余弦是 $Q_S^\\top Q_{W^{(k)}}$ 的奇异值，其中 $Q_S$ 和 $Q_{W^{(k)}}$ 是其列向量构成相应子空间的正交归一基的矩阵。\n2.  **方向选择**：我们研究扰动如何在子空间内“选择”一个特定的基。这通过测量首个右奇异向量 $v_1^{(k)}$ 相对于 $S$ 内两个关键方向的朝向量化：$e_1$ 轴和对角方向 $d = \\frac{1}{\\sqrt{2}}(1, 1, 0)^\\top$。角度由 $\\phi_{e_1}^{(k)} = \\arccos(|\\langle v_1^{(k)}, e_1 \\rangle|)$ 和 $\\phi_{\\text{diag}}^{(k)} = \\arccos(|\\langle v_1^{(k)}, d \\rangle|)$ 给出。\n\n我们现在对每个测试用例进行分析。\n\n**测试用例 1：零扰动**\n$E^{(1)} = \\mathbf{0}$，所以 $A^{(1)} = A = \\operatorname{diag}(2, 2, 1)$。\n-   **奇异值**：奇异值精确为 $\\sigma_1^{(1)}=2$，$\\sigma_2^{(1)}=2$，$\\sigma_3^{(1)}=1$。差值 $|\\sigma_1^{(1)} - \\sigma_2^{(1)}| = 0$，不大于阈值 $\\tau=10^{-7}$。因此，$\\text{distinct}^{(1)}$ 为 $\\text{False}$。\n-   **奇异向量**：对于对角矩阵，一个标准的 SVD 算法通常返回标准基向量。因此，$V^{(1)} = I$，得到 $v_1^{(1)} = e_1$ 和 $v_2^{(1)} = e_2$。\n-   **主角**：受扰动的子空间是 $W^{(1)} = \\operatorname{span}\\{e_1, e_2\\} = S$。一个子空间与其自身的两个主角均为 $0$。\n-   **向量朝向**：对于 $v_1^{(1)} = e_1$，我们有 $\\phi_{e_1}^{(1)} = \\arccos(|\\langle e_1, e_1 \\rangle|) = \\arccos(1) = 0$ 弧度。与对角方向的角度为 $\\phi_{\\text{diag}}^{(1)} = \\arccos(|\\langle e_1, d \\rangle|) = \\arccos(1/\\sqrt{2}) = \\pi/4$ 弧度。\n\n**测试用例 2：小对称混合**\n$E^{(2)} = \\begin{pmatrix} 0  \\delta_s  0 \\\\ \\delta_s  0  0 \\end{pmatrix}$，其中 $\\delta_s = 10^{-8}$。\n$A^{(2)} = \\begin{pmatrix} 2  \\delta_s  0 \\\\ \\delta_s  2  0 \\\\ 0  0  1 \\end{pmatrix}$。该矩阵是对称且块对角的。奇异值是各块的特征值。$1 \\times 1$ 块给出 $\\sigma_3^{(2)} = 1$。左上角的 $2 \\times 2$ 块的特征值为 $2 \\pm \\delta_s$。\n-   **奇异值**：奇异值为 $\\sigma_1^{(2)} = 2+\\delta_s$，$\\sigma_2^{(2)} = 2-\\delta_s$，$\\sigma_3^{(2)} = 1$。差值为 $|\\sigma_1^{(2)} - \\sigma_2^{(2)}| = 2\\delta_s = 2 \\times 10^{-8}$。这不大于 $\\tau=10^{-7}$，所以 $\\text{distinct}^{(2)}$ 为 $\\text{False}$。\n-   **奇异向量**：对应于 $2 \\pm \\delta_s$ 的右奇异向量（即 $A^{(2)}$ 的特征向量）是 $\\frac{1}{\\sqrt{2}}(1, 1, 0)^\\top$ 和 $\\frac{1}{\\sqrt{2}}(1, -1, 0)^\\top$。按奇异值大小排序后，$v_1^{(2)} = \\frac{1}{\\sqrt{2}}(1, 1, 0)^\\top = d$ 且 $v_2^{(2)} = \\frac{1}{\\sqrt{2}}(1, -1, 0)^\\top$。\n-   **主角**：$W^{(2)} = \\operatorname{span}\\{v_1^{(2)}, v_2^{(2)}\\}$ 是 xy 平面，与 $S$ 相同。两个主角均为 $0$。\n-   **向量朝向**：对于 $v_1^{(2)} = d$，我们有 $\\phi_{e_1}^{(2)} = \\arccos(|\\langle d, e_1 \\rangle|) = \\arccos(1/\\sqrt{2}) = \\pi/4$ 弧度。与对角方向的角度为 $\\phi_{\\text{diag}}^{(2)} = \\arccos(|\\langle d, d \\rangle|) = \\arccos(1) = 0$ 弧度。\n\n**测试用例 3：中等对称混合**\n此用例在形式上与用例 2 相同，但 $\\delta_m = 10^{-2}$。\n$A^{(3)} = \\begin{pmatrix} 2  \\delta_m  0 \\\\ \\delta_m  2  0 \\\\ 0  0  1 \\end{pmatrix}$。\n-   **奇异值**：$\\sigma_1^{(3)} = 2+\\delta_m$，$\\sigma_2^{(3)} = 2-\\delta_m$，$\\sigma_3^{(3)} = 1$。差值为 $|\\sigma_1^{(3)} - \\sigma_2^{(3)}| = 2\\delta_m = 2 \\times 10^{-2}$。这大于 $\\tau=10^{-7}$，所以 $\\text{distinct}^{(3)}$ 为 $\\text{True}$。\n-   **奇异向量**：结构与用例 2 相同。$v_1^{(3)} = \\frac{1}{\\sqrt{2}}(1, 1, 0)^\\top = d$。\n-   **主角**：如前所述，$W^{(3)} = S$，所以两个主角均为 $0$。\n-   **向量朝向**：与用例 2 相同：$\\phi_{e_1}^{(3)} = \\pi/4$ 弧度，$\\phi_{\\text{diag}}^{(3)} = 0$ 弧度。对称的非对角扰动选择了对角方向作为主导分析方向，这与扰动的大小无关（只要其非零）。\n\n**测试用例 4：对角偏置**\n$E^{(4)} = \\begin{pmatrix} \\epsilon  0  0 \\\\ 0  -\\epsilon  0 \\\\ 0  0  0 \\end{pmatrix}$，其中 $\\epsilon = 10^{-3}$。\n$A^{(4)} = \\operatorname{diag}(2+\\epsilon, 2-\\epsilon, 1)$。该矩阵已经是- 对角矩阵。\n-   **奇异值**：奇异值是排序后的对角元素：$\\sigma_1^{(4)} = 2+\\epsilon$，$\\sigma_2^{(4)} = 2-\\epsilon$，$\\sigma_3^{(4)} = 1$。差值为 $|\\sigma_1^{(4)} - \\sigma_2^{(4)}| = 2\\epsilon = 2 \\times 10^{-3}$，大于 $\\tau=10^{-7}$。因此，$\\text{distinct}^{(4)}$ 为 $\\text{True}$。\n-   **奇异向量**：对角矩阵的 SVD 给出 $V^{(4)}=I$。因此，$v_1^{(4)} = e_1$ 且 $v_2^{(4)} = e_2$。\n-   **主角**：$W^{(4)} = \\operatorname{span}\\{e_1, e_2\\} = S$。两个主角均为 $0$。\n-   **向量朝向**：对于 $v_1^{(4)}=e_1$，分析与用例 1 相同：$\\phi_{e_1}^{(4)} = 0$ 弧度，$\\phi_{\\text{diag}}^{(4)} = \\pi/4$ 弧度。对角扰动加强了标准轴作为偏好方向。\n\n在所有用例中，扰动的构造使得受扰动的主导子空间 $W^{(k)}$ 与原始子空间 $S$ 保持相同。因此，主角始终为零（或由于浮点运算而接近于零）。关键的变化是在该子空间*内部*基向量的旋转。对称的非对角扰动选择了方向 $(\\pm 1, 1, 0)/\\sqrt{2}$，而对角扰动则选择了标准基方向 $(1, 0, 0)$ 和 $(0, 1, 0)$。\n\n现在将构建一个数值程序来精确计算这些量。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import subspace_angles\n\ndef solve():\n    \"\"\"\n    Solves the matrix perturbation problem for four test cases.\n    \"\"\"\n\n    # Define the base matrix with a repeated singular value.\n    A_base = np.diag([2.0, 2.0, 1.0])\n\n    # Define test parameters\n    delta_s = 1e-8\n    delta_m = 1e-2\n    epsilon = 1e-3\n    tau = 1e-7\n\n    # Define the test suite of perturbation matrices.\n    test_perturbations = [\n        # Case 1: Zero perturbation\n        np.zeros((3, 3)),\n        # Case 2: Small symmetric mixing\n        np.array([[0, delta_s, 0], [delta_s, 0, 0], [0, 0, 0]]),\n        # Case 3: Moderate symmetric mixing\n        np.array([[0, delta_m, 0], [delta_m, 0, 0], [0, 0, 0]]),\n        # Case 4: Diagonal bias\n        np.array([[epsilon, 0, 0], [0, -epsilon, 0], [0, 0, 0]])\n    ]\n\n    # Define reference subspace and vectors for analysis\n    # S = span{e1, e2}\n    Q_S = np.eye(3)[:, :2]\n    # e1 axis\n    e1 = np.array([1.0, 0.0, 0.0])\n    # Diagonal direction in the S subspace\n    d_diag = np.array([1.0, 1.0, 0.0]) / np.sqrt(2)\n\n    results = []\n\n    for E_k in test_perturbations:\n        # 1. Form the perturbed matrix and compute its SVD.\n        A_k = A_base + E_k\n        _U_k, s_k, Vh_k = np.linalg.svd(A_k)\n        V_k = Vh_k.T\n        \n        # Ensure singular vectors have a deterministic orientation for reproducibility.\n        # This step canonicalizes the basis by ensuring the element with the largest\n        # absolute value in each vector is positive. For vectors like [1/sqrt(2), 1/sqrt(2)],\n        # it ensures consistency.\n        for j in range(V_k.shape[1]):\n            max_abs_idx = np.argmax(np.abs(V_k[:, j]))\n            if V_k[max_abs_idx, j]  0:\n                V_k[:, j] *= -1\n\n        # 2. Extract top two singular values and check if they are distinct.\n        sigma1_k, sigma2_k = s_k[0], s_k[1]\n        distinct_k = np.abs(sigma1_k - sigma2_k) > tau\n\n        # 3. Compute principal angles between S and W_k.\n        # W_k = span{v1_k, v2_k}\n        Q_Wk = V_k[:, :2]\n        principal_angles_k = subspace_angles(Q_S, Q_Wk)\n        \n        # 4. Extract leading right singular vector v1_k\n        v1_k = V_k[:, 0]\n\n        # 5. Quantify orientation of v1_k.\n        # Angle with e1 axis\n        phi_e1_k = np.arccos(np.clip(np.abs(np.dot(v1_k, e1)), -1.0, 1.0))\n        # Angle with diagonal direction d\n        phi_diag_k = np.arccos(np.clip(np.abs(np.dot(v1_k, d_diag)), -1.0, 1.0))\n        \n        # 6. Assemble the results for the current test case.\n        case_result = [\n            distinct_k,\n            list(principal_angles_k),\n            phi_e1_k,\n            phi_diag_k\n        ]\n        results.append(case_result)\n\n    # Format the final output as specified.\n    # The default string representation of lists matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3401170"}]}