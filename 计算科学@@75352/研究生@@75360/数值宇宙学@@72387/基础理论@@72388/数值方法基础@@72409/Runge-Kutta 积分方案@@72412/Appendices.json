{"hands_on_practices": [{"introduction": "要精通数值积分，不仅要会用现成的算法，更要深刻理解其误差的来源和行为。本练习将引导你运用后向误差分析这一强大工具，推导经典四阶龙格-库塔方法（RK4）在一个简化的宇宙学模型中所满足的“修正方程”。通过这项实践，你将学会如何从理论上估算数值解在长时间积分后与真实解之间的系统性偏差，这对于评估和预测模拟的长期保真度至关重要。[@problem_id:3484645]", "problem": "考虑一个空间平坦的Λ冷暗物质（ΛCDM）宇宙学模型，其尺度因子$a(t)$遵循弗里德曼方程，形式为$\\dot{a}(t)=H(a)\\,a(t)$，其中$H(a)=H_{0}\\sqrt{\\Omega_{m}a^{-3}+\\Omega_{\\Lambda}}$，$H_{0}0$是当前的哈勃参数，$\\Omega_{m}\\ge 0$是物质密度参数，$\\Omega_{\\Lambda}\\ge 0$是宇宙学常数密度参数。设e-fold变量为$N(t)=\\ln a(t)$，因此$\\dot{N}(t)=H(a(t))$。考虑使用经典的四阶龙格-库塔（RK4）方法，以均匀步长$h0$在宇宙时$t$中推进$a(t)$。\n\n关注一个持续时间足够长的晚期时间区间，在此期间宇宙学常数占主导地位，即在整个区间内$\\Omega_{m}\\exp(-3N)\\ll \\Omega_{\\Lambda}$，从而累积了$\\Delta N=10$个e-folds。在此机制下，取$H(a)\\approx H_{\\Lambda}$，其中$H_{\\Lambda}=H_{0}\\sqrt{\\Omega_{\\Lambda}}$为常数，因此演化有效地变为$\\dot{a}=H_{\\Lambda}\\,a$。\n\n从第一性原理出发，对应用于标量线性常微分方程$\\dot{y}=\\lambda\\,y$（其中$\\lambda$为常数）的RK4方法进行后向误差分析，并确定修正方程（其精确流与一个RK4步长相匹配的自治微分方程）中直到$h^4$阶的领头非零修正项。将您的结果特化到$\\lambda=H_{\\Lambda}$的情况，将修正方程转化为$N(t)=\\ln a(t)$的漂移，并用它来获得在真实解恰好经历$\\Delta N=10$个e-folds的区间内，累积e-folds的领头阶长时间偏差。最后，给出一个关于$h$、$H_{0}$和$\\Omega_{\\Lambda}$的领头阶偏差$\\Delta N_{\\mathrm{bias}}=N_{\\mathrm{RK4}}-10$的封闭形式表达式。\n\n将您的最终结果表示为单个关于$h$、$H_{0}$和$\\Omega_{\\Lambda}$的封闭形式解析表达式。不包括单位。无需数值四舍五入。", "solution": "用户希望在使用RK4方法对宇宙学常数主导区域的弗里德曼方程进行数值积分时，找到累积e-folds的领头阶偏差。这需要进行后向误差分析。\n\n### 第一步：问题验证\n\n我将首先提取给定条件并验证问题陈述。\n\n**给定条件：**\n1.  **宇宙学**：空间平坦的Λ冷暗物质（ΛCDM）模型。\n2.  **运动方程**：尺度因子$a(t)$根据弗里德曼方程$\\dot{a}(t)=H(a)\\,a(t)$演化。\n3.  **哈勃参数**：$H(a)=H_{0}\\sqrt{\\Omega_{m}a^{-3}+\\Omega_{\\Lambda}}$，参数为$H_{0}0$、$\\Omega_{m}\\ge 0$和$\\Omega_{\\Lambda}\\ge 0$。由于宇宙是平坦的，$\\Omega_m + \\Omega_\\Lambda = 1$。\n4.  **E-fold变量**：$N(t)=\\ln a(t)$，这意味着$\\dot{N}(t)=H(a(t))$。\n5.  **数值方法**：经典的四阶龙格-库塔（RK4）方法，均匀步长$h0$。\n6.  **物理机制**：晚期演化，其中宇宙学常数占主导，即$\\Omega_{m}\\exp(-3N)\\ll \\Omega_{\\Lambda}$。\n7.  **近似**：在此机制下，哈勃参数近似为常数，$H(a)\\approx H_{\\Lambda}$，其中$H_{\\Lambda}=H_{0}\\sqrt{\\Omega_{\\Lambda}}$。\n8.  **有效常微分方程（ODE）**：尺度因子的演化由线性常微分方程$\\dot{a}=H_{\\Lambda}\\,a$描述。\n9.  **任务1**：对泛型标量线性ODE $\\dot{y}=\\lambda\\,y$（$\\lambda$为常数）进行后向误差分析。\n10. **任务2**：确定修正方程中直到$h^{4}$阶的领头非零修正项。\n11. **任务3**：通过设置$\\lambda=H_{\\Lambda}$将结果特化到宇宙学情况。\n12. **任务4**：将$a(t)$的修正方程转化为$N(t)$的修正演化方程。\n13. **任务5**：计算在真实解累积恰好$\\Delta N=10$个e-folds的区间上的领头阶长时间偏差$\\Delta N_{\\mathrm{bias}}=N_{\\mathrm{RK4}}-10$。\n14. **最终结果**：偏差应为关于$h$、$H_{0}$和$\\Omega_{\\Lambda}$的封闭形式表达式。\n\n**验证结论：**\n该问题具有科学依据，基于标准的ΛCDM模型和标准的数值分析技术（RK4的后向误差分析）。在晚期、$\\Omega_\\Lambda$主导的宇宙中将哈勃参数近似为常数，是标准且有效的简化方法。问题陈述清晰，目标明确，并有结构化的解决路径。语言精确客观。所有必要信息均已提供，没有内部矛盾。该问题是数值宇宙学中一个有效的理论练习。因此，我将继续进行求解。\n\n### 第二步：对$\\dot{y} = \\lambda y$进行RK4后向误差分析\n\n问题要求从第一性原理出发，对ODE $\\dot{y}=\\lambda y$进行后向误差分析。经典RK4方法从$y_n = y(t_n)$到$y_{n+1} = y(t_n+h)$的单步计算由下式给出\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n其中，对于函数$f(y)=\\lambda y$，阶段$k_i$为：\n$$k_1 = f(y_n) = \\lambda y_n$$\n$$k_2 = f(y_n + \\frac{h}{2}k_1) = \\lambda(y_n + \\frac{h}{2}\\lambda y_n) = \\lambda y_n (1 + \\frac{h\\lambda}{2})$$\n$$k_3 = f(y_n + \\frac{h}{2}k_2) = \\lambda(y_n + \\frac{h}{2}\\lambda y_n(1 + \\frac{h\\lambda}{2})) = \\lambda y_n (1 + \\frac{h\\lambda}{2} + \\frac{h^2\\lambda^2}{4})$$\n$$k_4 = f(y_n + hk_3) = \\lambda(y_n + h\\lambda y_n(1 + \\frac{h\\lambda}{2} + \\frac{h^2\\lambda^2}{4})) = \\lambda y_n (1 + h\\lambda + \\frac{h^2\\lambda^2}{2} + \\frac{h^3\\lambda^3}{4})$$\n将这些代入RK4公式：\n$$y_{n+1} = y_n + \\frac{h\\lambda y_n}{6} \\left[ 1 + 2(1+\\frac{h\\lambda}{2}) + 2(1+\\frac{h\\lambda}{2}+\\frac{h^2\\lambda^2}{4}) + (1+h\\lambda+\\frac{h^2\\lambda^2}{2}+\\frac{h^3\\lambda^3}{4}) \\right]$$\n按$h\\lambda$的幂次合并项：\n$$y_{n+1} = y_n + \\frac{h\\lambda y_n}{6} \\left[ (1+2+2+1) + (1+1+1)h\\lambda + (\\frac{1}{2}+\\frac{1}{2})h^2\\lambda^2 + \\frac{1}{4}h^3\\lambda^3 \\right]$$\n$$y_{n+1} = y_n + \\frac{h\\lambda y_n}{6} \\left[ 6 + 3h\\lambda + h^2\\lambda^2 + \\frac{1}{4}h^3\\lambda^3 \\right]$$\n$$y_{n+1} = y_n + \\left( h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24} \\right) y_n$$\n所以，单步更新为$y_{n+1} = R(h\\lambda) y_n$，其中$R(z)$是RK4方法的稳定性函数：\n$$R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$$\n这个表达式是$\\exp(z)$在$z^4$项截断的泰勒级数。\n\n后向误差分析旨在寻找一个修正的微分方程$\\dot{\\tilde{y}} = \\tilde{f}(\\tilde{y})$，其在一个步长$h$后的精确解与数值解重合。对于我们的线性问题，我们假设修正方程的形式为$\\dot{\\tilde{y}} = \\tilde{\\lambda}\\tilde{y}$。该方程的精确解是$\\tilde{y}(t+h) = \\exp(h\\tilde{\\lambda})\\tilde{y}(t)$。\n将修正方程的精确流与数值单步映射等同，我们得到：\n$$\\exp(h\\tilde{\\lambda}) = R(h\\lambda) = 1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24}$$\n为求得$\\tilde{\\lambda}$，我们对两边取自然对数：\n$$h\\tilde{\\lambda} = \\ln\\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24}\\right)$$\n对数内的表达式可以与$\\exp(h\\lambda)$相关联：\n$$\\exp(h\\lambda) = 1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{6} + \\frac{(h\\lambda)^4}{24} + \\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)$$\n所以，$R(h\\lambda) = \\exp(h\\lambda) - \\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)$。\n将此代入$h\\tilde{\\lambda}$的方程中：\n$$h\\tilde{\\lambda} = \\ln\\left(\\exp(h\\lambda) - \\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)\\right) = \\ln\\left(\\exp(h\\lambda)\\left[1 - \\exp(-h\\lambda)\\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)\\right]\\right)$$\n$$h\\tilde{\\lambda} = h\\lambda + \\ln\\left(1 - \\exp(-h\\lambda)\\frac{(h\\lambda)^5}{120} + \\mathcal{O}(h^6)\\right)$$\n使用泰勒级数$\\ln(1-u) = -u - \\frac{u^2}{2} - \\dots$，并仅保留$h$的领头项：\n$$h\\tilde{\\lambda} \\approx h\\lambda - \\exp(-h\\lambda)\\frac{(h\\lambda)^5}{120}$$\n对于领头阶修正，我们可以近似$\\exp(-h\\lambda) \\approx 1$。\n$$h\\tilde{\\lambda} \\approx h\\lambda - \\frac{(h\\lambda)^5}{120}$$\n两边除以$h$，我们找到修正后的速率$\\tilde{\\lambda}$：\n$$\\tilde{\\lambda} = \\lambda - \\frac{\\lambda^5 h^4}{120} + \\mathcal{O}(h^5)$$\n因此，修正方程为：\n$$\\dot{\\tilde{y}} = \\left(\\lambda - \\frac{\\lambda^5 h^4}{120}\\right)\\tilde{y}$$\n修正方程中的领头非零修正项是$-\\frac{\\lambda^5 h^4}{120}\\tilde{y}$。这是$h^4$阶的，符合四阶方法的预期。\n\n### 第三步：应用于宇宙学问题\n\n在$\\Omega_\\Lambda$主导的区域，尺度因子的方程是$\\dot{a} = H_\\Lambda a$。这与$\\dot{y} = \\lambda y$的形式相匹配，其中$y \\to a$，$\\lambda \\to H_\\Lambda = H_0\\sqrt{\\Omega_\\Lambda}$。\n尺度因子的修正方程，记为$a_{\\text{mod}}$，是：\n$$\\dot{a}_{\\text{mod}} = \\left(H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}\\right)a_{\\text{mod}}$$\n数值解$a_{\\text{RK4}}$由$a_{\\text{mod}}$伴随。\n\n### 第四步：累积e-folds中的偏差\n\ne-folds的数量是$N(t) = \\ln a(t)$。e-folds的变化率是$\\dot{N}(t) = \\dot{a}(t)/a(t)$。\n对于真实解，该速率是恒定的：\n$$\\dot{N}_{\\text{true}} = \\frac{\\dot{a}}{a} = H_\\Lambda$$\n对于由修正方程描述的数值解，有效速率也是恒定的：\n$$\\dot{N}_{\\text{RK4}} = \\frac{\\dot{a}_{\\text{mod}}}{a_{\\text{mod}}} = H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}$$\n问题考虑了一个宇宙时区间$T=t_f-t_i$，在此期间，真实解恰好累积了$\\Delta N = 10$个e-folds。这定义了积分的时长：\n$$\\Delta N_{\\text{true}} = \\int_{t_i}^{t_f} \\dot{N}_{\\text{true}} dt = H_\\Lambda T = 10$$\n$$T = \\frac{10}{H_\\Lambda}$$\n在同样的时间间隔$T$内，数值解累积的e-folds为：\n$$\\Delta N_{\\text{RK4}} = \\int_{t_i}^{t_f} \\dot{N}_{\\text{RK4}} dt = \\left(H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}\\right)T$$\n代入$T = 10/H_\\Lambda$：\n$$\\Delta N_{\\text{RK4}} = \\left(H_\\Lambda - \\frac{H_\\Lambda^5 h^4}{120}\\right)\\frac{10}{H_\\Lambda} = 10\\left(1 - \\frac{H_\\Lambda^4 h^4}{120}\\right) = 10 - \\frac{10 H_\\Lambda^4 h^4}{120} = 10 - \\frac{H_\\Lambda^4 h^4}{12}$$\n领头阶偏差定义为$\\Delta N_{\\text{bias}} = \\Delta N_{\\text{RK4}} - 10$。\n$$\\Delta N_{\\text{bias}} = \\left(10 - \\frac{H_\\Lambda^4 h^4}{12}\\right) - 10 = -\\frac{H_\\Lambda^4 h^4}{12}$$\n\n### 第五步：最终表达式\n\n最后一步是用给定的参数$h$、$H_0$和$\\Omega_\\Lambda$来表示偏差。我们代入$H_\\Lambda = H_0 \\sqrt{\\Omega_\\Lambda}$：\n$$H_\\Lambda^4 = \\left(H_0 \\sqrt{\\Omega_\\Lambda}\\right)^4 = H_0^4 (\\Omega_\\Lambda^{1/2})^4 = H_0^4 \\Omega_\\Lambda^2$$\n将此代入偏差的表达式中：\n$$\\Delta N_{\\text{bias}} = -\\frac{(H_0^4 \\Omega_\\Lambda^2) h^4}{12} = -\\frac{H_0^4 \\Omega_\\Lambda^2 h^4}{12}$$\n这就是领头阶偏差的最终封闭形式表达式。负号表示RK4方法在此应用中，相对于真实解的膨胀率，倾向于在固定的时间间隔内系统性地低估e-folds的数量。\n该分析证实了RK4方法表现出$h^4$阶的领头偏差，这与其作为四阶精度积分器的地位是一致的。", "answer": "$$\\boxed{-\\frac{H_0^4 \\Omega_\\Lambda^2 h^4}{12}}$$", "id": "3484645"}, {"introduction": "物理定律常常以约束条件的形式出现，例如能量守恒定律，而标准数值方法在离散化过程中可能会违背这些约束，导致结果不符合物理规律。本练习聚焦于宇宙学中最核心的约束之一——弗里德曼方程 $H^2 = \\frac{8\\pi G}{3} \\rho$，并要求你设计和比较几种不同的龙格-库塔方案来保持该约束。通过对比简单的“投影法”和更精密的“级约束法”，你将获得处理约束性微分方程系统的宝贵实践经验。[@problem_id:3484652]", "problem": "考虑一个在广义相对论（General Relativity, GR）框架下演化的空间平坦的 Friedmann–Lemaître–Robertson–Walker（FLRW）宇宙学模型，其中包含一种具有恒定物态方程参数 $w$ 的理想流体，该参数由压力 $p$ 和能量密度 $\\rho$ 之间的关系式 $p = w \\rho$ 定义。哈勃参数 $H$ 定义为 $H = \\dot{a}/a$，其中 $a$ 是宇宙学尺度因子。在此背景下，动力学演化由两个常微分方程决定，这两个方程是从适用于 FLRW 对称性的爱因斯坦场方程和应力-能量守恒推导出来的：\n- Raychaudhuri 方程：$\\dot{H} = -4 \\pi G \\left( \\rho + p \\right)$。\n- 连续性方程：$\\dot{\\rho} = -3 H \\left( \\rho + p \\right)$。\n对于恒定的物态方程参数 $w$，这些方程简化为：\n$\\dot{H} = -4 \\pi G (1+w) \\rho$ 和 $\\dot{\\rho} = -3 (1+w) H \\rho$。\n这些方程蕴含了空间平坦且宇宙学常数为零时的 Friedmann 约束：\n$H^2 = \\dfrac{8\\pi G}{3} \\rho$，\n我们将其记为完整约束 $g(H,\\rho) = H^2 - \\alpha \\rho = 0$，其中 $\\alpha := \\dfrac{8\\pi G}{3}$。\n\n本数值任务是设计显式 Runge–Kutta (RK) 时间积分格式，其目标是在从满足约束的初始数据出发、从 $t=0$ 步进到最终时间 $t=T$ 的过程中，在数值上保持该约束。应实现并比较两种方法：\n- 一种阶段约束 RK 格式，该格式通过与 RK 各阶段耦合的离散拉格朗日乘子来增广系统的一个分量，以强制每个阶段在阶段性约束导数为零的意义上满足约束。\n- 一种步后投影格式，该格式执行一个标准的 RK 步，然后在每一步结束时将结果投影回约束流形 $g(H,\\rho)=0$ 上。\n\n从上述 Raychaudhuri 方程和连续性方程以及 Friedmann 约束 $H^2 = \\dfrac{8\\pi G}{3} \\rho$ 的基本体系出发，根据第一性原理推导一种适用于显式 Runge–Kutta 方法的离散拉格朗日乘子强制策略。您的设计必须确保在每个 RK 阶段，通过仅使用特定于阶段的离散拉格朗日乘子修改 $\\dot{\\rho}$ 分量，使得从阶段值计算出的瞬时约束漂移 $dg/dt$ 恒等于零。使用经典的 4 阶段 4 阶 Runge–Kutta 方法实现阶段约束格式和步后投影格式，并比较它们在保持约束方面的有效性。\n\n在所有计算中，使用光速满足 $c=1$ 的单位制。引力常数 $G$ 应被视为一个正常数，并根据测试套件中的规定进行数值设置。需要报告的诊断量是所有步末端点上的最大相对约束残差，\n$r = \\max_{n} \\dfrac{\\left| H_n^2 - \\alpha \\rho_n \\right|}{\\left| H_n^2 \\right| + \\left| \\alpha \\rho_n \\right|}$，\n该值是无量纲的，因此最终答案中无需物理单位。此处，$H_n$ 和 $\\rho_n$ 是第 $n$ 步结束时的数值，且 $\\alpha = \\dfrac{8\\pi G}{3}$。\n\n您的程序必须实现这两种格式，并为每个测试用例报告一个包含三个浮点数的列表，分别对应：\n$[$阶段约束 RK 的最大相对约束残差$, $步后投影 RK 的最大相对约束残差$, $无约束的普通 RK 的最大相对约束残差$]$。\n\n测试套件：\n- 用例 A（正常路径，尘埃流体）：$w=0$, $G=1$, $H_0=1$, $T=1$, $N=50$ 步。\n- 用例 B（辐射，较粗的步长）：$w=\\dfrac{1}{3}$, $G=1$, $H_0=1$, $T=1$, $N=20$ 步。\n- 用例 C（大的初始膨胀率）：$w=0$, $G=1$, $H_0=10$, $T=0.1$, $N=100$ 步。\n- 用例 D（接近边界的小膨胀率）：$w=0$, $G=1$, $H_0=10^{-3}$, $T=1$, $N=100$ 步。\n\n在所有用例中，使用约束 $\\rho_0 = \\dfrac{H_0^2}{\\alpha}$ 初始化 $\\rho_0$，并使用指定的步数向前积分。您的程序应生成单行输出，其中包含一个由逗号分隔的列表，并用方括号括起来，每个测试用例一个子列表，按 A、B、C、D 的顺序排列。例如，输出格式应如下所示：$[[x_A,y_A,z_A],[x_B,y_B,z_B],[x_C,y_C,z_C],[x_D,y_D,z_D]]$，其中每个 $x,y,z$ 是一个浮点数。", "solution": "该问题是有效的。它在科学上是合理的，内容自洽且良定，描述了计算宇宙学中的一个标准数值练习。我们将着手推导和实现指定的数值格式。\n\n所考虑的动力学系统描述了一个包含理想流体的平坦 FLRW 宇宙的演化。系统的状态由向量 $y(t) = [H(t), \\rho(t)]^T$ 给出，其中 $H$ 是哈勃参数，$\\rho$ 是能量密度。其演化由以下常微分方程（ODE）系统决定：\n$$\n\\dot{H} = -4 \\pi G (1+w) \\rho =: f_H(H, \\rho)\n$$\n$$\n\\dot{\\rho} = -3 (1+w) H \\rho =: f_\\rho(H, \\rho)\n$$\n其中 $w$ 是恒定的物态方程参数，$G$ 是引力常数。\n\n该常微分方程系统拥有一个完整约束，这是一个状态变量必须始终满足的代数关系。这就是平坦宇宙的 Friedmann 方程：\n$$\ng(H, \\rho) = H^2 - \\alpha \\rho = 0\n$$\n其中 $\\alpha := \\dfrac{8\\pi G}{3}$。从满足 $g(H_0, \\rho_0) = 0$ 的初始状态 $(H_0, \\rho_0)$ 出发的常微分方程的解析解，将在所有后续时间 $t  0$ 满足 $g(H(t), \\rho(t)) = 0$。这可以通过计算约束的时间导数来验证：\n$$\n\\frac{dg}{dt} = \\frac{\\partial g}{\\partial H}\\dot{H} + \\frac{\\partial g}{\\partial \\rho}\\dot{\\rho} = (2H)f_H + (-\\alpha)f_\\rho\n$$\n代入 $f_H$、$f_\\rho$ 和 $\\alpha$ 的表达式：\n$$\n\\frac{dg}{dt} = 2H(-4 \\pi G (1+w) \\rho) - \\left(\\frac{8\\pi G}{3}\\right)(-3 (1+w) H \\rho) = -8\\pi G (1+w) H \\rho + 8\\pi G (1+w) H \\rho = 0\n$$\n这证实了约束流形 $g=0$ 是流的一个不变流形。然而，像 Runge-Kutta 方法这样的标准数值积分器会在每一步引入离散化误差，导致数值解偏离此流形。本任务是实现并比较三种格式在控制这种约束违背方面的能力。所有格式的基础积分器都是经典的 4 阶段 4 阶 Runge-Kutta (RK4) 方法。\n\n令 $y_n = [H_n, \\rho_n]^T$ 为时间 $t_n$ 时的数值解，并假设其满足约束，即 $g(y_n)=0$。单步计算将在时间 $t_{n+1} = t_n + \\Delta t$ 时的解 $y_{n+1}$。\n\n**1. 普通 RK4 格式（基准）**\n这是对常微分方程系统 $\\dot{y} = f(y)$ 标准的、未经校正的 RK4 算法应用。\n$$\nk_1 = f(y_n) \\\\\nk_2 = f(y_n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 = f(y_n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 = f(y_n + \\Delta t k_3) \\\\\ny_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\n得到的状态 $y_{n+1}$ 通常不满足约束，即 $g(y_{n+1}) \\neq 0$。该格式作为一个基准，用于衡量约束违背的增长。\n\n**2. 步后投影 RK4 格式**\n此方法包含两部分：一个演化步和一个投影步。\n首先，使用上述的普通 RK4 步计算一个临时状态 $\\tilde{y}_{n+1}$。\n$$\n\\tilde{y}_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\n这个临时状态 $[\\tilde{H}_{n+1}, \\tilde{\\rho}_{n+1}]^T$ 将不位于约束流形上。其次，将该状态投影回流形 $g=0$ 以获得最终状态 $y_{n+1}$。我们采用一种简单直接的投影：保留计算出的哈勃参数值 $\\tilde{H}_{n+1}$，并校正密度 $\\rho$ 以满足约束。\n$$\nH_{n+1} = \\tilde{H}_{n+1} \\\\\n\\rho_{n+1} = \\frac{H_{n+1}^2}{\\alpha}\n$$\n这通过构造确保了 $g(y_{n+1}) = H_{n+1}^2 - \\alpha\\rho_{n+1} = 0$，在机器浮点精度范围内成立。\n\n**3. 阶段约束 RK4 格式**\n该格式修改了 RK 阶段内的动力学，以主动抑制约束违背。问题指定只修改右手侧（RHS）向量场 $f=[f_H, f_\\rho]^T$ 的 $\\dot{\\rho}$ 分量，以确保阶段性约束导数为零。\n\n在每个 RK 阶段 $i$，我们计算一个状态值 $Y_i = [H^{(i)}, \\rho^{(i)}]^T$。目标是定义一个修正后的 RHS $\\tilde{f}^{(i)}$，使得使用此修正后的 RHS 在阶段值上计算的约束导数为零：\n$$\n\\left.\\frac{dg}{dt}\\right|_{\\text{stage }i} = \\nabla g(Y_i) \\cdot \\tilde{f}^{(i)}(Y_i) = 0\n$$\nRHS 通过仅向 $\\rho$ 分量添加一个特定于阶段的拉格朗日乘子 $\\lambda_i$ 来进行修正：\n$$\n\\tilde{f}^{(i)}(Y_i) = [f_H(Y_i), f_\\rho(Y_i) + \\lambda_i]^T\n$$\n条件变为：\n$$\n\\frac{\\partial g}{\\partial H}(Y_i) \\cdot f_H(Y_i) + \\frac{\\partial g}{\\partial \\rho}(Y_i) \\cdot (f_\\rho(Y_i) + \\lambda_i) = 0\n$$\n代入 $\\frac{\\partial g}{\\partial H} = 2H$ 和 $\\frac{\\partial g}{\\partial \\rho} = -\\alpha$，我们得到：\n$$\n2H^{(i)} f_H(Y_i) - \\alpha (f_rho(Y_i) + \\lambda_i) = 0\n$$\n求解拉格朗日乘子 $\\lambda_i$：\n$$\n\\lambda_i = \\frac{2H^{(i)} f_H(Y_i) - \\alpha f_\\rho(Y_i)}{\\alpha}\n$$\n分子恰好是未校正的约束漂移率 $\\nabla g(Y_i) \\cdot f(Y_i)$。因此，$\\rho$ 分量的修正后 RHS 为 $\\tilde{f}_\\rho(Y_i) = f_\\rho(Y_i) + \\lambda_i = \\frac{2H^{(i)}}{\\alpha} f_H(Y_i)$。\n\n于是，RK4 算法被修改如下：\n令 $y_n = [H_n, \\rho_n]^T$ 为 $t_n$ 时的状态。\n\n- **阶段 1**：阶段值为 $Y_1 = y_n$。由于 $y_n$ 满足约束，未校正的漂移 $\\nabla g(y_n) \\cdot f(y_n) = 0$。因此 $\\lambda_1 = 0$。第一个斜率使用原始的 RHS 计算：\n$k_1 = f(y_n)$。\n\n- **阶段 2**：阶段值为 $Y_2 = y_n + \\frac{\\Delta t}{2} k_1$。通常情况下，$g(Y_2) \\neq 0$。我们计算修正后的斜率 $k_2$：\n$H^{(2)}, \\rho^{(2)} = Y_2$\n$f_H(Y_2) = -4\\pi G(1+w)\\rho^{(2)}$\n$f_\\rho(Y_2) = -3(1+w)H^{(2)}\\rho^{(2)}$\n$\\lambda_2 = (2H^{(2)}f_H(Y_2) - \\alpha f_\\rho(Y_2)) / \\alpha$\n$k_2 = [f_H(Y_2), f_\\rho(Y_2) + \\lambda_2]^T$。\n\n- **阶段 3**：阶段值为 $Y_3 = y_n + \\frac{\\Delta t}{2} k_2$。我们使用相同的步骤计算修正后的斜率 $k_3$：\n$Y_3 = [H^{(3)}, \\rho^{(3)}]^T$\n$\\lambda_3 = (2H^{(3)}f_H(Y_3) - \\alpha f_\\rho(Y_3)) / \\alpha$\n$k_3 = [f_H(Y_3), f_\\rho(Y_3) + \\lambda_3]^T$。\n\n- **阶段 4**：阶段值为 $Y_4 = y_n + \\Delta t k_3$。我们计算修正后的斜率 $k_4$：\n$Y_4 = [H^{(4)}, \\rho^{(4)}]^T$\n$\\lambda_4 = (2H^{(4)}f_H(Y_4) - \\alpha f_\\rho(Y_4)) / \\alpha$\n$k_4 = [f_H(Y_4), f_\\rho(Y_4) + \\lambda_4]^T$。\n\n- **最终更新**：新状态由计算出的斜率组合而成：\n$y_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)$。\n\n该格式不保证 $g(y_{n+1}) = 0$ 精确成立，但其构造旨在与普通 RK4 方法相比，减少约束违背的增长。所有三种格式的性能通过计算给定测试用例在整个积分周期内的最大相对约束残差来评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path, dust fluid)\n        {'w': 0.0, 'G': 1.0, 'H0': 1.0, 'T': 1.0, 'N': 50},\n        # Case B (radiation, coarser step)\n        {'w': 1.0/3.0, 'G': 1.0, 'H0': 1.0, 'T': 1.0, 'N': 20},\n        # Case C (large initial expansion rate)\n        {'w': 0.0, 'G': 1.0, 'H0': 10.0, 'T': 0.1, 'N': 100},\n        # Case D (near-boundary small expansion rate)\n        {'w': 0.0, 'G': 1.0, 'H0': 1e-3, 'T': 1.0, 'N': 100},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_case(params)\n        all_results.append(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_case(params):\n    \"\"\"\n    Runs the simulation for a single test case using all three schemes.\n    \n    Args:\n        params (dict): A dictionary containing the parameters for the case.\n        \n    Returns:\n        list: A list of three floats corresponding to the max relative constraint\n              residuals for stage-constrained, projection, and plain RK schemes.\n    \"\"\"\n    w = params['w']\n    G = params['G']\n    H0 = params['H0']\n    T = params['T']\n    N = params['N']\n\n    alpha = 8.0 * np.pi * G / 3.0\n    rho0 = H0**2 / alpha\n    dt = T / N\n\n    y_plain = np.array([H0, rho0], dtype=np.float64)\n    y_proj = np.array([H0, rho0], dtype=np.float64)\n    y_stage = np.array([H0, rho0], dtype=np.float64)\n\n    max_res_plain = 0.0\n    max_res_proj = 0.0\n    max_res_stage = 0.0\n\n    # RHS of the ODE system\n    def rhs(y, w_val, G_val):\n        H, rho = y\n        H_dot = -4.0 * np.pi * G_val * (1.0 + w_val) * rho\n        rho_dot = -3.0 * (1.0 + w_val) * H * rho\n        return np.array([H_dot, rho_dot], dtype=np.float64)\n\n    # Plain RK4 step\n    def rk4_step_plain(y_n, w_val, G_val, dt_val):\n        k1 = rhs(y_n, w_val, G_val)\n        k2 = rhs(y_n + dt_val / 2.0 * k1, w_val, G_val)\n        k3 = rhs(y_n + dt_val / 2.0 * k2, w_val, G_val)\n        k4 = rhs(y_n + dt_val * k3, w_val, G_val)\n        return y_n + dt_val / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # Post-step projection RK4 step\n    def rk4_step_projection(y_n, w_val, G_val, dt_val, alpha_val):\n        y_tilde = rk4_step_plain(y_n, w_val, G_val, dt_val)\n        H_next = y_tilde[0]\n        rho_next = H_next**2 / alpha_val\n        return np.array([H_next, rho_next], dtype=np.float64)\n\n    # Stage-constrained RK4 step\n    def rk4_step_stage_constrained(y_n, w_val, G_val, dt_val, alpha_val):\n        \n        def modified_rhs_at_stage(y_stage, w_v, G_v, a_v):\n            H, rho = y_stage\n            fH = -4.0 * np.pi * G_v * (1.0 + w_v) * rho\n            frho = -3.0 * (1.0 + w_v) * H * rho\n            # Constraint derivative with unmodified RHS\n            dgdt_unmod = 2.0 * H * fH - a_v * frho\n            # Lagrange multiplier correction\n            lambda_correction = dgdt_unmod / a_v\n            return np.array([fH, frho + lambda_correction], dtype=np.float64)\n\n        # Stage 1: Correction is zero as y_n is on the constraint manifold\n        k1 = rhs(y_n, w_val, G_val)\n        \n        # Stage 2\n        y2 = y_n + dt_val / 2.0 * k1\n        k2 = modified_rhs_at_stage(y2, w_val, G_val, alpha_val)\n\n        # Stage 3\n        y3 = y_n + dt_val / 2.0 * k2\n        k3 = modified_rhs_at_stage(y3, w_val, G_val, alpha_val)\n\n        # Stage 4\n        y4 = y_n + dt_val * k3\n        k4 = modified_rhs_at_stage(y4, w_val, G_val, alpha_val)\n        \n        return y_n + dt_val / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for _ in range(N):\n        y_plain = rk4_step_plain(y_plain, w, G, dt)\n        y_proj = rk4_step_projection(y_proj, w, G, dt, alpha)\n        y_stage = rk4_step_stage_constrained(y_stage, w, G, dt, alpha)\n\n        for scheme_idx, y_current in enumerate([y_stage, y_proj, y_plain]):\n            H_n, rho_n = y_current\n            numerator = abs(H_n**2 - alpha * rho_n)\n            denominator = abs(H_n**2) + abs(alpha * rho_n)\n            \n            if denominator == 0.0:\n                residual = 0.0\n            else:\n                residual = numerator / denominator\n\n            if scheme_idx == 0:\n                max_res_stage = max(max_res_stage, residual)\n            elif scheme_idx == 1:\n                max_res_proj = max(max_res_proj, residual)\n            else:\n                max_res_plain = max(max_res_plain, residual)\n\n    return [max_res_stage, max_res_proj, max_res_plain]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3484652"}, {"introduction": "通用数值积分器虽然功能强大，但有时会忽略特定问题所蕴含的特殊数学结构。本练习将展示一种更高级的数值设计思想：为你所研究的问题量身打造一个“保持结构”的积分器。你将为一个在德西特时空中运动的相对论性粒子的动力学方程构建一个特殊的龙格-库塔方法，该方法能精确求解该问题（在机器精度范围内），从而有力地证明针对性算法设计的巨大优势。[@problem_id:3484668]", "problem": "考虑一个空间平坦的 Friedmann–Lemaître–Robertson–Walker 时空，其线元在共形坐标下写作 $ds^2 = a(\\eta)^2 \\left(-d\\eta^2 + d\\mathbf{x}^2\\right)$，其中 $\\eta$ 是共形时间，$a(\\eta)$ 是尺度因子。在 de Sitter 时空中，尺度因子在共形时间下为 $a(\\eta) = -\\dfrac{1}{H \\eta}$，其中 Hubble 参数 $H0$ 为常数，且 $\\eta  0$。在几何化单位制下进行计算，光速设为 $c=1$，因此代码中所有量都是无量纲的；不要打印任何单位。\n\n一个静止质量为 $m \\ge 0$ 的自由传播的相对论性粒子，在一维空间中运动，其共动位置为 $x(\\eta)$，拥有一个守恒的共动量 $q$，满足 $q = a(\\eta) p_{\\text{phys}}(\\eta)$，其中 $p_{\\text{phys}}(\\eta)$ 是物理动量。利用相对论的质能关系，运动方程在共形时间下可以写成以下一阶常微分方程组\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{m^2 a(\\eta)^2 + q^2}}, \\qquad \\frac{dq}{d\\eta} = 0,\n$$\n其初始数据为 $x(\\eta_0) = x_0$ 和 $q(\\eta_0) = q_0 \\ne 0$，其中 $\\eta_0  0$。\n\n您的任务是为该系统构建三种 Runge–Kutta 积分方案，并通过适当的阶设计，严格测试针对 $a(\\eta) = -\\dfrac{1}{H\\eta}$ 这一特定情况出现的精确解保持特性：\n\n- 方案 A (显式中点法，二阶)：将经典的显式中点 Runge–Kutta 方法（也称为二阶 Runge–Kutta）应用于 $(x,q)$ 系统，步长为 $h  0$。将 $q$ 视为由 $\\dfrac{dq}{d\\eta} = 0$ 控制的动态变量。\n\n- 方案 B (经典四阶显式 Runge–Kutta)：将具有 Butcher 权重 $b = \\left[\\dfrac{1}{6}, \\dfrac{1}{3}, \\dfrac{1}{3}, \\dfrac{1}{6}\\right]$ 和横坐标 $c = [0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1]$ 的标准四阶方法应用于 $(x,q)$ 系统，步长为 $h$。\n\n- 方案 C (通过辅助变量进行阶设计的精确保持 Runge–Kutta)：引入辅助变量 $y(\\eta) := q^2 \\eta^2 + \\mu^2$，其中 $\\mu := \\dfrac{m}{H}$。观察到 $y(\\eta)$ 满足一个仅与时间相关的标量一阶常微分方程，即 $\\dfrac{dy}{d\\eta} = 2 q^2 \\eta$。构建一个三阶显式 Runge–Kutta 方法，其权重与 Simpson 求积法则一致，即阶横坐标为 $c = [0, \\tfrac{1}{2}, 1]$，权重为 $b = \\left[\\dfrac{1}{6}, \\dfrac{2}{3}, \\dfrac{1}{6}\\right]$，并将其应用于 $\\dfrac{dy}{d\\eta} = 2 q^2 \\eta$，使得 $y$ 在一个步长内的更新对于 $y'$ 是一个精确的求积，因为 $y'$ 是 $\\eta$ 的 1 次多项式。然后，将此方法与精确的代数关系\n$$\nx(\\eta) = x(\\eta_n) - \\frac{1}{q}\\left(\\sqrt{y(\\eta)} - \\sqrt{y(\\eta_n)}\\right)\n$$\n在从 $\\eta_n$ 到 $\\eta_{n+1} = \\eta_n + h$ 的每一步上结合，使得该方法通过\n$$\nx_{n+1} = x_n - \\frac{1}{q}\\left(\\sqrt{y_{n+1}} - \\sqrt{y_n}\\right),\n$$\n来推进 $x$，由于 $\\dfrac{dq}{d\\eta}=0$，在所有三种方案下 $q$ 保持不变。这种阶设计应该对任何步长 $h$（在浮点舍入误差范围内）都能保持 $x(\\eta)$ 的精确解，这特定于 de Sitter 尺度因子 $a(\\eta)=-\\dfrac{1}{H\\eta}$。\n\n从度规定义和均匀各向同性背景下共动量守恒的基本出发点，可以推导出 de Sitter 时空中 $x(\\eta)$ 的闭式精确解。使用该精确解计算每个方案在最终时间的绝对误差。\n\n实现一个单一程序，对于以下测试套件，将解从 $\\eta=\\eta_0$ 推进到 $\\eta=\\eta_1$（其中 $\\eta_0  \\eta_1  0$；使用正的 $h$ 并调整最后一步以精确到达 $\\eta_1$），并为每个测试用例报告一个包含三个浮点数的列表，这三个数分别等于方案 A、方案 B 和方案 C 产生的 $x(\\eta_1)$ 的绝对误差。共动量 $q(\\eta)$ 必须在每个 Runge–Kutta 方法内部作为动态变量通过 $\\dfrac{dq}{d\\eta}=0$ 进行更新（这应该能精确地保持其值）。所有计算都应在无量纲的几何化单位制中进行；不要打印任何单位。\n\n测试套件参数，须逐字使用：\n\n- 用例 1 (happy path 相对论性)：$H = 1.0$, $m = 1.0$, $q_0 = 2.0$, $x_0 = 0.3$, $\\eta_0 = -1.0$, $\\eta_1 = -0.1$, $h = 0.05$。\n\n- 用例 2 (超相对论性且接近 $\\eta \\to 0^-$)：$H = 1.0$, $m = 10^{-4}$, $q_0 = 1.0$, $x_0 = -0.2$, $\\eta_0 = -1.0$, $\\eta_1 = -10^{-2}$, $h = 0.01$。\n\n- 用例 3 (非相对论性重粒子)：$H = 0.5$, $m = 10.0$, $q_0 = 0.2$, $x_0 = 1.0$, $\\eta_0 = -2.0$, $\\eta_1 = -0.5$, $h = 0.1$。\n\n- 用例 4 (无质量且动量为负)：$H = 1.0$, $m = 0.0$, $q_0 = -3.0$, $x_0 = 0.0$, $\\eta_0 = -1.5$, $\\eta_1 = -0.5$, $h = 0.1$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表包含一个测试用例的三个误差，所有内容都包含在方括号内，例如 $[[e_{1A},e_{1B},e_{1C}],[e_{2A},e_{2B},e_{2C}],\\dots]$。每个 $e_{ij}$ 必须是浮点数。", "solution": "该问题要求构建并验证三种不同的 Runge-Kutta 积分方案，用于求解 de Sitter 宇宙中相对论性粒子的运动方程。任务的核心是通过将数值结果与已知的精确解析解进行比较来分析其准确性，特别关注一种定制设计的方案（方案 C），该方案预期在机器精度范围内是精确的。\n\n首先，必须确立模型的物理和数学有效性。该时空是一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 模型，其线元为 $ds^2 = a(\\eta)^2(-d\\eta^2 + d\\mathbf{x}^2)$。对于 de Sitter 宇宙，尺度因子指定为 $a(\\eta) = -1/(H\\eta)$，其中 $H  0$ 是常数 Hubble 参数，$\\eta  0$ 是共形时间。静止质量为 $m$ 的粒子的运动方程以其共动位置 $x(\\eta)$ 和守恒共动量 $q(\\eta)$ 的一阶系统形式给出：\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{m^2 a(\\eta)^2 + q^2}}, \\qquad \\frac{dq}{d\\eta} = 0\n$$\n这些方程在宇宙学中是标准的。第一个方程源于共动速度 $d\\mathbf{x}/d\\eta$ 与物理动量和物理能量之比 $\\mathbf{p}_{\\text{phys}}/E_{\\text{phys}}$ 之间的关系，并结合了相对论的质能关系 $E_{\\text{phys}}^2 = p_{\\text{phys}}^2 + m^2$ (其中 $c=1$)以及动量的红移 $p_{\\text{phys}} = q/a$。第二个方程 $dq/d\\eta=0$ 表示了自由粒子在均匀各向同性背景下共动量的守恒。该系统是一个适定的初值问题。\n\n为了量化数值方案的误差，我们必须首先推导出 $x(\\eta)$ 的精确解析解。由于 $q$ 是常数，我们可以直接对 $x$ 的方程进行积分。将 de Sitter 尺度因子 $a(\\eta) = -1/(H\\eta)$ 代入 $x$ 的常微分方程得到：\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{q^2 + m^2 / (H^2 \\eta^2)}} = \\frac{q}{\\sqrt{(q^2 \\eta^2 + m^2/H^2)/\\eta^2}}\n$$\n鉴于 $\\eta  0$，我们有 $\\sqrt{\\eta^2} = -\\eta$。该表达式简化为：\n$$\n\\frac{dx}{d\\eta} = \\frac{-q\\eta}{\\sqrt{q^2 \\eta^2 + (m/H)^2}}\n$$\n将此方程从初始时间 $\\eta_0$（位置为 $x_0 = x(\\eta_0)$）积分到稍后的时间 $\\eta$，得到位置的变化：\n$$\nx(\\eta) - x(\\eta_0) = \\int_{\\eta_0}^{\\eta} \\frac{-q\\eta'}{\\sqrt{q^2 (\\eta')^2 + (m/H)^2}} d\\eta'\n$$\n这个积分可以精确求解，例如，通过换元 $u = q^2 (\\eta')^2 + (m/H)^2$，得到 $du = 2q^2 \\eta' d\\eta'$。定积分的结果是：\n$$\nx(\\eta) - x(\\eta_0) = \\left[ -\\frac{1}{q} \\sqrt{q^2 (\\eta')^2 + (m/H)^2} \\right]_{\\eta_0}^{\\eta}\n$$\n这就给出了任意时间 $\\eta$ 下共动位置的精确解：\n$$\nx(\\eta) = x(\\eta_0) - \\frac{1}{q} \\left( \\sqrt{q^2 \\eta^2 + (m/H)^2} - \\sqrt{q^2 \\eta_0^2 + (m/H)^2} \\right)\n$$\n该公式将作为基准真相，用于计算每个方案在最终时间 $\\eta_1$ 的绝对误差 $|x_{\\text{numerical}}(\\eta_1) - x_{\\text{exact}}(\\eta_1)|$。\n\n数值积分从 $\\eta_0$ 到 $\\eta_1  \\eta_0$ 进行，基础步长为 $h  0$。为了精确到达 $\\eta_1$，最后一步的步长被调整为 $h_{\\text{final}} = \\eta_1 - \\eta_{\\text{current}}$。我们将状态向量定义为 $\\mathbf{S} = [x, q]^T$，常微分方程组的右侧定义为 $\\mathbf{F}(\\mathbf{S}, \\eta)$。由于 $dq/d\\eta = 0$，对于任何有效的数值积分器，$\\mathbf{S}$ 的 $q$ 分量都将保持不变。\n\n方案 A是显式中点法，一种二阶 Runge-Kutta 方案。从 $\\eta_n$ 到 $\\eta_{n+1} = \\eta_n + h$ 的单步计算如下：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{S}_n, \\eta_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_1, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{S}_{n+1} = \\mathbf{S}_n + h \\mathbf{k}_2\n$$\n\n方案 B 是经典的四阶显式 Runge-Kutta 方法。其单步更新规则是：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{S}_n, \\eta_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_1, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_2, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(\\mathbf{S}_n + h\\mathbf{k}_3, \\eta_n + h) \\\\\n\\mathbf{S}_{n+1} = \\mathbf{S}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n\n方案 C 是一种利用问题结构的专用方法。它引入了一个辅助变量 $y(\\eta) := q^2 \\eta^2 + \\mu^2$，其中 $\\mu := m/H$。将 $y(\\eta)$ 对 $\\eta$求导，可以得到一个只依赖于时间的更简单的常微分方程：\n$$\n\\frac{dy}{d\\eta} = 2q^2\\eta\n$$\n该方案使用一个三阶显式 Runge-Kutta 方法来积分这个方程，其 Butcher 权重 $b = [1/6, 2/3, 1/6]$ 和横坐标 $c = [0, 1/2, 1]$ 对应于 Simpson 求积法则。对于形式为 $y' = f(\\eta)$ 的常微分方程，一个 RK 步长等价于一个求积评估：$y_{n+1} = y_n + h \\sum_i b_i f(\\eta_n + c_i h)$。已知 Simpson 法则对次数不超过 3 的多项式是精确的。由于右侧 $2q^2\\eta$ 是 $\\eta$ 的 1 次多项式，因此该数值求积是精确的。因此，该方案计算出的值 $y_{n+1}$ 精确等于 $y(\\eta_{n+1})$，误差仅为浮点误差。然后使用从解析解推导出的精确代数关系来更新 $x$：\n$$\nx_{n+1} = x_n - \\frac{1}{q}\\left(\\sqrt{y_{n+1}} - \\sqrt{y_n}\\right)\n$$\n由于 $y(\\eta)$ 的更新和随后的 $x(\\eta)$ 计算都是精确的，方案 C 预期对任何步长 $h$ 都能保持精确解，误差仅源于浮点运算。\n\n最终的实现计算了所提供测试套件中每个方案的绝对误差，并以列表的列表形式格式化输出。", "answer": "```python\nimport numpy as np\n\ndef get_ode_rhs_func(H, m):\n    \"\"\"\n    Returns the function F(state, eta) for the ODE system d(x,q)/d(eta).\n    \"\"\"\n    def F(state, eta):\n        _x, q = state\n        # The problem statement ensures eta  0, so eta != 0.\n        a_sq = 1.0 / (H**2 * eta**2)\n        denominator = np.sqrt(m**2 * a_sq + q**2)\n        \n        # Handle the case where the denominator might be zero if q=0 and m=0.\n        # Problem statement says q0 != 0, so q is never 0.\n        dxdeta = q / denominator\n        dqdeta = 0.0\n        \n        return np.array([dxdeta, dqdeta])\n    return F\n\ndef solve_scheme_A(params):\n    \"\"\"\n    Solves the ODE system using Scheme A (Explicit Midpoint / RK2).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n    \n    F = get_ode_rhs_func(H, m)\n    \n    state = np.array([x0, q0], dtype=np.float64)\n    eta = eta0\n    \n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step  1e-15:  # Avoid negligible steps due to floating point arithmetic\n            break\n\n        k1 = F(state, eta)\n        mid_state = state + 0.5 * h_step * k1\n        mid_eta = eta + 0.5 * h_step\n        \n        k2 = F(mid_state, mid_eta)\n        \n        state = state + h_step * k2\n        eta += h_step\n        \n    return state[0]\n\ndef solve_scheme_B(params):\n    \"\"\"\n    Solves the ODE system using Scheme B (Classical RK4).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n\n    F = get_ode_rhs_func(H, m)\n    \n    state = np.array([x0, q0], dtype=np.float64)\n    eta = eta0\n    \n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step  1e-15:\n            break\n            \n        k1 = F(state, eta)\n        k2 = F(state + 0.5 * h_step * k1, eta + 0.5 * h_step)\n        k3 = F(state + 0.5 * h_step * k2, eta + 0.5 * h_step)\n        k4 = F(state + h_step * k3, eta + h_step)\n        \n        state = state + (h_step / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n        eta += h_step\n        \n    return state[0]\n\ndef solve_scheme_C(params):\n    \"\"\"\n    Solves the ODE system using Scheme C (Exact-preserving method).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n    \n    q = q0\n    mu_sq = (m / H)**2\n    \n    # State is (x, y) where y = q^2*eta^2 + mu^2\n    y = mu_sq + q**2 * eta0**2\n    x = x0\n    eta = eta0\n\n    def F_y(eta_val, q_val):\n        return 2.0 * q_val**2 * eta_val\n\n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step  1e-15:\n            break\n        \n        # Simpson's rule RK method for y(eta)\n        k1_y = F_y(eta, q)\n        k2_y = F_y(eta + 0.5 * h_step, q)\n        k3_y = F_y(eta + h_step, q)\n        \n        # Weights are b = [1/6, 2/3, 1/6]. Note 2/3 = 4/6.\n        y_next = y + (h_step / 6.0) * (k1_y + 4.0 * k2_y + k3_y)\n        \n        # Exact algebraic update for x\n        x_next = x - (1.0 / q) * (np.sqrt(y_next) - np.sqrt(y))\n        \n        x = x_next\n        y = y_next\n        eta += h_step\n        \n    return x\n\ndef get_exact_x(params, final_eta):\n    \"\"\"\n    Calculates the exact solution for x at a given final time.\n    \"\"\"\n    H, m, q0, x0, eta0, _, _ = params\n    \n    mu_sq = (m / H)**2\n    \n    y_final = mu_sq + q0**2 * final_eta**2\n    y_initial = mu_sq + q0**2 * eta0**2\n    \n    delta_x = - (1.0 / q0) * (np.sqrt(y_final) - np.sqrt(y_initial))\n    \n    return x0 + delta_x\n\ndef solve():\n    test_cases = [\n        # (H,     m,    q0,   x0,   eta0,  eta1,     h)\n        (1.0,   1.0,   2.0,  0.3, -1.0, -0.1,    0.05),\n        (1.0, 1e-4,  1.0, -0.2, -1.0, -1e-2,   0.01),\n        (0.5,  10.0,  0.2,  1.0, -2.0, -0.5,    0.1),\n        (1.0,   0.0,  -3.0,  0.0, -1.5, -0.5,    0.1),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        _, _, _, _, _, eta1, _ = case\n        \n        x_exact_final = get_exact_x(case, eta1)\n        \n        x_final_A = solve_scheme_A(case)\n        x_final_B = solve_scheme_B(case)\n        x_final_C = solve_scheme_C(case)\n        \n        error_A = abs(x_final_A - x_exact_final)\n        error_B = abs(x_final_B - x_exact_final)\n        error_C = abs(x_final_C - x_exact_final)\n        \n        all_results.append([error_A, error_B, error_C])\n        \n    inner_formatted_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(str(err) for err in res_list)}]\"\n        inner_formatted_results.append(inner_str)\n    \n    final_output_string = f\"[{','.join(inner_formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3484668"}]}