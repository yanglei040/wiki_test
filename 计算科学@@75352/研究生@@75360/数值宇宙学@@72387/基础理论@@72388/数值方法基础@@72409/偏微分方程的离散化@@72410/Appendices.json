{"hands_on_practices": [{"introduction": "宇宙学方程常常包含时间尺度差异巨大的项，这使得方程组在数值上是“刚性”的。隐式-显式（IMEX）方法通过对刚性项（为了稳定性）进行隐式处理，同时对非刚性项（为了速度）进行显式处理，从而高效地解决这类问题。这项练习 [@problem_id:3470353] 将通过分析一个基础IMEX格式的线性稳定性，为您奠定理论基础，这是在处理更复杂的偏微分方程之前必须掌握的关键一步。", "problem": "考虑对共动坐标系中的一个线性化宇宙学流体模式进行半离散的线方法近似，其中单个傅里叶模式振幅 $u(t)$ 遵循常微分方程 $\\partial_{t} u(t) = -\\lambda u(t) - \\mu u(t)$，其中常数速率 $\\lambda \\geq 0$ 和 $\\mu \\geq 0$ 的单位为 $\\mathrm{s}^{-1}$。此处，$\\lambda$ 源于显式处理的非刚性输运算子（例如，共动平流或源耦合），而 $\\mu$ 源于隐式处理的刚性阻尼算子（例如，哈勃拖拽或碰撞项）。采用一阶隐式-显式（IMEX）方法，在一个大小为 $\\Delta t$ 的单一组合时间步长中，显式部分对 $\\lambda$ 的贡献使用前向欧拉法，隐式部分对 $\\mu$ 的贡献使用后向欧拉法。假设显式和隐式算子在此模式上是对易的，因此它们的特征值相加，并且底层的空间离散化产生实非负的谱速率。\n\n从半离散演化定律和所描述的 IMEX 时间离散化出发，推导单步放大因子，并用它来确定此 IMEX 更新的组合线性稳定性要求，用 $\\lambda$、$\\mu$ 和 $\\Delta t$ 表示。在 $0 \\leq \\mu  \\lambda$ 的假设下，计算最大允许时间步长 $\\Delta t_{\\max}$，使得更新对于区间 $0 \\leq \\Delta t \\leq \\Delta t_{\\max}$ 中的所有 $\\Delta t$ 都是线性稳定的。将您的最终答案表示为 $\\Delta t_{\\max}$ 的闭式解析表达式，单位为秒。无需进行数值计算，也不应进行四舍五入。", "solution": "首先将验证问题的科学和数学合理性、完整性和清晰度。\n\n### 第1步：提取已知条件\n- 单个傅里叶模式振幅 $u(t)$ 的半离散演化方程为 $\\partial_{t} u(t) = -\\lambda u(t) - \\mu u(t)$。\n- 速率 $\\lambda$ 和 $\\mu$ 是常数，满足 $\\lambda \\geq 0$ 和 $\\mu \\geq 0$，单位为 $\\mathrm{s}^{-1}$。\n- 项 $-\\lambda u(t)$ 源于非刚性算子，并被显式处理。\n- 项 $-\\mu u(t)$ 源于刚性算子，并被隐式处理。\n- 时间步进格式为一阶隐式-显式（IMEX）方法。\n- 显式部分（对于 $\\lambda$）使用前向欧拉法。\n- 隐式部分（对于 $\\mu$）使用后向欧拉法。\n- 时间步长用 $\\Delta t$ 表示。\n- 假设显式和隐式算子是对易的。\n- 假设底层的空间离散化产生实数、非负的谱速率。\n- 最终计算在 $0 \\leq \\mu  \\lambda$ 的假设下进行。\n- 目标是推导单步放大因子、线性稳定性要求以及最大允许稳定时间步长 $\\Delta t_{\\max}$。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学或事实不合理性**：该问题在科学和数学上是合理的。它描述了将标准一阶 IMEX（前向欧拉/后向欧拉）格式应用于线性常微分方程的线性稳定性分析，这是求解刚性微分方程的数值分析中的一项基本技术。此类方程是物理现象（包括线性化的宇宙学微扰）的常见模型。没有违反科学原理。\n2.  **不可形式化或不相关**：该问题是高度可形式化的，并且与偏微分方程离散化的主题直接相关，这是数值宇宙学的一个核心问题。\n3.  **不完整或矛盾的设置**：该问题是自洽的，并提供了进行推导所需的所有必要信息。常微分方程、数值方法、参数和所有必要的假设都已明确说明。没有内部矛盾。\n4.  **不切实际或不可行**：该设置是用于分析数值方法稳定性的标准简化模型（Dahlquist 测试方程）。它在数学上是可行的，并代表了对更复杂物理系统的有效理想化。\n5.  **不适定或结构不良**：该问题是适定的。它要求进行明确的数学推导，从而得到唯一且有意义的结果。所有术语在数值分析领域都是标准的。\n6.  **伪深刻、琐碎或同义反复**：该问题是数值稳定性理论中的一个标准的、非平凡的练习。它需要正确应用定义和代数操作。\n7.  **超出科学可验证性**：该推导纯粹是数学上的，因此可以通过逻辑和代数规则进行验证。\n\n### 第3步：结论和行动\n问题是有效的。现在将提供完整的解答。\n\n### 解答推导\n控制模式振幅 $u(t)$ 演化的半离散常微分方程 (ODE) 由下式给出：\n$$\n\\frac{d u}{d t} = -\\lambda u - \\mu u\n$$\n我们使用大小为 $\\Delta t$ 的单步在时间上离散化该方程。设 $u^n$ 表示在时间 $t_n = n \\Delta t$ 时对 $u(t_n)$ 的数值近似。下一个状态是时间 $t_{n+1} = t_n + \\Delta t$ 时的 $u^{n+1}$。\n\n问题指定了一阶 IMEX 格式。项 $-\\lambda u$ 使用前向欧拉法进行显式处理，意味着它在时间 $t_n$ 处求值。项 $-\\mu u$ 使用后向欧拉法进行隐式处理，意味着它在时间 $t_{n+1}$ 处求值。结合这些，该 ODE 的有限差分近似为：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = -\\lambda u^n - \\mu u^{n+1}\n$$\n我们的第一个目标是找到单步放大因子 $g(\\lambda, \\mu, \\Delta t)$，它由关系式 $u^{n+1} = g \\cdot u^n$ 定义。为了找到 $g$，我们必须重新整理离散化方程，以 $u^n$ 的形式求解 $u^{n+1}$。\n\n从离散化方程开始：\n$$\nu^{n+1} - u^n = \\Delta t (-\\lambda u^n - \\mu u^{n+1})\n$$\n我们将所有包含 $u^{n+1}$ 的项移到左边，所有包含 $u^n$ 的项移到右边：\n$$\nu^{n+1} + \\mu \\Delta t u^{n+1} = u^n - \\lambda \\Delta t u^n\n$$\n提出 $u^{n+1}$ 和 $u^n$ 的公因子：\n$$\nu^{n+1} (1 + \\mu \\Delta t) = u^n (1 - \\lambda \\Delta t)\n$$\n求解 $u^{n+1}$ 可得：\n$$\nu^{n+1} = \\left( \\frac{1 - \\lambda \\Delta t}{1 + \\mu \\Delta t} \\right) u^n\n$$\n根据定义，括号中的表达式即为放大因子 $g$：\n$$\ng(\\lambda, \\mu, \\Delta t) = \\frac{1 - \\lambda \\Delta t}{1 + \\mu \\Delta t}\n$$\n为使数值方法线性稳定，放大因子的模不得超过1。即，稳定性要求为：\n$$\n|g| \\leq 1\n$$\n代入 $g$ 的表达式：\n$$\n\\left| \\frac{1 - \\lambda \\Delta t}{1 + \\mu \\Delta t} \\right| \\leq 1\n$$\n问题陈述 $\\mu \\geq 0$ 且时间步长 $\\Delta t$ 为非负，因此 $\\Delta t \\geq 0$。所以，分母 $1 + \\mu \\Delta t$ 总是正的且大于等于1。我们可以在不等式两边同乘以 $1 + \\mu \\Delta t$ 而不改变不等式的方向：\n$$\n|1 - \\lambda \\Delta t| \\leq 1 + \\mu \\Delta t\n$$\n这个绝对值不等式等价于以下一对不等式：\n$$\n-(1 + \\mu \\Delta t) \\leq 1 - \\lambda \\Delta t \\leq 1 + \\mu \\Delta t\n$$\n我们必须同时满足这两个不等式。\n\n首先分析右侧不等式：\n$$\n1 - \\lambda \\Delta t \\leq 1 + \\mu \\Delta t\n$$\n$$\n-\\lambda \\Delta t \\leq \\mu \\Delta t\n$$\n$$\n0 \\leq (\\lambda + \\mu) \\Delta t\n$$\n因为 $\\lambda \\geq 0$，$\\mu \\geq 0$ 和 $\\Delta t \\geq 0$，这个条件总是满足的，并且没有对 $\\Delta t$ 施加任何上限。\n\n现在分析左侧不等式：\n$$\n-(1 + \\mu \\Delta t) \\leq 1 - \\lambda \\Delta t\n$$\n$$\n-1 - \\mu \\Delta t \\leq 1 - \\lambda \\Delta t\n$$\n重新整理各项以分离出 $\\Delta t$：\n$$\n\\lambda \\Delta t - \\mu \\Delta t \\leq 1 + 1\n$$\n$$\n(\\lambda - \\mu) \\Delta t \\leq 2\n$$\n这是 IMEX 格式的一般线性稳定性要求。\n\n问题的最后一部分要求在特定假设 $0 \\leq \\mu  \\lambda$ 下求出最大允许时间步长 $\\Delta t_{\\max}$。这个假设意味着项 $(\\lambda - \\mu)$ 是严格为正的。由于 $(\\lambda - \\mu) > 0$，我们可以用它来除稳定性不等式的两边，而不改变不等式的方向：\n$$\n\\Delta t \\leq \\frac{2}{\\lambda - \\mu}\n$$\n为使方法稳定，必须满足此不等式。问题要求的是最大允许时间步长 $\\Delta t_{\\max}$，使得更新对于区间 $0 \\leq \\Delta t \\leq \\Delta t_{\\max}$ 内的所有 $\\Delta t$ 都是线性稳定的。这意味着 $\\Delta t_{\\max}$ 是此稳定区间的上界。\n因此，最大允许时间步长为：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\lambda - \\mu}\n$$\n$\\lambda$ 和 $\\mu$ 的单位是 $\\mathrm{s}^{-1}$，所以 $\\Delta t_{\\max}$ 的单位是 $1 / (\\mathrm{s}^{-1}) = \\mathrm{s}$，这与问题的要求一致。", "answer": "$$\n\\boxed{\\frac{2}{\\lambda - \\mu}}\n$$", "id": "3470353"}, {"introduction": "数值精度不仅仅是减小误差的大小，更重要的是保持系统的基本物理性质。一个“良好平衡”的格式被设计用于在离散层面精确地维持已知的平衡解或定常解，防止截断误差充当虚假的物理源项。通过这个编码实践 [@problem_id:3470344]，您将直接见证一个朴素的离散化方法如何导致非物理的结果，以及一个良好平衡的设计如何修正这个问题，这是开发稳健模拟代码的至关重要的一课。", "problem": "考虑一个由物质主导的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙，在牛顿规范下的线性标量微扰。关注波数为 $k$ 的单个傅里叶模式，以及密度对比 $\\delta$ 在共形时间 $\\tau$下的连续性方程，\n$$\n\\delta'(\\tau) = -\\theta(\\tau) + 3\\,\\Phi'(\\tau),\n$$\n其中 $\\theta$ 是速度散度，$\\Phi$ 是 Bardeen 势。在 Einstein–de Sitter 极限下进行研究，其中标度因子 $a(\\tau)\\propto \\tau^2$ 且共形哈勃参数 $\\mathcal{H}(\\tau)=2/\\tau$，并将注意力限制在势在物理上不随时间变化的子问题上，\n$$\n\\Phi(\\tau) = \\Phi_0,\n$$\n因此物理源 $3\\,\\Phi'(\\tau)$ 恒等于零。假设增长模式具有精确的密度对比和速度散度，由下式给出\n$$\n\\delta_{\\text{exact}}(\\tau) = D_0\\,\\tau^2,\\quad \\theta_{\\text{exact}}(\\tau) = -2 D_0\\,\\tau,\n$$\n这满足 $\\Phi'(\\tau)=0$ 的连续性方程。所有量均为无量纲量。\n\n您将研究离散反作用：一个破坏 $\\Phi$ 的离散表示的模型截断误差如何通过耦合项 $3\\,\\Phi'(\\tau)$ 在 $\\delta$ 中引发伪增长，并设计一个修正的源平衡，以在离散层面上消除这种伪增长。\n\n将在网格点 $\\tau_n=\\tau_0+n\\,\\Delta \\tau$ 上采样的 $\\Phi$ 的离散表示建模为\n$$\n\\Phi^{\\text{num}}(\\tau_n) = \\Phi_0 + \\eta(\\tau_n),\\quad \\eta(\\tau) = C\\,(\\Delta \\tau)^p \\sin(\\omega \\tau),\n$$\n其中 $C$ 是一个振幅，$p$ 是截断误差的形式阶数，$\\omega$ 是一个固定的角频率。此 $\\eta(\\tau)$ 代表截断误差的确定性代理，它随时间步长 $\\Delta \\tau$ 的幂次衰减。\n\n任务1（推导）：从连续性方程出发，仅使用上述基本定律，推导：\n\n- 一个在均匀网格上对 $\\delta$ 进行的二阶时间精度的一致离散更新。该更新对 $-\\theta$ 项使用中点法则，并使用带噪声的样本 $\\Phi^{\\text{num}}(\\tau_n)$ 和 $\\Phi^{\\text{num}}(\\tau_{n+1})$ 通过中心离散斜率来近似半步处的 $3\\,\\Phi'$。\n- 一种修正的、良好平衡的源离散化方法，即使当 $\\Phi^{\\text{num}}$ 包含上述建模的截断误差时，也能精确保持与 $3\\,\\Phi'(\\tau)=0$ 相关的稳态。该设计必须从 $3\\,\\Phi'$ 在一个时间步长上的积分的守恒兼容表示出发，并且不得依赖于经验性地抵消误差。\n\n任务2（实现）：在区间 $\\tau\\in[\\tau_0,\\tau_f]$ 上，使用初始条件 $\\delta(\\tau_0)=\\delta_{\\text{exact}}(\\tau_0)$ 实现以下两种更新：\n\n- 朴素中点格式，它对 $-\\theta$ 使用中点法则，并对 $3\\,\\Phi'$ 使用基于带噪声的 $\\Phi^{\\text{num}}$ 的中心差分。\n- 平衡源格式，它对 $-\\theta$ 使用中点法则，并对 $3\\,\\Phi'$ 的贡献使用任务1中得到的守恒兼容表示，以消除当 $\\Phi(\\tau)$ 在物理上为常数时的伪增长。\n\n对宇宙学背景和截断误差代理使用以下参数值：\n$$\n\\tau_0=1.0,\\quad \\tau_f=2.0,\\quad D_0=0.1,\\quad \\Phi_0=10^{-5},\\quad \\omega=5.0.\n$$\n\n对于每次运行，计算最终时刻的绝对分数误差，\n$$\nE_{\\text{naive}}=\\frac{\\left|\\delta_{\\text{naive}}(\\tau_f)-\\delta_{\\text{exact}}(\\tau_f)\\right|}{\\left|\\delta_{\\text{exact}}(\\tau_f)\\right|},\\qquad\nE_{\\text{bal}}=\\frac{\\left|\\delta_{\\text{bal}}(\\tau_f)-\\delta_{\\text{exact}}(\\tau_f)\\right|}{\\left|\\delta_{\\text{exact}}(\\tau_f)\\right|}.\n$$\n\n任务3（测试套件）：在以下测试套件上运行您的实现，其中每个案例由 $(\\Delta \\tau, p, C)$ 指定：\n\n- 案例A（粗步长，二阶误差）：$(\\Delta \\tau, p, C)=(0.1,\\,2,\\,1.0)$。\n- 案例B（细化步长，二阶误差）：$(\\Delta \\tau, p, C)=(0.05,\\,2,\\,1.0)$。\n- 案例C（细化步长，三阶误差）：$(\\Delta \\tau, p, C)=(0.05,\\,3,\\,1.0)$。\n- 案例D（无截断误差）：$(\\Delta \\tau, p, C)=(0.05,\\,2,\\,0.0)$。\n\n所有量均为无量纲量；将数值结果报告为无单位的浮点数。将所有报告的误差四舍五入到 $12$ 位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表。列表按上述案例顺序排列，其中每个内部列表为 $[E_{\\text{naive}},E_{\\text{bal}}]$。例如，格式必须严格为\n$$\n\\big[\\,[e_A^{\\text{naive}},e_A^{\\text{bal}}],[e_B^{\\text{naive}},e_B^{\\text{bal}}],[e_C^{\\text{naive}},e_C^{\\text{bal}}],[e_D^{\\text{naive}},e_D^{\\text{bal}}]\\,\\big].\n$$", "solution": "分析始于对问题陈述的验证。所有提供的信息均被逐字提取，并随后评估其科学一致性、完整性和客观性。\n\n### 步骤1：提取给定信息\n- **控制方程：** 密度对比 $\\delta$ 的连续性方程为 $\\delta'(\\tau) = -\\theta(\\tau) + 3\\,\\Phi'(\\tau)$。\n- **宇宙学模型：** Einstein–de Sitter 极限下的物质主导 FLRW 宇宙，其中 $a(\\tau)\\propto \\tau^2$ 且 $\\mathcal{H}(\\tau)=2/\\tau$。\n- **物理状态：** Bardeen 势在物理上是常数，$\\Phi(\\tau) = \\Phi_0$，这意味着物理源项 $3\\,\\Phi'(\\tau)$ 为零。\n- **精确解析解：** 增长模式解由 $\\delta_{\\text{exact}}(\\tau) = D_0\\,\\tau^2$ 和 $\\theta_{\\text{exact}}(\\tau) = -2 D_0\\,\\tau$ 给出。\n- **数值网格：** 均匀时间网格，点为 $\\tau_n = \\tau_0+n\\,\\Delta \\tau$。\n- **数值势模型：** 在网格上采样的势被一个确定性误差代理所破坏：$\\Phi^{\\text{num}}(\\tau_n) = \\Phi_0 + \\eta(\\tau_n)$，其中 $\\eta(\\tau) = C\\,(\\Delta \\tau)^p \\sin(\\omega \\tau)$。\n- **任务1（推导）：** 为 $\\delta(\\tau)$ 推导一个朴素中点离散更新和一个修正的、良好平衡的源更新。\n- **任务2（实现）：** 在区间 $\\tau\\in[\\tau_0,\\tau_f]$ 上，使用初始条件 $\\delta(\\tau_0)=\\delta_{\\text{exact}}(\\tau_0)$ 实现两种格式。\n- **参数：** $\\tau_0=1.0$，$\\tau_f=2.0$，$D_0=0.1$，$\\Phi_0=10^{-5}$，$\\omega=5.0$。\n- **误差度量：** $E = \\frac{\\left|\\delta_{\\text{num}}(\\tau_f)-\\delta_{\\text{exact}}(\\tau_f)\\right|}{\\left|\\delta_{\\text{exact}}(\\tau_f)\\right|}$。\n- **测试套件：** 案例A：$(\\Delta \\tau, p, C)=(0.1,\\,2,\\,1.0)$；案例B：$(\\Delta \\tau, p, C)=(0.05,\\,2,\\,1.0)$；案例C：$(\\Delta \\tau, p, C)=(0.05,\\,3,\\,1.0)$；案例D：$(\\Delta \\tau, p, C)=(0.05,\\,2,\\,0.0)$。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题在科学上基于标准的宇宙学微扰理论和数值分析。截断误差和良好平衡格式的概念是计算物理学的核心。该问题是适定的，提供了一个带初始条件和所有必要参数的一阶常微分方程。语言精确客观。该设置是一个简化但概念丰富的模型问题，旨在阐明一个特定的数值原理，并且没有任何科学缺陷、矛盾或含糊之处。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个完整的解决方案。\n\n### 基于原理的求解与推导\n\n需要求解的基本方程是密度对比 $\\delta$ 的连续性方程：\n$$\n\\frac{d\\delta}{d\\tau} = -\\theta(\\tau) + 3\\frac{d\\Phi}{d\\tau}\n$$\n为构造一个数值格式，我们将此方程在一个时间步长上从 $\\tau_n$ 积分到 $\\tau_{n+1} = \\tau_n + \\Delta\\tau$：\n$$\n\\int_{\\tau_n}^{\\tau_{n+1}} \\frac{d\\delta}{d\\tau} d\\tau = \\int_{\\tau_n}^{\\tau_{n+1}} \\left( -\\theta(\\tau) + 3\\frac{d\\Phi}{d\\tau} \\right) d\\tau\n$$\n对左侧和 $\\Phi'$ 的积分应用微积分基本定理，得到一个精确关系：\n$$\n\\delta(\\tau_{n+1}) - \\delta(\\tau_n) = -\\int_{\\tau_n}^{\\tau_{n+1}} \\theta(\\tau) d\\tau + 3\\left[ \\Phi(\\tau_{n+1}) - \\Phi(\\tau_n) \\right]\n$$\n令 $\\delta_n$ 表示 $\\delta(\\tau_n)$ 的数值近似。一个通用的一步数值更新可以写为：\n$$\n\\delta_{n+1} = \\delta_n - \\left( \\int_{\\tau_n}^{\\tau_{n+1}} \\theta(\\tau) d\\tau \\right)_{\\text{disc}} + \\left( 3\\left[ \\Phi_{n+1} - \\Phi_n \\right] \\right)_{\\text{disc}}\n$$\n其中下标 'disc' 表示对该项的离散近似。\n\n问题指定对 $\\theta$ 的积分使用二阶中点法则：\n$$\n\\left( \\int_{\\tau_n}^{\\tau_{n+1}} \\theta(\\tau) d\\tau \\right)_{\\text{disc}} = \\Delta\\tau \\cdot \\theta(\\tau_{n+1/2})\n$$\n其中 $\\tau_{n+1/2} = \\tau_n + \\Delta\\tau/2$。使用给定的精确形式 $\\theta_{\\text{exact}}(\\tau) = -2 D_0 \\tau$，我们有：\n$$\n\\Delta\\tau \\cdot \\theta(\\tau_{n+1/2}) = \\Delta\\tau \\cdot (-2 D_0 (\\tau_n + \\Delta\\tau/2)) = -2 D_0 \\tau_n \\Delta\\tau - D_0 (\\Delta\\tau)^2\n$$\n一个关键的观察是，对于给定的 $\\theta(\\tau)$，这个中点求积是精确的，因为精确积分为 $\\int_{\\tau_n}^{\\tau_{n+1}} (-2D_0\\tau) d\\tau = -D_0(\\tau_{n+1}^2 - \\tau_n^2) = -D_0((\\tau_n+\\Delta\\tau)^2 - \\tau_n^2) = -2D_0\\tau_n\\Delta\\tau - D_0(\\Delta\\tau)^2$。这意味着 $\\theta$ 项的离散化不引入误差，数值误差将完全由 $\\Phi'$ 项的处理决定。\n\n两种要求的格式仅在源项 $3\\Phi'$ 的离散化上有所不同。\n\n**任务1，第1部分：朴素中点格式**\n\n该格式遵循的解释是，整个更新是一个前向欧拉步，其中右侧在时间中点 $\\tau_{n+1/2}$ 处求值。导数 $\\Phi'(\\tau_{n+1/2})$ 使用可用的带噪声数据点 $\\Phi^{\\text{num}}(\\tau_n)$ 和 $\\Phi^{\\text{num}}(\\tau_{n+1})$ 通过中心有限差分来近似：\n$$\n3\\Phi'(\\tau_{n+1/2}) \\approx 3\\frac{\\Phi^{\\text{num}}(\\tau_{n+1}) - \\Phi^{\\text{num}}(\\tau_n)}{\\Delta\\tau}\n$$\n将此近似在一个步长 $\\Delta\\tau$ 上积分，得到离散的源贡献：\n$$\nS_{\\text{naive}} = \\Delta\\tau \\cdot \\left( 3\\frac{\\Phi^{\\text{num}}_{n+1} - \\Phi^{\\text{num}}_n}{\\Delta\\tau} \\right) = 3(\\Phi^{\\text{num}}_{n+1} - \\Phi^{\\text{num}}_n)\n$$\n因此，朴素中点格式的完整更新为：\n$$\n\\delta^{\\text{naive}}_{n+1} = \\delta^{\\text{naive}}_n - \\Delta\\tau \\cdot \\theta(\\tau_{n+1/2}) + 3(\\Phi^{\\text{num}}_{n+1} - \\Phi^{\\text{num}}_n)\n$$\n代入 $\\Phi^{\\text{num}}_n = \\Phi_0 + \\eta_n$，源项变为 $3(\\eta_{n+1}-\\eta_n)$。尽管物理势是常数，但该格式引入了一个与相邻时间步上截断误差代理的差值成正比的伪源项。\n\n**任务1，第2部分：平衡源格式**\n\n良好平衡格式旨在离散层面上精确地保持已知的连续性质。问题陈述指出，物理势是常数，$\\Phi(\\tau) = \\Phi_0$，这意味着物理源项 $3\\Phi'(\\tau)$ 恒等于零。良好平衡格式必须遵守这一事实。\n\n推导从源贡献的“守恒兼容”积分形式开始：$3[\\Phi(\\tau_{n+1}) - \\Phi(\\tau_n)]$。平衡的离散化方法能正确识别由数值数据表示的物理函数。这里，我们已知物理势为 $\\Phi(\\tau) = \\Phi_0$。格式必须使用这个*先验的*物理信息。通过将真实的物理势代入表达式，我们得到平衡源项：\n$$\nS_{\\text{bal}} = 3\\left[ \\Phi(\\tau_{n+1}) - \\Phi(\\tau_n) \\right] = 3\\left[ \\Phi_0 - \\Phi_0 \\right] = 0\n$$\n这种离散化方法正确地计算为零，完美地平衡了一个常数势的源，而与数值表示 $\\Phi^{\\text{num}}$ 无关。平衡源格式的更新为：\n$$\n\\delta^{\\text{bal}}_{n+1} = \\delta^{\\text{bal}}_n - \\Delta\\tau \\cdot \\theta(\\tau_{n+1/2}) + 0\n$$\n由于 $\\theta$ 项的离散化已被证明是精确的，并且平衡源项正确地为零，因此平衡格式在网格点上精确地再现了解析解。因此，误差 $E_{\\text{bal}}$ 预计为零（或机器精度量级）。朴素格式在最终时间步 $N$ 的误差 $\\delta^{\\text{naive}}_N - \\delta^{\\text{exact}}_N$ 是伪源项的总和，它形成一个伸缩级数：\n$$\n\\sum_{n=0}^{N-1} 3(\\Phi^{\\text{num}}_{n+1} - \\Phi^{\\text{num}}_n) = 3(\\Phi^{\\text{num}}_N - \\Phi^{\\text{num}}_0) = 3(\\Phi^{\\text{num}}(\\tau_f) - \\Phi^{\\text{num}}(\\tau_0))\n$$\n这为朴素格式的误差提供了一个解析预测。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem of discrete backreaction in a simplified cosmological setting.\n\n    This function implements and compares two numerical schemes for solving the\n    continuity equation for density contrast perturbations:\n    1. A naive-midpoint scheme that is susceptible to spurious growth from\n       errors in the potential's numerical representation.\n    2. A well-balanced scheme that is designed to exactly preserve the state\n       where the potential is physically constant, thus eliminating spurious growth.\n\n    The function runs a suite of tests with different numerical parameters\n    and computes the final fractional error for both schemes in each case.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    tau0 = 1.0\n    tauf = 2.0\n    d0 = 0.1\n    phi0 = 1.0e-5\n    omega = 5.0\n\n    # Test suite: (delta_tau, p, C)\n    test_cases = [\n        (0.1, 2, 1.0),   # Case A\n        (0.05, 2, 1.0),  # Case B\n        (0.05, 3, 1.0),  # Case C\n        (0.05, 2, 0.0),  # Case D\n    ]\n\n    # --- Exact Solution ---\n    def delta_exact(tau):\n        return d0 * tau**2\n\n    delta_exact_tauf = delta_exact(tauf)\n    \n    # --- Main Loop for Test Cases ---\n    final_results = []\n    for dt, p, C in test_cases:\n\n        # --- Numerical Integration Setup ---\n        # Ensure the number of steps is an integer.\n        # Use round() to handle potential float inaccuracies.\n        num_steps = int(round((tauf - tau0) / dt))\n\n        # Initial conditions from the exact solution\n        delta_naive = delta_exact(tau0)\n        delta_bal = delta_exact(tau0)\n\n        tau = tau0\n        # --- Time-stepping Loop ---\n        for _ in range(num_steps):\n            tau_next = tau + dt\n            \n            # --- Common Term (from theta) ---\n            # Midpoint rule for the integral of -theta(tau).\n            # This discretization is exact for the given quadratic solution.\n            theta_term_integral = 2 * d0 * dt * (tau + dt / 2.0)\n\n            # --- Naive-Midpoint Scheme ---\n            # Source term is derived from a finite difference of noisy potential data.\n            eta_tau = C * (dt**p) * np.sin(omega * tau)\n            eta_tau_next = C * (dt**p) * np.sin(omega * tau_next)\n            phi_num_tau = phi0 + eta_tau\n            phi_num_tau_next = phi0 + eta_tau_next\n            source_naive = 3.0 * (phi_num_tau_next - phi_num_tau)\n            \n            delta_naive += theta_term_integral + source_naive\n\n            # --- Balanced-Source Scheme ---\n            # The source term is known to be zero because the physical potential is\n            # constant. The scheme correctly incorporates this physical knowledge.\n            # source_bal = 0.0\n            \n            delta_bal += theta_term_integral\n            \n            # Update time for the next step\n            tau = tau_next\n\n        # --- Error Calculation ---\n        # The final numerical values are at tau_next, which is tauf.\n        err_naive = abs(delta_naive - delta_exact_tauf) / abs(delta_exact_tauf)\n        err_bal = abs(delta_bal - delta_exact_tauf) / abs(delta_exact_tauf)\n\n        # Round results to 12 decimal places as specified.\n        final_results.append([round(err_naive, 12), round(err_bal, 12)])\n\n    # Format the final output as a list of lists.\n    # e.g., [[err_A_naive, err_A_bal], [err_B_naive, err_B_bal], ...]\n    output_str = \"[\" + \",\".join([f\"[{e_n},{e_b}]\" for e_n, e_b in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3470344"}, {"introduction": "现在，我们将稳定性和保真度的概念结合起来，为一个经典的宇宙学问题构建一个完整的求解器。此实践将精确的空间离散化方法（傅里叶伪谱法）与稳定的时间积分器和良好平衡技术（变量变换）相结合，以模拟线性宇宙学微扰。这个总结性练习 [@problem_id:3470311] 将多种数值技术融合成一个功能性的模拟。通过成功地模拟宇宙结构的增长和衰减模式，您将开发出一个强大而精确的理论宇宙学工具。", "problem": "您需要设计并实现一种数值方法，该方法对于物质主导、空间平坦宇宙中的一维线性宇宙学微扰方程是良好平衡的。该方法必须精确维持平凡解 $ \\delta(x,\\tau)=0 $ 和 $ \\theta(x,\\tau)=0 $，同时能准确解析线性微扰的增长模和衰减模。目标是在尊重宇宙学背景的情况下，对控制性偏微分方程（PDE）在空间和时间上进行离散化，并在一组给定的初始条件下测试该方案。\n\n其基本理论基础是针对 Einstein–de Sitter 宇宙中无压强物质的牛顿极限线性微扰理论。在共形时间 $ \\tau $ 下，标度因子为 $ a(\\tau) $，共形哈勃参数为 $ \\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau) $，关于密度衬度 $ \\delta(x,\\tau) $、本动速度 $ u(x,\\tau) $ 和引力势 $ \\phi(x,\\tau) $ 的线性化一维系统为：\n- $ \\partial_{\\tau} \\delta + \\partial_{x} u = 0 $，\n- $ \\partial_{\\tau} u + \\mathcal{H} u = - \\partial_{x} \\phi $，\n- $ \\partial_{x}^{2} \\phi = \\frac{3}{2} \\mathcal{H}^{2} \\delta $。\n\n在 Einstein–de Sitter 背景下，取单位使得 $ \\tau_{0} = 1 $，并且\n- $ a(\\tau) = \\tau^{2} $，\n- $ \\mathcal{H}(\\tau) = \\frac{2}{\\tau} $，\n- $ \\partial_{x}^{2} \\phi = \\frac{6}{\\tau^{2}} \\delta $。\n\n定义速度散度 $ \\theta = \\partial_{x} u $。平凡态 $ \\delta = 0 $ 和 $ \\theta = 0 $ 是一个精确解。在傅里叶空间中，每个模式 $ \\delta_{k}(\\tau) $ 服从线性常微分方程（ODE）\n$$\n\\delta_{k}'' + \\mathcal{H} \\, \\delta_{k}' - \\frac{3}{2} \\mathcal{H}^{2} \\delta_{k} = 0,\n$$\n在此背景下，其两个线性无关解分别是增长模 $ \\delta_{k} \\propto \\tau^{2} $ 和衰减模 $ \\delta_{k} \\propto \\tau^{-3} $。\n\n算法设计要求：\n- 在周期性区域 $ x \\in [0, L] $（$ L = 2\\pi $）上使用傅里叶伪谱方法进行空间离散化。对于任意场 $ f(x) $，通过快速傅里叶变换（FFT）的微分法则 $ \\widehat{\\partial_{x} f}(k) = i k \\hat{f}(k) $ 来计算 $ \\partial_{x} f $，其中 $ k = \\frac{2\\pi n}{L} $，n 为整数。\n- 在傅里叶空间中逐个模式求解泊松方程，对于 $ k \\neq 0 $ 使用 $ \\hat{\\phi}(k) = - \\frac{6}{\\tau^{2}} \\frac{\\hat{\\delta}(k)}{k^{2}} $，并设置 $ \\hat{\\phi}(0) = 0 $。\n- 为实现能精确保持 $ \\delta = 0 $ 和 $ \\theta = 0 $ 的良好平衡时间离散化，通过引入积分因子变量 $ w = a(\\tau) u $ 来消除线性阻尼项。然后该系统变为\n  - $ \\partial_{\\tau} \\delta = - \\frac{1}{a(\\tau)} \\partial_{x} w $，\n  - $ \\partial_{\\tau} w = - a(\\tau) \\, \\partial_{x} \\phi $，\n  - $ \\partial_{x}^{2} \\phi = \\frac{6}{\\tau^{2}} \\delta $，\n  背景为 $ a(\\tau) = \\tau^{2} $。如果对通量项和源项使用一致的空间离散化，此变换可确保 $ (\\delta, w) \\equiv (0, 0) $ 是一个精确的数值平衡态。\n- 使用两步显式龙格-库塔方法（Heun 方法）在共形时间 $ \\tau $ 上进行积分。\n\n测试套件和参数：\n- 空间区域：$ L = 2\\pi $，有 $ N = 128 $ 个等距格点。所有量均为无量纲；无需物理单位。\n- 初始和最终共形时间：$ \\tau_{i} = 1 $ 和 $ \\tau_{f} = 5 $。\n- 时间步进：使用均匀时间步长，步数为 $ N_{\\text{steps}} = 2000 $。\n- 要激发的波数：$ k_{\\star} = 3 $（与周期性区域兼容的整数）。\n- 良好平衡性质的容差：$ \\text{tol}_{0} = 10^{-12} $。\n- 测试振幅：增长模振幅 $ A_{g} = 10^{-3} $，衰减模振幅 $ A_{d} = 10^{-3} $。\n- 混合模振幅：$ A_{g}^{(m)} = 7 \\times 10^{-4} $ 和 $ A_{d}^{(m)} = 3 \\times 10^{-3} $。\n\n构建以下四个测试用例：\n1. 平凡态的精确保持：设置 $ \\delta(x,\\tau_{i}) \\equiv 0 $ 和 $ u(x,\\tau_{i}) \\equiv 0 $。演化到 $ \\tau_{f} $，并计算 $ \\max\\{\\|\\delta(\\cdot,\\tau_{f})\\|_{\\infty}, \\|\\theta(\\cdot,\\tau_{f})\\|_{\\infty}\\} $。报告一个布尔值，指示该最大值是否 $ \\le \\text{tol}_{0} $。\n2. 在 $ k_{\\star} $ 处的纯增长模：初始化 $ \\delta(x,\\tau_{i}) = A_{g} \\cos(k_{\\star} x) $，并选择 $ u(x,\\tau_{i}) $ 以使只有增长模存在。对于增长分支使用 $ \\delta(\\tau) = C_{1} \\tau^{2} $ 意味着 $ \\delta'(\\tau_{i}) = 2 C_{1} \\tau_{i} = 2 A_{g} $。由于 $ \\theta = -\\delta' $ 且 $ \\theta = \\partial_{x} u $，设置 $ u(x,\\tau_{i}) = \\frac{\\theta_{\\text{amp}}}{k_{\\star}} \\sin(k_{\\star} x) $，其中 $ \\theta_{\\text{amp}} = -2 A_{g} $。演化后，将数值解 $ \\delta(x,\\tau_{f}) $ 投影到 $ \\cos(k_{\\star} x) $ 上以获得振幅 $ A_{\\text{num}} $。解析振幅为 $ A_{\\text{ana}} = A_{g} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{2} $。以浮点数形式报告相对误差 $ \\left| A_{\\text{num}} - A_{\\text{ana}} \\right| / \\left| A_{\\text{ana}} \\right| $。\n3. 在 $ k_{\\star} $ 处的纯衰减模：初始化 $ \\delta(x,\\tau_{i}) = A_{d} \\cos(k_{\\star} x) $，并选择 $ u(x,\\tau_{i}) $ 以使只有衰减模存在。使用 $ \\delta(\\tau) = C_{2} \\tau^{-3} $ 意味着 $ \\delta'(\\tau_{i}) = -3 C_{2} \\tau_{i}^{-4} = -3 A_{d} $。设置 $ \\theta_{\\text{amp}} = -\\delta'(\\tau_{i}) = 3 A_{d} $ 和 $ u(x,\\tau_{i}) = \\frac{\\theta_{\\text{amp}}}{k_{\\star}} \\sin(k_{\\star} x) $。演化后，将 $ \\delta(x,\\tau_{f}) $ 投影到 $ \\cos(k_{\\star} x) $ 上得到 $ A_{\\text{num}} $。解析振幅为 $ A_{\\text{ana}} = A_{d} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{-3} $。以浮点数形式报告相对误差。\n4. 在相同 $ k_{\\star} $ 处的混合增长和衰减模：设置 $ \\delta(x,\\tau_{i}) = \\left(A_{g}^{(m)} + A_{d}^{(m)}\\right) \\cos(k_{\\star} x) $ 和 $ u(x,\\tau_{i}) = \\frac{-2 A_{g}^{(m)} + 3 A_{d}^{(m)}}{k_{\\star}} \\sin(k_{\\star} x) $。演化后，将 $ \\delta(x,\\tau_{f}) $ 投影到 $ \\cos(k_{\\star} x) $ 上得到 $ A_{\\text{num}} $。解析振幅为 $ A_{\\text{ana}} = A_{g}^{(m)} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{2} + A_{d}^{(m)} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{-3} $。以浮点数形式报告相对误差。\n\n输出规范：\n- 您的程序必须运行这四个测试，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：$ [\\text{wb\\_ok}, \\text{err\\_grow}, \\text{err\\_decay}, \\text{err\\_mix}] $，其中 $ \\text{wb\\_ok} $ 是一个布尔值，误差是浮点数。\n- 所有量均为无量纲；无需物理单位。\n- 角度参数以弧度为单位。\n\n您的最终结果必须是一个完整且可运行的程序，实现所述的离散化和测试，无需任何用户输入或外部文件。程序必须仅使用指定的库，并严格按照描述的格式打印结果。", "solution": "该问题要求为物质主导的 Einstein–de Sitter 宇宙中的一维线性宇宙学微扰方程设计并实现一个良好平衡的数值格式。该格式必须通过四个特定的测试用例进行验证：保持平凡解，以及精确演化纯增长、纯衰减和混合微扰模式。\n\n在共形时间 $\\tau$ 下，关于密度衬度 $\\delta(x,\\tau)$ 和本动速度 $u(x,\\tau)$ 的控制方程是：\n$$ \\partial_{\\tau} \\delta + \\partial_{x} u = 0 $$\n$$ \\partial_{\\tau} u + \\mathcal{H} u = - \\partial_{x} \\phi $$\n$$ \\partial_{x}^{2} \\phi = \\frac{3}{2} \\mathcal{H}^{2} \\delta $$\n在指定的 Einstein–de Sitter 背景中，标度因子为 $a(\\tau) = \\tau^2$，共形哈勃参数为 $\\mathcal{H}(\\tau) = 2/\\tau$，这使得泊松方程简化为 $\\partial_{x}^{2} \\phi = (6/\\tau^2) \\delta$。欧拉方程中的 $\\mathcal{H} u$ 项是一个阻尼项，在试图保持平衡态 $\\delta=0, u=0$ 时可能引入数值误差。\n\n一个良好平衡的格式是指能够精确（在机器精度范围内）保持已知稳态解或平衡解的格式。为实现这一点，我们遵循问题的指示并变换变量。我们引入 $w = a(\\tau) u$。原始变量 $(\\delta, u)$ 的时间导数与新变量 $w$ 的关系如下：\n$\\partial_{\\tau} u = \\partial_{\\tau} (w/a) = (1/a)\\partial_{\\tau} w - (a'/a^2)w = (1/a)\\partial_{\\tau}w - (\\mathcal{H}/a)w$。\n将此代入欧拉方程：\n$$ \\frac{1}{a}\\partial_{\\tau}w - \\frac{\\mathcal{H}}{a}w + \\mathcal{H}u = -\\partial_x \\phi $$\n$$ \\frac{1}{a}\\partial_{\\tau}w - \\frac{\\mathcal{H}}{a}w + \\frac{\\mathcal{H}}{a}w = -\\partial_x \\phi $$\n$$ \\partial_{\\tau}w = -a(\\tau)\\partial_x \\phi $$\n连续性方程变为 $\\partial_{\\tau}\\delta = -\\partial_x u = -\\partial_x(w/a) = -(1/a)\\partial_x w$。\n这样就得到了需要求解的变换后的系统：\n$$ \\partial_{\\tau} \\delta = - \\frac{1}{a(\\tau)} \\partial_{x} w $$\n$$ \\partial_{\\tau} w = - a(\\tau) \\, \\partial_{x} \\phi $$\n$$ \\partial_{x}^{2} \\phi = \\frac{6}{\\tau^{2}} \\delta $$\n在这种形式下，如果 $\\delta=0$ 和 $w=0$，那么 $\\phi=0$（由泊松方程得出），因此 $\\delta$ 和 $w$ 演化方程的右端项恒为零。这确保了对这些方程进行一致离散化的数值格式将保持 $(\\delta, w) = (0,0)$ 的状态。\n\n数值实现过程如下：\n\n**1. 空间离散化：傅里叶伪谱方法**\n空间区域是周期性的，$x \\in [0, L]$，$L=2\\pi$，用 $N=128$ 个点 $x_j = j L/N$（$j=0, \\dots, N-1$）进行离散化。这种选择使得傅里叶方法异常准确。空间导数 $\\partial_x f(x)$ 在傅里叶空间中计算。一个函数 $f(x)$ 通过快速傅里叶变换（FFT）得到其傅里叶系数 $\\hat{f}(k_n)$。导数的傅里叶系数则由 $\\widehat{\\partial_x f}(k_n) = i k_n \\hat{f}(k_n)$ 给出，其中 $k_n$ 是离散波数。实空间中的导数 $\\partial_x f(x)$ 通过应用逆 FFT 恢复。波数为 $k_n = 2\\pi n / L = n$，因为 $L=2\\pi$。\n\n泊松方程 $\\partial_{x}^{2} \\phi = (6/\\tau^2) \\delta$ 在傅里叶空间中变成一个代数方程：\n$$ (i k_n)^2 \\hat{\\phi}(k_n) = -k_n^2 \\hat{\\phi}(k_n) = \\frac{6}{\\tau^2} \\hat{\\delta}(k_n) $$\n对于 $k_n \\neq 0$ 的模式，势可以解为 $\\hat{\\phi}(k_n) = -\\frac{6}{\\tau^2} \\frac{\\hat{\\delta}(k_n)}{k_n^2}$。对于平均模式 $k_n=0$，我们按要求设置 $\\hat{\\phi}(0)=0$。\n\n**2. 时间离散化：Heun 方法**\n我们使用一个两步显式龙格-库塔格式（Heun 方法）来将状态向量 $Y = [\\delta, w]$ 从时间 $\\tau_n$ 推进到 $\\tau_{n+1} = \\tau_n + \\Delta\\tau$。令我们系统方程组的右端项为 $F(Y, \\tau) = [\\dot{\\delta}, \\dot{w}]$。\n更新规则是：\n1. **预测步：** $Y^* = Y_n + \\Delta\\tau F(Y_n, \\tau_n)$\n2. **校正步：** $Y_{n+1} = Y_n + \\frac{\\Delta\\tau}{2} \\left[ F(Y_n, \\tau_n) + F(Y^*, \\tau_n + \\Delta\\tau) \\right]$\n\n**3. 算法实现与测试用例**\n模拟从 $\\tau_i=1$ 运行到 $\\tau_f=5$，步数为 $N_{\\text{steps}}=2000$，时间步长为 $\\Delta\\tau = (\\tau_f - \\tau_i)/N_{\\text{steps}} = 0.002$。\n\n- **测试 1（平凡态）：** 我们初始化 $\\delta(x, \\tau_i)=0$ 和 $u(x, \\tau_i)=0$。因为 $a(\\tau_i)=\\tau_i^2 = 1$，初始的 $w(x, \\tau_i)$ 也为 $0$。模拟演化到 $\\tau_f$。最终的速度散度 $\\theta(\\cdot, \\tau_f) = \\partial_x u(\\cdot, \\tau_f)$ 从最终状态 $w(\\cdot, \\tau_f)$ 通过 $u_f = w_f / a(\\tau_f)$ 和谱方法微分计算得出。如果 $\\max\\{\\|\\delta_f\\|_{\\infty}, \\|\\theta_f\\|_{\\infty}\\} \\le 10^{-12}$，结果为 `True`。\n\n- **测试 2（增长模）：** 初始条件设置为波数 $k_{\\star}=3$、振幅 $A_g=10^{-3}$ 的纯增长模。关系 $\\theta = -\\partial_\\tau \\delta$ 和增长模形式 $\\delta \\propto \\tau^2$ 意味着 $\\theta(\\tau_i)=-2\\delta(\\tau_i)/\\tau_i = -2A_g$（因为 $\\tau_i=1$）。初始状态是 $\\delta(x, \\tau_i) = A_g \\cos(k_{\\star} x)$ 和 $u(x, \\tau_i) = \\frac{-2A_g}{k_{\\star}} \\sin(k_{\\star} x)$。状态演化到 $\\tau_f$。最终密度衬度 $\\delta(\\cdot, \\tau_f)$ 中的数值振幅 $A_{\\text{num}}$ 通过将其投影到 $\\cos(k_{\\star}x)$ 上找到。这可以通过 FFT 高效完成：对于实信号，$\\cos(k_{\\star}x)$ 分量的振幅由 $\\frac{2}{N}\\text{Re}(\\hat\\delta_f[k_{\\star}])$ 给出。解析振幅为 $A_{\\text{ana}} = A_g (\\tau_f/\\tau_i)^2$。报告相对误差。\n\n- **测试 3（衰减模）：** 这类似于测试 2。对于衰减模 $\\delta \\propto \\tau^{-3}$，我们有 $\\theta(\\tau_i)=-(-3)\\delta(\\tau_i)/\\tau_i=3A_d$。初始条件为 $\\delta(x, \\tau_i) = A_d \\cos(k_{\\star} x)$ 和 $u(x, \\tau_i) = \\frac{3A_d}{k_{\\star}} \\sin(k_{\\star} x)$，其中 $A_d=10^{-3}$。解析的最终振幅是 $A_{\\text{ana}} = A_d (\\tau_f/\\tau_i)^{-3}$。报告相对误差。\n\n- **测试 4（混合模）：** 初始条件是增长模和衰减模的线性叠加：$\\delta(x, \\tau_i) = (A_g^{(m)} + A_d^{(m)}) \\cos(k_{\\star}x)$，并相应地设置 $u(x, \\tau_i)$。最终的数值振幅与解析解 $A_{\\text{ana}} = A_{g}^{(m)} (\\tau_f/\\tau_i)^{2} + A_{d}^{(m)} (\\tau_f/\\tau_i)^{-3}$进行比较。报告相对误差。\n\n实现将这些原理结合到一个程序中，该程序运行所有四个测试并以指定格式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear cosmological perturbation equations using a\n    well-balanced Fourier pseudo-spectral scheme and Heun's method for time integration.\n    \"\"\"\n    \n    # Define parameters from the problem statement.\n    L = 2.0 * np.pi\n    N = 128\n    tau_i = 1.0\n    tau_f = 5.0\n    N_steps = 2000\n    k_star = 3\n    tol_0 = 1e-12\n    A_g = 1e-3\n    A_d = 1e-3\n    A_g_m = 7e-4\n    A_d_m = 3e-3\n\n    # Spatial grid and wavenumbers\n    x = np.linspace(0, L, N, endpoint=False)\n    dx = L / N\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Time step\n    dt = (tau_f - tau_i) / N_steps\n\n    # Precompute the k^-2 operator for the Poisson solve\n    k_sq_inv = np.zeros_like(k)\n    nonzero_k_mask = k != 0\n    k_sq_inv[nonzero_k_mask] = 1.0 / (k[nonzero_k_mask]**2)\n\n    def get_rhs(delta, w, tau):\n        \"\"\"\n        Computes the right-hand side of the transformed system for (delta, w).\n        d(delta)/d(tau) = - (1/a) * d_x(w)\n        d(w)/d(tau)     = - a * d_x(phi)\n        \"\"\"\n        # Transform state variables to Fourier space\n        delta_hat = np.fft.fft(delta)\n        w_hat = np.fft.fft(w)\n\n        # Solve Poisson equation for phi_hat in Fourier space\n        # phi_hat(k) = - (6/tau^2) * delta_hat(k) / k^2\n        phi_hat = - (6.0 / tau**2) * delta_hat * k_sq_inv\n        \n        # Compute spatial derivatives in Fourier space\n        # d_x(f_hat) = ik * f_hat\n        dx_w_hat = 1j * k * w_hat\n        dx_phi_hat = 1j * k * dx_phi_hat\n\n        # Transform derivatives back to real space\n        dx_w = np.fft.ifft(dx_w_hat).real\n        dx_phi = np.fft.ifft(dx_phi_hat).real\n\n        # Scale factor a(tau) = tau^2\n        a_tau = tau**2\n\n        # Compute time derivatives\n        d_delta_dt = - (1.0 / a_tau) * dx_w\n        d_w_dt = - a_tau * dx_phi\n\n        return d_delta_dt, d_w_dt\n\n    def evolve(delta_0, w_0):\n        \"\"\"\n        Evolves the system from tau_i to tau_f using Heun's method.\n        \"\"\"\n        delta = delta_0.copy()\n        w = w_0.copy()\n        tau = tau_i\n\n        for _ in range(N_steps):\n            # Stage 1 (Predictor)\n            k1_delta, k1_w = get_rhs(delta, w, tau)\n            delta_star = delta + dt * k1_delta\n            w_star = w + dt * k1_w\n            \n            # Stage 2 (Corrector)\n            k2_delta, k2_w = get_rhs(delta_star, w_star, tau + dt)\n            \n            # Update state variables\n            delta += (dt / 2.0) * (k1_delta + k2_delta)\n            w += (dt / 2.0) * (k1_w + k2_w)\n            tau += dt\n            \n        return delta, w\n\n    results = []\n\n    # --- Test 1: Exact preservation of the trivial state ---\n    delta_0_t1 = np.zeros(N)\n    u_0_t1 = np.zeros(N)\n    w_0_t1 = u_0_t1 * (tau_i**2)\n    delta_f, w_f = evolve(delta_0_t1, w_0_t1)\n    \n    # Compute final velocity divergence theta\n    u_f = w_f / (tau_f**2)\n    u_f_hat = np.fft.fft(u_f)\n    theta_f_hat = 1j * k * u_f_hat\n    theta_f = np.fft.ifft(theta_f_hat).real\n    \n    max_err = max(np.max(np.abs(delta_f)), np.max(np.abs(theta_f)))\n    results.append(max_err = tol_0)\n\n    # --- Function to run a test and compute relative error ---\n    def run_and_get_error(delta_0, u_0, A_ana):\n        w_0 = u_0 * (tau_i**2)\n        delta_f, _ = evolve(delta_0, w_0)\n        delta_f_hat = np.fft.fft(delta_f)\n        # Amplitude of cos(k*x) is (2/N) * Re(fft[k]) for real signals\n        A_num = (2.0 / N) * delta_f_hat[k_star].real\n        return np.abs(A_num - A_ana) / np.abs(A_ana)\n\n    # --- Test 2: Pure growing mode ---\n    delta_0_g = A_g * np.cos(k_star * x)\n    u_0_g = (-2.0 * A_g / k_star) * np.sin(k_star * x)\n    A_ana_g = A_g * (tau_f / tau_i)**2\n    err_grow = run_and_get_error(delta_0_g, u_0_g, A_ana_g)\n    results.append(err_grow)\n\n    # --- Test 3: Pure decaying mode ---\n    delta_0_d = A_d * np.cos(k_star * x)\n    u_0_d = (3.0 * A_d / k_star) * np.sin(k_star * x)\n    A_ana_d = A_d * (tau_f / tau_i)**(-3.0)\n    err_decay = run_and_get_error(delta_0_d, u_0_d, A_ana_d)\n    results.append(err_decay)\n    \n    # --- Test 4: Mixed growing and decaying mode ---\n    delta_0_m = (A_g_m + A_d_m) * np.cos(k_star * x)\n    u_0_m = ((-2.0 * A_g_m + 3.0 * A_d_m) / k_star) * np.sin(k_star * x)\n    A_ana_m = A_g_m * (tau_f / tau_i)**2 + A_d_m * (tau_f / tau_i)**(-3.0)\n    err_mix = run_and_get_error(delta_0_m, u_0_m, A_ana_m)\n    results.append(err_mix)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```", "id": "3470311"}]}