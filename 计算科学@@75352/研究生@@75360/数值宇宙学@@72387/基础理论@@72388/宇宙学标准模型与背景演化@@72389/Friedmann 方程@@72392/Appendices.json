{"hands_on_practices": [{"introduction": "深入研究数值宇宙学的第一步，是求解宇宙标度因子 $a(t)$ 的基本演化方程。本练习旨在通过编写一个数值求解器来解决 $da/dt = aH(a)$ 这个核心常微分方程，从而巩固这一基本功。为了验证我们数值解的准确性，我们将把它与已知的、由单一组分（如辐射、物质或宇宙学常数）主导的宇宙的解析解进行比较 [@problem_id:3495819]。", "problem": "考虑一个由弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规描述并由弗里德曼膨胀定律支配的空间均匀且各向同性的宇宙。令 $a(t)$ 表示尺度因子，并通过 $H(a) = \\dot{a}/a$ 定义哈勃率 $H(a)$。$H(a)$ 的演化由弗里德曼方程决定，该方程将膨胀率与总能量密度、空间曲率和宇宙学常数联系起来。总能量密度可以建模为具有恒定状态方程参数 $w$ 的无相互作用的理想流体组分之和，对于这些组分，能量守恒定律意味着其能量密度随尺度因子存在一个标度律。此外，空间曲率和宇宙学常数分别通过曲率项和一个常数项对等式右侧产生加性贡献。\n\n您的任务是设计并实现一个数值求解器，用于计算 $H(a)$ 并对指定单组分宇宙的常微分方程 (ODE) 进行积分，\n$$\n\\frac{da}{dt} = a \\, H(a),\n$$\n然后，您必须将 $a(t)$ 的数值解与适用于单组分情况的解析推导解进行对比验证。程序必须在无量纲归一化下运行，其中所有常数都经过选择，使得特征膨胀尺度为 1 的量级；最终的数值输出不需要物理单位。所有输出都必须是无量纲的，并且本问题不涉及角度。\n\n使用的基本原理：\n- 弗里德曼方程，在所选的归一化下可以写为\n$$\nH(a)^2 = \\sum_i C_i \\, a^{-3(1+w_i)} - \\frac{k}{a^2} + L,\n$$\n其中 $C_i$ 是对应于状态方程参数为 $w_i$ 的理想流体组分的非负常数，$k$ 是空间曲率参数，$L$ 是一个与宇宙学常数项成正比的常数。\n- 在膨胀的 FLRW 宇宙中，对于状态方程参数 $w$ 为常数的理想流体，能量守恒定律意味着\n$$\n\\rho(a) \\propto a^{-3(1+w)}.\n$$\n在问题陈述中，不应假定任何其他快捷公式；所有用于验证的解析表达式都必须在您的解答中从这些基本原理推导出来。\n\n算法要求：\n1. 实现一个函数，用于根据给定的 $(C_i, w_i)$、$k$ 和 $L$ 计算 $H(a)$。\n2. 从指定的初始时间 $t_0$ 和初始尺度因子 $a(t_0) = a_0$ 开始，对常微分方程 $da/dt = a H(a)$ 进行随时间 $t$ 的正向积分。\n3. 推导并实现适用于单组分情况的 $a(t)$ 解析解，以验证数值积分。使用这些解析表达式在 $t_0$ 设置一致的初始条件，并计算指定时间的验证目标。\n\n测试套件：\n您必须在以下三个单组分情况下运行您的程序。对于每种情况，计算在 $t_{\\text{eval}}$ 中列出的时间点的数值解 $a_{\\text{num}}(t)$，计算相应的解析解 $a_{\\text{ana}}(t)$，并报告在 $t_{\\text{eval}}$ 时间点上的最大相对误差，\n$$\n\\max_{t \\in t_{\\text{eval}}} \\left| \\frac{a_{\\text{num}}(t) - a_{\\text{ana}}(t)}{a_{\\text{ana}}(t)} \\right|.\n$$\n\n- 情况 A (单辐射组分)：\n  - 一个组分，其 $(C, w) = (1.0, 1/3)$。\n  - 空间曲率 $k = 0.0$。\n  - 宇宙学常数项 $L = 0.0$。\n  - 初始时间 $t_0 = 0.01$。\n  - 初始尺度因子 $a_0$ 必须等于您解答中推导出的在 $t_0$ 时的解析值。\n  - 验证时间 $t_{\\text{eval}} = [0.05, 0.1, 1.0]$。\n\n- 情况 B (单无压物质组分)：\n  - 一个组分，其 $(C, w) = (1.0, 0.0)$。\n  - 空间曲率 $k = 0.0$。\n  - 宇宙学常数项 $L = 0.0$。\n  - 初始时间 $t_0 = 0.01$。\n  - 初始尺度因子 $a_0$ 必须等于您解答中推导出的在 $t_0$ 时的解析值。\n  - 验证时间 $t_{\\text{eval}} = [0.05, 0.1, 1.0]$。\n\n- 情况 C (纯宇宙学常数)：\n  - 无流体组分。\n  - 空间曲率 $k = 0.0$。\n  - 宇宙学常数项 $L = 1.0$。\n  - 初始时间 $t_0 = 0.0$。\n  - 初始尺度因子 $a_0 = 1.0$。\n  - 验证时间 $t_{\\text{eval}} = [0.05, 0.1, 1.0]$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含三个最大相对误差（每种情况一个），以逗号分隔的列表形式并用方括号括起来（例如，\"[e_A,e_B,e_C]\"）。每个条目必须是浮点数。不得打印任何其他文本。", "solution": "该问题要求设计并实现一个数值求解器，用于求解由弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规描述的空间均匀且各向同性的宇宙中的尺度因子 $a(t)$。$a(t)$ 的演化由第一弗里德曼方程和哈勃率的定义共同决定，它们组合成一个一阶常微分方程 (ODE)。然后，必须将数值解与针对特定单组分宇宙的解析解进行对比验证。\n\n基本的控制方程是尺度因子的常微分方程，\n$$\n\\frac{da}{dt} = a(t) H(a(t))\n$$\n以及定义哈勃率 $H(a)$ 的弗里德曼方程：\n$$\nH(a)^2 = \\sum_i C_i \\, a^{-3(1+w_i)} - \\frac{k}{a^2} + L\n$$\n此处，$C_i$ 是代表状态方程为 $w_i$ 的理想流体组分能量密度的常数，$k$ 是空间曲率参数，$L$ 代表宇宙学常数。问题指定在无量纲系统中进行评估。\n\n任务的核心是首先在简化的单组分宇宙中推导出 $a(t)$ 的解析解，然后使用这些解来验证通用常微分方程的数值积分。\n\n**1. 解析解的推导**\n\n为了找到 $a(t)$ 的解析解，我们将常微分方程重新整理为 $dt = \\frac{da}{a H(a)}$ 并进行积分。$H(a)$ 的形式由存在的特定宇宙学组分决定。我们考虑指定的三个单组分测试情况。\n\n**情况 A：辐射主导的宇宙**\n在这种情况下，宇宙仅包含一个辐射组分，其 $(C, w) = (1.0, 1/3)$，并且空间曲率为零 ($k=0$)，没有宇宙学常数 ($L=0$)。弗里德曼方程简化为：\n$$\nH(a)^2 = C a^{-3(1+w)} = (1.0) a^{-3(1+1/3)} = a^{-4}\n$$\n假设宇宙正在膨胀，我们取哈勃率的正根，即 $H(a) = a^{-2}$。尺度因子的常微分方程变为：\n$$\n\\frac{da}{dt} = a H(a) = a \\cdot a^{-2} = a^{-1}\n$$\n我们通过分离变量法求解此方程：\n$$\na \\, da = dt\n$$\n对两边积分，$\\int a' \\, da' = \\int dt'$，得到 $\\frac{1}{2}a^2 = t + K$，其中 $K$ 是一个积分常数。通过选择时间原点使得 $a(0)=0$，我们令 $K=0$。这给出了解析解：\n$$\na_{\\text{ana}}(t) = \\sqrt{2t}\n$$\n对于这种情况，初始时间是 $t_0 = 0.01$。初始尺度因子 $a_0$ 必须与解析解一致，因此 $a_0 = a_{\\text{ana}}(t_0) = \\sqrt{2 \\cdot 0.01} = \\sqrt{0.02}$。\n\n**情况 B：物质主导的宇宙**\n这种情况考虑一个只含无压物质的宇宙，其 $(C, w) = (1.0, 0.0)$，同样 $k=0$ 且 $L=0$。弗里德曼方程为：\n$$\nH(a)^2 = C a^{-3(1+w)} = (1.0) a^{-3(1+0)} = a^{-3}\n$$\n取正根，得 $H(a) = a^{-3/2}$。尺度因子的常微分方程为：\n$$\n\\frac{da}{dt} = a H(a) = a \\cdot a^{-3/2} = a^{-1/2}\n$$\n分离变量得到：\n$$\na^{1/2} \\, da = dt\n$$\n积分 $\\int (a')^{1/2} \\, da' = \\int dt'$ 得到 $\\frac{2}{3}a^{3/2} = t + K$。同样选择 $a(0)=0$ 使积分常数 $K=0$，从而得出解析解：\n$$\na_{\\text{ana}}(t) = \\left(\\frac{3}{2} t\\right)^{2/3}\n$$\n初始时间是 $t_0 = 0.01$，所以一致的初始尺度因子是 $a_0 = a_{\\text{ana}}(t_0) = (\\frac{3}{2} \\cdot 0.01)^{2/3} = (0.015)^{2/3}$。\n\n**情况 C：宇宙学常数主导的宇宙**\n这种情况没有流体组分，$k=0$，并且有一个非零的宇宙学常数项 $L=1.0$。弗里德曼方程简化为：\n$$\nH(a)^2 = L = 1.0\n$$\n哈勃率是常数：$H(a) = \\sqrt{L} = 1$。尺度因子的常微分方程为：\n$$\n\\frac{da}{dt} = a H(a) = a\n$$\n分离变量得到 $\\frac{da}{a} = dt$。从初始时间 $t_0$ 和尺度因子 $a_0$ 积分到稍后的时间 $t$ 得到：\n$$\n\\int_{a_0}^{a(t)} \\frac{da'}{a'} = \\int_{t_0}^{t} dt' \\implies \\ln\\left(\\frac{a(t)}{a_0}\\right) = t - t_0\n$$\n因此，解析解呈指数增长：\n$$\na_{\\text{ana}}(t) = a_0 e^{t - t_0}\n$$\n对于这种情况，初始条件明确给出为 $t_0=0.0$ 和 $a_0=1.0$。解析解简化为 $a_{\\text{ana}}(t) = e^t$，这是一致的，因为 $a_{\\text{ana}}(0)=e^0=1.0$。\n\n**2. 数值积分与验证**\n\n数值解是通过使用标准数值求解器对常微分方程 $\\frac{da}{dt} = a H(a)$ 进行积分得到的。SciPy 库中的 `scipy.integrate.solve_ivp` 函数是一个合适的选择，它提供了高阶龙格-库塔方法的稳健实现。\n\n对于每个测试情况：\n1. 根据特定情况的参数 $(C, w, k, L)$，定义一个代表常微分方程右侧 $f(t, a) = a H(a)$ 的 Python 函数。\n2. 设置初始条件 $(t_0, a_0)$。对于情况 A 和 B，$a_0$ 是根据各自在 $t_0$ 时的解析解计算的。对于情况 C，它是直接给出的。\n3. 调用 `solve_ivp` 将常微分方程从 $t_0$ 积分到 $t_{\\text{eval}}$ 中的最大时间，并请求在 $t_{\\text{eval}}$ 中列出的特定时间点的解值。为确保高精度，指定了严格的误差容限（例如，相对容限 `rtol` 和绝对容限 `atol` 为 $10^{-12}$）。\n4. 从求解器的输出中获得数值解 $a_{\\text{num}}(t)$。\n5. 在同一组时间点 $t_{\\text{eval}}$ 上计算解析解 $a_{\\text{ana}}(t)$。\n6. 然后根据以下公式计算最大相对误差：\n$$\n\\text{error} = \\max_{t \\in t_{\\text{eval}}} \\left| \\frac{a_{\\text{num}}(t) - a_{\\text{ana}}(t)}{a_{\\text{ana}}(t)} \\right|\n$$\n这个误差量化了数值结果与精确解析解的偏差，并作为验证指标。预期的误差应该非常小，与求解器的容限在同一数量级。\n\n该过程应用于三个指定的情况：\n- **情况 A:** $(C, w)=(1.0, 1/3), k=0, L=0$。初始条件: $t_0=0.01, a_0=a_{\\text{ana}}(0.01)$。\n- **情况 B:** $(C, w)=(1.0, 0), k=0, L=0$。初始条件: $t_0=0.01, a_0=a_{\\text{ana}}(0.01)$。\n- **情况 C:** 无流体, $k=0, L=1.0$。初始条件: $t_0=0.0, a_0=1.0$。\n\n最终输出是每种情况的最大相对误差列表。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the scale factor a(t) in single-component universes,\n    validates against analytic solutions, and reports the maximum relative error.\n    \"\"\"\n\n    # Define the three test cases as specified in the problem statement.\n    # Each tuple contains:\n    # (C, w, k, L, t0, a0 (or None if derived), t_eval, analytic_func)\n    test_cases = [\n        # Case A: Radiation-dominated\n        (\n            1.0, 1.0/3.0, 0.0, 0.0, 0.01, None,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: np.sqrt(2.0 * t)\n        ),\n        # Case B: Matter-dominated\n        (\n            1.0, 0.0, 0.0, 0.0, 0.01, None,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: (1.5 * t)**(2.0/3.0)\n        ),\n        # Case C: Cosmological constant-dominated\n        (\n            0.0, 0.0, 0.0, 1.0, 0.0, 1.0,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: np.exp(t)\n        )\n    ]\n\n    results = []\n\n    for case in test_cases:\n        C, w, k, L, t0, a0_val, t_eval, a_analytic_func = case\n\n        # Set the initial scale factor a0.\n        # If a0_val is not provided, compute it from the analytic solution at t0.\n        if a0_val is None:\n            a0 = a_analytic_func(t0)\n        else:\n            a0 = a0_val\n\n        # Define the ODE: da/dt = a * H(a)\n        def dadt(t, y):\n            a = y[0]\n            \n            # Guard against non-positive scale factor due to numerical errors.\n            # a > 0 for all cases considered.\n            if a = 0:\n                return [0.0]\n\n            # Calculate H(a)^2 from the Friedmann equation.\n            # Handle potential negative values from numerical precision issues.\n            h_squared = C * a**(-3.0 * (1.0 + w)) - k * a**(-2.0) + L\n            if h_squared  0:\n                h_squared = 0.0\n\n            H = np.sqrt(h_squared)\n            return [a * H]\n\n        # Set up integration time span and initial conditions.\n        t_span = (t0, t_eval[-1])\n        y0 = [a0]\n\n        # Use a high-precision solver to integrate the ODE.\n        # rtol and atol are set to small values to minimize solver error.\n        sol = solve_ivp(\n            dadt,\n            t_span,\n            y0,\n            t_eval=t_eval,\n            method='DOP853', # A high-order accurate solver\n            rtol=1e-13,\n            atol=1e-13\n        )\n\n        # Extract the numerical solution at the evaluation times.\n        a_numerical = sol.y[0]\n\n        # Compute the analytic solution at the evaluation times for validation.\n        a_analytical = a_analytic_func(t_eval)\n\n        # Calculate the maximum relative error.\n        # Guard against division by zero if an analytic value is zero (not the case here).\n        relative_errors = np.abs((a_numerical - a_analytical) / a_analytical)\n        max_relative_error = np.max(relative_errors)\n        \n        results.append(max_relative_error)\n\n    # Print the results in the specified format.\n    print(f\"[{','.join(f'{err:.10e}' for err in results)}]\")\n\nsolve()\n```", "id": "3495819"}, {"introduction": "掌握了如何模拟宇宙的膨胀历史后，下一步便是计算那些连接理论与观测的物理量，例如宇宙学距离。本练习专注于横向共动距离 $S_k(\\chi)$ 的计算，它是构建各种距离度规（如光度距离和角直径距离）的关键组成部分。本练习将引导你开发一个数值稳健的算法，并特别关注在处理不同宇宙几何（尤其是近乎平坦的宇宙）时可能出现的数值问题 [@problem_id:3495804]。", "problem": "你需要实现一个数值上鲁棒的横向共动距离函数 $S_k(\\chi)$ 的求值方法。该函数出现在均匀各向同性宇宙的弗里德曼-罗伯逊-沃尔克 (FRW) 度规的空间部分。请使用以下基本依据。\n\n1. 弗里德曼方程通过无量纲哈勃函数 $E(z)$ 定义了宇宙的膨胀率，其中 $E(z) = H(z)/H_0$，$H_0$ 是哈勃常数。对于一个物质密度参数为 $\\Omega_m$、宇宙学常数密度参数为 $\\Omega_\\Lambda$、曲率密度参数为 $\\Omega_k$ 的宇宙，假设 $E(z)$ 的形式为\n$$\nE(z) = \\sqrt{\\Omega_m (1+z)^3 + \\Omega_k (1+z)^2 + \\Omega_\\Lambda}.\n$$\n本问题中忽略辐射。\n\n2. 视线共动距离 $\\chi(z)$ 定义为\n$$\n\\chi(z) = \\int_{0}^{z} \\frac{dz'}{E(z')}.\n$$\n\n3. FRW 空间切片的三维空间曲率常数为 $k_\\text{geom}$，它与曲率密度参数的关系是\n$$\nk_\\text{geom} = -\\Omega_k \\frac{H_0^2}{c^2}.\n$$\n\n4. 横向共动距离函数 $S_k(\\chi)$ 是以下常微分方程的唯一解\n$$\n\\frac{d^2 S_k}{d\\chi^2} + k_\\text{geom}\\, S_k = 0,\n$$\n其初始条件为 $S_k(0) = 0$ 和 $\\left.\\frac{d S_k}{d\\chi}\\right|_{\\chi=0} = 1$。\n\n你的任务是：\n\n- 推导一个数值稳定的算法来计算通用 $k_\\text{geom}$ 和 $\\chi$ 下的 $S_k(\\chi)$，特别注意 $k_\\text{geom} \\to 0$、大参数和数值对消等边界情况。在一个完整的、可运行的程序中实现该算法，该程序通过对 $\\chi(z)$ 的积分，从给定的宇宙学参数计算出 $S_k(\\chi(z))$。\n\n- 假设使用自然单位制，其中 $c/H_0 = 1$，因此所有距离都是无量纲的，你的输出也是无量纲数。不需要角度单位或物理单位转换。\n\n- 讨论并从算法上解决定义域和数值问题：$S_k(\\chi)$ 在 $k_\\text{geom}=0$ 处的连续性、$k_\\text{geom} > 0$ 和 $k_\\text{geom}  0$ 时的行为、小 $|k_\\text{geom}|\\chi^2$ 时的对消问题，以及当出现双曲函数时大 $|k_\\text{geom}|^{1/2}\\chi$ 带来的溢出风险。\n\n设计一个包含以下参数集的测试套件来评估你的实现：\n\n- 情况 A (理想情况，平坦宇宙): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 0.0, 2.0)$。输出 $S_k(\\chi(z))$ 的浮点数值。\n\n- 情况 B (闭合宇宙): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.75, -0.05, 2.0)$，其中 $k_\\text{geom} > 0$。输出 $S_k(\\chi(z))$ 的浮点数值。\n\n- 情况 C (开放宇宙): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.65, 0.05, 2.0)$，其中 $k_\\text{geom}  0$。输出 $S_k(\\chi(z))$ 的浮点数值。\n\n- 情况 D (近似平坦连续性检查): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 10^{-12}, 2.0)$。计算 $S_k(\\chi(z))$ 和 $\\chi(z)$，并输出一个布尔值，指示它们的相对差异是否满足 $\\left|S_k(\\chi) - \\chi\\right|/\\max(1,\\chi)  10^{-10}$。\n\n- 情况 E (零距离边界): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 0.0, 0.0)$。输出一个布尔值，指示 $S_k(\\chi(0)) = 0$ 是否在机器精度范围内成立。\n\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC,resultD,resultE]”）。输出必须按上述情况的顺序列出。前三个条目必须是浮点数，第四和第五个条目必须是布尔值。不应打印任何额外文本。", "solution": "用户需要一个数值上鲁棒的实现，用于计算宇宙学中使用的横向共动距离函数 $S_k(\\chi)$。解决方案涉及通过数值积分计算视线共动距离 $\\chi(z)$，然后利用其解析形式计算 $S_k(\\chi)$，并特别注意在接近平坦时（$k_\\text{geom} \\to 0$）的数值稳定性。\n\n该问题的基本原理源于均匀各向同性宇宙的弗里德曼-罗伯逊-沃尔克 (FRW) 模型。推导过程分为几个步骤：求解 $S_k(\\chi)$ 的定义微分方程，分析解的数值性质，并设计一个鲁棒的算法。\n\n**1. 公式化与简化**\n\n问题提供了必要的定义。无量纲哈勃函数为：\n$$\nE(z) = \\sqrt{\\Omega_m (1+z)^3 + \\Omega_k (1+z)^2 + \\Omega_\\Lambda}\n$$\n到红移 $z$ 的视线共动距离 $\\chi$ 是光速的共动积分：\n$$\n\\chi(z) = \\int_{0}^{z} \\frac{dz'}{E(z')}\n$$\n横向共动距离 $S_k(\\chi)$ 由二阶常微分方程 (ODE) 决定：\n$$\n\\frac{d^2 S_k}{d\\chi^2} + k_\\text{geom}\\, S_k = 0\n$$\n初始条件为 $S_k(0) = 0$ 和 $\\left.\\frac{d S_k}{d\\chi}\\right|_{\\chi=0} = 1$。空间曲率常数 $k_\\text{geom}$ 与曲率密度参数 $\\Omega_k$ 的关系为 $k_\\text{geom} = -\\Omega_k \\frac{H_0^2}{c^2}$。\n\n问题指定使用哈勃距离 $c/H_0 = 1$ 的自然单位制。这意味着 $c = H_0$。将此代入 $k_\\text{geom}$ 的表达式中可得到一个显著的简化：\n$$\nk_\\text{geom} = -\\Omega_k \\frac{H_0^2}{H_0^2} = -\\Omega_k\n$$\n这种直接关系使我们可以在确定几何时直接使用 $\\Omega_k$。\n\n**2. ODE 的解析解**\n\n关于 $S_k(\\chi)$ 的 ODE 是一个线性、齐次、系数为常数 $k_\\text{geom} = -\\Omega_k$ 的二阶方程。其解取决于 $k_\\text{geom}$ 的符号。有3种不同情况：\n\n情况 1: $k_\\text{geom} > 0$ (闭合宇宙, $\\Omega_k  0$)\n方程为 $S_k'' + (\\sqrt{k_\\text{geom}})^2 S_k = 0$。通解为 $S_k(\\chi) = A \\cos(\\sqrt{k_\\text{geom}}\\chi) + B \\sin(\\sqrt{k_\\text{geom}}\\chi)$。应用初始条件：\n- $S_k(0) = 0 \\implies A = 0$。\n- $S_k'(0) = 1 \\implies B\\sqrt{k_\\text{geom}}\\cos(0) = 1 \\implies B = 1/\\sqrt{k_\\text{geom}}$。\n解为：\n$$\nS_k(\\chi) = \\frac{1}{\\sqrt{k_\\text{geom}}} \\sin(\\sqrt{k_\\text{geom}}\\chi)\n$$\n\n情况 2: $k_\\text{geom}  0$ (开放宇宙, $\\Omega_k > 0$)\n方程为 $S_k'' - (\\sqrt{-k_\\text{geom}})^2 S_k = 0$。通解为 $S_k(\\chi) = A \\cosh(\\sqrt{-k_\\text{geom}}\\chi) + B \\sinh(\\sqrt{-k_\\text{geom}}\\chi)$。应用初始条件：\n- $S_k(0) = 0 \\implies A = 0$。\n- $S_k'(0) = 1 \\implies B\\sqrt{-k_\\text{geom}}\\cosh(0) = 1 \\implies B = 1/\\sqrt{-k_\\text{geom}}$。\n解为：\n$$\nS_k(\\chi) = \\frac{1}{\\sqrt{-k_\\text{geom}}} \\sinh(\\sqrt{-k_\\text{geom}}\\chi)\n$$\n\n情况 3: $k_\\text{geom} = 0$ (平坦宇宙, $\\Omega_k = 0$)\n方程为 $S_k'' = 0$。通解为 $S_k(\\chi) = A\\chi + B$。应用初始条件：\n- $S_k(0) = 0 \\implies B = 0$。\n- $S_k'(0) = 1 \\implies A = 1$。\n解为：\n$$\nS_k(\\chi) = \\chi\n$$\n\n**3. 数值稳定性分析与算法设计**\n\n对这些解析解的简单实现会在 $|k_\\text{geom}|$ 非常小时遇到数值问题。对于小 $x$，$\\sin(x) \\approx x$ 和 $\\sinh(x) \\approx x$。直接计算像 $\\sin(\\sqrt{k_\\text{geom}}\\chi)/\\sqrt{k_\\text{geom}}$ 这样的表达式，在 $k_\\text{geom}$ 很小时会导致 $0/0$ 的形式，从而引起灾难性对消和精度损失。\n\n为了构建一个鲁棒的算法，我们使用泰勒级数展开来分析当 $k_\\text{geom} \\to 0$ 时解的行为。\n令 $y = k_\\text{geom}\\chi^2$。\n- 对于 $k_\\text{geom} > 0$，$y > 0$。解可以写为 $S_k(\\chi) = \\chi \\frac{\\sin(\\sqrt{y})}{\\sqrt{y}}$。$\\frac{\\sin(x)}{x}$ 的泰勒级数为 $\\sum_{n=0}^{\\infty} (-1)^n \\frac{x^{2n}}{(2n+1)!}$。代入 $x = \\sqrt{y}$ 得：\n$$\nS_k(\\chi) = \\chi \\sum_{n=0}^{\\infty} (-1)^n \\frac{y^n}{(2n+1)!} = \\chi \\left(1 - \\frac{y}{6} + \\frac{y^2}{120} - \\ldots\\right)\n$$\n- 对于 $k_\\text{geom}  0$，$y  0$。令 $y' = -y > 0$。解为 $S_k(\\chi) = \\chi \\frac{\\sinh(\\sqrt{y'})}{\\sqrt{y'}}$。$\\frac{\\sinh(x)}{x}$ 的泰勒级数为 $\\sum_{n=0}^{\\infty} \\frac{x^{2n}}{(2n+1)!}$。代入 $x = \\sqrt{y'}$ 得：\n$$\nS_k(\\chi) = \\chi \\sum_{n=0}^{\\infty} \\frac{(y')^n}{(2n+1)!} = \\chi \\sum_{n=0}^{\\infty} \\frac{(-y)^n}{(2n+1)!} = \\chi \\left(1 - \\frac{y}{6} + \\frac{y^2}{120} - \\ldots\\right)\n$$\n值得注意的是，两种情况在变量 $y = k_\\text{geom}\\chi^2$ 中共享相同的泰勒级数。这为在 $|y|$ 很小时计算 $S_k(\\chi)$ 提供了一种统一且数值稳定的方法。\n\n$S_k(\\chi)$ 的算法：\n1. 给定 $\\chi$ 和 $\\Omega_k$，计算 $k_\\text{geom} = -\\Omega_k$。\n2. 如果 $k_\\text{geom}$ 恰好为 $0$，返回 $\\chi$。\n3. 如果 $\\chi$ 恰好为 $0$，返回 $0$。\n4. 计算 $y = k_\\text{geom} \\chi^2$。\n5. 选择一个阈值，例如 $TOL = 10^{-8}$。如果 $|y|  TOL$，使用截断的泰勒级数计算 $S_k(\\chi)$ 以避免数值对消：\n   $$S_k(\\chi) \\approx \\chi \\left(1 - \\frac{y}{6}\\left(1 - \\frac{y}{20}\\left(1 - \\frac{y}{42}\\right)\\right)\\right)$$\n   这种嵌套形式（霍纳方法）对于多项式求值是高效且稳定的。\n6. 如果 $|y| \\ge TOL$，使用标准的解析公式：\n   - 如果 $k_\\text{geom} > 0$，计算 $S_k(\\chi) = \\sin(\\sqrt{k_\\text{geom}}\\chi) / \\sqrt{k_\\text{geom}}$。\n   - 如果 $k_\\text{geom}  0$，计算 $S_k(\\chi) = \\sinh(\\sqrt{-k_\\text{geom}}\\chi) / \\sqrt{-k_\\text{geom}}$。\n\n此外，对于开放宇宙的情况 ($k_\\text{geom}  0$)，双曲正弦的参数 $\\sqrt{-k_\\text{geom}}\\chi$ 可能会变得很大，有浮点溢出的风险。对于所提供的测试用例，这不是问题，因为参数值仍然很小。在一个通用库中，对于大参数可能会切换到对数表示。\n\n**4. 实现计划**\n\n最终程序的结构如下：\n1. 一个函数 `compute_chi(z, Omega_m, Omega_Lambda, Omega_k)` 将通过使用 `scipy.integrate.quad` 从 $z'=0$ 到 $z$ 对 $1/E(z')$ 进行数值积分来计算共动距离 $\\chi(z)$。一个对 $z=0$ 的显式检查将立即返回 $0$。\n2. 一个函数 `compute_Sk_chi(chi, Omega_k)` 将实现上述鲁棒算法来计算 $S_k(\\chi)$。\n3. 主函数 `solve()` 将遍历问题陈述中提供的 5 个测试用例。\n4. 对每个用例，它将调用 `compute_chi` 和 `compute_Sk_chi` 来获取所需的值。\n5. 对于情况 A、B 和 C，存储 $S_k(\\chi(z))$ 的浮点数值。\n6. 对于情况 D，存储相对差异测试 $|\\frac{S_k(\\chi) - \\chi}{\\max(1, \\chi)}|  10^{-10}$ 的布尔结果。\n7. 对于情况 E，存储测试 $S_k(\\chi(0))$ 是否等于 $0$ 的布尔结果。\n8. 所有结果将被收集到一个列表中，并以指定的逗号分隔格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the transverse comoving distance S_k(chi)\n    for a set of cosmological parameters and redshifts.\n    \"\"\"\n    \n    # (Omega_m, Omega_Lambda, Omega_k, z)\n    # Omega_r is assumed to be 0.\n    # Natural units with c/H_0 = 1 are used.\n    test_cases = [\n        # Case A: Happy path, flat universe\n        (0.3, 0.7, 0.0, 2.0),\n        # Case B: Closed universe\n        (0.3, 0.75, -0.05, 2.0),\n        # Case C: Open universe\n        (0.3, 0.65, 0.05, 2.0),\n        # Case D: Near-flat continuity check\n        (0.3, 0.7, 1e-12, 2.0),\n        # Case E: Zero-distance boundary\n        (0.3, 0.7, 0.0, 0.0),\n    ]\n\n    def _integrand(z_prime, om_m, om_l, om_k):\n        \"\"\"The integrand 1/E(z') for the comoving distance integral.\"\"\"\n        e_z = np.sqrt(om_m * (1 + z_prime)**3 + om_k * (1 + z_prime)**2 + om_l)\n        return 1.0 / e_z\n\n    def compute_chi(z, om_m, om_l, om_k):\n        \"\"\"\n        Calculates the line-of-sight comoving distance chi(z).\n        \"\"\"\n        if z == 0.0:\n            return 0.0\n        \n        # scipy.integrate.quad returns a tuple (result, error_estimate)\n        chi_val, _ = quad(_integrand, 0, z, args=(om_m, om_l, om_k))\n        return chi_val\n\n    def compute_Sk_chi(chi, om_k):\n        \"\"\"\n        Calculates the transverse comoving distance S_k(chi) using a\n        numerically robust algorithm.\n        \"\"\"\n        # In natural units with c/H_0=1, k_geom = -Omega_k\n        k_geom = -om_k\n\n        # Case 1: Flat universe (k_geom = 0)\n        if k_geom == 0.0:\n            return chi\n        \n        # Handle chi=0 boundary condition\n        if chi == 0.0:\n            return 0.0\n\n        # Argument for Taylor expansion/analytical functions\n        y = k_geom * chi**2\n        \n        # Threshold for switching to Taylor series to avoid cancellation error\n        TOLERANCE = 1e-8\n        if abs(y)  TOLERANCE:\n            # S_k(chi) = chi * (1 - y/6 + y^2/120 - y^3/5040 + ...)\n            # Use Horner's method for stable polynomial evaluation\n            val = chi * (1.0 - y / 6.0 * (1.0 - y / 20.0 * (1.0 - y / 42.0)))\n            return val\n        \n        # Case 2: Closed universe (k_geom > 0)\n        if k_geom > 0:\n            sqrt_k = np.sqrt(k_geom)\n            return np.sin(sqrt_k * chi) / sqrt_k\n        # Case 3: Open universe (k_geom  0)\n        else:\n            sqrt_abs_k = np.sqrt(-k_geom)\n            return np.sinh(sqrt_abs_k * chi) / sqrt_abs_k\n\n    results = []\n    \n    # Case A\n    om_m, om_l, om_k, z = test_cases[0]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case B\n    om_m, om_l, om_k, z = test_cases[1]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case C\n    om_m, om_l, om_k, z = test_cases[2]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case D\n    om_m, om_l, om_k, z = test_cases[3]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    relative_difference = abs(Sk_chi - chi) / max(1.0, chi)\n    results.append(relative_difference  1e-10)\n\n    # Case E\n    om_m, om_l, om_k, z = test_cases[4]\n    chi = compute_chi(z, om_m, om_l, om_k)  # This will be 0.0\n    Sk_chi = compute_Sk_chi(chi, om_k)      # This will be 0.0\n    results.append(Sk_chi == 0.0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3495804"}, {"introduction": "在学会求解和应用弗里德曼方程之后，研究人员的一项关键技能是理解模型的预测结果如何依赖于其输入参数（例如物质密度参数 $\\Omega_m$）。这项高级练习介绍了一种强大的技术——切线线性模型(Tangent Linear Model)，用于高效、精确地计算这些灵敏度。通过推导并实现灵敏度本身的演化方程，你将超越简单的有限差分方法，接触到更复杂的模型分析技术 [@problem_id:3495846]。", "problem": "考虑一个空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克（FLRW）宇宙，其由第一弗里德曼方程所支配。设由其当前值归一化的哈勃膨胀率由无量纲函数 $E(a)$ 定义，其中 $a$ 是标度因子，并定义无量纲时间 $\\tau$ 为 $\\tau \\equiv H_0 t$，因此 $d\\tau = H_0 \\, dt$。假设一个平坦的能量收支，其中辐射密度参数 $\\Omega_r$ 和物质密度参数 $\\Omega_m$ 为常数，暗能量密度参数 $\\Omega_\\Lambda$ 被调整以维持平坦性，即 $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$。归一化的哈勃函数为 $E(a) = \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}$。标度因子 $a(\\tau;\\Omega_m)$ 根据自治常微分方程（ODE）$da/d\\tau = a E(a)$ 从一个严格为正的初始值 $a(0;\\Omega_m) = a_i$ 开始演化，该初始值与 $\\Omega_m$ 无关。\n\n您的任务是推导、实现并验证一个关于标度因子对物质密度参数灵敏度的切线性模型（TLM）。将灵敏度定义为在固定 $\\tau$ 下计算的 $s(\\tau) \\equiv \\partial a(\\tau;\\Omega_m)/\\partial \\Omega_m$。仅从第一弗里德曼方程、无量纲时间的定义以及 $a(\\tau;\\Omega_m)$ 的自治常微分方程出发，推导 $s(\\tau)$ 满足的线性常微分方程，其通用形式为 $ds/d\\tau = \\left(\\partial f/\\partial a\\right) s + \\partial f/\\partial \\Omega_m$，其中 $f(a,\\Omega_m) = a E(a)$。同时，推导出一个与 $a(0;\\Omega_m) = a_i$ 独立于 $\\Omega_m$ 相一致的适当初始条件。您的推导必须将所有偏导数明确地用 $a$、$\\Omega_m$ 和 $\\Omega_r$ 表示，而不能引入任何额外的参数。\n\n然后，实现一个数值求解器，通过从 $\\tau = 0$ 到给定的最终时间 $\\tau_f$ 积分 $a$ 的常微分方程和推导出的 $s$ 的切线性模型，来计算 $a(\\tau;\\Omega_m)$ 和 $s(\\tau)$。积分从 $a(0) = a_i$ 和您推导所蕴含的 $s(\\tau)$ 的初始条件开始。通过将 $s(\\tau_f)$ 与一个中心差分（CD）有限差分估计进行比较来验证该TLM。该估计是通过两个微扰解 $a(\\tau_f;\\Omega_m + \\delta)$ 和 $a(\\tau_f;\\Omega_m - \\delta)$ 计算得出的，公式为 $(a(\\tau_f;\\Omega_m + \\delta) - a(\\tau_f;\\Omega_m - \\delta))/(2 \\delta)$，其中 $\\delta$ 是一个小的正数。在您的常微分方程求解器中使用足够严格的数值容差，以确保TLM灵敏度与中心差分估计之间的差异主要由 $\\delta$ 的截断误差决定，而不是时间积分误差。\n\n由于 $\\tau$ 是无量纲的，因此不需要物理单位。不出现角度。所有报告的数值答案都必须是实数。\n\n测试套件。您的程序必须为以下每个测试用例评估TLM灵敏度与CD估计之间的绝对差，每个测试用例以五元组 $(\\Omega_m,\\Omega_r,\\tau_f,a_i,\\delta)$ 的形式给出：\n- 测试 A：$(0.3, 9 \\times 10^{-5}, 1.0, 10^{-3}, 10^{-5})$。\n- 测试 B：$(0.3, 9 \\times 10^{-5}, 0.1, 10^{-4}, 10^{-6})$。\n- 测试 C：$(0.8, 10^{-5}, 0.5, 10^{-3}, 10^{-5})$。\n- 测试 D：$(0.1, 9 \\times 10^{-5}, 2.0, 10^{-3}, 10^{-5})$。\n\n实现要求：\n- 使用严格的绝对和相对容差来积分 $a(\\tau;\\Omega_m)$ 的常微分方程和 $s(\\tau)$ 的切线性模型，以可靠地解析给定参数下的动力学。\n- 在所有 $E(a)$ 及其导数的计算中，始终使用平坦性关系 $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$。\n- 确保 $s(\\tau)$ 的初始条件与 $a(0;\\Omega_m) = a_i$ 独立于 $\\Omega_m$ 的设定相一致。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。第 $k$ 个条目必须是第 $k$ 个测试用例（按 A、B、C、D 的顺序）的TLM灵敏度与CD估计之间的绝对差。例如，一个有效的输出形式为 $[x_1,x_2,x_3,x_4]$，其中每个 $x_k$ 都是一个实数。", "solution": "该问题被评估为有效。它在科学上基于标准的宇宙学原理（弗里德曼方程），在数学上是适定的，具有完整且一致的定义和初始条件，并以客观、正式的语言表述。该任务是应用于描述宇宙膨胀的常微分方程（ODE）系统的灵敏度分析中的一个标准但非平凡的练习。\n\n### 切线性模型（TLM）的推导\n\n标度因子 $a$ 作为无量纲时间 $\\tau$ 的函数，其演化由自治一阶常微分方程所支配：\n$$\n\\frac{da}{d\\tau} = a E(a) \\equiv f(a, \\Omega_m)\n$$\n在此，$a$ 被视为 $\\tau$ 和物质密度参数 $\\Omega_m$ 的函数，即 $a = a(\\tau; \\Omega_m)$。空间平坦宇宙的归一化哈勃函数 $E(a)$ 由以下公式给出：\n$$\nE(a) = \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}\n$$\n使用平坦性条件 $\\Omega_r + \\Omega_m + \\Omega_\\Lambda = 1$，我们可以写出 $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$。将其代入 $E(a)$ 的表达式中，得到：\n$$\nE(a) = \\sqrt{\\Omega_r (a^{-4} - 1) + \\Omega_m (a^{-3} - 1) + 1}\n$$\n因此，函数 $f(a, \\Omega_m)$ 为：\n$$\nf(a, \\Omega_m) = a \\sqrt{\\Omega_r (a^{-4} - 1) + \\Omega_m (a^{-3} - 1) + 1}\n$$\n标度因子对物质密度参数的灵敏度定义为 $s(\\tau) \\equiv \\partial a(\\tau; \\Omega_m) / \\partial \\Omega_m$。为了找到 $s(\\tau)$ 的控制常微分方程，我们将 $a$ 的常微分方程对 $\\Omega_m$ 求导：\n$$\n\\frac{\\partial}{\\partial \\Omega_m} \\left( \\frac{da}{d\\tau} \\right) = \\frac{\\partial f(a, \\Omega_m)}{\\partial \\Omega_m}\n$$\n由于 $\\tau$ 和 $\\Omega_m$ 是自变量，我们可以交换左侧的微分顺序：\n$$\n\\frac{d}{d\\tau} \\left( \\frac{\\partial a}{\\partial \\Omega_m} \\right) = \\frac{d s}{d\\tau}\n$$\n在右侧使用多元链式法则，我们得到：\n$$\n\\frac{ds}{d\\tau} = \\frac{\\partial f}{\\partial a} \\frac{\\partial a}{\\partial \\Omega_m} + \\frac{\\partial f}{\\partial \\Omega_m}\n$$\n代入灵敏度的定义 $s = \\partial a / \\partial \\Omega_m$，我们得到切线性模型（TLM）方程，这是一个关于 $s(\\tau)$ 的线性一阶常微分方程：\n$$\n\\frac{ds}{d\\tau} = \\left( \\frac{\\partial f}{\\partial a} \\right) s + \\frac{\\partial f}{\\partial \\Omega_m}\n$$\n为了完善该模型，我们必须推导出偏导数 $\\partial f / \\partial a$ 和 $\\partial f / \\partial \\Omega_m$ 的显式表达式。\n\n#### $\\partial f / \\partial a$ 的计算\n我们将 $f(a, \\Omega_m) = a E(a)$ 对 $a$ 求导，同时保持 $\\Omega_m$ 不变：\n$$\n\\frac{\\partial f}{\\partial a} = \\frac{\\partial}{\\partial a}(a E(a)) = E(a) + a \\frac{\\partial E(a)}{\\partial a}\n$$\n首先，我们通过对 $E(a)^2 = \\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda$ 求导来找到 $\\partial E(a) / \\partial a$：\n$$\n2 E(a) \\frac{\\partial E(a)}{\\partial a} = -4 \\Omega_r a^{-5} - 3 \\Omega_m a^{-4}\n$$\n$$\n\\frac{\\partial E(a)}{\\partial a} = \\frac{-4 \\Omega_r a^{-5} - 3 \\Omega_m a^{-4}}{2 E(a)}\n$$\n将此结果代回 $\\partial f / \\partial a$ 的表达式中：\n$$\n\\frac{\\partial f}{\\partial a} = E(a) + a \\left( \\frac{-4 \\Omega_r a^{-5} - 3 \\Omega_m a^{-4}}{2 E(a)} \\right) = \\frac{2 E(a)^2 - 4 \\Omega_r a^{-4} - 3 \\Omega_m a^{-3}}{2 E(a)}\n$$\n用其定义替换 $E(a)^2$：\n$$\n\\frac{\\partial f}{\\partial a} = \\frac{2 (\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda) - 4 \\Omega_r a^{-4} - 3 \\Omega_m a^{-3}}{2 E(a)}\n$$\n$$\n\\frac{\\partial f}{\\partial a} = \\frac{-2 \\Omega_r a^{-4} - \\Omega_m a^{-3} + 2 \\Omega_\\Lambda}{2 E(a)}\n$$\n\n#### $\\partial f / \\partial \\Omega_m$ 的计算\n我们将 $f(a, \\Omega_m) = a E(a)$ 对 $\\Omega_m$ 求导，同时保持 $a$ 不变。\n$$\n\\frac{\\partial f}{\\partial \\Omega_m} = a \\frac{\\partial E(a)}{\\partial \\Omega_m}\n$$\n我们使用 $E(a)^2 = \\Omega_r (a^{-4} - 1) + \\Omega_m (a^{-3} - 1) + 1$。对 $\\Omega_m$ 求导：\n$$\n2 E(a) \\frac{\\partial E(a)}{\\partial \\Omega_m} = a^{-3} - 1\n$$\n$$\n\\frac{\\partial E(a)}{\\partial \\Omega_m} = \\frac{a^{-3} - 1}{2 E(a)}\n$$\n因此，$f$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial \\Omega_m} = a \\left( \\frac{a^{-3} - 1}{2 E(a)} \\right) = \\frac{a^{-2} - a}{2 E(a)}\n$$\n\n#### $s(\\tau)$ 的初始条件\n问题陈述指出，初始标度因子 $a(0; \\Omega_m) = a_i$ 是一个常数，与 $\\Omega_m$ 无关。灵敏度的初始条件 $s(0)$ 是通过将 $a$ 的初始条件对 $\\Omega_m$ 求导得到的：\n$$\ns(0) = \\frac{\\partial a(0; \\Omega_m)}{\\partial \\Omega_m} = \\frac{\\partial (a_i)}{\\partial \\Omega_m} = 0\n$$\n\n### 数值实现策略\n我们求解以下关于状态向量 $Y(\\tau)=[a(\\tau), s(\\tau)]^T$ 的两个耦合一阶常微分方程组：\n$$\n\\frac{d}{d\\tau}\n\\begin{pmatrix}\na \\\\\ns\n\\end{pmatrix}\n=\n\\begin{pmatrix}\na E(a) \\\\\n\\left( \\frac{-2 \\Omega_r a^{-4} - \\Omega_m a^{-3} + 2 \\Omega_\\Lambda}{2 E(a)} \\right) s + \\left( \\frac{a^{-2} - a}{2 E(a)} \\right)\n\\end{pmatrix}\n$$\n初始条件为 $a(0) = a_i$ 和 $s(0) = 0$。该系统使用数值求解器从 $\\tau=0$ 积分到 $\\tau = \\tau_f$。灵敏度的结果是 $s(\\tau_f)$ 的值。\n\n为了验证，将此结果与一个二阶精确的中心差分（CD）估计进行比较。CD 估计是通过将原始常微分方程 $da/d\\tau = a E(a)$ 积分两次来计算的：\n1.  使用参数 $\\Omega_m + \\delta$ 积分一次，得到 $a_+(\\tau_f) = a(\\tau_f; \\Omega_m + \\delta, \\Omega_r)$。\n2.  使用参数 $\\Omega_m - \\delta$ 积分一次，得到 $a_-(\\tau_f) = a(\\tau_f; \\Omega_m - \\delta, \\Omega_r)$。\n\n那么，灵敏度的CD估计为：\n$$\ns_{CD}(\\tau_f) = \\frac{a_+(\\tau_f) - a_-(\\tau_f)}{2 \\delta}\n$$\n最终输出是绝对差 $|s(\\tau_f) - s_{CD}(\\tau_f)|$。所有积分都使用 `scipy.integrate.solve_ivp` 配合严格的容差（$atol = 10^{-12}$, $rtol = 10^{-12}$）来执行，以最小化数值积分误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a Tangent Linear Model for the sensitivity\n    of the cosmological scale factor with respect to the matter density parameter.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.3, 9e-5, 1.0, 1e-3, 1e-5),  # Test A\n        (0.3, 9e-5, 0.1, 1e-4, 1e-6),  # Test B\n        (0.8, 1e-5, 0.5, 1e-3, 1e-5),  # Test C\n        (0.1, 9e-5, 2.0, 1e-3, 1e-5),  # Test D\n    ]\n\n    results = []\n\n    # ODE system for the scale factor 'a' and its sensitivity 's'\n    def coupled_system(tau, y, Omega_m, Omega_r):\n        a, s = y\n        \n        # Avoid division by zero or negative roots if 'a' becomes non-positive.\n        if a = 0:\n            return np.array([0., 0.])\n\n        Omega_L = 1.0 - Omega_m - Omega_r\n        \n        a_inv = 1.0 / a\n        a_inv2 = a_inv * a_inv\n        a_inv3 = a_inv2 * a_inv\n        a_inv4 = a_inv3 * a_inv\n\n        E_squared = Omega_r * a_inv4 + Omega_m * a_inv3 + Omega_L\n        E = np.sqrt(E_squared)\n\n        # Evolution equation for a\n        f_a = a * E\n        da_dtau = f_a\n\n        # Partial derivatives for the sensitivity equation\n        # df/da = (-2*Or*a^-4 - Om*a^-3 + 2*OL) / (2*E)\n        df_da_num = -2.0 * Omega_r * a_inv4 - Omega_m * a_inv3 + 2.0 * Omega_L\n        df_da = df_da_num / (2.0 * E)\n\n        # df/dOm = (a^-2 - a) / (2*E)\n        df_dOm_num = a_inv2 - a\n        df_dOm = df_dOm_num / (2.0 * E)\n\n        # Evolution equation for s\n        ds_dtau = df_da * s + df_dOm\n        \n        return np.array([da_dtau, ds_dtau])\n\n    # ODE system for the scale factor 'a' only, for Central Difference calculation\n    def a_only_system(tau, a, Omega_m, Omega_r):\n        if a[0] = 0:\n            return [0.]\n        \n        Omega_L = 1.0 - Omega_m - Omega_r\n        \n        # Use a single-element array for the state vector\n        a_val = a[0] \n        E_squared = Omega_r * a_val**-4 + Omega_m * a_val**-3 + Omega_L\n        E = np.sqrt(E_squared)\n        \n        da_dtau = a_val * E\n        return np.array([da_dtau])\n\n    # Numerical integration tolerances\n    rtol = 1e-12\n    atol = 1e-12\n\n    for case in test_cases:\n        Omega_m, Omega_r, tau_f, a_i, delta = case\n\n        # 1. Solve the coupled system for the TLM sensitivity\n        y0_coupled = np.array([a_i, 0.0])\n        t_span = np.array([0., tau_f])\n        \n        sol_tlm = solve_ivp(\n            coupled_system, t_span, y0_coupled,\n            args=(Omega_m, Omega_r),\n            rtol=rtol, atol=atol,\n            method='RK45'\n        )\n        s_tlm = sol_tlm.y[1, -1]\n\n        # 2. Compute the Central Difference estimate\n        y0_a = np.array([a_i])\n\n        # Perturbed '+' solution\n        sol_p = solve_ivp(\n            a_only_system, t_span, y0_a,\n            args=(Omega_m + delta, Omega_r),\n            rtol=rtol, atol=atol,\n            method='RK45'\n        )\n        a_plus = sol_p.y[0, -1]\n\n        # Perturbed '-' solution\n        sol_m = solve_ivp(\n            a_only_system, t_span, y0_a,\n            args=(Omega_m - delta, Omega_r),\n            rtol=rtol, atol=atol,\n            method='RK45'\n        )\n        a_minus = sol_m.y[0, -1]\n\n        s_cd = (a_plus - a_minus) / (2.0 * delta)\n\n        # 3. Calculate the absolute difference\n        abs_diff = np.abs(s_tlm - s_cd)\n        results.append(abs_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3495846"}]}