{"hands_on_practices": [{"introduction": "要真正掌握一个数值方法，我们必须首先理解其最基本的数学性质。这项练习将引导您通过解析推导，从第一性原理出发，揭示单元内云（CIC）分配方案在傅里叶空间中的核心特征。通过推导其一维窗口函数及其在大尺度（小 $k$）下的展开，您将能够量化该方案固有的平滑效应，这是理解其如何影响宇宙学功率谱测量的关键第一步 [@problem_id:3466986]。", "problem": "在用于宇宙学$N$体模拟的粒子-网格方法中，单元内云 (CIC) 质量分配方案将每个粒子的质量线性地分配到一维空间中最近的两个网格点上。设网格间距为$\\,\\Delta\\,$，并定义单元内云 (CIC) 的一维归一化实空间分配核为\n$$\nK_{\\mathrm{CIC}}(x) \\equiv \n\\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  |x| \\le \\Delta, \\\\\n0,  |x| > \\Delta,\n\\end{cases}\n$$\n它满足 $\\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\mathrm{d}x = 1$。考虑一个连续密度场 $\\,\\rho(x)\\,$ 及其通过卷积得到的网格分配对应物 $\\,\\rho_{\\mathrm{grid}}(x) = \\int_{-\\infty}^{\\infty} \\rho(x')\\,K_{\\mathrm{CIC}}(x-x')\\,\\mathrm{d}x'$。在傅里叶空间中，该分配将真实场的变换乘以一个窗函数 $\\,W_{1\\mathrm{D}}(k)\\,$，该窗函数由傅里叶变换定义为\n$$\nW_{1\\mathrm{D}}(k) \\equiv \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n\n从上述定义出发，不使用任何预先制表的傅里叶变换对或专门的质量分配公式，推导 $\\,W_{1\\mathrm{D}}(k)\\,$ 并求其小$k$展开式，直到并包括 $\\,k^{2}\\,$ 项。然后，将领先的有效平滑长度 $\\,R_{\\mathrm{eff}}\\,$ 定义为满足以下条件的唯一正量\n$$\nW_{1\\mathrm{D}}(k) \\;=\\; 1 \\;-\\; \\frac{(k\\,R_{\\mathrm{eff}})^{2}}{2} \\;+\\; \\mathcal{O}(k^{4})\n\\quad\\text{for } k \\to 0,\n$$\n并仅用 $\\,\\Delta\\,$ 表示 $\\,R_{\\mathrm{eff}}\\,$。您的最终答案必须是 $\\,R_{\\mathrm{eff}}\\,$ 关于 $\\,\\Delta\\,$ 的单个闭式解析表达式。最终答案中不要包含任何单位，并且不要在最终答案中报告级数余项符号 $\\,\\mathcal{O}(k^{4})\\,$。", "solution": "根据指定的验证程序对问题陈述进行严格评估。\n\n### 第 1 步：提取已知条件\n- 单元内云 (CIC) 的一维归一化实空间分配核由下式给出：\n$$\nK_{\\mathrm{CIC}}(x) \\equiv \n\\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  |x| \\le \\Delta, \\\\\n0,  |x| > \\Delta,\n\\end{cases}\n$$\n- 核是归一化的，使得 $\\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\mathrm{d}x = 1$。\n- 网格分配的密度场通过卷积与连续场相关：$\\rho_{\\mathrm{grid}}(x) = \\int_{-\\infty}^{\\infty} \\rho(x')\\,K_{\\mathrm{CIC}}(x-x')\\,\\mathrm{d}x'$。\n- 傅里叶空间窗函数 $W_{1\\mathrm{D}}(k)$ 是核的傅里叶变换：\n$$\nW_{1\\mathrm{D}}(k) \\equiv \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n- $W_{1\\mathrm{D}}(k)$ 的小 $k$ 行为定义了有效平滑长度 $R_{\\mathrm{eff}}$：\n$$\nW_{1\\mathrm{D}}(k) \\;=\\; 1 \\;-\\; \\frac{(k\\,R_{\\mathrm{eff}})^{2}}{2} \\;+\\; \\mathcal{O}(k^{4})\n\\quad\\text{for } k \\to 0,\n$$\n其中 $R_{\\mathrm{eff}}$ 是一个唯一的正量。\n\n### 第 2 步：使用提取的已知条件进行验证\n对问题的有效性进行评估：\n- **科学依据**：该问题基于计算宇宙学中的标准、公认的概念和方法，特别是粒子-网格 N 体模拟技术。CIC 分配方案及其傅里叶表示是该领域的基本组成部分。\n- **适定性**：问题陈述清晰，包含了所有必要的定义和约束。目标是进行特定的推导并计算一个定义明确的量，该量存在唯一解。\n- **客观性**：语言精确、正式，没有任何主观或模棱两可的术语。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。它是在特定背景下的标准数学物理推导。将按要求提供解答。\n\n第一步是通过计算核 $K_{\\mathrm{CIC}}(x)$ 的傅里叶变换来推导窗函数 $W_{1\\mathrm{D}}(k)$ 的解析形式。\n从定义出发：\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n我们代入 $K_{\\mathrm{CIC}}(x)$ 的分段定义。核仅在 $|x| \\le \\Delta$ 时非零，因此积分限变为 $[-\\Delta, \\Delta]$：\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n使用欧拉公式 $\\exp(-\\mathrm{i} k x) = \\cos(kx) - \\mathrm{i}\\sin(kx)$，我们可以将积分拆分为：\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x - \\mathrm{i} \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\sin(k x)\\,\\mathrm{d}x.\n$$\n函数 $\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)$ 是 $x$ 的偶函数。函数 $\\sin(kx)$ 是 $x$ 的奇函数。一个偶函数和一个奇函数的乘积是奇函数。一个奇函数在对称区间 $[-\\Delta, \\Delta]$ 上的积分为零。因此，积分的虚部为零。\n剩下的被积函数是两个偶函数的乘积，结果是偶函数。我们可以简化积分的实部：\n$$\nW_{1\\mathrm{D}}(k) = 2 \\int_{0}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x.\n$$\n对于 $x \\ge 0$，有 $|x| = x$，因此表达式变为：\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{\\Delta} \\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x.\n$$\n这个积分可以用分部积分法 $\\int u\\,\\mathrm{d}v = uv - \\int v\\,\\mathrm{d}u$ 求解。设 $u = 1 - \\frac{x}{\\Delta}$ 且 $\\mathrm{d}v = \\cos(kx)\\,\\mathrm{d}x$。这意味着 $\\mathrm{d}u = -\\frac{1}{\\Delta}\\,\\mathrm{d}x$ 且 $v = \\frac{1}{k}\\sin(kx)$。\n$$\n\\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x = \\left[\\left(1 - \\frac{x}{\\Delta}\\right)\\frac{\\sin(kx)}{k}\\right]_{0}^{\\Delta} - \\int_{0}^{\\Delta} \\frac{\\sin(kx)}{k} \\left(-\\frac{1}{\\Delta}\\right)\\,\\mathrm{d}x.\n$$\n第一项在两个积分限处的值都为零：在 $x=\\Delta$ 处，因子 $(1 - \\frac{\\Delta}{\\Delta}) = 0$；在 $x=0$ 处，因子 $\\sin(0) = 0$。\n表达式简化为：\n$$\n\\frac{1}{k\\Delta} \\int_{0}^{\\Delta} \\sin(kx)\\,\\mathrm{d}x = \\frac{1}{k\\Delta} \\left[-\\frac{\\cos(kx)}{k}\\right]_{0}^{\\Delta} = \\frac{1}{k^2\\Delta} \\left(-\\cos(k\\Delta) - (-\\cos(0))\\right) = \\frac{1 - \\cos(k\\Delta)}{k^2\\Delta}.\n$$\n将此结果代回 $W_{1\\mathrm{D}}(k)$ 的表达式中：\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{\\Delta} \\left(\\frac{1 - \\cos(k\\Delta)}{k^2\\Delta}\\right) = \\frac{2(1 - \\cos(k\\Delta))}{(k\\Delta)^2}.\n$$\n接下来，我们求 $W_{1\\mathrm{D}}(k)$ 的小 $k$ 展开。我们使用余弦函数在 0 附近的泰勒级数：\n$$\n\\cos(y) = 1 - \\frac{y^2}{2!} + \\frac{y^4}{4!} - \\mathcal{O}(y^6).\n$$\n设 $y = k\\Delta$。那么对于小的 $k$，$y$ 也很小。\n$$\n1 - \\cos(k\\Delta) = 1 - \\left(1 - \\frac{(k\\Delta)^2}{2} + \\frac{(k\\Delta)^4}{24} - \\dots\\right) = \\frac{(k\\Delta)^2}{2} - \\frac{(k\\Delta)^4}{24} + \\mathcal{O}(k^6).\n$$\n将此代入 $W_{1\\mathrm{D}}(k)$ 的表达式中：\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{(k\\Delta)^2} \\left[ \\frac{(k\\Delta)^2}{2} - \\frac{(k\\Delta)^4}{24} + \\mathcal{O}(k^6) \\right].\n$$\n分配前面的因子，得到直到 $k^2$ 项的展开式：\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{2(k\\Delta)^4}{24(k\\Delta)^2} + \\mathcal{O}(k^4) = 1 - \\frac{(k\\Delta)^2}{12} + \\mathcal{O}(k^4).\n$$\n最后，我们将此推导出的展开式与问题陈述中给出的形式进行比较，该形式定义了有效平滑长度 $R_{\\mathrm{eff}}$：\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{(k R_{\\mathrm{eff}})^2}{2} + \\mathcal{O}(k^4).\n$$\n通过令两个表达式中 $k^2$ 项的系数相等，我们得到：\n$$\n\\frac{(k R_{\\mathrm{eff}})^2}{2} = \\frac{(k\\Delta)^2}{12}.\n$$\n$$\n\\frac{k^2 R_{\\mathrm{eff}}^2}{2} = \\frac{k^2 \\Delta^2}{12}.\n$$\n对于 $k \\neq 0$，我们可以除以 $k^2$：\n$$\nR_{\\mathrm{eff}}^2 = \\frac{2\\Delta^2}{12} = \\frac{\\Delta^2}{6}.\n$$\n问题陈述指出 $R_{\\mathrm{eff}}$ 是一个正量。对两边取正平方根，得到 $R_{\\mathrm{eff}}$ 的所求表达式：\n$$\nR_{\\mathrm{eff}} = \\sqrt{\\frac{\\Delta^2}{6}} = \\frac{\\Delta}{\\sqrt{6}}.\n$$\n这就是有效平滑长度用网格间距 $\\Delta$ 表示的闭式解析表达式。", "answer": "$$\\boxed{\\frac{\\Delta}{\\sqrt{6}}}$$", "id": "3466986"}, {"introduction": "理论上的理解需要通过数值实验来巩固和验证。这项编码实践将指导您构建一个简化的粒子-网格（PM）模拟，用于测量所谓的“蛋盒效应”——即由网格几何结构自身引入的、即使在均匀物质分布下也会产生的虚假各向异性力。这项练习将使 CIC 方案的一个关键理论限制变得具体可感，并训练您通过受控实验来隔离和量化数值误差的能力 [@problem_id:3466963]。", "problem": "您的任务是设计并实现一个数值实验，以分离并量化由粒子网格（PM）引力求解器中的单元内云（CIC）质量分配方案引入的伪各向异性力。该研究专注于所谓的“蛋盒”印记：即使在演化一个原本均匀的构型时也会出现的、由网格引起的各向异性。您必须从第一性原理出发构建算法，并生成一个完整的、可运行的程序，该程序计算单个粒子因其自身在周期性网格上的单元内云沉积而受到的伪力，然后测量由此产生的速度增量如何随网格间距和积分时间步长而变化。所有量均为无量纲；输出中不包含任何物理单位。\n\n请从以下符合背景的基础开始。\n\n- 粒子网格（PM）方法通过将粒子质量沉积到规则网格上，在网格上求解势的泊松方程，计算网格上的力场作为势的负梯度，然后将力插值回粒子位置来近似引力势的解。\n- 在周期性盒子中，引力势满足泊松方程，\n  $$\\nabla^2 \\Phi(\\mathbf{x}) = 4\\pi G\\left[\\rho(\\mathbf{x}) - \\bar{\\rho}\\right],$$\n  其中 $G$ 是引力常数，$\\rho(\\mathbf{x})$ 是质量密度，$\\bar{\\rho}$ 是其空间平均值。在周期性域中，拉普拉斯算子的傅里叶变换是对角的，并且必须将 $\\mathbf{k}=\\mathbf{0}$ 处的平均分量设置为零以避免发散。\n- 在 $d=2$ 维中，单元内云（CIC）质量分配使用一个可分离的三角形核。对于位于位置 $(x,y)$、网格间距为 $\\Delta$ 的粒子，令 $g_x = x/\\Delta$ 和 $g_y = y/\\Delta$，$i_0 = \\lfloor g_x \\rfloor$，$j_0 = \\lfloor g_y \\rfloor$，$f_x = g_x - i_0$，以及 $f_y = g_y - j_0$。那么，四个周围的网格节点 $(i_0,j_0)$、$(i_0+1,j_0)$、$(i_0,j_0+1)$ 和 $(i_0+1,j_0+1)$ 接收的质量分数权重为\n  $$w_{x,0} = 1 - f_x,\\quad w_{x,1} = f_x,\\quad w_{y,0} = 1 - f_y,\\quad w_{y,1} = f_y,$$\n  单位单元面积的质量通过除以 $\\Delta^2$ 得到。相同的权重也用于将网格力插值回粒子位置。定义盒子大小为 $L$，每个维度的网格单元数为 $N$，因此 $\\Delta = L/N$。\n- 泊松方程在傅里叶空间中求解。令 $\\tilde{\\rho}(\\mathbf{k})$ 为密度的离散傅里叶变换。使用与二阶有限差分拉普拉斯算子相关的离散有效波数，\n  $$k_{\\mathrm{eff}}^2(\\mathbf{k}) = \\left(\\frac{2}{\\Delta}\\right)^2\\left[\\sin^2\\left(\\frac{k_x \\Delta}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta}{2}\\right)\\right],$$\n  其中离散波数为 $k_x = 2\\pi n_x / L$ 和 $k_y = 2\\pi n_y / L$，对于整数 $n_x, n_y \\in \\{0,1,\\dots,N-1\\}$ 且具有周期性排序。傅里叶空间中的势为\n  $$\\tilde{\\Phi}(\\mathbf{k}) = -\\frac{4\\pi G\\, \\tilde{\\rho}(\\mathbf{k})}{k_{\\mathrm{eff}}^2(\\mathbf{k})},$$\n  且 $\\tilde{\\Phi}(\\mathbf{0}) = 0$。变换回实空间以获得 $\\Phi(\\mathbf{x})$。\n- 网格力由二阶中心有限差分计算，\n  $$F_x(i,j) = -\\frac{\\Phi(i+1,j) - \\Phi(i-1,j)}{2\\Delta},\\qquad F_y(i,j) = -\\frac{\\Phi(i,j+1) - \\Phi(i,j-1)}{2\\Delta},$$\n  索引具有周期性。粒子感受到插值后的力\n  $$\\mathbf{F}_p = \\sum_{a\\in\\{0,1\\}}\\sum_{b\\in\\{0,1\\}} \\left[w_{x,a} w_{y,b}\\right]\\, \\mathbf{F}(i_0+a, j_0+b)。$$\n- 速度更新（“踢”）在一个时间步长内计算为\n  $$\\Delta \\mathbf{v} = \\mathbf{F}_p\\, \\Delta t,$$\n  从零初始速度开始。\n\n您必须在一个边长 $L = 1$ 的二维周期性方盒中，为单个粒子实现上述流程，粒子质量 $m = 1$，引力常数 $G = 1$。密度必须减去平均值，即在求解泊松方程时使用 $\\rho(\\mathbf{x}) - \\bar{\\rho}$。使用上面定义的离散有效波数 $k_{\\mathrm{eff}}^2(\\mathbf{k})$，并通过有限差分在实空间中计算梯度。力插值必须使用与质量分配相同的 CIC 权重。粒子被放置在盒子中心附近，位置为 $(x,y) = (L/2 + \\delta_x, L/2 + \\delta_y)$，其中 $(\\delta_x, \\delta_y)$ 是在一个单元内指定的偏移量。\n\n任务：对于每个测试用例，计算伪力的大小 $||\\mathbf{F}_p||$ 和单次踢动后产生的速度增量 $||\\Delta \\mathbf{v}||$。报告每个测试用例的这两个浮点数，以揭示各向异性和标度关系。通过比较轴对齐与对角线的子单元偏移的 $||\\mathbf{F}_p||$ 值，可以揭示各向异性（“蛋盒”印记）。通过比较不同 $N$ 的结果，可以揭示随网格间距 $\\Delta$ 的标度关系；通过比较不同 $\\Delta t$ 的结果，可以揭示随时间步长 $\\Delta t$ 的标度关系。\n\n测试套件：\n- 情况 1：$N=32$，$\\Delta t = 0.01$，轴向偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, 0)$。\n- 情况 2：$N=32$，$\\Delta t = 0.01$，对角线偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$。\n- 情况 3：$N=16$，$\\Delta t = 0.01$，对角线偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$。\n- 情况 4：$N=32$，$\\Delta t = 0.005$，对角线偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$。\n- 情况 5：$N=32$，$\\Delta t = 0.01$，单元中心偏移 $(\\delta_x,\\delta_y) = (0, 0)$。\n\n对于每个测试用例 $i$，计算 $s_i = \\left\\lVert \\mathbf{F}_p \\right\\rVert$ 和 $u_i = \\left\\lVert \\Delta \\mathbf{v} \\right\\rVert$。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$[s_1,u_1,s_2,u_2,s_3,u_3,s_4,u_4,s_5,u_5]。$$\n\n所有计算和输出都是无量纲的实数。不出现角度。所有最终输出均表示为浮点数。任何地方都不出现百分比。程序必须是自包含的，并且不需要外部输入。", "solution": "用户提供的问题已经过验证，被认为是科学上合理、定义明确且自洽的。任务是实现一个数值实验，以测量在二维粒子网格（PM）引力模拟中，由单元内云（CIC）质量分配方案产生的伪各向异性力。该算法将按照规定从第一性原理构建。\n\nPM方法的核心包括四个步骤：\n1.  将粒子的质量分配到离散网格上，以定义密度场 $\\rho$。\n2.  在网格上求解泊松方程 $\\nabla^2 \\Phi = 4\\pi G (\\rho - \\bar{\\rho})$，以找到引力势 $\\Phi$。\n3.  在网格上计算力场 $\\mathbf{F}$ 作为势的负梯度，$\\mathbf{F} = -\\nabla \\Phi$。\n4.  将力从网格插值回粒子位置，以更新其速度。\n\n此过程将为一个质量 $m=1$ 的单个粒子在边长 $L=1$ 的周期性方盒中实现，引力常数 $G=1$。目标是为几种不同构型计算伪自作用力的大小 $||\\mathbf{F}_p||$ 和由此产生的速度增量 $||\\Delta\\mathbf{v}||$。\n\n程序步骤如下：\n\n1.  **系统离散化与粒子放置**\n    模拟区域是一个大小为 $L \\times L$ 的周期性方盒，其中 $L=1$。该区域被离散化为一个 $N \\times N$ 的均匀网格，网格间距为 $\\Delta = L/N$。对于每个由 $N$、时间步长 $\\Delta t$ 和子单元偏移 $(\\delta_x, \\delta_y)$ 指定的测试用例，将一个质量为 $m=1$ 的单个粒子放置在位置 $\\mathbf{p} = (x,y) = (L/2 + \\delta_x, L/2 + \\delta_y)$。\n\n2.  **质量分配：单元内云（CIC）**\n    粒子的质量 $m$ 被分配到 $N \\times N$ 网格上，以创建质量密度场 $\\rho_{ij}$。CIC方案将质量分配给最近的四个网格节点。设粒子位置为 $(x,y)$。其连续网格坐标为 $(g_x, g_y) = (x/\\Delta, y/\\Delta)$。这些坐标的整数部分确定了包含该粒子的单元格的左下角：$(i_0, j_0) = (\\lfloor g_x \\rfloor, \\lfloor g_y \\rfloor)$。小数部分 $(f_x, f_y) = (g_x - i_0, g_y - j_0)$ 决定了双线性插值的权重。权重为 $w_{x,0} = 1 - f_x$, $w_{x,1} = f_x$, $w_{y,0} = 1 - f_y$ 和 $w_{y,1} = f_y$。质量 $m$ 根据权重之积 $w_{x,a}w_{y,b}$ 分配给四个周围的节点 $(i_0+a, j_0+b)$，其中 $a,b \\in \\{0, 1\\}$。节点 $(i,j)$ 处的网格密度是此分配的质量除以单元面积 $\\Delta^2$。考虑到周期性边界条件，节点 $(i,j)=( (i_0+a)\\%N, (j_0+b)\\%N )$ 处的密度增加 $m \\cdot w_{x,a} w_{y,b} / \\Delta^2$。\n\n3.  **在傅里叶空间中求解泊松方程**\n    泊松方程 $\\nabla^2 \\Phi(\\mathbf{x}) = 4\\pi G\\left[\\rho(\\mathbf{x}) - \\bar{\\rho}\\right]$ 在傅里叶空间中求解最为高效，因为拉普拉斯算子 $\\nabla^2$ 变为简单的乘法。\n    首先，使用二维离散傅里叶变换（DFT）将实空间密度网格 $\\rho_{ij}$ 转换为傅里叶空间，得到 $\\tilde{\\rho}(\\mathbf{k})$。通过将势的 $\\mathbf{k}=\\mathbf{0}$（直流）分量设置为零来处理 $\\rho(\\mathbf{x}) - \\bar{\\rho}$ 项，即 $\\tilde{\\Phi}(\\mathbf{0}) = 0$。\n    离散波矢量为 $\\mathbf{k} = (k_x, k_y)$，其分量为 $k_x = 2\\pi n_x/L$ 和 $k_y = 2\\pi n_y/L$，其中 $n_x, n_y$ 为整数。问题指定使用二阶有限差分近似来表示拉普拉斯算子，其傅里叶表示是有效波数的平方：\n    $$k_{\\mathrm{eff}}^2(\\mathbf{k}) = \\left(\\frac{2}{\\Delta}\\right)^2\\left[\\sin^2\\left(\\frac{k_x \\Delta}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta}{2}\\right)\\right]$$\n    傅里叶空间中的势随后计算为：\n    $$\\tilde{\\Phi}(\\mathbf{k}) = -\\frac{4\\pi G\\, \\tilde{\\rho}(\\mathbf{k})}{k_{\\mathrm{eff}}^2(\\mathbf{k})}$$\n    这对所有 $\\mathbf{k} \\neq \\mathbf{0}$ 进行计算。对于 $\\mathbf{k} = \\mathbf{0}$，我们设置 $\\tilde{\\Phi}(\\mathbf{0}) = 0$。最后，通过对 $\\tilde{\\Phi}(\\mathbf{k})$ 应用逆二维DFT，恢复实空间势 $\\Phi_{ij}$。\n\n4.  **在网格上计算力**\n    网格上的引力场 $\\mathbf{F}_{ij} = (F_{x,ij}, F_{y,ij})$ 作为势的负梯度计算，$\\mathbf{F} = -\\nabla\\Phi$。这通过在势网格 $\\Phi_{ij}$ 上使用二阶中心有限差分格式来近似：\n    $$F_x(i,j) = -\\frac{\\Phi(i+1,j) - \\Phi(i-1,j)}{2\\Delta}$$\n    $$F_y(i,j) = -\\frac{\\Phi(i,j+1) - \\Phi(i,j-1)}{2\\Delta}$$\n    对索引 $(i,j)$ 应用周期性边界条件。\n\n5.  **力的插值与速度更新**\n    粒子精确位置 $\\mathbf{p}$ 处的力是通过从周围四个节点的网格力插值得到的，使用与质量分配步骤中相同的CIC权重：\n    $$\\mathbf{F}_p = \\sum_{a\\in\\{0,1\\}}\\sum_{b\\in\\{0,1\\}} \\left[w_{x,a} w_{y,b}\\right]\\, \\mathbf{F}((i_0+a)\\%N, (j_0+b)\\%N)$$\n    在一个理想的、完全各向同性的系统中，空盒子中的单个粒子应受到的自作用力为零。任何非零力 $\\mathbf{F}_p$ 都是数值效应。我们通过其大小 $s = ||\\mathbf{F}_p|| = \\sqrt{F_{p,x}^2 + F_{p,y}^2}$ 来量化这个伪力。\n    粒子的速度从静止开始，通过一个时间步长 $\\Delta t$ 的单次“踢”进行更新：\n    $$\\Delta \\mathbf{v} = \\mathbf{F}_p\\, \\Delta t$$\n    此速度增量的大小为 $u = ||\\Delta \\mathbf{v}|| = ||\\mathbf{F}_p|| \\Delta t = s \\cdot \\Delta t$。\n\n对于每个测试用例，我们计算并报告一对值 $(s, u)$。零偏移 $(\\delta_x, \\delta_y) = (0,0)$ 的情况将粒子精确放置在网格节点上，根据对称性，这必须导致净力为零，可作为对实现进行的关键合理性检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n\n    def compute_spurious_force(N, dt, delta_offset):\n        \"\"\"\n        Computes the spurious force and speed increment for a single particle.\n\n        Args:\n            N (int): Number of grid cells per dimension.\n            dt (float): Timestep for the velocity kick.\n            delta_offset (tuple): Particle offset (delta_x, delta_y) from the box center.\n\n        Returns:\n            tuple: A tuple containing the force magnitude (s) and speed increment (u).\n        \"\"\"\n        # 1. System Definition and Discretization\n        L = 1.0\n        G = 1.0\n        m = 1.0\n        delta = L / N\n        \n        delta_x, delta_y = delta_offset\n        \n        # Particle position\n        x = L / 2.0 + delta_x\n        y = L / 2.0 + delta_y\n\n        # 2. Mass Assignment (CIC)\n        rho_grid = np.zeros((N, N), dtype=np.float64)\n        \n        g_x = x / delta\n        g_y = y / delta\n        \n        i_0 = int(g_x)\n        j_0 = int(g_y)\n        \n        f_x = g_x - i_0\n        f_y = g_y - j_0\n        \n        weights_x = [1.0 - f_x, f_x]\n        weights_y = [1.0 - f_y, f_y]\n        \n        # Distribute mass to 4 nearest grid nodes\n        for b in range(2):\n            for a in range(2):\n                node_i = (i_0 + a) % N\n                node_j = (j_0 + b) % N\n                mass_fraction = m * weights_x[a] * weights_y[b]\n                rho_grid[node_j, node_i] += mass_fraction / (delta**2)\n\n        # 3. Solve Poisson Equation in Fourier Space\n        rho_k = np.fft.fft2(rho_grid)\n        \n        # Wave numbers\n        k_vals = 2.0 * np.pi * np.fft.fftfreq(N, d=delta)\n        KX, KY = np.meshgrid(k_vals, k_vals)\n\n        # Effective k^2 for finite difference Laplacian\n        k_eff_sq = (2.0 / delta)**2 * (np.sin(KX * delta / 2.0)**2 + np.sin(KY * delta / 2.0)**2)\n        \n        # Avoid division by zero at k=0\n        # The potential at k=0 will be set to 0 anyway.\n        k_eff_sq[0, 0] = 1.0  \n\n        # Potential in Fourier space\n        phi_k = -4.0 * np.pi * G * rho_k / k_eff_sq\n        \n        # Set k=0 mode of potential to zero (enforces mean density subtraction)\n        phi_k[0, 0] = 0.0\n\n        # Potential in real space\n        phi_grid = np.fft.ifft2(phi_k).real\n\n        # 4. Force Calculation on the Grid\n        # Using np.roll for periodic boundary conditions\n        Fx_grid = - (np.roll(phi_grid, -1, axis=1) - np.roll(phi_grid, 1, axis=1)) / (2.0 * delta)\n        Fy_grid = - (np.roll(phi_grid, -1, axis=0) - np.roll(phi_grid, 1, axis=0)) / (2.0 * delta)\n\n        # 5. Force Interpolation (CIC)\n        Fp_x = 0.0\n        Fp_y = 0.0\n        \n        for b in range(2):\n            for a in range(2):\n                node_i = (i_0 + a) % N\n                node_j = (j_0 + b) % N\n                weight = weights_x[a] * weights_y[b]\n                Fp_x += Fx_grid[node_j, node_i] * weight\n                Fp_y += Fy_grid[node_j, node_i] * weight\n\n        # Calculate final quantities\n        s = np.sqrt(Fp_x**2 + Fp_y**2)\n        u = s * dt\n        \n        return s, u\n\n    # Define the test cases from the problem statement.\n    test_params = [\n        {'N': 32, 'dt': 0.01, 'offset_frac': (1/4, 0)},\n        {'N': 32, 'dt': 0.01, 'offset_frac': (1/4, 1/4)},\n        {'N': 16, 'dt': 0.01, 'offset_frac': (1/4, 1/4)},\n        {'N': 32, 'dt': 0.005, 'offset_frac': (1/4, 1/4)},\n        {'N': 32, 'dt': 0.01, 'offset_frac': (0, 0)},\n    ]\n\n    results = []\n    for params in test_params:\n        N = params['N']\n        dt = params['dt']\n        delta = 1.0 / N\n        offset_frac_x, offset_frac_y = params['offset_frac']\n        delta_offset = (offset_frac_x * delta, offset_frac_y * delta)\n        \n        s, u = compute_spurious_force(N, dt, delta_offset)\n        results.extend([s, u])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3466963"}, {"introduction": "在精确宇宙学研究中，识别误差固然重要，但修正这些误差则更为关键。这项综合性练习挑战您推导并实现一种强大的傅里叶空间校正技术。该技术能够同时抵消 CIC 质量分配引入的平滑效应以及离散拉普拉斯算子和梯度计算带来的各向异性误差，从而展示了如何从有偏差的离散解中恢复出更精确、更符合物理的各向同性结果 [@problem_id:3466943]。", "problem": "您的任务是推导并实现在傅里叶空间中的联合反卷积，该反卷积同时校正了单元内云（CIC）质量分配窗口和由标准二阶离散拉普拉斯算子在均匀网格上引入的各向异性。背景是一个周期性的立方域和平面波密度模式，这些被用来测试恢复的引力的各向同性和准确性。目标是，从第一性原理出发，展示如何构建一个傅里叶空间中的乘法校正，将朴素的离散解映射回连续介质目标，并验证在不同方向的波矢上各向同性的改进。\n\n从以下基本基础开始：\n- 单元内云（CIC）方案是一个线性质量分配核。在傅里叶空间中，分配的密度振幅乘以一个窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$，对于间距为 $\\Delta x$ 的均匀立方网格，该函数可分解为\n$$\nW_{\\mathrm{CIC}}(\\boldsymbol{k}) \\;=\\; \\prod_{i\\in\\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left(\\frac{k_i \\,\\Delta x}{2}\\right) \\right]^2,\n\\quad \\mathrm{sinc}(z)\\equiv\\frac{\\sin z}{z},\n$$\n其中 $k_i$ 是角波矢 $\\boldsymbol{k}$ 的笛卡尔分量，单位为弧度/单位长度。sinc 函数在 $z=0$ 处的值根据连续性取为 $1$。\n- 在间距为 $\\Delta x$ 的网格上，二阶中心差分离散拉普拉斯算子具有平面波特征值\n$$\n\\tilde{k}^2(\\boldsymbol{k}) \\;=\\; \\frac{2}{\\Delta x^2}\\sum_{i\\in\\{x,y,z\\}} \\left[1 - \\cos\\!\\left(k_i \\,\\Delta x\\right)\\right],\n$$\n因此 $-\\nabla_{\\mathrm{disc}}^2 e^{i\\boldsymbol{k}\\cdot\\boldsymbol{x}} \\;=\\; \\tilde{k}^2(\\boldsymbol{k}) \\, e^{i\\boldsymbol{k}\\cdot\\boldsymbol{x}}$。\n- 在连续介质中，对于密度对比度场 $\\delta(\\boldsymbol{x})$，泊松方程在傅里叶空间中简化为\n$$\n\\phi(\\boldsymbol{k}) \\;=\\; -\\frac{\\delta(\\boldsymbol{k})}{k^2}, \\qquad k^2 \\equiv \\boldsymbol{k}\\cdot\\boldsymbol{k},\n$$\n引力为\n$$\n\\boldsymbol{f}(\\boldsymbol{k}) \\;=\\; -i\\,\\boldsymbol{k}\\,\\phi(\\boldsymbol{k}) \\;=\\; i\\,\\frac{\\boldsymbol{k}}{k^2}\\,\\delta(\\boldsymbol{k}),\n$$\n采用无量纲单位。\n\n您的任务：\n1. 仅使用上述事实，推导出一个傅里叶空间乘法反卷积 $D(\\boldsymbol{k})$，当应用于从CIC分配的密度和离散拉普拉斯算子获得的朴素离散傅里叶空间势时，可以为每个非零模式产生连续介质目标势。明确地说，您的 $D(\\boldsymbol{k})$ 必须联合校正单元内云（CIC）窗口 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 和离散拉普拉斯算子特征值 $\\tilde{k}^2(\\boldsymbol{k})$。\n2. 实现一个完整的程序，该程序：\n   - 构建一个大小为 $N\\times N\\times N$ 的周期性立方网格，其中 $N=32$，盒子边长 $L=1$（因此 $\\Delta x = L/N$）。\n   - 对于每个测试用例，使用指定的整数三元组 $(m_x,m_y,m_z)$ 构建一个平面波密度场 $\\delta(\\boldsymbol{x}) = \\cos(\\boldsymbol{k}\\cdot\\boldsymbol{x})$，其中 $\\boldsymbol{k} = \\frac{2\\pi}{L}(m_x,m_y,m_z)$。\n   - 计算 $\\delta(\\boldsymbol{x})$ 的快速傅里叶变换（FFT），并通过将每个傅里叶模式乘以 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 来应用单元内云（CIC）分配。\n   - 在傅里叶空间中使用离散拉普拉斯算子特征值求解朴素的离散泊松方程，以获得所有非零模式的 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})/\\tilde{k}^2(\\boldsymbol{k})$，零模式则为零。\n   - 形成朴素力 $\\boldsymbol{f}_{\\mathrm{naive}}(\\boldsymbol{k}) = -i\\,\\boldsymbol{k}\\,\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$，将其变换回实空间，并计算连续介质目标力 $\\boldsymbol{f}_{\\mathrm{true}}(\\boldsymbol{x}) = -\\frac{\\boldsymbol{k}}{k^2}\\sin(\\boldsymbol{k}\\cdot\\boldsymbol{x})$。\n   - 将您推导的联合反卷积 $D(\\boldsymbol{k})$ 应用于 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 以获得 $\\phi_{\\mathrm{corr}}(\\boldsymbol{k})$，构建校正后的力 $\\boldsymbol{f}_{\\mathrm{corr}}(\\boldsymbol{k}) = -i\\,\\boldsymbol{k}\\,\\phi_{\\mathrm{corr}}(\\boldsymbol{k})$，并在实空间中计算它。\n   - 对于每个测试用例，计算两个无量纲浮点数：朴素力的相对均方根误差\n     $$\n     \\varepsilon_{\\mathrm{naive}} \\;=\\; \\frac{\\left\\lVert \\boldsymbol{f}_{\\mathrm{naive}} - \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}{\\left\\lVert \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}},\n     $$\n     和校正后力的相对均方根误差\n     $$\n     \\varepsilon_{\\mathrm{corr}} \\;=\\; \\frac{\\left\\lVert \\boldsymbol{f}_{\\mathrm{corr}} - \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}{\\left\\lVert \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}.\n     $$\n     这里 $\\left\\lVert \\cdot \\right\\rVert_{L^2}$ 表示在网格上的均方根，即网格点上矢量场欧几里得范数平方的平均值的平方根。\n3. 全程使用无量纲单位，并确保所有三角函数使用弧度。\n4. 测试套件：\n   - 使用以下整数模式三元组 $(m_x,m_y,m_z)$ 来探测不同的方向和尺度：\n     - $(1,0,0)$：长波长轴对齐模式（理想情况）。\n     - $(3,0,0)$：中等波长轴对齐模式。\n     - $(3,5,2)$：离轴倾斜模式。\n     - $(15,0,0)$：近奈奎斯特频率轴对齐模式（边界）。\n     - $(15,14,0)$：近奈奎斯特频率离轴模式（边缘情况）。\n     - $(9,9,9)$：探测各向同性的对角线模式。\n5. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含结果，形式为无空格的逗号分隔方括号对列表，每个对为 $[\\varepsilon_{\\mathrm{naive}},\\varepsilon_{\\mathrm{corr}}]$，采用小数点后六位的科学记数法，按上述测试用例的顺序排列。例如：`[[1.234567e-03,4.567890e-05],[\\dots],[\\dots],\\dots]`。\n\n您的推导和实现应严格基于上述基本原理，不应依赖任何捷径或预先指定的校正公式。清晰地展示您的反卷积为何有效，以及它如何改善所提供的测试模式的各向同性。程序必须是自包含的，不需要任何输入、外部文件或网络访问。全程使用无量纲单位和弧度。", "solution": "用户在数值宇宙学领域提供了一个定义明确的问题。所有必要的物理和数学定义都已提供，目标清晰，并且问题在科学上基于标准的计算物理技术。因此，该问题被认为是有效的。\n\n### 联合反卷积因子的推导\n\n目标是找到傅里叶空间中的一个乘法校正因子 $D(\\boldsymbol{k})$，它将朴素计算出的引力势 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 转换为真实的连续介质势 $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$。\n\n令 $\\delta(\\boldsymbol{x})$ 为真实的连续介质密度对比度场。其傅里叶变换为 $\\delta(\\boldsymbol{k})$。在网格上的数值模拟背景下，该场首先被分配到网格单元上。问题陈述我们使用单元内云（CIC）分配方案对此进行建模，该方案起线性滤波器的作用。在傅里叶空间中，网格上的密度 $\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$ 通过 CIC 窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 与真实密度相关联：\n$$\n\\delta_{\\mathrm{CIC}}(\\boldsymbol{k}) = W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})\n$$\n其中\n$$\nW_{\\mathrm{CIC}}(\\boldsymbol{k}) \\;=\\; \\prod_{i\\in\\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left(\\frac{k_i \\,\\Delta x}{2}\\right) \\right]^2,\n\\quad \\mathrm{sinc}(z)\\equiv\\frac{\\sin z}{z}\n$$\n这里，$k_i$ 是波矢 $\\boldsymbol{k}$ 的分量，$\\Delta x$ 是网格间距。该窗口函数解释了单元内云（CIC）分配的平滑效应。\n\n接下来，求解离散泊松方程。连续介质的泊松方程在傅里叶空间中是 $\\nabla^2 \\phi = \\delta$（在适当单位下），这变为 $-k^2 \\phi(\\boldsymbol{k}) = \\delta(\\boldsymbol{k})$。朴素的离散方法用二阶有限差分拉普拉斯算子的特征值 $-\\tilde{k}^2(\\boldsymbol{k})$ 替换连续介质拉普拉斯算子的特征值 $-k^2 = -(\\boldsymbol{k}\\cdot\\boldsymbol{k})$，其中：\n$$\n\\tilde{k}^2(\\boldsymbol{k}) \\;=\\; \\frac{2}{\\Delta x^2}\\sum_{i\\in\\{x,y,z\\}} \\left[1 - \\cos\\!\\left(k_i \\,\\Delta x\\right)\\right]\n$$\n因此，朴素的离散求解器通过求解 $-\\tilde{k}^2(\\boldsymbol{k}) \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$ 来计算势 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$。对于任何 $\\tilde{k}^2(\\boldsymbol{k}) \\neq 0$ 的模式，朴素势为：\n$$\n\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\frac{\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})}\n$$\n代入 $\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$ 的表达式，我们得到：\n$$\n\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})}\n$$\n此表达式揭示了朴素解中两个误差来源：分子中的 CIC 窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$，以及分母中的离散拉普拉斯算子特征值 $\\tilde{k}^2(\\boldsymbol{k})$。\n\n目标解是连续介质势 $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$，由连续介质泊松方程定义：\n$$\n\\phi_{\\mathrm{true}}(\\boldsymbol{k}) = -\\frac{\\delta(\\boldsymbol{k})}{k^2}\n$$\n其中 $k^2 = \\boldsymbol{k}\\cdot\\boldsymbol{k}$ 是连续介质波矢的模平方。\n\n我们寻求一个反卷积因子 $D(\\boldsymbol{k})$，使得将其应用于朴素势能得到真实势：\n$$\n\\phi_{\\mathrm{corr}}(\\boldsymbol{k}) = D(\\boldsymbol{k}) \\, \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\phi_{\\mathrm{true}}(\\boldsymbol{k})\n$$\n代入 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 和 $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$ 的表达式：\n$$\nD(\\boldsymbol{k}) \\left( -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} \\right) = -\\frac{\\delta(\\boldsymbol{k})}{k^2}\n$$\n对于任何 $\\delta(\\boldsymbol{k}) \\neq 0$ 的模式 $\\boldsymbol{k}$，我们可以从两边消去 $-\\delta(\\boldsymbol{k})$：\n$$\nD(\\boldsymbol{k}) \\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} = \\frac{1}{k^2}\n$$\n解出 $D(\\boldsymbol{k})$，我们得到联合反卷积因子：\n$$\nD(\\boldsymbol{k}) = \\frac{\\tilde{k}^2(\\boldsymbol{k})}{k^2 \\, W_{\\mathrm{CIC}}(\\boldsymbol{k})}\n$$\n对于每个非零模式 $\\boldsymbol{k}$（即 $k^2 \\neq 0$），必须将此因子乘到朴素势 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 上。对于 $\\boldsymbol{k}=\\boldsymbol{0}$ 模式（直流分量），$k^2$ 和 $\\tilde{k}^2$ 均为零，势通常设置为零，因为它代表一个任意的常数偏移。反卷积因子 $D(\\boldsymbol{k})$ 同时校正了两个系统误差：\n1.  项 $1/W_{\\mathrm{CIC}}(\\boldsymbol{k})$“反卷积”或反转了 CIC 质量分配的平滑效应。\n2.  项 $\\tilde{k}^2(\\boldsymbol{k})/k^2$ 校正了离散拉普拉斯算子的各向异性和不准确响应，用各向同性的连续介质算子取而代之。\n\n因此，校正后的势为：\n$$\n\\phi_{\\mathrm{corr}}(\\boldsymbol{k}) = D(\\boldsymbol{k}) \\, \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\left( \\frac{\\tilde{k}^2(\\boldsymbol{k})}{k^2 \\, W_{\\mathrm{CIC}}(\\boldsymbol{k})} \\right) \\left( -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} \\right) = -\\frac{\\delta(\\boldsymbol{k})}{k^2} = \\phi_{\\mathrm{true}}(\\boldsymbol{k})\n$$\n这证实了所推导的反卷积因子的有效性。实现将为所有相关的傅里叶模式计算此因子，并应用它来获得一个校正后的力场，预期该力场将比朴素结果显著更准确和更具各向同性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a joint deconvolution in Fourier space to correct\n    for CIC mass assignment and discrete Laplacian anisotropy in a numerical\n    cosmology context.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    N = 32  # Grid size\n    L = 1.0  # Box side length\n    dx = L / N  # Grid spacing\n\n    # Real space grid coordinates\n    grid_1d = np.arange(N) * dx\n    xx, yy, zz = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # Fourier space wave vectors (angular frequencies)\n    k_freq = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n\n    # 2. Pre-compute Fourier-space kernels\n\n    # Mask for the k=0 mode\n    k_is_zero = (kx == 0)  (ky == 0)  (kz == 0)\n    non_zero_k = ~k_is_zero\n    \n    # Continuum Laplacian eigenvalue (squared magnitude of wave vector)\n    k_squared = kx**2 + ky**2 + kz**2\n\n    # Discrete Laplacian eigenvalue\n    tilde_k_squared = (2.0 / dx**2) * ( (1 - np.cos(kx * dx)) +\n                                       (1 - np.cos(ky * dx)) +\n                                       (1 - np.cos(kz * dx)) )\n\n    # CIC window function W_CIC(k).\n    # The problem defines sinc(z) = sin(z)/z.\n    # numpy.sinc(x) computes sin(pi*x)/(pi*x).\n    # To compute sin(z)/z, we can use np.sinc(z/pi).\n    # The argument to our sinc is z = k_i * dx / 2.\n    # So the argument to np.sinc is (k_i * dx / 2) / pi = k_i * dx / (2*pi).\n    sinc_arg_x = kx * dx / (2.0 * np.pi)\n    sinc_arg_y = ky * dx / (2.0 * np.pi)\n    sinc_arg_z = kz * dx / (2.0 * np.pi)\n    W_cic = (np.sinc(sinc_arg_x) * np.sinc(sinc_arg_y) * np.sinc(sinc_arg_z))**2\n    \n    # Joint deconvolution factor D(k)\n    # D(k) = tilde_k^2 / (k^2 * W_cic)\n    D_k = np.ones_like(kx, dtype=float) # Initialize to 1\n    # Compute only for non-zero k to avoid division by zero\n    D_k[non_zero_k] = np.divide(tilde_k_squared[non_zero_k],\n                                W_cic[non_zero_k] * k_squared[non_zero_k])\n    \n    # Test suite\n    test_cases = [\n        (1, 0, 0),\n        (3, 0, 0),\n        (3, 5, 2),\n        (15, 0, 0),\n        (15, 14, 0),\n        (9, 9, 9),\n    ]\n\n    results = []\n\n    for m_vec in test_cases:\n        # 3. Define the wave for the current test case\n        k0_vec = (2 * np.pi / L) * np.array(m_vec)\n        k0_sq = np.sum(k0_vec**2)\n\n        # 4. Generate density field and its Fourier transform\n        # delta(x) = cos(k_0 . x)\n        delta_x = np.cos(k0_vec[0] * xx + k0_vec[1] * yy + k0_vec[2] * zz)\n        delta_k = np.fft.fftn(delta_x)\n\n        # Apply CIC window effect\n        delta_cic_k = delta_k * W_cic\n\n        # 5. Naive Solution\n        # phi_naive(k) = -delta_cic(k) / tilde_k^2\n        phi_naive_k = np.zeros_like(delta_k, dtype=complex)\n        phi_naive_k[non_zero_k] = -delta_cic_k[non_zero_k] / tilde_k_squared[non_zero_k]\n        \n        # f_naive(k) = -i * k * phi_naive(k)\n        f_naive_k_x = -1j * kx * phi_naive_k\n        f_naive_k_y = -1j * ky * phi_naive_k\n        f_naive_k_z = -1j * kz * phi_naive_k\n\n        # Transform naive force back to real space\n        f_naive_x = np.real(np.fft.ifftn(f_naive_k_x))\n        f_naive_y = np.real(np.fft.ifftn(f_naive_k_y))\n        f_naive_z = np.real(np.fft.ifftn(f_naive_k_z))\n        f_naive = np.stack([f_naive_x, f_naive_y, f_naive_z])\n        \n        # 6. Corrected Solution\n        # phi_corr(k) = D(k) * phi_naive(k)\n        phi_corr_k = D_k * phi_naive_k\n        \n        # f_corr(k) = -i * k * phi_corr(k)\n        f_corr_k_x = -1j * kx * phi_corr_k\n        f_corr_k_y = -1j * ky * phi_corr_k\n        f_corr_k_z = -1j * kz * phi_corr_k\n\n        # Transform corrected force back to real space\n        f_corr_x = np.real(np.fft.ifftn(f_corr_k_x))\n        f_corr_y = np.real(np.fft.ifftn(f_corr_k_y))\n        f_corr_z = np.real(np.fft.ifftn(f_corr_k_z))\n        f_corr = np.stack([f_corr_x, f_corr_y, f_corr_z])\n\n        # 7. True (Continuum) Solution\n        # f_true(x) = -(k_0 / k_0^2) * sin(k_0 . x)\n        sin_term = np.sin(k0_vec[0] * xx + k0_vec[1] * yy + k0_vec[2] * zz)\n        # Avoid division by zero if k0_sq is zero (not the case here)\n        factor = -1.0 / k0_sq if k0_sq > 0 else 0.0\n        f_true_x = k0_vec[0] * factor * sin_term\n        f_true_y = k0_vec[1] * factor * sin_term\n        f_true_z = k0_vec[2] * factor * sin_term\n        f_true = np.stack([f_true_x, f_true_y, f_true_z])\n\n        # 8. Compute Errors\n        # L2-norm is sqrt of mean of squared magnitudes\n        norm_true_sq = np.mean(np.sum(f_true**2, axis=0))\n        \n        diff_naive_sq = np.mean(np.sum((f_naive - f_true)**2, axis=0))\n        err_naive = np.sqrt(diff_naive_sq / norm_true_sq)\n        \n        diff_corr_sq = np.mean(np.sum((f_corr - f_true)**2, axis=0))\n        err_corr = np.sqrt(diff_corr_sq / norm_true_sq)\n        \n        results.append([err_naive, err_corr])\n\n    # 9. Format and Print Output\n    output_str = '[' + ','.join([f'[{r[0]:.6e},{r[1]:.6e}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3466943"}]}