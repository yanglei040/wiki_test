{"hands_on_practices": [{"introduction": "在任何功率谱分析中，正确处理散粒噪声都是至关重要的一步。本练习将指导你直接从泊松点过程的统计特性出发，为加权巡天推导出精确的散粒噪声减除项。通过亲手实现并验证一个完整的功率谱估计器，你将把理论知识固化为实践技能。[@problem_id:3486501]", "problem": "实现一个完整的程序，用于构建和验证一个适用于具有空间变化选源函数的立方周期性巡天的 Feldman–Kaiser–Peacock (FKP) 加权功率谱估计器。目标是从非均匀泊松点过程的统计特性出发，推导出获得功率谱无偏估计器所需的精确散粒噪声减除项。该推导必须从具有强度的点过程及其两点统计的第一性原理开始，并且不得预先假设任何专门的快捷公式。然后，在离散化的、基于网格的设置中实现该估计器，并使用根据已知选源函数生成的随机星表对其进行验证。\n\n给定以下设置，该设置必须在所有部分中保持一致使用：\n\n- 考虑一个边长为 $L$ 且具有周期性边界条件的立方盒子。所有位置均以盒子边长为单位，所有待打印的量均为无物理单位的实数。\n- 用一个包含 $N^3$ 个等体积 $\\Delta V = L^3 / N^3$ 的立方单元（索引为 $i \\in \\{1,\\dots,N^3\\}$）的离散化网格来表示连续数密度场。定义单元中心的平均数密度为 $\\bar n_i \\equiv \\bar n(\\mathbf x_i)$，并令 $n_i$ 表示该单元中数密度的随机实现。对于非均匀泊松过程，单元 $i$ 中的点数服从均值为 $\\mu_i = \\bar n_i \\Delta V$ 的泊松分布，且 $n_i = \\text{Poisson}(\\mu_i)/\\Delta V$。\n- 定义一个实的、非负的权重场 $w(\\mathbf x)$，其离散化形式为 $w_i \\equiv w(\\mathbf x_i)$。\n- 定义网格上的加权涨落场为 $F_i = w_i \\left(n_i - \\bar n_i\\right)$。\n- 将网格上 $F_i$ 的离散傅里叶变换定义为连续变换的近似：\n  $$ F(\\mathbf k) \\approx \\Delta V \\sum_{i=1}^{N^3} F_i \\, e^{i \\mathbf k \\cdot \\mathbf x_i}, $$\n  使用周期性网格上的标准离散傅里叶变换约定。所有波矢量 $\\mathbf k$ 均以由网格傅里叶变换决定的基本模式 $2\\pi / L$ 为单位。\n\n你的任务：\n\n1. 从强度为 $\\bar n(\\mathbf x)$ 的非均匀泊松点过程及其两点协方差的定义，以及加权场 $F(\\mathbf x) = w(\\mathbf x)\\left[n(\\mathbf x) - \\bar n(\\mathbf x)\\right]$ 的定义出发，推导出精确的、与 $k$ 无关的散粒噪声项 $S$。当估计器通过巡天权重积分 $I_1$ 的平方进行归一化时，为在没有成团性的情况下获得功率谱振幅的无偏估计器，该项必须从 $|F(\\mathbf k)|^2$ 中减去。你的推导必须从以下几点开始：\n   - 泊松点过程的定义属性：对于无穷小体积 $d^3x$，计数服从均值为 $\\bar n(\\mathbf x) d^3x$ 的泊松分布，以及\n   - 数密度的协方差：对于一般的两点统计，$\\langle n(\\mathbf x) n(\\mathbf y) \\rangle = \\bar n(\\mathbf x) \\bar n(\\mathbf y) \\left[1 + \\xi(\\mathbf x,\\mathbf y)\\right] + \\bar n(\\mathbf x) \\delta_{\\rm D}(\\mathbf x - \\mathbf y)$，其中 $\\delta_{\\rm D}$ 是狄拉克δ分布，$\\xi$ 是两点相关函数。\n   不要预先假设 $S$ 的任何特殊情况或快捷表达式。清楚地说明你使用的归一化积分，并获得一个以 $\\bar n(\\mathbf x)$ 和 $w(\\mathbf x)$ 的空间积分为形式的 $S$ 的闭式表达式。\n\n2. 按如下方式在三维网格上实现离散化估计器：\n   - 使用近似相应空间积分的离散求和来计算 $I_1$ 和推导出的 $S$。\n   - 根据 $\\bar n_i$ 生成每个单元中服从泊松分布的数密度。\n   - 使用 $F_i$ 的离散傅里叶变换乘以 $\\Delta V$ 来计算网格上的傅里叶变换 $F(\\mathbf k)$。\n   - 对于每个非零 $\\mathbf k$ 模式，构建\n     $$ \\hat P(\\mathbf k) = \\frac{|F(\\mathbf k)|^2}{I_1^2} - S, $$\n     并如下面的测试套件所指定的那样聚合统计数据。\n   - 权重场 $w(\\mathbf x)$ 可以是任意的；对于其中一个测试用例，使用 FKP 权重 $w_{\\rm FKP}(\\mathbf x) = \\left[1 + \\bar n(\\mathbf x) P_0\\right]^{-1}$，其中 $P_0$ 是一个给定的常数。\n\n3. 通过打印所要求的标量值，在三个测试用例中验证散粒噪声减除的正确性。所有要求的输出都是无量纲的。\n\n测试套件和要求输出：\n\n- 测试用例 A（均匀基线一致性）：\n  - 参数：$L = 200$, $N = 48$, $\\bar n(\\mathbf x) = n_0$ 其中 $n_0 = 2 \\times 10^{-3}$，以及 $w(\\mathbf x) \\equiv 1$。\n  - 使用网格求和，根据你的通用公式计算离散散粒噪声项，并将其与从第一性原理推导出的常数 $\\bar n$ 和常数 $w$ 的均匀场极限预测值进行比较。令 $V = L^3$ 并将均匀场预测值表示为 $S_{\\rm unif}$。对此测试用例，输出绝对差 $\\left|S_{\\rm grid} - S_{\\rm unif}\\right|$，作为一个浮点数。\n\n- 测试用例 B（通过随机星表验证非均匀选源函数）：\n  - 参数：$L = 200$, $N = 48$，空间变化的平均密度\n    $$ \\bar n(\\mathbf x) = n_0 \\left[1 + a \\sin\\left(\\frac{2\\pi x}{L}\\right)\\sin\\left(\\frac{2\\pi y}{L}\\right)\\sin\\left(\\frac{2\\pi z}{L}\\right)\\right], $$\n    其中 $n_0 = 2 \\times 10^{-3}$ 且 $a = 0.4$。使用 $w(\\mathbf x) \\equiv 1$。\n  - 在网格上根据你的通用公式计算 $S_{\\rm grid}$。\n  - 使用从盒内与 $\\bar n(\\mathbf x)$ 成正比的概率密度中抽取的随机星表，通过蒙特卡洛积分独立地估计相同的量。使用足够大量的蒙特卡洛样本，并基于与 $\\bar n(\\mathbf x)$ 成正比的目标进行重要性抽样，返回相同表达式的蒙特卡洛估计值 $S_{\\rm MC}$。\n  - 对此测试用例，输出绝对差 $\\left|S_{\\rm grid} - S_{\\rm MC}\\right|$，作为一个浮点数。\n\n- 测试用例 C（FKP 加权的端到端零检验）：\n  - 参数：$L = 200$, $N = 48$，与测试用例 B 中相同的 $\\bar n(\\mathbf x)$，FKP 权重，其中 $P_0 = 5000$。\n  - 对每个单元格抽取一个与 $\\bar n_i$ 一致的泊松实现，并使用你的估计器和推导出的 $S$ 来计算所有非零 $\\mathbf k$ 模式的 $\\hat P(\\mathbf k)$。\n  - 输出所有非零模式上 $\\hat P(\\mathbf k)$ 均值的绝对值，作为一个浮点数。在没有成团性的情况下，如果散粒噪声减除是正确的，这个量应该接近于零。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试用例 A、B、C 的顺序排列：\n  - 测试用例 A：浮点数 $\\left|S_{\\rm grid} - S_{\\rm unif}\\right|$。\n  - 测试用例 B：浮点数 $\\left|S_{\\rm grid} - S_{\\rm MC}\\right|$。\n  - 测试用例 C：浮点数 $\\left|\\langle \\hat P(\\mathbf k) \\rangle_{\\mathbf k \\ne 0}\\right|$。\n- 示例格式（所示数字为占位符）：\"[0.00123,4.56e-06,0.0000789]\"。", "solution": "用户提供的问题陈述已经过验证，并被认为是合理的、适定的且具有科学依据。我们继续提供解决方案，该方案包括一个理论推导，随后是对数值实现和验证测试的说明。\n\n### 1. 散粒噪声项的推导\n\n目标是为功率谱估计器 $\\hat P(\\mathbf k)$ 推导出散粒噪声减除项 $S$。该推导从非均匀泊松点过程的第一性原理开始。\n\n加权涨落场 $F(\\mathbf{x})$ 定义为：\n$$\nF(\\mathbf{x}) = w(\\mathbf{x}) \\left[ n(\\mathbf{x}) - \\bar{n}(\\mathbf{x}) \\right]\n$$\n其中 $n(\\mathbf{x})$ 是实现的数密度，$\\bar{n}(\\mathbf{x})$ 是泊松过程的平均数密度（或强度），$w(\\mathbf{x})$ 是一个空间权重函数。\n\n该场的傅里叶变换由下式给出：\n$$\nF(\\mathbf{k}) = \\int_V F(\\mathbf{x}) e^{i \\mathbf{k} \\cdot \\mathbf{x}} d^3x\n$$\n问题将模式 $\\mathbf{k}$ 的功率谱估计器定义为：\n$$\n\\hat P(\\mathbf{k}) = \\frac{|F(\\mathbf{k})|^2}{I_1^2} - S\n$$\n为使该估计器在没有物理成团性的情况下是无偏的，其期望值必须为零。因此，散粒噪声项 $S$ 必须等于在无成团性零假设下第一项的期望值。\n$$\nS = \\left\\langle \\frac{|F(\\mathbf{k})|^2}{I_1^2} \\right\\rangle_{\\xi=0}\n$$\n此处，$\\xi$ 表示两点相关函数。我们计算分子 $\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0}$。\n\n首先，我们展开 $|F(\\mathbf{k})|^2 = F(\\mathbf{k}) F^*(\\mathbf{k})$：\n$$\n\\langle|F(\\mathbf{k})|^2\\rangle = \\left\\langle \\left( \\int_V F(\\mathbf{x}) e^{i \\mathbf{k} \\cdot \\mathbf{x}} d^3x \\right) \\left( \\int_V F(\\mathbf{y}) e^{-i \\mathbf{k} \\cdot \\mathbf{y}} d^3y \\right) \\right\\rangle\n$$\n根据期望算子的线性性质，这变为：\n$$\n\\langle|F(\\mathbf{k})|^2\\rangle = \\iint_V \\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle e^{i \\mathbf{k} \\cdot (\\mathbf{x} - \\mathbf{y})} d^3x d^3y\n$$\n接下来，我们计算加权场的两点相关函数 $\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle$：\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle = \\langle w(\\mathbf{x})[n(\\mathbf{x}) - \\bar{n}(\\mathbf{x})] w(\\mathbf{y})[n(\\mathbf{y}) - \\bar{n}(\\mathbf{y})] \\rangle = w(\\mathbf{x}) w(\\mathbf{y}) \\left[ \\langle n(\\mathbf{x}) n(\\mathbf{y}) \\rangle - \\bar{n}(\\mathbf{x})\\bar{n}(\\mathbf{y}) \\right]\n$$\n问题为一般点过程提供了协方差：\n$$\n\\langle n(\\mathbf{x}) n(\\mathbf{y}) \\rangle = \\bar{n}(\\mathbf{x}) \\bar{n}(\\mathbf{y}) [1 + \\xi(\\mathbf{x}, \\mathbf{y})] + \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})\n$$\n其中 $\\delta_{\\rm D}$ 是狄拉克δ分布。将此代入 $\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle$ 的表达式中：\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle = w(\\mathbf{x}) w(\\mathbf{y}) \\left[ \\bar{n}(\\mathbf{x}) \\bar{n}(\\mathbf{y}) \\xi(\\mathbf{x}, \\mathbf{y}) + \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y}) \\right]\n$$\n我们关心的是散粒噪声的贡献，即在没有成团性（即 $\\xi(\\mathbf{x}, \\mathbf{y}) = 0$）时的值。\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle_{\\xi=0} = w(\\mathbf{x}) w(\\mathbf{y}) \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})\n$$\n由于δ函数 $\\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})$ 的存在，该表达式仅在 $\\mathbf{x} = \\mathbf{y}$ 时非零。因此，我们可以用 $w(\\mathbf{x})$ 替换 $w(\\mathbf{y})$：\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle_{\\xi=0} = w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})\n$$\n现在，我们将其代回 $\\langle |F(\\mathbf{k})|^2 \\rangle$ 的积分中：\n$$\n\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0} = \\iint_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y}) e^{i \\mathbf{k} \\cdot (\\mathbf{x} - \\mathbf{y})} d^3x d^3y\n$$\n对 $\\mathbf{y}$ 积分会消去δ函数：\n$$\n\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0} = \\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) e^{i \\mathbf{k} \\cdot (\\mathbf{x} - \\mathbf{x})} d^3x = \\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) d^3x\n$$\n这个量代表了来自散粒噪声的总功率，并且它与波矢量 $\\mathbf{k}$ 无关。我们将此积分表示为 $I_S$：\n$$\nI_S = \\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) d^3x\n$$\n问题指出估计器由 $I_1^2$ 归一化，其中 $I_1$ 是一个“巡天权重积分”。在这种情况下，对此积分的一个标准且合乎逻辑的选择是：\n$$\nI_1 = \\int_V w(\\mathbf{x}) \\bar{n}(\\mathbf{x}) d^3x\n$$\n该积分与巡天中天体总数的加权期望成正比。我们将采用此定义。\n\n根据这些定义，确保 $\\langle \\hat P(\\mathbf{k}) \\rangle_{\\xi=0} = 0$ 的散粒噪声项 $S$ 是：\n$$\nS = \\frac{\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0}}{I_1^2} = \\frac{\\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) d^3x}{\\left( \\int_V w(\\mathbf{x}) \\bar{n}(\\mathbf{x}) d^3x \\right)^2}\n$$\n这就是散粒噪声减除项的最终表达式。\n\n### 2. 离散化实现与验证计划\n\n连续推导现在被转换为一个针对 $N^3$ 个单元的立方网格的离散算法，每个单元的体积为 $\\Delta V = (L/N)^3$。积分被替换为对网格单元（索引为 $i$）的求和：\n$$\nI_S \\rightarrow I_{S, \\text{grid}} = \\sum_{i=1}^{N^3} w_i^2 \\bar{n}_i \\Delta V\n$$\n$$\nI_1 \\rightarrow I_{1, \\text{grid}} = \\sum_{i=1}^{N^3} w_i \\bar{n}_i \\Delta V\n$$\n离散散粒噪声项则为：\n$$\nS_{\\text{grid}} = \\frac{I_{S, \\text{grid}}}{I_{1, \\text{grid}}^2}\n$$\n涨落场 $F_i = w_i(n_i - \\bar{n}_i)$ 的离散傅里叶变换由 $F(\\mathbf k) \\approx \\Delta V \\sum_i F_i e^{i \\mathbf k \\cdot \\mathbf x_i}$ 给出。这可以使用快速傅里叶变换（FFT）高效地计算。具体来说，如果 $\\mathcal{F}$ 表示来自 `numpy.fft` 的 `ifftn` 例程（它使用正指数），那么对于波矢量网格的 $F(\\mathbf k)$ 计算为 $L^3 \\times \\mathcal{F}[F_i]$。然后其模的平方为 $|F(\\mathbf k)|^2$。\n\n验证计划按照指定的三个测试用例进行。\n\n**测试用例 A（均匀基线一致性）：**\n在这里，$\\bar{n}(\\mathbf{x}) = n_0$ 且 $w(\\mathbf{x}) = 1$。$S_{\\text{grid}}$ 的离散公式给出：\n$S_{\\text{grid}} = \\frac{\\sum_i 1^2 n_0 \\Delta V}{(\\sum_i 1 \\cdot n_0 \\Delta V)^2} = \\frac{N^3 n_0 \\Delta V}{(N^3 n_0 \\Delta V)^2} = \\frac{n_0 L^3}{(n_0 L^3)^2} = \\frac{1}{n_0 L^3}$。\n从第一性原理推导出的均匀场极限预测 $S_{\\text{unif}}$ 得出相同的结果。该测试要求计算绝对差 $|S_{\\text{grid}} - S_{\\text{unif}}|$，在浮点精度范围内，该值应为零。\n\n**测试用例 B（通过蒙特卡洛验证非均匀选源函数）：**\n在这里，$\\bar{n}(\\mathbf{x})$ 随空间变化且 $w(\\mathbf{x}) = 1$。$S_{\\text{grid}}$ 使用通用的离散公式计算。\n对于蒙特卡洛估计 $S_{\\text{MC}}$，我们必须估计量 $S = 1 / \\int_V \\bar{n}(\\mathbf{x}) d^3x$。积分 $I_{\\text{norm}} = \\int_V \\bar{n}(\\mathbf{x}) d^3x$ 按照指定使用拒绝抽样法进行估计。我们为 $\\bar{n}(\\mathbf{x})$ 定义一个高度为 $n_{\\text{max}} = \\max_{\\mathbf x} \\bar{n}(\\mathbf{x})$ 的包围盒。我们在体积 $V \\times [0, n_{\\text{max}}]$ 中生成 $N_{\\text{tot}}$ 个均匀随机点 $(\\mathbf{x}_j, u_j)$。被接受的点数 $N_{\\text{acc}}$ 是那些满足 $u_j  \\bar{n}(\\mathbf{x}_j)$ 的点。然后积分估计为 $\\hat{I}_{\\text{norm}} = (N_{\\text{acc}} / N_{\\text{tot}}) \\times n_{\\text{max}} \\times L^3$。接着，$S_{\\text{MC}} = 1/\\hat{I}_{\\text{norm}}$。该测试计算 $|S_{\\text{grid}} - S_{\\text{MC}}|$。\n\n**测试用例 C（FKP 加权的端到端零检验）：**\n此测试验证整个估计器流程。对于一个空间变化的 $\\bar{n}(\\mathbf{x})$ 和 FKP 权重 $w_{\\text{FKP}}(\\mathbf{x}) = [1 + \\bar{n}(\\mathbf{x}) P_0]^{-1}$，我们首先使用完整的离散公式计算散粒噪声项 $S$。然后，我们生成泊松场的单个实现：对于每个单元 $i$，从均值为 $\\mu_i = \\bar{n}_i \\Delta V$ 的泊松分布中抽取天体数 $N_i$。这给出了实现密度 $n_i = N_i / \\Delta V$。由此，我们计算涨落场 $F_i$、其傅里叶变换 $F(\\mathbf{k})$，最后计算所有非零波矢量的估计功率谱 $\\hat P(\\mathbf{k}) = |F(\\mathbf{k})|^2/I_{1,\\text{grid}}^2 - S$。由于基础场没有成团性，$\\hat P(\\mathbf{k})$ 的期望值为零。该测试计算所有 $\\mathbf{k} \\neq \\mathbf{0}$ 的 $\\hat P(\\mathbf{k})$ 的均值的绝对值。对于单个实现，该值会很小但非零，代表样本方差。对许多模式进行平均会减小此方差，因此结果应接近于零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates the FKP weighted power spectrum estimator's\n    shot-noise subtraction term.\n    \"\"\"\n\n    def get_shot_noise(n_bar, w, L, N):\n        \"\"\"\n        Computes the shot noise term S from the derived formula on a grid.\n        S = (Integral(w^2 * n_bar) / Integral(w * n_bar)^2)\n        \"\"\"\n        delta_V = (L / N)**3\n        \n        # Numerator integral: I_S = Integral(w^2 * n_bar dV)\n        integrand_S = w**2 * n_bar\n        I_S_grid = np.sum(integrand_S) * delta_V\n        \n        # Denominator integral: I_1 = Integral(w * n_bar dV)\n        integrand_1 = w * n_bar\n        I_1_grid = np.sum(integrand_1) * delta_V\n        \n        S_grid = I_S_grid / (I_1_grid**2)\n        return S_grid, I_1_grid\n\n    # --- Test Case A: Uniform Baseline Consistency ---\n    def test_case_a():\n        L = 200.0\n        N = 48\n        n0 = 2.0e-3\n        \n        # Setup grid\n        n_bar_grid = np.full((N, N, N), n0)\n        w_grid = np.ones((N, N, N))\n        \n        # Compute S_grid from the general formula\n        S_grid, _ = get_shot_noise(n_bar_grid, w_grid, L, N)\n        \n        # Compute S_unif from the analytical prediction for a uniform field\n        V = L**3\n        S_unif = 1.0 / (n0 * V)\n        \n        return np.abs(S_grid - S_unif)\n\n    # --- Test Case B: Nonuniform Selection Validation by MC ---\n    def test_case_b():\n        L = 200.0\n        N = 48\n        n0 = 2.0e-3\n        a = 0.4\n        \n        # Setup grid and fields\n        grid_coords = np.linspace(0, L, N, endpoint=False) + 0.5 * (L/N)\n        X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n        \n        k_factor = 2.0 * np.pi / L\n        sin_term = np.sin(k_factor * X) * np.sin(k_factor * Y) * np.sin(k_factor * Z)\n        n_bar_grid = n0 * (1.0 + a * sin_term)\n        w_grid = np.ones((N, N, N))\n        \n        # Compute S_grid from the general formula\n        S_grid, _ = get_shot_noise(n_bar_grid, w_grid, L, N)\n        \n        # Compute S_MC by Monte Carlo integration (rejection sampling)\n        N_tot = 2 * 10**7\n        n_max = n0 * (1.0 + a)\n        V = L**3\n        \n        # Using vectorized operations for efficiency\n        rand_pos = np.random.uniform(0, L, (N_tot, 3))\n        rand_u = np.random.uniform(0, n_max, N_tot)\n        \n        n_bar_values = n0 * (1.0 + a * np.prod(np.sin(k_factor * rand_pos), axis=1))\n        \n        N_acc = np.sum(rand_u  n_bar_values)\n        \n        I_norm_mc = (N_acc / N_tot) * n_max * V\n        S_mc = 1.0 / I_norm_mc\n        \n        return np.abs(S_grid - S_mc)\n\n    # --- Test Case C: FKP-Weighted End-to-End Null Test ---\n    def test_case_c():\n        L = 200.0\n        N = 48\n        n0 = 2.0e-3\n        a = 0.4\n        P0 = 5000.0\n        \n        # Setup grid and fields\n        delta_V = (L / N)**3\n        grid_coords = np.linspace(0, L, N, endpoint=False) + 0.5 * (L/N)\n        X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n        \n        k_factor = 2.0 * np.pi / L\n        sin_term = np.sin(k_factor * X) * np.sin(k_factor * Y) * np.sin(k_factor * Z)\n        n_bar_grid = n0 * (1.0 + a * sin_term)\n        \n        # FKP weights\n        w_grid = 1.0 / (1.0 + n_bar_grid * P0)\n        \n        # Compute shot noise S and normalization I_1\n        S, I_1_grid = get_shot_noise(n_bar_grid, w_grid, L, N)\n        \n        # Generate a Poisson realization\n        mu_grid = n_bar_grid * delta_V\n        np.random.seed(42) # for reproducibility\n        N_grid = np.random.poisson(mu_grid)\n        n_grid = N_grid / delta_V\n        \n        # Compute the fluctuation field\n        F_grid = w_grid * (n_grid - n_bar_grid)\n        \n        # Compute its Fourier transform. F(k) = L^3 * ifftn(F_i)\n        F_k_grid = L**3 * np.fft.ifftn(F_grid)\n        \n        # Compute the unbiased power spectrum estimator P_hat(k)\n        P_hat_k = np.abs(F_k_grid)**2 / I_1_grid**2 - S\n        \n        # Calculate the mean of P_hat(k) over all k != 0 modes\n        # The k=0 mode is at index (0,0,0)\n        num_modes = N**3 - 1\n        mean_P_hat = (np.sum(P_hat_k) - P_hat_k[0, 0, 0]) / num_modes\n        \n        return np.abs(mean_P_hat)\n\n    # Run all test cases and collect results\n    results = [\n        test_case_a(),\n        test_case_b(),\n        test_case_c()\n    ]\n    \n    # Format and print the final output string\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3486501"}, {"introduction": "理想化的 $1/\\bar{n}$ 散粒噪声项在实践中会受到功率谱估计算法中数值方法的影响。本练习旨在分离并量化质量分配方案和混叠效应，展示朴素的解卷积如何在小尺度上放大噪声。通过此练习，你将学习到一种强大的缓解这些数值效应的技术——交错网格法（interlacing）。[@problem_id:3486452]", "problem": "要求您构建一个独立的程序，用于在一个周期性的立方体域中，分离并量化快速傅里叶变换（FFT）质量分配窗口对泊松散粒噪声的影响，并提出一种数值稳定的减法方案。在纯数学环境下工作，无需模拟粒子。必须以下述基本原理为出发点：(i) 均匀泊松点过程具有恒定的散粒噪声功率谱，其值为 $P_{\\rm shot} = 1/\\bar n$，其中 $\\bar n$ 是平均数密度；(ii) 傅里叶变换将实空间中的卷积转换为傅里叶空间中的乘积；(iii) 在规则网格上对连续场进行采样会引入由奈奎斯特频率的整数倍平移产生的混叠图像。您必须利用这些原理来推导并实现所要求的流程。\n\n考虑一个边长为 $\\mathcal{L}$ 的周期性立方体盒子，以及一个均匀的单元尺寸 $\\Delta x$，它定义了用于FFT分析的规则网格。令奈奎斯特频率为 $k_{\\rm Ny} = \\pi/\\Delta x$。接下来，您将分析质量分配窗口、交错和反卷积在傅里叶空间中对均匀泊松场的影响。\n\n使用的定义：\n- 令给定方案的质量分配窗口为 $W(\\mathbf{k}) = \\prod_{j \\in \\{x,y,z\\}} \\left[\\mathrm{sinc}\\left(\\frac{k_j \\Delta x}{2}\\right)\\right]^p$，其中 $\\mathrm{sinc}(u) \\equiv \\sin(u)/u$。对于最近格点法（NGP），使用 $p=1$；对于云中单元法（CIC），使用 $p=2$；对于三角形状云法（TSC），使用 $p=3$。模的平方为 $|W(\\mathbf{k})|^2 = \\prod_{j} \\left[\\mathrm{sinc}\\left(\\frac{k_j \\Delta x}{2}\\right)\\right]^{2p}$。\n- 在规则网格上采样会引入形式为 $\\mathbf{k} + 2 k_{\\rm Ny} \\mathbf{n}$ 的混叠图像，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。\n- 对于一个具有恒定底层 $P_{\\rm shot} = 1/\\bar n$ 且无宇宙学信号的均匀泊松场，在模式 $\\mathbf{k}$ 处经过窗口化、采样和反卷积后的功率可以写为\n$$\nP_{\\rm meas}^{\\rm deconv}(\\mathbf{k}) \\;=\\; \\frac{1}{\\bar n} \\;\\frac{\\displaystyle \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\omega(\\mathbf{n})\\,\\left|W\\!\\left(\\mathbf{k} + 2 k_{\\rm Ny} \\mathbf{n}\\right)\\right|^2}{\\left|W(\\mathbf{k})\\right|^2},\n$$\n其中 $\\omega(\\mathbf{n})$ 是一个交错权重：无交错时，对所有 $\\mathbf{n}$ 都有 $\\omega(\\mathbf{n}) = 1$，而对于两个半单元偏移网格的交错，如果 $n_x + n_y + n_z$ 是偶数，则 $\\omega(\\mathbf{n}) = 1$，如果 $n_x + n_y + n_z$ 是奇数，则 $\\omega(\\mathbf{n}) = 0$。这反映了通过交错消除奇宇称混叠图像。\n- 将反卷积下的有效散粒噪声放大因子定义为\n$$\n\\mathcal{A}(\\mathbf{k}) \\;\\equiv\\; \\frac{P_{\\rm meas}^{\\rm deconv}(\\mathbf{k})}{1/\\bar n} \\;=\\; \\frac{\\displaystyle \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\omega(\\mathbf{n})\\,\\left|W\\!\\left(\\mathbf{k} + 2 k_{\\rm Ny} \\mathbf{n}\\right)\\right|^2}{\\left|W(\\mathbf{k})\\right|^2}.\n$$\n\n您的任务：\n- 实现一个流程来计算与x轴对齐的模式 $\\mathbf{k} = (k,0,0)$ 的 $\\mathcal{A}(\\mathbf{k})$，计算在奈奎斯特频率的指定分数 $f$ 处进行，即 $k = f\\,k_{\\rm Ny}$。为了数值处理的可行性并分离窗口和交错效应，通过将 $\\mathbf{n}$ 的分量 $n_i$ 限制在 $\\{-1,0,1\\}$ 内来近似混叠和。您必须在求和中明确包含中心图像 $\\mathbf{n}=\\mathbf{0}$。\n- 使用三种质量分配方案：NGP ($p=1$)、CIC ($p=2$)和TSC ($p=3$)。\n- 根据上述定义，通过权重 $\\omega(\\mathbf{n})$ 实现交错。\n\n稳定减法要求：\n- 提出一种稳定的、逐模式的散粒噪声减法估计器，该估计器在高 $k$ 值时能避免灾难性放大，同时在低 $k$ 值时保持准确性。对于此问题，实现一个带上限的估计器\n$$\n\\widehat{P}_{\\rm shot}(\\mathbf{k}) \\;=\\; \\frac{1}{\\bar n}\\,\\min\\!\\left(\\mathcal{A}(\\mathbf{k}),\\, \\mathcal{A}_{\\rm cap}\\right),\n$$\n其上限由相同方案和交错选择在阈值 $k_t = f_t\\,k_{\\rm Ny}$ (其中 $f_t = 0.7$) 处定义，即\n$$\n\\mathcal{A}_{\\rm cap} \\;=\\; \\mathcal{A}\\!\\left(k_t\\right).\n$$\n- 将残差（由 $1/\\bar n$ 归一化）定义为\n$$\n\\mathcal{R}(\\mathbf{k}) \\;\\equiv\\; \\frac{P_{\\rm meas}^{\\rm deconv}(\\mathbf{k}) - \\widehat{P}_{\\rm shot}(\\mathbf{k})}{1/\\bar n} \\;=\\; \\mathcal{A}(\\mathbf{k}) - \\min\\!\\left(\\mathcal{A}(\\mathbf{k}),\\, \\mathcal{A}_{\\rm cap}\\right).\n$$\n\n测试套件：\n- 对于所有计算，将 $\\Delta x$ 设为任意单位，使得 $k_{\\rm Ny} = \\pi/\\Delta x$ 仅通过分数 $f$ 出现；您的输出必须是无量纲的，且独立于任何物理单位的选择。\n- 对所有三个轴使用混叠截断，即 $n_i \\in \\{-1,0,1\\}$。\n- 评估并以浮点数形式输出以下五个结果：\n    $1.$ NGP无交错在 $f = 0.2$ 时的放大系数 $\\mathcal{A}(k)$。\n    $2.$ CIC有交错在 $f = 0.6$ 时的放大系数 $\\mathcal{A}(k)$。\n    $3.$ TSC有交错在 $f = 0.95$ 时的放大系数 $\\mathcal{A}(k)$。\n    $4.$ CIC有交错在 $f = 0.95$ 时的残差 $\\mathcal{R}(k)$，上限由相同方案和交错选择在 $f_t = 0.7$ 处定义。\n    $5.$ TSC有交错在集合 $f \\in \\{0.2, 0.6, 0.95\\}$ 上的残差平方均值，上限由该相同方案和交错选择在 $f_t = 0.7$ 处定义：\n    $$\n    \\overline{\\mathcal{R}^2} \\;=\\; \\frac{1}{3}\\,\\sum_{f \\in \\{0.2,0.6,0.95\\}} \\left[\\mathcal{R}\\!\\left(f\\,k_{\\rm Ny}\\right)\\right]^2.\n    $$\n- 最终输出格式：您的程序应生成单行输出，其中包含按上述顺序列出的结果，结果为逗号分隔的列表，并用方括号括起来。\n\n注意事项和约束：\n- 角度和三角函数参数以弧度为单位。\n- 不要模拟粒子；根据上述窗口和混叠模型解析地计算所有量。\n- 通过定义 $\\mathrm{sinc}(0)=1$ 来确保在 $\\mathrm{sinc}$ 函数参数为0的点的数值稳定性。\n- 所有输出均为无量纲浮点数。", "solution": "用户提供的问题已经过分析和验证。\n\n### 第1步：提取已知条件\n- **域**：边长为 $\\mathcal{L}$ 的周期性立方体盒子。\n- **网格**：均匀单元尺寸 $\\Delta x$。\n- **奈奎斯特频率**：$k_{\\rm Ny} = \\pi/\\Delta x$。\n- **质量分配窗口**：$W(\\mathbf{k}) = \\prod_{j \\in \\{x,y,z\\}} \\left[\\mathrm{sinc}\\left(\\frac{k_j \\Delta x}{2}\\right)\\right]^p$，其中 $\\mathrm{sinc}(u) \\equiv \\sin(u)/u$。\n  - 最近格点法 (NGP): $p=1$。\n  - 云中单元法 (CIC): $p=2$。\n  - 三角形状云法 (TSC): $p=3$。\n- **混叠模型**：来自均匀泊松场 ($P_{\\rm shot} = 1/\\bar n$) 的反卷积功率为：\n$$P_{\\rm meas}^{\\rm deconv}(\\mathbf{k}) = \\frac{1}{\\bar n} \\frac{\\displaystyle \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\omega(\\mathbf{n})\\,\\left|W\\!\\left(\\mathbf{k} + 2 k_{\\rm Ny} \\mathbf{n}\\right)\\right|^2}{\\left|W(\\mathbf{k})\\right|^2}$$\n- **交错权重**：对所有 $\\mathbf{n}$，$\\omega(\\mathbf{n}) = 1$ (无交错)。有交错时，如果 $n_x + n_y + n_z$ 为偶数，则 $\\omega(\\mathbf{n}) = 1$，如果为奇数，则 $\\omega(\\mathbf{n}) = 0$。\n- **放大因子**：$\\mathcal{A}(\\mathbf{k}) \\equiv P_{\\rm meas}^{\\rm deconv}(\\mathbf{k}) / (1/\\bar n)$。\n- **散粒噪声估计器**：$\\widehat{P}_{\\rm shot}(\\mathbf{k}) = \\frac{1}{\\bar n}\\,\\min\\!\\left(\\mathcal{A}(\\mathbf{k}),\\, \\mathcal{A}_{\\rm cap}\\right)$。\n- **估计器上限**：$\\mathcal{A}_{\\rm cap} = \\mathcal{A}(k_t)$，其中 $k_t = f_t\\,k_{\\rm Ny}$ 且 $f_t = 0.7$。\n- **残差**：$\\mathcal{R}(\\mathbf{k}) = \\mathcal{A}(\\mathbf{k}) - \\min\\!\\left(\\mathcal{A}(\\mathbf{k}),\\, \\mathcal{A}_{\\rm cap}\\right)$。\n- **数值近似**：混叠和 $\\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}$ 被截断为 $\\mathbf{n}$ 的分量 $n_i \\in \\{-1, 0, 1\\}$。\n- **评估模式**：与x轴对齐的模式，$\\mathbf{k} = (k,0,0)$，其中 $k = f\\,k_{\\rm Ny}$。\n- **测试用例**：\n  1. NGP ($p=1$)，无交错，在 $f = 0.2$ 时的 $\\mathcal{A}(k)$。\n  2. CIC ($p=2$)，有交错，在 $f = 0.6$ 时的 $\\mathcal{A}(k)$。\n  3. TSC ($p=3$)，有交错，在 $f = 0.95$ 时的 $\\mathcal{A}(k)$。\n  4. CIC ($p=2$)，有交错，在 $f = 0.95$ 时的 $\\mathcal{R}(k)$，$f_t=0.7$。\n  5. TSC ($p=3$)，有交错时的残差平方均值 $\\overline{\\mathcal{R}^2} = \\frac{1}{3}\\,\\sum_{f \\in \\{0.2,0.6,0.95\\}} \\left[\\mathcal{R}(f\\,k_{\\rm Ny})\\right]^2$，$f_t=0.7$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题科学上基于宇宙学中快速傅里叶变换（FFT）功率谱估计的混叠效应标准模型。所提供的质量分配窗口、混叠和以及交错的方程是文献中的标准公式 (例如 Hockney  Eastwood 的《Computer Simulation Using Particles》)。该问题是适定的，提供了所有必要的定义、常数和评估点，以得出一组唯一的数值结果。语言客观且专业。混叠和的截断是为了数值处理的可行性而做出的明确且必要的简化。该问题是自洽的、数学上一致的，并且没有说明中列出的导致无效的缺陷。\n\n### 第3步：结论与行动\n问题是**有效的**。将提供解决方案。\n\n### 基于原理的设计与求解\n核心任务是计算波矢量 $\\mathbf{k}=(k,0,0)$ 的散粒噪声放大因子 $\\mathcal{A}(\\mathbf{k})$，然后用它来求指定的量。计算过程首先在给定约束下简化 $\\mathcal{A}(\\mathbf{k})$ 的表达式。\n\n不失一般性，我们设置网格间距 $\\Delta x=1$，因为所有波矢量都以奈奎斯特频率 $k_{\\rm Ny} = \\pi/\\Delta x = \\pi$ 的分数形式给出。因此，$\\mathbf{k} = (f\\pi, 0, 0)$。\n\n窗口函数的模平方为：\n$$|W(\\mathbf{k'})|^2 = \\prod_{j \\in \\{x,y,z\\}} \\left|\\mathrm{sinc}\\left(\\frac{k'_j \\Delta x}{2}\\right)\\right|^{2p} = \\prod_{j \\in \\{x,y,z\\}} \\left[\\mathrm{sinc}\\left(\\frac{k'_j}{2}\\right)\\right]^{2p}$$\n根据定义 $\\mathrm{sinc}(0)=1$。混叠波矢量为 $\\mathbf{k'} = \\mathbf{k} + 2k_{\\rm Ny}\\mathbf{n} = (f\\pi + 2\\pi n_x, 2\\pi n_y, 2\\pi n_z)$。\n\nsinc函数的参数为：\n- $\\frac{k'_x}{2} = \\frac{f\\pi + 2\\pi n_x}{2} = \\pi\\left(\\frac{f}{2} + n_x\\right)$\n- $\\frac{k'_y}{2} = \\frac{2\\pi n_y}{2} = \\pi n_y$\n- $\\frac{k'_z}{2} = \\frac{2\\pi n_z}{2} = \\pi n_z$\n\n项 $\\left[\\mathrm{sinc}(\\pi n_j)\\right]^{2p}$ 仅在 $n_j=0$ 时非零，因为对于任何非零整数 $m$，$\\mathrm{sinc}(m\\pi) = \\sin(m\\pi)/(m\\pi) = 0$。由于求和被截断为 $n_y, n_z \\in \\{-1, 0, 1\\}$，任何 $n_y \\neq 0$ 或 $n_z \\neq 0$ 的项都将为零。因此，对 $\\mathbf{n}$ 的 $3^3=27$ 个值的求和简化为仅对 $n_y=n_z=0$ 的三个项求和：$\\mathbf{n} \\in \\{(-1,0,0), (0,0,0), (1,0,0)\\}$。\n\n因此，放大因子为：\n$$ \\mathcal{A}(k) = \\frac{\\displaystyle \\sum_{n_x=-1}^{1} \\omega(n_x,0,0)\\,\\left|W(k+2k_{\\rm Ny} n_x, 0, 0)\\right|^2}{|W(k,0,0)|^2} $$\n其中 $|W(k',0,0)|^2 = \\left[\\mathrm{sinc}\\left(\\frac{k'}{2}\\right)\\right]^{2p} \\left[\\mathrm{sinc}(0)\\right]^{2p} \\left[\\mathrm{sinc}(0)\\right]^{2p} = \\left[\\mathrm{sinc}\\left(\\frac{k'}{2}\\right)\\right]^{2p}$。\n\n表达式简化为：\n$$ \\mathcal{A}(k) = \\frac{\\sum_{n_x=-1}^{1} \\omega(n_x,0,0) \\left[\\mathrm{sinc}\\left(\\pi(\\frac{f}{2}+n_x)\\right)\\right]^{2p}}{\\left[\\mathrm{sinc}\\left(\\pi \\frac{f}{2}\\right)\\right]^{2p}} $$\n\n现在我们分析交错的情况。\n\n**情况1：无交错**\n这里，对所有 $n_x$，$\\omega(n_x, 0, 0) = 1$。\n$$ \\mathcal{A}(k) = \\frac{\\left[\\mathrm{sinc}\\left(\\pi(\\frac{f}{2}-1)\\right)\\right]^{2p} + \\left[\\mathrm{sinc}\\left(\\pi\\frac{f}{2}\\right)\\right]^{2p} + \\left[\\mathrm{sinc}\\left(\\pi(\\frac{f}{2}+1)\\right)\\right]^{2p}}{\\left[\\mathrm{sinc}\\left(\\pi \\frac{f}{2}\\right)\\right]^{2p}} $$\n这可以简化为：\n$$ \\mathcal{A}(k) = 1 + \\left(\\frac{\\mathrm{sinc}(\\pi(\\frac{f}{2}-1))}{\\mathrm{sinc}(\\pi\\frac{f}{2})}\\right)^{2p} + \\left(\\frac{\\mathrm{sinc}(\\pi(\\frac{f}{2}+1))}{\\mathrm{sinc}(\\pi\\frac{f}{2})}\\right)^{2p} $$\n使用恒等式 $\\mathrm{sinc}(u \\pm \\pi) = \\frac{\\mp u}{u \\pm \\pi}\\mathrm{sinc}(u)$，其中 $u=\\pi f/2$，比率分别变为 $\\frac{f}{2-f}$ 和 $\\frac{-f}{2+f}$。\n$$ \\mathcal{A}(k) = 1 + \\left(\\frac{f}{2-f}\\right)^{2p} + \\left(\\frac{f}{2+f}\\right)^{2p} $$\n\n**情况2：有交错**\n权重 $\\omega(n_x, 0, 0)$ 仅在 $n_x+0+0 = n_x$ 是偶数时非零。在 $n_x \\in \\{-1, 0, 1\\}$ 范围内，只有 $n_x=0$ 是偶数。\n因此，求和中只有 $n_x=0$ 的项保留下来。\n分子变为 $\\omega(0,0,0) \\left[\\mathrm{sinc}\\left(\\pi \\frac{f}{2}\\right)\\right]^{2p} = 1 \\cdot \\left[\\mathrm{sinc}\\left(\\pi \\frac{f}{2}\\right)\\right]^{2p}$。\n放大因子为：\n$$ \\mathcal{A}(k) = \\frac{\\left[\\mathrm{sinc}\\left(\\pi \\frac{f}{2}\\right)\\right]^{2p}}{\\left[\\mathrm{sinc}\\left(\\pi \\frac{f}{2}\\right)\\right]^{2p}} = 1 $$\n这个结果虽然出奇地简单，却是问题定义的直接结果：对于坐标轴上的一个模式，指定的交错方案完美地消除了截断和中包含的主阶混叠图像。\n\n有了这些公式，我们就可以计算所需的量。\n\n1.  **NGP ($p=1$)，无交错，在 $f = 0.2$ 时的 $\\mathcal{A}(k)$：**\n    使用无交错公式，其中 $p=1, f=0.2$：\n    $$ \\mathcal{A} = 1 + \\left(\\frac{0.2}{2-0.2}\\right)^{2} + \\left(\\frac{0.2}{2+0.2}\\right)^{2} = 1 + \\left(\\frac{0.2}{1.8}\\right)^{2} + \\left(\\frac{0.2}{2.2}\\right)^{2} = 1 + \\left(\\frac{1}{9}\\right)^2 + \\left(\\frac{1}{11}\\right)^2 $$\n    $$ \\mathcal{A} = 1 + \\frac{1}{81} + \\frac{1}{121} \\approx 1.0206101418 $$\n\n2.  **CIC ($p=2$)，有交错，在 $f = 0.6$ 时的 $\\mathcal{A}(k)$：**\n    使用交错公式，结果与 $p$ 和 $f$ 无关：\n    $$ \\mathcal{A} = 1.0 $$\n\n3.  **TSC ($p=3$)，有交错，在 $f = 0.95$ 时的 $\\mathcal{A}(k)$：**\n    使用交错公式：\n    $$ \\mathcal{A} = 1.0 $$\n\n4.  **CIC ($p=2$)，有交错，在 $f = 0.95$, $f_t=0.7$ 时的 $\\mathcal{R}(k)$：**\n    方案是带交错的CIC。\n    $f=0.95$ 时的 $\\mathcal{A}(k)$ 是 $1.0$。\n    上限为 $\\mathcal{A}_{\\rm cap} = \\mathcal{A}(k_t)$，其中 $k_t=0.7 k_{\\rm Ny}$。对于此方案，$\\mathcal{A}(k_t) = 1.0$。\n    残差为 $\\mathcal{R}(k) = \\mathcal{A}(k) - \\min(\\mathcal{A}(k), \\mathcal{A}_{\\rm cap}) = 1.0 - \\min(1.0, 1.0) = 0.0$。\n\n5.  **TSC ($p=3$)，有交错，在 $f \\in \\{0.2, 0.6, 0.95\\}$, $f_t=0.7$ 时的 $\\overline{\\mathcal{R}^2}$：**\n    方案是带交错的TSC。对任何 $f$，$\\mathcal{A}(k)=1.0$。上限 $\\mathcal{A}_{\\rm cap}$ 也是 $1.0$。\n    因此，对所有 $k$，残差 $\\mathcal{R}(k)$ 均为 $0.0$。残差的平方也均为 $0.0$。\n    残差平方的均值为 $\\overline{\\mathcal{R}^2} = \\frac{1}{3}(0^2+0^2+0^2) = 0.0$。\n\n实现将遵循这些推导出的公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes shot noise amplification and residuals based on the problem statement.\n    \"\"\"\n\n    def compute_amplification(f, p, interlacing):\n        \"\"\"\n        Computes the shot noise amplification factor A(k) for k = f*k_Ny.\n\n        Args:\n            f (float): Fraction of the Nyquist frequency, k/k_Ny.\n            p (int): Order of the mass assignment scheme (1=NGP, 2=CIC, 3=TSC).\n            interlacing (bool): True if interlacing is used, False otherwise.\n\n        Returns:\n            float: The amplification factor A(k).\n        \"\"\"\n        if not (0  f  2):\n            # Deconvolution is undefined or problematic at f=0 and f=2 (Nyquist).\n            # The problem's f values are in (0,1).\n            if f == 0: return 1.0\n            raise ValueError(\"f must be in (0, 2) to avoid division by zero in sinc.\")\n\n        if interlacing:\n            # For a mode k on a coordinate axis, the chosen interlacing scheme\n            # perfectly cancels the alias images from n={-1, 1} in the truncated sum.\n            # Only the n=0 term survives, resulting in A(k) = 1.\n            return 1.0\n        else:\n            # For the non-interlaced case, the sum includes aliases from n_x = -1, 0, 1.\n            # A(k) = 1 + (sinc(pi(f/2-1))/sinc(pi*f/2))^(2p) + (sinc(pi(f/2+1))/sinc(pi*f/2))^(2p)\n            # This simplifies to the more stable form below:\n            term1 = (f / (2.0 - f)) ** (2 * p)\n            term2 = (f / (2.0 + f)) ** (2 * p) # The minus sign in -f/(2+f) vanishes due to squaring\n            return 1.0 + term1 + term2\n\n    def compute_residual(f, p, interlacing, f_t):\n        \"\"\"\n        Computes the residual R(k) after capped shot-noise subtraction.\n\n        Args:\n            f (float): Fraction of the Nyquist frequency.\n            p (int): Order of the mass assignment scheme.\n            interlacing (bool): True if interlacing is used.\n            f_t (float): Fraction of Nyquist frequency for the cap threshold.\n\n        Returns:\n            float: The residual R(k).\n        \"\"\"\n        A_k = compute_amplification(f, p, interlacing)\n        A_cap = compute_amplification(f_t, p, interlacing)\n        residual = A_k - min(A_k, A_cap)\n        return residual\n\n    # Define test cases from the problem statement.\n    # (p, f, interlacing, f_t)\n    # p: 1=NGP, 2=CIC, 3=TSC\n    \n    results = []\n\n    # 1. Amplification for NGP without interlacing at f = 0.2\n    p1, f1, interlacing1 = 1, 0.2, False\n    res1 = compute_amplification(f1, p1, interlacing1)\n    results.append(res1)\n\n    # 2. Amplification for CIC with interlacing at f = 0.6\n    p2, f2, interlacing2 = 2, 0.6, True\n    res2 = compute_amplification(f2, p2, interlacing2)\n    results.append(res2)\n\n    # 3. Amplification for TSC with interlacing at f = 0.95\n    p3, f3, interlacing3 = 3, 0.95, True\n    res3 = compute_amplification(f3, p3, interlacing3)\n    results.append(res3)\n\n    # 4. Residual for CIC with interlacing at f = 0.95, using ft = 0.7\n    p4, f4, interlacing4, f_t4 = 2, 0.95, True, 0.7\n    res4 = compute_residual(f4, p4, interlacing4, f_t4)\n    results.append(res4)\n\n    # 5. Mean of squared residuals for TSC with interlacing\n    p5, interlacing5, f_t5 = 3, True, 0.7\n    f_values_5 = [0.2, 0.6, 0.95]\n    squared_residuals = []\n    for f_val in f_values_5:\n        r = compute_residual(f_val, p5, interlacing5, f_t5)\n        squared_residuals.append(r**2)\n    \n    res5 = np.mean(squared_residuals)\n    results.append(res5)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486452"}, {"introduction": "在真实的数据分析中，经常会遇到意想不到的结果，例如在高波数处出现负的功率谱值。本练习提供了一个诊断此类异常的框架，教你如何使用定制化的模拟数据（mock）来区分物理效应（如不正确的散粒噪声水平）和系统误差（如巡天窗口函数导致的功率泄露）。[@problem_id:3486487]", "problem": "给定一组测量的功率谱带，在减去 $1/\\bar n$ 后，这些功率谱带在高 $k$ 值处变为负值。在数值宇宙学的背景下，考虑一个巡天窗口的一维玩具模型，以设计一种有原则的诊断方法，用于区分散粒噪声的过度扣除和由窗口函数引起的大尺度功率泄漏。该诊断方法必须基于由可控的底层功率谱构建的、经窗口函数卷积的模拟功率谱带。最终交付成果是一个完整的、可运行的程序，该程序实现此诊断方法，并为提供的测试套件输出分类结果。\n\n从以下基本原理出发：\n\n- 在实空间中，星系超密度场乘以巡天窗口函数 $W(x)$，在傅里叶空间中对应于真实谱与窗口核的卷积。具体而言，构型空间中的乘法对应于傅里叶空间中的卷积。\n- 对于离散示踪物的泊松采样，对功率谱的散粒噪声贡献近似为常数，等于 $1/\\bar n$，其中 $\\bar n$ 是平均数密度。\n- 在窗口函数下测得的伪功率谱带被建模为经窗口函数卷积的真实功率加上一个恒定的散粒噪声项。\n\n使用两组经窗口函数卷积的模拟功率谱带设计一个诊断程序：\n\n- 构建一个具有由平滑谱 $P_{\\mathrm{true}}(k)$ 表征的完整大尺度功率的模拟数据。\n- 构建一个模拟数据，其中大尺度功率在截止波数 $k_{\\mathrm{cut}}$ 以下被抑制，从而产生一个修正谱 $P_{\\mathrm{cut}}(k)$。\n\n在两个模拟数据中使用相同的巡天窗口。对于巡天窗口，将实空间窗口建模为一个长度为 $L$ 的顶帽函数，其傅里叶空间核与波数差的sinc函数的平方成正比。将波数在一个最小值和最大值之间的均匀网格上离散为 $N$ 个区间，并将窗口卷积近似为一个离散混合矩阵，该矩阵的元素仅取决于波数差，并以在每个输出行上保持总功率的方式进行归一化。对于完整的模拟数据，使用以下真实谱形式：\n$$\nP_{\\mathrm{true}}(k) = \\frac{A_0}{1 + \\left(\\frac{k}{k_0}\\right)^2}.\n$$\n通过设置当 $k \\le k_{\\mathrm{cut}}$ 时 $P_{\\mathrm{cut}}(k) = 0$ 以及当 $k  k_{\\mathrm{cut}}$ 时 $P_{\\mathrm{cut}}(k) = P_{\\mathrm{true}}(k)$ 来定义“截止”模拟数据。\n\n给定真实平均密度 $\\bar n_{\\mathrm{true}}$ 的值和一个假定值 $\\bar n_{\\mathrm{assumed}}$，将伪功率谱带构建为经窗口函数卷积的功率加上恒定的散粒噪声 $1/\\bar n_{\\mathrm{true}}$。根据这些模拟数据，定义以下诊断量，这些量是在包含波数网格顶部比例 $f_{\\mathrm{high}}$ 的高 $k$ 值区间子集上计算的：\n\n- 有效散粒噪声估计 $S_{\\mathrm{eff}}$，即“截止”模拟数据伪功率谱带在高 $k$ 值区域的平均值。\n- 泄漏度量 $L_{\\mathrm{metric}}$，即完整模拟数据伪功率谱带在高 $k$ 值区域的平均值与“截止”模拟数据伪功率谱带在高 $k$ 值区域的平均值之差。\n\n使用阈值 $\\tau = 0.05 \\times \\left(1/\\bar n_{\\mathrm{assumed}}\\right)$，将高 $k$ 值处功率谱带为负的原因分类如下：\n\n- 过度扣除：如果 $1/\\bar n_{\\mathrm{assumed}} - S_{\\mathrm{eff}}  \\tau$ 且 $L_{\\mathrm{metric} } \\le \\tau$。\n- 窗口引起的泄漏：如果 $L_{\\mathrm{metric}}  \\tau$ 且 $1/\\bar n_{\\mathrm{assumed}} - S_{\\mathrm{eff}} \\le \\tau$。\n- 不明确：如果以上两个条件同时为真或同时为假。\n\n您的程序必须实现上述诊断方法，并为以下测试套件生成分类。每个测试用例提供 $\\left(N, L, A_0, k_0, \\bar n_{\\mathrm{true}}, \\bar n_{\\mathrm{assumed}}, k_{\\mathrm{cut}}, f_{\\mathrm{high}}\\right)$：\n\n- 测试用例 1 (理想情况下的过度扣除): $\\left(256, 200.0, 10^{-3}, 0.05, 1000.0, 800.0, 0.03, 0.3\\right)$。\n- 测试用例 2 (理想情况下的泄漏): $\\left(256, 20.0, 5\\times 10^{-3}, 0.02, 1000.0, 1000.0, 0.03, 0.3\\right)$。\n- 测试用例 3 (混合贡献，边界情况): $\\left(256, 20.0, 3\\times 10^{-3}, 0.02, 1000.0, 900.0, 0.03, 0.3\\right)$。\n- 测试用例 4 (边界，无强效应): $\\left(256, 200.0, 10^{-3}, 0.05, 1000.0, 1000.0, 0.03, 0.3\\right)$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，结果为用方括号括起来的逗号分隔列表。使用以下整数代码进行分类：$0$ 表示过度扣除，$1$ 表示泄漏，$2$ 表示不明确。例如，如果结果是这些，则输出格式必须为 $\\left[0,1,2,2\\right]$。\n\n所有计算都是无量纲的；不需要物理单位。不涉及角度。所有派生的数值答案在内部均表示为浮点值。最终输出必须是如上所述的单行整数列表。", "solution": "该问题要求设计并实现一种诊断程序，以区分在扣除散粒噪声后，高波数（$k$）处功率谱带出现负值的两个潜在原因：1) 由于对平均星系密度（$\\bar{n}$）的估计不正确而导致的散粒噪声过度扣除；2) 由巡天窗口函数引起的大尺度（低 $k$）功率向小尺度（高 $k$）的泄漏。该诊断是在一个简化的一维玩具模型中构建的。\n\n其核心原则是构建两个模拟数据集来分离这些效应。一个模拟数据包含完整的宇宙学功率，而第二个模拟数据则人为地移除了其大尺度功率。通过比较这些模拟数据，我们可以量化泄漏的贡献，并将其与散粒噪声相关的影响区分开来。整个过程作为一系列明确定义的计算步骤来实现。\n\n首先，我们建立计算域。连续的波数 $k$ 在一个有限范围 $[k_{\\min}, k_{\\max}]$ 内被离散化为 $N$ 个均匀的区间。根据问题的特征尺度（$k_0 \\approx 0.02-0.05$），选择一个合理的范围，例如 $k_{\\min} = 0$ 到 $k_{\\max} = 1.0$。每个区间 $i$ 的中心表示为 $k_i$。\n\n接下来，我们定义底层的理论功率谱。完整的、平滑的功率谱 $P_{\\mathrm{true}}(k)$ 由一个类洛伦兹函数建模：\n$$\nP_{\\mathrm{true}}(k) = \\frac{A_0}{1 + \\left(\\frac{k}{k_0}\\right)^2}\n$$\n其中 $A_0$ 是振幅，$k_0$ 是一个特征尺度。为了分离大尺度功率的影响，定义了第二个谱 $P_{\\mathrm{cut}}(k)$。这个“截止”谱与 $P_{\\mathrm{true}}(k)$ 相同，但在某个截止波数 $k_{\\mathrm{cut}}$ 以下被设置为零：\n$$\nP_{\\mathrm{cut}}(k) = \\begin{cases} 0  k \\le k_{\\mathrm{cut}} \\\\ P_{\\mathrm{true}}(k)  k  k_{\\mathrm{cut}} \\end{cases}\n$$\n这两个谱以在各区间中心 $k_i$ 处求值的向量表示，作为我们模拟观测的基准真相。\n\n必须对巡天窗口函数的影响进行建模。在构型空间中，观测到的星系场是真实场乘以窗口函数 $W(x)$。在傅里叶空间中，这对应于真实功率谱与窗口的功率谱（或核）的卷积。对于长度为 $L$ 的顶帽窗口，傅里叶核与sinc函数的平方成正比。这种卷积被一个混合矩阵 $M$ 离散地近似。元素 $M_{ij}$ 量化了从输入区间 $k_j$ “泄漏”到输出区间 $k_i$ 的功率大小。它由以下公式给出：\n$$\nM_{ij} \\propto \\mathrm{sinc}^2\\left(\\frac{L(k_i - k_j)}{2}\\right)\n$$\n其中sinc函数为 $\\mathrm{sinc}(x) = \\sin(x)/x$。矩阵 $M$ 的构造方式是使其每行之和为 $1$（对于所有 $i$，$\\sum_j M_{ij} = 1$）。这种归一化确保了一个平坦的输入谱在卷积后仍然保持平坦，在特定意义上守恒了功率。\n\n有了这些组件，我们就可以构建模拟的伪功率谱带。它们模拟了在真实巡天中将要测量的结果。它们是经窗口函数卷积的真实功率加上一个由真实示踪物平均密度决定的恒定散粒噪声项 $1/\\bar{n}_{\\mathrm{true}}$：\n$$\n\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{full}} = M \\cdot \\vec{P}_{\\mathrm{true}} + \\frac{1}{\\bar{n}_{\\mathrm{true}}}\n$$\n$$\n\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{cut}} = M \\cdot \\vec{P}_{\\mathrm{cut}} + \\frac{1}{\\bar{n}_{\\mathrm{true}}}\n$$\n这里，$\\vec{P}_{\\mathrm{true}}$ 和 $\\vec{P}_{\\mathrm{cut}}$ 是在每个 $k_i$ 处的功率谱值的向量，$M \\cdot \\vec{P}$ 表示矩阵-向量乘法。\n\n该诊断依赖于在“高 $k$”区域上计算的两个量，该区域定义为波数区间的顶部比例 $f_{\\mathrm{high}}$。\n第一个诊断量是有效散粒噪声估计 $S_{\\mathrm{eff}}$。它是“截止”模拟数据的高 $k$ 伪功率谱带的平均值：\n$$\nS_{\\mathrm{eff}} = \\mathrm{mean}\\left( \\left(\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{cut}}\\right)_{\\mathrm{high-}k} \\right)\n$$\n通过使用“截止”模拟数据，我们移除了泄漏的主要来源（在 $k \\le k_{\\mathrm{cut}}$ 处的功率）。因此，$S_{\\mathrm{eff}}$ 表示真实散粒噪声与从中间尺度（$k  k_{\\mathrm{cut}}$）泄漏到高 $k$ 区域的任何残余功率之和。\n\n第二个诊断量是泄漏度量 $L_{\\mathrm{metric}}$。它是完整模拟数据和“截止”模拟数据在高 $k$ 功率平均值之间的差：\n$$\nL_{\\mathrm{metric}} = \\mathrm{mean}\\left( \\left(\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{full}}\\right)_{\\mathrm{high-}k} \\right) - \\mathrm{mean}\\left( \\left(\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{cut}}\\right)_{\\mathrm{high-}k} \\right)\n$$\n这个差值抵消了公共的散粒噪声项以及任何来自 $k  k_{\\mathrm{cut}}$ 的泄漏，从而完美地分离出从大尺度（$k \\le k_{\\mathrm{cut}}$）泄漏到高 $k$ 频带的功率。\n\n最后，根据这些度量进行分类。假定要扣除的散粒噪声是 $1/\\bar{n}_{\\mathrm{assumed}}$。与有效散粒噪声的偏差是 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}}$。我们定义一个显著性阈值 $\\tau = 0.05 \\times (1/\\bar{n}_{\\mathrm{assumed}})$。\n- **过度扣除（代码 $0$）**：如果散粒噪声差异显著而泄漏不显著，则声明为此类：$1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}}  \\tau$ 且 $L_{\\mathrm{metric}} \\le \\tau$。这表明负功率谱带主要是由于扣除了过大的散粒噪声值造成的。\n- **窗口引起的泄漏（代码 $1$）**：如果泄漏显著而散粒噪声差异很小，则声明为此类：$L_{\\mathrm{metric}}  \\tau$ 且 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}} \\le \\tau$。这指出主要问题是来自低 $k$ 模式的功率污染了高 $k$ 区间。\n- **不明确（代码 $2$）**：此类别适用于两种效应均显著（$L_{\\mathrm{metric}}  \\tau$ 且 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}}  \\tau$）或均不显著（$L_{\\mathrm{metric}} \\le \\tau$ 且 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}} \\le \\tau$）的情况。\n\n这种基于模型的、有原则的方法为诊断宇宙学功率谱估计中的异常来源提供了一种定量的、可自动化的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _run_diagnostic_case(params):\n    \"\"\"\n    Runs the diagnostic procedure for a single test case.\n\n    Args:\n        params (tuple): A tuple containing the parameters for the test case:\n            (N, L, A0, k0, n_true, n_assumed, k_cut, f_high).\n\n    Returns:\n        int: The classification code (0, 1, or 2).\n    \"\"\"\n    # Step 0: Unpack parameters\n    N, L, A0, k0, n_true, n_assumed, k_cut, f_high = params\n\n    # Step 1: Set up the wavenumber grid\n    # Assuming a fixed, reasonable k-range for all cases is sufficient for the diagnostic.\n    k_min, k_max = 0.0, 1.0\n    delta_k = (k_max - k_min) / N\n    # Bin centers\n    k_bins = k_min + (np.arange(N) + 0.5) * delta_k\n    \n    # Step 2: Define the underlying power spectra\n    P_true = A0 / (1.0 + (k_bins / k0)**2)\n    P_cut = np.where(k_bins = k_cut, 0, P_true)\n\n    # Step 3: Construct the window convolution matrix M\n    # Create a matrix of wavenumber differences: k_diff[i, j] = k_bins[i] - k_bins[j]\n    k_diff_matrix = k_bins[:, np.newaxis] - k_bins[np.newaxis, :]\n    \n    # The argument for the sinc function is L * (ki - kj) / 2\n    # To use np.sinc(x) = sin(pi*x)/(pi*x), the argument should be x = arg / pi.\n    sinc_arg = L * k_diff_matrix / (2.0 * np.pi)\n    \n    # Unnormalized mixing matrix M_ij ~ sinc^2(L*(ki-kj)/2)\n    M_unnormalized = np.sinc(sinc_arg)**2\n    \n    # Normalize rows to sum to 1\n    row_sums = M_unnormalized.sum(axis=1, keepdims=True)\n    # Avoid division by zero, though unlikely as diagonal elements are 1 before normalization\n    row_sums[row_sums == 0] = 1.0\n    M = M_unnormalized / row_sums\n\n    # Step 4: Calculate convolved power spectra\n    P_conv_true = M @ P_true\n    P_conv_cut = M @ P_cut\n\n    # Step 5: Construct pseudo-bandpowers\n    shot_noise_true = 1.0 / n_true\n    P_pseudo_full = P_conv_true + shot_noise_true\n    P_pseudo_cut = P_conv_cut + shot_noise_true\n\n    # Step 6: Calculate diagnostic quantities\n    # Define high-k region indices\n    num_high_k_bins = int(N * f_high)\n    high_k_indices = slice(N - num_high_k_bins, N)\n\n    # Effective shot-noise estimate\n    S_eff = np.mean(P_pseudo_cut[high_k_indices])\n\n    # Leakage metric\n    # L_metric = mean(P_pseudo_full_high) - mean(P_pseudo_cut_high)\n    # This simplifies to mean over the convolution of the difference spectrum\n    P_diff = P_true - P_cut\n    P_conv_diff = M @ P_diff\n    L_metric = np.mean(P_conv_diff[high_k_indices])\n\n    # Step 7: Classify the case\n    shot_noise_assumed = 1.0 / n_assumed\n    tau = 0.05 * shot_noise_assumed\n\n    cond_oversub = (shot_noise_assumed - S_eff) > tau\n    cond_leakage = L_metric > tau\n\n    if cond_oversub and not cond_leakage:\n        return 0  # Over-subtraction\n    elif not cond_oversub and cond_leakage:\n        return 1  # Window-induced leakage\n    else:\n        # This covers (cond_oversub and cond_leakage) or (not cond_oversub and not cond_leakage)\n        return 2  # Ambiguous\n\ndef solve():\n    \"\"\"\n    Main function to run the diagnostic on the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, L, A0, k0, n_true, n_assumed, k_cut, f_high)\n    test_cases = [\n        (256, 200.0, 1e-3, 0.05, 1000.0, 800.0, 0.03, 0.3),    # Case 1\n        (256, 20.0, 5e-3, 0.02, 1000.0, 1000.0, 0.03, 0.3),  # Case 2\n        (256, 20.0, 3e-3, 0.02, 1000.0, 900.0, 0.03, 0.3),    # Case 3\n        (256, 200.0, 1e-3, 0.05, 1000.0, 1000.0, 0.03, 0.3),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _run_diagnostic_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486487"}]}