{"hands_on_practices": [{"introduction": "几何守恒律（Geometric Conservation Law, GCL）是任何可靠的移动网格模拟的基石。它将单元体积的变化与其边界的运动精确联系起来，从而确保模拟不会因网格运动而人为地产生或破坏守恒量。本实践将指导您完成这一基本原则的实现与验证，这是开发或使用任意拉格朗日-欧拉（ALE）代码的一项关键技能 [@problem_id:3480236]。", "problem": "考虑一种适用于数值宇宙学中任意拉格朗日-欧拉 (ALE) 方法的二维移动网格有限体积离散化方案。每个计算单元是一个简单多边形，其顶点 $\\{(x_i,y_i)\\}_{i=0}^{N_v-1}$ 按逆时针顺序排列。网格以给定的、空间上可能变化的网格速度场 $\\mathbf{w}(x,y)$ 移动，并且为了本次诊断的目的，流体速度 $\\mathbf{v}$ 被设为 $\\mathbf{0}$。令 $V$ 表示单元面积。对于多边形的每个面 $f$，令 $A_f$ 表示面的度量（在二维中为边长），$\\mathbf{n}_f$ 为单位外法向量。面中心的法向网格速度表示为 $(\\mathbf{w}\\cdot\\mathbf{n})_f$。\n\n每个单元的离散几何守恒律 (GCL) 要求面的法向网格运动必须与单元体积（二维中为面积）的变化率相一致。具体而言，该定律表述为\n$$\n\\sum_{f} A_f\\,(\\mathbf{w}\\cdot\\mathbf{n})_f \\;=\\; \\frac{dV}{dt}.\n$$\n对于遵循守恒律 $\\partial_t u + \\nabla\\cdot(u\\,\\mathbf{v})=0$ 的被动标量 $u$，其 ALE 有限体积形式的移动网格半离散更新方程对单元平均值 $u$ 而言是\n$$\n\\frac{d}{dt}\\left(V u\\right) + \\sum_{f} A_f\\, u\\,(\\mathbf{v}-\\mathbf{w})\\cdot\\mathbf{n}_f \\;=\\; 0.\n$$\n一个均匀解 $u=\\text{const.}$ 在任意网格运动下保持不变的充分必要条件是离散 GCL 精确成立。\n\n需要实现的任务：\n- 从基本几何恒等式推导出一个算法，仅使用顶点位置 $\\{(x_i,y_i)\\}$ 和顶点速度 $\\{(w^x_i,w^y_i)\\}$ 来计算单元面积 $V$ 及其时间导数 $dV/dt$。\n- 对于给定的测试套件，计算每个单元的未校正的面法向和 $S=\\sum_f A_f(\\mathbf{w}\\cdot\\mathbf{n})_f$ 以及 GCL 残差 $R=S-\\frac{dV}{dt}$。\n- 通过对 $(\\mathbf{w}\\cdot\\mathbf{n})_f$ 应用最小范数的、统一的、逐面的加性校正，来精确地强制每个单元满足离散 GCL，使得校正后的和等于 $\\frac{dV}{dt}$。\n- 使用 $u$ 的 ALE 有限体积更新方程（其中 $\\mathbf{v}=\\mathbf{0}$），在强制 GCL 之前和之后，分别计算均匀解 $u$ 的单步更新 $u(t+\\Delta t)$，并构建用于检测与均匀解偏离的诊断工具。报告校正后的更新是否在严格容差内保持了均匀性。\n- 所有量都应在无量纲代码单位中处理。最终的诊断布尔值应精确地表示为 True 或 False。\n\n测试套件规范（每个测试案例提供顶点、顶点速度、面中心的法向网格速度和时间步长）：\n- 案例 1（正常路径：均匀平移，面积变化为零）：\n  - 顶点：$\\{(0,0),(1,0),(1,1),(0,1)\\}$。\n  - 顶点速度（每个顶点）：$(0.5,-0.3)$。\n  - 面中心网格速度：在所有面中心处为常数 $(0.5,-0.3)$，用于构成 $(\\mathbf{w}\\cdot\\mathbf{n})_f$。\n  - 时间步长：$\\Delta t = 0.1$。\n- 案例 2（扩张的正方形，不一致的面数据以触发 GCL 校正）：\n  - 顶点：$\\{(0,0),(1,0),(1,1),(0,1)\\}$。\n  - 顶点速度：在每个顶点 $(x_i,y_i)$ 处为 $(0.2\\,x_i,\\,0.2\\,y_i)$。\n  - 面中心网格速度：在每个面中心 $(x_c,y_c)$ 处为 $(0.15\\,x_c,\\,0.15\\,y_c)$，用于构成 $(\\mathbf{w}\\cdot\\mathbf{n})_f$。\n  - 时间步长：$\\Delta t = 0.1$。\n- 案例 3（斜四边形上的剪切运动，添加确定性的面不一致性）：\n  - 顶点：$\\{(0,0),(2,0),(2.2,1.2),(-0.1,1.0)\\}$。\n  - 顶点速度：在每个顶点 $(x_i,y_i)$ 处为 $(0.3\\,y_i,\\,0)$。\n  - 面中心网格速度：在每个面中心 $(x_c,y_c)$ 处为 $(0.3\\,y_c,\\,0)$，然后对于按循环顺序索引为 $f$ 的面，直接向 $(\\mathbf{w}\\cdot\\mathbf{n})_f$ 添加一个确定性偏移量 $0.01\\times f$。\n  - 时间步长：$\\Delta t = 0.1$。\n- 案例 4（细长矩形，近退化几何形状，顶面不一致性）：\n  - 顶点：$\\{(0,0),(5,0),(5,0.05),(0,0.05)\\}$。\n  - 顶点速度：在顶点 $(0,0)$ 和 $(0,0.05)$ 处为 $(0,0.01)$，在顶点 $(5,0)$ 和 $(5,0.05)$ 处为 $(0,0.02)$。\n  - 面中心网格速度：取两个端点顶点速度的算术平均值，并投影到 $\\mathbf{n}_f$ 上以获得 $(\\mathbf{w}\\cdot\\mathbf{n})_f$，然后仅在顶面上从 $(\\mathbf{w}\\cdot\\mathbf{n})_f$ 中减去 $0.003$。\n  - 时间步长：$\\Delta t = 0.1$。\n\n诊断和答案规范：\n- 对每个案例，计算校正后的 GCL 残差和一步时间步长后校正的均匀解漂移。为每个案例声明两个布尔值：\n  - $gcl\\_ok$：如果 $|\\sum_f A_f(\\mathbf{w}\\cdot\\mathbf{n})_f^{\\text{corr}} - \\frac{dV}{dt}| \\le \\varepsilon$，则为 True。\n  - $uniform\\_ok$：如果校正后 $|u(t+\\Delta t) - u(t)| \\le \\varepsilon$，则为 True，其中 $u(t)=1$。\n- 使用严格容差 $\\varepsilon = 10^{-12}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试案例的包含两个条目的列表 $[gcl\\_ok,uniform\\_ok]$（例如，$[[\\text{True},\\text{True}],[\\text{True},\\text{True}],\\dots]$）。", "solution": "该问题要求对二维移动网格有限体积格式实现并验证几何守恒律 (GCL)。GCL 是任何在时变域上的数值格式的基本要求，它确保离散算子能正确处理因网格运动引起的单元体积变化。若不满足 GCL，可能会导致伪源项的产生，例如，这会使格式无法保持一个简单的常数解。\n\n首先，我们根据多边形单元的顶点位置 $\\{(x_i, y_i)\\}_{i=0}^{N_v-1}$ 和顶点速度 $\\{(w^x_i, w^y_i)\\}_{i=0}^{N_v-1}$ 推导所需的几何量和运动学量。顶点按逆时针顺序排列。\n\n单元的面积，记为 $V$，可以使用鞋带公式计算：\n$$\nV = \\frac{1}{2} \\sum_{i=0}^{N_v-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n其中，索引对 $N_v$ 取模。为了求得面积的时间导数 $\\frac{dV}{dt}$，我们将此表达式对时间求导，将顶点坐标视为时间的函数，其中 $\\frac{dx_i}{dt} = w^x_i$ 且 $\\frac{dy_i}{dt} = w^y_i$。应用微分的乘法法则可得：\n$$\n\\frac{dV}{dt} = \\frac{1}{2} \\sum_{i=0}^{N_v-1} \\left( \\frac{dx_i}{dt} y_{i+1} + x_i \\frac{dy_{i+1}}{dt} - \\frac{dx_{i+1}}{dt} y_i - x_{i+1} \\frac{dy_i}{dt} \\right)\n$$\n代入顶点速度可得：\n$$\n\\frac{dV}{dt} = \\frac{1}{2} \\sum_{i=0}^{N_v-1} (w^x_i y_{i+1} + x_i w^y_{i+1} - w^x_{i+1} y_i - x_{i+1} w^y_i)\n$$\n通过合并与每个顶点速度分量 $(w^x_i, w^y_i)$ 相关的项，可以重排此表达式。这导出了一个计算上更方便的形式：\n$$\n\\frac{dV}{dt} = \\frac{1}{2} \\sum_{i=0}^{N_v-1} \\left[ w^x_i (y_{i+1} - y_{i-1}) + w^y_i (x_{i-1} - x_{i+1}) \\right]\n$$\n该公式仅基于瞬时顶点位置和速度，提供了单元面积的精确变化率。\n\n离散 GCL 由下式给出：\n$$\n\\sum_{f} A_f (\\mathbf{w} \\cdot \\mathbf{n})_f = \\frac{dV}{dt}\n$$\n在这里，求和是针对单元的所有面 $f$。对于连接顶点 $i$ 和顶点 $i+1$ 的面 $f_i$，$A_{f_i}$ 是其长度，$\\mathbf{n}_{f_i}$ 是单位外法向量。长度为 $A_{f_i} = \\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}$。对于逆时针排序的顶点，单位外法向量为 $\\mathbf{n}_{f_i} = \\frac{1}{A_{f_i}}(y_{i+1}-y_i, -(x_{i+1}-x_i))$。项 $(\\mathbf{w} \\cdot \\mathbf{n})_f$ 是面法向网格速度，在每个测试案例中其定义方式各不相同。\n\n问题指出，面中心的网格速度可能与顶点运动不一致，导致违反 GCL。我们用 GCL 残差 $R$ 来量化这种违反：\n$$\nR = S - \\frac{dV}{dt}\n$$\n其中 $S = \\sum_f A_f (\\mathbf{w} \\cdot \\mathbf{n})_f$ 是未校正的面法向速度通量之和。\n\n为强制满足 GCL，我们对每个面法向速度 $(\\mathbf{w} \\cdot \\mathbf{n})_f$ 应用一个统一的加性校正量 $\\delta$。校正后的速度为 $(\\mathbf{w} \\cdot \\mathbf{n})_f^{\\text{corr}} = (\\mathbf{w} \\cdot \\mathbf{n})_f + \\delta$。校正后的和 $S^{\\text{corr}}$ 被要求等于 $\\frac{dV}{dt}$：\n$$\nS^{\\text{corr}} = \\sum_f A_f ((\\mathbf{w} \\cdot \\mathbf{n})_f + \\delta) = S + \\delta \\sum_f A_f = \\frac{dV}{dt}\n$$\n求解 $\\delta$ 可得最小范数校正量：\n$$\n\\delta = \\frac{\\frac{dV}{dt} - S}{\\sum_f A_f} = -\\frac{R}{L}\n$$\n其中 $L = \\sum_f A_f$ 是单元的周长。\n\nGCL 的重要性体现在其对保持均匀状态的影响上。问题给出了被动标量 $u$ 的半离散 ALE 更新方程：\n$$\n\\frac{d}{dt}(V u) + \\sum_{f} A_f u (\\mathbf{v} - \\mathbf{w}) \\cdot \\mathbf{n}_f = 0\n$$\n当流体速度 $\\mathbf{v}=\\mathbf{0}$ 且标量 $u$ 空间均匀时，我们可以写出：\n$$\n\\frac{d(Vu)}{dt} - u \\sum_f A_f (\\mathbf{w} \\cdot \\mathbf{n})_f = 0\n$$\n使用乘法法则展开时间导数项 $u\\frac{dV}{dt} + V\\frac{du}{dt}$，我们得到：\n$$\nu\\frac{dV}{dt} + V\\frac{du}{dt} - u S = 0 \\quad \\implies \\quad V\\frac{du}{dt} = u(S - \\frac{dV}{dt}) = u R\n$$\n这得出了均匀状态的变化率：\n$$\n\\frac{du}{dt} = \\frac{R}{V} u\n$$\n显然，如果 GCL 得到满足（$R=0$），那么 $\\frac{du}{dt}=0$，均匀状态得以保持。如果 $R \\ne 0$，解将产生伪漂移。\n\n对于数值测试，我们使用步长为 $\\Delta t$ 的一阶前向欧拉时间步：\n$$\nu(t+\\Delta t) \\approx u(t) + \\Delta t \\frac{du}{dt} = u(t) \\left(1 + \\frac{R \\Delta t}{V}\\right)\n$$\n我们计算校正后的 GCL 残差 $R^{\\text{corr}} = S^{\\text{corr}} - \\frac{dV}{dt}$ 以及相应的更新后标量值 $u(t+\\Delta t)$。根据构造， $R^{\\text{corr}}$ 在浮点误差范围内将为零。诊断工具 `gcl_ok` 检查是否 $|R^{\\text{corr}}| \\le \\varepsilon$，而 `uniform_ok` 检查对于初始状态 $u(t)=1$ 和容差 $\\varepsilon=10^{-12}$，是否有 $|u(t+\\Delta t) - u(t)| \\le \\varepsilon$。对于所有测试案例，所实现的校正确保了这些条件得到满足。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": 1,\n            \"vertices\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"vertex_vels_rule\": lambda p: np.array([0.5, -0.3]),\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: np.dot(np.array([0.5, -0.3]), n),\n            \"dt\": 0.1\n        },\n        {\n            \"id\": 2,\n            \"vertices\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"vertex_vels_rule\": lambda p: 0.2 * p,\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: np.dot(0.15 * pc, n),\n            \"dt\": 0.1\n        },\n        {\n            \"id\": 3,\n            \"vertices\": np.array([[0.0, 0.0], [2.0, 0.0], [2.2, 1.2], [-0.1, 1.0]]),\n            \"vertex_vels_rule\": lambda p: np.array([0.3 * p[1], 0.0]),\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: np.dot(np.array([0.3 * pc[1], 0.0]), n) + 0.01 * f_idx,\n            \"dt\": 0.1\n        },\n        {\n            \"id\": 4,\n            \"vertices\": np.array([[0.0, 0.0], [5.0, 0.0], [5.0, 0.05], [0.0, 0.05]]),\n            \"vertex_vels_rule\": lambda p: np.array([0.0, 0.01]) if p[0] == 0.0 else np.array([0.0, 0.02]),\n            \"face_vel_rule\": lambda pc, n, A, f_idx, vw1, vw2: (\n                np.dot(0.5 * (vw1 + vw2), n) - (0.003 if np.isclose(n[1], 1.0) else 0.0)\n            ),\n            \"dt\": 0.1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"vertices\"],\n            case[\"vertex_vels_rule\"],\n            case[\"face_vel_rule\"],\n            case[\"dt\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(vertices, vertex_vels_rule, face_vel_rule, dt, epsilon=1e-12):\n    \"\"\"\n    Processes a single test case for GCL validation.\n    \"\"\"\n    p = vertices\n    num_verts = p.shape[0]\n\n    # Calculate vertex velocities based on the provided rule\n    vertex_vels = np.array([vertex_vels_rule(v) for v in p])\n    w = vertex_vels\n\n    # Compute cell area V using the shoelace formula\n    V = 0.5 * np.sum(p[:, 0] * np.roll(p[:, 1], -1) - np.roll(p[:, 0], -1) * p[:, 1])\n\n    # Compute dV/dt from vertex positions and velocities\n    y_plus_1 = np.roll(p[:, 1], -1)\n    y_minus_1 = np.roll(p[:, 1], 1)\n    x_plus_1 = np.roll(p[:, 0], -1)\n    x_minus_1 = np.roll(p[:, 0], 1)\n    \n    term_wx = w[:, 0] * (y_plus_1 - y_minus_1)\n    term_wy = w[:, 1] * (x_minus_1 - x_plus_1)\n    dVdt = 0.5 * np.sum(term_wx + term_wy)\n\n    # Loop over faces to compute uncorrected sum S and perimeter L\n    S = 0.0\n    L = 0.0\n    \n    face_data = [] # Store face data for later use\n\n    for i in range(num_verts):\n        p1 = p[i]\n        p2 = p[np.mod(i + 1, num_verts)]\n        \n        edge_vec = p2 - p1\n        A_f = np.linalg.norm(edge_vec)\n        \n        # Outward normal for CCW vertices\n        n_hat = np.array([edge_vec[1], -edge_vec[0]]) / A_f\n        \n        p_center = 0.5 * (p1 + p2)\n\n        # Get vertex velocities for endpoints of the face\n        w1 = w[i]\n        w2 = w[np.mod(i + 1, num_verts)]\n        \n        # Compute face-normal velocity w_dot_n from its rule\n        w_dot_n = face_vel_rule(p_center, n_hat, A_f, i, w1, w2)\n\n        face_data.append({'A_f': A_f, 'w_dot_n': w_dot_n})\n\n        S += A_f * w_dot_n\n        L += A_f\n    \n    # GCL residual R for the uncorrected velocities\n    R = S - dVdt\n    \n    # Compute the uniform additive correction delta\n    if L > 1e-15: # Avoid division by zero for degenerate cells\n        delta = -R / L\n    else:\n        delta = 0.0\n\n    # Compute corrected sum S_corr and residual R_corr\n    S_corr = 0.0\n    for data in face_data:\n        w_dot_n_corr = data['w_dot_n'] + delta\n        S_corr += data['A_f'] * w_dot_n_corr\n\n    R_corr = S_corr - dVdt\n\n    # Diagnostic 1: Check if the GCL is satisfied after correction\n    gcl_ok = abs(R_corr) <= epsilon\n    \n    # Diagnostic 2: Check if the uniform solution is preserved\n    u_initial = 1.0\n    # Update using forward Euler based on the corrected residual\n    if V > 1e-15:\n        u_final = u_initial * (1.0 + (R_corr * dt) / V)\n    else:\n        u_final = u_initial\n        \n    uniform_ok = abs(u_final - u_initial) <= epsilon\n    \n    return [gcl_ok, uniform_ok]\n\nsolve()\n```", "id": "3480236"}, {"introduction": "ALE 方法的“任意性”提供了极大的灵活性，但这通常需要一个“重映射”（remap）步骤来维持高质量的网格，而这一步不可避免地会引入数值误差。理解这种误差的来源和形式对于评估模拟的保真度至关重要。本实践通过解析推导来量化一个简单的一阶重映射格式所引入的数值扩散，从而提供对格式行为的深刻见解 [@problem_id:3480215]。", "problem": "考虑一个被动共动标量场 $q(x,y,t)$，它代表了宇宙学流中一个局部区域的尘埃密度衬度，并遵循共动坐标系下的线性平流方程，\n$$\n\\partial_{t} q + \\boldsymbol{u} \\cdot \\nabla q = 0,\n$$\n其速度场为均匀剪切速度 $\\boldsymbol{u}(x,y) = (\\gamma y, 0)$，其中 $\\gamma$ 为恒定的剪切率。一种任意拉格朗日-欧拉 (ALE) 方法首先在一个时间步长 $\\Delta t$ 内跟随速度场 $\\boldsymbol{u}$ 进行网格运动，然后执行网格重构 (重映)，将其映射回间距为 $\\Delta x = \\Delta y$ 的均匀笛卡尔网格。该重映过程沿 $x$ 方向采用一阶供体单元 (迎风) 格式完成。\n\n取初始条件为 $q(x,y,0) = \\sin(k x)\\sin(k y)$，其中波数 $k>0$。考虑固定 $y=y_{0}>0$ 的一行，使得库朗数 $C_{0} \\equiv \\gamma y_{0} \\Delta t / \\Delta x$ 满足 $0 < C_{0} < 1$。设 $x_{i}$ 表示该行上的一个单元中心，用 $q^{n+1}_{\\text{donor}}(x_{i},y_{0})$ 表示经过一个 ALE 步后由供体单元重映产生的值，用 $q_{\\text{exact}}(x_{i},y_{0},\\Delta t)$ 表示在相同位置和时间求值的精确解。将经过一次重映事件后在 $(x_{i},y_{0})$ 处的局部重映误差定义为\n$$\nE_{i} \\equiv q^{n+1}_{\\text{donor}}(x_{i},y_{0}) - q_{\\text{exact}}(x_{i},y_{0},\\Delta t).\n$$\n\n从平流方程和供体单元格式的定义出发，通过对小的 $\\Delta x$ 和 $\\Delta t$ 进行展开并保留到二阶项，推导 $E_{i}$ 的主导非平凡阶。将你的最终答案表示为关于 $\\gamma$、$\\Delta t$、$\\Delta x$、$k$、$x_{i}$ 和 $y_{0}$ 的单个闭式解析表达式，并明确展示其如何依赖于 $\\mathcal{O}(\\gamma \\Delta t \\Delta x)$ 和网格尺寸。无需提供数值；仅给出闭式表达式。", "solution": "我们首先回顾对于给定的剪切速度场 $\\boldsymbol{u}(x,y) = (\\gamma y, 0)$，线性平流方程 $\\partial_{t} q + \\boldsymbol{u} \\cdot \\nabla q = 0$ 的精确解。沿着特征线，\n$$\n\\frac{d x}{d t} = \\gamma y, \\qquad \\frac{d y}{d t} = 0,\n$$\n因此 $y$ 是常数且 $x(t) = x(0) + \\gamma y t$。所以，在时间 $\\Delta t$ 的精确解是在 $x$ 方向上平移了 $\\gamma y \\Delta t$：\n$$\nq_{\\text{exact}}(x,y,\\Delta t) = q(x - \\gamma y \\Delta t, y, 0).\n$$\n对于初始条件 $q(x,y,0) = \\sin(k x)\\sin(k y)$，我们得到\n$$\nq_{\\text{exact}}(x,y,\\Delta t) = \\sin\\!\\big(k (x - \\gamma y \\Delta t)\\big)\\,\\sin(k y).\n$$\n\n接下来，考虑在固定行 $y=y_{0}>0$ 上沿 $x$ 方向的供体单元 (迎风) 重映，该处速度为正 $u_{x}(y_{0}) = \\gamma y_{0}$。单元中心 $x_{i}$ 处的供体单元更新公式为\n$$\nq^{n+1}_{\\text{donor}}(x_{i},y_{0}) = (1 - C_{0})\\,q^{n}(x_{i},y_{0}) + C_{0}\\,q^{n}(x_{i} - \\Delta x, y_{0}),\n$$\n其中库朗数为 $C_{0} = \\gamma y_{0} \\Delta t / \\Delta x$ 且 $q^{n}(\\cdot,\\cdot) = q(\\cdot,\\cdot,0)$。\n\n对于 $q^{n}(x,y) = \\sin(k x)\\sin(k y)$，上式变为\n$$\nq^{n+1}_{\\text{donor}}(x_{i},y_{0}) = \\sin(k y_{0})\\Big[(1 - C_{0}) \\sin(k x_{i}) + C_{0} \\sin\\!\\big(k (x_{i} - \\Delta x)\\big)\\Big].\n$$\n在同一点的精确值为\n$$\nq_{\\text{exact}}(x_{i},y_{0},\\Delta t) = \\sin(k y_{0})\\,\\sin\\!\\big(k (x_{i} - \\gamma y_{0} \\Delta t)\\big).\n$$\n因此误差 $E_{i}$ 为\n$$\nE_{i} = \\sin(k y_{0})\\left[(1 - C_{0}) \\sin(k x_{i}) + C_{0} \\sin\\!\\big(k (x_{i} - \\Delta x)\\big) - \\sin\\!\\big(k (x_{i} - \\gamma y_{0} \\Delta t)\\big)\\right].\n$$\n\n为了得到主导非平凡阶，我们对 $\\Delta x$ 和 $\\Delta t$ 进行泰勒展开，并保留到二阶项。定义\n$$\ns \\equiv \\sin(k x_{i}), \\qquad c \\equiv \\cos(k x_{i}), \\qquad s_{y} \\equiv \\sin(k y_{0}).\n$$\n于是\n$$\n\\sin\\!\\big(k (x_{i} - \\Delta x)\\big) = s - k \\Delta x\\,c - \\frac{k^{2} \\Delta x^{2}}{2}\\,s + \\mathcal{O}(\\Delta x^{3}),\n$$\n以及\n$$\n\\sin\\!\\big(k (x_{i} - \\gamma y_{0} \\Delta t)\\big) = s - k \\gamma y_{0} \\Delta t\\,c - \\frac{k^{2} (\\gamma y_{0} \\Delta t)^{2}}{2}\\,s + \\mathcal{O}(\\Delta t^{3}).\n$$\n将这些展开式代入 $q^{n+1}_{\\text{donor}}$ 和 $q_{\\text{exact}}$ 的表达式中，可得\n\\begin{align*}\nq^{n+1}_{\\text{donor}}(x_{i},y_{0}) &= s_{y}\\Big[(1 - C_{0}) s + C_{0}\\left(s - k \\Delta x\\,c - \\frac{k^{2} \\Delta x^{2}}{2}\\,s\\right)\\Big] + \\mathcal{O}(\\Delta x^{3}) \\\\\n&= s_{y}\\left[s - C_{0} k \\Delta x\\,c - \\frac{C_{0} k^{2} \\Delta x^{2}}{2}\\,s\\right] + \\mathcal{O}(\\Delta x^{3}),\n\\end{align*}\n以及\n$$\nq_{\\text{exact}}(x_{i},y_{0},\\Delta t) = s_{y}\\left[s - k \\gamma y_{0} \\Delta t\\,c - \\frac{k^{2} (\\gamma y_{0} \\Delta t)^{2}}{2}\\,s\\right] + \\mathcal{O}(\\Delta t^{3}).\n$$\n回忆一下，$C_{0} \\Delta x = (\\gamma y_{0} \\Delta t / \\Delta x)\\Delta x = \\gamma y_{0} \\Delta t$。因此，在 $q^{n+1}_{\\text{donor}}$ 和 $q_{\\text{exact}}$ 中与 $c$ 成正比的项完全匹配，并在求差时抵消，这对于近似纯平移的一阶迎风离散化是符合预期的。\n\n因此，主导非平凡误差来自于二阶项：\n\\begin{align*}\nE_{i} &= q^{n+1}_{\\text{donor}}(x_{i},y_{0}) - q_{\\text{exact}}(x_{i},y_{0},\\Delta t) \\\\\n&= s_{y}\\left[- \\frac{C_{0} k^{2} \\Delta x^{2}}{2}\\,s + \\frac{k^{2} (\\gamma y_{0} \\Delta t)^{2}}{2}\\,s\\right] + \\mathcal{O}\\big(\\Delta x^{3}, \\Delta t^{3}\\big) \\\\\n&= \\frac{k^{2}}{2}\\,s_{y}\\,s\\left[(\\gamma y_{0} \\Delta t)^{2} - C_{0} \\Delta x^{2}\\right] + \\mathcal{O}\\big(\\Delta x^{3}, \\Delta t^{3}\\big).\n\\end{align*}\n使用 $C_{0} \\Delta x^{2} = (\\gamma y_{0} \\Delta t / \\Delta x)\\,\\Delta x^{2} = \\gamma y_{0} \\Delta t\\,\\Delta x$，我们得到紧凑的主导阶表达式\n$$\nE_{i} = \\frac{k^{2}}{2}\\,\\sin(k x_{i})\\,\\sin(k y_{0})\\left[(\\gamma y_{0} \\Delta t)^{2} - \\gamma y_{0} \\Delta t\\,\\Delta x\\right] + \\mathcal{O}\\big(\\Delta x^{3}, \\Delta t^{3}\\big).\n$$\n\n这明确表明，对于小的 $\\Delta t$ 和 $\\Delta x$，误差中的主导项的量级为\n$$\n-\\frac{k^{2}}{2}\\,\\sin(k x_{i})\\,\\sin(k y_{0})\\,\\gamma y_{0}\\,\\Delta t\\,\\Delta x \\;\\;=\\;\\; \\mathcal{O}(\\gamma \\Delta t \\Delta x),\n$$\n其更高阶的修正项为 $\\mathcal{O}\\big((\\gamma \\Delta t)^{2}\\big)$ 阶。网格尺寸 $\\Delta x$ 在主导阶项中线性出现，这表明了供体单元重映的一阶空间精度，以及在任意拉格朗日-欧拉 (ALE) 背景下，它通过行坐标 $y_{0}$ 与剪切 $\\gamma$ 的耦合关系。", "answer": "$$\\boxed{\\frac{k^{2}}{2}\\,\\sin(k x_{i})\\,\\sin(k y_{0})\\left[(\\gamma y_{0}\\,\\Delta t)^{2} - \\gamma y_{0}\\,\\Delta t\\,\\Delta x\\right]}$$", "id": "3480215"}, {"introduction": "我们为何要接受移动网格的复杂性？主要原因是通过最小化与大尺度流体平流相关的数值误差，从而显著提高精度。本实践通过比较移动网格和固定网格在模拟经典的开尔文-亥姆霍兹不稳定性时的表现，来定量地展示这一优势。通过计算两种情况下的有效数值粘性，您将精确地看到使网格与流体一起运动如何减少人为的阻尼，从而更好地捕捉真实的物理过程 [@problem_id:3480230]。", "problem": "考虑用于数值宇宙学中研究界面剪切不稳定性的两种可压缩欧拉方程的数值离散化方法：一种是固定的笛卡尔网格，另一种是移动网格，该网格本着任意拉格朗日-欧拉 (ALE) 方法的精神与主体剪切对齐。在随网格速度移动的参考系中，质量和动量的控制守恒律是可压缩欧拉方程，而 ALE 公式确保了平流输运是相对于网格运动来度量的。开尔文-亥姆霍兹不稳定性是由一个沿平面界面的小振幅正弦扰动引发的，该扰动的波长为 $\\lambda_{\\mathrm{wave}}$。这个平面界面分隔了两个密度相等、速度差为 $\\Delta U$、平均主体速度为 $U_{\\mathrm{mean}}$ 的流体，且处于声速为 $c_s$ 的亚音速条件下。假设初始扰动振幅足够小，可以进行线性分析。\n\n从欧拉方程的守恒形式和任意拉格朗日-欧拉 (ALE) 参考系的定义出发，从第一性原理推导出一个关系式，将测得的不稳定性指数增长率与一个由离散化误差产生的有效数值粘性项联系起来。具体来说，请使用以下基础：\n\n- 可压缩流中的质量和动量守恒。\n- 在密度相等、速度为亚音速的均匀剪切状态附近进行线性化。\n- 有限体积 Godunov 型方法的修正方程概念，其中主导耗散截断项的作用类似于速度的拉普拉斯算子，其系数取决于相对于网格的特征信号速度和网格间距。\n\n除了这些经过充分检验的原理外，不要引入任何未经检验或临时的公式。推导必须与线性稳定性理论一致，将无粘性开尔文-亥姆霍兹增长率与一个取决于有效粘性和波长的修正项联系起来。\n\n然后，您必须在一个程序中实现所得到的关系式，该程序针对下面提供的每个测试用例计算：\n\n1. 与剪切对齐的移动网格和固定笛卡尔网格的有效数值粘性，单位为 $\\mathrm{m}^2/\\mathrm{s}$。\n2. 两种网格下测得的增长率相对于无粘性基准的相对误差，表示为一个无量纲小数，定义为 $(\\gamma_{\\mathrm{meas}} - \\gamma_0)/\\gamma_0$，其中 $\\gamma_0$ 是无粘性增长率，$\\gamma_{\\mathrm{meas}}$ 是存在有效数值粘性时的增长率。\n\n假设密度相等且为亚音速条件，因此无粘性基准的线性开尔文-亥姆霍兹增长可以使用标准的等密度、无重力、无表面张力的结果来近似。进入耗散截断项的特征信号速度应相对于网格运动来取值。对于固定笛卡尔网格，将特征速度视为 $|U_{\\mathrm{mean}}| + c_s$。对于与剪切对齐的移动网格，将特征速度视为 $c_s$，因为网格速度等于沿剪切方向的主体速度 $U_{\\mathrm{mean}}$。设网格间距为 $\\Delta x = \\lambda_{\\mathrm{wave}}/N$，其中 $N$ 是每波长的单元数。主导耗散项的与格式相关的比例因子是一个常数 $\\beta$，在每个测试用例中提供。\n\n您的程序必须不接受任何输入，并且必须使用指定的物理单位为以下测试套件计算结果：\n\n- 案例 A (理想情况)：$\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{19}\\ \\mathrm{m}$，$\\Delta U = 2.0\\times 10^{4}\\ \\mathrm{m/s}$， $U_{\\mathrm{mean}} = 5.0\\times 10^{4}\\ \\mathrm{m/s}$， $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$， $N = 64$， $\\beta = 0.25$。\n- 案例 B (粗分辨率，较大平流)：$\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{19}\\ \\mathrm{m}$，$\\Delta U = 2.0\\times 10^{4}\\ \\mathrm{m/s}$， $U_{\\mathrm{mean}} = 1.0\\times 10^{5}\\ \\mathrm{m/s}$， $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$， $N = 16$， $\\beta = 0.25$。\n- 案例 C (精细分辨率，零平均平流)：$\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{19}\\ \\mathrm{m}$，$\\Delta U = 1.0\\times 10^{4}\\ \\mathrm{m/s}$， $U_{\\mathrm{mean}} = 0.0\\ \\mathrm{m/s}$， $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$， $N = 256$， $\\beta = 0.25$。\n- 案例 D (较短波长)：$\\lambda_{\\mathrm{wave}} = 3.086\\times 10^{18}\\ \\mathrm{m}$，$\\Delta U = 5.0\\times 10^{4}\\ \\mathrm{m/s}$， $U_{\\mathrm{mean}} = 8.0\\times 10^{4}\\ \\mathrm{m/s}$， $c_s = 1.0\\times 10^{5}\\ \\mathrm{m/s}$， $N = 64$， $\\beta = 0.25$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按案例排序，每个案例贡献四个值，顺序为：$[\\nu_{\\mathrm{moving}}, \\nu_{\\mathrm{fixed}}, \\varepsilon_{\\mathrm{moving}}, \\varepsilon_{\\mathrm{fixed}}]$，其中 $\\nu$ 是有效数值粘性，单位为 $\\mathrm{m}^2/\\mathrm{s}$，$\\varepsilon$ 是增长率的相对误差。将案例 A、B、C、D 的结果按顺序连接成一个扁平列表。所有粘性必须以 $\\mathrm{m}^2/\\mathrm{s}$ 表示，所有增长率误差必须表示为无量纲小数。", "solution": "该问题具有科学依据，是适定的，并包含了获得唯一解所需的所有信息。其推导和后续计算基于流体动力学、线性稳定性理论和数值分析的既定原理。因此，该问题是有效的。\n\n任务是推导开尔文-亥姆霍兹不稳定性的测量增长率与有效数值粘性之间的关系，然后应用此关系比较固定笛卡尔网格与移动网格。\n\n**1. 无粘性开尔文-亥姆霍兹增长率**\n\n我们从位于 $y=0$ 的界面的线性稳定性分析开始，该界面分隔了两种密度均为 $\\rho$ 的流体。流体在 $x$ 方向上以速度 $U_1$ 和 $U_2$ 运动。平均速度为 $U_{\\mathrm{mean}} = (U_1 + U_2)/2$，速度剪切为 $\\Delta U = U_1 - U_2$。问题指定在亚音速条件下使用等密度的标准结果，这类似于不可压缩情况。对于涡片（零厚度界面），波数为 $k$ 的小正弦扰动的色散关系产生一个纯指数增长率 $\\gamma_0$。扰动以 $e^{\\gamma_0 t}$ 的形式增长。经典结果是：\n$$\n\\gamma_0 = \\frac{k |\\Delta U|}{2}\n$$\n波数 $k$ 与扰动波长 $\\lambda_{\\mathrm{wave}}$ 的关系是：\n$$\nk = \\frac{2\\pi}{\\lambda_{\\mathrm{wave}}}\n$$\n将 $k$ 代入 $\\gamma_0$ 的表达式中，得到基准的无粘性增长率：\n$$\n\\gamma_0 = \\frac{\\pi |\\Delta U|}{\\lambda_{\\mathrm{wave}}}\n$$\n\n**2. 粘性对增长率的影响**\n\n接下来，我们引入粘性的影响。可压缩欧拉方程中的动量方程通过一个粘性应力张量被修改为纳维-斯托克斯方程。对于我们的目的，粘性对动量的主导影响由项 $\\nu \\nabla^2 \\mathbf{u}$ 捕获，其中 $\\nu$ 是运动粘度。该项代表动量的扩散。\n\n对于形式为 $e^{i k x}$ 的正弦扰动模，拉普拉斯算子作用为 $\\nabla^2 \\rightarrow -k^2$。因此，粘性项对不稳定性引入了一个阻尼效应。增长率被一个附加的阻尼项修正，该项与粘性扩散的强度成正比。阻尼率为 $\\gamma_{\\mathrm{damp}} = \\nu k^2$。\n\n在存在这种小粘性的情况下，测得的增长率 $\\gamma_{\\mathrm{meas}}$ 是无粘性增长和粘性阻尼之和：\n$$\n\\gamma_{\\mathrm{meas}} = \\gamma_0 - \\gamma_{\\mathrm{damp}} = \\gamma_0 - \\nu k^2\n$$\n这个关系表明，粘性会抑制不稳定性的增长，且在更高波数（更短波长）下效果更强。\n\n**3. 来自截断误差的数值粘性**\n\n用于求解双曲守恒律（如欧拉方程）的数值格式会引入误差。对于一阶 Godunov 型格式，离散化动量方程的截断误差中的主导阶项通常具有粘性耗散项的形式。这是“修正方程”方法的关键概念，即数值解是一个略微修改过的偏微分方程的精确解。这个主导耗散项产生了“有效数值粘性” $\\nu_{\\mathrm{num}}$。\n\n问题指出，这种数值粘性可以建模为：\n$$\n\\nu_{\\mathrm{num}} = \\beta \\cdot v_{\\mathrm{char}} \\cdot \\Delta x\n$$\n其中 $\\beta$ 是一个量级为 1 的无量纲、与格式相关的常数，$v_{\\mathrm{char}}$ 是相对于计算网格的特征信号速度，$\\Delta x$ 是网格间距。\n\n问题为 $v_{\\mathrm{char}}$ 和 $\\Delta x$ 提供了具体的模型：\n- 网格间距与每波长单元数 $N$ 相关：$\\Delta x = \\lambda_{\\mathrm{wave}}/N$。\n- 对于**固定笛卡尔网格**，流体以平均速度 $U_{\\mathrm{mean}}$ 平流过网格。相对于固定网格单元的最快信号速度是主体流速与相对于流体传播的声速之和。因此，$v_{\\mathrm{char, fixed}} = |U_{\\mathrm{mean}}| + c_s$。\n- 对于与主体剪切对齐的**移动网格** (ALE)，网格以速度 $U_{\\mathrm{mean}}$ 移动。相对于网格的平流输运为零。此时，特征速度就是声速，$v_{\\mathrm{char, moving}} = c_s$。\n\n使用这些定义，我们可以写出两种情况下有效数值粘性的表达式：\n$$\n\\nu_{\\mathrm{fixed}} = \\beta (|U_{\\mathrm{mean}}| + c_s) \\frac{\\lambda_{\\mathrm{wave}}}{N}\n$$\n$$\n\\nu_{\\mathrm{moving}} = \\beta c_s \\frac{\\lambda_{\\mathrm{wave}}}{N}\n$$\n\n**4. 增长率的相对误差**\n\n最后一步是计算增长率的相对误差 $\\varepsilon$，定义为 $(\\gamma_{\\mathrm{meas}} - \\gamma_0)/\\gamma_0$。我们代入 $\\gamma_{\\mathrm{meas}}$ 和数值粘性 $\\nu_{\\mathrm{num}}$（从现在起简称为 $\\nu$）的表达式。\n$$\n\\varepsilon = \\frac{\\gamma_{\\mathrm{meas}} - \\gamma_0}{\\gamma_0} = \\frac{(\\gamma_0 - \\nu k^2) - \\gamma_0}{\\gamma_0} = -\\frac{\\nu k^2}{\\gamma_0}\n$$\n现在，我们代入 $k = 2\\pi/\\lambda_{\\mathrm{wave}}$ 和 $\\gamma_0 = \\pi |\\Delta U|/\\lambda_{\\mathrm{wave}}$ 的表达式：\n$$\n\\varepsilon = -\\frac{\\nu (2\\pi/\\lambda_{\\mathrm{wave}})^2}{\\pi |\\Delta U|/\\lambda_{\\mathrm{wave}}} = -\\frac{\\nu \\cdot 4\\pi^2/\\lambda_{\\mathrm{wave}}^2}{\\pi |\\Delta U|/\\lambda_{\\mathrm{wave}}} = -\\frac{4\\pi\\nu}{|\\Delta U| \\lambda_{\\mathrm{wave}}}\n$$\n这提供了相对误差与数值粘性之间的直接联系。我们也可以将 $\\nu$ 的公式代入这个表达式，以查看其对模拟参数的直接依赖性：\n$$\n\\varepsilon = -\\frac{4\\pi (\\beta v_{\\mathrm{char}} \\frac{\\lambda_{\\mathrm{wave}}}{N})}{|\\Delta U| \\lambda_{\\mathrm{wave}}} = -\\frac{4\\pi \\beta v_{\\mathrm{char}}}{N |\\Delta U|}\n$$\n这个简化形式在计算上是稳健的，并清楚地表明数值误差被特征速度 ($v_{\\mathrm{char}}$) 放大，并被更高分辨率 ($N$) 和更强的物理剪切 ($|\\Delta U|$) 减小。移动网格方法 (ALE) 通过将 $v_{\\mathrm{char}}$ 从 $|U_{\\mathrm{mean}}| + c_s$ 最小化到仅为 $c_s$ 来减小误差。\n\n每个案例所需的量是：\n1.  $\\nu_{\\mathrm{moving}}$ 和 $\\nu_{\\mathrm{fixed}}$，单位为 $\\mathrm{m}^2/\\mathrm{s}$。\n2.  $\\varepsilon_{\\mathrm{moving}}$ 和 $\\varepsilon_{\\mathrm{fixed}}$，为无量纲小数。\n\n将实现以下公式：\n- $\\nu_{\\mathrm{moving}} = \\beta c_s (\\lambda_{\\mathrm{wave}} / N)$\n- $\\nu_{\\mathrm{fixed}} = \\beta (|U_{\\mathrm{mean}}| + c_s) (\\lambda_{\\mathrm{wave}} / N)$\n- $\\varepsilon_{\\mathrm{moving}} = - (4\\pi \\beta c_s) / (N |\\Delta U|)$\n- $\\varepsilon_{\\mathrm{fixed}} = - (4\\pi \\beta (|U_{\\mathrm{mean}}| + c_s)) / (N |\\Delta U|)$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating numerical viscosity and growth rate error\n    for the Kelvin-Helmholtz instability on fixed and moving meshes.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (lambda_wave [m], delta_U [m/s], U_mean [m/s], c_s [m/s], N, beta)\n    test_cases = [\n        # Case A\n        (3.086e19, 2.0e4, 5.0e4, 1.0e5, 64, 0.25),\n        # Case B\n        (3.086e19, 2.0e4, 1.0e5, 1.0e5, 16, 0.25),\n        # Case C\n        (3.086e19, 1.0e4, 0.0, 1.0e5, 256, 0.25),\n        # Case D\n        (3.086e18, 5.0e4, 8.0e4, 1.0e5, 64, 0.25),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        lambda_wave, delta_u, u_mean, c_s, n, beta = case\n\n        # Calculate metrics for the MOVING MESH\n        # v_char for moving mesh is c_s\n        v_char_moving = c_s\n        nu_moving = beta * v_char_moving * (lambda_wave / n)\n        \n        # The fractional error can be calculated using the simplified formula:\n        # eps = -(4 * pi * beta * v_char) / (N * |delta_U|)\n        eps_moving = -(4 * np.pi * beta * v_char_moving) / (n * abs(delta_u))\n\n        # Calculate metrics for the FIXED MESH\n        # v_char for fixed mesh is |U_mean| + c_s\n        v_char_fixed = abs(u_mean) + c_s\n        nu_fixed = beta * v_char_fixed * (lambda_wave / n)\n\n        eps_fixed = -(4 * np.pi * beta * v_char_fixed) / (n * abs(delta_u))\n\n        # Append the four results for the current case\n        all_results.extend([nu_moving, nu_fixed, eps_moving, eps_fixed])\n\n    # Format the final output string as a comma-separated list in brackets.\n    # Convert each result to a string. The default float formatting is sufficient.\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3480230"}]}