{"hands_on_practices": [{"introduction": "玻尔兹曼方程等级结构在理论上是一个无限耦合的微分方程组，在数值计算中必须在某个最大多极矩 $\\ell_{\\max}$ 处进行截断。本练习旨在介绍截断带来的核心挑战——“闭合关系”，并通过将一个简化的数值方案与已知的解析解进行对比，为学习者提供一种具体的精度检验方法。通过这项实践[@problem_id:3493623]，你将掌握求解自由流等级结构的基本数值技能，并理解截断误差的来源。", "problem": "考虑傅里叶空间中与宇宙微波背景（CMB）各向异性和遗迹中微子相关的无质量粒子的无碰撞玻尔兹曼级联，并以勒让德多极矩展开。设 $k$ 为共动波数，$\\eta$ 为共形时间，并定义无量纲时间变量 $x \\equiv k\\eta$。用 $F_\\ell(x)$ 表示在没有引力驱动和碰撞的情况下，单个自由流无质量粒子物种的相空间亮度微扰的勒让德多极矩。对于所有非负整数 $\\ell$，以 $x$ 表示的精确无源级联是一个一阶常微分方程的耦合链，\n$$\n\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right],\n$$\n其在 $x \\to 0$ 时的正则初始行为对应于初始各向同性微扰。在辐射主导（RD）时期，尺度因子满足 $a(\\eta)\\propto \\eta$，而在物质主导（MD）时期，$a(\\eta)\\propto \\eta^2$。在没有引力驱动的情况下，$F_\\ell$ 的动力学仅取决于 $x$，而与背景膨胀历史无关。齐次解析解可用球贝塞尔函数表示。\n\n您的任务是为此级联构建并验证一个截断的数值求解器，该求解器只保留前三个多极矩（$\\ell \\le 2$），并在 $\\ell=3$ 处使用渐近自由流闭合关系来闭合系统：\n$$\nF_3(x) \\approx \\frac{3}{x}\\,F_2(x).\n$$\n初始条件对应于一个在 $x\\to 0$ 极限下具有单位单极矩且高阶多极矩为零的初始各向同性微扰，通过从一个小的但有限的 $x_0$ 开始，并使用与各向同性一致的正则初始数据来实现。使用 $x_0 = 10^{-6}$。\n\n实现以下步骤：\n- 对每个测试用例，将 $F_0(x)$、$F_1(x)$ 和 $F_2(x)$ 的截断系统从 $x=x_0$ 积分到指定的 $x=x_{\\mathrm{end}}$。\n- 对于每个 $x_{\\mathrm{end}}$，计算 $\\ell \\in \\{0,1,2\\}$ 的齐次自由流解析解（用球贝塞尔函数表示），并进行归一化以匹配相同的初始单极矩振幅。\n- 对于每个 $\\ell \\in \\{0,1,2\\}$，计算相对偏差\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}.\n$$\n- 对于每个测试用例，报告在 $\\ell \\in \\{0,1,2\\}$ 上的最大偏差：\n$$\n\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}.\n$$\n\n测试套件：\n- 辐射主导时期（RD），$x_{\\mathrm{end}} = 10^{-3}$。\n- 辐射主导时期（RD），$x_{\\mathrm{end}} = 1$。\n- 辐射主导时期（RD），$x_{\\mathrm{end}} = 20$。\n- 物质主导时期（MD），$x_{\\mathrm{end}} = 10^{-3}$。\n- 物质主导时期（MD），$x_{\\mathrm{end}} = 1$。\n- 物质主导时期（MD），$x_{\\mathrm{end}} = 20$。\n\n注意事项和要求：\n- 使用齐次自由流解析解作为验证的参考。由于忽略了引力驱动，级联与 $x$ 之间的关系在辐射主导和物质主导时期是相同的；这两个时期仅通过 $x$ 相对于 $\\eta$ 和 $a(\\eta)$ 的解释而进入问题，而不影响级联的 $x$-演化。\n- 确保在 $x_0 = 10^{-6}$ 处的数值初始数据是正则的，并与一个在 $x\\to 0$ 极限下具有单位单极矩振幅且偶极矩和四极矩为零的初始各向同性微扰相一致。\n- 角度没有显式出现；不需要角度单位。\n- 所有量都是无量纲的；不需要物理单位转换。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个 $r_i$ 是对应于上述指定顺序的测试用例的 $\\epsilon_{\\max}(x_{\\mathrm{end}})$ 的值。每个 $r_i$ 必须以科学记数法格式的浮点数打印，且恰好有 $8$ 位有效数字。", "solution": "用户想要解决一个来自数值宇宙学的关于玻尔兹曼级联的问题。\n\n### 问题验证\n\n**步骤 1：提取的已知信息**\n- **系统**：无质量粒子的无碰撞玻尔兹曼级联。\n- **变量和定义**：共动波数 $k$，共形时间 $\\eta$，无量纲时间 $x \\equiv k\\eta$。\n- **微扰多极矩**：$F_\\ell(x)$，相空间亮度微扰的勒让德多极矩。\n- **级联方程**：$\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right]$，对于非负整数 $\\ell$。\n- **初始条件**：在 $x \\to 0$ 时对应于单位单极矩振幅的初始各向同性微扰的正则初始行为。\n- **数值截断**：求解 $\\ell \\le 2$，即求解 $F_0(x)$、$F_1(x)$ 和 $F_2(x)$。\n- **闭合关系**：系统在 $\\ell=3$ 处使用近似 $F_3(x) \\approx \\frac{3}{x}\\,F_2(x)$ 进行闭合。\n- **数值积分起点**：$x_0 = 10^{-6}$，使用正则初始数据。\n- **解析解**：精确的齐次解以球贝塞尔函数 $j_\\ell(x)$ 给出。\n- **误差度量**：\n  - 相对偏差：$\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}$。\n  - 最大偏差：$\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}$.\n- **测试用例**：\n    1. 辐射主导（RD），$x_{\\mathrm{end}} = 10^{-3}$。\n    2. 辐射主导（RD），$x_{\\mathrm{end}} = 1$。\n    3. 辐射主导（RD），$x_{\\mathrm{end}} = 20$。\n    4. 物质主导（MD），$x_{\\mathrm{end}} = 10^{-3}$。\n    5. 物质主导（MD），$x_{\\mathrm{end}} = 1$。\n    6. 物质主导（MD），$x_{\\mathrm{end}} = 20$。\n- **辅助信息**：$F_\\ell(x)$ 的演化仅取决于 $x$，与背景膨胀历史（RD 或 MD）无关。\n\n**步骤 2：已知信息的验证**\n- **科学依据**：该问题在科学上是合理的。玻尔兹曼级联是物理宇宙学中研究微扰演化的基本工具。所提供的方程对于自由流的无质量粒子是正确的。使用球贝塞尔函数作为初始各向同性微扰的解析解也是正确的。测试数值截断和闭合方案与解析解的对比是计算物理学中一个标准且有效的练习。\n- **适定性**：该问题是适定的。它提供了一个常微分方程（ODE）系统、一个使截断系统可解的特定闭合关系，以及一个明确定义的初始条件。其目标——计算一个特定的误差度量——是明确无误的。\n- **完整性和一致性**：该问题是自洽的。\n  - 初始条件虽然是描述性的（“正则初始行为……”），但可以被唯一确定。对于初始条件 $F_\\ell(0) = \\delta_{\\ell 0}$，解析解是 $F_\\ell(x) = j_\\ell(x)$。因此，在小的起始值 $x_0 = 10^{-6}$ 处的数值初始数据应设置为 $F_\\ell(x_0) = j_\\ell(x_0)$，其中 $\\ell \\in \\{0, 1, 2\\}$。\n  - 问题为RD和MD时期都指定了测试用例，但也明确说明了 $F_\\ell(x)$ 的动力学在这两种情况下是相同的。这意味着具有相同 $x_{\\mathrm{end}}$ 的测试用例的结果将是相同的（即，情况1=4，2=5，3=6）。这不是矛盾，而是一种冗余，用以测试对基础物理的理解。\n  - 提供的闭合关系 $F_3(x) \\approx \\frac{3}{x}F_2(x)$ 是待测数值方案的一个定义特征。虽然它可能不是一个高度准确的物理近似，但其有效性并非问题本身的先决条件，问题本身是要量化由这一特定近似引入的误差。\n\n**步骤 3：结论与行动**\n问题有效。我将继续进行求解。\n\n### 求解设计\n\n问题的核心是求解一个截断的常微分方程组，并将结果与已知的解析解进行比较。\n\n**1. 截断的常微分方程组**\n我们要求解微扰向量 $\\vec{F}(x) = [F_0(x), F_1(x), F_2(x)]^T$。对于 $\\ell=0, 1, 2$ 的级联方程是：\n$$\n\\frac{d F_0}{dx} = \\frac{1}{1}\\left[0 \\cdot F_{-1} - (0+1)F_1\\right] = -F_1\n$$\n$$\n\\frac{d F_1}{dx} = \\frac{1}{2(1)+1}\\left[1 \\cdot F_0 - (1+1)F_2\\right] = \\frac{1}{3}(F_0 - 2F_2)\n$$\n$$\n\\frac{d F_2}{dx} = \\frac{1}{2(2)+1}\\left[2 \\cdot F_1 - (2+1)F_3\\right] = \\frac{1}{5}(2F_1 - 3F_3)\n$$\n该系统使用给定的关系 $F_3(x) = \\frac{3}{x}F_2(x)$ 进行闭合。将其代入 $F_2$ 的方程中得到：\n$$\n\\frac{d F_2}{dx} = \\frac{1}{5}\\left(2F_1 - 3 \\cdot \\frac{3}{x}F_2\\right) = \\frac{2}{5}F_1 - \\frac{9}{5x}F_2\n$$\n这得到以下一阶线性常微分方程组：\n$$\n\\frac{d}{dx}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n=\n\\begin{pmatrix}\n0  -1  0 \\\\\n1/3  0  -2/3 \\\\\n0  2/5  -9/(5x)\n\\end{pmatrix}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n$$\n\n**2. 初始条件**\n问题指出，初始微扰是各向同性的，具有单位单极矩，即 $F_\\ell(x \\to 0) = \\delta_{\\ell 0}$。具有此初始条件的完整级联的解析解是 $F_\\ell(x) = j_\\ell(x)$，其中 $j_\\ell(x)$ 是第一类球贝塞尔函数。为了从 $x_0 = 10^{-6}$ 开始数值积分，我们将初始状态向量设置为解析解在该点的值：\n$$\n\\vec{F}(x_0) = \\begin{pmatrix} F_0(x_0) \\\\ F_1(x_0) \\\\ F_2(x_0) \\end{pmatrix} = \\begin{pmatrix} j_0(x_0) \\\\ j_1(x_0) \\\\ j_2(x_0) \\end{pmatrix}\n$$\n\n**3. 数值积分**\n该常微分方程组将从 $x_0 = 10^{-6}$ 数值积分到每个指定的 $x_{\\mathrm{end}} \\in \\{10^{-3}, 1, 20\\}$。我们将使用一个高精度自适应步长求解器，例如 `scipy.integrate.solve_ivp` 提供的求解器，以确保误差主要由闭合近似本身引起，而不是由数值积分的不准确性引起。我们设置严格的相对和绝对容差（例如，$10^{-12}$ 和 $10^{-14}$）。\n\n**4. 解析参考与误差计算**\n对于每个 $x_{\\mathrm{end}}$，数值解 $F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}})$ 与解析解 $F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}}) = j_\\ell(x_{\\mathrm{end}})$ 进行比较。使用提供的公式计算每个 $\\ell \\in \\{0,1,2\\}$ 的相对偏差 $\\epsilon_\\ell(x_{\\mathrm{end}})$：\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) = \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - j_\\ell(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|j_\\ell(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}\n$$\n每个测试用例的最终结果是这些偏差的最大值，$\\epsilon_{\\max}(x_{\\mathrm{end}}) = \\max_{ \\ell \\in \\{0,1,2\\}} \\epsilon_\\ell(x_{\\mathrm{end}})$。\n\n**5. 测试用例处理**\n如验证期间所确定的，RD和MD时期之间的区别对于计算 $F_\\ell(x)$ 是无关紧要的。因此，对于 $x_{\\mathrm{end}} = 10^{-3}$、$x_{\\mathrm{end}} = 1$ 和 $x_{\\mathrm{end}} = 20$ 的计算只执行一次，其结果在最终输出中为相应的RD和MD测试用例复制。最终的结果列表将有 6 个条目。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Solves the truncated Boltzmann hierarchy and computes the maximum relative\n    deviation from the analytic solution for a set of test cases.\n    \"\"\"\n    # Define constants from the problem statement.\n    x0 = 1.0e-6\n    floor_val = 1.0e-14\n\n    # Define the test cases. Note that the distinction between RD and MD eras is\n    # irrelevant for the computation of F_l(x), as the hierarchy's evolution\n    # only depends on the dimensionless variable x.\n    x_end_values_unique = [1.0e-3, 1.0, 20.0]\n    test_cases_x_end = [1.0e-3, 1.0, 20.0] * 2 # RD cases followed by MD cases\n\n    def boltzmann_hierarchy_truncated(x, F):\n        \"\"\"\n        Defines the system of ODEs for the truncated Boltzmann hierarchy.\n        \n        Args:\n            x (float): The dimensionless time variable k*eta.\n            F (np.ndarray): The state vector [F0, F1, F2].\n        \n        Returns:\n            list: The derivatives [dF0/dx, dF1/dx, dF2/dx].\n        \"\"\"\n        F0, F1, F2 = F\n        \n        # Equation for F_0: d_x F_0 = -F_1\n        dF0_dx = -F1\n        \n        # Equation for F_1: d_x F_1 = (1/3)*(F_0 - 2*F_2)\n        dF1_dx = F0 / 3.0 - (2.0 / 3.0) * F2\n        \n        # Equation for F_2 with closure F_3 = (3/x)*F_2:\n        # d_x F_2 = (1/5)*(2*F_1 - 3*F_3) = (2/5)*F_1 - (9/5x)*F_2\n        if x == 0:\n            # This case should not be reached since we start at x0 > 0.\n            # The small-x limit of dF2/dx is 0.\n            dF2_dx = 0.0\n        else:\n            dF2_dx = (2.0 / 5.0) * F1 - (9.0 / (5.0 * x)) * F2\n            \n        return [dF0_dx, dF1_dx, dF2_dx]\n\n    # Store results for unique x_end values to avoid redundant computations.\n    unique_results = {}\n\n    for x_end in x_end_values_unique:\n        # Set initial conditions using the analytic solution at x0.\n        # F_l(x0) = j_l(x0) for l=0,1,2.\n        F_initial = spherical_jn([0, 1, 2], x0)\n\n        # Numerically integrate the system of ODEs.\n        # Use high-precision tolerances to isolate the error from the closure.\n        sol = solve_ivp(\n            fun=boltzmann_hierarchy_truncated,\n            t_span=[x0, x_end],\n            y0=F_initial,\n            t_eval=[x_end],\n            method='LSODA',  # Good for potentially stiff problems like this.\n            rtol=1e-12,\n            atol=1e-14\n        )\n        # Numerical solution at x_end\n        F_num = sol.y.flatten()\n\n        # Analytic solution at x_end is j_l(x_end)\n        F_ana = spherical_jn([0, 1, 2], x_end)\n\n        # Compute the relative deviation for each multipole l={0,1,2}.\n        numerator = np.abs(F_num - F_ana)\n        denominator = np.maximum(np.abs(F_ana), floor_val)\n        epsilons = numerator / denominator\n        \n        # Find the maximum deviation for this test case.\n        epsilon_max = np.max(epsilons)\n        unique_results[x_end] = epsilon_max\n\n    # Assemble the final list of results in the specified order.\n    results = [unique_results[x] for x in test_cases_x_end]\n\n    # Format the output as specified: a list of floats in scientific\n    # notation with 8 significant digits.\n    formatted_results = [f\"{r:.8e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "3493623"}, {"introduction": "在真实宇宙中，中微子等粒子具有质量，这为玻尔兹曼等级结构引入了新的维度——动量。本练习将指导你开发一种稳健的数值方法（高斯求积法），以精确计算确定大质量中微子背景性质所需的动量空间积分。这项实践[@problem_id:3493584]对于在实际的玻尔兹曼代码中实现大质量中微子物理至关重要，它能帮助你处理相空间分布中的动量依赖性。", "problem": "考虑在宇宙微波背景（CMB）各向异性和玻尔兹曼级联的线性机制中的大质量中微子。在没有碰撞的情况下，刘维尔方程（Liouville equation）意味着未受扰动的相空间分布函数沿测地线守恒。对于一个具有费米-狄拉克平衡分布和零化学势的中微子种类，其共动量 $q$ 是恒定的，而共动能量为 $\\epsilon(a,q) = \\sqrt{q^2 + a^2 m_\\nu^2}$，其中 $a$ 是标度因子，$m_\\nu$ 是中微子质量。如果使用当前的中微子温度将共动量无量纲化为 $q \\rightarrow q/T_{\\nu,0}$，那么无量纲量 $y \\equiv a m_\\nu / T_{\\nu,0}$ 控制着从相对论性到非相对论性的转变。该中微子种类的背景能量密度和压强可以写成对共动量的积分，其中包含费米-狄拉克因子。在无量纲形式下，定义以下矩：\n$$\n\\rho_\\nu(y) \\propto \\int_0^\\infty \\frac{q^2 \\sqrt{q^2 + y^2}}{e^{q} + 1} \\, dq, \\qquad\nP_\\nu(y) \\propto \\int_0^\\infty \\frac{q^4}{3 \\sqrt{q^2 + y^2}} \\frac{1}{e^{q} + 1} \\, dq,\n$$\n以及相应的状态方程参数 $w_\\nu(y) \\equiv P_\\nu(y)/\\rho_\\nu(y)$。比例因子相对于 $q$ 和 $y$ 是常数，在本数值练习中可以忽略；目标是计算无量纲积分本身。\n\n您的任务是设计并实现一种数值策略，用于计算以下形式的积分：\n$$\nI_h(y) \\equiv \\int_0^\\infty \\frac{h(q,y)}{e^{q} + 1} \\, dq\n$$\n其中 $h(q,y)$ 是依赖于共动量 $q$ 和参数 $y$ 的平滑函数，特别关注 $y$ 既非极小也非极大的转变区域。通过离散化共动量 $q$ 并构建求积节点和权重，构造一个专用于半无限区间 $[0,\\infty)$ 的高斯求积法，该方法能在相对论性转变区域内得到精确的积分结果。此构造必须从第一性原理推导：从 $\\rho_\\nu(y)$ 和 $P_\\nu(y)$ 的相空间积分开始，系统地将积分转换为适合在 $[0,\\infty)$ 上进行高斯求积的形式，而不假设任何预先存在的针对费米-狄拉克积分的专门法则。明确证明在求积法中所选正交多项式和权重函数的合理性。\n\n实现一个程序，该程序：\n- 根据所选的权重函数，在 $[0,\\infty)$ 上构建高斯求积节点和权重，并使用它们来近似计算给定 $y$ 值下定义 $\\rho_\\nu(y)$ 和 $P_\\nu(y)$ 的积分。\n- 使用在 $[0,\\infty)$ 上的自适应数值积分计算相同积分的高精度参考值。\n- 报告 $\\rho_\\nu(y)$、$P_\\nu(y)$ 和 $w_\\nu(y)$ 的求积近似值，以及 $\\rho_\\nu(y)$ 和 $P_\\nu(y)$ 相对于参考值的相对误差。\n\n所有量都是无量纲的，因此不需要物理单位。\n\n测试套件：\n为以下测试用例 $(y,N)$ 提供结果，其中 $y$ 是无量纲质量参数，$N$ 是高斯求积点的数量：\n1. $(y,N) = (0.0, 12)$ 用于探测严格相对论性极限。\n2. $(y,N) = (0.5, 16)$ 作为轻度相对论性情况。\n3. $(y,N) = (1.0, 24)$ 作为转变区附近的一个“理想路径”。\n4. $(y,N) = (10.0, 12)$ 作为一个中度非相对论性情况，使用较少的节点以测试稳健性。\n5. $(y,N) = (50.0, 48)$ 使用更多节点来探测深度非相对论性极限。\n\n对于每个案例，计算：\n- $\\rho_\\nu(y)$ 的高斯求积近似值，\n- $P_\\nu(y)$ 的高斯求积近似值，\n- $w_\\nu(y)$ 的高斯求积近似值，\n- $\\rho_\\nu(y)$ 相对于自适应参考值的相对误差，以小数形式表示，\n- $P_\\nu(y)$ 相对于自适应参考值的相对误差，以小数形式表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表本身包含在方括号中，每个测试用例的结果按 $[\\rho_\\nu(y),P_\\nu(y),w_\\nu(y),\\text{rel\\_err\\_}\\rho_\\nu(y),\\text{rel\\_err\\_}P_\\nu(y)]$ 的顺序列出。例如，对于两个案例，输出格式将是：\n$$\n\\text{[}[r_1,p_1,w_1,e_{\\rho,1},e_{p,1}],[r_2,p_2,w_2,e_{\\rho,2},e_{p,2}]\\text{]}.\n$$\n您的程序必须在内部实现所有计算，并且不得读取任何外部输入。", "solution": "用户提供的问题是有效的。它在科学上植根于标准宇宙学模型中大质量中微子的物理学，问题定义明确，具有清晰的目标和充足的数据，并使用精确、客观的语言。其任务是开发并实现一种数值方法，用于计算在此背景下出现的特定积分，这是一个非平凡但可行的计算物理问题。\n\n### 基于原理的解决方案设计\n\n问题的核心是数值计算以下形式的积分：\n$$\nI_h(y) = \\int_0^\\infty \\frac{h(q,y)}{e^{q} + 1} \\, dq\n$$\n其中 $h(q,y)$ 代表与大质量中微子物种的能量密度和压强相关的函数。具体来说，对于能量密度 $\\rho_\\nu(y)$ 和压强 $P_\\nu(y)$，这些函数是：\n$$\nh_\\rho(q,y) = q^2 \\sqrt{q^2 + y^2}\n$$\n$$\nh_P(q,y) = \\frac{q^4}{3 \\sqrt{q^2 + y^2}}\n$$\n因子 $1 / (e^q + 1)$ 是费米-狄拉克分布因子。目标是构建一个高斯求积法则来准确计算这些积分。\n\n#### 1. 求积方案的选择\n\n标准的高斯求积方法，如高斯-勒让德（Gauss-Legendre）求积，定义在有限区间（通常是 $[-1, 1]$）上，不直接适用于我们积分的半无限区间 $[0, \\infty)$。虽然可以通过变量替换将 $[0, \\infty)$ 映射到有限区间，但这通常会引入新的数值挑战，或导致被积函数无法用低阶多项式很好地近似。\n\n一个更有效的策略是使用为区间 $[0, \\infty)$ 设计的高斯求积法则。高斯求积的一般形式是将积分近似为加权和：\n$$\n\\int_a^b W(q) f(q) \\, dq \\approx \\sum_{i=1}^{N} w_i f(q_i)\n$$\n其中 $W(q)$ 是一个固定的权重函数，$q_i$ 是求积节点（或点），$w_i$ 是相应的权重。关键是从我们的被积函数中选择一个合适的 $W(q)$。\n\n我们的积分可以通过分解出高斯-拉盖尔（Gauss-Laguerre）求积的标准权重函数 $W(q) = e^{-q}$ 来重写：\n$$\nI_h(y) = \\int_0^\\infty e^{-q} \\left( \\frac{e^q}{e^q + 1} h(q,y) \\right) \\, dq\n$$\n我们将需要由求积法则近似的函数确定为：\n$$\nf(q; y) = \\frac{e^q}{e^q + 1} h(q,y) = \\frac{1}{1 + e^{-q}} h(q,y)\n$$\n第二种形式使用 $e^{-q}$，在数值上更稳定，因为它避免了当 $q$ 值较大时发生上溢。\n\n选择 $W(q) = e^{-q}$ 是非常合理的。它将费米-狄拉克因子在大 $q$ 值时的主要指数衰减行为分离出来，形成一个标准的权重函数。相关的正交多项式是拉盖尔多项式（Laguerre polynomials） $L_n(q)$，得到的求积法是高斯-拉盖尔求积。为了使该方法高效，函数 $f(q;y)$ 必须能被关于 $q$ 的多项式很好地近似。对于 $\\rho_\\nu$ 和 $P_\\nu$，$h(q,y)$ 函数在大 $q$ 值时表现为 $q$ 的幂次（具体为 $q^3$），而因子 $1/(1+e^{-q})$ 平滑地趋近于 $1$。因此，$f(q;y)$ 是一个适合多项式近似的平滑函数。\n\n#### 2. 高斯-拉盖尔求积法则的构建\n\n问题要求从第一性原理构建求积法则。一个 $N$ 点高斯-拉盖尔求积的节点 $q_i$ 是 $N$ 阶拉盖尔多项式 $L_N(q)$ 的根。节点和权重可以通过 Golub-Welsch 算法高效且稳定地确定，该算法将问题与一个称为雅可比矩阵（Jacobi matrix）的特定对称三对角矩阵的特征系统联系起来。\n\n首一（monic）拉盖尔多项式 $\\hat{L}_n(q)$ 满足三项递推关系：\n$$\n\\hat{L}_{n+1}(q) = (q - \\alpha_n) \\hat{L}_n(q) - \\beta_n \\hat{L}_{n-1}(q)\n$$\n其递推系数为：\n$$\n\\alpha_n = 2n + 1, \\qquad \\beta_n = n^2\n$$\n相应的 $N \\times N$ 雅可比矩阵 $J_N$ 由这些系数构建：\n$$\nJ_N = \\begin{pmatrix}\n\\alpha_0  \\sqrt{\\beta_1}  0  \\dots  0 \\\\\n\\sqrt{\\beta_1}  \\alpha_1  \\sqrt{\\beta_2}  \\dots  0 \\\\\n0  \\sqrt{\\beta_2}  \\alpha_2  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  \\sqrt{\\beta_{N-1}} \\\\\n0  \\dots  \\dots  \\sqrt{\\beta_{N-1}}  \\alpha_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1  1  0  \\dots  0 \\\\\n1  3  2  \\dots  0 \\\\\n0  2  5  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  N-1 \\\\\n0  \\dots  \\dots  N-1  2N-1\n\\end{pmatrix}\n$$\n该矩阵 $J_N$ 的特征值即为求积节点 $\\{q_i\\}_{i=1}^N$。相应的权重 $\\{w_i\\}_{i=1}^N$ 由归一化特征向量的第一个分量的平方给出。权重函数的积分为 $\\int_0^\\infty e^{-q} dq = 1$，这简化了权重的计算。\n\n算法步骤如下：\n1. 对于给定的点数 $N$，构建 $N \\times N$ 的雅可比矩阵 $J_N$。\n2. 求解 $J_N$ 的特征值问题，得到特征值（节点 $q_i$）和相应的归一化特征向量 $\\mathbf{v}_i$。\n3. 权重为 $w_i = (\\mathbf{v}_i)_1^2$，其中 $(\\mathbf{v}_i)_1$ 是特征向量 $\\mathbf{v}_i$ 的第一个分量。\n\n#### 3. 数值实现与评估\n\n构建好节点 $q_i$ 和权重 $w_i$ 后，能量密度和压强的积分近似为：\n$$\n\\rho_\\nu(y) \\approx \\sum_{i=1}^N w_i f_\\rho(q_i, y) = \\sum_{i=1}^N w_i \\frac{1}{1+e^{-q_i}} \\left( q_i^2 \\sqrt{q_i^2 + y^2} \\right)\n$$\n$$\nP_\\nu(y) \\approx \\sum_{i=1}^N w_i f_P(q_i, y) = \\sum_{i=1}^N w_i \\frac{1}{1+e^{-q_i}} \\left( \\frac{q_i^4}{3 \\sqrt{q_i^2 + y^2}} \\right)\n$$\n在压强积分中，对于 $y=0$ 的情况需要特别处理以避免除以零。在此极限下，$\\sqrt{q^2+y^2} \\to q$，因此 $h_P(q,0) \\to q^3/3$。\n\n为了评估此自定义求积的准确性，我们使用自适应求积程序（具体为 `scipy.integrate.quad`）计算每个积分的高精度参考值，该程序应用于原始积分形式 $\\int_0^\\infty g(q,y) dq$。然后，相对误差计算如下：\n$$\n\\text{rel\\_err} = \\left| \\frac{I_{\\text{approx}} - I_{\\text{ref}}}{I_{\\text{ref}}} \\right|\n$$\n状态方程参数直接由近似的密度和压强计算得出：$w_\\nu(y) = P_\\nu(y) / \\rho_\\nu(y)$。\n\n这种综合方法能够在从高度相对论性（$y \\ll 1$）到非相对论性（$y \\gg 1$）的整个物理范围内，稳健而准确地计算所需的中微子矩积分。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the neutrino integral problem by constructing a Gauss-Laguerre quadrature rule,\n    evaluating the integrals for given test cases, and comparing with a high-accuracy reference.\n    \"\"\"\n\n    test_cases = [\n        (0.0, 12),\n        (0.5, 16),\n        (1.0, 24),\n        (10.0, 12),\n        (50.0, 48),\n    ]\n\n    results = []\n    for y, N in test_cases:\n        # Step 1: Construct Gauss-Laguerre quadrature nodes and weights\n        # using the Golub-Welsch algorithm on the Jacobi matrix.\n        \n        # Coefficients for the three-term recurrence of monic Laguerre polynomials:\n        # alpha_n = 2n + 1, beta_n = n^2\n        alpha = np.arange(1, 2 * N, 2, dtype=float)\n        beta_sqrt = np.arange(1, N, dtype=float)\n\n        # Construct the symmetric tridiagonal Jacobi matrix\n        J = np.diag(alpha) + np.diag(beta_sqrt, k=1) + np.diag(beta_sqrt, k=-1)\n\n        # Solve the eigenvalue problem for the Jacobi matrix.\n        # Eigenvalues are the quadrature nodes.\n        # Weights are the squared first components of the normalized eigenvectors.\n        nodes, evecs = np.linalg.eigh(J)\n        weights = evecs[0, :]**2\n        \n        # Step 2: Define the integrands for density and pressure\n        \n        # Functions h(q,y) from the problem statement\n        def h_rho(q, y_val):\n            return q**2 * np.sqrt(q**2 + y_val**2)\n\n        def h_P(q, y_val):\n            if y_val == 0.0:\n                # For y=0, sqrt(q^2+y^2) = q. The integrand h_P becomes q^3/3.\n                # This correctly handles the limit q->0.\n                return q**3 / 3.0\n            else:\n                return q**4 / (3.0 * np.sqrt(q**2 + y_val**2))\n\n        # Functions f(q,y) = h(q,y) / (1 + exp(-q)) for Gauss-Laguerre quadrature\n        def f_rho(q, y_val):\n            return h_rho(q, y_val) / (1.0 + np.exp(-q))\n\n        def f_P(q, y_val):\n            return h_P(q, y_val) / (1.0 + np.exp(-q))\n        \n        # Step 3: Compute approximations using the constructed quadrature rule\n        rho_approx = np.sum(weights * f_rho(nodes, y))\n        p_approx = np.sum(weights * f_P(nodes, y))\n\n        if rho_approx != 0:\n            w_approx = p_approx / rho_approx\n        else:\n            w_approx = 0.0 # Should not happen as integrand is positive\n\n        # Step 4: Compute high-accuracy reference values using adaptive quadrature\n        \n        # Full integrands g(q,y) = h(q,y) / (exp(q) + 1)\n        def g_rho(q, y_val):\n            return h_rho(q, y_val) / (np.exp(q) + 1.0)\n        \n        def g_P(q, y_val):\n            return h_P(q, y_val) / (np.exp(q) + 1.0)\n\n        rho_ref, _ = integrate.quad(g_rho, 0, np.inf, args=(y,))\n        p_ref, _ = integrate.quad(g_P, 0, np.inf, args=(y,))\n        \n        # Step 5: Calculate relative errors\n        if rho_ref != 0:\n            rel_err_rho = np.abs((rho_approx - rho_ref) / rho_ref)\n        else:\n            rel_err_rho = 0.0 if rho_approx == 0.0 else np.inf\n\n        if p_ref != 0:\n            rel_err_p = np.abs((p_approx - p_ref) / p_ref)\n        else:\n            rel_err_p = 0.0 if p_approx == 0.0 else np.inf\n\n        results.append([\n            rho_approx,\n            p_approx,\n            w_approx,\n            rel_err_rho,\n            rel_err_p\n        ])\n\n    # Final print statement in the exact required format.\n    # We construct the string representation manually to ensure no spaces within sub-lists.\n    formatted_results = []\n    for res_list in results:\n        # Format each sublist to a string like \"[item1,item2,...]\"\n        formatted_sublist = f\"[{','.join(f'{item:.15g}' for item in res_list)}]\"\n        formatted_results.append(formatted_sublist)\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3493584"}, {"introduction": "闭合关系的选择不仅仅是数值精度问题，它还具有深刻的物理影响。这个高级练习将前述的截断概念与引力理论联系起来，揭示不正确的闭合关系如何产生虚假的各向异性应力。这项实践[@problem_id:3493570]将通过一个可量化的测试，展示这种数值误差如何非物理地改变引力势的演化，从而加深你对玻尔兹曼方程与爱因斯坦方程之间自洽耦合重要性的理解。", "problem": "考虑一个空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克宇宙，在线元为 $ds^2 = a^2(\\tau)\\left\\{-(1+2\\psi)d\\tau^2 + (1-2\\phi)d\\mathbf{x}^2\\right\\}$ 的牛顿规范下研究线性标量微扰，其中 $a(\\tau)$ 是尺度因子，$\\tau$ 是共形时间。将无碰撞、无质量的中微子作为唯一的物质组分，并考虑一个共动波数为 $k$ 的傅里叶模式。中微子相空间分布函数的微扰被展开为勒让德多极矩，形成一个玻尔兹曼级联 $F_\\ell(\\tau)$，其中 $\\ell = 0,1,2,\\dots$。相关关系式包括：牛顿规范势 $\\phi$ 和 $\\psi$ 在傅里叶空间中的线性化爱因斯坦方程、由玻尔兹曼多极矩定义的各向异性应力，以及无质量粒子的无碰撞玻尔兹曼级联。使用以下基本事实作为出发点：\n- 在辐射主导时期，共形哈勃率满足 $H(\\tau) \\equiv a'(\\tau)/a(\\tau) = 1/\\tau$，背景弗里德曼方程则意味着 $8\\pi G a^2 \\rho = 3H^2$。\n- 在傅里叶空间中，牛顿规范的爱因斯坦方程（约束方程）为\n$$\nk^2 \\psi + 3 H \\left(\\psi' + H \\phi\\right) = -4\\pi G a^2 \\delta \\rho,\\quad\nk^2 \\left(\\psi' + H \\phi\\right) = 4\\pi G a^2 (\\rho + P) \\theta,\\quad\nk^2(\\phi - \\psi) = 12\\pi G a^2 \\sum_s (\\rho_s + P_s) \\sigma_s,\n$$\n其中撇号表示 $d/d\\tau$，$\\delta \\rho$ 是能量密度微扰，$\\theta$ 是速度散度，$\\sigma_s$ 是粒子种类 $s$ 的各向异性应力。对于无质量粒子，$(\\rho+P)=\\frac{4}{3}\\rho$。\n- 对于无碰撞的无质量中微子，与亮度多极矩的标准对应关系成立：$\\delta_\\nu = F_0$，$\\theta_\\nu = \\frac{3k}{4}F_1$，$\\sigma_\\nu = \\frac{1}{2}F_2$，并且对于 $\\ell \\ge 3$，无碰撞演化是自由流。\n- 无质量粒子多极矩的无碰撞玻尔兹曼级联为\n$$\nF_0' = -k F_1 - 4\\phi',\\quad\nF_1' = k\\left(\\frac{F_0}{3} - \\frac{2F_2}{3}\\right) + k\\psi,\\quad\nF_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right),\\quad\nF_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right]\\ \\text{for}\\ \\ell\\ge 3.\n$$\n\n你的任务是：\n1. 证明在有限多极矩 $l_{\\max}$ 处截断玻尔兹曼级联，并对 $F_{l_{\\max}+1}$ 使用不恰当的闭合关系，通常会产生虚假的各向异性应力（通过不正确的 $F_2$），从而导致 $\\phi$ 和 $\\psi$ 之间出现非物理的差异，并反馈到动力学演化中。你的证明必须从上述基本方程出发，通过逻辑步骤进行，不能假设任何未在你推理中推导出的简化公式。你必须做出一个科学上现实的近似选择，以便将证明推向一个清晰的数学陈述，并且必须明确说明你的近似适用的范围。\n2. 设计一个数值测试，以检测度规演化是否因不恰当的闭合关系而受到污染。该测试必须能够以程序形式实现，并应能产生一个可量化的诊断指标。在一个仅含中微子的辐射背景（$a(\\tau) \\propto \\tau$）上构建该测试，并在亚视界、准静态区域内进行，该区域中 $k \\gg H(\\tau)$ 且类泊松方程中的 $3H(\\psi' + H\\phi)$ 项可以忽略不计。检测应基于比较使用物理上合理的自由流闭合关系与使用朴素闭合关系所得到的引力滑移参数 $\\eta(\\tau) \\equiv \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$。物理上合理的闭合关系可以采用渐近自由流形式 $F_{l_{\\max}+1} \\approx \\frac{2l_{\\max}+1}{k\\tau}F_{l_{\\max}}$，而朴素闭合关系则设 $F_{l_{\\max}+1}=0$。\n3. 将该测试实现为一个完整的可运行程序，该程序对单个傅里叶模式积分玻尔兹曼级联，并计算在两种闭合关系下最终时刻的滑移参数 $\\eta(\\tau_f)$。如果绝对差超过指定阈值，则宣布检测到污染，并为每个测试用例输出一个布尔值。使用准静态亚视界近似\n$$\n\\psi(\\tau) \\approx -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau),\\quad\n\\phi(\\tau) \\approx \\psi(\\tau) + \\frac{6H^2(\\tau)}{k^2}\\sigma_\\nu(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau),\n$$\n并通过消去 $\\phi'$，用 $F_0$ 和 $F_2$ 的时间导数来表示，从而自洽地强制实现级联与 $\\phi'$ 的耦合。\n\n将 $\\tau=\\tau_i$ 时的初始多极矩定义为 $F_0(\\tau_i)=10^{-5}$ 和 $F_\\ell(\\tau_i)=0$（对于 $\\ell\\ge 1$）。你必须将所有量视为无量纲的，并明确说明你使用的任何近似。你的程序必须使用以下测试套件，涵盖一个正常路径用例、一个截断应力边缘用例和一个高分辨率边界用例：\n\n- 测试用例1（正常路径）：$l_{\\max}=7$，$k=3.0$，$\\tau_i=20.0$，$\\tau_f=120.0$，阈值 $=10^{-3}$。\n- 测试用例2（边缘用例，激进截断）：$l_{\\max}=3$，$k=3.0$，$\\tau_i=20.0$，$\\tau_f=120.0$，阈值 $=10^{-2}$。\n- 测试用例3（边界用例，高多极矩分辨率）：$l_{\\max}=25$，$k=3.0$，$\\tau_i=20.0$，$\\tau_f=120.0$，阈值 $=10^{-5}$。\n\n你的程序应该生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如“[True,False,True]”。每个元素都是一个布尔值，指示在比较朴素闭合与物理上合理的闭合时，相应测试用例是否检测到污染。所有输出都是无量纲的。不涉及角度或百分比；输出中不要包含任何单位。", "solution": "用户提供的问题已经过分析并被确定为有效。该问题在科学上基于宇宙学微扰理论的原理，在数学上是适定的，具有完整且一致的方程组和条件，并且其表述是客观的。该问题探讨了数值宇宙学中一个相关且重要的话题——玻尔兹曼级联中截断误差的影响。\n\n### 第1部分：截断产生虚假各向异性应力的证明\n\n目标是证明在有限多极矩 $\\ell_{\\max}$ 处截断玻尔兹曼级联，并为 $F_{\\ell_{\\max}+1}$ 使用不当的闭合关系，会产生一个非物理的各向异性应力，这反过来又在引力势 $\\phi$ 和 $\\psi$ 之间造成人为的差异。\n\n1.  **度规势与各向异性应力之间的关系：**\n    出发点是关联引力滑移 $\\phi-\\psi$ 和各向异性应力 $\\sigma_s$ 的爱因斯坦方程。对于单一类型的无质量中微子，该方程为：\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 (\\rho_\\nu + P_\\nu) \\sigma_\\nu$$\n    对于无质量粒子（辐射），其状态方程为 $P_\\nu = \\frac{1}{3}\\rho_\\nu$，所以 $\\rho_\\nu + P_\\nu = \\frac{4}{3}\\rho_\\nu$。方程变为：\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 \\left(\\frac{4}{3}\\rho_\\nu\\right) \\sigma_\\nu = 16\\pi G a^2 \\rho_\\nu \\sigma_\\nu$$\n    从辐射主导宇宙中的背景弗里德曼方程，我们有 $3H^2 = 8\\pi G a^2 \\rho_\\nu$。将此代入前一个方程得到：\n    $$k^2(\\phi - \\psi) = 2 \\cdot (8\\pi G a^2 \\rho_\\nu) \\sigma_\\nu = 2 \\cdot (3H^2) \\sigma_\\nu = 6H^2 \\sigma_\\nu$$\n    问题将中微子各向异性应力多极矩定义为 $\\sigma_\\nu = \\frac{1}{2}F_2$。代入此关系式得到直接的联系：\n    $$k^2(\\phi - \\psi) = 3H^2 F_2 \\implies \\phi - \\psi = \\frac{3H^2}{k^2} F_2$$\n    该方程表明，四极矩 $F_2$ 计算中的任何误差都将直接且成比例地在 $\\phi$ 和 $\\psi$ 之间产生非物理的差异。\n\n2.  **截断误差在级联中的传播：**\n    对于 $\\ell \\ge 2$，玻尔兹曼多极矩的演化由无碰撞玻尔兹曼级联控制：\n    $$F_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right)$$\n    $$F_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right] \\quad \\text{for}\\ \\ell\\ge 3$$\n    为了数值求解该系统，必须在某个有限的 $\\ell_{\\max}$ 处进行截断。$F_{\\ell_{\\max}}$ 的方程为：\n    $$F_{\\ell_{\\max}}' = \\frac{k}{2\\ell_{\\max}+1}\\left[\\ell_{\\max} F_{\\ell_{\\max}-1} - (\\ell_{\\max}+1)F_{\\ell_{\\max}+1}\\right]$$\n    这个方程需要一个关于 $F_{\\ell_{\\max}+1}$ 的闭合关系。一个朴素但错误的闭合是设 $F_{\\ell_{\\max}+1} = 0$。\n\n3.  **在自由流状态下的分析：**\n    在亚视界、自由流状态（$k\\tau \\gg 1$）下，证明最为清晰，此时微扰以相对论性方式传播。在这种状态下，多极矩 $F_\\ell$ 的真实物理解是非零的，并且通常呈振荡衰减（类似于球贝塞尔函数，$F_\\ell \\sim j_\\ell(k\\tau)$）。关键是，如果 $F_{\\ell_{\\max}}$ 非零，那么 $F_{\\ell_{\\max}+1}$ 通常也非零。\n\n4.  **误差级联：**\n    设 $\\tilde{F}_\\ell$ 为使用朴素闭合 $\\tilde{F}_{\\ell_{\\max}+1} = 0$ 计算出的数值多极矩，而 $F_\\ell$ 为真实的物理解。\n    计算出的 $\\tilde{F}_{\\ell_{\\max}}$ 的演化变为：\n    $$\\tilde{F}_{\\ell_{\\max}}' = \\frac{k \\ell_{\\max}}{2\\ell_{\\max}+1}\\tilde{F}_{\\ell_{\\max}-1}$$\n    导数的误差 $\\Delta F_{\\ell_{\\max}}' = \\tilde{F}_{\\ell_{\\max}}' - F_{\\ell_{\\max}}'$ 可通过从截断的演化方程中减去真实的演化方程得到：\n    $$\\Delta F_{\\ell_{\\max}}' \\approx \\frac{k(\\ell_{\\max}+1)}{2\\ell_{\\max}+1} F_{\\ell_{\\max}+1}$$\n    这里我们假设较低阶多极矩的误差初始很小，即 $\\tilde{F}_{\\ell_{\\max}-1} \\approx F_{\\ell_{\\max}-1}$。由于物理上 $F_{\\ell_{\\max}+1} \\neq 0$，朴素闭合引入了一个误差源项 $\\Delta F_{\\ell_{\\max}}'$。这个误差会通过级联向下传播。任何较低阶多极矩 $\\ell-1$ 的方程是 $F_{\\ell-1}' = \\frac{k}{2\\ell-1}\\left[(\\ell-1)F_{\\ell-2} - \\ell F_\\ell\\right]$，这表明误差 $\\Delta F_{\\ell_{\\max}}$ 将会引发误差 $\\Delta F_{\\ell_{\\max}-1}'$，后者又会引发误差 $\\Delta F_{\\ell_{\\max}-2}'$，依此类推。这种误差级联不可避免地会影响到 $F_3$，从而产生误差 $\\Delta F_3$。\n\n5.  **结论：**\n    误差 $\\Delta F_3$ 会馈入四极矩的演化中：\n    $$\\Delta F_2' = \\tilde{F}_2' - F_2' = k\\left(-\\frac{3}{5}\\Delta F_3\\right)$$\n    这会产生一个随时间累积的误差 $\\Delta F_2$。这个虚假的 $\\tilde{F}_2 = F_2 + \\Delta F_2$ 直接产生了一个虚假的各向异性应力 $\\tilde{\\sigma}_\\nu = \\frac{1}{2}\\tilde{F}_2$。如步骤1所示，这导致了非物理的引力滑移：\n    $$(\\phi - \\psi)_{\\text{spurious}} = \\frac{3H^2}{k^2} \\tilde{F}_2 \\neq \\frac{3H^2}{k^2} F_2 = (\\phi - \\psi)_{\\text{physical}}$$\n    至此证明完成。不恰当的闭合关系 $F_{\\ell_{\\max}+1}=0$ 引入了一个系统误差，污染了整个级联，最终导致度规势的物理上不正确的演化。\n\n### 第2部分：数值测试设计\n\n数值测试旨在通过比较两种不同玻尔兹曼级联闭合方案的结果，来量化上述污染。\n\n1.  **常微分方程组：** 测试的核心是对多极矩向量 $\\vec{F}(\\tau) = [F_0, F_1, \\dots, F_{\\ell_{\\max}}]^T$ 的 $l_{\\max}+1$ 个耦合一阶常微分方程组进行数值积分。\n2.  **运动方程：** 导数 $F_\\ell' = dF_\\ell/d\\tau$ 由玻尔兹曼级联给出。$F_0'$ 和 $F_1'$ 的方程被修改以包含引力源项 $\\phi'$ 和 $\\psi$，这些项在准静态亚视界近似（$k \\gg H$）下自洽计算。\n    -   引力势：$\\psi(\\tau) = -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau)$ 和 $\\phi(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau)$，其中 $H(\\tau)=1/\\tau$。\n    -   $F_0'$ 项：通过对 $\\phi(\\tau)$ 的表达式求导并将其代入 $F_0'$ 方程，代数消去 $F_0'$ 方程中的 $\\phi'$ 项。这得到一个依赖于 $F_0, F_1, F_2, F_3$ 的 $F_0'$ 方程。\n    -   $F_1'$ 项：将引力势 $\\psi$ 直接代入 $F_1'$ 的方程。\n    -   级联：其余的 $F_\\ell'$ 方程（$\\ell \\ge 2$）按原样使用。\n\n3.  **闭合方案：** 该系统被积分两次，每次使用不同的 $F_{\\ell_{\\max}+1}$ 闭合方案：\n    -   **朴素闭合：** $F_{\\ell_{\\max}+1}(\\tau) = 0$。预计这将产生污染。\n    -   **物理上合理的闭合：** $F_{\\ell_{\\max}+1}(\\tau) \\approx \\frac{2\\ell_{\\max}+1}{k\\tau}F_{\\ell_{\\max}}(\\tau)$。这是一个在自由流极限（$k\\tau \\gg \\ell_{\\max}$）下有效的渐近近似，并作为更准确的物理参考。\n\n4.  **诊断与检测：** 诊断指标是引力滑移参数 $\\eta(\\tau) = \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$。使用准静态近似：\n    $$\\eta(\\tau) = \\frac{(3H^2/k^2) F_2(\\tau)}{-(3H^2/2k^2) F_0(\\tau)} = -2\\frac{F_2(\\tau)}{F_0(\\tau)}$$\n    测试流程如下：\n    a. 以初始条件 $F_0(\\tau_i)=10^{-5}$ 和 $F_{\\ell\\ge1}(\\tau_i)=0$ 对常微分方程组从 $\\tau_i$ 积分到 $\\tau_f$。对朴素闭合和物理闭合两种情况都执行此操作，以获得最终状态向量 $\\vec{F}_{\\text{naive}}(\\tau_f)$ 和 $\\vec{F}_{\\text{phys}}(\\tau_f)$。\n    b. 计算两种情况下的最终滑移参数：$\\eta_{\\text{naive}}(\\tau_f) = -2 \\frac{F_{2, \\text{naive}}(\\tau_f)}{F_{0, \\text{naive}}(\\tau_f)}$ 和 $\\eta_{\\text{phys}}(\\tau_f) = -2 \\frac{F_{2, \\text{phys}}(\\tau_f)}{F_{0, \\text{phys}}(\\tau_f)}$。\n    c. 计算绝对差 $\\Delta\\eta = |\\eta_{\\text{naive}} - \\eta_{\\text{phys}}|$。\n    d. 如果 $\\Delta\\eta$ 超过了测试用例指定的阈值，则检测到污染。\n\n### 第3部分：实现策略\n\n该数值测试以Python程序实现。\n-   **常微分方程求解器：** 使用 `scipy.integrate.solve_ivp` 函数，因其鲁棒性和自适应步长，适合处理玻尔兹曼级联可能出现的刚性或振荡行为。\n-   **导数函数：** 定义一个函数 `derivatives(tau, F, k, lmax, closure_type)`，用于计算时间导数向量 $\\vec{F}'$。\n    - 它接受当前时间 `tau`、状态向量 `F`、波数 `k`、截断阶数 `lmax` 和一个指定 `closure_type` 的字符串。\n    - 它实现了选择 $F_{\\ell_{\\max}+1}$ 闭合方案的逻辑。\n    - 它根据级联方程和自洽的准静态近似计算每个 $F_\\ell'$。其逻辑结构正确处理了 $\\ell=0, 1, 2$ 的特殊形式和 $\\ell \\ge 3$ 的通用形式。\n-   **主循环：** 一个主函数遍历预定义的测试用例。对每个用例，它初始化系统，运行求解器两次（每种闭合方案一次），计算污染诊断指标 $\\Delta\\eta$，并将其与阈值比较以产生布尔结果。最终输出格式化为这些布尔值的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef derivatives(tau, F, k, lmax, closure_type):\n    \"\"\"\n    Computes the time derivative of the Boltzmann hierarchy multipoles F_l.\n\n    Args:\n        tau (float): Conformal time.\n        F (np.ndarray): State vector of multipoles [F_0, F_1, ..., F_lmax].\n        k (float): Comoving wavenumber.\n        lmax (int): Maximum multipole moment in the hierarchy.\n        closure_type (str): Either 'naive' or 'phys' for the closure scheme.\n\n    Returns:\n        np.ndarray: The vector of derivatives dF/dtau.\n    \"\"\"\n    dF = np.zeros(lmax + 1)\n\n    # A helper to get F_l, applying the closure rule for l > lmax.\n    # This simplifies the loops and makes the logic clear.\n    def get_F(l):\n        if l = lmax:\n            return F[l]\n        elif l == lmax + 1:\n            if closure_type == 'naive':\n                return 0.0\n            elif closure_type == 'phys':\n                # Physically motivated free-streaming closure\n                return (2 * lmax + 1) / (k * tau) * F[lmax]\n            else:\n                raise ValueError(\"Unknown closure_type\")\n        else:\n            # For l > lmax + 1, we assume the contribution is zero.\n            # This is implicitly part of the truncation scheme.\n            return 0.0\n\n    # The problem specifies test cases with lmax >= 3, so F[0]..F[3] exist.\n    F0, F1, F2, F3 = get_F(0), get_F(1), get_F(2), get_F(3)\n\n    # --- F_0' Equation ---\n    # This is the most complex due to the self-consistent treatment of phi'.\n    # F_0'(1 + 6/(k^2*tau^2)) = -k*F_1 - 12/(k^2*tau^3)*F_0 + 24/(k^2*tau^3)*F_2 - 12/(k^2*tau^2)*F_2'\n    # We substitute F_2' = k*(2/5*F_1 - 3/5*F_3)\n    F2_prime = k * (2.0 / 5.0 * F1 - 3.0 / 5.0 * F3)\n    \n    # Pre-computation for clarity\n    k_tau_sq = (k * tau)**2\n    k_sq_tau_cubed = k**2 * tau**3\n    \n    f0_factor = 1.0 + 6.0 / k_tau_sq\n    rhs_f0 = -k * F1 - (12.0 / k_sq_tau_cubed) * F0 \\\n             + (24.0 / k_sq_tau_cubed) * F2 \\\n             - (12.0 / k_tau_sq) * F2_prime\n    dF[0] = rhs_f0 / f0_factor\n\n    # --- F_1' Equation ---\n    # F_1' = k*(F_0/3 - 2*F_2/3) + k*psi, with psi = -1.5/(k^2*tau^2)*F_0\n    psi = -1.5 / k_tau_sq * F0\n    dF[1] = k * (F0 / 3.0 - 2.0 / 3.0 * F2) + k * psi\n\n    # --- F_2' and higher Hierarchy ---\n    # F_2'\n    dF[2] = F2_prime\n\n    # F_l' for l in [3, lmax]\n    for l in range(3, lmax + 1):\n        F_l_minus_1 = get_F(l - 1)\n        F_l_plus_1 = get_F(l + 1)\n        dF[l] = (k / (2 * l + 1.0)) * (l * F_l_minus_1 - (l + 1) * F_l_plus_1)\n\n    return dF\n\n\ndef run_test_case(lmax, k, tau_i, tau_f, threshold):\n    \"\"\"\n    Runs the numerical test for a single case.\n    \"\"\"\n    # Initial conditions\n    y0 = np.zeros(lmax + 1)\n    y0[0] = 1e-5\n\n    # Integration parameters for solve_ivp\n    integration_params = {\n        't_span': [tau_i, tau_f],\n        'y0': y0,\n        'method': 'RK45', # Standard choice\n        'rtol': 1e-9,\n        'atol': 1e-12\n    }\n\n    # Solve with naive closure\n    sol_naive = solve_ivp(derivatives, args=(k, lmax, 'naive'), **integration_params)\n    F_naive_final = sol_naive.y[:, -1]\n\n    # Solve with physical closure\n    sol_phys = solve_ivp(derivatives, args=(k, lmax, 'phys'), **integration_params)\n    F_phys_final = sol_phys.y[:, -1]\n\n    # Calculate slip parameter eta = -2 * F_2 / F_0\n    # Guard against division by zero, although F_0 should be stable.\n    if F_naive_final[0] == 0 or F_phys_final[0] == 0:\n        # This case indicates a numerical failure, should not happen.\n        return False\n        \n    eta_naive = -2.0 * F_naive_final[2] / F_naive_final[0]\n    eta_phys = -2.0 * F_phys_final[2] / F_phys_final[0]\n\n    # Detect contamination\n    delta_eta = abs(eta_naive - eta_phys)\n    return delta_eta > threshold\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (l_max, k, tau_i, tau_f, threshold)\n        (7, 3.0, 20.0, 120.0, 1e-3),\n        (3, 3.0, 20.0, 120.0, 1e-2),\n        (25, 3.0, 20.0, 120.0, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        lmax, k, tau_i, tau_f, threshold = case\n        result = run_test_case(lmax, k, tau_i, tau_f, threshold)\n        results.append(result)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493570"}]}