{"hands_on_practices": [{"introduction": "自适应偏置力（ABF）方法的理论基础是平均力场是一个保守场，这意味着其路径积分与路径无关。然而在实践中，采样噪声会引入一个非保守分量，从而破坏路径无关性。本练习提供了一个直接的动手实践机会，通过沿不同路径对含噪声的力场进行数值积分，并观察由此产生的差异，来量化这种效应 ([@problem_id:3394488])。", "problem": "考虑一个二维集体变量空间，其坐标为 $\\xi = (\\xi_1,\\xi_2) \\in \\mathbb{R}^2$。在自适应偏置力 (Adaptive Biasing Force, ABF) 方法中，平均力场定义为自由能（也称作平均力势）$A(\\xi)$ 的负梯度，即 $M(\\xi) = -\\nabla A(\\xi)$。根据矢量微积分中的线积分基本定理，如果 $M(\\xi)$ 是严格保守的，那么 $M(\\xi)$ 从点 $\\xi^{(0)}$ 到点 $\\xi^{(1)}$ 的线积分与路径无关，且等于 $A(\\xi^{(0)}) - A(\\xi^{(1)})$。在计算实践中，估算的平均力场包含噪声，可写作 $\\widetilde{M}(\\xi) = M(\\xi) + \\eta(\\xi)$，其中 $\\eta(\\xi)$ 是一个零均值扰动，这使得对于 $\\eta(\\xi)$ 的任何特定实现，线积分都变得与路径相关。您的任务是对于给定的解析自由能 $A(\\xi_1,\\xi_2)$，量化这种噪声所引起的差异。\n\n仅从上述基本定义和标准微积分出发，对每个测试用例执行以下操作：\n1. 使用提供的解析 $A(\\xi)$ 来精确定义 $M(\\xi) = -\\nabla A(\\xi)$。\n2. 对于固定的端点 $\\xi^{(0)}$ 和 $\\xi^{(1)}$，构建两条不同的积分路径：\n   - 路径 S（直线）：$\\xi(t) = \\xi^{(0)} + t\\left(\\xi^{(1)} - \\xi^{(0)}\\right)$，其中 $t \\in [0,1]$。\n   - 路径 L（两段式L形路径）：首先在固定的 $\\xi_2 = \\xi_2^{(0)}$ 下沿 $\\xi_1$ 方向从 $\\xi_1^{(0)}$ 移动到 $\\xi_1^{(1)}$，然后在固定的 $\\xi_1 = \\xi_1^{(1)}$ 下沿 $\\xi_2$ 方向从 $\\xi_2^{(0)}$ 移动到 $\\xi_2^{(1)}$。\n3. 定义含噪估计 $\\widetilde{M}(\\xi) = M(\\xi) + \\eta$，其中在每个求积线段上，$\\eta$ 是从一个零均值、协方差为 $\\sigma^2 I_2$ 的二元正态分布中进行的独立抽样。每个测试用例使用固定的随机种子以保证结果可复现；在同一测试用例中，为路径 S 和路径 L 使用独立的种子。\n4. 使用中点求积法，沿路径参数化将路径分为 $N = 20000$ 个等长线段，计算每条路径上的线积分，即近似计算\n   $$\\int_{\\mathcal{C}} \\widetilde{M}(\\xi) \\cdot d\\xi \\approx \\sum_{k=0}^{N-1} \\widetilde{M}\\!\\left(\\frac{\\xi_k + \\xi_{k+1}}{2}\\right) \\cdot \\left(\\xi_{k+1} - \\xi_k\\right),$$\n   其中 $\\{\\xi_k\\}_{k=0}^{N}$ 是沿路径的连续离散化节点。\n5. 令 $\\Delta A_{\\mathrm{exact}} = A(\\xi^{(0)}) - A(\\xi^{(1)})$ 为精确自由能差。对每条路径 $p \\in \\{\\mathrm{S},\\mathrm{L}\\}$，计算绝对误差 $e_p = \\left|\\int_{\\mathcal{C}_p} \\widetilde{M}(\\xi) \\cdot d\\xi - \\Delta A_{\\mathrm{exact}}\\right|$。\n6. 计算绝对路径差异 $d = \\left|\\int_{\\mathcal{C}_{\\mathrm{S}}} \\widetilde{M}(\\xi) \\cdot d\\xi - \\int_{\\mathcal{C}_{\\mathrm{L}}} \\widetilde{M}(\\xi) \\cdot d\\xi\\right|$。\n7. 所有能量以玻尔兹曼常数乘以温度（$k_{\\mathrm{B}}T$）为单位报告，作为无量纲数。每个浮点数输出均四舍五入到六位小数。\n\n您必须实现一个完整的、可运行的程序，对以下测试套件执行上述计算。每个测试用例都指定了解析自由能 $A(\\xi_1,\\xi_2)$、端点、噪声标准差 $\\sigma$ 以及基础随机种子。对于每个测试用例，您的程序必须输出一个列表 $[e_{\\mathrm{S}}, e_{\\mathrm{L}}, d]$。\n\n测试套件：\n- 测试 1（正常路径，零噪声基线）：\n  - $A(\\xi_1,\\xi_2) = \\tfrac{1}{2}\\left(k_1 \\xi_1^2 + k_2 \\xi_2^2\\right) + c \\,\\xi_1 \\xi_2$，其中 $k_1 = 1.0, k_2 = 2.0, c = 0.3$。\n  - $\\xi^{(0)} = (-1.0,-1.0)$，$\\xi^{(1)} = (1.0,1.0)$。\n  - $\\sigma = 0.0$，基础种子 $s = 100$。\n- 测试 2（与测试 1 具有相同的解析 $A$，中等噪声）：\n  - 与测试 1 相同的 $A$ 和端点。\n  - $\\sigma = 0.2$，基础种子 $s = 101$。\n- 测试 3（非线性非谐自由能，小噪声）：\n  - $A(\\xi_1,\\xi_2) = \\tfrac{1}{4}\\xi_1^4 + \\tfrac{1}{4}\\xi_2^4 + \\tfrac{1}{2}\\xi_1^2 - \\xi_1 \\xi_2$。\n  - $\\xi^{(0)} = (-1.0, 0.5)$，$\\xi^{(1)} = (1.5, -0.5)$。\n  - $\\sigma = 0.1$，基础种子 $s = 102$。\n- 测试 4（非线性非谐自由能，更长路径和更高噪声）：\n  - 与测试 3 相同的 $A$。\n  - $\\xi^{(0)} = (-2.0, 2.0)$，$\\xi^{(1)} = (2.0, -2.0)$。\n  - $\\sigma = 0.3$，基础种子 $s = 103$。\n\n角度单位不适用。所有能量必须以 $k_{\\mathrm{B}}T$ 为单位表示为无量纲数。您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表的列表，每个浮点数四舍五入到六位小数，例如：“[[eS1,eL1,d1],[eS2,eL2,d2],[eS3,eL3,d3],[eS4,eL4,d4]]”，不含空格。", "solution": "用户的请求是一个有效的计算问题，它基于统计力学和矢量微积分的原理，特别是在分子动力学中自适应偏置力（ABF）方法的应用。该问题是适定的、科学上合理的，并包含了解决该问题所需的所有必要信息。\n\n核心任务是量化一个含噪矢量场线积分的路径依赖性。在ABF的背景下，作用于一组集体变量 $\\xi$ 上的精确平均力场 $M(\\xi)$ 是保守的，因为它是势（即自由能 $A(\\xi)$）的负梯度，即 $M(\\xi) = -\\nabla A(\\xi)$。因此，该力所做的功（由线积分 $\\int M(\\xi) \\cdot d\\xi$ 表示）与路径无关。然而，任何对平均力的数值估计（记作 $\\widetilde{M}(\\xi)$）都会包含随机噪声，$\\widetilde{M}(\\xi) = M(\\xi) + \\eta(\\xi)$。这个噪声项通常会破坏场的保守性，使得线积分变得与路径相关。本问题要求计算并比较该积分在两条不同路径上的值，并量化由此产生的差异。\n\n以下是解决方案方法论的逐步推导。\n\n### 1. 解析自由能和平均力\n\n问题提供了两个解析自由能面 $A(\\xi_1, \\xi_2)$。平均力 $M(\\xi)$ 是通过对它们取负梯度得到的，即 $M(\\xi) = -\\nabla A(\\xi) = -(\\partial A / \\partial \\xi_1, \\partial A / \\partial \\xi_2)$。\n\n**情况1：二次势（测试1和2）**\n自由能由一个通用的二次型给出：\n$$A(\\xi_1, \\xi_2) = \\frac{1}{2}(k_1 \\xi_1^2 + k_2 \\xi_2^2) + c \\xi_1 \\xi_2$$\n对应的平均力为：\n$$M(\\xi_1, \\xi_2) = -\\nabla A(\\xi_1, \\xi_2) = -\\begin{pmatrix} k_1 \\xi_1 + c \\xi_2 \\\\ k_2 \\xi_2 + c \\xi_1 \\end{pmatrix}$$\n\n**情况2：非谐势（测试3和4）**\n自由能是一个非线性的非谐势：\n$$A(\\xi_1, \\xi_2) = \\frac{1}{4}\\xi_1^4 + \\frac{1}{4}\\xi_2^4 + \\frac{1}{2}\\xi_1^2 - \\xi_1 \\xi_2$$\n对应的平均力为：\n$$M(\\xi_1, \\xi_2) = -\\nabla A(\\xi_1, \\xi_2) = -\\begin{pmatrix} \\xi_1^3 + \\xi_1 - \\xi_2 \\\\ \\xi_2^3 - \\xi_1 \\end{pmatrix}$$\n\n### 2. 路径定义和参数化\n\n对于给定的端点 $\\xi^{(0)}$ 和 $\\xi^{(1)}$，定义了两条不同的路径。\n\n**路径 S（直线）：**\n该路径是端点之间的直接线性插值。它可以通过 $t \\in [0, 1]$ 进行参数化：\n$$\\xi(t) = \\xi^{(0)} + t(\\xi^{(1)} - \\xi^{(0)})$$\n路径微分元为 $d\\xi = (\\xi^{(1)} - \\xi^{(0)}) dt$。\n\n**路径 L（L形）：**\n该路径由两个正交分段组成。\n- **第一段：** 保持 $\\xi_2$ 在 $\\xi_2^{(0)}$ 恒定，沿 $\\xi_1$ 方向从 $\\xi_1^{(0)}$ 移动到 $\\xi_1^{(1)}$。\n- **第二段：** 保持 $\\xi_1$ 在 $\\xi_1^{(1)}$ 恒定，沿 $\\xi_2$ 方向从 $\\xi_2^{(0)}$ 移动到 $\\xi_2^{(1)}$。\n\n### 3. 含噪数值积分\n\n含噪力场 $\\widetilde{M}(\\xi) = M(\\xi) + \\eta$ 的线积分使用复合中点求积法则，以 $N=20000$ 个分段进行计算。沿路径 $\\mathcal{C}$ 的积分近似为：\n$$\\int_{\\mathcal{C}} \\widetilde{M}(\\xi) \\cdot d\\xi \\approx \\sum_{k=0}^{N-1} \\widetilde{M}\\!\\left(\\xi_k^{\\text{mid}}\\right) \\cdot \\Delta\\xi_k$$\n其中 $\\xi_k^{\\text{mid}} = (\\xi_k + \\xi_{k+1})/2$ 是第 $k$ 段的中点，$\\Delta\\xi_k = \\xi_{k+1} - \\xi_k$ 是表示该分段的向量。每个中点处的噪声 $\\eta$ 是从一个零均值、协方差为 $\\sigma^2 I_2$ 的二元正态分布中独立抽取的随机向量，其中 $I_2$ 是 $2 \\times 2$ 的单位矩阵。\n\n**对于路径 S：** 路径被分为 $N$ 个等长分段。第 $k$ 个分段的向量是 $\\Delta\\xi_k = (\\xi^{(1)} - \\xi^{(0)})/N$。\n\n**对于路径 L：** 总分段数 $N$ 根据两段的长度按比例分配。设 $L_1 = |\\xi_1^{(1)} - \\xi_1^{(0)}|$ 和 $L_2 = |\\xi_2^{(1)} - \\xi_2^{(0)}|$。第一段的分段数为 $N_1 = \\text{round}(N \\cdot L_1 / (L_1+L_2))$，第二段的分段数为 $N_2 = N - N_1$。\n- 第一段的积分通过对 $N_1$ 个分段求和来近似：$\\sum_{k=0}^{N_1-1} \\widetilde{M}_{1}(\\xi_{1,k}^{\\text{mid}}, \\xi_2^{(0)}) \\cdot \\Delta\\xi_{1,k}$，其中 $\\Delta\\xi_{1,k} = (\\xi_1^{(1)} - \\xi_1^{(0)})/N_1$。\n- 第二段的积分通过对 $N_2$ 个分段求和来近似：$\\sum_{k=0}^{N_2-1} \\widetilde{M}_{2}(\\xi_1^{(1)}, \\xi_{2,k}^{\\text{mid}}) \\cdot \\Delta\\xi_{2,k}$，其中 $\\Delta\\xi_{2,k} = (\\xi_2^{(1)} - \\xi_2^{(0)})/N_2$。\n路径 L 的总积分是这两段结果的总和。\n\n### 4. 量化误差和差异\n\n计算以下指标以评估噪声的影响：\n\n1.  **精确自由能差：** 积分的真实值与路径无关，为 $\\Delta A_{\\mathrm{exact}} = A(\\xi^{(0)}) - A(\\xi^{(1)})$。\n2.  **绝对误差：** 对于每条路径 $p \\in \\{\\mathrm{S}, \\mathrm{L}\\}$，绝对误差 $e_p$ 衡量数值积分与精确值之间的偏差：\n    $$e_p = \\left| \\int_{\\mathcal{C}_p} \\widetilde{M}(\\xi) \\cdot d\\xi - \\Delta A_{\\mathrm{exact}} \\right|$$\n3.  **绝对路径差异：** 差异 $d$ 衡量沿两条路径计算的积分值之间的差值：\n    $$d = \\left| \\int_{\\mathcal{C}_{\\mathrm{S}}} \\widetilde{M}(\\xi) \\cdot d\\xi - \\int_{\\mathcal{C}_{\\mathrm{L}}} \\widetilde{M}(\\xi) \\cdot d\\xi \\right|$$\n\n此计算过程应用于每个指定的测试用例，在每个测试中为路径 S 和路径 L 使用独立的随机种子，以确保它们的随机误差不相关。每个用例的最终结果 $[e_{\\mathrm{S}}, e_{\\mathrm{L}}, d]$ 都会被报告。对于零噪声情况（$\\sigma=0$），任何非零误差都完全由求积近似引起，考虑到所用 $N$ 值很大，该误差预计会非常小。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes path-dependent discrepancies in line integrals of noisy force fields.\n    \"\"\"\n    N_segments = 20000\n\n    # Define the free energy and mean force functions for the test cases.\n    def A1(xi, k1, k2, c):\n        x, y = xi\n        return 0.5 * (k1 * x**2 + k2 * y**2) + c * x * y\n\n    def M1(xi, k1, k2, c):\n        x, y = xi\n        return -np.array([k1 * x + c * y, k2 * y + c * x])\n\n    def A2(xi):\n        x, y = xi\n        return 0.25 * x**4 + 0.25 * y**4 + 0.5 * x**2 - x * y\n\n    def M2(xi):\n        x, y = xi\n        return -np.array([x**3 + x - y, y**3 - x])\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"A_func\": lambda xi: A1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"M_func\": lambda xi: M1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"xi0\": np.array([-1.0, -1.0]),\n            \"xi1\": np.array([1.0, 1.0]),\n            \"sigma\": 0.0,\n            \"seed_base\": 100,\n        },\n        {\n            \"A_func\": lambda xi: A1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"M_func\": lambda xi: M1(xi, k1=1.0, k2=2.0, c=0.3),\n            \"xi0\": np.array([-1.0, -1.0]),\n            \"xi1\": np.array([1.0, 1.0]),\n            \"sigma\": 0.2,\n            \"seed_base\": 101,\n        },\n        {\n            \"A_func\": A2,\n            \"M_func\": M2,\n            \"xi0\": np.array([-1.0, 0.5]),\n            \"xi1\": np.array([1.5, -0.5]),\n            \"sigma\": 0.1,\n            \"seed_base\": 102,\n        },\n        {\n            \"A_func\": A2,\n            \"M_func\": M2,\n            \"xi0\": np.array([-2.0, 2.0]),\n            \"xi1\": np.array([2.0, -2.0]),\n            \"sigma\": 0.3,\n            \"seed_base\": 103,\n        }\n    ]\n\n    def integrate_path_S(M_func, xi0, xi1, N, sigma, seed):\n        \"\"\"Computes the line integral along a straight path.\"\"\"\n        rng = np.random.default_rng(seed)\n        path_vec = xi1 - xi0\n        segment_vec = path_vec / N\n        total_integral = 0.0\n        \n        for k in range(N):\n            midpoint = xi0 + (k + 0.5) * segment_vec\n            mean_force = M_func(midpoint)\n            noise = rng.normal(loc=0.0, scale=sigma, size=2) if sigma > 0 else np.zeros(2)\n            noisy_force = mean_force + noise\n            total_integral += np.dot(noisy_force, segment_vec)\n            \n        return total_integral\n\n    def integrate_path_L(M_func, xi0, xi1, N, sigma, seed):\n        \"\"\"Computes the line integral along an L-shaped path.\"\"\"\n        rng = np.random.default_rng(seed)\n        total_integral = 0.0\n        \n        # Determine segment distribution\n        L1 = np.abs(xi1[0] - xi0[0])\n        L2 = np.abs(xi1[1] - xi0[1])\n        L_total = L1 + L2\n        \n        if L_total == 0:\n            return 0.0\n            \n        N1 = int(round(N * L1 / L_total))\n        N2 = N - N1\n\n        # Leg 1: along xi_1\n        if N1 > 0:\n            d_xi1 = (xi1[0] - xi0[0]) / N1\n            for k in range(N1):\n                mid_xi1 = xi0[0] + (k + 0.5) * d_xi1\n                midpoint = np.array([mid_xi1, xi0[1]])\n                mean_force = M_func(midpoint)\n                noise = rng.normal(loc=0.0, scale=sigma, size=2) if sigma > 0 else np.zeros(2)\n                noisy_force = mean_force + noise\n                total_integral += noisy_force[0] * d_xi1\n                \n        # Leg 2: along xi_2\n        if N2 > 0:\n            d_xi2 = (xi1[1] - xi0[1]) / N2\n            for k in range(N2):\n                mid_xi2 = xi0[1] + (k + 0.5) * d_xi2\n                midpoint = np.array([xi1[0], mid_xi2])\n                mean_force = M_func(midpoint)\n                noise = rng.normal(loc=0.0, scale=sigma, size=2) if sigma > 0 else np.zeros(2)\n                noisy_force = mean_force + noise\n                total_integral += noisy_force[1] * d_xi2\n\n        return total_integral\n\n    all_results = []\n    for case in test_cases:\n        A_func = case[\"A_func\"]\n        M_func = case[\"M_func\"]\n        xi0 = case[\"xi0\"]\n        xi1 = case[\"xi1\"]\n        sigma = case[\"sigma\"]\n        seed_base = case[\"seed_base\"]\n        \n        delta_A_exact = A_func(xi0) - A_func(xi1)\n        \n        # Path S\n        integral_S = integrate_path_S(M_func, xi0, xi1, N_segments, sigma, seed_base)\n        e_S = abs(integral_S - delta_A_exact)\n        \n        # Path L\n        integral_L = integrate_path_L(M_func, xi0, xi1, N_segments, sigma, seed_base + 1)\n        e_L = abs(integral_L - delta_A_exact)\n        \n        # Discrepancy\n        d = abs(integral_S - integral_L)\n        \n        all_results.append([e_S, e_L, d])\n\n    # Format output\n    formatted_results = []\n    for res_list in all_results:\n        formatted_list_str = \",\".join([f\"{x:.6f}\" for x in res_list])\n        formatted_results.append(f\"[{formatted_list_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3394488"}, {"introduction": "在网格上估算出平均力后，下一个关键步骤是整合该矢量场以重建多维自由能面。这项任务并非易事，数值积分（求积）规则的选择会影响最终结果的准确性和平滑度。本练习将指导您实现并比较几种求积规则，评估它们在理想以及更具挑战性的含噪声和非保守力场下的表现 ([@problem_id:3394473])。", "problem": "要求您实现、分析和比较用于从二维集体变量 (CV) 空间上估算的平均力场重建平均力标量势的数值积分方法。该问题的背景是分子动力学中的自适应偏置力 (ABF) 方法，该方法通过估算平均力势的梯度，然后沿网格上的路径进行积分来重建标量势。本任务要求您编写一个完整、可运行的程序，仅使用此处提供的规范执行以下步骤。程序无需输入；必须在内部定义所有参数，并按指定格式生成单行输出。\n\n定义与设置：\n- 考虑一个二维集体变量空间 (CV) 域 $$\\Omega = [0,1]\\times[0,1].$$\n- 设平均力势为一个足够光滑的标量场 $$A:\\Omega\\to\\mathbb{R},$$ 其梯度（即平均力场）为 $$\\nabla A.$$\n- 在自适应偏置力 (ABF) 方法中，我们构建一个平均力的估计量，其分量表示为 $$\\widehat{A}_{,i}(\\boldsymbol{\\xi})$$，其中 $$i\\in\\{1,2\\},$$ 且 $$\\boldsymbol{\\xi}=(\\xi_{1},\\xi_{2}).$$ 在本问题中，您将使用 $$\\Omega$$ 的三角化网格上的解析定义的代理场来模拟估算的平均力。\n\n网格与三角化：\n- 使用一个均匀网格，每个轴上有 $$n=17$$ 个节点，即坐标为 $$x_{i}=i/(n-1)$$ 和 $$y_{j}=j/(n-1)$$，其中 $$i,j\\in\\{0,1,\\dots,n-1\\}.$$\n- 通过连接每个轴对齐的单位正方形单元 $$[x_{i},x_{i+1}]\\times[y_{j},y_{j+1}]$$ 从 $$(x_{i},y_{j})$$ 到 $$(x_{i+1},y_{j+1})$$ 的对角线来构建一个三角化网格。\n- 定义无向边集 $$E$$，使其包含所有水平边、所有垂直边以及三角化中选定的对角线边。设 $$V$$ 为所有节点的集合。\n\n曲线积分的求积法则：\n- 对于从 $$\\mathbf{r}_{0}=(x_{0},y_{0})$$ 到 $$\\mathbf{r}_{1}=(x_{1},y_{1})$$ 的一条边，通过 $$\\mathbf{r}(t)=\\mathbf{r}_{0}+t(\\mathbf{r}_{1}-\\mathbf{r}_{0}),\\; t\\in[0,1],$$ 对该直线段进行参数化，并设 $$\\mathbf{F}(\\mathbf{r})$$ 表示点 $$\\mathbf{r}$$ 处的估算平均力。沿该边对势差有贡献的曲线积分为\n$$\n\\Delta A = \\int_{0}^{1} \\mathbf{F}(\\mathbf{r}(t))\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})\\,dt.\n$$\n- 实现以下三种求积法则来近似该积分：\n  1. 梯形法则：$$\\Delta A\\approx \\tfrac{1}{2}\\left[\\mathbf{F}(\\mathbf{r}_{0})+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0}).$$\n  2. Simpson 法则：$$\\Delta A\\approx \\tfrac{1}{6}\\left[\\mathbf{F}(\\mathbf{r}_{0})+4\\,\\mathbf{F}\\!\\left(\\tfrac{\\mathbf{r}_{0}+\\mathbf{r}_{1}}{2}\\right)+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0}).$$\n  3. $$[0,1]$$ 上的三点 Gauss–Legendre 法则：节点为 $$t_{1}=\\tfrac{1}{2}-\\tfrac{\\sqrt{15}}{10},\\; t_{2}=\\tfrac{1}{2},\\; t_{3}=\\tfrac{1}{2}+\\tfrac{\\sqrt{15}}{10}$$，权重为 $$w_{1}=\\tfrac{5}{18},\\; w_{2}=\\tfrac{8}{18},\\; w_{3}=\\tfrac{5}{18},$$\n  $$\n  \\Delta A\\approx \\sum_{k=1}^{3} w_{k}\\,\\mathbf{F}(\\mathbf{r}(t_{k}))\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0}).\n  $$\n\n通过图积分进行重建：\n- 选择原点 $$(0,0)$$ 作为参考节点，其参考势可任意设定；为在误差评估中消除该任意常数，请使用下文定义的均值偏移移除方法。\n- 构建网格图的任意一个生成树（例如，通过在节点集为 $$V$$、边集为 $$E$$ 的无向图上进行广度优先搜索）。通过沿从参考节点出发的树路径累加边的曲线积分贡献，来定义所有节点上的重建势 $$\\widehat{A}$$。\n\n准确度与平滑度度量：\n- 对于给定的基准势 $$A$$ 和重建势 $$\\widehat{A},$$ 定义均值偏移为 $$c=\\frac{1}{|V|}\\sum_{\\mathbf{v}\\in V}\\left(\\widehat{A}(\\mathbf{v})-A(\\mathbf{v})\\right).$$\n- 定义均方根误差 (RMSE) 为\n$$\n\\mathrm{RMSE}=\\sqrt{\\frac{1}{|V|}\\sum_{\\mathbf{v}\\in V}\\left(\\widehat{A}(\\mathbf{v})-A(\\mathbf{v})-c\\right)^{2}}.\n$$\n- 定义一个平滑度度量，即均方边差\n$$\nS=\\frac{1}{|E|}\\sum_{(\\mathbf{u},\\mathbf{v})\\in E}\\left(\\widehat{A}(\\mathbf{u})-\\widehat{A}(\\mathbf{v})\\right)^{2}.\n$$\n\n测试套件：\n- 使用以下四个测试用例，每个用例提供一个基准标量势 $$A$$ 和一个估算的平均力场 $$\\mathbf{F}_{\\mathrm{est}}.$$ 在所有用例中，误差都是相对于指定的 $$A$$ 进行评估的。\n  1. 保守场，光滑：\n     - $$A(x,y)=\\sin(2\\pi x)\\sin(2\\pi y).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y).$$\n  2. 保守场，更高频率：\n     - $$A(x,y)=\\sin(6\\pi x)\\sin(6\\pi y).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y).$$\n  3. 带幅度为 $$\\sigma=0.2$$ 的确定性伪噪声的保守场：\n     - $$A(x,y)=\\sin(2\\pi x)\\sin(2\\pi y).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y)+\\boldsymbol{\\eta}(x,y),$$ 其中伪噪声按分量定义为\n       $$\n       \\eta_{1}(x,y)=\\sigma\\left(2\\,\\mathrm{frac}\\!\\left(\\sin(a_{1}x+b_{1}y)\\,c_{1}\\right)-1\\right),\\quad\n       \\eta_{2}(x,y)=\\sigma\\left(2\\,\\mathrm{frac}\\!\\left(\\sin(a_{2}x+b_{2}y)\\,c_{2}\\right)-1\\right),\n       $$\n       常数为 $$a_{1}=12.9898,\\; b_{1}=78.233,\\; c_{1}=43758.5453$$ 和 $$a_{2}=93.9898,\\; b_{2}=67.345,\\; c_{2}=12731.3719,$$ 且 $$\\mathrm{frac}(z)=z-\\lfloor z\\rfloor.$$\n  4. 幅度为 $$\\alpha=0.4$$ 的非保守场（旋转污染）：\n     - $$A(x,y)=\\sin(2\\pi x)\\sin(2\\pi y).$$\n     - 定义一个流函数 $$\\psi(x,y)=\\sin(2\\pi x)\\sin(2\\pi y),$$ 以及一个旋转场 $$\\mathbf{R}(x,y)=\\left(-\\frac{\\partial \\psi}{\\partial y},\\;\\frac{\\partial \\psi}{\\partial x}\\right).$$\n     - $$\\mathbf{F}_{\\mathrm{est}}(x,y)=\\nabla A(x,y)+\\alpha\\,\\mathbf{R}(x,y).$$\n\n任务：\n- 实现三种求积法则来近似边的曲线积分。\n- 从参考节点 $$(0,0)$$ 开始，通过生成树累加方法在所有节点上重建 $$\\widehat{A}$$。\n- 对每个测试用例和每种求积法则，计算序对 $$(\\mathrm{RMSE},S)$$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的扁平浮点数列表。条目必须按测试用例 $$1\\to 4$$ 的顺序排列，在每个测试用例中，按梯形法则、Simpson 法则、Gauss–Legendre 法则的顺序排列求积法则，而在每个法则内，按序对 $$(\\mathrm{RMSE},S)$$ 的顺序排列。具体来说，输出应为\n$$\n[\\mathrm{RMSE}_{1,\\mathrm{trap}},S_{1,\\mathrm{trap}},\\mathrm{RMSE}_{1,\\mathrm{simp}},S_{1,\\mathrm{simp}},\\mathrm{RMSE}_{1,\\mathrm{gl3}},S_{1,\\mathrm{gl3}},\\dots,\\mathrm{RMSE}_{4,\\mathrm{trap}},S_{4,\\mathrm{trap}},\\mathrm{RMSE}_{4,\\mathrm{simp}},S_{4,\\mathrm{simp}},\\mathrm{RMSE}_{4,\\mathrm{gl3}},S_{4,\\mathrm{gl3}}].\n$$\n- 总共有 $$24$$ 个数字。不需要单位；所有量都是无量纲的。三角函数中出现的角度，根据构造，单位是弧度。", "solution": "所提出的问题是一个定义明确的数值任务，其基础是向量微积分和数值分析的原理，并直接应用于计算物理学，特别是在分子动力学模拟中重建平均力势 (PMF)。该问题是自洽的、科学上合理的，并且所有参数和步骤都得到了明确无误的规定。因此，该问题是有效的。\n\n问题的核心是从二维域 $$\\Omega = [0,1]\\times[0,1]$$ 上的梯度，即平均力场 $$\\mathbf{F}(\\boldsymbol{\\xi}) = \\nabla A(\\boldsymbol{\\xi})$$，重建标量势场 $$A(\\boldsymbol{\\xi})$$。势与力之间的关系由曲线积分基本定理给出：两点 $$\\mathbf{r}_0$$ 和 $$\\mathbf{r}_1$$ 之间的势差是力沿着连接它们的任意路径的曲线积分，即 $$\\Delta A = A(\\mathbf{r}_1) - A(\\mathbf{r}_0) = \\int_{\\mathbf{r}_0}^{\\mathbf{r}_1} \\mathbf{F} \\cdot d\\mathbf{r}$$。\n\n该解决方案通过以下步骤以算法方式实现：\n\n1.  **域的离散化**：连续域 $$\\Omega$$ 被离散化为一个由 $$n \\times n$$ 个节点组成的均匀网格，其中 $$n=17$$。节点集合记为 $$V$$。这些节点连接起来形成一个图 $$G=(V, E)$$，其中边集 $$E$$ 由每个网格单元的水平边、垂直边和一条对角线连接组成。这个结构定义了可用于积分的路径。对于索引为 $$(i, j)$$（其中 $$i, j \\in \\{0, 1, \\dots, n-1\\}$$）的节点，其网格坐标为 $$(x_i, y_j) = (i/(n-1), j/(n-1))$$。\n\n2.  **图上的路径积分公式**：为了在每个节点上重建势 $$\\widehat{A}$$，我们必须计算曲线积分。由于对于保守力场，积分是路径无关的，因此从参考节点到目标节点的任何路径都会产生相同的势差。为确保每个节点都有唯一的路径，从而得到一个明确定义的重建势，我们选择图 $$G$$ 的一个生成树。生成树是一个连接所有顶点且不含任何环的子图。在此实现中，我们使用从原点 $$(0,0)$$ 的参考节点开始的广度优先搜索 (BFS) 算法来生成一个生成树。此参考节点的势被设为 $$\\widehat{A}(0,0) = 0$$。然后，通过对从原点到 $$\\mathbf{v}$$ 的生成树中的唯一路径上的势差 $$\\Delta \\widehat{A}$$ 进行求和，来计算任何其他节点 $$\\mathbf{v} \\in V$$ 的势。\n\n3.  **曲线积分的数值求积**：沿着生成树的每条边，从父节点 $$\\mathbf{r}_0$$ 到子节点 $$\\mathbf{r}_1$$ 的曲线积分是进行数值近似的。该问题指定了三种对光滑被积函数精度阶数递增的求积法则：\n    -   **梯形法则**：一种一阶方法，通过在边的端点进行力评估，对被积函数进行线性近似。$$\\Delta A\\approx \\tfrac{1}{2}\\left[\\mathbf{F}(\\mathbf{r}_{0})+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})$$。\n    -   **Simpson 法则**：一种二阶方法，使用二次近似，需要在边的中点额外进行一次力评估。$$\\Delta A\\approx \\tfrac{1}{6}\\left[\\mathbf{F}(\\mathbf{r}_{0})+4\\,\\mathbf{F}\\!\\left(\\tfrac{\\mathbf{r}_{0}+\\mathbf{r}_{1}}{2}\\right)+\\mathbf{F}(\\mathbf{r}_{1})\\right]\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})$$。\n    -   **三点 Gauss-Legendre 法则**：一种更高阶的法则，对最高为 $$5$$ 次的多项式是精确的。它使用沿边上三个特定的、非均匀间隔点的力评估的加权和。$$\\Delta A\\approx \\sum_{k=1}^{3} w_{k}\\,\\mathbf{F}(\\mathbf{r}(t_{k}))\\cdot(\\mathbf{r}_{1}-\\mathbf{r}_{0})$$。\n\n4.  **测试用例分析**：使用四个测试用例来评估这些方法。\n    -   用例 $$1$$ 和 $$2$$ 使用保守力场 ($$\\mathbf{F}_{\\mathrm{est}} = \\nabla A$$)。唯一的误差来源是数值积分。用例 $$2$$ 具有更高的空间频率，这对求积法则构成了更大的挑战，预计会产生更大的误差。\n    -   用例 $$3$$ 在保守场中引入了一个高频、伪随机、非保守的噪声分量 $$\\boldsymbol{\\eta}(x,y)$$。这模拟了 ABF 模拟中的统计噪声。被积函数不再光滑，这对高阶求积法所依赖的多项式可近似性假设提出了挑战，可能会削弱其优势。\n    -   用例 $$4$$ 引入了一个非保守的旋转分量 $$\\mathbf{R}(x,y)$$，其中 $$\\nabla \\times \\mathbf{R} \\neq \\mathbf{0}$$。对于这样的场，曲线积分是路径相关的。因此，重建的势 $$\\widehat{A}$$ 将取决于所选的生成树，并且无法完美地表示该场。这引入了一种与求积误差分离的、根本性的、路径相关的误差。\n\n5.  **评估度量**：每种求积法则在每个测试用例上的性能由两个度量来量化：\n    -   **均方根误差 (RMSE)**：该度量衡量了重建势 $$\\widehat{A}$$ 相对于真实势 $$A$$ 的准确度。在计算 RMSE 之前，通过减去平均差 $$c = \\langle \\widehat{A} - A \\rangle_V$$ 来移除一个物理上无意义的任意势偏移。这确保了比较是基于势面的形状。\n    -   **平滑度度量 ($$S$$)**：定义为完整图 $$E$$ 中所有边上的均方势差，即 $$S = \\langle (\\widehat{A}(\\mathbf{u})-\\widehat{A}(\\mathbf{v}))^2 \\rangle_E$$。由于势差近似于力所做的功，该度量与重建所捕获的力场的均方大小有关。它提供了对重建势景观的“活性”或“粗糙度”的度量。\n\n该程序系统地构建网格和图，生成一个生成树，实现指定的力场和求积法则，并为所有 $$4 \\times 3 = 12$$ 种组合计算 $$\\mathrm{RMSE}$$ 和 $$S$$ 度量，从而产生 $$24$$ 个最终值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import breadth_first_order\n\ndef solve():\n    \"\"\"\n    Main function to solve the numerical quadrature problem for PMF reconstruction.\n    \"\"\"\n    n = 17\n    N_nodes = n * n\n\n    # --- 1. Mesh, Graph, and Spanning Tree Setup ---\n    # Node coordinates\n    x_coords = np.linspace(0.0, 1.0, n)\n    y_coords = np.linspace(0.0, 1.0, n)\n    xv, yv = np.meshgrid(x_coords, y_coords)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    # Adjacency matrix and edge list\n    adj_matrix = np.zeros((N_nodes, N_nodes), dtype=int)\n    edge_set = set()\n\n    def add_edge(u, v):\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n        edge_set.add(tuple(sorted((u, v))))\n\n    for j in range(n):\n        for i in range(n):\n            idx = j * n + i\n            # Horizontal edge\n            if i < n - 1:\n                idx_right = j * n + (i + 1)\n                add_edge(idx, idx_right)\n            # Vertical edge\n            if j < n - 1:\n                idx_down = (j + 1) * n + i\n                add_edge(idx, idx_down)\n            # Diagonal edge\n            if i < n - 1 and j < n - 1:\n                idx_diag = (j + 1) * n + (i + 1)\n                add_edge(idx, idx_diag)\n\n    edges = list(edge_set)\n    graph_csr = csr_matrix(adj_matrix)\n\n    # Spanning tree via BFS\n    start_node = 0\n    bfs_order, predecessors = breadth_first_order(\n        csgraph=graph_csr, i_start=start_node, directed=False, return_predecessors=True\n    )\n\n    # --- 2. Test Case Definitions ---\n    pi = np.pi\n    \n    # Test Case 1\n    def A_true_1(x, y): return np.sin(2 * pi * x) * np.sin(2 * pi * y)\n    def F_est_1(x, y):\n        fx = 2 * pi * np.cos(2 * pi * x) * np.sin(2 * pi * y)\n        fy = 2 * pi * np.sin(2 * pi * x) * np.cos(2 * pi * y)\n        return np.array([fx, fy]).T\n\n    # Test Case 2\n    def A_true_2(x, y): return np.sin(6 * pi * x) * np.sin(6 * pi * y)\n    def F_est_2(x, y):\n        fx = 6 * pi * np.cos(6 * pi * x) * np.sin(6 * pi * y)\n        fy = 6 * pi * np.sin(6 * pi * x) * np.cos(6 * pi * y)\n        return np.array([fx, fy]).T\n\n    # Test Case 3\n    A_true_3 = A_true_1\n    def F_est_3(x, y):\n        F_base = F_est_1(x, y)\n        sigma = 0.2\n        a1, b1, c1 = 12.9898, 78.233, 43758.5453\n        a2, b2, c2 = 93.9898, 67.345, 12731.3719\n        \n        arg1 = np.sin(a1 * x + b1 * y) * c1\n        eta1 = sigma * (2 * (arg1 - np.floor(arg1)) - 1)\n        \n        arg2 = np.sin(a2 * x + b2 * y) * c2\n        eta2 = sigma * (2 * (arg2 - np.floor(arg2)) - 1)\n        \n        noise = np.array([eta1, eta2]).T\n        return F_base + noise\n\n    # Test Case 4\n    A_true_4 = A_true_1\n    def F_est_4(x, y):\n        alpha = 0.4\n        F_grad = F_est_1(x, y)\n        Rx = -2 * pi * np.sin(2 * pi * x) * np.cos(2 * pi * y)\n        Ry = 2 * pi * np.cos(2 * pi * x) * np.sin(2 * pi * y)\n        R = np.array([Rx, Ry]).T\n        return F_grad + alpha * R\n\n    test_cases = [ (A_true_1, F_est_1), (A_true_2, F_est_2), (A_true_3, F_est_3), (A_true_4, F_est_4) ]\n\n    # --- 3. Quadrature Rule Definitions ---\n    # Trapezoid rule\n    def trapezoid_rule(F_func, r0, r1):\n        dr = r1 - r0\n        F0 = F_func(r0[0], r0[1])\n        F1 = F_func(r1[0], r1[1])\n        return 0.5 * np.dot(F0 + F1, dr)\n\n    # Simpson's rule\n    def simpson_rule(F_func, r0, r1):\n        dr = r1 - r0\n        rmid = 0.5 * (r0 + r1)\n        F0 = F_func(r0[0], r0[1])\n        Fmid = F_func(rmid[0], rmid[1])\n        F1 = F_func(r1[0], r1[1])\n        return (1/6) * np.dot(F0 + 4 * Fmid + F1, dr)\n\n    # 3-point Gauss-Legendre rule\n    def gauss_legendre_3pt_rule(F_func, r0, r1):\n        dr = r1 - r0\n        t = np.array([0.5 - np.sqrt(15)/10, 0.5, 0.5 + np.sqrt(15)/10])\n        w = np.array([5/18, 8/18, 5/18])\n        \n        points_x = r0[0] + t * dr[0]\n        points_y = r0[1] + t * dr[1]\n        \n        F_vals = F_func(points_x, points_y)\n        integral = np.dot(w, F_vals)\n        return np.dot(integral, dr)\n\n    quadrature_rules = [\n        (\"trap\", trapezoid_rule),\n        (\"simp\", simpson_rule),\n        (\"gl3\", gauss_legendre_3pt_rule)\n    ]\n    \n    final_results = []\n    \n    # --- 4. Main Calculation Loop ---\n    for A_true_func, F_est_func in test_cases:\n        A_true_values = A_true_func(nodes[:, 0], nodes[:, 1])\n        \n        for quad_name, quad_rule in quadrature_rules:\n            # Reconstruct potential\n            A_hat = np.zeros(N_nodes)\n            for u_idx in bfs_order:\n                if u_idx == start_node:\n                    continue\n                p_idx = predecessors[u_idx]\n                r0 = nodes[p_idx]\n                r1 = nodes[u_idx]\n                delta_A = quad_rule(F_est_func, r0, r1)\n                A_hat[u_idx] = A_hat[p_idx] + delta_A\n\n            # Calculate metrics\n            # RMSE\n            offset = np.mean(A_hat - A_true_values)\n            rmse = np.sqrt(np.mean((A_hat - A_true_values - offset)**2))\n            \n            # Smoothness S\n            squared_diffs = []\n            for u_idx, v_idx in edges:\n                diff = A_hat[u_idx] - A_hat[v_idx]\n                squared_diffs.append(diff**2)\n            s_metric = np.mean(squared_diffs)\n            \n            final_results.extend([rmse, s_metric])\n\n    # --- 5. Final Output ---\n    print(f\"[{','.join(f'{x:.12f}' for x in final_results)}]\")\n\nsolve()\n```", "id": "3394473"}, {"introduction": "如果没有对其不确定性进行稳健的估计，计算出的自由能曲线就是不完整的。这种不确定性主要来自两个方面：有限采样带来的统计误差和集体变量空间离散化引入的系统误差。这个高级练习将指导您通过严谨的推导，应用一个结合了两种误差来源的不确定性估计器，从而为您的模拟结果提供更完整、更可靠的描述 ([@problem_id:3394466])。", "problem": "您正在分析沿无量纲集体变量 $\\xi \\in [0,1]$ 的一维自适应偏置力 (Adaptive Biasing Force, ABF) 自由能计算。平均力势 $A(\\xi)$ 的定义为其导数是平均力的负值，即 $A'(\\xi) = -\\mathcal{F}(\\xi)$，其中 $\\mathcal{F}(\\xi)$ 表示沿 $\\xi$ 的平衡平均广义力。在 ABF 模拟中，$\\xi$ 以间距 $h$ 进行均匀离散，并在网格节点上估计平均力。您希望构建一个 $A(\\xi)$ 不确定度的严格估计量，该估计量既要考虑平均力估计中的抽样误差，也要考虑由有限 $\\xi$ 网格引入的系统离散化误差。您将使用 delta 方法进行计算，并采用 Euler–Maclaurin 求和公式的第一个非零项。\n\n假设使用均匀网格，间距 $h = 0.25$，节点为 $\\xi_j = j h$，$j \\in \\{0,1,2,3,4\\}$。设 $\\widehat{\\mathcal{F}}_j$ 为节点 $\\xi_j$ 处从 $n_j$ 个样本中获得的样本平均力，并假设 $\\widehat{\\mathcal{F}}_j$ 是无偏的，其抽样方差为 $\\sigma_j^2/n_j$，其中 $\\sigma_j^2$ 是节点 $j$ 处瞬时广义力的样本方差。您将通过对平均力应用复合梯形法则来估计自由能差 $A(1) - A(0)$，然后通过对该积分近似值取负，将其转换为 ABF 估计值 $\\widehat{A}(1) - \\widehat{A}(0)$。\n\n可以使用 delta 方法将抽样误差通过平均力估计的线性泛函进行传播，以获得 $\\widehat{A}(1)-\\widehat{A}(0)$ 的近似方差。对于复合梯形法则的系统离散化误差，请使用第一个 Euler–Maclaurin 修正项，该修正项涉及端点导数 $\\mathcal{F}'(1)$ 和 $\\mathcal{F}'(0)$。由于 $\\mathcal{F}'$ 未知，请使用观测到的 $\\widehat{\\mathcal{F}}_j$ 通过单边一阶有限差分来估计 $\\mathcal{F}'(0)$ 和 $\\mathcal{F}'(1)$。将此系统离散化视为一个偏差项，该偏差项以正交相加的方式贡献于定义一个估计的标准不确定度，即估计的均方误差的平方根。\n\n请进行推导，然后使用以下合成数据集（能量单位为千焦/摩尔）验证所得的估计量。五个节点上的 ABF 力估计和抽样统计数据如下：\n- $\\xi_0 = 0$：$\\widehat{\\mathcal{F}}_0 = 0$，$n_0 = 200$，$\\sigma_0^2 = 4.0$，\n- $\\xi_1 = 0.25$：$\\widehat{\\mathcal{F}}_1 = -0.125$，$n_1 = 400$，$\\sigma_1^2 = 1.0$，\n- $\\xi_2 = 0.5$：$\\widehat{\\mathcal{F}}_2 = 0$，$n_2 = 300$，$\\sigma_2^2 = 1.44$，\n- $\\xi_3 = 0.75$：$\\widehat{\\mathcal{F}}_3 = 0.375$，$n_3 = 500$，$\\sigma_3^2 = 2.25$，\n- $\\xi_4 = 1.0$：$\\widehat{\\mathcal{F}}_4 = 1.0$，$n_4 = 200$，$\\sigma_4^2 = 9.0$。\n\n根据定义，$[0,1]$ 上平均力积分的梯形估计值为\n$$\n\\widehat{I}_T = h\\left(\\tfrac{1}{2}\\widehat{\\mathcal{F}}_0 + \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_2 + \\widehat{\\mathcal{F}}_3 + \\tfrac{1}{2}\\widehat{\\mathcal{F}}_4\\right),\n$$\n而 ABF 自由能差估计值为 $\\widehat{A}(1) - \\widehat{A}(0) = -\\widehat{I}_T$。\n\n假设节点之间相互独立，为方差 $\\operatorname{Var}[\\widehat{A}(1) - \\widehat{A}(0)]$ 构建一个 delta 方法估计量。对于 $\\widehat{A}(1) - \\widehat{A}(0)$ 中的系统离散化偏差 $b_A$，请使用复合梯形的第一个 Euler–Maclaurin 修正项，该修正项在主导阶上取决于 $\\mathcal{F}'(1) - \\mathcal{F}'(0)$，并使用端点处的 $\\widehat{\\mathcal{F}}_j$ 的单边一阶有限差分来估计此差值。将方差和偏差的平方合并，构成估计的均方误差，并将估计的 1-sigma 不确定度定义为 $u_A = \\sqrt{\\widehat{\\operatorname{Var}} + \\widehat{b}_A^{\\,2}}$。\n\n根据合成数据集计算 $u_A$，以千焦/摩尔为单位表示您的最终答案，并将答案四舍五入至四位有效数字。", "solution": "在尝试给出解答之前，对用户提供的问题进行了严格审查和验证。\n\n### 第 1 步：提取已知条件\n- **系统**：一维自适应偏置力 (ABF) 计算。\n- **集体变量**：$\\xi \\in [0,1]$。\n- **热力学量**：平均力势 $A(\\xi)$。\n- **定义**：$A'(\\xi) = -\\mathcal{F}(\\xi)$，其中 $\\mathcal{F}(\\xi)$ 是平均广义力。\n- **离散化**：均匀网格，间距 $h = 0.25$，节点为 $\\xi_j = j h$，$j \\in \\{0,1,2,3,4\\}$。\n- **力估计量**：$\\widehat{\\mathcal{F}}_j$ 是在节点 $\\xi_j$ 处从 $n_j$ 个样本获得的样本平均力。\n- **统计特性**：$\\widehat{\\mathcal{F}}_j$ 是无偏的，其 $\\operatorname{Var}[\\widehat{\\mathcal{F}}_j] = \\sigma_j^2/n_j$。不同节点处的估计值 $\\widehat{\\mathcal{F}}_j$ 相互独立。\n- **自由能估计量**：自由能差的估计值，记为 $\\widehat{\\Delta A} = \\widehat{A}(1) - \\widehat{A}(0)$，由平均力的复合梯形法则积分的负值给出：\n$$\n\\widehat{\\Delta A} = -\\widehat{I}_T = -h\\left(\\tfrac{1}{2}\\widehat{\\mathcal{F}}_0 + \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_2 + \\widehat{\\mathcal{F}}_3 + \\tfrac{1}{2}\\widehat{\\mathcal{F}}_4\\right)\n$$\n- **不确定度定义**：总估计不确定度 $u_A$ 是估计的均方误差 (MSE) 的平方根，即抽样方差与系统偏差平方之和：$u_A = \\sqrt{\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] + \\widehat{b}_{\\Delta A}^{\\,2}}$。\n- **偏差估计**：系统离散化偏差 $b_{\\Delta A}$ 将通过第一个 Euler–Maclaurin 修正项 $\\frac{h^2}{12}(\\mathcal{F}'(1) - \\mathcal{F}'(0))$ 进行估计。导数 $\\mathcal{F}'(0)$ 和 $\\mathcal{F}'(1)$ 将使用样本平均力 $\\widehat{\\mathcal{F}}_j$ 的单边一阶有限差分进行估计。\n- **合成数据集**：\n  - $\\xi_0 = 0$：$\\widehat{\\mathcal{F}}_0 = 0$，$n_0 = 200$，$\\sigma_0^2 = 4.0$。\n  - $\\xi_1 = 0.25$：$\\widehat{\\mathcal{F}}_1 = -0.125$，$n_1 = 400$，$\\sigma_1^2 = 1.0$。\n  - $\\xi_2 = 0.5$：$\\widehat{\\mathcal{F}}_2 = 0$，$n_2 = 300$，$\\sigma_2^2 = 1.44$。\n  - $\\xi_3 = 0.75$：$\\widehat{\\mathcal{F}}_3 = 0.375$，$n_3 = 500$，$\\sigma_3^2 = 2.25$。\n  - $\\xi_4 = 1.0$：$\\widehat{\\mathcal{F}}_4 = 1.0$，$n_4 = 200$，$\\sigma_4^2 = 9.0$。\n- **最终输出要求**：计算 $u_A$ 并四舍五入至四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题被评估为**有效**。\n- **科学基础**：该问题植根于统计力学、数值分析和误差理论在分子动力学模拟中的标准实践。平均力势、自适应偏置力、梯形法则积分、Euler-Maclaurin 误差分析以及用于误差传播的 delta 方法等概念都是公认的。将统计（抽样）误差和系统（离散化）误差以正交方式组合成均方误差是计量学中的标准程序。\n- **适定性**：该问题提供了得出唯一数值解所需的所有必要数据和定义。估计方差和偏差的说明是明确且无歧义的。\n- **客观性**：问题陈述不含主观语言，依赖于形式化的数学和统计定义。\n- **完整性与一致性**：所提供的数据和条件是自洽且一致的。不需要外部信息或未声明的假设。\n\n### 第 3 步：结论与行动\n问题有效。将制定一个完整的解决方案。\n\n目标是计算总不确定度 $u_A = \\sqrt{\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] + \\widehat{b}_{\\Delta A}^{\\,2}}$。这需要计算两个部分：抽样方差 $\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}]$ 和系统偏差估计量 $\\widehat{b}_{\\Delta A}$。\n\n**1. 抽样方差的估计, $\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}]$**\n\n自由能差的估计量 $\\widehat{\\Delta A} = \\widehat{A}(1) - \\widehat{A}(0)$ 是随机变量 $\\widehat{\\mathcal{F}}_j$ 的线性组合：\n$$\n\\widehat{\\Delta A} = -h\\left(\\frac{1}{2}\\widehat{\\mathcal{F}}_0 + \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_2 + \\widehat{\\mathcal{F}}_3 + \\frac{1}{2}\\widehat{\\mathcal{F}}_4\\right)\n$$\n由于假设不同节点处的估计值 $\\widehat{\\mathcal{F}}_j$ 相互独立，因此其线性组合的方差是其方差与系数平方的线性组合。这是误差传播规则的直接应用（delta 方法对于线性函数的一种精确形式）。\n$$\n\\operatorname{Var}[\\widehat{\\Delta A}] = \\operatorname{Var}\\left[-h\\left(\\frac{1}{2}\\widehat{\\mathcal{F}}_0 + \\sum_{j=1}^{3}\\widehat{\\mathcal{F}}_j + \\frac{1}{2}\\widehat{\\mathcal{F}}_4\\right)\\right]\n$$\n$$\n\\operatorname{Var}[\\widehat{\\Delta A}] = (-h)^2 \\left( \\left(\\frac{1}{2}\\right)^2\\operatorname{Var}[\\widehat{\\mathcal{F}}_0] + \\sum_{j=1}^{3}\\operatorname{Var}[\\widehat{\\mathcal{F}}_j] + \\left(\\frac{1}{2}\\right)^2\\operatorname{Var}[\\widehat{\\mathcal{F}}_4] \\right)\n$$\n代入给定的抽样方差 $\\operatorname{Var}[\\widehat{\\mathcal{F}}_j] = \\sigma_j^2/n_j$，我们得到方差的估计量，记为 $\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}]$：\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = h^2 \\left( \\frac{\\sigma_0^2}{4n_0} + \\frac{\\sigma_1^2}{n_1} + \\frac{\\sigma_2^2}{n_2} + \\frac{\\sigma_3^2}{n_3} + \\frac{\\sigma_4^2}{4n_4} \\right)\n$$\n使用所提供的数据，其中 $h=0.25$：\n$$\n\\frac{\\sigma_0^2}{n_0} = \\frac{4.0}{200} = 0.02, \\quad \\frac{\\sigma_1^2}{n_1} = \\frac{1.0}{400} = 0.0025, \\quad \\frac{\\sigma_2^2}{n_2} = \\frac{1.44}{300} = 0.0048, \\quad \\frac{\\sigma_3^2}{n_3} = \\frac{2.25}{500} = 0.0045, \\quad \\frac{\\sigma_4^2}{n_4} = \\frac{9.0}{200} = 0.045\n$$\n代入这些值：\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = (0.25)^2 \\left( \\frac{0.02}{4} + 0.0025 + 0.0048 + 0.0045 + \\frac{0.045}{4} \\right)\n$$\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = 0.0625 \\left( 0.005 + 0.0025 + 0.0048 + 0.0045 + 0.01125 \\right)\n$$\n$$\n\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] = 0.0625 \\left( 0.02805 \\right) = 0.001753125\n$$\n\n**2. 系统偏差的估计, $\\widehat{b}_{\\Delta A}$**\n\n真实的自由能差为 $\\Delta A = A(1)-A(0) = -\\int_0^1 \\mathcal{F}(\\xi) d\\xi$。假设力估计是无偏的，我们估计量的期望值为 $E[\\widehat{\\Delta A}] = -I_T$，其中 $I_T$ 是该积分的复合梯形法则近似。偏差为 $b_{\\Delta A} = E[\\widehat{\\Delta A}] - \\Delta A = -I_T - (-\\int_0^1 \\mathcal{F}(\\xi) d\\xi) = \\int_0^1 \\mathcal{F}(\\xi) d\\xi - I_T$。\nEuler-Maclaurin 公式给出了复合梯形法则的主导误差项为 $\\int_a^b f(x)dx - I_T \\approx \\frac{h^2}{12}(f'(b)-f'(a))$。\n将此应用于我们的问题，其中 $f=\\mathcal{F}$, $a=0$, $b=1$：\n$$\nb_{\\Delta A} \\approx \\frac{h^2}{12}(\\mathcal{F}'(1) - \\mathcal{F}'(0))\n$$\n我们使用单边一阶有限差分来估计导数：\n$$\n\\widehat{\\mathcal{F}}'(0) = \\frac{\\widehat{\\mathcal{F}}_1 - \\widehat{\\mathcal{F}}_0}{h}, \\quad \\widehat{\\mathcal{F}}'(1) = \\frac{\\widehat{\\mathcal{F}}_4 - \\widehat{\\mathcal{F}}_3}{h}\n$$\n偏差估计量 $\\widehat{b}_{\\Delta A}$ 则为：\n$$\n\\widehat{b}_{\\Delta A} = \\frac{h^2}{12}(\\widehat{\\mathcal{F}}'(1) - \\widehat{\\mathcal{F}}'(0)) = \\frac{h^2}{12}\\left(\\frac{\\widehat{\\mathcal{F}}_4 - \\widehat{\\mathcal{F}}_3}{h} - \\frac{\\widehat{\\mathcal{F}}_1 - \\widehat{\\mathcal{F}}_0}{h}\\right)\n$$\n$$\n\\widehat{b}_{\\Delta A} = \\frac{h}{12}(\\widehat{\\mathcal{F}}_4 - \\widehat{\\mathcal{F}}_3 - \\widehat{\\mathcal{F}}_1 + \\widehat{\\mathcal{F}}_0)\n$$\n代入数值：\n$$\n\\widehat{b}_{\\Delta A} = \\frac{0.25}{12}(1.0 - 0.375 - (-0.125) + 0) = \\frac{0.25}{12}(1.0 - 0.375 + 0.125)\n$$\n$$\n\\widehat{b}_{\\Delta A} = \\frac{0.25}{12}(0.75) = \\frac{1/4}{12}(3/4) = \\frac{1}{48} \\frac{3}{4} = \\frac{3}{192} = \\frac{1}{64}\n$$\n$$\n\\widehat{b}_{\\Delta A} = 0.015625\n$$\n偏差的平方为 $\\widehat{b}_{\\Delta A}^{\\,2} = (0.015625)^2 = 0.000244140625$。\n\n**3. 总不确定度的计算, $u_A$**\n\n总不确定度是估计的均方误差 (MSE) 的平方根，即抽样方差与偏差平方之和。\n$$\nu_A = \\sqrt{\\widehat{\\operatorname{Var}}[\\widehat{\\Delta A}] + \\widehat{b}_{\\Delta A}^{\\,2}}\n$$\n$$\nu_A = \\sqrt{0.001753125 + 0.000244140625} = \\sqrt{0.001997265625}\n$$\n$$\nu_A \\approx 0.044690778...\n$$\n根据问题要求，四舍五入至四位有效数字：\n$$\nu_A \\approx 0.04469\n$$", "answer": "$$\n\\boxed{0.04469}\n$$", "id": "3394466"}]}