{"hands_on_practices": [{"introduction": "理论模型为并行计算的性能提供了理想化的预测，但实际性能受到硬件和通信开销的限制。本练习将引导您运用强标度伸缩性的核心概念，来分析一个真实的分子动力学模拟场景。通过计算并行效率并识别通信瓶颈，您将学会如何量化并行策略的有效性，这是评估和优化大规模模拟性能的一项基本技能 [@problem_id:3448088]。", "problem": "一个具有周期性边界的稠密 Lennard-Jones 流体的三维分子动力学模拟，使用空间域分解和消息传递接口 (MPI) 的 halo 交换来执行。力计算采用截断半径 $r_c$ 和 Verlet 邻居列表。在分布式内存系统上，针对两种处理器数量 $P=64$ 和 $P=512$ 测量了每个时间步的墙上时钟时间。每个时间步的时间被分解为计算部分 $T_c(P)$（子域内的力和积分工作）和通信部分 $T_m(P)$（halo 交换和集体规约）。假设每个时间步的总时间满足 $T(P)=T_c(P)+T_m(P)$，并忽略输入/输出。\n\n测量到的时间是：\n- 当 $P=64$ 时：$T_c(64)=2.40\\,\\mathrm{ms}$，$T_m(64)=0.35\\,\\mathrm{ms}$。\n- 当 $P=512$ 时：$T_c(512)=0.34\\,\\mathrm{ms}$，$T_m(512)=0.62\\,\\mathrm{ms}$。\n\n从强扩展加速比和效率的基本定义出发，且不引入任何额外的经验模型，推导在 $P=512$ 时相对于基线 $P_0=64$ 的强扩展效率的表达式，该表达式应使用 $T(64)$、$T(512)$、$P$ 和 $P_0$ 来表示。使用上述测量值来数值计算该效率。作为推理的一部分，根据准则 $T_m(P)>T_c(P)$ 判断在 $P=512$ 时通信是否占主导地位，但只报告效率值。\n\n将你的最终答案表示为一个无量纲小数，并四舍五入到四位有效数字。", "solution": "该问题被验证为具有科学依据、提法明确、客观且完整。解决问题所需的所有数据和条件均已提供，不存在矛盾或不成立的前提。该问题是并行计算性能分析中的一个标准练习。\n\n主要任务是推导并计算分子动力学模拟从基线处理器数量 $P_0$ 扩展到更大数量 $P$ 时的强扩展效率。\n\n强扩展分析假设总问题规模（在此情况下，为原子数量和模拟体积）保持不变，而处理器数量增加。\n\n加速比 $S(P)$ 定义为串行执行时间 $T_{serial}$（在单个处理器上）与在 $P$ 个处理器上的并行执行时间 $T(P)$ 之比。\n$$ S(P) = \\frac{T_{serial}}{T(P)} $$\n在许多实际情况中，真正的单处理器串行运行是不可行或不切实际的。取而代之的是，性能是相对于在 $P_0$ 个处理器上的基线运行来测量的。当从 $P_0$ 个处理器增加到 $P$ 个处理器时，相对加速比 $S_{P_0 \\to P}$ 是其执行时间之比：\n$$ S_{P_0 \\to P} = \\frac{T(P_0)}{T(P)} $$\n对于理想或线性扩展，将处理器数量从 $P_0$ 增加到 $P$ 所获得的加速比将等于处理器数量之比，即 $\\frac{P}{P_0}$。\n\n强扩展效率 $E_{P_0 \\to P}$ 是观测到的相对加速比与理想线性加速比之比。这提供了一个衡量额外计算资源被有效利用程度的指标。\n$$ E_{P_0 \\to P} = \\frac{\\text{观测加速比}}{\\text{理想加速比}} = \\frac{S_{P_0 \\to P}}{P/P_0} $$\n代入相对加速比的表达式，我们得到相对强扩展效率的公式：\n$$ E_{P_0 \\to P} = \\frac{T(P_0)/T(P)}{P/P_0} = \\frac{T(P_0) P_0}{T(P) P} $$\n这个效率表达式是根据要求从基本定义推导出来的，并用指定的变量表示。\n\n现在，我们将此公式应用于给定数据。基线和最终处理器数量分别为 $P_0 = 64$ 和 $P = 512$。\n每个时间步的总执行时间 $T(P)$ 是计算时间 $T_c(P)$ 和通信时间 $T_m(P)$ 的总和：\n$$ T(P) = T_c(P) + T_m(P) $$\n使用所提供的测量值：\n对于基线运行 $P_0=64$：\n$$ T(64) = T_c(64) + T_m(64) = 2.40\\,\\mathrm{ms} + 0.35\\,\\mathrm{ms} = 2.75\\,\\mathrm{ms} $$\n对于扩展后的运行 $P=512$：\n$$ T(512) = T_c(512) + T_m(512) = 0.34\\,\\mathrm{ms} + 0.62\\,\\mathrm{ms} = 0.96\\,\\mathrm{ms} $$\n在计算效率之前，我们先解决第二个问题，即在 $P=512$ 时通信是否占主导地位。判断准则是 $T_m(P) > T_c(P)$。\n在 $P=512$ 时，我们有 $T_m(512) = 0.62\\,\\mathrm{ms}$ 和 $T_c(512) = 0.34\\,\\mathrm{ms}$。由于 $0.62\\,\\mathrm{ms} > 0.34\\,\\mathrm{ms}$，条件满足，通信时间确实在此规模下超过了计算时间，占主导地位。这是强扩展中收益递减的常见原因。\n\n我们现在将总时间和处理器数量代入推导出的效率公式：\n$$ E_{64 \\to 512} = \\frac{T(64) \\times 64}{T(512) \\times 512} = \\frac{2.75 \\times 64}{0.96 \\times 512} $$\n时间单位（ms）相互抵消，得到一个无量纲的效率值。\n$$ E_{64 \\to 512} = \\frac{176}{491.52} $$\n进行除法运算：\n$$ E_{64 \\to 512} \\approx 0.3580729166... $$\n问题要求结果四舍五入到四位有效数字。\n$$ E_{64 \\to 512} \\approx 0.3581 $$\n这个值表示，当从 64 个处理器扩展到 512 个处理器时，该并行作业达到了理想线性加速比的大约 $35.81\\%$。", "answer": "$$\\boxed{0.3581}$$", "id": "3448088"}, {"introduction": "在并行模拟中，通信开销通常是限制可扩展性的关键因素。降低通信成本的一个有效方法是优化区域分解的几何形状，其核心原则是最小化子区域的表面积与体积之比。本练习将通过一个假设场景，让您定量比较“板状”分解和“线状”分解两种策略的通信量，从而直观地理解为何更接近立方的子区域划分能显著提升并行计算的效率 [@problem_id:3448083]。", "problem": "考虑一个三维周期性分子动力学系统，其中粒子数密度均匀，短程对力采用球形截断进行计算。设粒子总数为 $N=10^6$，分布在边长为 $L$ 的立方体区域内，力截断半径为 $r_c$。该截断通过带有 halo 交换的空间区域分解来实现。用于粒子-网格操作的网格是均匀的，有 $M_x \\times M_y \\times M_z = 256^3$ 个点，截断半径设为 $r_c = 3h$，其中 $h=L/256$ 是网格间距。\n\n假设在 $P=512$ 个处理器上采用以下两种分解方式：\n1. 板状分解（Slab decomposition）：$P_x=1$, $P_y=1$, $P_z=512$，因此每个子区域的尺寸为 $l_x=L$, $l_y=L$, $l_z=L/512$。\n2. 笔状分解（Pencil decomposition）：$P_x=16$, $P_y=32$, $P_z=1$，因此每个子区域的尺寸为 $l_x=L/16$, $l_y=L/32$, $l_z=L$。\n\n假设一个标准的三阶段 halo 交换协议，该协议保证每个进程能接收到其子区域周围厚度为 $r_c$ 的并集 halo 区域内的所有粒子，因此每个进程的预期通信粒子数等于数密度 $\\rho=N/L^3$ 乘以并集 halo 的体积\n$$\nV_{\\mathrm{halo}}=(l_x+2r_c)(l_y+2r_c)(l_z+2r_c)-l_x l_y l_z.\n$$\n定义总预期通信量为在一个力交换步骤中通过网络发送的总预期粒子数，即对所有进程求和后等于 $P \\rho V_{\\mathrm{halo}}$。\n\n仅使用上述假设和定义，计算板状分解的总预期通信量与笔状分解的总预期通信量之比 $\\mathcal{R}$。将最终答案表示为单个实数，并四舍五入到四位有效数字。", "solution": "用户提供的问题通过了所有验证标准。它在计算分子动力学领域有科学依据，提法明确，包含所有必要信息，并且陈述客观。数据一致且物理上合理。因此，我将提供完整解答。\n\n目标是计算板状分解与笔状分解的总预期通信量之比 $\\mathcal{R}$。总预期通信量 $C$ 定义为 $P \\rho V_{\\mathrm{halo}}$，其中 $P$ 是处理器数量，$\\rho$ 是粒子数密度，$V_{\\mathrm{halo}}$ 是单个处理器子区域的 halo 区域的体积。\n\n设 $C_S$ 和 $V_{\\mathrm{halo}, S}$ 分别为板状分解的总通信量和单个子区域的 halo 体积。\n设 $C_P$ 和 $V_{\\mathrm{halo}, P}$ 分别为笔状分解的总通信量和单个子区域的 halo 体积。\n\n比率 $\\mathcal{R}$ 由下式给出：\n$$\n\\mathcal{R} = \\frac{C_S}{C_P} = \\frac{P \\rho V_{\\mathrm{halo}, S}}{P \\rho V_{\\mathrm{halo}, P}}\n$$\n由于两种情况下处理器数量 $P$ 和密度 $\\rho$ 相同，它们可以消掉，比率简化为：\n$$\n\\mathcal{R} = \\frac{V_{\\mathrm{halo}, S}}{V_{\\mathrm{halo}, P}}\n$$\n问题给出了 halo 体积的公式：\n$$\nV_{\\mathrm{halo}} = (l_x+2r_c)(l_y+2r_c)(l_z+2r_c) - l_x l_y l_z\n$$\n其中 $l_x$、$l_y$ 和 $l_z$ 是子区域的尺寸，$r_c$ 是力截断半径。请注意，本次计算不需要粒子总数 $N=10^6$。\n\n为了方便计算，我们用网格间距 $h$ 来表示所有长度。问题陈述如下：\n- 立方体区域的边长为 $L$。\n- 网格有 $256^3$ 个点，因此网格间距为 $h = L/256$。这意味着 $L = 256h$。\n- 力截断半径为 $r_c = 3h$。\n\n首先，我们分析板状分解。\n处理器排列为 $P_x=1$, $P_y=1$, $P_z=512$。\n板状分解情况（S）下的子区域尺寸为：\n$l_{x,S} = \\frac{L}{P_x} = \\frac{L}{1} = L = 256h$\n$l_{y,S} = \\frac{L}{P_y} = \\frac{L}{1} = L = 256h$\n$l_{z,S} = \\frac{L}{P_z} = \\frac{L}{512} = \\frac{256h}{512} = 0.5h$\n\n现在我们计算 halo 体积 $V_{\\mathrm{halo}, S}$：\n$$\nV_{\\mathrm{halo}, S} = (l_{x,S}+2r_c)(l_{y,S}+2r_c)(l_{z,S}+2r_c) - l_{x,S}l_{y,S}l_{z,S}\n$$\n将尺寸用 $h$ 代入：\n$$\nV_{\\mathrm{halo}, S} = (256h + 2(3h))(256h + 2(3h))(0.5h + 2(3h)) - (256h)(256h)(0.5h)\n$$\n$$\nV_{\\mathrm{halo}, S} = (256h + 6h)(256h + 6h)(0.5h + 6h) - (256 \\times 256 \\times 0.5)h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = (262h)(262h)(6.5h) - (32768)h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = (262^2 \\times 6.5)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = (68644 \\times 6.5)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = 446186h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = 413418h^3\n$$\n\n接下来，我们分析笔状分解。\n处理器排列为 $P_x=16$, $P_y=32$, $P_z=1$。\n笔状分解情况（P）下的子区域尺寸为：\n$l_{x,P} = \\frac{L}{P_x} = \\frac{L}{16} = \\frac{256h}{16} = 16h$\n$l_{y,P} = \\frac{L}{P_y} = \\frac{L}{32} = \\frac{256h}{32} = 8h$\n$l_{z,P} = \\frac{L}{P_z} = \\frac{L}{1} = L = 256h$\n\n现在我们计算 halo 体积 $V_{\\mathrm{halo}, P}$：\n$$\nV_{\\mathrm{halo}, P} = (l_{x,P}+2r_c)(l_{y,P}+2r_c)(l_{z,P}+2r_c) - l_{x,P}l_{y,P}l_{z,P}\n$$\n将尺寸用 $h$ 代入：\n$$\nV_{\\mathrm{halo}, P} = (16h + 2(3h))(8h + 2(3h))(256h + 2(3h)) - (16h)(8h)(256h)\n$$\n$$\nV_{\\mathrm{halo}, P} = (16h + 6h)(8h + 6h)(256h + 6h) - (16 \\times 8 \\times 256)h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = (22h)(14h)(262h) - (32768)h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = (22 \\times 14 \\times 262)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = (308 \\times 262)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = 80696h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = 47928h^3\n$$\n\n最后，我们计算比率 $\\mathcal{R}$：\n$$\n\\mathcal{R} = \\frac{V_{\\mathrm{halo}, S}}{V_{\\mathrm{halo}, P}} = \\frac{413418h^3}{47928h^3} = \\frac{413418}{47928}\n$$\n$$\n\\mathcal{R} \\approx 8.625801201552328\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\mathcal{R} \\approx 8.626\n$$\n这个结果证实了一个计算原理：产生更接近“立方体”形状的子区域（如此处的笔状分解，尺寸为 $16h \\times 8h \\times 256h$）的区域分解方式，在通信量方面比高度各向异性的分解方式（如板状分解，尺寸为 $256h \\times 256h \\times 0.5h$）更有效率，因为它们最小化了子区域的表面积与体积之比。", "answer": "$$\n\\boxed{8.626}\n$$", "id": "3448083"}, {"introduction": "真实世界的模拟系统，如包含相界面的系统，其计算工作量在空间上往往分布不均。在这种情况下，简单的几何分解会导致严重的负载不均衡，从而降低并行效率。本练习要求您为一个包含密集液滴和稀疏气相的非均匀系统，实现一种先进的负载均衡算法——加权递归二分法。通过根据局部粒子密度的平方来估计计算负载，您将学习如何设计一个能适应非均匀工作负载并实现卓越可扩展性的分解策略 [@problem_id:3448085]。", "problem": "一个边长为 $L$（单位为 $\\mathrm{nm}$）的立方模拟盒子中，包含一个半径为 $R$（单位为 $\\mathrm{nm}$）、沿 $x$ 轴以 $x_0$ 位置为中心的致密球形液滴，以及其他地方的稀疏蒸汽。考虑一种短程对相互作用势，根据 Newton 定律以及在固定截断半径下力的局域性，一个分子动力学（MD）步骤的计算功主要由力评估所主导。在连续介质近似中，设局部数密度为 $n(\\mathbf{r})$（单位为 $\\mathrm{nm}^{-3}$），单位体积的局部功密度与 $n(\\mathbf{r})^2$ 成正比，因为在一个小邻域内相互作用的粒子对数量与该邻域内的粒子数的平方成比例。假设一个两相近似，液滴内部的数密度为 $n(\\mathbf{r}) = n_d$，蒸汽中的数密度为 $n(\\mathbf{r}) = n_v$，且 $n_d \\gg n_v$。\n\n为了给 $P$ 个处理器构建沿 $x$ 轴的一维分解，需要通过对沿 $x$ 轴排列的板层上的功密度进行积分来估算每个处理器的功。设盒子是周期性的，并且液滴完全包含在盒子内，满足 $R \\le L/2$，从而使得横截面是明确的。在给定的 $x$ 处，位于液滴内部的横截面积是一个半径为 $\\sqrt{R^2 - (x - x_0)^2}$ 的圆的面积（当 $\\lvert x - x_0 \\rvert \\le R$ 时），否则为零。$y$–$z$ 平面上直到面积为 $L^2$ 的剩余部分是蒸汽。因此，每单位无限小宽度 $\\mathrm{d}x$ 的板层功与 $n_d^2$ 乘以内部面积加上 $n_v^2$ 乘以外部面积成正比。您的目标是使用一种简单的加权递归二分法（WRB）将区间 $[0,L]$ 划分为 $P$ 个连续的子域，使得每个子域中的估计总功相等：按分配给每一侧的处理器数量的比例，递归地将一个区间分割成两个子区间，并将分割点置于累积估计功达到所需比例的 $x$ 位置。\n\n从第一性原理出发，实现以下步骤：\n- 将 $[0,L]$ 离散化为 $N_x$ 个均匀单元，单元边界为 $x_i$，宽度为 $\\Delta x = L/N_x$。通过评估单元中心的横截面积并乘以 $\\Delta x$ 来近似计算单元 $i$ 中的板层功，从而得到一个非负权重 $w_i$。\n- 在离散权重 $w_i$ 和边界 $x_i$ 上实现加权递归二分法以生成域边界。对于一个分配了 $P$ 个处理器的区间，将其分割为 $P_\\ell = \\lfloor P/2 \\rfloor$ 和 $P_r = P - P_\\ell$ 的两部分，将分割位置设置在累积权重等于该区间总权重的 $(P_\\ell/P)$ 的地方。然后分别用 $P_\\ell$ 和 $P_r$ 在每一侧上进行递归。当分割点落在一个单元内部时，在该单元内进行线性插值以确定分割位置，并相应地分配该单元的权重，以使后续的递归操作能够在与分割一致的精确子区间权重上进行。\n- 返回包括 $0$ 和 $L$ 在内的完整域边界列表。\n\n物理单位：所有长度输入和输出必须以 $\\mathrm{nm}$ 为单位。数密度以 $\\mathrm{nm}^{-3}$ 为单位。最终的域边界坐标必须以 $\\mathrm{nm}$ 为单位报告，并四舍五入到6位小数。\n\n测试套件：\n- 案例 $1$（非对称液滴，2的幂次方处理器）：$L = 10.0$, $R = 2.0$, $x_0 = 6.0$, $n_d = 30.0$, $n_v = 1.0$, $N_x = 2000$, $P = 4$。\n- 案例 $2$（非对称液滴，非2的幂次方处理器）：$L = 10.0$, $R = 2.0$, $x_0 = 6.0$, $n_d = 30.0$, $n_v = 1.0$, $N_x = 2000$, $P = 3$。\n- 案例 $3$（无液滴，均匀蒸汽）：$L = 10.0$, $R = 0.0$, $x_0 = 6.0$, $n_d = 30.0, n_v = 1.0$, $N_x = 2000, P = 4$。\n- 案例 $4$（中心液滴，两个处理器）：$L = 10.0$, $R = 2.0, x_0 = 5.0, n_d = 30.0, n_v = 1.0, $N_x = 2000$, $P = 2$。\n\n您的程序应计算每个案例的边界，并生成单行输出，其中包含四个结果，格式为方括号括起来的逗号分隔列表。每个结果本身是从 $0$ 到 $L$ 的边界坐标列表，按升序排列，每个坐标四舍五入到6位小数。例如，包含两个案例的输出应如下所示：$[[0.000000,2.500000,5.000000],[0.000000,5.000000,10.000000]]$；您必须按此格式准确生成一行，并按顺序列出四个案例。", "solution": "用户希望解决一个分子动力学模拟的域分解问题。\n\n### 步骤1：提取已知条件\n- **模拟盒子**：立方体，边长 $L$ (nm)。\n- **系统**：一个半径为 $R$ (nm) 的球形液滴，在x轴上以 $x_0$ 为中心，周围是稀疏的蒸汽。\n- **数密度**：$n(\\mathbf{r}) = n_d$ (液滴, $\\mathrm{nm}^{-3}$)，$n(\\mathbf{r}) = n_v$ (蒸汽, $\\mathrm{nm}^{-3}$)，其中 $n_d \\gg n_v$。\n- **功模型**：局部功密度与 $n(\\mathbf{r})^2$ 成正比。\n- **分解**：沿 $x$ 轴为 $P$ 个处理器进行一维分解。\n- **假设**：盒子是周期性的，且液滴被完全包含（$R \\le L/2$）。\n- **功分布**：在位置 $x$ 处，宽度为 $\\mathrm{d}x$ 的无限小板层中的功与 $W(x) \\mathrm{d}x$ 成正比，其中 $W(x) = (n_d^2 - n_v^2)A_{droplet}(x) + n_v^2 L^2$。\n- **液滴横截面**：当 $|x - x_0| \\le R$ 时，$A_{droplet}(x) = \\pi(R^2 - (x - x_0)^2)$，否则为 $0$。\n- **离散化**：区间 $[0, L]$ 被离散化为 $N_x$ 个宽度为 $\\Delta x = L/N_x$ 的均匀单元。\n- **单元权重**：单元 $i$ 中的功 $w_i$ 通过在单元中心评估功密度并乘以 $\\Delta x$ 来近似。\n- **算法**：加权递归二分法（WRB）。\n  - 一个分配给 $P$ 个处理器的区间被分割为两个，分别用于 $P_\\ell = \\lfloor P/2 \\rfloor$ 和 $P_r = P - P_\\ell$ 个处理器。\n  - 分割点设置在一个位置，使得该点的累积功构成该区间总功的 $P_\\ell/P$ 分数。\n  - 此过程递归应用。\n  - 如果分割点落在一个单元内，则使用线性插值来找到坐标。\n- **输出**：为每个测试案例输出从 $0$ 到 $L$ 的所有域边界的列表，坐标四舍五入到6位小数。\n- **测试案例**：\n  1. $L=10.0, R=2.0, x_0=6.0, n_d=30.0, n_v=1.0, N_x=2000, P=4$。\n  2. $L=10.0, R=2.0, x_0=6.0, n_d=30.0, n_v=1.0, N_x=2000, P=3$。\n  3. $L=10.0, R=0.0, x_0=6.0, n_d=30.0, n_v=1.0, N_x=2000, P=4$。\n  4. $L=10.0, R=2.0, x_0=5.0, n_d=30.0, n_v=1.0, N_x=2000, P=2$。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述的严格评估如下：\n- **科学上合理**：该问题基于计算物理学中一个可靠且广泛使用的近似。短程MD模拟的计算成本与局部粒子密度的平方（$n^2$）成比例的假设是估算负载的标准模型，因为它反映了对相互作用的标度关系。几何和物理学与既定原理一致。\n- **定义明确**：该问题定义良好。输入已指定，物理模型明确，算法（加权递归二分法）也得到了足够详细的描述，包括离散化和插值方法。这种结构确保可以通过算法确定一个唯一且稳定的解。\n- **客观性**：语言精确、量化，没有主观或模糊的术语。\n\n该问题不存在任何无效性缺陷：\n1.  **科学/事实不健全**：不存在违反科学原理的情况。\n2.  **无法形式化/不相关**：该问题是分解策略在分子动力学中的直接且相关的应用。\n3.  **不完整/矛盾的设置**：所有必需的参数都已提供。在所有测试案例中都满足条件 $R \\le L/2$，确保模型是自洽的。\n4.  **不切实际/不可行**：物理参数在纳米级模拟的实际范围内。\n5.  **病态/结构不良**：规定的算法能够导出一组唯一的边界。\n6.  **伪深刻/琐碎**：该问题需要在离散近似的连续域上实现一个非平凡的递归分区算法，代表了一项真正的计算任务。测试案例经过精心选择，用以测试算法的不同方面。\n7.  **超出科学可验证性**：结果是可通过计算验证的。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n---\n\n问题的核心是在空间域 $[0, L]$ 上定义的功分布上实现加权递归二分算法。一种稳健的实现方法是处理由细粒度离散化近似的累积功的连续表示。\n\n**1. 离散化功分布**\n首先，我们将域 $[0,L]$ 离散化为 $N_x$ 个宽度为 $\\Delta x = L/N_x$ 的单元。对于每个单元 $i \\in \\{0, 1, ..., N_x-1\\}$，我们计算其计算权重 $w_i$。该权重与在体积为 $L^2 \\Delta x$ 的相应板层中所做的功成正比。我们通过评估单元中心 $x_{c,i} = (i+0.5)\\Delta x$ 处的功密度来近似这个值。\n\n单位体积的功与 $n(\\mathbf{r})^2$ 成正比。厚度为 $\\mathrm{d}x$ 的板层中的功通过对其横截面积分得到：\n$$ \\mathrm{d}W \\propto [n_d^2 A_{droplet}(x) + n_v^2 (L^2 - A_{droplet}(x))] \\mathrm{d}x $$\n设功分布函数为 $W'(x) = (n_d^2 - n_v^2)A_{droplet}(x) + n_v^2 L^2$，其中当 $|x-x_0| \\le R$ 时，$A_{droplet}(x) = \\pi(R^2 - (x - x_0)^2)$，否则为 $0$。单元 $i$ 的权重则为 $w_i = W'(x_{c,i}) \\Delta x$。\n\n**2. 连续累积功及其反函数**\n根据离散权重 $w_i$，我们可以构建一个近似的连续累积功函数 $C(x)$，表示区间 $[0,x]$ 内的总功。这可以通过对所有完全位于 $x$ 左侧的单元的权重求和，并加上 $x$ 所在单元的按比例权重来完成。\n$$ C(x) \\approx \\sum_{j=0}^{i-1} w_j + w_i \\frac{x - x_i}{\\Delta x}, \\quad \\text{其中 } x \\in [x_i, x_{i+1}] $$\n此处，$x_i = i \\Delta x$ 是单元 $i$ 的左边界。使用预先计算的累积权重数组 $S_i = \\sum_{j=0}^{i} w_j$，可以高效地计算该函数。\n\n反之，我们需要反函数 $C^{-1}(W)$，它给出与给定累积功 $W$ 相对应的坐标 $x$。这可以通过首先确定累积功 $W$ 所在的单元 $i$（即 $S_{i-1} \\le W \\le S_i$），然后在该单元内使用线性插值来找到精确坐标。\n\n**3. 加权递归二分法（WRB）算法**\nWRB 算法通过管理一个任务队列来实现。每个任务是一个元组 `(x_start, x_end, P_current)`，表示一个待在 $P_{current}$ 个处理器之间进行分区的区间 $[x_{start}, x_{end}]$。\n\n该过程从单个任务开始：$(0, L, P)$。对于每个任务：\n- 如果 $P_{current} \\le 1$，则该区间不需要进一步分割。\n- 如果 $P_{current} > 1$，我们计算左右子问题的处理器数量：$P_\\ell = \\lfloor P_{current}/2 \\rfloor$ 和 $P_r = P_{current} - P_\\ell$。\n- 区间 $[x_{start}, x_{end}]$ 必须在坐标 $x_{split}$ 处分割，使得功按 $P_\\ell : P_r$ 的比例分配。左侧区间的功分数为 $f = P_\\ell / P_{current}$。\n- 我们计算当前区间的总功，$W_{interval} = C(x_{end}) - C(x_{start})$。\n- 从原点测量的分割点的目标累积功为 $W_{target} = C(x_{start}) + f \\cdot W_{interval}$。\n- 然后使用累积功的反函数找到分割坐标：$x_{split} = C^{-1}(W_{target})$。\n- 记录这个新的边界 $x_{split}$，并将两个新任务 $(x_{start}, x_{split}, P_\\ell)$ 和 $(x_{split}, x_{end}, P_r)$ 添加到队列中。\n\n此过程一直持续到所有区间都分配给单个处理器。最终结果是唯一的边界坐标的排序列表，并补充 $0$ 和 $L$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\nclass DomainDecomposer:\n    \"\"\"\n    Handles the calculation of domain decomposition boundaries for a given\n    MD system profile using weighted recursive bisection.\n    \"\"\"\n    def __init__(self, L, R, x0, nd, nv, Nx):\n        \"\"\"\n        Initializes the decomposer with system parameters and pre-computes\n        the work profile.\n\n        Args:\n            L (float): Side length of the cubic simulation box.\n            R (float): Radius of the spherical droplet.\n            x0 (float): x-coordinate of the droplet center.\n            nd (float): Number density inside the droplet.\n            nv (float): Number density in the vapor.\n            Nx (int): Number of discretization cells along the x-axis.\n        \"\"\"\n        self.L = float(L)\n        self.R = float(R)\n        self.x0 = float(x0)\n        self.nd = float(nd)\n        self.nv = float(nv)\n        self.Nx = int(Nx)\n        \n        self.dx = self.L / self.Nx if self.Nx > 0 else self.L\n        \n        self._calculate_weights()\n\n    def _calculate_weights(self):\n        \"\"\"\n        Calculates the discrete work weights for each cell and their\n        cumulative sum based on the continuum model.\n        \"\"\"\n        if self.Nx == 0:\n            self.weights = np.array([])\n            self.cumulative_weights = np.array([])\n            self.total_work = 0.0\n            return\n\n        cell_centers = np.linspace(self.dx / 2.0, self.L - self.dx / 2.0, self.Nx)\n        \n        # Calculate work density profile W'(x)\n        nd2_minus_nv2 = self.nd**2 - self.nv**2\n        nv2_L2 = self.nv**2 * self.L**2\n        \n        # Vectorized calculation for droplet cross-sectional area\n        dist_sq = (cell_centers - self.x0)**2\n        A_droplet = np.zeros_like(cell_centers)\n        mask = dist_sq = self.R**2\n        A_droplet[mask] = np.pi * (self.R**2 - dist_sq[mask])\n        \n        work_density_prime = nd2_minus_nv2 * A_droplet + nv2_L2\n        \n        self.weights = work_density_prime * self.dx\n        self.cumulative_weights = np.cumsum(self.weights)\n        self.total_work = self.cumulative_weights[-1] if len(self.cumulative_weights) > 0 else 0.0\n\n    def get_work_from_coord(self, x):\n        \"\"\"Calculates the cumulative work from 0 to coordinate x.\"\"\"\n        if x = 0.0:\n            return 0.0\n        if x >= self.L:\n            return self.total_work\n            \n        # Determine cell index and fraction within the cell\n        idx = int(x / self.dx)\n        if idx >= self.Nx:\n            idx = self.Nx - 1\n            \n        cell_start_coord = idx * self.dx\n        fraction = (x - cell_start_coord) / self.dx\n        \n        work_in_cell_part = self.weights[idx] * fraction\n        \n        prev_cumulative_work = self.cumulative_weights[idx - 1] if idx > 0 else 0.0\n        \n        return prev_cumulative_work + work_in_cell_part\n\n    def get_coord_from_work(self, work):\n        \"\"\"Calculates the coordinate x for a given cumulative work.\"\"\"\n        if work = 0.0:\n            return 0.0\n        if work >= self.total_work:\n            return self.L\n            \n        # Find cell index where cumulative work W is reached\n        idx = np.searchsorted(self.cumulative_weights, work, side='left')\n        \n        prev_cumulative_work = self.cumulative_weights[idx - 1] if idx > 0 else 0.0\n        work_into_cell = work - prev_cumulative_work\n        cell_weight = self.weights[idx]\n        cell_start_coord = idx * self.dx\n        \n        if cell_weight == 0.0:\n            # If target work falls on a boundary before a zero-weight cell region,\n            # place the split at the start of that region.\n            return cell_start_coord\n\n        fraction = work_into_cell / cell_weight\n        \n        return cell_start_coord + fraction * self.dx\n\n    def calculate_boundaries(self, P):\n        \"\"\"\n        Performs weighted recursive bisection to find domain boundaries.\n\n        Args:\n            P (int): The number of processors.\n\n        Returns:\n            list: A sorted list of domain boundaries from 0 to L.\n        \"\"\"\n        if P = 1:\n            return [0.0, self.L]\n\n        boundaries = set()\n        tasks = [(0.0, self.L, P)]  # (x_start, x_end, num_procs)\n\n        while tasks:\n            x_start, x_end, p_curr = tasks.pop(0)\n\n            if p_curr = 1:\n                continue\n\n            p_left = p_curr // 2\n            p_right = p_curr - p_left\n            work_frac = p_left / p_curr\n\n            work_start = self.get_work_from_coord(x_start)\n            work_end = self.get_work_from_coord(x_end)\n            \n            interval_work = work_end - work_start\n\n            if interval_work == 0.0:\n                # Fallback for zero-work intervals: geometric split\n                x_split = x_start + (x_end - x_start) * work_frac\n            else:\n                target_cumulative_work = work_start + interval_work * work_frac\n                x_split = self.get_coord_from_work(target_cumulative_work)\n\n            boundaries.add(x_split)\n\n            tasks.append((x_start, x_split, p_left))\n            tasks.append((x_split, x_end, p_right))\n        \n        final_boundaries = [0.0] + sorted(list(boundaries)) + [self.L]\n        return final_boundaries\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        # L, R, x0, nd, nv, Nx, P\n        (10.0, 2.0, 6.0, 30.0, 1.0, 2000, 4),\n        (10.0, 2.0, 6.0, 30.0, 1.0, 2000, 3),\n        (10.0, 0.0, 6.0, 30.0, 1.0, 2000, 4),\n        (10.0, 2.0, 5.0, 30.0, 1.0, 2000, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, R, x0, nd, nv, Nx, P = case\n        decomposer = DomainDecomposer(L, R, x0, nd, nv, Nx)\n        boundaries = decomposer.calculate_boundaries(P)\n        \n        formatted_boundaries = [f\"{b:.6f}\" for b in boundaries]\n        results.append(f\"[{','.join(formatted_boundaries)}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3448085"}]}