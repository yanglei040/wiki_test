{"hands_on_practices": [{"introduction": "我们从并行分子动力学模拟的基石——空间分解开始。本练习将指导您完成一个基本计算：将模拟盒子划分为单元格网格，这是有效管理邻近粒子相互作用的一项基础技术。通过解决这个问题[@problem_id:3431951]，您将学习如何根据相互作用截断半径确定最佳单元格尺寸，以及这一选择如何影响原子分布——这是实现负载均衡的关键因素。", "problem": "在一个边长为 $L$、具有周期性边界条件的立方体盒子中，对一个数密度均匀的简单流体进行三维分子动力学模拟。为了能够使用单元列表进行高效的并行邻居搜索，该区域被划分成一个由立方单元组成的均匀网格。单元边长 $a$ 的选择必须满足邻居列表安全条件 $a \\geq l_c$，其中列表单元尺寸 $l_c$ 等于用于对相互作用的保守截断半径 $r_c$ 与用于分摊邻居列表重建成本的非键合表皮距离 $\\Delta$ 之和。该实现为每条边选择整数个单元 $n$，使得 $a = L/n \\geq l_c$ 且在该约束下 $n$ 被最大化，单元总数为 $N_{\\text{cell}} = n^3$。每个单元的平均原子数是原子总数除以单元总数。\n\n已知 $r_c = 1.0$ nm，$\\Delta = 0.2$ nm，$\\rho = 33$ nm$^{-3}$，以及一个边长 $L = 20$ nm 的立方体盒子，计算：\n- 网格中的单元总数 $N_{\\text{cell}}$，以及\n- 每个单元的平均原子数。\n\n使用列表单元尺寸 $l_c = r_c + \\Delta$，将数密度 $\\rho$ 视为均匀的，并假设原子总数为 $N = \\rho L^3$。请将单元总数报告为无量纲整数，并将每个单元的平均原子数报告为四舍五入到四位有效数字的无量纲量。", "solution": "经验证，该问题是自洽、一致且科学合理的。它代表了在设置带区域分解的分子动力学模拟时的一个标准流程。我们开始进行求解。\n\n目标是计算两个量：单元总数 $N_{\\text{cell}}$ 和每个单元的平均原子数。\n\n首先，我们确定每条边的最优单元数 $n$。该实现要求单元边长 $a$ 必须满足安全条件 $a \\geq l_c$，其中 $l_c$ 是列表单元尺寸。列表单元尺寸是截断半径 $r_c$ 和非键合表皮距离 $\\Delta$ 的和。已知 $r_c = 1.0$ nm 和 $\\Delta = 0.2$ nm，我们计算 $l_c$：\n$$l_c = r_c + \\Delta = 1.0 \\text{ nm} + 0.2 \\text{ nm} = 1.2 \\text{ nm}$$\n单元边长 $a$ 由总盒子长度 $L$ 和每条边的单元数 $n$ 定义为 $a = L/n$。将此代入安全条件中：\n$$\\frac{L}{n} \\geq l_c$$\n问题指明 $n$ 必须为整数且在此约束下被最大化。我们可以重新整理该不等式以求解 $n$：\n$$n \\leq \\frac{L}{l_c}$$\n使用给定的盒子边长 $L = 20$ nm 和计算出的 $l_c = 1.2$ nm 值：\n$$n \\leq \\frac{20 \\text{ nm}}{1.2 \\text{ nm}} = \\frac{200}{12} = \\frac{50}{3} \\approx 16.667$$\n由于 $n$ 必须是整数，满足此条件的 $n$ 的最大值是 $16.667$ 的向下取整（floor）：\n$$n = \\lfloor 16.667 \\rfloor = 16$$\n既然我们已经确定了每条边的单元数，我们就可以计算三维网格中的单元总数 $N_{\\text{cell}}$。\n$$N_{\\text{cell}} = n^3 = 16^3 = 4096$$\n这是第一个需要计算的量。\n\n第二，我们计算每个单元的平均原子数。该值由原子总数 $N$ 除以单元总数 $N_{\\text{cell}}$ 得出。原子总数由均匀数密度 $\\rho$ 和模拟盒子的体积 $V = L^3$ 决定。已知 $\\rho = 33 \\text{ nm}^{-3}$ 和 $L = 20$ nm：\n$$N = \\rho V = \\rho L^3 = (33 \\text{ nm}^{-3}) \\times (20 \\text{ nm})^3 = 33 \\times 8000 = 264000$$\n因此，每个单元的平均原子数，我们记为 $\\langle N_{\\text{atoms/cell}} \\rangle$，为：\n$$\\langle N_{\\text{atoms/cell}} \\rangle = \\frac{N}{N_{\\text{cell}}} = \\frac{264000}{4096}$$\n执行除法运算得到精确值：\n$$\\langle N_{\\text{atoms/cell}} \\rangle = 64.453125$$\n问题要求将此值报告为四舍五入到 $4$ 位有效数字。前 $4$ 位有效数字是 $6$、$4$、$4$ 和 $5$。第五位有效数字是 $3$，小于 $5$，因此我们向下舍入。\n$$\\langle N_{\\text{atoms/cell}} \\rangle \\approx 64.45$$\n因此，计算出的两个量是 $N_{\\text{cell}} = 4096$，每个单元的平均原子数约为 $64.45$。", "answer": "$$\\boxed{\\begin{pmatrix} 4096  64.45 \\end{pmatrix}}$$", "id": "3431951"}, {"introduction": "一旦模拟区域被划分，模拟的速度就取决于核心力计算的效率。本练习探讨了内存中数据的组织方式——特别是结构数组(AoS)与数组结构(SoA)之间的选择——如何深刻影响现代处理器上的性能[@problem_id:3431984]。通过推导性能模型，您将深入了解SIMD矢量化和内存访问模式等概念，这些对于在并行计算中实现高吞吐量至关重要。", "problem": "考虑一个经典的短程成对分子动力学内核，该内核对每个中心粒子 $i$，使用单指令多数据 (SIMD) 宽度 $w$ 来评估与 $w$ 个邻居 $\\{j_{1},\\dots,j_{w}\\}$ 的成对相互作用。假设以下经过充分测试的性能建模基础：\n\n1. 每次 SIMD 向量迭代的时间是算术项和内存流量项之和，后者与移动的缓存行数量成正比。这与屋顶线式分解一致，其中当算术和数据移动均未完全重叠时，它们对执行时间是加性贡献。\n2. 对于内存，从主导内存层级传输一个缓存行的成本是一个常数 $c_{L}$（单位为周期/行），非单位步长向量加载 (gather) 和非单位步长向量存储 (scatter) 分别增加每行 $c_{g}$ 和 $c_{s}$ 的开销。单位步长加载和存储不产生 gather/scatter 开销。\n3. 缓存行大小为 $B$ 字节。标量值（例如，一个坐标分量）大小为 $a$ 字节。对于结构数组 (AoS) 布局，每个粒子占据一个大小为 $s$ 字节的结构，该结构至少包含三个位置分量和三个力分量。对于数组结构 (SoA) 布局，位置和力存储在单独的数组中，每个分量一个数组（例如，位置的 $x, y, z$ 和力的 $f_{x}, f_{y}, f_{z}$），每个元素占据 $a$ 字节。\n\n假设一个短程邻居列表，使得在一次 SIMD 向量迭代中，$w$ 个邻居索引 $\\{j_{k}\\}$ 在内存中是有效不相关的（向量内无复用），因此：\n- 在 SoA 布局下，加载 $w$ 个邻居位置所触及的缓存行数为 $L_{\\mathrm{SoA},j}^{\\mathrm{load}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil$，存储 $w$ 个邻居力更新所触及的缓存行数为 $L_{\\mathrm{SoA},j}^{\\mathrm{store}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil$。\n- 在 AoS 布局下，加载 $w$ 个邻居位置（作为结构）所触及的缓存行数为 $L_{\\mathrm{AoS},j}^{\\mathrm{load}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil$，存储 $w$ 个邻居力更新所触及的缓存行数为 $L_{\\mathrm{AoS},j}^{\\mathrm{store}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil$。\n\n对于中心粒子 $i$，假设其数据以单位步长访问，因此：\n- 在 SoA 布局下，$i$ 的位置触及 $L_{\\mathrm{SoA},i} = \\left\\lceil \\frac{3 a}{B} \\right\\rceil$ 个缓存行。\n- 在 AoS 布局下，$i$ 的结构触及 $L_{\\mathrm{AoS},i} = \\left\\lceil \\frac{s}{B} \\right\\rceil$ 个缓存行。\n\n设每次成对相互作用的算术成本为 $c_{c}$ 个周期（这包括浮点力评估，但不包括内存成本）。假设没有其他内存流量占主导地位（例如，就本问题而言，邻居索引与位置和力相比可以忽略不计），并且算术和内存成本之间没有重叠。\n\n将吞吐量定义为每个处理器周期完成的成对相互作用的数量。仅使用上述建模假设和定义，推导在 AoS 和 SoA 布局下 SIMD 向量迭代的吞吐量的封闭形式表达式，分别表示为 $T_{\\mathrm{AoS}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s})$ 和 $T_{\\mathrm{SoA}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s})$，均以每次交互/周期为单位。用 $w, B, a, s, c_{c}, c_{L}, c_{g}$ 和 $c_{s}$ 的解析表达式表示你的最终答案。最终表达式中不要包含任何单位。无需进行数值评估。", "solution": "我们从屋顶线式原理开始，即每次 SIMD 向量迭代的时间是算术贡献和数据移动贡献之和。设一次 SIMD 向量迭代处理 $w$ 次成对相互作用，即中心粒子 $i$ 与 $w$ 个邻居 $\\{j_{1},\\dots,j_{w}\\}$ 的相互作用。吞吐量，以每次交互/周期为单位，是完成的交互次数除以该次迭代所花费的总周期数。因此，如果每次迭代的总周期数为 $C_{\\mathrm{iter}}$，则吞吐量为 $T = \\frac{w}{C_{\\mathrm{iter}}}$。\n\n我们现在从第一性原理出发，构建每种内存布局下的 $C_{\\mathrm{iter}}$。\n\n算术成本。根据假设，每次成对相互作用的算术成本为 $c_{c}$ 个周期，且与布局无关。对于每次迭代的 $w$ 对相互作用，算术成本为\n$$\nC_{\\mathrm{comp}} = c_{c} \\, w.\n$$\n\n内存成本模型。在主导内存层级计算时，每次缓存行传输的成本为 $c_{L}$ 个周期，无论其是加载还是存储。此外，非单位步长向量加载 (gather) 会为 gather 触及的每个缓存行产生 $c_{g}$ 的开销，非单位步长向量存储 (scatter) 会为 scatter 触及的每个缓存行产生 $c_{s}$ 的开销。单位步长访问不产生这些 gather/scatter 开销。\n\n短程邻居列表的访问模式特征。在一次 SIMD 向量迭代中，邻居索引 $\\{j_{k}\\}$ 被假定在内存中是不相关的。这意味着，在向量粒度上，从数组 (SoA) 或结构 (AoS) 中提取的 $w$ 个元素跨越了足够多的地址，以至于触及的不同缓存行的数量可以很好地用寻址的总字节数除以缓存行大小 $B$ 再向上取整来近似。\n\n在数组结构 (SoA) 布局下，每个坐标分量存储在元素大小为 $a$ 字节的专用数组中。要加载 $w$ 个邻居的位置，我们必须从 $x、y$ 和 $z$ 数组中分别 gather $w$ 个元素。加载这些数据所触及的缓存行数为\n$$\nL_{\\mathrm{SoA},j}^{\\mathrm{load}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n类似地，要将 $w$ 个邻居的力更新 scatter 到 $f_{x}, f_{y}, f_{z}$ 数组中，所触及的缓存行数为\n$$\nL_{\\mathrm{SoA},j}^{\\mathrm{store}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n对于中心粒子 $i$，其数据以单位步长访问，加载其位置分量所触及的缓存行数为\n$$\nL_{\\mathrm{SoA},i} = \\left\\lceil \\frac{3 a}{B} \\right\\rceil.\n$$\n因为这些是单位步长访问，所以对 $i$ 没有 gather 开销。\n\n在结构数组 (AoS) 布局下，每个粒子占据一个大小为 $s$ 字节的结构，其中至少包含三个位置分量和三个力分量。$w$ 个邻居的位置是通过读取 $w$ 个结构来 gather 的。加载所触及的缓存行数为\n$$\nL_{\\mathrm{AoS},j}^{\\mathrm{load}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil,\n$$\n存储 $w$ 个邻居力更新所触及的缓存行数为\n$$\nL_{\\mathrm{AoS},j}^{\\mathrm{store}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil.\n$$\n对于以单位步长访问的中心粒子 $i$，加载其结构所触及的缓存行数为\n$$\nL_{\\mathrm{AoS},i} = \\left\\lceil \\frac{s}{B} \\right\\rceil.\n$$\n\nSoA 布局下的周期核算。每次迭代移动的缓存行总数（加载加存储）为\n$$\nL_{\\mathrm{SoA}}^{\\mathrm{tot}} = L_{\\mathrm{SoA},j}^{\\mathrm{load}} + L_{\\mathrm{SoA},j}^{\\mathrm{store}} + L_{\\mathrm{SoA},i} = 2 \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil.\n$$\ngather 开销仅适用于邻居的加载，为 $L_{\\mathrm{SoA},j}^{\\mathrm{load}}$ 中触及的每个缓存行增加 $c_{g}$。scatter 开销仅适用于邻居的存储，为 $L_{\\mathrm{SoA},j}^{\\mathrm{store}}$ 中触及的每个缓存行增加 $c_{s}$。对于中心粒子 $i$ 的单位步长加载，没有 gather/scatter 开销。因此，在 SoA 布局下每次迭代的总周期数为\n$$\nC_{\\mathrm{iter}}^{\\mathrm{SoA}} = c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil \\right) \\;+\\; c_{g} \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil \\;+\\; c_{s} \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n为方便起见，我们将邻居的 gather 和 scatter 开销合并：\n$$\nC_{\\mathrm{iter}}^{\\mathrm{SoA}} = c_{c} \\, w \\;+\\; c_{L} \\left( 6 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n因此，SoA 的吞吐量（以每次交互/周期为单位）是\n$$\nT_{\\mathrm{SoA}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s}) \\;=\\; \\frac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 6 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil\\,}.\n$$\n\nAoS 布局下的周期核算。每次迭代移动的缓存行总数（加载加存储）为\n$$\nL_{\\mathrm{AoS}}^{\\mathrm{tot}} = L_{\\mathrm{AoS},j}^{\\mathrm{load}} + L_{\\mathrm{AoS},j}^{\\mathrm{store}} + L_{\\mathrm{AoS},i} = 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil.\n$$\n同上，邻居的加载会产生 gather 开销，邻居的存储会产生 scatter 开销，均按每个缓存行计算。对于单位步长访问的中心粒子 $i$，没有 gather/scatter 开销。因此，在 AoS 布局下每次迭代的总周期数为\n$$\nC_{\\mathrm{iter}}^{\\mathrm{AoS}} = c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil \\right) \\;+\\; c_{g} \\left\\lceil \\frac{w s}{B} \\right\\rceil \\;+\\; c_{s} \\left\\lceil \\frac{w s}{B} \\right\\rceil,\n$$\n或等价地，\n$$\nC_{\\mathrm{iter}}^{\\mathrm{AoS}} = c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\left\\lceil \\frac{w s}{B} \\right\\rceil.\n$$\n因此，AoS 的吞吐量（以每次交互/周期为单位）是\n$$\nT_{\\mathrm{AoS}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s}) \\;=\\; \\frac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\left\\lceil \\frac{w s}{B} \\right\\rceil\\,}.\n$$\n\n这些表达式明确地展示了在所述的短程、不相关邻居的假设下，吞吐量对 SIMD 宽度 $w$、缓存行大小 $B$、标量大小 $a$、结构大小 $s$、算术成本 $c_{c}$、缓存行传输成本 $c_{L}$ 以及 gather/scatter 开销 $c_{g}$ 和 $c_{s}$ 的依赖关系。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\dfrac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\dfrac{w s}{B} \\right\\rceil + \\left\\lceil \\dfrac{s}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\left\\lceil \\dfrac{w s}{B} \\right\\rceil\\,} \n\\dfrac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 6 \\left\\lceil \\dfrac{w a}{B} \\right\\rceil + \\left\\lceil \\dfrac{3 a}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\cdot 3 \\left\\lceil \\dfrac{w a}{B} \\right\\rceil\\,}\n\\end{pmatrix}\n}\n$$", "id": "3431984"}, {"introduction": "如果粒子密度发生波动，静态的区域分解可能会变得低效，导致一些处理器空闲而另一些处理器过载。这个问题引入了一种通过“工作窃取”算法实现的动态负载均衡，这是一种在非均匀系统中提高并行效率的强大技术[@problem_id:3431949]。通过模拟这一调度策略，您将探索计算负载、通信延迟和整体模拟速度之间的权衡，甚至思考其对数值可重复性的影响。", "problem": "考虑一个经典的分子动力学 (MD) 短程力计算，其空间域被分解为 $P$ 个子域，每个工作单元一个。每个子域 $i \\in \\{0,1,\\dots,P-1\\}$ 持有 $W_i$ 个等成本的交互区块。处理单个区块的确定性成本为 $t_u$ 微秒（每区块时间）。工作单元并发执行，并遵循一种本地优先的工作窃取 (WS) 策略，以减轻空洞（空或稀疏的子域）的影响。WS 策略每次窃取使用固定大小为 $c$ 个区块的块，并且每次成功窃取会产生 $\\ell_s$ 微秒的窃取延迟。\n\n调度器定义如下。\n- 所有工作单元在时间 $0$ 开始，并在连续时间内执行。每个工作单元 $i$ 都有一个包含 $W_i$ 个区块的初始本地队列。\n- 仍有本地区块的工作单元总是优先处理一个本地块。一个大小为 $q$（其中 $q = \\min(c,\\text{local remaining})$）的块需要 $q \\cdot t_u$ 微秒来完成，没有额外开销。\n- 当一个工作单元的本地队列为空时，它会尝试从一个受害子域窃取。该受害子域被选为所有子域中剩余区块数量最多的那个（若数量相同，则选择子域索引最小的）。如果受害者剩余 $r$ 个区块，窃取者会窃取一个大小为 $q = \\min(c,r)$ 的块。在处理该块之前，窃取者需要支付 $\\ell_s$ 微秒的延迟。该被窃取块的处理时间在延迟之后为 $q \\cdot t_u$ 微秒。当窃取决定做出时，受害者的剩余区块数立即减少 $q$。如果整个系统中没有剩余区块，该工作单元将永久进入空闲状态。\n- 所有块的执行（本地和被窃取的）都是非抢占式的。全局执行将持续到所有区块都被处理完毕。\n\n定义性能度量为 WS 下的并行完成时间，记为 $T_{\\text{steal}}$，即最后一个块完成的时间。定义无窃取时的静态基线完成时间为 $T_{\\text{base}} = \\max_{i} \\left(W_i \\cdot t_u\\right)$，其中每个工作单元只处理自己子域的区块，没有窃取也无额外开销。定义加速比为 $S = T_{\\text{base}} / T_{\\text{steal}}$（无量纲）。定义可复现性暴露度量为 $R$，即被窃取者（而非其所属子域的原始工作单元）处理的区块所占的比例，即 $R = (\\text{total stolen tiles})/\\left(\\sum_{i=0}^{P-1} W_i\\right)$，以小数形式表示（无百分号）。\n\n你的任务是严格按照规定实现上述调度器，并为每个测试用例计算元组 $\\left(T_{\\text{steal}}, S, R\\right)$。时间 $T_{\\text{steal}}$ 必须以微秒表示，为整数微秒。加速比 $S$ 和可复现性暴露度 $R$ 必须作为十进制浮点值返回。\n\n你可以假设的基本原则：\n- 完成时间定义为所有并发工作单元中的最大完成时间。\n- 顺序块处理时间是可加的：一个大小为 $q$ 的区块需要 $q \\cdot t_u$ 微秒，窃取操作在块的计算时间开始前会增加一个固定的延迟 $\\ell_s$。\n- 通过最低索引进行确定性平局打破，以确保调度是明确定义的。\n\n测试套件。对于每个案例，使用 $P=4$ 个工作单元（每个子域一个），参数如下，所有时间单位为微秒：\n- 案例 1：$W=[800,50,0,50]$, $c=20$, $\\ell_s=40$, $t_u=1$。\n- 案例 2：$W=[200,200,200,200]$, $c=50$, $\\ell_s=5$, $t_u=1$。\n- 案例 3：$W=[0,0,0,1000]$, $c=10$, $\\ell_s=100$, $t_u=1$。\n- 案例 4：$W=[300,10,10,10]$, $c=64$, $\\ell_s=30$, $t_u=1$。\n- 案例 5：$W=[101,0,101,0]$, $c=1$, $\\ell_s=1$, $t_u=1$。\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含所有结果，平铺成一个逗号分隔的列表，并用方括号括起来。每个案例的结果必须按 $\\left[T_{\\text{steal}}, S, R\\right]$ 三元组的顺序追加，最终形成一个扁平列表，顺序为\n$[T_{\\text{steal}}^{(1)}, S^{(1)}, R^{(1)}, T_{\\text{steal}}^{(2)}, S^{(2)}, R^{(2)}, \\dots, T_{\\text{steal}}^{(5)}, S^{(5)}, R^{(5)}]$，\n其中 $T_{\\text{steal}}^{(k)}$ 是一个整数（微秒），$S^{(k)}$ 和 $R^{(k)}$ 是十进制浮点值。请用微秒表示 $T_{\\text{steal}}$，用小数表示 $S$ 和 $R$（无百分号），不要包含任何额外文本。", "solution": "该问题要求模拟一个并行工作窃取调度器，以确定其性能特征。该系统由 $P$ 个工作单元组成，每个工作单元都有一个包含 $W_i$ 个工作区块的初始队列。调度策略是确定性的，使其适合进行精确模拟。这是一个定义明确的离散事件模拟任务。\n\n该解决方案被设计为一个离散事件模拟，这是对在异步、离散时间点演化的系统进行建模的标准方法。此模拟的核心组件是系统状态、事件和事件驱动的控制循环。\n\n1.  **系统状态**：模拟的全局状态主要由每个子域队列中剩余的未处理区块数量定义。这由一个大小为 $P$ 的数组 `rem_tiles` 表示，并用工作负载分布 $W$ 进行初始化。其他状态变量跟踪被窃取的总区块数 (`total_stolen_tiles`) 和模拟的完成时间。\n\n2.  **事件**：“事件”被定义为一个工作单元完成其当前工作块并可用于新任务。每个事件由一个元组 $(t, i)$ 来表征，表示工作单元 $i$ 在时间 $t$ 变为空闲。\n\n3.  **事件队列与模拟循环**：一个按事件时间 $t$ 排序的优先队列管理事件序列。模拟开始时，通过在时间 $t=0$ 为所有 $P$ 个工作单元填充初始事件来初始化队列。主循环重复地从队列中提取时间最小的事件，将模拟的 `current_time` 推进到该事件的时间，并处理该事件。\n\n4.  **事件处理逻辑**：当一个工作单元 $i$ 在 `current_time` 变为空闲时，根据指定的策略为其分配一个新任务：\n    a. **本地工作**：工作单元首先检查自己的区块队列 `rem_tiles[i]`。如果 `rem_tiles[i] > 0`，它会处理一个大小为 $q = \\min(c, \\text{rem\\_tiles}[i])$ 的本地块。该任务需要 $q \\cdot t_u$ 微秒。一个对应于完成时间 `current_time` + $q \\cdot t_u$ 的新事件将被添加到该工作单元的优先队列中。\n    \n    b. **工作窃取**：如果本地队列为空 (`rem_tiles[i] == 0`)，工作单元尝试窃取。它将剩余区块数量最多的子域确定为受害子域 $v$。平局通过选择索引最小的子域来打破，以确保确定性。如果找到了一个有非零区块的受害者，工作单元将窃取一个大小为 $q = \\min(c, \\text{rem\\_tiles}[v])$ 的块。受害者队列的状态 `rem_tiles[v]` 将立即递减。窃取者支付一个延迟成本 $\\ell_s$。这个被窃取任务的完成时间是 `current_time` + $\\ell_s$ + $q \\cdot t_u$。一个相应的完成事件被入队。\n    \n    c. **空闲**：如果一个工作单元的本地队列为空，并且系统中任何地方都没有剩余区块，该工作单元将永久进入空闲状态，并且不会被重新插入到事件队列中。\n\n5.  **终止与度量计算**：当事件队列变空时，模拟终止，这发生在所有区块被处理完毕且所有工作单元都变为空闲之后。工作窃取下的完成时间 $T_{\\text{steal}}$ 是所有任务中记录的最大完成时间。基线完成时间 $T_{\\text{base}}$ 计算为 $\\max_i(W_i \\cdot t_u)$。加速比 $S$ 是比率 $T_{\\text{base}} / T_{\\text{steal}}$，而可复现性暴露度 $R$ 是被窃取的总区块数与初始总区块数的比率。所有时间计算均按规定使用整数算术。\n\n这个模拟模型忠实地实现了调度器的确定性规则，从而可以为每个测试用例精确计算所需的性能度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef run_simulation(P, W, c, l_s, t_u):\n    \"\"\"\n    Runs the discrete-event simulation for one test case to compute\n    makespan, speedup, and reproducibility exposure.\n    \n    Args:\n        P (int): Number of workers/subdomains.\n        W (list): Initial workload (number of tiles) for each subdomain.\n        c (int): Chunk size for processing and stealing.\n        l_s (int): Latency for a successful steal in microseconds.\n        t_u (int): Time to process a single tile in microseconds.\n        \n    Returns:\n        tuple: A tuple containing (T_steal, S, R).\n    \"\"\"\n    # Initialize state variables\n    rem_tiles = list(W)\n    total_initial_tiles = sum(W)\n    \n    # Handle the edge case of no work.\n    if total_initial_tiles == 0:\n        return (0, 1.0, 0.0)\n\n    total_stolen_tiles = 0\n    \n    # The event queue stores (finish_time, worker_id) tuples.\n    # heapq implements a min-priority queue perfectly suited for this.\n    # Python's tuple comparison breaks ties on finish_time by worker_id,\n    # ensuring deterministic processing of simultaneous events.\n    event_queue = []\n    for i in range(P):\n        heapq.heappush(event_queue, (0, i))\n\n    makespan = 0\n\n    # The simulation loop continues as long as there are workers with\n    # pending tasks in the event queue.\n    while event_queue:\n        # Dequeue the event with the earliest finish time.\n        current_time, worker_id = heapq.heappop(event_queue)\n\n        # Assign a new task to the now-available worker.\n\n        # PRIORITY 1: Process local work if available.\n        if rem_tiles[worker_id] > 0:\n            # Determine local chunk size.\n            q = min(c, rem_tiles[worker_id])\n            rem_tiles[worker_id] -= q\n            \n            # Calculate task duration and the worker's next finish time.\n            duration = q * t_u\n            finish_time = current_time + duration\n            makespan = max(makespan, finish_time)\n            \n            # Add the worker's next availability event to the queue.\n            heapq.heappush(event_queue, (finish_time, worker_id))\n\n        # PRIORITY 2: Attempt to steal work if local queue is empty.\n        else:\n            # Find a victim based on the specified policy: the subdomain with\n            # the largest number of tiles, with ties broken by smallest index.\n            max_tiles = -1\n            victim_idx = -1\n            for j in range(P):\n                if rem_tiles[j] > max_tiles:\n                    max_tiles = rem_tiles[j]\n                    victim_idx = j\n            \n            # If a victim with work is found, perform the steal.\n            if victim_idx != -1 and max_tiles > 0:\n                # Determine stolen chunk size.\n                q = min(c, rem_tiles[victim_idx])\n                \n                # Atomically update victim's tile count and total stolen count.\n                rem_tiles[victim_idx] -= q\n                total_stolen_tiles += q\n                \n                # Calculate task duration (including latency) and finish time.\n                duration = l_s + q * t_u\n                finish_time = current_time + duration\n                makespan = max(makespan, finish_time)\n                \n                # Add the thief's next availability event to the queue.\n                heapq.heappush(event_queue, (finish_time, worker_id))\n            # If no work is left anywhere, the worker becomes idle and is not\n            # pushed back onto the event queue, naturally ending its work life.\n\n    # Post-simulation metric calculations.\n    T_steal = int(makespan)\n    \n    T_base = max(W) * t_u if W else 0\n    \n    # S = T_base / T_steal\n    S = T_base / T_steal if T_steal > 0 else 1.0\n    \n    # R = (total stolen tiles) / (total initial tiles)\n    R = total_stolen_tiles / total_initial_tiles\n\n    return (T_steal, S, R)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (W, c, l_s, t_u)\n        ([800, 50, 0, 50], 20, 40, 1),\n        ([200, 200, 200, 200], 50, 5, 1),\n        ([0, 0, 0, 1000], 10, 100, 1),\n        ([300, 10, 10, 10], 64, 30, 1),\n        ([101, 0, 101, 0], 1, 1, 1),\n    ]\n\n    P = 4 # Number of workers is fixed for all test cases.\n    \n    all_results = []\n    for case_params in test_cases:\n        W, c, l_s, t_u = case_params\n        # Run the simulation for the current case.\n        result_tuple = run_simulation(P, W, c, l_s, t_u)\n        # Append the flattened results to the final list.\n        all_results.extend(result_tuple)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3431949"}]}