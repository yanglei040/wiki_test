{"hands_on_practices": [{"introduction": "## 从生成函数到辛映射\n\n一个保持哈密顿方程形式的变换被称为正则变换，它天然是辛的。生成函数是构建此类变换的经典工具。本练习 [@problem_id:3456299] 将指导您从一个二次生成函数出发，推导出一个具体的线性辛映射，从而加深对哈密顿力学和几何积分之间基本联系的理解。", "problem": "考虑一个用于分子动力学 (MD) 的单自由度哈密顿系统，其中离散时间更新是通过保持辛二形式的正则变换来构造的。一个第二类生成函数 $F_2(q,P)$ 通过哈密顿力学的基本关系式定义了一个从旧变量 $(q,p)$ 到新变量 $(Q,P)$ 的正则映射，\n$$\np = \\frac{\\partial F_2}{\\partial q}, \\qquad Q = \\frac{\\partial F_2}{\\partial P}.\n$$\n假设在一个时间步长上的离散更新由二次第二类生成函数定义\n$$\nF_2(q,P) = \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2,\n$$\n其中 $(a,b,c)$ 为实数参数且 $b \\neq 0$。仅从上述定义出发，推导显式的正则映射 $(q,p) \\mapsto (Q,P)$ 并计算其雅可比行列式。利用单自由度下辛性的特征，阐述确保该映射为辛映射时参数 $(a,b,c)$ 需满足的条件。将您的最终答案表示为关于 $(q,p)$ 的 $Q$ 和 $P$ 的线性公式对，以及该映射的雅可比矩阵行列式的值。无需四舍五入。", "solution": "该问题要求从一个给定的第二类生成函数推导正则映射，计算其雅可比行列式，并找出使该映射成为辛映射的条件。\n\n给定的第二类生成函数是\n$$\nF_2(q, P) = \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2\n$$\n其中 $(q,p)$ 是旧的正则坐标，$(Q,P)$ 是新的正则坐标。参数 $a$，$b$ 和 $c$ 是实常数，并有约束条件 $b \\neq 0$。\n\n正则变换由以下关系式定义：\n$$\np = \\frac{\\partial F_2}{\\partial q} \\quad \\text{and} \\quad Q = \\frac{\\partial F_2}{\\partial P}.\n$$\n\n首先，我们通过计算 $F_2(q,P)$ 的偏导数来推导显式的变换方程。\n关于 $q$ 的导数给出旧动量 $p$：\n$$\np = \\frac{\\partial}{\\partial q} \\left( \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2 \\right) = a q + b P.\n$$\n关于新动量 $P$ 的导数给出新坐标 $Q$：\n$$\nQ = \\frac{\\partial}{\\partial P} \\left( \\frac{1}{2} a q^2 + b q P + \\frac{1}{2} c P^2 \\right) = b q + c P.\n$$\n现在我们得到了一个联系新旧变量的两个线性方程组：\n1. $p = a q + b P$\n2. $Q = b q + c P$\n\n为了找到显式映射 $(q,p) \\mapsto (Q,P)$，我们必须用 $q$ 和 $p$ 来表示 $Q$ 和 $P$。从方程(1)中，我们可以解出 $P$。条件 $b \\neq 0$ 在这里至关重要，因为它允许我们对该关系进行逆运算：\n$$\nb P = p - a q \\implies P = \\frac{1}{b} p - \\frac{a}{b} q.\n$$\n现在，我们将 $P$ 的这个表达式代入方程(2)来求 $Q$：\n$$\nQ = b q + c \\left( \\frac{1}{b} p - \\frac{a}{b} q \\right) = b q + \\frac{c}{b} p - \\frac{ac}{b} q.\n$$\n合并含 $q$ 的项，我们得到：\n$$\nQ = \\left( b - \\frac{ac}{b} \\right) q + \\frac{c}{b} p = \\frac{b^2 - ac}{b} q + \\frac{c}{b} p.\n$$\n因此，显式的正则映射由以下线性方程对给出：\n$$\nQ = \\frac{b^2 - ac}{b} q + \\frac{c}{b} p\n$$\n$$\nP = -\\frac{a}{b} q + \\frac{1}{b} p\n$$\n\n接下来，我们计算这个变换的雅可比行列式。该变换可以写成矩阵形式 $\\vec{Z} = M \\vec{z}$，其中 $\\vec{z} = \\begin{pmatrix} q \\\\ p \\end{pmatrix}$ 且 $\\vec{Z} = \\begin{pmatrix} Q \\\\ P \\end{pmatrix}$。矩阵 $M$ 是该映射的雅可比矩阵，$M = \\frac{\\partial(Q,P)}{\\partial(q,p)}$：\n$$\nM = \\begin{pmatrix} \\frac{\\partial Q}{\\partial q} & \\frac{\\partial Q}{\\partial p} \\\\ \\frac{\\partial P}{\\partial q} & \\frac{\\partial P}{\\partial p} \\end{pmatrix} = \\begin{pmatrix} \\frac{b^2 - ac}{b} & \\frac{c}{b} \\\\ -\\frac{a}{b} & \\frac{1}{b} \\end{pmatrix}.\n$$\n雅可比矩阵的行列式为：\n$$\n\\det(M) = \\left( \\frac{b^2 - ac}{b} \\right) \\left( \\frac{1}{b} \\right) - \\left( \\frac{c}{b} \\right) \\left( -\\frac{a}{b} \\right)\n$$\n$$\n\\det(M) = \\frac{b^2 - ac}{b^2} - \\left( -\\frac{ac}{b^2} \\right) = \\frac{b^2 - ac + ac}{b^2} = \\frac{b^2}{b^2} = 1.\n$$\n该映射的雅可比行列式恰好为 $1$。\n\n最后，我们讨论使该映射成为辛映射的条件。一个变换是正则的，如果它保持哈密顿方程的结构。对于一个单自由度系统，线性映射 $\\vec{Z} = M \\vec{z}$ 是辛映射，当且仅当其雅可比矩阵 $M$ 满足 $M^T J M = J$，其中 $J = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$ 是标准辛矩阵。对于一个 $2 \\times 2$ 矩阵，这个条件等价于要求其行列式等于 $1$。\n正如我们刚刚计算的，从生成函数 $F_2(q,P)$ 推导出的映射的雅可比行列式为 $\\det(M) = 1$。只要该映射是良定义的，这个结果对任何实数参数 $a$，$b$ 和 $c$ 都成立。该映射是良定义的，当且仅当我们能唯一地用 $(q,p)$ 解出 $(Q,P)$，这要求 $b \\neq 0$。\n因此，只要满足初始条件 $b \\neq 0$，该变换对于任何参数 $(a,b,c)$ 的选择都是辛的。这是一个普遍性质：任何从非退化生成函数导出的变换，根据其构造，都是正则变换，因此也是辛变换。行列式的计算证实了这一原理。对参数 $(a,b,c)$ 的唯一条件是使该映射良定义所必需的条件，即 $b \\neq 0$。\n\n题目要求将 $Q$ 和 $P$ 的线性公式对以及雅可比行列式的值作为最终答案。\n这些公式是：\n$Q(q,p) = \\frac{b^2 - ac}{b} q + \\frac{c}{b} p$\n$P(q,p) = -\\frac{a}{b} q + \\frac{1}{b} p$\n行列式为 $1$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{b^2-ac}{b}q + \\frac{c}{b}p & -\\frac{a}{b}q + \\frac{1}{b}p & 1 \\end{pmatrix}}\n$$", "id": "3456299"}, {"introduction": "## 时间可逆性的惊人精度\n\n对称（或时间可逆）积分方法具有一个非凡的特性：在没有数值溢出或下溢的情况下，前向积分过程中累积的浮点误差可以在轨迹逆转时被精确地抵消。在本练习 [@problem_id:3456282] 中，您将实现一个测试来验证这一精确到比特位的现象。这将直观地展示这些算法的独特之处，并将其与非可逆方法形成鲜明对比。", "problem": "考虑一个分子动力学系统，其构型坐标为 $q \\in \\mathbb{R}^{n}$，共轭动量为 $p \\in \\mathbb{R}^{n}$，质量参数为 $m \\in \\mathbb{R}^{n}$（其分量严格为正），势能为 $V(q)$。运动方程源于牛顿第二定律和哈密顿力学，其哈密顿量为 $H(q,p) = \\sum_{i=1}^{n} \\frac{p_i^2}{2m_i} + V(q)$，演化由 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$ 确定。定义时间反演算符 $\\mathcal{R}$，其作用为 $\\mathcal{R}(q,p) = (q,-p)$。一个具有步进映射 $\\Phi_{\\Delta t}$ 的积分器是时间可逆的，如果它满足 $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$。辛积分器保持从哈密顿流继承的辛二形式。\n\n你的任务是实现一个完整的、可运行的程序，该程序使用以下步骤对多个子系统和代码路径执行严格的精确时间可逆性测试：\n1. 从初始状态 $(q_0,p_0)$ 开始，使用数值上辛且时间可逆的方案进行正向积分，总时间为 $T$，使用固定的时间步长 $\\Delta t$ 和严格为正的整数步数 $N$，使得 $T = N \\Delta t$。将所得状态记为 $(q_T, p_T)$。\n2. 对动量应用时间反演算符：$(q_T, p_T) \\mapsto (q_T, -p_T)$。\n3. 使用相同的方案和时间步长 $\\Delta t$ 再次正向积分相同的步数 $N$，产生 $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$。\n4. 再次对动量应用时间反演算符：$(q_{\\mathrm{fin}}, p_{\\mathrm{fin}}) = (q_{\\mathrm{back}}, -p_{\\mathrm{back}})$。\n5. 测量 $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ 和 $(q_0, p_0)$ 之间的按位相等性，即当 $q$ 和 $p$ 的所有 $64$ 位浮点分量被视为无符号整数时，其二进制表示完全相等。为此测试报告一个布尔结果。\n\n此外，实现一个基于前向欧拉法的非时间可逆基准积分器以对比其行为。\n\n使用无量纲单位（即，所有量都是与数值模型一致的无单位标量）。\n\n为辛积分器实现两种结构上不同的代码路径：\n- “标量循环”路径，按顺序执行原地更新。\n- “矢量化”路径，使用具有不同算术分组的矢量化数组操作执行更新。\n\n你的程序必须为以下测试套件执行上述过程。对于每个测试用例，输出一个布尔值，指示最终的 $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ 是否与初始的 $(q_0, p_0)$ 按位相等：\n\n- 测试用例 1 (正常路径，二进制步长): 一维谐振子，其 $V(q) = \\frac{1}{2} k q^2$, $k=1$, 质量 $m=1$, 初始 $q_0 = 1/2$, $p_0 = 1/4$, 时间步长 $\\Delta t = 1/8$, 总时间 $T = 8$, 使用带有标量循环路径的辛时间可逆方案。\n\n- 测试用例 2 (备用代码路径): 与测试用例 1 相同的系统和参数，但使用矢量化路径。\n\n- 测试用例 3 (非二进制步长): 一维谐振子，其 $k=1$, $m=1$, 初始 $q_0 = 1/2$, $p_0 = 1/4$, 时间步长 $\\Delta t = 0.1$, 总时间 $T = 1.0$, 使用带有标量循环路径的辛时间可逆方案。\n\n- 测试用例 4 (边界情况，零力): 二维自由粒子 ($V(q) \\equiv 0$), 每个自由度的质量 $m=1$, 初始 $q_0 = [1/4, -1/8]$, $p_0 = [1/16, 1/32]$, 时间步长 $\\Delta t = 1/16$, 总时间 $T = 1$, 使用带有矢量化路径的辛时间可逆方案。\n\n- 测试用例 5 (非线性相互作用): 两个在二维空间中通过 Lennard-Jones 势 $V(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$ 相互作用的粒子，其中 $\\varepsilon = 1$, $\\sigma = 1$, 两个粒子的质量均为 $m=1$, 初始位置 $q_{0,1} = [1.5, 0.0]$, $q_{0,2} = [-1.5, 0.0]$, 初始动量 $p_{0,1} = [0.0, 0.05]$, $p_{0,2} = [0.0, -0.05]$, 时间步长 $\\Delta t = 0.001$, 总时间 $T = 0.01$, 使用带有矢量化路径的辛时间可逆方案。\n\n- 测试用例 6 (非时间可逆基准): 一维谐振子，其 $k=1$, $m=1$, 初始 $q_0 = 1/2$, $p_0 = 1/4$, 时间步长 $\\Delta t = 1/8$, 总时间 $T = 8$, 使用带有标量循环路径的前向欧拉基准积分器。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4,result5,result6]\"），其中每个条目为 \"True\" 或 \"False\"，按上述顺序列出，对应于每个测试用例的按位相等性测试。不涉及角度；除了所述的无量纲化之外，不需要进行单位转换。", "solution": "用户提供的问题是有效的。它在科学上基于哈密顿力学和数值积分的原理，问题陈述清晰，具有完整明确的规范，并且其表述是客观的。任务是测试数值积分器的精确、按位时间可逆性，这是计算物理学中的一个标准且严谨的程序。\n\n问题的核心在于算法的数学属性与其有限精度数值实现之间的区别。一个积分器 $\\Phi_{\\Delta t}$ 被定义为时间可逆的，如果它满足关系式 $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$，其中 $\\mathcal{R}$ 是反转动量的时间反演算符，$\\mathcal{R}(q,p) = (q,-p)$。所描述的测试过程利用了这一属性。对于一个完全时间可逆的方案，一次 $N$ 步的正向积分，然后是一次动量反转，再进行 $N$ 步正向积分，最后再进行一次动量反转，应当将系统恢复到其精确的初始状态：$(\\mathcal{R} \\circ \\Phi_T \\circ \\mathcal{R}) \\circ \\Phi_T (q_0, p_0) = \\Phi_T^{-1} \\circ \\Phi_T (q_0, p_0) = (q_0, p_0)$。\n\n挑战在于验证这是否能达到*按位*精度。浮点数运算会引入舍入误差。然而，像速度 Verlet 方法这样的对称、时间可逆算法的一个关键特征是，其后向积分路径的算术运算序列与前向路径的运算序列完全相反且镜像对称。这种对称性使得浮点误差可以被抵消，理论上可以逐位恢复初始状态，前提是没有信息因下溢或上溢而丢失。\n\n问题要求实现两个积分器：\n\n1.  **速度 Verlet 积分器**: 这是辛且时间可逆方案的标准选择。它可以从与哈密顿量 $H(q,p) = T(p) + V(q)$ 对应的刘维尔算符的 Trotter 分解中导出。步进映射 $\\Phi_{\\Delta t}$ 被构造为动能 $T(p)$ 和势能 $V(q)$ 下精确流的对称组合：$\\Phi_{\\Delta t} = \\Phi_V(\\Delta t/2) \\circ \\Phi_T(\\Delta t) \\circ \\Phi_V(\\Delta t/2)$。这三个操作对应于：\n    a. 对动量进行半步“踢”：$p(t+\\frac{\\Delta t}{2}) = p(t) + F(q(t))\\frac{\\Delta t}{2}$，其中力 $F = -\\nabla_q V$。\n    b. 对位置进行整步“漂移”：$q(t+\\Delta t) = q(t) + \\frac{p(t+\\frac{\\Delta t}{2})}{m}\\Delta t$。\n    c. 对动量进行最终的半步“踢”：$p(t+\\Delta t) = p(t+\\frac{\\Delta t}{2}) + F(q(t+\\Delta t))\\frac{\\Delta t}{2}$。\n    这种对称结构是其时间可逆性的来源。我们将按要求以两种不同的方式实现它：一个带有显式维度循环的“标量循环”路径，以及一个使用 `numpy` 数组操作的“矢量化”路径，后者可能具有不同的算术分组。\n\n2.  **前向欧拉积分器**: 这作为一个非时间可逆的基准。其更新方式为：\n    $q(t+\\Delta t) = q(t) + \\frac{p(t)}{m}\\Delta t$\n    $p(t+\\Delta t) = p(t) + F(q(t))\\Delta t$\n    异步更新（力仅基于时间 $t$ 的状态）破坏了对称性，因此它既不是时间可逆的，也不是辛的。我们预计它将无法通过按位可逆性测试。\n\n该过程针对六个测试用例执行，涵盖了不同的势（谐振子、自由粒子、Lennard-Jones）、不同的数值参数（二进制与非二进制时间步长）以及不同的积分器代码路径。为每个用例报告一个布尔结果，指示最终状态是否与初始状态按位相同。按位比较是通过将状态向量的 64 位浮点数重新解释为 64 位无符号整数并检查其相等性来执行的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef are_bitwise_equal(q1, p1, q2, p2):\n    \"\"\"\n    Performs a bitwise comparison of two states (q, p).\n    Each state is composed of numpy arrays q and p of dtype float64.\n    \"\"\"\n    s1 = np.concatenate((np.ravel(q1), np.ravel(p1)))\n    s2 = np.concatenate((np.ravel(q2), np.ravel(p2)))\n\n    if s1.dtype != np.float64 or s2.dtype != np.float64:\n        raise TypeError(\"Inputs must be float64 numpy arrays for bitwise comparison.\")\n\n    if s1.shape != s2.shape:\n        return False\n\n    # View arrays as 64-bit unsigned integers and check for equality.\n    return np.all(s1.view(np.uint64) == s2.view(np.uint64))\n\n# --- Force Functions ---\n\ndef force_harmonic_oscillator(q, k=1.0):\n    \"\"\"Force for a 1D harmonic oscillator: F = -kq.\"\"\"\n    return -k * q\n\ndef force_free_particle(q):\n    \"\"\"Force for a free particle: F = 0.\"\"\"\n    return np.zeros_like(q)\n\ndef force_lennard_jones(q, epsilon=1.0, sigma=1.0):\n    \"\"\"Force for two particles interacting via Lennard-Jones potential.\"\"\"\n    q1 = q[0:2]\n    q2 = q[2:4]\n    r_vec = q1 - q2\n    r_sq = np.dot(r_vec, r_vec)\n    \n    r_minus2 = 1.0 / r_sq\n    sigma_sq = sigma * sigma\n    \n    sig2_r_minus2 = sigma_sq * r_minus2\n    sig6_r_minus6 = sig2_r_minus2 * sig2_r_minus2 * sig2_r_minus2\n    sig12_r_minus12 = sig6_r_minus6 * sig6_r_minus6\n\n    # F = (24*epsilon/r^2) * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec\n    force_scalar_part = (24.0 * epsilon * r_minus2) * (2.0 * sig12_r_minus12 - sig6_r_minus6)\n    \n    force_on_1 = force_scalar_part * r_vec\n    force_on_2 = -force_on_1\n    \n    return np.concatenate((force_on_1, force_on_2))\n\n# --- Integrator Implementations ---\n\nclass VelocityVerletScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using sequential scalar loops.\"\"\"\n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        for i in range(len(q)):\n            q[i] += (p[i] / self.m[i]) * dt\n        \n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        return q, p\n\nclass VelocityVerletVectorized:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using vectorized numpy operations.\"\"\"\n        p += self.force_func(q) * 0.5 * dt\n        q += (p / self.m) * dt\n        p += self.force_func(q) * 0.5 * dt\n        return q, p\n\nclass ForwardEulerScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"Out-of-place update using scalar loops.\"\"\"\n        force = self.force_func(q)\n        q_next = np.empty_like(q)\n        p_next = np.empty_like(p)\n        for i in range(len(q)):\n            q_next[i] = q[i] + (p[i] / self.m[i]) * dt\n            p_next[i] = p[i] + force[i] * dt\n        return q_next, p_next\n\n# --- Simulation and Test Logic ---\n\ndef test_reversibility(integrator_class, force_func, q0_list, p0_list, m_val, T, dt, force_params):\n    \"\"\"\n    Executes the time-reversibility test for a given configuration.\n    \"\"\"\n    # Bind parameters to the force function\n    bound_force_func = lambda q: force_func(q, **force_params)\n\n    # Prepare initial state as float64 numpy arrays\n    q0 = np.array(q0_list, dtype=np.float64)\n    p0 = np.array(p0_list, dtype=np.float64)\n    m = np.full_like(q0, m_val, dtype=np.float64)\n\n    # Calculate number of steps\n    num_steps = int(round(T / dt))\n\n    integrator = integrator_class(bound_force_func, m)\n\n    # --- Step 1: Forward integration ---\n    q_fwd, p_fwd = q0.copy(), p0.copy()\n    for _ in range(num_steps):\n        q_fwd, p_fwd = integrator.step(q_fwd, p_fwd, dt)\n    \n    # --- Step 2: Apply time-reversal to momenta ---\n    p_fwd = -p_fwd\n\n    # --- Step 3: Integrate forward again (\"backward\" evolution) ---\n    q_back, p_back = q_fwd.copy(), p_fwd.copy()\n    for _ in range(num_steps):\n        q_back, p_back = integrator.step(q_back, p_back, dt)\n    \n    # --- Step 4: Apply time-reversal again ---\n    q_fin, p_fin = q_back.copy(), -p_back\n\n    # --- Step 5: Measure bitwise equality ---\n    return are_bitwise_equal(q0, p0, q_fin, p_fin)\n\ndef solve():\n    test_cases = [\n        # Test Case 1 (happy path, dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 2 (alternate code path)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 3 (non-dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 0.1},\n        # Test Case 4 (boundary, zero force)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_free_particle, \"force_params\": {},\n         \"q0_list\": [1/4, -1/8], \"p0_list\": [1/16, 1/32], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 1/16},\n        # Test Case 5 (nonlinear interaction)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_lennard_jones, \"force_params\": {\"epsilon\": 1.0, \"sigma\": 1.0},\n         \"q0_list\": [1.5, 0.0, -1.5, 0.0], \"p0_list\": [0.0, 0.05, 0.0, -0.05], \"m_val\": 1.0, \"T\": 0.01, \"dt\": 0.001},\n        # Test Case 6 (non-time-reversible baseline)\n        {\"integrator_class\": ForwardEulerScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = test_reversibility(\n            integrator_class=case[\"integrator_class\"],\n            force_func=case[\"force_func\"],\n            q0_list=case[\"q0_list\"],\n            p0_list=case[\"p0_list\"],\n            m_val=case[\"m_val\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"],\n            force_params=case[\"force_params\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456282"}, {"introduction": "## 非线性系统中的长期稳定性\n\n数值积分方法的真正考验在于其在复杂非线性系统中的长期行为。本练习 [@problem_id:3456295] 要求您模拟著名的 Fermi–Pasta–Ulam–Tsingou (FPUT) 链，比较辛积分方法（速度-Verlet）和标准的非辛方法（RK4）。通过分析能量守恒、可逆性和系统的物理行为，您将亲身体验到为何在长期分子动力学模拟中，保持辛结构对于获得有物理意义的结果至关重要。", "problem": "考虑一个由$N$个相同粒子组成的一维Fermi–Pasta–Ulam–Tsingou链，该链具有周期性边界条件，且粒子质量为单位质量。设位置和动量为 $(q_i,p_i)$，其中 $i=0,1,\\dots,N-1$，粒子排列在一个环上。该系统根据哈密顿动力学演化，其 $\\beta$-Fermi–Pasta–Ulam–Tsingou 哈密顿量为\n$$\nH(q,p) \\equiv \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right),\n$$\n其中，索引在模$N$（周期性）的意义下理解，$\\beta > 0$ 控制非线性强度。运动方程由哈密顿形式的牛顿第二定律给出，\n$$\n\\dot{q}_i = p_i, \\quad \\dot{p}_i = F_i(q),\n$$\n其中力 $F_i(q)$ 通过 $-\\partial H / \\partial q_i$ 获得。\n\n您必须为此哈密顿系统实现并比较两种在长时间范围内的数值积分器：\n- 一种时间可逆辛积分器：速度–Verlet，\n- 一种非辛显式积分器：经典四阶龙格–库塔。\n\n对于每种积分器和每个测试用例，您必须在时间区间 $[0,T]$ 内，使用固定时间步长 $dt$ 和总步数 $n=\\lfloor T/dt \\rfloor$ 来计算以下诊断指标：\n\n1. 最大绝对相对能量漂移：\n$$\nD_{\\mathrm{energy}} \\equiv \\max_{0 \\le k \\le n} \\left| \\frac{H\\left(q^{(k)},p^{(k)}\\right) - H\\left(q^{(0)},p^{(0)}\\right)}{H\\left(q^{(0)},p^{(0)}\\right)} \\right|,\n$$\n其中 $(q^{(k)},p^{(k)})$ 表示经过 $k$ 步后的状态。\n\n2. 时间可逆性误差：使用时间步长 $dt$ 从 $t=0$ 正向积分到 $t=T$ 以产生 $(q^{(n)},p^{(n)})$，然后将动量反转为 $(q^{(n)},-p^{(n)})$，并使用相同数量的步数和负时间步长 $-dt$ 反向积分以获得 $(\\tilde{q}^{(0)},\\tilde{p}^{(0)})$。定义\n$$\nD_{\\mathrm{rev}} \\equiv \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\left[\\tilde{q}^{(0)}_i - q^{(0)}_i\\right]^2 + \\left[\\tilde{p}^{(0)}_i - p^{(0)}_i\\right]^2 \\right) }.\n$$\n\n3. 基于线性简正模的亚稳态泄漏：定义 $q$ 和 $p$ 的离散傅里叶变换 (DFT)，采用幺正归一化 $Q_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} q_j e^{-2\\pi i k j / N}$ 和 $P_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} p_j e^{-2\\pi i k j / N}$，其中 $k=0,1,\\dots,N-1$。对于线性化链，模式频率为\n$$\n\\omega_k = \\sqrt{2\\left(1 - \\cos\\left(\\frac{2\\pi k}{N}\\right)\\right)}, \\quad k=0,1,\\dots,N-1.\n$$\n定义在时间步 $k_{\\mathrm{step}}$ 时，波数为 $m$ 的线性化模态能量为\n$$\n\\mathcal{E}_m(k_{\\mathrm{step}}) \\equiv \\frac{1}{2} \\left|P_m\\right|^2 + \\frac{1}{2} \\omega_m^2 \\left|Q_m\\right|^2,\n$$\n以及初始激发的低频共轭模式集合 $\\mathcal{S} \\equiv \\{1, N-1\\}$。在第 $k_{\\mathrm{step}}$ 步的瞬时泄漏为\n$$\nL(k_{\\mathrm{step}}) \\equiv 1 - \\frac{\\sum_{m \\in \\mathcal{S}} \\mathcal{E}_m(k_{\\mathrm{step}})}{\\sum_{m=1}^{N-1} \\mathcal{E}_m(k_{\\mathrm{step}})}.\n$$\n亚稳态泄漏指标是时间平均值\n$$\nD_{\\mathrm{leak}} \\equiv \\frac{1}{n} \\sum_{k_{\\mathrm{step}}=1}^{n} L(k_{\\mathrm{step}}).\n$$\n\n初始化：使用低振幅单模位移\n$$\nq_i(0) = A \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad p_i(0) = 0,\n$$\n振幅 $A > 0$。\n\n对于每个测试用例，计算两种积分器诊断指标之间的差异三元组，\n$$\n\\left[\\, D_{\\mathrm{energy}}^{\\mathrm{RK4}} - D_{\\mathrm{energy}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{rev}}^{\\mathrm{RK4}} - D_{\\mathrm{rev}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{leak}}^{\\mathrm{RK4}} - D_{\\mathrm{leak}}^{\\mathrm{VV}} \\,\\right],\n$$\n其中上标表示积分器方法（四阶龙格–库塔与速度–Verlet）。所有量均为无量纲；以浮点数形式报告数值。\n\n您的程序必须生成单行输出，其中包含一个以逗号分隔的列表的列表，并用方括号括起来，例如 $\\left[ [x_1,y_1,z_1], [x_2,y_2,z_2], [x_3,y_3,z_3] \\right]$，其中每个内部列表按下面列出的顺序对应一个测试用例。\n\n使用以下测试套件，它涵盖了一个典型场景、一个小时间步长情况以及一个具有更大时间步长的更强非线性情况：\n- 用例 1 (典型): $N=8$, $\\beta=0.25$, $A=0.1$, $T=100$, $dt=0.02$.\n- 用例 2 (小步长): $N=8$, $\\beta=0.25$, $A=0.1$, $T=100$, $dt=0.005$.\n- 用例 3 (更强非线性): $N=8$, $\\beta=1.0$, $A=0.2$, $T=100$, $dt=0.05$.\n\n您的最终输出必须是单行，其中包含三个计算出的三元组，格式必须完全符合 $\\left[\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot]\\,\\right]$。", "solution": "此问题是有效的。它提出了一个在计算物理学中定义明确、有科学依据的任务，并提供了所有必要的参数和定义。其目标是比较两种用于模拟一维Fermi–Pasta–Ulam–Tsingou (FPUT) 链的数值积分方案：速度–Verlet和四阶龙格–库塔。这种比较是哈密顿系统数值分析中的一个经典练习，没有任何科学或逻辑上的缺陷。\n\n问题的核心在于理解辛积分器和非辛积分器在哈密顿系统长时间模拟中的定性差异。FPUT系统为此提供了一个绝佳的测试平台。其动力学由哈密顿量控制：\n$$\nH(q,p) = K(p) + V(q) = \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right)\n$$\n其中 $q_i$ 和 $p_i$ 是第$i$个粒子的位置和动量，$m=1$ 是质量，$\\beta$ 控制四次非线性的强度。运动方程为 $\\dot{q}_i = \\partial H / \\partial p_i = p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i = F_i(q)$。作用在粒子 $i$ 上的力由势能 $V(q)$ 导出：\n$$\nF_i(q) = -\\frac{\\partial V}{\\partial q_i} = (q_{i+1} - q_i) + \\beta(q_{i+1} - q_i)^3 - (q_i - q_{i-1}) - \\beta(q_i - q_{i-1})^3\n$$\n其中，由于周期性边界条件，索引在模$N$的意义下取值。\n\n比较了两种积分器：\n\n1.  **速度–Verlet (VV)**：这是一种二阶显式积分器，属于几何积分器或辛积分器一类。单步执行如下：\n    $$\n    \\begin{align*}\n    p\\left(t + \\frac{dt}{2}\\right) = p(t) + F(q(t)) \\frac{dt}{2} \\\\\n    q(t + dt) = q(t) + p\\left(t + \\frac{dt}{2}\\right) dt \\\\\n    p(t + dt) = p\\left(t + \\frac{dt}{2}\\right) + F(q(t+dt)) \\frac{dt}{2}\n    \\end{align*}\n    $$\n    它的关键特性是时间可逆性和辛性。辛性意味着积分器精确地保持一个“影子”哈密顿量，该哈密顿量与真实的哈密顿量非常接近。这带来了出色的长期能量稳定性，数值能量误差保持有界并振荡，而不是随时间长期漂移。\n\n2.  **经典四阶龙格–库塔 (RK4)**：这是一种通用的高阶显式积分器。对于系统 $\\dot{y} = f(t,y)$，一个步长为：\n    $$\n    \\begin{align*}\n    k_1 = f(t_n, y_n) \\\\\n    k_2 = f\\left(t_n + \\frac{dt}{2}, y_n + \\frac{dt}{2}k_1\\right) \\\\\n    k_3 = f\\left(t_n + \\frac{dt}{2}, y_n + \\frac{dt}{2}k_2\\right) \\\\\n    k_4 = f(t_n + dt, y_n + dt k_3) \\\\\n    y_{n+1} = y_n + \\frac{dt}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{align*}\n    $$\n    虽然 RK4 对于单步计算非常精确（局部误差为 $O(dt^5)$），但它不是辛的。当应用于哈密顿系统时，它不保持能量或相空间流的其他几何特性。数值能量通常表现出长期漂移，这使得它不适用于那些物理守恒定律至关重要的长期模拟。\n\n使用三种旨在突出这些差异的诊断指标来评估解：\n\n1.  **能量漂移 ($D_{\\mathrm{energy}}$)**：该指标直接衡量对能量守恒的违背，这是精确动力学的一个基本属性。我们期望 VV 的值会显著小于 RK4，尤其是在长积分时间内。\n\n2.  **时间可逆性误差 ($D_{\\mathrm{rev}}$)**：精确的哈密顿动力学是时间可逆的。VV 积分器的构造恰好也具有此属性。相比之下，RK4 不是时间可逆的。该指标量化了从时间 $T$ 正向积分再反向积分回时间 $0$ 时的误差。VV 的误差应接近机器精度（由于浮点舍入），而 RK4 的误差将是巨大的。\n\n3.  **亚稳态泄漏 ($D_{\\mathrm{leak}}$)**：FPUT 问题因其“亚稳态”而闻名，即最初置于低频模式中的能量泄漏到其他模式的速度比统计力学预期的要慢得多。保持这种微妙的、长期的动力学行为是一个好的几何积分器的标志。这个基于线性化简正模中能量的指标，量化了这种泄漏。我们预计，非辛的 RK4 会引入数值伪影，从而加速这种泄漏，导致与结构保持的 VV 积分器相比，$D_{\\mathrm{leak}}$ 值更高。\n\n实现过程将通过定义力、哈密顿量和每个积分步骤的函数来进行。一个主模拟循环将根据指定的初始条件，对每个测试用例和积分器演化系统，收集数据以计算三个诊断指标。最终结果是两种方法在这些诊断值上的差异集合。为了高效计算，采用了使用 NumPy 的矢量化操作，特别是使用 `numpy.roll` 来处理周期性边界条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_force(q, beta):\n    \"\"\"Calculates the force on each particle in the FPUT chain.\"\"\"\n    dq_plus = np.roll(q, -1) - q\n    dq_minus = q - np.roll(q, 1)\n    # The term (dq + beta * dq^3) represents the force from a spring.\n    # The net force is the difference between the pull from the right and the pull from the left.\n    force = (dq_plus + beta * dq_plus**3) - (dq_minus + beta * dq_minus**3)\n    return force\n\ndef calculate_hamiltonian(q, p, beta):\n    \"\"\"Calculates the total energy (Hamiltonian) of the FPUT chain.\"\"\"\n    kinetic_energy = 0.5 * np.sum(p**2)\n    dq = np.roll(q, -1) - q\n    potential_energy = np.sum(0.5 * dq**2 + (beta / 4.0) * dq**4)\n    return kinetic_energy + potential_energy\n\ndef velocity_verlet_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the velocity-Verlet integrator.\"\"\"\n    force_t = calculate_force(q, beta)\n    p_half = p + 0.5 * dt * force_t\n    q_new = q + dt * p_half\n    force_t_plus_dt = calculate_force(q_new, beta)\n    p_new = p_half + 0.5 * dt * force_t_plus_dt\n    return q_new, p_new\n\ndef rk4_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the classical fourth-order Runge-Kutta integrator.\"\"\"\n    # State vector y = (q, p), ODE is y_dot = f(y) = (p, F(q))\n    # k1\n    k1_q = p\n    k1_p = calculate_force(q, beta)\n    # k2\n    q2 = q + 0.5 * dt * k1_q\n    p2 = p + 0.5 * dt * k1_p\n    k2_q = p2\n    k2_p = calculate_force(q2, beta)\n    # k3\n    q3 = q + 0.5 * dt * k2_q\n    p3 = p + 0.5 * dt * k2_p\n    k3_q = p3\n    k3_p = calculate_force(q3, beta)\n    # k4\n    q4 = q + dt * k3_q\n    p4 = p + dt * k3_p\n    k4_q = p4\n    k4_p = calculate_force(q4, beta)\n    \n    q_new = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n    p_new = p + (dt / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n    return q_new, p_new\n\ndef compute_diagnostics(integrator_name, q0, p0, N, beta, T, dt):\n    \"\"\"Computes the three diagnostic metrics for a given integrator.\"\"\"\n    if integrator_name == 'vv':\n        step_func = velocity_verlet_step\n    elif integrator_name == 'rk4':\n        step_func = rk4_step\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    n_steps = int(np.floor(T / dt))\n\n    # --- Forward integration for D_energy and D_leak ---\n    q_curr, p_curr = q0.copy(), p0.copy()\n    \n    # Store final state for reversibility test\n    q_final, p_final = None, None\n    \n    # D_energy calculation\n    H0 = calculate_hamiltonian(q0, p0, beta)\n    if H0 == 0: H0 = 1.0 # Avoid division by zero, though unlikely\n    max_energy_drift = 0.0\n\n    # D_leak calculation\n    k_modes = np.arange(N)\n    omega_sq = 2.0 * (1.0 - np.cos(2.0 * np.pi * k_modes / N))\n    total_leakage = 0.0\n\n    for k in range(n_steps):\n        q_curr, p_curr = step_func(q_curr, p_curr, dt, beta)\n        \n        # Energy drift\n        Hk = calculate_hamiltonian(q_curr, p_curr, beta)\n        drift = np.abs((Hk - H0) / H0)\n        if drift > max_energy_drift:\n            max_energy_drift = drift\n\n        # Leakage\n        Q_k = np.fft.fft(q_curr, norm='ortho')\n        P_k = np.fft.fft(p_curr, norm='ortho')\n        modal_energies = 0.5 * (np.abs(P_k)**2 + omega_sq * np.abs(Q_k)**2)\n        total_linear_energy = np.sum(modal_energies[1:])\n        energy_in_S = modal_energies[1] + modal_energies[N-1]\n        \n        if total_linear_energy > 1e-15:\n            instantaneous_leakage = 1.0 - (energy_in_S / total_linear_energy)\n        else:\n            instantaneous_leakage = 0.0\n        total_leakage += instantaneous_leakage\n    \n    q_final, p_final = q_curr, p_curr\n    D_energy = max_energy_drift\n    D_leak = total_leakage / n_steps if n_steps > 0 else 0.0\n\n    # --- Backward integration for D_rev ---\n    q_rev, p_rev = q_final.copy(), -p_final.copy() # Reverse momenta\n    \n    for _ in range(n_steps):\n        q_rev, p_rev = step_func(q_rev, p_rev, -dt, beta)\n\n    # Reversibility error\n    q_diff_sq = np.sum((q_rev - q0)**2)\n    p_diff_sq = np.sum((p_rev - p0)**2)\n    D_rev = np.sqrt((q_diff_sq + p_diff_sq) / N)\n\n    return D_energy, D_rev, D_leak\n\ndef solve():\n    test_cases = [\n        # Case 1 (typical)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.02},\n        # Case 2 (small step)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.005},\n        # Case 3 (stronger nonlinearity)\n        {'N': 8, 'beta': 1.0, 'A': 0.2, 'T': 100, 'dt': 0.05}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, beta, A, T, dt = case['N'], case['beta'], case['A'], case['T'], case['dt']\n        \n        # Initial conditions\n        i = np.arange(N)\n        q0 = A * np.cos(2.0 * np.pi * i / N)\n        p0 = np.zeros(N)\n\n        # Compute diagnostics for both integrators\n        d_energy_vv, d_rev_vv, d_leak_vv = compute_diagnostics(\n            'vv', q0, p0, N, beta, T, dt)\n        \n        d_energy_rk4, d_rev_rk4, d_leak_rk4 = compute_diagnostics(\n            'rk4', q0, p0, N, beta, T, dt)\n\n        # Calculate differences RK4 - VV\n        diffs = [\n            d_energy_rk4 - d_energy_vv,\n            d_rev_rk4 - d_rev_vv,\n            d_leak_rk4 - d_leak_vv\n        ]\n        all_results.append(diffs)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the required format.\n    print(str(all_results))\n\nsolve()\n```", "id": "3456295"}]}