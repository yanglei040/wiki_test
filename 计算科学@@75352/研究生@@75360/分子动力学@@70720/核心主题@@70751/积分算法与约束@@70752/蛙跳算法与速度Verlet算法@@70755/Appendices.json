{"hands_on_practices": [{"introduction": "任何成功的数值积分都始于精确的第一步。蛙跳法（leap-frog）通过将速度和位置存储在交错的时间点上来实现其卓越的长期稳定性，但这使得初始化过程变得不那么直观。本练习将指导您通过泰勒级数展开，从第一性原理推导出正确的初始“半步踢”（half-kick），以确保积分器从一开始就达到其理论上的二阶精度[@problem_id:3420452]。掌握这个推导过程对于深刻理解和正确实现这些时间交错积分器至关重要。", "problem": "考虑一个质量为 $m$ 的单个粒子，在光滑、与位置相关的力 $\\mathbf{F}(\\mathbf{r})$ 的作用下，根据牛顿第二定律 $m\\,\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))$ 演化。在分子动力学 (MD) 中，蛙跳积分法通过半步速度将位置推进一个步长，即 $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$，而速度的更新则以半步为中心。在时间 $t=0$ 时，给定初始数据 $\\mathbf{r}^{0}=\\mathbf{r}(0)$ 和 $\\mathbf{v}^{0}=\\mathbf{v}(0)$。您希望仅使用 $\\mathbf{r}^{0}$、$\\mathbf{v}^{0}$、$h$、$m$ 和 $\\mathbf{F}(\\mathbf{r}^{0})$ 来初始化时间 $t=h/2$ 时的半步速度 $\\mathbf{v}^{1/2}$，使得第一个位置更新 $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$ 达到 $\\mathcal{O}(h^{3})$ 的局部误差，即该方案在第一步具有二阶精度。\n\n从基本定义 $\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$ 和 $\\mathbf{a}(t)=\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))/m$ 出发，使用关于 $t=0$ 的泰勒展开，推导出一个 $\\mathbf{v}^{1/2}$ 必须满足的相容性条件，以使 $\\mathbf{r}^{1}$ 与精确位置 $\\mathbf{r}(h)$ 的误差在 $\\mathcal{O}(h^{3})$ 之内。然后，提供一个仅用给定物理量表示的 $\\mathbf{v}^{1/2}$ 的显式公式。您的最终答案必须是 $\\mathbf{v}^{1/2}$ 的单个闭式解析表达式。", "solution": "该问题要求在蛙跳积分方案中推导半步速度 $\\mathbf{v}^{1/2}$ 的初始化公式。此初始化必须确保第一个位置更新 $\\mathbf{r}^{1}$ 是二阶精度的，即相对于精确解 $\\mathbf{r}(h)$ 的局部误差为 $\\mathcal{O}(h^3)$ 阶。$\\mathbf{v}^{1/2}$ 的公式只能依赖于初始位置 $\\mathbf{r}^{0}$、初始速度 $\\mathbf{v}^{0}$、时间步长 $h$、质量 $m$ 以及在初始位置计算的力 $\\mathbf{F}(\\mathbf{r}^{0})$。\n\n我们首先通过对 $\\mathbf{r}(t)$ 在 $t=0$ 附近进行泰勒级数展开，来求得粒子在时间 $t=h$ 时的精确位置。粒子的运动由牛顿第二定律 $m\\,\\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))$ 决定。我们已知定义 $\\mathbf{v}(t) = \\dot{\\mathbf{r}}(t)$ 和 $\\mathbf{a}(t) = \\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))/m$。$\\mathbf{r}(t)$ 在 $t=0$ 附近的泰勒展开为：\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0) + t\\,\\dot{\\mathbf{r}}(0) + \\frac{t^2}{2!}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(t^3)\n$$\n在 $t=h$ 处求值，并使用初始条件 $\\mathbf{r}(0) = \\mathbf{r}^0$ 和 $\\dot{\\mathbf{r}}(0) = \\mathbf{v}^0$，我们得到：\n$$\n\\mathbf{r}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(h^3)\n$$\n在 $t=0$ 时的加速度为 $\\mathbf{a}^{0} = \\ddot{\\mathbf{r}}(0) = \\mathbf{F}(\\mathbf{r}(0))/m = \\mathbf{F}(\\mathbf{r}^0)/m$。将其代入展开式，得到精确到 $h^2$ 阶的位置：\n$$\n\\mathbf{r}_{exact}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^3)\n$$\n第一个时间步的位置的数值近似由蛙跳更新规则给出：\n$$\n\\mathbf{r}^{1} = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2}\n$$\n这第一步的局部误差是精确位置 $\\mathbf{r}_{exact}(h)$ 与数值近似 $\\mathbf{r}^{1}$ 之间的差。问题要求此误差为 $\\mathcal{O}(h^3)$ 阶：\n$$\n\\mathbf{r}_{exact}(h) - \\mathbf{r}^{1} = \\mathcal{O}(h^3)\n$$\n代入 $\\mathbf{r}_{exact}(h)$ 和 $\\mathbf{r}^{1}$ 的表达式：\n$$\n\\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} \\right) - \\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2} \\right) = \\mathcal{O}(h^3)\n$$\n项 $\\mathbf{r}^{0}$ 消去。我们剩下：\n$$\nh\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} - h\\,\\mathbf{v}^{1/2} = \\mathcal{O}(h^3)\n$$\n为了分离出关于 $\\mathbf{v}^{1/2}$ 的条件，我们将整个方程除以时间步长 $h$：\n$$\n\\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} - \\mathbf{v}^{1/2} = \\mathcal{O}(h^2)\n$$\n重新整理此方程，得到 $\\mathbf{v}^{1/2}$ 必须满足的相容性条件：\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\n此条件意味着 $\\mathbf{v}^{1/2}$ 必须是半个时间步长（$t=h/2$）时精确速度的一阶近似（关于 $h$）。我们可以通过对精确速度 $\\mathbf{v}(t)$ 在 $t=0$ 附近进行泰勒展开来验证这一点：\n$$\n\\mathbf{v}(t) = \\mathbf{v}(0) + t\\,\\dot{\\mathbf{v}}(0) + \\mathcal{O}(t^2) = \\mathbf{v}^{0} + t\\,\\mathbf{a}^{0} + \\mathcal{O}(t^2)\n$$\n在 $t=h/2$ 处求值：\n$$\n\\mathbf{v}(h/2) = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\n将此与 $\\mathbf{v}^{1/2}$ 的相容性条件进行比较，我们看到 $\\mathbf{v}^{1/2}$ 必须与 $\\mathbf{v}(h/2)$ 一致，直到 $\\mathcal{O}(h)$ 阶的项。\n\n为了得到 $\\mathbf{v}^{1/2}$ 的显式公式，我们可以通过简单地截断级数展开来满足相容性条件，即舍去 $\\mathcal{O}(h^2)$ 项。这给出：\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0}\n$$\n这个选择提供了满足精度要求的最简单的显式公式。等式右边的量是初始速度 $\\mathbf{v}^{0}$、时间步长 $h$ 和初始加速度 $\\mathbf{a}^{0}$。问题规定该公式只能使用 $\\mathbf{r}^{0}$、$\\mathbf{v}^{0}$、$h$、$m$ 和 $\\mathbf{F}(\\mathbf{r}^{0})$。由于 $\\mathbf{a}^{0} = \\mathbf{F}(\\mathbf{r}^{0})/m$，我们关于 $\\mathbf{v}^{1/2}$ 的表达式满足这个约束。\n\n代入 $\\mathbf{a}^0$：\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})\n$$\n这就是在蛙跳积分的第一个位置步中实现二阶精度所需的初始半步速度的显式公式。", "answer": "$$\\boxed{\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})}$$", "id": "3420452"}, {"introduction": "在正确地初始化积分器之后，下一步是评估其在模拟一个非平凡系统时的长期性能。本练习将使用双阱势（double-well potential）——一个比简谐振子更具挑战性的标准基准——来检验蛙跳法和速度Verlet方法的实际表现[@problem_id:3420524]。通过这项实践，您将学习如何量化能量漂移，用数值方法验证算法的理论收敛阶数（$D \\propto \\Delta t^{n}$），并理解在精度和计算成本之间进行权衡的艺术，这是微正则系综（NVE）模拟中的一项核心技能。", "problem": "考虑一个质量为 $m$ 的单个粒子，在一维空间中在非谐双势阱 $V(x)=\\alpha\\,(x^2-x_0^2)^2$ 下运动。其受力为 $F(x)=-\\partial V/\\partial x$。通过使用两种二阶辛算法（蛙跳法和速度 Verlet 方法）积分牛顿第二定律 $m\\,\\mathrm{d}^2 x/\\mathrm{d} t^2=F(x)$，生成一条微正则系综（NVE）轨迹。从牛顿定律和速度定义 $v=\\mathrm{d}x/\\mathrm{d}t$ 出发，实现这两种积分器，并使用多个时间步长 $\\Delta t$ 模拟在固定总时间 $T$ 内的动力学过程。对于每种积分器和每个 $\\Delta t$，计算总能量 $E(t)=\\tfrac{1}{2}m\\,v(t)^2+V(x(t))$，并将在时间 $T$ 后的绝对相对能量漂移定义为 $D(\\Delta t)=\\left|E(T)-E(0)\\right|/\\left|E(0)\\right|$。\n\n您的程序必须：\n- 对于每个指定的 $\\Delta t$ 和积分器，演化系统，如果状态的任何分量变为非有限数（不是实数），或者 $|x|$ 或 $|v|$ 超过界限 $10^6$，则检测不稳定性（发散），并在这种情况下将该次运行的漂移 $D(\\Delta t)$ 标记为未定义。\n- 对于每个测试用例和每个积分器，通过对所有 $D(\\Delta t)0$ 的稳定运行的 $\\log D$ 与 $\\log \\Delta t$ 进行最小二乘线性回归，估计标度律 $D(\\Delta t)\\approx C\\,\\Delta t^{n}$ 中的指数 $n$。报告 $n$ 值，四舍五入到两位小数（以无量纲单位计）。\n- 对于每种积分器，将“最优 $\\Delta t$ 区域”定义为所提供列表中稳定且满足 $D(\\Delta t)\\le\\tau$ 的 $\\Delta t$ 值的集合，其中 $\\tau$ 是特定于用例的容差。以浮点数形式报告此区域的下界和上界，四舍五入到三位小数（以无量纲单位计）。如果没有时间步满足该标准，则两个界限均报告为 $\\mathrm{NaN}$。\n\n使用约化无量纲单位，并设 $m=1$；因此，所有报告的量都是无量纲的。不涉及角度。所有最终数值答案必须是浮点数。程序应以科学上真实的方式实现这两种积分器，并严格从第一性原理出发产生结果。\n\n测试套件：\n1. 用例 1（基准双势阱）：\n   - 参数：$\\alpha=1.0$，$x_0=1.0$，$m=1.0$，$T=20.0$。\n   - 初始条件：$x(0)=0.9$，$v(0)=0.0$。\n   - 时间步：$\\Delta t\\in\\{0.002,\\,0.004,\\,0.008,\\,0.016,\\,0.032\\}$。\n   - 容差：$\\tau=10^{-3}$。\n2. 用例 2（更陡峭的双势阱）：\n   - 参数：$\\alpha=5.0$，$x_0=1.0$，$m=1.0$，$T=10.0$。\n   - 初始条件：$x(0)=0.8$，$v(0)=0.0$。\n   - 时间步：$\\Delta t\\in\\{0.001,\\,0.002,\\,0.004,\\,0.008\\}$。\n   - 容差：$\\tau=5\\times 10^{-4}$。\n3. 用例 3（近势垒动力学）：\n   - 参数：$\\alpha=1.0$，$x_0=1.0$，$m=1.0$，$T=20.0$。\n   - 初始条件：$x(0)=0.0$，$v(0)=0.5$。\n   - 时间步：$\\Delta t\\in\\{0.002,\\,0.004,\\,0.008,\\,0.016\\}$。\n   - 容差：$\\tau=2\\times 10^{-3}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行文本，其中包含 3 个测试用例的汇总结果，格式为不含空格的逗号分隔列表的列表。对于每个用例，输出列表 $[n_{\\mathrm{LF}},n_{\\mathrm{VV}},\\Delta t_{\\min,\\mathrm{LF}},\\Delta t_{\\max,\\mathrm{LF}},\\Delta t_{\\min,\\mathrm{VV}},\\Delta t_{\\max,\\mathrm{VV}}]$，其中 $n_{\\mathrm{LF}}$ 是蛙跳法的漂移标度指数，$n_{\\mathrm{VV}}$ 是速度 Verlet 方法的漂移标度指数。两个区域界限是为每种积分器定义的满足上述标准的下界和上界 $\\Delta t$ 值。因此，汇总输出必须是 $[[\\dots],[\\dots],[\\dots]]$ 的形式，所有浮点数均按规定四舍五入。", "solution": "用户要求实现并分析两种常见的辛积分器——蛙跳法和速度 Verlet 方法，用于模拟一维双势阱中粒子的动力学。主要任务是验证问题，如果有效，则提供一个包括 Python 程序在内的完整解决方案。\n\n### 问题验证\n\n根据指定标准对问题陈述进行严格评估。\n\n**第一步：提取已知条件**\n\n- **系统定义**：一维空间中的单个质量为 $m$ 的粒子。\n- **势能**：$V(x) = \\alpha(x^2 - x_0^2)^2$。\n- **力**：$F(x) = -\\partial V/\\partial x = -4\\alpha x(x^2 - x_0^2)$。\n- **运动方程**：$m\\,\\mathrm{d}^2 x/\\mathrm{d} t^2 = F(x)$。\n- **数值积分器**：蛙跳法和速度 Verlet 方法。\n- **模拟时长**：总时间 $T$。\n- **时间步长**：$\\Delta t$。\n- **总能量**：$E(t) = \\frac{1}{2}m v(t)^2 + V(x(t))$。\n- **能量漂移**：绝对相对能量漂移定义为 $D(\\Delta t) = |E(T) - E(0)|/|E(0)|$。\n- **不稳定性条件**：如果任何状态变量（$x$ 或 $v$）变为非有限数，或者 $|x|  10^6$ 或 $|v|  10^6$，则轨迹不稳定。对于不稳定的运行，$D(\\Delta t)$ 被视为未定义。\n- **标度指数 $n$**：通过对所有稳定运行且 $D(\\Delta t)  0$ 的 $\\log D$ 与 $\\log \\Delta t$ 进行最小二乘线性回归，从 $D(\\Delta t) \\approx C\\,\\Delta t^n$ 中估算。$n$ 的值必须四舍五入到两位小数。\n- **最优 $\\Delta t$ 区域**：对于其中 $D(\\Delta t) \\le \\tau$ 的稳定 $\\Delta t$ 值的集合，其中 $\\tau$ 是给定的容差。该区域的下界和上界需报告，并四舍五入到三位小数。如果没有 $\\Delta t$ 符合条件，则两个界限都应报告为 `NaN`。\n- **单位**：所有量均采用约化无量纲单位，并设 $m=1$。\n- **测试用例**：提供了三个不同的测试用例，每个用例都具有特定的 $\\alpha$、$x_0$、$T$ 值、初始条件 $(x(0), v(0))$、一组 $\\Delta t$ 值和一个容差 $\\tau$。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在根本上是合理的。它涉及牛顿第二定律、一个标准的非谐势，以及在分子动力学和计算物理学中广泛使用的规范数值积分算法（蛙跳法/速度 Verlet）。能量守恒的分析是评估 NVE 模拟的基石。\n- **适定性**：该问题是适定的。它描述了一个二阶常微分方程的初值问题。所有必要的参数、初始条件和分析标准都已明确提供，确保可以计算出唯一且有意义的解。\n- **客观性**：问题陈述具有科学客观性和数学精确性。所有任务和要求的输出都是定量的，没有歧义或主观解释的余地。\n- **完整性与一致性**：问题是自洽的。每个测试用例都得到了完整说明。没有内部矛盾。\n- **无其他缺陷**：该问题不违反任何其他验证标准。它不基于错误的前提，可以直接形式化，计算上可行，并且并非微不足道。\n\n**第三步：结论与行动**\n\n此问题被判定为**有效**。将提供一个完整的解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是求解牛顿运动方程 $\\ddot{x} = a(x)$，其中加速度 $a(x) = F(x)/m$。当 $m=1$ 时，这简化为 $a(x) = F(x) = -4\\alpha x (x^2 - x_0^2)$。我们将实现两种二阶辛积分器：速度 Verlet 和蛙跳法。\n\n**1. 速度 Verlet 积分器**\n\n该算法将时间 $t_n = n\\Delta t$ 的状态 $(x_n, v_n)$ 传播到时间 $t_{n+1}$ 的状态 $(x_{n+1}, v_{n+1})$。位置和速度在整数时间步上是同步的。\n\n更新规则如下：\n1.  计算新位置：\n    $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n    其中 $a_n = a(x_n)$。\n2.  计算新位置处的加速度：\n    $$a_{n+1} = a(x_{n+1})$$\n3.  计算新速度：\n    $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n\n**2. 蛙跳积分器（交错时间格式）**\n\n该算法通常将速度在半整数时间步 $t_{n+1/2} = (n+1/2)\\Delta t$ 进行计算，而位置则在整数时间步 $t_n$。\n\n主循环的更新规则是：\n1.  更新位置：\n    $$x_{n+1} = x_n + v_{n+1/2} \\Delta t$$\n2.  将速度更新到下一个半步：\n    $$v_{n+3/2} = v_{n+1/2} + a_{n+1} \\Delta t$$\n    其中 $a_{n+1} = a(x_{n+1})$。\n\n为了从 $(x_0, v_0)$ 初始化此方案，并在与最终位置 $x_N$ 相同的时间 $T=N\\Delta t$ 获得最终速度 $v_N$，需要特殊的半步操作：\n-   **初始化**：需要对速度进行一次初步的半步“踢”，以启动循环：\n    $$v_{1/2} = v_0 + \\frac{1}{2} a_0 \\Delta t$$\n-   **终结**：计算出最终位置 $x_N$ 后，通过最后的半步“踢”来同步速度：\n    $$v_N = v_{N-1/2} + \\frac{1}{2} a_N \\Delta t$$\n\n在数值分析中，一个众所周知的结果是，速度 Verlet 和这种特定的蛙跳积分器实现在数学上是等价的。假设浮点运算完全相同，它们将产生相同的轨迹。我们的实现将按照要求，遵循它们各自不同的算法表述。\n\n**3. 模拟与分析**\n\n对于每个测试用例和每个积分器：\n1.  对每个指定的 $\\Delta t$ 运行一次模拟。总步数为 $N = \\text{round}(T/\\Delta t)$。\n2.  计算初始能量 $E_0 = E(0) = \\frac{1}{2} m v(0)^2 + V(x(0))$。\n3.  系统演化 $N$ 步。在每一步中，我们检查不稳定性（$|x|  10^6$、$|v|  10^6$ 或非有限值）。如果发生不稳定性，则终止运行，并将漂移标记为未定义（例如 `np.nan`）。\n4.  如果模拟完成，则计算最终能量 $E_T = E(N\\Delta t)$，并计算漂移 $D(\\Delta t) = |E_T - E_0|/|E_0|$。\n5.  在对所有 $\\Delta t$ 运行模拟后，找到标度指数 $n$。我们收集所有稳定运行且 $D  0$ 的 $(\\Delta t, D)$ 对。然后对其对数值进行线性回归：$\\log D = n \\log(\\Delta t) + \\text{const}$。此拟合的斜率即为 $n$。这至少需要两个有效的数据点。\n6.  通过找到所有稳定的 $\\Delta t$（其漂移 $D(\\Delta t)$ 小于或等于特定情况的容差 $\\tau$）来确定最优 $\\Delta t$ 区域。该集合中的最小值和最大值构成了该区域的边界。\n\n这种结构化的方法确保满足所有问题要求，并最终形成 Python 实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, process test cases, and print results.\n    \"\"\"\n    # Define test cases as per the problem statement.\n    test_cases = [\n        {\n            \"alpha\": 1.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 20.0,\n            \"x_init\": 0.9, \"v_init\": 0.0,\n            \"dts\": [0.002, 0.004, 0.008, 0.016, 0.032],\n            \"tau\": 1e-3\n        },\n        {\n            \"alpha\": 5.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 10.0,\n            \"x_init\": 0.8, \"v_init\": 0.0,\n            \"dts\": [0.001, 0.002, 0.004, 0.008],\n            \"tau\": 5e-4\n        },\n        {\n            \"alpha\": 1.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 20.0,\n            \"x_init\": 0.0, \"v_init\": 0.5,\n            \"dts\": [0.002, 0.004, 0.008, 0.016],\n            \"tau\": 2e-3\n        }\n    ]\n\n    # Helper functions for the physics\n    def potential(x, alpha, x0_pot):\n        return alpha * (x**2 - x0_pot**2)**2\n\n    def acceleration(x, m, alpha, x0_pot):\n        force = -4 * alpha * x * (x**2 - x0_pot**2)\n        return force / m\n\n    def total_energy(x, v, m, alpha, x0_pot):\n        return 0.5 * m * v**2 + potential(x, alpha, x0_pot)\n\n    def run_velocity_verlet(params):\n        \"\"\"\n        Runs a simulation using the velocity Verlet integrator.\n        \"\"\"\n        x = params['x_init']\n        v = params['v_init']\n        dt = params['dt']\n        n_steps = int(round(params['T'] / dt))\n        stability_bound = 1e6\n\n        a = acceleration(x, params['m'], params['alpha'], params['x0'])\n        \n        for _ in range(n_steps):\n            x = x + v * dt + 0.5 * a * dt**2\n            a_new = acceleration(x, params['m'], params['alpha'], params['x0'])\n            v = v + 0.5 * (a + a_new) * dt\n            a = a_new\n            \n            if not (np.isfinite(x) and np.isfinite(v) and abs(x)  stability_bound and abs(v)  stability_bound):\n                return np.nan, np.nan\n        \n        return x, v\n\n    def run_leap_frog(params):\n        \"\"\"\n        Runs a simulation using the leap-frog integrator (staggered time).\n        \"\"\"\n        x = params['x_init']\n        v = params['v_init']\n        dt = params['dt']\n        n_steps = int(round(params['T'] / dt))\n        stability_bound = 1e6\n\n        a = acceleration(x, params['m'], params['alpha'], params['x0'])\n        v_half = v + 0.5 * a * dt\n        \n        for _ in range(n_steps):\n            x = x + v_half * dt\n            \n            if not (np.isfinite(x) and abs(x)  stability_bound):\n                return np.nan, np.nan\n            \n            a = acceleration(x, params['m'], params['alpha'], params['x0'])\n            v_half = v_half + a * dt\n            \n            # Use v_half as a proxy for velocity magnitude check\n            if not (np.isfinite(v_half) and abs(v_half)  stability_bound):\n                return np.nan, np.nan\n\n        # Final half-step to synchronize velocity\n        v_final = v_half - 0.5 * a * dt\n        return x, v_final\n\n    def analyze_results(dts, drifts, tau):\n        \"\"\"\n        Analyzes simulation results to find scaling exponent and optimal regime.\n        \"\"\"\n        # Prepare data for scaling exponent calculation\n        log_dts_stable = []\n        log_drifts_stable = []\n        for dt, drift in zip(dts, drifts):\n            if np.isfinite(drift) and drift > 0:\n                log_dts_stable.append(np.log(dt))\n                log_drifts_stable.append(np.log(drift))\n        \n        # Calculate scaling exponent n\n        if len(log_dts_stable)  2:\n            n = np.nan\n        else:\n            res = linregress(log_dts_stable, log_drifts_stable)\n            n = round(res.slope, 2)\n            \n        # Find optimal dt regime\n        optimal_dts = []\n        for dt, drift in zip(dts, drifts):\n            if np.isfinite(drift) and drift = tau:\n                optimal_dts.append(dt)\n        \n        if not optimal_dts:\n            dt_min, dt_max = np.nan, np.nan\n        else:\n            dt_min = round(min(optimal_dts), 3)\n            dt_max = round(max(optimal_dts), 3)\n            \n        return n, dt_min, dt_max\n\n    all_case_results = []\n    integrators = {\"LF\": run_leap_frog, \"VV\": run_velocity_verlet}\n\n    for case in test_cases:\n        case_results = {}\n        for name, integrator_func in integrators.items():\n            drifts = []\n            for dt_val in case['dts']:\n                sim_params = case.copy()\n                sim_params['dt'] = dt_val\n                \n                e_initial = total_energy(case['x_init'], case['v_init'], case['m'], case['alpha'], case['x0'])\n                \n                x_final, v_final = integrator_func(sim_params)\n                \n                if not np.isfinite(x_final):\n                    drift = np.nan\n                else:\n                    e_final = total_energy(x_final, v_final, case['m'], case['alpha'], case['x0'])\n                    # Avoid division by zero if E(0) is zero.\n                    if abs(e_initial)  1e-15:\n                        drift = abs(e_final - e_initial)\n                    else:\n                        drift = abs(e_final - e_initial) / abs(e_initial)\n                \n                drifts.append(drift)\n            \n            n, dt_min, dt_max = analyze_results(case['dts'], drifts, case['tau'])\n            case_results[name] = [n, dt_min, dt_max]\n\n        all_case_results.append([\n            case_results[\"LF\"][0], case_results[\"VV\"][0],\n            case_results[\"LF\"][1], case_results[\"LF\"][2],\n            case_results[\"VV\"][1], case_results[\"VV\"][2]\n        ])\n\n    # Final print statement in the exact required format.\n    # Convert numpy.nan to float('nan') for string representation as 'nan'\n    formatted_results = []\n    for case_res in all_case_results:\n        formatted_case = []\n        for item in case_res:\n            if np.isnan(item):\n                formatted_case.append(float('nan'))\n            else:\n                formatted_case.append(item)\n        formatted_results.append(formatted_case)\n    \n    print(str(formatted_results).replace(\" \", \"\").replace(\"'\",\"\"))\n\nsolve()\n```", "id": "3420524"}, {"introduction": "Verlet积分器在处理平滑势能时表现出色，但其鲁棒性依赖于力的良好数学性质。当理论分析的核心假设——力的李普希茨连续性（Lipschitz continuity）——被破坏时会发生什么？本练习通过一个尖点势（cusp potential）$V(q) = |q|$来探讨这一问题，该势能产生的力在原点是不连续的[@problem_id:3420474]。这项实践不仅揭示了数值方法的局限性，还引入了“正则化”（regularization）这一强大的实用技术，它被广泛用于处理物理模型中遇到的奇异或非平滑特征。", "problem": "考虑一个质量为 $m$ 的一维粒子，在不含时势能函数 $V(q)$ 的作用下运动。该运动遵循牛顿第二定律 $m \\,\\mathrm{d}^{2}q/\\mathrm{d}t^{2} = F(q)$，其中 $F(q) = -\\mathrm{d}V/\\mathrm{d}q$。你将研究在力于某一点非Lipschitz时，分子动力学中常用的两种辛积分器（即蛙跳法和速度Verlet方法）的表现。具体来说，考虑尖点势 $V(q) = |q|$，它产生的分段常数力 $F(q) = -\\mathrm{sign}(q)$ 在 $q=0$ 处无定义，并且在 $q=0$ 的任何邻域内都是非Lipschitz的。你将研究这些积分器在这种势下的失效模式，然后测试在 $q=0$ 附近平滑尖点以恢复力的Lipschitz连续性的正则化策略。\n\n你的任务是：\n- 从牛顿第二定律出发，实现蛙跳法和速度Verlet方法，不使用任何预封装的常微分方程求解器。\n- 实现三种势：\n  - 尖点势 $V(q)=|q|$，采用朴素约定 $F(0)=0$。\n  - 一种由 $\\varepsilon  0$ 参数化的平滑正则化 $V_{\\varepsilon}(q) = \\sqrt{q^{2} + \\varepsilon^{2}}$，其产生的力为 $F_{\\varepsilon}(q) = -q/\\sqrt{q^{2} + \\varepsilon^{2}}$。\n  - 一种Huber型正则化 $V_{\\delta}(q)$，定义为：当 $|q| \\le \\delta$ 时，$V_{\\delta}(q) = \\frac{q^{2}}{2\\delta}$；当 $|q|  \\delta$ 时，$V_{\\delta}(q) = |q| - \\frac{\\delta}{2}$。其产生的力为：当 $|q| \\le \\delta$ 时，$F_{\\delta}(q) = -q/\\delta$；当 $|q|  \\delta$ 时，$F_{\\delta}(q) = -\\mathrm{sign}(q)$。\n- 对于每次模拟，在等间隔的时间点 $t_{n} = n\\,\\Delta t$（$n=0,1,\\dots,N$）上计算离散总能量 $E_{n} = \\frac{1}{2} m v_{n}^{2} + V(q_{n})$。其中时间步长为 $\\Delta t$，总积分时间为 $T = N \\,\\Delta t$。\n- 通过对 $\\{(t_{n}, E_{n})\\}_{n=0}^{N}$ 拟合一条最小二乘直线 $E(t) \\approx s\\,t + b$ 来量化长期能量漂移，并报告拟合的斜率 $s$。\n- 此斜率 $s$ 是你每次测试的标量性能指标。由于所有量都将以无量纲单位处理，请以无量纲能量每单位时间报告 $s$。\n\n科学和数值要求：\n- 从牛顿第二定律以及速度和加速度的标准定义出发。\n- 不使用任何预封装的常微分方程求解器。\n- 使用无量纲单位，设 $m=1$，并以相同的无量纲单位（能量每单位时间）报告能量漂移斜率 $s$。\n- 不涉及角度，因此不需要角度单位。\n\n测试套件：\n使用以下测试用例，每个用例由一个参数元组 $(\\text{integrator}, \\text{potential}, \\Delta t, T, q_{0}, v_{0}, \\text{reg\\_param})$ 定义。其中，所有用例中 $m=1$，积分器为蛙跳法或速度Verlet方法，势为上述三种之一，对于尖点势，$\\text{reg\\_param}$ 未被使用。对于平滑正则化，使用 $\\varepsilon$ 作为 $\\text{reg\\_param}$；对于Huber正则化，使用 $\\delta$ 作为 $\\text{reg\\_param}$。\n\n- 用例 A: $(\\text{速度Verlet}, \\text{尖点势}, \\Delta t = 0.05, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$。\n- 用例 B: $(\\text{蛙跳法}, \\text{尖点势}, \\Delta t = 0.05, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$。\n- 用例 C: $(\\text{速度Verlet}, \\text{尖点势}, \\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$。\n- 用例 D: $(\\text{速度Verlet}, \\text{平滑}, \\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\varepsilon = 10^{-2})$。\n- 用例 E: $(\\text{蛙跳法}, \\text{Huber}, \\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\delta = 10^{-2})$。\n- 用例 F: $(\\text{速度Verlet}, \\text{尖点势}, \\Delta t = 0.05, T = 20.0, q_{0} = 0.0, v_{0} = 0.1, \\text{reg\\_param} = \\text{None})$。\n\n你的程序应：\n- 实现所述的两种积分器和所有三种势。\n- 对于每个测试用例，以步长 $\\Delta t$ 积分至时间 $T$，计算序列 $\\{(t_{n}, E_{n})\\}_{n=0}^{N}$，并输出 $E$ 相对于 $t$ 的最小二乘斜率 $s$。\n- 按顺序将用例 A 到 F 的斜率汇总到单行输出中，结果为一个用方括号括起来的逗号分隔列表，例如 $[\\text{result\\_A}, \\text{result\\_B}, \\dots, \\text{result\\_F}]$。\n\n所有输出都必须以指定的无量纲能量每单位时间进行报告。最终输出必须严格遵循上述格式，仅占一行，无任何附加文本或换行。", "solution": "该问题要求实现并比较两种数值积分器（蛙跳法和速度Verlet方法），用于求解质量为 $m=1$ 的一维粒子在势 $V(q)$ 下的运动。重点是当力 $F(q) = -\\mathrm{d}V/\\mathrm{d}q$ 为非Lipschitz时这些积分器的表现，特别是对于尖点势 $V(q)=|q|$。同时，也研究了两种正则化策略。性能指标是长期能量漂移，通过对总能量时间序列进行线性最小二乘拟合得到的斜率 $s$ 来量化。\n\n1. 势函数和力函数\n我们实现三种指定的势能函数及其对应的力。所有物理量均采用无量纲单位。\n\n1.1. 尖点势\n势为 $V(q) = |q|$。力为 $F(q) = -\\mathrm{d}V/\\mathrm{d}q = -\\mathrm{sign}(q)$。在 $q=0$ 处，导数无定义。问题指定了约定 $F(0)=0$。这可以由数值库自然处理，因为在这些库中 $\\mathrm{sign}(0)=0$。\n\n1.2. 平滑正则化\n势为 $V_{\\varepsilon}(q) = \\sqrt{q^2 + \\varepsilon^2}$，由 $\\varepsilon  0$ 参数化。对应的力为 $F_{\\varepsilon}(q) = -q/\\sqrt{q^2 + \\varepsilon^2}$。当 $\\varepsilon  0$ 时，该力函数是平滑的，并且在 $\\varepsilon$ 很小且 $|q| \\gg \\varepsilon$ 时，近似于 $-\\mathrm{sign}(q)$。\n\n1.3. Huber型正则化\n该势是分段定义的：\n$$\nV_{\\delta}(q) = \n\\begin{cases} \n\\frac{q^2}{2\\delta}  \\text{若 } |q| \\le \\delta \\\\\n|q| - \\frac{\\delta}{2}  \\text{若 } |q|  \\delta \n\\end{cases}\n$$\n该势是连续可微的。力为：\n$$\nF_{\\delta}(q) = \n\\begin{cases} \n-q/\\delta  \\text{若 } |q| \\le \\delta \\\\\n-\\mathrm{sign}(q)  \\text{若 } |q|  \\delta \n\\end{cases}\n$$\n该力是连续且Lipschitz的，为正则化尖点提供了另一种方法。\n\n2. 数值积分器\n我们从牛顿第二定律 $m\\ddot{q} = F(q)$ 出发，对于 $m=1$ 即为 $\\ddot{q} = F(q)$。设 $q_n$、$v_n$ 和 $a_n$ 分别为时间 $t_n = n\\Delta t$ 时的位置、速度和加速度。\n\n2.1. 速度Verlet方法\n速度Verlet算法按如下方式更新位置和速度：\n1. $q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$\n2. $a_{n+1} = F(q_{n+1})/m$\n3. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$\n该方法是时间可逆和辛的，对于平滑势通常能实现良好的长期能量守恒。每个时间步长需要一次力计算。量 $q_n$ 和 $v_n$ 在整数时间步上是同步的，这允许直接计算能量 $E_n = \\frac{1}{2}mv_n^2 + V(q_n)$。\n\n2.2. 蛙跳法\n“蛙跳法”这一术语可指代几种代数上等价的公式。常见的一种是“踢-漂移-踢”（KDK）形式，也称为位置更新形式或LF2。该方法在代数上与速度Verlet方法完全相同。其步骤如下：\n1. (踢) $v_{n+1/2} = v_n + \\frac{1}{2} a_n \\Delta t$\n2. (漂移) $q_{n+1} = q_n + v_{n+1/2} \\Delta t$\n3. (踢) $v_{n+1} = v_{n+1/2} + \\frac{1}{2} a_{n+1} \\Delta t$, 其中 $a_{n+1} = F(q_{n+1})/m$。\n通过在相同的整数时间步上提供位置和速度，这种形式也便于直接计算能量。鉴于其与速度Verlet方法的代数等价性，我们预期模拟轨迹以及因此产生的能量漂移，在浮点精度差异范围内是相同的。问题中包含比较这两种方法的测试用例，很可能是为了验证这种等价性。\n\n3. 模拟与分析\n对于每个测试用例，系统使用固定的时间步长 $\\Delta t$ 从 $t=0$ 积分到 $T$，生成一系列位置和速度。在每一步 $n=0, 1, \\dots, N$（其中 $N=T/\\Delta t$）计算总能量 $E_n = \\frac{1}{2} m v_n^2 + V(q_n)$。\n长期能量漂移通过对离散能量数据点 $\\{(t_n, E_n)\\}_{n=0}^N$ 拟合一条简单线性回归线得到的斜率 $s$ 来量化。这通过使用 `numpy.polyfit(t, E, 1)` 来计算，该函数提供鲁棒且标准的最小二乘拟合。得到的斜率 $s$ 代表了整个模拟过程中的平均能量变化率。\n\n4. 实现细节\n模拟使用 Python 和 `numpy` 库实现。为每种势和积分器创建了专用函数。一个主控制循环遍历指定的测试用例，运行相应的模拟，计算能量漂移斜率，并收集结果。\n步数 $N$ 通过 `int(round(T/dt))` 计算，以避免浮点数不精确性。时间数组使用 `numpy.linspace(0, T, N + 1)` 生成，以确保最终时间点恰好是 $T$。\n对于尖点势，`numpy.sign(0)` 会返回 $0$，从而正确处理了 $F(0)=0$ 的约定。\n测试用例 A 到 F 的最终斜率列表被格式化为指定的字符串表示形式。", "answer": "```python\nimport numpy as np\n\ndef V_cusp(q):\n    \"\"\"Cusp potential V(q) = |q|.\"\"\"\n    return np.abs(q)\n\ndef F_cusp(q):\n    \"\"\"Force for cusp potential, F(q) = -sign(q), with F(0)=0.\"\"\"\n    return -np.sign(q)\n\ndef V_smooth(q, eps):\n    \"\"\"Smoothly regularized potential.\"\"\"\n    return np.sqrt(q**2 + eps**2)\n\ndef F_smooth(q, eps):\n    \"\"\"Force for smoothly regularized potential.\"\"\"\n    denom = np.sqrt(q**2 + eps**2)\n    return -q / denom if denom != 0 else 0.0\n\ndef V_huber(q, delta):\n    \"\"\"Huber-type regularized potential.\"\"\"\n    if np.abs(q) = delta:\n        return 0.5 * q**2 / delta\n    else:\n        return np.abs(q) - 0.5 * delta\n\ndef F_huber(q, delta):\n    \"\"\"Force for Huber-type regularized potential.\"\"\"\n    if np.abs(q) = delta:\n        return -q / delta\n    else:\n        return -np.sign(q)\n\ndef velocity_verlet(F_func, V_func, q0, v0, dt, N, m):\n    \"\"\"Velocity Verlet integrator.\"\"\"\n    q = np.zeros(N + 1)\n    v = np.zeros(N + 1)\n    E = np.zeros(N + 1)\n    \n    q[0] = q0\n    v[0] = v0\n    E[0] = 0.5 * m * v[0]**2 + V_func(q[0])\n    \n    a_curr = F_func(q[0]) / m\n    \n    for n in range(N):\n        q[n+1] = q[n] + v[n] * dt + 0.5 * a_curr * dt**2\n        a_next = F_func(q[n+1]) / m\n        v[n+1] = v[n] + 0.5 * (a_curr + a_next) * dt\n        E[n+1] = 0.5 * m * v[n+1]**2 + V_func(q[n+1])\n        a_curr = a_next\n        \n    return E\n\ndef leap_frog(F_func, V_func, q0, v0, dt, N, m):\n    \"\"\"Leap-frog integrator (kick-drift-kick formulation).\"\"\"\n    q_curr = q0\n    v_curr = v0\n    E = np.zeros(N + 1)\n    E[0] = 0.5 * m * v_curr**2 + V_func(q_curr)\n    \n    a_curr = F_func(q_curr) / m\n    \n    for n in range(N):\n        v_half = v_curr + 0.5 * a_curr * dt\n        q_curr = q_curr + v_half * dt\n        a_curr = F_func(q_curr) / m\n        v_curr = v_half + 0.5 * a_curr * dt\n        E[n+1] = 0.5 * m * v_curr**2 + V_func(q_curr)\n        \n    return E\n\ndef run_simulation(integrator_name, potential_name, dt, T, q0, v0, reg_param):\n    \"\"\"Runs a single simulation and returns the energy drift slope.\"\"\"\n    m = 1.0\n    N = int(round(T / dt))\n    t = np.linspace(0, T, N + 1)\n\n    if potential_name == 'cusp':\n        V_func = V_cusp\n        F_func = F_cusp\n    elif potential_name == 'smooth':\n        V_func = lambda q: V_smooth(q, reg_param)\n        F_func = lambda q: F_smooth(q, reg_param)\n    elif potential_name == 'Huber':\n        V_func = lambda q: V_huber(q, reg_param)\n        F_func = lambda q: F_huber(q, reg_param)\n    else:\n        raise ValueError(f\"Unknown potential: {potential_name}\")\n\n    if integrator_name == 'velocity Verlet':\n        integrator_func = velocity_verlet\n    elif integrator_name == 'leap-frog':\n        integrator_func = leap_frog\n    else:\n        raise ValueError(f\"Unknown integrator: {integrator_name}\")\n\n    E = integrator_func(F_func, V_func, q0, v0, dt, N, m)\n    \n    slope, _ = np.polyfit(t, E, 1)\n    \n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        ('velocity Verlet', 'cusp', 0.05, 20.0, 0.1, 0.0, None),\n        # Case B\n        ('leap-frog', 'cusp', 0.05, 20.0, 0.1, 0.0, None),\n        # Case C\n        ('velocity Verlet', 'cusp', 0.2, 20.0, 0.1, 0.0, None),\n        # Case D\n        ('velocity Verlet', 'smooth', 0.2, 20.0, 0.1, 0.0, 1e-2),\n        # Case E\n        ('leap-frog', 'Huber', 0.2, 20.0, 0.1, 0.0, 1e-2),\n        # Case F\n        ('velocity Verlet', 'cusp', 0.05, 20.0, 0.0, 0.1, None),\n    ]\n\n    results = []\n    for case in test_cases:\n        slope = run_simulation(*case)\n        results.append(slope)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3420474"}]}