{"hands_on_practices": [{"introduction": "理论的生命力在于实践。本章的第一个练习将作为后续探索的基石。我们将亲手实现并直接比较一个辛积分器（速度 Verlet 算法）和一个非辛积分器（经典的四阶 Runge-Kutta 算法）。通过测量能量漂移、能量涨落和时间可逆性误差，你将亲身体会到这两类算法在实际应用中的巨大差异，并掌握评估模拟质量的基本诊断工具。[@problem_id:3409941]", "problem": "考虑一个分子动力学中确定性的、封闭的经典系统，其哈密顿量为 $H(q,p) = T(p) + U(q)$，其中 $q$ 表示位置，$p$ 表示动量，$T(p)$ 是动能，$U(q)$ 是势能。精确的动力学遵循牛顿第二定律和哈密顿方程，确保总能量 $E(t) = H(q(t),p(t))$ 守恒，即对于连续轨迹有 $dE/dt = 0$。在时间步长为 $\\Delta t$ 的离散时间数值模拟中，数值流（numerical flow）取决于所用的积分器。辛的、时间可逆的积分器（例如，速度Verlet方法）已知在长时间内能近似守恒一个修正的（影子）哈密顿量，而通用的非辛积分器（例如，经典的四阶Runge–Kutta方法）可能会表现出长期的能量漂移。能量审计和诊断可以量化一个算法在给定系统上的能量守恒性、漂移和长期稳定性。\n\n您的任务是为两个系统实现两种数值积分器，运行长轨迹，并为每个测试案例计算三个诊断指标：\n\n- 线性能量漂移率 $s$，定义为 $\\Delta E(t) = E(t) - E(0)$ 作为 $t$ 的函数的最小二乘拟合的斜率。\n- 减去最佳拟合直线后，$\\Delta E(t)$ 的均方根涨落幅度 $R$，即拟合残差平方均值的平方根。\n- 时间可逆性误差 $J$，其计算方法为：向前积分 $N$ 步，反转速度，再积分 $N$ 步，并测量最终状态与初始状态之间的欧几里得相空间误差。\n\n您的工作仅需基于以下基本定律和定义：\n- 牛顿第二定律：$m \\, \\ddot{q} = F(q)$，其中 $F(q) = - \\nabla U(q)$。\n- 运动学：$\\dot{q} = v$，$\\dot{v} = a(q)$，其中 $a(q) = F(q)/m$。\n- 适用于每个系统的动能和势能定义。\n- 应用于 $(q,v)$ 一阶系统的标准、广泛使用的数值方案（速度Verlet和经典四阶Runge–Kutta）。\n\n在约化单位下，为两个封闭系统实现这两种积分器：\n\n系统A（一维谐振子）：\n- 质量 $m = 1$。\n- 劲度系数 $k = 1$。\n- 力 $F(x) = -k x$。\n- 能量 $E = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2$。\n\n系统B（三维双粒子Lennard–Jones二聚体）：\n- 两个质量为 $m = 1$ 的相同粒子。\n- Lennard–Jones参数 $\\varepsilon = 1$，$\\sigma = 1$。对于粒子间距 $r$，对势为 $U(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$。\n- 力是中心力，作用在两个粒子上大小相等、方向相反。\n- 能量 $E = \\sum_{i=1}^{2} \\tfrac{1}{2} m \\|v_i\\|^2 + U(\\|r_1 - r_2\\|)$。\n\n每个测试案例需计算的诊断指标：\n- 将 $\\Delta E(t)$ 拟合为一条直线 $\\Delta E(t) \\approx s \\, t + b$，通过对包括 $t = 0$ 在内的整个轨迹进行最小二乘法，并报告拟合的斜率 $s$。\n- 报告 $R = \\sqrt{\\tfrac{1}{M} \\sum_{j=1}^{M} [\\Delta E(t_j) - (s \\, t_j + b)]^2}$，其中 $M$ 是采样的时间点数量。\n- 对于时间可逆性，从 $(q_0,v_0)$ 开始，向前积分 $N$ 步到 $(q_N, v_N)$，设置 $(q^*, v^*) = (q_N, -v_N)$，再向前积分 $N$ 步到 $(\\tilde{q}, \\tilde{v})$，并报告 $J = \\sqrt{\\| \\tilde{q} - q_0 \\|^2 + \\| \\tilde{v} - v_0 \\|^2}$。\n\n使用以下测试套件。所有量均以约化单位指定，所有输出必须报告为十进制浮点数，其中 $s$ 的单位是约化能量单位每单位时间， $R$ 的单位是约化能量单位，$J$ 的单位是约化单位。\n\n测试案例1（系统A，速度Verlet）：\n- 初始条件：$x(0) = 1$, $v(0) = 0$。\n- 时间步长：$\\Delta t = 0.1$。\n- 步数：$N = 20000$。\n\n测试案例2（系统A，经典四阶Runge–Kutta）：\n- 初始条件：$x(0) = 1$, $v(0) = 0$。\n- 时间步长：$\\Delta t = 0.1$。\n- 步数：$N = 20000$。\n\n测试案例3（系统B，速度Verlet）：\n- 初始位置：$r_1(0) = (-0.65, 0, 0)$, $r_2(0) = (0.65, 0, 0)$，因此初始间距为 $r(0) = 1.3$。\n- 初始速度：$v_1(0) = (0, 0, 0)$, $v_2(0) = (0, 0, 0)$。\n- 时间步长：$\\Delta t = 0.002$。\n- 步数：$N = 20000$。\n\n测试案例4（系统A，速度Verlet，接近稳定性边界）：\n- 初始条件：$x(0) = 1$, $v(0) = 0$。\n- 时间步长：$\\Delta t = 1.9$。\n- 步数：$N = 5000$。\n\n数值要求：\n- 实现应用于 $(q,v)$ 一阶系统的速度Verlet和经典四阶Runge–Kutta积分器。\n- 使用双精度算术。\n- 在回归分析中，采样并使用从 $t=0$ 到 $t=N\\Delta t$（包含两端）的每个整数倍 $\\Delta t$ 处的能量。\n- 最小二乘拟合必须包含截距 $b$。\n- 时间可逆性测试使用与每个案例的能量审计相同的 $\\Delta t$ 和 $N$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试案例，并且本身是一个按顺序排列的三元素列表 $[s,R,J]$。例如，生成形如 $[[s_1,R_1,J_1],[s_2,R_2,J_2],[s_3,R_3,J_3],[s_4,R_4,J_4]]$ 的行，不含内嵌空格。", "solution": "该问题要求对分子动力学中两种常用的积分算法进行数值研究：速度Verlet方法和经典的四阶Runge-Kutta (RK4) 方法。这项研究将在两个代表性的物理系统上进行：一个一维谐振子和一个三维双粒子Lennard-Jones系统。任务的核心是量化这些积分器的三个关键性能指标：长期能量漂移率（$s$）、能量涨落幅度（$R$）和时间可逆性误差（$J$）。此分析突显了在守恒系统长期模拟的背景下，辛的、时间可逆的积分器与通用的、非辛的积分器之间的根本差异。\n\n**数值积分算法**\n\n系统的动力学由牛顿第二定律决定，可以表示为一个一阶常微分方程（ODE）组：\n$$\n\\frac{d\\mathbf{q}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{q}) = \\frac{\\mathbf{F}(\\mathbf{q})}{m}\n$$\n其中 $\\mathbf{q}$、$\\mathbf{v}$ 和 $\\mathbf{a}$ 分别是广义位置、速度和加速度，$m$ 是质量。\n\n**速度Verlet积分器**\n速度Verlet算法是一种几何积分器，专为哈密顿系统设计。它通过以下步骤将状态从时间 $t$推进到 $t+\\Delta t$：\n1. 将速度更新到半步：\n$$\n\\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) = \\mathbf{v}(t) + \\tfrac{1}{2}\\mathbf{a}(t)\\Delta t\n$$\n2. 将位置更新到完整步长：\n$$\n\\mathbf{q}(t + \\Delta t) = \\mathbf{q}(t) + \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t)\\Delta t\n$$\n3. 根据新位置 $\\mathbf{q}(t+\\Delta t)$ 处的力计算新加速度 $\\mathbf{a}(t+\\Delta t)$。\n4. 完成速度到完整步长的更新：\n$$\n\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) + \\tfrac{1}{2}\\mathbf{a}(t + \\Delta t)\\Delta t\n$$\n速度Verlet方法的关键特性是它既是辛的又是时间可逆的。辛性确保积分器精确地保持一个“影子”哈密顿量，这是一个与系统真实哈密顿量非常接近的守恒量。这导致测量的能量 $E(t)$ 在其初始值附近有界振荡，并排除了系统性的长期能量漂移。时间可逆性确保了在时间上向后积分可以完美地撤销向前积分的步骤，这一特性对长期稳定性至关重要。\n\n**经典四阶Runge-Kutta (RK4) 积分器**\nRK4方法是一种广泛使用的高精度、通用ODE求解器。对于一阶系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$，其中状态向量为 $\\mathbf{y} = (\\mathbf{q}, \\mathbf{v})$，不依赖时间的导数为 $f(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{q}))$，从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的单步计算如下：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n中间阶段的向量 $\\mathbf{k}_i$ 计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n\\end{aligned}\n$$\n虽然RK4具有很高的局部精度（步长误差为 $O(\\Delta t^5)$），但它不是一个辛算法。因此，它不守恒一个影子哈密顿量，并且对于哈密顿系统，通常会在长时间的模拟中引入总能量的长期（系统性）漂移。它也不是时间可逆的，这是导致其在这种情况下长期稳定性差的另一个因素。\n\n**物理系统**\n\n**系统A：一维谐振子**\n这是一个基本的线性系统，质量 $m=1$，劲度系数 $k=1$。\n- 势能：$U(x) = \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} x^2$\n- 力：$F(x) = -\\frac{dU}{dx} = -k x = -x$\n- 加速度：$a(x) = F(x)/m = -x$\n- 总能量：$E = T + U = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} v^2 + \\tfrac{1}{2} x^2$\n\n**系统B：三维Lennard-Jones二聚体**\n该系统由两个质量为 $m=1$ 的相同粒子组成，它们通过Lennard-Jones势相互作用，参数为 $\\varepsilon=1$ 和 $\\sigma=1$。设 $\\mathbf{r}_1, \\mathbf{r}_2$ 为位置矢量，$\\mathbf{v}_1, \\mathbf{v}_2$ 为速度矢量。粒子间距矢量为 $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2$，其大小为 $r = \\|\\mathbf{r}_{12}\\|_2$。\n- 势能：$U(r) = 4\\varepsilon [(\\frac{\\sigma}{r})^{12} - (\\frac{\\sigma}{r})^6] = 4(r^{-12} - r^{-6})$\n- 作用在粒子1上的力是 $\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U(r) = -\\frac{dU}{dr} \\frac{\\mathbf{r}_{12}}{r}$。势的导数是 $\\frac{dU}{dr} = 24\\varepsilon(\\sigma^6 r^{-7} - 2\\sigma^{12} r^{-13})$。使用给定参数，这变为：\n$$\n\\mathbf{F}_1 = -24(r^{-7} - 2r^{-13}) \\frac{\\mathbf{r}_{12}}{r} = 24(2r^{-14} - r^{-8})\\mathbf{r}_{12}\n$$\n- 根据牛顿第三定律，作用在粒子2上的力是 $\\mathbf{F}_2 = -\\mathbf{F}_1$。\n- 加速度为 $\\mathbf{a}_1 = \\mathbf{F}_1/m = \\mathbf{F}_1$ 和 $\\mathbf{a}_2 = \\mathbf{F}_2/m = \\mathbf{F}_2$。\n- 总能量：$E = \\sum_{i=1}^2 \\tfrac{1}{2}m_i \\|\\mathbf{v}_i\\|^2 + U(r) = \\tfrac{1}{2}(\\|\\mathbf{v}_1\\|^2 + \\|\\mathbf{v}_2\\|^2) + 4(r^{-12} - r^{-6})$。\n\n**诊断指标**\n\n对于4个测试案例中的每一个，都会计算三个诊断指标来评估积分器的性能。\n1.  **能量漂移率（$s$）和涨落幅度（$R$）**：在每个时间步 $t_j = j \\Delta t$（其中 $j \\in [0, N]$）计算总能量相对于其初始值的变化量 $\\Delta E(t_j) = E(t_j) - E(0)$。通过最小二乘法将这些数据拟合到一个线性模型 $\\Delta E(t) \\approx s t + b$。得到的斜率 $s$ 就是能量漂移率。此拟合残差的均方根 $R = \\sqrt{\\frac{1}{M} \\sum_{j=0}^{N} [\\Delta E(t_j) - (s t_j + b)]^2}$（其中 $M=N+1$），量化了能量在拟合漂移线周围的涨落幅度。\n2.  **时间可逆性误差（$J$）**：该指标量化了与完美时间可逆性的偏离程度。首先，从初始状态 $(\\mathbf{q}_0, \\mathbf{v}_0)$ 开始向前进行 $N$ 步模拟，到达最终状态 $(\\mathbf{q}_N, \\mathbf{v}_N)$。然后反转速度，得到 $(\\mathbf{q}_N, -\\mathbf{v}_N)$，并再次向前进行 $N$ 步模拟，到达状态 $(\\tilde{\\mathbf{q}}, \\tilde{\\mathbf{v}})$。误差是最终状态与初始状态在相空间中的欧几里得距离：\n    $$\n    J = \\sqrt{\\| \\tilde{\\mathbf{q}} - \\mathbf{q}_0 \\|^2 + \\| \\tilde{\\mathbf{v}} - \\mathbf{v}_0 \\|^2}\n    $$\n    对于一个完美的时间可逆积分器和精确算术， $J$ 将为零。\n\n**实现策略**\n该解决方案使用Python语言和`numpy`库来实现，以便进行高效的矢量化计算。一个主函数 `solve` 负责协调4个测试案例。对于每个案例，通过重复调用相应的积分步进函数（`step_verlet` 或 `step_rk4`）来执行模拟。这些步进函数被设计为通用的，接受当前状态和加速度函数作为输入。特定于系统的函数（`acc_ho`, `energy_ho`, `acc_lj`, `energy_lj`）提供物理模型。生成能量轨迹后，使用`numpy.polyfit`进行线性回归以确定 $s$ 和 $b$，并由此计算出 $R$。为了计算 $J$，会运行一个独立的模拟来进行时间可逆性测试。所有计算均以双精度算术执行。结果被收集并格式化为指定的字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy is sufficient as allowed.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # --- System A: 1D Harmonic Oscillator ---\n    def acc_ho(q, m=1.0, k=1.0):\n        \"\"\"Acceleration for 1D harmonic oscillator.\"\"\"\n        return -k * q / m\n\n    def energy_ho(q, v, m=1.0, k=1.0):\n        \"\"\"Total energy for 1D harmonic oscillator.\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * q**2\n\n    # --- System B: 3D Lennard-Jones Dimer ---\n    def acc_lj(q, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Acceleration for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check for particle overlap\n        if dist_sq == 0:\n            return np.zeros_like(q)\n\n        inv_dist_sq = 1.0 / dist_sq\n        inv_dist_6 = inv_dist_sq**3\n        \n        # Force calculation based on dU/dr\n        # F1 = 24 * epsilon * (2 * sigma^12 * r^-14 - sigma^6 * r^-8) * r12\n        force_mag_term = 24.0 * epsilon * (2.0 * (sigma**12) * inv_dist_6**2 * inv_dist_sq - (sigma**6) * inv_dist_6 * inv_dist_sq)\n        f1 = force_mag_term * r12\n        f2 = -f1\n        \n        # Since mass is 1 for both particles\n        a1 = f1 / m\n        a2 = f2 / m\n        \n        return np.array([a1, a2]).flatten()\n\n    def energy_lj(q, v, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Total energy for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        v1, v2 = v.reshape(2, 3)\n        \n        ke = 0.5 * m * (np.sum(v1**2) + np.sum(v2**2))\n        \n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check\n        if dist_sq == 0:\n            pe = np.inf\n        else:\n            inv_dist_sq = 1.0 / dist_sq\n            inv_dist_6 = inv_dist_sq**3\n            pe = 4.0 * epsilon * (inv_dist_6**2 - inv_dist_6)\n\n        return ke + pe\n\n    # --- Numerical Integrators ---\n    def step_verlet(q, v, dt, acc_func):\n        \"\"\"A single step of the velocity Verlet integrator.\"\"\"\n        a = acc_func(q)\n        v_half = v + 0.5 * dt * a\n        q_next = q + dt * v_half\n        a_next = acc_func(q_next)\n        v_next = v_half + 0.5 * dt * a_next\n        return q_next, v_next\n\n    def step_rk4(q, v, dt, acc_func):\n        \"\"\"A single step of the classical 4th-order Runge-Kutta integrator.\"\"\"\n        # k1\n        k1_q = v\n        k1_v = acc_func(q)\n        # k2\n        k2_q = v + 0.5 * dt * k1_v\n        k2_v = acc_func(q + 0.5 * dt * k1_q)\n        # k3\n        k3_q = v + 0.5 * dt * k2_v\n        k3_v = acc_func(q + 0.5 * dt * k2_q)\n        # k4\n        k4_q = v + dt * k3_v\n        k4_v = acc_func(q + dt * k3_q)\n        # update\n        q_next = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n        v_next = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n        return q_next, v_next\n\n    # --- Simulation and Diagnostics ---\n    def run_simulation(q0, v0, dt, N, step_func, acc_func, energy_func):\n        \"\"\"Runs a simulation and returns diagnostic metrics.\"\"\"\n        q, v = np.copy(q0), np.copy(v0)\n        \n        # Energy audit\n        energies = np.zeros(N + 1, dtype=np.float64)\n        energies[0] = energy_func(q, v)\n        \n        for i in range(1, N + 1):\n            q, v = step_func(q, v, dt, acc_func)\n            energies[i] = energy_func(q, v)\n\n        times = np.arange(N + 1) * dt\n        e0 = energies[0]\n        delta_e = energies - e0\n        \n        # Calculate s and R\n        s, b = np.polyfit(times, delta_e, 1)\n        residuals = delta_e - (s * times + b)\n        R = np.sqrt(np.mean(residuals**2))\n\n        # Time-reversibility test\n        q, v = np.copy(q0), np.copy(v0)\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        # Reverse and integrate back\n        v = -v\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        q_tilde, v_tilde = q, v\n        \n        # Calculate J\n        q_error = np.linalg.norm(q_tilde - q0)\n        v_error = np.linalg.norm(v_tilde - v0)\n        J = np.sqrt(q_error**2 + v_error**2)\n        \n        return s, R, J\n\n    test_cases = [\n        # Case 1: System A, Verlet\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 2: System A, RK4\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_rk4, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 3: System B, Verlet\n        dict(q0=np.array([-0.65, 0, 0, 0.65, 0, 0]), \n             v0=np.array([0, 0, 0, 0, 0, 0]), \n             dt=0.002, N=20000, \n             step_func=step_verlet, acc_func=acc_lj, energy_func=energy_lj),\n        # Case 4: System A, Verlet, near stability boundary\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=1.9, N=5000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, R, J = run_simulation(case['q0'], case['v0'], case['dt'], case['N'], \n                                   case['step_func'], case['acc_func'], case['energy_func'])\n        results.append([s, R, J])\n        \n    def format_list(lst):\n        return '[' + ','.join(f'{x:.8e}' for x in lst) + ']'\n    \n    # Custom formatting to remove spaces\n    result_str = '[' + ','.join(map(format_list, results)) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "3409941"}, {"introduction": "在观察到不同积分器的误差特性存在差异后，下一步自然是量化这种行为。本练习将引导你通过经验性测量，探究积分误差如何随时间步长 $\\Delta t$ 缩放。通过验证误差确实以 $\\mathcal{O}(\\Delta t^p)$ 的形式缩放，你将能够确认积分器的理论“阶数”，这是选择合适模拟参数的关键概念。[@problem_id:3409975]", "problem": "考虑一个确定性的微正则系综分子动力学（MD）模拟，该模拟在一个小系统中根据牛顿第二定律演化。其中，$N$个质量为$m$的相同粒子的位置$x_i(t)$和速度$v_i(t)$的运动方程由$m\\,\\dfrac{d^2 x_i}{dt^2} = F_i(x)$给出，其中$F_i(x) = -\\nabla_{x_i} V(x)$。假设总能量$E(x,v) = K(v) + V(x)$，其中动能为$K(v) = \\dfrac{1}{2} \\sum_{i=1}^{N} m\\, v_i^2$，势能$V(x)$是保守且不随时间变化的。该系统使用时间步长为$\\Delta t$的显式时间步进法进行数值积分。该数值积分器的方法阶数为$p$，意味着在固定的总时间后，状态变量的全局误差标度关系为$\\mathcal{O}(\\Delta t^p)$。\n\n您将测试两种边界条件设置下的长期能量守恒和漂移标度关系：周期性晶胞和固定软壁。目标是量化能量漂移度量如何随$\\Delta t^p$变化，并通过对数-对数拟合经验性地估计标度指数$p$。\n\n设置的基本原理：\n- 粒子$i$的牛顿第二定律：$m\\,\\dfrac{d^2 x_i}{dt^2} = F_i(x)$。\n- 速度定义为$v_i = \\dfrac{dx_i}{dt}$。\n- 总能量$E(t) = K(t) + V(t)$对于精确动力学必须是守恒的，因为势是时间无关的，且系统是孤立的（微正则系综）。\n\n系统规格：\n- 使用一维空间中的$N = 2$个粒子，其位置为$x_1$和$x_2$，速度为$v_1$和$v_2$。\n- 使用简化的Lennard-Jones单位：长度单位为$\\sigma$，能量单位为$\\varepsilon$，时间单位为$\\sigma \\sqrt{m/\\varepsilon}$。\n- 对相互作用通过在截断半径$r_c$处截断的力移位Lennard-Jones势来描述，以确保在$r_c$处力的连续性。定义未移位的Lennard-Jones势为\n$$\nV_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6\\right],\n$$\n其对应的力的大小（沿粒子间分离方向作用）为\n$$\nf_{\\mathrm{LJ}}(r) = 24\\varepsilon\\left[\\dfrac{2\\sigma^{12}}{r^{13}} - \\dfrac{\\sigma^6}{r^7}\\right] = 24\\varepsilon\\left[\\dfrac{2\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6}{r}\\right].\n$$\n设$r_c$为截断半径，并记$V_c = V_{\\mathrm{LJ}}(r_c)$和$f_c = f_{\\mathrm{LJ}}(r_c)$。对于$r  r_c$，力移位势和力为\n$$\nV_{\\mathrm{SF}}(r) = V_{\\mathrm{LJ}}(r) - V_c - (r - r_c)\\, \\left.\\dfrac{d V_{\\mathrm{LJ}}}{dr}\\right|_{r_c},\n$$\n$$\nf_{\\mathrm{SF}}(r) = f_{\\mathrm{LJ}}(r) - f_c,\n$$\n对于$r \\ge r_c$，两者均为零。在一维中，粒子$j$对粒子$i$的力为$F_{i \\leftarrow j} = f_{\\mathrm{SF}}(|r|)\\,\\mathrm{sign}(x_i - x_j)$，其中$r = x_i - x_j$。\n\n边界条件：\n- 长度为$L$的周期性晶胞：使用最小镜像约定计算粒子间距离。对于任意分离$r = x_2 - x_1$，定义$r_{\\mathrm{MIC}} = r - L\\,\\mathrm{round}(r/L)$，并在$V_{\\mathrm{SF}}$和$f_{\\mathrm{SF}}$中使用$|r_{\\mathrm{MIC}}|$。每步之后，位置应被包裹回主晶胞$[0,L)$内，以避免坐标无界；在最小镜像约定下，这种包裹不影响力。\n- $x=0$和$x=L$处的固定软壁：除对相互作用外，还为每个粒子引入一个光滑的排斥壁势，\n$$\nV_{\\mathrm{wall}}(x) = \\varepsilon_w \\left[\\left(\\dfrac{\\sigma_w}{x}\\right)^{12} + \\left(\\dfrac{\\sigma_w}{L - x}\\right)^{12}\\right],\n$$\n其对应的壁力为\n$$\nF_{\\mathrm{wall}}(x) = -\\dfrac{d V_{\\mathrm{wall}}}{dx} = 12 \\varepsilon_w \\sigma_w^{12}\\left[\\dfrac{1}{x^{13}} - \\dfrac{1}{(L - x)^{13}}\\right].\n$$\n\n要比较的数值积分器：\n- 速度Verlet（一种二阶辛方法）：使用标准的交错半步速度算法更新位置和速度。方法阶数$p = 2$。\n- 经典四阶龙格-库塔方法：将标准布彻表应用于状态$\\left[x, v\\right]$，其中$x' = v$，$v' = a(x) = F(x)/m$。方法阶数$p = 4$。\n\n能量漂移度量：\n- 对于给定的$\\Delta t$和总模拟时间$T$，在时间步$t_n = n\\,\\Delta t$（其中$n = 0, 1, \\dots, N_t$，$N_t = T/\\Delta t$）记录能量时间序列$E(t_n)$。\n- 定义能量偏差$\\delta E(t_n) = E(t_n) - E(0)$。\n- 定义均方根能量偏差\n$$\nD(\\Delta t) = \\sqrt{\\dfrac{1}{N_t + 1}\\sum_{n=0}^{N_t}\\left[\\delta E(t_n)\\right]^2}.\n$$\n通过对一组$\\Delta t$值的$\\log D(\\Delta t)$与$\\log \\Delta t$进行最小二乘拟合，经验性地估计标度指数$p$，并将斜率作为估计值$\\hat{p}$。\n\n所有测试通用的初始条件和参数（以简化单位表示）（除非明确改变）：\n- 粒子数：$N = 2$。\n- 质量：每个粒子$m = 1$。\n- Lennard-Jones参数：$\\varepsilon = 1$，$\\sigma = 1$，截断半径$r_c = 2.5$。\n- 晶胞长度：$L = 5$。\n- 壁参数（仅用于固定壁情况）：$\\varepsilon_w = 0.5$，$\\sigma_w = 0.5$。\n- 总模拟时间：$T = 10$。\n- 初始位置：$x_1(0) = 1.25$, $x_2(0) = 3.60$。\n- 初始速度：$v_1(0) = 0.15$, $v_2(0) = -0.10$。\n\n测试套件：\n- 情况1：周期性边界，速度Verlet积分器，$\\Delta t$值集合为$\\{0.01, 0.005, 0.0025\\}$。\n- 情况2：周期性边界，四阶龙格-库塔积分器，$\\Delta t$值集合为$\\{0.012, 0.006, 0.003\\}$。\n- 情况3：固定软壁，速度Verlet积分器，$\\Delta t$值集合为$\\{0.008, 0.004, 0.002\\}$。\n- 情况4：固定软壁，四阶龙格-库塔积分器，$\\Delta t$值集合为$\\{0.01, 0.005, 0.0025\\}$。\n\n所需输出：\n- 对于每种情况，计算估计的标度指数$\\hat{p}$（浮点数）。由于$\\hat{p}$是无量纲的，因此不需要物理单位。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为$\\left[\\hat{p}_1, \\hat{p}_2, \\hat{p}_3, \\hat{p}_4\\right]$，每个浮点数格式化为三位小数（例如，$\\left[2.003,3.998,2.012,3.955\\right]$）。\n\n模拟中的所有量均以简化的Lennard-Jones单位表示；不涉及角度；不使用百分比。程序必须是自包含的，且不需要用户输入。", "solution": "问题陈述已经过验证，被认为是可靠的。它具有科学依据，是良构且客观的。确定性模拟所需的所有必要参数和定义都已提供，没有内部矛盾或歧义。任务是实现一个分子动力学模拟，以研究两种标准数值积分器的能量守恒特性。\n\n目标是经验性地确定能量漂移度量$D(\\Delta t)$相对于积分时间步长$\\Delta t$的标度指数$\\hat{p}$。该度量预期标度关系为$D(\\Delta t) \\propto (\\Delta t)^p$，其中$p$是数值积分方法的阶数。指数$\\hat{p}$被估计为$\\log D(\\Delta t)$对$\\log \\Delta t$进行线性拟合的斜率。\n\n该模拟涉及一个一维空间中$N=2$个质量为$m=1$的粒子组成的系统，它们通过力移位Lennard-Jones势相互作用。考虑了两种边界条件情景：长度为$L=5$的晶胞中的周期性边界条件（PBC），以及位于$x=0$和$x=L=5$处的固定软排斥壁。测试了两种数值积分方案：二阶速度Verlet（VV）算法和四阶经典龙格-库塔（RK4）方法。所有量均采用简化的Lennard-Jones单位，其中$\\varepsilon=1$且$\\sigma=1$。\n\n解决方案的核心包括以下步骤：\n1.  定义物理模型，包括势能函数和相应的力。\n2.  实现数值积分器，以随时间演化系统的状态（位置和速度）。\n3.  对四个指定的测试案例分别执行模拟，改变时间步长$\\Delta t$。\n4.  对于每次模拟，计算总能量时间序列和均方根能量偏差度量$D(\\Delta t)$。\n5.  对于每个测试案例，对对数数据$(\\log \\Delta t, \\log D(\\Delta t))$进行线性回归，以找到标度指数$\\hat{p}$。\n\n**1. 势和力的计算**\n\n每个粒子上的总力是总势能的负梯度。势能函数根据边界条件而变化。\n\n对相互作用由力移位Lennard-Jones势决定，该势在粒子间距$r \\ge r_c$时为零。对于$r  r_c = 2.5$，势为：\n$$\nV_{\\mathrm{SF}}(r) = V_{\\mathrm{LJ}}(r) - V_{\\mathrm{LJ}}(r_c) - (r - r_c) \\left.\\frac{dV_{\\mathrm{LJ}}}{dr}\\right|_{r=r_c}\n$$\n相应的力的大小为：\n$$\nf_{\\mathrm{SF}}(r) = -\\frac{dV_{\\mathrm{SF}}}{dr} = f_{\\mathrm{LJ}}(r) - f_{\\mathrm{LJ}}(r_c)\n$$\n其中$V_{\\mathrm{LJ}}(r) = 4\\varepsilon[(\\sigma/r)^{12} - (\\sigma/r)^6]$且$f_{\\mathrm{LJ}}(r) = -\\frac{dV_{\\mathrm{LJ}}}{dr} = 24\\varepsilon/r[2(\\sigma/r)^{12} - (\\sigma/r)^6]$。当$\\varepsilon=1$和$\\sigma=1$时，这些简化为$V_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$和$f_{\\mathrm{LJ}}(r) = 24(2r^{-13} - r^{-7})$。\n\n**a) 周期性边界条件（PBC）：**\n总势能是$V(x_1, x_2) = V_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|)$，其中$r_{\\mathrm{MIC}} = (x_2-x_1) - L\\,\\mathrm{round}((x_2-x_1)/L)$是最小镜像约定下的分离。粒子上的力大小相等、方向相反：$F_1 = -F_2$，其中$F_2 = f_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|) \\mathrm{sign}(r_{\\mathrm{MIC}})$。总能量是$E = \\frac{1}{2}m(v_1^2 + v_2^2) + V_{\\mathrm{SF}}(|r_{\\mathrm{MIC}}|)$。\n\n**b) 固定软壁：**\n粒子被限制在$x=0$和$x=L$的壁之间。总势能包括对相互作用以及每个粒子的壁相互作用：\n$$\nV(x_1, x_2) = V_{\\mathrm{SF}}(|x_2-x_1|) + V_{\\mathrm{wall}}(x_1) + V_{\\mathrm{wall}}(x_2)\n$$\n一个位于位置$x$的粒子的壁势为$V_{\\mathrm{wall}}(x) = \\varepsilon_w [(\\sigma_w/x)^{12} + (\\sigma_w/(L - x))^{12}]$。粒子$i$上的力为$F_i = F_{i \\leftarrow j} + F_{\\mathrm{wall}}(x_i)$，其中$F_{i \\leftarrow j}$是对作用力，$F_{\\mathrm{wall}}(x) = -\\frac{dV_{\\mathrm{wall}}}{dx}$。总能量是$E = \\frac{1}{2}m(v_1^2 + v_2^2) + V(x_1, x_2)$。\n\n**2. 数值积分**\n\n设系统的状态由位置向量$x = (x_1, x_2)$和速度向量$v = (v_1, v_2)$描述。加速度为$a(x) = F(x)/m$。\n\n**a) 速度Verlet（VV）：**\n这是一种二阶（$p=2$）的辛积分器。从时间$t$到$t+\\Delta t$的一步计算如下：\n1.  计算半步速度：$v(t + \\frac{1}{2}\\Delta t) = v(t) + \\frac{1}{2} a(x(t)) \\Delta t$。\n2.  更新位置：$x(t + \\Delta t) = x(t) + v(t + \\frac{1}{2}\\Delta t) \\Delta t$。\n3.  对PBC应用位置包裹：$x(t + \\Delta t) \\leftarrow x(t + \\Delta t) \\pmod L$。\n4.  使用新位置计算新加速度$a(x(t + \\Delta t))$。\n5.  更新全步速度：$v(t + \\Delta t) = v(t + \\frac{1}{2}\\Delta t) + \\frac{1}{2} a(x(t + \\Delta t)) \\Delta t$。\n对于辛积分器，在哈密顿系统中，数值能量在长时间内不会表现出系统性漂移；相反，它会围绕初始值振荡。这些振荡的幅度预期标度关系为$\\mathcal{O}(\\Delta t^2)$。\n\n**b) 四阶龙格-库塔（RK4）：**\n这是一种通用的四阶（$p=4$）积分器。设系统状态为单个向量$Y = [x_1, x_2, v_1, v_2]$。时间导数为$\\frac{dY}{dt} = f(t, Y) = [v_1, v_2, a_1(x), a_2(x)]$。一步计算如下：\n1.  $k_1 = \\Delta t \\cdot f(t_n, Y_n)$\n2.  $k_2 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, Y_n + \\frac{k_1}{2})$\n3.  $k_3 = \\Delta t \\cdot f(t_n + \\frac{\\Delta t}{2}, Y_n + \\frac{k_2}{2})$\n4.  $k_4 = \\Delta t \\cdot f(t_n + \\Delta t, Y_n + k_3)$\n5.  $Y_{n+1} = Y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n6.  对PBC，对$Y_{n+1}$的位置分量应用位置包裹。\nRK4不是辛方法，对于长时间模拟，它通常会导致总能量的系统性漂移。累积误差以及因此的能量偏差度量$D(\\Delta t)$预期标度关系为$\\mathcal{O}(\\Delta t^4)$。\n\n**3. 模拟与分析**\n对于每种情况，我们使用一组给定的$\\Delta t$值，在总时间$T=10$内运行模拟。\n1.  将系统初始化为$x_1(0)=1.25, x_2(0)=3.60, v_1(0)=0.15, v_2(0)=-0.10$。\n2.  计算初始总能量$E(0)$。\n3.  在每个时间步$t_n = n \\Delta t$（从$n=0$到$N_t = T/\\Delta t$），计算总能量$E(t_n)$和偏差的平方$[\\delta E(t_n)]^2 = [E(t_n) - E(0)]^2$。\n4.  计算均方根能量偏差$D(\\Delta t) = \\sqrt{\\frac{1}{N_t+1}\\sum_{n=0}^{N_t} [\\delta E(t_n)]^2}$。\n5.  在获得一个测试案例中所有$\\Delta t$值的$D(\\Delta t)$后，我们假设一个幂律关系$D(\\Delta t) \\approx C(\\Delta t)^{\\hat{p}}$。取对数得到$\\log D(\\Delta t) \\approx \\log C + \\hat{p} \\log \\Delta t$。\n6.  通过对收集到的数据点$(\\log \\Delta t, \\log D(\\Delta t))$进行线性最小二乘拟合，并取其斜率来估计指数$\\hat{p}$。这可以通过使用`numpy.polyfit`来完成。\n\n预期结果是，对于速度Verlet情况，$\\hat{p} \\approx 2$；对于RK4情况，$\\hat{p} \\approx 4$，这反映了积分器的阶数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics energy drift scaling problem.\n    \"\"\"\n    # System and potential parameters in reduced units\n    N_PARTICLES = 2\n    MASS = 1.0\n    EPSILON = 1.0\n    SIGMA = 1.0\n    RC = 2.5\n    L = 5.0\n    EPSILON_W = 0.5\n    SIGMA_W = 0.5\n    T_TOTAL = 10.0\n\n    # Initial conditions\n    INITIAL_CONDITIONS = {\n        'pos': np.array([1.25, 3.60]),\n        'vel': np.array([0.15, -0.10]),\n    }\n\n    # Pre-calculate Lennard-Jones constants at the cutoff\n    _rc_pow6 = RC**6\n    _rc_pow12 = _rc_pow6**2\n    V_LJ_RC = 4.0 * EPSILON * ((SIGMA**12 / _rc_pow12) - (SIGMA**6 / _rc_pow6))\n    F_LJ_RC = 24.0 * EPSILON / RC * (2.0 * (SIGMA**12 / _rc_pow12) - (SIGMA**6 / _rc_pow6))\n    _sw12 = SIGMA_W**12\n\n    def get_accel_and_potential(pos, bc_type):\n        \"\"\"Calculates accelerations and potential energy for the 2-particle system.\"\"\"\n        accel = np.zeros(N_PARTICLES)\n        potential = 0.0\n        \n        # Pair interaction\n        r12 = pos[1] - pos[0]\n        dr = r12\n        if bc_type == 'periodic':\n            dr = dr - L * np.round(dr / L)\n        \n        r_abs = np.abs(dr)\n        \n        if r_abs  0 and r_abs  RC:\n            r_inv = SIGMA / r_abs\n            r_inv6 = r_inv**6\n            r_inv12 = r_inv6**2\n            \n            v_lj = 4.0 * EPSILON * (r_inv12 - r_inv6)\n            f_lj_mag = 24.0 * EPSILON / r_abs * (2.0 * r_inv12 - r_inv6)\n            \n            # Shifted-force potential and force\n            potential_pair = v_lj - V_LJ_RC + (r_abs - RC) * F_LJ_RC\n            force_mag = f_lj_mag - F_LJ_RC\n\n            potential += potential_pair\n            force_on_2 = force_mag * np.sign(dr)\n            accel[1] += force_on_2 / MASS\n            accel[0] -= force_on_2 / MASS\n\n        # Wall interactions for 'fixed' boundary conditions\n        if bc_type == 'fixed':\n            for i in range(N_PARTICLES):\n                x = pos[i]\n                if x  0 and x  L:\n                    term1 = (SIGMA_W / x)**12\n                    term2 = (SIGMA_W / (L - x))**12\n                    potential += EPSILON_W * (term1 + term2)\n                    \n                    force_wall = 12.0 * EPSILON_W * _sw12 * (x**-13 - (L - x)**-13)\n                    accel[i] += force_wall / MASS\n\n        return accel, potential\n\n    def step_vv(pos, vel, dt, bc_type):\n        \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n        accel, _ = get_accel_and_potential(pos, bc_type)\n        vel_half = vel + 0.5 * accel * dt\n        pos_new = pos + vel_half * dt\n        if bc_type == 'periodic':\n            pos_new = pos_new % L\n        \n        accel_new, _ = get_accel_and_potential(pos_new, bc_type)\n        vel_new = vel_half + 0.5 * accel_new * dt\n        return pos_new, vel_new\n\n    def get_state_derivative(state, bc_type):\n        \"\"\"Calculates the time derivative of the state vector [pos, vel] for RK4.\"\"\"\n        pos = state[:N_PARTICLES]\n        vel = state[N_PARTICLES:]\n        accel, _ = get_accel_and_potential(pos, bc_type)\n        return np.concatenate((vel, accel))\n\n    def step_rk4(pos, vel, dt, bc_type):\n        \"\"\"A single step of the classic 4th-order Runge-Kutta integrator.\"\"\"\n        state = np.concatenate((pos, vel))\n        \n        k1 = get_state_derivative(state, bc_type)\n        k2 = get_state_derivative(state + 0.5 * dt * k1, bc_type)\n        k3 = get_state_derivative(state + 0.5 * dt * k2, bc_type)\n        k4 = get_state_derivative(state + dt * k3, bc_type)\n        \n        state_new = state + dt / 6.0 * (k1 + 2*k2 + 2*k3 + k4)\n        \n        pos_new = state_new[:N_PARTICLES]\n        vel_new = state_new[N_PARTICLES:]\n        \n        if bc_type == 'periodic':\n            pos_new = pos_new % L\n            \n        return pos_new, vel_new\n\n    def run_simulation(integrator_func, bc_type, dt, ic):\n        \"\"\"Runs a simulation and returns the RMS energy deviation.\"\"\"\n        pos, vel = ic['pos'].copy(), ic['vel'].copy()\n        \n        num_steps = int(round(T_TOTAL / dt))\n        \n        _, v0 = get_accel_and_potential(pos, bc_type)\n        k0 = 0.5 * MASS * np.sum(vel**2)\n        e0 = k0 + v0\n        \n        energy_devs_sq = [0.0]\n        \n        for _ in range(num_steps):\n            pos, vel = integrator_func(pos, vel, dt, bc_type)\n            _, v_current = get_accel_and_potential(pos, bc_type)\n            k_current = 0.5 * MASS * np.sum(vel**2)\n            e_current = k_current + v_current\n            \n            delta_e = e_current - e0\n            energy_devs_sq.append(delta_e**2)\n            \n        return np.sqrt(np.mean(energy_devs_sq))\n\n    def estimate_p_hat(dts, Ds):\n        \"\"\"Estimates the scaling exponent p from log-log data.\"\"\"\n        log_dts = np.log(dts)\n        log_Ds = np.log(Ds)\n        # polyfit returns [slope, intercept] for degree 1\n        slope, _ = np.polyfit(log_dts, log_Ds, 1)\n        return slope\n        \n    test_cases = [\n        {'integrator': step_vv, 'bc_type': 'periodic', 'dts': [0.01, 0.005, 0.0025]},\n        {'integrator': step_rk4, 'bc_type': 'periodic', 'dts': [0.012, 0.006, 0.003]},\n        {'integrator': step_vv, 'bc_type': 'fixed', 'dts': [0.008, 0.004, 0.002]},\n        {'integrator': step_rk4, 'bc_type': 'fixed', 'dts': [0.01, 0.005, 0.0025]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        dts = np.array(case['dts'])\n        Ds = np.array([run_simulation(case['integrator'], case['bc_type'], dt, INITIAL_CONDITIONS) for dt in dts])\n        p_hat = estimate_p_hat(dts, Ds)\n        results.append(p_hat)\n        \n    print(f\"[{','.join(f'{p:.3f}' for p in results)}]\")\n\nsolve()\n```", "id": "3409975"}, {"introduction": "我们已经看到，辛积分器展现出卓越的长期能量守恒特性，其能量误差表现为有界涨落而非系统性漂移。其深层理论原因是，它们能够精确地守恒一个与真实哈密顿量非常接近的“影子”哈密顿量。在这个更深入的压轴练习中，你将通过数值方法为谐振子体系“揭示”出这个影子哈密顿量的存在，从而将你的模拟结果与优美的后向误差分析理论直接联系起来。[@problem_id:3409974]", "problem": "构建一个完整、可运行的程序，通过对测量的能量时间序列进行关于时间步长的多项式拟合，来研究辛分子动力学积分器的影子哈密顿量的辨识，并将拟合系数与理论后向误差分析预测的系数进行比较。使用一维谐振子作为模型系统，其质量为单位质量，角频率为 $\\omega$。基本出发点是牛顿第二定律和哈密顿动力学：$\\dot{q} = \\partial H / \\partial p$，$\\dot{p} = -\\partial H / \\partial q$，哈密顿量为 $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$。数值积分器是时间可逆的辛速度 Verlet 方法，以时间步长 $\\Delta t$ 应用：\n- $p_{n+1/2} = p_n - \\frac{\\Delta t}{2} \\, \\omega^2 q_n$，\n- $q_{n+1} = q_n + \\Delta t \\, p_{n+1/2}$,\n- $p_{n+1} = p_{n+1/2} - \\frac{\\Delta t}{2} \\, \\omega^2 q_{n+1}$。\n\n目标是通过将时间平均的真实能量与其初始值的偏差拟合为 $(\\Delta t)^2$ 的多项式，来经验性地检测辛方法近似守恒的影子哈密顿量 $\\tilde{H}$，然后与通过后向误差分析获得的理论预测进行比较。\n\n您的程序必须基于第一性原理实现以下步骤：\n1. 对于每个指定的 $\\Delta t$，使用速度 Verlet 方案，从指定的初始条件 $(q_0, p_0)$ 开始，对谐振子进行预定步数 $N$ 的模拟。在每个离散时间 $t_n = n \\, \\Delta t$，计算并累加真实能量 $E_n = \\frac{1}{2} p_n^2 + \\frac{1}{2} \\omega^2 q_n^2$。计算时间平均值 $\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n$。\n2. 对于案例中的一组 $\\Delta t$ 值，形成数据对 $(u, y)$，其中 $u = (\\Delta t)^2$ 且 $y = \\overline{E}(\\Delta t) - E_0$，而 $E_0 = \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2$ 是初始真实能量。通过对提供的 $u$ 值进行最小二乘法，拟合模型 $y \\approx c_2 \\, u + c_4 \\, u^2$，以获得经验系数 $c_2^{\\mathrm{emp}}$ 和 $c_4^{\\mathrm{emp}}$。\n3. 使用后向误差分析独立推导主导的影子哈密顿量修正系数的理论预测。对于应用于谐振子二次哈密顿量的速度 Verlet 方法，存在一个由离散映射守恒的精确二次不变量（影子能量）：\n$$\n\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2\n$$\n将 $\\tilde{E} - E$ 按 $(\\Delta t)$ 的幂次展开，得到\n$$\n\\tilde{E} - E = -\\frac{\\omega^4 q^2}{8} (\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)\n$$\n因此，能量偏差的多项式近似的理论系数为\n$$\nc_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8} \\quad \\text{和} \\quad c_4^{\\mathrm{th}} = 0\n$$\n4. 对每个测试案例，计算并报告绝对误差 $|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ 和 $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$。\n\n所有量均为无量纲；不包含物理单位。\n\n测试套件：\n- 案例1（通用小步长区间）：$\\omega = 1.0$, $q_0 = 1.0$, $p_0 = 0.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.05, 0.10, 0.15, 0.20\\}$。\n- 案例2（初始位置为零的边界情况）：$\\omega = 1.5$, $q_0 = 0.0$, $p_0 = 1.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.03, 0.05, 0.08, 0.10\\}$。\n- 案例3（混合初始条件，$\\Delta t$ 分布范围宽且远在稳定性界限内）：$\\omega = 0.7$, $q_0 = 0.8$, $p_0 = -0.6$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60\\}$。\n- 案例4（接近稳定性边界，大步长）：$\\omega = 1.0$, $q_0 = 0.5$, $p_0 = 0.2$, $N = 20000$, $\\Delta t \\in \\{0.40, 0.80, 1.20, 1.60, 1.80\\}$。该系统上速度 Verlet 的稳定性条件是 $\\omega \\Delta t  2$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含每个案例的两个浮点数 $|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ 和 $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$。例如，格式必须为 $[e_{2,1},e_{4,1},e_{2,2},e_{4,2},e_{2,3},e_{4,3},e_{2,4},e_{4,4}]$，其中 $e_{2,i}$ 和 $e_{4,i}$ 表示案例 $i$ 的绝对误差。", "solution": "该问题要求通过将经验拟合的系数与理论预测进行比较，来研究辛数值积分器的影子哈密顿量概念。物理系统是一维简谐振子，积分器是速度 Verlet 方法。\n\n核心原理基于哈密顿力学中辛积分器的性质。虽然这些积分器不能完美地守恒真实哈密顿量（能量）$H$，但它们能精确地守恒一个邻近的、修正过的哈密顿量，通常称为影子哈密顿量 $\\tilde{H}$。这一性质确保了长期稳定性和防止系统性能量漂移，这是高质量几何积分器的标志。对于应用于简谐振子的速度 Verlet 方法这一特定情况，出现了一个罕见且方便的特性：影子哈密顿量不仅仅是一个形式无穷级数，而是该离散映射的一个简单的、精确的二次不变量。\n\n该系统的哈密顿量由下式给出：\n$$\nH(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2\n$$\n其中 $q$ 是位置，$p$ 是动量，$\\omega$ 是角频率。质量取为单位一。运动方程为 $\\dot{q} = p$ 和 $\\dot{p} = -\\omega^2 q$。\n\n速度 Verlet 算法通过以下步骤将系统从时间 $t_n = n \\Delta t$ 推进到 $t_{n+1} = (n+1) \\Delta t$：\n1. 将动量更新到中点：$p_{n+1/2} = p_n - \\frac{\\Delta t}{2} F(q_n)$，其中力为 $F(q) = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q$。\n    $$p_{n+1/2} = p_n - \\frac{\\Delta t}{2} (-\\omega^2 q_n) = p_n + \\frac{\\Delta t}{2} \\omega^2 q_n$$\n    等等，问题陈述为 $p_{n+1/2} = p_n - \\frac{\\Delta t}{2} \\omega^2 q_n$。让我们重新验证力。$F = -\\nabla V(q)$，且 $V(q) = \\frac{1}{2}\\omega^2 q^2$。所以 $F(q) = -\\omega^2 q$。那么 $\\dot{p} = F(q_n)$。更新应为 $p_{n+1/2} = p_n + \\frac{\\Delta t}{2} F(q_n) = p_n - \\frac{\\Delta t}{2} \\omega^2 q_n$。问题陈述是正确的。\n    $$p_{n+1/2} = p_n - \\frac{\\Delta t}{2} \\omega^2 q_n$$\n2. 将位置更新到下一步：\n    $$q_{n+1} = q_n + \\Delta t \\, p_{n+1/2}$$\n3. 使用新位置 $q_{n+1}$ 处的力，将动量从中点更新到完整步长：\n    $$p_{n+1} = p_{n+1/2} - \\frac{\\Delta t}{2} \\omega^2 q_{n+1}$$\n\n该方法论涉及以下计算步骤：\n\n首先，对于一个测试案例中提供的每组参数，我们执行一系列数值模拟。每次模拟对应于给定集合中时间步长 $\\Delta t$ 的一个特定值。从初始条件 $(q_0, p_0)$ 开始，使用速度 Verlet 算法将系统演化 $N$ 步。在模拟过程中，每一步 $n$ 都会计算真实能量 $E_n = H(q_n, p_n)$。模拟完成后，计算时间平均能量：\n$$\n\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n\n$$\n\n其次，我们分析这个时间平均能量与初始能量 $E_0 = H(q_0, p_0)$ 的偏差。根据后向误差分析，这个偏差应该是 $\\Delta t$ 的一个偶次幂级数。我们构成数据对 $(u, y)$，其中 $u = (\\Delta t)^2$ 且 $y = \\overline{E}(\\Delta t) - E_0$。然后我们将此数据拟合到一个二次多项式模型：\n$$\ny(u) \\approx c_2^{\\mathrm{emp}} u + c_4^{\\mathrm{emp}} u^2\n$$\n系数 $c_2^{\\mathrm{emp}}$ 和 $c_4^{\\mathrm{emp}}$ 通过线性最小二乘拟合确定。这可以表示为一个矩阵问题 $\\mathbf{A}\\mathbf{c} = \\mathbf{y}$，其中 $\\mathbf{y}$ 是观测到的能量偏差向量，$\\mathbf{c} = [c_2^{\\mathrm{emp}}, c_4^{\\mathrm{emp}}]^T$ 是待求的系数向量，$\\mathbf{A}$ 是设计矩阵，其行向量为每个 $\\Delta t_i$ 对应的 $[u_i, u_i^2]$。解由 $\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$ 给出。\n\n第三，我们计算理论基准系数。问题陈述指出，对于此系统和积分器，存在一个精确的二次不变量（影子能量）：\n$$\n\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2\n$$\n这个影子能量 $\\tilde{E}$ 被离散动力学精确守恒，意味着对于所有 $n$，都有 $\\tilde{E}(q_n, p_n) = \\tilde{E}(q_0, p_0)$。\n问题基于影子能量与真实能量之间的初始偏差来定义理论系数：\n$$\n\\tilde{E}(q_0, p_0) - E_0 = \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 - \\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2 \\right] - \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 \\right] = -\\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2\n$$\n由此，问题将 $\\overline{E} - E_0$ 拟合的理论系数定义为：\n$$\nc_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8} \\quad \\text{和} \\quad c_4^{\\mathrm{th}} = 0\n$$\n一个微妙但重要的一点是，这个理论值仅从初始状态 $(q_0, p_0)$ 推导得出，而经验拟合是基于时间平均能量 $\\overline{E}$。时间平均偏差 $\\overline{E}-E_0$ 的实际理论系数是 $\\frac{\\omega^4}{8}(\\overline{q^2}-q_0^2)$，它依赖于数值轨迹上位置平方的时间平均值。问题的定义建立了一个明确的比较，即比较时间平均的经验结果与基于初始条件的理论预测，这是一个有效且具有指导意义的数值实验。\n\n最后，对于每个测试案例，我们计算经验拟合系数与理论定义系数之间的绝对误差：$|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ 和 $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$。所有测试案例的这些误差的集合构成了最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the shadow Hamiltonian for a symplectic integrator by fitting\n    the energy time series of a harmonic oscillator and comparing with theory.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General small-step regime\n        {\n            \"omega\": 1.0, \"q0\": 1.0, \"p0\": 0.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.05, 0.10, 0.15, 0.20])\n        },\n        # Case 2: Edge with zero initial position\n        {\n            \"omega\": 1.5, \"q0\": 0.0, \"p0\": 1.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.03, 0.05, 0.08, 0.10])\n        },\n        # Case 3: Mixed initial conditions, broad dt spread\n        {\n            \"omega\": 0.7, \"q0\": 0.8, \"p0\": -0.6, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60])\n        },\n        # Case 4: Near the stability boundary\n        {\n            \"omega\": 1.0, \"q0\": 0.5, \"p0\": 0.2, \"N\": 20000,\n            \"dts\": np.array([0.40, 0.80, 1.20, 1.60, 1.80])\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega = case[\"omega\"]\n        q0 = case[\"q0\"]\n        p0 = case[\"p0\"]\n        N = case[\"N\"]\n        dts = case[\"dts\"]\n        \n        u_values = []\n        y_values = []\n        \n        E0 = 0.5 * p0**2 + 0.5 * omega**2 * q0**2\n        \n        for dt in dts:\n            q, p = q0, p0\n            total_energy = 0.0\n            \n            # Pre-calculate constant factor for force\n            force_factor = omega**2\n            \n            # Simulation loop\n            for _ in range(N):\n                # Calculate and accumulate energy for the current step (q_n, p_n)\n                current_energy = 0.5 * p**2 + 0.5 * force_factor * q**2\n                total_energy += current_energy\n                \n                # Velocity Verlet integration step\n                # p_{n+1/2} = p_n - (dt/2) * omega^2 * q_n\n                p_half = p - 0.5 * dt * force_factor * q\n                # q_{n+1} = q_n + dt * p_{n+1/2}\n                q_next = q + dt * p_half\n                # p_{n+1} = p_{n+1/2} - (dt/2) * omega^2 * q_{n+1}\n                p_next = p_half - 0.5 * dt * force_factor * q_next\n                \n                q, p = q_next, p_next\n            \n            # Calculate time-averaged energy and its deviation from initial\n            E_avg = total_energy / N\n            y = E_avg - E0\n            \n            # Store u = dt^2 and y for fitting\n            u_values.append(dt**2)\n            y_values.append(y)\n            \n        # Perform least-squares fit: y = c2*u + c4*u^2\n        u_vals = np.array(u_values)\n        y_vals = np.array(y_values)\n        \n        # Design matrix A for the fit Ax = y\n        # Column 1 is u, Column 2 is u^2\n        A = np.vstack([u_vals, u_vals**2]).T\n        \n        # Solve for coefficients [c2, c4]\n        coeffs, _, _, _ = np.linalg.lstsq(A, y_vals, rcond=None)\n        c2_emp, c4_emp = coeffs[0], coeffs[1]\n        \n        # Calculate theoretical coefficients\n        # c2_th fromtilde{E} - E evaluated at t=0\n        c2_th = - (omega**4 * q0**2) / 8.0\n        c4_th = 0.0\n        \n        # Calculate absolute errors\n        error_c2 = np.abs(c2_emp - c2_th)\n        error_c4 = np.abs(c4_emp - c4_th)\n        \n        results.extend([error_c2, error_c4])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3409974"}]}