{"hands_on_practices": [{"introduction": "在分子力学中，精确的原子部分电荷是描述静电相互作用的基石，对于像碳水化合物这样的极性分子尤其重要。本练习将引导您实现一个核心的电荷拟合流程，即基于量子力学（QM）计算的静电势（ESP）来推导原子电荷。我们将采用约束最小二乘法，这是一种稳健的技术，可以确保拟合出的电荷严格满足电中性和化学等效性等物理化学约束，这是高质量力场参数化的关键步骤。[@problem_id:3400174]", "problem": "您的任务是实现一个物理上合理、带等式约束的静电势（ESP）电荷拟合方案，该方案适用于分子动力学中碳水化合物羟基的参数化。该方案必须将以原子为中心的点电荷拟合到使用 6-31G* 基组在 Hartree–Fock (HF) 水平下计算的量子力学静电势数据，同时强制执行化学上合理的对称性和等价性约束以及精确的电中性。拟合必须针对多个羟基旋转异构体同时进行，且每个原子在所有旋转异构体中共享同一个电荷。\n\n从以下基本原理出发：\n- 由固定点电荷在某个场点产生的静电势定义为 $V(\\mathbf{r})=\\sum_{i=1}^{N} \\dfrac{q_i}{\\lVert \\mathbf{r}-\\mathbf{R}_i\\rVert}$，其中 $q_i$ 是未知的部分电荷（单位为元电荷 $e$），$\\mathbf{R}_i$ 是原子坐标（单位为 $\\mathrm{\\AA}$），$\\mathbf{r}$ 是网格点位置（单位为 $\\mathrm{\\AA}$）。\n- 带等式约束的最小二乘准则是用一个受物理约束的简洁点电荷集来协调众多ESP观测值的逻辑上最简约的方法。\n- 可以对 $q_i$ 值施加一个小的二次约束（岭），以确保数值稳定性并模拟约束静电势拟合。\n\n您的拟合目标是一个用于模拟碳水化合物羟基取代基的最小含羟基片段：一个具有 $N=6$ 个原子的类甲醇部分，原子索引如下：$1$（氧 O）、$2$（羟基氢 H$_\\mathrm{oh}$）、$3$（碳 C）、$4$（甲基氢 H$_\\mathrm{c1}$）、$5$（甲基氢 H$_\\mathrm{c2}$）、$6$（甲基氢 H$_\\mathrm{c3}$）。考虑了两种羟基旋转异构体，并且必须使用一套共享的电荷 $\\{q_i\\}_{i=1}^6$ 对它们同时进行拟合。\n\n两种旋转异构体的几何结构（单位为 $\\mathrm{\\AA}$）由原子笛卡尔坐标定义：\n\n- 旋转异构体 A：\n  - O: $(1.43, 0.00, 0.00)$\n  - H$_\\mathrm{oh}$: $(0.95, 0.00, 0.831)$\n  - C: $(0.00, 0.00, 0.00)$\n  - H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$\n  - H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$\n  - H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$\n\n- 旋转异构体 B（羟基氢围绕 C–O 键旋转）：\n  - O: $(1.43, 0.00, 0.00)$\n  - H$_\\mathrm{oh}$: $(0.95, 0.00, -0.831)$\n  - C: $(0.00, 0.00, 0.00)$\n  - H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$\n  - H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$\n  - H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$\n\n用于每个旋转异构体的静电势网格点（单位为 $\\mathrm{\\AA}$）被定义为笛卡尔坐标集。对于测试用例 $1$ 和测试用例 $2$ 中的旋转异构体 A 和旋转异构体 B，每个旋转异构体使用以下 $8$ 个网格点：\n- $(2.50, 0.00, 0.00)$\n- $(2.50, 2.50, 0.00)$\n- $(0.00, 2.50, 2.50)$\n- $(-2.50, 0.00, 0.00)$\n- $(0.00, -2.50, 2.50)$\n- $(2.00, 0.00, 2.00)$\n- $(-2.00, -2.00, 0.00)$\n- $(0.00, 0.00, -2.50)$\n\n对于测试用例 $3$，每个旋转异构体使用以下 $6$ 个网格点（选择这些点是为了通过 $y=z$ 对称性强制 H$_\\mathrm{c2}$ 和 H$_\\mathrm{c3}$ 具有相同的距离）：\n- $(2.00, 1.00, 1.00)$\n- $(0.00, 2.00, 2.00)$\n- $(-2.00, -1.00, -1.00)$\n- $(1.00, 0.50, 0.50)$\n- $(-1.00, -0.50, -0.50)$\n- $(0.50, 1.50, 1.50)$\n\n将给定旋转异构体的设计矩阵 $\\mathbf{A}$ 定义为 $\\mathbf{A}_{k i}=\\dfrac{1}{r_{k i}}$，其中 $r_{k i}$ 是网格点 $k$ 和原子 $i$ 之间的欧几里得距离（单位为 $\\mathrm{\\AA}$）。将所有特定于旋转异构体的行连接起来，形成一个跨旋转异构体的全局 $\\mathbf{A}$。令 $\\mathbf{q}\\in\\mathbb{R}^{6}$ 为电荷向量，$\\mathbf{V}^{\\mathrm{QM}}\\in\\mathbb{R}^{M}$ 为所有旋转异构体上所有 $M$ 个网格点的量子力学静电势向量（单位为 $e/\\mathrm{\\AA}$）。\n\n为确保测试套件的数值定义是自洽的，您必须使用由参考电荷\n$$\n\\mathbf{q}^{\\mathrm{ref}}=\\big[-0.66,\\; 0.43,\\; -0.02,\\; 0.083,\\; 0.083,\\; 0.083\\big]\n$$\n（单位为 $e$）通过 $V^{\\mathrm{QM}}_k=\\sum_{i=1}^{6}\\dfrac{q^{\\mathrm{ref}}_i}{r_{k i}}$ 生成的人工合成但物理上一致的 $\\mathbf{V}^{\\mathrm{QM}}$，且不添加任何噪声。所有距离 $r_{k i}$ 均由上述坐标（单位为 $\\mathrm{\\AA}$）计算得出，因此 $V^{\\mathrm{QM}}$ 的单位为 $e/\\mathrm{\\AA}$。\n\n通过最小化带二次小约束的加权最小二乘目标函数来拟合 $\\mathbf{q}$，\n$$\n\\min_{\\mathbf{q}} \\;\\; \\frac{1}{2}\\left\\lVert \\mathbf{A}\\mathbf{q}-\\mathbf{V}^{\\mathrm{QM}}\\right\\rVert_2^2+\\frac{\\kappa}{2}\\left\\lVert \\mathbf{q}\\right\\rVert_2^2\n$$\n该过程受编码物理需求的线性等式约束：\n- 精确总电中性：$\\sum_{i=1}^{6} q_i=0$。\n- 甲基氢等价性：$q_4=q_5$ 和 $q_5=q_6$。\n\n角度不是必需的；如果您需要在内部引入任何角度，请以度为单位表示，但问题本身不要求进行任何角度计算。\n\n实现一个程序，对三个测试用例执行此拟合，这些测试用例在网格点的数量和位置以及约束强度 $\\kappa$ 上有所不同：\n\n- 测试用例 1（一般情况，超定）：对两个旋转异构体均使用全部 $8$ 个网格点（总共 $M=16$），$\\kappa=10^{-5}$。\n- 测试用例 2（边界情况，无约束时欠定）：对每个旋转异构体仅使用上述列表中的前 $3$ 个网格点（总共 $M=6$），$\\kappa=10^{-3}$。\n- 测试用例 3（对称性引起的列简并）：对每个旋转异构体使用 $6$ 个 $y=z$ 的特殊网格点（总共 $M=12$），$\\kappa=10^{-4}$。\n\n对于每个测试用例，计算满足约束条件的拟合电荷向量 $\\mathbf{q}^{\\ast}$，然后计算电中性符合度，即总电荷的绝对值，\n$$\n\\left|\\sum_{i=1}^{6} q^{\\ast}_i\\right| \\;\\; \\text{单位为 } e.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），其中每个元素是表示一个测试用例的电中性符合度的浮点数（单位 $e$）。如果约束被正确执行，其量级应接近于零。所有距离计算必须使用 $\\mathrm{\\AA}$，静电势必须以 $e/\\mathrm{\\AA}$ 为单位，电荷必须以 $e$ 为单位。", "solution": "该问题提出了一个任务：通过拟合量子力学静电势（ESP）数据，来确定一个类甲醇分子片段的以原子为中心的部分电荷。这是分子力学力场开发中的一个标准流程，通常称为约束静电势（RESP）拟合。该问题被表述为一个数学上适定（well-posed）的、线性约束的二次优化问题。\n\n首先，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **静电势模型**：由 $N$ 个位于位置 $\\mathbf{R}_i$ 的原子电荷 $q_i$ 在点 $\\mathbf{r}$ 处产生的电势为 $V(\\mathbf{r})=\\sum_{i=1}^{N} \\dfrac{q_i}{\\lVert \\mathbf{r}-\\mathbf{R}_i\\rVert}$。\n- **目标函数**：电荷 $\\mathbf{q}$ 通过最小化目标函数 $J(\\mathbf{q}) = \\frac{1}{2}\\left\\lVert \\mathbf{A}\\mathbf{q}-\\mathbf{V}^{\\mathrm{QM}}\\right\\rVert_2^2+\\frac{\\kappa}{2}\\left\\lVert \\mathbf{q}\\right\\rVert_2^2$ 来找到，其中 $\\kappa$ 是一个约束参数。\n- **分子体系**：一个有 $N=6$ 个原子的片段，索引为 $1$(O)、$2$(H$_\\mathrm{oh}$)、$3$(C)、$4$(H$_\\mathrm{c1}$)、$5$(H$_\\mathrm{c2}$) 和 $6$(H$_\\mathrm{c3}$)。\n- **构象**：同时考虑两个旋转异构体（A 和 B）。\n- **几何结构**（单位 $\\mathrm{\\AA}$）：\n  - 旋转异构体 A：O: $(1.43, 0.00, 0.00)$，H$_\\mathrm{oh}$: $(0.95, 0.00, 0.831)$，C: $(0.00, 0.00, 0.00)$，H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$，H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$，H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$。\n  - 旋转异构体 B：O: $(1.43, 0.00, 0.00)$，H$_\\mathrm{oh}$: $(0.95, 0.00, -0.831)$，C: $(0.00, 0.00, 0.00)$，H$_\\mathrm{c1}$: $(-1.09, 0.00, 0.00)$，H$_\\mathrm{c2}$: $(0.00, 1.09, 0.00)$，H$_\\mathrm{c3}$: $(0.00, 0.00, 1.09)$。\n- **ESP 网格点**（单位 $\\mathrm{\\AA}$）：\n  - 对于测试用例 1 和 2：每个旋转异构体一组 $8$ 个点：$(2.50, 0.00, 0.00)$, $(2.50, 2.50, 0.00)$, $(0.00, 2.50, 2.50)$, $(-2.50, 0.00, 0.00)$, $(0.00, -2.50, 2.50)$, $(2.00, 0.00, 2.00)$, $(-2.00, -2.00, 0.00)$, $(0.00, 0.00, -2.50)$。\n  - 对于测试用例 3：每个旋转异构体一组 $6$ 个点：$(2.00, 1.00, 1.00)$, $(0.00, 2.00, 2.00)$, $(-2.00, -1.00, -1.00)$, $(1.00, 0.50, 0.50)$, $(-1.00, -0.50, -0.50)$, $(0.50, 1.50, 1.50)$。\n- **设计矩阵**：矩阵元素 $\\mathbf{A}_{ki}$ 定义为 $\\dfrac{1}{r_{ki}}$，其中 $r_{ki}$ 是网格点 $k$ 与原子 $i$ 之间的距离。\n- **人工合成的目标数据**：向量 $\\mathbf{V}^{\\mathrm{QM}}$ 通过 $\\mathbf{V}^{\\mathrm{QM}} = \\mathbf{A}\\mathbf{q}^{\\mathrm{ref}}$ 计算得出，使用参考电荷向量 $\\mathbf{q}^{\\mathrm{ref}}=\\big[-0.66,\\; 0.43,\\; -0.02,\\; 0.083,\\; 0.083,\\; 0.083\\big]$（单位为 $e$）。\n- **等式约束**：\n  - 电中性：$\\sum_{i=1}^{6} q_i=0$。\n  - 甲基氢等价性：$q_4=q_5$ 和 $q_5=q_6$。\n- **测试用例**：\n  - 测试用例 1：$M=16$ 个网格点，$\\kappa=10^{-5}$。\n  - 测试用例 2：$M=6$ 个网格点，$\\kappa=10^{-3}$。\n  - 测试用例 3：$M=12$ 个网格点，$\\kappa=10^{-4}$。\n- **要求输出**：对于每个测试用例，输出电中性符合度，定义为 $\\left|\\sum_{i=1}^{6} q^{\\ast}_i\\right|$。\n\n**步骤 2：已知条件验证**\n该问题在科学上是合理的，复现了计算化学中的一种标准方法。物理基础（库仑定律）、数学表述（约束最小二乘法）和化学概念（电中性、原子等价性）都是正确且一致的。所有需要的数据（几何结构、网格点、参数）均已提供，使得问题自洽且可通过数值方法验证。目标函数是凸的，约束是线性的，这定义了一个具有唯一解的适定二次规划问题。包含吉洪诺夫正则化项（$\\kappa > 0$）确保了数值稳定性，即使在设计矩阵 $\\mathbf{A}$ 可能秩亏的情况下（如测试用例3中故意设计的那样）。\n\n**步骤 3：结论与行动**\n问题被判定为**有效**。将开发一个解决方案。\n\n**基于原理的求解设计**\n\n问题在于找到电荷向量 $\\mathbf{q} \\in \\mathbb{R}^6$，以最小化正则化的最小二乘目标函数：\n$$ J(\\mathbf{q}) = \\frac{1}{2} \\left( \\mathbf{A}\\mathbf{q} - \\mathbf{V}^{\\mathrm{QM}} \\right)^T \\left( \\mathbf{A}\\mathbf{q} - \\mathbf{V}^{\\mathrm{QM}} \\right) + \\frac{\\kappa}{2} \\mathbf{q}^T \\mathbf{q} $$\n忽略常数项，这可以重写为标准二次型：\n$$ \\min_{\\mathbf{q}} \\frac{1}{2} \\mathbf{q}^T (\\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}) \\mathbf{q} - \\mathbf{q}^T \\mathbf{A}^T \\mathbf{V}^{\\mathrm{QM}} $$\n其中 $\\mathbf{I}$ 是单位矩阵。\n\n最小化过程受一组线性等式约束的限制：\n1.  中性：$q_1 + q_2 + q_3 + q_4 + q_5 + q_6 = 0$\n2.  等价性：$q_4 - q_5 = 0$\n3.  等价性：$q_5 - q_6 = 0$\n\n这些约束可以用矩阵形式表示为 $\\mathbf{Cq} = \\mathbf{d}$，其中：\n$$\n\\mathbf{C} = \\begin{pmatrix} 1  1  1  1  1  1 \\\\ 0  0  0  1  -1  0 \\\\ 0  0  0  0  1  -1 \\end{pmatrix}, \\quad\n\\mathbf{q} = \\begin{pmatrix} q_1 \\\\ q_2 \\\\ q_3 \\\\ q_4 \\\\ q_5 \\\\ q_6 \\end{pmatrix}, \\quad\n\\mathbf{d} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n\n这个约束优化问题使用拉格朗日乘数法求解。通过一个拉格朗日乘数向量 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^3$ 将约束条件附加到目标函数上，构建拉格朗日函数 $\\mathcal{L}$：\n$$ \\mathcal{L}(\\mathbf{q}, \\boldsymbol{\\lambda}) = J(\\mathbf{q}) + \\boldsymbol{\\lambda}^T (\\mathbf{Cq} - \\mathbf{d}) $$\n\n通过将 $\\mathcal{L}$ 对 $\\mathbf{q}$ 和 $\\boldsymbol{\\lambda}$ 的梯度设为零，可以找到最小值的必要条件：\n$$ \\nabla_{\\mathbf{q}} \\mathcal{L} = (\\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I})\\mathbf{q} - \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}} + \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{0} $$\n$$ \\nabla_{\\boldsymbol{\\lambda}} \\mathcal{L} = \\mathbf{Cq} - \\mathbf{d} = \\mathbf{0} $$\n\n这两个方程构成一个线性方程组。令 $\\mathbf{P} = \\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}$ 和 $\\mathbf{s} = \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}}$。该系统可写作：\n$$ \\mathbf{Pq} + \\mathbf{C}^T\\boldsymbol{\\lambda} = \\mathbf{s} $$\n$$ \\mathbf{Cq} = \\mathbf{d} $$\n\n这是一个 Karush-Kuhn-Tucker (KKT) 系统，可以表示为单个分块矩阵方程：\n$$\n\\begin{pmatrix}\n\\mathbf{P}  \\mathbf{C}^T \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{s} \\\\\n\\mathbf{d}\n\\end{pmatrix}\n$$\n在这里，左侧的分块矩阵是一个 $(6+3) \\times (6+3) = 9 \\times 9$ 的矩阵，右侧是一个 $9 \\times 1$ 的向量。\n\n算法流程如下：\n1.  对于每个测试用例，定义由旋转异构体 A 和旋转异构体 B 组成的系统。ESP 网格点的总数 $M$ 是每个旋转异构体点数之和。\n2.  构建大小为 $M \\times 6$ 的全局设计矩阵 $\\mathbf{A}$。对于 $M$ 个网格点中的每一个，计算一个行，其中第 $i$ 个元素是该网格点到原子 $i$ 的距离的倒数。\n3.  构建大小为 $M \\times 1$ 的全局人工合成电势向量 $\\mathbf{V}^{\\mathrm{QM}}$。对于每个网格点 $k$，使用给定的参考电荷，通过 $\\sum_{i=1}^{6} q_i^{\\mathrm{ref}} / r_{ki}$ 计算值 $V_k^{\\mathrm{QM}}$。\n4.  构成矩阵 $\\mathbf{P} = \\mathbf{A}^T\\mathbf{A} + \\kappa\\mathbf{I}$ 和向量 $\\mathbf{s} = \\mathbf{A}^T\\mathbf{V}^{\\mathrm{QM}}$。\n5.  组装 $9 \\times 9$ 的 KKT 矩阵和 $9 \\times 1$ 的右侧向量。\n6.  求解该线性系统，以获得包含最优电荷 $\\mathbf{q}^*$（前 $6$ 个元素）和拉格朗日乘数 $\\boldsymbol{\\lambda}$（后 $3$ 个元素）的解向量。\n7.  提取电荷向量 $\\mathbf{q}^*$ 并计算电中性符合度，即其元素总和的绝对值 $\\left|\\sum_{i=1}^{6} q_i^*\\right|$。这个值源于有限精度运算，可用于验证约束是否被正确实现。\n该过程将应用于三个指定的测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained ESP charge fitting problem for three test cases.\n    \"\"\"\n\n    # --- Geometries and Reference Charges ---\n    # Atomic coordinates are given in Angstroms.\n    coords_rot_A = np.array([\n        [1.43, 0.00, 0.000],  # O (1)\n        [0.95, 0.00, 0.831],  # H_oh (2)\n        [0.00, 0.00, 0.000],  # C (3)\n        [-1.09, 0.00, 0.000], # H_c1 (4)\n        [0.00, 1.09, 0.000],  # H_c2 (5)\n        [0.00, 0.00, 1.090],  # H_c3 (6)\n    ])\n\n    coords_rot_B = np.array([\n        [1.43, 0.00, 0.000],   # O (1)\n        [0.95, 0.00, -0.831],  # H_oh (2)\n        [0.00, 0.00, 0.000],   # C (3)\n        [-1.09, 0.00, 0.000],  # H_c1 (4)\n        [0.00, 1.09, 0.000],   # H_c2 (5)\n        [0.00, 0.00, 1.090],   # H_c3 (6)\n    ])\n    \n    rotamer_coords = [coords_rot_A, coords_rot_B]\n\n    # Reference charges (in elementary charge e) for generating synthetic V_QM.\n    q_ref = np.array([-0.66, 0.43, -0.02, 0.083, 0.083, 0.083])\n    \n    # --- Grid Points for Test Cases ---\n    grid_points_12 = np.array([\n        [2.50, 0.00, 0.00],\n        [2.50, 2.50, 0.00],\n        [0.00, 2.50, 2.50],\n        [-2.50, 0.00, 0.00],\n        [0.00, -2.50, 2.50],\n        [2.00, 0.00, 2.00],\n        [-2.00, -2.00, 0.00],\n        [0.00, 0.00, -2.50],\n    ])\n\n    grid_points_3 = np.array([\n        [2.00, 1.00, 1.00],\n        [0.00, 2.00, 2.00],\n        [-2.00, -1.00, -1.00],\n        [1.00, 0.50, 0.50],\n        [-1.00, -0.50, -0.50],\n        [0.50, 1.50, 1.50],\n    ])\n\n    test_cases = [\n        {'kappa': 1e-5, 'grid_points': grid_points_12, 'num_points_per_rotamer': 8, 'case_id': 1},\n        {'kappa': 1e-3, 'grid_points': grid_points_12, 'num_points_per_rotamer': 3, 'case_id': 2},\n        {'kappa': 1e-4, 'grid_points': grid_points_3, 'num_points_per_rotamer': 6, 'case_id': 3},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        kappa = case['kappa']\n        grid_points = case['grid_points'][:case['num_points_per_rotamer']]\n        \n        A_rows = []\n        V_qm_vals = []\n\n        # Build the global design matrix A and target vector V_qm\n        for R_atoms in rotamer_coords:\n            for r_grid in grid_points:\n                # Calculate distances from grid point to all atoms\n                distances = np.linalg.norm(R_atoms - r_grid, axis=1)\n                \n                # Append row to design matrix A (1/r)\n                A_rows.append(1.0 / distances)\n                \n                # Calculate and append V_qm from reference charges\n                v_k = np.sum(q_ref / distances)\n                V_qm_vals.append(v_k)\n\n        A = np.array(A_rows)\n        V_qm = np.array(V_qm_vals)\n\n        num_charges = q_ref.shape[0]\n\n        # --- Set up and solve the KKT system for constrained optimization ---\n        \n        # P = A.T @ A + kappa * I\n        P = A.T @ A + kappa * np.identity(num_charges)\n        \n        # s = A.T @ V_qm\n        s = A.T @ V_qm\n\n        # Constraint matrix C\n        C = np.zeros((3, num_charges))\n        C[0, :] = 1.0        # Sum of charges = 0\n        C[1, 3] = 1.0; C[1, 4] = -1.0  # q4 - q5 = 0\n        C[2, 4] = 1.0; C[2, 5] = -1.0  # q5 - q6 = 0\n        \n        # Constraint vector d\n        d = np.zeros(C.shape[0])\n\n        # Assemble the KKT block matrix\n        num_constraints = C.shape[0]\n        KKT_matrix = np.block([\n            [P, C.T],\n            [C, np.zeros((num_constraints, num_constraints))]\n        ])\n        \n        # Assemble the KKT right-hand side vector\n        KKT_rhs = np.concatenate([s, d])\n\n        # Solve the linear system KKT_matrix * x = KKT_rhs\n        solution = np.linalg.solve(KKT_matrix, KKT_rhs)\n        \n        # Extract the fitted charges q*\n        q_fit = solution[:num_charges]\n        \n        # Calculate neutrality compliance\n        neutrality_compliance = np.abs(np.sum(q_fit))\n        results.append(neutrality_compliance)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3400174"}, {"introduction": "在确定了静电参数之后，参数化工作的下一个关键步骤是精确地描述分子关键柔性自由度的势能面，例如连接糖单元的糖苷键扭转角（$\\phi$ 和 $\\psi$）。本练习模拟了将傅立叶级数模型拟合到（模拟的）QM势能扫描数据的完整过程，这构成了扭转参数优化的核心。更进一步，我们还将通过计算系综平均的核奥弗豪泽效应（NOE）距离来验证新参数，将理论计算与可测量的物理量直接联系起来，从而检验参数化的有效性。[@problem_id:3400156]", "problem": "您的任务是实现一个物理上合理的算法流程，用于重新拟合葡萄糖二糖的糖苷二面角参数。该流程使用截断傅里叶展开来模拟糖苷扭转，并通过重现核奥弗豪瑟效应 (NOE) 导出的距离来验证重新拟合的结果。重点是糖苷二面角 $\\phi$ 和 $\\psi$，以及匹配由六阶矩平均 $\\langle r^{-6}\\rangle^{-1/6}$ 定义的、从NOE强度导出的有效距离。该计算流程必须从基本原理出发，特别是扭转势的周期性和用于系综平均的玻尔兹曼统计，并且不得依赖预先给定的拟合参数或经验性捷径。\n\n从以下基本依据开始：\n- 二面角的经典扭转势是周期函数。任何足够平滑的 $2\\pi$ 周期函数 $V(\\theta)$ 都可以用傅里叶级数表示，而截断级数在分子力学力场中是常规使用的。使用在一组三角基函数上展开的表示法 $V(\\phi,\\psi)$。\n- 扭转态上的平衡布居遵循玻尔兹曼统计。对于温度为 $T$ 时的势 $V(\\phi,\\psi)$，其概率密度为 $p(\\phi,\\psi)\\propto\\exp\\left(-\\beta V(\\phi,\\psi)\\right)$，其中 $\\beta=1/\\left(k_{\\mathrm{B}}T\\right)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n- 核奥弗豪瑟效应 (NOE) 的有效质子-质子距离为 $r_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}$，其中的系综平均是基于玻尔兹曼分布计算的。\n\n您的程序必须实现以下流程：\n1. 生成合成的从头算扭转扫描能量，以模拟使用相关一致性极化价三重泽塔基组 (cc-pVTZ) 的 Møller–Plesset 二阶微扰理论 (MP2) 的结果。扫描覆盖以弧度为单位的两个扭转角 $\\phi$ 和 $\\psi$ 上的均匀网格。合成的“真实”能量面由一组已知的傅里叶振幅和相位，加上一个真实的交叉项构建，然后通过添加小的高斯噪声进行扰动，以模拟量子化学计算的不完美性。这代表了输入数据。\n2. 使用基于三角基函数的线性最小二乘法，将截断傅里叶模型拟合到带噪声的合成能量上。使用以下线性基来表示重新拟合的势 $V_{\\mathrm{fit}}(\\phi,\\psi)$：一个常数项，对于 $n=1,2,3$ 的 $\\cos(n\\phi)$ 和 $\\sin(n\\phi)$，对于 $m=1,2,3$ 的 $\\cos(m\\psi)$ 和 $\\sin(m\\psi)$，以及一个包含 $\\cos(\\phi-\\psi)$ 和 $\\sin(\\phi-\\psi)$ 的单一耦合项。求解线性系数，以最小化与整个网格上带噪声能量的平方误差。\n3. 通过计算一个代表性质子-质子对的 $r_{\\mathrm{eff}}$ 来验证重新拟合的结果，该质子对的距离通过一个物理上合理的三角函数映射 $r(\\phi,\\psi)=r_{0}+a\\cos\\left(\\phi-\\phi_{0}\\right)+b\\cos\\left(\\psi-\\psi_{0}\\right)$ 依赖于糖苷扭转角，其中常数由每个测试用例提供。计算两个有效距离：使用 $V_{\\mathrm{fit}}(\\phi,\\psi)$ 计算的 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ 和使用无噪声的“真实”势计算的 $r_{\\mathrm{eff}}^{\\mathrm{true}}$。在均匀网格上使用离散玻尔兹曼平均来评估 $\\left\\langle r^{-6}\\right\\rangle$，然后取其-1/6次方。\n4. 报告重新拟合势与带噪声的合成能量之间的均方根误差 (RMSE)，以量化拟合质量，并通过检查 $\\left|r_{\\mathrm{eff}}^{\\mathrm{fit}}-r_{\\mathrm{eff}}^{\\mathrm{true}}\\right|\\leq \\mathrm{tol}$ 来确定重新拟合的结果是否重现了NOE导出的距离，其中 $\\mathrm{tol}$ 是每个测试用例指定的容差。\n\n角度单位必须是弧度，能量单位必须是千焦耳/摩尔，温度单位必须是开尔文，距离单位必须是埃。报告 RMSE 和 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ 时，需四舍五入到三位小数。玻尔兹曼常数必须使用千焦耳/摩尔·开尔文作为单位。\n\n为模型构建和验证实现以下细节：\n- 使用一个均匀网格，包含 $N_{\\phi}=36$ 和 $N_{\\psi}=36$ 个采样点，覆盖范围为 $\\phi\\in[-\\pi,\\pi)$ 和 $\\psi\\in[-\\pi,\\pi)$。\n- 合成的“真实”能量面定义为\n$$\nV_{\\mathrm{true}}(\\phi,\\psi)=\\sum_{n=1}^{3}K_{\\phi,n}\\left[1-\\cos\\left(n\\phi-\\delta_{\\phi,n}\\right)\\right]+\\sum_{m=1}^{3}K_{\\psi,m}\\left[1-\\cos\\left(m\\psi-\\delta_{\\psi,m}\\right)\\right]+K_{c}\\left[1-\\cos\\left(\\phi-\\psi-\\delta_{c}\\right)\\right],\n$$\n其中所有 $K$ 的单位为千焦耳/摩尔，所有相位移 $\\delta$ 的单位为弧度。带噪声的合成能量为 $V_{\\mathrm{QM}}(\\phi,\\psi)=V_{\\mathrm{true}}(\\phi,\\psi)+\\epsilon$，其中 $\\epsilon$ 是均值为零、标准差为 $\\sigma_{E}$ (单位为千焦耳/摩尔) 的高斯噪声。为保证可复现性，每个用例使用指定的随机种子。\n- 重新拟合的模型是线性展开式\n$$\nV_{\\mathrm{fit}}(\\phi,\\psi)=C+\\sum_{n=1}^{3}\\left[A_{\\phi,n}\\cos(n\\phi)+B_{\\phi,n}\\sin(n\\phi)\\right]+\\sum_{m=1}^{3}\\left[A_{\\psi,m}\\cos(m\\psi)+B_{\\psi,m}\\sin(m\\psi)\\right]+A_{c}\\cos(\\phi-\\psi)+B_{c}\\sin(\\phi-\\psi),\n$$\n其中系数通过对整个网格上计算的 $V_{\\mathrm{QM}}(\\phi,\\psi)$ 值进行最小二乘法确定。\n\n对于网格上的玻尔兹曼平均：\n- 定义 $\\beta=1/\\left(k_{\\mathrm{B}}T\\right)$，其中 $k_{\\mathrm{B}}=0.008314462618$ 千焦耳/摩尔·开尔文。\n- 为提高数值稳定性，在进行指数运算前，从能量面中减去最小能量 $V_{\\min}$，即使用权重 $w_{ij}=\\exp\\left(-\\beta\\left[V(\\phi_{i},\\psi_{j})-V_{\\min}\\right]\\right)$ 并通过 $Z=\\sum_{ij}w_{ij}$ 进行归一化。\n- 计算 $\\left\\langle r^{-6}\\right\\rangle=\\sum_{ij}\\left[w_{ij}/Z\\right]\\cdot r(\\phi_{i},\\psi_{j})^{-6}$，然后得到 $r_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}$。\n\n测试套件：\n实现三个测试用例以检验不同的行为。对于每个用例，会给出 $\\phi$、$\\psi$ 和耦合项的“真实”振幅和相位、距离映射常数、温度 $T$、能量噪声水平 $\\sigma_{E}$、容差 $\\mathrm{tol}$ 和随机种子。\n\n- 用例 1 (代表性的 $\\alpha$ 糖苷键):\n  - $K_{\\phi}=\\left[2.5,1.2,0.5\\right]$, $\\delta_{\\phi}=\\left[0.0,\\frac{\\pi}{3},\\frac{\\pi}{2}\\right]$.\n  - $K_{\\psi}=\\left[3.0,0.8,0.4\\right]$, $\\delta_{\\psi}=\\left[\\frac{\\pi}{6},\\frac{\\pi}{2},\\frac{\\pi}{3}\\right]$.\n  - $K_{c}=0.6$, $\\delta_{c}=\\frac{\\pi}{4}$.\n  - 距离映射常数: $r_{0}=3.0$, $a=0.35$, $b=0.25$, $\\phi_{0}=0.0$, $\\psi_{0}=\\frac{\\pi}{3}$.\n  - $T=300$, $\\sigma_{E}=0.1$, $\\mathrm{tol}=0.06$, seed $=42$.\n\n- 用例 2 (代表性的 $\\beta$ 糖苷键):\n  - $K_{\\phi}=\\left[1.5,0.7,0.3\\right]$, $\\delta_{\\phi}=\\left[\\frac{\\pi}{2},0.0,\\frac{\\pi}{2}\\right]$.\n  - $K_{\\psi}=\\left[2.2,1.0,0.4\\right]$, $\\delta_{\\psi}=\\left[0.0,\\frac{\\pi}{3},\\frac{\\pi}{2}\\right]$.\n  - $K_{c}=0.2$, $\\delta_{c}=0.0$.\n  - 距离映射常数: $r_{0}=2.8$, $a=0.30$, $b=0.35$, $\\phi_{0}=\\frac{\\pi}{6}$, $\\psi_{0}=\\frac{\\pi}{4}$.\n  - $T=298$, $\\sigma_{E}=0.15$, $\\mathrm{tol}=0.05$, seed $=123$.\n\n- 用例 3 (近乎平坦的边界情况):\n  - $K_{\\phi}=\\left[0.2,0.1,0.0\\right]$, $\\delta_{\\phi}=\\left[0.0,0.0,0.0\\right]$.\n  - $K_{\\psi}=\\left[0.2,0.1,0.0\\right]$, $\\delta_{\\psi}=\\left[0.0,0.0,0.0\\right]$.\n  - $K_{c}=0.0$, $\\delta_{c}=0.0$.\n  - 距离映射常数: $r_{0}=3.2$, $a=0.20$, $b=0.20$, $\\phi_{0}=0.0$, $\\psi_{0}=0.0$.\n  - $T=310$, $\\sigma_{E}=0.05$, $\\mathrm{tol}=0.08$, seed $=7$.\n\n对于每个用例，您的程序应计算：\n- 在整个网格上，$V_{\\mathrm{fit}}$ 和 $V_{\\mathrm{QM}}$ 之间的均方根误差 $\\mathrm{RMSE}$（单位为千焦耳/摩尔），四舍五入到三位小数。\n- NOE 有效距离 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$（单位为埃），四舍五入到三位小数。\n- 一个布尔值，指示 $\\left|r_{\\mathrm{eff}}^{\\mathrm{fit}}-r_{\\mathrm{eff}}^{\\mathrm{true}}\\right|\\leq \\mathrm{tol}$ 是否成立。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个结果列表。该列表由逗号分隔的各用例三元组构成，每个三元组用方括号括起来，整个列表也用方括号括起来。例如，输出应类似于 $\\left[\\left[\\mathrm{RMSE}_{1},r_{\\mathrm{eff},1},\\mathrm{pass}_{1}\\right],\\left[\\mathrm{RMSE}_{2},r_{\\mathrm{eff},2},\\mathrm{pass}_{2}\\right],\\left[\\mathrm{RMSE}_{3},r_{\\mathrm{eff},3},\\mathrm{pass}_{3}\\right]\\right]$，其中 $\\mathrm{pass}_{i}$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。所有角度单位必须是弧度，能量单位是千焦耳/摩尔，温度单位是开尔文，距离单位是埃，并且所有浮点值必须按要求四舍五入到三位小数。", "solution": "该问题提出了计算化学领域中一个有效且定义明确的任务，特别是在分子力学力场参数化领域。它要求实现一个算法流程，以重新拟合二糖糖苷键的二面角参数。该流程基于统计力学的基本原理，并通过与一个有物理意义的可观测量——核奥弗豪瑟效应 (NOE) 导出的质子间距离——进行对比来验证。此问题是自洽的、科学上合理的且计算上可行的。我们将继续提供详细的解决方案。\n\n目标是重新拟合控制糖苷扭转角 $\\phi$ 和 $\\psi$ 的势能面 $V(\\phi,\\psi)$，并通过其重现系综平均结构性质的能力来验证此拟合。该流程从第一性原理设计，避免了经验性捷径。\n\n**1. 理论和物理基础**\n\n分子的构象景观由其势能面 (PES) 决定。对于二面角，其势能是周期函数。任何足够平滑的 $2\\pi$ 周期函数都可以通过截断傅里叶级数来近似。这是大多数经典力场中二面角参数化的基石。\n\n我们从一个合成的“真实”势能面 $V_{\\mathrm{true}}(\\phi,\\psi)$ 开始，它模拟了高质量的量子力学扫描。其函数形式是每个扭转角的周期项与一个耦合项之和：\n$$\nV_{\\mathrm{true}}(\\phi,\\psi)=\\sum_{n=1}^{3}K_{\\phi,n}\\left[1-\\cos\\left(n\\phi-\\delta_{\\phi,n}\\right)\\right]+\\sum_{m=1}^{3}K_{\\psi,m}\\left[1-\\cos\\left(m\\psi-\\delta_{\\psi,m}\\right)\\right]+K_{c}\\left[1-\\cos\\left(\\phi-\\psi-\\delta_{c}\\right)\\right]\n$$\n在这里，$K$ 代表振幅（势垒高度），单位为千焦耳/摩尔 (kJ/mol)，$\\delta$ 是相位移，单位为弧度。通过向这个真实能量面添加标准差为 $\\sigma_E$ 的高斯噪声 $\\epsilon$，生成了合成的“量子力学”数据 $V_{\\mathrm{QM}}(\\phi,\\psi)$：$V_{\\mathrm{QM}}(\\phi,\\psi)=V_{\\mathrm{true}}(\\phi,\\psi)+\\epsilon$。\n\n待拟合的模型 $V_{\\mathrm{fit}}(\\phi,\\psi)$ 由三角基函数的线性组合构成。这一选择确保了所需的周期性，并允许通过线性最小二乘法直接求解。该基组包括一个常数项、每个角度频率最高为 3 的正弦和余弦函数，以及一个单一的交叉项：\n$$\nV_{\\mathrm{fit}}(\\phi,\\psi)=C+\\sum_{n=1}^{3}\\left[A_{\\phi,n}\\cos(n\\phi)+B_{\\phi,n}\\sin(n\\phi)\\right]+\\sum_{m=1}^{3}\\left[A_{\\psi,m}\\cos(m\\psi)+B_{\\psi,m}\\sin(m\\psi)\\right]+A_{c}\\cos(\\phi-\\psi)+B_{c}\\sin(\\phi-\\psi)\n$$\n微观势能面与宏观可观测量之间的联系由统计力学建立。在温度为 $T$ 的热平衡状态下，系统处于坐标为 $(\\phi,\\psi)$ 的状态的概率由玻尔兹曼分布给出：\n$$\np(\\phi,\\psi) = \\frac{1}{Z} \\exp\\left(-\\beta V(\\phi,\\psi)\\right)\n$$\n其中 $\\beta = 1/(k_{\\mathrm{B}}T)$ 是逆热能，$k_{\\mathrm{B}}$ 是玻尔兹曼常数 ($0.008314462618~\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$)，而 $Z = \\int \\int \\exp(-\\beta V(\\phi,\\psi)) d\\phi d\\psi$ 是配分函数。\n\n验证依赖于 NOE，它为质子间距离提供了实验约束。NOE 信号强度与 $\\langle r^{-6} \\rangle$ 成正比，其中 $r$ 是质子间距离，尖括号表示基于玻尔兹曼分布的系综平均。因此，有效距离定义为：\n$$\nr_{\\mathrm{eff}}=\\left\\langle r^{-6}\\right\\rangle^{-1/6}\n$$\n距离 $r$ 本身是二面角的函数，由三角函数映射 $r(\\phi,\\psi)=r_{0}+a\\cos\\left(\\phi-\\phi_{0}\\right)+b\\cos\\left(\\psi-\\psi_{0}\\right)$ 给出。\n\n**2. 算法流程与实现**\n\n该流程实现为一系列离散的计算步骤。所有操作都在一个 $N_{\\phi}=36 \\times N_{\\psi}=36$ 的均匀网格上进行，该网格覆盖 $\\phi, \\psi \\in [-\\pi, \\pi)$ 的范围。\n\n**步骤 1：数据生成**\n对于每个测试用例，我们首先构建扭转角 $(\\phi_i, \\psi_j)$ 的二维网格。然后，我们在每个网格点上计算 $V_{\\mathrm{true}}(\\phi_i, \\psi_j)$ 的解析表达式。使用一个特定的随机种子生成一个均值为 0、标准差为 $\\sigma_E$ 的高斯噪声值网格 $\\epsilon_{ij}$。将这些噪声值加到 $V_{\\mathrm{true}}$ 上，以生成用于拟合的目标数据 $V_{\\mathrm{QM}}$。\n\n**步骤 2：线性最小二乘拟合**\n重新拟合过程的核心是确定 $V_{\\mathrm{fit}}$ 模型的系数 $\\{C, A_{\\phi,n}, B_{\\phi,n}, \\ldots, B_c\\}$。这被表述为一个线性最小二乘问题：$\\mathbf{A}\\mathbf{c} \\approx \\mathbf{v}_{\\mathrm{QM}}$。\n- 向量 $\\mathbf{v}_{\\mathrm{QM}}$ 是一个由 $V_{\\mathrm{QM}}$ 能量面上 $N_{\\phi} \\times N_{\\psi} = 1296$ 个值展平而成的数组。\n- 向量 $\\mathbf{c}$ 包含待确定的 15 个未知系数。\n- 设计矩阵 $\\mathbf{A}$ 的维度为 $(1296 \\times 15)$。每一行对应一个网格点 $(\\phi_i, \\psi_j)$，每一列对应在该点计算的 15 个基函数之一。例如，第一列全是 1（对应系数 $C$），第二列是 $\\cos(\\phi_i)$，第三列是 $\\sin(\\phi_i)$，以此类推。\n\n最小化平方欧几里得范数 $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{v}_{\\mathrm{QM}}\\|^2$ 的最优系数向量 $\\mathbf{c}$ 是通过标准的线性最小二乘求解器（特别是 `numpy.linalg.lstsq`）找到的。一旦获得 $\\mathbf{c}$，就可以通过计算矩阵-向量乘积 $\\mathbf{A}\\mathbf{c}$ 并将结果重塑为 $36 \\times 36$ 的网格来重建拟合后的势能面 $V_{\\mathrm{fit}}$。此拟合的质量通过拟合面 $V_{\\mathrm{fit}}$ 与噪声数据 $V_{\\mathrm{QM}}$ 之间的均方根误差 (RMSE) 来量化：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N_{\\phi}N_{\\psi}}\\sum_{i,j}\\left(V_{\\mathrm{fit}}(\\phi_i,\\psi_j) - V_{\\mathrm{QM}}(\\phi_i,\\psi_j)\\right)^2}\n$$\n\n**步骤 3：通过系综平均进行验证**\n关键的验证步骤是评估拟合的势是否能重现“真实”系统的物理性质。我们使用离散求和来计算系综平均 $\\langle r^{-6} \\rangle$，求和在所有网格点上进行，并由它们的玻尔兹曼概率加权。对于一个通用的势能面 $V$，函数 $f(\\phi,\\psi)$ 的平均值为：\n$$\n\\langle f \\rangle \\approx \\frac{\\sum_{i,j} f(\\phi_i, \\psi_j) w_{ij}}{\\sum_{i,j} w_{ij}}\n$$\n其中统计权重为 $w_{ij}=\\exp\\left(-\\beta\\left[V(\\phi_{i},\\psi_{j})-V_{\\min}\\right]\\right)$。在进行指数运算前减去最小能量 $V_{\\min}$ 是一种防止数值溢出的标准技术。\n\n此计算执行两次：\n1. 使用 $V_{\\mathrm{true}}$ 计算“基准真相”有效距离 $r_{\\mathrm{eff}}^{\\mathrm{true}}$。\n2. 使用 $V_{\\mathrm{fit}}$ 计算我们模型的有效距离 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$。\n\n如果这两个距离之间的绝对差在指定的容差范围内，即 $|r_{\\mathrm{eff}}^{\\mathrm{fit}} - r_{\\mathrm{eff}}^{\\mathrm{true}}| \\leq \\mathrm{tol}$，则认为重新拟合成功。最终程序为每个测试用例实现此完整工作流程，并报告拟合的 RMSE、计算出的 $r_{\\mathrm{eff}}^{\\mathrm{fit}}$ 以及验证检查的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a full protocol for refitting and validating glycosidic\n    dihedral parameters based on synthetic QM data and NOE-derived distances.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (representative alpha linkage)\n        {\n            \"K_phi\": [2.5, 1.2, 0.5], \"d_phi\": [0.0, np.pi/3, np.pi/2],\n            \"K_psi\": [3.0, 0.8, 0.4], \"d_psi\": [np.pi/6, np.pi/2, np.pi/3],\n            \"K_c\": 0.6, \"d_c\": np.pi/4,\n            \"dist_map\": {\"r0\": 3.0, \"a\": 0.35, \"b\": 0.25, \"phi0\": 0.0, \"psi0\": np.pi/3},\n            \"T\": 300, \"sigma_E\": 0.1, \"tol\": 0.06, \"seed\": 42\n        },\n        # Case 2 (representative beta linkage)\n        {\n            \"K_phi\": [1.5, 0.7, 0.3], \"d_phi\": [np.pi/2, 0.0, np.pi/2],\n            \"K_psi\": [2.2, 1.0, 0.4], \"d_psi\": [0.0, np.pi/3, np.pi/2],\n            \"K_c\": 0.2, \"d_c\": 0.0,\n            \"dist_map\": {\"r0\": 2.8, \"a\": 0.30, \"b\": 0.35, \"phi0\": np.pi/6, \"psi0\": np.pi/4},\n            \"T\": 298, \"sigma_E\": 0.15, \"tol\": 0.05, \"seed\": 123\n        },\n        # Case 3 (near-flat edge case)\n        {\n            \"K_phi\": [0.2, 0.1, 0.0], \"d_phi\": [0.0, 0.0, 0.0],\n            \"K_psi\": [0.2, 0.1, 0.0], \"d_psi\": [0.0, 0.0, 0.0],\n            \"K_c\": 0.0, \"d_c\": 0.0,\n            \"dist_map\": {\"r0\": 3.2, \"a\": 0.20, \"b\": 0.20, \"phi0\": 0.0, \"psi0\": 0.0},\n            \"T\": 310, \"sigma_E\": 0.05, \"tol\": 0.08, \"seed\": 7\n        }\n    ]\n\n    # Global parameters\n    N_PHI = 36\n    N_PSI = 36\n    K_B = 0.008314462618  # kJ/mol/K\n\n    def generate_true_potential(phi, psi, K_phi, d_phi, K_psi, d_psi, K_c, d_c):\n        \"\"\"Generates the true potential energy surface V_true.\"\"\"\n        V = np.zeros_like(phi)\n        for n in range(1, 4):\n            if n-1  len(K_phi):\n                V += K_phi[n-1] * (1 - np.cos(n * phi - d_phi[n-1]))\n        for m in range(1, 4):\n            if m-1  len(K_psi):\n                V += K_psi[m-1] * (1 - np.cos(m * psi - d_psi[m-1]))\n        V += K_c * (1 - np.cos(phi - psi - d_c))\n        return V\n\n    def build_design_matrix(phi, psi):\n        \"\"\"Builds the design matrix A for the linear least squares fit.\"\"\"\n        num_points = phi.size\n        # 1(const) + 3*2(phi) + 3*2(psi) + 2(couple) = 15 columns\n        A = np.zeros((num_points, 15))\n        \n        phi_flat = phi.flatten()\n        psi_flat = psi.flatten()\n        \n        A[:, 0] = 1.0  # Constant term\n        col_idx = 1\n        for n in range(1, 4):\n            A[:, col_idx] = np.cos(n * phi_flat)\n            A[:, col_idx+1] = np.sin(n * phi_flat)\n            col_idx += 2\n            \n        for m in range(1, 4):\n            A[:, col_idx] = np.cos(m * psi_flat)\n            A[:, col_idx+1] = np.sin(m * psi_flat)\n            col_idx += 2\n            \n        A[:, col_idx] = np.cos(phi_flat - psi_flat)\n        A[:, col_idx+1] = np.sin(phi_flat - psi_flat)\n        \n        return A\n\n    def calculate_effective_distance(V, phi, psi, T, r0, a, b, phi0, psi0):\n        \"\"\"Calculates the NOE effective distance r_eff from a potential surface V.\"\"\"\n        beta = 1.0 / (K_B * T)\n        \n        # Numerically stable Boltzmann weights\n        V_min = np.min(V)\n        weights = np.exp(-beta * (V - V_min))\n        Z = np.sum(weights)\n        probs = weights / Z\n        \n        # Distance map\n        R = r0 + a * np.cos(phi - phi0) + b * np.cos(psi - psi0)\n        \n        # Ensemble average of r^-6\n        r_m6_avg = np.sum(probs * (R**(-6)))\n        \n        # Effective distance\n        r_eff = r_m6_avg**(-1.0/6.0)\n        \n        return r_eff\n\n    results = []\n    \n    # Grid setup\n    phi_1d = np.linspace(-np.pi, np.pi, N_PHI, endpoint=False)\n    psi_1d = np.linspace(-np.pi, np.pi, N_PSI, endpoint=False)\n    PHI, PSI = np.meshgrid(phi_1d, psi_1d)\n\n    A_matrix = build_design_matrix(PHI, PSI)\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        V_true = generate_true_potential(PHI, PSI, case[\"K_phi\"], case[\"d_phi\"],\n                                         case[\"K_psi\"], case[\"d_psi\"], case[\"K_c\"], case[\"d_c\"])\n        \n        rng = np.random.default_rng(case[\"seed\"])\n        noise = rng.normal(0, case[\"sigma_E\"], size=(N_PSI, N_PHI))\n        V_QM = V_true + noise\n        \n        # 2. Fit the model using linear least squares\n        b = V_QM.flatten()\n        coeffs, _, _, _ = np.linalg.lstsq(A_matrix, b, rcond=None)\n        \n        V_fit_flat = A_matrix @ coeffs\n        V_fit = V_fit_flat.reshape((N_PSI, N_PHI))\n        \n        # 4. Calculate RMSE\n        rmse = np.sqrt(np.mean((V_fit - V_QM)**2))\n        \n        # 3. Validate with NOE distance\n        r_eff_true = calculate_effective_distance(V_true, PHI, PSI, case[\"T\"], **case[\"dist_map\"])\n        r_eff_fit = calculate_effective_distance(V_fit, PHI, PSI, case[\"T\"], **case[\"dist_map\"])\n        \n        # 4. Check tolerance\n        passes_check = np.abs(r_eff_fit - r_eff_true) = case[\"tol\"]\n        \n        # Format results\n        results.append([round(rmse, 3), round(r_eff_fit, 3), bool(passes_check)])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\").replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```", "id": "3400156"}, {"introduction": "一个力场的最终考验在于它是否能在模拟中重现正确的构象平衡分布。本练习着重于模拟数据的后处理，我们将学习如何从轨迹的构象分布中构建关键自由度（糖苷键扭转角）的二维自由能面。您将应用玻尔兹曼反演原理，将采样得到的概率直方图转换为自由能，并将计算出的能量盆地的位置与高水平QM计算的最小值进行比较，这是验证力场在描述构象动力学和平衡方面准确性的标准方法。[@problem_id:3400219]", "problem": "您的任务是实现一个有原则的协议，根据分子动力学模拟计算双糖糖苷键扭转角的二维自由能面，并将主要扭转势阱的位置与量子力学（QM）预测的位置进行比较。其科学基础是玻尔兹曼分布及其反演，即从概率得到自由能。扭转角是周期性变量，所有角度计算都必须以正确的周期性环绕方式进行。物理和数值规范以及一个测试套件在下面提供。\n\n从以下基本原理开始。在温度为 $T$ 的平衡状态下，观测到亥姆霍兹自由能为 $F(\\boldsymbol{x})$ 的构型 $\\boldsymbol{x}$ 的概率密度 $p(\\boldsymbol{x})$ 服从玻尔兹曼分布\n$$\np(\\boldsymbol{x}) \\propto \\exp\\left(-\\beta F(\\boldsymbol{x})\\right), \\quad \\beta = \\frac{1}{k_{\\mathrm{B}} T},\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。因此，如果一个粗粒化直方图提供了糖苷键扭转角 $(\\phi,\\psi)$ 在网格上的概率估计 $P(\\phi,\\psi)$，则相应的自由能面可定义为（相差一个可加常数）：\n$$\nF(\\phi,\\psi) = -k_{\\mathrm{B}} T \\ln P(\\phi,\\psi) + C,\n$$\n其中 $C$ 的选择使得 $\\min_{\\phi,\\psi} F(\\phi,\\psi) = 0$，以固定参考点。角度以 $360^\\circ$ 为周期，两个角度 $\\theta_a$ 和 $\\theta_b$（以度为单位）之间的角度差必须计算为\n$$\n\\Delta\\theta = \\mathrm{wrap}\\_{\\pm 180}\\!\\left(\\theta_a - \\theta_b\\right) = \\left[\\left(\\theta_a - \\theta_b + 180\\right) \\bmod 360\\right] - 180,\n$$\n以使 $\\Delta\\theta \\in [-180,180)$。\n\n您的程序必须为每个测试用例实现以下计算步骤：\n\n1. 在环面上，根据指定的周期性二维高斯函数混合体，在一个由扭转角中心 $\\{\\phi_i\\}$ 和 $\\{\\psi_j\\}$（以度为单位）组成的矩形网格上，构建一个离散化的概率直方图 $P(\\phi_i,\\psi_j)$。每个高斯分量 $k$ 在中心 $(\\phi^{(k)}\\_0,\\psi^{(k)}\\_0)$ 处贡献权重 $w_k$，标准差为 $(\\sigma\\_\\phi^{(k)},\\sigma\\_\\psi^{(k)})$（以度为单位），其贡献为\n$$\nG^{(k)}(\\phi_i,\\psi_j) = w_k \\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{\\Delta\\phi^{(k)}\\_{i}}{\\sigma\\_\\phi^{(k)}}\\right)^2 + \\left(\\frac{\\Delta\\psi^{(k)}\\_{j}}{\\sigma\\_\\psi^{(k)}}\\right)^2\\right]\\right),\n$$\n其中 $\\Delta\\phi^{(k)}\\_{i}$ 和 $\\Delta\\psi^{(k)}\\_{j}$ 是使用上面给出的周期性差值公式计算的 $(\\phi_i,\\psi_j)$ 和 $(\\phi^{(k)}\\_0,\\psi^{(k)}\\_0)$ 之间的环绕角度差。未归一化的直方图为 $P\\_{\\mathrm{unnorm}}(\\phi_i,\\psi_j) = \\sum_k G^{(k)}(\\phi_i,\\psi_j)$。归一化直方图，使得 $\\sum\\_{i,j} P(\\phi_i,\\psi_j) = 1$。如果高斯分量列表为空，则将 $P(\\phi_i,\\psi_j)$ 设置为网格上的均匀分布。\n\n2. 计算自由能面\n$$\nF(\\phi_i,\\psi_j) = -k\\_{\\mathrm{B}} T \\ln \\max\\left(P(\\phi_i,\\psi_j), \\varepsilon\\right),\n$$\n其中 $k\\_{\\mathrm{B}} = 0.0019872041$，单位为 $\\mathrm{kcal\\,mol^{-1}\\,K^{-1}}$，$T$ 是以开尔文为单位的绝对温度，$\\varepsilon$ 是一个小的正数下限，以避免 $\\ln 0$。通过从所有条目中减去 $\\min\\_{i,j} F(\\phi_i,\\psi_j)$ 来平移曲面，使其最小值为零。\n\n3. 在 $\\phi$ 和 $\\psi$ 方向均采用周期性边界条件和八邻域连接的情况下，将 $P(\\phi_i,\\psi_j)$ 的严格局部最大值集合检测为主要扭转势阱集合，并受占据率截断值的限制。一个网格点 $(i,j)$ 是一个被检测到的峰值，当且仅当：\n   - 对于周期性网格上 $(i,j)$ 的所有八个邻居 $(i',j')$，都有 $P(\\phi_i,\\psi_j)  P(\\phi_{i'},\\psi_{j'})$，并且\n   - $P(\\phi_i,\\psi_j) \\ge f\\_{\\mathrm{cut}} \\cdot \\max\\_{i,j} P(\\phi_i,\\psi_j)$，其中 $f\\_{\\mathrm{cut}} \\in (0,1]$ 是一个给定的分数。\n\n4. 使用独立角度容差 $\\Delta\\phi\\_{\\mathrm{tol}}$ 和 $\\Delta\\psi\\_{\\mathrm{tol}}$（以度为单位），将检测到的峰值位置与提供的 QM 预测的最小值列表 $\\{(\\phi^{\\mathrm{QM}}_m,\\psi^{\\mathrm{QM}}_m)\\}$进行比较。一个 QM 最小值 $(\\phi^{\\mathrm{QM}}_m,\\psi^{\\mathrm{QM}}_m)$ 被认为是匹配的，如果存在至少一个位于 $(\\phi^\\*,\\psi^\\*)$ 的检测峰值，使得\n$$\n|\\mathrm{wrap}\\_{\\pm 180}(\\phi^\\* - \\phi^{\\mathrm{QM}}_m)| \\le \\Delta\\phi\\_{\\mathrm{tol}} \\quad \\text{and} \\quad |\\mathrm{wrap}\\_{\\pm 180}(\\psi^\\* - \\psi^{\\mathrm{QM}}_m)| \\le \\Delta\\psi\\_{\\mathrm{tol}}.\n$$\n\n对于每个测试用例，您的程序必须返回一个布尔值，指示该测试用例中的每个 QM 最小值是否都与至少一个检测到的峰值匹配。程序必须将所有测试用例的结果汇总到单行输出中，包含用方括号括起来的逗号分隔的布尔值列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。\n\n角度必须以度为单位。温度必须以开尔文为单位。自由能必须以 $\\mathrm{kcal\\,mol^{-1}}$ 计算，尽管您不需要打印能量。所有角度差异和比较都必须遵守周期性。\n\n测试套件。请精确实现以下三个测试用例：\n\n- 测试用例 A（具有两个主要势阱的一般情况）：\n  - 温度 $T = 300$。\n  - $\\phi$ 中心：从 $-180$ 到 $150$（含）的等差数列，步长为 $30$（即 $\\{-180,-150,\\dots,150\\}$）。\n  - $\\psi$ 中心：与 $\\phi$ 相同。\n  - 高斯分量：两个分量，参数如下\n    - 分量 1：权重 $w\\_1 = 1.0$，中心 $(\\phi^{(1)}\\_0,\\psi^{(1)}\\_0) = (-60,120)$，宽度 $(\\sigma\\_\\phi^{(1)},\\sigma\\_\\psi^{(1)}) = (20,20)$。\n    - 分量 2：权重 $w\\_2 = 0.8$，中心 $(\\phi^{(2)}\\_0,\\psi^{(2)}\\_0) = (60,-120)$，宽度 $(\\sigma\\_\\phi^{(2)},\\sigma\\_\\psi^{(2)}) = (20,20)$。\n  - 概率下限 $\\varepsilon = 10^{-12}$。\n  - 占据率截断值 $f\\_{\\mathrm{cut}} = 0.6$。\n  - QM 最小值列表：$[(-60,120),(60,-120)]$。\n  - 容差：$\\Delta\\phi\\_{\\mathrm{tol}} = 15$, $\\Delta\\psi\\_{\\mathrm{tol}} = 15$。\n\n- 测试用例 B（周期性边缘附近有势阱的边界环绕情况）：\n  - 温度 $T = 300$。\n  - $\\phi$ 中心：从 $-180$ 到 $160$（含）的等差数列，步长为 $20$（即 $\\{-180,-160,\\dots,160\\}$）。\n  - $\\psi$ 中心：与 $\\phi$ 相同。\n  - 高斯分量：两个分量，参数如下\n    - 分量 1：权重 $w\\_1 = 1.0$，中心 $(\\phi^{(1)}\\_0,\\psi^{(1)}\\_0) = (170,-170)$，宽度 $(\\sigma\\_\\phi^{(1)},\\sigma\\_\\psi^{(1)}) = (15,15)$。\n    - 分量 2：权重 $w\\_2 = 0.5$，中心 $(\\phi^{(2)}\\_0,\\psi^{(2)}\\_0) = (-30,30)$，宽度 $(\\sigma\\_\\phi^{(2)},\\sigma\\_\\psi^{(2)}) = (20,20)$。\n  - 概率下限 $\\varepsilon = 10^{-12}$。\n  - 占据率截断值 $f\\_{\\mathrm{cut}} = 0.7$。\n  - QM 最小值列表：$[(170,-170)]$。\n  - 容差：$\\Delta\\phi\\_{\\mathrm{tol}} = 20$, $\\Delta\\psi\\_{\\mathrm{tol}} = 20$。\n\n- 测试用例 C（接近均匀直方图的边缘情况）：\n  - 温度 $T = 300$。\n  - $\\phi$ 中心：从 $-180$ 到 $150$（含）的等差数列，步长为 $30$。\n  - $\\psi$ 中心：与 $\\phi$ 相同。\n  - 高斯分量：无（空列表）。这意味着网格上为均匀直方图。\n  - 概率下限 $\\varepsilon = 10^{-12}$。\n  - 占据率截断值 $f\\_{\\mathrm{cut}} = 0.5$。\n  - QM 最小值列表：$[(0,0),(60,60)]$。\n  - 容差：$\\Delta\\phi\\_{\\mathrm{tol}} = 15$, $\\Delta\\psi\\_{\\mathrm{tol}} = 15$。\n\n最终输出格式。您的程序必须生成单行输出，其中包含三个布尔结果，以逗号分隔并用方括号括起来，顺序与测试用例 A、B、C 相同；例如，如果前两个测试用例通过而第三个未通过，则输出为 $[\\mathrm{True},\\mathrm{True},\\mathrm{False}]$。不允许有其他输出。", "solution": "问题陈述已经过仔细审查，并被确定为 **有效**。它在科学上基于统计力学原理，特别是玻尔兹曼分布，并提出了一个适定、客观且算法细节详尽的计算任务。所有必要的数据、常数和边界条件都已提供，问题没有矛盾或含糊之处。任务是实现一个既定协议，用于分析模拟的糖苷键扭转角概率分布，这是计算生物物理学中用于力场验证和构象分析的标准程序。\n\n计算协议将遵循问题陈述中概述的四个步骤来实施。\n\n**步骤 1：构建概率密度直方图**\n\n此分析的基础是定义在扭转角 $\\phi$ 和 $\\psi$ 上的二维概率密度函数 $P(\\phi,\\psi)$。该函数在一个离散的点网格 $\\{(\\phi_i, \\psi_j)\\}$ 上进行估计。每个测试用例的网格点被指定为等差数列。对于给定的起始点 $s$、结束点 $e$ 和步长 $\\delta$，使用 $N = \\mathrm{round}((e-s)/\\delta) + 1$ 个从 $s$ 到 $e$（含）的等间距点来稳健地生成网格点。\n\n概率密度被建模为加权的周期性二维高斯函数的总和。每个高斯分量 $k$ 对网格点 $(\\phi_i, \\psi_j)$ 处未归一化概率的贡献由下式给出：\n$$\nG^{(k)}(\\phi_i,\\psi_j) = w_k \\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{\\Delta\\phi^{(k)}_{i}}{\\sigma_\\phi^{(k)}}\\right)^2 + \\left(\\frac{\\Delta\\psi^{(k)}_{j}}{\\sigma_\\psi^{(k)}}\\right)^2\\right]\\right)\n$$\n此处，$w_k$ 是权重，$(\\sigma_\\phi^{(k)}, \\sigma_\\psi^{(k)})$ 是标准差，$(\\Delta\\phi^{(k)}_{i}, \\Delta\\psi^{(k)}_{j})$ 是网格点 $(\\phi_i, \\psi_j)$ 与高斯中心 $(\\phi^{(k)}_0, \\psi^{(k)}_0)$ 之间的角度差。由于扭转角是周期性的，这些差异必须在一个圆上计算。两个角度 $\\theta_a$ 和 $\\theta_b$（以度为单位）之间正确的环绕差 $\\Delta\\theta$（将结果映射到区间 $[-180, 180)$）计算如下：\n$$\n\\Delta\\theta = \\mathrm{wrap}_{\\pm 180}(\\theta_a - \\theta_b) = ((\\theta_a - \\theta_b + 180) \\pmod{360}) - 180\n$$\n每个网格点的总未归一化概率是所有高斯分量贡献的总和，$P_{\\mathrm{unnorm}}(\\phi_i,\\psi_j) = \\sum_k G^{(k)}(\\phi_i,\\psi_j)$。如果高斯分量列表为空，则假定为均匀概率分布，即 $P_{\\mathrm{unnorm}}(\\phi_i,\\psi_j)$ 是一个常数。\n\n最后，对概率分布进行归一化，使其在所有网格点上的总和为 1：\n$$\nP(\\phi_i,\\psi_j) = \\frac{P_{\\mathrm{unnorm}}(\\phi_i,\\psi_j)}{\\sum_{i,j} P_{\\mathrm{unnorm}}(\\phi_i,\\psi_j)}\n$$\n\n**步骤 2：自由能面计算**\n\n根据玻尔兹曼分布，亥姆霍兹自由能 $F(\\phi,\\psi)$ 与概率密度 $P(\\phi,\\psi)$ 的关系为 $P \\propto \\exp(-F / (k_{\\mathrm{B}}T))$。对其进行反演可得到自由能面：\n$$\nF(\\phi_i,\\psi_j) = -k_{\\mathrm{B}} T \\ln \\max(P(\\phi_i,\\psi_j), \\varepsilon)\n$$\n其中 $k_{\\mathrm{B}} = 0.0019872041 \\, \\mathrm{kcal\\,mol^{-1}\\,K^{-1}}$ 是玻尔兹曼常数，$T$ 是以开尔文为单位的温度，$\\varepsilon$ 是一个小的正常数，以防止对零取对数时出现数值问题。然后通过一个可加常数对该曲面进行平移，使其最小值为 0。虽然此步骤对于物理释义至关重要，但所需的输出仅取决于概率分布 $P$，因此自由能面本身无需在最终程序中计算。$P$ 中的局部最大值对应于 $F$ 中的局部最小值（势阱）。\n\n**步骤 3：检测扭转势阱（概率峰值）**\n\n主要构象势阱被识别为概率矩阵 $P(\\phi_i,\\psi_j)$ 中的严格局部最大值。一个网格点 $(i,j)$ 如果满足两个条件，则对应一个检测到的峰值：\n1.  **严格局部最大值：** $(i,j)$ 点的概率必须严格大于其所有八个直接邻居的概率：对于所有邻居 $(i',j')$，都有 $P(\\phi_i,\\psi_j)  P(\\phi_{i'},\\psi_{j'})$。邻域搜索必须遵守域的周期性，这意味着索引会在网格边界处环绕。\n2.  **占据率截断：** 峰值处的概率必须足够显著，超过全局最大概率的一定分数 $f_{\\mathrm{cut}} \\in (0,1]$：$P(\\phi_i,\\psi_j) \\ge f_{\\mathrm{cut}} \\cdot \\max_{k,l} P(\\phi_k,\\psi_l)$。\n\n满足这两个条件的网格坐标集 $(\\phi_i, \\psi_j)$ 构成了检测到的扭转势阱。\n\n**步骤 4：与量子力学（QM）最小值比较**\n\n最后一步是通过将检测到的势阱位置与高级别量子力学计算预测的能量最小值参考列表 $\\{(\\phi^{\\mathrm{QM}}_m, \\psi^{\\mathrm{QM}}_m)\\}$ 进行比较，来验证模拟结果。一个 QM 最小值 $(\\phi^{\\mathrm{QM}}_m, \\psi^{\\mathrm{QM}}_m)$ 被视为“匹配”，如果至少存在一个检测到的峰值 $(\\phi^*, \\psi^*)$ 位于其周围指定的容差框内。此条件使用周期性角度差正式表示为：\n$$\n|\\mathrm{wrap}_{\\pm 180}(\\phi^* - \\phi^{\\mathrm{QM}}_m)| \\le \\Delta\\phi_{\\mathrm{tol}} \\quad \\land \\quad |\\mathrm{wrap}_{\\pm 180}(\\psi^* - \\psi^{\\mathrm{QM}}_m)| \\le \\Delta\\psi_{\\mathrm{tol}}\n$$\n其中 $\\Delta\\phi_{\\mathrm{tol}}$ 和 $\\Delta\\psi_{\\mathrm{tol}}$ 是给定的角度容差。\n\n对于每个测试用例，最终结果是一个布尔值：如果每个提供的 QM 最小值都与至少一个检测到的峰值匹配，则为 `True`，否则为 `False`。程序会将所有测试用例的这些布尔结果汇总成指定的列表格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            # Test case A\n            \"T\": 300.0,\n            \"phi_grid_params\": (-180, 150, 30),\n            \"psi_grid_params\": (-180, 150, 30),\n            \"gaussians\": [\n                {\"weight\": 1.0, \"center\": (-60.0, 120.0), \"widths\": (20.0, 20.0)},\n                {\"weight\": 0.8, \"center\": (60.0, -120.0), \"widths\": (20.0, 20.0)},\n            ],\n            \"epsilon\": 1e-12,\n            \"f_cut\": 0.6,\n            \"qm_minima\": [(-60.0, 120.0), (60.0, -120.0)],\n            \"tolerances\": (15.0, 15.0),\n        },\n        {\n            # Test case B\n            \"T\": 300.0,\n            \"phi_grid_params\": (-180, 160, 20),\n            \"psi_grid_params\": (-180, 160, 20),\n            \"gaussians\": [\n                {\"weight\": 1.0, \"center\": (170.0, -170.0), \"widths\": (15.0, 15.0)},\n                {\"weight\": 0.5, \"center\": (-30.0, 30.0), \"widths\": (20.0, 20.0)},\n            ],\n            \"epsilon\": 1e-12,\n            \"f_cut\": 0.7,\n            \"qm_minima\": [(170.0, -170.0)],\n            \"tolerances\": (20.0, 20.0),\n        },\n        {\n            # Test case C\n            \"T\": 300.0,\n            \"phi_grid_params\": (-180, 150, 30),\n            \"psi_grid_params\": (-180, 150, 30),\n            \"gaussians\": [],\n            \"epsilon\": 1e-12,\n            \"f_cut\": 0.5,\n            \"qm_minima\": [(0.0, 0.0), (60.0, 60.0)],\n            \"tolerances\": (15.0, 15.0),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _wrap_pm180(angle):\n    \"\"\"Computes the periodic angle difference to the range [-180, 180).\"\"\"\n    return (angle + 180) % 360 - 180\n\ndef _process_case(params):\n    \"\"\"\n    Processes a single test case according to the specified protocol.\n    \"\"\"\n    # Step 1: Construct probability histogram\n    \n    # Generate grid centers robustly\n    start_phi, stop_phi, step_phi = params[\"phi_grid_params\"]\n    num_phi = round((stop_phi - start_phi) / step_phi) + 1\n    phi_grid = np.linspace(start_phi, stop_phi, num_phi)\n\n    start_psi, stop_psi, step_psi = params[\"psi_grid_params\"]\n    num_psi = round((stop_psi - start_psi) / step_psi) + 1\n    psi_grid = np.linspace(start_psi, stop_psi, num_psi)\n    \n    # Create meshgrid for vectorized calculation\n    phis, psis = np.meshgrid(phi_grid, psi_grid, indexing='ij')\n    \n    prob_matrix = np.zeros_like(phis)\n\n    if not params[\"gaussians\"]:\n        # Uniform probability for empty Gaussian list\n        prob_matrix.fill(1.0)\n    else:\n        for g in params[\"gaussians\"]:\n            w = g[\"weight\"]\n            phi0, psi0 = g[\"center\"]\n            sigma_phi, sigma_psi = g[\"widths\"]\n            \n            d_phi = _wrap_pm180(phis - phi0)\n            d_psi = _wrap_pm180(psis - psi0)\n            \n            exponent = -0.5 * ((d_phi / sigma_phi)**2 + (d_psi / sigma_psi)**2)\n            prob_matrix += w * np.exp(exponent)\n\n    # Normalize the probability matrix\n    total_prob = np.sum(prob_matrix)\n    if total_prob > 0:\n        prob_matrix /= total_prob\n    \n    # Step 3: Detect dominant torsional basins\n    \n    detected_peaks = []\n    if np.any(prob_matrix):\n        p_max = np.max(prob_matrix)\n        if p_max > 0: # Avoid division by zero for an all-zero matrix\n            f_cut = params[\"f_cut\"]\n            \n            for i in range(num_phi):\n                for j in range(num_psi):\n                    p_val = prob_matrix[i, j]\n                    \n                    # Condition 1: Occupancy cutoff\n                    if p_val  f_cut * p_max:\n                        continue\n                    \n                    # Condition 2: Strict local maximum\n                    is_strict_max = True\n                    for di in [-1, 0, 1]:\n                        for dj in [-1, 0, 1]:\n                            if di == 0 and dj == 0:\n                                continue\n                            \n                            # Periodic neighbor indices\n                            ni = (i + di) % num_phi\n                            nj = (j + dj) % num_psi\n                            \n                            if p_val = prob_matrix[ni, nj]:\n                                is_strict_max = False\n                                break\n                        if not is_strict_max:\n                            break\n                    \n                    if is_strict_max:\n                        detected_peaks.append((phi_grid[i], psi_grid[j]))\n\n    # Step 4: Compare with QM minima\n    \n    qm_minima = params[\"qm_minima\"]\n    if not qm_minima:\n        return True # Vacuously true if there are no QM minima to match\n\n    all_qm_matched = True\n    for qm_min in qm_minima:\n        qm_phi, qm_psi = qm_min\n        tol_phi, tol_psi = params[\"tolerances\"]\n        is_this_qm_matched = False\n        \n        for peak in detected_peaks:\n            peak_phi, peak_psi = peak\n            \n            d_phi_match = _wrap_pm180(peak_phi - qm_phi)\n            d_psi_match = _wrap_pm180(peak_psi - qm_psi)\n            \n            if abs(d_phi_match) = tol_phi and abs(d_psi_match) = tol_psi:\n                is_this_qm_matched = True\n                break # Found a match for this QM minimum\n        \n        if not is_this_qm_matched:\n            all_qm_matched = False\n            break # One QM minimum was not matched, so the case fails\n            \n    return all_qm_matched\n\nsolve()\n\n```", "id": "3400219"}]}