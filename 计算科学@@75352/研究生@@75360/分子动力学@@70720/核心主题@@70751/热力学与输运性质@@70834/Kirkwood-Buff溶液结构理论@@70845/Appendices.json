{"hands_on_practices": [{"introduction": "柯克伍德-巴夫积分（KBI）的计算核心在于求解积分 $G_{ij} = 4\\pi \\int_0^\\infty (g_{ij}(r) - 1) r^2 dr$。在编写任何复杂的科学计算程序时，首要任务是验证核心算法的正确性。本练习将通过一个最简单的物理情景——理想气体——来构建和测试一个数值积分器。[@problem_id:3419765] 在理想气体中，粒子间不存在空间关联，即 $g_{ij}(r)=1$，因此 $G_{ij}$ 的精确值必须为零。这个“零测试”是验证我们对积分公式（特别是 $4\\pi r^2$ 体积元）的理解和代码实现是否准确的黄金标准。", "problem": "考虑一个理想气体极限下的二元混合物，其中粒子不相互作用，结构在三维空间中是各向同性的。设物种 $i$ 和 $j$ 之间的径向分布函数 (RDF) 表示为 $g_{ij}(r)$。在理想气体极限下，不存在空间相关性，RDF 满足对于所有 $r > 0$ 都有 $g_{ij}(r) = 1$。Kirkwood-Buff (KB) 积分 $G_{ij}$ 定义为总相关函数 $h_{ij}(\\mathbf{r}) = g_{ij}(\\mathbf{r}) - 1$ 在整个空间上的积分。在各向同性流体中，该积分可以用径向坐标 $r$ 和适当的球面测度来表示。\n\n您的任务是推导、实现并单元测试一个基于在均匀径向网格上采样的离散化 RDF 的 $G_{ij}$ 数值估计器。推导必须从 RDF 的定义和 KB 积分作为总相关函数在空间上的三维积分的定义开始，并通过正确的球面测度将其特化为适用于各向同性系统。然后，设计一个一致的数值积分方法，使用在区间 $[0, R_{\\max}]$ 上间距为 $\\Delta r$ 的均匀网格来近似各向同性的三维积分。该估计器必须至少支持两种积分法则：复合梯形法则和复合辛普森法则（后者要求奇数个网格点）。\n\n在理想气体极限下，$g_{ij}(r) = 1$，因此精确积分为 $G_{ij} = 0$。利用这一事实构建一个单元测试套件，检查数值估计器是否在指定的绝对容差内得到接近 $0$ 的值。为了在不脱离理想气体极限的情况下模拟来自分子动力学 (MD) 数据的真实有限采样伪影，可以选择在积分前向 $g_{ij}(r)$ 添加指定标准差 $\\sigma$ 的零均值高斯噪声；这保留了理想气体的期望值 $G_{ij}=0$，但引入了数值偏差，一个稳健的估计器应能将其控制在您必须指定的容差范围内。如果使用噪声，您必须使用提供的随机种子以确保可复现性。\n\n实现细节和要求：\n- 构建均匀网格为 $r_k = k\\,\\Delta r$，其中 $k = 0, 1, \\dots, N$，且 $N = R_{\\max}/\\Delta r$ 假定为整数，因此网格包括 $0$ 和 $R_{\\max}$。距离 $r$ 的单位必须是纳米 (nm)。最终的 Kirkwood-Buff 积分必须以立方纳米 (nm$^3$) 为单位进行报告和比较。\n- 数值估计器必须实现复合梯形法则和复合辛普森法则，以使用三维各向同性系统的正确球面测度，对 $g_{ij}(r) - 1$ 在空间上的积分进行近似计算。\n- 对于单元测试，请使用以下测试套件。对于每种情况，按所述构建 $g_{ij}(r)$ 为 $1$ 加上可选的、在每个网格点上独立添加的高斯噪声 $\\mathcal{N}(0,\\sigma^2)$，当 $\\sigma > 0$ 时使用提供的随机种子。计算数值估计值 $\\widehat{G}_{ij}$，并返回一个布尔值，指示是否满足 $|\\widehat{G}_{ij}| \\le \\text{tol}$，其中 $\\text{tol}$ 是给定的绝对容差，单位为 nm$^3$。\n    1. 情况 A (正常路径，梯形法则，细网格，无噪声)：$\\Delta r = 0.01$ nm, $R_{\\max} = 10.0$ nm, 积分法则 = trapezoid, $\\sigma = 0$, 容差 $\\text{tol} = 1.0\\times 10^{-12}$ nm$^3$。\n    2. 情况 B (正常路径，辛普森法则，细网格，无噪声)：$\\Delta r = 0.0025$ nm, $R_{\\max} = 5.0$ nm, 积分法则 = Simpson, $\\sigma = 0$, 容差 $\\text{tol} = 1.0\\times 10^{-12}$ nm$^3$。\n    3. 情况 C (有噪声，中等网格)：$\\Delta r = 0.005$ nm, $R_{\\max} = 5.0$ nm, 积分法则 = trapezoid, $\\sigma = 1.0\\times 10^{-7}$, 随机种子 $12345$, 容差 $\\text{tol} = 1.0\\times 10^{-4}$ nm$^3$。\n    4. 情况 D (边界条件，非常粗的网格，无噪声)：$\\Delta r = 1.0$ nm, $R_{\\max} = 1.0$ nm, 积分法则 = trapezoid, $\\sigma = 0$, 容差 $\\text{tol} = 1.0\\times 10^{-12}$ nm$^3$。\n    5. 情况 E (小截断距离，有噪声)：$\\Delta r = 0.01$ nm, $R_{\\max} = 0.5$ nm, 积分法则 = trapezoid, $\\sigma = 1.0\\times 10^{-6}$, 随机种子 $24680$, 容差 $\\text{tol} = 1.0\\times 10^{-6}$ nm$^3$。\n\n您的程序必须：\n- 使用正确的三维各向同性测度和指定的积分法则实现 $G_{ij}$ 的数值估计器。\n- 对于每个测试用例，按所述构建网格和 $g_{ij}(r)$，计算 $\\widehat{G}_{ij}$，将 $|\\widehat{G}_{ij}|$ 与提供的容差进行比较，并收集一个布尔结果。\n- 生成单行输出，其中包含情况 A 到 E 的布尔结果，形式为逗号分隔的列表，并用方括号括起来，例如 `[True,False,True,True,True]`。\n\n注意：确保任何角度（如果出现）都将以弧度为单位，但这里没有使用角度。距离单位必须是纳米 (nm)，Kirkwood-Buff 积分单位必须是立方纳米 (nm$^3$)。最终程序必须在没有外部输入的情况下运行，并且必须以指定格式精确打印一行。[@problem_id:458]", "solution": "该问题要求推导和实现 Kirkwood-Buff (KB) 积分 $G_{ij}$ 的数值估计器，适用于理想气体极限下的二元混合物。该估计器的验证通过一个单元测试套件进行，其中理想气体条件意味着积分的理论值为零。\n\n### 各向同性 KB 积分估计器的推导\n\nKirkwood-Buff 积分 $G_{ij}$ 定义为总相关函数 $h_{ij}(\\mathbf{r})$ 在整个空间上的体积积分。总相关函数通过 $h_{ij}(\\mathbf{r}) = g_{ij}(\\mathbf{r}) - 1$ 与径向分布函数 (RDF) $g_{ij}(\\mathbf{r})$ 相关。\n$G_{ij}$ 的定义是：\n$$\nG_{ij} = \\int_{\\mathbb{R}^3} h_{ij}(\\mathbf{r}) \\, d\\mathbf{r}\n$$\n\n对于各向同性系统，相关函数仅依赖于标量距离 $r = |\\mathbf{r}|$，因此 $g_{ij}(\\mathbf{r}) = g_{ij}(r)$ 和 $h_{ij}(\\mathbf{r}) = h_{ij}(r)$。这种对称性允许通过转换为球坐标来显著简化三维积分。在球坐标中，微分体积元为 $d\\mathbf{r} = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$，其中 $r \\in [0, \\infty)$，$\\theta \\in [0, \\pi]$，$\\phi \\in [0, 2\\pi]$。\n\n$G_{ij}$ 的积分可以重写为：\n$$\nG_{ij} = \\int_0^\\infty \\int_0^\\pi \\int_0^{2\\pi} h_{ij}(r) \\, r^2 \\sin\\theta \\, d\\phi \\, d\\theta \\, dr\n$$\n\n由于被积函数 $h_{ij}(r) r^2$ 不依赖于角变量 $\\theta$ 和 $\\phi$，我们可以分开进行角度积分：\n$$\n\\int_0^{2\\pi} d\\phi = 2\\pi\n$$\n$$\n\\int_0^\\pi \\sin\\theta \\, d\\theta = [-\\cos\\theta]_0^\\pi = (-\\cos(\\pi)) - (-\\cos(0)) = 1 - (-1) = 2\n$$\n\n角度积分的乘积是总立体角 $4\\pi$。因此，$G_{ij}$ 积分简化为关于径向坐标 $r$ 的一维积分：\n$$\nG_{ij} = 4\\pi \\int_0^\\infty h_{ij}(r) \\, r^2 \\, dr = 4\\pi \\int_0^\\infty (g_{ij}(r) - 1) \\, r^2 \\, dr\n$$\n\n在实际应用中，例如分析分子动力学模拟数据时，RDF 仅在有限的截断距离 $R_{\\max}$ 内是已知的。在此截断之外，假定相关性已经消失，即对于 $r > R_{\\max}$ 有 $g_{ij}(r) = 1$。这意味着对于 $r > R_{\\max}$ 有 $h_{ij}(r) = 0$，因此在此假设下，积分可以在 $R_{\\max}$ 处截断而不会损失精度。因此，数值估计器 $\\widehat{G}_{ij}$ 基于以下定积分：\n$$\n\\widehat{G}_{ij} = 4\\pi \\int_0^{R_{\\max}} (g_{ij}(r) - 1) \\, r^2 \\, dr\n$$\n\n### 数值积分\n\n为了数值计算这个积分，我们将径向域 $[0, R_{\\max}]$ 离散化为一个由点 $r_k = k \\Delta r$（$k = 0, 1, \\dots, N$）定义的均匀网格，其中 $N = R_{\\max} / \\Delta r$ 是一个整数。设被积函数为 $f(r) = 4\\pi (g_{ij}(r) - 1) r^2$，其在网格点 $r_k$ 上的值为 $f_k = f(r_k)$。指定了两种数值积分方法：\n\n1.  **复合梯形法则**：该方法通过对相邻网格点构成的梯形面积求和来近似积分。积分公式为：\n    $$\n    \\widehat{G}_{ij} \\approx \\frac{\\Delta r}{2} \\sum_{k=0}^{N-1} (f_k + f_{k+1}) = \\Delta r \\left( \\frac{f_0 + f_N}{2} + \\sum_{k=1}^{N-1} f_k \\right)\n    $$\n\n2.  **复合辛普森法则**：该方法通过对相邻的区间对拟合抛物线段来提供更精确的近似。它要求区间数 $N$为偶数，这意味着总网格点数 $N+1$ 必须为奇数。公式为：\n    $$\n    \\widehat{G}_{ij} \\approx \\frac{\\Delta r}{3} [f_0 + 4f_1 + 2f_2 + 4f_3 + \\dots + 2f_{N-2} + 4f_{N-1} + f_N]\n    $$\n\n### 用于单元测试的实现\n\n实现将针对几个测试用例计算 $\\widehat{G}_{ij}$。对于每个用例，我们首先构建径向网格 $r_k$ 和 RDF 值 $g_{ij}(r_k)$。在理想气体极限下，对于 $r > 0$，$g_{ij}(r) = 1$。在 $r_0 = 0$ 处，被积函数 $f(r)$ 中的 $r^2$ 项确保了 $f(0) = 4\\pi (g_{ij}(0) - 1) \\cdot 0^2 = 0$，使得 $g_{ij}(0)$ 的值无关紧要。因此，在没有噪声的情况下，被积函数 $f(r_k)$ 对所有 $k$ 都恒为 $0$，任何正确的积分实现都应返回精确的 $0.0$。\n\n对于有噪声的情况，RDF 被建模为 $g_{ij}(r_k) = 1 + \\epsilon_k$，其中 $\\epsilon_k$ 是从高斯分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的随机变量。被积函数变为 $f(r_k) = 4\\pi \\epsilon_k r_k^2$。所得积分是随机变量的加权和。虽然其期望值为 $0$，但任何单次实现都会产生一个小的非零值。单元测试通过检查 $|\\widehat{G}_{ij}| \\le \\text{tol}$ 来验证这种数值噪声是否保持在指定的容差 $\\text{tol}$ 内。提供的 `numpy` 和 `scipy` 库为这些积分法则提供了稳健的实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef compute_kb_integral(delta_r: float, r_max: float, quadrature_rule: str, sigma: float, seed: int | None) -> float:\n    \"\"\"\n    Computes the Kirkwood-Buff integral for a given set of parameters.\n\n    Args:\n        delta_r: The radial grid spacing in nm.\n        r_max: The cutoff radius for the integration in nm.\n        quadrature_rule: The name of the quadrature rule ('trapezoid' or 'Simpson').\n        sigma: The standard deviation of the Gaussian noise to add to g_ij(r).\n        seed: The random seed for noise generation.\n\n    Returns:\n        The numerically estimated Kirkwood-Buff integral in nm^3.\n    \"\"\"\n    # Ensure N is an integer, as per problem statement\n    if not np.isclose(r_max % delta_r, 0) and not np.isclose(r_max % delta_r, delta_r):\n        raise ValueError(\"r_max must be an integer multiple of delta_r\")\n    N = int(round(r_max / delta_r))\n    \n    num_points = N + 1\n\n    # For Simpson's rule, the number of intervals N must be even,\n    # which means the number of points (N+1) must be odd.\n    if quadrature_rule.lower() == 'simpson' and num_points % 2 == 0:\n        raise ValueError(\"Simpson's rule requires an odd number of grid points (even number of intervals).\")\n\n    # 1. Construct the uniform radial grid from 0 to r_max\n    r = np.linspace(0.0, r_max, num=num_points)\n\n    # 2. Construct the radial distribution function g_ij(r)\n    # In the ideal gas limit, g_ij(r) = 1.\n    g_ij = np.ones_like(r)\n\n    # 3. Add optional mean-zero Gaussian noise\n    if sigma > 0:\n        if seed is None:\n            raise ValueError(\"A seed must be provided for noise generation.\")\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=sigma, size=g_ij.shape)\n        g_ij += noise\n\n    # 4. Calculate the integrand: 4 * pi * (g_ij(r) - 1) * r^2\n    # The term (g_ij - 1) is simply the noise if present, or zero otherwise.\n    total_correlation_h = g_ij - 1.0\n    integrand = 4.0 * np.pi * total_correlation_h * r**2\n\n    # 5. Perform the numerical integration\n    g_kb = 0.0\n    if quadrature_rule.lower() == 'trapezoid':\n        g_kb = np.trapz(integrand, x=r)\n    elif quadrature_rule.lower() == 'simpson':\n        g_kb = simpson(integrand, x=r)\n    else:\n        raise ValueError(f\"Unknown quadrature rule: {quadrature_rule}\")\n\n    return g_kb\n    \n\ndef solve():\n    \"\"\"\n    Runs the unit test suite for the Kirkwood-Buff integral estimator.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, trapezoid, fine grid, no noise\n        {'delta_r': 0.01, 'r_max': 10.0, 'rule': 'trapezoid', 'sigma': 0.0, 'seed': None, 'tol': 1.0e-12},\n        # Case B: happy path, Simpson, fine grid, no noise\n        {'delta_r': 0.0025, 'r_max': 5.0, 'rule': 'Simpson', 'sigma': 0.0, 'seed': None, 'tol': 1.0e-12},\n        # Case C: noisy, moderate grid\n        {'delta_r': 0.005, 'r_max': 5.0, 'rule': 'trapezoid', 'sigma': 1.0e-7, 'seed': 12345, 'tol': 1.0e-4},\n        # Case D: boundary condition, very coarse grid, no noise\n        {'delta_r': 1.0, 'r_max': 1.0, 'rule': 'trapezoid', 'sigma': 0.0, 'seed': None, 'tol': 1.0e-12},\n        # Case E: small cutoff with noise\n        {'delta_r': 0.01, 'r_max': 0.5, 'rule': 'trapezoid', 'sigma': 1.0e-6, 'seed': 24680, 'tol': 1.0e-6},\n    ]\n\n    results = []\n    for case in test_cases:\n        g_kb_estimate = compute_kb_integral(\n            delta_r=case['delta_r'],\n            r_max=case['r_max'],\n            quadrature_rule=case['rule'],\n            sigma=case['sigma'],\n            seed=case['seed']\n        )\n        \n        # Check if the absolute value of the estimate is within the tolerance\n        test_passed = abs(g_kb_estimate) <= case['tol']\n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419765"}, {"introduction": "真实流体的结构远比理想气体复杂，其径向分布函数 $g_{ij}(r)$ 往往呈现出复杂的振荡和衰减行为。此外，分子模拟只能在有限的距离范围（截断半径 $R$）内计算 $g_{ij}(r)$。本练习旨在解决这一挑战，要求您为几种代表不同物理情景的解析 $g_{ij}(r)$ 形式计算 $G_{ij}$。[@problem_id:3419771] 此过程的关键在于引入“尾部校正”的概念，即当 $r>R$ 时，利用 $g_{ij}(r)$ 的渐近形式解析地计算积分的剩余部分。这项技能对于从有限的模拟数据中获得准确的 KBI 至关重要，它完美地结合了数值积分与解析推导。", "problem": "考虑一个三维空间中的各向同性、均匀的流体混合物。令物种 $i$ 和 $j$ 之间的对径向分布函数表示为 $g_{ij}(r)$，其定义为：在一个标记的 $i$ 型粒子周围，半径为 $r$、厚度为 $\\mathrm{d}r$ 的球壳中，$j$ 型粒子的期望数量等于物种 $j$ 的体数密度、该球壳的体积以及 $g_{ij}(r)$ 的乘积。仅从此定义和三维球壳的几何事实出发，推导用于量化 $i$ 和 $j$ 之间总相关函数的空间积分的柯克伍德-巴夫积分（Kirkwood–Buff integral）的表达式。然后，基于离散化的径向网格，设计一个数值估计器，用于从在有限区间 $[0,R]$ 上采样的给定 $g_{ij}(r)$ 计算该积分。你的估计器必须：\n- 与三维空间中的球对称性保持一致。\n- 在间距为 $\\Delta r$ 的均匀 $r$ 值网格上，使用一个适定的黎曼和（Riemann sum）近似。\n- 处理有限截断半径 $R$ 的问题，可以通过证明超出 $R$ 的尾部贡献可以忽略不计，或者通过添加一个从特定情况下 $g_{ij}(r)$ 的渐近形式推导出的、有数学依据的尾部校正来解决。\n\n所有半径单位均为纳米 (nm)。你的程序必须以浮点数形式返回柯克伍德-巴夫积分，单位为立方纳米 (nm$^3$)。\n\n实现一个程序，该程序为以下四个测试用例在指定的网格上构建 $g_{ij}(r)$，应用你的数值估计器（在要求时包括精确的解析尾部校正），并以单行形式输出结果，结果为一个用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 案例 A (理想气体参考)：对于所有 $r \\in [0,R]$，$g_{ij}(r) = 1$。网格：$R = 5.0$ nm，$N = 10000$ 个均匀区间，因此 $\\Delta r = R/N$。不需要尾部校正。\n- 案例 B (纯衰减相关)：$g_{ij}(r) = 1 + A \\exp(-\\alpha r)$，其中 $A = 0.5$ 且 $\\alpha = 3.0$ nm$^{-1}$。网格：$R = 6.0$ nm，$N = 12000$。添加此函数形式所隐含的 $r \\in (R,\\infty)$ 的精确解析尾部校正。\n- 案例 C (硬核排斥)：对于 $0 \\le r < r_{0}$，$g_{ij}(r) = 0$；对于 $r \\ge r_{0}$，$g_{ij}(r) = 1$，其中 $r_{0} = 0.3$ nm。网格：$R = 5.0$ nm，$N = 10000$。不需要尾部校正。\n- 案例 D (阻尼振荡相关)：$g_{ij}(r) = 1 + A \\exp(-\\alpha r)\\,\\dfrac{\\sin(\\beta r)}{\\beta r}$，其中 $A = 0.8$，$\\alpha = 2.0$ nm$^{-1}$，且 $\\beta = 5.0$ nm$^{-1}$。在 $r=0$ 处，使用 $\\dfrac{\\sin(\\beta r)}{\\beta r}$ 在 $r \\to 0$ 时的极限，通过连续性来定义其值。网格：$R = 8.0$ nm，$N = 16000$。添加此函数形式所隐含的 $r \\in (R,\\infty)$ 的精确解析尾部校正。\n\n数值要求：\n- 对于 $[0,R]$ 上的积分，使用均匀网格上的梯形法则。\n- 对于案例 B，使用给定函数形式的尾部积分 $\\int_{R}^{\\infty} \\left(g_{ij}(r) - 1\\right)$ 的精确解析值。对于案例 D，使用从给定的阻尼振荡形式推导出的尾部积分的精确解析值。在这两种情况下，尾部校正必须从初等微积分和复指数表示推导出来，然后精确实现。\n- 将每个最终结果以 nm$^3$ 为单位表示为浮点数。你必须输出小数点后六位数字。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC,resultD]”），其中每个结果分别对应案例 A、案例 B、案例 C 和案例 D，且每个结果都四舍五入到小数点后六位。", "solution": "该问题要求推导各向同性流体混合物的柯克伍德-巴夫积分（Kirkwood-Buff integral, KBI），记为 $G_{ij}$，并设计一个数值估计器来计算其在几个测试用例中的值。推导必须从对径向分布函数 $g_{ij}(r)$ 的定义开始。\n\n**1. 柯克伍德-巴夫积分的定义与推导**\n\n对径向分布函数 $g_{ij}(r)$ 描述了在距离物种 $i$ 的一个粒子 $r$ 处找到一个物种 $j$ 的粒子的概率，这是相对于均匀随机分布而言的。对于大的分离距离 $r \\to \\infty$，粒子变得不相关，因此 $g_{ij}(r) \\to 1$。\n\n总相关函数 $h_{ij}(r)$ 量化了与这种不相关状态的偏差，其定义为：\n$$ h_{ij}(r) = g_{ij}(r) - 1 $$\n当 $r \\to \\infty$ 时，此函数趋近于 $0$。\n\n柯克伍德-巴夫积分 $G_{ij}$ 定义为总相关函数在整个三维空间上的空间积分：\n$$ G_{ij} = \\int_{\\mathbb{R}^3} h_{ij}(\\mathbf{r}) \\, \\mathrm{d}\\mathbf{r} $$\n对于各向同性系统，相关函数仅取决于径向距离 $r = |\\mathbf{r}|$，因此我们可以写成 $h_{ij}(\\mathbf{r}) = h_{ij}(r)$。为计算该积分，我们切换到球坐标系，其中体积元为 $\\mathrm{d}\\mathbf{r} = r^2 \\sin\\theta \\, \\mathrm{d}r \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$。积分变为：\n$$ G_{ij} = \\int_0^\\infty \\int_0^\\pi \\int_0^{2\\pi} h_{ij}(r) \\, r^2 \\sin\\theta \\, \\mathrm{d}\\phi \\, \\mathrm{d}\\theta \\, \\mathrm{d}r $$\n由于 $h_{ij}(r)$ 和 $r^2$ 不依赖于角度 $\\theta$ 和 $\\phi$，因此可以分开进行角度积分：\n$$ \\int_0^{2\\pi} \\mathrm{d}\\phi = 2\\pi $$\n$$ \\int_0^\\pi \\sin\\theta \\, \\mathrm{d}\\theta = [-\\cos\\theta]_0^\\pi = -(-1) - (-1) = 2 $$\n角度积分的乘积为 $4\\pi$，即球体的总立体角。将其代回，得到以径向函数表示的柯克伍德-巴夫积分的最终表达式：\n$$ G_{ij} = 4\\pi \\int_0^\\infty r^2 h_{ij}(r) \\, \\mathrm{d}r = 4\\pi \\int_0^\\infty r^2 (g_{ij}(r) - 1) \\, \\mathrm{d}r $$\n\n**2. 数值估计策略**\n\n积分为无限域 $[0, \\infty)$。对于从有限区间 $[0, R]$ 上采样的数据进行的数值评估，我们将积分分解为两部分：\n$$ G_{ij} = 4\\pi \\left[ \\int_0^R r^2 (g_{ij}(r) - 1) \\, \\mathrm{d}r + \\int_R^\\infty r^2 (g_{ij}(r) - 1) \\, \\mathrm{d}r \\right] $$\n第一项 $(G_{ij})_\\text{num}$ 进行数值评估，而第二项 $(G_{ij})_\\text{tail}$ 是尾部校正。\n\n数值部分使用均匀网格上的梯形法则进行近似。区间 $[0, R]$ 被分成 $N$ 个宽度为 $\\Delta r = R/N$ 的子区间。网格点为 $r_k = k \\Delta r$，其中 $k = 0, 1, \\dots, N$。被积函数为 $f(r) = 4\\pi r^2 (g_{ij}(r) - 1)$。该积分近似为：\n$$ (G_{ij})_\\text{num} = \\int_0^R f(r) \\, \\mathrm{d}r \\approx \\Delta r \\left( \\frac{f(r_0) + f(r_N)}{2} + \\sum_{k=1}^{N-1} f(r_k) \\right) $$\n由于 $r_0 = 0$，且 $g_{ij}(0)$ 是有限的，因此被积函数 $f(0) = 4\\pi (0)^2 (g_{ij}(0) - 1) = 0$。\n\n尾部校正 $(G_{ij})_\\text{tail}$ 必须基于 $r > R$ 时 $g_{ij}(r)$ 的渐近形式进行解析评估。\n\n**3. 测试用例分析**\n\n**案例 A (理想气体)：**\n对所有 $r$，$g_{ij}(r) = 1$。这意味着对所有 $r$，$h_{ij}(r) = g_{ij}(r) - 1 = 0$。\n因此，该积分恒等于零：\n$$ G_{ij} = 4\\pi \\int_0^\\infty r^2 (0) \\, \\mathrm{d}r = 0 \\, \\text{nm}^3 $$\n不需要进行数值计算，但正确的实现必须得到 $0$。\n\n**案例 B (纯衰减相关)：**\n$g_{ij}(r) = 1 + A \\exp(-\\alpha r)$，其中 $A = 0.5$ 且 $\\alpha = 3.0 \\, \\text{nm}^{-1}$。\n$h_{ij}(r) = A \\exp(-\\alpha r)$。数值部分通过对 $4\\pi r^2 A \\exp(-\\alpha r)$ 从 $r=0$ 到 $r=R=6.0 \\, \\text{nm}$ 的积分使用梯形法则计算。\n尾部校正为：\n$$ (G_{ij})_\\text{tail} = 4\\pi A \\int_R^\\infty r^2 \\exp(-\\alpha r) \\, \\mathrm{d}r $$\n这个积分可以通过重复分部积分法求解，得到：\n$$ \\int_R^\\infty r^2 e^{-\\alpha r} \\mathrm{d}r = \\left[ -e^{-\\alpha r} \\left( \\frac{r^2}{\\alpha} + \\frac{2r}{\\alpha^2} + \\frac{2}{\\alpha^3} \\right) \\right]_R^\\infty = e^{-\\alpha R} \\left( \\frac{R^2}{\\alpha} + \\frac{2R}{\\alpha^2} + \\frac{2}{\\alpha^3} \\right) $$\n因此，尾部贡献为：\n$$ (G_{ij})_\\text{tail} = 4\\pi A e^{-\\alpha R} \\left( \\frac{R^2}{\\alpha} + \\frac{2R}{\\alpha^2} + \\frac{2}{\\alpha^3} \\right) $$\n\n**案例 C (硬核排斥)：**\n当 $r < r_0 = 0.3 \\, \\text{nm}$ 时，$g_{ij}(r) = 0$；当 $r \\ge r_0$ 时，$g_{ij}(r) = 1$。\n当 $r < r_0$ 时，$h_{ij}(r) = -1$；当 $r \\ge r_0$ 时，$h_{ij}(r) = 0$。\n由于数值网格的截断半径 $R = 5.0 \\, \\text{nm} > r_0$，相关函数 $h_{ij}(r)$ 在 $r > R$ 时恒等于零。因此，尾部校正为零。积分的精确值为：\n$$ G_{ij} = 4\\pi \\int_0^{r_0} r^2 (-1) \\, \\mathrm{d}r = -4\\pi \\left[ \\frac{r^3}{3} \\right]_0^{r_0} = -\\frac{4}{3}\\pi r_0^3 $$\n对于 $r_0 = 0.3 \\, \\text{nm}$，$G_{ij} = -\\frac{4}{3}\\pi (0.3)^3 = -0.036\\pi \\approx -0.113097 \\, \\text{nm}^3$。数值方法应能精确逼近此值。\n\n**案例 D (阻尼振荡相关)：**\n$g_{ij}(r) = 1 + A \\exp(-\\alpha r)\\,\\dfrac{\\sin(\\beta r)}{\\beta r}$，其中 $A = 0.8$，$\\alpha = 2.0 \\, \\text{nm}^{-1}$，$\\beta = 5.0 \\, \\text{nm}^{-1}$。\n$h_{ij}(r) = A \\exp(-\\alpha r)\\,\\dfrac{\\sin(\\beta r)}{\\beta r}$。数值部分是为被积函数 $f(r) = 4\\pi r^2 h_{ij}(r) = \\frac{4\\pi A}{\\beta} r \\sin(\\beta r) \\exp(-\\alpha r)$ 从 $r=0$ 到 $r=R=8.0 \\, \\text{nm}$ 计算的。\n在 $r=0$ 处，该值由连续性定义：$\\lim_{r\\to 0} \\frac{\\sin(\\beta r)}{\\beta r} = 1$，因此 $g_{ij}(0) = 1+A$。被积函数 $f(0)$ 为 $0$。\n尾部校正为：\n$$ (G_{ij})_\\text{tail} = \\int_R^\\infty \\frac{4\\pi A}{\\beta} r \\sin(\\beta r) \\exp(-\\alpha r) \\, \\mathrm{d}r $$\n该积分使用复指数进行计算。令 $\\sin(\\beta r) = \\text{Im}(e^{i\\beta r})$。我们需要计算 $\\text{Im} \\left[ \\int_R^\\infty r e^{-(\\alpha-i\\beta)r} \\, \\mathrm{d}r \\right]$。原函数为 $\\int r e^{-\\gamma r} \\mathrm{d}r = -e^{-\\gamma r}(\\frac{r}{\\gamma} + \\frac{1}{\\gamma^2})$。从 $R$ 到 $\\infty$ 的定积分为 $e^{-\\gamma R}(\\frac{R}{\\gamma} + \\frac{1}{\\gamma^2})$。取 $\\gamma = \\alpha - i\\beta$ 时结果的虚部，得到积分部分的以下表达式：\n$$ \\int_R^\\infty r e^{-\\alpha r} \\sin(\\beta r) \\mathrm{d}r = \\frac{e^{-\\alpha R}}{(\\alpha^2+\\beta^2)^2} \\left[ (R\\alpha(\\alpha^2+\\beta^2) + \\alpha^2-\\beta^2)\\sin(\\beta R) + (R\\beta(\\alpha^2+\\beta^2) + 2\\alpha\\beta)\\cos(\\beta R) \\right] $$\n总的尾部贡献是 $(G_{ij})_\\text{tail} = \\frac{4\\pi A}{\\beta}$ 乘以该表达式。\n最终的 $G_{ij}$ 是在 $[0, R]$ 上的数值积分与此解析尾部校正之和。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the Kirkwood-Buff integral for four test cases\n    using numerical integration and analytical tail corrections.\n    \"\"\"\n\n    test_cases = [\n        {'case': 'A', 'R': 5.0, 'N': 10000},\n        {'case': 'B', 'R': 6.0, 'N': 12000, 'A': 0.5, 'alpha': 3.0},\n        {'case': 'C', 'R': 5.0, 'N': 10000, 'r0': 0.3},\n        {'case': 'D', 'R': 8.0, 'N': 16000, 'A': 0.8, 'alpha': 2.0, 'beta': 5.0},\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        case = params['case']\n        R = params['R']\n        N = params['N']\n\n        r_grid = np.linspace(0, R, N + 1)\n        g_ij = np.zeros_like(r_grid)\n\n        tail_correction = 0.0\n\n        if case == 'A':\n            # g_ij(r) = 1, so h_ij(r) = 0 everywhere.\n            g_ij.fill(1.0)\n            \n        elif case == 'B':\n            A = params['A']\n            alpha = params['alpha']\n            \n            g_ij = 1.0 + A * np.exp(-alpha * r_grid)\n\n            # Analytical tail correction for G_ij = 4*pi*Integral[r^2*A*exp(-alpha*r), {r, R, inf}]\n            # Integral part is exp(-alpha*R) * (R^2/alpha + 2*R/alpha^2 + 2/alpha^3)\n            exp_term = np.exp(-alpha * R)\n            poly_term = (R**2 / alpha) + (2 * R / alpha**2) + (2 / alpha**3)\n            tail_correction = 4.0 * np.pi * A * exp_term * poly_term\n\n        elif case == 'C':\n            r0 = params['r0']\n            g_ij = np.where(r_grid < r0, 0.0, 1.0)\n            # No tail correction needed as h_ij(r) = 0 for r >= r0, and R > r0.\n            \n        elif case == 'D':\n            A = params['A']\n            alpha = params['alpha']\n            beta = params['beta']\n            \n            # handle r=0 by continuity, where sin(beta*r)/(beta*r) -> 1\n            g_ij[0] = 1.0 + A\n            # for r > 0\n            r_positive = r_grid[1:]\n            g_ij[1:] = 1.0 + A * np.exp(-alpha * r_positive) * np.sin(beta * r_positive) / (beta * r_positive)\n\n            # Analytical tail correction for G_ij = Integral[4*pi*r^2 * h_ij(r), {r, R, inf}]\n            # h_ij(r) = A * exp(-alpha*r) * sin(beta*r)/(beta*r)\n            # Integrand for tail is (4*pi*A/beta) * r * exp(-alpha*r) * sin(beta*r)\n            exp_R = np.exp(-alpha * R)\n            sin_R = np.sin(beta * R)\n            cos_R = np.cos(beta * R)\n            alpha2_beta2 = alpha**2 + beta**2\n            \n            term1_sin = (R * alpha * alpha2_beta2 + alpha**2 - beta**2) * sin_R\n            term2_cos = (R * beta * alpha2_beta2 + 2 * alpha * beta) * cos_R\n            \n            integral_part = exp_R * (term1_sin + term2_cos) / (alpha2_beta2**2)\n            \n            tail_correction = (4.0 * np.pi * A / beta) * integral_part\n\n        # Integrand for the numerical part\n        h_ij = g_ij - 1.0\n        integrand = 4.0 * np.pi * r_grid**2 * h_ij\n        \n        # Numerical integration using the trapezoidal rule\n        numerical_integral = np.trapz(integrand, r_grid)\n\n        total_g_ij = numerical_integral + tail_correction\n        results.append(f\"{total_g_ij:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3419771"}, {"introduction": "到目前为止，我们的方法都集中于基于 $g_{ij}(r)$ 的“实空间积分”路径。然而，统计力学为我们提供了另一条同样强大的途径，它将热力学性质与微观涨落直接联系起来。本练习将探索一种计算 KBI 的替代方法，该方法完全绕过了对 $g_{ij}(r)$ 的计算。[@problem_id:3419775] 柯克伍德-巴夫理论的核心关系之一，便是将 $G_{ij}$ 积分与开放子系统中的粒子数协方差 $\\langle \\Delta N_i \\Delta N_j \\rangle$ 联系起来。通过分析不同尺寸子体积内的粒子数涨落数据，并利用有限尺寸标度律外推到热力学极限，我们可以精确地求解 $G_{ij}$。这种方法不仅加深了我们对涨落理论的理解，也展示了从不同角度解决同一问题的科学思想。", "problem": "给定在一个大型周期性盒子中模拟的均匀、各向同性溶液的子体积数涨落数据。目标是直接从数涨落估算Kirkwood–Buff积分，该积分量化了对相关函数与1的偏差的积分，而无需计算对相关函数。您的任务是从基本的统计力学定义和热力学关系出发，推导出一个算法，该算法可根据嵌入子体积中测得的粒子数协方差来估算Kirkwood–Buff积分矩阵。\n\n假设以下基本前提：\n- 在体积为 $V$ 的空间子体积中，物种 $i$ 的微观粒子数为 $N_i$，其数涨落为 $\\Delta N_i = N_i - \\langle N_i \\rangle$，协方差为 $\\langle \\Delta N_i \\Delta N_j \\rangle$。\n- 对于均匀流体，对相关函数 $g_{ij}(r)$ 通过 $h_{ij}(r) = g_{ij}(r) - 1$ 与总相关函数 $h_{ij}(r)$ 相关联。\n- Kirkwood–Buff积分 $G_{ij}$ 在热力学极限下定义为 $G_{ij} = \\int_{\\mathbb{R}^3} h_{ij}(r) \\, d\\mathbf{r}$，条件是确保绝对可积性。\n- 对于一个特征长度为 $L$ 的足够大的子体积（对于立方体而言，$V = L^3$），对体积平均的两点积分的主要有限尺寸修正是按表面积与体积之比缩放的，即 $\\mathcal{O}(L^{-1})$。\n\n基于这些前提，推导出一个可计算的估计器，该估计器使用在更大模拟中嵌入的不同线性尺寸 $L$ 的立方子体积中测得的 $\\langle \\Delta N_i \\Delta N_j \\rangle$，以及已知的体相数密度 $\\rho_i$，来推断Kirkwood–Buff积分。该估计器必须：\n- 仅使用给定的数涨落矩阵和子体积尺寸。\n- 通过将单位体积协方差建模为 $L^{-1}$ 的仿射函数并外推至 $L \\to \\infty$，来考虑主要的有限尺寸效应。\n- 然后，利用单位体积协方差、密度和Kirkwood–Buff积分之间的热力学极限关系来推断 $G_{ij}$。\n\n物理单位：\n- 长度 $L$ 的单位是 $\\mathrm{nm}$，因此体积 $V$ 的单位是 $\\mathrm{nm}^3$，密度 $\\rho_i$ 的单位是 $\\mathrm{nm}^{-3}$，协方差 $\\langle \\Delta N_i \\Delta N_j \\rangle$ 是无量纲的计数。Kirkwood–Buff积分 $G_{ij}$ 必须以 $\\mathrm{nm}^3$ 为单位报告。\n\n不涉及角度单位。所有输出必须是数值，并采用指定单位。\n\n程序输入由本问题固定；您的程序必须使用代码中嵌入的给定测试套件。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个数字四舍五入到六位小数。该列表必须是按给定顺序将每个测试的行主序扁平化 $G_{ij}$ 矩阵连接而成的。\n\n测试套件：\n- 测试用例1（二元溶液，一般情况）：\n  - 物种数 $m = 2$。\n  - 密度 $\\boldsymbol{\\rho} = [0.8, 0.6] \\, \\mathrm{nm}^{-3}$。\n  - 子体积线性尺寸 $L \\in \\{5, 6, 8\\} \\, \\mathrm{nm}$，其中 $V = L^3$。\n  - 每个 $L$ 对应的测量协方差矩阵 $\\langle \\Delta \\mathbf{N} \\Delta \\mathbf{N}^\\top \\rangle$：\n    - 对于 $L = 5 \\mathrm{nm}$，矩阵为 [[147.5, -8.5], [-8.5, 89.0]]。\n    - 对于 $L = 6 \\mathrm{nm}$，矩阵为 [[252.72, -13.968], [-13.968, 152.352]]。\n    - 对于 $L = 8 \\mathrm{nm}$，矩阵为 [[592.64, -30.976], [-30.976, 356.864]]。\n- 测试用例2（单组分，近理想边界情况）：\n  - 物种数 $m = 1$。\n  - 密度 $\\boldsymbol{\\rho} = [1.0] \\, \\mathrm{nm}^{-3}$。\n  - 子体积线性尺寸 $L \\in \\{4, 7\\} \\, \\mathrm{nm}$，其中 $V = L^3$。\n  - 测量的协方差矩阵：\n    - 对于 $L = 4 \\mathrm{nm}$，矩阵为 [[68.0]]。\n    - 对于 $L = 7 \\mathrm{nm}$，矩阵为 [[355.25]]。\n- 测试用例3（二元溶液，其中交叉Kirkwood–Buff积分为零作为边缘特征）：\n  - 物种数 $m = 2$。\n  - 密度 $\\boldsymbol{\\rho} = [0.5, 1.2] \\, \\mathrm{nm}^{-3}$。\n  - 子体积线性尺寸 $L \\in \\{6, 9, 12\\} \\, \\mathrm{nm}$。\n  - 测量的协方差矩阵：\n    - 对于 $L = 6 \\mathrm{nm}$，矩阵为 [[118.8, 1.8], [1.8, 387.216]]。\n    - 对于 $L = 9 \\mathrm{nm}$，矩阵为 [[394.875, 4.05], [4.05, 1302.804]]。\n    - 对于 $L = 12 \\mathrm{nm}$，矩阵为 [[928.8, 7.2], [7.2, 3083.328]]。\n\n可量化的答案要求：\n- 对于每个测试用例，输出以 $\\mathrm{nm}^3$ 为单位的估计 $G_{ij}$ 的行主序扁平化列表，每个值均为浮点数，四舍五入到六位小数。\n- 将三个测试用例的结果通过连接聚合成一个扁平列表，打印在单行上，作为用方括号括起来的逗号分隔列表，例如 $[\\,\\dots\\,]$。\n\n您的程序必须是一个完整的、可运行的程序，无需任何外部输入即可执行这些计算。", "solution": "从子体积中的粒子数涨落估算Kirkwood–Buff积分（记作 $G_{ij}$）是溶液统计力学中的一个经典课题。解决方案需要建立体积为 $V$ 的子体积中粒子数协方差 $\\langle \\Delta N_i \\Delta N_j \\rangle$ 与在热力学极限下定义的积分 $G_{ij}$ 之间的定量联系。\n\n我们从巨正则系综中数涨落的基本表达式开始，该表达式适用于嵌入在更大系统中的开放子体积 $V$。物种 $i$ 的粒子数 $N_i$ 与物种 $j$ 的粒子数 $N_j$ 之间的协方差由下式给出：\n$$\n\\langle \\Delta N_i \\Delta N_j \\rangle = \\langle (N_i - \\langle N_i \\rangle)(N_j - \\langle N_j \\rangle) \\rangle = \\delta_{ij} \\langle N_i \\rangle + \\frac{\\langle N_i \\rangle \\langle N_j \\rangle}{V^2} \\int_V \\int_V \\left( g_{ij}(\\mathbf{r}_1, \\mathbf{r}_2) - 1 \\right) d\\mathbf{r}_1 d\\mathbf{r}_2\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ函数，$\\langle N_i \\rangle$ 是子体积 $V$ 中物种 $i$ 的平均粒子数，$g_{ij}$ 是对相关函数。对于均匀且各向同性的流体，$g_{ij}(\\mathbf{r}_1, \\mathbf{r}_2)$ 仅取决于距离 $r = |\\mathbf{r}_1 - \\mathbf{r}_2|$，我们可以写作 $g_{ij}(r)$。总相关函数定义为 $h_{ij}(r) = g_{ij}(r) - 1$。平均粒子数通过 $\\langle N_i \\rangle = \\rho_i V$ 与体相数密度 $\\rho_i$ 相关。将这些代入方程可得：\n$$\n\\langle \\Delta N_i \\Delta N_j \\rangle = \\delta_{ij} \\rho_i V + \\rho_i \\rho_j \\int_V \\int_V h_{ij}(|\\mathbf{r}_1 - \\mathbf{r}_2|) d\\mathbf{r}_1 d\\mathbf{r}_2\n$$\n除以体积 $V$ 得到单位体积协方差：\n$$\n\\frac{\\langle \\Delta N_i \\Delta N_j \\rangle}{V} = \\delta_{ij} \\rho_i + \\rho_i \\rho_j \\frac{1}{V} \\int_V \\int_V h_{ij}(|\\mathbf{r}_1 - \\mathbf{r}_2|) d\\mathbf{r}_1 d\\mathbf{r}_2\n$$\n在热力学极限下，子体积 $V$ 变得无限大，双重积分项得以简化。积分 $\\int_V \\int_V h_{ij}(|\\mathbf{r}_1 - \\mathbf{r}_2|) d\\mathbf{r}_1 d\\mathbf{r}_2$ 变为 $V \\int_{\\mathbb{R}^3} h_{ij}(r) d\\mathbf{r}$，其中第二个积分是Kirkwood–Buff积分，$G_{ij} = \\int_{0}^{\\infty} h_{ij}(r) 4\\pi r^2 dr$。因此，在 $V \\to \\infty$ 的极限下：\n$$\n\\lim_{V \\to \\infty} \\frac{\\langle \\Delta N_i \\Delta N_j \\rangle}{V} = \\delta_{ij} \\rho_i + \\rho_i \\rho_j G_{ij}\n$$\n让我们将在热力学极限下的单位体积协方差矩阵定义为 $A_{ij}(\\infty) = \\lim_{V \\to \\infty} \\frac{\\langle \\Delta N_i \\Delta N_j \\rangle}{V}$。方程变为：\n$$\nA_{ij}(\\infty) = \\delta_{ij} \\rho_i + \\rho_i \\rho_j G_{ij}\n$$\n该方程提供了外推的单位体积涨落与Kirkwood–Buff积分之间的直接联系。\n\n对于有限子体积，如边长为 $L$、体积为 $V = L^3$ 的立方体，测得的单位体积协方差 $A_{ij}(L) = \\frac{\\langle \\Delta N_i \\Delta N_j \\rangle}{L^3}$ 会偏离其热力学极限值。问题指出，主要的有限尺寸修正与表面积与体积之比成正比，即与 $L^{-1}$ 成正比。我们可以用 $L^{-1}$ 的仿射函数来对此行为建模：\n$$\nA_{ij}(L) = A_{ij}(\\infty) + \\frac{B_{ij}}{L}\n$$\n其中 $B_{ij}$ 是一个捕捉表面效应的常数。该方程为从不同子体积尺寸的测量值确定 $A_{ij}(\\infty)$ 提供了一条清晰的算法路径。通过计算一组不同尺寸 $L_k$ 对应的 $A_{ij}(L_k)$，我们得到一组点 $(x_k, y_k) = (1/L_k, A_{ij}(L_k))$。对这些点进行线性回归可得到斜率 $B_{ij}$ 以及至关重要的y轴截距 $A_{ij}(\\infty)$。\n\n总体算法如下：\n1.  对于 $m$ 组分系统中的每个物种对 $(i, j)$，收集每个对应的边长为 $L_k$ 的立方子体积的测量数协方差 $[\\langle \\Delta N_i \\Delta N_j \\rangle]_k$。\n2.  对于每个尺寸 $L_k$，计算体积 $V_k = L_k^3$ 和单位体积协方差 $A_{ij}(L_k) = [\\langle \\Delta N_i \\Delta N_j \\rangle]_k / V_k$。\n3.  对数据点 $(1/L_k, A_{ij}(L_k))$ 进行线性最小二乘拟合，模型为 $y = mx+c$。拟合得到的截距 $c$ 即为 $A_{ij}(\\infty)$ 的估计值。\n4.  对所有对 $(i, j)$ 重复此过程，以构建完整的矩阵 $[A_{ij}(\\infty)]$。\n5.  最后，重新整理热力学极限方程，以求解每个Kirkwood–Buff积分 $G_{ij}$：\n    $$\n    G_{ij} = \\frac{A_{ij}(\\infty) - \\delta_{ij} \\rho_i}{\\rho_i \\rho_j}\n    $$\n此过程直接使用所提供的涨落数据和密度来计算所需的 $G_{ij}$ 矩阵，同时通过外推法系统地考虑了主要的有限尺寸效应。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Kirkwood-Buff integrals from number fluctuation data in subvolumes\n    by extrapolating to the thermodynamic limit.\n    \"\"\"\n    test_cases = [\n        {\n            \"m\": 2,\n            \"rho\": np.array([0.8, 0.6]),\n            \"L\": np.array([5.0, 6.0, 8.0]),\n            \"covs\": [\n                np.array([[147.5, -8.5], [-8.5, 89.0]]),\n                np.array([[252.72, -13.968], [-13.968, 152.352]]),\n                np.array([[592.64, -30.976], [-30.976, 356.864]]),\n            ],\n        },\n        {\n            \"m\": 1,\n            \"rho\": np.array([1.0]),\n            \"L\": np.array([4.0, 7.0]),\n            \"covs\": [\n                np.array([[68.0]]),\n                np.array([[355.25]]),\n            ],\n        },\n        {\n            \"m\": 2,\n            \"rho\": np.array([0.5, 1.2]),\n            \"L\": np.array([6.0, 9.0, 12.0]),\n            \"covs\": [\n                np.array([[118.8, 1.8], [1.8, 387.216]]),\n                np.array([[394.875, 4.05], [4.05, 1302.804]]),\n                np.array([[928.8, 7.2], [7.2, 3083.328]]),\n            ],\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        m = case[\"m\"]\n        rho = case[\"rho\"]\n        L = case[\"L\"]\n        covs = case[\"covs\"]\n\n        # The independent variable for the linear fit is 1/L.\n        x_vals = 1.0 / L\n        \n        # Calculate the extrapolated per-volume covariance matrix A_inf.\n        A_inf_matrix = np.zeros((m, m))\n        \n        for i in range(m):\n            for j in range(m):\n                # Calculate the per-volume covariance for each subvolume size.\n                volumes = L**3\n                y_vals = np.array([covs[k][i, j] / volumes[k] for k in range(len(L))])\n                \n                # Perform a linear fit y = mx + c, where x = 1/L.\n                # The intercept c is the extrapolated value A_ij(infinity).\n                # np.polyfit returns [slope, intercept] for degree 1.\n                fit_params = np.polyfit(x_vals, y_vals, 1)\n                A_inf_matrix[i, j] = fit_params[1]\n\n        # Calculate the Kirkwood-Buff integral matrix G from A_inf.\n        G_matrix = np.zeros((m, m))\n        \n        for i in range(m):\n            for j in range(m):\n                # The Kronecker delta is 1 if i==j, else 0.\n                delta_ij = 1.0 if i == j else 0.0\n                \n                # G_ij = (A_ij(inf) - delta_ij * rho_i) / (rho_i * rho_j)\n                numerator = A_inf_matrix[i, j] - delta_ij * rho[i]\n                denominator = rho[i] * rho[j]\n                \n                G_matrix[i, j] = numerator / denominator\n\n        # Flatten the G matrix in row-major order and add to results.\n        all_results.extend(G_matrix.flatten().tolist())\n\n    # Format the final output as a comma-separated list of floats\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = f\"[{','.join(f'{val:.6f}' for val in all_results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3419775"}]}