{"hands_on_practices": [{"introduction": "我们的第一个练习从最简单的键合相互作用——谐振子键势——入手，旨在建立抽象的势能函数与驱动原子运动的具体力之间的桥梁。通过从势能函数的梯度推导并计算原子上的力 [@problem_id:3399229]，你将能够巩固对保守力概念的理解，并直观地验证牛顿第三定律在分子尺度上的体现。", "problem": "考虑在分子动力学（MD）模拟中由一个键连接的两个原子。这两个原子在三维空间中的位置向量分别为 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$，其中 $\\mathbf{r}_1 = (0.000,\\,0.000,\\,0.000)\\,\\mathrm{nm}$，$\\mathbf{r}_2 = (0.140,\\,0.060,\\,-0.020)\\,\\mathrm{nm}$。设键长为 $r = |\\mathbf{r}_2 - \\mathbf{r}_1|$，平衡键长为 $r_0 = 0.154\\,\\mathrm{nm}$。在关于 $r_0$ 的谐波近似中，势能最小值点的曲率（键力常数）为 $k_b$，键合相互作用势能对键伸长量 $r - r_0$ 展开至二阶，其曲率 $k_b = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$。\n\n从第一性原理出发，特别是牛顿第二定律和保守力是势能负梯度的定义，推导出作用于每个原子的力向量，该向量是 $k_b$、$r_0$ 和原子位置的函数。然后，使用所提供的数值，计算在给定键伸长情况下，作用于每个原子的力的大小和方向。通过证明作用于两个原子的力大小相等、方向相反，明确地展示牛顿第三定律。\n\n以有序六元组 $(F_{1x},\\,F_{1y},\\,F_{1z},\\,F_{2x},\\,F_{2y},\\,F_{2z})$ 的形式提供您的最终数值答案，该元组对应于原子1和2上的力分量，单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$。将每个分量四舍五入到四位有效数字。答案必须是单个解析或数值表达式。", "solution": "该问题被评估为具有科学依据、提法明确且完整。所有必要的参数都已提供，所要求的推导和计算均基于经典力学的基本原理。所给数值对于共价键是物理上现实的。因此，该问题是有效的，下面提供了解决方案。\n\n作用在原子 $i$ 上的力 $\\mathbf{F}_i$ 是从势能 $U$ 通过保守力的定义推导出来的，该定义指出，力是势能相对于原子位置坐标 $\\mathbf{r}_i$ 的负梯度：\n$$\n\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U\n$$\n键合相互作用势由谐波近似给出，在平衡键长 $r_0$ 附近展开到二阶：\n$$\nU(r) = \\frac{1}{2} k_b (r - r_0)^2\n$$\n其中 $k_b$ 是键力常数，$r$ 是瞬时键长。键长 $r$ 是原子间距离向量 $\\mathbf{r}_{12} = \\mathbf{r}_2 - \\mathbf{r}_1$ 的大小：\n$$\nr = |\\mathbf{r}_{12}| = |\\mathbf{r}_2 - \\mathbf{r}_1| = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2}\n$$\n势能 $U$ 是标量距离 $r$ 的函数，而 $r$ 又是向量坐标 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 的函数。为了求出作用在原子1上的力，我们应用链式法则进行微分：\n$$\n\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U(r(\\mathbf{r}_1, \\mathbf{r}_2)) = -\\frac{dU}{dr} \\nabla_{\\mathbf{r}_1} r\n$$\n首先，我们计算势能对键长 $r$ 的导数：\n$$\n\\frac{dU}{dr} = \\frac{d}{dr} \\left[ \\frac{1}{2} k_b (r - r_0)^2 \\right] = k_b (r - r_0)\n$$\n接下来，我们计算键长 $r$ 相对于原子1的位置 $\\mathbf{r}_1 = (x_1, y_1, z_1)$ 的梯度：\n$$\n\\nabla_{\\mathbf{r}_1} r = \\left( \\frac{\\partial r}{\\partial x_1}, \\frac{\\partial r}{\\partial y_1}, \\frac{\\partial r}{\\partial z_1} \\right)\n$$\n偏导数是：\n$$\n\\frac{\\partial r}{\\partial x_1} = \\frac{\\partial}{\\partial x_1} \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2} = \\frac{1}{2r} \\cdot 2(x_2-x_1)(-1) = -\\frac{x_2-x_1}{r}\n$$\n同理，$\\frac{\\partial r}{\\partial y_1} = -\\frac{y_2-y_1}{r}$ 且 $\\frac{\\partial r}{\\partial z_1} = -\\frac{z_2-z_1}{r}$。组合这些分量得到梯度向量：\n$$\n\\nabla_{\\mathbf{r}_1} r = -\\frac{\\mathbf{r}_2 - \\mathbf{r}_1}{r} = -\\frac{\\mathbf{r}_{12}}{r} = -\\hat{\\mathbf{r}}_{12}\n$$\n其中 $\\hat{\\mathbf{r}}_{12}$ 是从原子1指向原子2的单位向量。\n\n将这些结果代回到 $\\mathbf{F}_1$ 的表达式中：\n$$\n\\mathbf{F}_1 = - \\left( k_b(r-r_0) \\right) \\left( -\\frac{\\mathbf{r}_{12}}{r} \\right) = k_b(r-r_0) \\frac{\\mathbf{r}_{12}}{r} = k_b(r-r_0)\\hat{\\mathbf{r}}_{12}\n$$\n同理，对于作用在原子2上的力 $\\mathbf{F}_2$：\n$$\n\\mathbf{F}_2 = -\\nabla_{\\mathbf{r}_2} U(r(\\mathbf{r}_1, \\mathbf{r}_2)) = -\\frac{dU}{dr} \\nabla_{\\mathbf{r}_2} r\n$$\nr 相对于 $\\mathbf{r}_2$ 的梯度是：\n$$\n\\frac{\\partial r}{\\partial x_2} = \\frac{1}{2r} \\cdot 2(x_2-x_1)(1) = \\frac{x_2-x_1}{r}\n$$\n这导致：\n$$\n\\nabla_{\\mathbf{r}_2} r = \\frac{\\mathbf{r}_2 - \\mathbf{r}_1}{r} = \\frac{\\mathbf{r}_{12}}{r} = \\hat{\\mathbf{r}}_{12}\n$$\n代入 $\\mathbf{F}_2$ 的表达式中：\n$$\n\\mathbf{F}_2 = - \\left( k_b(r-r_0) \\right) \\left( \\frac{\\mathbf{r}_{12}}{r} \\right) = -k_b(r-r_0)\\hat{\\mathbf{r}}_{12}\n$$\n比较 $\\mathbf{F}_1$ 和 $\\mathbf{F}_2$ 的表达式，我们看到 $\\mathbf{F}_1 = -\\mathbf{F}_2$。这明确地证明了牛顿第三定律：作用于两个原子上的力大小相等，方向相反。\n\n现在，我们使用所提供的值进行数值计算：\n$\\mathbf{r}_1 = (0.000, 0.000, 0.000)\\,\\mathrm{nm}$, $\\mathbf{r}_2 = (0.140, 0.060, -0.020)\\,\\mathrm{nm}$, $r_0 = 0.154\\,\\mathrm{nm}$，以及 $k_b = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$。\n\n首先，我们计算键向量 $\\mathbf{r}_{12}$：\n$$\n\\mathbf{r}_{12} = \\mathbf{r}_2 - \\mathbf{r}_1 = (0.140 - 0.000, 0.060 - 0.000, -0.020 - 0.000)\\,\\mathrm{nm} = (0.140, 0.060, -0.020)\\,\\mathrm{nm}\n$$\n接下来，我们计算当前键长 $r$：\n$$\nr = |\\mathbf{r}_{12}| = \\sqrt{(0.140)^2 + (0.060)^2 + (-0.020)^2}\\,\\mathrm{nm} = \\sqrt{0.0196 + 0.0036 + 0.0004}\\,\\mathrm{nm}\n$$\n$$\nr = \\sqrt{0.0236}\\,\\mathrm{nm} \\approx 0.1536229\\,\\mathrm{nm}\n$$\n由于 $r  r_0$，键被压缩。这意味着存在一个将原子推开的排斥力。\n\n我们现在计算标量力大小项 $k_b(r-r_0)$：\n$$\nk_b(r - r_0) = 1200\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2} \\times (0.1536229\\,\\mathrm{nm} - 0.154\\,\\mathrm{nm})\n$$\n$$\nk_b(r - r_0) = 1200 \\times (-0.0003771)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1} \\approx -0.45252\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}\n$$\n现在我们计算力向量。单位向量 $\\hat{\\mathbf{r}}_{12}$ 是：\n$$\n\\hat{\\mathbf{r}}_{12} = \\frac{\\mathbf{r}_{12}}{r} = \\frac{(0.140, 0.060, -0.020)}{0.1536229}\n$$\n作用在原子1上的力是：\n$$\n\\mathbf{F}_1 = k_b(r-r_0)\\hat{\\mathbf{r}}_{12} \\approx -0.45252 \\times \\frac{(0.140, 0.060, -0.020)}{0.1536229} \\approx (-0.41237, -0.17673, 0.05891)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}\n$$\n这个力的方向与 $\\mathbf{r}_{12}$ 相反，将原子1推离原子2。\n\n作用在原子2上的力是：\n$$\n\\mathbf{F}_2 = -\\mathbf{F}_1 \\approx (0.41237, 0.17673, -0.05891)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}\n$$\n这个力的方向与 $\\mathbf{r}_{12}$ 相同，将原子2推离原子1。\n\n作用在每个原子上的力的大小是：\n$$\n|\\mathbf{F}_1| = |\\mathbf{F}_2| = |k_b(r-r_0)| \\approx |-0.45252|\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1} \\approx 0.4525\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}.\n$$\n$\\mathbf{F}_1$ 的方向沿着 $-\\hat{\\mathbf{r}}_{12}$，$\\mathbf{F}_2$ 的方向沿着 $\\hat{\\mathbf{r}}_{12}$。\n\n按照要求将力分量四舍五入到四位有效数字：\n$F_{1x} = -0.4124\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{1y} = -0.1767\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{1z} = 0.05891\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{2x} = 0.4124\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{2y} = 0.1767\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n$F_{2z} = -0.05891\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$\n\n最终答案是有序六元组 $(F_{1x}, F_{1y}, F_{1z}, F_{2x}, F_{2y}, F_{2z})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-0.4124  -0.1767  0.05891  0.4124  0.1767  -0.05891\n\\end{pmatrix}\n}\n$$", "id": "3399229"}, {"introduction": "在掌握了双原子键合力的计算之后，我们接下来将挑战更复杂的三体相互作用——键角弯曲势。这个练习 [@problem_id:3399277] 不仅要求你推导并实现键角力，更关键的是，它引导你编写一个一致性检查程序，以验证你的计算是否严格遵守线动量和角动量守恒。这是一个在开发科学计算软件时至关重要的调试和验证技巧。", "problem": "您需要实现一个独立的程序，用于计算分子动力学 (MD) 中单个角键合相互作用下三个原子所受的力，并验证两个守恒性质：线性动量守恒（力之和等于零）和角动量守恒（关于任意原点的力矩之和等于零）。该相互作用由两个键 $(i,j)$ 和 $(k,j)$ 在原子 $j$ 处形成的夹角定义。目标是从第一性原理出发推导力的表达式，然后以高精度数值检验守恒定律。\n\n使用的基本原理：\n- 牛顿第二定律和保守力的定义：原子 $n$ 上的力为 $\\mathbf{F}_n = -\\nabla_{\\mathbf{r}_n} U$，其中 $U$ 是势能，$\\mathbf{r}_n$ 是原子 $n$ 的位置矢量。\n- 单个角相互作用的角势仅是角度 $\\theta$ 的函数，其势能 $U(\\theta)$ 由谐波形式 $U(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2$ 给出，其中 $k_\\theta$ 是角刚度，$\\theta_0$ 是平衡角。\n- 顶点 $j$ 处的角度定义：设 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$，则角度 $\\theta$ 满足 $\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|}$。\n- 力的计算使用链式法则，从 $U(\\theta)$ 到位置导数，除了上述指定的基本原理外，不假定任何快捷表达式或表格化公式。\n\n角度单位：所有角度必须使用弧度。\n\n数值验证任务：\n- 根据 $U(\\theta)$ 和位置 $\\mathbf{r}_i$、$\\mathbf{r}_j$、$\\mathbf{r}_k$，使用梯度关系 $\\mathbf{F}_n = -\\nabla_{\\mathbf{r}_n} U(\\theta)$ 计算 $\\mathbf{F}_i$、$\\mathbf{F}_j$ 和 $\\mathbf{F}_k$。\n- 验证线性动量守恒：检查 $\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k$ 是否在指定的数值容差内等于 $\\mathbf{0}$。\n- 验证角动量守恒：对于每个指定的原点 $\\mathbf{o}$，计算净力矩 $\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o}) = (\\mathbf{r}_i - \\mathbf{o}) \\times \\mathbf{F}_i + (\\mathbf{r}_j - \\mathbf{o}) \\times \\mathbf{F}_j + (\\mathbf{r}_k - \\mathbf{o}) \\times \\mathbf{F}_k$ 并检查其是否在相同容差内等于 $\\mathbf{0}$。\n\n容差要求：\n- 对净力和每个净力矩矢量的范数使用 $\\varepsilon = 10^{-10}$ 的严格容差。即，如果欧几里得范数小于或等于 $\\varepsilon$，则认为守恒成立。\n\n测试套件：\n实现您的程序以评估以下五个测试用例。在每个案例中，角度以弧度为单位，位置采用笛卡尔坐标（在此任务中无单位）。参数 $k_\\theta$ 的单位是能量/弧度平方，但您无需假定任何特定的能量单位；验证是无量纲的。\n\n- 案例1（一般三维构型）：\n  - $\\mathbf{r}_i = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [1.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [1.0, 1.0, 0.0]$\n  - $k_\\theta = 100.0$\n  - $\\theta_0 = 1.2$\n- 案例2（原点处的直角）：\n  - $\\mathbf{r}_i = [1.0, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [0.0, 1.0, 0.0]$\n  - $k_\\theta = 50.0$\n  - $\\theta_0 = \\pi/2$\n- 案例3（近共线构型）：\n  - $\\mathbf{r}_i = [-1.0, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [1.0, 10^{-6}, 0.0]$\n  - $k_\\theta = 0.001$\n  - $\\theta_0 = \\pi$\n- 案例4（随机三维构型）：\n  - $\\mathbf{r}_i = [0.2, -0.7, 1.1]$\n  - $\\mathbf{r}_j = [-0.3, 0.4, -0.5]$\n  - $\\mathbf{r}_k = [0.9, 0.3, 0.2]$\n  - $k_\\theta = 10.0$\n  - $\\theta_0 = 1.0$\n- 案例5（一侧键长较小）：\n  - $\\mathbf{r}_i = [10^{-4}, 0.0, 0.0]$\n  - $\\mathbf{r}_j = [0.0, 0.0, 0.0]$\n  - $\\mathbf{r}_k = [0.0, 1.0, 0.0]$\n  - $k_\\theta = 200.0$\n  - $\\theta_0 = \\pi/3$\n\n对于每个案例，检查关于三个原点的力矩守恒：\n- $\\mathbf{o}_1 = [0.0, 0.0, 0.0]$\n- $\\mathbf{o}_2 = \\mathbf{r}_j$ (顶点原子位置)\n- $\\mathbf{o}_3 = [0.5, -1.0, 2.0]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且是一个布尔值，指示该案例的两个守恒检查是否都通过（净力范数 $\\le \\varepsilon$ 且每个净力矩范数 $\\le \\varepsilon$）。例如，输出应类似于 $[{\\text{True}},{\\text{False}},\\dots]$。", "solution": "该问题是有效的，因为它在经典力学中有科学依据，定义和数据完整，表述适定，并且其公式是客观的。它提出了计算物理学中一个标准的、非平凡的问题，可以使用所提供的原理来解决。\n\n解决方案源于一个基本原理：保守力是其势能的负梯度。对于位置矢量为 $\\mathbf{r}_n$ 的原子 $n$ 所受的力，表示为 $\\mathbf{F}_n = -\\nabla_{\\mathbf{r}_n} U$。角相互作用的势能 $U$ 仅是矢量 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ 之间夹角 $\\theta$ 的函数。指定的谐波形式为 $U(\\theta) = \\frac{1}{2} k_\\theta (\\theta - \\theta_0)^2$。\n\n为了计算力，我们应用链式法则：\n$$\n\\mathbf{F}_n = -\\frac{dU}{d\\theta} \\nabla_{\\mathbf{r}_n} \\theta\n$$\n第一项很简单：\n$$\n\\frac{dU}{d\\theta} = k_\\theta (\\theta - \\theta_0)\n$$\n为了求角度的梯度 $\\nabla_{\\mathbf{r}_n} \\theta$，更方便的是先计算 $\\cos\\theta$ 的梯度。对关系式 $\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|}$ 关于 $\\theta$ 求导得到 $-\\sin\\theta$。再次使用链式法则，$\\nabla_{\\mathbf{r}_n} (\\cos\\theta) = -\\sin\\theta \\, (\\nabla_{\\mathbf{r}_n} \\theta)$，这给出：\n$$\n\\nabla_{\\mathbf{r}_n} \\theta = -\\frac{1}{\\sin\\theta} \\nabla_{\\mathbf{r}_n} (\\cos\\theta)\n$$\n该表达式在共线构型（$\\theta=0$ 或 $\\theta=\\pi$）时未定义，但提供的测试用例避免了这些精确的奇点。\n\n结合这些结果，得到力的表达式：\n$$\n\\mathbf{F}_n = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta} \\nabla_{\\mathbf{r}_n} (\\cos\\theta)\n$$\n\n下一步是推导 $\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab}$ 的梯度，其中 $a = \\|\\mathbf{a}\\|$ 且 $b = \\|\\mathbf{b}\\|$。设 $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ 和 $\\hat{\\mathbf{b}} = \\mathbf{b}/b$ 为单位矢量。\n\n对于原子 $i$，$\\mathbf{r}_i$ 仅出现在 $\\mathbf{a}$ 中。使用标准的矢量微积分恒等式，梯度为：\n$$\n\\nabla_{\\mathbf{r}_i} (\\cos\\theta) = \\nabla_{\\mathbf{r}_i} (\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}) = \\frac{1}{ab} \\left( \\mathbf{b} - \\frac{(\\mathbf{a} \\cdot \\mathbf{b})}{a^2} \\mathbf{a} \\right) = \\frac{\\hat{\\mathbf{b}} - \\cos\\theta \\, \\hat{\\mathbf{a}}}{a}\n$$\n因此，原子 $i$ 上的力是：\n$$\n\\mathbf{F}_i = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta \\, \\hat{\\mathbf{a}}}{a} \\right)\n$$\n根据对称性，将 $\\mathbf{a}$ 与 $\\mathbf{b}$ 以及 $i$ 与 $k$ 交换，原子 $k$ 上的力是：\n$$\n\\mathbf{F}_k = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{a}} - \\cos\\theta \\, \\hat{\\mathbf{b}}}{b} \\right)\n$$\n中心原子 $j$ 上的力可以通过注意到势能 $U$ 仅依赖于原子的相对位置来找到。这种平移不变性决定了所有力的总和必须为零（线性动量守恒）。因此：\n$$\n\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\n$\\|\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k\\| \\le \\varepsilon$（其中 $\\varepsilon=10^{-10}$）的数值验证可作为对计算实现和浮点精度的检查。\n\n对于角动量守恒，我们必须验证关于任意原点 $\\mathbf{o}$ 的净力矩 $\\boldsymbol{\\tau}_{\\text{net}}$ 为零。净力矩由下式给出：\n$$\n\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o}) = \\sum_{n=i,j,k} (\\mathbf{r}_n - \\mathbf{o}) \\times \\mathbf{F}_n\n$$\n由于 $\\sum \\mathbf{F}_n = \\mathbf{0}$，我们可以写出 $\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o}) = \\sum \\mathbf{r}_n \\times \\mathbf{F}_n - \\mathbf{o} \\times (\\sum \\mathbf{F}_n) = \\sum \\mathbf{r}_n \\times \\mathbf{F}_n$。这表明净力矩与原点的选择无关。我们可以通过选择一个方便的原点来证明它为零，例如顶点原子的位置 $\\mathbf{o} = \\mathbf{r}_j$：\n$$\n\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{r}_j) = (\\mathbf{r}_i - \\mathbf{r}_j) \\times \\mathbf{F}_i + (\\mathbf{r}_j - \\mathbf{r}_j) \\times \\mathbf{F}_j + (\\mathbf{r}_k - \\mathbf{r}_j) \\times \\mathbf{F}_k = \\mathbf{a} \\times \\mathbf{F}_i + \\mathbf{b} \\times \\mathbf{F}_k\n$$\n代入力表达式并令 $C = \\frac{k_\\theta (\\theta - \\theta_0)}{\\sin\\theta}$：\n$$\n\\mathbf{a} \\times \\mathbf{F}_i = \\mathbf{a} \\times C \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta \\, \\hat{\\mathbf{a}}}{a} \\right) = \\frac{C}{a} (\\mathbf{a} \\times \\hat{\\mathbf{b}}) = C (\\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}})\n$$\n$$\n\\mathbf{b} \\times \\mathbf{F}_k = \\mathbf{b} \\times C \\left( \\frac{\\hat{\\mathbf{a}} - \\cos\\theta \\, \\hat{\\mathbf{b}}}{b} \\right) = \\frac{C}{b} (\\mathbf{b} \\times \\hat{\\mathbf{a}}) = C (\\hat{\\mathbf{b}} \\times \\hat{\\mathbf{a}})\n$$\n将这两项相加得到：\n$$\n\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{r}_j) = C (\\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}} + \\hat{\\mathbf{b}} \\times \\hat{\\mathbf{a}}) = C (\\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}} - \\hat{\\mathbf{a}} \\times \\hat{\\mathbf{b}}) = \\mathbf{0}\n$$\n这个解析结果证实了，如果力计算正确，它们将保持角动量守恒。对于所有指定原点，$\\|\\boldsymbol{\\tau}_{\\text{net}}(\\mathbf{o})\\| \\le \\varepsilon$ 的数值验证为力计算的正确性提供了稳健的测试。\n\n该实现将计算矢量 $\\mathbf{a}$ 和 $\\mathbf{b}$、它们的范数以及角度 $\\theta = \\arccos(\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}})$。一种数值上安全的做法是将 $\\arccos$ 的参数裁剪到 $[-1, 1]$ 范围内。然后，计算力 $\\mathbf{F}_i$ 和 $\\mathbf{F}_k$，接着计算 $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$。最后，将净力和净力矩（对于每个指定原点）的范数与容差 $\\varepsilon$ 进行比较，以确定每个测试用例中守恒定律的有效性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general 3-dimensional configuration)\n        {\n            \"ri\": np.array([0.0, 0.0, 0.0]),\n            \"rj\": np.array([1.0, 0.0, 0.0]),\n            \"rk\": np.array([1.0, 1.0, 0.0]),\n            \"k_theta\": 100.0,\n            \"theta_0\": 1.2\n        },\n        # Case 2 (right angle at the origin)\n        {\n            \"ri\": np.array([1.0, 0.0, 0.0]),\n            \"rj\": np.array([0.0, 0.0, 0.0]),\n            \"rk\": np.array([0.0, 1.0, 0.0]),\n            \"k_theta\": 50.0,\n            \"theta_0\": np.pi / 2\n        },\n        # Case 3 (near-collinear configuration)\n        {\n            \"ri\": np.array([-1.0, 0.0, 0.0]),\n            \"rj\": np.array([0.0, 0.0, 0.0]),\n            \"rk\": np.array([1.0, 1e-6, 0.0]),\n            \"k_theta\": 0.001,\n            \"theta_0\": np.pi\n        },\n        # Case 4 (random 3-dimensional configuration)\n        {\n            \"ri\": np.array([0.2, -0.7, 1.1]),\n            \"rj\": np.array([-0.3, 0.4, -0.5]),\n            \"rk\": np.array([0.9, 0.3, 0.2]),\n            \"k_theta\": 10.0,\n            \"theta_0\": 1.0\n        },\n        # Case 5 (small bond length on one side)\n        {\n            \"ri\": np.array([1e-4, 0.0, 0.0]),\n            \"rj\": np.array([0.0, 0.0, 0.0]),\n            \"rk\": np.array([0.0, 1.0, 0.0]),\n            \"k_theta\": 200.0,\n            \"theta_0\": np.pi / 3\n        }\n    ]\n\n    origins = [\n        np.array([0.0, 0.0, 0.0]),\n        None,  # Placeholder for r_j\n        np.array([0.5, -1.0, 2.0])\n    ]\n    tolerance = 1e-10\n\n    results = []\n    for i, case in enumerate(test_cases):\n        # Set the second origin to be the vertex atom's position r_j\n        current_origins = origins[:]\n        current_origins[1] = case[\"rj\"]\n        \n        result = compute_and_verify(\n            case[\"ri\"], case[\"rj\"], case[\"rk\"],\n            case[\"k_theta\"], case[\"theta_0\"],\n            current_origins, tolerance\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_and_verify(ri, rj, rk, k_theta, theta_0, origins, tolerance):\n    \"\"\"\n    Computes forces for a three-atom angle and verifies conservation laws.\n\n    Args:\n        ri (np.ndarray): Position vector of atom i.\n        rj (np.ndarray): Position vector of atom j (vertex).\n        rk (np.ndarray): Position vector of atom k.\n        k_theta (float): Angle stiffness constant.\n        theta_0 (float): Equilibrium angle in radians.\n        origins (list of np.ndarray): Origins for torque calculation.\n        tolerance (float): Numerical tolerance for verification.\n\n    Returns:\n        bool: True if all conservation laws are met, False otherwise.\n    \"\"\"\n    # 1. Compute vectors from the central atom j\n    a_vec = ri - rj\n    b_vec = rk - rj\n\n    # 2. Compute vector norms (bond lengths)\n    a_norm = np.linalg.norm(a_vec)\n    b_norm = np.linalg.norm(b_vec)\n\n    # Prevent division by zero if a bond length is zero\n    if a_norm == 0 or b_norm == 0:\n        return False # Invalid configuration for angle potential\n\n    # 3. Compute unit vectors\n    a_hat = a_vec / a_norm\n    b_hat = b_vec / b_norm\n\n    # 4. Compute the angle theta\n    # Clip to handle potential floating-point inaccuracies\n    cos_theta = np.clip(np.dot(a_hat, b_hat), -1.0, 1.0)\n    theta = np.arccos(cos_theta)\n\n    # 5. Compute the derivative of potential energy w.r.t. theta\n    dU_dtheta = k_theta * (theta - theta_0)\n    \n    # Check for collinear cases to avoid division by zero\n    sin_theta = np.sin(theta)\n    if np.isclose(sin_theta, 0.0):\n        # If theta is near 0 or pi, and it is the equilibrium angle, forces are zero.\n        if np.isclose(theta, theta_0):\n            Fi, Fj, Fk = np.zeros(3), np.zeros(3), np.zeros(3)\n        else:\n            # The formula has a 0/0 form near equilibrium, use L'Hopital's rule limit.\n            # C = k_theta * (theta - theta_0) / sin(theta)\n            # as theta -> theta_0 (where theta_0 is 0 or pi), C -> k_theta * sign(theta-theta_0) * 1\n            # But forces should be orthogonal to the bond axis, which is ill-defined.\n            # MD engines handle this with specific routines. For this problem's scope,\n            # this indicates a potentially unstable calculation. However, test case 3\n            # is near-collinear and has a non-zero force, handled by the general formula.\n            # If sin_theta is truly zero, it's a singularity unless dU_dtheta is also zero.\n            return False # Unstable case not handled beyond equilibrium\n\n    # 6. Compute forces using the derived formulas\n    # Pre-factor from the chain rule\n    C = dU_dtheta / sin_theta\n    \n    Fi = C * (b_hat - cos_theta * a_hat) / a_norm\n    Fk = C * (a_hat - cos_theta * b_hat) / b_norm\n    \n    # Force on the central atom by translational invariance\n    Fj = -(Fi + Fk)\n\n    # 7. Verify linear momentum conservation\n    F_net = Fi + Fj + Fk\n    if np.linalg.norm(F_net) > tolerance:\n        return False\n\n    # 8. Verify angular momentum conservation for each origin\n    for o in origins:\n        tau_i = np.cross(ri - o, Fi)\n        tau_j = np.cross(rj - o, Fj)\n        tau_k = np.cross(rk - o, Fk)\n        tau_net = tau_i + tau_j + tau_k\n        if np.linalg.norm(tau_net) > tolerance:\n            return False\n\n    # If all checks pass\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3399277"}, {"introduction": "最后一个练习将带你深入探讨分子动力学力场实现中的一个高级话题：数值稳定性。理论上等价的数学表达式在计算机中的表现可能截然不同，这个练习 [@problem_id:3399282] 通过一个具体的编码任务，让你比较两种不同的键角势函数形式在接近线性几何构型时的行为。通过亲手实践，你将深刻理解为何在某些情况下，选择基于角度余弦的势函数 $U(\\cos\\theta)$ 而不是基于角度本身的势函数 $U(\\theta)$，对于保证模拟的稳定性和准确性至关重要。", "problem": "您需要构建一个三原子测试体系，并使用两种不同的势能公式计算键角力，然后比较它们在近线性几何构型下的数值行为。该体系包含三个点状粒子，其位置分别为 $\\mathbf{r}_i$、$\\mathbf{r}_j$ 和 $\\mathbf{r}_k$，它们通过向量 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ 在原子 $j$ 处形成一个角。角度 $\\theta$ 由点积定义，其中 $\\cos\\theta = \\dfrac{\\mathbf{a}\\cdot\\mathbf{b}}{\\lVert \\mathbf{a}\\rVert \\lVert \\mathbf{b}\\rVert}$。您应使用的基本依据是 Newton 第二定律以及保守力定义为势能的梯度：对于一个势能 $U$，作用在坐标 $\\mathbf{r}$ 上的力为 $\\mathbf{F} = -\\nabla_{\\mathbf{r}} U$。使用链式法则，通过 $\\theta$ 或 $\\cos\\theta$ 对笛卡尔坐标的导数来表示力。\n\n考虑两种角势能公式：\n1. 以角变量 $\\theta$ 表示的谐振角势：$U_\\theta(\\theta) = \\dfrac{k}{2}\\left(\\theta - \\theta_0\\right)^2$。\n2. 以角的余弦表示的谐振势：$U_c\\!\\left(\\cos\\theta\\right) = \\dfrac{k_c}{2}\\left(\\cos\\theta - \\cos\\theta_0\\right)^2$。\n\n您的推导应从 $\\theta$、$\\cos\\theta$ 的定义以及梯度法则 $\\mathbf{F} = -\\nabla U$ 出发，并使用链式法则，推导出每种势能下作用于三个原子上的力的表达式。算法实现应避免使用不符合物理原理的捷径，且必须直接反映数学推导过程。\n\n为每个测试用例构建以下测试分子几何构型：将原子 $j$ 置于原点 $\\mathbf{r}_j = (0,0,0)$，将原子 $i$ 置于 $\\mathbf{r}_i = (-1,0,0)$，将原子 $k$ 置于 $\\mathbf{r}_k = (1,\\varepsilon,0)$，其中 $\\varepsilon$ 由各测试用例指定。当 $\\varepsilon$ 很小时，这会在原子 $j$ 处产生一个近线性的角。对位置和力使用无量纲单位，并以弧度为单位测量角度。取 $k = 1$ 和 $k_c = 1$，且 $\\theta_0 = \\pi$ 和 $\\cos\\theta_0 = -1$。\n\n对每个测试用例，分别计算基于 $\\theta$ 的势能和基于 $\\cos\\theta$ 的势能下，三个原子所受力的最大模。具体而言，计算\n$$\nF_{\\max}^{(\\theta)} = \\max\\left(\\lVert \\mathbf{F}_i^{(\\theta)}\\rVert, \\lVert \\mathbf{F}_j^{(\\theta)}\\rVert, \\lVert \\mathbf{F}_k^{(\\theta)}\\rVert\\right),\\quad\nF_{\\max}^{(c)} = \\max\\left(\\lVert \\mathbf{F}_i^{(c)}\\rVert, \\lVert \\mathbf{F}_j^{(c)}\\rVert, \\lVert \\mathbf{F}_k^{(c)}\\rVert\\right),\n$$\n其中上标 $(\\theta)$ 和 $(c)$ 分别表示由 $U_\\theta(\\theta)$ 和 $U_c(\\cos\\theta)$ 计算出的力。\n\n测试组（无量纲 $\\varepsilon$ 值）：\n- 情况 1 (完全线性): $\\varepsilon = 0.0$。\n- 情况 2 (极度接近线性): $\\varepsilon = 10^{-9}$。\n- 情况 3 (非常接近线性): $\\varepsilon = 10^{-6}$。\n- 情况 4 (接近线性): $\\varepsilon = 10^{-3}$。\n- 情况 5 (中度弯曲): $\\varepsilon = 2\\times 10^{-1}$。\n\n您的程序应生成单行输出，该行包含用方括号括起来的、以逗号分隔的结果列表，顺序为 $[F_{\\max}^{(\\theta)}\\text{(情况 1)},F_{\\max}^{(c)}\\text{(情况 1)},F_{\\max}^{(\\theta)}\\text{(情况 2)},F_{\\max}^{(c)}\\text{(情况 2)},\\dots,F_{\\max}^{(\\theta)}\\text{(情况 5)},F_{\\max}^{(c)}\\text{(情况 5)}]$。所有输出均为无量纲单位的实数（浮点数）。在整个计算过程中，角度必须以弧度处理。", "solution": "该问题要求计算和比较源于两种不同键角势能函数的原子受力，特别是在近线性角的情况下。此计算的基础是保守力 $\\mathbf{F}$ 与其对应势能 $U$ 之间的关系，即 $\\mathbf{F} = -\\nabla U$。该体系由三个原子组成，其位置分别为 $\\mathbf{r}_i$、$\\mathbf{r}_j$ 和 $\\mathbf{r}_k$，并在中心原子 $j$ 处形成一个角。\n\n让我们将从中心原子 $j$ 出发的键向量定义为 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$。这些向量的模分别为 $a = \\lVert \\mathbf{a} \\rVert$ 和 $b = \\lVert \\mathbf{b} \\rVert$，其对应的单位向量为 $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ 和 $\\hat{\\mathbf{b}} = \\mathbf{b}/b$。这些向量之间的夹角 $\\theta$ 由其夹角余弦定义，即 $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$。\n\n作用于给定原子（例如原子 $i$）上的力是势能对其笛卡尔坐标的负梯度：$\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$。由于两种势能函数都用角度 $\\theta$ 表示，我们必须使用链式法则。\n\n对于一个势能 $U(\\xi)$（其中 $\\xi$ 是角度的函数，即 $\\theta$ 或 $\\cos\\theta$），作用在原子 $i$ 上的力为：\n$$\n\\mathbf{F}_i = -\\frac{dU}{d\\xi} \\nabla_{\\mathbf{r}_i} \\xi\n$$\n类似的表达式也适用于原子 $j$ 和 $k$。由于平移不变性，体系的总力为零，因此 $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$。这意味着我们只需要推导原子 $i$ 和 $k$ 的梯度。\n\n首先，我们推导 $\\cos\\theta$ 对原子坐标的梯度。对于原子 $i$：\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\nabla_{\\mathbf{r}_i} \\left( \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab} \\right)\n$$\n使用向量微积分的乘法法则以及恒等式 $\\nabla_{\\mathbf{r}_i} \\mathbf{a} = I$（单位矩阵）、$\\nabla_{\\mathbf{r}_i} \\mathbf{b} = 0$、$\\nabla_{\\mathbf{r}_i} a = \\hat{\\mathbf{a}}$ 和 $\\nabla_{\\mathbf{r}_i} b = \\mathbf{0}$，我们得到：\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\frac{1}{ab} (\\nabla_{\\mathbf{r}_i}(\\mathbf{a} \\cdot \\mathbf{b})) + (\\mathbf{a} \\cdot \\mathbf{b}) \\nabla_{\\mathbf{r}_i}((ab)^{-1}) = \\frac{\\mathbf{b}}{ab} - \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{a^3b} \\mathbf{a} = \\frac{1}{a} \\left(\\frac{\\mathbf{b}}{b} - \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab} \\frac{\\mathbf{a}}{a}\\right) = \\frac{\\hat{\\mathbf{b}} - (\\cos\\theta)\\hat{\\mathbf{a}}}{a}\n$$\n根据对称性，将 $i \\leftrightarrow k$ 和 $\\mathbf{a} \\leftrightarrow \\mathbf{b}$ 互换可得：\n$$\n\\nabla_{\\mathbf{r}_k} \\cos\\theta = \\frac{\\hat{\\mathbf{a}} - (\\cos\\theta)\\hat{\\mathbf{b}}}{b}\n$$\n对于所有非共线和非重合的构型，这些表达式都是良定义的。\n\n现在我们可以写出两种势能形式下的力。\n\n1.  **谐振余弦势**：$U_c = \\dfrac{k_c}{2}(\\cos\\theta - \\cos\\theta_0)^2$。\n    此处，$\\xi = \\cos\\theta$。对 $\\xi$ 的导数为 $\\frac{dU_c}{d(\\cos\\theta)} = k_c(\\cos\\theta - \\cos\\theta_0)$。\n    作用在原子 $i$ 和 $k$ 上的力为：\n    $$\n    \\mathbf{F}_i^{(c)} = -k_c(\\cos\\theta - \\cos\\theta_0) \\nabla_{\\mathbf{r}_i} \\cos\\theta = -k_c(\\cos\\theta - \\cos\\theta_0) \\frac{\\hat{\\mathbf{b}} - (\\cos\\theta)\\hat{\\mathbf{a}}}{a}\n    $$\n    $$\n    \\mathbf{F}_k^{(c)} = -k_c(\\cos\\theta - \\cos\\theta_0) \\nabla_{\\mathbf{r}_k} \\cos\\theta = -k_c(\\cos\\theta - \\cos\\theta_0) \\frac{\\hat{\\mathbf{a}} - (\\cos\\theta)\\hat{\\mathbf{b}}}{b}\n    $$\n    这些力的表达式在计算上是稳定的，包括在 $\\theta = 0$ 或 $\\theta = \\pi$ 的线性几何构型下。在平衡角 $\\theta_0=\\pi$ 处，项 $(\\cos\\theta - \\cos\\theta_0)$ 变为零，所有的力都消失，这在物理上是正确的。\n\n2.  **谐振角势**：$U_\\theta = \\dfrac{k}{2}(\\theta - \\theta_0)^2$。\n    此处，$\\xi = \\theta$。导数为 $\\frac{dU_\\theta}{d\\theta} = k(\\theta - \\theta_0)$。$\\theta$ 的梯度可以通过再次应用链式法则找到：$\\nabla \\theta = \\frac{d\\theta}{d(\\cos\\theta)} \\nabla\\cos\\theta = \\frac{-1}{\\sin\\theta} \\nabla\\cos\\theta$。\n    作用在原子 $i$ 和 $k$ 上的力为：\n    $$\n    \\mathbf{F}_i^{(\\theta)} = -k(\\theta - \\theta_0) \\nabla_{\\mathbf{r}_i} \\theta = -k(\\theta - \\theta_0) \\left( \\frac{-1}{\\sin\\theta} \\nabla_{\\mathbf{r}_i} \\cos\\theta \\right) = \\frac{k(\\theta - \\theta_0)}{\\sin\\theta} \\nabla_{\\mathbf{r}_i} \\cos\\theta\n    $$\n    $$\n    \\mathbf{F}_k^{(\\theta)} = \\frac{k(\\theta - \\theta_0)}{\\sin\\theta} \\nabla_{\\mathbf{r}_k} \\cos\\theta\n    $$\n    在 $\\sin\\theta=0$ 的线性几何构型（$\\theta=0$ 或 $\\theta=\\pi$）处，项 $1/\\sin\\theta$ 引入了一个奇点。对于指定的平衡角 $\\theta_0 = \\pi$，当 $\\theta \\to \\pi$ 时，分子 $k(\\theta - \\theta_0)$ 也趋于零。这就产生了一个 $0/0$ 的不定式。虽然解析极限存在，但通过 `(arccos(c) - pi) / sqrt(1 - c*c)` 进行数值计算可能会导致灾难性抵消和浮点误差，使得该公式在数值上不稳定。\n\n对于几何构型完全线性的特殊情况（$\\varepsilon=0$），我们有 $\\theta=\\pi=\\theta_0$。对于 $U_c$ 和 $U_\\theta$ 两种势，体系都处于其势能最低点。能量为零，能量的梯度（因此所有原子上的力）也必须为零。实现中将为这种情况显式地将力设置为零。对于 $\\varepsilon  0$ 的情况，直接应用推导出的公式来计算力和它们的最大模。在近线性几何构型（$\\varepsilon \\to 0$）附近的标度行为表明 $|\\mathbf{F}^{(\\theta)}| \\sim \\varepsilon$，而 $|\\mathbf{F}^{(c)}| \\sim \\varepsilon^3$，这凸显了基于 $\\theta$ 的势能在偏离线性构型很小时所施加的不符合物理原理的扭矩。\n\n对每个 $\\varepsilon$ 值，算法按以下步骤进行：\n1.  定义原子位置 $\\mathbf{r}_i, \\mathbf{r}_j, \\mathbf{r}_k$。\n2.  如果 $\\varepsilon=0$，则力为零。返回 $F_{\\max}^{(\\theta)}=0$ 和 $F_{\\max}^{(c)}=0$。\n3.  如果 $\\varepsilon0$，计算键向量 $\\mathbf{a}, \\mathbf{b}$、它们的模 $a, b$ 以及单位向量 $\\hat{\\mathbf{a}}, \\hat{\\mathbf{b}}$。\n4.  计算 $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$，然后计算 $\\theta = \\arccos(\\cos\\theta)$ 和 $\\sin\\theta = \\sqrt{1 - \\cos^2\\theta}$。\n5.  计算 $\\cos\\theta$ 对 $\\mathbf{r}_i$ 和 $\\mathbf{r}_k$ 的梯度。\n6.  对于 $U_c$ 势，计算力 $\\mathbf{F}_i^{(c)}$、$\\mathbf{F}_k^{(c)}$ 和 $\\mathbf{F}_j^{(c)} = -(\\mathbf{F}_i^{(c)} + \\mathbf{F}_k^{(c)})$。\n7.  对于 $U_\\theta$ 势，计算力 $\\mathbf{F}_i^{(\\theta)}$、$\\mathbf{F}_k^{(\\theta)}$ 和 $\\mathbf{F}_j^{(\\theta)} = -(\\mathbf{F}_i^{(\\theta)} + \\mathbf{F}_k^{(\\theta)})$。\n8.  计算所有力向量的欧几里得范数，并找出每种势能类型下的最大模 $F_{\\max}^{(c)}$ 和 $F_{\\max}^{(\\theta)}$。\n然后收集并格式化所有测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_forces(epsilon):\n    \"\"\"\n    Computes maximum force magnitudes for two angle potentials for a given geometry.\n\n    Args:\n        epsilon (float): The y-coordinate of atom k, controlling the angle.\n\n    Returns:\n        tuple[float, float]: A tuple containing (F_max_theta, F_max_c).\n    \"\"\"\n    # Define physical constants and system parameters\n    k = 1.0\n    k_c = 1.0\n    theta_0 = np.pi\n    cos_theta_0 = -1.0\n\n    # Set up atom coordinates\n    r_i = np.array([-1.0, 0.0, 0.0])\n    r_j = np.array([0.0, 0.0, 0.0])\n    r_k = np.array([1.0, epsilon, 0.0])\n\n    # Handle the exactly linear case (epsilon = 0)\n    # The angle is exactly the equilibrium angle, U=0, so the forces must be zero.\n    # A naive calculation for the theta-potential would result in 0/0 (NaN).\n    if epsilon == 0.0:\n        return 0.0, 0.0\n\n    # Calculate bond vectors and their properties\n    a_vec = r_i - r_j\n    b_vec = r_k - r_j\n\n    a_norm = np.linalg.norm(a_vec)\n    b_norm = np.linalg.norm(b_vec)\n\n    a_hat = a_vec / a_norm\n    b_hat = b_vec / b_norm\n\n    # Calculate angle-related quantities\n    cos_theta = np.dot(a_hat, b_hat)\n    # Clipping can prevent domain errors in np.arccos due to floating point inaccuracies.\n    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n    \n    # theta is needed for the theta-based potential.\n    theta = np.arccos(cos_theta)\n    \n    # sin_theta is required for the derivative d(theta)/dr.\n    # This calculation is more stable than np.sin(np.arccos(cos_theta)).\n    sin_theta = np.sqrt(1.0 - cos_theta**2)\n\n    # --- Forces from the cosine-based potential U_c ---\n    \n    # The force is F = -dU/dr = -(dU/d(cos(theta))) * (d(cos(theta))/dr)\n    # The pre-multiplier is -dU/d(cos(theta)) = -k_c * (cos(theta) - cos_theta_0)\n    premultiplier_c = -k_c * (cos_theta - cos_theta_0)\n\n    # Gradients of cos(theta) with respect to atomic positions\n    grad_cos_theta_i = (b_hat - cos_theta * a_hat) / a_norm\n    grad_cos_theta_k = (a_hat - cos_theta * b_hat) / b_norm\n    \n    F_i_c = premultiplier_c * grad_cos_theta_i\n    F_k_c = premultiplier_c * grad_cos_theta_k\n    # Total force must sum to zero: F_i + F_j + F_k = 0\n    F_j_c = -(F_i_c + F_k_c)\n    \n    # Find the maximum force magnitude\n    F_max_c = max(np.linalg.norm(F_i_c), np.linalg.norm(F_j_c), np.linalg.norm(F_k_c))\n\n    # --- Forces from the angle-based potential U_theta ---\n    \n    # The force is F = -dU/dr = -(dU/d(theta)) * (d(theta)/dr)\n    # and d(theta)/dr = d(arccos(cos_theta))/dr = (-1/sin(theta)) * d(cos(theta))/dr\n    # so F = -k*(theta-theta_0) * (-1/sin(theta)) * d(cos(theta))/dr\n    # The premultiplier is k*(theta-theta_0)/sin(theta)\n    \n    # This premultiplier is numerically unstable as sin(theta) - 0.\n    # For small epsilon  0, theta is near pi, so sin(theta) is small.\n    # (theta - theta_0) is also small. Division of two small numbers can amplify errors.\n    if np.isclose(sin_theta, 0.0):\n        # This condition is met for epsilon=0, handled above. In theory, for very\n        # small epsilon, it could also be triggered, representing the singularity.\n        # The analytical limit of the force is zero, so we set it here.\n        F_max_theta = 0.0\n    else:\n        premultiplier_theta = k * (theta - theta_0) / sin_theta\n    \n        # Reuse the stable gradients of cos(theta)\n        F_i_theta = premultiplier_theta * grad_cos_theta_i\n        F_k_theta = premultiplier_theta * grad_cos_theta_k\n        F_j_theta = -(F_i_theta + F_k_theta)\n        \n        # Find the maximum force magnitude\n        F_max_theta = max(np.linalg.norm(F_i_theta), np.linalg.norm(F_j_theta), np.linalg.norm(F_k_theta))\n\n    return F_max_theta, F_max_c\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-9,\n        1e-6,\n        1e-3,\n        2e-1,\n    ]\n\n    results = []\n    for epsilon in test_cases:\n        f_max_theta, f_max_c = calculate_forces(epsilon)\n        results.append(f_max_theta)\n        results.append(f_max_c)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3399282"}]}