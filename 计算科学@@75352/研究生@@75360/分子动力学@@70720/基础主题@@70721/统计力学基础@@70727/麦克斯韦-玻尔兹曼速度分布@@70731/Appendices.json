{"hands_on_practices": [{"introduction": "这项练习是构建分子模拟的基石。在我们模拟一个系统的演化之前，必须为其粒子赋予与目标温度相符的初始速度。本练习将指导您完成二维麦克斯韦-玻尔兹曼分布的基本推导及其实际实现，为您提供一种生成并验证物理上正确的初始速度系综的可靠方法。[@problem_id:2456611]", "problem": "要求您使用 Maxwell–Boltzmann (MB) 框架，为限制在二维表面上的原子推导、实现并验证一个物理上一致的初始速度分配程序。您的目标是 (i) 从第一性原理推导二维 MB 速率分布，以及 (ii) 编写一个完整的程序，该程序能抽样与此分布一致的初始速度，并通过将统计数据与解析预测进行比较来验证抽样。\n\n您的推导必须从适用于平衡统计力学和经典分子运动的基本原理和定义出发：\n- 动能的玻尔兹曼因子，与 $\\exp\\!\\left(-E/(k_\\mathrm{B} T)\\right)$ 成正比，其中 $E$ 是能量，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n- 在二维空间中，一个质量为 $m$、速度分量为 $\\{v_x, v_y\\}$ 的粒子的理想动能为 $E = \\tfrac{1}{2} m \\left(v_x^2 + v_y^2\\right)$。\n- 平衡态下经典理想气体的动能中，各正交自由度 (DOF) 的独立性。\n- 概率密度函数的变量替换，包括雅可比行列式。\n\n请勿使用、引用或假设目标二维 MB 速率分布或任何关于速率的中间闭式分布；您必须从上述基础出发明确地推导它。您的推导必须得出二维空间中归一化的速率分布以及平均速率 $\\langle v \\rangle$ 的解析表达式。\n\n推导之后，请实现一个完整的、可运行的程序，该程序：\n- 为 $N$ 个位于二维表面上、质量为 $m$、绝对温度为 $T$ 的原子抽样初始速度 $\\{v_x, v_y\\}$，且与推导出的二维 MB 速率分布一致。\n- 使用一个固定种子为 $314159$ 的伪随机数生成器以保证可复现性。\n- 为每个测试用例计算以下验证指标：\n  1. 样本平均速率 $\\overline{v}$，单位为 $\\mathrm{m/s}$。\n  2. $\\overline{v}$ 与您的推导所蕴含的理论平均速率 $\\langle v \\rangle$ 之间的绝对误差，单位为 $\\mathrm{m/s}$。\n  3. 将经验速率分布与解析二维 MB 速率分布（等效地表示为具有适当尺度参数的 Rayleigh 分布）进行比较的 Kolmogorov–Smirnov (KS) 统计量。\n  4. 一个布尔值，指示在相对容差 $\\varepsilon = 5\\times 10^{-3}$ 内，每个自由度的能量均分定理是否成立，即是否同时满足 $\\left|\\frac{\\tfrac{1}{2} m \\overline{v_x^2} - \\tfrac{1}{2} k_\\mathrm{B} T}{\\tfrac{1}{2} k_\\mathrm{B} T}\\right| \\le \\varepsilon$ 和 $\\left|\\frac{\\tfrac{1}{2} m \\overline{v_y^2} - \\tfrac{1}{2} k_\\mathrm{B} T}{\\tfrac{1}{2} k_\\mathrm{B} T}\\right| \\le \\varepsilon$。\n\n使用以下常数和单位：\n- 玻尔兹曼常数 $k_\\mathrm{B} = 1.380\\,649 \\times 10^{-23}\\ \\mathrm{J/K}$。\n- 质量 $m$ 单位为 $\\mathrm{kg}$，温度 $T$ 单位为 $\\mathrm{K}$，速度单位为 $\\mathrm{m/s}$，动能单位为 $\\mathrm{J}$。\n\n测试套件：\n- 用例 1：$m = 6.633\\,520\\,9 \\times 10^{-26}\\ \\mathrm{kg}$，$T = 300$，$N = 100\\,000$。\n- 用例 2：$m = 1.673\\,557\\,5 \\times 10^{-27}\\ \\mathrm{kg}$，$T = 300$，$N = 100\\,000$。\n- 用例 3：$m = 6.633\\,520\\,9 \\times 10^{-26}\\ \\mathrm{kg}$，$T = 1$，$N = 100\\,000$。\n\n程序要求：\n- 程序必须是自包含的，并且不需要任何输入。\n- 对每个用例，计算上面列出的四个验证指标。对于浮点数，四舍五入到 $6$ 位小数。对于布尔值，打印 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，条目按以下顺序排列：$[\\overline{v}_1,\\ \\Delta_1,\\ D_1,\\ b_1,\\ \\overline{v}_2,\\ \\Delta_2,\\ D_2,\\ b_2,\\ \\overline{v}_3,\\ \\Delta_3,\\ D_3,\\ b_3]$，其中 $\\overline{v}_i$ 是用例 $i$ 的样本平均速率（单位 $\\mathrm{m/s}$），$\\Delta_i$ 是绝对误差（单位 $\\mathrm{m/s}$），$D_i$ 是 KS 统计量，$b_i$ 是能量均分布尔值。\n\n所有速率均以 $\\mathrm{m/s}$ 表示，能量以 $\\mathrm{J}$ 表示。不使用角度。百分比（如有）必须表示为小数（例如，百分之三表示为 $0.03$）。\n\n您的最终答案必须是一个遵循指定执行环境的单个完整程序，并准确地产生如上所述的一行输出。", "solution": "所提出的问题是有效的。它在科学上基于统计力学原理，提供了所有必要信息，是适定的，并且其表述是客观的。我们将按要求进行推导和实现。\n\n本文首先从第一性原理推导了二维 Maxwell-Boltzmann (MB) 速率分布，接着推导了理论平均速率。随后，详细说明了用于计算验证的算法。\n\n**1. 二维 Maxwell-Boltzmann 分布的推导**\n\n**1.1. 速度分量分布**\n我们从经典统计力学中关于理想气体处于热平衡状态的基本原理开始。粒子处于特定状态的概率与玻尔兹曼因子 $\\exp(-E/(k_\\mathrm{B} T))$ 成正比，其中 $E$ 是该状态的能量，$k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。对于一个质量为 $m$、被限制在二维表面上的粒子，其动能 $E$ 以其笛卡尔速度分量 $\\{v_x, v_y\\}$ 表示为：\n$$\nE = \\frac{1}{2}m(v_x^2 + v_y^2)\n$$\n速度分量 $v_x$ 和 $v_y$ 代表独立的、正交的自由度。因此，速度矢量 $f(v_x, v_y)$ 的联合概率密度函数 (PDF) 可以表示为每个分量的独立 PDF 的乘积，即 $f_x(v_x)$ 和 $f_y(v_y)$。能量可以分解为 $E = E_x + E_y$，其中 $E_x = \\frac{1}{2}mv_x^2$ 且 $E_y = \\frac{1}{2}mv_y^2$。\n因此，$v_x$ 分量的 PDF 与其相应能量的玻尔兹曼因子成正比：\n$$\nf_x(v_x) \\propto \\exp\\left(-\\frac{E_x}{k_\\mathrm{B} T}\\right) = \\exp\\left(-\\frac{m v_x^2}{2 k_\\mathrm{B} T}\\right)\n$$\n为了获得一个归一化的 PDF，我们引入一个归一化常数 $A$，并施加总概率为 1 的条件：\n$$\n\\int_{-\\infty}^{\\infty} f_x(v_x) dv_x = A \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{m v_x^2}{2 k_\\mathrm{B} T}\\right) dv_x = 1\n$$\n这是一个形式为 $\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\pi/a}$ 的标准高斯积分。当 $a = m/(2 k_\\mathrm{B} T)$ 时，该积分的计算结果为 $\\sqrt{2\\pi k_\\mathrm{B} T/m}$。\n求解 $A$：\n$$\nA = \\left(\\frac{m}{2\\pi k_\\mathrm{B} T}\\right)^{1/2}\n$$\n$v_x$ 的归一化 PDF 是一个均值为 $0$、方差为 $\\sigma_v^2 = k_\\mathrm{B} T/m$ 的高斯分布：\n$$\nf_x(v_x) = \\left(\\frac{m}{2\\pi k_\\mathrm{B} T}\\right)^{1/2} \\exp\\left(-\\frac{m v_x^2}{2 k_\\mathrm{B} T}\\right)\n$$\n根据对称性，$v_y$ 的 PDF 是相同的。速度分量的联合 PDF 为：\n$$\nf(v_x, v_y) = f_x(v_x) f_y(v_y) = \\frac{m}{2\\pi k_\\mathrm{B} T} \\exp\\left(-\\frac{m(v_x^2 + v_y^2)}{2 k_\\mathrm{B} T}\\right)\n$$\n\n**1.2. 速率分布**\n为了找到速率 $v = \\sqrt{v_x^2 + v_y^2}$ 的分布，我们将速度分量从笛卡尔坐标 $(v_x, v_y)$ 变换到极坐标 $(v, \\theta)$，其中 $v$ 是速率 ($v \\ge 0$)，$\\theta$ 是方向角。变换关系为 $v_x = v \\cos\\theta$ 和 $v_y = v \\sin\\theta$。\n微分面积元变换为 $dv_x dv_y = |J| dv d\\theta$，其中 $J$ 是变换的雅可比行列式：\n$$\nJ = \\det \\begin{pmatrix} \\frac{\\partial v_x}{\\partial v}  \\frac{\\partial v_x}{\\partial \\theta} \\\\ \\frac{\\partial v_y}{\\partial v}  \\frac{\\partial v_y}{\\partial \\theta} \\end{pmatrix} = \\det \\begin{pmatrix} \\cos\\theta  -v\\sin\\theta \\\\ \\sin\\theta  v\\cos\\theta \\end{pmatrix} = v\\cos^2\\theta + v\\sin^2\\theta = v\n$$\n极坐标中的联合 PDF $g(v, \\theta)$ 是通过将坐标变换代入 $f(v_x, v_y)$ 并乘以雅可比行列式得到的：\n$$\ng(v, \\theta) dv d\\theta = f(v\\cos\\theta, v\\sin\\theta) v dv d\\theta = \\frac{m}{2\\pi k_\\mathrm{B} T} \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right) v dv d\\theta\n$$\n速率的 PDF $P(v)$ 是通过将 $g(v, \\theta)$ 对所有可能的角度 $\\theta \\in [0, 2\\pi]$ 进行积分得到的：\n$$\nP(v) = \\int_0^{2\\pi} \\frac{m}{2\\pi k_\\mathrm{B} T} v \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right) d\\theta = 2\\pi \\left(\\frac{m}{2\\pi k_\\mathrm{B} T}\\right) v \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right)\n$$\n这可以简化为二维 Maxwell-Boltzmann 速率分布：\n$$\nP(v) = \\frac{m}{k_\\mathrm{B} T} v \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right) \\quad \\text{for } v \\geq 0\n$$\n这是一个尺度参数为 $\\sigma = \\sqrt{k_\\mathrm{B} T / m}$ 的 Rayleigh 分布。\n\n**1.3. 平均速率**\n平均速率 $\\langle v \\rangle$ 是 $v$ 相对于分布 $P(v)$ 的期望值：\n$$\n\\langle v \\rangle = \\int_0^{\\infty} v P(v) dv = \\int_0^{\\infty} v \\left(\\frac{m}{k_\\mathrm{B} T}\\right) v \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right) dv = \\frac{m}{k_\\mathrm{B} T} \\int_0^{\\infty} v^2 \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right) dv\n$$\n这个积分的形式为 $\\int_0^{\\infty} x^2 e^{-ax^2} dx = \\frac{1}{4}\\sqrt{\\frac{\\pi}{a^3}}$。这里，$a = m/(2 k_\\mathrm{B} T)$。\n将 $a$ 代入积分的解中得到：\n$$\n\\int_0^{\\infty} v^2 \\exp\\left(-\\frac{mv^2}{2 k_\\mathrm{B} T}\\right) dv = \\frac{1}{4} \\sqrt{\\frac{\\pi}{(m/2k_\\mathrm{B} T)^3}} = \\frac{1}{4} \\sqrt{\\frac{8\\pi (k_\\mathrm{B} T)^3}{m^3}} = \\frac{\\sqrt{2\\pi}}{2} \\frac{(k_\\mathrm{B} T)^{3/2}}{m^{3/2}}\n$$\n将此结果代回 $\\langle v \\rangle$ 的表达式中：\n$$\n\\langle v \\rangle = \\frac{m}{k_\\mathrm{B} T} \\left(\\frac{\\sqrt{2\\pi}}{2} \\frac{(k_\\mathrm{B} T)^{3/2}}{m^{3/2}}\\right) = \\sqrt{\\frac{\\pi k_\\mathrm{B} T}{2m}}\n$$\n这就是在二维空间中平均速率的解析表达式。\n\n**2. 计算验证算法**\n\n该计算过程旨在为包含 $N$ 个原子的系统抽样初始速度，并将样本与推导出的理论结果进行验证。\n\n**2.1. 速度抽样**\n根据推导，速度分量 $v_x$ 和 $v_y$ 是独立的，并且各自服从均值为 $0$、方差为 $\\sigma_v^2 = k_\\mathrm{B} T / m$ 的高斯（正态）分布。因此，标准差为 $\\sigma_v = \\sqrt{k_\\mathrm{B} T / m}$。\n对于一个包含 $N$ 个粒子的系统，我们使用一个伪随机数生成器从该正态分布中抽取 $N$ 个 $v_x$ 值和 $N$ 个 $v_y$ 值。使用固定种子初始化的生成器可确保可复现性。\n\n**2.2. 验证指标计算**\n对于每个具有指定质量 $m$、温度 $T$ 和粒子数 $N$ 的测试用例：\n1.  **样本平均速率 ($\\overline{v}$)**：在生成了 $i=1, \\dots, N$ 的速度分量 $\\{v_{x,i}, v_{y,i}\\}$ 之后，每个粒子的速率计算为 $v_i = \\sqrt{v_{x,i}^2 + v_{y,i}^2}$。样本平均速率是算术平均值：$\\overline{v} = \\frac{1}{N} \\sum_{i=1}^N v_i$。\n2.  **绝对误差 ($\\Delta$)**: 样本平均速率与理论平均速率之间的绝对误差计算为 $\\Delta = |\\overline{v} - \\langle v \\rangle|$，其中 $\\langle v \\rangle = \\sqrt{\\pi k_\\mathrm{B} T / (2m)}$。\n3.  **Kolmogorov-Smirnov (KS) 统计量 ($D$)**: 将抽样速率的经验累积分布函数 (CDF) 与二维 MB 速率分布的理论 CDF 进行比较。后者是一个尺度参数为 $\\sigma = \\sqrt{k_\\mathrm{B} T / m}$ 的 Rayleigh 分布。KS 统计量 $D$ 是两个 CDF 之间的最大绝对差。\n4.  **能量均分检验 ($b$)**: 能量均分定理指出，每个二次自由度的平均动能为 $\\frac{1}{2} k_\\mathrm{B} T$。我们通过计算每个分量的样本平均动能 $\\langle E_x \\rangle = \\frac{1}{2}m \\overline{v_x^2}$ 和 $\\langle E_y \\rangle = \\frac{1}{2}m \\overline{v_y^2}$ 来对此进行计算验证。将相对于理论值 $\\frac{1}{2} k_\\mathrm{B} T$ 的相对误差与容差 $\\varepsilon = 5 \\times 10^{-3}$ 进行比较。如果两个相对误差都小于或等于 $\\varepsilon$，则条件满足。\n$$\n\\left|\\frac{\\frac{1}{2}m \\overline{v_x^2} - \\frac{1}{2}k_\\mathrm{B} T}{\\frac{1}{2}k_\\mathrm{B} T}\\right| \\le \\varepsilon \\quad \\text{和} \\quad \\left|\\frac{\\frac{1}{2}m \\overline{v_y^2} - \\frac{1}{2}k_\\mathrm{B} T}{\\frac{1}{2}k_\\mathrm{B} T}\\right| \\le \\varepsilon\n$$\n然后，将这些计算的结果按规定格式化并报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a 2D initial velocity assignment procedure\n    using the Maxwell-Boltzmann framework.\n    \"\"\"\n\n    # Define constants and test cases\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    EPSILON = 5e-3        # Relative tolerance for equipartition check\n    SEED = 314159         # Seed for pseudo-random number generator\n\n    test_cases = [\n        # Case 1: Argon-like at 300 K\n        {'m': 6.6335209e-26, 'T': 300, 'N': 100000},\n        # Case 2: Hydrogen-like at 300 K\n        {'m': 1.6735575e-27, 'T': 300, 'N': 100000},\n        # Case 3: Argon-like at 1 K\n        {'m': 6.6335209e-26, 'T': 1, 'N': 100000},\n    ]\n\n    # Initialize the random number generator for reproducibility\n    rng = np.random.default_rng(SEED)\n\n    results = []\n\n    for case in test_cases:\n        m = case['m']\n        T = case['T']\n        N = case['N']\n\n        # 1. Sample initial velocities\n        # The velocity components vx and vy are independent and follow a\n        # a normal distribution with mean=0 and variance = k_B*T/m.\n        # The standard deviation is sqrt(k_B*T/m).\n        sigma_v = np.sqrt(K_B * T / m)\n        vx = rng.normal(loc=0.0, scale=sigma_v, size=N)\n        vy = rng.normal(loc=0.0, scale=sigma_v, size=N)\n\n        # 2. Compute sample speeds and average speed\n        speeds = np.sqrt(vx**2 + vy**2)\n        v_bar = np.mean(speeds)\n\n        # 3. Compute theoretical mean speed for 2D system\n        v_theory = np.sqrt((np.pi * K_B * T) / (2 * m))\n        \n        # 4. Calculate validation metrics\n        \n        # Absolute error\n        delta = np.abs(v_bar - v_theory)\n\n        # Kolmogorov-Smirnov statistic\n        # The theoretical distribution is a Rayleigh distribution with scale=sigma_v.\n        ks_statistic, _ = stats.kstest(speeds, 'rayleigh', args=(0, sigma_v))\n        \n        # Equipartition theorem check\n        E_kin_x = 0.5 * m * np.mean(vx**2)\n        E_kin_y = 0.5 * m * np.mean(vy**2)\n        E_theory_per_dof = 0.5 * K_B * T\n        \n        rel_err_x = np.abs((E_kin_x - E_theory_per_dof) / E_theory_per_dof)\n        rel_err_y = np.abs((E_kin_y - E_theory_per_dof) / E_theory_per_dof)\n        \n        equipartition_ok = (rel_err_x = EPSILON) and (rel_err_y = EPSILON)\n\n        results.extend([\n            round(v_bar, 6),\n            round(delta, 6),\n            round(ks_statistic, 6),\n            equipartition_ok\n        ])\n    \n    # Format the final output string\n    output_str = \"[\"\n    for i in range(len(test_cases)):\n        base_idx = i * 4\n        output_str += f\"{results[base_idx]:.6f},\"\n        output_str += f\"{results[base_idx+1]:.6f},\"\n        output_str += f\"{results[base_idx+2]:.6f},\"\n        output_str += f\"{results[base_idx+3]}\"\n        if i  len(test_cases) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n\n    print(output_str)\n\nsolve()\n```", "id": "2456611"}, {"introduction": "虽然生成理想的麦克斯韦-玻尔兹曼分布是一个关键的起点，但一项更高级的任务是诊断系统在模拟过程中是否*保持*在热平衡状态。本练习介绍了一种复杂的统计工具——矩生成函数（MGF），用于检测诸如“尾部膨胀”之类的细微偏差——即高能粒子的过度存在，这可能预示着非平衡条件或恒温器伪影。通过将模拟数据得出的矩生成函数与理论预测进行比较，您将学会如何为重要的物理现象构建一个灵敏的探测器。[@problem_id:3424072]", "problem": "考虑一种三维气体，由相同的、无相互作用的粒子组成，并进行分子动力学 (MD) 模拟。分子动力学 (MD) 是指在指定的热力学条件下，对遵循牛顿动力学的经典粒子进行的数值模拟。设每个粒子的质量为 $m$，绝对温度为 $T$。Maxwell-Boltzmann (MB) 速度分布意味着速度的每个笛卡尔分量都是一个独立的、均值为零、方差为 $k_\\mathrm{B} T / m$ 的高斯随机变量，其中 $k_\\mathrm{B}$ 表示 Boltzmann 常数。将速率记为 $v$，且 $v^2 = v_x^2 + v_y^2 + v_z^2$。定义速率平方可观测量的矩生成函数为 $M(t) = \\langle e^{t v^2} \\rangle$，其中 $t$ 是一个单位为 $\\mathrm{s^2/m^2}$ 的实数参数，$\\langle \\cdot \\rangle$ 表示关于 $v$ 分布的统计期望。您的任务是为 MB 速率分布推导 $M(t)$，并从类 MD 的合成数据中经验性地计算 $M(t)$，然后利用正 $t$ 值的偏差来检测尾部膨胀。\n\n从与 MB 理论一致的基本事实出发，即：(i) 每个分量 $v_i$ ($i \\in \\{x,y,z\\}$) 服从均值为零、方差为 $k_\\mathrm{B}T/m$ 的高斯分布，以及 (ii) 速率 $v$ 具有一个通过从笛卡尔坐标变换到球坐标获得的相关分布，为 MB 速率分布推导出 $M(t)$ 的闭合形式。指明使 $M(t)$ 存在的 $t$ 的定义域。设计一个算法，从大量的合成 MD 样本中经验性地估计 $M(t)$，并在正 $t$ 值的经验 $M(t)$ 显著大于 MB 预测值时标记尾部膨胀。使用具有统计学原理的决策规则：应使用中心极限定理 (CLT)，将正 $t$ 值下的经验差异与均值的经验标准误进行比较，并使用一个指定的阈值乘数。\n\n您必须实现一个完整、可运行的程序，该程序：\n- 使用下面列出的物理常数和参数。\n- 计算解析的 Maxwell-Boltzmann $M_\\mathrm{MB}(t)$。\n- 生成两个粒子速度的合成 MD 数据集：\n  1. 一个与温度 $T$ 下的 MB 分布一致的基准平衡数据集。\n  2. 一个作为混合物构建的尾部膨胀数据集：以概率 $p$ 从较高温度 $T_\\mathrm{hot}$ 的 MB 分布中抽取速度分量，以概率 $1 - p$ 从温度 $T$ 的 MB 分布中抽取。这种混合模型模拟了罕见的、使尾部膨胀的高能爆发，同时保持了物理上的合理性和自洽性。\n- 对于给定的 $t$，计算经验矩生成函数 $M_\\mathrm{emp}(t) = \\frac{1}{N}\\sum_{j=1}^{N} e^{t v_j^2}$，其中 $N$ 是采样粒子数，$v_j^2$ 是粒子 $j$ 的速率平方；计算合成数据集上 $e^{t v^2}$ 的经验方差以及相应的标准误 $\\mathrm{SE}(t) = \\sqrt{\\mathrm{Var}(e^{t v^2})/N}$。\n- 应用检测规则：当且仅当 $t  0$ 且对于指定的阈值乘数 $z$ 有 $M_\\mathrm{emp}(t) - M_\\mathrm{MB}(t)  z \\cdot \\mathrm{SE}(t)$ 时，将尾部膨胀声明为布尔值 true；否则声明为 false。\n\n使用以下科学上一致的常数和参数，所有量均以其适当的单位表示：\n- Boltzmann 常数：$k_\\mathrm{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J/K}$。\n- 粒子质量 (类氩)：$m = 6.6335209 \\times 10^{-26}\\ \\mathrm{kg}$。\n- 平衡温度：$T = 300\\ \\mathrm{K}$。\n- 混合物的高温：$T_\\mathrm{hot} = 600\\ \\mathrm{K}$。\n- 混合分数：$p = 0.10$。\n- 每个数据集的样本大小：$N = 200\\,000$。\n- 显著性阈值乘数：$z = 5$。\n\n您必须以 $\\mathrm{s^2/m^2}$ 为单位表示 $t$，并且仅在 MB 分布所隐含的存在域内的 $t$ 值上计算 $M(t)$。该算法必须是纯数值的，并且不得依赖任何外部数据。\n\n测试套件：\n- 情况 1：在温度 $T$ 下的基准数据集，其中 $t = 1.0 \\times 10^{-6}\\ \\mathrm{s^2/m^2}$。\n- 情况 2：在温度 $T$ 下的基准数据集，其中 $t = -1.0 \\times 10^{-6}\\ \\mathrm{s^2/m^2}$。\n- 情况 3：尾部膨胀的混合数据集，其中 $t = 1.0 \\times 10^{-6}\\ \\mathrm{s^2/m^2}$。\n- 情况 4：尾部膨胀的混合数据集，其中 $t = 3.0 \\times 10^{-6}\\ \\mathrm{s^2/m^2}$。\n\n所有四个 $t$ 值都满足由平衡温度 $T$ 隐含的 MB 定义域约束和由 $T_\\mathrm{hot}$ 隐含的混合物定义域约束；您必须在程序中以数值方式验证并使用此定义域。\n\n您的程序应输出单行，其中包含一个方括号内的逗号分隔列表，该列表按顺序汇总了上述四个测试用例的布尔型尾部膨胀检测结果，例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$，其中每个条目为 $\\text{True}$ 或 $\\text{False}$。不允许有其他输出。所有内部数值计算必须在国际单位制 (SI) 中执行，速度单位为 $\\mathrm{m/s}$，质量单位为 $\\mathrm{kg}$，温度单位为 $\\mathrm{K}$，$t$ 的单位为 $\\mathrm{s^2/m^2}$。", "solution": "用户提供的问题经过严格验证和确认，是科学上合理、适定且客观的。它基于统计力学和计算物理的既定原理，为理论推导和数值实现提供了一套清晰、自洽的指令和参数。该问题没有任何列出的可使其无效的缺陷。\n\n这项任务是双重的：首先，对于服从 Maxwell-Boltzmann (MB) 分布的气体，推导速率平方的矩生成函数 (MGF) 的解析形式，$M(t) = \\langle e^{t v^2} \\rangle$；其次，设计并实现一个数值算法，从合成数据中估计此函数，并用它来检测粒子速度分布中的尾部膨胀。\n\n### 1. 矩生成函数的解析推导\n\n出发点是三维空间中 Maxwell-Boltzmann 分布的基本原理。粒子速度的每个笛卡尔分量 $v_i$ (其中 $i \\in \\{x, y, z\\}$) 是一个独立同分布 (i.i.d.) 的随机变量，服从均值为零 ($\\mu=0$)、方差为 $\\sigma^2 = k_\\mathrm{B} T / m$ 的高斯 (正态) 分布。单个速度分量 $v_i$ 的概率密度函数 (PDF) 为：\n$$\nf(v_i) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{v_i^2}{2\\sigma^2}\\right)\n$$\n其中 $k_\\mathrm{B}$ 是 Boltzmann 常数，$T$ 是绝对温度，$m$ 是粒子质量。\n\n矩生成函数是为某个可观测量定义的，在此情况下是速率平方 $v^2 = v_x^2 + v_y^2 + v_z^2$。我们要求解 $M(t) = \\langle e^{t v^2} \\rangle$。由于速度分量的独立性，积的期望等于期望的积：\n$$\nM(t) = \\langle e^{t(v_x^2 + v_y^2 + v_z^2)} \\rangle = \\langle e^{t v_x^2} e^{t v_y^2} e^{t v_z^2} \\rangle = \\langle e^{t v_x^2} \\rangle \\langle e^{t v_y^2} \\rangle \\langle e^{t v_z^2} \\rangle\n$$\n由于各分量是同分布的，我们只需要计算一个分量速度平方的 MGF，$M_{v_i^2}(t) = \\langle e^{t v_i^2} \\rangle$，然后将结果取立方即可。\n\n$v_i^2$ 的 MGF 是通过对其概率分布进行积分来计算的：\n$$\nM_{v_i^2}(t) = \\int_{-\\infty}^{\\infty} e^{t v_i^2} f(v_i) dv_i = \\int_{-\\infty}^{\\infty} e^{t v_i^2} \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{v_i^2}{2\\sigma^2}\\right) dv_i\n$$\n合并指数项可得：\n$$\nM_{v_i^2}(t) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\int_{-\\infty}^{\\infty} \\exp\\left(-\\left(\\frac{1}{2\\sigma^2} - t\\right)v_i^2\\right) dv_i\n$$\n这是一个形式为 $\\int_{-\\infty}^{\\infty} e^{-ax^2} dx = \\sqrt{\\pi/a}$ 的标准高斯积分。为使此积分收敛，$-v_i^2$ 的系数必须为正，这给参数 $t$ 施加了一个约束。令 $a = \\frac{1}{2\\sigma^2} - t$。收敛条件是 $a  0$，这意味着 $t  \\frac{1}{2\\sigma^2}$。\n\n假设此条件成立，积分计算结果为 $\\sqrt{\\pi/a} = \\sqrt{\\pi / \\left(\\frac{1}{2\\sigma^2} - t\\right)}$。将其代回 $M_{v_i^2}(t)$ 的表达式中：\n$$\nM_{v_i^2}(t) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\sqrt{\\frac{\\pi}{\\frac{1}{2\\sigma^2} - t}} = \\frac{1}{\\sqrt{2\\sigma^2}} \\frac{1}{\\sqrt{\\frac{1 - 2\\sigma^2 t}{2\\sigma^2}}} = \\frac{1}{\\sqrt{1 - 2\\sigma^2 t}}\n$$\n因此，单个速度平方分量的 MGF 为 $M_{v_i^2}(t) = (1 - 2\\sigma^2 t)^{-1/2}$。\n\n总速率平方 $v^2$ 的 MGF 是此结果的立方：\n$$\nM(t) = \\left( M_{v_i^2}(t) \\right)^3 = \\left( (1 - 2\\sigma^2 t)^{-1/2} \\right)^3 = (1 - 2\\sigma^2 t)^{-3/2}\n$$\n最后，代入 $\\sigma^2 = k_\\mathrm{B} T / m$，我们得到 Maxwell-Boltzmann 分布下 $v^2$ 的 MGF 的解析形式：\n$$\nM_\\mathrm{MB}(t) = \\left(1 - \\frac{2k_\\mathrm{B}T}{m}t\\right)^{-3/2}\n$$\n该函数的存在域由收敛条件 $1 - \\frac{2k_\\mathrm{B}T}{m}t  0$ 定义，可简化为 $t  \\frac{m}{2k_\\mathrm{B}T}$。\n\n### 2. 尾部膨胀检测的算法设计\n\n该算法将数值上检验给定的粒子速度数据集相对于温度 $T$ 下的基准 Maxwell-Boltzmann 分布是否表现出“尾部膨胀”。\n\n**A. 合成数据生成**\n1.  **基准 (MB) 数据集**：为生成 $N$ 个与温度 $T$ 下的 MB 分布一致的速度向量，我们首先计算每个速度分量的标准差：$\\sigma = \\sqrt{k_\\mathrm{B} T / m}$。然后，我们从高斯分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取 $N \\times 3$ 个随机数，并将它们排列成一个 $N \\times 3$ 的数组，其中每一行代表一个粒子的速度向量 $(v_x, v_y, v_z)$。\n\n2.  **尾部膨胀 (混合) 数据集**：该数据集模拟了一个具有罕见高能事件的系统。它是两个 MB 分布的混合。一个粒子的速度分量以概率 $p$ 从温度为 $T_\\mathrm{hot}$ 的“热”分布（标准差为 $\\sigma_\\mathrm{hot} = \\sqrt{k_\\mathrm{B} T_\\mathrm{hot} / m}$）中抽取，并以概率 $1-p$ 从温度为 $T$ 的基准分布中抽取。为了生成这个数据集，对 $N$ 个粒子中的每一个进行随机选择。根据这个选择，相应的速度向量从热高斯分布或基准高斯分布中采样。\n\n**B. 经验 MGF 估计与统计检验**\n给定一个包含 $N$ 个速度向量的数据集 $\\{ \\vec{v}_j \\}_{j=1}^N$ 和一个参数 $t$：\n\n1.  **计算速率平方**：对每个粒子 $j$，计算其速率平方 $v_j^2 = v_{jx}^2 + v_{jy}^2 + v_{jz}^2$。\n\n2.  **计算可观测量**：对每个粒子，计算量 $O_j = e^{t v_j^2}$。\n\n3.  **估计经验 MGF**：经验 MGF，$M_\\mathrm{emp}(t)$，是可观测量 $O_j$ 的样本均值：\n    $$\n    M_\\mathrm{emp}(t) = \\frac{1}{N} \\sum_{j=1}^{N} e^{t v_j^2}\n    $$\n4.  **估计标准误**：中心极限定理 (CLT) 指出，对于大的 $N$，样本均值 $M_\\mathrm{emp}(t)$ 近似服从正态分布，其均值等于真实期望 $\\langle e^{t v^2} \\rangle$，标准差等于均值标准误 (SE)。SE 从数据中估计：\n    $$\n    \\mathrm{SE}(t) = \\sqrt{\\frac{\\mathrm{Var}(e^{t v^2})}{N}}\n    $$\n    其中 $\\mathrm{Var}(e^{t v^2})$ 是可观量的样本方差，计算如下：\n    $$\n    \\mathrm{Var}(e^{t v^2}) = \\frac{1}{N-1} \\sum_{j=1}^{N} \\left(e^{t v_j^2} - M_\\mathrm{emp}(t)\\right)^2\n    $$\n    因子 $1/(N-1)$ 提供了方差的无偏估计。\n\n**C. 检测规则**\n零假设是数据是从温度为 $T$ 的基准 MB 分布中抽取的。尾部膨胀对应于找到高速粒子的概率高于预期。对于 $t  0$，项 $e^{t v^2}$ 极大地加权了高速粒子。因此，如果经验 MGF 显著大于基准分布的理论 MGF，则表明存在尾部膨胀。“显著”的标准由阈值乘数 $z$ 定义。\n\n规则如下：当且仅当同时满足以下两个条件时，检测到尾部膨胀（布尔值 `True`）：\n1.  参数 $t$ 为正 ($t  0$)。\n2.  测量的偏差超过 $z$ 个标准误：$M_\\mathrm{emp}(t) - M_\\mathrm{MB}(t)  z \\cdot \\mathrm{SE}(t)$。\n\n如果 $t \\le 0$ 或者根据此标准偏差在统计上不显著，则不声明存在尾部膨胀（布尔值 `False`）。\n\n这个框架提供了一种有原则的方法，用于将模拟数据与理论模型进行比较，并标记出统计上显著的偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically validates the moment generating function for the\n    Maxwell-Boltzmann speed distribution, and uses it to detect tail inflation.\n    \"\"\"\n\n    # Define physical constants and simulation parameters in SI units.\n    K_B = 1.380649e-23  # Boltzmann constant (J/K)\n    M_PARTICLE = 6.6335209e-26  # Mass of an argon-like particle (kg)\n    T_BASE = 300.0  # Equilibrium temperature (K)\n    T_HOT = 600.0  # Hot temperature for mixture model (K)\n    P_MIXTURE = 0.10  # Mixture fraction for hot particles\n    N_SAMPLES = 200000  # Number of particles in synthetic datasets\n    Z_THRESHOLD = 5.0  # Significance threshold multiplier\n\n    # Set a fixed seed for the random number generator for reproducibility.\n    np.random.seed(42)\n\n    # Define the test suite. Each case is a tuple: (dataset_type, t_value).\n    # dataset_type can be 'baseline' or 'inflated'.\n    # t_value is the parameter for the MGF in s^2/m^2.\n    test_cases = [\n        ('baseline', 1.0e-6),\n        ('baseline', -1.0e-6),\n        ('inflated', 1.0e-6),\n        ('inflated', 3.0e-6),\n    ]\n\n    # --- Helper Functions ---\n\n    def analytic_mgf(t, T, m, k_b):\n        \"\"\"\n        Calculates the analytical moment generating function M(t) for the\n        Maxwell-Boltzmann distribution of squared speeds.\n        Formula: M(t) = (1 - 2*k_b*T*t/m)^(-3/2)\n        \"\"\"\n        # Critical value of t for which the MGF diverges.\n        t_crit = m / (2 * k_b * T)\n        if t >= t_crit:\n            # This case is avoided by problem constraints but good practice.\n            return np.inf\n        \n        arg = 1 - (2 * k_b * T * t) / m\n        return arg**(-1.5)\n\n    def generate_velocities(n, T, m, k_b):\n        \"\"\"\n        Generates n velocity vectors from a Maxwell-Boltzmann distribution.\n        \"\"\"\n        # Standard deviation for each velocity component\n        sigma = np.sqrt(k_b * T / m)\n        # Generate 3D velocity vectors (N, 3)\n        return np.random.normal(loc=0.0, scale=sigma, size=(n, 3))\n\n    def generate_mixture_velocities(n, T_base, T_hot, p, m, k_b):\n        \"\"\"\n        Generates n velocity vectors from a two-temperature mixture model.\n        \"\"\"\n        rng = np.random.default_rng(np.random.PCG64(42))\n        sigma_base = np.sqrt(k_b * T_base / m)\n        sigma_hot = np.sqrt(k_b * T_hot / m)\n\n        # Determine which particles are 'hot' based on probability p\n        is_hot = rng.random(n)  p\n        n_hot = np.sum(is_hot)\n        n_base = n - n_hot\n        \n        velocities = np.zeros((n, 3))\n        \n        # Generate velocities for hot and base particles and place them\n        velocities[is_hot, :] = rng.normal(loc=0.0, scale=sigma_hot, size=(n_hot, 3))\n        velocities[~is_hot, :] = rng.normal(loc=0.0, scale=sigma_base, size=(n_base, 3))\n\n        return velocities\n\n    def test_tail_inflation(velocities, t, T_baseline, m, k_b, z):\n        \"\"\"\n        Tests for tail inflation using the moment generating function.\n        \"\"\"\n        # The detection rule is only defined for t > 0.\n        if t = 0:\n            return False\n\n        # 1. Compute squared speeds for all particles.\n        # velocities shape is (N, 3), so summing over axis 1 gives N speeds.\n        v_squared = np.sum(velocities**2, axis=1)\n\n        # 2. Compute the observable exp(t * v^2) for each particle.\n        observable = np.exp(t * v_squared)\n\n        # 3. Compute empirical MGF and standard error.\n        m_emp = np.mean(observable)\n        # Use ddof=1 for an unbiased estimate of the sample variance.\n        var_obs = np.var(observable, ddof=1)\n        se_m_emp = np.sqrt(var_obs / len(velocities))\n\n        # 4. Compute the theoretical MGF for the baseline distribution.\n        m_theory = analytic_mgf(t, T_baseline, m, k_b)\n\n        # 5. Apply the detection rule.\n        is_inflated = (m_emp - m_theory) > (z * se_m_emp)\n        \n        return is_inflated\n\n    # --- Main Logic ---\n\n    results = []\n    # Re-initialize the global numpy random generator for the mixture model choice\n    np.random.seed(42)\n    for dataset_type, t_val in test_cases:\n        # Generate the appropriate dataset for the current test case.\n        if dataset_type == 'baseline':\n            # Use a fresh generator to ensure independence between test cases if needed\n            vel_data = generate_velocities(N_SAMPLES, T_BASE, M_PARTICLE, K_B)\n        elif dataset_type == 'inflated':\n            vel_data = generate_mixture_velocities(N_SAMPLES, T_BASE, T_HOT, P_MIXTURE, M_PARTICLE, K_B)\n        else:\n            raise ValueError(\"Unknown dataset type\")\n\n        # Perform the tail inflation test.\n        # The comparison is always against the baseline temperature T_BASE.\n        result = test_tail_inflation(vel_data, t_val, T_BASE, M_PARTICLE, K_B, Z_THRESHOLD)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3424072"}, {"introduction": "在实际的分子动力学模拟中，诸如总动量之类的守恒量会引入一些细微的相关性，这在有限规模的系统中尤其显著。本练习探讨了一个关键例子：强制质心总动量为零（一种防止系统整体漂移的标准程序）所带来的效应。您将推导出该约束如何改变单个粒子的速度分布，使其偏离理想的麦克斯韦-玻尔兹曼形式，并量化由此产生的有限尺寸效应，从而深入理解宏观约束与微观统计之间的联系。[@problem_id:3424116]", "problem": "考虑一个由 $N$ 个点粒子组成的经典系综，其质量分别为 $\\{m_1,m_2,\\dots,m_N\\}$，处于三维空间中，热力学温度为 $T$，其热平衡由正则系综描述。用 $k_{\\mathrm{B}}$ 表示玻尔兹曼常数。在没有任何全局约束的情况下，所有粒子笛卡尔速度分量的联合分布是具有零均值的独立高斯分布的乘积，这与麦克斯韦-玻尔兹曼分布一致。在许多分子动力学模拟中，为了专注于内部热运动，会通过施加线性约束 $\\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0}$ 来移除全局质心漂移，其中 $\\mathbf{v}_i \\in \\mathbb{R}^3$ 是粒子 $i$ 的速度。质心（Center of Mass, CM）指的是质量加权的平均位置；这里的质心漂移指的是质量加权的平均速度。\n\n你的任务是，从第一性原理（从正则系综和多元高斯分布的基本性质）出发，推导在质心约束 $\\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0}$ 条件下，对于有限的 $N$，固定粒子索引 $j \\in \\{1,\\dots,N\\}$ 的单粒子速度分布 $f(\\mathbf{v}_j)$。你应该得到在此约束下 $\\mathbf{v}_j$ 的三维概率密度函数的闭式表达式，并描述它与无约束的单粒子麦克斯韦-玻尔兹曼分布有何不同。麦克斯韦-玻尔兹曼（Maxwell–Boltzmann, MB）分布指的是正则系综中处于平衡状态的分子速度的经典分布。\n\n然后，使用你推导的表达式，定义并计算以下无量纲量，这些量化了移除质心漂移对单粒子分布的影响：\n\n- 粒子 $j$ 的每分量方差缩减因子，定义为 $r_j$，它是有约束的每笛卡尔分量方差与无约束的每笛卡尔分量方差之比。\n- 粒子 $j$ 的有约束单粒子速度分布与无约束单粒子速度分布之间的库尔贝克-莱布勒散度（KLD），单位为奈特（nats），记为 $D_{\\mathrm{KL}}$（两者均视为零均值的 $\\mathbb{R}^3$ 上的分布）。库尔贝克-莱布勒（KL）散度是衡量一个概率分布与第二个参考概率分布之间差异的度量。\n- 有约束与无约束的麦克斯韦速率密度在指定标量速率 $v_0$（$v_0$ 以 $\\mathrm{m/s}$ 为单位）处的比值 $R(v_0)$。对于速率 $v = \\|\\mathbf{v}_j\\|$，麦克斯韦速率密度是三维高斯速度矢量分布到径向坐标的标准变换。\n\n用 $N$、$\\{m_i\\}$、$m_j$、$M = \\sum_{i=1}^{N} m_i$、$T$ 和 $k_{\\mathrm{B}}$ 来表示所有中间推导和最终公式。\n\n你的最终程序必须实现这些公式，并为以下每个科学上真实的测试用例计算 $r_j$、$D_{\\mathrm{KL}}$ 和 $R(v_0)$。在指定情况下，使用原子质量单位 $1\\,\\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$ 和氩原子质量 $39.948\\,\\mathrm{amu}$。所有速率 $v_0$ 均以 $\\mathrm{m/s}$ 为单位。\n\n测试套件：\n1.  情况 A（正常路径，质量相同）：$N = 10$，所有 $i$ 的 $m_i = 39.948\\,\\mathrm{amu}$，$T = 300$ (开尔文)，$j = 1$，$v_0 = 400$ (单位 $\\mathrm{m/s}$)。\n2.  情况 B（强约束效应，N 较小）：$N = 2$，所有 $i$ 的 $m_i = 39.948\\,\\mathrm{amu}$，$T = 300$ (开尔文)，$j = 1$，$v_0 = 400$ (单位 $\\mathrm{m/s}$)。\n3.  情况 C（异质质量，重粒子）：$N = 3$，$(m_1,m_2,m_3) = (39.948\\,\\mathrm{amu}, 39.948\\,\\mathrm{amu}, 2 \\times 39.948\\,\\mathrm{amu})$，$T = 1000$ (开尔文)，$j = 3$，$v_0 = 1000$ (单位 $\\mathrm{m/s}$)。\n4.  情况 D（异质质量，轻粒子）：$N = 3$，$(m_1,m_2,m_3) = (39.948\\,\\mathrm{amu}, 39.948\\,\\mathrm{amu}, 2 \\times 39.948\\,\\mathrm{amu})$，$T = 1000$ (开尔文)，$j = 1$，$v_0 = 1000$ (单位 $\\mathrm{m/s}$)。\n5.  情况 E（趋向大 N 的边界情况）：$N = 100$，所有 $i$ 的 $m_i = 39.948\\,\\mathrm{amu}$，$T = 300$ (开尔文)，$j = 51$，$v_0 = 400$ (单位 $\\mathrm{m/s}$)。\n\n对于每种情况，你的程序必须计算：\n- $r_j$\n- $D_{\\mathrm{KL}}$\n- $R(v_0)$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列，每个用例贡献三个连续的浮点数 $[r_j, D_{\\mathrm{KL}}, R(v_0)]$。例如，输出格式必须是 $[r_{A},D_{\\mathrm{KL},A},R_A,r_{B},D_{\\mathrm{KL},B},R_B,\\dots]$。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **系统**：一个由 $N$ 个点粒子组成的经典系综，其质量分别为 $\\{m_1, m_2, \\dots, m_N\\}$，处于三维空间中。\n- **热力学状态**：在温度 $T$ 下处于热平衡，由正则系综描述。\n- **常数**：玻尔兹曼常数为 $k_{\\mathrm{B}}$。\n- **无约束分布**：所有粒子笛卡尔速度分量的联合分布是具有零均值的独立高斯分布的乘积。\n- **约束**：通过施加线性约束 $\\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0}$ 来移除质心（CM）漂移，其中 $\\mathbf{v}_i$ 是粒子 $i$ 的速度。\n- **任务 1：推导**：推导在质心约束条件下，固定粒子索引 $j$ 的单粒子速度分布 $f(\\mathbf{v}_j)$。\n- **任务 2：表征**：获得 $f(\\mathbf{v}_j)$ 的闭式表达式，并表征它与无约束的麦克斯韦-玻尔兹曼分布有何不同。\n- **任务 3：计算**：定义并计算三个无量纲量：\n    1.  每分量方差缩减因子 $r_j$：有约束与无约束的每笛卡尔分量方差之比。\n    2.  库尔贝克-莱布勒散度 $D_{\\mathrm{KL}}$：粒子 $j$ 的有约束与无约束单粒子速度分布之间的散度。\n    3.  速率密度之比 $R(v_0)$：有约束与无约束的麦克斯韦速率密度在标量速率 $v_0$ 处的值的比。\n- **公式所需变量**：$N$, $\\{m_i\\}$, $m_j$, $M = \\sum_{i=1}^{N} m_i$, $T$, 和 $k_{\\mathrm{B}}$。\n- **测试套件**：五个具有给定参数（$N$、质量、$T$、$j$、$v_0$）的具体测试用例。\n- **测试用常数**：$1\\,\\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$，氩原子质量 = $39.948\\,\\mathrm{amu}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学基础（关键）**：该问题牢固地植根于经典统计力学，特别是气体动理论和正则系综的性质。麦克斯韦-玻尔兹曼分布和移除质心运动是分子动力学模拟中的标准概念。该问题在科学上是合理的。\n2.  **良态的**：该问题要求基于一组明确的前提推导条件概率分布及相关量。约束和变量定义明确，能够导出一个唯一且有意义的解。\n3.  **客观性（关键）**：问题以精确的数学语言陈述，没有任何主观性或观点。\n4.  **不完整或矛盾的设置**：问题是自洽的。所有必要信息（系统描述、约束、待推导的量）都已提供。没有矛盾之处。\n5.  **不切实际或不可行**：物理场景（处于平衡态的粒子系综）是现实的。该约束是计算物理中的一种标准技术。测试套件中提供的参数对于像惰性气体这样的系统是科学上可信的。\n6.  **病态或结构不良**：问题结构逻辑清晰，要求先进行推导，然后应用推导出的公式。解是唯一的且稳定的。\n7.  **伪深刻、琐碎或同义反复**：该问题需要涉及多元高斯分布和统计力学性质的非平凡推导，代表了一项实质性的概念挑战。\n8.  **超出科学可验证范围**：推导出的结果可以通过标准的数学和物理推理进行验证。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**，因为它在科学上合理、良态、客观且完整。我将继续进行完整的推导和求解。\n\n---\n\n## 推导与求解\n\n求解过程首先建立无约束的速度分布，然后利用多元高斯分布的性质在零质心动量约束下推导条件分布，最后利用此结果推导所需的量 $r_j$、$D_{\\mathrm{KL}}$ 和 $R(v_0)$。\n\n### 1. 无约束的单粒子速度分布\n\n在温度为 $T$ 的正则系综中，系统在速度空间中的状态的概率密度与玻尔兹曼因子 $e^{-\\beta K}$ 成正比，其中 $\\beta = (k_{\\mathrm{B}}T)^{-1}$，$K$ 是总动能。\n总动能为 $K = \\sum_{i=1}^{N} \\frac{1}{2} m_i \\|\\mathbf{v}_i\\|^2 = \\sum_{i=1}^{N} \\sum_{\\alpha \\in \\{x,y,z\\}} \\frac{1}{2} m_i v_{i\\alpha}^2$。\n这 $3N$ 个速度分量的无约束联合概率密度函数（PDF）是独立高斯分布的乘积：\n$$P(\\mathbf{v}_1, \\dots, \\mathbf{v}_N) \\propto \\exp\\left(-\\frac{\\beta}{2} \\sum_{i=1}^{N} m_i \\|\\mathbf{v}_i\\|^2\\right)$$\n由此，单个粒子 $j$ 的无约束速度分布是一个三维高斯（麦克斯韦-玻尔兹曼）分布：\n$$f_{\\text{unc}}(\\mathbf{v}_j) = \\left(\\frac{m_j \\beta}{2\\pi}\\right)^{3/2} \\exp\\left(-\\frac{1}{2} \\beta m_j \\|\\mathbf{v}_j\\|^2\\right)$$\n这对应于一个多元正态分布 $\\mathbf{v}_j \\sim \\mathcal{N}_3(\\mathbf{0}, \\sigma_{j,\\text{unc}}^2 \\mathbf{I}_3)$，其中 $\\mathbf{I}_3$ 是 $3 \\times 3$ 单位矩阵，每分量方差为 $\\sigma_{j,\\text{unc}}^2 = (m_j \\beta)^{-1} = k_{\\mathrm{B}}T/m_j$。\n\n### 2. 有约束的单粒子速度分布\n\n约束条件是系统的总动量为零：$\\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0}$。这个矢量方程对每个笛卡尔分量独立成立。我们关注 $x$ 分量：\n$$\\sum_{i=1}^{N} m_i v_{ix} = 0$$\n令 $\\mathbf{u}_x = (v_{1x}, v_{2x}, \\dots, v_{Nx})^T$ 为所有粒子速度 $x$ 分量的向量。无约束时，$\\mathbf{u}_x$ 是一个多元高斯随机向量，其均值为 $\\boldsymbol{\\mu} = \\mathbf{0}$，协方差矩阵 $\\mathbf{\\Sigma}_{\\text{unc}}$ 为对角矩阵，其对角元为 $(\\mathbf{\\Sigma}_{\\text{unc}})_{ii} = \\text{Var}(v_{ix}) = k_{\\mathrm{B}}T/m_i$。变量 $v_{ix}$ 是独立的。\n\n为了找到在约束条件下 $v_{jx}$ 的分布，我们使用条件高斯分布的性质。定义一个辅助随机变量 $Z_x = \\sum_{i=1}^N m_i v_{ix}$。作为独立高斯变量的线性组合，$Z_x$ 也是高斯分布的。\n其均值为 $E[Z_x] = \\sum_{i=1}^N m_i E[v_{ix}] = 0$。\n其方差为 $\\text{Var}(Z_x) = \\sum_{i=1}^N \\text{Var}(m_i v_{ix}) = \\sum_{i=1}^N m_i^2 \\text{Var}(v_{ix}) = \\sum_{i=1}^N m_i^2 \\frac{k_{\\mathrm{B}}T}{m_i} = k_{\\mathrm{B}}T \\sum_{i=1}^N m_i = k_{\\mathrm{B}}T M$，其中 $M = \\sum_{i=1}^N m_i$。\n\n我们需要在 $Z_x=0$ 条件下 $v_{jx}$ 的条件分布。我们分析 $(v_{jx}, Z_x)$ 的联合分布，它是一个二元高斯分布。\n协方差为 $\\text{Cov}(v_{jx}, Z_x) = \\text{Cov}(v_{jx}, \\sum_{i=1}^N m_i v_{ix}) = \\sum_{i=1}^N m_i \\text{Cov}(v_{jx}, v_{ix})$。\n由于当 $i \\neq j$ 时 $v_{jx}$ 和 $v_{ix}$ 是独立的，所以当 $i \\neq j$ 时 $\\text{Cov}(v_{jx}, v_{ix})=0$。\n因此，$\\text{Cov}(v_{jx}, Z_x) = m_j \\text{Cov}(v_{jx}, v_{jx}) = m_j \\text{Var}(v_{jx}) = m_j \\frac{k_{\\mathrm{B}}T}{m_j} = k_{\\mathrm{B}}T$。\n\n给定 $Z_x=0$ 时 $v_{jx}$ 的条件方差由标准公式给出：\n$\\sigma_{j,\\text{constr}}^2 = \\text{Var}(v_{jx} | Z_x=0) = \\text{Var}(v_{jx}) - \\frac{\\text{Cov}(v_{jx}, Z_x)^2}{\\text{Var}(Z_x)}$\n$$ \\sigma_{j,\\text{constr}}^2 = \\frac{k_{\\mathrm{B}}T}{m_j} - \\frac{(k_{\\mathrm{B}}T)^2}{k_{\\mathrm{B}}T M} = k_{\\mathrm{B}}T \\left(\\frac{1}{m_j} - \\frac{1}{M}\\right) = \\frac{k_{\\mathrm{B}}T}{m_j} \\left(1 - \\frac{m_j}{M}\\right) $$\n条件均值仍为 $E[v_{jx} | Z_x=0] = 0$。\n同样的逻辑独立地适用于 $y$ 和 $z$ 分量。因此，有约束的速度矢量 $\\mathbf{v}_j$ 服从一个三维高斯分布 $\\mathcal{N}_3(\\mathbf{0}, \\sigma_{j,\\text{constr}}^2 \\mathbf{I}_3)$。其概率密度函数为：\n$$f_{\\text{constr}}(\\mathbf{v}_j) = \\left(\\frac{1}{2\\pi \\sigma_{j,\\text{constr}}^2}\\right)^{3/2} \\exp\\left(-\\frac{\\|\\mathbf{v}_j\\|^2}{2 \\sigma_{j,\\text{constr}}^2}\\right) = \\left(\\frac{m_j \\beta}{2\\pi(1-m_j/M)}\\right)^{3/2} \\exp\\left(-\\frac{\\beta m_j \\|\\mathbf{v}_j\\|^2}{2(1-m_j/M)}\\right)$$\n约束的效果是使每分量方差减少了一个因子 $(1 - m_j/M)$。\n\n### 3. 所需量的计算\n\n#### 方差缩减因子 $r_j$\n方差缩减因子 $r_j$ 是有约束与无约束的每分量方差之比。\n$$r_j = \\frac{\\sigma_{j,\\text{constr}}^2}{\\sigma_{j,\\text{unc}}^2} = \\frac{\\frac{k_{\\mathrm{B}}T}{m_j}(1 - m_j/M)}{\\frac{k_{\\mathrm{B}}T}{m_j}} = 1 - \\frac{m_j}{M}$$\n\n#### 库尔贝克-莱布勒散度 $D_{\\mathrm{KL}}$\n对于两个 $d$ 维零均值高斯分布 $P \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{\\Sigma}_P)$ 和 $Q \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{\\Sigma}_Q)$，从分布 $P$ 到参考分布 $Q$ 的 KL 散度由 $D_{\\mathrm{KL}}(P||Q) = \\frac{1}{2} \\left[ \\text{tr}(\\mathbf{\\Sigma}_Q^{-1} \\mathbf{\\Sigma}_P) - d - \\ln(\\det(\\mathbf{\\Sigma}_Q^{-1}\\mathbf{\\Sigma}_P)) \\right]$ 给出。\n这里，$P$ 是有约束分布，$Q$ 是无约束分布，所以 $\\mathbf{\\Sigma}_P = \\sigma_{j,\\text{constr}}^2 \\mathbf{I}_3$ 且 $\\mathbf{\\Sigma}_Q = \\sigma_{j,\\text{unc}}^2 \\mathbf{I}_3$。维度是 $d=3$。\n$\\mathbf{\\Sigma}_Q^{-1}\\mathbf{\\Sigma}_P = \\frac{\\sigma_{j,\\text{constr}}^2}{\\sigma_{j,\\text{unc}}^2} \\mathbf{I}_3 = r_j \\mathbf{I}_3$。\n迹为 $\\text{tr}(r_j \\mathbf{I}_3) = 3r_j$。\n行列式项为 $\\ln(\\det(r_j \\mathbf{I}_3)) = \\ln(r_j^3) = 3\\ln(r_j)$。\n将这些代入 KLD 公式：\n$$D_{\\mathrm{KL}} = \\frac{1}{2} (3r_j - 3 - 3\\ln(r_j)) = \\frac{3}{2}(r_j - 1 - \\ln(r_j))$$\n因为 $r_j = 1 - m_j/M$，我们也可以写成 $D_{\\mathrm{KL}} = \\frac{3}{2} \\left( -\\frac{m_j}{M} - \\ln\\left(1 - \\frac{m_j}{M}\\right) \\right)$。\n\n#### 速率密度之比 $R(v_0)$\n对于一个各向同性的三维速度分布 $f(\\mathbf{v})$，速率为 $v = \\|\\mathbf{v}\\|$，其速率密度为 $g(v) = 4\\pi v^2 f(\\mathbf{v})$。我们需要比值 $R(v_0) = \\frac{g_{\\text{constr}}(v_0)}{g_{\\text{unc}}(v_0)}$。\n$$R(v_0) = \\frac{4\\pi v_0^2 f_{\\text{constr}}(\\mathbf{v}_j)|_{\\|\\mathbf{v}_j\\|=v_0}}{4\\pi v_0^2 f_{\\text{unc}}(\\mathbf{v}_j)|_{\\|\\mathbf{v}_j\\|=v_0}} = \\frac{\\left(\\frac{1}{2\\pi\\sigma_{j,\\text{constr}}^2}\\right)^{3/2} \\exp\\left(-\\frac{v_0^2}{2\\sigma_{j,\\text{constr}}^2}\\right)}{\\left(\\frac{1}{2\\pi\\sigma_{j,\\text{unc}}^2}\\right)^{3/2} \\exp\\left(-\\frac{v_0^2}{2\\sigma_{j,\\text{unc}}^2}\\right)}$$\n$$R(v_0) = \\left(\\frac{\\sigma_{j,\\text{unc}}^2}{\\sigma_{j,\\text{constr}}^2}\\right)^{3/2} \\exp\\left(\\frac{v_0^2}{2\\sigma_{j,\\text{unc}}^2} - \\frac{v_0^2}{2\\sigma_{j,\\text{constr}}^2}\\right)$$\n使用 $\\sigma_{j,\\text{constr}}^2 = r_j \\sigma_{j,\\text{unc}}^2$:\n$$R(v_0) = \\left(\\frac{1}{r_j}\\right)^{3/2} \\exp\\left(\\frac{v_0^2}{2\\sigma_{j,\\text{unc}}^2} \\left(1 - \\frac{1}{r_j}\\right)\\right)$$\n代入 $\\sigma_{j,\\text{unc}}^2 = k_{\\mathrm{B}}T/m_j$ 和 $1-1/r_j = (r_j-1)/r_j$:\n$$R(v_0) = r_j^{-3/2} \\exp\\left(\\frac{m_j v_0^2}{2 k_{\\mathrm{B}}T} \\left(\\frac{r_j - 1}{r_j}\\right)\\right)$$\n这些公式在提供的代码中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: scipy is permitted but not required for this problem.\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It derives and computes three quantities characterizing the effect of\n    removing center-of-mass drift on a single-particle velocity distribution.\n    \"\"\"\n\n    # Physical constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    AMU = 1.66053906660e-27  # Atomic mass unit in kg\n    M_AR_AMU = 39.948  # Mass of Argon in amu\n    M_AR = M_AR_AMU * AMU # Mass of Argon in kg\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (Happy path, identical masses)\n        {'N': 10, 'masses': [M_AR] * 10, 'T': 300, 'j': 1, 'v0': 400},\n        # Case B (Strong constraint effect, small N)\n        {'N': 2, 'masses': [M_AR] * 2, 'T': 300, 'j': 1, 'v0': 400},\n        # Case C (Heterogeneous masses, heavy particle)\n        {'N': 3, 'masses': [M_AR, M_AR, 2 * M_AR], 'T': 1000, 'j': 3, 'v0': 1000},\n        # Case D (Heterogeneous masses, light particle)\n        {'N': 3, 'masses': [M_AR, M_AR, 2 * M_AR], 'T': 1000, 'j': 1, 'v0': 1000},\n        # Case E (Boundary toward large N)\n        {'N': 100, 'masses': [M_AR] * 100, 'T': 300, 'j': 51, 'v0': 400},\n    ]\n\n    def calculate_metrics(masses, T, j, v0):\n        \"\"\"\n        Calculates r_j, D_KL, and R(v0) for a single test case.\n\n        Args:\n            masses (list): List of particle masses in kg.\n            T (float): Temperature in Kelvin.\n            j (int): 1-based index of the particle of interest.\n            v0 (float): Speed in m/s for evaluating the speed density ratio.\n\n        Returns:\n            tuple: A tuple containing (r_j, D_KL, R_v0).\n        \"\"\"\n        # Convert 1-based particle index to 0-based array index\n        j_idx = j - 1\n        m_j = masses[j_idx]\n        M = sum(masses)\n        \n        # 1. Variance reduction factor, r_j\n        # r_j = 1 - m_j / M\n        r_j = 1.0 - m_j / M\n        \n        # 2. Kullback-Leibler divergence, D_KL (in nats)\n        # D_KL = (3/2) * (r_j - 1 - ln(r_j))\n        D_KL = 1.5 * (r_j - 1.0 - np.log(r_j))\n        \n        # 3. Ratio of speed densities, R(v0)\n        # R(v0) = r_j^(-3/2) * exp( (m_j * v0^2) / (2 * k_B * T) * (r_j - 1) / r_j )\n        exponent_term = (m_j * v0**2) / (2.0 * K_B * T) * ((r_j - 1.0) / r_j)\n        R_v0 = r_j**(-1.5) * np.exp(exponent_term)\n        \n        return r_j, D_KL, R_v0\n\n    results = []\n    for case in test_cases:\n        r, dkl, rv0 = calculate_metrics(\n            masses=case['masses'],\n            T=case['T'],\n            j=case['j'],\n            v0=case['v0']\n        )\n        results.extend([r, dkl, rv0])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3424116"}]}