{"hands_on_practices": [{"introduction": "在分子动力学中，力是势能的负梯度，即 $\\mathbf{F} = -\\nabla V$。虽然这一关系在理论上很简单，但在实际应用中，尤其是在量子力学/分子力学（QM/MM）模拟中，由于势能面是动态计算的，我们常常需要进行数值微分来获得力。本练习让您比较前向差分和中心差分方法的准确性，从而深入理解在力的计算中计算成本与精度之间的权衡。", "problem": "设一个势能面 (PES) 定义在一个 $d$ 维构型空间上，其坐标向量为 $\\mathbf x = (x_1,\\dots,x_d)^\\top$，其中 $d \\in \\mathbb N$。在分子动力学中，作用于系统的力 $\\mathbf F(\\mathbf x)$ 由势能的负梯度给出，即 $\\mathbf F(\\mathbf x) = -\\nabla V(\\mathbf x)$。考虑以下无量纲势能面：\n$$\nV(\\mathbf x) = \\sum_{i=1}^d \\left( \\frac{1}{4} k_i x_i^4 - \\frac{1}{2} a_i x_i^2 \\right) + \\frac{1}{2} c \\sum_{i=1}^d m_i x_i^2,\n$$\n其中 $k_i > 0$，$a_i > 0$，$c > 0$ 和 $m_i > 0$ 是参数。对于此 $V(\\mathbf x)$，其解析梯度分量由基本法则 $\\nabla V(\\mathbf x) = \\left( \\frac{\\partial V}{\\partial x_1}, \\dots, \\frac{\\partial V}{\\partial x_d} \\right)^\\top$ 定义。\n\n假设 $d=20$，选择 $k_i$ 在区间 $[0.8, 1.2]$ 内线性间隔取值，选择 $a_i$ 在区间 $[0.5, 1.5]$ 内线性间隔取值，选择 $c=1$，并选择 $m_i$ 使得当 $i \\le 10$ 时 $m_i=1.8$，当 $i \\ge 11$ 时 $m_i=0.2$。这些选择使得 Hessian 矩阵 $\\nabla^2 V(\\mathbf 0)$ 是不定的，因此 $\\mathbf x=\\mathbf 0$ 是 $V$ 的一个鞍点。\n\n为了研究势能面与力之间的关系，并评估梯度近似对鞍点识别的数值效应，考虑在点 $\\mathbf x$ 处的两个梯度有限差分估计量：\n- 前向差分梯度 $\\mathbf g^{\\mathrm{FD}}(\\mathbf x; h)$，其第 $i$ 个分量为\n$$\ng^{\\mathrm{FD}}_i(\\mathbf x; h) = \\frac{V(\\mathbf x + h \\mathbf e_i) - V(\\mathbf x)}{h},\n$$\n其中 $\\mathbf e_i$ 是第 $i$ 个标准基向量，$h>0$ 是步长。\n- 中心差分梯度 $\\mathbf g^{\\mathrm{CD}}(\\mathbf x; h)$，其第 $i$ 个分量为\n$$\ng^{\\mathrm{CD}}_i(\\mathbf x; h) = \\frac{V(\\mathbf x + h \\mathbf e_i) - V(\\mathbf x - h \\mathbf e_i)}{2h}.\n$$\n\n您的任务如下：\n1. 对给定的 $V(\\mathbf x)$ 推导其解析梯度 $\\nabla V(\\mathbf x)$ 并予以实现。\n2. 实现上文定义的前向差分和中心差分梯度估计量。\n3. 在测试点 $\\mathbf x^\\star \\in \\mathbb R^d$（其分量为 $x^\\star_i = 0.1 \\cdot (-1)^i \\cdot \\frac{i}{d}$）处，计算误差范数\n$$\nE_{\\mathrm{FD}}(h) = \\left\\| \\mathbf g^{\\mathrm{FD}}(\\mathbf x^\\star; h) - \\nabla V(\\mathbf x^\\star) \\right\\|_2, \\quad\nE_{\\mathrm{CD}}(h) = \\left\\| \\mathbf g^{\\mathrm{CD}}(\\mathbf x^\\star; h) - \\nabla V(\\mathbf x^\\star) \\right\\|_2,\n$$\n对于步长列表 $h \\in \\{ 10^{-1}, 5\\cdot10^{-2}, 2.5\\cdot10^{-2}, 1.25\\cdot10^{-2}, 6.25\\cdot10^{-3} \\}$，分别通过对数据对 $\\left(\\log h, \\log E_{\\mathrm{FD}}(h)\\right)$ 和 $\\left(\\log h, \\log E_{\\mathrm{CD}}(h)\\right)$ 进行线性最小二乘拟合，来估计经验标度指数 $p_{\\mathrm{FD}}$ 和 $p_{\\mathrm{CD}}$。\n4. 使用判据 $\\|\\widehat{\\nabla V}(\\mathbf 0; h)\\|_2 < \\tau$ 在 $\\mathbf x=\\mathbf 0$ 处评估鞍点识别，其中 $\\widehat{\\nabla V}$ 是 $\\mathbf g^{\\mathrm{FD}}$ 或 $\\mathbf g^{\\mathrm{CD}}$。为以下三种情况计算此布尔判据：\n   - 情况 A：前向差分，步长 $h = 10^{-1}$，阈值 $\\tau = 10^{-6}$。\n   - 情况 B：前向差分，步长 $h = 10^{-8}$，阈值 $\\tau = 10^{-6}$。\n   - 情况 C：中心差分，步长 $h = 10^{-1}$，阈值 $\\tau = 10^{-12}$。\n本问题中所有量均为无量纲；无需物理单位。\n\n测试套件与最终输出：\n- 您必须总共产生五个结果：\n  1. 浮点数 $p_{\\mathrm{FD}}$。\n  2. 浮点数 $p_{\\mathrm{CD}}$。\n  3. 情况 A 的布尔值。\n  4. 情况 B 的布尔值。\n  5. 情况 C 的布尔值。\n- 您的程序必须产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序如上所述。例如，您的输出必须类似于 $[p_{\\mathrm{FD}},p_{\\mathrm{CD}},\\mathrm{A},\\mathrm{B},\\mathrm{C}]$，不含空格。\n\n程序不应读取任何输入；所有参数和测试用例均按规定固定。算法推导必须基于第一性原理：梯度定义、有限差分定义以及用于推断误差行为的泰勒展开性质。避免使用或引用未从这些基础推导出的快捷公式。", "solution": "用户提供的问题经评估为 **有效的**。它在科学上基于经典力学和数值分析的原理，特别是关于势能面和有限差分法。所有参数、变量和任务都得到了明确的定义，使得问题是适定且自洽的。其前提和目标是客观的，没有任何事实或逻辑上的矛盾。\n\n### 1. 理论框架\n\n该问题围绕 $d$ 维空间中的势能面 $V(\\mathbf{x})$ 与相应力场 $\\mathbf{F}(\\mathbf{x}) = -\\nabla V(\\mathbf{x})$ 之间的关系展开。我们需要比较解析梯度与其数值近似，并分析其对识别临界点的影响。\n\n#### 1.1. 解析梯度\n势能面由下式给出：\n$$\nV(\\mathbf x) = \\sum_{i=1}^d \\left( \\frac{1}{4} k_i x_i^4 - \\frac{1}{2} a_i x_i^2 \\right) + \\frac{1}{2} c \\sum_{i=1}^d m_i x_i^2\n$$\n通过合并二次项，可以将其写得更紧凑：\n$$\nV(\\mathbf x) = \\sum_{i=1}^d \\left( \\frac{1}{4} k_i x_i^4 + \\frac{1}{2} (c m_i - a_i) x_i^2 \\right)\n$$\n梯度 $\\nabla V(\\mathbf x)$ 是一个向量，其分量为偏导数 $\\frac{\\partial V}{\\partial x_j}$。由于势能是各个坐标函数之和（即 $V(\\mathbf{x}) = \\sum_i V_i(x_i)$），因此对 $x_j$ 的偏导数只影响和式中的第 $j$ 项。\n$$\n\\frac{\\partial V}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left( \\frac{1}{4} k_j x_j^4 + \\frac{1}{2} (c m_j - a_j) x_j^2 \\right)\n$$\n应用基本微分法则：\n$$\n\\frac{\\partial V}{\\partial x_j} = \\frac{1}{4} k_j (4 x_j^3) + \\frac{1}{2} (c m_j - a_j) (2 x_j) = k_j x_j^3 + (c m_j - a_j) x_j\n$$\n因此，解析梯度向量 $\\nabla V(\\mathbf{x})$ 的第 $j$ 个分量是 $(\\nabla V(\\mathbf{x}))_j = k_j x_j^3 + (c m_j - a_j) x_j$。\n\n#### 1.2. 有限差分近似与误差标度\n\n有限差分法的精度由其截断误差决定，该误差可通过泰勒级数展开进行分析。\n\n**前向差分 (FD):**\n$V(\\mathbf{x} + h \\mathbf{e}_i)$ 在第 $i$ 个方向上围绕 $\\mathbf{x}$ 的泰勒展开为：\n$$\nV(\\mathbf{x} + h \\mathbf{e}_i) = V(\\mathbf{x}) + h \\frac{\\partial V}{\\partial x_i}\\bigg|_{\\mathbf{x}} + \\frac{h^2}{2!} \\frac{\\partial^2 V}{\\partial x_i^2}\\bigg|_{\\mathbf{x}} + O(h^3)\n$$\n对导数进行整理可得：\n$$\n\\frac{\\partial V}{\\partial x_i}\\bigg|_{\\mathbf{x}} = \\frac{V(\\mathbf{x} + h \\mathbf{e}_i) - V(\\mathbf{x})}{h} - \\frac{h}{2} \\frac{\\partial^2 V}{\\partial x_i^2}\\bigg|_{\\mathbf{x}} - O(h^2)\n$$\n前向差分估计量 $g^{\\mathrm{FD}}_i(\\mathbf{x}; h)$ 与第一项匹配。主误差项为 $-\\frac{h}{2} \\frac{\\partial^2 V}{\\partial x_i^2}$，其阶数为 $O(h)$。因此，误差范数 $E_{\\mathrm{FD}}(h) = \\|\\mathbf{g}^{\\mathrm{FD}} - \\nabla V\\|_2$ 预期与 $h$ 成正比。在误差对步长的对数-对数图上，这对应于一条斜率为 $p_{\\mathrm{FD}} \\approx 1$ 的直线。\n\n**中心差分 (CD):**\n$V(\\mathbf{x} \\pm h \\mathbf{e}_i)$ 的泰勒展开为：\n$$\nV(\\mathbf{x} + h \\mathbf{e}_i) = V(\\mathbf{x}) + h \\frac{\\partial V}{\\partial x_i} + \\frac{h^2}{2} \\frac{\\partial^2 V}{\\partial x_i^2} + \\frac{h^3}{6} \\frac{\\partial^3 V}{\\partial x_i^3} + O(h^4)\n$$\n$$\nV(\\mathbf{x} - h \\mathbf{e}_i) = V(\\mathbf{x}) - h \\frac{\\partial V}{\\partial x_i} + \\frac{h^2}{2} \\frac{\\partial^2 V}{\\partial x_i^2} - \\frac{h^3}{6} \\frac{\\partial^3 V}{\\partial x_i^3} + O(h^4)\n$$\n用第一个展开式减去第二个展开式可以消去偶数阶导数项：\n$$\nV(\\mathbf{x} + h \\mathbf{e}_i) - V(\\mathbf{x} - h \\mathbf{e}_i) = 2h \\frac{\\partial V}{\\partial x_i} + \\frac{2h^3}{6} \\frac{\\partial^3 V}{\\partial x_i^3} + O(h^5)\n$$\n对导数进行整理可得：\n$$\n\\frac{\\partial V}{\\partial x_i} = \\frac{V(\\mathbf{x} + h \\mathbf{e}_i) - V(\\mathbf{x} - h \\mathbf{e}_i)}{2h} - \\frac{h^2}{6} \\frac{\\partial^3 V}{\\partial x_i^3} - O(h^4)\n$$\n中心差分估计量 $g^{\\mathrm{CD}}_i(\\mathbf{x}; h)$ 与第一项匹配。主误差项为 $-\\frac{h^2}{6} \\frac{\\partial^3 V}{\\partial x_i^3}$，其阶数为 $O(h^2)$。因此，误差范数 $E_{\\mathrm{CD}}(h) = \\|\\mathbf{g}^{\\mathrm{CD}} - \\nabla V\\|_2$ 预期与 $h^2$ 成正比。这对应于在对数-对数图上斜率为 $p_{\\mathrm{CD}} \\approx 2$。\n\n### 2. 算法实现\n\n该解决方案将使用 Python 和 `numpy` 库来实现，并遵循任务序列。\n\n1.  **参数设置**：定义常数 $d=20$ 和 $c=1.0$。根据指定规则生成参数向量 $\\mathbf{k}$、$\\mathbf{a}$ 和 $\\mathbf{m}$。构建测试点 $\\mathbf{x}^\\star$。\n\n2.  **函数实现**：实现四个函数：\n    -   `potential_V(x, ...)`：计算标量势能 $V(\\mathbf{x})$。\n    -   `analytic_grad(x, ...)`：使用推导的解析公式计算向量 $\\nabla V(\\mathbf{x})$。\n    -   `forward_diff_grad(x, h, ...)`：对每个分量应用其定义来计算向量 $\\mathbf{g}^{\\mathrm{FD}}(\\mathbf{x}; h)$。\n    -   `central_diff_grad(x, h, ...)`：类似地计算向量 $\\mathbf{g}^{\\mathrm{CD}}(\\mathbf{x}; h)$。\n\n3.  **误差标度分析（任务 3）**：\n    -   解析梯度 $\\nabla V(\\mathbf{x}^\\star)$ 只计算一次。\n    -   一个循环遍历给定的步长 $h$ 列表。在每次迭代中，计算 $\\mathbf{g}^{\\mathrm{FD}}(\\mathbf{x}^\\star; h)$ 和 $\\mathbf{g}^{\\mathrm{CD}}(\\mathbf{x}^\\star; h)$。\n    -   计算并存储误差向量的欧几里得范数 $E_{\\mathrm{FD}}(h)$ 和 $E_{\\mathrm{CD}}(h)$。\n    -   计算步长和误差范数的对数。\n    -   使用 `numpy.polyfit` 对 FD 和 CD 两种情况下的 $(\\log h, \\log E)$ 数据执行线性最小二乘回归。所得直线的斜率提供了估计的标度指数 $p_{\\mathrm{FD}}$ 和 $p_{\\mathrm{CD}}$。\n\n4.  **鞍点分析（任务 4）**：\n    -   此任务在原点 $\\mathbf{x} = \\mathbf{0}$ 处执行。真实梯度为 $\\nabla V(\\mathbf{0}) = \\mathbf{0}$。\n    -   对 $\\mathbf{x}=\\mathbf{0}$ 处的 $\\mathbf{g}^{\\mathrm{CD}}$ 进行分析会发现一个特殊情况。势能 $V(\\mathbf{x})$ 对于每个坐标 $x_i$ 都是一个偶函数（它只包含 $x_i^4$ 和 $x_i^2$ 项）。因此，$V(h\\mathbf{e}_i) = V(-h\\mathbf{e}_i)$。这导致中心差分公式中的分子恰好为零：\n        $$\n        g^{\\mathrm{CD}}_i(\\mathbf{0}; h) = \\frac{V(h\\mathbf{e}_i) - V(-h\\mathbf{e}_i)}{2h} = 0\n        $$\n        这在精确算术和标准浮点算术中都成立，因为 $V(h\\mathbf{e}_i)$ 和 $V(-h\\mathbf{e}_i)$ 的计算是相同的。因此，$\\|\\mathbf{g}^{\\mathrm{CD}}(\\mathbf{0}; h)\\|_2 = 0$。\n    -   在原点处的前向差分梯度不为零：\n        $$\n        g^{\\mathrm{FD}}_i(\\mathbf{0}; h) = \\frac{V(h\\mathbf{e}_i) - V(\\mathbf{0})}{h} = \\frac{1}{h} \\left( \\frac{1}{4}k_i h^4 + \\frac{1}{2}(c m_i - a_i)h^2 \\right) = \\frac{1}{2}(c m_i - a_i)h + \\frac{1}{4}k_i h^3\n        $$\n        对于小的 $h$，这与 $h$ 近似成线性关系。\n    -   评估三个布尔判据：\n        -   **情况 A**：计算 $\\mathbf{g}^{\\mathrm{FD}}(\\mathbf{0}; h=10^{-1})$ 的范数，并与 $\\tau = 10^{-6}$ 比较。由于范数将是 $O(h)$，预期会远大于 $\\tau$。\n        -   **情况 B**：计算 $\\mathbf{g}^{\\mathrm{FD}}(\\mathbf{0}; h=10^{-8})$ 的范数，并与 $\\tau = 10^{-6}$ 比较。由于范数是 $O(h)$，预期会小于 $\\tau$。\n        -   **情况 C**：计算 $\\mathbf{g}^{\\mathrm{CD}}(\\mathbf{0}; h=10^{-1})$ 的范数，并与 $\\tau = 10^{-12}$ 比较。如前所述，此范数将数值上为零，因此满足条件。\n\n最终结果被收集并格式化为所需的字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem by deriving and comparing analytic\n    and finite-difference gradients of a potential energy surface.\n    \"\"\"\n    # 1. Define constants and parameters\n    d = 20\n    c = 1.0\n    k = np.linspace(0.8, 1.2, d)\n    a = np.linspace(0.5, 1.5, d)\n    m = np.zeros(d)\n    m[:10] = 1.8  # for i = 10 (1-based), which is index 0-9 (0-based)\n    m[10:] = 0.2 # for i >= 11 (1-based), which is index 10-19 (0-based)\n\n    # 2. Define the potential and gradient functions\n\n    def potential_v(x_vec, k_vec, a_vec, c_val, m_vec):\n        \"\"\"Computes the potential energy V(x).\"\"\"\n        term1 = 0.25 * k_vec * x_vec**4\n        term2 = -0.5 * a_vec * x_vec**2\n        term3 = 0.5 * c_val * m_vec * x_vec**2\n        return np.sum(term1 + term2 + term3)\n\n    def analytic_grad(x_vec, k_vec, a_vec, c_val, m_vec):\n        \"\"\"Computes the analytic gradient of V(x).\"\"\"\n        return k_vec * x_vec**3 + (c_val * m_vec - a_vec) * x_vec\n\n    def forward_diff_grad(x_vec, h, k_vec, a_vec, c_val, m_vec):\n        \"\"\"Computes the forward-difference gradient.\"\"\"\n        grad = np.zeros_like(x_vec)\n        v_at_x = potential_v(x_vec, k_vec, a_vec, c_val, m_vec)\n        for i in range(len(x_vec)):\n            x_plus_h = x_vec.copy()\n            x_plus_h[i] += h\n            v_at_x_plus_h = potential_v(x_plus_h, k_vec, a_vec, c_val, m_vec)\n            grad[i] = (v_at_x_plus_h - v_at_x) / h\n        return grad\n    \n    def central_diff_grad(x_vec, h, k_vec, a_vec, c_val, m_vec):\n        \"\"\"Computes the central-difference gradient.\"\"\"\n        grad = np.zeros_like(x_vec)\n        for i in range(len(x_vec)):\n            x_plus_h = x_vec.copy()\n            x_plus_h[i] += h\n            v_at_x_plus_h = potential_v(x_plus_h, k_vec, a_vec, c_val, m_vec)\n            \n            x_minus_h = x_vec.copy()\n            x_minus_h[i] -= h\n            v_at_x_minus_h = potential_v(x_minus_h, k_vec, a_vec, c_val, m_vec)\n            \n            grad[i] = (v_at_x_plus_h - v_at_x_minus_h) / (2.0 * h)\n        return grad\n    \n    # 3. Task 3: Error norms and scaling exponents\n    i_vals = np.arange(1, d + 1)\n    x_star = 0.1 * ((-1)**i_vals) * i_vals / d\n    \n    h_values = np.array([1e-1, 5e-2, 2.5e-2, 1.25e-2, 6.25e-3])\n    \n    E_fd = []\n    E_cd = []\n    \n    grad_analytic_at_x_star = analytic_grad(x_star, k, a, c, m)\n    \n    for h in h_values:\n        # Forward difference error\n        grad_fd = forward_diff_grad(x_star, h, k, a, c, m)\n        error_fd = np.linalg.norm(grad_fd - grad_analytic_at_x_star)\n        E_fd.append(error_fd)\n        \n        # Central difference error\n        grad_cd = central_diff_grad(x_star, h, k, a, c, m)\n        error_cd = np.linalg.norm(grad_cd - grad_analytic_at_x_star)\n        E_cd.append(error_cd)\n        \n    # Perform linear regression on log-log data to find scaling exponents\n    log_h = np.log(h_values)\n    log_E_fd = np.log(np.array(E_fd))\n    log_E_cd = np.log(np.array(E_cd))\n    \n    # polyfit returns [slope, intercept]\n    p_fd = np.polyfit(log_h, log_E_fd, 1)[0]\n    p_cd = np.polyfit(log_h, log_E_cd, 1)[0]\n    \n    # 4. Task 4: Saddle point identification at x = 0\n    x_zero = np.zeros(d)\n    \n    # Case A\n    h_A = 1e-1\n    tau_A = 1e-6\n    grad_fd_A = forward_diff_grad(x_zero, h_A, k, a, c, m)\n    norm_A = np.linalg.norm(grad_fd_A)\n    case_A = norm_A  tau_A\n    \n    # Case B\n    h_B = 1e-8\n    tau_B = 1e-6\n    grad_fd_B = forward_diff_grad(x_zero, h_B, k, a, c, m)\n    norm_B = np.linalg.norm(grad_fd_B)\n    case_B = norm_B  tau_B\n\n    # Case C\n    h_C = 1e-1\n    tau_C = 1e-12\n    grad_cd_C = central_diff_grad(x_zero, h_C, k, a, c, m)\n    norm_C = np.linalg.norm(grad_cd_C)\n    case_C = norm_C  tau_C\n    \n    results = [p_fd, p_cd, case_A, case_B, case_C]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3436103"}, {"introduction": "本练习将视角颠倒：给定一组力场样本，我们能否判断它们是否源于一个保守势场？如果可以，我们又该如何重建该势能面？这个“逆问题”是力场开发和理解相互作用本质的基础。您将通过计算旋度等方法来对保守性进行数值检验，并探索路径依赖的线积分如何揭示非保守分量的存在。", "problem": "给定一个有限、均匀的二维网格和一个矢量场的含噪声样本（解释为以约化的无量纲单位表示的力样本）。目标是编程评估该场是否为保守场，使用线积分从力样本中重建标量势，并诊断由噪声或非保守分量引起的路径依赖误差。\n\n假设以下基本事实。一个力场由二维矢量场 $\\mathbf F(\\mathbf r)$ 表示，其中 $\\mathbf r = (x,y)$。一个力场是保守的，当且仅当存在一个标量势 $V(\\mathbf r)$ 使得 $\\mathbf F(\\mathbf r) = -\\nabla V(\\mathbf r)$，这在二维情况下等价于 $\\nabla \\times \\mathbf F(\\mathbf r) = \\mathbf 0$，也等价于线积分与路径无关，即对于任意两点 $\\mathbf a$ 和 $\\mathbf b$ 以及从 $\\mathbf a$到 $\\mathbf b$ 的任意分段光滑路径 $\\mathcal P$，积分 $\\int_{\\mathcal P} \\mathbf F(\\mathbf r)\\cdot d\\mathbf r$ 的值仅取决于 $\\mathbf a$ 和 $\\mathbf b$。对于闭合回路 $\\mathcal C$，路径无关性意味着 $\\oint_{\\mathcal C} \\mathbf F(\\mathbf r)\\cdot d\\mathbf r = 0$。\n\n您的程序必须实现以下内容，并遵循适用于均匀网格的有限差分和离散线积分近似方法：\n\n1. 在矩形区域 $[0,L_x]\\times[0,L_y]$上构建一个均匀网格，沿 $x$ 轴有 $N_x$ 个点，沿 $y$ 轴有 $N_y$ 个点（包括端点），使得网格间距为 $\\Delta x = L_x/(N_x-1)$ 和 $\\Delta y = L_y/(N_y-1)$。\n\n2. 对于每个测试用例，在网格上构建形式如下的含噪声力样本：\n$$\n\\mathbf F(x,y) = -\\nabla V(x,y) + \\gamma \\begin{bmatrix} -y \\\\ x \\end{bmatrix} + \\boldsymbol\\eta(x,y),\n$$\n其中 $V(x,y)$ 是一个由下式定义的二次标量势：\n$$\nV(x,y) = \\tfrac{1}{2}k_x x^2 + \\tfrac{1}{2}k_y y^2 + k_{xy} x y,\n$$\n$\\gamma$ 是非保守旋转强度，$\\boldsymbol\\eta(x,y)$ 是一个加性噪声矢量，其分量是标准差为 $\\sigma$ 的独立同分布零均值高斯分量。由该势产生的精确力是 $(x,y)$ 的线性函数，由 $-\\nabla V(x,y) = \\big(-(k_x x + k_{xy} y), -(k_y y + k_{xy} x)\\big)$ 给出。\n\n3. 通过两种互补的方法诊断非保守性：\n   - 在内部网格节点处计算标量旋度（平面外分量）的离散有限差分近似。使用中心差分来近似内部节点处的 $\\partial F_y/\\partial x$ 和 $\\partial F_x/\\partial y$，并计算所有内部节点上 $\\left(\\partial F_y/\\partial x - \\partial F_x/\\partial y\\right)$ 的均方根。如果没有内部节点（例如，当 $N_x  3$ 或 $N_y  3$ 时），则将此诊断值定义为下面指定的离散环路环流密度的均方根。\n   - 对每个单位网格单元计算离散环路环流密度。具体方法是：在每个边上使用梯形法则计算沿单元边界的线积分 $\\oint \\mathbf F\\cdot d\\mathbf r$ 并求和，然后除以单元面积 $\\Delta x\\,\\Delta y$。报告所有单元上的均方根值。\n\n4. 通过从原点 $(0,0)$到每个网格节点 $(x_i,y_j)$ 的两条典型的正交路径进行线积分来重建标量势场：\n   - 路径 A：首先沿 $x$ 轴从 $(0,0)$ 到 $(x_i,0)$，然后垂直移动到 $(x_i,y_j)$。\n   - 路径 B：首先沿 $y$ 轴从 $(0,0)$ 到 $(0,y_j)$，然后水平移动到 $(x_i,y_j)$。\n   沿每个网格边段使用梯形法则来近似 $\\int \\mathbf F\\cdot d\\mathbf r$，并通过 $V_{\\mathrm A}(x_i,y_j) = -\\int_{\\mathcal P_{\\mathrm A}} \\mathbf F\\cdot d\\mathbf r$ 和 $V_{\\mathrm B}(x_i,y_j) = -\\int_{\\mathcal P_{\\mathrm B}} \\mathbf F\\cdot d\\mathbf r$ 定义重建的势，参考点为 $V(0,0)=0$。计算所有网格节点上差值 $V_{\\mathrm A}(x_i,y_j) - V_{\\mathrm B}(x_i,y_j)$ 的均方根，作为以势为单位的路径依赖性诊断指标。\n\n所有量均采用约化的无量纲单位。您必须将所有输出报告为不带单位符号的纯数字。\n\n您的程序必须实现上述逻辑，并将其应用于以下参数集的测试套件。对于每个测试用例，网格和场生成参数为：\n\n- 测试用例 1（基准保守情况，无噪声）：\n  - $N_x = 41$， $N_y = 41$， $L_x = 1$， $L_y = 1$，\n  - $k_x = 1.2$， $k_y = 0.8$， $k_{xy} = 0.3$，\n  - $\\gamma = 0$， $\\sigma = 0$， $\\text{seed} = 0$。\n\n- 测试用例 2（保守情况，有少量噪声）：\n  - $N_x = 41$， $N_y = 41$， $L_x = 1$， $L_y = 1$，\n  - $k_x = 1.2$， $k_y = 0.8$， $k_{xy} = 0.3$，\n  - $\\gamma = 0$， $\\sigma = 0.01$， $\\text{seed} = 12345$。\n\n- 测试用例 3（非保守旋转分量，无噪声）：\n  - $N_x = 41$， $N_y = 41$， $L_x = 1$， $L_y = 1$，\n  - $k_x = 1.2$， $k_y = 0.8$， $k_{xy} = 0.3$，\n  - $\\gamma = 0.1$， $\\sigma = 0$， $\\text{seed} = 0$。\n\n- 测试用例 4（最小网格边缘情况，有噪声和旋转）：\n  - $N_x = 2$， $N_y = 2$， $L_x = 1$， $L_y = 1$，\n  - $k_x = 1.2$， $k_y = 0.8$，$k_{xy} = 0.3$，\n  - $\\gamma = 0.2$， $\\sigma = 0.05$， $\\text{seed} = 777$。\n\n对于每个测试用例，您的程序必须计算并返回一个包含三个浮点数的列表：\n- 上述定义的有限差分旋度诊断的均方根值，\n- 所有节点上路径差诊断 $\\left(V_{\\mathrm A} - V_{\\mathrm B}\\right)$ 的均方根值，\n- 所有单元上环路环流密度的均方根值。\n\n将报告的每个浮点数四舍五入到六位小数。您的程序应生成单行输出，包含一个以逗号分隔的列表的列表，每个内部列表对应一个测试用例，顺序与上述测试用例相同。例如，您的程序必须打印一行格式如下的输出：\n$[\\,[c_1,p_1,\\ell_1],[c_2,p_2,\\ell_2],[c_3,p_3,\\ell_3],[c_4,p_4,\\ell_4]\\,]$\n其中 $c_i$ 是测试用例 $i$ 的有限差分旋度均方根值，$p_i$ 是测试用例 $i$ 的路径差均方根值，$\\ell_i$ 是测试用例 $i$ 的环路环流密度均方根值。不得打印任何其他文本。", "solution": "该问题是有效的，因为它在科学上基于矢量微积分和经典力学，问题提法明确，有一套清晰客观的任务，并为得到唯一、可验证的解提供了所有必要信息。解决方案通过实现指定的数值方法来推进。\n\n问题的核心是研究二维网格上矢量场 $\\mathbf F$ 的性质。如果一个矢量场是标量势的梯度，即 $\\mathbf F = -\\nabla V$，那么它就是保守场。此性质等价于场的旋度为零，即 $\\nabla \\times \\mathbf F = \\mathbf 0$，也等价于场的线积分与两点之间的路径无关。给定的力场是三个分量的总和：来自二次势 $V(x,y)$ 的保守力、一个非保守的旋转力以及随机噪声。\n$$\n\\mathbf F(x,y) = -\\nabla V(x,y) + \\gamma \\begin{bmatrix} -y \\\\ x \\end{bmatrix} + \\boldsymbol\\eta(x,y)\n$$\n其中 $V(x,y) = \\frac{1}{2}k_x x^2 + \\frac{1}{2}k_y y^2 + k_{xy} x y$。保守部分的旋度为零。旋转部分的旋度为 $(\\nabla \\times \\gamma(-y, x))_z = \\frac{\\partial}{\\partial x}(\\gamma x) - \\frac{\\partial}{\\partial y}(-\\gamma y) = \\gamma + \\gamma = 2\\gamma$。噪声分量为旋度增加了一个随机贡献。\n\n该解决方案通过一个 Python 程序实现，该程序对每个测试用例执行以下步骤：\n\n1.  **网格和力场生成**：在矩形域 $[0,L_x]\\times[0,L_y]$ 上构建一个包含 $N_x \\times N_y$ 个点的均匀网格。网格间距为 $\\Delta x = L_x/(N_x-1)$ 和 $\\Delta y = L_y/(N_y-1)$。建立坐标 $(x_i, y_j)$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。在每个网格点 $(x_i, y_j)$，根据其定义计算力矢量 $\\mathbf F(x_i, y_j) = (F_x, F_y)$。保守分量是 $-\\nabla V = (-(k_x x + k_{xy} y), -(k_y y + k_{xy} x))$。旋转分量是 $(-\\gamma y, \\gamma x)$。添加标准差为 $\\sigma$ 的高斯噪声 $\\boldsymbol\\eta$，并使用特定的随机种子以保证可复现性。\n\n2.  **旋度诊断**：首先通过计算旋度 $(\\nabla \\times \\mathbf F)_z = \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y}$ 的离散近似来诊断非保守性。在内部网格点 $(x_i, y_j)$（其中 $i \\in \\{1, \\dots, N_x-2\\}$ 且 $j \\in \\{1, \\dots, N_y-2\\}$），使用二阶中心差分格式来近似偏导数：\n    $$\n    \\frac{\\partial F_y}{\\partial x}\\bigg|_{(x_i, y_j)} \\approx \\frac{F_y(x_{i+1}, y_j) - F_y(x_{i-1}, y_j)}{2\\Delta x}\n    $$\n    $$\n    \\frac{\\partial F_x}{\\partial y}\\bigg|_{(x_i, y_j)} \\approx \\frac{F_x(x_i, y_{j+1}) - F_x(x_i, y_{j-1})}{2\\Delta y}\n    $$\n    这些旋度值在所有内部点上的均方根（RMS）提供了一个衡量场旋转特性的指标。如果网格没有内部点（即 $N_x  3$ 或 $N_y  3$），则此诊断值定义为接下来描述的环路环流密度的均方根。\n\n3.  **环路环流诊断**：另一个相关的诊断是环流密度。对于由顶点 $(x_i, y_j), (x_{i+1}, y_j), (x_{i+1}, y_{j+1}), (x_i, y_{j+1})$ 定义的每个基本网格单元，通过对沿其四个边的线积分求和来计算环流量 $\\oint \\mathbf F \\cdot d\\mathbf r$。每个边积分都使用梯形法则。例如，沿底边从 $(x_i,y_j)$ 到 $(x_{i+1},y_j)$ 的积分近似为 $\\frac{1}{2}(F_x(x_i,y_j) + F_x(x_{i+1},y_j))\\Delta x$。然后将总环流量除以单元面积 $\\Delta x \\Delta y$ 以获得环流密度。报告该量在所有单元上的均方根值。根据格林定理，该值是网格上平均旋度的离散度量。\n\n4.  **路径依赖诊断**：最终的诊断直接测量势重建的路径依赖性。势 $V(x,y)$ 通过线积分从力场重建，$V(\\mathbf r) = V(\\mathbf r_0) - \\int_{\\mathbf r_0}^{\\mathbf r} \\mathbf F \\cdot d\\mathbf s$。原点的势设置为零，$V(0,0)=0$。使用两条不同的路径到达每个网格点 $(x_i, y_j)$：\n    -   路径 A：$(0,0) \\to (x_i,0) \\to (x_i,y_j)$。势为 $V_A(x_i,y_j) = -\\int_0^{x_i} F_x(x',0)dx' - \\int_0^{y_j} F_y(x_i,y')dy'$。\n    -   路径 B：$(0,0) \\to (0,y_j) \\to (x_i,y_j)$。势为 $V_B(x_i,y_j) = -\\int_0^{y_j} F_y(0,y')dy' - \\int_0^{x_i} F_x(x',y_j)dx'$。\n    沿网格线的积分是通过使用梯形法则对每个分段的贡献求和来计算的。如果场是真正保守的，$V_A$ 和 $V_B$ 将会相同。差值 $V_A(x_i,y_j) - V_B(x_i,y_j)$ 等于由 $(0,0)$ 和 $(x_i,y_j)$ 定义的矩形区域内的总环流量的负值。这个差值在所有网格点上的均方根量化了路径依赖误差，并作为非保守性的全局度量。\n\n程序将此完整过程应用于每个测试用例，计算三个指定的均方根诊断值，将它们四舍五入到六位小数，并将输出格式化为列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (baseline conservative, no noise)\n        {'Nx': 41, 'Ny': 41, 'Lx': 1.0, 'Ly': 1.0,\n         'kx': 1.2, 'ky': 0.8, 'kxy': 0.3,\n         'gamma': 0.0, 'sigma': 0.0, 'seed': 0},\n\n        # Test case 2 (conservative with small noise)\n        {'Nx': 41, 'Ny': 41, 'Lx': 1.0, 'Ly': 1.0,\n         'kx': 1.2, 'ky': 0.8, 'kxy': 0.3,\n         'gamma': 0.0, 'sigma': 0.01, 'seed': 12345},\n\n        # Test case 3 (non-conservative rotational component, no noise)\n        {'Nx': 41, 'Ny': 41, 'Lx': 1.0, 'Ly': 1.0,\n         'kx': 1.2, 'ky': 0.8, 'kxy': 0.3,\n         'gamma': 0.1, 'sigma': 0.0, 'seed': 0},\n\n        # Test case 4 (minimal grid edge case with noise and rotation)\n        {'Nx': 2, 'Ny': 2, 'Lx': 1.0, 'Ly': 1.0,\n         'kx': 1.2, 'ky': 0.8, 'kxy': 0.3,\n         'gamma': 0.2, 'sigma': 0.05, 'seed': 777}\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_one_case(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of floats is the desired format '[f1, f2, f3]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(Nx, Ny, Lx, Ly, kx, ky, kxy, gamma, sigma, seed):\n    \"\"\"\n    Solves a single test case for the given parameters.\n    \"\"\"\n    # 1. Grid and Force Field Generation\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    xx, yy = np.meshgrid(x, y)\n\n    dx = Lx / (Nx - 1) if Nx > 1 else 0\n    dy = Ly / (Ny - 1) if Ny > 1 else 0\n\n    # Conservative force component\n    Fx_cons = -(kx * xx + kxy * yy)\n    Fy_cons = -(ky * yy + kxy * xx)\n\n    # Non-conservative rotational component\n    Fx_rot = -gamma * yy\n    Fy_rot = gamma * xx\n\n    # Noise component\n    rng = np.random.default_rng(seed)\n    eta_x = rng.normal(0, sigma, size=(Ny, Nx))\n    eta_y = rng.normal(0, sigma, size=(Ny, Nx))\n\n    # Total force field\n    Fx = Fx_cons + Fx_rot + eta_x\n    Fy = Fy_cons + Fy_rot + eta_y\n    \n    # 2. Loop Circulation Diagnostic (must be calculated before curl for the edge case)\n    rms_loop_density = 0.0\n    if Nx > 1 and Ny > 1:\n        # Integrals along four edges of each cell (counter-clockwise)\n        int_bottom = (Fx[:-1, :-1] + Fx[:-1, 1:]) * dx / 2.0\n        int_right = (Fy[:-1, 1:] + Fy[1:, 1:]) * dy / 2.0\n        int_top = -(Fx[1:, :-1] + Fx[1:, 1:]) * dx / 2.0\n        int_left = -(Fy[:-1, :-1] + Fy[1:, :-1]) * dy / 2.0\n        \n        circulations = int_bottom + int_right + int_top + int_left\n        \n        cell_area = dx * dy\n        loop_densities = circulations / cell_area\n        rms_loop_density = np.sqrt(np.mean(loop_densities**2))\n\n    # 3. Finite-Difference Curl Diagnostic\n    if Nx  3 or Ny  3:\n        # Edge case: no interior nodes, use loop circulation density as per problem spec\n        rms_curl = rms_loop_density\n    else:\n        # Central difference for interior nodes\n        dFy_dx = (Fy[1:-1, 2:] - Fy[1:-1, :-2]) / (2 * dx)\n        dFx_dy = (Fx[2:, 1:-1] - Fx[:-2, 1:-1]) / (2 * dy)\n        curl_z = dFy_dx - dFx_dy\n        rms_curl = np.sqrt(np.mean(curl_z**2))\n\n    # 4. Path-Dependence Diagnostic\n    VA = np.zeros((Ny, Nx))\n    VB = np.zeros((Ny, Nx))\n\n    # Calculate VA: path along x-axis, then vertically\n    if Nx > 1:\n        integral_x_segments = (Fx[0, :-1] + Fx[0, 1:]) / 2.0 * dx\n        VA[0, 1:] = -np.cumsum(integral_x_segments)\n    if Ny > 1:\n        integral_y_segments = (Fy[:-1, :] + Fy[1:, :]) / 2.0 * dy\n        VA[1:, :] = VA[0, :] - np.cumsum(integral_y_segments, axis=0)\n\n    # Calculate VB: path along y-axis, then horizontally\n    if Ny > 1:\n        integral_y_segments = (Fy[:-1, 0] + Fy[1:, 0]) / 2.0 * dy\n        VB[1:, 0] = -np.cumsum(integral_y_segments)\n    if Nx > 1:\n        integral_x_segments = (Fx[:, :-1] + Fx[:, 1:]) / 2.0 * dx\n        # VB must be reshaped to add column vector to each column\n        VB[:, 1:] = VB[:, 0].reshape(-1, 1) - np.cumsum(integral_x_segments, axis=1)\n\n    path_difference = VA - VB\n    rms_path_diff = np.sqrt(np.mean(path_difference**2))\n    \n    # Return rounded results\n    return [\n        round(rms_curl, 6),\n        round(rms_path_diff, 6),\n        round(rms_loop_density, 6)\n    ]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3436066"}, {"introduction": "微正则系综（NVE）模拟的一个基石是总能量守恒，这正是力场为保守场（即可以从一个势能函数导出）的直接结果。本练习探讨了当这一原则被违背时的关键实际后果。通过在力场中引入一个微小的非保守分量，您将亲眼见证系统总能量如何随时间产生系统性的漂移。", "problem": "考虑一个质量为 $m$ 的单个粒子在二维空间中运动，其受到一个光滑标量势 $V(\\mathbf r)$ 的作用，其中 $\\mathbf r \\in \\mathbb{R}^2$。基本原理是牛顿第二定律、动能定理以及保守力的定义。在分子动力学代码中物理上实现的力场通常是保守力的一个近似，在本问题中，它被建模为\n$$\n\\tilde{\\mathbf F}(\\mathbf r) = -\\nabla V(\\mathbf r) + \\boldsymbol\\delta(\\mathbf r),\n$$\n其中 $\\boldsymbol\\delta(\\mathbf r)$ 是一个非保守力场，它不能由任何标量势能面导出。你将研究由 $\\boldsymbol\\delta(\\mathbf r)\\neq \\mathbf 0$ 导致的能量漂移、其随 $\\boldsymbol\\delta(\\mathbf r)$ 的大小和时间步长 $\\Delta t$ 的标度关系，并基于非保守功的计算实现一种校正。\n\n你必须编写一个完整的、可运行的程序，在二维空间中完全执行以下任务：\n1. 定义势能面\n$$\nV(\\mathbf r) = \\frac{k}{2}\\left(x^2 + y^2\\right),\n$$\n参数为 $m = 1$ 和 $k = 1$（约化单位）。将力的非保守微扰定义为\n$$\n\\boldsymbol\\delta(\\mathbf r) = \\alpha\\,\\mathbf R\\,\\mathbf r,\n$$\n其中 $\\alpha$ 是一个标量振幅，$\\mathbf r = (x,y)$，$\\mathbf R$ 是一个常数 $2\\times 2$ 矩阵\n$$\n\\mathbf R = \\begin{pmatrix}0  -1\\\\ 1  0\\end{pmatrix}.\n$$\n这个 $\\boldsymbol\\delta(\\mathbf r)$ 具有非零旋度，且不能表示为任何标量 $U$ 的 $-\\nabla U(\\mathbf r)$ 形式，这使其成为代表许多现实中力近似伪影的非保守误差。\n\n2. 使用速度-Verlet时间离散化方法，对总力 $\\tilde{\\mathbf F}(\\mathbf r)$ 以时间步长 $\\Delta t$ 传播轨迹，总物理时间为 $T$。使用固定的初始条件 $\\mathbf r(0) = (1,0)$ 和 $\\mathbf v(0) = (0,1)$，以及固定的参数 $m=1$ 和 $k=1$。所有量均使用约化单位。在每个离散步长 $n$ 记录总机械能\n$$\nE_n = \\frac{m}{2}\\|\\mathbf v_n\\|^2 + V(\\mathbf r_n),\n$$\n以约化能量单位表示。\n\n3. 对于给定的轨迹，通过对 $E_n$ 与 $t_n = n\\Delta t$ 进行普通最小二乘线性拟合来估算能量漂移率（单位为约化能量/约化时间），并报告拟合的斜率。这估算了在给定的积分和力模型下能量的系统性漂移。\n\n4. 通过定义一个校正后的能量，为非保守力实现一个功计算校正\n$$\nE_n^{\\mathrm{corr}} = E_n - W_n^{\\mathrm{nc}},\n$$\n其中 $W_n^{\\mathrm{nc}}$ 是对累积的非保守功的一个离散近似\n$$\nW^{\\mathrm{nc}}(t) = \\int_0^t \\mathbf v(\\tau)\\cdot \\boldsymbol\\delta(\\mathbf r(\\tau))\\,d\\tau.\n$$\n你必须在每一步使用梯形法则对这个积分进行数值近似，\n$$\nW_{n+1}^{\\mathrm{nc}} \\approx W_n^{\\mathrm{nc}} + \\Delta t\\,\\mathbf v_{n+\\frac{1}{2}}\\cdot \\boldsymbol\\delta(\\mathbf r_{n+\\frac{1}{2}}),\n$$\n其中中点为 $\\mathbf v_{n+\\frac{1}{2}} = \\frac{1}{2}(\\mathbf v_n + \\mathbf v_{n+1})$ 和 $\\mathbf r_{n+\\frac{1}{2}} = \\frac{1}{2}(\\mathbf r_n + \\mathbf r_{n+1})$。如步骤3所示，通过与 $t_n$ 进行线性拟合来估算 $E_n^{\\mathrm{corr}}$ 的漂移率。\n\n5. 为研究随非保守微扰的大小和时间步长的标度关系，请使用以下测试套件。所有测试均使用 $T=50$（约化时间单位）：\n   - 测试 A (基准保守): $\\alpha = 0$, $\\Delta t = 0.02$。\n   - 测试 B (非保守，粗步长): $\\alpha = 1\\times 10^{-3}$, $\\Delta t = 0.02$。\n   - 测试 C (非保守，细步长): $\\alpha = 1\\times 10^{-3}$, $\\Delta t = 0.01$。\n   - 测试 D (关于 $\\alpha$ 的线性度): $\\alpha = 2\\times 10^{-3}$, $\\Delta t = 0.02$。\n\n6. 你的程序必须产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序如下：\n   - 测试A的能量漂移斜率（浮点数，单位为约化能量/约化时间）。\n   - 测试B的能量漂移斜率（浮点数）。\n   - 测试C的能量漂移斜率（浮点数）。\n   - 测试D的能量漂移斜率（浮点数）。\n   - 斜率之比 $s_D/s_B$，用于评估关于 $\\alpha$ 的线性标度关系（浮点数，无单位）。\n   - 时间步长平方偏差系数的有限差分估计\n     $$\n     c_{\\Delta t^2} = \\frac{s_B - s_C}{(0.02)^2 - (0.01)^2}\n     $$\n     （浮点数，单位为约化能量/约化时间立方）。\n   - 测试B的校正后能量漂移斜率（浮点数）。\n   - 测试C的校正后能量漂移斜率（浮点数）。\n所有斜率都必须以约化能量/约化时间为单位表示。最终打印应严格为单行，格式为 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$，不含任何多余字符或空格。\n\n你的推导和代码必须仅从第一性原理和经过充分检验的事实出发，具体包括牛顿第二定律、动能和势能的定义以及动能定理。你不能引入或假设问题陈述中的任何最终目标公式。确保所有数值选择在科学上是一致的，并且只使用上面指定的参数值。程序必须是完全自包含的，并且不需要任何外部输入。", "solution": "该问题要求对一个粒子在二维空间中的动力学进行数值研究，该粒子在一个由保守谐振势和非保守旋转微扰组成的复合力场作用下运动。目标是实现一种数值积分方案，分析由此产生的能量漂移，并评估一种功计算校正方法。我们将使用速度-Verlet算法进行时间传播，并使用普通最小二乘回归来量化能量漂移率。\n\n### 理论框架\n\n**1. 运动方程**\n\n粒子质量为 $m=1$（约化单位）。其运动遵循牛顿第二定律：\n$$\nm \\frac{d^2\\mathbf{r}}{dt^2} = \\tilde{\\mathbf{F}}(\\mathbf{r})\n$$\n其中 $\\mathbf{r}(t) = (x(t), y(t))$ 是位置矢量，$\\tilde{\\mathbf{F}}(\\mathbf{r})$ 是总力。该力由一个从势 $V(\\mathbf{r})$ 导出的保守力与一个非保守微扰 $\\boldsymbol{\\delta}(\\mathbf{r})$ 之和给出：\n$$\n\\tilde{\\mathbf{F}}(\\mathbf{r}) = -\\nabla V(\\mathbf{r}) + \\boldsymbol{\\delta}(\\mathbf{r})\n$$\n势能是一个二维各向同性谐振子：\n$$\nV(\\mathbf{r}) = \\frac{k}{2}(x^2 + y^2)\n$$\n当参数 $k=1$ 时，保守力分量为：\n$$\n-\\nabla V(\\mathbf{r}) = -\\left(\\frac{\\partial V}{\\partial x}, \\frac{\\partial V}{\\partial y}\\right) = -(kx, ky) = (-x, -y) = -\\mathbf{r}\n$$\n非保守分量定义为：\n$$\n\\boldsymbol{\\delta}(\\mathbf{r}) = \\alpha \\mathbf{R} \\mathbf{r} = \\alpha \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\alpha \\begin{pmatrix} -y \\\\ x \\end{pmatrix}\n$$\n其中 $\\alpha$ 是一个标量振幅。该力场具有非零旋度 $\\nabla \\times \\boldsymbol{\\delta} = 2\\alpha \\, \\hat{\\mathbf{z}}$，证实了当 $\\alpha \\neq 0$ 时它是非保守的。\n\n综合这些，作用在粒子上的总力为：\n$$\n\\tilde{\\mathbf{F}}(x, y) = (-x - \\alpha y, -y + \\alpha x)\n$$\n\n**2. 功和能**\n\n总机械能 $E$ 是动能 $K$ 和势能 $V$ 的和：\n$$\nE = K + V = \\frac{1}{2} m \\|\\mathbf{v}\\|^2 + V(\\mathbf{r})\n$$\n其中 $\\mathbf{v} = d\\mathbf{r}/dt$ 是速度。能量随时间的变化率由总力所做的功率给出：\n$$\n\\frac{dE}{dt} = \\frac{d}{dt}\\left(\\frac{1}{2}m\\mathbf{v}\\cdot\\mathbf{v} + V(\\mathbf{r})\\right) = m\\mathbf{v}\\cdot\\frac{d\\mathbf{v}}{dt} + \\nabla V \\cdot \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} \\cdot (m\\ddot{\\mathbf{r}}) + \\mathbf{v}\\cdot\\nabla V\n$$\n代入 $m\\ddot{\\mathbf{r}} = \\tilde{\\mathbf{F}} = -\\nabla V + \\boldsymbol{\\delta}$：\n$$\n\\frac{dE}{dt} = \\mathbf{v} \\cdot (-\\nabla V + \\boldsymbol{\\delta}) + \\mathbf{v}\\cdot\\nabla V = -\\mathbf{v}\\cdot\\nabla V + \\mathbf{v}\\cdot\\boldsymbol{\\delta} + \\mathbf{v}\\cdot\\nabla V = \\mathbf{v}\\cdot\\boldsymbol{\\delta}\n$$\n总机械能的变化率等于非保守力所传递的功率。对时间从 $0$ 到 $t$ 积分，得到非保守系统的动能定理：\n$$\nE(t) - E(0) = \\int_0^t \\mathbf{v}(\\tau) \\cdot \\boldsymbol{\\delta}(\\mathbf{r}(\\tau)) d\\tau = W^{\\mathrm{nc}}(t)\n$$\n其中 $W^{\\mathrm{nc}}(t)$ 是非保守力所做的功。该方程表明，如果 $\\boldsymbol{\\delta} \\neq \\boldsymbol{0}$，机械能 $E$ 通常不守恒。\n\n**3. 数值积分：速度-Verlet算法**\n\n为了数值求解运动方程，我们使用速度-Verlet算法，这是一种时间可逆的辛积分器，以其在保守系统中的良好长期能量稳定性而闻名。给定在时间 $t_n = n\\Delta t$ 的状态 $(\\mathbf{r}_n, \\mathbf{v}_n)$，在 $t_{n+1}$ 的状态计算如下：\n1. 计算当前位置的力：$\\tilde{\\mathbf{F}}_n = \\tilde{\\mathbf{F}}(\\mathbf{r}_n)$。\n2. 将速度更新到半步：$\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2m} \\tilde{\\mathbf{F}}_n$。\n3. 将位置更新到完整步：$\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}$。\n4. 计算新位置的力：$\\tilde{\\mathbf{F}}_{n+1} = \\tilde{\\mathbf{F}}(\\mathbf{r}_{n+1})$。\n5. 将速度更新到完整步：$\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2m} \\tilde{\\mathbf{F}}_{n+1}$。\n\n**4. 能量漂移分析与校正**\n\n模拟将在时间 $t_n = n\\Delta t$ 处生成一系列能量值 $E_n = \\frac{m}{2}\\|\\mathbf{v}_n\\|^2 + V(\\mathbf{r}_n)$。我们通过对数据点 $(t_n, E_n)$ 进行普通最小二乘线性拟合来估算系统性能量漂移率 $s$，即求出最佳拟合线的斜率。\n\n为了补偿物理能量漂移，我们定义一个校正后的能量 $E^{\\mathrm{corr}}$。根据动能定理，我们有 $E(t) - W^{\\mathrm{nc}}(t) = E(0)$，这意味着量 $E^{\\mathrm{corr}}(t) = E(t) - W^{\\mathrm{nc}}(t)$ 应该是守恒的。我们计算一个离散的类似量 $E_n^{\\mathrm{corr}} = E_n - W_n^{\\mathrm{nc}}$，其中 $W_n^{\\mathrm{nc}}$ 是到步骤 $n$ 为止累积的非保守功。这个功是通过使用梯形法则对每个时间步 $[t_n, t_{n+1}]$ 上的积分求和增量贡献来计算的：\n$$\nW_{n+1}^{\\mathrm{nc}} = W_n^{\\mathrm{nc}} + \\Delta t \\, \\mathbf{v}_{n+1/2}^{\\mathrm{mid}} \\cdot \\boldsymbol{\\delta}(\\mathbf{r}_{n+1/2}^{\\mathrm{mid}})\n$$\n其中中点值定义为区间端点的平均值：\n$$\n\\mathbf{r}_{n+1/2}^{\\mathrm{mid}} = \\frac{1}{2}(\\mathbf{r}_n + \\mathbf{r}_{n+1}), \\quad \\mathbf{v}_{n+1/2}^{\\mathrm{mid}} = \\frac{1}{2}(\\mathbf{v}_n + \\mathbf{v}_{n+1})\n$$\n这个校正后能量的漂移率 $s^{\\mathrm{corr}}$ 也通过线性回归计算。$E^{\\mathrm{corr}}$ 中的任何残余漂移都可归因于Verlet算法中的数值误差以及功积分的梯形近似误差。\n\n### 计算步骤\n\n对于由特定 $(\\alpha, \\Delta t)$ 对定义的每个测试用例（A, B, C, D），我们将执行以下步骤：\n1. 设置初始条件 $\\mathbf{r}(0)=(1,0)$、$\\mathbf{v}(0)=(0,1)$ 和参数 $m=1, k=1$。\n2. 使用速度-Verlet算法模拟总时间 $T=50$ 的轨迹。\n3. 在每一步 $n$，计算并存储时间 $t_n$、总能量 $E_n$ 和校正后的能量 $E_n^{\\mathrm{corr}}$（如果适用）。\n4. 模拟结束后，对时间序列 $(t_n, E_n)$ 进行线性回归，以找到未校正的能量漂移斜率 $s$。\n5. 对于测试B和C，也对 $(t_n, E_n^{\\mathrm{corr}})$ 进行线性回归，以找到校正后的能量漂移斜率 $s^{\\mathrm{corr}}$。\n6. 最后，计算导出量：比率 $s_D/s_B$ 用于检查 $\\alpha$ 的线性度，以及系数 $c_{\\Delta t^2}$ 用于分析与时间步长相关的误差。结果将按指定顺序报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(alpha, dt, T, r0, v0, m, k, compute_corrected_energy):\n    \"\"\"\n    Runs a single particle simulation using the velocity-Verlet algorithm.\n\n    Args:\n        alpha (float): Amplitude of the non-conservative force.\n        dt (float): Time step.\n        T (float): Total simulation time.\n        r0 (np.ndarray): Initial position vector.\n        v0 (np.ndarray): Initial velocity vector.\n        m (float): Mass of the particle.\n        k (float): Spring constant of the potential.\n        compute_corrected_energy (bool): Flag to compute corrected energy.\n\n    Returns:\n        tuple: A tuple containing:\n            - slope (float): The drift slope of the uncorrected energy.\n            - corrected_slope (float): The drift slope of the corrected energy,\n                                      or 0.0 if not computed.\n    \"\"\"\n    num_steps = int(T / dt)\n    \n    # Define force functions\n    R_matrix = np.array([[0., -1.], [1., 0.]])\n    \n    def conservative_force(r):\n        return -k * r\n        \n    def non_conservative_force(r):\n        return alpha * np.dot(R_matrix, r)\n\n    def total_force(r):\n        return conservative_force(r) + non_conservative_force(r)\n        \n    def potential_energy(r):\n        return 0.5 * k * np.dot(r, r)\n        \n    # History arrays\n    t_hist = np.linspace(0, T, num_steps + 1)\n    E_hist = np.zeros(num_steps + 1)\n    E_corr_hist = np.zeros(num_steps + 1)\n\n    # Initial state\n    r = r0.copy()\n    v = v0.copy()\n    W_nc = 0.0\n\n    # Store initial energy\n    E_hist[0] = 0.5 * m * np.dot(v, v) + potential_energy(r)\n    E_corr_hist[0] = E_hist[0]\n\n    # Main integration loop\n    for i in range(num_steps):\n        # Velocity-Verlet Integration\n        F = total_force(r)\n        v_half = v + (0.5 * dt / m) * F\n        r_next = r + dt * v_half\n        F_next = total_force(r_next)\n        v_next = v_half + (0.5 * dt / m) * F_next\n        \n        # Calculate uncorrected energy at step i+1\n        E_hist[i+1] = 0.5 * m * np.dot(v_next, v_next) + potential_energy(r_next)\n        \n        # Calculate work correction and corrected energy\n        if compute_corrected_energy:\n            r_mid = 0.5 * (r + r_next)\n            v_mid = 0.5 * (v + v_next)\n            delta_F_mid = non_conservative_force(r_mid)\n            dW_nc = dt * np.dot(v_mid, delta_F_mid)\n            W_nc += dW_nc\n        \n        E_corr_hist[i+1] = E_hist[i+1] - W_nc\n        \n        # Update state for next iteration\n        r, v = r_next, v_next\n\n    # Perform linear regression to find slopes\n    slope = np.polyfit(t_hist, E_hist, 1)[0]\n    \n    corrected_slope = 0.0\n    if compute_corrected_energy:\n        corrected_slope = np.polyfit(t_hist, E_corr_hist, 1)[0]\n        \n    return slope, corrected_slope\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Fixed parameters\n    m = 1.0\n    k = 1.0\n    T = 50.0\n    r0 = np.array([1.0, 0.0])\n    v0 = np.array([0.0, 1.0])\n\n    # Test cases parameters: (alpha, dt)\n    params = {\n        'A': {'alpha': 0.0, 'dt': 0.02, 'correct': False},\n        'B': {'alpha': 1e-3, 'dt': 0.02, 'correct': True},\n        'C': {'alpha': 1e-3, 'dt': 0.01, 'correct': True},\n        'D': {'alpha': 2e-3, 'dt': 0.02, 'correct': False},\n    }\n\n    # Run simulations and store results\n    slopes = {}\n    corrected_slopes = {}\n    for test_name, p in params.items():\n        s, s_corr = run_simulation(p['alpha'], p['dt'], T, r0, v0, m, k, p['correct'])\n        slopes[test_name] = s\n        if p['correct']:\n            corrected_slopes[test_name] = s_corr\n\n    s_A = slopes['A']\n    s_B = slopes['B']\n    s_C = slopes['C']\n    s_D = slopes['D']\n    \n    # Calculate derived quantities\n    # 5. Ratio of slopes s_D/s_B\n    ratio_sD_sB = s_D / s_B if s_B != 0 else 0.0\n    \n    # 6. Finite-difference estimate of the timestep-squared bias coefficient\n    dt_B = params['B']['dt']\n    dt_C = params['C']['dt']\n    c_dt2 = (s_B - s_C) / (dt_B**2 - dt_C**2)\n    \n    # 7  8. Corrected energy drift slopes\n    s_B_corr = corrected_slopes['B']\n    s_C_corr = corrected_slopes['C']\n\n    # Assemble final results list\n    results = [\n        s_A,\n        s_B,\n        s_C,\n        s_D,\n        ratio_sD_sB,\n        c_dt2,\n        s_B_corr,\n        s_C_corr,\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3436106"}]}