{"hands_on_practices": [{"introduction": "在分子动力学模拟中，核心任务是精确地积分牛顿运动方程。速度Verlet算法因其时间可逆性、辛结构以及出色的长期能量守恒特性，已成为该领域的基石。本实践将通过为一个现实的分子振动模型——莫尔斯势(Morse potential)——实现速度Verlet积分器，来锻炼你的基本编程与分析能力。通过系统地研究能量误差如何依赖于积分时间步长，你将深入理解数值积分器的稳定性和精度，这是验证任何分子动力学代码正确性的关键一步[@problem_id:3401300]。", "problem": "考虑一个质量为 $m$ 的单个粒子在一维空间中在莫尔斯势下运动，莫尔斯势是双原子分子振动的标准模型。莫尔斯势 $V(r)$ 定义为\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2,\n$$\n其中 $D_e$ 是势阱深度（单位为焦耳），$a$ 是一个范围参数（单位为米$^{-1}$），$r_e$ 是平衡键长（单位为米）。该运动遵循牛顿第二定律，即 $m \\,\\ddot{r} = F(r)$，其中 $F(r) = -\\frac{dV}{dr}$，并且在精确动力学下，能量 $E(r, \\dot{r}) = \\frac{1}{2} m \\dot{r}^2 + V(r)$ 是守恒的。\n\n你的任务是编写一个完整的程序，该程序：\n- 实现速度 Verlet 积分器（不使用允许范围之外的外部库）来对上述系统进行动力学的时间演化。\n- 通过使用莫尔斯势最小值处的曲率，计算该最小值附近的最快小振幅振动角频率 $\\omega_{\\max}$，\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}}, \\quad k = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}.\n$$\n- 使用一组时间步长 $\\Delta t$，其构造为基频周期 $T = \\frac{2\\pi}{\\omega_{\\max}}$ 的分数 $s$，即 $\\Delta t = s\\,T$。\n- 对于每个时间步长，从初始位置 $r(0) = r_e + x_0$ 和初始速度 $\\dot{r}(0) = 0$ 开始，对动力学进行总时长为 $N_{\\text{periods}}$ 个完整周期的积分，其中 $x_0$ 是一个小位移，以保持系统在近谐振范围内。\n- 对于每个时间步长，报告在积分过程中达到的最大相对能量误差，其定义为\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le t \\le N_{\\text{periods}} T} \\frac{\\left|E(t) - E(0)\\right|}{E(0)}.\n$$\n\n使用以下参数值（国际单位制）：\n- $D_e = 3.0 \\,\\text{eV}$，使用 $1\\,\\text{eV} = 1.602176634 \\times 10^{-19}\\,\\text{J}$ 转换为焦耳，因此 $D_e = 3.0 \\times 1.602176634 \\times 10^{-19}\\,\\text{J}$，\n- $a = 2.0 \\times 10^{10}\\,\\text{m}^{-1}$，\n- $r_e = 1.0 \\times 10^{-10}\\,\\text{m}$，\n- $m = 1.0 \\times 10^{-26}\\,\\text{kg}$，\n- $x_0 = 2.0 \\times 10^{-12}\\,\\text{m}$，\n- $N_{\\text{periods}} = 50$。\n\n测试组规范（每个测试用例是一个 $s$ 值，该值定义了 $\\Delta t = s\\,T$）：\n- $s = 0.01$ (小时间步长)，\n- $s = 0.05$ (中等时间步长)，\n- $s = 0.10$ (较大时间步长)，\n- $s = 0.20$ (接近实际精度的极限)，\n- $s = \\frac{1.9}{2\\pi}$ (一个接近谐振稳定性阈值 $\\Delta t \\,\\omega \\approx 2$ 的边界情况)。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的浮点数列表，其顺序与上述测试组的顺序相同。例如，输出格式应为 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是对应 $s$ 值的最大相对能量误差 $\\varepsilon_{\\max}$。\n- 报告的值是无量纲的浮点数；输出中不需要物理单位。", "solution": "该问题是有效的，因为它在经典力学和计算物理学方面有科学依据，具有一套完整的参数和明确的目标，问题表述适定且客观。因此，我们可以着手解决。\n\n一个质量为 $m$ 的粒子在一维空间中的运动由莫尔斯势 $V(r)$ 控制，其表达式为：\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2\n$$\n在这里，$D_e$ 是势阱深度，$a$ 是一个控制势阱宽度的参数，$r_e$ 是对应于势能最小值的平衡位置。\n\n作用在粒子上的力 $F(r)$ 是势能的负梯度：\n$$\nF(r) = -\\frac{dV}{dr}\n$$\n使用链式法则，设 $u(r) = 1 - e^{-a(r-r_e)}$，我们有 $\\frac{dV}{dr} = \\frac{d(D_e u^2)}{du} \\frac{du}{dr}$。\n各导数分别为 $\\frac{d(D_e u^2)}{du} = 2D_e u = 2D_e(1 - e^{-a(r-r_e)})$ 和 $\\frac{du}{dr} = -e^{-a(r-r_e)}(-a) = a e^{-a(r-r_e)}$。\n将它们组合起来得到：\n$$\n\\frac{dV}{dr} = 2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)}\n$$\n因此，力为：\n$$\nF(r) = -2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)} = -2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right)\n$$\n\n对于平衡位置 $r_e$ 附近的小位移，该势可以近似为一个谐振势 $V(r) \\approx \\frac{1}{2} k (r-r_e)^2$，其中 $k$ 是劲度系数。该劲度系数由势在最小值处的曲率决定：\n$$\nk = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}\n$$\n对 $\\frac{dV}{dr}$ 的表达式求导：\n$$\n\\frac{d^2 V}{dr^2} = \\frac{d}{dr} \\left[ 2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right) \\right] = 2a D_e \\left( -a e^{-a(r-r_e)} - (-2a) e^{-2a(r-r_e)} \\right)\n$$\n$$\n\\frac{d^2 V}{dr^2} = 2a^2 D_e \\left( 2e^{-2a(r-r_e)} - e^{-a(r-r_e)} \\right)\n$$\n在 $r=r_e$ 处计算该式：\n$$\nk = 2a^2 D_e \\left( 2e^0 - e^0 \\right) = 2a^2 D_e (2 - 1) = 2a^2 D_e\n$$\n那么小振幅振荡的角频率为：\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{2a^2 D_e}{m}} = a\\sqrt{\\frac{2D_e}{m}}\n$$\n相应的振荡周期为 $T = \\frac{2\\pi}{\\omega_{\\max}}$。\n\n为了模拟动力学，我们采用速度 Verlet 积分算法。这是一种时间可逆的辛积分器，能够在长时间模拟中很好地保持总能量守恒。对于给定的时间步长 $\\Delta t$，位置 $r$、速度 $v$ 和加速度 $acc = F/m$ 按如下方式更新：\n1. 更新位置: $r(t + \\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2} acc(t) (\\Delta t)^2$\n2. 计算新的力和加速度: $F(t+\\Delta t)=F(r(t+\\Delta t))$ 以及 $acc(t+\\Delta t) = F(t+\\Delta t)/m$。\n3. 更新速度: $v(t + \\Delta t) = v(t) + \\frac{1}{2} \\left[ acc(t) + acc(t+\\Delta t) \\right] \\Delta t$\n\n模拟从初始条件 $r(0) = r_e + x_0$ 和 $\\dot{r}(0) = v(0) = 0$ 开始。初始总能量 $E(0)$ 完全是势能：\n$$\nE(0) = \\frac{1}{2} m v(0)^2 + V(r(0)) = V(r_e + x_0) = D_e \\left(1 - e^{-a x_0}\\right)^2\n$$\n模拟的总时长为 $N_{\\text{periods}}T$，使用的时间步长为 $\\Delta t = sT$。因此，积分步数为 $N_{\\text{steps}} = \\frac{N_{\\text{periods}} T}{sT} = \\frac{N_{\\text{periods}}}{s}$。在每一步 $i$，我们计算总能量 $E(t_i) = \\frac{1}{2} m v(t_i)^2 + V(r(t_i))$ 和相对能量误差 $\\varepsilon_i = \\frac{|E(t_i) - E(0)|}{E(0)}$。最终报告的量是在整个模拟过程中观察到的最大相对误差：\n$$\n\\varepsilon_{\\max} = \\max_{i} \\varepsilon_i\n$$\n\n对于每个给定的 $s$ 值，流程如下：\n1. 计算常数 $k$、$\\omega_{\\max}$ 和 $T$。\n2. 确定时间步长 $\\Delta t = sT$ 和总步数 $N_{\\text{steps}} = \\text{round}(N_{\\text{periods}}/s)$。\n3. 根据初始条件初始化位置 $r$、速度 $v$ 和加速度 $acc$。计算初始能量 $E(0)$。\n4. 循环 $N_{\\text{steps}}$ 次迭代，每一步应用速度 Verlet 更新规则。\n5. 在每次迭代中，计算当前能量 $E(t)$ 并更新观察到的最大相对误差 $\\varepsilon_{\\max}$。\n6. 循环结束后，$\\varepsilon_{\\max}$ 的最终值即为给定 $s$ 的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics problem for a particle in a Morse potential\n    using the velocity Verlet integrator and calculates the maximum relative\n    energy error for different timesteps.\n    \"\"\"\n\n    # --- Problem Parameters (SI units) ---\n    EV_TO_JOULE = 1.602176634e-19\n    D_e = 3.0 * EV_TO_JOULE  # Well depth (J)\n    a = 2.0e10               # Range parameter (m^-1)\n    r_e = 1.0e-10            # Equilibrium distance (m)\n    m = 1.0e-26              # Mass (kg)\n    x_0 = 2.0e-12            # Initial displacement (m)\n    N_periods = 50.0         # Number of periods to simulate\n\n    # --- Test Suite ---\n    # Each value 's' defines a timestep dt = s * T\n    s_values = [0.01, 0.05, 0.10, 0.20, 1.9 / (2 * np.pi)]\n\n    # --- Helper Functions for Physics ---\n    def potential(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the Morse potential energy.\"\"\"\n        return D_e_val * (1.0 - np.exp(-a_val * (r - r_e_val)))**2\n\n    def force(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the force derived from the Morse potential.\"\"\"\n        # This form is slightly more efficient as it computes exp once.\n        # F(r) = -2*a*D_e * (exp(-a(r-re)) - exp(-2a(r-re)))\n        exp_term = np.exp(-a_val * (r - r_e_val))\n        return -2.0 * a_val * D_e_val * (exp_term - exp_term**2)\n\n    def total_energy(r, v, m_val, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the total energy (kinetic + potential).\"\"\"\n        kinetic = 0.5 * m_val * v**2\n        potential_e = potential(r, D_e_val, a_val, r_e_val)\n        return kinetic + potential_e\n\n    # --- Derived Harmonic Quantities ---\n    # Stiffness k = d^2V/dr^2 at r=r_e\n    k = 2.0 * a**2 * D_e\n    # Harmonic angular frequency omega_max = sqrt(k/m)\n    omega_max = np.sqrt(k / m)\n    # Harmonic period T = 2*pi / omega_max\n    T = 2.0 * np.pi / omega_max\n\n    results = []\n\n    # --- Main Loop over Test Cases ---\n    for s in s_values:\n        # --- Simulation Setup ---\n        dt = s * T\n        num_steps = int(round(N_periods / s))\n\n        # --- Initial Conditions ---\n        r = r_e + x_0\n        v = 0.0\n        acc = force(r, D_e, a, r_e) / m\n\n        # --- Initial Energy Calculation ---\n        E0 = total_energy(r, v, m, D_e, a, r_e)\n        if E0 == 0:\n            # This case should not be reached with the given parameters\n            # but is a safeguard against division by zero.\n            max_rel_error = 0.0\n        else:\n            max_rel_error = 0.0\n\n            # --- Velocity Verlet Integration Loop ---\n            for _ in range(num_steps):\n                # 1. Update position\n                r = r + v * dt + 0.5 * acc * dt**2\n                \n                # 2. Calculate new force and acceleration\n                acc_new = force(r, D_e, a, r_e) / m\n                \n                # 3. Update velocity\n                v = v + 0.5 * (acc + acc_new) * dt\n                \n                # Update acceleration for the next step\n                acc = acc_new\n\n                # 4. Calculate energy drift\n                E_t = total_energy(r, v, m, D_e, a, r_e)\n                rel_error = np.abs((E_t - E0) / E0)\n                \n                # 5. Update maximum relative error\n                if rel_error > max_rel_error:\n                    max_rel_error = rel_error\n\n        results.append(max_rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.15e}' for err in results)}]\")\n\nsolve()\n\n```", "id": "3401300"}, {"introduction": "成功的分子动力学模拟不仅需要精确积分运动方程，还需要在特定热力学系综（如恒温恒容的NVT系综）下进行。本实践将引导你实现一种先进的积分方案——BAOAB分裂积分器，用于求解描述与热浴耦合的朗之万动力学方程。与仅关注能量守恒不同，本练习要求你分析该积分器的弱精度阶数以及在有限时间步长下对构型空间的采样准确性。通过这项实践，你将掌握现代随机积分器设计的核心思想，并理解如何确保模拟能够正确地复现系统的统计物理性质[@problem_id:3401323]。", "problem": "实现一个基于经典力学的分子动力学数值积分器，该积分器使用 BAOAB 分裂法推进谐振势中粒子的一维郎之万动力学。然后，通过分析不变构型方差，量化其在有限时间步长下对位置均值的弱精度阶以及构型采样精度。使用无量纲简化单位，其中玻尔兹曼常数等于 1，即设 $k_{\\mathrm{B}}=1$，并将所有量视为无量纲。不需要进行物理单位转换。\n\n该动力学由位置 $x(t)$ 和速度 $v(t)$ 的郎之万方程决定，描述了质量为 $m$ 的粒子在谐振势 $U(x)=\\tfrac{1}{2} k x^2$ 中运动，摩擦系数为 $\\gamma$，温度为 $T$：\n$$\nm \\,\\mathrm{d} v(t)= -\\nabla U\\bigl(x(t)\\bigr)\\,\\mathrm{d} t - \\gamma m\\, v(t)\\,\\mathrm{d} t + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T}\\,\\mathrm{d} W_t,\\qquad \\mathrm{d} x(t)= v(t)\\,\\mathrm{d} t,\n$$\n其中 $W_t$ 是标准维纳过程。在简化单位中，取 $k_{\\mathrm{B}}=1$，并将 $m$、$k$、$\\gamma$、$T$ 以及时间步长 $h$ 视为无量纲。\n\nBAOAB 分裂法在单个时间步长 $h$ 内包括以下子步骤序列：由保守力引起的半步动量更新（表示为 B），半步位置漂移（表示为 A），一个整步的随机 Ornstein–Uhlenbeck (OU) 恒温器用于速度（表示为 O），接着是另一个半步 A 和最后一个半步 B。具体来说，对于谐振力 $F(x)=-\\partial_x U(x)=-k x$，在一个时间步长 $h$ 内，子步骤按 $B\\to A\\to O\\to A\\to B$ 的顺序应用。你必须实现这个 BAOAB 传播算子。\n\n你的任务：\n\n$1.$ 均值位置的弱精度阶评估。对于固定的 $m$、$k$、$\\gamma$、$T$ 和初始条件 $(x_0,v_0)$，考虑在最终时间 $t_f$ 时 BAOAB 下的均值位置 $\\mathbb{E}[x(t_f)]$。随机 OU 噪声的期望为零，因此 BAOAB 下均值的演化可以通过将其随机 OU 子步骤替换为其无噪声的均值映射来获得。定义时间步长为 $h$ 的数值弱误差为\n$$\ne(h) = \\bigl|\\mathbb{E}[x_{h}(t_f)] - x_{\\mathrm{exact}}(t_f)\\bigr|,\n$$\n其中 $\\mathbb{E}[x_{h}(t_f)]$ 是使用大小为 $h$ 的步长通过 BAOAB 均值映射传播 $t_f$ 时间后的均值，而 $x_{\\mathrm{exact}}(t_f)$ 是从连续郎之万动力学得到的精确均值位置。由于 $\\mathbb{E}[W_t]=0$，精确均值满足确定性阻尼谐振子方程\n$$\nm \\ddot{x}(t) + \\gamma m \\dot{x}(t) + k x(t) = 0,\n$$\n并具有给定的初始条件 $(x_0,v_0)$。计算误差比\n$$\nR = \\frac{e(h)}{e(h/2)}\n$$\n用于测试套件中指定的两对时间步长。一个二阶弱方法应该产生 $R\\approx 4$。\n\n$2.$ 有限时间步长下的构型采样精度。BAOAB 积分器为 $(x_n,v_n)$ 定义了一个线性马尔可夫链，其中包含源自 OU 子步骤的仿射高斯噪声注入。对于谐振势，连续动力学的不变分布具有构型方差 $\\mathrm{Var}(x)=T/k$。BAOAB 链有一个不变协方差矩阵 $\\Sigma$，它解算离散李雅普诺夫方程\n$$\n\\Sigma = M \\Sigma M^\\top + Q,\n$$\n其中 $M$ 是一个完整 BAOAB 步骤对 $(x,v)$ 的 $2\\times 2$ 确定性均值映射，而 $Q$ 是来自一个步骤的 OU 噪声通过周围 A 和 B 子步骤传播后的 $2\\times 2$ 协方差贡献。通过使用线性代数（此部分不要使用蒙特卡洛采样）精确求解此离散李雅普诺夫方程来计算 $\\Sigma$（使用双精度），并报告绝对构型方差误差\n$$\n\\varepsilon_{\\mathrm{conf}} = \\bigl|\\Sigma_{11} - T/k\\bigr|,\n$$\n用于指定的参数集。\n\n实现说明和约束：\n\n- 仅使用郎之万动力学的基本陈述和 BAOAB 分裂描述。不要在问题陈述中使用任何预先推导的快捷公式。任何必要的公式都应在你的解决方案中从第一性原理推导。\n- 对于弱误差，请确保 $t_f$ 是 $h$ 的整数倍，以便采取整数步数。使用 BAOAB 均值映射传播均值，不进行噪声采样。\n- 对于不变协方差，构造单步仿射高斯映射，并通过向量化使用克罗内克积方法求解 $\\Sigma$ 的离散李雅普诺夫方程，即求解\n$$\n\\mathrm{vec}(\\Sigma) = \\bigl(I - M \\otimes M \\bigr)^{-1} \\mathrm{vec}(Q).\n$$\n\n测试套件和要求的输出：\n\n你的程序必须为下面的四个测试用例计算以下八个量，并将它们作为包含在方括号中的逗号分隔列表单行打印，顺序如下。列表元素为：\n\n$1.$ 对于测试 A（欠阻尼弱阶检验）：弱误差比 $R_A$（浮点数），后跟一个布尔值，指示 $R_A \\in [3.5, 4.5]$ 是否成立。\n\n$2.$ 对于测试 B（有限时间步长下的构型方差，中等阻尼）：绝对方差误差 $\\varepsilon_{\\mathrm{conf},B}$（浮点数），后跟一个布尔值，指示 $\\varepsilon_{\\mathrm{conf},B} \\le 10^{-12}$ 是否成立。\n\n$3.$ 对于测试 C（临界阻尼弱阶检验）：弱误差比 $R_C$（浮点数），后跟一个布尔值，指示 $R_C \\in [3.5, 4.5]$ 是否成立。\n\n$4.$ 对于测试 D（有限时间步长下的构型方差，过阻尼）：绝对方差误差 $\\varepsilon_{\\mathrm{conf},D}$（浮点数），后跟一个布尔值，指示 $\\varepsilon_{\\mathrm{conf},D} \\le 10^{-12}$ 是否成立。\n\n使用以下测试参数：\n\n- 测试 A（欠阻尼弱阶检验）：$m=1$，$k=1$，$\\gamma=0.5$，$T=1$，$(x_0,v_0)=(1,0)$，$t_f=10$，$h=0.08$ 和 $h/2=0.04$。\n\n- 测试 B（有限时间步长下的构型方差）：$m=1$，$k=3$，$\\gamma=0.5$，$T=2$，$h=0.4$。\n\n- 测试 C（临界阻尼弱阶检验）：$m=1$，$k=1$，$\\gamma=2$，$T=1$，$(x_0,v_0)=(1,1)$，$t_f=3$，$h=0.05$ 和 $h/2=0.025$。\n\n- 测试 D（过阻尼构型方差）：$m=1$，$k=1$，$\\gamma=5$，$T=1$，$h=0.1$。\n\n最终输出格式：\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序完全如下：\n$$\n\\bigl[ R_A,\\ \\text{bool}(R_A\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},B},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},B}\\le 10^{-12}),\\ R_C,\\ \\text{bool}(R_C\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},D},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},D}\\le 10^{-12}) \\bigr].\n$$", "solution": "该问题是有效的，因为它在科学上基于经典力学和统计力学，给出了所有必要的参数和明确的目标，并且其表述是客观的。我们将继续提供完整的解决方案。\n\n该问题要求实现和分析用于谐振势中一维郎之万动力学的 BAOAB 分裂积分器。我们被要求进行两个不同的分析：评估均值位置的弱精度阶，以及量化不变构型方差中的有限时间步长误差。所有计算均在无量纲简化单位中进行，玻尔兹曼常数 $k_{\\mathrm{B}}=1$。\n\n让粒子的状态由向量 $z(t) = (x(t), v(t))^\\top$ 表示。动力学由质量为 $m$ 的粒子在谐振势 $U(x) = \\frac{1}{2} k x^2$ 中的郎之万方程决定：\n$$\n\\begin{cases}\n\\mathrm{d}x(t) = v(t)\\,\\mathrm{d}t \\\\\nm\\,\\mathrm{d}v(t) = -k x(t)\\,\\mathrm{d}t - \\gamma m\\, v(t)\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t\n\\end{cases}\n$$\n力为 $F(x) = -\\nabla U(x) = -k x$。BAOAB 积分器将动力学分解为三个部分，并在一个时间步长 $h$ 内依次求解：\n- **B**: 在保守力作用下更新速度：$m\\,\\mathrm{d}v = F(x)\\,\\mathrm{d}t$。\n- **A**: 更新位置：$\\mathrm{d}x = v\\,\\mathrm{d}t$。\n- **O**: 在 Ornstein-Uhlenbeck (OU) 过程下更新速度：$m\\,\\mathrm{d}v = -\\gamma m v\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t$。\n\nBAOAB 方案按对称序列 B(h/2)、A(h/2)、O(h)、A(h/2)、B(h/2) 应用这些步骤。由于力是线性的，并且 OU 过程是线性的，每个子步骤都可以由一个矩阵算子表示。设 $z_n = (x_n, v_n)^\\top$ 为时间 $t_n$ 时的状态。\n\n**1. 子步骤传播算子的推导**\n\n**子步骤 B (力):** 在时长 $\\delta t = h/2$ 内对 $\\dot{v} = F(x)/m = - (k/m) x$ 进行积分，将 $x$ 视为常数（Verlet 方案）：\n$v_{n+1} = v_n - (k/m) x_n \\delta t$。位置 $x_n$ 不变。\n算子 $M_B$ 是：\n$$\nz \\mapsto M_B z, \\quad M_B = \\begin{pmatrix} 1  0 \\\\ - \\frac{k h}{2m}  1 \\end{pmatrix}\n$$\n\n**子步骤 A (漂移):** 在时长 $\\delta t = h/2$ 内对 $\\dot{x} = v$ 进行积分，将 $v$ 视为常数：\n$x_{n+1} = x_n + v_n \\delta t$。速度 $v_n$ 不变。\n算子 $M_A$ 是：\n$$\nz \\mapsto M_A z, \\quad M_A = \\begin{pmatrix} 1  \\frac{h}{2} \\\\ 0  1 \\end{pmatrix}\n$$\n\n**子步骤 O (恒温器):** OU 过程 $\\mathrm{d}v = -\\gamma v\\,\\mathrm{d}t + \\sqrt{2 \\gamma T/m}\\,\\mathrm{d}W_t$ 在时长 $h$ 内精确求解。位置 $x$ 不变。\n$v_{n+1} = v_n e^{-\\gamma h} + \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})} R_n$，其中 $R_n \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。\n这是一个仿射变换：\n$$\nz \\mapsto M_O z + \\xi_O, \\quad M_O = \\begin{pmatrix} 1  0 \\\\ 0  e^{-\\gamma h} \\end{pmatrix}, \\quad \\xi_O = \\begin{pmatrix} 0 \\\\ \\sigma_v R_n \\end{pmatrix}\n$$\n其中 $\\sigma_v = \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})}$。\n\n**完整 BAOAB 步骤:** 通过组合这些操作获得状态 $z_{n+1}$：\n$z_{n+1} = M_B(M_A(M_O(M_A(M_B z_n)) + \\xi_O))$。\n展开得到一个完整步骤的仿射映射：\n$$\nz_{n+1} = (M_B M_A M_O M_A M_B) z_n + (M_B M_A) \\xi_O = M z_n + \\xi\n$$\n其中 $M = M_B M_A M_O M_A M_B$ 是确定性均值映射，$\\xi = M_B M_A \\xi_O$ 是完整步骤的有效噪声向量。\n\n**任务 1: 弱精度阶评估**\n\n状态的均值 $\\bar{z}_n = \\mathbb{E}[z_n]$ 根据 $\\bar{z}_{n+1} = M \\bar{z}_n$ 演化，因为 $\\mathbb{E}[\\xi_O]=0$。从 $z_0 = (x_0, v_0)^\\top$ 开始，经过 $N = t_f/h$ 步后的均值状态为 $\\bar{z}_N = M^N z_0$。数值均值位置为 $\\mathbb{E}[x_h(t_f)] = (\\bar{z}_N)_1$。\n\n精确的均值动力学遵循确定性方程 $m \\ddot{x} + \\gamma m \\dot{x} + k x = 0$，或 $\\ddot{x} + \\gamma \\dot{x} + \\omega_0^2 x = 0$，其中 $\\omega_0^2 = k/m$。特征方程是 $r^2 + \\gamma r + \\omega_0^2 = 0$。解取决于判别式 $\\Delta = \\gamma^2 - 4\\omega_0^2$。\n- **欠阻尼 ($\\Delta  0$):** 测试 A ($m=1, k=1, \\gamma=0.5 \\implies \\Delta = -3.75$)。\n  解为 $x(t) = e^{-\\gamma t/2} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t))$，其中 $\\omega_d = \\sqrt{\\omega_0^2 - (\\gamma/2)^2}$。\n  给定 $(x_0, v_0)$，我们找到 $C_1 = x_0$ 和 $C_2 = (v_0 + \\gamma x_0/2)/\\omega_d$。\n- **临界阻尼 ($\\Delta = 0$):** 测试 C ($m=1, k=1, \\gamma=2 \\implies \\Delta = 0$)。\n  解为 $x(t) = (C_1 + C_2 t) e^{-\\gamma t/2}$。\n  给定 $(x_0, v_0)$，我们找到 $C_1 = x_0$ 和 $C_2 = v_0 + \\gamma x_0/2$。\n\n弱误差为 $e(h) = |\\mathbb{E}[x_h(t_f)] - x_{\\mathrm{exact}}(t_f)|$。一个弱精度阶为 $p$ 的方法具有 $e(h) \\propto h^p$。因此，比率 $R = e(h)/e(h/2)$ 应约等于 $2^p$。对于 BAOAB，这是一个二阶弱方法，我们期望 $R \\approx 4$。\n\n**任务 2: 构型采样精度**\n\nBAOAB 积分器生成一个线性马尔可夫链，其不变分布是具有某个协方差矩阵 $\\Sigma = \\mathbb{E}[(z-\\bar{z})(z-\\bar{z})^\\top]$ 的高斯分布。该矩阵是离散李雅普诺夫方程的平稳解：\n$$\n\\Sigma = M \\Sigma M^\\top + Q\n$$\n这里，$Q = \\mathbb{E}[\\xi \\xi^\\top]$ 是有效噪声向量 $\\xi = M_B M_A \\xi_O$ 的协方差矩阵。\n令 $C = M_B M_A$。噪声为 $\\xi = C \\xi_O$。\nOU 噪声的协方差为 $Q_O = \\mathbb{E}[\\xi_O \\xi_O^\\top] = \\mathrm{diag}(0, \\sigma_v^2)$。\n因此，$Q = C Q_O C^\\top$。\n这个李雅普诺夫方程可以通过向量化求解 $\\Sigma$。令 $\\sigma = \\mathrm{vec}(\\Sigma)$ 和 $q = \\mathrm{vec}(Q)$，其中 $\\mathrm{vec}(\\cdot)$ 将矩阵按列展平为向量。方程变为：\n$$\n\\sigma = (M \\otimes M)\\sigma + q\n$$\n其中 $\\otimes$ 是克罗内克积。这是一个关于 $\\sigma$ 的标准线性系统：\n$$\n(I - M \\otimes M)\\sigma = q \\implies \\sigma = (I - M \\otimes M)^{-1}q\n$$\n求解出向量 $\\sigma$ 后，将其重塑回 $2 \\times 2$ 的矩阵 $\\Sigma$。模拟得到的构型方差为 $\\Sigma_{11}$。\n\n对于连续动力学，不变分布是吉布斯-玻尔兹曼分布，其构型部分是方差为 $\\mathrm{Var}(x) = k_B T/k = T/k$ 的高斯分布。已知 BAOAB 方案对于线性力能精确地保持此构型边际分布。因此，绝对构型方差误差 $\\varepsilon_{\\mathrm{conf}} = |\\Sigma_{11} - T/k|$ 应接近机器精度，仅反映浮点运算误差。\n\n下面的 Python 代码实现了对指定测试用例的这些计算。它首先定义了用于计算 BAOAB 传播算子矩阵、阻尼谐振子的精确均值位置、通过传播算子计算的数值均值位置，以及通过求解李雅普诺夫方程计算不变协方差矩阵的函数。然后将这些函数应用于四个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_baoab_matrices(m, k, gamma, h):\n    \"\"\"\n    Constructs the matrix operators for the BAOAB substeps.\n    \n    Returns:\n        M_A (np.ndarray): Matrix for the A (position drift) substep.\n        M_B (np.ndarray): Matrix for the B (force) substep.\n        M_O (np.ndarray): Matrix for the O (thermostat) substep's mean map.\n    \"\"\"\n    # B step matrix for a timestep of h/2\n    M_B = np.array([[1, 0], [-k * h / (2 * m), 1]])\n    \n    # A step matrix for a timestep of h/2\n    M_A = np.array([[1, h / 2], [0, 1]])\n    \n    # O step matrix (mean map) for a timestep of h\n    M_O = np.array([[1, 0], [0, np.exp(-gamma * h)]])\n    \n    return M_A, M_B, M_O\n\ndef get_exact_mean_pos(m, k, gamma, x0, v0, tf):\n    \"\"\"\n    Computes the exact mean position for the damped harmonic oscillator.\n    \"\"\"\n    omega0_sq = k / m\n    delta = gamma**2 - 4 * omega0_sq\n\n    if np.abs(delta)  1e-15:  # Critically damped case\n        alpha = gamma / 2\n        c1 = x0\n        c2 = v0 + alpha * x0\n        x_exact = (c1 + c2 * tf) * np.exp(-alpha * tf)\n    elif delta  0:  # Underdamped case\n        alpha = gamma / 2\n        omega_d = np.sqrt(omega0_sq - alpha**2)\n        c1 = x0\n        c2 = (v0 + alpha * x0) / omega_d\n        x_exact = np.exp(-alpha * tf) * (c1 * np.cos(omega_d * tf) + c2 * np.sin(omega_d * tf))\n    else:  # Overdamped case\n        # Not needed for the specific test cases in this problem, but included for completeness.\n        sqrt_delta = np.sqrt(delta)\n        r1 = (-gamma + sqrt_delta) / 2\n        r2 = (-gamma - sqrt_delta) / 2\n        c2 = (v0 - r1 * x0) / (r2 - r1)\n        c1 = x0 - c2\n        x_exact = c1 * np.exp(r1 * tf) + c2 * np.exp(r2 * tf)\n        \n    return x_exact\n\ndef get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h):\n    \"\"\"\n    Computes the numerical mean position by propagating the mean map.\n    \"\"\"\n    if not np.isclose(tf % h, 0, atol=1e-9) and not np.isclose(tf % h, h, atol=1e-9):\n        raise ValueError(\"tf must be an integer multiple of h.\")\n    num_steps = int(round(tf / h))\n    \n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    \n    # Full BAOAB deterministic mean map M\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # Propagate for N steps\n    M_N = np.linalg.matrix_power(M, num_steps)\n    z0 = np.array([x0, v0])\n    zf = M_N @ z0\n    \n    return zf[0]\n\ndef calculate_weak_error_ratio(params):\n    \"\"\"\n    Calculates the weak error ratio R = e(h)/e(h/2).\n    \"\"\"\n    m, k, gamma, _, x0, v0, tf, h = params.values()\n    \n    x_exact = get_exact_mean_pos(m, k, gamma, x0, v0, tf)\n    \n    # Error for timestep h\n    x_num_h = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h)\n    e_h = np.abs(x_num_h - x_exact)\n    \n    # Error for timestep h/2\n    x_num_h2 = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h / 2)\n    e_h2 = np.abs(x_num_h2 - x_exact)\n    \n    if e_h2 == 0:\n        return np.inf if e_h != 0 else 1.0\n\n    return e_h / e_h2\n\ndef calculate_configurational_variance_error(params):\n    \"\"\"\n    Calculates the configurational variance error at finite timestep.\n    \"\"\"\n    m, k, gamma, T, h = params.values()\n    \n    # 1. Get the BAOAB mean map M\n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # 2. Get the noise covariance matrix Q\n    sigma_v_sq = (T / m) * (1 - np.exp(-2 * gamma * h))\n    Q_O = np.array([[0, 0], [0, sigma_v_sq]])\n    C = M_B @ M_A\n    Q = C @ Q_O @ C.T\n    \n    # 3. Solve the discrete Lyapunov equation using Kronecker product\n    dim = M.shape[0]\n    Id_kronsq = np.eye(dim**2)\n    M_kron_M = np.kron(M, M)\n    A_lyap = Id_kronsq - M_kron_M\n    \n    q_vec = Q.flatten('F') # Use Fortran order for vec operator\n    \n    sigma_vec = np.linalg.solve(A_lyap, q_vec)\n    \n    Sigma = sigma_vec.reshape((dim, dim), order='F')\n\n    # 4. Compute the error\n    Sigma_11 = Sigma[0, 0]\n    var_exact = T / k\n    error = np.abs(Sigma_11 - var_exact)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = {\n        'A': {'m': 1, 'k': 1, 'gamma': 0.5, 'T': 1, 'x0': 1, 'v0': 0, 'tf': 10, 'h': 0.08},\n        'B': {'m': 1, 'k': 3, 'gamma': 0.5, 'T': 2, 'h': 0.4},\n        'C': {'m': 1, 'k': 1, 'gamma': 2, 'T': 1, 'x0': 1, 'v0': 1, 'tf': 3, 'h': 0.05},\n        'D': {'m': 1, 'k': 1, 'gamma': 5, 'T': 1, 'h': 0.1},\n    }\n\n    results = []\n\n    # Test A: Weak order (underdamped)\n    params_A = test_cases['A']\n    R_A = calculate_weak_error_ratio(params_A)\n    results.append(R_A)\n    results.append(3.5 = R_A = 4.5)\n\n    # Test B: Configurational variance (moderate damping)\n    params_B = test_cases['B']\n    eps_conf_B = calculate_configurational_variance_error(params_B)\n    results.append(eps_conf_B)\n    results.append(eps_conf_B = 1e-12)\n\n    # Test C: Weak order (critical damping)\n    params_C = test_cases['C']\n    R_C = calculate_weak_error_ratio(params_C)\n    results.append(R_C)\n    results.append(3.5 = R_C = 4.5)\n\n    # Test D: Configurational variance (overdamped)\n    params_D = test_cases['D']\n    eps_conf_D = calculate_configurational_variance_error(params_D)\n    results.append(eps_conf_D)\n    results.append(eps_conf_D = 1e-12)\n    \n    # Format a boolean as a lowercase string \"true\" or \"false\" for printing\n    def format_bool(b):\n        return 'true' if b else 'false'\n\n    # Prepare string representations for each result item\n    str_results = []\n    for i, item in enumerate(results):\n        if isinstance(item, bool):\n            str_results.append(format_bool(item))\n        else:\n            str_results.append(str(item))\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3401323"}, {"introduction": "为了提高计算效率，在模拟中常需要固定分子内部某些自由度，例如高频振动的化学键，这便引出了约束动力学的问题。本实践在理论与实践之间架起了一座桥梁，要求你分析和比较两种处理约束的方法。一方面是源自哈密顿力学、理论上严谨优美的狄拉克括号(Dirac bracket)形式，另一方面是计算上更易于实现且广泛应用的SHAKE和RATTLE算法。通过对一个简单的双原子分子模型的分析，你将深入体会理论的完备性与算法的实用性之间的权衡，这是高级分子模拟方法开发中的一个核心主题[@problem_id:3401341]。", "problem": "考虑一个三维空间中的经典双粒子系统，其位置为 $r_1 \\in \\mathbb{R}^3$，$r_2 \\in \\mathbb{R}^3$，正则动量为 $p_1 \\in \\mathbb{R}^3$，$p_2 \\in \\mathbb{R}^3$，质量为 $m_10$，$m_20$。设哈密顿量为 $H(r_1,r_2,p_1,p_2)=\\frac{\\lVert p_1\\rVert^2}{2 m_1}+\\frac{\\lVert p_2\\rVert^2}{2 m_2}+U(r_1,r_2)$，其中 $U$ 是一个不依赖于时间的光滑势。施加一个完整约束，将原子间距固定为一个常数 $a0$，即 $\\phi(r_1,r_2)=\\lVert r_1-r_2\\rVert^2-a^2=0$。令 $R=r_1-r_2$ 并定义次级（速度级）约束 $\\psi(r_1,r_2,p_1,p_2)=R\\cdot\\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right)=0$，这是确保约束流形在动力学演化下保持不变所必需的。\n\n在 Dirac 约束哈密顿框架中，定义第二类约束集 $\\chi_1=\\phi$，$\\chi_2=\\psi$，标准正则泊松括号 $\\{f,g\\}=\\sum_{i=1}^{2}\\left(\\frac{\\partial f}{\\partial r_i}\\cdot\\frac{\\partial g}{\\partial p_i}-\\frac{\\partial f}{\\partial p_i}\\cdot\\frac{\\partial g}{\\partial r_i}\\right)$，$2\\times 2$ 约束矩阵 $C_{ij}=\\{\\chi_i,\\chi_j\\}$，以及 Dirac 括号 $\\{f,g\\}_D=\\{f,g\\}-\\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$，其中重复指标表示求和。精确的约束连续时间演化由哈密顿量 $H$ 通过泊松括号 $\\{\\cdot,\\cdot\\}_D$ 生成，并在所有时间内保持 $\\phi=0$ 和 $\\psi=0$。\n\n在计算分子动力学中，SHAKE 算法是一种位置校正方法，它在无约束更新后，通过迭代调整位置以满足 $\\phi=0$，从而在离散时间步上施加完整约束。RATTLE 算法增强了 SHAKE，它额外校正速度，以便在每一步结束时，位置和速度级约束都得到满足，例如，当与速度 Verlet 积分结合使用时。\n\n使用哈密顿力学、约束动力学的第一性原理以及上述定义，分析所述双原子约束下 Dirac 括号演化与 SHAKE 和 RATTLE 算法的几何和计算性质。下列哪个陈述是正确的？\n\nA. 在固定键长约束下，Dirac 括号演化将相对动量投影到约束流形的切空间上，精确地移除了径向分量，并保持了约束辛形式；因此，对于不依赖于时间的哈密顿量 $H$，连续时间能量是精确守恒的。\n\nB. 在与速度 Verlet 积分一起应用的标准仅位置 SHAKE 校正中，完整约束 $\\phi=0$ 在离散时间点上得到满足，但次级约束 $\\psi=0$ 通常不被强制执行；因此，径向动量分量可以保持非零，并且仅通过后续的位置校正被间接减小。\n\nC. RATTLE 算法在每一步将约束求解到机器精度时，会为完整约束产生一个辛性和时间可逆的离散映射；因此，它表现出有界的长期能量误差，但不精确守恒能量。\n\nD. 为此双原子约束计算 Dirac 括号需要在每一步对一个 $6\\times 6$ 矩阵求逆，这使得即使只有一个键长约束，其计算成本也渐进地高于 SHAKE 和 RATTLE。\n\nE. 对于双原子约束，Dirac 矩阵简化为一个标量，因此 Dirac 括号演化和 RATTLE 计算相同的拉格朗日乘子，这意味着这些方法在代数上是等价的，并且对于任何时间步长都会产生相同的离散轨迹。\n\n选择所有适用项。", "solution": "该问题陈述已被验证，并被认为是具有科学依据、良定且客观的。它呈现了高等经典力学和计算分子动力学中的一个标准场景，所有术语和形式体系都已正确定义。我们可以开始进行分析。\n\n系统由哈密顿量 $H=\\frac{\\lVert p_1\\rVert^2}{2 m_1}+\\frac{\\lVert p_2\\rVert^2}{2 m_2}+U(r_1,r_2)$ 描述，受一组第二类约束 $\\chi_1 = \\phi(r_1,r_2)=\\lVert r_1-r_2\\rVert^2-a^2=0$ 和 $\\chi_2 = \\psi(r_1,r_2,p_1,p_2)=R\\cdot\\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right)=0$ 的制约，其中 $R=r_1-r_2$。约束 $\\chi_2 = 0$ 源于要求 $\\chi_1$ 在时间演化中守恒，即 $\\dot{\\chi}_1 = \\{\\chi_1, H\\} = 0$。直接计算得出：\n$$\n\\{\\chi_1, H\\} = \\left\\{ \\lVert R \\rVert^2, \\frac{\\lVert p_1\\rVert^2}{2 m_1} + \\frac{\\lVert p_2\\rVert^2}{2 m_2} \\right\\} = \\sum_{k=1}^2 \\frac{\\partial \\lVert R \\rVert^2}{\\partial r_k} \\cdot \\frac{\\partial T}{\\partial p_k} = (2R) \\cdot \\frac{p_1}{m_1} + (-2R) \\cdot \\frac{p_2}{m_2} = 2 R \\cdot \\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right) = 2\\chi_2\n$$\n为了使 $\\dot{\\chi}_1=0$，我们必须强制 $\\chi_2=0$。约束 $(\\chi_1, \\chi_2)$ 是第二类的，因为它们的泊松括号矩阵 $C_{ij} = \\{\\chi_i, \\chi_j\\}$ 是可逆的。矩阵元素为 $C_{11}=\\{\\chi_1, \\chi_1\\}=0$，$C_{22}=\\{\\chi_2, \\chi_2\\}=0$，以及\n$$\nC_{12} = \\{\\chi_1, \\chi_2\\} = \\left\\{ \\lVert R \\rVert^2, R \\cdot \\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right) \\right\\} = \\sum_{k=1}^2 \\frac{\\partial \\chi_1}{\\partial r_k} \\cdot \\frac{\\partial \\chi_2}{\\partial p_k} = (2R) \\cdot \\frac{R}{m_1} + (-2R) \\cdot \\left(-\\frac{R}{m_2}\\right) = 2 \\lVert R \\rVert^2 \\left(\\frac{1}{m_1}+\\frac{1}{m_2}\\right)\n$$\n在约束流形 $\\lVert R \\rVert^2 = a^2$ 上，因此 $C_{12} = 2 a^2 (\\frac{1}{m_1}+\\frac{1}{m_2})$。由于 $m_1, m_2, a  0$，所以 $C_{12} \\neq 0$。矩阵 $C = \\begin{pmatrix} 0  C_{12} \\\\ -C_{12}  0 \\end{pmatrix}$ 的行列式是 $C_{12}^2 \\neq 0$，所以 $C$ 是可逆的。\n\n现在我们逐一分析每个选项。\n\n**A. 在固定键长约束下，Dirac 括号演化将相对动量投影到约束流形的切空间上，精确地移除了径向分量，并保持了约束辛形式；因此，对于不依赖于时间的哈密顿量 $H$，连续时间能量是精确守恒的。**\n约束 $\\chi_1 = \\lVert R \\rVert^2 - a^2 = 0$ 在相对坐标空间中定义了一个半径为 $a$ 的球面。在该流形上一点 $R$ 处的切空间是与 $R$ 正交的向量集合。约束 $\\chi_2=R\\cdot(\\dot{r}_1-\\dot{r}_2)=R\\cdot\\dot{R}=0$ 明确指出相对速度向量 $\\dot{R}$ 与相对位置向量 $R$ 正交。这意味着 $\\dot{R}$ 位于切空间内。由于相对动量与相对速度成正比（$p_{rel} = \\mu \\dot{R}$，其中 $\\mu$ 是约化质量），该约束强制相对动量的径向分量为零。根据其构造，Dirac 括号形式体系生成的动力学在所有时间都遵循所有第二类约束。所以该陈述的第一部分是正确的。\nDirac 括号在约束子流形上定义了一个泊松结构。相关的非退化2-形式是一个辛形式，根据 $\\dot{F}=\\{F,H\\}_D$ 的时间演化是一个保持此约束辛形式的哈密顿流。这是 Dirac 形式体系的一个基本结果。所以第二部分是正确的。\n对于不依赖于时间的哈密顿量 $H$，能量的变化由 $\\frac{dH}{dt} = \\{H, H\\}_D$ 给出。使用 Dirac 括号的定义，$\\{f,g\\}_D = \\{f,g\\} - \\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$：\n$$\n\\{H, H\\}_D = \\{H,H\\} - \\{H,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,H\\}\n$$\n第一项 $\\{H,H\\}=0$。因此表达式为：\n$$\n\\{H, H\\}_D = - \\begin{pmatrix} \\{H, \\chi_1\\}  \\{H, \\chi_2\\} \\end{pmatrix} \\frac{1}{C_{12}} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} \\{\\chi_1, H\\} \\\\ \\{\\chi_2, H\\} \\end{pmatrix}\n$$\n使用 $\\{H, \\chi_j\\} = -\\{\\chi_j, H\\}$，上式变为：\n$$\n\\{H, H\\}_D = - \\frac{1}{C_{12}} \\begin{pmatrix} -\\{\\chi_1, H\\}  -\\{\\chi_2, H\\} \\end{pmatrix} \\begin{pmatrix} -\\{\\chi_2, H\\} \\\\ \\{\\chi_1, H\\} \\end{pmatrix} = -\\frac{1}{C_{12}} ( \\{\\chi_1, H\\}\\{\\chi_2, H\\} - \\{\\chi_2, H\\}\\{\\chi_1, H\\} ) = 0\n$$\n因此，$\\frac{dH}{dt}=0$，能量精确守恒。该陈述的所有部分都与哈密顿力学的原理一致。\n**结论：正确。**\n\n**B. 在与速度 Verlet 积分一起应用的标准仅位置 SHAKE 校正中，完整约束 $\\phi=0$ 在离散时间点上得到满足，但次级约束 $\\psi=0$ 通常不被强制执行；因此，径向动量分量可以保持非零，并且仅通过后续的位置校正被间接减小。**\n速度 Verlet 算法包含以下步骤：\n1. 更新位置：$r(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2$。\n2. 应用 SHAKE：修改 $r(t+\\Delta t)$ 为 $r'(t+\\Delta t)$ 以满足 $\\phi(r'(t+\\Delta t))=0$。\n3. 计算新力/加速度：$a'(t+\\Delta t) = F(r'(t+\\Delta t))/m$。\n4. 更新速度：$v'(t+\\Delta t) = v(t) + \\frac{1}{2}(a(t)+a'(t+\\Delta t))\\Delta t$。\n关键点在于 SHAKE 仅校正位置。然后根据 $t$ 和 $t+\\Delta t$ 时刻的加速度，使用标准 Verlet 公式计算速度。此过程中没有步骤显式地投影速度 $v'(t+\\Delta t)$ 以满足速度级约束 $\\psi(t+\\Delta t) = R'(t+\\Delta t) \\cdot (\\frac{p'_1(t+\\Delta t)}{m_1} - \\frac{p'_2(t+\\Delta t)}{m_2}) = 0$。由于这个条件没有被强制执行，相对速度（和动量）的径向分量在一步结束时通常不为零。虽然强制 $\\phi(t)=0$ 和 $\\phi(t+\\Delta t)=0$ 意味着区间上的时间平均径向速度必须非常小，但这并不能保证在 $t+\\Delta t$ 时刻的瞬时径向速度为零。在 $t+2\\Delta t$ 时刻的后续 SHAKE 校正将防止粒子飞散，从而“间接减小”任何径向速度的影响，但它并没有在每一步都消除它。这个缺陷正是 RATTLE 算法旨在修复的。\n**结论：正确。**\n\n**C. RATTLE 算法在每一步将约束求解到机器精度时，会为完整约束产生一个辛性和时间可逆的离散映射；因此，它表现出有界的长期能量误差，但不精确守恒能量。**\nRATTLE 算法通过增加第二个校正步骤来扩展 SHAKE。在 SHAKE 位置校正和速度更新的第一半步之后，RATTLE 执行速度校正以强制执行速度级约束 $\\psi=0$。完整的带 RATTLE 的速度 Verlet 算法是：\n1. 速度半步：$v(t+\\Delta t/2) = v(t) + \\frac{1}{2}a(t)\\Delta t$。\n2. 位置全步：$r(t+\\Delta t) = r(t) + v(t+\\Delta t/2)\\Delta t$。\n3. 位置校正（SHAKE 部分）：求解拉格朗日乘子以调整 $r(t+\\Delta t)$ 来满足 $\\phi(t+\\Delta t)=0$。\n4. 速度校正（RATTLE 部分）：半步速度 $v(t+\\Delta t/2)$ 与校正后的位置不一致。首先计算不含约束力贡献的最终速度，然后求解另一组拉格朗日乘子来投影最终速度以满足 $\\psi(t+\\Delta t)=0$。\n该算法是一种几何积分器。从微分方程数值分析的文献中可知，RATTLE 是一种辛积分器。这意味着它精确地保持了约束相空间上辛2-形式的一个离散模拟。它在时间上也是对称构造的，这使其具有时间可逆性。辛积分器应用于哈密顿系统时的一个基本性质是，它们并不精确守恒原始哈密顿量 $H$。相反，它们精确守恒一个与 $H$ 相近的修正哈密顿量，或称“影子”哈密顿量 $H'$。这确保了原始能量的误差 $H(t)-H(0)$ 在非常长的模拟时间内保持有界，而不是表现出长期漂移。因此，RATTLE 以不精确守恒能量为代价，提供了出色的长期稳定性。\n**结论：正确。**\n\n**D. 为此双原子约束计算 Dirac 括号需要在每一步对一个 $6\\times 6$ 矩阵求逆，这使得即使只有一个键长约束，其计算成本也渐进地高于 SHAKE 和 RATTLE。**\nDirac 括号 $\\{f,g\\}_D = \\{f,g\\} - \\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$ 的计算需要对约束矩阵 $C_{ij} = \\{\\chi_i, \\chi_j\\}$ 求逆。该矩阵的大小由第二类约束的数量决定。对于给定的问题，我们有两个第二类约束，$\\chi_1 = \\phi$ 和 $\\chi_2 = \\psi$。因此，下标 $i, j$ 的取值范围是从 1 到 2，而 $C$ 是一个 $2 \\times 2$ 矩阵。必须对一个 $6 \\times 6$ 矩阵求逆的前提是错误的。数字 6 很可能源于与位置坐标数量（2 个粒子 $\\times$ 3 个维度）的混淆。由于前提是错误的，关于相对计算成本的结论是没有根据的。对一个 $2 \\times 2$ 矩阵求逆在计算上是微不足道的。\n**结论：不正确。**\n\n**E. 对于双原子约束，Dirac 矩阵简化为一个标量，因此 Dirac 括号演化和 RATTLE 计算相同的拉格朗日乘子，这意味着这些方法在代数上是等价的，并且对于任何时间步长都会产生相同的离散轨迹。**\n这个陈述包含几个错误。首先，如选项 D 的分析所确立的，约束矩阵 $C$（“Dirac 矩阵”）是一个 $2 \\times 2$ 矩阵，而不是一个标量。其次，Dirac 括号演化是关于精确的、*连续时间*动力学的形式体系。RATTLE 是一个生成近似*离散时间*轨迹的算法。对于任何有限的时间步长 $\\Delta t > 0$，离散时间近似在代数上不可能等同于精确的连续解。RATTLE 产生的轨迹仅在极限 $\\Delta t \\to 0$ 时才收敛于精确轨迹。第三，虽然两种方法在概念上都使用拉格朗日乘子，但在连续形式体系中，乘子是连续相空间变量的函数，而在 RATTLE 中，乘子是在每个离散步骤中为满足依赖于 $\\Delta t$ 的代数方程而计算出的数值。它们不是相同的量，也不会有相同的值。\n**结论：不正确。**", "answer": "$$\\boxed{ABC}$$", "id": "3401341"}]}