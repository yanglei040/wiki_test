{"hands_on_practices": [{"introduction": "本练习旨在帮助您巩固将离散的次模集函数转化为连续的凸正则项的理论基础。我们将从一个为重叠组结构设计的具体函数入手[@problem_id:3483776]，通过您的推导来验证其次模性，并构建其对应的Lovász扩展。通过这个过程，您将深入理解这些函数如何作为正则项在优化问题中发挥作用，并为后续的算法实践打下坚实的基础。", "problem": "考虑基集 $\\{1,2,3,4\\}$ 和重叠群 $G_{1}=\\{1,2,3\\}$ 与 $G_{2}=\\{2,4\\}$。定义集合函数 $F:2^{\\{1,2,3,4\\}}\\to\\mathbb{R}_{+}$ 如下：\n$$\nF(S)=3\\,\\mathbf{1}\\{S\\cap G_{1}\\neq\\emptyset\\}+2\\,\\mathbf{1}\\{S\\cap G_{2}\\neq\\emptyset\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 表示指示函数。仅使用子模性和 Lovász 扩展的核心定义，按以下步骤进行：\n\n1. 从子模性的定义出发，证明 $F$ 是一个非递减的子模函数，且 $F(\\emptyset)=0$。\n\n2. 从子模函数的 Lovász 扩展定义出发，推导 $F$ 的 Lovász 扩展 $f:\\mathbb{R}^{4}\\to\\mathbb{R}$，然后推导其对称范数 $\\|x\\|_{F}=f(|x|)$，并用 $x$ 的坐标直接表示。你的推导过程不能依赖于任何现成的公式；必须纯粹从应用于 $F$ 的 Lovász 扩展定义中推导出该表达式。\n\n3. 使用对偶范数 $\\|\\cdot\\|_{F}^{*}$ 的定义 $\\|z\\|_{F}^{*}=\\sup\\{z^{\\top}x:\\|x\\|_{F}\\leq 1\\}$，推导在 $z=(0,1,0,0)^{\\top}$ 这一特殊情况下的对偶范数 $\\|z\\|_{F}^{*}$。\n\n4. 写出以下无约束凸优化问题的 Karush-Kuhn-Tucker (KKT) 条件：\n$$\n\\min_{x\\in\\mathbb{R}^{4}}\\ \\frac{1}{2}\\|y-Ax\\|_{2}^{2}+\\lambda\\|x\\|_{F},\n$$\n其中 $A\\in\\mathbb{R}^{m\\times 4}$，$y\\in\\mathbb{R}^{m}$，且 $\\lambda0$；使用 $\\|x\\|_{F}$ 的次微分来指明平稳性条件。\n\n不要对任何数值进行四舍五入；给出精确表达式。将最终答案表示为步骤 3 中获得的对偶范数值的单个解析表达式。", "solution": "该问题是有效的，因为它是数学上适定的、自洽的，并且基于子模函数和凸优化的成熟理论。我们将按顺序解决问题的四个部分。\n\n基集为 $V = \\{1, 2, 3, 4\\}$，群为 $G_1 = \\{1, 2, 3\\}$ 和 $G_2 = \\{2, 4\\}$。集合函数 $F: 2^V \\to \\mathbb{R}_{+}$ 定义为 $F(S) = 3\\,\\mathbf{1}\\{S\\cap G_1 \\neq\\emptyset\\} + 2\\,\\mathbf{1}\\{S\\cap G_2 \\neq\\emptyset\\}$。\n\n1.  我们必须证明 $F$ 是一个非递减子模函数，并且 $F(\\emptyset) = 0$。\n\n首先，我们计算 $F$ 在空集 $\\emptyset$ 上的值：\n$$\nF(\\emptyset) = 3\\,\\mathbf{1}\\{\\emptyset \\cap G_1 \\neq \\emptyset\\} + 2\\,\\mathbf{1}\\{\\emptyset \\cap G_2 \\neq \\emptyset\\} = 3\\,\\mathbf{1}\\{\\emptyset \\neq \\emptyset\\} + 2\\,\\mathbf{1}\\{\\emptyset \\neq \\emptyset\\} = 3(0) + 2(0) = 0\n$$\n因此，确认 $F(\\emptyset)=0$。\n\n接下来，我们证明 $F$ 是非递减的。如果对于任意两个集合 $S \\subseteq T \\subseteq V$，都有 $F(S) \\leq F(T)$，则集合函数 $F$ 是非递减的。\n令 $S \\subseteq T$。对于任何群 $G_i$，如果 $S \\cap G_i \\neq \\emptyset$，那么必然有 $T \\cap G_i \\neq \\emptyset$，因为 $S \\cap G_i \\subseteq T \\cap G_i$。这意味着指示函数的值不会减小：对于 $i \\in \\{1, 2\\}$，有 $\\mathbf{1}\\{S \\cap G_i \\neq \\emptyset\\} \\leq \\mathbf{1}\\{T \\cap G_i \\neq \\emptyset\\}$。由于权重 $w_1 = 3$ 和 $w_2 = 2$ 是正数，我们可以写出：\n$$\nF(S) = 3\\,\\mathbf{1}\\{S \\cap G_1 \\neq \\emptyset\\} + 2\\,\\mathbf{1}\\{S \\cap G_2 \\neq \\emptyset\\} \\leq 3\\,\\mathbf{1}\\{T \\cap G_1 \\neq \\emptyset\\} + 2\\,\\mathbf{1}\\{T \\cap G_2 \\neq \\emptyset\\} = F(T)\n$$\n因此，$F$ 是一个非递减函数。\n\n最后，我们证明子模性。如果对于任意两个集合 $S, T \\subseteq V$，以下不等式成立：$F(S) + F(T) \\geq F(S \\cup T) + F(S \\cap T)$，则集合函数 $F$ 是子模的。\n函数 $F$ 是两个更简单的集合函数 $F_1$ 和 $F_2$ 的锥组合，$F(S) = 3 F_1(S) + 2 F_2(S)$。由于子模函数集合是一个凸锥，如果我们能证明 $F_1$ 和 $F_2$ 是子模的，那么 $F$ 也必然是子模的。\n我们来证明对于任意固定的群 $G \\subseteq V$，形如 $g(S) = \\mathbf{1}\\{S \\cap G \\neq \\emptyset\\}$ 的一般函数是子模的。我们需要证明 $g(S) + g(T) \\geq g(S \\cup T) + g(S \\cap T)$。\n令 $A = S \\cap G$ 和 $B = T \\cap G$。不等式变为：\n$$\n\\mathbf{1}\\{A \\neq \\emptyset\\} + \\mathbf{1}\\{B \\neq \\emptyset\\} \\geq \\mathbf{1}\\{(S \\cup T) \\cap G \\neq \\emptyset\\} + \\mathbf{1}\\{(S \\cap T) \\cap G \\neq \\emptyset\\}\n$$\n使用集合运算的分配律，$(S \\cup T) \\cap G = (S \\cap G) \\cup (T \\cap G) = A \\cup B$，以及 $(S \\cap T) \\cap G = (S \\cap G) \\cap (T \\cap G) = A \\cap B$。因此不等式为：\n$$\n\\mathbf{1}\\{A \\neq \\emptyset\\} + \\mathbf{1}\\{B \\neq \\emptyset\\} \\geq \\mathbf{1}\\{A \\cup B \\neq \\emptyset\\} + \\mathbf{1}\\{A \\cap B \\neq \\emptyset\\}\n$$\n我们分情况检验：\n- 情况1：$A = \\emptyset$ 且 $B = \\emptyset$。则 $A \\cup B = \\emptyset$ 且 $A \\cap B = \\emptyset$。不等式为 $0 + 0 \\geq 0 + 0$，成立。\n- 情况2：$A \\neq \\emptyset$ 且 $B = \\emptyset$。则 $A \\cup B = A \\neq \\emptyset$ 且 $A \\cap B = \\emptyset$。不等式为 $1 + 0 \\geq 1 + 0$，成立。$A = \\emptyset$ 且 $B \\neq \\emptyset$ 的情况是对称的。\n- 情况3：$A \\neq \\emptyset$ 且 $B \\neq \\emptyset$。则 $A \\cup B \\neq \\emptyset$。不等式为 $1 + 1 \\geq 1 + \\mathbf{1}\\{A \\cap B \\neq \\emptyset\\}$。这可以简化为 $1 \\geq \\mathbf{1}\\{A \\cap B \\neq \\emptyset\\}$，由于指示函数最大为 $1$，所以该式恒成立。\n由于不等式在所有情况下都成立，所以函数 $g(S)$ 是子模的。因此 $F_1(S)$ 和 $F_2(S)$ 是子模的，所以 $F(S)$ 也是子模的。\n\n2.  我们推导 $F$ 的 Lovász 扩展 $f:\\mathbb{R}^4 \\to \\mathbb{R}$，以及相应的对称范数 $\\|x\\|_F = f(|x|)$。\n\n对于一个子模函数 $F$ 且 $F(\\emptyset)=0$，其 Lovász 扩展可以为一个向量 $u \\in \\mathbb{R}_+^n$ 定义，方法是将其分量排序为 $u_{\\pi(1)} \\ge u_{\\pi(2)} \\ge \\dots \\ge u_{\\pi(n)} \\ge u_{\\pi(n+1)} = 0$。该扩展由下式给出：\n$$\nf(u) = \\sum_{i=1}^{n} (u_{\\pi(i)} - u_{\\pi(i+1)}) F(S_i)\n$$\n其中 $S_i = \\{\\pi(1), \\dots, \\pi(i)\\}$。Lovász 扩展关于 $F$ 是线性的，所以对于 $F = 3F_1 + 2F_2$，其扩展为 $f(u) = 3f_1(u) + 2f_2(u)$，其中 $f_i$ 是 $F_i(S) = \\mathbf{1}\\{S \\cap G_i \\neq \\emptyset\\}$ 的 Lovász 扩展。\n\n我们来推导对于一般函数 $F_G(S) = \\mathbf{1}\\{S \\cap G \\neq \\emptyset\\}$ 和 $u \\in \\mathbb{R}_+^n$，其 Lovász 扩展 $f_G$ 的形式。\n$$\nf_G(u) = \\sum_{i=1}^{n} (u_{\\pi(i)} - u_{\\pi(i+1)}) \\mathbf{1}\\{S_i \\cap G \\neq \\emptyset\\}\n$$\n令 $k$ 为使得 $S_i$ 与 $G$ 的交集非空的第一个索引 $i$。这意味着 $\\pi(k) \\in G$，但对于所有 $j  k$，都有 $\\pi(j) \\notin G$。对于所有 $i \\ge k$，$S_i \\supseteq S_k$，因此 $S_i \\cap G \\neq \\emptyset$ 且 $\\mathbf{1}\\{S_i \\cap G \\neq \\emptyset\\} = 1$。对于 $i  k$，指示函数为 $0$。该和式变成一个伸缩级数：\n$$\nf_G(u) = \\sum_{i=k}^{n} (u_{\\pi(i)} - u_{\\pi(i+1)}) = (u_{\\pi(k)} - u_{\\pi(k+1)}) + \\dots + (u_{\\pi(n)} - u_{\\pi(n+1)}) = u_{\\pi(k)} - u_{\\pi(n+1)} = u_{\\pi(k)}\n$$\n分量 $u_{\\pi(k)}$ 是所有索引 $j$ 在群 $G$ 中的分量 $u_j$ 中的最大值。因此，$f_G(u) = \\max_{j \\in G} u_j$。\n\n将此结果应用于我们的函数 $F$ 和向量 $u \\in \\mathbb{R}_+^4$：\n$f(u) = 3 f_1(u) + 2 f_2(u) = 3 \\max_{j \\in G_1} u_j + 2 \\max_{j \\in G_2} u_j$。\n对于 $G_1 = \\{1, 2, 3\\}$ 和 $G_2 = \\{2, 4\\}$，我们有：\n$f(u) = 3 \\max(u_1, u_2, u_3) + 2 \\max(u_2, u_4)$。\n\n对称范数 $\\|x\\|_F$ 定义为在 $x$ 各分量绝对值组成的向量上计算的 Lovász 扩展，即 $\\|x\\|_F = f(|x|)$，其中 $|x| = (|x_1|, |x_2|, |x_3|, |x_4|)^\\top$。\n$$\n\\|x\\|_F = 3 \\max(|x_1|, |x_2|, |x_3|) + 2 \\max(|x_2|, |x_4|)\n$$\n\n3.  我们推导 $z = (0, 1, 0, 0)^\\top$ 时的对偶范数 $\\|z\\|_F^*$。\n\n对偶范数定义为 $\\|z\\|_F^* = \\sup\\{z^\\top x : \\|x\\|_F \\leq 1\\}$。对于给定的 $z$，这变为：\n$$\n\\|z\\|_F^* = \\sup \\{ x_2 \\ : \\ 3 \\max(|x_1|, |x_2|, |x_3|) + 2 \\max(|x_2|, |x_4|) \\le 1 \\}\n$$\n我们想要在范数约束下最大化 $x_2$。为此，我们可以假设 $x_2  0$，所以 $|x_2| = x_2$。\n我们来找一个关于 $x_2$ 的上界。范数表达式包含两个含有 $|x_2|$ 的项。我们有以下不等式：\n$\\max(|x_1|, |x_2|, |x_3|) \\ge |x_2|$\n$\\max(|x_2|, |x_4|) \\ge |x_2|$\n使用这些不等式，我们可以建立范数 $\\|x\\|_F$ 的一个下界：\n$$\n\\|x\\|_F = 3 \\max(|x_1|, |x_2|, |x_3|) + 2 \\max(|x_2|, |x_4|) \\ge 3|x_2| + 2|x_2| = 5|x_2|\n$$\n因此，约束 $\\|x\\|_F \\le 1$ 意味着 $5|x_2| \\le 1$，即 $|x_2| \\le \\frac{1}{5}$。这就为 $x_2$ 提供了一个上界 $\\frac{1}{5}$。\n\n我们现在检查这个上界是否可达。为了最大化 $x_2$，我们应该使其他分量 $|x_1|, |x_3|, |x_4|$ 尽可能小，以放宽范数约束。我们设 $x_1 = 0$，$x_3 = 0$，$x_4 = 0$。约束变为：\n$$\n3 \\max(0, |x_2|, 0) + 2 \\max(|x_2|, 0) \\le 1\n$$\n假设 $x_2  0$：\n$$\n3x_2 + 2x_2 \\le 1 \\implies 5x_2 \\le 1 \\implies x_2 \\le \\frac{1}{5}\n$$\n$x_2$ 的最大值是 $\\frac{1}{5}$，在点 $x = (0, \\frac{1}{5}, 0, 0)^\\top$ 处达到。这个值与我们推导出的上界相符。\n因此，上确界是 $\\frac{1}{5}$。\n\n4.  我们写出该优化问题的 Karush-Kuhn-Tucker (KKT) 条件。\n\n问题是 $\\min_{x\\in\\mathbb{R}^{4}}\\ \\frac{1}{2}\\|y-Ax\\|_{2}^{2}+\\lambda\\|x\\|_{F}$。\n令目标函数为 $L(x) = g(x) + h(x)$，其中 $g(x) = \\frac{1}{2}\\|y-Ax\\|_{2}^{2}$ 是光滑且凸的，而 $h(x) = \\lambda\\|x\\|_{F}$ 是凸但非光滑的。这是一个无约束凸优化问题。其充要最优性条件（平稳性）是零向量必须属于目标函数在极小值点 $x^*$ 处的次微分：\n$$\n0 \\in \\partial L(x^*)\n$$\n使用次微分的和法则，由于 $g(x)$ 是可微的，该法则在此适用：\n$$\n\\partial L(x^*) = \\nabla g(x^*) + \\partial h(x^*)\n$$\n最小二乘项 $g(x) = \\frac{1}{2}(y-Ax)^\\top(y-Ax)$ 的梯度是：\n$$\n\\nabla g(x) = -A^\\top(y-Ax) = A^\\top(Ax-y)\n$$\n范数项 $h(x) = \\lambda\\|x\\|_{F}$ 的次微分是：\n$$\n\\partial h(x) = \\lambda \\partial \\|x\\|_F\n$$\n结合以上两点，在解 $x^*$ 处的最优性条件是：\n$$\n0 \\in A^\\top(Ax^*-y) + \\lambda \\partial \\|x^*\\|_F\n$$\n这可以重写为 $A^\\top(y-Ax^*) \\in \\lambda \\partial \\|x^*\\|_F$。令 $s$ 为一个次梯度向量，$s \\in \\partial \\|x^*\\|_F$。那么条件就是 $A^\\top(y-Ax^*) = \\lambda s$。\n次微分 $\\partial \\|x^*\\|_F$ 是用对偶范数 $\\|\\cdot\\|_F^*$ 来定义的：\n$$\n\\partial \\|x^*\\|_F = \\{ v \\in \\mathbb{R}^4 \\mid \\|v\\|_F^* \\le 1 \\text{ and } v^\\top x^* = \\|x^*\\|_F \\}\n$$\n因此，完整的 KKT 条件是存在一个向量 $s \\in \\mathbb{R}^4$，使得在极小值点 $x^*$ 处：\n1. 平稳性：$A^\\top(y-Ax^*) = \\lambda s$\n2. 次梯度条件：$\\|s\\|_F^* \\leq 1$ 且 $s^\\top x^* = \\|x^*\\|_F$。\n这些条件完全刻画了解 $x^*$。", "answer": "$$\n\\boxed{\\frac{1}{5}}\n$$", "id": "3483776"}, {"introduction": "在理论上理解了Lovász扩展的构造之后，下一步关键技能是高效地计算它。本练习将指导您为一个在机器学习中非常重要的层级树结构正则项实现其Lovász扩展的贪心算法[@problem_id:3483792]。通过将数学定义转化为实际代码，您将掌握如何处理这类复杂的结构化稀疏模型，并为在优化算法中调用它做好准备。", "problem": "考虑一个定义在包含$p$个叶节点的基集上的分层树结构次模集函数。基集为$\\{0,1,\\dots,p-1\\}$，其中$p=8$。一个有根二叉树有$15$个节点，索引为$\\{0,1,\\dots,14\\}$，其中叶节点索引为$\\{0,1,2,3,4,5,6,7\\}$，内部节点索引为$\\{8,9,10,11,12,13,14\\}$。父子关系如下：\n- 节点$8$的子节点为$0$和$1$。\n- 节点$9$的子节点为$2$和$3$。\n- 节点$10$的子节点为$4$和$5$。\n- 节点$11$的子节点为$6$和$7$。\n- 节点$12$的子节点为$8$和$9$。\n- 节点$13$的子节点为$10$和$11$。\n- 节点$14$是根节点，其子节点为$12$和$13$。\n\n为所有节点分配非负权重$\\{w_v\\}_{v=0}^{14}$：\n- 叶节点权重：$w_0=0.5$, $w_1=1.0$, $w_2=0.8$, $w_3=1.2$, $w_4=0.7$, $w_5=0.6$, $w_6=0.9$, $w_7=1.1$。\n- 内部节点权重：$w_8=1.5$, $w_9=1.3$, $w_{10}=1.4$, $w_{11}=1.6$, $w_{12}=2.0$, $w_{13}=2.2$, $w_{14}=3.0$。\n\n定义次模、单调的覆盖函数$F:\\,2^{\\{0,\\dots,7\\}}\\to\\mathbb{R}_+$为\n$F(S)=\\sum_{v=0}^{14} w_v \\,\\mathbf{1}\\{S\\cap \\text{Leaves}(\\text{subtree}(v))\\neq \\emptyset\\}$，\n其中$\\text{Leaves}(\\text{subtree}(v))$表示以节点$v$为根的子树中的叶节点集合，而$\\mathbf{1}\\{\\cdot\\}$是指示集合$S$与该子树相交的指示函数。\n\n令$F$的Lovász扩展（LE），表示为$\\hat{F}:\\mathbb{R}^p\\to\\mathbb{R}$，是定义在向量$x\\in\\mathbb{R}^p$上的凸扩展。您的任务是实现$\\hat{F}(x)$的贪心计算，该计算通过对坐标进行排序并累加与次梯度生成一致的边际增益，且专门针对上述分层函数$F$。该计算必须：\n- 通过按非递增值对$x$的索引进行排序来定义一个集合链。\n- 遍历排序后的顺序；当添加一个叶节点索引$i$时，边际增益等于$i$的祖先节点（包括$i$本身）的权重$w_v$之和，这些祖先节点的子树尚未被先前添加的叶节点覆盖。\n- 通过将这些边际增益与排序顺序中$x$的相应坐标进行加权求和来累加该值。\n\n您必须实现一个程序，在给定上述固定树和权重的情况下，为以下每个测试用例计算$\\hat{F}(x)$：\n- 测试用例$1$（一般情况）：$x^{(1)}=[0.9,\\,0.1,\\,0.4,\\,0.3,\\,0.7,\\,0.2,\\,0.05,\\,0.8]$。\n- 测试用例$2$（包含负坐标和零坐标）：$x^{(2)}=[1.0,\\,-0.5,\\,0.0,\\,0.0,\\,-0.2,\\,0.3,\\,-0.1,\\,0.6]$。\n- 测试用例$3$（均匀坐标）：$x^{(3)}=[0.5,\\,0.5,\\,0.5,\\,0.5,\\,0.5,\\,0.5,\\,0.5,\\,0.5]$。\n- 测试用例$4$（单个非零项）：$x^{(4)}=[0.0,\\,0.0,\\,0.0,\\,2.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0]$。\n\n您的程序必须为每个测试用例计算一个浮点数，等于$\\hat{F}(x^{(t)})$，并按顺序进行。不涉及物理单位。角度单位不适用。不涉及百分比。\n\n您必须确保排序是稳定的，以便确定性地解决平局问题。除了计算值之外，您的实现必须与一个主要成本为排序的算法保持一致，并且您必须确保每个测试用例的计算都遵循上述贪心过程，除了评估分层覆盖更新外，不使用任何专门的预言机。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。输出必须是浮点数。在对相等值进行排序时，请包含稳定的排序顺序，以确保跨次运行的可复现性。\n\n设计您的方法，使得每个向量$x$的算法复杂度为排序的$O(p\\log p)$加上沿祖先路径的线性时间覆盖更新，并在解决方案中对此进行评论。正确性必须遵循次模性和Lovász扩展的基本定义，并且您的方法不得依赖任何未从这些定义中推导出的捷径恒等式。", "solution": "该问题要求计算定义在基集$V = \\{0, 1, \\dots, 7\\}$上的特定分层次模集函数$F$的Lovász扩展，表示为$\\hat{F}(x)$。函数$F$和向量$x \\in \\mathbb{R}^8$定义在包含$p=8$个元素的基集上，这些元素是给定二叉树的叶节点。\n\n首先，我们将问题的各个组成部分形式化。树中所有节点的集合是$\\mathcal{N} = \\{0, 1, \\dots, 14\\}$，其中节点$\\{0, \\dots, 7\\}$是叶节点（我们的基集$V$），节点$\\{8, \\dots, 14\\}$是内部节点。每个节点$v \\in \\mathcal{N}$都有一个非负权重$w_v \\ge 0$。对于任何子集$S \\subseteq V$，分层覆盖函数$F: 2^V \\to \\mathbb{R}_+$定义为：\n$$\nF(S) = \\sum_{v \\in \\mathcal{N}} w_v \\, \\mathbf{1}\\{S \\cap L(v) \\neq \\emptyset\\}\n$$\n其中$L(v)$是以节点$v$为根的子树中的叶节点集合，而$\\mathbf{1}\\{\\cdot\\}$是指示函数。该函数是非负加权的集合覆盖型函数的和，已知这类函数是单调的（对于$A \\subseteq B$有$F(A) \\le F(B)$）和次模的（对于$A \\subseteq B \\subseteq V \\setminus \\{i\\}$有$F(A \\cup \\{i\\}) - F(A) \\ge F(B \\cup \\{i\\}) - F(B)$）。函数值$F(S)$表示所有被集合$S$中至少一个元素“覆盖”的子树的总权重。由于所有权重$w_v$都是非负的且$F(\\emptyset) = 0$，这是一个表现良好的次模函数。\n\nLovász扩展（或Choquet积分）$\\hat{F}: \\mathbb{R}^p \\to \\mathbb{R}$是集合函数$F$到连续域上的凸扩展。对于一个向量$x \\in \\mathbb{R}^p$，其值可以通过贪心算法计算。设$\\pi$是索引$\\{0, \\dots, p-1\\}$的一个排列，它将$x$的分量按非递增顺序排序：\n$$\nx_{\\pi(1)} \\ge x_{\\pi(2)} \\ge \\dots \\ge x_{\\pi(p)}\n$$\n这个排序定义了一个嵌套集合链$S_0 = \\emptyset \\subset S_1 \\subset \\dots \\subset S_p = V$，其中$S_k = \\{\\pi(1), \\pi(2), \\dots, \\pi(k)\\}$。Lovász扩展的值由以下公式给出：\n$$\n\\hat{F}(x) = \\sum_{k=1}^{p} (x_{\\pi(k)} - x_{\\pi(k+1)}) F(S_k)\n$$\n其中我们定义$x_{\\pi(p+1)} = 0$。通过重新整理求和项并利用$F(S_0)=F(\\emptyset)=0$的事实，此公式等价于问题中指定的公式：\n$$\n\\hat{F}(x) = \\sum_{k=1}^{p} x_{\\pi(k)} (F(S_k) - F(S_{k-1})) = \\sum_{k=1}^{p} x_{\\pi(k)} \\Delta_{\\pi(k)}\n$$\n其中$\\Delta_{\\pi(k)} = F(S_k) - F(S_{k-1})$是将元素$\\pi(k)$添加到集合$S_{k-1}$中的边际增益。\n\n任务的核心是在贪心算法的每一步高效地计算这个边际增益$\\Delta_{\\pi(k)}$。对于我们特定的分层函数$F$，将一个叶节点$i = \\pi(k)$添加到集合$S = S_{k-1}$中的边际增益是：\n$$\n\\Delta_{i} = F(S \\cup \\{i\\}) - F(S) = \\sum_{v \\in \\mathcal{N}} w_v \\left[ \\mathbf{1}\\{(S \\cup \\{i\\}) \\cap L(v) \\neq \\emptyset\\} - \\mathbf{1}\\{S \\cap L(v) \\neq \\emptyset\\} \\right]\n$$\n只有当$v$处的子树未被$S$覆盖但被$S \\cup \\{i\\}$覆盖时，括号内的项才非零（等于$1$）。这当且仅当$i \\in L(v)$且$S \\cap L(v) = \\emptyset$时发生。由于$i$是一个叶节点，$i \\in L(v)$意味着$v$是$i$的一个祖先节点（包括$i$本身）。条件$S \\cap L(v) = \\emptyset$意味着$v$处的子树尚未被任何先前添加的元素覆盖。\n因此，边际增益是$i$的所有祖先节点的权重之和，这些祖先节点的子树是首次被覆盖。\n\n这引出了以下算法：\n1.  **初始化**：\n    *   存储树结构。一个父指针数组`parents`即可，其中`parents[v]`给出节点`v`的父节点。\n    *   将节点权重$w_v$存储在一个数组中。\n    *   对于给定的输入向量$x \\in \\mathbb{R}^p$，为$i \\in \\{0, \\dots, p-1\\}$创建索引-值对$(i, x_i)$的列表。\n    *   将总值$\\hat{F}(x)$初始化为$0$。\n    *   初始化一个大小为$|\\mathcal{N}|=15$的布尔数组`is_covered`为`False`，用于跟踪哪些子树已被覆盖。\n\n2.  **排序**：按$x_i$的降序对索引-值对进行排序。问题要求使用稳定排序来确定性地处理平局。\n\n3.  **贪心累加**：遍历排序后的对$(i, x_i)$：\n    a. 对于当前值为$x_i = x_{\\pi(k)}$的叶节点$i = \\pi(k)$，计算其边际增益$\\Delta_i$。\n    b. 初始化$\\Delta_i = 0$。\n    c. 使用父指针从叶节点$i$向上遍历树至根节点。设此遍历中的当前节点为$v$，从$v=i$开始。\n    d. 在此路径上的每个节点$v$，检查`is_covered[v]`。\n    e. 如果`is_covered[v]`为`False`，意味着这是第一次处理来自子树$L(v)$的元素。将其权重$w_v$加到$\\Delta_i$上，并设置`is_covered[v] = True`。\n    f. 如果`is_covered[v]`为`True`，则该子树已被覆盖。继续到父节点，不添加权重。\n    g. 到达根节点的遍历完成后，添加叶节点$i$的总边际增益$\\Delta_i$已计算完毕。\n    h. 更新Lovász扩展的总值：$\\hat{F}(x) \\leftarrow \\hat{F}(x) + x_i \\cdot \\Delta_i$。\n\n4.  **最终确定**：遍历完所有元素后，累加的和即为最终值$\\hat{F}(x)$。\n\n该算法的计算复杂度主要由排序步骤决定，为$O(p \\log p)$。主循环运行$p$次。在循环内部，对于一个平衡二叉树，祖先遍历需要$O(\\log p)$步。因此，总复杂度为$O(p \\log p + p \\log p) = O(p \\log p)$，这很高效且满足问题的约束。`is_covered`数组的使用正确地实现了计算边际增益的逻辑，而无需在每一步重新评估整个函数$F$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the Lovász extension of a hierarchical submodular function for given test cases.\n    \"\"\"\n    # Problem setup: Ground set size, tree structure, and weights\n    p = 8  # Number of leaves\n    num_nodes = 15\n\n    # Parent-child relationships define the tree structure.\n    # We use a parent array where parents[i] is the parent of node i.\n    # The root's parent is marked as -1.\n    parents = [-1] * num_nodes\n    parents[0] = 8\n    parents[1] = 8\n    parents[2] = 9\n    parents[3] = 9\n    parents[4] = 10\n    parents[5] = 10\n    parents[6] = 11\n    parents[7] = 11\n    parents[8] = 12\n    parents[9] = 12\n    parents[10] = 13\n    parents[11] = 13\n    parents[12] = 14\n    parents[13] = 14\n    # Root is node 14, parents[14] remains -1\n\n    # Node weights {w_v} for v=0..14\n    weights = np.zeros(num_nodes)\n    # Leaf weights\n    weights[0] = 0.5; weights[1] = 1.0; weights[2] = 0.8; weights[3] = 1.2\n    weights[4] = 0.7; weights[5] = 0.6; weights[6] = 0.9; weights[7] = 1.1\n    # Internal weights\n    weights[8] = 1.5; weights[9] = 1.3; weights[10] = 1.4; weights[11] = 1.6\n    weights[12] = 2.0; weights[13] = 2.2; weights[14] = 3.0\n\n    # Test cases for x\n    test_cases = [\n        np.array([0.9, 0.1, 0.4, 0.3, 0.7, 0.2, 0.05, 0.8]),\n        np.array([1.0, -0.5, 0.0, 0.0, -0.2, 0.3, -0.1, 0.6]),\n        np.array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]),\n        np.array([0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 0.0])\n    ]\n\n    def compute_lovasz_extension(x, parents, weights):\n        \"\"\"\n        Computes the Lovász extension of the hierarchical function F for a vector x.\n        The algorithm's complexity is O(p log p) due to sorting, followed by a linear\n        scan with O(log p) work per step for ancestor traversal.\n        \"\"\"\n        # Step 1: Sort indices by the values of x in non-increasing order.\n        # Python's `sorted` is stable, which handles ties as required.\n        # We create pairs of (index, value) from x.\n        indexed_x = sorted(enumerate(x), key=lambda item: item[1], reverse=True)\n\n        # Step 2: Initialize for greedy accumulation\n        total_value = 0.0\n        is_covered = [False] * len(weights)\n\n        # Step 3: Iterate through sorted elements and accumulate weighted marginal gains\n        for leaf_idx, x_val in indexed_x:\n            marginal_gain = 0.0\n            \n            # Walk up the tree from the current leaf to the root\n            current_node = leaf_idx\n            while current_node != -1:\n                # If the subtree at current_node is not yet covered, it contributes\n                # its weight to the marginal gain.\n                if not is_covered[current_node]:\n                    marginal_gain += weights[current_node]\n                    is_covered[current_node] = True\n                \n                # Move to the parent node\n                current_node = parents[current_node]\n\n            # Accumulate the total value\n            total_value += x_val * marginal_gain\n            \n        return total_value\n\n    results = []\n    for x_test in test_cases:\n        result = compute_lovasz_extension(x_test, parents, weights)\n        results.append(result)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.10g}' for r in results)}]\")\n\nsolve()\n```", "id": "3483792"}, {"introduction": "这个最终练习将前面所学的理论和计算知识融会贯通，应用于解决一个完整的结构化稀疏优化问题。您将推导在机器学习领域广泛应用的近端梯度算法（ISTA和FISTA），并学习如何高效计算这些算法的核心步骤——次模正则项的近端算子[@problem_id:3483796]。通过这个练习，您将看到次模函数如何与强大的优化框架结合，解决实际的信号恢复或特征选择问题。", "problem": "考虑一个由次模函数产生的带有结构化稀疏性诱导正则化项的复合凸最小化问题。给定 $A \\in \\mathbb{R}^{m \\times n}$ 和 $b \\in \\mathbb{R}^{m}$，并设 $f:2^{\\{1,\\dots,n\\}} \\to \\mathbb{R}_{+}$ 为一个归一化的（$f(\\varnothing)=0$）、非递减的（单调的）次模集函数，其 Lovász 扩展为 $\\hat{f}:\\mathbb{R}^{n} \\to \\mathbb{R}_{+}$。考虑目标函数\n$$\nF(x) \\triangleq \\frac{1}{2}\\|A x - b\\|_{2}^{2} + \\lambda \\,\\hat{f}(x),\n$$\n其中 $\\lambda0$。\n\n任务：\n1. 仅使用凸可微性、梯度 Lipschitz 连续性和近端算子的定义，从第一性原理推导迭代收缩阈值算法 (ISTA) 和快速迭代收缩阈值算法 (FISTA) 的更新规则。你的推导必须从具有 $L$-Lipschitz 梯度的光滑函数的二次上界以及凸函数的近端映射的定义开始。\n2. 对于一个通用的单调次模函数 $f$，说明如何高效地计算 Lovász 扩展的近端算子，并用与 $f$ 相关的多面体上的投影来表示。陈述将近端算子求值简化为欧几里得投影的关键几何关系，并明确指出该多面体。\n3. 现在，专门考虑一种基于基数的单调次模函数 $f$，其定义为 $f(S) = \\sum_{k=1}^{|S|} v_{k}$，其中权重非递增，$v_{1} \\geq v_{2} \\geq \\dots \\geq v_{n} \\geq 0$。在这种情况下，Lovász 扩展是有序加权 $\\ell_{1}$ 范数 $\\hat{f}(x) = \\sum_{k=1}^{n} v_{k} |x|_{(k)}$，其中 $|x|_{(1)} \\geq \\dots \\geq |x|_{(n)}$ 表示 $x$ 的绝对值条目的递减重排。解释在 $\\mathcal{O}(n \\log n)$ 时间内得到任意 $y \\in \\mathbb{R}^{n}$ 的近端算子 $\\mathrm{prox}_{\\lambda \\hat{f}}(y)$ 的排序与保序回归过程，并详细说明池邻违规者算法 (pool-adjacent-violators algorithm) 的作用。\n\n最后，考虑一个具体实例，其中 $n=m=3$，$A=I_{3}$，$\\lambda=1$，权重 $v=(2,1,0.5)$，以及 $b=(3,1,-2)^{\\top}$。从 $x^{0}=0$ 开始，执行一次 ISTA 迭代，步长等于 $\\nabla \\left(\\frac{1}{2}\\|Ax-b\\|_{2}^{2}\\right)$ 的 Lipschitz 常数的倒数。将结果 $x^{1}$ 以一个 $1 \\times 3$ 的行矩阵的形式表示。无需四舍五入，且不涉及物理单位。", "solution": "该问题是良定的，在凸优化领域具有科学依据，并为获得唯一解提供了所有必要信息。因此，该问题被认为是有效的。\n\n要最小化的目标函数具有复合形式 $F(x) = g(x) + h(x)$，其中：\n- $g(x) = \\frac{1}{2}\\|A x - b\\|_{2}^{2}$ 是一个光滑、凸且可微的函数。\n- $h(x) = \\lambda \\,\\hat{f}(x)$ 是一个凸函数，但通常不可微。因为 $f$ 是一个归一化的、非递减的次模集函数，其 Lovász 扩展 $\\hat{f}$ 是凸的。由于 $\\lambda  0$，$h(x)$ 也是凸的。\n\n**1. ISTA 和 FISTA 的推导**\n\n近端梯度方法背后的核心原理是通过对光滑部分 $g(x)$ 形成一个局部二次近似，同时保持非光滑部分 $h(x)$ 的精确性，来迭代地最小化目标函数。\n\n$g(x)$ 的梯度是 $\\nabla g(x) = A^{\\top}(Ax - b)$。为了使 $g(x)$ 的梯度具有 $L$-Lipschitz 连续性，对于某个常数 $L  0$，必须满足以下条件：\n$$\n\\|\\nabla g(x) - \\nabla g(y)\\|_{2} \\leq L\\|x-y\\|_{2} \\quad \\forall x, y \\in \\mathbb{R}^{n}\n$$\n计算梯度之差：\n$$\n\\|\\nabla g(x) - \\nabla g(y)\\|_{2} = \\|A^{\\top}(Ax - b) - A^{\\top}(Ay - b)\\|_{2} = \\|A^{\\top}A(x-y)\\|_{2} \\leq \\|A^{\\top}A\\|_{2} \\|x-y\\|_{2}\n$$\n其中 $\\|A^{\\top}A\\|_{2}$ 是 $A^{\\top}A$ 的谱范数。因此，最小的可能 Lipschitz 常数是 $L = \\|A^{\\top}A\\|_{2} = \\sigma_{\\max}(A)^2$，其中 $\\sigma_{\\max}(A)$ 是 $A$ 的最大奇异值。\n\n具有 $L$-Lipschitz 梯度的函数的一个基本性质是下降引理，它为函数提供了一个二次上界（一个上界函数）：\n$$\ng(x) \\leq g(x^{k}) + \\langle \\nabla g(x^{k}), x - x^{k} \\rangle + \\frac{L}{2}\\|x - x^{k}\\|_{2}^{2}\n$$\n在每次迭代 $k$ 中，我们通过最小化 $g(x)$ 的这个上界加上非光滑项 $h(x)$ 来找到下一个迭代点 $x^{k+1}$：\n$$\nx^{k+1} = \\underset{x}{\\arg\\min} \\left( g(x^{k}) + \\langle \\nabla g(x^{k}), x - x^{k} \\rangle + \\frac{L}{2}\\|x - x^{k}\\|_{2}^{2} + h(x) \\right)\n$$\n我们可以舍去相对于 $x$ 是常数的项（即 $g(x^k)$ 以及只涉及 $x^k$ 的项），并对剩下涉及 $x$ 的项进行配方：\n\\begin{align*}\nx^{k+1} = \\underset{x}{\\arg\\min} \\left( \\langle \\nabla g(x^{k}), x \\rangle + \\frac{L}{2}\\|x - x^{k}\\|_{2}^{2} + h(x) \\right) \\\\\n= \\underset{x}{\\arg\\min} \\left( \\frac{L}{2} \\|x\\|_{2}^{2} - L \\langle x, x^{k} \\rangle + \\langle \\nabla g(x^{k}), x \\rangle + h(x) \\right) \\\\\n= \\underset{x}{\\arg\\min} \\left( \\frac{L}{2} \\|x\\|_{2}^{2} - \\langle x, L x^{k} - \\nabla g(x^{k}) \\rangle + h(x) \\right) \\\\\n= \\underset{x}{\\arg\\min} \\left( \\frac{L}{2} \\left\\| x - \\left(x^{k} - \\frac{1}{L}\\nabla g(x^{k})\\right) \\right\\|_{2}^{2} + h(x) \\right)\n\\end{align*}\n这个最小化问题是参数为 $1/L$ 的 $h(x)$ 的近端算子的定义。凸函数 $\\phi$ 的近端算子定义为 $\\mathrm{prox}_{\\phi}(y) \\triangleq \\underset{x}{\\arg\\min} \\left( \\frac{1}{2}\\|x-y\\|_{2}^{2} + \\phi(x) \\right)$。\n在我们的情况下，目标函数等价于 $\\underset{x}{\\arg\\min} \\left( \\frac{1}{2}\\left\\| x - \\left(x^{k} - \\frac{1}{L}\\nabla g(x^{k})\\right) \\right\\|_{2}^{2} + \\frac{1}{L}h(x) \\right)$。\n令步长 $\\eta = 1/L$，则更新规则为：\n$$\nx^{k+1} = \\mathrm{prox}_{\\eta h}\\left(x^{k} - \\eta \\nabla g(x^{k})\\right)\n$$\n代入 $h(x) = \\lambda \\hat{f}(x)$，我们得到**迭代收缩阈值算法 (ISTA)** 的更新规则：\n$$\nx^{k+1} = \\mathrm{prox}_{\\eta \\lambda \\hat{f}}\\left(x^{k} - \\eta A^{\\top}(Ax^{k} - b)\\right)\n$$\n**快速迭代收缩阈值算法 (FISTA)** 引入了一个动量项来加速收敛。它在同一个近端梯度步骤上，但作用于一个外推点 $y^k$ 而不是前一个迭代点 $x^{k-1}$。更新规则如下：\n初始化 $x^0$，令 $y^1 = x^0$, $t_1 = 1$。对于 $k \\geq 1$：\n\\begin{enumerate}\n    \\item 在 $y^{k}$ 处执行近端梯度步骤：$x^{k} = \\mathrm{prox}_{\\eta \\lambda \\hat{f}}\\left(y^{k} - \\eta \\nabla g(y^{k})\\right)$\n    \\item 更新动量参数：$t_{k+1} = \\frac{1 + \\sqrt{1 + 4t_k^2}}{2}$\n    \\item 形成下一个外推点：$y^{k+1} = x^{k} + \\frac{t_k - 1}{t_{k+1}}(x^{k} - x^{k-1})$\n\\end{enumerate}\n\n**2. Lovász 扩展的近端算子**\n\n任务是计算 $\\mathrm{prox}_{\\gamma \\hat{f}}(y) = \\underset{x}{\\arg\\min} \\left( \\frac{1}{2}\\|x-y\\|_{2}^{2} + \\gamma \\hat{f}(x) \\right)$，其中 $\\gamma = \\eta\\lambda$。\n次模函数 $f$ 的 Lovász 扩展 $\\hat{f}(x)$ 可以表示为相关基多面体 $B(f)$ 的支撑函数，即 $\\hat{f}(x) = \\max_{s \\in B(f)} s^{\\top}x$。基多面体定义为：\n$$\nB(f) = \\left\\{ s \\in \\mathbb{R}^n \\mid \\sum_{i=1}^n s_i = f(\\{1,\\dots,n\\}), \\text{ and } \\forall S \\subseteq \\{1,\\dots,n\\}, \\sum_{i \\in S} s_i \\le f(S) \\right\\}\n$$\n将此代入近端问题，我们得到一个极小极大问题：\n$$\n\\mathrm{prox}_{\\gamma \\hat{f}}(y) = \\underset{x}{\\arg\\min} \\left( \\frac{1}{2}\\|x-y\\|_{2}^{2} + \\gamma \\max_{s \\in B(f)} s^{\\top}x \\right)\n$$\n由于目标函数在 $x$ 上是凸的，在 $s$ 上是凹的（线性的），且域 $B(f)$ 是紧的，我们可以交换 min 和 max 算子（根据 Sion 极小极大定理）：\n$$\n\\max_{s \\in B(f)} \\min_{x} \\left( \\frac{1}{2}\\|x-y\\|_{2}^{2} + \\gamma s^{\\top}x \\right)\n$$\n关于 $x$ 的内部最小化是无约束的。令梯度为零，得到 $x-y+\\gamma s = 0$，这意味着最小化点为 $x^*(s) = y - \\gamma s$。将此代回表达式：\n$$\n\\max_{s \\in B(f)} \\left( \\frac{1}{2}\\|(y - \\gamma s) - y\\|_{2}^{2} + \\gamma s^{\\top}(y - \\gamma s) \\right) = \\max_{s \\in B(f)} \\left( \\frac{\\gamma^2}{2}\\|s\\|_{2}^{2} + \\gamma s^{\\top}y - \\gamma^2 \\|s\\|_{2}^{2} \\right) = \\max_{s \\in B(f)} \\left( \\gamma s^{\\top}y - \\frac{\\gamma^2}{2}\\|s\\|_{2}^{2} \\right)\n$$\n找到最大化的 $s$ 等价于最小化其相反数：\n$$\n\\underset{s \\in B(f)}{\\arg\\min} \\left( \\frac{\\gamma^2}{2}\\|s\\|_{2}^{2} - \\gamma s^{\\top}y \\right) = \\underset{s \\in B(f)}{\\arg\\min} \\frac{\\gamma^2}{2} \\left\\| s - \\frac{y}{\\gamma} \\right\\|_{2}^{2}\n$$\n解（我们称之为 $s^*$）是向量 $y/\\gamma$ 在基多面体 $B(f)$ 上的欧几里得投影：\n$$\ns^* = \\mathrm{proj}_{B(f)}\\left(\\frac{y}{\\gamma}\\right)\n$$\n关键的几何关系是，近端问题的解 $x^*$ 由我们之前找到的原始-对偶关系给出：\n$$\nx^* = y - \\gamma s^* \\quad \\implies \\quad \\mathrm{prox}_{\\gamma \\hat{f}}(y) = y - \\gamma \\, \\mathrm{proj}_{B(f)}\\left(\\frac{y}{\\gamma}\\right)\n$$\n因此，计算 Lovász 扩展的近端算子被简化为在其对应的基多面体上的欧几里得投影。\n\n**3. 基于基数的函数的近端算子**\n\n对于特定情况 $f(S) = \\sum_{k=1}^{|S|} v_{k}$，其中 $v_{1} \\geq v_{2} \\geq \\dots \\geq v_{n} \\geq 0$，Lovász 扩展是有序加权 $\\ell_1$ 范数（也称为 OWL 范数）：$\\hat{f}(x) = \\sum_{k=1}^{n} v_{k} |x|_{(k)}$，其中 $|x|_{(k)}$ 是 $x$ 中条目绝对值的第 $k$ 大的值。\n\n我们需要计算 $x^* = \\mathrm{prox}_{\\lambda \\hat{f}}(y) = \\underset{x}{\\arg\\min} \\frac{1}{2}\\|x-y\\|_2^2 + \\lambda \\sum_{k=1}^n v_k |x|_{(k)}$。\n由于正则化项的对称性，解 $x^*$ 必须满足对于 $y_i \\ne 0$ 有 $\\mathrm{sign}(x^*_i) = \\mathrm{sign}(y_i)$，并且解的绝对值的排序必须与 $y$ 的绝对值的排序相匹配。即，如果 $|y_i| \\ge |y_j|$，那么 $|x^*_i| \\ge |x^*_j|$。\n\n这允许我们先对 $y$ 的绝对值进行排序，然后在此基础上求解问题，最后重构解。过程如下：\n1.  令 $u = |y|$ 为 $y$ 的绝对值向量。令 $\\sigma = \\mathrm{sign}(y)$ 为符号向量。\n2.  找到一个排列 $\\pi$，使得 $u$ 按降序排列，即 $u_{\\pi(1)} \\ge u_{\\pi(2)} \\ge \\dots \\ge u_{\\pi(n)}$。令 $u_{\\text{sorted}} = (u_{\\pi(1)}, \\dots, u_{\\pi(n)})$。\n3.  关于排序后的非负解值 $z=(z_1, \\dots, z_n)$ 的优化问题变为：\n    $$\n    \\underset{z_1 \\ge \\dots \\ge z_n \\ge 0}{\\min} \\frac{1}{2}\\sum_{k=1}^n (z_k - u_{\\pi(k)})^2 + \\lambda \\sum_{k=1}^n v_k z_k\n    $$\n    这等价于找到一个向量在非负、非增向量锥上的投影。通过配方，目标函数可以重写为：\n    $$\n    \\underset{z_1 \\ge \\dots \\ge z_n \\ge 0}{\\min} \\frac{1}{2}\\sum_{k=1}^n (z_k - (u_{\\pi(k)} - \\lambda v_k))^2\n    $$\n4.  令 $c_k = u_{\\pi(k)} - \\lambda v_k$。我们希望找到在约束 $z_1 \\ge \\dots \\ge z_n \\ge 0$ 下最接近 $c=(c_1, \\dots, c_n)$ 的向量 $z$。这是一个带非负约束的保序回归问题。\n5.  这个问题分两步解决。首先，我们找到最接近 $c$ 的非增向量 $z'$。这是一个标准的保序回归问题，可以使用池邻违规者算法 (Pool-Adjacent-Violators Algorithm, PAVA) 在 $\\mathcal{O}(n)$ 时间内解决。PAVA 遍历向量 $c$。如果发现某个分量 $c_k$ 违反了非增顺序（即 $c_k  c_{k+1}$），它会将违反中涉及的分量块进行平均，并用该平均值替换该块中的每个分量。重复此过程，直到没有违规为止。\n6.  其次，施加非负约束 $z_k \\ge 0$。由于一个已经是非增向量在非负象限上的投影会保持其顺序，因此排序值的最终解为 $z_k = \\max(0, z'_k)$。\n7.  最终解 $x^*$ 通过重新应用排列和符号来重构：创建一个向量 $x'_{\\text{abs}}$ 使得对 $k=1, \\dots, n$ 有 $(x'_{\\text{abs}})_{\\pi(k)} = z_k$。然后最终结果是 $x^*_i = \\sigma_i (x'_{\\text{abs}})_i$。\n\n主要的计算成本是初始对 $|y|$ 的排序，这需要 $\\mathcal{O}(n \\log n)$ 的时间。\n\n**4. 具体实例计算**\n\n给定：$n=m=3$, $A=I_{3}$, $\\lambda=1$, $v=(2,1,0.5)$, $b=(3,1,-2)^{\\top}$, 以及 $x^{0}=(0,0,0)^{\\top}$。我们执行一次 ISTA 迭代。\n\n目标函数是 $F(x) = \\frac{1}{2}\\|x-b\\|_2^2 + \\hat{f}(x)$。\n光滑部分是 $g(x) = \\frac{1}{2}\\|x-b\\|_2^2$，其梯度为 $\\nabla g(x) = x-b$。\n$\\nabla g(x)$ 的 Lipschitz 常数是 $L = \\|I_3\\|_2 = 1$。\n步长是 $\\eta = 1/L = 1$。\n\n第一次 ISTA 迭代是：\n$x^{1} = \\mathrm{prox}_{\\eta \\lambda \\hat{f}}(x^0 - \\eta \\nabla g(x^0))$\n$x^{1} = \\mathrm{prox}_{1 \\cdot 1 \\cdot \\hat{f}}(x^0 - 1 \\cdot (x^0 - b)) = \\mathrm{prox}_{\\hat{f}}(b)$。\n我们需要计算 $\\mathrm{prox}_{\\hat{f}}((3,1,-2)^{\\top})$。令 $y=(3,1,-2)^{\\top}$。\n\n我们使用第 3 部分的程序：\n1.  绝对值：$u = |y| = (|3|, |1|, |-2|) = (3, 1, 2)$。\n    符号：$\\sigma = \\mathrm{sign}(y) = (1, 1, -1)$。\n2.  排序后的绝对值：$u$ 的排序值为 $(3, 2, 1)$。对应的原始索引为 $(1, 3, 2)$。所以， $|y|_{(1)} = 3$, $|y|_{(2)} = 2$, $|y|_{(3)} = 1$。\n3.  权重向量是 $v=(v_1, v_2, v_3) = (2, 1, 0.5)$。$\\lambda=1$。\n4.  形成向量 $c = (|y|_{(k)} - \\lambda v_k)_{k=1,2,3}$：\n    $c_1 = |y|_{(1)} - \\lambda v_1 = 3 - 1 \\cdot 2 = 1$。\n    $c_2 = |y|_{(2)} - \\lambda v_2 = 2 - 1 \\cdot 1 = 1$。\n    $c_3 = |y|_{(3)} - \\lambda v_3 = 1 - 1 \\cdot 0.5 = 0.5$。\n    所以，$c = (1, 1, 0.5)$。\n5.  执行保序回归。向量 $c$ 已经是非增的（$1 \\ge 1 \\ge 0.5$），所以 PAVA 返回 $c$ 本身。令此为 $z' = (1, 1, 0.5)$。\n6.  投影到非负锥上。$z'$ 的所有条目都是非负的，所以 $z=z'=(1, 1, 0.5)$。这是解的排序后绝对值向量。\n7.  重构解。排序值 $z$ 对应于原始索引 $(1, 3, 2)$。\n    - 最大绝对值 $z_1=1$ 对应于索引 $1$。\n    - 第二大绝对值 $z_2=1$ 对应于索引 $3$。\n    - 最小绝对值 $z_3=0.5$ 对应于索引 $2$。\n    所以，解的绝对值向量是 $|x^1| = (1, 0.5, 1)$。\n8.  应用符号 $\\sigma=(1, 1, -1)$：\n    $x^1_1 = 1 \\cdot 1 = 1$。\n    $x^1_2 = 1 \\cdot 0.5 = 0.5$。\n    $x^1_3 = -1 \\cdot 1 = -1$。\n一次 ISTA 迭代的结果是 $x^1 = (1, 0.5, -1)^{\\top}$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  0.5  -1\n\\end{pmatrix}\n}\n$$", "id": "3483796"}]}