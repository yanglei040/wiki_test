{"hands_on_practices": [{"introduction": "LASSO 解决方案路径 $x(\\lambda)$ 的一个基本特性是其分段线性。为了从根本上理解这一特性，我们必须首先分析其局部行为。这个练习将引导您推导在固定活动集上路径导数 $\\dot{x}_S(\\lambda)$ 的精确表达式，这是理解解如何在“事件”之间演变的数学核心 [@problem_id:3451804]。掌握这一分析技巧对于建立同伦方法的直觉至关重要。", "problem": "考虑参数化凸优化问题（最小绝对收缩和选择算子，也称为 Lasso）\n$$\n\\min_{x \\in \\mathbb{R}^p} \\; \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1,\n$$\n其中数据矩阵为 $A \\in \\mathbb{R}^{m \\times p}$，数据向量为 $b \\in \\mathbb{R}^m$，正则化参数为 $\\lambda \\ge 0$。令 $x^{\\star}(\\lambda)$ 表示作为 $\\lambda$ 的函数的解。假设存在一个 $\\lambda$ 值的区间，在该区间上，活动集 $S \\subset \\{1,\\dots,p\\}$ 和符号 $\\operatorname{sign}(x^{\\star}_S(\\lambda))$ 保持不变，且在该区间上有 $x^{\\star}_{S^c}(\\lambda) = 0$。\n\n1) 从凸最优性的第一性原理出发，即 Karush–Kuhn–Tucker (KKT) 条件和 $\\ell_1$-范数的次微分，推导在该区间上路径导数 $\\dot{x}_S(\\lambda) := \\frac{d}{d\\lambda} x^{\\star}_S(\\lambda)$ 关于 $A_S$ 和 $\\operatorname{sign}(x^{\\star}_S(\\lambda))$ 的显式表达式。你的推导必须仅使用所述的最优性框架，以及基本的微分法则和活动集上 $A_S^{\\top}A_S$ 的可逆性。\n\n2) 构建并分析以下具体实例，以说明 $\\dot{x}_S(\\lambda)$ 如何预测即将发生的系数符号翻转。令 $p = m = 2$, $S = \\{1,2\\}$，且\n$$\nA = \\begin{pmatrix} \\sqrt{\\frac{1}{2}}  \\sqrt{2} \\\\ 0  \\sqrt{3} \\end{pmatrix}, \\qquad\n\\lambda_0 = 1, \\qquad\nx^{\\star}(\\lambda_0) = \\begin{pmatrix} 0.2 \\\\ 0.1 \\end{pmatrix},\n$$\n活动集 $S$ 上的符号向量由 $\\operatorname{sign}(x^{\\star}_S(\\lambda_0)) = (1,1)^{\\top}$ 给出。选择 $b \\in \\mathbb{R}^2$ 以使 KKT 平稳性条件在 $\\lambda_0$ 处对该活动集和符号配置成立。然后，使用第 1 部分得到的一般表达式，计算 $\\dot{x}_S(\\lambda_0)$ 并使用得到的局部线性模型\n$$\nx^{\\star}_S(\\lambda) = x^{\\star}_S(\\lambda_0) + (\\lambda - \\lambda_0)\\,\\dot{x}_S(\\lambda_0)\n$$\n来预测第一个参数值 $\\lambda_{\\text{flip}}  \\lambda_0$，在该值处，当前活动坐标之一达到零（因此预测在 $\\lambda$ 进一步减小时会发生符号翻转），并假设在此事件之前没有其他支撑集变化发生。\n\n将此构造生成的 $\\lambda_{\\text{flip}}$ 的精确值作为你的最终答案。将你的最终答案表示为精确的分数。不要包含任何单位。", "solution": "我们从凸最优性条件开始。目标函数为\n$$\nf(x,\\lambda) = \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1.\n$$\n$\\ell_1$-范数的次微分是\n$$\n\\partial \\|x\\|_1 = \\{ z \\in \\mathbb{R}^p : z_i = \\operatorname{sign}(x_i) \\text{ if } x_i \\ne 0,\\; \\text{and}\\; z_i \\in [-1,1] \\text{ if } x_i = 0 \\}.\n$$\n最优性的 Karush–Kuhn–Tucker (KKT) 平稳性条件是\n$$\n0 \\in \\nabla_x \\left( \\tfrac{1}{2}\\|A x - b\\|_2^2 \\right) + \\lambda \\,\\partial \\|x\\|_1 = A^{\\top}(A x - b) + \\lambda \\,\\partial \\|x\\|_1.\n$$\n假设存在一个 $\\lambda$ 的区间，在该区间上活动集 $S$ 和 $S$ 上的符号保持不变，且有 $x_{S^c}(\\lambda) = 0$。令 $s_S := \\operatorname{sign}(x_S(\\lambda))$ 为该区间上的符号。那么限制在 $S$ 上的平稳性条件为等式\n$$\nA_S^{\\top}(A_S x_S - b) + \\lambda \\, s_S = 0,\n$$\n因为在 $S$ 上，我们有确定的次梯度 $z_S = s_S$。整理得，\n$$\nA_S^{\\top} A_S \\, x_S - A_S^{\\top} b + \\lambda \\, s_S = 0.\n$$\n假设 $A_S^{\\top} A_S$ 可逆（在 $S$ 上是列满秩的），我们可以在 $S$ 和 $s_S$ 固定的区间上对等式两边关于 $\\lambda$ 求导。利用 $A_S^{\\top} A_S$ 和 $A_S^{\\top} b$ 关于 $\\lambda$ 是常数，以及 $s_S$ 在此区间上是常数这一事实，我们得到\n$$\nA_S^{\\top} A_S \\, \\dot{x}_S(\\lambda) + s_S = 0.\n$$\n求解活动集上的路径导数，得到显式表达式\n$$\n\\dot{x}_S(\\lambda) = -\\,\\left(A_S^{\\top} A_S\\right)^{-1} \\, s_S.\n$$\n\n我们现在实例化这个例子。取 $p = m = 2$, $S = \\{1,2\\}$，且\n$$\nA = \\begin{pmatrix} \\sqrt{\\frac{1}{2}}  \\sqrt{2} \\\\ 0  \\sqrt{3} \\end{pmatrix}, \\qquad\n\\lambda_0 = 1, \\qquad\nx^{\\star}(\\lambda_0) = \\begin{pmatrix} 0.2 \\\\ 0.1 \\end{pmatrix}, \\qquad\ns_S = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n$S$ 上在 $\\lambda_0$ 处的 KKT 平稳性条件要求\n$$\nA^{\\top} A \\, x^{\\star}(\\lambda_0) - A^{\\top} b + \\lambda_0 \\, s_S = 0\n\\quad\\Longleftrightarrow\\quad\nA^{\\top} b = A^{\\top} A \\, x^{\\star}(\\lambda_0) + \\lambda_0 \\, s_S.\n$$\n计算 Gram 矩阵\n$$\nA^{\\top} A = \\begin{pmatrix}\n\\frac{1}{2}  1 \\\\\n1  5\n\\end{pmatrix}.\n$$\n因此\n$$\nA^{\\top} A \\, x^{\\star}(\\lambda_0) = \\begin{pmatrix}\n\\frac{1}{2}  1 \\\\\n1  5\n\\end{pmatrix}\n\\begin{pmatrix} 0.2 \\\\ 0.1 \\end{pmatrix}\n= \\begin{pmatrix} 0.2 \\\\ 0.7 \\end{pmatrix},\n$$\n因此\n$$\nA^{\\top} b = \\begin{pmatrix} 0.2 \\\\ 0.7 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n= \\begin{pmatrix} 1.2 \\\\ 1.7 \\end{pmatrix}.\n$$\n由于 $A$ 是可逆的，我们可以选择\n$$\nb = \\left(A^{\\top}\\right)^{-1} \\begin{pmatrix} 1.2 \\\\ 1.7 \\end{pmatrix}.\n$$\n现在使用通用公式计算 $\\dot{x}_S(\\lambda_0)$。首先，对 Gram 矩阵求逆。对于\n$$\nG = A^{\\top} A = \\begin{pmatrix}\n\\frac{1}{2}  1 \\\\\n1  5\n\\end{pmatrix},\n$$\n其行列式为\n$$\n\\det(G) = \\frac{1}{2}\\cdot 5 - 1^2 = \\frac{5}{2} - 1 = \\frac{3}{2},\n$$\n逆矩阵为\n$$\nG^{-1} = \\frac{1}{\\det(G)} \\begin{pmatrix} 5  -1 \\\\ -1  \\frac{1}{2} \\end{pmatrix}\n= \\frac{2}{3} \\begin{pmatrix} 5  -1 \\\\ -1  \\frac{1}{2} \\end{pmatrix}\n= \\begin{pmatrix} \\frac{10}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  \\frac{1}{3} \\end{pmatrix}.\n$$\n因此，\n$$\n\\dot{x}_S(\\lambda_0) = -\\,G^{-1} s_S = - \\begin{pmatrix} \\frac{10}{3}  -\\frac{2}{3} \\\\ -\\frac{2}{3}  \\frac{1}{3} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n= - \\begin{pmatrix} \\frac{8}{3} \\\\ -\\frac{1}{3} \\end{pmatrix}\n= \\begin{pmatrix} -\\frac{8}{3} \\\\ \\frac{1}{3} \\end{pmatrix}.\n$$\n该导数预测，当 $\\lambda$ 从 $\\lambda_0$ 减小时，第一个坐标会增加（因为对于 $\\lambda  \\lambda_0$，我们有 $\\lambda - \\lambda_0  0$，且 $\\dot{x}_{1}(\\lambda_0)  0$），而第二个坐标会减小（因为 $\\dot{x}_{2}(\\lambda_0) > 0$），向零移动，并可能在穿过零后翻转符号。\n\n在支撑集和符号固定的区间上使用局部线性路径模型：\n$$\nx_S(\\lambda) = x_S(\\lambda_0) + (\\lambda - \\lambda_0) \\,\\dot{x}_S(\\lambda_0).\n$$\n第二个坐标在第一个满足 $\\lambda  \\lambda_0$ 的 $\\lambda$ 处达到零，使得\n$$\n0 = x_2(\\lambda) = 0.1 + (\\lambda - 1)\\cdot \\frac{1}{3}.\n$$\n求解 $\\lambda$ 可得\n$$\n(\\lambda - 1)\\cdot \\frac{1}{3} = -0.1\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda - 1 = -0.3\n\\;\\;\\Longrightarrow\\;\\;\n\\lambda = 0.7 = \\frac{7}{10}.\n$$\n没有更早的事件发生，因为当 $\\lambda$ 减小时，第一个坐标远离零。因此，局部模型预测在以下值处即将发生符号翻转\n$$\n\\lambda_{\\text{flip}} = \\frac{7}{10}.\n$$\n该值作为一个有理数是精确的。", "answer": "$$\\boxed{\\frac{7}{10}}$$", "id": "3451804"}, {"introduction": "在理解了路径的局部分段线性行为之后，下一步就是通过连接这些线性片段来构建完整的路径。这需要精确地识别出活动变量集发生改变的“断点”或“事件”。本练习将指导您从头开始实现完整的 LARS-LASSO 算法 [@problem_id:3451768]。通过编写事件检测（变量进入和退出）的逻辑，您将对如何追踪整个解路径获得深刻的实践理解。", "problem": "您的任务是为压缩感知和稀疏优化中的最小绝对收缩和选择算子 (LASSO) 问题构建并分析同伦路径。重点是明确追踪支撑集的变化，并验证 LASSO 解路径相对于正则化参数的分段线性特性。该路径应通过应用 Karush-Kuhn-Tucker (KKT) 条件和同伦方法（也称为带有 LASSO 修正的最小角回归）来追踪。\n\n考虑 LASSO 目标函数\n$$\n\\min_{x \\in \\mathbb{R}^n} \\; \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1,\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $b \\in \\mathbb{R}^m$，$ \\lambda \\ge 0$ 是正则化参数。最优性的 KKT 条件表明\n$$\nA^\\top \\left(b - A x(\\lambda)\\right) \\in \\lambda \\, \\partial \\|x(\\lambda)\\|_1,\n$$\n这等价于\n$$\n\\begin{cases}\nA_i^\\top \\left(b - A x(\\lambda)\\right) = \\lambda \\, \\operatorname{sign}\\left(x_i(\\lambda)\\right),  \\text{若 } x_i(\\lambda) \\ne 0, \\\\\n\\left|A_i^\\top \\left(b - A x(\\lambda)\\right)\\right| \\le \\lambda,  \\text{若 } x_i(\\lambda) = 0,\n\\end{cases}\n$$\n对于每个索引 $i \\in \\{1,\\ldots,n\\}$。$\\ell_1$ 路径的同伦方法始于 $\\lambda_{\\max} = \\|A^\\top b\\|_\\infty$，其中 $x(\\lambda_{\\max}) = 0$，然后减小 $\\lambda$，在保持 KKT 条件的同时追踪活动支撑集和符号的变化。在支撑集变化事件之间，解 $x(\\lambda)$ 随 $\\lambda$ 线性演化。\n\n您的程序必须：\n\n1. 构建合成矩阵 $A$ 和向量 $b$ 以引导出可预测且非平凡的 LASSO 路径，包括多个系数脱落（索引离开活动集）的情况，以及没有脱落的情况。\n\n2. 从 $\\lambda_{\\max} = \\|A^\\top b\\|_\\infty$ 开始，通过迭代追踪同伦路径：\n   - 当非活动相关性达到 $\\pm \\lambda$ 时，将条目选入活动集，\n   - 计算在活动集上保持等相关性的等角下降方向，\n   - 当活动系数达到零时，检测并应用脱落，\n   - 在事件之间沿选定方向线性更新 $x(\\lambda)$ 和 $\\lambda$，\n   - 在每个断点处强制执行 KKT 条件。\n\n3. 预测并输出支撑集变化的确切序列，作为沿路径的事件列表，编码为整数对 $[e,i]$，其中 $e=1$ 表示索引 $i$ 进入活动集，$e=-1$ 表示索引 $i$ 从活动集脱落。索引必须使用基于 1 的索引进行报告。\n\n4. 对于连续支撑集变化事件之间的每个分段，验证：\n   - 通过检查 $A^\\top(b - A x(\\lambda))$ 与 $\\lambda \\, \\partial \\|x\\|_1$ 的关系，验证分段端点的 KKT 可行性，\n   - 通过确认 $x(\\lambda)$ 相对于 $\\lambda$ 的每段斜率是恒定的并且与计算出的等角方向匹配，来验证分段线性。\n\n所有计算都是纯数学和无量纲的；没有物理单位。不涉及角度。\n\n测试套件：\n提供三个涵盖不同行为的测试案例：\n- 案例 1 (多个脱落): $m = 4$, $n = 5$，$A$ 的列由规范基 $\\{e_1,e_2,e_3,e_4\\}$ 的组合定义，然后归一化为单位 $\\ell_2$ 范数：\n  $$\n  \\begin{aligned}\n   A_1 = e_1, \\\\\n   A_2 = 0.98\\, e_1 + 0.20\\, e_2, \\\\\n   A_3 = -0.95\\, e_1 + 0.30\\, e_3, \\\\\n   A_4 = 0.60\\, e_2 + 0.20\\, e_3, \\\\\n   A_5 = 0.60\\, e_3 + 0.20\\, e_1,\n  \\end{aligned}\n  $$\n  $b$ 向量为：\n  $$\n  b = 1.00\\, e_1 + 0.45\\, e_2 - 0.50\\, e_3 + 0.05\\, e_4.\n  $$\n  在对 $A$ 进行列归一化后，追踪 LASSO 路径。此案例旨在展示由于正相关和负相关预测变量相互竞争而导致的多个脱落。\n\n- 案例 2 (无脱落，正交设计): $m = 5$, $n = 5$，$A = I_5$ 且\n  $$\n  b = \\begin{bmatrix} 1.0 \\\\ 0.8 \\\\ 0.6 \\\\ 0.4 \\\\ 0.2 \\end{bmatrix}.\n  $$\n  路径应该是软阈值化的，具有单调的条目且无脱落。\n\n- 案例 3 (近共线预测变量): $m = 6$, $n = 6$，列由 $\\{e_1,\\ldots,e_6\\}$ 构建并归一化：\n  $$\n  \\begin{aligned}\n   A_1 = e_1, \\\\\n   A_2 = 0.99\\, e_1 + 0.10\\, e_2, \\\\\n   A_3 = 0.99\\, e_1 - 0.10\\, e_2, \\\\\n   A_4 = e_2, \\\\\n   A_5 = e_3, \\\\\n   A_6 = 0.50\\, e_3 + 0.40\\, e_4,\n  \\end{aligned}\n  $$\n  $b$ 向量为：\n  $$\n  b = 1.00\\, e_1 + 0.70\\, e_2 + 0.25\\, e_3 - 0.20\\, e_4 + 0.10\\, e_6.\n  $$\n\n所需输出格式：\n您的程序应生成单行输出，其中包含三个测试案例的结果，格式为用方括号括起来的逗号分隔列表。每个测试案例的结果必须是一个包含以下三个组件的列表：\n- 支撑集变化事件的列表，表示为整数对 $[e,i]$，其中 $e \\in \\{1,-1\\}$，i 为基于 1 的索引。\n- 一个布尔值，指示断点处的所有 KKT 检查是否成功。\n- 一个布尔值，指示所有分段的 piecewise 线性检查是否成功。\n\n例如，整体输出应如下所示：\n$$\n[ [ [e_1,i_1],\\ldots,[e_k,i_k] ] , \\text{True} , \\text{True} ] , \\ldots ].\n$$\n您的程序必须从第一性原理实现同伦追踪和验证，并以指定格式生成确切的单行输出。", "solution": "用户提供了一个有效的问题陈述。任务是为 LASSO 优化问题实现同伦方法，追踪作为正则化参数 $\\lambda$ 函数的解路径，识别支撑集变化（系数的进入和脱落），并根据 Karush-Kuhn-Tucker (KKT) 条件及其分段线性性质验证路径的正确性。\n\nLASSO 问题定义为：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\; \\frac{1}{2}\\|A x - b\\|_2^2 + \\lambda \\|x\\|_1\n$$\n当 $\\lambda$ 变化时，解 $x(\\lambda)$ 描绘出一条分段线性路径。同伦方法，也称为 LARS-LASSO 算法，提供了一种计算这条完整路径的方法。我们从一个大的 $\\lambda$ 开始，此时解为 $x=0$，然后逐步减小 $\\lambda$，同时追踪非零系数活动集的变化。\n\n算法流程如下：\n\n**1. 初始化**\n路径始于 $\\lambda = \\lambda_{\\max}$，此时解是平凡的，$x(\\lambda_{\\max}) = 0$。此时，残差为 $r = b - A x = b$。KKT 条件要求对于所有 $i$，$|A_i^\\top(b-Ax)| \\le \\lambda$。为了找到可能首次出现非零解的最大 $\\lambda$，我们找到该不等式对至少一个索引变为等式的点。这发生在：\n$$\n\\lambda_{\\max} = \\|A^\\top b\\|_{\\infty}\n$$\n设 $j_0$ 是一个索引，满足 $|A_{j_0}^\\top b| = \\lambda_{\\max}$。该索引是第一个进入活动集 $\\mathcal{A}$ 的。\n- 初始解: $x_0 = 0 \\in \\mathbb{R}^n$。\n- 初始 $\\lambda$: $\\lambda_0 = \\lambda_{\\max}$。\n- 初始活动集: $\\mathcal{A} = \\{j_0\\}$。\n- 初始符号: $s_{\\mathcal{A}} = [\\operatorname{sign}((A^\\top b)_{j_0})]$。\n\n**2. 路径分段构建**\n在两个连续事件（活动集的变化）之间，解 $x(\\lambda)$ 是 $\\lambda$ 的线性函数。对于给定的活动集 $\\mathcal{A}$ 和相应的符号 $s_{\\mathcal{A}}$，活动的 KKT 条件是：\n$$\nA_{\\mathcal{A}}^\\top (b - A x(\\lambda)) = \\lambda s_{\\mathcal{A}}\n$$\n其中 $A_{\\mathcal{A}}$ 是 $A$ 中由 $\\mathcal{A}$ 索引的列组成的子矩阵，且对于 $i \\notin \\mathcal{A}$，$x_i(\\lambda) = 0$。这可以简化为：\n$$\nA_{\\mathcal{A}}^\\top (b - A_{\\mathcal{A}} x_{\\mathcal{A}}(\\lambda)) = \\lambda s_{\\mathcal{A}}\n$$\n对 $\\lambda$ 求导，我们得到活动系数的路径方向：\n$$\n-A_{\\mathcal{A}}^\\top A_{\\mathcal{A}} \\frac{dx_{\\mathcal{A}}}{d\\lambda} = s_{\\mathcal{A}}\n$$\n求解导数，它代表了路径分段的斜率：\n$$\n\\frac{dx_{\\mathcal{A}}}{d\\lambda} = -(A_{\\mathcal{A}}^\\top A_{\\mathcal{A}})^{-1} s_{\\mathcal{A}}\n$$\n我们将路径更新方向定义为 $w_{\\mathcal{A}} = (A_{\\mathcal{A}}^\\top A_{\\mathcal{A}})^{-1} s_{\\mathcal{A}}$。完整的方向向量 $w \\in \\mathbb{R}^n$ 仅在 $\\mathcal{A}$ 中的索引处有非零项。当我们将 $\\lambda$ 从当前值 $\\lambda_{\\text{curr}}$ 减小一个量 $\\delta_{\\lambda}  0$ 时，解更新如下：\n$$\nx_{\\text{new}} = x_{\\text{curr}} + \\delta_{\\lambda} w\n$$\n新的 $\\lambda$ 将是 $\\lambda_{\\text{new}} = \\lambda_{\\text{curr}} - \\delta_{\\lambda}$。\n\n**3. 事件检测**\n路径分段的线性演化在活动集必须改变之前是有效的。这是一个“事件”。我们必须找到触发此类事件的最小步长 $\\delta_{\\lambda}  0$。有两种类型的事件：\n\n- **进入事件**：对于 $j \\notin \\mathcal{A}$ 的一个系数 $x_j$ 变为非零。这发生在其对应的相关性 $c_j = A_j^\\top(b - Ax)$ 达到边界 $\\pm\\lambda$ 时。相关性演化如下 $c_j(\\lambda_{\\text{new}}) = c_j(\\lambda_{\\text{curr}}) - \\delta_{\\lambda} A_j^\\top A w$。我们需要找到满足 $|c_j(\\lambda_{\\text{curr}}) - \\delta_{\\lambda} A_j^\\top A w| = \\lambda_{\\text{curr}} - \\delta_{\\lambda}$ 的最小 $\\delta_{\\lambda}  0$，对于某个 $j \\notin \\mathcal{A}$。这为每个非活动索引 $j$ 导出了关于 $\\delta_{\\lambda}$ 的两个线性方程：\n    $$\n    \\delta_{\\lambda} = \\frac{\\lambda_{\\text{curr}} - c_j(\\lambda_{\\text{curr}})}{1 - A_j^\\top A w} \\quad \\text{和} \\quad \\delta_{\\lambda} = \\frac{\\lambda_{\\text{curr}} + c_j(\\lambda_{\\text{curr}})}{1 + A_j^\\top A w}\n    $$\n    我们考虑在所有 $j \\notin \\mathcal{A}$ 中找到的最小正 $\\delta_{\\lambda}$。\n\n- **脱落事件**：对于 $k \\in \\mathcal{A}$ 的一个活动系数 $x_k(\\lambda)$ 穿过零。LARS 的 LASSO 修正要求将这样的系数从活动集中移除。这发生在 $x_k(\\lambda_{\\text{new}}) = x_k(\\lambda_{\\text{curr}}) + \\delta_{\\lambda} w_k = 0$ 时。这给出了步长：\n    $$\n    \\delta_{\\lambda} = -x_k(\\lambda_{\\text{curr}}) / w_k\n    $$\n    仅当 $\\delta_{\\lambda}  0$ 时，这才是未来事件的候选，这种情况发生在 $x_k$ 和 $w_k$ 符号相反时。我们找到在所有 $k \\in \\mathcal{A}$ 上这样的最小正 $\\delta_{\\lambda}$。\n\n下一个事件发生在 $\\delta_{\\lambda} = \\min(\\delta_{\\lambda, \\text{entry}}, \\delta_{\\lambda, \\text{dropout}})$。\n\n**4. 迭代与验证**\n算法迭代计算方向 $w$，找到最小步长 $\\delta_{\\lambda}$，更新状态 $(x, \\lambda)$，并根据事件类型修改活动集 $\\mathcal{A}$ 和符号 $s_{\\mathcal{A}}$。该过程一直持续到 $\\lambda$ 达到零或满足另一个终止条件。\n\n在每个断点（即每一步之后），我们执行两项验证：\n- **KKT 验证**：我们检查对于*新*活动集，KKT 条件在新的点 $(x_{\\text{new}}, \\lambda_{\\text{new}})$ 是否成立。即，对于活动索引 $i$ 有 $|A_i^\\top(b-Ax_{\\text{new}})| = \\lambda_{\\text{new}}$，对于非活动索引 $j$ 有 $|A_j^\\top(b-Ax_{\\text{new}})| \\le \\lambda_{\\text{new}}$。\n- **分段线性 (PWL) 验证**：我们确认分段上 $x$ 的变化与计算出的路径方向一致。经验斜率是 $(\\Delta x) / (\\Delta \\lambda) = (x_{\\text{new}} - x_{\\text{curr}}) / (\\lambda_{\\text{new}} - \\lambda_{\\text{curr}})$。这必须与理论斜率 $dx/d\\lambda = -w$ 相匹配。\n\n实现将使用一个小的容差 $\\epsilon$ 来处理比较中的数值精度问题。测试案例旨在检验算法的不同方面，包括脱落（案例 1）、简单的单调路径（案例 2）和近共线性（案例 3）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the LASSO path algorithm.\n    It formats and prints the results as specified.\n    \"\"\"\n    \n    TOL = 1e-9\n\n    def format_result(result_list):\n        \"\"\"Custom formatter to match the output string format [item1,item2,...].\"\"\"\n        events_str = '[' + ','.join([f'[{e},{i}]' for e, i in result_list[0]]) + ']'\n        kkt_str = 'True' if result_list[1] else 'False'\n        pwl_str = 'True' if result_list[2] else 'False'\n        return f\"[{events_str},{kkt_str},{pwl_str}]\"\n    \n    # Case 1: Multiple dropouts\n    m1, n1 = 4, 5\n    A1_unnormalized = np.zeros((m1, n1))\n    e = np.eye(m1)\n    A1_unnormalized[:, 0] = e[:, 0]\n    A1_unnormalized[:, 1] = 0.98 * e[:, 0] + 0.20 * e[:, 1]\n    A1_unnormalized[:, 2] = -0.95 * e[:, 0] + 0.30 * e[:, 2]\n    A1_unnormalized[:, 3] = 0.60 * e[:, 1] + 0.20 * e[:, 2]\n    A1_unnormalized[:, 4] = 0.60 * e[:, 2] + 0.20 * e[:, 0]\n    b1 = 1.00 * e[:, 0] + 0.45 * e[:, 1] - 0.50 * e[:, 2] + 0.05 * e[:, 3]\n    \n    # Case 2: Orthonormal design\n    m2, n2 = 5, 5\n    A2_unnormalized = np.eye(m2)\n    b2 = np.array([1.0, 0.8, 0.6, 0.4, 0.2])\n\n    # Case 3: Near-collinear predictors\n    m3, n3 = 6, 6\n    A3_unnormalized = np.zeros((m3, n3))\n    e = np.eye(m3)\n    A3_unnormalized[:, 0] = e[:, 0]\n    A3_unnormalized[:, 1] = 0.99 * e[:, 0] + 0.10 * e[:, 1]\n    A3_unnormalized[:, 2] = 0.99 * e[:, 0] - 0.10 * e[:, 1]\n    A3_unnormalized[:, 3] = e[:, 1]\n    A3_unnormalized[:, 4] = e[:, 2]\n    A3_unnormalized[:, 5] = 0.50 * e[:, 2] + 0.40 * e[:, 3]\n    b3 = 1.00 * e[:, 0] + 0.70 * e[:, 1] + 0.25 * e[:, 2] - 0.20 * e[:, 3] + 0.10 * e[:, 5]\n\n    test_cases = [\n        (A1_unnormalized, b1, TOL),\n        (A2_unnormalized, b2, TOL),\n        (A3_unnormalized, b3, TOL)\n    ]\n    \n    results = []\n    for A_un, b, tol in test_cases:\n        # Normalize columns of A\n        A = A_un.copy()\n        norms = np.linalg.norm(A, axis=0)\n        # Avoid division by zero for zero-columns if any\n        non_zero_norms = norms > tol\n        A[:, non_zero_norms] /= norms[non_zero_norms]\n        \n        res = run_lasso_path(A, b, tol)\n        results.append(res)\n    \n    # Using python's str() will introduce spaces which is acceptable.\n    # The problem description's provided code skeleton implies this is the desired way.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_lasso_path(A, b, tol):\n    \"\"\"\n    Implements the homotopy (LARS-LASSO) algorithm to trace the LASSO solution path.\n    \"\"\"\n    m, n = A.shape\n    x = np.zeros(n)\n    events = []\n    kkt_ok = True\n    pwl_ok = True\n\n    # Initial state\n    c = A.T @ (b - A @ x)\n    lam = np.max(np.abs(c))\n    \n    full_indices = np.arange(n)\n    active_set = {np.argmax(np.abs(c))}\n    \n    events.append([1, list(active_set)[0] + 1])\n\n    while lam > tol and len(active_set) > 0 and len(active_set) = m:\n        active_indices = sorted(list(active_set))\n        inactive_indices = np.setdiff1d(full_indices, active_indices)\n\n        x_old = x.copy()\n        lam_old = lam\n\n        c = A.T @ (b - A @ x)\n        signs = np.sign(c[active_indices])\n        \n        # This handles cases where a sign is zero due to numerical precision\n        zero_sign_mask = np.abs(signs)  tol\n        if np.any(zero_sign_mask):\n            signs[zero_sign_mask] = 1.0 # Or some other robust choice\n\n        # Compute path direction\n        A_active = A[:, active_indices]\n        try:\n            # G u = s => u = G^-1 s\n            G_active = A_active.T @ A_active\n            w_active = np.linalg.solve(G_active, signs)\n        except np.linalg.LinAlgError:\n            kkt_ok = False # Singular matrix, path cannot continue\n            break\n        \n        w = np.zeros(n)\n        w[active_indices] = w_active\n        \n        # Calculate step to next event\n        delta_lam = lam # Initialize with max possible step\n\n        # --- 1. Entry event ---\n        delta_lam_entry = delta_lam\n        entry_candidates = []\n        if len(inactive_indices) > 0:\n            a = A.T @ (A @ w)\n            for j in inactive_indices:\n                # Solve for delta_lam_j in |c_j - delta_lam_j * a_j| = lam - delta_lam_j\n                # Case 1: c_j - d*a_j = lam-d => d(1-a_j) = lam-c_j\n                if abs(1 - a[j]) > tol:\n                    d1 = (lam - c[j]) / (1 - a[j])\n                    if d1 > tol:\n                        entry_candidates.append(d1)\n                # Case 2: c_j - d*a_j = -(lam-d) => d(1+a_j) = lam+c_j\n                if abs(1 + a[j]) > tol:\n                    d2 = (lam + c[j]) / (1 + a[j])\n                    if d2 > tol:\n                        entry_candidates.append(d2)\n            if entry_candidates:\n                delta_lam_entry = min(entry_candidates)\n        \n        # --- 2. Dropout event ---\n        delta_lam_dropout = delta_lam\n        dropout_candidates = []\n        for i, k in enumerate(active_indices):\n            # Find d s.t. x_k + d * w_k = 0\n            if signs[i] * w_active[i]  -tol: # x and w must move towards each other\n                d = -x[k] / w[k]\n                if d > tol:\n                    dropout_candidates.append(d)\n        if dropout_candidates:\n            delta_lam_dropout = min(dropout_candidates)\n\n        delta_lam = min(delta_lam_entry, delta_lam_dropout)\n        \n        if delta_lam >= lam or delta_lam = tol:\n            delta_lam = lam # Take final step to zero\n        \n        # Update state\n        lam -= delta_lam\n        x += delta_lam * w\n        \n        # Force near-zero components to be exactly zero\n        x[np.abs(x)  tol] = 0.0\n        \n        # Verification\n        # PWL check\n        if lam_old - lam > tol:\n            slope_empirical = (x - x_old) / (lam - lam_old)\n            slope_theoretical = -w\n            if not np.allclose(slope_empirical, slope_theoretical, atol=tol*10):\n                 pwl_ok = False\n        \n        # KKT Check - At the new point, before updating active set\n        c_new = A.T @ (b - A @ x)\n        \n        is_entry = delta_lam_entry = delta_lam_dropout + tol\n        is_dropout = delta_lam_dropout = delta_lam_entry + tol\n        \n        next_active_set = active_set.copy()\n        newly_added = set()\n        if is_entry:\n            for j in inactive_indices:\n                if abs(1 - a[j]) > tol:\n                    d1 = (lam_old - c[j]) / (1 - a[j])\n                    if abs(d1 - delta_lam)  tol:\n                        next_active_set.add(j)\n                        newly_added.add(j)\n                if abs(1 + a[j]) > tol:\n                    d2 = (lam_old + c[j]) / (1 + a[j])\n                    if abs(d2 - delta_lam)  tol:\n                        next_active_set.add(j)\n                        newly_added.add(j)\n        \n        newly_removed = set()\n        if is_dropout:\n            for i, k in enumerate(active_indices):\n                if signs[i] * w_active[i]  -tol:\n                    d = -x_old[k] / w[k]\n                    if abs(d - delta_lam)  tol:\n                        if k in next_active_set:\n                           next_active_set.remove(k)\n                        newly_removed.add(k)\n        \n        next_active_indices = sorted(list(next_active_set))\n        if next_active_indices:\n            signs_new = np.sign(c_new[next_active_indices])\n            for i, k in enumerate(next_active_indices):\n                if abs(abs(c_new[k]) - lam) > tol * 10 or abs(c_new[k] - signs_new[i] * lam) > tol * 10:\n                    kkt_ok = False\n                    break\n        if not kkt_ok: break\n        \n        for k in range(n):\n            if k not in next_active_set:\n                if abs(c_new[k]) > lam + tol * 10:\n                    kkt_ok = False\n                    break\n        if not kkt_ok: break\n\n        # Record events and update active set\n        for j in newly_added:\n            events.append([1, j + 1])\n        for j in newly_removed:\n            events.append([-1, j + 1])\n\n        active_set = next_active_set\n        \n        if lam  tol:\n            break\n\n    return [events, kkt_ok, pwl_ok]\n\nsolve()\n```", "id": "3451768"}, {"introduction": "同伦框架的一个关键优势在于其清晰的解析结构。这不仅使我们能够为静态数据集计算解路径，还能分析当数据本身更新时路径如何变化。这个高级问题挑战您将所学知识应用于流式数据场景 [@problem_id:3451784]。通过推导新数据点如何扰动解路径及其下一个断点，您将学习如何在不从头开始重新计算的情况下高效更新模型，这突显了解路径追踪算法的一个强大特性。", "problem": "考虑通过最小化目标函数定义的最小绝对收缩和选择算子 (LASSO) 路径\n$$\\frac{1}{2}\\|A x - b\\|_{2}^{2} + \\lambda \\|x\\|_{1},$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^{m}$，$x \\in \\mathbb{R}^{n}$ 且 $\\lambda \\geq 0$。该路径通过减小 $\\lambda$ 并维持卡罗什-库恩-塔克 (KKT) 条件来追踪。在一个活动集 $S \\subset \\{1,\\dots,n\\}$ 及其关联的符号向量 $s \\in \\mathbb{R}^{|S|}$ 固定的路径段上，KKT 条件意味着 $x_{S^{c}}(\\lambda)=0$，平稳性条件 $A_{S}^{\\top}(A x(\\lambda) - b) + \\lambda s = 0$，以及对偶可行性条件 $|A_{j}^{\\top}(A x(\\lambda) - b)| \\leq \\lambda$（对每个非活动索引 $j \\in S^{c}$ 成立）。\n\n当前，对于给定的数据，您正处于一个活动集为 $S = \\{1\\}$ 且固定符号为 $s_{1} = +1$ 的路径段上\n$$A = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0\n\\end{pmatrix}, \\qquad b = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}。$$\n在没有流式更新的情况下，此路径段上的下一个断点由非活动索引 $j^{\\star} = 2$ 决定，当其对偶约束达到等式时，该索引变为活动状态。\n\n现在，假设一个流式更新追加了一个新行 $a^{\\top} \\in \\mathbb{R}^{n}$ 和一个新条目 $b_{\\mathrm{new}} \\in \\mathbb{R}$：\n$$a^{\\top} = \\begin{pmatrix} 1  0.25  0 \\end{pmatrix}, \\qquad b_{\\mathrm{new}} = 1.2,$$\n因此更新后的系统为\n$$A' = \\begin{pmatrix}\nA \\\\\na^{\\top}\n\\end{pmatrix}, \\qquad b' = \\begin{pmatrix}\nb \\\\\nb_{\\mathrm{new}}\n\\end{pmatrix}。$$\n请仅使用基本的 KKT 条件和秩一矩阵逆更新原理，推导更新后的原始解 $x_{S}(\\lambda)$ 的公式（无需重启同伦），并表达在流式更新下非活动索引 $j^{\\star} = 2$ 的相关性。然后，确定旧的下一个断点 $\\lambda_{\\mathrm{old}}$ 和新的下一个断点 $\\lambda_{\\mathrm{new}}$，在这两个断点处，非活动索引 $j^{\\star} = 2$ 分别满足 $|A_{2}^{\\top}(A x(\\lambda) - b)| = \\lambda$ 和 $|A'_{2}{}^{\\top}(A' x(\\lambda) - b')| = \\lambda$，同时活动集 $S = \\{1\\}$ 和 $s_{1} = +1$ 在达到这些断点前保持不变。\n\n最后，计算扰动\n$$\\Delta = \\lambda_{\\mathrm{new}} - \\lambda_{\\mathrm{old}},$$\n并以最简分数形式给出其精确值。不要四舍五入。", "solution": "首先验证问题，以确保其具有科学依据、良态且客观。\n\n### 第 1 步：提取已知条件\n- **目标函数**：$\\frac{1}{2}\\|A x - b\\|_{2}^{2} + \\lambda \\|x\\|_{1}$\n- **数据矩阵和向量**：$A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^{m}$，$x \\in \\mathbb{R}^{n}$，$\\lambda \\geq 0$。\n- **KKT 条件**：\n    1. 原始可行性：解路径满足此条件。\n    2. 次梯度/平稳性：对于活动集 $S$ 及其符号向量 $s \\in \\mathbb{R}^{|S|}$，$x_{S^{c}}(\\lambda)=0$ 且 $A_{S}^{\\top}(A x(\\lambda) - b) + \\lambda s = 0$。\n    3. 对偶可行性：对于每个非活动索引 $j \\in S^{c}$，有 $|A_{j}^{\\top}(A x(\\lambda) - b)| \\leq \\lambda$。\n- **初始数据**：\n    - $A = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\end{pmatrix}$\n    - $b = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$\n- **路径段**：\n    - 活动集 $S = \\{1\\}$。\n    - 符号向量 $s = s_{1} = +1$。\n    - 下一个断点由非活动索引 $j^{\\star} = 2$ 决定。\n- **流式更新**：\n    - 新行：$a^{\\top} = \\begin{pmatrix} 1  0.25  0 \\end{pmatrix}$\n    - 新条目：$b_{\\mathrm{new}} = 1.2$\n- **更新后的系统**：\n    - $A' = \\begin{pmatrix} A \\\\ a^{\\top} \\end{pmatrix} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 1  0.25  0 \\end{pmatrix}$\n    - $b' = \\begin{pmatrix} b \\\\ b_{\\mathrm{new}} \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 1 \\\\ 1.2 \\end{pmatrix}$\n- **任务**：\n    1. 推导当 $S=\\{1\\}$ 时路径段上更新后的原始解 $x_{S}(\\lambda)$ 的公式。\n    2. 表达在流式更新下非活动索引 $j^{\\star} = 2$ 的相关性。\n    3. 确定旧断点 $\\lambda_{\\mathrm{old}}$ 和新断点 $\\lambda_{\\mathrm{new}}$。\n    4. 以最简分数形式计算扰动 $\\Delta = \\lambda_{\\mathrm{new}} - \\lambda_{\\mathrm{old}}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题设定在稀疏优化和压缩感知的标准数学框架内，具体涉及求解 LASSO 的同伦方法。所有术语（$A$、$b$、$\\lambda$、KKT 条件、活动集、断点）在该领域都是良定义和标准的。所提供的数据是完整且一致的，可以计算出唯一的解路径。该任务是将这些原理直接应用于一个涉及流式数据更新的具体数值示例，这是现代数据分析中的一个相关课题。该问题不违反任何科学原理，没有歧义，并且是可形式化的。\n\n### 第 3 步：结论与行动\n问题有效。我们继续进行求解。\n\n#### 原始系统分析（更新前）\n\n我们首先分析流式更新前的系统。活动集为 $S=\\{1\\}$，活动系数的符号为 $s_{1}=+1$。解向量的形式为 $x(\\lambda) = (x_1(\\lambda), 0, 0)^{\\top}$。KKT 平稳性条件由 $A_{S}^{\\top}(A x(\\lambda) - b) + \\lambda s = 0$ 给出。\n\n在这里，$A_S = A_1$（$A$ 的第一列），即 $A_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。该条件变为：\n$$A_{1}^{\\top}(A_1 x_1(\\lambda) - b) + \\lambda s_1 = 0$$\n我们计算各项：\n$A_1^{\\top} A_1 = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 1$\n$A_1^{\\top} b = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = 2$\n将这些代入平稳性方程：\n$(1) x_1(\\lambda) - 2 + \\lambda (1) = 0$\n这给出了活动系数的原始路径：\n$$x_1(\\lambda) = 2 - \\lambda$$\n下一个断点 $\\lambda_{\\mathrm{old}}$ 发生在某个非活动索引 $j \\in S^c = \\{2, 3\\}$ 首次以等式形式满足对偶可行性条件时：$|A_{j}^{\\top}(A x(\\lambda) - b)| = \\lambda$。问题指明该索引为 $j^{\\star} = 2$。\n残差为 $r(\\lambda) = A x(\\lambda) - b = A_1 x_1(\\lambda) - b = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} (2 - \\lambda) - \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 2 - \\lambda - 2 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} -\\lambda \\\\ -1 \\end{pmatrix}$。\n非活动索引 $j^{\\star}=2$ 的相关性为 $c_2(\\lambda) = A_2^{\\top} r(\\lambda)$。其中 $A_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$：\n$c_2(\\lambda) = \\begin{pmatrix} 0  1 \\end{pmatrix} \\begin{pmatrix} -\\lambda \\\\ -1 \\end{pmatrix} = -1$\n断点条件为 $|c_2(\\lambda)| = \\lambda$，这得到 $|-1| = \\lambda$。\n因此，旧断点为 $\\lambda_{\\mathrm{old}} = 1$。\n\n#### 更新后系统分析\n\n流式更新后，我们得到由 $A'$ 和 $b'$ 定义的新系统。假设在新路径段上，活动集 $S=\\{1\\}$ 和符号 $s_1=+1$ 保持不变。设新的原始路径为 $x'(\\lambda) = (x'_1(\\lambda), 0, 0)^{\\top}$。\n更新后系统的 KKT 平稳性条件为 $A'_{S}{}^{\\top}(A' x'(\\lambda) - b') + \\lambda s = 0$。\n在这里，$A'_S = A'_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$。我们计算新的格拉姆矩阵以及与 $b'$ 的相关性：\n$A'_{1}{}^{\\top} A'_{1} = \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = 1 + 0 + 1 = 2$。\n此更新对应于 $A_{S}^{\\top}A_{S} \\to A_{S}^{\\top}A_{S} + a_{S}a_{S}^{\\top}$，一个秩一更新。\n$A'_{1}{}^{\\top} b' = \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\\\ 1.2 \\end{pmatrix} = 2 + 0 + 1.2 = 3.2$。\n\n平稳性方程变为：\n$(2) x'_1(\\lambda) - 3.2 + \\lambda(1) = 0$\n解出 $x'_1(\\lambda)$，我们得到更新后的原始解的公式：\n$$x'_1(\\lambda) = \\frac{3.2 - \\lambda}{2} = 1.6 - 0.5\\lambda$$\n\n接下来，我们找出由非活动索引 $j^{\\star} = 2$ 确定的新断点 $\\lambda_{\\mathrm{new}}$。我们计算更新后的非活动相关性 $c'_2(\\lambda) = A'_{2}{}^{\\top}(A' x'(\\lambda) - b')$。\n新的残差为 $r'(\\lambda) = A' x'(\\lambda) - b' = A'_1 x'_1(\\lambda) - b'$。\n$r'(\\lambda) = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} (1.6 - 0.5\\lambda) - \\begin{pmatrix} 2 \\\\ 1 \\\\ 1.2 \\end{pmatrix} = \\begin{pmatrix} 1.6 - 0.5\\lambda - 2 \\\\ -1 \\\\ 1.6 - 0.5\\lambda - 1.2 \\end{pmatrix} = \\begin{pmatrix} -0.4 - 0.5\\lambda \\\\ -1 \\\\ 0.4 - 0.5\\lambda \\end{pmatrix}$。\n$A'$ 的第二列是 $A'_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0.25 \\end{pmatrix}$。\n更新后，非活动索引 $j^{\\star}=2$ 的相关性为：\n$c'_2(\\lambda) = A'_{2}{}^{\\top} r'(\\lambda) = \\begin{pmatrix} 0  1  0.25 \\end{pmatrix} \\begin{pmatrix} -0.4 - 0.5\\lambda \\\\ -1 \\\\ 0.4 - 0.5\\lambda \\end{pmatrix}$\n$c'_2(\\lambda) = (0) + (-1) + 0.25(0.4 - 0.5\\lambda) = -1 + 0.1 - 0.125\\lambda$\n$$c'_2(\\lambda) = -0.9 - 0.125\\lambda$$\n通过求解 $|c'_2(\\lambda)| = \\lambda$ 来找到新断点 $\\lambda_{\\mathrm{new}}$：\n$|-0.9 - 0.125\\lambda| = \\lambda$\n由于 $\\lambda \\geq 0$，项 $-0.9 - 0.125\\lambda$ 总是负数。因此，我们可以写成：\n$0.9 + 0.125\\lambda = \\lambda$\n$0.9 = \\lambda - 0.125\\lambda = 0.875\\lambda$\n$\\lambda_{\\mathrm{new}} = \\frac{0.9}{0.875}$\n为了将其表示为最简分数，我们转换小数：$0.9 = \\frac{9}{10}$ 且 $0.875 = \\frac{875}{1000} = \\frac{7}{8}$。\n$\\lambda_{\\mathrm{new}} = \\frac{9/10}{7/8} = \\frac{9}{10} \\times \\frac{8}{7} = \\frac{72}{70} = \\frac{36}{35}$。\n\n#### 扰动计算\n\n最后，我们计算扰动 $\\Delta = \\lambda_{\\mathrm{new}} - \\lambda_{\\mathrm{old}}$。\n$\\Delta = \\frac{36}{35} - 1 = \\frac{36}{35} - \\frac{35}{35} = \\frac{1}{35}$。", "answer": "$$\\boxed{\\frac{1}{35}}$$", "id": "3451784"}]}