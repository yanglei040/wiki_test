{"hands_on_practices": [{"introduction": "在理解了算子的基本定义之后，我们进一步探讨其稳定性。在实际应用中，输入信号常常会受到噪声或微小扰动的影响。这个练习 [@problem_id:3469834] 通过计算改变输出稀疏支撑所需之最小扰动，为您提供了一种量化算子敏感度的具体方法，并引入了“支撑间隔”（support gap）这一重要概念。", "problem": "考虑硬阈值算子 $H_{k} : \\mathbb{R}^{n} \\to \\mathbb{R}^{n}$，对于给定的向量 $x \\in \\mathbb{R}^{n}$，该算子保留绝对值最大的 $k$ 个分量，并将其余所有分量置零。令经过 $k$-硬阈值处理的向量的支撑集表示为 $\\operatorname{supp}(H_{k}(x))$，并假设 $n \\geq k+1$。假设 $x$ 的分量大小严格有序，即 $|x|_{(1)}  \\cdots  |x|_{(k)}  |x|_{(k+1)}  \\cdots  |x|_{(n)}$，其中 $|x|_{(i)}$ 表示 $x$ 的第 $i$ 大的绝对值分量，并定义支撑间隙 $g$ 为 $g := |x|_{(k)} - |x|_{(k+1)}  0$。\n\n对抗性扰动是任意满足欧几里得范数至多为 $\\epsilon$ 的 $d \\in \\mathbb{R}^{n}$，即 $\\|d\\|_{2} \\leq \\epsilon$。设计 $x$，使得在所有可能的小范数对抗方向中，对 $H_{k}(x)$ 改变最剧烈的方向是通过将大小为 $|x|_{(k)}$ 的索引降级并将大小为 $|x|_{(k+1)}$ 的索引升级来实现的，而所有其他索引与此边界保持足够远的距离（您可以假设所有其他成对间隙都大于 $g$）。仅从 $H_{k}$ 的核心定义、欧几里得范数以及绝对值的排序出发，推导改变支撑集所需的最小对抗半径 $\\epsilon^{\\star}$，其定义为\n$$\n\\epsilon^{\\star} := \\inf\\left\\{ \\|d\\|_{2} : \\operatorname{supp}(H_{k}(x + d)) \\neq \\operatorname{supp}(H_{k}(x)) \\right\\},\n$$\n将其表示为支撑间隙 $g$ 的解析函数。以 $g$ 的闭式表达式给出您的最终答案。无需四舍五入，不涉及单位。", "solution": "令 $x \\in \\mathbb{R}^{n}$ 是一个分量大小严格有序的向量。令 $S_{0} = \\operatorname{supp}(H_{k}(x))$ 是对应于 $x$ 的 $k$ 个最大大小的索引集合。令 $i_j$ 为索引，使得 $|x_{i_j}| = |x|_{(j)}$ 对 $j=1, \\ldots, n$ 成立。则 $S_0 = \\{i_1, i_2, \\ldots, i_k\\}$。\n\n当扰动后向量 $x+d$ 的 $k$ 个最大大小的索引集合不同于 $S_0$ 时，支撑集发生变化，即 $\\operatorname{supp}(H_{k}(x+d)) \\neq S_0$。问题要求我们考虑一种特定情况，即这种变化是由于扰动后索引 $i_k$ 处分量的大小降至索引 $i_{k+1}$ 处分量的大小之下引起的。也就是说，一个来自 $S_0$ 外部的索引（具体为 $i_{k+1}$）进入新的支撑集，而一个来自 $S_0$ 内部的索引（具体为 $i_k$）离开它。\n\n当扰动后分量的大小满足 $|(x+d)_{i_{k}}| \\le |(x+d)_{i_{k+1}}|$ 时，这种转变发生。最小扰动范数 $\\epsilon^{\\star}$ 将在该条件的边界上达到，即当等式成立时：\n$$\n|(x+d)_{i_k}| = |(x+d)_{i_{k+1}}|\n$$\n\n问题还指出，所有其他大小之间的成对间隙都大于 $g$。这证明了将扰动 $d$ 仅集中于两个关键分量 $x_{i_k}$ 和 $x_{i_{k+1}}$ 是合理的。施加到其他分量上的任何扰动都会增加范数 $\\|d\\|_2$，而不能最高效地满足等式条件。因此，我们可以对所有 $j \\notin \\{i_k, i_{k+1}\\}$ 设置 $d_j=0$。优化问题是在约束条件下找到 $\\|d\\|_2 = \\sqrt{d_{i_k}^2 + d_{i_{k+1}}^2}$ 的最小值。\n\n目标是扰动 $x_{i_k}$ 和 $x_{i_{k+1}}$，使其大小相等。设这个共同的目标大小为 $M$。因此，有 $|x_{i_k} + d_{i_k}| = M$ 和 $|x_{i_{k+1}} + d_{i_{k+1}}| = M$。\n为以最小的扰动实现这一目标，我们必须减小 $x_{i_k}$ 的大小（因为 $|x_{i_k}|=|x|_{(k)}  |x|_{(k+1)}=|x_{i_{k+1}}|$），并增加 $x_{i_{k+1}}$ 的大小。改变一个标量大小的最有效方法是沿其方向加上或减去一个值。\n- 要将 $|x_{i_k}|$ 减小到 $M$，最小的扰动 $d_{i_k}$ 的大小为 $|d_{i_k}| = |x_{i_k}| - M = |x|_{(k)} - M$。这是通过选择与 $x_{i_k}$ 反平行的 $d_{i_k}$ 来实现的。这要求 $M  |x|_{(k)}$。\n- 要将 $|x_{i_{k+1}}|$ 增加到 $M$，最小的扰动 $d_{i_{k+1}}$ 的大小为 $|d_{i_{k+1}}| = M - |x_{i_{k+1}}| = M - |x|_{(k+1)}$。这是通过选择与 $x_{i_{k+1}}$ 平行的 $d_{i_{k+1}}$ 来实现的。这要求 $M  |x|_{(k+1)}$。\n因此，目标大小 $M$ 必须位于区间 $(|x|_{(k+1)}, |x|_{(k)})$ 内。\n\n扰动向量 $d$ 的欧几里得范数的平方是其非零分量大小的平方和：\n$$\n\\|d\\|_2^2 = |d_{i_k}|^2 + |d_{i_{k+1}}|^2 = (|x|_{(k)} - M)^2 + (M - |x|_{(k+1)})^2\n$$\n我们需要找到使该表达式最小化的 $M$ 值。令 $L(M) = (|x|_{(k)} - M)^2 + (M - |x|_{(k+1)})^2$。为求最小值，我们将 $L(M)$ 对 $M$ 求导，并令导数为零：\n$$\n\\frac{dL}{dM} = 2(|x|_{(k)} - M)(-1) + 2(M - |x|_{(k+1)})(1) = -2|x|_{(k)} + 2M + 2M - 2|x|_{(k+1)}\n$$\n$$\n\\frac{dL}{dM} = 4M - 2(|x|_{(k)} + |x|_{(k+1)})\n$$\n令 $\\frac{dL}{dM} = 0$:\n$$\n4M = 2(|x|_{(k)} + |x|_{(k+1)}) \\implies M = \\frac{|x|_{(k)} + |x|_{(k+1)}}{2}\n$$\n这个 $M$ 值是两个初始大小的算术平均值，并且它位于所需区间 $(|x|_{(k+1)}, |x|_{(k)})$ 内。二阶导数 $\\frac{d^2L}{dM^2} = 4  0$ 证实了这是一个最小值。\n\n现在，我们将这个最优 $M$ 值代回到扰动分量大小的表达式中：\n第 $k$ 个分量的变化大小为：\n$$\n|d_{i_k}| = |x|_{(k)} - M = |x|_{(k)} - \\frac{|x|_{(k)} + |x|_{(k+1)}}{2} = \\frac{2|x|_{(k)} - |x|_{(k)} - |x|_{(k+1)}}{2} = \\frac{|x|_{(k)} - |x|_{(k+1)}}{2}\n$$\n使用支撑间隙的定义 $g = |x|_{(k)} - |x|_{(k+1)}$，我们得到 $|d_{i_k}| = \\frac{g}{2}$。\n\n第 $(k+1)$ 个分量的变化大小为：\n$$\n|d_{i_{k+1}}| = M - |x|_{(k+1)} = \\frac{|x|_{(k)} + |x|_{(k+1)}}{2} - |x|_{(k+1)} = \\frac{|x|_{(k)} + |x|_{(k+1)} - 2|x|_{(k+1)}}{2} = \\frac{|x|_{(k)} - |x|_{(k+1)}}{2}\n$$\n这得到 $|d_{i_{k+1}}| = \\frac{g}{2}$。\n\n最小对抗半径 $\\epsilon^{\\star}$ 是这个最小扰动向量 $d$ 的范数。范数的平方为：\n$$\n(\\epsilon^{\\star})^2 = \\|d\\|_2^2 = |d_{i_k}|^2 + |d_{i_{k+1}}|^2 = \\left(\\frac{g}{2}\\right)^2 + \\left(\\frac{g}{2}\\right)^2 = \\frac{g^2}{4} + \\frac{g^2}{4} = \\frac{2g^2}{4} = \\frac{g^2}{2}\n$$\n取平方根得到最小半径：\n$$\n\\epsilon^{\\star} = \\sqrt{\\frac{g^2}{2}} = \\frac{g}{\\sqrt{2}}\n$$\n这是使第 $k$ 和第 $(k+1)$ 个分量的大小相等所需的最小扰动范数，从而为支撑集变化创造了条件。任何更小的范数都不足以以这种方式弥合间隙 $g$。", "answer": "$$\n\\boxed{\\frac{g}{\\sqrt{2}}}\n$$", "id": "3469834"}, {"introduction": "从抽象属性转向实际应用，这个练习 [@problem_id:3469788] 在一个常见的信号去噪场景中评估硬阈值算子的性能。通过推导其偏差（bias）和均方误差（MSE）风险的解析表达式，您将能更深刻地理解它作为一种估计量的统计行为和内在权衡，特别是与另一著名算子——软阈值算子相比较时。", "problem": "考虑压缩感知和稀疏优化中的一个标准加性高斯噪声模型。设 $x \\in \\mathbb{R}^n$ 是一个 $k$-稀疏向量，意味着其恰好有 $k$ 个非零项和 $n-k$ 个零项。观测值由 $y = x + \\varepsilon$ 给出，其中 $\\varepsilon \\in \\mathbb{R}^n$ 的分量 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立同分布的，且噪声方差 $\\sigma^2  0$ 已知。考虑两种逐元素阈值估计器：\n\n- 硬阈值算子 $H_{\\tau}$，其阈值为 $\\tau \\ge 0$，按分量定义为 $H_{\\tau}(y_i) = y_i \\cdot \\mathbf{1}\\{ |y_i| \\ge \\tau \\}$。\n- 软阈值算子 $S_{\\tau}$，其阈值为 $\\tau \\ge 0$，按分量定义为 $S_{\\tau}(y_i) = \\operatorname{sign}(y_i) \\cdot \\max\\{ |y_i| - \\tau, 0 \\}$。\n\n所有操作均独立地应用于每个坐标。\n\n基本原理和目标：\n- 使用上述定义以及关于高斯分布（特别是标准正态概率密度函数和累积分布函数）、指示函数和期望的公认事实，推导这些算子在标量模型下的估计器偏差和均方误差 (MSE) 风险的表达式。具体来说，考虑单个坐标，其真实值为 $\\mu \\in \\mathbb{R}$，观测值为 $Y = \\mu + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n- 定义标量估计器偏差为 $b_{\\mathrm{op}}(\\mu;\\sigma,\\tau) = \\mathbb{E}[T_{\\tau}(Y)] - \\mu$，其中算子 $T_{\\tau} \\in \\{ H_{\\tau}, S_{\\tau} \\}$ 作用于标量 $Y$；定义标量 MSE 风险为 $r_{\\mathrm{op}}(\\mu;\\sigma,\\tau) = \\mathbb{E}[(T_{\\tau}(Y) - \\mu)^2]$。\n- 对于一个 $k$-稀疏向量 $x$，其恰好有 $k$ 个分量等于同一个非零值 $\\mu$（其余分量等于 $0$），定义混合比例 $p = k/n$，并定义算子 $T_{\\tau}$ 的每坐标平均偏差和风险为\n$$\nB_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau) = p \\cdot b_{\\mathrm{op}}(\\mu;\\sigma,\\tau) + (1-p) \\cdot b_{\\mathrm{op}}(0;\\sigma,\\tau),\n$$\n$$\nR_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau) = p \\cdot r_{\\mathrm{op}}(\\mu;\\sigma,\\tau) + (1-p) \\cdot r_{\\mathrm{op}}(0;\\sigma,\\tau).\n$$\n\n稀疏度和信噪比参数化：\n- 定义每活动项的信噪比为 $\\mathrm{SNR}_{\\mathrm{active}} = \\mu^2 / \\sigma^2$。对于给定的 $\\sigma  0$ 和 $\\mathrm{SNR}_{\\mathrm{active}} \\ge 0$，设置 $\\mu = \\sigma \\sqrt{\\mathrm{SNR}_{\\mathrm{active}}}$。\n\n任务：\n- 对于每个指定的测试用例，计算硬阈值算子 $H_{\\tau}$ 和软阈值算子 $S_{\\tau}$ 的每坐标平均 MSE 风险曲线 $\\tau \\mapsto R_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau)$。计算范围为一个均匀网格，包含 $L = 1001$ 个点，从 $\\tau = 0$ 到 $\\tau_{\\max}$，其中\n$$\n\\tau_{\\max} = \\sigma \\left( 6 + \\sqrt{\\mathrm{SNR}_{\\mathrm{active}}} \\right).\n$$\n- 对于每个算子 $T_{\\tau} \\in \\{ H_{\\tau}, S_{\\tau} \\}$，在网格中找出使 $R_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau)$ 最小化的阈值 $\\tau^{\\star}$（若有多个最小值，则取最小的 $\\tau$）。在此 $\\tau^{\\star}$ 处，同时计算相应的每坐标平均偏差 $B_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau^{\\star})$。\n- 你的程序必须为每个测试用例输出一个包含6个浮点数的元组\n$[\\tau^{\\star}_{H}, R_{H}^{\\star}, B_{H}^{\\star}, \\tau^{\\star}_{S}, R_{S}^{\\star}, B_{S}^{\\star}]$，\n其中下标 $H$ 和 $S$ 分别代表硬阈值和软阈值，上标 $\\star$ 表示在相应算子风险曲线的最小值点处取值。\n\n测试套件：\n- 用例 1：$(n, k, \\sigma, \\mathrm{SNR}_{\\mathrm{active}}) = (1000, 10, 1.0, 1.0)$。\n- 用例 2：$(n, k, \\sigma, \\mathrm{SNR}_{\\mathrm{active}}) = (1000, 100, 1.0, 0.1)$。\n- 用例 3：$(n, k, \\sigma, \\mathrm{SNR}_{\\mathrm{active}}) = (1000, 10, 1.0, 10.0)$。\n- 用例 4：$(n, k, \\sigma, \\mathrm{SNR}_{\\mathrm{active}}) = (1000, 0, 1.0, 0.0)$。\n- 用例 5：$(n, k, \\sigma, \\mathrm{SNR}_{\\mathrm{active}}) = (1000, 1000, 1.0, 1.0)$。\n\n答案规范：\n- 最终输出必须是单行文本，包含一个由浮点数组成的扁平化、逗号分隔的列表，该列表通过按顺序 1 到 5 串联 5 个用例的 6 元组构成：\n$[\\tau^{\\star}_{H,1}, R_{H,1}^{\\star}, B_{H,1}^{\\star}, \\tau^{\\star}_{S,1}, R_{S,1}^{\\star}, B_{S,1}^{\\star}, \\dots, \\tau^{\\star}_{H,5}, R_{H,5}^{\\star}, B_{H,5}^{\\star}, \\tau^{\\star}_{S,5}, R_{S,5}^{\\star}, B_{S,5}^{\\star}]$。\n- 本问题不涉及物理单位。所有报告的数值必须是浮点数。", "solution": "该问题要求在高斯去噪背景下分析硬阈值和软阈值估计器。我们的任务是计算这些估计器的平均偏差和均方误差 (MSE) 风险，在给定范围内找到最优阈值，并为一系列测试用例报告最优阈值、最小化风险以及相应的偏差。\n\n解决方案分四个阶段进行：\n1.  推导通用信号值 $\\mu$ 的标量偏差和均方误差。\n2.  将这些公式特化到零信号情况，即 $\\mu=0$。\n3.  使用指定的混合模型结合 $\\mu \\neq 0$ 和 $\\mu=0$ 的情况，得到每坐标的平均偏差和风险。\n4.  描述为每个测试用例寻找最优阈值及相关量的数值计算过程。\n\n设单个坐标的观测数据为 $Y = \\mu + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)$。我们定义一个标准化随机变量 $Z = (Y-\\mu)/\\sigma \\sim \\mathcal{N}(0,1)$。令 $\\phi(z)$ 和 $\\Phi(z)$ 分别表示标准正态分布的概率密度函数 (PDF) 和累积分布函数 (CDF)。所有的期望 $\\mathbb{E}[\\cdot]$ 都是关于 $Y$ 的分布计算的。\n\n为了简化积分表达式，我们引入用于积分限的归一化阈值：\n$$a_{\\tau}(\\mu, \\sigma) = \\frac{\\tau - \\mu}{\\sigma}$$\n$$b_{\\tau}(\\mu, \\sigma) = \\frac{-\\tau - \\mu}{\\sigma}$$\n为简洁起见，在对 $\\mu$ 和 $\\sigma$ 的依赖关系从上下文中明确时，我们将它们写为 $a_{\\tau}$ 和 $b_{\\tau}$。\n\n估计器 $T_{\\tau}(Y)$ 的标量偏差为 $b_{\\mathrm{op}}(\\mu;\\sigma,\\tau) = \\mathbb{E}[T_{\\tau}(Y)] - \\mu$，标量均方误差风险为 $r_{\\mathrm{op}}(\\mu;\\sigma,\\tau) = \\mathbb{E}[(T_{\\tau}(Y) - \\mu)^2]$。\n\n### 1. 硬阈值算子 ($H_{\\tau}$)\n\n硬阈值算子定义为 $H_{\\tau}(y) = y \\cdot \\mathbf{1}\\{|y| \\ge \\tau\\}$。\n\n**标量偏差 $b_H(\\mu;\\sigma,\\tau)$:**\n该估计器的期望为：\n$$ \\mathbb{E}[H_{\\tau}(Y)] = \\int_{-\\infty}^{-\\tau} y \\phi_{\\mu,\\sigma^2}(y) dy + \\int_{\\tau}^{\\infty} y \\phi_{\\mu,\\sigma^2}(y) dy $$\n使用恒等式 $\\int y \\phi_{\\mu,\\sigma^2}(y) dy = \\sigma \\int z \\phi(z) d(z) + \\mu \\int \\phi(z) d(z) = -\\sigma \\phi(z) + \\mu \\Phi(z) + C$，其中 $z=(y-\\mu)/\\sigma$，我们计算定积分：\n$$ \\mathbb{E}[H_{\\tau}(Y)] = \\left[\\mu\\Phi(b_{\\tau}) - \\sigma\\phi(b_{\\tau})\\right] + \\left[\\mu(1-\\Phi(a_{\\tau})) + \\sigma\\phi(a_{\\tau})\\right] $$\n偏差即为 $b_H(\\mu;\\sigma,\\tau) = \\mathbb{E}[H_{\\tau}(Y)] - \\mu$:\n$$ b_H(\\mu;\\sigma,\\tau) = -\\mu(\\Phi(a_{\\tau}) - \\Phi(b_{\\tau})) + \\sigma(\\phi(a_{\\tau}) - \\phi(b_{\\tau})) $$\n\n**标量均方误差风险 $r_H(\\mu;\\sigma,\\tau)$:**\n风险是平方误差的期望，即 $\\mathbb{E}[(H_{\\tau}(Y) - \\mu)^2]$。我们可以根据 $|Y|$ 是否超过阈值 $\\tau$ 来分解它：\n$$ r_H(\\mu) = \\mathbb{E}[(0-\\mu)^2 \\mathbf{1}\\{|Y|  \\tau\\}] + \\mathbb{E}[(Y-\\mu)^2 \\mathbf{1}\\{|Y| \\ge \\tau\\}] $$\n第一项是 $\\mu^2 P(|Y|  \\tau) = \\mu^2 (\\Phi(a_{\\tau}) - \\Phi(b_{\\tau}))$。\n第二项是 $\\int_{|y|\\ge\\tau} (y-\\mu)^2 \\phi_{\\mu,\\sigma^2}(y) dy$。换元为 $z=(y-\\mu)/\\sigma$，此项变为 $\\sigma^2 \\int_{z \\in (-\\infty, b_{\\tau}] \\cup [a_{\\tau}, \\infty)} z^2 \\phi(z) dz$。\n使用 $\\int z^2\\phi(z)dz = -z\\phi(z)+\\Phi(z) + C$，该积分计算结果为 $\\sigma^2(1 - \\Phi(a_{\\tau}) + \\Phi(b_{\\tau}) + a_{\\tau}\\phi(a_{\\tau}) - b_{\\tau}\\phi(b_{\\tau}))$。\n将各部分贡献相加，风险为：\n$$ r_H(\\mu;\\sigma,\\tau) = \\mu^2(\\Phi(a_{\\tau}) - \\Phi(b_{\\tau})) + \\sigma^2(1 - \\Phi(a_{\\tau}) + \\Phi(b_{\\tau}) + a_{\\tau}\\phi(a_{\\tau}) - b_{\\tau}\\phi(b_{\\tau})) $$\n\n### 2. 软阈值算子 ($S_{\\tau}$)\n\n软阈值算子定义为 $S_{\\tau}(y) = \\operatorname{sign}(y) \\max(|y|-\\tau, 0)$。\n\n**标量偏差 $b_S(\\mu;\\sigma,\\tau)$:**\n期望为 $\\mathbb{E}[S_{\\tau}(Y)] = \\int_{-\\infty}^{-\\tau}(y+\\tau)\\phi_{\\mu,\\sigma^2}(y)dy + \\int_{\\tau}^{\\infty}(y-\\tau)\\phi_{\\mu,\\sigma^2}(y)dy$。\n我们展开此式并使用之前的积分形式：\n$$ \\mathbb{E}[S_{\\tau}(Y)] = \\left(\\mathbb{E}[Y\\mathbf{1}\\{Y  -\\tau\\}] + \\tau P(Y  -\\tau)\\right) + \\left(\\mathbb{E}[Y\\mathbf{1}\\{Y\\tau\\}] - \\tau P(Y\\tau)\\right) $$\n$$ \\mathbb{E}[S_{\\tau}(Y)] = (\\mu\\Phi(b_{\\tau}) - \\sigma\\phi(b_{\\tau}) + \\tau\\Phi(b_{\\tau})) + (\\mu(1-\\Phi(a_{\\tau})) + \\sigma\\phi(a_{\\tau}) - \\tau(1-\\Phi(a_{\\tau}))) $$\n偏差为 $b_S(\\mu;\\sigma,\\tau) = \\mathbb{E}[S_{\\tau}(Y)] - \\mu$:\n$$ b_S(\\mu;\\sigma,\\tau) = (\\mu-\\tau)(1-\\Phi(a_{\\tau})) + (\\mu+\\tau)\\Phi(b_{\\tau}) + \\sigma(\\phi(a_{\\tau}) - \\phi(b_{\\tau})) - \\mu $$\n\n**标量均方误差风险 $r_S(\\mu;\\sigma,\\tau)$:**\n风险为 $\\mathbb{E}[(S_{\\tau}(Y) - \\mu)^2]$。我们按区域分解：\n$$ r_S(\\mu) = \\mathbb{E}[(0-\\mu)^2 \\mathbf{1}\\{|Y|  \\tau\\}] + \\mathbb{E}[(Y+\\tau-\\mu)^2 \\mathbf{1}\\{Y  -\\tau\\}] + \\mathbb{E}[(Y-\\tau-\\mu)^2 \\mathbf{1}\\{Y > \\tau\\}] $$\n第一项是 $\\mu^2 P(|Y|  \\tau) = \\mu^2(\\Phi(a_{\\tau}) - \\Phi(b_{\\tau}))$。\n第二项 $\\int_{-\\infty}^{-\\tau}(y+\\tau-\\mu)^2\\phi_{\\mu,\\sigma^2}(y)dy$，换元后变为 $\\int_{-\\infty}^{b_{\\tau}}(\\sigma z+\\tau)^2\\phi(z)dz$。其计算结果为 $(\\sigma^2+\\tau^2)\\Phi(b_{\\tau}) - \\sigma(\\tau-\\mu)\\phi(b_{\\tau})$。\n第三项 $\\int_{\\tau}^{\\infty}(y-\\tau-\\mu)^2\\phi_{\\mu,\\sigma^2}(y)dy$，换元后变为 $\\int_{a_{\\tau}}^{\\infty}(\\sigma z-\\tau)^2\\phi(z)dz$。其计算结果为 $(\\sigma^2+\\tau^2)(1-\\Phi(a_{\\tau})) - \\sigma(\\tau+\\mu)\\phi(a_{\\tau})$。\n将三部分贡献相加得到风险：\n$$ r_S(\\mu;\\sigma,\\tau) = \\mu^2(\\Phi(a_{\\tau})-\\Phi(b_{\\tau})) + (\\sigma^2+\\tau^2)(1-\\Phi(a_{\\tau})+\\Phi(b_{\\tau})) - \\sigma(\\tau+\\mu)\\phi(a_{\\tau}) - \\sigma(\\tau-\\mu)\\phi(b_{\\tau}) $$\n\n### 3. 特殊情况：$\\mu = 0$\n\n当真实信号为零（$\\mu=0$）时，我们有 $a_{\\tau}(0,\\sigma) = \\tau/\\sigma$ 和 $b_{\\tau}(0,\\sigma) = -\\tau/\\sigma$。由于高斯分布的对称性（$\\phi(z)=\\phi(-z)$ 和 $\\Phi(-z)=1-\\Phi(z)$），公式得以简化。\n-   $b_H(0;\\sigma,\\tau) = 0$\n-   $b_S(0;\\sigma,\\tau) = 0$\n-   $r_H(0;\\sigma,\\tau) = 2\\sigma^2(1 - \\Phi(\\tau/\\sigma) + (\\tau/\\sigma)\\phi(\\tau/\\sigma))$\n-   $r_S(0;\\sigma,\\tau) = 2(\\sigma^2+\\tau^2)(1 - \\Phi(\\tau/\\sigma)) - 2\\sigma\\tau\\phi(\\tau/\\sigma)$\n\n### 4. 聚合与计算过程\n\n对于一个 $k$-稀疏向量，其中 $k$ 个分量为 $\\mu$，$n-k$ 个分量为 $0$，每坐标平均偏差 $B_{\\mathrm{op}}$ 和风险 $R_{\\mathrm{op}}$ 是混合比例为 $p=k/n$ 的混合模型：\n$$ B_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau) = p \\cdot b_{\\mathrm{op}}(\\mu;\\sigma,\\tau) + (1-p) \\cdot b_{\\mathrm{op}}(0;\\sigma,\\tau) = p \\cdot b_{\\mathrm{op}}(\\mu;\\sigma,\\tau) $$\n$$ R_{\\mathrm{op}}(p,\\mu;\\sigma,\\tau) = p \\cdot r_{\\mathrm{op}}(\\mu;\\sigma,\\tau) + (1-p) \\cdot r_{\\mathrm{op}}(0;\\sigma,\\tau) $$\n对于每个测试用例，给定 $(n, k, \\sigma, \\mathrm{SNR}_{\\mathrm{active}})$。我们计算 $p = k/n$ 和 $\\mu = \\sigma \\sqrt{\\mathrm{SNR}_{\\mathrm{active}}}$。然后我们构建一个包含 $L=1001$ 个阈值 $\\tau$ 的均匀网格，范围从 $0$ 到 $\\tau_{\\max} = \\sigma ( 6 + \\sqrt{\\mathrm{SNR}_{\\mathrm{active}}} )$。\n对于每个算子（$H$ 和 $S$），我们在 $\\tau$ 网格的每个点上评估其平均风险 $R_{\\mathrm{op}}$。然后我们找到使该风险最小化的阈值 $\\tau^{\\star}$（若有并列，则取最小的 $\\tau$）。最后，我们在这个最优阈值 $\\tau^{\\star}$ 处计算平均偏差 $B_{\\mathrm{op}}$。为每个测试用例计算得到的 6 元组 $[\\tau^{\\star}_{H}, R_{H}^{\\star}, B_{H}^{\\star}, \\tau^{\\star}_{S}, R_{S}^{\\star}, B_{S}^{\\star}]$。最终输出是这些元组的串联。\n\n下面的Python代码实现了这一计算过程。\n```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef compute_scalar_metrics(mu, sigma, tau_grid):\n    \"\"\"\n    Computes scalar bias and MSE risk for hard and soft thresholding operators.\n\n    Args:\n        mu (float): The true signal value.\n        sigma (float): The standard deviation of the Gaussian noise.\n        tau_grid (np.ndarray): A grid of threshold values.\n\n    Returns:\n        tuple: A tuple of four np.ndarray objects:\n               (b_H, r_H, b_S, r_S) for bias and risk of Hard and Soft operators.\n    \"\"\"\n    # To prevent division by zero if sigma is hypothetically zero.\n    # The problem statement guarantees sigma > 0.\n    sigma = np.maximum(sigma, 1e-15)\n    \n    a_tau = (tau_grid - mu) / sigma\n    b_tau = (-tau_grid - mu) / sigma\n\n    phi_a = norm.pdf(a_tau)\n    phi_b = norm.pdf(b_tau)\n    Phi_a = norm.cdf(a_tau)\n    Phi_b = norm.cdf(b_tau)\n\n    # Common term for risk: mu^2 * P(|Y|  tau)\n    risk_common_term = mu**2 * (Phi_a - Phi_b)\n\n    # Hard Thresholding\n    b_H = -mu * (Phi_a - Phi_b) + sigma * (phi_a - phi_b)\n    \n    risk_H_term2 = sigma**2 * (1 - Phi_a + Phi_b + a_tau * phi_a - b_tau * phi_b)\n    r_H = risk_common_term + risk_H_term2\n\n    # Soft Thresholding\n    b_S = (mu - tau_grid) * (1 - Phi_a) + (mu + tau_grid) * Phi_b + sigma * (phi_a - phi_b) - mu\n    \n    risk_S_term2 = (sigma**2 + tau_grid**2) * (1 - Phi_a + Phi_b)\n    risk_S_term3 = -sigma * (tau_grid + mu) * phi_a\n    risk_S_term4 = -sigma * (tau_grid - mu) * phi_b\n    r_S = risk_common_term + risk_S_term2 + risk_S_term3 + risk_S_term4\n    \n    return b_H, r_H, b_S, r_S\n\ndef solve_for_test_cases():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (1000, 10, 1.0, 1.0),\n        (1000, 100, 1.0, 0.1),\n        (1000, 10, 1.0, 10.0),\n        (1000, 0, 1.0, 0.0),\n        (1000, 1000, 1.0, 1.0),\n    ]\n\n    L = 1001\n    all_results = []\n\n    for n, k, sigma, snr_active in test_cases:\n        p = k / n\n        mu = sigma * np.sqrt(snr_active)\n        \n        tau_max = sigma * (6 + np.sqrt(snr_active))\n        tau_grid = np.linspace(0, tau_max, L)\n\n        if np.isclose(mu, 0.0):\n             bh_mu, rh_mu, bs_mu, rs_mu = (np.zeros_like(tau_grid) for _ in range(4))\n        else:\n            bh_mu, rh_mu, bs_mu, rs_mu = compute_scalar_metrics(mu, sigma, tau_grid)\n        \n        if p  1:\n            _, rh_0, _, rs_0 = compute_scalar_metrics(0, sigma, tau_grid)\n        else:\n            rh_0 = np.zeros_like(tau_grid)\n            rs_0 = np.zeros_like(tau_grid)\n\n        B_H_curve = p * bh_mu\n        B_S_curve = p * bs_mu\n        \n        R_H_curve = p * rh_mu + (1 - p) * rh_0\n        R_S_curve = p * rs_mu + (1 - p) * rs_0\n\n        idx_h_star = np.argmin(R_H_curve)\n        tau_h_star = tau_grid[idx_h_star]\n        r_h_star = R_H_curve[idx_h_star]\n        b_h_star = B_H_curve[idx_h_star]\n\n        idx_s_star = np.argmin(R_S_curve)\n        tau_s_star = tau_grid[idx_s_star]\n        r_s_star = R_S_curve[idx_s_star]\n        b_s_star = B_S_curve[idx_s_star]\n\n        all_results.extend([tau_h_star, r_h_star, b_h_star, tau_s_star, r_s_star, b_s_star])\n    \n    return all_results\n```", "answer": "2.387000,0.010419,-0.003923,1.484000,0.010260,-0.007633,1.942940,0.088657,-0.016335,1.401400,0.078235,-0.052685,3.168530,0.018868,-0.000306,3.580210,0.017773,-0.002878,0.000000,0.999000,0.000000,0.000000,1.000000,0.000000,1.505000,0.380753,-0.370776,0.616000,0.380183,-0.490800", "id": "3469788"}]}