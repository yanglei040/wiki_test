{"hands_on_practices": [{"introduction": "本练习是理解拉格朗日乘子法的基础。通过一个简单的一维双杆系统，我们将从第一性原理出发，推导出包含约束的 Karush-Kuhn-Tucker (KKT) 系统。这个过程将具体展示运动学约束如何转化为有限元系统矩阵特有的鞍点结构，帮助你建立对约束系统代数形式的直观理解 ([@problem_id:3512475])。", "problem": "考虑一个由两根串联的线性弹性杆组成的一维轴向双杆系统。左杆占据区间 $x \\in [0,L_1]$，具有恒定的轴向刚度 $E_1A_1$；右杆占据区间 $x \\in [L_1,L_1+L_2]$，具有恒定的轴向刚度 $E_2A_2$。左端 $x=0$ 处固定，即 $u(0)=0$，右端 $x=L_1+L_2$ 处承受一个沿轴向的节点荷载 $p$。每根杆都使用单个一阶拉格朗日有限元（$P_1$）进行离散化，因此左杆在 $x=L_1$ 处有节点未知量 $u_1^{-}$（其位于 $x=0$ 的左端节点是给定的并被消去），而右杆在 $x=L_1$ 处有节点未知量 $u_1^{+}$，在 $x=L_1+L_2$ 处有节点未知量 $u_R$。为了在多物理场耦合仿真中强制实现界面 $x=L_1$ 处的运动学连续性，在界面处引入一个拉格朗日乘子 $\\lambda$ 来强制满足 $u_1^{-}=u_1^{+}$。\n\n从轴向弹性的虚功原理和标准的一阶有限元组装出发（不预设或提示任何目标公式），推导离散的 Karush–Kuhn–Tucker (KKT) 系统，其中未知向量为 $(u_1^{-},\\,u_1^{+},\\,u_R,\\,\\lambda)^{\\top}$。用 $E_1$、$A_1$、$L_1$、$E_2$、$A_2$ 和 $L_2$ 的符号表示最终的 KKT 矩阵。识别强制连续性的约束行的代数结构，以及它如何与原始未知量耦合。最终答案只提供 KKT 矩阵。无需四舍五入；精确表示答案。缩写 KKT 代表 Karush–Kuhn–Tucker，而 $P_1$ 在有限元法 (FEM) 中表示一阶拉格朗日有限元。", "solution": "本问题要求推导一个使用拉格朗日乘子在界面处耦合的双杆组件的 Karush–Kuhn–Tucker (KKT) 系统。推导过程从虚功原理开始，这对于保守系统而言，等同于求解总势能泛函的驻点。\n\n系统的总势能 $\\Pi$ 是储存在两根杆中的应变能 $U$ 与外荷载 $p$ 的势能 $W_{\\text{ext}}$ 之差。\n$$ \\Pi = U - W_{\\text{ext}} = U_1 + U_2 - W_{\\text{ext}} $$\n其中 $U_1$ 和 $U_2$ 分别是杆1和杆2的应变能。\n\n一维弹性杆的应变能由下式给出：\n$$ U = \\frac{1}{2} \\int_{0}^{L} EA \\left( \\frac{du}{dx} \\right)^2 dx $$\n其中 $E$ 是杨氏模量，$A$ 是横截面积，$L$ 是长度，$u(x)$ 是轴向位移场。\n\n问题陈述，在界面 $x=L_1$ 处的运动学连续性通过拉格朗日乘子 $\\lambda$ 来强制实现。约束方程为 $g(u_1^{-}, u_1^{+}) = u_1^{-} - u_1^{+} = 0$。我们通过将总势能与约束项相加来构造拉格朗日泛函 $\\mathcal{L}$：\n$$ \\mathcal{L}(u, \\lambda) = \\Pi + \\lambda g = U_1 + U_2 - W_{\\text{ext}} + \\lambda(u_1^{-} - u_1^{+}) $$\nKKT 条件是通过将 $\\mathcal{L}$ 对所有自由度的一阶变分设为零来求得的。\n\n我们来离散化系统。每根杆都用一个一阶（$P_1$）有限元建模。\n\n对于杆1，占据 $x \\in [0, L_1]$：\n位移场为 $u^{(1)}(x)$。节点位移为 $u(0)$ 和在 $x=L_1$ 处的 $u_1^{-}$。鉴于固定边界条件 $u(0)=0$，位移场可插值为：\n$$ u^{(1)}(x) = \\left(\\frac{x}{L_1}\\right) u_1^{-} $$\n轴向应变为常数：$\\epsilon_1 = \\frac{d u^{(1)}}{dx} = \\frac{u_1^{-}}{L_1}$。\n杆1中的应变能为：\n$$ U_1 = \\frac{1}{2} \\int_0^{L_1} E_1A_1 (\\epsilon_1)^2 dx = \\frac{1}{2} E_1A_1 \\left(\\frac{u_1^{-}}{L_1}\\right)^2 \\int_0^{L_1} dx = \\frac{1}{2} \\frac{E_1A_1}{L_1} (u_1^{-})^2 $$\n\n对于杆2，占据 $x \\in [L_1, L_1+L_2]$：\n使用局部坐标 $\\xi = x - L_1$（其中 $\\xi \\in [0, L_2]$）会很方便。节点位移是在 $\\xi=0$ 处的 $u_1^{+}$ 和在 $\\xi=L_2$ 处的 $u_R$。位移场可插值为：\n$$ u^{(2)}(\\xi) = \\left(1 - \\frac{\\xi}{L_2}\\right) u_1^{+} + \\left(\\frac{\\xi}{L_2}\\right) u_R $$\n轴向应变为常数：$\\epsilon_2 = \\frac{d u^{(2)}}{d\\xi} = \\frac{u_R - u_1^{+}}{L_2}$。\n杆2中的应变能为：\n$$ U_2 = \\frac{1}{2} \\int_0^{L_2} E_2A_2 (\\epsilon_2)^2 d\\xi = \\frac{1}{2} E_2A_2 \\left(\\frac{u_R - u_1^{+}}{L_2}\\right)^2 \\int_0^{L_2} d\\xi = \\frac{1}{2} \\frac{E_2A_2}{L_2} (u_R - u_1^{+})^2 $$\n这可以展开为：\n$$ U_2 = \\frac{1}{2} \\frac{E_2A_2}{L_2} \\left((u_1^{+})^2 - 2u_1^{+}u_R + (u_R)^2\\right) $$\n\n施加在 $x=L_1+L_2$ 处的外荷载 $p$ 所做的功是：\n$$ W_{\\text{ext}} = p u_R $$\n\n现在，用离散未知数 $(u_1^{-}, u_1^{+}, u_R, \\lambda)$ 组装完整的拉格朗日泛函：\n$$ \\mathcal{L}(u_1^{-}, u_1^{+}, u_R, \\lambda) = \\frac{1}{2} \\frac{E_1A_1}{L_1} (u_1^{-})^2 + \\frac{1}{2} \\frac{E_2A_2}{L_2} (u_R - u_1^{+})^2 - p u_R + \\lambda(u_1^{-} - u_1^{+}) $$\n\n为了找到驻点，我们求 $\\mathcal{L}$ 对每个未知数的偏导数，并将其设为零。\n1.  $\\frac{\\partial \\mathcal{L}}{\\partial u_1^{-}} = \\frac{E_1A_1}{L_1} u_1^{-} + \\lambda = 0$\n2.  $\\frac{\\partial \\mathcal{L}}{\\partial u_1^{+}} = -\\frac{E_2A_2}{L_2} (u_R - u_1^{+}) - \\lambda = \\frac{E_2A_2}{L_2} u_1^{+} - \\frac{E_2A_2}{L_2} u_R - \\lambda = 0$\n3.  $\\frac{\\partial \\mathcal{L}}{\\partial u_R} = \\frac{E_2A_2}{L_2} (u_R - u_1^{+}) - p = -\\frac{E_2A_2}{L_2} u_1^{+} + \\frac{E_2A_2}{L_2} u_R - p = 0$\n4.  $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = u_1^{-} - u_1^{+} = 0$\n\n这四个线性方程构成了 KKT 系统。我们把它们写成矩阵形式 $\\mathbf{K}_{\\text{KKT}} \\mathbf{d} = \\mathbf{f}$，其中未知向量为 $\\mathbf{d} = (u_1^{-}, u_1^{+}, u_R, \\lambda)^{\\top}$。\n\n从方程1：$(\\frac{E_1A_1}{L_1}) u_1^{-} + (0) u_1^{+} + (0) u_R + (1) \\lambda = 0$\n从方程2：$(0) u_1^{-} + (\\frac{E_2A_2}{L_2}) u_1^{+} - (\\frac{E_2A_2}{L_2}) u_R - (1) \\lambda = 0$\n从方程3：$(0) u_1^{-} - (\\frac{E_2A_2}{L_2}) u_1^{+} + (\\frac{E_2A_2}{L_2}) u_R + (0) \\lambda = p$\n从方程4：$(1) u_1^{-} - (1) u_1^{+} + (0) u_R + (0) \\lambda = 0$\n\n将这些组装成 KKT 矩阵系统，得到：\n$$\n\\begin{pmatrix}\n\\frac{E_1A_1}{L_1} & 0 & 0 & 1 \\\\\n0 & \\frac{E_2A_2}{L_2} & -\\frac{E_2A_2}{L_2} & -1 \\\\\n0 & -\\frac{E_2A_2}{L_2} & \\frac{E_2A_2}{L_2} & 0 \\\\\n1 & -1 & 0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nu_1^{-} \\\\\nu_1^{+} \\\\\nu_R \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\np \\\\\n0\n\\end{pmatrix}\n$$\n左边的矩阵是 KKT 矩阵。它具有约束优化问题特有的对称鞍点结构。左上角的 $3 \\times 3$ 分块是未耦合原始系统的刚度矩阵 $\\mathbf{K}$，由于两根杆尚未连接，因此它是块对角矩阵。最后一行和最后一列（通常表示为 $\\mathbf{B}$ 和 $\\mathbf{B}^\\top$）代表耦合约束。\n\n问题要求说明约束行的代数结构。第四行 $(1, -1, 0, 0)$ 直接表示离散约束方程 $u_1^{-} - u_1^{+} = 0$。它的非零项 $(1, -1)$ 在界面处耦合了原始未知量 $u_1^{-}$ 和 $u_1^{+}$。第四列 $(1, -1, 0, 0)^\\top$ 显示了拉格朗日乘子 $\\lambda$ 如何作为力作用于原始自由度：它对 $u_1^{-}$ 自由度施加一个力 $+\\lambda$，对 $u_1^{+}$ 自由度施加一个大小相等、方向相反的力 $-\\lambda$，这即是强制连续性的接触力的物理解释。\n\n最终的 KKT 矩阵由此推导得出。", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{E_1A_1}{L_1} & 0 & 0 & 1 \\\\ 0 & \\frac{E_2A_2}{L_2} & -\\frac{E_2A_2}{L_2} & -1 \\\\ 0 & -\\frac{E_2A_2}{L_2} & \\frac{E_2A_2}{L_2} & 0 \\\\ 1 & -1 & 0 & 0 \\end{pmatrix} } $$", "id": "3512475"}, {"introduction": "在掌握了基本的约束施加方法后，我们转向更复杂的 Nitsche 方法，并聚焦于其数值稳定性的核心问题。本练习旨在通过分析推导，揭示稳定化参数 $\\gamma_T$ 的选择对于确保方法在材料属性剧烈变化的异质介质问题中的鲁棒性至关重要。通过这个思想实验，你将理解为何特定的参数缩放（例如，与扩散系数的调和平均值成比例）是实现稳定且精确的数值解的关键 ([@problem_id:3512477])。", "problem": "考虑一个标量扩散模型，该模型建立在两个子区域 $\\Omega_1$ 和 $\\Omega_2$ 上，其界面为 $\\Gamma$。在 $\\Omega_1$ 和 $\\Omega_2$ 中的扩散系数分别为分片常数、正值的 $k_1$ 和 $k_2$。其强形式由 $-\\nabla \\cdot (k_i \\nabla u_i) = f_i$ 在 $\\Omega_i$ 中（$i=1,2$）给出，以及界面条件 $u_1 = u_2$ 和 $k_1 \\nabla u_1 \\cdot n_1 + k_2 \\nabla u_2 \\cdot n_2 = 0$ 在 $\\Gamma$ 上，其中 $n_i$ 是 $\\partial \\Omega_i$ 上的单位外法向量。假设每个子区域内有协调网格，界面网格由特征尺寸为 $h_T$ 的面元 $T \\subset \\Gamma$ 组成。解在界面 $\\Gamma$ 上的连续性通过 Nitsche 方法被弱施加，该方法在每个界面面元 $T$ 上添加了一致性项和一个形式为 $\\int_T \\gamma_T [u][v] \\, \\mathrm{d}s$ 的对称罚项，其中 $[u] := u_1 - u_2$ 表示跳跃，$\\gamma_T$ 是逐单元选择的稳定化参数。\n\n从以下几点出发：\n- 扩散能量 $E(u) = \\sum_{i=1}^2 \\int_{\\Omega_i} k_i |\\nabla u_i|^2 \\, \\mathrm{d}x$，\n- 上述界面条件，\n- 以及对于与面元 $T$ 相邻的形状正则单元 $K$，形式为 $\\|w\\|_{L^2(T)} \\leq C_{\\mathrm{tr}} h_T^{-1/2} \\|w\\|_{L^2(K)} + C_{\\mathrm{tr}}' \\|\\nabla w\\|_{L^2(K)}$ 的标准迹不等式，\n\n推导 $\\gamma_T$ 所需的标度关系，以确保 Nitsche 双线性形式的矫顽性对 $k_1$ 和 $k_2$ 的巨大变化具有鲁棒性，并避免对精度有害的过度罚。为简单起见，假设使用线性有限元、具有不依赖于网格的迹常数的形状正则性，并使用 $\\Gamma$ 上通量的加权平均，其中权重经选择以平衡扩散对比度。在每个面元 $T \\subset \\Gamma$ 上，下列哪种关于 $\\gamma_T$ 的逐单元规则最能实现独立于系数对比度的稳定性，同时在非均匀介质中保持精度？\n\nA. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{2 k_1 k_2}{k_1 + k_2} \\dfrac{1}{h_T}$\n\nB. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{\\max(k_1,k_2)}{h_T}$\n\nC. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{k_1 + k_2}{h_T}$\n\nD. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{\\min(k_1,k_2)}{h_T}$\n\nE. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{\\sqrt{k_1 k_2}}{h_T}$\n\n这里 $c_{\\mathrm{stab}} \\geq 1$ 是一个无量纲常数，仅依赖于多项式次数和形状正则性（不依赖于 $k_1$、$k_2$ 或 $h_T$）。选择唯一最佳选项。", "solution": "用户需要对非均匀扩散问题中 Nitsche 方法的稳定化参数进行分析。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- **模型：** 两个子区域 $\\Omega_1$ 和 $\\Omega_2$ 上的标量扩散，界面为 $\\Gamma$。\n- **系数：** 在 $\\Omega_1$ 和 $\\Omega_2$ 中分别为分片常数、正值的扩散系数 $k_1$ 和 $k_2$。\n- **强形式：** $-\\nabla \\cdot (k_i \\nabla u_i) = f_i$ 在 $\\Omega_i$ 中，对于 $i=1,2$。\n- **界面条件：** $u_1 = u_2$ 和 $k_1 \\nabla u_1 \\cdot n_1 + k_2 \\nabla u_2 \\cdot n_2 = 0$ 在 $\\Gamma$ 上。$n_i$ 是 $\\partial \\Omega_i$ 上的单位外法向量。\n- **离散化：** 每个子区域内为协调网格；界面网格由特征尺寸为 $h_T$ 的面元 $T \\subset \\Gamma$ 组成；线性有限元；形状正则网格。\n- **Nitsche 方法：** 弱施加连续性 $u_1 = u_2$。添加一个对称罚项 $\\int_T \\gamma_T [u][v] \\, \\mathrm{d}s$，其中 $[u] := u_1 - u_2$。$\\gamma_T$ 是稳定化参数。\n- **推导基础：**\n    1. 扩散能量：$E(u) = \\sum_{i=1}^2 \\int_{\\Omega_i} k_i |\\nabla u_i|^2 \\, \\mathrm{d}x$。\n    2. 如上所述的界面条件。\n    3. 迹不等式：$\\|w\\|_{L^2(T)} \\leq C_{\\mathrm{tr}} h_T^{-1/2} \\|w\\|_{L^2(K)} + C_{\\mathrm{tr}}' \\|\\nabla w\\|_{L^2(K)}$，对于与面元 $T$ 相邻的单元 $K$。（尽管对于有限元，一个更简单的逆迹不等式更直接）。\n- **目标：** 推导 $\\gamma_T$ 的标度关系，以确保矫顽性对 $k_1$ 和 $k_2$ 的巨大变化具有鲁棒性，并避免过度罚。\n- **约束：** 在 $\\Gamma$ 上使用通量的加权平均，权重经选择以平衡扩散对比度。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是偏微分方程数值分析领域的典型问题，特别涉及间断 Galerkin 或 Nitsche 方法处理界面问题。所有概念都是标准且成熟的。此项有效。\n- **适定性：** 为数值方法推导稳定性条件是数值分析中的一个标准且适定的任务。“最佳”选择的标准（对对比度的鲁棒性、最小化罚项）在此背景下是客观和标准的。此项有效。\n- **客观性：** 问题使用精确、技术性的语言陈述，没有主观或含糊的术语。此项有效。\n- **完整性与一致性：** 问题为 Nitsche 方法的标准稳定性分析提供了所有必要组成部分：强形式、公式化提示（对称罚、加权通量平均）和数学工具（迹不等式）。没有矛盾之处。此项有效。\n- **现实性：** 该模型是一个简化模型，但代表了模拟具有材料界面的多物理场系统（例如，通过复合材料的热传递）中的一个基本挑战。此项有效。\n\n**第 3 步：结论与行动**\n问题陈述有效。我将继续进行推导和求解。\n\n### 稳定化参数标度关系的推导\n\n目标是为与 Nitsche 方法相关的双线性形式建立矫顽性。我们首先构建双线性形式。将强形式与测试函数 $v$ 相乘，并在两个子区域 $\\Omega_1$ 和 $\\Omega_2$ 上积分求和，得到：\n$$\n\\sum_{i=1}^2 \\int_{\\Omega_i} k_i \\nabla u_i \\cdot \\nabla v_i \\, \\mathrm{d}x - \\sum_{i=1}^2 \\int_{\\partial\\Omega_i} (k_i \\nabla u_i \\cdot n_i) v_i \\, \\mathrm{d}s = \\sum_{i=1}^2 \\int_{\\Omega_i} f_i v_i \\, \\mathrm{d}x\n$$\n令界面法向量 $n$ 从 $\\Omega_1$ 指向 $\\Omega_2$。则 $n_1=n$ 且 $n_2=-n$。问题陈述中提到使用对称 Nitsche 方法，并采用通量的加权平均。一个通用的对称 Nitsche 双线性形式 $B(u,v)$ 为：\n$$\nB(u,v) = \\sum_{i=1}^2 \\int_{\\Omega_i} k_i \\nabla u_i \\cdot \\nabla v_i \\, \\mathrm{d}x - \\int_{\\Gamma} \\langle k \\nabla u \\cdot n \\rangle [v] \\, \\mathrm{d}s - \\int_{\\Gamma} \\langle k \\nabla v \\cdot n \\rangle [u] \\, \\mathrm{d}s + \\int_{\\Gamma} \\gamma [u][v] \\, \\mathrm{d}s\n$$\n其中 $[u] = u_1 - u_2$ 是跳跃，$\\langle k \\nabla u \\cdot n \\rangle$ 是一个数值通量，它必须是真实物理通量 $k_1 \\nabla u_1 \\cdot n = k_2 \\nabla u_2 \\cdot n$ 的一致近似。如提示所述，我们使用来自两侧的法向导数的加权平均：\n$$\n\\langle k \\nabla u \\cdot n \\rangle = \\theta (k_1 \\nabla u_1 \\cdot n) + (1-\\theta) (k_2 \\nabla u_2 \\cdot n)\n$$\n对于任何权重 $\\theta \\in \\mathbb{R}$ 的选择，这都是一致的。\n\n为确保矫顽性，我们分析离散有限元空间中函数 $v$ 的 $B(v,v)$。\n$$\nB(v,v) = \\sum_{i=1}^2 \\int_{\\Omega_i} k_i |\\nabla v_i|^2 \\, \\mathrm{d}x - 2\\int_{\\Gamma} \\langle k \\nabla v \\cdot n \\rangle [v] \\, \\mathrm{d}s + \\int_{\\Gamma} \\gamma [v]^2 \\, \\mathrm{d}s\n$$\n关键部分是为中间项定界。让我们在一个界面面元 $T$ 上分析它：\n$$\n-2\\int_{T} \\left( \\theta k_1 \\nabla v_1 \\cdot n + (1-\\theta) k_2 \\nabla v_2 \\cdot n \\right) [v] \\, \\mathrm{d}s\n$$\n使用 Cauchy-Schwarz 不等式和 Young 不等式 ($2ab \\le \\epsilon a^2 + \\frac{1}{\\epsilon} b^2$)，我们为该项的两个部分定界：\n$$\n|-2\\theta \\int_T (k_1 \\nabla v_1 \\cdot n) [v] \\, \\mathrm{d}s| \\le \\int_T \\left( \\epsilon_1 |k_1 \\nabla v_1 \\cdot n|^2 + \\frac{\\theta^2}{\\epsilon_1} |[v]|^2 \\right) \\, \\mathrm{d}s\n$$\n$$\n|-2(1-\\theta) \\int_T (k_2 \\nabla v_2 \\cdot n) [v] \\, \\mathrm{d}s| \\le \\int_T \\left( \\epsilon_2 |k_2 \\nabla v_2 \\cdot n|^2 + \\frac{(1-\\theta)^2}{\\epsilon_2} |[v]|^2 \\right) \\, \\mathrm{d}s\n$$\n不，这不是最优的方法。Young 不等式的一个更好的应用是：\n$|-2\\theta \\int_T k_1 (\\nabla v_1 \\cdot n) [v] \\, \\mathrm{d}s| \\le \\int_T (\\epsilon_1 k_1 |\\nabla v_1 \\cdot n|^2 + \\frac{\\theta^2 k_1}{\\epsilon_1}|[v]|^2) \\, \\mathrm{d}s$。对于第二项也类似：\n$|-2(1-\\theta) \\int_T k_2 (\\nabla v_2 \\cdot n) [v] \\, \\mathrm{d}s| \\le \\int_T (\\epsilon_2 k_2 |\\nabla v_2 \\cdot n|^2 + \\frac{(1-\\theta)^2 k_2}{\\epsilon_2}|[v]|^2) \\, \\mathrm{d}s$。\n\n现在，我们对形状正则网格上的有限元函数使用一个标准的逆迹不等式，该不等式表明对于单元 $K$ 的一个面元 $T$：$\\|\\nabla w\\|_{L^2(T)}^2 \\le C_I h_T^{-1} \\|\\nabla w\\|_{L^2(K)}^2$。应用此不等式：\n$$\n\\int_T k_1 |\\nabla v_1 \\cdot n|^2 \\, \\mathrm{d}s \\le \\int_T k_1 |\\nabla v_1|^2 \\, \\mathrm{d}s \\le C_I h_T^{-1} \\int_{K_1} k_1 |\\nabla v_1|^2 \\, \\mathrm{d}x\n$$\n对所有面元 $T$ 和相邻单元 $K_i$ 求和，我们得到：\n$$\nB(v,v) \\ge \\sum_{i=1}^2 \\int_{\\Omega_i} k_i |\\nabla v_i|^2 - \\epsilon_1 C_I h^{-1}_{\\Gamma} \\int_{\\Omega_1} k_1 |\\nabla v_1|^2 - \\epsilon_2 C_I h^{-1}_{\\Gamma} \\int_{\\Omega_2} k_2 |\\nabla v_2|^2 + \\sum_T \\int_T \\left(\\gamma_T - \\frac{\\theta^2 k_1}{\\epsilon_1} - \\frac{(1-\\theta)^2 k_2}{\\epsilon_2} \\right) |[v]|^2 \\, \\mathrm{d}s\n$$\n其中 $h_{\\Gamma}$ 代表 $h_T$ 的集合。为了将负的梯度项吸收到主能量项中，我们可以选择足够小的 $\\epsilon_1, \\epsilon_2$。令 $\\epsilon_1 = \\epsilon_2 = c_{abs} h_T/C_I$，其中常数 $c_{abs} < 1$。然后，为保证矫顽性，乘以 $|[v]|^2$ 的项必须为非负。这要求：\n$$\n\\gamma_T \\ge \\frac{1}{\\epsilon_1}(\\theta^2 k_1) + \\frac{1}{\\epsilon_2}((1-\\theta)^2 k_2) = \\frac{C_I}{c_{abs} h_T} (\\theta^2 k_1 + (1-\\theta)^2 k_2)\n$$\n问题要求我们选择权重以“平衡扩散对比度”并实现鲁棒性。这转化为选择 $\\theta$ 以最小化所需的稳定化参数 $\\gamma_T$。我们必须关于 $\\theta$ 最小化表达式 $g(\\theta) = \\theta^2 k_1 + (1-\\theta)^2 k_2$。\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}\\theta} = 2\\theta k_1 - 2(1-\\theta)k_2 = 0 \\implies \\theta k_1 = (1-\\theta)k_2 \\implies \\theta(k_1+k_2) = k_2 \\implies \\theta = \\frac{k_2}{k_1+k_2}\n$$\n将这个最优 $\\theta$ 代回到最小 $\\gamma_T$ 的表达式中：\n$$\n\\gamma_T \\ge \\frac{C_{\\mathrm{stab}}}{h_T} \\left( \\left(\\frac{k_2}{k_1+k_2}\\right)^2 k_1 + \\left(\\frac{k_1}{k_1+k_2}\\right)^2 k_2 \\right)\n$$\n简化括号中的项：\n$$\n\\frac{k_2^2 k_1 + k_1^2 k_2}{(k_1+k_2)^2} = \\frac{k_1 k_2 (k_2+k_1)}{(k_1+k_2)^2} = \\frac{k_1 k_2}{k_1+k_2}\n$$\n因此，为实现鲁棒稳定性所需的最小充分稳定化参数的标度关系为：\n$$\n\\gamma_T \\propto \\frac{1}{h_T} \\frac{k_1 k_2}{k_1+k_2}\n$$\n该表达式与系数的调和平均 $H(k_1, k_2) = \\frac{2k_1 k_2}{k_1+k_2}$ 成正比。\n\n### 逐项分析\n\n让我们基于这个推导出的标度关系来评估每个选项。鲁棒性和避免过度罚的关键在于高对比度极限（例如 $k_1 \\gg k_2 > 0$）下的行为。\n\n*   **A. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{2 k_1 k_2}{k_1 + k_2} \\dfrac{1}{h_T}$**\n    这是调和平均标度。我们的推导表明，这提供了实现矫顽性所需的最小稳定化，且与对比度无关。在高对比度极限（$k_1 \\gg k_2$）下，$\\frac{2 k_1 k_2}{k_1 + k_2} \\approx \\frac{2 k_1 k_2}{k_1} = 2k_2$。罚项与*较小*的系数成比例，这对于避免锁定现象和保持精度至关重要。此选择是稳定的，并避免了过度罚。\n    **结论：正确**\n\n*   **B. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{\\max(k_1,k_2)}{h_T}$**\n    在高对比度极限（$k_1 \\gg k_2$）下，此项的标度为 $k_1/h_T$。这是一个严重的过度罚。它迫使解的跳跃 $[u]$ 过小，这可能对精度有害，特别是当真实解的梯度在界面上出现急剧变化时。此选择会导致病态的系统矩阵，其条件数取决于对比度 $k_1/k_2$。\n    **结论：不正确**\n\n*   **C. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{k_1 + k_2}{h_T}$**\n    这是算术平均标度。在高对比度极限（$k_1 \\gg k_2$）下，此项的标度为 $k_1/h_T$。与选项 B 类似，这会导致显著的过度罚并降低精度。这种标度关系源于非最优或朴素的稳定性分析（例如，使用简单的平均通量 $\\frac{1}{2}(k_1\\nabla u_1 \\cdot n + k_2\\nabla u_2 \\cdot n)$）。\n    **结论：不正确**\n\n*   **D. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{\\min(k_1,k_2)}{h_T}$**\n    在高对比度极限（$k_1 \\gg k_2$）下，此项的标度为 $k_2/h_T$，这是正确的渐近行为。然而，调和平均 $H(k_1, k_2) = \\frac{2k_1k_2}{k_1+k_2}$ 总是大于或等于最小值 $\\min(k_1, k_2)$（考虑 $k_2 \\le k_1$，则 $H/ \\min = \\frac{2k_1}{k_1+k_2} \\ge 1$）。由于我们的分析表明所需的罚项必须与调和平均成正比，选择与最小值成正比的罚项可能不足以保证对所有对比度都稳定。例如，如果 $k_1=3k_2$，则 $H = 1.5 k_2$ 而 $\\min=k_2$。所需的罚项要大 $1.5$ 倍。\n    **结论：不正确**\n\n*   **E. $\\gamma_T = c_{\\mathrm{stab}} \\dfrac{\\sqrt{k_1 k_2}}{h_T}$**\n    这是几何平均标度。在高对比度极限（$k_1 \\gg k_2$）下，此项的标度为 $\\sqrt{k_1 k_2}/h_T = \\sqrt{k_1/k_2} \\cdot k_2/h_T$。此罚项随对比度的平方根增长，与算术平均相比有所改善，但与调和平均相比仍构成过度罚。它不能提供鲁棒性。\n    **结论：不正确**\n\n总之，调和平均标度是唯一能够提供可证明的充分稳定性的同时又是最小的标度，从而确保对系数对比度的鲁棒性，而不会因过度罚而造成不应有的精度损失。", "answer": "$$\\boxed{A}$$", "id": "3512477"}, {"introduction": "本练习是一个综合性的实践项目，旨在将本章讨论的几种主要界面耦合方法——罚函数法、Nitsche 方法和拉格朗日乘子法——付诸实践。你将通过编写代码，在一个精心设计的计算实验中实现并比较这些方法的性能，特别是它们的收敛性质。这个练习不仅能巩固你对这些方法理论的理解，还将锻炼你作为计算科学家评估和验证数值算法的关键能力 ([@problem_id:3512524])。", "problem": "考虑定义在区间 $[-1,1]$ 上的一个一维稳态扩散问题，其在 $x=0$ 处存在一个内部界面。设 $a(x)$ 为分段常数，当 $x\\in[-1,0]$ 时 $a(x)=a_L$，当 $x\\in[0,1]$ 时 $a(x)=a_R$。其控制偏微分方程和弱形式基于守恒定律和本构关系：通量 $q(x)$ 满足 $q(x)=-a(x)u'(x)$，而守恒定律意味着 $-q'(x)=f(x)$，其中 $u(x)$ 是势， $f(x)$ 是源项。我们取 $f(x)=1$ 于 $[-1,1]$ 上，并采用齐次 Dirichlet 边界条件 $u(-1)=0$ 和 $u(1)=0$。在 $x=0$ 处的界面条件是势和通量的连续性，即 $u(0^-)=u(0^+)$ 和 $a_L u'(0^-)=a_R u'(0^+)$。\n\n从这些基本定律和定义出发，在一个统一的离散化框架中推导并实现三种数值界面耦合策略。该框架在左右子区域的非重叠网格上使用连续分片线性基函数，并在界面处采用重复的自由度：\n- 拉格朗日乘子法 (LM)：引入一个辅助未知量 $\\lambda$ 以在弱意义下强制施加约束 $u_L(0)-u_R(0)=0$，通过向双线性形式中增加 $\\langle \\lambda, u_L(0)-u_R(0)\\rangle$ 项，并增加约束方程 $\\langle \\mu, u_L(0)-u_R(0)\\rangle=0$ (对于任意测试乘子 $\\mu$)。\n- 罚函数法：通过一个对称的罚函数项 $\\dfrac{\\alpha}{h_\\Gamma}\\left(u_L(0)-u_R(0)\\right)\\left(v_L(0)-v_R(0)\\right)$ 来增广双线性形式，其中 $\\alpha>0$ 是罚参数，$h_\\Gamma$ 是界面处的特征网格尺寸。\n- 对称 Nitsche 方法：通过一致性界面项和稳定性界面项来增广双线性形式，\n$$\n-\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma \\left[v\\right]_\\Gamma\n-\\left\\{\\! a\\,v' \\cdot n \\!\\right\\}_\\Gamma \\left[u\\right]_\\Gamma\n+\\dfrac{\\gamma}{h_\\Gamma}\\left[u\\right]_\\Gamma \\left[v\\right]_\\Gamma,\n$$\n其中 $\\left[u\\right]_\\Gamma=u_L(0)-u_R(0)$ 和 $\\left[v\\right]_\\Gamma=v_L(0)-v_R(0)$ 表示跳跃， $n$ 是每一侧的外法线方向 ($x=0^-$ 处 $n_L=+1$，$x=0^+$ 处 $n_R=-1$)，而 $\\left\\{\\! a\\,w' \\cdot n \\!\\right\\}_\\Gamma=\\dfrac{1}{2}\\left(a_L w_L'(0)\\,n_L + a_R w_R'(0)\\,n_R\\right)$ 表示平均法向通量。\n\n为了将界面误差与主体区域误差分离开，构造仅在界面邻域加密的网格。对于给定的加密半径 $r\\in(0,1)$，将左侧网格定义为一个由 $[-1,-r]$ 上的 $m_{\\mathrm{bulk}}$ 个等长单元组成的粗网格和一个由 $[-r,0]$ 上的 $n_{\\mathrm{iface}}$ 个等长单元组成的加密网格的并集。类似地，将右侧网格定义为一个由 $[0,r]$ 上的 $n_{\\mathrm{iface}}$ 个等长单元组成的加密网格和一个由 $[r,1]$ 上的 $m_{\\mathrm{bulk}}$ 个等长单元组成的粗网格的并集。$x=0$ 处的界面节点被复制，从而产生不同的自由度 $u_L(0)$ 和 $u_R(0)$。在每个子区域上使用带有重复界面节点的连续分片线性有限元，并强施加边界条件 $u(-1)=0$ 和 $u(1)=0$。\n\n设 $u_{\\mathrm{exact}}(x)$ 是通过求解常微分方程 $-a_L u_L''(x)=1$ (在 $[-1,0]$ 上) 和 $-a_R u_R''(x)=1$ (在 $[0,1]$ 上) 并满足所述边界和界面条件得到的精确解。这将得到分段二次表达式\n$$\nu_L(x)=-\\dfrac{x^2}{2 a_L} + c_1 x + c_2,\\quad x\\in[-1,0],\\qquad\nu_R(x)=-\\dfrac{x^2}{2 a_R} + d_1 x + d_2,\\quad x\\in[0,1],\n$$\n其中常数 $c_1,c_2,d_1,d_2$ 由条件 $u_L(-1)=0$、$u_R(1)=0$、$u_L(0)=u_R(0)$ 和 $a_L u_L'(0)=a_R u_R'(0)$ 确定。\n\n将特征界面尺寸 $h_\\Gamma$ 定义为左右网格在 $x=0$ 处相邻单元尺寸的平均值。对于每种耦合方法，求解离散系统并计算以下两种误差度量：\n- 界面邻域误差：误差的 $L^2$ 范数 $\\|u_h-u_{\\mathrm{exact}}\\|_{L^2([-r,r])}$。\n- 主体区域误差：误差的 $L^2$ 范数 $\\|u_h-u_{\\mathrm{exact}}\\|_{L^2([-1,-r]\\cup[r,1])}$。\n\n为了估计收敛率，考虑三个加密级别 $n_{\\mathrm{iface}}\\in\\{10,20,40\\}$，并固定 $m_{\\mathrm{bulk}}=4$。对于每个加密级别，在相同的网格下计算所有三种方法的界面邻域误差和主体区域误差。对于每种误差类别和方法，通过对三个级别的结果进行线性回归，将对数-对数关系 $\\log(\\mathrm{error})=\\mathrm{const}+p\\,\\log(h_\\Gamma)$ 中的斜率作为收敛率 $p$ 的估计。\n\n您的程序必须实现上述过程，并为以下参数集测试套件生成收敛率：\n- 测试用例 1：$(a_L,a_R,\\alpha,\\gamma,r)=(1.0,10.0,10.0,10.0,0.3)$。\n- 测试用例 2：$(a_L,a_R,\\alpha,\\gamma,r)=(1.0,1.0,1.0,1.0,0.2)$。\n- 测试用例 3：$(a_L,a_R,\\alpha,\\gamma,r)=(0.1,100.0,100.0,50.0,0.1)$。\n\n在所有情况下，收敛率均以实数表示。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个嵌套列表，该列表包含两个子列表：第一个列表包含三种方法的界面邻域收敛率 $[p_{\\mathrm{penalty}},p_{\\mathrm{Nitsche}},p_{\\mathrm{LM}}]$，第二个列表包含三种方法的主体区域收敛率 $[p_{\\mathrm{penalty}},p_{\\mathrm{Nitsche}},p_{\\mathrm{LM}}]$。例如，三个测试用例的整体输出格式为\n$[[p^{(1)}_{\\mathrm{iface,pen}},p^{(1)}_{\\mathrm{iface,Nitsche}},p^{(1)}_{\\mathrm{iface,LM}],[p^{(1)}_{\\mathrm{bulk,pen}},p^{(1)}_{\\mathrm{bulk,Nitsche}},p^{(1)}_{\\mathrm{bulk,LM}]}],\\dots]$，其中包含与三个测试用例相对应的三对这样的列表。", "solution": "推导从稳态扩散的守恒关系和本构关系开始。物理通量为 $q(x)=-a(x)u'(x)$，守恒定律要求 $-q'(x)=f(x)$，其中 $f(x)=1$。结合这些可得到强形式\n$$\n-(a(x)u'(x))'=1\\quad \\text{in }(-1,0)\\cup(0,1),\n$$\n以及界面条件 $u(0^-)=u(0^+)$ 和 $a_L u'(0^-)=a_R u'(0^+)$。通过乘以一个满足 $v(-1)=0$ 和 $v(1)=0$ 的测试函数 $v$ 并在每个子区域上进行分部积分，可以得到弱形式：\n$$\n\\int_{-1}^{0} a_L u'(x) v'(x)\\,dx + \\int_{0}^{1} a_R u'(x) v'(x)\\,dx = \\int_{-1}^{1} v(x)\\,dx.\n$$\n该恒等式假设在界面处是连续的；由于对 $u_L(0)$ 和 $u_R(0)$ 使用了重复的界面自由度，我们必须通过耦合方法来强制施加连续性。\n\n精确解是通过分段求解常微分方程并施加界面和边界条件来计算的。在 $[-1,0]$ 上，$-a_L u_L''=1$ 意味着 $u_L''=-1/a_L$，因此\n$$\nu_L(x)=-\\frac{x^2}{2 a_L} + c_1 x + c_2.\n$$\n类似地，在 $[0,1]$ 上，$u_R(x)=-\\frac{x^2}{2 a_R} + d_1 x + d_2$。边界条件 $u_L(-1)=0$ 和 $u_R(1)=0$ 得到 $-1/(2 a_L) - c_1 + c_2=0$ 和 $-1/(2 a_R) + d_1 + d_2=0$。连续性 $u_L(0)=u_R(0)$ 给出 $c_2=d_2$，通量连续性 $a_L u_L'(0)=a_R u_R'(0)$ 意味着 $a_L c_1 = a_R d_1$。求解这些方程可得\n$$\nc_1 = \\frac{1}{2}\\frac{a_L - a_R}{a_L(a_L + a_R)},\\quad d_1=\\frac{1}{2}\\frac{a_L - a_R}{a_R(a_L + a_R)},\\quad c_2 = \\frac{1}{2 a_L} + c_1,\\quad d_2=c_2.\n$$\n\n对于空间离散化，我们在每个具有重复界面节点的子区域上使用连续分片线性有限元。设左侧网格为一个由 $[-1,-r]$ 上的 $m_{\\mathrm{bulk}}$ 个单元组成的粗糙均匀剖分和一个由 $[-r,0]$ 上的 $n_{\\mathrm{iface}}$ 个单元组成的加密均匀剖分的并集。右侧网格的定义类似，它是一个由 $[0,r]$ 上的 $n_{\\mathrm{iface}}$ 个单元组成的加密剖分和一个由 $[r,1]$ 上的 $m_{\\mathrm{bulk}}$ 个单元组成的粗糙剖分的并集。自由度是每个子区域上 $u$ 的节点值，其中界面节点被复制 ($u_L(0)$ 和 $u_R(0)$)。左边界值 $u(-1)=0$ 和右边界值 $u(1)=0$ 通过将这些节点从未知向量中排除来强施加。\n\n每个子区域上的组装使用标准双线性形式 $\\int a\\,u'v'\\,dx$，对于区间 $[x_i,x_{i+1}]$ 上的分片线性单元，这会产生局部刚度 $k_e=\\frac{a}{h}\\begin{bmatrix}1 & -1\\\\ -1 & 1\\end{bmatrix}$，其中 $h=x_{i+1}-x_i$。对于常数源项 $f=1$ 的载荷向量为 $f_e=\\frac{h}{2}\\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$。对所有单元进行组装，得到块对角刚度矩阵 $K_L$ 和 $K_R$ 以及载荷向量 $F_L$ 和 $F_R$。未耦合系统的全局刚度 $K$ 和载荷 $F$ 是块对角的，即 $K=\\mathrm{diag}(K_L,K_R)$ 和 $F=[F_L;F_R]$。\n\n界面强制施加的方法因策略而异：\n- 拉格朗日乘子法 (LM)：引入一个辅助未知量 $\\lambda$ 来强制 $u_L(0)-u_R(0)=0$。离散的鞍点系统为\n$$\n\\begin{bmatrix}\nK & B^\\top\\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nU\\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nF\\\\ 0\n\\end{bmatrix},\n$$\n其中 $U$ 包含了所有子区域的自由度，$B$ 是一个选取界面跳跃的行向量：$B U = u_L(0)-u_R(0)$，即 $B$ 在左界面位置为 $+1$，右界面位置为 $-1$，其他位置为零。$B^\\top$ 耦合项将 $\\lambda$ 添加到左界面方程，将 $-\\lambda$ 添加到右界面方程，这可以解释为平衡约束的界面力。\n\n- 罚函数法：在跨越 $(u_L(0),u_R(0))$ 的 $2\\times 2$ 区块上，通过一个对称的二阶界面罚函数\n$$\nK \\leftarrow K + \\frac{\\alpha}{h_\\Gamma}\n\\begin{bmatrix}\n\\phantom{-}1 & -1\\\\\n-1 & \\phantom{-}1\n\\end{bmatrix}\n$$\n来增广 $K$。这里 $h_\\Gamma$ 是特征界面尺寸，取为左侧最后一个单元的长度和右侧第一个单元的长度的平均值。\n\n- 对称 Nitsche 方法：增加两个一致性界面项和一个稳定性项。使用 $x=0$ 处的外法线 $n_L=+1$ 和 $n_R=-1$，平均法向通量为\n$$\n\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma = \\frac{1}{2}\\left(a_L\\,\\frac{u_L(0)-u_L(x^-)}{h_L} - a_R\\,\\frac{u_R(x^+)-u_R(0)}{h_R}\\right),\n$$\n其中 $h_L$ 是左侧最后一个单元的尺寸，$h_R$ 是右侧第一个单元的尺寸，$x^-$ 和 $x^+$ 分别表示与 $0$ 相邻的左侧节点和右侧节点。将界面相邻的四个自由度向量表示为 $\\left[u_L(x^-),u_L(0),u_R(0),u_R(x^+)\\right]$。一致性双线性形式的贡献为\n$$\n-\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma \\left[v\\right]_\\Gamma - \\left\\{\\! a\\,v' \\cdot n \\!\\right\\}_\\Gamma \\left[u\\right]_\\Gamma.\n$$\n在离散形式中，这些可以表示为一个 $4\\times 4$ 矩阵，该矩阵由平均通量相对于四个相邻自由度的梯度组装而成。定义梯度向量\n$$\ng=\\left[ -\\frac{1}{2}\\frac{a_L}{h_L}, \\;\\frac{1}{2}\\frac{a_L}{h_L},\\;\\frac{1}{2}\\frac{a_R}{h_R},\\; -\\frac{1}{2}\\frac{a_R}{h_R}\\right],\n$$\n这对应于 $\\partial\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma/\\partial [u_L(x^-),u_L(0),u_R(0),u_R(x^+)]$。那么一致性矩阵是两部分之和：$M_1$ 将试探函数的梯度映射到测试函数的跳跃，而 $M_2$ 将测试函数的梯度映射到试探函数的跳跃。具体来说，如果行按 $[u_L(x^-),u_L(0),u_R(0),u_R(x^+)]$ 的顺序排列，那么 $M_1$ 仅在跳跃测试自由度 $u_L(0)$ 和 $u_R(0)$ 处有非零行，其中 $M_1[\\text{row }u_L(0),:]=-g$ 和 $M_1[\\text{row }u_R(0),:]=+g$。伴随的一致性部分 $M_2$ 仅在跳跃试探自由度 $u_L(0)$ 和 $u_R(0)$ 处有非零列，其中 $M_2[:,\\text{col }u_L(0)]=-g$ 和 $M_2[:,\\text{col }u_R(0)]=+g$。对称的一致性贡献是 $M_{\\mathrm{cons}}=M_1+M_2$。稳定性项增加了 $(\\gamma/h_\\Gamma)\\left[u\\right]_\\Gamma\\left[v\\right]_\\Gamma$，它在 $(u_L(0),u_R(0))$ 上贡献了一个等于 $(\\gamma/h_\\Gamma)\\begin{bmatrix}1 & -1\\\\-1 & 1\\end{bmatrix}$ 的 $2\\times 2$ 区块。\n\n定义了这些离散算子后，算法按以下步骤进行。\n- 对于每个测试用例 $(a_L,a_R,\\alpha,\\gamma,r)$，以及每个加密级别 $n_{\\mathrm{iface}}\\in\\{10,20,40\\}$ (固定 $m_{\\mathrm{bulk}}=4$)，根据定义构建左右网格。组装 $K_L,F_L$ 和 $K_R,F_R$，形成 $K=\\mathrm{diag}(K_L,K_R)$ 和 $F=[F_L;F_R]$。\n- 识别界面相邻自由度 $u_L(x^-)$、$u_L(0)$、$u_R(0)$ 和 $u_R(x^+)$ 的索引，并计算 $h_L$、$h_R$ 和 $h_\\Gamma=\\frac{1}{2}(h_L+h_R)$。\n- 对于罚函数法：在 $(u_L(0),u_R(0))$ 上添加 $(\\alpha/h_\\Gamma)\\begin{bmatrix}1 & -1\\\\-1 & 1\\end{bmatrix}$ 并求解 $K U=F$。\n- 对于对称 Nitsche 方法：在界面相邻自由度的 $4\\times 4$ 区块上添加 $M_{\\mathrm{cons}}$，在 $(u_L(0),u_R(0))$ 上添加 $(\\gamma/h_\\Gamma)\\begin{bmatrix}1 & -1\\\\-1 & 1\\end{bmatrix}$，然后求解 $K U=F$。\n- 对于拉格朗日乘子法：增加一个未知数并求解鞍点系统 $\\begin{bmatrix}K & B^\\top\\\\B & 0\\end{bmatrix}\\begin{bmatrix}U\\\\\\lambda\\end{bmatrix}=\\begin{bmatrix}F\\\\0\\end{bmatrix}$。\n\n求解后，重构节点值，包括边界节点（左侧 $u(-1)=0$ 和右侧 $u(1)=0$）。计算精确系数 $(c_1,c_2,d_1,d_2)$ 并在每个单元上计算精确解。通过在每个单元上分别使用数值积分（例如，Gauss-Legendre 积分）计算 $L^2$ 误差，累积 $[-r,r]$ 上的界面邻域误差和 $[-1,-r]\\cup[r,1]$ 上的主体区域误差。对于每种方法和测试用例，收集三个加密级别的误差，并通过对 $\\log(\\mathrm{error})$ 与 $\\log(h_\\Gamma)$ 进行线性回归来计算收敛率 $p$。线性回归的斜率提供了收敛阶的估计，使得 $\\mathrm{error}\\approx C h_\\Gamma^p$。\n\n最后，对于每个测试用例，输出一个嵌套列表，其中包含三种方法的界面邻域收敛率 $[p_{\\mathrm{penalty}},p_{\\mathrm{Nitsche}},p_{\\mathrm{LM}}]$ 和三种方法的主体区域收敛率 $[p_{\\mathrm{penalty}},p_{\\mathrm{Nitsche}},p_{\\mathrm{LM}}]$，并按规定格式汇总为单行输出。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef build_mesh_left(r, n_iface, m_bulk):\n    # Left mesh: [-1, -r] coarse, [-r, 0] refined\n    left_bulk = np.linspace(-1.0, -r, m_bulk + 1)\n    left_iface = np.linspace(-r, 0.0, n_iface + 1)\n    # Concatenate, avoiding duplicate -r\n    nodes = np.concatenate([left_bulk[:-1], left_iface])\n    return nodes\n\ndef build_mesh_right(r, n_iface, m_bulk):\n    # Right mesh: [0, r] refined, [r, 1] coarse\n    right_iface = np.linspace(0.0, r, n_iface + 1)\n    right_bulk = np.linspace(r, 1.0, m_bulk + 1)\n    # Concatenate, avoiding duplicate r\n    nodes = np.concatenate([right_iface, right_bulk[1:]])\n    return nodes\n\ndef assemble_subdomain(nodes, a, is_left_boundary):\n    # Assemble K and F for piecewise linear FEM with Dirichlet at boundary.\n    # is_left_boundary: True for left subdomain (Dirichlet at first node), False for right (Dirichlet at last node).\n    n = len(nodes)\n    # Unknowns exclude boundary node\n    if is_left_boundary:\n        unknown_map = np.full(n, -1, dtype=int)\n        unknown_map[1:] = np.arange(n - 1)  # exclude index 0\n    else:\n        unknown_map = np.full(n, -1, dtype=int)\n        unknown_map[:-1] = np.arange(n - 1)  # exclude last index\n\n    N_unknown = np.max(unknown_map) + 1\n    K = np.zeros((N_unknown, N_unknown))\n    F = np.zeros(N_unknown)\n\n    for i in range(n - 1):\n        x0 = nodes[i]\n        x1 = nodes[i + 1]\n        h = x1 - x0\n        # Local stiffness and load\n        k_loc = (a / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        f_loc = (h / 2.0) * np.array([1.0, 1.0])\n        iu = unknown_map[i]\n        ju = unknown_map[i + 1]\n        if iu != -1 and ju != -1:\n            K[iu, iu] += k_loc[0, 0]\n            K[iu, ju] += k_loc[0, 1]\n            K[ju, iu] += k_loc[1, 0]\n            K[ju, ju] += k_loc[1, 1]\n            F[iu] += f_loc[0]\n            F[ju] += f_loc[1]\n        elif iu != -1 and ju == -1:\n            K[iu, iu] += k_loc[0, 0]\n            F[iu] += f_loc[0]\n            # boundary contribution with u(boundary)=0 gives no RHS adjustment\n        elif iu == -1 and ju != -1:\n            K[ju, ju] += k_loc[1, 1]\n            F[ju] += f_loc[1]\n        else:\n            # both boundary -> no unknowns, nothing to add\n            pass\n\n    return K, F, unknown_map\n\ndef compute_exact_coeffs(aL, aR):\n    c1 = 0.5 * (aL - aR) / (aL * (aL + aR))\n    d1 = 0.5 * (aL - aR) / (aR * (aL + aR))\n    c2 = (1.0 / (2.0 * aL)) + c1\n    d2 = c2\n    return c1, c2, d1, d2\n\ndef u_exact_left(x, aL, c1, c2):\n    return -x**2 / (2.0 * aL) + c1 * x + c2\n\ndef u_exact_right(x, aR, d1, d2):\n    return -x**2 / (2.0 * aR) + d1 * x + d2\n\ndef reconstruct_full_nodal_values(nodes, unknown_map, U_unknown, boundary_value):\n    # Fill full nodal array with boundary_value at boundary and unknowns mapped\n    u = np.zeros(len(nodes))\n    for i, um in enumerate(unknown_map):\n        if um == -1:\n            u[i] = boundary_value\n        else:\n            u[i] = U_unknown[um]\n    return u\n\ndef add_penalty(K, idx_L0, idx_R0, alpha, h_int):\n    val = alpha / h_int\n    K[idx_L0, idx_L0] += val\n    K[idx_R0, idx_R0] += val\n    K[idx_L0, idx_R0] -= val\n    K[idx_R0, idx_L0] -= val\n\ndef add_nitsche(K, idx_Lprev, idx_L0, idx_R0, idx_Rnext, aL, aR, hL, hR, gamma, h_int):\n    # Construct gradient vector g for average flux\n    g = np.array([-0.5 * aL / hL, 0.5 * aL / hL, 0.5 * aR / hR, -0.5 * aR / hR])\n    # Assemble M1: rows at L0 (-g) and R0 (+g)\n    indices = [idx_Lprev, idx_L0, idx_R0, idx_Rnext]\n    # M1 additions\n    for col_pos, col_idx in enumerate(indices):\n        if idx_L0 is not None:\n            K[idx_L0, col_idx] += -g[col_pos]\n        if idx_R0 is not None:\n            K[idx_R0, col_idx] += +g[col_pos]\n    # M2 additions: columns at L0 (-g) and R0 (+g)\n    for row_pos, row_idx in enumerate(indices):\n        if idx_L0 is not None:\n            K[row_idx, idx_L0] += -g[row_pos]\n        if idx_R0 is not None:\n            K[row_idx, idx_R0] += +g[row_pos]\n    # Stabilization term\n    stab = gamma / h_int\n    K[idx_L0, idx_L0] += stab\n    K[idx_R0, idx_R0] += stab\n    K[idx_L0, idx_R0] -= stab\n    K[idx_R0, idx_L0] -= stab\n\ndef solve_LM(K, F, idx_L0, idx_R0):\n    n = K.shape[0]\n    K_aug = np.zeros((n + 1, n + 1))\n    F_aug = np.zeros(n + 1)\n    K_aug[:n, :n] = K\n    F_aug[:n] = F\n    # B and B^T\n    K_aug[n, idx_L0] = 1.0\n    K_aug[n, idx_R0] = -1.0\n    K_aug[idx_L0, n] = 1.0\n    K_aug[idx_R0, n] = -1.0\n    # Solve\n    sol = np.linalg.solve(K_aug, F_aug)\n    U = sol[:n]\n    # lambda = sol[n], not used\n    return U\n\ndef element_error_L2(x0, x1, u0, u1, a_side, coeffs, side, quad_pts, quad_wts):\n    # Compute L2 error on an element via quadrature\n    # side: 'L' or 'R'\n    # coeffs: (c1,c2) for left or (d1,d2) for right appropriately\n    err_sq = 0.0\n    for t, w in zip(quad_pts, quad_wts):  # t in [-1,1]\n        s = 0.5 * (t + 1.0)  # map to [0,1]\n        x = x0 + s * (x1 - x0)\n        uh = (1.0 - s) * u0 + s * u1\n        if side == 'L':\n            c1, c2 = coeffs\n            ue = u_exact_left(x, a_side, c1, c2)\n        else:\n            d1, d2 = coeffs\n            ue = u_exact_right(x, a_side, d1, d2)\n        diff = uh - ue\n        err_sq += w * diff * diff * 0.5 * (x1 - x0)  # Jacobian factor for mapping [-1,1] to [x0,x1]\n    return err_sq\n\ndef compute_errors(nodes_left, U_left_full, nodes_right, U_right_full, aL, aR, c1, c2, d1, d2, r):\n    # Quadrature\n    qpts, qwts = leggauss(5)\n    # Accumulate errors\n    err_iface = 0.0\n    err_bulk = 0.0\n    # Left elements\n    for i in range(len(nodes_left) - 1):\n        x0 = nodes_left[i]\n        x1 = nodes_left[i + 1]\n        u0 = U_left_full[i]\n        u1 = U_left_full[i + 1]\n        esq = element_error_L2(x0, x1, u0, u1, aL, (c1, c2), 'L', qpts, qwts)\n        # classify\n        if x1 <= -r:\n            err_bulk += esq\n        else:\n            err_iface += esq\n    # Right elements\n    for i in range(len(nodes_right) - 1):\n        x0 = nodes_right[i]\n        x1 = nodes_right[i + 1]\n        u0 = U_right_full[i]\n        u1 = U_right_full[i + 1]\n        esq = element_error_L2(x0, x1, u0, u1, aR, (d1, d2), 'R', qpts, qwts)\n        # classify\n        if x0 >= r:\n            err_bulk += esq\n        else:\n            err_iface += esq\n    return np.sqrt(err_iface), np.sqrt(err_bulk)\n\ndef convergence_rate(log_h, log_err):\n    # Linear regression slope\n    x = np.array(log_h)\n    y = np.array(log_err)\n    xm = np.mean(x)\n    ym = np.mean(y)\n    denom = np.sum((x - xm) ** 2)\n    if denom == 0.0:\n        return 0.0\n    slope = np.sum((x - xm) * (y - ym)) / denom\n    return slope\n\ndef run_test_case(aL, aR, alpha, gamma, r):\n    m_bulk = 4\n    levels = [10, 20, 40]  # n_iface\n    methods = ['penalty', 'nitsche', 'LM']\n    # Store errors per method per level\n    errors_iface = {m: [] for m in methods}\n    errors_bulk = {m: [] for m in methods}\n    h_ints = []\n    for n_iface in levels:\n        # Build meshes\n        nodes_left = build_mesh_left(r, n_iface, m_bulk)\n        nodes_right = build_mesh_right(r, n_iface, m_bulk)\n        # Assemble subdomains\n        KL, FL, mapL = assemble_subdomain(nodes_left, aL, is_left_boundary=True)\n        KR, FR, mapR = assemble_subdomain(nodes_right, aR, is_left_boundary=False)\n        # Global K and F\n        K = np.zeros((KL.shape[0] + KR.shape[0], KL.shape[1] + KR.shape[1]))\n        F = np.zeros(K.shape[0])\n        K[:KL.shape[0], :KL.shape[1]] = KL\n        K[KL.shape[0]:, KL.shape[1]:] = KR\n        F[:KL.shape[0]] = FL\n        F[KL.shape[0]:] = FR\n        # Identify indices\n        # Left interface index in unknowns: last node is interface; previous is second last\n        idx_L0_global = mapL[-1]\n        idx_Lprev_global = mapL[-2]\n        # Right interface index in unknowns: first unknown is interface; next is second unknown\n        idx_R0_global = KL.shape[0] + mapR[0]\n        idx_Rnext_global = KL.shape[0] + mapR[1]\n        # Element sizes adjacent to interface\n        hL = nodes_left[-1] - nodes_left[-2]\n        hR = nodes_right[1] - nodes_right[0]\n        h_int = 0.5 * (hL + hR)\n        h_ints.append(h_int)\n        # Solve per method\n        # Penalty\n        K_pen = K.copy()\n        add_penalty(K_pen, idx_L0_global, idx_R0_global, alpha, h_int)\n        U_pen = np.linalg.solve(K_pen, F)\n        # Nitsche\n        K_nit = K.copy()\n        add_nitsche(K_nit, idx_Lprev_global, idx_L0_global, idx_R0_global, idx_Rnext_global, aL, aR, hL, hR, gamma, h_int)\n        U_nit = np.linalg.solve(K_nit, F)\n        # LM\n        U_lm = solve_LM(K.copy(), F.copy(), idx_L0_global, idx_R0_global)\n        # Reconstruct full nodal values\n        U_left_pen_full = reconstruct_full_nodal_values(nodes_left, mapL, U_pen[:KL.shape[0]], 0.0)\n        U_right_pen_full = reconstruct_full_nodal_values(nodes_right, mapR, U_pen[KL.shape[0]:], 0.0)\n        U_left_nit_full = reconstruct_full_nodal_values(nodes_left, mapL, U_nit[:KL.shape[0]], 0.0)\n        U_right_nit_full = reconstruct_full_nodal_values(nodes_right, mapR, U_nit[KL.shape[0]:], 0.0)\n        U_left_lm_full = reconstruct_full_nodal_values(nodes_left, mapL, U_lm[:KL.shape[0]], 0.0)\n        U_right_lm_full = reconstruct_full_nodal_values(nodes_right, mapR, U_lm[KL.shape[0]:], 0.0)\n        # Exact coefficients\n        c1, c2, d1, d2 = compute_exact_coeffs(aL, aR)\n        # Errors\n        ei_pen, eb_pen = compute_errors(nodes_left, U_left_pen_full, nodes_right, U_right_pen_full, aL, aR, c1, c2, d1, d2, r)\n        ei_nit, eb_nit = compute_errors(nodes_left, U_left_nit_full, nodes_right, U_right_nit_full, aL, aR, c1, c2, d1, d2, r)\n        ei_lm, eb_lm = compute_errors(nodes_left, U_left_lm_full, nodes_right, U_right_lm_full, aL, aR, c1, c2, d1, d2, r)\n        errors_iface['penalty'].append(ei_pen)\n        errors_iface['nitsche'].append(ei_nit)\n        errors_iface['LM'].append(ei_lm)\n        errors_bulk['penalty'].append(eb_pen)\n        errors_bulk['nitsche'].append(eb_nit)\n        errors_bulk['LM'].append(eb_lm)\n    # Compute rates\n    log_h = np.log(np.array(h_ints))\n    rates_iface = []\n    rates_bulk = []\n    for m in methods:\n        rates_iface.append(convergence_rate(log_h, np.log(np.array(errors_iface[m]))))\n        rates_bulk.append(convergence_rate(log_h, np.log(np.array(errors_bulk[m]))))\n    return rates_iface, rates_bulk\n\ndef solve():\n    test_cases = [\n        (1.0, 10.0, 10.0, 10.0, 0.3),\n        (1.0, 1.0, 1.0, 1.0, 0.2),\n        (0.1, 100.0, 100.0, 50.0, 0.1),\n    ]\n    results = []\n    for aL, aR, alpha, gamma, r in test_cases:\n        rates_iface, rates_bulk = run_test_case(aL, aR, alpha, gamma, r)\n        # Round for readability\n        iface_list = [float(f\"{rate:.6f}\") for rate in rates_iface]\n        bulk_list = [float(f\"{rate:.6f}\") for rate in rates_bulk]\n        results.append([iface_list, bulk_list])\n    # Final output\n    # Print single line with comma-separated list enclosed in square brackets\n    # Convert nested lists to string without spaces to match strict format\n    def list_to_str(lst):\n        if isinstance(lst, list):\n            return \"[\" + \",\".join(list_to_str(x) for x in lst) + \"]\"\n        else:\n            return str(lst)\n    print(list_to_str(results))\n\nsolve()\n```", "id": "3512524"}]}