{"hands_on_practices": [{"introduction": "要真正掌握SIMPLE系列算法，必须首先理解区分其不同成员的核心近似方法。本练习深入探讨了标准SIMPLE算法与其“一致性”变体SIMPLEC之间的根本理论差异。通过从第一性原理出发，推导每种方法的速度修正方程，您将清晰地洞察它们如何处理压力和速度修正之间的耦合，而这直接影响到算法的收敛行为[@problem_id:3362268]。", "problem": "考虑沿 $x$ 方向的稳态一维不可压缩流，该流场在均匀网格上通过有限体积法进行离散。内部控制体为 $P$，其西侧和东侧的相邻点分别用 $W$ 和 $E$ 表示。设节点 $P$ 处的 $x$ 方向动量方程的离散化线性对流-扩散形式为 $a_{P} u_{P} = a_{W} u_{W} + a_{E} u_{E} + b + S \\left( p_{W} - p_{E} \\right)$，其中 $u_{P}$ 是节点速度，$p_{P}$ 是节点压力，$a_{P}$、$a_{W}$ 和 $a_{E}$ 是由对流-扩散通量产生的对角和相邻系数，$b$ 是一个已知的源项贡献，$S$ 是控制体面的横截面积。假设已经通过使用一个猜测的压力场求解动量方程，得到了临时速度 $u^{*}$ 和临时压力 $p^{*}$。通过 $u = u^{*} + u^{\\prime}$ 和 $p = p^{*} + p^{\\prime}$ 定义修正量 $u^{\\prime}$ 和 $p^{\\prime}$。在压力耦合方程组的半隐式方法 (SIMPLE) 和 SIMPLE-Consistent (SIMPLEC) 算法中，速度修正量 $u_{P}^{\\prime}$ 是在关于相邻速度修正量的不同一致性假设下，从动量修正方程中得到的。从控制体的积分形式动量守恒及其标准的有限体积离散化出发，推导 SIMPLE 和 SIMPLEC 算法在节点 $P$ 处使用的速度修正表达式，然后计算在 $P$ 处由 SIMPLEC 预测和由 SIMPLE 预测的速度修正量之间的差值。在一维情况下，假设修正场是缓变的，因此在一阶近似下有 $u_{W}^{\\prime} \\approx u_{P}^{\\prime}$ 和 $u_{E}^{\\prime} \\approx u_{P}^{\\prime}$。将你的最终答案表示为一个单一的、简化的解析表达式，用 $a_{P}$、$a_{W}$、$a_{E}$、$S$ 和 $\\Delta p^{\\prime} = p_{W}^{\\prime} - p_{E}^{\\prime}$ 来表示。不要引入任何额外的参数。你的最终答案必须是一个单一的封闭形式表达式，表达式内不含单位。", "solution": "问题要求在计算流体力学中为 SIMPLE 和 SIMPLEC 算法推导速度修正表达式，并计算这些修正量之间的差值。我们从给定的离散化动量方程和修正场的定义开始。\n\n对于节点 $P$ 及其相邻点 $W$ 和 $E$，真实速度场 $u$ 和真实压力场 $p$ 的离散化动量方程如下：\n$$a_{P} u_{P} = a_{W} u_{W} + a_{E} u_{E} + b + S \\left( p_{W} - p_{E} \\right)$$\n通过对相邻点 ($nb$) 求和，可以更紧凑地写成：\n$$a_{P} u_{P} = \\sum_{nb} a_{nb} u_{nb} + b + S \\left( p_{W} - p_{E} \\right)$$\n在 SIMPLE 系列算法中，通过使用猜测的或上一次迭代的压力场 $p^{*}$ 求解动量方程，来计算临时速度场 $u^{*}$：\n$$a_{P} u_{P}^{*} = \\sum_{nb} a_{nb} u_{nb}^{*} + b + S \\left( p_{W}^{*} - p_{E}^{*} \\right)$$\n真实场通过修正量与临时场相关联，修正量用上撇号 ($^{\\prime}$) 表示：\n$$u = u^{*} + u^{\\prime}$$\n$$p = p^{*} + p^{\\prime}$$\n将这些定义代入第一个方程，我们得到节点 $P$ 的方程：\n$$a_{P} (u_{P}^{*} + u_{P}^{\\prime}) = \\sum_{nb} a_{nb} (u_{nb}^{*} + u_{nb}^{\\prime}) + b + S \\left( (p_{W}^{*} + p_{W}^{\\prime}) - (p_{E}^{*} + p_{E}^{\\prime}) \\right)$$\n展开各项可得：\n$$a_{P} u_{P}^{*} + a_{P} u_{P}^{\\prime} = \\sum_{nb} a_{nb} u_{nb}^{*} + \\sum_{nb} a_{nb} u_{nb}^{\\prime} + b + S \\left( p_{W}^{*} - p_{E}^{*} \\right) + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n为了得到修正量的方程，我们从这个展开后的方程中减去临时场的方程。涉及 $u^{*}$ 和 $p^{*}$ 的项相互抵消：\n$$(a_{P} u_{P}^{*} + a_{P} u_{P}^{\\prime}) - (a_{P} u_{P}^{*}) = \\left(\\sum_{nb} a_{nb} u_{nb}^{*} + \\sum_{nb} a_{nb} u_{nb}^{\\prime} + b + S(p_{W}^{*} - p_{E}^{*}) + S(p_{W}^{\\prime} - p_{E}^{\\prime})\\right) - \\left(\\sum_{nb} a_{nb} u_{nb}^{*} + b + S(p_{W}^{*} - p_{E}^{*})\\right)$$\n这就简化为动量修正方程：\n$$a_{P} u_{P}^{\\prime} = \\sum_{nb} a_{nb} u_{nb}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n在我们的一维情况下，该方程为：\n$$a_{P} u_{P}^{\\prime} = a_{W} u_{W}^{\\prime} + a_{E} u_{E}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n现在，我们基于 SIMPLE 和 SIMPLEC 算法所做的特定近似，来推导速度修正量 $u_{P}^{\\prime}$ 的表达式。\n\n**SIMPLE 算法的速度修正**\n标准的 SIMPLE 算法通过忽略相邻速度修正项 $\\sum_{nb} a_{nb} u_{nb}^{\\prime}$ 来简化动量修正方程。这是一个重要的近似，其基础假设是压力修正是速度变化的主要驱动力。将此近似应用于我们的一维方程：\n$$a_{P} u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n求解节点 $P$ 处的速度修正量，得到 SIMPLE 算法的预测结果：\n$$u_{P, \\text{SIMPLE}}^{\\prime} = \\frac{S}{a_{P}} \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n**SIMPLEC 算法的速度修正**\nSIMPLEC (SIMPLE-Consistent) 算法旨在实现一个更一致的近似。它不是完全舍弃相邻修正项，而是对其进行近似。问题陈述要求使用速度修正场缓变的假设，即 $u_{W}^{\\prime} \\approx u_{P}^{\\prime}$ 和 $u_{E}^{\\prime} \\approx u_{P}^{\\prime}$。我们将此近似代入完整的动量修正方程：\n$$a_{P} u_{P}^{\\prime} \\approx a_{W} u_{P}^{\\prime} + a_{E} u_{P}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n现在，我们将包含 $u_{P}^{\\prime}$ 的项组合到左侧，然后求解 $u_{P}^{\\prime}$：\n$$a_{P} u_{P}^{\\prime} - a_{W} u_{P}^{\\prime} - a_{E} u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n$$\\left( a_{P} - a_{W} - a_{E} \\right) u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n这就得到了由 SIMPLEC 预测的节点 $P$ 处速度修正量：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} = \\frac{S}{a_{P} - a_{W} - a_{E}} \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n**SIMPLEC 和 SIMPLE 修正量之间的差值**\n最后，我们计算由 SIMPLEC 预测和由 SIMPLE 预测的速度修正量之间的差值。我们使用给定的定义 $\\Delta p^{\\prime} = p_{W}^{\\prime} - p_{E}^{\\prime}$。\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = \\frac{S \\Delta p^{\\prime}}{a_{P} - a_{W} - a_{E}} - \\frac{S \\Delta p^{\\prime}}{a_{P}}$$\n提出公因式 $S \\Delta p^{\\prime}$：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{1}{a_{P} - a_{W} - a_{E}} - \\frac{1}{a_{P}} \\right)$$\n为了简化，我们通过找到公分母 $a_{P} (a_{P} - a_{W} - a_{E})$ 来合并括号内的分数：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{P} - \\left( a_{P} - a_{W} - a_{E} \\right)}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n简化分子：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{P} - a_{P} + a_{W} + a_{E}}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{W} + a_{E}}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n这就得到了所要求的、速度修正量差值的最终简化解析表达式。", "answer": "$$\\boxed{\\frac{S \\Delta p^{\\prime} (a_{W} + a_{E})}{a_{P} (a_{P} - a_{W} - a_{E})}}$$", "id": "3362268"}, {"introduction": "计算科学中的一项关键技能是验证数值实现是否正确地求解了预期的方程。本练习将指导您使用“制造解方法”（Method of Manufactured Solutions, MMS），这是一种评估代码准确性的强大技术。通过求解一个具有已知解析解的问题，您将验证压力修正方程的空间离散格式是否达到了其理论上的二阶收敛精度，这是开发可靠CFD求解器的关键里程碑[@problem_id:3362285]。", "problem": "考虑在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 内，具有恒定密度 $\\rho$ 和运动粘度 $\\nu$ 的牛顿流体的稳态、二维、不可压缩流动。控制方程为稳态不可压缩 Navier–Stokes 方程：\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\quad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f},\n$$\n边界条件为无滑移速度边界条件，以及下文指定的在 $\\partial\\Omega$ 上的压力修正的狄利克雷边界条件。此处，$\\mathbf{u} = (u,v)$ 是速度场，$p$ 是压力。\n\n您将采用人工解法（Method of Manufactured Solutions）构造一个精确解析解，并用它来验证三种压力-速度耦合算法：SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）计算出的压力修正 $p'$ 的空间收敛阶。\n\n人工解析解：\n- 选择速度场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\qquad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\n$$\n该速度场对所有 $(x,y)\\in\\Omega$ 均满足 $\\nabla\\cdot\\mathbf{u}=0$。选择压力场\n$$\np(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n该压力场在 $\\partial\\Omega$ 上满足 $p(x,y)=0$。利用这些场，可以构造一个体积力 $\\mathbf{f}(x,y)$，使得 $(\\mathbf{u},p)$ 成为稳态方程的精确解。\n\nSIMPLE 族算法中的压力修正方程：\n- 在压力-速度耦合框架中，压力修正 $p'$ 满足一个泊松型压力修正方程，该方程源于对预测的质量通量强制执行质量守恒。在均匀网格、中心差分和动量方程对角元恒定的条件下，压力修正方程简化为：\n$$\n\\nabla^2 p'(x,y) = s(x,y),\n$$\n边界条件为在 $\\partial\\Omega$ 上的齐次狄利克雷边界条件 $p'(x,y)=0$。为验证目的，取人工构造的压力修正为 $p'(x,y) = p(x,y)$，并设猜测压力为零，相应地将源项定义为：\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n从而压力修正方程的精确解为 $p'(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$。\n\n您的任务：\n- 从稳态不可压缩 Navier–Stokes 方程和 SIMPLE 族算法中压力修正方程的定义出发，证明在给定的人工假设（均匀网格、系数恒定、中心差分、狄利克雷边界数据）下，SIMPLE、SIMPLER 和 SIMPLEC 的离散化压力修正方程均退化为 $p'(x,y)$ 的标量泊松问题的同一个二阶中心差分近似。\n\n- 实现一个求解器，使用二阶中心差分在一系列覆盖 $\\Omega$ 的均匀笛卡尔网格上近似求解 $p'(x,y)$。网格由每个坐标方向上的等分数量 $N\\in\\{8,16,32,64\\}$ 指定，因此网格间距为 $h=1/N$，未知量位于每个方向的 $N-1$ 个内部点上，边界上 $p'=0$。对每个 $N$，组装标准的五点离散拉普拉斯算子，并求解得到的线性系统。\n\n- 对每个 $N$，计算数值解 $p'_h$ 相对于精确人工解 $p'(x,y)$ 的离散 $\\ell^2$ 误差。离散 $\\ell^2$ 误差必须定义为：\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n其中 $x_i=i\\,h$ 和 $y_j=j\\,h$，$i=1,\\dots,N-1$，$j=1,\\dots,N-1$。\n\n- 对于每种算法变体（SIMPLE、SIMPLER、SIMPLEC），使用两个最密的网格通过以下公式计算 $p'$ 的观测收敛阶 $r$：\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)},\n$$\n其中 $h=1/32$ 且 $h/2=1/64$。在这种人工设定的情况下，所有三种算法对压力修正方程使用相同的空间离散化，因此观测到的 $r$ 值应相等且接近 $2$。\n\n测试套件和输出规范：\n- 使用网格尺寸 $N\\in\\{8,16,32,64\\}$ 作为测试套件，以覆盖粗网格的边缘情况和逐渐加密的网格。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{SIMPLE},\\text{SIMPLER},\\text{SIMPLEC}]$。列表中的每个条目是按上述方法计算的 $r$ 的浮点值，例如 $[r_{\\text{SIMPLE}},r_{\\text{SIMPLER}},r_{\\text{SIMPLEC}}]$。", "solution": "控制方程为稳态不可压缩 Navier–Stokes 方程：\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\qquad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f}.\n$$\n我们选择人工构造的场为\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\quad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\\quad p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n这些场满足不可压缩性条件，因为\n$$\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n= \\pi\\cos(\\pi x)\\,\\cos(\\pi y) - \\pi\\cos(\\pi x)\\,\\cos(\\pi y) = 0.\n$$\n给定 $\\rho$ 和 $\\nu$，可将 $(\\mathbf{u},p)$ 代入动量方程，并计算出使 $(\\mathbf{u},p)$ 成为精确解的体积力 $\\mathbf{f}(x,y)$；这利用了控制定律的基本原理。\n\nSIMPLE（Semi-Implicit Method for Pressure-Linked Equations）族算法中的压力-速度耦合引入了一个根据猜测压力计算的中间速度 $\\mathbf{u}^*$，随后使用压力修正 $p'$ 来修正质量通量以满足连续性方程。修正步骤满足一个从离散连续性方程和离散动量方程导出的压力修正方程。在其一般的有限体积形式中，离散压力修正方程可以写为：\n$$\n\\sum_{f\\in \\text{faces}} \\rho\\,d_f\\,\\left(p'_N - p'_P\\right) = \\sum_{f\\in \\text{faces}} \\dot{m}^*_f,\n$$\n其中 $d_f$ 是代表动量方程对角元倒数和几何因子的系数，$P$ 表示所考虑的单元，$N$ 表示相邻单元，$\\dot{m}^*_f$ 是违反连续性方程的预测质量通量。在均匀网格、物性恒定和中心差分的条件下，动量方程对角元 $a_P$ 在所有单元中均为常数，面系数 $d_f$ 也变为常数，预测质量通量的离散散度简化为对 $p'$ 的离散拉普拉斯算子的均匀缩放。因此，修正方程简化为标量泊松问题：\n$$\n\\nabla^2 p'(x,y) = s(x,y)\n$$\n当猜测压力为零且精确压力在边界上消失时，边界条件为在 $\\partial\\Omega$ 上的齐次狄利克雷边界条件。此简化仅使用了算法的核心定义和结构，而没有调用简化公式。SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）之间的区别在于中间速度 $\\mathbf{u}^*$ 和耦合系数的形成方式，但在人工构造的均匀系数情况下，它们对压力修正方程的空间离散化是相同的。\n\n为了构造源项，我们取 $p'(x,y) = p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$（这与猜测压力为零的情况一致），因此\n$$\n\\nabla^2 p'(x,y) = \\frac{\\partial^2}{\\partial x^2}\\sin(\\pi x)\\,\\sin(\\pi y) + \\frac{\\partial^2}{\\partial y^2}\\sin(\\pi x)\\,\\sin(\\pi y)\n= -\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n从而\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n\n我们在均匀网格上离散化泊松方程，网格间距为 $h=1/N$，内部点为 $(x_i,y_j) = (i h, j h)$，$i=1,\\dots,N-1$，$j=1,\\dots,N-1$。在笛卡尔网格上，对 $\\nabla^2 p'$ 的标准二阶中心差分近似得到五点模板：\n$$\n\\left(\\nabla^2 p'\\right)_{i,j} \\approx \\frac{p'_{i+1,j} - 2 p'_{i,j} + p'_{i-1,j}}{h^2} + \\frac{p'_{i,j+1} - 2 p'_{i,j} + p'_{i,j-1}}{h^2},\n$$\n该近似在 $h$ 上具有二阶精度。应用在 $\\partial\\Omega$ 上的齐次狄利克雷边界条件 $p'=0$ 后，离散系统呈矩阵形式：\n$$\n\\mathbf{L}\\,\\mathbf{p} = h^2\\,\\mathbf{s},\n$$\n其中 $\\mathbf{L}$ 是使用五点模板的离散二维拉普拉斯算子，$\\mathbf{p}$ 和 $\\mathbf{s}$ 分别是内部节点上的未知量和源项值的向量。\n\n离散 $\\ell^2$ 误差定义为：\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n这是连续 $L^2$ 范数的一致求积。对于二阶中心差分，截断误差为 $\\mathcal{O}(h^2)$，对于均匀网格上的光滑解，在狄利克雷边界条件下，离散解在 $h$ 上以 2 阶收敛，因此我们预期：\n$$\nE(h) \\approx C\\,h^2\n$$\n其中 $C$ 为某个常数，这导致观测到的收敛阶为：\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)} \\approx 2.\n$$\n\n在所描述的人工设定中，SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）对压力修正方程共享相同的空间离散化，因此当线性系统求解至收敛时，它们会产生相同的 $p'$ 解。因此，对 $h=1/32$ 和 $h/2=1/64$ 计算 $E(h)$ 并按上式构造 $r$，应得出三个接近 $2$ 的相等值。该实现使用二维离散拉普拉斯算子的克罗内克和构造以及一个稀疏直接线性求解器来消除迭代效应并分离出空间离散误差，这与基于原理的推导和验证任务相符。\n\n程序评估了 $N\\in\\{8,16,32,64\\}$ 时的误差，并报告了从两个最密的网格计算出的三个观测阶数 $[r_{\\text{SIMPLE}}, r_{\\text{SIMPLER}}, r_{\\text{SIMPLEC}}]$，从而在这种人工的、均匀系数的极限情况下，验证了所有三种算法的 $p'$ 在网格加密下的二阶收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef build_poisson_matrix(m):\n    \"\"\"\n    Build the 2D Poisson matrix with Dirichlet boundary conditions\n    on an m x m interior grid using the 5-point Laplacian.\n    \"\"\"\n    # 1D Laplacian (Dirichlet interior nodes): tridiagonal [-1, 2, -1]\n    main = -2.0 * np.ones(m)\n    off = 1.0 * np.ones(m - 1)\n    L1 = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    I = identity(m, format='csr')\n    # 2D Laplacian via Kronecker sum\n    L2 = kron(I, L1) + kron(L1, I)\n    return L2\n\ndef manufactured_source_and_exact(N):\n    \"\"\"\n    Compute source term s(x,y) = 2*pi^2*sin(pi*x)*sin(pi*y)\n    and exact p'(x,y) at interior points for grid size N (spacing h=1/N).\n    Returns (s_flat, p_exact_flat).\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    x = np.linspace(h, 1.0 - h, m)\n    y = np.linspace(h, 1.0 - h, m)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    p_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    s = 2.0 * (np.pi ** 2) * p_exact\n    return s.ravel(), p_exact.ravel()\n\ndef solve_poisson(N):\n    \"\"\"\n    Solve L p = h^2 * s for p on interior grid for given N,\n    with exact source manufactured from p'(x,y) = sin(pi*x)*sin(pi*y).\n    Returns L2 error E(h) with discrete quadrature.\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    L = build_poisson_matrix(m)\n    s_flat, p_exact_flat = manufactured_source_and_exact(N)\n    rhs = (h ** 2) * s_flat\n    p_num = spsolve(L, rhs)\n    # Discrete L2 error: sqrt(sum((error)^2)) * h\n    err = p_num - p_exact_flat\n    E = np.sqrt(np.sum(err ** 2)) * h\n    return E\n\ndef observed_order(e_h, e_h2):\n    \"\"\"\n    Compute observed order r = log(e_h/e_h2)/log(2),\n    where h2 = h/2 (i.e., N doubled).\n    \"\"\"\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    grid_sizes = [8, 16, 32, 64]\n\n    # Compute errors for each grid size.\n    errors = {}\n    for N in grid_sizes:\n        errors[N] = solve_poisson(N)\n\n    # Compute observed order using the two finest grids N=32 and N=64.\n    e32 = errors[32]\n    e64 = errors[64]\n    r = observed_order(e32, e64)\n\n    # In this manufactured uniform-coefficient setting, SIMPLE, SIMPLER, and SIMPLEC\n    # produce identical spatial discretizations for the pressure correction equation,\n    # hence identical observed orders.\n    results = [r, r, r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362285"}, {"introduction": "除了形式上的准确性，一个鲁棒的数值求解器还必须能够处理潜在的不稳定性。本练习直面不可压缩流模拟中的一个经典挑战：当仅指定诺伊曼（Neumann）边界条件时，压力的不确定性。您将研究压力的“浮动”现象，并实施常见的稳定化技术，例如强制零平均值约束或固定一个压力点，以确保获得唯一且稳定的解[@problem_id:3362264]。", "problem": "考虑一个单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维、定常、不可压缩流。其控制约束为连续性方程 $\\nabla \\cdot \\mathbf{u} = 0$，其中 $\\mathbf{u} = (u_x, u_y)$ 是速度场。在压力耦合方程组的半隐式方法 (Semi-Implicit Method for Pressure-Linked Equations, SIMPLE) 算法族（包括 SIMPLE-Revised (SIMPLER) 和 SIMPLE-Consistent (SIMPLEC)）中，一个预测速度 $\\mathbf{u}^*$ 通过压力修正 $p'$ 进行修正，使得修正后的速度为 $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* + \\mathbf{u}'$，并且通过一个形式为 $\\mathbf{u}' \\approx -\\kappa \\nabla p'$ 的关系式来近似满足连续性，其中 $\\kappa > 0$ 是一个常数，它将从线性化动量方程中获得的速度修正与压力梯度联系起来。压力修正 $p'$ 是通过求解一个泊松型方程得到的，该方程是将 $\\mathbf{u}^{\\text{new}}$ 代入连续性条件后产生的。对于 $p'$ 的纯诺伊曼边界条件（法向梯度为零），$p'$ 的离散算子拥有一个包含常数的零空间。如果没有压力基准，$p'$ 可以浮动一个任意的附加常数，并且如果由于建模或离散化缺陷导致源项的域积分为非零，则在迭代求解过程中可能会发生漂移。\n\n你的任务是使用 $\\Omega$ 上的一个 $N \\times N$ 节点的均匀笛卡尔网格，在一个程序中实现以下场景：\n\n- 使用均匀间距 $h = 1/(N-1)$ 和节点坐标 $(x_i,y_j)$，其中 $x_i = i h$，$y_j = j h$，适用于所有满足 $0 \\leq i,j \\leq N-1$ 的整数 $i,j$。\n- 将预测速度 $\\mathbf{u}^*$ 构建为一个无散分量和一个可压缩缺陷的叠加，其中无散分量由流函数 $\\psi(x,y)$ 得到：\n  - 令 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，并定义无散基础速度 $\\mathbf{u}^{\\text{df}} = (\\partial \\psi / \\partial y, -\\partial \\psi / \\partial x)$。\n  - 定义一个可压缩缺陷 $\\mathbf{u}^{\\text{c}} = (\\varepsilon \\sin(\\pi x)\\sin(\\pi y), 0)$，其中 $\\varepsilon > 0$ 是一个小振幅。\n  - 设置 $\\mathbf{u}^* = \\mathbf{u}^{\\text{df}} + \\mathbf{u}^{\\text{c}}$。\n- 使用内部的二阶中心差分和边界处的镜像（诺伊曼）边界处理来计算网格上的离散散度，以形成源项 $f = \\nabla \\cdot \\mathbf{u}^*$。\n- 使用标准的五点拉普拉斯模板和镜像（诺伊曼）边界条件构造 $p'$ 的离散泊松方程。使用雅可比迭代来更新 $p'$：\n  - 对于内部点，更新基于相邻点的平均值减去 $h^2 f / 4$。\n  - 在边界处，实现与 $\\partial p'/\\partial n = 0$ 一致的镜像相邻点处理。\n- 实现以下三种压力修正求解的算法变体：\n  $1$) 浮动 $p'$：无压力基准或约束。\n  $2$) 受约束的 $p'$：在每次迭代中离散地施加零均值条件，即强制执行 $\\sum_{i,j} p'_{i,j} h^2 = 0$，这是 $\\int_{\\Omega} p' \\, dV = 0$ 的离散形式。\n  $3$) 单单元格锚定：通过在每次迭代中设置 $p'_{0,0} = 0$ 来约束一个特定单元格（例如 $(i,j) = (0,0)$）。\n\n为了分析在不正确的压力基准下的漂移和收敛行为，通过一个常数偏移量 $m$ 对源项 $f$ 进行扰动，使得 $f \\leftarrow f + m$，其中 $m$ 可能非零。这模拟了一种源项的域积分不为零的不一致性，该不一致性与诺伊曼拉普拉斯算子的零空间相互作用。\n\n对每种变体，计算：\n- $p'$ 的最终均值（离散积分除以面积），用于量化压力漂移（无量纲）。\n- 离散泊松方程的最终残差范数 $\\|\\Delta_h p' - f\\|_2$，其中 $\\Delta_h$ 是离散拉普拉斯算子（无量纲）。\n- 通过使用中心差分计算 $\\nabla_h$ 来计算修正后的速度 $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* - \\kappa \\nabla_h p'$，然后测量 $\\nabla \\cdot \\mathbf{u}^{\\text{new}}$ 的离散 $L^2$ 范数，以此来评估对速度的影响（无量纲）。\n- 达到目标残差容差所需的迭代次数，或者，如果未达到，则为执行的最大迭代次数（整数计数）。\n\n使用以下常数和数值选择：\n- 取 $\\kappa = 1$。\n- 将 $p'$ 处处初始化为零。\n- 使用无超松弛的雅可比迭代。\n- 定义残差容差为 $\\text{tol} = 10^{-8}$，最大迭代次数为 $2000$。\n\n设计一个测试套件以检验不同的行为：\n- 情况 A（具有可观察漂移的理想路径）：$N = 32$，$\\varepsilon = 0.2$，$m = 10^{-3}$，浮动 $p'$（无约束）。\n- 情况 B（约束消除漂移）：$N = 32$，$\\varepsilon = 0.2$，$m = 10^{-3}$，受约束的零均值 $p'$。\n- 情况 C（锚定参考单元格）：$N = 32$，$\\varepsilon = 0.2$，$m = 10^{-3}$，在 $(0,0)$ 处进行单单元格锚定。\n- 情况 D（相容源项，在无强迫项的情况下测试零空间）：$N = 32$，$\\varepsilon = 0.2$，$m = 0$，浮动 $p'$。\n\n所有量均为无量纲；除迭代次数为整数外，所有输出均报告为浮点数。你的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个测试用例贡献一个包含四个值的列表，顺序为 $[\\text{mean}(p'), \\|\\Delta_h p' - f\\|_2, \\|\\nabla \\cdot \\mathbf{u}^{\\text{new}}\\|_2, \\text{iterations}]$。例如，格式为 $[[r_{A1}, r_{A2}, r_{A3}, r_{A4}], [r_{B1}, r_{B2}, r_{B3}, r_{B4}], [r_{C1}, r_{C2}, r_{C3}, r_{C4}], [r_{D1}, r_{D2}, r_{D3}, r_{D4}]]$.", "solution": "该问题要求对不可压缩流的压力修正方法进行分析，特别关注在纯诺伊曼边界条件下求解压力修正泊松方程的数值稳定性。任务的核心是实现一个数值模拟，以演示不同的稳定化技术如何处理离散诺伊曼-拉普拉斯算子的零空间（常值函数），尤其是在源项不相容（即其域积分为非零）的情况下。\n\n解决方案通过以下步骤进行开发：\n\n1.  **离散化与场定义**：\n    连续域 $\\Omega = [0,1] \\times [0,1]$ 被离散化为一个 $N \\times N$ 个节点的均匀笛卡尔网格。网格间距为 $h = 1/(N-1)$。节点坐标为 $(x_i, y_j)$，其中 $x_i = i h$，$y_j = j h$，适用于从 $0$ 到 $N-1$ 的整数 $i,j$。\n    在此网格上构建一个预测速度场 $\\mathbf{u}^* = (u_x^*, u_y^*)$。它包含一个从流函数 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 推导而来的无散部分 $\\mathbf{u}^{\\text{df}}$ 和一个可压缩缺陷 $\\mathbf{u}^{\\text{c}}$：\n    $$ \\mathbf{u}^{\\text{df}} = \\left( \\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x} \\right) = (2\\pi \\sin(2\\pi x)\\cos(2\\pi y), -2\\pi \\cos(2\\pi x)\\sin(2\\pi y)) $$\n    $$ \\mathbf{u}^{\\text{c}} = (\\varepsilon \\sin(\\pi x)\\sin(\\pi y), 0) $$\n    最终得到的预测速度为 $\\mathbf{u}^* = \\mathbf{u}^{\\text{df}} + \\mathbf{u}^{\\text{c}}$。\n\n2.  **源项构建**：\n    压力修正 $p'$ 必须满足泊松方程 $\\Delta p' = f$，其中源项 $f$ 是预测速度的散度，$f = \\nabla \\cdot \\mathbf{u}^*$。从解析上讲，$\\nabla \\cdot \\mathbf{u}^{\\text{df}} = 0$，因此散度完全由缺陷引起：$f = \\nabla \\cdot \\mathbf{u}^{\\text{c}} = \\varepsilon \\pi \\cos(\\pi x) \\sin(\\pi y)$。\n    问题指定使用记为 $\\nabla_h \\cdot$ 的二阶中心差分算子来离散地计算 $f$。对于一个矢量场 $\\mathbf{q}=(q_x, q_y)$，其在节点 $(i,j)$ 处的散度为：\n    $$ (\\nabla_h \\cdot \\mathbf{q})_{i,j} = \\frac{q_{x,i+1,j} - q_{x,i-1,j}}{2h} + \\frac{q_{y,i,j+1} - q_{y,i,j-1}}{2h} $$\n    在边界处，使用镜像（零诺伊曼）边界处理。这是通过使用虚拟点来实现的，虚拟点上场的值是其对应内部点的对称反射（例如，$q_{x,-1,j} = q_{x,1,j}$）。该方法被一致地应用于所有离散微分算子。\n\n3.  **压力修正泊松方程**：\n    我们求解离散泊松方程 $\\Delta_h p' = f$，其中 $\\Delta_h$ 是与零诺伊曼边界条件 $\\partial p'/\\partial n = 0$ 一致的拉普拉斯算子标准五点模板。雅可比迭代在第 $k+1$ 步的更新规则是：\n    $$ p'^{(k+1)}_{i,j} = \\frac{1}{4} \\left( p'^{(k)}_{i+1,j} + p'^{(k)}_{i-1,j} + p'^{(k)}_{i,j+1} + p'^{(k)}_{i,j-1} - h^2 f_{i,j} \\right) $$\n    镜像边界条件通过虚拟点处理，例如在边界 $i=0$ 处：\n    $$ p'^{(k+1)}_{0,j} = \\frac{1}{4} \\left( 2p'^{(k)}_{1,j} + p'^{(k)}_{0,j+1} + p'^{(k)}_{0,j-1} - h^2 f_{0,j} \\right) $$\n    源项 $f$ 被一个常数偏移量 $m$ 扰动，因此方程变为 $\\Delta_h p' = f + m$。这模拟了一种常见的数值情况，即离散源项求和不为零，$\\sum_{i,j} (f_{i,j}+m)h^2 \\neq 0$。这违背了诺伊曼-泊松问题的可解性条件，因为根据散度定理，拉普拉斯算子输出的积分总是为零。\n\n4.  **处理零空间**：\n    带有诺伊曼边界条件的离散算子 $\\Delta_h$ 有一个由常数场组成的零空间。这意味着如果 $p'$ 是一个解，那么对于任意常数 $C$，$p' + C$ 也是解。如果源项不相容（非零积分），迭代解通常会发散或漂移。实现了三种变体来处理这个问题：\n    - **浮动 $p'$**：不施加任何约束。对于不相容源项（$m \\neq 0$），$p'$ 的均值预计会无限漂移。\n    - **受约束的 $p'$**：在每次迭代时强制执行零均值条件 $\\sum_{i,j} p'_{i,j} h^2 = 0$。这是通过计算更新后压力场的算术平均值并将其从每个点减去来实现的：$p' \\leftarrow p' - \\text{mean}(p')$。这稳定了均值，但不能解决根本的不相容性问题，从而阻止收敛到指定的容差。\n    - **单单元格锚定**：在每次迭代时将单个单元格的压力 $p'_{0,0}$ 固定为 $0$。这消除了常数偏移的自由度，使线性系统非奇异，并确保即使在有不相容源项的情况下也能收敛到唯一解。\n\n5.  **度量指标计算**：\n    在迭代求解器收敛到 $\\text{tol} = 10^{-8}$ 的容差或达到 $2000$ 次迭代的最大值后，计算四个度量指标：\n    - **$p'$ 的均值**：最终压力场的算术平均值，$\\frac{1}{N^2}\\sum_{i,j}p'_{i,j}$。\n    - **残差范数**：最终残差的离散 $L^2$ 范数，$\\|\\Delta_h p' - (f+m)\\|_2 = \\sqrt{\\sum_{i,j} (\\Delta_h p'_{i,j} - (f_{i,j}+m))^2}$。\n    - **修正后速度散度范数**：计算新的速度场 $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* - \\kappa \\nabla_h p'$，其中 $\\kappa=1$，$\\nabla_h$ 是离散梯度算子（使用中心差分和镜像边界）。然后计算其散度的 $L^2$ 范数 $\\|\\nabla_h \\cdot \\mathbf{u}^{\\text{new}}\\|_2$。\n    - **迭代次数**：执行的雅可比迭代次数。\n\n实现代码封装了此逻辑，并将其系统地应用于四个指定的测试用例，每个用例都旨在突出数值行为的不同方面。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, epsilon, m, constraint_type, tol, max_iter, kappa):\n    \"\"\"\n    Runs a single simulation case for the pressure-correction Poisson problem.\n\n    Args:\n        N (int): Number of grid points in each dimension.\n        epsilon (float): Amplitude of the compressible defect.\n        m (float): Constant offset for the source term.\n        constraint_type (str): Type of constraint ('floating', 'mean_zero', 'anchor').\n        tol (float): Convergence tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n        kappa (float): Proportionality constant for pressure correction.\n\n    Returns:\n        list: A list containing [final_p_mean, residual_norm, div_u_new_norm, iterations].\n    \"\"\"\n    # 1. Grid and Coordinates\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # 'ij' indexing ensures xx[i, j] = x[i] and yy[i, j] = y[j]\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Velocity Field Construction\n    # Divergence-free component from streamfunction\n    ux_df = 2 * np.pi * np.sin(2 * np.pi * xx) * np.cos(2 * np.pi * yy)\n    uy_df = -2 * np.pi * np.cos(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n\n    # Compressible defect\n    ux_c = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    uy_c = np.zeros_like(yy)\n\n    # Tentative velocity u*\n    ux_star = ux_df + ux_c\n    uy_star = uy_df + uy_c\n\n    # Helper functions for discrete operators with mirrored Neumann boundaries\n    def discr_divergence(u, v, h_val):\n        u_padded = np.pad(u, 1, mode='symmetric')\n        v_padded = np.pad(v, 1, mode='symmetric')\n        du_dx = (u_padded[2:, 1:-1] - u_padded[:-2, 1:-1]) / (2 * h_val)\n        dv_dy = (v_padded[1:-1, 2:] - v_padded[1:-1, :-2]) / (2 * h_val)\n        return du_dx + dv_dy\n\n    def discr_gradient(p, h_val):\n        p_padded = np.pad(p, 1, mode='symmetric')\n        dp_dx = (p_padded[2:, 1:-1] - p_padded[:-2, 1:-1]) / (2 * h_val)\n        dp_dy = (p_padded[1:-1, 2:] - p_padded[1:-1, :-2]) / (2 * h_val)\n        return dp_dx, dp_dy\n\n    def discr_laplacian(p, h_val):\n        p_padded = np.pad(p, 1, mode='symmetric')\n        lap_p = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                 p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - 4 * p) / h_val**2\n        return lap_p\n\n    # 3. Source Term Calculation\n    f = discr_divergence(ux_star, uy_star, h)\n    f += m  # Add perturbation\n\n    # 4. Jacobi Iteration for the Poisson equation\n    p_prime = np.zeros((N, N))\n    iterations = 0\n    residual_norm = np.inf\n\n    for k in range(max_iter):\n        iterations = k + 1\n        \n        # Jacobi update step\n        p_padded = np.pad(p_prime, 1, mode='symmetric')\n        p_new = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                 p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - h**2 * f) / 4.0\n        \n        # 5. Apply constraints based on the variant\n        if constraint_type == 'mean_zero':\n            p_new -= np.mean(p_new)\n        elif constraint_type == 'anchor':\n            p_new[0, 0] = 0.0\n        # For 'floating', no action is taken.\n        \n        p_prime = p_new\n\n        # Check for convergence based on the L2 norm of the residual\n        residual = discr_laplacian(p_prime, h) - f\n        residual_norm = np.linalg.norm(residual)\n        if residual_norm  tol:\n            break\n            \n    # 6. Post-Processing and Metrics Calculation\n    final_p_mean = np.mean(p_prime)\n    \n    # Corrected velocity divergence calculation\n    dp_dx, dp_dy = discr_gradient(p_prime, h)\n    ux_new = ux_star - kappa * dp_dx\n    uy_new = uy_star - kappa * dp_dy\n    \n    div_u_new = discr_divergence(ux_new, uy_new, h)\n    div_u_new_norm = np.linalg.norm(div_u_new)\n\n    return [final_p_mean, residual_norm, div_u_new_norm, int(iterations)]\n\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, m, constraint_type)\n        (32, 0.2, 1e-3, 'floating'),     # Case A\n        (32, 0.2, 1e-3, 'mean_zero'),   # Case B\n        (32, 0.2, 1e-3, 'anchor'),       # Case C\n        (32, 0.2, 0.0, 'floating'),      # Case D\n    ]\n\n    # Global constants for the simulation\n    tol = 1e-8\n    max_iter = 2000\n    kappa = 1.0\n    \n    results = []\n    for N, epsilon, m, constraint_type in test_cases:\n        result = run_simulation(N, epsilon, m, constraint_type, tol, max_iter, kappa)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362264"}]}