{"hands_on_practices": [{"introduction": "本练习旨在揭开投影法的神秘面纱，为您提供一个坚实的实践基础。通过在一个简单的一维交错网格上手动构建离散算子（散度、梯度和拉普拉斯算子），您将具体地理解连续的控制方程是如何转化为可解的代数系统的。这个“纸笔”练习是连接理论与计算实现的第一步，它将帮助您掌握Chorin投影法的核心机制。[@problem_id:3301246]", "problem": "考虑在一个长度为 $L$ 的通道中的一维空间上的不可压缩纳维-斯托克斯方程，该通道在 $x=0$ 和 $x=L$ 处具有无滑移壁面，并使用标记网格法（MAC）网格。速度存储在面上，压力存储在单元中心。共有 $N$ 个大小均匀的控制体积（单元），单元中心索引为 $i=1,\\dots,N$，面索引为 $j=0,\\dots,N$。网格间距为 $h=L/N$。与通道对齐的速度分量用 $u$ 表示，不可压缩性要求投影后每个单元中的离散散度等于零。Chorin 方法的投影步通过求解压力的离散泊松方程然后校正中间速度来强制实现不可压缩性。\n\n从质量守恒的有限体积陈述（每个单元的面法向通量的离散散度）和内部面上压力梯度的中心差分近似（在壁面处采用与无滑移和零法向压力梯度一致的齐次诺伊曼边界条件）出发，针对 $N=4$，$L=1$ m，$h=L/N$，密度 $\\rho=1$ kg/m$^{3}$，时间步长 $\\Delta t=0.2$ s 的具体情况，执行以下操作：\n\n1. 定义离散散度算子 $D \\in \\mathbb{R}^{N \\times (N+1)}$，该算子将面速度 $\\boldsymbol{u} \\in \\mathbb{R}^{N+1}$ 映射到单元中心的散度，使用二阶有限体积通量差分。对于排序 $\\boldsymbol{u} = \\big(u_0,u_1,\\dots,u_N\\big)^{\\mathsf{T}}$ 和 $\\boldsymbol{d} = D \\boldsymbol{u}$（其中 $\\boldsymbol{d} \\in \\mathbb{R}^{N}$ 按单元 $i=1,\\dots,N$ 排序），写出其显式矩阵项。\n\n2. 定义离散梯度算子 $G \\in \\mathbb{R}^{(N+1) \\times N}$，该算子将单元中心的压力 $\\boldsymbol{p} \\in \\mathbb{R}^{N}$ 映射到面中心的压力梯度，在内面 $j=1,\\dots,N-1$ 上使用中心差分，在边界面 $j=0$ 和 $j=N$ 上使用齐次诺伊曼条件。写出其显式矩阵项。\n\n3. 构成离散压力拉普拉斯算子 $L = D G \\in \\mathbb{R}^{N \\times N}$ 并写出其显式矩阵形式。陈述诺伊曼问题的可解性条件以及您将用来获得唯一压力的规范约束。\n\n4. 给定中间面速度矢量（单位：m/s）\n$$\n\\boldsymbol{u}^{\\ast} \\;=\\; \\big(0,\\;0.8,\\;-0.4,\\;0.6,\\;0\\big)^{\\mathsf{T}},\n$$\n从第一性原理推导投影步中压力的离散泊松方程，并求解唯一的均值为零的离散压力 $\\boldsymbol{p} \\in \\mathbb{R}^{N}$（单位：Pa）。然后通过强制壁面无滑移的投影更新计算校正后的面速度。\n\n第二个单元中心的压力值 $p_2$（单位：Pa）是多少？将您的答案四舍五入到四位有效数字，并以帕斯卡（Pa）为单位表示。", "solution": "问题要求解作为 Chorin 方法中用于不可压缩纳维-斯托克斯方程的投影步的一部分，第二个单元中心的压力值 $p_2$。问题定义清晰，并提供了所有必要的数据和边界条件。我们将通过系统地构建离散算子并求解得到的压力泊松方程来继续。\n\n给定具体情况的参数如下：\n- 单元数：$N=4$\n- 通道长度：$L=1$ m\n- 单元宽度：$h = \\frac{L}{N} = \\frac{1}{4} = 0.25$ m\n- 流体密度：$\\rho=1$ kg/m$^3$\n- 时间步长：$\\Delta t = 0.2$ s\n- 中间速度矢量：$\\boldsymbol{u}^{\\ast} = \\big(0, 0.8, -0.4, 0.6, 0\\big)^{\\mathsf{T}}$ m/s\n\n**1. 离散散度算子 $D$**\n\n离散散度算子 $D$ 将面中心的速度 $\\boldsymbol{u} = \\big(u_0, u_1, u_2, u_3, u_4\\big)^{\\mathsf{T}}$ 映射到单元中心的散度 $\\boldsymbol{d} = \\big(d_1, d_2, d_3, d_4\\big)^{\\mathsf{T}}$。对于均匀网格，单元 $i$（其面为 $i-1$ 和 $i$）中的散度是每单位体积（或二维中的面积，一维中的长度）的净通量，由下式给出：\n$$\nd_i = (\\nabla \\cdot \\boldsymbol{u})_i = \\frac{u_i - u_{i-1}}{h}\n$$\n对于 $i=1, \\dots, N$。这定义了 $N \\times (N+1)$ 矩阵 $D$ 的行。当 $N=4$ 且 $h=0.25$ 时，$1/h=4$，算子为：\n$$\n\\boldsymbol{d} = D\\boldsymbol{u} = \\frac{1}{h}\n\\begin{pmatrix}\n-1  & 1  & 0  & 0  & 0 \\\\\n0  & -1 & 1  & 0  & 0 \\\\\n0  & 0  & -1 & 1  & 0 \\\\\n0  & 0  & 0  & -1 & 1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix}\n=\n4\n\\begin{pmatrix}\n-1  & 1  & 0  & 0  & 0 \\\\\n0  & -1 & 1  & 0  & 0 \\\\\n0  & 0  & -1 & 1  & 0 \\\\\n0  & 0  & 0  & -1 & 1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix}\n$$\n\n**2. 离散梯度算子 $G$**\n\n离散梯度算子 $G$ 将单元中心的压力 $\\boldsymbol{p} = \\big(p_1, p_2, p_3, p_4\\big)^{\\mathsf{T}}$ 映射到面中心的梯度 $(\\nabla p)_j$。\n- 对于内面 $j=1, \\dots, N-1$，使用中心差分。面 $j$（位于单元 $j$ 和 $j+1$ 之间）处的梯度为：\n  $$ (\\nabla p)_j = \\frac{p_{j+1} - p_j}{h} $$\n- 对于边界面 $j=0$ 和 $j=N=4$，应用齐次诺伊曼条件 $(\\nabla p)_0 = 0$ 和 $(\\nabla p)_N = 0$。\n\n这定义了 $(N+1) \\times N$ 矩阵 $G$：\n$$\nG \\boldsymbol{p} = \\frac{1}{h}\n\\begin{pmatrix}\n0  & 0  & 0  & 0 \\\\\n-1 & 1  & 0  & 0 \\\\\n0  & -1 & 1  & 0 \\\\\n0  & 0  & -1 & 1 \\\\\n0  & 0  & 0  & 0\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n=\n4\n\\begin{pmatrix}\n0  & 0  & 0  & 0 \\\\\n-1 & 1  & 0  & 0 \\\\\n0  & -1 & 1  & 0 \\\\\n0  & 0  & -1 & 1 \\\\\n0  & 0  & 0  & 0\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n$$\n对于此类离散化，一个常见的性质是，如果我们忽略边界条件，$G$ 是 $D$ 的负转置，即 $D = -G^{\\mathsf{T}}$。$G$ 中的零行代表诺伊曼边界条件。\n\n**3. 离散压力拉普拉斯算子 $L = DG$**\n\n离散拉普拉斯算子是一个通过乘积 $L=DG$ 形成的 $N \\times N$ 矩阵。\n$$\nL = DG = \\frac{1}{h^2}\n\\begin{pmatrix}\n-1  & 1  & 0  & 0  & 0 \\\\\n0  & -1 & 1  & 0  & 0 \\\\\n0  & 0  & -1 & 1  & 0 \\\\\n0  & 0  & 0  & -1 & 1\n\\end{pmatrix}\n\\begin{pmatrix}\n0  & 0  & 0  & 0 \\\\\n-1 & 1  & 0  & 0 \\\\\n0  & -1 & 1  & 0 \\\\\n0  & 0  & -1 & 1 \\\\\n0  & 0  & 0  & 0\n\\end{pmatrix}\n$$\n进行矩阵乘法得到：\n$$\nL = \\frac{1}{h^2}\n\\begin{pmatrix}\n-1 & 1  & 0  & 0 \\\\\n1  & -2 & 1  & 0 \\\\\n0  & 1  & -2 & 1 \\\\\n0  & 0  & 1  & -1\n\\end{pmatrix}\n$$\n代入 $h=0.25$，我们有 $1/h^2 = 1/(0.0625) = 16$。\n$$\nL = 16\n\\begin{pmatrix}\n-1 & 1  & 0  & 0 \\\\\n1  & -2 & 1  & 0 \\\\\n0  & 1  & -2 & 1 \\\\\n0  & 0  & 1  & -1\n\\end{pmatrix}\n$$\n这是具有诺伊曼边界条件的二阶导数的一维标准有限差分表示。每行元素之和为零，这意味着矩阵 $L$ 是奇异的。其零空间由常数向量 $\\boldsymbol{c} = (c, c, \\dots, c)^{\\mathsf{T}}$ 组成。诺伊曼问题 $L\\boldsymbol{p} = \\boldsymbol{f}$ 的可解性条件是右端向量 $\\boldsymbol{f}$ 必须与 $L^{\\mathsf{T}}$ 的零空间正交。由于 $L$ 是对称的（$L=L^{\\mathsf{T}}$），这意味着 $\\boldsymbol{f}$ 必须与常数向量正交，这要求其分量之和为零：$\\sum_{i=1}^N f_i = 0$。为了得到 $\\boldsymbol{p}$ 的唯一解，需要施加一个规范约束，例如固定一个压力值或要求平均压力为零，如题目所要求的：$\\sum_{i=1}^N p_i = 0$。\n\n**4. 求解压力**\n\n投影步涉及求解压力的泊松方程，该方程校正中间速度场 $\\boldsymbol{u}^*$ 使其无散度。更新步骤是 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p$。要求 $\\nabla \\cdot \\boldsymbol{u}^{n+1}=0$ 导致压力泊松方程：\n$$\n\\nabla^2 p = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^*\n$$\n离散形式为 $L\\boldsymbol{p} = \\frac{\\rho}{\\Delta t} D\\boldsymbol{u}^*$。\n\n首先，我们计算右侧项 $\\boldsymbol{f} = \\frac{\\rho}{\\Delta t} D\\boldsymbol{u}^*$。\n$$\n\\frac{\\rho}{\\Delta t} = \\frac{1 \\text{ kg/m}^3}{0.2 \\text{ s}} = 5 \\text{ kg/(m}^3 \\cdot \\text{s)}\n$$\n$$\nD\\boldsymbol{u}^* = \\frac{1}{h}\n\\begin{pmatrix} u_1^* - u_0^* \\\\ u_2^* - u_1^* \\\\ u_3^* - u_2^* \\\\ u_4^* - u_3^* \\end{pmatrix}\n= 4\n\\begin{pmatrix} 0.8 - 0 \\\\ -0.4 - 0.8 \\\\ 0.6 - (-0.4) \\\\ 0 - 0.6 \\end{pmatrix}\n= 4\n\\begin{pmatrix} 0.8 \\\\ -1.2 \\\\ 1.0 \\\\ -0.6 \\end{pmatrix}\n=\n\\begin{pmatrix} 3.2 \\\\ -4.8 \\\\ 4.0 \\\\ -2.4 \\end{pmatrix} \\text{ s}^{-1}\n$$\n分量之和为 $3.2 - 4.8 + 4.0 - 2.4 = 0$，满足可解性条件。现在，我们计算 $\\boldsymbol{f}$：\n$$\n\\boldsymbol{f} = 5 \\times D\\boldsymbol{u}^* =\n5 \\begin{pmatrix} 3.2 \\\\ -4.8 \\\\ 4.0 \\\\ -2.4 \\end{pmatrix}\n=\n\\begin{pmatrix} 16 \\\\ -24 \\\\ 20 \\\\ -12 \\end{pmatrix} \\text{ Pa/m}^2\n$$\n需要求解的线性系统是 $L\\boldsymbol{p} = \\boldsymbol{f}$：\n$$\n16\n\\begin{pmatrix}\n-1 & 1  & 0  & 0 \\\\\n1  & -2 & 1  & 0 \\\\\n0  & 1  & -2 & 1 \\\\\n0  & 0  & 1  & -1\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 16 \\\\ -24 \\\\ 20 \\\\ -12 \\end{pmatrix}\n$$\n两边同除以 $16$ 得到方程组：\n1.  $-p_1 + p_2 = 1$\n2.  $p_1 - 2p_2 + p_3 = -1.5$\n3.  $p_2 - 2p_3 + p_4 = 1.25$\n4.  $p_3 - p_4 = -0.75$\n\n我们用均值为零的规范约束来补充这些方程：\n5.  $p_1 + p_2 + p_3 + p_4 = 0$\n\n从方程（1）得，$p_1 = p_2 - 1$。\n从方程（4）得，$p_4 = p_3 + 0.75$。\n将 $p_1$ 代入方程（2）：\n$(p_2 - 1) - 2p_2 + p_3 = -1.5 \\implies -p_2 + p_3 = -0.5 \\implies p_3 = p_2 - 0.5$。\n现在用 $p_2$ 表示 $p_4$：\n$p_4 = p_3 + 0.75 = (p_2 - 0.5) + 0.75 = p_2 + 0.25$。\n\n我们已经将所有压力用 $p_2$ 表示：\n- $p_1 = p_2 - 1$\n- $p_2 = p_2$\n- $p_3 = p_2 - 0.5$\n- $p_4 = p_2 + 0.25$\n\n现在，将这些代入规范约束（5）：\n$$ (p_2 - 1) + p_2 + (p_2 - 0.5) + (p_2 + 0.25) = 0 $$\n$$ 4p_2 - 1.25 = 0 $$\n$$ 4p_2 = 1.25 $$\n$$ p_2 = \\frac{1.25}{4} = \\frac{5/4}{4} = \\frac{5}{16} = 0.3125 $$\n第二个单元中心的压力值 $p_2$ 是 $0.3125$ Pa。问题要求答案四舍五入到四位有效数字，这恰好是 $0.3125$。\n\n作为最后的验证，我们可以计算校正后的速度场 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} G \\boldsymbol{p}$。\n压力向量为 $\\boldsymbol{p} = (-0.6875, 0.3125, -0.1875, 0.5625)^{\\mathsf{T}}$。\n压力梯度项为：\n$$\n\\frac{\\Delta t}{\\rho} G \\boldsymbol{p} = 0.2 \\times 4 \\times\n\\begin{pmatrix}\n0 \\\\\np_2 - p_1 \\\\\np_3 - p_2 \\\\\np_4 - p_3 \\\\\n0\n\\end{pmatrix}\n= 0.8\n\\begin{pmatrix}\n0 \\\\\n0.3125 - (-0.6875) \\\\\n-0.1875 - 0.3125 \\\\\n0.5625 - (-0.1875) \\\\\n0\n\\end{pmatrix}\n= 0.8\n\\begin{pmatrix}\n0 \\\\\n1 \\\\\n-0.5 \\\\\n0.75 \\\\\n0\n\\endpmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0.8 \\\\\n-0.4 \\\\\n0.6 \\\\\n0\n\\endpmatrix}\n$$\n校正后的速度为：\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} G \\boldsymbol{p} = \\begin{pmatrix} 0 \\\\ 0.8 \\\\ -0.4 \\\\ 0.6 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0.8 \\\\ -0.4 \\\\ 0.6 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n最终速度处处为零。它显然是无散的（$D\\boldsymbol{u}^{n+1} = \\boldsymbol{0}$）并且满足无滑移边界条件（$u_0^{n+1}=0, u_4^{n+1}=0$）。这证实了计算的正确性。\n\n第二个单元中心的压力值 $p_2$ 是 $0.3125$ Pa。", "answer": "$$\\boxed{0.3125}$$", "id": "3301246"}, {"introduction": "理解任何数值方法的局限性与了解其能力同样重要。本练习将引导您探究Chorin方法的一个关键理论问题：分裂误差。通过强大的“人造解方法”(Method of Manufactured Solutions)，您将能分离并量化因压力和速度更新步骤分离而引入的误差，并揭示压力梯度项如何从根本上影响方法的时间精度。这项实践对于理解算子分裂格式中精度与效率之间的权衡至关重要。[@problem_id:3301208]", "problem": "考虑二维不可压缩纳维-斯托克斯方程作为计算流体动力学 (CFD) 的基本方程：$$\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f},\\quad \\nabla\\cdot \\mathbf{u} = 0,$$ 其中 $\\mathbf{u}(x,y,t)$ 是速度，$p(x,y,t)$ 是运动压力，$\\nu$ 是運動黏度，$\\mathbf{f}(x,y,t)$ 是彻体力。Chorin 投影法通过首先计算一个忽略了压力梯度贡献的暂定（预投影）速度 $\\mathbf{u}^\\star$，然后通过压力泊松方程 (Pressure Poisson Equation, PPE) 将 $\\mathbf{u}^\\star$ 投影到一个无散场上，从而分裂时间推进过程。分裂误差源于在暂定更新步骤中省略了 $-\\nabla p$。\n\n使用精确解方法 (Method of Manufactured Solutions)，在周期性域 $[0,2\\pi]\\times[0,2\\pi]$上定义两个光滑的无散精确解：\n\n- 情况 A (Taylor–Green 涡)：$$\\mathbf{u}(x,y,t) = \\begin{bmatrix} -U_0 \\cos(x)\\sin(y)\\, e^{-2\\nu t} \\\\ U_0 \\sin(x)\\cos(y)\\, e^{-2\\nu t} \\end{bmatrix},\\quad p(x,y,t) = \\frac{U_0^2}{4}\\big(\\cos(2x) + \\cos(2y)\\big) e^{-4\\nu t},\\quad \\mathbf{f}=\\mathbf{0}.$$\n\n- 情况 B (扩散剪切流，零压力梯度)：$$\\mathbf{u}(x,y,t) = \\begin{bmatrix} \\sin(y)\\, e^{-\\nu t} \\\\ 0 \\end{bmatrix},\\quad p(x,y,t) = \\text{constant},\\quad \\mathbf{f}=\\mathbf{0}.$$\n\n在周期性边界条件下，两种情况都满足给定 $p$ 和 $\\mathbf{f}$ 的不可压缩方程。设粘度为 $\\nu = 0.1$，$U_0=1$。\n\n通过仅显式推进非压力项，定义在时间 $t^n$ 处、时间步长为 $\\Delta t$ 的 Chorin 暂定更新：$$\\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t\\left(-(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f}\\right)\\Big|_{t=t^n}.$$ 使用精确的制造解 $\\mathbf{u}(t^n)$ 来精确（解析地）评估所有空间导数，并且不执行投影步骤。对于每种情况，计算误差 $$E(\\Delta t) = \\left\\|\\mathbf{u}^\\star - \\mathbf{u}(t^n+\\Delta t)\\right\\|_{L^2(\\Omega)},$$ 其中 $\\Omega=[0,2\\pi]\\times[0,2\\pi]$ 并且 $L^2$ 范数是相对于面积测度在整个域上计算的。该误差分离出了在暂定步骤中省略 $-\\nabla p$ 的分裂效应（由于非零的 $\\nabla p$，情况 A 预计将由一阶 $\\Delta t$ 项主导，而情况 B 应表现出更高阶的衰减，因为 $\\nabla p=\\mathbf{0}$）。\n\n您的程序必须：\n- 通过在 $[0,2\\pi]\\times[0,2\\pi]$ 上的均匀网格上使用周期性采样进行数值积分，并使用由制造场所暗示的 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$、$\\Delta \\mathbf{u}$ 和 $\\nabla p$ 的精确解析表达式来评估 $L^2$ 误差。\n- 使用时间设置 $t^n = 0$。\n- 使用以下时间步长测试套件：$\\Delta t \\in \\{0.2, 0.1, 0.05, 0.025, 0.0125\\}$。\n- 对于每种情况，报告五个 $\\Delta t$ 值对应的 $L^2$ 误差列表 $E(\\Delta t)$，然后报告通过对 $\\log E$ 与 $\\log \\Delta t$ 进行最小二乘拟合得到的斜率（即，在 $E \\approx C\\,\\Delta t^{\\,q}$ 中估计 $q$）所计算的观测衰减阶。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，条目按以下顺序排列：首先是情况 A (Taylor–Green 涡) 从最大到最小 $\\Delta t$ 的五个误差，然后是给出情况 A 估计阶数的单个浮点数，接着是情况 B (扩散剪切流) 从最大到最小 $\\Delta t$ 的五个误差，最后是给出情况 B 估计阶数的单个浮点数。例如，格式为“[E_A(0.2),E_A(0.1),E_A(0.05),E_A(0.025),E_A(0.0125),q_A,E_B(0.2),E_B(0.1),E_B(0.05),E_B(0.025),E_B(0.0125),q_B]”的行。", "solution": "本练习的核心是分析Chorin投影法第一步（预测步）所产生的算子分裂误差。此误差主要源于在计算中间速度 $\\mathbf{u}^\\star$ 时暂时忽略了压力梯度项 $-\\nabla p$。\n\n我们首先分析误差项 $\\mathbf{e}(\\Delta t) = \\mathbf{u}^\\star - \\mathbf{u}(t^n + \\Delta t)$ 的来源。\n根据定义，中间速度为：\n$$ \\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t \\left( -(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f} \\right)\\Big|_{t=t^n} $$\n由于给定的精确解满足完整的纳维-斯托克斯方程，即 $\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f}$，我们可以将非压力项替换掉：\n$$ -(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} + \\nu \\Delta \\mathbf{u} + \\mathbf{f} = \\partial_t \\mathbf{u} + \\nabla p $$\n代入 $\\mathbf{u}^\\star$ 的表达式，得到：\n$$ \\mathbf{u}^\\star = \\mathbf{u}(t^n) + \\Delta t \\left( \\partial_t \\mathbf{u} + \\nabla p \\right) \\Big|_{t=t^n} $$\n与此同时，精确解在 $t^n+\\Delta t$ 的值可以通过在 $t^n$ 处的泰勒展开来表示：\n$$ \\mathbf{u}(t^n + \\Delta t) = \\mathbf{u}(t^n) + \\Delta t \\, \\partial_t\\mathbf{u}|_{t^n} + \\frac{(\\Delta t)^2}{2} \\partial_{tt}\\mathbf{u}|_{t^n} + \\mathcal{O}((\\Delta t)^3) $$\n因此，误差向量 $\\mathbf{e}(\\Delta t) = \\mathbf{u}^\\star - \\mathbf{u}(t^n + \\Delta t)$ 的主导项为：\n$$ \\mathbf{e}(\\Delta t) \\approx \\Delta t \\, \\nabla p|_{t^n} - \\frac{(\\Delta t)^2}{2} \\partial_{tt}\\mathbf{u}|_{t^n} + \\mathcal{O}((\\Delta t)^3) $$\n这个展开清晰地表明，如果压力梯度 $\\nabla p$不为零，则分裂误差是时间步长 $\\Delta t$ 的一阶。如果压力梯度为零，则误差是二阶的。\n\n现在，我们针对两种情况在 $t^n = 0$ 时具体分析：\n\n**情况 A：Taylor-Green 涡**\n在此情况下，压力梯度 $\\nabla p|_{t=0} = \\begin{bmatrix} -\\frac{1}{2}\\sin(2x) \\\\ -\\frac{1}{2}\\sin(2y) \\end{bmatrix}$ 不为零。因此，我们预期误差由 $\\Delta t \\nabla p|_{t=0}$ 项主导，其 $L^2$ 范数将表现为 $\\mathcal{O}(\\Delta t)$，即收敛阶为 1。\n\n**情况 B：扩散剪切流**\n在此情况下，压力 $p$ 为常数，因此压力梯度 $\\nabla p = \\mathbf{0}$。误差表达式简化为：\n$$ \\mathbf{e}_B(\\Delta t) = \\left( (1-\\nu\\Delta t)\\mathbf{u}(0) \\right) - \\left( \\mathbf{u}(0) e^{-\\nu\\Delta t} \\right) = (1-\\nu\\Delta t - e^{-\\nu\\Delta t})\\mathbf{u}(0) $$\n由于 $e^{-x} = 1-x+x^2/2! - \\dots$，括号内的项 $(1-\\nu\\Delta t - (1-\\nu\\Delta t + \\frac{(\\nu\\Delta t)^2}{2} - \\dots)) = -\\frac{(\\nu\\Delta t)^2}{2} + \\dots$ 是 $\\mathcal{O}((\\Delta t)^2)$。因此，我们预期误差的 $L^2$ 范数将表现为 $\\mathcal{O}((\\Delta t)^2)$，收敛阶为 2。\n\n数值积分将通过在 $N \\times N$ 网格上对误差向量的平方求和来近似 $L^2$ 范数，收敛阶 $q$ 通过对数-对数坐标下的线性回归 $\\log(E)$ vs $\\log(\\Delta t)$ 得到。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes the splitting error for Chorin's projection method for two\n    manufactured solutions and estimates the order of convergence.\n    \"\"\"\n    # Define problem parameters\n    nu = 0.1\n    U0 = 1.0\n    dts = np.array([0.2, 0.1, 0.05, 0.025, 0.0125])\n    \n    # Numerical quadrature parameters\n    N = 256\n    h = 2 * np.pi / N\n    x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    y = np.linspace(0, 2 * np.pi, N, endpoint=False)\n    X, Y = np.meshgrid(x, y)\n\n    # --- Case A: Taylor-Green Vortex ---\n    errors_A = []\n    \n    # Pre-compute spatial fields at t=0\n    u0_x_A = -U0 * np.cos(X) * np.sin(Y)\n    u0_y_A =  U0 * np.sin(X) * np.cos(Y)\n    grad_p_x_A = - (U0**2 / 2.0) * np.sin(2 * X)\n    grad_p_y_A = - (U0**2 / 2.0) * np.sin(2 * Y)\n\n    for dt in dts:\n        # Calculate terms for the error vector e = u* - u(dt)\n        # The equation for the error vector is:\n        # e = (1 - 2*nu*dt - exp(-2*nu*dt)) * u(0) + dt * grad_p(0)\n        \n        # Coefficient for the u(0) term\n        C1 = 1.0 - 2.0 * nu * dt - np.exp(-2.0 * nu * dt)\n        \n        # Components of the error vector field\n        e_x = C1 * u0_x_A + dt * grad_p_x_A\n        e_y = C1 * u0_y_A + dt * grad_p_y_A\n\n        # Compute L2 norm via numerical quadrature\n        sum_sq_error = np.sum(e_x**2 + e_y**2)\n        l2_error = h * np.sqrt(sum_sq_error)\n        errors_A.append(l2_error)\n        \n    # Estimate order of convergence q_A\n    log_dts = np.log(dts)\n    log_errors_A = np.log(np.array(errors_A))\n    # linregress returns a tuple, the slope is the first element\n    q_A = linregress(log_dts, log_errors_A).slope\n\n    # --- Case B: Diffusing Shear ---\n    errors_B = []\n\n    # Pre-compute spatial fields at t=0\n    u0_x_B = np.sin(Y)\n    # u0_y_B is zero everywhere\n\n    for dt in dts:\n        # Calculate terms for the error vector e = u* - u(dt)\n        # The equation for the error vector is:\n        # e = (1 - nu*dt - exp(-nu*dt)) * u(0)\n        # Note: grad_p(0) is zero for this case.\n\n        # Coefficient for the u(0) term\n        C2 = 1.0 - nu * dt - np.exp(-nu * dt)\n        \n        # Components of the error vector field\n        e_x = C2 * u0_x_B\n        # e_y is zero\n\n        # Compute L2 norm via numerical quadrature\n        sum_sq_error = np.sum(e_x**2) # e_y is zero\n        l2_error = h * np.sqrt(sum_sq_error)\n        errors_B.append(l2_error)\n\n    # Estimate order of convergence q_B\n    log_errors_B = np.log(np.array(errors_B))\n    q_B = linregress(log_dts, log_errors_B).slope\n    \n    # Combine all results into a single list\n    final_results = errors_A + [q_A] + errors_B + [q_B]\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{val:.8f}' for val in final_results)}]\")\n\nsolve()\n\n```", "id": "3301208"}, {"introduction": "在实际的计算流体力学应用中，压力泊松方程几乎总是通过迭代法来近似求解，而非精确求解。本练习将带您深入探讨这种近似求解带来的实际影响。您需要首先推导出线性求解器的残差（即求解精度）与最终流场质量守恒误差之间的直接关系，然后通过编程来验证这一关系。这是一项关于数值误差如何传播及如何控制的关键实践，它连接了数值线性代数的理论与流体模拟的物理现实。[@problem_id:3301215]", "problem": "考虑不可压缩的Navier–Stokes方程以及一种算子分裂格式，其中通过一个投影步来更新速度以施加不可压缩性约束。在Chorin投影法中，首先使用不含压力的动量方程推进到一个中间速度场$u^\\ast$，然后通过求解一个关于类压力变量$p$的泊松方程并进行投影来施加不可压缩性约束：\n$$\nu^{n+1} \\leftarrow u^\\ast - \\frac{\\Delta t}{\\rho}\\,\\nabla p,\n$$\n其意图是使修正后的速度满足离散无散约束。假设在周期性方形域$[0,1]^2$上有一个均匀笛卡爾网格，每个方向的网格间距为$h = 1/N$，使用交錯的Marker-And-Cell (MAC) 离散化：水平速度分量位于水平面心，垂直速度分量位于垂直面心，而压力和散度位于单元中心。将面心速度映射到单元中心的MAC离散散度记为$\\nabla_h \\cdot$，将单元中心压力映射到面心的MAC离散梯度记为$\\nabla_h$，将单元中心的标准五点离散拉普拉斯算子记为$L_h$。在周期性边界条件下，MAC算子满足相容性恒等式$\\nabla_h \\cdot \\nabla_h p = L_h p$。设$\\|\\cdot\\|_{2}$表示所有网格值向量的未加权欧几里得范数，设$\\|\\cdot\\|_{L^2_h}$表示在域上定义的离散$L^2$范数\n$$\n\\|q\\|_{L^2_h} \\equiv \\left( \\sum_{i,j} |q_{i,j}|^2\\, h^2 \\right)^{1/2}.\n$$\n在压力投影中，类压力变量$p_h$是通过求解离散泊松方程\n$$\nL_h p_h = b_h, \\quad \\text{其中} \\quad b_h = \\frac{\\rho}{\\Delta t} \\, (\\nabla_h \\cdot u^\\ast),\n$$\n来计算的，但假设线性求解不精确，并在残差$r_h = L_h p_h - b_h$满足某个停止准则时终止。然后用这个不精确的$p_h$执行投影。两种常见的停止准则是：\n1. 绝对容差：$\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{abs}}$，对于给定的$\\varepsilon_{\\mathrm{abs}} > 0$。\n2. 相对容差：$\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{rel}} \\, \\|b_h\\|_{2}$，对于给定的$\\varepsilon_{\\mathrm{rel}} > 0$。\n\n仅从MAC离散化的基本性质、投影更新的定义以及上述范数出发，推导修正后速度中的离散质量守恒误差（由离散$L^2$范数$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$衡量）与求解器容差（$\\varepsilon_{\\mathrm{abs}}$或$\\varepsilon_{\\mathrm{rel}}$）以及网格间距$h$之间的定量关系。使用无量纲单位，其中$\\rho = 1$且$\\Delta t = 1$。\n\n然后，实现一个程序，通过在均匀周期网格上的适当面位置采样连续场\n$$\nu_x(x,y) = \\sin(2\\pi x)\\,\\sin(2\\pi y), \\qquad u_y(x,y) = \\cos(2\\pi x)\\,\\sin(2\\pi y),\n$$\n来构造MAC网格上的光滑面心中心中间速度场$u^\\ast_h$，计算单元中心对应的$b_h = \\nabla_h \\cdot u^\\ast_h$，并在两种停止准则下，根据推导出的关系评估预测的离散质量守恒误差$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$，而无需实际求解该线性系统。使用连接$\\nabla_h \\cdot u^{n+1}$与残差$r_h$的恒等式以及离散范数之间的关系，来评估给定容差下的误差大小。\n\n构建以下测试套件以探究不同的缩放关系：\n- 固定网格分辨率下绝对容差的缩放关系：固定$N = 64$，使用$\\varepsilon_{\\mathrm{abs}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$，计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log \\varepsilon_{\\mathrm{abs}}$的斜率（以$e$为底的对数回归）。\n- 固定容差下绝对容差随网格间距的缩放关系：固定$\\varepsilon_{\\mathrm{abs}} = 10^{-6}$，使用$N \\in \\{32, 64, 128\\}$（因此$h \\in \\{1/32,1/64,1/128\\}$），计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log h$的斜率。\n- 固定网格分辨率下相对容差的缩放关系：固定$N = 64$，使用$\\varepsilon_{\\mathrm{rel}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$，计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log \\varepsilon_{\\mathrm{rel}}$的斜率。\n- 固定容差下相对容差随网格间距的缩放关系：固定$\\varepsilon_{\\mathrm{rel}} = 10^{-6}$，使用$N \\in \\{32, 64, 128\\}$，计算$\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$对$\\log h$的斜率。\n\n对于上述四个要点中的每一个，通过对数据对$(\\log x,\\log y)$进行线性最小二乘法拟合来估计斜率，其中$x$分别是$\\varepsilon_{\\mathrm{abs}}$、$h$、$\\varepsilon_{\\mathrm{rel}}$或$h$，而$y$是对应的$\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$。您的程序应输出一行，其中包含按此顺序排列的四个斜率：\n- 首先，绝对容差相对于$\\varepsilon_{\\mathrm{abs}}$的斜率，\n- 其次，绝对容差相对于$h$的斜率，\n- 第三，相对容差相对于$\\varepsilon_{\\mathrm{rel}}$的斜率，\n- 第四，相对容差相对于$h$的斜率，\n并四舍五入到三位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个斜率，格式为方括号括起来的逗号分隔列表，例如，“[s1,s2,s3,s4]”。由于输出是无量纲斜率，因此不需要物理单位。", "solution": "本题的目标是推导投影后速度场的离散质量守恒误差 $\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 与压力泊松方程迭代求解器的残差参数（容差和网格间距）之间的定量关系。\n\n**1. 关联散度误差与泊松求解器残差**\n\n根据Chorin投影法的校正步骤，更新后的速度场 $u_h^{n+1}$ 由下式给出：\n$$ u_h^{n+1} = u_h^\\ast - \\frac{\\Delta t}{\\rho} \\nabla_h p_h $$\n题目设定无量纲单位 $\\rho = 1$ 和 $\\Delta t = 1$，方程简化为：\n$$ u_h^{n+1} = u_h^\\ast - \\nabla_h p_h $$\n我们对此方程应用离散散度算子 $\\nabla_h \\cdot$，得到新速度场的散度：\n$$ \\nabla_h \\cdot u_h^{n+1} = \\nabla_h \\cdot u_h^\\ast - \\nabla_h \\cdot (\\nabla_h p_h) $$\n利用周期性边界条件下MAC离散化的恒等式 $\\nabla_h \\cdot \\nabla_h p_h = L_h p_h$，我们得到：\n$$ \\nabla_h \\cdot u_h^{n+1} = \\nabla_h \\cdot u_h^\\ast - L_h p_h $$\n压力泊松方程 (PPE) 为 $L_h p_h = b_h$，其中源项 $b_h = \\frac{\\rho}{\\Delta t} \\nabla_h \\cdot u_h^\\ast = \\nabla_h \\cdot u_h^\\ast$。由于线性系统求解不精确，存在残差 $r_h = L_h p_h - b_h$。因此，$L_h p_h = b_h + r_h$。\n将此代入散度方程，我们发现一个关键关系：\n$$ \\nabla_h \\cdot u_h^{n+1} = b_h - (b_h + r_h) = -r_h $$\n此恒等式表明，**投影后速度场的离散散度，精确地等于压力泊松方程求解残差的负值**。\n\n**2. 关联范数**\n\n接下来，我们将此关系转化为范数之间的关系。我们关心的是离散$L^2_h$范数下的质量守恒误差：\n$$ \\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} = \\|-r_h\\|_{L^2_h} = \\|r_h\\|_{L^2_h} $$\n题目中线性求解器的停止准则基于未加权的欧几里得范数 $\\|\\cdot\\|_2$。对于定义在 $N \\times N$ 单元中心网格上的任意函数 $q_h$，两种范数的关系是：\n$$ \\|q_h\\|_{L^2_h} = h \\|q_h\\|_2 $$\n将此应用于残差 $r_h$，我们得到散度误差的核心表达式：\n$$ \\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} = h \\|r_h\\|_2 $$\n\n**3. 分析停止准则**\n\n最后，我们分析两种停止准则对最终误差的影响，假设求解器在达到容差边界时终止。\n\n*   **绝对容差**: 停止准则为 $\\|r_h\\|_2 \\approx \\varepsilon_{\\mathrm{abs}}$。代入误差表达式得：\n    $$ \\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{abs}} $$\n    这预测了对 $\\log(\\varepsilon_{\\mathrm{abs}})$ 的斜率为 1，对 $\\log(h)$ 的斜率也为 1。\n\n*   **相对容差**: 停止准则为 $\\|r_h\\|_2 \\approx \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2$。误差表达式为：\n    $$ \\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2 $$\n    为了分析其对 $h$ 的依赖性，我们需要知道 $\\|b_h\\|_2$ 如何随 $h$ 变化。由于 $b_h$ 是连续散度场 $\\nabla \\cdot u$ 的一个相容离散化，其离散$L^2_h$范数 $\\|b_h\\|_{L^2_h}$ 会收敛于一个常数（连续场的$L^2$范数）。因此，$\\|b_h\\|_2 = h^{-1}\\|b_h\\|_{L^2_h} \\propto h^{-1}$。将此缩放关系代入：\n    $$ \\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{rel}} (C h^{-1}) = C \\varepsilon_{\\mathrm{rel}} $$\n    其中 $C$ 是一个与 $u$ 相关的常数。这预测了误差与 $h$ 无关，因此对 $\\log(\\varepsilon_{\\mathrm{rel}})$ 的斜率为 1，而对 $\\log(h)$ 的斜率为 0。\n\n程序将通过数值实验来验证这四个预测的斜率（1, 1, 1, 0）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_bh_norm2(N):\n    \"\"\"\n    Computes the Euclidean norm of the discrete divergence of the\n    intermediate velocity field u* on a MAC grid.\n\n    Args:\n        N (int): The number of grid cells in each direction.\n\n    Returns:\n        float: The Euclidean L2 norm of the discrete divergence vector b_h.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Create grid indices for an N x N grid\n    j_idx, i_idx = np.indices((N, N))\n\n    # Define coordinates for the horizontal (u) velocity components\n    # ux is located at (i*h, (j+0.5)*h)\n    x_u = i_idx * h\n    y_u = (j_idx + 0.5) * h\n    \n    # Define coordinates for the vertical (v) velocity components\n    # uy is located at ((i+0.5)*h, j*h)\n    x_v = (i_idx + 0.5) * h\n    y_v = j_idx * h\n\n    # Sample the continuous velocity field to get the discrete intermediate velocity u*\n    # u_x(x,y) = sin(2*pi*x)*sin(2*pi*y)\n    # u_y(x,y) = cos(2*pi*x)*sin(2*pi*y)\n    ux_h = np.sin(2 * np.pi * x_u) * np.sin(2 * np.pi * y_u)\n    uy_h = np.cos(2 * np.pi * x_v) * np.sin(2 * np.pi * y_v)\n\n    # Compute the discrete divergence b_h = nabla_h . u* at cell centers.\n    # The divergence at cell (j,i) is (u_right - u_left)/h + (u_top - u_bottom)/h.\n    # On a periodic MAC grid, u_left of cell (j,i) is ux_h[j,i] and u_right is ux_h[j,(i+1)%N].\n    # Similarly, u_bottom is uy_h[j,i] and u_top is uy_h[(j+1)%N,i].\n    # We use np.roll for efficient periodic boundary handling.\n    # np.roll(ux_h, -1, axis=1) corresponds to ux_h[j, (i+1)%N]\n    # np.roll(uy_h, -1, axis=0) corresponds to uy_h[(j+1)%N, i]\n    b_h = ((np.roll(ux_h, -1, axis=1) - ux_h) + (np.roll(uy_h, -1, axis=0) - uy_h)) / h\n    \n    # The Euclidean norm ||b_h||_2 is equivalent to the Frobenius norm of the matrix\n    b_h_norm2 = np.linalg.norm(b_h)\n    \n    return b_h_norm2\n\ndef get_slope(x_values, y_values):\n    \"\"\"\n    Performs a linear regression on the base-e logarithm of the data.\n\n    Args:\n        x_values (np.ndarray): The independent variable values.\n        y_values (np.ndarray): The dependent variable values.\n\n    Returns:\n        float: The slope of the line fitted to (log(x), log(y)).\n    \"\"\"\n    log_x = np.log(x_values)\n    log_y = np.log(y_values)\n    # np.polyfit with degree 1 returns [slope, intercept]\n    slope, _ = np.polyfit(log_x, log_y, 1)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to perform the four scaling tests and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Absolute tolerance scaling with tol, fixed N\n        {'N_vals': np.array([64]), 'eps_vals': np.array([1e-6, 5e-7, 2.5e-7]), 'mode': 'abs_vs_eps'},\n        # 2. Absolute tolerance scaling with h, fixed tol\n        {'N_vals': np.array([32, 64, 128]), 'eps_vals': np.array([1e-6]), 'mode': 'abs_vs_h'},\n        # 3. Relative tolerance scaling with tol, fixed N\n        {'N_vals': np.array([64]), 'eps_vals': np.array([1e-6, 5e-7, 2.5e-7]), 'mode': 'rel_vs_eps'},\n        # 4. Relative tolerance scaling with h, fixed tol\n        {'N_vals': np.array([32, 64, 128]), 'eps_vals': np.array([1e-6]), 'mode': 'rel_vs_h'},\n    ]\n\n    results = []\n\n    # Case 1: Absolute tolerance vs. epsilon_abs\n    case1 = test_cases[0]\n    N1 = case1['N_vals'][0]\n    h1 = 1.0 / N1\n    eps_abs_vals = case1['eps_vals']\n    # Derived relationship: ||div u||_L2h = h * eps_abs\n    errors1 = h1 * eps_abs_vals\n    slope1 = get_slope(eps_abs_vals, errors1)\n    results.append(slope1)\n\n    # Case 2: Absolute tolerance vs. h\n    case2 = test_cases[1]\n    N_vals2 = case2['N_vals']\n    h_vals2 = 1.0 / N_vals2\n    eps_abs2 = case2['eps_vals'][0]\n    # Derived relationship: ||div u||_L2h = h * eps_abs\n    errors2 = h_vals2 * eps_abs2\n    slope2 = get_slope(h_vals2, errors2)\n    results.append(slope2)\n\n    # Case 3: Relative tolerance vs. epsilon_rel\n    case3 = test_cases[2]\n    N3 = case3['N_vals'][0]\n    h3 = 1.0 / N3\n    eps_rel_vals = case3['eps_vals']\n    b_h_norm2_N64 = compute_bh_norm2(N3)\n    # Derived relationship: ||div u||_L2h = h * eps_rel * ||b_h||_2\n    errors3 = h3 * eps_rel_vals * b_h_norm2_N64\n    slope3 = get_slope(eps_rel_vals, errors3)\n    results.append(slope3)\n\n    # Case 4: Relative tolerance vs. h\n    case4 = test_cases[3]\n    N_vals4 = case4['N_vals']\n    h_vals4 = 1.0 / N_vals4\n    eps_rel4 = case4['eps_vals'][0]\n    errors4 = []\n    for N_val in N_vals4:\n        h_val = 1.0 / N_val\n        b_h_norm2 = compute_bh_norm2(N_val)\n        # Derived relationship: ||div u||_L2h = h * eps_rel * ||b_h||_2\n        error = h_val * eps_rel4 * b_h_norm2\n        errors4.append(error)\n    errors4 = np.array(errors4)\n    slope4 = get_slope(h_vals4, errors4)\n    results.append(slope4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]:.3f},{results[1]:.3f},{results[2]:.3f},{results[3]:.3f}]\")\n\nsolve()\n\n```", "id": "3301215"}]}