{"hands_on_practices": [{"introduction": "要生成高质量的计算网格，我们必须能够量化其几何特性。本练习将引导您分析一个由参数 $\\alpha$ 控制的解析映射，并推导其关键质量度量：雅可比行列式（$J$）、正交性误差（$\\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta$）和局部单元纵横比（$A$）。通过这个过程，您将亲身体会到控制函数如何直接影响网格的拉伸和正交性，为理解更复杂的网格生成策略奠定基础。[@problem_id:3313603]", "problem": "在计算流体动力学 (CFD) 椭圆网格生成的背景下，考虑一个从计算空间到物理空间的光滑映射，该映射在计算坐标 $(\\xi,\\eta)$ 的单位正方形 $[0,1]\\times[0,1]$ 上定义为\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = \\eta + \\alpha \\sin(\\pi \\xi),\n$$\n其中 $\\alpha \\in \\mathbb{R}$ 是一个实值控制参数。在使用泊松方程进行椭圆网格生成时，坐标函数满足\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta),\\qquad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta),\n$$\n其中 $P$ 和 $Q$ 是给定的右端项，用于控制网格线的聚集和平滑度。\n\n从物理平面中协变基向量的基本定义出发，\n$$\n\\mathbf{g}_{\\xi} = \\begin{pmatrix} x_{\\xi} \\\\ y_{\\xi} \\end{pmatrix},\\qquad \\mathbf{g}_{\\eta} = \\begin{pmatrix} x_{\\eta} \\\\ y_{\\eta} \\end{pmatrix},\n$$\n雅可比行列式\n$$\nJ = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi},\n$$\n正交性误差\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta},\n$$\n以及局部单元纵横比（对应于 $\\xi$ 和 $\\eta$ 方向单位步长的边长之比）\n$$\nA = \\frac{\\|\\mathbf{g}_{\\xi}\\|}{\\|\\mathbf{g}_{\\eta}\\|},\n$$\n推导 $J(\\xi,\\eta;\\alpha)$、$\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta}(\\xi,\\eta;\\alpha)$ 和 $A(\\xi,\\eta;\\alpha)$ 的解析表达式。然后，基于这些表达式和泊松公式，简要讨论参数 $\\alpha$ 如何影响物理平面中的网格正交性和单元拉伸。\n\n将您的最终结果以闭合形式的有序三元组 $\\big(J,\\ \\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta},\\ A\\big)$ 给出。无需四舍五入，也无需单位。", "solution": "该问题是有效的，因为它在科学上基于应用于计算网格生成的微分几何原理，是适定的，具有足够的信息来获得唯一解，并以客观、正式的语言表述。我们开始进行推导。\n\n从计算坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的给定变换为：\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\alpha \\sin(\\pi \\xi)\n$$\n其中 $\\alpha$ 是一个实值参数。\n\n首先，我们计算 $x$ 和 $y$ 关于 $\\xi$ 和 $\\eta$ 的一阶偏导数。这些导数是协变基向量的分量。\n$$\nx_{\\xi} = \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi) = 1\n$$\n$$\nx_{\\eta} = \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi) = 0\n$$\n$$\ny_{\\xi} = \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\eta + \\alpha \\sin(\\pi \\xi)) = \\alpha \\pi \\cos(\\pi \\xi)\n$$\n$$\ny_{\\eta} = \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\eta + \\alpha \\sin(\\pi \\xi)) = 1\n$$\n\n使用这些导数，我们构建协变基向量 $\\mathbf{g}_{\\xi}$ 和 $\\mathbf{g}_{\\eta}$：\n$$\n\\mathbf{g}_{\\xi} = \\begin{pmatrix} x_{\\xi} \\\\ y_{\\xi} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\alpha \\pi \\cos(\\pi \\xi) \\end{pmatrix}\n$$\n$$\n\\mathbf{g}_{\\eta} = \\begin{pmatrix} x_{\\eta} \\\\ y_{\\eta} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n在物理 $(x,y)$ 平面中，这些向量分别与 $\\eta$ 为常数和 $\\xi$ 为常数的网格线相切。\n\n接下来，我们根据其定义推导所要求的量。\n\n**1. 雅可比行列式, $J(\\xi,\\eta;\\alpha)$**\n雅可比行列式定义为 $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$。代入计算出的偏导数：\n$$\nJ = (1)(1) - (0)(\\alpha \\pi \\cos(\\pi \\xi)) = 1 - 0 = 1\n$$\n雅可比行列式为常数1。这表明该变换是局部保面积的；计算空间中的一个微分面积元 $d\\xi d\\eta$ 映射到物理空间中大小相同的微分面积元 $dx dy$。\n\n**2. 正交性误差, $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta}(\\xi,\\eta;\\alpha)$**\n网格的正交性由协变基向量的点积来衡量。值为0表示局部正交。\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = x_{\\xi} x_{\\eta} + y_{\\xi} y_{\\eta}\n$$\n代入导数：\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = (1)(0) + (\\alpha \\pi \\cos(\\pi \\xi))(1) = \\alpha \\pi \\cos(\\pi \\xi)\n$$\n该表达式量化了在任意点 $(\\xi, \\eta)$ 处与正交性的偏离程度。\n\n**3. 局部单元纵横比, $A(\\xi,\\eta;\\alpha)$**\n纵横比 $A$ 是基向量模长之比, $A = \\frac{\\|\\mathbf{g}_{\\xi}\\|}{\\|\\mathbf{g}_{\\eta}\\|}$。我们首先计算模长：\n$$\n\\|\\mathbf{g}_{\\xi}\\| = \\sqrt{x_{\\xi}^{2} + y_{\\xi}^{2}} = \\sqrt{1^{2} + (\\alpha \\pi \\cos(\\pi \\xi))^{2}} = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}\n$$\n$$\n\\|\\mathbf{g}_{\\eta}\\| = \\sqrt{x_{\\eta}^{2} + y_{\\eta}^{2}} = \\sqrt{0^{2} + 1^{2}} = 1\n$$\n因此，纵横比为：\n$$\nA = \\frac{\\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}}{1} = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}\n$$\n\n**关于 $\\alpha$ 作用的讨论：**\n\n参数 $\\alpha$ 直接控制物理平面中网格的几何特性。\n- **网格正交性**：正交性误差为 $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = \\alpha \\pi \\cos(\\pi \\xi)$。如果 $\\alpha=0$，变换简化为恒等映射 $(x,y) = (\\xi,\\eta)$，正交性误差处处为0，网格是一个简单的正交笛卡尔网格。对于 $\\alpha \\neq 0$，网格通常是非正交的。与正交性的偏离程度与 $|\\alpha|$ 成正比，并随 $\\xi$ 变化。对于任何非零的 $\\alpha$，只有在 $\\cos(\\pi \\xi) = 0$ 的地方才能实现完全正交，这在定义域 $[0,1]$ 中发生在 $\\xi=1/2$ 处。最大的非正交性出现在边界 $\\xi=0$ 和 $\\xi=1$ 处，此时 $|\\cos(\\pi \\xi)|=1$。\n\n- **单元拉伸**：局部单元纵横比为 $A = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}$。如果 $\\alpha=0$，$A=1$ 处处成立，表明由 $\\xi$ 和 $\\eta$ 方向的单位步长形成的单元是局部正方形。对于 $\\alpha \\neq 0$，$A \\geq 1$，表明网格单元被拉伸。在 $\\xi$ 方向的单元边长 $\\|\\mathbf{g}_{\\xi}\\|$ 相对于 $\\eta$ 方向的边长 $\\|\\mathbf{g}_{\\eta}\\|$ 被拉伸。拉伸是 $\\alpha^2$ 的函数，因此其大小与 $\\alpha$ 的符号无关。最大拉伸发生在 $|\\cos(\\pi \\xi)|=1$ 的地方（在 $\\xi=0, 1$ 处），而在 $\\cos(\\pi \\xi)=0$ 的地方（在 $\\xi=1/2$ 处）没有拉伸（$A=1$）。\n\n- **与泊松方程的关系**：泊松网格生成方程中的强迫函数 $P$ 和 $Q$ 由映射函数的二阶导数确定。我们可以为给定的变换计算它们：\n$$\nx_{\\xi\\xi} = 0, \\quad x_{\\eta\\eta} = 0 \\implies P(\\xi,\\eta) = x_{\\xi\\xi} + x_{\\eta\\eta} = 0\n$$\n$$\ny_{\\xi\\xi} = -\\alpha \\pi^{2} \\sin(\\pi \\xi), \\quad y_{\\eta\\eta} = 0 \\implies Q(\\xi,\\eta) = y_{\\xi\\xi} + y_{\\eta\\eta} = -\\alpha \\pi^{2} \\sin(\\pi \\xi)\n$$\n这表明参数 $\\alpha$ 与强迫函数 $Q$ 成正比，后者控制着 $y$-坐标线的曲率。一个非零的 $\\alpha$ 引入了一个非零的强迫项 $Q$，它会“拉动”网格线以产生所观察到的非正交性和拉伸。因此，$\\alpha$ 通过泊松方程源项的机制，作为这些网格特性的控制参数。\n\n总之，推导出的表达式为：\n$J = 1$\n$\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = \\alpha \\pi \\cos(\\pi \\xi)$\n$A = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}$\n这些构成了最终的有序三元组。", "answer": "$$\n\\boxed{\\left( 1, \\alpha \\pi \\cos(\\pi \\xi), \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)} \\right)}\n$$", "id": "3313603"}, {"introduction": "从连续的偏微分方程到离散的代数方程组，是计算方法的核心，但这一过程可能引入数值不稳定性。本实践练习将通过一个具体的编程任务，带您探索离散极值原理在网格生成中的关键作用。您将通过实验证明，即使源项和边界条件都非常光滑，破坏离散系统的对角占优性也可能导致灾难性的网格折叠，从而深刻理解数值稳定性的实际意义。[@problem_id:3313541]", "problem": "考虑在计算单位正方形 $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ 上，通过泊松 (Poisson) 系统对物理映射分量 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 进行二维椭圆网格生成，并采用狄利克雷 (Dirichlet) 边界条件。其连续形式规定 $x$ 和 $y$ 求解在计算空间中带有光滑源项的泊松方程。此问题的基本依据包括：(i) 拉普拉斯 (Laplace) 算子的连续极值原理，该原理指出调和函数的极值出现在边界上；(ii) 由有限差分离散化产生的线性系统的离散极值原理的定义，当系数矩阵是单调矩阵（例如 M-矩阵）时，该原理成立，其特征为非正的非对角元、正的对角元，以及足以确保非负逆的对角占优条件；以及 (iii) 在均匀网格上对拉普拉斯算子的标准五点有限差分离散化。\n\n您的任务是，通过一个具体的、可计算的构造来证明，在泊松网格生成器的离散线性系统中违反（或破坏）对角占优，即使在源项和边界数据都光滑的情况下，也可能破坏离散极值原理并产生一个不可逆的网格（即出现折叠单元）；并实现一种稳定化处理，以恢复对角占优并防止网格折叠。\n\n为使任务完全确定，请使用以下设置。\n\n1. 定义一个具有微小、光滑内部聚类的精确光滑目标映射：\n   - 设光滑性振幅为 $A=0.158$（无量纲）。\n   - 定义\n     $$x_{\\text{exact}}(\\xi,\\eta) = \\xi + A \\sin(2\\pi \\xi)\\sin(\\pi \\eta),$$\n     $$y_{\\text{exact}}(\\xi,\\eta) = \\eta + A \\sin(2\\pi \\eta)\\sin(\\pi \\xi).$$\n   - 通过上述函数在计算空间中的拉普拉斯算子来定义源项：\n     $$P(\\xi,\\eta) = \\nabla^2 x_{\\text{exact}}(\\xi,\\eta) = -A\\,(5\\pi^2)\\,\\sin(2\\pi \\xi)\\sin(\\pi \\eta),$$\n     $$Q(\\xi,\\eta) = \\nabla^2 y_{\\text{exact}}(\\xi,\\eta) = -A\\,(5\\pi^2)\\,\\sin(2\\pi \\eta)\\sin(\\pi \\xi).$$\n   - 在单位正方形的边界上，施加从精确映射 $x_{\\text{exact}}$ 和 $y_{\\text{exact}}$ 中提取的狄利克雷边界条件。\n\n2. 使用每个坐标方向有 $N$ 个节点的均匀网格对内部进行离散化，因此网格间距为 $h = 1/(N-1)$，内部点数量为 $(N-2)^2$。对内部的离散拉普拉斯算子使用标准五点格式，即对应于以下算子：\n   $$4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j},$$\n   其中，对于边界上的邻点，其边界贡献被加到右侧。\n\n3. 通过缩放离散算子的对角线，构造一个可以破坏对角占优的单参数线性系统族：\n   - 设 $s \\in \\mathbb{R}$ 为一个对角缩放参数。将标准五点格式中的中心系数 $4$ 替换为 $4s$，同时保持所有非对角元等于 $-1$。在矩阵形式下，这会产生一个系数矩阵为如下形式的线性系统：\n     $$A_s = L + 4(s-1)I,$$\n     其中 $L$ 是标准五点离散拉普拉斯矩阵乘以 $h^2$（形式为 $4I -$ 非对角元），$I$ 是大小为 $(N-2)^2\\times(N-2)^2$ 的单位矩阵。请注意，当 $s<1$ 时，对角占优可能被破坏。\n   - 通过向算子中添加一个单位矩阵的正倍数（一个反应项），用一个稳定化参数 $\\sigma \\ge 0$ 来增强系统，得到：\n     $$A_{s,\\sigma} = L + 4(s-1+\\sigma)I.$$\n     当 $\\sigma \\ge 1-s$ 时，行对角占优至少恢复到标准水平。\n\n4. 使用相同的 $A_{s,\\sigma}$ 以及由源项和边界贡献决定的右侧项，求解两个解耦的泊松问题，分别得到 $x$ 和 $y$。重构包括边界在内的完整网格。\n\n5. 通过使用前向差分计算每个计算单元上的离散单元雅可比行列式来检测网格折叠：\n   $$J_{i,j} = \\det\\begin{pmatrix}\n   x_{i+1,j} - x_{i,j} & x_{i,j+1} - x_{i,j} \\\\\n   y_{i+1,j} - y_{i,j} & y_{i,j+1} - y_{i,j}\n   \\end{pmatrix}.$$\n   如果任何 $J_{i,j} \\le 0$，则检测到折叠单元。\n\n6. 您的程序必须实现以上内容，并为每个测试用例返回一个布尔值，指示是否有任何单元格发生折叠（即是否存在 $J_{i,j} \\le 0$）。程序不得要求任何用户输入。\n\n使用以下测试套件，其中包括一个基准案例、一个不稳定的非对角占优案例、一个稳定化案例和一个临近占优的边界案例：\n- 测试用例 1：$N=41$, $s=1.0$, $\\sigma=0.0$。\n- 测试用例 2：$N=41$, $s=0.1$, $\\sigma=0.0$。\n- 测试用例 3：$N=41$, $s=0.1$, $\\sigma=1.0$。\n- 测试用例 4：$N=16$, $s=0.95$, $\\sigma=0.0$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的、以逗号分隔的结果列表，结果顺序与测试用例顺序一致，例如，形式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是测试用例 $k$ 的布尔结果，指示是否发生折叠。无需物理单位。三角函数内部使用的角度以弧度为单位。最终输出是布尔值，无需四舍五入。", "solution": "该问题陈述经评估是有效的。其科学依据在于计算流体动力学和数值分析的原理，特别是关于通过泊松方程进行椭圆网格生成。该问题是适定的，为数值实验提供了一套完整且一致的定义、参数和边界条件。其目标是证明离散线性系统中的对角占优性对于维持网格质量（即防止折叠）的重要性。这是科学计算中一个标准且富有洞察力的练习。所有术语都得到了正式定义，并且任务是可以通过计算来验证的。\n\n求解过程如下：\n\n首先，我们建立计算域，即 $(\\xi, \\eta)$ 坐标系中的一个单位正方形，该正方形由一个大小为 $N \\times N$ 的均匀网格离散化。网格间距为 $h = 1/(N-1)$。网格点为 $(\\xi_i, \\eta_j) = (i h, j h)$，其中 $i, j = 0, \\dots, N-1$。\n\n问题要求为物理坐标 $x(\\xi, \\eta)$ 和 $y(\\xi, \\eta)$ 求解两个解耦的泊松方程：\n$$ \\nabla^2 x = P(\\xi, \\eta) $$\n$$ \\nabla^2 y = Q(\\xi, \\eta) $$\n其中 $\\nabla^2 = \\frac{\\partial^2}{\\partial \\xi^2} + \\frac{\\partial^2}{\\partial \\eta^2}$。源项 $P$ 和 $Q$ 以及狄利克雷边界条件均源自一个已知的精确映射：\n$$ x_{\\text{exact}}(\\xi,\\eta) = \\xi + A \\sin(2\\pi \\xi)\\sin(\\pi \\eta) $$\n$$ y_{\\text{exact}}(\\xi,\\eta) = \\eta + A \\sin(2\\pi \\eta)\\sin(\\pi \\xi) $$\n振幅 $A = 0.158$。源项为 $P = \\nabla^2 x_{\\text{exact}}$ 和 $Q = \\nabla^2 y_{\\text{exact}}$，由以下公式给出：\n$$ P(\\xi,\\eta) = -A(5\\pi^2)\\sin(2\\pi \\xi)\\sin(\\pi \\eta) $$\n$$ Q(\\xi,\\eta) = -A(5\\pi^2)\\sin(2\\pi \\eta)\\sin(\\pi \\xi) $$\n\n问题的核心在于泊松方程的离散化。对内部点 $(i, j)$（其中 $i, j \\in \\{1, \\dots, N-2\\}$）使用修正的五点格式：\n$$ 4(s+\\sigma) u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j} $$\n这里，$u$ 代表 $x$ 或 $y$，$f$ 代表 $P$ 或 $Q$。参数 $s$ 和 $\\sigma$ 控制所得线性系统矩阵的对角元，从而影响其对角占优性。对于一个内部节点，对角元是 $4(s+\\sigma)$，而非对角元绝对值之和为 $4$。如果 $|4(s+\\sigma)| \\ge 4$，即 $s+\\sigma \\ge 1$，则可保证对角占优。\n\n我们为内部网格点上 $(N-2)^2$ 个 $x$ 和 $y$ 的未知值建立一个线性系统 $A_{s,\\sigma} \\mathbf{u} = \\mathbf{b}$。矩阵 $A_{s,\\sigma}$ 基于修正的格式构造。对于每个内部点 $(i,j)$，构建线性系统中相应的一行。矩阵的对角元是 $4(s+\\sigma)$，对于每个内部邻点，非对角元是 $-1$。如果一个邻点 $(i', j')$ 在边界上，其值 $u_{i',j'}$ 可从狄利克雷条件（通过 $x_{\\text{exact}}$ 或 $y_{\\text{exact}}$ 计算）得知。这个已知值被移到方程的右侧。因此，对于给定的内部点 $(i,j)$，右端向量 $\\mathbf{b}$ 由缩放后的源项 $h^2 f_{i,j}$ 加上来自相邻单元的任何边界值的总和构成。\n\n求解这两个稀疏线性系统（一个用于 $x$ 坐标，一个用于 $y$ 坐标），以找到内部网格点的值。然后将这些解与已知的边界值相结合，形成完整的 $N \\times N$ 物理坐标网格 $(x_{i,j}, y_{i,j})$。\n\n最后一步是检查网格折叠。如果网格中任何单元的面积为非正值或定向不正确，则认为该网格发生了折叠。这通过计算每个四边形单元的映射雅可比行列式来检测。对于左下角位于 $(\\xi_i, \\eta_j)$ 的单元，其雅可比行列式 $J_{i,j}$ 使用前向差分计算：\n$$ J_{i,j} = \\det\\begin{pmatrix}\nx_{i+1,j} - x_{i,j} & x_{i,j+1} - x_{i,j} \\\\\ny_{i+1,j} - y_{i,j} & y_{i,j+1} - y_{i,j}\n\\end{pmatrix} $$\n对所有单元（其中 $i, j = 0, \\dots, N-2$）进行此计算。如果任何 $J_{i,j} \\le 0$，则表示一个局部不可逆的映射，该网格被标记为已折叠。为每个测试用例确定布尔结果 `True`（折叠）或 `False`（未折叠）。\n\n实现细节包括：\n1.  设置计算网格坐标。\n2.  在边界上计算精确解，在内部计算源项。\n3.  构造稀疏矩阵 $A_{s,\\sigma}$ 和右端向量 $\\mathbf{b}_x$ 和 $\\mathbf{b}_y$。使用一个从二维网格索引 $(i, j)$ 到一维向量索引 $k$ 的索引映射，例如，对于 $i,j \\in \\{1, \\dots, N-2\\}$，使用 $k = (j-1)(N-2) + (i-1)$。\n4.  使用 `scipy.sparse.linalg.spsolve` 求解稀疏线性系统。\n5.  重构完整的 $N \\times N$ 的 $x$ 和 $y$ 求解网格。\n6.  为提高效率，将对所有 $(N-1) \\times (N-1)$ 个单元的雅可比行列式计算进行向量化处理。\n7.  如果任何雅可比行列式小于或等于零，则返回 `True`，否则返回 `False`。\n此过程将应用于每个指定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef run_case(N, s, sigma, A_const):\n    \"\"\"\n    Sets up and solves the Poisson grid generation problem for a single test case.\n\n    Args:\n        N (int): Number of grid points in each direction.\n        s (float): Diagonal scaling parameter.\n        sigma (float): Stabilization parameter.\n        A_const (float): Amplitude for the exact solution.\n\n    Returns:\n        bool: True if the grid is folded, False otherwise.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    n_interior = (N - 2)**2\n\n    # 1. Computational grid and function definitions\n    xi_1d = np.linspace(0.0, 1.0, N)\n    eta_1d = np.linspace(0.0, 1.0, N)\n    # With indexing='xy', array[j, i] corresponds to (xi_i, eta_j)\n    xi_grid, eta_grid = np.meshgrid(xi_1d, eta_1d, indexing='xy')\n\n    def x_exact_func(xi, eta):\n        return xi + A_const * np.sin(2.0 * np.pi * xi) * np.sin(np.pi * eta)\n\n    def y_exact_func(xi, eta):\n        return eta + A_const * np.sin(2.0 * np.pi * eta) * np.sin(np.pi * xi)\n\n    def p_source_func(xi, eta):\n        return -A_const * (5.0 * np.pi**2) * np.sin(2.0 * np.pi * xi) * np.sin(np.pi * eta)\n\n    def q_source_func(xi, eta):\n        return -A_const * (5.0 * np.pi**2) * np.sin(2.0 * np.pi * eta) * np.sin(np.pi * xi)\n\n    # 2. Evaluate boundary conditions and source terms\n    x_exact_grid = x_exact_func(xi_grid, eta_grid)\n    y_exact_grid = y_exact_func(xi_grid, eta_grid)\n\n    P_interior = p_source_func(xi_grid[1:-1, 1:-1], eta_grid[1:-1, 1:-1])\n    Q_interior = q_source_func(xi_grid[1:-1, 1:-1], eta_grid[1:-1, 1:-1])\n\n    # 3. Assemble matrix A and RHS vectors b_x, b_y\n    rows, cols, data = [], [], []\n    b_x = np.zeros(n_interior)\n    b_y = np.zeros(n_interior)\n    \n    # Loop over interior grid points (eta_j, xi_i)\n    for j in range(1, N - 1):  # Index for eta\n        for i in range(1, N - 1):  # Index for xi\n            k = (j - 1) * (N - 2) + (i - 1)  # Row-major 1D index\n\n            rows.append(k)\n            cols.append(k)\n            data.append(4.0 * (s + sigma))\n            \n            b_x[k] = h**2 * P_interior[j-1, i-1]\n            b_y[k] = h**2 * Q_interior[j-1, i-1]\n\n            # Neighbors: west, east, south, north\n            if i == 1: # West boundary\n                b_x[k] += x_exact_grid[j, 0]\n                b_y[k] += y_exact_grid[j, 0]\n            else:\n                rows.append(k); cols.append(k - 1); data.append(-1.0)\n            \n            if i == N - 2: # East boundary\n                b_x[k] += x_exact_grid[j, N - 1]\n                b_y[k] += y_exact_grid[j, N - 1]\n            else:\n                rows.append(k); cols.append(k + 1); data.append(-1.0)\n\n            if j == 1: # South boundary\n                b_x[k] += x_exact_grid[0, i]\n                b_y[k] += y_exact_grid[0, i]\n            else:\n                rows.append(k); cols.append(k - (N - 2)); data.append(-1.0)\n                \n            if j == N - 2: # North boundary\n                b_x[k] += x_exact_grid[N - 1, i]\n                b_y[k] += y_exact_grid[N - 1, i]\n            else:\n                rows.append(k); cols.append(k + (N - 2)); data.append(-1.0)\n\n    A_matrix = coo_matrix((data, (rows, cols)), shape=(n_interior, n_interior)).tocsc()\n    \n    # 4. Solve linear systems\n    try:\n        x_interior_sol = spsolve(A_matrix, b_x)\n        y_interior_sol = spsolve(A_matrix, b_y)\n    except np.linalg.LinAlgError:\n        # A singular matrix implies catastrophic failure of the grid generation.\n        return True\n\n    # 5. Reconstruct full grid solution\n    x_sol = np.copy(x_exact_grid)\n    y_sol = np.copy(y_exact_grid)\n    x_sol[1:-1, 1:-1] = x_interior_sol.reshape((N - 2, N - 2))\n    y_sol[1:-1, 1:-1] = y_interior_sol.reshape((N - 2, N - 2))\n\n    # 6. Check for grid folding by computing cell Jacobians\n    # J_ij = (x_{i+1,j}-x_{ij})(y_{i,j+1}-y_{ij}) - (x_{i,j+1}-x_{ij})(y_{i+1,j}-y_{ij})\n    # x_{i,j} -> x_sol[j,i]\n    \n    dx_dxi_approx = x_sol[:, 1:] - x_sol[:, :-1]   # shape (N, N-1)\n    dy_dxi_approx = y_sol[:, 1:] - y_sol[:, :-1]\n    dx_deta_approx = x_sol[1:, :] - x_sol[:-1, :]   # shape (N-1, N)\n    dy_deta_approx = y_sol[1:, :] - y_sol[:-1, :]\n    \n    # We want det( (dx_dxi_approx/h), (dx_deta_approx/h) ) but can ignore the 1/h^2 factor.\n    # The vectors in the problem are (x_ip1j - x_ij, y_ip1j - y_ij) and (x_ijp1 - x_ij, y_ijp1 - y_ij)\n    # Using numpy array slicing for this:\n    # dx_dxi is x_{i+1,j} - x_{i,j}, has shape (N, N-1) -> corresponds to columns\n    # dx_deta is x_{i,j+1} - x_{i,j}, has shape (N-1, N) -> corresponds to rows\n    \n    vec1_x = x_sol[0:N-1, 1:N] - x_sol[0:N-1, 0:N-1]\n    vec1_y = y_sol[0:N-1, 1:N] - y_sol[0:N-1, 0:N-1]\n    \n    vec2_x = x_sol[1:N, 0:N-1] - x_sol[0:N-1, 0:N-1]\n    vec2_y = y_sol[1:N, 0:N-1] - y_sol[0:N-1, 0:N-1]\n    \n    # The problem definition of J_ij is det([v_xi, v_eta]) where v_xi = pos(i+1,j)-pos(i,j) etc.\n    # This is different from the standard Jacobian of the transformation. Let's use the provided def.\n    # It has a typo in the matrix. It should be det([c1 | c2]), where c1 is difference in i and c2 is diff in j.\n    # J_ij = (x_{i+1,j}-x_{ij}) * (y_{i,j+1}-y_{ij}) - (x_{i,j+1}-x_{ij}) * (y_{i+1,j}-y_{ij})\n    # x_sol is indexed (j,i)\n    dx_i = x_sol[:, 1:] - x_sol[:, :-1]\n    dy_i = y_sol[:, 1:] - y_sol[:, :-1]\n    dx_j = x_sol[1:, :] - x_sol[:-1, :]\n    dy_j = y_sol[1:, :] - y_sol[:-1, :]\n    \n    J = dx_i[:-1, :] * dy_j[:, :-1] - dx_j[:, :-1] * dy_i[:-1, :]\n    \n    return np.any(J = 0)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 1.0, 0.0),  # Baseline, diagonally dominant\n        (41, 0.1, 0.0),  # Not diagonally dominant, unstable\n        (41, 0.1, 1.0),  # Stabilized\n        (16, 0.95, 0.0), # Near-dominance edge case\n    ]\n\n    results = []\n    A_const = 0.158\n    for case in test_cases:\n        N, s, sigma = case\n        is_folded = run_case(N, s, sigma, A_const)\n        results.append(is_folded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3313541"}, {"introduction": "椭圆网格生成方法的真正威力在于其通过泊松方程的源项（$P$ 和 $Q$）实现对网格的智能控制。本项高级实践将指导您设计源项来模拟一个涡对的流场，并通过求解相应的泊松方程来生成网格。您将通过这个数值实验，探索网格线是否会像流线一样环绕涡旋中心，从而掌握一种为高精度CFD模拟创建“流动自适应”网格的强大技术。[@problem_id:3313605]", "problem": "考虑计算流体动力学 (CFD) 中使用的经典椭圆网格生成框架。设计算坐标为均匀格点上的 $\\xi \\in [0,1]$ 和 $\\eta \\in [0,1]$，物理映射为 $(x(\\xi,\\eta), y(\\xi,\\eta))$。通过泊松方程的椭圆网格生成方法通过以下方程规定坐标函数\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta), \\quad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta),\n$$\n其狄利克雷边界条件将边界固定为恒等映射，即 $x(\\xi,0)=\\xi$，$x(\\xi,1)=\\xi$，$x(0,\\eta)=0$，$x(1,\\eta)=1$ 以及 $y(\\xi,0)=0$，$y(\\xi,1)=1$，$y(0,\\eta)=\\eta$，$y(1,\\eta)=\\eta$。\n\n您需要设计一个实验，其中控制函数 $P$ 和 $Q$ 中的虚拟点源和点汇模拟一个涡对，然后检验坐标线是否会像施加的涡流场的流线一样缠绕。实验必须从第一性原理出发，使用以下经过充分检验的基础：位于 $(c_x,c_y)$ 的一个环量强度为 $\\Gamma$ 的二维、无粘、不可压缩点涡产生的速度场为\n$$\nu(\\xi,\\eta) = -\\frac{\\Gamma}{2\\pi} \\frac{\\eta-c_y}{(\\xi-c_x)^2 + (\\eta-c_y)^2}, \\quad\nv(\\xi,\\eta) = \\phantom{-}\\frac{\\Gamma}{2\\pi} \\frac{\\xi-c_x}{(\\xi-c_x)^2 + (\\eta-c_y)^2}.\n$$\n为确保数值稳定性和物理真实性，通过将分母替换为 $(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2$ 来对奇点进行正则化，其中 $\\varepsilon0$ 是一个核心尺寸。通过叠加两个强度相等、方向相反（分别为 $+\\Gamma$ 和 $-\\Gamma$）、中心分别位于 $(c_{1x},c_{1y})$ 和 $(c_{2x},c_{2y})$ 的涡来构造一个涡对。通过将标量缩放因子 $k$ 应用于速度分量来定义控制函数：\n$$\nP(\\xi,\\eta) = k\\,u_{\\text{pair}}(\\xi,\\eta), \\quad Q(\\xi,\\eta) = k\\,v_{\\text{pair}}(\\xi,\\eta),\n$$\n其中 $(u_{\\text{pair}}, v_{\\text{pair}})$ 是由两个涡引起的正则化速度之和。\n\n在一个均匀的 $\\xi$–$\\eta$ 网格上，为所选整数 $N\\ge 5$ 和网格间距 $h=\\frac{1}{N-1}$ 实现一个针对上述泊松方程的有限差分求解器。对内部节点使用 Gauss–Seidel 迭代法求解 $(x,y)$，并以恒等映射作为初始猜测。当 $x$ 和 $y$ 的任意内部节点的最大绝对变化量低于容差 $10^{-6}$，或达到 $10^4$ 次迭代时，以先到者为准，停止迭代。\n\n计算出 $(x,y)$ 后，通过中心差分估计坐标线的局部切线：\n$$\n\\mathbf{t}_\\xi = \\big(x_\\xi, y_\\xi\\big), \\quad \\mathbf{t}_\\eta = \\big(x_\\eta, y_\\eta\\big),\n$$\n并在同一格点上评估正则化的涡对速度 $(u_{\\text{pair}}, v_{\\text{pair}})$。对于每个内部节点，如果切线和速度的模超过一个小的阈值（例如 $10^{-12}$），则计算 $\\mathbf{t}_\\xi$ 与局部流线方向之间以及 $\\mathbf{t}_\\eta$ 与局部流线方向之间的无符号错位角（以弧度为单位）：\n$$\n\\theta_\\xi = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\xi \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\xi\\|\\,\\|\\mathbf{s}\\|}\\right), \\quad\n\\theta_\\eta = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\eta \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\eta\\|\\,\\|\\mathbf{s}\\|}\\right),\n$$\n其中 $\\mathbf{s} = (u_{\\text{pair}}, v_{\\text{pair}})$ 是局部速度矢量，$\\|\\cdot\\|$ 表示欧几里得范数。通过对所有内部节点求平均，将这些值汇总成一个标量：\n$$\n\\bar{\\theta} = \\frac{1}{2}\\left(\\operatorname{mean}(\\theta_\\xi) + \\operatorname{mean}(\\theta_\\eta)\\right).\n$$\n此外，估计坐标变换的局部雅可比行列式，\n$$\nJ = x_\\xi y_\\eta - x_\\eta y_\\xi,\n$$\n并报告是否在所有内部节点上都满足 $J0$（一个表示没有发生折叠的布尔值）。使用中心差分计算内部节点的 $x_\\xi$、$x_\\eta$、$y_\\xi$、$y_\\eta$。\n\n设计一个包含三个案例的测试套件来探索其行为：\n- 案例 1（正常路径）：$N=51$，$\\Gamma=1.0$，$\\varepsilon=0.02$，$k=0.02$，$(c_{1x},c_{1y})=(0.35,0.50)$，$(c_{2x},c_{2y})=(0.65,0.50)$。\n- 案例 2（近拉普拉斯基线）：$N=51$，$\\Gamma=1.0$，$\\varepsilon=0.02$，$k=0.0$，$(c_{1x},c_{1y})=(0.35,0.50)$，$(c_{2x},c_{2y})=(0.65,0.50)$。\n- 案例 3（更强控制）：$N=51$，$\\Gamma=1.0$，$\\varepsilon=0.015$，$k=0.08$，$(c_{1x},c_{1y})=(0.35,0.50)$，$(c_{2x},c_{2y})=(0.65,0.50)$。\n\n您的程序必须为每个案例求解网格，计算以弧度为单位的 $\\bar{\\theta}$ 和布尔值 $\\text{all\\_positive\\_Jacobian}$（表示是否所有内部节点的 $J0$），然后生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[\\bar{\\theta}_1,\\text{all\\_positive\\_Jacobian}_1,\\bar{\\theta}_2,\\text{all\\_positive\\_Jacobian}_2,\\bar{\\theta}_3,\\text{all\\_positive\\_Jacobian}_3].\n$$\n角度必须以弧度报告。不允许外部输入，程序必须自包含运行。", "solution": "该问题要求在一个单位正方形上对一组用于椭圆网格生成的两个泊松方程进行数值求解，并对得到的网格几何形状进行后续分析。此过程分为四个主要阶段：问题构建、离散化、数值求解和后处理分析。\n\n物理坐标 $(x, y)$ 将作为计算坐标 $(\\xi, \\eta)$ 的函数来确定，其中 $(\\xi, \\eta)$ 在单位正方形 $[0,1] \\times [0,1]$ 上形成一个均匀格点。控制方程是一对泊松方程：\n$$\n\\nabla^2 x = x_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)\n$$\n$$\n\\nabla^2 y = y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)\n$$\n函数 $P(\\xi,\\eta)$ 和 $Q(\\xi,\\eta)$ 是用于影响网格特性的控制函数。边界条件为狄利克雷类型，将计算正方形的边界恒等映射到物理正方形的边界：\n$$\n\\begin{align*}\nx(\\xi,0) = \\xi,  x(\\xi,1) = \\xi,  x(0,\\eta) = 0,  x(1,\\eta) = 1 \\\\\ny(\\xi,0) = 0,  y(\\xi,1) = 1,  y(0,\\eta) = \\eta,  y(1,\\eta) = \\eta\n\\end{align*}\n$$\n控制函数由正则化涡对的速度场构建而成。位于 $(c_x, c_y)$、强度为 $\\Gamma$、正则化核心尺寸为 $\\varepsilon$ 的单个涡的速度场 $(u,v)$ 为：\n$$\n u(\\xi,\\eta) = -\\frac{\\Gamma}{2\\pi} \\frac{\\eta-c_y}{(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2}, \\quad\n v(\\xi,\\eta) = \\phantom{-}\\frac{\\Gamma}{2\\pi} \\frac{\\xi-c_x}{(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2}\n$$\n涡对场 $(u_{\\text{pair}}, v_{\\text{pair}})$ 是两个此类涡的叠加：一个强度为 $+\\Gamma$，位于 $(c_{1x},c_{1y})$；另一个强度为 $-\\Gamma$，位于 $(c_{2x},c_{2y})$。然后，控制函数被定义为 $P(\\xi,\\eta) = k\\,u_{\\text{pair}}(\\xi,\\eta)$ 和 $Q(\\xi,\\eta) = k\\,v_{\\text{pair}}(\\xi,\\eta)$，其中 $k$ 是一个缩放因子。\n\n为了数值求解该系统，我们将计算域离散化为一个 $N \\times N$ 点的均匀网格。两个方向的网格间距均为 $h = 1/(N-1)$。令 $x_{i,j} = x(i h, j h)$ 和 $y_{i,j} = y(i h, j h)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。在每个内部节点 $(i,j)$，拉普拉斯算子 $\\nabla^2$ 使用二阶中心差分格式进行近似：\n$$\n\\nabla^2 x |_{i,j} \\approx \\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{h^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{h^2}\n$$\n将此应用于 $x$ 的泊松方程，得到离散方程：\n$$\nx_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1} - 4x_{i,j} = h^2 P_{i,j}\n$$\n一个相似的方程对 $y_{i,j}$ 也成立。\n\n对内部节点得到的线性代数方程组使用 Gauss-Seidel 迭代法求解。从初始猜测（即恒等映射，$x_{i,j} = i h$, $y_{i,j} = j h$）开始，每个内部节点 $(i,j)$ 的值使用其邻居节点的最新计算值进行更新。$x_{i,j}$ 在第 $k+1$ 次迭代的更新公式为：\n$$\nx_{i,j}^{(k+1)} = \\frac{1}{4} \\left( x_{i+1,j}^{(k)} + x_{i-1,j}^{(k+1)} + x_{i,j+1}^{(k)} + x_{i,j-1}^{(k+1)} - h^2 P_{i,j} \\right)\n$$\n对 $y_{i,j}$ 也执行类似的更新。重复此过程，直到连续迭代中 $x$ 和 $y$ 的任何内部节点值的最大绝对变化量低于 $10^{-6}$ 的容差，或达到 $10^4$ 次迭代的最大次数。\n\n收敛后，我们分析生成的网格。首先，我们使用二阶中心差分在每个内部节点计算坐标线的切线 $\\mathbf{t}_\\xi = (x_\\xi, y_\\xi)$ 和 $\\mathbf{t}_\\eta = (x_\\eta, y_\\eta)$：\n$$\nx_\\xi \\approx \\frac{x_{i+1,j} - x_{i-1,j}}{2h}, \\quad x_\\eta \\approx \\frac{x_{i,j+1} - x_{i,j-1}}{2h}, \\quad \\text{对 } y \\text{ 等同}\n$$\n计算这些切线与局部流线方向矢量 $\\mathbf{s} = (u_{\\text{pair}}, v_{\\text{pair}})$ 之间的无符号错位角 $\\theta_\\xi$ 和 $\\theta_\\eta$：\n$$\n\\theta_\\xi = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\xi \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\xi\\|\\,\\|\\mathbf{s}\\|}\\right), \\quad \\theta_\\eta = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\eta \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\eta\\|\\,\\|\\mathbf{s}\\|}\\right)\n$$\n这些角仅在矢量模大于阈值 $10^{-12}$ 的节点上计算。然后，平均错位角 $\\bar{\\theta}$ 计算为 $\\bar{\\theta} = \\frac{1}{2}(\\text{mean}(\\theta_\\xi) + \\text{mean}(\\theta_\\eta))$。\n最后，我们在所有内部节点上评估变换的雅可比行列式 $J = x_\\xi y_\\eta - x_\\eta y_\\xi$。处处为正的雅可比行列式（$J0$）表示网格没有自我折叠，这是有效网格的一个关键质量指标。基于此检查报告一个布尔标志。整个过程针对三个不同的测试案例执行，以探究控制函数强度的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (N, Gamma, epsilon, k, c1, c2)\n    test_cases = [\n        # Case 1: happy path\n        (51, 1.0, 0.02, 0.02, (0.35, 0.50), (0.65, 0.50)),\n        # Case 2: near-Laplace baseline\n        (51, 1.0, 0.02, 0.0, (0.35, 0.50), (0.65, 0.50)),\n        # Case 3: stronger control\n        (51, 1.0, 0.015, 0.08, (0.35, 0.50), (0.65, 0.50)),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        bar_theta, all_positive_jacobian = run_case(*case_params)\n        results.append(f\"{bar_theta:.12f}\")\n        results.append(str(all_positive_jacobian).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_case(N, Gamma, epsilon, k, c1, c2):\n    \"\"\"\n    Solves the grid generation problem for a single set of parameters.\n    \"\"\"\n    # Unpack vortex centers\n    c1x, c1y = c1\n    c2x, c2y = c2\n\n    # Grid setup\n    h = 1.0 / (N - 1)\n    xi_coords = np.linspace(0.0, 1.0, N)\n    eta_coords = np.linspace(0.0, 1.0, N)\n    XI, ETA = np.meshgrid(xi_coords, eta_coords, indexing='ij')\n\n    # --- Step 1: Compute source terms P and Q ---\n    def vortex_velocity(grid_XI, grid_ETA, G, center, eps):\n        cx_v, cy_v = center\n        den = (grid_XI - cx_v)**2 + (grid_ETA - cy_v)**2 + eps**2\n        u = -(G / (2 * np.pi)) * (grid_ETA - cy_v) / den\n        v =  (G / (2 * np.pi)) * (grid_XI - cx_v) / den\n        return u, v\n\n    u1, v1 = vortex_velocity(XI, ETA, Gamma, c1, epsilon)\n    u2, v2 = vortex_velocity(XI, ETA, -Gamma, c2, epsilon)\n    \n    u_pair = u1 + u2\n    v_pair = v1 + v2\n    \n    P = k * u_pair\n    Q = k * v_pair\n\n    # --- Step 2: Solve the Poisson equations using Gauss-Seidel ---\n    x = XI.copy()\n    y = ETA.copy()\n\n    tol = 1e-6\n    max_iter = 10000\n    h2 = h**2\n    \n    for _ in range(max_iter):\n        x_old = x.copy()\n        y_old = y.copy()\n        \n        # Explicit point-wise Gauss-Seidel iteration over interior nodes\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                x[i, j] = 0.25 * (x[i+1, j] + x[i-1, j] + x[i, j+1] + x[i, j-1] - h2 * P[i, j])\n                y[i, j] = 0.25 * (y[i+1, j] + y[i-1, j] + y[i, j+1] + y[i, j-1] - h2 * Q[i, j])\n\n        # Check for convergence\n        max_change = np.max([np.abs(x - x_old), np.abs(y - y_old)])\n        if max_change  tol:\n            break\n\n    # --- Step 3: Post-processing and analysis ---\n    # Compute derivatives on interior nodes using centered differences\n    x_xi = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * h)\n    x_eta = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * h)\n    y_xi = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * h)\n    y_eta = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * h)\n\n    # Calculate Jacobian determinant and check for folding\n    J = x_xi * y_eta - x_eta * y_xi\n    all_positive_jacobian = np.all(J > 0)\n\n    # Calculate misalignment angles\n    s_u = u_pair[1:-1, 1:-1]\n    s_v = v_pair[1:-1, 1:-1]\n    \n    # Calculate magnitudes of tangent and streamline vectors\n    norm_t_xi = np.sqrt(x_xi**2 + y_xi**2)\n    norm_t_eta = np.sqrt(x_eta**2 + y_eta**2)\n    norm_s = np.sqrt(s_u**2 + s_v**2)\n\n    # Filter nodes where magnitudes are too small\n    mag_tol = 1e-12\n    valid_mask = (norm_t_xi > mag_tol)  (norm_t_eta > mag_tol)  (norm_s > mag_tol)\n    \n    # Compute dot products only for valid nodes\n    dot_xi_s = x_xi[valid_mask] * s_u[valid_mask] + y_xi[valid_mask] * s_v[valid_mask]\n    dot_eta_s = x_eta[valid_mask] * s_u[valid_mask] + y_eta[valid_mask] * s_v[valid_mask]\n\n    # Filtered norms\n    norm_t_xi_f = norm_t_xi[valid_mask]\n    norm_t_eta_f = norm_t_eta[valid_mask]\n    norm_s_f = norm_s[valid_mask]\n\n    # Calculate angles, clipping to avoid domain errors with arccos\n    cos_arg_xi = np.clip(np.abs(dot_xi_s) / (norm_t_xi_f * norm_s_f), -1.0, 1.0)\n    cos_arg_eta = np.clip(np.abs(dot_eta_s) / (norm_t_eta_f * norm_s_f), -1.0, 1.0)\n\n    theta_xi = np.arccos(cos_arg_xi)\n    theta_eta = np.arccos(cos_arg_eta)\n    \n    # Compute the final average misalignment angle\n    if theta_xi.size == 0 and theta_eta.size == 0:\n        bar_theta = 0.0\n    else:\n        mean_xi = np.mean(theta_xi) if theta_xi.size > 0 else 0.0\n        mean_eta = np.mean(theta_eta) if theta_eta.size > 0 else 0.0\n        bar_theta = 0.5 * (mean_xi + mean_eta)\n\n    return bar_theta, all_positive_jacobian\n\nsolve()\n```", "id": "3313605"}]}