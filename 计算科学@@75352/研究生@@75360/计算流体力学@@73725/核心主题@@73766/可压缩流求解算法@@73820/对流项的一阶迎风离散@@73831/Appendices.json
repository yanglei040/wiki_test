{"hands_on_practices": [{"introduction": "理论学习之后，第一个关键步骤是通过实践来验证。本练习将指导您为一维线性平流方程实现一阶迎风格式，并通过网格加密研究来实证其一阶收敛精度。这个过程不仅是验证代码正确性的基本方法，也是计算流体力学中评估数值方案性能的标准技术。[@problem_id:3318421]", "problem": "考虑由守恒律 $$\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$$ 控制的被动标量的一维线性平流，其通量为 $$f(u) = a\\,u,$$ 其中 $$u(x,t)$$ 是一个光滑标量场，$$a$$ 是一个恒定的平流速度。在长度为 $$L$$ 的周期性域上的均匀网格中，目标是设计并实现一个网格加密研究，以经验性地验证应用于光滑余弦波输运的一阶迎风空间离散格式的一阶收敛性。推导和实现必须从守恒律和与信息传播方向一致的单调数值通量选择出发，并且不得假定任何简便公式。该研究必须使用一阶显式时间积分器，并选择合适的时间步长，以在不同网格加密级别上保持 Courant–Friedrichs–Lewy (CFL) 数恒定。\n\n使用以下物理上和数值上一致的设置：\n- 域长度 $$L = 1\\,\\mathrm{m}$$，采用周期性边界条件。\n- 平流速度 $$a \\in \\{1\\,\\mathrm{m/s}, -1\\,\\mathrm{m/s}\\}$$，由测试套件指定。\n- 初始条件 $$u(x,0) = \\cos\\left(2\\pi k\\, \\frac{x}{L}\\right),$$ 波数 $$k = 1$$ (无量纲)。\n- 均匀网格，包含 $$N$$ 个单元，单元中心为 $$x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$$，其中 $$i \\in \\{0,1,\\dots,N-1\\}$$，且 $$\\Delta x = \\frac{L}{N}$$。\n- 最终物理时间 $$T = \\frac{L}{2\\,|a|}$$，单位为 $$\\mathrm{s}$$。\n- 选择时间步长 $$\\Delta t$$ 以使 Courant–Friedrichs–Lewy (CFL) 数 $$\\nu = \\frac{|a|\\,\\Delta t}{\\Delta x}$$ 对每个测试用例和加密级别保持恒定；调整 $$\\Delta t$$ 以使整数步数 $$n_{\\text{steps}}$$ 对每个网格都精确满足 $$n_{\\text{steps}}\\,\\Delta t = T$$。\n\n空间离散要求：\n- 在周期性网格上，实现一个与 $$a$$ 符号一致的一阶迎风空间离散。该离散必须从带有单调数值通量的守恒律推导而来，并且只能使用迎风方向上的最近邻信息。\n\n时间离散要求：\n- 对半离散系统使用一阶显式时间积分器。\n\n误差测量：\n- 在最终时间 $$T$$，将单元中心 $$x_i$$ 处的数值解 $$u_i^{n_{\\text{final}}}$$ 与精确解 $$u_{\\text{exact}}(x_i,T) = \\cos\\left(2\\pi k\\,\\frac{x_i - a\\,T}{L}\\right)$$ 进行比较，并计算以下离散误差范数：\n  1. 离散 $$L^1$$ 范数 $$\\|e\\|_{1} = \\sum_{i=0}^{N-1} |e_i|\\,\\Delta x,$$ 其中 $$e_i = u_i^{n_{\\text{final}}} - u_{\\text{exact}}(x_i,T).$$\n  2. 离散 $$L^2$$ 范数 $$\\|e\\|_{2} = \\left(\\sum_{i=0}^{N-1} e_i^2\\,\\Delta x\\right)^{1/2}.$$\n  3. 离散 $$L^{\\infty}$$ 范数 $$\\|e\\|_{\\infty} = \\max_{0 \\le i \\le N-1} |e_i|.$$\n\n观测到的收敛阶：\n- 对于每个范数，给定加密集 $$\\{N_j\\}$$ 以及相应的 $$\\Delta x_j$$ 和误差值 $$E_j$$，通过对 $$\\log(E_j)$$ 与 $$\\log(\\Delta x_j)$$ 进行线性最小二乘拟合来估计观测到的收敛阶 $$p$$。将 $$p$$ 报告为实数。\n\n测试套件规范：\n- 使用 $$k = 1$$，$$L = 1\\,\\mathrm{m}$$，以及加密集 $$N \\in \\{50, 100, 200, 400\\}$$。\n- 对 $$a$$ 和 CFL 使用以下三组参数：\n  1. 情况 A (理想路径，正速度，中等 CFL): $$a = 1\\,\\mathrm{m/s}$$ 且 $$\\nu = 0.5.$$\n  2. 情况 B (边缘情况，负速度以测试迎风方向切换): $$a = -1\\,\\mathrm{m/s}$$ 且 $$\\nu = 0.5.$$\n  3. 情况 C (接近 CFL-$$1$$ 的情况以探测稳定性边界): $$a = 1\\,\\mathrm{m/s}$$ 且 $$\\nu = 0.9.$$\n\n单位和输出：\n- 所有物理量必须使用 $$\\mathrm{m}$$ 作为长度单位，$$\\mathrm{s}$$ 作为时间单位进行处理。\n- 最终程序输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中有九个无单位的实数，按顺序代表情况 A、B 和 C 的 $$L^1$$、$$L^2$$ 和 $$L^{\\infty}$$ 范数的观测收敛阶 $$p$$。\n\n您的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，顺序为 $$[p_{A,1}, p_{A,2}, p_{A,\\infty}, p_{B,1}, p_{B,2}, p_{B,\\infty}, p_{C,1}, p_{C,2}, p_{C,\\infty}]$$，其中每个 $$p$$ 是一个浮点数。", "solution": "该问题要求进行网格加密研究，以验证一维线性平流方程的一阶迎风格式的一阶收敛性。推导和实现必须从第一性原理出发。\n\n我们从守恒形式的一维线性平流方程开始：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是一个标量场，通量由 $f(u) = a\\,u$ 给出，而 $a$ 是一个恒定的平流速度。\n\n为推导数值格式，我们采用有限体积法。我们将长度为 $L$ 的空间域划分为 $N$ 个均匀的单元（或称控制体）$C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=0, 1, \\dots, N-1$。每个单元的宽度为 $\\Delta x = L/N$，单元中心为 $x_i = (i + 1/2)\\Delta x$。将守恒律在单元 $C_i$ 上积分得到：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial f(u)}{\\partial x} dx = 0\n$$\n我们将时间 $t$ 时单元 $i$ 中 $u$ 的单元平均值定义为：\n$$\nu_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx\n$$\n假设 $\\Delta x$ 是常数，第一项变为 $\\Delta x \\frac{d u_i}{dt}$。根据微积分基本定理，第二项变为 $f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t))$。现在，方程成为关于单元平均值 $u_i$ 的常微分方程 (ODE)：\n$$\n\\frac{d u_i}{dt} + \\frac{f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t))}{\\Delta x} = 0\n$$\n单元界面处的通量点值（例如 $f(u(x_{i+1/2},t))$）是未知的。我们用数值通量函数 $\\hat{f}$ 来替代它们，该函数依赖于界面左右两侧的状态。设 $\\hat{f}_{i+1/2}$ 为界面 $x_{i+1/2}$ 处的数值通量，它依赖于单元平均值 $u_i$ 和 $u_{i+1}$。守恒律的半离散形式为：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} (\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2})\n$$\n问题指定了一阶迎风空间离散。迎风通量是一种单调通量，它遵循信息传播的方向，而该方向由特征速度 $f'(u) = a$ 的符号决定。\n介于左状态 $u_L$ 和右状态 $u_R$ 之间的一阶迎风数值通量为：\n$$\n\\hat{f}(u_L, u_R) =\n\\begin{cases}\nf(u_L) = a\\,u_L  \\text{if } a > 0 \\\\\nf(u_R) = a\\,u_R  \\text{if } a  0\n\\end{cases}\n$$\n这可以使用平流速度的正部 $a^+ = \\max(a, 0)$ 和负部 $a^- = \\min(a, 0)$ 紧凑地写为：\n$$\n\\hat{f}(u_L, u_R) = a^+ u_L + a^- u_R\n$$\n对于我们的网格，界面 $x_{i+1/2}$ 处的通量为 $\\hat{f}_{i+1/2} = \\hat{f}(u_i, u_{i+1}) = a^+ u_i + a^- u_{i+1}$，而在界面 $x_{i-1/2}$ 处为 $\\hat{f}_{i-1/2} = \\hat{f}(u_{i-1}, u_i) = a^+ u_{i-1} + a^- u_i$。将这些代入半离散方程得到：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left( (a^+ u_i + a^- u_{i+1}) - (a^+ u_{i-1} + a^- u_i) \\right) = -\\frac{1}{\\Delta x} \\left( a^+(u_i - u_{i-1}) + a^-(u_{i+1} - u_i) \\right)\n$$\n接下来，我们使用一阶显式（前向欧拉）方法在时间上进行离散。设 $u_i^n$ 为单元 $i$ 在时间步 $n$ 处的数值解。时间导数近似为 $\\frac{du_i}{dt} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$。全离散格式为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = -\\frac{1}{\\Delta x} \\left( a^+(u_i^n - u_{i-1}^n) + a^-(u_{i+1}^n - u_i^n) \\right)\n$$\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a^+(u_i^n - u_{i-1}^n) + a^-(u_{i+1}^n - u_i^n) \\right)\n$$\n让我们分析 $a$ 符号的两种情况：\n1. 如果 $a > 0$：$a^+ = a$ 且 $a^- = 0$。格式变为 $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)$。\n2. 如果 $a  0$：$a^+ = 0$ 且 $a^- = a$。格式变为 $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n)$。\n\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = \\frac{|a| \\Delta t}{\\Delta x}$，我们可以写出 $\\frac{\\Delta t}{\\Delta x} = \\frac{\\nu}{|a|}$。更新规则变为：\n1. 如果 $a > 0$：$u_i^{n+1} = u_i^n - \\frac{a}{|a|}\\nu(u_i^n - u_{i-1}^n) = u_i^n - \\nu(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n$。\n2. 如果 $a  0$：$u_i^{n+1} = u_i^n - \\frac{a}{|a|}\\nu(u_{i+1}^n - u_i^n) = u_i^n + \\nu(u_{i+1}^n - u_i^n) = (1-\\nu)u_i^n + \\nu u_{i+1}^n$。\n\n问题陈述了域是周期性的。这意味着对于单元 $i=0$，其“迎风”邻居 $u_{-1}$ 是 $u_{N-1}$。对于单元 $i=N-1$，其“顺风”邻居 $u_N$ 是 $u_0$。\n\n网格加密研究按以下步骤进行。对于每个由 $a$ 和目标 CFL 数 $\\nu_{\\text{target}}$ 定义的测试用例，我们在网格序列 $N \\in \\{50, 100, 200, 400\\}$ 上求解问题。对于每个网格 $N$：\n- 网格间距为 $\\Delta x = L/N$。\n- 最终时间为 $T = L/(2|a|)$。\n- 目标时间步长为 $\\Delta t_{\\text{target}} = \\nu_{\\text{target}} \\Delta x / |a|$。\n- 时间步数必须是整数 $n_{\\text{steps}}$，以使最终时间 $T$ 被精确达到。我们首先计算一个非整数步数 $n_{\\text{float}} = T/\\Delta t_{\\text{target}} = (L/(2|a|)) / (\\nu_{\\text{target}} \\Delta x / |a|) = N/(2\\nu_{\\text{target}})$。然后我们将其四舍五入到最近的整数：$n_{\\text{steps}} = \\text{round}(n_{\\text{float}})$。\n- 实际使用的时间步长为 $\\Delta t = T/n_{\\text{steps}}$。实际的 CFL 数为 $\\nu_{\\text{actual}} = |a|\\Delta t / \\Delta x$，它将接近于 $\\nu_{\\text{target}}$。\n- 应用初始条件：$u_i^0 = \\cos(2\\pi k x_i/L)$。\n- 将解推进 $n_{\\text{steps}}$ 个时间步以达到 $t=T$。\n- 在 $t=T$ 时，计算误差 $e_i = u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i, T)$，其中 $u_{\\text{exact}}(x,t) = \\cos(2\\pi k (x - at)/L)$。\n- 计算离散误差范数 $\\|e\\|_1$, $\\|e\\|_2$ 和 $\\|e\\|_{\\infty}$。\n\n在获得加密序列中每个网格间距 $\\Delta x_j$ 的误差 $E_j$ 后，我们估计收敛阶 $p$。假设误差关系为 $E_j = C (\\Delta x_j)^p$，取对数得到 $\\log(E_j) = p \\log(\\Delta x_j) + \\log(C)$。这是一个线性关系。我们对点集 $(\\log(\\Delta x_j), \\log(E_j))$ 进行线性最小二乘拟合，所得斜率即为观测到的收敛阶 $p$。对每个范数和每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the grid refinement study for all test cases.\n    \"\"\"\n\n    # Test suite specification\n    test_cases = [\n        # Case A: a = 1.0 m/s, nu = 0.5\n        {'a': 1.0, 'nu_target': 0.5, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n        # Case B: a = -1.0 m/s, nu = 0.5\n        {'a': -1.0, 'nu_target': 0.5, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n        # Case C: a = 1.0 m/s, nu = 0.9\n        {'a': 1.0, 'nu_target': 0.9, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n    ]\n    \n    all_results = []\n    for params in test_cases:\n        p1, p2, p_inf = run_convergence_study(**params)\n        all_results.extend([p1, p2, p_inf])\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(f'{r:.8f}' for r in all_results)}]\")\n\ndef run_convergence_study(a, nu_target, N_list, L, k):\n    \"\"\"\n    Performs a grid refinement study for a single test case.\n\n    Args:\n        a (float): Advection speed.\n        nu_target (float): Target CFL number.\n        N_list (list): List of grid resolutions.\n        L (float): Domain length.\n        k (int): Wavenumber of the initial condition.\n\n    Returns:\n        tuple: A tuple containing the observed orders of convergence (p1, p2, p_inf).\n    \"\"\"\n    \n    dx_values = []\n    errors_l1 = []\n    errors_l2 = []\n    errors_linf = []\n\n    for N in N_list:\n        # 1. Setup grid and time parameters\n        dx = L / N\n        dx_values.append(dx)\n        \n        # Cell centers\n        x = (np.arange(N) + 0.5) * dx\n        \n        # Time parameters\n        T_final = L / (2.0 * abs(a))\n        \n        # Adjust dt to hit T_final exactly with an integer number of steps\n        dt_target = nu_target * dx / abs(a)\n        n_steps_float = T_final / dt_target\n        n_steps = int(round(n_steps_float))\n        dt = T_final / n_steps\n        \n        # Calculate actual CFL number based on the adjusted dt\n        nu_actual = abs(a) * dt / dx\n\n        # 2. Initial Condition\n        u = np.cos(2.0 * np.pi * k * x / L)\n        \n        # 3. Time Marching Loop\n        for _ in range(n_steps):\n            if a > 0.0:\n                # Upwind is from the left (i-1)\n                # u_new = (1-nu)*u + nu*u_im1\n                u_im1 = np.roll(u, 1)\n                u = (1.0 - nu_actual) * u + nu_actual * u_im1\n            else: # a  0.0\n                # Upwind is from the right (i+1)\n                # u_new = (1-nu)*u + nu*u_ip1\n                u_ip1 = np.roll(u, -1)\n                u = (1.0 - nu_actual) * u + nu_actual * u_ip1\n\n        # 4. Error Calculation\n        # Exact solution at T_final\n        u_exact = np.cos(2.0 * np.pi * k * (x - a * T_final) / L)\n\n        # Error vector\n        error = u - u_exact\n\n        # Calculate and store norms\n        errors_l1.append(np.sum(np.abs(error)) * dx)\n        errors_l2.append(np.sqrt(np.sum(error**2) * dx))\n        errors_linf.append(np.max(np.abs(error)))\n\n    # 5. Calculate Order of Convergence\n    # Use linear regression on log(error) vs log(dx)\n    # log(E) = p * log(dx) + C, so the slope is the order p.\n    \n    log_dx = np.log(dx_values)\n    \n    log_err_l1 = np.log(errors_l1)\n    p1 = linregress(log_dx, log_err_l1).slope\n    \n    log_err_l2 = np.log(errors_l2)\n    p2 = linregress(log_dx, log_err_l2).slope\n    \n    log_err_linf = np.log(errors_linf)\n    p_inf = linregress(log_dx, log_err_linf).slope\n\n    return p1, p2, p_inf\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3318421"}, {"introduction": "真实世界的流场很少是均匀不变的。这个练习将挑战您将一阶迎风格式应用于一个更复杂的场景：一个空间变化的、甚至会改变方向的对流速度场。您的任务是实现一个稳健的迎风逻辑，并设计诊断工具来验证质量守恒和迎风方向选择的正确性，这对于确保数值解的物理真实性至关重要。[@problem_id:3318437]", "problem": "考虑在周期性域 $[0,1]$ 上带空间变化系数的一维线性守恒律，\n$$\\partial_t u(x,t) + \\partial_x\\big(a(x)\\,u(x,t)\\big) = 0,$$\n其中 $u(x,t)$ 是输运的标量场，$a(x)$ 是一个已知的、不随时间变化的平流速度，其符号可以在空间上改变。目标是为此守恒律实现一个一阶迎风有限体积离散化方法，并构建诊断工具来验证正确的风向选择和输运量的守恒性。\n\n从积分形式的守恒律和一个包含 $N$ 个单元格、宽度为 $\\Delta x = 1/N$ 的均匀网格出发，将单元中心表示为 $x_i \\in [0,1]$（对于 $i=0,\\dots,N-1$），单元面表示为 $x_{i+\\frac{1}{2}}$。使用周期性边界条件。所有测试案例的初始条件均相同：\n$$u(x,0) = 0.1 + 0.6\\,\\exp\\!\\left(-\\frac{(x-0.25)^2}{2\\cdot 0.05^2}\\right) + 0.4\\,\\chi_{[0.6,\\,0.8]}(x),$$\n其中 $\\chi_{[0.6,\\,0.8]}(x)$ 是指示函数，当 $x\\in[0.6,0.8]$ 时其值为 1，否则为 0。所有量均为无量纲。\n\n实现一个与守恒律以及由交界面速度 $a(x_{i+\\frac{1}{2}})$ 的符号确定的风向逻辑相一致的一阶迎风有限体积方法。使用显式时间步进，时间步长 $\\Delta t$ 通过 Courant–Friedrichs–Lewy (CFL) 条件和一个指定的 CFL 数来选择。在计算出 $N_t=\\lceil T/(\\mathrm{CFL}\\,\\Delta x/\\max_{x}|a(x)|)\\rceil$ 后，通过将 $\\Delta t$ 调整为 $T/N_t$ 来选择时间步数，以确保恰好在最终时间 $T$ 结束。对通量差分使用周期性索引。不要引入任何源项。\n\n定义以下诊断量，需在整个运行期间直到最终时间 $T$ 进行计算：\n- 风向违反计数：用于构成数值通量的一侧与 $a(x_{i+\\frac{1}{2}})$ 的符号不一致的交界面和时间步的整数计数，不包括 $|a(x_{i+\\frac{1}{2}})| \\le 10^{-12}$ 或相邻单元状态在 $10^{-12}$ 容差内相等的情况。\n- 质量相对误差：浮点数 $(M(T)-M(0))/M(0)$，其中 $M(t) = \\sum_i u_i(t)\\,\\Delta x$ 是在时间 $t$ 的离散总质量。\n- 观测到的最大 CFL：在所有时间步和交界面上的浮点数 $\\max_{n,i} \\big(|a(x_{i+\\frac{1}{2}})|\\,\\Delta t/\\Delta x\\big)$。\n- 总变差变化量：浮点数 $\\mathrm{TV}(u(T)) - \\mathrm{TV}(u(0))$，其中 $\\mathrm{TV}(u) = \\sum_{i} |u_{i+1}-u_i|$ 并采用周期性环绕。\n\n你的程序必须实现该格式并为以下参数值的测试套件计算这些诊断量：\n- 测试案例 A（具有非负速度和零速区域的理想路径）：$a(x) = 0.5 + 0.5\\sin(2\\pi x)$，$N = 200$，$T = 0.25$，$\\mathrm{CFL} = 0.9$。\n- 测试案例 B（速度符号多次反转）：$a(x) = \\sin(4\\pi x)$，$N = 256$，$T = 0.20$，$\\mathrm{CFL} = 0.9$。\n- 测试案例 C（严格负常数速度）：$a(x) = -1$，$N = 128$，$T = 0.10$，$\\mathrm{CFL} = 0.9$。\n\n所有量都是无量纲的，因此不需要物理单位。三角函数中出现的角度，单位为弧度。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。对于每个测试案例，输出列表 $[\\text{wrong\\_direction\\_count},\\text{mass\\_relative\\_error},\\text{max\\_cfl},\\text{tv\\_change}]$，并将三个测试案例的结果汇总到一个顶层列表中，例如：\n$$\\big[[\\text{A1},\\text{A2},\\text{A3},\\text{A4}],[\\text{B1},\\text{B2},\\text{B3},\\text{B4}],[\\text{C1},\\text{C2},\\text{C3},\\text{C4}]\\big],$$\n输出为精确的单行，逗号后没有空格，数值采用标准十进制表示法。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它具有科学依据，问题定义明确且完整。我们现在开始提供详细的解决方案。\n\n该问题要求为具有空间变化平流速度 $a(x)$ 的一维线性守恒定律实现一个一阶迎风有限体积格式：\n$$ \\partial_t u(x,t) + \\partial_x\\big(a(x)\\,u(x,t)\\big) = 0 $$\n域是周期性的，$x \\in [0,1]$。\n\n**1. 有限体积离散化**\n有限体积法源于守恒定律的积分形式。将偏微分方程在一个控制体积（一个单元）$[x_{i-1/2}, x_{i+1/2}]$ 上积分，得到：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_t u(x,t) \\,dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_x\\big(a(x)u(x,t)\\big) \\,dx = 0 $$\n假设网格不随时间移动，并应用微积分基本定理，这变为：\n$$ \\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + \\big[a(x)u(x,t)\\big]_{x_{i-1/2}}^{x_{i+1/2}} = 0 $$\n我们将宽度为 $\\Delta x = 1/N$ 的单元上的单元平均量 $u_i(t)$ 定义为：\n$$ u_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx $$\n单元平均值 $u_i$ 的演化方程则近似为：\n$$ \\frac{d u_i}{dt} + \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) = 0 $$\n此处，$F_{i+1/2}$ 和 $F_{i-1/2}$ 分别是右侧和左侧单元交界面上的数值通量。这些通量近似于单元边界处的瞬时通量 $a(x)u(x,t)$。\n\n**2. 一阶迎风通量**\n一阶迎风格式根据信息流动的方向确定数值通量，该方向由单元交界面处平流速度 $a(x)$ 的符号给出。在单元 $i$ 和单元 $i+1$ 之间的交界面 $x_{i+1/2}$ 处的通量，是使用来自“迎风”方向的单元平均值构建的。\n\n- 如果交界面处的平流速度为非负，$a(x_{i+1/2}) \\ge 0$，则信息从左向右流动。迎风单元是单元 $i$。通量使用 $u_i$ 构建：\n  $$ F_{i+1/2} = a(x_{i+1/2}) u_i $$\n- 如果平流速度为负，$a(x_{i+1/2})  0$，则信息从右向左流动。迎风单元是单元 $i+1$。通量使用 $u_{i+1}$ 构建：\n  $$ F_{i+1/2} = a(x_{i+1/2}) u_{i+1} $$\n\n这个逻辑可以用一个单一的公式表示：\n$$ F_{i+1/2} = \\begin{cases} a(x_{i+1/2}) u_i  \\text{若 } a(x_{i+1/2}) \\ge 0 \\\\ a(x_{i+1/2}) u_{i+1}  \\text{若 } a(x_{i+1/2})  0 \\end{cases} $$\n\n**3. 时间离散化与稳定性**\n使用前向欧拉法（一种显式一阶格式）对常微分方程的半离散系统进行时间积分：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = - \\frac{1}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) $$\n可将其重新排列，得到时间步 $n+1$ 处状态的更新公式：\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) $$\n其中 $F^n$ 表示使用状态 $u^n$ 计算的通量。此显式格式的稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定，该条件要求数值依赖域必须包含物理依赖域。对于此格式，该条件为 $\\max_i (|a(x_{i\\pm1/2})| \\frac{\\Delta t}{\\Delta x}) \\le 1$。\n\n问题指定了一个固定的 CFL 数 $\\mathrm{CFL}$ 来确定时间步长 $\\Delta t$。首先，根据整个连续域上的最大可能速度 $\\max_x |a(x)|$ 计算一个临时时间步长：\n$$ \\Delta t_{\\mathrm{CFL}} = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_{x \\in [0,1]} |a(x)|} $$\n为确保模拟恰好在时间 $T$ 结束，通过向上取整计算时间步数 $N_t$：\n$$ N_t = \\left\\lceil \\frac{T}{\\Delta t_{\\mathrm{CFL}}} \\right\\rceil $$\n那么，用于模拟的最终调整后的时间步长为：\n$$ \\Delta t = \\frac{T}{N_t} $$\n\n**4. 网格、初始条件和边界条件**\n使用包含 $N$ 个单元的均匀网格，因此 $\\Delta x = 1/N$。单元中心位于 $x_i = (i+0.5)\\Delta x$（对于 $i=0, \\dots, N-1$）。单元交界面位于 $x_{i+1/2} = (i+1)\\Delta x$（对于 $i=0, \\dots, N-1$）。\n初始离散状态 $u_i^0$ 是通过在单元中心 $x_i$ 处评估给定的连续初始条件 $u(x,0)$ 得到的：\n$$ u_i^0 = u(x_i, 0) = 0.1 + 0.6\\,\\exp\\!\\left(-\\frac{(x_i-0.25)^2}{2\\cdot 0.05^2}\\right) + 0.4\\,\\chi_{[0.6,\\,0.8]}(x_i) $$\n强制施加周期性边界条件，这意味着域是环绕的。对于任何索引 $i$，对单元 $i-1$ 或 $i+1$ 的访问都是以 $N$ 为模进行的。例如，单元 $N-1$ 的右邻居是单元 $0$，而单元 $0$ 的左邻居是单元 $N-1$。这确保了在 $x=1$ 处离开域的通量会在 $x=0$ 处重新进入。\n\n**5. 诊断指标**\n计算以下诊断量以评估格式的性能：\n- **风向违反计数**：这是一个整数计数器，当任何交界面和时间步中，实现的通量逻辑偏离第 2 节中描述的迎风原理时，该计数器就会递增。对于正确的实现，此计数将为 $0$。如果交界面速度 $|a(x_{i+1/2})|$ 低于 $10^{-12}$ 的容差，或者相邻单元状态在 $10^{-12}$ 的容差内相等，则跳过此检查。\n- **质量相对误差**：总离散质量为 $M(t) = \\sum_{i=0}^{N-1} u_i(t)\\,\\Delta x$。守恒律的有限体积格式的一个关键特性是质量的离散守恒。在周期性边界条件下，通量差分之和伸缩为零，即 $\\sum_i u_i^{n+1} = \\sum_i u_i^n$。因此，总质量应在浮点精度范围内守恒。相对误差 $(M(T)-M(0))/M(0)$ 用于衡量任何偏差。\n- **观测到的最大 CFL**：这是在整个模拟过程中所有交界面上的局部 CFL 数 $\\sigma_{i+1/2} = |a(x_{i+1/2})|\\,\\Delta t/\\Delta x$ 的最大值。由于 $\\Delta t$ 和 $\\Delta x$ 是常数，这可以简化为 $\\frac{\\Delta t}{\\Delta x} \\max_{i} |a(x_{i+1/2})|$。\n- **总变差变化量**：离散解的总变差 (TV) 为 $\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} |u_{(i+1)\\pmod N}-u_i|$。对于 $\\mathrm{CFL} \\le 1$，一阶迎风格式是总变差递减 (TVD) 的，即 $\\mathrm{TV}(u^{n+1}) \\le \\mathrm{TV}(u^n)$。诊断量是总变化 $\\mathrm{TV}(u(T)) - \\mathrm{TV}(u(0))$，其值应为非正数。\n\n实现过程是为每个测试案例设置网格和初始条件，计算时间步长，然后迭代时间步进循环 $N_t$ 步。在每一步中，计算通量，更新诊断信息，并推进解。最后，计算并收集四个诊断指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Non-negative speed with zero-speed regions\n        {\"a_func\": lambda x: 0.5 + 0.5 * np.sin(2 * np.pi * x), \"N\": 200, \"T\": 0.25, \"CFL\": 0.9, \"a_max_cont\": 1.0},\n        # Case B: Sign-changing speed\n        {\"a_func\": lambda x: np.sin(4 * np.pi * x), \"N\": 256, \"T\": 0.20, \"CFL\": 0.9, \"a_max_cont\": 1.0},\n        # Case C: Strictly negative constant speed\n        {\"a_func\": lambda x: -1.0 + 0.0 * x, \"N\": 128, \"T\": 0.10, \"CFL\": 0.9, \"a_max_cont\": 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = solve_case(case[\"a_func\"], case[\"N\"], case[\"T\"], case[\"CFL\"], case[\"a_max_cont\"])\n        results.append(res)\n    \n    # Format the final output as specified\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_case(a_func, N, T, CFL_target, a_max_cont):\n    \"\"\"\n    Implements the first-order upwind finite-volume method for a single test case.\n\n    Args:\n        a_func (callable): The advection speed function a(x).\n        N (int): Number of grid cells.\n        T (float): Final simulation time.\n        CFL_target (float): The target CFL number for time step calculation.\n        a_max_cont (float): The maximum of |a(x)| over the continuous domain.\n\n    Returns:\n        list: A list containing the four computed diagnostics.\n    \"\"\"\n    # 1. Grid Setup\n    dx = 1.0 / N\n    x_centers = (np.arange(N) + 0.5) * dx\n    x_faces = (np.arange(N) + 1.0) * dx\n\n    # 2. Initial Condition\n    def chi(x, a, b):\n        return np.where((x >= a)  (x = b), 1.0, 0.0)\n    \n    u0 = 0.1 + 0.6 * np.exp(-(x_centers - 0.25)**2 / (2 * 0.05**2)) + 0.4 * chi(x_centers, 0.6, 0.8)\n    u = u0.copy()\n\n    # 3. Time Stepping\n    dt_cfl = CFL_target * dx / a_max_cont\n    Nt = int(np.ceil(T / dt_cfl))\n    dt = T / Nt\n\n    # 4. Diagnostics Initialization\n    wind_direction_violation_count = 0\n    mass_initial = np.sum(u0) * dx\n    \n    def total_variation(v):\n        return np.sum(np.abs(np.roll(v, -1) - v))\n        \n    tv_initial = total_variation(u0)\n    \n    a_faces = a_func(x_faces)\n    max_cfl_observed = np.max(np.abs(a_faces)) * dt / dx\n\n    # Tolerances from problem statement\n    tol_a = 1e-12\n    tol_u = 1e-12\n    \n    # 5. Main Time-Stepping Loop\n    for _ in range(Nt):\n        u_n = u.copy()\n        \n        # Determine upwind states at each interface\n        # u_left corresponds to u_i, u_right corresponds to u_{i+1}\n        u_left = u_n\n        u_right = np.roll(u_n, -1)\n        \n        # Calculate numerical fluxes using first-order upwind scheme\n        # F_{i+1/2} = a_{i+1/2} * u_upwind\n        fluxes = np.where(a_faces >= 0, a_faces * u_left, a_faces * u_right)\n\n        # Diagnostic: Wind-direction violation count\n        # This check verifies that the vectorized implementation (np.where)\n        # is consistent with the definitional if/else logic of upwinding.\n        # For a correct implementation, the count will be 0.\n        indices_to_check = np.where((np.abs(a_faces) > tol_a)  (np.abs(u_left - u_right) > tol_u))[0]\n        if len(indices_to_check) > 0:\n            for i in indices_to_check:\n                if a_faces[i] >= 0:\n                    correct_flux = a_faces[i] * u_left[i]\n                else:\n                    correct_flux = a_faces[i] * u_right[i]\n                \n                if not np.isclose(fluxes[i], correct_flux, rtol=1e-15, atol=1e-15):\n                     wind_direction_violation_count += 1\n\n        # Update solution using finite volume formula\n        # u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        flux_right_of_cell = fluxes\n        flux_left_of_cell = np.roll(fluxes, 1) # Fluxes are at interfaces i+1/2\n        \n        u = u_n - (dt / dx) * (flux_right_of_cell - flux_left_of_cell)\n\n    # 6. Final Diagnostics Calculation\n    mass_final = np.sum(u) * dx\n    if np.abs(mass_initial)  1e-15:\n        # Avoid division by zero if initial mass is zero\n        mass_relative_error = 0.0 if np.isclose(mass_final, mass_initial) else np.inf\n    else:\n        mass_relative_error = (mass_final - mass_initial) / mass_initial\n        \n    tv_final = total_variation(u)\n    tv_change = tv_final - tv_initial\n\n    return [wind_direction_violation_count, mass_relative_error, max_cfl_observed, tv_change]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3318437"}, {"introduction": "虽然一阶迎风格式很稳健，但它有一个固有的缺陷，在多维问题中尤其明显。本练习旨在揭示这一局限性：当流动方向与网格轴线不一致时，会产生被称为“伪扩散”的数值误差。通过在二维空间中模拟一个斜向流动的标量场，您将量化这种各向异性的数值扩散，从而深刻理解为什么在许多实际应用中需要更高阶的格式。[@problem_id:3318407]", "problem": "考虑二维空间中的线性常系数平流方程，\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\boldsymbol{a} \\cdot \\nabla \\phi = 0,\n$$\n其中 $\\phi(x,y,t)$ 是一个被动标量，$\\boldsymbol{a} = (a_x,a_y)$ 是一个恒定的平流速度。计算域为无量纲单位下的周期性单位正方形 $[0,1]\\times[0,1]$，该区域被一个由 $N_x \\times N_y$ 个网格单元组成的均匀笛卡尔网格离散化，网格尺寸为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。\n\n从平流的守恒形式和迎风数值通量的定义出发，推导在该网格上针对恒定 $\\boldsymbol{a}$ 的一阶迎风（施主单元）半离散空间离散格式。然后，选择一个时间步长为 $\\Delta t$ 的单步显式前向欧拉时间积分方法，该方法需满足一个合适的 Courant–Friedrichs–Lewy (CFL) 稳定性要求。该格式必须使用周期性边界条件。\n\n您将创建一个二维斜风平流测试，以测量伪扩散，并报告相对于 $\\boldsymbol{a}$ 与网格轴之间夹角的方向性平滑。使用以下数学上指定的设置：\n\n- 在时间 $t=0$ 时的初始条件是一个光滑、局域化的高斯凸起，其中心位于 $(x_0,y_0)$，\n$$\n\\phi(x,y,0) = \\exp\\left( - \\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2} \\right),\n$$\n其中 $x_0=0.25$，$y_0=0.25$，$\\sigma=0.05$（均为无量纲单位）。\n\n- 对于指定的角度 $\\theta$（以弧度为单位），速度为 $\\boldsymbol{a} = (\\cos\\theta,\\sin\\theta)$。其大小 $\\|\\boldsymbol{a}\\|$ 为 $1$。\n\n- 取 $N_x = N_y = 256$，$\\Delta t = 0.2\\,\\Delta x$，并使用显式前向欧拉方法积分至最终时间 $T=0.1$。实际积分时间 $T_{\\text{actual}}$ 应为整数步数与 $\\Delta t$ 的乘积。在所有边界上使用周期性边界条件。\n\n为了量化伪扩散和方向性平滑，计算 $\\phi$ 相对于其质量加权质心的二阶中心矩，并将它们投影到平行和垂直于 $\\boldsymbol{a}$ 的方向上：\n\n1. 计算质量 $M = \\int_{0}^{1}\\int_{0}^{1} \\phi(x,y,t)\\,\\mathrm{d}x\\,\\mathrm{d}y$、质心 $(\\bar{x}(t),\\bar{y}(t))$ 和协方差矩阵\n$$\n\\mathbf{C}(t) = \\frac{1}{M}\\int_{0}^{1}\\int_{0}^{1} \n\\begin{bmatrix}\nx-\\bar{x}(t)\\\\\ny-\\bar{y}(t)\n\\end{bmatrix}\n\\begin{bmatrix}\nx-\\bar{x}(t)  y-\\bar{y}(t)\n\\end{bmatrix}\n\\phi(x,y,t)\\,\\mathrm{d}x\\,\\mathrm{d}y.\n$$\n2. 设沿流动方向和与流动方向正交的单位向量分别为 $\\hat{\\boldsymbol{s}} = \\boldsymbol{a}/\\|\\boldsymbol{a}\\|$ 和 $\\hat{\\boldsymbol{n}} = (-\\hat{s}_y,\\hat{s}_x)$。定义沿这些方向的方差为 $v_s(t) = \\hat{\\boldsymbol{s}}^\\top \\mathbf{C}(t)\\,\\hat{\\boldsymbol{s}}$ 和 $v_n(t) = \\hat{\\boldsymbol{n}}^\\top \\mathbf{C}(t)\\,\\hat{\\boldsymbol{n}}$。\n3. 通过以下公式估算有效方向数值扩散系数\n$$\nD_{\\text{eff},s} = \\frac{v_s(T_{\\text{actual}}) - v_s(0)}{2\\,T_{\\text{actual}}}, \\quad\nD_{\\text{eff},n} = \\frac{v_n(T_{\\text{actual}}) - v_n(0)}{2\\,T_{\\text{actual}}},\n$$\n并报告方向性平滑比 $R = D_{\\text{eff},n}/D_{\\text{eff},s}$。\n\n所有量均为无量纲量，并应以与单位长度域和单位速度大小一致的无量纲单位进行报告。输出中的角度必须以度为单位指定。\n\n测试套件：\n对以下角度 $\\theta$（此处以度为单位提供，需在内部转换为弧度）进行上述评估：$0$、$5$、$22.5$、$45$、$67.5$、$90$。这些角度涵盖了轴对齐流、近轴斜流和对角流。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个包含四个浮点数的列表：$[\\theta_{\\text{deg}}, D_{\\text{eff},s}, D_{\\text{eff},n}, R]$。\n例如，输出格式必须是\n$$\n[\\,[\\theta_1,D_{\\text{eff},s,1},D_{\\text{eff},n,1},R_1],\\,[\\theta_2,D_{\\text{eff},s,2},D_{\\text{eff},n,2},R_2],\\,\\dots\\,]\n$$\n其中符号位置为数值。不应打印任何额外文本。", "solution": "该问题是有效的。它提出了一个来自计算流体力学的标准的、适定的初边值问题，提供了所有必要的参数和清晰的分析目标。其底层的物理和数学原理是合理的，所用数值方法是经典的。\n\n### 一阶迎风半离散格式的推导\n\n我们从二维线性平流方程的守恒形式开始：\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot (\\boldsymbol{a}\\phi) = 0\n$$\n其中 $\\boldsymbol{a}=(a_x, a_y)$ 是一个恒定的速度矢量。我们对此方程在一个面积为 $\\Delta x \\Delta y$ 的计算单元 $\\Omega_{i,j} = [x_{i-1/2}, x_{i+1/2}] \\times [y_{j-1/2}, y_{j+1/2}]$ 上进行积分。应用散度定理，我们得到积分形式：\n$$\n\\frac{d}{dt} \\iint_{\\Omega_{i,j}} \\phi \\,dx\\,dy + \\oint_{\\partial\\Omega_{i,j}} (\\phi\\boldsymbol{a}) \\cdot \\hat{\\boldsymbol{n}} \\,ds = 0\n$$\n设 $\\phi_{i,j}(t)$ 为标量的单元平均值，即 $\\phi_{i,j}(t) = \\frac{1}{\\Delta x \\Delta y} \\iint_{\\Omega_{i,j}} \\phi \\,dx\\,dy$。该积分的时间导数近似为 $\\Delta x \\Delta y \\frac{d\\phi_{i,j}}{dt}$。边界积分（通量项）是穿过单元四个面（东、西、南、北）的通量之和：\n$$\n\\oint_{\\partial\\Omega_{i,j}} (\\phi\\boldsymbol{a}) \\cdot \\hat{\\boldsymbol{n}} \\,ds = (F_e - F_w) + (F_n - F_s)\n$$\n其中通量定义在单元面上。例如，通过东面 $x_{i+1/2}$ 的通量为 $F_e = \\int_{y_{j-1/2}}^{y_{j+1/2}} \\phi(x_{i+1/2}, y) a_x \\,dy$。我们将其近似为 $F_e \\approx (\\phi_{i+1/2,j} a_x) \\Delta y$，其中 $\\phi_{i+1/2,j}$ 是 $\\phi$ 在该面上的值。对其他面也做类似的近似：$F_w \\approx (\\phi_{i-1/2,j} a_x) \\Delta y$，$F_n \\approx (\\phi_{i,j+1/2} a_y) \\Delta x$ 和 $F_s \\approx (\\phi_{i,j-1/2} a_y) \\Delta x$。\n\n一阶迎风（或施主单元）格式将单元面上的值定义为来自“迎风”或“施主”单元的值，即流动起源的那个单元。\n对于 $x_{i+1/2}$ 处的面，值 $\\phi_{i+1/2,j}$ 由 $a_x$ 的符号决定：\n$$\n\\phi_{i+1/2,j} = \\begin{cases} \\phi_{i,j}  \\text{若 } a_x > 0 \\\\ \\phi_{i+1,j}  \\text{若 } a_x  0 \\end{cases}\n$$\n此逻辑应用于所有面。一种方便的表达方式是，将速度分量分解为正部和负部：$a_x = a_x^+ + a_x^-$，其中 $a_x^+ = \\max(a_x, 0)$ 且 $a_x^- = \\min(a_x, 0)$。x方向的净通量 $F_e - F_w$ 变为：\n$$\nF_e - F_w \\approx \\left[ (a_x^+ \\phi_{i,j} + a_x^- \\phi_{i+1,j}) - (a_x^+ \\phi_{i-1,j} + a_x^- \\phi_{i,j}) \\right] \\Delta y\n$$\ny方向的净通量也存在类似的表达式。将这些代入离散化的守恒定律，并除以单元面积 $\\Delta x \\Delta y$，我们便得到关于单元平均值 $\\phi_{i,j}$ 的半离散方程：\n$$\n\\frac{d\\phi_{i,j}}{dt} = - \\left[ \\frac{a_x^+(\\phi_{i,j} - \\phi_{i-1,j}) + a_x^-(\\phi_{i+1,j} - \\phi_{i,j})}{\\Delta x} + \\frac{a_y^+(\\phi_{i,j} - \\phi_{i,j-1}) + a_y^-(\\phi_{i,j+1} - \\phi_{i,j})}{\\Delta y} \\right]\n$$\n\n### 使用前向欧拉的全离散格式\n\n为获得全离散格式，我们使用一阶显式前向欧拉方法来离散化时间导数：$\\frac{d\\phi_{i,j}}{dt} \\approx \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t}$，其中上标 $n$ 表示时间层 $t^n = n\\Delta t$。\n这就得到了更新公式：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\frac{\\Delta t}{\\Delta x} \\left[ a_x^+(\\phi_{i,j}^n - \\phi_{i-1,j}^n) + a_x^-(\\phi_{i+1,j}^n - \\phi_{i,j}^n) \\right] - \\frac{\\Delta t}{\\Delta y} \\left[ a_y^+(\\phi_{i,j}^n - \\phi_{i,j-1}^n) + a_y^-(\\phi_{i,j+1}^n - \\phi_{i,j}^n) \\right]\n$$\n该格式在 Courant–Friedrichs–Lewy (CFL) 条件 $|a_x|\\frac{\\Delta t}{\\Delta x} + |a_y|\\frac{\\Delta t}{\\Delta y} \\le 1$ 下是稳定的。问题指定 $\\Delta x = \\Delta y = 1/256$，$\\Delta t = 0.2 \\Delta x$，且 $\\|\\boldsymbol{a}\\|=1$。Courant 数之和为 $C_x+C_y = \\frac{\\Delta t}{\\Delta x}(|a_x| + |a_y|) = 0.2(|\\cos\\theta| + |\\sin\\theta|)$。$|\\cos\\theta| + |\\sin\\theta|$ 的最大值为 $\\sqrt{2}$，因此最大 CFL 数为 $0.2\\sqrt{2} \\approx 0.283  1$，确保了稳定性。\n\n### 数值扩散分析\n\n该分析通过测量标量场的空间方差的变化来量化格式中固有的数值扩散。所需的量是从网格上的离散解 $\\phi_{i,j}$ 中数值计算得出的。我们使用单元中心坐标 $x_i = (i+0.5)\\Delta x$ 和 $y_j = (j+0.5)\\Delta y$。\n\n1.  **质量和质心**：积分通过对所有单元求和来近似。总质量为 $M \\approx \\sum_{i,j} \\phi_{i,j} \\Delta x \\Delta y$。质心分量为 $\\bar{x} \\approx \\frac{1}{M} \\sum_{i,j} x_i \\phi_{i,j} \\Delta x \\Delta y$ 和 $\\bar{y} \\approx \\frac{1}{M} \\sum_{i,j} y_j \\phi_{i,j} \\Delta x \\Delta y$。由于传播距离相对于域的大小很小，因此质心计算无需进行周期性校正。\n\n2.  **协方差矩阵**：协方差矩阵 $\\mathbf{C}$ 的分量也通过求和计算：\n    $$\n    C_{xx} \\approx \\frac{1}{M} \\sum_{i,j} (x_i - \\bar{x})^2 \\phi_{i,j} \\Delta x \\Delta y = \\frac{\\sum_{i,j} (x_i - \\bar{x})^2 \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}} \\\\\n    C_{yy} \\approx \\frac{\\sum_{i,j} (y_j - \\bar{y})^2 \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}} \\\\\n    C_{xy} \\approx \\frac{\\sum_{i,j} (x_i - \\bar{x})(y_j - \\bar{y}) \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}}\n    $$\n\n3.  **方向方差**：计算出 $\\mathbf{C}$ 后，通过投影找到平行于（$v_s$）和垂直于（$v_n$）流动方向 $\\hat{\\boldsymbol{s}} = \\boldsymbol{a}/\\|\\boldsymbol{a}\\|=(\\cos\\theta, \\sin\\theta)$ 的方差：\n    $$\n    v_s = \\hat{\\boldsymbol{s}}^\\top \\mathbf{C}\\,\\hat{\\boldsymbol{s}} = C_{xx} \\cos^2\\theta + C_{yy} \\sin^2\\theta + 2 C_{xy} \\sin\\theta \\cos\\theta \\\\\n    v_n = \\hat{\\boldsymbol{n}}^\\top \\mathbf{C}\\,\\hat{\\boldsymbol{n}} = C_{xx} \\sin^2\\theta + C_{yy} \\cos^2\\theta - 2 C_{xy} \\sin\\theta \\cos\\theta\n    $$\n    其中 $\\hat{\\boldsymbol{n}} = (-\\sin\\theta, \\cos\\theta)$。\n\n4.  **有效扩散**：通过观察这些方差在模拟时间 $T_{\\text{actual}}$ 内的增长来估算有效数值扩散系数：\n    $$\n    D_{\\text{eff},s} = \\frac{v_s(T_{\\text{actual}}) - v_s(0)}{2\\,T_{\\text{actual}}}, \\quad\n    D_{\\text{eff},n} = \\frac{v_n(T_{\\text{actual}}) - v_n(0)}{2\\,T_{\\text{actual}}}\n    $$\n    这些系数是针对初始状态（$t=0$）和最终状态（$t=T_{\\text{actual}}$）计算的。为保持一致性，初始方差 $v_s(0)$ 和 $v_n(0)$ 是从离散化的初始条件计算的，而不是从完美高斯分布的解析公式计算，以便仅分离出由数值格式本身引起的变化。比率 $R = D_{\\text{eff},n}/D_{\\text{eff},s}$ 量化了数值误差的各向异性，当误差作用于垂直于流动的方向时，通常被称为“伪扩散”。\n\n### 计算实现\n\n对每个指定的角度 $\\theta$ 执行模拟。对于每种情况，都会生成网格和初始高斯剖面。求解器的核心是一个时间循环，该循环迭代地应用全离散迎风公式。周期性边界条件通过数组移位操作（例如 `numpy.roll`）得到高效处理。在最后一个时间步之后，调用分析程序处理初始和最终的标量场，以计算方差、有效扩散系数及其比率。然后将结果整理并以指定的格式打印出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D advection equation using a first-order upwind scheme\n    and analyzes the numerical diffusion for various flow angles.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        5.0,\n        22.5,\n        45.0,\n        67.5,\n        90.0,\n    ]\n\n    # Simulation parameters\n    Nx = 256\n    Ny = 256\n    x0 = 0.25\n    y0 = 0.25\n    sigma = 0.05\n    domain_size = 1.0\n    T_final = 0.1\n\n    dx = domain_size / Nx\n    dy = domain_size / Ny\n    dt = 0.2 * dx\n    \n    # Create grid\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    X, Y = np.meshgrid(x_coords, y_coords)\n\n    def calculate_analysis(phi, X_grid, Y_grid, s_hat, n_hat):\n        \"\"\"\n        Calculates mass, centroid, covariance matrix, and directional variances.\n        \"\"\"\n        # Mass calculation (dx*dy cancels out in ratios, so can be omitted)\n        mass = np.sum(phi)\n        if mass == 0:\n            return 0, 0, 0 # Should not happen with a Gaussian\n\n        # Centroid calculation\n        # The bump does not wrap around, so simple weighted average is fine.\n        x_bar = np.sum(X_grid * phi) / mass\n        y_bar = np.sum(Y_grid * phi) / mass\n\n        # Distances from centroid\n        dx_bar = X_grid - x_bar\n        dy_bar = Y_grid - y_bar\n        \n        # Covariance matrix components\n        C_xx = np.sum(dx_bar**2 * phi) / mass\n        C_yy = np.sum(dy_bar**2 * phi) / mass\n        C_xy = np.sum(dx_bar * dy_bar * phi) / mass\n\n        # Directional variances\n        s_x, s_y = s_hat\n        n_x, n_y = n_hat\n\n        v_s = C_xx * s_x**2 + C_yy * s_y**2 + 2 * C_xy * s_x * s_y\n        v_n = C_xx * n_x**2 + C_yy * n_y**2 + 2 * C_xy * n_x * n_y\n        \n        return v_s, v_n\n\n    results = []\n    \n    for theta_deg in test_cases:\n        theta_rad = np.radians(theta_deg)\n        \n        # Velocity vector and its positive/negative parts\n        ax = np.cos(theta_rad)\n        ay = np.sin(theta_rad)\n        ax_pos = max(ax, 0)\n        ax_neg = min(ax, 0)\n        ay_pos = max(ay, 0)\n        ay_neg = min(ay, 0)\n\n        # Projection vectors\n        s_hat = np.array([ax, ay])\n        n_hat = np.array([-ay, ax])\n        \n        # Initial condition\n        phi0 = np.exp(-((X - x0)**2 + (Y - y0)**2) / (2 * sigma**2))\n\n        # Analysis of initial condition\n        v_s0, v_n0 = calculate_analysis(phi0, X, Y, s_hat, n_hat)\n\n        # Time stepping\n        phi = phi0.copy()\n        num_steps = int(np.floor(T_final / dt))\n        T_actual = num_steps * dt\n\n        for _ in range(num_steps):\n            # Periodic BCs using numpy.roll\n            phi_im1 = np.roll(phi, 1, axis=1) # phi at i-1\n            phi_ip1 = np.roll(phi, -1, axis=1) # phi at i+1\n            phi_jm1 = np.roll(phi, 1, axis=0) # phi at j-1\n            phi_jp1 = np.roll(phi, -1, axis=0) # phi at j+1\n            \n            # Spatial derivative term (upwind)\n            dphi_dx_term = (ax_pos * (phi - phi_im1) + ax_neg * (phi_ip1 - phi)) / dx\n            dphi_dy_term = (ay_pos * (phi - phi_jm1) + ay_neg * (phi_jp1 - phi)) / dy\n\n            # Forward Euler update\n            phi -= dt * (dphi_dx_term + dphi_dy_term)\n\n        # Analysis of final condition\n        v_sT, v_nT = calculate_analysis(phi, X, Y, s_hat, n_hat)\n        \n        # Effective diffusion coefficients\n        if T_actual > 0:\n            D_eff_s = (v_sT - v_s0) / (2 * T_actual)\n            D_eff_n = (v_nT - v_n0) / (2 * T_actual)\n        else:\n            D_eff_s = 0.0\n            D_eff_n = 0.0\n\n        # Smoothing ratio\n        # Avoid division by zero, although D_eff_s should be positive.\n        if D_eff_s != 0:\n            R = D_eff_n / D_eff_s\n        else:\n            # If stream-wise diffusion is zero, but cross-stream is not, ratio is infinite.\n            # If both are zero, ratio is undefined, we can set it to 0 or 1. \n            # In this problem, D_eff_s > 0 is expected for T>0.\n            R = np.inf if D_eff_n != 0 else 0.0\n            \n        results.append([theta_deg, D_eff_s, D_eff_n, R])\n\n    # Final print statement in the exact required format.\n    case_strings = [f\"[{c[0]},{c[1]},{c[2]},{c[3]}]\" for c in results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3318407"}]}