{"hands_on_practices": [{"introduction": "高分辨率格式虽然能够提供更高的精度，但在求解像欧拉方程这样具有强间断的复杂问题时，可能会产生非物理的解，例如负密度或负压力。本练习将指导您通过一种称为凸组合通量限制器的技术，来设计一个保证正性的更新格式。通过混合一个高阶通量和一个保证正性的低阶通量，您可以推导出确保物理约束得以满足的条件，这是开发稳健的流体动力学求解器的关键一步[@problem_id:3320306]。", "problem": "考虑守恒变量$U = (\\rho, m, E)^{\\top}$下的一维可压缩欧拉方程，其中$\\rho$是密度，$m = \\rho u$是动量（$u$为速度），$E$是总能量。压力$p$由理想气体关系式$p = (\\gamma - 1)\\left(E - \\frac{m^{2}}{2 \\rho}\\right)$给出，其中比热比$\\gamma  1$。在间距为$\\Delta x$的均匀网格上，使用形式为如下的通量更新，以时间步长$\\Delta t$进行有限体积离散化的时间推进：\n$$\nU_{i}^{n+1} \\;=\\; U_{i}^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中$F_{i\\pm\\frac{1}{2}}$是单元界面处的数值通量。为了构造密度和压力的保正性高分辨率更新，考虑一个凸通量限制器，它将高阶通量与低阶通量混合如下：\n$$\nF_{i\\pm\\frac{1}{2}}(\\theta) \\;=\\; \\theta\\,F_{i\\pm\\frac{1}{2}}^{\\mathrm{HO}} \\;+\\; (1-\\theta)\\,F_{i\\pm\\frac{1}{2}}^{\\mathrm{LO}},\n$$\n其中系数$\\theta \\in [0,1]$。记净通量差为：\n$$\n\\Delta F^{\\mathrm{HO}} \\;=\\; F_{i+\\frac{1}{2}}^{\\mathrm{HO}} - F_{i-\\frac{1}{2}}^{\\mathrm{HO}}, \\qquad\n\\Delta F^{\\mathrm{LO}} \\;=\\; F_{i+\\frac{1}{2}}^{\\mathrm{LO}} - F_{i-\\frac{1}{2}}^{\\mathrm{LO}},\n$$\n这样单元$i$中的更新可以写为：\n$$\nU_{i}^{n+1}(\\theta) \\;=\\; U_{i}^{n} \\;-\\; \\lambda\\left(\\theta\\,\\Delta F^{\\mathrm{HO}} + (1-\\theta)\\,\\Delta F^{\\mathrm{LO}}\\right),\n\\qquad \\lambda \\;=\\; \\frac{\\Delta t}{\\Delta x}.\n$$\n假设$\\gamma = 1.4$，$\\lambda = 0.1$，且初始状态为：\n$$\nU_{i}^{n} \\;=\\; \\begin{pmatrix} \\rho_{i}^{n} \\\\ m_{i}^{n} \\\\ E_{i}^{n} \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix}.\n$$\n假设高阶净通量差和低阶净通量差分别为：\n$$\n\\Delta F^{\\mathrm{HO}} \\;=\\; \\begin{pmatrix} 0.8 \\\\ -3.0 \\\\ 18.0 \\end{pmatrix},\n\\qquad\n\\Delta F^{\\mathrm{LO}} \\;=\\; \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix},\n$$\n并进一步假设低阶通量是保证正性的，即当$\\theta = 0$时，更新得到的密度和压力为非负。根据控制更新方程和压力的定义，推导为保证$\\rho_{i}^{n+1}(\\theta) \\ge 0$和$p_{i}^{n+1}(\\theta) \\ge 0$所需要的关于$\\theta$的代数条件。然后，对于给定的数据，计算在$[0,1]$中满足这两个条件的最大允许值$\\theta$。将最终答案表示为一个四舍五入到四位有效数字的实数。答案是无量纲的，因此不需要单位。", "solution": "问题要求找到最大的混合系数$\\theta \\in [0,1]$，以确保更新后的密度$\\rho_{i}^{n+1}$和压力$p_{i}^{n+1}$为非负。\n\n守恒变量向量$U_{i}^{n+1} = (\\rho_{i}^{n+1}, m_{i}^{n+1}, E_{i}^{n+1})^{\\top}$的更新由下式给出：\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\left(\\theta\\,\\Delta F^{\\mathrm{HO}} + (1-\\theta)\\,\\Delta F^{\\mathrm{LO}}\\right)\n$$\n其中$\\lambda = \\frac{\\Delta t}{\\Delta x}$。我们可以通过分离出低阶部分来重写这个方程：\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\Delta F^{\\mathrm{LO}} - \\theta\\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}})\n$$\n令$U_{i}^{\\mathrm{LO}} = U_{i}^{n} - \\lambda\\Delta F^{\\mathrm{LO}}$为仅使用低阶通量更新得到的状态。题目说明此更新是保正的，意味着$\\rho_{i}^{\\mathrm{LO}} \\ge 0$和$p_{i}^{\\mathrm{LO}} \\ge 0$。令$P = \\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}})$。则更新可以紧凑地写为：\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{\\mathrm{LO}} - \\theta P\n$$\n用分量形式写出：\n$$\n\\rho_{i}^{n+1}(\\theta) = \\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho} \\\\\nm_{i}^{n+1}(\\theta) = m_{i}^{\\mathrm{LO}} - \\theta P_{m} \\\\\nE_{i}^{n+1}(\\theta) = E_{i}^{\\mathrm{LO}} - \\theta P_{E}\n$$\n其中$P = (P_\\rho, P_m, P_E)^\\top$。\n\n首先，我们推导密度正性的代数条件，$\\rho_{i}^{n+1}(\\theta) \\ge 0$：\n$$\n\\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho} \\ge 0\n$$\n这是一个关于$\\theta$的线性不等式。\n\n其次，我们推导压力正性的条件，$p_{i}^{n+1}(\\theta) \\ge 0$。压力由$p = (\\gamma - 1)(E - \\frac{m^2}{2\\rho})$给出。由于$\\gamma  1$，条件$p \\ge 0$等价于其宗量为非负：\n$$\nE_{i}^{n+1}(\\theta) - \\frac{(m_{i}^{n+1}(\\theta))^2}{2\\rho_{i}^{n+1}(\\theta)} \\ge 0\n$$\n为避免除以可能为零的$\\rho_{i}^{n+1}(\\theta)$，我们乘以$2\\rho_{i}^{n+1}(\\theta)$。假设$\\rho_{i}^{n+1}(\\theta)  0$，这得到：\n$$\n2E_{i}^{n+1}(\\theta)\\rho_{i}^{n+1}(\\theta) - (m_{i}^{n+1}(\\theta))^2 \\ge 0\n$$\n代入关于$\\theta$的表达式：\n$$\n2(E_{i}^{\\mathrm{LO}} - \\theta P_{E})(\\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho}) - (m_{i}^{\\mathrm{LO}} - \\theta P_{m})^2 \\ge 0\n$$\n这是一个关于$\\theta$的形如$A\\theta^2 + B\\theta + C \\ge 0$的二次不等式。展开并整理关于$\\theta$的各项，我们可以得到系数。方便起见，我们考虑等价的不等式 $E_{i}^{n+1}(\\theta)\\rho_{i}^{n+1}(\\theta) - \\frac{1}{2}(m_{i}^{n+1}(\\theta))^2 \\ge 0$。展开后得到二次不等式 $A\\theta^2 + B\\theta + C \\ge 0$，其系数为：\n$$\nA = P_{E}P_{\\rho} - \\frac{1}{2}P_{m}^{2}\n$$\n$$\nB = m_{i}^{\\mathrm{LO}}P_{m} - (E_{i}^{\\mathrm{LO}}P_{\\rho} + \\rho_{i}^{\\mathrm{LO}}P_{E})\n$$\n$$\nC = E_{i}^{\\mathrm{LO}}\\rho_{i}^{\\mathrm{LO}} - \\frac{1}{2}(m_{i}^{\\mathrm{LO}})^2\n$$\n注意，由于低阶更新是保正的，因此$C \\ge 0$。\n\n现在，我们代入给定的数值：\n$\\gamma = 1.4$，$\\lambda = 0.1$。\n$U_{i}^{n} = (1.0, 2.0, 4.5)^{\\top}$。\n$\\Delta F^{\\mathrm{HO}} = (0.8, -3.0, 18.0)^{\\top}$。\n$\\Delta F^{\\mathrm{LO}} = (0.1, 0.0, 0.5)^{\\top}$。\n\n首先，计算低阶状态$U_{i}^{\\mathrm{LO}}$：\n$$\nU_{i}^{\\mathrm{LO}} = U_{i}^{n} - \\lambda \\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix} - 0.1 \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix} - \\begin{pmatrix} 0.01 \\\\ 0.0 \\\\ 0.05 \\end{pmatrix} = \\begin{pmatrix} 0.99 \\\\ 2.0 \\\\ 4.45 \\end{pmatrix}\n$$\n所以，$\\rho_{i}^{\\mathrm{LO}} = 0.99$，$m_{i}^{\\mathrm{LO}} = 2.0$，且$E_{i}^{\\mathrm{LO}} = 4.45$。\n\n接下来，计算向量$P$：\n$$\n\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 0.8 \\\\ -3.0 \\\\ 18.0 \\end{pmatrix} - \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 0.7 \\\\ -3.0 \\\\ 17.5 \\end{pmatrix}\n$$\n$$\nP = \\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}}) = 0.1 \\begin{pmatrix} 0.7 \\\\ -3.0 \\\\ 17.5 \\end{pmatrix} = \\begin{pmatrix} 0.07 \\\\ -0.3 \\\\ 1.75 \\end{pmatrix}\n$$\n所以，$P_{\\rho} = 0.07$，$P_{m} = -0.3$，且$P_{E} = 1.75$。\n\n评估密度条件：\n$$\n0.99 - \\theta(0.07) \\ge 0 \\implies 0.99 \\ge 0.07\\theta \\implies \\theta \\le \\frac{0.99}{0.07} = \\frac{99}{7} \\approx 14.14\n$$\n对于任意$\\theta \\in [0,1]$，此条件都满足。\n\n通过计算系数$A$、$B$和$C$来评估压力条件：\n$$\nC = (4.45)(0.99) - \\frac{1}{2}(2.0)^2 = 4.4055 - 2.0 = 2.4055\n$$\n$$\nB = (2.0)(-0.3) - ((4.45)(0.07) + (0.99)(1.75)) = -0.6 - (0.3115 + 1.7325) = -0.6 - 2.044 = -2.644\n$$\n$$\nA = (1.75)(0.07) - \\frac{1}{2}(-0.3)^2 = 0.1225 - \\frac{1}{2}(0.09) = 0.1225 - 0.045 = 0.0775\n$$\n压力正性的二次不等式为：\n$$\n0.0775 \\theta^2 - 2.644 \\theta + 2.4055 \\ge 0\n$$\n为了找到此不等式成立的区域，我们使用二次公式$\\theta = \\frac{-B \\pm \\sqrt{B^2-4AC}}{2A}$来求解二次方程$0.0775 \\theta^2 - 2.644 \\theta + 2.4055 = 0$的根：\n$$\nB^2 - 4AC = (-2.644)^2 - 4(0.0775)(2.4055) = 6.990736 - 0.745705 = 6.245031\n$$\n$$\n\\sqrt{B^2 - 4AC} \\approx 2.499006\n$$\n根为：\n$$\n\\theta_{1,2} = \\frac{2.644 \\pm 2.499006}{2(0.0775)} = \\frac{2.644 \\pm 2.499006}{0.155}\n$$\n$$\n\\theta_1 = \\frac{2.644 - 2.499006}{0.155} = \\frac{0.144994}{0.155} \\approx 0.935445\n$$\n$$\n\\theta_2 = \\frac{2.644 + 2.499006}{0.155} = \\frac{5.143006}{0.155} \\approx 33.18068\n$$\n由于系数$A=0.0775$为正，抛物线开口向上。不等式$A\\theta^2 + B\\theta + C \\ge 0$在$\\theta \\le \\theta_1$或$\\theta \\ge \\theta_2$时成立。因此，我们必须有：\n$$\n\\theta \\le 0.935445 \\quad \\text{或} \\quad \\theta \\ge 33.18068\n$$\n我们需要找到同时满足所有条件的最大$\\theta$：\n1. $\\theta \\in [0,1]$ (根据限制器的定义)\n2. $\\theta \\le 14.14$ (来自密度正性)\n3. $\\theta \\le 0.935445$ 或 $\\theta \\ge 33.18068$ (来自压力正性)\n\n这些条件的交集是$0 \\le \\theta \\le 0.935445$。\n$\\theta$的最大允许值是该区间的上界，$\\theta_{max} \\approx 0.935445$。\n四舍五入到四位有效数字，结果是$0.9354$。", "answer": "$$\\boxed{0.9354}$$", "id": "3320306"}, {"introduction": "将一维TVD（总变差递减）格式推广到多维并非易事，一个常见但有缺陷的方法是简单地对每个坐标方向独立应用一维限制器。当流动方向与计算网格斜交时，这种方法可能会失效，尤其是在大纵横比的网格上。本练习要求您通过编码实践，对比这种逐坐标限制的策略与一种真正的多维限制器，后者能够感知并沿着流动方向进行限制，从而揭示多维格式设计的核心挑战[@problem_id:3320354]。", "problem": "考虑一个标量场 $q(x,y,t)$ 的二维线性平流，其由以下守恒律控制：\n$$\n\\partial_t q + a\\,\\partial_x q + b\\,\\partial_y q = 0,\n$$\n其中 $(a,b)$ 是一个恒定速度矢量。在尺寸为 $\\,\\Delta x\\,$ 和 $\\,\\Delta y\\,$ 的矩形单元组成的均匀笛卡尔网格上，一个二阶精确的有限体积法更新可以写为：\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2},j} - F_{i-\\frac{1}{2},j}\\right) - \\frac{\\Delta t}{\\Delta y}\\left(G_{i,j+\\frac{1}{2}} - G_{i,j-\\frac{1}{2}}\\right),\n$$\n边界条件为周期性，其中 $F_{i+\\frac{1}{2},j}$ 和 $G_{i,j+\\frac{1}{2}}$ 是穿过单元面的数值通量。对于线性平流，迎风黎曼求解器使用 $F_{i+\\frac{1}{2},j} = a\\,q_{i+\\frac{1}{2},j}^{\\mathrm{up}}$ 和 $G_{i,j+\\frac{1}{2}} = b\\,q_{i,j+\\frac{1}{2}}^{\\mathrm{up}}$，其中 $q^{\\mathrm{up}}$ 是在单元面上从迎风侧取值的重构标量。\n\n重构在每个单元内使用基于受限梯度的线性分布。在许多多维实现中，通过沿每个坐标轴使用一维全变差递减（TVD）限制器，分别对 $\\partial_x q$ 和 $\\partial_y q$ 分量施加限制。当真实梯度和特征线与网格轴线倾斜时，这种逐坐标限制可能无法防止非物理行为，尤其是在纵横比 $\\Delta x/\\Delta y \\neq 1$ 的网格上。一个真正的多维限制器应该能感知信息传播的方向，并限制沿该方向的梯度分量，而不是独立地限制 $x$ 和 $y$ 方向上的分量。\n\n任务：从上述守恒律和有限体积离散化出发，实现两种重构策略：\n- 逐坐标限制：使用应用于各轴向前和向后差分的一维TVD限制器，为 $\\partial_x q$ 和 $\\partial_y q$ 计算单独的受限斜率。\n- 方向性多维限制：使用相同的TVD限制器，计算沿平流方向单位矢量 $\\boldsymbol{n} = (a,b)/\\sqrt{a^2+b^2}$ 的受限斜率，然后将此受限方向斜率乘以方向矢量 $\\boldsymbol{n}$ 来重构梯度矢量。\n\n使用大小为 $\\Delta t$ 的单个显式时间步，该步长选择为满足标准稳定性约束。在周期性单位正方形域 $[0,1]\\times[0,1]$ 上，将 $q$ 初始化为一个斜向平面阶跃函数：\n$$\nq(x,y,0) = \\begin{cases}\n1,  \\text{if } x\\cos\\alpha + y\\sin\\alpha  s,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $\\alpha$ 是阶跃法向角， $s$ 是一个阈值。一个时间步后的精确解是 $q_{\\mathrm{exact}}(x,y,\\Delta t) = q(x - a\\Delta t, y - b\\Delta t, 0)$，并应用周期性回卷。\n\n您必须：\n- 从基础离散格式推导出受限重构，并定义您选择使用的限制器。\n- 实现这两种格式，并推进一个时间步。\n- 每个测试案例使用两个指标来量化其失败和改进：\n    1. 过冲差异：逐坐标限制器的非物理有界性违背量值减去方向性限制器的相应量值，定义为\n       $$\n       \\Delta_{\\mathrm{over}} = \\left[\\max\\left(\\max(q_{\\mathrm{axis}} - 1), \\max(0 - q_{\\mathrm{axis}}), 0\\right)\\right] - \\left[\\max\\left(\\max(q_{\\mathrm{dir}} - 1), \\max(0 - q_{\\mathrm{dir}}), 0\\right)\\right].\n       $$\n    2. 误差比：离散 $L^1$ 误差之比，\n       $$\n       R_{L^1} = \\frac{\\frac{1}{N_x N_y}\\sum_{i,j}\\left|q_{i,j}^{\\mathrm{axis}} - q_{i,j}^{\\mathrm{exact}}\\right|}{\\frac{1}{N_x N_y}\\sum_{i,j}\\left|q_{i,j}^{\\mathrm{dir}} - q_{i,j}^{\\mathrm{exact}}\\right|}.\n       $$\n\n角度量必须以弧度表示。除了上述无量纲变量外，没有其他物理单位。在两个方向上都使用周期性边界条件。根据以下公式选择 $\\Delta t$\n$$\n\\Delta t = \\mathrm{CFL}\\cdot \\min\\left( \\frac{\\Delta x}{|a|}, \\frac{\\Delta y}{|b|} \\right),\n$$\n约定如果 $a=0$ 或 $b=0$，则在求最小值时，相应的分数被视为 $+\\infty$。\n\n测试套件：\n- 案例1（理想情况，近各向同性网格）：$N_x=128$, $N_y=128$, $\\beta= \\pi/4$, $\\alpha=\\pi/4$, $s=0.5$, $\\mathrm{CFL}=0.4$，其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n- 案例2（极端纵横比，斜向平流）：$N_x=200$, $N_y=20$, $\\beta= \\pi/3$, $\\alpha=\\pi/3$, $s=0.5$, $\\mathrm{CFL}=0.95$，其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n- 案例3（相反方向的极端纵横比）：$N_x=40$, $N_y=400$, $\\beta= \\pi/6$, $\\alpha=\\pi/6$, $s=0.5$, $\\mathrm{CFL}=0.95$，其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n- 案例4（边界情况，纯一维平流）：$N_x=128$, $N_y=32$, $\\beta= 0$, $\\alpha=\\pi/4$, $s=0.5$, $\\mathrm{CFL}=0.8$，其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个双元素列表 $[\\Delta_{\\mathrm{over}}, R_{L^1}]$。例如，输出格式必须为\n$$\n\\text{[}[d_1,r_1],[d_2,r_2],[d_3,r_3],[d_4,r_4]\\text{]},\n$$\n其中每个 $d_k$ 和 $r_k$ 都以浮点数形式打印。", "solution": "该问题要求实现并比较用于二维线性平流方程的两种有限体积格式，\n$$\n\\partial_t q + \\mathbf{v} \\cdot \\nabla q = 0,\n$$\n其中 $\\mathbf{v} = (a, b)$ 是一个恒定速度矢量，$q(x,y,t)$ 是一个标量场。比较的重点是在均匀笛卡尔网格上的二阶重构步骤中使用的梯度限制策略。\n\n首先，我们建立数值框架。使用有限体积法对控制偏微分方程进行离散化。对面积为 $|\\Omega_{i,j}| = \\Delta x \\Delta y$ 的控制体（单元）$\\Omega_{i,j} = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}] \\times [y_{j-\\frac{1}{2}}, y_{j+\\frac{1}{2}}]$ 进行积分，并应用散度定理，我们得到单元平均量 $q_{i,j}(t)$ 的半离散守恒律：\n$$\n\\frac{d q_{i,j}}{dt} + \\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2},j} - F_{i-\\frac{1}{2},j} \\right) + \\frac{1}{\\Delta y} \\left( G_{i,j+\\frac{1}{2}} - G_{i,j-\\frac{1}{2}} \\right) = 0.\n$$\n此处，$F$ 和 $G$ 分别是 $x$ 和 $y$ 方向的数值通量。对于线性平流，物理通量为 $f(q) = a q$ 和 $g(q) = b q$。数值通量近似于物理通量在单元面上的积分。对于迎风格式，单元面上的通量由迎风单元中的 $q$ 值确定。例如，在单元 $(i,j)$ 和 $(i+1,j)$ 之间的面 $x = x_{i+\\frac{1}{2}}$ 处，通量为：\n$$\nF_{i+\\frac{1}{2},j} = a^+ q_{i+\\frac{1}{2},j}^L + a^- q_{i+\\frac{1}{2},j}^R,\n$$\n其中 $a^+ = \\max(a,0)$，$a^- = \\min(a,0)$，而 $q^L$ 和 $q^R$ 分别是从左侧（单元 $i,j$）和右侧（单元 $i+1,j$）看，在界面上 $q$ 的重构值。\n\n为达到二阶空间精度，我们将每个单元内的 $q$ 重构为线性函数：\n$$\nq(x,y) = q_{i,j} + (\\partial_x q)_{i,j} (x-x_i) + (\\partial_y q)_{i,j} (y-y_j),\n$$\n其中 $(x_i, y_j)$ 是单元中心，$(\\partial_x q)_{i,j}, (\\partial_y q)_{i,j}$ 是单元 $(i,j)$ 中梯度的估计值。\n通过这种重构，在面 $x_{i+\\frac{1}{2}}$ 上的左右状态为：\n$$\nq_{i+\\frac{1}{2},j}^L = q_{i,j} + (\\partial_x q)_{i,j} \\frac{\\Delta x}{2}\n$$\n$$\nq_{i+\\frac{1}{2},j}^R = q_{i+1,j} - (\\partial_x q)_{i+1,j} \\frac{\\Delta x}{2}\n$$\n对于 $y$ 方向的面，也有类似的表达式。\n\n为防止在间断附近出现伪振荡（吉布斯现象），必须对梯度分量进行限制。这确保了重构是全变差递减（TVD）的。我们将使用 minmod 限制器。对于两个斜率 $s_1$ 和 $s_2$，其定义为：\n$$\n\\mathrm{minmod}(s_1, s_2) = \\begin{cases} \\min(s_1, s_2)  \\text{if } s_1, s_2  0 \\\\ \\max(s_1, s_2)  \\text{if } s_1, s_2  0 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n\n所要求的两种格式在计算受限梯度矢量 $\\nabla q_{i,j} = ((\\partial_x q)_{i,j}, (\\partial_y q)_{i,j})$ 的方式上有所不同。\n\n**1. 逐坐标限制 (`axis`)**\n这是将一维限制推广到多维的最直接方法。梯度分量沿每个坐标轴独立地进行限制。\n我们首先计算单元 $(i,j)$ 在每个方向上的向前和向后差商：\n$$\n\\Delta_x^b q = \\frac{q_{i,j}-q_{i-1,j}}{\\Delta x}, \\quad \\Delta_x^f q = \\frac{q_{i+1,j}-q_{i,j}}{\\Delta x}\n$$\n$$\n\\Delta_y^b q = \\frac{q_{i,j}-q_{i,j-1}}{\\Delta y}, \\quad \\Delta_y^f q = \\frac{q_{i,j+1}-q_{i,j}}{\\Delta y}\n$$\n然后通过对这些差商应用 minmod 限制器来计算受限梯度分量：\n$$\n(\\partial_x q)_{i,j}^{\\mathrm{axis}} = \\mathrm{minmod}(\\Delta_x^b q, \\Delta_x^f q)\n$$\n$$\n(\\partial_y q)_{i,j}^{\\mathrm{axis}} = \\mathrm{minmod}(\\Delta_y^b q, \\Delta_y^f q)\n$$\n这种方法很简单，但当流向与网格倾斜时，可能会产生过度耗散，因为它未能将不同坐标方向上的限制过程关联起来。\n\n**2. 方向性多维限制 (`dir`)**\n该策略旨在沿平流方向 $\\mathbf{n} = \\mathbf{v} / \\|\\mathbf{v}\\|_2 = (n_x, n_y)$ 限制梯度。遵循问题描述，我们首先使用上面计算的向前和向后差商构造方向导数的两个估计值：\n$$\nS_b = n_x \\Delta_x^b q + n_y \\Delta_y^b q\n$$\n$$\nS_f = n_x \\Delta_x^f q + n_y \\Delta_y^f q\n$$\n这些代表了向后和向前偏置的差分矢量在平流方向上的投影。然后我们对这些方向斜率应用 minmod 限制器：\n$$\n\\sigma_n = \\mathrm{minmod}(S_b, S_f)\n$$\n然后将这个受限的方向斜率 $\\sigma_n$ 投影回平流方向矢量 $\\mathbf{n}$，以形成最终的受限梯度矢量：\n$$\n\\nabla q_{i,j}^{\\mathrm{dir}} = \\sigma_n \\mathbf{n} = (\\sigma_n n_x, \\sigma_n n_y)\n$$\n这确保了受限梯度始终与平流速度对齐，这与逐坐标方法中受限梯度方向可能是任意的根本不同。\n\n**时间离散化和最终算法**\n我们使用单个向前欧拉步进行时间积分。完整的更新公式为：\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2},j}^n - F_{i-\\frac{1}{2},j}^n\\right) - \\frac{\\Delta t}{\\Delta y}\\left(G_{i,j+\\frac{1}{2}}^n - G_{i,j-\\frac{1}{2}}^n\\right),\n$$\n其中通量是使用两种限制格式之一的重构值计算的。时间步长 $\\Delta t$ 是基于CFL条件选择的，以确保稳定性。初始条件通过在单元中心对给定的阶跃函数进行采样来设置。精确解是通过对初始条件场进行平流并应用周期性回卷得到的。周期性边界条件通过使用 `numpy.roll` 访问邻近数据来处理。", "answer": "```python\nimport numpy as np\n\ndef minmod(s1, s2):\n    \"\"\"Vectorized minmod limiter function.\"\"\"\n    # This implementation is equivalent to the standard definition.\n    # It correctly handles arrays s1 and s2 element-wise.\n    signs = np.sign(s1) + np.sign(s2)\n    return 0.5 * signs * np.minimum(np.abs(s1), np.abs(s2))\n\ndef solve_step(q, dx, dy, dt, a, b, limiter_type):\n    \"\"\"\n    Advances the scalar field q by one time step dt.\n    \"\"\"\n    Nx, Ny = q.shape\n\n    # --- 1. Compute limited gradients ---\n    # Get neighbor values using periodic boundary conditions\n    q_im1_j = np.roll(q, 1, axis=0)\n    q_ip1_j = np.roll(q, -1, axis=0)\n    q_i_jm1 = np.roll(q, 1, axis=1)\n    q_i_jp1 = np.roll(q, -1, axis=1)\n\n    # Compute forward/backward difference quotients\n    grad_x_bwd = (q - q_im1_j) / dx\n    grad_x_fwd = (q_ip1_j - q) / dx\n    grad_y_bwd = (q - q_i_jm1) / dy\n    grad_y_fwd = (q_i_jp1 - q) / dy\n\n    if limiter_type == 'axis':\n        grad_x = minmod(grad_x_bwd, grad_x_fwd)\n        grad_y = minmod(grad_y_bwd, grad_y_fwd)\n    elif limiter_type == 'dir':\n        v_norm = np.sqrt(a**2 + b**2)\n        if v_norm == 0:\n            grad_x, grad_y = np.zeros_like(q), np.zeros_like(q)\n        else:\n            nx, ny = a / v_norm, b / v_norm\n            s_b = nx * grad_x_bwd + ny * grad_y_bwd\n            s_f = nx * grad_x_fwd + ny * grad_y_fwd\n            sigma_n = minmod(s_b, s_f)\n            grad_x = sigma_n * nx\n            grad_y = sigma_n * ny\n    else:\n        raise ValueError(\"Unknown limiter type\")\n\n    # --- 2. Reconstruct states at cell faces ---\n    # x-faces (i+1/2, j)\n    q_L_x = q + grad_x * dx / 2.0\n    q_R_x = np.roll(q, -1, axis=0) - np.roll(grad_x, -1, axis=0) * dx / 2.0\n    \n    # y-faces (i, j+1/2)\n    q_L_y = q + grad_y * dy / 2.0\n    q_R_y = np.roll(q, -1, axis=1) - np.roll(grad_y, -1, axis=1) * dy / 2.0\n\n    # --- 3. Compute upwind fluxes ---\n    # Fluxes F across x-faces\n    q_upwind_x = np.where(a > 0.0, q_L_x, q_R_x)\n    F = a * q_upwind_x\n    \n    # Fluxes G across y-faces\n    q_upwind_y = np.where(b > 0.0, q_L_y, q_R_y)\n    G = b * q_upwind_y\n\n    # --- 4. Compute flux divergence ---\n    div_F = (F - np.roll(F, 1, axis=0)) / dx\n    div_G = (G - np.roll(G, 1, axis=1)) / dy\n\n    # --- 5. Update cell averages ---\n    q_new = q - dt * (div_F + div_G)\n\n    return q_new\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute metrics.\n    \"\"\"\n    test_cases = [\n        # Case 1: Nx=128, Ny=128, beta=pi/4, alpha=pi/4, s=0.5, CFL=0.4\n        (128, 128, np.pi/4, np.pi/4, 0.5, 0.4),\n        # Case 2: Nx=200, Ny=20, beta=pi/3, alpha=pi/3, s=0.5, CFL=0.95\n        (200, 20, np.pi/3, np.pi/3, 0.5, 0.95),\n        # Case 3: Nx=40, Ny=400, beta=pi/6, alpha=pi/6, s=0.5, CFL=0.95\n        (40, 400, np.pi/6, np.pi/6, 0.5, 0.95),\n        # Case 4: Nx=128, Ny=32, beta=0, alpha=pi/4, s=0.5, CFL=0.8\n        (128, 32, 0.0, np.pi/4, 0.5, 0.8),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Nx, Ny, beta, alpha, s, CFL = case\n        \n        # Grid setup\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_centers, y_centers, indexing='ij')\n\n        # Advection velocity\n        a, b = np.cos(beta), np.sin(beta)\n        \n        # Time step calculation\n        term_x = dx / np.abs(a) if np.abs(a) > 1e-12 else np.inf\n        term_y = dy / np.abs(b) if np.abs(b) > 1e-12 else np.inf\n        dt = CFL * min(term_x, term_y)\n\n        # Initial condition\n        q0 = np.where(xx * np.cos(alpha) + yy * np.sin(alpha) > s, 1.0, 0.0)\n\n        # Run both schemes\n        q_axis = solve_step(q0, dx, dy, dt, a, b, 'axis')\n        q_dir = solve_step(q0, dx, dy, dt, a, b, 'dir')\n\n        # Exact solution at t=dt\n        x_shifted = (xx - a * dt) % 1.0\n        y_shifted = (yy - b * dt) % 1.0\n        q_exact = np.where(x_shifted * np.cos(alpha) + y_shifted * np.sin(alpha) > s, 1.0, 0.0)\n\n        # Calculate metrics\n        # 1. Overshoot difference\n        over_axis = np.max([np.max(q_axis - 1.0), np.max(0.0 - q_axis), 0.0])\n        over_dir = np.max([np.max(q_dir - 1.0), np.max(0.0 - q_dir), 0.0])\n        delta_over = over_axis - over_dir\n\n        # 2. L1 error ratio\n        err_axis = np.sum(np.abs(q_axis - q_exact))\n        err_dir = np.sum(np.abs(q_dir - q_exact))\n        \n        # Handle cases where denominator is zero (e.g., perfect solution)\n        R_L1 = err_axis / err_dir if err_dir > 1e-15 else 1.0\n        \n        all_results.append([delta_over, R_L1])\n\n    # Format output\n    result_str = \",\".join([f\"[{d:.12f},{r:.12f}]\" for d, r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3320354"}, {"introduction": "理想的通量限制器应在光滑区域保持高精度（使用压缩性更强的限制器），同时在激波处保证稳定性（使用耗散性更强的限制器）。本练习将引导您实现一种先进的自适应限制器，它使用一个激波传感器来动态调整其压缩性。此外，您还将探索并实现一种滞回策略，以减少因限制器在不同状态间频繁切换而引起的数值“抖动”，这代表了现代数值格式设计中一种精巧而实用的技术[@problem_id:3320332]。", "problem": "考虑一维标量线性平流方程 $u_t + a u_x = 0$，其定义在长度为 $L = 1$ 的周期性域上，具有恒定的平流速度 $a  0$。使用守恒有限体积更新，该更新采用一阶精度的迎风通量，并通过守恒律的单调上游中心格式 (MUSCL) 对左界面状态进行重构来增强。MUSCL重构采用一个通量限制器，该限制器根据一个激波传感器自适应地调整其压缩性，并引入滞回效应以减少限制器抖动。三角函数中的所有角度必须以弧度为单位。\n\n请基于以下基本原理进行推导：\n- 标量守恒律 $u_t + a u_x = 0$ 及其守恒有限体积离散化\n$$\nu_i^{n+1} = u_i^n - \\lambda\\left(f_{i+\\frac{1}{2}}^n - f_{i-\\frac{1}{2}}^n\\right), \\quad \\lambda = \\frac{a\\,\\Delta t}{\\Delta x},\n$$\n其中，对于 $a0$，数值通量为 $f_{i+\\frac{1}{2}}^n = a\\, u_{i+\\frac{1}{2}}^{-\\,n}$。\n- 对于 $a0$，使用受限斜率的MUSCL左界面重构，\n$$\nu_{i+\\frac{1}{2}}^{-\\,n} = u_i^n + \\frac{1}{2}\\,\\phi\\!\\left(r_i^n; c_i^n\\right)\\,\\left(u_i^n - u_{i-1}^n\\right),\n$$\n其中梯度比 $r_i^n$ 为\n$$\nr_i^n = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n + \\varepsilon},\n$$\n其中 $\\varepsilon  0$ 是一个小的正则化参数，以避免除以零。\n- 参数化通量限制器族（有时称为斜率限制中心族），\n$$\n\\phi\\!\\left(r; c\\right) = \\max\\!\\left(0,\\, \\min\\!\\left(\\min\\!\\left(c\\,r,\\,1\\right),\\,\\min\\!\\left(r,\\,c\\right)\\right)\\right),\n$$\n其中 $c \\in [1,2]$ 控制压缩性，$c=1$ 恢复为minmod限制器（耗散性更强），$c=2$ 恢复为类superbee行为（压缩性更强）。\n- 激波传感器\n$$\nS_i^n = \\frac{\\left|u_{i+1}^n - 2\\,u_i^n + u_{i-1}^n\\right|}{\\left|u_{i+1}^n - u_i^n\\right| + \\left|u_i^n - u_{i-1}^n\\right| + \\delta},\n$$\n其中 $\\delta  0$ 以避免分母消失。\n\n设计一个基于激波传感器 $S_i^n$ 的自适应压缩性策略 $c_i^n$，该策略包含滞回效应以减轻限制器抖动。具体来说，为每个单元定义一个二元状态 $H_i^n \\in \\{0,1\\}$ 来指示压缩性分支：$H_i^n = 1$ 选择 $c_{\\mathrm{high}}$，$H_i^n = 0$ 选择 $c_{\\mathrm{low}}$，其中 $1 \\le c_{\\mathrm{low}}  c_{\\mathrm{high}} \\le 2$。使用两个阈值 $S_{\\mathrm{low}}  S_{\\mathrm{high}}$ 来实现滞回转变：\n- 如果 $H_i^n = 1$ 且 $S_i^n \\ge S_{\\mathrm{high}}$，则 $H_i^{n+} = 0$；否则 $H_i^{n+} = H_i^n$。\n- 如果 $H_i^n = 0$ 且 $S_i^n \\le S_{\\mathrm{low}}$，则 $H_i^{n+} = 1$；否则 $H_i^{n+} = H_i^n$。\n\n作为非滞回基线，定义一个单阈值策略，其中 $S_{\\mathrm{thr}} = \\left(S_{\\mathrm{low}} + S_{\\mathrm{high}}\\right)/2$：\n- 在每个时间步，如果 $S_i^n \\le S_{\\mathrm{thr}}$，则设置 $c_i^n = c_{\\mathrm{high}}$，否则设置 $c_i^n = c_{\\mathrm{low}}$。\n\n在 $a0$ 且具有周期性边界条件的 MUSCL 格式中，实现滞回和非滞回两种策略。对于每种方法，将限制器抖动计数定义为所有单元在所有时间步上二元状态转变的总次数。通过与具有周期性回绕的精确解 $u(x,T) = u_0(x - aT)$ 相比，在最终时刻 $T$ 的离散 $L^1$ 误差来评估精度，其中 $u_0(x)$ 是初始条件。\n\n你的程序必须：\n- 从在网格点 $x_i = i\\,\\Delta x$（其中 $i=0,\\dots,N-1$, $\\Delta x = L/N$, $L=1$）上求值的连续初始条件 $u_0(x)$ 初始化解 $u_i^0$。\n- 使用前向欧拉时间步进，Courant–Friedrichs–Lewy数 $\\lambda = a\\,\\Delta t/\\Delta x \\in (0,1]$。\n- 计算激波传感器 $S_i^n$、梯度比 $r_i^n$、限制器 $\\phi(r_i^n;c_i^n)$，并对滞回和非滞回两种策略执行更新。\n- 记录两种方法的总抖动次数和最终时刻的 $L^1$ 误差。\n\n测试套件：\n- 情况A（混合光滑与间断）：$N=256$, $a=1$, $\\lambda=0.5$, $T=0.25$, $c_{\\mathrm{low}}=1.0$, $c_{\\mathrm{high}}=2.0$, $S_{\\mathrm{low}}=0.2$, $S_{\\mathrm{high}}=0.4$, $\\delta=\\varepsilon=10^{-12}$, 初始条件\n$$\nu_0(x) = \\begin{cases}\n0.5 + 0.5\\,\\sin(2\\pi x),  0 \\le x  0.7,\\\\\n1,  0.7 \\le x  0.85,\\\\\n0,  0.85 \\le x  1.\n\\end{cases}\n$$\n- 情况B（具有多尺度内容的光滑函数）：$N=256$, $a=1$, $\\lambda=0.5$, $T=0.25$, $c_{\\mathrm{low}}=1.0$, $c_{\\mathrm{high}}=2.0$, $S_{\\mathrm{low}}=0.1$, $S_{\\mathrm{high}}=0.3$, $\\delta=\\varepsilon=10^{-12}$, 初始条件\n$$\nu_0(x) = 0.5 + 0.4\\,\\sin(2\\pi x) + 0.05\\,\\sin(16\\pi x).\n$$\n- 情况C（恒定状态边缘情况）：$N=128$, $a=1$, $\\lambda=0.5$, $T=0.25$, $c_{\\mathrm{low}}=1.0$, $c_{\\mathrm{high}}=2.0$, $S_{\\mathrm{low}}=0.2$, $S_{\\mathrm{high}}=0.4$, $\\delta=\\varepsilon=10^{-12}$, 初始条件\n$$\nu_0(x) = 0.3.\n$$\n\n对于每种情况，按以下顺序计算并返回四个量：\n1. 非滞回策略的总抖动次数（整数）。\n2. 滞回策略的总抖动次数（整数）。\n3. 非滞回策略的最终时刻离散 $L^1$ 误差（浮点数）。\n4. 滞回策略的最终时刻离散 $L^1$ 误差（浮点数）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有三种情况的结果，格式为逗号分隔的列表的列表，不含空格，例如：\n- \"[[cA_no,cA_hyst,eA_no,eA_hyst],[cB_no,cB_hyst,eB_no,eB_hyst],[cC_no,cC_hyst,eC_no,eC_hyst]]\"。", "solution": "该问题要求在一维线性平流方程 $u_t + a u_x = 0$ 的守恒律单调上游中心格式 (MUSCL) 中，实现并比较两种自适应通量限制器策略。这些策略根据局部激波传感器调整限制器的压缩性，其中一种策略引入了滞回效应以减轻限制器抖动。\n\n数值框架是一种守恒有限体积方法。长度为 $L=1$ 的域被离散为 $N$ 个宽度均匀的单元，单元宽度为 $\\Delta x = L/N$。在时间步 $n$，单元 $i$ 中的解（由单元平均值 $u_i^n$ 表示）使用以下公式更新：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(f_{i+\\frac{1}{2}}^n - f_{i-\\frac{1}{2}}^n\\right)\n$$\n此处，$\\Delta t$ 是时间步长，$f_{i\\pm\\frac{1}{2}}^n$ 是单元界面处的数值通量。给定平流速度 $a  0$，使用迎风格式，这意味着通量由界面左侧的状态确定。具体而言，数值通量为 $f_{i+\\frac{1}{2}}^n = a\\, u_{i+\\frac{1}{2}}^{-\\,n}$，其中 $u_{i+\\frac{1}{2}}^{-\\,n}$ 是在单元 $i$ 和 $i+1$ 之间界面左侧的解的重构值。\n\nMUSCL方法通过在每个单元内对解进行分段线性重构来实现更高阶的精度。界面 $i+\\frac{1}{2}$ 左侧的值根据单元 $i$ 及其邻近单元的数据进行重构：\n$$\nu_{i+\\frac{1}{2}}^{-\\,n} = u_i^n + \\frac{1}{2}\\,\\phi\\!\\left(r_i^n; c_i^n\\right)\\,\\left(u_i^n - u_{i-1}^n\\right)\n$$\n此公式在一阶值 $u_i^n$ 的基础上增加了一个受限的修正项。项 $u_i^n - u_{i-1}^n$ 表示后向差分，是对局部梯度的一个近似。函数 $\\phi$ 是一个通量限制器，它是防止在陡峭梯度或间断附近产生伪振荡的关键组成部分。\n\n限制器函数 $\\phi(r_i^n; c_i^n)$ 取决于连续梯度的比率 $r_i^n$，其定义为：\n$$\nr_i^n = \\frac{u_i^n - u_{i-1}^n}{u_{i+1}^n - u_i^n + \\varepsilon}\n$$\n参数 $\\varepsilon$ 是一个小的正数（$10^{-12}$），用于在常数状态区域防止除以零。所使用的特定通量限制器来自参数化族：\n$$\n\\phi\\!\\left(r; c\\right) = \\max\\!\\left(0,\\, \\min\\!\\left(\\min\\!\\left(c\\,r,\\,1\\right),\\,\\min\\!\\left(r,\\,c\\right)\\right)\\right)\n$$\n参数 $c \\in [1, 2]$ 控制格式的“压缩性”。值为 $c=1$ 对应于耗散性更强的 minmod 限制器，而 $c=2$ 则产生一个压缩性更强的、类似 superbee 的限制器，它更擅长解析尖锐特征，但也可能更具振荡性。\n\n问题的核心是根据解的局部光滑度，在每个时间步 $n$ 为每个单元 $i$ 自适应调整参数 $c_i^n$。这是通过使用一个激波传感器 $S_i^n$ 来实现的：\n$$\nS_i^n = \\frac{\\left|u_{i+1}^n - 2\\,u_i^n + u_{i-1}^n\\right|}{\\left|u_{i+1}^n - u_i^n\\right| + \\left|u_i^n - u_{i-1}^n\\right| + \\delta}\n$$\n该传感器测量局部二阶导数相对于一阶导数的大小。$S_i^n$ 的大值（接近1）表示存在陡峭梯度或激波，而小值则表明是光滑区域。参数 $\\delta$ 和 $\\varepsilon$ 一样，是一个小值（$10^{-12}$），以避免除以零。\n\n评估了两种基于 $S_i^n$ 自适应调整 $c_i^n$ 的策略：\n\n1.  **非滞回策略**：这是一种简单的单阈值方法。定义一个阈值 $S_{\\mathrm{thr}} = (S_{\\mathrm{low}} + S_{\\mathrm{high}})/2$。在每个时间步，单元 $i$ 的压缩性参数设置如下：\n    $$\n    c_i^n =\n    \\begin{cases}\n    c_{\\mathrm{high}}  \\text{如果 } S_i^n \\le S_{\\mathrm{thr}} \\quad \\text{（光滑区域）} \\\\\n    c_{\\mathrm{low}}  \\text{如果 } S_i^n  S_{\\mathrm{thr}} \\quad \\text{（非光滑区域）}\n    \\end{cases}\n    $$\n    该策略旨在光滑区域使用压缩性更强的限制器以保持精度，在激波附近使用耗散性更强的限制器以确保稳定性。一个潜在的缺点是“限制器抖动”，即如果 $S_i^n$ 在 $S_{\\mathrm{thr}}$ 附近徘徊，$c_i^n$ 会在 $c_{\\mathrm{low}}$ 和 $c_{\\mathrm{high}}$ 之间快速切换。\n\n2.  **滞回策略**：该策略向系统中引入记忆以抑制抖动。它为每个单元使用一个二元状态变量 $H_i^n \\in \\{0, 1\\}$。压缩性由 $c_i^n = c_{\\mathrm{high}}$（如果 $H_i^n=1$）和 $c_i^n=c_{\\mathrm{low}}$（如果 $H_i^n=0$）设定。状态 $H_i^n$ 使用两个不同的阈值 $S_{\\mathrm{low}}$ 和 $S_{\\mathrm{high}}$（其中 $S_{\\mathrm{low}}  S_{\\mathrm{high}}$）进行更新：\n    - 如果系统处于高压缩性状态（$H_i^n = 1$）且激波传感器超过上阈值（$S_i^n \\ge S_{\\mathrm{high}}$），则切换到低压缩性状态：$H_i^{n+1} = 0$。\n    - 如果系统处于低压缩性状态（$H_i^n = 0$）且激波传感器降至下阈值以下（$S_i^n \\le S_{\\mathrm{low}}$），则切换到高压缩性状态：$H_i^{n+1} = 1$。\n    - 否则，状态保持不变：$H_i^{n+1} = H_i^n$。\n    $S_{\\mathrm{low}}$ 和 $S_{\\mathrm{high}}$ 之间的间隙创建了一个“死区”，防止状态因 $S_i^n$ 的小幅波动而来回切换，从而减少抖动。\n\n实现过程首先在 $N$ 个点的网格上离散化初始条件 $u_0(x)$。然后使用前向欧拉步进法和固定的 Courant 数 $\\lambda = a \\Delta t / \\Delta x = 0.5$ 对系统进行时间演化。在每个时间步，对于每个单元 $i$，算法计算必要的差分、激波传感器 $S_i^n$，根据所选策略选择 $c_i^n$，计算梯度比 $r_i^n$ 和限制器 $\\phi_i^n$，重构所有界面值 $u_{i+1/2}^{-,n}$，计算相应的通量，并最终更新单元平均值 $u_i^{n+1}$。周期性边界条件通过数组滚动操作来处理。\n\n每种策略的性能通过两个指标来量化：总抖动次数（所有单元在所有时间步上状态转变的总和）和最终时刻 $T$ 的离散 $L^1$ 误差，计算公式为 $\\sum_{i=0}^{N-1} |u_i^{\\text{final}} - u_{\\text{exact}}(x_i, T)| \\Delta x$，其中 $u_{\\text{exact}}(x, T) = u_0(x-aT \\pmod 1)$。滞回策略的初始状态 $H_i^0$ 是在 $t=0$ 时刻使用非滞回规则确定的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs simulations for all test cases and prints the results.\n    \"\"\"\n\n    def get_u0_A(x):\n        \"\"\"Initial condition for Case A.\"\"\"\n        return np.piecewise(x,\n                            [(x >= 0)  (x  0.7), (x >= 0.7)  (x  0.85)],\n                            [lambda v: 0.5 + 0.5 * np.sin(2 * np.pi * v), 1.0, 0.0])\n\n    def get_u0_B(x):\n        \"\"\"Initial condition for Case B.\"\"\"\n        return 0.5 + 0.4 * np.sin(2 * np.pi * x) + 0.05 * np.sin(16 * np.pi * x)\n\n    def get_u0_C(x):\n        \"\"\"Initial condition for Case C.\"\"\"\n        return 0.3 * np.ones_like(x)\n\n    def run_simulation(N, a, lam, T, c_low, c_high, S_low, S_high, delta, epsilon, u0_func, policy):\n        \"\"\"\n        Runs a single simulation for a given policy ('hysteretic' or 'non_hysteretic').\n        \"\"\"\n        L = 1.0\n        dx = L / N\n        x = np.arange(N) * dx\n        dt = lam * dx / a\n        num_steps = int(round(T / dt))\n\n        u = u0_func(x)\n        chatter_count = 0\n        \n        S_thr = (S_low + S_high) / 2.0\n\n        # Policy-specific state initialization\n        if policy == 'hysteretic':\n            # Initial H state based on non-hysteretic rule\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n            du_left = u - u_im1\n            du_right = u_ip1 - u\n            sensor_num = np.abs(du_right - du_left)\n            sensor_den = np.abs(du_right) + np.abs(du_left) + delta\n            S = sensor_num / sensor_den\n            H = np.where(S = S_thr, 1, 0)\n        elif policy == 'non_hysteretic':\n            # Initial state for chatter counting\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n            du_left = u - u_im1\n            du_right = u_ip1 - u\n            sensor_num = np.abs(du_right - du_left)\n            sensor_den = np.abs(du_right) + np.abs(du_left) + delta\n            S = sensor_num / sensor_den\n            C_state = np.where(S = S_thr, 1, 0) # 1 for high, 0 for low\n\n        for _ in range(num_steps):\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n\n            du_left = u - u_im1  # u_i - u_{i-1}\n            du_right = u_ip1 - u # u_{i+1} - u_i\n            \n            sensor_num = np.abs(du_right - du_left)\n            sensor_den = np.abs(du_right) + np.abs(du_left) + delta\n            S = sensor_num / sensor_den\n            \n            if policy == 'hysteretic':\n                H_old = H.copy()\n                # Apply transition rules based on H_old\n                H[(H_old == 1)  (S >= S_high)] = 0\n                H[(H_old == 0)  (S = S_low)] = 1\n                chatter_count += np.sum(H != H_old)\n                c = np.where(H == 1, c_high, c_low)\n            elif policy == 'non_hysteretic':\n                C_state_old = C_state.copy()\n                C_state = np.where(S = S_thr, 1, 0)\n                chatter_count += np.sum(C_state != C_state_old)\n                c = np.where(C_state == 1, c_high, c_low)\n            \n            r_num = du_left\n            r_den = du_right + epsilon\n            r = r_num / r_den\n\n            # Limiter function: phi(r,c) = max(0, min(min(c*r, 1), min(r, c)))\n            min1 = np.minimum(c * r, 1.0)\n            min2 = np.minimum(r, c)\n            phi = np.maximum(0.0, np.minimum(min1, min2))\n            \n            # Reconstruct left interface states\n            u_interface_minus = u + 0.5 * phi * du_left\n            \n            # Compute fluxes\n            F = a * u_interface_minus\n            \n            # Update cell averages\n            F_diff = F - np.roll(F, 1)\n            u = u - lam * F_diff\n        \n        # Calculate L1 error\n        x_shifted = np.mod(x - a * T, L)\n        u_exact = u0_func(x_shifted)\n        l1_error = np.sum(np.abs(u - u_exact)) * dx\n        \n        return int(chatter_count), float(l1_error)\n\n    test_cases = [\n        # Case A\n        {'N': 256, 'a': 1.0, 'lam': 0.5, 'T': 0.25, 'c_low': 1.0, 'c_high': 2.0,\n         'S_low': 0.2, 'S_high': 0.4, 'delta': 1e-12, 'epsilon': 1e-12, 'u0_func': get_u0_A},\n        # Case B\n        {'N': 256, 'a': 1.0, 'lam': 0.5, 'T': 0.25, 'c_low': 1.0, 'c_high': 2.0,\n         'S_low': 0.1, 'S_high': 0.3, 'delta': 1e-12, 'epsilon': 1e-12, 'u0_func': get_u0_B},\n        # Case C\n        {'N': 128, 'a': 1.0, 'lam': 0.5, 'T': 0.25, 'c_low': 1.0, 'c_high': 2.0,\n         'S_low': 0.2, 'S_high': 0.4, 'delta': 1e-12, 'epsilon': 1e-12, 'u0_func': get_u0_C}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        \n        # Non-hysteretic policy\n        chatter_non, error_non = run_simulation(**case, policy='non_hysteretic')\n        \n        # Hysteretic policy\n        chatter_hyst, error_hyst = run_simulation(**case, policy='hysteretic')\n        \n        case_results.extend([chatter_non, chatter_hyst, error_non, error_hyst])\n        all_results.append(case_results)\n\n    # Format output string\n    result_str = f\"[[{','.join(map(str, all_results[0]))}],[{','.join(map(str, all_results[1]))}],[{','.join(map(str, all_results[2]))}]]\"\n    print(result_str)\n\nsolve()\n```", "id": "3320332"}]}