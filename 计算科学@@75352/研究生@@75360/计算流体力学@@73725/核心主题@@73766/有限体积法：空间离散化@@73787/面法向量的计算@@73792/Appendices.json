{"hands_on_practices": [{"introduction": "在有限体积法中，基本思想是在离散的控制体（或单元）上求解守恒定律的积分形式。这需要精确计算流经每个单元面的通量，而通量的计算与面的法向量和面积紧密相关。本练习将通过一个简单的二维矩形单元，带你从最基本的定义出发，动手计算一个给定速度场通过单元边界的净流出量，从而深入理解通量积分与法向量之间的核心关系。[@problem_id:3297266]", "problem": "考虑计算流体力学 (CFD) 中使用的笛卡尔网格中的一个二维矩形控制体 $\\Omega$，其几何中心位于 $(x_{c}, y_{c})$，边长为 $\\Delta x$ 和 $\\Delta y$。该矩形是轴对齐的，因此其边界 $\\partial \\Omega$ 由位于 $x = x_{c} \\pm \\Delta x/2$ 和 $y = y_{c} \\pm \\Delta y/2$ 的四条直边组成。一个线性空间变化的速度场被指定为 $\\mathbf{u}(x,y) = \\begin{pmatrix} a x + b y + c \\\\ d x + e y + f \\end{pmatrix}$，其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 是常数。假设所有量均为无量纲。\n\n任务：\n- 确定 $\\partial \\Omega$ 每条边的向外单位法向量。\n- 使用向外法向通量的基本定义，精确计算环路积分 $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$，并给出闭合形式的解。\n\n将您的最终答案表示为关于 $a$、$b$、$c$、$d$、$e$、$f$、$\\Delta x$ 和 $\\Delta y$ 的单一、简化的解析表达式。不包含单位，也无需四舍五入。", "solution": "我们从向量场 $\\mathbf{u}$ 穿过边界 $\\partial \\Omega$（其向外单位法向量为 $\\hat{n}$）的通量的基本定义开始，该通量由线积分 $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ 给出。对于一个轴对齐的矩形，四条边具有恒定的向外单位法向量。\n\n几何与法向量：\n- 右（东）边：$x = x_{c} + \\Delta x/2$，$y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$，向外单位法向量 $\\hat{n}_{E} = (1, 0)^{\\top}$。\n- 左（西）边：$x = x_{c} - \\Delta x/2$，$y \\in [y_{c} - \\Delta y/2, \\, y_{c} + \\Delta y/2]$，向外单位法向量 $\\hat{n}_{W} = (-1, 0)^{\\top}$。\n- 上（北）边：$y = y_{c} + \\Delta y/2$，$x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$，向外单位法向量 $\\hat{n}_{N} = (0, 1)^{\\top}$。\n- 下（南）边：$y = y_{c} - \\Delta y/2$，$x \\in [x_{c} - \\Delta x/2, \\, x_{c} + \\Delta x/2]$，向外单位法向量 $\\hat{n}_{S} = (0, -1)^{\\top}$。\n\n我们使用定义 $\\displaystyle \\int_{\\text{edge}} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell$ 并通过每条直边的坐标变量对其进行参数化，将通量计算为四条边积分之和。\n\n东边：\n- 参数化：$x = x_{E} := x_{c} + \\Delta x/2$，$y \\in [y_{-}, y_{+}]$，其中 $y_{\\pm} := y_{c} \\pm \\Delta y/2$，且 $d\\ell = dy$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{E} = u_{x}(x,y) = a x + b y + c$ 在 $x = x_{E}$ 处的值。\n- 积分：\n$$\n\\Phi_{E} = \\int_{y_{-}}^{y_{+}} \\left( a x_{E} + b y + c \\right) \\, dy = \\left( a x_{E} + c \\right) \\Delta y + b \\int_{y_{-}}^{y_{+}} y \\, dy.\n$$\n使用 $\\int_{y_{-}}^{y_{+}} y \\, dy = \\tfrac{1}{2} \\left( y_{+}^{2} - y_{-}^{2} \\right) = y_{c} \\Delta y$，我们得到\n$$\n\\Phi_{E} = \\Delta y \\left( a x_{E} + b y_{c} + c \\right).\n$$\n\n西边：\n- 参数化：$x = x_{W} := x_{c} - \\Delta x/2$，$y \\in [y_{-}, y_{+}]$，$d\\ell = dy$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{W} = - u_{x}(x,y) = - \\left( a x + b y + c \\right)$ 在 $x = x_{W}$ 处的值。\n- 积分：\n$$\n\\Phi_{W} = \\int_{y_{-}}^{y_{+}} \\left( - a x_{W} - b y - c \\right) \\, dy = - \\Delta y \\left( a x_{W} + b y_{c} + c \\right).\n$$\n\n将东边和西边的贡献相加：\n$$\n\\Phi_{E} + \\Phi_{W} = \\Delta y \\left[ a \\left( x_{E} - x_{W} \\right) + \\left( b y_{c} + c \\right) - \\left( b y_{c} + c \\right) \\right] = \\Delta y \\, a \\left( x_{E} - x_{W} \\right).\n$$\n因为 $x_{E} - x_{W} = \\left( x_{c} + \\tfrac{\\Delta x}{2} \\right) - \\left( x_{c} - \\tfrac{\\Delta x}{2} \\right) = \\Delta x$，我们得到\n$$\n\\Phi_{E} + \\Phi_{W} = a \\, \\Delta x \\, \\Delta y.\n$$\n\n北边：\n- 参数化：$y = y_{N} := y_{c} + \\Delta y/2$，$x \\in [x_{-}, x_{+}]$，其中 $x_{\\pm} := x_{c} \\pm \\Delta x/2$，且 $d\\ell = dx$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{N} = u_{y}(x,y) = d x + e y + f$ 在 $y = y_{N}$ 处的值。\n- 积分：\n$$\n\\Phi_{N} = \\int_{x_{-}}^{x_{+}} \\left( d x + e y_{N} + f \\right) \\, dx = d \\int_{x_{-}}^{x_{+}} x \\, dx + \\left( e y_{N} + f \\right) \\Delta x.\n$$\n使用 $\\int_{x_{-}}^{x_{+}} x \\, dx = \\tfrac{1}{2} \\left( x_{+}^{2} - x_{-}^{2} \\right) = x_{c} \\Delta x$，我们得到\n$$\n\\Phi_{N} = d \\, x_{c} \\, \\Delta x + \\left( e y_{N} + f \\right) \\Delta x.\n$$\n\n南边：\n- 参数化：$y = y_{S} := y_{c} - \\Delta y/2$，$x \\in [x_{-}, x_{+}]$，$d\\ell = dx$。\n- 被积函数：$\\mathbf{u} \\cdot \\hat{n}_{S} = - u_{y}(x,y) = - \\left( d x + e y + f \\right)$ 在 $y = y_{S}$ 处的值。\n- 积分：\n$$\n\\Phi_{S} = \\int_{x_{-}}^{x_{+}} \\left( - d x - e y_{S} - f \\right) \\, dx = - d \\int_{x_{-}}^{x_{+}} x \\, dx - \\left( e y_{S} + f \\right) \\Delta x.\n$$\n因此，\n$$\n\\Phi_{S} = - d \\, x_{c} \\, \\Delta x - \\left( e y_{S} + f \\right) \\Delta x.\n$$\n\n将北边和南边的贡献相加：\n$$\n\\Phi_{N} + \\Phi_{S} = \\left[ d x_{c} \\Delta x + \\left( e y_{N} + f \\right) \\Delta x \\right] + \\left[ - d x_{c} \\Delta x - \\left( e y_{S} + f \\right) \\Delta x \\right] = \\Delta x \\, e \\left( y_{N} - y_{S} \\right).\n$$\n因为 $y_{N} - y_{S} = \\Delta y$，我们有\n$$\n\\Phi_{N} + \\Phi_{S} = e \\, \\Delta x \\, \\Delta y.\n$$\n\n总向外通量：\n$$\n\\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell \\;=\\; \\left( \\Phi_{E} + \\Phi_{W} \\right) + \\left( \\Phi_{N} + \\Phi_{S} \\right) \\;=\\; a \\, \\Delta x \\, \\Delta y \\;+\\; e \\, \\Delta x \\, \\Delta y \\;=\\; \\left( a + e \\right) \\Delta x \\, \\Delta y.\n$$\n\n作为一致性检验，使用散度定理（高斯定理），对于具有恒定散度 $\\nabla \\cdot \\mathbf{u} = \\partial u_{x}/\\partial x + \\partial u_{y}/\\partial y = a + e$ 的线性场 $\\mathbf{u}(x,y)$，可得 $\\displaystyle \\oint_{\\partial \\Omega} \\mathbf{u} \\cdot \\hat{n} \\, d\\ell = \\iint_{\\Omega} \\nabla \\cdot \\mathbf{u} \\, dA = \\left( a + e \\right) \\, \\text{area}(\\Omega) = \\left( a + e \\right) \\Delta x \\Delta y$，这与上述逐边直接计算的结果一致。\n\n因此，该环路积分的精确闭合形式表达式为 $\\left( a + e \\right) \\Delta x \\Delta y$。", "answer": "$$\\boxed{(a+e)\\,\\Delta x\\,\\Delta y}$$", "id": "3297266"}, {"introduction": "现实世界中的许多CFD应用，如航空航天和涡轮机械，都涉及复杂的曲面几何。我们通常使用多边形网格（如三角形）来逼近这些曲面，但这会不可避免地在法向量的计算中引入离散误差。本练习旨在通过对一个标准球体进行逐步加密的三角形网格剖分，让你亲手量化离散法向量与精确解析法向量之间的角度误差，从而直观地体验网格精度如何影响几何表示的保真度。[@problem_id:3297286]", "problem": "您的任务是在计算流体动力学 (CFD) 的背景下，对光滑球面的三角化近似进行单位面法向量的原理性计算研究。在非结构化网格的有限体积离散化中，面法线方向对于通量计算至关重要。本练习要求从第一性原理出发，推导隐式定义球面的解析法向量，构建一系列逐步加密的三角化近似，并量化解析法向量与离散面法向量之间的角度差异。\n\n从基本定义开始：一个光滑曲面可以表示为标量场 $F(\\mathbf{x}) = 0$ 的一个水平集。在曲面上任意一点 $\\mathbf{x}$，若 $\\nabla F(\\mathbf{x}) \\neq \\mathbf{0}$，则该点的切向量位于线性泛函 $\\mathbf{t} \\mapsto \\nabla F(\\mathbf{x}) \\cdot \\mathbf{t}$ 的零空间中。因此，单位法向量平行于 $\\nabla F(\\mathbf{x})$，通过对其进行归一化得到。请将此原理应用于由 $F(\\mathbf{x}) = x^2 + y^2 + z^2 - R^2$ 隐式定义的球面，推导出其解析单位法向量，并确保其指向外侧。不要使用或假设任何已知的球面法向量封闭形式；相反，应从梯度定义中明确推导它。\n\n对于三角化近似，使用以下公认的几何构造方法。从一个内接于以原点为中心、半径为 $R$ 的球面中的正二十面体开始。执行 $s$ 次递归细分，定义如下：\n- 对每个具有顶点 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的三角面，计算各边的中点，将每个中点径向投影回半径为 $R$ 的球面上，然后将该面细分为 4 个子三角形。\n- 经过 $s$ 轮细分后，得到一个所有顶点都位于球面上的三角剖分。\n\n对于最终分辨率下的每个三角面：\n- 通过边向量的向量叉积和归一化计算朝外的单位面法向量。如果初始计算出的方向朝内（通过与面心的位置向量的点积为负来判断），则翻转其符号以强制其朝外。\n- 在球面上对应于面心（定义为面三个顶点的算术平均值）径向投影的点上，计算解析单位法向量。\n- 通过离散面单位法向量和解析单位法向量之间截断点积的反余弦，计算角度误差。角度必须以弧度为单位报告。\n\n对于所有面，使用以下精确定义的度量标准来量化角度误差分布：\n- 平均角度误差 $m = \\frac{1}{N}\\sum_{i=1}^{N} \\theta_i$。\n- 最大角度误差 $M = \\max_{i \\in \\{1,\\dots,N\\}} \\theta_i$。\n- 第 $95$ 百分位角度误差 $q_{95}$，根据传统百分位定义，该值为 $95\\%$ 的角度所低于的数值。\n- 均方根角度误差 $r = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\theta_i^2}$。\n\n角度必须以弧度表示。您的程序必须仅使用数值线性代数和几何学来实现上述整个流程，不得依赖任何网格库或外部文件。网格构造必须使用具有标准黄金比例坐标的正二十面体，并在每次插入中点后进行归一化并投影到半径为 $R$ 的球面上。\n\n测试套件：\n- 使用以下有序的 $(R,s)$ 测试用例集，其中 $R$ 是半径， $s$ 是细分层级数：\n    1. $(R = 1.0, s = 0)$,\n    2. $(R = 1.0, s = 1)$,\n    3. $(R = 1.0, s = 2)$,\n    4. $(R = 2.75, s = 3)$。\n- 对每个用例，计算并报告一个包含四个浮点值的列表 $[m, M, q_{95}, r]$，单位为弧度，每个值四舍五入到小数点后 $10$ 位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表，每个子列表对应一个测试用例，顺序与上述完全一致。例如，文本结构必须类似于 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4],[d_1,d_2,d_3,d_4]]$，其中每个符号代表一个四舍五入到小数点后 $10$ 位的浮点数。输出必须是单行，不含任何额外文本。", "solution": "我们从隐式曲面表示开始。设光滑曲面由 $F(\\mathbf{x}) = 0$ 给出，其中 $\\mathbf{x} \\in \\mathbb{R}^3$ 且在曲面上 $\\nabla F(\\mathbf{x}) \\neq \\mathbf{0}$。考虑位于曲面上的任意可微曲线 $\\mathbf{x}(t)$，使得在一个邻域内的所有 $t$ 都有 $F(\\mathbf{x}(t)) = 0$。对 $t$ 求导可得\n$$\n\\frac{d}{dt} F(\\mathbf{x}(t)) = \\nabla F(\\mathbf{x}(t)) \\cdot \\frac{d\\mathbf{x}}{dt} = 0.\n$$\n因此，对于任意切向量 $\\mathbf{t} = \\frac{d\\mathbf{x}}{dt}$，我们有 $\\nabla F(\\mathbf{x}) \\cdot \\mathbf{t} = 0$。所以，$\\nabla F(\\mathbf{x})$ 与点 $\\mathbf{x}$ 处的所有切向量正交，从而与曲面垂直。单位法向量通过归一化得到：\n$$\n\\hat{\\mathbf{n}}(\\mathbf{x}) = \\frac{\\nabla F(\\mathbf{x})}{\\lVert \\nabla F(\\mathbf{x}) \\rVert}.\n$$\n对于球面，取 $F(\\mathbf{x}) = x^2 + y^2 + z^2 - R^2$。那么\n$$\n\\nabla F(\\mathbf{x}) = \\begin{bmatrix} 2x \\\\ 2y \\\\ 2z \\end{bmatrix} = 2 \\mathbf{x}.\n$$\n在球面上，$\\lVert \\mathbf{x} \\rVert = R$，因此朝外的单位法向量是\n$$\n\\hat{\\mathbf{n}}_{\\text{analytic}}(\\mathbf{x}) = \\frac{2 \\mathbf{x}}{\\lVert 2 \\mathbf{x} \\rVert} = \\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert} = \\frac{\\mathbf{x}}{R}.\n$$\n此推导表明，球面上任意点的解析单位法向量都径向朝外，并且与任何特定的参数化无关。\n\n对于三角化近似，我们采用标准的“icosphere”（二十面体球面）构造方法：\n1. 初始化一个内接于单位球面的正二十面体。其 $12$ 个顶点可以使用黄金比例 $\\varphi = \\frac{1 + \\sqrt{5}}{2}$ 来定义，坐标形式为 $(\\pm 1, \\pm \\varphi, 0)$、$(0, \\pm 1, \\pm \\varphi)$ 和 $(\\pm \\varphi, 0, \\pm 1)$，然后归一化到单位长度。$20$ 个面通过一致的索引模式固定，以确保朝向一致。\n2. 对于每个细分层级 $s$，通过连接边的中点将每个三角面细分为 $4$ 个更小的三角形。每个中点 $\\mathbf{m} = \\frac{\\mathbf{u} + \\mathbf{v}}{2}$（对于边端点 $\\mathbf{u}$ 和 $\\mathbf{v}$）通过映射 $\\mathbf{m} \\mapsto R \\frac{\\mathbf{m}}{\\lVert \\mathbf{m} \\rVert}$ 被径向投影回半径为 $R$ 的球面上。对边使用去重映射确保每个边的中点顶点只被创建一次。这在加密过程中保持了球面几何形状。\n\n对于一个给定的面，其顶点 $\\mathbf{a}, \\mathbf{b}, \\mathbf{c}$ 位于以原点为中心、半径为 $R$ 的球面上：\n- 离散面单位法向量由边向量 $\\mathbf{e}_1 = \\mathbf{b} - \\mathbf{a}$ 和 $\\mathbf{e}_2 = \\mathbf{c} - \\mathbf{a}$ 通过叉积 $\\mathbf{n} = \\mathbf{e}_1 \\times \\mathbf{e}_2$ 计算得出。归一化得到 $\\hat{\\mathbf{n}}_{\\text{face}} = \\frac{\\mathbf{n}}{\\lVert \\mathbf{n} \\rVert}$。为确保朝外，计算（未投影的）面心 $\\mathbf{g} = \\frac{1}{3}(\\mathbf{a} + \\mathbf{b} + \\mathbf{c})$ 并强制 $\\hat{\\mathbf{n}}_{\\text{face}} \\cdot \\mathbf{g} \\ge 0$；如果不满足，则翻转符号：$\\hat{\\mathbf{n}}_{\\text{face}} \\leftarrow -\\hat{\\mathbf{n}}_{\\text{face}}$。\n- 解析单位法向量在面心到球面的径向投影点 $\\mathbf{x}_c = R \\frac{\\mathbf{g}}{\\lVert \\mathbf{g} \\rVert}$ 处进行评估。根据上述推导，$\\hat{\\mathbf{n}}_{\\text{analytic}}(\\mathbf{x}_c) = \\frac{\\mathbf{x}_c}{R} = \\frac{\\mathbf{g}}{\\lVert \\mathbf{g} \\rVert}$，这揭示了其方向与 $R$ 无关。\n\n定义一个面的角度误差为\n$$\n\\theta = \\arccos\\!\\left( \\operatorname{clip}\\left( \\hat{\\mathbf{n}}_{\\text{face}} \\cdot \\hat{\\mathbf{n}}_{\\text{analytic}}, -1, 1 \\right) \\right),\n$$\n以弧度为单位。由于两个输入都是单位向量且被截断，所以 $\\theta \\in [0, \\pi]$。\n\n对于所有面 $\\{\\theta_i\\}_{i=1}^N$，计算：\n- 平均值：$m = \\frac{1}{N} \\sum_{i=1}^N \\theta_i$。\n- 最大值：$M = \\max_i \\theta_i$。\n- 百分位数：$q_{95}$ 为经验第 $95$ 百分位数。\n- 均方根：$r = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\theta_i^2 }$。\n\n值得注意的是，角度误差分布在 $R$ 的均匀缩放变换下是不变的，因为法向量都是方向向量。尽管如此，测试用例中包含了不同的 $R$ 值，以在数值精度范围内验证这种尺度不变性。\n\n算法注意事项：\n- 经过 $s$ 次细分后，二十面体球面有 $20 \\cdot 4^s$ 个面，因此 $s \\in \\{0,1,2,3\\}$ 产生的面数 $N \\in \\{20,80,320,1280\\}$，这在计算上是可行的。\n- 中点去重使用一个哈希映射，其键为排序后的边端点索引，以避免重复创建顶点。\n- 所有向量归一化操作都防止了除零错误；对于一个构造良好的二十面体球面，不会出现退化情况。\n\n测试套件说明：\n- 按顺序执行四个用例：$(R,s) \\in \\{(1.0,0),(1.0,1),(1.0,2),(2.75,3)\\}$。\n- 对每个用例，计算并输出 $[m, M, q_{95}, r]$，单位为弧度，每个值四舍五入到小数点后 $10$ 位。\n\n最终输出说明：\n- 精确打印一行，其中包含按指定顺序排列的列表的列表形式的总体结果。例如，输出的文本形式将是 $[[0.0000000000,0.1000000000,0.0900000000,0.0600000000],\\dots]$，其中每个浮点数都四舍五入到小数点后 $10$ 位，并且没有额外的字符或换行符。\n\n该过程严谨地将通过梯度定义法向量的基本原理与三角化网格上面法向量的实际计算联系起来，并量化了离散化引入的角度误差。", "answer": "```python\nimport numpy as np\n\ndef icosahedron():\n    \"\"\"\n    Construct a unit icosahedron.\n    Returns:\n        V (np.ndarray): (12,3) array of vertex positions on the unit sphere.\n        F (np.ndarray): (20,3) array of triangular face indices (int).\n    \"\"\"\n    phi = (1.0 + np.sqrt(5.0)) / 2.0\n    verts = np.array([\n        [-1,  phi,  0],\n        [ 1,  phi,  0],\n        [-1, -phi,  0],\n        [ 1, -phi,  0],\n        [ 0, -1,  phi],\n        [ 0,  1,  phi],\n        [ 0, -1, -phi],\n        [ 0,  1, -phi],\n        [ phi,  0, -1],\n        [ phi,  0,  1],\n        [-phi,  0, -1],\n        [-phi,  0,  1],\n    ], dtype=float)\n\n    # Normalize to unit sphere\n    V = verts / np.linalg.norm(verts, axis=1)[:, None]\n\n    F = np.array([\n        [0, 11, 5],\n        [0, 5, 1],\n        [0, 1, 7],\n        [0, 7, 10],\n        [0, 10, 11],\n        [1, 5, 9],\n        [5, 11, 4],\n        [11, 10, 2],\n        [10, 7, 6],\n        [7, 1, 8],\n        [3, 9, 4],\n        [3, 4, 2],\n        [3, 2, 6],\n        [3, 6, 8],\n        [3, 8, 9],\n        [4, 9, 5],\n        [2, 4, 11],\n        [6, 2, 10],\n        [8, 6, 7],\n        [9, 8, 1],\n    ], dtype=int)\n    return V, F\n\ndef normalize_rows(X, eps=1e-15):\n    nrm = np.linalg.norm(X, axis=1, keepdims=True)\n    nrm = np.maximum(nrm, eps)\n    return X / nrm\n\ndef subdivide_icosphere(V, F, levels, R):\n    \"\"\"\n    Subdivide an icosahedron-based sphere mesh 'levels' times.\n    Vertices are kept on the sphere of radius R by radial projection.\n    Args:\n        V (np.ndarray): (n,3) vertices on unit sphere initially.\n        F (np.ndarray): (m,3) faces.\n        levels (int): number of subdivision levels.\n        R (float): sphere radius.\n    Returns:\n        V_out (np.ndarray): vertices on sphere of radius R.\n        F_out (np.ndarray): faces.\n    \"\"\"\n    # Start with vertices on sphere of radius R\n    V = normalize_rows(V) * R\n    F = F.copy()\n\n    for _ in range(levels):\n        edge_mid_cache = {}\n        new_faces = []\n\n        def get_midpoint(i, j):\n            key = (i, j) if i  j else (j, i)\n            if key in edge_mid_cache:\n                return edge_mid_cache[key]\n            vi = V[i]\n            vj = V[j]\n            m = (vi + vj) * 0.5\n            # Radial project to sphere of radius R\n            m = m / (np.linalg.norm(m) + 1e-30) * R\n            idx = len(V_list)\n            V_list.append(m)\n            edge_mid_cache[key] = idx\n            return idx\n\n        V_list = [v for v in V]\n        for a, b, c in F:\n            ab = get_midpoint(a, b)\n            bc = get_midpoint(b, c)\n            ca = get_midpoint(c, a)\n            # Create 4 new faces\n            new_faces.append([a, ab, ca])\n            new_faces.append([b, bc, ab])\n            new_faces.append([c, ca, bc])\n            new_faces.append([ab, bc, ca])\n\n        V = np.array(V_list, dtype=float)\n        F = np.array(new_faces, dtype=int)\n\n    return V, F\n\ndef face_normals_outward(V, F):\n    \"\"\"\n    Compute outward-oriented unit face normals for triangles with vertices V and faces F.\n    Uses centroid direction to enforce outward orientation for origin-centered sphere.\n    Args:\n        V (np.ndarray): (n,3) vertices.\n        F (np.ndarray): (m,3) faces, integer indices.\n    Returns:\n        normals (np.ndarray): (m,3) unit normals oriented outward.\n        centroids (np.ndarray): (m,3) centroids of each face (not projected).\n    \"\"\"\n    A = V[F[:, 0], :]\n    B = V[F[:, 1], :]\n    C = V[F[:, 2], :]\n\n    E1 = B - A\n    E2 = C - A\n    N = np.cross(E1, E2)\n    # Normalize normals\n    N = normalize_rows(N)\n    # Face centroids\n    G = (A + B + C) / 3.0\n    # Ensure outward direction for origin-centered sphere\n    s = np.sign(np.sum(N * G, axis=1))\n    s[s == 0] = 1.0\n    N = N * s[:, None]\n    return N, G\n\ndef analytic_normals_at_centroids(G):\n    \"\"\"\n    Compute analytic unit normals at radial projection of centroids G onto sphere.\n    Since the sphere is centered at the origin, the analytic normal at projected centroid\n    is simply the normalized centroid direction.\n    Args:\n        G (np.ndarray): (m,3) centroids (not necessarily on sphere).\n    Returns:\n        A (np.ndarray): (m,3) analytic unit normals.\n    \"\"\"\n    return normalize_rows(G)\n\ndef angular_errors(N_face, N_analytic):\n    \"\"\"\n    Compute angular errors in radians between corresponding unit normals.\n    Args:\n        N_face (np.ndarray): (m,3) face unit normals.\n        N_analytic (np.ndarray): (m,3) analytic unit normals.\n    Returns:\n        angles (np.ndarray): (m,) angles in radians.\n    \"\"\"\n    dots = np.sum(N_face * N_analytic, axis=1)\n    dots = np.clip(dots, -1.0, 1.0)\n    return np.arccos(dots)\n\ndef metrics_from_angles(angles):\n    \"\"\"\n    Compute [mean, max, 95th percentile, RMS] for the angle distribution.\n    Args:\n        angles (np.ndarray): (m,) angles in radians.\n    Returns:\n        tuple: (mean, max, p95, rms)\n    \"\"\"\n    mean = float(np.mean(angles))\n    maxv = float(np.max(angles))\n    p95 = float(np.percentile(angles, 95.0))\n    rms = float(np.sqrt(np.mean(angles**2)))\n    return mean, maxv, p95, rms\n\ndef run_case(R, s):\n    V0, F0 = icosahedron()\n    V, F = subdivide_icosphere(V0, F0, s, R)\n    N_face, G = face_normals_outward(V, F)\n    N_analytic = analytic_normals_at_centroids(G)\n    angles = angular_errors(N_face, N_analytic)\n    return metrics_from_angles(angles)\n\ndef solve():\n    # Define the test suite as specified: ordered (R, s) pairs.\n    test_cases = [\n        (1.0, 0),\n        (1.0, 1),\n        (1.0, 2),\n        (2.75, 3),\n    ]\n\n    results = []\n    for R, s in test_cases:\n        m, M, q95, r = run_case(R, s)\n        # Round to 10 decimal places as strings\n        results.append([\n            f\"{m:.10f}\",\n            f\"{M:.10f}\",\n            f\"{q95:.10f}\",\n            f\"{r:.10f}\",\n        ])\n\n    # Print as a single line list of lists\n    # Ensure no spaces to strictly follow a compact single-line format.\n    inner = \",\".join(\n        \"[\" + \",\".join(vals) + \"]\" for vals in results\n    )\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3297286"}, {"introduction": "在实际的CFD前处理中，生成的网格单元面，特别是四边形或多边形面，并非总是严格共面的。这种几何上的不完美给计算带来了挑战，因为一个“有效”的面法向量和面积需要被恰当地定义。本练习将引导你探索并比较两种处理非平面四边形的主流方法，通过编程实现并量化它们之间的差异，这对于开发或使用能够处理真实、非理想网格的CFD软件至关重要。[@problem_id:3297351]", "problem": "考虑一个嵌入在三维欧几里得空间中的四边形面，由四个顶点按顺序表示，形成一个简单多边形。在计算流体动力学（CFD）中，基于面的通量计算依赖于面法向量和面面积。对于非平面，存在两种构建“有效”面积向量的原则性方法：对离散化曲面的定向三角形面积向量进行求和，以及将拟合平面的单位法向量与在该平面上正交投影得到的标量面积相乘。本问题要求您从第一性原理推导这两种构造方法，实现它们，并在一组指定的扭曲四边形测试套件上量化它们的差异。\n\n请使用以下基本依据和定义。\n\n1. 设该面为一个光滑曲面片，其参数表示为 $\\mathbf{r}(u,v)$，其定向面积向量为\n$$\n\\mathbf{A} \\equiv \\iint_{S} \\mathbf{n}\\, \\mathrm{d}S,\n$$\n其中 $\\mathbf{n}$ 是曲面的单位法向量，$\\mathrm{d}S$ 是标量微分面积元。对于一个具有恒定单位法向量 $\\mathbf{n}_{\\mathrm{pl}}$ 的平面多边形面，$\\mathbf{A} = \\mathbf{n}_{\\mathrm{pl}}\\, A_{\\mathrm{pl}}$，其中 $A_{\\mathrm{pl}}$ 是该多边形的标量面积。\n\n2. 对于一个四边形面的离散三角化，将其分为两个三角形，顶点分别为 $(\\mathbf{p}_0,\\mathbf{p}_1,\\mathbf{p}_2)$ 和 $(\\mathbf{p}_0,\\mathbf{p}_2,\\mathbf{p}_3)$。每个三角形的定向面积向量定义为其两条边向量叉积的一半，总三角化面积向量是它们的和。\n\n3. 为对一组点 $\\{\\mathbf{p}_i\\}_{i=0}^{3}$ 进行平面拟合，定义形心 $\\bar{\\mathbf{p}}$，并最小化这些点到通过 $\\bar{\\mathbf{p}}$ 的平面的正交距离的平方和。拟合平面的最小二乘单位法向量 $\\hat{\\mathbf{n}}$ 是去均值坐标的 $3\\times 3$ 协方差矩阵的与最小特征值相关联的单位特征向量。四边形在拟合平面上的标量投影面积 $A_{\\mathrm{proj}}$ 是该多边形在该平面上正交投影的有向面积。\n\n从这些基础出发，推导计算以下向量的算法：\n- 基于三角化的面积向量，记为 $\\mathbf{A}_{\\triangle}$。\n- 基于拟合平面的面积向量，记为 $\\mathbf{A}_{\\mathrm{fit}} \\equiv \\hat{\\mathbf{n}}\\, A_{\\mathrm{proj}}$，其中 $\\hat{\\mathbf{n}}$ 的符号选择应使 $\\hat{\\mathbf{n}}\\cdot \\mathbf{A}_{\\triangle}$ 最大化。\n\n对每个面，使用以下指标量化两种构造方法之间的差异：\n- 差值的欧几里得范数，$\\Delta \\equiv \\lVert \\mathbf{A}_{\\triangle} - \\mathbf{A}_{\\mathrm{fit}} \\rVert$。\n- 相对大小误差，$\\varepsilon \\equiv \\dfrac{\\lVert \\mathbf{A}_{\\triangle} \\rVert - \\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}{\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}$。\n- 向量间的夹角，$\\theta \\equiv \\arccos\\!\\left(\\dfrac{\\mathbf{A}_{\\triangle}\\cdot \\mathbf{A}_{\\mathrm{fit}}}{\\lVert \\mathbf{A}_{\\triangle} \\rVert \\,\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\\right)$，以弧度表示。如果任一向量的大小为零，则定义 $\\theta$ 为 $0$。\n\n实现一个程序，对下面的每个测试用例，使用上述推导计算 $[\\Delta,\\ \\varepsilon,\\ \\theta]$。使用给定的顶点顺序；使用在拟合平面上的正交投影来计算 $A_{\\mathrm{proj}}$；角度以弧度表示；不涉及物理单位。每个测试用例的输出必须是一个包含三个浮点数的列表。您的程序应生成单行输出，其中包含一个由列表组成的逗号分隔列表，并用方括号括起来，例如 \"[[a,b,c],[d,e,f],...]\"。\n\n四个四边形面的测试套件（每个都是一个包含四个顶点的列表，按顺序排列）：\n1. 在 $z=0$ 平面上的平面矩形：$\\left[(0,0,0),(2,0,0),(2,1,0),(0,1,0)\\right]$。\n2. 轻度扭曲四边形：$\\left[(0,0,0),(1,0,0.1),(1,1,-0.1),(0,1,0)\\right]$。\n3. 严重扭曲四边形：$\\left[(0,0,0),(2,0,0.5),(2,2,-0.6),(0,2,0.4)\\right]$。\n4. 近似退化但平面的细长四边形：$\\left[(0,0,0),(10^{-6},0,0),(10^{-6},1,0),(0,1,0)\\right]$。\n\n您的程序必须为每个案例计算列表 $[\\Delta,\\ \\varepsilon,\\ \\theta]$，并打印单行结果，该结果将这些列表聚合为一个逗号分隔的列表，并用方括号括起来，格式与 \"[[result_case1],[result_case2],[result_case3],[result_case4]]\" 完全相同。", "solution": "核心任务是为一个由三维空间中四个有序顶点 $\\{\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$ 定义的四边形面，计算并比较两种面积向量的定义。\n\n**1. 基于三角化的面积向量 ($\\mathbf{A}_{\\triangle}$) 的推导**\n\n该构造将面积向量定义为构成四边形的两个三角形的面积向量之和。问题指定使用连接顶点 $\\mathbf{p}_0$ 和 $\\mathbf{p}_2$ 的对角线进行三角化。这形成了两个三角形，即顶点为 $(\\mathbf{p}_0, \\mathbf{p}_1, \\mathbf{p}_2)$ 的 $T_1$ 和顶点为 $(\\mathbf{p}_0, \\mathbf{p}_2, \\mathbf{p}_3)$ 的 $T_2$。\n\n三角形的定向面积向量由其两条边向量叉积的一半给出。对于 $T_1$，我们使用从 $\\mathbf{p}_0$ 出发的边向量，即 $(\\mathbf{p}_1 - \\mathbf{p}_0)$ 和 $(\\mathbf{p}_2 - \\mathbf{p}_0)$。其面积向量 $\\mathbf{A}_1$ 为：\n$$\n\\mathbf{A}_1 = \\frac{1}{2} (\\mathbf{p}_1 - \\mathbf{p}_0) \\times (\\mathbf{p}_2 - \\mathbf{p}_0)\n$$\n\n类似地，对于 $T_2$，我们使用边向量 $(\\mathbf{p}_2 - \\mathbf{p}_0)$ 和 $(\\mathbf{p}_3 - \\mathbf{p}_0)$。其面积向量 $\\mathbf{A}_2$ 为：\n$$\n\\mathbf{A}_2 = \\frac{1}{2} (\\mathbf{p}_2 - \\mathbf{p}_0) \\times (\\mathbf{p}_3 - \\mathbf{p}_0)\n$$\n\n总的基于三角化的面积向量 $\\mathbf{A}_{\\triangle}$ 是 $\\mathbf{A}_1$ 和 $\\mathbf{A}_2$ 的向量和：\n$$\n\\mathbf{A}_{\\triangle} = \\mathbf{A}_1 + \\mathbf{A}_2 = \\frac{1}{2} \\left[ (\\mathbf{p}_1 - \\mathbf{p}_0) \\times (\\mathbf{p}_2 - \\mathbf{p}_0) + (\\mathbf{p}_2 - \\mathbf{p}_0) \\times (\\mathbf{p}_3 - \\mathbf{p}_0) \\right]\n$$\n此公式为根据顶点坐标计算 $\\mathbf{A}_{\\triangle}$ 提供了一个直接的算法。\n\n**2. 基于拟合平面的面积向量 ($\\mathbf{A}_{\\mathrm{fit}}$) 的推导**\n\n该构造方法涉及为四个顶点找到一个最佳拟合平面，然后计算四边形在该平面上投影的面积。最终的面积向量是该投影面积与平面单位法向量的乘积。\n\n**步骤 2.1：通过主成分分析 (PCA) 进行平面拟合**\n为了找到点集 $\\{\\mathbf{p}_i\\}_{i=0}^3$ 的最佳拟合平面，我们最小化这些点到平面的正交距离的平方和。这是主成分分析 (PCA) 的一个经典应用。\n\n首先，我们计算顶点的形心：\n$$\n\\bar{\\mathbf{p}} = \\frac{1}{4} \\sum_{i=0}^{3} \\mathbf{p}_i\n$$\n\n接下来，我们找到去均值坐标（相对于形心的坐标）：\n$$\n\\mathbf{q}_i = \\mathbf{p}_i - \\bar{\\mathbf{p}}\n$$\n\n然后我们构造 $3 \\times 3$ 的协方差矩阵（或散布矩阵）$C$：\n$$\nC = \\sum_{i=0}^{3} \\mathbf{q}_i \\mathbf{q}_i^T\n$$\n如果 $Q$ 是一个 $4 \\times 3$ 的矩阵，其行是向量 $\\mathbf{q}_i^T$，那么 $C = Q^T Q$。最佳拟合平面的单位法向量 $\\hat{\\mathbf{n}}$ 是 $C$ 的对应于其最小特征值的单位特征向量。该特征向量表示点云方差最小的方向，该方向与最大方差平面正交。\n\n**步骤 2.2：法向量的定向**\n特征求解器将返回一个单位特征向量 $\\hat{\\mathbf{n}}_{\\text{eig}}$，但其方向（符号）是任意的。问题规定，必须选择符号以最大化点积 $\\hat{\\mathbf{n}} \\cdot \\mathbf{A}_{\\triangle}$。这确保了两种面积向量定义之间的一致性。我们首先计算 $\\mathbf{A}_{\\triangle}$ 和一个初始的 $\\hat{\\mathbf{n}}_{\\text{eig}}$。然后，确定方向正确的法向量 $\\hat{\\mathbf{n}}$：\n$$\n\\hat{\\mathbf{n}} = \\begin{cases} \\hat{\\mathbf{n}}_{\\text{eig}}  \\text{if } \\hat{\\mathbf{n}}_{\\text{eig}} \\cdot \\mathbf{A}_{\\triangle} \\ge 0 \\\\ -\\hat{\\mathbf{n}}_{\\text{eig}}  \\text{if } \\hat{\\mathbf{n}}_{\\text{eig}} \\cdot \\mathbf{A}_{\\triangle}  0 \\end{cases}\n$$\n\n**步骤 2.3：投影面积 ($A_{\\mathrm{proj}}$) 的计算**\n标量面积 $A_{\\mathrm{proj}}$ 是四边形在拟合平面上正交投影的有向面积。为了计算它，我们为该平面建立一个二维正交基 $\\{\\mathbf{u}_1, \\mathbf{u}_2\\}$。一个稳健的基选择可以由协方差矩阵 $C$ 的其他特征向量构成。设对应于最大和中间特征值的单位特征向量分别为 $\\mathbf{e}_{\\text{large}}$ 和 $\\mathbf{e}_{\\text{mid}}$。我们可以设置 $\\mathbf{u}_1 = \\mathbf{e}_{\\text{large}}$，并通过定义 $\\mathbf{u}_2 = \\hat{\\mathbf{n}} \\times \\mathbf{u}_1$ 来形成一个右手坐标系 $\\{\\mathbf{u}_1, \\mathbf{u}_2, \\hat{\\mathbf{n}}\\}$。\n\n每个投影顶点在这个新基中的二维坐标（相对于形心）是：\n$$\n(u_i, v_i) = (\\mathbf{q}_i \\cdot \\mathbf{u}_1, \\mathbf{q}_i \\cdot \\mathbf{u}_2)\n$$\n\n得到的二维多边形 $\\{(u_0, v_0), (u_1, v_1), (u_2, v_2), (u_3, v_3)\\}$ 的有向面积使用鞋带公式计算：\n$$\nA_{\\mathrm{proj}} = \\frac{1}{2} \\sum_{i=0}^{3} (u_i v_{i+1} - u_{i+1} v_i)\n$$\n其中索引 $4$ 被视为 $0$（即 $(u_4, v_4) = (u_0, v_0)$）。\n\n**步骤 2.4：组合 $\\mathbf{A}_{\\mathrm{fit}}$**\n最后，通过组合有向标量面积和定向单位法向量来构造基于拟合平面的面积向量：\n$$\n\\mathbf{A}_{\\mathrm{fit}} = A_{\\mathrm{proj}} \\hat{\\mathbf{n}}\n$$\n\n**3. 差异量化**\n\n在计算出 $\\mathbf{A}_{\\triangle}$ 和 $\\mathbf{A}_{\\mathrm{fit}}$ 后，我们使用指定的度量标准来量化它们之间的差异。\n\n- 差值的欧几里得范数：\n$$\n\\Delta = \\lVert \\mathbf{A}_{\\triangle} - \\mathbf{A}_{\\mathrm{fit}} \\rVert\n$$\n\n- 相对大小误差：\n$$\n\\varepsilon = \\frac{\\lVert \\mathbf{A}_{\\triangle} \\rVert - \\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}{\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\n$$\n这在 $\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert \\neq 0$ 的条件下计算。\n\n- 向量间的夹角，以弧度为单位：\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{A}_{\\triangle}\\cdot \\mathbf{A}_{\\mathrm{fit}}}{\\lVert \\mathbf{A}_{\\triangle} \\rVert \\,\\lVert \\mathbf{A}_{\\mathrm{fit}} \\rVert}\\right)\n$$\n这在两个向量的大小都非零的条件下计算。根据问题陈述，如果任一向量是零向量，我们定义 $\\theta = 0$。为了数值稳定性，$\\arccos$ 的参数应被截断到 $[-1, 1]$ 范围内。\n\n这些步骤为解决该问题提供了一个完整而严谨的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares two types of area vectors for quadrilateral faces\n    and prints the discrepancy metrics for a suite of test cases.\n    \"\"\"\n    # Test suite of four quadrilateral faces (each is a list of four vertices, in order).\n    # Vertices are given as lists of tuples and converted to numpy arrays.\n    test_cases_raw = [\n        [(0,0,0),(2,0,0),(2,1,0),(0,1,0)],\n        [(0,0,0),(1,0,0.1),(1,1,-0.1),(0,1,0)],\n        [(0,0,0),(2,0,0.5),(2,2,-0.6),(0,2,0.4)],\n        [(0,0,0),(1e-6,0,0),(1e-6,1,0),(0,1,0)],\n    ]\n    test_cases = [np.array(case, dtype=float) for case in test_cases_raw]\n\n    results = []\n    for quad_vertices in test_cases:\n        # --- 1. Compute Triangulation-based Area Vector (A_triangle) ---\n        p0, p1, p2, p3 = quad_vertices[0], quad_vertices[1], quad_vertices[2], quad_vertices[3]\n        \n        vec1 = p1 - p0\n        vec2 = p2 - p0\n        vec3 = p3 - p0\n\n        area_vec1 = 0.5 * np.cross(vec1, vec2)\n        area_vec2 = 0.5 * np.cross(vec2, vec3)\n        A_triangle = area_vec1 + area_vec2\n\n        # --- 2. Compute Fitted-plane-based Area Vector (A_fit) ---\n\n        # 2.1. Plane Fitting via PCA\n        centroid = np.mean(quad_vertices, axis=0)\n        demeaned_pts = quad_vertices - centroid\n        \n        # Covariance matrix C = Q^T Q, where Q is the 4x3 matrix of demeaned points\n        cov_matrix = demeaned_pts.T @ demeaned_pts\n        \n        # eigh for symmetric matrices; returns eigenvalues in ascending order\n        eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)\n        \n        # The normal is the eigenvector for the smallest eigenvalue\n        n_eig = eigenvectors[:, 0]\n\n        # 2.2. Orient the Normal Vector\n        if np.dot(n_eig, A_triangle)  0:\n            n_hat = -n_eig\n        else:\n            n_hat = n_eig\n\n        # 2.3. Calculate Projected Area (A_proj)\n        # Form an orthonormal basis for the plane\n        u1_eig = eigenvectors[:, 2]  # Eigenvector for largest eigenvalue\n        u1 = u1_eig / np.linalg.norm(u1_eig)\n        u2 = np.cross(n_hat, u1) # Guarantees a right-handed system {u1, u2, n_hat}\n\n        # Project demeaned points onto the 2D basis\n        coords_2d = np.array([(np.dot(q, u1), np.dot(q, u2)) for q in demeaned_pts])\n        u, v = coords_2d[:, 0], coords_2d[:, 1]\n        \n        # Shoelace formula for signed area of projected 2D polygon\n        A_proj = 0.5 * (u[0]*v[1] - u[1]*v[0] + \n                         u[1]*v[2] - u[2]*v[1] + \n                         u[2]*v[3] - u[3]*v[2] + \n                         u[3]*v[0] - u[0]*v[3])\n\n        # 2.4. Assemble A_fit\n        A_fit = A_proj * n_hat\n\n        # --- 3. Quantify Discrepancy ---\n        \n        # Delta: Euclidean norm of the difference\n        delta = np.linalg.norm(A_triangle - A_fit)\n\n        # Epsilon: Relative magnitude error\n        norm_A_triangle = np.linalg.norm(A_triangle)\n        norm_A_fit = np.linalg.norm(A_fit)\n        \n        if np.isclose(norm_A_fit, 0.0):\n            # If fitted area is zero, relative error is infinite if triangle area is non-zero\n            epsilon = np.inf if not np.isclose(norm_A_triangle, 0.0) else 0.0\n        else:\n            epsilon = (norm_A_triangle - norm_A_fit) / norm_A_fit\n\n        # Theta: Angle between vectors\n        if np.isclose(norm_A_triangle, 0.0) or np.isclose(norm_A_fit, 0.0):\n            theta = 0.0\n        else:\n            dot_product = np.dot(A_triangle, A_fit)\n            # Clip for numerical stability to prevent arccos domain errors\n            cos_theta = np.clip(dot_product / (norm_A_triangle * norm_A_fit), -1.0, 1.0)\n            theta = np.arccos(cos_theta)\n\n        results.append([delta, epsilon, theta])\n\n    # Final print statement in the exact required format.\n    # The format requires a string representation of a list of lists.\n    results_str = ','.join([f\"[{d},{e},{t}]\" for d, e, t in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3297351"}]}