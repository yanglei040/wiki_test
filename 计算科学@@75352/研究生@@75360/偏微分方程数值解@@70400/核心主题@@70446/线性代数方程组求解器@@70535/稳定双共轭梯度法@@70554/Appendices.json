{"hands_on_practices": [{"introduction": "要真正掌握一个复杂的数值算法，最好的方法莫过于亲手执行其每一个步骤。本练习提供了一个具体的数值算例，引导你完整地追踪双共轭梯度稳定（BiCGSTAB）方法的一次迭代过程 [@problem_id:3585874]。通过为一个小规模的线性系统手动计算每一步中的标量和向量，你将清晰地理解该算法的内在逻辑和数据流。", "problem": "考虑线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是非奇异矩阵。克雷洛夫子空间方法通过在低维子空间中根据诸如彼得罗夫-伽辽金条件和残差最小化等原则对残差 $r_{k} = b - A x_{k}$ 进行投影来构造近似解 $x_{k}$。双共轭梯度稳定方法（BiCGSTAB）是通过将双共轭梯度（BiCG）方法的双正交投影特性与局部残差最小化稳定步相结合而得到的。\n\n从以下经过充分检验的原则出发：\n- 欧几里得内积为 $\\langle u, v \\rangle = u^{\\top} v$，欧几里得（二-）范数为 $\\|u\\|_{2} = \\sqrt{\\langle u, u \\rangle}$。\n- 带有固定非零“影子残差” $\\tilde r$ 的彼得罗夫-伽辽金投影，对于通过搜索方向更新得到的中间残差，强制满足 $\\langle \\tilde r, r_{k+1} \\rangle = 0$。\n- 给定一个非零的中间残差 $s_{k}$，在 $\\omega \\in \\mathbb{R}$ 上使 $\\|s_{k} - \\omega A s_{k}\\|_{2}$ 最小化的标量 $\\omega_{k}$ 由最小二乘问题产生的正规方程确定。\n\n使用这些原则，对以下特定数据执行一整轮双共轭梯度稳定（BiCGSTAB）方法的迭代：\n$$\nA = \\begin{bmatrix}2  -1 \\\\ 1  3\\end{bmatrix}, \\quad\nb = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}, \\quad\nx_{0} = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}, \\quad\n\\tilde r = r_{0},\n$$\n采用标准初始化 $r_{0} = b - A x_{0}$ 和 $p_{0} = r_{0}$。数值计算标量和向量\n$$\n\\rho_{0}, \\ \\alpha_{0}, \\ s_{0}, \\ \\omega_{0}, \\ x_{1}, \\ r_{1}, \\ p_{1}.\n$$\n\n答案要求：\n- 使用标准的欧几里得内积 $\\langle u, v \\rangle = u^{\\top} v$。\n- 作为最终报告量，提供单一标量值 $\\|r_{1}\\|_{2}^{2}$，其形式为最简精确有理数。\n- 不要四舍五入；由于要求精确有理数答案，因此不需要有效数字指令。", "solution": "问题陈述经评估有效。它在科学上基于数值线性代数的既定原则，特别是双共轭梯度稳定（BiCGSTAB）方法。该问题是适定的，为算法的一次完整迭代提供了所有必要的数据。数据和目标是客观陈述的，没有矛盾或歧义。因此，我将继续进行解答。\n\n任务是为给定的线性系统 $A x = b$ 执行一整轮 BiCGSTAB 方法的迭代。该算法由一系列明确定义的步骤组成。我们从索引 $k=0$ 开始。\n\n**步骤 0：初始化**\n\n解的初始猜测值为 $x_{0} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n初始残差 $r_{0}$ 计算为 $r_{0} = b - A x_{0}$。\n给定 $A = \\begin{bmatrix} 2  -1 \\\\ 1  3 \\end{bmatrix}$ 和 $b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$：\n$A x_{0} = \\begin{bmatrix} 2  -1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n因此，$r_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} - \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n问题指定初始“影子残差”为 $\\tilde{r}_{0} = r_{0}$，所以 $\\tilde{r}_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n初始搜索方向为 $p_{0} = r_{0}$，所以 $p_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n**迭代 $k=0$**\n\n1.  **计算 $\\rho_{0}$：**\n    标量 $\\rho_{0}$ 由内积 $\\rho_{0} = \\langle \\tilde{r}_{0}, r_{0} \\rangle$ 定义。\n    使用欧几里得内积 $\\langle u, v \\rangle = u^{\\top} v$：\n    $\\rho_{0} = r_{0}^{\\top} r_{0} = \\begin{bmatrix} 1  0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = (1)(1) + (0)(0) = 1$。\n\n2.  **计算 $v_{0} = A p_{0}$：**\n    $v_{0} = \\begin{bmatrix} 2  -1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} (2)(1) + (-1)(0) \\\\ (1)(1) + (3)(0) \\end{bmatrix} = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}$。\n\n3.  **计算 $\\alpha_{0}$：**\n    标量 $\\alpha_{0}$ 从中间更新的彼得罗夫-伽辽金条件导出，得到 $\\alpha_{0} = \\frac{\\rho_{0}}{\\langle \\tilde{r}_{0}, v_{0} \\rangle}$。\n    分母中的内积为：\n    $\\langle \\tilde{r}_{0}, v_{0} \\rangle = \\tilde{r}_{0}^{\\top} v_{0} = \\begin{bmatrix} 1  0 \\end{bmatrix} \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} = (1)(2) + (0)(1) = 2$。\n    因此，$\\alpha_{0} = \\frac{1}{2}$。\n\n4.  **计算中间残差 $s_{0}$：**\n    $s_{0} = r_{0} - \\alpha_{0} v_{0}$。\n    $s_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} - \\frac{1}{2} \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} - \\begin{bmatrix} 1 \\\\ 1/2 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -1/2 \\end{bmatrix}$。\n\n5.  **计算 $t_{0} = A s_{0}$：**\n    $t_{0} = \\begin{bmatrix} 2  -1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ -1/2 \\end{bmatrix} = \\begin{bmatrix} (2)(0) + (-1)(-1/2) \\\\ (1)(0) + (3)(-1/2) \\end{bmatrix} = \\begin{bmatrix} 1/2 \\\\ -3/2 \\end{bmatrix}$。\n\n6.  **计算 $\\omega_{0}$：**\n    选择标量 $\\omega_{0}$ 以最小化 $\\|s_{0} - \\omega A s_{0}\\|_{2}$，这等价于最小化 $\\|s_{0} - \\omega t_{0}\\|_{2}$。这个最小二乘问题的解由正规方程给出，得到 $\\omega_{0} = \\frac{\\langle s_{0}, t_{0} \\rangle}{\\langle t_{0}, t_{0} \\rangle}$。\n    首先，我们计算必要的内积：\n    $\\langle s_{0}, t_{0} \\rangle = s_{0}^{\\top} t_{0} = \\begin{bmatrix} 0  -1/2 \\end{bmatrix} \\begin{bmatrix} 1/2 \\\\ -3/2 \\end{bmatrix} = (0)(1/2) + (-1/2)(-3/2) = \\frac{3}{4}$。\n    $\\langle t_{0}, t_{0} \\rangle = t_{0}^{\\top} t_{0} = \\begin{bmatrix} 1/2  -3/2 \\end{bmatrix} \\begin{bmatrix} 1/2 \\\\ -3/2 \\end{bmatrix} = (\\frac{1}{2})^{2} + (-\\frac{3}{2})^{2} = \\frac{1}{4} + \\frac{9}{4} = \\frac{10}{4} = \\frac{5}{2}$。\n    因此，$\\omega_{0} = \\frac{3/4}{5/2} = \\frac{3}{4} \\cdot \\frac{2}{5} = \\frac{6}{20} = \\frac{3}{10}$。\n\n7.  **更新解以得到 $x_{1}$：**\n    $x_{1} = x_{0} + \\alpha_{0} p_{0} + \\omega_{0} s_{0}$。\n    $x_{1} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} + \\frac{1}{2} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} + \\frac{3}{10} \\begin{bmatrix} 0 \\\\ -1/2 \\end{bmatrix} = \\begin{bmatrix} 1/2 \\\\ 0 \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ -3/20 \\end{bmatrix} = \\begin{bmatrix} 1/2 \\\\ -3/20 \\end{bmatrix}$。\n\n8.  **更新残差以得到 $r_{1}$：**\n    $r_{1} = s_{0} - \\omega_{0} t_{0}$。\n    $r_{1} = \\begin{bmatrix} 0 \\\\ -1/2 \\end{bmatrix} - \\frac{3}{10} \\begin{bmatrix} 1/2 \\\\ -3/2 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ -5/10 \\end{bmatrix} - \\begin{bmatrix} 3/20 \\\\ -9/20 \\end{bmatrix} = \\begin{bmatrix} 0 - 3/20 \\\\ -10/20 - (-9/20) \\end{bmatrix} = \\begin{bmatrix} -3/20 \\\\ -1/20 \\end{bmatrix}$。\n\n9.  **更新搜索方向以得到 $p_{1}$：**\n    这需要计算 $\\rho_{1}$ 和 $\\beta_{0}$。\n    $\\rho_{1} = \\langle \\tilde{r}_{0}, r_{1} \\rangle = \\begin{bmatrix} 1  0 \\end{bmatrix} \\begin{bmatrix} -3/20 \\\\ -1/20 \\end{bmatrix} = -\\frac{3}{20}$。\n    $\\beta_{0} = \\frac{\\rho_{1}}{\\rho_{0}} \\frac{\\alpha_{0}}{\\omega_{0}} = \\frac{-3/20}{1} \\frac{1/2}{3/10} = -\\frac{3}{20} \\cdot \\frac{1}{2} \\cdot \\frac{10}{3} = -\\frac{30}{120} = -\\frac{1}{4}$。\n    搜索方向更新为 $p_{1} = r_{1} + \\beta_{0} (p_{0} - \\omega_{0} v_{0})$。\n    首先，计算括号中的项：\n    $p_{0} - \\omega_{0} v_{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} - \\frac{3}{10} \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} - \\begin{bmatrix} 6/10 \\\\ 3/10 \\end{bmatrix} = \\begin{bmatrix} 4/10 \\\\ -3/10 \\end{bmatrix} = \\begin{bmatrix} 2/5 \\\\ -3/10 \\end{bmatrix}$。\n    现在，计算 $p_{1}$：\n    $p_{1} = \\begin{bmatrix} -3/20 \\\\ -1/20 \\end{bmatrix} + (-\\frac{1}{4}) \\begin{bmatrix} 2/5 \\\\ -3/10 \\end{bmatrix} = \\begin{bmatrix} -3/20 \\\\ -1/20 \\end{bmatrix} - \\begin{bmatrix} 2/20 \\\\ -3/40 \\end{bmatrix} = \\begin{bmatrix} -5/20 \\\\ -2/40 + 3/40 \\end{bmatrix} = \\begin{bmatrix} -1/4 \\\\ 1/40 \\end{bmatrix}$。\n\n第一次完整迭代计算出的量是：\n$\\rho_{0} = 1$, $\\alpha_{0} = \\frac{1}{2}$, $s_{0} = \\begin{bmatrix} 0 \\\\ -1/2 \\end{bmatrix}$, $\\omega_{0} = \\frac{3}{10}$, $x_{1} = \\begin{bmatrix} 1/2 \\\\ -3/20 \\end{bmatrix}$, $r_{1} = \\begin{bmatrix} -3/20 \\\\ -1/20 \\end{bmatrix}$, $p_{1} = \\begin{bmatrix} -1/4 \\\\ 1/40 \\end{bmatrix}$。\n\n**最终计算**\n\n问题要求计算 $\\|r_{1}\\|_{2}^{2}$。\n$\\|r_{1}\\|_{2}^{2} = \\langle r_{1}, r_{1} \\rangle = r_{1}^{\\top} r_{1} = \\begin{bmatrix} -3/20  -1/20 \\end{bmatrix} \\begin{bmatrix} -3/20 \\\\ -1/20 \\end{bmatrix}$。\n$\\|r_{1}\\|_{2}^{2} = (-\\frac{3}{20})^{2} + (-\\frac{1}{20})^{2} = \\frac{9}{400} + \\frac{1}{400} = \\frac{10}{400} = \\frac{1}{40}$。\n结果是所要求的精确有理数。", "answer": "$$\\boxed{\\frac{1}{40}}$$", "id": "3585874"}, {"introduction": "在掌握了算法的机械步骤之后，更深入的理解来自于探究其每个组成部分的设计意图。这个思想实验将我们引向一个特殊情景：当旨在平滑收敛过程的“稳定化”步骤本身失效时会发生什么 [@problem_id:3616023]。通过推导这一特殊情况下的后果，我们能更深刻地揭示局部最小残差投影在保证算法稳健性中所扮演的关键角色。", "problem": "考虑一个产生于黏声介质频率域地震波场建模的线性系统 $A x = b$，其中 $A \\in \\mathbb{C}^{n \\times n}$ 是一个大型、稀疏、非厄米矩阵，其非厄米性是由吸收边界条件和衰减所导致的。我们应用基于双共轭梯度稳定 (BiCGSTAB) 方法的迭代求解器来近似其解。设初始猜测解为 $x_{0}$，初始残差为 $r_{0} = b - A x_{0}$，阴影残差为 $r^{\\sharp}$ 且满足 $\\langle r^{\\sharp}, r_{0}\\rangle \\neq 0$，其中 $\\langle \\cdot, \\cdot \\rangle$ 表示 $\\mathbb{C}^{n}$ 上的标准欧几里得内积，并约定 $\\langle u, v \\rangle = v^{*} u$。定义初始搜索方向 $p_{0} = r_{0}$，并通过常规的非对称克雷洛夫（Krylov）投影得到标量 $\\alpha_{1}$，然后构成中间残差\n$$\ns_{1} = r_{0} - \\alpha_{1} A p_{0}.\n$$\n接下来，该方法通过最小化残差 $r_{1}(\\omega) = s_{1} - \\omega t_{1}$ 的平方2-范数来寻找一个稳定化标量 $\\omega_{1}$，其中 $t_{1} = A s_{1}$。最小化子 $\\omega_{1}$ 是通过使 $r_{1}(\\omega)$ 在一维仿射子空间 $\\{s_{1} - \\omega t_{1} : \\omega \\in \\mathbb{C}\\}$ 中具有最小2-范数这一条件来确定的。\n\n假设一个与强非均匀衰减相关的情景，其中 $A$ 作用于 $s_{1}$ 产生的向量 $t_{1}$ 在欧几里得内积下与 $s_{1}$ 正交，即\n$$\n\\langle t_{1}, s_{1} \\rangle = 0 \\quad \\text{且} \\quad \\langle t_{1}, t_{1} \\rangle \\neq 0.\n$$\n在这些假设下，确定最小化子 $\\omega_{1}$，并推导出对迭代解和残差的相应更新：\n$$\nx_{1} = x_{0} + \\alpha_{1} p_{0} + \\omega_{1} s_{1}, \\qquad r_{1} = s_{1} - \\omega_{1} t_{1}.\n$$\n请将最终答案以包含 $\\omega_{1}$、$x_{1}$ 和 $r_{1}$ 三个条目的单行矩阵形式给出，并用 $x_{0}$、$p_{0}$、$\\alpha_{1}$ 和 $s_{1}$ 进行符号表示。无需进行数值计算或四舍五入。", "solution": "用户提出了一个来自计算地球物理学领域的问题，具体涉及使用双共轭梯度稳定 (BiCGSTAB) 方法求解线性系统。按照流程，必须首先对问题进行严格验证。\n\n### 步骤 1：提取已知条件\n问题提供了以下数据和定义：\n-   一个线性系统 $A x = b$，其中 $A \\in \\mathbb{C}^{n \\times n}$ 是一个大型、稀疏、非厄米矩阵。\n-   初始猜测解为 $x_{0}$。\n-   初始残差为 $r_{0} = b - A x_{0}$。\n-   存在一个阴影残差 $r^{\\sharp}$，使得 $\\langle r^{\\sharp}, r_{0}\\rangle \\neq 0$。\n-   $\\mathbb{C}^{n}$ 上的内积定义为 $\\langle u, v \\rangle = v^{*} u$。\n-   初始搜索方向为 $p_{0} = r_{0}$。\n-   对于某个标量 $\\alpha_{1}$，中间残差定义为 $s_{1} = r_{0} - \\alpha_{1} A p_{0}$。\n-   向量 $t_{1}$ 定义为 $t_{1} = A s_{1}$。\n-   需要寻找一个稳定化标量 $\\omega_{1}$，以最小化 $r_{1}(\\omega) = s_{1} - \\omega t_{1}$ 的平方2-范数。\n-   假设了一个特定条件：$\\langle t_{1}, s_{1} \\rangle = 0$ 且 $\\langle t_{1}, t_{1} \\rangle \\neq 0$。\n-   更新后的迭代解为 $x_{1} = x_{0} + \\alpha_{1} p_{0} + \\omega_{1} s_{1}$。\n-   更新后的残差为 $r_{1} = s_{1} - \\omega_{1} t_{1}$。\n-   任务是在给定条件下求出 $\\omega_{1}$、$x_{1}$、$r_{1}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n-   **科学依据**：该问题在数值线性代数及其在地震建模中的应用方面有充分的依据。BiCGSTAB 方法是一种标准的迭代求解器。关于矩阵 $A$ 因物理现象（衰减）和数值效应（吸收边界）而呈非厄米性的描述是准确的。BiCGSTAB 算法的步骤是标准的。指定的内积定义是复向量空间中两种常用约定之一。条件 $\\langle t_1, s_1 \\rangle = 0$ 是为分析而提出的一个特定数学情景，并非断言其普遍发生。因此，该问题是科学合理的。\n-   **适定性**：该问题是适定的。它要求基于一组明确的定义和一个特定的、数学上一致的假设来确定具体量（$\\omega_{1}$、$x_{1}$、$r_{1}$）。最小化二次函数的目标确保了唯一最小化子的存在。\n-   **客观性**：语言正式、精确，且无主观性。所有术语均为相关领域的标准术语。\n-   该问题不存在所列出的任何缺陷：\n    1.  不存在科学或事实上的不合理之处。\n    2.  问题陈述规范，与主题直接相关。\n    3.  设定完整且一致；所有必要的量都已定义。\n    4.  条件并非物理上不可能，即使中心假设代表了一个特定的、可能不常见的案例。\n    5.  问题不是不适定的；可以推导出一个唯一的、稳定的解。\n    6.  问题并非微不足道；它需要正确应用向量微积分和线性代数原理。\n    7.  问题是一个数学推导，因此是可验证的。\n\n### 步骤 3：结论与行动\n问题被判定为 **有效**。现在将提供一个合理的解答。\n\n### 解答推导\n目标是确定标量 $\\omega_{1} \\in \\mathbb{C}$，以最小化残差 $r_{1}(\\omega) = s_{1} - \\omega t_{1}$ 的平方2-范数。对于任意向量 $v \\in \\mathbb{C}^{n}$，平方2-范数定义为 $\\|v\\|_{2}^{2} = \\langle v, v \\rangle$。\n\n设 $f(\\omega)$ 为待最小化的函数：\n$$\nf(\\omega) = \\|s_{1} - \\omega t_{1}\\|_{2}^{2} = \\langle s_{1} - \\omega t_{1}, s_{1} - \\omega t_{1} \\rangle\n$$\n根据给定的内积定义 $\\langle u, v \\rangle = v^{*} u$，我们可以展开这个表达式。标量-向量乘积的共轭转置为 $(\\omega t_1)^* = \\bar{\\omega} t_1^*$。\n$$\nf(\\omega) = (s_{1} - \\omega t_{1})^{*} (s_{1} - \\omega t_{1}) = (s_{1}^{*} - \\bar{\\omega} t_{1}^{*}) (s_{1} - \\omega t_{1})\n$$\n展开乘积可得：\n$$\nf(\\omega) = s_{1}^{*}s_{1} - \\omega s_{1}^{*}t_{1} - \\bar{\\omega} t_{1}^{*}s_{1} + \\bar{\\omega}\\omega t_{1}^{*}t_{1}\n$$\n我们可以使用内积符号表示各项：\n-   $s_{1}^{*}s_{1} = \\langle s_{1}, s_{1} \\rangle = \\|s_{1}\\|_{2}^{2}$\n-   $t_{1}^{*}s_{1} = \\langle s_{1}, t_{1} \\rangle$\n-   $s_{1}^{*}t_{1} = (t_{1}^{*}s_{1})^{*} = \\langle s_{1}, t_{1} \\rangle^{*}$\n-   $t_{1}^{*}t_{1} = \\langle t_{1}, t_{1} \\rangle = \\|t_{1}\\|_{2}^{2}$\n\n将这些代入 $f(\\omega)$ 的表达式中：\n$$\nf(\\omega) = \\|s_{1}\\|_{2}^{2} - \\omega \\langle s_{1}, t_{1} \\rangle^{*} - \\bar{\\omega} \\langle s_{1}, t_{1} \\rangle + |\\omega|^{2} \\|t_{1}\\|_{2}^{2}\n$$\n为了找到最小值，我们可以将关于 $\\bar{\\omega}$ 的复导数设为零：\n$$\n\\frac{\\partial f}{\\partial \\bar{\\omega}} = - \\langle s_{1}, t_{1} \\rangle + \\omega \\|t_{1}\\|_{2}^{2} = 0\n$$\n求解 $\\omega$ 得到最小化子的一般表达式，我们记为 $\\omega_1$：\n$$\n\\omega_{1} = \\frac{\\langle s_{1}, t_{1} \\rangle}{\\|t_{1}\\|_{2}^{2}} = \\frac{\\langle s_{1}, t_{1} \\rangle}{\\langle t_{1}, t_{1} \\rangle}\n$$\n这是 BiCGSTAB 算法中 $\\omega_1$ 的标准公式。\n\n现在，我们应用问题陈述中给出的特定条件：$\\langle t_{1}, s_{1} \\rangle = 0$。\n复内积具有性质 $\\langle u, v \\rangle = \\langle v, u \\rangle^{*}$。因此：\n$$\n\\langle s_{1}, t_{1} \\rangle = \\langle t_{1}, s_{1} \\rangle^{*}\n$$\n由于 $\\langle t_{1}, s_{1} \\rangle = 0$，我们有：\n$$\n\\langle s_{1}, t_{1} \\rangle = (0)^{*} = 0\n$$\n$\\omega_{1}$ 表达式的分子为零。分母为 $\\langle t_{1}, t_{1} \\rangle$，题目明确指出其不为零。\n因此，$\\omega_{1}$ 的值为：\n$$\n\\omega_{1} = \\frac{0}{\\langle t_{1}, t_{1} \\rangle} = 0\n$$\n或者，将条件 $\\langle t_1, s_1 \\rangle = 0$（这意味着 $\\langle s_1, t_1 \\rangle = 0$）直接代入展开的函数 $f(\\omega)$ 中：\n$$\nf(\\omega) = \\|s_{1}\\|_{2}^{2} - \\omega(0) - \\bar{\\omega}(0) + |\\omega|^{2} \\|t_{1}\\|_{2}^{2} = \\|s_{1}\\|_{2}^{2} + |\\omega|^{2} \\|t_{1}\\|_{2}^{2}\n$$\n由于 $\\|s_{1}\\|_{2}^{2}$ 是一个非负常数，而 $\\|t_{1}\\|_{2}^{2}$ 是一个正常数（因为 $\\langle t_{1}, t_{1} \\rangle \\neq 0$），当 $|\\omega|^{2} \\|t_{1}\\|_{2}^{2}$ 项最小时，函数 $f(\\omega)$ 达到最小值。这发生在 $|\\omega|^{2}=0$ 时，即 $\\omega = 0$。因此，最小化标量为 $\\omega_1 = 0$。\n\n在确定了 $\\omega_{1} = 0$ 后，我们可以求出更新后的迭代解 $x_{1}$ 和残差 $r_{1}$。\n迭代解的更新公式为：\n$$\nx_{1} = x_{0} + \\alpha_{1} p_{0} + \\omega_{1} s_{1}\n$$\n代入 $\\omega_{1}=0$：\n$$\nx_{1} = x_{0} + \\alpha_{1} p_{0} + (0) s_{1} = x_{0} + \\alpha_{1} p_{0}\n$$\n残差的更新公式为：\n$$\nr_{1} = s_{1} - \\omega_{1} t_{1}\n$$\n代入 $\\omega_{1}=0$：\n$$\nr_{1} = s_{1} - (0) t_{1} = s_{1}\n$$\n条件 $\\langle t_1, s_1 \\rangle = \\langle As_1, s_1 \\rangle = 0$ 意味着 BiCGSTAB 的稳定化步骤对残差没有任何改善，因为最优稳定化参数 $\\omega_1$ 为零。对于本次迭代，该方法实际上退化为双共轭梯度法的一步，新的残差 $r_1$ 就是中间残差 $s_1$。\n\n所要求的三个量用指定变量表示为 $\\omega_1=0$、$x_1=x_0 + \\alpha_1 p_0$ 和 $r_1=s_1$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  & x_{0} + \\alpha_{1} p_{0}  & s_{1}\n\\end{pmatrix}\n}\n$$", "id": "3616023"}, {"introduction": "将理论算法转化为功能代码是检验和巩固理解的最终试金石。这项练习不仅要求你实现 BiCGSTAB 方法，更挑战你扮演一名“侦探”，去精心构造特定的线性系统 [@problem_id:3102131]。你的目标是触发一种被称为“幸运分解”的现象，即算法出人意料地提前找到精确解，从而揭示迭代过程与矩阵特征系统之间的精妙联系。", "problem": "要求您实现一个完整、可运行的程序，构建一个小型测试工具，以演示迭代克雷洛夫子空间方法中的一个特定现象，即双共轭梯度稳定方法 (BiCGSTAB) 中的“幸运分解” (lucky breakdown)。请在以双精度浮点数为模型的精确算术中进行操作，并将向量和矩阵视为实数数组。\n\n您的程序必须完成以下任务。\n\n1. 用作基本基础的核心定义：\n   - 给定一个线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$x \\in \\mathbb{R}^{n}$，$b \\in \\mathbb{R}^{n}$。\n   - 给定一个初始猜测解 $x_0 \\in \\mathbb{R}^{n}$，定义初始残差 $r_0 = b - A x_0$。\n   - 使用标准的欧几里得内积 $(u, v) = \\sum_{i=1}^{n} u_i v_i$ 和其诱导的 2-范数 $\\lVert u \\rVert_2 = \\sqrt{(u,u)}$。\n   - 实现双共轭梯度稳定方法 (BiCGSTAB)，并使用 $r_0$ 作为固定的影子残差。使用一个基于残差范数低于某个容差的标准停止准则。\n\n2. 需要检测的幸运分解事件：\n   - 在每次 BiCGSTAB 迭代中，计算出标量步长 $\\alpha_k$ 和中间向量 $s_k = r_{k-1} - \\alpha_k A p_{k-1}$ 之后，如果在计算下一个稳定化步骤之前出现 $s_k = 0$（在浮点运算中，将 $\\lVert s_k \\rVert_2 \\le \\varepsilon$ 视为零），则称发生了“幸运分解”。在这种情况下，精确解已在该迭代内通过 $x_k = x_{k-1} + \\alpha_k p_{k-1}$ 提前找到。\n   - 您的程序必须仅在此意义上声明幸运分解。不要将 $r_0 = 0$ 的平凡情况计为幸运分解；也不要将仅在完成 $\\omega_k$ 稳定化步骤后才发生的收敛计为幸运分解。\n\n3. 数值容差：\n   - 使用 $\\varepsilon = 10^{-12}$ 的收敛和零检测容差来检查 $\\lVert s_k \\rVert_2$ 和 $\\lVert r_k \\rVert_2$。\n   - 对每个测试用例使用 $k_{\\max} = 1000$ 的最大迭代次数上限，以避免在病态输入下出现无限循环。\n\n4. 测试套件的设计与构建：\n   - 通过显式指定 $A$、$b$ 和 $x_0$ 来构建四个测试用例，以便测试工具能够覆盖以下行为。所有条目和大小都必须明确说明，并且所有矩阵都必须是非奇异的。\n     - 用例 L1（对称幸运分解）：令 $A \\in \\mathbb{R}^{3 \\times 3}$ 为对角矩阵，其条目为 $A = \\mathrm{diag}(2, 3, 4)$，令 $x_0 = (0, 0, 0)^{\\top}$，令 $b = (1, 0, 0)^{\\top}$。该配置的构建应确保 $r_0$ 是 $A$ 的一个特征向量，这在代数上使得能够通过 $s_0 = 0$ 提前得到精确解。\n     - 用例 L2（非对称幸运分解）：令 $A \\in \\mathbb{R}^{2 \\times 2}$ 为上三角类若尔当块 $A = \\begin{bmatrix} 5  1 \\\\ 0  5 \\end{bmatrix}$，令 $x_0 = (0, 0)^{\\top}$，令 $b = (1, 0)^{\\top}$。该配置应再次确保 $r_0$ 是 $A$ 的一个特征向量，因此即使 $A$ 不是对称的，同样的代数机制也可以触发 $s_0 = 0$。\n     - 用例 B1（边界情况，非幸运分解）：令 $A \\in \\mathbb{R}^{2 \\times 2}$ 为对角矩阵 $A = \\mathrm{diag}(7, 8)$，选择 $x_{\\star} = (1, 2)^{\\top}$，设置 $b = A x_{\\star}$，并将初始猜测解设置为精确解 $x_0 = x_{\\star}$。这会得到 $r_0 = 0$。这种情况不能被计为幸运分解，因为不需要进行迭代。\n     - 用例 G1（一般情况，非幸运分解）：令 $A \\in \\mathbb{R}^{2 \\times 2}$ 为对角矩阵 $A = \\mathrm{diag}(2, 3)$，令 $x_0 = (0, 0)^{\\top}$，令 $b = (1, 1)^{\\top}$。此设置应产生一个正常的迭代序列，其中 $s_0 \\ne 0$，并且如果达到收敛，也是在稳定化步骤或后续迭代之后发生。\n\n5. 输出规范：\n   - 对于每个测试用例，如果某次迭代的 $\\alpha$-步骤中发生了幸运分解（如上文所定义），您的程序必须输出整数 $1$，否则输出整数 $0$（包括 $r_0 = 0$ 的平凡情况以及在 $\\omega$-步骤之后发生的任何收敛）。\n   - 将四个结果聚合到一行中，以逗号分隔列表的形式打印，并用方括号括起来，不含空格，顺序为 $[\\text{L1},\\text{L2},\\text{B1},\\text{G1}]$。例如，一个有效的输出可能看起来像 $[1,1,0,0]$。\n\n6. 角度单位、物理单位和百分比：\n   - 此任务不涉及任何物理量、角度或百分比。\n\n您的程序必须是完全自包含的，不需要用户输入，并且必须遵守上述确切的输出格式。", "solution": "该问题要求实现双共轭梯度稳定 (BiCGSTAB) 迭代法来求解线性系统 $A x = b$，并构建一个测试套件以演示一个被称为“幸运分解”的特定现象。\n\n一个线性系统由 $A x = b$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个非奇异矩阵，$x, b \\in \\mathbb{R}^{n}$ 是向量。给定一个初始猜测解 $x_0$，初始残差为 $r_0 = b - A x_0$。BiCGSTAB 方法通过迭代地改进解的猜测值 $x_k$ 来最小化残差 $r_k = b - A x_k$。\n\nBiCGSTAB 算法使用一个固定的影子残差 $\\hat{r}_0$（根据问题要求设为 $r_0$），可以表述如下：\n\n1.  初始化：\n    $x_0$ 是初始猜测解。\n    $r_0 = b - A x_0$。\n    如果 $\\lVert r_0 \\rVert_2$ 接近于零，则初始猜测解已经是解。\n    设置固定的影子残差 $\\hat{r}_0 = r_0$。\n    设置初始搜索方向 $p_0 = r_0$。\n    计算残差投影的初始平方范数 $\\rho_0 = (\\hat{r}_0, r_0)$。\n\n2.  对 $k = 1, 2, \\dots$ 进行迭代，直到收敛或达到最大迭代次数：\n    a. 计算矩阵向量积：$v_{k-1} = A p_{k-1}$。\n    b. 计算步长 $\\alpha_k$：\n       $$ \\alpha_k = \\frac{\\rho_{k-1}}{(\\hat{r}_0, v_{k-1})} = \\frac{(\\hat{r}_0, r_{k-1})}{(\\hat{r}_0, A p_{k-1})} $$\n    c. 沿搜索方向 $p_{k-1}$ 更新解，并计算中间残差 $s_k$：\n       $$ s_k = r_{k-1} - \\alpha_k v_{k-1} = r_{k-1} - \\alpha_k A p_{k-1} $$\n    d. **幸运分解检查**：如果 $\\lVert s_k \\rVert_2 \\le \\varepsilon$（其中 $\\varepsilon=10^{-12}$ 是一个小容差），则发生“幸运分解”。精确解被提前找到。最终解为 $x_k = x_{k-1} + \\alpha_k p_{k-1}$。我们报告此事件并终止。\n    e. 如果没有发生幸运分解，则继续进行稳定化步骤。计算矩阵向量积 $t_k = A s_k$。\n    f. 计算稳定化参数 $\\omega_k$：\n       $$ \\omega_k = \\frac{(t_k, s_k)}{(t_k, t_k)} $$\n    g. 对解和本次迭代的最终残差进行完全更新：\n       $$ x_k = x_{k-1} + \\alpha_k p_{k-1} + \\omega_k s_k $$\n       $$ r_k = s_k - \\omega_k t_k $$\n    h. 检查正常收敛：如果 $\\lVert r_k \\rVert_2 \\le \\varepsilon$，则终止。\n    i. 为下一次迭代做准备。更新投影范数和搜索方向：\n       $$ \\rho_k = (\\hat{r}_0, r_k) $$\n       $$ \\beta_k = \\frac{\\rho_k}{\\rho_{k-1}} \\frac{\\alpha_k}{\\omega_k} $$\n       $$ p_k = r_k + \\beta_k (p_{k-1} - \\omega_k v_{k-1}) $$\n\n问题的核心是检测幸运分解。当 $s_k=0$ 时会发生这种情况。让我们分析第一次迭代（$k=1$）时的这个条件。初始搜索方向为 $p_0 = r_0$。条件 $s_1 = 0$ 意味着：\n$$ s_1 = r_0 - \\alpha_1 A p_0 = r_0 - \\alpha_1 A r_0 = 0 $$\n$$ \\implies A r_0 = \\frac{1}{\\alpha_1} r_0 $$\n这个方程表明，在第一次迭代中发生幸运分解的充分必要条件是初始残差 $r_0$ 是矩阵 $A$ 的一个特征向量。相应的步长 $\\alpha_1$ 将是该特征值的倒数。测试用例就是为了利用这一性质而设计的。\n\n- **用例 L1（对称幸运分解）**：$A = \\mathrm{diag}(2, 3, 4)$，$x_0 = (0, 0, 0)^{\\top}$，$b = (1, 0, 0)^{\\top}$。\n  初始残差为 $r_0 = b - A x_0 = (1, 0, 0)^{\\top}$。这是对角矩阵 $A$ 的一个特征向量，其特征值为 $\\lambda=2$。因此，预计会发生幸运分解，算法应报告 $1$。\n\n- **用例 L2（非对称幸运分解）**：$A = \\begin{bmatrix} 5  1 \\\\ 0  5 \\end{bmatrix}$，$x_0 = (0, 0)^{\\top}$，$b = (1, 0)^{\\top}$。\n  初始残差为 $r_0 = b - A x_0 = (1, 0)^{\\top}$。我们检查它是否是特征向量：$A r_0 = \\begin{pmatrix} 5 \\\\ 0 \\end{pmatrix} = 5 \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 5 r_0$。它是一个特征向量，特征值为 $\\lambda=5$。因此，这里也预计会发生幸运分解，结果是 $1$。\n\n- **用例 B1（边界情况，非幸运分解）**：$A = \\mathrm{diag}(7, 8)$，$x_0 = x_{\\star} = (1, 2)^{\\top}$，$b = A x_{\\star}$。\n  初始残差为 $r_0 = b - A x_0 = A x_{\\star} - A x_{\\star} = 0$。在任何迭代开始之前，检查 $\\lVert r_0 \\rVert_2 \\le \\varepsilon$ 就已满足。根据问题陈述，这种平凡情况不被视为幸运分解。程序应报告 $0$。\n\n- **用例 G1（一般情况，非幸运分解）**：$A = \\mathrm{diag}(2, 3)$，$x_0 = (0, 0)^{\\top}$，$b = (1, 1)^{\\top}$。\n  初始残差为 $r_0 = b - A x_0 = (1, 1)^{\\top}$。我们检查它是否是特征向量：$A r_0 = \\mathrm{diag}(2, 3) (1, 1)^{\\top} = (2, 3)^{\\top}$。由于 $(2, 3)^{\\top}$ 不是 $(1, 1)^{\\top}$ 的标量倍，所以 $r_0$ 不是 $A$ 的特征向量。因此，$s_1 \\ne 0$，在第一次迭代中不会发生幸运分解。算法将正常进行。预期输出为 $0$。\n\n所提供的程序实现了这一逻辑，正确地实例化了每个测试用例，运行了 BiCGSTAB 算法，并根据幸运分解的精确定义报告了 $1$ 或 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bicgstab(A, b, x0, tol, max_iter):\n    \"\"\"\n    Implements the Biconjugate Gradient Stabilized (BiCGSTAB) method and detects \"lucky breakdowns\".\n\n    A \"lucky breakdown\" is detected if the intermediate residual 's' becomes zero\n    before the stabilization step.\n\n    Args:\n        A (np.ndarray): The matrix of the linear system.\n        b (np.ndarray): The right-hand side vector of the linear system.\n        x0 (np.ndarray): The initial guess for the solution.\n        tol (float): The tolerance for convergence and zero-detection.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        int: Returns 1 if a lucky breakdown occurred, 0 otherwise.\n    \"\"\"\n    x = np.copy(x0)\n    r = b - A @ x\n\n    # Per problem: do not count trivial convergence as a lucky breakdown.\n    if np.linalg.norm(r) = tol:\n        return 0\n\n    # Fixed shadow residual as per problem specification.\n    r_hat = np.copy(r)\n\n    rho = r_hat @ r\n    # Handle potential breakdown if rho is zero initially.\n    if abs(rho)  1e-50:\n        return 0 # Breakdown, not lucky.\n        \n    p = np.copy(r)\n    \n    is_lucky = 0\n\n    for _ in range(max_iter):\n        v = A @ p\n        \n        denom = r_hat @ v\n        # Handle potential breakdown.\n        if abs(denom)  1e-50:\n            return 0 # Breakdown, not lucky.\n\n        alpha = rho / denom\n        \n        s = r - alpha * v\n\n        # The specific \"lucky breakdown\" check as defined in the problem.\n        if np.linalg.norm(s) = tol:\n            x = x + alpha * p\n            is_lucky = 1\n            break\n\n        t = A @ s\n        \n        denom = t @ t\n        # If s is not zero, but As is, it's a breakdown. A must be singular, but problem guarantees nonsingular A.\n        # This check is for numerical stability with floating point arithmetic.\n        if abs(denom)  1e-50:\n            return 0 # Breakdown, not lucky.\n        \n        omega = (t @ s) / denom\n        \n        # Full update for x and r.\n        x = x + alpha * p + omega * s\n        r_new = s - omega * t\n\n        # Normal convergence check after the full stabilization step.\n        if np.linalg.norm(r_new) = tol:\n            break\n\n        rho_new = r_hat @ r_new\n\n        # Handle potential breakdown from rho or omega being zero.\n        if abs(rho)  1e-50 or abs(omega)  1e-50:\n            return 0 # Breakdown, not lucky.\n\n        beta = (rho_new / rho) * (alpha / omega)\n\n        # Update search direction p.\n        p = r_new + beta * (p - omega * v)\n\n        # Update r and rho for the next iteration.\n        r = r_new\n        rho = rho_new\n\n    return is_lucky\n\ndef solve():\n    # Define the parameters and test cases from the problem statement.\n    tol = 1e-12\n    max_iter = 1000\n\n    # Case L1 (symmetric lucky breakdown)\n    A1 = np.diag([2.0, 3.0, 4.0])\n    x0_1 = np.zeros(3)\n    b1 = np.array([1.0, 0.0, 0.0])\n\n    # Case L2 (nonsymmetric lucky breakdown)\n    A2 = np.array([[5.0, 1.0], [0.0, 5.0]])\n    x0_2 = np.zeros(2)\n    b2 = np.array([1.0, 0.0])\n\n    # Case B1 (boundary, no-lucky)\n    A3 = np.diag([7.0, 8.0])\n    x_star3 = np.array([1.0, 2.0])\n    b3 = A3 @ x_star3\n    x0_3 = np.copy(x_star3)\n\n    # Case G1 (general, no-lucky)\n    A4 = np.diag([2.0, 3.0])\n    x0_4 = np.zeros(2)\n    b4 = np.array([1.0, 1.0])\n\n    test_cases = [\n        (A1, b1, x0_1),  # L1\n        (A2, b2, x0_2),  # L2\n        (A3, b3, x0_3),  # B1\n        (A4, b4, x0_4),  # G1\n    ]\n\n    results = []\n    for A, b, x0 in test_cases:\n        is_lucky = bicgstab(A, b, x0, tol, max_iter)\n        results.append(is_lucky)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3102131"}]}