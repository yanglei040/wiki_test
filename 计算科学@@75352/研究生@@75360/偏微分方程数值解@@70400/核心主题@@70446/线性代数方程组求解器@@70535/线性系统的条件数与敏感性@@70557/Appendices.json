{"hands_on_practices": [{"introduction": "本次练习是对偏微分方程数值解中病态问题的一次基础分析。通过解析推导离散化一维泊松方程条件数的渐近行为，您将揭示网格细化与数值敏感性增加之间的根本关系。这项实践对于理解为何更精细的网格（虽然理论上更精确）会给数值求解器带来巨大挑战至关重要 [@problem_id:3372809]。", "problem": "考虑在区间 $(0,1)$ 上的一维泊松偏微分方程 (PDE) $-u''(x)=f(x)$，其具有齐次狄利克雷边界条件 $u(0)=u(1)=0$。使用 $n$ 个内部网格点对该域进行离散化，网格间距为均匀的 $h=1/(n+1)$，并使用中心二阶差分来近似 $-u''(x)$。这会得到线性系统 $A\\mathbf{u}=\\mathbf{f}$，其中 $A$ 是 $n\\times n$ 矩阵 $A=(1/h^{2})\\,\\mathrm{tridiag}(-1,2,-1)$。\n\n仅从欧几里得范数（2-范数）、矩阵的 2-范数条件数以及带有齐次狄利克雷边界条件的离散二阶差分算子的基本定义出发，推导当 $h\\to 0$ 时 2-范数条件数 $\\kappa_{2}(A)$ 的主阶渐近行为。具体来说，证明 $\\kappa_{2}(A)\\sim C\\,h^{-2}$ 并确定精确常数 $C$。\n\n你的最终答案必须是 $C$ 的精确封闭形式值（一个用符号表示的实数，而非数值近似值）。最终答案中请勿提供中间步骤或任何其他量。", "solution": "矩阵 $A$ 源于在均匀网格上对带有齐次狄利克雷边界条件的负二阶导数 $-u''(x)$ 进行中心二阶差分近似。矩阵 $A$ 是实对称且严格对角占优的，其对角线元素为正，非对角线元素为负，因此它是对称正定 (SPD) 矩阵。\n\n根据定义，$A$ 的欧几里得范数（2-范数）条件数为\n$$\n\\kappa_{2}(A)=\\|A\\|_{2}\\,\\|A^{-1}\\|_{2}.\n$$\n对于对称正定矩阵，谱范数 $\\|A\\|_{2}$ 等于 $A$ 的最大特征值，而 $\\|A^{-1}\\|_{2}$ 等于 $A$ 的最小特征值的倒数。因此，\n$$\n\\kappa_{2}(A)=\\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}.\n$$\n\n为了确定 $A$ 的特征值，我们使用齐次狄利克雷边界条件下的离散二阶差分算子。设网格索引为 $j=1,2,\\dots,n$，并定义向量分量 $v^{(k)}_{j}=\\sin\\!\\big(j\\theta_{k}\\big)$，其中\n$$\n\\theta_{k}=\\frac{k\\pi}{n+1}, \\quad k=1,2,\\dots,n.\n$$\n这 $n$ 个向量构成一组与齐次狄利克雷边界条件 $v^{(k)}_{0}=v^{(k)}_{n+1}=0$ 相一致的正交基。\n\n将 $A$ 作用于 $v^{(k)}$：\n$$\n(Av^{(k)})_{j}=\\frac{1}{h^{2}}\\Big(-v^{(k)}_{j-1}+2v^{(k)}_{j}-v^{(k)}_{j+1}\\Big)=\\frac{1}{h^{2}}\\Big(-\\sin((j-1)\\theta_{k})+2\\sin(j\\theta_{k})-\\sin((j+1)\\theta_{k})\\Big).\n$$\n使用三角恒等式\n$$\n-\\sin((j-1)\\theta)+2\\sin(j\\theta)-\\sin((j+1)\\theta)=2\\big(1-\\cos\\theta\\big)\\sin(j\\theta)=4\\sin^{2}\\!\\Big(\\frac{\\theta}{2}\\Big)\\sin(j\\theta),\n$$\n我们得到\n$$\n(Av^{(k)})_{j}=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{\\theta_{k}}{2}\\Big)\\sin(j\\theta_{k})=\\lambda_{k}\\,v^{(k)}_{j},\n$$\n特征值为\n$$\n\\lambda_{k}=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{k\\pi}{2(n+1)}\\Big), \\quad k=1,2,\\dots,n.\n$$\n\n因此，\n$$\n\\lambda_{\\min}(A)=\\lambda_{1}=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{\\pi}{2(n+1)}\\Big), \\qquad \\lambda_{\\max}(A)=\\lambda_{n}=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{n\\pi}{2(n+1)}\\Big).\n$$\n\n我们现在提取当 $h\\to 0$ 时的主阶渐近行为。由于 $h=1/(n+1)$，当 $h\\to 0$ 时，我们有 $n\\to\\infty$。\n\n对于最小特征值，\n$$\n\\lambda_{\\min}(A)=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{\\pi}{2(n+1)}\\Big)=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{\\pi h}{2}\\Big).\n$$\n使用当 $x\\to 0$ 时的小角度近似 $\\sin x \\sim x$，我们得到\n$$\n\\sin\\!\\Big(\\frac{\\pi h}{2}\\Big)\\sim \\frac{\\pi h}{2} \\quad \\text{as } h\\to 0,\n$$\n所以\n$$\n\\lambda_{\\min}(A)\\sim \\frac{4}{h^{2}}\\Big(\\frac{\\pi h}{2}\\Big)^{2}=\\pi^{2}.\n$$\n\n对于最大特征值，\n$$\n\\lambda_{\\max}(A)=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{n\\pi}{2(n+1)}\\Big)=\\frac{4}{h^{2}}\\sin^{2}\\!\\Big(\\frac{\\pi}{2}-\\frac{\\pi}{2(n+1)}\\Big).\n$$\n使用 $\\sin\\!\\big(\\frac{\\pi}{2}-\\varepsilon\\big)=\\cos(\\varepsilon)$ 以及当 $\\varepsilon\\to 0$ 时 $\\cos(\\varepsilon)\\to 1$，我们得到\n$$\n\\sin^{2}\\!\\Big(\\frac{\\pi}{2}-\\frac{\\pi}{2(n+1)}\\Big)\\to 1 \\quad \\text{as } n\\to\\infty,\n$$\n因此\n$$\n\\lambda_{\\max}(A)\\sim \\frac{4}{h^{2}}.\n$$\n\n因此，2-范数条件数满足\n$$\n\\kappa_{2}(A)=\\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\\sim \\frac{(4/h^{2})}{\\pi^{2}}=\\Big(\\frac{4}{\\pi^{2}}\\Big)h^{-2} \\quad \\text{as } h\\to 0.\n$$\n这确定了渐近关系 $\\kappa_{2}(A)\\sim C\\,h^{-2}$ 中的精确常数 $C$：\n$$\nC=\\frac{4}{\\pi^{2}}.\n$$", "answer": "$$\\boxed{\\frac{4}{\\pi^{2}}}$$", "id": "3372809"}, {"introduction": "在离散拉普拉斯算子概念的基础上，本练习利用强大的图论框架，探讨了计算域几何形状对条件数的影响。您将通过编程构建带有“瓶颈”的计算域，并研究这些几何特征如何削弱图的代数连通性，从而导致条件数和解的敏感性急剧增加。这项练习为问题的结构如何决定其数值稳定性提供了一种具体、可视化的直觉 [@problem_id:3372820]。", "problem": "考虑通过基于图的离散化方法对偏微分方程 (PDE) 进行数值求解。将一个二维矩形网格建模为一个无向图，其中顶点代表网格单元，边表示域内的 $4$-邻域邻接关系（上、下、左、右）。组合图拉普拉斯算子 $L$ 定义为 $L = D - W$，其中 $W$ 是邻接矩阵，$D$ 是对角度矩阵。代数连通度是 $L$ 的第二小特征值。\n\n为了构成一个可解的线性系统，选择一个顶点作为狄利克雷接地点（固定电势），并通过从 $L$ 中移除相应的行和列来构造接地拉普拉斯算子 $A$。给定非接地顶点上的载荷向量 $b$，考虑线性系统 $A x = b$，其中 $x$ 表示离散电势。$2$-范数条件数 $\\kappa_2(A)$ 定义为 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$，对于对称正定 (SPD) 矩阵 $A$，$\\kappa_2(A)$ 等于其最大特征值与最小特征值之比。\n\n已知具有狭窄部（连接两个较大块体的细长通道）的网格几何形状会降低子区域之间的连通性。使用此设置来研究代数连通度的降低如何增大 $\\kappa_2(A)$ 并放大解对局部载荷的敏感性。\n\n从上述核心定义出发，实现一个程序，该程序：\n- 构建三种域几何形状，它们是由整格点 $(x,y)$ 组成的集合，形成两个由一条长度为 $c_\\ell$、宽度为 $c_w$ 的通道连接的 $b_x \\times b_y$ 矩形块体，该通道在垂直方向上居中放置。左侧块体覆盖 $x \\in \\{0,\\dots,b_x-1\\}$ 和 $y \\in \\{0,\\dots,b_y-1\\}$。通道覆盖 $x \\in \\{b_x,\\dots,b_x+c_\\ell-1\\}$ 和 $y \\in \\{y_0,\\dots,y_0+c_w-1\\}$，其中 $y_0 = \\lfloor (b_y - c_w)/2 \\rfloor$。右侧块体覆盖 $x \\in \\{b_x+c_\\ell,\\dots,2b_x+c_\\ell-1\\}$ 和 $y \\in \\{0,\\dots,b_y-1\\}$。使用 $4$-邻域邻接关系在域内形成边。\n- 构建域的完整组合拉普拉斯算子 $L$ 并计算代数连通度 $\\lambda_2$（$L$ 的第二小特征值）。\n- 将位于 $(0,0)$ 的单个顶点接地，通过从 $L$ 中移除其对应的行和列来形成 SPD 接地拉普拉斯算子 $A$。\n- 在右侧块体中，位于水平坐标 $x^\\star = 2b_x + c_\\ell - 1$（最右侧边缘）以及垂直坐标分别为 $y^\\star = \\lfloor b_y/2 \\rfloor$ 和 $y^\\star + 1$ 的两个相邻顶点上，形成两个局部载荷向量 $b_0$ 和 $b_1$ 作为单位脉冲。如果 $y^\\star + 1$ 不属于域，则使用 $y^\\star - 1$。这些载荷定义在非接地索引集上（即移除接地点后）。精确求解 $A x_0 = b_0$ 和 $A x_1 = b_1$。计算放大系数 $s = \\lVert x_1 - x_0 \\rVert_2 / \\lVert b_1 - b_0 \\rVert_2$。\n- 通过 $A$ 的最大和最小特征值计算 $2$-范数条件数 $\\kappa_2(A)$。\n\n对于每个测试用例，你的程序必须报告一个由浮点数组成的三元组 $[\\lambda_2, \\kappa_2(A), s]$。\n\n测试套件：\n- 案例 1 (理想情况): $b_x = 6$, $b_y = 6$, $c_\\ell = 6$, $c_w = 3$.\n- 案例 2 (狭窄部): $b_x = 6$, $b_y = 6$, $c_\\ell = 6$, $c_w = 1$.\n- 案例 3 (长狭窄部): $b_x = 6$, $b_y = 6$, $c_\\ell = 12$, $c_w = 1$.\n\n答案规格：\n- 对于每个案例，以浮点数形式输出列表 $[\\lambda_2, \\kappa_2(A), s]$。\n- 将三个案例的结果汇总到一个列表的列表中。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个案例的三元组，例如 $[[\\lambda_2^{(1)},\\kappa_2^{(1)},s^{(1)}],[\\lambda_2^{(2)},\\kappa_2^{(2)},s^{(2)}],[\\lambda_2^{(3)},\\kappa_2^{(3)},s^{(3)}]]$。", "solution": "该问题被评估为有效。它在数值线性代数和图论领域具有科学依据，特别关注图拉普拉斯算子的性质及其与离散化偏微分方程的联系。该问题是适定的，提供了构建唯一且有意义的解所需的所有必要定义、约束和数据。术语精确，计算任务明确且可行。\n\n目标是分析图的几何形状（特别是狭窄部的存在）、其代数连通度 $\\lambda_2$、相关接地拉普拉斯矩阵 $A$ 的条件数 $\\kappa_2(A)$ 以及线性系统 $Ax=b$ 对载荷向量 $b$ 中扰动的敏感度 $s$ 之间的关系。\n\n对于每个测试用例，解题过程遵循以下步骤。\n\n**步骤 1：域构建和图表示**\n首先，我们构建构成域的顶点集合。该域由三部分组成：一个左侧矩形块体、一个中央通道和一个右侧矩形块体。每个部分顶点 $(x,y)$ 的坐标由以下公式给出：\n- 左侧块体: $x \\in \\{0, \\dots, b_x-1\\}$, $y \\in \\{0, \\dots, b_y-1\\}$。\n- 通道: $x \\in \\{b_x, \\dots, b_x+c_\\ell-1\\}$, $y \\in \\{y_0, \\dots, y_0+c_w-1\\}$，其中 $y_0 = \\lfloor (b_y - c_w)/2 \\rfloor$。\n- 右侧块体: $x \\in \\{b_x+c_\\ell, \\dots, 2b_x+c_\\ell-1\\}$, $y \\in \\{0, \\dots, b_y-1\\}$。\n\n我们生成属于该域的所有整数值坐标对 $(x,y)$ 的集合。设顶点总数为 $N$。我们创建一个从每个坐标对 $(x,y)$ 到唯一整数索引 $i \\in \\{0, \\dots, N-1\\}$ 的映射。此映射有助于图矩阵的构建。\n\n**步骤 2：组合拉普拉斯算子 $L$ 的构建**\n组合图拉普拉斯矩阵 $L$ 定义为 $L = D - W$，其中 $W$ 是邻接矩阵，$D$ 是度矩阵。$L$ 是一个 $N \\times N$ 矩阵。\n- 邻接矩阵 $W$ 是根据 $4$-邻域规则构建的。对于任意两个坐标为 $(x_i, y_i)$ 和 $(x_j, y_j)$ 的顶点 $i$ 和 $j$，如果 $|x_i - x_j| + |y_i - y_j| = 1$，则条目 $W_{ij}$ 为 $1$，否则为 $0$。\n- 度矩阵 $D$ 是一个对角矩阵，其中对角线元素 $D_{ii}$ 是顶点 $i$ 的度，即其在域内的邻居数量。\n拉普拉斯矩阵 $L$ 的元素可以直接构建：\n- 对于 $i \\neq j$，如果顶点 $i$ 和 $j$ 相邻，则 $L_{ij} = -1$，否则 $L_{ij} = 0$。\n- 对角线元素 $L_{ii}$ 等于顶点 $i$ 的度。\n\n**步骤 3：代数连通度 $\\lambda_2$ 的计算**\n代数连通度 $\\lambda_2$ 是拉普拉斯矩阵 $L$ 的第二小特征值。对于任何连通图，$L$ 的最小特征值 $\\lambda_1$ 始终为 $0$。我们使用标准的数值特征值求解器计算对称矩阵 $L$ 的所有特征值。这些特征值是实数且非负。将它们按非递减顺序排序后，$\\lambda_2$ 是排序列表中的第二个值。较小的 $\\lambda_2$ 表示图的连通性较差，通常与瓶颈或稀疏切割有关。\n\n**步骤 4：接地拉普拉斯算子 $A$ 的形成**\n为了对具有固定边界条件的系统进行建模，我们将系统在单个顶点接地。问题指定将坐标为 $(0,0)$ 的顶点接地。这等效于将其电势设置为一个固定值（例如 $0$）并求解其他顶点的电势。在矩阵术语中，这是通过从完整的拉普拉斯算子 $L$ 中移除与接地点对应的行和列来完成的。得到的 $(N-1) \\times (N-1)$ 矩阵就是接地拉普拉斯算子 $A$。对于连通图，矩阵 $A$ 是对称正定的 (SPD)。\n\n**步骤 5：条件数 $\\kappa_2(A)$ 的计算**\n矩阵 $A$ 的 $2$-范数条件数是 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$。由于我们的矩阵 $A$ 是对称正定的，该表达式简化为其最大特征值与最小特征值之比：\n$$ \\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} $$\n我们计算 $A$ 的特征值。由于 $A$ 是 SPD 矩阵，其所有特征值都严格为正。然后我们找到最大和最小特征值来计算 $\\kappa_2(A)$。大的条件数表明矩阵接近奇异，并且线性系统 $Ax=b$ 的解对 $A$ 或 $b$ 的扰动高度敏感。\n\n**步骤 6：解敏感度 $s$ 的计算**\n为了量化解向量 $x$ 对载荷向量 $b$ 局部变化的敏感度，我们定义了两个特定的载荷向量 $b_0$ 和 $b_1$。这些向量表示在域的右侧块体中两个相邻顶点上的单位脉冲。\n这些顶点的坐标是 $(x^\\star, y^\\star)$ 和 $(x^\\star, y^\\star+1)$，其中 $x^\\star = 2b_x + c_\\ell - 1$ 和 $y^\\star = \\lfloor b_y/2 \\rfloor$。\n载荷向量 $b_0$ 和 $b_1$ 构建在非接地顶点的 $(N-1)$ 维空间中。每个向量都是零向量，除了在对应于两个指定顶点之一的索引处有一个值为 $1$ 的条目。\n然后我们求解两个线性系统：\n$$ A x_0 = b_0 $$\n$$ A x_1 = b_1 $$\n敏感度通过放大系数 $s$ 来衡量，它是解的变化范数与载荷变化范数之比：\n$$ s = \\frac{\\lVert x_1 - x_0 \\rVert_2}{\\lVert b_1 - b_0 \\rVert_2} $$\n载荷向量中的扰动范数为 $\\lVert b_1 - b_0 \\rVert_2 = \\sqrt{1^2 + (-1)^2} = \\sqrt{2}$，因为它是一个具有两个非零条目 $1$ 和 $-1$ 的向量。\n\n通过对这三个测试用例执行这些步骤，我们预期会观察到，随着通道宽度 $c_w$ 减少和长度 $c_\\ell$ 增加，代数连通度 $\\lambda_2$ 将减小，而条件数 $\\kappa_2(A)$ 和敏感度因子 $s$ 将增加。这说明了何种几何瓶颈会导致代数病态和解敏感度的提高。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite, calculating algebraic\n    connectivity, condition number, and solution sensitivity for different\n    mesh geometries.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\"bx\": 6, \"by\": 6, \"cl\": 6, \"cw\": 3},\n        # Case 2 (narrow isthmus)\n        {\"bx\": 6, \"by\": 6, \"cl\": 6, \"cw\": 1},\n        # Case 3 (long, narrow isthmus)\n        {\"bx\": 6, \"by\": 6, \"cl\": 12, \"cw\": 1},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        b_x = case[\"bx\"]\n        b_y = case[\"by\"]\n        c_l = case[\"cl\"]\n        c_w = case[\"cw\"]\n\n        # Step 1: Domain Construction\n        domain_coords = set()\n        # Left block\n        for x in range(b_x):\n            for y in range(b_y):\n                domain_coords.add((x, y))\n        # Corridor\n        y0 = (b_y - c_w) // 2\n        for x in range(b_x, b_x + c_l):\n            for y in range(y0, y0 + c_w):\n                domain_coords.add((x, y))\n        # Right block\n        for x in range(b_x + c_l, 2 * b_x + c_l):\n            for y in range(b_y):\n                domain_coords.add((x, y))\n\n        sorted_coords = sorted(list(domain_coords))\n        n_vertices = len(sorted_coords)\n        coord_to_idx = {coord: i for i, coord in enumerate(sorted_coords)}\n\n        # Step 2: Construction of the Combinatorial Laplacian L\n        L = np.zeros((n_vertices, n_vertices), dtype=float)\n        for i, (x, y) in enumerate(sorted_coords):\n            degree = 0\n            neighbors = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n            for neighbor_coord in neighbors:\n                if neighbor_coord in domain_coords:\n                    j = coord_to_idx[neighbor_coord]\n                    L[i, j] = -1.0\n                    degree += 1\n            L[i, i] = float(degree)\n\n        # Step 3: Computation of the Algebraic Connectivity lambda_2\n        eigenvalues_L = np.linalg.eigh(L)[0]\n        # Eigenvalues from eigh are sorted. The smallest is ~0.\n        lambda_2 = eigenvalues_L[1]\n\n        # Step 4: Formation of the Grounded Laplacian A\n        ground_idx = coord_to_idx[(0, 0)]\n        A = np.delete(L, ground_idx, axis=0)\n        A = np.delete(A, ground_idx, axis=1)\n\n        # Step 5: Computation of the Condition Number kappa_2(A)\n        eigenvalues_A = np.linalg.eigh(A)[0]\n        kappa_2_A = eigenvalues_A[-1] / eigenvalues_A[0]\n\n        # Step 6: Computation of the Solution Sensitivity s\n        # Define load vertices\n        x_star = 2 * b_x + c_l - 1\n        y_star = b_y // 2\n        \n        coord_a = (x_star, y_star)\n        coord_b = (x_star, y_star + 1)\n        # Check if neighbor is in domain, if not, choose the other one\n        if coord_b not in domain_coords:\n            coord_b = (x_star, y_star - 1)\n\n        # Get original indices\n        idx_a_orig = coord_to_idx[coord_a]\n        idx_b_orig = coord_to_idx[coord_b]\n\n        # Map to reduced indices (after grounding)\n        def get_reduced_idx(orig_idx, ground_idx_val):\n            if orig_idx  ground_idx_val:\n                return orig_idx\n            else: # orig_idx  ground_idx. It cannot be equal since loads are on the right.\n                return orig_idx - 1\n\n        reduced_idx_a = get_reduced_idx(idx_a_orig, ground_idx)\n        reduced_idx_b = get_reduced_idx(idx_b_orig, ground_idx)\n\n        n_reduced = n_vertices - 1\n        b0 = np.zeros(n_reduced, dtype=float)\n        b1 = np.zeros(n_reduced, dtype=float)\n        b0[reduced_idx_a] = 1.0\n        b1[reduced_idx_b] = 1.0\n\n        # Solve linear systems\n        x0 = np.linalg.solve(A, b0)\n        x1 = np.linalg.solve(A, b1)\n\n        # Compute amplification factor\n        delta_x_norm = np.linalg.norm(x1 - x0)\n        delta_b_norm = np.linalg.norm(b1 - b0) # This is sqrt(2)\n        s = delta_x_norm / delta_b_norm\n\n        results.append([lambda_2, kappa_2_A, s])\n\n    # Format the final output string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]},{res[1]},{res[2]}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3372820"}, {"introduction": "最后的这项实践将直面我们所分析的病态问题带来的实际后果。您将量化二维泊松矩阵的条件数在何种程度上会变得过大，以至于压垮标准浮点运算的精度，导致解的有效数字灾难性丢失。此外，您还将探索预处理这一科学计算中的关键技术，学习如何利用它来减轻这些影响并恢复数值解的准确性 [@problem_id:3372810]。", "problem": "考虑模型椭圆偏微分方程 (PDE) Poisson 问题 $-\\Delta u = f$，该问题定义在单位正方形上，并带有齐次 Dirichlet 边界条件。令 $A_h$ 表示在使用标准五点差分格式和网格间距 $h = 1/(n+1)$ 的 $n \\times n$ 内部网格上，对负拉普拉斯算子进行的有限差分；由此产生的线性系统为 $A_h x = b$。矩阵 $A_h$ 是对称正定的。在有限精度算术中求解 $A_h x = b$ 的敏感性由谱范数（欧几里得范数）下的条件数 $\\kappa_2(A_h)$ 决定，其定义为 $\\kappa_2(A_h) = \\|A_h\\|_2 \\|A_h^{-1}\\|_2$，对于对称正定矩阵，该值等于最大特征值与最小特征值之比。机器精度由机器 epsilon $\\epsilon_{\\mathrm{mach}}$ 表征，它是在浮点运算中使 $1 + \\epsilon_{\\mathrm{mach}} \\neq 1$ 成立的最小正数。在共轭梯度 (CG) 方法中，有限精度会导致搜索方向失去正交性，并产生一个与 $\\kappa_2(A_h)\\,\\epsilon_{\\mathrm{mach}}$ 成比例的可达精度极限。请基于以下基本要素进行推导：通过五点差分格式得到的离散算子 $A_h$ 的定义，以及谱条件数和机器 epsilon 的定义。推导二维 Dirichlet 问题中 $\\kappa_2(A_h)$ 对 $h$ 的渐近依赖关系，并用它来确定使得 $\\kappa_2(A_h) \\approx 1/\\epsilon_{\\mathrm{mach}}$ 的网格间距 $h$，这对应于舍入误差导致几乎所有有效数字丢失的阈值。为 IEEE 754 双精度和由 long double 类型表示的扩展精度量化这些阈值。此外，分析简单对角缩放（Jacobi 平衡）$\\tilde{A}_h = D^{-1/2} A_h D^{-1/2}$（其中 $D = \\mathrm{diag}(A_h)$）对此算子条件数的影响，并评估一个移位预处理 $M = A_h + \\alpha I$ 作为右预处理器，即分析 $M^{-1} A_h$ 的谱以减轻敏感性。\n\n你的任务是：\n\n1.  对于给定的 $n$，使用五点差分格式和 $h = 1/(n+1)$，将 $A_h$ 显式构造为一个稀疏矩阵。数值计算其最小和最大特征值，从而计算出 $\\kappa_2(A_h)$。\n\n2.  从离散算子的结构及其谱出发，推导出对于某个常数 $c  0$ 的渐近关系 $\\kappa_2(A_h) \\sim c\\,h^{-2}$。利用此渐近关系，为两种机器精度（IEEE 754 双精度和您环境中的 long double 精度）计算由 $\\kappa_2(A_{h^\\star}) = 1/\\epsilon$ 定义的阈值网格间距 $h^\\star(\\epsilon)$。将 $h^\\star$ 表示为浮点数。\n\n3.  对于一个具有 $n = 32$ 的代表性网格，数值计算 $\\kappa_2(A_h)$，然后使用启发式公式 $d(\\epsilon) = \\max\\{0,-\\log_{10}(\\kappa_2(A_h)\\,\\epsilon)\\}$，估算在无预处理的理想 CG 方法下可获得的解中可信十进制数字的位数。为双精度和 long double 精度计算 $d(\\epsilon)$。将 $d(\\epsilon)$ 表示为浮点数。\n\n4.  通过构建 $\\tilde{A}_h = D^{-1/2}A_hD^{-1/2}$（其中 $D = \\mathrm{diag}(A_h)$）来分析对角缩放。判断此缩放是否改变了该算子的 $\\kappa_2$，并报告一个布尔值表示是否改变（如果 $\\kappa_2$ 改变则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$）。\n\n5.  考虑使用 $M = A_h + \\alpha I$（其中 $\\alpha  0$）作为预处理器的右预处理算子 $M^{-1}A_h$。证明 $M^{-1}A_h$ 的特征值为 $\\lambda_i/( \\lambda_i + \\alpha)$，其中 $\\lambda_i$ 是 $A_h$ 的特征值。利用 $n=32$ 时数值计算得到的极端特征值，评估当选择 $\\alpha = \\lambda_{\\min}(A_h)$ 时 $M^{-1}A_h$ 的条件数，并计算相应的双精度下的 $d(\\epsilon)$。将这些结果表示为浮点数。\n\n角度单位不适用，本问题中没有物理单位。\n\n测试套件：\n- 案例 1 (happy path)：$n = 32$ 用于数值特征值和条件数计算。\n- 案例 2 (boundary thresholds)：根据渐近分析计算 IEEE 754 双精度和 long double 精度的 $h^\\star$。\n- 案例 3 (edge case mitigation)：在 $n=32$ 时使用 $\\alpha = \\lambda_{\\min}(A_h)$ 进行预处理及其对条件数和数字位数的影响。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，并按以下顺序排列结果：\n$[h^\\star_{\\text{double}}, h^\\star_{\\text{longdouble}}, \\kappa_2(A_h)\\ \\text{at}\\ n=32, d_{\\text{double}}\\ \\text{at}\\ n=32, d_{\\text{longdouble}}\\ \\text{at}\\ n=32, \\text{JacobiChanges}, \\kappa_2(M^{-1}A_h)\\ \\text{with}\\ \\alpha=\\lambda_{\\min}, d_{\\text{double,pre}}]$。\n除 $\\text{JacobiChanges}$ 必须为布尔值外，每个条目都必须是浮点数。", "solution": "该问题是有效的，因为它科学地植根于偏微分方程数值分析的原理，问题陈述清晰且提供了足够的信息以获得唯一解，并使用客观、正式的语言表述。我们将进行完整的解答。\n\n该问题研究了线性系统 $A_h x = b$ 的敏感性，该系统源于 Poisson 方程 $-\\Delta u = f$ 在单位正方形上使用齐次 Dirichlet 边界条件的五点有限差分。敏感性由谱条件数 $\\kappa_2(A_h)$ 来量化。\n\n**1. 矩阵构造和数值条件数**\n\n离散算子 $A_h$ 作用于一个按字典序排列的未知网格值向量。对于一个 $n \\times n$ 的内部点网格，网格间距为 $h = 1/(n+1)$，未知数的总数为 $N = n^2$。在网格点 $(i,j)$ 处，负拉普拉斯算子的五点差分格式由下式给出：\n$$\n(-\\Delta u)_{i,j} \\approx \\frac{1}{h^2} (4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1})\n$$\n这种结构产生一个大小为 $n^2 \\times n^2$ 的块三对角矩阵 $A_h$。一种更简洁的构造方法是利用克罗内克积。令 $I_n$ 为 $n \\times n$ 单位矩阵，$T_n$ 为表示一维二阶导数的 $n \\times n$ 三对角矩阵：\n$$\nT_n = \\begin{pmatrix}\n2  -1   \\\\\n-1  2  \\ddots  \\\\\n \\ddots  \\ddots  -1 \\\\\n  -1  2\n\\end{pmatrix}\n$$\n矩阵 $A_h$ 则由下式给出：\n$$\nA_h = \\frac{1}{h^2} (I_n \\otimes T_n + T_n \\otimes I_n)\n$$\n对于像 $A_h$ 这样的对称正定矩阵，谱条件数是其最大特征值与最小特征值之比，即 $\\kappa_2(A_h) = \\lambda_{\\max}(A_h) / \\lambda_{\\min}(A_h)$。对于 $n=32$，我们构造这个 $1024 \\times 1024$ 的矩阵，并数值计算其极端特征值。\n\n**2. 渐近分析和阈值网格间距 $h^\\star$**\n\n$T_n$ 的特征值为 $\\mu_k = 2 - 2\\cos(k\\pi/(n+1)) = 2 - 2\\cos(k\\pi h)$，其中 $k = 1, \\dots, n$。因此，$A_h$ 的特征值可以解析地得知：\n$$\n\\lambda_{k,j} = \\frac{1}{h^2} (\\mu_k + \\mu_j) = \\frac{1}{h^2} (4 - 2\\cos(k\\pi h) - 2\\cos(j\\pi h)) \\quad \\text{其中 } k,j = 1, \\dots, n.\n$$\n最小特征值 $\\lambda_{\\min}$ 对应于最低频率，即 $(k,j)=(1,1)$：\n$$\n\\lambda_{\\min} = \\lambda_{1,1} = \\frac{1}{h^2} (4 - 4\\cos(\\pi h))\n$$\n对小 $x$（即小 $h$）使用泰勒展开 $\\cos(x) \\approx 1 - x^2/2$，我们得到：\n$$\n\\lambda_{\\min} \\approx \\frac{1}{h^2} \\left(4 - 4\\left(1 - \\frac{(\\pi h)^2}{2}\\right)\\right) = \\frac{2\\pi^2 h^2}{h^2} = 2\\pi^2\n$$\n最大特征值 $\\lambda_{\\max}$ 对应于最高频率，即 $(k,j)=(n,n)$：\n$$\n\\lambda_{\\max} = \\lambda_{n,n} = \\frac{1}{h^2} (4 - 2\\cos(n\\pi h) - 2\\cos(n\\pi h)) = \\frac{1}{h^2}(4 - 4\\cos(n\\pi h))\n$$\n由于 $h=1/(n+1)$，我们有 $n\\pi h = n\\pi/(n+1) = \\pi - \\pi/(n+1) = \\pi - \\pi h$。因此，$\\cos(n\\pi h) = \\cos(\\pi - \\pi h) = -\\cos(\\pi h)$。\n$$\n\\lambda_{\\max} = \\frac{1}{h^2} (4 + 4\\cos(\\pi h)) \\approx \\frac{1}{h^2} (4 + 4(1)) = \\frac{8}{h^2}\n$$\n当 $h \\to 0$ 时，条件数的渐近行为是：\n$$\n\\kappa_2(A_h) = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}} \\approx \\frac{8/h^2}{2\\pi^2} = \\frac{4}{\\pi^2 h^2} = c h^{-2} \\quad \\text{其中 } c = \\frac{4}{\\pi^2}\n$$\n阈值网格间距 $h^\\star$ 由 $\\kappa_2(A_{h^\\star}) = 1/\\epsilon_{\\mathrm{mach}}$ 定义。使用渐近公式：\n$$\n\\frac{4}{\\pi^2 (h^\\star)^2} = \\frac{1}{\\epsilon_{\\mathrm{mach}}} \\implies (h^\\star)^2 = \\frac{4 \\epsilon_{\\mathrm{mach}}}{\\pi^2} \\implies h^\\star(\\epsilon_{\\mathrm{mach}}) = \\frac{2\\sqrt{\\epsilon_{\\mathrm{mach}}}}{\\pi}\n$$\n我们为 IEEE 754 双精度（$\\epsilon_{\\text{double}}$）和可用的 long double 精度（$\\epsilon_{\\text{longdouble}}$）计算此值，其具体值取决于执行环境。\n\n**3. CG 方法中的可信数字**\n\n由共轭梯度 (CG) 等迭代方法计算出的解中，可信十进制数字的位数可以通过启发式方法估算。解的相对误差通常受一个与 $\\kappa_2(A_h)\\epsilon_{\\mathrm{mach}}$ 成正比的项所界定。因此，丢失的数字位数与 $\\log_{10}(\\kappa_2(A_h)\\epsilon_{\\mathrm{mach}})$ 相关。可信数字位数 $d(\\epsilon)$ 的一个常用启发式公式是：\n$$\nd(\\epsilon) = \\max\\{0, -\\log_{10}(\\kappa_2(A_h)\\epsilon)\\}\n$$\n我们使用为 $n=32$ 数值计算出的 $\\kappa_2(A_h)$ 值以及双精度和 long double 精度的机器 epsilon 值来应用此公式。\n\n**4. 对角缩放（Jacobi 平衡）**\n\n对角缩放，或称 Jacobi 平衡，是一种预处理技术，其中缩放后的矩阵为 $\\tilde{A}_h = D^{-1/2}A_hD^{-1/2}$，其中 $D = \\mathrm{diag}(A_h)$。对于均匀网格上的标准五点差分格式， $A_h$ 的每个对角线元素都对应于中心节点 $u_{i,j}$ 的系数，该系数统一为 $4/h^2$。因此，$D$ 是单位矩阵的标量倍数：\n$$\nD = \\frac{4}{h^2} I\n$$\n因此，$D^{-1/2} = (\\sqrt{h^2/4})I = (h/2)I$。缩放后的矩阵是：\n$$\n\\tilde{A}_h = \\left(\\frac{h}{2}I\\right) A_h \\left(\\frac{h}{2}I\\right) = \\frac{h^2}{4} A_h\n$$\n由于 $\\tilde{A}_h$ 是 $A_h$ 的标量倍数，其特征值为 $\\tilde{\\lambda}_i = (h^2/4)\\lambda_i$。条件数在标量乘法下是不变的：\n$$\n\\kappa_2(\\tilde{A}_h) = \\frac{\\tilde{\\lambda}_{\\max}}{\\tilde{\\lambda}_{\\min}} = \\frac{(h^2/4)\\lambda_{\\max}}{(h^2/4)\\lambda_{\\min}} = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}} = \\kappa_2(A_h)\n$$\n对于这个特定的算子，Jacobi 缩放对条件数没有影响。因此，所要求的布尔值 `JacobiChanges` 是 `False`。\n\n**5. 移位预处理器分析**\n\n我们分析右预处理算子 $P = M^{-1}A_h$，其中预处理器为 $M = A_h + \\alpha I$，对于某个 $\\alpha  0$。$A_h$ 的特征值为 $\\lambda_i$，对应的特征向量为 $v_i$。由于 $A_h$ 和 $I$ 可交换，它们共享相同的特征向量。因此，$v_i$ 也是 $M$ 的一个特征向量：\n$$\nM v_i = (A_h + \\alpha I) v_i = A_h v_i + \\alpha v_i = (\\lambda_i + \\alpha) v_i\n$$\n算子 $P$ 作用于一个特征向量 $v_i$ 的结果是：\n$$\nP v_i = M^{-1}A_h v_i = M^{-1}(\\lambda_i v_i) = \\lambda_i M^{-1}v_i = \\lambda_i \\frac{1}{\\lambda_i + \\alpha} v_i\n$$\n预处理矩阵 $P$ 的特征值为 $\\mu_i = \\frac{\\lambda_i}{\\lambda_i + \\alpha}$。对于 $x  0$ 和 $\\alpha0$，函数 $f(x) = x/(x+\\alpha)$ 是单调递增的。\n选择 $\\alpha = \\lambda_{\\min}(A_h)$，新的特征值为：\n$$\n\\mu_{\\min} = \\frac{\\lambda_{\\min}}{\\lambda_{\\min} + \\alpha} = \\frac{\\lambda_{\\min}}{\\lambda_{\\min} + \\lambda_{\\min}} = \\frac{1}{2}\n$$\n$$\n\\mu_{\\max} = \\frac{\\lambda_{\\max}}{\\lambda_{\\max} + \\alpha} = \\frac{\\lambda_{\\max}}{\\lambda_{\\max} + \\lambda_{\\min}}\n$$\n预处理系统的条件数为：\n$$\n\\kappa_2(P) = \\frac{\\mu_{\\max}}{\\mu_{\\min}} = \\frac{\\lambda_{\\max}/(\\lambda_{\\max} + \\lambda_{\\min})}{1/2} = \\frac{2\\lambda_{\\max}}{\\lambda_{\\max} + \\lambda_{\\min}} = \\frac{2(\\lambda_{\\max}/\\lambda_{\\min})}{(\\lambda_{\\max}/\\lambda_{\\min}) + 1} = \\frac{2\\kappa_2(A_h)}{\\kappa_2(A_h)+1}\n$$\n这种变换将一个大的条件数 $\\kappa_2(A_h) \\gg 1$ 映射到一个接近 2 的值，这是一个显著的改进。我们使用数值计算得到的 $n=32$ 时的极端特征值来计算这个新的条件数，并计算相应的双精度下可信数字的位数。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Computes various metrics related to the condition number of the finite difference\n    discretization of the 2D Poisson equation.\n    \"\"\"\n    # Define parameters for the main numerical case\n    n = 32\n\n    # Get machine precisions for double and long double floating point types.\n    # Note: The precision of np.longdouble is platform-dependent and may be\n    # equivalent to np.float64 on some systems.\n    eps_double = np.finfo(np.float64).eps\n    eps_longdouble = np.finfo(np.longdouble).eps\n\n    # ---- Task 2: Asymptotic threshold h_star ----\n    # Derive h_star from kappa_2(A_h) = 4 / (pi^2 * h^2) = 1/epsilon\n    # h_star = 2 * sqrt(epsilon) / pi\n    h_star_double = (2.0 * np.sqrt(eps_double)) / np.pi\n    h_star_longdouble = (2.0 * np.sqrt(eps_longdouble)) / np.pi\n\n    # ---- Numerical computations for n=32 ----\n    h = 1.0 / (n + 1)\n    h_sq = h**2\n\n    # ---- Task 1: Construct A_h and compute its condition number ----\n    # Create the 1D discrete Laplacian matrix T_n\n    diagonals = [-1.0 * np.ones(n - 1), 2.0 * np.ones(n), -1.0 * np.ones(n - 1)]\n    offsets = [-1, 0, 1]\n    T_n = diags(diagonals, offsets, shape=(n, n), format='csr')\n    \n    # Create the 2D discrete Laplacian A_h using Kronecker products\n    I_n = identity(n, format='csr')\n    A_h_unscaled = kron(I_n, T_n) + kron(T_n, I_n)\n    A_h = (1.0 / h_sq) * A_h_unscaled\n\n    # Compute extreme eigenvalues (smallest and largest) of A_h.\n    # For a sparse SPD matrix, eigsh with which='BE' (Both Ends) is efficient.\n    # It returns k/2 smallest and k/2 largest eigenvalues. For k=2, this is\n    # the smallest and the largest.\n    try:\n        # eigsh returns eigenvalues in ascending order.\n        eigenvalues = eigsh(A_h, k=2, which='BE', return_eigenvectors=False)\n        lambda_min_A = eigenvalues[0]\n        lambda_max_A = eigenvalues[1]\n    except Exception as e:\n        # Fallback in case 'BE' is not supported or fails, though it should not.\n        # This is more robust.\n        lambda_min_val = eigsh(A_h, k=1, which='SA', return_eigenvectors=False)\n        lambda_max_val = eigsh(A_h, k=1, which='LA', return_eigenvectors=False)\n        lambda_min_A = lambda_min_val[0]\n        lambda_max_A = lambda_max_val[0]\n\n    # Compute the condition number of A_h\n    kappa_A_h = lambda_max_A / lambda_min_A\n\n    # ---- Task 3: Compute trustworthy digits for the original system ----\n    # d(eps) = max(0, -log10(kappa * eps))\n    arg_double = kappa_A_h * eps_double\n    arg_longdouble = kappa_A_h * eps_longdouble\n\n    d_double = max(0.0, -np.log10(arg_double))\n    d_longdouble = max(0.0, -np.log10(arg_longdouble))\n\n    # ---- Task 4: Analyze Jacobi (diagonal) scaling ----\n    # As derived in the solution, for this specific constant-diagonal operator,\n    # Jacobi scaling is equivalent to scalar multiplication and does not change\n    # the condition number.\n    JacobiChanges = False\n\n    # ---- Task 5: Analyze shifted preconditioning ----\n    # Preconditioner M = A_h + alpha*I, with alpha = lambda_min(A_h)\n    alpha = lambda_min_A\n    \n    # The condition number of M_inv * A_h is kappa_new = (2*kappa) / (kappa+1)\n    kappa_M_inv_A = (2.0 * kappa_A_h) / (kappa_A_h + 1.0)\n    # Direct computation from eigenvalues:\n    # kappa_M_inv_A = (2 * lambda_max_A) / (lambda_max_A + lambda_min_A)\n\n    # Compute trustworthy digits for the preconditioned system\n    arg_pre_double = kappa_M_inv_A * eps_double\n    d_double_pre = max(0.0, -np.log10(arg_pre_double))\n    \n    # ---- Final Output Assembly ----\n    # Assemble results in the specified order.\n    results = [\n        h_star_double,\n        h_star_longdouble,\n        kappa_A_h,\n        d_double,\n        d_longdouble,\n        JacobiChanges,\n        kappa_M_inv_A,\n        d_double_pre\n    ]\n\n    # Format the final output string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3372810"}]}