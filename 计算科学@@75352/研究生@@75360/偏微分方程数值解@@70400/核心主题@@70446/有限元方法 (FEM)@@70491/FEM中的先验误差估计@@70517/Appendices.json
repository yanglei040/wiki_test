{"hands_on_practices": [{"introduction": "有限元分析的核心思想之一是将物理域中的复杂计算转移到简单的“参考”单元上进行。然而，为了使这种方法有效，我们必须理解当函数及其导数从参考单元映射回物理单元时，其范数（用于度量误差）会如何变化。这项练习 [@problem_id:2575277] 引导你推导 $H^1$ 半范数在仿射映射下的基本尺度变换关系，揭示误差估计中网格尺寸 $h_K$ 的指数是如何产生的。", "problem": "考虑一个有界利普希茨参考单元 $\\hat K \\subset \\mathbb{R}^{d}$ 和一个物理单元 $K \\subset \\mathbb{R}^{d}$，其中物理单元 $K$ 是通过形式为 $F_{K}(\\hat x) = A_{K}\\hat x + b_{K}$ 的仿射映射 $F_{K} : \\hat K \\to K$ 获得的，并且 $A_{K} \\in \\mathbb{R}^{d \\times d}$ 是可逆的。令 $h_{K}$ 表示 $K$ 的直径。假设单元族是形状正则的，这意味着存在与 $K$ 无关的正常数 $c_{1},c_{2},c_{3},c_{4}$，使得\n- $c_{1} h_{K} \\le \\|A_{K}\\| \\le c_{2} h_{K}$ 且 $c_{3} h_{K}^{-1} \\le \\|A_{K}^{-1}\\| \\le c_{4} h_{K}^{-1}$，\n- 存在 $c_{5},c_{6} > 0$ 使得 $c_{5} h_{K}^{d} \\le |\\det A_{K}| \\le c_{6} h_{K}^{d}$。\n对于 $\\hat v \\in H^{1}(\\hat K)$，通过 $v(x) = \\hat v(F_{K}^{-1}(x))$ 定义 $v \\in H^{1}(K)$。在域 $D$ 上的 $H^{1}$ 半范数定义为 $|w|_{H^{1}(D)} := \\left(\\int_{D} |\\nabla w(x)|^{2} \\, dx \\right)^{1/2}$。\n\n仅使用链式法则和变量替换公式，结合上述界限，确定 $h_{K}$ 的精确幂次，该幂次捕捉了 $H^{1}$ 半范数在映射 $F_{K}$ 下的缩放行为。即，$|v|_{H^{1}(K)}$ 与因子 $S(h_{K},d)$ 乘以 $|\\hat v|_{H^{1}(\\hat K)}$ 成比例（相差一个与 $h_{K}$ 和 $\\hat v$ 无关的常数）。你的最终答案必须是 $S(h_{K},d)$ 作为 $h_{K}$ 和 $d$ 的函数的闭式解析表达式。不要包含任何比例常数；只报告对 $h_{K}$ 和 $d$ 的依赖关系。", "solution": "在尝试任何解答之前，将对所述问题进行严格的验证。\n\n首先，我们精确地提取所给出的信息。\n已知条件如下：\n1.  一个有界利普希茨参考单元 $\\hat K \\subset \\mathbb{R}^{d}$。\n2.  一个物理单元 $K \\subset \\mathbb{R}^{d}$。\n3.  一个由 $F_{K}(\\hat x) = A_{K}\\hat x + b_{K}$ 给出的仿射映射 $F_{K} : \\hat K \\to K$。\n4.  矩阵 $A_{K} \\in \\mathbb{R}^{d \\times d}$ 是可逆的。\n5.  $h_{K}$ 是 $K$ 的直径。\n6.  假设单元族是形状正则的，这意味着存在与 $K$ 无关的正常数 $c_{1}, c_{2}, c_{3}, c_{4}, c_{5}, c_{6}$ 使得：\n    -   $c_{1} h_{K} \\le \\|A_{K}\\| \\le c_{2} h_{K}$\n    -   $c_{3} h_{K}^{-1} \\le \\|A_{K}^{-1}\\| \\le c_{4} h_{K}^{-1}$\n    -   $c_{5} h_{K}^{d} \\le |\\det A_{K}| \\le c_{6} h_{K}^{d}$\n7.  函数 $\\hat v \\in H^{1}(\\hat K)$ 通过拉回操作 $v(x) = \\hat v(F_{K}^{-1}(x))$ 与函数 $v \\in H^{1}(K)$ 相关联。\n8.  在域 $D$ 上的 $H^{1}$ 半范数定义为 $|w|_{H^{1}(D)} := \\left(\\int_{D} |\\nabla w(x)|^{2} \\, dx \\right)^{1/2}$。\n9.  目标是仅使用链式法则、变量替换和给定的界限，确定比例关系 $|v|_{H^{1}(K)} \\propto S(h_{K},d) |\\hat v|_{H^{1}(\\hat K)}$ 中的缩放因子 $S(h_{K},d)$。\n\n接下来，我们验证问题的陈述。\n该问题具有科学依据。它展示了有限元法先验误差分析中的一个标准推导，这是计算力学和工程学的基石。参考单元和物理单元之间的仿射映射、索博列夫空间（$H^{1}$）以及形状正则性条件等概念是该理论的基础。\n该问题是适定的。它要求基于一组清晰的定义和假设，求一个特定的缩放因子。推导所需的所有信息都已提供，且没有内部矛盾。语言客观且数学上精确。\n该问题不违反任何无效性标准。它是形式化的、相关的、完整的、现实的且非平凡的。\n\n结论：问题有效。我们现在开始求解。\n\n目标是建立物理单元 $K$ 上的函数 $v$ 的 $H^{1}$ 半范数与参考单元 $\\hat K$ 上的对应函数 $\\hat v$ 的 $H^{1}$ 半范数之间的关系。我们从 $v$ 的半范数的平方的定义开始：\n$$\n|v|_{H^{1}(K)}^{2} = \\int_{K} |\\nabla_{x} v(x)|^{2} \\, dx\n$$\n此处，$\\nabla_{x}$ 表示关于变量 $x \\in K$ 的梯度。函数 $v$ 定义为 $v(x) = \\hat v(\\hat x)$，其中 $\\hat x = F_{K}^{-1}(x)$。为了将 $\\nabla_{x} v$ 与 $\\nabla_{\\hat x} \\hat v$ 联系起来，我们使用链式法则。逆映射由 $\\hat x = F_{K}^{-1}(x) = A_{K}^{-1}(x - b_{K})$ 给出。这个逆变换的雅可比矩阵是 $J_{F_{K}^{-1}} = A_{K}^{-1}$。\n\n应用向量值函数的链式法则， $v(x) = \\hat v(F_{K}^{-1}(x))$ 关于 $x$ 的梯度为：\n$$\n\\nabla_{x} v(x) = (J_{F_{K}^{-1}})^{T} \\nabla_{\\hat x} \\hat v(\\hat x) = (A_{K}^{-1})^{T} \\nabla_{\\hat x} \\hat v(\\hat x)\n$$\n其中 $\\nabla_{\\hat x} \\hat v$ 是 $\\hat v$ 关于 $\\hat x$ 的梯度。\n\n现在，我们考虑该梯度向量的欧几里得范数的平方：\n$$\n|\\nabla_{x} v(x)|^{2} = \\left| (A_{K}^{-1})^{T} \\nabla_{\\hat x} \\hat v(\\hat x) \\right|^{2}\n$$\n一个向量被矩阵变换后的范数的平方，可以用该矩阵的算子范数来界定。具体来说，我们有不等式：\n$$\n|\\nabla_{x} v(x)|^{2} \\le \\|(A_{K}^{-1})^{T}\\|^{2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2}\n$$\n由于一个矩阵的算子范数等于其转置的范数，即 $\\|(A_{K}^{-1})^{T}\\| = \\|A_{K}^{-1}\\|$，上式变为：\n$$\n|\\nabla_{x} v(x)|^{2} \\le \\|A_{K}^{-1}\\|^{2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2}\n$$\n对于下界，我们使用以下性质：对于一个可逆矩阵 $M$ 和任意向量 $u$，有 $|Mu| \\ge \\|M^{-1}\\|^{-1}|u|$。将此性质应用于矩阵 $(A_{K}^{-1})^{T}$ 和向量 $\\nabla_{\\hat x} \\hat v(\\hat x)$：\n$$\n|\\nabla_{x} v(x)|^{2} = \\left| (A_{K}^{-1})^{T} \\nabla_{\\hat x} \\hat v(\\hat x) \\right|^{2} \\ge \\left( \\| ((A_{K}^{-1})^{T})^{-1} \\|^{-1} |\\nabla_{\\hat x} \\hat v(\\hat x)| \\right)^{2} = \\|(A_{K}^{T})^{-1}\\|^{-2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2}\n$$\n利用性质 $\\|M^{-1}\\|^{-1} = \\sigma_{\\min}(M)$（$M$ 的最小奇异值）和 $\\|M\\| = \\|M^T\\|$，上式可简化为：\n$$\n|\\nabla_{x} v(x)|^{2} \\ge \\|A_{K}^{T}\\|^{-2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2} = \\|A_{K}\\|^{-2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2}\n$$\n综合这些不等式，我们得到了梯度范数平方的界：\n$$\n\\|A_{K}\\|^{-2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2} \\le |\\nabla_{x} v(x)|^{2} \\le \\|A_{K}^{-1}\\|^{2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2}\n$$\n接下来，我们在定义 $|v|_{H^{1}(K)}^{2}$ 的积分中进行变量替换。我们代入 $x = F_{K}(\\hat x)$，这意味着微分体积元变换为 $dx = |\\det(J_{F_{K}})| \\,d\\hat x = |\\det(A_{K})| \\,d\\hat x$。积分区域从 $K$ 变为 $\\hat K$。\n$$\n|v|_{H^{1}(K)}^{2} = \\int_{\\hat K} |\\nabla_{x} v(F_{K}(\\hat x))|^{2} |\\det(A_{K})| \\, d\\hat x\n$$\n将 $|\\nabla_{x} v(x)|^{2}$ 的界代入此积分表达式，我们得到：\n$$\n\\int_{\\hat K} \\|A_{K}\\|^{-2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2} |\\det(A_{K})| \\, d\\hat x \\le |v|_{H^{1}(K)}^{2} \\le \\int_{\\hat K} \\|A_{K}^{-1}\\|^{2} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2} |\\det(A_{K})| \\, d\\hat x\n$$\n涉及 $A_{K}$ 的项相对于积分变量 $\\hat x$ 是常数，因此可以从积分中提出：\n$$\n\\|A_{K}\\|^{-2} |\\det(A_{K})| \\int_{\\hat K} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2} \\, d\\hat x \\le |v|_{H^{1}(K)}^{2} \\le \\|A_{K}^{-1}\\|^{2} |\\det(A_{K})| \\int_{\\hat K} |\\nabla_{\\hat x} \\hat v(\\hat x)|^{2} \\, d\\hat x\n$$\n该积分正是参考单元上 $\\hat v$ 的半范数平方的定义，即 $|\\hat v|_{H^{1}(\\hat K)}^{2}$。因此，我们有：\n$$\n\\|A_{K}\\|^{-2} |\\det(A_{K})| |\\hat v|_{H^{1}(\\hat K)}^{2} \\le |v|_{H^{1}(K)}^{2} \\le \\|A_{K}^{-1}\\|^{2} |\\det(A_{K})| |\\hat v|_{H^{1}(\\hat K)}^{2}\n$$\n现在我们应用给定的形状正则性界限来确定对 $h_{K}$ 的依赖关系。\n对于上界：\n-   $\\|A_{K}^{-1}\\| \\le c_{4} h_{K}^{-1} \\implies \\|A_{K}^{-1}\\|^{2} \\le c_{4}^{2} h_{K}^{-2}$\n-   $|\\det(A_{K})| \\le c_{6} h_{K}^{d}$\n乘积为 $\\|A_{K}^{-1}\\|^{2} |\\det(A_{K})| \\le (c_{4}^{2} h_{K}^{-2})(c_{6} h_{K}^{d}) = c_{4}^{2}c_{6} h_{K}^{d-2}$。\n\n对于下界：\n-   $\\|A_{K}\\| \\le c_{2} h_{K} \\implies \\|A_{K}\\|^{-2} \\ge (c_{2} h_{K})^{-2} = c_{2}^{-2} h_{K}^{-2}$\n-   $|\\det(A_{K})| \\ge c_{5} h_{K}^{d}$\n乘积为 $\\|A_{K}\\|^{-2} |\\det(A_{K})| \\ge (c_{2}^{-2} h_{K}^{-2})(c_{5} h_{K}^{d}) = c_{2}^{-2}c_{5} h_{K}^{d-2}$。\n\n令 $C_{L} = c_{2}^{-2}c_{5}$ 和 $C_{U} = c_{4}^{2}c_{6}$。这些是与 $K$ 无关的正常数。不等式变为：\n$$\nC_{L} h_{K}^{d-2} |\\hat v|_{H^{1}(\\hat K)}^{2} \\le |v|_{H^{1}(K)}^{2} \\le C_{U} h_{K}^{d-2} |\\hat v|_{H^{1}(\\hat K)}^{2}\n$$\n对所有部分取平方根，得到：\n$$\n\\sqrt{C_{L}} (h_{K}^{d-2})^{1/2} |\\hat v|_{H^{1}(\\hat K)} \\le |v|_{H^{1}(K)} \\le \\sqrt{C_{U}} (h_{K}^{d-2})^{1/2} |\\hat v|_{H^{1}(\\hat K)}\n$$\n这表明 $|v|_{H^{1}(K)}$ 与 $h_{K}^{\\frac{d-2}{2}} |\\hat v|_{H^{1}(\\hat K)}$ 成比例，其比例常数与 $h_{K}$ 和 $\\hat v$ 无关。\n问题要求找到捕捉对 $h_{K}$ 和 $d$ 依赖关系的缩放因子 $S(h_{K},d)$。根据我们的推导，这个因子是 $h_{K}^{\\frac{d-2}{2}}$。", "answer": "$$\n\\boxed{h_{K}^{\\frac{d-2}{2}}}\n$$", "id": "2575277"}, {"introduction": "先验误差理论的一个重要预测是，使用更高阶的多项式（即增加 $k$）可以获得更快的收敛速度。然而，这一预测依赖于解本身足够光滑的假设。这项练习 [@problem_id:2557615] 探究了一个关键的例外情况：当求解区域存在凹角（re-entrant corner）时，解在角点附近会产生奇性，从而降低其光滑性。你将分析这种奇性如何成为收敛速度的瓶颈，即使使用高阶单元也无法突破这一限制，这是一个在实际工程问题中至关重要的概念。", "problem": "考虑一个有界多边形区域 $\\Omega \\subset \\mathbb{R}^{2}$ 以及一族协调、形状正则、拟一致的三角剖分 $\\{\\mathcal{T}_{h}\\}_{h>0}$，其网格尺寸为 $h$。令 $V_{h}^{k} \\subset H^{1}(\\Omega)$ 表示总多项式次数为 $k \\in \\mathbb{N}$ 的标准 $C^{0}$ 拉格朗日有限元空间。对于一个目标函数 $u:\\Omega \\to \\mathbb{R}$，其 Sobolev 正则性为 $u \\in H^{s}(\\Omega)$（对于某个 $s>0$），令 $\\Pi_{h}:L^{2}(\\Omega)\\to V_{h}^{k}$ 为任意一个局部的、$H^{m}$-稳定的拟插值算子（例如 Scott–Zhang 算子），该算子能够再生最高次数为 $k$ 的多项式。\n\n1) 从 Bramble–Hilbert 引理和在每个 $K \\in \\mathcal{T}_{h}$ 上的尺度变换论证出发，推导一个形如\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(\\Omega)} \\leq C\\, h^{t}\\, |u|_{H^{t}(\\Omega)},\n$$\n的 $L^{2}$-逼近估计，该估计对所有满足 $0  t \\le \\min\\{s, k+1\\}$ 的 $t$ 有效，并确定收敛阶。\n\n2) 给定一个有凹角的多边形 $\\Omega_{\\omega}$，其在原点处的内角为 $\\omega > \\pi$。考虑由拉普拉斯方程 $\\Delta u = 0$ 产生的典型角点奇异性函数 $u_{\\lambda}(r,\\theta) = r^{\\lambda}\\sin(\\lambda\\theta)$，其中 $\\lambda = \\pi/\\omega$。对于任意 $\\epsilon > 0$，确定该函数的最大 Sobolev 正则性指数 $s_{eff} = s_{lim} - \\epsilon$，使得 $u_{\\lambda} \\in H^s(\\Omega_\\omega)$ 对所有 $s \\le s_{eff}$ 均成立。利用这个结果，确定拟一致网格上有限元逼近的收敛阶，该收敛阶受限于该解的正则性。\n\n3) 考虑一个具有 $L$ 形的域，其凹角为 $\\omega = \\frac{3\\pi}{2}$，并使用分片二次拉格朗日有限元（即 $k=2$）。计算在 $L^{2}$-范数下，有限元解收敛于 $u_{\\lambda}$ 的（潜在的次优）收敛阶指数。", "solution": "该问题是有限元方法先验误差分析中的一个标准练习，尤其关注解的正则性对收敛阶的影响。我们依次处理这三个部分。\n\n对于第一部分，我们推导 $L^2$-范数误差估计。目标是找到 $\\|u - \\Pi_{h}u\\|_{L^{2}(\\Omega)}$ 的一个界。我们首先将全局误差分解为在三角剖分 $\\mathcal{T}_{h}$ 的单元 $K$ 上的局部误差之和：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(\\Omega)}^{2} = \\sum_{K \\in \\mathcal{T}_{h}} \\|u - \\Pi_{h}u\\|_{L^{2}(K)}^{2}.\n$$\n我们分析单个单元 $K$ 上的局部误差。拟插值算子 $\\Pi_{h}$ 被定义为可以再生最高次数为 $k$ 的多项式。也就是说，对于任意多项式 $p \\in \\mathcal{P}_{k}(\\Omega)$，其中 $\\mathcal{P}_{k}$ 是总次数最多为 $k$ 的多项式空间，我们有 $\\Pi_{h}p = p$。利用此性质，对于任意 $p \\in \\mathcal{P}_{k}$，我们可以写出：\n$$\nu - \\Pi_{h}u = (u - p) - \\Pi_{h}(u - p).\n$$\n对 $L^{2}(K)$-范数应用三角不等式可得：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(K)} \\leq \\|u - p\\|_{L^{2}(K)} + \\|\\Pi_{h}(u - p)\\|_{L^{2}(K)}.\n$$\n问题陈述 $\\Pi_h$ 是一个局部的、$H^{m}$-稳定的算子。对于 $L^2$ 估计，我们假设在 $L^2$-范数下是稳定的（即 $m=0$）。算子的局部性意味着 $\\Pi_h v$ 在一个单元 $K$ 上的值仅依赖于 $v$ 在一个由相邻单元组成的小片区域（我们记为 $\\omega_K$）上的值。稳定性则意味着存在一个与 $h$ 和 $v$ 无关的常数 $C_{stab}$，使得：\n$$\n\\|\\Pi_{h}v\\|_{L^{2}(K)} \\leq C_{stab} \\|v\\|_{L^{2}(\\omega_K)}.\n$$\n将此应用于 $\\|\\Pi_{h}(u-p)\\|_{L^2(K)}$ 项可得：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(K)} \\leq \\|u - p\\|_{L^{2}(K)} + C_{stab} \\|u - p\\|_{L^{2}(\\omega_K)}.\n$$\n由于 $K \\subset \\omega_K$，我们可以合并这些项：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(K)} \\leq (1+C_{stab}) \\|u - p\\|_{L^{2}(\\omega_K)}.\n$$\n这个不等式对任意多项式 $p \\in \\mathcal{P}_{k}$ 都成立。因此，我们可以选择使右侧最小化的多项式：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(K)} \\leq (1+C_{stab}) \\inf_{p \\in \\mathcal{P}_{k}} \\|u - p\\|_{L^{2}(\\omega_K)}.\n$$\nBramble–Hilbert 引理，结合从参考单元出发的尺度变换论证，为这个多项式逼近误差提供了一个估计。对于像 $\\omega_K$ 这样的区域以及函数 $v \\in H^{t}(\\omega_K)$，以下标准逼近结果对 $0 \\leq j \\leq t$ 和 $t \\leq k+1$ 成立：\n$$\n\\inf_{p \\in \\mathcal{P}_{k}} \\|v-p\\|_{H^{j}(\\omega_K)} \\leq C (\\text{diam}(\\omega_K))^{t-j} |v|_{H^{t}(\\omega_K)}.\n$$\n由于网格是拟一致的，片区 $\\omega_K$ 的直径与网格尺寸 $h$ 成正比，即 $\\text{diam}(\\omega_K) \\le C'h$。设 $j=0$ 并将其应用于我们的函数 $u$，假设 $u \\in H^t(\\omega_K)$，我们得到：\n$$\n\\inf_{p \\in \\mathcal{P}_{k}} \\|u - p\\|_{L^{2}(\\omega_K)} \\leq C h^{t} |u|_{H^{t}(\\omega_K)}.\n$$\n这对任何满足 $0  t \\leq k+1$ 的 $t$ 都成立。为了使 $|u|_{H^{t}(\\omega_K)}$ 项有意义，我们还要求全局函数 $u$ 至少具有这么多的正则性，即 $u \\in H^s(\\Omega)$ 且 $t \\le s$。结合这些约束，该估计对 $0  t \\leq \\min\\{k+1, s\\}$ 成立。将此代入我们的局部误差界：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(K)}^{2} \\leq C_{loc}^2 h^{2t} |u|_{H^{t}(\\omega_K)}^{2} = C_{loc}^2 h^{2t} \\sum_{K' \\subset \\omega_K} |u|_{H^{t}(K')}^{2}.\n$$\n我们对所有单元 $K \\in \\mathcal{T}_{h}$ 求和以获得全局误差：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(\\Omega)}^{2} = \\sum_{K \\in \\mathcal{T}_{h}} \\|u - \\Pi_{h}u\\|_{L^{2}(K)}^{2} \\leq C h^{2t} \\sum_{K \\in \\mathcal{T}_{h}} \\sum_{K' \\subset \\omega_K} |u|_{H^{t}(K')}^{2}.\n$$\n网格族是形状正则和拟一致的假设意味着存在一个有限的重叠数。因此我们可以重排求和顺序：\n$$\n\\sum_{K \\in \\mathcal{T}_{h}} \\sum_{K' \\subset \\omega_K} |u|_{H^{t}(K')}^{2} \\leq C_{overlap} \\sum_{K' \\in \\mathcal{T}_{h}} |u|_{H^{t}(K')}^{2} = C_{overlap} |u|_{H^{t}(\\Omega)}^{2}.\n$$\n这导出了全局估计 $\\|u - \\Pi_{h}u\\|_{L^{2}(\\Omega)}^{2} \\leq C' h^{2t} |u|_{H^{t}(\\Omega)}^{2}$。开平方根得到所需结果：\n$$\n\\|u - \\Pi_{h}u\\|_{L^{2}(\\Omega)} \\leq C h^{t} |u|_{H^{t}(\\Omega)},\n$$\n对 $0  t \\leq \\min\\{k+1,s\\}$ 成立。这意味着收敛阶为 $O(h^{\\min\\{k+1,s\\}})$。\n\n对于第二部分，我们分析奇异函数 $u_{\\lambda}(r,\\theta) = r^{\\lambda}\\sin(\\lambda \\theta)$，其中 $\\lambda = \\pi/\\omega$。如果一个函数直到 $s$ 阶的弱导数都在 $L^{2}(\\Omega)$ 中，则该函数属于 $H^{s}(\\Omega)$。奇异点在原点（$r=0$）。$u_{\\lambda}$ 的一个 $m$ 阶整数阶偏导数在原点附近的行为类似于 $r^{\\lambda-m}$。我们检查一个在 $r=0$ 附近形如 $g(r,\\theta) \\sim r^{\\beta}$ 的项的平方可积性。在极坐标中，$L^2$ 范数的平方涉及积分 $\\int_0^{\\epsilon} r^{2\\beta} r \\, dr$。此积分收敛当且仅当 $2\\beta+1 > -1$，可简化为 $\\beta > -1$。\n对于一个 $m$ 阶偏导数，其径向行为是 $r^{\\lambda-m}$。为了使其属于 $L^2(\\Omega_{\\omega})$，我们必须有 $\\lambda-m > -1$，这意味着 $m  \\lambda+1$。这意味着对于所有整数 $m  \\lambda+1$，$u_{\\lambda} \\in H^{m}(\\Omega_{\\omega})$，并且通过插值，对于所有实数 $s  \\lambda+1$，$u_{\\lambda} \\in H^{s}(\\Omega_{\\omega})$。反之，一个阶数 $m \\ge \\lambda+1$ 的导数将有一个径向分量 $r^\\beta$ 且 $\\beta \\le -1$，其积分是发散的。因此，对于任何 $s \\ge \\lambda+1$，$u_{\\lambda} \\notin H^{s}(\\Omega_{\\omega})$。极限 Sobolev 正则性为 $s_{lim} = \\lambda+1$。因此，第1部分的收敛阶 $O(h^{\\min\\{k+1,s\\}})$ 被限制为 $O(h^{\\min\\{k+1, \\lambda+1 - \\epsilon\\}})$ 对于任意 $\\epsilon > 0$。由于角奇异点的污染效应，已知这个收敛阶在拟一致网格上是尖锐的，即收敛阶为 $\\min\\{k+1, \\lambda+1-\\epsilon\\}$。\n\n对于第三部分，给定角度 $\\omega = \\frac{3\\pi}{2}$ 和二次单元，这对应于多项式次数 $k=2$。我们计算奇异性指数 $\\lambda$：\n$$\n\\lambda = \\frac{\\pi}{\\omega} = \\frac{\\pi}{3\\pi/2} = \\frac{2}{3}.\n$$\n根据第2部分，决定收敛阶的有效 Sobolev 正则性指数是 $s_{eff} = \\lambda+1 - \\epsilon$：\n$$\ns_{eff} = \\frac{2}{3} + 1 - \\epsilon = \\frac{5}{3} - \\epsilon.\n$$\n根据第1部分，$L^2$-范数下的收敛指数是 $\\min\\{k+1, s_{eff}\\}$。当 $k=2$ 时，最大可能的指数是 $k+1 = 3$。我们将其与正则性限制的指数进行比较：\n$$\n\\text{exponent} = \\min\\left\\{3, \\frac{5}{3} - \\epsilon \\right\\}.\n$$\n由于 $3 = \\frac{9}{3}$，我们有 $\\min\\{\\frac{9}{3}, \\frac{5}{3} - \\epsilon\\} = \\frac{5}{3} - \\epsilon$。当 $\\epsilon \\to 0$ 时，收敛阶指数趋向于 $\\frac{5}{3}$。", "answer": "$$\n\\boxed{\\frac{5}{3}}\n$$", "id": "2557615"}, {"introduction": "理论误差估计（如 $O(h^{k+1})$）为我们提供了评估有限元方法性能的强大工具，但通过数值模拟亲眼见证这些理论速率的出现，能带来更深刻的理解。这项练习 [@problem_id:2395840] 将指导你编写一个完整的有限元程序，来求解一个简单的泊松问题。通过在一系列加密的网格上计算误差，并对结果进行数据拟合，你将能够从计算上测量收敛阶，并验证先验误差理论的预测。", "problem": "设计并实现一个完整的程序，该程序从第一性原理出发，验证应用于一维泊松问题的协调有限元方法在 $L_2$ 范数下的收敛速度。考虑在开区间 $(0,1)$ 上的边值问题：求解 $u \\in H_0^1(0,1)$，使得\n$$\n-\\frac{d^2 u}{dx^2} = f \\quad \\text{in } (0,1), \\qquad u(0)=0, \\quad u(1)=0,\n$$\n其精确解指定为 $u(x) = \\sin(\\pi x)$，从而 $f(x) = \\pi^2 \\sin(\\pi x)$。对于多项式次数 $k \\in \\{1,2\\}$，以及将 $(0,1)$ 均匀划分为 $N$ 个尺寸为 $h = 1/N$ 的单元，令 $V_h^k \\subset H_0^1(0,1)$ 表示网格上次数至多为 $k$ 的连续分段多项式空间。令 $u_h \\in V_h^k$ 为满足伽辽金变分公式的唯一函数\n$$\n\\int_0^1 \\frac{d u_h}{dx}(x)\\, \\frac{d v_h}{dx}(x)\\, dx = \\int_0^1 f(x)\\, v_h(x)\\, dx \\quad \\text{for all } v_h \\in V_h^k,\n$$\n其中齐次狄利克雷边界条件已包含在 $V_h^k$ 中。对于一组递减的网格尺寸，定义 $L_2$ 误差\n$$\nE(h) = \\left(\\int_0^1 \\left(u(x) - u_h(x)\\right)^2\\, dx \\right)^{1/2},\n$$\n并将观测收敛速度 $r$ 定义为在给定网格尺寸集上，在最小二乘意义下最佳拟合幂律 $E(h) \\approx C h^r$ 的实数，即，对于实数 $a$ 和 $r$，使 $\\sum_i \\left(\\log E(h_i) - (a + r \\log h_i)\\right)^2$ 最小化的 $r$ 值。\n\n计算实验必须产生以下测试套件结果，每个结果都完全源自上述数学定义：\n\n- 测试用例 A (理想路径)：$k = 1$，单元数 $N \\in \\{10,20,40,80,160\\}$。\n- 测试用例 B (高阶空间)：$k = 2$，单元数 $N \\in \\{8,16,32,64\\}$。\n- 测试用例 C (渐近区域边界)：$k = 1$，单元数 $N \\in \\{2,4,8,16\\}$。\n\n对每个测试用例，计算如上定义的观测速度 $r$。此外，对每个测试用例，输出一个布尔标志，表明不等式 $r \\geq k+1 - \\delta$ 是否成立，其中测试用例 A 的 $\\delta = 0.1$，测试用例 B 的 $\\delta = 0.2$，测试用例 C 的 $\\delta = 0.4$。所有角度均以弧度为单位，且不涉及物理单位。\n\n您的程序必须生成单行输出，其中包含按以下顺序聚合到单个列表中的所有结果：\n$[r_A, r_B, r_C, b_A, b_B, b_C]$，\n其中 $r_A$、$r_B$ 和 $r_C$ 分别是测试用例 A、B 和 C 的观测收敛速度，$b_A$、$b_B$ 和 $b_C$ 是对应的布尔标志。例如，输出应为单行，格式为 $[r_1,r_2,r_3,b_1,b_2,b_3]$，无任何附加文本。", "solution": "问题陈述是计算工程领域一个有效且适定的练习。它在科学上基于求解偏微分方程的有限元方法 (FEM) 理论。所有参数和目标都经过了精确的数学定义。我现在将提供解决方案。\n\n该问题要求对带齐次狄利克雷边界条件的一维泊松问题的协调有限元方法的收敛速度进行数值验证。问题表述为：求解 $u \\in H_0^1(0,1)$，使得\n$$\n-\\frac{d^2 u}{dx^2} = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0) = u(1) = 0.\n$$\n精确解被指定为 $u(x) = \\sin(\\pi x)$，这意味着强迫函数必须是 $f(x) = \\pi^2 \\sin(\\pi x)$。\n\n有限元方法的核心是将此微分方程转换为其弱形式或变分形式。我们求解 $u \\in H_0^1(0,1)$，使得对于所有测试函数 $v \\in H_0^1(0,1)$：\n$$\n\\int_0^1 \\frac{du}{dx}(x) \\frac{dv}{dx}(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx.\n$$\n这是通过将原方程乘以一个测试函数 $v$，在定义域 $(0,1)$ 上积分，并应用分部积分法，同时并入边界条件来实现的。我们定义双线性形式 $a(u,v) = \\int_0^1 u'v' \\,dx$ 和线性形式 $L(v) = \\int_0^1 fv \\,dx$。问题就变成了求解 $u \\in H_0^1(0,1)$，使得对于所有 $v \\in H_0^1(0,1)$，都有 $a(u,v) = L(v)$。\n\n为了数值求解此问题，我们引入一个有限维子空间 $V_h^k \\subset H_0^1(0,1)$。定义域 $(0,1)$ 被划分为 $N$ 个尺寸为 $h=1/N$ 的均匀单元。空间 $V_h^k$ 由在此划分上次数至多为 $k$ 的连续分段多项式函数组成。下标 $h$ 表示对网格尺寸的依赖性。条件 $V_h^k \\subset H_0^1(0,1)$ 意味着该空间中的任何函数在边界 $x=0$ 和 $x=1$ 处都必须为零。\n\n伽辽金方法旨在寻找一个近似解 $u_h \\in V_h^k$，使得\n$$\na(u_h, v_h) = L(v_h) \\quad \\text{for all } v_h \\in V_h^k.\n$$\n设 $\\{\\phi_j\\}_{j=1}^{M}$ 是 $V_h^k$ 的一组基函数，其中 $M$ 是该空间的维度（内部自由度的数量）。近似解可以写成这些基函数的线性组合：\n$$\nu_h(x) = \\sum_{j=1}^{M} c_j \\phi_j(x),\n$$\n其中 $c_j$ 是未知系数。将此代入伽辽金公式，并选择基函数本身作为测试函数（即对于 $i=1,\\dots,M$，$v_h = \\phi_i$），我们得到一个线性代数方程组：\n$$\n\\sum_{j=1}^{M} c_j a(\\phi_j, \\phi_i) = L(\\phi_i) \\quad \\text{for } i=1,\\dots,M.\n$$\n这是一个线性系统 $A\\mathbf{c} = \\mathbf{b}$，其中刚度矩阵 $A$ 的元素为 $A_{ij} = a(\\phi_j, \\phi_i)$，载荷向量 $\\mathbf{b}$ 的元素为 $b_i = L(\\phi_i)$，而 $\\mathbf{c} = [c_1, \\dots, c_M]^T$ 是未知系数向量。\n\n实际实现涉及以下步骤：\n\n1.  **组装：** 定义矩阵 $A$ 和向量 $\\mathbf{b}$ 元素的积分是逐个单元计算的。这是通过将每个物理单元 $[x_e, x_{e+1}]$ 映射到一个标准的参考单元（例如 $\\hat{I}=[-1,1]$）来完成的。基函数定义在此参考单元上。对于次数 $k$，有 $k+1$ 个局部基函数（拉格朗日多项式）。\n    积分被转换为：\n    $$\n    A_{ij}^e = \\int_{x_e}^{x_{e+1}} \\frac{d\\phi_j}{dx} \\frac{d\\phi_i}{dx} \\, dx, \\quad b_i^e = \\int_{x_e}^{x_{e+1}} f(x) \\phi_i(x) \\, dx.\n    $$\n    使用坐标变换 $x(\\xi) = x_e + \\frac{h}{2}(\\xi+1)$，这些积分就变成了在 $\\xi \\in [-1,1]$ 上的积分。由于被积函数可能不是简单的多项式，因此使用数值积分（特别是高斯积分）来确保精确计算。然后，根据局部和全局节点索引之间的映射关系，将单元贡献量 $A_{ij}^e$ 和 $b_i^e$ 添加到全局系统 $A\\mathbf{c} = \\mathbf{b}$ 中。\n\n2.  **求解：** 所得的线性系统是对称正定的。可以使用标准的数值线性代数程序求解系数向量 $\\mathbf{c}$。一旦 $\\mathbf{c}$ 已知，近似解 $u_h(x)$ 就完全确定了。\n\n3.  **误差计算：** 计算 $L_2$ 误差 $E(h)$ 以评估解的准确性：\n    $$\n    E(h) = \\| u - u_h \\|_{L_2(0,1)} = \\left( \\int_0^1 (u(x) - u_h(x))^2 \\, dx \\right)^{1/2}.\n    $$\n    这个积分也通过使用足够阶数的逐单元高斯积分进行数值计算，以确保准确性。\n\n4.  **收敛速度估计：** 有限元方法的先验误差估计预测，对于一个足够光滑的解 $u$，当 $h \\to 0$ 时，$L_2$ 误差以 $E(h) \\approx C h^{k+1}$ 的形式收敛，其中 $C$ 是某个常数。为了对这个关系进行数值验证，我们取该关系的对数：\n    $$\n    \\log E(h) \\approx \\log C + (k+1) \\log h.\n    $$\n    这表明 $\\log E(h)$ 和 $\\log h$ 之间存在线性关系。对于一组与网格尺寸集 $\\{h_i\\}$ 对应的计算误差 $\\{E(h_i)\\}$，我们对数据点 $(\\log h_i, \\log E(h_i))$ 进行线性最小二乘拟合。所得直线的斜率就是观测到的收敛阶数 $r$。问题将 $r$ 定义为使平方残差和 $\\sum_i (\\log E(h_i) - (a + r \\log h_i))^2$ 最小化的值。这是一个标准的线性回归问题。\n\n对问题陈述中指定的每个测试用例执行上述计算过程。然后将所得的速度 $r$ 与理论期望值 $k+1$ 进行比较，其中使用提供的容差 $\\delta$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom typing import List, Dict, Any, Callable, Tuple\n\ndef get_basis_functions(k: int) - Tuple[int, np.ndarray, Callable, Callable]:\n    \"\"\"\n    Returns Lagrange basis functions and their derivatives on the reference element [-1, 1].\n\n    Args:\n        k: The polynomial degree (1 or 2).\n\n    Returns:\n        A tuple containing:\n        - Number of local basis functions.\n        - Nodal points on the reference element.\n        - A function that evaluates all basis functions at a point xi.\n        - A function that evaluates all basis function derivatives at a point xi.\n    \"\"\"\n    if k == 1:\n        num_basis = 2\n        nodes = np.array([-1.0, 1.0])\n        def basis_vals(xi: float) - np.ndarray:\n            return np.array([(1.0 - xi) / 2.0, (1.0 + xi) / 2.0])\n        def basis_ders(xi: float) - np.ndarray:\n            # Derivatives are constant for linear basis functions\n            return np.array([-0.5, 0.5])\n        return num_basis, nodes, basis_vals, basis_ders\n    elif k == 2:\n        num_basis = 3\n        nodes = np.array([-1.0, 0.0, 1.0])\n        def basis_vals(xi: float) - np.ndarray:\n            return np.array([\n                xi * (xi - 1.0) / 2.0,\n                1.0 - xi**2,\n                xi * (xi + 1.0) / 2.0\n            ])\n        def basis_ders(xi: float) - np.ndarray:\n            return np.array([\n                xi - 0.5,\n                -2.0 * xi,\n                xi + 0.5\n            ])\n        return num_basis, nodes, basis_vals, basis_ders\n    else:\n        raise ValueError(\"This implementation only supports polynomial degrees k=1 and k=2.\")\n\ndef solve_fem_poisson_1d(k: int, N: int, num_quad_points: int = 5) - float:\n    \"\"\"\n    Solves the 1D Poisson problem using the Finite Element Method.\n\n    Args:\n        k: The polynomial degree of the basis functions.\n        N: The number of elements in the uniform mesh.\n        num_quad_points: The number of points for Gaussian quadrature.\n\n    Returns:\n        The L2 error of the numerical solution.\n    \"\"\"\n    h = 1.0 / N\n    f = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u_exact = lambda x: np.sin(np.pi * x)\n\n    num_local_basis, _, ref_basis_vals, ref_basis_ders = get_basis_functions(k)\n    num_dofs = k * N - 1\n\n    A = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n\n    xi_q, w_q = roots_legendre(num_quad_points)\n\n    # Assembly loop over elements\n    for e in range(N):\n        x_e = e * h\n        A_elem = np.zeros((num_local_basis, num_local_basis))\n        b_elem = np.zeros(num_local_basis)\n\n        # Quadrature loop for element matrix and vector\n        for i in range(num_quad_points):\n            xi, w = xi_q[i], w_q[i]\n            x_phys = x_e + (h / 2.0) * (xi + 1.0)\n            jacobian = h / 2.0\n            \n            grads = ref_basis_ders(xi)\n            vals = ref_basis_vals(xi)\n            \n            # Element stiffness matrix\n            for p in range(num_local_basis):\n                for q in range(num_local_basis):\n                    A_elem[p, q] += (grads[q] / jacobian) * (grads[p] / jacobian) * w * jacobian\n            \n            # Element load vector\n            for p in range(num_local_basis):\n                b_elem[p] += f(x_phys) * vals[p] * w * jacobian\n\n        # Map local contributions to global system\n        for p_loc in range(num_local_basis):\n            p_glob_node = k * e + p_loc\n            if 0  p_glob_node  k * N:\n                p_dof = p_glob_node - 1\n                b[p_dof] += b_elem[p_loc]\n                for q_loc in range(num_local_basis):\n                    q_glob_node = k * e + q_loc\n                    if 0  q_glob_node  k * N:\n                        q_dof = q_glob_node - 1\n                        A[p_dof, q_dof] += A_elem[p_loc, q_loc]\n    \n    # Solve for coefficients\n    coeffs = np.linalg.solve(A, b)\n\n    # Compute L2 error\n    error_sq = 0.0\n    for e in range(N):\n        x_e = e * h\n        for i in range(num_quad_points):\n            xi, w = xi_q[i], w_q[i]\n            x_phys = x_e + (h / 2.0) * (xi + 1.0)\n            jacobian = h / 2.0\n            \n            u_val = u_exact(x_phys)\n            \n            uh_val = 0.0\n            vals = ref_basis_vals(xi)\n            for p_loc in range(num_local_basis):\n                p_glob_node = k * e + p_loc\n                node_coeff = 0.0\n                if 0  p_glob_node  k * N:\n                    p_dof = p_glob_node - 1\n                    node_coeff = coeffs[p_dof]\n                uh_val += node_coeff * vals[p_loc]\n            \n            error_sq += (u_val - uh_val)**2 * w * jacobian\n\n    return np.sqrt(error_sq)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'id': 'A', 'k': 1, 'N_list': [10, 20, 40, 80, 160], 'delta': 0.1},\n        {'id': 'B', 'k': 2, 'N_list': [8, 16, 32, 64], 'delta': 0.2},\n        {'id': 'C', 'k': 1, 'N_list': [2, 4, 8, 16], 'delta': 0.4}\n    ]\n\n    rates = {}\n    flags = {}\n\n    for case in test_cases:\n        k = case['k']\n        N_list = case['N_list']\n        delta = case['delta']\n        \n        h_values = 1.0 / np.array(N_list)\n        error_values = np.array([solve_fem_poisson_1d(k, N) for N in N_list])\n        \n        log_h = np.log(h_values)\n        log_e = np.log(error_values)\n        \n        # Calculate convergence rate r via linear regression slope\n        r, _ = np.polyfit(log_h, log_e, 1)\n        \n        # Check against theoretical rate k+1 with tolerance delta\n        passes_check = r = (k + 1.0 - delta)\n        \n        rates[case['id']] = r\n        flags[case['id']] = passes_check\n\n    # Assemble final list in the specified order: [r_A, r_B, r_C, b_A, b_B, b_C]\n    final_results = [\n        rates['A'], rates['B'], rates['C'],\n        flags['A'], flags['B'], flags['C']\n    ]\n    \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2395840"}]}