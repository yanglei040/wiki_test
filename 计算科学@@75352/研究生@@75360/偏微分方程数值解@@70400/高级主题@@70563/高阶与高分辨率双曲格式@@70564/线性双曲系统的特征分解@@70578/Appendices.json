{"hands_on_practices": [{"introduction": "本练习是特征分解的基础实践。通过解析求解线性浅水方程的经典黎曼问题，您将直接应用特征值、特征向量和波强度投影等概念，以理解初始间断如何分解为传播波。这项基本计算将巩固您对线性双曲系统核心理论的理解。[@problem_id:3369623]", "problem": "考虑由常系数偏微分方程（PDE）给出的线性双曲系统\n$$\n\\partial_{t}\\boldsymbol{u}(x,t) + A\\,\\partial_{x}\\boldsymbol{u}(x,t) = \\boldsymbol{0}, \\quad A = \\begin{pmatrix} 0 & 1 \\\\ g H & 0 \\end{pmatrix},\n$$\n其中引力加速度$g>0$，背景深度$H>0$。设黎曼初始数据为\n$$\n\\boldsymbol{u}(x,0) = \\begin{cases}\n\\boldsymbol{u}_{L}, & x0,\\\\\n\\boldsymbol{u}_{R},  x>0,\n\\end{cases}\n$$\n其中$\\boldsymbol{u}_{L},\\boldsymbol{u}_{R}\\in\\mathbb{R}^{2}$是常数的左、右状态。将跳跃记为$\\Delta \\boldsymbol{u} = \\boldsymbol{u}_{R} - \\boldsymbol{u}_{L}$，其分量记为$\\Delta u_{1}$和$\\Delta u_{2}$。仅使用严格双曲性、矩阵$A$的特征分解以及线性系统的特征投影等基本定义，推导与每个族相关的特征波强度以及在时间$t0$时所有间断点的位置。将波强度$\\alpha_{+}$和$\\alpha_{-}$定义为跳跃在$A$的右特征向量上的分解，其中$\\alpha_{+}$对应于右行特征，$\\alpha_{-}$对应于左行特征。将您的最终答案表示为单个行矩阵\n$$\n\\left(\\alpha_{+},\\,\\alpha_{-},\\,x_{-}(t),\\,x_{+}(t)\\right),\n$$\n其中$x_{-}(t)$和$x_{+}(t)$分别是时间$t0$时左行和右行间断点的位置。提供一个用$g$、$H$、$t$、$\\Delta u_{1}$和$\\Delta u_{2}$表示的精确符号表达式。不需要四舍五入，最终答案中不应包含任何单位。", "solution": "该问题是有效的。这是一个在偏微分方程领域内提法良好的、有科学依据的问题，具体涉及线性双曲系统的特征分解。所有必要的数据和定义都已给出，没有矛盾或含糊之处。\n\n给定的线性双曲系统是\n$$\n\\partial_{t}\\boldsymbol{u}(x,t) + A\\,\\partial_{x}\\boldsymbol{u}(x,t) = \\boldsymbol{0},\n$$\n其中$\\boldsymbol{u}(x,t) \\in \\mathbb{R}^{2}$，常系数矩阵$A$为\n$$\nA = \\begin{pmatrix} 0  1 \\\\ g H  0 \\end{pmatrix}.\n$$\n该问题描述了一个黎曼问题，其初始数据由两个常数状态组成，即$x0$时的$\\boldsymbol{u}_{L}$和$x>0$时的$\\boldsymbol{u}_{R}$。对于线性双曲系统，此类问题的解是通过将初始跳跃$\\Delta \\boldsymbol{u} = \\boldsymbol{u}_{R} - \\boldsymbol{u}_{L}$分解到矩阵$A$的特征向量上构建的。\n\n首先，我们必须对$A$进行特征分解。特征值$\\lambda$是特征方程$\\det(A - \\lambda I) = 0$的根。\n$$\n\\det\\begin{pmatrix} 0-\\lambda  1 \\\\ gH  0-\\lambda \\end{pmatrix} = (-\\lambda)(-\\lambda) - (1)(gH) = \\lambda^{2} - gH = 0.\n$$\n由于$g>0$且$H>0$，特征值是实数且不相等：\n$$\n\\lambda_{\\pm} = \\pm\\sqrt{gH}.\n$$\n存在两个不相等的实特征值证实了该系统是严格双曲的。这些特征值代表信息传播的特征速度。正特征值$\\lambda_{+} = \\sqrt{gH}$对应一个右行波，负特征值$\\lambda_{-} = -\\sqrt{gH}$对应一个左行波。\n\n接下来，我们通过求解$(A - \\lambda_{\\pm} I)\\boldsymbol{r}_{\\pm} = \\boldsymbol{0}$来找到相应的右特征向量$\\boldsymbol{r}_{\\pm}$。\n\n对于特征值$\\lambda_{+} = \\sqrt{gH}$：\n$$\n(A - \\lambda_{+}I)\\boldsymbol{r}_{+} = \\begin{pmatrix} -\\sqrt{gH}  1 \\\\ gH  -\\sqrt{gH} \\end{pmatrix} \\begin{pmatrix} r_{1,+} \\\\ r_{2,+} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}.\n$$\n这给出了方程$-\\sqrt{gH}r_{1,+} + r_{2,+} = 0$，意味着$r_{2,+} = \\sqrt{gH}r_{1,+}$。我们可以选择$r_{1,+} = 1$，得到特征向量\n$$\n\\boldsymbol{r}_{+} = \\begin{pmatrix} 1 \\\\ \\sqrt{gH} \\end{pmatrix}.\n$$\n该特征向量对应于右行特征族。\n\n对于特征值$\\lambda_{-} = -\\sqrt{gH}$：\n$$\n(A - \\lambda_{-}I)\\boldsymbol{r}_{-} = \\begin{pmatrix} \\sqrt{gH}  1 \\\\ gH  \\sqrt{gH} \\end{pmatrix} \\begin{pmatrix} r_{1,-} \\\\ r_{2,-} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}.\n$$\n这给出了方程$\\sqrt{gH}r_{1,-} + r_{2,-} = 0$，意味着$r_{2,-} = -\\sqrt{gH}r_{1,-}$。我们可以选择$r_{1,-} = 1$，得到特征向量\n$$\n\\boldsymbol{r}_{-} = \\begin{pmatrix} 1 \\\\ -\\sqrt{gH} \\end{pmatrix}.\n$$\n该特征向量对应于左行特征族。\n\n黎曼问题的解由与每个特征族相关的波的叠加给出。初始数据的跳跃$\\Delta \\boldsymbol{u} = \\boldsymbol{u}_{R} - \\boldsymbol{u}_{L}$被分解为右特征向量的线性组合。这个分解的系数是特征波的强度，记为$\\alpha_{+}$和$\\alpha_{-}$。\n$$\n\\Delta \\boldsymbol{u} = \\alpha_{+} \\boldsymbol{r}_{+} + \\alpha_{-} \\boldsymbol{r}_{-}.\n$$\n代入$\\Delta \\boldsymbol{u} = \\begin{pmatrix} \\Delta u_{1} \\\\ \\Delta u_{2} \\end{pmatrix}$和特征向量的表达式，我们得到一个关于波强度的线性系统：\n$$\n\\begin{pmatrix} \\Delta u_{1} \\\\ \\Delta u_{2} \\end{pmatrix} = \\alpha_{+} \\begin{pmatrix} 1 \\\\ \\sqrt{gH} \\end{pmatrix} + \\alpha_{-} \\begin{pmatrix} 1 \\\\ -\\sqrt{gH} \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ \\sqrt{gH}  -\\sqrt{gH} \\end{pmatrix} \\begin{pmatrix} \\alpha_{+} \\\\ \\alpha_{-} \\end{pmatrix}.\n$$\n我们求解这个方程组以得到$\\alpha_{+}$和$\\alpha_{-}$。从第一行，我们有$\\alpha_{+} + \\alpha_{-} = \\Delta u_{1}$。从第二行，我们有$\\sqrt{gH}(\\alpha_{+} - \\alpha_{-}) = \\Delta u_{2}$，这给出$\\alpha_{+} - \\alpha_{-} = \\frac{\\Delta u_{2}}{\\sqrt{gH}}$。\n\n将这两个方程相加：\n$$\n(\\alpha_{+} + \\alpha_{-}) + (\\alpha_{+} - \\alpha_{-}) = \\Delta u_{1} + \\frac{\\Delta u_{2}}{\\sqrt{gH}} \\implies 2\\alpha_{+} = \\Delta u_{1} + \\frac{\\Delta u_{2}}{\\sqrt{gH}}.\n$$\n$$\n\\alpha_{+} = \\frac{1}{2}\\Delta u_{1} + \\frac{\\Delta u_{2}}{2\\sqrt{gH}}.\n$$\n从第一个新方程中减去第二个新方程：\n$$\n(\\alpha_{+} + \\alpha_{-}) - (\\alpha_{+} - \\alpha_{-}) = \\Delta u_{1} - \\frac{\\Delta u_{2}}{\\sqrt{gH}} \\implies 2\\alpha_{-} = \\Delta u_{1} - \\frac{\\Delta u_{2}}{\\sqrt{gH}}.\n$$\n$$\n\\alpha_{-} = \\frac{1}{2}\\Delta u_{1} - \\frac{\\Delta u_{2}}{2\\sqrt{gH}}.\n$$\n这些分别是右行波和左行波的强度。\n\n间断点的位置$x_{-}(t)$和$x_{+}(t)$由特征速度决定。对于线性常系数系统，间断点是接触间断，它们从原点$x=0$发出，并以等于特征值的恒定速度传播。\n时间$t0$时右行间断点的位置由其速度$\\lambda_{+}$乘以时间$t$给出：\n$$\nx_{+}(t) = \\lambda_{+} t = \\sqrt{gH}t.\n$$\n时间$t0$时左行间断点的位置由其速度$\\lambda_{-}$乘以时间$t$给出：\n$$\nx_{-}(t) = \\lambda_{-} t = -\\sqrt{gH}t.\n$$\n解$\\boldsymbol{u}(x,t)$是分段常数，当$x  x_{-}(t)$时$\\boldsymbol{u}(x,t) = \\boldsymbol{u}_{L}$，当$x > x_{+}(t)$时$\\boldsymbol{u}(x,t) = \\boldsymbol{u}_{R}$，以及在$x_{-}(t)  x  x_{+}(t)$之间存在一个常数的中间状态。\n\n我们现在将所需的量组合成一个单行矩阵$(\\alpha_{+}, \\alpha_{-}, x_{-}(t), x_{+}(t))$：\n$$\n\\left( \\frac{1}{2}\\Delta u_{1} + \\frac{\\Delta u_{2}}{2\\sqrt{gH}}, \\quad \\frac{1}{2}\\Delta u_{1} - \\frac{\\Delta u_{2}}{2\\sqrt{gH}}, \\quad -\\sqrt{gH}t, \\quad \\sqrt{gH}t \\right).\n$$\n该表达式按要求提供了完整的特征分解和所产生间断点的动力学。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}\\Delta u_{1} + \\frac{\\Delta u_{2}}{2\\sqrt{gH}}  \\frac{1}{2}\\Delta u_{1} - \\frac{\\Delta u_{2}}{2\\sqrt{gH}}  -\\sqrt{gH}t  \\sqrt{gH}t\n\\end{pmatrix}\n}\n$$", "id": "3369623"}, {"introduction": "从解析解转向数值验证，本实践将指导您为周期域上的线性双曲系统创建一个“精确解”生成器。这项结合了特征分解和傅里叶变换的强大技术是代码验证的基石，使您能够精确地测量高阶数值格式的误差。这个练习将理论与计算科学中的关键实践技能联系起来。[@problem_id:3369531]", "problem": "考虑在周期性边界条件下的一维空间常系数线性双曲系统，\n$$\n\\partial_t \\mathbf{u}(x,t) + A\\,\\partial_x \\mathbf{u}(x,t) = \\mathbf{0}, \\quad x \\in [0,L), \\quad t \\ge 0,\n$$\n其中 $\\mathbf{u}(x,t) \\in \\mathbb{R}^m$，$A \\in \\mathbb{R}^{m \\times m}$ 是一个常数矩阵， $L0$ 是区域长度。当 $A$ 具有实特征值和一组完备的特征向量时，该系统是双曲的。令 $R \\in \\mathbb{R}^{m \\times m}$ 表示右特征向量矩阵，$\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_m) \\in \\mathbb{R}^{m \\times m}$ 表示特征值对角矩阵，从而有 $A = R \\Lambda R^{-1}$。引入特征变量 $\\boldsymbol{\\alpha}(x,t) = L^\\top \\mathbf{u}(x,t)$，其中 $L^\\top = R^{-1}$。\n\n仅使用以下基本事实：(i) 线性系统满足叠加原理，(ii) 双曲性意味着可以对角化为独立的特征族，以及 (iii) 对于周期性区域，傅里叶级数可以逐模式地解耦线性常系数空间导数，推导出一个表示，通过每个特征场依据其平流速度进行时间推进，并从特征变量重构 $\\mathbf{u}(x,t)$，从而为该系统生成一个精确解生成器。您的程序必须对三角函数初始数据以数值精确的方式实现此表示，方法是结合特征分解与快速傅里叶变换 (FFT) 在 $[0,L)$ 上实现周期性平移。\n\n此外，为了跨多个波族验证高阶方法的有效性，请使用标准的中心5点模板对 $\\partial_x$ 实现一个4阶精度的空间离散化，并结合经典的4级4阶 Runge–Kutta 时间积分器。使用基于最大波速绝对值的 Courant–Friedrichs–Lewy (CFL) 步长限制。通过将数值解与基于特征-傅里叶表示构建的精确解生成器进行比较，计算在指定最终时刻的相对 $\\ell^2$ 误差。\n\n空间区域是周期的， $L = 2\\pi$ ，由包含 $N$ 个点的均匀网格离散化，其中 $N = 256$。对于每个测试，通过以下公式确定时间步长 $\\Delta t$：\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_j|\\lambda_j|}, \\quad \\Delta x = L/N,\n$$\n使用 $\\mathrm{CFL} = 0.3$，并通过取 $n$ 个等步长积分到指定的最终时间，使得 $n\\,\\Delta t = T$（取 $n$ 为满足 $n \\ge T/\\Delta t$ 的最小正整数，然后重置 $\\Delta t \\leftarrow T/n$）。\n\n您的程序必须实现以下三个测试用例。在每个用例中，通过 $A = R \\Lambda R^{-1}$ 构建 $A$，定义特征初始数据 $\\alpha_j(x)$，然后设置 $\\mathbf{u}(x,0) = R\\,\\boldsymbol{\\alpha}(x)$，其中 $\\boldsymbol{\\alpha}(x) = (\\alpha_1(x),\\dots,\\alpha_m(x))^\\top$。演化至时间 $T$。\n\n- 测试 #1 (双波声学型系统)：\n  - $m=2, R = \\begin{pmatrix}1  1\\\\ 1  -1\\end{pmatrix}, \\Lambda = \\mathrm{diag}(1,-1)$.\n  - $\\alpha_1(x) = \\sin(3x) + 0.5\\cos(5x)$, $\\alpha_2(x) = 0.3\\cos(2x) - 0.4\\sin(4x)$.\n  - $T = 0.7$.\n\n- 测试 #2 (三波系统，含一个静止族)：\n  - $m=3, R = \\begin{pmatrix}1  1  0\\\\ 0  1  1\\\\ 1  0  1\\end{pmatrix}, \\Lambda = \\mathrm{diag}(-2,0,3)$.\n  - $\\alpha_1(x) = 0.8\\sin(2x) + 0.2\\cos(7x)$, $\\alpha_2(x) = 0.5\\sin(5x)$, $\\alpha_3(x) = 0.4\\cos(3x) - 0.1\\sin(9x)$.\n  - $T = 0.5$.\n\n- 测试 #3 (三波系统，具有重复速度但有完备特征基)：\n  - $m=3, R = \\begin{pmatrix}1  0  1\\\\ 0  1  1\\\\ 0  1  0\\end{pmatrix}, \\Lambda = \\mathrm{diag}(1,1,-0.5)$.\n  - $\\alpha_1(x) = \\sin(x) + 0.25\\cos(4x)$, $\\alpha_2(x) = 0.6\\cos(6x)$, $\\alpha_3(x) = 0.3\\sin(3x) - 0.2\\cos(8x)$.\n  - $T = 1.1$.\n\n定义与所需计算：\n- 精确解生成器必须实现特征投影 $\\boldsymbol{\\alpha}(x,0) = L^\\top \\mathbf{u}(x,0)$，使用其傅里叶级数将每个 $\\alpha_j$ 以速度 $\\lambda_j$ 进行周期性平移推进，并重构 $\\mathbf{u}(x,T) = R\\,\\boldsymbol{\\alpha}(x,T)$。\n- 高阶数值格式必须通过4阶中心模板离散化 $\\partial_x$\n$$\n(\\partial_x f)(x_i) \\approx \\frac{-f_{i+2} + 8 f_{i+1} - 8 f_{i-1} + f_{i-2}}{12\\,\\Delta x},\n$$\n  以周期性索引方式逐分量应用，并使用经典的4级4阶 Runge–Kutta 方法对半离散系统 $\\partial_t \\mathbf{u}_h = -A\\,\\partial_x \\mathbf{u}_h$ 进行时间推进。\n\n对于每个测试，报告在时间 $T$ 的相对 $\\ell^2$ 误差，\n$$\n\\varepsilon = \\frac{\\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_h(x_i,T) - \\mathbf{u}_{\\mathrm{exact}}(x_i,T)\\|_2^2 \\,\\Delta x\\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_{\\mathrm{exact}}(x_i,T)\\|_2^2 \\,\\Delta x\\right)^{1/2}},\n$$\n其中 $\\|\\cdot\\|_2$ 是 $\\mathbb{R}^m$ 中的欧几里得范数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试 #1、#2 和 #3 的三个相对误差，形式为用方括号括起来的逗号分隔列表（例如，$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3]$）。不涉及单位；所有量均为无量纲。", "solution": "该问题要求解一个一维常系数线性双曲系统 $\\partial_t \\mathbf{u}(x,t) + A\\,\\partial_x \\mathbf{u}(x,t) = \\mathbf{0}$，定义在周期性区域 $x \\in [0,L)$ 上。我们被要求开发两种求解方法：一种是基于特征分解和傅里叶变换的精确解生成器，另一种是使用有限差分和 Runge-Kutta 积分器的高阶数值格式。最后，我们必须为三个指定的测试用例计算这两种解之间的相对 $\\ell^2$ 误差。\n\n### 1. 特征分解\n\n求解此系统的核心在于其双曲性，该性质保证了矩阵 $A$ 可用实特征值对角化。这意味着存在一个可逆矩阵 $R$（其列是 $A$ 的右特征向量）和一个对角矩阵 $\\Lambda$（由相应的实特征值 $\\lambda_j$ 构成），使得 $A = R \\Lambda R^{-1}$。\n\n我们可以利用此性质来解耦这个包含 $m$ 个偏微分方程(PDE)的系统。我们通过变换 $\\mathbf{u}(x,t) = R\\,\\boldsymbol{\\alpha}(x,t)$ 定义特征变量 $\\boldsymbol{\\alpha}(x,t)$。因此，$\\boldsymbol{\\alpha}(x,t) = R^{-1}\\,\\mathbf{u}(x,t)$。将此代入原始偏微分方程系统可得：\n$$\n\\partial_t (R\\,\\boldsymbol{\\alpha}) + A\\,\\partial_x (R\\,\\boldsymbol{\\alpha}) = \\mathbf{0}\n$$\n由于 $R$ 是常数矩阵，可以将其从导数中提出：\n$$\nR\\,\\partial_t \\boldsymbol{\\alpha} + (R \\Lambda R^{-1})\\,R\\,\\partial_x \\boldsymbol{\\alpha} = \\mathbf{0}\n$$\n$$\nR\\,\\partial_t \\boldsymbol{\\alpha} + R \\Lambda\\,\\partial_x \\boldsymbol{\\alpha} = \\mathbf{0}\n$$\n从左侧乘以 $R^{-1}$（由于 $A$ 可对角化，故 $R^{-1}$ 存在），我们得到一个关于特征变量 $\\boldsymbol{\\alpha}$ 的解耦系统：\n$$\n\\partial_t \\boldsymbol{\\alpha} + \\Lambda\\,\\partial_x \\boldsymbol{\\alpha} = \\mathbf{0}\n$$\n因为 $\\Lambda$ 是一个对角矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_1, \\dots, \\lambda_m)$，这个向量方程代表了 $m$ 个独立的标量平流方程：\n$$\n\\partial_t \\alpha_j + \\lambda_j\\,\\partial_x \\alpha_j = 0, \\quad \\text{for } j = 1, \\dots, m\n$$\n每个方程描述了一个波，或称特征场 $\\alpha_j(x,t)$，它以恒定速度 $\\lambda_j$ 传播（平流），且其形状不发生改变。\n\n### 2. 通过傅里叶变换求解精确解\n\n标量平流方程 $\\partial_t f + c\\,\\partial_x f = 0$ 的解是初始剖面的简单平移：$f(x,t) = f(x - c t, 0)$。因此，每个特征变量的精确解是：\n$$\n\\alpha_j(x,t) = \\alpha_j(x - \\lambda_j t, 0)\n$$\n对于区间 $[0,L)$ 上的周期函数，可以使用傅里叶变换高效地执行此平移，且不会产生数值误差。函数 $f(x)$ 的傅里叶级数为 $f(x) = \\sum_k \\hat{f}_k e^{i k_x x}$，其中 $k_x = 2\\pi k/L$ 是波数。傅里叶变换的平移性质表明，实空间中的位移对应于傅里叶空间中的相位调制：\n$$\nf(x - d) \\quad \\longleftrightarrow \\quad \\hat{f}_k e^{-i k_x d}\n$$\n这为在任意时间 $T$ 生成精确解提供了一个方法：\n1.  **构造初始数据**：每个测试用例都给定了特征变量的初始条件 $\\boldsymbol{\\alpha}(x,0)$。\n2.  **在傅里叶空间中演化**：对每个分量 $\\alpha_j(x,0)$：\n    a.  使用快速傅里叶变换 (FFT) 算法计算其离散傅里叶变换 (DFT)，得到一组离散波数 $k_n$ 对应的系数 $\\hat{\\alpha}_j(k_n, 0)$。\n    b.  将每个系数乘以相应的相位因子 $e^{-i k_n \\lambda_j T}$，以获得时间 $T$ 时的傅里叶系数：\n    $$\n    \\hat{\\alpha}_j(k_n, T) = \\hat{\\alpha}_j(k_n, 0) e^{-i k_n \\lambda_j T}\n    $$\n    c.  计算 $\\hat{\\alpha}_j(k_n, T)$ 的逆离散傅里叶变换 (IDFT)，以在物理空间中恢复平移后的特征剖面 $\\alpha_j(x,T)$。\n3.  **重构物理变量**：结合演化后的特征变量，使用关系式 $\\mathbf{u}(x,T) = R\\,\\boldsymbol{\\alpha}(x,T)$ 来找到 $\\mathbf{u}(x,T)$ 的最终解。\n\n此过程之所以是“精确的”，是因为它避免了时间步进误差和空间离散误差，其精度仅受浮点运算的限制。\n\n### 3. 高阶数值解\n\n数值解是通过在空间和时间上离散化偏微分方程系统来计算的。\n半离散系统为 $\\frac{d}{dt}\\mathbf{u}_h(t) = -A (\\partial_x \\mathbf{u}_h)(t)$，其中 $\\mathbf{u}_h$ 表示空间网格上的解。\n\n**空间离散化**：在均匀网格 $x_i = i\\,\\Delta x$（其中 $i=0,\\dots,N-1$，$\\Delta x = L/N$）上，使用一个4阶精度的5点中心有限差分模板来近似空间导数 $\\partial_x$。给定网格函数 $f_i = f(x_i)$，其导数近似为：\n$$\n(\\partial_x f)(x_i) \\approx \\frac{-f_{i+2} + 8 f_{i+1} - 8 f_{i-1} + f_{i-2}}{12\\,\\Delta x}\n$$\n周期性边界条件通过模 $N$ 的索引算术来处理。此算子逐分量地应用于向量 $\\mathbf{u}_h(x_i, t)$。\n\n**时间积分**：我们求解得到的常微分方程 (ODE) 系统 $\\frac{d}{dt}\\mathbf{U}(t) = \\mathcal{F}(\\mathbf{U}(t))$，其中 $\\mathbf{U}$ 是拼接所有 $\\mathbf{u}_h(x_i, t)$ 得到的大状态向量，而 $\\mathcal{F}$ 表示半离散化的右侧项 $-A \\cdot (\\text{模板算子})$。积分采用经典的4级4阶 Runge-Kutta (RK4) 方法。对于从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单步积分：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathcal{F}(\\mathbf{U}(t_n)) \\\\\n\\mathbf{k}_2 = \\mathcal{F}(\\mathbf{U}(t_n) + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathcal{F}(\\mathbf{U}(t_n) + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathcal{F}(\\mathbf{U}(t_n) + \\Delta t \\mathbf{k}_3) \\\\\n\\mathbf{U}(t_{n+1}) = \\mathbf{U}(t_n) + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n时间步长 $\\Delta t$ 根据 CFL 条件 $\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_j|\\lambda_j|}$ 选择以确保稳定性。为了精确达到最终时间 $T$，我们找到满足 $n\\,\\Delta t \\ge T$ 的最小整数步数 $n$，然后将时间步长调整为 $\\Delta t' = T/n$。\n\n### 4. 误差计算\n\n在最终时间 $T$ 计算出网格点 $x_i$ 上的精确解 $\\mathbf{u}_{\\mathrm{exact}}(x_i, T)$ 和数值解 $\\mathbf{u}_h(x_i, T)$ 之后，计算相对 $\\ell^2$ 误差。向量值网格函数 $\\mathbf{v}(x_i)$ 的离散 $\\ell^2$ 范数为 $\\|\\mathbf{v}\\|_{\\ell^2} = \\left(\\sum_{i=0}^{N-1} \\|\\mathbf{v}(x_i)\\|_2^2 \\,\\Delta x\\right)^{1/2}$，其中 $\\|\\cdot\\|_2$ 是 $\\mathbb{R}^m$ 中的标准欧几里得向量范数。相对误差则为：\n$$\n\\varepsilon = \\frac{\\|\\mathbf{u}_h - \\mathbf{u}_{\\mathrm{exact}}\\|_{\\ell^2}}{\\|\\mathbf{u}_{\\mathrm{exact}}\\|_{\\ell^2}} = \\frac{\\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_h(x_i,T) - \\mathbf{u}_{\\mathrm{exact}}(x_i,T)\\|_2^2 \\,\\Delta x\\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_{\\mathrm{exact}}(x_i,T)\\|_2^2 \\,\\Delta x\\right)^{1/2}}\n$$\n该度量通过将数值格式的输出与通过特征-傅里叶方法生成的真实解进行比较，来量化其精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_test_case(m, R, Lambda, alpha_funcs, T, N, CFL):\n    \"\"\"\n    Solves a linear hyperbolic system for a single test case.\n\n    This function performs the following steps:\n    1. Sets up the spatial grid and system matrices.\n    2. Constructs the initial condition u(x, 0) from the given characteristic data.\n    3. Computes the \"exact\" solution at time T using characteristic decomposition\n       and the Fast Fourier Transform (FFT) for periodic translation.\n    4. Computes the numerical solution at time T using a 4th-order finite\n       difference scheme for space and the classical 4th-order Runge-Kutta\n       method for time.\n    5. Calculates the relative l2 error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Setup\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.linspace(0, L, N, endpoint=False)\n    \n    R = np.array(R, dtype=float)\n    Lambda = np.diag(Lambda)\n    A = R @ Lambda @ np.linalg.inv(R)\n\n    # 2. Initial Condition\n    alpha_initial = np.zeros((N, m))\n    for j in range(m):\n        alpha_initial[:, j] = alpha_funcs[j](x)\n    u0 = alpha_initial @ R.T\n\n    # 3. Exact Solution Generator at Time T\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    alpha_final = np.zeros_like(alpha_initial, dtype=complex)\n    for j in range(m):\n        alpha_j_0_hat = np.fft.fft(alpha_initial[:, j])\n        lambda_j = Lambda[j, j]\n        phase_shift = np.exp(-1j * k * lambda_j * T)\n        alpha_j_T_hat = alpha_j_0_hat * phase_shift\n        alpha_final[:, j] = np.fft.ifft(alpha_j_T_hat)\n    \n    # The result should be real; take the real part to discard small imaginary noise\n    u_exact_T = (alpha_final @ R.T).real\n\n    # 4. Numerical Solution\n    \n    # Spatial derivative function (4th-order centered difference)\n    def spatial_derivative(u, dx_val):\n        # np.roll implements periodic boundary conditions\n        du_dx = (\n            -np.roll(u, -2, axis=0) + 8 * np.roll(u, -1, axis=0)\n            - 8 * np.roll(u, 1, axis=0) + np.roll(u, 2, axis=0)\n        ) / (12 * dx_val)\n        return du_dx\n\n    # RHS of the semi-discrete system: d_t u = -A * d_x u\n    def rhs(u, dx_val, A_mat):\n        du_dx = spatial_derivative(u, dx_val)\n        # Using u @ A.T is equivalent to (A @ u.T).T but can be more efficient\n        return - (du_dx @ A_mat.T)\n\n    # Time-stepping setup\n    lambda_max = np.max(np.abs(np.diag(Lambda)))\n    if lambda_max == 0: # Handle stationary wave case\n      dt_cfl = T # Avoid division by zero, take one large step\n    else:\n      dt_cfl = CFL * dx / lambda_max\n      \n    num_steps = int(np.ceil(T / dt_cfl))\n    dt = T / num_steps\n\n    # RK4 Integration\n    u_numerical = u0.copy()\n    for _ in range(num_steps):\n        k1 = rhs(u_numerical, dx, A)\n        k2 = rhs(u_numerical + dt/2 * k1, dx, A)\n        k3 = rhs(u_numerical + dt/2 * k2, dx, A)\n        k4 = rhs(u_numerical + dt * k3, dx, A)\n        u_numerical += dt/6 * (k1 + 2*k2 + 2*k3 + k4)\n\n    # 5. Error Calculation\n    diff = u_numerical - u_exact_T\n    \n    # Discrete l2 norm: sqrt(sum(|v_i|^2 * dx))\n    numerator_sq = np.sum(np.linalg.norm(diff, axis=1)**2) * dx\n    denominator_sq = np.sum(np.linalg.norm(u_exact_T, axis=1)**2) * dx\n    \n    if denominator_sq == 0:\n        return 0.0\n    \n    error = np.sqrt(numerator_sq / denominator_sq)\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the errors.\n    \"\"\"\n    # Common parameters\n    N = 256\n    CFL = 0.3\n\n    test_cases = [\n        {\n            \"m\": 2, \"T\": 0.7,\n            \"R\": [[1, 1], [1, -1]],\n            \"Lambda\": [1, -1],\n            \"alpha_funcs\": [\n                lambda x: np.sin(3*x) + 0.5*np.cos(5*x),\n                lambda x: 0.3*np.cos(2*x) - 0.4*np.sin(4*x)\n            ]\n        },\n        {\n            \"m\": 3, \"T\": 0.5,\n            \"R\": [[1, 1, 0], [0, 1, 1], [1, 0, 1]],\n            \"Lambda\": [-2, 0, 3],\n            \"alpha_funcs\": [\n                lambda x: 0.8*np.sin(2*x) + 0.2*np.cos(7*x),\n                lambda x: 0.5*np.sin(5*x),\n                lambda x: 0.4*np.cos(3*x) - 0.1*np.sin(9*x)\n            ]\n        },\n        {\n            \"m\": 3, \"T\": 1.1,\n            \"R\": [[1, 0, 1], [0, 1, 1], [0, 1, 0]],\n            \"Lambda\": [1, 1, -0.5],\n            \"alpha_funcs\": [\n                lambda x: np.sin(x) + 0.25*np.cos(4*x),\n                lambda x: 0.6*np.cos(6*x),\n                lambda x: 0.3*np.sin(3*x) - 0.2*np.cos(8*x)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_test_case(\n            m=case[\"m\"],\n            R=case[\"R\"],\n            Lambda=case[\"Lambda\"],\n            alpha_funcs=case[\"alpha_funcs\"],\n            T=case[\"T\"],\n            N=N,\n            CFL=CFL\n        )\n        results.append(f\"{error:.16e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3369531"}, {"introduction": "最后的这项实践将挑战您直面朴素特征方法的一个关键限制：在系统矩阵变得亏损（defective）的点附近的数值不稳定性。通过实现并比较两种针对特征值合并（coalescing）系统的不同迎风通量格式，您将获得关于设计鲁棒数值格式的实践见解，即使在特征分解病态时也能保持稳定和准确。[@problem_id:3369632]", "problem": "考虑一维线性双曲型偏微分方程组\n$$\n\\partial_t \\mathbf{u}(x,t) + A(x)\\,\\partial_x \\mathbf{u}(x,t) = 0,\\quad x\\in[-1,1],\\ t\\ge 0,\n$$\n该方程组具有周期性边界条件和未知向量场 $\\mathbf{u}:\\mathbb{R}\\times\\mathbb{R}_{\\ge 0}\\to\\mathbb{R}^2$。系数矩阵由变系数系统给出\n$$\nA(x) = \\begin{pmatrix} x  1 \\\\ 0  -x \\end{pmatrix}.\n$$\n该系统在 $x\\neq 0$ 时是严格双曲的，其特征值为 $\\lambda_1(x)=x$ 和 $\\lambda_2(x)=-x$，而在 $x=0$ 处变为亏损（defective），此时特征值合并为 $0$，且只有一个线性无关的特征向量。在 $x=0$ 附近的病态性对依赖于特征向量分解的基于特征的迎风通量构成了挑战。\n\n你必须在定义域 $[-1,1]$ 上，使用具有 $N$ 个单元的均匀网格，并采用周期性边界条件，为此系统实现一个一阶有限体积法。设单元宽度为 $\\Delta x = 2/N$，单元中心为 $x_i=-1+(i+\\tfrac{1}{2})\\Delta x$（其中 $i=0,\\dots,N-1$），单元面为 $x_{i+\\frac{1}{2}}=-1+(i+1)\\Delta x$（其中 $i=0,\\dots,N-1$），并采用周期性索引。初始化\n$$\n\\mathbf{u}(x,0) = \\begin{pmatrix} \\sin(2\\pi x) \\\\ \\cos(2\\pi x) \\end{pmatrix}.\n$$\n定义半离散一阶守恒更新格式\n$$\n\\mathbf{u}_i^{n+1} = \\mathbf{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\mathbf{F}_{i+\\frac{1}{2}}^n - \\mathbf{F}_{i-\\frac{1}{2}}^n\\right),\n$$\n其中 $\\mathbf{F}_{i+\\frac{1}{2}}$ 表示在面 $x_{i+\\frac{1}{2}}$ 处的数值通量，$\\Delta t$ 是时间步长。使用与 Courant–Friedrichs–Lewy (CFL) 条件一致的均匀时间步长，该条件基于所有面上的 $A(x)$ 的最大谱半径，即 $\\Delta t = \\text{CFL} \\cdot \\Delta x / \\max_{i} \\rho(A(x_{i+\\frac{1}{2}}))$，其中 $\\rho(\\cdot)$ 表示谱半径。由于 $\\rho(A(x)) = \\max\\{|\\lambda_1(x)|,|\\lambda_2(x)|\\} = |x|$，所有面上的全局最大值为 $1$，因此 $\\Delta t = \\text{CFL}\\cdot\\Delta x$。积分至时间 $T$。\n\n在每个面 $x_{i+\\frac{1}{2}}$ 处实现并比较两种通量构造方法：\n\n1. 基于特征分解的迎风通量（记为变体U）：令 $A=A(x_{i+\\frac{1}{2}})$，计算其特征分解 $A=R\\Lambda R^{-1}$，其中 $\\Lambda=\\mathrm{diag}(\\lambda_1,\\lambda_2)$。将 $\\Lambda^+$ 和 $\\Lambda^-$ 定义为对角元分别为 $(\\max(\\lambda_k,0))$ 和 $(\\min(\\lambda_k,0))$ 的对角矩阵。然后设置\n$$\nA^+ = R\\Lambda^+ R^{-1},\\quad A^- = R\\Lambda^- R^{-1},\\quad \\mathbf{F}_{i+\\frac{1}{2}} = A^+\\mathbf{u}_i + A^-\\mathbf{u}_{i+1}.\n$$\n在 $x=0$ 附近，矩阵接近亏损，而在 $x=0$ 处是亏损的，数值特征分解可能产生病态的 $R$。为避免在此实现中出现崩溃，如果 $R$ 的条件数超过用户指定的阈值或分解失败，则在该面上回退到局部Lax–Friedrichs通量\n$$\n\\mathbf{F}_{\\mathrm{LF}} = \\frac{1}{2}\\left(A\\,\\mathbf{u}_i + A\\,\\mathbf{u}_{i+1}\\right) - \\frac{s}{2}\\left(\\mathbf{u}_{i+1}-\\mathbf{u}_i\\right),\n$$\n其中 $s$ 设置为用户指定的正则化参数 $\\delta0$。当分解接近亏损时，这种回退机制模拟了特征迎风格式性能的退化。\n\n2. 基于投影算子的谱分裂回退方法（记为变体P）：对于 $A=A(x_{i+\\frac{1}{2}})$ 且 $x=x_{i+\\frac{1}{2}}$，如果对于用户指定的小正则化参数 $\\delta0$ 有 $|x|\\ge \\delta$，则通过拉格朗日插值公式定义到特征值 $\\lambda=x$ 和 $\\lambda=-x$ 对应特征空间的谱投影算子\n$$\nP_+(x) = \\frac{A + x I}{2x},\\quad P_-(x) = \\frac{-A + x I}{2x},\n$$\n这在 $x\\neq 0$ 时有效，并得出 $P_+ + P_- = I$ 和 $A = x P_+ - x P_-$。然后设置\n$$\nA^+ = \\begin{cases} x\\,P_+(x),  x\\ge 0, \\\\ (-x)\\,P_-(x),  x0,\\end{cases}\n\\quad\nA^- = \\begin{cases} -x\\,P_-(x),  x\\ge 0, \\\\ x\\,P_+(x),  x0,\\end{cases}\n\\quad \\mathbf{F}_{i+\\frac{1}{2}} = A^+\\mathbf{u}_i + A^-\\mathbf{u}_{i+1}.\n$$\n如果 $|x|\\delta$，则回退到局部Lax–Friedrichs通量，其中 $s=\\delta$ 如上所述。这种构造方法避免了显式的特征向量计算，并且在远离特征值合并点时保持良态。\n\n对于两种变体，测量在时间 $T$ 时的以下量化输出：\n- 离散 $L^2$ 范数与其初始值的比值，定义为\n$$\nR = \\frac{\\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_i(T)\\|_2^2 \\,\\Delta x\\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_i(0)\\|_2^2 \\,\\Delta x\\right)^{1/2}},\n$$\n分别对变体U和变体P计算。这用于评估稳定性（远大于1的值表示放大）。\n- 两个最终解之间的离散 $L^2$ 差异，\n$$\nD = \\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_i^{\\mathrm{U}}(T)-\\mathbf{u}_i^{\\mathrm{P}}(T)\\|_2^2 \\,\\Delta x\\right)^{1/2},\n$$\n这用于评估近亏损性对两种迎风构造方法的准确性和一致性的影响。\n\n测试套件：\n使用以下参数集，它们探究了不同的方面：\n- 情况1（边缘情况，一个面位于 $x=0$）：$N=200$（偶数），$\\text{CFL}=0.45$, $T=0.1$, $\\delta=10^{-3}$。\n- 情况2（理想情况，没有面恰好在 $x=0$）：$N=201$（奇数），$\\text{CFL}=0.45$, $T=0.1$, $\\delta=10^{-3}$。\n- 情况3（更严重的近亏损性）：$N=200$（偶数），$\\text{CFL}=0.45$, $T=0.1$, $\\delta=10^{-6}$。\n\n你的程序必须实现上述方案，并为每个测试用例生成一个包含三个浮点数的列表 $[R_\\mathrm{U}, R_\\mathrm{P}, D]$，顺序如指定。最终输出必须是单行，包含所有测试用例的结果，聚合为一个用方括号括起来的逗号分隔列表，其中每个元素本身是对应情况的三个浮点数的列表，例如\n$$\n[\\,[R_{\\mathrm{U}}^{(1)},R_{\\mathrm{P}}^{(1)},D^{(1)}],\\,[R_{\\mathrm{U}}^{(2)},R_{\\mathrm{P}}^{(2)},D^{(2)}],\\,[R_{\\mathrm{U}}^{(3)},R_{\\mathrm{P}}^{(3)},D^{(3)}]\\,].\n$$\n所有输出都是无单位的实数。本问题中不出现角度。不得使用百分比；所有比率都应以小数形式返回。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的，但这取决于一个合理的假设来解决一个模糊之处。该问题是计算流体力学领域一个适定的数值实验，旨在比较两种为线性双曲系统构造迎风通量的方法，该系统的变系数矩阵在某一点处变为亏损。\n\n问题陈述中的核心模糊之处在于基于特征分解的迎风通量（变体U）的回退条件。陈述中指明，回退应在“R的条件数超过用户指定的阈值”时触发，但测试套件中并未提供这样的阈值。对于给定的系统矩阵 $A(x)$，其特征向量矩阵 $R(x)$ 的条件数在 $|x|$ 较小时约与 $1/|x|$ 成正比。基于投影算子的方法（变体P）给出了一个明确的回退条件 $|x|  \\delta$。为了在两种变体的主要通量公式之间进行有意义的直接比较，有逻辑上和必要性上的理由假设，相同的条件 $|x|  \\delta$ 也触发变体U的回退。这统一了评估两种方法核心差异以及两者都进行正则化的区域，从而满足了该问题的教学意图。在这个假设下，该问题是适定的，并且可以被求解。\n\n解决方案通过按规定实现一个一阶有限体积格式来展开。该方法论可分解为以下步骤：\n\n1.  **空间和时间离散化**：将定义域 $x \\in [-1, 1]$ 离散化为 $N$ 个宽度为 $\\Delta x = 2/N$ 的均匀单元。单元中心位于 $x_i = -1 + (i+1/2)\\Delta x$，单元面位于 $x_{i+1/2} = -1 + (i+1)\\Delta x$。时间步长 $\\Delta t$ 由CFL条件决定，$\\Delta t = \\text{CFL} \\cdot \\Delta x / \\rho_{\\max}$。所有面上的 $A(x)$ 的全局最大谱半径为 $\\rho_{\\max} = \\max |x_{i+1/2}| = 1$。因此，$\\Delta t = \\text{CFL} \\cdot \\Delta x$。为确保模拟恰好达到最终时间 $T$，步数计算为 $n_{\\text{steps}} = \\lceil T / \\Delta t \\rceil$，并使用一个新的有效时间步长 $\\Delta t_{\\text{eff}} = T / n_{\\text{steps}}$ 进行积分。\n\n2.  **初始条件**：通过在单元中心 $x_i$ 处评估给定的函数来离散化初始状态 $\\mathbf{u}(x, 0)$，从而得到初始的单元平均值 $\\mathbf{u}_i(0)$。用此状态初始化两个独立的解数组 $\\mathbf{u}^{\\mathrm{U}}$ 和 $\\mathbf{u}^{\\mathrm{P}}$。用于归一化的初始离散 $L^2$ 范数计算为 $\\|\\mathbf{u}(0)\\|_{L^2} = \\left(\\sum_{i=0}^{N-1} \\|\\mathbf{u}_i(0)\\|_2^2 \\Delta x\\right)^{1/2}$。\n\n3.  **通量实现**：在每个面 $x_{i+1/2}$ 和每个时间步，计算两个数值通量 $\\mathbf{F}^{\\mathrm{U}}_{i+1/2}$ 和 $\\mathbf{F}^{\\mathrm{P}}_{i+1/2}$。两种方法都依赖于在简并点 $x=0$ 附近回退到Lax-Friedrichs通量进行正则化。\n    -   **回退通量**：如果 $|x_{i+1/2}|  \\delta$，两种变体都使用局部Lax-Friedrichs（或Rusanov）通量：$\\mathbf{F}_{\\mathrm{LF}} = \\frac{1}{2}\\left(A(\\mathbf{u}_i + \\mathbf{u}_{i+1})\\right) - \\frac{s}{2}\\left(\\mathbf{u}_{i+1}-\\mathbf{u}_i\\right)$，稳定化参数为 $s=\\delta$。\n    -   **变体U（基于特征分解的迎风格式）**：对于 $|x_{i+1/2}| \\ge \\delta$，此方法使用标准的特征分解。系统矩阵 $A(x_{i+1/2})$ 使用标准库例程（`numpy.linalg.eig`）进行数值对角化，以找到其特征值 $\\Lambda$ 和右特征向量矩阵 $R$。矩阵被分裂为 $A^+ = R\\Lambda^+R^{-1}$ 和 $A^- = R\\Lambda^-R^{-1}$。这种实现是特意选择的，以反映理论的直接应用，众所周知，当 $R$ 是病态的（即对于小的 $|x_{i+1/2}|$）时，这种方法容易受到矩阵求逆 $R^{-1}$ 带来的数值误差的影响。那么通量为 $\\mathbf{F}^{\\mathrm{U}}_{i+1/2} = A^+\\mathbf{u}_i + A^-\\mathbf{u}_{i+1}$。\n    -   **变体P（基于投影算子的谱分裂）**：对于 $|x_{i+1/2}| \\ge \\delta$，此方法使用提供的谱投影算子公式。一个关键步骤是在实现之前对 $A^+$ 和 $A^-$ 的表达式进行代数简化。投影算子公式涉及除以 $2x$，这对于小的 $|x|$ 在数值上是不稳定的。然而，$A^+$ 和 $A^-$ 的最终表达式在 $x \\to 0$ 时表现得非常好。对于 $x \\ne 0$，它们是：\n        $$A^+(x) = \\begin{cases} \\begin{pmatrix} x  1/2 \\\\ 0  0 \\end{pmatrix}  \\text{if } x  0 \\\\ \\begin{pmatrix} 0  1/2 \\\\ 0  -x \\end{pmatrix}  \\text{if } x  0 \\end{cases}, \\quad A^-(x) = \\begin{cases} \\begin{pmatrix} 0  1/2 \\\\ 0  -x \\end{pmatrix}  \\text{if } x  0 \\\\ \\begin{pmatrix} x  1/2 \\\\ 0  0 \\end{pmatrix}  \\text{if } x  0 \\end{cases}$$\n        这种实现是数值稳健的，并避免了黑箱特征分解和投影算子公式的朴素实现的潜在不稳定性。通量为 $\\mathbf{F}^{\\mathrm{P}}_{i+1/2} = A^+\\mathbf{u}_i + A^-\\mathbf{u}_{i+1}$。\n\n4.  **时间积分**：向前欧拉法根据守恒公式将单元平均值从时间 $t_n$ 更新到 $t_{n+1}=t_n+\\Delta t_{\\text{eff}}$：\n    $$ \\mathbf{u}_i^{n+1} = \\mathbf{u}_i^n - \\frac{\\Delta t_{\\text{eff}}}{\\Delta x}\\left(\\mathbf{F}_{i+\\frac{1}{2}}^n - \\mathbf{F}_{i-\\frac{1}{2}}^n\\right) $$\n    这使用各自的通量分别应用于 $\\mathbf{u}^{\\mathrm{U}}$ 和 $\\mathbf{u}^{\\mathrm{P}}$。周期性边界条件通过在定义域边界处对状态和通量的索引进行环绕处理。\n\n5.  **最终指标**：在积分到时间 $T$ 后，最终解 $\\mathbf{u}^{\\mathrm{U}}(T)$ 和 $\\mathbf{u}^{\\mathrm{P}}(T)$ 用于计算所需的输出：范数比率 $R_\\mathrm{U}$ 和 $R_\\mathrm{P}$，以及 $L^2$ 差异 $D$。\n\n两种通量实现（变体U数值敏感，变体P稳健）在先验稳定性上的这种明显区别，旨在产生一个非零差异 $D$，该差异量化了基于特征向量的方法在亏损点附近的病态性所引入的数值误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_A(x):\n    \"\"\"Returns the matrix A(x).\"\"\"\n    return np.array([[x, 1.0], [0.0, -x]])\n\ndef flux_LF(u_left, u_right, x_face, s):\n    \"\"\"Computes the local Lax-Friedrichs (Rusanov) flux.\"\"\"\n    A = get_A(x_face)\n    return 0.5 * (A @ u_left + A @ u_right) - 0.5 * s * (u_right - u_left)\n\ndef flux_U(u_left, u_right, x_face):\n    \"\"\"Computes the eigen-based upwind flux using numerical decomposition.\"\"\"\n    A = get_A(x_face)\n    lam, R = np.linalg.eig(A)\n    \n    # Sort eigenvalues and eigenvectors to be consistent: lam[0]~=x, lam[1]~=-x\n    # This is important for correctly defining Lambda^+ and Lambda^-.\n    if np.abs(lam[0] - (-x_face))  np.abs(lam[0] - x_face):\n        lam = lam[::-1]\n        R = R[:, ::-1]\n\n    R_inv = np.linalg.inv(R)\n    \n    Lambda_p = np.diag([max(l, 0) for l in lam])\n    Lambda_m = np.diag([min(l, 0) for l in lam])\n    \n    A_p = R @ Lambda_p @ R_inv\n    A_m = R @ Lambda_m @ R_inv\n    \n    return A_p @ u_left + A_m @ u_right\n\ndef flux_P(u_left, u_right, x_face):\n    \"\"\"Computes the projector-based upwind flux using a stable analytic form.\"\"\"\n    x = x_face\n    if x > 0:\n        A_p = np.array([[x, 0.5], [0.0, 0.0]])\n        A_m = np.array([[0.0, 0.5], [0.0, -x]])\n    else: # x  0. The case x=0 is handled by the delta-fallback.\n        A_p = np.array([[0.0, 0.5], [0.0, -x]])\n        A_m = np.array([[x, 0.5], [0.0, 0.0]])\n        \n    return A_p @ u_left + A_m @ u_right\n\ndef run_simulation(N, CFL, T, delta):\n    \"\"\"\n    Runs one simulation case for the given parameters.\n    \"\"\"\n    # Grid setup\n    dx = 2.0 / N\n    x_centers = -1.0 + (np.arange(N) + 0.5) * dx\n    x_faces = -1.0 + (np.arange(N + 1)) * dx\n\n    # Time step calculation\n    max_rho = 1.0 # Max spectral radius is max|x| over faces, which is 1.\n    dt_cfl = CFL * dx / max_rho\n    # Ensure final time T is reached exactly\n    num_steps = int(np.ceil(T / dt_cfl))\n    dt = T / num_steps\n    \n    # Initial conditions\n    u0 = np.zeros((N, 2))\n    u0[:, 0] = np.sin(2 * np.pi * x_centers)\n    u0[:, 1] = np.cos(2 * np.pi * x_centers)\n    \n    u_U = u0.copy()\n    u_P = u0.copy()\n\n    # Initial discrete L2 norm\n    norm_u0_sq = np.sum(np.linalg.norm(u0, axis=1)**2) * dx\n    norm_u0 = np.sqrt(norm_u0_sq)\n\n    # Time integration loop\n    for _ in range(num_steps):\n        # --- Variant U Simulation Step ---\n        fluxes_U = np.zeros_like(u_U)\n        for i in range(N):\n            x_face = x_faces[i+1] # Flux at right face of cell i\n            u_left = u_U[i]\n            u_right = u_U[(i + 1) % N]\n            \n            if abs(x_face)  delta:\n                fluxes_U[i] = flux_LF(u_left, u_right, x_face, s=delta)\n            else:\n                fluxes_U[i] = flux_U(u_left, u_right, x_face)\n\n        # --- Variant P Simulation Step ---\n        fluxes_P = np.zeros_like(u_P)\n        for i in range(N):\n            x_face = x_faces[i+1]\n            u_left = u_P[i]\n            u_right = u_P[(i + 1) % N]\n            \n            if abs(x_face)  delta:\n                fluxes_P[i] = flux_LF(u_left, u_right, x_face, s=delta)\n            else:\n                fluxes_P[i] = flux_P(u_left, u_right, x_face)\n\n        # Vectorized update of solutions\n        u_U -= (dt / dx) * (fluxes_U - np.roll(fluxes_U, 1, axis=0))\n        u_P -= (dt / dx) * (fluxes_P - np.roll(fluxes_P, 1, axis=0))\n\n    # --- Final Metrics Calculation ---\n    # Norm Ratio R\n    norm_uT_U_sq = np.sum(np.linalg.norm(u_U, axis=1)**2) * dx\n    R_U = np.sqrt(norm_uT_U_sq) / norm_u0\n    \n    norm_uT_P_sq = np.sum(np.linalg.norm(u_P, axis=1)**2) * dx\n    R_P = np.sqrt(norm_uT_P_sq) / norm_u0\n\n    # L2 Difference D\n    diff_sq = np.sum(np.linalg.norm(u_U - u_P, axis=1)**2) * dx\n    D = np.sqrt(diff_sq)\n    \n    return [R_U, R_P, D]\n\ndef solve():\n    \"\"\"Main solver function to run test cases and print results.\"\"\"\n    test_cases = [\n        # (N, CFL, T, delta)\n        (200, 0.45, 0.1, 1e-3),\n        (201, 0.45, 0.1, 1e-3),\n        (200, 0.45, 0.1, 1e-6),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        all_results.append(result)\n\n    # Format output as a string representation of a list of lists.\n    # The default np.array2string or list str() might add unwanted whitespace.\n    outer_list_str = []\n    for res in all_results:\n        inner_list_str = f\"[{res[0]},{res[1]},{res[2]}]\"\n        outer_list_str.append(inner_list_str)\n    \n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```", "id": "3369632"}]}