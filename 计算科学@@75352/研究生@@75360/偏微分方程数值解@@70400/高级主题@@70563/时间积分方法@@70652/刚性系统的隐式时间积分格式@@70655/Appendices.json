{"hands_on_practices": [{"introduction": "对于刚性系统，标准的龙格-库塔（Runge-Kutta）方法可能会遭受阶数退化（order reduction）的困扰，导致实际精度低于理论预期。为了设计能避免此问题的积分器，我们不仅需要满足经典的阶条件（$B(p)$），还必须考虑保证中间计算步骤精度的级阶（stage order）条件（$C(q)$）。这项练习 [@problem_id:3406965] 将指导您从第一性原理出发推导这些关键条件，并构建一个满足特定阶数和结构要求的对角隐式龙格-库塔（DIRK）方法，从而让您对如何为刚性线性问题设计高精度积分器获得根本性的理解。", "problem": "考虑通过方法线得到的线性抛物型偏微分方程的半离散形式，它产生一个形如 $y'(t) = J y(t) + g(t)$ 的刚性常微分方程组，其中 $y(t) \\in \\mathbb{R}^{m}$，$J \\in \\mathbb{R}^{m \\times m}$ 是负定且与 $t$ 无关的矩阵，而 $g(t)$ 是充分光滑的。令 $h > 0$ 表示时间步长，且 $t_{n+1} = t_n + h$。一个 $s$ 阶对角隐式龙格-库塔 (DIRK) 方法由其内部阶段 $Y_i$ 和步长更新 $y_{n+1}$ 定义：\n$$\nY_i = y_n + h \\sum_{j=1}^{i} a_{ij} \\left( J Y_j + g(t_n + c_j h) \\right), \\quad i = 1, \\dots, s,\n$$\n$$\ny_{n+1} = y_n + h \\sum_{j=1}^{s} b_j \\left( J Y_j + g(t_n + c_j h) \\right),\n$$\n其中 $A = (a_{ij})$ 是一个下三角矩阵，$b = (b_1, \\dots, b_s)^{\\top}$ 是权重，$c = (c_1, \\dots, c_s)^{\\top}$ 是节点。\n\n从精确解的常数变易公式出发，并围绕 $t_n$ 对 $h$ 进行泰勒展开，推导刚性阶条件，以确保该方法在给定的线性刚性问题上达到经典阶 $p=2$ 且不发生阶数退化。特别地，推导保证内部阶段具有阶段阶 $q=2$ 的条件。基于这些条件，提出一个满足 $p=2$ 和 $q=2$、刚性精确（即 $y_{n+1}$ 等于最后一个阶段）且 $c_2 = 1$ 的 $2$ 阶 DIRK 方法。按顺序将其系数表示为 $a_{11}$, $a_{21}$, $a_{22}$, $b_1$, $b_2$, $c_1$, $c_2$。你的最终答案必须是按给定顺序收集在单个行矩阵中的这些系数。无需四舍五入，也无需物理单位。", "solution": "该问题要求推导对角隐式龙格-库塔 (DIRK) 方法在线性刚性系统 $y'(t) = J y(t) + g(t)$ 上达到经典阶 $p=2$ 和阶段阶 $q=2$ 的条件，并随后构造一个具有这些性质的特定 $2$ 阶方法。\n\n首先，我们建立阶段阶 $q$ 的条件。一个 $s$ 阶 Runge-Kutta 方法在中间时间点提供对精确解 $y(t_n + c_i h)$ 的近似 $Y_i$。如果阶段的局部误差 $Y_i - y(t_n+c_i h)$ 为 $O(h^{q+1})$，则阶段阶为 $q$，这里假设之前的阶段是精确的，即对 $j  i$ 有 $Y_j = y(t_n+c_j h)$。\n\n精确解 $y(t)$ 满足以下积分方程：\n$$\ny(t_n + c_i h) = y(t_n) + \\int_{t_n}^{t_n + c_i h} y'(\\tau) d\\tau = y_n + h \\int_{0}^{c_i} y'(t_n + \\theta h) d\\theta\n$$\n假设 $y(t_n)=y_n$。数值阶段值 $Y_i$ 由下式给出：\n$$\nY_i = y_n + h \\sum_{j=1}^{i} a_{ij} y'(t_n + c_j h, Y_j)\n$$\n对于给定问题，$y'(t,y) = Jy+g(t)$。为了推导阶条件，我们分析局部误差，假设函数 $y'$ 的参数满足 $Y_j = y(t_n + c_j h)$。精确解积分与其数值近似之间的差是截断误差的来源。\n$$\nY_i - y(t_n+c_i h) \\approx h \\sum_{j=1}^{i} a_{ij} y'(t_n+c_j h) - h \\int_{0}^{c_i} y'(t_n + \\theta h) d\\theta\n$$\n其中 $y'(t_n+\\theta h)$ 代表 $y'(t_n+\\theta h, y(t_n+\\theta h))$。\n为使此误差为 $O(h^{q+1})$，求积公式\n$$\n\\int_{0}^{c_i} \\phi(\\theta) d\\theta \\approx \\sum_{j=1}^{i} a_{ij} \\phi(c_j)\n$$\n必须对最高次数为 $q-1$ 的多项式 $\\phi(\\theta)$ 精确成立。这必须对 $y'$ 的任何具体形式都成立，即对依赖于 $J$ 的部分和依赖于 $g(t)$ 的部分独立成立。令 $\\phi(\\theta) = \\theta^{k-1}$（其中 $k=1, \\dots, q$）可得到阶段阶条件，通常表示为 $C(q)$：\n$$\n\\sum_{j=1}^{s} a_{ij} c_j^{k-1} = \\frac{c_i^k}{k}, \\quad \\text{for } i=1,\\dots,s \\text{ and } k=1,\\dots,q.\n$$\n注意，对于 DIRK 方法，求和实际上是 $\\sum_{j=1}^{i}$。对于所要求的阶段阶 $q=2$，这些条件是：\n$C(1): \\sum_{j=1}^{s} a_{ij} = c_i$，对于 $i=1,\\dots,s$。\n$C(2): \\sum_{j=1}^{s} a_{ij} c_j = \\frac{c_i^2}{2}$，对于 $i=1,\\dots,s$。\n\n接下来，我们建立经典阶 $p=2$ 的条件。这与步末误差 $y_{n+1} - y(t_{n+1})$ 有关。推导过程类似，基于整个步长区间 $[t_n, t_{n+1}]$ 的求积法则：\n$$\ny(t_{n+1}) = y_n + h \\int_0^1 y'(t_n+\\theta h)d\\theta\n$$\n$$\ny_{n+1} = y_n + h \\sum_{j=1}^s b_j y'(t_n+c_j h)\n$$\n为使方法具有经典阶 $p$，求积法则 $\\int_0^1 \\phi(\\theta)d\\theta \\approx \\sum_{j=1}^s b_j \\phi(c_j)$ 必须对最高次数为 $p-1$ 的多项式精确成立。这些是条件 $B(p)$：\n$$\n\\sum_{j=1}^{s} b_j c_j^{k-1} = \\frac{1}{k}, \\quad \\text{for } k=1,\\dots,p.\n$$\n对于所要求的经典阶 $p=2$，这些条件是：\n$B(1): \\sum_{j=1}^{s} b_j = 1$。\n$B(2): \\sum_{j=1}^{s} b_j c_j = \\frac{1}{2}$。\n\n问题指出不应发生阶数退化。对于线性问题 $y'=Jy+g(t)$，如果阶段阶 $q$ 足够高（特别是 $q \\ge p-1$），则可以避免阶数退化。这里，我们被要求满足 $p=2$ 和 $q=2$。由于 $2 \\ge 2-1$，这些条件足以防止阶数退化。\n\n现在，我们构造特定的 $s=2$ 阶 DIRK 方法。其 Butcher 表具有以下形式：\n$$\n\\begin{array}{c|cc}\nc_1  a_{11}  0 \\\\\nc_2  a_{21}  a_{22} \\\\\n\\hline\n b_1  b_2\n\\end{array}\n$$\n该方法必须满足以下约束条件：\n1.  $s=2$\n2.  阶段阶 $q=2$：对 $i=1,2$ 成立的 $C(1)$ 和 $C(2)$。\n3.  经典阶 $p=2$：$B(1)$ 和 $B(2)$。\n4.  刚性精确：$y_{n+1} = Y_s$。对于 $s=2$，这意味着 $y_{n+1} = Y_2$。这表明最终更新的系数必须与最后一个阶段的系数相同。因此，对 $j=1, ..., s$ 有 $b_j = a_{sj}$。对于 $s=2$，我们有 $b_1 = a_{21}$ 和 $b_2 = a_{22}$。\n5.  $c_2 = 1$。\n\n让我们写下完整的方程组：\n由阶段阶 $q=2$ 可得：\n对于 $i=1$：\n(1) $a_{11} = c_1$\n(2) $a_{11} c_1 = \\frac{c_1^2}{2}$\n对于 $i=2$：\n(3) $a_{21} + a_{22} = c_2$\n(4) $a_{21} c_1 + a_{22} c_2 = \\frac{c_2^2}{2}$\n\n由经典阶 $p=2$ 可得：\n(5) $b_1 + b_2 = 1$\n(6) $b_1 c_1 + b_2 c_2 = \\frac{1}{2}$\n\n由刚性精确性可得：\n(7) $b_1 = a_{21}$\n(8) $b_2 = a_{22}$\n\n由给定条件可得：\n(9) $c_2 = 1$\n\n我们求解这个方程组。\n将 (1) 代入 (2)：$c_1 \\cdot c_1 = \\frac{c_1^2}{2}$，化简为 $c_1^2 = \\frac{c_1^2}{2}$。这意味着 $\\frac{c_1^2}{2} = 0$，所以 $c_1=0$。\n由 (1) 可得 $a_{11} = c_1 = 0$。\n\n现在我们将已知值 $c_1=0$ 和 $c_2=1$ 代入剩余的方程。\n代入 (6)：$b_1(0) + b_2(1) = \\frac{1}{2}$，得到 $b_2 = \\frac{1}{2}$。\n将 $b_2 = \\frac{1}{2}$ 代入 (5)：$b_1 + \\frac{1}{2} = 1$，得到 $b_1 = \\frac{1}{2}$。\n\n现在，使用刚性精确条件 (7) 和 (8)：\n$a_{21} = b_1 = \\frac{1}{2}$。\n$a_{22} = b_2 = \\frac{1}{2}$。\n\n到目前为止找到的系数是：\n$c_1=0, c_2=1$\n$a_{11}=0, a_{21}=1/2, a_{22}=1/2$\n$b_1=1/2, b_2=1/2$。\n\n我们必须验证这些值是否满足剩余未使用的方程 (3) 和 (4)。\n检验 (3)：$a_{21} + a_{22} = \\frac{1}{2} + \\frac{1}{2} = 1$。右边是 $c_2=1$。条件 (3) 满足。\n检验 (4)：$a_{21} c_1 + a_{22} c_2 = (\\frac{1}{2})(0) + (\\frac{1}{2})(1) = \\frac{1}{2}$。右边是 $\\frac{c_2^2}{2} = \\frac{1^2}{2} = \\frac{1}{2}$。条件 (4) 满足。\n\n所有条件都已满足。该方法的系数是唯一确定的。\n最终的系数集是：\n$a_{11} = 0$\n$a_{21} = \\frac{1}{2}$\n$a_{22} = \\frac{1}{2}$\n$b_1 = \\frac{1}{2}$\n$b_2 = \\frac{1}{2}$\n$c_1 = 0$\n$c_2 = 1$\n\n问题要求将这些系数按 $a_{11}, a_{21}, a_{22}, b_1, b_2, c_1, c_2$ 的顺序收集在一个单行矩阵中。\n得到的行矩阵是 $(0, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, 0, 1)$。该方法是隐式梯形法则的一种表示。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  \\frac{1}{2}  \\frac{1}{2}  \\frac{1}{2}  \\frac{1}{2}  0  1\n\\end{pmatrix}\n}\n$$", "id": "3406965"}, {"introduction": "在满足阶条件之后，确保数值稳定性是构建一个可靠的刚性积分器的下一个关键步骤，其中A-稳定性和L-稳定性是保证刚性分量能够被有效衰减的理想属性。单对角隐式龙格-库塔（SDIRK）方法因其计算上的高效性而备受青睐。在此实践中 [@problem_id:3407002]，您将通过推导其稳定性函数，深入分析一个SDIRK方法族，并确定其参数满足A-稳定性和L-稳定性的条件，从而将方法的设计选择与其实际的稳定性表现直接联系起来。", "problem": "考虑一个由抛物型偏微分方程空间离散化得到的刚性半离散演化系统，写为常微分方程 (ODE) $y'(t) = F(y(t))$，其中状态向量 $y(t) \\in \\mathbb{R}^{m}$ 且 $F : \\mathbb{R}^{m} \\to \\mathbb{R}^{m}$。您将构建一个两级单对角隐式龙格-库塔 (SDIRK) 方法，其特点是具有一个公共的对角系数 $\\gamma$（两级相同）并且满足刚性精确性质，即数值解的更新使用的最后一级权重与龙格-库塔系数矩阵的最后一行相同。设时间步长为 $h  0$，记级值为 $Y_{1}$ 和 $Y_{2}$，并定义 $k_{1} = F(Y_{1})$, $k_{2} = F(Y_{2})$。\n\n任务：\n1. 从龙格-库塔方法的核心定义、SDIRK 结构和刚性精确性质出发，推导出关于 $\\gamma$、$h$ 和前一步解 $y_{n}$ 的显式级方程 $Y_{1}$、$Y_{2}$ 以及更新公式 $y_{n+1}$，并确保方法的节点满足 $c_{1} = \\gamma$ 和 $c_{2} = 1$。\n2. 使用线性检验方程 $y'(t) = \\lambda y(t)$（其中 $\\lambda$ 为满足 $\\operatorname{Re}(\\lambda) \\le 0$ 的复数），推导所构建的两级 SDIRK 方法的稳定性函数 $R(z)$，其中 $z = h \\lambda$。不要假设 $R(z)$ 的任何预先存在的形式；而是要直接从级方程和更新公式推导它。\n3. 从第一性原理出发，确定使该方法A-稳定的关于 $\\gamma$ 的条件，即确保整个复平面闭左半平面都位于该方法绝对稳定域内的条件。您的答案必须以关于 $\\gamma$ 的解析条件的形式陈述。\n4. 评估稳定性函数在 $\\operatorname{Re}(z) \\to -\\infty$ 的射线上当 $|z|$ 很大时的渐近行为，并确定该方法是否是 L-稳定的。明确陈述 L-稳定性成立时 $\\gamma$ 需满足的条件。\n5. 应用两级龙格-库塔方法的经典二阶精度条件，确定唯一的 $\\gamma \\in (0,1)$，使其同时达到二阶精度和 L-稳定性。请将您的最终答案表示为 $\\gamma$ 的精确闭式解析表达式。最终答案中无需进行数值舍入。", "solution": "该问题被验证为具有科学依据、适定且客观。它是常微分方程数值分析领域的标准问题，提供了所有必要信息且无矛盾。\n\n对于常微分方程 $y'(t) = F(y(t))$，一个通用的两级龙格-库塔方法由以下方程定义：\n$$ Y_1 = y_n + h (a_{11} F(Y_1) + a_{12} F(Y_2)) $$\n$$ Y_2 = y_n + h (a_{21} F(Y_1) + a_{22} F(Y_2)) $$\n$$ y_{n+1} = y_n + h (b_1 F(Y_1) + b_2 F(Y_2)) $$\n其系数由布卓 (Butcher) 阵列表定义：\n$$\n\\begin{array}{c|cc}\nc_1  a_{11}  a_{12} \\\\\nc_2  a_{21}  a_{22} \\\\\n\\hline\n b_1  b_2\n\\end{array}\n$$\n该问题对这种通用形式规定了几个约束条件。\n首先，它是一个具有公共对角系数 $\\gamma$ 的单对角隐式龙格-库塔 (SDIRK) 方法。这意味着系数矩阵 $A = (a_{ij})$ 是下三角矩阵（当 $ji$ 时，$a_{ij}=0$），并且对角元素相等（$a_{11}=a_{22}=\\gamma$）。阵列表变为：\n$$\n\\begin{array}{c|cc}\nc_1  \\gamma  0 \\\\\nc_2  a_{21}  \\gamma \\\\\n\\hline\n b_1  b_2\n\\end{array}\n$$\n其次，节点给定为 $c_1 = \\gamma$ 和 $c_2 = 1$。节点必须满足相容性条件 $c_i = \\sum_{j=1}^2 a_{ij}$。对于 $i=1$，我们有 $c_1 = a_{11} + a_{12}$，即 $\\gamma = \\gamma + 0$，这是一个相容的关系。对于 $i=2$，我们有 $c_2 = a_{21} + a_{22}$，这得到 $1 = a_{21} + \\gamma$，所以 $a_{21} = 1 - \\gamma$。\n第三，该方法是刚性精确的。这意味着解的更新使用最后一级的值，即 $y_{n+1} = Y_2$。就阵列表系数而言，此性质意味着权重 $b_j$ 等于系数矩阵 $A$ 的最后一行。因此，$b_1 = a_{21} = 1-\\gamma$ 且 $b_2 = a_{22} = \\gamma$。\n综合这些约束条件，布卓阵列表由参数 $\\gamma$ 完全确定：\n$$\n\\begin{array}{c|cc}\n\\gamma  \\gamma  0 \\\\\n1  1-\\gamma  \\gamma \\\\\n\\hline\n 1-\\gamma  \\gamma\n\\end{array}\n$$\n\n**1. 级方程和更新公式的推导**\n使用已确定的布卓阵列表，我们可以写出级方程。令 $k_1 = F(Y_1)$ 和 $k_2 = F(Y_2)$。\n第一级方程为：\n$$ Y_1 = y_n + h (a_{11} k_1 + a_{12} k_2) = y_n + h (\\gamma k_1 + 0 \\cdot k_2) $$\n$$ Y_1 = y_n + h \\gamma F(Y_1) $$\n第二级方程为：\n$$ Y_2 = y_n + h (a_{21} k_1 + a_{22} k_2) = y_n + h ((1-\\gamma) k_1 + \\gamma k_2) $$\n$$ Y_2 = y_n + h((1-\\gamma)F(Y_1) + \\gamma F(Y_2)) $$\n由于刚性精确性质，更新公式就是最后一级的值：\n$$ y_{n+1} = Y_2 $$\n这些方程定义了该方法。它们是隐式的，因为 $Y_1$ 和 $Y_2$ 出现在它们各自定义方程的两边。\n\n**2. 稳定性函数 $R(z)$ 的推导**\n为求稳定性函数，我们将该方法应用于线性检验方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $\\operatorname{Re}(\\lambda) \\le 0$。对于此方程，$F(y) = \\lambda y$。令 $z = h \\lambda$。\n级方程变为：\n$$ Y_1 = y_n + h \\gamma (\\lambda Y_1) = y_n + z \\gamma Y_1 $$\n$$ Y_2 = y_n + h ((1-\\gamma) \\lambda Y_1 + \\gamma \\lambda Y_2) = y_n + z(1-\\gamma) Y_1 + z \\gamma Y_2 $$\n首先，我们求解第一级方程得到 $Y_1$：\n$$ Y_1 (1 - z \\gamma) = y_n \\implies Y_1 = \\frac{1}{1 - z \\gamma} y_n $$\n接下来，我们求解第二级方程得到 $Y_2$：\n$$ Y_2 (1 - z \\gamma) = y_n + z(1-\\gamma) Y_1 $$\n代入 $Y_1$ 的表达式：\n$$ Y_2 (1 - z \\gamma) = y_n + z(1-\\gamma) \\left( \\frac{1}{1 - z \\gamma} \\right) y_n $$\n$$ Y_2 = \\frac{1}{1 - z \\gamma} y_n + \\frac{z(1-\\gamma)}{(1 - z \\gamma)^2} y_n $$\n$$ Y_2 = \\left( \\frac{1 - z \\gamma + z(1-\\gamma)}{(1 - z \\gamma)^2} \\right) y_n $$\n$$ Y_2 = \\left( \\frac{1 - z \\gamma + z - z\\gamma}{(1 - z \\gamma)^2} \\right) y_n $$\n$$ Y_2 = \\left( \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2} \\right) y_n $$\n数值解更新为 $y_{n+1} = Y_2$。稳定性函数由 $y_{n+1} = R(z) y_n$ 定义。因此：\n$$ R(z) = \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2} $$\n\n**3. A-稳定性的条件**\n如果一个数值方法的绝对稳定域包含整个左半平面 $\\mathbb{C}^- = \\{ z \\in \\mathbb{C} \\mid \\operatorname{Re}(z) \\le 0 \\}$，则该方法是 A-稳定的。对于有理稳定性函数 $R(z)$，这需要满足两个条件：\n(i) $R(z)$ 必须在开左半平面 $\\operatorname{Re}(z)  0$ 内解析。$R(z)$ 的极点由 $(1-\\gamma z)^2 = 0$ 给出，即 $z = 1/\\gamma$。为了在开左半平面内解析，极点不能位于其中，即 $\\operatorname{Re}(1/\\gamma) \\ge 0$。由于 $\\gamma$ 是实数，这意味着 $1/\\gamma \\ge 0$，所以我们必须有 $\\gamma  0$。\n(ii) 在区域的边界，即虚轴上，我们必须有 $|R(i\\omega)| \\le 1$ 对所有 $\\omega \\in \\mathbb{R}$ 成立。\n我们来计算 $|R(i\\omega)|^2$：\n$$ |R(i\\omega)|^2 = \\left| \\frac{1 + (1 - 2\\gamma)i\\omega}{(1 - i\\gamma\\omega)^2} \\right|^2 = \\frac{|1 + i(1-2\\gamma)\\omega|^2}{|(1 - i\\gamma\\omega)^2|^2} = \\frac{1^2 + ((1-2\\gamma)\\omega)^2}{(|1-i\\gamma\\omega|^2)^2} $$\n$$ |R(i\\omega)|^2 = \\frac{1 + (1-2\\gamma)^2\\omega^2}{(1+\\gamma^2\\omega^2)^2} $$\n条件 $|R(i\\omega)|^2 \\le 1$ 变为：\n$$ 1 + (1-2\\gamma)^2\\omega^2 \\le (1+\\gamma^2\\omega^2)^2 $$\n$$ 1 + (1 - 4\\gamma + 4\\gamma^2)\\omega^2 \\le 1 + 2\\gamma^2\\omega^2 + \\gamma^4\\omega^4 $$\n两边减去 $1$ 并除以 $\\omega^2$（对于 $\\omega \\neq 0$）：\n$$ 1 - 4\\gamma + 4\\gamma^2 \\le 2\\gamma^2 + \\gamma^4\\omega^2 $$\n$$ 1 - 4\\gamma + 2\\gamma^2 \\le \\gamma^4\\omega^2 $$\n这个不等式必须对所有 $\\omega \\in \\mathbb{R}$ 成立。右边（假设 $\\gamma$ 是实数）是非负的，其最小值为 $0$，在 $\\omega=0$ 时取到。因此，该不等式必须对这个最小值成立，从而得到条件：\n$$ 2\\gamma^2 - 4\\gamma + 1 \\le 0 $$\n这是 $\\gamma$ 满足 A-稳定性的条件，需结合 $\\gamma  0$。二次方程 $2\\gamma^2 - 4\\gamma + 1 = 0$ 的根是 $\\gamma = \\frac{4 \\pm \\sqrt{16-8}}{4} = 1 \\pm \\frac{\\sqrt{2}}{2}$。由于该二次函数图像开口向上，不等式在两根之间成立。区间下限 $1 - \\frac{\\sqrt{2}}{2} \\approx 0.293  0$，所以条件 $\\gamma0$ 得到满足。该条件是 $\\gamma \\in [1 - \\frac{\\sqrt{2}}{2}, 1 + \\frac{\\sqrt{2}}{2}]$。\n\n**4. L-稳定性分析**\n如果一个方法是 A-稳定的，并且其稳定性函数满足 $\\lim_{|z|\\to\\infty, \\operatorname{Re}(z) \\le 0} |R(z)| = 0$，则该方法是 L-稳定的。对于像 $R(z)$ 这样的有理函数，这等价于要求方法是 A-稳定的并且 $\\lim_{z\\to\\infty} R(z) = 0$。后一个条件成立的条件是分子多项式的次数严格小于分母多项式的次数。\n我们的稳定性函数是：\n$$ R(z) = \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2} = \\frac{(1-2\\gamma)z + 1}{\\gamma^2 z^2 - 2\\gamma z + 1} $$\n假设 $\\gamma \\neq 0$，分母的次数为 $2$。\n如果 $1-2\\gamma \\neq 0$ (即 $\\gamma \\neq 1/2$)，则分子的次数为 $1$；如果 $1-2\\gamma = 0$ (即 $\\gamma=1/2$)，则分子的次数为 $0$。在任何一种情况下，分子的次数都严格小于分母的次数。\n因此，对于任何 $\\gamma \\neq 0$，我们有 $\\lim_{z\\to\\infty} R(z) = 0$。A-稳定性条件要求 $\\gamma0$。因此，任何这种形式的 A-稳定方法都是自动 L-稳定的。L-稳定性的条件与 A-稳定性的条件相同：\n$$ 2\\gamma^2 - 4\\gamma + 1 \\le 0 $$\n\n**5. 二阶精度与 L-稳定性**\n龙格-库塔方法达到二阶精度的阶条件是：\n1阶：$\\sum_{i=1}^2 b_i = 1$。我们的方法有 $b_1 = 1-\\gamma$ 和 $b_2 = \\gamma$，所以 $\\sum b_i = (1-\\gamma) + \\gamma = 1$。对于任何 $\\gamma$，该方法至少是一阶的。\n2阶：$\\sum_{i=1}^2 b_i c_i = 1/2$。我们的方法有 $c_1=\\gamma$ 和 $c_2=1$。该条件是：\n$$ b_1 c_1 + b_2 c_2 = (1-\\gamma)\\gamma + \\gamma(1) = \\gamma - \\gamma^2 + \\gamma = 2\\gamma - \\gamma^2 $$\n令其等于 $1/2$：\n$$ 2\\gamma - \\gamma^2 = \\frac{1}{2} $$\n乘以 $2$ 并重新整理得到二次方程：\n$$ 4\\gamma - 2\\gamma^2 = 1 \\implies 2\\gamma^2 - 4\\gamma + 1 = 0 $$\n这恰好是定义 A-稳定性和 L-稳定性区域边界的方程。其根为 $\\gamma = 1 \\pm \\frac{\\sqrt{2}}{2}$。\n问题要求找到唯一的 $\\gamma \\in (0,1)$。\n两个根是 $\\gamma_1 = 1 - \\frac{\\sqrt{2}}{2}$ 和 $\\gamma_2 = 1 + \\frac{\\sqrt{2}}{2}$。\n数值上，$\\sqrt{2} \\approx 1.414$，所以 $\\gamma_1 \\approx 1 - 0.707 = 0.293$ 并且 $\\gamma_2 \\approx 1 + 0.707 = 1.707$。\n在区间 $(0,1)$ 内的唯一根是 $\\gamma_1 = 1 - \\frac{\\sqrt{2}}{2}$。\n对于这个 $\\gamma$ 值，L-稳定性条件 $2\\gamma^2 - 4\\gamma + 1 \\le 0$ 得到满足，因为 $2\\gamma^2 - 4\\gamma + 1 = 0$。\n因此，同时达到二阶精度和 L-稳定性的唯一 $\\gamma \\in (0,1)$ 值是 $\\gamma = 1 - \\frac{\\sqrt{2}}{2}$。", "answer": "$$\\boxed{1 - \\frac{\\sqrt{2}}{2}}$$", "id": "3407002"}, {"introduction": "数值方法的理论属性，如阶数和稳定性，必须通过实践来检验，而在求解刚性偏微分方程（PDEs）时，阶数退化是一个常见的陷阱。梯形法则（或称Crank-Nicolson方法）虽然是A-稳定且二阶的，但在处理带有随时间变化边界条件的抛物型PDE时，由于其级阶（stage order）有限，其实际精度常常会退化为一阶。这项计算练习 [@problem_id:3406952] 将让您亲手实现该方法并观察这一现象，通过对比其在有无非齐次边界条件问题上的性能，您将巩固对刚性阶理论实践意义的理解。", "problem": "考虑一维热方程，它是一个线性抛物型偏微分方程 (PDE)，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t), \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\n服从狄利克雷边界条件\n$$\nu(0,t) = g_0(t), \\quad u(1,t) = g_1(t),\n$$\n以及一个初始条件\n$$\nu(x,0) = u_0(x),\n$$\n其中 $u$ 是温度，$\\alpha$ 是热扩散系数，$f$ 是一个源项，$g_0$ 和 $g_1$ 是给定的边界数据。使用直线法 (MOL)，在具有 $M$ 个内部点的均匀网格上，用二阶中心差分来离散化空间算子，并应用梯形法则（也称为 Crank–Nicolson 方法）进行时间积分。通过将其贡献纳入半离散的右端项，来一致地处理非齐次狄利克雷边界条件。在最大范数（无穷范数）下量化时间上的经验收敛阶，并分析带有非齐次边界条件的刚性系统的阶数降低现象。\n\n将推导和实现建立在以下基本且广为接受的事实之上：\n- 在间距为 $h$ 的均匀网格上，二阶导数的二阶中心差分近似由三点格式给出。\n- 梯形法则是求解常微分方程 (ODEs) 的一种隐式、A-稳定的二阶格式。\n- 随着空间网格的细化，半离散抛物型偏微分方程的刚性增加，离散拉普拉斯算子的特征值与 $h^{-2}$ 成比例缩放。\n\n实现一种精确解构造法来设置 $f$、$g_0$、$g_1$ 和 $u_0$，从而使精确解已知。对于下面的每个测试用例，计算在一系列时间步长下 $T$ 时刻的数值解，并测量内部网格上的最大范数误差。然后，通过对所提供的时间步长上的 $\\log_{10}(E(\\Delta t))$ 与 $\\log_{10}(\\Delta t)$ 进行最小二乘线性拟合，来估计观测到的收敛阶 $p$，其中 $E(\\Delta t)$ 表示最终时刻的最大范数误差，$\\Delta t$ 是时间步长。\n\n使用以下测试套件，均设置 $\\alpha = 1$ 和 $T = 1$：\n\n- 情况 A（非齐次狄利克雷边界条件，光滑的时间依赖性）：\n  - 精确解：$u(x,t) = e^{-t}\\left(\\sin(\\pi x) + x\\right)$。\n  - 边界数据：$g_0(t) = 0$, $g_1(t) = e^{-t}$。\n  - 源项：$f(x,t) = e^{-t}\\left((\\pi^2 - 1)\\sin(\\pi x) - x\\right)$。\n  - 空间分辨率：$M = 400$ 个内部点。\n  - 时间步长：$\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$。\n\n- 情况 B（齐次狄利克雷边界条件）：\n  - 精确解：$u(x,t) = e^{-t}\\sin(\\pi x)$。\n  - 边界数据：$g_0(t) = 0$, $g_1(t) = 0$。\n  - 源项：$f(x,t) = e^{-t}(\\pi^2 - 1)\\sin(\\pi x)$。\n  - 空间分辨率：$M = 400$ 个内部点。\n  - 时间步长：$\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$。\n\n- 情况 C（非齐次狄利克雷边界条件，通过更细的网格获得更强的刚性）：\n  - 精确解：$u(x,t) = e^{-t^2}\\left(\\sin(\\pi x) + x\\right)$。\n  - 边界数据：$g_0(t) = 0$, $g_1(t) = e^{-t^2}$。\n  - 源项：$f(x,t) = e^{-t^2}\\left(\\pi^2\\sin(\\pi x) - 2t\\left(\\sin(\\pi x) + x\\right)\\right)$。\n  - 空间分辨率：$M = 1600$ 个内部点。\n  - 时间步长：$\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$。\n\n对于每种情况，按以下步骤进行：\n- 构建内部网格点 $x_i = i h$，$i = 1,2,\\dots,M$，其中 $h = \\frac{1}{M+1}$。\n- 使用二阶中心差分离散化和适当的随时间变化的边界注入，为内部未知量构建半离散刚性常微分方程组，得到形式为 $\\mathbf{y}'(t) = A\\mathbf{y}(t) + \\mathbf{b}(t)$ 的常微分方程，其中 $A$ 是由 $\\alpha$ 缩放的离散拉普拉斯算子，$\\mathbf{b}(t)$ 包含边界数据和源项。\n- 从精确的内部初始条件开始，对每个给定的 $\\Delta t$ 应用梯形法则于 $\\mathbf{y}'(t) = A\\mathbf{y}(t) + \\mathbf{b}(t)$ 进行时间推进，并计算 $t = T$ 时的数值解。\n- 计算 $t = T$ 时的最大范数误差为 $E(\\Delta t) = \\max_i \\left|y_i^{\\text{num}}(T) - u(x_i,T)\\right|$。\n- 通过最小二乘法将一条直线拟合到点 $\\left(\\log_{10}(\\Delta t), \\log_{10}(E(\\Delta t))\\right)$ 来估计观测阶 $p$，并报告其斜率 $p$。\n\n您的程序应产生一行输出，其中包含情况 A、情况 B 和情况 C 的三个观测阶 $p$，形式为用方括号括起来的逗号分隔列表（例如，“[pA,pB,pC]”）。所有计算都是纯数学的；不需要物理单位。此问题中不出现角度。此问题中不出现百分比。", "solution": "为了分析梯形法则（Crank–Nicolson 方法）在一维热方程与非齐次狄利克雷边界条件下的阶数降低现象，我们从抛物型偏微分方程的标准形式开始\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t), \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\n边界条件为 $u(0,t)=g_0(t)$ 和 $u(1,t)=g_1(t)$，初始条件为 $u(x,0)=u_0(x)$。\n\n直线法 (MOL) 在保持时间连续的同时离散化空间算子，从而产生一个常微分方程 (ODEs) 的刚性系统。使用一个包含 $M$ 个内部点 $x_i = i h$（其中 $i=1,\\dots,M$ 且 $h=(M+1)^{-1}$）的均匀网格，二阶导数通过二阶中心差分近似为\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t) \\approx \\frac{u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)}{h^2}.\n$$\n对于狄利克雷边界条件，$u_0(t)=g_0(t)$ 和 $u_{M+1}(t)=g_1(t)$ 是已知值，通过一个随时间变化的边界注入向量进入半离散常微分方程。将内部未知量表示为 $\\mathbf{y}(t) \\in \\mathbb{R}^M$，其分量为 $y_i(t)=u(x_i,t)$，并将离散拉普拉斯矩阵 $L \\in \\mathbb{R}^{M \\times M}$ 定义为三对角矩阵，其主对角线上元素为 $-2/h^2$，紧邻的次对角线和超对角线上元素为 $1/h^2$。半离散常微分方程可以写为\n$$\n\\mathbf{y}'(t) = \\alpha L \\mathbf{y}(t) + \\alpha \\mathbf{b}_{\\text{bc}}(t) + \\mathbf{f}(t),\n$$\n其中 $\\mathbf{b}_{\\text{bc}}(t) \\in \\mathbb{R}^M$ 除了第一个分量（取值为 $g_0(t)/h^2$）和最后一个分量（取值为 $g_1(t)/h^2$）外，其余各处均为零，而 $\\mathbf{f}(t) \\in \\mathbb{R}^M$ 是源项 $f(x_i,t)$ 的内部采样。\n\n我们现在将梯形法则应用于非自治线性常微分方程\n$$\n\\mathbf{y}'(t) = A \\mathbf{y}(t) + \\mathbf{b}(t), \\quad \\text{with } A = \\alpha L, \\ \\mathbf{b}(t) = \\alpha \\mathbf{b}_{\\text{bc}}(t) + \\mathbf{f}(t).\n$$\n梯形法则通过\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left( A \\mathbf{y}_{n} + \\mathbf{b}(t_n) + A \\mathbf{y}_{n+1} + \\mathbf{b}(t_{n+1}) \\right),\n$$\n从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$，这可以重新整理为线性系统\n$$\n\\left(I - \\frac{\\Delta t}{2} A \\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{\\Delta t}{2} A \\right) \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left( \\mathbf{b}(t_n) + \\mathbf{b}(t_{n+1}) \\right).\n$$\n由于 $A$ 是刚性的（其谱半径与 $h^{-2}$ 成比例），该系统必须在每个时间步长内进行隐式求解。我们预先计算矩阵 $I \\pm \\frac{\\Delta t}{2} A$，并使用直接稀疏求解器来高效处理具有相同 $\\Delta t$ 的多个时间步长。\n\n为了测试阶数降低，我们采用精确解构造法，一致地定义 $u(x,t)$、$g_0(t)$、$g_1(t)$ 和 $f(x,t)$，从而使得内部精确解在所有时刻都是已知的。我们考虑三种情况：\n- 情况 A：$u(x,t) = e^{-t}\\left(\\sin(\\pi x) + x\\right)$，其中 $g_0(t) = 0$, $g_1(t) = e^{-t}$，且 $f(x,t) = e^{-t}\\left((\\pi^2 - 1)\\sin(\\pi x) - x\\right)$。\n- 情况 B：$u(x,t) = e^{-t}\\sin(\\pi x)$，其中 $g_0(t) = 0$, $g_1(t) = 0$，且 $f(x,t) = e^{-t}(\\pi^2 - 1)\\sin(\\pi x)$。\n- 情况 C：$u(x,t) = e^{-t^2}\\left(\\sin(\\pi x) + x\\right)$，其中 $g_0(t) = 0$, $g_1(t) = e^{-t^2}$，且 $f(x,t) = e^{-t^2}\\left(\\pi^2\\sin(\\pi x) - 2t\\left(\\sin(\\pi x) + x\\right)\\right)$。\n\n对于每种情况，我们设置 $\\alpha = 1$, $T = 1$，并使用各自的 $M$ 值（情况 A 和情况 B 为 $M=400$，情况 C 为 $M=1600$）。然后我们使用 $\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$ 进行积分，并计算最终时刻的最大范数误差\n$$\nE(\\Delta t) = \\max_{1 \\le i \\le M} \\left| y_i^{\\text{num}}(T) - u(x_i,T) \\right|.\n$$\n为了估计观测阶 $p$，我们对点 $\\left( \\log_{10}(\\Delta t), \\log_{10}(E(\\Delta t)) \\right)$ 进行最小二乘直线拟合；这条线的斜率即为经验收敛阶 $p$：\n$$\np \\approx \\text{slope of } \\log_{10}(E(\\Delta t)) \\text{ versus } \\log_{10}(\\Delta t).\n$$\n\n阶数降低的原理性解释：对于足够光滑的非刚性常微分方程，梯形法则是全局二阶精确的。然而，对于由半离散抛物型偏微分方程产生的刚性系统，随时间变化的非齐次边界条件的存在引入了一个非自治强迫项 $\\mathbf{b}(t)$，它在每个时间步长都会激发刚性空间模态。在无穷范数中，这些由边界驱动的层会主导全局误差，除非该方法是为非自治项特别设计的刚性精确方法或采用了边界修正，否则在最大范数下观测到的时间收敛阶会从二阶降低到近似一阶。相比之下，对于齐次狄利克雷边界条件，强迫项不会引入随时间变化的边界层，梯形法则通常能在最大范数下保持二阶精度。\n\n算法：\n- 对每个 $\\Delta t$ 构建离散拉普拉斯算子 $L$ 和稀疏矩阵 $I \\pm \\frac{\\Delta t}{2}A$。\n- 预计算 $I - \\frac{\\Delta t}{2}A$ 的稀疏分解，以高效求解线性系统。\n- 使用梯形更新进行时间推进，同时进行一致的边界注入和源项采样。\n- 计算最终时刻的最大范数误差并进行拟合以获得 $p$。\n\n程序最终以“[pA,pB,pC]”的格式单行输出情况 A、情况 B 和情况 C 的三个观测阶 $p$。根据理论和经验证据，我们预期对于非齐次边界条件（情况 A 和情况 C），收敛阶近似为一阶；对于齐次边界条件（情况 B），收敛阶近似为二阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import splu\n\ndef build_laplacian_matrix(M, h, alpha=1.0):\n    \"\"\"\n    Build the discrete Laplacian with Dirichlet boundary conditions on M interior points.\n    L is tridiagonal with -2/h^2 on diagonal and 1/h^2 on off-diagonals, scaled by alpha.\n    \"\"\"\n    main = (-2.0 / h**2) * np.ones(M)\n    off = (1.0 / h**2) * np.ones(M - 1)\n    L = diags([off, main, off], offsets=[-1, 0, 1], shape=(M, M), format='csc')\n    return alpha * L\n\ndef trapezoidal_time_integration(M, T, dt, alpha, u_exact, f_fun, g0_fun, g1_fun):\n    \"\"\"\n    Integrate the semi-discrete system y' = A y + b(t), with A = alpha*L,\n    where b(t) = alpha*bc(t) + f(t), bc encodes Dirichlet boundary injection.\n    Return the infinity-norm error at time T.\n    \"\"\"\n    h = 1.0 / (M + 1)\n    x = (np.arange(1, M + 1)) * h\n\n    # Build A = alpha*L\n    A = build_laplacian_matrix(M, h, alpha=alpha)\n    I = diags([np.ones(M)], [0], shape=(M, M), format='csc')\n\n    # Precompute matrices for trapezoidal rule\n    M_lhs = (I - (dt / 2.0) * A).tocsc()\n    M_rhs = (I + (dt / 2.0) * A).tocsc()\n    # Factorize LHS matrix for repeated solves\n    lu = splu(M_lhs)\n\n    # Initial condition from exact solution at t=0\n    y = u_exact(x, 0.0)\n\n    # Number of time steps\n    N_steps = int(round(T / dt))\n    # March in time\n    t = 0.0\n    for n in range(N_steps):\n        t_n = t\n        t_np1 = t + dt\n\n        # Boundary injection vectors at t_n and t_{n+1}\n        bc_n = np.zeros(M)\n        bc_np1 = np.zeros(M)\n        g0_n = g0_fun(t_n)\n        g1_n = g1_fun(t_n)\n        g0_np1 = g0_fun(t_np1)\n        g1_np1 = g1_fun(t_np1)\n        # Injection: first and last entries incorporate boundary values scaled by 1/h^2\n        bc_n[0] = g0_n / h**2\n        bc_n[-1] = g1_n / h**2\n        bc_np1[0] = g0_np1 / h**2\n        bc_np1[-1] = g1_np1 / h**2\n\n        # Source term vectors at t_n and t_{n+1}\n        f_n = f_fun(x, t_n)\n        f_np1 = f_fun(x, t_np1)\n\n        # Assemble RHS: (I + dt/2 A) y_n + dt/2 [alpha*(bc_n + bc_np1) + (f_n + f_np1)]\n        rhs = M_rhs.dot(y) + (dt / 2.0) * (alpha * (bc_n + bc_np1) + (f_n + f_np1))\n\n        # Solve for y_{n+1}\n        y = lu.solve(rhs)\n\n        t = t_np1\n\n    # Compute exact solution at final time and error in infinity norm\n    y_exact_T = u_exact(x, T)\n    err = np.max(np.abs(y - y_exact_T))\n    return err\n\ndef observed_order(errors, dts):\n    \"\"\"\n    Estimate observed order p by least-squares fit of log10(error) vs log10(dt).\n    \"\"\"\n    log_dt = np.log10(np.array(dts))\n    log_err = np.log10(np.array(errors))\n    # Fit line: log_err = p*log_dt + c\n    p, c = np.polyfit(log_dt, log_err, 1)\n    return float(p)\n\n# Manufactured solutions and data for the test cases\ndef case_A_data():\n    alpha = 1.0\n    M = 400\n    T = 1.0\n    dts = [1/20, 1/40, 1/80, 1/160]\n    # Exact solution: u(x,t) = exp(-t) * (sin(pi x) + x)\n    def u_exact(x, t):\n        return np.exp(-t) * (np.sin(np.pi * x) + x)\n    def g0_fun(t):\n        return 0.0\n    def g1_fun(t):\n        return np.exp(-t)\n    # f(x,t) = exp(-t) * ((pi^2 - 1) sin(pi x) - x)\n    def f_fun(x, t):\n        return np.exp(-t) * ((np.pi**2 - 1.0) * np.sin(np.pi * x) - x)\n    return alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun\n\ndef case_B_data():\n    alpha = 1.0\n    M = 400\n    T = 1.0\n    dts = [1/20, 1/40, 1/80, 1/160]\n    # Exact solution: u(x,t) = exp(-t) * sin(pi x)\n    def u_exact(x, t):\n        return np.exp(-t) * np.sin(np.pi * x)\n    def g0_fun(t):\n        return 0.0\n    def g1_fun(t):\n        return 0.0\n    # f(x,t) = exp(-t) * (pi^2 - 1) * sin(pi x)\n    def f_fun(x, t):\n        return np.exp(-t) * (np.pi**2 - 1.0) * np.sin(np.pi * x)\n    return alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun\n\ndef case_C_data():\n    alpha = 1.0\n    M = 1600\n    T = 1.0\n    dts = [1/20, 1/40, 1/80, 1/160]\n    # Exact solution: u(x,t) = exp(-t^2) * (sin(pi x) + x)\n    def u_exact(x, t):\n        return np.exp(-t**2) * (np.sin(np.pi * x) + x)\n    def g0_fun(t):\n        return 0.0\n    def g1_fun(t):\n        return np.exp(-t**2)\n    # f(x,t) = exp(-t^2) * (pi^2 sin(pi x) - 2 t (sin(pi x) + x))\n    def f_fun(x, t):\n        return np.exp(-t**2) * (np.pi**2 * np.sin(np.pi * x) - 2.0 * t * (np.sin(np.pi * x) + x))\n    return alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun\n\ndef run_case(alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun):\n    errors = []\n    for dt in dts:\n        err = trapezoidal_time_integration(M, T, dt, alpha, u_exact, f_fun, g0_fun, g1_fun)\n        errors.append(err)\n    p = observed_order(errors, dts)\n    return p\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = [case_A_data(), case_B_data(), case_C_data()]\n    results = []\n    for alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun in cases:\n        p = run_case(alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun)\n        # For stability in printing, limit to a reasonable number of decimals\n        results.append(f\"{p:.6f}\")\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3406952"}]}