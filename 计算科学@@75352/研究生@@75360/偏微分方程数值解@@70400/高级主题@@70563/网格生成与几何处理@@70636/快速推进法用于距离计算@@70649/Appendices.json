{"hands_on_practices": [{"introduction": "快速行进法 (FMM) 的核心在于其局部更新机制，该机制在每个网格点上精确地计算到达时间。这个过程不仅仅是简单地应用一个公式，而是需要根据波前的局部几何形状，动态地在一维和二维更新方案之间做出选择。这个练习将带你深入该决策逻辑的推导过程，确保你不仅知道如何计算，更理解为何如此计算，这对于深刻掌握算法的因果律至关重要。[@problem_id:3391176]", "problem": "考虑各向同性的Eikonal方程 $|\\nabla T(\\mathbf{x})| = 1/f(\\mathbf{x})$，其中 $T$ 是以速度 $f(\\mathbf{x})$ 传播的波前的到达时间。在快速行进法（FMM）中，网格节点 $(i,j)$ 处的暂定更新值是使用迎风Godunov离散化计算的，该离散化在两个方向上具有相等的网格间距 $h$，并基于沿坐标轴已接受的相邻节点的到达时间。设沿 $x$ 方向和 $y$ 方向的最小已接受到达时间分别为 $a$ 和 $b$。假设在暂定更新时必须满足单调性约束 $T \\geq \\max\\{a,b\\}$。\n\n从Eikonal方程出发，利用迎风原理，推导出 $T$ 必须满足的关于 $a$、$b$、$h$ 和 $f$ 的局部离散关系，并由此关系推导出决定二维更新或一维更新是否适用的决策逻辑。然后，应用您的逻辑，使用数值 $a=0.35$，$b=0.50$，$h=0.01$ 和恒定速度 $f=1.8$ 来计算节点上的暂定更新值 $T$。将您的最终答案表示为单个数字。不需要四舍五入。", "solution": "此问题陈述经评估具有科学依据、提法恰当且客观。它是偏微分方程数值解中的一个标准问题，具体涉及用于求解Eikonal方程的快速行进法。所提供的数据充分且一致，足以得出一个唯一解。因此，该问题被视为有效，并将在下面给出完整解答。\n\n各向同性的Eikonal方程由下式给出\n$$ |\\nabla T(\\mathbf{x})|^2 = \\frac{1}{f(\\mathbf{x})^2} $$\n其中 $T(\\mathbf{x})$ 是在位置 $\\mathbf{x}$ 的到达时间，$f(\\mathbf{x})$ 是传播速度。在具有均匀间距 $h$ 的二维笛卡尔网格中，该方程可以写成\n$$ \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = \\frac{1}{f^2} $$\n快速行进法（FMM）使用迎风Godunov格式来离散化空间导数。迎风原理确保信息从较小的到达时间传播到较大的到达时间。在我们希望计算暂定到达时间 $T$ 的网格节点 $(i,j)$ 处，我们使用其邻居的已接受到达时间。设 $a$ 和 $b$ 分别是沿 $x$ 和 $y$ 坐标方向的最小已接受到达时间。偏导数的迎风离散化基于这样一个思想：为了使波前推进，新的时间 $T$ 必须大于波前传播来源邻居处的时间。一阶迎风离散化的一般形式是：\n$$ \\left(\\max\\left(0, \\frac{T-a}{h}\\right)\\right)^2 + \\left(\\max\\left(0, \\frac{T-b}{h}\\right)\\right)^2 = \\frac{1}{f^2} $$\n这里，我们通过直接使用 $a$ 和 $b$ 作为相关的迎风邻居值来简化表示法。问题陈述了单调性约束 $T \\ge \\max\\{a, b\\}$，这意味着 $(T-a)$ 和 $(T-b)$ 都应为非负数。\n\n首先，我们假设二维（2D）更新是适用的，并推导局部离散关系。这个假设意味着波前使用来自 $x$ 和 $y$ 两个方向的信息传播到节点 $(i,j)$。在这种情况下，$\\max$ 函数内的两项都是正的，方程简化为：\n$$ \\left(\\frac{T-a}{h}\\right)^2 + \\left(\\frac{T-b}{h}\\right)^2 = \\frac{1}{f^2} $$\n该方程是 $T$ 在二维更新下必须满足的局部离散关系。我们可以解这个关于 $T$ 的二次方程：\n$$ (T-a)^2 + (T-b)^2 = \\frac{h^2}{f^2} $$\n$$ T^2 - 2aT + a^2 + T^2 - 2bT + b^2 = \\frac{h^2}{f^2} $$\n$$ 2T^2 - 2(a+b)T + \\left(a^2 + b^2 - \\frac{h^2}{f^2}\\right) = 0 $$\n使用二次方程求根公式 $T = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$，其中 $A=2$，$B=-2(a+b)$，$C = a^2+b^2 - (h/f)^2$：\n$$ T = \\frac{2(a+b) \\pm \\sqrt{4(a+b)^2 - 8\\left(a^2+b^2 - \\frac{h^2}{f^2}\\right)}}{4} $$\n$$ T = \\frac{a+b \\pm \\sqrt{(a+b)^2 - 2(a^2+b^2) + \\frac{2h^2}{f^2}}}{2} $$\n$$ T = \\frac{a+b \\pm \\sqrt{a^2+2ab+b^2 - 2a^2-2b^2 + \\frac{2h^2}{f^2}}}{2} $$\n$$ T = \\frac{a+b \\pm \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2}}{2} $$\n由于我们要求 $T \\ge \\max\\{a, b\\}$，我们必须选择较大的根，即对应于 `+` 号的根：\n$$ T_{2D} = \\frac{a+b + \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2}}{2} $$\n这是二维更新的候选解。\n\n接下来，我们推导决策逻辑。$T_{2D}$ 的实数解存在的条件是判别式为非负：$\\frac{2h^2}{f^2} - (a-b)^2 \\ge 0$，这意味着 $|a-b| \\le \\frac{\\sqrt{2}h}{f}$。更重要的是，这个二维更新有效的假设取决于结果是否满足单调性约束 $T \\ge \\max\\{a,b\\}$。不失一般性，我们假设 $b \\ge a$，所以 $\\max\\{a,b\\}=b$。有效性条件是 $T_{2D} \\ge b$。\n$$ \\frac{a+b + \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2}}{2} \\ge b $$\n$$ a+b + \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2} \\ge 2b $$\n$$ \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2} \\ge b-a $$\n由于 $b-a \\ge 0$，我们可以对两边进行平方：\n$$ \\frac{2h^2}{f^2} - (a-b)^2 \\ge (b-a)^2 $$\n$$ \\frac{2h^2}{f^2} \\ge 2(a-b)^2 $$\n$$ \\frac{h^2}{f^2} \\ge (a-b)^2 \\implies \\frac{h}{f} \\ge |a-b| $$\n这就提供了决策逻辑。二维更新是适用的，当且仅当 $|a-b| \\le \\frac{h}{f}$。\n\n如果不满足此条件，即 $|a-b| > \\frac{h}{f}$，那么二维公式将得出 $T_{2D}  \\max\\{a,b\\}$，这违反了因果性原理。这意味着我们最初的假设是错误的；具体来说，更新并非受到两个邻居的影响。必须使用一般离散方程，其中一个 $\\max$ 项变为零。如果 $b \\ge a$ 且 $|a-b| > h/f$，那么 $T  b$，所以 $\\max(0, (T-b)/h) = 0$。控制方程简化为由具有较小到达时间的邻居（本例中为 $a$）决定的一维（1D）更新：\n$$ \\left(\\frac{T-a}{h}\\right)^2 + 0 = \\frac{1}{f^2} $$\n解出 $T$ 得：\n$$ T_{1D} = a + \\frac{h}{f} $$\n更一般地，一维更新使用邻居值中的最小值：$T = \\min(a,b) + \\frac{h}{f}$。\n\n决策逻辑如下：\n1.  计算 $|a-b|$ 和 $\\frac{h}{f}$。\n2.  如果 $|a-b| \\le \\frac{h}{f}$，则更新是二维的，且 $T = \\frac{a+b + \\sqrt{2(h/f)^2 - (a-b)^2}}{2}$。\n3.  如果 $|a-b| > \\frac{h}{f}$，则更新是一维的，且 $T = \\min(a,b) + \\frac{h}{f}$。\n\n现在，我们将此逻辑应用于给定值：$a=0.35$，$b=0.50$，$h=0.01$ 和 $f=1.8$。\n我们将这些值表示为精确分数以避免舍入误差：\n$a = 0.35 = \\frac{35}{100} = \\frac{7}{20}$\n$b = 0.50 = \\frac{50}{100} = \\frac{1}{2}$\n$h = 0.01 = \\frac{1}{100}$\n$f = 1.8 = \\frac{18}{10} = \\frac{9}{5}$\n\n首先，我们检查决策逻辑的条件：\n$$ |a-b| = \\left|\\frac{7}{20} - \\frac{1}{2}\\right| = \\left|\\frac{7}{20} - \\frac{10}{20}\\right| = \\left|-\\frac{3}{20}\\right| = \\frac{3}{20} $$\n$$ \\frac{h}{f} = \\frac{1/100}{9/5} = \\frac{1}{100} \\cdot \\frac{5}{9} = \\frac{5}{900} = \\frac{1}{180} $$\n现在我们比较 $|a-b|$ 与 $\\frac{h}{f}$：\n$$ \\frac{3}{20} \\quad \\text{vs.} \\quad \\frac{1}{180} $$\n为了比较，我们可以使用通分或交叉相乘：\n$$ 3 \\times 180 = 540 $$\n$$ 20 \\times 1 = 20 $$\n因为 $540 > 20$，我们有 $\\frac{3}{20} > \\frac{1}{180}$。\n条件 $|a-b| \\le \\frac{h}{f}$ 不成立。\n\n因此，一维（1D）更新是适用的。暂定更新值 $T$ 使用两个邻居值中较小的一个来计算，即 $T_{\\min} = \\min(a,b) = a = \\frac{7}{20}$。\n$$ T = T_{\\min} + \\frac{h}{f} $$\n$$ T = \\frac{7}{20} + \\frac{1}{180} $$\n为了将这些分数相加，我们找到一个公分母，即 $180$：\n$$ T = \\frac{7 \\times 9}{20 \\times 9} + \\frac{1}{180} = \\frac{63}{180} + \\frac{1}{180} = \\frac{64}{180} $$\n最后，我们简化分数：\n$$ T = \\frac{64 \\div 4}{180 \\div 4} = \\frac{16}{45} $$\n节点上到达时间 $T$ 的暂定更新值为 $\\frac{16}{45}$。", "answer": "$$ \\boxed{\\frac{16}{45}} $$", "id": "3391176"}, {"introduction": "将数值算法从理论转化为可靠的代码是计算科学中的一项关键技能。然而，仅仅实现算法是不够的，我们还必须验证其正确性。这个实践将指导你完成一个标准的验证流程：通过网格加密研究，将你的快速行进法 (FMM) 实现与已知的解析解进行比较，并量化其精度和收敛阶，这是衡量任何数值方法性能的基本步骤。[@problem_id:3391181]", "problem": "考虑各向同性的程函方程（Eikonal equation），这是一个 Hamilton–Jacobi 偏微分方程，用于模拟具有空间变化速度的波前传播。未知到达时间场 $T(x)$ 满足方程 $|\\nabla T(x)| = \\frac{1}{f(x)}$，其中 $f(x)$ 表示局部波前速度。对于常数速度 $f(x) \\equiv f_0$ 和位于 $x_s$ 的单点源，解是径向对称的，并由最短路径的几何形状决定。在此设定下，设计并实现一个网格加密研究，以评估快速行进法（Fast Marching Method, FMM）在均匀二维网格上对程函方程进行离散化的数值精度和观测到的精度阶。\n\n您的任务是编写一个完整的程序，该程序：\n- 在方形域 $[0,1] \\times [0,1]$ 上，使用间距为 $h$ 的均匀笛卡尔网格，通过一阶迎风、单调离散化方法实现二维快速行进法。离散化必须从程函方程导出，并通过一个从较小到达时间向较大到达时间推进的接受机制来遵循因果关系。\n- 使用恒定速度 $f(x) \\equiv f_0$ 和一个到达时间为零的单点源，该点源精确位于网格节点上，以避免子网格投影误差。源点位置的选择必须确保其在测试套件的所有网格分辨率上都存在。\n- 对于具有点源的恒定速度情况，根据控制方程和最短路径的几何形状推导出解析解 $T_{\\text{exact}}(x)$，并用它来计算基于网格的误差范数。\n\n网格加密研究必须遵循以下要求：\n- 网格：使用每个维度有 $N \\in \\{33,65,129,257\\}$ 个点的均匀网格，因此网格间距为 $h = \\frac{1}{N-1}$。这确保了当 $N$ 为奇数时，坐标 $x = 0.5$ 始终是网格节点。\n- 误差范数：对于每个 $N$，计算数值解 $T_h$ 和解析解 $T_{\\text{exact}}$ 在所有网格节点上的离散 $L_1$、$L_2$ 和 $L_\\infty$ 误差范数。使用与积分范数一致的离散近似：\n  - $L_1$ 误差：$E_{1}(h) = h^2 \\sum_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$。\n  - $L_2$ 误差：$E_{2}(h) = \\sqrt{h^2 \\sum_{i,j} (T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j}))^2}$。\n  - $L_\\infty$ 误差：$E_{\\infty}(h) = \\max_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$。\n- 观测精度阶：对于一系列网格间距 $h_1 > h_2 > \\dots$，通过在对数-对数空间中计算连续网格级别之间误差趋势的斜率来定义给定范数的观测阶 $p$：\n  $$p_{k} = \\frac{\\log\\left(\\frac{E(h_{k+1})}{E(h_{k})}\\right)}{\\log\\left(\\frac{h_{k+1}}{h_{k}}\\right)}.$$\n  通过计算测试套件中所有连续网格对的 $\\{p_{k}\\}$ 的中位数，为每个范数报告一个鲁棒性增强的估计值。\n\n测试套件规范：\n- 情况 A（理想情况）：$f_0 = 1$，源点位于域中心 $x_s = (0.5,0.5)$。\n- 情况 B（速度变化）：$f_0 = 2$，源点位于域中心 $x_s = (0.5,0.5)$。\n- 情况 C（几何边界情况）：$f_0 = 1$，源点位于域角落 $x_s = (0,0)$。\n\n解析解要求：您必须使用程函方程和最短路径的几何形状，从第一性原理出发，确定恒定 $f_0$ 和单源 $x_s$ 情况下的解析解 $T_{\\text{exact}}(x)$。此解析解必须用于误差计算。\n\n最终输出格式：\n- 对于每种情况，计算四个网格上三种范数 $L_1$、$L_2$ 和 $L_\\infty$ 的观测阶中位数。将三种情况的结果汇总为一个包含九个浮点数的列表，顺序为 $[p_{L_1}^{\\text{A}}, p_{L_2}^{\\text{A}}, p_{L_\\infty}^{\\text{A}}, p_{L_1}^{\\text{B}}, p_{L_2}^{\\text{B}}, p_{L_\\infty}^{\\text{B}}, p_{L_1}^{\\text{C}}, p_{L_2}^{\\text{C}}, p_{L_\\infty}^{\\text{C}}]$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[result_1,result_2,\\dots,result_9]$）。\n所有量都是无量纲的；不需要物理单位。不涉及角度。将所有最终数值输出表示为浮点数。", "solution": "该问题要求实现一个网格加密研究，以确定求解程函方程的一阶快速行进法（Fast Marching Method, FMM）的观测精度阶。该研究将在二维方形域上针对恒定波速和单点源进行。\n\n### 1. 基本原理与解析解\n\n控制方程是各向同性程函方程：\n$$\n|\\nabla T(x)| = \\frac{1}{f(x)}\n$$\n其中 $T(x)$ 是传播波前的到达时间场，$f(x)$ 是波前的局部速度。在这个问题中，速度是恒定的，$f(x) \\equiv f_0$。该方程描述了从源区域出发的最短传播时间。在速度恒为 $f_0$ 时，介质是均匀的，两点之间的最短路径是直线。走完这条路径所需的时间是其欧几里得长度除以速度。\n\n给定位于 $x_s$ 的单点源，其初始到达时间为 $T(x_s) = 0$，则到达任何其他点 $x$ 的时间由从 $x_s$ 到 $x$ 的最短路径长度决定。对于恒定速度，此路径是连接它们的直线段。因此，解析解是从源点的欧几里得距离，并按慢度 $S_0 = 1/f_0$ 进行缩放：\n$$\nT_{\\text{exact}}(x) = \\frac{\\|x - x_s\\|_2}{f_0}\n$$\n对于点 $x = (x, y)$ 和源点 $x_s = (x_s, y_s)$，其显式形式为：\n$$\nT_{\\text{exact}}(x, y) = \\frac{\\sqrt{(x-x_s)^2 + (y-y_s)^2}}{f_0}\n$$\n这个精确解将作为计算数值误差的基准。除了在源点 $x=x_s$ 处存在一个锥形奇点外，它在任何地方都是光滑的。\n\n### 2. 数值离散化与快速行进法\n\n我们使用每个维度有 $N$ 个点的均匀笛卡尔网格对域 $[0,1] \\times [0,1]$ 进行离散化，网格间距为 $h = 1/(N-1)$。设 $T_{i,j}$ 为 $T(ih, jh)$ 的数值近似。\n\n程函方程平方后为 $(\\frac{\\partial T}{\\partial x})^2 + (\\frac{\\partial T}{\\partial y})^2 = S^2$，其中 $S = 1/f_0$ 是恒定的慢度。必须使用一阶、迎风、单调的离散化方法。这意味着值 $T_{i,j}$ 仅使用其具有更小到达时间的邻居节点的值来计算。FMM 算法自然地强制了这种因果关系。偏导数的迎风离散化为：\n$$\n\\left(\\max\\left(\\frac{T_{i,j}-T_{i-1,j}}{h}, -\\frac{T_{i+1,j}-T_{i,j}}{h}, 0\\right)\\right)^2 + \\left(\\max\\left(\\frac{T_{i,j}-T_{i,j-1}}{h}, -\\frac{T_{i,j+1}-T_{i,j}}{h}, 0\\right)\\right)^2 = S^2\n$$\n在 FMM 框架内，当更新 $T_{i,j}$ 时，其迎风邻居节点已被赋予其最终的、更小的到达时间。设 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$。$T_{i,j}$ 的方程根据两种情况简化：\n\n1.  **一维更新**：如果波前主要从一个方向（例如 $x$ 方向）到达 $(i,j)$，则更新模拟一维问题。这种情况发生在 $|T_x - T_y| \\ge hS$ 时。此时，更新公式为：\n    $$\n    T_{i,j} = \\min(T_x, T_y) + hS\n    $$\n\n2.  **二维更新**：如果波前从包含 $x$ 和 $y$分量的方向到达，则必须求解一个二次方程。这种情况发生在 $|T_x - T_y|  hS$ 时。其基本方程是 $(T_{i,j} - T_x)^2 + (T_{i,j} - T_y)^2 = (hS)^2$。求解 $T_{i,j}$ 并取较大根（对应于粘性解）可得：\n    $$\n    T_{i,j} = \\frac{T_x + T_y + \\sqrt{2(hS)^2 - (T_x - T_y)^2}}{2}\n    $$\n\n**快速行进法（FMM）**是一种高效的算法，用于按正确顺序求解离散化的程函方程。它使用一个最小优先队列来系统地将波前从较小到达时间推进到较大到达时间。\n- **节点状态**：每个网格节点处于三种状态之一：`KNOWN`（已知，最终时间已计算）、`TRIAL`（试验，已计算临时时间，位于传播波前上）或 `UNSEEN`（未知，远离波前）。\n- **初始化**：除源节点外，所有节点都为 `UNSEEN` 状态，其 $T=\\infty$。源节点的 $T=0$ 并标记为 `TRIAL`。\n- **算法**：\n    1. 一个最小优先队列存储所有 `TRIAL` 节点，按其到达时间排序。\n    2. 重复地从队列中提取具有最小到达时间的 `TRIAL` 节点 $(i,j)$。\n    3. 将此节点标记为 `KNOWN`。\n    4. 对于 $(i,j)$ 的每个 `UNSEEN` 或 `TRIAL` 邻居，使用上述迎风离散化方案计算新的到达时间。\n    5. 如果新计算的时间小于邻居的当前时间，则更新邻居的时间并将其添加到优先队列中。\n\n### 3. 网格加密研究与误差分析\n\n进行网格加密研究以评估数值精度。理论精度阶 $p$ 通过 $E(h) \\approx C h^p$ 将误差 $E$ 与网格间距 $h$ 联系起来。通过在一系列连续加密的网格上计算误差，我们可以估计 $p$。\n\n- **网格**：每个维度有 $N \\in \\{33, 65, 129, 257\\}$ 个点的均匀网格，产生的网格间距 $h_k = 1/(N_k-1)$ 逐次减半。\n- **误差范数**：对于每个网格，通过将数值解 $T_h$ 与在网格节点上求值的解析解 $T_{\\text{exact}}$进行比较，计算离散 $L_1$、$L_2$ 和 $L_\\infty$ 误差范数。\n    - $L_1$ 误差：$E_{1}(h) = h^2 \\sum_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$\n    - $L_2$ 误差：$E_{2}(h) = \\sqrt{h^2 \\sum_{i,j} (T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j}))^2}$\n    - $L_\\infty$ 误差：$E_{\\infty}(h) = \\max_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$\n- **观测精度阶**：对于每个范数，在连续的网格级别 $h_k$ 和 $h_{k+1}$ 之间计算阶数 $p_k$：\n    $$\n    p_{k} = \\frac{\\log\\left(E(h_{k+1})/E(h_{k})\\right)}{\\log\\left(h_{k+1}/h_{k}\\right)}\n    $$\n由于 $h_{k+1}/h_k = 1/2$，这简化为 $p_k = -\\log_2(E(h_{k+1})/E(h_k))$。通过取序列 $\\{p_k\\}$ 的中位数，可以获得对阶数 $p$ 的单个鲁棒估计。对所有三个指定的测试用例执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef fast_marching(N, h, f0, source_idx):\n    \"\"\"\n    Implements the Fast Marching Method on a 2D uniform grid.\n\n    Args:\n        N (int): Number of grid points per dimension.\n        h (float): Grid spacing.\n        f0 (float): Constant wave speed.\n        source_idx (tuple): (row, col) indices of the source point.\n\n    Returns:\n        numpy.ndarray: A (N, N) array of arrival times.\n    \"\"\"\n    # 1. Initialization\n    T = np.full((N, N), np.inf, dtype=np.float64)\n    # States: 0=UNSEEN, 1=TRIAL, 2=KNOWN\n    states = np.zeros((N, N), dtype=np.uint8)\n    UNSEEN, TRIAL, KNOWN = 0, 1, 2\n    \n    pq = []  # Min-priority queue\n\n    slowness_h = h / f0\n\n    # Set source node\n    isrc, jsrc = source_idx\n    T[isrc, jsrc] = 0.0\n    states[isrc, jsrc] = TRIAL\n    heapq.heappush(pq, (0.0, isrc, jsrc))\n\n    # 2. Main loop\n    while pq:\n        time, i, j = heapq.heappop(pq)\n\n        # If a better time has been found since this entry was added, skip.\n        if time  T[i, j]:\n            continue\n\n        states[i, j] = KNOWN\n\n        # 3. Update neighbors\n        # Iterate over neighbors (_ni, _nj) of the current node (i, j)\n        for _ni, _nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            # Check if neighbor is within grid and not already finalized\n            if 0 = _ni  N and 0 = _nj  N and states[_ni, _nj] != KNOWN:\n                \n                # Calculate new tentative time for the neighbor (_ni, _nj)\n                # by solving its local Eikonal equation.\n                \n                # Get minimum arrival time from x-direction neighbors of (_ni, _nj)\n                t_x_min = np.inf\n                if _ni  0:\n                    t_x_min = min(t_x_min, T[_ni - 1, _nj])\n                if _ni  N - 1:\n                    t_x_min = min(t_x_min, T[_ni + 1, _nj])\n                \n                # Get minimum arrival time from y-direction neighbors of (_ni, _nj)\n                t_y_min = np.inf\n                if _nj  0:\n                    t_y_min = min(t_y_min, T[_ni, _nj - 1])\n                if _nj  N - 1:\n                    t_y_min = min(t_y_min, T[_ni, _nj + 1])\n                \n                # If neither neighbor has a finite time, we can't update yet.\n                if not (np.isfinite(t_x_min) or np.isfinite(t_y_min)):\n                    continue\n\n                # Determine whether to use 1D or 2D update\n                if abs(t_x_min - t_y_min) = slowness_h:\n                    t_new = min(t_x_min, t_y_min) + slowness_h\n                else:\n                    # Quadratic update\n                    discriminant = 2 * slowness_h**2 - (t_x_min - t_y_min)**2\n                    # Discriminant should be non-negative due to the condition above,\n                    # but floating point arithmetic may cause small negative values.\n                    discriminant = max(0, discriminant)\n                    t_new = (t_x_min + t_y_min + np.sqrt(discriminant)) / 2.0\n\n                # If the new time is an improvement, update and add to queue\n                if t_new  T[_ni, _nj]:\n                    T[_ni, _nj] = t_new\n                    if states[_ni, _nj] == UNSEEN:\n                        states[_ni, _nj] = TRIAL\n                    heapq.heappush(pq, (t_new, _ni, _nj))\n    \n    return T\n\ndef run_refinement_study(f0, source_coords):\n    \"\"\"\n    Performs a grid refinement study for a given case.\n\n    Args:\n        f0 (float): Constant wave speed.\n        source_coords (tuple): (x, y) coordinates of the source.\n\n    Returns:\n        list: A list of three median observed orders for L1, L2, Linf norms.\n    \"\"\"\n    grid_sizes = [33, 65, 129, 257]\n    errors = { \"l1\": [], \"l2\": [], \"linf\": [] }\n    h_values = []\n\n    for N in grid_sizes:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n\n        # Create grid\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n\n        # Source index must be exactly on a node\n        isrc = int(round(source_coords[0] / h))\n        jsrc = int(round(source_coords[1] / h))\n\n        # Compute numerical solution\n        T_numerical = fast_marching(N, h, f0, (isrc, jsrc))\n        \n        # Compute analytic solution\n        T_analytic = np.sqrt((xx - source_coords[0])**2 + (yy - source_coords[1])**2) / f0\n        \n        # Compute errors\n        diff = np.abs(T_numerical - T_analytic)\n        \n        # L_infinity error\n        errors[\"linf\"].append(np.max(diff))\n        \n        # L1 error\n        errors[\"l1\"].append(h**2 * np.sum(diff))\n        \n        # L2 error\n        errors[\"l2\"].append(np.sqrt(h**2 * np.sum(diff**2)))\n\n    # Compute observed orders of accuracy\n    orders = []\n    log_h_ratio = np.log(0.5)\n    for norm in [\"l1\", \"l2\", \"linf\"]:\n        p_k = []\n        for i in range(len(grid_sizes) - 1):\n            # p_k = log(E_k+1 / E_k) / log(h_k+1 / h_k)\n            # handle cases where error is zero\n            if errors[norm][i+1]  0 and errors[norm][i]  0:\n                log_err_ratio = np.log(errors[norm][i+1] / errors[norm][i])\n                p_k.append(log_err_ratio / log_h_ratio)\n        \n        if not p_k:\n             # This can happen if error is consistently zero, implying perfect accuracy\n             # on the test grids. The theoretical order is then irrelevant.\n             # Or if there are not enough data points.\n             orders.append(np.nan)\n        else:\n             orders.append(np.median(p_k))\n\n    return orders\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite specification\n    test_cases = [\n        {'f0': 1.0, 'source_coords': (0.5, 0.5)},  # Case A\n        {'f0': 2.0, 'source_coords': (0.5, 0.5)},  # Case B\n        {'f0': 1.0, 'source_coords': (0.0, 0.0)},  # Case C\n    ]\n\n    all_results = []\n    for case in test_cases:\n        orders = run_refinement_study(case['f0'], case['source_coords'])\n        all_results.extend(orders)\n    \n    # Format a string for the final output\n    result_str = \",\".join([f\"{r:.7f}\" for r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3391181"}]}