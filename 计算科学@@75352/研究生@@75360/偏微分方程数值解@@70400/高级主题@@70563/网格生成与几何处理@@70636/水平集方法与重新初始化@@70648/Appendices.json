{"hands_on_practices": [{"introduction": "重初始化方程是一种哈密顿-雅可比类型的偏微分方程，对于维持水平集函数的符号距离特性至关重要。其数值解通常依赖于迎风格式来正确捕捉信息的传播方向。本练习 ([@problem_id:2606595]) 提供了一个一维重初始化步骤的具体计算，让您在处理更复杂的多维实现之前，能够掌握迎风离散化的核心机理。", "problem": "在基于密度的结构拓扑优化中，通常将固体各向同性材料惩罚法 (Solid Isotropic Material with Penalization, SIMP) 与水平集方法 (Level-Set Method, LSM) 相结合，通过将过滤后的密度投影到由水平集场表示的隐式边界上。为了在水平集方法中保持曲率相关速度的数值鲁棒性，水平集场必须通过演化 Hamilton–Jacobi 型重新初始化方程，周期性地重新初始化为符号距离函数\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_{0})\\left(|\\nabla \\phi| - 1\\right) = 0,\n$$\n其中 $\\tau$ 是伪时间，$\\phi_{0}$ 是用于符号函数中的冻结初始水平集场，$S(\\phi_{0})$ 是一个平滑的符号函数，定义为\n$$\nS(\\phi_{0}) = \\frac{\\phi_{0}}{\\sqrt{\\phi_{0}^{2} + \\varepsilon^{2}}}.\n$$\n考虑一个一维均匀网格，节点索引为 $i \\in \\{0,1,2,3,4,5,6\\}$，间距 $\\Delta x = 0.5$，伪时间步长 $\\Delta \\tau = 0.1$。初始场为\n$$\n\\phi_{0} = \\left[\\phi_{0,0}, \\phi_{0,1}, \\phi_{0,2}, \\phi_{0,3}, \\phi_{0,4}, \\phi_{0,5}, \\phi_{0,6}\\right] = \\left[1.2,\\, 0.7,\\, 0.2,\\, -0.1,\\, -0.6,\\, -1.1,\\, -1.6\\right],\n$$\n平滑参数为 $\\varepsilon = 0.5$。请在节点 $i=3$ 处，对重新初始化方程执行一次显式伪时间更新。更新时，Hamilton–Jacobi 项使用一维空间中的单调迎风 Godunov 离散格式，并采用单边有限差分：\n$$\nD^{-}\\phi_{i} = \\frac{\\phi_{i}-\\phi_{i-1}}{\\Delta x}, \\quad D^{+}\\phi_{i} = \\frac{\\phi_{i+1}-\\phi_{i}}{\\Delta x}.\n$$\n在当前伪时间层级，将 $\\phi^{n}=\\phi_{0}$，计算一个伪时间步长后的 $\\phi^{n+1}_{3}$。最终答案以实数形式表示，并四舍五入至四位有效数字。无需单位。", "solution": "该问题要求在特定网格节点上，对水平集重新初始化方程计算单个伪时间步。问题陈述清晰，并包含了所有必要的物理量和数值参数。我们将按步骤进行求解。\n\n控制方程为 Hamilton-Jacobi 重新初始化方程，如下所示：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_{0})\\left(|\\nabla \\phi| - 1\\right) = 0\n$$\n其中 $\\tau$ 是伪时间，$\\phi$ 是水平集场，$S(\\phi_{0})$ 是基于初始场 $\\phi_0$ 的平滑符号函数。该方程可以重写为：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} = - S(\\phi_{0})\\left(|\\nabla \\phi| - 1\\right)\n$$\n我们使用显式前向欧拉格式在伪时间上对该方程进行离散化。对于给定的节点 $i$，更新规则为：\n$$\n\\frac{\\phi_{i}^{n+1} - \\phi_{i}^{n}}{\\Delta \\tau} = - S(\\phi_{0,i})\\left((|\\nabla \\phi|)_i^n - 1\\right)\n$$\n其中 $(|\\nabla \\phi|)_i^n$ 是在节点 $i$ 和伪时间层级 $n$ 处梯度大小的合适数值近似。整理方程以求解 $\\phi_{i}^{n+1}$，我们得到：\n$$\n\\phi_{i}^{n+1} = \\phi_{i}^{n} - \\Delta \\tau S(\\phi_{0,i}) \\left( (|\\nabla \\phi|)_i^n - 1 \\right)\n$$\n问题指定初始条件为 $\\phi^n = \\phi_0$。我们的任务是计算节点 $i=3$ 处的 $\\phi_{3}^{n+1}$。该节点的更新方程为：\n$$\n\\phi_{3}^{n+1} = \\phi_{0,3} - \\Delta \\tau S(\\phi_{0,3}) \\left( (|\\nabla \\phi|)_3^n - 1 \\right)\n$$\n首先，我们使用给定的定义 $S(\\phi_{0}) = \\frac{\\phi_{0}}{\\sqrt{\\phi_{0}^{2} + \\varepsilon^{2}}}$ 来计算平滑符号函数 $S(\\phi_{0,3})$。给定 $\\phi_{0,3} = -0.1$ 和 $\\varepsilon = 0.5$。\n$$\nS(\\phi_{0,3}) = \\frac{-0.1}{\\sqrt{(-0.1)^{2} + (0.5)^{2}}} = \\frac{-0.1}{\\sqrt{0.01 + 0.25}} = \\frac{-0.1}{\\sqrt{0.26}}\n$$\n接下来，我们必须确定梯度大小的数值近似值 $(|\\nabla \\phi|)_3^n$。问题指定了单调迎风 Godunov 格式。迎风方向的选择取决于信息传播的方向，该方向由 Hamilton-Jacobi 方程的特征速度的符号决定。方程的空间部分是 $H(\\phi_x) = S(\\phi_0)(|\\phi_x|-1)$。特征速度为 $c = H'(\\phi_x) = S(\\phi_0) \\frac{d}{d\\phi_x}(|\\phi_x|) = S(\\phi_0) \\text{sgn}(\\phi_x)$。\n\n我们使用所提供的单边有限差分公式来近似节点 $i=3$ 处的 $\\phi_x$：\n后向差分为：\n$$\nD^{-}\\phi_{3}^{n} = \\frac{\\phi_{3}^{n}-\\phi_{2}^{n}}{\\Delta x} = \\frac{\\phi_{0,3}-\\phi_{0,2}}{\\Delta x} = \\frac{-0.1 - 0.2}{0.5} = \\frac{-0.3}{0.5} = -0.6\n$$\n前向差分为：\n$$\nD^{+}\\phi_{3}^{n} = \\frac{\\phi_{4}^{n}-\\phi_{3}^{n}}{\\Delta x} = \\frac{\\phi_{0,4}-\\phi_{0,3}}{\\Delta x} = \\frac{-0.6 - (-0.1)}{0.5} = \\frac{-0.5}{0.5} = -1.0\n$$\n由于 $D^{-}\\phi_{3}^{n}$ 和 $D^{+}\\phi_{3}^{n}$ 均为负值，局部梯度 $\\phi_x$ 为负。因此，$\\text{sgn}(\\phi_x) = -1$。\n$S(\\phi_{0,3})$ 的符号为负，因为 $\\phi_{0,3} = -0.1  0$。\n特征速度为 $c = S(\\phi_{0,3}) \\text{sgn}(\\phi_x) = (\\text{负}) \\times (-1) = (\\text{正})$。\n正的特征速度意味着信息从左向右传播。因此，迎风格式需要使用后向差分（向左侧“迎风”方向取值）。\n因此，数值梯度大小由后向差分的绝对值来近似：\n$$\n(|\\nabla \\phi|)_3^n \\approx |D^{-}\\phi_{3}^{n}| = |-0.6| = 0.6\n$$\n现在我们拥有计算 $\\phi_{3}^{n+1}$ 所需的所有部分。给定的参数是 $\\Delta \\tau = 0.1$ 和 $\\phi_{0,3} = -0.1$。\n将这些值代入更新方程：\n$$\n\\phi_{3}^{n+1} = -0.1 - (0.1) \\left(\\frac{-0.1}{\\sqrt{0.26}}\\right) \\left( 0.6 - 1 \\right)\n$$\n$$\n\\phi_{3}^{n+1} = -0.1 - (0.1) \\left(\\frac{-0.1}{\\sqrt{0.26}}\\right) \\left( -0.4 \\right)\n$$\n由于有三个负号，减法中的三项乘积为负。\n$$\n\\phi_{3}^{n+1} = -0.1 - \\frac{(0.1)(0.1)(0.4)}{\\sqrt{0.26}} = -0.1 - \\frac{0.004}{\\sqrt{0.26}}\n$$\n现在我们进行最终计算：\n$$\n\\sqrt{0.26} \\approx 0.50990195\n$$\n$$\n\\phi_{3}^{n+1} \\approx -0.1 - \\frac{0.004}{0.50990195} \\approx -0.1 - 0.0078446\n$$\n$$\n\\phi_{3}^{n+1} \\approx -0.1078446\n$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $1$, $0$, $7$, $8$。接下来的数字是 $4$，所以我们不进行进位。\n$$\n\\phi_{3}^{n+1} \\approx -0.1078\n$$", "answer": "$$\n\\boxed{-0.1078}\n$$", "id": "2606595"}, {"introduction": "理论上，重初始化方程能够保持零水平集的位置不变，但其数值实现会引入一些微妙的挑战，例如平滑参数 $\\epsilon$ 的选择。选择不当的 $\\epsilon$ 会导致在数值稳定性和界面位置精度（即界面漂移）之间进行权衡。本实践 ([@problem_id:3415541]) 将指导您完整实现一个二维重初始化方案，以通过经验性方法研究这种权衡，帮助您为调整这一关键参数以兼顾精度和效率建立直觉。", "problem": "要求您设计并实现一个数值实验，用以检验平滑符号函数正则化在水平集重新初始化中的作用。该实验的基础是水平集重新初始化偏微分方程的 Hamilton-Jacobi 方程形式及其离散上风（Godunov）近似。您的实验必须确定平滑参数如何影响界面漂移和收敛速度，并且必须在给出理论预测的同时，提供平滑参数的经验性优化结果。\n\n从以下经过充分测试且广泛使用的公式出发。令 $\\phi(x,y,\\tau)$ 为在重新初始化伪时间 $\\tau$ 内演化为符号距离函数的水平集函数。给定一个初始水平集函数 $\\phi_0(x,y)$，考虑重新初始化方程\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + \\operatorname{sign}_\\epsilon(\\phi_0)\\left(\\lVert \\nabla \\phi \\rVert - 1\\right) = 0,\n$$\n其中平滑符号函数为\n$$\n\\operatorname{sign}_\\epsilon(\\phi) = \\frac{\\phi}{\\sqrt{\\phi^2 + \\epsilon^2}},\n$$\n且 $\\epsilon0$ 是一个平滑参数。在理想离散化条件下，其稳态解满足 $\\lVert \\nabla \\phi \\rVert = 1$，同时保持 $\\phi_0$ 的零水平集不变。\n\n在一个具有网格中心未知量的均匀笛卡尔网格上，实现一个二维显式格式，该格式对哈密顿量 $\\lVert \\nabla \\phi \\rVert$ 使用 Godunov 上风近似。使用零诺伊曼边界条件。伪时间步长 $\\Delta \\tau$ 必须满足与 Hamilton-Jacobi 方程一致的稳定性条件，并且您必须监控其是否收敛到容差阈值。\n\n界面漂移必须相对于一个已知的解析零水平集进行量化。使用一个初始水平集函数，其零水平集是一个以 $(c_x,c_y)$ 为中心、半径为 $R_0$ 的圆，但其梯度初始大小不为 1。具体而言，定义径向距离 $r(x,y) = \\sqrt{(x-c_x)^2 + (y-c_y)^2}$ 并设置\n$$\n\\phi_0(x,y) = \\left[r(x,y) - R_0\\right] + \\beta \\left[r(x,y) - R_0\\right]^3,\n$$\n其中 $\\beta$ 是一个小的三次扰动振幅，以确保零水平集保持为 $r(x,y)=R_0$。界面漂移必须度量为数值上重新初始化的零水平集的平均半径与 $R_0$ 之间的绝对差，并以域长度单位表示。\n\n对于每个测试用例，您的程序必须扫描一组平滑参数 $\\epsilon$ 的候选值。这些值通过网格间距 $\\Delta x$ 进行缩放，即 $\\epsilon = c \\,\\Delta x$，其中 $c$ 来自一个给定的候选集。对于每个候选值 $c$，运行重新初始化直至收敛，并记录：\n- 以域长度单位表示的界面漂移，定义为 $| \\bar{R} - R_0 |$，其中 $\\bar{R}$ 是在以弧度为单位均匀间隔的角度上采样的零点穿越半径的平均值，\n- 达到收敛容差所需的伪时间迭代次数。\n\n然后，通过最小化漂移来选择经验最优的 $c$；如果出现平局，选择迭代次数最少的那个；如果仍然平局，选择最接近理论预测值 $c_{\\mathrm{theory}}=1$ 的那个。程序还必须报告每个测试用例的 $c_{\\mathrm{theory}}$。\n\n需实现的离散化细节：\n- 域：$[0,L]\\times[0,L]$，其中 $L=1$。\n- 网格：网格中心点 $(x_i,y_j)$，其中 $x_i = (i+1/2)\\Delta x$, $y_j = (j+1/2)\\Delta y$, $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y-1$。对于正方形网格，$\\Delta x = \\Delta y = L/N_x = L/N_y$。\n- 边界条件：零诺伊曼（将边界值复制到幽灵层或等效处理）。\n- Godunov 上风梯度大小。对每个网格点，计算单边差分 $D_x^+$, $D_x^-$, $D_y^+$, $D_y^-$ 并定义\n  - 对于 $\\operatorname{sign}_\\epsilon(\\phi_0)\\ge 0$，\n    $$\n    G = \\sqrt{\\max\\left(\\left[\\max(D_x^-,0)\\right]^2,\\left[\\min(D_x^+,0)\\right]^2\\right) + \\max\\left(\\left[\\max(D_y^-,0)\\right]^2,\\left[\\min(D_y^+,0)\\right]^2\\right)},\n    $$\n  - 对于 $\\operatorname{sign}_\\epsilon(\\phi_0) 0$，\n    $$\n    G = \\sqrt{\\max\\left(\\left[\\max(D_x^+,0)\\right]^2,\\left[\\min(D_x^-,0)\\right]^2\\right) + \\max\\left(\\left[\\max(D_y^+,0)\\right]^2,\\left[\\min(D_y^-,0)\\right]^2\\right)}.\n    $$\n  在更新式 $\\phi^{n+1} = \\phi^{n} - \\Delta \\tau \\operatorname{sign}_\\epsilon(\\phi_0)\\left(G - 1\\right)$ 中使用 $G$。\n\n收敛性评估：\n- 在每个伪时间步，计算残差 $R = \\max_{i,j}\\left|\\operatorname{sign}_\\epsilon(\\phi_0)\\left(G-1\\right)\\right|$。\n- 当 $R \\le \\mathrm{tol}$ 或达到最大迭代次数时停止。\n\n界面漂移估计：\n- 在 $[0,2\\pi)$ 上以弧度为单位均匀采样角度 $\\theta_k$。\n- 沿着从 $(c_x,c_y)$ 出发、方向为 $(\\cos\\theta_k,\\sin\\theta_k)$ 的每条射线，在半径 $r$ 上确定 $\\phi$ 的零点穿越区间，并使用双线性插值计算网格外的点上的 $\\phi(x,y)$ 值，通过二分法计算根直至达到容差。\n- 对这些半径求平均得到 $\\bar{R}$，并计算 $|\\bar{R} - R_0|$。\n\n测试套件：\n- 测试用例1（理想路径）：$N_x=N_y=64$, $R_0=0.28$, $(c_x,c_y)=(0.47,0.52)$, $\\beta=0.2$, $\\Delta \\tau = 0.3\\,\\Delta x$, $\\mathrm{tol}=10^{-3}$, $\\text{max\\_iter}=200$, 候选集 $\\mathcal{C}=\\{0.5,1.0,2.0,3.0\\}$, 角度样本数 $K=48$。\n- 测试用例2（边界条件压力测试）：$N_x=N_y=96$, 同样的 $R_0$, $(c_x,c_y)$, $\\beta$, $\\Delta \\tau=0.3\\,\\Delta x$, $\\mathrm{tol}=10^{-3}$, $\\text{max\\_iter}=250$, $\\mathcal{C}=\\{0.5,1.0,2.0,3.0\\}$, $K=64$。\n- 测试用例3（高分辨率边界情况）：$N_x=N_y=128$, 同样的 $R_0$, $(c_x,c_y)$, $\\beta$, $\\Delta \\tau=0.3\\,\\Delta x$, $\\mathrm{tol}=8\\times 10^{-4}$, $\\text{max\\_iter}=300$, $\\mathcal{C}=\\{0.5,1.0,2.0,3.0\\}$, $K=72$。\n\n理论预测：\n- 提供并使用理论值 $c_{\\mathrm{theory}}=1$，其动机是在 $\\phi$ 空间中平衡平滑宽度 $\\epsilon$ 与网格分辨率 $\\Delta x$，使得 $\\operatorname{sign}_\\epsilon$ 的过渡区域能被大约一个网格单元所解析。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例产生一个列表 $[c_{\\mathrm{emp}}, d, n, c_{\\mathrm{theory}}]$，其中 $c_{\\mathrm{emp}}$ 是经验最优缩放因子， $d$ 是以域长度单位表示的浮点数漂移值， $n$ 是达到容差的整数迭代次数， $c_{\\mathrm{theory}}$ 是理论缩放因子。例如：`[[c_emp1,d1,n1,c_theory1],[c_emp2,d2,n2,c_theory2],[c_emp3,d3,n3,c_theory3]]`。不应打印任何其他文本。", "solution": "所提出的问题在科学上是合理的、适定的，并包含了获得唯一、可验证解所需的所有信息。它涉及偏微分方程数值解中的一个标准课题：水平集方法中正则化的参数化问题。该问题是有效的。\n\n在此，我们介绍该数值实验的设计和基本原理。\n\n目标是分析平滑参数 $\\epsilon$ 对水平集重新初始化过程的准确性和效率的影响。重新初始化是一个过程，通过该过程，一个其零水平集隐式定义了一个几何界面的任意水平集函数 $\\phi$ 被转换为一个符号距离函数（SDF），而其零水平集的位置保持不变。一个 SDF 满足程函方程 $\\lVert \\nabla \\phi \\rVert = 1$。\n\n$\\phi$ 向 SDF 的演化由 Hamilton-Jacobi 偏微分方程控制：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0) \\left( \\lVert \\nabla \\phi \\rVert - 1 \\right) = 0\n$$\n其中 $\\tau$ 是一个伪时间变量。项 $S(\\phi_0)$ 是一个基于初始状态 $\\phi_0(x,y)$ 的符号函数。其目的是确保此双曲型偏微分方程的特征线将信息从零水平集向内和向外传播，从而在保持界面 $\\phi=0$ 的同时，对整个域重新计算距离。一个关键的洞见是，项 $(\\lVert \\nabla \\phi \\rVert - 1)$ 驱动了演化，当 $\\phi$ 成为 SDF 时，演化停止。\n\n直接实现不连续符号函数 $S(\\phi_0) = \\operatorname{sign}(\\phi_0)$ 会引入数值伪影。因此，采用了一个平滑版本：\n$$\n\\operatorname{sign}_\\epsilon(\\phi) = \\frac{\\phi}{\\sqrt{\\phi^2 + \\epsilon^2}}\n$$\n参数 $\\epsilon$ 控制了 $\\phi=0$ 周围过渡区域的宽度。$\\epsilon$ 的选择至关重要：如果太小，可能会出现数值振荡；如果太大，可能会导致零水平集漂移，从而破坏解的准确性。该问题要求通过一个缩放因子 $c$ 将 $\\epsilon$ 与网格间距 $\\Delta x$ 联系起来（即 $\\epsilon = c \\, \\Delta x$）来研究这种权衡关系。\n\n将 $c_{\\mathrm{theory}}=1$ 的理论动机基于尺度匹配论证。由于重新初始化的函数 $\\phi$ 近似于一个距离函数，函数值的变化 $\\Delta\\phi$ 大约对应于空间距离 $\\Delta\\phi$。平滑参数 $\\epsilon$ 定义了正则化符号函数在 $\\phi$ 空间中过渡带的厚度。通过设置 $\\epsilon = \\Delta x$，我们实质上规定了该过渡区域的物理宽度应与一个网格单元的量级相当。这是一种常见的启发式方法，用于在锐利而平滑的过渡需求与可用网格分辨率之间取得平衡。\n\n数值解在一个二维、均匀、网格中心的笛卡尔网格上实现。空间域为 $[0, L] \\times [0, L]$，其中 $L=1$，离散为 $N_x \\times N_y$ 个大小为 $\\Delta x = \\Delta y = L/N_x$ 的网格单元。网格点为 $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$。\n\n时间演化使用显式前向欧拉法进行：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta \\tau \\operatorname{sign}_\\epsilon(\\phi_{0,i,j}) \\left( G_{i,j} - 1 \\right)\n$$\n其中 $\\phi_{i,j}^{n}$ 是在网格点 $(i,j)$ 和伪时间步 $n$ 上的 $\\phi$ 值。关键部分是 $G_{i,j}$，即哈密顿量 $\\lVert \\nabla \\phi \\rVert$ 的数值近似。问题指定了 Godunov 上风格式。该格式遵循 Hamilton-Jacobi 方程固有的信息传播方向。单边有限差分的选择取决于 $\\operatorname{sign}_\\epsilon(\\phi_0)$ 的符号，该符号决定了信息在 $\\phi$ 中是“上坡”流动还是“下坡”流动。\n\n令单边差分算子为 $D_x^\\pm$ 和 $D_y^\\pm$。对于一个点 $(i,j)$，若 $\\operatorname{sign}_\\epsilon(\\phi_{0,i,j}) \\ge 0$，系统会使 $\\phi0$ 的点向距离函数性质演化。信息从界面流向正值区域。合适的上风梯度大小近似为：\n$$\nG = \\sqrt{\\max\\left(\\left[\\max(D_x^-\\phi,0)\\right]^2,\\left[\\min(D_x^+\\phi,0)\\right]^2\\right) + \\max\\left(\\left[\\max(D_y^-\\phi,0)\\right]^2,\\left[\\min(D_y^+\\phi,0)\\right]^2\\right)}\n$$\n相反，若 $\\operatorname{sign}_\\epsilon(\\phi_{0,i,j})  0$，信息从界面流向负值区域。上风方向相反：\n$$\nG = \\sqrt{\\max\\left(\\left[\\max(D_x^+\\phi,0)\\right]^2,\\left[\\min(D_x^-\\phi,0)\\right]^2\\right) + \\max\\left(\\left[\\max(D_y^+\\phi,0)\\right]^2,\\left[\\min(D_y^-,0)\\right]^2\\right)}\n$$\n零诺伊曼边界条件通过在网格周围填充一层额外的“幽灵”单元并从最近的内部单元复制数值来实现。\n\n初始条件设置为\n$$\n\\phi_0(x,y) = \\left[r(x,y) - R_0\\right] + \\beta \\left[r(x,y) - R_0\\right]^3\n$$\n其中 $r(x,y)$ 是距中心点 $(c_x, c_y)$ 的径向距离。该函数被专门设计成其零水平集是一个半径为 $R_0$ 的完美圆，但其梯度大小偏离 1，即对于 $r \\ne R_0$ 有 $\\lVert \\nabla \\phi_0 \\rVert \\ne 1$。这为重新初始化过程提供了一个非平凡的起始点。\n\n对于每个候选值 $c$ 的模拟，迭代进行直到最大残差 $R = \\max_{i,j}\\left|\\operatorname{sign}_\\epsilon(\\phi_0)(G-1)\\right|$ 小于容差 $\\mathrm{tol}$，或达到最大迭代次数。\n\n为了量化准确性，我们测量界面漂移。这涉及到定位最终收敛函数 $\\phi_{\\text{final}}$ 的零水平集。我们在 $[0, 2\\pi)$ 上采样 $K$ 个均匀间隔的角度 $\\theta_k$。对于每个角度，我们寻找函数 $f(r) = \\phi_{\\text{final}}(c_x + r\\cos\\theta_k, c_y + r\\sin\\theta_k)$ 的根。由于点 $(c_x + r\\cos\\theta_k, c_y + r\\sin\\theta_k)$ 可能不落在网格点上，因此使用双线性插值来评估 $\\phi_{\\text{final}}$ 在网格外的点上的值。然后采用二分法找到使 $f(r_k)=0$ 的半径 $r_k$。计算平均半径 $\\bar{R} = \\frac{1}{K}\\sum_k r_k$，漂移定义为绝对误差 $d = |\\bar{R} - R_0|$。\n\n最后一步是确定经验最优缩放因子 $c_{\\mathrm{emp}}$。对于每个测试用例，我们收集每个候选 $c$ 对应的漂移 $d$ 和迭代次数 $n$。最优的 $c$ 是使 $d$ 最小化的那个。平局则通过选择 $n$ 最小的来打破。如果仍然平局，则通过选择最接近理论最优值 $c_{\\mathrm{theory}}=1$ 的 $c$ 值来打破。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef run_reinitialization(phi_0, dx, dy, dt, tol, max_iter, epsilon):\n    \"\"\"\n    Performs the level-set reinitialization using a Godunov upwind scheme.\n    \"\"\"\n    phi = phi_0.copy()\n    sign_field = phi_0 / np.sqrt(phi_0**2 + epsilon**2)\n    \n    Nx, Ny = phi.shape\n    \n    num_iter = 0\n    for i in range(max_iter):\n        num_iter = i + 1\n        \n        # Apply zero-Neumann boundary conditions using ghost cells\n        phi_pad = np.pad(phi, 1, mode='edge')\n        \n        # Compute one-sided differences\n        Dx_p = (phi_pad[1:-1, 2:] - phi_pad[1:-1, 1:-1]) / dx\n        Dx_m = (phi_pad[1:-1, 1:-1] - phi_pad[1:-1, :-2]) / dx\n        Dy_p = (phi_pad[2:, 1:-1] - phi_pad[1:-1, 1:-1]) / dy\n        Dy_m = (phi_pad[1:-1, 1:-1] - phi_pad[:-2, 1:-1]) / dy\n\n        # Godunov Hamiltonian for sign >= 0\n        grad_norm_sq_pos = (\n            np.maximum(np.maximum(Dx_m, 0)**2, np.minimum(Dx_p, 0)**2) +\n            np.maximum(np.maximum(Dy_m, 0)**2, np.minimum(Dy_p, 0)**2)\n        )\n        \n        # Godunov Hamiltonian for sign  0\n        grad_norm_sq_neg = (\n            np.maximum(np.maximum(Dx_p, 0)**2, np.minimum(Dx_m, 0)**2) +\n            np.maximum(np.maximum(Dy_p, 0)**2, np.minimum(Dy_m, 0)**2)\n        )\n        \n        G_sq = np.where(sign_field >= 0, grad_norm_sq_pos, grad_norm_sq_neg)\n        # Avoid sqrt(0) issues at steady state points, although it should be fine\n        G_sq[G_sq  0] = 0\n        G = np.sqrt(G_sq)\n        \n        update = sign_field * (G - 1)\n        \n        residual = np.max(np.abs(update))\n        if residual = tol:\n            break\n            \n        phi -= dt * update\n        \n    return phi, num_iter\n\ndef calculate_drift(phi, dx, dy, cx, cy, R0, K):\n    \"\"\"\n    Calculates the interface drift by finding the average radius of the zero level set.\n    \"\"\"\n    Nx, Ny = phi.shape\n    L = Nx * dx \n    \n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    \n    # Create an interpolator for the phi field\n    # phi has shape (Nx, Ny), corresponding to points (x_coords, y_coords)\n    # The RegularGridInterpolator expects values with shape (len(x_coords), len(y_coords))\n    interpolator = RegularGridInterpolator((x_coords, y_coords), phi, \n                                           method='linear', bounds_error=False, fill_value=None)\n                                           \n    found_radii = []\n    angles = np.linspace(0, 2 * np.pi, K, endpoint=False)\n    \n    for theta in angles:\n        cos_theta, sin_theta = np.cos(theta), np.sin(theta)\n        \n        # Function whose root we want to find for radius r\n        def f(r):\n            pt_x = cx + r * cos_theta\n            pt_y = cy + r * sin_theta\n            # Interpolator takes a (N, 2) array of points\n            val = interpolator(np.array([pt_x, pt_y]))\n            return val[0]\n        \n        # Bisection method to find the root\n        # A robust bracket for this problem geometry\n        r_low, r_high = 0.1 * R0, 3.0 * R0\n\n        val_low = f(r_low)\n        val_high = f(r_high)\n        \n        # Check if the bracket is valid\n        if val_low is None or val_high is None or val_low * val_high >= 0:\n            continue\n        \n        # 30 iterations give high precision, more than needed\n        for _ in range(30):\n            r_mid = (r_low + r_high) / 2.0\n            val_mid = f(r_mid)\n            if val_mid is None: # handle cases where mid-point is out of bounds\n                r_high = r_mid\n                continue\n            if val_low * val_mid  0:\n                r_high = r_mid\n            else:\n                r_low = r_mid\n                val_low = val_mid\n        \n        found_radii.append((r_low + r_high) / 2.0)\n    \n    if not found_radii:\n        return np.inf # Return a large drift if no roots found\n\n    avg_R = np.mean(found_radii)\n    drift = np.abs(avg_R - R0)\n    return drift\n\ndef run_experiment(case_params):\n    \"\"\"\n    Runs the full numerical experiment for a single test case.\n    \"\"\"\n    Nx, Ny, R0, cx, cy, beta, dt_factor, tol, max_iter, c_candidates, K = case_params\n    \n    L = 1.0\n    dx = L / Nx\n    dy = L / Ny\n    dt = dt_factor * dx\n    c_theory = 1.0\n\n    # Create grid and initial condition phi_0\n    i = np.arange(Nx)\n    j = np.arange(Ny)\n    x = (i[:, np.newaxis] + 0.5) * dx\n    y = (j[np.newaxis, :] + 0.5) * dy\n    \n    r = np.sqrt((x - cx)**2 + (y - cy)**2)\n    phi_0 = (r - R0) + beta * (r - R0)**3\n    \n    results = []\n    for c_val in c_candidates:\n        epsilon = c_val * dx\n        \n        phi_final, iters = run_reinitialization(phi_0, dx, dy, dt, tol, max_iter, epsilon)\n        \n        drift = calculate_drift(phi_final, dx, dy, cx, cy, R0, K)\n        \n        results.append({'c': c_val, 'drift': drift, 'iters': iters})\n    \n    # Find the optimal c based on the criteria\n    # 1. Minimize drift\n    # 2. Minimize iterations (tie-breaker)\n    # 3. Closest to c_theory (tie-breaker)\n    results.sort(key=lambda res: (res['drift'], res['iters'], abs(res['c'] - c_theory)))\n    \n    best_result = results[0]\n    c_emp = best_result['c']\n    final_drift = best_result['drift']\n    final_iters = best_result['iters']\n\n    return [c_emp, final_drift, final_iters, c_theory]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, R0, cx, cy, beta, dt_factor, tol, max_iter, C_set, K)\n        (64, 64, 0.28, 0.47, 0.52, 0.2, 0.3, 1e-3, 200, [0.5, 1.0, 2.0, 3.0], 48),\n        (96, 96, 0.28, 0.47, 0.52, 0.2, 0.3, 1e-3, 250, [0.5, 1.0, 2.0, 3.0], 64),\n        (128, 128, 0.28, 0.47, 0.52, 0.2, 0.3, 8e-4, 300, [0.5, 1.0, 2.0, 3.0], 72),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_experiment(case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    results_str_list = []\n    for res in all_results:\n        # Format each sub-list: e.g., '[1.0,0.00123,150,1.0]'\n        c_emp, d, n, c_theory = res\n        s = f\"[{c_emp},{d},{n},{c_theory}]\"\n        results_str_list.append(s)\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3415541"}, {"introduction": "法向量和曲率等几何量的计算精度是水平集方法的核心，而这在很大程度上取决于离散导数计算的质量。标准的有限差分格式在各向异性网格（即坐标轴方向的网格间距不同）上可能表现不佳。本练习 ([@problem_id:3415549]) 将量化由网格各向异性引入的误差，并引导您实现一种更稳健的局部二次最小二乘拟合方法，这是一种在实际工程应用中提高水平集模拟保真度的宝贵技术。", "problem": "考虑一个二维水平集函数 $\\phi(x,y)$，它表示到一个光滑闭合界面 $\\Gamma$ 的符号距离。对于一个精确的符号距离函数，程函(Eikonal)属性成立，即在 $\\Gamma$ 的一个邻域内 $\\lvert \\nabla \\phi \\rvert = 1$。$\\phi$ 的任意水平集的曲率由单位法向量的散度定义，即 $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / \\lvert \\nabla \\phi \\rvert \\right)$。这些是在水平集重新初始化中使用的基本定义，该过程在一个虚拟时间上演化 $\\phi$ 以恢复界面附近的程函属性，同时保持零水平集不变。\n\n在本问题中，你将量化网格各向异性对倾斜界面附近 $\\lvert \\nabla \\phi \\rvert$ 和曲率的离散精度的影响，并通过局部二次最小二乘拟合使用旋转模板来实现一种修正方法。该界面被设为以 $(x_0, y_0)$ 为中心、半径为 $R$ 的圆，因此符号距离函数为\n$$\n\\phi(x,y) = \\sqrt{(x - x_0)^2 + (y - y_0)^2} - R,\n$$\n其精确的 $\\lvert \\nabla \\phi \\rvert$ 处处为 $1$，且通过 $(x,y)$ 的水平集的曲率等于\n$$\n\\kappa_{\\text{true}}(x,y) = \\frac{1}{R + \\phi(x,y)}.\n$$\n计算域为正方形 $[-\\tfrac{1}{2},\\tfrac{1}{2}] \\times [-\\tfrac{1}{2},\\tfrac{1}{2}]$。你将在均匀但可能各向异性的网格上工作，该网格在 $x$ 方向有 $N_x$ 个节点，在 $y$ 方向有 $N_y$ 个节点。网格间距分别为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。\n\n你必须计算界面附近（一个窄带内）$\\lvert \\nabla \\phi \\rvert$ 和 $\\kappa$ 的两种离散近似，并评估它们相对于精确值的均方根 (RMS) 误差：\n\n1. 基准轴对齐中心差分：\n   - 使用二阶中心差分计算一阶导数，\n     $$\n     \\phi_x \\approx \\frac{\\phi_{i+1,j}-\\phi_{i-1,j}}{2h_x}, \\quad \\phi_y \\approx \\frac{\\phi_{i,j+1}-\\phi_{i,j-1}}{2h_y}.\n     $$\n   - 使用二阶中心差分计算二阶导数，\n     $$\n     \\phi_{xx} \\approx \\frac{\\phi_{i+1,j}-2\\phi_{i,j}+\\phi_{i-1,j}}{h_x^2}, \\quad \\phi_{yy} \\approx \\frac{\\phi_{i,j+1}-2\\phi_{i,j}+\\phi_{i,j-1}}{h_y^2},\n     $$\n     $$\n     \\phi_{xy} \\approx \\frac{\\phi_{i+1,j+1}-\\phi_{i+1,j-1}-\\phi_{i-1,j+1}+\\phi_{i-1,j-1}}{4 h_x h_y}.\n     $$\n   - 计算\n     $$\n     \\lvert \\nabla \\phi \\rvert \\approx \\sqrt{\\phi_x^2 + \\phi_y^2}\n     $$\n     并通过标准公式计算曲率\n     $$\n     \\kappa \\approx \\frac{\\phi_{xx}\\,\\phi_y^2 - 2\\,\\phi_x\\,\\phi_y\\,\\phi_{xy} + \\phi_{yy}\\,\\phi_x^2}{\\left(\\phi_x^2+\\phi_y^2\\right)^{3/2}}.\n     $$\n\n2. 旋转模板二次最小二乘法（修正方法）：\n   - 在每个内部网格点上，使用 $3\\times 3$ 邻域（即偏移量 $\\{(-h_x,0,h_x)\\} \\times \\{(-h_y,0,h_y)\\}$），在以该网格点为中心的局部物理坐标中拟合一个二次多项式\n     $$\n     p(x,y)=a_0 + a_1 x + a_2 y + a_3 x^2 + a_4 x y + a_5 y^2\n     $$\n     。使用所有 $9$ 个点通过最小二乘法求解 $(a_0,\\dots,a_5)$。然后在中心点，近似\n     $$\n     \\phi_x \\approx a_1, \\quad \\phi_y \\approx a_2, \\quad \\phi_{xx} \\approx 2a_3, \\quad \\phi_{xy} \\approx a_4, \\quad \\phi_{yy} \\approx 2a_5,\n     $$\n     并如上所述计算 $\\lvert \\nabla \\phi \\rvert$ 和 $\\kappa$。这种 $3\\times 3$ 旋转模板利用了对角方向的信息，从而缓解了网格各向异性。\n\n评估区域与误差：\n- 将评估限制在内部带 $\\{(i,j): \\lvert \\phi_{i,j} \\rvert \\le 2\\max(h_x,h_y)\\}$ 内，以便只考虑靠近界面的点，并确保所有必需的 $3\\times 3$ 模板都位于内部。\n- 对于每种方法，计算带内所有点上 $\\lvert \\nabla \\phi \\rvert$ 相对于精确值 $1$ 的 RMS 误差，以及 $\\kappa$ 相对于 $\\kappa_{\\text{true}}(x,y)=1/(R+\\phi(x,y))$ 的 RMS 误差。\n\n你的程序必须实现这两种离散化方法，测量误差，并报告 $\\lvert \\nabla \\phi \\rvert$ 和 $\\kappa$ 的改进比（基准误差除以旋转模板误差）。大于 $1$ 的值表示旋转模板带来了改进。\n\n所有测试均使用以下固定的问题参数：\n- 圆半径 $R = 0.35$，中心 $(x_0,y_0) = (0.17,-0.11)$。\n- 计算域 $[-\\tfrac{1}{2},\\tfrac{1}{2}] \\times [-\\tfrac{1}{2},\\tfrac{1}{2}]$。\n\n测试套件（每个测试用例指定 $(N_x,N_y)$；网格间距为 $h_x=1/(N_x-1)$，$h_y=1/(N_y-1)$）：\n- 案例 A（各向同性理想路径）：$(N_x,N_y) = (201,201)$。\n- 案例 B（中等各向异性）：$(N_x,N_y) = (401,201)$。\n- 案例 C（强各向异性）：$(N_x,N_y) = (801,101)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含六个改进比，形式为方括号括起来的逗号分隔列表，顺序为\n$$\n[\\ \\rho_{\\lvert \\nabla \\phi \\rvert}^{(A)},\\ \\rho_{\\kappa}^{(A)},\\ \\rho_{\\lvert \\nabla \\phi \\rvert}^{(B)},\\ \\rho_{\\kappa}^{(B)},\\ \\rho_{\\lvert \\nabla \\phi \\rvert}^{(C)},\\ \\rho_{\\kappa}^{(C)}\\ ],\n$$\n其中 $\\rho_{\\lvert \\nabla \\phi \\rvert}^{(\\cdot)}$ 是 $\\lvert \\nabla \\phi \\rvert$ 的基准 RMS 误差除以旋转模板的 RMS 误差，而 $\\rho_{\\kappa}^{(\\cdot)}$ 是 $\\kappa$ 的基准 RMS 误差除以旋转模板的 RMS 误差，每个都在指定的点带上计算。所有量都是无量纲实数，你应该将它们打印为没有任何附加文本的普通十进制浮点数。", "solution": "用户要求比较两种从水平集函数计算几何量的数值方法，特别关注网格各向异性的影响。该问题是适定的且在科学上是合理的，为数值实验提供了清晰的基础。\n\n### **问题验证**\n\n**1. 已知条件提取：**\n- **水平集函数**：$\\phi(x,y) = \\sqrt{(x - x_0)^2 + (y - y_0)^2} - R$，表示到圆的符号距离。\n- **参数**：半径 $R = 0.35$，中心 $(x_0, y_0) = (0.17, -0.11)$。\n- **计算域和网格**：正方形 $[-\\tfrac{1}{2},\\tfrac{1}{2}] \\times [-\\tfrac{1}{2},\\tfrac{1}{2}]$ 由一个 $N_x \\times N_y$ 个节点的均匀网格离散化，网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。\n- **精确量**：梯度模长 $\\lvert \\nabla \\phi \\rvert = 1$ 和曲率 $\\kappa_{\\text{true}}(x,y) = 1/(R + \\phi(x,y))$。\n- **方法1（基准）**：对所有一阶和二阶偏导数（$\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{yy}, \\phi_{xy}$）使用二阶中心差分。\n- **方法2（修正）**：在 $3 \\times 3$ 模板上进行局部二次最小二乘拟合，以找到多项式 $p(x,y)=a_0 + a_1 x + a_2 y + a_3 x^2 + a_4 x y + a_5 y^2$ 的系数，并由此近似导数（例如，$\\phi_x \\approx a_1$, $\\phi_{xx} \\approx 2a_3$）。\n- **评估区域**：点 $(i,j)$ 所在的一个内部带，其中 $|\\phi_{i,j}| \\le 2\\max(h_x, h_y)$ 且 $3 \\times 3$ 模板完全在网格边界内。\n- **误差度量**：计算出的 $\\lvert \\nabla \\phi \\rvert$ 相对于 $1$ 的均方根（RMS）误差，以及计算出的 $\\kappa$ 相对于 $\\kappa_{\\text{true}}$ 的均方根（RMS）误差。\n- **输出**：基准方法的 RMS 误差与修正方法的 RMS 误差之比，分别针对 $\\lvert \\nabla \\phi \\rvert$ 和 $\\kappa$。\n- **测试用例**：(A) $(N_x, N_y) = (201, 201)$，(B) $(N_x, N_y) = (401, 201)$，(C) $(N_x, N_y) = (801, 101)$。\n\n**2. 验证：**\n- **科学依据**：该问题牢固地植根于偏微分方程数值分析的成熟领域，特别是水平集方法。所有公式和概念（程函属性、曲率、有限差分、最小二乘拟合）都是标准且正确的。\n- **适定性**：问题定义清晰。给定输入，所需的计算将导出一组唯一的输出值。$3 \\times 3$ 模板上的最小二乘问题是非奇异的，并且有唯一解。\n- **完整性与一致性**：提供了所有必要的参数、方程和评估标准。设置是自洽的，没有矛盾。圆不完全在域内的约束不会妨碍指定的计算。\n- **客观性**：问题以精确、客观的数学语言陈述。\n\n**3. 结论：**\n问题有效。我们将继续进行求解。\n\n### **基于原理的求解设计**\n\n这个问题的核心是展示并修正标准有限差分格式在各向异性网格上的一个已知缺陷。一个相对于网格轴倾斜的界面（如 $\\phi$ 的零水平集）对那些本身与坐标轴对齐的导数近似方法构成了挑战。当每个方向的网格间距不同（各向异性）时，这个问题会更加严重，即网格具有高纵横比（例如，$h_y \\gg h_x$）。\n\n**1. 基准方法：轴对齐中心差分**\n我们首先实现一个标准的基准方法，使用二阶中心差分。对于在网格上采样的函数 $f$，点 $(i,j)$ 处的导数使用其沿网格线的直接邻点来近似：\n- 一阶导数（$\\phi_x$, $\\phi_y$）沿 $x$ 轴或 $y$ 轴使用一个 $3$ 点模板。\n- 二阶导数（$\\phi_{xx}$, $\\phi_{yy}$）也使用这个 $3$ 点模板。\n- 混合导数（$\\phi_{xy}$）使用 $3 \\times 3$ 单元格的 $4$ 个角点。\n这些方法的截断误差取决于网格间距 $h_x$ 和 $h_y$。当网格具有高纵横比时（例如，$h_y \\gg h_x$），涉及较粗方向的导数精度会显著下降，特别是对于未与网格对齐的特征。这会污染坐标无关量（如 $\\lvert \\nabla \\phi \\rvert$ 和 $\\kappa$）的计算。\n\n**2. 修正方法：旋转模板二次最小二乘法**\n为了减轻网格引起的误差，我们使用一种对网格方向不太敏感的方法。我们不是为每个导数使用独立的、轴对齐的模板，而是在目标点周围的 $3 \\times 3$（共 $9$ 个）数据点块上拟合一个单一的、通用的二次曲面。多项式为 $p(\\Delta x, \\Delta y) = a_0 + a_1 \\Delta x + a_2 \\Delta y + a_3 (\\Delta x)^2 + a_4 (\\Delta x)(\\Delta y) + a_5 (\\Delta y)^2$，其中 $(\\Delta x, \\Delta y)$ 是相对于模板中心的局部物理坐标。\n\n这是一个线性最小二乘问题。对于以 $(x_i, y_j)$ 为中心的每个模板，我们有 $9$ 个数据点 $(\\Delta x_k, \\Delta y_k, \\phi_k)$，其中 $k$ 索引模板中的点。我们在最小二乘意义上求解系统 $A \\mathbf{a} = \\mathbf{b}$ 以获得系数向量 $\\mathbf{a} = [a_0, \\dots, a_5]^T$。设计矩阵 $A$ 是一个 $9 \\times 6$ 的矩阵，其行是 $[1, \\Delta x_k, \\Delta y_k, (\\Delta x_k)^2, \\dots]$，而 $\\mathbf{b}$ 是 $9$ 个对应 $\\phi$ 值的向量。解由 $\\mathbf{a} = (A^T A)^{-1} A^T \\mathbf{b}$ 给出。\n\n一旦找到系数，$\\phi$ 在中心点的偏导数就通过拟合多项式 $p$ 在 $(\\Delta x, \\Delta y)=(0,0)$ 处的导数来近似：\n- $\\phi_x \\approx \\partial p/\\partial (\\Delta x) |_{(0,0)} = a_1$\n- $\\phi_y \\approx \\partial p/\\partial (\\Delta y) |_{(0,0)} = a_2$\n- $\\phi_{xx} \\approx \\partial^2 p/\\partial (\\Delta x)^2 |_{(0,0)} = 2a_3$\n- $\\phi_{xy} \\approx \\partial^2 p/\\partial (\\Delta x)\\partial (\\Delta y) |_{(0,0)} = a_4$\n- $\\phi_{yy} \\approx \\partial^2 p/\\partial (\\Delta y)^2 |_{(0,0)} = 2a_5$\n\n这种方法内在地使用所有 $9$ 个模板点（包括对角线上的点）的信息来计算所有导数。这使得近似对网格各向异性更具鲁棒性，因为拟合可以捕捉局部几何形状，而不管其相对于网格轴的方向如何。\n\n**3. 通过二维相关实现**\n最小二乘拟合过程可以高效实现。从 $9$ 个 $\\phi$ 值中找到系数 $\\mathbf{a}$ 的操作是线性的。这意味着每个导数近似（例如 $\\phi_x \\approx a_1$）都是模板中 $9$ 个 $\\phi$ 值的固定线性组合。这正是一个二维离散相关运算。我们可以为每个偏导数预先计算 $3 \\times 3$ 的相关核，并使用像 `scipy.signal.correlate2d` 这样的函数将其应用于整个 `phi_grid`。这将计算向量化，避免了在 Python 中进行缓慢的逐点循环。\n\n**4. 误差分析**\n最后，对于每个测试用例，我们在指定的界面附近评估带上计算两种方法的 RMS 误差。改进比定义为 $\\rho = \\text{Error}_{\\text{baseline}} / \\text{Error}_{\\text{remedy}}$，它量化了最小二乘法的有效性。比率 $\\rho  1$ 表示有改进。我们预计随着网格各向异性变得更严重，这个比率会显著增加。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import correlate2d\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    \n    def solve_case(Nx, Ny):\n        \"\"\"\n        Computes the improvement ratios for a single grid configuration (Nx, Ny).\n\n        Args:\n            Nx (int): Number of grid points in the x-direction.\n            Ny (int): Number of grid points in the y-direction.\n\n        Returns:\n            tuple: A tuple containing the improvement ratios for the gradient magnitude\n                   and curvature, respectively.\n        \"\"\"\n        # Fixed parameters from the problem statement\n        R = 0.35\n        x0, y0 = 0.17, -0.11\n        domain_size = 1.0\n\n        # Grid setup\n        hx = domain_size / (Nx - 1)\n        hy = domain_size / (Ny - 1)\n        x = np.linspace(-0.5, 0.5, Nx)\n        y = np.linspace(-0.5, 0.5, Ny)\n        # 'xy' indexing ensures grid[j, i] corresponds to (x_i, y_j)\n        X, Y = np.meshgrid(x, y, indexing='xy')\n\n        # Analytical level-set field\n        phi_grid = np.sqrt((X - x0)**2 + (Y - y0)**2) - R\n\n        # Define the evaluation band\n        h_max = max(hx, hy)\n        # The evaluation is restricted to interior points where a 3x3 stencil is valid.\n        interior_mask = np.zeros_like(phi_grid, dtype=bool)\n        interior_mask[1:-1, 1:-1] = True\n        band_mask = np.abs(phi_grid) = 2 * h_max\n        evaluation_mask = interior_mask  band_mask\n\n        # Sliced mask for arrays defined only on the interior grid\n        eval_mask_interior = evaluation_mask[1:-1, 1:-1]\n        \n        if np.sum(eval_mask_interior) == 0:\n            return np.nan, np.nan\n\n        # Exact quantities for the points in the evaluation band\n        phi_eval = phi_grid[evaluation_mask]\n        kappa_true = 1.0 / (R + phi_eval)\n\n        # --- Method 1: Baseline (Central Differences) ---\n        # Derivatives computed on the (Ny-2, Nx-2) interior grid\n        phi_y_cd = (phi_grid[2:, 1:-1] - phi_grid[:-2, 1:-1]) / (2 * hy)\n        phi_x_cd = (phi_grid[1:-1, 2:] - phi_grid[1:-1, :-2]) / (2 * hx)\n        \n        grad_mag_sq_cd = phi_x_cd**2 + phi_y_cd**2\n        grad_mag_cd = np.sqrt(grad_mag_sq_cd)\n\n        phi_xx_cd = (phi_grid[1:-1, 2:] - 2 * phi_grid[1:-1, 1:-1] + phi_grid[1:-1, :-2]) / (hx**2)\n        phi_yy_cd = (phi_grid[2:, 1:-1] - 2 * phi_grid[1:-1, 1:-1] + phi_grid[:-2, 1:-1]) / (hy**2)\n        phi_xy_cd = (phi_grid[2:, 2:] - phi_grid[2:, :-2] - phi_grid[:-2, 2:] + phi_grid[:-2, :-2]) / (4 * hx * hy)\n        \n        num_kappa_cd = phi_xx_cd * phi_y_cd**2 - 2 * phi_x_cd * phi_y_cd * phi_xy_cd + phi_yy_cd * phi_x_cd**2\n        den_kappa_cd = np.maximum(grad_mag_sq_cd**1.5, 1e-12)\n        kappa_cd = num_kappa_cd / den_kappa_cd\n\n        grad_mag_cd_eval = grad_mag_cd[eval_mask_interior]\n        kappa_cd_eval = kappa_cd[eval_mask_interior]\n\n        err_grad_cd = np.sqrt(np.mean((grad_mag_cd_eval - 1.0)**2))\n        err_kappa_cd = np.sqrt(np.mean((kappa_cd_eval - kappa_true)**2))\n\n        # --- Method 2: Rotated-stencil Quadratic Least-Squares ---\n        # Build the 9x6 design matrix A for the 3x3 stencil\n        dx_vals = np.array([-hx, 0, hx] * 3)\n        dy_vals = np.array(np.repeat([-hy, 0, hy], 3))\n\n        A = np.stack([\n            np.ones(9), dx_vals, dy_vals,\n            dx_vals**2, dx_vals * dy_vals, dy_vals**2\n        ], axis=1)\n\n        # The operator M_lsq maps 9 stencil values to 6 polynomial coefficients\n        # M_lsq = (A.T @ A)^-1 @ A.T\n        M_lsq = np.linalg.pinv(A)\n\n        # Create 3x3 correlation kernels for each derivative\n        ker_phix = M_lsq[1, :].reshape(3, 3)\n        ker_phiy = M_lsq[2, :].reshape(3, 3)\n        ker_phixx = 2 * M_lsq[3, :].reshape(3, 3)\n        ker_phixy = M_lsq[4, :].reshape(3, 3)\n        ker_phiyy = 2 * M_lsq[5, :].reshape(3, 3)\n    \n        # Compute derivatives using 2D correlation (mode='valid' returns interior grid)\n        phi_x_lsq = correlate2d(phi_grid, ker_phix, mode='valid')\n        phi_y_lsq = correlate2d(phi_grid, ker_phiy, mode='valid')\n        phi_xx_lsq = correlate2d(phi_grid, ker_phixx, mode='valid')\n        phi_xy_lsq = correlate2d(phi_grid, ker_phixy, mode='valid')\n        phi_yy_lsq = correlate2d(phi_grid, ker_phiyy, mode='valid')\n        \n        grad_mag_sq_lsq = phi_x_lsq**2 + phi_y_lsq**2\n        grad_mag_lsq = np.sqrt(grad_mag_sq_lsq)\n\n        num_kappa_lsq = phi_xx_lsq * phi_y_lsq**2 - 2 * phi_x_lsq * phi_y_lsq * phi_xy_lsq + phi_yy_lsq * phi_x_lsq**2\n        den_kappa_lsq = np.maximum(grad_mag_sq_lsq**1.5, 1e-12)\n        kappa_lsq = num_kappa_lsq / den_kappa_lsq\n\n        grad_mag_lsq_eval = grad_mag_lsq[eval_mask_interior]\n        kappa_lsq_eval = kappa_lsq[eval_mask_interior]\n\n        err_grad_lsq = np.sqrt(np.mean((grad_mag_lsq_eval - 1.0)**2))\n        err_kappa_lsq = np.sqrt(np.mean((kappa_lsq_eval - kappa_true)**2))\n        \n        # Improvement ratios\n        ratio_grad = err_grad_cd / err_grad_lsq if err_grad_lsq > 0 else np.inf\n        ratio_kappa = err_kappa_cd / err_kappa_lsq if err_kappa_lsq > 0 else np.inf\n\n        return ratio_grad, ratio_kappa\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (201, 201), # Case A (isotropic)\n        (401, 201), # Case B (moderate anisotropy)\n        (801, 101), # Case C (strong anisotropy)\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case\n        ratio_grad, ratio_kappa = solve_case(Nx, Ny)\n        results.append(ratio_grad)\n        results.append(ratio_kappa)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3415549"}]}