{"hands_on_practices": [{"introduction": "快速泊松求解器的核心在于利用快速傅里叶变换（FFT）算法来对离散拉普拉斯算子进行对角化。本实践将指导你为具有齐次狄利克雷边界条件的泊松方程构建一个基于离散正弦变换（DST-I）的求解器。通过从第一性原理推导特征值，并分析一个与奇偶性相关的微妙索引错误，你将深入理解该方法的数值基础，并学会设计必要的回归测试来确保求解器的准确性 ([@problem_id:3391502])。", "problem": "考虑在矩形域上的带有齐次边界条件的狄利克雷泊松问题，该问题在均匀张量积网格上使用二阶中心差分进行离散化。设连续问题定义在开放单位正方形上，离散算子为标准的$5$-点拉普拉斯算子，在$x$和$y$方向上分别有$n_x$和$n_y$个内部未知数。记$h_x = 1/(n_x+1)$和$h_y = 1/(n_y+1)$，离散网格点为$x_i = i h_x$和$y_j = j h_y$，其中$i = 1,\\dots,n_x$，$j=1,\\dots,n_y$。已知每个坐标方向上的离散狄利克雷特征向量是正弦函数，相应的特征值是网格间距和离散模态指数的函数。矩形域上的快速泊松求解器沿每个轴使用I型离散正弦变换（DST-I）来对角化离散拉普拉斯算子，并在变换空间中求解，时间复杂度为$\\mathcal{O}(n_x n_y \\log(n_x n_y))$。\n\n您的任务是分析、推导、实现和测试在DST-I特征值公式中一个与奇偶性相关的微妙索引错误（在角度归一化中使用$n$而非$n+1$）如何在$n$为偶数与奇数时对精度产生不同程度的降低。您必须从有限差分离散化和正弦变换对角化的第一性原理出发，不假设任何闭式谱公式；在需要时进行推导。\n\n起点（基本基础）：\n- 连续问题为$-\\Delta u = f$，在开放单位正方形上具有齐次狄利克雷边界条件。\n- 在$1$维情况下，作用于内部点$\\{x_i\\}$的$-u''$的二阶中心差分模板为$(2 u_i - u_{i-1} - u_{i+1})/h^2$，其中$u_0 = u_{n+1} = 0$。\n- $2$维离散拉普拉斯算子是$x$和$y$方向上$1$维算子的克罗内克和。\n- DST-I对角化了均匀网格上的$1$维狄利克雷算子。\n\n您必须：\n- 从有限差分算子和正弦基出发，推导出$1$维中的正确特征对以及在变换空间中导出的$2$维分离。清楚地指明带有标准正交归一化的DST-I如何对角化该算子并产生每个模态的标量求解。\n- 定义一个特征值错位变体，其中$x$方向的角度归一化错误地使用$n_x$代替$n_x+1$来计算模态角度，而$y$方向保持正确。解释为什么在编写基于DST的求解器时，这是一个貌似合理的实现陷阱。\n- 使用带有标准正交归一化的DST-I实现两个快速泊松求解器：$1$) 一个正确的求解器，在两个方向上都使用正确推导的特征值；$2$) 一个错位的求解器，使用上述错误的$x$方向角度归一化，同时保持$h_x$和$h_y$由$n_x+1$和$n_y+1$定义。\n- 使用这些求解器在内部网格上为制造数据求解离散泊松方程。对于制造解，使用$u(x,y) = \\sin(\\pi x)\\sin(2\\pi y)$并解析计算$f(x,y) = -\\Delta u(x,y)$。在内部网格点上计算$f$和精确解$u$的值。测量最大范数误差$e_{\\infty} = \\max_{i,j} |u_{i,j}^{\\text{num}} - u(x_i,y_j)|$。\n\n设计一个揭示奇偶效应的测试套件：\n- 情况A（理想情况，正确求解器）：$(n_x,n_y) = (31,31)$和$(n_x,n_y) = (32,32)$，计算正确求解器的$e_{\\infty}$。\n- 情况B（奇偶性敏感度，错位求解器）：$(n_x,n_y) = (31,31)$和$(n_x,n_y) = (32,32)$，计算错位求解器的$e_{\\infty}$。\n- 情况C（定向谱回归探针）：对于$(n_x,n_y) = (32,32)$，模态指数为$(k,\\ell) = (n_x/2,1)$；以及对于$(n_x,n_y) = (31,31)$，模态指数为$(k,\\ell) = ((n_x-1)/2,1)$，构造一个在变换空间中为单个标准正交DST-I基向量的强迫项，并比较正确求解器和错位求解器返回的标量模态振幅。报告每种奇偶性下的相对振幅差异，其定义为一个无量纲浮点数\n$$\n\\varepsilon_{\\text{rel}} = \\left|\\frac{1}{\\lambda^{\\text{bug}}_{x}(k)+\\lambda_{y}(\\ell)} - \\frac{1}{\\lambda_{x}(k)+\\lambda_{y}(\\ell)}\\right| \\bigg/ \\left|\\frac{1}{\\lambda_{x}(k)+\\lambda_{y}(\\ell)}\\right|.\n$$\n这将分离出在$n_x$为偶数时，特征值错位对一个最敏感的特定模态的影响。\n- 此外，提供错位制造解在偶数尺寸与奇数尺寸下的误差之比，即$e_{\\infty}^{\\text{bug}}(32,32) / e_{\\infty}^{\\text{bug}}(31,31)$，以量化平滑强迫项上的任何奇偶性偏差。\n- 最后，计算一个布尔回归指示器，当且仅当偶数情况下的定向谱差异至少是奇数情况下差异的$5$倍时，该指示器为真。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[e_{\\infty}^{\\text{corr}}(31,31), e_{\\infty}^{\\text{corr}}(32,32), e_{\\infty}^{\\text{bug}}(31,31), e_{\\infty}^{\\text{bug}}(32,32), e_{\\infty}^{\\text{bug}}(32,32)/e_{\\infty}^{\\text{bug}}(31,31), \\varepsilon_{\\text{rel}}^{\\text{even}}, \\varepsilon_{\\text{rel}}^{\\text{odd}}, \\text{flag}]$，\n其中`flag`是上述布尔回归指示器。所有量均为无量纲。无需报告任何角度；所有三角函数均以弧度计算。输出必须是严格的单行，包含按指定顺序排列的列表，不得有任何额外文本。前七个条目应为浮点数类型，最后一个条目应为布尔类型。", "solution": "用户提供的问题经评估有效。该问题在科学上是合理的，适定的，客观的，并且是完全指定的。问题描述了一个标准的数值分析任务，涉及使用谱方法（离散正弦变换）求解泊松方程，并要求对一个特定的、貌似合理的实现错误进行定量分析。所有组成部分都基于数值偏微分方程的既定原理。因此，我们可以进行推导和求解。\n\n问题的核心是理解离散泊松算子如何通过离散正弦变换（DST）对角化，以及由此产生的特征值误差如何影响解的精度。\n\n**1. 1维离散拉普拉斯算子及其特征分解**\n\n考虑在区间 $(0, 1)$ 上的一维边值问题 $-\\frac{d^2u}{dx^2} = f(x)$，其齐次狄利克雷边界条件为 $u(0) = u(1) = 0$。我们在一个均匀网格上对其进行离散化，该网格有 $n$ 个内部点 $x_i = i h$（$i=1, \\dots, n$），网格间距为 $h = 1/(n+1)$。边界点为 $x_0 = 0$ 和 $x_{n+1} = 1$。\n\n在内部点 $x_i$ 处使用二阶中心有限差分来近似二阶导数，算子 $-\\frac{d^2}{dx^2}$ 可近似为\n$$ (-\\nabla_h^2 u)_i = \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} $$\n其中 $u_i \\approx u(x_i)$。边界条件意味着 $u_0 = 0$ 和 $u_{n+1} = 0$。这种离散化产生一个线性系统 $A_n \\mathbf{u} = \\mathbf{f}$，其中 $\\mathbf{u} = [u_1, \\dots, u_n]^T$，而 $n \\times n$ 矩阵 $A_n$ 是对称三对角托普利兹矩阵：\n$$ A_n = \\frac{1}{h^2} \\begin{pmatrix} 2  -1   \\\\ -1  2  -1  \\\\  \\ddots  \\ddots  \\ddots \\\\   -1  2  -1 \\\\    -1  2 \\end{pmatrix} $$\n$A_n$ 的特征向量已知为离散正弦向量。我们来验证这一点并找出相应的特征值。我们假设一个特征向量 $\\mathbf{v}_k$，其分量为 $(v_k)_i = \\sin\\left(\\frac{ik\\pi}{n+1}\\right)$，其中 $i=1, \\dots, n$，模态指数 $k=1, \\dots, n$。将 $h^2 A_n$ 的第 $i$ 行作用于 $\\mathbf{v}_k$ 可得：\n$$ (h^2 A_n \\mathbf{v}_k)_i = 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right) - \\sin\\left(\\frac{(i-1)k\\pi}{n+1}\\right) - \\sin\\left(\\frac{(i+1)k\\pi}{n+1}\\right) $$\n使用三角恒等式 $\\sin(\\alpha-\\beta) + \\sin(\\alpha+\\beta) = 2\\sin(\\alpha)\\cos(\\beta)$，我们可以简化第二项和第三项的和：\n$$ \\sin\\left(\\frac{ik\\pi}{n+1} - \\frac{k\\pi}{n+1}\\right) + \\sin\\left(\\frac{ik\\pi}{n+1} + \\frac{k\\pi}{n+1}\\right) = 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right) $$\n将其代回，我们得到：\n$$ (h^2 A_n \\mathbf{v}_k)_i = 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right) - 2\\sin\\left(\\frac{ik\\pi}{n+1}\\right)\\cos\\left(\\frac{k\\pi}{n+1}\\right) = 2\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)\\sin\\left(\\frac{ik\\pi}{n+1}\\right) $$\n使用半角恒等式 $1-\\cos(\\theta) = 2\\sin^2(\\theta/2)$，上式变为：\n$$ (h^2 A_n \\mathbf{v}_k)_i = 4\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)\\sin\\left(\\frac{ik\\pi}{n+1}\\right) = \\left( 4\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) \\right) (v_k)_i $$\n因此，$\\mathbf{v}_k$ 确实是 $A_n$ 的一个特征向量，其对应的特征值为：\n$$ \\lambda_k = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) $$\n向量集合 $\\{\\mathbf{v}_k\\}_{k=1}^n$ 构成一个正交基。将一个向量从标准基变换到这个特征基的过程就是I型离散正弦变换（DST-I）。\n\n**2. 2维问题与变量分离**\n\n在单位正方形 $(0,1) \\times (0,1)$ 上具有齐次狄利克雷边界条件的连续问题 $-\\Delta u = f$ 在一个 $n_x \\times n_y$ 的内部点网格上进行离散化。作用于网格函数 $U$（一个 $n_y \\times n_x$ 的未知数矩阵）的离散拉普拉斯算子 $A$ 可以用克罗内克积来表示。如果我们将 $U$ 堆叠成一个长度为 $n_x n_y$ 的向量，则矩阵 $A$ 由克罗内克和给出：\n$$ A = I_{n_y} \\otimes A_{n_x} + A_{n_y} \\otimes I_{n_x} $$\n其中 $A_{n_x}$ 和 $A_{n_y}$ 分别是 $x$ 和 $y$ 方向上的1维离散拉普拉斯算子，$I$ 是单位矩阵。\n\n克罗内克和的特征向量是其构成矩阵特征向量的克罗内克积。用2维网格函数表示，$A$ 的特征向量是1维正弦特征向量的外积：\n$$ E_{k,\\ell}(i,j) = (v_k^x)_i (v_\\ell^y)_j = \\sin\\left(\\frac{ik\\pi}{n_x+1}\\right) \\sin\\left(\\frac{j\\ell\\pi}{n_y+1}\\right) $$\n其中 $i=1,\\dots,n_x$，$j=1,\\dots,n_y$，$k=1,\\dots,n_x$，$\\ell=1,\\dots,n_y$。$A$ 对应的特征值是1维特征值的和：\n$$ \\lambda_{k,\\ell} = \\lambda_x(k) + \\lambda_y(\\ell) = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k\\pi}{2(n_x+1)}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{\\ell\\pi}{2(n_y+1)}\\right) $$\n\n**3. 快速泊松求解器算法**\n\n快速泊松求解器利用了这种特征分解。离散方程为 $A U = F$，其中 $U$ 和 $F$ 是网格函数。该算法分三步进行：\n1.  **分析（正向变换）：** 将右侧的网格函数 $F$ 分解到特征向量基 $\\{E_{k,\\ell}\\}$ 上。这通过对 $F$ 执行2维DST-I来完成。设 $\\hat{F}$ 为变换系数矩阵。\n    $$ \\hat{F} = \\text{DST}(F) $$\n2.  **在变换空间中标量求解：** 在特征基中，微分算子是对角的。解的系数 $\\hat{U}_{k,\\ell}$ 的方程变为对每个模态 $(k,\\ell)$ 的简单标量除法：\n    $$ \\lambda_{k,\\ell} \\hat{U}_{k,\\ell} = \\hat{F}_{k,\\ell} \\implies \\hat{U}_{k,\\ell} = \\frac{\\hat{F}_{k,\\ell}}{\\lambda_{k,\\ell}} $$\n3.  **合成（逆变换）：** 通过执行逆2维DST-I，从其系数 $\\hat{U}$ 重构解的网格函数 $U$。\n    $$ U = \\text{IDST}(\\hat{U}) $$\nDST-I（及其逆变换）可以使用快速傅里叶变换（FFT）算法快速计算，这使得求解器具有“快速”的特性，复杂度为 $\\mathcal{O}(n_x n_y \\log(n_x n_y))$。\n\n**4. 错位特征值及其奇偶性相关效应**\n\n问题指明了实现中的一个错误，即在计算 $x$ 方向的特征值时，错误地在正弦函数的参数中使用了 $n_x$ 而非 $n_x+1$。这是一个貌似合理的实现错误，源于对网格点数（$n_x$）和定义基函数周期的区间数（$n_x+1$）之间的混淆。\n- **正确的 $x$ 特征值：** $\\lambda_x(k) = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k\\pi}{2(n_x+1)}\\right)$\n- **错误的 $x$ 特征值：** $\\lambda^{\\text{bug}}_x(k) = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{k\\pi}{2n_x}\\right)$\n\n这个错误引入的误差在不同模态或网格尺寸上并非均匀。由于奇偶性的原因，会出现显著的差异。\n\n考虑 $n_x$ 为**偶数**的情况，$n_x = 2m$。问题引导我们研究模态 $k = m = n_x/2$。\n- 错误公式中正弦函数的参数变为 $\\frac{m\\pi}{2(2m)} = \\frac{\\pi}{4}$。\n- 正确公式中的参数为 $\\frac{m\\pi}{2(2m+1)}$。\n对于这个中心模态，错误公式计算出 $\\sin^2(\\pi/4) = 1/2$，这是一个不依赖于 $n_x$ 的常数值。而正确公式在一个当 $n_x \\to \\infty$ 时趋近于 $\\pi/4$ 的参数点上求值。对于中等大小的 $n_x$，差值 $\\sin^2(\\frac{n_x\\pi}{4(n_x+1)}) - \\sin^2(\\frac{\\pi}{4})$ 是相当大的。\n\n现在考虑 $n_x$ 为**奇数**的情况，$n_x = 2m+1$。我们研究模态 $k = m = (n_x-1)/2$。\n- 错误公式中正弦函数的参数为 $\\frac{m\\pi}{2(2m+1)}$。\n- 正确公式中的参数为 $\\frac{m\\pi}{2(2m+2)}$。\n在这里，两个参数都是 $n_x$ 的函数，并且彼此非常接近，特别是对于大的 $n_x$。$\\sin^2\\left(\\frac{(n_x-1)\\pi}{4n_x}\\right)$ 和 $\\sin^2\\left(\\frac{(n_x-1)\\pi}{4(n_x+1)}\\right)$ 之间的差异远小于偶数情况下的差异。\n\n这种结构上的差异解释了奇偶性敏感度。对于模态 $n_x/2$，偶数情况下的误差异常大，因为错误的公式巧合地锁定在一个特殊角度 $\\pi/4$ 上，从而与正确的、邻近的角度产生了更显著的偏差。在奇数情况下，对于相应的模态没有发生这种巧合。制造解是平滑的，会激发许多模态，但偶数 $n_x$ 情况下特定模态的放大误差会污染整个解，并导致更大的最大误差。单模态强迫项测试直接分离出了这种效应。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import dst\n\ndef solve():\n    \"\"\"\n    Analyzes the effect of a parity-dependent eigenvalue error in a fast Poisson solver.\n    \"\"\"\n\n    def fast_poisson_solver(nx, ny, f_grid, is_buggy):\n        \"\"\"\n        Solves the Poisson equation on a rectangular grid using a 2D DST-I.\n\n        Args:\n            nx (int): Number of interior grid points in the x-direction.\n            ny (int): Number of interior grid points in the y-direction.\n            f_grid (np.ndarray): The right-hand side function evaluated on the grid.\n            is_buggy (bool): If True, uses the misaligned eigenvalue formula for the x-direction.\n\n        Returns:\n            np.ndarray: The numerical solution on the grid.\n        \"\"\"\n        # Step 1: Analysis (Forward 2D DST-I)\n        # The transform is applied separably.\n        # Scipy's DST with type=1 and norm='ortho' is its own inverse.\n        f_hat = dst(dst(f_grid, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n\n        # Step 2: Define eigenvalues and solve in transform space\n        hx = 1 / (nx + 1)\n        hy = 1 / (ny + 1)\n        \n        # Mode indices k for x-direction, l for y-direction\n        k = np.arange(1, nx + 1)\n        l = np.arange(1, ny + 1)\n\n        # Calculate 1D eigenvalues for the x-direction\n        if is_buggy:\n            # Mistaken formula using n_x instead of n_x+1 in the angle\n            lambda_x = (4 / hx**2) * np.sin(k * np.pi / (2 * nx))**2\n        else:\n            # Correct formula\n            lambda_x = (4 / hx**2) * np.sin(k * np.pi / (2 * (nx + 1)))**2\n        \n        # Calculate 1D eigenvalues for the y-direction (always correct)\n        lambda_y = (4 / hy**2) * np.sin(l * np.pi / (2 * (ny + 1)))**2\n\n        # Create the 2D grid of eigenvalues lambda_k,l = lambda_x(k) + lambda_y(l)\n        # np.add.outer combines the (ny,) and (nx,) arrays into a (ny, nx) grid.\n        eigenvalue_grid = np.add.outer(lambda_y, lambda_x)\n        \n        # Solve for coefficients of the solution\n        u_hat = f_hat / eigenvalue_grid\n\n        # Step 3: Synthesis (Inverse 2D DST-I)\n        u_num = dst(dst(u_hat, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n        \n        return u_num\n\n    def compute_spectral_discrepancy(nx, ny, k_mode, l_mode):\n        \"\"\"\n        Calculates the relative discrepancy in the solution amplitude for a single Fourier mode.\n        \"\"\"\n        hx = 1 / (nx + 1)\n        hy = 1 / (ny + 1)\n\n        # Correct eigenvalues for the specific mode (k_mode, l_mode)\n        lambda_x_corr = (4 / hx**2) * np.sin(k_mode * np.pi / (2 * (nx + 1)))**2\n        lambda_y_corr = (4 / hy**2) * np.sin(l_mode * np.pi / (2 * (ny + 1)))**2\n        \n        # Buggy eigenvalue for the x-direction\n        lambda_x_buggy = (4 / hx**2) * np.sin(k_mode * np.pi / (2 * nx))**2\n\n        # The solution amplitude in Fourier space is 1/lambda_total\n        divisor_corr = lambda_x_corr + lambda_y_corr\n        divisor_buggy = lambda_x_buggy + lambda_y_corr\n\n        # Relative discrepancy formula from the problem statement\n        rel_discrepancy = np.abs(divisor_corr / divisor_buggy - 1.0)\n\n        return rel_discrepancy\n\n    # --- Test Suite ---\n    test_params = [(31, 31), (32, 32)]\n    results = {}\n\n    # Define the manufactured solution and its corresponding forcing term f = -delta(u)\n    u_exact_func = lambda x, y: np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n    f_func = lambda x, y: (np.pi**2 + (2*np.pi)**2) * u_exact_func(x, y)\n\n    # --- Cases A  B: Manufactured Solution Test ---\n    for nx, ny in test_params:\n        # Create grid coordinates\n        hx = 1 / (nx + 1)\n        hy = 1 / (ny + 1)\n        x_pts = np.arange(1, nx + 1) * hx\n        y_pts = np.arange(1, ny + 1) * hy\n        # `indexing='xy'` (default) is crucial for matching array axes to x/y directions\n        X, Y = np.meshgrid(x_pts, y_pts)\n\n        # Evaluate exact solution and forcing term on the grid\n        u_exact_grid = u_exact_func(X, Y)\n        f_grid = f_func(X, Y)\n        \n        # Solve with correct and buggy solvers\n        u_corr = fast_poisson_solver(nx, ny, f_grid, is_buggy=False)\n        u_buggy = fast_poisson_solver(nx, ny, f_grid, is_buggy=True)\n        \n        # Calculate maximum-norm error\n        e_corr = np.max(np.abs(u_corr - u_exact_grid))\n        e_buggy = np.max(np.abs(u_buggy - u_exact_grid))\n        \n        results[f\"e_corr_{nx}\"] = e_corr\n        results[f\"e_buggy_{nx}\"] = e_buggy\n\n    # --- Case C: Targeted Spectral Regression Probe ---\n    # For even n_x=32, probe mode k=n_x/2=16\n    eps_rel_even = compute_spectral_discrepancy(32, 32, k_mode=16, l_mode=1)\n    \n    # For odd n_x=31, probe mode k=(n_x-1)/2=15\n    eps_rel_odd = compute_spectral_discrepancy(31, 31, k_mode=15, l_mode=1)\n\n    # --- Final calculations for output ---\n    # Ratio of errors for the buggy solver\n    error_ratio = results[\"e_buggy_32\"] / results[\"e_buggy_31\"]\n\n    # Boolean flag for regression test\n    regression_flag = eps_rel_even >= 5 * eps_rel_odd\n\n    # Assemble final results in the specified order\n    final_results = [\n        results[\"e_corr_31\"],\n        results[\"e_corr_32\"],\n        results[\"e_buggy_31\"],\n        results[\"e_buggy_32\"],\n        error_ratio,\n        eps_rel_even,\n        eps_rel_odd,\n        regression_flag,\n    ]\n\n    # Print the final result in the exact specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3391502"}, {"introduction": "不同的边界条件要求使用不同的谱变换，因为变换的基函数必须满足相应的边界对称性。本实践将探讨如何使用离散余弦变换（DCT）来求解具有齐次诺伊曼边界条件的泊松方程。你将实现一个基于DCT的快速求解器，并学习如何处理该算子的奇异性，这对于保证解的存在性和唯一性至关重要 ([@problem_id:3391525])。", "problem": "考虑矩形域上的二维泊松方程，其边界条件为齐次诺伊曼（Neumann）边界条件：\n$$\n-\\Delta u(x,y) = f(x,y), \\quad (x,y) \\in (0,L_x) \\times (0,L_y),\n$$\n其中\n$$\n\\frac{\\partial u}{\\partial n} = 0 \\quad \\text{on} \\quad \\partial\\big((0,L_x)\\times(0,L_y)\\big),\n$$\n其中 $\\Delta$ 是拉普拉斯算子，$\\frac{\\partial u}{\\partial n}$ 表示法向导数。在一个均匀的、以单元为中心的网格上，x 方向有 $N_x$ 个单元，y 方向有 $N_y$ 个单元，定义网格间距 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$，单元中心位于 $x_i = (i+0.5)h_x$（对于 $i = 0,1,\\dots,N_x-1$）和 $y_j = (j+0.5)h_y$（对于 $j = 0,1,\\dots,N_y-1$）。使用标准的拉普拉斯算子五点有限差分离散格式，并通过在边界处进行偶延拓来施加诺伊曼边界条件。离散泊松算子是奇异的；因此，离散的右端项 $f_{i,j}$ 必须具有零离散平均值：\n$$\n\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} f_{i,j} = 0,\n$$\n这是在相差一个可加常数的意义下问题可解的必要相容性条件。\n\n从以下基本事实出发：(i) 均匀网格上的五点拉普拉斯算子是连续拉普拉斯算子的一个相容的二阶近似；(ii) 在有限差分框架中，齐次诺伊曼边界条件对应于边界处的偶延拓；(iii) 笛卡尔网格上的可分离线性算子可以通过适当的正交变换进行对角化。请推导一个用于离散泊松问题的快速谱对角化求解器，该求解器使用二维第二类离散余弦变换（DCT-II）进行正变换，使用第三类离散余弦变换（DCT-III）进行逆变换，并采用正交归一化缩放。使用与单元中心网格和齐次诺伊曼边界条件相对应的变换对。在变换域中，通过固定规范以产生零均值解，来与算子的零空间一致地处理零频模式。\n\n您必须实现一个完整的程序，该程序能够：\n- 为给定的测试套件构建离散右端项 $f_{i,j}$。\n- 应用一个快速泊松求解器，该求解器基于 DCT-II 正变换、通过单元中心网格上诺伊曼拉普拉斯算子的离散特征值进行对角缩放，以及 DCT-III 逆变换。\n- 通过计算方程 $-\\Delta_h u = f$ 的离散残差来验证计算出的解 $u_{i,j}$，其中 $\\Delta_h$ 是通过偶延拓施加齐次诺伊曼边界条件的五点有限差分拉普拉斯算子。每个测试用例的验证指标是最大绝对残差：\n$$\n\\max_{i,j} \\left| \\left(-\\Delta_h u\\right)_{i,j} - f_{i,j} \\right|.\n$$\n- 输出一行，其中包含这些残差的列表（每个测试用例一个浮点数），格式为方括号内以逗号分隔的列表。\n\n测试套件：\n- 情况 1（单位正方形上的单余弦模式）：\n  - $L_x = 1.0$, $L_y = 1.0$, $N_x = 64$, $N_y = 64$。\n  - 已知解：$u_{i,j} = \\cos\\!\\left(\\pi k_x \\frac{i+0.5}{N_x}\\right)\\cos\\!\\left(\\pi k_y \\frac{j+0.5}{N_y}\\right)$，其中 $k_x = 3$ 且 $k_y = 5$。\n  - 通过其谱特征值将离散算子 $-\\Delta_h$ 应用于 $u_{i,j}$ 来定义 $f_{i,j}$，使得精确离散解就是 $u_{i,j}$。\n- 情况 2（非正方形矩形上的双余弦模式之和）：\n  - $L_x = 2.0$, $L_y = 1.0$, $N_x = 32$, $N_y = 40$。\n  - 已知解：$u_{i,j} = 0.7\\,\\cos\\!\\left(\\pi \\cdot 1 \\cdot \\frac{i+0.5}{N_x}\\right) + (-1.2)\\,\\cos\\!\\left(\\pi \\cdot 2 \\cdot \\frac{i+0.5}{N_x}\\right)\\cos\\!\\left(\\pi \\cdot 3 \\cdot \\frac{j+0.5}{N_y}\\right)$。\n  - 通过将离散算子 $-\\Delta_h$ 谱方法地应用于每个模式并求和来定义 $f_{i,j}$，使得精确离散解就是 $u_{i,j}$。\n- 情况 3（各向异性矩形上的零均值随机强迫项）：\n  - $L_x = 0.7$, $L_y = 0.9$, $N_x = 50$, $N_y = 45$。\n  - $f_{i,j}$ 是一个固定的伪随机数组，其离散平均值为零（减去均值），并确定性地生成。\n- 情况 4（用于强调边界处理的小网格）：\n  - $L_x = 3.0$, $L_y = 0.5$, $N_x = 8$, $N_y = 8$。\n  - $f_{i,j}$ 是一个固定的伪随机数组，其离散平均值为零（减去均值），并确定性地生成。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述测试用例顺序排列的结果，格式为方括号内以逗号分隔的列表，例如：\n$$\n[\\text{residual\\_case1},\\text{residual\\_case2},\\text{residual\\_case3},\\text{residual\\_case4}],\n$$\n其中每个条目都是一个浮点数，代表该情况下的最大绝对残差。", "solution": "用户要求推导并实现一个快速泊松求解器，用于求解矩形域上带有齐次诺伊曼边界条件的二维泊松方程。该解法必须基于使用离散余弦变换（DCT）的谱对角化方法。\n\n### 1. 问题描述与离散化\n\n问题是求解泊松方程：\n$$\n-\\Delta u(x,y) = f(x,y), \\quad \\text{for } (x,y) \\in \\Omega = (0,L_x) \\times (0,L_y)\n$$\n其服从齐次诺伊曼边界条件：\n$$\n\\frac{\\partial u}{\\partial n} = \\vec{n} \\cdot \\nabla u = 0 \\quad \\text{on } \\partial\\Omega\n$$\n其中 $\\vec{n}$ 是指向边界 $\\partial\\Omega$ 外侧的法向量。解存在的必要条件是强迫项 $f$ 必须与边界条件相容。对该方程在整个域上积分并应用散度定理可得：\n$$\n-\\iint_{\\Omega} \\Delta u \\,dA = -\\oint_{\\partial\\Omega} \\nabla u \\cdot \\vec{n} \\,ds = -\\oint_{\\partial\\Omega} \\frac{\\partial u}{\\partial n} \\,ds = 0\n$$\n这对 $f$ 提出了一个可解性条件：\n$$\n\\iint_{\\Omega} f(x,y) \\,dx\\,dy = 0\n$$\n解 $u$ 仅在相差一个可加常数的意义下是唯一的。可以通过施加一个额外约束来获得唯一解，例如要求解的均值为零，即 $\\iint_{\\Omega} u(x,y) \\,dx\\,dy = 0$。\n\n我们使用一个具有 $N_x \\times N_y$ 个单元的均匀单元中心网格来离散化域 $\\Omega$。网格间距为 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$。单元中心位于 $(x_i, y_j)$，其中 $x_i = (i+0.5)h_x$（对于 $i=0,\\dots,N_x-1$）以及 $y_j = (j+0.5)h_y$（对于 $j=0,\\dots,N_y-1$）。离散解和强迫项分别表示为 $u_{i,j} \\approx u(x_i, y_j)$ 和 $f_{i,j} = f(x_i, y_j)$。\n\n负拉普拉斯算子 $-\\Delta = -\\frac{\\partial^2}{\\partial x^2} - \\frac{\\partial^2}{\\partial y^2}$ 使用二阶精度的有限差分格式进行近似。对于具有齐次诺伊曼边界条件的单元中心网格，离散负拉普拉斯算子 $(-\\Delta_h u)_{i,j}$ 由下式给出：\n$$\n(-\\Delta_h u)_{i,j} = \\left(-\\frac{d^2}{dx^2}\\right)_h u_{i,j} + \\left(-\\frac{d^2}{dy^2}\\right)_h u_{i,j}\n$$\n一维算子定义为：\n$$\n\\left(-\\frac{d^2}{dx^2}\\right)_h u_{i,j} =\n\\begin{cases}\n\\frac{1}{h_x^2}(-u_{i+1,j} + 2u_{i,j} - u_{i-1,j}) & \\text{for } 0  i  N_x-1 \\\\\n\\frac{1}{h_x^2}(u_{i,j} - u_{i+1,j})  \\text{for } i=0 \\\\\n\\frac{1}{h_x^2}(u_{i,j} - u_{i-1,j})  \\text{for } i=N_x-1\n\\end{cases}\n$$\ny 方向的算子定义与此类似。这种特定形式源于有限体积离散化，并能正确模拟边界上的零通量条件。离散问题即求解以下线性方程组：\n$$\n(-\\Delta_h u)_{i,j} = f_{i,j}, \\quad \\text{for } i=0,\\dots,N_x-1, j=0,\\dots,N_y-1\n$$\n与连续情况对应的离散可解性条件是强迫项的离散均值必须为零：$\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} f_{i,j} = 0$。\n\n### 2. 通过离散余弦变换进行谱对角化\n\n离散拉普拉斯算子 $-\\Delta_h$ 是笛卡尔网格上的一个线性可分离算子。其矩阵表示是对称的。这类算子可以通过基于其特征向量的变换被有效地对角化。对于单元中心网格和齐次诺伊曼边界条件的特定情况，特征向量是第二类离散余弦变换（DCT-II）的基向量。\n\n未归一化的二维基函数（特征向量）由一维基函数的张量积给出：\n$$\n\\Phi_{k,l}(i,j) = \\cos\\left(\\frac{\\pi k (i+0.5)}{N_x}\\right) \\cos\\left(\\frac{\\pi l (j+0.5)}{N_y}\\right)\n$$\n其中模式指数 $k=0,\\dots,N_x-1$ 和 $l=0,\\dots,N_y-1$。这些函数构成了 $N_x \\times N_y$ 网格上离散函数的正交基。\n\n将离散算子 $-\\Delta_h$ 应用于特征函数 $\\Phi_{k,l}$，会得到同一个特征函数，但乘以其对应的特征值 $\\lambda_{k,l}$：\n$$\n-\\Delta_h \\Phi_{k,l} = \\lambda_{k,l} \\Phi_{k,l}\n$$\n特征值 $\\lambda_{k,l}$ 是一维特征值之和，$\\lambda_{k,l} = \\lambda_k^{(x)} + \\lambda_l^{(y)}$，其中\n$$\n\\lambda_k^{(x)} = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{\\pi k}{2N_x}\\right), \\quad k=0,\\dots,N_x-1\n$$\n$$\n\\lambda_l^{(y)} = \\frac{4}{h_y^2} \\sin^2\\left(\\frac{\\pi l}{2N_y}\\right), \\quad l=0,\\dots,N_y-1\n$$\n因此，二维特征值为：\n$$\n\\lambda_{k,l} = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{\\pi k}{2N_x}\\right) + \\frac{4}{h_y^2} \\sin^2\\left(\\frac{\\pi l}{2N_y}\\right)\n$$\n该算子有一个对应于常数模式 $(k,l)=(0,0)$ 的零空间，此时 $\\lambda_{0,0}=0$。这个奇异性对应于解仅在相差一个可加常数的意义下是确定的。\n\n### 3. 快速泊松求解器算法\n\n上述谱特性引出了一个快速求解器算法：\n1.  **分析（正变换）：** 网格上的任何离散函数，如 $f_{i,j}$ 和 $u_{i,j}$，都可以表示为基函数 $\\Phi_{k,l}$ 的线性组合。此展开的系数通过执行二维 DCT-II 来找到。令 $\\hat{f}$ 和 $\\hat{u}$ 为变换后的数组：\n    $$\n    \\hat{f} = \\text{DCT-II}(f), \\quad \\hat{u} = \\text{DCT-II}(u)\n    $$\n    问题要求使用正交归一化变换，像 `scipy.fft` 这样的科学计算库可以正确处理这一点。\n\n2.  **在谱域中求解：** 将离散方程 $(-\\Delta_h u)_{i,j} = f_{i,j}$ 变换到谱域，可以使算子对角化，从而将耦合的线性方程组转化为一组简单的标量方程：\n    $$\n    \\lambda_{k,l} \\hat{u}_{k,l} = \\hat{f}_{k,l}\n    $$\n    因此，谱系数 $\\hat{u}_{k,l}$ 的解为：\n    $$\n    \\hat{u}_{k,l} = \\frac{\\hat{f}_{k,l}}{\\lambda_{k,l}}\n    $$\n\n3.  **处理奇异性：** 对于模式 $(k,l)=(0,0)$，我们有 $\\lambda_{0,0}=0$。可解性条件确保了 $\\hat{f}_{0,0} = 0$，这导致了 $0/0$ 的不定形式。为了获得唯一解，我们对解 $u$ 施加零均值条件。$u$ 的均值与其常数模式系数 $\\hat{u}_{0,0}$ 成正比。设置 $\\hat{u}_{0,0}=0$ 可以产生唯一的零均值解。\n    谱解的最终规则是：\n    $$\n    \\hat{u}_{k,l} = \\begin{cases}\n    \\frac{\\hat{f}_{k,l}}{\\lambda_{k,l}}  \\text{for } (k,l) \\neq (0,0) \\\\\n    0  \\text{for } (k,l) = (0,0)\n    \\end{cases}\n    $$\n\n4.  **合成（逆变换）：** 通过对谱系数 $\\hat{u}_{k,l}$ 应用逆变换，可以恢复物理空间中的解 $u_{i,j}$。正交归一化的 DCT-II 的逆变换是正交归一化的第三类离散余弦变换（DCT-III）。\n    $$\n    u = \\text{DCT-III}(\\hat{u})\n    $$\n\n这个过程利用基于快速傅里叶变换（FFT）的算法来实现 DCT，构成了一个“快速泊松求解器”，其计算复杂度为 $O(N_x N_y \\log(N_x N_y))$。\n\n### 4. 残差验证\n\n为了验证计算出的解 $u_{sol}$，我们必须将离散负拉普拉斯算子 $-\\Delta_h$ 应用于它，并将结果与原始右端项 $f$ 进行比较。残差定义为 $r = (-\\Delta_h u_{sol}) - f$。残差的最大绝对值 $\\max_{i,j} |r_{i,j}|$ 用作衡量解精度的指标。一个小的残差表明计算出的解精确地满足离散方程。用于验证的算子 $-\\Delta_h$ 的实现必须与第 1 节中指定的有限差分公式完全匹配。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import dctn, idctn\n\ndef apply_poisson_operator(u, hx, hy):\n    \"\"\"\n    Applies the discrete negative Laplacian operator (-Delta_h) with homogeneous\n    Neumann boundary conditions on a cell-centered grid.\n    \n    Args:\n        u (np.ndarray): The 2D array representing the function on the grid.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n\n    Returns:\n        np.ndarray: The result of applying the operator, (-Delta_h u).\n    \"\"\"\n    Lu = np.zeros_like(u)\n    Ny, Nx = u.shape\n    \n    # x-component of the operator\n    if Nx > 1:\n        # Interior points\n        if Nx > 2:\n            Lu[:, 1:-1] += (-u[:, 2:] + 2*u[:, 1:-1] - u[:, :-2]) / hx**2\n        # Boundary points (i=0 and i=Nx-1)\n        Lu[:, 0] += (u[:, 0] - u[:, 1]) / hx**2\n        Lu[:, -1] += (u[:, -1] - u[:, -2]) / hx**2\n\n    # y-component of the operator\n    if Ny > 1:\n        # Interior points\n        if Ny > 2:\n            Lu[1:-1, :] += (-u[2:, :] + 2*u[1:-1, :] - u[:-2, :]) / hy**2\n        # Boundary points (j=0 and j=Ny-1)\n        Lu[0, :] += (u[0, :] - u[1, :]) / hy**2\n        Lu[-1, :] += (u[-1, :] - u[-2, :]) / hy**2\n        \n    return Lu\n\ndef solve_poisson_dct(f, hx, hy):\n    \"\"\"\n    Solves the Poisson equation -Delta u = f using a fast DCT-based solver.\n\n    Args:\n        f (np.ndarray): The right-hand side function array.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n\n    Returns:\n        np.ndarray: The solution array u.\n    \"\"\"\n    Ny, Nx = f.shape\n    \n    # 1. Forward Transform (DCT-II)\n    f_hat = dctn(f, type=2, norm='ortho')\n    \n    # 2. Construct eigenvalues\n    kx = np.arange(Nx)\n    ky = np.arange(Ny)\n    \n    lambda_kx = (4 / hx**2) * np.sin(np.pi * kx / (2 * Nx))**2\n    lambda_ky = (4 / hy**2) * np.sin(np.pi * ky / (2 * Ny))**2\n    \n    # `lambda_kl` are eigenvalues of -Delta_h\n    lambda_kl = lambda_ky[:, np.newaxis] + lambda_kx[np.newaxis, :]\n    \n    # 3. Solve in spectral domain\n    # Avoid division by zero for the (0,0) mode\n    # The solver will set u_hat[0,0] = 0 later, so the value here doesn't matter\n    lambda_kl[0, 0] = 1.0 \n    \n    u_hat = f_hat / lambda_kl\n    \n    # Enforce zero-mean solution by setting the constant mode coefficient to zero\n    u_hat[0, 0] = 0.0\n    \n    # 4. Inverse Transform (DCT-III)\n    # scipy.fft.idctn with type=2 is the inverse of dctn with type=2\n    u_sol = idctn(u_hat, type=2, norm='ortho')\n    \n    return u_sol\n    \ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 64, 'Ny': 64, 'type': 'manufactured', 'params': {'kx': 3, 'ky': 5}},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 32, 'Ny': 40, 'type': 'manufactured', 'params': {}},\n        {'Lx': 0.7, 'Ly': 0.9, 'Nx': 50, 'Ny': 45, 'type': 'random', 'seed': 0},\n        {'Lx': 3.0, 'Ly': 0.5, 'Nx': 8, 'Ny': 8, 'type': 'random', 'seed': 1}\n    ]\n    \n    results = []\n    \n    for i, case in enumerate(test_cases):\n        Lx, Ly = case['Lx'], case['Ly']\n        Nx, Ny = case['Nx'], case['Ny']\n        hx, hy = Lx / Nx, Ly / Ny\n        \n        j_coords, i_coords = np.indices((Ny, Nx))\n        \n        # --- Construct the right-hand side f_ij ---\n        if case['type'] == 'manufactured':\n            # Eigenvalues for construction of f\n            kx_modes = np.arange(Nx)\n            ky_modes = np.arange(Ny)\n            lambda_kx = (4 / hx**2) * np.sin(np.pi * kx_modes / (2 * Nx))**2\n            lambda_ky = (4 / hy**2) * np.sin(np.pi * ky_modes / (2 * Ny))**2\n\n            if i == 0: # Case 1\n                kx, ky = case['params']['kx'], case['params']['ky']\n                u_exact = np.cos(np.pi * kx * (i_coords + 0.5) / Nx) * \\\n                          np.cos(np.pi * ky * (j_coords + 0.5) / Ny)\n                lambda_val = lambda_kx[kx] + lambda_ky[ky]\n                f = lambda_val * u_exact\n            \n            elif i == 1: # Case 2\n                u_mode1 = 0.7 * np.cos(np.pi * 1 * (i_coords + 0.5) / Nx)\n                u_mode2 = -1.2 * np.cos(np.pi * 2 * (i_coords + 0.5) / Nx) * \\\n                           np.cos(np.pi * 3 * (j_coords + 0.5) / Ny)\n                \n                lambda_val1 = lambda_kx[1] + lambda_ky[0]\n                lambda_val2 = lambda_kx[2] + lambda_ky[3]\n\n                f = lambda_val1 * u_mode1 + lambda_val2 * u_mode2\n        \n        elif case['type'] == 'random':\n            rng = np.random.default_rng(case['seed'])\n            f = rng.random((Ny, Nx))\n            f -= np.mean(f) # Enforce compatibility condition\n\n        # --- Solve the problem and validate ---\n        u_solution = solve_poisson_dct(f, hx, hy)\n        \n        # Calculate residual: R = (-Delta_h * u_solution) - f\n        neg_lap_u = apply_poisson_operator(u_solution, hx, hy)\n        residual = neg_lap_u - f\n        \n        max_abs_residual = np.max(np.abs(residual))\n        results.append(max_abs_residual)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3391525"}, {"introduction": "现实世界中的问题通常涉及非零的边界数据，这使得直接应用为齐次问题设计的快速求解器变得不可能。本实践介绍了一种强大的技术——提升法（lifting method），它能将非齐次边界问题转化为我们已经熟悉的齐次问题。你将通过实现并比较两种不同的提升函数，来探索该方法如何影响离散化误差和混叠效应，从而加深对处理复杂边界条件的理解 ([@problem_id:3391522])。", "problem": "考虑在矩形域 $\\Omega=(0,1)\\times(0,1)$ 上的二维泊松方程，其带有非齐次狄利克雷边界数据，由下式给出\n$$\n-\\Delta u(x,y) = f(x,y), \\quad (x,y)\\in \\Omega, \\quad u|_{\\partial\\Omega} = g(x,y).\n$$\n使用提升分解 $u=v+w$，其中 $v$ 满足 $v|_{\\partial\\Omega}=g$，因此 $w$ 具有齐次狄利克雷边界条件，从而\n$$\n-\\Delta w = f + \\Delta v \\quad \\text{in } \\Omega, \\quad w|_{\\partial\\Omega}=0.\n$$\n你需要设计并实现一个基于离散正弦变换 (DST) 的快速泊松求解器，用于在大小为 $N_x\\times N_y$ 的均匀内部网格上求解 $w$，步长分别为 $h_x=1/(N_x+1)$ 和 $h_y=1/(N_y+1)$。该求解器必须使用标准的二阶五点有限差分法来离散拉普拉斯算子：\n$$\n\\Delta_h \\phi_{i,j} = \\frac{\\phi_{i-1,j}-2\\phi_{i,j}+\\phi_{i+1,j}}{h_x^2} + \\frac{\\phi_{i,j-1}-2\\phi_{i,j}+\\phi_{i,j+1}}{h_y^2},\n$$\n该公式应用于所有内部索引 $i=1,\\dots,N_x$ 和 $j=1,\\dots,N_y$，边界上的邻点使用给定的狄利克雷边界值。\n\n为能够量化数值误差，我们采用制造解法，即首先定义一个精确解 $u_{\\text{exact}}$，然后从中推导出对应的源项 $f$ 和边界数据 $g$。选择齐次分量\n$$\nw_{\\text{exact}}(x,y) = \\sin(p\\pi x)\\sin(q\\pi y),\n$$\n因此\n$$\n-\\Delta w_{\\text{exact}}(x,y) = \\pi^2(p^2+q^2)\\sin(p\\pi x)\\sin(q\\pi y),\n$$\n并定义边界数据 $g$ 仅在顶边 $y=1$ 上非零，由下式给出\n$$\ng(x,1) = \\sin(m\\pi x), \\quad g(x,0)=g(0,y)=g(1,y)=0.\n$$\n令典型的连续调和提升为\n$$\nv_{\\text{harm}}(x,y) = \\sin(m\\pi x)\\frac{\\sinh(m\\pi y)}{\\sinh(m\\pi)},\n$$\n该函数满足 $\\Delta v_{\\text{harm}}=0$ 于 $\\Omega$ 内且 $v_{\\text{harm}}|_{\\partial\\Omega}=g$。则总的制造解为\n$$\nu_{\\text{exact}}(x,y) = v_{\\text{harm}}(x,y) + w_{\\text{exact}}(x,y),\n$$\n其中\n$$\nf(x,y) = -\\Delta u_{\\text{exact}}(x,y) = -\\Delta v_{\\text{harm}}(x,y) - \\Delta w_{\\text{exact}}(x,y) = \\pi^2(p^2+q^2)\\sin(p\\pi x)\\sin(q\\pi y).\n$$\n\n使用两种不同的 $v$ 的离散实现来实施提升方法：\n- 在内部网格上采样的调和提升：对于内部节点为 $v_{\\text{harm}}(x_i,y_j)$，边界线上的边界值来自相同的连续公式。使用边界邻近的有限差分构建 $\\Delta_h v_{\\text{harm}}$。\n- 在内部网格上采样的朴素 $y$ 方向线性提升：\n$$\nv_{\\text{naive}}(x,y) = y\\sin(m\\pi x),\n$$\n该函数满足 $v_{\\text{naive}}|_{\\partial\\Omega}=g$ 但 $\\Delta v_{\\text{naive}}\\neq 0$。\n\n对于每种提升，将 $w$ 的离散右端项组装为\n$$\n\\text{rhs}_{i,j} = f(x_i,y_j) + \\Delta_h v_{i,j},\n$$\n然后使用基于 I 型离散正弦变换 (DST-I) 和标准正交归一化的快速 DST 对角化方法求解 $-\\Delta_h w = \\text{rhs}$。在 DST-I 基下，$-\\Delta_h$ 的特征值为\n$$\n\\lambda_{k,\\ell} = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{\\pi k}{2(N_x+1)}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{\\pi \\ell}{2(N_y+1)}\\right), \\quad k=1,\\dots,N_x, \\ \\ell=1,\\dots,N_y.\n$$\n\n你的任务是量化 $v$ 的离散化和边界频率 $m$ 如何影响混叠以及 $w$ 和 $u$ 的总体误差。具体来说，计算内部网格上的相对离散 $\\ell^2$ 误差：\n$$\nE = \\frac{\\left\\|u_{\\text{num}} - u_{\\text{exact}}\\right\\|_2}{\\left\\|u_{\\text{exact}}\\right\\|_2},\n$$\n对于 $u_{\\text{num}}=v_{\\text{harm}}+w_{\\text{harm}}$ 和 $u_{\\text{num}}=v_{\\text{naive}}+w_{\\text{naive}}$ 两种情况，其中 $w_{\\text{harm}}$ 和 $w_{\\text{naive}}$ 是通过 DST-I 分别求解离散系统 $-\\Delta_h w = f + \\Delta_h v$ 得到的。\n\n为以下参数集测试套件提供结果，这些参数集旨在探测良好解析频率、近奈奎斯特内容和清晰的混叠场景：\n- 测试 1 (理想情况): $N_x=64$, $N_y=64$, $m=4$, $p=3$, $q=2$.\n- 测试 2 (接近奈奎斯特频率): $N_x=64$, $N_y=64$, $m=30$, $p=3$, $q=2$.\n- 测试 3 (超奈奎斯特频率混叠): $N_x=32$, $N_y=32$, $m=70$, $p=3$, $q=2$.\n- 测试 4 (粗网格混叠边缘情况): $N_x=8$, $N_y=8$, $m=16$, $p=3$, $q=2$.\n\n你的程序必须输出一行，其中包含八个浮点误差值的逗号分隔列表\n$$\n[E_{\\text{harm}}^{(1)}, E_{\\text{naive}}^{(1)}, E_{\\text{harm}}^{(2)}, E_{\\text{naive}}^{(2)}, E_{\\text{harm}}^{(3)}, E_{\\text{naive}}^{(3)}, E_{\\text{harm}}^{(4)}, E_{\\text{naive}}^{(4)}]\n$$\n并用方括号括起来。不得打印任何额外文本。此问题中没有物理单位；所有量均为无量纲。角度以弧度为单位。所有输出均以指定的单行格式表示为浮点数。", "solution": "该问题被验证为具有科学依据、适定的和客观的。它提出了一个用于快速泊松求解器的标准数值验证任务，旨在探究不同提升策略对非齐次狄利克雷边界条件的影响。所有给定的公式和参数都是正确且一致的。该问题是一个精心设计的数值分析练习，特别关注离散误差、混叠及其与求解方法的相互作用。\n\n问题的核心是在单位正方形 $\\Omega=(0,1)\\times(0,1)$ 上求解二维泊松方程\n$$-\\Delta u(x,y) = f(x,y),$$\n其具有非齐次狄利克雷边界条件 $u|_{\\partial\\Omega} = g(x,y)$。所选方法是提升分解，将解 $u$ 分成两个分量 $u = v+w$。“提升”函数 $v$ 被构造为满足非齐次边界条件 $v|_{\\partial\\Omega} = g$。这将关于 $u$ 的问题转化为关于新未知函数 $w = u-v$ 的问题，该函数满足齐次边界条件 $w|_{\\partial\\Omega} = 0$。将 $u=v+w$代入泊松方程得到：\n$$-\\Delta (v+w) = f \\implies -\\Delta w = f + \\Delta v.$$\n因此，问题简化为求解一个具有修正右端项和齐次狄利克雷边界条件的关于 $w$ 的泊松方程。\n\n数值解在具有 $N_x \\times N_y$ 个内部点的均匀网格上寻求。网格间距为 $h_x=1/(N_x+1)$ 和 $h_y=1/(N_y+1)$，内部网格点为 $(x_i, y_j) = (ih_x, jh_y)$，其中 $i=1,\\dots,N_x$ 且 $j=1,\\dots,N_y$。拉普拉斯算子使用标准的五点有限差分格式进行离散：\n$$\n\\Delta_h \\phi_{i,j} = \\frac{\\phi_{i-1,j}-2\\phi_{i,j}+\\phi_{i+1,j}}{h_x^2} + \\frac{\\phi_{i,j-1}-2\\phi_{i,j}+\\phi_{i,j+1}}{h_y^2}.\n$$\n关于 $w$ 的离散问题是找到网格函数 $w_{i,j}$，使其在所有内部点 $(i,j)$ 上满足：\n$$-\\Delta_h w_{i,j} = f(x_i,y_j) + (\\Delta_h v)_{i,j},$$\n并在边界上 $w=0$。这个线性系统可以通过基于离散正弦变换 (DST) 的快速泊松求解器高效求解。在具有齐次狄利克雷条件的矩形网格上，代表负离散拉普拉斯算子 $-\\Delta_h$ 的矩阵可被二维 DST 对角化。其特征值 $\\lambda_{k,\\ell}$ 由下式给出：\n$$\n\\lambda_{k,\\ell} = \\frac{4}{h_x^2}\\sin^2\\left(\\frac{\\pi k}{2(N_x+1)}\\right) + \\frac{4}{h_y^2}\\sin^2\\left(\\frac{\\pi \\ell}{2(N_y+1)}\\right),\n$$\n其中 $k=1,\\dots,N_x$ 且 $\\ell=1,\\dots,N_y$。\n\n$w$ 的求解算法如下：\n1.  在内部网格上计算离散右端项 $\\text{RHS}_{i,j} = f(x_i,y_j) + (\\Delta_h v)_{i,j}$。\n2.  使用 I 型二维 DST (DST-I) 将 RHS 变换到频域：$\\widehat{\\text{RHS}} = \\text{DST}(\\text{RHS})$。\n3.  通过除法求解频域中 $w$ 的系数：$\\hat{w}_{k,\\ell} = \\widehat{\\text{RHS}}_{k,\\ell} / \\lambda_{k,\\ell}$。\n4.  变换回空间域以获得解：$w = \\text{IDST}(\\hat{w})$，其中 IDST 是逆 DST。对于具有标准正交归一化的 DST-I，IDST 与 DST 相同。\n\n该问题研究了提升函数 $v$ 的两种不同选择：\n1.  **调和提升**：$v_{\\text{harm}}(x,y) = \\sin(m\\pi x)\\frac{\\sinh(m\\pi y)}{\\sinh(m\\pi)}$。此函数是调和的，即 $\\Delta v_{\\text{harm}} = 0$。因此，离散 RHS 上的项 $\\Delta_h v_{\\text{harm}}$ 完全是有限差分格式的截断误差的结果，其阶数为 $O(h_x^2, h_y^2)$。\n2.  **朴素提升**：$v_{\\text{naive}}(x,y) = y\\sin(m\\pi x)$。此函数不是调和的；$\\Delta v_{\\text{naive}} = -m^2\\pi^2 y \\sin(m\\pi x)$。因此，$\\Delta_h v_{\\text{naive}}$ 是这个非零函数的近似，它为 $w$ 的 RHS 引入了一个实质性的、物理上不同的项。\n\n为了验证，使用了一个制造解 $u_{\\text{exact}}(x,y) = v_{\\text{harm}}(x,y) + w_{\\text{exact}}(x,y)$，其中 $w_{\\text{exact}}(x,y) = \\sin(p\\pi x)\\sin(q\\pi y)$。这意味着源项为 $f(x,y) = -\\Delta u_{\\text{exact}} = -\\Delta w_{\\text{exact}} = \\pi^2(p^2+q^2)\\sin(p\\pi x)\\sin(q\\pi y)$。\n\n总数值解构造为 $u_{\\text{num}} = v + w_{\\text{num}}$，其中 $v$ 是在网格上采样的所选提升函数，$w_{\\text{num}}$ 是相应的数值解。精度通过误差的相对离散 $\\ell^2$ 范数量化，$E = \\|u_{\\text{num}} - u_{\\text{exact}}\\|_2 / \\|u_{\\text{exact}}\\|_2$，在内部网格上计算。测试案例旨在探究边界数据频率 $m$ 被良好解析、接近网格的奈奎斯特极限或超出该极限导致混叠的场景。当高频信号的采样率不足以捕捉它时，就会发生混叠，使其看起来像一个较低频率的信号。这会影响采样的提升函数 $v$ 及其离散拉普拉斯算子 $\\Delta_h v$，从而影响 $w_{\\text{num}}$ 和总解 $u_{\\text{num}}$ 的精度。对于高波数情况 ($m=70$)，项 $\\sinh(m\\pi y)/\\sinh(m\\pi)$ 通过数值稳定的公式 $e^{m\\pi(y-1)} \\frac{1 - e^{-2m\\pi y}}{1-e^{-2m\\pi}}$ 计算，以防止浮点溢出。\n\n该实现计算了四种指定测试案例下两种提升选择的误差 E。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import dst\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation using a fast sine transform-based solver\n    with two different lifting techniques for inhomogeneous boundary conditions,\n    and computes the relative l2-error for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, m, p, q)\n        (64, 64, 4, 3, 2),\n        (64, 64, 30, 3, 2),\n        (32, 32, 70, 3, 2),\n        (8, 8, 16, 3, 2),\n    ]\n\n    results = []\n    for params in test_cases:\n        error_harm = compute_error_for_lifting(*params, lifting_type='harm')\n        error_naive = compute_error_for_lifting(*params, lifting_type='naive')\n        results.extend([error_harm, error_naive])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_v_harm_on_grid(X, Y, m):\n    \"\"\"\n    Computes the harmonic lifting function v_harm on a grid,\n    using a numerically stable formula to avoid overflow for large m.\n    \"\"\"\n    if m == 0:\n        return np.zeros_like(X)\n    \n    m_pi = m * np.pi\n    \n    # sinh(m_pi) can overflow for large m (e.g., m=70).\n    # We use the identity:\n    # sinh(m*pi*y)/sinh(m*pi) = exp(m*pi*(y-1)) * (1-exp(-2*m*pi*y))/(1-exp(-2*m*pi))\n    # This is numerically stable for y in [0, 1].\n    if m_pi > 30.0:  # Threshold for using stable formula\n        exp_term = np.exp(m_pi * (Y - 1.0))\n        num_corr = 1.0 - np.exp(-2.0 * m_pi * Y)\n        den_corr = 1.0 - np.exp(-2.0 * m_pi)\n        \n        # Handle den_corr being zero if m_pi is huge\n        if den_corr == 0.0:\n             val = exp_term\n        else:\n             val = exp_term * num_corr / den_corr\n    else:\n        val = np.sinh(m_pi * Y) / np.sinh(m_pi)\n        \n    return np.sin(m_pi * X) * val\n\ndef compute_error_for_lifting(Nx, Ny, m, p, q, lifting_type):\n    \"\"\"\n    Computes the relative l2-error for a single test case and lifting type.\n    \"\"\"\n    # Grid parameters\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n\n    # Interior grid\n    xi = np.arange(1, Nx + 1) * hx\n    yi = np.arange(1, Ny + 1) * hy\n    X_int, Y_int = np.meshgrid(xi, yi, indexing='ij')\n\n    # Padded grid (includes boundaries)\n    x_pad = np.linspace(0, 1, Nx + 2)\n    y_pad = np.linspace(0, 1, Ny + 2)\n    X_pad, Y_pad = np.meshgrid(x_pad, y_pad, indexing='ij')\n\n    # Exact solution components on interior grid\n    w_exact_interior = np.sin(p * np.pi * X_int) * np.sin(q * np.pi * Y_int)\n    v_harm_interior = get_v_harm_on_grid(X_int, Y_int, m)\n    u_exact_interior = v_harm_interior + w_exact_interior\n\n    # Source term f on interior grid\n    f_interior = np.pi**2 * (p**2 + q**2) * np.sin(p * np.pi * X_int) * np.sin(q * np.pi * Y_int)\n\n    # Define and sample the lifting function v on the padded grid\n    if lifting_type == 'harm':\n        v_padded = get_v_harm_on_grid(X_pad, Y_pad, m)\n    elif lifting_type == 'naive':\n        v_padded = Y_pad * np.sin(m * np.pi * X_pad)\n    else:\n        raise ValueError(\"Invalid lifting type\")\n\n    v_interior = v_padded[1:-1, 1:-1]\n    \n    # Compute discrete Laplacian of v on the interior grid\n    term_x = (v_padded[0:-2, 1:-1] - 2 * v_padded[1:-1, 1:-1] + v_padded[2:, 1:-1]) / hx**2\n    term_y = (v_padded[1:-1, 0:-2] - 2 * v_padded[1:-1, 1:-1] + v_padded[1:-1, 2:]) / hy**2\n    delta_h_v = term_x + term_y\n\n    # Assemble the right-hand side for the w-problem\n    rhs_w = f_interior + delta_h_v\n\n    # Solve for w_num using DST-based fast Poisson solver\n    # 1. Transform RHS to frequency domain\n    rhs_w_hat = dst(dst(rhs_w, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n\n    # 2. Define eigenvalues of the discrete negative Laplacian\n    k = np.arange(1, Nx + 1).reshape(-1, 1)\n    l = np.arange(1, Ny + 1).reshape(1, -1)\n    lambda_kl = (4/hx**2) * np.sin(np.pi * k / (2 * (Nx + 1)))**2 + \\\n                (4/hy**2) * np.sin(np.pi * l / (2 * (Ny + 1)))**2\n\n    # 3. Solve in frequency domain\n    w_hat_num = rhs_w_hat / lambda_kl\n\n    # 4. Transform back to spatial domain\n    w_num = dst(dst(w_hat_num, axis=1, type=1, norm='ortho'), axis=0, type=1, norm='ortho')\n\n    # Reconstruct the full numerical solution on the interior grid\n    u_num = v_interior + w_num\n\n    # Compute relative discrete l2 error\n    norm_error = np.linalg.norm(u_num - u_exact_interior)\n    norm_exact = np.linalg.norm(u_exact_interior)\n    \n    if norm_exact == 0:\n        return 0.0\n    \n    return norm_error / norm_exact\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3391522"}]}