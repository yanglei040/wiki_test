{"hands_on_practices": [{"introduction": "谱配置法 (spectral collocation methods) 的核心在于能够精确地计算函数在网格点上的导数，这通过谱微分矩阵实现，该矩阵是连接函数值与其导数值的线性算子。本练习将指导您构建切比雪夫 (Chebyshev) 谱微分矩阵，这是谱方法中最基本也最重要的工具之一 [@problem_id:3446562]。通过这个实践，您将不仅学习如何从拉格朗日 (Lagrange) 插值的基础原理出发，利用数值稳定的重心坐标公式 (barycentric formula) 来构造这些矩阵，还将分析它们的谱范数 (spectral norm)，这对于理解数值稳定性和误差增长至关重要。", "problem": "构建一个完整的程序，该程序针对区间 $[-1,1]$ 上的切比雪夫谱搭配法，使用高斯-洛巴托点，通过全局基函数构建一阶和二阶微分矩阵，并估计它们的谱范数作为 $N$ 的函数。高斯-洛巴托点定义为 $x_j = \\cos\\left(\\pi j / N\\right)$，其中 $j = 0,1,\\dots,N$。切比雪夫一阶微分矩阵 $D^{(1)} \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 定义为 $D^{(1)}_{j,k} = \\ell_k'(x_j)$，其中 $\\ell_k$ 是在节点 $\\{x_j\\}_{j=0}^N$ 处的拉格朗日基多项式。使用重心坐标公式，通过权重 $w_j$ 和恒等式 $D^{(1)}_{j,k} = \\frac{w_k}{w_j}\\frac{1}{x_j - x_k}$（对于 $j \\neq k$）以及 $D^{(1)}_{j,j} = -\\sum_{k\\neq j} D^{(1)}_{j,k}$ 来推导和实现 $D^{(1)}$。对于切比雪夫高斯-洛巴托点，选择与第一类切比雪夫多项式网格一致的重心权重。然后构建二阶微分矩阵 $D^{(2)} = D^{(1)}D^{(1)}$，它表示对多项式插值函数应用两次一阶导数。\n\n矩阵 $A$ 的谱范数，记为 $\\|A\\|_2$，是由欧几里得范数诱导的算子范数，等于 $A$ 的最大奇异值。您必须使用奇异值分解（Singular Value Decomposition, SVD）计算 $\\|D^{(1)}\\|_2$ 和 $\\|D^{(2)}\\|_2$。\n\n您的推导需从多项式插值、拉格朗日基函数和导数的重心表示等基本定义出发。避免使用跳过这些推导过程的现成公式。清晰地论证每一步为何正确，以及它如何从使用全局基函数的谱搭配法的基本原理中得出。\n\n使用以下参数值测试套件实现算法：\n- $N \\in \\{1,2,8,32,128\\}$。\n\n对于测试套件中的每个 $N$，返回一对浮点数值 $[\\|D^{(1)}\\|_2,\\|D^{(2)}\\|_2]$，并四舍五入到 $10$ 位小数。最终输出必须将所有提供的测试用例的结果汇总到一行中。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[[r_1^{(1)},r_1^{(2)}],[r_2^{(1)},r_2^{(2)}],\\dots]$），其中每个内部对按指定顺序 $[1,2,8,32,128]$ 对应一个 $N$ 值，每个 $r_i^{(\\cdot)}$ 是一个四舍五入到 $10$ 位小数的浮点数。此问题不要求物理单位或角度单位，所有输出必须是无量纲实数。", "solution": "该问题要求在（切比雪夫）高斯-洛巴托网格上构建一阶和二阶切比雪夫微分矩阵 $D^{(1)}$ 和 $D^{(2)}$，并计算它们的谱范数。推导过程必须从多项式插值的基本原理开始。\n\n### 1. 多项式插值与微分矩阵\n假设函数 $u(x)$ 定义在区间 $[-1, 1]$ 上。我们用一个唯一的、次数至多为 $N$ 的多项式 $p(x)$ 来近似 $u(x)$，该多项式在 $N+1$ 个不同的搭配点 $\\{x_j\\}_{j=0}^N$ 处对 $u(x)$ 进行插值。这个插值多项式可以用拉格朗日形式表示：\n$$\np(x) = \\sum_{k=0}^{N} u_k \\ell_k(x)\n$$\n其中 $u_k = u(x_k)$ 是函数在搭配点处的值，而 $\\ell_k(x)$ 是拉格朗日基多项式。它们的定义属性为 $\\ell_k(x_j) = \\delta_{kj}$，其中 $\\delta_{kj}$ 是克罗内克δ函数。\n\n插值多项式 $p(x)$ 的导数由下式给出：\n$$\np'(x) = \\sum_{k=0}^{N} u_k \\ell'_k(x)\n$$\n为了求出多项式在搭配点处的导数，我们在每个 $x_j$ 处计算 $p'(x)$ 的值：\n$$\np'(x_j) = \\sum_{k=0}^{N} u_k \\ell'_k(x_j)\n$$\n这个方程可以表示为矩阵-向量乘积。令 $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$ 为网格点上的函数值向量，$\\mathbf{u'} = [p'(x_0), p'(x_1), \\dots, p'(x_N)]^T$ 为导数值向量。那么，$\\mathbf{u'} = D^{(1)} \\mathbf{u}$，其中 $D^{(1)}$ 是一阶微分矩阵，其元素为：\n$$\nD^{(1)}_{j,k} = \\ell'_k(x_j)\n$$\n这是谱微分矩阵的基本定义。\n\n### 2. 用于数值稳定性的重心坐标公式\n从标准拉格朗日公式 $\\ell_k(x) = \\prod_{i \\neq k} \\frac{x-x_i}{x_k-x_i}$ 直接计算 $\\ell'_k(x_j)$ 在数值上是不稳定的。一种更稳健的方法是使用重心坐标公式。\n\n令 $L(x)$ 为节点多项式，定义为 $L(x) = \\prod_{i=0}^{N}(x-x_i)$。拉格朗日基多项式 $\\ell_k(x)$ 可以写成：\n$$\n\\ell_k(x) = \\frac{L(x)}{(x-x_k)L'(x_k)}\n$$\n我们将重心权重 $w_k$ 定义为：\n$$\nw_k = \\frac{1}{L'(x_k)} = \\frac{1}{\\prod_{i \\neq k}(x_k-x_i)}\n$$\n使用这些权重，拉格朗日多项式变为 $\\ell_k(x) = w_k \\frac{L(x)}{x-x_k}$。\n\n### 3. 微分矩阵元素的推导\n\n**非对角线元素 ($j \\neq k$)：**\n为了找到 $j \\neq k$ 时的元素 $D^{(1)}_{j,k} = \\ell'_k(x_j)$，我们对 $\\ell_k(x)$ 的重心形式进行微分：\n$$\n\\ell'_k(x) = w_k \\left( \\frac{L'(x)(x-x_k) - L(x)}{(x-x_k)^2} \\right)\n$$\n现在，我们在 $x=x_j$ 处计算此表达式的值。由于对任意 $j$，$x_j$ 都是节点多项式 $L(x)$ 的一个根，因此有 $L(x_j)=0$。\n$$\n\\ell'_k(x_j) = w_k \\left( \\frac{L'(x_j)(x_j-x_k) - 0}{(x_j-x_k)^2} \\right) = w_k \\frac{L'(x_j)}{x_j-x_k}\n$$\n根据重心权重 $w_j = 1/L'(x_j)$ 的定义，我们有 $L'(x_j) = 1/w_j$。将此代入 $\\ell'_k(x_j)$ 的表达式中，即可得到 $D^{(1)}$ 的非对角线元素的公式：\n$$\nD^{(1)}_{j,k} = \\frac{w_k}{w_j} \\frac{1}{x_j-x_k} \\quad \\text{对于 } j \\neq k\n$$\n\n**对角线元素 ($j = k$)：**\n为了找到对角线元素 $D^{(1)}_{j,j}$，我们利用微分矩阵必须能精确地对常数函数求导这一性质。令 $u(x) = c$ 为一个常数函数。这是一个次数为0的多项式，对于 $N \\ge 0$，它可以被我们的插值函数精确表示。函数值向量为 $\\mathbf{u} = [c, c, \\dots, c]^T$。其导数为 $u'(x) = 0$，因此导数值向量必须为 $\\mathbf{u'} = \\mathbf{0}$。\n从 $\\mathbf{u'} = D^{(1)}\\mathbf{u}$，我们得到 $D^{(1)}[c, \\dots, c]^T = [0, \\dots, 0]^T$。这意味着微分矩阵的每一行之和必须为零：\n$$\n\\sum_{k=0}^{N} D^{(1)}_{j,k} = 0 \\quad \\text{对于每个 } j = 0, 1, \\dots, N\n$$\n由此，我们可以解出对角线元素 $D^{(1)}_{j,j}$：\n$$\nD^{(1)}_{j,j} = - \\sum_{k \\neq j} D^{(1)}_{j,k}\n$$\n这个推导证实了问题陈述中提供的公式。\n\n### 4. 网格点与重心权重\n问题指定了切比雪夫-高斯-洛巴托点，它们是 $N$ 次第一类切比雪夫多项式 $T_N(x)$ 的极值点。这些点由下式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{对于 } j = 0, 1, \\dots, N\n$$\n对于这组特定的点，已知的重心权重为：\n$$\nw_j = (-1)^j \\delta_j\n$$\n其中，当 $j=0$ 和 $j=N$ 时，$\\delta_j = 1/2$；当 $j=1, 2, \\dots, N-1$ 时，$\\delta_j=1$。这些权重的任意常数倍也是有效的，因为常数会在 $D^{(1)}_{j,k}$ 的公式中被约掉。为方便起见，我们选择以下特定形式：\n$$\nw_0 = \\frac{1}{2}, \\quad w_j = (-1)^j \\text{ for } 1 \\le j \\le N-1, \\quad w_N = \\frac{(-1)^N}{2}\n$$\n\n### 5. 二阶微分矩阵\n二阶微分矩阵 $D^{(2)}$ 表示将一阶导数算子应用两次。在次数至多为 $N$ 的多项式空间上，这等价于一阶微分矩阵的矩阵平方：\n$$\nD^{(2)} = (D^{(1)})^2 = D^{(1)}D^{(1)}\n$$\n我们通过对构建的 $D^{(1)}$ 执行矩阵乘法来计算 $D^{(2)}$。\n\n### 6. 谱范数计算\n矩阵 $A$ 的谱范数，记为 $\\|A\\|_2$，定义为 $A$ 的最大奇异值 $\\sigma_{\\max}(A)$。$A$ 的奇异值是半正定矩阵 $A^H A$（对于实数矩阵则是 $A^T A$）的特征值的平方根。我们使用标准的奇异值分解（SVD）算法计算 $D^{(1)}$ 和 $D^{(2)}$ 的奇异值，并在每种情况下取最大值以求得谱范数。\n\n### 7. 算法总结\n对于每个给定的 $N$ 值：\n1.  生成 $N+1$ 个切比雪夫-高斯-洛巴托点 $x_j = \\cos(\\pi j / N)$。\n2.  生成对应的 $N+1$ 个重心权重 $w_j = (-1)^j \\delta_j$。\n3.  构建 $(N+1) \\times (N+1)$ 矩阵 $D^{(1)}$：\n    a. 对于 $j \\neq k$，计算 $D^{(1)}_{j,k} = \\frac{w_k}{w_j}\\frac{1}{x_j - x_k}$。\n    b. 对于对角线元素，计算 $D^{(1)}_{j,j} = - \\sum_{k \\neq j} D^{(1)}_{j,k}$。\n4.  计算 $D^{(2)} = D^{(1)} @ D^{(1)}$。\n5.  计算 $D^{(1)}$ 的奇异值并找到最大值以获得 $\\|D^{(1)}\\|_2$。\n6.  计算 $D^{(2)}$ 的奇异值并找到最大值以获得 $\\|D^{(2)}\\|_2$。\n7.  存储数值对 $[\\left\\|D^{(1)}\\right\\|_2, \\left\\|D^{(2)}\\right\\|_2]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library, numpy, or scipy are permitted.\n# Note: scipy is permitted but not necessary for this solution.\n\ndef build_chebyshev_diff_matrices(N):\n    \"\"\"\n    Constructs the Chebyshev first and second differentiation matrices.\n\n    Args:\n        N (int): The degree of the polynomial interpolant. The grid will have N+1 points.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the first (D1) and second (D2)\n                                       differentiation matrices.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([[0.]])\n    \n    # Grid points (Chebyshev-Gauss-Lobatto)\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n\n    # Barycentric weights\n    w = (-1.0)**j\n    w[0] *= 0.5\n    w[-1] *= 0.5\n\n    # Construct the first differentiation matrix D1\n    N_plus_1 = N + 1\n    D1 = np.zeros((N_plus_1, N_plus_1))\n    \n    # Off-diagonal entries using broadcasting\n    # w_k / w_j term\n    w_ratio = w[np.newaxis, :] / w[:, np.newaxis]\n    # x_j - x_k term\n    x_diff = x[:, np.newaxis] - x[np.newaxis, :]\n\n    # To avoid division by zero on the diagonal, we temporarily set diagonal of x_diff to 1.\n    # The diagonal of D1 will be correctly computed later.\n    np.fill_diagonal(x_diff, 1)\n    D1 = w_ratio / x_diff\n    \n    # Correct the diagonal of D1, which was filled with temporary values.\n    # We set it to 0 before summing the rows.\n    np.fill_diagonal(D1, 0)\n    \n    # Diagonal entries: D1_jj = -sum(D1_jk for k!=j)\n    # The sum of each row must be zero.\n    row_sums = np.sum(D1, axis=1)\n    np.fill_diagonal(D1, -row_sums)\n    \n    # Second differentiation matrix\n    D2 = D1 @ D1\n\n    return D1, D2\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 8, 32, 128]\n\n    results = []\n    for N in test_cases:\n        # Build the differentiation matrices for the current N.\n        D1, D2 = build_chebyshev_diff_matrices(N)\n        \n        # Compute the spectral norm (largest singular value) for D1.\n        # np.linalg.svd returns singular values in descending order.\n        # Using compute_uv=False is more efficient as we only need singular values.\n        s1 = np.linalg.svd(D1, compute_uv=False)\n        norm_D1 = s1[0] if len(s1) > 0 else 0.0\n\n        # Compute the spectral norm for D2.\n        s2 = np.linalg.svd(D2, compute_uv=False)\n        norm_D2 = s2[0] if len(s2) > 0 else 0.0\n\n        # Store the rounded results.\n        results.append((norm_D1, norm_D2))\n\n    # Format the final output string exactly as required.\n    # Each float must be formatted to 10 decimal places.\n    output_pairs = []\n    for res_pair in results:\n        norm1_str = f\"{res_pair[0]:.10f}\"\n        norm2_str = f\"{res_pair[1]:.10f}\"\n        output_pairs.append(f\"[{norm1_str},{norm2_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(output_pairs)}]\")\n\nsolve()\n```", "id": "3446562"}, {"introduction": "拥有了微分矩阵这一工具后，我们便可以着手求解微分方程。然而，将连续的微分方程离散化为代数系统后，一个关键的挑战是如何正确地施加边界条件或内部约束。本练习通过一个具体的常微分方程 (ODE) 问题，对比了两种施加内部约束的常见技术：“陶氏修正法” (tau correction) 和“基函数修正法” (basis modification) [@problem_id:3446566]。通过亲手实现并比较这两种方法的精度和线性系统的条件数，您将深刻理解不同约束处理方式对解的准确性和数值稳定性的根本性影响。", "problem": "考虑在区间 $[-1,1]$ 上的线性常微分方程 (ODE) $u^{\\prime}(x) = g(x)$，其内部约束为 $u(0) = 0$。设未知函数 $u(x)$ 由一个 $N$ 次多项式阶数的全局第一类切比雪夫级数近似，即 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$，其中 $T_k(x)$ 表示第 $k$ 个第一类切比雪夫多项式。右端项由 $g(x) = e^x + \\sin(3x)$ 指定。与该约束一致的精确解为 $u(x) = \\int_{0}^{x} g(s)\\, ds = e^x - 1 + \\frac{1 - \\cos(3x)}{3}$。\n\n您的任务是比较在切比雪夫基中用于施加内部约束的两种谱方法，重点关注其精度和线性系统条件数：\n\n1. 通过丢弃常数模态进行基修正：从未知数中消除常数系数 $a_0$，并在切比雪夫系数空间中使用导数方程 $u^{\\prime}(x) = g(x)$ 求解一个降维方阵系统以得到其余系数。求解后，设置 $a_0 = 0$。此方法不直接使用内部约束，而是依赖于移除与常数相关的零空间。\n\n2. 通过约束替换进行 Tau 修正：在切比雪夫系数空间中构建一个方阵系统，使 $u^{\\prime}(x)$ 的切比雪夫系数与 $g(x)$ 的系数相等，然后用线性约束 $u(0) = 0$ 替换其中一个方程（一行）。该约束在系数空间中可以写为 $\\sum_{k=0}^{N} a_k T_k(0) = 0$，其中 $T_k(0) = \\cos(k \\pi / 2)$。\n\n使用以下基本事实和定义从第一性原理设计您的算法：\n\n- 第一类切比雪夫多项式满足 $T_k(\\cos \\theta) = \\cos(k \\theta)$。\n- $N$ 阶全局切比雪夫级数近似为 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$。\n- 系数空间中的微分是线性的：如果 $a = (a_0,\\dots,a_N)^{\\top}$ 是 $u$ 的系数，则存在一个矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，使得 $u^{\\prime}$ 的切比雪夫系数 $b = (b_0,\\dots,b_N)^{\\top}$ 满足 $b = M a$。算子 $M$ 有一个对应于常数的一维零空间。\n- 内部约束在系数上是线性的：$u(0) = \\sum_{k=0}^{N} a_k \\cos(k \\pi/2) = 0$。\n- 第一类离散余弦变换 (DCT-I) 实现了 $T_k$ 在切比雪夫-洛巴托网格 $x_j = \\cos(\\pi j/N)$，$j = 0,\\dots,N$ 上的离散正交性，从而允许在函数值和切比雪夫系数之间进行转换。如果 $y_j = f(x_j)$，那么 $N$ 阶插值多项式的切比雪夫系数 $(\\hat{f}_k)_{k=0}^{N}$ 满足 $\\hat{f} = c/N$，并带有端点修正 $\\hat{f}_0 \\leftarrow \\hat{f}_0/2$，$\\hat{f}_N \\leftarrow \\hat{f}_N/2$，其中 $c$ 是 $y$ 的 DCT-I。\n\n算法要求：\n\n- 通过将导数的切比雪夫系数的精确递推关系应用于基向量，构建系数空间微分算子 $M$：\n  - 如果 $u(x) = \\sum_{k=0}^{N} a_k T_k(x)$，则通过切比雪夫级数的标准微分递推关系定义 $b = (b_k)_{k=0}^{N}$，这会产生一个线性映射 $b = M a$。通过将此映射应用于 $\\mathbb{R}^{N+1}$ 中的每个标准基向量来实现此映射并组装 $M$。\n- 通过在切比雪夫-洛巴托点上对 $g$ 进行采样，并使用第一类离散余弦变换 (DCT-I) 将函数值转换为系数（如上所述），来获得 $g$ 的切比雪夫系数。\n- 方法 1 (基修正)：从 $M$ 中移除与 $a_0$ 对应的列，得到 $M_{\\text{red}} \\in \\mathbb{R}^{(N+1)\\times N}$。为了得到一个方阵系统，移除一个方程行（选择最后一行）以获得 $\\tilde{M}_{\\text{red}} \\in \\mathbb{R}^{N \\times N}$，并将得到的前 $N$ 个方程与 $g$ 系数向量的相应项匹配。求解 $(a_1,\\dots,a_N)$ 并设置 $a_0 = 0$。\n- 方法 2 (tau 修正)：构建 $M$ 并用系数空间中表示为 $c^{\\top} a = 0$ 的约束 $u(0) = 0$ 替换一个方程行（选择最后一行），其中 $c_k = \\cos(k \\pi/2)$。求解得到的方阵系统以得到 $(a_0,\\dots,a_N)$。\n\n精度和条件数指标：\n\n- 对于每种方法，使用切比雪夫级数在切比雪夫-洛巴托网格上重构近似解，并计算最大绝对误差 $E_{\\infty} = \\max_{0 \\leq j \\leq N} |u_N(x_j) - u(x_j)|$，其中 $u(x)$ 是上面给出的精确解。\n- 对于每个线性系统，报告 2-范数条件数 $\\kappa_2(A)$，其中 $A$ 是该方法中实际求解的方阵。\n\n所有三角函数的角度单位必须是弧度。\n\n您的程序必须实现这两种方法，并为以下多项式阶数的测试套件生成结果：\n- $N = 8$ (粗分辨率)，\n- $N = 16$ (标准情况)，\n- $N = 33$ (奇数阶，网格点不包含 $x=0$)，\n- $N = 64$ (更高分辨率)。\n\n对于上述顺序中的每个 $N$，计算并输出四元组 $[E_{\\infty}^{\\text{basis}}, E_{\\infty}^{\\text{tau}}, \\kappa_2^{\\text{basis}}, \\kappa_2^{\\text{tau}}]$，其中误差和条件数均为浮点数。将所有结果按照测试套件指定的顺序汇总到一个扁平列表中，并打印包含此列表的单行，格式为逗号分隔并用方括号括起，例如 $[r_1,r_2,\\dots]$，不带任何额外文本。不涉及物理单位，所有角度必须是弧度。", "solution": "所给问题是使用谱方法进行常微分方程数值求解的一个有效练习。它引导我们比较两种不同的一阶 ODE 内部点约束施加方法。该问题是适定的，其科学基础在于数值分析和逼近理论的原理，并且求解所需的所有组件都已明确定义。\n\n问题的核心是在定义域 $x \\in [-1, 1]$ 上求解线性常微分方程 $u^{\\prime}(x) = g(x)$，并满足内部值约束 $u(0) = 0$。右端项由 $g(x) = e^x + \\sin(3x)$ 给出。同时满足微分方程和约束的解析解是 $u(x) = e^x - 1 + \\frac{1 - \\cos(3x)}{3}$。\n\n我们采用一种基于全局多项式逼近的谱方法。未知函数 $u(x)$ 由第一类切比雪夫多项式的截断级数近似，即 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$，其中 $a_k$ 是未知的谱系数。\n\n**谱离散化**\n\n第一步是将连续的微分方程转换为关于系数 $a_k$ 的代数方程组。微分算子 $\\frac{d}{dx}$ 在多项式空间上作为线性算子作用。如果向量 $a = [a_0, a_1, \\dots, a_N]^\\top$ 包含 $u_N(x)$ 的切比雪夫系数，那么其导数 $u_N^{\\prime}(x) = \\sum_{k=0}^{N} b_k T_k(x)$ 的系数由线性变换 $b = Ma$ 给出。这里，$M$ 是系数空间中 $(N+1) \\times (N+1)$ 的切比雪夫微分矩阵。$M$ 的元素源于切比雪夫级数导数系数的递推关系。具体来说，$M$ 的第 $j$ 列由第 $j$ 个基函数 $T_j^{\\prime}(x)$ 的导数的切比雪夫系数构成。\n\n右端项函数 $g(x)$ 也在切比雪夫基中表示，其系数为 $\\hat{g} = [\\hat{g}_0, \\hat{g}_1, \\dots, \\hat{g}_N]^\\top$。这些系数可以通过在 $N+1$ 个切比雪夫-洛巴托点 $x_j = \\cos(\\pi j / N)$（其中 $j = 0, \\dots, N$）上对 $g(x)$ 进行采样，然后应用按比例缩放的第一类离散余弦变换 (DCT-I) 来高效计算，具体方法如问题陈述中所指定。\n\n微分方程的离散形式是线性系统 $Ma = \\hat{g}$。然而，微分算子有一个对应于常数函数的一维零空间（因为常数的导数为零）。因此，矩阵 $M$ 是奇异的，系统 $Ma = \\hat{g}$ 没有唯一解。需要内部约束 $u(0)=0$ 来从可能解的族 $u(x) = C + \\int_0^x g(s) ds$ 中选择出唯一的正确解。\n\n我们比较两种引入此约束的方法。\n\n**方法 1：基修正**\n\n此方法通过修改逼近空间本身来保证唯一性。它寻求形式为 $u_N(x) = \\sum_{k=1}^{N} a_k T_k(x)$ 的解，这等同于强制系数 $a_0$ 为零。系数 $a_0$ 与函数的加权平均值成正比，$a_0 \\propto \\int_{-1}^1 u(x) (1-x^2)^{-1/2} dx$。因此，设置 $a_0=0$ 施加的是一个积分约束，而不是点约束 $u(0)=0$。因此，预计此方法会产生一个对于本问题来说根本上不正确的解，从而导致较大的误差。\n\n在算法上，其实现如下：\n1.  移除 $M$ 中与 $a_0$ 对应的列，得到一个矩形矩阵 $M_{\\text{red}} \\in \\mathbb{R}^{(N+1)\\times N}$。系统变为 $M_{\\text{red}} [a_1, \\dots, a_N]^\\top = \\hat{g}$。\n2.  这是一个包含 $N+1$ 个方程和 $N$ 个未知数的超定系统。为了创建一个方阵系统，我们丢弃一个方程。根据问题的指示，我们移除最后一个方程（对应于最高频率模态 $T_N$）。这会产生一个方阵系统 $\\tilde{M}_{\\text{red}} [a_1, \\dots, a_N]^\\top = [\\hat{g}_0, \\dots, \\hat{g}_{N-1}]^\\top$，其中 $\\tilde{M}_{\\text{red}} \\in \\mathbb{R}^{N\\times N}$。\n3.  求解此系统以得到系数 $[a_1, \\dots, a_N]^\\top$。然后以 $a_0=0$ 组装完整的系数向量。\n\n**方法 2：Tau 修正**\n\n此方法是 Tau 方法的一个变体，它在完整的逼近空间 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$ 中工作，并将约束直接整合到代数系统中。\n1.  从完整的奇异系统 $Ma = \\hat{g}$ 开始。\n2.  内部约束 $u(0)=0$ 是关于系数的一个线性方程：$\\sum_{k=0}^{N} a_k T_k(0) = 0$。由于 $T_k(0) = \\cos(k\\pi/2)$，该方程为 $\\sum_{k=0}^{N} a_k \\cos(k\\pi/2) = 0$。\n3.  为了使系统非奇异并引入约束，用约束方程替换 $Ma = \\hat{g}$ 中的一个原始方程。选择替换哪个方程是 Tau 方法的一个关键方面；一个常见且有效的选择是替换对应于最高频率模态的方程，因为其对整体精度的贡献通常最小。根据问题要求，我们将系统的最后一行 $(Ma)_N = \\hat{g}_N$ 替换为约束行。\n4.  这会产生一个新的、非奇异的方阵系统 $A_{\\text{tau}} a = \\hat{g}_{\\text{tau}}$，求解该系统可得到完整的系数向量 $a$。此方法正确地施加了指定的约束，预计将具有很高的精度。\n\n**比较指标**\n\n两种方法的评估基于：\n1.  **精度**：在切比雪夫-洛巴托网格上评估的最大绝对误差 $E_{\\infty} = \\max_{j} |u_N(x_j) - u(x_j)|$。\n2.  **条件数**：每种方法中求解的最终线性系统矩阵 $A$ 的 2-范数条件数 $\\kappa_2(A)$。大的条件数表示对扰动的敏感性和潜在的数值不稳定性。\n\n实现过程将是为每个指定的多项式阶数 $N$ 构建必要的矩阵和向量，并求解相应的线性系统以找出误差和条件数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct\n\ndef solve():\n    \"\"\"\n    Implements and compares two spectral methods for solving u'(x) = g(x) with u(0)=0.\n    1. Basis modification: assumes a_0=0, solves a reduced system.\n    2. Tau correction: replaces the highest-frequency equation with the constraint u(0)=0.\n    \"\"\"\n\n    def g_func(x):\n        \"\"\"The right-hand side function of the ODE.\"\"\"\n        return np.exp(x) + np.sin(3 * x)\n\n    def u_exact(x):\n        \"\"\"The exact solution of the ODE with the given constraint.\"\"\"\n        return np.exp(x) - 1.0 + (1.0 - np.cos(3 * x)) / 3.0\n\n    def get_cheb_diff_matrix(N):\n        \"\"\"\n        Constructs the (N+1)x(N+1) Chebyshev differentiation matrix M.\n        The j-th column of M contains the Chebyshev coefficients of T_j'(x).\n        \"\"\"\n        M = np.zeros((N + 1, N + 1))\n        # Apply differentiation to each basis vector T_j(x)\n        for j in range(N + 1):\n            a = np.zeros(N + 1)\n            a[j] = 1.0  # Coefficients of T_j(x)\n            \n            # Compute coefficients of the derivative using the standard recurrence.\n            # If u(x) = sum(a_k T_k(x)), u'(x) = sum(b_k T_k(x)) where\n            # b_k = (2/c_k) * sum_{p=k+1, p-k odd}^N p * a_p with c_0=2, c_k=1 else.\n            b = np.zeros(N + 1)\n            for k in range(N - 1, -1, -1):\n                s = 0.0\n                for p in range(k + 1, N + 1, 2):\n                    s += p * a[p]\n                \n                ck = 2.0 if k == 0 else 1.0\n                b[k] = (2.0 / ck) * s\n            M[:, j] = b\n        return M\n\n    def get_g_coeffs(N):\n        \"\"\"\n        Computes Chebyshev coefficients of g(x) on an (N+1)-point Lobatto grid\n        using the specified DCT-I based algorithm.\n        \"\"\"\n        x = np.cos(np.pi * np.arange(N + 1) / N)\n        y = g_func(x)\n        \n        # Following the recipe in the problem statement\n        c = dct(y, type=1)\n        ghat = c / N\n        ghat[0] /= 2.0\n        ghat[N] /= 2.0\n        return ghat\n\n    def reconstruct_from_coeffs(N, a):\n        \"\"\"\n        Reconstructs function values on the Lobatto grid from Chebyshev coefficients\n        using direct summation: u(x_j) = sum_k a_k T_k(x_j).\n        \"\"\"\n        j_indices = np.arange(N + 1).reshape(-1, 1)\n        k_indices = np.arange(N + 1)\n        # T_k(x_j) = cos(k*pi*j/N)\n        eval_matrix = np.cos(np.pi * j_indices * k_indices / N)\n        return eval_matrix @ a\n\n    test_cases = [8, 16, 33, 64]\n    all_results = []\n\n    for N in test_cases:\n        # --- Common Setup for degree N ---\n        lobatto_points = np.cos(np.pi * np.arange(N + 1) / N)\n        u_exact_vals = u_exact(lobatto_points)\n        \n        M = get_cheb_diff_matrix(N)\n        ghat = get_g_coeffs(N)\n\n        # --- Method 1: Basis Modification ---\n        # System for [a_1, ..., a_N] after removing a_0\n        M_red = M[:, 1:]  # Shape: (N+1) x N\n        # Make square by removing last equation row\n        tilde_M_red = M[:N, 1:] # Shape: N x N\n        g_red = ghat[:N] # Corresponding RHS\n\n        kappa_basis = np.linalg.cond(tilde_M_red, 2)\n        try:\n            a_tail = np.linalg.solve(tilde_M_red, g_red)\n            a_basis = np.concatenate(([0.0], a_tail))\n            u_basis_vals = reconstruct_from_coeffs(N, a_basis)\n            E_inf_basis = np.max(np.abs(u_basis_vals - u_exact_vals))\n        except np.linalg.LinAlgError:\n            E_inf_basis = np.inf\n            kappa_basis = np.inf\n\n\n        # --- Method 2: Tau Correction ---\n        A_tau = M.copy()\n        g_tau = ghat.copy()\n        \n        # Constraint row: c^T a = 0, where c_k = T_k(0) = cos(k*pi/2)\n        constraint_row = np.cos(np.pi * np.arange(N + 1) / 2.0)\n        \n        # Replace last row of system with the constraint\n        A_tau[-1, :] = constraint_row\n        g_tau[-1] = 0.0\n        \n        kappa_tau = np.linalg.cond(A_tau, 2)\n        try:\n            a_tau = np.linalg.solve(A_tau, g_tau)\n            u_tau_vals = reconstruct_from_coeffs(N, a_tau)\n            E_inf_tau = np.max(np.abs(u_tau_vals - u_exact_vals))\n        except np.linalg.LinAlgError:\n            E_inf_tau = np.inf\n            kappa_tau = np.inf\n\n        all_results.extend([E_inf_basis, E_inf_tau, kappa_basis, kappa_tau])\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3446566"}, {"introduction": "谱方法的真正威力通常体现在为多维问题设计“快速算法”上。本练习将引导您分析一个用于求解二维泊松型方程 (Poisson-like equation) 的快速直接求解器的计算复杂度。该求解器巧妙地结合了傅里叶 (Fourier) 谱方法处理周期性方向和切比雪夫 (Chebyshev) 谱方法处理非周期性方向 [@problem_id:3446498]。这个实践不要求您从零开始实现整个复杂算法，而是让您学会如何根据其核心组件（如快速傅里叶变换和带状矩阵求解器）来预估其计算成本，这是评估和设计高效数值算法的一项核心技能。", "problem": "考虑二维屏蔽泊松方程，该方程定义在一个在一个方向上周期性而另一个方向上非周期性的带状区域上，在非周期性边界上具有齐次狄利克雷边界条件。具体来说，令 $u(x,y)$ 满足\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) - \\alpha\\,u(x,y) = f(x,y),\n$$\n其中 $(x,y) \\in [0,2\\pi) \\times [-1,1]$，对于所有 $x$，$u(x,-1) = 0$ 和 $u(x,1) = 0$，并且在 $x$ 方向上具有周期 $2\\pi$。假设 $\\alpha > 0$ 是一个固定常数。\n\n请在以下原则和约束条件下，设计一个快速直接求解器，该求解器在周期性的 $x$ 方向上使用快速傅里叶变换 (FFT)，在 $y$ 方向的切比雪夫全局基下使用带状求解器：\n\n- 在周期性方向，使用全局傅里叶基函数进行展开，并通过变换到傅里叶空间来对角化二阶导数 $\\frac{\\partial^2}{\\partial x^2}$，从而将偏微分方程简化为一组由傅里葉波数索引的、在 $y$ 方向上解耦的常微分方程。\n- 在非周期性方向，使用第一类全局切比雪夫多项式 $T_n(y)$ 在 $y$ 定义域 $[-1,1]$ 上使用切比雪夫-高斯-洛巴托点进行离散化，并强制施加齐次狄利克雷边界条件。使用的表示法和算法设计应能为每个傅里叶模式生成一个带状线性系统，其带宽独立于截断大小，以便可以应用带状直接求解器，其复杂度与每个模式的未知数数量成线性关系。\n\n您必须从以下基本知识出发：\n- 关于在 $[0,2\\pi)$ 上周期函数的傅里叶级数表示，以及傅里葉变换可对角化周期方向上常系数线性微分算子的性质。\n- 关于在 $[-1,1]$ 上的全局切比雪夫多项式基，其配置点为 $y_j = \\cos\\left(\\frac{\\pi j}{N_y-1}\\right)$，其中 $j=0,1,\\ldots,N_y-1$，以及一个原理，即当在类切比雪夫基的系数空间中表示时，适当选择的超球或等效公式可以为常系数微分方程产生带状算子。\n- 经过充分验证的复杂度事实：对 $N$ 个点进行快速傅里叶变换需要 $\\mathcal{O}(N \\log N)$ 次算术运算，对一个大小为 $M$、上下固定带宽分别为 $\\beta_u$ 和 $\\beta_\\ell$ 的带状线性系统进行直接高斯消元法需要 $\\mathcal{O}\\!\\left(M(\\beta_u+\\beta_\\ell)^2\\right)$ 次算术运算。\n\n您的实现任务是编写一个程序，给定周期性傅里叶方向的截断大小 $N_x$ 和非周期性切比雪夫方向的截断大小 $N_y$，根据 $N_x$ 和 $N_y$ 预测所设计的快速直接求解器的归一化算术运算计数。您必须使用以下归一化复杂度模型：\n- 在所有 $N_y$ 个配置行上沿 $x$ 方向的 FFT 阶段成本为 $C_{\\mathrm{FFT}}(N_x,N_y) = N_x\\,N_y\\,\\log_2(N_x)$ 归一化单位。\n- 对于所有 $N_x$ 个傅里叶模式，每个模式在切比雪夫系数空间中产生一个 $N_y \\times N_y$ 的带状系统，其带状直接求解阶段的成本为 $C_{\\mathrm{band}}(N_x,N_y) = N_x\\,N_y\\,(\\beta_u+\\beta_\\ell)^2$ 归一化单位，其中 $(\\beta_u+\\beta_\\ell)$ 是所选全局基带状公式产生的切比雪夫方向算子的固定总半带宽。\n- 因此，总归一化算术运算计数为 $C_{\\mathrm{total}}(N_x,N_y) = C_{\\mathrm{FFT}}(N_x,N_y) + C_{\\mathrm{band}}(N_x,N_y)$。\n\n假设在切比雪夫方向上，一个常系数算子和一个标准的超球型构造产生了一个固定的总半带宽 $(\\beta_u+\\beta_\\ell) = 2$。这表示算子结构中有两个非对角线，其不随 $N_y$ 增长。\n\n您的程序必须为以下截断大小的测试套件计算 $C_{\\mathrm{total}}(N_x,N_y)$：\n- 测试用例 1：$N_x = 64$, $N_y = 65$。\n- 测试用例 2：$N_x = 1$, $N_y = 33$。\n- 测试用例 3：$N_x = 1024$, $N_y = 257$。\n- 测试用例 4：$N_x = 2$, $N_y = 2$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"），其中每个结果是相应测试用例的总归一化算术运算计数 $C_{\\mathrm{total}}(N_x,N_y)$，表示为浮点数。不涉及物理单位。如果存在角度，必须以弧度为单位；但是，此问题不要求在输出中指定角度。此问题不使用百分比。\n\n程序必须是自包含的，并且不需要用户输入。", "solution": "该问题已经过验证，被确定为是合理的。它具有科学依据，提法明確且客观。计算指定的算术运算计数所需的所有必要数据和定义均已提供。该问题描述了在圆柱域上求解屏蔽泊松方程的标准傅里叶-切比雪夫谱方法，并且为快速傅里叶变换和带状线性系统求解器提供的复杂度模型是数值分析中的标准模型。为切比雪夫离散化实现固定带宽算子的前提是高等谱方法中的一个已知结果，这使得该设置与既有理论一致。\n\n该问题要求计算二维屏蔽泊松方程的快速直接求解器的总归一化算术运算计数 $C_{\\mathrm{total}}(N_x, N_y)$：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) - \\alpha\\,u(x,y) = f(x,y)\n$$\n定义域为 $(x,y) \\in [0,2\\pi) \\times [-1,1]$。边界条件在 $x$ 方向是周期性的，在 $y$ 方向是齐次狄利克雷条件，即 $u(x,-1) = 0$ 和 $u(x,1) = 0$。常数 $\\alpha$ 为正。\n\n该求解器策略包括两个主要阶段：\n1. 在周期性的 $x$ 方向应用傅里葉谱方法。解 $u(x,y)$ 和源项 $f(x,y)$ 展开为傅里葉级数：\n$$\nu(x,y) = \\sum_{k=-(N_x/2-1)}^{N_x/2} \\hat{u}_k(y) e^{ikx}\n$$\n其中 $N_x$ 是傅里叶模式的数量。算子 $\\frac{\\partial^2}{\\partial x^2}$ 被傅里叶变换对角化，在第 $k$ 个模式上相当于乘以 $(ik)^2 = -k^2$。这将二维偏微分方程 (PDE) 简化为关于傅里叶系数 $\\hat{u}_k(y)$ 的一组 $N_x$ 个解耦的一维常微分方程 (ODE)：\n$$\n\\frac{d^2 \\hat{u}_k}{d y^2}(y) - k^2 \\hat{u}_k(y) - \\alpha \\hat{u}_k(y) = \\hat{f}_k(y)\n$$\n简化为：\n$$\n\\frac{d^2 \\hat{u}_k}{d y^2}(y) - (k^2 + \\alpha) \\hat{u}_k(y) = \\hat{f}_k(y)\n$$\n对于每个波数 $k$。边界条件变为 $\\hat{u}_k(-1) = 0$ 和 $\\hat{u}_k(1) = 0$。\n\n2. 这 $N_x$ 个 ODE中的每一个都使用切比雪夫配置法在 $N_y$ 个切比雪夫-高斯-洛巴托点上求解。问题陈述指出，所选的公式对每个 $\\hat{u}_k(y)$ 的切比雪夫系数产生一个带状线性系统。\n\n总复杂度是傅里葉变换阶段和带状求解器阶段成本的总和。\n\n傅里叶变换阶段的成本 $C_{\\mathrm{FFT}}$ 涉及对 $N_y$ 个配置行中的每一行沿 $x$ 方向应用快速傅里叶变换 (FFT)。其归一化复杂度由下式给出：\n$$\nC_{\\mathrm{FFT}}(N_x, N_y) = N_x\\,N_y\\,\\log_2(N_x)\n$$\n\n带状求解器阶段的成本 $C_{\\mathrm{band}}$ 涉及求解 $N_x$ 个独立的带状线性系统，每个傅里叶模式 $k$ 对应一个。每个系统的大小约为 $N_y$ 阶。问题为此阶段提供了总归一化复杂度：\n$$\nC_{\\mathrm{band}}(N_x, N_y) = N_x\\,N_y\\,(\\beta_u+\\beta_\\ell)^2\n$$\n其中 $(\\beta_u+\\beta_\\ell)$ 是总半带宽。问题指定该值固定为 $(\\beta_u+\\beta_\\ell) = 2$。因此，公式变为：\n$$\nC_{\\mathrm{band}}(N_x, N_y) = N_x\\,N_y\\,(2)^2 = 4\\,N_x\\,N_y\n$$\n\n总归一化算术运算计数是这两个成本的总和：\n$$\nC_{\\mathrm{total}}(N_x, N_y) = C_{\\mathrm{FFT}}(N_x, N_y) + C_{\\mathrm{band}}(N_x, N_y) \\\\\nC_{\\mathrm{total}}(N_x, N_y) = N_x\\,N_y\\,\\log_2(N_x) + 4\\,N_x\\,N_y \\\\\nC_{\\mathrm{total}}(N_x, N_y) = N_x\\,N_y\\,(\\log_2(N_x) + 4)\n$$\n我们现在将此公式应用于给定的测试用例。\n\n测试用例 1：$N_x = 64$, $N_y = 65$。\n$\\log_2(64) = 6$。\n$C_{\\mathrm{total}}(64, 65) = 64 \\times 65 \\times (\\log_2(64) + 4) = 4160 \\times (6 + 4) = 4160 \\times 10 = 41600$。\n\n测试用例 2：$N_x = 1$, $N_y = 33$。\n$\\log_2(1) = 0$。\n$C_{\\mathrm{total}}(1, 33) = 1 \\times 33 \\times (\\log_2(1) + 4) = 33 \\times (0 + 4) = 33 \\times 4 = 132$。\n\n测试用例 3：$N_x = 1024$, $N_y = 257$。\n$\\log_2(1024) = 10$。\n$C_{\\mathrm{total}}(1024, 257) = 1024 \\times 257 \\times (\\log_2(1024) + 4) = 263168 \\times (10 + 4) = 263168 \\times 14 = 3684352$。\n\n测试用例 4：$N_x = 2$, $N_y = 2$。\n$\\log_2(2) = 1$。\n$C_{\\mathrm{total}}(2, 2) = 2 \\times 2 \\times (\\log_2(2) + 4) = 4 \\times (1 + 4) = 4 \\times 5 = 20$。\n\n这些值将由程序计算得出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized arithmetic operation count for a fast direct solver\n    on the 2D screened Poisson equation using a Fourier-Chebyshev spectral method.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is of the form (N_x, N_y).\n    test_cases = [\n        (64, 65),\n        (1, 33),\n        (1024, 257),\n        (2, 2),\n    ]\n\n    results = []\n    \n    # The total half-bandwidth is given as a fixed constant.\n    total_half_bandwidth = 2.0\n\n    for case in test_cases:\n        Nx, Ny = case\n        \n        # The cost formula for the FFT stage is given as:\n        # C_FFT = Nx * Ny * log2(Nx)\n        # Note: log2(1) = 0, which is correctly handled by np.log2.\n        # If Nx is not a power of 2, the FFT is still well-defined,\n        # though practical implementations might be more efficient for powers of 2.\n        # The formula given must be used as is.\n        c_fft = float(Nx) * float(Ny) * np.log2(float(Nx))\n        \n        # The cost formula for the banded solver stage is given as:\n        # C_band = Nx * Ny * (beta_u + beta_l)^2\n        c_band = float(Nx) * float(Ny) * (total_half_bandwidth**2)\n        \n        # The total normalized arithmetic operation count is the sum of the two.\n        c_total = c_fft + c_band\n        \n        results.append(c_total)\n\n    # Final print statement in the exact required format.\n    # The output format must be \"[result1,result2,result3,result4]\" with floating-point numbers.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3446498"}]}