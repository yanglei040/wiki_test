{"hands_on_practices": [{"introduction": "为了建立对混叠现象的扎实理解，从第一性原理出发亲眼见证其发生过程至关重要。第一个练习将引导您在一个稀疏网格上，分析性地计算一个简单函数的离散傅里叶变换。通过这个过程，您将直接观察到一个高频分量如何变得与一个低频分量无法区分——这正是混叠现象——并量化其对谱系数的影响 [@problem_id:3362811]。", "problem": "考虑周期函数 $u(x) = \\sin(3x) + \\sin(9x)$，该函数在区间 $[0,2\\pi)$ 上，于 $N=8$ 个等间距网格点上采样，点的位置为 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0,1,\\dots,N-1$。设离散傅里叶变换 (DFT) 定义为\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1,\n$$\n其逆变换为\n$$\nu(x_j) \\;=\\; \\frac{1}{N}\\sum_{k=0}^{N-1} \\hat{u}_k\\,\\exp\\!\\left(\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right).\n$$\n从这些定义出发，并基于关于周期采样和三角恒等式的基本原理，推导当 $N=8$ 时精确的 DFT 系数 $\\hat{u}_k$（其中 $k=0,1,\\dots,N-1$）。在你的推导中，指明对于 $\\sin(3x)$ 和 $\\sin(9x)$ 这两个分量，哪些离散索引携带非零能量，并解释由于在 $N=8$ 上采样，哪个高频分量混叠到了哪个索引，以及其复振幅是多少。最后，将 $\\hat{u}_k$（$k=0,1,\\dots,7$）的完整向量写成一个单行。不需要数值四舍五入。以精确形式表示所有数学量。", "solution": "问题要求推导函数 $u(x) = \\sin(3x) + \\sin(9x)$ 在 $N=8$ 个点的网格上采样后的离散傅里叶变换 (DFT) 系数 $\\hat{u}_k$。\n\n给定函数为 $u(x) = \\sin(3x) + \\sin(9x)$。采样点为 $x_j = \\frac{2\\pi j}{N}$，其中 $j=0, 1, \\dots, N-1$。采样序列 $u(x_j)$ 的 DFT 由下式给出\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1.\n$$\n为了从基本原理出发，我们使用欧拉公式 $\\sin(\\theta) = \\frac{1}{2\\mathrm{i}}(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta})$ 来表示正弦函数。\n函数 $u(x)$ 可以写成四个复指数的和：\n$$\nu(x) = \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}3x} - e^{-\\mathrm{i}3x}\\right) + \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}9x} - e^{-\\mathrm{i}9x}\\right)\n$$\n由于 DFT 的线性性质，我们可以分别求出每个分量的变换然后将结果相加。让我们分析一个在网格上采样的通用复指数项 $f_m(x) = e^{\\mathrm{i}mx}$ 的 DFT，其中 $m$ 是一个整数波数。在网格点 $x_j$ 处，这变为 $f_m(x_j) = e^{\\mathrm{i}m(2\\pi j/N)} = \\exp(\\frac{2\\pi \\mathrm{i} m j}{N})$。\n\n该序列的 DFT 是\n$$\n\\hat{f}_{m,k} = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} m j}{N}\\right) \\exp\\left(-\\frac{2\\pi \\mathrm{i} k j}{N}\\right) = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k) j}{N}\\right)\n$$\n这是一个几何级数。根据离散复指数的正交性，这个和的计算结果为：\n$$\n\\sum_{j=0}^{N-1} \\left(\\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k)}{N}\\right)\\right)^j =\n\\begin{cases}\nN  \\text{若 } m-k \\text{ 是 } N \\text{ 的整数倍} \\\\\n0  \\text{否则}\n\\end{cases}\n$$\n由于 DFT 索引 $k$ 在范围 $\\{0, 1, \\dots, N-1\\}$ 内，条件“$m-k$ 是 $N$ 的整数倍”简化为 $k \\equiv m \\pmod N$。对于任何整数波数 $m$，在此范围内都存在一个唯一的索引 $k$ 满足该同余关系。\n\n现在我们将此结果应用于 $u(x)$ 中 $N=8$ 的四个指数项中的每一项。\n\n分量 1：$\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}3x}$。这里，波数是 $m=3$。同余关系 $k \\equiv 3 \\pmod 8$ 由 $k=3$ 满足。这一项对 DFT 系数 $\\hat{u}_3$ 有贡献。其贡献是其振幅乘以 $N$：$\\frac{1}{2\\mathrm{i}} \\times N = \\frac{N}{2\\mathrm{i}} = -\\frac{\\mathrm{i}N}{2}$。\n\n分量 2：$-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}3x}$。这里，波数是 $m=-3$。同余关系 $k \\equiv -3 \\pmod 8$ 由 $k=-3+8=5$ 满足。这一项对 $\\hat{u}_5$ 有贡献。其贡献是其振幅乘以 $N$：$-\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{N}{2\\mathrm{i}} = \\frac{\\mathrm{i}N}{2}$。\n因此，$\\sin(3x)$ 分量的能量位于索引 $k=3$ 和 $k=5$ 处。\n\n分量 3：$\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}9x}$。这里，波数是 $m=9$。这里发生了混叠。对于 $N=8$ 个点的网格，奈奎斯特频率对应的波数为 $N/2=4$。由于 $|m|=9 > 4$，该频率被混叠。我们从同余关系 $k \\equiv 9 \\pmod 8$ 中找到它的混叠索引 $k$。因为 $9=1 \\times 8 + 1$，我们得到 $k=1$。在离散网格上，这个高频分量与波数 $m=1$ 的分量无法区分。它对 DFT 的贡献在索引 $\\hat{u}_1$ 处。振幅是 $\\frac{1}{2\\mathrm{i}}$，所以贡献是 $\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{\\mathrm{i}N}{2}$。\n\n分量 4：$-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}9x}$。这里，波数是 $m=-9$。同余关系是 $k \\equiv -9 \\pmod 8$。因为 $-9=-2 \\times 8 + 7$，我们得到 $k=7$。（或者，$-9 \\equiv -1 \\pmod 8$，这对应于索引 $k=N-1=7$）。这个分量混叠到波数为 $m=-1$ 的模式上。它对 DFT 的贡献在索引 $\\hat{u}_7$ 处。振幅是 $-\\frac{1}{2\\mathrm{i}}$，所以贡献是 $-\\frac{1}{2\\mathrm{i}} \\times N = \\frac{\\mathrm{i}N}{2}$。\n高频分量 $\\sin(9x)$ 在网格上混叠到低频分量 $\\sin(x)$，因为 $e^{\\mathrm{i}9x_j}=e^{\\mathrm{i}9(2\\pi j/8)}=e^{\\mathrm{i}(8+1)(2\\pi j/8)}=e^{\\mathrm{i}2\\pi j}e^{\\mathrm{i}1(2\\pi j/8)}=e^{\\mathrm{i}x_j}$。类似地，$e^{-\\mathrm{i}9x_j}=e^{-\\mathrm{i}x_j}$。$\\sin(9x)$ 分量的能量混叠到索引 $k=1$ 和 $k=7$ 处。\n\n我们通过对 $N=8$ 的每个索引 $k \\in \\{0, 1, \\dots, 7\\}$ 的贡献求和，来组装 DFT 系数的完整向量 $\\hat{u}_k$。\n- $\\hat{u}_0 = 0$，因为没有零频（常数）项。\n- $\\hat{u}_1$：来自混叠的 $e^{\\mathrm{i}9x}$ 项的贡献：$-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$。\n- $\\hat{u}_2 = 0$。\n- $\\hat{u}_3$：来自 $e^{\\mathrm{i}3x}$ 项的贡献：$-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$。\n- $\\hat{u}_4 = 0$。\n- $\\hat{u}_5$：来自 $e^{-\\mathrm{i}3x}$ 项的贡献：$\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$。（索引 $k=5 = 8-3$）。\n- $\\hat{u}_6 = 0$。\n- $\\hat{u}_7$：来自混叠的 $e^{-\\mathrm{i}9x}$ 项的贡献：$\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$。（索引 $k=7 = 8-1$）。\n\nDFT 系数的完整向量是 $(\\hat{u}_0, \\hat{u}_1, \\hat{u}_2, \\hat{u}_3, \\hat{u}_4, \\hat{u}_5, \\hat{u}_6, \\hat{u}_7)$。\n代入计算出的值得到：\n$$\n(0, -4\\mathrm{i}, 0, -4\\mathrm{i}, 0, 4\\mathrm{i}, 0, 4\\mathrm{i})\n$$\n这个结果反映了一个性质：对于一个实值输入信号 $u(x_j)$，DFT 系数必须满足共轭对称性质 $\\hat{u}_k = \\overline{\\hat{u}_{N-k}}$，其中 $k=1, \\dots, N-1$。\n我们来检查一下：\n$\\hat{u}_1 = -4\\mathrm{i}$，$\\hat{u}_{8-1}=\\hat{u}_7 = 4\\mathrm{i}$。$\\overline{\\hat{u}_7} = -4\\mathrm{i} = \\hat{u}_1$。正确。\n$\\hat{u}_2 = 0$，$\\hat{u}_{8-2}=\\hat{u}_6 = 0$。$\\overline{\\hat{u}_6} = 0 = \\hat{u}_2$。正确。\n$\\hat{u}_3 = -4\\mathrm{i}$，$\\hat{u}_{8-3}=\\hat{u}_5 = 4\\mathrm{i}$。$\\overline{\\hat{u}_5} = -4\\mathrm{i} = \\hat{u}_3$。正确。\n$\\hat{u}_4=0$，$\\hat{u}_{8-4}=\\hat{u}_4=0$。这个系数必须是实数，它确实是。正确。\n推导是一致的。", "answer": "$$\n\\boxed{\\pmatrix{0  -4\\mathrm{i}  0  -4\\mathrm{i}  0  4\\mathrm{i}  0  4\\mathrm{i}}}\n$$", "id": "3362811"}, {"introduction": "理解了什么是混叠之后，下一步是学习如何防止它。本练习聚焦于“$3/2$规则”的实际实现，这是一种广泛用于处理二次非线性项的去混叠技术。您将编写一个简短的程序来验证，通过在变换前对谱数据进行补零，伪谱乘积的结果能够精确匹配已解析模态的、无混叠的精确卷积结果 [@problem_id:3362836]。", "problem": "考虑一个在一维、$N$ 个点的均匀网格上表示的 $2\\pi$ 周期函数及其离散傅里叶变换 (DFT)。设 DFT 的约定与标准数值库所使用的约定相同：网格函数 $u_j$（$j=0,\\dots,N-1$）的正向 DFT 由下式给出：\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\, e^{-2\\pi i j k / N},\n$$\n逆 DFT 由下式给出：\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\, e^{2\\pi i j k / N}.\n$$\n物理空间中的逐点乘法对应于谱空间中的循环卷积。具体来说，对于乘积 $w_j = u_j v_j$，我们有：\n$$\n\\widehat{w}_k = \\frac{1}{N} \\sum_{p=0}^{N-1} \\hat{u}_p \\, \\hat{v}_{(k-p) \\bmod N}.\n$$\n混叠的产生是由于谱卷积是模 $N$ 计算的。当输入谱带限于 $|k| \\le K_{\\max}$，且我们关心 $|k| \\le K_{\\max}$ 内的乘积谱时，将谱零填充至更长的长度 $M$（满足 $M \\ge \\frac{3}{2} N$，即所谓的“三分之二”规则），并在此更高分辨率下执行伪乘积，可以防止解析频带内的卷积发生环绕，从而消除二次非线性项的混叠。\n\n你的任务是实现一个当 $N=12$ 且输入谱的支撑集在 $|k| \\le 4$ 内时的计算，以证明以下陈述：\n对于所有解析模式 $|k| \\le 4$，三分之二填充（零填充至 $M = \\frac{3}{2} N = 18$）所产生的谱系数 $\\widehat{(uv)}_k$ 与精确的、无混叠的卷积结果相同。\n$$\n\\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p},\n$$\n其中 $k-p$ 在 $[-4,4]$ 之外的项被视为零。换句话说，当 $u$ 和 $v$ 的谱在 $|k| \\le 4$ 之外为零，并且通过长度为 $M=18$ 的逆 DFT 形成乘积时，物理空间中的乘法后接正向 DFT 会产生：\n$$\n\\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p}\n$$\n对于所有 $|k| \\le 4$，没有循环环绕影响这些模式。\n\n实现一个程序，该程序：\n- 在 $N=12$ 的网格上构建支撑集在 $|k| \\le 4$ 内的测试谱 $\\hat{u}_k$ 和 $\\hat{v}_k$，使用偶数 $N$ 的 $N$ 点 DFT 分箱约定表示：整数波数 $k$ 对应于 DFT 分箱，其中 $k=0,1,\\dots,5,-6,-5,\\dots,-1$ 分别映射到索引 $0,1,\\dots,5,6,7,\\dots,11$。\n- 通过将相同的 $\\hat{u}_k$ 和 $\\hat{v}_k$ 值放置在 $k=-4,-3,\\dots,4$ 对应的 $M$ 点 DFT 分箱中，构建长度为 $M=18$ 的零填充谱（当 $M$ 为偶数时，分箱对应于 $k=0,1,\\dots,8,-9,-8,\\dots,-1$ 映射到索引 $0,1,\\dots,8,9,10,\\dots,17$）。\n- 通过长度为 $M$ 的逆 DFT 变换到物理空间、进行逐点乘法，然后通过正向 DFT 变换回谱空间，从而计算填充后的伪乘积，从 $M$ 点变换中得到 $|k| \\le 4$ 的 $\\widehat{(uv)}_k^{\\mathrm{pad}}$。\n- 使用上述带有因子 $\\frac{1}{M}$ 的线性（非模）和，计算 $|k| \\le 4$ 的精确、无混叠卷积系数 $\\widehat{(uv)}_k^{\\mathrm{exact}}$，并将 $p$ 或 $q$ 在 $[-4,4]$ 之外的 $\\hat{u}_p$ 和 $\\hat{v}_{q}$ 视为零。\n- 对每个测试用例，报告最大绝对差异：\n$$\n\\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right|.\n$$\n\n设计一个包含四个用例的测试套件，以检验不同的方面：\n1. 一个一般情况，其中 $\\hat{u}_k$ 和 $\\hat{v}_k$ 在 $k=-4,\\dots,4$ 范围内具有随机复系数，使用固定的随机种子以保证可复现性。\n2. 一个边界情况，其中只有最高解析模式非零：$\\hat{u}_{\\pm 4}$ 和 $\\hat{v}_{\\pm 4}$ 非零，所有其他系数为零。\n3. 一个实值函数情况，其中 $\\hat{u}_k$ 满足埃尔米特对称性 $\\hat{u}_{-k} = \\overline{\\hat{u}_k}$ 且 $\\hat{u}_0$ 为实数，而 $\\hat{v}_k$ 为一般复数，两者的支撑集都在 $|k| \\le 4$ 内。\n4. 一个常数乘以带限函数的情况：$\\hat{u}_0$ 非零，所有其他 $\\hat{u}_k=0$，而 $\\hat{v}_k$ 是支撑集在 $|k| \\le 4$ 内的一般复数。\n\n对于每种情况，你的程序应按上述规定计算最大差异。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：\n$$\n[\\text{e}_1,\\text{e}_2,\\text{e}_3,\\text{e}_4]\n$$\n其中每个 $\\text{e}_i$ 是一个浮点数。不涉及任何物理单位或角度单位。所有四个输出都必须是浮点数。预期结果是每个 $\\text{e}_i$ 都在机器精度的数量级上，从而证明在给定条件下，三分之二填充能够为解析频带 $|k| \\le 4$ 再现精确的、无混叠的卷积。", "solution": "问题陈述要求在谱方法背景下，对用于二次非线性的三分之二 ($3/2$) 去混叠规则进行数值验证。该问题在科学上是合理的、适定的，并且为其求解提供了所有必要的参数和定义。这是理解谱变换机理和混叠控制的一个典型练习。\n\n所测试的基本原理是，物理空间中两个函数 $u(x)$ 和 $v(x)$ 的逐点乘法对应于谱空间中它们谱 $\\hat{u}_k$ 和 $\\hat{v}_k$ 的卷积。当在 $N$ 个点的有限网格上使用离散傅里叶变换 (DFT) 时，这种卷积变成循环的（即模 $N$）。这种循环性可能导致乘积的高频分量“环绕”并污染低频分量，这种效应称为混叠。\n\n三分之二规则是为消除这种混叠而采用的更通用的零填充或填充方法的一种特定形式。如果输入函数 $u$ 和 $v$ 是带限的，其谱仅在波数 $|k| \\le K_{\\max}$ 范围内非零，那么它们的乘积 $w = uv$ 的谱将带限于 $|k| \\le 2K_{\\max}$。为防止在原始解析频带（$|k| \\le K_{\\max}$）内发生混叠，我们必须在足够大的网格上执行计算，以确保不发生环绕。对二次非线性的条件是，填充后的网格大小 $M$ 必须满足 $M > 3K_{\\max}$。\n\n在此问题中，给定 $N=12$，输入谱带限于 $K_{\\max}=4$。三分之二规则建议填充到 $M = \\frac{3}{2}N = 18$。这满足去混叠条件，因为 $M=18 > 3K_{\\max} = 3 \\times 4 = 12$。任务是证明对于解析模式 $|k| \\le 4$，此填充计算的结果与精确的、无混叠的卷积和相同。\n\n解决方案通过实现和比较计算乘积谱 $\\widehat{(uv)}_k$ 的两种路径来进行。\n\n**路径 1：填充伪谱乘积 $\\widehat{(uv)}_k^{\\mathrm{pad}}$**\n\n此路径模拟了谱方法代码中使用的数值过程。\n1.  **谱表示**：为每个测试用例生成输入谱系数 $\\hat{u}_k$ 和 $\\hat{v}_k$（$|k| \\le 4$）。\n2.  **零填充**：将两个长度为 $M=18$ 的复值数组初始化为零。输入系数 $\\hat{u}_k$ 和 $\\hat{v}_k$ 被放置到这些数组中与它们各自的波数 $k \\in [-4, 4]$ 对应的索引处。对于给定的变换大小，从波数 $k$ 到 DFT 数组索引的映射由标准库函数（如 `numpy.fft.fftfreq`）提供。对于 $M=18$，整数波数的排序为 $k=0, 1, \\dots, 8, -9, -8, \\dots, -1$。\n3.  **变换到物理空间**：对每个填充后的谱数组 $\\hat{u}^{\\mathrm{pad}}$ 和 $\\hat{v}^{\\mathrm{pad}}$ 应用大小为 $M$ 的逆 DFT，以获得在填充后的物理网格上的相应函数 $u_j$ 和 $v_j$（$j=0, \\dots, M-1$）。遵循给定的标准约定，逆 DFT 包含一个归一化因子 $1/M$：\n    $$u_j = \\frac{1}{M} \\sum_{k} \\hat{u}^{\\mathrm{pad}}_k e^{2\\pi i j k / M}$$\n4.  **逐点乘法**：在 $M$ 点物理网格上对函数进行逐点相乘：$w_j = u_j v_j$。\n5.  **变换到谱空间**：对乘积 $w_j$ 应用大小为 $M$ 的正向 DFT，以获得其谱 $\\widehat{(uv)}_k^{\\mathrm{pad}}$。\n\n**路径 2：精确的无混叠卷积 $\\widehat{(uv)}_k^{\\mathrm{exact}}$**\n\n此路径计算数学上精确的线性卷积和，它作为基准真相。DFT 的卷积定理指出，填充过程产生：\n$$ \\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p} \\hat{u}^{\\mathrm{pad}}_p \\hat{v}^{\\mathrm{pad}}_{(k-p) \\pmod M} $$\n如前所述，对于 $|k| \\le 4$、$|p| \\le 4$ 和 $M=18$，波数之和 $p+(k-p)$ 不会混叠到感兴趣的范围内。因此，模运算是无关紧要的，其结果应与线性卷积匹配。我们直接计算这个和：\n$$ \\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\hat{v}_{k-p} $$\n其中，如果输入系数 $\\hat{u}_p$ 和 $\\hat{v}_{k-p}$ 对应的波数在 $[-4, 4]$ 范围之外，则它们被视为零。对每个目标波数 $k \\in [-4, 4]$ 计算此和。\n\n**比较与验证**\n\n对于四个测试用例中的每一个，程序计算原始解析频带 $|k| \\le 4$ 中所有波数的 $\\widehat{(uv)}_k^{\\mathrm{pad}}$ 和 $\\widehat{(uv)}_k^{\\mathrm{exact}}$。然后计算两条路径结果之间的最大绝对差：\n$$ \\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right| $$\n正如理论所预测的，这个差值应在机器浮点精度的数量级上，从而数值上证明了三分之二填充规则成功地消除了解析谱模式的混叠误差。这四个测试用例旨在探究不同场景（一般、边界、实值、常数），以确保此结论的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_discrepancy(u_hat_coeffs, v_hat_coeffs, M, K_max):\n    \"\"\"\n    Calculates the maximum discrepancy between the padded pseudospectral product\n    and the exact non-aliased convolution.\n\n    Args:\n        u_hat_coeffs (dict): Coefficients for u_hat, mapping k - value.\n        v_hat_coeffs (dict): Coefficients for v_hat, mapping k - value.\n        M (int): Padded grid size.\n        K_max (int): Maximum wavenumber for inputs.\n\n    Returns:\n        float: The maximum absolute discrepancy.\n    \"\"\"\n    # Define the wavenumbers we are interested in for both input and output.\n    wavenumbers_of_interest = list(range(-K_max, K_max + 1))\n\n    # --- Path 1: Padded Pseudospectral Product ---\n\n    # Map integer wavenumbers to their indices in the M-point DFT array.\n    k_vals_M = np.fft.fftfreq(M, 1/M)\n    k_map_M = {int(round(k)): i for i, k in enumerate(k_vals_M)}\n\n    # Create M-length spectral arrays and populate them (zero-padding).\n    u_hat_M = np.zeros(M, dtype=complex)\n    v_hat_M = np.zeros(M, dtype=complex)\n    \n    for k in wavenumbers_of_interest:\n        # Check if the wavenumber k is representable on the M-grid\n        if k in k_map_M:\n            idx = k_map_M[k]\n            u_hat_M[idx] = u_hat_coeffs.get(k, 0)\n            v_hat_M[idx] = v_hat_coeffs.get(k, 0)\n\n    # IFFT to physical space, pointwise multiply, then FFT back to spectral space.\n    # numpy's ifft includes the 1/M normalization factor as per the problem.\n    u_M = np.fft.ifft(u_hat_M)\n    v_M = np.fft.ifft(v_hat_M)\n    w_M = u_M * v_M\n    w_hat_padded = np.fft.fft(w_M)\n\n    # --- Path 2: Exact Non-Aliased Convolution ---\n\n    w_hat_exact = {}\n    for k in wavenumbers_of_interest:\n        conv_sum = 0.0 + 0.0j\n        # Sum over p from -K_max to K_max\n        for p in wavenumbers_of_interest:\n            u_p = u_hat_coeffs.get(p, 0)\n            # v_q where q = k-p. .get() handles cases where k-p is out of band.\n            v_k_minus_p = v_hat_coeffs.get(k - p, 0)\n            conv_sum += u_p * v_k_minus_p\n        \n        w_hat_exact[k] = (1 / M) * conv_sum\n\n    # --- Comparison ---\n\n    max_discrepancy = 0.0\n    for k in wavenumbers_of_interest:\n        # Get the coefficient from the padded product result array.\n        idx = k_map_M[k]\n        val_padded = w_hat_padded[idx]\n        \n        # Get the coefficient from the exact convolution calculation.\n        val_exact = w_hat_exact[k]\n        \n        discrepancy = np.abs(val_padded - val_exact)\n        if discrepancy  max_discrepancy:\n            max_discrepancy = discrepancy\n\n    return max_discrepancy\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print results.\n    \"\"\"\n    # Define problem parameters\n    N = 12\n    M = int(N * 3 / 2)  # M = 18\n    K_max = 4\n\n    wavenumbers = list(range(-K_max, K_max + 1))\n    \n    # --- Test Case Generation ---\n\n    # Case 1: General case with random complex coefficients\n    rng1 = np.random.default_rng(seed=123)\n    u_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n    v_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 2: Boundary case where only the highest resolved modes are nonzero\n    rng2 = np.random.default_rng(seed=456)\n    u_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n    v_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n\n    # Case 3: Real-valued function u (Hermitian symmetry)\n    rng3 = np.random.default_rng(seed=789)\n    u_hat_3 = {}\n    u_hat_3[0] = rng3.uniform(-1, 1)  # u_0 must be real\n    for k in range(1, K_max + 1):\n        val = rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1)\n        u_hat_3[k] = val\n        u_hat_3[-k] = np.conj(val)\n    v_hat_3 = {k: rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 4: Constant times band-limited case (u has only k=0 mode)\n    rng4 = np.random.default_rng(seed=101)\n    u_hat_4 = {0: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1)}\n    v_hat_4 = {k: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1) for k in wavenumbers}\n    \n    test_cases = [\n        (u_hat_1, v_hat_1),\n        (u_hat_2, v_hat_2),\n        (u_hat_3, v_hat_3),\n        (u_hat_4, v_hat_4),\n    ]\n\n    results = []\n    for u_coeffs, v_coeffs in test_cases:\n        discrepancy = calculate_discrepancy(u_coeffs, v_coeffs, M, K_max)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362836"}, {"introduction": "最后，我们将理论与技术联系到实际应用中，通过模拟一个偏微分方程。本练习涉及为伯格斯方程（Burgers equation）建立一个伪谱求解器，用以测量混叠所带来的物理后果，特别是能量向低波数模态的虚假注入。通过对比使用和不使用去混叠的模拟结果，您将对为何控制混叠对于数值模拟的稳定性和准确性至关重要，获得一个切实的理解 [@problem_id:3362824]。", "problem": "考虑一维粘性Burgers方程，定义在一个以弧度为单位测量的周期性域上：\n$$\nu_t + \\frac{1}{2}\\partial_x\\left(u^2\\right) = \\nu\\, u_{xx}, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\n其中 $u(x,t)$ 是一个标量场，$\\nu \\ge 0$ 是粘度，且在 $x=0$ 和 $x=2\\pi$ 处施加周期性边界条件。伪谱方法利用快速傅里叶变换 (FFT) 对 $u(x,t)$ 的傅里叶系数 $\\hat{u}_k(t)$ 进行演化，并在物理空间中计算诸如 $u^2$ 的乘积。非线性项在谱空间中的离散卷积可能导致混叠：未解析的三元组 $(k_1,k_2,k_3)$（满足 $k_3=k_1+k_2$）如果位于最高可解析波数之外，会折返回来并虚假地向低阶模态注入能量。一种标准的缓解方法是三分之二去混叠规则，对于二次非线性，该规则将非线性项中所有满足 $|k| > \\lfloor N/3 \\rfloor$ 的傅里叶模态置零，其中 $N$ 是网格点和傅里叶模态的数量。\n\n设计并实现一个数值实验，通过比较无去混叠和使用三分之二规则这两种情况，经验性地描绘由于伪谱离散化粘性Burgers方程所产生的混叠导致的向低阶模态的能量传递。使用以下基本依据：\n\n- $[0,2\\pi]$ 上的傅里叶级数为 $u(x,t) = \\sum_{k=-\\infty}^{\\infty} \\hat{u}_k(t) e^{\\mathrm{i}k x}$，在一个包含 $N$ 个点的离散网格上，可解析的波数为 $k \\in \\{-N/2+1,\\dots,-1,0,1,\\dots,N/2\\}$。\n- 伪谱方法在物理空间中计算 $u^2$，然后变换到傅里叶空间，从而得到 $\\widehat{u^2}_k$ 的离散卷积。\n- 对于任意信号 $u$，离散网格上的Parseval恒等式意味着 $\\sum_{j=0}^{N-1} |u(x_j,t)|^2 = \\frac{1}{N} \\sum_{k} |\\hat{u}_k(t)|^2$，其中 $x_j$ 是网格点。\n- 仅由非线性项 $\\mathcal{N}[u] = -\\frac{1}{2}\\partial_x(u^2)$ 引起的向一组低阶模态 $\\mathcal{K}_\\ell = \\{k: |k| \\le k_\\ell\\}$ 的模态能量传递率定义为\n$$\n\\dot{E}_\\ell(t) = \\frac{1}{N}\\sum_{k \\in \\mathcal{K}_\\ell} \\Re\\left\\{\\hat{u}_k^*(t)\\,\\widehat{\\mathcal{N}[u]}_k(t)\\right\\}。\n$$\n这衡量了在时间 $t$ 时，由非线性相互作用流入低阶模态频带的能量速率。在 $[0,T]$ 上的累积注入能量为 $I = \\int_0^T \\dot{E}_\\ell(t)\\,\\mathrm{d}t$。\n\n您的程序必须：\n\n1. 实现一个用于 $u_t = -\\frac{1}{2}\\partial_x(u^2) + \\nu\\,u_{xx}$ 的伪谱时间积分器，该积分器在傅里叶空间中维持状态，在物理空间中评估非线性项，并使用四阶Runge–Kutta格式。谱空间中的微分算子为 $\\partial_x \\leftrightarrow \\mathrm{i}k$ 和 $\\partial_{xx} \\leftrightarrow -k^2$。\n2. 在每个时间步，从相同的当前状态 $u(\\cdot,t)$ 计算非线性项两次：\n   - 无去混叠：$\\widehat{\\mathcal{N}}^{\\mathrm{unal}}_k(t) = -\\frac{1}{2}\\mathrm{i}k\\,\\widehat{u^2}_k(t)$，不进行滤波。\n   - 使用三分之二规则：$\\widehat{\\mathcal{N}}^{2/3}_k(t) = -\\frac{1}{2}\\mathrm{i}k\\,\\left[\\widehat{u^2}_k(t)\\,\\mathbf{1}_{\\{|k|\\le \\lfloor N/3 \\rfloor\\}}\\right]$，其中 $\\mathbf{1}_{\\{|k|\\le \\lfloor N/3 \\rfloor\\}}$ 是一个指示函数，它将 $|k|$ 超过截止值的模态置零。\n3. 使用经过滤波的非线性项 $\\widehat{\\mathcal{N}}^{2/3}_k(t)$ 与粘性项结合来演化 $u$，以确保在实验进行过程中状态不受混叠污染。\n4. 在每个时间步，使用上述定义测量两种情况下的低阶模态能量传递率 $\\dot{E}_\\ell$，即 $\\dot{E}_\\ell^{\\mathrm{unal}}(t)$ 和 $\\dot{E}_\\ell^{2/3}(t)$。通过黎曼和 $I \\approx \\sum_n \\dot{E}_\\ell(t_n)\\,\\Delta t$ 来近似累积注入能量。\n5. 对于每个测试用例，报告标量 $D = I^{\\mathrm{unal}} - I^{2/3}$，该值量化了由混叠引起的累积的额外低阶模态能量注入。\n\n使用确定性初始条件\n$$\nu(x,0) = A_1\\sin(m_1 x) + A_2\\cos(m_2 x + \\phi) + A_3\\sin(m_3 x),\n$$\n其中 $A_1=1.0$, $A_2=0.8$, $A_3=0.5$, $\\phi=0.3$，以及\n$$\nm_1 = \\left\\lfloor \\frac{N}{4} \\right\\rfloor,\\quad m_2 = \\left\\lfloor \\frac{N}{5} \\right\\rfloor,\\quad m_3 = \\left\\lfloor \\frac{N}{3} \\right\\rfloor - 1.\n$$\n基于Courant–Friedrichs–Lewy (CFL) 约束 $ \\Delta t = \\alpha\\,\\Delta x/\\max_x |u(x,0)|$ 选择时间步长，其中 $\\alpha=0.2$，网格间距 $\\Delta x = 2\\pi/N$，并将步数向上取整为整数，以便精确达到最终时间。\n\n您的程序应使用以下测试套件以确保覆盖不同场景：\n\n- 测试 1 (正常路径): $N=64$, $\\nu=10^{-3}$, $T=0.5$, $k_\\ell=4$。\n- 测试 2 (中等粘度，更多模态): $N=96$, $\\nu=5\\times 10^{-3}$, $T=0.4$, $k_\\ell=8$。\n- 测试 3 (边界情况，低分辨率和零粘度，短时间): $N=32$, $\\nu=0$, $T=0.2$, $k_\\ell=3$。\n- 测试 4 (更高分辨率，更强粘度): $N=128$, $\\nu=10^{-2}$, $T=0.3$, $k_\\ell=6$。\n\n对于每个测试用例，计算如上定义的标量 $D$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。所有量都是无量纲的；角度以弧度为单位，您必须将输出报告为不带单位的普通十进制数。", "solution": "用户提供的问题是有效的。它针对偏微分方程计算解中的一个标准课题，提出了一个定义明确、科学合理并且形式良好的数值实验。所有必要的参数和定义都已提供，并且没有内部矛盾或歧义会妨碍唯一解的得出。\n\n该问题要求量化一维粘性Burgers方程 $u_t + \\frac{1}{2}\\partial_x\\left(u^2\\right) = \\nu\\, u_{xx}$ 在周期性域 $x \\in [0, 2\\pi]$ 上的伪谱模拟中的混叠效应。任务的核心是比较非线性项在施加和未施加三分之二去混叠规则两种情况下，传递到低波数模态的能量。\n\n该解决方案实现为一个伪谱求解器，它在傅里叶空间中演化系统。系统在任何时间 $t$ 的状态由一组傅里叶系数 $\\hat{u}_k(t)$ 表示，其中 $u(x,t) = \\sum_k \\hat{u}_k(t) e^{\\mathrm{i}k x}$。在一个包含 $N$ 个点的离散网格上，波数 $k$ 取整数值，其范围由 $N$ 决定，通常从大约 $-N/2$ 到 $N/2$。\n\n傅里叶空间中的Burgers方程为：\n$$\n\\frac{d\\hat{u}_k}{dt} = \\widehat{\\mathcal{N}[u]}_k + \\widehat{\\mathcal{L}[u]}_k\n$$\n其中 $\\widehat{\\mathcal{L}[u]}_k$ 是线性（粘性）项，$\\widehat{\\mathcal{N}[u]}_k$ 是非线性（平流）项。利用微分等于乘以 $\\mathrm{i}k$ 的性质，线性项在谱空间中精确计算为 $\\widehat{\\mathcal{L}[u]}_k = \\nu \\widehat{u_{xx}}_k = -\\nu k^2 \\hat{u}_k$。\n\n非线性项 $\\mathcal{N}[u] = -\\frac{1}{2}\\partial_x(u^2)$ 采用伪谱方法处理，以避免在傅里叶空间中进行计算成本高昂的卷积。步骤如下：\n1. 将状态转换到物理空间：$u(x_j) = \\text{iFFT}(\\hat{u}_k)$。\n2. 在物理空间中计算二次乘积：$u^2(x_j)$。\n3. 将乘积转换回傅里叶空间：$\\widehat{u^2}_k = \\text{FFT}(u^2(x_j))$。\n4. 应用谱微分：$\\widehat{\\mathcal{N}[u]}_k = -\\frac{1}{2}(\\mathrm{i}k) \\widehat{u^2}_k$。\n\n这个过程会引入混叠误差。两个频带限制在 $|k| \\le K_{\\max}$ 的信号相乘，会产生频率高达 $|k| \\le 2K_{\\max}$ 的信号。在一个解析到 $|k| \\approx N/2$ 的离散网格上，任何超出此限制的频率成分都会被混叠或“折返”到解析的波数范围内，表现为对低阶模态的虚假贡献。对于二次非线性，三分之二去混叠规则可以缓解此问题。它涉及截断傅里叶变换后的乘积项 $\\widehat{u^2}_k$，将所有 $|k| > \\lfloor N/3 \\rfloor$ 的模态置零。这确保了最终非线性项中的最高波数 $2\\lfloor N/3 \\rfloor$ 小于 $N - \\lfloor N/3 \\rfloor$，从而防止混叠模态污染保留的模态 $|k| \\le \\lfloor N/3 \\rfloor$。\n\n该数值实验旨在隔离并测量混叠误差。系统的状态 $\\hat{u}_k(t)$ 使用四阶Runge-Kutta (RK4) 格式进行演化。关键的是，时间演化步骤始终使用去混叠的非线性项 $\\widehat{\\mathcal{N}}^{2/3}_k$，以确保参考状态不受污染。在每个时间步 $t_n$，在进行RK4更新之前，使用当前状态 $\\hat{u}_k(t_n)$ 来计算瞬时能量传递到一个低阶模态频带 $\\mathcal{K}_\\ell = \\{k : |k| \\le k_\\ell\\}$ 的速率。该速率定义为 $\\dot{E}_\\ell(t) = \\frac{1}{N}\\sum_{k \\in \\mathcal{K}_\\ell} \\Re\\left\\{\\hat{u}_k^*(t)\\,\\widehat{\\mathcal{N}[u]}_k(t)\\right\\}$。我们为两种情况计算它：\n1. $\\dot{E}_\\ell^{\\mathrm{unal}}(t_n)$，使用原始的、有混叠的非线性项 $\\widehat{\\mathcal{N}}^{\\mathrm{unal}}_k$。\n2. $\\dot{E}_\\ell^{2/3}(t_n)$，使用去混叠的非线性项 $\\widehat{\\mathcal{N}}^{2/3}_k$。\n\n在积分时间 $[0, T]$ 内注入低阶模态频带的累积能量通过黎曼和近似，$I \\approx \\sum_n \\dot{E}_\\ell(t_n) \\Delta t$。最终报告的量 $D = I^{\\mathrm{unal}} - I^{2/3}$ 代表了由于混叠而虚假注入低阶模态的总多余能量。\n\n实现细节如下。初始条件直接在谱空间中构建，以避免采样带来的离散化误差。时间步长 $\\Delta t$ 根据基于初始最大速度的CFL条件确定，并调整步数以确保精确达到最终时间 $T$。该算法使用Python中的`numpy`库实现，以进行高效的FFT计算和数组操作。求解器遍历所提供的测试用例，为每个用例计算 $D$，并报告结果。", "answer": "```python\nimport numpy as np\nfrom scipy import __version__ as scipy_version\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n\n    def solve_case(N, nu, T, k_ell):\n        \"\"\"\n        Solves one test case for the Burgers equation aliasing problem.\n        \n        Args:\n            N (int): Number of grid points.\n            nu (float): Viscosity coefficient.\n            T (float): Total integration time.\n            k_ell (int): Cutoff wavenumber for low-mode energy measurement.\n\n        Returns:\n            float: The scalar quantity D, representing excess aliased energy.\n        \"\"\"\n        # Grid and wavenumbers\n        # We use the standard numpy.fft.fftfreq convention {-N/2, ..., N/2-1} for even N.\n        # This is required for compatibility with numpy's FFT algorithms.\n        dx = 2 * np.pi / N\n        k = np.fft.fftfreq(N, d=1.0 / N)  # Integer wavenumbers for domain [0, 2pi]\n\n        # Initial condition parameters\n        A1, A2, A3, phi = 1.0, 0.8, 0.5, 0.3\n        m1 = int(np.floor(N / 4))\n        m2 = int(np.floor(N / 5))\n        m3 = int(np.floor(N / 3)) - 1\n        \n        # Construct initial condition in spectral space\n        u_hat0 = np.zeros(N, dtype=np.complex128)\n        k_indices = {int(ki): i for i, ki in enumerate(k)}\n\n        # A1*sin(m1*x) = A1 * (e^{im1x} - e^{-im1x}) / 2i\n        if m1 in k_indices: u_hat0[k_indices[m1]] += A1 * N / (2j)\n        if -m1 in k_indices: u_hat0[k_indices[-m1]] -= A1 * N / (2j)\n        \n        # A2*cos(m2*x + phi) = A2 * (e^{i(m2x+phi)} + e^{-i(m2x+phi)}) / 2\n        if m2 in k_indices: u_hat0[k_indices[m2]] += A2 * N / 2 * np.exp(1j * phi)\n        if -m2 in k_indices: u_hat0[k_indices[-m2]] += A2 * N / 2 * np.exp(-1j * phi)\n\n        # A3*sin(m3*x)\n        if m3 in k_indices: u_hat0[k_indices[m3]] += A3 * N / (2j)\n        if -m3 in k_indices: u_hat0[k_indices[-m3]] -= A3 * N / (2j)\n\n        # Time step calculation\n        u_phys0 = np.fft.ifft(u_hat0)\n        u_max = np.max(np.abs(u_phys0))\n        alpha = 0.2\n        \n        if u_max  1e-9:\n            dt_cfl = alpha * dx / u_max\n        else:\n            # Fallback for zero initial condition, though not expected here\n            dt_cfl = 1e-3 \n\n        num_steps = int(np.ceil(T / dt_cfl))\n        dt = T / num_steps\n        \n        # Masks for dealiasing and energy measurement\n        dealias_cutoff = int(np.floor(N / 3))\n        dealias_mask = np.abs(k) = dealias_cutoff\n        low_mode_mask = np.abs(k) = k_ell\n        \n        # RK4 right-hand-side function (evolves with dealiasing)\n        def rhs(u_hat_in):\n            u_phys = np.fft.ifft(u_hat_in)\n            u_sq_phys = u_phys**2\n            u_sq_hat = np.fft.fft(u_sq_phys)\n            \n            # Apply 2/3 dealiasing rule\n            u_sq_hat_dealiased = u_sq_hat * dealias_mask\n            \n            nonlinear_term = -0.5j * k * u_sq_hat_dealiased\n            viscous_term = -nu * (k**2) * u_hat_in\n            return nonlinear_term + viscous_term\n\n        # Initialize state and cumulative energy sums\n        u_hat = u_hat0.copy()\n        I_unal = 0.0\n        I_23 = 0.0\n        \n        # Time integration loop\n        for _ in range(num_steps):\n            # Measure energy transfer rate at the start of the step\n            u_phys = np.fft.ifft(u_hat)\n            u_sq_phys = u_phys**2\n            u_sq_hat = np.fft.fft(u_sq_phys)\n            \n            # Unaliased nonlinear term\n            N_hat_unal = -0.5j * k * u_sq_hat\n            # Dealiased nonlinear term\n            N_hat_23 = N_hat_unal * dealias_mask\n\n            # Energy transfer rates into low modes\n            Edot_unal = (1/N) * np.real(np.sum(np.conj(u_hat) * N_hat_unal * low_mode_mask))\n            Edot_23 = (1/N) * np.real(np.sum(np.conj(u_hat) * N_hat_23 * low_mode_mask))\n            \n            # Accumulate energy injection (Riemann sum)\n            I_unal += Edot_unal * dt\n            I_23 += Edot_23 * dt\n            \n            # Evolve state using RK4\n            k1 = rhs(u_hat)\n            k2 = rhs(u_hat + dt / 2 * k1)\n            k3 = rhs(u_hat + dt / 2 * k2)\n            k4 = rhs(u_hat + dt * k3)\n            u_hat += dt / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n            \n        D = I_unal - I_23\n        return D\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 1e-3, 0.5, 4),    # Test 1\n        (96, 5e-3, 0.4, 8),    # Test 2\n        (32, 0.0, 0.2, 3),     # Test 3\n        (128, 1e-2, 0.3, 6),   # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, nu, T, k_ell = case\n        result = solve_case(N, nu, T, k_ell)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362824"}]}