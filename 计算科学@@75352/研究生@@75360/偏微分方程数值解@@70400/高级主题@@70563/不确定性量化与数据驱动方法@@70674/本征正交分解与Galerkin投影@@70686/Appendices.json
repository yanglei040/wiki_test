{"hands_on_practices": [{"introduction": "为了建立对POD-Galerkin方法的直观理解和信任，我们从一个理想化的场景开始。本练习采用“人造解”方法，即我们构造一个精确解，使其始终位于一个已知的低维子空间内。通过对一个线性偏微分方程（热传导方程）进行此项操作，我们将通过计算验证，只要我们选择的POD基的维度足够高，降阶模型就能够完美地复现完整模型的动态行为，从而得到零误差。这个练习清晰地展示了POD方法的核心威力：识别并利用系统内在的低维结构。[@problem_id:3435994]", "problem": "考虑在开区间 $\\left(0,1\\right)$ 上具有齐次狄利克雷（Dirichlet）边界条件和恒定扩散系数的一维扩散偏微分方程（PDE），并设在 $n$ 个内部网格点上使用标准的二阶中心有限差分半离散化方法。将得到的半离散状态向量记为 $u\\left(t\\right) \\in \\mathbb{R}^{n}$。该半离散模型是一个线性时不变系统\n$$\n\\frac{d}{dt} u\\left(t\\right) \\;=\\; A\\,u\\left(t\\right), \\quad A \\;=\\; \\nu\\,L_{h},\n$$\n其中 $\\nu \\in \\mathbb{R}_{+}$ 是扩散系数，$L_{h} \\in \\mathbb{R}^{n \\times n}$ 是三对角离散拉普拉斯算子，其元素为\n$$\n\\left(L_{h}\\right)_{i,i} \\;=\\; -\\frac{2}{h^{2}}, \\quad \\left(L_{h}\\right)_{i,i+1} \\;=\\; \\left(L_{h}\\right)_{i+1,i} \\;=\\; \\frac{1}{h^{2}}, \\quad h \\;=\\; \\frac{1}{n+1}, \\quad i \\;=\\; 1,\\dots,n-1.\n$$\n矩阵 $A$ 是实对称负定的，因此可以进行特征分解 $A \\;=\\; V \\Lambda V^{\\top}$，得到正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 和对角元素严格为负的对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$。对于任意初始条件 $u\\left(0\\right)$，其精确解为\n$$\nu\\left(t\\right) \\;=\\; V\\,e^{\\Lambda t}\\,V^{\\top} u\\left(0\\right).\n$$\n\n你需要设计一个制造解（manufactured-solution）实验，在该实验中，全阶模型的解精确地位于少数选定特征模态的张成空间内，然后通过计算验证，当本征正交分解（POD, Proper Orthogonal Decomposition）的阶数不小于活跃模态数量时，POD 结合到 POD 子空间上的伽辽金（Galerkin）投影能够恢复相同的张成空间，并产生零投影误差。请遵循以下基于原理的步骤。\n\n1) 子空间不变性与制造解。选择一个小的模态索引集 $\\mathcal{K} \\subset \\left\\{1,\\dots,n\\right\\}$，其大小为 $r_{\\mathrm{true}}$（活跃模态的数量）。令 $V_{\\mathcal{K}} \\in \\mathbb{R}^{n \\times r_{\\mathrm{true}}}$ 表示一个矩阵，其列是 $A$ 对应的特征向量，按相关特征值的绝对值升序排列。选择一个非零系数向量 $a \\in \\mathbb{R}^{r_{\\mathrm{true}}}$ 并设置\n$$\nu\\left(0\\right) \\;=\\; V_{\\mathcal{K}}\\,a, \\qquad u\\left(t\\right) \\;=\\; V_{\\mathcal{K}}\\,\\exp\\!\\left(\\Lambda_{\\mathcal{K}} t\\right) a,\n$$\n其中 $\\Lambda_{\\mathcal{K}} \\in \\mathbb{R}^{r_{\\mathrm{true}} \\times r_{\\mathrm{true}}}$ 是对角特征值子矩阵。根据构造，对于所有 $t \\ge 0$，$u\\left(t\\right)$ 都位于 $\\mathrm{span}\\!\\left(V_{\\mathcal{K}}\\right)$ 中，这是一个 $A$-不变子空间。\n\n2) 快照收集与 POD。构建快照矩阵 $X \\in \\mathbb{R}^{n \\times m}$，其列为在 $m$ 个不同时刻 $0 = t_1  t_2  \\dots  t_m = T$ 的 $u\\left(t_{j}\\right)$。计算奇异值分解（SVD, singular value decomposition）$X \\;=\\; U \\Sigma W^{\\top}$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是非负对角矩阵，$W \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵。对于给定的 POD 阶数 $r_{\\mathrm{pod}}$，将 POD 基定义为 $U$ 的前 $r_{\\mathrm{pod}}$ 列，记为 $\\Phi \\in \\mathbb{R}^{n \\times r_{\\mathrm{pod}}}$。\n\n3) POD 投影误差。到 POD 子空间的正交投影算子是 $P \\;=\\; \\Phi \\Phi^{\\top}$。快照的归一化投影误差为\n$$\n\\mathcal{E}_{\\mathrm{proj}} \\;=\\; \\frac{\\left\\| X \\;-\\; P X \\right\\|_{F}}{\\left\\| X \\right\\|_{F}},\n$$\n其中 $\\left\\|\\cdot\\right\\|_{F}$ 表示弗罗贝尼乌斯（Frobenius）范数。如果 $r_{\\mathrm{pod}} \\ge r_{\\mathrm{true}}$ 且 $\\mathrm{rank}\\left(X\\right) = r_{\\mathrm{true}}$，那么在精确计算中 $\\mathcal{E}_{\\mathrm{proj}}$ 必须为零。\n\n4) POD-伽辽金降阶模型。构建伽辽金投影的降阶算子\n$$\nA_{r} \\;=\\; \\Phi^{\\top} A \\Phi \\;\\in\\; \\mathbb{R}^{r_{\\mathrm{pod}} \\times r_{\\mathrm{pod}}},\n$$\n以及降阶初始状态 $c\\left(0\\right) \\;=\\; \\Phi^{\\top} u\\left(0\\right)$。演化该降阶模型\n$$\n\\frac{d}{dt} c\\left(t\\right) \\;=\\; A_{r}\\,c\\left(t\\right), \\qquad c\\left(t\\right) \\;=\\; e^{A_{r} t} c\\left(0\\right),\n$$\n并重构降阶状态 $u_{r}\\left(t\\right) \\;=\\; \\Phi\\,c\\left(t\\right)$。计算最终时刻的相对误差\n$$\n\\mathcal{E}_{\\mathrm{final}} \\;=\\; \\frac{\\left\\| u\\left(T\\right) - u_{r}\\left(T\\right) \\right\\|_{2}}{\\left\\| u\\left(T\\right) \\right\\|_{2}}.\n$$\n如果 $r_{\\mathrm{pod}} \\ge r_{\\mathrm{true}}$，则根据不变性，在精确计算中 $u_{r}\\left(t\\right) \\equiv u\\left(t\\right)$，因此 $\\mathcal{E}_{\\mathrm{final}} = 0$。\n\n实现一个程序，该程序根据 $\\nu$ 和 $n$ 构造 $A$，计算其特征分解，根据选定的模态和系数制造 $u\\left(t\\right)$，构建 POD 基，计算 $\\mathcal{E}_{\\mathrm{proj}}$ 和 $\\mathcal{E}_{\\mathrm{final}}$，并为以下每个测试用例输出这两个误差。在所有情况下，POD 内积是 $\\mathbb{R}^{n}$ 上的欧几里得内积，所有时间值都使用相同的任意单位，不需要物理单位。\n\n测试套件（每个用例是一个元组 $\\left(n, \\nu, T, \\mathcal{K}, a, m, r_{\\mathrm{pod}}\\right)$）：\n- 用例 1: $\\left(n=80, \\nu=0.5, T=0.7, \\mathcal{K}=\\left[1,3\\right], a=\\left[1.0,-0.4\\right], m=6, r_{\\mathrm{pod}}=2\\right)$。\n- 用例 2: $\\left(n=60, \\nu=0.2, T=1.3, \\mathcal{K}=\\left[2,5,7\\right], a=\\left[0.7,-1.0,0.5\\right], m=9, r_{\\mathrm{pod}}=3\\right)$。\n- 用例 3: $\\left(n=64, \\nu=1.0, T=0.3, \\mathcal{K}=\\left[4\\right], a=\\left[1.0\\right], m=4, r_{\\mathrm{pod}}=5\\right)$。\n- 用例 4: $\\left(n=60, \\nu=0.2, T=0.8, \\mathcal{K}=\\left[1,4,6\\right], a=\\left[1.0,-0.5,0.3\\right], m=8, r_{\\mathrm{pod}}=2\\right)$。\n\n重要的实现细节：\n- 构造 $A$ 时，使用上面定义的三对角矩阵 $L_{h}$ 并乘以扩散系数 $\\nu$。\n- 计算 $A$ 的特征分解为 $A \\;=\\; V \\Lambda V^{\\top}$，并按 $\\left|\\lambda\\right|$ 的升序对特征对进行排序，使得模态索引 $k$ 表示具有第 $k$ 小 $\\left|\\lambda\\right|$ 的特征对。\n- 仅使用 $\\mathcal{K}$ 中选定的特征对和公式 $u\\left(t\\right) \\;=\\; \\sum_{j} a_{j}\\,e^{\\lambda_{k_{j}} t}\\,v_{k_{j}}$ 来制造快照，以确保精确的子空间不变性。\n- 对于每个测试用例，将对 $\\left(\\mathcal{E}_{\\mathrm{proj}}, \\mathcal{E}_{\\mathrm{final}}\\right)$ 作为两个浮点数输出，并附加到一个扁平的输出列表中。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个列表，每个测试用例包含 $2$ 个浮点数，按上述用例顺序排列，即\n$$\n\\left[\\mathcal{E}_{\\mathrm{proj}}^{(1)}, \\mathcal{E}_{\\mathrm{final}}^{(1)}, \\mathcal{E}_{\\mathrm{proj}}^{(2)}, \\mathcal{E}_{\\mathrm{final}}^{(2)}, \\mathcal{E}_{\\mathrm{proj}}^{(3)}, \\mathcal{E}_{\\mathrm{final}}^{(3)}, \\mathcal{E}_{\\mathrm{proj}}^{(4)}, \\mathcal{E}_{\\mathrm{final}}^{(4)}\\right],\n$$\n精确地以方括号括起来的逗号分隔列表形式打印。不应打印任何其他文本。所有角度度量、百分比和物理单位均不适用；所有数值输出必须是实数。", "solution": "问题陈述构成了一个有效且适定的数值验证实验。它基于偏微分方程数值解、线性代数以及通过本征正交分解（POD）和伽辽金（Galerkin）投影进行模型降阶的既定原理。所有必需的参数和过程都得到了明确无误的规定，没有歧义或矛盾，从而可以得到唯一且有意义的计算结果。我们将继续进行求解。\n\n问题的核心是验证 POD-伽辽金降阶模型（ROMs）的一个基本性质：如果一个全阶模型（FOM）的解在一个低维子空间内演化，那么一个足够阶数的 POD-伽辽金 ROM 能够精确地表示该解及其动力学，从而产生零误差。\n\n解决方案是按照问题描述中概述的四个基于原理的步骤来实现的。\n\n**1. 系统与制造解的构建**\n\n首先，我们构建半离散线性时不变系统 $\\frac{d}{dt} u(t) = A u(t)$，该系统近似于一维扩散方程。对于一个长度为 $L=1$、用 $n$ 个内部点离散化的空间域，网格间距为 $h = \\frac{1}{n+1}$。系统矩阵是 $A = \\nu L_h$，其中 $\\nu \\in \\mathbb{R}_{+}$ 是扩散系数，$L_h \\in \\mathbb{R}^{n \\times n}$ 是具有齐次狄利克雷边界条件的拉普拉斯算子的二阶有限差分近似。$L_h$ 是一个由下式定义的实对称三对角矩阵：\n$$\n(L_h)_{ij} = \\frac{1}{h^2} \\begin{cases} -2  i=j \\\\ 1  |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n矩阵 $A$ 是对称且负定的。其特征分解 $A = V \\Lambda V^{\\top}$ 提供了一组标准正交的特征向量基 $V \\in \\mathbb{R}^{n \\times n}$ 和一个由相应的实数负特征值组成的对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$。问题要求特征对 $(\\lambda_k, v_k)$ 按特征值绝对值的升序排列，即 $|\\lambda_1| \\le |\\lambda_2| \\le \\dots \\le |\\lambda_n|$。\n\n然后，构造一个制造解，使其精确地位于 $A$ 的一个预定不变子空间内。我们选择一个包含 $r_{\\mathrm{true}}$ 个模态索引的集合 $\\mathcal{K} \\subset \\{1, \\dots, n\\}$。令 $V_{\\mathcal{K}} \\in \\mathbb{R}^{n \\times r_{\\mathrm{true}}}$ 是以所选特征向量为列的矩阵，$\\Lambda_{\\mathcal{K}} \\in \\mathbb{R}^{r_{\\mathrm{true}} \\times r_{\\mathrm{true}}}$ 是相应特征值构成的对角矩阵。对于给定的系数向量 $a \\in \\mathbb{R}^{r_{\\mathrm{true}}}$，初始条件设置为 $u(0) = V_{\\mathcal{K}} a$。随时间演化的精确解则由下式给出：\n$$\nu(t) = V e^{\\Lambda t} V^{\\top} u(0) = V e^{\\Lambda t} V^{\\top} V_{\\mathcal{K}} a\n$$\n由于 $V$ 的列是标准正交的，$V^{\\top} V_{\\mathcal{K}}$ 除了与 $\\mathcal{K}$ 中索引对应的行之外，其余均为零。这将解简化为：\n$$\nu(t) = V_{\\mathcal{K}} e^{\\Lambda_{\\mathcal{K}} t} a\n$$\n根据构造，状态向量 $u(t)$ 对于所有 $t \\ge 0$ 都保持在子空间 $\\mathrm{span}(V_{\\mathcal{K}})$ 内。\n\n**2. 快照收集与 POD 基**\n\n我们在区间 $[0, T]$ 上，于 $m$ 个不同的时间点 $t_j$（其中 $0 = t_1  t_2  \\dots  t_m = T$）收集系统状态 $u(t_j)$ 的 $m$ 个“快照”。这些快照构成了快照矩阵 $X = [u(t_1), u(t_2), \\dots, u(t_m)] \\in \\mathbb{R}^{n \\times m}$ 的列。\n\nPOD 基是一组能最优地捕捉快照能量的标准正交向量。它是通过对快照矩阵进行奇异值分解（SVD）得到的，$X = U \\Sigma W^{\\top}$。此处，$U \\in \\mathbb{R}^{n \\times n}$ 包含左奇异向量（即 POD 模态），$\\Sigma \\in \\mathbb{R}^{n \\times m}$ 是一个由奇异值 $\\sigma_i \\ge 0$ 组成的对角矩阵，而 $W \\in \\mathbb{R}^{m \\times m}$ 包含右奇异向量。阶数为 $r_{\\mathrm{pod}}$ 的 POD 基是由 $U$ 的前 $r_{\\mathrm{pod}}$ 列构成的矩阵 $\\Phi \\in \\mathbb{R}^{n \\times r_{\\mathrm{pod}}}$。\n\n**3. POD 投影误差**\n\n到 POD 子空间 $\\mathrm{span}(\\Phi)$ 上的正交投影算子是 $P = \\Phi \\Phi^{\\top}$。将快照投影到该子空间所产生的误差，通过残差的归一化弗罗贝尼乌斯范数来量化：\n$$\n\\mathcal{E}_{\\mathrm{proj}} = \\frac{\\| X - P X \\|_{F}}{\\| X \\|_{F}}\n$$\n利用 SVD 的性质，这个误差可以由奇异值计算得出，而无需显式地构建矩阵：\n$$\n\\mathcal{E}_{\\mathrm{proj}} = \\sqrt{\\frac{\\sum_{i=r_{\\mathrm{pod}}+1}^{k} \\sigma_i^2}{\\sum_{i=1}^{k} \\sigma_i^2}}\n$$\n其中 $k = \\mathrm{rank}(X)$。如果数据位于一个 $r_{\\mathrm{true}}$ 维子空间中，则 $\\mathrm{rank}(X) = r_{\\mathrm{true}}$（假设有足够的快照）。如果 $r_{\\mathrm{pod}} \\ge r_{\\mathrm{true}}$，所有非零奇异值都被捕获，分子变为零，因此在精确计算中 $\\mathcal{E}_{\\mathrm{proj}}$ 必须为零。\n\n**4. POD-伽辽金降阶模型与最终时刻误差**\n\nPOD-伽辽金方法将控制方程投影到 POD 基 $\\Phi$ 上。寻求 $u_r(t) = \\Phi c(t)$ 形式的近似解，其中 $c(t) \\in \\mathbb{R}^{r_{\\mathrm{pod}}}$ 是降阶坐标。将其代入 FOM 并左乘 $\\Phi^{\\top}$，得到降阶模型：\n$$\n\\frac{d}{dt} c(t) = A_r c(t), \\quad \\text{with} \\quad A_r = \\Phi^{\\top} A \\Phi \\in \\mathbb{R}^{r_{\\mathrm{pod}} \\times r_{\\mathrm{pod}}}\n$$\n初始条件也被投影：$c(0) = \\Phi^{\\top} u(0)$。降阶系统使用矩阵指数随时间演化：$c(t) = e^{A_r t} c(0)$。然后，FOM 解被重构为 $u_r(t) = \\Phi c(t)$。\n\nROM 的精度通过在最终时刻 $t=T$ 将其解与制造的 FOM 解进行比较来评估：\n$$\n\\mathcal{E}_{\\mathrm{final}} = \\frac{\\| u(T) - u_r(T) \\|_{2}}{\\| u(T) \\|_{2}}\n$$\n当 $r_{\\mathrm{pod}} \\ge r_{\\mathrm{true}}$ 时，POD 子空间 $\\mathrm{span}(\\Phi)$ 包含不变子空间 $\\mathrm{span}(V_{\\mathcal{K}})$。因此，投影是精确的，$u_r(t)$ 将与 $u(t)$ 完全相同，在精确计算中 $\\mathcal{E}_{\\mathrm{final}}$ 将为零。对于 $r_{\\mathrm{pod}}  r_{\\mathrm{true}}$ 的情况，预计 $\\mathcal{E}_{\\mathrm{proj}}$ 和 $\\mathcal{E}_{\\mathrm{final}}$ 都将非零。以下程序为指定的测试用例计算这两个误差度量。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements the POD-Galerkin model reduction experiment for the 1D diffusion equation.\n    \"\"\"\n    test_cases = [\n        # (n, nu, T, K, a, m, r_pod)\n        (80, 0.5, 0.7, [1, 3], [1.0, -0.4], 6, 2),\n        (60, 0.2, 1.3, [2, 5, 7], [0.7, -1.0, 0.5], 9, 3),\n        (64, 1.0, 0.3, [4], [1.0], 4, 5),\n        (60, 0.2, 0.8, [1, 4, 6], [1.0, -0.5, 0.3], 8, 2),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n, nu, T, K, a, m, r_pod = case\n        a_vec = np.array(a)\n\n        # 1. System construction and manufactured solution\n        # Construct the system matrix A\n        h = 1.0 / (n + 1.0)\n        diag_val = -2.0 / (h**2)\n        offdiag_val = 1.0 / (h**2)\n        main_diag = np.full(n, diag_val)\n        off_diag = np.full(n - 1, offdiag_val)\n        L_h = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        A = nu * L_h\n\n        # Compute eigendecomposition and sort by increasing absolute eigenvalue\n        lambdas, V = np.linalg.eigh(A)\n        sort_indices = np.argsort(np.abs(lambdas))\n        lambdas_sorted = lambdas[sort_indices]\n        V_sorted = V[:, sort_indices]\n\n        # Select modes for manufactured solution (convert 1-based K to 0-based indices)\n        mode_indices = [k - 1 for k in K]\n        V_K = V_sorted[:, mode_indices]\n        lambdas_K = lambdas_sorted[mode_indices]\n        \n        # Define initial condition\n        u0 = V_K @ a_vec\n\n        # 2. Snapshot collection and POD basis\n        # Generate snapshots\n        t_space = np.linspace(0.0, T, m)\n        X = np.zeros((n, m))\n        for j, t_j in enumerate(t_space):\n            # u(t) = V_K @ diag(exp(lambda_k * t)) @ a\n            X[:, j] = V_K @ (np.exp(lambdas_K * t_j) * a_vec)\n        \n        # Compute POD basis via SVD. U must be n x n as per problem description.\n        U, s, _ = np.linalg.svd(X, full_matrices=True)\n        Phi = U[:, :r_pod]\n\n        # 3. POD projection error\n        norm_X_sq = np.sum(s**2)\n        if norm_X_sq  1e-15:\n            # Handle trivial case of zero snapshots\n            E_proj = 0.0\n        else:\n            # Sum of squares of truncated singular values\n            norm_err_sq = np.sum(s[r_pod:]**2)\n            E_proj = np.sqrt(norm_err_sq / norm_X_sq)\n\n        # 4. POD-Galerkin reduced model and final-time error\n        # Full (manufactured) solution at the final time T\n        u_T = V_K @ (np.exp(lambdas_K * T) * a_vec)\n        \n        # If r_pod is 0, reduced solution is identically zero\n        if r_pod == 0:\n            u_r_T = np.zeros(n)\n        else:\n            # Construct and evolve the reduced-order model\n            A_r = Phi.T @ A @ Phi\n            c0 = Phi.T @ u0\n            c_T = expm(A_r * T) @ c0\n            \n            # Reconstruct the FOM-space solution from the ROM\n            u_r_T = Phi @ c_T\n\n        # Compute final-time relative error\n        norm_u_T = np.linalg.norm(u_T)\n        if norm_u_T  1e-15:\n            E_final = 0.0\n        else:\n            E_final = np.linalg.norm(u_T - u_r_T) / norm_u_T\n            \n        all_results.extend([E_proj, E_final])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3435994"}, {"introduction": "现实世界中的系统往往是非线性的，这给基于投影的降阶方法带来了挑战。本练习将处理一种常见的二次非线性项，展示伽辽金投影如何将其转化为降阶坐标下的一系列二次项。我们将推导出一个控制这些相互作用的三阶张量，并计算其特定分量，这阐明了关键的“离线/在线”计算策略，即在“离线”阶段预先计算这些计算成本高昂的张量，以实现在线阶段的快速仿真。[@problem_id:3436025]", "problem": "考虑一个具有 $N$ 个自由度的空间半离散化非线性偏微分方程，它产生一个常微分方程，形式如下\n$$\n\\frac{d}{dt} x(t) \\;=\\; A\\,x(t) \\;+\\; B\\big(x(t)\\odot x(t)\\big),\n$$\n其中 $x(t)\\in\\mathbb{R}^N$，$A\\in\\mathbb{R}^{N\\times N}$ 是一个线性算子，$B\\in\\mathbb{R}^{N\\times N}$ 是在哈达玛（逐分量）乘积后应用的线性映射，$\\odot$ 表示哈达玛乘积。假设已获得一个真正常交分解（Proper Orthogonal Decomposition, POD）基 $U=\\big[u_1,\\dots,u_r\\big]\\in\\mathbb{R}^{N\\times r}$，其列在欧几里得内积下是标准正交的，并且使用拟设 $x(t)\\approx U\\,a(t)$ 执行伽辽金（Galerkin）投影，其中 $a(t)\\in\\mathbb{R}^r$ 是降阶坐标。通过在 $\\operatorname{span}\\{u_1,\\dots,u_r\\}$ 上强制施加带有欧几里得内积的伽辽金条件来形成降阶模型。\n\n第 $(i)$ 部分：从伽辽金投影的定义出发，推导出一个适合离线预计算和快速在线评估的降阶二次项形式。您的推导必须从将 $x(t)\\approx U\\,a(t)$ 代入全阶模型和正交性（伽辽金）条件开始。清晰地指出控制二次项的三阶张量项，并纯粹用 $B$ 和 POD 基向量 $\\{u_i\\}_{i=1}^r$ 来表示。您可以假设除了线性性之外，$B$ 没有特殊结构。\n\n第 $(ii)$ 部分：对 $N=4$ 和 $r=3$ 的情况，使用以下数据进行特例化分析：\n$$\nB \\;=\\;\n\\begin{pmatrix}\n2  -1  0  0\\\\\n1  \\phantom{-}3  2  0\\\\\n0  -2  1  4\\\\\n0  \\phantom{-}0  3  -1\n\\end{pmatrix},\\quad\nu_1 \\;=\\;\n\\begin{pmatrix}\n1\\\\ 0\\\\ 0\\\\ 0\n\\end{pmatrix},\\quad\nu_2 \\;=\\;\\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n0\\\\ 1\\\\ 1\\\\ 0\n\\end{pmatrix},\\quad\nu_3 \\;=\\;\\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n0\\\\ 1\\\\ -1\\\\ 0\n\\end{pmatrix}.\n$$\n使用您在第 $(i)$ 部分得到的结果，计算降阶模型中对应于二次项系数 $C_{1,2,3}$ 的特定降阶张量项。请以单个实数形式提供您的最终答案。不需要四舍五入，也不涉及物理单位。", "solution": "该问题是有效的，因为它在科学上基于模型降阶理论，是适定的，提供了所有必要信息且没有矛盾，并以客观、正式的语言表述。我们可以开始求解。\n\n### 第 (i) 部分：降阶二次项的推导\n\n给定全阶模型，它是一个常微分方程（ODE）系统：\n$$\n\\frac{d}{dt} x(t) = A\\,x(t) + B\\big(x(t)\\odot x(t)\\big)\n$$\n其中 $x(t) \\in \\mathbb{R}^N$。我们寻求使用伽辽金投影到一个由 POD 基矩阵 $U = [u_1, \\dots, u_r] \\in \\mathbb{R}^{N\\times r}$ 的列所张成的子空间上，来构建一个降阶模型（ROM）。$U$ 的列是标准正交的，满足 $u_i^T u_j = \\delta_{ij}$ 对于 $i,j \\in \\{1, \\dots, r\\}$。\n\n伽辽金拟设将高维状态 $x(t)$ 近似为基向量的线性组合：\n$$\nx(t) \\approx x_r(t) = U\\,a(t) = \\sum_{j=1}^{r} a_j(t) u_j\n$$\n其中 $a(t) \\in \\mathbb{R}^r$ 是降阶（或广义）坐标的向量。\n\n我们将此拟设代入全阶模型。由于 $U$ 是一个常数矩阵，近似解的时间导数为 $\\frac{d}{dt}x_r(t) = U \\frac{d}{dt}a(t) = U \\dot{a}(t)$。近似解并不能精确满足完整的 ODE，从而留下一个残差 $R(t)$：\n$$\nR(t) = U \\dot{a}(t) - A(U a(t)) - B\\big((U a(t)) \\odot (U a(t))\\big)\n$$\n伽辽金条件要求残差与投影子空间的基正交。这意味着残差与每个基向量 $u_i$ 的欧几里得内积必须为零：\n$$\n\\langle R(t), u_i \\rangle = u_i^T R(t) = 0 \\quad \\text{对于 } i=1, \\dots, r\n$$\n应用这个条件，我们得到：\n$$\nu_i^T \\left( U \\dot{a}(t) - A U a(t) - B\\big((U a(t)) \\odot (U a(t))\\big) \\right) = 0\n$$\n重新整理各项得到：\n$$\nu_i^T U \\dot{a}(t) = u_i^T A U a(t) + u_i^T B\\big((U a(t)) \\odot (U a(t))\\big)\n$$\n我们来分析降阶系统第 $i$ 个方程的每一项。\n\n对于左侧项，我们利用基向量的标准正交性：\n$$\nu_i^T U \\dot{a}(t) = u_i^T \\left( \\sum_{k=1}^r \\dot{a}_k(t) u_k \\right) = \\sum_{k=1}^r \\dot{a}_k(t) (u_i^T u_k) = \\sum_{k=1}^r \\dot{a}_k(t) \\delta_{ik} = \\dot{a}_i(t)\n$$\n对于右侧的线性项：\n$$\nu_i^T A U a(t) = u_i^T A \\left( \\sum_{j=1}^r a_j(t) u_j \\right) = \\sum_{j=1}^r (u_i^T A u_j) a_j(t)\n$$\n这表示矩阵向量积 $A_r a(t)$ 的第 $i$ 个分量，其中降阶线性算子为 $A_r = U^T A U \\in \\mathbb{R}^{r \\times r}$。\n\n对于右侧的非线性项，我们首先展开算子 $B$ 内部的项：\n$$\n(Ua(t)) \\odot (Ua(t)) = \\left(\\sum_{j=1}^r a_j(t) u_j\\right) \\odot \\left(\\sum_{k=1}^r a_k(t) u_k\\right) = \\sum_{j=1}^r \\sum_{k=1}^r a_j(t) a_k(t) (u_j \\odot u_k)\n$$\n现在，我们应用线性算子 $B$ 和投影 $u_i^T$：\n$$\nu_i^T B\\big((U a(t)) \\odot (U a(t))\\big) = u_i^T B \\left( \\sum_{j=1}^r \\sum_{k=1}^r a_j(t) a_k(t) (u_j \\odot u_k) \\right)\n$$\n根据 $B$ 和投影 $u_i^T$ 的线性性：\n$$\nu_i^T B\\big((U a(t)) \\odot (U a(t))\\big) = \\sum_{j=1}^r \\sum_{k=1}^r \\left(u_i^T B(u_j \\odot u_k)\\right) a_j(t) a_k(t)\n$$\n合并所有项，降阶系统的第 $i$ 个方程为：\n$$\n\\dot{a}_i(t) = \\sum_{j=1}^r (u_i^T A u_j) a_j(t) + \\sum_{j=1}^r \\sum_{k=1}^r \\left(u_i^T B(u_j \\odot u_k)\\right) a_j(t) a_k(t)\n$$\n二次项由一个三阶张量 $C \\in \\mathbb{R}^{r \\times r \\times r}$ 控制，其项由以下公式给出：\n$$\nC_{i,j,k} = u_i^T B(u_j \\odot u_k)\n$$\n这些张量项是常数，仅取决于算子 $B$ 和 POD 基向量 $\\{u_i\\}_{i=1}^r$。它们可以在离线阶段进行预计算，从而实现在线阶段对降阶模型的快速评估。\n\n### 第 (ii) 部分：张量项 $C_{1,2,3}$ 的计算\n\n我们被要求使用所提供的数据，计算 $N=4$ 和 $r=3$ 情况下的特定张量项 $C_{1,2,3}$。在第 (i) 部分推导出的张量项公式为 $C_{i,j,k} = u_i^T B(u_j \\odot u_k)$。对于 $(i,j,k) = (1,2,3)$，这变为：\n$$\nC_{1,2,3} = u_1^T B(u_2 \\odot u_3)\n$$\n所提供的数据为：\n$$\nB = \\begin{pmatrix} 2  -1  0  0\\\\ 1  3  2  0\\\\ 0  -2  1  4\\\\ 0  0  3  -1 \\end{pmatrix}, \\quad u_1 = \\begin{pmatrix} 1\\\\ 0\\\\ 0\\\\ 0 \\end{pmatrix}, \\quad u_2 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0\\\\ 1\\\\ 1\\\\ 0 \\end{pmatrix}, \\quad u_3 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0\\\\ 1\\\\ -1\\\\ 0 \\end{pmatrix}\n$$\n首先，我们计算哈达玛乘积 $u_2 \\odot u_3$：\n$$\nu_2 \\odot u_3 = \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0\\\\ 1\\\\ 1\\\\ 0 \\end{pmatrix} \\right) \\odot \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0\\\\ 1\\\\ -1\\\\ 0 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0 \\cdot 0 \\\\ 1 \\cdot 1 \\\\ 1 \\cdot (-1) \\\\ 0 \\cdot 0 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 0 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix}\n$$\n我们将这个结果向量表示为 $v = u_2 \\odot u_3$。接下来，我们将算子 $B$ 应用于 $v$：\n$$\nB v = B (u_2 \\odot u_3) = \\begin{pmatrix} 2  -1  0  0\\\\ 1  3  2  0\\\\ 0  -2  1  4\\\\ 0  0  3  -1 \\end{pmatrix} \\left( \\frac{1}{2} \\begin{pmatrix} 0 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix} \\right)\n$$\n$$\nB v = \\frac{1}{2} \\begin{pmatrix} 2(0) + (-1)(1) + 0(-1) + 0(0) \\\\ 1(0) + 3(1) + 2(-1) + 0(0) \\\\ 0(0) + (-2)(1) + 1(-1) + 4(0) \\\\ 0(0) + 0(1) + 3(-1) + (-1)(0) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} -1 \\\\ 1 \\\\ -3 \\\\ -3 \\end{pmatrix}\n$$\n最后，我们计算这个结果与 $u_1^T$ 的点积：\n$$\nC_{1,2,3} = u_1^T (B v) = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\left( \\frac{1}{2} \\begin{pmatrix} -1 \\\\ 1 \\\\ -3 \\\\ -3 \\end{pmatrix} \\right)\n$$\n这个操作只是提取了向量 $Bv$ 的第一个分量：\n$$\nC_{1,2,3} = \\frac{1}{2} \\times (-1) = -\\frac{1}{2}\n$$\n因此，指定张量项的值为 $-\\frac{1}{2}$。", "answer": "$$\\boxed{-\\frac{1}{2}}$$", "id": "3436025"}, {"introduction": "虽然上一个练习展示了如何对非线性项进行投影，但其评估过程本身可能成为计算瓶颈，因为它需要重构整个高维状态向量。这个高级实践将引入离散经验插值方法（DEIM），一种“超降阶”（hyper-reduction）技术，它仅使用非线性函数在少数几个插值点上的值来近似整个非线性项，从而绕开了这一难题。在本练习中，我们不仅要实现这种强大的方法，还将推导并验证一个先验误差界，从而将实际应用与严谨的数值分析理论联系起来。[@problem_id:3435952]", "problem": "考虑一个通过在一维偏微分方程的空间离散化得到的半离散非线性演化方程，该离散化在包含 $N$ 个内部点的均匀网格上进行。设 $u(t) \\in \\mathbb{R}^N$ 表示状态向量，并考虑以下模型\n$$\n\\frac{d u}{d t} = A u + N(u),\n$$\n其中 $A \\in \\mathbb{R}^{N \\times N}$ 是具有齐次狄利克雷边界条件的二阶扩散算子的对称负定刚度矩阵，而 $N(u) \\in \\mathbb{R}^N$ 是分量形式施加的非线性反应项。对于此问题，取 $N(u) = \\alpha\\, u \\odot u$，其中 $\\odot$ 表示哈达玛积（分量乘积），$\\alpha > 0$ 是一个标量参数。\n\n您需要实现本征正交分解 (Proper Orthogonal Decomposition, POD) 与伽辽金投影，并结合离散经验插值方法 (Discrete Empirical Interpolation Method, DEIM) 来近似非线性项。给定一个快照矩阵 $S \\in \\mathbb{R}^{N \\times K}$，其中包含在训练时间区间 $[0, T_{\\mathrm{train}}]$ 内从全阶模型采样的 $K$ 个全阶模型状态 $u(t_k)$，从 $S$ 的前 $r$ 个左奇异向量构建一个 POD 基 $V_r \\in \\mathbb{R}^{N \\times r}$。类似地，从非线性项计算结果的快照矩阵 $N(S) = [N(u(t_1)), \\dots, N(u(t_K))]$ 的前 $m$ 个左奇异向量构建一个 DEIM 基 $U_m \\in \\mathbb{R}^{N \\times m}$。使用 DEIM 贪心插值点选择算法，从与所选插值索引相对应的 $m$ 个标准单位向量形成选择矩阵 $P \\in \\mathbb{R}^{N \\times m}$。$N(u)$ 的 DEIM 近似为\n$$\nN(u) \\approx U_m (P^\\top U_m)^{-1} P^\\top N(u).\n$$\n\n通过在 POD 子空间上进行伽辽金投影，并对非线性项使用 DEIM 近似，得到降阶模型 (reduced-order model, ROM)：\n$$\n\\frac{d a}{d t} = V_r^\\top A V_r\\, a + V_r^\\top U_m (P^\\top U_m)^{-1} P^\\top N(V_r a),\n$$\n其中 $a(t) \\in \\mathbb{R}^r$ 是降阶系数，且 $u(t) \\approx V_r a(t)$。\n\n从 Lipschitz 连续性的基本定义和三角不等式出发，推导一个关于全阶与降阶模型状态误差 $e(t) = u(t) - V_r a(t)$ 在 $[0, T]$ 上的先验误差界，该界将 $\\|e(t)\\|_2$ 表示为谱范数 $\\|A\\|_2$、非线性项 $N(\\cdot)$ 的 Lipschitz 常数 $L_N$、初始投影误差 $\\|e(0)\\|_2$ 以及 DEIM 残差\n$$\nr_{\\mathrm{DEIM}}(V_r a) := \\big(I - U_m (P^\\top U_m)^{-1} P^\\top\\big)\\, N(V_r a)\n$$\n的函数。您的界必须是显式的，并且只能使用能够从训练数据和 ROM 轨迹中估计的量，即从训练快照中观察到的最大无穷范数推导出的 $L_N$ 的上界，以及 $\\|r_{\\mathrm{DEIM}}(V_r a(s))\\|_2$ 对时间积分的数值积分近似。\n\n实现细节：\n- 在区间 $[0,1]$ 上使用包含 $N = 64$ 个内部点的均匀网格，并采用齐次狄利克雷边界条件。\n- 扩散矩阵 $A$ 由二阶中心差分拉普拉斯算子乘以一个扩散系数 $\\nu > 0$ 构成。\n- 非线性系数为 $\\alpha > 0$，且 $N(u) = \\alpha\\, u \\odot u$。\n- 初始条件为 $u_0(x_i) = \\epsilon \\sin(\\pi x_i)$，适用于内部网格点 $x_i$，其中 $\\epsilon$ 是一个小的振幅。\n- 将训练数据上 $N(\\cdot)$ 的 Lipschitz 常数估计为 $L_N = 2 \\alpha M_\\infty$，其中 $M_\\infty$ 是训练快照 $S$ 上 $u$ 的无穷范数的上界（即 $M_\\infty = \\max_k \\|u(t_k)\\|_\\infty$）。\n\n按如下方式设计 DEIM 贪心插值点选择算法：\n- 设 $u_1, \\dots, u_m$ 是 $U_m$ 的列。\n- 将第一个插值索引初始化为 $u_1$ 中绝对值最大分量的位置。\n- 对于 $k = 2, \\dots, m$，计算 $u_k$ 经过当前 $k-1$ 个基向量和索引插值后的残差，并选择下一个插值索引为该残差中绝对值最大分量的位置。\n\n数值积分要求：\n- 对全阶和降阶模型均实现一个四阶显式龙格-库塔方法。\n- 对训练和评估使用相同的时间步长 $dt$，并在评估区间 $[0, T]$ 上运行 ROM。\n\n对于每个测试用例，您必须输出一个布尔值，指示观测到的最终时刻误差 $\\|e(T)\\|_2$ 是否满足您推导的界。为此，计算\n$$\n\\beta := \\|A\\|_2 + L_N,\\quad B(T) := \\exp(\\beta T)\\left(\\|e(0)\\|_2 + \\int_0^T \\|r_{\\mathrm{DEIM}}(V_r a(s))\\|_2\\, ds\\right),\n$$\n并检查是否 $\\|e(T)\\|_2 \\le B(T)$。\n\n测试套件：\n- 使用 $N = 64$，$\\nu = 10^{-2}$，$\\alpha = 1$，$\\epsilon = 0.1$，以及 $dt = 5 \\times 10^{-4}$。取 $T_{\\mathrm{train}} = T = 0.05$。\n- 要测试的四组 $(r,m)$ 参数集是：\n    1. $(r,m) = (10,10)$ (一般情况)，\n    2. $(r,m) = (10,5)$ (DEIM 点数少于 POD 维数)，\n    3. $(r,m) = (5,5)$ (小子空间)，\n    4. $(r,m) = (12,12)$ (大子空间)。\n对于每种情况，构建 $V_r$、$U_m$，计算 DEIM 索引，建立 ROM，在 $[0,T]$ 上评估误差和界，并为每种情况返回一个布尔值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个包含在方括号中的逗号分隔列表的结果，例如，\"[true,false,true,false]\"。在 Python 中，将布尔值打印为标准的 Python 布尔值，得到 \"[True,False,True,False]\"。", "solution": "该问题要求推导一个针对使用离散经验插值方法（DEIM）的本征正交分解（POD）降阶模型（ROM）的先验误差界，并随后进行数值验证。\n\n半离散全阶模型（FOM）由以下常微分方程组给出：\n$$\n\\frac{d u}{d t} = A u + N(u) \\equiv f(u)\n$$\n其中 $u(t) \\in \\mathbb{R}^N$ 是状态向量，$A \\in \\mathbb{R}^{N \\times N}$ 是代表扩散的对称负定矩阵，$N(u) = \\alpha u \\odot u$ 是非线性反应项。\n\nPOD-DEIM ROM 将解近似为 $u(t) \\approx u_r(t) = V_r a(t)$，其中 $V_r \\in \\mathbb{R}^{N \\times r}$ 是 POD 基，$a(t) \\in \\mathbb{R}^r$ 是降阶坐标。$a(t)$ 的演化由以下方程控制：\n$$\n\\frac{d a}{d t} = V_r^\\top A V_r a + V_r^\\top U_m (P^\\top U_m)^{-1} P^\\top N(V_r a)\n$$\n其中 $U_m \\in \\mathbb{R}^{N \\times m}$ 是 DEIM 基，$P \\in \\mathbb{R}^{N \\times m}$ 是 DEIM 选择矩阵。令 $\\Pi_{\\mathrm{DEIM}} = U_m (P^\\top U_m)^{-1} P^\\top$ 为 DEIM 投影算子。ROM 可以更紧凑地写出。通过乘以 $V_r$ 并定义到 POD 基空间上的正交投影算子 $\\Pi_r = V_r V_r^\\top$，我们得到降阶状态 $u_r = V_r a$ 的演化：\n$$\n\\frac{d u_r}{d t} = \\Pi_r \\left( A u_r + \\Pi_{\\mathrm{DEIM}} N(u_r) \\right)\n$$\n请注意，$da/dt$ 的方程直接意味着 $V_r da/dt = \\Pi_r (A u_r + \\Pi_{\\mathrm{DEIM}} N(u_r))$。线性项通常被预先投影为 $\\Pi_r A \\Pi_r u_r$。对于此问题，我们遵循指定的 ROM 方程，它等价于 $\\Pi_r (A u_r + \\dots)$。\n\n我们的目标是推导误差 $e(t) = u(t) - u_r(t)$ 的误差界。\n\n**误差界的推导**\n\n1.  **误差动力学方程**：我们首先找到控制误差 $e(t)$ 的微分方程。\n    $$\n    \\frac{de}{dt} = \\frac{du}{dt} - \\frac{du_r}{dt} = f(u) - \\Pi_r \\left( A u_r + \\Pi_{\\mathrm{DEIM}} N(u_r) \\right)\n    $$\n    我们添加和减去项以分离来自线性算子、非线性项和模型降阶近似的贡献。\n    $$\n    \\frac{de}{dt} = [A u + N(u)] - [\\Pi_r A u_r + \\Pi_r \\Pi_{\\mathrm{DEIM}} N(u_r)]\n    $$\n    添加和减去 $A u_r$ 和 $N(u_r)$：\n    $$\n    \\frac{de}{dt} = A(u - u_r) + [N(u) - N(u_r)] + [A u_r + N(u_r) - \\Pi_r A u_r - \\Pi_r \\Pi_{\\mathrm{DEIM}} N(u_r)]\n    $$\n    让我们识别这些项：\n    -   $A e = A(u - u_r)$ 是由线性算子传播的误差。\n    -   $N(u) - N(u_r)$ 是来自非线性项的误差。\n    -   最后一个括号内的项是将 FOM 动力学投影到降阶近似流形上产生的残差。我们称之为 $\\mathcal{R}(t)$。\n    \n    因此，误差动力学为：\n    $$\n    \\frac{de}{dt} = A e + [N(u) - N(u_r)] + \\mathcal{R}(t)\n    $$\n    其中残差项 $\\mathcal{R}(t)$ 可以展开为：\n    $$\n    \\mathcal{R}(t) = (I - \\Pi_r) A u_r + (I - \\Pi_r) \\Pi_{\\mathrm{DEIM}} N(u_r) + (I - \\Pi_{\\mathrm{DEIM}}) N(u_r)\n    $$\n    项 $(I - \\Pi_{\\mathrm{DEIM}}) N(u_r)$ 正是问题陈述中定义的 DEIM 残差 $r_{\\mathrm{DEIM}}(u_r)$。$\\mathcal{R}(t)$ 中的另外两项与 POD 基 $V_r$ 无法表示 $A$ 在 $u_r$ 上的作用以及 DEIM 近似的非线性项有关。在这种情况下，先验误差界通常通过忽略这些项来简化分析，隐含地假设它们是次要的，或者可以被其他量所界定。问题要求一个特别用 DEIM 残差表示的界，这引导我们做出这个标准的简化假设：我们仅用 DEIM 残差来近似完整残差 $\\mathcal{R}(t)$。\n    $$\n    \\mathcal{R}(t) \\approx r_{\\mathrm{DEIM}}(u_r) = \\left(I - U_m (P^\\top U_m)^{-1} P^\\top\\right) N(u_r)\n    $$\n    这导致了简化的误差动力学：\n    $$\n    \\frac{de}{dt} \\approx A e + [N(u) - N(u_r)] + r_{\\mathrm{DEIM}}(u_r)\n    $$\n\n2.  **范数和不等式的应用**：我们现在对简化的误差方程取欧几里得范数（$\\|\\cdot\\|_2$）并应用三角不等式：\n    $$\n    \\left\\| \\frac{de}{dt} \\right\\|_2 \\le \\|A e\\|_2 + \\|N(u) - N(u_r)\\|_2 + \\|r_{\\mathrm{DEIM}}(u_r)\\|_2\n    $$\n    使用诱导矩阵范数的定义和 $N(\\cdot)$ 的 Lipschitz 连续性：\n    -   $\\|A e\\|_2 \\le \\|A\\|_2 \\|e\\|_2$\n    -   $\\|N(u) - N(u_r)\\|_2 \\le L_N \\|u - u_r\\|_2 = L_N \\|e\\|_2$，其中 $L_N$ 是 Lipschitz 常数。\n    \n    将这些代入不等式中得到：\n    $$\n    \\left\\| \\frac{de}{dt} \\right\\|_2 \\le \\|A\\|_2 \\|e\\|_2 + L_N \\|e\\|_2 + \\|r_{\\mathrm{DEIM}}(u_r)\\|_2\n    $$\n    $$\n    \\left\\| \\frac{de}{dt} \\right\\|_2 \\le (\\underbrace{\\|A\\|_2 + L_N}_{\\beta}) \\|e\\|_2 + \\|r_{\\mathrm{DEIM}}(u_r)\\|_2\n    $$\n\n3.  **Gronwall 不等式的应用**：我们将微分不等式在时间区间 $[0, t]$ 上进行积分。根据微积分基本定理，$e(t) = e(0) + \\int_0^t \\frac{de}{ds} ds$。取范数，我们得到 $\\|e(t)\\|_2 \\le \\|e(0)\\|_2 + \\int_0^t \\|\\frac{de}{ds}\\|_2 ds$。\n    \n    代入我们对 $\\|\\frac{de}{ds}\\|_2$ 的界：\n    $$\n    \\|e(t)\\|_2 \\le \\|e(0)\\|_2 + \\int_0^t \\left( \\beta \\|e(s)\\|_2 + \\|r_{\\mathrm{DEIM}}(u_r(s))\\|_2 \\right) ds\n    $$\n    整理各项：\n    $$\n    \\|e(t)\\|_2 \\le \\left( \\|e(0)\\|_2 + \\int_0^t \\|r_{\\mathrm{DEIM}}(u_r(s))\\|_2 ds \\right) + \\beta \\int_0^t \\|e(s)\\|_2 ds\n    $$\n    这符合 Gronwall 不等式的积分形式。如果一个非负连续函数 $y(t)$ 满足 $y(t) \\le C_1(t) + \\int_0^t C_2(s) y(s) ds$，则 $y(t) \\le C_1(t) + \\int_0^t C_1(s) C_2(s) \\exp\\left(\\int_s^t C_2(\\tau) d\\tau\\right) ds$。这里适用一个更简单的形式：如果 $y(t) \\le C + \\int_0^t (\\gamma y(s) + g(s)) ds$ 其中 $\\gamma$ 是一个常数，则 $y(t) \\le (C + \\int_0^t g(s) ds) e^{\\gamma t}$。\n    \n    令 $y(t) = \\|e(t)\\|_2$, $C = \\|e(0)\\|_2$, $\\gamma = \\beta$ 以及 $g(s) = \\|r_{\\mathrm{DEIM}}(u_r(s))\\|_2$。应用这种形式的 Gronwall 不等式，我们得到所需的先验误差界：\n    $$\n    \\|e(t)\\|_2 \\le \\left( \\|e(0)\\|_2 + \\int_0^t \\|r_{\\mathrm{DEIM}}(V_r a(s))\\|_2 ds \\right) \\exp(\\beta t)\n    $$\n\n4.  **用于数值验证的最终界**：问题要求在最终时刻 $t=T$ 验证该界。\n    $$\n    \\|e(T)\\|_2 \\le B(T) := \\exp(\\beta T) \\left( \\|e(0)\\|_2 + \\int_0^T \\|r_{\\mathrm{DEIM}}(V_r a(s))\\|_2 ds \\right)\n    $$\n    其中 $\\beta = \\|A\\|_2 + L_N$。界中的量计算如下：\n    -   $\\|A\\|_2$：扩散矩阵的谱范数。\n    -   $L_N$：Lipschitz 常数的估计值，给定为 $2 \\alpha M_\\infty$，其中 $M_\\infty = \\max_k \\|u(t_k)\\|_\\infty$ 是在训练快照上的最大值。\n    -   $\\|e(0)\\|_2$：初始投影误差，$\\|u(0) - V_r V_r^\\top u(0)\\|_2$。\n    -   $\\int_0^T \\|r_{\\mathrm{DEIM}}(V_r a(s))\\|_2 ds$：沿着 ROM 轨迹的 DEIM 残差范数的时间积分，使用简单的求积法则（例如，矩形法则）在模拟时间步上进行数值近似。\n\n这个推导为所要求的数值实现和验证提供了理论基础。实现将构建 FOM 和 ROM，对两者进行仿真，计算实际误差 $\\|e(T)\\|_2$，评估界 $B(T)$ 中的所有项，并检查不等式是否成立。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, verify the error bound for POD-DEIM ROMs.\n    \"\"\"\n    # Problem parameters\n    N = 64\n    nu = 1.0e-2\n    alpha = 1.0\n    epsilon = 0.1\n    dt = 5.0e-4\n    T_train = 0.05\n    T = 0.05\n    test_cases = [(10, 10), (10, 5), (5, 5), (12, 12)]\n\n    # Grid and initial condition\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    u0 = epsilon * np.sin(np.pi * x)\n\n    # Diffusion matrix A\n    A = nu / h**2 * (np.diag(np.ones(N - 1), 1) + np.diag(np.ones(N - 1), -1) - 2 * np.diag(np.ones(N)))\n    norm_A = np.linalg.norm(A, 2)\n\n    # Nonlinear term N(u)\n    def N_func(u, current_alpha):\n        return current_alpha * u**2\n\n    # RK4 stepper\n    def rk4_step(f, t, y, dt_step):\n        k1 = f(t, y)\n        k2 = f(t + dt_step / 2, y + dt_step / 2 * k1)\n        k3 = f(t + dt_step / 2, y + dt_step / 2 * k2)\n        k4 = f(t + dt_step, y + dt_step * k3)\n        return y + dt_step / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # FOM simulation (training data generation)\n    def run_fom():\n        num_steps = int(round(T_train / dt))\n        num_snapshots = num_steps + 1\n        S = np.zeros((N, num_snapshots))\n        SN = np.zeros((N, num_snapshots))\n        u = u0.copy()\n        max_inf_norm = 0.0\n        \n        for k in range(num_snapshots):\n            S[:, k] = u\n            SN[:, k] = N_func(u, alpha)\n            max_inf_norm = max(max_inf_norm, np.linalg.norm(u, np.inf))\n            if k  num_steps:\n                f_fom = lambda t, y: A @ y + N_func(y, alpha)\n                u = rk4_step(f_fom, k * dt, u, dt)\n        return S, SN, max_inf_norm, u  # u is now u(T)\n\n    # Generate training data once\n    S, SN, M_inf, u_T_fom = run_fom()\n    L_N = 2 * alpha * M_inf\n    beta = norm_A + L_N\n\n    # DEIM greedy point selection algorithm\n    def deim_point_selection(U_m, m_dim):\n        indices = []\n        u1 = U_m[:, 0]\n        indices.append(np.argmax(np.abs(u1)))\n        \n        for k in range(1, m_dim):\n            uk = U_m[:, k]\n            # Solve for coefficients c of the projection of uk onto span of previous basis vectors\n            # using the already selected points.\n            c = np.linalg.solve(U_m[np.ix_(indices, list(range(k)))], uk[indices])\n            residual = uk - U_m[:, :k] @ c\n            indices.append(np.argmax(np.abs(residual)))\n        return indices\n\n    # POD and DEIM bases from SVD\n    U_pod, _, _ = svd(S, full_matrices=False)\n    U_deim, _, _ = svd(SN, full_matrices=False)\n    \n    results = []\n    \n    for r, m in test_cases:\n        # 1. Construct ROM for the given (r, m)\n        Vr = U_pod[:, :r]\n        Um = U_deim[:, :m]\n        \n        deim_indices = deim_point_selection(Um, m)\n        \n        P_T_Um = Um[deim_indices, :]\n        inv_P_T_Um = np.linalg.inv(P_T_Um)\n        \n        Ar = Vr.T @ A @ Vr\n        DEIM_op_const = Vr.T @ Um @ inv_P_T_Um\n\n        def f_rom(t, a):\n            ur = Vr @ a\n            N_ur = N_func(ur, alpha)\n            P_T_N_ur = N_ur[deim_indices]\n            return Ar @ a + DEIM_op_const @ P_T_N_ur\n\n        # 2. Simulate ROM and compute bound quantities\n        a0 = Vr.T @ u0\n        e0_norm = np.linalg.norm(u0 - Vr @ a0)\n        \n        a = a0.copy()\n        r_deim_integral = 0.0\n        num_steps = int(round(T / dt))\n\n        for k in range(num_steps):\n            # Compute DEIM residual for integral\n            ur = Vr @ a\n            N_ur = N_func(ur, alpha)\n            N_ur_deim = Um @ (inv_P_T_Um @ N_ur[deim_indices])\n            r_deim_norm = np.linalg.norm(N_ur - N_ur_deim)\n            r_deim_integral += r_deim_norm * dt\n            \n            # Time step\n            a = rk4_step(f_rom, k * dt, a, dt)\n        \n        ur_T = Vr @ a\n\n        # 3. Calculate final error and bound\n        eT_norm = np.linalg.norm(u_T_fom - ur_T)\n        bound_B_T = np.exp(beta * T) * (e0_norm + r_deim_integral)\n        \n        # 4. Check if observed error satisfies the bound\n        results.append(eT_norm = bound_B_T)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3435952"}]}