{"hands_on_practices": [{"introduction": "在使用任何激励源之前，理解其基本属性是至关重要的。高斯调制正弦脉冲（或称Gabor脉冲）因其优良特性而被广泛使用。本练习 [@problem_id:3310757] 将通过推导其峰值因子（crest factor），来深入探究其广受欢迎的原因之一。峰值因子是衡量信号数值稳定性和动态范围的关键指标，对时域求解器尤为重要。", "problem": "在计算电磁学中用作宽带激励的高斯调制正弦源（Gabor脉冲）由实值波形定义\n$$\ns(t) = \\exp\\!\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\!\\left(2\\pi f_{0} t\\right),\n$$\n其中 $f_{0}$ 是载波频率，$\\sigma$ 是高斯包络的时间标准差。考虑波峰因数（峰值与均方根之比），其定义为峰值振幅与通过适用于有限能量脉冲的高斯窗时间平均计算出的均方根值之比：\n$$\nC = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}, \\quad s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}.\n$$\n仅从给定的定义和高斯函数的标准积分恒等式出发，推导波峰因数 $C$ 作为无量纲参数 $f_{0}\\sigma$ 的函数的精确封闭形式表达式。你的推导必须是自洽的，并且不得假定任何未经证明的中间公式。然后，利用你的结果，解释 $C$ 对 $f_{0}\\sigma$ 的依赖关系如何影响在时域求解器（如时域有限差分法，FDTD）中激励和记录场时所需的动态范围，包括对数值精度和稳定性的任何影响。\n\n将你的最终答案表示为仅包含 $f_{0}\\sigma$ 的单个解析表达式。最终答案中不要包含单位。不需要进行数值近似。", "solution": "该问题是有效的，因为它在科学上基于信号处理和计算电磁学的原理，问题陈述清晰，提供了所有必要的定义，并以客观、正式的语言表述。我们可以开始求解。\n\n该问题要求推导Gabor脉冲的波峰因数 $C$ 并讨论其影响。Gabor脉冲由下式给出\n$$s(t) = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right)$$\n波峰因数定义为\n$$C = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}$$\n其中均方根值 $s_{\\mathrm{rms}}$ 由高斯窗平均定义：\n$$s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}$$\n我们的推导将分两个主要步骤进行：计算峰值振幅 $\\max|s(t)|$ 和计算均方根值 $s_{\\mathrm{rms}}$。\n\n**第1步：计算峰值振幅**\n\n峰值振幅是 $|s(t)|$ 在所有 $t \\in \\mathbb{R}$ 上的最大值。\n$$|s(t)| = \\left| \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right| = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right) \\left|\\cos\\left(2\\pi f_{0} t\\right)\\right|$$\n项 $\\exp(-t^{2}/(2\\sigma^{2}))$ 是一个高斯函数，它在 $t=0$ 时有唯一的最大值 $1$。对于任何 $t \\neq 0$，其值严格小于 $1$。项 $|\\cos(2\\pi f_{0} t)|$ 是一个周期函数，最大值为 $1$。其中一个最大值出现在 $t=0$。\n由于两项都在同一点 $t=0$ 达到其最大值 $1$，它们的乘积也在此点达到其全局最大值。\n因此，峰值振幅为：\n$$\\max_{t\\in\\mathbb{R}} |s(t)| = |s(0)| = \\exp(0) \\cdot |\\cos(0)| = 1 \\cdot 1 = 1$$\n\n**第2步：计算均方根值**\n\n$s_{\\mathrm{rms}}$ 的计算需要求解两个积分。我们把分子中的积分记为 $I_{N}$，分母中的积分记为 $I_{D}$。\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{I_{N}}{I_{D}}}$$\n\n首先，我们计算分母积分 $I_{D}$：\n$$I_{D} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-at^{2}) \\mathrm{d}t = \\sqrt{\\pi/a}$。这里，$a=1/\\sigma^2$。\n$$I_{D} = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} = \\sqrt{\\pi\\sigma^{2}} = \\sigma\\sqrt{\\pi}$$\n\n接下来，我们计算分子积分 $I_{N}$：\n$$I_{N} = \\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t = \\int_{-\\infty}^{\\infty} \\left[ \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right]^{2} \\mathrm{d}t$$\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos^{2}\\left(2\\pi f_{0} t\\right)\\mathrm{d}t$$\n我们使用三角恒等式 $\\cos^{2}(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$。令 $\\theta = 2\\pi f_{0} t$。\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right) \\frac{1}{2}\\left[1 + \\cos\\left(4\\pi f_{0} t\\right)\\right]\\mathrm{d}t$$\n我们可以将其分成两个积分：\n$$I_{N} = \\frac{1}{2} \\left[ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t + \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t \\right]$$\n第一个积分就是 $I_{D} = \\sigma\\sqrt{\\pi}$。第二个积分是高斯函数的傅里叶余弦变换。我们使用标准恒等式 $\\int_{-\\infty}^{\\infty} \\exp(-at^{2})\\cos(bt)\\mathrm{d}t = \\sqrt{\\pi/a} \\exp(-b^{2}/(4a))$。\n对于这个积分，我们有 $a=1/\\sigma^2$ 和 $b=4\\pi f_{0}$。\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} \\exp\\left(-\\frac{(4\\pi f_{0})^{2}}{4(1/\\sigma^{2})}\\right) = \\sigma\\sqrt{\\pi} \\exp\\left(-\\frac{16\\pi^{2}f_{0}^{2}\\sigma^{2}}{4}\\right)$$\n$$= \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right)$$\n将此代回 $I_{N}$ 的表达式中：\n$$I_{N} = \\frac{1}{2} \\left[ \\sigma\\sqrt{\\pi} + \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right) \\right] = \\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\n\n现在我们可以计算 $s_{\\mathrm{rms}}^{2}$：\n$$s_{\\mathrm{rms}}^{2} = \\frac{I_{N}}{I_{D}} = \\frac{\\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]}{\\sigma\\sqrt{\\pi}} = \\frac{1}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\n取平方根得到 $s_{\\mathrm{rms}}$：\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}$$\n\n**第3步：推导波峰因数C**\n\n最后，我们将峰值振幅和均方根值代入其定义中，求出波峰因数 $C$：\n$$C = \\frac{\\max|s(t)|}{s_{\\mathrm{rms}}} = \\frac{1}{\\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}} = \\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}$$\n这就是所求的波峰因数 $C$ 作为无量纲参数 $f_{0}\\sigma$ 的封闭形式表达式。\n\n**关于对时域求解器（例如FDTD）影响的讨论**\n\n推导出的波峰因数表达式 $C(f_{0}\\sigma)$ 揭示了波形形状如何影响其作为计算求解器中源的数值特性。我们来分析参数 $f_{0}\\sigma$ 在两种极限情况下 $C$ 的行为，该参数代表高斯包络有效持续时间内的载波周期数。\n\n1.  **低频或脉冲极限 ($f_{0}\\sigma \\to 0$):**\n    当 $f_{0}\\sigma \\to 0$ 时，指数项 $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to \\exp(0) = 1$。\n    $$C \\to \\sqrt{\\frac{2}{1+1}} = \\sqrt{1} = 1$$\n    这对应于基带高斯脉冲（其中 $f_{0}=0$）。波峰因数为 $1$ 意味着峰值等于均方根值，这是恒定（直流）信号的特征。对于给定的脉冲定义，$f_0=0$ 得出 $s(t) = \\exp(-t^2/(2\\sigma^2))$ 且 $s_{\\mathrm{rms}}=1$，从而导致 $C=1$。\n\n2.  **高频或窄带极限 ($f_{0}\\sigma \\gg 1$):**\n    当 $f_{0}\\sigma \\to \\infty$ 时，指数项 $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to 0$。\n    $$C \\to \\sqrt{\\frac{2}{1+0}} = \\sqrt{2}$$\n    这对应于由一个缓慢变化的高斯包络调制的正弦载波，包含许多周期。波峰因数接近 $\\sqrt{2}$，这正是一个理想的、未加窗的正弦波形（$\\cos(\\omega t)$）的波峰因数。\n\n关键的洞见是Gabor脉冲的波峰因数是有界的：$1 \\le C \\le \\sqrt{2}$。这对像FDTD这样的数值方法具有重要影响。\n\n在数值模拟中，**动态范围**指的是最大可表示（不溢出）值与数值噪声基底（由舍入误差引起）之上的最小可辨别值之间的比率。源波形的选择必须适合这个范围。\n- **峰值振幅**（$\\max|s(t)|$）决定了模拟中产生的最大场值。这个峰值必须足够低以防止浮点数溢出，否则会导致灾难性的不稳定性。\n- **均方根值**（$s_{\\mathrm{rms}}$）是有效振幅的度量，并与脉冲的总能量有关。相对于机器精度，这个值必须足够大，以确保记录的场数据具有良好的信噪比（SNR），这些数据稍后将用于后处理（例如，通过傅里叶变换求S参数）。\n\n$C \\le \\sqrt{2}$ 这个事实是非常理想的。这意味着峰值振幅绝不会超过有效均方根振幅的约 $1.414$ 倍。这与其他可能具有非常高波峰因数的信号（例如，一串尖锐的脉冲）形成对比，后者与其总能量含量相比会有非常大的峰值。\n\n对于Gabor脉冲，可以将峰值振幅设置为一个安全的、较高的值（例如，归一化为 $1$）以最大化注入的能量。由此产生的均方根值最差情况下为 $1/\\sqrt{2} \\approx 0.707$，这仍然是峰值的一个相当大的部分。这同时确保了高信噪比和低溢出风险。其波峰因数的良性和有界特性使得Gabor脉冲成为在FDTD和其他时域方法中进行宽带激励的一种数值上稳健且“友好”的源，有助于提高模拟的准确性和稳定性。", "answer": "$$\n\\boxed{\\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}}\n$$", "id": "3310757"}, {"introduction": "理想的数学函数是一回事，而用有限精度的数字硬件生成它则是另一回事。这个实践练习 [@problem_id:3310693] 要求你对一个真实的数字源进行建模，包括相位和幅度的量化效应。你将使用工业标准的频谱度量指标，如无杂散动态范围（SFDR）和载噪比（CNR），来量化由此产生的信号退化，这对于理解仿真中的噪声基底至关重要。", "problem": "考虑一个在一维计算电磁学仿真中驱动电场振幅 $E(t)$ 的源。该激励是一个高斯包络正弦波，其在连续时间下的模型由以下函数表示：\n$$\nE_{\\mathrm{ideal}}(t) = E_0 \\exp\\!\\left(-\\frac{(t - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t\\right),\n$$\n其中，$E_0$ 是峰值电场振幅（单位为 $\\mathrm{V/m}$），$t_0$ 是脉冲中心时间（单位为 $\\mathrm{s}$），$\\sigma$ 是高斯标准差（单位为 $\\mathrm{s}$），$f_0$ 是载波频率（单位为 $\\mathrm{Hz}$）。角度单位为弧度。\n\n在实践中，$E(t)$ 由一个采样系统生成，该系统具有均匀的时间量化步长 $\\Delta t$（采样频率 $f_s = 1/\\Delta t$）和一个定点直接数字频率合成（DDS）相位发生器。DDS 具有一个 M 位相位累加器，并使用一个在 $[-1,1]$ 范围内进行 $B_{\\cos}$ 位均匀幅度量化的余弦查找表。高斯包络通过在 $[0,E_0]$ 范围内进行 $B_{\\mathrm{env}}$ 位的均匀幅度量化来实现。对于整数 $n \\in \\{0,1,\\dots,N-1\\}$，定义采样时间 $t_n = n \\Delta t$，并设置 $t_0 = \\frac{(N-1)\\Delta t}{2}$ 以将脉冲置于记录中心。\n\nDDS 相位累加器使用一个整数频率控制字 $K = \\mathrm{round}\\!\\left(\\frac{f_0}{f_s} 2^M\\right)$，产生离散相位序列：\n$$\n\\phi[n] = \\left( (n K) \\bmod 2^M \\right)\\cdot \\frac{2\\pi}{2^M}.\n$$\n令 $\\mathrm{Q}_{B_{\\cos}}(\\cdot)$ 表示在 $[-1,1]$ 范围内的 $B_{\\cos}$ 位均匀量化，令 $\\mathrm{Q}_{B_{\\mathrm{env}}}(\\cdot)$ 表示在 $[0,E_0]$ 范围内的 $B_{\\mathrm{env}}$ 位均匀量化。实现的离散时间源为：\n$$\nE_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\mathrm{env}}}\\!\\left(E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)\\right)\\cdot \\mathrm{Q}_{B_{\\cos}}\\!\\left(\\cos(\\phi[n])\\right).\n$$\n\n您的任务是评估时间量化和有限精度对调制正弦源的影响，并分析由定点运算引入的相位噪声及其对 $E(t)$ 频谱的影响。请仅使用定义和第一性原理来构建您的算法。具体而言：\n\n1. 通过对连续时间表达式进行采样，构建理想的离散时间参考信号：\n$$\nE_{\\mathrm{float}}[n] = E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t_n\\right),\n$$\n该信号使用浮点算术计算，除了在 $t_n$ 处的固有采样外，不进行任何量化。\n\n2. 构建误差序列：\n$$\ne[n] = E_{\\mathrm{quant}}[n] - E_{\\mathrm{float}}[n].\n$$\n\n3. 使用标准的复指数定义，计算 $E_{\\mathrm{float}}[n]$ 和 $e[n]$ 的单边离散傅里叶变换。将载波频点索引 $k_0$ 确定为非负频率点中其对应频率最接近 $f_0$ 的索引。定义载波频带为索引 $k \\in \\{k_0-2, k_0-1, k_0, k_0+1, k_0+2\\}$，并将其裁剪到有效索引范围内。\n\n4. 定义以下指标：\n   - 载噪比（CNR），以分贝（dB）为单位：\n     $$\n     \\mathrm{CNR} = 10 \\log_{10}\\!\\left(\\frac{\\sum_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\sum_{k \\notin \\mathcal{B},\\, k0} |X_{e}[k]|^2}\\right),\n     $$\n     其中 $X_{\\mathrm{float}}[k]$ 是 $E_{\\mathrm{float}}[n]$ 的单边离散傅里叶变换，$X_{e}[k]$ 是 $e[n]$ 的单边离散傅里叶变换，而 $\\mathcal{B}$ 是载波频带。从分母中排除直流（DC）分量（$k=0$）。\n   - 无杂散动态范围（SFDR），以分贝（dB）为单位，计算如下：\n     $$\n     \\mathrm{SFDR} = 10 \\log_{10}\\!\\left(\\frac{\\max_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\max_{k \\notin \\mathcal{B},\\, k0} |X_{e}[k]|^2}\\right).\n     $$\n   - 均方根（RMS）相位误差，以弧度为单位，在理想包络足够大（使用阈值标准 $E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\ge 0.2 E_0$）的索引上计算：\n     使用希尔伯特变换获得 $E_{\\mathrm{quant}}[n]$ 的解析信号 $z_{\\mathrm{quant}}[n]$，并定义瞬时相位 $\\hat{\\phi}[n] = \\mathrm{unwrap}(\\arg(z_{\\mathrm{quant}}[n]))$。计算\n     $$\n     \\epsilon_\\phi[n] = \\hat{\\phi}[n] - \\left(2\\pi f_0 t_n + b\\right),\n     $$\n     其中 $b$ 是在满足阈值条件的索引上最小化均方误差的常数，然后报告\n     $$\n     \\phi_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N_\\mathrm{thr}} \\sum_{n \\in \\mathcal{I}_\\mathrm{thr}} \\epsilon_\\phi[n]^2},\n     $$\n     其中 $\\mathcal{I}_\\mathrm{thr}$ 是满足阈值条件的索引集合， $N_\\mathrm{thr}$ 是其基数。\n\n所有角度必须以弧度为单位。所有时间必须以秒为单位。所有频率必须以赫兹为单位。电场振幅必须以伏特/米为单位。\n\n实现一个完整、可运行的程序，对于下面测试套件中的每个测试用例，计算并按顺序 $\\left[\\mathrm{CNR}, \\mathrm{SFDR}, \\phi_{\\mathrm{rms}}\\right]$ 以浮点数形式返回上述指标。您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，该列表按给定顺序连接所有测试用例的三元组。\n\n测试套件参数集 $(f_s, f_0, N, \\sigma, E_0, M, B_{\\cos}, B_{\\mathrm{env}})$：\n- 情况 A（正常路径）： $(10^9, 1.25\\times 10^8, 16384, 1.0\\times 10^{-7}, 1.0, 28, 14, 14)$。\n- 情况 B（接近较高分数带宽的粗糙量化）： $(2.0\\times 10^8, 8.0\\times 10^7, 8192, 2.5\\times 10^{-7}, 1.0, 16, 10, 10)$。\n- 情况 C（DDS 无法精确表示的频率）： $(5.0\\times 10^8, 1.93333333333\\times 10^8, 8192, 1.2\\times 10^{-7}, 1.0, 12, 8, 8)$。\n- 情况 D（近似稳态振幅的极宽广高斯包络）： $(10^9, 3.0\\times 10^8, 16384, 3.0\\times 10^{-6}, 1.0, 20, 12, 12)$。\n\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表（例如，$[\\mathrm{CNR}_A,\\mathrm{SFDR}_A,\\phi_{\\mathrm{rms},A},\\mathrm{CNR}_B,\\mathrm{SFDR}_B,\\phi_{\\mathrm{rms},B},\\mathrm{CNR}_C,\\mathrm{SFDR}_C,\\phi_{\\mathrm{rms},C},\\mathrm{CNR}_D,\\mathrm{SFDR}_D,\\phi_{\\mathrm{rms},D}]$）。这些值必须是浮点数。以分贝表示 $\\mathrm{CNR}$ 和 $\\mathrm{SFDR}$，以弧度表示 $\\phi_{\\mathrm{rms}}$。", "solution": "用户提供了一个问题，要求对有限精度数字合成调制正弦源所引入的误差进行定量分析。该问题具有科学依据，提法明確，并包含得出唯一解所需的所有必要信息。我们将通过实现一个直接遵循指定步骤的算法来解决它。\n\n问题的核心是将高斯包络正弦波的理想浮点表示与其实际的定点实现进行比较，并使用成熟的信号处理指标来量化它们之间的差异。该算法设计分为四个主要阶段：信号生成、误差计算、频谱分析和指标评估。\n\n**1. 信号生成**\n\n首先，我们通过构建理想的离散时间参考信号 $E_{\\mathrm{float}}[n]$ 来建立一个基准。该信号是通过在离散时间点 $t_n = n \\Delta t$（其中 $\\Delta t = 1/f_s$ 是采样周期）对连续时间理想函数进行采样得到的。\n$$\nE_{\\mathrm{float}}[n] = E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t_n\\right)\n$$\n通过设置 $t_0 = \\frac{(N-1)\\Delta t}{2}$，将脉冲置于N个采样点的时间窗口中心。此参考信号的所有计算均使用标准双精度浮点运算执行。\n\n接下来，我们对真实的量化信号 $E_{\\mathrm{quant}}[n]$ 进行建模。该模型包含了数字硬件固有的两个主要误差来源：相位截断和幅度量化。\n\n相位由直接数字频率合成器（DDS）模型生成。DDS 使用一个 M 位相位累加器和一个频率控制字 K。K 是所需归一化频率的最接近整数表示，由 $K = \\mathrm{round}\\!\\left(\\frac{f_0}{f_s} 2^M\\right)$ 给出。在每个时间步 n，相位累加器的值增加 K，然后对 $2^M$ 取模。由此产生的离散相位序列是：\n$$\n\\phi[n] = \\left( (n K) \\bmod 2^M \\right)\\cdot \\frac{2\\pi}{2^M}\n$$\n“模”运算是相位截断误差的来源，该误差表现为相位噪声。该相位的余弦值 $\\cos(\\phi[n])$ 随后在 $[-1, 1]$ 范围内被量化为 $B_{\\cos}$ 位。\n\n高斯包络 $E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)$ 则在 $[0, E_0]$ 范围内被单独量化为 $B_{\\mathrm{env}}$ 位。\n\n我们定义一个通用的均匀量化函数 $\\mathrm{Q}_B(x; x_{\\min}, x_{\\max})$，它将一个值 $x$ 映射到在 $[x_{\\min}, x_{\\max}]$ 范围内均匀分布的 $2^B$ 个离散电平中的一个。步长为 $\\Delta = (x_{\\max} - x_{\\min}) / (2^B - 1)$。该函数实现为：\n$$\n\\mathrm{Q}_B(x) = x_{\\min} + \\mathrm{round}\\left(\\frac{x - x_{\\min}}{\\Delta}\\right) \\Delta\n$$\n使用此函数，量化后的分量为：\n$$\n\\text{envelope}_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\mathrm{env}}}\\!\\left(E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)\\right)\n$$\n$$\n\\text{carrier}_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\cos}}\\!\\left(\\cos(\\phi[n])\\right)\n$$\n最终的量化信号是这两个分量的乘积：\n$$\nE_{\\mathrm{quant}}[n] = \\text{envelope}_{\\mathrm{quant}}[n] \\cdot \\text{carrier}_{\\mathrm{quant}}[n]\n$$\n\n**2. 误差信号和频谱分析**\n\n数字合成过程引入的总误差由误差序列 $e[n]$ 体现，其定义为量化信号与理想信号之间的逐点差：\n$$\ne[n] = E_{\\mathrm{quant}}[n] - E_{\\mathrm{float}}[n]\n$$\n为了分析信号和误差的特性，我们计算它们的离散傅里叶变换（DFT），分别表示为 $X_{\\mathrm{float}}[k]$ 和 $X_{e}[k]$。我们使用标准的未缩放 DFT 定义：$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp(-j 2\\pi nk/N)$。分析在单边谱上进行，仅考虑非负频率点，这些点对应于索引 $k \\in \\{0, 1, \\dots, N/2\\}$。\n\n定义一个载波频带 $\\mathcal{B}$ 以分离出目标信号功率。它包含最接近载波频率 $f_0$ 的频率点 $k_0$ 及其四个最近的邻居：$\\mathcal{B} = \\{k_0-2, k_0-1, k_0, k_0+1, k_0+2\\}$，并裁剪到非负频率索引的有效范围内。这里，$k_0 = \\mathrm{round}(f_0 N / f_s)$。\n\n**3. 性能指标**\n\n计算出频谱后，我们评估三个指定的性能指标。\n\n**载噪比（CNR）：** 此指标测量所需信号频带内的总功率与该频带外的误差信号总功率之比。它提供了对信号质量的全局度量。我们从噪声计算中排除了直流分量（$k=0$）。\n$$\n\\mathrm{CNR} = 10 \\log_{10}\\!\\left(\\frac{\\sum_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\sum_{k \\notin \\mathcal{B},\\, k0} |X_{e}[k]|^2}\\right)\n$$\n\n**无杂散动态范围（SFDR）：** 此指标给出载波频带中最强分量的功率与误差频谱中最强不期望分量（杂散）的功率之比。对于关注杂散音调干扰的系统来说，这是一个关键的测量指标。\n$$\n\\mathrm{SFDR} = 10 \\log_{10}\\!\\left(\\frac{\\max_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\max_{k \\notin \\mathcal{B},\\, k0} |X_{e}[k]|^2}\\right)\n$$\n对于 CNR 和 SFDR，在分母上加上一个小的 epsilon 以防止在数值误差可能忽略不计的高精度情况下出现除零错误。\n\n**均方根（RMS）相位误差：** 此指标专门量化相位噪声。它仅在脉冲中信号较强的部分进行计算，该部分由理想包络幅度超过其峰值20%的条件定义，即 $E_0 \\exp(-\\frac{(t_n-t_0)^2}{2\\sigma^2}) \\ge 0.2 E_0$。令满足此条件的索引集合为 $\\mathcal{I}_{\\mathrm{thr}}$。\n\n首先，我们使用希尔伯特变换计算 $E_{\\mathrm{quant}}[n]$ 的解析信号，$z_{\\mathrm{quant}}[n] = E_{\\mathrm{quant}}[n] + j\\mathcal{H}\\{E_{\\mathrm{quant}}[n]\\}$。然后提取瞬时相位并进行解卷绕以使其连续：$\\hat{\\phi}[n] = \\mathrm{unwrap}(\\arg(z_{\\mathrm{quant}}[n]))$。\n\n相位误差 $\\epsilon_\\phi[n]$ 是测得相位与理想线性相位斜坡 $2\\pi f_0 t_n$ 之间的差值，其中移除了任何恒定的相位偏移 $b$。选择偏移量 $b$ 以最小化在阈值索引上的均方误差，这对应于该区域相位差的均值：$b = \\frac{1}{N_{\\mathrm{thr}}}\\sum_{n \\in \\mathcal{I}_{\\mathrm{thr}}} (\\hat{\\phi}[n] - 2\\pi f_0 t_n)$。相位误差则为 $\\epsilon_\\phi[n] = (\\hat{\\phi}[n] - 2\\pi f_0 t_n) - b$。\n\n最后，RMS 相位误差是在阈值区域内相位误差平方的均值的平方根：\n$$\n\\phi_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N_{\\mathrm{thr}}} \\sum_{n \\in \\mathcal{I}_{\\mathrm{thr}}} \\epsilon_\\phi[n]^2}\n$$\n其中 $N_{\\mathrm{thr}}$ 是 $\\mathcal{I}_{\\mathrm{thr}}$ 中的索引数量。这个过程能够稳健地量化由 DDS 和量化引入的相位抖动，且不受任何固定相位偏移的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem solution.\n    It iterates through test cases, computes metrics, and prints the final result.\n    \"\"\"\n\n    def quantize(x, min_val, max_val, num_bits):\n        \"\"\"\n        Performs uniform amplitude quantization.\n        \n        Args:\n            x (np.ndarray): The input signal to be quantized.\n            min_val (float): The minimum value of the quantization range.\n            max_val (float): The maximum value of the quantization range.\n            num_bits (int): The number of bits for quantization.\n\n        Returns:\n            np.ndarray: The quantized signal.\n        \"\"\"\n        num_levels = 2**num_bits\n        if num_levels == 1:\n            return np.full_like(x, (min_val + max_val) / 2.0)\n        \n        delta = (max_val - min_val) / (num_levels - 1)\n        if delta == 0:\n            return np.full_like(x, min_val)\n            \n        quantized_indices = np.round((x - min_val) / delta)\n        quantized_values = min_val + quantized_indices * delta\n        \n        return np.clip(quantized_values, min_val, max_val)\n\n    def compute_metrics(fs, f0, N, sigma, E0, M, B_cos, B_env):\n        \"\"\"\n        Computes CNR, SFDR, and RMS phase error for a given parameter set.\n        \"\"\"\n        # 1. Setup time vector and pulse center\n        dt = 1.0 / fs\n        t = np.arange(N, dtype=np.float64) * dt\n        t0 = (N - 1) * dt / 2.0\n\n        # 2. Generate E_float (ideal discrete-time reference)\n        time_exp_term = (t - t0)**2\n        gaussian_envelope_ideal = E0 * np.exp(-time_exp_term / (2.0 * sigma**2))\n        carrier_ideal = np.cos(2.0 * np.pi * f0 * t)\n        E_float = gaussian_envelope_ideal * carrier_ideal\n\n        # 3. Generate E_quant (realized discrete-time source)\n        # DDS phase generation\n        K = np.round((f0 / fs) * (2**M))\n        n_indices = np.arange(N, dtype=np.int64)\n        phase_accumulator = (n_indices * K) % (2**M)\n        phi_dds = phase_accumulator * (2.0 * np.pi / (2**M))\n        \n        # Quantized carrier from cosine lookup\n        carrier_unquantized = np.cos(phi_dds)\n        carrier_quantized = quantize(carrier_unquantized, -1.0, 1.0, B_cos)\n\n        # Quantized envelope\n        envelope_quantized = quantize(gaussian_envelope_ideal, 0.0, E0, B_env)\n        \n        E_quant = envelope_quantized * carrier_quantized\n\n        # 4. Form error sequence\n        e = E_quant - E_float\n\n        # 5. Perform spectral analysis\n        X_float = np.fft.fft(E_float)\n        X_e = np.fft.fft(e)\n        \n        # Use one-sided spectrum for analysis (non-negative frequencies)\n        num_freq_bins = N // 2 + 1\n        X_float_one_sided = X_float[:num_freq_bins]\n        X_e_one_sided = X_e[:num_freq_bins]\n\n        # Define carrier band\n        freq_res = fs / N\n        k0 = int(np.round(f0 / freq_res))\n        carrier_band_indices = np.arange(max(0, k0 - 2), min(num_freq_bins, k0 + 3))\n\n        # 6. Calculate performance metrics\n        epsilon = 1e-30  # Small value to prevent log(0) or division by zero\n\n        # CNR calculation\n        signal_power = np.sum(np.abs(X_float_one_sided[carrier_band_indices])**2)\n        all_positive_indices = np.arange(1, num_freq_bins)\n        noise_indices = np.setdiff1d(all_positive_indices, carrier_band_indices, assume_unique=True)\n        noise_power = np.sum(np.abs(X_e_one_sided[noise_indices])**2)\n        cnr = 10.0 * np.log10(signal_power / (noise_power + epsilon))\n\n        # SFDR calculation\n        peak_signal_power = np.max(np.abs(X_float_one_sided[carrier_band_indices])**2)\n        if noise_indices.size == 0:\n            peak_spur_power = 0.0\n        else:\n            peak_spur_power = np.max(np.abs(X_e_one_sided[noise_indices])**2)\n        sfdr = 10.0 * np.log10(peak_signal_power / (peak_spur_power + epsilon))\n\n        # RMS phase error calculation\n        threshold = 0.2 * E0\n        thr_indices = np.where(gaussian_envelope_ideal >= threshold)[0]\n        \n        phi_rms = 0.0\n        if thr_indices.size > 0:\n            z_quant = signal.hilbert(E_quant)\n            inst_phase_quant = np.unwrap(np.angle(z_quant))\n            ideal_phase_ramp = 2.0 * np.pi * f0 * t\n            phase_diff = inst_phase_quant - ideal_phase_ramp\n            \n            # Remove constant phase offset by subtracting the mean\n            b = np.mean(phase_diff[thr_indices])\n            phase_error = phase_diff - b\n\n            phi_rms = np.sqrt(np.mean(phase_error[thr_indices]**2))\n\n        return cnr, sfdr, phi_rms\n\n    test_cases = [\n        # (fs, f0, N, sigma, E0, M, B_cos, B_env)\n        (1e9, 1.25e8, 16384, 1.0e-7, 1.0, 28, 14, 14),\n        (2.0e8, 8.0e7, 8192, 2.5e-7, 1.0, 16, 10, 10),\n        (5.0e8, 1.93333333333e8, 8192, 1.2e-7, 1.0, 12, 8, 8),\n        (1.0e9, 3.0e8, 16384, 3.0e-6, 1.0, 20, 12, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters: all are floats except N, M, B_cos, B_env\n        fs, f0, N_int, sigma, E0, M_int, B_cos_int, B_env_int = case\n        cnr, sfdr, phi_rms = compute_metrics(\n            fs, f0, int(N_int), sigma, E0, int(M_int), int(B_cos_int), int(B_env_int)\n        )\n        results.extend([cnr, sfdr, phi_rms])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310693"}, {"introduction": "激励源参数的选择对整体计算成本有着深远的影响。最后一个练习 [@problem_id:3310734] 将引导你从更高层面进行分析，推导源带宽与两种不同高级求解器架构（伪谱时域法PSTD和辅助微分方程FDTD法）的总计算工作量之间的关系模型。这种“信封背面”式的估算能力，对于规划和预测大规模仿真的性能而言是无价之宝。", "problem": "必须设计一个一维时域电磁仿真，用于生成宽带激励，并为两类求解器（使用快速傅里叶变换 (FFT) 的伪谱时域 (PSTD) 和针对单极点德拜色散使用辅助微分方程 (ADE) 的时域有限差分 (FDTD)）设定算法工作负载的基准。目标是量化当离散化选择为解析脉冲最高有效频率分量时，总计算工作负载如何随源带宽扩展。该问题必须从波传播和采样约束的基本原理出发进行求解，并且算法工作负载必须根据基本操作计数来定义，而不依赖于经验计时。\n\n假设一个长度为 $L$、光速为 $c$ 的一维真空域，以及一个形式为 $s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$ 的时域源，其中心频率为 $f_{0}$，时间标准差为 $\\sigma_{t}$。根据傅里叶分析，高斯调制正弦波的正频率谱是中心位于 $f_{0}$、标准差为 $\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}$ 的高斯分布。为确保频谱截断可以忽略不计，定义最大设计频率为 $f_{\\max} = f_{0} + m\\,\\sigma_{f}$，其中 $m$ 为一固定值。离散化必须满足时域电磁学中两个标准约束：每个最小波长的最小空间点数和对时间步长的 Courant 稳定性界限。具体来说，设最小可分辨波长为 $\\lambda_{\\min} = \\frac{c}{f_{\\max}}$，强制每个 $\\lambda_{\\min}$ 有 $p$ 个点，因此 $\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}$，并选择时间步长 $\\Delta t = S \\frac{\\Delta x}{c}$，其中 Courant 数 $S \\in (0,1)$。考虑一个总仿真时间窗口 $T_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}$，其中 $q$ 是时间标准差的一个固定倍数，选择该值以基本上捕获所有脉冲能量和脉冲穿过域的传播时间。设空间样本数为 $N = \\lceil \\frac{L}{\\Delta x} \\rceil$，时间步数为 $N_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil$，FFT 网格大小为 $N_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}$（不小于 $N$ 的最小的2的幂），以对 FFT 工作负载施加压力。\n\n定义一个操作计数模型，其中一个操作单元是一个浮点加法或乘法。对于 PSTD 求解器，将每个时间步建模为完成固定数量的长度为 $N_{\\text{fft}}$ 的复数 FFT；假设每个时间步有 $n_{\\text{fft}}$ 个此类变换，并且一个长度为 $N_{\\text{fft}}$ 的复数 FFT 耗费 $k_{\\text{fft}}\\,N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$ 个操作单元。因此，总 PSTD 工作负载是每步 FFT 成本与步数的乘积。对于具有单极点德拜极化的 ADE-FDTD 求解器，将每个单元、每个时间步的工作负载建模为一个常数 $k_{\\text{cell}}$ 操作单元，计入一次磁场更新、一次极化更新和一次电场更新。因此，总 ADE-FDTD 工作负载是每个单元的成本乘以 $N$ 再乘以 $N_{t}$。\n\n所有物理常数和建模参数均被视为给定常数：\n- 光速：$c = 299792458$ (单位 $\\text{m/s}$)。\n- 域长度：$L = 1.0$ (单位 $\\text{m}$)。\n- 每个最小波长的点数：$p = 12$。\n- 频谱截断倍数：$m = 4$。\n- Courant 数：$S = 0.99$。\n- 时间窗口倍数：$q = 6$。\n- FFT 成本系数：$k_{\\text{fft}} = 5$。\n- PSTD 中每个时间步的复数 FFT 数量：$n_{\\text{fft}} = 4$。\n- ADE-FDTD 每单元成本：$k_{\\text{cell}} = 12$。\n\n使用以上常数和定义，为测试套件中的每个测试用例计算以下内容：\n- 总 PSTD 工作负载 $W_{\\text{PSTD}}$（以操作单元为单位）。\n- 总 ADE-FDTD 工作负载 $W_{\\text{ADE}}$（以操作单元为单位）。\n\n此外，在整个测试套件上，通过对数-对数坐标上的最小二乘拟合计算两个缩放指数：\n- $\\log W_{\\text{PSTD}}$ 相对于 $\\log f_{\\max}$ 的斜率 $s_{\\text{PSTD}}$。\n- $\\log W_{\\text{ADE}}$ 相对于 $\\log f_{\\max}$ 的斜率 $s_{\\text{ADE}}$。\n\n测试套件包含四个用例，所有单位都已明确指定：\n1. 用例 A（中等宽带，调制）：$f_{0} = 3000000000$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.0000000005$ (单位 $\\text{s}$)。\n2. 用例 B（强宽带，调制）：$f_{0} = 3000000000$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.00000000005$ (单位 $\\text{s}$)。\n3. 用例 C（超宽带，基带高斯）：$f_{0} = 0$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.00000000002$ (单位 $\\text{s}$)。\n4. 用例 D（窄带，调制）：$f_{0} = 3000000000$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.000000005$ (单位 $\\text{s}$)。\n\n您的程序必须按 A、B、C、D 的顺序为每个用例计算工作负载对 $\\left(W_{\\text{PSTD}}, W_{\\text{ADE}}\\right)$。然后使用所有四个用例计算两个斜率 $s_{\\text{PSTD}}$ 和 $s_{\\text{ADE}}$。将工作负载报告为整数（操作单元），斜率报告为四舍五入到三位小数的十进制数。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表形式的结果，并用方括号括起来，顺序如下：\n$\\left[W_{\\text{PSTD}}^{(A)}, W_{\\text{ADE}}^{(A)}, W_{\\text{PSTD}}^{(B)}, W_{\\text{ADE}}^{(B)}, W_{\\text{PSTD}}^{(C)}, W_{\\text{ADE}}^{(C)}, W_{\\text{PSTD}}^{(D)}, W_{\\text{ADE}}^{(D)}, s_{\\text{PSTD}}, s_{\\text{ADE}}\\right]$。\n所有工作负载都是无单位的操作计数；输出不需要物理单位，并且不出现角度。斜率必须表示为小数（而非百分比）。", "solution": "该问题要求计算两种电磁学数值方法（伪谱时域 (PSTD) 和带有辅助微分方程的时域有限差分 (ADE-FDTD)）在各种源条件下的计算工作负载。此外，它还要求分析这些工作负载如何随源的最大频率分量进行扩展。该解决方案是根据波理论、数值离散化和指定的算法复杂度分析的基本原理推导出来的。\n\n此过程首先需要根据每个测试用例给定的物理源参数计算必要的仿真参数。\n源是一个高斯调制正弦波，$s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$，其中心频率为 $f_{0}$，时间标准差为 $\\sigma_{t}$。其频谱特性决定了仿真要求。脉冲频谱在频域的标准差 $\\sigma_{f}$ 与其时间标准差成反比：\n$$\n\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}\n$$\n为了准确捕获脉冲的能量，仿真必须解析高达最大设计频率 $f_{\\max}$ 的频率。该频率通过从中心频率扩展频谱标准差的 $m$ 倍来定义：\n$$\nf_{\\max} = f_{0} + m\\,\\sigma_{f}\n$$\n确定 $f_{\\max}$ 后，我们可以确定所需的空间和时间离散化。为使数值方法稳定和准确，其网格必须能解析存在的最小波长，即 $\\lambda_{\\min} = c/f_{\\max}$。空间步长 $\\Delta x$ 设置为该最小波长的一小部分，由参数 $p$（每个波长的点数）控制：\n$$\n\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}\n$$\n然后，通过将域长度 $L$ 除以 $\\Delta x$ 并取上限，得到总空间网格点数 $N$，以确保覆盖整个域：\n$$\nN = \\left\\lceil \\frac{L}{\\Delta x} \\right\\rceil = \\left\\lceil \\frac{L\\,p\\,f_{\\max}}{c} \\right\\rceil\n$$\n时间步长 $\\Delta t$ 受 Courant-Friedrichs-Lewy (CFL) 稳定性条件的约束。它通过 Courant 数 $S$ 与 $\\Delta x$ 相关：\n$$\n\\Delta t = S \\frac{\\Delta x}{c} = S \\frac{1}{p\\,f_{\\max}}\n$$\n总仿真时长 $T_{\\text{tot}}$ 必须足够长，以使波能够传播穿过整个域（时间 $L/c$），并让脉冲时间包络的绝大部分通过，这被估计为 $\\sigma_{t}$ 的 $q$ 倍：\n$$\nT_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}\n$$\n总时间步数 $N_{t}$ 则是总时长除以时间步长，同样取其上限：\n$$\nN_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil = \\left\\lceil \\left(\\frac{L}{c} + q\\,\\sigma_{t}\\right) \\frac{p\\,f_{\\max}}{S} \\right\\rceil\n$$\n对于依赖快速傅里叶变换 (FFT) 的 PSTD 方法，当网格大小是 2 的幂时，性能最佳。因此，用于 FFT 的计算网格大小 $N_{\\text{fft}}$ 被定义为不小于 $N$ 的最小的 2 的幂：\n$$\nN_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}\n$$\n有了这些导出的数值参数 ($N, N_{t}, N_{\\text{fft}}$)，我们就可以应用给定的操作计数模型来计算工作负载。\nPSTD 工作负载 $W_{\\text{PSTD}}$ 建模为总时间步数 $N_t$ 乘以每个时间步的成本。每步的成本由 FFT 的数量 $n_{\\text{fft}}$、成本系数 $k_{\\text{fft}}$ 以及大小为 $N_{\\text{fft}}$ 的单个 FFT 的复杂度 $N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$ 决定：\n$$\nW_{\\text{PSTD}} = N_{t} \\cdot n_{\\text{fft}} \\cdot k_{\\text{fft}} \\cdot N_{\\text{fft}} \\log_{2} N_{\\text{fft}}\n$$\nADE-FDTD 工作负载 $W_{\\text{ADE}}$ 是一个更简单的计算量模型。它是每个单元更新成本 $k_{\\text{cell}}$、空间单元数 $N$ 和时间步数 $N_t$ 的乘积：\n$$\nW_{\\text{ADE}} = k_{\\text{cell}} \\cdot N \\cdot N_{t}\n$$\n最后，为了分析这些工作负载相对于最大频率的缩放情况，我们假设存在幂律关系 $W \\propto (f_{\\max})^s$。对两边取对数得到 $\\log W = s \\log f_{\\max} + \\log(\\text{constant})$，这是一个线性方程。缩放指数 $s$ 是对每个测试用例 $i$ 的数据点 $(\\log f_{\\max}^{(i)}, \\log W^{(i)})$ 进行最佳拟合直线的斜率。该斜率使用标准的线性最小二乘回归法计算。对于一组点 $(x_i, y_i)$，斜率 $s$ 的公式为：\n$$\ns = \\frac{\\sum (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum (x_i - \\bar{x})^2}\n$$\n其中 $x_i = \\log f_{\\max}^{(i)}$ 和 $y_i = \\log W^{(i)}$。此过程分别应用于 $W_{\\text{PSTD}}$ 和 $W_{\\text{ADE}}$ 的数据集，以找到指数 $s_{\\text{PSTD}}$ 和 $s_{\\text{ADE}}$。\n\n提供的常数为：$c = 299792458$, $L=1.0$, $p=12$, $m=4$, $S=0.99$, $q=6$, $k_{\\text{fft}}=5$, $n_{\\text{fft}}=4$, 以及 $k_{\\text{cell}}=12$。将这些值连同每个测试用例的参数代入上述公式，即可计算出最终结果。所有工作负载结果都将转换为整数，斜率将按要求四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics workload problem.\n\n    This function calculates the computational workloads for PSTD and ADE-FDTD methods\n    for a set of test cases involving Gaussian-modulated sinusoidal sources. It then\n    computes the scaling exponents of these workloads with respect to the maximum\n    simulation frequency using a log-log linear least-squares fit.\n    \"\"\"\n\n    # Define physical constants and modeling parameters.\n    c = 299792458       # Speed of light in m/s\n    L = 1.0             # Domain length in m\n    p = 12              # Points per minimum wavelength\n    m = 4               # Spectral truncation multiple\n    S = 0.99            # Courant number\n    q = 6               # Time-window multiple\n    k_fft = 5           # FFT cost coefficient\n    n_fft = 4           # Number of complex FFTs per time step in PSTD\n    k_cell = 12         # ADE-FDTD per-cell cost\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f0 in Hz, sigma_t in s)\n        (3.0e9, 5.0e-10),  # Case A\n        (3.0e9, 5.0e-11),  # Case B\n        (0.0,   2.0e-11),  # Case C\n        (3.0e9, 5.0e-9),   # Case D\n    ]\n\n    results = []\n    log_fmax_list = []\n    log_w_pstd_list = []\n    log_w_ade_list = []\n\n    for f0, sigma_t in test_cases:\n        # Step 1: Calculate maximum frequency\n        sigma_f = 1 / (2 * np.pi * sigma_t)\n        f_max = f0 + m * sigma_f\n\n        # Step 2: Calculate discretization parameters\n        delta_x = c / (p * f_max)\n        delta_t = S / (p * f_max) # This is equivalent to S * delta_x / c\n\n        # Step 3: Calculate grid and time dimensions\n        N = int(np.ceil(L / delta_x))\n        T_tot = L / c + q * sigma_t\n        N_t = int(np.ceil(T_tot / delta_t))\n\n        # Step 4: Calculate FFT grid size\n        # N is guaranteed to be >= 1 for the given parameters.\n        if N > 1:\n            log2_N_ceil = int(np.ceil(np.log2(N)))\n        else: # This branch handles N = 1\n            log2_N_ceil = 0\n        N_fft = 1  log2_N_ceil\n\n        # Step 5: Calculate workloads\n        W_pstd = N_t * n_fft * k_fft * N_fft * log2_N_ceil\n        W_ade = k_cell * N * N_t\n        \n        results.extend([int(W_pstd), int(W_ade)])\n\n        # Step 6: Store log values for regression\n        log_fmax_list.append(np.log(f_max))\n        # Add a small epsilon to workloads that could be zero to avoid log(0)\n        # In this problem, workloads are guaranteed to be positive.\n        log_w_pstd_list.append(np.log(W_pstd))\n        log_w_ade_list.append(np.log(W_ade))\n\n    # Step 7: Compute scaling exponents using least-squares fit on log-log data\n    # np.polyfit(x, y, 1) returns [slope, intercept] for the best-fit line.\n    slope_pstd, _ = np.polyfit(log_fmax_list, log_w_pstd_list, 1)\n    slope_ade, _ = np.polyfit(log_fmax_list, log_w_ade_list, 1)\n\n    results.extend([round(slope_pstd, 3), round(slope_ade, 3)])\n    \n    # Final print statement in the exact required format.\n    # Convert all numbers to string before joining\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3310734"}]}