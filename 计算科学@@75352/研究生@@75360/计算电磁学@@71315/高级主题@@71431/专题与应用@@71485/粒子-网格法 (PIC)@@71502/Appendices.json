{"hands_on_practices": [{"introduction": "在粒子模拟(PIC)方法中，首要步骤是将离散粒子的物理量（如电荷）分配到网格点上。这个实践将引导你通过编程实现，来量化比较两种基础的电荷分配方案：最近网格点(NGP)法和云中单元(CIC)法[@problem_id:3310354]。通过计算离散高斯定律的误差，你将亲身体会到不同分配方案如何影响物理守恒律的精确性，并深入理解数值精度与计算成本之间的权衡。", "problem": "给定一个均匀的三维笛卡尔网格和一个点电荷。目标是比较“粒子模拟”(Particle-In-Cell, PIC)方法中使用的两种电荷分配方案——最近单元分配(nearest-cell deposition)和单元云分配(cloud-in-cell deposition)——并评估在网格上由这两种方案产生的离散高斯定律误差的 $L^2$ 范数和最大范数。该评估必须通过以下方式执行：使用点电荷的连续库仑电场计算通过每个单元闭合表面的近似电通量，然后将该基于通量的包围电荷与每种方案下每个单元的分配电荷进行比较。使用归一化单位，其中真空介电常数设为1，即 $\\varepsilon_0 = 1$，单位电荷为 $q = 1$，因此所有输出都是无量纲的浮点数，没有物理单位。\n\n基本原理：静电学形式的麦克斯韦方程组要求电场的散度等于电荷密度除以真空介电常数，即微分形式的高斯定律 $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$。其积分形式断言，通过任何闭合曲面的电通量等于该曲面内包围的总电荷除以真空介电常数，即 $\\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = Q_{\\mathrm{enc}} / \\varepsilon_0$。在自由空间中，点电荷的静电场为 $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0) \\right) q \\, (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$。\n\n离散设置与近似：\n- 网格：设域为矩形盒 $[0, L_x] \\times [0, L_y] \\times [0, L_z]$，划分为 $N_x \\times N_y \\times N_z$ 个均匀单元，间距分别为 $h_x = L_x/N_x$，$h_y = L_y/N_y$，$h_z = L_z/N_z$。单元索引为 $(i,j,k)$，其中 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，$k \\in \\{0,\\dots,N_z-1\\}$。单元 $(i,j,k)$ 的中心坐标为 $(x_i, y_j, z_k) = \\left((i + 0.5) h_x, (j + 0.5) h_y, (k + 0.5) h_z\\right)$。\n- 电通量近似：对于每个单元 $(i,j,k)$，使用其各面上的中点法则来近似计算通过其闭合表面的净电通量。六个面的中心分别是\n  - 左面中心位于 $\\left(i h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_x^- = (-1,0,0)$，面积为 $A_x = h_y h_z$，\n  - 右面中心位于 $\\left((i+1) h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_x^+ = (1,0,0)$，面积为 $A_x = h_y h_z$，\n  - 底面中心位于 $\\left((i+0.5) h_x, j h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_y^- = (0,-1,0)$，面积为 $A_y = h_x h_z$，\n  - 顶面中心位于 $\\left((i+0.5) h_x, (j+1) h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_y^+ = (0,1,0)$，面积为 $A_y = h_x h_z$，\n  - 后面中心位于 $\\left((i+0.5) h_x, (j+0.5) h_y, k h_z\\right)$，外法线为 $\\mathbf{n}_z^- = (0,0,-1)$，面积为 $A_z = h_x h_y$，\n  - 前面中心位于 $\\left((i+0.5) h_x, (j+0.5) h_y, (k+1) h_z\\right)$，外法线为 $\\mathbf{n}_z^+ = (0,0,1)$，面积为 $A_z = h_x h_y$。\n  使用点电荷的连续库仑场，记 $\\mathbf{E}_{\\mathrm{face}}$ 为在相应面中心处计算的场。近似的净通量则为\n  $$\\Phi_{i,j,k} \\approx A_x \\left(\\mathbf{E}_{\\mathrm{right}} \\cdot \\mathbf{n}_x^+\\right) + A_x \\left(\\mathbf{E}_{\\mathrm{left}} \\cdot \\mathbf{n}_x^-\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{top}} \\cdot \\mathbf{n}_y^+\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{bottom}} \\cdot \\mathbf{n}_y^-\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{front}} \\cdot \\mathbf{n}_z^+\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{back}} \\cdot \\mathbf{n}_z^-\\right)。$$\n- 最近单元分配 (NGP)：将全部电荷 $q$ 分配到包含点电荷坐标 $\\mathbf{r}_0 = (x_0,y_0,z_0)$ 的单个单元中。也就是说，如果 $i^\\ast = \\lfloor x_0/h_x \\rfloor$，$j^\\ast = \\lfloor y_0/h_y \\rfloor$，$k^\\ast = \\lfloor z_0/h_z \\rfloor$，那么单元 $(i,j,k)$ 的分配电荷为\n  $$Q^{\\mathrm{NGP}}_{i,j,k} = \\begin{cases} q,  \\text{if } (i,j,k) = (i^\\ast,j^\\ast,k^\\ast), \\\\ 0,  \\text{otherwise.} \\end{cases}$$\n- 单元云分配 (CIC)：通过三线性权重，将电荷 $q$ 分配到其中心沿每个轴紧邻点位置 $\\mathbf{r}_0$ 的 $2 \\times 2 \\times 2$ 单元块中。令 $i_0 = \\left\\lfloor x_0/h_x - 0.5 \\right\\rfloor$, $j_0 = \\left\\lfloor y_0/h_y - 0.5 \\right\\rfloor$, $k_0 = \\left\\lfloor z_0/h_z - 0.5 \\right\\rfloor$，并进行钳位（clamped）以使 $i_0 \\in \\{0,\\dots,N_x-2\\}$，$j_0 \\in \\{0,\\dots,N_y-2\\}$ 以及 $k_0 \\in \\{0,\\dots,N_z-2\\}$。定义由单元中心构成的分段内的局部小数坐标为 $s_x = x_0/h_x - (i_0 + 0.5)$、$s_y = y_0/h_y - (j_0 + 0.5)$、$s_z = z_0/h_z - (k_0 + 0.5)$，每个坐标都在 $[0,1)$ 区间内。对于 $a,b,c \\in \\{0,1\\}$ 的八个单元 $(i_0 + a, j_0 + b, k_0 + c)$ 的权重为 $w_{a,b,c} = \\left(a s_x + (1-a)(1 - s_x)\\right) \\left(b s_y + (1-b)(1 - s_y)\\right) \\left(c s_z + (1-c)(1 - s_z)\\right)$，权重经归一化以使 $\\sum_{a,b,c} w_{a,b,c} = 1$，且这八个单元的分配电荷为 $Q^{\\mathrm{CIC}}_{i_0+a,j_0+b,k_0+c} = q \\, w_{a,b,c}$，其他单元为零。\n\n每个单元的离散高斯定律误差：对于每种分配方案 $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$，将每个单元的误差定义为基于近似通量计算出的包围电荷与分配的电荷之间的差值，\n$$\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0。$$\n在 $\\varepsilon_0 = 1$ 和 $q = 1$ 的归一化单位中，这简化为 $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$。为每种分配方案计算所有单元上误差的全局 $L^2$ 范数和最大范数，公式如下\n$$\\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} \\left(\\mathcal{E}^{\\mathcal{D}}_{i,j,k}\\right)^2}, \\quad \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} \\left| \\mathcal{E}^{\\mathcal{D}}_{i,j,k} \\right|.$$\n\n实现细节：\n- 使用连续库仑场 $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0)\\right) q (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$，其中 $\\varepsilon_0 = 1$ 且 $q = 1$，因此 $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi)\\right) (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$。\n- 如上所述，在每个面中心使用中点法则近似通量。\n- 确保点电荷位置避免与任何面中心精确重合，以防止奇异求值。在所有给定的测试用例中，位置都已相应选择。\n\n测试套件：\n为以下每个测试用例，计算最近单元分配和单元云分配的 $(L^2, \\text{max})$ 误差范数。所有位置和长度都以米为单位，但请记住 $\\varepsilon_0 = 1$ 且 $q = 1$，因此输出是无量纲的浮点数。\n1. 情况1：$N_x = 24$, $N_y = 22$, $N_z = 20$, $L_x = 1.2$, $L_y = 1.2$, $L_z = 1.2$，点电荷位于 $(x_0, y_0, z_0) = (0.53, 0.47, 0.41)$。\n2. 情况2：$N_x = 12$, $N_y = 10$, $N_z = 8$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$，点电荷位于 $(x_0, y_0, z_0) = (0.05, 0.92, 0.13)$。\n3. 情况3：$N_x = 18$, $N_y = 18$, $N_z = 18$, $L_x = 0.9$, $L_y = 0.9$, $L_z = 0.9$，点电荷位于 $(x_0, y_0, z_0) = (0.275, 0.225, 0.275)$。\n4. 情况4：$N_x = 6$, $N_y = 6$, $N_z = 6$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$，点电荷位于 $(x_0, y_0, z_0) = (0.37, 0.58, 0.41)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个用例，按以下顺序附加四个值：最近单元分配的 $L^2$ 误差，最近单元分配的最大误差，单元云分配的 $L^2$ 误差，单元云分配的最大误差。将这四个用例的四元组连接起来，形成一个扁平列表。例如，输出格式必须完全是\n$$[\\text{case1\\_L2\\_NGP},\\text{case1\\_Max\\_NGP},\\text{case1\\_L2\\_CIC},\\text{case1\\_Max\\_CIC},\\text{case2\\_L2\\_NGP},\\dots,\\text{case4\\_Max\\_CIC}]。$$", "solution": "该问题要求通过评估离散形式高斯定律中的误差，对计算电磁学中两种常见的电荷分配方案进行定量比较，即最近单元分配（Nearest-Cell Deposition，也称最近网格点法, NGP）和单元云（Cloud-in-Cell, CIC）。\n\n此分析的基础是积分形式的高斯定律，该定律指出通过闭合曲面 $\\partial V$ 的净电通量 $\\Phi$ 与体积 $V$ 内包围的总电荷 $Q_{\\mathrm{enc}}$ 成正比：\n$$ \\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = \\frac{Q_{\\mathrm{enc}}}{\\varepsilon_0} $$\n对于此问题，我们在真空中给定一个位于位置 $\\mathbf{r}_0$ 的点电荷 $q$。其电场由库仑定律给出：\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{q}{4 \\pi \\varepsilon_0} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\n使用指定的归一化条件 $q=1$ 和 $\\varepsilon_0=1$，公式简化为：\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{1}{4 \\pi} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\n核心思想是为笛卡尔网格中的每个单元计算两种不同版本的包围电荷：\n1.  “基于通量”的电荷，$Q_{\\mathrm{flux}}$，通过对单元边界上的通量积分 $\\Phi_{i,j,k}$ 进行数值近似并应用高斯定律得出：$Q_{\\mathrm{flux}, i,j,k} = \\varepsilon_0 \\Phi_{i,j,k}$。\n2.  “分配的”电荷，$Q^{\\mathcal{D}}_{i,j,k}$，通过应用电荷分配方案 $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$ 获得。\n\n这两个量之间的差异，$\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0$，代表了满足高斯定律的局部误差。根据我们的归一化条件，这简化为 $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$。然后我们使用 $L^2$ 范数和最大范数量化全局误差。\n\n对于每个测试用例，算法按以下步骤进行：\n\n1.  **网格和参数初始化**：对于给定大小为 $L_x \\times L_y \\times L_z$ 的域和 $N_x \\times N_y \\times N_z$ 个单元的网格，我们计算单元间距 $h_x = L_x/N_x$，$h_y = L_y/N_y$ 和 $h_z = L_z/N_z$。点电荷 $q=1$ 位于 $\\mathbf{r}_0 = (x_0, y_0, z_0)$。\n\n2.  **电荷分配**：我们计算两种方案下分配到每个单元 $(i,j,k)$ 的电荷。\n    *   **NGP 方案**：我们找到包含 $\\mathbf{r}_0$ 的单元索引 $(i^\\ast, j^\\ast, k^\\ast)$，其中 $i^\\ast = \\lfloor x_0/h_x \\rfloor$，$j^\\ast = \\lfloor y_0/h_y \\rfloor$，$k^\\ast = \\lfloor z_0/h_z \\rfloor$。全部电荷 $q=1$ 被分配给这个单元。所有其他单元接收到的电荷为零。这样就创建了一个 $N_x \\times N_y \\times N_z$ 的数组 $Q^{\\mathrm{NGP}}$。\n    *   **CIC 方案**：此方案将电荷分配到其中心包围粒子位置的 8 个单元中。我们首先找到这个 $2 \\times 2 \\times 2$ 块的基准索引：$i_0 = \\lfloor x_0/h_x - 0.5 \\rfloor$，$j_0 = \\lfloor y_0/h_y - 0.5 \\rfloor$，$k_0 = \\lfloor z_0/h_z - 0.5 \\rfloor$，并确保这些索引被钳位以使该块保持在网格边界内。然后，我们计算粒子与基准单元中心的相对小数距离：$s_x = x_0/h_x - (i_0 + 0.5)$，$s_y = y_0/h_y - (j_0 + 0.5)$ 和 $s_z = z_0/h_z - (k_0 + 0.5)$。使用三线性插值权重将电荷分配给 8 个单元 $(i_0+a, j_0+b, k_0+c)$（其中 $a,b,c \\in \\{0,1\\}$）。这样就创建了一个电荷数组 $Q^{\\mathrm{CIC}}$。\n\n3.  **数值通量计算**：我们计算通过每个单元边界的电通量。问题指定了中点法则近似。对于每个单元 $(i,j,k)$，净通量 $\\Phi_{i,j,k}$ 是通过其六个面的通量之和。\n    $$ \\Phi_{i,j,k} \\approx \\sum_{\\text{faces } f} \\mathbf{E}(\\mathbf{r}_f) \\cdot \\mathbf{n}_f A_f $$\n    其中 $\\mathbf{r}_f$ 是一个面的中心，$\\mathbf{n}_f$ 是其向外的法向量，$A_f$ 是其面积。例如，对于‘右’面（$x$ 恒定，最大值），$\\mathbf{r}_f = ((i+1)h_x, (j+0.5)h_y, (k+0.5)h_z)$，$\\mathbf{n}_f = (1,0,0)$，并且 $A_f = h_y h_z$。\n    为了高效地实现这一点，我们利用了向量化。我们生成代表所有单元索引 $(i,j,k)$ 坐标的 3D 数组。基于这些，我们计算所有六种类型面（例如，所有‘左’面、所有‘右’面等）中心的坐标数组。然后，我们在这六个面心网格上计算电场矢量分量。与各自法线的点积再乘以面面积，得到六个部分通量的 3D 数组。将这六个数组相加，得到最终的 3D 数组 $\\Phi$，其中 $\\Phi_{i,j,k}$ 是流出单元 $(i,j,k)$ 的总近似通量。\n\n4.  **误差计算与范数**：利用通量数组 $\\Phi$ 和电荷数组 $Q^{\\mathrm{NGP}}$ 与 $Q^{\\mathrm{CIC}}$，我们计算每种方案的误差数组：\n    $$ \\mathcal{E}^{\\mathrm{NGP}} = \\Phi - Q^{\\mathrm{NGP}} $$\n    $$ \\mathcal{E}^{\\mathrm{CIC}} = \\Phi - Q^{\\mathrm{CIC}} $$\n    最后，我们为每个误差数组计算 $L^2$ 范数和最大 ($L^\\infty$) 范数：\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i,j,k} (\\mathcal{E}^{\\mathcal{D}}_{i,j,k})^2} $$\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} |\\mathcal{E}^{\\mathcal{D}}_{i,j,k}| $$\n    为每个测试用例计算这四个标量值（两种方案，两种范数），并附加到最终结果列表中。对问题陈述中提供的所有用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (Nx, Ny, Nz, Lx, Ly, Lz, (x0, y0, z0))\n        (24, 22, 20, 1.2, 1.2, 1.2, (0.53, 0.47, 0.41)),\n        (12, 10, 8, 1.0, 1.0, 1.0, (0.05, 0.92, 0.13)),\n        (18, 18, 18, 0.9, 0.9, 0.9, (0.275, 0.225, 0.275)),\n        (6, 6, 6, 1.0, 1.0, 1.0, (0.37, 0.58, 0.41)),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = calculate_errors_for_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_errors_for_case(case_params):\n    \"\"\"\n    Calculates the L2 and max errors for NGP and CIC schemes for a single test case.\n    \"\"\"\n    Nx, Ny, Nz, Lx, Ly, Lz, r0 = case_params\n    r0 = np.array(r0)\n    q = 1.0\n    eps0 = 1.0\n\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n    h = np.array([hx, hy, hz])\n    Ax, Ay, Az = hy * hz, hx * hz, hx * hy\n\n    # --- Charge Deposition ---\n\n    # NGP (Nearest-Cell Deposition)\n    Q_ngp = np.zeros((Nx, Ny, Nz))\n    i_star = int(np.floor(r0[0] / hx))\n    j_star = int(np.floor(r0[1] / hy))\n    k_star = int(np.floor(r0[2] / hz))\n    if 0 = i_star  Nx and 0 = j_star  Ny and 0 = k_star  Nz:\n        Q_ngp[i_star, j_star, k_star] = q\n\n    # CIC (Cloud-in-Cell)\n    Q_cic = np.zeros((Nx, Ny, Nz))\n    # Base cell index for the 2x2x2 cloud\n    i0 = int(np.floor(r0[0] / hx - 0.5))\n    j0 = int(np.floor(r0[1] / hy - 0.5))\n    k0 = int(np.floor(r0[2] / hz - 0.5))\n\n    # Clamp indices to ensure the 2x2x2 stencil is within the grid\n    i0 = np.clip(i0, 0, Nx - 2)\n    j0 = np.clip(j0, 0, Ny - 2)\n    k0 = np.clip(k0, 0, Nz - 2)\n\n    # Fractional coordinates relative to the base cell center\n    sx = r0[0] / hx - (i0 + 0.5)\n    sy = r0[1] / hy - (j0 + 0.5)\n    sz = r0[2] / hz - (k0 + 0.5)\n\n    # Trilinear weights\n    wx = [1 - sx, sx]\n    wy = [1 - sy, sy]\n    wz = [1 - sz, sz]\n\n    for a in range(2):\n        for b in range(2):\n            for c in range(2):\n                weight = wx[a] * wy[b] * wz[c]\n                Q_cic[i0 + a, j0 + b, k0 + c] = q * weight\n    \n    # --- Electric Field and Flux Calculation ---\n    \n    i_idx, j_idx, k_idx = np.indices((Nx, Ny, Nz))\n\n    def get_E_field(pos_x, pos_y, pos_z):\n        \"\"\"Vectorized E-field calculation.\"\"\"\n        rx = pos_x - r0[0]\n        ry = pos_y - r0[1]\n        rz = pos_z - r0[2]\n        dist_sq = rx**2 + ry**2 + rz**2\n        # Add a small epsilon to avoid division by zero if r coincides with r0.\n        # Problem statement guarantees no coincidence with face centers.\n        dist_cubed = dist_sq * np.sqrt(dist_sq) \n        factor = (q / (4 * np.pi * eps0)) / dist_cubed\n        return factor * rx, factor * ry, factor * rz\n\n    flux_total = np.zeros((Nx, Ny, Nz))\n\n    # Faces at x = constant\n    x_left = i_idx * hx\n    x_right = (i_idx + 1) * hx\n    y_x_face = (j_idx + 0.5) * hy\n    z_x_face = (k_idx + 0.5) * hz\n    Ex_left, _, _ = get_E_field(x_left, y_x_face, z_x_face)\n    Ex_right, _, _ = get_E_field(x_right, y_x_face, z_x_face)\n    flux_total += (Ex_right * 1.0 + Ex_left * -1.0) * Ax\n\n    # Faces at y = constant\n    y_bottom = j_idx * hy\n    y_top = (j_idx + 1) * hy\n    x_y_face = (i_idx + 0.5) * hx\n    z_y_face = (k_idx + 0.5) * hz\n    _, Ey_bottom, _ = get_E_field(x_y_face, y_bottom, z_y_face)\n    _, Ey_top, _ = get_E_field(x_y_face, y_top, z_y_face)\n    flux_total += (Ey_top * 1.0 + Ey_bottom * -1.0) * Ay\n\n    # Faces at z = constant\n    z_back = k_idx * hz\n    z_front = (k_idx + 1) * hz\n    x_z_face = (i_idx + 0.5) * hx\n    y_z_face = (j_idx + 0.5) * hy\n    _, _, Ez_back = get_E_field(x_z_face, y_z_face, z_back)\n    _, _, Ez_front = get_E_field(x_z_face, y_z_face, z_front)\n    flux_total += (Ez_front * 1.0 + Ez_back * -1.0) * Az\n\n    # --- Error Calculation ---\n    \n    # Error = Flux - Q_enclosed (with eps0=1)\n    error_ngp = flux_total - Q_ngp\n    error_cic = flux_total - Q_cic\n\n    # L2 and Max Norms\n    l2_ngp = np.sqrt(np.sum(error_ngp**2))\n    max_ngp = np.max(np.abs(error_ngp))\n    l2_cic = np.sqrt(np.sum(error_cic**2))\n    max_cic = np.max(np.abs(error_cic))\n    \n    return [l2_ngp, max_ngp, l2_cic, max_cic]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3310354"}, {"introduction": "从网格场到粒子力的插值是PIC循环的关键一步，一个设计良好的方案应避免粒子产生作用于自身的虚假“自作用力”。本练习将带你探究这一重要的数值现象，通过对比交错网格(Yee)和同位网格(collocated)上的力计算，你将揭示为何交错网格布局能够巧妙地消除这种非物理效应[@problem_id:3338067]。这个实践是理解现代PIC代码设计中动量守恒和数值稳定性的核心。", "problem": "考虑一个基于均匀网格的一维周期性静电质点网格（PIC）模型。目标是通过量化一个静止于网格中心处的单个粒子所受的虚假自作用力，来比较电场的交错网格存储（Yee 排列）与同位网格存储。这种比较必须在科学上一致的离散假设下，通过计算仅由粒子自身沉积的电荷、数值场求解和收集过程所产生的净自作用力 $\\mathbf{F}_{\\text{self}}$（单位为牛顿）来执行。\n\n基础和离散模型。从微分形式的高斯定律 $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$ 和静电势定义 $\\mathbf{E} = -\\nabla \\phi$ 出发，其中 $\\varepsilon_0$ 是真空介电常数。在一个长度为 $L$ 的一维周期性边界条件域中，假设电荷密度 $\\rho(x)$ 的空间平均值为零，从而保证离散泊松方程是可解的。使用一个包含 $N$ 个网格的均匀网格，网格尺寸为 $\\Delta x = L/N$，网格中心位于 $x_i = (i + \\tfrac{1}{2}) \\Delta x$（其中整数 $i \\in \\{0,1,\\dots,N-1\\}$）。将静电势 $\\phi$ 存储在网格中心。引入一个电荷为 $q$ 的静止单个粒子，其精确位于索引为 $i_0$ 的网格中心，并通过一个密度为 $-q/L$ 的均匀背景来中和其净电荷，使得离散电荷密度为\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L},\n$$\n其中 $\\delta_{i,i_0}$ 是克罗内克 δ。使用网格云（CIC）沉积和收集方法，在这种特殊配置下，对于定义在网格中心的操作，其权重在 $i_0$ 处为 1，在其他地方为 0；对于定义在网格面上的操作，其权重为相邻两面各占一半。\n\n定义并比较两种场存储和离散算子配置：\n\n1. 交错网格（Yee 排列）：将电场分量 $E_x$ 存储在位置为 $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$ 的网格面上，而将 $\\rho$ 和 $\\phi$ 存储在网格中心 $x_i$。通过在傅里叶空间中求解周期性离散泊松方程来计算中心的 $\\phi$，\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0},\n$$\n其中离散拉普拉斯算子的特征值为 $\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)$，对应模态指数 $m$。零模设置为零，即 $\\phi_{k=0} = 0$，以确保势为零均值。通过离散梯度 $E_{x,i+\\tfrac{1}{2}} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$ 计算面心电场，并通过对相邻面进行对称 CIC 平均，将其收集到位于网格 $i_0$ 中心的粒子上：\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right).\n$$\n\n2. 同位网格：将 $E_x$ 与 $\\rho$ 和 $\\phi$ 一同存储在网格中心。通过与上述相同的离散泊松方程计算中心的 $\\phi$。然后使用前向差分离散梯度 $E_{x,i} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$ 计算网格中心的 $E_x$。使用中心的 CIC 权重将场收集到粒子上，这简化为在粒子所在的网格中心进行求值：\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0}.\n$$\n\n在两种配置中，计算自作用力\n$$\n\\mathbf{F}_{\\text{self}} = q\\, E_{p} \\,\\hat{\\mathbf{x}},\n$$\n并报告标量值 $F_{\\text{self}} = q E_p$（单位为牛顿）。粒子是静止的，因此没有磁力贡献。\n\n您的任务。实现一个完整、可运行的程序，该程序：\n- 根据指定的参数构建离散电荷密度 $\\rho_i$。\n- 使用上面给出的离散拉普拉斯算子特征值，在傅里叶空间中求解一维周期性离散泊松方程以得到 $\\phi_i$，并设 $\\phi_{k=0}=0$。\n- 按照定义为交错网格和同位网格两种配置计算 $E_x$，使用 CIC 规则将各自的场收集到粒子位置，并为每种配置计算 $F_{\\text{self}}$。\n- 为指定的测试套件生成数值结果。\n\n单位与输出。所有力均以牛顿表示。角度不适用。最终程序输出必须是单行文本，包含一个逗号分隔的各测试用例结果列表，其中每个结果是该用例的 $[F_{\\text{self}}^{\\text{Yee}}, F_{\\text{self}}^{\\text{Coll}}]$ 对。例如：“[val1,val2,val3]”，其中每个“valk”本身就是一个写为“[F_Yee,F_Coll]”的列表。\n\n测试套件。使用以下测试用例，每个用例由 $(N, L, q, \\varepsilon_0)$ 指定：\n- A 用例（正常路径）：$N = 64$，$L = 1.0$ 米，$q = 1.0 \\times 10^{-9}$ 库仑，$\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ 法拉/米。\n- B 用例（粗分辨率边界）：$N = 8$，$L = 1.0$ 米，$q = 1.0 \\times 10^{-9}$ 库仑，$\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ 法拉/米。\n- C 用例（符号边缘情况）：$N = 64$，$L = 1.0$ 米，$q = -1.0 \\times 10^{-9}$ 库仑，$\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ 法拉/米。\n- D 用例（更大域，更细网格）：$N = 256$，$L = 2.0$ 米，$q = 5.0 \\times 10^{-10}$ 库仑，$\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ 法拉/米。\n\n实现约束。程序必须是自包含的，无需任何输入，并严格使用最终答案中指定的运行时环境。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表中的每个元素本身也是一个包含两个元素的列表，格式为：“[[F_A_Yee,F_A_Coll],[F_B_Yee,F_B_Coll],[F_C_Yee,F_C_Coll],[F_D_Yee,F_D_Coll]]”。", "solution": "问题陈述已经过严格验证，并被认定为有效。它在科学上是合理的、自包含的、适定的，并描述了计算等离子体物理中用于分析质点网格（PIC）方法中虚假自作用力的一个标准数值实验。所有必需的参数、方程和离散算子都得到了明确的定义。\n\n解决方案通过实现指定的数值算法来展开。我们将为一个静止在网格单元中心的单个粒子，计算两种不同数值方案下的虚假自作用力：一种是交错网格（Yee）方案，另一种是同位网格方案。\n\n**1. 模型离散化与设置**\n\n对于每个测试用例，我们都给定了网格单元数 $N$、域长度 $L$、粒子电荷 $q$ 和真空介电常数 $\\varepsilon_0$。\n网格单元尺寸为 $\\Delta x = L/N$。该域包含 $N$ 个单元，其中心位于 $x_i = (i + \\tfrac{1}{2})\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n一个电荷为 $q$ 的单个粒子被放置在单元 $i_0$ 的中心。由于域的周期性， $i_0$ 的选择是任意的；为方便起见，我们选择 $i_0 = N/2$。对于位于单元中心的粒子，网格云（CIC）电荷沉积方案简化为将全部电荷沉积到该单元中。为确保周期性泊松方程的可解性，添加了密度为 $-q/L$ 的中和背景电荷。因此，每个单元中心 $i$ 处的离散电荷密度为：\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L}\n$$\n其中 $\\delta_{i,i_0}$ 是克罗内克 δ。这个公式正确地确保了域中的总电荷为零：$\\sum_{i=0}^{N-1} \\rho_i \\Delta x = 0$。\n\n**2. 求解离散泊松方程**\n\n静电势 $\\phi$ 存储在单元中心 $x_i$ 处，并通过离散泊松方程与电荷密度 $\\rho_i$ 相关联：\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0}\n$$\n其中 $-\\Delta_d$ 是离散负拉普拉斯算子。按照规定，我们在傅里叶空间中求解此方程。设 $\\tilde{\\phi}_m$ 和 $\\tilde{\\rho}_m$ 分别是 $\\phi_i$ 和 $\\rho_i$ 的离散傅里叶变换（DFT）。方程变换为：\n$$\n\\lambda_m \\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0}\n$$\n其中 $\\lambda_m$ 是 $-\\Delta_d$ 算子的特征值，由下式给出：\n$$\n\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right) \\quad \\text{for mode index } m \\in \\{0, 1, \\dots, N-1\\}\n$$\n对于直流分量 $m=0$，我们有 $\\lambda_0 = 0$。零均值电荷密度确保了 $\\tilde{\\rho}_0 = \\sum_i \\rho_i = 0$，使得 $m=0$ 的方程变为 $0 \\cdot \\tilde{\\phi}_0 = 0$。问题规定将平均势设置为零，这等同于 $\\tilde{\\phi}_0 = 0$。对于所有其他模式（$m > 0$），我们可以求解 $\\tilde{\\phi}_m$：\n$$\n\\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0 \\lambda_m}\n$$\n求解势 $\\phi_i$ 的算法如下：\n1. 构建实空间电荷密度数组 $\\rho_i$。\n2. 使用快速傅里叶变换（FFT）算法计算其离散傅里叶变换 $\\tilde{\\rho}_m$。\n3. 计算特征值 $\\lambda_m$。\n4. 使用上述公式构建傅里叶空间中的势 $\\tilde{\\phi}_m$，并设置 $\\tilde{\\phi}_0 = 0$。\n5. 计算 $\\tilde{\\phi}_m$ 的逆离散傅里叶变换以获得 $\\phi_i$。由于初始的 $\\rho_i$ 是实数且表现出对称性，因此得到的 $\\phi_i$ 也将是实数（在数值精度误差范围内）。\n\n**3. 自作用力计算：交错网格（Yee）方案**\n\n在 Yee 方案中，电场 $E_x$ 与势 $\\phi$ 交错存储，即存储在位置为 $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$ 的单元面上。离散梯度是一个中心差分：\n$$\nE_{x,i+\\tfrac{1}{2}} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\n粒子位于 $x_{i_0}$。粒子位置处的电场 $E_{p}^{\\text{Yee}}$ 是使用 CIC 权重收集得到的。对于位于单元中心的粒子，这意味着对来自两个相邻面的场进行平均：\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right) = \\frac{1}{2}\\left( -\\frac{\\phi_{i_0} - \\phi_{i_0-1}}{\\Delta x} - \\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x} \\right) = -\\frac{\\phi_{i_0+1} - \\phi_{i_0-1}}{2\\Delta x}\n$$\n由于问题设置的对称性（周期域中的单个点电荷），所得到的势 $\\phi_i$ 必须关于粒子位置 $i_0$ 对称。即，对于任何整数 $k$，都有 $\\phi_{i_0+k} = \\phi_{i_0-k}$。特别地，$\\phi_{i_0+1} = \\phi_{i_0-1}$。因此，收集到的电场 $E_{p}^{\\text{Yee}}$ 在解析上为零。\n自作用力为 $F_{\\text{self}}^{\\text{Yee}} = q E_{p}^{\\text{Yee}} = 0$。任何非零结果都将归因于浮点表示误差，并且应该是可以忽略不计的。\n\n**4. 自作用力计算：同位网格方案**\n\n在同位方案中，电场 $E_x$ 与 $\\phi$ 和 $\\rho$ 一样，存储在相同的单元中心位置 $x_i$。势 $\\phi_i$ 的计算方式与之前相同。离散梯度被指定为前向差分：\n$$\nE_{x,i} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\n场被收集到粒子所在的位置 $i_0$。对于位于单元中心的粒子，CIC 收集简化为直接求值：\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0} = -\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\n如前所述，势 $\\phi_i$ 在 $i_0$ 处有一个对称的极值（当 $q>0$ 时为峰值，当 $q0$ 时为谷值）。因此，$\\phi_{i_0+1} \\neq \\phi_{i_0}$，并且场 $E_{p}^{\\text{Coll}}$ 将不为零。这个非零场是由前向差分算子的不对称性引起的。由此产生的自作用力是：\n$$\nF_{\\text{self}}^{\\text{Coll}} = q E_{p}^{\\text{Coll}} = -q\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\n解析计算表明，该力的大小为 $F_{\\text{self}}^{\\text{Coll}} = \\frac{q^2(N-1)}{2N\\varepsilon_0}$。这个力始终是正的（沿 $+\\hat{\\mathbf{x}}$ 方向），并且当 $N \\to \\infty$ 时，它会趋近于一个常数值 $q^2/(2\\varepsilon_0)$。这证实了带有前向差分梯度的同位网格方案会产生一个显著且系统性的虚假自作用力。\n\n下面的程序为所提供的测试套件实现了这些计算。", "answer": "```python\nimport numpy as np\n\ndef calculate_forces(N, L, q, epsilon_0):\n    \"\"\"\n    Calculates the spurious self-force for staggered and collocated schemes.\n\n    Args:\n        N (int): Number of grid cells.\n        L (float): Length of the 1D periodic domain.\n        q (float): Charge of the particle.\n        epsilon_0 (float): Vacuum permittivity.\n\n    Returns:\n        list: A two-element list containing [F_self_Yee, F_self_Coll].\n    \"\"\"\n    # 1. Setup Grid and Charge Density\n    dx = L / N\n    # Place particle at the center of cell i0 for symmetry\n    i0 = N // 2\n    \n    # Create the discrete charge density array rho_i\n    # rho_i = (q / dx) * delta_{i,i0} - q / L\n    rho = np.full(N, -q / L)\n    rho[i0] += q / dx\n\n    # 2. Solve Poisson's Equation for phi\n    # FFT of the charge density\n    rho_tilde = np.fft.fft(rho)\n\n    # Eigenvalues of the discrete negative Laplacian\n    m = np.arange(N)\n    # The m=0 eigenvalue is 0. Avoid division by zero.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        lambda_m = (4.0 / dx**2) * np.sin(np.pi * m / N)**2\n\n    # Solve for phi_tilde in Fourier space: phi_tilde = rho_tilde / (epsilon_0 * lambda)\n    phi_tilde = np.zeros(N, dtype=complex)\n    # For m > 0 (lambda_m != 0)\n    phi_tilde[1:] = rho_tilde[1:] / (epsilon_0 * lambda_m[1:])\n    # For m = 0, phi_tilde[0] is 0 as specified (zero mean potential).\n\n    # Inverse FFT to get phi in real space\n    phi = np.fft.ifft(phi_tilde)\n    phi = np.real(phi) # Potential should be real, discard negligible imag part\n\n    # 3. Calculate Staggered-Grid (Yee) Force\n    # E_p^Yee = - (phi_{i0+1} - phi_{i0-1}) / (2 * dx)\n    # Handle periodic boundary conditions for indices\n    i_prev = (i0 - 1 + N) % N\n    i_next = (i0 + 1) % N\n    \n    phi_prev = phi[i_prev]\n    phi_next = phi[i_next]\n\n    E_p_Yee = - (phi_next - phi_prev) / (2.0 * dx)\n    F_self_Yee = q * E_p_Yee\n\n    # 4. Calculate Collocated-Grid Force\n    # E_p^Coll = - (phi_{i0+1} - phi_{i0}) / (dx)\n    phi_i0 = phi[i0]\n    \n    E_p_Coll = - (phi_next - phi_i0) / dx\n    F_self_Coll = q * E_p_Coll\n\n    return [F_self_Yee, F_self_Coll]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test suite: (N, L, q, epsilon_0)\n    test_cases = [\n        # Case A: happy path\n        (64, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case B: coarse resolution boundary\n        (8, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case C: sign edge case\n        (64, 1.0, -1.0e-9, 8.8541878128e-12),\n        # Case D: larger domain, finer grid\n        (256, 2.0, 5.0e-10, 8.8541878128e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, q, epsilon_0 = case\n        forces = calculate_forces(N, L, q, epsilon_0)\n        results.append(forces)\n\n    # Format the output string exactly as required, removing spaces\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3338067"}, {"introduction": "PIC模拟中的场求解器是连接所有粒子的核心，但离散化的网格会引入误差，使得粒子间的相互作用依赖于其相对于网格轴的方向，即“各向异性”。本练习引入了离散格林函数的概念，它是一个强大的诊断工具，用于全面评估从电荷分配到场求解再到力插值整个过程的特性[@problem_id:2424113]。通过数值计算并分析这个函数，你将能直观地量化PIC模拟中固有的网格各向异性，并理解其对模拟结果真实性的影响。", "problem": "您的任务是开发一个完整、可运行的程序，该程序为在具有周期性边界条件的均匀笛卡尔网格上的三维静电粒子模拟 (PIC) 求解器构建并分析离散格林函数。您的 PIC 求解器使用拉普拉斯算子的二阶中心差分离散，并在傅里叶空间中求解泊松方程。\n\n从基本原理开始：麦克斯韦方程组的静电极限导出泊松方程 $\\nabla^2 \\phi(\\mathbf{x}) = -\\rho(\\mathbf{x})/\\varepsilon_0$。在间距为 $h$ 且具有周期性边界条件的均匀网格上，二阶离散拉普拉斯算子近似于 $\\nabla^2$。离散格林函数 $G_d(\\mathbf{r})$ 定义为，由指定的离散求解器和网格计算出的、位于原点的单位点电荷在网格点上产生的电势响应。在粒子模拟 (PIC) 方法中，由粒子到网格的分配和场到粒子的插值所隐含的有限粒子尺寸，会通过所选形函数的傅里叶变换的平方来修正波数空间中的有效源和测量。\n\n在您的程序中实现以下内容：\n\n1) 对于一个大小为 $N \\times N \\times N$ 的均匀周期性网格，结合二阶中心差分拉普拉斯算子和泊松方程的谱方法（离散傅里叶变换）反演，构建三维离散格林函数。通过将波数零模设置为零来强制执行零均值条件，以便在周期性边界条件下唯一地定义电势。\n\n2) 包含粒子形状的影响。使用阶数为 $m$ 的一维B样条形函数，其傅里叶变换为 $S_m(k) = \\left[\\operatorname{sinc}\\!\\left(\\frac{k h}{2}\\right)\\right]^{m+1}$，其中 $\\operatorname{sinc}(x) = \\frac{\\sin x}{x}$。假设粒子到网格的沉积和网格到粒子的插值使用相同的形函数，因此有效谱响应乘以 $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$。对于最近网格点 (NGP) 使用 $m=0$，对于云中粒子 (CIC) 使用 $m=1$。\n\n3) 在无量纲晶格单位下工作，以便与连续格林函数进行比较。令 $\\hat{\\mathbf{r}} = \\mathbf{r}/h$ 为晶格坐标。通过有效谱格林函数的离散傅里叶逆变换来定义无量纲离散格林函数 $\\hat{G}_d(\\hat{\\mathbf{r}})$。将 $\\hat{G}_d(\\hat{\\mathbf{r}})$ 与连续表达式 $\\hat{G}_c(\\hat{r}) = \\frac{1}{4\\pi \\hat{r}}$ 进行比较（经过适当缩放后，这对应于物理上的 $1/(4\\pi r)$）。您报告的所有度量必须是无量纲的。\n\n4) 分析各向异性以及与连续解的偏差：\n   - 将网格点按整数平方距离 $s = i^2 + j^2 + k^2$ 分组到球壳中，其中 $(i,j,k)$ 是与源点的最短周期位移。对于每个半径为 $\\hat{r} = \\sqrt{s}$ 的球壳，计算：\n     a) 该球壳上 $\\hat{G}_d$ 值的球壳均值 $\\overline{G}_s$ 和球壳标准差 $\\sigma_s$。\n     b) 球壳各向异性，为 $\\sigma_s / \\overline{G}_s$。\n     c) 球壳相对误差 $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$。\n   - 仅考虑 $\\hat{r}_{\\min}  \\hat{r}  \\hat{r}_{\\max}$ 范围内的球壳，以避免原点的奇异单元并减少周期性镜像的影响。使用 $\\hat{r}_{\\min} = 1.5$ 和 $\\hat{r}_{\\max} = N/4$。\n   - 为每种情况报告两个全局度量：最大球壳各向异性和球壳相对误差的均方根 $\\sqrt{\\langle \\delta_s^2 \\rangle}$，在所考虑的球壳上进行均匀平均。这两个度量都是无量纲的。\n\n5) 使用以下参数集测试套件来检验您的实现：\n   - 情况1 (常规路径): $N = 32$, $h = 1.0$, shape = NGP。\n   - 情况2 (形函数效应): $N = 32$, $h = 1.0$, shape = CIC。\n   - 情况3 (分辨率/间距变化): $N = 48$, $h = 0.5$, shape = CIC。\n\n您的程序必须对所有情况执行计算，并打印单行，其中包含一个包含六个浮点数的扁平列表：按顺序为每种情况打印最大球壳各向异性，后跟均方根相对误差。要求的最终输出格式为单行：\n\"[a1,e1,a2,e2,a3,e3]\"\n其中每个数字都四舍五入到小数点后恰好六位。例如，一个语法正确的输出可能看起来像 \"[0.123456,0.012345,0.234567,0.023456,0.345678,0.034567]\"。报告的量是无量纲的，因此输出中不需要也不允许出现物理单位。", "solution": "该问题要求为周期性笛卡尔网格上的三维静电粒子模拟 (PIC) 求解器构建并分析离散格林函数。分析将重点量化由网格、有限差分算子和粒子形函数引入的各向异性以及与连续解的偏差。\n\n基本方程是给定电荷密度 $\\rho(\\mathbf{x})$ 下静电势 $\\phi(\\mathbf{x})$ 的泊松方程：\n$$ \\nabla^2 \\phi(\\mathbf{x}) = -\\frac{\\rho(\\mathbf{x})}{\\varepsilon_0} $$\n我们考虑一个大小为 $N \\times N \\times N$、网格间距为 $h$ 的均匀笛卡尔网格。网格上的位置由 $\\mathbf{r}_{\\mathbf{j}} = (j_x h, j_y h, j_z h)$ 表示，其中 $\\mathbf{j} = (j_x, j_y, j_z)$ 是整数索引的三元组。电势和电荷密度在该网格上离散化为 $\\phi_{\\mathbf{j}} = \\phi(\\mathbf{r}_{\\mathbf{j}})$ 和 $\\rho_{\\mathbf{j}} = \\rho(\\mathbf{r}_{\\mathbf{j}})$。\n\n拉普拉斯算子 $\\nabla^2$ 使用二阶精度的中心差分格式来近似。在三维中，作用于网格点 $\\mathbf{j}$ 处电势的离散算子 $D^2$ 为：\n$$ (D^2 \\phi)_{\\mathbf{j}} = \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_x} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_x}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_y} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_y}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_z} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_z}}{h^2} $$\n其中 $\\mathbf{e}_x, \\mathbf{e}_y, \\mathbf{e}_z$ 是沿网格轴的单位向量。\n由此，离散泊松方程为 $(D^2 \\phi)_{\\mathbf{j}} = -\\rho_{\\mathbf{j}}/\\varepsilon_0$。\n\n由于周期性边界条件，该系统可以在傅里叶空间中高效求解。网格量 $f_{\\mathbf{j}}$ 的离散傅里叶变换 (DFT) 是 $\\tilde{f}_{\\mathbf{n}} = \\sum_{\\mathbf{j}} f_{\\mathbf{j}} e^{-i \\mathbf{k}_{\\mathbf{n}} \\cdot \\mathbf{r}_{\\mathbf{j}}}$，其中离散波矢量为 $\\mathbf{k}_{\\mathbf{n}} = (2\\pi n_x/(Nh), 2\\pi n_y/(Nh), 2\\pi n_z/(Nh))$，对于整数模索引 $\\mathbf{n}=(n_x, n_y, n_z)$。DFT 将类卷积的差分算子转换为简单的乘法。离散拉普拉斯算子的傅里叶表示（特征值）是：\n$$ \\hat{D}^2(\\mathbf{k}_{\\mathbf{n}}) = \\sum_{i \\in \\{x,y,z\\}} \\frac{2}{h^2} (\\cos(k_{n_i} h) - 1) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{k_{n_i} h}{2}\\right) $$\n代入 $k_{n_i}$ 的表达式，这变为：\n$$ \\hat{D}^2(\\mathbf{n}) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_i}{N}\\right) $$\n傅里叶空间中的离散泊松方程是 $\\hat{D}^2(\\mathbf{n}) \\tilde{\\phi}_{\\mathbf{n}} = -\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0$。\n\n离散格林函数 $G_d$ 是对放置在原点网格点 $\\mathbf{j}=(0,0,0)$ 的单个单位点电荷 $q=1$ 的电势响应。这对应于离散电荷密度 $\\rho_{\\mathbf{j}} = \\delta_{\\mathbf{j}0} / h^3$，其中 $\\delta_{\\mathbf{j}0}$ 是克罗内克 δ，而 $h^3$ 是单元体积。该源的 DFT 是一个常数，$\\tilde{\\rho}_{\\mathbf{n}} = 1/h^3$。\n\n在 PIC 模拟中，粒子间的相互作用通过粒子形函数被软化，该函数既用于将电荷沉积到网格上，也用于将场插值回粒子。对于沉积函数 $W(\\mathbf{x})$ 和插值函数 $I(\\mathbf{x})$，测试粒子感受到的来自源粒子的有效电势由求解器和这两个滤波器共同调节。在傅里叶空间中，这导致相互作用被因子 $\\tilde{I}^*(\\mathbf{k})\\tilde{W}(\\mathbf{k})$ 修正。问题指出沉积和插值函数是相同的阶数为 $m$ 的 B 样条，$W=I=S_m$，其傅里叶变换为实数。因此，有效相互作用被 $|S_m(\\mathbf{k})|^2$ 修正。问题给出的形式是：\n$$ S_m(k) = \\left[\\operatorname{sinc}\\left(\\frac{kh}{2}\\right)\\right]^{m+1} \\quad \\text{其中 } \\operatorname{sinc}(x) = \\frac{\\sin x}{x} $$\n三维中的总修正因子为 $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$。\n\n结合这些元素，描述粒子-粒子相互作用的有效谱势 $\\tilde{G}_{d, \\text{eff}}$ 是：\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{-\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0}{\\hat{D}^2(\\mathbf{n})} |S_m(\\mathbf{k}_{\\mathbf{n}})|^2 = \\frac{-(1/h^3)/\\varepsilon_0}{-\\frac{4}{h^2} \\sum_i \\sin^2(\\frac{\\pi n_i}{N})} \\prod_j \\left[\\operatorname{sinc}\\left(\\frac{\\pi n_j}{N}\\right)\\right]^{2(m+1)} $$\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{1}{4 \\varepsilon_0 h} \\frac{\\prod_j \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{\\sum_i \\sin^2(\\pi n_i/N)} $$\n我们寻求一个无量纲的格林函数 $\\hat{G}_d$。连续格林函数是 $G_c(r) = 1/(4\\pi\\varepsilon_0 r)$。给出的无量纲比较函数是 $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$，其中 $\\hat{r}=r/h$。这建议进行 $4\\pi\\varepsilon_0 h$ 的归一化并设置 $\\varepsilon_0=1/(4\\pi)$。一个更直接的方法是定义无量纲谱格林函数 $\\hat{\\tilde{G}}_d(\\mathbf{n})$，当变换到实空间时，可以与 $\\hat{G}_c(\\hat{r})$ 进行比较。从 $\\tilde{G}_{d, \\text{eff}}$ 的表达式中，我们可以构建一个独立于 $h$ 和 $\\varepsilon_0$ 的无量纲谱函数：\n$$ \\hat{\\tilde{G}}_d(\\mathbf{n}) = \\frac{\\prod_{j \\in \\{x,y,z\\}} \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{4 \\sum_{i \\in \\{x,y,z\\}} \\sin^2(\\pi n_i/N)} $$\n对于 $\\mathbf{n}=(0,0,0)$ 的模式，其分母为零，代表平均电势。对于具有隐式电荷中性的周期性系统，此模式设置为零，即 $\\hat{\\tilde{G}}_d(\\mathbf{0}) = 0$。\n\n计算过程如下：\n1. 对于给定的网格尺寸 $N$ 和形函数阶数 $m$，为所有模式索引 $\\mathbf{n}$ 构建三维数组 $\\hat{\\tilde{G}}_d(\\mathbf{n})$。\n2. 通过对 $\\hat{\\tilde{G}}_d(\\mathbf{n})$ 执行三维离散傅里叶逆变换，计算实空间无量纲格林函数 $\\hat{G}_d(\\hat{\\mathbf{r}})$。\n3. 为了分析结果，将网格点按距原点的恒定平方距离 $s = i^2+j^2+k^2$ 分组到球壳中，其中 $(i,j,k)$ 是最短的周期位移。球壳半径为 $\\hat{r} = \\sqrt{s}$。\n4. 对于 $1.5  \\hat{r}  N/4$ 范围内的每个球壳，我们计算：\n   - 该球壳上 $\\hat{G}_d$ 值的球壳均值 $\\overline{G}_s$ 和标准差 $\\sigma_s$。\n   - 球壳各向异性 $\\alpha_s = \\sigma_s / \\overline{G}_s$。\n   - 连续值 $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$。\n   - 球壳相对误差 $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$。\n5. 最后，我们计算所有考虑的球壳上的两个全局度量：最大球壳各向异性 $\\max(\\alpha_s)$ 和球壳相对误差的均方根 $\\sqrt{\\langle \\delta_s^2 \\rangle}$。为每个测试案例计算这两个无量纲量。", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(N, h, shape_str):\n    \"\"\"\n    Constructs and analyzes the discrete Green's function for a 3D PIC solver.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        h (float): The grid spacing (not used in the dimensionless calculation but kept for parameter consistency).\n        shape_str (str): The particle shape function, \"NGP\" or \"CIC\".\n\n    Returns:\n        tuple[float, float]: A tuple containing the maximum shell anisotropy and the RMS relative error.\n    \"\"\"\n    if shape_str == 'NGP':\n        m = 0\n    elif shape_str == 'CIC':\n        m = 1\n    else:\n        raise ValueError(\"Invalid shape string. Must be 'NGP' or 'CIC'.\")\n\n    # 1. Create wave-number index grid\n    n_coords_1d = np.fft.fftfreq(N) * N\n    nx, ny, nz = np.meshgrid(n_coords_1d, n_coords_1d, n_coords_1d, indexing='ij')\n\n    # 2. Numerator: Shape function factor |S_m(k)|^2\n    # np.sinc(x) computes sin(pi*x)/(pi*x). We need sinc(pi*n/N) = sin(pi*n/N)/(pi*n/N).\n    # This corresponds to np.sinc(n/N).\n    sinc_arg_x = nx / N\n    sinc_arg_y = ny / N\n    sinc_arg_z = nz / N\n\n    sinc_val_x = np.sinc(sinc_arg_x)\n    sinc_val_y = np.sinc(sinc_arg_y)\n    sinc_val_z = np.sinc(sinc_arg_z)\n\n    shape_factor_sq = (sinc_val_x * sinc_val_y * sinc_val_z)**(2 * (m + 1))\n\n    # 3. Denominator: Fourier representation of the -Laplacian operator\n    # Denom = 4 * sum(sin^2(pi*n_i/N))\n    K_sq = 4 * (np.sin(np.pi * nx / N)**2 + \n                np.sin(np.pi * ny / N)**2 + \n                np.sin(np.pi * nz / N)**2)\n\n    # 4. Spectral Green's function, handling k=0 singularity\n    with np.errstate(divide='ignore', invalid='ignore'):\n        G_k = shape_factor_sq / K_sq\n    \n    G_k[0, 0, 0] = 0.0 # Set DC mode to zero\n    \n    # 5. Inverse FFT to get real-space Green's function\n    G_r = np.real(np.fft.ifftn(G_k))\n\n    # 6. Analysis of anisotropy and error\n    r_min = 1.5\n    r_max = N / 4.0\n\n    # Create coordinate grid for distance calculation. fftshift centers the result.\n    G_r_shifted = np.fft.fftshift(G_r)\n    coords_1d = np.arange(-N // 2, N // 2)\n    ix, iy, iz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n    s = ix**2 + iy**2 + iz**2\n    \n    # Group grid points into shells by squared distance 's'\n    shell_data = {}\n    unique_s_values = np.unique(s)\n    \n    for s_val in unique_s_values:\n        if s_val == 0:\n            continue\n        \n        r_val = np.sqrt(s_val)\n        \n        if r_min  r_val  r_max:\n            indices = np.where(s == s_val)\n            g_d_values = G_r_shifted[indices]\n            \n            mean_g = np.mean(g_d_values)\n            std_g = np.std(g_d_values)\n            \n            anisotropy = 0.0\n            if abs(mean_g) > 1e-16: # Avoid division by zero\n                anisotropy = std_g / abs(mean_g)\n            \n            g_c = 1.0 / (4.0 * np.pi * r_val)\n            rel_error = mean_g / g_c - 1.0\n            \n            shell_data[s_val] = {\n                'anisotropy': anisotropy, \n                'rel_error_sq': rel_error**2\n            }\n\n    # 7. Compute final global metrics\n    anisotropies = [d['anisotropy'] for d in shell_data.values()]\n    rel_errors_sq = [d['rel_error_sq'] for d in shell_data.values()]\n    \n    max_anisotropy = 0.0\n    if anisotropies:\n        max_anisotropy = np.max(anisotropies)\n        \n    rms_rel_error = 0.0\n    if rel_errors_sq:\n        rms_rel_error = np.sqrt(np.mean(rel_errors_sq))\n        \n    return max_anisotropy, rms_rel_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (32, 1.0, \"NGP\"),\n        (32, 1.0, \"CIC\"),\n        (48, 0.5, \"CIC\"),\n    ]\n\n    results = []\n    for N, h, shape in test_cases:\n        max_anisotropy, rms_rel_error = calculate_metrics(N, h, shape)\n        results.append(max_anisotropy)\n        results.append(rms_rel_error)\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2424113"}]}