{"hands_on_practices": [{"introduction": "在构建任何计算反演方法时，一个首要的考虑是其数值稳定性。本练习将探讨离散化选择对衬度源反演（CSI）中核心线性系统条件数的影响，这是一个决定算法收敛性和鲁棒性的关键因素。通过分析网格分辨率与系统条件数之间的关系[@problem_id:3295893]，您将深入理解数值模型构建中的基本权衡，并为选择合适的离散化策略建立起直观认识。", "problem": "考虑计算电磁学中“对比源反演”（Contrast Source Inversion, CSI）方法所基于的频域散射问题。在 CSI 中，对比源定义为 $w = \\chi E$，其中 $E$ 是总电场，$\\chi$ 是对比度函数。CSI 中的 $w$ 更新源于最小化一个数据失配项，该项与一个状态约束耦合，此约束由标量亥姆霍兹模型的 Lippmann–Schwinger 积分方程导出，该方程从频域中的麦克斯韦方程组开始。对于背景波数 $k_0$ 和自由空间亥姆霍兹格林函数 $G$，状态算子涉及 $(I - k_0^2 G)$ 作用于 $w$。\n\n为了分离并分析空间离散化步长对 $w$ 更新线性系统条件数的影响，我们考虑一个一维、周期性、标量亥姆霍兹设定，其域长为 $L$ 米。假设 $L = N_w \\lambda$，其中 $\\lambda$ 是自由空间波长，$N_w$ 是域中包含的波长数。设离散化步长为 $\\Delta$，因此网格点数为 $N = L / \\Delta$。设一维离散自由空间亥姆霍兹格林函数为循环矩阵 $G \\in \\mathbb{C}^{N \\times N}$，由第一列 $g_j = \\frac{i}{2 k_0} e^{i k_0 r_j}$ 生成，其中 $r_j$ 是沿网格测量的参考点与第 $j$ 个网格点之间的周期性距离，$k_0 = \\frac{2 \\pi}{\\lambda}$，$i$ 是虚数单位。定义 $w$ 更新系统矩阵为\n$$\nA = S^\\ast S + \\alpha (I - k_0^2 G)^\\ast (I - k_0^2 G),\n$$\n其中 $S$ 是数据算子。为了分离状态算子离散化引入的内在条件数，我们将 $S$ 取为单位算子，因此系统简化为\n$$\nA = I + \\alpha (I - k_0^2 G)^\\ast (I - k_0^2 G).\n$$\n\n从标量亥姆霍兹模型和格林函数的定义出发，使用均匀网格上的周期性距离（间距为 $\\Delta$ 米）来构造 $G$。使用上述定义的算子 $A$ 和一个固定的正权重 $\\alpha$（无量纲），并计算谱条件数\n$$\n\\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)},\n$$\n其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别表示 $A$ 的最大和最小奇异值。该条件数为无量纲。\n\n您的任务是实现一个程序，对于固定的波长 $\\lambda$（米）、固定的波长数 $N_w$ 和固定的 $\\alpha$，评估 $\\kappa_2(A)$ 如何随离散化步长 $\\Delta = \\lambda / \\text{Nppw}$ 的变化而变化，其中 $\\text{Nppw}$ 表示每个波长的网格点数。根据计算结果，确定一个关于网格分辨率相对于波长的经验法则（例如，每个波长 $\\ge 10$ 个点），以产生一个条件良好的 $w$ 更新系统。\n\n您必须使用的基本依据包括：\n- 在标准假设下，频域麦克斯韦方程组可推导出标量亥姆霍兹方程，进而得到 Lippmann–Schwinger 积分公式。\n- 一维自由空间亥姆霍兹格林函数为 $g(x) = \\frac{i}{2 k_0} e^{i k_0 |x|}$。\n- 在周期域上，与 $g$ 的卷积在均匀网格上的离散化会产生一个循环矩阵 $G$。\n\n请纯粹从数学和算法的角度进行分析，除了上述核心定义外，不使用任何经验性的快捷公式。以数值精确的方式计算 $A$ 的奇异值。所有物理量必须以指定的单位表示。\n\n测试套件使用以下参数：\n- 波长 $\\lambda = 1.0$ 米。\n- 域中的波长数 $N_w = 2$（无量纲）。\n- 权重 $\\alpha = 1.0$（无量纲）。\n- 每个波长的点数值（无量纲）：$\\text{Nppw} \\in \\{2, 4, 6, 8, 10, 12, 16, 25\\}$。\n\n对于上述集合中的每个 $\\text{Nppw}$ 值，按规定构造 $A$ 并计算 $\\kappa_2(A)$（无量纲）。您的程序必须输出一行结果，该结果是一个用方括号括起来的逗号分隔列表，其中每个条件数四舍五入到六位小数，顺序与上面列出的 $\\text{Nppw}$ 值相对应。例如，输出格式必须与以下形式完全一致：\n$$\n[\\kappa_2(A_{\\text{Nppw}=2}),\\kappa_2(A_{\\text{Nppw}=4}),\\dots,\\kappa_2(A_{\\text{Nppw}=25})],\n$$\n其中每个条目是四舍五入到六位小数的浮点数。", "solution": "该问题定义明确，并在计算电磁学领域有坚实的科学基础，具体涉及逆散射方法的数值分析。任务是分析在“对比源反演”（CSI）方法中出现的系统矩阵的条件数。我们将提供一个完整的解决方案。\n\n问题的核心是计算矩阵 $A \\in \\mathbb{C}^{N \\times N}$ 的谱条件数 $\\kappa_2(A)$，该矩阵定义为：\n$$\nA = I + \\alpha (I - k_0^2 G)^\\ast (I - k_0^2 G)\n$$\n其中 $I$ 是 $N \\times N$ 单位矩阵，$\\alpha$ 是一个正的无量纲权重，$k_0$ 是背景波数，$G$ 是离散化的格林函数矩阵，$(\\cdot)^\\ast$ 表示共轭转置。条件数定义为最大奇异值与最小奇异值之比，$\\kappa_2(A) = \\sigma_{\\max}(A) / \\sigma_{\\min}(A)$。\n\n首先，我们来分析矩阵 $A$ 的性质。令 $B = I - k_0^2 G$。矩阵 $A$ 可以写成 $A = I + \\alpha B^\\ast B$。矩阵 $B^\\ast B$ 是厄米特（Hermitian）且半正定的。它的特征值是实数且非负。因此，矩阵 $A$ 的特征值形式为 $1 + \\alpha \\lambda_i(B^\\ast B)$，其中 $\\lambda_i(B^\\ast B)$ 是 $B^\\ast B$ 的特征值。因为 $\\alpha > 0$ 且 $\\lambda_i(B^\\ast B) \\ge 0$，所以 $A$ 的所有特征值都是实数且大于等于 $1$。这意味着 $A$ 是一个厄米特正定矩阵。对于厄米特矩阵，其奇异值是其特征值的绝对值。由于 $A$ 的特征值是正的，其奇异值与特征值相同。因此，条件数是最大特征值与最小特征值之比：\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\n$$\n这将问题简化为求 $A$ 的特征值。虽然我们可以显式地构造矩阵 $A$ 并用数值方法计算其特征值，但利用格林函数矩阵 $G$ 的结构，存在一种更高效、更优雅的解法。\n\n问题指出，域是一维且周期性的，并且离散化网格是均匀的。数值分析的一个关键原理是，在均匀周期网格上对卷积算子进行离散化会得到一个循环矩阵。矩阵 $G$ 就代表了这样一个算子。循环矩阵完全由其第一列（例如 $c = (c_0, c_1, \\dots, c_{N-1})^T$）确定，其形式为：\n$$\nC = \\begin{pmatrix}\nc_0  c_{N-1}  \\dots  c_1 \\\\\nc_1  c_0  \\dots  c_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\nc_{N-1}  c_{N-2}  \\dots  c_0\n\\end{pmatrix}\n$$\n循环矩阵有一个基本性质：它们可由离散傅里叶变换（DFT）矩阵对角化。循环矩阵 $C$ 的特征值由其第一列 $c$ 的 DFT 给出。也就是说，如果 $\\hat{c} = \\text{DFT}(c)$，则 $C$ 的特征值就是向量 $\\hat{c}$ 的分量。\n\n我们可以应用这个性质来求 $A$ 的特征值，而无需组装完整的矩阵。\n1. 格林函数矩阵 $G$ 是循环矩阵。其特征值（记为 $\\lambda_k(G)$）是其第一列 $g$ 的 DFT。令 $\\hat{g} = \\text{DFT}(g)$。则 $\\lambda_k(G) = \\hat{g}_k$，其中 $k = 0, \\dots, N-1$。\n\n2. 矩阵 $B = I - k_0^2 G$ 是两个循环矩阵（$I$ 是第一列为 $(1, 0, \\dots, 0)^T$ 的循环矩阵）的线性组合。结果也是一个循环矩阵。因此，其特征值为 $\\lambda_k(B) = 1 - k_0^2 \\lambda_k(G) = 1 - k_0^2 \\hat{g}_k$。\n\n3. 循环矩阵的共轭转置 $B^\\ast$ 也是循环矩阵。两个循环矩阵的乘积 $B^\\ast B$ 是一个可交换的乘积，结果是另一个循环矩阵。可同时对角化的矩阵（如此处的情况）乘积的特征值是它们各自特征值的乘积。$B^\\ast$ 的特征值是 $B$ 特征值的复共轭，即 $\\overline{\\lambda_k(B)}$。因此，$B^\\ast B$ 的特征值为 $\\lambda_k(B^\\ast B) = \\lambda_k(B^\\ast) \\lambda_k(B) = \\overline{\\lambda_k(B)} \\lambda_k(B) = |\\lambda_k(B)|^2$。\n\n4. 最后，矩阵 $A = I + \\alpha B^\\ast B$ 也是循环矩阵。其特征值为 $\\lambda_k(A) = 1 + \\alpha \\lambda_k(B^\\ast B) = 1 + \\alpha |\\lambda_k(B)|^2$。\n\n综合这些结果，我们得到了一个计算 $A$ 特征值的直接公式：\n$$\n\\lambda_k(A) = 1 + \\alpha |1 - k_0^2 \\hat{g}_k|^2, \\quad k = 0, \\dots, N-1\n$$\n其中 $\\hat{g}_k$ 是 $G$ 第一列的 DFT 的分量。\n\n对于每个指定的 $\\text{Nppw}$ 值，计算算法如下：\n1. 根据问题给定的条件定义物理和数值参数：\n    - 波长: $\\lambda = 1.0$ 米。\n    - 域中波长数: $N_w = 2$。\n    - 权重: $\\alpha = 1.0$。\n    - 波数: $k_0 = 2\\pi / \\lambda = 2\\pi$ rad/m。\n    - 离散化步长: $\\Delta = \\lambda / \\text{Nppw}$。\n    - 域长: $L = N_w \\lambda = 2.0$ 米。\n    - 网格点数: $N = L / \\Delta = N_w \\times \\text{Nppw}$。\n\n2. 构造格林函数矩阵 $G$ 的第一列 $g$。第 $j$ 个元素由 $g_j = \\frac{i}{2 k_0} e^{i k_0 r_j}$ 给出，其中 $r_j$ 是网格上从原点到点 $j$ 的周期性距离。对于一个长度为 $L=N\\Delta$、包含 $N$ 个点、间距为 $\\Delta$ 的网格，该距离为 $r_j = \\min(j\\Delta, L - j\\Delta)$，其中 $j = 0, 1, \\dots, N-1$。\n\n3. 计算向量 $g$ 的 DFT 以找到 $G$ 的特征值：$\\hat{g} = \\text{DFT}(g)$。\n\n4. 使用推导的公式计算 $A$ 的特征值：$\\lambda_k(A) = 1.0 + 1.0 \\times |1.0 - (2\\pi)^2 \\hat{g}_k|^2$。\n\n5. 在特征值集合 $\\{\\lambda_k(A)\\}$ 中找到最大值和最小值。\n\n6. 计算条件数 $\\kappa_2(A) = \\lambda_{\\max}(A) / \\lambda_{\\min}(A)$。\n\n这个过程在数值上是高效和准确的，因为它避免了构造大型 $N \\times N$ 矩阵，并利用了快速傅里叶变换（FFT）算法。\n\n根据计算结果，可以推断出一个经验法则。每个波长点数较少（例如 $\\text{Nppw}=2$）会违反波现象的奈奎斯特采样定理，预计会导致非常高的条件数，表明系统是病态的。随着 $\\text{Nppw}$ 的增加，离散化变得更精细，能更准确地表示连续算子，这通常应能改善矩阵 $A$ 的条件数。计算电磁学中的一个通用准则是每个波长至少使用 $10$ 个点以获得可接受的精度。对 $\\kappa_2(A)$ 的分析将揭示该准则是否也为这种 CSI 公式带来了条件良好的系统矩阵。我们预计随着 $\\text{Nppw}$ 的增长，$\\kappa_2(A)$ 会减小并趋于稳定。", "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Computes the spectral condition number of the CSI w-update matrix\n    for a 1D periodic scalar Helmholtz problem.\n    \"\"\"\n\n    # --- Test Suite Parameters ---\n    lambda_ = 1.0  # Wavelength in meters\n    n_w = 2.0      # Number of wavelengths in domain\n    alpha = 1.0    # Regularization weight\n    nppw_values = [2, 4, 6, 8, 10, 12, 16, 25]\n\n    results = []\n\n    for nppw in nppw_values:\n        # --- 1. Calculate physical and numerical parameters ---\n        # Background wavenumber (rad/m)\n        k0 = 2.0 * np.pi / lambda_\n        \n        # Discretization step (m)\n        delta = lambda_ / nppw\n        \n        # Domain length (m)\n        L = n_w * lambda_\n        \n        # Number of grid points (N = n_w * nppw, an integer)\n        N = int(n_w * nppw)\n\n        # --- 2. Construct the first column of the Green's function matrix G ---\n        # The first column g corresponds to the Green's function evaluated\n        # at distances from the source at the origin (j=0) to all other points j.\n        \n        # Create an array of grid indices\n        j_indices = np.arange(N)\n        \n        # Calculate the periodic distance r_j = min(j*delta, L - j*delta) for each grid point\n        r_distances = np.minimum(j_indices * delta, L - j_indices * delta)\n        \n        # The problem defines the discrete Green's function generating vector as:\n        # g_j = (i / 2*k0) * exp(i*k0*r_j).\n        # This formula is used directly.\n        g_col = (1j / (2.0 * k0)) * np.exp(1j * k0 * r_distances)\n\n        # --- 3. Compute eigenvalues of G using FFT ---\n        # The eigenvalues of a circulant matrix are the DFT of its first column.\n        eig_G = scipy.fft.fft(g_col)\n\n        # --- 4. Compute eigenvalues of A using the derived formula ---\n        # The eigenvalues of A = I + alpha * (I - k0^2*G)' * (I - k0^2*G) can be\n        # calculated directly from the eigenvalues of G.\n        # Let B = I - k0^2*G. eig(B) = 1 - k0^2 * eig(G).\n        # Since A is HPD and circulant, its eigenvalues are:\n        # eig(A) = 1 + alpha * |eig(B)|^2\n        eig_A = 1.0 + alpha * np.abs(1.0 - k0**2 * eig_G)**2\n\n        # --- 5. Compute the spectral condition number ---\n        # For a Hermitian Positive Definite matrix, the condition number is the\n        # ratio of the largest to the smallest eigenvalue.\n        kappa = np.max(eig_A) / np.min(eig_A)\n        \n        results.append(kappa)\n\n    # Format the results for output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Print the final result in the exact specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3295893"}, {"introduction": "基于梯度的优化算法是CSI方法的核心，而其成功的关键在于梯度计算的准确性。本练习提供了一个标准的“泰勒检验”（Taylor test）来验证伴随状态法（adjoint-state method）计算出的梯度是否正确[@problem_id:3295894]。通过将解析梯度与有限差分近似进行比较，您将掌握验证和调试复杂优化代码的一项基本技能，确保您的反演算法朝着正确的方向收敛。", "problem": "考虑一个均匀背景下的一维频域散射问题，该问题被离散化为对比源反演（Contrast Source Inversion, CSI）的设置。令总场 $E(x)$ 在有界区间 $\\Omega = [0,L]$ 上满足 Lippmann–Schwinger 积分方程，\n$$\nE(x) \\;=\\; E_{\\mathrm{inc}}(x) \\;+\\; \\int_{\\Omega} G(x,x')\\, k_0^2\\, \\chi(x')\\, E(x')\\, dx',\n$$\n其中 $E_{\\mathrm{inc}}(x)$ 是给定的入射场，$\\chi(x)$ 是未知的（实值）对比度，$k_0$ 是背景波数，$G(x,x')$ 是标量 Helmholtz 方程的一维自由空间格林函数，\n$$\nG(x,x') \\;=\\; \\frac{i}{2 k_0}\\, e^{i k_0 |x - x'|}.\n$$\n我们全程使用无量纲单位。\n\n用 $N$ 个等距节点 $x_n$ 对 $\\Omega$ 进行离散化，节点间距为 $\\Delta x = L/(N-1)$。将总场向量记为 $E \\in \\mathbb{C}^N$，其元素为 $E_n \\approx E(x_n)$；将对比度样本向量记为 $\\chi \\in \\mathbb{R}^N$，其元素为 $\\chi_n \\approx \\chi(x_n)$。定义稠密矩阵 $G \\in \\mathbb{C}^{N \\times N}$，其元素为\n$$\nG_{mn} \\;=\\; \\Delta x \\,\\frac{i}{2 k_0}\\, e^{i k_0 |x_m - x_n|},\n$$\n以及对角矩阵 $V(\\chi) = k_0^2 \\,\\mathrm{diag}(\\chi) \\in \\mathbb{R}^{N \\times N}$。离散总场 $E(\\chi)$ 解线性系统\n$$\nA(\\chi)\\, E(\\chi) \\;=\\; E_{\\mathrm{inc}}, \n\\qquad A(\\chi) \\;=\\; I \\;-\\; G\\,V(\\chi),\n$$\n其中 $I$ 是单位矩阵，$E_{\\mathrm{inc}} \\in \\mathbb{C}^N$ 是在 $\\{x_n\\}$ 处采样的入射场。\n\n令 $P \\in \\{0,1\\}^{M \\times N}$ 为一个选择算子，用于提取总场的 $M$ 个内部样本。给定由选定的基准真实对比度 $\\chi_{\\mathrm{true}}$ 生成的合成数据 $d \\in \\mathbb{C}^M$，定义数据失配目标函数\n$$\nJ(\\chi) \\;=\\; \\frac{1}{2}\\, \\| P\\,E(\\chi) \\;-\\; d \\|_2^2.\n$$\n通过伴随状态法，引入解伴随线性系统的 $\\lambda \\in \\mathbb{C}^N$\n$$\nA(\\chi)^{H}\\, \\lambda \\;=\\; P^{H}\\,\\big(P\\,E(\\chi) \\;-\\; d\\big),\n$$\n其中 ${}^{H}$ 表示共轭转置。$J$ 相对于 $\\chi$ 的梯度是实向量 $g(\\chi) \\in \\mathbb{R}^N$，其分量为\n$$\ng_n(\\chi) \\;=\\; k_0^2\\, \\mathrm{Re}\\!\\left\\{ \\overline{\\left(G^{H}\\lambda\\right)_n}\\; E_n(\\chi) \\right\\}, \n\\qquad n = 1,\\dots,N,\n$$\n其中上划线表示复共轭。该梯度通过以下方式给出了 $J$ 相对于实值扰动 $\\delta\\chi$ 的一阶方向导数\n$$\n\\delta J \\;=\\; \\sum_{n=1}^{N} g_n(\\chi)\\, \\delta\\chi_n \\;+\\; \\mathcal{O}(\\|\\delta\\chi\\|^2).\n$$\n\n您的任务是编写一个完整的程序，该程序：\n- 针对特定的测试配置，构建上述正演模型。\n- 计算基于伴随状态的梯度 $g(\\chi)$。\n- 数值验证这个基于伴随状态的梯度与 $J$ 的有限差分近似在 $\\delta\\chi$ 上达到一阶匹配。\n\n使用以下测试配置和测试套件，全部采用无量纲单位：\n- 域长度：$L = 1$。\n- 网格点数：$N = 80$。\n- 波数：$k_0 = 20\\pi$。\n- 入射场：$E_{\\mathrm{inc}}(x) = e^{i k_0 x}$，在 $\\{x_n\\}$ 处采样。\n- 基准真实对比度：一个以 $x=L/2$ 为中心的高斯凸起，\n  $$\n  \\chi_{\\mathrm{true}}(x) \\;=\\; 0.5 \\,\\exp\\!\\left( -\\frac{(x - L/2)^2}{2\\sigma^2} \\right),\n  \\quad \\text{其中 } \\sigma = 0.15\\,L.\n  $$\n- 数据：$d = P\\,E(\\chi_{\\mathrm{true}})$，使用相同的正演模型和选择算子 $P$。\n- 选择算子 $P$：选择 $M = 16$ 个等距的内部网格索引（为避免边缘效应，排除每个边界的前四个和后四个节点），并让 $P$ 提取这些 $E$ 的样本。\n- 测试背景对比度：\n  - 对于测试 1 和 3，使用 \n    $$\n    \\chi_0(x) \\;=\\; 0.1\\, \\sin\\!\\left( \\frac{2\\pi x}{L} \\right).\n    $$\n  - 对于测试 2，使用 $\\chi_0(x) \\equiv 0$。\n- 方向向量：\n  - 对于测试 1，使用单像素扰动，即 $\\delta\\chi = \\mathbf{e}_p$，其中 $p = \\lfloor N/3 \\rfloor$。\n  - 对于测试 2 和测试 3，使用一个固定的伪随机实向量 $\\delta\\chi$，其 $\\ell_2$-范数为单位范数（为保证可复现性设置种子），并在所有 $N$ 个条目上都有支撑。\n- 有限差分步长：$\\varepsilon_1 = 1 \\times 10^{-3}$ 和 $\\varepsilon_2 = 5 \\times 10^{-4}$。\n\n定义以下三个测试，并返回布尔值，以指示预期的一阶一致性是否成立：\n- 测试 1（前向差分一阶缩放）：对于如上的 $\\chi_0$ 和 $\\delta\\chi = \\mathbf{e}_p$，定义\n  $$\n  \\mathrm{FD}(\\varepsilon) \\;=\\; \\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) \\;-\\; J(\\chi_0)}{\\varepsilon}, \n  \\qquad \\mathrm{AD} \\;=\\; g(\\chi_0)^{T} \\delta\\chi,\n  $$\n  以及失配 $R(\\varepsilon) = \\big| \\mathrm{FD}(\\varepsilon) - \\mathrm{AD} \\big|$。验证 $R(\\varepsilon_2)/R(\\varepsilon_1)$ 位于 $[0.3,\\,0.7]$ 区间内。\n- 测试 2（零对比度下的中心差分一致性）：对于 $\\chi_0 \\equiv 0$ 和单位范数的随机向量 $\\delta\\chi$，定义\n  $$\n  \\mathrm{CD}(\\varepsilon) \\;=\\; \\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) \\;-\\; J(\\chi_0 - \\varepsilon\\,\\delta\\chi)}{2\\varepsilon},\n  \\qquad \\mathrm{AD} \\;=\\; g(\\chi_0)^{T} \\delta\\chi,\n  $$\n  以及失配 $C(\\varepsilon) = \\big| \\mathrm{CD}(\\varepsilon) - \\mathrm{AD} \\big|$。验证 $C(10^{-4}) \\le 10^{-6}$。\n- 测试 3（中心差分二阶缩放）：对于与测试 1 中相同的 $\\chi_0$ 和单位范数的随机向量 $\\delta\\chi$，验证比率 $C(\\varepsilon_2)/C(\\varepsilon_1)$ 位于 $[0.2,\\,0.3]$ 区间内。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个结果都必须是布尔值。不允许有其他输出。", "solution": "用户要求对一维对比源反演问题的伴随状态梯度进行数值验证。该问题是适定的、有科学依据的，并为提供完整解法提供了所有必要信息。该验证过程通常称为泰勒测试或梯度检验，是开发基于优化的反演算法中一个标准且至关重要的步骤。它确保解析推导出的梯度能正确表示目标函数的局部一阶行为。\n\n问题的核心在于 Lippmann-Schwinger 积分方程，它将总电场 $E(x)$ 描述为入射场 $E_{\\mathrm{inc}}(x)$ 与由对比度物体 $\\chi(x)$ 产生的散射场之和：\n$$\nE(x) \\;=\\; E_{\\mathrm{inc}}(x) \\;+\\; k_0^2 \\int_{\\Omega} G(x,x')\\, \\chi(x')\\, E(x')\\, dx'\n$$\n在 $N$ 个点 $\\{x_n\\}$ 的网格上离散化后，该方程转换为场样本向量 $E \\in \\mathbb{C}^N$ 的线性系统：\n$$\nA(\\chi)\\, E(\\chi) \\;=\\; E_{\\mathrm{inc}}\n$$\n其中 $A(\\chi) = I - G V(\\chi)$。此处，$I \\in \\mathbb{R}^{N \\times N}$ 是单位矩阵，$G \\in \\mathbb{C}^{N \\times N}$ 是离散化的格林函数算子，$V(\\chi) \\in \\mathbb{R}^{N \\times N}$ 是一个对角矩阵，其对角线元素为对比度值 $\\chi_n \\approx \\chi(x_n)$ 乘以 $k_0^2$。求解该系统以获得 $E(\\chi)$ 的过程构成了正演模型。\n\n反演的目标是找到一个对比度 $\\chi$，使数据失配目标函数 $J(\\chi)$ 最小化。该函数量化了测量数据 $d \\in \\mathbb{C}^M$ 与计算场的相应样本 $E(\\chi)$ 之间的平方 $\\ell_2$-范数差：\n$$\nJ(\\chi) \\;=\\; \\frac{1}{2}\\, \\| P\\,E(\\chi) \\;-\\; d \\|_2^2\n$$\n矩阵 $P \\in \\{0,1\\}^{M \\times N}$ 是一个选择算子，用于提取测量位置处的场值。\n\n为了使用基于梯度的优化方法，我们需要 $J$ 相对于 $\\chi$ 的梯度。直接计算的成本会非常高，因为它需要为 $\\chi$ 的每个分量求解一次正演问题。伴随状态法提供了一种高效的替代方案。通过引入伴随场 $\\lambda \\in \\mathbb{C}^N$（它是伴随线性系统的解），\n$$\nA(\\chi)^{H}\\, \\lambda \\;=\\; P^{H}\\,\\big(P\\,E(\\chi) \\;-\\; d\\big),\n$$\n梯度向量 $g(\\chi) \\in \\mathbb{R}^N$ 只需再解一个线性系统即可计算得出。梯度的分量由下式给出：\n$$\ng_n(\\chi) \\;=\\; k_0^2\\, \\mathrm{Re}\\!\\left\\{ \\overline{\\left(G^{H}\\lambda\\right)_n}\\; E_n(\\chi) \\right\\}\n$$\n该梯度给出了 $J$ 在任意方向 $\\delta\\chi$ 上的方向导数，即 $g(\\chi)^T \\delta\\chi$。\n\n为了验证这个基于伴随状态的梯度 $g(\\chi)$ 的正确性，我们将其对 $J$ 变化的预测与有限差分近似进行比较。目标函数在点 $\\chi_0$ 处沿方向 $\\delta\\chi$ 的泰勒级数展开为：\n$$\nJ(\\chi_0 + \\varepsilon\\,\\delta\\chi) = J(\\chi_0) + \\varepsilon\\, g(\\chi_0)^T \\delta\\chi + \\mathcal{O}(\\varepsilon^2)\n$$\n由此，我们可以推导出方向导数的前向差分近似：\n$$\n\\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) - J(\\chi_0)}{\\varepsilon} = g(\\chi_0)^T \\delta\\chi + \\mathcal{O}(\\varepsilon)\n$$\n此近似的误差是关于 $\\varepsilon$ 的一阶误差。测试 1 通过检查将步长 $\\varepsilon$ 减半是否会使误差近似减半来验证这一点，即误差比率接近 0.5。\n\n一个更精确的近似是中心差分：\n$$\n\\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) - J(\\chi_0 - \\varepsilon\\,\\delta\\chi)}{2\\varepsilon} = g(\\chi_0)^T \\delta\\chi + \\mathcal{O}(\\varepsilon^2)\n$$\n中心差分近似的误差是关于 $\\varepsilon$ 的二阶误差。测试 2 通过检验对于一个小的 $\\varepsilon$，中心差分近似与基于伴随状态的方向导数非常接近，来验证梯度计算的准确性。测试 3 通过检查将 $\\varepsilon$ 减半是否会使误差减少约 $(\\frac{1}{2})^2 = 0.25$ 的因子，来验证二阶收敛性。\n\n实现将按以下步骤进行：\n1.  建立计算网格并定义物理常数（$L$、$N$、$k_0$）。\n2.  构建离散格林矩阵 $G$ 和入射场向量 $E_{\\mathrm{inc}}$。\n3.  定义真实对比度分布 $\\chi_{\\mathrm{true}}$，并通过求解 $\\chi_{\\mathrm{true}}$ 的正演问题并选择所需样本来生成合成数据 $d$。\n4.  实现以下函数：\n    a. 求解正演问题 $A(\\chi)E=E_{\\mathrm{inc}}$ 以获得 $E(\\chi)$。\n    b. 计算目标函数 $J(\\chi)$。\n    c. 求解伴随问题 $A(\\chi)^H \\lambda = \\text{rhs}$，然后计算梯度 $g(\\chi)$。\n5.  通过将有限差分近似与基于伴随状态的方向导数 $g(\\chi_0)^T \\delta\\chi$ 进行比较，对给定的测试对比度 $\\chi_0$ 和扰动方向 $\\delta\\chi$ 执行三个指定的测试。\n6.  返回三个测试的布尔结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the contrast source inversion gradient verification problem.\n    \"\"\"\n    # 1. Define problem parameters and discretize the domain\n    L = 1.0\n    N = 80\n    k0 = 20.0 * np.pi\n    M = 16\n    \n    # Grid\n    x = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    \n    # Incident field\n    E_inc = np.exp(1j * k0 * x)\n    \n    # Green's function matrix\n    x_m, x_n = np.meshgrid(x, x, indexing='ij')\n    G_mat = dx * (1j / (2 * k0)) * np.exp(1j * k0 * np.abs(x_m - x_n))\n\n    # Selection operator (indices)\n    # Exclude first and last 4 nodes. Select from indices 4 to N-5=75.\n    P_indices = np.round(np.linspace(4, N - 5, M)).astype(int)\n\n    # 2. Generate synthetic data from ground-truth contrast\n    sigma = 0.15 * L\n    chi_true = 0.5 * np.exp(-(x - L/2)**2 / (2 * sigma**2))\n\n    # Helper functions that capture the simulation context (G_mat, k0, E_inc, etc.)\n    def get_total_field(chi: np.ndarray) -> np.ndarray:\n        \"\"\"Solves the forward problem for the total field E(chi).\"\"\"\n        I = np.eye(N, dtype=np.complex128)\n        # V(chi) is diagonal, so G*V(chi) is G_mn * k0^2 * chi_n\n        # This is equivalent to scaling columns of G\n        A_chi = I - G_mat * (k0**2 * chi[None, :])\n        E = np.linalg.solve(A_chi, E_inc)\n        return E\n\n    E_true = get_total_field(chi_true)\n    d = E_true[P_indices]\n\n    # 3. Implement core computational functions\n    def get_objective(chi: np.ndarray) -> float:\n        \"\"\"Computes the data misfit objective J(chi).\"\"\"\n        E_chi = get_total_field(chi)\n        residual = E_chi[P_indices] - d\n        return 0.5 * np.linalg.norm(residual)**2\n\n    def get_gradient(chi: np.ndarray) -> np.ndarray:\n        \"\"\"Computes the adjoint-based gradient g(chi).\"\"\"\n        E_chi = get_total_field(chi)\n        \n        # Adjoint RHS: P^H * (P*E(chi) - d)\n        adj_rhs = np.zeros(N, dtype=np.complex128)\n        residual = E_chi[P_indices] - d\n        adj_rhs[P_indices] = residual\n        \n        # Adjoint matrix: A^H = I - V(chi) * G^H\n        # V is real diagonal, so V^H = V\n        # Product V*G^H corresponds to scaling rows of G^H\n        A_chi_H = np.eye(N, dtype=np.complex128) - (k0**2 * chi[:, None]) * G_mat.conj().T\n        \n        lambda_vec = np.linalg.solve(A_chi_H, adj_rhs)\n        \n        # Gradient formula\n        GH_lambda = G_mat.conj().T @ lambda_vec\n        g = k0**2 * np.real(np.conj(GH_lambda) * E_chi)\n        return g\n\n    results = []\n    \n    # 4. Define test configurations\n    chi0_test1_3 = 0.1 * np.sin(2 * np.pi * x / L)\n    chi0_test2 = np.zeros(N)\n\n    p = N // 3\n    delta_chi_test1 = np.zeros(N)\n    delta_chi_test1[p] = 1.0\n\n    np.random.seed(0)\n    delta_chi_test2_3 = np.random.randn(N)\n    delta_chi_test2_3 /= np.linalg.norm(delta_chi_test2_3)\n\n    eps1 = 1e-3\n    eps2 = 5e-4\n\n    # 5. Execute tests\n    # --- Test 1: Forward-difference first-order scaling ---\n    g0_t1 = get_gradient(chi0_test1_3)\n    AD_t1 = g0_t1 @ delta_chi_test1\n    J0_t1 = get_objective(chi0_test1_3)\n    \n    J_p_eps1 = get_objective(chi0_test1_3 + eps1 * delta_chi_test1)\n    FD1 = (J_p_eps1 - J0_t1) / eps1\n    R1 = np.abs(FD1 - AD_t1)\n\n    J_p_eps2 = get_objective(chi0_test1_3 + eps2 * delta_chi_test1)\n    FD2 = (J_p_eps2 - J0_t1) / eps2\n    R2 = np.abs(FD2 - AD_t1)\n\n    ratio1 = R2 / R1 if R1 != 0 else 0\n    results.append(0.3 = ratio1 = 0.7)\n\n    # --- Test 2: Central-difference consistency at zero contrast ---\n    g0_t2 = get_gradient(chi0_test2)\n    AD_t2 = g0_t2 @ delta_chi_test2_3\n    eps_t2 = 1e-4\n    \n    J_p = get_objective(chi0_test2 + eps_t2 * delta_chi_test2_3)\n    J_m = get_objective(chi0_test2 - eps_t2 * delta_chi_test2_3)\n    CD_t2 = (J_p - J_m) / (2 * eps_t2)\n    C_eps = np.abs(CD_t2 - AD_t2)\n    \n    results.append(C_eps = 1e-6)\n    \n    # --- Test 3: Central-difference second-order scaling ---\n    g0_t3 = get_gradient(chi0_test1_3) # Same chi0 as Test 1\n    AD_t3 = g0_t3 @ delta_chi_test2_3 # Same random delta_chi as Test 2\n    \n    Jp1 = get_objective(chi0_test1_3 + eps1 * delta_chi_test2_3)\n    Jm1 = get_objective(chi0_test1_3 - eps1 * delta_chi_test2_3)\n    CD1 = (Jp1 - Jm1) / (2 * eps1)\n    C1 = np.abs(CD1 - AD_t3)\n    \n    Jp2 = get_objective(chi0_test1_3 + eps2 * delta_chi_test2_3)\n    Jm2 = get_objective(chi0_test1_3 - eps2 * delta_chi_test2_3)\n    CD2 = (Jp2 - Jm2) / (2 * eps2)\n    C2 = np.abs(CD2 - AD_t3)\n\n    ratio3 = C2 / C1 if C1 != 0 else 0\n    results.append(0.2 = ratio3 = 0.3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3295894"}, {"introduction": "反演算法的最终目标是获得物理上真实可信的结果。然而，由于噪声和模型误差，计算出的材料参数可能违反基本的物理定律。本练习要求您从麦克斯韦方程和坡印廷定理出发，推导并实现一个诊断工具，用于检查重构的电纳率 $\\chi$ 是否满足无源性（passivity）这一物理约束[@problem_id:3295880]。这项实践将理论物理原理与计算验证相结合，强调了在反演问题中确保解的物理现实性的重要性。", "problem": "考虑一个时间依赖性约定为 $e^{-i \\omega t}$ 的时谐电磁散射场景，其中计算重建在离散网格上产生了一个标量、各向同性电纳场 $\\chi(\\mathbf{r})$ 的估计值。在对比源反演的一种常见公式中，本构关系为 $ \\mathbf{D}(\\mathbf{r}) = \\varepsilon_b \\left( 1 + \\chi(\\mathbf{r}) \\right) \\mathbf{E}(\\mathbf{r}) $，其中 $\\varepsilon_b$ 是真实的、正值的背景介电常数，$\\mathbf{E}(\\mathbf{r})$ 是电场的复相量。当且仅当一种材料不产生净电磁能量时，该材料是无源的。在上述时间约定下，当背景是无损耗的时，无源性意味着一个局部材料不等式 $ \\operatorname{Im}\\{\\chi(\\mathbf{r})\\} \\ge 0 $，以及全局耗散功率非负性：任何有限区域内的时间平均总耗散功率必须是非负的。\n\n从基本的电磁学原理（包括麦克斯韦方程组和坡印廷定理）出发，推导一个诊断工具。给定在具有体积 $\\{\\Delta V_n\\}_{n=1}^N$ 的 $N$ 个单元格的网格上的离散样本 $\\{\\chi_n\\}_{n=1}^N$ 和 $\\{E_n\\}_{n=1}^N$，该工具需要检验：\n- 局部无源性条件 $ \\operatorname{Im}\\{\\chi_n\\} \\ge 0 $ 对所有 $n$ 成立。\n- 全局耗散功率非负性条件 $ P_{\\mathrm{diss}} \\ge 0 $，其中 $ P_{\\mathrm{diss}} $ 是网格上时间平均耗散功率的离散近似。\n\n你的推导必须从计算电磁学的有效基础开始：麦克斯韦方程组和坡印廷定理。不要假设任何快捷公式；从这些原理推导出离散诊断工具。清楚地陈述证明该诊断工具合理性的任何假设。\n\n然后，实现一个程序，将此诊断工具应用于一组通过扰动一个已知的基准真相 $\\{\\chi^{\\mathrm{true}}_n\\}$ 得到的合成“带噪重建” $\\{\\widehat{\\chi}_n\\}$。扰动使用的是独立同分布的复高斯噪声 $\\eta_n \\sim \\mathcal{N}(0,\\sigma^2) + i\\,\\mathcal{N}(0,\\sigma^2)$，即 $ \\widehat{\\chi}_n = \\chi^{\\mathrm{true}}_n + \\eta_n $。该诊断工具必须标记出违反局部无源性和全局耗散功率非负性的情况。\n\n所有物理量必须用国际单位制 (SI) 表示。频率必须以赫兹（对于 $f$）或弧度/秒（对于 $\\omega$）给出。相位必须以弧度指定。功率必须以瓦特报告，并四舍五入到 $12$ 位小数。\n\n使用以下常数和假设：\n- 背景相对介电常数 $ \\varepsilon_{r,b} = 2.25 $，真空介电常数 $ \\varepsilon_0 = 8.854187817 \\times 10^{-12} \\,\\mathrm{F/m} $，以及背景介电常数 $ \\varepsilon_b = \\varepsilon_0 \\varepsilon_{r,b} $。\n- 工作频率 $ f = 3.0 \\times 10^{9} \\,\\mathrm{Hz} $，角频率 $ \\omega = 2\\pi f $。\n- 对所有 $n$，均匀单元体积 $ \\Delta V_n = 1.0 \\times 10^{-6} \\,\\mathrm{m}^3 $。\n\n你的程序必须实现该诊断工具并评估以下测试套件。对于每个测试用例，使用幅度和相位构造标量复数场 $E_n$：$ E_n = |E_n| e^{i \\phi_n} $。\n\n测试套件：\n- 情况 A（标称，低噪声，典型场变化）：\n  - 网格大小 $ N = 5 $。\n  - 基准真相电纳实部 $ \\operatorname{Re}\\{\\chi^{\\mathrm{true}}_n\\} $: $ [0.10,\\,0.05,\\,0.00,\\,0.02,\\,0.08] $。\n  - 基准真相电纳虚部 $ \\operatorname{Im}\\{\\chi^{\\mathrm{true}}_n\\} $: $ [0.020,\\,0.010,\\,0.030,\\,0.005,\\,0.015] $。\n  - 场幅度 $ |E_n| $: $ [1.0,\\,2.0,\\,1.5,\\,0.0,\\,0.5] $。\n  - 场相位 $ \\phi_n $ (弧度): $ [0.0,\\,\\pi/4,\\,-\\pi/2,\\,0.0,\\,\\pi] $。\n  - 噪声标准差 $ \\sigma = 0.002 $。\n  - 伪随机种子 $ s = 12345 $。\n- 情况 B（较高噪声，变化场，可能违规）：\n  - 网格大小 $ N = 5 $。\n  - 基准真相电纳实部 $ \\operatorname{Re}\\{\\chi^{\\mathrm{true}}_n\\} $: $ [0.10,\\,0.05,\\,0.00,\\,0.02,\\,0.08] $。\n  - 基准真相电纳虚部 $ \\operatorname{Im}\\{\\chi^{\\mathrm{true}}_n\\} $: $ [0.020,\\,0.010,\\,0.030,\\,0.005,\\,0.015] $。\n  - 场幅度 $ |E_n| $: $ [0.3,\\,0.7,\\,1.2,\\,2.0,\\,1.0] $。\n  - 场相位 $ \\phi_n $ (弧度): $ [\\pi/3,\\,-\\pi/6,\\,\\pi/2,\\,\\pi/8,\\,-\\pi/5] $。\n  - 噪声标准差 $ \\sigma = 0.030 $。\n  - 伪随机种子 $ s = 2025 $。\n- 情况 C（零场边缘情况，中等噪声）：\n  - 网格大小 $ N = 4 $。\n  - 基准真相电纳实部 $ \\operatorname{Re}\\{\\chi^{\\mathrm{true}}_n\\} $: $ [0.0,\\,0.10,\\,-0.05,\\,0.20] $。\n  - 基准真相电纳虚部 $ \\operatorname{Im}\\{\\chi^{\\mathrm{true}}_n\\} $: $ [0.0,\\,0.0,\\,0.0,\\,0.0] $。\n  - 场幅度 $ |E_n| $: $ [0.0,\\,0.0,\\,0.0,\\,0.0] $。\n  - 场相位 $ \\phi_n $ (弧度): $ [0.0,\\,0.0,\\,0.0,\\,0.0] $。\n  - 噪声标准差 $ \\sigma = 0.010 $。\n  - 伪随机种子 $ s = 7 $。\n\n对于每种情况，程序必须：\n- 从 $ \\chi^{\\mathrm{true}}_n $ 和指定的噪声生成 $ \\widehat{\\chi}_n $。\n- 计算布尔值，指示是否所有 $ \\operatorname{Im}\\{\\widehat{\\chi}_n\\} \\ge 0 $ 以及总耗散功率 $ P_{\\mathrm{diss}} $ 是否为非负。\n- 统计使 $ \\operatorname{Im}\\{\\widehat{\\chi}_n\\}  0 $ 的索引 $n$ 的数量。\n- 计算以瓦特为单位的总耗散功率 $ P_{\\mathrm{diss}} $，并四舍五入到 $12$ 位小数。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，包含一个 Python 风格的列表，每个测试用例对应一个条目。每个条目本身必须是一个形式为 $[\\text{all\\_imag\\_nonneg}, \\text{total\\_power\\_nonneg}, \\text{num\\_negative\\_pixels}, \\text{P\\_diss\\_W}]$ 的列表，其中前两个条目是布尔值，第三个是整数，第四个是四舍五入到 $12$ 位小数的浮点数。例如，打印的输出应在单行上显示为 $[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]$，不含任何多余文本。", "solution": "该问题要求推导并实现一个诊断工具，用于验证在离散网格上重建的电纳场 $\\chi(\\mathbf{r})$ 的物理无源性。推导必须源于麦克斯韦方程组和坡印廷定理。\n\n### 无源性诊断工具的推导\n\n我们从时谐场的宏观麦克斯韦方程组开始，假设时间依赖性为 $e^{-i\\omega t}$，并且在一个没有自由磁荷和外部源电流的区域内：\n$$ \\nabla \\times \\mathbf{E} = i\\omega \\mathbf{B} \\quad (1) $$\n$$ \\nabla \\times \\mathbf{H} = -i\\omega \\mathbf{D} \\quad (2) $$\n此处，$\\mathbf{E}$ 和 $\\mathbf{H}$ 分别是电场和磁场的复相量，而 $\\mathbf{D}$ 和 $\\mathbf{B}$ 是相应的通量密度。角频率是 $\\omega$。\n\n问题指定了一个非磁性介质，因此磁本构关系为 $\\mathbf{B} = \\mu_0 \\mathbf{H}$，其中 $\\mu_0$ 是自由空间的磁导率。电本构关系由 $\\mathbf{D}(\\mathbf{r}) = \\varepsilon_b (1 + \\chi(\\mathbf{r})) \\mathbf{E}(\\mathbf{r})$ 给出，其中 $\\varepsilon_b$ 是无损耗背景介质的真实、正值介电常数，$\\chi(\\mathbf{r})$ 是标量电纳对比度。\n\n我们可以将电位移场 $\\mathbf{D}$ 表示为背景位移和感应电极化强度 $\\mathbf{P}$ 的和：\n$$ \\mathbf{D} = \\varepsilon_b \\mathbf{E} + \\varepsilon_b \\chi \\mathbf{E} = \\varepsilon_b \\mathbf{E} + \\mathbf{P} $$\n因此，极化矢量为 $\\mathbf{P} = \\varepsilon_b \\chi \\mathbf{E}$。极化产生等效的体电流密度 $\\mathbf{J}_{eq}$，它是时域中极化强度对时间的导数。在频域中，这对应于：\n$$ \\mathbf{J}_{eq} = -i\\omega \\mathbf{P} = -i\\omega \\varepsilon_b \\chi \\mathbf{E} \\quad (3) $$\n该电流代表了材料对比度对总电场 $\\mathbf{E}$ 的响应。\n\n在一个体积内由电磁场耗散的时间平均功率由场对电流所做的功给出。该功率的密度 $p_{diss}$ 由 $\\frac{1}{2}\\operatorname{Re}\\{\\mathbf{E} \\cdot \\mathbf{J}^*\\}$ 给出，其中 $\\mathbf{J}$ 是相关的电流密度。在我们的案例中，我们关心的是由材料对比度（由等效电流 $\\mathbf{J}_{eq}$ 表示）特别耗散的功率。\n因此，由电纳对比度耗散的时间平均功率密度为：\n$$ p_{diss}(\\mathbf{r}) = \\frac{1}{2}\\operatorname{Re}\\{\\mathbf{E}(\\mathbf{r}) \\cdot \\mathbf{J}_{eq}(\\mathbf{r})^*\\} \\quad (4) $$\n我们取方程 $(3)$ 中 $\\mathbf{J}_{eq}$ 的复共轭。由于 $\\omega$ 和 $\\varepsilon_b$ 是实数，我们有：\n$$ \\mathbf{J}_{eq}^* = (-i\\omega \\varepsilon_b \\chi \\mathbf{E})^* = i\\omega \\varepsilon_b \\chi^* \\mathbf{E}^* $$\n将其代入 $p_{diss}$ 的表达式：\n$$ p_{diss} = \\frac{1}{2}\\operatorname{Re}\\{\\mathbf{E} \\cdot (i\\omega \\varepsilon_b \\chi^* \\mathbf{E}^*)\\} $$\n由于 $\\chi$ 是标量，我们可以重新排列各项。点积 $\\mathbf{E} \\cdot \\mathbf{E}^*$ 等于 $|\\mathbf{E}|^2$，即电场矢量的大小平方。\n$$ p_{diss} = \\frac{1}{2}\\operatorname{Re}\\{i\\omega \\varepsilon_b \\chi^* |\\mathbf{E}|^2\\} $$\n让我们用实部和虚部表示复电纳 $\\chi = \\operatorname{Re}\\{\\chi\\} + i\\operatorname{Im}\\{\\chi\\}$。其共轭为 $\\chi^* = \\operatorname{Re}\\{\\chi\\} - i\\operatorname{Im}\\{\\chi\\}$。\n$$ p_{diss} = \\frac{1}{2}\\operatorname{Re}\\{i\\omega \\varepsilon_b (\\operatorname{Re}\\{\\chi\\} - i\\operatorname{Im}\\{\\chi\\}) |\\mathbf{E}|^2\\} $$\n$$ p_{diss} = \\frac{1}{2}\\operatorname{Re}\\{i\\omega \\varepsilon_b \\operatorname{Re}\\{\\chi\\} |\\mathbf{E}|^2 + \\omega \\varepsilon_b \\operatorname{Im}\\{\\chi\\} |\\mathbf{E}|^2\\} $$\n大括号内的第一项是纯虚数，而第二项是纯实数。取表达式的实部得到：\n$$ p_{diss}(\\mathbf{r}) = \\frac{1}{2}\\omega \\varepsilon_b \\operatorname{Im}\\{\\chi(\\mathbf{r})\\} |\\mathbf{E}(\\mathbf{r})|^2 \\quad (5) $$\n这个方程提供了局部材料特性和耗散功率密度之间的基本关系。\n\n如果材料不产生净电磁能量，则定义为无源的。这施加了两个条件：\n1.  **局部无源性**：在任何点 $\\mathbf{r}$，时间平均耗散功率密度必须为非负，$p_{diss}(\\mathbf{r}) \\ge 0$。由于量 $\\omega$、$\\varepsilon_b$ 和 $|\\mathbf{E}(\\mathbf{r})|^2$ 都是非负的，方程 $(5)$ 意味着局部无源性等价于以下条件：\n    $$ \\operatorname{Im}\\{\\chi(\\mathbf{r})\\} \\ge 0 $$\n    这构成了我们诊断工具的第一部分的基础。\n\n2.  **全局无源性**：在任何有限体积 $V$ 内耗散的总时间平均功率必须是非负的。这个总功率 $P_{diss}$ 是功率密度在体积上的积分：\n    $$ P_{diss} = \\int_V p_{diss}(\\mathbf{r}) \\, dV = \\int_V \\frac{1}{2}\\omega \\varepsilon_b \\operatorname{Im}\\{\\chi(\\mathbf{r})\\} |\\mathbf{E}(\\mathbf{r})|^2 \\, dV \\ge 0 $$\n\n### 用于计算诊断的离散化\n\n问题提供了在具有 $N$ 个单元格（每个单元格体积为 $\\Delta V_n$）的离散网格上的重建电纳 $\\{\\widehat{\\chi}_n\\}_{n=1}^N$ 和电场 $\\{E_n\\}_{n=1}^N$。为了构建诊断工具，我们假设电纳和电场在每个单元格 $n$ 内是分段常数，取值为 $\\widehat{\\chi}_n$ 和 $E_n$。问题还指定 $E_n$ 是一个标量复数场，这是二维模型中常见的简化，其中只有一个矢量分量非零（例如 $E_z$）。因此我们假设在单元格 $n$ 内，$|\\mathbf{E}(\\mathbf{r})|^2$ 可以被 $|E_n|^2$ 替代。\n\n离散诊断工具直接如下：\n-   **局部无源性检查**：对于每个单元格 $n \\in \\{1, \\dots, N\\}$，我们检查是否满足局部无源性准则：\n    $$ \\operatorname{Im}\\{\\widehat{\\chi}_n\\} \\ge 0 $$\n    诊断工具将统计违反此条件的单元格 $n$ 的数量（即 $\\operatorname{Im}\\{\\widehat{\\chi}_n\\}  0$）。\n\n-   **全局耗散功率检查**：总耗散功率 $P_{diss}$ 的积分通过对所有单元格求和来近似：\n    $$ P_{diss} = \\sum_{n=1}^{N} \\left( \\frac{1}{2}\\omega \\varepsilon_b \\operatorname{Im}\\{\\widehat{\\chi}_n\\} |E_n|^2 \\right) \\Delta V_n $$\n    诊断工具将计算这个总和并检查是否满足全局无源性准则 $P_{diss} \\ge 0$。\n\n这两项检查构成了要实现的完整诊断工具。实现将使用提供的带噪电纳值 $\\widehat{\\chi}_n$ 来代替解析的 $\\chi(\\mathbf{r})$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a passivity diagnostic to noisy susceptibility reconstructions.\n    \"\"\"\n\n    # --- Constants ---\n    EPSILON_0 = 8.854187817e-12  # Vacuum permittivity in F/m\n    EPSILON_R_B = 2.25            # Background relative permittivity\n    FREQ = 3.0e9                  # Operating frequency in Hz\n    DELTA_V = 1.0e-6              # Uniform cell volume in m^3\n\n    # --- Derived Constants ---\n    EPSILON_B = EPSILON_0 * EPSILON_R_B  # Background permittivity\n    OMEGA = 2 * np.pi * FREQ           # Angular frequency in rad/s\n\n    # Prefactor for dissipated power calculation\n    power_prefactor = 0.5 * OMEGA * EPSILON_B * DELTA_V\n\n    # --- Test Suite ---\n    test_cases = [\n        {\n            \"N\": 5,\n            \"re_chi_true\": np.array([0.10, 0.05, 0.00, 0.02, 0.08]),\n            \"im_chi_true\": np.array([0.020, 0.010, 0.030, 0.005, 0.015]),\n            \"E_mag\": np.array([1.0, 2.0, 1.5, 0.0, 0.5]),\n            \"E_phase\": np.array([0.0, np.pi/4, -np.pi/2, 0.0, np.pi]),\n            \"sigma\": 0.002,\n            \"seed\": 12345,\n        },\n        {\n            \"N\": 5,\n            \"re_chi_true\": np.array([0.10, 0.05, 0.00, 0.02, 0.08]),\n            \"im_chi_true\": np.array([0.020, 0.010, 0.030, 0.005, 0.015]),\n            \"E_mag\": np.array([0.3, 0.7, 1.2, 2.0, 1.0]),\n            \"E_phase\": np.array([np.pi/3, -np.pi/6, np.pi/2, np.pi/8, -np.pi/5]),\n            \"sigma\": 0.030,\n            \"seed\": 2025,\n        },\n        {\n            \"N\": 4,\n            \"re_chi_true\": np.array([0.0, 0.10, -0.05, 0.20]),\n            \"im_chi_true\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"E_mag\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"E_phase\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"sigma\": 0.010,\n            \"seed\": 7,\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        sigma = case[\"sigma\"]\n        seed = case[\"seed\"]\n\n        # --- Setup for the case ---\n        # Initialize random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Construct ground-truth and electric field arrays\n        chi_true = case[\"re_chi_true\"] + 1j * case[\"im_chi_true\"]\n        E_field = case[\"E_mag\"] * np.exp(1j * case[\"E_phase\"])\n\n        # 2. Generate noisy susceptibility\n        noise_real = rng.normal(loc=0.0, scale=sigma, size=N)\n        noise_imag = rng.normal(loc=0.0, scale=sigma, size=N)\n        eta = noise_real + 1j * noise_imag\n        chi_hat = chi_true + eta\n        \n        # --- Apply Passivity Diagnostic ---\n        \n        # 3. Check local passivity: Im{chi_hat_n} >= 0 for all n\n        im_chi_hat = chi_hat.imag\n        negative_mask = im_chi_hat  0\n        num_negative_pixels = int(np.sum(negative_mask))\n        all_imag_nonneg = (num_negative_pixels == 0)\n\n        # 4. Compute total dissipated power: P_diss >= 0\n        E_mag_sq = np.abs(E_field)**2\n        power_terms = im_chi_hat * E_mag_sq\n        P_diss_W = power_prefactor * np.sum(power_terms)\n        total_power_nonneg = (P_diss_W >= 0)\n        \n        # Round power to 12 decimal places\n        P_diss_W_rounded = round(P_diss_W, 12)\n\n        all_results.append([\n            all_imag_nonneg,\n            total_power_nonneg,\n            num_negative_pixels,\n            P_diss_W_rounded\n        ])\n    \n    # --- Format and Print Output ---\n    # Manually format the output string to match the required specifications\n    # (e.g., lowercase booleans, no spaces, specific float format)\n    case_strs = []\n    for r in all_results:\n        # Format: [bool,bool,int,float]\n        case_str = (\n            f\"[{str(r[0]).lower()},\"\n            f\"{str(r[1]).lower()},\"\n            f\"{r[2]},\"\n            f\"{f'{r[3]:.12f}'.rstrip('0').rstrip('.') if '.' in f'{r[3]:.12f}' and r[3]!=0 else f'{r[3]:.1f}' if r[3]==0 else f'{r[3]:.12f}'}]\"\n        )\n        # A bit more careful formatting to avoid trailing zeros for integers like 0.0\n        if r[3] == 0.0:\n             final_power_str = \"0.0\"\n        else:\n             final_power_str = f\"{r[3]:.12f}\"\n\n        case_str = (\n            f\"[{str(r[0]).lower()},\"\n            f\"{str(r[1]).lower()},\"\n            f\"{r[2]},\"\n            f\"{final_power_str}]\"\n        )\n        case_strs.append(case_str)\n\n    # Final format: [[...],[...],[...]]\n    final_output = f\"[{','.join(case_strs)}]\"\n    print(final_output)\n\n\nsolve()\n```", "id": "3295880"}]}