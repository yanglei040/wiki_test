{"hands_on_practices": [{"introduction": "谱元法的效率取决于避免组装和存储大型稠密单元矩阵。本实践将探讨和积分解 (sum-factorization)，这一使高阶方法在计算上具有竞争力的关键算法技术。通过计算应用旋度-旋度算子的运算量，您将发现如何利用基函数的张量积结构将计算复杂度从 $O(p^6)$ 降低到 $O(p^4)$，这是高性能谱元法实现的一个基础性结论。[@problem_id:3349976]", "problem": "考虑均匀各向同性介质中具有恒定介电常数和磁导率的频域 Maxwell 方程组，其中电场 $\\mathbf{E}$ 满足矢量 Helmholtz 形式 $\\nabla \\times \\nabla \\times \\mathbf{E} - k^{2} \\mathbf{E} = \\mathbf{J}$。重点关注在单个仿射六面体单元上，谱元法（SEM）中旋度-旋度算子 $\\nabla \\times \\nabla \\times \\mathbf{E}$ 的单元局部应用。在每个一维坐标上使用 $p$ 次的张量积 Lagrange 基，其节点为 Gauss–Lobatto–Legendre (GLL) 节点，因此每个坐标方向有 $N = p+1$ 个节点，每个单元有 $N^{3}$ 个节点。假设从参考单元到物理单元的映射是仿射的，具有恒定的几何因子和雅可比矩阵，因此度量项是恒定的，在计算主阶运算量时可以忽略。\n\n定义参考区间上具有 GLL 节点的一维节点基函数 $\\ell_{i}(\\xi)$（$i = 0,\\dots,p$），并设一维微分矩阵 $D$ 为稠密的 $(N \\times N)$ 矩阵，其元素为 $D_{\\alpha\\beta} = \\frac{\\mathrm{d}\\ell_{\\beta}}{\\mathrm{d}\\xi}$ 在节点 $\\xi_{\\alpha}$ 处的值。参考单元 $[-1,1]^{3}$ 上的三维张量积基为 $\\ell_{i}(\\xi)\\,\\ell_{j}(\\eta)\\,\\ell_{k}(\\zeta)$。离散矢量场 $\\mathbf{E}$ 有三个分量，每个分量都在同一个张量积网格上表示。考虑一种无矩阵的、单元局部的算子应用，其中所有微分和缩并都通过和因子分解法执行，即通过在张量积网格中沿固定索引的线应用一维变换，而不是形成稠密的三维矩阵。\n\n从旋度-旋度算子的弱形式和张量积基的定义出发，推导在 $N^{3}$ 个网格点上计算旋度 $\\nabla \\times \\mathbf{E}$，然后将弱形式的贡献累加回节点系数的和因子分解方案。在您的推导中，将一个一维 $(N \\times N)$ 微分矩阵应用于长度为 $N$ 的线上每次的成本视为 $N^{2}$ 次标量浮点乘加 (FMA) 运算。在首次出现时定义浮点乘加 (FMA) 运算。只计算主阶运算项，忽略所有 $O(N^{3})$ 的成本，如逐点线性组合、常数度量缩放和对角质量矩阵运算。\n\n然后，解析地比较将一个完全组装的尺寸为 $(3N^{3} \\times 3N^{3})$ 的单元局部矩阵应用于向量的朴素稠密方法的主阶运算量，与和因子分解方法的主阶运算量。最后，陈述使用和因子分解法应用旋度-旋度算子所需的每个单元主阶 FMA 运算次数的闭式表达式（用 $p$ 表示）。\n\n将您的最终答案表示为关于 $p$ 的单个闭式表达式。无需单位。无需四舍五入。", "solution": "该问题要求在谱元法（SEM）框架内，分析应用单元局部旋度-旋度算子 $\\nabla \\times \\nabla \\times (\\cdot)$ 的计算成本。我们被要求推导一种无矩阵的和因子分解方法的运算量，并将其与朴素的稠密矩阵-向量乘积进行比较，以多项式次数 $p$ 的形式给出最终成本。\n\n首先，我们确定计算工作的单位。浮点乘加（FMA）运算是一种融合运算，用于计算 $d = a \\times b + c$，并计为一次运算。\n\n问题的核心在于计算来自单个六面体单元 $\\Omega_e$ 的弱形式贡献。对于矢量测试函数 $\\mathbf{v}$ 和电场 $\\mathbf{E}$，该贡献由以下积分给出：\n$$\n\\int_{\\Omega_e} (\\nabla \\times \\mathbf{v}) \\cdot (\\nabla \\times \\mathbf{E}) \\, dV\n$$\n为了分析计算成本，我们将此积分映射到参考单元 $\\hat{\\Omega} = [-1,1]^3$。设仿射映射为 $\\mathbf{x}(\\boldsymbol{\\xi}) = F \\boldsymbol{\\xi} + \\mathbf{c}$，其中 $\\mathbf{x} = (x,y,z)$ 是物理坐标，$\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ 是参考坐标。此变换的雅可比矩阵 $J = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}}$ 是一个常数矩阵。体积微元变换为 $dV = |J| d\\hat{V}$，其中 $|J|$ 是雅可比矩阵的常数行列式。\n\n旋度算子根据关系式 $\\nabla \\times = (J^{-T} \\nabla_{\\boldsymbol{\\xi}}) \\times$ 进行变换，其中 $\\nabla_{\\boldsymbol{\\xi}}$ 是参考坐标系中的 del 算子。将此应用于矢量场 $\\mathbf{A}$，我们得到 $\\nabla \\times \\mathbf{A} = J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{A})$，因为 $J^{-T}$ 是一个常数矩阵。参考单元上的弱形式变为：\n$$\n\\int_{\\hat{\\Omega}} \\left( J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{v}) \\right) \\cdot \\left( J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}) \\right) |J| \\, d\\hat{V}\n$$\n这可以用矩阵表示法重写点积：\n$$\n|J| \\int_{\\hat{\\Omega}} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{v})^T (J^{-1} J^{-T}) (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}) \\, d\\hat{V}\n$$\n矩阵 $G = J^{-1} J^{-T}$ 包含常数度量张量分量。使用 Gauss-Lobatto-Legendre (GLL) 求积对此积分进行数值计算的过程是：在 $N^3$ 个 GLL 节点处计算被积函数的值，然后将结果与相应的求积权重相加。整个算子应用可以分解为一系列步骤。设 $\\mathbf{E}$ 的离散节点表示为系数向量 $\\underline{\\mathbf{E}}$。\n\n和因子分解方案如下：\n1.  在所有 $N^3$ 个 GLL 节点上计算参考旋度 $\\mathbf{c}_E = \\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}$。\n2.  逐点应用度量张量和求积权重：在每个节点 $(i,j,k)$ 处，计算 $\\tilde{\\mathbf{c}}_E = |J| w_{ijk} G (\\mathbf{c}_E)_{ijk}$。\n3.  将参考旋度算子的转置 $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ 应用于加权值场 $\\tilde{\\mathbf{c}}_E$，以累加得到最终的节点系数 $\\underline{\\mathbf{F}}$。\n\n问题规定我们只应计算主阶项，并忽略 $O(N^3)$ 的成本，如逐点线性组合和缩放。步骤 2 仅涉及 $N^3$ 个节点上的逐点运算，因此其成本为 $O(N^3)$，我们将其忽略。主要成本在于步骤 1 和 3。\n\n**步骤 1：计算参考旋度 $(\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E})$ 的成本**\n\n参考旋度由下式给出：\n$$\n\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E} = \\left(\\frac{\\partial E_z}{\\partial \\eta} - \\frac{\\partial E_y}{\\partial \\zeta}\\right)\\hat{\\xi} + \\left(\\frac{\\partial E_x}{\\partial \\zeta} - \\frac{\\partial E_z}{\\partial \\xi}\\right)\\hat{\\eta} + \\left(\\frac{\\partial E_y}{\\partial \\xi} - \\frac{\\partial E_x}{\\partial \\eta}\\right)\\hat{\\zeta}\n$$\n要在 $N^3$ 个节点上计算此式，我们需要计算六个偏导数的节点值：$\\frac{\\partial E_y}{\\partial \\xi}$、$\\frac{\\partial E_z}{\\partial \\xi}$、$\\frac{\\partial E_x}{\\partial \\eta}$、$\\frac{\\partial E_z}{\\partial \\eta}$、$\\frac{\\partial E_x}{\\partial \\zeta}$ 和 $\\frac{\\partial E_y}{\\partial \\zeta}$。\n\n让我们分析计算其中一个（例如 $\\frac{\\partial E_x}{\\partial \\eta}$）的成本。场分量 $E_x$ 在一个 $N \\times N \\times N$ 节点值的张量积网格上表示。使用和因子分解法，关于 $\\eta$ 的导数是通过将一维 $(N \\times N)$ 微分矩阵 $D$ 应用于沿 $\\eta$ 方向的 $N^2$ 条线上的数据来计算的。\n- 此类线的数量为 $N^2$（每个 $(\\xi_i, \\zeta_k)$ 索引对一条）。\n- 将稠密的 $N \\times N$ 矩阵 $D$ 应用于长度为 $N$ 的向量的成本为 $N^2$ 次 FMA 运算。\n- 因此，在整个三维网格上计算一个标量场（如 $E_x$）关于一个方向（如 $\\eta$）的导数的总成本为 $N^2 \\text{ 条线} \\times N^2 \\text{ FMA/线} = N^4$ FMA。\n\n由于我们需要计算 6 个这样的偏导数，步骤 1 的总成本为：\n$$\n\\text{成本}_{\\text{步骤 1}} = 6 \\times N^4 \\text{ FMA}\n$$\n根据问题的指示，形成 $\\mathbf{c}_E$ 分量的后续逐点减法是 $O(N^3)$ 运算，因此被忽略。\n\n**步骤 3：应用转置参考旋度 $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ 的成本**\n\n此步骤涉及应用步骤 1 中算子的离散转置。该操作包括应用偏导数算子的转置。例如，对 $E_x$ 的最终节点系数的贡献来自 $\\tilde{\\mathbf{c}}_E$ 中在步骤 1 中涉及 $E_x$ 导数的那些分量。此过程需要将一维微分矩阵的转置 $D^T$ 应用于相应的网格线。将一个 $N \\times N$ 矩阵 $D^T$ 应用于长度为 $N$ 的向量的成本也是 $N^2$ FMA。在微分应用的数量方面，算子 $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ 的结构与 $\\nabla_{\\boldsymbol{\\xi}} \\times$ 相同。它也需要计算 6 个类偏导数运算。\n因此，步骤 3 的成本也是：\n$$\n\\text{成本}_{\\text{步骤 3}} = 6 \\times N^4 \\text{ FMA}\n$$\n\n**总和因子分解成本**\n\n和因子分解的旋度-旋度算子应用的总主阶成本是步骤 1 和 3 的成本之和：\n$$\n\\text{成本}_{\\text{SF}} = 6 N^4 + 6 N^4 = 12 N^4 \\text{ FMA}\n$$\n\n**与朴素稠密方法的比较**\n\n在朴素方法中，会显式地形成单元局部刚度矩阵 $K_e^{curlcurl}$。\n- 矢量场 $\\mathbf{E}$ 在单元上的自由度（DoFs）数量为 每个节点 3 个分量 $\\times$ $N^3$ 个节点 = $3N^3$。\n- 稠密刚度矩阵 $K_e^{curlcurl}$ 的维度为 $(3N^3) \\times (3N^3)$。\n- 应用此算子对应于一次矩阵-向量乘积。将一个 $(3N^3 \\times 3N^3)$ 的稠密矩阵与一个长度为 $3N^3$ 的向量相乘的成本大约是 $(3N^3)^2$ 次 FMA 运算。\n$$\n\\text{成本}_{\\text{稠密}} = (3N^3)^2 = 9 N^6 \\text{ FMA}\n$$\n和因子分解方法的成本为 $12N^4$，而稠密方法的成本为 $9N^6$。成本比为 $\\text{成本}_{\\text{稠密}} / \\text{成本}_{\\text{SF}} = \\frac{9N^6}{12N^4} = \\frac{3}{4}N^2$。对于任何 $p \\ge 1$（即 $N \\ge 2$），和因子分解方法的效率要高得多，并且其优势随每个维度的节点数 $N$ 呈二次方增长。\n\n**和因子分解成本的最终表达式**\n\n问题要求用多项式次数 $p$ 表示主阶 FMA 运算次数的闭式表达式。由于 $N = p+1$，总成本为：\n$$\n\\text{成本}_{\\text{SF}} = 12 N^4 = 12 (p+1)^4\n$$", "answer": "$$\\boxed{12(p+1)^4}$$", "id": "3349976"}, {"introduction": "除了高效的算子应用，谱元法的性能还通过减小全局线性系统的规模得到极大提升。本实践将介绍静态凝聚 (static condensation)，这是一种在全局求解之前消除每个单元内部未知量的强大技术。您将从理论上推导 Nédélec 单元内部与边界自由度的标度律，然后通过编程实现来量化系统规模的显著减小，从而阐明高阶方法在解决大规模仿真问题时的一个关键优势。[@problem_id:3350015]", "problem": "考虑一个有界利普希茨域 $\\Omega \\subset \\mathbb{R}^3$ 中由麦克斯韦方程组控制的时谐电磁场。电场为 $\\mathbf{E}(\\mathbf{x})$，磁导率为 $\\mu(\\mathbf{x})$，介电常数为 $\\varepsilon(\\mathbf{x})$。在弱形式中导出旋度-旋度算子的标准假设下，该偏微分方程可简化为涉及 $\\nabla \\times \\mathbf{E}$ 和测试函数的双线性形式。采用谱元法（SEM），使用高阶张量积六面体单元，并基于由张量积多项式空间构造的Nédélec第一类单元，构建旋度协调向量空间。\n\n从弱形式和旋度协调空间的定义出发，为与旋度-旋度算子相关的离散系统推导一个静态凝聚过程。明确地将单元级矩阵划分为内部块和边界块，消去内部未知数，并形成控制边界未知数的舒尔补。然后，严格计算阶数为 $p$ 的旋度协调譜元空间中每个单元的自由度，并将其划分为内部子集和边界子集。使用这些计数结果表明，每个单元的完整系统维度按 $O(p^3)$ 比例缩放，而静态凝聚后的维度按 $O(p^2)$ 比例缩放，并解释为何这种维度降低会影响迭代求解器的性能，因为迭代求解器的单次迭代成本与未知数的数量成正比。\n\n您必须使用张量积构造来表示自由度计数。设参考六面体上的旋度协调谱元空间由形式为 $Q_{a,b,c}$ 的多项式空间构建，其维度为 $(a+1)(b+1)(c+1)$。对于三个向量分量，允许的次数三元组满足以下条件：与某个坐标方向对齐的分量，其在一个轴上的次数为 $p-1$，在另外两个轴上的次数为 $p$。从第一性原理出发，通过分析哪些基函数在单元边界上的切向迹为零，推导出每个单元的总自由度计数以及内部和边界未知数的划分。\n\n接下来，将计数扩展到一个由 $N_x \\times N_y \\times N_z$ 个六面体单元组成的结构化网格。使用网格边和面的唯一计数，为凝聚后（边界）未知数的全局数量提供公式：\n- 与$x$轴对齐的边数为 $N_x (N_y + 1) (N_z + 1)$，其他轴的表达式类似。\n- 与$x$轴正交的面数为 $(N_x + 1) N_y N_z$，其他轴的表达式类似。\n假设采用高阶Nédélec第一类构造，其中每条边承载 $p$ 个未知数，每个面承载 $2 p (p-1)$ 个切向未知数。全局完整未知数的总数等于凝聚后的未知数数量加上内部未知数的数量，其中每个单元的内部未知数数量为 $3 p (p-1)^2$，且内部未知数在单元之间不耦合。\n\n最后，实现一个完整的、可运行的程序，该程序根据给定的多项式阶数 $p$ 和网格维度 $(N_x,N_y,N_z)$ 计算以下三个量：\n- 完整系统中的未知数总数。\n- 静态凝聚系统中的未知数总数。\n- 两个总数的比值，可解释为单次迭代工作量与未知数数量呈线性关系的迭代求解器中每次迭代成本的代理指标。\n\n设计一个测试套件，包括一般情况、低阶边界情况和各向异性网格情况：\n- 情况 $1$：$p=1$, $N_x=1$, $N_y=1$, $N_z=1$。\n- 情况 $2$：$p=2$, $N_x=1$, $N_y=1$, $N_z=1$。\n- 情况 $3$：$p=4$, $N_x=2$, $N_y=2$, $N_z=2$。\n- 情况 $4$：$p=8$, $N_x=1$, $N_y=2$, $N_z=3$。\n- 情况 $5$：$p=10$, $N_x=3$, $N_y=3$, $N_z=1$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表被方括号包围，每个测试用例的结果为列表 $[N_{\\text{full}},N_{\\text{condensed}},\\text{ratio}]$。例如，整体格式必须是 $[[a_1,b_1,r_1],[a_2,b_2,r_2],\\dots]$。输出中不需要物理单位。", "solution": "该问题是有效的。这是一个在计算电磁学谱元法领域内定义明确的理论和计算练习，其基础是成熟的数学和数值原理。\n\n分析始于时谐麦克斯韦方程组的弱形式，经过离散化后得到一个线性方程组 $A\\mathbf{u}=\\mathbf{f}$。我们使用谱元法（SEM），在六面体单元网格上采用高阶旋度协调向量基函数。下文详细介绍了静态凝聚的过程、其对系统规模的影响，以及其在自由度（DoFs）计数中的实现。\n\n**静态凝聚过程**\n\n静态凝聚是一种求解线性系统的有效技术，它在全局组装之前，在单元级别上消除了未知数的一个子集。在谱元法（SEM）的背景下，每个单元内的未知数（自由度）被划分为两个集合：内部未知数（$u_I$），其基函数的支撑域仅限于该单元内部；以及边界未知数（$u_B$），其基函数的支撑域延伸到单元边界并与相邻单元共享。\n\n对于单个单元 $(e)$，其局部方程组 $A^{(e)} u^{(e)} = f^{(e)}$ 可以根据这种划分写成块形式：\n$$\n\\begin{pmatrix} A_{II}  A_{IB} \\\\ A_{BI}  A_{BB} \\end{pmatrix}\n\\begin{pmatrix} u_I \\\\ u_B \\end{pmatrix} =\n\\begin{pmatrix} f_I \\\\ f_B \\end{pmatrix}\n$$\n在这里，$A_{II}$ 表示内部自由度之间的耦合，$A_{BB}$ 表示边界自由度之间的耦合，而 $A_{IB}$ 和 $A_{BI}$（对于对称问题，$A_{BI}=A_{IB}^T$）表示内部和边界自由度之间的耦合。\n\n因为内部基函数在单元边界上的迹为零，所以它们不与任何其他单元的基函数耦合。这意味着子矩阵 $A_{II}$ 完全是单元局部的，可以独立求逆。从块系统的第一行，我们可以用边界未知数来表示内部未知数：\n$$\nA_{II} u_I + A_{IB} u_B = f_I \\implies u_I = A_{II}^{-1} (f_I - A_{IB} u_B)\n$$\n将此表达式代入块系统的第二行，即可消去 $u_I$：\n$$\nA_{BI} \\left( A_{II}^{-1} (f_I - A_{IB} u_B) \\right) + A_{BB} u_B = f_B\n$$\n重新整理各项，将涉及未知数 $u_B$ 的项归类，得到关于边界未知数的凝聚系统：\n$$\n(A_{BB} - A_{BI} A_{II}^{-1} A_{IB}) u_B = f_B - A_{BI} A_{II}^{-1} f_I\n$$\n该方程形如 $S u_B = \\hat{f}_B$，其中：\n-   $S = A_{BB} - A_{BI} A_{II}^{-1} A_{IB}$ 是舒尔补矩阵。它代表了在内部效应被“凝聚”掉之后，边界未知数的有效刚度矩阵。\n-   $\\hat{f}_B = f_B - A_{BI} A_{II}^{-1} f_I$ 是边界未知数的修正载荷向量。\n\n通过组装所有单元的舒尔补矩阵 $S^{(e)}$ 和修正载荷向量 $\\hat{f}_B^{(e)}$ 来形成全局系统。这将得到一个只涉及边界自由度的、规模小得多的全局系统。在求解全局凝聚系统得到所有 $u_B$ 之后，可以通过使用先前推导的公式进行回代，为每个单元恢复内部未知数 $u_I$。\n\n**自由度计数与渐近缩放**\n\n为了理解静态凝聚的优势，我们必须计算内部和边界自由度的数量。对于使用多项式阶数为 $p$ 的Nédélec第一类旋度协调单元的六面体单元，向量基函数 $\\mathbf{E} = (E_x, E_y, E_z)^T$ 是由张量积多项式空间构建的。在坐标为 $(\\xi_1, \\xi_2, \\xi_3)$ 的参考单元 $\\hat{K} = [-1, 1]^3$上，函数空间为：\n$$\n\\mathbf{V}_p(\\hat{K}) = \\left\\{ \\mathbf{E} \\mid E_x \\in Q_{p-1, p, p}(\\hat{K}), \\quad E_y \\in Q_{p, p-1, p}(\\hat{K}), \\quad E_z \\in Q_{p, p, p-1}(\\hat{K}) \\right\\}\n$$\n其中 $Q_{a,b,c}$ 是在 $\\xi_1$ 方向最高次数为 $a$，在 $\\xi_2$ 方向最高次数为 $b$，在 $\\xi_3$ 方向最高次数为 $c$ 的多项式空间。$Q_{a,b,c}$ 的维度是 $(a+1)(b+1)(c+1)$。\n\n每个单元的总自由度数 $N_{\\text{total,elem}}$ 是 $\\mathbf{V}_p(\\hat{K})$ 的维度：\n$$\nN_{\\text{total,elem}} = \\dim(Q_{p-1, p, p}) + \\dim(Q_{p, p-1, p}) + \\dim(Q_{p, p, p-1})\n$$\n$$\nN_{\\text{total,elem}} = (p)(p+1)(p+1) + (p+1)(p)(p+1) + (p+1)(p+1)(p) = 3p(p+1)^2\n$$\n对于大的 $p$，主导项为 $3p(p^2) = 3p^3$，因此每个单元的总自由度数按 $O(p^3)$ 比例缩放。\n\n内部自由度对应于那些在单元边界 $\\partial\\hat{K}$ 上切向迹为零的基函数。对于 $x$-分量 $E_x \\in Q_{p-1, p, p}$，若 $E_x$ 在与 $\\xi_2$ 和 $\\xi_3$ 轴正交的面上（即 $\\xi_2=\\pm 1$ 和 $\\xi_3=\\pm 1$）为零，则其在所有面上的切向分量均为零。这要求 $E_x$ 具有形式 $E_x(\\xi_1, \\xi_2, \\xi_3) = (1-\\xi_2^2)(1-\\xi_3^2) \\psi(\\xi_1, \\xi_2, \\xi_3)$。为使 $E_x$ 保持在 $Q_{p-1,p,p}$ 中，多项式 $\\psi$ 必须属于 $Q_{p-1, p-2, p-2}$。这类 $x$-分量内部基函数的数量是 $\\dim(Q_{p-1, p-2, p-2}) = p(p-1)(p-1) = p(p-1)^2$。\n根据对称性，$y$ 和 $z$ 分量的内部基函数数量也为 $p(p-1)^2$。\n每个单元的内部自由度总数 $N_{I, \\text{elem}}$ 为：\n$$\nN_{I, \\text{elem}} = 3p(p-1)^2\n$$\n对于大的 $p$，这也按 $O(p^3)$ 比例缩放。\n\n每个单元的边界自由度数 $N_{B, \\text{elem}}$ 是总自由度数与内部自由度数之差：\n$$\nN_{B, \\text{elem}} = N_{\\text{total,elem}} - N_{I, \\text{elem}} = 3p(p+1)^2 - 3p(p-1)^2\n$$\n$$\nN_{B, \\text{elem}} = 3p \\left[ (p^2+2p+1) - (p^2-2p+1) \\right] = 3p(4p) = 12p^2\n$$\n在单元级别，静态凝聚系统的维度 $N_{B, \\text{elem}}$ 按 $O(p^2)$ 比例缩放。\n\n每个单元的维度从 $O(p^3)$ 降低到 $O(p^2)$ 是非常显著的。许多迭代求解器（如共轭梯度法）的单次迭代成本主要由稀疏矩阵向量乘积决定，该操作的成本与全局系统中的未知数数量呈线性关系。通过从每个单元中消除 $O(p^3)$ 的内部未知数，静态凝聚将全局系统的规模减小到只包含 $O(p^2)$ 的边界未知数（每个单元），从而显著减少了全局求解每次迭代所需的计算工作量。\n\n**全局自由度计数**\n\n对于一个由 $N_x \\times N_y \\times N_z$ 个单元组成的结构化网格，我们可以计算完整系统和凝聚系统中的未知数总数。内部自由度是每个单元独有的，而边界自由度在公共边和面上由相邻单元共享。\n\n凝聚系统中的未知数总数 $N_{\\text{condensed}}$ 是整个网格中所有唯一边界自由度的总和。这些自由度与网格的边和面相关联。\n边数：\n-   $x$-向对齐： $N_{\\text{edges},x} = N_x (N_y + 1) (N_z + 1)$\n-   $y$-向对齐： $N_{\\text{edges},y} = N_y (N_x + 1) (N_z + 1)$\n-   $z$-向对齐： $N_{\\text{edges},z} = N_z (N_x + 1) (N_y + 1)$\n总边数： $N_{\\text{edges}} = N_{\\text{edges},x} + N_{\\text{edges},y} + N_{\\text{edges},z}$\n每条边承载 $p$ 个自由度。\n\n面数：\n-   与 $x$-轴正交： $N_{\\text{faces},x} = (N_x + 1) N_y N_z$\n-   与 $y$-轴正交： $N_{\\text{faces},y} = N_x (N_y + 1) N_z$\n-   与 $z$-轴正交： $N_{\\text{faces},z} = N_x N_y (N_z + 1)$\n总面数： $N_{\\text{faces}} = N_{\\text{faces},x} + N_{\\text{faces},y} + N_{\\text{faces},z}$\n每个面承载 $2p(p-1)$ 个切向自由度。\n\n因此，凝聚系统中的未知数总数为：\n$$\nN_{\\text{condensed}} = p \\cdot N_{\\text{edges}} + 2p(p-1) \\cdot N_{\\text{faces}}\n$$\n注意，当 $p=1$ 时，面的贡献为零，这符合预期。\n\n完整系统中的未知数总数 $N_{\\text{full}}$ 是凝聚系统未知数与所有单元中全部内部未知数的总和。\n单元总数为 $N_e = N_x N_y N_z$。\n每个单元有 $N_{I, \\text{elem}} = 3p(p-1)^2$ 个内部自由度。\n$$\nN_{\\text{full}} = N_{\\text{condensed}} + N_{I, \\text{elem}} \\cdot N_e = N_{\\text{condensed}} + 3p(p-1)^2 \\cdot (N_x N_y N_z)\n$$\n这些公式可以直接计算两种方法的系统规模。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of unknowns for full and statically condensed systems\n    in a Spectral Element Method discretization for electromagnetics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (p, Nx, Ny, Nz)\n    test_cases = [\n        (1, 1, 1, 1),\n        (2, 1, 1, 1),\n        (4, 2, 2, 2),\n        (8, 1, 2, 3),\n        (10, 3, 3, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        p, Nx, Ny, Nz = case\n\n        # Ensure integer types for calculations to avoid float precision issues\n        p, Nx, Ny, Nz = int(p), int(Nx), int(Ny), int(Nz)\n\n        # Calculate the total number of unique edges in the structured mesh\n        num_edges_x = Nx * (Ny + 1) * (Nz + 1)\n        num_edges_y = Ny * (Nx + 1) * (Nz + 1)\n        num_edges_z = Nz * (Nx + 1) * (Ny + 1)\n        total_edges = num_edges_x + num_edges_y + num_edges_z\n\n        # Calculate the total number of unique faces in the structured mesh\n        num_faces_x = (Nx + 1) * Ny * Nz\n        num_faces_y = Nx * (Ny + 1) * Nz\n        num_faces_z = Nx * Ny * (Nz + 1)\n        total_faces = num_faces_x + num_faces_y + num_faces_z\n\n        # Degrees of freedom (DoFs) per geometric entity based on polynomial order p\n        # For p=1, there are no face or interior DoFs.\n        dofs_per_edge = p\n        if p > 1:\n            dofs_per_face = 2 * p * (p - 1)\n            dofs_per_interior = 3 * p * (p - 1)**2\n        else: # p=1 case\n            dofs_per_face = 0\n            dofs_per_interior = 0\n\n        # Calculate the total number of unknowns in the statically condensed system\n        # This is the sum of boundary DoFs (on edges and faces).\n        N_condensed = (dofs_per_edge * total_edges) + (dofs_per_face * total_faces)\n\n        # Calculate the total number of unknowns in the full system\n        # This is the condensed size plus the interior DoFs for all elements.\n        num_elements = Nx * Ny * Nz\n        total_interior_dofs = dofs_per_interior * num_elements\n        N_full = N_condensed + total_interior_dofs\n        \n        # Calculate the ratio as a proxy for per-iteration cost reduction\n        # Handle the case where N_condensed could be 0, though not possible for p>=1.\n        if N_condensed > 0:\n            ratio = N_full / N_condensed\n        else:\n            ratio = 1.0 # If no boundary DoFs, full and condensed are same (e.g., size 0)\n\n        # Format results for the current test case\n        # N_full and N_condensed are integers, ratio is float\n        case_result = [N_full, N_condensed, ratio]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Example: [[12,12,1.0],[54,48,1.125]]\n    # Using str(item) handles converting lists to strings '[...]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3350015"}, {"introduction": "在实际应用中，计算效率通常需要与数值精度相权衡。本实践将探讨“变分犯罪”(variational crimes) 的概念，重点关注一种常见的做法：使用非精确积分来获得对角（或“集总”）质量矩阵。通过为一个本征值问题和散射问题编写一个谱元求解器，您将直接研究并量化这种权衡对物理结果的影响，从而深刻理解实现选择与仿真保真度之间微妙的相互作用。[@problem_id:3350051]", "problem": "考虑在单位区间 $[0,1]$ 上的无损、非磁性介质中，线性偏振场对应的麦克斯韦方程组的一维时谐简化形式。在分离变量法和假设介电常数分段光滑的条件下，电场分量 $u(x)$ 满足标量亥姆霍兹型模型。我们关注两种情况：\n\n1. 本征频率问题（具有理想导电边界的闭合腔体）：寻找角频率 $\\omega$ 和非平凡解 $u(x)$，使得\n$$\n-\\frac{d^2 u}{dx^2} = \\omega^2 \\mu_0 \\epsilon_0 \\epsilon_r(x) u \\quad \\text{在 } (0,1) \\text{ 内}, \\quad u(0)=0, \\; u(1)=0,\n$$\n其中 $\\epsilon_r(x)$ 是相对介电常数，$\\epsilon_0$ 是真空介电常数，$\\mu_0$ 是真空磁导率。使用无量纲单位，使得 $\\mu_0 \\epsilon_0 = 1$，这意味着当 $\\epsilon_r(x) \\equiv 1$ 为常数时，连续精确基频本征频率为 $\\omega_1 = \\pi$。\n\n2. 在 $(0,1)$ 上的驱动散射问题：对于给定的实数波数 $k > 0$ 和常数 $\\epsilon_r(x) \\equiv 1$，寻找满足以下条件的 $u(x)$\n$$\n-\\frac{d^2 u}{dx^2} - k^2 u = 0 \\quad \\text{在 } (0,1) \\text{ 内},\n$$\n在 $x=1$ 处采用一阶吸收边界条件，并在 $x=0$ 处施加一个单位振幅的入射平面波。相应地，使用罗宾型条件\n$$\n\\frac{du}{dx}(1) - i k u(1) = 0, \\quad \\frac{du}{dx}(0) + i k u(0) = 2 i k,\n$$\n使得在 $x=0$ 处的精确连续反射振幅为零。反射系数的离散估计取为\n$$\nR = \\frac{i k u(0) - u'(0)}{i k u(0) + u'(0)},\n$$\n我们测量 $|R|$。\n\n使用高阶谱元法（SEM）对这两个问题进行离散化，网格由 $[0,1]$ 上的 $N_e$ 个均匀单元构成，基函数为在参考区间 $[-1,1]$ 上的高斯-洛巴托-勒让德（GLL）节点 $\\{\\xi_j\\}_{j=0}^{p}$ 上构建的 $p$ 次拉格朗日基函数 $\\{\\ell_j(\\xi)\\}_{j=0}^{p}$。设单元仿射映射为 $x(\\xi) = x_e^L + \\frac{h_e}{2}(\\xi+1)$，其雅可比为 $J_e = \\frac{h_e}{2}$。标准的 $H^1$ 协调谱元法得到单元刚度矩阵和质量矩阵\n$$\nK_e = \\frac{1}{J_e} \\int_{-1}^{1} \\ell_i'(\\xi) \\ell_j'(\\xi) \\, d\\xi, \\quad\nM_e = J_e \\int_{-1}^{1} \\epsilon_r(x(\\xi)) \\ell_i(\\xi) \\ell_j(\\xi) \\, d\\xi,\n$$\n并按常规方式进行全局组装。刚度积分是次数最多为 $2p-2$ 的多项式，可由 $p+1$ 阶 GLL 求积精确积分；而质量积分涉及两个 $p$ 次多项式与一个可能非多项式的系数的乘积，是“变分犯罪”的发生之处。\n\n通过对比两种质量矩阵组装策略，研究质量矩阵中非精确求积对离散本征频率和散射振幅的影响：\n\n- 非精确 GLL 质量（变分犯罪）：在插值节点 $\\{\\xi_j\\}$ 处使用权重为 $\\{w_j^{\\mathrm{GLL}}\\}$ 的 GLL 求积来近似 $M_e$：\n$$\nM_e^{\\mathrm{GLL}} \\approx J_e \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_q)) \\ell_i(\\xi_q) \\ell_j(\\xi_q),\n$$\n对于常数 $\\epsilon_r$，这会简化为一个对角单元质量矩阵，但对于 $2p$ 次多项式而言是不精确的。\n\n- 过积分质量：使用 $q = p+1$ 个点 $\\{\\hat{\\xi}_m, \\hat{w}_m\\}_{m=1}^{q}$ 的高斯-勒让德（GL）求积来近似 $M_e$：\n$$\nM_e^{\\mathrm{OI}} \\approx J_e \\sum_{m=1}^{q} \\hat{w}_m \\epsilon_r(x(\\hat{\\xi}_m)) \\ell_i(\\hat{\\xi}_m) \\ell_j(\\hat{\\xi}_m),\n$$\n对于常数 $\\epsilon_r$（次数最高为 $2p$），这种方法能精确积分质量双线性形式，并能减少可变 $\\epsilon_r(x)$ 带来的混叠效应。\n\n在所有情况下，对刚度矩阵均使用精确的 GLL 求积：\n$$\nK_e = \\frac{1}{J_e} \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\ell_i'(\\xi_q) \\ell_j'(\\xi_q).\n$$\n\n从第一性原理出发，推导散射问题的弱形式、组装公式和边界贡献，然后实现一个程序，该程序能够：\n\n- 为两种求积策略组装全局矩阵。\n- 求解带有本质边界条件的广义本征问题 $K u = \\omega^2 M u$，以获得第一本征对。\n- 求解带有上述罗宾边界条件的驱动散射问题的线性系统，并评估离散反射振幅。\n\n提供一个包含多组参数的测试套件，以测试不同方面和边界情况。使用无量纲单位并报告无量纲结果。具体来说，计算并输出以下五个标量，作为唯一的最终结果：\n\n1. 对于 $[0,1]$ 上的常数 $\\epsilon_r(x) \\equiv 1$，使用 $N_e = 2$ 个单元和次数 $p=3$，计算使用非精确 GLL 质量得到的最小本征频率的相对误差 $\\left|\\omega_{1}^{\\mathrm{GLL}} - \\pi\\right|/\\pi$。\n\n2. 对于与第 1 项相同的设置，使用含 $q=p+1$ 个高斯-勒让德点的过积分质量，计算相对误差 $\\left|\\omega_{1}^{\\mathrm{OI}} - \\pi\\right|/\\pi$。\n\n3. 对于可变介电常数 $\\epsilon_r(x) = 1 + 0.3 \\cos(10 \\pi x)$，使用 $N_e = 8$ 和 $p=5$，计算使用非精确质量和过积分质量获得的第一本征频率之间的相对差异：$\\left|\\omega_{1}^{\\mathrm{GLL}} - \\omega_{1}^{\\mathrm{OI}}\\right| / \\left|\\omega_{1}^{\\mathrm{OI}}\\right|$。\n\n4. 对于常数 $\\epsilon_r \\equiv 1$、$N_e = 16$、$p=5$ 且波数 $k = 12 \\pi$ 的散射问题，计算使用非精确质量得到的反射系数的模 $\\left|R^{\\mathrm{GLL}}\\right|$。\n\n5. 对于与第 4 项相同的散射设置，计算使用过积分质量得到的 $\\left|R^{\\mathrm{OI}}\\right|$。\n\n角度单位为弧度。所有五个输出均为无量纲实数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5]”），结果顺序与上述描述一致。无需任何输入；所有参数均按测试套件中给定的值固定。", "solution": "用户提供了一个问题，要求在一维电磁问题的谱元法（SEM）框架内，实现并比较两种不同的质量矩阵组装策略。这些问题包括谐振腔的亥姆霍兹本征值问题和带有吸收边界条件的驱动散射问题。\n\n### I. 问题验证\n\n首先，对问题陈述进行严格验证。\n\n**第1步：提取已知条件**\n- **本征频率问题**:\n  - 控制方程: $-\\frac{d^2 u}{dx^2} = \\omega^2 \\epsilon_r(x) u$，在 $x \\in (0,1)$ 上，使用无量纲单位，其中 $\\mu_0 \\epsilon_0 = 1$。\n  - 边界条件（BCs）: $u(0)=0$, $u(1)=0$ (理想电导体)。\n  - 参考解: 当 $\\epsilon_r(x) \\equiv 1$ 时，精确基频本征频率为 $\\omega_1 = \\pi$。\n\n- **驱动散射问题**:\n  - 控制方程: $-\\frac{d^2 u}{dx^2} - k^2 u = 0$，在 $x \\in (0,1)$ 上，对于给定的波数 $k>0$ 且 $\\epsilon_r(x) \\equiv 1$。\n  - 边界条件（罗宾型）: $\\frac{du}{dx}(1) - i k u(1) = 0$ (吸收) 和 $\\frac{du}{dx}(0) + i k u(0) = 2 i k$ (入射波)。\n  - 精确解: $u(x)=e^{ikx}$，其反射系数为零。\n  - 离散反射系数: $R = \\frac{i k u(0) - u'(0)}{i k u(0) + u'(0)}$。\n\n- **SEM 离散化**:\n  - 网格: $[0,1]$ 上的 $N_e$ 个均匀单元。\n  - 基函数: 在高斯-洛巴托-勒让德（GLL）节点上的 $p$ 次拉格朗日多项式。\n  - 刚度矩阵 ($K_e$): 使用 $p+1$ 阶 GLL 求积进行精确积分。\n  - 质量矩阵 ($M_e$): 需要比较两种变体：\n    1.  **非精确 GLL 质量 ($M_e^{\\mathrm{GLL}}$)**: 通过 GLL 求积进行“质量集中”，得到一个对角矩阵。这是一种“变分犯罪”，因为该求积规则对于被积函数 $\\ell_i \\ell_j$ 是不精确的。\n    2.  **过积分质量 ($M_e^{\\mathrm{OI}}$)**: 使用含 $q=p+1$ 个点的高斯-勒让德（GL）规则进行积分，这对于常数 $\\epsilon_r$ 是精确的。\n\n- **测试套件**:\n  1.  本征问题, $\\epsilon_r \\equiv 1$, $N_e=2$, $p=3$: 计算 $\\omega_1^{\\mathrm{GLL}}$ 相对于 $\\pi$ 的相对误差。\n  2.  本征问题, $\\epsilon_r \\equiv 1$, $N_e=2$, $p=3$: 计算 $\\omega_1^{\\mathrm{OI}}$ 相对于 $\\pi$ 的相对误差。\n  3.  本征问题, $\\epsilon_r(x) = 1 + 0.3 \\cos(10 \\pi x)$, $N_e=8$, $p=5$: 计算相对差异 $|\\omega_1^{\\mathrm{GLL}} - \\omega_1^{\\mathrm{OI}}| / |\\omega_1^{\\mathrm{OI}}|$。\n  4.  散射问题, $k=12\\pi$, $N_e=16$, $p=5$: 计算 $|R^{\\mathrm{GLL}}|$。\n  5.  散射问题, $k=12\\pi$, $N_e=16$, $p=5$: 计算 $|R^{\\mathrm{OI}}|$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**: 该问题基于标量亥姆霍兹方程，这是一个从麦克斯韦方程组推导出的标准模型。本征问题和散射问题是波物理和计算电磁学中的经典问题。所有提到的数值方法（SEM、GLL/GL 求积、质量集中）都是公认的成熟方法。结论：**有效**。\n- **适定性**: 该本征问题是一个标准的斯特姆-刘维尔问题，是适定的。具有指定罗宾边界条件的散射问题也是适定的，并提供了精确解来证实这一点。它们的离散对应形式被表述为标准的广义本征值问题和线性系统问题，这些问题是可数值求解的。结论：**有效**。\n- **客观性**: 所有参数、方程和待计算量都以数学精度明确指定。语言客观，没有歧义。结论：**有效**。\n- **其他缺陷**: 该问题是完整的、一致的、计算上可行的，并且是非平凡的。它探讨了数值方法中的一个核心概念——求积误差（“变分犯罪”）对解精度的影响。\n\n**第3步：结论与行动**\n此问题是**有效的**。将提供一个完整的、合理的解决方案。\n\n### II. 推导与算法设计\n\n该解决方案需要实现一个一维、$H^1$ 协调谱元法。\n\n**1. 弱形式**\n\n*   **本征问题**：将方程 $-\\frac{d^2 u}{dx^2} = \\omega^2 \\epsilon_r(x) u$ 乘以一个来自空间 $V = H_0^1(0,1) = \\{v \\in H^1(0,1) | v(0)=v(1)=0\\}$ 的测试函数 $v$。分部积分后得到弱形式：寻找 $(\\omega^2, u) \\in (\\mathbb{R}, V)$ 使得\n    $$ a(u,v) = \\int_0^1 u' v' dx = \\omega^2 \\int_0^1 \\epsilon_r(x) u v dx = \\omega^2 m(u,v) \\quad \\forall v \\in V. $$\n    使用 $u(x) = \\sum_j u_j N_j(x)$ 进行离散化，得到广义矩阵本征值问题 $K \\mathbf{u} = \\omega^2 M \\mathbf{u}$，其中 $K_{ij} = a(N_j, N_i)$ 且 $M_{ij} = m(N_j, N_i)$。通过将问题限制在内部自由度上，来施加狄利克雷边界条件。\n\n*   **散射问题**：将方程 $-\\frac{d^2 u}{dx^2} - k^2 u = 0$ 乘以一个来自空间 $V = H^1(0,1)$ 的测试函数的共轭 $\\bar{v}$。分部积分后得到：\n    $$ \\int_0^1 u' \\bar{v}' dx - [u'\\bar{v}]_0^1 - k^2 \\int_0^1 u \\bar{v} dx = 0. $$\n    将罗宾边界条件 $u'(1) = i k u(1)$ 和 $u'(0) = -i k u(0) + 2ik$ 代入边界项 $[u'\\bar{v}]_0^1 = u'(1)\\bar{v}(1) - u'(0)\\bar{v}(0)$，得到弱形式：寻找 $u \\in V$ 使得对于所有 $v \\in V$ 都满足，\n    $$ \\underbrace{\\int_0^1 u' \\bar{v}' dx - k^2 \\int_0^1 u \\bar{v} dx - ik u(1)\\bar{v}(1) - ik u(0)\\bar{v}(0)}_{a(u,v)} = \\underbrace{-2ik\\bar{v}(0)}_{L(v)}. $$\n    离散化后得到线性系统 $A \\mathbf{u} = \\mathbf{b}$，其中 $A_{ij} = a(N_j, N_i)$ 且 $b_i = L(N_i)$。矩阵为 $A = K - k^2 M - C$，其中 $C$ 包含边界贡献。对于全局节点基 $N_j$，$C$ 是一个非零项为 $C_{0,0} = ik$ 和 $C_{N_{dof}-1, N_{dof}-1} = ik$ 的矩阵。右端向量 $\\mathbf{b}$ 只有一个非零项 $b_0 = -2ik$。\n\n**2. SEM 实现**\n\n核心组件包括：\n*   **基函数**：构建一个辅助类来管理参考区间 $[-1,1]$ 上的 $p$ 次拉格朗日基。它计算 GLL 节点、权重以及关键的微分矩阵 $D_{ij} = \\ell_j'(\\xi_i)$，这对于构建参考刚度矩阵至关重要。\n*   **矩阵组装**：通过一个循环遍历 $N_e$ 个单元中的每一个。\n    *   单元刚度矩阵通过缩放参考刚度矩阵来计算：$K_e = (1/J_e) K_{ref}$，其中 $J_e = h_e/2$ 是从 $[-1,1]$到单元的仿射映射的雅可比。\n    *   单元质量矩阵 $M_e$ 根据指定的 `mass_type` 进行计算：\n        *   `GLL`：一个对角矩阵，其元素是雅可比、GLL 权重和 GLL 节点处介电常数值的乘积。$ (M_e^{\\mathrm{GLL}})_{ii} = J_e w_i^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_i)) $。\n        *   `OI`：一个通过使用 $q=p+1$ 个高斯-勒让德点进行数值求积计算出的满矩阵，对于常数介电常数，该方法能正确地对质量项的多项式部分进行积分。$(M_e^{\\mathrm{OI}})_{ij} = J_e \\sum_{m=1}^{q} \\hat{w}_m \\epsilon_r(x(\\hat{\\xi}_m)) \\ell_i(\\hat{\\xi}_m) \\ell_j(\\hat{\\xi}_m)$。\n    *   使用标准的局部到全局索引映射，将单元矩阵添加到全局 `dof x dof` 矩阵中，其中 `dof` $= N_e p + 1$。\n\n**3. 问题求解器**\n\n*   **本征问题**：组装后，从 $K$ 和 $M$ 中移除对应于边界节点（$x=0, 1$）的行和列，以施加狄利克雷条件。使用 `scipy.linalg.eigh` 求解得到的较小的广义本征值问题。返回的最小本征值对应于 $\\omega_1^2$。\n*   **散射问题**：构建复线性系统 $A \\mathbf{u} = \\mathbf{b}$ 并使用 `numpy.linalg.solve` 求解。为了计算反射系数 $R$，需要对导数 $u'(0)$ 进行估计。这可以通过数值解 $\\mathbf{u}$ 和第一个单元的微分矩阵得到：$u'(0) = (1/J_0)\\sum_{j=0}^{p} u_j D_{0j}$，其中 $u_j$ 是 $\\mathbf{u}$ 的前 $p+1$ 个分量。\n\n这种结构化的方法确保了从底层的数学理论到 SEM 的具体实现细节，问题的各个方面都得到正确处理。", "answer": "```python\nimport numpy as np\nimport scipy.special\nimport scipy.linalg\nfrom numpy.polynomial.legendre import leggauss\n\nclass _SpectralBasis:\n    \"\"\"\n    A helper class to manage properties of 1D Lagrange polynomial basis \n    functions defined on Gauss-Lobatto-Legendre (GLL) nodes.\n    \"\"\"\n    def __init__(self, p):\n        self.p = p\n        \n        if p == 0:\n            self.nodes = np.array([-1.0])\n            self.weights = np.array([2.0])\n        else:\n            # GLL nodes are the endpoints [-1, 1] and the roots of the \n            # derivative of the degree-p Legendre polynomial, L_p'.\n            coeffs = scipy.special.legendre(p)\n            deriv_coeffs = coeffs.deriv()\n            interior_nodes = np.roots(deriv_coeffs)\n            self.nodes = np.unique(np.sort(np.concatenate(([-1.0], interior_nodes, [1.0]))))\n            \n            # GLL weights are calculated from the values of L_p at the nodes.\n            lp_vals = scipy.special.eval_legendre(p, self.nodes)\n            self.weights = 2.0 / (p * (p + 1) * lp_vals**2)\n\n        # The differentiation matrix D_ij = l_j'(xi_i) is pre-computed.\n        self.diff_matrix = self._compute_diff_matrix()\n        \n    def _compute_diff_matrix(self):\n        p, nodes = self.p, self.nodes\n        D = np.zeros((p + 1, p + 1))\n        lp_vals = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(p + 1):\n            for j in range(p + 1):\n                if i != j:\n                    D[i, j] = lp_vals[i] / (lp_vals[j] * (nodes[i] - nodes[j]))\n        \n        if p > 0:\n            D[0, 0] = -p * (p + 1) / 4.0\n            D[p, p] = p * (p + 1) / 4.0\n        return D\n\n    def lagrange_basis_at_points(self, eval_points):\n        \"\"\"Evaluates all p+1 Lagrange basis functions at a set of points.\"\"\"\n        p, nodes = self.p, self.nodes\n        L = np.ones((len(eval_points), p + 1))\n        for j in range(p + 1):\n            for i in range(len(eval_points)):\n                val = 1.0\n                for m in range(p + 1):\n                    if m != j:\n                        val *= (eval_points[i] - nodes[m]) / (nodes[j] - nodes[m])\n                L[i, j] = val\n        return L\n\ndef _run_calculation(params):\n    \"\"\"\n    Performs a single SEM calculation for a given set of parameters.\n    This function handles both eigenproblems and scattering problems.\n    \"\"\"\n    Ne, p, eps_r_func, mass_type, k = params\n    \n    basis = _SpectralBasis(p)\n    dof = Ne * p + 1\n    h = 1.0 / Ne\n    \n    K_global = np.zeros((dof, dof))\n    M_global = np.zeros((dof, dof))\n\n    # Reference element stiffness matrix (integrated exactly with GLL quadrature)\n    K_ref = basis.diff_matrix.T @ np.diag(basis.weights) @ basis.diff_matrix\n\n    # Assembly loop over elements\n    for e in range(Ne):\n        J = h / 2.0  # Jacobian of the affine map\n        x_left = e * h\n        \n        # Scale reference stiffness matrix\n        K_elem = (1.0 / J) * K_ref\n        \n        # Compute element mass matrix based on the specified strategy\n        if mass_type == 'GLL':\n            elem_nodes_x = x_left + J * (basis.nodes + 1)\n            eps_vals = eps_r_func(elem_nodes_x)\n            M_elem = J * np.diag(basis.weights * eps_vals)\n        elif mass_type == 'OI':\n            q = p + 1 # Number of quadrature points for over-integration\n            gl_nodes, gl_weights = leggauss(q)\n            \n            L_at_gl = basis.lagrange_basis_at_points(gl_nodes)\n            gl_nodes_x = x_left + J * (gl_nodes + 1)\n            eps_vals_at_gl = eps_r_func(gl_nodes_x)\n            \n            W_eps = np.diag(gl_weights * eps_vals_at_gl)\n            M_elem_ref = L_at_gl.T @ W_eps @ L_at_gl\n            M_elem = J * M_elem_ref\n        \n        # Add element contributions to global matrices\n        for i in range(p + 1):\n            for j in range(p + 1):\n                g_i, g_j = e * p + i, e * p + j\n                K_global[g_i, g_j] += K_elem[i, j]\n                M_global[g_i, g_j] += M_elem[i, j]\n    \n    # EIGENPROBLEM SOLVER\n    if k is None:\n        # Enforce u(0)=u(1)=0 by using only interior degrees of freedom\n        interior_dofs = slice(1, dof - 1)\n        K_int = K_global[interior_dofs, interior_dofs]\n        M_int = M_global[interior_dofs, interior_dofs]\n        \n        # Solve the generalized eigenvalue problem K*u = lambda*M*u\n        eigenvalues, _ = scipy.linalg.eigh(K_int, M_int)\n        omega_sq = eigenvalues[0] # Smallest eigenvalue\n        return np.sqrt(omega_sq)\n        \n    # SCATTERING PROBLEM SOLVER\n    else:\n        # Form complex system matrix A = K - k^2*M - C_boundary\n        A = (K_global - k**2 * M_global).astype(np.complex128)\n        A[0, 0] -= 1j * k\n        A[dof-1, dof-1] -= 1j * k\n        \n        # Form right-hand side vector from boundary condition\n        b = np.zeros(dof, dtype=np.complex128)\n        b[0] = -2j * k\n        \n        # Solve the linear system\n        u_sol = np.linalg.solve(A, b)\n        \n        # Calculate reflection coefficient R from the numerical solution\n        u0 = u_sol[0]\n        J0 = h / 2.0\n        D_first_row = basis.diff_matrix[0, :]\n        u_prime_0 = (1.0 / J0) * np.dot(u_sol[:p + 1], D_first_row)\n        \n        numerator = 1j * k * u0 - u_prime_0\n        denominator = 1j * k * u0 + u_prime_0\n        \n        R = numerator / denominator if np.abs(denominator) > 1e-15 else 0.\n        return np.abs(R)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the permittivity functions for the test cases\n    eps_r_const = lambda x: np.ones_like(x, dtype=float)\n    eps_r_variable = lambda x: 1.0 + 0.3 * np.cos(10 * np.pi * x)\n\n    # Define the parameter sets for the five required calculations\n    # Format: (Ne, p, eps_r_func, mass_type, k)\n    # k=None indicates an eigenproblem.\n    test_cases = [\n        # 1. Eigenproblem, GLL mass, constant eps_r\n        (2, 3, eps_r_const, 'GLL', None),\n        # 2. Eigenproblem, OI mass, constant eps_r\n        (2, 3, eps_r_const, 'OI', None),\n        # 3. Eigenproblem, variable eps_r, comparison\n        {'Ne': 8, 'p': 5, 'eps_r': eps_r_variable},\n        # 4. Scattering, GLL mass\n        (16, 5, eps_r_const, 'GLL', 12 * np.pi),\n        # 5. Scattering, OI mass\n        (16, 5, eps_r_const, 'OI', 12 * np.pi),\n    ]\n\n    results = []\n\n    # Case 1\n    omega1_gll = _run_calculation(test_cases[0])\n    results.append(np.abs(omega1_gll - np.pi) / np.pi)\n\n    # Case 2\n    omega1_oi = _run_calculation(test_cases[1])\n    results.append(np.abs(omega1_oi - np.pi) / np.pi)\n\n    # Case 3\n    params_gll = (test_cases[2]['Ne'], test_cases[2]['p'], test_cases[2]['eps_r'], 'GLL', None)\n    params_oi = (test_cases[2]['Ne'], test_cases[2]['p'], test_cases[2]['eps_r'], 'OI', None)\n    omega1_var_gll = _run_calculation(params_gll)\n    omega1_var_oi = _run_calculation(params_oi)\n    results.append(np.abs(omega1_var_gll - omega1_var_oi) / np.abs(omega1_var_oi))\n    \n    # Case 4\n    results.append(_run_calculation(test_cases[3]))\n\n    # Case 5\n    results.append(_run_calculation(test_cases[4]))\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3350051"}]}