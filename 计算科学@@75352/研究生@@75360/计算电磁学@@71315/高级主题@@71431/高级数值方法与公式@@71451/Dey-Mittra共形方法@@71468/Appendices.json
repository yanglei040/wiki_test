{"hands_on_practices": [{"introduction": "任何用于近似弯曲边界的数值方法都会引入几何误差，一个关键问题是这种误差如何随着网格的细化而变化。本练习为Dey-Mittra方法提供了核心的理论依据。通过推导其误差阶数，您将从解析上证明它相对于传统阶梯近似的优越性，并理解为何它是一种二阶精度的保形方法。[@problem_id:3298046]", "problem": "考虑一个单连通域中的时谐麦克斯韦方程组，其边界 $\\Gamma$ 为 $\\mathcal{C}^{2}$ 类的光滑理想电导体 (PEC)。设外法向单位向量为 $\\hat{\\boldsymbol{n}}$，对于 $\\Gamma$ 上的任意单位切向量 $\\hat{\\boldsymbol{t}}$，切向电场迹为 $E_{t}=\\hat{\\boldsymbol{t}}\\cdot\\boldsymbol{E}$。PEC 上的精确边界条件为 $E_{t}|_{\\Gamma}=0$。假设精确解在 $\\Gamma$ 的管状邻域内是光滑的，因此在局部法向坐标 $(s,n)$ 中（其中 $n$ 是沿 $\\hat{\\boldsymbol{n}}$ 到 $\\Gamma$ 的有符号距离），精确切向场有如下展开式\n$$\nE_{t}(s,n)=A(s)\\,n+B(s)\\,n^{2}+\\mathcal{O}(n^{3}),\n$$\n其中 $A(s)=\\partial E_{t}/\\partial n|_{\\Gamma}$ 通常是有限且非零的。\n\n假设使用间距为 $h$ 的均匀笛卡尔网格。比较两种边界表示方法：\n- 标准 Yee 时域有限差分 (FDTD) 方案中使用的阶梯状边界，记为 $\\Gamma_{\\text{stair}}$，它是由一系列与网格对齐的平面面元构成的并集，用以近似 $\\Gamma$。\n- Dey–Mittra 共形方法边界，记为 $\\Gamma_{\\text{DM}}$，它在每个被切割的单元内，用一个由 $\\Gamma$ 与网格边交点确定的平面来替换该部分 $\\Gamma$，并通过面积和长度分数来修正旋度算子（即 Dey–Mittra 共形 FDTD）。\n\n假设 $\\Gamma$ 的主曲率有界，并令 $\\kappa(s)$ 表示弧长坐标 $s$ 处的代表性曲率大小（对于一个曲面，可取 $\\kappa(s)$ 为主曲率大小的最大值）。设 $\\delta n_{\\text{stair}}(s)$ 和 $\\delta n_{\\text{DM}}(s)$ 分别表示从 $\\Gamma$ 到 $\\Gamma_{\\text{stair}}$ 和 $\\Gamma_{\\text{DM}}$ 的有符号法向偏移量，沿 $\\hat{\\boldsymbol{n}}$ 测量。仅使用：\n- PEC 边界条件，\n- $E_{t}(s,n)$ 在法向坐标下的光滑性（泰勒展开），\n- 从 $\\Gamma_{\\text{stair}}$ 和 $\\Gamma_{\\text{DM}}$ 的构造以及 $\\Gamma$ 的光滑性推断出的几何近似属性，\n推导在近似边界上施加 $E_{t}=0$ 所产生的、在真实边界上的伪切向电场关于 $h$ 的主阶标度关系。也就是说，推导下式中的阶数 $p_{\\text{stair}}$ 和 $p_{\\text{DM}}$\n$$\n\\left|E_{t}^{\\text{num}}(s,0)\\right|\\sim C_{\\text{stair}}(s)\\,h^{p_{\\text{stair}}}\n\\quad\\text{和}\\quad\n\\left|E_{t}^{\\text{num}}(s,0)\\right|\\sim C_{\\text{DM}}(s)\\,h^{p_{\\text{DM}}},\n$$\n当 $h\\to 0$ 时，其中 $C_{\\text{stair}}(s)$ 和 $C_{\\text{DM}}(s)$ 是与 $h$ 无关的系数。您的推导必须通过法向泰勒展开，明确地将几何引起的偏移量 $\\delta n_{\\text{stair}}$ 和 $\\delta n_{\\text{DM}}$ 与 $E_{t}^{\\text{num}}(s,0)$ 联系起来，并且必须从 $\\Gamma_{\\text{stair}}$ 和 $\\Gamma_{\\text{DM}}$ 的几何考虑出发，论证这些偏移量的标度关系。\n\n请以行矩阵的形式给出最终答案对 $\\left(p_{\\text{stair}},\\,p_{\\text{DM}}\\right)$。不包含单位。不需要数值取整。", "solution": "首先验证该问题是自洽的，在计算电磁学领域有科学依据，并且是适定的。所有提供的信息都是一致的，足以推导出唯一解。\n\n问题的核心是确定理想电导体 (PEC) 边界的几何表示误差如何转化为真实边界上切向电场 $E_t$ 的误差。数值方法将 PEC 边界条件 $E_t = 0$ 施加在近似边界上，而不是在真实的光滑边界 $\\Gamma$ 上。我们可以将这个近似边界通常表示为 $\\Gamma_{\\text{approx}}$。这个近似边界距离真实边界的有符号法向距离为 $n = \\delta n(s)$，其中 $s$ 是沿 $\\Gamma$ 的弧长坐标。\n\n设 $E_t^{\\text{num}}(s,n)$ 表示数值解在局部法向坐标 $(s,n)$ 中的切向电场分量。数值格式在 $\\Gamma_{\\text{approx}}$ 上强制施加边界条件，这意味着：\n$$\nE_t^{\\text{num}}(s, \\delta n(s)) = 0\n$$\n我们需要求解的是在真实边界 $\\Gamma$（对应于位置 $n=0$）上的伪切向场，即 $E_t^{\\text{num}}(s, 0)$ 的值。假设对于小的 $n$，数值解 $E_t^{\\text{num}}(s, n)$ 是法向坐标 $n$ 的一个光滑函数，我们可以写出其在 $n=0$ 附近的泰勒级数展开：\n$$\nE_t^{\\text{num}}(s, n) = E_t^{\\text{num}}(s, 0) + \\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} n + \\mathcal{O}(n^2)\n$$\n代入 $n = \\delta n(s)$ 并利用条件 $E_t^{\\text{num}}(s, \\delta n(s)) = 0$，我们得到：\n$$\n0 = E_t^{\\text{num}}(s, 0) + \\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} \\delta n(s) + \\mathcal{O}((\\delta n(s))^2)\n$$\n求解真实边界上的伪场，我们发现：\n$$\nE_t^{\\text{num}}(s, 0) = - \\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} \\delta n(s) - \\mathcal{O}((\\delta n(s))^2)\n$$\n对于一个收敛的数值格式，当网格间距 $h \\to 0$ 时，数值解及其导数应收敛于精确解及其导数。问题给出了边界附近精确场的展开式：$E_t(s,n) = A(s)n + B(s)n^2 + \\mathcal{O}(n^3)$。精确场在边界处的法向导数为 $\\partial E_t/\\partial n|_{n=0} = A(s)$。因此，我们可以用这个值来近似数值解的导数：\n$$\n\\left.\\frac{\\partial E_t^{\\text{num}}}{\\partial n}\\right|_{n=0} \\approx \\left.\\frac{\\partial E_t}{\\partial n}\\right|_{n=0} = A(s)\n$$\n问题陈述 $A(s)$ 通常是有限且非零的。因此，在主阶上，伪切向场与近似边界的几何偏移量成正比：\n$$\nE_t^{\\text{num}}(s, 0) \\approx -A(s) \\delta n(s)\n$$\n因此，误差的大小为 $|E_t^{\\text{num}}(s, 0)| \\sim |A(s)| |\\delta n(s)|$。任务简化为确定对于两种指定的边界表示方法，法向偏移量 $|\\delta n(s)|$ 关于网格间距 $h$ 的标度阶数。\n\n**阶梯法 ($\\Gamma_{\\text{stair}}$)**\n\n阶梯近似法使用一系列与笛卡尔网格坐标轴对齐的平面面元来表示光滑边界 $\\Gamma$。对于光滑边界 $\\Gamma$ 上任意一点，只要其法线方向不与网格轴完全对齐，阶梯边界 $\\Gamma_{\\text{stair}}$ 就会在局部发生位移。$\\Gamma$ 上一点与其所在网格单元各面之间的最大距离，从根本上受限于单元尺寸 $h$。法向偏移量 $\\delta n_{\\text{stair}}(s)$ 是该位移在法线方向 $\\hat{\\boldsymbol{n}}(s)$ 上的投影。除特殊情况（例如，与网格对齐的平面边界）外，在几乎所有点 $s$ 处，该偏移量都与网格间距 $h$ 同阶。\n更正式地说，从点 $P \\in \\Gamma$ 到离散边界 $\\Gamma_{\\text{stair}}$ 的距离由一个常数乘以 $h$ 为上界。因此，我们有：\n$$\n|\\delta n_{\\text{stair}}(s)| = \\mathcal{O}(h)\n$$\n这是一个一阶几何近似误差。将此标度关系代入我们的误差表达式，可得到伪切向场的标度关系：\n$$\n|E_t^{\\text{num}}(s,0)| \\sim |A(s)| |\\delta n_{\\text{stair}}(s)| = \\mathcal{O}(h)\n$$\n将其与所需形式 $|E_t^{\\text{num}}(s,0)| \\sim C_{\\text{stair}}(s) h^{p_{\\text{stair}}}$进行比较，我们确定阶梯法的精度阶数为：\n$$\np_{\\text{stair}} = 1\n$$\n\n**Dey–Mittra 共形方法 ($\\Gamma_{\\text{DM}}$)**\n\nDey–Mittra 方法提供了一种更精细的近似。在每个被边界 $\\Gamma$“切割”的网格单元内，该方法用一个平面面元 $\\Gamma_{\\text{DM}}$ 来替换 $\\Gamma$ 的弯曲段。该面元是根据真实边界 $\\Gamma$ 与网格单元边的交点来构造的。\n为了分析几何误差，考虑在 $\\Gamma$ 上某一点建立一个局部坐标系，原点在该点，一个轴与 $\\Gamma$ 相切，另一个轴与其垂直。由于 $\\Gamma$ 是 $\\mathcal{C}^2$ 类的，它可以在局部被抛物线近似。描述边界的函数形式为 $n(t) = \\frac{1}{2}\\kappa t^2 + \\mathcal{O}(t^3)$，其中 $t$ 是切向坐标，$\\kappa$ 是局部曲率。从这个角度看，Dey–Mittra 近似相当于用其弦来代替这段抛物线弧。该弦的长度为 $h$ 阶。\n一个标准的几何结论指出，抛物线弧与其弦之间的最大距离与曲率以及弦长的平方成正比。曲线 $y(x) = \\frac{1}{2}\\kappa x^2$ 与连接 $(\\pm L/2, \\frac{1}{2}\\kappa(L/2)^2)$ 的弦之间的误差在 $x=0$ 处达到最大，其值为 $\\frac{1}{8}\\kappa L^2$。由于特征长度 $L$ 与网格尺寸 $h$ 成比例，法向偏移量 $\\delta n_{\\text{DM}}(s)$ 与局部曲率 $\\kappa(s)$ 和 $h^2$ 成正比。\n$$\n|\\delta n_{\\text{DM}}(s)| = \\mathcal{O}(\\kappa(s) h^2)\n$$\n由于问题陈述曲率是有界的，这表示一个二阶几何近似误差：\n$$\n|\\delta n_{\\text{DM}}(s)| = \\mathcal{O}(h^2)\n$$\n将这个改进的几何标度关系代入场误差的表达式中：\n$$\n|E_t^{\\text{num}}(s,0)| \\sim |A(s)| |\\delta n_{\\text{DM}}(s)| = \\mathcal{O}(h^2)\n$$\n将其与形式 $|E_t^{\\text{num}}(s,0)| \\sim C_{\\text{DM}}(s) h^{p_{\\text{DM}}}$ 进行比较，我们确定 Dey–Mittra 共形方法的精度阶数为：\n$$\np_{\\text{DM}} = 2\n$$\n总而言之，施加 PEC 边界条件所产生的主导误差源于边界位置的错位。阶梯法的一阶几何误差导致一阶场误差，而 Dey-Mittra 共形方法的二阶几何误差导致二阶场误差。\n\n因此得到的阶数为 $p_{\\text{stair}}=1$ 和 $p_{\\text{DM}}=2$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2\n\\end{pmatrix}\n}\n$$", "id": "3298046"}, {"introduction": "理论上精度的提升应直接转化为对物理现象更精确的预测。在电磁学中，一个经典的测试案例就是计算谐振腔的谐振频率。这个编程练习将理论与实践联系起来，您将通过实现一个模型来量化不同边界处理方法所引入的几何误差如何导致计算出的谐振频率发生系统性偏移，从而直观地展示Dey-Mittra方法的实际优势。[@problem_id:3298105]", "problem": "考虑一个真空中的二维、无源、时谐电磁腔问题。根据麦克斯韦方程组和理想电导体（PEC）边界条件（PEC表面上的切向电场为零），单连通腔中横向电极化（$\\mathrm{TE}_z$）的平面外电场可简化为域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量狄利克雷亥姆霍兹特征问题：\n$$\n\\nabla^2 u + k^2 u = 0 \\ \\ \\text{in } \\Omega, \\qquad u=0 \\ \\ \\text{on } \\partial \\Omega,\n$$\n其中 $u$ 表示平面外电场分量，$k$ 是波数。对于半径为 $R$ 的圆形腔体，其基频波数为 $k_\\star = j_{0,1}/R$，其中 $j_{0,1}$ 是贝塞尔函数 $J_0$ 的第一个正根。对应的基频为 $f_\\star = c\\,k_\\star/(2\\pi)$，其中 $c$ 是光速。在本问题中，使用无量纲单位，设 $R=1$，并将 $c$ 视为一个在比率计算中可以消去的正常数，因此所有计算出的频率比都是无量纲的。\n\n弯曲 PEC 边界的笛卡尔时域有限差分（FDTD）Yee网格离散化会引入几何误差。标准的“阶梯状Yee”近似根据网格单元的中心点将其视为完全在腔内或完全在腔外，而 Dey–Mittra 共形方法则使用边和面上的子单元几何分数来更精确地表示真实的 PEC 边界。\n\n您的任务是，对于半径 $R=1$ 的圆形腔体，使用以下第一性原理代理模型，量化阶梯状Yee近似与Dey–Mittra式共形近似在基频计算中的系统性偏差方向（高估或低估）：\n\n1. 对于给定的均匀网格间距 $h$，用边长为 $h$ 的正方形（单元）平铺正方形区域 $[-R,R]\\times[-R,R]$。设单元中心集合为 $\\{(x_i,y_j)\\}$。\n\n2. 定义“阶梯状Yee”等效腔体面积 $A_{\\mathrm{st}}(h)$，其值为所有中心满足 $x_i^2 + y_j^2 \\le R^2$ 的单元的面积 $h^2$ 之和（如果中心在圆内，则单元完全计入，否则不计入）。定义相应的等效半径\n$$\nR_{\\mathrm{st}}(h) = \\sqrt{\\frac{A_{\\mathrm{st}}(h)}{\\pi}}.\n$$\n\n3. 定义“Dey–Mittra式”等效腔体面积 $A_{\\mathrm{dm}}(h)$，其值为每个网格单元位于圆内部分的面积分数之和。为近似计算单个边长为 $h$ 的单元的面积分数，使用 $n_s \\times n_s$ 的确定性子网格（中点采样）对该单元进行均匀子采样，并取满足 $x^2+y^2 \\le R^2$ 的子样本的比例。使用\n$$\nn_s = 12\n$$\n用于所有计算。定义\n$$\nR_{\\mathrm{dm}}(h) = \\sqrt{\\frac{A_{\\mathrm{dm}}(h)}{\\pi}}.\n$$\n\n4. 利用狄利克雷谱在均匀缩放下的尺度不变性，将两种方法的基频比近似为\n$$\nr_{\\mathrm{st}}(h) = \\frac{f_{\\mathrm{st}}(h)}{f_\\star} \\approx \\frac{R}{R_{\\mathrm{st}}(h)}, \n\\qquad\nr_{\\mathrm{dm}}(h) = \\frac{f_{\\mathrm{dm}}(h)}{f_\\star} \\approx \\frac{R}{R_{\\mathrm{dm}}(h)},\n$$\n其中 $R=1$。若值 $r>1$，表示对真实频率的高估；若值 $r  1$，表示低估。\n\n5. 对于每种方法和每个网格间距 $h$，以布尔值报告偏差方向：如果 $r>1$ 则为“高估”，如果 $r  1$ 则为“低估”。在极不可能发生的情况下，若 $r=1$（在数值公差范围内），则既不视为高估也不视为低估，并将“高估”报告为假。\n\n使用以下网格间距测试套件：\n- $h = 0.50$ （非常粗糙，边界主导区域），\n- $h = 0.25$ （粗糙），\n- $h = 0.10$ （中等），\n- $h = 0.05$ （精细）。\n\n您的程序必须为测试套件中的每个 $h$ 计算频率比对 $\\left(r_{\\mathrm{st}}(h), \\ r_{\\mathrm{dm}}(h)\\right)$，以及指示阶梯状Yee近似和Dey–Mittra式近似是否高估的相应布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为以逗号分隔的列表的列表，每个测试用例一个列表，每个测试用例中的顺序如下：\n$$\n\\left[h, \\ r_{\\mathrm{st}}(h), \\ r_{\\mathrm{dm}}(h), \\ \\mathrm{over}_{\\mathrm{st}}(h), \\ \\mathrm{over}_{\\mathrm{dm}}(h)\\right],\n$$\n其中 $h$、$r_{\\mathrm{st}}(h)$ 和 $r_{\\mathrm{dm}}(h)$ 是浮点数，而 $\\mathrm{over}_{\\mathrm{st}}(h)$ 和 $\\mathrm{over}_{\\mathrm{dm}}(h)$ 是如上定义的布尔值。整个集合必须作为Python风格的列表打印在单行上，例如：\n$$\n\\left[\\,[0.5, 1.234, 1.056, \\mathrm{True}, \\mathrm{True}], [\\dots]\\,\\right].\n$$\n\n科学真实性约束：\n- 从特征值问题出发，利用域的均匀缩放来证明使用 $r \\approx R/R_{\\mathrm{eff}}$ 的合理性。\n- 不要使用任何直接给出Dey–Mittra方法数值偏差的公式；偏差必须源于上述的几何推理。\n- 所有量都是无量纲的；输出中不需要也不允许使用物理单位。", "solution": "该问题要求分析在二维电磁腔问题中，两种不同的圆形边界数值近似方法所引入的系统性频率偏差。这两种方法是标准的阶梯状Yee网格和一种模仿Dey–Mittra技术的共形方法。该分析使用基于离散化腔体等效面积的代理模型进行。\n\n首先，我们必须证明用于近似频率比 $r = f_{\\mathrm{eff}}/f_\\star \\approx R/R_{\\mathrm{eff}}$ 的模型的合理性。腔体的谐振模式由标量狄利克雷亥姆霍兹特征问题决定：\n$$\n\\nabla^2 u + k^2 u = 0 \\ \\ \\text{in } \\Omega, \\qquad u=0 \\ \\ \\text{on } \\partial \\Omega\n$$\n此处，$k$ 是波数，在域 $\\Omega$ 上带有狄利克雷边界条件的负拉普拉斯算子 $-\\nabla^2$ 的特征值为 $\\lambda_n = k_n^2$。对于半径为 $R$ 的圆形域 $\\Omega_\\star$，基频波数为 $k_\\star = \\sqrt{\\lambda_1(\\Omega_\\star)}$。\n\n让我们考虑一个均匀缩放的域 $\\Omega' = \\alpha \\Omega_\\star$。对于 $\\Omega'$ 中的一个点 $\\mathbf{x}'$，可以写成 $\\mathbf{x}' = \\alpha \\mathbf{x}$，其中 $\\mathbf{x} \\in \\Omega_\\star$。梯度算子的变换关系为 $\\nabla_{\\mathbf{x}'} = (1/\\alpha)\\nabla_{\\mathbf{x}}$，因此拉普拉斯算子的缩放关系为 $\\nabla_{\\mathbf{x}'}^2 = (1/\\alpha^2)\\nabla_{\\mathbf{x}}^2$。缩放域 $\\Omega'$ 上的特征问题是 $\\nabla_{\\mathbf{x}'}^2 v + (k')^2 v = 0$。代入缩放后的拉普拉斯算子，我们得到 $(1/\\alpha^2)\\nabla_{\\mathbf{x}}^2 v + (k')^2 v = 0$，这等价于 $\\nabla_{\\mathbf{x}}^2 v + (\\alpha k')^2 v = 0$。为了使 $\\Omega'$ 上的特征函数 $v$ 与 $\\Omega_\\star$ 上的特征函数 $u$ 相对应，其特征值必须相同。因此，$(\\alpha k')^2 = k_\\star^2$，这意味着缩放域上的波数为 $k' = k_\\star / \\alpha$。\n\n数值方法实际上是用一个面积为 $A_{\\mathrm{eff}}$ 的等效域 $\\Omega_{\\mathrm{eff}}$ 来代替半径为 $R$、面积为 $A_\\star = \\pi R^2$ 的真实圆形域 $\\Omega_\\star$。我们将此等效域建模为一个等效半径为 $R_{\\mathrm{eff}} = \\sqrt{A_{\\mathrm{eff}}/\\pi}$ 的圆。因此，真实域与等效域之间的线性缩放因子为 $\\alpha \\approx R_{\\mathrm{eff}}/R$。\n\n使用上面推导的缩放关系，等效域的波数 $k_{\\mathrm{eff}}$ 与真实基频波数 $k_\\star$ 的关系为 $k_{\\mathrm{eff}} \\approx k_\\star / \\alpha = k_\\star (R/R_{\\mathrm{eff}})$。由于谐振频率 $f$ 与波数 $k$ 成正比（通过 $f = ck/(2\\pi)$），数值近似频率 $f_{\\mathrm{eff}}$ 与真实基频 $f_\\star$ 的比值为：\n$$\nr(h) = \\frac{f_{\\mathrm{eff}}(h)}{f_\\star} = \\frac{k_{\\mathrm{eff}}(h)}{k_\\star} \\approx \\frac{R}{R_{\\mathrm{eff}}(h)}\n$$\n鉴于问题指定 $R=1$，该比率简化为 $r(h) \\approx 1/R_{\\mathrm{eff}}(h)$。$r(h)>1$ 的值表示对频率的高估，而 $r(h)  1$ 的值表示低估。\n\n任务的核心是计算给定网格间距 $h$ 的等效面积 $A_{\\mathrm{st}}(h)$ 和 $A_{\\mathrm{dm}}(h)$。分析在正方形域 $[-R, R] \\times [-R, R]$（即 $[-1, 1] \\times [-1, 1]$）上进行，该域由边长为 $h$ 的正方形单元平铺而成。\n\n对于阶梯状Yee近似，等效面积 $A_{\\mathrm{st}}(h)$ 是所有中心 $(x_i, y_j)$ 位于真实圆内的单元的面积之和。算法如下：\n1.  生成一个覆盖正方形 $[-1, 1] \\times [-1, 1]$、均匀间距为 $h$ 的单元中心网格 $(x_i, y_j)$。\n2.  对每个中心，检查其是否满足条件 $x_i^2 + y_j^2 \\le R^2 = 1$。\n3.  统计圆内的中心数量 $N_{\\mathrm{inside}}$。\n4.  总等效面积为 $A_{\\mathrm{st}}(h) = N_{\\mathrm{inside}} \\times h^2$。\n\n对于Dey–Mittra式共形近似，等效面积 $A_{\\mathrm{dm}}(h)$ 通过对面积分数求和得到。问题指定了一种确定性的子采样方法来计算这些分数。一种高效的等效方法是构建一个更精细的网格并执行类似的计数程序。\n1.  定义子网格间距 $\\delta = h/n_s$，其中子采样因子给定为 $n_s = 12$。\n2.  生成一个覆盖正方形 $[-1, 1] \\times [-1, 1]$、间距为 $\\delta$ 的精细子单元中心网格。\n3.  统计位于真实圆内的子单元中心数量 $N_{\\mathrm{sub,inside}}$，即满足 $x^2+y^2 \\le R^2=1$ 的中心数量。\n4.  总等效面积是这些包含在内的子单元的面积之和：$A_{\\mathrm{dm}}(h) = N_{\\mathrm{sub,inside}} \\times \\delta^2$。这在数学上等同于对原始较粗单元的面积分数求和。\n\n对于这两种方法，一旦计算出等效面积 $A_{\\mathrm{eff}}(h)$，就按如下方式计算相应的等效半径 $R_{\\mathrm{eff}}(h)$、频率比 $r(h)$ 和高估布尔值 $\\mathrm{over}(h)$：\n$$\nR_{\\mathrm{eff}}(h) = \\sqrt{\\frac{A_{\\mathrm{eff}}(h)}{\\pi}}\n$$\n$$\nr(h) = \\frac{1}{R_{\\mathrm{eff}}(h)}\n$$\n$$\n\\mathrm{over}(h) = (r(h)  1)\n$$\n对所提供的测试套件 $\\{0.50, 0.25, 0.10, 0.05\\}$ 中的每个网格间距 $h$ 重复此整个过程。因为这两种方法都是通过计算中心在内的网格对齐正方形来近似一个凸形（圆形），所以得到的面积将是对真实面积 $\\pi R^2$ 的低估。因此，$A_{\\mathrm{eff}}  \\pi$，导致 $R_{\\mathrm{eff}}  1$ 和 $r  1$。因此，我们预计两种方法都会持续高估基频，而Dey–Mittra式方法产生的误差要小得多。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the frequency bias of staircased vs. conformal approximations\n    for a circular cavity using an effective area model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.50, 0.25, 0.10, 0.05]\n\n    # Define problem constants.\n    R = 1.0\n    R_sq = R**2\n    ns = 12 # Subsampling factor for Dey-Mittra-style method\n\n    results = []\n    for h in test_cases:\n        # --- Staircased Yee Method ---\n        # Generate cell centers for the grid of spacing h.\n        centers = np.arange(-R + h / 2.0, R, h)\n        \n        # Check if the grid has any points to avoid errors with large h.\n        if centers.size > 0:\n            X_c, Y_c = np.meshgrid(centers, centers)\n            # Calculate squared distance from origin for each center.\n            D2_c = X_c**2 + Y_c**2\n            # Count centers inside the circle.\n            N_inside_st = np.sum(D2_c = R_sq)\n            # Calculate effective area.\n            A_st = N_inside_st * h**2\n        else:\n            A_st = 0.0\n        \n        # Calculate frequency ratio from effective area.\n        if A_st > 1e-12: # Avoid division by zero\n            R_st = np.sqrt(A_st / np.pi)\n            r_st = 1.0 / R_st\n        else:\n            r_st = np.inf\n        \n        # Determine bias direction.\n        over_st = r_st > 1.0\n\n        # --- Dey-Mittra-style Conformal Method ---\n        # Define sub-grid spacing.\n        delta = h / float(ns)\n        # Generate sub-cell centers.\n        sub_centers = np.arange(-R + delta / 2.0, R, delta)\n        \n        if sub_centers.size > 0:\n            X_s, Y_s = np.meshgrid(sub_centers, sub_centers)\n            # Calculate squared distance from origin for each sub-center.\n            D2_s = X_s**2 + Y_s**2\n            # Count sub-centers inside the circle.\n            N_inside_dm = np.sum(D2_s = R_sq)\n            # Calculate effective area.\n            A_dm = N_inside_dm * delta**2\n        else:\n            A_dm = 0.0\n\n        # Calculate frequency ratio from effective area.\n        if A_dm > 1e-12: # Avoid division by zero\n            R_dm = np.sqrt(A_dm / np.pi)\n            r_dm = 1.0 / R_dm\n        else:\n            r_dm = np.inf\n            \n        # Determine bias direction.\n        over_dm = r_dm > 1.0\n\n        results.append([h, r_st, r_dm, over_st, over_dm])\n\n    # Final print statement in the exact required format.\n    # The template uses str(results), which has spaces. Let's make it match that.\n    # str(list) automatically adds spaces after commas.\n    # map(str, results) converts each sublist to its string representation.\n    # ','.join(...) joins these strings with a comma.\n    # The outer f-string adds the final brackets.\n    # This exactly reproduces the format: [[...],[...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3298105"}, {"introduction": "在实现一种数值方法后，验证其是否达到了理论上的收敛阶数至关重要。“补丁测试”（patch test）是实现这一目标的一种标准而强大的技术，它通常使用一个精确构造的解析解。这个高级练习将指导您完成一个专业级的验证过程，通过构建一个局部补丁测试，您将学习如何严格地检验Dey-Mittra方法的实现是否在离散形式下精确满足麦克斯韦方程组，并达到二阶精度。[@problem_id:3298002]", "problem": "考虑均匀、各向同性自由空间中的三维麦克斯韦方程组的积分形式，其介电常数为 $\\epsilon$，磁导率为 $\\mu$。在角频率为 $\\omega$ 的相量频域中，法拉第定律在一个边界为 $\\partial \\mathcal{S}$ 的光滑开曲面 $\\mathcal{S}$ 上表示为\n$$\n\\oint_{\\partial \\mathcal{S}} \\mathbf{E} \\cdot d\\boldsymbol{\\ell} \\;=\\; -\\,i\\,\\omega\\,\\mu \\int_{\\mathcal{S}} \\mathbf{H}\\cdot \\mathbf{n}_{\\mathcal{S}}\\, dS,\n$$\n其中 $\\mathbf{n}_{\\mathcal{S}}$ 是 $\\mathcal{S}$ 的单位法向量，$i$ 是虚数单位。我们关注时域有限差分 (FDTD) 框架中，在单个被切割元胞上，针对 Dey–Mittra 共形方法的局部片元检验。Dey–Mittra (DM) 方法修改了被理想电导体 (PEC) 部分切割的 Yee 元胞边和面的几何量（长度和面积），同时将场自由度保持在规范的 Yee 位置上。PEC 边界条件强制切向电场在导体表面上为零，因此内部导体边界对环路积分的贡献为零。\n\n您将构建一个构造的时谐平面波解，该解精确满足麦克斯韦旋度方程，并在切割平面上强制满足 PEC 切向电场条件。设 $\\mathbf{n}$ 为 PEC 平面的固定单位法向量，$\\mathbf{k}$ 为满足 $\\mathbf{k}\\cdot \\mathbf{n} = 0$ 的波矢量，自由空间参数的选择使得 $|\\mathbf{k}| = \\omega \\sqrt{\\mu\\,\\epsilon}$。定义相量场\n$$\n\\mathbf{E}(\\mathbf{r}) \\;=\\; E_0\\, e^{\\,i\\,\\mathbf{k}\\cdot\\mathbf{r}}\\, \\mathbf{n}, \\qquad\n\\mathbf{H}(\\mathbf{r}) \\;=\\; \\frac{1}{\\mu\\,\\omega}\\, \\mathbf{k}\\times \\mathbf{E}(\\mathbf{r}),\n$$\n其中 $E_0$ 为实数振幅。只要 $|\\mathbf{k}| = \\omega \\sqrt{\\mu \\epsilon}$ 且 $\\mathbf{k}\\cdot \\mathbf{E} = 0$，这些场就满足 $\\nabla\\times \\mathbf{E} = -\\,i\\,\\omega\\,\\mu\\,\\mathbf{H}$ 和 $\\nabla\\times \\mathbf{H} = i\\,\\omega\\,\\epsilon\\,\\mathbf{E}$。后一个条件得到保证，因为 $\\mathbf{E}$ 平行于 $\\mathbf{n}$ 且 $\\mathbf{k}\\cdot \\mathbf{n} = 0$。由于 $\\mathbf{E}$ 平行于 $\\mathbf{n}$，因此 $\\mathbf{E}$ 在 PEC 平面上的切向分量为零，满足 PEC 条件。\n\n在一个尺寸为 $h$ 的立方体元胞位于 $z = 0$ 处的单个 Yee 面 $\\mathcal{S}_z$ 上进行计算，因此 $\\mathcal{S}_z = \\{(x,y,0)\\,:\\,0\\le x\\le h,\\,0\\le y\\le h\\}$，其边界 $\\partial \\mathcal{S}_z$ 由四条坐标轴对齐的边构成，按逆时针方向定向（根据右手定则，$\\mathbf{n}_{\\mathcal{S}} = \\hat{\\mathbf{z}}$）。一个平面法向量为 $\\mathbf{n}$、平面参数为 $d$ 的 PEC 半空间切割该元胞；$\\mathcal{S}_z$ 的开放（非导电）部分是通过半空间 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 在 $z=0$ 处对正方形 $[0,h]\\times[0,h]$ 进行裁剪后得到的多边形。类似地，每条边界边在满足相同半空间不等式的地方是部分开放的。\n\n定义 Dey–Mittra 离散几何量如下：\n- 对于 $\\partial \\mathcal{S}_z$ 的每条有向边 $e$，其开放长度 $L_e$ 是满足 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 的线段的长度。DM 线积分近似使用开放线段上切向电场的中点值，即\n$$\nI_{\\mathrm{DM}}^{(e)} \\;=\\; \\left(\\mathbf{E}(\\mathbf{r}_{e,\\mathrm{mid}})\\cdot \\mathbf{t}_e\\right)\\, L_e,\n$$\n其中 $\\mathbf{t}_e$ 是与 $\\partial \\mathcal{S}_z$ 方向一致的边 $e$ 的单位切向量，$\\mathbf{r}_{e,\\mathrm{mid}}$ 是 $e$ 的开放线段的中点。\n- 对于面积为 $A_{\\mathcal{P}}$ 的开放多边形 $\\mathcal{P}\\subset \\mathcal{S}_z$，DM 磁通量近似使用法向磁场的形心值，\n$$\n\\Phi_{\\mathrm{DM}} \\;=\\; \\left(\\mathbf{H}(\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}})\\cdot \\hat{\\mathbf{z}}\\right)\\, A_{\\mathcal{P}}.\n$$\n\n在被切割面上，法拉第定律的 DM 残差是一个复数\n$$\nR(h;\\mathbf{n},d,\\mathbf{k}) \\;=\\; \\sum_{e\\subset \\partial \\mathcal{S}_z} I_{\\mathrm{DM}}^{(e)} \\;+\\; i\\,\\omega\\,\\mu\\, \\Phi_{\\mathrm{DM}}.\n$$\n对于上述构造解和平面 PEC 表面，由于沿内部切割线段的 PEC 切向条件和精确的麦克斯韦积分关系，精确残差为零。因此，DM 残差的模 $|R|$ 衡量了局部的 DM 一致性误差。如果 $|R| = \\mathcal{O}(h^2)$，则称 DM 方法在此片元上以二阶精度再现了积分关系。\n\n您的任务是实现一个程序，该程序：\n- 对于给定的 $\\mathbf{n}$、$d$、$\\mathbf{k}$ 和 $h$，计算开放边的长度 $L_e$、中点位置 $\\mathbf{r}_{e,\\mathrm{mid}}$、被裁剪的开放多边形 $\\mathcal{P}$、其面积 $A_{\\mathcal{P}}$ 和形心 $\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}}$。\n- 对三个逐次减半的网格尺寸 $h$ 序列，计算 $R(h;\\mathbf{n},d,\\mathbf{k})$ 及其模 $|R|$。\n- 通过计算成对的比率来估计观测到的阶数 $p$\n$$\np_1 \\;=\\; \\frac{\\ln\\left(|R(h_1)|/|R(h_2)|\\right)}{\\ln\\left(h_1/h_2\\right)}, \\qquad\np_2 \\;=\\; \\frac{\\ln\\left(|R(h_2)|/|R(h_3)|\\right)}{\\ln\\left(h_2/h_3\\right)},\n$$\n并返回保守估计值 $\\min(p_1,p_2)$。\n\n使用以下参数集的测试套件，每个测试集包含三个网格尺寸 $h\\in\\{\\,h_1, h_2, h_3\\,\\}$，其中 $h_1 = 0.2$，$h_2 = 0.1$，$h_3 = 0.05$：\n- 测试 A (一般斜向切割)：$\\mathbf{n} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v} = (0.8,\\,0.6,\\,0.3)$，$d = \\alpha h$，其中 $\\alpha = 0.7$，平面波振幅 $E_0 = 1$，自由空间参数 $\\mu = 1$，$\\epsilon = 1$，且 $|\\mathbf{k}| = \\omega \\sqrt{\\mu \\epsilon}$，其中 $|\\mathbf{k}| = k_0 = 5.0$。选择垂直于 $\\mathbf{n}$ 且 $\\mathbf{k}\\times \\mathbf{n}$ 的 $z$ 分量不为零的 $\\mathbf{k}$。\n- 测试 B (近角点切割)：$\\mathbf{n} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v} = (0.8,\\,0.6,\\,0.1)$，$d = \\alpha h$，其中 $\\alpha = 0.1$，$E_0 = 1$，$\\mu = 1$，$\\epsilon = 1$，且 $k_0 = 7.0$，选择 $\\mathbf{k}\\perp \\mathbf{n}$ 以使得 $(\\mathbf{k}\\times \\mathbf{n})\\cdot \\hat{\\mathbf{z}}\\neq 0$。\n- 测试 C (面上无切割；完全开放)：$\\mathbf{n} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v} = (0.3,\\,0.4,\\,0.5)$，$d = \\alpha h$，其中 $\\alpha = 1.5$，$E_0 = 1$，$\\mu = 1$，$\\epsilon = 1$，且 $k_0 = 3.0$，选择 $\\mathbf{k}\\perp \\mathbf{n}$ 如上。\n\n所有量均为无量纲，角度以弧度为单位。您的程序必须：\n- 实现对正方形 $[0,h]\\times[0,h]$ 在 $z=0$ 处按半空间 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 进行的稳健多边形裁剪。\n- 对每个测试，为 $h\\in\\{\\,0.2,\\,0.1,\\,0.05\\,\\}$ 计算 DM 残差的模 $|R|$。\n- 对每个测试用例，按所述方法计算并报告保守的观测阶数 $\\min(p_1,p_2)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，按测试 A、B、C 的顺序给出结果，即 $\\big[ p_{\\mathrm{A}}, p_{\\mathrm{B}}, p_{\\mathrm{C}} \\big]$，其中每个 $p$ 是一个浮点数。", "solution": "用户要求实现一个程序，以数值方式验证电磁学中 Dey-Mittra (DM) 共形方法的精度阶数。这涉及在一个被切割的元胞面上，使用一个构造的平面波解进行片元检验。该问题是适定的且科学上合理的，为几何、物理和数值分析提供了明确的指令集。我们将按详细的、分步的方案进行求解。\n\n问题的核心是为一系列递减的网格尺寸 $h$ 计算 DM 残差 $R$，然后使用这些残差来估计方法的收敛阶数 $p$。残差定义为：\n$$\nR(h;\\mathbf{n},d,\\mathbf{k}) \\;=\\; \\sum_{e\\subset \\partial \\mathcal{S}_z} I_{\\mathrm{DM}}^{(e)} \\;+\\; i\\,\\omega\\,\\mu\\, \\Phi_{\\mathrm{DM}}\n$$\n此表达式代表法拉第电磁感应定律的离散形式。第一项是电场 $\\mathbf{E}$ 沿元胞面边界开放部分的离散线积分，第二项是磁场 $\\mathbf{H}$ 穿过元胞面开放区域的磁通量的离散时间导数。对于理想电导体 (PEC) 域上的精确解，此表达式的解析值为零。因此，数值近似的非零值 $R$ 代表了 DM 方案的局部截断误差。如果模 $|R|$ 的缩放关系为 $\\mathcal{O}(h^p)$，则 $p$ 为精度阶数。\n\n求解过程可分为三个主要部分：\n1.  **几何处理**：对于给定的元胞尺寸 $h$ 和由 $\\mathbf{n}\\cdot \\mathbf{r} = d$ 定义的切割平面，我们必须确定未被 PEC 占据的“开放”区域的几何形状。这涉及将位于 $z=0$ 的方形元胞面 $[0,h]\\times[0,h]$ 与半空间 $\\mathbf{n}\\cdot \\mathbf{r} \\le d$ 进行裁剪。这将产生一个凸多边形 $\\mathcal{P}$。我们需要计算其面积 $A_{\\mathcal{P}}$ 和形心 $\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}}$。我们还必须确定正方形四个边界边中每条边的开放线段的长度 $L_e$ 和中点 $\\mathbf{r}_{e,\\mathrm{mid}}$。\n2.  **场值计算与离散化**：我们使用提供的电场和磁场 $\\mathbf{E}(\\mathbf{r})$ 和 $\\mathbf{H}(\\mathbf{r})$ 的构造平面波解。在几何步骤中确定的特定点（边中点和多边形形心）上对这些场进行求值，以计算线积分 $I_{\\mathrm{DM}}^{(e)}$ 和磁通量 $\\Phi_{\\mathrm{DM}}$ 的 DM 近似。\n3.  **残差与阶数计算**：将离散项组合成复数残差 $R$。我们对三个网格尺寸（$h_1=0.2$、$h_2=0.1$、$h_3=0.05$）重复此过程，以获得三个残差模 $|R_1|, |R_2|, |R_3|$。然后使用公式 $p = \\log_{h_1/h_2} (|R_1|/|R_2|)$ 成对地估计收敛阶数。对每个测试用例，报告保守估计值 $\\min(p_1, p_2)$。\n\n现在我们将详细说明实现步骤。\n\n**步骤 1：设置与参数定义**\n对于每个测试用例，我们首先确定物理和几何常数。材料参数为 $\\mu=1$ 和 $\\epsilon=1$。平面波振幅为 $E_0=1$。角频率 $\\omega$ 等于波数大小 $k_0=|\\mathbf{k}|$，因为 $\\omega = |\\mathbf{k}| / \\sqrt{\\mu\\epsilon}$。切割平面法向量 $\\mathbf{n}$ 通过对给定向量 $\\mathbf{v}$ 进行归一化得到。波矢量 $\\mathbf{k}$ 必须满足 $\\mathbf{k}\\cdot\\mathbf{n}=0$ 和 $(\\mathbf{k}\\times\\mathbf{n})\\cdot\\hat{\\mathbf{z}} \\ne 0$。一个满足这些条件的确定性选择是将 $\\mathbf{k}$ 设置为与 $\\hat{\\mathbf{z}} \\times \\mathbf{n}$ 成比例。该向量保证与 $\\mathbf{n}$ 正交。只要 $\\mathbf{n}$ 不平行于 $\\hat{\\mathbf{z}}$（所有测试用例中都如此），该向量就非零，并且条件 $(\\mathbf{k}\\times\\mathbf{n})\\cdot\\hat{\\mathbf{z}} \\ne 0$ 也得到满足。因此我们定义 $\\mathbf{k} = k_0 \\, (\\hat{\\mathbf{z}} \\times \\mathbf{n}) / \\|\\hat{\\mathbf{z}} \\times \\mathbf{n}\\|$。\n\n**步骤 2：几何计算**\n这是实现中最复杂的部分。\n- **多边形裁剪**：开放多边形 $\\mathcal{P}$ 是方形元胞面 $\\mathcal{S}_z$ 和半空间 $\\mathbf{n}\\cdot\\mathbf{r} \\le d$ 的交集。在 $z=0$ 处，这简化为用半平面 $n_x x + n_y y \\le d$ 裁剪二维正方形 $[0,h]\\times[0,h]$。我们使用 Sutherland-Hodgman 算法，该算法非常适合用凸多边形（我们的正方形）对凸裁剪区域（半平面）进行裁剪。该算法遍历正方形的各条边，为裁剪后的多边形生成一个新的顶点列表。\n- **多边形面积和形心**：给定裁剪后多边形 $\\mathcal{P}$ 的有序顶点，我们使用多边形形状的标准公式计算其面积 $A_{\\mathcal{P}}$ 和形心 $\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}}$。面积通过鞋带公式计算：$A = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)$。形心分量为 $C_x = \\frac{1}{6A} \\sum_{i=0}^{N-1} (x_i + x_{i+1})(x_i y_{i+1} - x_{i+1} y_i)$ 和 $C_y = \\frac{1}{6A} \\sum_{i=0}^{N-1} (y_i + y_{i+1})(x_i y_{i+1} - x_{i+1} y_i)$。对于面积接近于零的情况需要特别处理。\n- **边裁剪**：对于正方形的四个边界边中的每一条（参数化为 $t \\in [0,1]$），条件 $\\mathbf{n}\\cdot\\mathbf{r}(t) \\le d$ 定义了一个与开放线段相对应的子区间 $[t_{start}, t_{end}]$。开放长度为 $L_e = (t_{end} - t_{start})h$，中点对应于 $t_{mid} = (t_{start} + t_{end})/2$。\n\n**步骤 3：计算 DM 残差**\n在确定所有几何量后，我们计算残差 $R$ 的两个项：\n- **线积分求和**：对于每条边 $e$，我们计算 $I_{\\mathrm{DM}}^{(e)} = (\\mathbf{E}(\\mathbf{r}_{e,\\mathrm{mid}})\\cdot \\mathbf{t}_e)\\, L_e$。电场是一个复矢量，由 $\\mathbf{E}(\\mathbf{r}) = E_0 e^{i\\mathbf{k}\\cdot\\mathbf{r}} \\mathbf{n}$ 给出。求和 $\\sum_e I_{\\mathrm{DM}}^{(e)}$ 是一个复数。\n- **磁通量项**：我们计算 $\\Phi_{\\mathrm{DM}} = (\\mathbf{H}(\\mathbf{r}_{\\mathcal{P},\\mathrm{centroid}})\\cdot \\hat{\\mathbf{z}})\\, A_{\\mathcal{P}}$。磁场为 $\\mathbf{H}(\\mathbf{r}) = \\frac{1}{\\mu\\omega}\\mathbf{k}\\times \\mathbf{E}(\\mathbf{r}) = \\frac{E_0}{\\mu\\omega} e^{i\\mathbf{k}\\cdot\\mathbf{r}} (\\mathbf{k}\\times \\mathbf{n})$。然后将此项乘以 $i\\omega\\mu$。\n\n**步骤 4：估计收敛阶数**\n对每个网格尺寸 $h \\in \\{0.2, 0.1, 0.05\\}$ 执行上述步骤。这将产生一个包含三个残差模的列表 $|R(h_1)|$、 $|R(h_2)|$、 $|R(h_3)|$。然后我们计算两个成对的阶数估计：\n$$\np_1 \\;=\\; \\frac{\\ln(|R(h_1)|/|R(h_2)|)}{\\ln(h_1/h_2)}, \\qquad p_2 \\;=\\; \\frac{\\ln(|R(h_2)|/|R(h_3)|)}{\\ln(h_2/h_3)}\n$$\n由于 $h_{i+1}=h_i/2$，每种情况下的分母都是 $\\ln(2)$。每个测试用例的最终报告值为 $\\min(p_1, p_2)$，提供了收敛阶数的保守估计。整个过程在下面的 Python 程序中自动化实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed order of convergence for the Dey-Mittra method\n    on a single cut-cell face for three different test cases.\n    \"\"\"\n\n    # --- Geometric Helper Functions ---\n\n    def clip_polygon(subject_polygon, n_xy, d_plane):\n        \"\"\"Clips a convex polygon against a half-plane using Sutherland-Hodgman.\"\"\"\n        output_list = []\n        if not subject_polygon:\n            return []\n        \n        tol = 1e-14\n        \n        S = subject_polygon[-1]\n        s_val = np.dot(n_xy, S) - d_plane\n        \n        for E in subject_polygon:\n            e_val = np.dot(n_xy, E) - d_plane\n            \n            s_inside = s_val = tol\n            e_inside = e_val = tol\n\n            # Calculate intersection point if edge crosses the boundary\n            if abs(s_val - e_val) > tol:\n                t = s_val / (s_val - e_val)\n                intersection_point = S + t * (E - S)\n            else: # Edge is parallel to the clipping line\n                intersection_point = None\n\n            if e_inside:\n                if not s_inside:\n                    if intersection_point is not None:\n                        output_list.append(intersection_point)\n                output_list.append(E)\n            elif s_inside:\n                if intersection_point is not None:\n                    output_list.append(intersection_point)\n            \n            S = E\n            s_val = e_val\n        return output_list\n\n    def polygon_area(vertices):\n        \"\"\"Calculates the signed area of a polygon using the shoelace formula.\"\"\"\n        if len(vertices)  3:\n            return 0.0\n        area = 0.0\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            area += p1[0] * p2[1] - p2[0] * p1[1]\n        return area / 2.0\n\n    def polygon_centroid(vertices, area):\n        \"\"\"Calculates the centroid of a polygon.\"\"\"\n        if len(vertices)  3 or abs(area) = 1e-14:\n            if len(vertices) > 0:\n                return sum(vertices) / len(vertices)\n            return np.array([0.0, 0.0])\n        \n        centroid_x, centroid_y = 0.0, 0.0\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            cross_prod = p1[0] * p2[1] - p2[0] * p1[1]\n            centroid_x += (p1[0] + p2[0]) * cross_prod\n            centroid_y += (p1[1] + p2[1]) * cross_prod\n        \n        return np.array([centroid_x, centroid_y]) / (6.0 * area)\n\n    # --- Main computation logic ---\n    \n    test_cases = [\n        # (v vector, alpha, k0)\n        (np.array([0.8, 0.6, 0.3]), 0.7, 5.0),\n        (np.array([0.8, 0.6, 0.1]), 0.1, 7.0),\n        (np.array([0.3, 0.4, 0.5]), 1.5, 3.0),\n    ]\n\n    h_vals = [0.2, 0.1, 0.05]\n    result_orders = []\n    \n    for v, alpha, k0 in test_cases:\n        # Define physical parameters and fields for the test case\n        E0 = 1.0\n        mu = 1.0\n        omega = k0\n        n = v / np.linalg.norm(v)\n        \n        k_dir = np.cross(np.array([0.0, 0.0, 1.0]), n)\n        if np.linalg.norm(k_dir)  1e-12: # Handle case where n is parallel to z-axis\n            k_dir = np.cross(np.array([1.0, 0.0, 0.0]), n)\n        k = k0 * k_dir / np.linalg.norm(k_dir)\n\n        def E_field(r):\n            return E0 * np.exp(1j * np.dot(k, r)) * n\n\n        def H_field(r):\n            return (E0 / (mu * omega)) * np.cross(k, n) * np.exp(1j * np.dot(k, r))\n\n        # Calculate residual for each mesh size h\n        R_magnitudes = []\n        for h in h_vals:\n            d = alpha * h\n            n_xy = n[:2]\n            \n            # Clip the square face [0,h]x[0,h]\n            square_verts_2d = [np.array([0.,0.]), np.array([h,0.]), np.array([h,h]), np.array([0.,h])]\n            clipped_poly_2d = clip_polygon(square_verts_2d, n_xy, d)\n            \n            # Compute DM flux term\n            flux_term = 0.0 + 0.0j\n            area_val = polygon_area(clipped_poly_2d)\n            if abs(area_val) > 1e-14:\n                centroid_2d = polygon_centroid(clipped_poly_2d, area_val)\n                r_centroid = np.array([centroid_2d[0], centroid_2d[1], 0.0])\n                H_at_centroid = H_field(r_centroid)\n                phi_dm = H_at_centroid[2] * abs(area_val)\n                flux_term = 1j * omega * mu * phi_dm\n\n            # Compute DM line integral term\n            line_integral_term = 0.0 + 0.0j\n            edge_defs = [\n                (np.array([0., 0., 0.]), np.array([h, 0., 0.])),\n                (np.array([h, 0., 0.]), np.array([h, h, 0.])),\n                (np.array([h, h, 0.]), np.array([0., h, 0.])),\n                (np.array([0., h, 0.]), np.array([0., 0., 0.]))\n            ]\n            \n            for p0, p1 in edge_defs:\n                v0_val = np.dot(n, p0) - d\n                v1_val = np.dot(n, p1) - d\n                tol = 1e-14\n\n                t_start, t_end = 0.0, 1.0 # Default is fully open\n                if v0_val > tol and v1_val > tol: # Fully cut\n                    t_start, t_end = 0.0, 0.0 \n                elif v0_val = tol and v1_val > tol: # Cut at p1 end\n                    if abs(v0_val - v1_val) > tol: t_end = v0_val / (v0_val - v1_val)\n                elif v0_val > tol and v1_val = tol: # Cut at p0 end\n                    if abs(v0_val - v1_val) > tol: t_start = v0_val / (v0_val - v1_val)\n\n                if t_end > t_start:\n                    open_length = (t_end - t_start) * h\n                    t_mid = (t_start + t_end) / 2.0\n                    r_mid = p0 + t_mid * (p1 - p0)\n                    E_at_mid = E_field(r_mid)\n                    t_e = (p1 - p0) / h\n                    line_integral_term += np.dot(E_at_mid, t_e) * open_length\n\n            residual = line_integral_term + flux_term\n            R_magnitudes.append(np.abs(residual))\n            \n        # Estimate order of convergence\n        if any(r = 1e-15 for r in R_magnitudes):\n            p1 = p2 = float('inf')\n        else:\n            p1 = np.log(R_magnitudes[0] / R_magnitudes[1]) / np.log(h_vals[0] / h_vals[1])\n            p2 = np.log(R_magnitudes[1] / R_magnitudes[2]) / np.log(h_vals[1] / h_vals[2])\n\n        result_orders.append(min(p1, p2))\n        \n    print(f\"[{','.join(map(str, result_orders))}]\")\n\nsolve()\n```", "id": "3298002"}]}