{"hands_on_practices": [{"introduction": "物理学的一个基本原则是因果性：任何结果都不能先于其原因发生。在电磁学中，这意味着扰动传播的速度不能超过光速 $c$。本练习 [@problem_id:3328621] 提供了一种动手实践的方法，通过检查在物理上规定的推迟时间之前是否出现非零电流，来以编程方式测试 MOT 仿真是否违反了这一原则。这种验证是确保任何时域数值代码可靠性的关键第一步。", "problem": "您被要求为在计算电磁学中使用时间步进 (Marching-on-in-Time, MOT) 更新的时域边界积分方程求解器，形式化并实现一个因果性测试。目标是设计一个程序化检测器，该检测器在给定一个对脉冲激励的离散时间表面电流响应后，能够确定是否有任何非零电流在因有限传播速度而物理上规定的影响延迟时间之前出现。\n\n从以下基本原理和定义开始。\n\n- 在自由空间中，Maxwell 方程表明电磁扰动以光速 $c$ 传播。对于位于位置 $\\mathbf{r}_{s}$ 的源面元和位于位置 $\\mathbf{r}_{o}$ 的观测面元上的脉冲激励，欧几里得距离为 $R = \\lVert \\mathbf{r}_{o} - \\mathbf{r}_{s} \\rVert$。首次影响的延迟时间为 $t_{\\star} = R / c$。在理想的连续时间、连续空间模型中，对于 $t < t_{\\star}$，场和感应表面电流密度恒等于零。\n\n- 在用于时域电场积分方程 (EFIE) 的时间步进 (MOT) 方案中，时间在采样时刻 $t_{n} = n \\Delta t$ 被离散化，其中 $n$ 为非负整数，$\\Delta t$ 是固定的时间步长。在 $n = 0$ 时，于一个源面元上施加一个离散时间脉冲激励。如果求解器是因果的，那么在远处面元观测到的离散表面电流样本 $J_{o}[n]$ 必须对所有满足 $t_{n} < t_{\\star}$ 的 $n$ 满足 $J_{o}[n] = 0$。对于 $t_{n} \\ge t_{\\star}$，$J_{o}[n]$ 可以为非零值。\n\n- 我们将通过一个合成的、完全指定的、能够捕捉理想因果响应以及可选地一个用于模拟因果性违背的前因果“回波”的分段函数，来为观测到的离散电流响应 $J_{o}[n]$ 建模。这使得在没有完整 MOT 代码的情况下测试检测器成为可能。\n\n将在时刻 $t_{n} = n \\Delta t$ 的合成观测电流序列（对于 $n = 0,1,\\ldots,N-1$）定义为\n$$\nJ_{o}[n] =\n\\begin{cases}\nA \\exp\\!\\big(-\\alpha \\left(t_{n} - t_{\\star}\\right)\\big),  t_{n} \\ge t_{\\star}, \\\\\n0,  t_{n}  t_{\\star},\n\\end{cases}\n\\quad\\text{(因果部分)}\n$$\n并通过一个为 $t_{n}  t_{\\star}$ 定义的可选前因果高斯“回波”来增强，其定义为\n$$\nJ_{\\text{pre}}[n] = A_{\\text{pre}} \\exp\\!\\left(-\\dfrac{\\left(t_{n} - \\left(t_{\\star} - \\tau_{\\text{pre}}\\right)\\right)^{2}}{\\sigma_{\\text{pre}}^{2}}\\right),\n$$\n其中 $A$ 是因果指数尾部的正振幅，$\\alpha$ 是单位为 $\\mathrm{s}^{-1}$ 的正衰减率，$A_{\\text{pre}} \\ge 0$ 是前回波的峰值振幅，$\\tau_{\\text{pre}} > 0$ 将前回波中心置于 $t_{\\star}$ 之前 $\\tau_{\\text{pre}}$ 的位置，而 $\\sigma_{\\text{pre}} > 0$ 控制其宽度。完整的合成观测序列是\n$$\nJ_{o}[n] \\leftarrow J_{o}[n] + \\begin{cases}\nJ_{\\text{pre}}[n],  t_{n}  t_{\\star}, \\\\\n0,  t_{n} \\ge t_{\\star}.\n\\end{cases}\n$$\n\n按如下方式定义一个因果性违背检测器。给定参数 $(R, c, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$，使用上述规则（其中 $t_{\\star} = R/c$）合成 $J_{o}[n]$，并测试是否存在任何满足 $t_{n}  t_{\\star}$ 的索引 $n$，使得 $\\lvert J_{o}[n] \\rvert > \\varepsilon$。如果存在这样的 $n$，则声明存在违背（布尔值为 $\\mathrm{True}$）；否则，声明无违背（布尔值为 $\\mathrm{False}$）。容差 $\\varepsilon$ 是一个用户指定的非负阈值，用于避免将不重要的数值噪声标记出来。请注意，等式 $\\lvert J_{o}[n] \\rvert = \\varepsilon$ 不应被标记为违背。\n\n实现一个程序，将此检测器应用于以下测试套件。所有距离必须以米为单位，所有时间以秒为单位，衰减率以秒的倒数为单位，而在此合成模型中，电流振幅参数是无量纲的。使用真空中光速 $c = 299\\,792\\,458\\ \\mathrm{m/s}$。\n\n您的程序必须完全按照规定合成序列，并为每个案例生成一个单一的布尔值，以指示是否检测到违背。\n\n测试套件 (每个案例提供 $(R, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$；$c$ 固定为 $299\\,792\\,458\\ \\mathrm{m/s}$):\n- 案例 1 (正常路径，严格因果):\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 0.0$，\n  - $\\tau_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 5.0 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-6}$。\n\n- 案例 2 (边界相等，$t_{\\star}$ 在网格上):\n  - $R = 5.99584916\\ \\mathrm{m}$，等于 $c \\times 20.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 40$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 0.0$，\n  - $\\tau_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 5.0 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-6}$。\n\n- 案例 3 (近因果前回波低于阈值):\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 1.0 \\times 10^{-5}$，\n  - $\\tau_{\\text{pre}} = 3.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-4}$。\n\n- 案例 4 (明显因果性违背，高于阈值):\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 1.0 \\times 10^{-2}$，\n  - $\\tau_{\\text{pre}} = 3.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-4}$。\n\n- 案例 5 (阈值相等的边界情况):\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 5.0 \\times 10^{-3}$，\n  - $\\tau_{\\text{pre}} = 6.782047599076 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 2.0 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\varepsilon = 5.0 \\times 10^{-3}$。\n  对于 $R = 5.0\\ \\mathrm{m}$ 和 $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，这种 $\\tau_{\\text{pre}}$ 的选择将前回波的中心定位于最后一个严格的前因果样本处，因为 $t_{\\star} = R / c \\approx 1.66782047599076 \\times 10^{-8}\\ \\mathrm{s}$ 且 $t_{16} = 1.6 \\times 10^{-8}\\ \\mathrm{s}$，因此 $\\tau_{\\text{pre}} \\approx t_{\\star} - t_{16} = 6.782047599076 \\times 10^{-10}\\ \\mathrm{s}$。在这种配置下，前回波的峰值大小在一个严格的前因果索引处等于 $\\varepsilon$，并且必须不被标记。\n\n您的程序应：\n- 实现所定义的合成规则和检测器。\n- 按所列顺序将检测器应用于五个案例。\n- 生成单行输出，其中包含五个布尔结果，形式为用方括号括起来的逗号分隔列表，不含空格。例如，输出可能看起来像 $[\\mathrm{False},\\mathrm{True},\\ldots]$，但应使用指定案例的实际布尔值。\n\n无用户输入。所有常量和参数均如上所述。最终输出是布尔值，因此没有物理单位适用于输出。确保所有表示时间的内部量都以秒为单位，所有距离都以米为单位，并使用 $c = 299\\,792\\,458\\ \\mathrm{m/s}$。", "solution": "这个问题是有效的，因为它以计算电磁学的原理为科学基础，其提法是适定的，具有一套清晰客观的定义和约束，并要求实现一个特定的、可验证的算法。\n\n问题的核心在于由 Maxwell 方程所规定的因果性原理。在真空中，效应的传播速度不能超过光速 $c$。对于位于位置 $\\mathbf{r}_s$ 的源和位于 $\\mathbf{r}_o$ 的观测者，能感受到影响的最早时间是延迟时间 $t_{\\star} = R/c$，其中 $R = \\lVert \\mathbf{r}_{o} - \\mathbf{r}_{s} \\rVert$ 是欧几里得距离。在此时间之前，对于所有 $t  t_{\\star}$，观测者位置的任何场或感应电流都必须恒等于零。\n\n在数值时间步进 (MOT) 算法的背景下，时间被离散化为步长 $t_n = n \\Delta t$，其中 $n$ 为非负整数。一个因果的 MOT 求解器必须在计算上强制执行该物理原理，确保对于所有满足 $t_n  t_{\\star}$ 的时间索引 $n$，离散表面电流 $J_o[n]$ 均为零。\n\n任务是设计一个检测器，用于检测对这种离散因果条件的违背。该方法基于一个合成电流信号 $J_o[n]$，它对理想响应与一个潜在的非因果伪影的组合进行建模。完整的合成信号由因果部分和前因果部分之和给出。因果部分仅在 $t_n \\ge t_{\\star}$ 时非零，定义为\n$$\nJ_{o}[n] = A \\exp\\!\\big(-\\alpha \\left(t_{n} - t_{\\star}\\right)\\big), \\quad t_{n} \\ge t_{\\star}.\n$$\n前因果部分，或称“回波”，仅存在于 $t_n  t_{\\star}$ 时，并被建模为一个高斯脉冲：\n$$\nJ_{\\text{pre}}[n] = A_{\\text{pre}} \\exp\\!\\left(-\\dfrac{\\left(t_{n} - \\left(t_{\\star} - \\tau_{\\text{pre}}\\right)\\right)^{2}}{\\sigma_{\\text{pre}}^{2}}\\right), \\quad t_n  t_{\\star}.\n$$\n完整信号是这两个分量的和，每个分量都限制在其各自的时间域内。\n\n因果性检测器必须确定在前因果域 ($t_n  t_{\\star}$) 中是否存在任何时间索引 $n$，使得信号的幅度 $|J_o[n]|$ 严格大于指定的数值容差 $\\varepsilon$。\n\n从定义中可以得出一个关键的简化。对于任何时间 $t_n  t_{\\star}$，根据定义，$J_o[n]$ 的因果分量为零。因此，在前因果时期，总信号 $J_o[n]$ 等于前因果回波 $J_{\\text{pre}}[n]$。因此，因果性违背的测试简化为检查是否存在任何 $n$（其中 $t_n  t_{\\star}$）使得 $|J_{\\text{pre}}[n]| > \\varepsilon$。\n\n实现的算法如下：\n$1$. 对于给定的一组参数 $(R, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$，使用 $c = 299\\,792\\,458\\ \\mathrm{m/s}$ 计算延迟时间 $t_{\\star} = R/c$。\n$2$. 首先执行一个关键的逻辑优化。高斯函数 $J_{\\text{pre}}[n]$ 的最大值是其振幅 $A_{\\text{pre}}$。如果 $A_{\\text{pre}} \\le \\varepsilon$，则条件 $J_{\\text{pre}}[n] > \\varepsilon$ 对任何 $n$ 都不可能满足。因此，如果前因果信号的最大可能值不严格大于阈值，我们可以立即得出结论：不存在违背 (`False`)。这正确地处理了问题中指定的前因果信号峰值恰好等于阈值的情况（$|J_o[n]| = \\varepsilon$ 不是违背）。\n$3$. 如果 $A_{\\text{pre}} > \\varepsilon$，则可能存在违背。算法从 $0$ 到 $N-1$ 遍历时间索引 $n$。\n$4$. 对于每个 $n$，计算时间 $t_n = n \\Delta t$。如果 $t_n \\ge t_{\\star}$，我们已进入因果域，因此对前因果违背的搜索可以终止。\n$5$. 对于前因果域 ($t_n  t_{\\star}$) 中的每个时间步，计算 $J_{\\text{pre}}[n]$ 的值。由于 $A_{\\text{pre}} \\ge 0$，指数项始终为正，因此 $|J_{\\text{pre}}[n]| = J_{\\text{pre}}[n]$。\n$6$. 将此值与阈值 $\\varepsilon$ 进行比较。如果 $J_{\\text{pre}}[n] > \\varepsilon$，则已找到因果性违背，函数返回 `True`。\n$7$. 如果遍历所有相关的前因果索引 $n$ 的循环完成而未满足该条件，则不存在违背，函数返回 `False`。\n将此过程应用于五个测试案例中的每一个，以生成最终的布尔结果列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a causality test for synthetic MOT signals.\n    \"\"\"\n\n    def causality_detector(params):\n        \"\"\"\n        Detects causality violations for a single test case.\n\n        A violation occurs if |J_o[n]| > epsilon for any t_n  t_star.\n        For t_n  t_star, J_o[n] is identical to the pre-causal component J_pre[n].\n        \"\"\"\n        R, dt, N, A, alpha, A_pre, tau_pre, sigma_pre, epsilon = params\n        C = 299792458.0  # Speed of light in m/s\n\n        t_star = R / C\n\n        # Optimization: If the peak amplitude of the pre-causal echo is not strictly\n        # greater than the threshold, no violation is possible, as the exponential\n        # term is at most 1. This also correctly handles A_pre = 0 and the\n        # equality case |J_o[n]| = epsilon.\n        if A_pre = epsilon:\n            return False\n\n        # Iterate through discrete time steps up to the retarded time\n        for n in range(N):\n            t_n = n * dt\n\n            # We are only interested in the pre-causal time domain\n            if t_n >= t_star:\n                break  # Exit loop once we reach or pass the retarded time\n\n            # Calculate the pre-causal echo signal value at time t_n\n            t_center = t_star - tau_pre\n            exponent_numerator = (t_n - t_center)**2\n            exponent_denominator = sigma_pre**2\n            \n            # Avoid division by zero, although sigma_pre > 0 is a given\n            if exponent_denominator == 0:\n                # This case should not be reached given problem constraints\n                j_pre_n = 0.0 if exponent_numerator > 0 else A_pre\n            else:\n                exponent = -exponent_numerator / exponent_denominator\n                j_pre_n = A_pre * np.exp(exponent)\n\n            # Check for violation. The signal is non-negative, so abs() is not needed.\n            # The condition is strictly greater than epsilon.\n            if j_pre_n > epsilon:\n                return True  # Violation detected\n\n        # If the loop completes without finding any violation\n        return False\n\n    # Test Suite (R, delta_t, N, A, alpha, A_pre, tau_pre, sigma_pre, epsilon)\n    test_cases = [\n        # Case 1: happy path, strictly causal (A_pre = 0)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 0.0, 1.0e-9, 5.0e-10, 1.0e-6),\n        # Case 2: t_star on-grid, causal (A_pre = 0)\n        (5.99584916, 1.0e-9, 40, 1.0, 5.0e7, 0.0, 1.0e-9, 5.0e-10, 1.0e-6),\n        # Case 3: pre-echo below threshold (A_pre  epsilon)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 1.0e-5, 3.0e-9, 1.0e-9, 1.0e-4),\n        # Case 4: explicit causality violation (A_pre > epsilon and echo is significant)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 1.0e-2, 3.0e-9, 1.0e-9, 1.0e-4),\n        # Case 5: edge case at threshold equality (A_pre = epsilon)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 5.0e-3, 6.782047599076e-10, 2.0e-10, 5.0e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = causality_detector(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of booleans in brackets.\n    # Python's str() of a boolean is 'True' or 'False', which matches the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3328621"}, {"introduction": "MOT 仿真的准确性常常受到数值色散的限制，即在离散模型中，波的不同频率分量以略微不同的速度传播，从而导致信号失真。本练习 [@problem_id:3328595] 旨在展示如何通过使用高阶多项式基函数进行时间插值来显著提高相位精度。你将通过测量不同阶数基函数重建信号的相位误差来量化这种改进，从而深入理解数值精度与基函数选择之间的关系。", "problem": "考虑一个时域推迟势模型，该模型捕捉了电磁表面积分方程的时域步进 (marching-on-in-time, MOT) 公式中遇到的基本时间结构。设入射场为已知标量激励 $E_{\\text{inc}}(t)$，感应电流密度建模为标量函数 $J(t)$，两者通过推迟卷积相关联\n$$\nJ(t) = \\int_{-\\infty}^{\\infty} g(t-\\tau) E_{\\text{inc}}(\\tau)\\, d\\tau,\n$$\n其中标量核为因果点延迟 $g(t) = \\delta(t-\\tau_0)$，具有固定的传播延迟 $\\tau_0  0$。根据 Dirac delta 函数的筛选性质，精确电流为\n$$\nJ_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0).\n$$\n在时域步进法中，电流在时间步长为 $\\Delta t$ 的均匀时间网格上，使用有限支撑时间基（也称为时间形状函数）表示为\n$$\nJ_r(t) \\approx \\sum_{n=0}^{N-1} I_n \\, B_r\\!\\left(\\frac{t - n \\Delta t}{\\Delta t}\\right),\n$$\n其中 $r$ 是基的多项式阶数，$B_r$ 是阶数为 $r$ 的基数插值基，其紧支撑跨越 $r+1$ 个时间步，$I_n$ 是通过在时间网格上进行配置得到的系数，此处取为精确解的采样值 $I_n = J_{\\text{exact}}(n\\Delta t)$。对于插值基，在其支撑域内，对于整数 $k \\neq 0$，有 $B_r(0)=1$ 和 $B_r(k)=0$。\n\n您将实现并比较以下插值时间基：\n- 分段线性（阶数 $r=1$），也称为帽函数。\n- 分段三次（阶数 $r=3$），通过在整数模板上进行4点基数 Lagrange 插值实现。\n- 分段四次（阶数 $r=4$），通过在整数模板上进行5点基数 Lagrange 插值实现。\n\n输入信号是一个线性调频激励，带有一个平滑窗以强制实现有限支撑：\n$$\nE_{\\text{inc}}(t) = A(t)\\cos\\!\\left(2\\pi\\left(f_0 t + \\tfrac{1}{2}\\alpha t^2\\right)\\right),\n\\quad \\text{for } 0 \\le t \\le T,\\quad \\text{and } E_{\\text{inc}}(t)=0 \\text{ otherwise},\n$$\n其中扫描速率为 $\\alpha = \\frac{f_1 - f_0}{T}$，Hann 窗为 $A(t) = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\frac{2\\pi t}{T}\\right)\\right)$。精确电流为 $J_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0)$。\n\n您的任务是：\n1. 构造粗略时间网格 $t_n = n\\Delta t$（$n=0,1,\\dots,N-1$），并定义系数 $I_n = J_{\\text{exact}}(n\\Delta t)$。\n2. 在精细网格 $t_m^{\\text{fine}} = m\\Delta t/L$（$m=0,1,\\dots,LN-1$）上，使用 $r$ 阶插值基，通过在每个局部模板上进行基数 Lagrange 插值，重构连续时间电流 $J_r(t)$。\n3. 使用快速傅里叶变换，在精细网格上计算 $J_{\\text{exact}}(t_m^{\\text{fine}})$ 和 $J_r(t_m^{\\text{fine}})$ 的离散傅里叶变换 (DFT)。设单边 DFT 在频率 $\\omega_k = 2\\pi f_k$ 处为 $\\hat{J}_{\\text{exact}}(\\omega_k)$ 和 $\\hat{J}_r(\\omega_k)$，其中 $f_k$ 是由精细采样间隔 $\\Delta t/L$ 决定的非负 DFT 频率。\n4. 在精确频谱幅度显著的调频带 $[f_0,f_1]$ 内的频率点上，将基阶数为 $r$ 的相位误差定义为\n$$\n\\phi_r(\\omega_k,\\Delta t) = \\operatorname{unwrap}\\left(\\arg\\left(\\hat{J}_r(\\omega_k)\\right) - \\arg\\left(\\hat{J}_{\\text{exact}}(\\omega_k)\\right)\\right),\n$$\n相位单位为弧度。使用一个幅度掩码，仅保留那些满足 $\\left|\\hat{J}_{\\text{exact}}(\\omega_k)\\right| \\ge \\eta \\max_{f_0 \\le f \\le f_1} \\left|\\hat{J}_{\\text{exact}}(2\\pi f)\\right|$ 的 $k$，固定显著性阈值为 $\\eta = 0.2$。\n5. 报告在保留的频率点上的均方根 (RMS) 相位误差（单位为弧度）：\n$$\n\\mathrm{RMS}_r = \\sqrt{\\frac{1}{K}\\sum_{k \\in \\mathcal{K}} \\phi_r(\\omega_k,\\Delta t)^2},\n$$\n其中 $\\mathcal{K}$ 是保留的频率点集合，$K = |\\mathcal{K}|$。\n\n物理单位要求：\n- 所有时间必须以秒为单位。\n- 所有频率必须以赫兹为单位。\n- 所有角度必须以弧度为单位。\n- 最终的相位误差必须以弧度为单位，作为实值浮点数报告。\n\n实现上述步骤，并在以下测试套件上评估三种时间基 $r\\in\\{1,3,4\\}$。在每个测试中，使用指定的 $\\Delta t$、整数长度 $N$、调频带 $[f_0,f_1]$、延迟 $\\tau_0$ 和过采样因子 $L$ 来如上定义网格和信号。总持续时间为 $T = N\\Delta t$。\n\n测试套件：\n- 测试 1（正常情况，带内小数延迟）：\n    - $\\Delta t = 5.0\\times 10^{-10}\\ \\text{s}$，$N=4096$，$f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$，$f_1 = 8.0\\times 10^{8}\\ \\text{Hz}$，$\\tau_0 = 2.3\\,\\Delta t$，$L=8$。\n- 测试 2（边界情况，接近奈奎斯特的频带边缘和整数延迟）：\n    - $\\Delta t = 5.0\\times 10^{-10}\\ \\text{s}$，$N=4096$，$f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$，$f_1 = 9.0\\times 10^{8}\\ \\text{Hz}$，$\\tau_0 = 8\\,\\Delta t$，$L=8$。\n- 测试 3（更小的时间步长，更高频带，小数延迟）：\n    - $\\Delta t = 2.5\\times 10^{-10}\\ \\text{s}$，$N=4096$，$f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$，$f_1 = 1.5\\times 10^{9}\\ \\text{Hz}$，$\\tau_0 = 2.7\\,\\Delta t$，$L=8$。\n\n您的程序必须：\n- 在长度为 $r+1$ 的局部整数模板上实现阶数为 $r=1,3,4$ 的基数 Lagrange 插值，并在采样区间外进行零填充。\n- 在精细网格上构造 $J_{\\text{exact}}(t)$ 和 $J_r(t)$，并计算定义的基于 DFT 的相位误差。\n- 对于每个测试，计算并收集三个 RMS 相位误差 $\\mathrm{RMS}_1$、$\\mathrm{RMS}_3$ 和 $\\mathrm{RMS}_4$（单位为弧度）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个内部列表对应一个测试，顺序与上文相同。每个内部列表的形式必须为 $[\\mathrm{RMS}_1,\\mathrm{RMS}_3,\\mathrm{RMS}_4]$，其中每个条目都是以弧度为单位的浮点数。例如：[[x11,x13,x14],[x21,x23,x24],[x31,x33,x34]]。", "solution": "该问题被评估为有效。它在科学上基于计算电磁学和数值分析的原理，特别是在时域步进 (Marching-on-in-Time, MOT) 算法中，解决了使用时间基函数表示时域信号的问题。该问题是适定的，具有一套完整且一致的定义、参数和目标，可导出一个唯一且可验证的解。所有术语都得到了正式定义，所需的物理参数和数值程序在该领域内是标准的。\n\n求解过程首先构造指定的输入信号和精确的推迟响应。然后，对于每个指定的时间基阶数 $r \\in \\{1, 3, 4\\}$，从粗略网格上的采样点重构连续时间电流。最后，在频域中根据精确解来量化每种重构的相位精度。\n\n**1. 信号和网格生成**\n\n对于每个测试用例，我们给定一个时间步长 $\\Delta t$、时间步数 $N$、一个频率调频带 $[f_0, f_1]$、一个传播延迟 $\\tau_0$ 以及一个精细网格过采样因子 $L$。\n\n入射信号的总持续时间为 $T = N \\Delta t$。\n粗略时间网格定义为 $t_n = n \\Delta t$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n用于分析的精细时间网格为 $t_m^{\\text{fine}} = m \\frac{\\Delta t}{L}$，其中 $m \\in \\{0, 1, \\dots, LN-1\\}$。设 $N_{\\text{fine}} = LN$。\n\n入射场 $E_{\\text{inc}}(t)$ 是一个线性调频余弦脉冲，带有一个 Hann 窗以实现平滑的开始和结束：\n$$\nE_{\\text{inc}}(t) = \n\\begin{cases} \n\\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi t}{T}\\right)\\right) \\cos\\left(2\\pi\\left(f_0 t + \\frac{1}{2}\\alpha t^2\\right)\\right)  \\text{for } 0 \\le t \\le T \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n其中调频速率为 $\\alpha = \\frac{f_1 - f_0}{T}$。\n\n精确电流 $J_{\\text{exact}}(t)$ 是入射场的一个时延版本，由 Dirac delta 核的筛选性质给出：\n$$\nJ_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0)\n$$\n用于 MOT 表示的系数 $I_n$ 是该精确电流在粗略网格上的采样值：\n$$\nI_n = J_{\\text{exact}}(t_n) = J_{\\text{exact}}(n \\Delta t), \\quad n \\in \\{0, 1, \\dots, N-1\\}\n$$\n\n**2. 通过插值重构电流**\n\n近似电流 $J_r(t)$ 是使用阶数为 $r$ 的基函数从粗略网格样本 $\\{I_n\\}$ 重构的。问题将此重构指定为移位基函数的和，$J_r(t) = \\sum_{n=0}^{N-1} I_n \\, B_r\\!\\left(\\frac{t - n \\Delta t}{\\Delta t}\\right)$，但也称这些基为“分段的”，并通过“在局部模板上进行 Lagrange 插值”来实现。这最一致地解释为一种分段多项式插值方案。对于每个粗略时间区间 $[t_n, t_{n+1}]$，使用一个包含 $r+1$ 个邻近样本 $\\{I_k\\}$ 的模板来构造一个 $r$ 阶多项式，并使用该多项式计算 $t \\in [t_n, t_{n+1}]$ 的 $J_r(t)$ 值。这种方法等效于卷积和，其中 $B_r(\\tau)$ 是一个具有紧支撑的分段多项式函数，被称为 Lagrange 型基本样条。\n\n对于实现：\n- **阶数 $r=1$ (分段线性)**：这对应于标准的“帽”函数基。对于任何 $t \\in [t_n, t_{n+1}]$，值 $J_1(t)$ 是通过在点 $(t_n, I_n)$ 和 $(t_{n+1}, I_{n+1})$ 之间进行线性插值计算的。这可以在整个精细网格上高效实现。\n- **阶数 $r=3$ (分段三次)**：对于每个区间 $[t_n, t_{n+1}]$，我们使用一个4点模板来构造一个三次 Lagrange 多项式。一个标准的选择是样本模板 $\\{I_{n-1}, I_n, I_{n+1}, I_{n+2}\\}$。然后在 $[t_n, t_{n+1}]$ 内的精细网格点上对此多项式进行求值。\n- **阶数 $r=4$ (分段四次)**：类似地，对于每个区间 $[t_n, t_{n+1}]$，我们使用一个5点模板。相对于区间点的一个中心化选择是 $\\{I_{n-2}, I_{n-1}, I_n, I_{n+1}, I_{n+2}\\}$。该模板涉及与粗略时间 $\\{t_{n-2}, \\dots, t_{n+2}\\}$ 对应的样本。从这些样本构造一个四次 Lagrange 多项式，并在 $[t_n, t_{n+1}]$ 的精细网格上进行求值。\n\n在定义域 $[0, T]$ 的边界处，模板可能需要 $n  0$ 或 $n \\ge N$ 的样本 $I_n$。根据问题对“零填充”的规定，我们假设这些索引的 $I_n = 0$。\n\n**3. 频谱分析和相位误差计算**\n\n重构的精度在频域中进行评估。\n1.  **傅里叶变换**：使用快速傅里叶变换 (FFT) 算法，对精细采样的信号 $J_{\\text{exact}}(t_m^{\\text{fine}})$ 和 $J_r(t_m^{\\text{fine}})$ 计算精确电流 $\\hat{J}_{\\text{exact}}(\\omega_k)$ 和重构电流 $\\hat{J}_r(\\omega_k)$ 的单边离散傅里叶变换 (DFT)。相应的离散频率为 $f_k = k / (N_{\\text{fine}} \\cdot (\\Delta t/L))$。\n\n2.  **幅度掩码**：相位误差仅在信号具有显著能量的地方才有意义。我们首先确定落在调频带 $[f_0, f_1]$ 内的频率点 $k$。在该频带内，我们找到精确信号的最大频谱幅度，$M_{\\text{max}} = \\max_{f_k \\in [f_0, f_1]} \\left|\\hat{J}_{\\text{exact}}(2\\pi f_k)\\right|$。分析被限制在幅度超过此最大值的一个分数 $\\eta=0.2$ 的频率点集合 $\\mathcal{K}$ 上：\n$$\n\\mathcal{K} = \\left\\{ k \\;\\middle|\\; f_k \\in [f_0, f_1] \\text{ and } \\left|\\hat{J}_{\\text{exact}}(2\\pi f_k)\\right| \\ge \\eta M_{\\text{max}} \\right\\}\n$$\n\n3.  **相位误差**：对于每个对应于索引 $k \\in \\mathcal{K}$ 的频率 $\\omega_k$，计算原始相位差：$\\Delta\\phi(\\omega_k) = \\arg(\\hat{J}_r(\\omega_k)) - \\arg(\\hat{J}_{\\text{exact}}(\\omega_k))$。然后对该差值进行解卷绕以解决 $2\\pi$ 模糊性，从而得到连续相位误差 $\\phi_r(\\omega_k, \\Delta t)$。\n\n4.  **RMS 度量**：最终的误差度量是在所有保留的频率点上解卷绕相位误差的均方根 (RMS)：\n$$\n\\mathrm{RMS}_r = \\sqrt{\\frac{1}{K}\\sum_{k \\in \\mathcal{K}} \\phi_r(\\omega_k, \\Delta t)^2}\n$$\n其中 $K=|\\mathcal{K}|$ 是掩码集合中频率点的数量。对每个阶数 $r$ 和每个测试用例重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d, barycentric_interpolate\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test 1: Happy path\n        {'dt': 5.0e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 8.0e8, 'tau0_factor': 2.3, 'L': 8},\n        # Test 2: Near-Nyquist\n        {'dt': 5.0e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 9.0e8, 'tau0_factor': 8.0, 'L': 8},\n        # Test 3: Smaller time step, higher band\n        {'dt': 2.5e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 1.5e9, 'tau0_factor': 2.7, 'L': 8}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results_per_case = run_test_case(**params)\n        all_results.append(results_per_case)\n\n    # Format the final output string as a list of lists.\n    # e.g., [[x11,x13,x14],[x21,x23,x24],[x31,x33,x34]]\n    output_str = '[' + ','.join(['[' + ','.join([f\"{val:.8f}\" for val in res]) + ']' for res in all_results]) + ']'\n    print(output_str)\n\ndef run_test_case(dt, N, f0, f1, tau0_factor, L):\n    \"\"\"\n    Executes a single test case for the given parameters.\n    \"\"\"\n    T = N * dt\n    tau0 = tau0_factor * dt\n    alpha = (f1 - f0) / T\n\n    # Define the incident field E_inc(t)\n    def e_inc(t):\n        # Ensure t is a numpy array for vectorized operations\n        t = np.asarray(t)\n        # Signal is defined on [0, T], zero otherwise\n        active_mask = (t >= 0)  (t = T)\n        result = np.zeros_like(t, dtype=float)\n        \n        t_active = t[active_mask]\n        \n        # Hann window\n        amplitude = 0.5 * (1 - np.cos(2 * np.pi * t_active / T))\n        # Chirp signal\n        phase = 2 * np.pi * (f0 * t_active + 0.5 * alpha * t_active**2)\n        \n        result[active_mask] = amplitude * np.cos(phase)\n        return result\n\n    # Define the exact current J_exact(t)\n    def j_exact(t):\n        return e_inc(t - tau0)\n\n    # --- Grids and Coefficients ---\n    t_coarse = np.arange(N) * dt\n    I_coeffs = j_exact(t_coarse)\n\n    N_fine = N * L\n    dt_fine = dt / L\n    t_fine = np.arange(N_fine) * dt_fine\n\n    J_exact_fine = j_exact(t_fine)\n\n    rms_errors = []\n    for r in [1, 3, 4]:\n        J_recon_fine = reconstruct_current(I_coeffs, r, L, dt)\n        rms_error = calculate_rms_phase_error(J_recon_fine, J_exact_fine, dt_fine, f0, f1)\n        rms_errors.append(rms_error)\n        \n    return rms_errors\n\ndef reconstruct_current(I_coeffs, r, L, dt):\n    \"\"\"\n    Reconstructs the continuous-time current on a fine grid using piecewise\n    Lagrange interpolation of degree r.\n    \"\"\"\n    N = len(I_coeffs)\n    N_fine = N * L\n    t_fine = np.arange(N_fine) * (dt / L)\n    J_recon = np.zeros(N_fine)\n\n    if r == 1:\n        # Degree 1 (linear interpolation) is efficiently handled by interp1d\n        t_coarse_nodes = np.arange(N + 1) * dt\n        I_extended = np.pad(I_coeffs, (0, 1), 'constant')\n        interp_func = interp1d(t_coarse_nodes, I_extended, kind='linear', bounds_error=False, fill_value=0.0)\n        return interp_func(t_fine)\n\n    # For r > 1, use piecewise barycentric interpolation\n    # Determine padding needed based on stencil choice\n    if r == 3: # Stencil: [n-1, n, n+1, n+2]\n        pad_before, pad_after = 1, 2\n    elif r == 4: # Stencil: [n-2, n-1, n, n+1, n+2]\n        pad_before, pad_after = 2, 2\n    else:\n        raise ValueError(f\"Unsupported degree r={r}\")\n\n    I_padded = np.pad(I_coeffs, (pad_before, pad_after), 'constant')\n\n    for n in range(N):\n        m_start = n * L\n        m_end = (n + 1) * L\n        t_interval_fine = t_fine[m_start:m_end]\n\n        if r == 3:\n            stencil_n_indices = np.array([n - 1, n, n + 1, n + 2])\n        elif r == 4:\n            stencil_n_indices = np.array([n - 2, n - 1, n, n + 1, n + 2])\n        \n        t_stencil_nodes = stencil_n_indices * dt\n        I_stencil_values = I_padded[stencil_n_indices + pad_before]\n\n        J_recon[m_start:m_end] = barycentric_interpolate(t_stencil_nodes, I_stencil_values, t_interval_fine)\n        \n    return J_recon\n\ndef calculate_rms_phase_error(j_recon, j_exact, dt_fine, f0, f1, eta=0.2):\n    \"\"\"\n    Calculates the RMS phase error in the frequency domain.\n    \"\"\"\n    N_fine = len(j_exact)\n    \n    # Compute one-sided FFTs\n    J_hat_recon = np.fft.rfft(j_recon)\n    J_hat_exact = np.fft.rfft(j_exact)\n    \n    # Get corresponding frequencies\n    freqs = np.fft.rfftfreq(N_fine, d=dt_fine)\n    \n    # Identify frequency bins in the chirp band [f0, f1]\n    band_indices = np.where((freqs >= f0)  (freqs = f1))[0]\n    \n    if len(band_indices) == 0:\n        return 0.0\n\n    # Apply amplitude mask\n    J_hat_exact_band = J_hat_exact[band_indices]\n    max_mag_in_band = np.max(np.abs(J_hat_exact_band))\n    \n    threshold = eta * max_mag_in_band\n    \n    mask = np.abs(J_hat_exact_band) >= threshold\n    \n    masked_indices = band_indices[mask]\n    \n    if len(masked_indices) == 0:\n        return 0.0\n\n    # Calculate phase error\n    phase_recon = np.angle(J_hat_recon[masked_indices])\n    phase_exact = np.angle(J_hat_exact[masked_indices])\n    \n    phase_error = phase_recon - phase_exact\n    unwrapped_phase_error = np.unwrap(phase_error)\n    \n    # Compute RMS error\n    rms_error = np.sqrt(np.mean(unwrapped_phase_error**2))\n    \n    return rms_error\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3328595"}, {"introduction": "时域电场积分方程 (TD-EFIE) 的一个著名挑战是晚期时间不稳定性，即数值误差会随着仿真的进行而无限制地增长。本练习 [@problem_id:3328585] 介绍了时域组合场积分方程 (TD-CFIE) 作为一种强大的稳定化技术。你将通过一个简化的代理模型，探索如何通过寻找一个最佳混合参数 $\\eta$ 来抑制这种不稳定性，从而确保获得一个表现良好的数值解。", "problem": "您的任务是通过一个标量混合参数，结合时域电场积分方程 (TD-EFIE) 和时域磁场积分方程 (TD-MFIE) 的核函数，为理想电导体 (PEC) 球体上的表面电流密度构建一个时域组合场积分方程 (TD-CFIE) 的时间步进算法。从基于 Maxwell 方程组和标准 PEC 边界条件的第一性原理出发。目标是选择一个混合参数，以在高频范围内最小化离散表面电流随时间的增长。\n\n从自由空间中的时域 Maxwell 方程组开始，考虑电场 $\\mathbf{E}(\\mathbf{r},t)$ 和磁场 $\\mathbf{H}(\\mathbf{r},t)$，以及电通量密度 $\\mathbf{D}(\\mathbf{r},t)$、磁通量密度 $\\mathbf{B}(\\mathbf{r},t)$ 和线性本构关系，并对切向电场施加 PEC 边界条件。考虑时域积分方程的公式，该公式通过推迟势将球体上的未知表面电流密度 $\\mathbf{J}(\\mathbf{r},t)$ 映射到散射场。TD-EFIE 和 TD-MFIE 定义了卷积算子，其核函数 $K_E(t)$ 和 $K_M(t)$ 在表面上作用于 $\\mathbf{J}(\\mathbf{r},t)$。TD-CFIE 算子被定义为核函数的凸组合，\n$$\nK_C(t) = \\eta\\, K_E(t) + (1-\\eta)\\, K_M(t),\n$$\n其中 $0 \\le \\eta \\le 1$ 是混合参数。\n\n空间上使用单一主导的矢量球谐函数模式进行离散化，将算子简化为单个模态系数 $J(t)$ 的标量代理；时间上使用步长为 $\\Delta t$ 的均匀网格和分段常数时间基进行离散化。在空间和时间上进行 Galerkin 测试后，TD-CFIE 产生了一个关于模态系数的线性因果离散卷积方程，\n$$\n\\sum_{m=0}^{M} Z_C[m]\\, J^{n-m} = V^n,\n$$\n其中 $J^n$ 近似于 $J(n\\Delta t)$，$M$ 是有限记忆深度，$Z_C[m]$ 是离散的 TD-CFIE 权重，$V^n$ 是测试激励。对于后续激励为零（$V^n = 0$ for $n \\ge 1$）的情况，时间步进更新公式为\n$$\nJ^n = -\\frac{1}{Z_C[0]} \\sum_{m=1}^{\\min(M,n)} Z_C[m]\\, J^{n-m},\\quad n\\ge 1,\n$$\n其中初始条件为指定的 $J^0$ 且当 $n0$ 时 $J^n=0$。\n\n为了定义一个科学一致的降阶代理模型，用于描述在高频范围（以波数 $k$ 为特征，且 $ka \\gg 1$）下半径为 $a$ 的 PEC 球体，假设离散 TD-EFIE 和 TD-MFIE 权重具有以下参数化形式，这些形式能捕捉辐射的因果性、阻尼和振荡行为：\n$$\nZ_E[0] = z_{E0}, \\quad Z_M[0] = z_{M0},\n$$\n$$\nZ_E[m] = A_E\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad Z_M[m] = A_M\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad m\\ge 1,\n$$\n其中 $z_{M0} = 0.5$ 对应于光滑闭合曲面上 MFIE 的经典主值项，而一个小的非零值 $z_{E0}$ 则捕捉了 TD-EFIE 的自作用项。振幅 $A_E$ 和 $A_M$ 随 $ka$ 缩放，以表示高频下更强的 EFIE 耦合，其中 $A_E = \\min(1.0, 0.02\\,ka)$ 且 $A_M = 0.5\\,A_E$。阻尼因子为 $\\alpha = 0.05$，短因果延迟由整数 $m_d = 3$ 编码。角频率为 $\\omega = c\\,k$，其中 $c$ 是真空中光速。混合后得到\n$$\nZ_C[m] = \\eta\\, Z_E[m] + (1-\\eta)\\, Z_M[m], \\quad m=0,1,\\dots,M.\n$$\n\n使用时间步进更新来推进 $J^n$（$n=1,2,\\dots,N$），初始条件为 $J^0 = 1$ 和当 $n  0$ 时 $J^n = 0$，且测试激励在 $n\\ge 1$ 时为零（$V^n=0$）。对于给定的 $\\eta$，定义增长度量\n$$\nG(\\eta) = \\max_{0 \\le n \\le N} \\left|J^n\\right|,\n$$\n并选择最优混合参数\n$$\n\\eta^\\star = \\arg\\min_{\\eta \\in \\{0.00,0.01,\\dots,1.00\\}} G(\\eta).\n$$\n\n在一个完整的、可运行的程序中实现上述模型和过程。使用光速 $c = 299792458\\,\\mathrm{m/s}$，半径单位为米，时间步长单位为秒，所有角度单位为弧度。通过周期 $T = 2\\pi/\\omega$ 将时间步长 $\\Delta t$ 定义为 $\\Delta t = T/p$，其中 $p$ 为整数。对于每个测试用例，根据 $k = (ka)/a$ 计算 $\\omega$，设置 $z_{E0} = 0.1 + 0.02\\cdot\\pi/(10\\,ka)$，并使用上述指定的参数 $M$、$m_d$ 和 $\\alpha$ 来计算 $Z_E[m]$ 和 $Z_M[m]$。\n\n测试套件：\n- 案例 1 (正常路径)：$a = 0.1\\,\\mathrm{m}$，$ka = 50$，$p = 20$，$N = 200$，$M = 12$。\n- 案例 2 (边界条件，更粗糙的时间步长)：$a = 0.05\\,\\mathrm{m}$，$ka = 50$，$p = 10$，$N = 200$，$M = 12$。\n- 案例 3 (边缘情况，更低的 $ka$ 和更长的记忆)：$a = 0.1\\,\\mathrm{m}$，$ka = 30$，$p = 20$，$N = 400$，$M = 20$。\n\n必需的最终输出格式：\n您的程序应生成单行输出，其中包含测试套件的三个最优混合参数，形式为用方括号括起来的逗号分隔列表，例如 $\\left[\\eta^\\star_1,\\eta^\\star_2,\\eta^\\star_3\\right]$，其中每个条目都是一个四舍五入到三位小数的浮点数。", "solution": "目标是为一个用于模拟理想电导体 (PEC) 球体表面电流的时域组合场积分方程 (TD-CFIE) 公式，确定最优的标量混合参数 $\\eta^\\star$。优化准则是在时间上最小化离散模态电流系数的增长，这是时间步进 (MOT) 算法中一个已知的挑战，尤其对于时域电场积分方程 (TD-EFIE) 而言。\n\n这个问题的基础在于 Maxwell 方程组，它控制着电场 $\\mathbf{E}(\\mathbf{r},t)$ 和磁场 $\\mathbf{H}(\\mathbf{r},t)$ 的行为。对于 PEC 物体，其表面的总切向电场必须为零。这一边界条件，结合使用由未知表面电流密度 $\\mathbf{J}(\\mathbf{r},t)$ 产生的推迟势来表示散射场的方法，导出了积分方程。TD-EFIE 源于对电场施加边界条件，而时域磁场积分方程 (TD-MFIE) 则源于对磁场施加边界条件。\n\nTD-CFIE 是这两种公式的线性组合，其构建目的是利用 TD-MFIE 的稳定性特性来缓解在 TD-EFIE MOT 方案中经常观察到的晚期不稳定性。组合算子核为 $K_C(t) = \\eta\\, K_E(t) + (1-\\eta)\\, K_M(t)$，其中 $\\eta \\in [0, 1]$ 是混合参数。\n\n经过空间和时间离散化后，连续积分方程被转换为针对单个电流模态系数的离散线性卷积，记为 $J^n \\approx J(n\\Delta t)$：\n$$\n\\sum_{m=0}^{M} Z_C[m]\\, J^{n-m} = V^n\n$$\n此处，$Z_C[m]$ 是 TD-CFIE 的离散阻抗矩阵元素，$V^n$ 代表采样激励，$M$ 是相互作用的有限记忆深度。\n\n该问题为在高频范围 ($ka \\gg 1$) 下半径为 $a$ 的 PEC 球体，指定了一个对应于 TD-EFIE ($Z_E[m]$) 和 TD-MFIE ($Z_M[m]$) 的离散阻抗权重的代理模型。TD-CFIE 权重是一个凸组合：\n$$\nZ_C[m] = \\eta\\, Z_E[m] + (1-\\eta)\\, Z_M[m], \\quad m=0,1,\\dots,M.\n$$\nEFIE 和 MFIE 权重的具体参数化形式如下：\n$$\nZ_E[0] = z_{E0}, \\quad Z_M[0] = z_{M0} = 0.5\n$$\n$$\nZ_E[m] = A_E\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad Z_M[m] = A_M\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad m\\ge 1\n$$\n参数根据物理设置定义如下：\n- 波数：$k=(ka)/a$\n- 角频率：$\\omega = c\\,k$，其中 $c = 299792458\\,\\mathrm{m/s}$\n- 时间步长：$\\Delta t = T/p = (2\\pi/\\omega)/p$\n- EFIE 自作用项：$z_{E0} = 0.1 + 0.02\\cdot\\pi/(10\\,ka)$\n- 振幅：$A_E = \\min(1.0, 0.02\\,ka)$ 且 $A_M = 0.5\\,A_E$\n- 阻尼因子：$\\alpha = 0.05$\n- 因果延迟：$m_d = 3$\n\n该算法的核心是 MOT 更新方案。通过分离出当前时刻的电流系数 $J^n$（对应于求和中的 $m=0$），我们得到了一个递推关系。假设后续时间步的激励为零（$V^n = 0$ for $n \\ge 1$），则更新规则为：\n$$\nJ^n = -\\frac{1}{Z_C[0]} \\sum_{m=1}^{\\min(M,n)} Z_C[m]\\, J^{n-m},\\quad n\\ge 1\n$$\n该过程以 $J^0 = 1$ 和当 $n  0$ 时 $J^n = 0$ 的条件启动。由于 $z_{E0} > 0$，$z_{M0} > 0$ 且 $\\eta \\in [0, 1]$，项 $Z_C[0] = \\eta z_{E0} + (1-\\eta) z_{M0}$ 保证为正，从而确保更新总是良定义的。\n\n为了找到最优混合参数 $\\eta^\\star$，我们遵循一个数值优化过程。我们将增长度量 $G(\\eta)$ 定义为在整个模拟时间内电流系数的最大绝对值：\n$$\nG(\\eta) = \\max_{0 \\le n \\le N} \\left|J^n\\right|\n$$\n最优参数 $\\eta^\\star$ 是在可能的离散值网格上使该度量最小化的那个值：\n$$\n\\eta^\\star = \\arg\\min_{\\eta \\in \\{0.00,0.01,\\dots,1.00\\}} G(\\eta)\n$$\n每个测试用例的计算过程如下：\n1.  从给定的输入 ($a, ka, p$) 计算派生的物理和模型参数 ($k, \\omega, \\Delta t, z_{E0}, A_E, A_M$) 。\n2.  预先计算当 $m \\in [0, M]$ 时的阻抗权重数组 $Z_E[m]$ 和 $Z_M[m]$。\n3.  以 0.01 为步长，遍历从 0.00 到 1.00 的每个 $\\eta$ 候选值。\n4.  对于每个 $\\eta$，计算相应的 CFIE 权重 $Z_C[m]$。\n5.  使用 MOT 递推关系和初始条件 $J^0=1$，模拟电流 $J^n$ 从 $n=1$ 到 $N$ 的时间演化。\n6.  从得到的结果序列 $J^n$ 计算增长度量 $G(\\eta)$。\n7.  追踪迄今为止观察到的能产生 $G(\\eta)$ 最小值的 $\\eta$。\n8.  最终导致 $G(\\eta)$ 达到全局最小值的 $\\eta$ 即为给定测试用例的最优参数 $\\eta^\\star$。对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the optimal TD-CFIE mixing parameter for several test cases.\n    \"\"\"\n    \n    # Define physical constants and test cases from the problem statement.\n    c = 299792458.0  # Speed of light in m/s\n    \n    test_cases = [\n        # Case 1 (happy path): a=0.1, ka=50, p=20, N=200, M=12\n        {'a': 0.1, 'ka': 50, 'p': 20, 'N': 200, 'M': 12},\n        # Case 2 (boundary coarser time step): a=0.05, ka=50, p=10, N=200, M=12\n        {'a': 0.05, 'ka': 50, 'p': 10, 'N': 200, 'M': 12},\n        # Case 3 (edge lower ka and longer memory): a=0.1, ka=30, p=20, N=400, M=20\n        {'a': 0.1, 'ka': 30, 'p': 20, 'N': 400, 'M': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        optimal_eta = find_optimal_eta(case, c)\n        results.append(optimal_eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\ndef find_optimal_eta(params, c):\n    \"\"\"\n    Finds the optimal mixing parameter eta for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing the parameters for the test case\n                       (a, ka, p, N, M).\n        c (float): The speed of light.\n\n    Returns:\n        float: The optimal mixing parameter eta_star.\n    \"\"\"\n    a = params['a']\n    ka = params['ka']\n    p = params['p']\n    N = params['N']\n    M = params['M']\n    \n    # Given model parameters\n    alpha = 0.05\n    m_d = 3\n    z_M0 = 0.5\n    \n    # Step 1: Calculate derived physical and model parameters\n    k = ka / a\n    omega = c * k\n    T = 2 * np.pi / omega\n    dt = T / p\n    \n    z_E0 = 0.1 + 0.02 * np.pi / (10 * ka)\n    A_E = min(1.0, 0.02 * ka)\n    A_M = 0.5 * A_E\n    \n    # Step 2: Pre-compute the impedance weight arrays Z_E and Z_M\n    m_vals = np.arange(1, M + 1)\n    common_term = np.exp(-alpha * m_vals) * np.sin(omega * m_vals * dt) / (m_vals + m_d)\n    \n    Z_E = np.zeros(M + 1)\n    Z_M = np.zeros(M + 1)\n    \n    Z_E[0] = z_E0\n    Z_M[0] = z_M0\n    \n    Z_E[1:] = A_E * common_term\n    Z_M[1:] = A_M * common_term\n    \n    # Step 3: Optimization loop to find eta_star\n    eta_grid = np.linspace(0.00, 1.00, 101)\n    min_growth = float('inf')\n    optimal_eta = -1.0\n    \n    for eta in eta_grid:\n        # Step 4: Compute CFIE weights Z_C\n        Z_C = eta * Z_E + (1 - eta) * Z_M\n        \n        # Step 5: Run MOT simulation\n        J = np.zeros(N + 1)\n        J[0] = 1.0\n        \n        Z_C0_inv = 1.0 / Z_C[0]\n        \n        for n in range(1, N + 1):\n            # Calculate the summation part of the recurrence\n            sum_term = 0.0\n            limit = min(M, n)\n            for m in range(1, limit + 1):\n                sum_term += Z_C[m] * J[n - m]\n            \n            J[n] = -Z_C0_inv * sum_term\n            \n        # Step 6: Calculate the growth metric G(eta)\n        growth = np.max(np.abs(J))\n        \n        # Step 7: Update the optimal eta\n        if growth  min_growth:\n            min_growth = growth\n            optimal_eta = eta\n            \n    return optimal_eta\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3328585"}]}