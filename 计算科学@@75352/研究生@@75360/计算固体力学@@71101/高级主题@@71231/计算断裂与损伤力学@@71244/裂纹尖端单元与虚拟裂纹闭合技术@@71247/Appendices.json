{"hands_on_practices": [{"introduction": "我们首先从一个基本练习开始，它揭示了奇异单元背后的数学原理。在进行复杂的有限元模拟之前，通过一个简化的解析模型来验证数值方法的核心思想是至关重要的。这项练习将利用已知的裂纹尖端渐近场来推导虚拟裂纹闭合技术 (VCCT) 的离散表达式，旨在从根本上阐明为何四分之一点单元能够如此有效地捕捉裂纹尖端的应力奇异性。[@problem_id:3555960]", "problem": "考虑一个二维各向同性、均质的线性弹性板，在均匀远场拉伸作用下，含有一条长度为 $a$ 的直边裂纹。在裂纹尖端主导区域，近尖端场由线性弹性断裂力学中的 I 型应力强度因子（SIF）$K$ 表示。虚拟裂纹闭合技术（VCCT）通过裂纹尖端周围的节点力和相对位移来近似计算能量释放率 $G$。在此基准问题中，您将实现一个简化的、单元面级别的 VCCT 模型，该模型无需组装全局有限元法（FEM）系统，即可捕捉近尖端场的基本奇异性行为。目标是验证当裂纹尖端面使用四分之一点映射时，由 VCCT 推导出的 $K$ 值收敛于 Westergaard 解预测的解析 $K$ 值。\n\n基本和建模假设：\n- 材料是各向同性的线性弹性体，其杨氏模量为 $E$，泊松比为 $\\nu$。\n- 假设为平面应力条件，因此有效模量为 $E' = E$。\n- 裂纹承受垂直于裂纹面的均匀远场拉伸应力 $\\sigma$（张开型）。\n- 在均匀远场拉伸作用下，无限大板中边裂纹的 I 型应力强度因子解析解为 $K_{\\text{exact}} = \\sigma \\sqrt{\\pi a}$。\n- 对于小的 $r$，裂纹尖端前方沿裂纹扩展线（极角 $\\theta = 0$）的近尖端牵引力场具有奇异形式 $t_y(r) \\sim \\dfrac{K}{\\sqrt{2\\pi r}}$，其中 $r$ 是沿裂纹扩展线距尖端的距离。\n- 对于小的 $r$，紧邻尖端后方的裂纹张开位移（COD）按 $\\delta_y(r) \\sim \\dfrac{K}{E'} \\sqrt{2\\pi r}$ 的比例变化，这与能量释放恒等式 $G = \\dfrac{K^2}{E'}$ 以及渐近场中位移的 $\\sqrt{r}$ 标度关系一致。\n\n单个裂纹尖端面的离散 VCCT 近似：\n- 考虑裂纹尖端前方一个长度为 $\\Delta a$ 的单元面（潜在的裂纹扩展）。在单位厚度下，VCCT I 型能量释放率近似为\n$$\nG_I \\approx \\frac{F_y^{\\text{ahead}} \\, \\delta_y^{\\text{behind}}}{2 \\Delta a},\n$$\n其中 $F_y^{\\text{ahead}}$ 是与尖端前方面相关联的 $y$ 方向节点力，而 $\\delta_y^{\\text{behind}}$ 是位于距尖端 $\\Delta a$ 处、紧邻尖端后方的裂纹上、下表面节点之间的相对 $y$ 位移。\n- 在前方面上奇异牵引力积分的单点积分近似中，节点力建模为\n$$\nF_y^{\\text{ahead}} \\approx \\Delta a \\cdot t_y(r^*),\n$$\n其中采样点 $r^*$ 由单元面映射确定：\n  - 标准双线性映射：$r^* = \\dfrac{\\Delta a}{2}$。\n  - 四分之一点映射：$r^* = \\dfrac{\\Delta a}{4}$。\n- 紧邻尖端后方的 COD 在 $r = \\Delta a$ 处采样：\n$$\n\\delta_y^{\\text{behind}} \\approx \\frac{K}{E'} \\sqrt{2\\pi \\Delta a}.\n$$\n\n计算任务：\n- 给定 $E$、$ \\nu$、$ \\sigma$、$a$ 以及一系列面长度 $\\Delta a$，对于每个 $\\Delta a$，使用上述离散模型在两种映射下计算 VCCT 推导的 SIF 估计值 $K_{\\text{VCCT}}$。使用 $E' = E$（平面应力）、$t_y(r) = \\dfrac{K_{\\text{exact}}}{\\sqrt{2\\pi r}}$ 和 $\\delta_y^{\\text{behind}} = \\dfrac{K_{\\text{exact}}}{E'} \\sqrt{2\\pi \\Delta a}$。\n- 对于每种映射和每个 $\\Delta a$，计算相对误差\n$$\n\\varepsilon = \\frac{\\left| K_{\\text{VCCT}} - K_{\\text{exact}} \\right|}{K_{\\text{exact}}}.\n$$\n- 在单个输出列表中报告误差。\n\n使用的物理单位和常数：\n- 杨氏模量：$E = 210\\times 10^9$ Pa。\n- 泊松比：$\\nu = 0.3$。\n- 平面应力：$E' = E$。\n- 远场拉伸应力：$\\sigma = 100\\times 10^6$ Pa。\n- 裂纹长度：$a = 0.5$ m。\n- 面长度（测试套件）：$\\Delta a \\in \\{0.25\\ \\text{m},\\ 0.05\\ \\text{m},\\ 10^{-6}\\ \\text{m}\\}$。\n\n要求输出和测试套件覆盖范围：\n- 严格按照以下顺序计算下列六种情况的相对误差 $\\varepsilon$（无量纲小数）：\n  1. 四分之一点映射，$\\Delta a = 0.25$ m。\n  2. 四分之一点映射，$\\Delta a = 0.05$ m。\n  3. 四分之一点映射，$\\Delta a = 10^{-6}$ m。\n  4. 标准映射，$\\Delta a = 0.25$ m。\n  5. 标准映射，$\\Delta a = 0.05$ m。\n  6. 标准映射，$\\Delta a = 10^{-6}$ m。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5,result6]”）。\n- 角度（如适用）以弧度为单位。在内部以 $\\text{Pa}\\sqrt{\\text{m}}$ 为单位表示 $K$，所有长度以米为单位。仅以小数形式输出无量纲的相对误差。\n\n该设计确保覆盖：\n- 具有中等 $\\Delta a$ 值的常规“理想路径”情况。\n- 具有非常小 $\\Delta a$ 值的边界情况，用以探测奇异性近似。\n- 面长度相对于裂纹长度较大的一种边缘情况。", "solution": "该问题被评估为具有科学依据、适定、客观且内部一致。所有必要的参数和定义都已提供，可以进行正式求解。\n\n主要目标是计算由虚拟裂纹闭合技术（VCCT）估算的 I 型应力强度因子（SIF）$K_{\\text{I}}$ 与解析值相比的相对误差。这将针对两种不同的有限元映射假设进行：标准双线性映射和四分之一点映射。\n\n首先，我们从线性弹性断裂力学（LEFM）中建立基本关系。对于处于平面应力条件下的材料，I 型能量释放率 $G_{\\text{I}}$ 与 I 型应力强度因子 $K_{\\text{I}}$ 通过以下方程相关联：\n$$\nG_{\\text{I}} = \\frac{K_{\\text{I}}^2}{E'}\n$$\n其中 $E'$ 是有效杨氏模量。对于平面应力，如题所述，$E' = E$。\n\n问题给出了在远场拉伸应力 $\\sigma$ 作用下，板中长度为 $a$ 的边裂纹的 SIF 解析表达式：\n$$\nK_{\\text{exact}} = \\sigma \\sqrt{\\pi a}\n$$\n这是我们的离散近似将与之进行比较的基准值。\n\nVCCT 基于离散（例如，有限元）模型中的节点力和位移，提供了能量释放率的近似计算。对于长度为 $\\Delta a$、单位厚度的单个裂纹尖端面，其公式为：\n$$\nG_{\\text{I, VCCT}} \\approx \\frac{F_y^{\\text{ahead}} \\, \\delta_y^{\\text{behind}}}{2 \\Delta a}\n$$\n此处，$F_y^{\\text{ahead}}$ 是在长度 $\\Delta a$ 上保持裂纹面闭合所需的节点力，而 $\\delta_y^{\\text{behind}}$ 是恰好在当前裂纹尖端后方节点的裂纹张开位移（COD）。\n\n该问题通过使用依赖于 $K_{\\text{exact}}$ 的解析近尖端场解来对这些离散量进行建模，从而简化了完整的有限元分析。\n\nCOD $\\delta_y^{\\text{behind}}$ 使用提供的渐近形式在裂纹尖端后方距离 $r = \\Delta a$ 处进行评估：\n$$\n\\delta_y^{\\text{behind}} = \\frac{K_{\\text{exact}}}{E'} \\sqrt{\\frac{8(\\Delta a)}{\\pi}}\n$$\n等等，问题陈述提供了一个不一致的公式。让我重读一下。“对于小的 $r$，紧邻尖端后方的裂纹张开位移（COD）按 $\\delta_y(r) \\sim \\dfrac{K}{E'} \\sqrt{2\\pi r}$ 的比例变化”。我们来核对一下。标准的 Irwin 关系给出了 I 型问题中沿裂纹面（$\\theta = \\pm \\pi$）的位移场分量 $u_y$ 为 $u_y(r, \\pm\\pi) = \\pm \\frac{K_I}{E'} \\frac{\\kappa+1}{4} \\sqrt{\\frac{r}{2\\pi}}$，其中对于平面应力 $\\kappa = \\frac{3-\\nu}{1+\\nu}$。COD 为 $\\delta_y(r) = u_y(r, \\pi) - u_y(r, -\\pi) = 2 u_y(r, \\pi) = \\frac{K_I}{E'} \\frac{\\kappa+1}{2} \\sqrt{\\frac{r}{2\\pi}}$。代入 $\\kappa$ 得 $\\frac{\\kappa+1}{2} = \\frac{(3-\\nu)/(1+\\nu) + 1}{2} = \\frac{3-\\nu+1+\\nu}{2(1+\\nu)} = \\frac{4}{2(1+\\nu)} = \\frac{2}{1+\\nu}$。当 $\\nu=0.3$ 时，这不是一个简单的常数。然而，还有另一种常见的渐近形式：$u_y(r, \\pm \\pi) = \\pm \\frac{2K_I}{E'} \\sqrt{\\frac{r}{2\\pi}}$。这给出 $\\delta_y(r) = \\frac{4K_I}{E'} \\sqrt{\\frac{r}{2\\pi}} = \\frac{K_I}{E'}\\sqrt{\\frac{8r}{\\pi}}$。问题陈述为 $\\delta_y(r) \\sim \\dfrac{K}{E'} \\sqrt{2\\pi r}$（注意：问题陈述有一个笔误，写的是 $\\sqrt{2 \\pi r}$，这似乎不寻常。标准形式是 $\\sqrt{r/(2\\pi)}$ 乘以某个因子。让我们严格遵循所提供的公式）。问题明确指出，计算时应使用一个不同的公式：$\\delta_y^{\\text{behind}} \\approx \\frac{K_{\\text{exact}}}{E'} \\sqrt{2\\pi \\Delta a}$。我将按照规定使用这个确切的形式继续。\n\n节点力 $F_y^{\\text{ahead}}$ 通过在长度为 $\\Delta a$ 的面上对奇异牵引力场 $t_y(r) = \\frac{K_{\\text{exact}}}{\\sqrt{2\\pi r}}$ 进行积分来近似。使用单点积分方案：\n$$\nF_y^{\\text{ahead}} \\approx \\Delta a \\cdot t_y(r^*) = \\Delta a \\cdot \\frac{K_{\\text{exact}}}{\\sqrt{2\\pi r^*}}\n$$\n其中 $r^*$ 是采样点。\n\n将这些表达式代入 VCCT 的 $G_{\\text{I, VCCT}}$ 公式中：\n$$\nG_{\\text{I, VCCT}} \\approx \\frac{1}{2 \\Delta a} \\left( \\Delta a \\cdot \\frac{K_{\\text{exact}}}{\\sqrt{2\\pi r^*}} \\right) \\left( \\frac{K_{\\text{exact}}}{E'} \\sqrt{2\\pi \\Delta a} \\right)\n$$\n通过消项简化表达式：\n$$\nG_{\\text{I, VCCT}} \\approx \\frac{K_{\\text{exact}}^2}{2 E'} \\frac{\\sqrt{2\\pi \\Delta a}}{\\sqrt{2\\pi r^*}} = \\frac{K_{\\text{exact}}^2}{2 E'} \\sqrt{\\frac{\\Delta a}{r^*}}\n$$\n现在我们使用 LEFM 恒等式，将这个计算出的能量释放率关联回一个估算的 SIF，$K_{\\text{VCCT}}$：\n$$\nG_{\\text{I, VCCT}} = \\frac{K_{\\text{VCCT}}^2}{E'}\n$$\n令 $G_{\\text{I, VCCT}}$ 的两个表达式相等，可得：\n$$\n\\frac{K_{\\text{VCCT}}^2}{E'} = \\frac{K_{\\text{exact}}^2}{2 E'} \\sqrt{\\frac{\\Delta a}{r^*}}\n$$\n求解 $K_{\\text{VCCT}}$：\n$$\nK_{\\text{VCCT}}^2 = \\frac{K_{\\text{exact}}^2}{2} \\sqrt{\\frac{\\Delta a}{r^*}} \\implies K_{\\text{VCCT}} = K_{\\text{exact}} \\sqrt{\\frac{1}{2} \\sqrt{\\frac{\\Delta a}{r^*}}}\n$$\n因此，估算的 SIF 与精确的 SIF 之比为：\n$$\n\\frac{K_{\\text{VCCT}}}{K_{\\text{exact}}} = \\sqrt{\\frac{1}{2} \\sqrt{\\frac{\\Delta a}{r^*}}}\n$$\n相对误差 $\\varepsilon$ 定义为：\n$$\n\\varepsilon = \\frac{\\left| K_{\\text{VCCT}} - K_{\\text{exact}} \\right|}{K_{\\text{exact}}} = \\left| \\frac{K_{\\text{VCCT}}}{K_{\\text{exact}}} - 1 \\right|\n$$\n我们现在分析两种指定的映射情况。\n\n情况1：四分之一点映射\n这种映射是专门为正确表示裂纹尖端的 $1/\\sqrt{r}$ 应变奇异性而设计的。对于长度为 $\\Delta a$ 的单元面，合适的积分采样点是 $r^* = \\Delta a / 4$。\n将此代入我们的比率表达式：\n$$\n\\frac{K_{\\text{VCCT}}}{K_{\\text{exact}}} = \\sqrt{\\frac{1}{2} \\sqrt{\\frac{\\Delta a}{\\Delta a / 4}}} = \\sqrt{\\frac{1}{2} \\sqrt{4}} = \\sqrt{\\frac{1}{2} \\cdot 2} = \\sqrt{1} = 1\n$$\n在这个理想化模型中，四分之一点映射得出 $K_{\\text{VCCT}} = K_{\\text{exact}}$。相对误差为：\n$$\n\\varepsilon_{\\text{qp}} = |1 - 1| = 0\n$$\n这个结果与面长度 $\\Delta a$ 无关。\n\n情况2：标准双线性映射\n对于标准映射，积分点位于面的中心，即 $r^* = \\Delta a / 2$。\n将此代入比率表达式：\n$$\n\\frac{K_{\\text{VCCT}}}{K_{\\text{exact}}} = \\sqrt{\\frac{1}{2} \\sqrt{\\frac{\\Delta a}{\\Delta a / 2}}} = \\sqrt{\\frac{1}{2} \\sqrt{2}} = \\sqrt{\\frac{\\sqrt{2}}{2}}\n$$\n相对误差为：\n$$\n\\varepsilon_{\\text{std}} = \\left| \\sqrt{\\frac{\\sqrt{2}}{2}} - 1 \\right| \\approx |0.8408964 - 1| \\approx 0.1591036\n$$\n在这个特定模型中，此误差也与面长度 $\\Delta a$ 无关。\n\n因此，对于测试套件中提供的所有 $\\Delta a$ 值：\n- 使用四分之一点映射的三种情况的相对误差将为 $0$。\n- 使用标准映射的三种情况将具有约 $0.1591$ 的恒定相对误差。\n\n所需的输出将是按指定顺序排列的这六个误差值的列表。请注意，最终的误差计算不需要物理常数（$E$、$\\nu$、$\\sigma$、$a$），因为它们会相互抵消，这表明在该理想化问题中，该方法的准确性仅取决于单元的几何映射。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error of the SIF estimated by a simplified VCCT model\n    for standard and quarter-point mappings.\n    \"\"\"\n\n    # The problem asks for six specific cases in a fixed order.\n    # 1. Quarter-point mapping, delta_a = 0.25 m\n    # 2. Quarter-point mapping, delta_a = 0.05 m\n    # 3. Quarter-point mapping, delta_a = 1e-6 m\n    # 4. Standard mapping, delta_a = 0.25 m\n    # 5. Standard mapping, delta_a = 0.05 m\n    # 6. Standard mapping, delta_a = 1e-6 m\n    \n    # We can represent these cases as a list of tuples: (mapping_type, delta_a)\n    test_cases = [\n        ('quarter_point', 0.25),\n        ('quarter_point', 0.05),\n        ('quarter_point', 1e-6),\n        ('standard', 0.25),\n        ('standard', 0.05),\n        ('standard', 1e-6)\n    ]\n\n    results = []\n\n    for mapping_type, delta_a in test_cases:\n        # Based on the problem derivation, the relationship between the VCCT-derived SIF\n        # and the exact SIF is:\n        # K_VCCT / K_exact = sqrt( (1/2) * sqrt(delta_a / r_star) )\n        # where r_star is the sampling point for the traction.\n\n        # The relative error epsilon is then:\n        # epsilon = | (K_VCCT / K_exact) - 1 |\n\n        if mapping_type == 'quarter_point':\n            # For quarter-point mapping, the effective sampling point is r_star = delta_a / 4.\n            r_star = delta_a / 4.0\n        elif mapping_type == 'standard':\n            # For standard bilinear mapping, the sampling point is r_star = delta_a / 2.\n            r_star = delta_a / 2.0\n        else:\n            # This case should not be reached with the defined test_cases.\n            raise ValueError(\"Unknown mapping type\")\n\n        # The ratio of the face length to the sampling point distance.\n        # This term simplifies to a constant depending only on the mapping.\n        # For QP: delta_a / (delta_a / 4) = 4\n        # For STD: delta_a / (delta_a / 2) = 2\n        ratio_delta_r = delta_a / r_star\n\n        # The ratio of the estimated SIF to the exact SIF.\n        # As shown in the derivation, this is independent of the physical constants\n        # (E, sigma, a) and the specific value of delta_a.\n        k_ratio = np.sqrt(0.5 * np.sqrt(ratio_delta_r))\n\n        # The relative error.\n        error = np.abs(k_ratio - 1.0)\n        \n        results.append(error)\n\n    # Format the output as a comma-separated list in square brackets.\n    # The map(str, ...) converts each float in the results list to a string.\n    # ','.join(...) concatenates these strings with a comma in between.\n    # The f-string then adds the enclosing square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3555960"}, {"introduction": "接下来，我们将从静态的解析模型转向准静态模拟中更贴近实际的增量式裂纹扩展场景。VCCT 的准确性取决于能否正确地应用其底层的能量原理。这项练习解决了一个在实践中常见的困惑：在计算能量释放率时，应使用裂纹扩展之前还是之后的节点力？通过两种方式计算能量释放率，你将运用能量平衡原理来确定正确的方法。[@problem_id:3555913]", "problem": "一块厚度为 $b$ 的二维线弹性板包含一条长度为 $a$ 的预存尖锐裂纹。近尖端网格采用四分之一点裂纹尖端单元来捕捉应力的平方根反比奇异性。进行了一次准静态增量分析，在两个分别标记为 $n$（扩展前）和 $n+1$（扩展后）的载荷增量之间，裂纹扩展了微小量 $\\Delta a$。使用虚拟裂纹闭合技术 (VCCT) 来估算与此次裂纹扩展相关的应变能释放率 $G$。\n\nVCCT 需要作用于裂纹尖端的节点力以及在裂纹尖端前方测量的裂纹面之间的位移跳跃。对于本次分析，裂纹尖端处的以下分量数据是已知的：\n- 厚度：$b = 3 \\times 10^{-3}~\\text{m}$，\n- 裂纹扩展量：$\\Delta a = 4 \\times 10^{-4}~\\text{m}$，\n- 增量 $n+1$ 时裂纹尖端前方的位移跳跃：$\\Delta u_{x} = 6 \\times 10^{-6}~\\text{m}$ 和 $\\Delta u_{y} = 1.5 \\times 10^{-5}~\\text{m}$，\n- 增量 $n$ 时，距离尖端一个单元的节点处的节点力分量：$F_{x}^{(n)} = 80~\\text{N}$ 和 $F_{y}^{(n)} = 120~\\text{N}$，\n- 增量 $n+1$ 时，距离尖端一个单元的节点处的节点力分量：$F_{x}^{(n+1)} = 88~\\text{N}$ 和 $F_{y}^{(n+1)} = 132~\\text{N}$。\n\n从应变能释放率的定义（即每产生新裂纹面积时总势能的变化）出发，并利用能量平衡，在VCCT框架下，推导出一个计算 $G$ 的合适的离散表达式。然后计算：\n1) $G_{\\text{prev}}$，使用前一个增量 $n$ 的节点力，\n2) $G_{\\text{curr}}$，使用当前增量 $n+1$ 的节点力。\n\n最后，计算差值 $\\Delta G = G_{\\text{curr}} - G_{\\text{prev}}$，并基于准静态裂纹扩展中的能量平衡考虑，论证哪种节点力的选择（当前增量或前一增量）对于VCCT是正确的。将 $\\Delta G$ 的最终数值四舍五入到三位有效数字。最终能量差以 $\\text{J}/\\text{m}^{2}$ 表示。", "solution": "该问题要求使用虚拟裂纹闭合技术 (VCCT) 推导应变能释放率 $G$ 的离散表达式，使用来自两个不同时间增量的节点力数据计算 $G$，并为物理上正确的选择提供理由。\n\n首先，评估问题陈述的有效性。\n给定的数据是：\n- 板厚：$b = 3 \\times 10^{-3}~\\text{m}$\n- 裂纹扩展增量：$\\Delta a = 4 \\times 10^{-4}~\\text{m}$\n- 增量 $n+1$ 时裂纹面间的节点位移跳跃：$\\Delta u_{x} = 6 \\times 10^{-6}~\\text{m}$ 和 $\\Delta u_{y} = 1.5 \\times 10^{-5}~\\text{m}$\n- 增量 $n$ 时裂纹尖端的节点力分量：$F_{x}^{(n)} = 80~\\text{N}$ 和 $F_{y}^{(n)} = 120~\\text{N}$\n- 增量 $n+1$ 时新裂纹尖端的节点力分量：$F_{x}^{(n+1)} = 88~\\text{N}$ 和 $F_{y}^{(n+1)} = 132~\\text{N}$\n\n该问题在科学上基于成熟的线弹性断裂力学理论及其通过有限元法的数值实现。VCCT 是一种标准且广泛使用的技术。该问题是适定的，为获得唯一解提供了所有必要的数据。语言客观而精确。数值在量纲上是一致的，并且在物理上是合理的。因此，该问题是有效的。\n\n应变能释放率 $G$ 定义为每产生单位新裂纹表面积所耗散的能量。它是系统总势能 $\\Pi$ 相对于裂纹面积 $A$ 变化的负速率。\n$$G = -\\frac{d\\Pi}{dA}$$\n在离散的准静态分析中，裂纹在厚度为 $b$ 的板中扩展了 $\\Delta a$，新的裂纹面积为 $\\Delta A = b \\Delta a$。应变能释放率近似为：\n$$G \\approx -\\frac{\\Delta\\Pi}{\\Delta A} = -\\frac{\\Pi_{n+1} - \\Pi_{n}}{b \\Delta a}$$\n其中下标 $n$ 和 $n+1$ 分别表示裂纹扩展前后的状态。\n\nVCCT 基于 Irwin 的一个观点，即裂纹形成过程中释放的能量 ($-\\Delta\\Pi$) 等于将新形成的裂纹表面闭合回其原始未开裂状态所需的机械功 ($\\Delta W_c$)。\n$$-\\Delta\\Pi = \\Delta W_c$$\n在二维有限元模型中，这个闭合功由裂纹尖端的节点力和新分离节点的相对位移计算得出。闭合裂纹所做的功为：\n$$\\Delta W_c = \\frac{1}{2} \\left( F_x \\Delta u_x + F_y \\Delta u_y \\right)$$\n包含因子 $\\frac{1}{2}$ 是因为在闭合过程中，当位移间隙被闭合时，将表面拉回一起的力从其最大值线性减小到零。结合这些表达式，得到 $G$ 的 VCCT 公式：\n$$G = \\frac{\\Delta W_c}{\\Delta A} = \\frac{\\frac{1}{2} \\left( F_x \\Delta u_x + F_y \\Delta u_y \\right)}{b \\Delta a}$$\n这就是所要求的离散表达式。\n\n我们现在进行计算。新裂纹表面的面积是：\n$$\\Delta A = b \\Delta a = (3 \\times 10^{-3}~\\text{m}) \\times (4 \\times 10^{-4}~\\text{m}) = 1.2 \\times 10^{-6}~\\text{m}^2$$\n\n1) 使用增量 $n$ 的力计算 $G_{\\text{prev}}$：\n力是在裂纹扩展前保持裂纹尖端闭合的力，$F_{x}^{(n)} = 80~\\text{N}$ 和 $F_{y}^{(n)} = 120~\\text{N}$。位移是裂纹扩展后的张开值，$\\Delta u_{x} = 6 \\times 10^{-6}~\\text{m}$ 和 $\\Delta u_{y} = 1.5 \\times 10^{-5}~\\text{m}$。\n$$\\Delta W_{\\text{prev}} = \\frac{1}{2} \\left( F_x^{(n)} \\Delta u_x + F_y^{(n)} \\Delta u_y \\right)$$\n$$\\Delta W_{\\text{prev}} = \\frac{1}{2} \\left[ (80) \\times (6 \\times 10^{-6}) + (120) \\times (1.5 \\times 10^{-5}) \\right] = \\frac{1}{2} \\left[ 4.8 \\times 10^{-4} + 18 \\times 10^{-4} \\right]~\\text{J}$$\n$$\\Delta W_{\\text{prev}} = \\frac{1}{2} [ 22.8 \\times 10^{-4} ]~\\text{J} = 1.14 \\times 10^{-3}~\\text{J}$$\n$$G_{\\text{prev}} = \\frac{\\Delta W_{\\text{prev}}}{\\Delta A} = \\frac{1.14 \\times 10^{-3}~\\text{J}}{1.2 \\times 10^{-6}~\\text{m}^2} = 950~\\frac{\\text{J}}{\\text{m}^2}$$\n\n2) 使用增量 $n+1$ 的力计算 $G_{\\text{curr}}$：\n力取自裂纹扩展后的构型，$F_{x}^{(n+1)} = 88~\\text{N}$ 和 $F_{y}^{(n+1)} = 132~\\text{N}$。位移与之前相同。\n$$\\Delta W_{\\text{curr}} = \\frac{1}{2} \\left( F_x^{(n+1)} \\Delta u_x + F_y^{(n+1)} \\Delta u_y \\right)$$\n$$\\Delta W_{\\text{curr}} = \\frac{1}{2} \\left[ (88) \\times (6 \\times 10^{-6}) + (132) \\times (1.5 \\times 10^{-5}) \\right] = \\frac{1}{2} \\left[ 5.28 \\times 10^{-4} + 19.8 \\times 10^{-4} \\right]~\\text{J}$$\n$$\\Delta W_{\\text{curr}} = \\frac{1}{2} [ 25.08 \\times 10^{-4} ]~\\text{J} = 1.254 \\times 10^{-3}~\\text{J}$$\n$$G_{\\text{curr}} = \\frac{\\Delta W_{\\text{curr}}}{\\Delta A} = \\frac{1.254 \\times 10^{-3}~\\text{J}}{1.2 \\times 10^{-6}~\\text{m}^2} = 1045~\\frac{\\text{J}}{\\text{m}^2}$$\n\n差值为：\n$$\\Delta G = G_{\\text{curr}} - G_{\\text{prev}} = 1045~\\frac{\\text{J}}{\\text{m}^2} - 950~\\frac{\\text{J}}{\\text{m}^2} = 95~\\frac{\\text{J}}{\\text{m}^2}$$\n四舍五入到三位有效数字，$\\Delta G = 95.0~\\text{J}/\\text{m}^2$。\n\n关于节点力正确选择的理由：\nVCCT 的物理基础是闭合功。这是作用在裂纹平面上的内聚应力将虚拟裂纹面拉回一起所做的功。在离散有限元模型中，这些应力由在“闭合”构型（增量 $n$）中约束裂纹尖端单个节点的节点反力来表示。这些力是 $F_x^{(n)}$ 和 $F_y^{(n)}$。功是在裂纹张开位移 $\\Delta u_x$ 和 $\\Delta u_y$ 上完成的，而这些位移仅在节点约束被释放且裂纹扩展后才会出现。因此，这些位移是从“张开”构型（增量 $n+1$）中获得的。\n因此，VCCT 的正确且物理上一致的公式要求将裂纹扩展前状态的力乘以裂纹扩展后状态的位移。这对应于 $G_{\\text{prev}}$ 的计算。使用增量 $n+1$ 的力（如计算 $G_{\\text{curr}}$ 时那样）在物理上是不一致的，因为这些力存在于裂纹扩展已经发生后的新裂纹尖端；它们不代表为产生扩展所克服的内聚力。因此，基于能量平衡原则，$G_{\\text{prev}}$ 是 VCCT 的正确实现。", "answer": "$$\\boxed{95.0}$$", "id": "3555913"}, {"introduction": "最后的实践聚焦于计算力学中的一项核心技能：数值验证。单元的理论优势必须在实践中得到证实。这个编程练习将指导你完成一个收敛性研究，以定量地衡量相比于标准二次单元，使用四分之一点单元所带来的性能提升。通过分析合成的模拟数据，你将估算收敛速率，并验证理论预测。[@problem_id:3555912]", "problem": "考虑一个在线性弹性断裂力学 (LEFM) 范畴内承受均匀远场拉伸的二维单边裂纹有限宽度板。该板的裂纹长度为 $a$，宽度为 $W$，厚度（面外）为 $b$，杨氏模量为 $E$，泊松比为 $\\nu$。在均匀拉伸应力 $\\sigma$ 作用下，有限宽度板中单边裂纹的I型应力强度因子 $K_I$ 由广泛使用的 Tada 型几何因子公式给出\n$$\nK_I = \\sigma \\sqrt{\\pi a}\\, F\\!\\left(\\frac{a}{W}\\right),\n$$\n其中\n$$\nF(x) = 1.12 - 0.231\\,x + 10.55\\,x^2 - 21.72\\,x^3 + 30.39\\,x^4,\n\\quad x = \\frac{a}{W}.\n$$\n对于平面应变，有效模量为 $E' = \\frac{E}{1-\\nu^2}$。I型能量释放率 $G$ 与 $K_I$ 的关系为\n$$\nG = \\frac{K_I^2}{E'}.\n$$\n在虚拟裂纹闭合技术 (VCCT) 中，能量释放率 $G$ 是根据裂纹前缘局部的节点力-位移功计算的。对于具有裂纹前缘整合单元的足够细化的网格，当特征单元尺寸 $h \\to 0$ 时，由VCCT计算的 $G$ 收敛到LEFM值。近尖端平方根奇异性的表示方法影响收敛率。常规二次等参单元通常无法精确再现 $\\sqrt{r}$ 奇异性，而四分之一点单元将边中节点放置在四分之一位置，以更准确地捕捉奇异运动学。\n\n将 $K_I(h)$ 估计的收敛率 $p$ 定义为渐近关系式中的指数\n$$\n\\left|K_I(h) - K_I^{\\text{true}}\\right| \\sim C\\, h^p \\quad \\text{as} \\quad h \\to 0,\n$$\n其中 $C > 0$ 为某个常数，$K_I^{\\text{true}}$ 是精确的LEFM值。\n\n您的任务是编写一个程序，针对所提供的合成VCCT能量释放率数据集，使用 $K_I(h) = \\sqrt{E' G(h)}$ 从 $G(h)$ 计算 $K_I(h)$，评估误差 $\\left|K_I(h) - K_I^{\\text{true}}\\right|$，并通过对每种单元类型的 $\\log(\\left|K_I(h) - K_I^{\\text{true}}\\right|)$ 与 $\\log(h)$ 进行最小二乘线性回归来估计收敛率 $p$。回归斜率即为估计的 $p$。\n\n使用国际单位制 (SI单位)：$E$ 的单位是 $\\text{Pa}$，$\\sigma$ 的单位是 $\\text{Pa}$，$a$ 和 $W$ 的单位是 $\\text{m}$，$G$ 的单位是 $\\text{N/m}$。本问题不涉及角度。最终输出（估计的收敛率）是无量纲的，应以浮点数形式报告。本问题不涉及百分比。\n\n测试套件包含三个基准情景。所有案例均使用平面应变，其中 $E' = \\frac{E}{1-\\nu^2}$。对于每个情景，分别提供了代表常规二次单元和四分之一点单元的两个合成VCCT数据集。通过设置以下公式，构建的合成数据在渐近意义上与LEFM和VCCT物理一致：\n$$\nG_{\\text{reg}}(h) = G_{\\text{true}}\\left(1 + \\alpha_{\\text{reg}}\\, h\\right),\n\\qquad\nG_{\\text{qp}}(h) = G_{\\text{true}}\\left(1 + \\alpha_{\\text{qp}}\\, h^2\\right),\n$$\n其中 $G_{\\text{true}} = \\frac{K_I^2}{E'}$ 是LEFM能量释放率，$\\alpha_{\\text{reg}}$ 和 $\\alpha_{\\text{qp}}$ 是特定于情景的正常数。每个情景的网格尺寸 $h$ 均已给出。\n\n情景 $1$ (理想路径):\n- 材料: $E = 2.10 \\times 10^{11}\\,\\text{Pa}$, $\\nu = 0.30$.\n- 几何: $a = 0.05\\,\\text{m}$, $W = 0.50\\,\\text{m}$.\n- 载荷: $\\sigma = 1.00 \\times 10^{8}\\,\\text{Pa}$.\n- 网格尺寸: $h \\in \\{0.02,\\, 0.01,\\, 0.005,\\, 0.0025\\}\\,\\text{m}$.\n- 合成VCCT参数: $\\alpha_{\\text{reg}} = 0.50$, $\\alpha_{\\text{qp}} = 0.30$.\n\n情景 $2$ (几何因子在近半宽裂纹处的敏感性):\n- 材料: $E = 7.00 \\times 10^{10}\\,\\text{Pa}$, $\\nu = 0.33$.\n- 几何: $a = 0.20\\,\\text{m}$, $W = 0.40\\,\\text{m}$.\n- 载荷: $\\sigma = 5.00 \\times 10^{7}\\,\\text{Pa}$.\n- 网格尺寸: $h \\in \\{0.04,\\, 0.02,\\, 0.01,\\, 0.005\\}\\,\\text{m}$.\n- 合成VCCT参数: $\\alpha_{\\text{reg}} = 0.70$, $\\alpha_{\\text{qp}} = 0.40$.\n\n情景 $3$ (使用极细网格的近不可压缩平面应变):\n- 材料: $E = 3.00 \\times 10^{9}\\,\\text{Pa}$, $\\nu = 0.49$.\n- 几何: $a = 0.02\\,\\text{m}$, $W = 0.10\\,\\text{m}$.\n- 载荷: $\\sigma = 5.00 \\times 10^{6}\\,\\text{Pa}$.\n- 网格尺寸: $h \\in \\{0.01,\\, 0.005,\\, 0.0025,\\, 0.00125\\}\\,\\text{m}$.\n- 合成VCCT参数: $\\alpha_{\\text{reg}} = 0.60$, $\\alpha_{\\text{qp}} = 0.35$.\n\n算法要求：\n- 对于每个情景：\n    - 使用给定的 $E$, $\\nu$, $\\sigma$, $a$ 和 $W$，根据LEFM公式计算 $K_I^{\\text{true}}$。\n    - 计算 $E' = \\frac{E}{1-\\nu^2}$。\n    - 计算 $G_{\\text{true}} = \\frac{\\left(K_I^{\\text{true}}\\right)^2}{E'}$。\n    - 对于情景中的每个 $h$，使用上述合成VCCT公式计算 $G_{\\text{reg}}(h)$ 和 $G_{\\text{qp}}(h)$。\n    - 对于每个 $h$，计算 $K_{I,\\text{reg}}(h) = \\sqrt{E' G_{\\text{reg}}(h)}$ 和 $K_{I,\\text{qp}}(h) = \\sqrt{E' G_{\\text{qp}}(h)}$。\n    - 计算绝对误差 $e_{\\text{reg}}(h) = \\left|K_{I,\\text{reg}}(h) - K_I^{\\text{true}}\\right|$ 和 $e_{\\text{qp}}(h) = \\left|K_{I,\\text{qp}}(h) - K_I^{\\text{true}}\\right|$。\n    - 通过对 $\\log(e(h))$ 与 $\\log(h)$ 进行最小二乘拟合来估计收敛率 $p_{\\text{reg}}$ 和 $p_{\\text{qp}}$；拟合的斜率即为估计的 $p$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其中六个估计的斜率按以下顺序排列\n$$\n\\left[p_{\\text{reg},1}, p_{\\text{qp},1}, p_{\\text{reg},2}, p_{\\text{qp},2}, p_{\\text{reg},3}, p_{\\text{qp},3}\\right],\n$$\n其中下标表示情景索引。每个条目必须是一个浮点数。例如，输出格式应类似于 $[p_1,p_2,p_3,p_4,p_5,p_6]$。", "solution": "所提出的问题是计算固体力学领域一个有效且结构良好的练习，具体涉及线性弹性断裂力学（LEFM）中收敛率的数值验证。该问题具有科学依据、内容自洽且客观。它要求实现标准的LEFM公式和一个数值程序，以估计有限元法（FEM）近似的收敛率。所有必要的数据和本构关系都已提供，任务是通过规定的计算工作流程重现已知的理论结果。\n\n问题的核心在于理解有限元类型的选择如何影响裂纹尖端附近应力强度因子计算的准确性。在LEFM中，裂纹尖端前方的应力场表现出一种特征奇异性，其随距尖端距离 $r$ 的变化关系为 $r^{-1/2}$。在FEM中使用的标准多项式基函数，例如常规二次等参单元中的基函数，不能准确地表示这种奇异性。这导致在网格细化时，数值解的收敛率是次优的。具体而言，计算出的应力强度因子 $K_I$ 的误差预计会随着特征单元尺寸 $h$ 线性减小，这对应于 $p=1$ 的收敛率。\n\n为了解决这个缺陷，采用了特殊的“奇异”单元。四分之一点单元是一种常见而巧妙的选择。通过将8节点二次单元的边中节点放置在距裂纹尖端角节点四分之一单元边长的位置，单元的形函数被修改以在应变场中包含一个 $r^{-1/2}$ 项，从而精确地捕捉LEFM奇异性。这种对近尖端场的改进表示导致了更优的二次收敛率，其中 $K_I$ 的误差随 $h^2$ 减小，对应于 $p=2$ 的收敛率。\n\n该问题提供了能量释放率 $G$ 的合成数据，这些数据旨在模拟这种行为。在平面应变条件下，$G$ 和I型应力强度因子 $K_I$ 之间的关系由 $G = \\frac{(1-\\nu^2)K_I^2}{E} = \\frac{K_I^2}{E'}$ 给出，其中 $E$ 是杨氏模量，$\\nu$ 是泊松比，$E' = \\frac{E}{1-\\nu^2}$ 是有效模量。\n\n解决此问题的步骤如下，对所提供的三个情景中的每一个都执行：\n\n首先，我们使用单边裂纹受拉板的解析公式计算精确（或“真实”）的应力强度因子 $K_I^{\\text{true}}$：\n$$\nK_I^{\\text{true}} = \\sigma \\sqrt{\\pi a}\\, F\\!\\left(\\frac{a}{W}\\right)\n$$\n几何因子 $F(x)$ 取决于比率 $x = a/W$，并由以下多项式给出：\n$$\nF(x) = 1.12 - 0.231\\,x + 10.55\\,x^2 - 21.72\\,x^3 + 30.39\\,x^4\n$$\n在已知 $K_I^{\\text{true}}$ 的情况下，计算真实的能量释放率 $G_{\\text{true}}$：\n$$\nG_{\\text{true}} = \\frac{\\left(K_I^{\\text{true}}\\right)^2}{E'}\n$$\n\n其次，我们为一系列特征单元尺寸 $h$ 生成 $G(h)$ 的合成“数值”数据。这些数据旨在复制常规单元和四分之一点单元的预期收敛行为：\n$$\nG_{\\text{reg}}(h) = G_{\\text{true}}\\left(1 + \\alpha_{\\text{reg}}\\, h\\right) \\quad (\\text{用于常规单元})\n$$\n$$\nG_{\\text{qp}}(h) = G_{\\text{true}}\\left(1 + \\alpha_{\\text{qp}}\\, h^2\\right) \\quad (\\text{用于四分之一点单元})\n$$\n这里，$\\alpha_{\\text{reg}}$ 和 $\\alpha_{\\text{qp}}$ 是给定的常数。\n\n第三，对于每个 $h$ 值和每种单元类型，我们通过反转 $G-K_I$ 关系来计算相应的数值应力强度因子 $K_I(h)$：\n$$\nK_I(h) = \\sqrt{E' G(h)}\n$$\n则数值近似的绝对误差为 $e(h) = \\left|K_I(h) - K_I^{\\text{true}}\\right|$。\n\n最后，我们估计收敛率 $p$。渐近误差定义为 $e(h) \\sim C h^p$，其中 $C$ 为某个常数。对两边取自然对数，得到一个线性关系：\n$$\n\\log\\left(e(h)\\right) \\approx p \\log(h) + \\log(C)\n$$\n这是一个直线方程 $y = mx + c$，其中 $y = \\log(e(h))$，$x = \\log(h)$，斜率是收敛率 $m = p$，截距是 $c = \\log(C)$。为了求出 $p$，我们对网格细化研究生成的数据点集 $(\\log(h_i), \\log(e_i))$ 执行简单的线性最小二乘回归。最佳拟合线的斜率就是收敛率 $p$ 的期望估计值。\n\n在所有三个情景中，对两种单元类型重复此过程，总共得出六个 $p$ 的估计值。根据理论背景和合成数据的构建方式，我们预计 $p_{\\text{reg}}$ 的结果将非常接近 $1$，而 $p_{\\text{qp}}$ 的结果将非常接近 $2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the convergence rates for three fracture mechanics scenarios.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Scenario 1\n        {\n            \"E\": 2.10e11, \"nu\": 0.30, \"a\": 0.05, \"W\": 0.50, \"sigma\": 1.00e8,\n            \"h_values\": [0.02, 0.01, 0.005, 0.0025],\n            \"alpha_reg\": 0.50, \"alpha_qp\": 0.30\n        },\n        # Scenario 2\n        {\n            \"E\": 7.00e10, \"nu\": 0.33, \"a\": 0.20, \"W\": 0.40, \"sigma\": 5.00e7,\n            \"h_values\": [0.04, 0.02, 0.01, 0.005],\n            \"alpha_reg\": 0.70, \"alpha_qp\": 0.40\n        },\n        # Scenario 3\n        {\n            \"E\": 3.00e9, \"nu\": 0.49, \"a\": 0.02, \"W\": 0.10, \"sigma\": 5.00e6,\n            \"h_values\": [0.01, 0.005, 0.0025, 0.00125],\n            \"alpha_reg\": 0.60, \"alpha_qp\": 0.35\n        }\n    ]\n\n    results = []\n\n    def geometry_factor_F(x):\n        \"\"\"\n        Computes the geometry factor F(x) using the provided polynomial.\n        x = a/W\n        \"\"\"\n        return 1.12 - 0.231*x + 10.55*x**2 - 21.72*x**3 + 30.39*x**4\n\n    def estimate_convergence_rate(h_values, errors):\n        \"\"\"\n        Estimates the convergence rate p by a least-squares linear regression\n        on log(error) vs log(h).\n        \"\"\"\n        log_h = np.log(h_values)\n        log_e = np.log(errors)\n        \n        # polyfit returns [slope, intercept] for degree 1\n        p, _ = np.polyfit(log_h, log_e, 1)\n        return p\n\n    for case in test_cases:\n        # Extract parameters for the current scenario\n        E = case[\"E\"]\n        nu = case[\"nu\"]\n        a = case[\"a\"]\n        W = case[\"W\"]\n        sigma = case[\"sigma\"]\n        h_values = np.array(case[\"h_values\"])\n        alpha_reg = case[\"alpha_reg\"]\n        alpha_qp = case[\"alpha_qp\"]\n\n        # Step 1: Compute true values\n        x = a / W\n        F_x = geometry_factor_F(x)\n        K_I_true = sigma * np.sqrt(np.pi * a) * F_x\n        \n        E_prime = E / (1.0 - nu**2)\n        G_true = K_I_true**2 / E_prime\n\n        # Step 2: Process Regular Elements\n        G_reg_h = G_true * (1.0 + alpha_reg * h_values)\n        K_I_reg_h = np.sqrt(E_prime * G_reg_h)\n        errors_reg = np.abs(K_I_reg_h - K_I_true)\n        p_reg = estimate_convergence_rate(h_values, errors_reg)\n        results.append(p_reg)\n\n        # Step 3: Process Quarter-Point Elements\n        G_qp_h = G_true * (1.0 + alpha_qp * h_values**2)\n        K_I_qp_h = np.sqrt(E_prime * G_qp_h)\n        errors_qp = np.abs(K_I_qp_h - K_I_true)\n        p_qp = estimate_convergence_rate(h_values, errors_qp)\n        results.append(p_qp)\n\n    # Final print statement in the exact required format.\n    # The problem asks for floating-point numbers. Standard repr is sufficient.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3555912"}]}