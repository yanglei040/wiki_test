{"hands_on_practices": [{"introduction": "基于恢复的误差估计的核心是局部误差指标 $\\eta_K$，它量化了单个单元 $K$ 内的估计误差。本练习提供了一个动手实践的机会，让学生直接根据其在能量范数中的定义，利用有限元应变和预先计算好的恢复应变数据，来计算该指标。掌握这一计算是理解如何评估和定位全局误差的第一步。[@problem_id:3593882]", "problem": "考虑一个小应变、线性、各向同性的平面应变固体中的单个二维有限元 $K$。该材料的杨氏模量为 $E = 210 \\times 10^{9}$ Pa，泊松比为 $\\nu = 0.3$。该单元的面积为 $A = 0.25$ m$^2$，厚度恒为 $t = 0.02$ m，因此其体积为 $V = A \\cdot t$。局部能量范数误差指标的平方 $\\eta_K^2$ 定义为应变误差能量密度的单元积分，即在 $K$ 上的积分 $(\\boldsymbol{\\varepsilon}^* - \\boldsymbol{\\varepsilon}_h) : \\mathbb{C} : (\\boldsymbol{\\varepsilon}^* - \\boldsymbol{\\varepsilon}_h)$，其中 $\\mathbb{C}$ 是平面应变的四阶弹性张量，$\\boldsymbol{\\varepsilon}^*$ 是恢复应变（例如，使用 Zienkiewicz–Zhu 方法通过超收敛片恢复得到），而 $\\boldsymbol{\\varepsilon}_h$ 是有限元应变。在三角形上使用三点对称求积，求积点 $q = 1,2,3$ 处的权重相等，为 $w_q = V/3$。\n\n使用以下在求积点处的采样应变计算 $\\eta_K^2$（所有应变均为平面内对称小应变张量的分量，记为 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$）：\n- 在点 $q=1$ 处：$\\boldsymbol{\\varepsilon}^*(x_1) = (1.2 \\times 10^{-3}, 0.8 \\times 10^{-3}, 0.5 \\times 10^{-3})$ 和 $\\boldsymbol{\\varepsilon}_h(x_1) = (1.0 \\times 10^{-3}, 0.9 \\times 10^{-3}, 0.4 \\times 10^{-3})$。\n- 在点 $q=2$ 处：$\\boldsymbol{\\varepsilon}^*(x_2) = (1.1 \\times 10^{-3}, 0.85 \\times 10^{-3}, 0.6 \\times 10^{-3})$ 和 $\\boldsymbol{\\varepsilon}_h(x_2) = (1.05 \\times 10^{-3}, 0.90 \\times 10^{-3}, 0.55 \\times 10^{-3})$。\n- 在点 $q=3$ 处：$\\boldsymbol{\\varepsilon}^*(x_3) = (1.3 \\times 10^{-3}, 0.75 \\times 10^{-3}, 0.45 \\times 10^{-3})$ 和 $\\boldsymbol{\\varepsilon}_h(x_3) = (1.15 \\times 10^{-3}, 0.80 \\times 10^{-3}, 0.50 \\times 10^{-3})$。\n\n假设为平面应变，Lamé 参数为 $\\lambda$ 和 $\\mu$，并使用精确的小应变线弹性关系式来表示 $\\mathbb{C}$。以焦耳为单位表示 $\\eta_K^2$ 的最终值。将您的答案四舍五入到四位有效数字。", "solution": "用户提供了一个计算固体力学中适定的问题。所有必要的数据都已提供，所要求的计算基于有限元法和连续介质力学的标准、科学合理的原理。因此，该问题被认为是有效的。\n\n目标是计算单个有限元 $K$ 的能量范数误差指标的平方 $\\eta_K^2$。其定义为：\n$$\n\\eta_K^2 = \\int_{K} (\\boldsymbol{\\varepsilon}^* - \\boldsymbol{\\varepsilon}_h) : \\mathbb{C} : (\\boldsymbol{\\varepsilon}^* - \\boldsymbol{\\varepsilon}_h) dV\n$$\n其中 $\\boldsymbol{\\varepsilon}^*$ 是恢复应变，$\\boldsymbol{\\varepsilon}_h$ 是有限元应变，$\\mathbb{C}$ 是平面应变条件下线性各向同性材料的四阶弹性张量。令误差应变为 $\\boldsymbol{\\varepsilon}_e = \\boldsymbol{\\varepsilon}^* - \\boldsymbol{\\varepsilon}_h$。积分变为：\n$$\n\\eta_K^2 = \\int_{K} \\boldsymbol{\\varepsilon}_e : \\mathbb{C} : \\boldsymbol{\\varepsilon}_e \\, dV\n$$\n该积分使用三点数值求积法则进行计算，对于每个求积点 $q \\in \\{1,2,3\\}$，权重相等，为 $w_q = V/3$。单元体积 $V$ 由面积 $A=0.25$ m$^2$ 和厚度 $t=0.02$ m 给出。假设使用一致的国际单位制。\n$$\nV = A \\cdot t = 0.25 \\, \\text{m}^2 \\times 0.02 \\, \\text{m} = 0.005 \\, \\text{m}^3\n$$\n求积权重为 $w_1=w_2=w_3 = V/3 = 0.005/3$ m$^3$。\n因此，该积分可近似为一个和式：\n$$\n\\eta_K^2 \\approx \\sum_{q=1}^{3} w_q \\left[ \\boldsymbol{\\varepsilon}_e(x_q) : \\mathbb{C} : \\boldsymbol{\\varepsilon}_e(x_q) \\right] = \\frac{V}{3} \\sum_{q=1}^{3} \\left[ \\boldsymbol{\\varepsilon}_{e,q} : \\mathbb{C} : \\boldsymbol{\\varepsilon}_{e,q} \\right]\n$$\n项 $\\boldsymbol{\\varepsilon}_e : \\mathbb{C} : \\boldsymbol{\\varepsilon}_e$ 表示误差应变场的应变能密度乘以因子 2。对于线性各向同性材料，应力张量由 $\\boldsymbol{\\sigma} = \\lambda \\, \\text{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I} + 2\\mu \\boldsymbol{\\varepsilon}$ 给出，其中 $\\lambda$ 和 $\\mu$ 是 Lamé 参数。能量密度项等价于 $\\boldsymbol{\\sigma}_e : \\boldsymbol{\\varepsilon}_e$。在平面应变条件下（$\\varepsilon_{zz}=0, \\varepsilon_{xz}=0, \\varepsilon_{yz}=0$），这展开为：\n$$\n\\boldsymbol{\\varepsilon}_e : \\mathbb{C} : \\boldsymbol{\\varepsilon}_e = \\lambda (\\varepsilon_{e,xx} + \\varepsilon_{e,yy})^2 + 2\\mu (\\varepsilon_{e,xx}^2 + \\varepsilon_{e,yy}^2 + 2\\varepsilon_{e,xy}^2)\n$$\nLamé 参数由给定的杨氏模量 $E = 210 \\times 10^{9}$ Pa 和泊松比 $\\nu = 0.3$ 计算得出：\n$$\n\\mu = \\frac{E}{2(1+\\nu)} = \\frac{210 \\times 10^9}{2(1+0.3)} = \\frac{210 \\times 10^9}{2.6} = \\frac{105}{1.3} \\times 10^9 \\, \\text{Pa}\n$$\n$$\n\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} = \\frac{(210 \\times 10^9)(0.3)}{(1+0.3)(1-2(0.3))} = \\frac{63 \\times 10^9}{1.3 \\times 0.4} = \\frac{63 \\times 10^9}{0.52} = \\frac{1575}{13} \\times 10^9 \\, \\text{Pa}\n$$\n接下来，我们计算每个求积点 $q$ 处的误差应变张量 $\\boldsymbol{\\varepsilon}_{e,q}$：\n\\begin{itemize}\n    \\item 对于 $q=1$：$\\boldsymbol{\\varepsilon}_{e,1} = \\boldsymbol{\\varepsilon}^*(x_1) - \\boldsymbol{\\varepsilon}_h(x_1)$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,1} = (1.2 \\times 10^{-3} - 1.0 \\times 10^{-3}, \\, 0.8 \\times 10^{-3} - 0.9 \\times 10^{-3}, \\, 0.5 \\times 10^{-3} - 0.4 \\times 10^{-3})\n    $$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,1} = (0.2 \\times 10^{-3}, \\, -0.1 \\times 10^{-3}, \\, 0.1 \\times 10^{-3})\n    $$\n    \\item 对于 $q=2$：$\\boldsymbol{\\varepsilon}_{e,2} = \\boldsymbol{\\varepsilon}^*(x_2) - \\boldsymbol{\\varepsilon}_h(x_2)$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,2} = (1.1 \\times 10^{-3} - 1.05 \\times 10^{-3}, \\, 0.85 \\times 10^{-3} - 0.90 \\times 10^{-3}, \\, 0.6 \\times 10^{-3} - 0.55 \\times 10^{-3})\n    $$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,2} = (0.05 \\times 10^{-3}, \\, -0.05 \\times 10^{-3}, \\, 0.05 \\times 10^{-3})\n    $$\n    \\item 对于 $q=3$：$\\boldsymbol{\\varepsilon}_{e,3} = \\boldsymbol{\\varepsilon}^*(x_3) - \\boldsymbol{\\varepsilon}_h(x_3)$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,3} = (1.3 \\times 10^{-3} - 1.15 \\times 10^{-3}, \\, 0.75 \\times 10^{-3} - 0.80 \\times 10^{-3}, \\, 0.45 \\times 10^{-3} - 0.50 \\times 10^{-3})\n    $$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,3} = (0.15 \\times 10^{-3}, \\, -0.05 \\times 10^{-3}, \\, -0.05 \\times 10^{-3})\n    $$\n\\end{itemize}\n现在，我们计算每个点的被积项 $I_q = \\boldsymbol{\\varepsilon}_{e,q} : \\mathbb{C} : \\boldsymbol{\\varepsilon}_{e,q}$。我们可以提出因子 $(10^{-3})^2 = 10^{-6}$。\n\\begin{itemize}\n    \\item 对于 $q=1$：\n    $$\n    I_1 = \\left[ \\lambda (0.2 - 0.1)^2 + 2\\mu ( (0.2)^2 + (-0.1)^2 + 2(0.1)^2 ) \\right] \\times 10^{-6}\n    $$\n    $$\n    I_1 = \\left[ \\lambda(0.1)^2 + 2\\mu(0.04 + 0.01 + 0.02) \\right] \\times 10^{-6} = (0.01\\lambda + 0.14\\mu) \\times 10^{-6}\n    $$\n    \\item 对于 $q=2$：\n    $$\n    I_2 = \\left[ \\lambda (0.05 - 0.05)^2 + 2\\mu ( (0.05)^2 + (-0.05)^2 + 2(0.05)^2 ) \\right] \\times 10^{-6}\n    $$\n    $$\n    I_2 = \\left[ \\lambda(0)^2 + 2\\mu(0.0025 + 0.0025 + 0.005) \\right] \\times 10^{-6} = (0.02\\mu) \\times 10^{-6}\n    $$\n    \\item 对于 $q=3$：\n    $$\n    I_3 = \\left[ \\lambda (0.15 - 0.05)^2 + 2\\mu ( (0.15)^2 + (-0.05)^2 + 2(-0.05)^2 ) \\right] \\times 10^{-6}\n    $$\n    $$\n    I_3 = \\left[ \\lambda(0.1)^2 + 2\\mu(0.0225 + 0.0025 + 0.005) \\right] \\times 10^{-6} = (0.01\\lambda + 0.06\\mu) \\times 10^{-6}\n    $$\n\\end{itemize}\n被积项贡献的总和是：\n$$\n\\sum_{q=1}^{3} I_q = ( (0.01\\lambda + 0.14\\mu) + (0.02\\mu) + (0.01\\lambda + 0.06\\mu) ) \\times 10^{-6}\n$$\n$$\n\\sum_{q=1}^{3} I_q = (0.02\\lambda + 0.22\\mu) \\times 10^{-6}\n$$\n现在，代入 $\\lambda$ 和 $\\mu$ 的值：\n$$\n\\sum_{q=1}^{3} I_q = \\left(0.02 \\left(\\frac{1575}{13}\\times 10^9\\right) + 0.22 \\left(\\frac{105}{1.3}\\times 10^9\\right)\\right) \\times 10^{-6}\n$$\n$$\n\\sum_{q=1}^{3} I_q = \\left(\\frac{31.5}{13}\\times 10^9 + \\frac{23.1}{1.3}\\times 10^9\\right) \\times 10^{-6} = \\left(\\frac{31.5}{13}\\times 10^9 + \\frac{231}{13}\\times 10^9\\right) \\times 10^{-6}\n$$\n$$\n\\sum_{q=1}^{3} I_q = \\left(\\frac{262.5}{13}\\times 10^9\\right) \\times 10^{-6} = \\frac{262.5}{13} \\times 10^3 \\, \\text{J/m}^3\n$$\n最后，计算 $\\eta_K^2$：\n$$\n\\eta_K^2 = \\frac{V}{3} \\sum_{q=1}^{3} I_q = \\frac{0.005}{3} \\times \\left(\\frac{262.5}{13} \\times 10^3\\right)\n$$\n$$\n\\eta_K^2 = \\frac{0.005 \\times 262.5 \\times 1000}{3 \\times 13} = \\frac{5 \\times 262.5}{39} = \\frac{1312.5}{39} \\approx 33.653846... \\, \\text{J}\n$$\n根据要求将结果四舍五入到四位有效数字，得到 $33.65$。", "answer": "$$\n\\boxed{33.65}\n$$", "id": "3593882"}, {"introduction": "上一个练习假设恢复应变场是已知的，而本练习将深入探讨它是如何被构造出来的。我们将通过建立并分析加权最小二乘系统，来探索超收敛单元片恢复（SPR）方法，这是 Zienkiewicz-Zhu 方法的基石。该系统用于将一个连续的多项式拟合到不连续的有限元应力数据上，从而揭示恢复过程背后的数学引擎。[@problem_id:3593897]", "problem": "考虑节点周围局部片元上二维线弹性中单个平面内应力分量的超收敛片元恢复 (Superconvergent Patch Recovery, SPR)。设恢复的应力场由一个多项式拟设来近似，其系数由向量 $\\mathbf{a} \\in \\mathbb{R}^{3}$ 收集，使用由 $\\phi_1(x,y)=1$, $\\phi_2(x,y)=x$ 和 $\\phi_3(x,y)=y$ 定义的基 $\\{\\phi_1,\\phi_2,\\phi_3\\}$。假设有 $N$ 个采样点，索引为 $m=1,\\dots,N$，其无量纲局部坐标为 $(x_m,y_m)$，权重为 $w_m \\ge 0$，有限元样本应力为 $s_m$。\n\n定义加权最小二乘泛函\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_m\\,\\bigg(\\sum_{i=1}^{3} a_i\\,\\phi_i(x_m,y_m) - s_m\\bigg)^{2}.\n$$\n从该泛函和有限维优化的变分法出发，推导最小化子的法方程，并证明它们可以写成一个线性系统的形式，该系统由一个对称矩阵乘以 $\\mathbf{a}$ 和一个由加权数据构成的右端向量组成。然后，对于下文给出的具体数据，显式地构造该系统的矩阵和向量，并计算该矩阵的行列式。\n\n使用以下包含 $N=4$ 个点的采样集：\n- 点 $m=1$：$(x_1,y_1)=(0,0)$, $w_1=1$, $s_1=2$。\n- 点 $m=2$：$(x_2,y_2)=(1,0)$, $w_2=2$, $s_2=3$。\n- 点 $m=3$：$(x_3,y_3)=(0,1)$, $w_3=1$, $s_3=4$。\n- 点 $m=4$：$(x_4,y_4)=(1,1)$, $w_4=3$, $s_4=6$。\n\n在构建完系统后，讨论在一般情况下，对于基 $\\{1,x,y\\}$ 和非负权重，法方程中的矩阵可逆的条件。你最终报告的答案必须是根据上述给定数据计算出的矩阵的行列式，表示为一个精确的整数，无单位。不需要四舍五入。所有坐标都是无量纲的，因此所有量都没有单位。", "solution": "根据验证标准对问题陈述进行评估。\n\n### 步骤 1：提取已知条件\n- **问题领域**：二维线弹性中的超收敛片元恢复 (SPR)。\n- **恢复场拟设**：单个应力分量由 $\\sum_{i=1}^{3} a_i\\,\\phi_i(x,y)$ 近似。\n- **系数**：$\\mathbf{a} = [a_1, a_2, a_3]^T \\in \\mathbb{R}^{3}$。\n- **基函数**：$\\{\\phi_1,\\phi_2,\\phi_3\\}$，其中 $\\phi_1(x,y)=1$, $\\phi_2(x,y)=x$ 和 $\\phi_3(x,y)=y$。\n- **采样数据**：一组 $N$ 个采样点，索引为 $m=1,\\dots,N$，具有局部坐标 $(x_m,y_m)$，非负权重 $w_m \\ge 0$ 和有限元样本应力 $s_m$。\n- **待最小化的泛函**：加权最小二乘泛函 $J(\\mathbf{a})=\\sum_{m=1}^{N} w_m\\,\\bigg(\\sum_{i=1}^{3} a_i\\,\\phi_i(x_m,y_m) - s_m\\bigg)^{2}$。\n- **针对 $N=4$ 的具体数据**：\n  - 点 $m=1$：$(x_1,y_1)=(0,0)$, $w_1=1$, $s_1=2$。\n  - 点 $m=2$：$(x_2,y_2)=(1,0)$, $w_2=2$, $s_2=3$。\n  - 点 $m=3$：$(x_3,y_3)=(0,1)$, $w_3=1$, $s_3=4$。\n  - 点 $m=4$：$(x_4,y_4)=(1,1)$, $w_4=3$, $s_4=6$。\n- **任务**：\n  1. 推导 $J(\\mathbf{a})$ 的最小化子的法方程。\n  2. 证明这些方程构成一个具有对称矩阵的线性系统。\n  3. 对于具体数据，显式构造矩阵和右端向量。\n  4. 计算该矩阵的行列式。\n  5. 讨论一般情况下矩阵可逆的条件。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题评估如下：\n- **科学依据**：该问题基于成熟的加权最小二乘法，这是近似理论和数值分析中的一个基本技术。其在超收敛片元恢复中的应用是有限元方法中用于后验误差估计的标准程序。该设置在科学和数学上是合理的。\n- **适定性**：该问题是适定的。最小化一个严格凸的二次泛函会得到一个唯一的解，前提是系统矩阵是可逆的。问题提供了足够的数据和明确的目标来确定一个唯一的解。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。它是自包含的、一致的，并且有科学依据。我将继续进行解答。\n\n待最小化的加权最小二乘泛函由下式给出\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_m\\,\\bigg(\\sum_{i=1}^{3} a_i\\,\\phi_i(x_m,y_m) - s_m\\bigg)^{2}.\n$$\n代入给定的基函数 $\\phi_1(x,y)=1$, $\\phi_2(x,y)=x$ 和 $\\phi_3(x,y)=y$，该泛函变为\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_m\\,\\left(a_1 + a_2x_m + a_3y_m - s_m\\right)^{2}.\n$$\n为了找到最小化该泛函的系数 $\\mathbf{a}=[a_1, a_2, a_3]^T$，我们必须将 $J(\\mathbf{a})$ 对每个系数 $a_k$ 的偏导数设为零。这是凸泛函 $J$ 取得最小值的必要条件。对于 $k=1, 2, 3$：\n$$\n\\frac{\\partial J}{\\partial a_k} = 0.\n$$\n我们来计算这些偏导数。\n对于 $k=1$：\n$$\n\\frac{\\partial J}{\\partial a_1} = \\sum_{m=1}^{N} 2w_m\\,(a_1 + a_2x_m + a_3y_m - s_m) \\frac{\\partial}{\\partial a_1}(a_1 + a_2x_m + a_3y_m) = \\sum_{m=1}^{N} 2w_m\\,(a_1 + a_2x_m + a_3y_m - s_m) = 0.\n$$\n对于 $k=2$：\n$$\n\\frac{\\partial J}{\\partial a_2} = \\sum_{m=1}^{N} 2w_m\\,(a_1 + a_2x_m + a_3y_m - s_m) \\frac{\\partial}{\\partial a_2}(a_1 + a_2x_m + a_3y_m) = \\sum_{m=1}^{N} 2w_mx_m\\,(a_1 + a_2x_m + a_3y_m - s_m) = 0.\n$$\n对于 $k=3$：\n$$\n\\frac{\\partial J}{\\partial a_3} = \\sum_{m=1}^{N} 2w_m\\,(a_1 + a_2x_m + a_3y_m - s_m) \\frac{\\partial}{\\partial a_3}(a_1 + a_2x_m + a_3y_m) = \\sum_{m=1}^{N} 2w_my_m\\,(a_1 + a_2x_m + a_3y_m - s_m) = 0.\n$$\n我们可以将每个方程除以 $2$ 并重新排列各项，将未知系数 $a_i$ 与已知数据 $s_m$ 分开。\n由 $\\frac{\\partial J}{\\partial a_1} = 0$ 可得：\n$$\na_1\\left(\\sum_{m=1}^{N} w_m\\right) + a_2\\left(\\sum_{m=1}^{N} w_mx_m\\right) + a_3\\left(\\sum_{m=1}^{N} w_my_m\\right) = \\sum_{m=1}^{N} w_ms_m.\n$$\n由 $\\frac{\\partial J}{\\partial a_2} = 0$ 可得：\n$$\na_1\\left(\\sum_{m=1}^{N} w_mx_m\\right) + a_2\\left(\\sum_{m=1}^{N} w_mx_m^2\\right) + a_3\\left(\\sum_{m=1}^{N} w_mx_my_m\\right) = \\sum_{m=1}^{N} w_mx_ms_m.\n$$\n由 $\\frac{\\partial J}{\\partial a_3} = 0$ 可得：\n$$\na_1\\left(\\sum_{m=1}^{N} w_my_m\\right) + a_2\\left(\\sum_{m=1}^{N} w_mx_my_m\\right) + a_3\\left(\\sum_{m=1}^{N} w_my_m^2\\right) = \\sum_{m=1}^{N} w_my_ms_m.\n$$\n这个包含三个未知数 $a_1, a_2, a_3$ 的三元线性方程组构成了法方程。它可以写成矩阵形式 $\\mathbf{M}\\mathbf{a} = \\mathbf{b}$，其中：\n$$\n\\mathbf{M} = \\begin{pmatrix}\n\\sum w_m & \\sum w_m x_m & \\sum w_m y_m \\\\\n\\sum w_m x_m & \\sum w_m x_m^2 & \\sum w_m x_m y_m \\\\\n\\sum w_m y_m & \\sum w_m x_m y_m & \\sum w_m y_m^2\n\\end{pmatrix},\n\\quad \\mathbf{a} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix},\n\\quad \\mathbf{b} = \\begin{pmatrix}\n\\sum w_m s_m \\\\\n\\sum w_m x_m s_m \\\\\n\\sum w_m y_m s_m\n\\end{pmatrix}.\n$$\n矩阵 $\\mathbf{M}$ 是对称的，因为 $M_{ij} = M_{ji}$。例如，$M_{12} = \\sum w_m x_m = M_{21}$, $M_{13} = \\sum w_m y_m = M_{31}$, 且 $M_{23} = \\sum w_m x_m y_m = M_{32}$。这完成了任务的第一部分。\n\n接下来，我们使用提供的 $N=4$ 个点的数据来构造 $\\mathbf{M}$ 和 $\\mathbf{b}$。\n数据如下：\n$(x_1, y_1)=(0,0), w_1=1, s_1=2$\n$(x_2, y_2)=(1,0), w_2=2, s_2=3$\n$(x_3, y_3)=(0,1), w_3=1, s_3=4$\n$(x_4, y_4)=(1,1), w_4=3, s_4=6$\n\n我们为矩阵 $\\mathbf{M}$ 计算必要的总和：\n$M_{11} = \\sum w_m = 1+2+1+3 = 7$。\n$M_{12} = M_{21} = \\sum w_m x_m = 1(0) + 2(1) + 1(0) + 3(1) = 0+2+0+3 = 5$。\n$M_{13} = M_{31} = \\sum w_m y_m = 1(0) + 2(0) + 1(1) + 3(1) = 0+0+1+3 = 4$。\n$M_{22} = \\sum w_m x_m^2 = 1(0^2) + 2(1^2) + 1(0^2) + 3(1^2) = 0+2+0+3 = 5$。\n$M_{23} = M_{32} = \\sum w_m x_m y_m = 1(0)(0) + 2(1)(0) + 1(0)(1) + 3(1)(1) = 0+0+0+3 = 3$。\n$M_{33} = \\sum w_m y_m^2 = 1(0^2) + 2(0^2) + 1(1^2) + 3(1^2) = 0+0+1+3 = 4$。\n\n因此，矩阵 $\\mathbf{M}$ 是：\n$$\n\\mathbf{M} = \\begin{pmatrix}\n7 & 5 & 4 \\\\\n5 & 5 & 3 \\\\\n4 & 3 & 4\n\\end{pmatrix}.\n$$\n现在我们为右端向量 $\\mathbf{b}$ 计算总和：\n$b_1 = \\sum w_m s_m = 1(2)+2(3)+1(4)+3(6) = 2+6+4+18 = 30$。\n$b_2 = \\sum w_m x_m s_m = 1(0)(2)+2(1)(3)+1(0)(4)+3(1)(6) = 0+6+0+18 = 24$。\n$b_3 = \\sum w_m y_m s_m = 1(0)(2)+2(0)(3)+1(1)(4)+3(1)(6) = 0+0+4+18 = 22$。\n\n向量 $\\mathbf{b}$ 是：\n$$\n\\mathbf{b} = \\begin{pmatrix}\n30 \\\\\n24 \\\\\n22\n\\end{pmatrix}.\n$$\n问题要求计算矩阵 $\\mathbf{M}$ 的行列式。\n$$\n\\det(\\mathbf{M}) = \\det\\begin{pmatrix}\n7 & 5 & 4 \\\\\n5 & 5 & 3 \\\\\n4 & 3 & 4\n\\end{pmatrix}\n$$\n沿第一行进行代数余子式展开：\n$$\n\\det(\\mathbf{M}) = 7\\begin{vmatrix} 5 & 3 \\\\ 3 & 4 \\end{vmatrix} - 5\\begin{vmatrix} 5 & 3 \\\\ 4 & 4 \\end{vmatrix} + 4\\begin{vmatrix} 5 & 5 \\\\ 4 & 3 \\end{vmatrix}\n$$\n$$\n\\det(\\mathbf{M}) = 7(5 \\cdot 4 - 3 \\cdot 3) - 5(5 \\cdot 4 - 3 \\cdot 4) + 4(5 \\cdot 3 - 5 \\cdot 4)\n$$\n$$\n\\det(\\mathbf{M}) = 7(20 - 9) - 5(20 - 12) + 4(15 - 20)\n$$\n$$\n\\det(\\mathbf{M}) = 7(11) - 5(8) + 4(-5)\n$$\n$$\n\\det(\\mathbf{M}) = 77 - 40 - 20 = 17.\n$$\n该矩阵的行列式为 $17$。\n\n最后，我们讨论矩阵 $\\mathbf{M}$ 可逆的条件。矩阵 $\\mathbf{M}$ 可逆的充要条件是其行列式不为零。$\\mathbf{M}$ 可以写成 $\\mathbf{M} = \\mathbf{P}^T\\mathbf{W}\\mathbf{P}$，其中 $\\mathbf{P}$ 是在采样点处求值的基函数构成的 $N \\times 3$ 矩阵，$\\mathbf{W}$ 是权重的 $N \\times N$ 对角矩阵。\n$$\n\\mathbf{P} = \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ \\vdots & \\vdots & \\vdots \\\\ 1 & x_N & y_N \\end{pmatrix}, \\quad \\mathbf{W} = \\text{diag}(w_1, w_2, \\dots, w_N).\n$$\n$\\mathbf{M}$ 是一个格拉姆矩阵 (Gram matrix)。它奇异的充要条件是矩阵 $\\sqrt{\\mathbf{W}}\\mathbf{P}$ 的列线性相关。假设某个点子集的权重 $w_m$ 严格为正，这等价于 $\\mathbf{P}$ 的列（对于该点子集）线性相关。如果存在一个非零向量 $\\mathbf{c} = [c_1, c_2, c_3]^T$ 使得 $\\mathbf{P}\\mathbf{c} = \\mathbf{0}$，则 $\\mathbf{P}$ 的列线性相关。这对应于条件\n$$\nc_1 \\cdot 1 + c_2 \\cdot x_m + c_3 \\cdot y_m = 0\n$$\n对所有相应权重 $w_m > 0$ 的点 $(x_m, y_m)$ 成立。这是 $(x,y)$ 平面中的一条直线方程。\n因此，矩阵 $\\mathbf{M}$ 奇异的充要条件是所有权重 $w_m > 0$ 的采样点 $(x_m, y_m)$ 共线（位于同一条直线上）。要使 $\\mathbf{M}$ 可逆，我们需要至少 3 个具有正权重的采样点（因为我们要拟合 3 个参数），并且这些点不能共线。在给定问题中，四个点 $(0,0), (1,0), (0,1), (1,1)$ 都具有正权重，并且显然不共线。因此，矩阵 $\\mathbf{M}$ 是可逆的，这与其非零行列式值 $17$ 一致。", "answer": "$$\n\\boxed{17}\n$$", "id": "3593897"}, {"introduction": "后验误差估计的真正威力在于其引导自适应网格细化（AMR）的能力，使得计算能够将精力集中在最需要的地方。这个综合性练习将理论付诸实践，要求学生实现一个完整的工作流程：从计算整个网格的单元指标，到使用 Dörfler 体标记策略来标记需要细化的单元。这项练习弥合了局部误差估计与高效自动化仿真之间的鸿沟。[@problem_id:3593863]", "problem": "实现一个完整的程序，在二维线性弹性问题中，使用基于恢复的能量范数单元误差指标，执行用于自适应网格加密的Dörfler体标记。该程序必须根据给定的三角剖分和预设的连续位移场计算基于恢复的单元指标，然后根据Dörfler准则选择一个最小的被标记单元集。最后，对所提供的测试套件，汇总并打印所选单元的索引。\n\n从二维线性弹性力学的标准设置开始，考虑平面应力条件下的小应变情况。设位移场为一个向量函数 $\\boldsymbol{u} : \\Omega \\subset \\mathbb{R}^2 \\to \\mathbb{R}^2$。无穷小应变张量为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^\\top)$，应力为 $\\boldsymbol{\\sigma} = \\mathbf{C}\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$，其中 $\\mathbf{C}$ 是平面应力条件下的各向同性弹性张量，杨氏模量为 $E$，泊松比为 $\\nu$。考虑将 $\\Omega$ 剖分为三节点线性三角形单元。在每个单元 $K$ 上，标准的有限元法 (FEM) 应变 $\\boldsymbol{\\varepsilon}^h|_K$ 是常数，通过单元应变-位移矩阵由单元节点的位移值得到。\n\n使用Zienkiewicz–Zhu (ZZ) 恢复程序在网格上构建一个恢复应变场 $\\boldsymbol{\\varepsilon}^\\star$。在本问题中，您必须通过对贡献于每个节点的常数单元应变进行面积加权平均来实现节点恢复，并将单元恢复应变 $\\boldsymbol{\\varepsilon}^\\star|_K$ 定义为 $K$ 的三个节点上恢复应变的算术平均值。\n\n将每个单元 $K$ 的平方能量范数指标定义为\n$$\n\\eta_K^2 = \\int_{K} (\\boldsymbol{\\varepsilon}^\\star - \\boldsymbol{\\varepsilon}^h)^\\top \\, \\mathbf{C} \\, (\\boldsymbol{\\varepsilon}^\\star - \\boldsymbol{\\varepsilon}^h)\\, \\mathrm{d}\\Omega.\n$$\n在本问题中，通过单元面积乘以使用常数 $\\boldsymbol{\\varepsilon}^h|_K$ 和单元恢复应变 $\\boldsymbol{\\varepsilon}^\\star|_K$ 计算的能量密度来近似该积分：\n$$\n\\eta_K^2 \\approx |K|\\, (\\boldsymbol{\\varepsilon}^\\star|_K - \\boldsymbol{\\varepsilon}^h|_K)^\\top \\mathbf{C} \\, (\\boldsymbol{\\varepsilon}^\\star|_K - \\boldsymbol{\\varepsilon}^h|_K).\n$$\n\n实现Dörfler体标记，以选择满足以下条件的最小单元集 $\\mathcal{M}$\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\ge \\theta \\sum_{K} \\eta_K^2,\n$$\n其中 $0 < \\theta < 1$。使用以下确定性最小化规则：按 $\\eta_K^2$ 值降序对单元进行排序，并按单元索引升序打破平局；然后按此顺序包含单元，直到满足不等式。如果 $\\sum_K \\eta_K^2$ 在数值上为零，则使用浮点容差 $\\varepsilon = 10^{-12}$ 将其视为零，并返回空集（没有标记任何单元）。\n\n您必须使用国际单位制计算所有相关量。弹性张量 $\\mathbf{C}$ 必须根据 $E$（单位：帕斯卡）和 $\\nu$（无量纲）在平面应力条件下构建。面积单位必须是平方米。尽管中间变量有单位，但程序的最终输出是单元索引列表，因此是无量纲的。\n\n测试套件规范：\n- 对于每个测试用例，程序会接收一个网格和一个由解析函数在节点坐标处求值指定的位移场、材料参数以及标记参数 $\\theta$。您的程序必须计算所有单元的 $\\eta_K^2$，然后按规定返回被标记单元的索引。\n\n使用以下三个测试用例：\n1. 零误差的理想情况：\n   - 域：包含两个三角形的单位正方形，\n     - 节点（从 $0$ 开始索引）：$(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$。\n     - 单元：$K_0 = (0,1,2)$ 和 $K_1 = (0,2,3)$（每个三元组是节点索引列表）。\n   - 位移场：$u_x(x,y) = 0.1\\,x + 0.0\\,y$， $u_y(x,y) = 0.0\\,x + 0.05\\,y$。\n   - 材料：$E = 2.10\\times 10^{11}$ Pa, $\\nu = 0.3$。\n   - 标记参数：$\\theta = 0.6$。\n   - 预期行为：精确的线性场产生 $\\eta_K^2 \\approx 0$；根据容差规则，标记集为空列表。\n\n2. 加密网格上的非平凡二次场：\n   - 域：单位正方形，划分为一个均匀的 $2\\times 2$ 三角形网格，\n     - 节点（从 $0$ 开始索引）：$(0,0)$, $(0.5,0)$, $(1,0)$, $(0,0.5)$, $(0.5,0.5)$, $(1,0.5)$, $(0,1)$, $(0.5,1)$, $(1,1)$。\n     - 单元：左下角的单元格由其左下角到右上角的对角线分割，整个网格保持一致。具体来说，三角形为 $K_0=(0,1,4)$、 $K_1=(0,4,3)$、 $K_2=(1,2,5)$、 $K_3=(1,5,4)$、 $K_4=(3,4,7)$、 $K_5=(3,7,6)$、 $K_6=(4,5,8)$、 $K_7=(4,8,7)$。\n   - 位移场：$u_x(x,y) = 0.02\\,x^2$，$u_y(x,y) = 0.03\\,y^2$。\n   - 材料：$E = 2.10\\times 10^{11}$ Pa, $\\nu = 0.3$。\n   - 标记参数：$\\theta = 0.5$。\n   - 预期行为：非零指标；Dörfler标记选择一个最小的单元集，其捕获的总平方指标和至少为一半。\n\n3. 使用大体参数的情况：\n   - 与测试用例2相同的网格和材料。\n   - 位移场：$u_x(x,y) = 0.02\\,x^2$，$u_y(x,y) = 0.03\\,y^2$。\n   - 标记参数：$\\theta = 0.95$。\n   - 预期行为：近乎完全标记；该集合包含大部分单元。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个条目对应一个测试用例，其本身是按误差贡献从大到小（即按标记包含的顺序）排列的被标记单元索引列表。例如，输出必须如下所示：`[[i_0_1,i_0_2,...],[i_1_1,...],[i_2_1,...]]`，其中 $i_{t,k}$ 是整数。使用从零开始的单元索引。\n\n您还必须在附带的解决方案中解释从线性弹性和应变恢复推导能量范数指标的过程，Dörfler标记的算法结构，并为实践中使用的典型体参数 $\\theta$ 的选择提供基于原理的合理解释。", "solution": "该问题要求在二维线性弹性问题中，实现一个基于恢复的误差指标和用于自适应网格加密的Dörfler体标记策略。解决方案分为三部分：误差估计和标记程序的理论阐述，算法步骤的描述，以及最终的实现细节。\n\n### 基于原理的设计\n\n#### 1. 线性弹性中的能量范数误差估计\n\n在线性弹性的有限元法 (FEM) 中，主要目标是找到真实（但未知）位移场 $\\boldsymbol{u}$ 的一个近似位移场 $\\boldsymbol{u}^h$。近似的质量通常用能量范数下的误差 $\\boldsymbol{e} = \\boldsymbol{u} - \\boldsymbol{u}^h$ 来衡量。误差的平方能量范数定义为：\n$$\n\\|\\boldsymbol{e}\\|_E^2 = \\int_{\\Omega} (\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) - \\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h))^\\top \\, \\mathbf{C} \\, (\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) - \\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h)) \\, \\mathrm{d}\\Omega\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$ 是从位移场 $\\boldsymbol{u}$ 推导出的应变张量，$\\mathbf{C}$ 是本构（弹性）张量。该积分表示误差场的应变能。在实际情况中，精确解 $\\boldsymbol{u}$ 是不可用的，这使得直接计算 $\\|\\boldsymbol{e}\\|_E^2$ 成为不可能。\n\n后验误差估计旨在仅使用计算出的有限元解 $\\boldsymbol{u}^h$ 和问题数据来近似此误差。全局误差表示为网格剖分 $\\mathcal{T}$ 中每个单元 $K$ 的局部贡献之和：\n$$\n\\|\\boldsymbol{e}\\|_E^2 = \\sum_{K \\in \\mathcal{T}} \\int_{K} (\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) - \\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h))^\\top \\, \\mathbf{C} \\, (\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) - \\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h)) \\, \\mathrm{d}\\Omega = \\sum_{K \\in \\mathcal{T}} \\eta_K^2\n$$\n这里，$\\eta_K$ 是单元 $K$ 的局部误差指标。后验估计的关键是为 $\\eta_K$ 找到一个可计算的近似值。\n\n#### 2. Zienkiewicz-Zhu (ZZ) 恢复与误差指示\n\nZienkiewicz-Zhu (ZZ) 恢复方法是一种广泛使用的误差估计技术。它基于这样一个观察：虽然有限元位移解 $\\boldsymbol{u}^h$ 在单元边界上是连续的，但其导数，即有限元应变 $\\boldsymbol{\\varepsilon}^h$，通常是不连续且精度较低的。其核心思想是通过对不连续场 $\\boldsymbol{\\varepsilon}^h$ 进行后处理，来“恢复”一个更精确、连续的应变场，记为 $\\boldsymbol{\\varepsilon}^\\star$。\n\nZZ类型估计器的基本假设是，恢复应变 $\\boldsymbol{\\varepsilon}^\\star$ 是对真实应变 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$ 的一个比原始有限元应变 $\\boldsymbol{\\varepsilon}^h$ 好得多的近似。这使我们能够将应变误差近似为：\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) - \\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h) \\approx \\boldsymbol{\\varepsilon}^\\star - \\boldsymbol{\\varepsilon}^h\n$$\n将此近似代入单元误差指标的定义中，得到可计算的ZZ误差指标：\n$$\n\\eta_K^2 = \\int_{K} (\\boldsymbol{\\varepsilon}^\\star - \\boldsymbol{\\varepsilon}^h)^\\top \\, \\mathbf{C} \\, (\\boldsymbol{\\varepsilon}^\\star - \\boldsymbol{\\varepsilon}^h) \\, \\mathrm{d}\\Omega\n$$\n该问题指定了构建 $\\boldsymbol{\\varepsilon}^\\star$ 的一个特定过程：\n1.  **节点应变恢复**：对网格中的每个节点，其恢复应变 $\\boldsymbol{\\varepsilon}^\\star_{node}$ 通过对共享该节点的所有单元的常数有限元应变 $\\boldsymbol{\\varepsilon}^h$ 进行面积加权平均来计算。\n2.  **单元恢复应变**：对每个单元 $K$，其常数恢复应变 $\\boldsymbol{\\varepsilon}^\\star|_K$ 通过计算其三个顶点上恢复应变的算术平均值来得到。\n3.  **指标近似**：通过假设被积函数在单元上为常数，使用单元常数应变 $\\boldsymbol{\\varepsilon}^h|_K$ 和 $\\boldsymbol{\\varepsilon}^\\star|_K$ 来近似 $\\eta_K^2$ 的积分。这导出了如下代数表达式：\n    $$\n    \\eta_K^2 \\approx |K|\\, (\\boldsymbol{\\varepsilon}^\\star|_K - \\boldsymbol{\\varepsilon}^h|_K)^\\top \\mathbf{C} \\, (\\boldsymbol{\\varepsilon}^\\star|_K - \\boldsymbol{\\varepsilon}^h|_K)\n    $$\n    其中 $|K|$ 是单元 $K$ 的面积。\n\n#### 3. Dörfler体标记\n\n一旦所有单元的误差指标 $\\eta_K^2$ 计算完毕，自适应网格加密 (AMR) 就会只对那些对总误差贡献最大的单元进行加密。Dörfler标记为选择这组单元提供了一个稳健的策略。\n\n给定一个体参数 $0 < \\theta < 1$，Dörfler准则要求选择一个最小的单元集 $\\mathcal{M}$ 进行加密，使得它们的误差指标之和至少占总估计误差的 $\\theta$ 部分：\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\ge \\theta \\sum_{K \\in \\mathcal{T}} \\eta_K^2\n$$\n最小化条件通过以下确定性算法来满足：\n1.  计算网格 $\\mathcal{T}$ 中每个单元 $K$ 的平方指标 $\\eta_K^2$。\n2.  计算总的估计平方误差 $\\eta_{total}^2 = \\sum_{K \\in \\mathcal{T}} \\eta_K^2$。\n3.  根据单元的 $\\eta_K^2$ 值按降序排序。为确保确定性，任何平局都通过按原始索引升序对具有相等指标的单元进行排序来打破。\n4.  遍历排序后的单元列表，将其 $\\eta_K^2$ 值累加到一个运行总和中。将每个单元添加到标记集 $\\mathcal{M}$ 中。\n5.  当累积和首次达到或超过目标值 $\\theta \\cdot \\eta_{total}^2$ 时停止。\n\n最终得到的集合 $\\mathcal{M}$ 包含估计误差最大的单元，这些单元是进行细分以提高下一次有限元求解整体精度的主要候选者。\n\n参数 $\\theta$ 控制加密的积极性。较小的 $\\theta$（例如，$0.2-0.4$）仅针对误差最显著的单元，这对于具有尖锐奇异点的问题很有效。较大的 $\\theta$（例如，$0.7-0.9$）会导致一个更大的标记集，接近于均匀加密，这可能适用于误差分布更均匀的情况。在实践中，一个常见且平衡的选择是 $\\theta \\approx 0.5$。\n\n### 算法实现\n\n对于每个测试用例，程序将执行以下操作序列：\n1.  **初始化**：定义网格（节点坐标和单元连接关系）、材料属性（$E, \\nu$）和标记参数 $\\theta$。使用 $E$ 和 $\\nu$ 构建平面应力弹性矩阵 $\\mathbf{C}$。\n2.  **计算有限元应变 $\\boldsymbol{\\varepsilon}^h$**：对每个单元，计算应变-位移矩阵 $B_K$ 和面积 $|K|$。根据给定的解析位移函数，评估节点位移 $d_K$。计算单元常数应变 $\\boldsymbol{\\varepsilon}^h_K = B_K d_K$。\n3.  **计算恢复的节点应变 $\\boldsymbol{\\varepsilon}^\\star_{node}$**：对每个节点，将其所有相邻单元的应变与面积的乘积 $(\\boldsymbol{\\varepsilon}^h_K \\cdot |K|)$ 相加，然后除以这些单元的面积总和。\n4.  **计算恢复的单元应变 $\\boldsymbol{\\varepsilon}^\\star_K$**：对每个单元，取其三个节点上恢复应变的平均值。\n5.  **计算误差指标**：对每个单元，计算应变误差差 $\\Delta\\boldsymbol{\\varepsilon}_K = \\boldsymbol{\\varepsilon}^\\star_K - \\boldsymbol{\\varepsilon}^h_K$，然后计算平方指标 $\\eta_K^2 = |K|\\, (\\Delta\\boldsymbol{\\varepsilon}_K^\\top \\mathbf{C} \\Delta\\boldsymbol{\\varepsilon}_K)$。\n6.  **执行Dörfler标记**：将所有指标相加得到 $\\eta_{total}^2$。如果此和低于容差 ($10^{-12}$)，则返回一个空集。否则，将指标按降序排序（并处理平局），然后选择单元，直到其累积和达到 $\\theta \\cdot \\eta_{total}^2$。按包含顺序收集所选单元的索引。\n7.  **最终输出**：将所有测试用例的被标记索引列表按指定格式格式化为单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    class TestCaseSolver:\n        \"\"\"\n        Encapsulates the logic for solving one test case of Dörfler marking.\n        \"\"\"\n        def __init__(self, nodes, elements, E, nu, theta, u_func):\n            self.nodes = np.array(nodes, dtype=float)\n            self.elements = np.array(elements, dtype=int)\n            self.E = float(E)\n            self.nu = float(nu)\n            self.theta = float(theta)\n            self.u_func = u_func\n            self.num_nodes = self.nodes.shape[0]\n            self.num_elements = self.elements.shape[0]\n\n            # Plane stress elasticity matrix C for [exx, eyy, gxy]\n            c1 = self.E / (1 - self.nu**2)\n            c2 = self.E * self.nu / (1 - self.nu**2)\n            c3 = self.E / (2 * (1 + self.nu))  # Shear modulus G\n            self.C = np.array([[c1, c2, 0],\n                               [c2, c1, 0],\n                               [0,  0, c3]], dtype=float)\n\n        def _compute_fem_strains(self):\n            \"\"\"\n            Computes the constant FEM strain for each element.\n            \"\"\"\n            self.elem_strains_h = np.zeros((self.num_elements, 3))\n            self.elem_areas = np.zeros(self.num_elements)\n\n            for i, elem_nodes_indices in enumerate(self.elements):\n                node_coords = self.nodes[elem_nodes_indices]\n                \n                # Nodal coordinates\n                x1, y1 = node_coords[0]\n                x2, y2 = node_coords[1]\n                x3, y3 = node_coords[2]\n\n                # Element area\n                area = 0.5 * np.abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n                self.elem_areas[i] = area\n\n                if area = 1e-15:  # Degenerate element\n                    continue\n                \n                # B matrix components\n                b1, b2, b3 = y2 - y3, y3 - y1, y1 - y2\n                c1_b, c2_b, c3_b = x3 - x2, x1 - x3, x2 - x1\n\n                # Strain-displacement matrix B\n                B = (1 / (2 * area)) * np.array([\n                    [b1, 0,  b2, 0,  b3, 0 ],\n                    [0,  c1_b, 0,  c2_b, 0,  c3_b],\n                    [c1_b, b1, c2_b, b2, c3_b, b3]\n                ])\n\n                # Nodal displacement vector d\n                d = np.zeros(6)\n                for j, node_idx in enumerate(elem_nodes_indices):\n                    pos = self.nodes[node_idx]\n                    ux, uy = self.u_func(pos[0], pos[1])\n                    d[2*j] = ux\n                    d[2*j + 1] = uy\n                \n                # Element strain epsilon_h = B * d\n                self.elem_strains_h[i] = B @ d\n\n        def _compute_recovered_strains(self):\n            \"\"\"\n            Computes the recovered strain field epsilon_star.\n            \"\"\"\n            # 1. Nodal recovery by area-weighted averaging\n            nodal_strains_star_num = np.zeros((self.num_nodes, 3))\n            nodal_areas_sum = np.zeros(self.num_nodes)\n\n            for i, elem_nodes_indices in enumerate(self.elements):\n                area = self.elem_areas[i]\n                strain_h = self.elem_strains_h[i]\n                for node_idx in elem_nodes_indices:\n                    nodal_strains_star_num[node_idx] += strain_h * area\n                    nodal_areas_sum[node_idx] += area\n\n            # Avoid division by zero for nodes not in any element\n            valid_nodes = nodal_areas_sum > 1e-15\n            self.nodal_strains_star = np.zeros((self.num_nodes, 3))\n            self.nodal_strains_star[valid_nodes] = \\\n                nodal_strains_star_num[valid_nodes] / nodal_areas_sum[valid_nodes, np.newaxis]\n\n            # 2. Element-wise recovered strain by averaging nodal values\n            self.elem_strains_star = np.zeros((self.num_elements, 3))\n            for i, elem_nodes_indices in enumerate(self.elements):\n                self.elem_strains_star[i] = np.mean(self.nodal_strains_star[elem_nodes_indices], axis=0)\n        \n        def _compute_indicators(self):\n            \"\"\"\n            Computes the squared energy-norm indicator for each element.\n            \"\"\"\n            self.indicators_sq = np.zeros(self.num_elements)\n            strain_diff = self.elem_strains_star - self.elem_strains_h\n            \n            for i in range(self.num_elements):\n                delta_eps = strain_diff[i]\n                # indicator^2 = area * (delta_eps^T * C * delta_eps)\n                energy_density = delta_eps.T @ self.C @ delta_eps\n                self.indicators_sq[i] = self.elem_areas[i] * energy_density\n\n        def _perform_doerfler_marking(self):\n            \"\"\"\n            Performs Dörfler bulk marking to select elements for refinement.\n            \"\"\"\n            total_indicator_sq_sum = np.sum(self.indicators_sq)\n\n            # Handle zero-error case\n            if total_indicator_sq_sum = 1e-12:\n                return []\n\n            target_sum = self.theta * total_indicator_sq_sum\n\n            # Create tuples of (-indicator, index) for sorting\n            # Sort by descending indicator, then ascending index for tie-breaking\n            indexed_indicators = [(-self.indicators_sq[i], i) for i in range(self.num_elements)]\n            indexed_indicators.sort()\n\n            marked_indices = []\n            current_sum = 0.0\n            for neg_indicator, index in indexed_indicators:\n                if current_sum >= target_sum:\n                    break\n                current_sum += -neg_indicator\n                marked_indices.append(index)\n            \n            return marked_indices\n\n        def run(self):\n            \"\"\"\n            Runs the full analysis for the test case.\n            \"\"\"\n            self._compute_fem_strains()\n            self._compute_recovered_strains()\n            self._compute_indicators()\n            marked_set = self._perform_doerfler_marking()\n            return marked_set\n\n    # Test Suite Specification\n    test_cases = [\n        # Case 1: Happy path with zero error\n        {\n            \"nodes\": [(0,0), (1,0), (1,1), (0,1)],\n            \"elements\": [(0,1,2), (0,2,3)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.6,\n            \"u_func\": lambda x, y: (0.1*x, 0.05*y)\n        },\n        # Case 2: Nontrivial quadratic field on a refined mesh\n        {\n            \"nodes\": [(0,0), (0.5,0), (1,0), (0,0.5), (0.5,0.5), (1,0.5), (0,1), (0.5,1), (1,1)],\n            \"elements\": [(0,1,4), (0,4,3), (1,2,5), (1,5,4), (3,4,7), (3,7,6), (4,5,8), (4,8,7)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.5,\n            \"u_func\": lambda x, y: (0.02*x**2, 0.03*y**2)\n        },\n        # Case 3: Boundary regime with large bulk parameter\n        {\n            \"nodes\": [(0,0), (0.5,0), (1,0), (0,0.5), (0.5,0.5), (1,0.5), (0,1), (0.5,1), (1,1)],\n            \"elements\": [(0,1,4), (0,4,3), (1,2,5), (1,5,4), (3,4,7), (3,7,6), (4,5,8), (4,8,7)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.95,\n            \"u_func\": lambda x, y: (0.02*x**2, 0.03*y**2)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        solver = TestCaseSolver(\n            nodes=case[\"nodes\"],\n            elements=case[\"elements\"],\n            E=case[\"E\"],\n            nu=case[\"nu\"],\n            theta=case[\"theta\"],\n            u_func=case[\"u_func\"]\n        )\n        result = solver.run()\n        all_results.append(result)\n\n    # Final print statement in the specified format without spaces.\n    inner_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        inner_results.append(inner_str)\n    \n    print(f\"[{','.join(inner_results)}]\")\n\nsolve()\n```", "id": "3593863"}]}