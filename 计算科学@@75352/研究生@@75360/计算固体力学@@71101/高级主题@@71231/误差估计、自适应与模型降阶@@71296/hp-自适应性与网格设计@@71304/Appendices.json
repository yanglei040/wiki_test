{"hands_on_practices": [{"introduction": "在任何自适应有限元分析中，第一步都是识别哪些单元对总误差的贡献最大。此练习将引导您应用Dörfler标记法，这是一种基于后验误差估计的、理论上可靠且广泛使用的单元选择策略[@problem_id:3571719]。通过这个简单的计算，您将掌握如何以最少数量的单元来捕获大部分误差，这是实现高效自适应算法的关键一步。", "problem": "在二维平面应变线性弹性分析中，使用有限元法（FEM）考虑一种结合了单元细分（$h$-加密）和多项式阶次提升（$p$-加密）的自适应加密策略，通常称为$hp$-自适应。设采用后验误差估计来指导加密，通过分配非负的单元尺度指示子 $\\{\\eta_{i}\\}$ 来估计离散误差能量范数的局部贡献。一种常见的选择策略是Dörfler标记法，该方法要求选择一个最小的单元子集，使其指示子之和达到总指示子和的特定比例。假设一个包含五个单元的网格，其单元指示子由多重集 $\\{0.5, 0.3, 0.1, 0.05, 0.05\\}$ 给出，Dörfler标记参数为 $\\theta = 0.5$。在误差指示子相对于全局能量范数代理是可加的，并且执行标记是为了以最小基数满足Dörfler准则的假设下，确定必须标记的最小单元数。请以单个整数形式提供最终答案。无需四舍五入，也无需单位。", "solution": "用户提供了一个关于有限元法（FEM）中自适应加密策略的问题陈述。本回应将首先验证问题的完整性，如果有效，则继续进行完整解答。\n\n### 第1步：提取已知条件\n- **分析类型**：使用有限元法（FEM）的二维平面应变线性弹性分析。\n- **加密策略**：$hp$-自适应。\n- **误差估计**：后验估计，使用单元尺度误差指示子 $\\{\\eta_{i}\\}$。\n- **标记策略**：Dörfler标记。\n- **Dörfler准则**：选择一个最小的单元子集，使得其指示子之和达到总指示子和的一个由参数 $\\theta$ 定义的指定比例。\n- **网格数据**：网格包含 $5$ 个单元。\n- **误差指示子**：单元指示子的多重集为 $\\{\\eta_{i}\\} = \\{0.5, 0.3, 0.1, 0.05, 0.05\\}$。\n- **Dörfler参数**：$\\theta = 0.5$。\n- **假设**：误差指示子相对于全局能量范数代理是可加的。\n- **目标**：确定为满足Dörfler准则必须标记的最小单元数。\n\n### 第2步：使用提取的已知条件进行验证\n根据既定的验证标准对问题陈述进行评估。\n- **科学依据**：该问题在自适应有限元方法理论中有充分的依据，这是计算力学和数值分析中的一个标准且重要的课题。Dörfler标记（也称为 bulk chasing）是可证明最优自适应算法的基石。所有概念在科学上都是合理的。\n- **适定性**：该问题是适定的。它提供了一套完整的数据（指示子、标记参数）和一个清晰、明确的规则（具有最小基数的Dörfler准则），从而导向一个唯一的解。\n- **客观性**：语言精确、量化，并且没有任何主观性或偏见。\n\n问题陈述没有表现出任何诸如科学上不合理、不完整、矛盾或模棱两可的缺陷。它提出了一个计算科学中的标准、定义明确的任务。\n\n### 第3步：结论与行动\n该问题被判定为**有效**。将推导解答。\n\n### 解答推导\n该问题要求将Dörfler标记策略应用于一组给定的单元误差指示子。目标是识别出用于加密的最小单元子集，其误差指示子之和达到某个阈值。\n\n设网格中所有单元的集合为 $\\mathcal{T}$。单元数量为 $|\\mathcal{T}| = 5$。\n单元尺度误差指示子由多重集 $\\{\\eta_i\\} = \\{0.5, 0.3, 0.1, 0.05, 0.05\\}$ 给出。\nDörfler标记参数为 $\\theta = 0.5$。\n\nDörfler标记准则要求找到一个被标记单元的子集 $\\mathcal{M} \\subseteq \\mathcal{T}$，使得满足两个条件：\n$1$. 被标记单元的指示子之和至少是所有指示子总和的 $\\theta$ 倍。在数学上，这表示为：\n$$ \\sum_{\\eta \\in \\mathcal{M}} \\eta \\ge \\theta \\sum_{\\eta_i \\in \\{\\eta_i\\}} \\eta_i $$\n$2$. 集合 $\\mathcal{M}$ 的基数（记为 $|\\mathcal{M}|$）必须是最小的。\n\n首先，我们计算网格中所有单元的误差指示子总和：\n$$ \\sum_{i=1}^{5} \\eta_i = 0.5 + 0.3 + 0.1 + 0.05 + 0.05 = 1.0 $$\n\n接下来，我们计算Dörfler准则所需的目标和。这是总和的 $\\theta$ 倍：\n$$ \\text{Target Sum} = \\theta \\sum_{i=1}^{5} \\eta_i = 0.5 \\times 1.0 = 0.5 $$\n\n为了以最少的单元数满足该准则，我们必须采用贪心策略。这包括按误差指示子降序对单元进行排序，并累加它们的和，直到达到或超过目标和。这个过程保证了用最少的单元数达到阈值。\n\n按降序排序的误差指示子为：$\\{0.5, 0.3, 0.1, 0.05, 0.05\\}$。\n\n我们现在迭代地选择具有最高指示子的单元，并将它们添加到我们的标记集合 $\\mathcal{M}$ 中，直到它们的累积和达到目标值 $0.5$。\n\n- **第1步**：选择具有最大指示子的单元，$\\eta_1 = 0.5$。\n  - 累积和为 $0.5$。\n  - 被标记的单元数量为 $1$。\n  - 我们检查累积和是否满足准则：$0.5 \\ge 0.5$。条件满足。\n\n由于仅用第一个单元（具有最大误差指示子的那个）就满足了条件，我们不需要标记任何其他单元。因此，需要标记的最小单元数是 $1$。要标记的最小单元子集对应于单个指示子 $\\eta = 0.5$。", "answer": "$$\\boxed{1}$$", "id": "3571719"}, {"introduction": "当一个单元被标记为需要加密时，hp-自适应方法的核心挑战在于决定采用h-加密（细分单元）还是p-加密（提升多项式阶次）。此练习通过一个实际的编程任务[@problem_id:3571718]，让您实现一个基于解的勒让德谱系数模态衰减的复杂指标。通过分析衰减率，我们可以推断解的局部光滑性，从而在处理奇异性时选择h-加密，或在解光滑的区域选择p-加密。", "problem": "考虑一根长度为 $L=1$、横截面积恒为 $A=1$ 的一维线弹性杆，其受到轴向体力场 $f(x)$ 的作用，且右边界为无牵引力边界。该杆由两个均匀层组成，其杨氏模量 $E(x)$ 是分段常数，具体为：当 $0 \\le x < x_I$ 时，$E(x)=E_1$；当 $x_I \\le x \\le 1$ 时，$E(x)=E_2$，其中 $0<x_I<1$ 是界面位置。线性本构关系下的小应变弹性控制平衡方程为\n$$\\frac{d}{dx}\\left(E(x)A\\frac{du}{dx}\\right)=f(x),$$\n边界条件为 $u(0)=0$ 和 $E(1)A\\,u'(1)=0$。假设 $f(x)=f_0$ 是一个正常数。\n\n对于一个由不重叠单元 $\\{[x_{e,\\mathrm{L}},x_{e,\\mathrm{R}}]\\}$ 组成的、划分区间 $[0,1]$ 的给定网格，基于单元位移场 $u(x)$ 的勒让德 (Legendre) 多项式展开，为每个单元定义模态衰减指标。令 $\\xi \\in [-1,1]$ 为参考坐标， $x(\\xi)=\\frac{x_{e,\\mathrm{R}}-x_{e,\\mathrm{L}}}{2}(\\xi+1)+x_{e,\\mathrm{L}}$ 为仿射映射。参考场 $u_e(\\xi)$ 为 $u_e(\\xi)=u(x(\\xi))$。令 $P_\\ell(\\xi)$ 为 $\\ell$ 次勒让德多项式，在 $[-1,1]$ 上带单位权重正交。定义 $L^2$ 投影系数 $a_\\ell$ 为\n$$a_\\ell=\\frac{2\\ell+1}{2}\\int_{-1}^{1}u_e(\\xi)P_\\ell(\\xi)\\,d\\xi,\\quad \\ell=0,1,\\dots,p,$$\n其中 $p$ 是该指标要考虑的最大局部多项式次数。单元 $e$ 的模态衰减斜率 $m_e$ 由 $\\log_{10}(|a_\\ell|)$ 对 $\\ell$（其中 $\\ell=1,\\dots,p$）的最小二乘线性拟合给出，即计算 $m_e$ 使得\n$$\\log_{10}(|a_\\ell|)\\approx m_e\\,\\ell + b_e,$$\n在最小二乘意义下成立，其中在对数函数内部加入一个小的正则化项 $\\varepsilon$ 以避免在 $a_\\ell=0$ 处的奇异性。\n\n决策规则：如果 $m_e\\le m_{\\mathrm{crit}}$（更负的斜率表示更快的衰减），则对单元 $e$ 选择 $p$-富集 (p-enrichment)；否则，对单元 $e$ 选择 $h$-细化 (h-refinement)。\n\n任务：\n1. 从平衡方程和边界条件出发，推导在 $f(x)=f_0$ 和分段常数 $E(x)$（在 $x_I$ 处有单一界面）情况下的分段闭式解 $u(x)$，确保在 $x_I$ 处位移的连续性和轴向力 $E(x)A\\,u'(x)$ 的连续性。\n2. 使用 $Q$ 阶高斯-勒让德 (Gaussian-Legendre) 求积法，通过上述积分在每个单元中近似计算 $\\ell=0,\\dots,p$ 的 $a_\\ell$。然后，使用 $\\log_{10}(|a_\\ell|+\\varepsilon)$（其中正则化项定义为 $\\varepsilon=\\max_{\\ell}|a_\\ell|\\times 10^{-14}+10^{-30}$）通过对 $\\ell=1,\\dots,p$ 的最小二乘法计算斜率 $m_e$。\n3. 应用具有指定临界斜率 $m_{\\mathrm{crit}}$ 的决策规则，并为每个测试用例中的每个单元输出一个布尔值，指示是进行 $p$-富集（True）还是 $h$-细化（False）。\n\n单位：物理参数 $E_1$ 和 $E_2$ 的单位是帕斯卡 (Pascals)，$f_0$ 的单位是牛顿每立方米 (Newtons per cubic meter)。最终程序输出是无单位的布尔值。不需要进行单位转换。\n\n测试套件：\n- 测试用例 1（单单元，界面位于单元内部，中等对比度）：$E_1=200\\times 10^9$, $E_2=50\\times 10^9$, $x_I=0.35$, $f_0=10^6$, 单元 $[(0.0,1.0)]$, $p=8$, $Q=64$, $m_{\\mathrm{crit}}=-0.8$。\n- 测试用例 2（双单元，与界面对齐，中等对比度）：$E_1$, $E_2$, $x_I$ 和 $f_0$ 与测试用例 1 相同；单元 $[(0.0,0.35),(0.35,1.0)]$, $p=8$, $Q=64$, $m_{\\mathrm{crit}}=-0.8$。\n- 测试用例 3（双单元，与界面未对齐，中等对比度）：$E_1$, $E_2$, $x_I$ 和 $f_0$ 与测试用例 1 相同；单元 $[(0.0,0.5),(0.5,1.0)]$, $p=8$, $Q=64$, $m_{\\mathrm{crit}}=-0.8$。\n- 测试用例 4（单单元，界面位于单元内部，更高对比度，边界次数情况）：$E_1=200\\times 10^9$, $E_2=5\\times 10^9$, $x_I=0.65$, $f_0=10^6$, 单元 $[(0.0,1.0)]$, $p=3$, $Q=24$, $m_{\\mathrm{crit}}=-0.8$。\n\n您的程序应生成单行输出，其中包含按顺序排列的四个测试用例中所有单元的决策，形式为方括号括起来的逗号分隔列表。顺序是每个测试用例内按单元排列，并且测试用例按上述顺序处理。例如，输出格式必须与 $[b_1,b_2,\\dots,b_6]$ 完全一样，其中每个 $b_k$ 均为 True 或 False。", "solution": "该问题是有效的，因为它在科学上基于线弹性理论，在数学上是适定的、客观的，并且包含推导唯一解和执行指定数值任务所需的所有数据。\n\n求解过程分三个阶段：首先，推导位移场 $u(x)$ 的解析表达式；其次，描述为每个单元计算模态衰减指标 $m_e$ 的数值程序；第三，应用决策规则来确定合适的网格自适应策略。\n\n**1. 解析位移场 $u(x)$ 的推导**\n\n一维弹性杆的控制平衡方程如下所示：\n$$\n\\frac{d}{dx}\\left(E(x)A\\frac{du}{dx}\\right) = f(x)\n$$\n给定恒定的横截面积 $A=1$ 和恒定的体力 $f(x)=f_0$，方程得以简化。域 $[0, 1]$ 由两种材料组成，其杨氏模量为分段常数：当 $0 \\le x < x_I$ 时，$E(x) = E_1$；当 $x_I \\le x \\le 1$ 时，$E(x) = E_2$。我们在每个区域分别求解该方程。\n\n对于区域 1（$0 \\le x < x_I$）：\n$$\nE_1 \\frac{d^2u_1}{dx^2} = f_0\n$$\n对 $x$ 积分两次，得到位移 $u_1(x)$ 的通解：\n$$\nu_1(x) = \\frac{f_0}{2E_1}x^2 + C_1 x + C_2\n$$\n\n对于区域 2（$x_I \\le x \\le 1$）：\n$$\nE_2 \\frac{d^2u_2}{dx^2} = f_0\n$$\n积分两次，得到位移 $u_2(x)$ 的通解：\n$$\nu_2(x) = \\frac{f_0}{2E_2}x^2 + C_3 x + C_4\n$$\n存在 4 个未知的积分常数（$C_1, C_2, C_3, C_4$），它们通过应用边界和界面条件来确定。\n\n边界条件是：\n1.  左端固定位移：$u(0)=0$。将其应用于 $u_1(x)$：\n    $u_1(0) = C_2 = 0$。\n2.  右端无牵引力：$E(1)A u'(1)=0$。由于 $A=1$ 且 $E(1)=E_2$，这简化为 $E_2 u_2'(1)=0$。\n    $u_2(x)$ 的导数为 $u_2'(x) = \\frac{f_0}{E_2}x + C_3$。\n    $E_2 \\left(\\frac{f_0}{E_2}(1) + C_3\\right) = 0 \\implies f_0 + E_2 C_3 = 0 \\implies C_3 = -\\frac{f_0}{E_2}$。\n\n在 $x=x_I$ 处的界面条件确保了两种材料层之间的相容性：\n3.  位移的连续性：$u_1(x_I) = u_2(x_I)$。\n4.  轴向力的连续性：$E_1 A u_1'(x_I) = E_2 A u_2'(x_I)$。由于 $A=1$：\n    $E_1 \\left(\\frac{f_0}{E_1}x_I + C_1\\right) = E_2 \\left(\\frac{f_0}{E_2}x_I + C_3\\right)$。\n    代入 $C_3 = -f_0/E_2$：\n    $f_0 x_I + E_1 C_1 = E_2 \\left(\\frac{f_0}{E_2}x_I - \\frac{f_0}{E_2}\\right) = f_0 x_I - f_0$。\n    $E_1 C_1 = -f_0 \\implies C_1 = -\\frac{f_0}{E_1}$。\n\n最后，我们使用位移连续性条件 (3) 来求出 $C_4$。\n$u_1(x_I) = \\frac{f_0}{2E_1}x_I^2 - \\frac{f_0}{E_1}x_I = \\frac{f_0}{E_1}\\left(\\frac{x_I^2}{2} - x_I\\right)$。\n$u_2(x_I) = \\frac{f_0}{2E_2}x_I^2 - \\frac{f_0}{E_2}x_I + C_4 = \\frac{f_0}{E_2}\\left(\\frac{x_I^2}{2} - x_I\\right) + C_4$。\n令二者相等可得：\n$C_4 = \\frac{f_0}{E_1}\\left(\\frac{x_I^2}{2} - x_I\\right) - \\frac{f_0}{E_2}\\left(\\frac{x_I^2}{2} - x_I\\right) = f_0\\left(\\frac{1}{E_1} - \\frac{1}{E_2}\\right)\\left(\\frac{x_I^2}{2} - x_I\\right)$。\n\n位移场 $u(x)$ 的完整分段解析解为：\n$$\nu(x) =\n\\begin{cases}\nu_1(x) = \\frac{f_0}{E_1}\\left(\\frac{x^2}{2} - x\\right)  & \\text{当 } 0 \\le x < x_I \\\\\nu_2(x) = \\frac{f_0}{E_2}\\left(\\frac{x^2}{2} - x\\right) + f_0\\left(\\frac{1}{E_1} - \\frac{1}{E_2}\\right)\\left(\\frac{x_I^2}{2} - x_I\\right) & \\text{当 } x_I \\le x \\le 1\n\\end{cases}\n$$\n该解是连续的，但当 $E_1 \\neq E_2$ 时，其导数 $u'(x)$ 在 $x=x_I$ 处不连续，在位移剖面中产生一个“扭折”(kink)。这种不光滑性是模态衰减指标旨在检测的关键特征。\n\n**2. 模态衰减指标 $m_e$ 的数值计算**\n\n指标 $m_e$ 量化了单元内解的勒让德谱系数的衰减速率。快速衰减（$m_e$ 为大的负数）意味着解是光滑的，并且能被多项式很好地近似，因此适合进行 $p$-富集（增加多项式次数）。缓慢衰减（$m_e$ 的负值较小）表明存在奇异点或尖锐特征，对此 $h$-细化（细分单元）更为有效。\n\n对于每个单元 $e = [x_{e,\\mathrm{L}}, x_{e,\\mathrm{R}}]$，其步骤如下：\n1.  **计算勒让德系数 $a_\\ell$**：系数 $a_\\ell$ 是单元的参考位移场 $u_e(\\xi)$ 在勒让德多项式 $P_\\ell(\\xi)$ 上的投影。该积分使用 $Q$ 点高斯-勒让德求积法则进行近似，其求积点 $\\xi_q$ 和权重 $w_q$ 定义在参考区间 $[-1, 1]$ 上。\n    $$\n    a_\\ell \\approx \\frac{2\\ell+1}{2} \\sum_{q=1}^{Q} u(x(\\xi_q)) P_\\ell(\\xi_q) w_q\n    $$\n    物理坐标 $x(\\xi_q)$ 通过仿射映射 $x(\\xi)=\\frac{x_{e,\\mathrm{R}}-x_{e,\\mathrm{L}}}{2}(\\xi+1)+x_{e,\\mathrm{L}}$ 获得。计算 $\\ell=0, 1, \\dots, p$ 的系数。\n\n2.  **正则化**：为避免对数值上为零的系数计算 $\\log(0)$ 的问题，加入一个小的正常数 $\\varepsilon$。首先，计算系数向量 $[a_0, a_1, \\dots, a_p]$。然后，正则化项计算为 $\\varepsilon=\\max_{\\ell=0,\\dots,p}|a_\\ell|\\times 10^{-14}+10^{-30}$。\n\n3.  **最小二乘拟合**：我们寻求能最好地拟合数据点 $(\\ell, \\log_{10}(|a_\\ell|+\\varepsilon))$（其中 $\\ell=1, \\dots, p$）的直线的斜率 $m_e$。这是一个标准的线性回归问题。通过求解代表该拟合的线性系统的最小二乘解来计算斜率 $m_e$。这可以方便地使用数值库来完成。\n\n**3. 决策逻辑与实现**\n\n最后一步是对每个测试用例中的每个单元应用决策规则。对于给定的临界斜率 $m_{\\mathrm{crit}}$，自适应决策如下：\n-   如果 $m_e \\le m_{\\mathrm{crit}}$：谱衰减快。选择 $p$-富集（输出 `True`）。\n-   如果 $m_e > m_{\\mathrm{crit}}$：谱衰减慢。选择 $h$-细化（输出 `False`）。\n\n整个过程用 Python 实现。一个函数根据材料参数生成解析解 $u(x)$。另一个函数组织对给定单元的 $m_e$ 进行数值计算，利用 `numpy` 进行数组操作，`numpy.polynomial.legendre.leggauss` 进行求积，`scipy.special.legendre` 进行多项式求值，以及 `numpy.polyfit` 进行最小二乘拟合。主循环遍历所提供的测试用例，为每个单元计算指标，应用决策规则，并汇总布尔结果以供最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_analytical_solution_u(E1, E2, xI, f0):\n    \"\"\"\n    Creates and returns the analytical solution function u(x) for the given parameters.\n    \"\"\"\n    # Constant C4 is derived from continuity of displacement at x=xI\n    C4 = f0 * (1/E1 - 1/E2) * (xI**2 / 2 - xI)\n\n    def u(x):\n        \"\"\"\n        Calculates the displacement u at position(s) x.\n        x can be a single float or a numpy array.\n        \"\"\"\n        x_arr = np.asarray(x)\n        res = np.zeros_like(x_arr, dtype=float)\n        \n        # Region 1: 0 = x  xI\n        mask1 = x_arr  xI\n        res[mask1] = (f0 / E1) * (x_arr[mask1]**2 / 2 - x_arr[mask1])\n\n        # Region 2: xI = x = 1\n        mask2 = x_arr >= xI\n        res[mask2] = (f0 / E2) * (x_arr[mask2]**2 / 2 - x_arr[mask2]) + C4\n        \n        return res\n        \n    return u\n\ndef compute_modal_decay_slope(u_func, element_bounds, p, Q):\n    \"\"\"\n    Computes the modal decay slope m_e for a single element.\n    \"\"\"\n    x_L, x_R = element_bounds\n    \n    # Get Gaussian quadrature points and weights for interval [-1, 1]\n    xi_q, w_q = leggauss(Q)\n    \n    # Map reference coordinates xi_q to physical coordinates x_q\n    x_q = (x_R - x_L) / 2 * (xi_q + 1) + x_L\n    \n    # Evaluate solution at physical quadrature points\n    u_q = u_func(x_q)\n    \n    # Compute Legendre projection coefficients a_l for l=0,...,p\n    a_coeffs = np.zeros(p + 1)\n    for l_val in range(p + 1):\n        P_l = legendre(l_val)\n        integrand = u_q * P_l(xi_q)\n        integral = np.sum(w_q * integrand)\n        a_coeffs[l_val] = (2 * l_val + 1) / 2 * integral\n        \n    # Compute regularization term epsilon\n    epsilon = np.max(np.abs(a_coeffs)) * 1e-14 + 1e-30\n    \n    # Prepare data for least-squares fit for l=1,...,p\n    l_vals = np.arange(1, p + 1)\n    y_vals = np.log10(np.abs(a_coeffs[1:]) + epsilon)\n    \n    # Perform linear least-squares fit to find the slope m_e\n    m_e, _ = np.polyfit(l_vals, y_vals, 1)\n    \n    return m_e\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'E1': 200e9, 'E2': 50e9, 'xI': 0.35, 'f0': 1e6, 'elements': [(0.0, 1.0)], 'p': 8, 'Q': 64, 'm_crit': -0.8},\n        {'E1': 200e9, 'E2': 50e9, 'xI': 0.35, 'f0': 1e6, 'elements': [(0.0, 0.35), (0.35, 1.0)], 'p': 8, 'Q': 64, 'm_crit': -0.8},\n        {'E1': 200e9, 'E2': 50e9, 'xI': 0.35, 'f0': 1e6, 'elements': [(0.0, 0.5), (0.5, 1.0)], 'p': 8, 'Q': 64, 'm_crit': -0.8},\n        {'E1': 200e9, 'E2': 5e9, 'xI': 0.65, 'f0': 1e6, 'elements': [(0.0, 1.0)], 'p': 3, 'Q': 24, 'm_crit': -0.8}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the analytical solution function for the current case\n        u_func = get_analytical_solution_u(case['E1'], case['E2'], case['xI'], case['f0'])\n        \n        # Process each element in the test case's mesh\n        for element in case['elements']:\n            m_e = compute_modal_decay_slope(u_func, element, case['p'], case['Q'])\n            # Apply the decision rule\n            decision = m_e = case['m_crit']\n            results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3571718"}, {"introduction": "超越了对单个单元的局部决策，hp-自适应的一个高级应用是进行全局优化，即在给定的总计算成本（如自由度预算）下，如何分配整个网格的多项式阶次以最小化全局误差。本练习将此任务构建为一个凸优化问题[@problem_id:3571693]，并要求您求解其 Karush-Kuhn-Tucker (KKT) 条件。掌握这种方法使您能够设计出最高效、为特定问题量身定制的有限元离散方案。", "problem": "考虑一个固定的、协调的有限元网格，其单元集由 $K \\in \\{1,\\dots,N_e\\}$ 索引。在网格尺寸和多项式次数自适应（通常称为 $h$-$p$ 自适应）的背景下，假设为每个单元 $K$ 分配一个多项式次数 $p_K$，为了优化的目的，该次数被视为区间 $[p_{\\min},p_{\\max}]$ 内的连续变量。假设全局后验误差估计的凸代理模型是单元贡献 $E_K(p_K)$ 的总和，其中 $E_K(p_K) = A_K \\exp(-b_K p_K)$，且 $A_K  0$ 和 $b_K  0$。设自由度（DOF）预算近似为一个线性函数 $\\sum_{K=1}^{N_e} c_K p_K \\le B$，其中 $c_K  0$ 且总预算 $B  0$。目标是分配多项式次数 $p_K$，以在满足自由度预算和边界约束的条件下最小化全局代理。\n\n将全局连续松弛优化问题表述如下：最小化\n$$\nJ(\\mathbf{p}) = \\sum_{K=1}^{N_e} A_K \\exp(-b_K p_K),\n$$\n约束条件为\n$$\n\\sum_{K=1}^{N_e} c_K p_K \\le B, \\quad p_{\\min} \\le p_K \\le p_{\\max} \\quad \\text{对所有 } K,\n$$\n其中 $\\mathbf{p} = (p_1,\\dots,p_{N_e})$。推导并求解该凸优化问题的 Karush-Kuhn-Tucker (KKT) 条件。您的程序必须求解最优多项式次数 $\\{p_K\\}$ 和与自由度预算约束相关的拉格朗日乘子 $\\lambda$，并为每个测试用例返回最优的 $\\mathbf{p}$ 和最优目标值 $J(\\mathbf{p})$。\n\n从一个符合背景的基本点出发：一个经过充分检验的观察结果是，当解在单元上局部足够光滑时，在合适的能量范数下，单元误差会随着多项式次数 $p_K$ 的增加呈指数级下降，并且对于中等范围的 $p_K$，自由度数量可以近似为 $p_K$ 的线性函数。请纯粹从数学角度构建优化问题，并推导 KKT 条件，除了凸优化的基本原理外，不依赖任何快捷公式。\n\n您的程序必须实现一个鲁棒的算法，该算法能够：\n- 计算满足 KKT 系统的 $\\{p_K\\}$ 和 $\\lambda$，包括在适当情况下处理边界激活 $p_K = p_{\\min}$ 或 $p_K = p_{\\max}$。\n- 通过验证自由度预算 $B$ 是否在可实现范围 $[\\sum_{K=1}^{N_e} c_K p_{\\min}, \\sum_{K=1}^{N_e} c_K p_{\\max}]$ 内，来确保科学真实性和可行性；如果不可行，程序必须通过返回一个所有条目均为 $\\texttt{nan}$ 的列表来指示不可行性，但仍需产生结果。\n- 基于加权自由度总和对 $\\lambda$ 的单调依赖性，使用单调求根策略来确定 $\\lambda$。\n\n此纯数学公式不涉及物理单位，因此不需要任何单位。不使用角度。不使用百分比。\n\n测试套件：\n为以下测试用例提供解决方案。在每个案例中，$N_e$ 由数组的长度隐式给出。\n\n- 案例 1（理想情况，预期为内部解，某些边界可能未激活）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 8.0$\n\n- 案例 2（边界条件，自由度预算等于最小可行总和）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 5.4$\n\n- 案例 3（边界条件，自由度预算等于最大可行总和）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 27.0$\n\n- 案例 4（边界情况，某些单元在 $p_{\\max}$ 处饱和，而其他单元是自由的）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 15.0$\n\n答案规格：\n对于每个测试用例，您的程序必须按顺序输出与自由度预算相关的最优拉格朗日乘子 $\\lambda$、最优目标值 $J(\\mathbf{p})$ 和最优多项式次数列表 $[p_1,\\dots,p_{N_e}]$。这些必须聚合成单行输出，包含一个列表的列表，每个测试用例一个，没有空格，只使用数字字面量。例如，输出必须看起来像\n$$\n[[\\lambda_1,J_1,p_{1,1},\\dots,p_{1,N_e}],[\\lambda_2,J_2,p_{2,1},\\dots,p_{2,N_e}],\\dots]\n$$\n并严格按照上面列出的顺序包含这些案例。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，如上所示，没有空格。", "solution": "用户希望解决一个源于计算力学中 $hp$-自适应的凸优化问题。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n\n问题是最小化目标函数：\n$$\nJ(\\mathbf{p}) = \\sum_{K=1}^{N_e} A_K \\exp(-b_K p_K)\n$$\n约束条件为：\n1. 预算约束：$\\sum_{K=1}^{N_e} c_K p_K \\le B$\n2. 边界约束：$p_{\\min} \\le p_K \\le p_{\\max}$ 对所有 $K \\in \\{1, \\dots, N_e\\}$\n\n参数定义如下：\n- $\\mathbf{p} = (p_1, \\dots, p_{N_e})$：多项式次数的向量，被视为连续变量。\n- $A_K  0$, $b_K  0$：误差估计的单元系数。\n- $c_K  0$：自由度（DOF）近似的单元系数。\n- $B  0$：总自由度预算。\n- $p_{\\min}, p_{\\max}$：多项式次数的下界和上界。\n\n问题要求推导并求解该系统的 Karush-Kuhn-Tucker (KKT) 条件，并实现一个鲁棒的算法来找到最优的 $\\mathbf{p}$ 和预算约束的拉格朗日乘子 $\\lambda$。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n- **科学依据**：该问题表述是计算科学与工程领域的标准形式，特别是在面向目标的误差估计和自适应有限元方法的背景下。误差的指数衰减模型 $A_K \\exp(-b_K p_K)$ 是一个公认的近似，用于描述当解在单元上是解析的时 $p$-版本有限元法的收敛性。自由度的线性近似也是一种常见的简化。该表述在科学上是合理的。\n\n- **良定性**：目标函数 $J(\\mathbf{p})$ 是指数函数的和，每个指数函数都是凸的。凸函数的和仍然是凸的。$J$ 的海森矩阵是对角的，其对角线元素为 $\\frac{\\partial^2 J}{\\partial p_K^2} = A_K b_K^2 \\exp(-b_K p_K)  0$，因此目标函数是严格凸的。约束都是线性不等式，它们定义了一个凸的可行集（一个多胞体）。在一个非空、闭合、凸的集合上最小化一个严格凸函数有唯一解。问题是良定的。问题陈述还要求检查可行性，即可行集是否非空。\n\n- **目标**：问题是用精确、无歧义的数学语言陈述的。它不含主观或基于意见的论断。\n\n问题通过了所有验证标准。\n\n**第 3 步：结论与行动**\n\n问题有效。我将继续进行求解推导。\n\n### 求解推导\n\n这是一个凸优化问题。我们可以通过找到满足 Karush-Kuhn-Tucker (KKT) 条件的点 $(\\mathbf{p}^*)$ 来解决它。\n\n#### 1. 拉格朗日公式\n\n我们为不等式约束引入拉格朗日乘子：\n- $\\lambda \\ge 0$ 对应预算约束 $g(\\mathbf{p}) = \\sum_{K=1}^{N_e} c_K p_K - B \\le 0$。\n- $\\mu_K \\ge 0$ 对应下界约束 $h_{K,1}(\\mathbf{p}) = p_{\\min} - p_K \\le 0$。\n- $\\nu_K \\ge 0$ 对应上界约束 $h_{K,2}(\\mathbf{p}) = p_K - p_{\\max} \\le 0$。\n\n拉格朗日函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(\\mathbf{p}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = J(\\mathbf{p}) + \\lambda g(\\mathbf{p}) + \\sum_{K=1}^{N_e} \\mu_K (p_{\\min} - p_K) + \\sum_{K=1}^{N_e} \\nu_K (p_K - p_{\\max})\n$$\n$$\n\\mathcal{L} = \\sum_{K=1}^{N_e} A_K e^{-b_K p_K} + \\lambda \\left(\\sum_{K=1}^{N_e} c_K p_K - B\\right) - \\sum_{K=1}^{N_e} \\mu_K p_K + \\sum_{K=1}^{N_e} \\nu_K p_K + \\text{const.}\n$$\n其中 `const.` 包含了不依赖于 $\\mathbf{p}$ 的项。\n\n#### 2. KKT 条件\n\n最优解 $(\\mathbf{p}^*, \\lambda^*, \\boldsymbol{\\mu}^*, \\boldsymbol{\\nu}^*)$ 的 KKT 条件是：\n\n1.  **驻点条件**：$\\nabla_{\\mathbf{p}} \\mathcal{L}(\\mathbf{p}^*, \\lambda^*, \\boldsymbol{\\mu}^*, \\boldsymbol{\\nu}^*) = 0$。\n    对于每个单元 $K$：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial p_K} = -A_K b_K e^{-b_K p_K^*} + \\lambda^* c_K - \\mu_K^* + \\nu_K^* = 0\n    $$\n\n2.  **原始可行性**：\n    - $\\sum_{K=1}^{N_e} c_K p_K^* \\le B$\n    - $p_{\\min} \\le p_K^* \\le p_{\\max}$ 对所有 $K$。\n\n3.  **对偶可行性**：\n    - $\\lambda^* \\ge 0$\n    - $\\mu_K^* \\ge 0$, $\\nu_K^* \\ge 0$ 对所有 $K$。\n\n4.  **互补松弛性**：\n    - $\\lambda^* \\left(\\sum_{K=1}^{N_e} c_K p_K^* - B\\right) = 0$\n    - $\\mu_K^* (p_{\\min} - p_K^*) = 0$ 对所有 $K$。\n    - $\\nu_K^* (p_K^* - p_{\\max}) = 0$ 对所有 $K$。\n\n#### 3. 求解多项式次数 $p_K$\n\n从驻点条件，我们有 $A_K b_K e^{-b_K p_K^*} = \\lambda^* c_K - \\mu_K^* + \\nu_K^*$。我们根据 $p_K^*$ 的值来分析这个等式：\n\n-   **情况 1：$p_K$ 的内部解 ($p_{\\min}  p_K^*  p_{\\max}$)**\n    根据互补松弛性，$\\mu_K^* = 0$ 且 $\\nu_K^* = 0$。驻点条件简化为：\n    $$\n    -A_K b_K e^{-b_K p_K^*} + \\lambda^* c_K = 0 \\implies e^{-b_K p_K^*} = \\frac{\\lambda^* c_K}{A_K b_K}\n    $$\n    这要求 $\\lambda^*  0$。求解 $p_K^*$：\n    $$\n    p_K^* = -\\frac{1}{b_K} \\ln \\left(\\frac{\\lambda^* c_K}{A_K b_K}\\right) = \\frac{1}{b_K} \\ln \\left(\\frac{A_K b_K}{\\lambda^* c_K}\\right)\n    $$\n    我们将这个无约束解表示为 $p_K^{\\text{free}}(\\lambda^*) = \\frac{1}{b_K} \\ln \\left(\\frac{A_K b_K}{\\lambda^* c_K}\\right)$。\n\n-   **情况 2：下界激活 ($p_K^* = p_{\\min}$)**\n    根据互补松弛性，$\\nu_K^* = 0$，但 $\\mu_K^* \\ge 0$。驻点条件给出 $\\mu_K^* = \\lambda^* c_K - A_K b_K e^{-b_K p_{\\min}}$。因为 $\\mu_K^* \\ge 0$，我们必须有 $\\lambda^* c_K \\ge A_K b_K e^{-b_K p_{\\min}}$。重新整理这个不等式得到 $p_K^{\\text{free}}(\\lambda^*) \\le p_{\\min}$。\n\n-   **情况 3：上界激活 ($p_K^* = p_{\\max}$)**\n    根据互补松弛性，$\\mu_K^* = 0$，但 $\\nu_K^* \\ge 0$。驻点条件给出 $\\nu_K^* = A_K b_K e^{-b_K p_{\\max}} - \\lambda^* c_K$。因为 $\\nu_K^* \\ge 0$，我们必须有 $A_K b_K e^{-b_K p_{\\max}} \\ge \\lambda^* c_K$。重新整理这个不等式得到 $p_K^{\\text{free}}(\\lambda^*) \\ge p_{\\max}$。\n\n结合这些情况，对于给定的 $\\lambda^*  0$，最优的 $p_K^*$ 通过将自由解裁剪到允许范围内得到：\n$$\np_K^*(\\lambda^*) = \\text{clip}(p_K^{\\text{free}}(\\lambda^*), p_{\\min}, p_{\\max}) = \\max\\left( p_{\\min}, \\min\\left( p_K^{\\text{free}}(\\lambda^*), p_{\\max} \\right) \\right)\n$$\n\n#### 4. 求解拉格朗日乘子 $\\lambda$\n\n现在，最优多项式次数 $\\{p_K^*\\}$ 被表示为一个单一未知标量 $\\lambda^*$ 的函数。我们必须找到满足剩余 KKT 条件的 $\\lambda^*$，特别是预算约束及其互补松弛条件。\n\n设 $S(\\lambda) = \\sum_{K=1}^{N_e} c_K p_K^*(\\lambda)$。我们需要求解 $\\lambda$。\n\n- **可行性**：总预算 $B$ 必须是可实现的。可能的最小预算使用量是 $B_{\\min} = \\sum_{K=1}^{N_e} c_K p_{\\min}$，最大是 $B_{\\max} = \\sum_{K=1}^{N_e} c_K p_{\\max}$。如果 $B$ 在区间 $[B_{\\min}, B_{\\max}]$ 之外，则问题如规定是不可行的。\n\n- **预算 $B$ 的边界情况**：\n    - 如果 $B \\ge B_{\\max}$：通过最大化所有 $p_K$ 来最小化目标函数 $J$。因此，最优解是 $p_K^* = p_{\\max}$ 对所有 $K$。预算约束 $\\sum c_K p_K^* \\le B$ 得到满足，并且可能是松弛的。根据互补松弛性，如果约束是松弛的（$\\sum c_K p_{\\max}  B$），则 $\\lambda^* = 0$。如果它是激活的（$B = B_{\\max}$），$\\lambda^*=0$ 仍然是一个满足 KKT 条件的有效选择。\n    - 如果 $B = B_{\\min}$：唯一的可行解是 $p_K^* = p_{\\min}$ 对所有 $K$。预算约束是激活的。我们需要找到 $\\lambda^*  0$ 使得 $p_K^*(\\lambda^*) = p_{\\min}$ 对所有 $K$。这要求 $p_K^{\\text{free}}(\\lambda^*) \\le p_{\\min}$ 对所有 $K$，这意味着 $\\lambda^* \\ge \\frac{A_K b_K}{c_K} e^{-b_K p_{\\min}}$。满足所有 $K$ 的最小的 $\\lambda^*$ 是 $\\lambda^* = \\max_K \\left\\{ \\frac{A_K b_K}{c_K} e^{-b_K p_{\\min}} \\right\\}$。\n\n- **内部情况 ($B_{\\min}  B  B_{\\max}$)**：\n    在这种情况下，我们期望预算约束是激活的，即 $\\sum c_K p_K^* = B$，这意味着 $\\lambda^*  0$。我们需要解非线性标量方程 $S(\\lambda) = B$。\n    函数 $p_K^*(\\lambda)$ 是 $\\lambda$ 的单调非增函数。因此，$S(\\lambda)$ 也是单调非增的。这个属性使我们能够使用一个高效且鲁棒的求根方法，如二分法。\n    要应用二分法，我们需要找到一个包含根的区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$。\n    - 任何 $p_K$ 开始从 $p_{\\max}$ 减小的最低 $\\lambda$ 值是 $\\lambda_K^{\\text{upper}} = \\frac{A_K b_K}{c_K} e^{-b_K p_{\\max}}$。我们搜索的下界是 $\\lambda_{\\text{low}} = \\min_K \\lambda_K^{\\text{upper}}$。在这个 $\\lambda$ 值下，$S(\\lambda_{\\text{low}}) = B_{\\max}  B$。\n    - 任何 $p_K$ 仍然高于 $p_{\\min}$ 的最高 $\\lambda$ 值是 $\\lambda_K^{\\text{lower}} = \\frac{A_K b_K}{c_K} e^{-b_K p_{\\min}}$。我们搜索的上界是 $\\lambda_{\\text{high}} = \\max_K \\lambda_K^{\\text{lower}}$。在这个 $\\lambda$ 值下，$S(\\lambda_{\\text{high}}) = B_{\\min}  B$。\n    区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 保证包含唯一的根 $\\lambda^*$。\n\n#### 5. 算法总结\n1.  计算 $B_{\\min} = \\sum_K c_K p_{\\min}$ 和 $B_{\\max} = \\sum_K c_K p_{\\max}$。\n2.  如果 $B  B_{\\min}$ 或 $B  B_{\\max}$，问题被视为不可行。返回一个指示这种情况的结果。\n3.  如果 $B = B_{\\max}$，解是 $\\lambda^* = 0$ 和 $p_K^* = p_{\\max}$ 对所有 $K$。\n4.  如果 $B = B_{\\min}$，解是 $p_K^* = p_{\\min}$ 对所有 $K$ 和 $\\lambda^* = \\max_K \\{ (A_K b_K / c_K) e^{-b_K p_{\\min}} \\}$。\n5.  如果 $B_{\\min}  B  B_{\\max}$，通过在上述定义的区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 中使用二分法求解 $S(\\lambda) - B = 0$ 来找到 $\\lambda^*$。\n6.  一旦找到 $\\lambda^*$，计算最优次数 $p_K^* = \\text{clip}\\left( \\frac{1}{b_K} \\ln \\left(\\frac{A_K b_K}{\\lambda^* c_K}\\right), p_{\\min}, p_{\\max} \\right)$。\n7.  计算最优目标值 $J^* = \\sum_K A_K e^{-b_K p_K^*}$。\n8.  返回最优的 $\\lambda^*$、$J^*$ 和向量 $\\mathbf{p}^*$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hp-adaptivity optimization problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 8.0},\n        # Case 2\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 5.4},\n        # Case 3\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 27.0},\n        # Case 4\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 15.0}\n    ]\n\n    results = []\n    for params in test_cases:\n        A = np.array(params['A'])\n        b = np.array(params['b'])\n        c = np.array(params['c'])\n        p_min = params['p_min']\n        p_max = params['p_max']\n        B = params['B']\n        \n        result = _solve_one_case(A, b, c, p_min, p_max, B)\n        results.append(result)\n\n    # Format the output as a string representation of a list of lists, with no spaces.\n    print(str(results).replace(' ', ''))\n\ndef _solve_one_case(A, b, c, p_min, p_max, B):\n    \"\"\"\n    Solves a single instance of the optimization problem.\n    \"\"\"\n    Ne = len(A)\n    B_min = np.sum(c * p_min)\n    B_max = np.sum(c * p_max)\n    \n    # Use a small tolerance for floating point comparisons to B_min and B_max\n    tol = 1e-9\n\n    # 1. Feasibility Check\n    if B  B_min - tol or B > B_max + tol:\n        return [np.nan] * (2 + Ne)\n\n    # 2. Boundary Cases for Budget B\n    if abs(B - B_max) = tol:\n        p_opt = np.full(Ne, p_max)\n        lambda_opt = 0.0\n        J_opt = np.sum(A * np.exp(-b * p_opt))\n        return [lambda_opt, J_opt] + p_opt.tolist()\n\n    if abs(B - B_min) = tol:\n        p_opt = np.full(Ne, p_min)\n        # As derived, lambda is the max required to push all p_k to p_min\n        lambda_opt = np.max((A * b / c) * np.exp(-b * p_min))\n        J_opt = np.sum(A * np.exp(-b * p_opt))\n        return [lambda_opt, J_opt] + p_opt.tolist()\n\n    # 3. Interior Case: B_min  B  B_max\n    # Use bisection to find lambda that satisfies Sum(c_k * p_k(lambda)) = B\n    \n    # Pre-compute constant terms\n    Ab_c = A * b / c\n\n    def get_p_from_lambda(lam):\n        # Handle lambda -> 0 case for safety, though bisection bounds prevent it.\n        if lam = 0: return np.full(Ne, p_max)\n        # Formula for p_k before clipping\n        p_free = (1 / b) * np.log(Ab_c / lam)\n        # Clip to [p_min, p_max]\n        return np.clip(p_free, p_min, p_max)\n\n    def budget_func(lam):\n        p = get_p_from_lambda(lam)\n        return np.sum(c * p) - B\n\n    # Establish search bounds for lambda\n    # lam_low corresponds to B_max, lam_high to B_min\n    lam_low = np.min(Ab_c * np.exp(-b * p_max))\n    lam_high = np.max(Ab_c * np.exp(-b * p_min))\n\n    # Bisection search loop\n    max_iter = 100\n    for _ in range(max_iter):\n        lam_mid = (lam_low + lam_high) / 2.0\n        if lam_mid == lam_low or lam_mid == lam_high: # converged\n            break\n        \n        # S(lambda) > B means lambda is too small\n        if budget_func(lam_mid) > 0:\n            lam_low = lam_mid\n        else:\n            lam_high = lam_mid\n            \n    lambda_opt = (lam_low + lam_high) / 2.0\n\n    # 4. Final Calculation\n    p_opt = get_p_from_lambda(lambda_opt)\n    J_opt = np.sum(A * np.exp(-b * p_opt))\n\n    return [lambda_opt, J_opt] + p_opt.tolist()\n\n\nsolve()\n```", "id": "3571693"}]}