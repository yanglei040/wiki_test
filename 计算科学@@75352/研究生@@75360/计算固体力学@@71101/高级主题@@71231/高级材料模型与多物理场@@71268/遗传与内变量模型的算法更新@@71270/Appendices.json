{"hands_on_practices": [{"introduction": "本练习旨在将粘弹性材料本构关系的微分形式转化为离散时间步下的代数递归关系。通过对一个由应变跳跃组成的具体加载路径进行逐步计算，您将掌握如何将连续的演化方程应用于分段恒定的输入，这是实现数值模拟的第一步。这项实践对于理解记忆性材料如何在计算框架中被处理至关重要 [@problem_id:3544102]。", "problem": "一个单轴、小应变、等温线性粘弹性固体由一个广义麦克斯韦链（三个麦克斯韦臂与一个平衡弹簧并联）建模。设应力分解为 $\\sigma(t) = E_{\\infty}\\,\\epsilon(t) + \\sum_{q=1}^{3} \\sigma_q(t)$，其中 $E_{\\infty}$ 是平衡弹性模量，$\\sigma_q(t)$ 是第 $q$ 个麦克斯韦臂的应力贡献。每个麦克斯韦臂遵循演化方程 $ \\frac{d\\sigma_q}{dt} + \\frac{1}{\\tau_q}\\,\\sigma_q = E_q\\,\\frac{d\\epsilon}{dt}$，其中 $E_q$ 是臂模量，$\\tau_q$ 是其松弛时间。假设初始条件为 $\\epsilon(0^-)=0$ 和 $\\sigma_q(0^-)=0$ (对于 $q=1,2,3$)。\n\n材料参数为 $E_{\\infty}=300\\,\\text{MPa}$，$E_1=700\\,\\text{MPa}$，$\\tau_1=1\\,\\text{s}$，$E_2=1000\\,\\text{MPa}$，$\\tau_2=5\\,\\text{s}$，$E_3=400\\,\\text{MPa}$，$\\tau_3=20\\,\\text{s}$。\n\n加载路径包括两个连续的应变跳跃：在 $t=0$ 时，施加一个瞬时跳跃 $\\Delta\\epsilon_1=0.012$，然后应变保持恒定 $\\Delta t_1=2\\,\\text{s}$；在 $t=\\Delta t_1$ 时，施加一个瞬时跳跃 $\\Delta\\epsilon_2=-0.004$，然后应变保持恒定 $\\Delta t_2=3\\,\\text{s}$。因此，最终时间为 $t_f=\\Delta t_1+\\Delta t_2=5\\,\\text{s}$。\n\n从每个模式给定的演化定律和应力分解出发，推导具有瞬时应变跳跃的分段恒定应变段的算法递推关系。应用此递推关系计算最终应力 $\\sigma(t_f)$，并分别报告每个麦克斯韦模式的贡献以及平衡弹簧的贡献。所有应力以 $\\text{MPa}$ 表示，并将结果四舍五入至四位有效数字。将您的最终答案以行矩阵的形式呈现，依次包含总应力、平衡弹簧贡献以及模式 $q=1,2,3$ 的贡献。", "solution": "问题陈述具有科学依据，提法恰当，客观且自成一体。它描述了线性粘弹性中的一个标准问题，提供了所有必要的材料参数、初始条件和明确定义的加载路径。该模型和控制方程是连续介质力学领域的基础。因此，该问题被认为是有效的，并对其进行求解。\n\n问题的核心是求解每个麦克斯韦臂中非平衡应力 $\\sigma_q(t)$ 的演化方程，这是一个一阶线性常微分方程：\n$$ \\frac{d\\sigma_q}{dt} + \\frac{1}{\\tau_q}\\,\\sigma_q = E_q\\,\\frac{d\\epsilon}{dt} $$\n加载被指定为一系列时间间隔，其中瞬时应变跳跃之后是一段恒定应变时期。我们首先推导在一个从 $t_n$到 $t_{n+1}$ 的通用时间步长上，应力 $\\sigma_q$ 的一般递推更新公式。设步长为 $\\Delta t_{n+1} = t_{n+1} - t_n$。在时间 $t_n$，施加一个瞬时应变跳跃 $\\Delta\\epsilon_{n+1}$。\n\n必须评估在 $t_n$ 时的瞬时应变跳跃对应力 $\\sigma_q$ 的影响。我们可以在一个无穷小的时间区间 $[t_n^-, t_n^+]$ 上对控制方程进行积分：\n$$ \\int_{t_n^-}^{t_n^+} \\left(\\frac{d\\sigma_q}{dt}\\right) dt + \\int_{t_n^-}^{t_n^+} \\frac{1}{\\tau_q}\\,\\sigma_q dt = \\int_{t_n^-}^{t_n^+} E_q\\,\\frac{d\\epsilon}{dt} dt $$\n当区间长度趋于零时，第二个积分消失，因为 $\\sigma_q$是有界的。方程简化为：\n$$ \\sigma_q(t_n^+) - \\sigma_q(t_n^-) = E_q \\left(\\epsilon(t_n^+) - \\epsilon(t_n^-)\\right) $$\n令 $\\sigma_{q,n}$ 表示前一步结束时的应力，即 $\\sigma_q(t_n^-)$，$\\Delta\\epsilon_{n+1}$ 为在 $t_n$ 时的应变跳跃。跳跃后瞬间的应力 $\\sigma_q(t_n^+)$ 为：\n$$ \\sigma_q(t_n^+) = \\sigma_{q,n} + E_q \\Delta\\epsilon_{n+1} $$\n在随后的时间段 $t \\in (t_n, t_{n+1}]$ 内，应变保持恒定，即 $\\frac{d\\epsilon}{dt} = 0$。控制方程变为齐次的：\n$$ \\frac{d\\sigma_q}{dt} + \\frac{1}{\\tau_q}\\,\\sigma_q = 0 $$\n该方程的解是指数衰减。在时间 $t_n$ 的初始条件为 $\\sigma_q(t_n^+)$ 时，对于 $t > t_n$ 的解为：\n$$ \\sigma_q(t) = \\sigma_q(t_n^+) \\exp\\left(-\\frac{t-t_n}{\\tau_q}\\right) $$\n在时间步结束时，$t = t_{n+1}$，计算此式得到应力 $\\sigma_{q,n+1}$：\n$$ \\sigma_{q,n+1} = \\sigma_q(t_{n+1}) = \\sigma_q(t_n^+) \\exp\\left(-\\frac{\\Delta t_{n+1}}{\\tau_q}\\right) $$\n代入 $\\sigma_q(t_n^+)$ 的表达式，我们得到非平衡应力的算法递推关系：\n$$ \\sigma_{q,n+1} = \\left(\\sigma_{q,n} + E_q \\Delta\\epsilon_{n+1}\\right) \\exp\\left(-\\frac{\\Delta t_{n+1}}{\\tau_q}\\right) $$\n我们现在将此公式应用于指定的加载历史。材料初始处于静止状态，因此在 $t=0^-$ 时，我们有 $\\epsilon(0^-)=0$ 和 $\\sigma_{q,0}=\\sigma_q(0^-)=0$ (对于 $q=1,2,3$)。\n\n步骤1：第一个加载段，$t \\in [0, 2\\,\\text{s}]$。\n在 $t_0=0$ 时，有一个应变跳跃 $\\Delta\\epsilon_1 = 0.012$。时间间隔为 $\\Delta t_1 = 2\\,\\text{s}$。此时间间隔内的应变为 $\\epsilon(t) = \\epsilon_1 = 0.012$。\n使用 $n=0$ 的递推关系计算此步骤结束时（$t_1 = 2\\,\\text{s}$）的应力：\n$$ \\sigma_{q,1} = (\\sigma_{q,0} + E_q \\Delta\\epsilon_1) \\exp\\left(-\\frac{\\Delta t_1}{\\tau_q}\\right) = (0 + E_q \\times 0.012) \\exp\\left(-\\frac{2}{\\tau_q}\\right) $$\n对于每个麦克斯韦臂 ($q=1,2,3$)：\n$$ \\sigma_{1,1} = (700 \\times 0.012) \\exp\\left(-\\frac{2}{1}\\right) = 8.4 \\exp(-2)\\,\\text{MPa} $$\n$$ \\sigma_{2,1} = (1000 \\times 0.012) \\exp\\left(-\\frac{2}{5}\\right) = 12 \\exp(-0.4)\\,\\text{MPa} $$\n$$ \\sigma_{3,1} = (400 \\times 0.012) \\exp\\left(-\\frac{2}{20}\\right) = 4.8 \\exp(-0.1)\\,\\text{MPa} $$\n\n步骤2：第二个加载段，$t \\in (2\\,\\text{s}, 5\\,\\text{s}]$。\n在 $t_1=2\\,\\text{s}$ 时，有一个应变跳跃 $\\Delta\\epsilon_2 = -0.004$。时间间隔为 $\\Delta t_2 = 5 - 2 = 3\\,\\text{s}$。此步骤的初始应力为上面计算出的 $\\sigma_{q,1}$。\n最终应变为 $\\epsilon(t_f) = \\epsilon_1 + \\Delta\\epsilon_2 = 0.012 - 0.004 = 0.008$。\n使用 $n=1$ 的递推关系计算最终时间 $t_f = 5\\,\\text{s}$ 时的应力：\n$$ \\sigma_{q,f} = \\sigma_q(t_f) = (\\sigma_{q,1} + E_q \\Delta\\epsilon_2) \\exp\\left(-\\frac{\\Delta t_2}{\\tau_q}\\right) $$\n对于每个麦克斯韦臂：\n$$ \\sigma_{1,f} = (8.4 \\exp(-2) + 700(-0.004)) \\exp\\left(-\\frac{3}{1}\\right) = (8.4 \\exp(-2) - 2.8) \\exp(-3) = 8.4 \\exp(-5) - 2.8 \\exp(-3) $$\n$$ \\sigma_{2,f} = (12 \\exp(-0.4) + 1000(-0.004)) \\exp\\left(-\\frac{3}{5}\\right) = (12 \\exp(-0.4) - 4) \\exp(-0.6) = 12 \\exp(-1) - 4 \\exp(-0.6) $$\n$$ \\sigma_{3,f} = (4.8 \\exp(-0.1) + 400(-0.004)) \\exp\\left(-\\frac{3}{20}\\right) = (4.8 \\exp(-0.1) - 1.6) \\exp(-0.15) = 4.8 \\exp(-0.25) - 1.6 \\exp(-0.15) $$\n现在我们计算在 $t_f = 5\\,\\text{s}$ 时这些模式贡献的数值，并四舍五入到四位有效数字：\n$$ \\sigma_{1,f} \\approx 8.4(0.0067379) - 2.8(0.049787) \\approx 0.056598 - 0.139404 = -0.082805\\,\\text{MPa} \\implies -0.08281\\,\\text{MPa} $$\n$$ \\sigma_{2,f} \\approx 12(0.36788) - 4(0.54881) \\approx 4.41456 - 2.19524 = 2.21932\\,\\text{MPa} \\implies 2.219\\,\\text{MPa} $$\n$$ \\sigma_{3,f} \\approx 4.8(0.77880) - 1.6(0.86071) \\approx 3.73824 - 1.37714 = 2.36110\\,\\text{MPa} \\implies 2.361\\,\\text{MPa} $$\n来自平衡弹簧的贡献是纯弹性的：\n$$ \\sigma_{\\infty}(t_f) = E_{\\infty} \\epsilon(t_f) = 300\\,\\text{MPa} \\times 0.008 = 2.4\\,\\text{MPa} $$\n为了报告的一致性，表示为 $2.400\\,\\text{MPa}$。\n\n总应力 $\\sigma(t_f)$ 是平衡贡献和非平衡贡献之和。将高精度值相加，然后四舍五入到四位有效数字：\n$$ \\sigma(t_f) = \\sigma_{\\infty}(t_f) + \\sigma_{1,f} + \\sigma_{2,f} + \\sigma_{3,f} $$\n$$ \\sigma(t_f) \\approx 2.4 + (-0.082805) + 2.21932 + 2.36110 = 6.897615\\,\\text{MPa} \\implies 6.898\\,\\text{MPa} $$\n\n最终结果是：\n- 总应力：$\\sigma(t_f) = 6.898\\,\\text{MPa}$\n- 平衡弹簧贡献：$\\sigma_{\\infty}(t_f) = 2.400\\,\\text{MPa}$\n- 模式 $1$ 贡献：$\\sigma_1(t_f) = -0.08281\\,\\text{MPa}$\n- 模式 $2$ 贡献：$\\sigma_2(t_f) = 2.219\\,\\text{MPa}$\n- 模式 $3$ 贡献：$\\sigma_3(t_f) = 2.361\\,\\text{MPa}$\n按要求将这些值组合成一个行矩阵。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.898  2.400  -0.08281  2.219  2.361\n\\end{pmatrix}\n}\n$$", "id": "3544102"}, {"introduction": "在开发数值算法时，确保其在离散化后仍遵守基本的物理定律至关重要，例如热力学第二定律。本练习将指导您分析广泛使用的后向欧拉格式，并验证其对于标准线性实体模型是否满足离散耗散不等式，从而保证了无条件热力学稳定性。通过这个编码实践，您将学会如何评估一个时间积分格式的物理相容性，这是开发可靠的材料模型代码的一项核心技能 [@problem_id:3544081]。", "problem": "考虑一个一维遗传黏弹性材料，该材料由多个与一个平衡弹性弹簧并联的麦克斯韦单元之和表示，通常被称为标准线性固体（Standard Linear Solid, SLS）模型。令总小应变为 $\\,\\varepsilon(t)\\,$，总应力为 $\\,\\sigma(t)\\,$。该模型包含一个模量为 $\\,E_{\\infty}\\,$ 的平衡弹性弹簧和一组共 $\\,m\\,$ 个麦克斯韦单元，其弹性模量为 $\\,E_k\\,$，松弛时间为 $\\,\\tau_k\\,$，其中 $\\,k=1,\\dots,m\\,$。每个麦克斯韦单元由一个代表其黏性应变的内变量 $\\,q_k(t)\\,$ 来表征。其本构关系和演化方程由以下基本且被广泛接受的框架定义：\n\n- 自由能密度为\n$$\n\\psi(\\varepsilon,\\{q_k\\}) \\;=\\; \\tfrac{1}{2} E_{\\infty}\\,\\varepsilon^2 \\;+\\; \\sum_{k=1}^m \\tfrac{1}{2} E_k\\,\\big(\\varepsilon - q_k\\big)^2.\n$$\n\n- 应力为\n$$\n\\sigma \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\varepsilon} \\;=\\; E_{\\infty}\\,\\varepsilon \\;+\\; \\sum_{k=1}^m E_k\\,\\big(\\varepsilon - q_k\\big).\n$$\n\n- 每个内变量遵循一个表示黏性松弛的线性常微分方程：\n$$\n\\dot{q}_k \\;=\\; \\dfrac{1}{\\tau_k}\\,\\big(\\varepsilon - q_k\\big),\n\\quad k=1,\\dots,m.\n$$\n\n对于等温过程，克劳修斯-杜亨（Clausius–Duhem）不等式指出耗散率 $\\,\\mathcal{D}(t)\\,$ 必须满足\n$$\n\\mathcal{D}(t) \\;=\\; \\sigma\\,\\dot{\\varepsilon} \\;-\\; \\dot{\\psi} \\;\\ge\\; 0.\n$$\n在上述定律下，可以得到经过充分检验的结果\n$$\n\\mathcal{D}(t) \\;=\\; \\sum_{k=1}^m \\dfrac{E_k}{\\tau_k}\\,\\big(\\varepsilon - q_k\\big)^2 \\;\\ge\\; 0.\n$$\n\n我们现在考虑在时间步 $\\,t_n\\,$ 上使用固定步长 $\\,\\Delta t\\,$（其中 $\\,t_{n+1}=t_n+\\Delta t\\,$）进行时间离散算法更新。内变量使用后向欧拉（Backward Euler, BE）格式进行更新，这是计算固体力学中一种标准的隐式方法：\n$$\nq_k^{n+1} - q_k^{n} \\;=\\; \\dfrac{\\Delta t}{\\tau_k}\\,\\big(\\varepsilon^{n+1} - q_k^{n+1}\\big),\n\\quad k=1,\\dots,m.\n$$\n时间步结束时的应力计算如下\n$$\n\\sigma^{n+1} \\;=\\; E_{\\infty}\\,\\varepsilon^{n+1} \\;+\\; \\sum_{k=1}^m E_k\\,\\big(\\varepsilon^{n+1} - q_k^{n+1}\\big).\n$$\n将第 $\\,n\\,$ 步的离散自由能定义为\n$$\n\\psi^{n} \\;=\\; \\tfrac{1}{2} E_{\\infty}\\,(\\varepsilon^{n})^2 \\;+\\; \\sum_{k=1}^m \\tfrac{1}{2} E_k\\,\\big(\\varepsilon^{n} - q_k^{n}\\big)^2.\n$$\n将时间步 $[t_n,t_{n+1}]$ 上的离散增量功 $\\,W^{n+1}\\,$ 使用步末单点积分定义为\n$$\nW^{n+1} \\;=\\; \\sigma^{n+1}\\,\\Delta\\varepsilon^{n+1},\n\\quad \\text{其中}\\quad \\Delta\\varepsilon^{n+1} \\;=\\; \\varepsilon^{n+1} - \\varepsilon^{n}.\n$$\n将离散耗散 $\\,D^{n+1}\\,$ 定义为\n$$\nD^{n+1} \\;=\\; W^{n+1} \\;-\\; \\big(\\psi^{n+1} - \\psi^{n}\\big).\n$$\n\n您的目标是对具有交替应变增量的数值试验进行能量分析，并验证所选的后向欧拉格式是否能确保离散耗散 $\\,D^{n+1}\\,$ 保持非负。此分析必须作为一个完整的、可运行的程序来实现。\n\n实现要求：\n- 使用上述包含 $\\,m\\,$ 个麦克斯韦单元的模型。初始条件为对所有 $\\,k\\,$，都有 $\\,\\varepsilon^{0} = 0\\,$ 和 $\\,q_k^{0} = 0\\,$。\n- 通过幅值为 $\\,A\\,$ 的交替增量构建应变序列 $\\{\\varepsilon^n\\}$：\n$$\n\\Delta\\varepsilon^{n+1} \\;=\\; A\\,(-1)^n,\n\\quad n=0,1,2,\\dots,N-1,\n$$\n并设置 $\\,\\varepsilon^{n+1} = \\varepsilon^{n} + \\Delta\\varepsilon^{n+1}\\,$，其中 $\\,\\varepsilon^{0} = 0\\,$。\n- 物理单位：\n    - 应变 $\\,\\varepsilon\\,$ 是无量纲的。\n    - 应力 $\\,\\sigma\\,$ 和模量 $\\,E_{\\infty}, E_k\\,$ 必须以帕斯卡（$\\,\\mathrm{Pa}\\,$）为单位。\n    - 时间 $\\,t\\,$ 和 $\\,\\tau_k\\,$ 必须以秒（$\\,\\mathrm{s}\\,$）为单位。\n- 对于每个时间步，使用后向欧拉法计算 $\\,q_k^{n+1}\\,$，然后计算 $\\,\\sigma^{n+1}\\,$、$\\,\\psi^{n+1}\\,$ 和 $\\,D^{n+1}\\,$。使用一个严格的数值容差来判断非负性：如果 $\\,D^{n+1} \\ge -\\mathrm{tol}\\,$，则该步是可接受的，其中 $\\,\\mathrm{tol}\\,$ 是一个相对于能量尺度选择的很小的正浮点数。\n- 对于每个测试用例，程序必须返回一个布尔值，指示在所有时间步 $\\,n=0,\\dots,N-1\\,$ 中，$\\,D^{n+1}\\,$ 是否（在容差范围内）都是非负的。\n\n测试套件：\n- 情况 $\\,1\\,$（常规情况）：\n    - $\\,m = 2\\,$, $\\,E_{\\infty} = 2.6\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 0.9\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_2 = 0.4\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.06\\,\\mathrm{s}\\,$, $\\,\\tau_2 = 0.8\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.05\\,\\mathrm{s}\\,$, $\\,N = 12\\,$, $\\,A = 0.007\\,$.\n- 情况 $\\,2\\,$（边界情况：无平衡弹簧）：\n    - $\\,m = 1\\,$, $\\,E_{\\infty} = 0\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 1.2\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.02\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.02\\,\\mathrm{s}\\,$, $\\,N = 20\\,$, $\\,A = 0.005\\,$.\n- 情况 $\\,3\\,$（边缘情况：时间步相对于某些 $\\,\\tau_k\\,$ 较大）：\n    - $\\,m = 3\\,$, $\\,E_{\\infty} = 3.0\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 1.5\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_2 = 0.5\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_3 = 0.2\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.01\\,\\mathrm{s}\\,$, $\\,\\tau_2 = 0.1\\,\\mathrm{s}\\,$, $\\,\\tau_3 = 1.0\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.5\\,\\mathrm{s}\\,$, $\\,N = 8\\,$, $\\,A = 0.03\\,$.\n- 情况 $\\,4\\,$（边缘情况：零幅值增量）：\n    - $\\,m = 2\\,$, $\\,E_{\\infty} = 1.0\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 0.7\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_2 = 0.3\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.2\\,\\mathrm{s}\\,$, $\\,\\tau_2 = 0.5\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.1\\,\\mathrm{s}\\,$, $\\,N = 10\\,$, $\\,A = 0\\,$.\n\n答案规格：\n- 您的程序应生成单行输出，其中包含以上四个测试用例的结果，结果为逗号分隔的列表并用方括号括起，例如 $\\,\\big[\\texttt{result1},\\texttt{result2},\\texttt{result3},\\texttt{result4}\\big]\\,$，其中每个 $\\,\\texttt{resulti}\\,$ 是一个布尔值。", "solution": "该问题要求对一个一维线性黏弹性模型的数值算法进行热力学一致性分析。具体来说，我们必须验证在使用后向欧拉积分格式时，所定义的离散耗散是否保持非负。\n\n首先，我们建立解析框架。该模型是标准线性固体模型，由一个平衡弹簧（$E_{\\infty}$）与 $m$ 个麦克斯韦单元并联组成。每个麦克斯韦单元 $k$ 由一个弹簧（$E_k$）和一个黏壶组成，其状态由一个内变量，即黏性应变 $q_k$ 描述。\n\n自由能密度 $\\psi$、应力 $\\sigma$ 以及内变量 $q_k$ 的演化由以下公式给出：\n$$\n\\psi(\\varepsilon, \\{q_k\\}) = \\frac{1}{2} E_{\\infty} \\varepsilon^2 + \\sum_{k=1}^m \\frac{1}{2} E_k (\\varepsilon - q_k)^2\n$$\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E_{\\infty} \\varepsilon + \\sum_{k=1}^m E_k (\\varepsilon - q_k)\n$$\n$$\n\\dot{q}_k = \\frac{1}{\\tau_k}(\\varepsilon - q_k)\n$$\n该问题考虑了从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的时间步上的离散模拟。内变量使用隐式后向欧拉（BE）格式进行更新：\n$$\n\\frac{q_k^{n+1} - q_k^n}{\\Delta t} = \\frac{1}{\\tau_k}(\\varepsilon^{n+1} - q_k^{n+1})\n$$\n该方程对于未知数 $q_k^{n+1}$ 是线性的，可以重新整理以提供一个显式的更新规则：\n$$\nq_k^{n+1} \\left(1 + \\frac{\\Delta t}{\\tau_k}\\right) = q_k^n + \\frac{\\Delta t}{\\tau_k} \\varepsilon^{n+1}\n$$\n$$\nq_k^{n+1} = \\frac{\\tau_k}{\\tau_k + \\Delta t} q_k^n + \\frac{\\Delta t}{\\tau_k + \\Delta t} \\varepsilon^{n+1}\n$$\n这个更新公式在计算上很方便，并将在实现中使用。\n\n任务的核心是分析离散耗散 $D^{n+1}$，它被定义为增量功 $W^{n+1}$ 与储存的自由能变化量 $\\psi^{n+1} - \\psi^n$ 之间的差值：\n$$\nD^{n+1} = W^{n+1} - (\\psi^{n+1} - \\psi^n)\n$$\n其中 $W^{n+1} = \\sigma^{n+1} \\Delta\\varepsilon^{n+1}$ 且 $\\Delta\\varepsilon^{n+1} = \\varepsilon^{n+1} - \\varepsilon^n$。我们必须证明对于这种特定的算法结构，$D^{n+1} \\ge 0$。\n\n让我们将 $W^{n+1}$ 和 $\\psi$ 的定义代入 $D^{n+1}$ 的表达式中：\n$$\nD^{n+1} = \\sigma^{n+1}(\\varepsilon^{n+1} - \\varepsilon^n) - \\left[ \\left( \\frac{1}{2} E_{\\infty} (\\varepsilon^{n+1})^2 + \\sum_{k=1}^m \\frac{1}{2} E_k (\\varepsilon^{n+1} - q_k^{n+1})^2 \\right) - \\left( \\frac{1}{2} E_{\\infty} (\\varepsilon^n)^2 + \\sum_{k=1}^m \\frac{1}{2} E_k (\\varepsilon^n - q_k^n)^2 \\right) \\right]\n$$\n代入应力 $\\sigma^{n+1}$ 的表达式：\n$$\n\\sigma^{n+1} = E_{\\infty}\\varepsilon^{n+1} + \\sum_{k=1}^m E_k (\\varepsilon^{n+1} - q_k^{n+1})\n$$\n耗散表达式变为：\n$$\nD^{n+1} = \\left( E_{\\infty}\\varepsilon^{n+1} + \\sum_{k=1}^m E_k (\\varepsilon^{n+1} - q_k^{n+1}) \\right) \\Delta\\varepsilon^{n+1} - \\frac{1}{2} E_{\\infty} ((\\varepsilon^{n+1})^2 - (\\varepsilon^n)^2) - \\sum_{k=1}^m \\frac{1}{2} E_k ((\\varepsilon^{n+1} - q_k^{n+1})^2 - (\\varepsilon^n - q_k^n)^2)\n$$\n我们可以分别分析来自平衡弹簧和麦克斯韦单元的贡献。\n\n来自平衡弹簧（$E_{\\infty}$）的贡献：\n$$\nD_{\\infty}^{n+1} = E_{\\infty}\\varepsilon^{n+1} \\Delta\\varepsilon^{n+1} - \\frac{1}{2} E_{\\infty} ((\\varepsilon^{n+1})^2 - (\\varepsilon^n)^2) = E_{\\infty}\\varepsilon^{n+1}(\\varepsilon^{n+1} - \\varepsilon^n) - \\frac{1}{2} E_{\\infty}(\\varepsilon^{n+1} - \\varepsilon^n)(\\varepsilon^{n+1} + \\varepsilon^n)\n$$\n$$\nD_{\\infty}^{n+1} = \\frac{1}{2} E_{\\infty}(\\varepsilon^{n+1} - \\varepsilon^n) [2\\varepsilon^{n+1} - (\\varepsilon^{n+1} + \\varepsilon^n)] = \\frac{1}{2} E_{\\infty}(\\varepsilon^{n+1} - \\varepsilon^n)^2 = \\frac{1}{2} E_{\\infty}(\\Delta\\varepsilon^{n+1})^2\n$$\n由于 $E_{\\infty} \\ge 0$，该项始终为非负。\n\n来自每个麦克斯韦单元（$k$）的贡献：\n令 $h_k^n = \\varepsilon^n - q_k^n$。$q_k$ 的后向欧拉演化方程可以用 $h_k^{n+1}$ 表示为 $\\Delta q_k^{n+1} = q_k^{n+1} - q_k^n = \\frac{\\Delta t}{\\tau_k} h_k^{n+1}$。\n$h_k$ 的变化量为 $\\Delta h_k^{n+1} = h_k^{n+1} - h_k^n = (\\varepsilon^{n+1} - q_k^{n+1}) - (\\varepsilon^n - q_k^n) = \\Delta\\varepsilon^{n+1} - \\Delta q_k^{n+1}$。\n由此，我们得到 $\\Delta\\varepsilon^{n+1} = \\Delta h_k^{n+1} + \\Delta q_k^{n+1} = \\Delta h_k^{n+1} + \\frac{\\Delta t}{\\tau_k} h_k^{n+1}$。\n单元 $k$ 的耗散部分 $D_k^{n+1}$ 为：\n$$\nD_k^{n+1} = E_k h_k^{n+1} \\Delta\\varepsilon^{n+1} - \\frac{1}{2} E_k ((h_k^{n+1})^2 - (h_k^n)^2)\n$$\n代入 $\\Delta\\varepsilon^{n+1}$ 的表达式：\n$$\nD_k^{n+1} = E_k h_k^{n+1} \\left( \\Delta h_k^{n+1} + \\frac{\\Delta t}{\\tau_k} h_k^{n+1} \\right) - \\frac{1}{2} E_k ((h_k^{n+1})^2 - (h_k^n)^2)\n$$\n$$\nD_k^{n+1} = E_k \\left( h_k^{n+1}(h_k^{n+1} - h_k^n) + \\frac{\\Delta t}{\\tau_k}(h_k^{n+1})^2 \\right) - \\frac{1}{2} E_k ((h_k^{n+1})^2 - (h_k^n)^2)\n$$\n$$\nD_k^{n+1} = E_k \\left( (h_k^{n+1})^2 - h_k^{n+1}h_k^n + \\frac{\\Delta t}{\\tau_k}(h_k^{n+1})^2 - \\frac{1}{2}(h_k^{n+1})^2 + \\frac{1}{2}(h_k^n)^2 \\right)\n$$\n$$\nD_k^{n+1} = E_k \\left( \\frac{1}{2}(h_k^{n+1})^2 - h_k^{n+1}h_k^n + \\frac{1}{2}(h_k^n)^2 + \\frac{\\Delta t}{\\tau_k}(h_k^{n+1})^2 \\right)\n$$\n识别出完全平方项：\n$$\nD_k^{n+1} = \\frac{1}{2} E_k (h_k^{n+1} - h_k^n)^2 + \\frac{\\Delta t E_k}{\\tau_k} (h_k^{n+1})^2 = \\frac{1}{2} E_k (\\Delta h_k^{n+1})^2 + \\frac{\\Delta t E_k}{\\tau_k} (\\varepsilon^{n+1} - q_k^{n+1})^2\n$$\n由于材料参数 $E_k > 0$、$\\tau_k > 0$ 且时间步 $\\Delta t > 0$，这两项都是非负的。\n\n总的离散耗散是所有贡献的总和：\n$$\nD^{n+1} = D_{\\infty}^{n+1} + \\sum_{k=1}^m D_k^{n+1} = \\frac{1}{2} E_{\\infty}(\\Delta\\varepsilon^{n+1})^2 + \\sum_{k=1}^m \\left( \\frac{1}{2} E_k (\\Delta h_k^{n+1})^2 + \\frac{\\Delta t E_k}{\\tau_k} (\\varepsilon^{n+1} - q_k^{n+1})^2 \\right)\n$$\n这个表达式是非负项的和。因此，从解析上保证了 $D^{n+1} \\ge 0$。此性质被称为无条件热力学稳定性，并且是后向欧拉格式应用于此类材料模型的一个关键特性。\n\n实现将通过编写一个程序来模拟每个测试用例的应变历史。在每个时间步 $n=0, ..., N-1$，从 $\\varepsilon^0=0, q_k^0=0$ 开始，算法将：\n1. 计算应变增量 $\\Delta\\varepsilon^{n+1} = A(-1)^n$ 和新应变 $\\varepsilon^{n+1} = \\varepsilon^n + \\Delta\\varepsilon^{n+1}$。\n2. 存储旧的自由能 $\\psi^n$。\n3. 使用从后向欧拉格式导出的显式更新规则计算所有 $k$ 的新内变量 $q_k^{n+1}$。\n4. 计算新应力 $\\sigma^{n+1}$ 和新自由能 $\\psi^{n+1}$。\n5. 计算增量功 $W^{n+1}$，最后计算离散耗散 $D^{n+1} = W^{n+1} - (\\psi^{n+1} - \\psi^n)$。\n6. 验证 $D^{n+1} \\ge -\\mathrm{tol}$ 是否成立，其中 $\\mathrm{tol}$ 是一个小的数值容差（例如 $10^{-9}$），用于考虑浮点数的不精确性。如果该条件在任何时候被违反，则该用例的测试失败。\n\n根据我们的证明，预计所有测试用例都将通过，返回 `True`。情况 4 中，应变幅值为零（$A=0$），将导致所有状态变量保持为零，因此在所有步骤中 $D^{n+1}$ 将恒等于零，这也满足非负性条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m: int, E_inf: float, E_k: np.ndarray, tau_k: np.ndarray, dt: float, N: int, A: float) - bool:\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    Args:\n        m (int): Number of Maxwell elements.\n        E_inf (float): Equilibrium elastic modulus.\n        E_k (np.ndarray): Array of elastic moduli for Maxwell elements.\n        tau_k (np.ndarray): Array of relaxation times for Maxwell elements.\n        dt (float): Time step size.\n        N (int): Number of time steps.\n        A (float): Amplitude of strain increments.\n\n    Returns:\n        bool: True if discrete dissipation is non-negative for all steps, False otherwise.\n    \"\"\"\n    # Numerical tolerance for checking non-negativity.\n    # This value is chosen to be small relative to any expected physical energy values.\n    TOL = 1e-9\n\n    # Initial conditions\n    epsilon_n = 0.0\n    q_n = np.zeros(m)  # Internal variables q_k^n\n\n    for n in range(N):\n        # 1. Calculate old free energy psi^n\n        h_n = epsilon_n - q_n\n        psi_n = 0.5 * E_inf * epsilon_n**2 + 0.5 * np.sum(E_k * h_n**2)\n\n        # 2. Update strain for step n+1\n        delta_epsilon_np1 = A * (-1)**n\n        epsilon_np1 = epsilon_n + delta_epsilon_np1\n\n        # 3. Update internal variables q_k^{n+1} using the explicit Backward Euler update rule\n        # q_k^{n+1} = (tau_k / (tau_k + dt)) * q_k^n + (dt / (tau_k + dt)) * epsilon^{n+1}\n        # This update is vectorized using numpy.\n        q_np1 = (tau_k / (tau_k + dt)) * q_n + (dt / (tau_k + dt)) * epsilon_np1\n\n        # 4. Calculate new stress sigma^{n+1}\n        h_np1 = epsilon_np1 - q_np1\n        sigma_np1 = E_inf * epsilon_np1 + np.sum(E_k * h_np1)\n\n        # 5. Calculate incremental work W^{n+1}\n        W_np1 = sigma_np1 * delta_epsilon_np1\n\n        # 6. Calculate new free energy psi^{n+1}\n        psi_np1 = 0.5 * E_inf * epsilon_np1**2 + 0.5 * np.sum(E_k * h_np1**2)\n\n        # 7. Calculate discrete dissipation D^{n+1}\n        D_np1 = W_np1 - (psi_np1 - psi_n)\n\n        # 8. Check for non-negativity\n        if D_np1  -TOL:\n            return False\n\n        # 9. Update state for the next step\n        epsilon_n = epsilon_np1\n        q_n = q_np1\n\n    return True\n\ndef solve():\n    \"\"\"\n    Defines the test suite and runs the simulation for each case.\n    \"\"\"\n    test_cases = [\n        # Case 1: General happy path\n        {'m': 2, 'E_inf': 2.6e9, 'E_k': [0.9e9, 0.4e9], 'tau_k': [0.06, 0.8], \n         'dt': 0.05, 'N': 12, 'A': 0.007},\n        \n        # Case 2: No equilibrium spring\n        {'m': 1, 'E_inf': 0.0, 'E_k': [1.2e9], 'tau_k': [0.02], \n         'dt': 0.02, 'N': 20, 'A': 0.005},\n        \n        # Case 3: Large time step relative to some tau_k\n        {'m': 3, 'E_inf': 3.0e9, 'E_k': [1.5e9, 0.5e9, 0.2e9], 'tau_k': [0.01, 0.1, 1.0], \n         'dt': 0.5, 'N': 8, 'A': 0.03},\n        \n        # Case 4: Zero amplitude increments\n        {'m': 2, 'E_inf': 1.0e9, 'E_k': [0.7e9, 0.3e9], 'tau_k': [0.2, 0.5], \n         'dt': 0.1, 'N': 10, 'A': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert lists to numpy arrays for vectorized calculations\n        E_k_arr = np.array(case['E_k'], dtype=float)\n        tau_k_arr = np.array(case['tau_k'], dtype=float)\n        \n        is_nonnegative = run_simulation(\n            case['m'], case['E_inf'], E_k_arr, tau_k_arr, \n            case['dt'], case['N'], case['A']\n        )\n        # Format boolean as lowercase string for output\n        results.append(str(is_nonnegative).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3544081"}, {"introduction": "求解率无关塑性问题通常会因其刚性的非线性约束而带来数值挑战。本练习介绍了一种强大的高级技术——同伦延拓法，它通过引入一个粘性正则化参数 $\\eta$ 来解决这个问题。您将构建一个从易于求解的粘塑性问题（$\\eta$ 较大）到目标率无关问题（$\\eta \\to 0$）的连续路径，从而为困难的加载步提供鲁棒的初始猜测并最终获得精确解 [@problem_id:3544019]。", "problem": "考虑一种具有线性各向同性硬化的一维小应变弹塑性材料，该材料在内变量模型的算法更新框架下进行建模。设总应变分解为 $ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $，其中 $ \\varepsilon^{e} $ 是弹性应变，$ \\varepsilon^{p} $ 是塑性应变。柯西应力由胡克定律给出：$ \\sigma = E \\, \\varepsilon^{e} $，其中 $ E $ 是杨氏模量（单位为 $\\mathrm{Pa}$）。选择累积塑性应变 $ \\alpha = \\varepsilon^{p} $ 作为内变量，线性各向同性硬化由硬化模量 $ H $（单位为 $\\mathrm{Pa}$）和初始屈服应力 $ \\sigma_{y0} $（单位为 $\\mathrm{Pa}$）表征。屈服函数为 $ f(\\sigma,\\alpha) = \\sigma - (\\sigma_{y0} + H \\alpha) $，假设为单调拉伸，因此 $ \\sigma \\ge 0 $，不需要使用绝对值。\n\n为了进行正则化并实现从黏性塑性到率无关塑性的同伦，考虑采用 Perzyna 型黏塑性更新，其中包含过应力参数 $ \\eta $（单位为 $ \\mathrm{s} $），并在一个时长为 $ \\Delta t = 1 $（单位为 $ \\mathrm{s} $）的步长上进行后向欧拉时间离散化。离散塑性增量为 $ \\Delta \\gamma \\ge 0 $，使得 $ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\gamma $ 且 $ \\alpha_{n+1} = \\varepsilon^{p}_{n+1} $。试探应力为 $ \\sigma_{\\mathrm{trial}} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n} \\right) $，其中 $ \\varepsilon_{n} $ 是上一步的总应变，$ \\Delta \\varepsilon $ 是该步长的应变增量，$ \\varepsilon^{p}_{n} $ 是上一步的塑性应变。定义相对于当前屈服面的试探过应力为 $ r_{\\mathrm{trial}} = \\sigma_{\\mathrm{trial}} - \\left( \\sigma_{y0} + H \\alpha_{n} \\right) $。\n\n指数为 $ m = 1 $ 的 Perzyna 法则的后向欧拉离散化得到标量隐式更新\n$$\n\\Delta \\gamma = \\frac{\\Delta t}{\\eta} \\, \\left\\langle f_{n+1} \\right\\rangle = \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right),\n$$\n其中 $ f_{n+1} = \\sigma_{n+1} - \\left( \\sigma_{y0} + H \\alpha_{n+1} \\right) $ 且 $ \\sigma_{n+1} = \\sigma_{\\mathrm{trial}} - E \\Delta \\gamma $。在 $ \\eta > 0 $ 的黏性状态下，该更新是良定的。在率无关极限 $ \\eta \\to 0^{+} $ 时，塑性增量满足经典的一致性形式 $ \\Delta \\gamma = \\max(r_{\\mathrm{trial}},0)/(E+H) $。\n\n你的任务是创建一个关于 $ \\eta $ 的同伦延拓，从黏性状态（$ \\eta $ 较大）过渡到率无关状态（$ \\eta = 0 $），并使用前一个 $ \\eta $ 步的解作为初始猜测值来初始化困难的步。对于每个测试用例，计算并报告在指定的 $ \\eta $ 值序列上的路径 $ \\alpha_{n+1}(\\eta) $。你必须为每个 $ \\eta > 0 $ 的情况，对分段残差使用牛顿法，实现一个鲁棒的求解器来求解关于 $ \\Delta \\gamma $ 的标量非线性方程\n$$\nR(\\Delta \\gamma; \\eta) = \\Delta \\gamma - \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right),\n$$\n其导数根据活动分支一致地选择。在 $ \\eta = 0 $ 时，使用率无关极限 $ \\Delta \\gamma = \\max(r_{\\mathrm{trial}},0)/(E+H) $。\n\n所有物理量必须使用其适当的单位：$ E $ 和 $ H $ 的单位为 $ \\mathrm{Pa} $，$ \\sigma_{y0} $ 的单位为 $ \\mathrm{Pa} $，$ \\eta $ 的单位为 $ \\mathrm{s} $，$ \\varepsilon $、$ \\varepsilon^{p} $ 和 $ \\alpha $ 是无量纲应变。最终报告的 $ \\alpha_{n+1}(\\eta) $ 值必须是无量纲的。\n\n测试套件：\n对所有测试使用以下金属常用的材料参数：$ E = 200 \\times 10^{9} \\, \\mathrm{Pa} $，$ H = 1 \\times 10^{9} \\, \\mathrm{Pa} $，$ \\sigma_{y0} = 250 \\times 10^{6} \\, \\mathrm{Pa} $，$ \\Delta t = 1 \\, \\mathrm{s} $。对于每个测试，在同伦序列 $ \\eta \\in \\{ 10^{3}, 10^{2}, 10^{1}, 10^{0}, 10^{-1}, 10^{-2}, 0 \\} $ （单位为 $ \\mathrm{s} $）上计算 $ \\alpha_{n+1}(\\eta) $，其中最后的 $ \\eta = 0 $ 表示率无关极限。\n\n- 测试 1 (纯弹性): $ \\varepsilon_{n} = 0 $, $ \\varepsilon^{p}_{n} = 0 $, $ \\Delta \\varepsilon = 0.001 $。这会得到 $ \\sigma_{\\mathrm{trial}} = 200 \\times 10^{6} \\, \\mathrm{Pa} $ 且 $ r_{\\mathrm{trial}}  0 $。\n- 测试 2 (在屈服边界): $ \\varepsilon_{n} = 0 $, $ \\varepsilon^{p}_{n} = 0 $, $ \\Delta \\varepsilon = \\sigma_{y0}/E = 0.00125 $。这会得到 $ r_{\\mathrm{trial}} = 0 $。\n- 测试 3 (中度塑性): $ \\varepsilon_{n} = 0 $, $ \\varepsilon^{p}_{n} = 0 $, $ \\Delta \\varepsilon = 0.002 $。这会得到 $ r_{\\mathrm{trial}} > 0 $。\n- 测试 4 (强度塑性): $ \\varepsilon_{n} = 0 $, $ \\varepsilon^{p}_{n} = 0 $, $ \\Delta \\varepsilon = 0.005 $。这会得到 $ r_{\\mathrm{trial}} \\gg 0 $。\n\n要求输出：\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于四个测试用例中的每一个，输出与有序 $ \\eta $ 序列 $ \\{ 10^{3}, 10^{2}, 10^{1}, 10^{0}, 10^{-1}, 10^{-2}, 0 \\} $ 对应的 $ \\alpha_{n+1}(\\eta) $ 值列表。因此，最终输出格式必须是\n$$\n\\text{[ [a_{1,1}, a_{1,2}, \\dots, a_{1,7}], [a_{2,1}, \\dots, a_{2,7}], [a_{3,1}, \\dots, a_{3,7}], [a_{4,1}, \\dots, a_{4,7}] ]},\n$$\n其中每个 $ a_{i,j} $ 是一个无量纲浮点数，表示测试 $ i $ 的 $ \\alpha_{n+1}(\\eta_{j}) $。", "solution": "我们从一维小应变运动学 $ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $ 和胡克定律 $ \\sigma = E \\, \\varepsilon^{e} $ 开始，其中 $ E $ 是杨氏模量。各向同性硬化的内变量选择为 $ \\alpha = \\varepsilon^{p} $，单调拉伸下的屈服函数为 $ f(\\sigma,\\alpha) = \\sigma - (\\sigma_{y0} + H \\alpha) $，其中 $ \\sigma_{y0} $ 是初始屈服应力，$ H $ 是线性硬化模量。\n\n考虑从步长 $ n $ 到步长 $ n+1 $（时长为 $ \\Delta t = 1 $）的离散更新。假设已知的上一步总应变 $ \\varepsilon_{n} $ 和应变增量 $ \\Delta \\varepsilon $，定义试探应力为\n$$\n\\sigma_{\\mathrm{trial}} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n} \\right).\n$$\n更新后的塑性应变为 $ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\gamma $，其中 $ \\Delta \\gamma \\ge 0 $。那么更新后的应力为\n$$\n\\sigma_{n+1} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n+1} \\right) = \\sigma_{\\mathrm{trial}} - E \\Delta \\gamma.\n$$\n更新后的内变量为 $ \\alpha_{n+1} = \\varepsilon^{p}_{n+1} = \\alpha_{n} + \\Delta \\gamma $。更新后的屈服函数为\n$$\nf_{n+1} = \\sigma_{n+1} - \\left( \\sigma_{y0} + H \\alpha_{n+1} \\right) = \\sigma_{\\mathrm{trial}} - E \\Delta \\gamma - \\left( \\sigma_{y0} + H \\alpha_{n} + H \\Delta \\gamma \\right).\n$$\n组合各项来定义相对于当前屈服面的试探过应力，\n$$\nr_{\\mathrm{trial}} := \\sigma_{\\mathrm{trial}} - \\left( \\sigma_{y0} + H \\alpha_{n} \\right),\n$$\n这样更新后的屈服函数可写为\n$$\nf_{n+1} = r_{\\mathrm{trial}} - (E+H) \\Delta \\gamma.\n$$\n\n对于使用指数 $ m=1 $ 和过应力参数 $ \\eta $ 的 Perzyna 型过应力正则化的黏塑性，后向欧拉离散化（$ \\Delta t = 1 $）得到隐式标量方程\n$$\n\\Delta \\gamma = \\frac{1}{\\eta} \\, \\left\\langle f_{n+1} \\right\\rangle = \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right).\n$$\n定义牛顿法的残差，\n$$\nR(\\Delta \\gamma; \\eta) = \\Delta \\gamma - \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right).\n$$\n存在两种情况：\n\n- 如果 $ r_{\\mathrm{trial}} \\le 0 $，即弹性区域，则 $ \\left\\langle f_{n+1} \\right\\rangle = 0 $，唯一容许解是 $ \\Delta \\gamma = 0 $，因此对于任何 $ \\eta \\ge 0 $，都有 $ \\alpha_{n+1} = \\alpha_{n} $。\n\n- 如果 $ r_{\\mathrm{trial}}  0 $，即塑性区域，则解在收敛时必须满足 $ r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma  0 $（否则方程右侧将为零，从而错误地强制 $ \\Delta \\gamma = 0 $）。在这个活动分支上，残差简化为线性形式，\n$$\nR(\\Delta \\gamma; \\eta) = \\Delta \\gamma - \\frac{1}{\\eta} \\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma \\right) = \\Delta \\gamma \\left( 1 + \\frac{E+H}{\\eta} \\right) - \\frac{r_{\\mathrm{trial}}}{\\eta}.\n$$\n令 $ R = 0 $ 得到 $ \\eta > 0 $ 时的唯一解，\n$$\n\\Delta \\gamma(\\eta) = \\frac{r_{\\mathrm{trial}}}{\\eta + E + H}.\n$$\n我们可以验证其一致性：代回可得 $ f_{n+1} = r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma = r_{\\mathrm{trial}} \\left( \\frac{\\eta}{\\eta + E + H} \\right) > 0 $，这符合 $ r_{\\mathrm{trial}} > 0 $ 和 $ \\eta > 0 $ 的要求。当 $ \\eta \\to 0^{+} $ 时，率无关极限变为\n$$\n\\Delta \\gamma(0) = \\frac{r_{\\mathrm{trial}}}{E+H},\n$$\n这是一维线性各向同性硬化的经典回映算法更新。\n\n因此，内变量 $ \\alpha_{n+1}(\\eta) $ 的路径为\n$$\n\\alpha_{n+1}(\\eta) =\n\\begin{cases}\n\\alpha_{n},  r_{\\mathrm{trial}} \\le 0, \\\\\n\\alpha_{n} + \\dfrac{r_{\\mathrm{trial}}}{\\eta + E + H},  r_{\\mathrm{trial}} > 0,\\; \\eta > 0, \\\\\n\\alpha_{n} + \\dfrac{r_{\\mathrm{trial}}}{E + H},  r_{\\mathrm{trial}} > 0,\\; \\eta = 0.\n\\end{cases}\n$$\n对于 $ r_{\\mathrm{trial}} > 0 $，该路径相对于 $ \\eta $ 是单调递减的，因为分母 $ \\eta + E + H $ 随 $ \\eta $ 增大而增大；而对于 $ r_{\\mathrm{trial}} \\le 0 $，路径是恒定的。\n\n同伦延拓算法：\n我们从黏性状态下的大 $ \\eta $ 值开始，逐步过渡到率无关极限 $ \\eta = 0 $，并使用前一个 $ \\eta $ 步的解作为牛顿法的初始猜测值。对于 $ \\eta > 0 $，活动分支上的残差导数为\n$$\n\\frac{\\partial R}{\\partial \\Delta \\gamma} =\n\\begin{cases}\n1,  r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma \\le 0, \\\\\n1 + \\dfrac{E+H}{\\eta},  r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma > 0,\n\\end{cases}\n$$\n这确保了牛顿法在活动分支上单次迭代即可收敛，因为残差是 $ \\Delta \\gamma $ 的线性函数。尽管如此，我们还是稳健地实现了牛顿法，并通过显式计算 max 算子来保护分支条件。在 $ \\eta = 0 $ 时，我们使用显式的率无关极限 $ \\Delta \\gamma = \\max(r_{\\mathrm{trial}},0)/(E+H) $。\n\n测试套件规范和单位：\n对所有测试使用 $ E = 200 \\times 10^{9} \\, \\mathrm{Pa} $，$ H = 1 \\times 10^{9} \\, \\mathrm{Pa} $，$ \\sigma_{y0} = 250 \\times 10^{6} \\, \\mathrm{Pa} $，$ \\Delta t = 1 \\, \\mathrm{s} $。应变变量 $ \\varepsilon $、$ \\varepsilon^{p} $ 和 $ \\alpha $ 是无量纲的；报告的 $ \\alpha_{n+1}(\\eta) $ 值必须是无量纲的。同伦参数序列为 $ \\eta \\in \\{ 10^{3}, 10^{2}, 10^{1}, 10^{0}, 10^{-1}, 10^{-2}, 0 \\} $，单位为 $ \\mathrm{s} $。\n\n对于四个测试：\n- 测试 1：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.001 $ 得到 $ \\sigma_{\\mathrm{trial}} = 200 \\times 10^{6} \\, \\mathrm{Pa} $ 且 $ r_{\\mathrm{trial}} = -50 \\times 10^{6} \\, \\mathrm{Pa} \\le 0 $，因此对于所有 $ \\eta $，$ \\alpha_{n+1}(\\eta) = 0 $。\n- 测试 2：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = \\sigma_{y0}/E = 0.00125 $ 得到 $ r_{\\mathrm{trial}} = 0 $，因此对于所有 $ \\eta $，$ \\alpha_{n+1}(\\eta) = 0 $。\n- 测试 3：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.002 $ 得到 $ \\sigma_{\\mathrm{trial}} = 400 \\times 10^{6} \\, \\mathrm{Pa} $，$ r_{\\mathrm{trial}} = 150 \\times 10^{6} \\, \\mathrm{Pa} > 0 $，因此 $ \\alpha_{n+1}(\\eta) = \\dfrac{150 \\times 10^{6}}{\\eta + 201 \\times 10^{9}} $。\n- 测试 4：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.005 $ 得到 $ \\sigma_{\\mathrm{trial}} = 1 \\times 10^{9} \\, \\mathrm{Pa} $，$ r_{\\mathrm{trial}} = 750 \\times 10^{6} \\, \\mathrm{Pa} > 0 $，因此 $ \\alpha_{n+1}(\\eta) = \\dfrac{750 \\times 10^{6}}{\\eta + 201 \\times 10^{9}} $。\n\n程序将为完整性起见实现同伦延拓和牛顿法，尽管存在闭式解；它将计算并以指定格式为每个测试输出列表 $ \\left[ \\alpha_{n+1}(10^{3}), \\alpha_{n+1}(10^{2}), \\alpha_{n+1}(10^{1}), \\alpha_{n+1}(10^{0}), \\alpha_{n+1}(10^{-1}), \\alpha_{n+1}(10^{-2}), \\alpha_{n+1}(0) \\right] $。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_delta_gamma(r_trial: float, E: float, H: float, eta: float, init_gamma: float = 0.0, tol: float = 1e-16, max_iter: int = 25) - float:\n    \"\"\"\n    Solve the scalar viscoplastic update for Delta gamma using Newton's method on:\n        R(gamma; eta) = gamma - (1/eta) * max(r_trial - (E+H)*gamma, 0) = 0  for eta  0.\n    For eta == 0, return the rate-independent limit gamma = max(r_trial, 0)/(E+H).\n    \"\"\"\n    if r_trial = 0.0:\n        # Elastic: no plastic increment for any eta.\n        return 0.0\n    if eta == 0.0:\n        # Rate-independent limit.\n        return r_trial / (E + H)\n\n    gamma = max(init_gamma, 0.0)\n    for _ in range(max_iter):\n        # Evaluate residual with the max operator.\n        arg = r_trial - (E + H) * gamma\n        pos_part = arg if arg > 0.0 else 0.0\n        R = gamma - (pos_part / eta)\n        # Derivative depends on the active branch.\n        if arg > 0.0:\n            dR = 1.0 + (E + H) / eta\n        else:\n            dR = 1.0\n        # Newton update\n        delta = -R / dR\n        gamma += delta\n        # Safeguards: gamma must be nonnegative\n        if gamma  0.0:\n            gamma = 0.0\n        # Convergence check\n        if abs(delta)  tol:\n            break\n    # Final projection to active branch if needed\n    if r_trial - (E + H) * gamma = 0.0:\n        # If we fell into the inactive branch, the correct solution is gamma = 0\n        # but since r_trial > 0 for entering this function, the active solution exists.\n        # To ensure robustness, use the closed form.\n        gamma = r_trial / (eta + E + H)\n    return gamma\n\ndef compute_alpha_path(E: float, H: float, sigma_y0: float, eps_n: float, eps_p_n: float, delta_eps: float, eta_values: list[float]) - list[float]:\n    \"\"\"\n    Compute alpha_{n+1}(eta) along a homotopy path of eta values, using continuation:\n    previous solution as initial guess for the next eta.\n    \"\"\"\n    sigma_trial = E * (eps_n + delta_eps - eps_p_n)\n    r_trial = sigma_trial - (sigma_y0 + H * eps_p_n)\n    alpha_n = eps_p_n\n    path = []\n    prev_gamma = 0.0\n    for eta in eta_values:\n        gamma = solve_delta_gamma(r_trial, E, H, eta, init_gamma=prev_gamma)\n        alpha_np1 = alpha_n + gamma\n        path.append(alpha_np1)\n        prev_gamma = gamma\n    return path\n\ndef solve():\n    # Material parameters (SI units)\n    E = 200.0e9      # Pa\n    H = 1.0e9        # Pa\n    sigma_y0 = 250.0e6  # Pa\n    # Homotopy eta values (s), including the rate-independent limit represented by 0\n    eta_values = [1e3, 1e2, 1e1, 1e0, 1e-1, 1e-2, 0.0]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (eps_n, eps_p_n, delta_eps) for each test\n        (0.0, 0.0, 0.001),          # Test 1: strictly elastic\n        (0.0, 0.0, sigma_y0 / E),   # Test 2: at yield boundary\n        (0.0, 0.0, 0.002),          # Test 3: moderately plastic\n        (0.0, 0.0, 0.005),          # Test 4: strongly plastic\n    ]\n\n    results = []\n    for eps_n, eps_p_n, delta_eps in test_cases:\n        path = compute_alpha_path(E, H, sigma_y0, eps_n, eps_p_n, delta_eps, eta_values)\n        # Convert to regular Python floats for printing\n        results.append([float(x) for x in path])\n\n    # Final print statement in the exact required format.\n    # Single line: nested lists for the four test cases.\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.12g}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_list(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3544019"}]}