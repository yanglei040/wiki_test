{"hands_on_practices": [{"introduction": "在有限元分析中，全局方程组是通过对所有单元的贡献进行累加而建立的，而每个单元的贡献则是在高斯积分点上计算得出的。这个练习将这一基本过程应用于一个节点-接触段（NTS）接触模型。通过这个练习，你将学习如何从接触虚功原理出发，结合罚函数法，将单个高斯积分点上的接触力学行为转化为对全局残差向量和切线刚度矩阵的具体贡献。理解这一过程对于深入掌握接触算法在有限元软件中的实现机制至关重要。", "problem": "考虑在平面应变设置下，一个从节点与一个由两节点组成的直主面元之间的无摩擦单边接触。该问题通过有限元法 (FEM) 进行离散化，采用点对面 (NTS) 列式和砂浆类积分。主面元的端点坐标为 $\\boldsymbol{x}_1=(0,\\,0)$ 和 $\\boldsymbol{x}_2=(0.1,\\,0)$，因此其物理长度为 $L=\\sqrt{(0.1-0)^{2}+(0-0)^{2}}=0.1\\,\\text{m}$。假设在从节点的投影点处定义了单位外法线方向，且接触处于激活状态，法向间隙为 $g_{n}=-2.0\\times 10^{-4}\\,\\text{m}$ (穿透为负值)。在激活接触中，法向接触牵引力遵循线性罚函数法，$p_{n}=-\\epsilon\\,g_{n}$，其中单位面积的法向罚刚度为 $\\epsilon=5.0\\times 10^{10}\\,\\text{N/m}^{3}$。取平面外厚度为 $t=1.0\\times 10^{-2}\\,\\text{m}$。\n\n在主面元上使用单个 Gauss 点，其参数坐标为 $\\xi_{g}=\\sqrt{3}/3$，Gauss 权重为 $w_{g}=1$。主面元在参考区间 $\\xi\\in[-1,1]$ 上通过标准线性等参形函数进行插值，形函数为 $N_{1}(\\xi)=\\frac{1-\\xi}{2}$ 和 $N_{2}(\\xi)=\\frac{1+\\xi}{2}$。该直面元的等参映射雅可比标量为 $J(\\xi)=\\left\\lVert \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\rVert=\\frac{L}{2}$。\n\n从接触的虚功原理和罚函数牵引力的定义出发，推导单个 Gauss 点对以下各项的贡献：\n- 与主节点2相关联的法向标量残差，记为 $R_{2}^{n}$，\n- 相应的关于法向间隙的标量一致切线刚度，记为 $K_{2}^{n}=\\frac{\\partial R_{2}^{n}}{\\partial g_{n}}$，\n\n在沿主面元的砂浆类积分下。将 $R_{2}^{n}$ 以 $\\text{N}$ 为单位表示，将 $K_{2}^{n}$ 以 $\\text{N/m}$ 为单位表示。将两个量均四舍五入至四位有效数字。以行矩阵 $\\begin{pmatrix}R_{2}^{n}  K_{2}^{n}\\end{pmatrix}$ 的形式报告您的最终答案。", "solution": "我们从基于虚功原理的法向接触弱形式开始。对于无摩擦单边接触，主面侧的接触虚功可以写为\n$$\n\\delta W_{c}=\\int_{\\Gamma_{m}} p_{n}\\,\\delta g_{n}\\, t\\, \\mathrm{d}\\Gamma,\n$$\n其中 $\\Gamma_{m}$ 是主接触面元，$p_{n}$ 是法向接触牵引力，$g_{n}$ 是法向间隙，$t$ 是平面外厚度，$\\mathrm{d}\\Gamma$ 是物理空间中的线元。在罚函数法中，对于激活接触 ($g_{n}  0$)，牵引力为\n$$\np_{n}=-\\epsilon\\,g_{n},\n$$\n其中 $\\epsilon$ 是单位面积的法向罚刚度 (单位为 $\\text{N/m}^{3}$)，因此 $p_{n}$ 的单位是应力单位 $\\text{N/m}^{2}$。\n\n在砂浆类 NTS 离散化中，与主节点 $i$ 相关联的法向残差贡献是通过用主面元形函数 $N_{i}$ 加权并沿该面元积分得到的。对于单个 Gauss 点，这可以简化为\n$$\nR_{i}^{n}\\approx -\\,w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,p_{n}(\\xi_{g}).\n$$\n负号反映了从面和主面之间的作用力与反作用力：作用在主面元上的压缩牵引力会产生一个残差，其方向与从节点在主面法向上的穿透方向相反。在 Gauss 点处使用罚函数法则，\n$$\np_{n}(\\xi_{g})=-\\epsilon\\,g_{n},\n$$\n我们有\n$$\nR_{i}^{n} = -\\,w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,\\big(-\\epsilon\\,g_{n}\\big)\n= w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,\\epsilon\\,g_{n}.\n$$\n\n此 Gauss 点贡献的关于法向间隙的一致切线刚度通过对 $R_{i}^{n}$ 关于 $g_{n}$ 求导得到：\n$$\nK_{i}^{n}=\\frac{\\partial R_{i}^{n}}{\\partial g_{n}}=w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,\\epsilon.\n$$\n\n我们现在专门针对主节点 $i=2$ 并根据给定的数据计算这些量值。首先，计算该直面元的雅可比标量：\n$$\nL=\\sqrt{(0.1-0)^{2}+(0-0)^{2}}=0.1\\,\\text{m},\\qquad J(\\xi_{g})=\\frac{L}{2}=\\frac{0.1}{2}=0.05\\,\\text{m}.\n$$\n计算在 $\\xi_{g}=\\sqrt{3}/3$ 处的形函数值：\n$$\nN_{2}(\\xi)=\\frac{1+\\xi}{2}\\quad\\Rightarrow\\quad N_{2}(\\xi_{g})=\\frac{1+\\sqrt{3}/3}{2}.\n$$\n为了进行数值计算，使用 $\\sqrt{3}\\approx 1.732050807568877$，因此\n$$\n\\xi_{g}=\\frac{\\sqrt{3}}{3}\\approx 0.5773502691896257,\\quad N_{2}(\\xi_{g})=\\frac{1+0.5773502691896257}{2}\\approx 0.7886751345948129.\n$$\nGauss 权重为 $w_{g}=1$，厚度为 $t=1.0\\times 10^{-2}\\,\\text{m}$，罚刚度为 $\\epsilon=5.0\\times 10^{10}\\,\\text{N/m}^{3}$，间隙为 $g_{n}=-2.0\\times 10^{-4}\\,\\text{m}$。\n\n计算残差贡献：\n$$\nR_{2}^{n} = w_{g}\\,J(\\xi_{g})\\,t\\,N_{2}(\\xi_{g})\\,\\epsilon\\,g_{n}\n= (1)\\,(0.05)\\,(1.0\\times 10^{-2})\\,(0.7886751345948129)\\,(5.0\\times 10^{10})\\,(-2.0\\times 10^{-4}).\n$$\n组合各项因子：\n$$\nw_{g}\\,J\\,t\\,N_{2}\\approx 1\\times 0.05\\times 0.01\\times 0.7886751346 \\approx 3.943375672974064\\times 10^{-4},\n$$\n那么\n$$\nR_{2}^{n}\\approx \\big(3.943375672974064\\times 10^{-4}\\big)\\times \\big(5.0\\times 10^{10}\\big)\\times \\big(-2.0\\times 10^{-4}\\big)\n= -3.943375672974064\\times 10^{3}\\,\\text{N}.\n$$\n\n计算切线贡献：\n$$\nK_{2}^{n}=w_{g}\\,J(\\xi_{g})\\,t\\,N_{2}(\\xi_{g})\\,\\epsilon\n= \\big(3.943375672974064\\times 10^{-4}\\big)\\times \\big(5.0\\times 10^{10}\\big)\n= 1.971687836487032\\times 10^{7}\\,\\text{N/m}.\n$$\n\n最后，将两个量均四舍五入至四位有效数字，并以行矩阵的形式报告：\n$$\nR_{2}^{n}\\approx -3.943\\times 10^{3}\\,\\text{N},\\qquad K_{2}^{n}\\approx 1.972\\times 10^{7}\\,\\text{N/m}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}-3.943 \\times 10^{3}  1.972 \\times 10^{7}\\end{pmatrix}}$$", "id": "3584757"}, {"introduction": "真实的接触问题几乎总是伴随着摩擦，这是一种高度非线性且路径依赖的物理现象。为了在数值模拟中准确地捕捉摩擦行为，我们需要一个稳健的本构更新算法。本练习将引导你实现径向返回算法，这是一种广泛应用于计算塑性力学和摩擦接触领域的“弹性预测-塑性修正”方法。通过在一个时间步内更新切向接触力，你将掌握处理库仑摩擦定律中粘着（stick）与滑移（slip）状态转换的核心逻辑。", "problem": "请考虑计算固体力学中一个维度为 $d=2$ 的平面内，单个节点（从节点）与一个直线段（主面）之间的摩擦接触相互作用。设线段的外法向为向量 $\\mathbf{n}\\in\\mathbb{R}^2$（不必是单位长度），节点相对于线段在最近点投影处的相对速度为 $\\mathbf{v}_\\text{rel}\\in\\mathbb{R}^2$，时间步长为 $\\Delta t0$。目标是计算该时间步内的切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t\\in\\mathbb{R}^2$，并使用带有径向返回至库仑摩擦锥的弹塑性预测-校正方法来更新切向牵引力 $\\mathbf{t}_t^{n+1}\\in\\mathbb{R}^2$。您需要从基本原理出发：相对运动的运动学、到由接触法线定义的切向子空间的正交投影，以及在切向方向上使用罚函数式弹性预测器的库仑摩擦定律的定义。不要假设任何预先推导的接触公式；相反，应从这些基础推导出必要的算子。\n\n每个测试案例的输入为：\n- 一个线段法线 $\\mathbf{n}$，\n- 一个相对速度 $\\mathbf{v}_\\text{rel}$，\n- 一个以秒为单位的时间步长 $\\Delta t$，\n- 一个以帕斯卡/米为单位的切向罚刚度 $k_t$，\n- 一个无量纲的摩擦系数 $\\mu$，\n- 一个以帕斯卡为单位的法向接触压力 $p_n\\ge 0$（压缩为正），\n- 以及上一步以帕斯卡为单位的切向牵引力 $\\mathbf{t}_t^{n}\\in\\mathbb{R}^2$。\n\n需要实现和论证的任务：\n- 从运动学出发，使用相对位移增量 $\\Delta \\mathbf{u}_\\text{rel}=\\mathbf{v}_\\text{rel}\\,\\Delta t$ 并构造到与单位法线 $\\widehat{\\mathbf{n}}=\\mathbf{n}/\\|\\mathbf{n}\\|$ 正交的切向子空间上的欧几里得正交投影算子，然后应用它来获得切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$。\n- 使用罚刚度和计算出的 $\\Delta\\boldsymbol{\\delta}_t$ 对切向牵引力进行弹性预测，以获得一个试探切向牵引力 $\\mathbf{t}_t^{\\text{trial}}$。\n- 通过最近点（径向返回）映射施加具有系数 $\\mu$ 和法向接触压力 $p_n$ 的库仑摩擦条件：如果试探牵引力的大小超过摩擦边界，则返回到摩擦锥的表面；否则，保持粘滞。\n- 通过将 $\\mathbf{n}$ 归一化为单位长度以及使用一个小的容差来处理 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 接近零的情况，确保数值鲁棒性。将压缩视为正，因此摩擦边界为 $\\mu\\,p_n$。\n\n科学和数值要求：\n- 所有长度单位为米，时间单位为秒，牵引力和压力单位为帕斯卡。\n- 切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$ 必须以米为单位报告，更新后的切向牵引力 $\\mathbf{t}_t^{n+1}$ 必须以帕斯卡为单位报告。\n- 不需要角度；如果任何内部计算使用角度，它们必须是弧度。\n- 您的算法必须适用于任何 $\\|\\mathbf{n}\\|0$ 的 $\\mathbf{n}\\in\\mathbb{R}^2$ 和任何 $\\mathbf{v}_\\text{rel}\\in\\mathbb{R}^2$。\n\n测试套件：\n为以下五个案例提供结果。对每个案例，计算 $\\Delta\\boldsymbol{\\delta}_t$ 和 $\\mathbf{t}_t^{n+1}$。\n\n- 案例1（滑动，轴对齐法线）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_\\text{rel}=[0.1,-0.2]$ 米/秒，$\\Delta t=0.01$ 秒，$k_t=10^6$ 帕斯卡/米，$\\mu=0.3$，$p_n=1000$ 帕斯卡，$\\mathbf{t}_t^{n}=[0,0]$ 帕斯卡。\n\n- 案例2（粘滞，小切向增量）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_\\text{rel}=[0.001,0.0]$ 米/秒，$\\Delta t=0.001$ 秒，$k_t=10^6$ 帕斯卡/米，$\\mu=0.4$，$p_n=500$ 帕斯卡，$\\mathbf{t}_t^{n}=[0,0]$ 帕斯卡。\n\n- 案例3（在摩擦边界上，无需返回）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_\\text{rel}=[0.2,0.0]$ 米/秒，$\\Delta t=0.001$ 秒，$k_t=10^6$ 帕斯卡/米，$\\mu=0.3$，$p_n=1000$ 帕斯卡，$\\mathbf{t}_t^{n}=[100,0]$ 帕斯卡。\n\n- 案例4（滑动，非单位法线的斜向投影）：\n  - $\\mathbf{n}=[2,2]$，$\\mathbf{v}_\\text{rel}=[0.05,0.0]$ 米/秒，$\\Delta t=0.02$ 秒，$k_t=5\\times 10^5$ 帕斯卡/米，$\\mu=0.25$，$p_n=400$ 帕斯卡，$\\mathbf{t}_t^{n}=[10,20]$ 帕斯卡。\n\n- 案例5（零相对速度，已有牵引力在边界内，保持粘滞）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_\\text{rel}=[0.0,0.0]$ 米/秒，$\\Delta t=0.05$ 秒，$k_t=2\\times 10^6$ 帕斯卡/米，$\\mu=0.6$，$p_n=800$ 帕斯卡，$\\mathbf{t}_t^{n}=[100,200]$ 帕斯卡。\n\n最终输出格式：\n- 对每个案例，输出一个包含五个条目的列表：以米为单位的 $\\Delta\\boldsymbol{\\delta}_t$ 的两个分量，以帕斯卡为单位的 $\\mathbf{t}_t^{n+1}$ 的两个分量，以及一个指示是否调用了塑性校正器（滑动）的布尔值。\n- 将所有浮点输出四舍五入到六位小数。\n- 将所有五个案例的结果聚合为单行，形式为用方括号括起来的逗号分隔列表，其中每个案例的结果本身就是一个方括号列表。例如：$[\\,[\\dots],[\\dots],\\dots\\,]$。", "solution": "该问题要求在摩擦接触界面上，基于针对库仑摩擦定律的弹塑性预测-校正方案和径向返回映射，实现切向牵引力矢量的增量更新。其理论框架将从运动学和连续介质力学的基本原理推导得出。\n\n### 1. 相对运动的运动学和切向投影\n\n分析始于一个二维欧几里得空间 $\\mathbb{R}^2$。接触界面由一个主段定义，其方向由外法向矢量 $\\mathbf{n} \\in \\mathbb{R}^2$ 给出。此矢量不一定是单位长度。为了执行投影，我们首先定义单位法向矢量 $\\widehat{\\mathbf{n}}$：\n$$\n\\widehat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|}\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数。矢量 $\\widehat{\\mathbf{n}}$ 定义了接触点的法线方向。切线方向是与 $\\widehat{\\mathbf{n}}$ 正交的子空间。\n\n从节点与主段之间的相对速度为 $\\mathbf{v}_{\\text{rel}} \\in \\mathbb{R}^2$。在持续时间为 $\\Delta t  0$ 的一个时间步内，假设步内速度恒定，相对位移增量计算如下：\n$$\n\\Delta \\mathbf{u}_{\\text{rel}} = \\mathbf{v}_{\\text{rel}} \\Delta t\n$$\n这个相对位移增量可以分解为一个法向分量 $\\Delta u_n$ 和一个切向分量，即切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$。该分解通过正交投影算子实现。\n\n到法向方向（由 $\\widehat{\\mathbf{n}}$ 张成的子空间）的正交投影算子是张量 $\\mathbf{P}_n = \\widehat{\\mathbf{n}} \\otimes \\widehat{\\mathbf{n}}^T$。将此算子应用于矢量 $\\mathbf{v}$ 会得到其法向分量：\n$$\n\\mathbf{v}_n = \\mathbf{P}_n \\mathbf{v} = (\\widehat{\\mathbf{n}} \\cdot \\mathbf{v}) \\widehat{\\mathbf{n}}\n$$\n到切向子空间的正交投影算子由 $\\mathbf{P}_t = \\mathbf{I} - \\mathbf{P}_n$ 给出，其中 $\\mathbf{I}$ 是二阶单位张量。将此算子应用于矢量 $\\mathbf{v}$ 会得到其切向分量：\n$$\n\\mathbf{v}_t = \\mathbf{P}_t \\mathbf{v} = \\mathbf{v} - \\mathbf{v}_n = \\mathbf{v} - (\\widehat{\\mathbf{n}} \\cdot \\mathbf{v}) \\widehat{\\mathbf{n}}\n$$\n将此切向投影算子应用于相对位移增量 $\\Delta \\mathbf{u}_{\\text{rel}}$，得到切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$：\n$$\n\\Delta\\boldsymbol{\\delta}_t = \\mathbf{P}_t(\\Delta \\mathbf{u}_{\\text{rel}}) = \\Delta \\mathbf{u}_{\\text{rel}} - (\\widehat{\\mathbf{n}} \\cdot \\Delta \\mathbf{u}_{\\text{rel}}) \\widehat{\\mathbf{n}}\n$$\n这个矢量 $\\Delta\\boldsymbol{\\delta}_t$ 代表在时间步 $\\Delta t$ 期间沿着接触面切线方向发生的那部分相对运动。\n\n### 2. 本构模型：弹塑性摩擦接触\n\n切向牵引力 $\\mathbf{t}_t$ 的演化采用类似于率无关塑性的框架进行建模。总切向滑移被加法分解为一个弹性（可恢复）部分和一个塑性（摩擦滑动）部分。切向牵引力与滑移的弹性部分之间的关系假定为线性关系，由切向罚刚度 $k_t$ 控制。\n\n从时间步 $n$ 到 $n+1$ 的切向牵引力更新过程遵循一个预测-校正方案。\n\n#### 2.1. 弹性预测\n\n首先，我们假设整个切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$ 是纯弹性的。这会产生一个在步骤 $n+1$ 的切向牵引力的“试探”状态。试探牵引力 $\\mathbf{t}_t^{\\text{trial}}$ 通过将一个弹性增量加到上一步的牵引力 $\\mathbf{t}_t^n$ 上来计算：\n$$\n\\mathbf{t}_t^{\\text{trial}} = \\mathbf{t}_t^n + k_t \\Delta\\boldsymbol{\\delta}_t\n$$\n在这里，$k_t$ 的单位是应力每单位长度（例如，Pa/m），代表接触界面的切向刚度。\n\n#### 2.2. 摩擦准则和校正步\n\n必须根据库仑摩擦定律检查试探牵引力的容许性。该定律规定，切向牵引力的模不能超过一个临界值，该临界值与法向接触压力 $p_n$ 和摩擦系数 $\\mu$ 成正比。这在切向牵引力空间中定义了一个“粘滞”区或弹性域。该条件可以用屈服函数 $\\Phi$ 表示：\n$$\n\\Phi(\\mathbf{t}_t, p_n) = \\|\\mathbf{t}_t\\| - \\mu p_n \\le 0\n$$\n由于法向压力 $p_n$ 在压缩时定义为正，摩擦极限为 $t_{\\text{crit}} = \\mu p_n$。容许状态是满足 $\\|\\mathbf{t}_t\\| \\le t_{\\text{crit}}$ 的状态。\n\n我们在试探状态下评估屈服函数：\n$$\n\\Phi^{\\text{trial}} = \\|\\mathbf{t}_t^{\\text{trial}}\\| - \\mu p_n\n$$\n\n出现两种情况：\n\n**案例 A：粘滞条件 ($\\Phi^{\\text{trial}} \\le 0$)**\n如果试探牵引力的模在摩擦极限内，则试探状态是可容许的。对于此增量，纯弹性行为的假设是正确的。没有发生摩擦滑动（塑性滑移）。更新后的切向牵引力就是试探牵引力：\n$$\n\\mathbf{t}_t^{n+1} = \\mathbf{t}_t^{\\text{trial}}\n$$\n在这种情况下，不调用塑性校正器。\n\n**案例 B：滑动条件 ($\\Phi^{\\text{trial}}  0$)**\n如果试探牵引力的模超过摩擦极限，则试探状态是不可容许的。这表明必须发生摩擦滑动。纯弹性行为的假设是错误的。牵引力矢量必须被“返回”到容许区域的边界，即半径为 $t_{\\text{crit}}$ 的圆。此校正的算法是最近点投影，称为径向返回映射。最终牵引力矢量的方向假定与试探牵引力矢量的方向相同。其模被缩减到极限值 $t_{\\text{crit}}$。\n更新后的切向牵引力为：\n$$\n\\mathbf{t}_t^{n+1} = t_{\\text{crit}} \\frac{\\mathbf{t}_t^{\\text{trial}}}{\\|\\mathbf{t}_t^{\\text{trial}}\\|} = (\\mu p_n) \\frac{\\mathbf{t}_t^{\\text{trial}}}{\\|\\mathbf{t}_t^{\\text{trial}}\\|}\n$$\n在这种情况下，调用塑性校正器。\n\n对于滑动情况，需要一个数值上的考虑。如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 非常接近于零，其归一化在数值上是不稳定的。然而，如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 小于一个小的容差（例如，$10^{-12}$），则可以保证它处于粘滞区（因为 $\\mu p_n \\ge 0$），因此对滑动的显式检查足以处理这种情况。只有当 $\\|\\mathbf{t}_t^{\\text{trial}}\\|  \\mu p_n$ 时才会发生除以 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 的操作，对于任何有意义的摩擦问题，这个值都是非零的。\n\n### 3. 算法总结\n\n对于每个具有输入 $\\{\\mathbf{n}, \\mathbf{v}_{\\text{rel}}, \\Delta t, k_t, \\mu, p_n, \\mathbf{t}_t^n\\}$ 的测试案例，计算 $\\Delta\\boldsymbol{\\delta}_t$ 和 $\\mathbf{t}_t^{n+1}$ 的算法如下：\n\n1.  **归一化法向矢量**：\n    计算单位法线 $\\widehat{\\mathbf{n}} = \\mathbf{n} / \\|\\mathbf{n}\\|$。\n\n2.  **计算切向滑移增量**：\n    a. 计算相对位移增量：$\\Delta \\mathbf{u}_{\\text{rel}} = \\mathbf{v}_{\\text{rel}} \\Delta t$。\n    b. 将 $\\Delta \\mathbf{u}_{\\text{rel}}$ 投影到切平面以获得滑移增量：$\\Delta\\boldsymbol{\\delta}_t = \\Delta \\mathbf{u}_{\\text{rel}} - (\\widehat{\\mathbf{n}} \\cdot \\Delta \\mathbf{u}_{\\text{rel}}) \\widehat{\\mathbf{n}}$。\n\n3.  **弹性预测**：\n    计算试探切向牵引力：$\\mathbf{t}_t^{\\text{trial}} = \\mathbf{t}_t^n + k_t \\Delta\\boldsymbol{\\delta}_t$。\n\n4.  **摩擦校正器（径向返回）**：\n    a. 计算试探牵引力的模 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$。\n    b. 计算摩擦极限：$t_{\\text{crit}} = \\mu p_n$。\n    c. 设置一个布尔标志 `corrector_invoked = False`。\n    d. 如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\|  t_{\\text{crit}}$：\n        i.  状态为滑动。设置 `corrector_invoked = True`。\n        ii. 通过径向返回更新牵引力：$\\mathbf{t}_t^{n+1} = t_{\\text{crit}} \\frac{\\mathbf{t}_t^{\\text{trial}}}{\\|\\mathbf{t}_t^{\\text{trial}}\\|}$。\n    e. 否则（如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\| \\le t_{\\text{crit}}$）：\n        i.  状态为粘滞。\n        ii. 更新后的牵引力即为试探牵引力：$\\mathbf{t}_t^{n+1} = \\mathbf{t}_t^{\\text{trial}}$。\n\n5.  **输出**：\n    存储计算出的 $\\Delta\\boldsymbol{\\delta}_t$ 的两个分量、$\\mathbf{t}_t^{n+1}$ 的两个分量以及布尔值 `corrector_invoked`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the tangential slip increment and updated tangential traction\n    for a node-to-segment frictional contact problem using a radial return algorithm.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Sliding, axis-aligned normal\n        {'n': [0, 1], 'v_rel': [0.1, -0.2], 'dt': 0.01, 'k_t': 1e6, 'mu': 0.3, 'p_n': 1000, 't_t_n': [0, 0]},\n        \n        # Case 2: Sticking, small tangential increment\n        {'n': [0, 1], 'v_rel': [0.001, 0.0], 'dt': 0.001, 'k_t': 1e6, 'mu': 0.4, 'p_n': 500, 't_t_n': [0, 0]},\n        \n        # Case 3: On the friction bound, no return needed\n        {'n': [0, 1], 'v_rel': [0.2, 0.0], 'dt': 0.001, 'k_t': 1e6, 'mu': 0.3, 'p_n': 1000, 't_t_n': [100, 0]},\n        \n        # Case 4: Sliding, oblique projection with non-unit normal\n        {'n': [2, 2], 'v_rel': [0.05, 0.0], 'dt': 0.02, 'k_t': 5e5, 'mu': 0.25, 'p_n': 400, 't_t_n': [10, 20]},\n        \n        # Case 5: Zero relative velocity, stick with pre-existing traction\n        {'n': [0, 1], 'v_rel': [0.0, 0.0], 'dt': 0.05, 'k_t': 2e6, 'mu': 0.6, 'p_n': 800, 't_t_n': [100, 200]},\n    ]\n\n    all_results_strings = []\n\n    for case in test_cases:\n        # Step 0: Extract givens and convert to numpy arrays\n        n = np.array(case['n'], dtype=float)\n        v_rel = np.array(case['v_rel'], dtype=float)\n        dt = case['dt']\n        k_t = case['k_t']\n        mu = case['mu']\n        p_n = case['p_n']\n        t_t_n = np.array(case['t_t_n'], dtype=float)\n\n        # Step 1: Normalize the normal vector\n        norm_n = np.linalg.norm(n)\n        if norm_n == 0:\n            # Handle the unlikely case of a zero normal vector\n            n_hat = np.zeros_like(n)\n        else:\n            n_hat = n / norm_n\n\n        # Step 2: Compute tangential slip increment\n        delta_u_rel = v_rel * dt\n        # Project onto normal: (n_hat . delta_u_rel) * n_hat\n        normal_component = np.dot(n_hat, delta_u_rel) * n_hat\n        # Tangential slip increment is the total minus the normal component\n        delta_t = delta_u_rel - normal_component\n\n        # Step 3: Elastic Predictor\n        # Compute trial tangential traction\n        t_t_trial = t_t_n + k_t * delta_t\n\n        # Step 4: Frictional Corrector (Radial Return)\n        norm_t_t_trial = np.linalg.norm(t_t_trial)\n        t_crit = mu * p_n\n        \n        corrector_invoked = False\n        \n        # Handle the tolerance for near-zero trial traction magnitude implicitly.\n        # If norm_t_t_trial is very small, it will be less than t_crit (as t_crit >= 0).\n        if norm_t_t_trial > t_crit:\n            # Slip condition: return to friction cone\n            corrector_invoked = True\n            # The condition norm_t_t_trial > t_crit ensures norm_t_t_trial is not zero,\n            # so the division is safe.\n            t_t_n_plus_1 = t_crit * (t_t_trial / norm_t_t_trial)\n        else:\n            # Stick condition: elastic update is admissible\n            t_t_n_plus_1 = t_t_trial\n\n        # Step 5: Format the output for this case\n        case_result_values = [\n            delta_t[0],\n            delta_t[1],\n            t_t_n_plus_1[0],\n            t_t_n_plus_1[1],\n            corrector_invoked\n        ]\n        \n        formatted_values = []\n        for val in case_result_values:\n            if isinstance(val, bool):\n                formatted_values.append(str(val))\n            else:\n                formatted_values.append(f\"{val:.6f}\")\n        \n        all_results_strings.append(f\"[{','.join(formatted_values)}]\")\n\n    # Final print statement in the exact required format\n    final_output = f\"[{','.join(all_results_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3584809"}, {"introduction": "在接触力学模拟中，节点-接触段（NTS）和接触段-接触段（STS）是两种主流的离散化策略。选择哪种方法对计算结果的精度、稳定性和效率有着深远的影响。本练习通过一个具有精确解析解的赫兹接触（Hertzian contact）基准问题，让你对这两种方法进行定量的性能评估。你将通过编写代码，在网格不断细化的过程中计算数值解的误差收敛速度，从而客观地揭示 NTS 和 STS 方法在精度和收敛特性上的根本差异。", "problem": "考虑一个一维赫兹线接触基准问题，该问题定义在闭区间 $\\left[-a,a\\right]$ 上，其精确的法向接触压力分布为 $p(x)=p_{0}\\,\\sqrt{1-\\left(\\frac{x}{a}\\right)^{2}}$（其中 $x\\in\\left[-a,a\\right]$），以无量纲单位表示。该压力源于弹性体之间的经典无摩擦法向接触，是一个在接触边缘 $x=\\pm a$ 处以平方根剖面消失的光滑函数。您将比较两种离散接触压力表示，并量化当网格加密时它们的收敛率。\n\n待对比的两种方案定义如下。\n- 段-段 (STS) 方法：定义有限维空间 $\\mathcal{V}_{h}$ 为在 $\\left[-a,a\\right]$ 的一个均匀剖分（该剖分将区间分为 $N$ 个大小为 $h=\\frac{2a}{N}$ 的相等线段）上的连续分段线性函数集合。STS 近似 $p_{h}^{\\mathrm{STS}}\\in\\mathcal{V}_{h}$ 是 $p$ 在 $\\mathcal{V}_{h}$ 上的 $L^{2}$ 正交投影，即它满足变分陈述 $\\int_{-a}^{a}\\left(p_{h}^{\\mathrm{STS}}(x)-p(x)\\right)\\,v_{h}(x)\\,\\mathrm{d}x=0$，对所有 $v_{h}\\in\\mathcal{V}_{h}$ 成立。\n- 节点-段 (NTS) 方法：定义有限维空间 $\\mathcal{W}_{h}$ 为在相同剖分上的分段常数函数集合。NTS 近似 $p_{h}^{\\mathrm{NTS}}\\in\\mathcal{W}_{h}$ 通过在每个单元的左端点进行节点配置来定义：在单元 $e=\\left[x_{i},x_{i+1}\\right]$ 上，对于所有 $x\\in e$，设置 $p_{h}^{\\mathrm{NTS}}(x)=p(x_{i})$，其中 $x_{i}=-a+i\\,h$，对于 $i\\in\\{0,1,\\dots,N-1\\}$。\n\n每种近似的精度通过相对 $L^{2}$ 误差来衡量\n$$\ne(h)=\\frac{\\left\\|p-p_{h}\\right\\|_{L^{2}(-a,a)}}{\\left\\|p\\right\\|_{L^{2}(-a,a)}},\\quad \\left\\|q\\right\\|_{L^{2}(-a,a)}=\\left(\\int_{-a}^{a}q(x)^{2}\\,\\mathrm{d}x\\right)^{\\frac{1}{2}}.\n$$\n所有积分必须使用足够精度的数值积分方法进行计算，以可靠地解析 $x=\\pm a$ 附近的平方根行为；在每个单元上使用高阶高斯-勒让德积分来计算所需的积分。\n\n将实验收敛率 $r$ 定义为，对于一组网格尺寸 $\\{h_{k}\\}$ 和相应的误差 $\\{e(h_{k})\\}$，在最小二乘意义下，将 $\\log h_{k}$ 映射到 $\\log e(h_{k})$ 的最佳拟合直线的斜率，即在所有给定的网格尺寸上，$\\log e$ 对 $\\log h$ 的线性回归的斜率。\n\n从以下必须用于推导和实现此程序的概念基础开始：\n- 连续介质力学中的无摩擦单边接触由间隙和法向牵引力之间的互补性以及线性动量平衡决定；在当前的基准问题中，精确压力 $p(x)$ 是先验已知的。\n- $L^{2}$ 内积中的正交投影在子空间上最小化 $L^{2}$ 误差，并导出一个带有质量矩阵的对称正定线性系统，该质量矩阵由所选基函数生成。\n- 基于左端点节点值的分段常数配置是对均匀网格上光滑场的一致的一阶表示。\n\n任务：对于下方的每个测试用例，构建具有 $N$ 个单元的均匀网格，如上文定义计算这些网格上的 $p_{h}^{\\mathrm{STS}}$ 和 $p_{h}^{\\mathrm{NTS}}$，评估 $e^{\\mathrm{STS}}(h)$ 和 $e^{\\mathrm{NTS}}(h)$，然后通过对数据对 $\\left(\\log h,\\log e\\right)$ 进行最小二乘法来估计收敛率 $r^{\\mathrm{STS}}$ 和 $r^{\\mathrm{NTS}}$。此外，对于每个测试用例，确定在最细网格（最小的 $h$）上，STS 方法是否比 NTS 方法更精确，即检查 $e^{\\mathrm{STS}}(h_{\\min})  e^{\\mathrm{NTS}}(h_{\\min})$。\n\n为以下每个测试用例提供结果，包括每种方案的收敛率以及在最细网格上 STS 是否更精确的布尔标志。\n- 测试用例1: $a=1.0$, $p_0=1.0$, $N \\in \\{8, 16, 32, 64\\}$\n- 测试用例2: $a=1.0$, $p_0=3.0$, $N \\in \\{8, 16, 32, 64\\}$\n- 测试用例3: $a=0.5$, $p_0=2.0$, $N \\in \\{10, 20, 40, 80\\}$\n\n将三个测试用例的所有结果聚合为单行，形式为用方括号括起来的逗号分隔列表，其中每个案例的结果本身就是一个方括号列表，包含三个条目：$r^{\\mathrm{STS}}$, $r^{\\mathrm{NTS}}$, 以及一个布尔值，所有浮点数四舍五入到三位小数。\n例如：`[[1.500,0.500,True],[1.500,0.500,True],[1.500,0.500,True]]`", "solution": "本练习的目标是量化和比较两种离散化方法（NTS 和 STS）在逼近一维赫兹接触压力分布时的收敛行为。我们将分别推导两种方法的误差计算方案，并阐述如何通过数值实验估计收敛率。\n\n### 1. 误差度量\n两种方法的精度都通过相对 $L^2$ 误差来衡量。首先，我们需要计算精确解 $p(x)$ 的 $L^2$ 范数的平方，$\\|p\\|_{L^2}^2$。该值可以通过解析积分得到：\n$$\n\\|p\\|_{L^2}^2 = \\int_{-a}^{a} p_0^2 \\left(1 - \\left(\\frac{x}{a}\\right)^2\\right) dx = p_0^2 \\left[x - \\frac{x^3}{3a^2}\\right]_{-a}^{a} = \\frac{4}{3} a p_0^2.\n$$\n相对 $L^2$ 误差为 $e(h) = \\sqrt{\\|p - p_h\\|_{L^2}^2 / \\|p\\|_{L^2}^2}$。因此，核心任务是计算每种近似的绝对 $L^2$ 误差的平方 $\\|p - p_h\\|_{L^2}^2$。\n\n### 2. NTS 近似误差\nNTS 方法使用分段常数函数 $p_h^{\\text{NTS}}$ 来近似 $p(x)$。在每个单元 $e_i = [x_i, x_{i+1}]$ 上，$p_h^{\\text{NTS}}(x) = p(x_i)$。\n总的平方误差是每个单元上误差的累加：\n$$\n\\|p - p_h^{\\text{NTS}}\\|_{L^2}^2 = \\sum_{i=0}^{N-1} \\int_{x_i}^{x_{i+1}} (p(x) - p(x_i))^2 dx.\n$$\n由于 $p(x)$ 在单元边界处存在平方根奇点，此积分需要通过高阶数值积分（如高斯-勒让德积分）来精确计算。\n\n### 3. STS 近似误差\nSTS 方法使用连续分段线性函数 $p_h^{\\text{STS}} \\in \\mathcal{V}_h$ 来近似 $p(x)$，该近似是 $p(x)$ 在 $\\mathcal{V}_h$ 上的 $L^2$ 正交投影。设 $p_h^{\\text{STS}}(x) = \\sum_{k=0}^{N} c_k N_k(x)$，其中 $N_k(x)$ 是标准的线性“帽”函数基底，$c_k$ 是待求的节点系数值。\n\n$L^2$ 投影的定义要求近似误差 $(p - p_h^{\\text{STS}})$ 与近似空间 $\\mathcal{V}_h$ 中的任何函数 $v_h$ 正交。特别地，我们可以选择基函数 $N_j(x)$ 作为检验函数：\n$$\n\\int_{-a}^{a} (p(x) - p_h^{\\text{STS}}(x)) N_j(x) dx = 0, \\quad \\forall j \\in \\{0, \\dots, N\\}.\n$$\n代入 $p_h^{\\text{STS}}$ 的表达式，我们得到一个线性方程组：\n$$\n\\sum_{k=0}^{N} c_k \\left( \\int_{-a}^{a} N_k(x) N_j(x) dx \\right) = \\int_{-a}^{a} p(x) N_j(x) dx.\n$$\n这可以写成矩阵形式 $\\mathbf{M}\\mathbf{c} = \\mathbf{f}$，其中：\n- $\\mathbf{M}$ 是“质量矩阵”，其元素为 $M_{jk} = \\int_{-a}^{a} N_j(x) N_k(x) dx$。\n- $\\mathbf{f}$ 是“载荷向量”，其元素为 $f_j = \\int_{-a}^{a} p(x) N_j(x) dx$。\n- $\\mathbf{c}$ 是包含未知系数 $c_k$ 的向量。\n\n求解这个线性系统可以得到系数 $\\mathbf{c}$，从而确定 $p_h^{\\text{STS}}(x)$。\n\n计算 STS 误差时，我们可以利用 $L^2$ 投影的正交性。由于 $(p - p_h^{\\text{STS}}, p_h^{\\text{STS}})_{L^2} = 0$，我们有 $(p, p_h^{\\text{STS}})_{L^2} = \\|p_h^{\\text{STS}}\\|_{L^2}^2$。因此，误差的平方可以简化为：\n$$\n\\|p - p_h^{\\text{STS}}\\|_{L^2}^2 = (p - p_h^{\\text{STS}}, p - p_h^{\\text{STS}})_{L^2} = \\|p\\|_{L^2}^2 - (p, p_h^{\\text{STS}})_{L^2}.\n$$\n其中 $(p, p_h^{\\text{STS}})_{L^2} = \\int p(x) \\left(\\sum_k c_k N_k(x)\\right) dx = \\sum_k c_k \\left(\\int p(x) N_k(x) dx\\right) = \\mathbf{c}^T \\mathbf{f}$。\n最终，我们得到一个高效的误差计算公式：\n$$\n\\|p - p_h^{\\text{STS}}\\|_{L^2}^2 = \\|p\\|_{L^2}^2 - \\mathbf{c}^T \\mathbf{f}.\n$$\n矩阵 $\\mathbf{M}$ 和向量 $\\mathbf{f}$ 中的积分同样需要通过高阶数值积分来计算。\n\n### 4. 收敛率估计\n对于一系列网格尺寸 $h_k$ 和计算出的相应误差 $e_k$，我们假设误差行为遵循 $e(h) \\approx C h^r$。两边取对数得到 $\\log(e) \\approx \\log(C) + r \\log(h)$。这是一个线性关系。因此，收敛率 $r$ 可以通过对数据点 $(\\log(h_k), \\log(e_k))$ 进行线性回归（最小二乘拟合）来估计，其结果即为拟合直线的斜率。\n\n由于赫兹压力函数在接触区域的边缘处不可导（其导数是无限的），标准的收敛理论预测会被修正。我们预期 NTS（分段常数）方法的收敛率约为 $r \\approx 0.5$，而 STS（分段线性 $L^2$ 投影）方法的收敛率约为 $r \\approx 1.5$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef p_func(x, a, p0):\n    \"\"\"\n    Computes the exact Hertzian pressure p(x). Uses np.maximum to prevent\n    taking the square root of a small negative number due to floating point\n    inaccuracies for x near +-a.\n    \"\"\"\n    arg = 1.0 - (x / a)**2\n    return p0 * np.sqrt(np.maximum(0, arg))\n\ndef calculate_nts_error_sq(a, p0, N, h, q_points, q_weights):\n    \"\"\"\n    Calculates the squared L2 error for the Node-to-Segment (NTS) approximation.\n    The NTS approximation is piecewise constant, defined by nodal collocation\n    at the left endpoint of each element.\n    \"\"\"\n    nodes = np.linspace(-a, a, N + 1)\n    total_error_sq = 0.0\n    for i in range(N):\n        x_i, x_i1 = nodes[i], nodes[i+1]\n        \n        # NTS approximation is p(x_i) on element i.\n        p_val_at_node = p_func(x_i, a, p0)\n        \n        # Map standard quadrature points [-1, 1] to the element [x_i, x_i1]\n        x_q = 0.5 * h * q_points + 0.5 * (x_i + x_i1)\n        \n        # Evaluate exact pressure and the integrand at quadrature points\n        p_vals_q = p_func(x_q, a, p0)\n        integrand = (p_vals_q - p_val_at_node)**2\n        \n        # Numerically compute the integral over the element. Jacobian is h/2.\n        elem_integral = (h / 2.0) * np.sum(q_weights * integrand)\n        total_error_sq += elem_integral\n        \n    return total_error_sq\n\ndef calculate_sts_error_sq(a, p0, N, h, p_norm_sq, q_points, q_weights):\n    \"\"\"\n    Calculates the squared L2 error for the Segment-to-Segment (STS) approximation.\n    The STS approximation is the L^2 projection onto piecewise linear functions.\n    \"\"\"\n    num_nodes = N + 1\n    nodes = np.linspace(-a, a, num_nodes)\n    \n    # Assemble the consistent mass matrix M for 1D linear elements on a uniform mesh\n    M = np.zeros((num_nodes, num_nodes))\n    diag = np.full(num_nodes, 2.0 * h / 3.0)\n    diag[0] = h / 3.0\n    diag[-1] = h / 3.0\n    off_diag = np.full(num_nodes - 1, h / 6.0)\n    M += np.diag(diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # Assemble the load vector f, where f_k = integral(p(x) * N_k(x) dx)\n    f = np.zeros(num_nodes)\n    for k in range(num_nodes):\n        f_k = 0.0\n        \n        # Contribution from the left element [x_{k-1}, x_k]\n        if k > 0:\n            x_start, x_end = nodes[k-1], nodes[k]\n            x_q = 0.5 * h * q_points + 0.5 * (x_start + x_end)\n            basis_vals = (x_q - x_start) / h\n            p_vals = p_func(x_q, a, p0)\n            f_k += (h / 2.0) * np.sum(q_weights * p_vals * basis_vals)\n            \n        # Contribution from the right element [x_k, x_{k+1}]\n        if k  N:\n            x_start, x_end = nodes[k], nodes[k+1]\n            x_q = 0.5 * h * q_points + 0.5 * (x_start + x_end)\n            basis_vals = (x_end - x_q) / h\n            p_vals = p_func(x_q, a, p0)\n            f_k += (h / 2.0) * np.sum(q_weights * p_vals * basis_vals)\n            \n        f[k] = f_k\n        \n    # Solve the system Mc = f for the nodal coefficients c\n    c = np.linalg.solve(M, f)\n    \n    # Compute error using the orthogonality property: ||p-p_h||^2 = ||p||^2 - c^T f\n    error_sq = p_norm_sq - np.dot(c, f)\n    \n    return error_sq\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 1.0, 'p0': 1.0, 'N_values': [8, 16, 32, 64]},\n        {'a': 1.0, 'p0': 3.0, 'N_values': [8, 16, 32, 64]},\n        {'a': 0.5, 'p0': 2.0, 'N_values': [10, 20, 40, 80]},\n    ]\n    \n    # High-order quadrature is specified to handle the function's square-root behavior.\n    QUAD_ORDER = 40\n    q_points, q_weights = np.polynomial.legendre.leggauss(QUAD_ORDER)\n\n    all_results = []\n\n    for case in test_cases:\n        a = case['a']\n        p0 = case['p0']\n        N_values = case['N_values']\n\n        h_list = []\n        e_sts_list = []\n        e_nts_list = []\n\n        # Analytical L2 norm squared of p(x) for relative error calculation.\n        # ||p||^2 = integral_{-a to a} (p0^2 * (1-(x/a)^2)) dx = (4/3)*a*p0^2\n        p_norm_sq = (4.0 / 3.0) * a * p0**2\n\n        for N in N_values:\n            h = 2.0 * a / N\n            h_list.append(h)\n            \n            # NTS error calculation\n            nts_error_sq = calculate_nts_error_sq(a, p0, N, h, q_points, q_weights)\n            e_nts = np.sqrt(nts_error_sq / p_norm_sq)\n            e_nts_list.append(e_nts)\n            \n            # STS error calculation\n            sts_error_sq = calculate_sts_error_sq(a, p0, N, h, p_norm_sq, q_points, q_weights)\n            e_sts = np.sqrt(max(0, sts_error_sq) / p_norm_sq)\n            e_sts_list.append(e_sts)\n\n        # Convergence rate is the slope of log(e) vs log(h)\n        log_h = np.log(h_list)\n        log_e_sts = np.log(e_sts_list)\n        log_e_nts = np.log(e_nts_list)\n        \n        # Use numpy's polyfit for linear regression\n        r_sts = np.polyfit(log_h, log_e_sts, 1)[0]\n        r_nts = np.polyfit(log_h, log_e_nts, 1)[0]\n        \n        # Compare accuracy at the finest mesh (last element in the list)\n        is_sts_more_accurate = e_sts_list[-1]  e_nts_list[-1]\n        \n        # Store results rounded as specified\n        case_result = [round(r_sts, 3), round(r_nts, 3), is_sts_more_accurate]\n        all_results.append(case_result)\n        \n    # Format the final output string to match the required format e.g., [[r1,r2,b1],[...]]\n    # with no spaces between list elements.\n    list_of_str_results = []\n    for res in all_results:\n        # Python's default str(bool) is 'True' or 'False', which is what's expected.\n        list_of_str_results.append(f\"[{res[0]},{res[1]},{str(res[2])}]\")\n    final_output_str = f\"[{','.join(list_of_str_results)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3584744"}]}