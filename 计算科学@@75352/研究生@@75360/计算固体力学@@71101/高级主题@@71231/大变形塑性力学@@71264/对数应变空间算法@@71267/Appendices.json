{"hands_on_practices": [{"introduction": "我们的实践探索始于对数应变本身的核心定义。该练习聚焦于计算给定拉伸张量的亨盖应变（Hencky strain），并引导我们分析在极端变形情况下出现的数值挑战 [@problem_id:3579140]。在构建更复杂的计算模型之前，理解这些基础概念至关重要。", "problem": "考虑一个均匀变形，其变形梯度为 $\\mathbf{F} \\in \\mathbb{R}^{3 \\times 3}$，允许进行极分解 $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$，其中 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 是一个旋转张量，$\\mathbf{U} \\in \\mathbb{R}^{3 \\times 3}$ 是右拉伸张量。假设 $\\mathbf{U}$ 是对称正定（SPD）的，其主拉伸为 $\\lambda_{1} > 0$，$\\lambda_{2} > 0$ 和 $\\lambda_{3} > 0$，并且存在一个标准正交基，在该基下 $\\mathbf{U}$ 是对角阵，$\\mathbf{U} = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$。在对数应变空间算法中，Hencky（对数）应变张量定义为拉伸张量的矩阵对数，即 $\\ln \\mathbf{U}$。\n\n从对称正定张量解析函数的光谱表征以及自然对数在 $(0,\\infty)$ 上的性质出发，计算给定对角阵 $\\mathbf{U}$ 的矩阵对数 $\\ln \\mathbf{U}$ 的闭合形式解。此外，请基于数值分析和微积分的基本原理，解释当任何一个 $\\lambda_{i}$ 在计算 $\\ln \\mathbf{U}$ 及其算法切线时趋近于零或变得非常大时的定性行为和数值影响。你的最终答案必须是 $\\ln \\mathbf{U}$ 的唯一解析表达式。无需四舍五入，且不涉及物理单位。", "solution": "问题陈述是有效的。它在连续介质力学中有科学依据，问题提法恰当，并以客观、精确的语言呈现。所有提供的信息都是自洽的，足以推导出解答。\n\n主要任务是计算 Hencky 应变张量，该张量定义为矩阵对数 $\\ln \\mathbf{U}$，其中 $\\mathbf{U}$ 是对称正定（SPD）的右拉伸张量。我们已知在某个标准正交基中，$\\mathbf{U}$ 是对角阵，$\\mathbf{U} = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$，其中 $\\lambda_{i} > 0$ 是主拉伸。\n\n矩阵函数（如 $\\ln \\mathbf{U}$）的计算是通过其谱分解来定义的。对于一个对称（因此可对角化）的矩阵 $\\mathbf{U}$，谱定理指出它可以写为：\n$$\n\\mathbf{U} = \\sum_{i=1}^{3} \\lambda_{i} \\mathbf{n}_{i} \\otimes \\mathbf{n}_{i}\n$$\n其中 $\\lambda_{i}$ 是实特征值（主拉伸），$\\mathbf{n}_{i}$ 是相应的标准正交特征向量（主拉伸方向）。\n\n如果一个标量函数 $f(x)$ 在 $\\mathbf{U}$ 的谱上（即在所有特征值 $\\lambda_{i}$ 处）是解析的，那么张量值函数 $f(\\mathbf{U})$ 定义为：\n$$\nf(\\mathbf{U}) = \\sum_{i=1}^{3} f(\\lambda_{i}) \\mathbf{n}_{i} \\otimes \\mathbf{n}_{i}\n$$\n这就是对称正定张量解析函数的谱表征。\n\n在这个问题中，函数是自然对数 $f(x) = \\ln(x)$。$\\ln(x)$ 的解析域是正实数集合 $(0, \\infty)$。由于拉伸张量 $\\mathbf{U}$ 是对称正定的（SPD），其特征值 $\\lambda_{i}$（主拉伸）都严格为正。因此，$\\mathbf{U}$ 的谱完全位于自然对数的解析域内，所以 $\\ln \\mathbf{U}$ 是良定义的。\n\n我们已知，在其特征向量基 $\\{\\mathbf{n}_1, \\mathbf{n}_2, \\mathbf{n}_3\\}$ 中，$\\mathbf{U}$ 的矩阵表示是对角的：\n$$\n[\\mathbf{U}] = \\begin{pmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{pmatrix}\n$$\n应用矩阵函数的定义，我们将 $f(\\lambda_{i}) = \\ln(\\lambda_{i})$ 代入 $f(\\mathbf{U})$ 的谱表示。在同一个标准正交基中，$\\ln \\mathbf{U}$ 的矩阵表示将是：\n$$\n[\\ln \\mathbf{U}] = \\begin{pmatrix} f(\\lambda_1) & 0 & 0 \\\\ 0 & f(\\lambda_2) & 0 \\\\ 0 & 0 & f(\\lambda_3) \\end{pmatrix} = \\begin{pmatrix} \\ln(\\lambda_1) & 0 & 0 \\\\ 0 & \\ln(\\lambda_2) & 0 \\\\ 0 & 0 & \\ln(\\lambda_3) \\end{pmatrix}\n$$\n这就是在主拉伸基中，Hencky 应变张量的闭合形式表达式。\n\n问题的第二部分要求解释在极端拉伸下的定性行为和数值影响。\n\n**情况1：主拉伸趋近于零 ($\\lambda_{i} \\to 0^{+}$)**\n这对应于一种极端压缩状态，其中材料单元在 $\\mathbf{n}_{i}$ 方向上被压缩至零长度。\n*   **定性行为**：当 $\\lambda_{i} \\to 0^{+}$ 时，相应的主对数应变 $\\ln(\\lambda_{i})$ 趋近于 $-\\infty$。这正确地表示了在该方向上实现体积坍缩所需的无限压缩应变。\n*   **数值影响**：标准浮点运算在没有特殊标志的情况下无法表示 $-\\infty$。涉及接近于零的 $\\lambda_{i}$ 的计算将导致 $\\ln(\\lambda_{i})$ 的值成为一个非常大的负数，可能导致下溢或被标记为 `-Inf`。这会通过算法传播，导致 `NaN`（非数值）结果和数值模拟（例如，Newton-Raphson 迭代求解器）的失败。此外，算法切线模量，即表示 Kirchhoff 应力对对数应变的导数的四阶张量，通常包含变得奇异或病态的项。例如，切线的分量可能涉及诸如 $\\frac{\\ln(\\lambda_i) - \\ln(\\lambda_j)}{\\lambda_i^2 - \\lambda_j^2}$ 的表达式。当 $\\lambda_i \\to 0^+$ 时，分子发散到 $-\\infty$，而分母保持有限（假设 $\\lambda_j > 0$），导致这些切线分量变为无穷大。这会导致刚度矩阵病态、收敛失败和数值不稳定性。\n\n**情况2：主拉伸变得非常大 ($\\lambda_{i} \\to \\infty$)**\n这对应于一种极端拉伸状态，其中材料单元在 $\\mathbf{n}_{i}$ 方向上被无限拉伸。\n*   **定性行为**：当 $\\lambda_{i} \\to \\infty$ 时，主对数应变 $\\ln(\\lambda_{i})$ 也趋近于 $+\\infty$。对数度量意味着应变的增长速度远慢于拉伸本身，这是该应变度量在大变形分析中的一个关键优势。\n*   **数值影响**：虽然 $\\ln(\\lambda_{i})$ 无界增长，但其增长速度非常缓慢。在 $\\ln(\\lambda_{i})$ 上发生数值溢出之前，$\\lambda_{i}$ 或相关量（如 $\\lambda_i^2$）可能已经发生溢出。主要的数值问题再次与算法切线的条件数有关。在项 $\\frac{\\ln(\\lambda_i) - \\ln(\\lambda_j)}{\\lambda_i^2 - \\lambda_j^2}$ 中，当 $\\lambda_i \\to \\infty$ 时，分母以 $\\lambda_i^2$ 的速度增长，而分子以 $\\ln(\\lambda_i)$ 的速度增长。根据 L'Hôpital 法则，该项趋近于 $0$。虽然这看起来可能稳定，但一些切线分量趋近于零而其他分量保持有限，仍然可能导致严重的病态问题。特征值之间非常大的差异（例如 $\\lambda_{i} \\gg \\lambda_{j}$）会使系统在数值上变得“刚性”，即刚度矩阵的特征值数量级差异巨大。众所周知，迭代线性求解器很难处理这种情况，从而导致收敛速度慢或失败。\n\n总之，对数映射在变形的极端情况（极端压缩和极端拉伸）下带来了重大的数值挑战，在稳健的计算固体力学代码中必须使用专门的数值技术来处理这些挑战。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\ln(\\lambda_1) & 0 & 0 \\\\\n0 & \\ln(\\lambda_2) & 0 \\\\\n0 & 0 & \\ln(\\lambda_3)\n\\end{pmatrix}\n}\n$$", "id": "3579140"}, {"introduction": "在确立了对数应变的定义之后，我们现在将其应用于计算塑性力学中的一个核心问题：单轴应力更新。这项练习将引导您在对数应变空间中推导并实现经典的弹性预测/塑性修正算法 [@problem_id:3579149]。掌握这一维情况为更普适的大应变弹塑性模拟提供了基本构建模块。", "problem": "请为在对数（Hencky）应变空间中进行的有限应变弹塑性单步单轴更新设计一个完整且可验证的算法。目标是为一个单轴杆计算其在步末经历指定的总对数应变后的更新应力和塑性应变。推导必须从适用于在对数应变空间中建模的有限应变塑性的第一性原理开始，并且实现必须遵循率无关本构中的弹性预测/塑性修正结构，并采用各向同性硬化。\n\n需要使用的基本原理：\n- 运动学：在一维情况下，总拉伸比用 $\\lambda$ 表示，总对数应变（Hencky应变）为 $h = \\ln \\lambda$。变形梯度的行列式（雅可比）为 $J=\\lambda$，弹性对数应变和塑性对数应变相加：$h = h_{\\mathrm{e}} + h_{\\mathrm{p}}$。\n- 功共轭性：Kirchhoff应力 $\\tau$ 与对数应变率是功共轭的。在一维情况下，对数应变空间中的弹性本构关系为 $\\tau = E\\, h_{\\mathrm{e}} = E \\left(h - h_{\\mathrm{p}}\\right)$，其中 $E$ 是杨氏模量。\n- 塑性：使用一维关联率无关塑性模型，并带有各向同性硬化。屈服函数为 $\\phi(\\tau,\\alpha) = |\\tau| - \\tau_{\\mathrm{y}}(\\alpha)$，其中 $\\tau_{\\mathrm{y}}(\\alpha)=\\tau_{\\mathrm{y0}}+H\\,\\alpha$，$α$ 是累积塑性应变，$\\tau_{\\mathrm{y0}}$ 是初始屈服应力，$H$ 是各向同性硬化模量。Kuhn–Tucker条件、一致性条件和关联流动法则均成立。在一维情况下，塑性流动方向由 $\\tau$ 的符号给出。\n\n您必须：\n- 从这些基本原理出发，推导在对数应变空间中单轴情况下的标量返回映射修正器，不援引任何未经证明的简化公式。清楚地展示在塑性区内，如何根据一致性条件获得塑性乘子。\n- 实现弹性预测器和塑性修正器，以计算步末的更新量：Kirchhoff应力 $\\tau_{n+1}$、塑性对数应变 $h_{\\mathrm{p},n+1}$ 和累积塑性应变 $\\alpha_{n+1}$。最后，使用 $\\sigma_{n+1}=\\tau_{n+1}/\\lambda_{n+1}$（其中 $\\lambda_{n+1}=\\exp(h_{n+1})$）计算Cauchy应力 $\\sigma_{n+1}$。\n- 为了数值报告的目的，最终的Cauchy应力以兆帕（MPa）表示。应变 $h_{\\mathrm{p}}$ 和 $\\alpha$ 是无量纲的。所有返回的浮点数值必须四舍五入到 $6$ 位小数。\n\n每个测试用例的输入规范：\n- 材料参数：$E$（单位MPa），$\\tau_{\\mathrm{y0}}$（单位MPa），$H$（单位MPa）。\n- 步末状态/输入：总对数应变 $h_{n+1}$（无量纲），上一步的塑性对数应变 $h_{\\mathrm{p},n}$（无量纲），上一步的累积塑性应变 $\\alpha_n$（无量纲）。\n\n每个测试用例的输出规范：\n- 一个包含 $3$ 个浮点数的列表 $[\\sigma_{n+1}, h_{\\mathrm{p},n+1}, \\alpha_{n+1}]$，其中 $\\sigma_{n+1}$ 的单位是MPa，所有值都四舍五入到 $6$ 位小数。\n\n您的程序必须处理以下测试套件，并将汇总结果输出到单行中。请精确使用下面提供的参数值。\n\n测试套件（每个项目符号提供 $(E,\\tau_{\\mathrm{y0}},H,h_{n+1},h_{\\mathrm{p},n},\\alpha_n)$）：\n- 案例A：$(200000, 300, 1000, 0.0005, 0.0, 0.0)$\n- 案例B：$(210000, 250, 0, 0.003, 0.0, 0.0)$\n- 案例C：$(70000, 100, 1000, 0.01, 0.0, 0.0)$\n- 案例D：$(100000, 200, 500, -0.005, 0.0, 0.0)$\n- 案例E：$(150000, 300, 200, 0.002, 0.0, 0.0)$\n- 案例F：$(210000, 250, 5000, 0.003, 0.01, 0.01)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个Python风格的列表，该列表由各案例的列表组成，不含空格，且每个浮点数都四舍五入到 $6$ 位小数。例如，一个有效的格式可能如下所示：$[[1.234000,0.000000,0.000000],[\\dots]]$，其中省略号表示其他案例。\n\n角度单位不适用。确保科学真实性和数值一致性。无需用户输入；程序必须嵌入测试套件并按所述确切格式将结果打印为单行。", "solution": "用户提供的问题经评估为**有效**。该问题在科学上基于连续介质力学和计算塑性力学的原理，是适定的、客观的，并包含了获得唯一解所需的所有必要信息。现将介绍用于对数应变空间中有限应变单轴弹塑性的返回映射算法的推导和实现。\n\n### **1. 问题描述**\n\n该问题涉及一个经历有限变形的单轴杆的状态更新。运动学通过总对数应变 $h = \\ln \\lambda$ 来描述，其中 $\\lambda$ 是拉伸比。模型假设总对数应变可以加法分解为弹性和塑性两部分：\n$$h = h_{\\mathrm{e}} + h_{\\mathrm{p}}$$\n一个时间步开始时（用下标 $n$ 表示）的材料状态由塑性对数应变 $h_{\\mathrm{p},n}$ 和累积塑性应变 $\\alpha_n$ 来表征。问题要求在给定步末总对数应变 $h_{n+1}$ 的情况下，求解更新后的状态 $\\{h_{\\mathrm{p},n+1}, \\alpha_{n+1}\\}$ 以及相应的应力（用下标 $n+1$ 表示）。\n\n本构关系如下：\n- **弹性**：Kirchhoff应力 $\\tau$ 通过杨氏模量 $E$ 与弹性对数应变 $h_{\\mathrm{e}}$ 相关联：\n  $$\\tau = E h_{\\mathrm{e}} = E(h - h_{\\mathrm{p}})$$\n- **屈服条件**：当屈服函数 $\\phi$ 为正时，发生塑性流动。对于一维各向同性硬化，屈服函数为：\n  $$\\phi(\\tau, \\alpha) = |\\tau| - \\tau_{\\mathrm{y}}(\\alpha) \\leq 0$$\n  其中屈服应力 $\\tau_{\\mathrm{y}}$ 是累积塑性应变 $\\alpha$ 的线性函数：\n  $$\\tau_{\\mathrm{y}}(\\alpha) = \\tau_{\\mathrm{y0}} + H \\alpha$$\n  此处，$\\tau_{\\mathrm{y0}}$ 是初始屈服应力，$H$ 是恒定的硬化模量。\n- **流动法则**：假设采用关联流动法则，塑性应变的增量方向沿着屈服函数对应力的梯度方向：\n  $$\\Delta h_{\\mathrm{p}} = h_{\\mathrm{p},n+1} - h_{\\mathrm{p},n} = \\Delta \\gamma \\frac{\\partial \\phi}{\\partial \\tau} = \\Delta \\gamma \\, \\text{sgn}(\\tau_{n+1})$$\n  其中 $\\Delta \\gamma \\geq 0$ 是该步的塑性乘子。\n- **硬化法则**：累积塑性应变的增量等于塑性应变增量的大小，在一维情况下，这恰好是塑性乘子：\n  $$\\Delta \\alpha = \\alpha_{n+1} - \\alpha_n = |\\Delta h_{\\mathrm{p}}| = \\Delta \\gamma$$\n\n最终的Cauchy应力 $\\sigma_{n+1}$ 通过以下关系从Kirchhoff应力 $\\tau_{n+1}$ 获得：\n$$\\sigma_{n+1} = \\frac{\\tau_{n+1}}{J_{n+1}} = \\frac{\\tau_{n+1}}{\\lambda_{n+1}} = \\frac{\\tau_{n+1}}{\\exp(h_{n+1})}$$\n\n### **2. 算法推导：返回映射**\n\n该算法基于标准的弹性预测/塑性修正结构，这是一种隐式时间积分方案。\n\n#### **步骤 2.1：弹性预测**\n\n首先，假设该步完全是弹性的。塑性状态变量被暂时保持恒定。计算“试探”状态如下：\n- 试探塑性应变：$h_{\\mathrm{p, trial}} = h_{\\mathrm{p},n}$\n- 试探累积塑性应变：$\\alpha_{\\text{trial}} = \\alpha_n$\n- 试探弹性应变：$h_{\\mathrm{e, trial}} = h_{n+1} - h_{\\mathrm{p, trial}} = h_{n+1} - h_{\\mathrm{p},n}$\n- 试探Kirchhoff应力：使用弹性定律计算：\n  $$\\tau_{\\text{trial}} = E h_{\\mathrm{e, trial}} = E (h_{n+1} - h_{\\mathrm{p},n})$$\n\n#### **步骤 2.2：屈服检查**\n\n将试探状态与屈服条件进行核对。步初的屈服应力为 $\\tau_{\\mathrm{y},n} = \\tau_{\\mathrm{y0}} + H \\alpha_n$。试探屈服函数值为：\n$$\\phi_{\\text{trial}} = |\\tau_{\\text{trial}}| - \\tau_{\\mathrm{y},n} = |\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n)$$\n\n- 如果 $\\phi_{\\text{trial}} \\le 0$，则弹性假设正确。试探状态即为最终状态。\n  - $\\tau_{n+1} = \\tau_{\\text{trial}}$\n  - $h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n}$\n  - $\\alpha_{n+1} = \\alpha_n$\n\n- 如果 $\\phi_{\\text{trial}} > 0$，则发生了塑性变形。试探状态违反了屈服条件，需要进行塑性修正。\n\n#### **步骤 2.3：塑性修正**\n\n当塑性发生时，步末的状态必须同时满足全套本构方程。这就是“返回映射”阶段，它将试探应力投影回更新后的屈服面上。待求解未知数 $\\{\\tau_{n+1}, h_{\\mathrm{p},n+1}, \\alpha_{n+1}, \\Delta\\gamma\\}$ 的方程组为：\n1.  **弹性**：$\\tau_{n+1} = E(h_{n+1} - h_{\\mathrm{p},n+1})$\n2.  **流动法则**：$h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$ (注意：$\\text{sgn}(\\tau_{n+1})=\\text{sgn}(\\tau_{\\text{trial}})$，因为在应力空间中返回路径是径向的)\n3.  **硬化法则**：$\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma$\n4.  **一致性条件**：$\\phi_{n+1} = |\\tau_{n+1}| - (\\tau_{\\mathrm{y0}} + H \\alpha_{n+1}) = 0$\n\n我们求解该方程组以获得塑性乘子 $\\Delta\\gamma$。将方程(2)代入方程(1)：\n$$\\tau_{n+1} = E(h_{n+1} - (h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})))$$\n$$\\tau_{n+1} = E(h_{n+1} - h_{\\mathrm{p},n}) - E \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$$\n将 $E(h_{n+1} - h_{\\mathrm{p},n})$ 视为 $\\tau_{\\text{trial}}$，我们得到：\n$$\\tau_{n+1} = \\tau_{\\text{trial}} - E \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$$\n两边乘以 $\\text{sgn}(\\tau_{\\text{trial}})$ 并利用 $|\\tau| = \\tau \\cdot \\text{sgn}(\\tau)$ 和 $(\\text{sgn}(\\tau_{\\text{trial}}))^2=1$：\n$$|\\tau_{n+1}| = |\\tau_{\\text{trial}}| - E \\Delta \\gamma$$\n现在，将 $|\\tau_{n+1}|$ 的这个表达式和硬化法则（方程3）代入一致性条件（方程4）：\n$$(|\\tau_{\\text{trial}}| - E \\Delta \\gamma) - (\\tau_{\\mathrm{y0}} + H (\\alpha_n + \\Delta \\gamma)) = 0$$\n重新整理以求解 $\\Delta\\gamma$：\n$$|\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n) = E \\Delta \\gamma + H \\Delta \\gamma$$\n左侧恰好是试探屈服函数值 $\\phi_{\\text{trial}}$：\n$$\\phi_{\\text{trial}} = (E + H) \\Delta \\gamma$$\n因此，塑性乘子确定为：\n$$\\Delta \\gamma = \\frac{\\phi_{\\text{trial}}}{E + H} = \\frac{|\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n)}{E + H}$$\n因为我们处于塑性情况，$\\phi_{\\text{trial}} > 0$。又因为 $E > 0$ 和 $H \\ge 0$，所以 $\\Delta \\gamma > 0$，符合要求。\n\n在 $\\Delta \\gamma$ 已知后，更新状态变量：\n- **累积塑性应变**：\n  $$\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma$$\n- **塑性对数应变**：\n  $$h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$$\n- **Kirchhoff应力**：从一致性条件可知，我们有 $|\\tau_{n+1}| = \\tau_{\\mathrm{y0}} + H \\alpha_{n+1}$。符号与试探状态保持一致。这提供了一个数值上稳健的更新方法：\n  $$\\tau_{n+1} = (\\tau_{\\mathrm{y0}} + H \\alpha_{n+1}) \\, \\text{sgn}(\\tau_{\\text{trial}})$$\n\n### **3. 最终算法总结**\n\n对于从状态 $n$ 到 $n+1$ 的每一步：\n1.  **输入**：材料参数 $\\{E, \\tau_{\\mathrm{y0}}, H\\}$，以及状态 $\\{h_{\\mathrm{p},n}, \\alpha_n, h_{n+1}\\}$。\n2.  **弹性预测**：计算试探Kirchhoff应力：\n    $$\\tau_{\\text{trial}} = E (h_{n+1} - h_{\\mathrm{p},n})$$\n3.  **屈服检查**：计算试探屈服函数值：\n    $$\\phi_{\\text{trial}} = |\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n)$$\n4.  **情况分析**：\n    a.  **如果 $\\phi_{\\text{trial}} \\le 0$ (弹性步)**：\n        - $\\tau_{n+1} = \\tau_{\\text{trial}}$\n        - $h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n}$\n        - $\\alpha_{n+1} = \\alpha_n$\n    b.  **如果 $\\phi_{\\text{trial}} > 0$ (塑性步)**：\n        - 计算塑性乘子：$\\Delta \\gamma = \\phi_{\\text{trial}} / (E + H)$\n        - 更新累积塑性应变：$\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma$\n        - 更新塑性对数应变：$h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$\n        - 更新Kirchhoff应力：$\\tau_{n+1} = (\\tau_{\\mathrm{y0}} + H \\alpha_{n+1}) \\, \\text{sgn}(\\tau_{\\text{trial}})$\n5.  **最终应力计算**：计算Cauchy（真实）应力：\n    $$\\sigma_{n+1} = \\frac{\\tau_{n+1}}{\\exp(h_{n+1})}$$\n6.  **输出**：返回更新值的集合 $\\{\\sigma_{n+1}, h_{\\mathrm{p},n+1}, \\alpha_{n+1}\\}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of uniaxial finite strain elastoplasticity problems\n    using a return-mapping algorithm in logarithmic strain space.\n    \"\"\"\n    # Test suite: (E, tau_y0, H, h_np1, h_p_n, alpha_n)\n    # E, tau_y0, H are in MPa. Strains are dimensionless.\n    test_cases = [\n        (200000.0, 300.0, 1000.0, 0.0005, 0.0, 0.0),      # Case A\n        (210000.0, 250.0, 0.0, 0.003, 0.0, 0.0),          # Case B\n        (70000.0, 100.0, 1000.0, 0.01, 0.0, 0.0),         # Case C\n        (100000.0, 200.0, 500.0, -0.005, 0.0, 0.0),       # Case D\n        (150000.0, 300.0, 200.0, 0.002, 0.0, 0.0),        # Case E\n        (210000.0, 250.0, 5000.0, 0.003, 0.01, 0.01),     # Case F\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E, tau_y0, H, h_np1, h_p_n, alpha_n = case\n\n        # 1. Elastic Predictor\n        tau_trial = E * (h_np1 - h_p_n)\n\n        # 2. Yield Check\n        # Current yield stress at the start of the step\n        tau_y_n = tau_y0 + H * alpha_n\n        phi_trial = np.abs(tau_trial) - tau_y_n\n\n        # 3. Case Analysis: Elastic or Plastic\n        if phi_trial = 0:\n            # Elastic step\n            tau_np1 = tau_trial\n            h_p_np1 = h_p_n\n            alpha_np1 = alpha_n\n        else:\n            # Plastic step: perform return mapping\n            # Calculate plastic multiplier\n            delta_gamma = phi_trial / (E + H)\n            \n            # Update state variables\n            alpha_np1 = alpha_n + delta_gamma\n            \n            # Handle the sign of trial stress for flow direction\n            # np.sign returns 0 for 0, but phi_trial > 0 implies tau_trial != 0\n            sign_tau_trial = np.sign(tau_trial)\n            h_p_np1 = h_p_n + delta_gamma * sign_tau_trial\n            \n            # Update Kirchhoff stress using the consistency condition (more robust)\n            tau_np1 = (tau_y0 + H * alpha_np1) * sign_tau_trial\n\n        # 4. Final Cauchy Stress Calculation\n        # Total stretch at the end of the step\n        lambda_np1 = np.exp(h_np1)\n        # Cauchy stress\n        sigma_np1 = tau_np1 / lambda_np1\n\n        # 5. Format results\n        # Round final values to 6 decimal places as required\n        result = [\n            round(sigma_np1, 6),\n            round(h_p_np1, 6),\n            round(alpha_np1, 6),\n        ]\n        all_results.append(result)\n\n    # Final print statement must be a single line in the exact specified format.\n    # The replace(\" \", \"\") ensures no spaces are present in the final output.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3579149"}, {"introduction": "最后，我们处理三维大应变分析中的一个关键挑战：主轴旋转效应。这个高级练习要求您构建一个非比例加载路径，并将运动学上精确的算法与简化的（也是不正确的）同轴假定进行比较 [@problem_id:3579110]。这种比较生动地说明了为什么精确追踪应变和应力张量的方向对于稳健的模拟是必不可少的。", "problem": "考虑一个三维均匀变形体，其由空间速度梯度 $\\mathbf{L}(t)$ 描述。$\\mathbf{L}(t)$ 可加法分解为对称的变形率张量 $\\mathbf{D}(t)$ 和反对称的自旋张量 $\\mathbf{W}(t)$，即 $\\mathbf{L}(t) = \\mathbf{D}(t) + \\mathbf{W}(t)$。变形梯度 $\\mathbf{F}(t)$ 根据基本运动学定律 $\\dot{\\mathbf{F}}(t) = \\mathbf{L}(t) \\mathbf{F}(t)$ 演化，初始条件为 $\\mathbf{F}(0) = \\mathbf{I}$，其中 $\\mathbf{I}$ 是单位张量。Cauchy-Green 变形张量 $\\mathbf{B}(t)$ 定义为 $\\mathbf{B}(t) = \\mathbf{F}(t) \\mathbf{F}(t)^{\\mathrm{T}}$，该张量是对称正定 (SPD) 的。左伸长张量 $\\mathbf{V}(t)$ 通过对 $\\mathbf{F}(t)$ 进行极分解得到，并满足 $\\mathbf{V}(t)^2 = \\mathbf{B}(t)$。Eulerian Hencky (对数) 应变定义为 $\\mathbf{E}^{\\ln}(t) = \\ln(\\mathbf{V}(t))$，其中 $\\ln(\\cdot)$ 表示主矩阵对数。\n\n为计算应力，假设 Kirchhoff 应力 $\\mathbf{\\tau}(t)$ 在对数应变空间中遵循各向同性 Hencky 弹性本构律，其中 Young’s 模量为 $E$、Poisson’s 比为 $\\nu$。体积模量 $K$ 和剪切模量 $G$ 分别为 $K = \\dfrac{E}{3(1 - 2 \\nu)}$ 和 $G = \\dfrac{E}{2(1 + \\nu)}$，应力由下式给出：\n$$\n\\mathbf{\\tau}(t) = K \\,\\mathrm{tr}\\big(\\mathbf{E}^{\\ln}(t)\\big)\\, \\mathbf{I} + 2 G \\left(\\mathbf{E}^{\\ln}(t) - \\frac{1}{3} \\mathrm{tr}\\big(\\mathbf{E}^{\\ln}(t)\\big) \\mathbf{I} \\right).\n$$\n\n您必须构建一个主轴旋转的加载路径，其中 $\\mathbf{D}(t)$ 和 $\\mathbf{W}(t)$ 是非对易的，然后比较两种用于应力评估的算法：\n- 算法 A（共轴假设）：假设 $\\mathbf{E}^{\\ln}(t)$ 和 $\\mathbf{\\tau}(t)$ 与一个固定的空间基底保持共轴，因此主轴不发生演化。仅通过在固定基底中对 $\\mathbf{D}(t)$ 的对角项进行积分来更新 $\\mathbf{E}^{\\ln}(t)$ 的主值，即 $\\mathbf{E}^{\\ln}(t+\\Delta t) \\approx \\mathbf{E}^{\\ln}(t) + \\mathrm{diag}(\\mathbf{D}(t)) \\Delta t$，并保持特征向量固定。\n- 算法 B（完全谱方位更新）：从 $\\dot{\\mathbf{F}} = \\mathbf{L} \\mathbf{F}$ 积分 $\\mathbf{F}(t)$，计算 $\\mathbf{B}(t)$，然后通过对 $\\mathbf{B}(t)$ 进行谱分解得到 $\\mathbf{V}(t)$，最后通过谱映射计算 $\\mathbf{E}^{\\ln}(t) = \\ln(\\mathbf{V}(t))$。使用此 $\\mathbf{E}^{\\ln}(t)$ 计算 $\\mathbf{\\tau}(t)$。\n\n通过下式定义旋转主轴加载路径：\n$$\n\\mathbf{D}(t) = \\mathbf{R}_z(\\alpha t) \\, \\mathbf{D}_0 \\, \\mathbf{R}_z(\\alpha t)^{\\mathrm{T}}, \\quad \\mathbf{W}(t) = \\begin{bmatrix} 0  -\\beta  0 \\\\ \\beta  0  0 \\\\ 0  0  0 \\end{bmatrix},\n$$\n其中 $\\mathbf{R}_z(\\theta)$ 是绕 $z$ 轴旋转角度 $\\theta$（以弧度为单位）的旋转张量，$\\mathbf{D}_0$ 是一个恒定的对角张量。参数 $\\alpha$ 和 $\\beta$ 是恒定速率（单位分别为 $\\mathrm{rad/s}$ 和 $\\mathrm{s}^{-1}$）。变形在总时间 $T$ 内进行，包含 $N$ 个大小为 $\\Delta t = T/N$ 的均匀时间步。时间演化通过对 $\\dot{\\mathbf{F}} = \\mathbf{L} \\mathbf{F}$ 进行显式积分来数值近似，更新方式为 $\\mathbf{F}_{n+1} \\approx (\\mathbf{I} + \\mathbf{L}_n \\Delta t) \\mathbf{F}_n$。\n\n对于每个测试用例，计算算法 A 得到的最终 Kirchhoff 应力 $\\mathbf{\\tau}_{\\mathrm{coax}}$ 和算法 B 得到的 $\\mathbf{\\tau}_{\\mathrm{spec}}$，并测量由下式定义的无量纲相对误差：\n$$\n\\epsilon = \\frac{\\left\\| \\mathbf{\\tau}_{\\mathrm{coax}} - \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F}{\\left\\| \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 是 Frobenius 范数。将最终输出表示为十进制数（无量纲）。\n\n所有用例均使用以下材料参数：$E = 2.10 \\times 10^{11}$，$\\nu = 0.30$。角度以弧度为单位。\n\n测试套件：\n- 用例 1（非对易，中等旋转）：$\\mathbf{D}_0 = \\mathrm{diag}(0.02, -0.02, 0.00)$，单位 $\\mathrm{s}^{-1}$，$\\alpha = 1.0$，单位 $\\mathrm{rad/s}$，$\\beta = 0.5$，单位 $\\mathrm{s}^{-1}$，$T = 0.5$，单位 $\\mathrm{s}$，$N = 2000$。\n- 用例 2（对易边界，各向同性拉伸）：$\\mathbf{D}_0 = \\mathrm{diag}(0.02, 0.02, 0.02)$，单位 $\\mathrm{s}^{-1}$，$\\alpha = 3.0$，单位 $\\mathrm{rad/s}$，$\\beta = 5.0$，单位 $\\mathrm{s}^{-1}$，$T = 0.3$，单位 $\\mathrm{s}$，$N = 1500$。\n- 用例 3（非对易，高速旋转）：$\\mathbf{D}_0 = \\mathrm{diag}(0.02, -0.02, 0.00)$，单位 $\\mathrm{s}^{-1}$，$\\alpha = 10.0$，单位 $\\mathrm{rad/s}$，$\\beta = 5.0$，单位 $\\mathrm{s}^{-1}$，$T = 0.2$，单位 $\\mathrm{s}$，$N = 4000$。\n- 用例 4（非对易，无自旋）：$\\mathbf{D}_0 = \\mathrm{diag}(0.02, -0.02, 0.00)$，单位 $\\mathrm{s}^{-1}$，$\\alpha = 1.0$，单位 $\\mathrm{rad/s}$，$\\beta = 0.0$，单位 $\\mathrm{s}^{-1}$，$T = 0.5$，单位 $\\mathrm{s}$，$N = 2000$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是相应测试用例的相对误差 $\\epsilon$，并以十进制数报告。", "solution": "该问题要求对计算有限变形体中应力的两种数值算法进行批判性比较。这是计算固体力学中的一项核心任务。第一种算法（算法 A）采用了与固定参考系共轴的简化假设，而第二种算法（算法 B）则实现了一个完整的、运动学上正确的更新。该比较在一个涉及变形主轴旋转的特定加载路径下进行，此路径旨在检验共轴假设的有效性。\n\n该分析基于有限变形连续介质力学的原理。变形状态由变形梯度张量 $\\mathbf{F}(t)$ 描述，它将物质矢量从参考构型映射到当前构型。其演化由基本运动学定律支配：\n$$\n\\dot{\\mathbf{F}}(t) = \\mathbf{L}(t) \\mathbf{F}(t)\n$$\n初始条件为 $\\mathbf{F}(0) = \\mathbf{I}$，其中 $\\mathbf{I}$ 是一个 $3 \\times 3$ 的单位张量。空间速度梯度 $\\mathbf{L}(t)$ 可加法分解为其对称部分，即变形率张量 $\\mathbf{D}(t)$，和其反对称部分，即自旋张量 $\\mathbf{W}(t)$：\n$$\n\\mathbf{L}(t) = \\mathbf{D}(t) + \\mathbf{W}(t)\n$$\n左 Cauchy-Green 变形张量 $\\mathbf{B}(t)$ 定义为 $\\mathbf{B}(t) = \\mathbf{F}(t) \\mathbf{F}(t)^{\\mathrm{T}}$。由于 $\\mathbf{F}(t)$ 是可逆的（对于任何物理变形），$\\mathbf{B}(t)$ 是一个对称正定 (SPD) 张量。极分解定理指出，$\\mathbf{F}(t)$可以唯一地分解为一个旋转和一个伸长。在空间描述中，这表示为 $\\mathbf{F}(t) = \\mathbf{V}(t) \\mathbf{R}(t)$，其中 $\\mathbf{V}(t)$ 是左伸长张量（也是 SPD），$\\mathbf{R}(t)$ 是一个纯正交旋转张量。根据 $\\mathbf{B}(t)$ 的定义，我们有 $\\mathbf{V}(t)^2 = \\mathbf{B}(t)$，这意味着 $\\mathbf{V}(t)$ 是 $\\mathbf{B}(t)$ 的唯一对称正定平方根。\n\n本构行为由各向同性 Hencky 弹性模型规定。该模型假设在对数应变空间中存在线性关系。Eulerian Hencky (对数) 应变张量 $\\mathbf{E}^{\\ln}(t)$ 定义为左伸长张量的主矩阵对数：\n$$\n\\mathbf{E}^{\\ln}(t) = \\ln(\\mathbf{V}(t))\n$$\nKirchhoff 应力 $\\mathbf{\\tau}(t)$ 随后通过各向同性线弹性定律与 $\\mathbf{E}^{\\ln}(t)$ 相关联：\n$$\n\\mathbf{\\tau}(t) = K \\,\\mathrm{tr}\\big(\\mathbf{E}^{\\ln}(t)\\big)\\, \\mathbf{I} + 2 G \\left(\\mathbf{E}^{\\ln}(t) - \\frac{1}{3} \\mathrm{tr}\\big(\\mathbf{E}^{\\ln}(t)\\big) \\mathbf{I} \\right)\n$$\n其中 $\\mathrm{tr}(\\cdot)$ 表示张量的迹。材料常数是体积模量 $K$ 和剪切模量 $G$，它们根据 Young’s 模量 $E$ 和 Poisson’s 比 $\\nu$ 定义如下：\n$$\nK = \\frac{E}{3(1 - 2 \\nu)}, \\quad G = \\frac{E}{2(1 + \\nu)}\n$$\n问题定义了一个特定的加载路径，其特征在于一个旋转的变形率张量 $\\mathbf{D}(t)$ 和一个恒定的自旋张量 $\\mathbf{W}(t)$：\n$$\n\\mathbf{D}(t) = \\mathbf{R}_z(\\alpha t) \\, \\mathbf{D}_0 \\, \\mathbf{R}_z(\\alpha t)^{\\mathrm{T}}\n$$\n$$\n\\mathbf{W}(t) = \\begin{bmatrix} 0  -\\beta  0 \\\\ \\beta  0  0 \\\\ 0  0  0 \\end{bmatrix}\n$$\n在此，$\\mathbf{D}_0$ 是一个恒定的对角张量，$\\alpha$ 是 $\\mathbf{D}(t)$ 主轴的旋转速率，$\\beta$ 控制一个附加刚体自旋的大小，$\\mathbf{R}_z(\\theta)$ 是绕 $z$ 轴旋转角度 $\\theta$ 的旋转矩阵：\n$$\n\\mathbf{R}_z(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{bmatrix}\n$$\n总变形发生在一个时间段 $T$ 内，使用 $N$ 个大小为 $\\Delta t = T/N$ 的离散时间步。$\\mathbf{F}(t)$ 的演化使用显式前向欧拉格式 $\\mathbf{F}_{n+1} = (\\mathbf{I} + \\mathbf{L}_n \\Delta t) \\mathbf{F}_n$ 进行近似，其中下标 $n$ 表示在时间 $t_n = n \\Delta t$ 时的值。\n\n两种算法的实现如下：\n\n算法 B（完全谱方位更新）：该算法作为参考解。它正确地对完整的运动学进行积分。\n1.  初始化 $\\mathbf{F}_0 = \\mathbf{I}$。\n2.  对于从 $0$ 到 $N-1$ 的每个时间步 $n$：\n    a. 计算当前时间 $t_n = n \\Delta t$。\n    b. 根据定义构建 $\\mathbf{D}(t_n)$ 和 $\\mathbf{W}(t_n)$。\n    c. 形成速度梯度 $\\mathbf{L}_n = \\mathbf{D}(t_n) + \\mathbf{W}(t_n)$。\n    d. 更新变形梯度：$\\mathbf{F}_{n+1} = (\\mathbf{I} + \\mathbf{L}_n \\Delta t) \\mathbf{F}_n$。\n3.  在最终时间 $T = N \\Delta t$ 时，令最终变形梯度为 $\\mathbf{F}_{\\text{final}} = \\mathbf{F}_N$。\n4.  计算最终左 Cauchy-Green 张量：$\\mathbf{B}_{\\text{final}} = \\mathbf{F}_{\\text{final}} \\mathbf{F}_{\\text{final}}^{\\mathrm{T}}$。\n5.  对对称张量 $\\mathbf{B}_{\\text{final}}$ 执行谱分解：$\\mathbf{B}_{\\text{final}} = \\mathbf{P} \\Lambda_B \\mathbf{P}^{\\mathrm{T}}$，其中 $\\Lambda_B$ 是特征值 $\\lambda_i^B$ 的对角矩阵，$\\mathbf{P}$ 是相应特征向量的正交矩阵。\n6.  $\\mathbf{V}_{\\text{final}}$ 的特征值为 $\\lambda_i = \\sqrt{\\lambda_i^B}$，其特征向量与 $\\mathbf{B}_{\\text{final}}$ 相同。对数应变 $\\mathbf{E}^{\\ln}_{\\mathrm{spec}}$ 的特征值为 $\\epsilon_i = \\ln(\\lambda_i) = \\frac{1}{2} \\ln(\\lambda_i^B)$。\n7.  构建最终的对数应变张量：$\\mathbf{E}^{\\ln}_{\\mathrm{spec}} = \\mathbf{P} \\, \\mathrm{diag}(\\epsilon_1, \\epsilon_2, \\epsilon_3) \\, \\mathbf{P}^{\\mathrm{T}}$。\n8.  使用本构律和 $\\mathbf{E}^{\\ln}_{\\mathrm{spec}}$ 计算最终的 Kirchhoff 应力 $\\mathbf{\\tau}_{\\mathrm{spec}}$。\n\n算法 A（共轴假设）：这是一种简化的、且通常不正确的算法。它假设在整个变形过程中，应变主轴在实验室坐标系中是固定的。\n1.  初始化对数应变张量 $\\mathbf{E}^{\\ln}_{\\mathrm{coax}, 0} = \\mathbf{0}$，这是一个 $3 \\times 3$ 的零矩阵。\n2.  对于从 $0$ 到 $N-1$ 的每个时间步 $n$：\n    a. 计算当前时间 $t_n = n \\Delta t$。\n    b. 构建 $\\mathbf{D}(t_n)$。\n    c. 通过仅对 $\\mathbf{D}(t_n)$ 的对角分量进行积分来更新对角对数应变张量：\n       $\\mathbf{E}^{\\ln}_{\\mathrm{coax}, n+1} = \\mathbf{E}^{\\ln}_{\\mathrm{coax}, n} + \\mathrm{diag}(\\mathbf{D}_{11}(t_n), \\mathbf{D}_{22}(t_n), \\mathbf{D}_{33}(t_n)) \\Delta t$。\n3.  在最终时间 $T$ 时，最终应变为 $\\mathbf{E}^{\\ln}_{\\mathrm{coax}} = \\mathbf{E}^{\\ln}_{\\mathrm{coax}, N}$。\n4.  使用本构律和 $\\mathbf{E}^{\\ln}_{\\mathrm{coax}}$ 计算最终的 Kirchhoff 应力 $\\mathbf{\\tau}_{\\mathrm{coax}}$。\n\n简化方法的误差由 Frobenius 范数下的相对差异来量化：\n$$\n\\epsilon = \\frac{\\left\\| \\mathbf{\\tau}_{\\mathrm{coax}} - \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F}{\\left\\| \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F}\n$$\n其中矩阵 $A$ 的 Frobenius 范数为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$。\n\n该分析预计，在加载是非比例的（即 $\\mathbf{D}(t)$ 的主轴旋转）情况下，算法 A 会显示出显著误差，因为它错误地忽略了主应变方向的演化。对于各向同性拉伸的特殊情况（$\\mathbf{D}_0 = d_0 \\mathbf{I}$），$\\mathbf{D}(t)$ 变为恒定且各向同性（$\\mathbf{D}(t) = d_0 \\mathbf{I}$），这会导致一种主应变轴相对于材料不发生旋转的变形。在这种特定场景（用例 2）下，两种算法应得出相同的结果，误差 $\\epsilon$ 预计为零（或接近机器精度）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem for the given test suite.\n    \"\"\"\n\n    # --- Material Parameters ---\n    E = 2.10e11  # Young's modulus\n    nu = 0.30    # Poisson's ratio\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: non-commutative, moderate rotation\n        {'D0_diag': [0.02, -0.02, 0.00], 'alpha': 1.0, 'beta': 0.5, 'T': 0.5, 'N': 2000},\n        # Case 2: commuting boundary, isotropic stretch\n        {'D0_diag': [0.02, 0.02, 0.02], 'alpha': 3.0, 'beta': 5.0, 'T': 0.3, 'N': 1500},\n        # Case 3: non-commutative, high rotation\n        {'D0_diag': [0.02, -0.02, 0.00], 'alpha': 10.0, 'beta': 5.0, 'T': 0.2, 'N': 4000},\n        # Case 4: non-commutative, no spin\n        {'D0_diag': [0.02, -0.02, 0.00], 'alpha': 1.0, 'beta': 0.0, 'T': 0.5, 'N': 2000},\n    ]\n\n    results = []\n\n    # --- Helper Functions ---\n    def get_rotation_matrix_z(theta):\n        \"\"\"Returns the rotation matrix around the z-axis by angle theta.\"\"\"\n        cos_t = np.cos(theta)\n        sin_t = np.sin(theta)\n        return np.array([\n            [cos_t, -sin_t, 0.0],\n            [sin_t,  cos_t, 0.0],\n            [0.0,    0.0,   1.0]\n        ])\n\n    def calculate_stress(E_log, K, G):\n        \"\"\"Calculates Kirchhoff stress from logarithmic strain.\"\"\"\n        I = np.eye(3)\n        tr_E_log = np.trace(E_log)\n        tau = K * tr_E_log * I + 2 * G * (E_log - (1/3) * tr_E_log * I)\n        return tau\n\n    # --- Main Loop ---\n    for case in test_cases:\n        # Unpack parameters\n        D0 = np.diag(case['D0_diag'])\n        alpha = case['alpha']\n        beta = case['beta']\n        T = case['T']\n        N = case['N']\n        \n        # Derived parameters\n        dt = T / N\n        K = E / (3 * (1 - 2 * nu))\n        G = E / (2 * (1 + nu))\n\n        # Initial conditions\n        F = np.eye(3) # For Algorithm B\n        E_log_coax = np.zeros((3, 3)) # For Algorithm A\n        W = np.array([\n            [0.0, -beta, 0.0],\n            [beta,  0.0, 0.0],\n            [0.0,  0.0, 0.0]\n        ])\n\n        # --- Time-stepping integration ---\n        for n in range(N):\n            t = n * dt\n            \n            # Common calculations\n            R_z = get_rotation_matrix_z(alpha * t)\n            D = R_z @ D0 @ R_z.T\n            \n            # --- Algorithm A update (Coaxial Assumption) ---\n            E_log_coax += np.diag(np.diag(D)) * dt\n            \n            # --- Algorithm B update (Full Spectral) ---\n            L = D + W\n            # Forward Euler update for F\n            F = (np.eye(3) + L * dt) @ F\n\n        # --- Post-processing after loop ---\n        \n        # Calculate final stress for Algorithm A\n        tau_coax = calculate_stress(E_log_coax, K, G)\n\n        # Calculate final stress for Algorithm B\n        B = F @ F.T\n        # Spectral decomposition of B\n        # eigh is for symmetric/hermitian matrices\n        eigvals_B, eigvecs_B = np.linalg.eigh(B)\n        \n        # Ensure eigenvalues are positive before sqrt\n        eigvals_B[eigvals_B  0] = 0\n        \n        eigvals_V = np.sqrt(eigvals_B)\n        \n        # To avoid log(0), handle zero eigenvalues carefully.\n        # Since stretches must be positive, log(stretch) should be well-defined.\n        # A zero eigenvalue in B would imply a singular deformation gradient F,\n        # which means the volume has collapsed to zero.\n        # We add a small epsilon to avoid numerical issues.\n        eigvals_E_log = np.log(eigvals_V + np.finfo(float).eps)\n\n        E_log_spec = eigvecs_B @ np.diag(eigvals_E_log) @ eigvecs_B.T\n        tau_spec = calculate_stress(E_log_spec, K, G)\n\n        # --- Error Calculation ---\n        norm_tau_spec = np.linalg.norm(tau_spec, 'fro')\n        norm_diff = np.linalg.norm(tau_coax - tau_spec, 'fro')\n        \n        if norm_tau_spec > np.finfo(float).eps:\n            error = norm_diff / norm_tau_spec\n        else:\n            # If the true stress is zero, the absolute error is more meaningful.\n            # For this problem, we can assume spec stress is non-zero\n            # except perhaps in trivial cases. Case 2 results in non-zero stress.\n            error = norm_diff\n\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3579110"}]}