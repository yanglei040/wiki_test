{"hands_on_practices": [{"introduction": "为了建立对静态凝聚的直观理解，我们从一个基础示例开始。这项练习将引导您完成一个简单一维杆件静态凝聚的全过程，该杆件被划分为两个子结构[@problem_id:2562927]。通过手动执行矩阵运算，您将对如何消除内部自由度以及如何将其影响一致地传递到边界上获得具体认识。", "problem": "一根与全局$x$轴对齐的直棱柱一维杆被分解为两个子结构 $\\mathcal{A}$ 和 $\\mathcal{B}$，它们通过一个单一的界面节点 $I$（节点 $2$）连接。子结构 $\\mathcal{A}$ 由两个线性的两节点轴向单元组成，连接节点 $0$–$1$ 和 $1$–$2$，其均匀轴向刚度为 $E A = 2.0 \\times 10^{5}\\,\\mathrm{N}$，单元长度分别为 $L_{01} = 1\\,\\mathrm{m}$ 和 $L_{12} = 1\\,\\mathrm{m}$。节点 $0$ 被固定，其位移 $u_{0} = 0$。一个均匀的轴向体力密度 $b_{12} = 1000\\,\\mathrm{N/m}$ 沿单元 $(1$–$2)$ 在正 $x$ 方向上作用；单元 $(0$–$1)$ 不受载荷。子结构 $\\mathcal{B}$ 由两个线性的两节点轴向单元组成，连接节点 $2$–$3$ 和 $3$–$4$，其轴向刚度为 $E A = 1.0 \\times 10^{4}\\,\\mathrm{N}$，长度分别为 $L_{23} = 2\\,\\mathrm{m}$ 和 $L_{34} = 1\\,\\mathrm{m}$。一个均匀的轴向体力密度 $b_{23} = 500\\,\\mathrm{N/m}$ 沿单元 $(2$–$3)$ 在正 $x$ 方向上作用。在节点 $4$ 处，有一个沿正 $x$ 方向施加的外部节点牵引力 $T_{4} = 2000\\,\\mathrm{N}$。没有其他载荷作用。\n\n从虚功原理和两节点轴向单元的线性形函数的定义出发，推导分布体力的等效单元载荷向量，组装子结构的平衡方程，并执行静态凝聚（子结构法）以消除每个子结构内部的所有内部自由度，从而只剩下界面位移 $u_{2}$。然后，组装简化的全局界面方程并求解界面位移 $u_{2}$。\n\n将 $u_{2}$ 的最终值以毫米表示，并四舍五入到四位有效数字。", "solution": "该问题具有科学依据，提法恰当且自成体系。所有必要的数据、边界条件和材料属性均已提供。要求使用虚功原理、等效载荷和静态凝聚是有限元方法中的一个标准且有效的程序。因此，该问题是有效的，并将提供解答。\n\n分析从线性两节点轴向单元的基本原理开始。长度为 $L_e$ 的单元内的轴向位移场 $u(x)$ 是通过使用线性形函数 $N_1(x)$ 和 $N_2(x)$ 从节点位移 $u_1$ 和 $u_2$ 插值得到的：\n$$u(x) = N_1(x) u_1 + N_2(x) u_2 = \\mathbf{N}(x) \\mathbf{d}^{(e)}$$\n在单元从 $x=0$ 延伸到 $x=L_e$ 的局部坐标系中，形函数为：\n$$N_1(x) = 1 - \\frac{x}{L_e} \\quad , \\quad N_2(x) = \\frac{x}{L_e}$$\n单元刚度矩阵 $\\mathbf{k}^{(e)}$ 由应变能推导得出，其表达式为：\n$$\\mathbf{k}^{(e)} = \\frac{EA}{L_e} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}$$\n\n对于分布体力 $b(x)$（单位长度上的力），其等效单元载荷向量 $\\mathbf{f}^{(e)}$ 是从虚功原理推导出来的。体力所做的虚功为：\n$$\\delta W_{\\text{ext}} = \\int_{0}^{L_e} \\delta u(x) b(x) dx$$\n代入插值得到的虚位移 $\\delta u(x) = \\mathbf{N}(x) \\delta\\mathbf{d}^{(e)}$：\n$$\\delta W_{\\text{ext}} = \\int_{0}^{L_e} (\\mathbf{N}(x) \\delta\\mathbf{d}^{(e)})^T b(x) dx = (\\delta\\mathbf{d}^{(e)})^T \\int_{0}^{L_e} \\mathbf{N}(x)^T b(x) dx$$\n由于 $\\delta W_{\\text{ext}} = (\\delta\\mathbf{d}^{(e)})^T \\mathbf{f}^{(e)}$，等效载荷向量为：\n$$\\mathbf{f}^{(e)} = \\int_{0}^{L_e} \\mathbf{N}(x)^T b(x) dx$$\n对于均匀体力 $b$，该积分变为：\n$$\\mathbf{f}^{(e)} = b \\int_{0}^{L_e} \\begin{pmatrix} 1 - x/L_e \\\\ x/L_e \\end{pmatrix} dx = b \\left[ \\begin{matrix} x - \\frac{x^2}{2L_e} \\\\ \\frac{x^2}{2L_e} \\end{matrix} \\right]_0^{L_e} = b \\begin{pmatrix} L_e - \\frac{L_e^2}{2L_e} \\\\ \\frac{L_e^2}{2L_e} \\end{pmatrix} = \\frac{bL_e}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$\n这意味着总载荷 $bL_e$ 被平均分配到两个节点上。\n\n现在，我们分析每个子结构。\n\n**子结构 $\\mathcal{A}$ (节点 $0, 1, 2$)**\n该子结构由单元 $(0-1)$ 和 $(1-2)$ 组成。\n单元 $(0-1)$: $L_{01} = 1\\,\\mathrm{m}$, $EA = 2.0 \\times 10^5\\,\\mathrm{N}$。无体力。\n$$\\mathbf{k}^{(0-1)} = \\frac{2.0 \\times 10^5}{1} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}_{u_0, u_1} \\quad ; \\quad \\mathbf{f}^{(0-1)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$\n单元 $(1-2)$: $L_{12} = 1\\,\\mathrm{m}$, $EA = 2.0 \\times 10^5\\,\\mathrm{N}$, $b_{12} = 1000\\,\\mathrm{N/m}$。\n$$\\mathbf{k}^{(1-2)} = \\frac{2.0 \\times 10^5}{1} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}_{u_1, u_2} \\quad ; \\quad \\mathbf{f}^{(1-2)} = \\frac{1000 \\times 1}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}_{u_1, u_2} = \\begin{pmatrix} 500 \\\\ 500 \\end{pmatrix}$$\n节点 $(0, 1, 2)$ 的组装系统为 $\\mathbf{K}^\\mathcal{A} \\mathbf{u}^\\mathcal{A} = \\mathbf{F}^\\mathcal{A}$：\n$$\n\\begin{pmatrix} k^{(0-1)}_{11}  & k^{(0-1)}_{12}  & 0 \\\\ k^{(0-1)}_{21}  & k^{(0-1)}_{22}+k^{(1-2)}_{11}  & k^{(1-2)}_{12} \\\\ 0  & k^{(1-2)}_{21}  & k^{(1-2)}_{22} \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} f^{(0-1)}_1 \\\\ f^{(0-1)}_2 + f^{(1-2)}_1 \\\\ f^{(1-2)}_2 \\end{pmatrix}\n$$\n$$2.0 \\times 10^5 \\begin{pmatrix} 1  & -1  & 0 \\\\ -1  & 2  & -1 \\\\ 0  & -1  & 1 \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 500 \\\\ 500 \\end{pmatrix}$$\n应用边界条件 $u_0=0$，自由度 $(u_1, u_2)$ 的系统变为：\n$$2.0 \\times 10^5 \\begin{pmatrix} 2  & -1 \\\\ -1  & 1 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} 500 \\\\ 500 \\end{pmatrix}$$\n为了执行静态凝聚，我们将系统划分为内部自由度 ($i = \\{1\\}$) 和界面自由度 ($b = \\{2\\}$)：\n$$\n\\begin{pmatrix} \\mathbf{K}_{ii}  & \\mathbf{K}_{ib} \\\\ \\mathbf{K}_{bi}  & \\mathbf{K}_{bb} \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_i \\\\ \\mathbf{u}_b \\end{pmatrix} = \\begin{pmatrix} \\mathbf{F}_i \\\\ \\mathbf{F}_b \\end{pmatrix}\n$$\n其中 $\\mathbf{K}_{ii} = 4.0 \\times 10^5$, $\\mathbf{K}_{ib} = -2.0 \\times 10^5$, $\\mathbf{K}_{bi} = -2.0 \\times 10^5$, $\\mathbf{K}_{bb} = 2.0 \\times 10^5$, $\\mathbf{F}_i = 500$, 以及 $\\mathbf{F}_b = 500$。\n凝聚后的系统为 $\\mathbf{K}^*_\\mathcal{A} \\mathbf{u}_b = \\mathbf{F}^*_\\mathcal{A}$，其中：\n$\\mathbf{K}^*_\\mathcal{A} = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} = 2.0 \\times 10^5 - (-2.0 \\times 10^5)(4.0 \\times 10^5)^{-1}(-2.0 \\times 10^5) = 2.0 \\times 10^5 - \\frac{(2.0 \\times 10^5)^2}{4.0 \\times 10^5} = 2.0 \\times 10^5 - 1.0 \\times 10^5 = 1.0 \\times 10^5\\,\\mathrm{N/m}$。\n$\\mathbf{F}^*_\\mathcal{A} = \\mathbf{F}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{F}_i = 500 - (-2.0 \\times 10^5)(4.0 \\times 10^5)^{-1}(500) = 500 - (-\\frac{1}{2})(500) = 500 + 250 = 750\\,\\mathrm{N}$。\n子结构 $\\mathcal{A}$ 在界面节点 $2$ 处的凝聚方程为 $1.0 \\times 10^5 u_2 = 750$。\n\n**子结构 $\\mathcal{B}$ (节点 $2, 3, 4$)**\n该子结构由单元 $(2-3)$ 和 $(3-4)$ 组成。\n单元 $(2-3)$: $L_{23} = 2\\,\\mathrm{m}$, $EA = 1.0 \\times 10^4\\,\\mathrm{N}$, $b_{23} = 500\\,\\mathrm{N/m}$。\n$$\\mathbf{k}^{(2-3)} = \\frac{1.0 \\times 10^4}{2} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}_{u_2, u_3} = 5000 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} \\quad ; \\quad \\mathbf{f}^{(2-3)} = \\frac{500 \\times 2}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}_{u_2, u_3} = \\begin{pmatrix} 500 \\\\ 500 \\end{pmatrix}$$\n单元 $(3-4)$: $L_{34} = 1\\,\\mathrm{m}$, $EA = 1.0 \\times 10^4\\,\\mathrm{N}$。无体力。\n$$\\mathbf{k}^{(3-4)} = \\frac{1.0 \\times 10^4}{1} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}_{u_3, u_4} \\quad ; \\quad \\mathbf{f}^{(3-4)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$\n节点 $4$ 处的节点力：$T_4 = 2000\\,\\mathrm{N}$。\n节点 $(2, 3, 4)$ 的组装系统为 $\\mathbf{K}^\\mathcal{B} \\mathbf{u}^\\mathcal{B} = \\mathbf{F}^\\mathcal{B}$：\n$$\n\\begin{pmatrix} 5000  & -5000  & 0 \\\\ -5000  & 5000+10000  & -10000 \\\\ 0  & -10000  & 10000 \\end{pmatrix} \\begin{pmatrix} u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix} = \\begin{pmatrix} 500 \\\\ 500 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ 0 \\\\ 2000 \\end{pmatrix}\n$$\n$$1000 \\begin{pmatrix} 5  & -5  & 0 \\\\ -5  & 15  & -10 \\\\ 0  & -10  & 10 \\end{pmatrix} \\begin{pmatrix} u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix} = \\begin{pmatrix} 500 \\\\ 500 \\\\ 2000 \\end{pmatrix}$$\n我们凝聚掉内部自由度 $i=\\{3, 4\\}$，以找到界面自由度 $b=\\{2\\}$ 的关系。\n$\\mathbf{K}_{bb}=5000$, $\\mathbf{K}_{bi}=\\begin{pmatrix} -5000  & 0 \\end{pmatrix}$, $\\mathbf{K}_{ib}=\\begin{pmatrix} -5000 \\\\ 0 \\end{pmatrix}$, $\\mathbf{K}_{ii}=1000\\begin{pmatrix} 15  & -10 \\\\ -10  & 10 \\end{pmatrix}$。\n$\\mathbf{F}_b = 500$, $\\mathbf{F}_i = \\begin{pmatrix} 500 \\\\ 2000 \\end{pmatrix}$。\n首先，我们求 $\\mathbf{K}_{ii}^{-1}$：$\\det(\\mathbf{K}_{ii}) = (1000)^2 (150-100) = 50 \\times 10^6$。\n$$\\mathbf{K}_{ii}^{-1} = \\frac{1}{50 \\times 10^6} \\begin{pmatrix} 10000  & 10000 \\\\ 10000  & 15000 \\end{pmatrix} = \\frac{1}{5000} \\begin{pmatrix} 1  & 1 \\\\ 1  & 1.5 \\end{pmatrix}$$\n凝聚后的刚度为 $\\mathbf{K}^*_\\mathcal{B} = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib}$。\n$\\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} = \\begin{pmatrix} -5000  & 0 \\end{pmatrix} \\frac{1}{5000} \\begin{pmatrix} 1  & 1 \\\\ 1  & 1.5 \\end{pmatrix} = \\begin{pmatrix} -1  & -1 \\end{pmatrix}$。\n$\\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} = \\begin{pmatrix} -1  & -1 \\end{pmatrix} \\begin{pmatrix} -5000 \\\\ 0 \\end{pmatrix} = 5000$。\n$\\mathbf{K}^*_\\mathcal{B} = 5000 - 5000 = 0$。这是预料之中的，因为子结构 $\\mathcal{B}$ 是无约束的，允许刚体运动。\n凝聚后的力为 $\\mathbf{F}^*_\\mathcal{B} = \\mathbf{F}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{F}_i$。\n$\\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{F}_i = \\begin{pmatrix} -1  & -1 \\end{pmatrix} \\begin{pmatrix} 500 \\\\ 2000 \\end{pmatrix} = -500 - 2000 = -2500$。\n$\\mathbf{F}^*_\\mathcal{B} = 500 - (-2500) = 3000\\,\\mathrm{N}$。\n凝聚后的力代表施加在子结构上的总力，并转移到界面上。作用于 $\\mathcal{B}$ 上的外力为 $b_{23}L_{23} + T_4 = (500)(2) + 2000 = 3000\\,\\mathrm{N}$。\n\n**组装与求解**\n最后一步是在界面节点 $2$ 处组装来自两个子结构的简化方程。子结构法的组装规则是 $(\\mathbf{K}^*_\\mathcal{A} + \\mathbf{K}^*_\\mathcal{B}) \\mathbf{u}_2 = \\mathbf{F}^*_\\mathcal{A} + \\mathbf{F}^*_\\mathcal{B}$。\n$$(1.0 \\times 10^5 + 0) u_2 = 750 + 3000$$\n$$1.0 \\times 10^5 u_2 = 3750$$\n求解界面位移 $u_2$：\n$$u_2 = \\frac{3750}{1.0 \\times 10^5} = 0.0375\\,\\mathrm{m}$$\n问题要求答案以毫米为单位，并四舍五入到四位有效数字。\n$$u_2 = 0.0375\\,\\mathrm{m} \\times \\frac{1000\\,\\mathrm{mm}}{1\\,\\mathrm{m}} = 37.5\\,\\mathrm{mm}$$\n四舍五入到四位有效数字得到 $37.50\\,\\mathrm{mm}$。", "answer": "$$\\boxed{37.50}$$", "id": "2562927"}, {"introduction": "静态凝聚不仅适用于消除无约束的内部节点，它同样能巧妙地处理内部的运动学约束。这项练习[@problem_id:3602467]要求您推导出一个子结构的有效刚度，其中一个内部节点的运动通过多点约束（MPC）与边界节点相联系。本练习强调了凝聚过程在能量上的一致性，并能提升您的解析推导能力。", "problem": "考虑一个用于系统级子结构分析的一维线性弹性子结构。该子结构由标记为 $1$、$2$ 和 $3$ 的 $3$ 个节点组成，这些节点由 $2$ 个轴向杆单元连接：单元 $(1,2)$ 的轴向刚度为 $k_1$，单元 $(2,3)$ 的轴向刚度为 $k_2$。设节点位移为 $u_1$、$u_2$ 和 $u_3$，节点力为 $f_1$、$f_2$ 和 $f_3$。该线性系统的全局平衡由虚功原理 (PVW) 控制，对于线性弹簧，该原理可简化为线性系统 $K u = f$。其中，$K$ 是由单元刚度组装而成的全局刚度矩阵，总势能为 $\\Pi(u) = \\tfrac{1}{2} u^{\\mathsf T} K u - f^{\\mathsf T} u$。\n\n该子结构受到一个线性多点约束 (MPC) 的作用，该约束将内部节点位移 $u_2$ 与边界节点位移的凸组合联系起来：\n$$u_2 = \\eta\\, u_1 + (1-\\eta)\\, u_3,$$\n其中参数 $0 < \\eta < 1$ 为给定值。物理上，这种 MPC 可能源于一个内部刚性约束，该约束在保留的边界自由度之间选择了仿射插值。\n\n您需要将节点 $1$ 和 $3$ 视为保留的边界自由度，将节点 $2$ 视为待消除的内部自由度。该子结构将作为一个更大模型中的组件使用，其中节点 $3$ 被固定，即 $u_3 = 0$，标量荷载 $f_1$ 施加在节点 $1$ 上，而 $f_3$ 代表反作用力。将受约束和凝聚后的子结构的有效边界刚度 $k_{\\text{eff}}$ 定义为\n$$k_{\\text{eff}} := \\frac{f_1}{u_1}\\quad\\text{在边界条件 }u_3=0 \\text{ 下，}$$\n其中 MPC 被精确施加，内部自由度以能量一致的方式被消除。\n\n仅从上述基本定义（轴向弹簧的线性弹性、基于 PVW 的平衡、线性运动学约束）出发，推导 $k_{\\text{eff}}$ 作为 $k_1$、$k_2$ 和 $\\eta$ 的函数的闭式解析表达式。以 $\\mathrm{N}/\\mathrm{m}$ 为单位表示最终的有效刚度。请以 $k_1$、$k_2$ 和 $\\eta$ 的单个解析表达式的形式提供最终答案。无需代入数值，也无需进行四舍五入。", "solution": "该问题陈述已经过严格验证，被认为是科学合理的、提法恰当的、客观的且自洽的。它提出了一个计算固体力学中关于受约束子结构静态凝聚的标准问题。所有提供的数据和定义都是一致且充分的，足以推导出一个唯一的、有意义的解。\n\n目标是求解一个受线性多点约束 (MPC) 的一维三节点子结构的有效刚度 $k_{\\text{eff}}$。有效刚度定义为在施加边界条件 $u_3=0$ 时的 $k_{\\text{eff}} := f_1/u_1$。推导将从问题陈述中指定的势能原理出发。\n\n无约束系统的总势能由 $\\Pi(u) = \\frac{1}{2} u^{\\mathsf T} K u - f^{\\mathsf T} u$ 给出。内应变能储存在两个轴向杆单元中，由 $\\Pi_{\\text{int}}(u) = \\frac{1}{2} u^{\\mathsf T} K u$ 给出。对于这两个单元，具体表达式为：\n$$\n\\Pi_{\\text{int}}(u) = \\frac{1}{2} k_1 (u_2 - u_1)^2 + \\frac{1}{2} k_2 (u_3 - u_2)^2\n$$\n其中，$k_1$ 和 $k_2$ 分别是单元 $(1,2)$ 和 $(2,3)$ 的轴向刚度，$u_1, u_2, u_3$ 是节点位移。\n\n该系统受到一个线性运动学 MPC 的约束：\n$$\nu_2 = \\eta u_1 + (1-\\eta) u_3\n$$\n其中节点 $1$ 和 $3$ 是保留的边界自由度 (DOF)，节点 $2$ 是待消除的内部自由度。参数 $\\eta$ 是给定的，且 $0 < \\eta < 1$。\n\n为了找到子结构的凝聚（或有效）属性，我们必须仅用保留的边界位移 $u_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$ 来表示势能。这是一种对内部自由度 $u_2$ 的能量一致性消除。我们将 MPC 代入应变能表达式中。\n\n首先，让我们用边界自由度 $u_1$ 和 $u_3$ 来表示单元伸长量：\n第一个单元的伸长量为 $(u_2 - u_1)$：\n$$\nu_2 - u_1 = (\\eta u_1 + (1-\\eta) u_3) - u_1 = (\\eta - 1) u_1 + (1-\\eta) u_3 = (1-\\eta)(u_3 - u_1)\n$$\n第二个单元的伸长量为 $(u_3 - u_2)$：\n$$\nu_3 - u_2 = u_3 - (\\eta u_1 + (1-\\eta) u_3) = -\\eta u_1 + (1 - (1-\\eta)) u_3 = -\\eta u_1 + \\eta u_3 = \\eta(u_3 - u_1)\n$$\n请注意，MPC 使得两个单元的伸长量都与子结构的总伸长量 $(u_3 - u_1)$ 成正比。\n\n现在，将这些表达式代回应变能方程：\n$$\n\\Pi_{\\text{int}}(u_1, u_3) = \\frac{1}{2} k_1 \\left[ (1-\\eta)(u_3 - u_1) \\right]^2 + \\frac{1}{2} k_2 \\left[ \\eta(u_3 - u_1) \\right]^2\n$$\n提出公因式 $(u_3 - u_1)^2$：\n$$\n\\Pi_{\\text{int}}(u_1, u_3) = \\frac{1}{2} \\left[ k_1 (1-\\eta)^2 + k_2 \\eta^2 \\right] (u_3 - u_1)^2\n$$\n该表达式是凝聚后子结构的应变能，完全用边界自由度 $u_1$ 和 $u_3$ 表示。该能量的形式为 $\\frac{1}{2} u_b^{\\mathsf{T}} K_c u_b$，其中 $K_c$ 是 $2 \\times 2$ 的凝聚刚度矩阵。让我们展开平方项以确定 $K_c$ 的分量：\n$$\n(u_3 - u_1)^2 = u_1^2 - 2u_1 u_3 + u_3^2 = \\begin{pmatrix} u_1 & u_3 \\end{pmatrix} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}\n$$\n令常数项为 $C = k_1 (1-\\eta)^2 + k_2 \\eta^2$。则应变能为：\n$$\n\\Pi_{\\text{int}}(u_1, u_3) = \\frac{1}{2} C (u_1^2 - 2u_1 u_3 + u_3^2) = \\frac{1}{2} \\begin{pmatrix} u_1 & u_3 \\end{pmatrix} \\begin{pmatrix} C & -C \\\\ -C & C \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}\n$$\n由此，我们确定凝聚刚度矩阵 $K_c$ 为：\n$$\nK_c = \\begin{pmatrix} k_1(1-\\eta)^2 + k_2\\eta^2 & -[k_1(1-\\eta)^2 + k_2\\eta^2] \\\\ -[k_1(1-\\eta)^2 + k_2\\eta^2] & k_1(1-\\eta)^2 + k_2\\eta^2 \\end{pmatrix}\n$$\n凝聚系统的平衡方程为 $K_c u_b = f_b$，其中 $f_b = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}$ 是作用在边界节点上的外力（假设内部节点上没有外力，即 $f_2=0$）。\n$$\n\\begin{pmatrix} K_{c,11}  & K_{c,12} \\\\ K_{c,21}  & K_{c,22} \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix} = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}\n$$\n我们需要在条件 $u_3=0$ 下求得 $k_{\\text{eff}} = f_1/u_1$。我们使用矩阵方程的第一行：\n$$\nK_{c,11} u_1 + K_{c,12} u_3 = f_1\n$$\n应用边界条件 $u_3=0$：\n$$\nK_{c,11} u_1 + K_{c,12} (0) = f_1 \\implies K_{c,11} u_1 = f_1\n$$\n因此，有效刚度由凝聚刚度矩阵的 $(1,1)$ 分量给出：\n$$\nk_{\\text{eff}} = \\frac{f_1}{u_1} = K_{c,11}\n$$\n代入我们求得的 $K_{c,11}$ 的表达式：\n$$\nk_{\\text{eff}} = k_1(1-\\eta)^2 + k_2\\eta^2\n$$\n这就是受约束子结构的有效刚度作为给定参数的函数的最终闭式解析表达式。问题中提到的单位 $\\mathrm{N}/\\mathrm{m}$ 是为了指明刚度的物理量纲，这与解析结果是一致的。", "answer": "$$\\boxed{k_1(1-\\eta)^2 + k_2\\eta^2}$$", "id": "3602467"}, {"introduction": "静态凝聚的真正威力体现在计算工作流中，尤其是在模型降阶方面。在最后的这项练习中[@problem_id:3602488]，您将编写一个程序，通过参数化子结构的属性并预先计算其凝聚刚度，来创建一个“超单元”库。然后，您将使用这个库来分析一个更大的结构，并评估使用插值降阶模型所带来的精度权衡，这是大型工程仿真中的一种常用技术。", "problem": "给定一个参数化的一维线性弹性子结构，它将作为一个超单元用于一个更大的装配体中。该子结构是一根长度为 $L$（单位：$\\mathrm{m}$）、杨氏模量 $E$（单位：$\\mathrm{Pa}$）和横截面积 $A$（单位：$\\mathrm{m}^2$）均恒定的直轴向杆。该子结构被离散为 $m$ 个等长的双节点有限元，根据虚功原理和小应变线性弹性理论，得到一个组装后的线性系统：一个对称正定的全局刚度矩阵 $K$（单位：$\\mathrm{N}/\\mathrm{m}$）通过 $K u = f$ 将节点位移向量 $u$（单位：$\\mathrm{m}$）与力向量 $f$（单位：$\\mathrm{N}$）联系起来。长度为 $\\ell_e$ 的轴向杆的单元刚度由基本本构律 $\\sigma = E \\varepsilon$ 和轴向平衡方程导出，其单元刚度矩阵与 $E A / \\ell_e$ 成正比。\n\n在子结构法中，通过消去内部自由度来定义一个凝聚刚度（或“超单元”刚度）$S(\\theta)$，它将子结构两端的边界位移对映射到相应的边界力，其中 $\\theta = (E, A, L)$。凝聚矩阵 $S(\\theta)$ 是一个对称的 $2 \\times 2$ 矩阵，它通过组装和凝聚后的有限元模型依赖于这些参数。\n\n你的任务是纯粹以计算方式实现以下步骤：\n\n1. 库的构建：\n   - 每个子结构固定为 $m = 4$ 个单元。\n   - 定义参数网格：\n     - $E \\in \\{70 \\times 10^{9}, 140 \\times 10^{9}, 210 \\times 10^{9}\\}$（单位：$\\mathrm{Pa}$）。\n     - $A \\in \\{5 \\times 10^{-4}, 10^{-3}, 2 \\times 10^{-3}\\}$（单位：$\\mathrm{m}^2$）。\n     - $L \\in \\{0.5, 1.0, 2.0\\}$（单位：$\\mathrm{m}$）。\n   - 对于张量积网格上的每个三元组 $\\theta = (E, A, L)$，使用 $m$ 个等长单元组装 $m+1$ 个节点的轴向有限元模型，并静态凝聚内部节点以获得两个边界节点的边界凝聚刚度 $S(\\theta)$。将这个超单元库制成表格。\n\n2. 插值：\n   - 对于网格凸包内的一个通用参数点 $\\theta$（无外插），通过在 $(E, A, L)$ 空间中对库进行多线性插值来构造一个三线性插值 $\\tilde{S}(\\theta)$。插值被逐个元素地应用于 $2 \\times 2$ 的凝聚刚度矩阵。\n\n3. 全局组装和柔度：\n   - 考虑一个由两个此类超单元串联组装而成的一维全局结构。将左超单元表示为 $\\theta_1$，右超单元表示为 $\\theta_2$。设全局左边界节点位移为零，固定不动，并在全局右边界节点施加一个右端点载荷 $P = 10^{5}$（单位：$\\mathrm{N}$）。每个节点有一个标量自由度。在共享界面节点处，使用标准有限元组装方法，从两个凝聚的 $2 \\times 2$ 超单元矩阵组装出 $3 \\times 3$ 的全局刚度矩阵。通过求解施加左侧狄利克雷边界条件后得到的简化系统，计算全局位移向量。设全局柔度为 $c = f^{\\mathsf{T}} u$（单位：$\\mathrm{J}$）。\n   - 将参数对 $(\\theta_1, \\theta_2)$ 的相对柔度误差定义为无量纲量\n     $$\n     \\varepsilon = \\frac{\\lvert c(S(\\theta_1), S(\\theta_2)) - c(\\tilde{S}(\\theta_1), \\tilde{S}(\\theta_2)) \\rvert}{\\lvert c(S(\\theta_1), S(\\theta_2)) \\rvert}.\n     $$\n\n4. 测试套件：\n   - 使用以下四个测试用例，每个用例指定 $(\\theta_1, \\theta_2)$，其中 $\\theta_i = (E_i, A_i, L_i)$：\n     - 测试 1（在网格点上，预期插值误差为零）：$\\theta_1 = (140 \\times 10^{9}, 10^{-3}, 1.0)$，$\\theta_2 = (140 \\times 10^{9}, 10^{-3}, 1.0)$。\n     - 测试 2（一个内部点，一个网格点）：$\\theta_1 = (100 \\times 10^{9}, 0.8 \\times 10^{-3}, 1.2)$，$\\theta_2 = (140 \\times 10^{9}, 10^{-3}, 1.0)$。\n     - 测试 3（在 $L$ 维度上混合内部点和边界点）：$\\theta_1 = (175 \\times 10^{9}, 1.5 \\times 10^{-3}, 0.5)$，$\\theta_2 = (100 \\times 10^{9}, 0.8 \\times 10^{-3}, 1.2)$。\n     - 测试 4（面边界情况和网格角点）：$\\theta_1 = (140 \\times 10^{9}, 0.75 \\times 10^{-3}, 2.0)$，$\\theta_2 = (210 \\times 10^{9}, 2 \\times 10^{-3}, 2.0)$。\n   - 所有量均采用上述指定单位。最终报告的误差是无量纲的。\n\n5. 程序输出格式：\n   - 您的程序必须构建库，按需进行插值，组装全局系统，并按所列顺序计算四个测试中每个测试的相对柔度误差 $\\varepsilon$。\n   - 您的程序应产生单行输出，其中包含四个结果，形式为用方括号括起来的逗号分隔列表（例如，$[e_1,e_2,e_3,e_4]$），其中每个 $e_i$ 是一个浮点数。\n\n约束和说明：\n- 您的推导应基于轴向杆的平衡、线性弹性、有限元组装以及将静态凝聚定义为通过消去内部自由度以获得边界关系。不要在问题陈述本身中使用任何未经证明的简化公式。\n- 数值稳定性：对于给定的数据，组装后的内部刚度块是对称正定的，因此标准线性代数足以进行静态凝聚。\n- 不涉及角度；不需要角度单位。\n- 由于要求的输出是无量纲的相对误差，因此最终的数值输出中不需要显式物理单位。", "solution": "用户提供的问题经过严格验证，具有科学依据、适定性、客观性和完整性。在计算线性弹性的框架内，所有提供的数据和约束都是一致且物理上现实的。任务是计算由超单元刚度矩阵的三线性插值引起的结构柔度的相对误差。将遵循规定的计算步骤来实施解决方案。\n\n### 静态凝聚原理\n\n有限元模型的静态分析由线性系统 $K u = f$ 控制，其中 $K$ 是全局刚度矩阵，$u$ 是节点位移向量，$f$ 是节点力向量。在子结构法中，我们将自由度（DOF）$u$ 划分为内部（或“待消去”）自由度 $u_i$ 和边界（或“保留”）自由度 $u_b$。方程组也作相应划分：\n\n$$\n\\begin{pmatrix} K_{bb}  & K_{bi} \\\\ K_{ib}  & K_{ii} \\end{pmatrix}\n\\begin{pmatrix} u_b \\\\ u_i \\end{pmatrix} =\n\\begin{pmatrix} f_b \\\\ f_i \\end{pmatrix}\n$$\n\n静态凝聚是消去内部自由度 $u_i$ 的过程，以找到边界力 $f_b$ 和边界位移 $u_b$ 之间的直接关系。这通常在假设没有外力施加于内部自由度（即 $f_i = 0$）的情况下进行。\n\n从分块系统的第二行，我们求解 $u_i$：\n$K_{ib} u_b + K_{ii} u_i = 0 \\implies u_i = -K_{ii}^{-1} K_{ib} u_b$。\n矩阵 $K_{ii}$ 是可逆的，因为它代表了边界自由度被固定时的结构刚度矩阵，这是一种稳定的构型。\n\n将 $u_i$ 的这个表达式代入系统的第一行，得到：\n$K_{bb} u_b + K_{bi} (-K_{ii}^{-1} K_{ib} u_b) = f_b$\n$$\n(K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}) u_b = f_b\n$$\n这就定义了凝聚刚度矩阵，或称超单元刚度矩阵 $S$ 为：\n$$\nS = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}\n$$\n这个矩阵 $S$ 关联了子结构边界上的位移和力。注意，由于刚度矩阵 $K$ 的对称性，有 $K_{ib} = K_{bi}^{\\mathsf{T}}$。\n\n### 步骤 1：子结构刚度矩阵的组装和凝聚\n\n子结构是一根长度为 $L$、杨氏模量为 $E$、面积为 $A$ 的一维轴向杆。它被离散为 $m=4$ 个等长单元。每个单元的长度为 $\\ell_e = L/4$。单个双节点杆单元的刚度矩阵为：\n$$\nk_e = \\frac{EA}{\\ell_e} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\frac{4EA}{L} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}\n$$\n对 $m=4$ 个单元（它们有 $m+1=5$ 个节点）进行标准有限元组装，得到 $5 \\times 5$ 的全局刚度矩阵 $K$：\n$$\nK = \\frac{4EA}{L} \\begin{pmatrix}\n1  & -1  & 0  & 0  & 0 \\\\\n-1  & 2  & -1  & 0  & 0 \\\\\n0  & -1  & 2  & -1  & 0 \\\\\n0  & 0  & -1  & 2  & -1 \\\\\n0  & 0  & 0  & -1  & 1\n\\end{pmatrix}\n$$\n边界自由度对应于第一个和最后一个节点（节点索引为 $0$ 和 $4$），内部自由度对应于中间节点（索引为 $1, 2, 3$）。根据划分方案，我们识别出各个子矩阵：$u_b = (u_0, u_4)^{\\mathsf{T}}$，$u_i = (u_1, u_2, u_3)^{\\mathsf{T}}$。基于完整的矩阵 $K$，这些块矩阵是：\n$$\nK_{bb} = \\frac{4EA}{L} \\begin{pmatrix} 1  & 0 \\\\ 0  & 1 \\end{pmatrix}, \\quad\nK_{bi} = \\frac{4EA}{L} \\begin{pmatrix} -1  & 0  & 0 \\\\ 0  & 0  & -1 \\end{pmatrix}\n$$\n$$\nK_{ii} = \\frac{4EA}{L} \\begin{pmatrix} 2  & -1  & 0 \\\\ -1  & 2  & -1 \\\\ 0  & -1  & 2 \\end{pmatrix}\n$$\n对于每个参数集 $\\theta = (E, A, L)$，$S(\\theta)$ 的计算过程是：数值上构建这些矩阵，并计算表达式 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$。我们将通过计算和存储 $(E, A, L)$ 指定张量积网格上每个点的 $S(\\theta)$ 来构建一个库。\n\n### 步骤 2：三线性插值\n\n对于不在网格点上的通用参数点 $\\theta=(E, A, L)$，凝聚刚度矩阵 $\\tilde{S}(\\theta)$ 通过对预先计算的库进行逐元素三线性插值来近似。对于定义在网格上的任何标量 $f(E,A,L)$，其在网格单元 $[E_i, E_{i+1}] \\times [A_j, A_{j+1}] \\times [L_k, L_{k+1}]$ 内一点 $(E,A,L)$ 的三线性插值，首先通过计算归一化坐标来找到：\n$$\nt_E = \\frac{E - E_i}{E_{i+1} - E_i}, \\quad t_A = \\frac{A - A_j}{A_{j+1} - A_j}, \\quad t_L = \\frac{L - L_k}{L_{k+1} - L_k}\n$$\n然后通过一系列线性插值（lerps）计算插值结果。设 $c_{pqr} = f(E_{i+p}, A_{j+q}, L_{k+r})$，其中 $p,q,r \\in \\{0, 1\\}$。\n1.  沿着与 $E$ 轴平行的四个单元边，在 $E$ 轴方向上进行插值。\n2.  将步骤1得到的四个结果沿 $A$ 轴方向进行插值，得到两个值。\n3.  将步骤2得到的两个结果沿 $L$ 轴方向进行插值，得到最终值。\n\n此过程应用于对称 $2 \\times 2$ 矩阵 $S(\\theta)$ 的独立元素，即 $S_{11}$、$S_{12}$ 和 $S_{22}$。\n\n### 步骤 3：全局组装和柔度计算\n\n由参数 $\\theta_1$ 和 $\\theta_2$ 描述的两个超单元被串联组装。这创建了一个具有三个节点的全局结构：节点 $0$（左端）、节点 $1$（界面）和节点 $2$（右端）。全局刚度矩阵 $K_G$ 是一个 $3 \\times 3$ 矩阵，由两个 $2 \\times 2$ 超单元矩阵 $S(\\theta_1)$ 和 $S(\\theta_2)$ 组装而成：\n$$\nK_G = \\begin{pmatrix}\nS_{1,11}  & S_{1,12}  & 0 \\\\\nS_{1,21}  & S_{1,22} + S_{2,11}  & S_{2,12} \\\\\n0  & S_{2,21}  & S_{2,22}\n\\end{pmatrix}\n$$\n边界条件是左端位移固定为 $u_0 = 0$。在右端施加一个载荷 $P=10^5 \\, \\mathrm{N}$。全局方程组为 $K_G u = f$，其中 $u = (u_0, u_1, u_2)^{\\mathsf{T}}$，外力向量为 $f_{ext} = (0, 0, P)^{\\mathsf{T}}$。\n\n施加边界条件 $u_0=0$ 后，系统简化为关于未知位移 $u_1$ 和 $u_2$ 的 $2 \\times 2$ 问题：\n$$\n\\begin{pmatrix}\nS_{1,22} + S_{2,11}  & S_{2,12} \\\\\nS_{2,21}  & S_{2,22}\n\\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ P \\end{pmatrix}\n$$\n求解出 $u_1$ 和 $u_2$ 后，完整的位移向量为 $u = (0, u_1, u_2)^{\\mathsf{T}}$。柔度 $c$ 是外施力所做的功，定义为 $c = f_{ext}^{\\mathsf{T}} u$。在这种情况下，它简化为 $c = P u_2$。\n\n### 步骤 4：相对误差计算\n\n对于每个测试用例 $(\\theta_1, \\theta_2)$，我们计算两个柔度值：\n1.  $c_{exact}$：使用精确计算的超单元矩阵 $S(\\theta_1)$ 和 $S(\\theta_2)$。\n2.  $c_{interp}$：使用三线性插值的矩阵 $\\tilde{S}(\\theta_1)$ 和 $\\tilde{S}(\\theta_2)$。\n\n然后，相对柔度误差 $\\varepsilon$ 按如下方式计算：\n$$\n\\varepsilon = \\frac{\\lvert c_{exact} - c_{interp} \\rvert}{\\lvert c_{exact} \\rvert}\n$$\n\n以下 Python 代码为四个指定的测试用例实现了这整个过程。", "answer": "```python\nimport numpy as np\n\ndef compute_S(theta, m):\n    \"\"\"\n    Computes the condensed stiffness matrix S for a 1D bar.\n    \n    Args:\n        theta (tuple): A tuple (E, A, L) of material and geometric properties.\n        m (int): Number of finite elements.\n    \n    Returns:\n        numpy.ndarray: The 2x2 condensed stiffness matrix.\n    \"\"\"\n    E, A, L = theta\n    if E == 0 or A == 0 or L == 0:\n        return np.zeros((2, 2))\n    \n    le = L / m\n    k_factor = E * A / le\n    \n    n_nodes = m + 1\n    K = np.zeros((n_nodes, n_nodes))\n    \n    for i in range(m):\n        k_e = k_factor * np.array([[1, -1], [-1, 1]])\n        K[i:i+2, i:i+2] += k_e\n\n    retained_dofs = [0, m]\n    doomed_dofs = list(range(1, m))\n\n    K_rr = K[np.ix_(retained_dofs, retained_dofs)]\n    K_rd = K[np.ix_(retained_dofs, doomed_dofs)]\n    K_dr = K[np.ix_(doomed_dofs, retained_dofs)]\n    K_dd = K[np.ix_(doomed_dofs, doomed_dofs)]\n    \n    # Solve K_dd * X = K_dr for X, then S = K_rr - K_rd @ X\n    Kdd_inv_Kdr = np.linalg.solve(K_dd, K_dr)\n    S = K_rr - K_rd @ Kdd_inv_Kdr\n    return S\n\ndef get_indices_and_t(val, grid):\n    \"\"\"\n    Finds the lower-bound index and normalized distance for interpolation.\n    \n    Args:\n        val (float): The value to locate in the grid.\n        grid (numpy.ndarray): The 1D sorted grid array.\n    \n    Returns:\n        tuple: (lower_bound_index, normalized_distance_t)\n    \"\"\"\n    if val == grid[-1]:\n        return len(grid) - 2, 1.0\n    \n    idx = np.searchsorted(grid, val, side='right') - 1\n    \n    # Handle precision issues where val might be slightly less than grid[0]\n    idx = max(0, idx)\n\n    t = (val - grid[idx]) / (grid[idx+1] - grid[idx])\n    \n    return idx, t\n\ndef interpolate_S(theta, library, grids):\n    \"\"\"\n    Computes the interpolated stiffness matrix S_tilde using trilinear interpolation.\n    \n    Args:\n        theta (tuple): The parameter point (E, A, L).\n        library (dict): The pre-computed library of stiffness matrices.\n        grids (tuple): A tuple of (E_grid, A_grid, L_grid).\n\n    Returns:\n        numpy.ndarray: The 2x2 interpolated stiffness matrix.\n    \"\"\"\n    if theta in library:\n        return library[theta]\n\n    E_grid, A_grid, L_grid = grids\n    E, A, L = theta\n\n    i, tE = get_indices_and_t(E, E_grid)\n    j, tA = get_indices_and_t(A, A_grid)\n    k, tL = get_indices_and_t(L, L_grid)\n\n    # Get the 8 corner points of the grid cell\n    corners = np.zeros((8, 3)) # 8 corners, 3 values (S00, S01, S11)\n    \n    E_coords = [E_grid[i], E_grid[i+1]]\n    A_coords = [A_grid[j], A_grid[j+1]]\n    L_coords = [L_grid[k], L_grid[k+1]]\n\n    corner_idx = 0\n    # The order of loops establishes the convention for interpolation axes.\n    # E -> x, A -> y, L -> z\n    for l_val in L_coords:\n        for a_val in A_coords:\n            for e_val in E_coords:\n                S_val = library[(e_val, a_val, l_val)]\n                corners[corner_idx, :] = [S_val[0,0], S_val[0,1], S_val[1,1]]\n                corner_idx += 1\n    \n    interp_vals = np.zeros(3)\n    for val_idx in range(3): # Iterate over S00, S01, S11\n        # Interpolate along E axis (tE)\n        c00 = corners[0, val_idx] * (1 - tE) + corners[1, val_idx] * tE\n        c10 = corners[2, val_idx] * (1 - tE) + corners[3, val_idx] * tE\n        c01 = corners[4, val_idx] * (1 - tE) + corners[5, val_idx] * tE\n        c11 = corners[6, val_idx] * (1 - tE) + corners[7, val_idx] * tE\n        \n        # Interpolate along A axis (tA)\n        c0 = c00 * (1 - tA) + c10 * tA\n        c1 = c01 * (1 - tA) + c11 * tA\n        \n        # Interpolate along L axis (tL)\n        interp_vals[val_idx] = c0 * (1 - tL) + c1 * tL\n\n    S_interp = np.array([\n        [interp_vals[0], interp_vals[1]],\n        [interp_vals[1], interp_vals[2]]\n    ])\n    return S_interp\n\ndef calculate_compliance(S1, S2, P):\n    \"\"\"\n    Calculates the global compliance for a two-element assembly.\n    \n    Args:\n        S1, S2 (numpy.ndarray): 2x2 stiffness matrices for elements 1 and 2.\n        P (float): Applied load at the right end.\n        \n    Returns:\n        float: The global compliance.\n    \"\"\"\n    K_red = np.array([\n        [S1[1,1] + S2[0,0], S2[0,1]],\n        [S2[1,0], S2[1,1]]\n    ])\n    f_red = np.array([0, P])\n    \n    if np.linalg.det(K_red) == 0:\n        return np.inf\n\n    u_red = np.linalg.solve(K_red, f_red)\n    u2 = u_red[1]\n    \n    return P * u2\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and print the results.\n    \"\"\"\n    # Define parameters and problem setup\n    m = 4\n    P = 1e5\n    E_grid = np.array([70e9, 140e9, 210e9])\n    A_grid = np.array([5e-4, 1e-3, 2e-3])\n    L_grid = np.array([0.5, 1.0, 2.0])\n    grids = (E_grid, A_grid, L_grid)\n\n    # Define the test cases\n    test_cases = [\n        # ((E1, A1, L1), (E2, A2, L2))\n        ((140e9, 1e-3, 1.0), (140e9, 1e-3, 1.0)),\n        ((100e9, 0.8e-3, 1.2), (140e9, 1e-3, 1.0)),\n        ((175e9, 1.5e-3, 0.5), (100e9, 0.8e-3, 1.2)),\n        ((140e9, 0.75e-3, 2.0), (210e9, 2e-3, 2.0)),\n    ]\n\n    # Step 1: Library construction\n    library = {}\n    for E in E_grid:\n        for A in A_grid:\n            for L in L_grid:\n                theta = (E, A, L)\n                library[theta] = compute_S(theta, m)\n\n    results = []\n    for theta1, theta2 in test_cases:\n        # Exact calculation\n        S1_exact = compute_S(theta1, m)\n        S2_exact = compute_S(theta2, m)\n        c_exact = calculate_compliance(S1_exact, S2_exact, P)\n\n        # Interpolated calculation\n        S1_interp = interpolate_S(theta1, library, grids)\n        S2_interp = interpolate_S(theta2, library, grids)\n        c_interp = calculate_compliance(S1_interp, S2_interp, P)\n\n        # Relative error\n        if c_exact != 0:\n            error = np.abs(c_exact - c_interp) / np.abs(c_exact)\n        else:\n            # This case implies infinite stiffness, zero compliance\n            error = 0.0 if c_interp == 0.0 else np.inf\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3602488"}]}