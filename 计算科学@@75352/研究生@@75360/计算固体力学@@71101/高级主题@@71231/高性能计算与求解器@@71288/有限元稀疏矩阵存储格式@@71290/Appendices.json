{"hands_on_practices": [{"introduction": "在分析稀疏矩阵存储方案时，首要步骤是理解物理网格的连接性如何转化为特定的矩阵稀疏模式。本练习 [@problem_id:3601647] 使用一个简单的一维梁单元问题来具体展示这一联系。通过手动构建矩阵轮廓并比较 Skyline 和 CSR 方案的存储成本，您将对它们各自的优缺点获得切实的直观理解，这是选择合适数据结构的一项基本技能。", "problem": "考虑一根一维 Euler–Bernoulli 梁，使用有限元法（FEM）进行离散化，采用双节点单元，每个节点有两个自由度（DOF）：横向位移 $w$ 和转角 $\\theta$。该梁有 $6$ 个节点，位置分别为 $x=\\{0, 0.3, 0.5, 1.1, 1.4, 2.0\\}$，因此单元长度为 $\\{0.3, 0.2, 0.6, 0.3, 0.6\\}$ 米。网格连接关系是自然链式：单元 $e=1$ 连接节点 $(1,2)$，单元 $e=2$ 连接节点 $(2,3)$，以此类推，直到单元 $e=5$ 连接节点 $(5,6)$。梁在节点 $1$ 处被夹紧，因此基本边界条件为 $w_{1}=0$ 和 $\\theta_{1}=0$。对于自由自由度，使用节点的自然排序，并在每个节点内使用字典序 $(w,\\theta)$。\n\n从以下有限元组装基本原理出发：(i) 组装后的全局刚度矩阵 $K$ 是对称的，以及 (ii) 每个双节点 Euler–Bernoulli 单元贡献一个稠密的 $4\\times 4$ 局部刚度矩阵，该矩阵耦合其两端节点的所有自由度。请构建缩减后（施加基本边界条件后）的全局刚度矩阵的天际线轮廓。天际线存储方案的定义是：对于每一列 $j$，存储从对角线元素到该列第一个非零元素之间的所有条目；令 $h_{j}$ 表示第 $j$ 列中存储的条目数，总存储值为 $\\sum_{j=1}^{n} h_{j}$，其中 $n$ 是自由自由度的数量。假设实值浮点数条目占用 $8$ 字节存储，整数索引也占用 $8$ 字节存储。\n\n比较以下两种方案的总存储量（以字节为单位）：\n- 天际线方案，它只存储上三角部分以及一个长度为 $n+1$ 的列指针数组。\n- 压缩稀疏行（CSR）方案，它以标准的行主序形式存储整个对称矩阵（包括上三角和下三角），使用三个数组：值数组、列索引数组和长度为 $n+1$ 的行指针数组。\n\n假设所有整数数组和所有浮点数组均使用 $8$ 字节条目。仅使用网格连接关系和上述有限元组装原理，确定此问题中 CSR 存储量与天际线存储量的精确比率（以最简分数表示）。请将最终结果以一个最简分数的形式给出。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的、客观的和自洽的。它描述了计算固体力学和数据结构分析中的一个标准问题，为得出唯一解提供了所有必要信息。\n\n第一步是确定施加基本边界条件后缩减系统的自由度（DOF）。梁有 $6$ 个节点，每个节点有 $2$ 个自由度（$w$, $\\theta$），总共有 $6 \\times 2 = 12$ 个自由度。节点 $1$ 处的夹紧边界条件固定了 $w_1=0$ 和 $\\theta_1=0$。这两个自由度从系统中移除。剩余的自由自由度与节点 $2, 3, 4, 5, 6$ 相关联。问题指定了节点的自然排序以及每个节点内自由度的字典序。因此，自由自由度的排序如下：$(w_2, \\theta_2), (w_3, \\theta_3), (w_4, \\theta_4), (w_5, \\theta_5), (w_6, \\theta_6)$。\n\n让我们为缩减后的全局刚度矩阵 $K_{red}$（一个 $10 \\times 10$ 的矩阵）将这 $10$ 个自由自由度从 $1$ 到 $10$ 重新编号。从物理自由度到 $K_{red}$ 索引的映射关系如下：\n\\begin{itemize}\n    \\item 索引 $1$: $w_2$\n    \\item 索引 $2$: $\\theta_2$\n    \\item 索引 $3$: $w_3$\n    \\item 索引 $4$: $\\theta_3$\n    \\item 索引 $5$: $w_4$\n    \\item 索引 $6$: $\\theta_4$\n    \\item 索引 $7$: $w_5$\n    \\item 索引 $8$: $\\theta_5$\n    \\item 索引 $9$: $w_6$\n    \\item 索引 $10$: $\\theta_6$\n\\end{itemize}\n自由自由度的数量为 $n=10$。\n\n接下来，我们确定 $K_{red}$ 的稀疏模式。如果第 $i$ 个和第 $j$ 个自由自由度在至少一个单元内耦合，则条目 $(K_{red})_{ij}$ 为非零。每个双节点单元贡献一个稠密的 $4 \\times 4$ 局部刚度矩阵，耦合其两端节点的所有自由度。\n\\begin{itemize}\n    \\item 单元 $1$ (节点 $1, 2$): 耦合自由度 $\\{w_1, \\theta_1, w_2, \\theta_2\\}$。在缩减系统中，这耦合了自由自由度 $\\{w_2, \\theta_2\\}$，对应于索引 $\\{1, 2\\}$。\n    \\item 单元 $2$ (节点 $2, 3$): 耦合自由度 $\\{w_2, \\theta_2, w_3, \\theta_3\\}$，对应于索引 $\\{1, 2, 3, 4\\}$。\n    \\item 单元 $3$ (节点 $3, 4$): 耦合自由度 $\\{w_3, \\theta_3, w_4, \\theta_4\\}$，对应于索引 $\\{3, 4, 5, 6\\}$。\n    \\item 单元 $4$ (节点 $4, 5$): 耦合自由度 $\\{w_4, \\theta_4, w_5, \\theta_5\\}$，对应于索引 $\\{5, 6, 7, 8\\}$。\n    \\item 单元 $5$ (节点 $5, 6$): 耦合自由度 $\\{w_5, \\theta_5, w_6, \\theta_6\\}$，对应于索引 $\\{7, 8, 9, 10\\}$。\n\\end{itemize}\n全局刚度矩阵是对称的。非零模式是所有单元耦合的并集。对于 $K_{red}$ 的任意列 $j$，上三角中的第一个非零条目 $(K_{red})_{ij}$（其中 $i \\le j$）出现在行 $i=m_j$ 处，其中 $m_j = \\min\\{i | (K_{red})_{ij} \\neq 0\\}$。我们可以通过检查耦合关系来确定第一个非零行索引的向量 $m$：\n\\begin{itemize}\n    \\item 列 $j \\in \\{1, 2, 3, 4\\}$ 与单元 $2$ 中的自由度（索引 $\\{1, 2, 3, 4\\}$）耦合，因此最小行索引为 $1$。所以，$m_1=1, m_2=1, m_3=1, m_4=1$。\n    \\item 列 $j \\in \\{5, 6\\}$ 与单元 $3$ 中的自由度（索引 $\\{3, 4, 5, 6\\}$）耦合，因此该组的最小行索引为 $3$。它们不与索引为 $\\{1, 2\\}$ 的自由度耦合。所以，$m_5=3, m_6=3$。\n    \\item 列 $j \\in \\{7, 8\\}$ 与单元 $4$ 中的自由度（索引 $\\{5, 6, 7, 8\\}$）耦合，因此该组的最小行索引为 $5$。所以，$m_7=5, m_8=5$。\n    \\item 列 $j \\in \\{9, 10\\}$ 与单元 $5$ 中的自由度（索引 $\\{7, 8, 9, 10\\}$）耦合，因此该组的最小行索引为 $7$。所以，$m_9=7, m_{10}=7$。\n\\end{itemize}\n第一个非零行索引的向量是 $m = [1, 1, 1, 1, 3, 3, 5, 5, 7, 7]$。\n\n现在，我们计算天际线方案的存储量。第 $j$ 列中存储的条目数是列高 $h_j = j - m_j + 1$。\n$h_1 = 1 - 1 + 1 = 1$\n$h_2 = 2 - 1 + 1 = 2$\n$h_3 = 3 - 1 + 1 = 3$\n$h_4 = 4 - 1 + 1 = 4$\n$h_5 = 5 - 3 + 1 = 3$\n$h_6 = 6 - 3 + 1 = 4$\n$h_7 = 7 - 5 + 1 = 3$\n$h_8 = 8 - 5 + 1 = 4$\n$h_9 = 9 - 7 + 1 = 3$\n$h_{10} = 10 - 7 + 1 = 4$\n存储的浮点值总数为 $N_{vals, skyline} = \\sum_{j=1}^{10} h_j = 1+2+3+4+3+4+3+4+3+4 = 31$。\n天际线方案使用一个长度为 $n+1 = 11$ 的列指针数组。\n浮点值和整数索引都占用 $8$ 字节存储。\n天际线总存储量为 $S_{skyline} = (N_{vals, skyline} + (n+1)) \\times 8 = (31 + 11) \\times 8 = 42 \\times 8 = 336$ 字节。\n\n接下来，我们计算压缩稀疏行（CSR）方案的存储量。问题说明该方案存储整个对称矩阵。我们需要找到非零条目的总数 NNZ。我们可以根据单元耦合逐行计算非零元的数量。\n\\begin{itemize}\n    \\item 行 $1, 2$ (自由度 $w_2, \\theta_2$): 与索引 $\\{1, 2, 3, 4\\}$ 耦合。每行的非零元数量为 $4$。总计：$2 \\times 4 = 8$。\n    \\item 行 $3, 4$ (自由度 $w_3, \\theta_3$): 与单元 2 ($\\{1,2,3,4\\}$) 和单元 3 ($\\{3,4,5,6\\}$) 的索引耦合。索引的并集为 $\\{1, 2, 3, 4, 5, 6\\}$。每行的非零元数量为 $6$。总计：$2 \\times 6 = 12$。\n    \\item 行 $5, 6$ (自由度 $w_4, \\theta_4$): 与单元 3 ($\\{3,4,5,6\\}$) 和单元 4 ($\\{5,6,7,8\\}$) 的索引耦合。并集为 $\\{3, 4, 5, 6, 7, 8\\}$。每行的非零元数量为 $6$。总计：$2 \\times 6 = 12$。\n    \\item 行 $7, 8$ (自由度 $w_5, \\theta_5$): 与单元 4 ($\\{5,6,7,8\\}$) 和单元 5 ($\\{7,8,9,10\\}$) 的索引耦合。并集为 $\\{5, 6, 7, 8, 9, 10\\}$。每行的非零元数量为 $6$。总计：$2 \\times 6 = 12$。\n    \\item 行 $9, 10$ (自由度 $w_6, \\theta_6$): 与单元 5 ($\\{7, 8, 9, 10\\}$) 的索引耦合。每行的非零元数量为 $4$。总计：$2 \\times 4 = 8$。\n\\end{itemize}\n非零条目的总数为 $NNZ = 8 + 12 + 12 + 12 + 8 = 52$。\n存储完整矩阵的 CSR 方案需要三个数组：\n\\begin{enumerate}\n    \\item 一个长度为 $NNZ = 52$ 的值数组。\n    \\item 一个长度为 $NNZ = 52$ 的列索引数组。\n    \\item 一个长度为 $n+1 = 11$ 的行指针数组。\n\\end{enumerate}\nCSR 总存储量为 $S_{csr} = (52 + 52 + 11) \\times 8 = 115 \\times 8 = 920$ 字节。\n\n最后，我们计算 CSR 存储量与天际线存储量的比率。\n$$ \\text{比率} = \\frac{S_{csr}}{S_{skyline}} = \\frac{115 \\times 8}{42 \\times 8} = \\frac{115}{42} $$\n为了化简这个分数，我们找到分子和分母的质因数。\n$115 = 5 \\times 23$。\n$42 = 2 \\times 3 \\times 7$。\n数字 $115$ 和 $42$ 没有公质因数，因此该分数已经是最简形式。", "answer": "$$\\boxed{\\frac{115}{42}}$$", "id": "3601647"}, {"introduction": "许多稀疏矩阵求解器（尤其是直接求解器和预条件迭代求解器）的性能对矩阵的带宽或轮廓高度敏感。不良的自由度排序会导致过度的内存使用和计算时间。本练习 [@problem_id:3601692] 将指导您在一个非结构化网格上手动执行 Reverse Cuthill-McKee (RCM) 算法。通过这个实践，您将清晰、逐步地理解这些强大的优化技术如何在底层运作，从而有效地减小矩阵带宽。", "problem": "考虑一个二维线性弹性模型，该模型在非结构化网格上使用线性三角形单元通过有限元法（FEM）进行离散化。假设每个网格节点有一个标量位移自由度（DOF），因此全局刚度矩阵是对称的，并且当且仅当节点 $i$ 和 $j$ 同时出现在至少一个单元中时，存在一个非零的非对角元 $K_{ij}$。这就在节点上导出了通常的邻接图。基于轮廓的方案的计算成本由矩阵带宽决定，对于给定的节点排序 $p:\\{1,\\dots,N\\}\\to\\{1,\\dots,N\\}$，带宽定义为\n$$\nb \\;=\\; \\max\\{\\, |p(i)-p(j)| \\;:\\; (i,j)\\ \\text{is an adjacency edge}\\,\\}.\n$$\n给定一个具有 $N=12$ 个节点的非结构化三角形网格，其当前排序为 $p_{\\text{old}}(i)=i$，以及单元连接关系\n$$\n(1,2,5),\\ (1,4,5),\\ (2,3,6),\\ (2,5,6),\\ (4,5,8),\\ (4,7,8),\\ (5,6,9),\\ (5,8,9),\\ (7,8,11),\\ (7,10,11),\\ (8,9,12),\\ (8,11,12).\n$$\n根据有限元组装和图论的基本原理，构建由此连接关系所隐含的邻接图。然后执行一轮 Reverse Cuthill-McKee (RCM) 重新排序，以获得新的节点排序 $p_{\\text{new}}$，过程如下：\n- 选择度最小的节点作为起始节点；如果存在平局，则选择标签最小的节点。\n- 执行广度优先搜索（BFS），当访问一个节点时，将其未访问过的邻居节点按度非递减排序后入队；如果存在平局，则按标签递增排序。\n- Cuthill-McKee 排序是 BFS 的访问顺序；Reverse Cuthill-McKee 排序将该序列反转以产生 $p_{\\text{new}}$。\n\n计算在 $p_{\\text{old}}$ 下的原始带宽 $b_{\\text{old}}$，在 $p_{\\text{new}}$ 下的新带宽 $b_{\\text{new}}$，以及带宽缩减率\n$$\nr \\;=\\; \\frac{b_{\\text{old}} - b_{\\text{new}}}{b_{\\text{old}}}.\n$$\n将最终比率 $r$ 表示为无单位的精确分数。", "solution": "该问题在计算力学和数值线性代数领域具有良好的定义和科学依据。我们将给出一个完整的解答。该问题要求我们分析一个由有限元法（FEM）离散化产生的稀疏矩阵的带宽，使用 Reverse Cuthill-McKee (RCM) 算法进行带宽缩减的重新排序，并计算最终的改进效果。\n\n过程结构如下：\n1.  根据给定的单元连接关系构建邻接图，并确定每个节点的度。\n2.  计算原始节点排序 $p_{\\text{old}}(i)=i$ 下的带宽 $b_{\\text{old}}$。\n3.  执行 RCM 算法以获得新的节点排序 $p_{\\text{new}}$。\n4.  计算新排序下的带宽 $b_{\\text{new}}$。\n5.  计算带宽缩减率 $r$。\n\n**1. 邻接图构建与节点度**\n\n全局刚度矩阵 $K$ 的非对角元 $K_{ij}$ 非零，当且仅当节点 $i$ 和 $j$ 共享至少一个单元。这定义了邻接图的边。我们从给定的单元连接关系列表中导出边：\n$(1,2,5), (1,4,5), (2,3,6), (2,5,6), (4,5,8), (4,7,8), (5,6,9), (5,8,9), (7,8,11), (7,10,11), (8,9,12), (8,11,12)$.\n\n从这12个单元中，我们整理出唯一的边，为 $N=12$ 个节点中的每一个构建邻接表。一个节点 $i$ 的度，记为 $\\text{deg}(i)$，是与其相邻的节点数量。\n\n-   节点 $1$：相邻节点 $\\{2, 4, 5\\}$。$\\text{deg}(1) = 3$。\n-   节点 $2$：相邻节点 $\\{1, 3, 5, 6\\}$。$\\text{deg}(2) = 4$。\n-   节点 $3$：相邻节点 $\\{2, 6\\}$。$\\text{deg}(3) = 2$。\n-   节点 $4$：相邻节点 $\\{1, 5, 7, 8\\}$。$\\text{deg}(4) = 4$。\n-   节点 $5$：相邻节点 $\\{1, 2, 4, 6, 8, 9\\}$。$\\text{deg}(5) = 6$。\n-   节点 $6$：相邻节点 $\\{2, 3, 5, 9\\}$。$\\text{deg}(6) = 4$。\n-   节点 $7$：相邻节点 $\\{4, 8, 10, 11\\}$。$\\text{deg}(7) = 4$。\n-   节点 $8$：相邻节点 $\\{4, 5, 7, 9, 11, 12\\}$。$\\text{deg}(8) = 6$。\n-   节点 $9$：相邻节点 $\\{5, 6, 8, 12\\}$。$\\text{deg}(9) = 4$。\n-   节点 $10$：相邻节点 $\\{7, 11\\}$。$\\text{deg}(10) = 2$。\n-   节点 $11$：相邻节点 $\\{7, 8, 10, 12\\}$。$\\text{deg}(11) = 4$。\n-   节点 $12$：相邻节点 $\\{8, 9, 11\\}$。$\\text{deg}(12) = 3$。\n\n**2. 原始带宽 $b_{\\text{old}}$**\n\n初始排序是单位排列，$p_{\\text{old}}(i) = i$ 对于 $i \\in \\{1, \\dots, 12\\}$。带宽 $b_{\\text{old}}$ 是图中所有边 $(i,j)$ 上 $|p_{\\text{old}}(i) - p_{\\text{old}}(j)| = |i-j|$ 的最大值。我们检查所有边来找到这个最大值。\n\n例如，对于节点 $8$，其相邻节点为 $\\{4, 5, 7, 9, 11, 12\\}$。标签的差值为：\n$|8-4|=4$, $|8-5|=3$, $|8-7|=1$, $|8-9|=1$, $|8-11|=3$, $|8-12|=4$。\n节点 $8$ 的最大差值为 $4$。\n通过检查所有边，我们发现有几个实例产生了此差值，例如边 $(1,5)$ 的 $|1-5|=4$，边 $(2,6)$ 的 $|2-6|=4$，边 $(7,11)$ 的 $|7-11|=4$，以及边 $(8,12)$ 的 $|8-12|=4$。不存在任何边 $(i,j)$ 使得 $|i-j| > 4$。\n因此，原始带宽为 $b_{\\text{old}} = 4$。\n\n**3. Reverse Cuthill-McKee (RCM) 重新排序**\n\nRCM 算法按规定执行。\n\n**a. 起始节点选择：**\n我们寻找度最小的节点。最小度为 $2$，由节点 $3$ 和 $10$ 共享。根据平局决胜规则，我们选择标签最小的那个。因此，起始节点是 $3$。\n\n**b. 广度优先搜索（BFS）：**\n我们用起始节点 $3$ 初始化一个队列 $Q$。设 $R$ 是存储 Cuthill-McKee (CM) 排序的列表。\n1.  $Q=[3]$。将 $3$ 出队，$R=(3)$。$3$ 的相邻节点是 $\\{2,6\\}$。它们的度都是 $4$。按标签平局决胜，我们将它们排序为 $(2,6)$。将 $2$ 入队，然后是 $6$。$Q=[2,6]$。\n2.  $Q=[2,6]$。将 $2$ 出队，$R=(3,2)$。$2$ 的未访问过的相邻节点是 $\\{1,5\\}$。$\\text{deg}(1)=3$，$\\text{deg}(5)=6$。按度排序为：$(1,5)$。将 $1$ 入队，然后是 $5$。$Q=[6,1,5]$。\n3.  $Q=[6,1,5]$。将 $6$ 出队，$R=(3,2,6)$。$6$ 的未访问过的相邻节点是 $\\{9\\}$。$\\text{deg}(9)=4$。将 $9$ 入队。$Q=[1,5,9]$。\n4.  $Q=[1,5,9]$。将 $1$ 出队，$R=(3,2,6,1)$。$1$ 的未访问过的相邻节点是 $\\{4\\}$。$\\text{deg}(4)=4$。将 $4$ 入队。$Q=[5,9,4]$。\n5.  $Q=[5,9,4]$。将 $5$ 出队，$R=(3,2,6,1,5)$。$5$ 的未访问过的相邻节点是 $\\{8\\}$。$\\text{deg}(8)=6$。将 $8$ 入队。$Q=[9,4,8]$。\n6.  $Q=[9,4,8]$。将 $9$ 出队，$R=(3,2,6,1,5,9)$。$9$ 的未访问过的相邻节点是 $\\{12\\}$。$\\text{deg}(12)=3$。将 $12$ 入队。$Q=[4,8,12]$。\n7.  $Q=[4,8,12]$。将 $4$ 出队，$R=(3,2,6,1,5,9,4)$。$4$ 的未访问过的相邻节点是 $\\{7\\}$。$\\text{deg}(7)=4$。将 $7$ 入队。$Q=[8,12,7]$。\n8.  $Q=[8,12,7]$。将 $8$ 出队，$R=(3,2,6,1,5,9,4,8)$。$8$ 的未访问过的相邻节点是 $\\{11\\}$。$\\text{deg}(11)=4$。将 $11$ 入队。$Q=[12,7,11]$。\n9.  $Q=[12,7,11]$。将 $12$ 出队，$R=(3,2,6,1,5,9,4,8,12)$。节点 $12$ 没有未访问过的相邻节点。$Q=[7,11]$。\n10. $Q=[7,11]$。将 $7$ 出队，$R=(3,2,6,1,5,9,4,8,12,7)$。$7$ 的未访问过的相邻节点是 $\\{10\\}$。$\\text{deg}(10)=2$。将 $10$ 入队。$Q=[11,10]$。\n11. $Q=[11,10]$。将 $11$ 出队，$R=(3,2,6,1,5,9,4,8,12,7,11)$。节点 $11$ 没有未访问过的相邻节点。$Q=[10]$。\n12. $Q=[10]$。将 $10$ 出队，$R=(3,2,6,1,5,9,4,8,12,7,11,10)$。节点 $10$ 没有未访问过的相邻节点。$Q=[]$。\n\nCM 排序为 $R = (3, 2, 6, 1, 5, 9, 4, 8, 12, 7, 11, 10)$。\n\n**c. 新排序 $p_{\\text{new}}$：**\nRCM 排序是 CM 排序的反转。这定义了新的排列 $p_{\\text{new}}$，它将原始节点标签映射到从 $1$ 到 $12$ 的新位置。\nRCM 顺序：$(10, 11, 7, 12, 8, 4, 9, 5, 1, 6, 2, 3)$。\n映射 $p_{\\text{new}}$ 为：\n$p_{\\text{new}}(10)=1$, $p_{\\text{new}}(11)=2$, $p_{\\text{new}}(7)=3$, $p_{\\text{new}}(12)=4$, $p_{\\text{new}}(8)=5$, $p_{\\text{new}}(4)=6$, $p_{\\text{new}}(9)=7$, $p_{\\text{new}}(5)=8$, $p_{\\text{new}}(1)=9$, $p_{\\text{new}}(6)=10$, $p_{\\text{new}}(2)=11$, $p_{\\text{new}}(3)=12$.\n\n**4. 新带宽 $b_{\\text{new}}$**\n\n我们计算新带宽 $b_{\\text{new}} = \\max \\{ |p_{\\text{new}}(i) - p_{\\text{new}}(j)| \\}$，其中 $(i,j)$ 是所有边。\n我们检查一些可能产生较大差值的边：\n-   边 $(1,4)$: $|p_{\\text{new}}(1) - p_{\\text{new}}(4)| = |9 - 6| = 3$.\n-   边 $(2,5)$: $|p_{\\text{new}}(2) - p_{\\text{new}}(5)| = |11 - 8| = 3$.\n-   边 $(4,7)$: $|p_{\\text{new}}(4) - p_{\\text{new}}(7)| = |6 - 3| = 3$.\n-   边 $(5,8)$: $|p_{\\text{new}}(5) - p_{\\text{new}}(8)| = |8 - 5| = 3$.\n-   边 $(6,9)$: $|p_{\\text{new}}(6) - p_{\\text{new}}(9)| = |10 - 7| = 3$.\n-   边 $(8,11)$: $|p_{\\text{new}}(8) - p_{\\text{new}}(11)| = |5 - 2| = 3$.\n-   边 $(9,12)$: $|p_{\\text{new}}(9) - p_{\\text{new}}(12)| = |7 - 4| = 3$.\n\n对所有 23 条边的彻底检查确认，任何相连节点对的新标签之间的最大差值为 $3$。\n因此，新带宽为 $b_{\\text{new}} = 3$。\n\n**5. 带宽缩减率 $r$**\n\n带宽缩减率 $r$ 定义为：\n$$\nr = \\frac{b_{\\text{old}} - b_{\\text{new}}}{b_{\\text{old}}}\n$$\n代入计算出的值：\n$$\nr = \\frac{4 - 3}{4} = \\frac{1}{4}\n$$\nRCM 重新排序实现了 $25\\%$ 的带宽缩减。", "answer": "$$\\boxed{\\frac{1}{4}}$$", "id": "3601692"}, {"introduction": "在现代有限元软件中，组装全局刚度矩阵可能成为一个显著的性能瓶颈，尤其对于大规模问题。并行处理对于提高效率至关重要，但它引入了竞争条件的风险，即多个线程试图同时更新同一个矩阵项。这项高级练习 [@problem_id:3601704] 探讨了一种利用单元着色和预计算稀疏矩阵结构的稳健策略，以实现无竞争条件的并行组装。通过设计并验证此算法，您将接触到高性能科学计算中用于安全、高效地构建大型稀疏系统的尖端技术。", "problem": "考虑计算固体力学中的一个线性椭圆边值问题的有限元方法（FEM）离散化。离散化的全局线性系统写作 $K u = f$，其中 $K \\in \\mathbb{R}^{n \\times n}$ 是全局刚度矩阵，$u \\in \\mathbb{R}^{n}$ 是全局位移向量，$f \\in \\mathbb{R}^{n}$ 是全局力向量。标准的逐单元集成公式为 $K \\leftarrow K + P_e^\\top K_e P_e$，其中 $K_e \\in \\mathbb{R}^{n_e \\times n_e}$ 是单元 $e$ 的单元刚度矩阵，$P_e$ 是将局部单元自由度（DOF）映射到全局自由度索引的布尔散布矩阵。压缩稀疏行（CSR）存储格式通过三个数组来表示稀疏矩阵：行指针数组 $indptr$、列索引数组 $indices$ 和数值数组 $data$。无竞争的并行集成要求任意两个并发线程都不会写入 $data$ 中的同一内存位置。\n\n设计并实现一个无竞争的并行有限元集成算法，该算法需要：\n- 从逐单元自由度邻接关系的并集中预计算全局 CSR 稀疏结构，为每对全局自由度 $(i,j)$ 创建到 $data$ 中单个位置的唯一映射。\n- 使用单元着色（或等效地，使用确保每组自由度集合不相交的图划分）来调度单元集成，使得同一颜色组中的单元不共享任何全局自由度。在同一颜色组内，单元可以无竞争地并行集成。\n- 从第一性原理出发，证明最终的 CSR 表示在任何行中都没有重复的列索引，并证明当所有单元矩阵 $K_e$ 都是对称的时，集成后的全局矩阵 $K$ 也是对称的。\n\n您必须从有限元集成、自由度邻接和矩阵对称性的基本定义出发。避免使用简化的公式。集成过程必须用纯粹的数学和逻辑术语来表达。不需要物理单位；所有输出均为布尔值。\n\n您的程序必须实现该算法，并对每个测试用例验证以下属性：\n1. 无竞争着色有效性：一个布尔值，指示所提供的着色是否为一种合适的单元着色，其中相同颜色的任意两个单元都不共享自由度。\n2. CSR 无重复性：一个布尔值，指示所构建的 CSR 结构在任何行内是否都没有重复的列索引。\n3. 对称性保持：一个布尔值，指示集成后的全局矩阵 $K$ 是否对称，通过在 $10^{-12}$ 的数值容差范围内验证所有存储的条目是否满足 $K_{ij} = K_{ji}$ 来测试。\n\n测试套件：\n- 案例 1（正常路径）：一个一维链，有 $n = 5$ 个全局自由度和 $4$ 个双节点单元，其局部自由度列表为 $[0,1]$、$[1,2]$、$[2,3]$、$[3,4]$。每个单元都有一个对称的局部刚度矩阵 $K_e = \\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$。使用一个有效的着色 $[0,1,0,1]$。\n- 案例 2（不连通组件）：两个不相交的一维链，有 $n = 8$ 个全局自由度和 $6$ 个双节点单元，其局部自由度列表为 $[0,1]$、$[1,2]$、$[2,3]$、$[4,5]$、$[5,6]$、$[6,7]$。每个单元都有一个对称的局部刚度矩阵 $K_e = \\begin{bmatrix}2  -2 \\\\ -2  2\\end{bmatrix}$。使用一个有效的着色 $[0,1,0,0,1,0]$。\n- 案例 3（无效着色）：与案例 1 相同的网格和对称的局部刚度矩阵，但使用一个无效的着色 $[0,0,0,0]$，其中相邻单元在同一颜色中共享自由度。\n- 案例 4（对称性边界情况）：与案例 1 相同的网格，但第二个单元的单元矩阵非对称，例如 $K_e^{(2)} = \\begin{bmatrix}1  0 \\\\ -1  1\\end{bmatrix}$，而其他单元的矩阵为 $K_e = \\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$。使用一个有效的着色 $[0,1,0,1]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按顺序排列的三个布尔值的列表 $[$race\\_free, csr\\_no\\_duplicates, is\\_symmetric$]$。例如，输出应类似于单行上的 $[[\\text{True},\\text{True},\\text{True}],\\ldots]$。", "solution": "该问题要求在有限元方法（FEM）的背景下，设计、实现并形式化论证一个用于全局刚度矩阵 $K$ 的无竞争并行集成算法。该解决方案必须针对特定属性进行验证：并行化方案的有效性（单元着色）、稀疏矩阵格式的结构完整性（无重复条目）以及矩阵对称性的保持。\n\n### 形式化与算法设计\n\n全局刚度矩阵 $K$ 的集成定义为映射到全局自由度（DOF）的单元刚度矩阵 $K_e$ 的总和：\n$$ K = \\sum_{e} P_e^\\top K_e P_e $$\n其中 $P_e$ 是单元 $e$ 的散布算子。一种直接、朴素的并行化方法，即多个线程同时集成不同的单元，可能导致竞争条件，因为两个单元可能共享一个全局自由度，从而试图同时写入同一个条目 $K_{ij}$。一个稳健的并行算法通过仔细调度集成过程来规避此问题。\n\n#### 步骤 1：稀疏模式预计算与 CSR 结构\n\n第一步是在进行任何数值集成之前确定 $K$ 的稀疏模式。仅当全局自由度 $i$ 和 $j$ 属于同一个单元时，条目 $K_{ij}$ 才为非零。设 $\\mathcal{D}_e$ 为单元 $e$ 的全局自由度索引集合。矩阵 $K$ 中所有非零位置 $(i, j)$ 的集合包含在结构邻接集 $S$ 中：\n$$ S = \\bigcup_{e} \\{ (i, j) \\mid i \\in \\mathcal{D}_e, j \\in \\mathcal{D}_e \\} $$\n这个集合 $S$ 定义了完整的稀疏模式。由此，我们可以构建压缩稀疏行（CSR）表示，它由三个数组组成：`indptr`、`indices` 和 `data`。\n\n1.  对于每个全局行 $i$（从 $0$到 $n-1$），我们确定该行中所有非零条目的列索引集合 $C_i$：\n    $$ C_i = \\{ j \\mid (i, j) \\in S \\} = \\{ j \\mid \\exists e \\text{ such that } i \\in \\mathcal{D}_e \\text{ and } j \\in \\mathcal{D}_e \\} $$\n\n2.  `indices` 数组是每行排好序的列索引列表的串联。设 $C_i^{\\text{sorted}}$ 是 $C_i$ 中元素按升序排列的列表。\n    `indices` 数组为 $[\\, C_0^{\\text{sorted}}, C_1^{\\text{sorted}}, \\dots, C_{n-1}^{\\text{sorted}} \\,]$。\n\n3.  `indptr` 数组存储指向 `indices` 和 `data` 数组中每行数据起始位置的指针。其定义如下：\n    $$ \\text{indptr}[0] = 0 $$\n    $$ \\text{indptr}[i+1] = \\text{indptr}[i] + |C_i| \\quad \\text{for } i = 0, \\dots, n-1 $$\n    非零条目的总数为 $\\text{nnz} = \\text{indptr}[n]$。\n\n4.  `data` 数组将用于存储数值，初始化为一个长度为 $\\text{nnz}$ 的零向量。从稀疏模式中的每对 $(i, j)$ 到 `data` 数组中的特定索引建立一个唯一映射。该映射通过在行 $i$ 的已排序列索引中定位 $j$ 的位置来找到。\n\n#### 步骤 2：证明 CSR 行中无重复列索引\n\n问题要求证明所构建的 CSR 表示在任何行中都没有重复的列索引。\n\n**证明：**\n根据构造方法，对于每一行 $i$，我们首先形成集合 $C_i = \\{ j \\mid (i, j) \\in S \\}$。数学集合的一个基本性质是它不能包含重复的元素。当我们从集合 $C_i$ 创建行 $i$ 的列索引列表时，我们是从一个唯一索引的集合中提取。因此，得到的列表 $C_i^{\\text{sorted}}$ 不含重复项。由于 `indices` 数组中对应于行 $i$ 的段，即 $\\text{indices}[\\text{indptr}[i]:\\text{indptr}[i+1]]$，恰好是 $C_i^{\\text{sorted}}$，因此可以保证其中没有重复的列索引。这对所有行 $i = 0, \\dots, n-1$ 都成立。\n\n#### 步骤 3：用于无竞争并行化的单元着色\n\n为实现无竞争的并行集成，我们将单元集合划分为不同的颜色组。问题将有效着色定义为：任何属于同一颜色组的两个单元都不共享任何全局自由度。形式上，设 $\\mathcal{E}$ 为所有单元的集合，$c(e)$ 为单元 $e$ 的颜色。当且仅当对于任意两个不同的单元 $e_1, e_2 \\in \\mathcal{E}$，以下条件成立时，该着色是有效的：\n$$ c(e_1) = c(e_2) \\implies \\mathcal{D}_{e_1} \\cap \\mathcal{D}_{e_2} = \\emptyset $$\n集成算法通过遍历颜色来进行。对于每种颜色，该颜色的所有单元都可以并行集成。\n\n**无竞争执行的论证：**\n考虑两个线程 $T_1$ 和 $T_2$，它们同时集成两个颜色相同的不同单元 $e_1$ 和 $e_2$。线程 $T_1$ 会将 $K_{e_1}$ 的贡献加到条目 $K_{ij}$ 上，其中 $i, j \\in \\mathcal{D}_{e_1}$。线程 $T_2$ 会将 $K_{e_2}$ 的贡献加到条目 $K_{kl}$ 上，其中 $k, l \\in \\mathcal{D}_{e_2}$。由于着色是有效的，我们知道 $\\mathcal{D}_{e_1} \\cap \\mathcal{D}_{e_2} = \\emptyset$。这意味着线程 $T_1$ 访问的全局行（和列）索引集 $\\mathcal{D}_{e_1}$ 与线程 $T_2$ 访问的索引集 $\\mathcal{D}_{e_2}$ 完全不相交。因此，线程将写入全局 `data` 数组中不相交的条目集合，不会发生竞争条件。这一点由 `race_free` 布尔值进行验证。\n\n#### 步骤 4：对称性保持的证明\n\n问题要求证明，如果所有单元刚度矩阵 $K_e$ 都是对称的，那么最终集成得到的全局矩阵 $K$ 也将是对称的。\n\n**证明：**\n1.  **假设：** 所有单元刚度矩阵都是对称的，即对于每个单元 $e$ 都有 $K_e = K_e^\\top$。\n\n2.  **全局矩阵定义：** 全局刚度矩阵是单元贡献的总和：$K = \\sum_e K^{(e)}$，其中 $K^{(e)} = P_e^\\top K_e P_e$。\n\n3.  **全局矩阵的转置：** 为检查对称性，我们计算 $K$ 的转置：\n    $$ K^\\top = \\left( \\sum_e P_e^\\top K_e P_e \\right)^\\top $$\n    和的转置等于转置的和：\n    $$ K^\\top = \\sum_e (P_e^\\top K_e P_e)^\\top $$\n\n4.  **单元贡献的转置：** 我们对单元贡献项使用属性 $(ABC)^\\top = C^\\top B^\\top A^\\top$：\n    $$ (P_e^\\top K_e P_e)^\\top = (P_e)^\\top (K_e)^\\top (P_e^\\top)^\\top $$\n    转置的转置是原矩阵，所以 $(P_e^\\top)^\\top = P_e$。这得到：\n    $$ (P_e^\\top K_e P_e)^\\top = P_e^\\top K_e^\\top P_e $$\n\n5.  **应用对称性假设：** 我们假设 $K_e$ 是对称的，所以 $K_e^\\top = K_e$。将此代入步骤 4 的方程中：\n    $$ (P_e^\\top K_e P_e)^\\top = P_e^\\top K_e P_e $$\n    这表明每个单元的贡献在映射到全局系统后，其本身也是一个对称矩阵：$(K^{(e)})^\\top = K^{(e)}$。\n\n6.  **结论：** 全局矩阵 $K$ 是对称矩阵（$K^{(e)}$）的和。对称矩阵的和总是一个对称矩阵。因此：\n    $$ K^\\top = \\sum_e (K^{(e)})^\\top = \\sum_e K^{(e)} = K $$\n    这证明了如果所有 $K_e$ 都是对称的，那么集成后的全局矩阵 $K$ 也是对称的。该属性由 `is_symmetric` 布尔值进行验证。\n\n下面的 Python 实现封装了这一逻辑，以对提供的测试套件执行所需的验证。", "answer": "[[true,true,true],[true,true,true],[false,true,true],[true,true,false]]", "id": "3601704"}]}