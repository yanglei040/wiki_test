{"hands_on_practices": [{"introduction": "圣维南原理的核心在于用一个静态等效的载荷系统替换另一个。本练习 [@problem_id:3597318] 旨在训练一项基本技能：如何从一个复杂的分布面力推导出等效的集中力和力偶。这个过程不仅能加深对合力和合力矩的理解，也揭示了决定远场效应的不变量，是应用该原理的数学基础。", "problem": "一个占据区域 $\\Omega \\subset \\mathbb{R}^{3}$ 的有界、均匀、各向同性的线性弹性体，其边界为 $\\Gamma$，外单位法向量为 $\\boldsymbol{n}$。在特征直径为 $a$ 的光滑边界区域 $\\Gamma_{0} \\subset \\Gamma$ 上，施加了两个可选的面力场 $\\boldsymbol{t}_{1}(\\boldsymbol{x})$ 和 $\\boldsymbol{t}_{2}(\\boldsymbol{x})$，而在 $\\Gamma \\setminus \\Gamma_{0}$ 上的其余边界条件是相同的。假设这两个面力场产生相同的合力与关于原点 $\\boldsymbol{O}$ 的相同合力矩，即\n$$\n\\boldsymbol{R} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{t}_{i}(\\boldsymbol{x})\\,\\mathrm{d}S, \n\\qquad\n\\boldsymbol{M} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{x} \\times \\boldsymbol{t}_{i}(\\boldsymbol{x})\\,\\mathrm{d}S,\n\\qquad i \\in \\{1,2\\}.\n$$\n选取一个与 $\\Gamma_{0}$ 相关联的任意参考点 $\\boldsymbol{x}_{c} \\in \\mathbb{R}^{3}$，例如 $\\Gamma_{0}$ 的面积形心。仅使用全局线动量守恒、全局角动量守恒以及 Saint-Venant 原理的内容，构建一个由单个集中力和一个自由力偶组成的静力等效对，两者都作用于 $\\boldsymbol{x}_{c}$，用于远场分析时替代任一一种面力场。您的构建必须使得对于场点 $\\boldsymbol{x}$（其中 $r = |\\boldsymbol{x}-\\boldsymbol{x}_{c}| \\gg a$），弹性场的主导项和次主导项贡献能被此力对所匹配。\n\n推导等效集中力 $\\boldsymbol{F}_{c}$ 和等效力偶 $\\boldsymbol{C}_{c}$ 关于 $\\boldsymbol{R}$、$\\boldsymbol{M}$ 和 $\\boldsymbol{x}_{c}$ 的显式表达式。将最终答案表示为一个包含两个元素的单行矩阵，第一个元素为 $\\boldsymbol{F}_{c}$，第二个元素为 $\\boldsymbol{C}_{c}$。无需进行数值计算，最终表达式中不应包含单位。最终答案必须是单个闭式解析表达式。", "solution": "任务是用一个集中载荷系统替换边界小块区域上的分布式面力场，以再现相同的远场响应。合适的出发点是线动量和角动量的全局守恒定律，以及 Saint-Venant 原理。该原理断言，如果两个不同的载荷系统是静力等效的，那么它们所产生的应力场和位移场之差会随着远离载荷施加区域而迅速衰减。\n\n首先，定义作用于 $\\Gamma_{0}$ 上的面力场 $\\boldsymbol{t}(\\boldsymbol{x})$ 关于原点的全局合力和全局合力矩：\n$$\n\\boldsymbol{R} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}S,\n\\qquad\n\\boldsymbol{M} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{x} \\times \\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}S.\n$$\n这些积分直接源于全局线动量和角动量守恒：边界上的面力传递的总力为 $\\boldsymbol{R}$，关于原点的总力矩为 $\\boldsymbol{M}$。根据假设，$\\boldsymbol{t}_{1}$ 和 $\\boldsymbol{t}_{2}$ 具有相同的 $\\boldsymbol{R}$ 和 $\\boldsymbol{M}$。\n\n对于远场等效性，只需将面力分布的前两个非零矩与一个静力等效的离散系统相匹配即可。这源于 Saint-Venant 原理和弹性场的多极展开观点：在线性弹性力学中，由局部载荷分布产生的远场主导项由净力（单极子）决定，次项由净力矩（偶极子）决定，后者可以表示为一个自由力偶加上力关于所选参考点的力矩。\n\n考虑一个集中力 $\\boldsymbol{F}_{c}$ 和一个自由力偶 $\\boldsymbol{C}_{c}$，两者都作用于所选参考点 $\\boldsymbol{x}_{c}$。此离散系统的总合力为\n$$\n\\boldsymbol{R}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{F}_{c}.\n$$\n此离散系统关于原点的总力矩是集中力关于原点的力矩与所施加力偶之和：\n$$\n\\boldsymbol{M}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{F}_{c} \\;+\\; \\boldsymbol{C}_{c}.\n$$\n为确保与原始面力系统静力等效，我们强制要求\n$$\n\\boldsymbol{R}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{M}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{M}.\n$$\n代入 $\\boldsymbol{R}_{\\mathrm{disc}}$ 和 $\\boldsymbol{M}_{\\mathrm{disc}}$ 的表达式，得到方程\n$$\n\\boldsymbol{F}_{c} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{x}_{c} \\times \\boldsymbol{F}_{c} \\;+\\; \\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M}.\n$$\n使用 $\\boldsymbol{F}_{c}=\\boldsymbol{R}$ 消去 $\\boldsymbol{F}_{c}$，得到所需力偶的显式形式：\n$$\n\\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M} \\;-\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{R}.\n$$\n这个力对匹配了全局合力和全局力矩。根据线性弹性力学背景下的 Saint-Venant 原理，匹配这两个不变量可确保对于距离 $\\boldsymbol{x}_{c}$ 为 $r \\gg a$ 的场点，由原始面力分布和离散载荷系统引起的弹性场之差比保留项衰减得更快，因为面力分布的所有更高阶矩都以 $r$ 的更高次负幂的形式贡献，并在远场近似中被忽略。\n\n因此，要施加于 $\\boldsymbol{x}_{c}$ 的静力等效集中力和力偶为\n$$\n\\boldsymbol{F}_{c} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M} \\;-\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{R},\n$$\n这就完成了构建过程。", "answer": "$$\\boxed{\\begin{pmatrix}\\boldsymbol{R} & \\boldsymbol{M}-\\boldsymbol{x}_{c}\\times\\boldsymbol{R}\\end{pmatrix}}$$", "id": "3597318"}, {"introduction": "现在，我们将圣维南原理应用于一个常见的计算力学场景：有限元分析。本练习 [@problem_id:3597346] 要求对梁模型上的分布载荷采用两种不同但静态等效的施加方法——集总加载与一致加载——并进行比较。计算结果将通过数值方式验证圣维南原理的预测：载荷的局部施加方式对远场响应的影响可以忽略不计。", "problem": "考虑一根长度为 $L$、抗弯刚度为 $EI$ 的等截面欧拉-伯努利梁，两端简支（$w(0)=0$ 且 $w(L)=0$，转角自由），并承受大小为 $q_0$ 的均布横向表面牵引力，该力仅作用于从左端算起的局部区域 $x \\in [0,a]$。使用包含 $N$ 个等长双节点单元的一维有限元离散化方法对梁进行建模。假设每个单元内的横向位移场由三次 Hermite 形函数近似，每个节点的节点自由度为横向位移 $w$ 和转角 $\\theta$。\n\n你的任务是，使用局部牵引荷载在单元层面上的两种不同表示方法，计算并比较跨中横向挠度：\n- 集中节点荷载：将每个部分或完全覆盖单元内的分布牵引力仅转换为竖向节点力，节点弯矩为零。对于仅左端附近被部分覆盖的单元，将该单元的全部局部荷载分配给左侧节点；对于被局部荷载完全覆盖的单元，将单元总荷载在两个节点之间均分。\n- 一致性节点荷载：利用虚功原理，通过对牵引力与单元形函数的乘积在单元覆盖部分上进行积分，来推导单元荷载向量，从而产生与插值相一致的节点力和节点弯矩。\n\n从欧拉-伯努利梁弯曲的运动学和虚功原理出发，执行以下步骤：\n- 推导与双节点三次 Hermite 插值相关联的单元刚度矩阵，用 $EI$ 和单元长度表示。\n- 推导由单元内任意子区间上的均布横向牵引力产生的一致性单元荷载向量，该向量通过单元形函数在该子区间上的积分来表示。不要假定荷载覆盖整个单元；你的推导必须适用于从单元左节点开始的部分覆盖情况。\n- 描述如何遵循上述规则构建集中节点荷载近似，以在忽略节点弯矩的同时保持总力平衡。\n- 为两种荷载表示方法组集全局刚度矩阵和全局荷载向量，施加简支边界条件（$w(0)=0$ 和 $w(L)=0$），并求解每种情况下的节点自由度。\n- 计算每种荷载表示方法下的跨中挠度 $w(L/2)$，并报告它们之间的绝对差值。将挠度差值以米为单位，表示为一个浮点数。\n\n根据圣维南原理（Saint–Venant’s principle）解释结果：解释为什么当局部荷载区域远离跨中时，这两种不同但静力等效的局部荷载表示方法所产生的 $w(L/2)$ 差异往往很小，以及为什么当荷载延伸至整个结构或离散化较粗时，差异可能会更加显著。\n\n必须严格遵守物理单位：$L$ 和 $a$ 的单位为米，$E$ 为帕斯卡，$I$ 为 $\\mathrm{m}^4$，$q_0$ 为 $\\mathrm{N/m}$，转角为弧度，挠度为米。角度应以弧度处理。最终输出必须是跨中挠度的绝对差值，单位为米。\n\n实现一个完整、可运行的程序，对以下参数集测试套件进行这些计算：\n- 情况1（正常情况，局部荷载）：$L=10$，$a=1$，$q_0=1000$，$E=210\\times 10^9$，$I=8\\times 10^{-6}$，$N=20$。\n- 情况2（边界情况，荷载覆盖全梁）：$L=10$，$a=10$，$q_0=1000$，$E=210\\times 10^9$，$I=8\\times 10^{-6}$，$N=20$。\n- 情况3（边缘情况，非常小的局部荷载）：$L=10$，$a=0.2$，$q_0=1000$，$E=210\\times 10^9$，$I=8\\times 10^{-6}$，$N=20$。\n- 情况4（离散化敏感性，粗网格）：$L=10$，$a=1$，$q_0=1000$，$E=210\\times 10^9$，$I=8\\times 10^{-6}$，$N=4$。\n\n你的程序应产生单行输出，包含这些情况下跨中挠度的绝对差值，形式为方括号内以逗号分隔的列表，例如 $\\texttt{[d_1,d_2,d_3,d_4]}$，其中每个 $d_i$ 是一个以米为单位的浮点数。不得打印任何额外文本。", "solution": "该问题要求使用两种不同的有限元荷载模型（集中式和一致性模型）计算和比较简支欧拉-伯努利梁在局部荷载作用下的跨中挠度。此分析将在圣维南原理（Saint-Venant's principle）的背景下进行。该问题是适定的，其科学基础是计算固体力学原理，并为获得唯一解提供了所有必要信息。\n\n### 1. 欧拉-伯努利梁的有限元列式\n\n我们使用 $N$ 个长度为 $h = L/N$ 的双节点有限元对长度为 $L$、抗弯刚度为 $EI$ 的梁进行建模。梁的行为由欧拉-伯努利方程 $EI \\frac{d^4 w}{dx^4} = q(x)$ 控制，其中 $w(x)$ 是横向位移，$q(x)$ 是分布式横向荷载。\n\n#### 运动学和形函数\n在每个单元内，横向位移场 $w(\\xi)$（其中 $\\xi \\in [0, h]$ 是局部坐标）从节点自由度（DOFs）插值得到。对于一个双节点梁单元，自由度是每个节点的位移 $w$ 和转角 $\\theta = dw/d\\xi$。单元的节点位移向量为 $\\mathbf{d}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$。\n\n位移使用三次 Hermite 形函数 $\\mathbf{N}(\\xi) = [N_1(\\xi), N_2(\\xi), N_3(\\xi), N_4(\\xi)]$ 来近似：\n$$w(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}_e$$\n形函数为：\n- $N_1(\\xi) = 1 - 3(\\xi/h)^2 + 2(\\xi/h)^3$\n- $N_2(\\xi) = \\xi - 2\\xi^2/h + \\xi^3/h^2$\n- $N_3(\\xi) = 3(\\xi/h)^2 - 2(\\xi/h)^3$\n- $N_4(\\xi) = -\\xi^2/h + \\xi^3/h^2$\n\n#### 单元刚度矩阵\n单元刚度矩阵 $\\mathbf{k}_e$ 是从梁的应变能 $U_e$ 推导出来的：\n$$U_e = \\frac{1}{2} \\int_0^h EI \\left( \\frac{d^2w}{d\\xi^2} \\right)^2 d\\xi$$\n曲率为 $\\frac{d^2w}{d\\xi^2} = \\frac{d^2\\mathbf{N}}{d\\xi^2} \\mathbf{d}_e = \\mathbf{B}(\\xi) \\mathbf{d}_e$。应变能可以写成 $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\left( EI \\int_0^h \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) d\\xi \\right) \\mathbf{d}_e$。括号中的项就是单元刚度矩阵 $\\mathbf{k}_e$：\n$$\\mathbf{k}_e = EI \\int_0^h \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) d\\xi = \\frac{EI}{h^3} \\begin{bmatrix} 12  & 6h  & -12 & 6h \\\\ 6h  & 4h^2  & -6h & 2h^2 \\\\ -12 & -6h & 12  & -6h \\\\ 6h  & 2h^2  & -6h & 4h^2 \\end{bmatrix}$$\n\n### 2. 单元荷载向量列式\n\n外部荷载是在区域 $[0, a]$ 上的均布牵引力 $q_0$。对于一个起始于全局坐标 $x_e$ 的单元，其局部坐标系 $\\xi$ 中的受载部分为 $[0, s]$，其中 $s = \\max(0, \\min(a, x_e+h) - x_e)$。\n\n#### 一致性荷载向量\n一致性荷载向量 $\\mathbf{f}_{e, \\text{cons}}$ 是根据虚功原理推导的。牵引力 $q_0$ 所做的虚功为 $\\delta W_e = \\int_0^s q_0 \\delta w(\\xi) d\\xi$。由于 $\\delta w(\\xi) = \\mathbf{N}(\\xi) \\delta \\mathbf{d}_e$，我们有 $\\delta W_e = \\delta \\mathbf{d}_e^T \\left( \\int_0^s q_0 \\mathbf{N}(\\xi)^T d\\xi \\right)$。\n因此，一致性荷载向量为：\n$$\\mathbf{f}_{e, \\text{cons}} = q_0 \\int_0^s \\mathbf{N}(\\xi)^T d\\xi$$\n每个分量是相应形函数在受载长度 $s$ 上的积分：\n- $f_1 = q_0 \\int_0^s N_1(\\xi) d\\xi = q_0 \\left[s - \\frac{s^3}{h^2} + \\frac{s^4}{2h^3}\\right]$\n- $f_2 = q_0 \\int_0^s N_2(\\xi) d\\xi = q_0 \\left[\\frac{s^2}{2} - \\frac{2s^3}{3h} + \\frac{s^4}{4h^2}\\right]$\n- $f_3 = q_0 \\int_0^s N_3(\\xi) d\\xi = q_0 \\left[\\frac{s^3}{h^2} - \\frac{s^4}{2h^3}\\right]$\n- $f_4 = q_0 \\int_0^s N_4(\\xi) d\\xi = q_0 \\left[-\\frac{s^3}{3h} + \\frac{s^4}{4h^2}\\right]$\n该列式生成了与假定的三次位移场在能量上一致的节点力和弯矩。对于一个完全受载的单元（$s=h$），这将得到经典的荷载向量 $\\mathbf{f}_{e, \\text{cons}} = q_0 [h/2, h^2/12, h/2, -h^2/12]^T$。\n\n#### 集中荷载向量\n集中荷载向量 $\\mathbf{f}_{e, \\text{lump}}$ 是一个简化模型，它保持了单元上的总力，但忽略了节点弯矩。单元上的总力为 $F_{\\text{total}} = q_0 s$。指定的规则如下：\n- 如果单元被完全覆盖（$s=h$），荷载将被均分：$\\mathbf{f}_{e, \\text{lump}} = [q_0 h/2, 0, q_0 h/2, 0]^T$。\n- 如果单元从左侧被部分覆盖（$0  s  h$），全部荷载都分配给左节点：$\\mathbf{f}_{e, \\text{lump}} = [q_0 s, 0, 0, 0]^T$。\n该模型在合力方面与分布荷载静力等效，但在合力矩方面则不等效。\n\n### 3. 全局系统与求解\n\n单元刚度矩阵和荷载向量被组集为全局方程组 $\\mathbf{K} \\mathbf{D} = \\mathbf{F}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{D}$ 是全局节点自由度向量，$\\mathbf{F}$ 是全局荷载向量（$\\mathbf{F}_{\\text{cons}}$ 或 $\\mathbf{F}_{\\text{lump}}$）。\n\n施加简支边界条件 $w(0)=0$ 和 $w(L)=0$。这对应于将第一个节点（索引0）和最后一个节点（索引 $N$）的位移自由度约束为零。两端的转动自由度保持自由。施加这些约束后，求解两个线性系统 $\\mathbf{K} \\mathbf{D}_{\\text{cons}} = \\mathbf{F}_{\\text{cons}}$ 和 $\\mathbf{K} \\mathbf{D}_{\\text{lump}} = \\mathbf{F}_{\\text{lump}}$，以找到每种荷载模型下的节点位移和转角。\n\n### 4. 跨中挠度与解释\n\n然后计算跨中挠度 $w(L/2)$。对于所提供的测试用例，$N$ 总是偶数，这意味着跨中 $x=L/2$ 与节点 $N/2$ 重合。因此，挠度直接由全局解向量中的节点位移值 $D[2 \\times (N/2)] = D[N]$ 给出。绝对差值 $|w_{\\text{cons}}(L/2) - w_{\\text{lump}}(L/2)|$ 量化了模型之间的差异。\n\n这种差异可以用圣维南原理（Saint-Venant's principle）来解释，该原理指出，静力等效荷载的影响是局部的。在远离荷载作用区域的地方，结构响应（应力、应变、位移）仅取决于荷载的净合力（总力和力矩），而不取决于其详细分布。\n\n- **情况1和3（局部荷载）：** 荷载区域很小，位于梁的一端，远离跨中。圣维南原理预测，跨中挠度应该对集中模型和一致性模型之间的局部差异不敏感。梁结构有效地“平滑掉”了这些差异。因此，预计挠度的绝对差值会很小。\n\n- **情况2（全局荷载）：** 荷载覆盖整个梁（$a=L$）。荷载不是局部的，因此没有“远场”区域。圣维南原理的先验假设不成立。两种荷载模型之间的差异作用于整个结构。一致性模型正确地捕捉了每个单元上分布荷载产生的功共轭力矩，而集中模型则忽略了它们。这种根本性的建模差异预计将在包括跨中在内的全局位移场中产生明显的差异。\n\n- **情况4（粗糙离散化）：** 粗网格（$N=4$）意味着每个单元都很大（$h=L/4=2.5$ m）。与细网格相比，将荷载集中在节点上的集中模型成为对分布荷载的更粗糙的近似。每个点荷载的“近场”更大，结构在粗单元尺度上的平滑效应较差。集中模型中增加的这种近似误差预计将导致与对应的细网格情况（情况1）相比产生更大的差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the beam problem for all test cases and print the results.\n    \"\"\"\n\n    def get_element_stiffness(EI, h):\n        \"\"\"Returns the 4x4 element stiffness matrix for an Euler-Bernoulli beam.\"\"\"\n        return (EI / h**3) * np.array([\n            [12, 6 * h, -12, 6 * h],\n            [6 * h, 4 * h**2, -6 * h, 2 * h**2],\n            [-12, -6 * h, 12, -6 * h],\n            [6 * h, 2 * h**2, -6 * h, 4 * h**2]\n        ])\n\n    def get_consistent_load_vector(q0, s, h):\n        \"\"\"Calculates the consistent load vector for a load over [0, s] in local coords.\"\"\"\n        if s = 1e-12: # Tolerance for zero length\n            return np.zeros(4)\n        \n        # Indefinite integrals of shape functions, evaluated at s.\n        f = np.zeros(4)\n        f[0] = s - s**3/h**2 + s**4/(2*h**3)\n        f[1] = s**2/2 - 2*s**3/(3*h) + s**4/(4*h**2)\n        f[2] = s**3/h**2 - s**4/(2*h**3)\n        f[3] = -s**3/(3*h) + s**4/(4*h**2)\n        \n        return q0 * f\n\n    def get_lumped_load_vector(q0, s, h):\n        \"\"\"Calculates the lumped load vector for a load over [0, s] in local coords.\"\"\"\n        if s = 1e-12: # Tolerance for zero length\n            return np.zeros(4)\n        \n        total_force = q0 * s\n        f_lump = np.zeros(4)\n        \n        # Using a small tolerance for floating point comparison of s and h\n        if np.isclose(s, h):  # Fully loaded element\n            f_lump[0] = total_force / 2\n            f_lump[2] = total_force / 2\n        else:  # Partially loaded element from the left\n            f_lump[0] = total_force\n            \n        return f_lump\n    \n    def shape_functions(xi, h):\n        \"\"\"Calculates cubic Hermite shape functions at a given local coordinate xi.\"\"\"\n        N = np.zeros(4)\n        N[0] = 1 - 3*(xi/h)**2 + 2*(xi/h)**3\n        N[1] = xi - 2*xi**2/h + xi**3/h**2\n        N[2] = 3*(xi/h)**2 - 2*(xi/h)**3\n        N[3] = -xi**2/h + xi**3/h**2\n        return N\n\n    def solve_beam_case(L, a, q0, E, I, N):\n        \"\"\"Solves a single instance of the beam problem.\"\"\"\n        h = L / N\n        EI = E * I\n        num_dofs = 2 * (N + 1)\n        \n        K = np.zeros((num_dofs, num_dofs))\n        F_cons = np.zeros(num_dofs)\n        F_lump = np.zeros(num_dofs)\n        \n        k_e = get_element_stiffness(EI, h)\n        \n        for e in range(N):\n            x_e = e * h\n            # Calculate the length of the loaded portion 's' for the current element\n            s = max(0, min(a, x_e + h) - x_e)\n            \n            if s > 0:\n                f_e_cons = get_consistent_load_vector(q0, s, h)\n                f_e_lump = get_lumped_load_vector(q0, s, h)\n                \n                # Assemble load vectors\n                dof_map = np.array([2*e, 2*e + 1, 2*(e+1), 2*(e+1) + 1])\n                F_cons[dof_map] += f_e_cons\n                F_lump[dof_map] += f_e_lump\n\n            # Assemble stiffness matrix\n            dof_map = np.array([2*e, 2*e+1, 2*(e+1), 2*(e+1)+1])\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n        # Apply boundary conditions w(0)=0 and w(L)=0 using the penalty method\n        K_mod = K.copy()\n        # A large number relative to stiffness matrix diagonal values\n        penalty = 1e12 * np.max(np.diag(K)) if N > 0 else 1e12\n        \n        # DOF for w(0) is 0\n        K_mod[0, 0] += penalty\n        # DOF for w(L) is 2*N\n        K_mod[2*N, 2*N] += penalty\n        \n        # Solve for nodal displacements for both loading cases\n        D_cons = np.linalg.solve(K_mod, F_cons)\n        D_lump = np.linalg.solve(K_mod, F_lump)\n        \n        w_mid_cons = 0.0\n        w_mid_lump = 0.0\n        \n        if N % 2 == 0:  # N is even, midspan L/2 is at node N/2\n            midspan_dof_idx = N\n            w_mid_cons = D_cons[midspan_dof_idx]\n            w_mid_lump = D_lump[midspan_dof_idx]\n        else:  # N is odd, midspan is inside an element\n            e_mid = int(L/2 / h)\n            x_e_mid = e_mid * h\n            xi = L/2 - x_e_mid\n            \n            N_mid = shape_functions(xi, h)\n            dof_map_mid = np.array([2*e_mid, 2*e_mid+1, 2*(e_mid+1), 2*(e_mid+1)+1])\n            \n            d_cons_local = D_cons[dof_map_mid]\n            d_lump_local = D_lump[dof_map_mid]\n            \n            w_mid_cons = N_mid.dot(d_cons_local)\n            w_mid_lump = N_mid.dot(d_lump_local)\n            \n        return abs(w_mid_cons - w_mid_lump)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, a, q0, E, I, N)\n        (10.0, 1.0, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 10.0, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 0.2, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 1.0, 1000.0, 210e9, 8e-6, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        difference = solve_beam_case(*case)\n        results.append(difference)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3597346"}, {"introduction": "为了更深入地探索圣维南原理，我们将其应用扩展到更复杂的各向异性材料中。本练习 [@problem_id:3597322] 旨在研究材料的各向异性如何影响应力场的衰减特性。通过分析等效载荷系统所产生的应力差场在不同方向上的衰减规律，您将能更深刻地理解圣维南效应不仅是几何现象，其衰减速率也受到材料本构性质的调控。", "problem": "考虑一个均匀、线弹性、正交各向异性固体的二维反平面剪切模型。令 $w(x,y)$ 表示平面外位移。在没有体力的情况下，平衡方程由各向异性剪切刚度的散度控制，当存在局部载荷时，可写为 $C_x \\frac{\\partial^2 w}{\\partial x^2} + C_y \\frac{\\partial^2 w}{\\partial y^2} = -q(x,y)$，其中 $C_x0$ 和 $C_y0$ 是沿 $x$ 和 $y$ 方向的恒定有效刚度，而 $q(x,y)$ 是一个在原点附近局部化的载荷分布。这个标量各向异性反平面模型是一个标准替代模型，用于从第一性原理出发，推导正交各向异性介质的 Saint-Venant 原理。当两种载荷产生相同的合力以及关于原点的相同一阶矩时，称这两种载荷是等效的。\n\n您的任务是利用这些基础知识，分析、计算并验证在强各向异性材料中两种等效载荷之间远场差异的方向性衰减，将观测到的衰减率与控制平衡方程所隐含的各向异性格林函数对应起来，并数值验证 Saint-Venant 原理在方向上成立。请按以下步骤进行。\n\n1. 从平衡方程 $C_x \\frac{\\partial^2 w}{\\partial x^2} + C_y \\frac{\\partial^2 w}{\\partial y^2} = -q(x,y)$ 出发，推导位于原点的单位点源的各向异性格林函数 $G(x,y)$，并用一个坐标缩放所定义的各向异性“椭圆半径”来表示 $G$。该坐标缩放可将算子简化为各向同性拉普拉斯算子。解释为什么对于合力和一阶矩净差异为零的两种等效载荷，其远场差异 $w_{\\Delta}(x,y)$ 的衰减速度比单个点源产生的场更快，并确定主导此衰减的多极阶。\n\n2. 考虑两种载荷：\n   - 载荷 A：位于原点、强度为 $Q$ 的单个点源，$q_A(x,y) = Q\\,\\delta(x)\\delta(y)$。\n   - 载荷 B：两个点源，每个强度为 $Q/2$，分别位于 $(x,y)=(a,0)$ 和 $(x,y)=(-a,0)$，$q_B(x,y) = \\frac{Q}{2}\\,\\delta(x-a)\\delta(y) + \\frac{Q}{2}\\,\\delta(x+a)\\delta(y)$。\n   这些载荷关于原点的合力和一阶矩是等效的。令 $w_A$ 和 $w_B$ 为相应的位移。定义差异场 $w_{\\Delta}(x,y) = w_B(x,y) - w_A(x,y)$，并确定当 $r \\to \\infty$ 时，沿固定角度射线其主导阶远场渐近方向性衰减。此处 $r$ 是欧几里得距离，角度以弧度为单位。证明 $w_{\\Delta}$ 的主导衰减由一个四极矩项控制，该项通过椭圆度量依赖于各向异性，并使用缩放坐标系中的角度来表达其方向依赖性。\n\n3. 实现一个程序，通过叠加所推导的各向异性格林函数，数值计算上述载荷的 $w_{\\Delta}(x,y)$。沿着每个指定的方向射线 $\\varphi$（在物理坐标中从 $x$ 轴测量的角度，以弧度为单位），在 $r_{\\min}$ 和 $r_{\\max}$ 之间采样半径 $r$，并：\n   - 通过在远场子集上拟合 $\\log|w_{\\Delta}(r,\\varphi)|$ 与 $\\log r$ 的关系并提取斜率，来估计衰减指数。\n   - 通过将在最大半径 $r$ 处的数值观测值 $w_{\\Delta}(r,\\varphi)\\,r^2$ 与您根据各向异性和方向推导出的解析主导阶振幅进行比较，来计算远场振幅一致性。将一致性量化为一个比率，并检查其是否在指定容差内接近于 $1$。\n\n4. 使用以下参数值的测试套件来评估在不同情况下的行为，包括各向同性、强各向异性和极端各向异性。所有空间量均应解释为米，刚度单位应保持一致，角度以弧度为单位。输出为无量纲。设 $r_{\\min} = 10\\,a$ 和 $r_{\\max} = 100\\,a$，每条射线采用对数间隔采样 50 个点，并对样本的远场一半使用线性回归进行斜率估计。对于每个方向和测试用例，产生两个输出：一个等于估计衰减斜率的浮点数，紧随其后的是一个布尔值。当且仅当斜率与理论值的误差在 $\\pm 0.05$ 容差范围内，并且在 $r_{\\max}$ 处的振幅比与 1 的误差在 $\\pm 0.05$ 容差范围内时，该布尔值为真。\n   - 情况1（各向同性，基准）：$C_x = 1.0$, $C_y = 1.0$, $a = 0.1$, $Q = 1.0$，方向 $\\varphi \\in \\{0.0,\\pi/3,\\pi/2\\}$。\n   - 情况2（强各向异性）：$C_x = 100.0$, $C_y = 1.0$, $a = 0.1$, $Q = 1.0$，方向 $\\varphi \\in \\{0.0,\\pi/6,\\pi/2\\}$。\n   - 情况3（极端各向异性）：$C_x = 1000.0$, $C_y = 1.0$, $a = 0.1$, $Q = 1.0$，方向 $\\varphi \\in \\{0.0,0.08726646259971647,1.4835298641951802\\}$，分别对应 $5^\\circ$ 和 $85^\\circ$ 的弧度值。\n\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按照上述顺序，为每个情况中的每个方向包含估计的斜率（浮点数），并紧随其后的是布尔验证结果（如果斜率和振幅检查都通过则为真，否则为假）。例如，一个包含 $9$ 个方向检查的输出看起来像 $[s_1,b_1,s_2,b_2,\\dots,s_9,b_9]$。\n\n请遵守以下要求：\n- 所有角度必须以弧度表示和使用。\n- 如果检查需要容差，则斜率容差和振幅比容差均使用 $0.05$。\n- 程序必须是自包含的，并且不需要用户输入。", "solution": "该问题被评估为有效，因为它在科学上基于线弹性和计算力学的原理，其问题陈述清晰客观，并且包含一套完整且一致的数据和约束。该问题提出了一个标准但并非微不足道的练习，要求将基本概念（格林函数、多极展开、Saint-Venant 原理）应用于特定的物理模型（各向异性反平面剪切），并对结果进行数值验证。\n\n### 第1部分：各向异性格林函数与远场衰减\n\n在反平面剪切下，均匀、线弹性、正交各向异性固体中平面外位移 $w(x,y)$ 的控制平衡方程为：\n$$\nC_x \\frac{\\partial^2 w}{\\partial x^2} + C_y \\frac{\\partial^2 w}{\\partial y^2} = -q(x,y)\n$$\n其中 $C_x  0$ 和 $C_y  0$ 是有效剪切刚度，$q(x,y)$ 是分布载荷。\n\n格林函数 $G(x,y)$ 是原点处单位点源的解，即 $q(x,y) = \\delta(x)\\delta(y)$。它满足以下方程：\n$$\nC_x \\frac{\\partial^2 G}{\\partial x^2} + C_y \\frac{\\partial^2 G}{\\partial y^2} = -\\delta(x)\\delta(y)\n$$\n为了求解此方程，我们引入坐标缩放，将各向异性算子转换为标准的各向同性拉普拉斯算子。令缩放坐标 $(\\tilde{x}, \\tilde{y})$ 定义为：\n$$\n\\tilde{x} = \\frac{x}{\\sqrt{C_x}}, \\quad \\tilde{y} = \\frac{y}{\\sqrt{C_y}}\n$$\n根据链式法则，偏导数变换为 $\\frac{\\partial^2}{\\partial x^2} = \\frac{1}{C_x}\\frac{\\partial^2}{\\partial \\tilde{x}^2}$ 和 $\\frac{\\partial^2}{\\partial y^2} = \\frac{1}{C_y}\\frac{\\partial^2}{\\partial \\tilde{y}^2}$。Dirac delta 函数的变换依据 $\\delta(ax) = \\frac{1}{|a|}\\delta(x)$，因此 $\\delta(x)\\delta(y) = \\delta(\\sqrt{C_x}\\tilde{x})\\delta(\\sqrt{C_y}\\tilde{y}) = \\frac{1}{\\sqrt{C_x C_y}}\\delta(\\tilde{x})\\delta(\\tilde{y})$。\n\n将这些代入格林函数方程，得到：\n$$\nC_x \\left(\\frac{1}{C_x}\\frac{\\partial^2 G}{\\partial \\tilde{x}^2}\\right) + C_y \\left(\\frac{1}{C_y}\\frac{\\partial^2 G}{\\partial \\tilde{y}^2}\\right) = -\\frac{1}{\\sqrt{C_x C_y}}\\delta(\\tilde{x})\\delta(\\tilde{y})\n$$\n$$\n\\frac{\\partial^2 G}{\\partial \\tilde{x}^2} + \\frac{\\partial^2 G}{\\partial \\tilde{y}^2} \\equiv \\tilde{\\nabla}^2 G = -\\frac{1}{\\sqrt{C_x C_y}}\\delta(\\tilde{x})\\delta(\\tilde{y})\n$$\n这是二维各向同性拉普拉斯算子 $\\tilde{\\nabla}^2$ 的泊松方程。$\\tilde{\\nabla}^2 G_{iso} = -\\delta(\\tilde{x})\\delta(\\tilde{y})$ 的基本解是 $G_{iso}(\\tilde{x},\\tilde{y}) = -\\frac{1}{2\\pi}\\ln(\\tilde{r})$，其中 $\\tilde{r} = \\sqrt{\\tilde{x}^2 + \\tilde{y}^2}$ 是缩放坐标系中的径向距离。根据线性关系，$G$ 的解为：\n$$\nG(\\tilde{x}, \\tilde{y}) = \\frac{1}{\\sqrt{C_x C_y}} G_{iso}(\\tilde{x},\\tilde{y}) = -\\frac{1}{2\\pi\\sqrt{C_x C_y}} \\ln(\\tilde{r})\n$$\n变换回物理坐标 $(x,y)$，我们得到各向异性格林函数：\n$$\nG(x,y) = -\\frac{1}{2\\pi\\sqrt{C_x C_y}} \\ln\\left(\\sqrt{\\frac{x^2}{C_x} + \\frac{y^2}{C_y}}\\right) = -\\frac{1}{4\\pi\\sqrt{C_x C_y}} \\ln\\left(\\frac{x^2}{C_x} + \\frac{y^2}{C_y}\\right)\n$$\n量 $R_{ellip} = \\sqrt{x^2/C_x + y^2/C_y}$ 即为问题中提到的各向异性“椭圆半径”。\n\n对于两种等效载荷 $q_1$ 和 $q_2$，它们的差值 $q_{\\Delta} = q_2 - q_1$ 的净合力为零，关于原点的净一阶矩也为零。由 $q_\\Delta$ 引起的位移场 $w_\\Delta$ 通过与格林函数的卷积求得，$w_\\Delta(\\mathbf{x}) = \\int G(\\mathbf{x}-\\mathbf{x'}) q_\\Delta(\\mathbf{x'}) d\\mathbf{x'}$。对于远场点 $\\mathbf{x}$（即 $|\\mathbf{x}| \\gg |\\mathbf{x'}|$），我们可以对格林函数进行泰勒展开：\n$$\nG(\\mathbf{x}-\\mathbf{x'}) \\approx G(\\mathbf{x}) - \\mathbf{x'} \\cdot \\nabla G(\\mathbf{x}) + \\frac{1}{2} (\\mathbf{x'} \\cdot \\nabla)^2 G(\\mathbf{x}) + \\dots\n$$\n逐项积分得到位移场的多极展开：\n$$\nw_\\Delta(\\mathbf{x}) \\approx G(\\mathbf{x})\\int q_\\Delta d\\mathbf{x'} - \\nabla G(\\mathbf{x}) \\cdot \\int \\mathbf{x'} q_\\Delta d\\mathbf{x'} + \\frac{1}{2}\\sum_{i,j} \\frac{\\partial^2 G(\\mathbf{x})}{\\partial x_i \\partial x_j} \\int x'_i x'_j q_\\Delta d\\mathbf{x'} + \\dots\n$$\n第一个积分是总力（单极矩），第二个是一阶矩（偶极矩矢量）。由于载荷是等效的， $q_\\Delta$ 的这两个矩都为零。因此，单极项和偶极项消失。远场位移的主导阶贡献来自四极矩张量，其分量为 $Q_{ij} = \\int x'_i x'_j q_\\Delta d\\mathbf{x'}$。格林函数 $G(x,y)$ 对数衰减，约为 $\\sim\\ln r$。它的一阶导数（偶极场）衰减为 $\\sim 1/r$，其二阶导数（四极场）衰减为 $\\sim 1/r^2$。因此，差异场 $w_\\Delta$ 按 $O(r^{-2})$ 衰减，比单个点源产生的场衰减得更快，这证明了 Saint-Venant 原理。主导的多极阶是四极阶。\n\n### 第2部分：特定载荷的渐近衰减\n\n给定：\n- 载荷 A: $q_A(x,y) = Q\\,\\delta(x)\\delta(y)$\n- 载荷 B: $q_B(x,y) = \\frac{Q}{2}\\,\\delta(x-a)\\delta(y) + \\frac{Q}{2}\\,\\delta(x+a)\\delta(y)$\n差异载荷为 $q_\\Delta = q_B - q_A$。让我们计算其四极矩：\n$$\nQ_{xx} = \\int x^2 q_\\Delta(x,y) dx dy = \\frac{Q}{2}(a)^2 + \\frac{Q}{2}(-a)^2 - Q(0)^2 = Qa^2\n$$\n$$\nQ_{xy} = \\int xy q_\\Delta(x,y) dx dy = 0\n$$\n$$\nQ_{yy} = \\int y^2 q_\\Delta(x,y) dx dy = 0\n$$\n远场位移差由 $Q_{xx}$ 分量主导：\n$$\nw_\\Delta(x,y) \\approx \\frac{1}{2} Q_{xx} \\frac{\\partial^2 G}{\\partial x^2}(x,y) = \\frac{Qa^2}{2} \\frac{\\partial^2 G}{\\partial x^2}(x,y)\n$$\n我们计算 $G$ 的二阶偏导数：\n$$\n\\frac{\\partial G}{\\partial x} = -\\frac{1}{2\\pi\\sqrt{C_x C_y}} \\frac{x/C_x}{(x^2/C_x + y^2/C_y)}\n$$\n$$\n\\frac{\\partial^2 G}{\\partial x^2} = -\\frac{1}{2\\pi C_x \\sqrt{C_x C_y}} \\frac{(x^2/C_x + y^2/C_y) - x(2x/C_x)}{(x^2/C_x + y^2/C_y)^2} = \\frac{1}{2\\pi C_x \\sqrt{C_x C_y}} \\frac{x^2/C_x - y^2/C_y}{(x^2/C_x + y^2/C_y)^2}\n$$\n将此代入 $w_\\Delta$ 的表达式：\n$$\nw_\\Delta(x,y) \\approx \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{x^2/C_x - y^2/C_y}{(x^2/C_x + y^2/C_y)^2}\n$$\n为了分析方向依赖性，我们使用物理极坐标 $(r, \\varphi)$，其中 $x=r\\cos\\varphi, y=r\\sin\\varphi$。衰减显然是 $O(r^{-2})$，因此 $\\log|w_\\Delta|$ 相对于 $\\log r$ 的理论斜率为 -2。\n主导阶振幅系数为 $A_{th}(\\varphi) = w_\\Delta(r,\\varphi) r^2$：\n$$\nA_{th}(\\varphi) = \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{r^2(\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y)}{[r^2(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)]^2} = \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)^2}\n$$\n这个表达式显示了通过 $C_x$ 和 $C_y$ 对各向异性的依赖性，以及通过 $\\varphi$ 对方向的依赖性。为了用缩放坐标系中的角度 $\\tilde{\\varphi}$ 来表示这一点，我们注意到 $\\tilde{x} = \\tilde{r}\\cos\\tilde{\\varphi}$ 和 $\\tilde{y} = \\tilde{r}\\sin\\tilde{\\varphi}$。我们有 $\\cos^2\\tilde{\\varphi} = \\frac{\\tilde{x}^2}{\\tilde{r}^2} = \\frac{x^2/C_x}{x^2/C_x+y^2/C_y}$ 和 $\\sin^2\\tilde{\\varphi} = \\frac{y^2/C_y}{x^2/C_x+y^2/C_y}$。振幅的方向部分可以写成：\n$$\n\\frac{\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)^2} = \\frac{\\cos^2\\tilde{\\varphi} - \\sin^2\\tilde{\\varphi}}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)} = \\frac{\\cos(2\\tilde{\\varphi})}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)}\n$$\n其中 $\\tilde{\\varphi} = \\operatorname{atan2}(\\tilde{y}, \\tilde{x}) = \\operatorname{atan2}(y/\\sqrt{C_y}, x/\\sqrt{C_x})$。\n\n### 第3部分：数值实现与验证\n\n数值部分涉及直接通过格林函数的叠加来计算 $w_\\Delta(x,y)$，并将其远场行为与推导出的渐近公式进行比较。\n精确的位移差为：\n$$\nw_\\Delta(x,y) = w_B(x,y) - w_A(x,y) = \\frac{Q}{2}[G(x-a, y) + G(x+a, y)] - QG(x,y)\n$$\n代入 $G$ 的表达式并利用对数性质，我们得到用于计算的形式：\n$$\nw_\\Delta(x,y) = -\\frac{Q}{8\\pi\\sqrt{C_x C_y}} \\ln\\left[ \\frac{\\left(\\frac{(x-a)^2}{C_x} + \\frac{y^2}{C_y}\\right)\\left(\\frac{(x+a)^2}{C_x} + \\frac{y^2}{C_y}\\right)}{\\left(\\frac{x^2}{C_x} + \\frac{y^2}{C_y}\\right)^2} \\right]\n$$\n对于每个测试用例和方向 $\\varphi$，步骤如下：\n1.  为半径 $r$ 生成 50 个点，这些点在 $r_{\\min}=10a$ 和 $r_{\\max}=100a$ 之间呈对数间隔分布。\n2.  对于每个 $r$，计算笛卡尔坐标 $(x,y)=(r\\cos\\varphi, r\\sin\\varphi)$ 并使用上述公式评估 $w_\\Delta(x,y)$。\n3.  取数据的远场子集，即最后的 $N/2 = 25$ 个点。\n4.  对此子集上的 $\\log|w_\\Delta|$ 与 $\\log r$ 进行线性回归。拟合的斜率即为估计的衰减指数。\n5.  验证斜率：检查其与理论值 -2 的误差是否在 $\\pm 0.05$ 范围内。\n6.  计算最大半径处的数值振幅：$A_{num} = |w_\\Delta(r_{\\max}, \\varphi)| \\cdot r_{\\max}^2$。\n7.  使用推导的公式计算理论振幅 $A_{th}(\\varphi)$：\n    $$\n    A_{th}(\\varphi) = \\left| \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)^2} \\right|\n    $$\n8.  验证振幅：计算比率 $A_{num}/A_{th}$ 并检查其与 1 的误差是否在 $\\pm 0.05$ 范围内。\n9.  该方向的最终布尔结果为 `True`，当且仅当斜率和振幅验证都通过时。\n\n此过程将在提供的 Python 脚本中自动化。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes and verifies the directional decay of far-field displacement differences\n    between two equivalent loadings in an anisotropic elastic solid.\n    \"\"\"\n    \n    test_suite = [\n        {\n            \"case_name\": \"Isotropy\",\n            \"params\": {\"Cx\": 1.0, \"Cy\": 1.0, \"a\": 0.1, \"Q\": 1.0},\n            \"directions_rad\": [0.0, np.pi/3, np.pi/2],\n        },\n        {\n            \"case_name\": \"Strong Anisotropy\",\n            \"params\": {\"Cx\": 100.0, \"Cy\": 1.0, \"a\": 0.1, \"Q\": 1.0},\n            \"directions_rad\": [0.0, np.pi/6, np.pi/2],\n        },\n        {\n            \"case_name\": \"Extreme Anisotropy\",\n            \"params\": {\"Cx\": 1000.0, \"Cy\": 1.0, \"a\": 0.1, \"Q\": 1.0},\n            \"directions_rad\": [0.0, 0.08726646259971647, 1.4835298641951802], # 0, 5, 85 degrees\n        },\n    ]\n\n    r_min_factor = 10.0\n    r_max_factor = 100.0\n    num_points = 50\n    slope_tolerance = 0.05\n    amplitude_tolerance = 0.05\n    theoretical_slope = -2.0\n\n    all_results = []\n\n    for case in test_suite:\n        params = case[\"params\"]\n        Cx, Cy, a, Q = params[\"Cx\"], params[\"Cy\"], params[\"a\"], params[\"Q\"]\n        \n        r_min = r_min_factor * a\n        r_max = r_max_factor * a\n        \n        radii = np.logspace(np.log10(r_min), np.log10(r_max), num_points)\n        log_radii = np.log(radii)\n\n        for phi in case[\"directions_rad\"]:\n            # --- 1. Compute numerical w_delta ---\n            x = radii * np.cos(phi)\n            y = radii * np.sin(phi)\n\n            # Argument for the logarithm in the w_delta formula\n            term_xa_sq = (x - a)**2 / Cx + y**2 / Cy\n            term_xpa_sq = (x + a)**2 / Cx + y**2 / Cy\n            term_x_sq = x**2 / Cx + y**2 / Cy\n            \n            # To avoid log(0) or issues at the origin if calculated there\n            # We filter for valid terms, which is always true for r > 0\n            valid_mask = (term_xa_sq > 0)  (term_xpa_sq > 0)  (term_x_sq > 0)\n            \n            w_delta_vals = np.zeros_like(radii)\n            if np.any(valid_mask):\n                log_arg = (term_xa_sq[valid_mask] * term_xpa_sq[valid_mask]) / (term_x_sq[valid_mask]**2)\n                \n                prefactor = -Q / (8.0 * np.pi * np.sqrt(Cx * Cy))\n                w_delta_vals[valid_mask] = prefactor * np.log(log_arg)\n\n            # --- 2. Estimate decay slope ---\n            far_field_start_index = num_points // 2\n            \n            log_w_delta_abs = np.log(np.abs(w_delta_vals[far_field_start_index:]))\n            log_radii_far_field = log_radii[far_field_start_index:]\n            \n            regression_result = linregress(log_radii_far_field, log_w_delta_abs)\n            estimated_slope = regression_result.slope\n\n            # --- 3. Check amplitude consistency ---\n            # Numerical amplitude at r_max\n            A_num = np.abs(w_delta_vals[-1]) * radii[-1]**2\n\n            # Theoretical amplitude\n            cos_phi_sq = np.cos(phi)**2\n            sin_phi_sq = np.sin(phi)**2\n            \n            term_cos = cos_phi_sq / Cx\n            term_sin = sin_phi_sq / Cy\n            \n            amp_num_term = np.abs(term_cos - term_sin)\n            amp_den_term = (term_cos + term_sin)**2\n            \n            # Handle cases where denominator is zero (not expected for given inputs)\n            if amp_den_term == 0:\n                amplitude_ratio = np.inf\n            else:\n                A_th_prefactor = (Q * a**2) / (4 * np.pi * Cx * np.sqrt(Cx * Cy))\n                A_th = A_th_prefactor * amp_num_term / amp_den_term\n                \n                if A_th == 0:\n                  # If theory predicts zero amp, and numerical is small, ratio is ill-defined but consistent\n                  amplitude_ratio = 1.0 if np.isclose(A_num, 0) else np.inf\n                else:\n                  amplitude_ratio = A_num / A_th\n\n            # --- 4. Perform verification checks ---\n            slope_check = np.abs(estimated_slope - theoretical_slope) = slope_tolerance\n            amplitude_check = np.abs(amplitude_ratio - 1.0) = amplitude_tolerance\n            verification_passed = slope_check and amplitude_check\n            \n            all_results.append(f\"{estimated_slope:.8f}\")\n            all_results.append(str(verification_passed).lower())\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3597322"}]}