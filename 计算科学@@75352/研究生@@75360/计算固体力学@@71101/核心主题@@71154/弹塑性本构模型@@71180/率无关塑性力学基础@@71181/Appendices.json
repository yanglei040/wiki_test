{"hands_on_practices": [{"introduction": "本实践将指导您为最常见且基础的塑性模型——具有线性各向同性硬化的 $J_2$ 塑性模型——实现核心的返回映射算法。这个练习是计算塑性力学领域的基石，通过从基本原理出发，您将构建一个功能完整的算法，并在一系列精心设计的加载路径下验证其正确性。完成此练习将使您对弹塑性本构积分的预测-校正结构有深刻的理解，并掌握如何通过检验塑性不可压缩性和耗散不等式等基本物理原则来确保代码的可靠性 [@problem_id:3593035]。", "problem": "考虑一个由偏应力第二不变量（通常称为 $J_2$ 塑性）和线性各向同性硬化控制的小应变、率无关、各向同性弹塑性材料。其弹性响应由各向同性线弹性张量定义，其中拉梅参数 $ \\lambda $ 和 $ \\mu $ 通过杨氏模量 $ E $ 和泊松比 $ \\nu $ 给出，关系为 $ \\mu = \\dfrac{E}{2(1+\\nu)} $ 和 $ \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2 \\nu)} $。材料行为通过应变加和分解 $ \\varepsilon = \\varepsilon^e + \\varepsilon^p $ 表示，其中 $ \\varepsilon $ 是总小应变张量，$ \\varepsilon^e $ 是弹性应变张量，$ \\varepsilon^p $ 是塑性应变张量。柯西应力张量为 $ \\sigma = 2 \\mu \\, \\varepsilon^e + \\lambda \\, \\mathrm{tr}(\\varepsilon^e) I $，其中 $ I $ 是二阶单位张量。\n\n塑性屈服由 von Mises 屈服函数 $ f(\\sigma, \\alpha) = \\sigma_{\\mathrm{eq}}(\\sigma) - \\sigma_y(\\alpha) $ 确定，其中 $ \\sigma_{\\mathrm{eq}}(\\sigma) = \\sqrt{\\dfrac{3}{2}} \\, \\| s \\| $，$ s = \\sigma - \\dfrac{1}{3} \\mathrm{tr}(\\sigma) I $ 是偏应力，$ \\| s \\| $ 是 $ s $ 的 Frobenius 范数，而 $ \\sigma_y(\\alpha) = \\sigma_{y0} + H \\alpha $ 是当前屈服应力，通过累积等效塑性应变 $ \\alpha $、初始屈服应力 $ \\sigma_{y0} $ 和硬化模量 $ H $ 表示。塑性流动是关联的，塑性应变率 $ \\dot{\\varepsilon}^p $ 与屈服函数对应力的梯度方向一致，累积等效塑性应变率 $ \\dot{\\alpha} $ 定义为 $ \\dot{\\alpha} = \\sqrt{\\dfrac{2}{3}} \\, \\| \\dot{\\varepsilon}^p \\| $。演化过程必须满足率无关塑性的经典 Kuhn–Tucker 条件：$ f \\le 0 $、$ \\dot{\\lambda} \\ge 0 $、$ \\dot{\\lambda} f = 0 $，以及发生屈服时的一致性条件。此处 $ \\dot{\\lambda} $ 是塑性乘子。\n\n你的任务是，从这些基本原理出发，推导一个用于三维空间中单个恒定应变增量的后向欧拉返回映射更新算法，并实现该算法以推进指定加载路径下的状态。该更新必须确保在发生塑性流动时塑性不可压缩性 $ \\mathrm{tr}(\\Delta \\varepsilon^p) = 0 $ 成立，并且每个增量步都必须满足力学耗散不等式 $ \\Delta D = \\sigma : \\Delta \\varepsilon^p \\ge 0 $。你还必须实现检查，以验证每条路径最终状态的屈服一致性。\n\n材料参数给定为 $ E = 210000 $（单位：兆帕，MPa），$ \\nu = 0.3 $（无量纲），$ \\sigma_{y0} = 250 $（单位：MPa），以及 $ H = 1000 $（单位：MPa）。应变为无量纲。应力必须以兆帕（MPa）计算。如果内部检查需要角度，则必须以弧度处理。\n\n实现该算法并模拟以下三个基准加载路径，每个路径都指定为应用于应变张量 $ \\varepsilon $ 的一系列恒定应变增量：\n\n- 单轴拉伸路径：施加 $ 20 $ 个增量，每个增量为 $ \\Delta \\varepsilon = \\mathrm{diag}(10^{-4}, 0, 0) $。\n- 纯剪切路径：施加 $ 20 $ 个增量，每个增量 $ \\Delta \\varepsilon $ 的分量为 $ \\Delta \\varepsilon_{12} = \\Delta \\varepsilon_{21} = 10^{-4} $，所有其他分量为零。\n- 非比例双轴路径：首先施加 $ 15 $ 个 $ \\Delta \\varepsilon = \\mathrm{diag}(10^{-4}, 0, 0) $ 的增量，然后施加 $ 5 $ 个 $ \\Delta \\varepsilon = \\mathrm{diag}(0, 10^{-4}, 0) $ 的增量。\n\n对于每个路径，在完成所有增量后，计算并报告三个布尔值检查：\n\n1. 塑性不可压缩性检查：$ |\\mathrm{tr}(\\varepsilon^p_{\\mathrm{final}})| \\le 10^{-10} $。\n2. 非负耗散检查：总累积塑性耗散 $ \\sum \\sigma_{n+1} : \\Delta \\varepsilon^p \\ge -10^{-12} $。\n3. 最终状态的屈服一致性检查：如果最终累积等效塑性应变 $ \\alpha_{\\mathrm{final}}  10^{-12} $，则 $ | f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) | \\le 10^{-10} $；否则（纯弹性最终状态），$ f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) \\le 10^{-10} $。\n\n你的程序应生成单行输出，其中包含按上述顺序排列的三个路径的九个布尔值结果，聚合为一个用方括号括起来的逗号分隔列表，例如 $ [\\mathrm{result}_1, \\mathrm{result}_2, \\mathrm{result}_3, \\ldots, \\mathrm{result}_9] $。不应产生任何其他输出。所有应力计算都必须以兆帕（MPa）为单位进行。布尔值为无量纲。", "solution": "该问题要求推导并实现一个数值算法，以模拟小应变、率无关、各向同性弹塑性材料的行为。该模型基于偏应力第二不变量 $J_2$，并包含线性各向同性硬化。该算法将用于模拟指定加载路径下的材料响应。解决方案的核心在于实现一个后向欧拉返回映射方案，以对离散应变增量上的本构方程进行积分。\n\n在离散时间步 $n$ 时，材料的状态由总应变张量 $\\varepsilon_n$、塑性应变张量 $\\varepsilon^p_n$ 和标量累积等效塑性应变 $\\alpha_n$ 定义。给定此状态和指定的总应变增量 $\\Delta\\varepsilon$，任务是计算时间步 $n+1$ 的状态。增量结束时的总应变为 $\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon$。该算法包括一个弹性预测步，以及在检测到屈服后的一个塑性修正步。\n\n第一步是弹性预测。我们假设整个应变增量是纯弹性的，这意味着塑性状态变量不发生变化：$\\Delta\\varepsilon^p = 0$ 和 $\\Delta\\alpha=0$。该步结束时的弹性应变，称为试探弹性应变 $\\varepsilon^{e, \\text{trial}}_{n+1}$，计算如下：\n$$ \\varepsilon^{e, \\text{trial}}_{n+1} = \\varepsilon_{n+1} - \\varepsilon^p_n = (\\varepsilon_n + \\Delta\\varepsilon) - \\varepsilon^p_n = \\varepsilon^e_n + \\Delta\\varepsilon $$\n然后，使用各向同性线弹性本构关系计算试探应力 $\\sigma^{\\text{trial}}_{n+1}$：\n$$ \\sigma^{\\text{trial}}_{n+1} = 2\\mu \\varepsilon^{e, \\text{trial}}_{n+1} + \\lambda \\mathrm{tr}(\\varepsilon^{e, \\text{trial}}_{n+1}) I $$\n其中 $\\mu = \\frac{E}{2(1+\\nu)}$ 和 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2 \\nu)}$ 是拉梅参数，$I$ 是二阶单位张量。累积塑性应变的试探值与上一步保持不变，$\\alpha^{\\text{trial}}_{n+1} = \\alpha_n$。\n\n第二步是屈服条件检查。我们在试探状态下评估 von Mises 屈服函数 $f(\\sigma, \\alpha) = \\sigma_{\\mathrm{eq}}(\\sigma) - \\sigma_y(\\alpha)$：\n$$ f^{\\text{trial}} = f(\\sigma^{\\text{trial}}_{n+1}, \\alpha_n) = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) - \\sigma_y(\\alpha_n) $$\n此处，等效应力为 $\\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) = \\sqrt{\\frac{3}{2}} \\| s^{\\text{trial}}_{n+1} \\|$，其中 $s^{\\text{trial}}_{n+1} = \\sigma^{\\text{trial}}_{n+1} - \\frac{1}{3} \\mathrm{tr}(\\sigma^{\\text{trial}}_{n+1}) I$ 是试探应力的偏量部分。屈服应力由线性硬化定律 $\\sigma_y(\\alpha_n) = \\sigma_{y0} + H\\alpha_n$ 给出。如果 $f^{\\text{trial}} \\le 0$，则弹性假设有效。试探状态成为该增量的最终状态：$\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1}$，$\\varepsilon^p_{n+1} = \\varepsilon^p_n$，且 $\\alpha_{n+1} = \\alpha_n$。\n\n如果 $f^{\\text{trial}}  0$，材料已屈服，需要进行塑性修正。这是返回映射阶段。塑性流动由关联流动法则控制，当使用后向欧拉方案离散化时，塑性应变增量 $\\Delta\\varepsilon^p = \\varepsilon^p_{n+1} - \\varepsilon^p_n$ 如下：\n$$ \\Delta\\varepsilon^p = \\Delta\\gamma \\frac{\\partial f}{\\partial\\sigma}\\bigg|_{\\sigma_{n+1}} = \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s_{n+1}}{\\|s_{n+1}\\|} $$\n其中 $\\Delta\\gamma \\ge 0$ 是塑性乘子增量。累积塑性应变的演化由 $\\Delta\\alpha = \\sqrt{\\frac{2}{3}} \\| \\Delta\\varepsilon^p \\|$ 给出。$J_2$ 塑性流动法则的一个关键推论是 $\\Delta\\alpha = \\Delta\\gamma$。这是因为梯度 $\\frac{\\partial f}{\\partial\\sigma}$ 的范数为1。另一个推论是塑性不可压缩性，即 $\\mathrm{tr}(\\Delta\\varepsilon^p)=0$，因为梯度是纯偏量的。\n\n$n+1$ 步的应力通过 $\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$ 与试探应力相关。由于 $\\mathrm{tr}(\\Delta\\varepsilon^p)=0$，静水应力不受塑性修正的影响，即 $\\mathrm{tr}(\\sigma_{n+1}) = \\mathrm{tr}(\\sigma^{\\text{trial}}_{n+1})$。修正仅适用于偏量部分：$s_{n+1} = s^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$。代入 $\\Delta\\varepsilon^p$ 的流动法则：\n$$ s_{n+1} = s^{\\text{trial}}_{n+1} - 2\\mu \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s_{n+1}}{\\|s_{n+1}\\|} $$\n该方程表明 $s_{n+1}$ 与 $s^{\\text{trial}}_{n+1}$ 共线。通过重新整理并对两边取范数，我们得到以下关系：\n$$ \\|s_{n+1}\\| + 2\\mu \\Delta\\gamma \\sqrt{\\frac{3}{2}} = \\|s^{\\text{trial}}_{n+1}\\| $$\n两边乘以 $\\sqrt{3/2}$ 并代入等效应力的定义，可得：\n$$ \\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) + 3\\mu\\Delta\\gamma = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) $$\n最终状态必须满足一致性条件 $f(\\sigma_{n+1}, \\alpha_{n+1})=0$，这要求 $\\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) = \\sigma_y(\\alpha_{n+1}) = \\sigma_y(\\alpha_n) + H\\Delta\\alpha$。使用 $\\Delta\\alpha = \\Delta\\gamma$，我们得到 $\\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) = \\sigma_y(\\alpha_n) + H\\Delta\\gamma$。将此代入前一个方程，即可解出 $\\Delta\\gamma$：\n$$ (\\sigma_y(\\alpha_n) + H\\Delta\\gamma) + 3\\mu\\Delta\\gamma = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) $$\n$$ \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) - \\sigma_y(\\alpha_n) = (3\\mu + H)\\Delta\\gamma $$\n左边即为 $f^{\\text{trial}}$。因此，塑性乘子可以以闭合形式求出：\n$$ \\Delta\\gamma = \\frac{f^{\\text{trial}}}{3\\mu + H} $$\n确定 $\\Delta\\gamma$ 后，状态变量得以更新。\n1. 更新内硬化变量：$\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$。\n2. 计算塑性应变增量。由于 $s_{n+1}$ 和 $s^{\\text{trial}}_{n+1}$ 共线，我们可以使用 $s^{\\text{trial}}_{n+1}$ 的方向：\n   $$ \\Delta\\varepsilon^p = \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s^{\\text{trial}}_{n+1}}{\\|s^{\\text{trial}}_{n+1}\\|} $$\n3. 更新总塑性应变：$\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\varepsilon^p$。\n4. 更新应力张量：$\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$。\n\n该算法针对给定的加载路径实现。在完成一条路径的所有增量后，对最终状态进行三个检查：塑性不可压缩性 $|\\mathrm{tr}(\\varepsilon^p_{\\mathrm{final}})| \\le 10^{-10}$、非负总耗散 $\\sum \\sigma_{n+1} : \\Delta \\varepsilon^p \\ge -10^{-12}$，以及屈服一致性 $| f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) | \\le 10^{-10}$（如果发生塑性流动，即 $\\alpha_{\\mathrm{final}}  10^{-12}$），或 $f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) \\le 10^{-10}$（其他情况）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the elasto-plastic problem for three loading paths and reports on the validation checks.\n    \"\"\"\n    \n    # Material parameters (stress in MPa)\n    E = 210000.0\n    nu = 0.3\n    sig_y0 = 250.0\n    H = 1000.0\n\n    # Derived elastic parameters\n    mu = E / (2.0 * (1.0 + nu))\n    lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    \n    # Identity tensor\n    I = np.identity(3)\n\n    # Define loading paths\n    # Path 1: Uniaxial tension\n    uniaxial_path = [\n        (np.diag([1e-4, 0.0, 0.0]), 20)\n    ]\n    \n    # Path 2: Pure shear\n    shear_increment = np.zeros((3, 3))\n    shear_increment[0, 1] = 1e-4\n    shear_increment[1, 0] = 1e-4\n    pure_shear_path = [\n        (shear_increment, 20)\n    ]\n    \n    # Path 3: Nonproportional biaxial path\n    nonproportional_path = [\n        (np.diag([1e-4, 0.0, 0.0]), 15),\n        (np.diag([0.0, 1e-4, 0.0]), 5)\n    ]\n    \n    paths = [uniaxial_path, pure_shear_path, nonproportional_path]\n    \n    final_results = []\n\n    for path in paths:\n        # Initialize state variables\n        eps_n = np.zeros((3, 3))\n        eps_p_n = np.zeros((3, 3))\n        alpha_n = 0.0\n        \n        # Initialize check accumulators\n        total_dissipation = 0.0\n\n        for segment in path:\n            delta_eps_template, num_increments = segment\n            for _ in range(num_increments):\n                # Current state is (eps_n, eps_p_n, alpha_n)\n                # Apply strain increment\n                eps_n1 = eps_n + delta_eps_template\n                \n                # --- Elasto-plastic update algorithm (return mapping) ---\n                \n                # 1. Elastic predictor\n                eps_e_trial = eps_n1 - eps_p_n\n                tr_eps_e_trial = np.trace(eps_e_trial)\n                sig_trial = lmbda * tr_eps_e_trial * I + 2.0 * mu * eps_e_trial\n                \n                s_trial = sig_trial - (np.trace(sig_trial) / 3.0) * I\n                norm_s_trial = np.linalg.norm(s_trial)\n                \n                # Handle case where s_trial is zero to avoid division by zero\n                if norm_s_trial  1e-12:\n                     sig_eq_trial = 0.0\n                else:\n                    sig_eq_trial = np.sqrt(3.0 / 2.0) * norm_s_trial\n\n                # 2. Yield check\n                sig_y_n = sig_y0 + H * alpha_n\n                f_trial = sig_eq_trial - sig_y_n\n\n                delta_eps_p = np.zeros((3, 3))\n                if f_trial = 1e-12:  # Elastic step (with tolerance)\n                    eps_p_n1 = eps_p_n\n                    alpha_n1 = alpha_n\n                    sig_n1 = sig_trial\n                else:  # 3. Plastic corrector\n                    delta_gamma = f_trial / (3.0 * mu + H)\n                    \n                    alpha_n1 = alpha_n + delta_gamma\n                    \n                    # Normal to the yield surface at trial state\n                    N_trial = np.sqrt(3.0 / 2.0) * s_trial / norm_s_trial\n                    \n                    delta_eps_p = delta_gamma * N_trial\n                    eps_p_n1 = eps_p_n + delta_eps_p\n                    \n                    # Update stress (radial return)\n                    sig_n1 = sig_trial - 2.0 * mu * delta_eps_p\n\n                # Accumulate dissipation for the current increment\n                dissipation_inc = np.sum(sig_n1 * delta_eps_p)\n                total_dissipation += dissipation_inc\n\n                # Update state for the next increment\n                eps_n = eps_n1\n                eps_p_n = eps_p_n1\n                alpha_n = alpha_n1\n\n        # --- Post-simulation checks for the completed path ---\n        eps_p_final = eps_p_n\n        alpha_final = alpha_n\n        \n        # Recalculate final stress from final strains for consistency\n        eps_e_final = eps_n - eps_p_final\n        sig_final = lmbda * np.trace(eps_e_final) * I + 2.0 * mu * eps_e_final\n\n        # Check 1: Plastic incompressibility\n        check1 = abs(np.trace(eps_p_final)) = 1e-10\n        final_results.append(check1)\n        \n        # Check 2: Nonnegative dissipation\n        check2 = total_dissipation >= -1e-12\n        final_results.append(check2)\n\n        # Check 3: Yield consistency\n        s_final = sig_final - (np.trace(sig_final) / 3.0) * I\n        norm_s_final = np.linalg.norm(s_final)\n        sig_eq_final = np.sqrt(3.0 / 2.0) * norm_s_final if norm_s_final > 1e-12 else 0.0\n\n        sig_y_final = sig_y0 + H * alpha_final\n        f_final = sig_eq_final - sig_y_final\n        \n        if alpha_final > 1e-12: # Plastic state\n            check3 = abs(f_final) = 1e-10\n        else: # Elastic state\n            check3 = f_final = 1e-10\n        final_results.append(check3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3593035"}, {"introduction": "在掌握了各向同性硬化之后，我们将转向一种更复杂的材料响应——运动硬化，它对于模拟材料在循环加载下的行为（如包申格效应）至关重要。此练习的核心是推导并实现描述屈服面平移的背应力（backstress）的更新算法。通过对比完全一致的隐式更新方案与简化的“滞后”更新方案 [@problem_id:3593012]，您将亲身体会到算法一致性与精度的深刻含义，并理解为何在追求精确解时，完全隐式的方法往往是不可或缺的。", "problem": "考虑具有线性随动硬化的小应变、单轴、率无关塑性。您将推导、实现并测试一个使用弹性预测/塑性修正回映算法方案的两子步应变控制更新算法。重点是揭示非零背应力如何在第二子步中改变容许性，并量化在以滞后方式处理背应力时的修正误差。\n\n从以下基本基础开始：\n- 运动学：总应变可加性地分解为弹性和塑性部分，$\\,\\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}}\\,.$\n- 自由能：假设一个二次亥姆霍兹自由能密度 $\\,\\psi(\\varepsilon, \\varepsilon^{\\mathrm{p}}, \\alpha) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{\\mathrm{p}}\\right)^{2} + \\tfrac{1}{2H}\\,\\alpha^{2}\\,,$ 其中 $\\,E\\,$ 是杨氏模量，$\\,H\\,$ 是线性随动硬化模量。假设为小应变。\n- 本构力共轭：应力 $\\,\\sigma\\,$ 与总应变 $\\,\\varepsilon\\,$ 功共轭，塑性应变 $\\,\\varepsilon^{\\mathrm{p}}\\,$ 是耗散的，并带有关联的塑性乘子 $\\,\\dot{\\gamma}\\ge 0\\,$，而背应力 $\\,\\alpha\\,$ 与其自身的随动内变量功共轭。使用 Clausius–Duhem 不等式确保非负耗散，并对率无关塑性采用标准的关联正交性。\n- 屈服函数：使用一维平移的 von Mises 型准则 $\\,f(\\sigma,\\alpha) = \\lvert \\sigma - \\alpha \\rvert - \\sigma_{y}\\le 0\\,,$ 其中 $\\,\\sigma_{y}\\,$ 是初始屈服应力。施加 Karush–Kuhn–Tucker 互补条件 $\\,\\dot{\\gamma}\\ge 0\\,$, $\\,f\\le 0\\,$ 和 $\\,\\dot{\\gamma}\\,f = 0\\,$，以及一致性条件 $\\,\\dot{\\gamma}0 \\Rightarrow \\dot{f}=0\\,.$ 采用一维关联流动，使得塑性流动方向为 $\\,\\mathrm{sign}(\\sigma-\\alpha)\\,$。对于一维线性随动硬化，取 $\\,\\dot{\\alpha} = H\\,\\dot{\\varepsilon}^{\\mathrm{p}}\\,.$\n\n您的任务：\n1) 从上述基础出发，推导用于从时间 $\\,t_{n}\\,$ 到 $\\,t_{n+1}\\,$ 的应变控制子步更新的一维回映算法方程。用标量塑性乘子增量 $\\,\\Delta\\gamma\\,$ 表达弹性预测（试探状态）和塑性修正。确保对于塑性加载 $\\,\\Delta\\gamma0\\,$，更新后的状态精确满足 $\\,f(\\sigma_{n+1},\\alpha_{n+1})=0\\,$。不要假设任何快捷公式；从所述原理推导它们。\n2) 定义一个“滞后背应力”方案，其中在塑性修正期间，背应力在屈服和一致性方程中固定为其子步开始时的值，同时仍然通过弹性模量更新应力。以这种滞后方式求解塑性乘子后，在子步结束时使用获得的塑性应变增量更新背应力。通过使用更新后的（非冻结的）背应力评估屈服残差 $\\,r = \\lvert \\sigma_{n+1}^{\\mathrm{lag}} - \\alpha_{n+1}^{\\mathrm{lag}} \\rvert - \\sigma_{y}\\,$，并与一致解比较最终应力，来量化此滞后方案的不一致性。\n3) 在单个步骤内实现两子步加载。第一个子步必须是弹性的。在第二个子步中，由于存在非零背应力，试探状态必须违反容许性，从而触发塑性修正。\n\n物理和数值细节：\n- 使用兆帕 (MPa) 作为应力单位，应变为无量纲。任何类应力输出以 MPa 表示，任何类应变输出以纯数字表示。报告相对误差时，以小数（而非百分比）形式报告。\n- 此处不适用角度单位。\n\n按如下方式为每个测试用例精确定义两子步更新：\n- 初始已知：$\\,E\\,$ (MPa)，$\\,\\sigma_{y}\\,$ (MPa)，$\\,H\\,$ (MPa)，$\\,\\varepsilon_{0}\\,$，$\\,\\varepsilon^{\\mathrm{p}}_{0}\\,$ 和 $\\,\\alpha_{0}\\,.$\n- 子步 $\\,1\\,$：施加 $\\,\\Delta\\varepsilon_{1}\\,$，计算弹性预测值 $\\,\\sigma^{\\mathrm{tr}}_{1} = \\sigma_{0} + E\\,\\Delta\\varepsilon_{1}\\,$，其中 $\\,\\sigma_{0} = E(\\varepsilon_{0} - \\varepsilon^{\\mathrm{p}}_{0})\\,$，检查容许性，并更新状态。对于所有测试用例，此子步必须保持弹性。\n- 子步 $\\,2\\,$：对子步 $\\,1\\,$ 更新后的状态施加 $\\,\\Delta\\varepsilon_{2}\\,$。计算试探状态并检测屈服。如果发生塑性变形，计算：\n  - 一致解 $\\,(\\Delta\\gamma^{\\mathrm{cons}}, \\sigma_{2}^{\\mathrm{cons}}, \\alpha_{2}^{\\mathrm{cons}})\\,$，使用强制 $\\,f(\\sigma_{2}^{\\mathrm{cons}},\\alpha_{2}^{\\mathrm{cons}})=0\\,$ 的推导回映算法。\n  - 滞后背应力解 $\\,(\\Delta\\gamma^{\\mathrm{lag}}, \\sigma_{2}^{\\mathrm{lag}}, \\alpha_{2}^{\\mathrm{lag}})\\,$，在修正器中使用冻结背应力评估，并在求解 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 之后才更新 $\\,\\alpha\\,.$\n  - 滞后更新的屈服残差 $\\,r = \\lvert \\sigma_{2}^{\\mathrm{lag}} - \\alpha_{2}^{\\mathrm{lag}} \\rvert - \\sigma_{y}\\,$（单位为 MPa），以及相对应力误差 $\\,e_{\\sigma} = (\\sigma_{2}^{\\mathrm{lag}} - \\sigma_{2}^{\\mathrm{cons}})/\\sigma_{2}^{\\mathrm{cons}}\\,$（小数形式）。\n\n测试套件：\n提供一个程序，为下面的每组数据计算每个测试用例的四个标量：$\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$，$\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$，$\\,r\\,$ 和 $\\,e_{\\sigma}\\,.$ 使用这些精确值。\n\n- 情况 $\\,\\mathrm{A}\\,$（顺利路径，拉伸加载，背应力为负，因此在第2子步中由于随动位移而导致容许性失效）：\n  - $\\,E = 210000\\,$ MPa, $\\,\\sigma_{y} = 250\\,$ MPa, $\\,H = 5000\\,$ MPa\n  - $\\,\\alpha_{0} = -80\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = -0.016\\,$, $\\,\\varepsilon_{0} = -0.015285714285714\\,$\n  - $\\,\\Delta\\varepsilon_{1} = 0.00002\\,$, $\\,\\Delta\\varepsilon_{2} = 0.00043238\\,$\n\n- 情况 $\\,\\mathrm{B}\\,$（反向加载边界类情况，在没有背应力时压缩试探是容许的，但由于正背应力而失效）：\n  - $\\,E = 70000\\,$ MPa, $\\,\\sigma_{y} = 150\\,$ MPa, $\\,H = 700\\,$ MPa\n  - $\\,\\alpha_{0} = 120\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = 0.171428571428571\\,$, $\\,\\varepsilon_{0} = 0.171428571428571\\,$\n  - $\\,\\Delta\\varepsilon_{1} = -0.000285714285714\\,$, $\\,\\Delta\\varepsilon_{2} = -0.001714285714286\\,$\n\n- 情况 $\\,\\mathrm{C}\\,$（随动硬化模量相对于弹性模量较大，一致修正量小且滞后误差可观）：\n  - $\\,E = 100000\\,$ MPa, $\\,\\sigma_{y} = 300\\,$ MPa, $\\,H = 200000\\,$ MPa\n  - $\\,\\alpha_{0} = -50\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = -0.00025\\,$, $\\,\\varepsilon_{0} = 0.00215\\,$\n  - $\\,\\Delta\\varepsilon_{1} = 0.00005\\,$, $\\,\\Delta\\varepsilon_{2} = 0.0002\\,$\n\n答案规格：\n- 对于每种情况，输出列表 $[\\Delta\\gamma^{\\mathrm{cons}}, \\Delta\\gamma^{\\mathrm{lag}}, r, e_{\\sigma}]$，其中 $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$ 和 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 是无量纲的，$\\,r\\,$ 的单位是 MPa，$\\,e_{\\sigma}\\,$ 是一个小数（无量纲）。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来。该行必须是三个情况结果列表的 Python 风格列表，例如 $[\\,[\\cdots], [\\cdots], [\\cdots]\\,]$。将每个打印的浮点数四舍五入到合理的小数位数，以便微小差异可见（例如，$10^{-12}$ 的精度是可以接受的）。", "solution": "本问题要求推导并实现一个用于一维率无关塑性及线性随动硬化的回映算法。该分析将比较一个完全一致的隐式更新和一个简化的“滞后背应力”显式更新。\n\n### 1. 本构框架\n\n该模型的基础是一个热力学一致的框架。材料的状态由总应变 $\\,\\varepsilon\\,$ 和两个内变量描述：塑性应变 $\\,\\varepsilon^{\\mathrm{p}}\\,$ 和一个标量随动硬化变量，对于线性硬化，该变量与背应力 $\\,\\alpha\\,$ 线性相关。\n\n**自由能与状态变量：**\n指定的亥姆霍兹自由能密度为：\n$$ \\psi(\\varepsilon, \\varepsilon^{\\mathrm{p}}, \\alpha) = \\frac{1}{2} E \\left(\\varepsilon - \\varepsilon^{\\mathrm{p}}\\right)^{2} + \\frac{1}{2H}\\,\\alpha^{2} $$\n其中 $\\,E\\,$ 是杨氏模量，$\\,H\\,$ 是随动硬化模量。项 $\\,\\varepsilon^{\\mathrm{e}} = \\varepsilon - \\varepsilon^{\\mathrm{p}}\\,$ 是弹性应变。\n\n**热力学力：**\n应力 $\\,\\sigma\\,$ 和热力学力的本构关系是通过对自由能相对于其共轭状态变量求导得出的。\n应力 $\\,\\sigma\\,$ 与总应变 $\\,\\varepsilon\\,$ 共轭：\n$$ \\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E (\\varepsilon - \\varepsilon^{\\mathrm{p}}) = E \\varepsilon^{\\mathrm{e}} $$\n这就是胡克定律。从 Clausius-Duhem 不等式推导出的耗散不等式，决定了内变量的演化。耗散率 $\\,\\mathcal{D}\\,$ 必须为非负：\n$$ \\mathcal{D} = \\sigma \\dot{\\varepsilon}^{\\mathrm{p}} - \\frac{\\partial \\psi}{\\partial \\alpha}\\dot{\\alpha} \\ge 0 $$\n问题将硬化法则定义为 $\\,\\dot{\\alpha} = H \\dot{\\varepsilon}^{\\mathrm{p}}\\,$。将此式和 $\\,\\frac{\\partial \\psi}{\\partial \\alpha} = \\frac{\\alpha}{H}\\,$ 代入耗散不等式，得到：\n$$ \\mathcal{D} = \\sigma \\dot{\\varepsilon}^{\\mathrm{p}} - \\left(\\frac{\\alpha}{H}\\right) (H \\dot{\\varepsilon}^{\\mathrm{p}}) = (\\sigma - \\alpha) \\dot{\\varepsilon}^{\\mathrm{p}} \\ge 0 $$\n项 $\\,\\xi = \\sigma - \\alpha\\,$ 是有效应力，是塑性流动的热力学驱动力。\n\n**塑性流动与屈服条件：**\n对于率无关塑性，只有当满足屈服准则时才会发生流动。屈服函数给定为：\n$$ f(\\sigma, \\alpha) = \\lvert \\sigma - \\alpha \\rvert - \\sigma_{y} = \\lvert \\xi \\rvert - \\sigma_{y} \\le 0 $$\n其中 $\\,\\sigma_{y}\\,$ 是初始屈服应力。塑性流动由 Karush-Kuhn-Tucker (KKT) 条件控制：\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\n其中 $\\,\\dot{\\gamma}\\,$ 是塑性乘子率。采用关联流动法则，将塑性应变率与屈服函数联系起来：\n$$ \\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sign}(\\sigma - \\alpha) $$\n一致性条件要求在塑性流动期间（$\\,\\dot{\\gamma}  0\\,$），状态必须保持在屈服面上（$\\,f=0\\,$），这意味着 $\\,\\dot{f}=0\\,.$\n\n### 2. 离散更新算法：回映算法\n\n我们采用后向欧拉积分格式，对应变控制的时间步从 $\\,t_{n}\\,$ 到 $\\,t_{n+1}\\,$ 进行积分。时间 $\\,t_n\\,$ 时的状态（$\\,\\varepsilon_n, \\varepsilon^{\\mathrm{p}}_n, \\alpha_n\\,$）是已知的，而时间 $\\,t_{n+1} = t_n + \\Delta t\\,$ 时的总应变是预先设定的。\n\n**第1步：弹性预测（试探状态）**\n首先，我们假设整个应变增量 $\\,\\Delta\\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n\\,$ 完全由弹性变形承担。\n- 塑性应变和背应力被冻结：$\\,\\varepsilon^{\\mathrm{p}}_{n+1, \\mathrm{tr}} = \\varepsilon^{\\mathrm{p}}_n\\,$ 和 $\\,\\alpha_{n+1, \\mathrm{tr}} = \\alpha_n\\,.$\n- 计算试探应力：\n  $$ \\sigma_{n+1}^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n+1, \\mathrm{tr}}) = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_n) = E(\\varepsilon_n + \\Delta\\varepsilon - \\varepsilon^{\\mathrm{p}}_n) = E(\\varepsilon_n - \\varepsilon^{\\mathrm{p}}_n) + E\\Delta\\varepsilon = \\sigma_n + E\\Delta\\varepsilon $$\n- 试探有效应力为 $\\,\\xi_{n+1}^{\\mathrm{tr}} = \\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n\\,.$\n\n**第2步：检查屈服**\n我们在试探状态下评估屈服函数：\n$$ f_{n+1}^{\\mathrm{tr}} = f(\\sigma_{n+1}^{\\mathrm{tr}}, \\alpha_{n+1, \\mathrm{tr}}) = \\lvert \\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n \\rvert - \\sigma_y = \\lvert \\xi_{n+1}^{\\mathrm{tr}} \\rvert - \\sigma_y $$\n- 如果 $\\,f_{n+1}^{\\mathrm{tr}} \\le 0\\,$，则试探状态是容许的。该步是弹性的。更新后的状态即为试探状态：\n  $$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}}, \\quad \\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_n, \\quad \\alpha_{n+1} = \\alpha_n $$\n- 如果 $\\,f_{n+1}^{\\mathrm{tr}}  0\\,$，则试探状态是不容许的。发生塑性流动，需要进行塑性修正步。\n\n**第3步：塑性修正**\n目标是找到塑性应变增量 $\\,\\Delta\\varepsilon^{\\mathrm{p}}\\,$，使得最终状态 $(\\sigma_{n+1}, \\alpha_{n+1})$ 满足屈服条件 $\\,f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$。内变量的离散增量为：\n- 塑性应变增量：$\\,\\Delta\\varepsilon^{\\mathrm{p}} = \\varepsilon^{\\mathrm{p}}_{n+1} - \\varepsilon^{\\mathrm{p}}_n = \\Delta\\gamma \\, \\mathrm{sign}(\\xi_{n+1})\\,$，其中 $\\,\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} dt \\ge 0\\,.$\n- 背应力增量：$\\,\\Delta\\alpha = \\alpha_{n+1} - \\alpha_n = H \\Delta\\varepsilon^{\\mathrm{p}} = H \\Delta\\gamma \\, \\mathrm{sign}(\\xi_{n+1})\\,.$\n\n对于径向回映，流动方向是恒定的，由试探有效应力决定：$\\,N = \\mathrm{sign}(\\xi_{n+1}) = \\mathrm{sign}(\\xi_{n+1}^{\\mathrm{tr}})\\,.$\n更新后的状态变量用试探状态和未知塑性乘子增量 $\\,\\Delta\\gamma\\,$ 表示：\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\varepsilon^{\\mathrm{p}} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N $$\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\alpha = \\alpha_n + H \\Delta\\gamma N $$\n最终有效应力为：\n$$ \\xi_{n+1} = \\sigma_{n+1} - \\alpha_{n+1} = (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N) - (\\alpha_n + H \\Delta\\gamma N) = (\\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n) - (E+H)\\Delta\\gamma N = \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma N $$\n\n### 3. 一致方案与滞后方案的推导\n\n**3.1. 一致回映算法**\n最终状态必须位于屈服面上：$\\,\\lvert \\xi_{n+1} \\rvert = \\sigma_y\\,.$ 由于 $\\,\\mathrm{sign}(\\xi_{n+1}) = N\\,$，这意味着 $\\,\\xi_{n+1} = \\sigma_y N\\,.$ 将此代入有效应力更新方程：\n$$ \\sigma_y N = \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma^{\\mathrm{cons}} N $$\n两边乘以 $\\,N\\,$（因为 $\\,N^2 = 1\\,$）并注意到 $\\,\\xi_{n+1}^{\\mathrm{tr}} N = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert\\,$：\n$$ \\sigma_y = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\Delta\\gamma^{\\mathrm{cons}} $$\n解出一致塑性乘子增量 $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$：\n$$ \\Delta\\gamma^{\\mathrm{cons}} = \\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E+H} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E+H} $$\n由于我们处于塑性情况（$\\,f_{n+1}^{\\mathrm{tr}}  0\\,$），因此 $\\,\\Delta\\gamma^{\\mathrm{cons}}  0\\,.$ 知道 $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$ 后，所有在 $\\,t_{n+1}\\,$ 时的状态变量都可以唯一确定。\n\n**3.2. 滞后背应力方案**\n在此方案中，当强制执行屈服条件时，背应力被“冻结”在其步长初始值 $\\,\\alpha_n\\,$。条件变为 $\\,f(\\sigma_{n+1}, \\alpha_n) = 0\\,$，或 $\\,\\lvert \\sigma_{n+1} - \\alpha_n \\rvert = \\sigma_y\\,.$\n应力更新 $\\,\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N\\,$ 仍然使用。我们将其代入滞后屈服条件：\n$$ \\lvert (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N) - \\alpha_n \\rvert = \\sigma_y $$\n$$ \\lvert \\xi_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N \\rvert = \\sigma_y $$\n同样，假设径向回映，我们得到：\n$$ \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - E \\Delta\\gamma^{\\mathrm{lag}} = \\sigma_y $$\n解出滞后塑性乘子增量 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$：\n$$ \\Delta\\gamma^{\\mathrm{lag}} = \\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E} $$\n计算出 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 后，更新所有状态变量。注意，由于 $\\,H  0\\,$，显然有 $\\,\\Delta\\gamma^{\\mathrm{lag}}  \\Delta\\gamma^{\\mathrm{cons}}\\,.$\n\n**3.3. 量化滞后方案的不一致性**\n滞后方案是不一致的，因为最终状态 $(\\sigma_{n+1}^{\\mathrm{lag}}, \\alpha_{n+1}^{\\mathrm{lag}})$ 不满足真实的屈服条件。我们用屈服残差 $\\,r\\,$ 来量化这一点。\n最终有效应力为 $\\,\\xi_{n+1}^{\\mathrm{lag}} = \\sigma_{n+1}^{\\mathrm{lag}} - \\alpha_{n+1}^{\\mathrm{lag}}\\,.$ 其大小为：\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma^{\\mathrm{lag}} N \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\Delta\\gamma^{\\mathrm{lag}} $$\n代入 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 的表达式：\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E} = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\left(1 + \\frac{H}{E}\\right)(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) $$\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) - \\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) = \\sigma_y - \\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) $$\n因此，屈服残差为：\n$$ r = \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert - \\sigma_y = -\\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) = -\\frac{H}{E} f_{n+1}^{\\mathrm{tr}} $$\n由于 $\\,H, E, f_{n+1}^{\\mathrm{tr}}  0\\,$，残差 $\\,r\\,$ 为负，表明滞后方案过度修正，并将状态带到真实屈服面的内部。\n\n相对应力误差 $\\,e_{\\sigma}\\,$ 定义为 $\\,e_{\\sigma} = (\\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}})/\\sigma_{n+1}^{\\mathrm{cons}}\\,.$\n应力差为：\n$$ \\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}} = (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N) - (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{cons}} N) = -E(\\Delta\\gamma^{\\mathrm{lag}} - \\Delta\\gamma^{\\mathrm{cons}})N $$\n乘子之差为：\n$$ \\Delta\\gamma^{\\mathrm{lag}} - \\Delta\\gamma^{\\mathrm{cons}} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E} - \\frac{f_{n+1}^{\\mathrm{tr}}}{E+H} = f_{n+1}^{\\mathrm{tr}} \\left(\\frac{E+H-E}{E(E+H)}\\right) = f_{n+1}^{\\mathrm{tr}} \\frac{H}{E(E+H)} $$\n所以，$\\,\\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}} = -E \\left( f_{n+1}^{\\mathrm{tr}} \\frac{H}{E(E+H)} \\right) N = -f_{n+1}^{\\mathrm{tr}} \\frac{H}{E+H} N\\,.$ 这个差异将对每种情况进行数值评估。\n\n### 4. 两子步实现总结\n\n对于每个具有参数 $\\,E, \\sigma_y, H\\,$、初始状态 $\\,\\varepsilon_0, \\varepsilon^{\\mathrm{p}}_0, \\alpha_0\\,$ 以及应变增量 $\\,\\Delta\\varepsilon_1, \\Delta\\varepsilon_2\\,$ 的测试用例：\n\n1.  **初始化**：计算 $\\,\\sigma_0 = E(\\varepsilon_0 - \\varepsilon^{\\mathrm{p}}_0)\\,$。\n2.  **子步 1（弹性）**：\n    -   计算试探应力 $\\,\\sigma_1^{\\mathrm{tr}} = \\sigma_0 + E\\Delta\\varepsilon_1\\,.$\n    -   确认 $\\,\\lvert \\sigma_1^{\\mathrm{tr}} - \\alpha_0 \\rvert - \\sigma_y \\le 0\\,.$\n    -   更新状态：$\\,\\sigma_1 = \\sigma_1^{\\mathrm{tr}}$, $\\,\\varepsilon^{\\mathrm{p}}_1 = \\varepsilon^{\\mathrm{p}}_0$, $\\,\\alpha_1 = \\alpha_0\\,.$\n3.  **子步 2（塑性）**：\n    -   计算试探应力 $\\,\\sigma_2^{\\mathrm{tr}} = \\sigma_1 + E\\Delta\\varepsilon_2\\,.$\n    -   计算试探有效应力 $\\,\\xi_2^{\\mathrm{tr}} = \\sigma_2^{\\mathrm{tr}} - \\alpha_1\\,$ 和屈服函数值 $\\,f_2^{\\mathrm{tr}} = \\lvert \\xi_2^{\\mathrm{tr}} \\rvert - \\sigma_y\\,.$\n    -   确认 $\\,f_2^{\\mathrm{tr}}  0\\,.$\n    -   设置流动方向 $\\,N = \\mathrm{sign}(\\xi_2^{\\mathrm{tr}})\\,.$\n4.  **计算一致解**：\n    -   $\\Delta\\gamma^{\\mathrm{cons}} = f_2^{\\mathrm{tr}} / (E+H)\\,.$\n    -   $\\sigma_2^{\\mathrm{cons}} = \\sigma_2^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{cons}} N\\,.$\n5.  **计算滞后解**：\n    -   $\\Delta\\gamma^{\\mathrm{lag}} = f_2^{\\mathrm{tr}} / E\\,.$\n    -   $\\sigma_2^{\\mathrm{lag}} = \\sigma_2^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N = \\alpha_1 + \\sigma_y N\\,.$\n    -   $\\alpha_2^{\\mathrm{lag}} = \\alpha_1 + H \\Delta\\gamma^{\\mathrm{lag}} N\\,.$\n6.  **计算误差**：\n    -   $r = \\lvert \\sigma_2^{\\mathrm{lag}} - \\alpha_2^{\\mathrm{lag}} \\rvert - \\sigma_y\\,.$\n    -   $e_{\\sigma} = (\\sigma_2^{\\mathrm{lag}} - \\sigma_2^{\\mathrm{cons}}) / \\sigma_2^{\\mathrm{cons}}\\,.$\n7.  **存储结果**：四个值 $\\,\\Delta\\gamma^{\\mathrm{cons}}, \\Delta\\gamma^{\\mathrm{lag}}, r, e_{\\sigma}\\,$ 是单个用例的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(E, sigma_y, H, eps0, eps_p0, alpha0, delta_eps1, delta_eps2):\n    \"\"\"\n    Solves a single test case for the two-substep plasticity problem.\n\n    Args:\n        E (float): Young's modulus (MPa)\n        sigma_y (float): Initial yield stress (MPa)\n        H (float): Linear kinematic hardening modulus (MPa)\n        eps0 (float): Initial total strain\n        eps_p0 (float): Initial plastic strain\n        alpha0 (float): Initial backstress (MPa)\n        delta_eps1 (float): Strain increment for substep 1\n        delta_eps2 (float): Strain increment for substep 2\n\n    Returns:\n        tuple: (delta_gamma_cons, delta_gamma_lag, r, e_sigma)\n    \"\"\"\n\n    # --- Initial State (n=0) ---\n    sigma0 = E * (eps0 - eps_p0)\n    \n    # Verify initial state admissibility\n    f0 = np.abs(sigma0 - alpha0) - sigma_y\n    if f0 > 1e-9: # Use a small tolerance for floating point comparisons\n        raise ValueError(f\"Initial state is not admissible (f0 = {f0} > 0)\")\n\n    # --- Substep 1 (Elastic) ---\n    sigma1_tr = sigma0 + E * delta_eps1\n    alpha1_tr = alpha0\n    \n    f1_tr = np.abs(sigma1_tr - alpha1_tr) - sigma_y\n    if f1_tr > 1e-9:\n        raise ValueError(f\"Substep 1 is not elastic as required (f1_tr = {f1_tr} > 0)\")\n    \n    # Update state after elastic substep 1\n    sigma1 = sigma1_tr\n    # eps_p1 = eps_p0\n    alpha1 = alpha0\n    \n    # --- Substep 2 (Plastic) ---\n    # Predictor\n    sigma2_tr = sigma1 + E * delta_eps2\n    alpha2_tr = alpha1 # Backstress at start of substep\n    \n    # Check yield\n    xi2_tr = sigma2_tr - alpha2_tr\n    f2_tr = np.abs(xi2_tr) - sigma_y\n    \n    if f2_tr = 1e-9:\n        raise ValueError(f\"Substep 2 is not plastic as required (f2_tr = {f2_tr} = 0)\")\n        \n    N = np.sign(xi2_tr)\n    \n    # --- Consistent Solution ---\n    delta_gamma_cons = f2_tr / (E + H)\n    sigma2_cons = sigma2_tr - E * delta_gamma_cons * N\n    # alpha2_cons = alpha1 + H * delta_gamma_cons * N\n    # Verification:\n    # xi2_cons = sigma2_cons - alpha2_cons\n    # assert np.isclose(np.abs(xi2_cons), sigma_y), \"Consistent solution failed yield check\"\n    \n    # --- Lagged Backstress Solution ---\n    delta_gamma_lag = f2_tr / E\n    \n    # Update variables for the lagged scheme\n    sigma2_lag = sigma2_tr - E * delta_gamma_lag * N\n    alpha2_lag = alpha1 + H * delta_gamma_lag * N\n    \n    # --- Error Quantification ---\n    # 1. Yield residual of the lagged solution\n    r = np.abs(sigma2_lag - alpha2_lag) - sigma_y\n    \n    # 2. Relative stress error\n    if np.abs(sigma2_cons)  1e-12:\n        e_sigma = 0.0 if np.isclose(sigma2_lag, sigma2_cons) else np.inf\n    else:\n        e_sigma = (sigma2_lag - sigma2_cons) / sigma2_cons\n        \n    return delta_gamma_cons, delta_gamma_lag, r, e_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'E': 210000.0, 'sigma_y': 250.0, 'H': 5000.0,\n         'alpha0': -80.0, 'eps_p0': -0.016, 'eps0': -0.015285714285714,\n         'delta_eps1': 0.00002, 'delta_eps2': 0.00043238},\n        # Case B\n        {'E': 70000.0, 'sigma_y': 150.0, 'H': 700.0,\n         'alpha0': 120.0, 'eps_p0': 0.171428571428571, 'eps0': 0.171428571428571,\n         'delta_eps1': -0.000285714285714, 'delta_eps2': -0.001714285714286},\n        # Case C\n        {'E': 100000.0, 'sigma_y': 300.0, 'H': 200000.0,\n         'alpha0': -50.0, 'eps_p0': -0.00025, 'eps0': 0.00215,\n         'delta_eps1': 0.00005, 'delta_eps2': 0.0002}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(list(result))\n\n    # Format output as specified\n    output_str = \"[\"\n    for i, res_list in enumerate(results):\n        # Using a list comprehension to format each number.\n        formatted_list = [f\"{v:.12g}\" for v in res_list]\n        output_str += f\"[{','.join(formatted_list)}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    # This manual construction is to exactly match the desired format example,\n    # which has a different structure than `str(results)`.\n    # E.g., `[[val1,val2,...],[val1,val2,...]]`\n    final_output = str(results).replace(\"'\", \"\").replace(\" \", \"\")\n    print(final_output)\n\n# Using a simpler print for robustness as the exact formatting is tricky\n# and str(list_of_lists) is standard Python output.\ndef solve_robust():\n    test_cases = [\n        {'E': 210000.0, 'sigma_y': 250.0, 'H': 5000.0,\n         'alpha0': -80.0, 'eps_p0': -0.016, 'eps0': -0.015285714285714,\n         'delta_eps1': 0.00002, 'delta_eps2': 0.00043238},\n        {'E': 70000.0, 'sigma_y': 150.0, 'H': 700.0,\n         'alpha0': 120.0, 'eps_p0': 0.171428571428571, 'eps0': 0.171428571428571,\n         'delta_eps1': -0.000285714285714, 'delta_eps2': -0.001714285714286},\n        {'E': 100000.0, 'sigma_y': 300.0, 'H': 200000.0,\n         'alpha0': -50.0, 'eps_p0': -0.00025, 'eps0': 0.00215,\n         'delta_eps1': 0.00005, 'delta_eps2': 0.0002}\n    ]\n    all_results = [list(solve_case(**case)) for case in test_cases]\n    print(str(all_results).replace(\" \", \"\"))\n\n# The prompt asks for a runnable script, so we choose one implementation.\n# The original code's custom string formatting is complex and fragile. \n# Using str() is more reliable and produces a valid Python list representation.\n# Let's go back to a simpler, correct formatting logic.\n\ndef solve_final():\n    test_cases = [\n        {'E': 210000.0, 'sigma_y': 250.0, 'H': 5000.0, 'alpha0': -80.0, 'eps_p0': -0.016, 'eps0': -0.015285714285714, 'delta_eps1': 0.00002, 'delta_eps2': 0.00043238},\n        {'E': 70000.0, 'sigma_y': 150.0, 'H': 700.0, 'alpha0': 120.0, 'eps_p0': 0.171428571428571, 'eps0': 0.171428571428571, 'delta_eps1': -0.000285714285714, 'delta_eps2': -0.001714285714286},\n        {'E': 100000.0, 'sigma_y': 300.0, 'H': 200000.0, 'alpha0': -50.0, 'eps_p0': -0.00025, 'eps0': 0.00215, 'delta_eps1': 0.00005, 'delta_eps2': 0.0002}\n    ]\n    results = [list(solve_case(**case)) for case in test_cases]\n    print(str(results).replace(\" \", \"\"))\n\nsolve_final()\n```", "id": "3593012"}, {"introduction": "最后，我们将从单个光滑的屈服面推广到由多个相交的线性屈服函数定义的多面体弹性域。这种多面屈服模型是处理如 Tresca 准则或晶体塑性等更高级模型的关键。此问题要求您放弃简单的闭式返回映射，转而设计一个更通用的迭代优化算法——活动集方法，以求解一个二次规划问题 [@problem_id:3593072]。您将直面非光滑角点带来的挑战，并设计一个严谨的“反循环”规则以确保算法的稳健性，这标志着您从掌握特定算法向驾驭通用优化框架的进阶。", "problem": "实现一个针对具有凸多面体屈服面的率无关、伴随、多面塑性模型的主动集返回映射算法。弹性域由一组有限的线性屈服函数 $f_i(\\sigma,\\kappa) \\le 0$ 定义，其中 $\\sigma \\in \\mathbb{R}^3$ 是平面应力状态下的柯西应力矢量，其分量为 $[\\sigma_{xx},\\sigma_{yy},\\tau_{xy}]$，而 $\\kappa$ 是一个表示累积塑性应变的标量内变量。使用小应变线弹性模型，其柔度张量 $S \\in \\mathbb{R}^{3 \\times 3}$ 为对称正定矩阵。假设流动法则是伴随的，并采用率无关塑性的经典 Karush–Kuhn–Tucker (KKT) 互补条件。\n\n您的推导和实现应基于以下基本定律和核心定义：\n- 具有柔度 $S$ 的小应变线弹性：增量弹性本构关系为 $\\Delta \\varepsilon^e = S : \\Delta \\sigma$，等效于由 $S$ 定义的弹性势能度量。\n- 具有伴随流动的率无关塑性：$\\Delta \\varepsilon^p = \\sum_{i=1}^{m} \\Delta \\lambda_i \\, \\partial_{\\sigma} f_i(\\sigma,\\kappa)$，其中 $\\Delta \\lambda_i \\ge 0$，屈服不等式为 $f_i(\\sigma,\\kappa) \\le 0$，以及互补条件为 $\\Delta \\lambda_i \\, f_i(\\sigma,\\kappa) = 0$。\n- 广义标准材料的增量最小原理：对于给定的弹性预测应力 $\\sigma^{\\text{trial}}$，应力更新是一个凸二次规划问题的解，该问题计算的是到弹性域上的度量投影。\n\n为使模型精确且可测试，考虑一个由 $m=6$ 个线性屈服函数定义的理想塑性（无硬化）多面体域\n$$\nf_i(\\sigma) = n_i^{\\top}\\sigma - R \\le 0 \\quad \\text{for } i \\in \\{1,2,3,4,5,6\\},\n$$\n其中 $R0$ 是一个常数，法向量为\n$$\nn_1 = [1,0,0]^\\top,\\; n_2 = [-1,0,0]^\\top,\\; n_3 = [0,1,0]^\\top,\\; n_4=[0,-1,0]^\\top,\\; n_5=[0,0,1]^\\top,\\; n_6=[0,0,-1]^\\top.\n$$\n这是一个多面模型，其在应力空间中的弹性域呈立方体形状，具有非光滑的角点，在这些角点上多个约束可以同时被激活。\n\n对于具有弹性预测（试探）应力 $\\sigma^{\\text{trial}}$ 的单个荷载增量，弹塑性应力 $\\sigma$ 定义为以下度量投影问题的唯一解\n$$\n\\min_{\\sigma \\in \\mathbb{R}^3}\\;\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S\\,(\\sigma-\\sigma^{\\text{trial}}) \\quad \\text{subject to}\\quad N\\,\\sigma \\le r,\n$$\n其中 $N \\in \\mathbb{R}^{6\\times 3}$ 是由行向量 $n_i^\\top$ 堆叠而成的矩阵，而 $r \\in \\mathbb{R}^6$ 是由 $R$ 堆叠而成的向量。此凸二次规划问题的 KKT 条件为\n$$\nS(\\sigma-\\sigma^{\\text{trial}}) + N^\\top \\lambda = 0,\\quad\nN\\sigma - r \\le 0,\\quad\n\\lambda \\ge 0,\\quad\n\\lambda \\odot (N\\sigma - r) = 0\n$$\n其中 $\\lambda \\in \\mathbb{R}^6$ 是拉格朗日乘子，$\\odot$ 表示阿达玛积。\n\n您的任务：\n- 推导一个主动集算法，通过迭代地猜测一个激活约束的工作集 $\\mathcal{A}$、求解等式约束子问题来强制满足 KKT 条件\n$$\n\\min_{\\sigma}\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S(\\sigma-\\sigma^{\\text{trial}})\\quad \\text{s.t.}\\quad N_{\\mathcal{A}}\\sigma = r_{\\mathcal{A}},\n$$\n并根据不可行性和乘子符号更新该集合，直到所有 KKT 条件都得到满足。\n- 设计一个严格且可实现的准则，用于检测和避免在非光滑角点处主动集的循环。您的准则必须基于基本的算法不变量（例如目标函数值不下降的重复主动集，或 Bland 型主元规则）。精确解释约束的进入/离开规则以及保证终止的破除僵局规则。\n\n测试套件请使用以下具体的、科学上一致的数据（无量纲量）：\n- 各向同性平面应力下的弹性柔度 $S$，其中杨氏模量为 $E$，泊松比为 $\\nu$：\n$$\nS = \\begin{bmatrix}\n\\dfrac{1}{E}  -\\dfrac{\\nu}{E}  0 \\\\\n-\\dfrac{\\nu}{E}  \\dfrac{1}{E}  0 \\\\\n0  0  \\dfrac{1}{G}\n\\end{bmatrix},\\quad G = \\dfrac{E}{2(1+\\nu)}.\n$$\n所有测试用例均取 $E = 1000$ 和 $\\nu = 0.3$。\n- 屈服半径 $R = 100$。\n- 屈服法向量 $N$ 如上定义。\n\n提供一个程序，对于每个给定的试探应力 $\\sigma^{\\text{trial}}$，通过您带有循环检测和反循环机制的主动集算法计算弹塑性应力 $\\sigma$。您的循环检测器必须报告一个布尔标志，指示在该案例的求解过程中反循环机制是否至少被调用过一次。\n\n测试套件。在以下 5 个试探应力上运行您的求解器（每个都是顺序为 $[\\sigma_{xx},\\sigma_{yy},\\tau_{xy}]$ 的矢量）：\n- 案例 1：$\\sigma^{\\text{trial}} = [90,\\,80,\\,20]$。\n- 案例 2：$\\sigma^{\\text{trial}} = [150,\\,0,\\,0]$。\n- 案例 3：$\\sigma^{\\text{trial}} = [150,\\,150,\\,0]$。\n- 案例 4：$\\sigma^{\\text{trial}} = [120,\\,120,\\,120]$。\n- 案例 5：$\\sigma^{\\text{trial}} = [100,\\,100,\\,100]$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个含有 5 个结果的列表，每个测试用例一个，按顺序排列。每个结果必须是一个长度为 4 的列表，按顺序包含弹塑性应力分量和布尔循环标志 $[\\sigma_{xx},\\sigma_{yy},\\tau_{xy},\\text{anticyle\\_used}]$。浮点数使用标准十进制表示法，布尔值使用字面量表示。整个输出必须是打印在单行上的 Python 风格列表，例如：\n$$\n[\\,[\\ldots],\\,[\\ldots],\\,[\\ldots],\\,[\\ldots],\\,[\\ldots]\\,].\n$$\n\n注：\n- 将所有量视为无量纲；无需进行物理单位转换。\n- 不涉及角度；无需角度单位。\n- 通过明确说明的容差来确保数值稳健性。", "solution": "该问题要求实现一个针对率无关、多面塑性模型的主动集返回映射算法。任务的核心是求解一个约束优化问题，即在弹性域中找到离给定试探应力最近的点，这里的“最近”是在弹性势能度量下定义的。要求的一个重要部分是实现一个稳健的反循环规则，以处理多面体屈服面的非光滑角点。\n\n### 1. 理论公式\n\n对于给定的总应变增量，弹塑性应力状态 $\\sigma$ 是通过最小化增量功来找到的。对于给定的试探弹性应力 $\\sigma^{\\text{trial}}$，这等效于一个度量投影问题。试探应力是在纯弹性行为假设下将达到的应力，即 $\\sigma^{\\text{trial}} = C:(\\varepsilon_{n} + \\Delta\\varepsilon)$，其中 $C=S^{-1}$ 是四阶弹性张量（刚度），$\\varepsilon_n$ 是增量开始时的总应变，$\\Delta\\varepsilon$ 是应变增量。\n\n更新后的应力 $\\sigma$ 是以下凸二次规划（QP）问题的解：\n$$\n\\min_{\\sigma \\in \\mathbb{R}^3}\\;\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S\\,(\\sigma-\\sigma^{\\text{trial}}) \\quad \\text{subject to}\\quad f_i(\\sigma) \\le 0 \\quad \\text{for } i=1,\\dots,m\n$$\n其中 $S$ 是柔度矩阵，弹性域由一组 $m$ 个线性屈服函数 $f_i(\\sigma) = n_i^\\top \\sigma - R \\le 0$ 定义。矩阵 $S$ 定义了投影的度量。该问题可以写成矩阵形式：\n$$\n\\min_{\\sigma \\in \\mathbb{R}^3}\\;\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S\\,(\\sigma-\\sigma^{\\text{trial}}) \\quad \\text{subject to}\\quad N\\,\\sigma \\le r\n$$\n其中 $N \\in \\mathbb{R}^{m \\times 3}$ 是行向量为法向量 $n_i^\\top$ 的矩阵，$r \\in \\mathbb{R}^m$ 是由屈服极限 $R$ 组成的向量。\n\nKarush-Kuhn-Tucker (KKT) 条件为此凸二次规划问题的唯一解 $\\sigma$ 提供了必要和充分条件：\n1.  **驻定性：** $S(\\sigma - \\sigma^{\\text{trial}}) + N^\\top \\lambda = 0$\n2.  **原始可行性：** $N\\sigma - r \\le 0$\n3.  **对偶可行性：** $\\lambda \\ge 0$\n4.  **互补性：** 对每个 $i=1,\\dots,m$ 都有 $\\lambda_i (n_i^\\top \\sigma - R) = 0$。\n\n此处，$\\lambda \\in \\mathbb{R}^m$ 是拉格朗日乘子向量，在塑性力学中，它对应于每个屈服面的塑性流动量（一致性参数），$\\lambda_i = \\Delta\\lambda_i$。\n\n### 2. 主动集算法\n\n主动集方法是求解此类约束优化问题的一种迭代过程。它维护一个“工作集”$\\mathcal{W}$，该集合包含在解处被假定为激活的（即作为等式满足的）约束。\n\n#### 迭代子问题\n\n在每次迭代 $k$ 中，给定一个工作集 $\\mathcal{W}_k$，我们求解一个等式约束的二次规划问题：\n$$\n\\min_{\\sigma}\\; \\tfrac{1}{2}(\\sigma - \\sigma^{\\text{trial}})^\\top S (\\sigma - \\sigma^{\\text{trial}})\\quad \\text{s.t.}\\quad N_{\\mathcal{W}_k}\\sigma = r_{\\mathcal{W}_k}\n$$\n其中 $N_{\\mathcal{W}_k}$ 和 $r_{\\mathcal{W}_k}$ 分别由 $N$ 和 $r$ 中与 $\\mathcal{W}_k$ 中索引对应的行组成。该子问题的解通过求解相关的 KKT 系统得到，这是一个线性方程组：\n$$\n\\begin{pmatrix}\nS  N_{\\mathcal{W}_k}^\\top \\\\\nN_{\\mathcal{W}_k}  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\sigma_{k+1} \\\\\n\\lambda_{\\mathcal{W}_k}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nS \\sigma^{\\text{trial}} \\\\\nr_{\\mathcal{W}_k}\n\\end{pmatrix}\n$$\n一种计算上更稳定的方法是首先求解乘子 $\\lambda_{\\mathcal{W}_k}$，然后更新应力 $\\sigma_{k+1}$。根据第一个 KKT 方程，$\\sigma_{k+1} = \\sigma^{\\text{trial}} - C N_{\\mathcal{W}_k}^\\top \\lambda_{\\mathcal{W}_k}$，其中 $C=S^{-1}$ 是刚度矩阵。将此代入约束方程 $N_{\\mathcal{W}_k}\\sigma_{k+1} = r_{\\mathcal{W}_k}$，可得到一个关于 $\\lambda_{\\mathcal{W}_k}$ 的较小线性系统：\n$$\n(N_{\\mathcal{W}_k} C N_{\\mathcal{W}_k}^\\top) \\lambda_{\\mathcal{W}_k} = N_{\\mathcal{W}_k} \\sigma^{\\text{trial}} - r_{\\mathcal{W}_k}\n$$\n求解出 $\\lambda_{\\mathcal{W}_k}$ 后，再计算 $\\sigma_{k+1}$。\n\n#### 更新工作集\n\n如果完整问题的 KKT 条件得到满足，算法终止。否则，工作集 $\\mathcal{W}_k$ 将被更新为 $\\mathcal{W}_{k+1}$ 用于下一次迭代：\n1.  **检查原始可行性：** 如果任何非激活约束 $i \\notin \\mathcal{W}_k$ 被 $\\sigma_{k+1}$ 违反（即 $n_i^\\top \\sigma_{k+1} - R  \\text{tol}$），则将其中一个被违反的约束添加到工作集中。\n2.  **检查对偶可行性：** 如果 $\\sigma_{k+1}$ 是原始可行的，我们检查乘子 $\\lambda_{\\mathcal{W}_k}$ 的符号。如果对于 $j \\in \\mathcal{W}_k$ 有任何乘子 $\\lambda_j  -\\text{tol}$，则相应的约束是非约束性的，应从工作集中移除。\n\n### 3. 反循环策略\n\n在退化点，例如多面体屈服面的非光滑角点，可能存在多个关于添加或移除哪个约束的选择。一个朴素或“贪婪”的选择（例如，添加违反最严重的约束，移除具有最负乘子的约束）可能导致算法无限循环地遍历一系列工作集。\n\n为了保证终止，一个严格的破除僵局规则是必要的。**Bland 的反循环规则**，改编自线性规划的单纯形法，提供了这样的保证。它规定应通过选择索引最小的约束来打破僵局。\n\n所实现的算法采用了 Bland 规则：\n- **添加约束：** 如果被违反的非激活约束集合 $\\mathcal{V}$ 非空，则将 $\\mathcal{V}$ 中索引最小的约束添加到工作集中。\n- **移除约束：** 如果具有负乘子的激活约束集合 $\\mathcal{N}$ 非空，则将 $\\mathcal{N}$ 中索引最小的约束从工作集中移除。\n\n问题要求报告此反循环机制是否被调用。这被解释为该机制被主动需要以解决歧义。因此，如果在任何步骤中，需要在多个候选者中选择添加或移除约束（即，如果 $|\\mathcal{V}|  1$ 或 $|\\mathcal{N}|  1$），`anticycle_used` 标志将被设置为 `True`。\n\n### 4. 算法总结\n\n完整的算法如下：\n1.  **初始化：** 给定 $\\sigma^{\\text{trial}}$，定义材料属性（$C$）、屈服面几何形状（$N, r$）和数值容差 `tol`。\n2.  **可行性检查：** 确定 $\\sigma^{\\text{trial}}$ 是否在弹性域内（$N\\sigma^{\\text{trial}} \\le r$）。如果是，则解为 $\\sigma = \\sigma^{\\text{trial}}$，算法终止。\n3.  **初始工作集：** 如果 $\\sigma^{\\text{trial}}$ 是不可行的，用所有被违反的约束的索引来初始化工作集 $\\mathcal{W}$。\n4.  **迭代求精：**\n    a. 针对当前工作集 $\\mathcal{W}$ 求解等式约束子问题，以找到下一个应力迭代值 $\\sigma$ 和乘子 $\\lambda_{\\mathcal{W}}$。\n    b. 检查 $\\mathcal{W}$ 之外是否有被违反的原始约束。如果存在，将索引最小的那个添加到 $\\mathcal{W}$ 中并继续。如果可供选择的超过一个，则设置 `anticycle_used = True`。\n    c. 如果没有原始约束被违反，检查 $\\lambda_{\\mathcal{W}}$ 中是否有负乘子。如果存在，从 $\\mathcal{W}$ 中移除索引最小的对应约束并继续。如果可供选择的超过一个，则设置 `anticycle_used = True`。\n    d. 如果解既是原始可行的也是对偶可行的，则 KKT 条件得到满足。终止循环。\n5.  **输出：** 返回最终应力 $\\sigma$ 和 `anticycle_used` 标志。\n\n此过程保证收敛到该凸二次规划问题的唯一解。", "answer": "```python\nimport numpy as np\n\ndef active_set_solver(sigma_trial, C, N, r, tol=1e-9, max_iter=20):\n    \"\"\"\n    Solves the QP return-mapping problem using an active-set method with\n    Bland's rule for anti-cycling.\n    \n    Args:\n        sigma_trial (np.array): The trial stress vector of shape (3,).\n        C (np.array): The stiffness matrix of shape (3, 3).\n        N (np.array): The matrix of yield surface normals of shape (m, 3).\n        r (np.array): The vector of yield radii of shape (m,).\n        tol (float): Numerical tolerance for checking constraints.\n        max_iter (int): Maximum number of iterations.\n        \n    Returns:\n        tuple: A tuple containing:\n            - np.array: The final elastoplastic stress vector.\n            - bool: A flag indicating if the anti-cycling rule was invoked.\n    \"\"\"\n    anticycle_used = False\n    num_constraints = N.shape[0]\n\n    # Step 2: Initial feasibility check\n    violations = N @ sigma_trial - r\n    if np.max(violations) = tol:\n        return sigma_trial, False\n\n    # Step 3: Initialize working set with all violated constraints\n    working_set = set(np.where(violations > tol)[0])\n    \n    sigma = sigma_trial.copy()\n\n    # Step 4: Iterative refinement\n    for _ in range(max_iter):\n        \n        # 4a: Solve the equality-constrained subproblem\n        if not working_set:\n            # If the working set becomes empty, the unconstrained minimum is feasible.\n            # This happens if the trial point was outside, but its projection\n            # lies strictly inside the feasible set.\n            sigma = sigma_trial\n            break\n\n        w_list = sorted(list(working_set))\n        Nw = N[w_list, :]\n        rw = r[w_list]\n        \n        try:\n            H = Nw @ C @ Nw.T\n            b = Nw @ sigma_trial - rw\n            lambdas_w = np.linalg.solve(H, b)\n        except np.linalg.LinAlgError:\n            # This indicates linearly dependent active constraints, which is\n            # not expected for the given problem's normals.\n            # E.g., trying to activate both sigma_xx=R and sigma_xx=-R.\n            # The initialization logic should prevent this from happening.\n            print(f\"Warning: Singular matrix for trial stress {sigma_trial} and working set {w_list}\")\n            return sigma, anticycle_used\n\n        sigma = sigma_trial - C @ Nw.T @ lambdas_w\n\n        # 4b: Check for primal feasibility violations\n        all_violations = N @ sigma - r\n        inactive_indices = np.array(list(set(range(num_constraints)) - working_set), dtype=int)\n        \n        if inactive_indices.size > 0:\n            inactive_violations = all_violations[inactive_indices]\n            violated_inactive_mask = inactive_violations > tol\n            \n            if np.any(violated_inactive_mask):\n                violated_inactive_indices = inactive_indices[violated_inactive_mask]\n                \n                # Check if anti-cycling rule is needed\n                if len(violated_inactive_indices) > 1:\n                    anticycle_used = True\n                \n                # Bland's rule: add the constraint with the smallest index\n                idx_to_add = np.min(violated_inactive_indices)\n                working_set.add(idx_to_add)\n                continue\n\n        # 4c: Check for dual feasibility violations\n        negative_lambda_mask = lambdas_w  -tol\n        if np.any(negative_lambda_mask):\n            w_array = np.array(w_list)\n            indices_with_neg_lambda = w_array[negative_lambda_mask]\n            \n            # Check if anti-cycling rule is needed\n            if len(indices_with_neg_lambda) > 1:\n                anticycle_used = True\n            \n            # Bland's rule: remove the constraint with the smallest index\n            idx_to_remove = np.min(indices_with_neg_lambda)\n            working_set.remove(idx_to_remove)\n            continue\n\n        # If no violations, KKT conditions are met. Terminate.\n        break\n    else:\n        # This block executes if the for-loop completes without a 'break'\n        print(f\"Warning: Max iterations ({max_iter}) reached for trial stress {sigma_trial}.\")\n\n    return sigma, anticycle_used\n\ndef solve():\n    # Define problem parameters\n    E = 1000.0\n    nu = 0.3\n    R = 100.0\n\n    # Define test cases for trial stress [sigma_xx, sigma_yy, tau_xy]\n    test_cases = [\n        np.array([90.0, 80.0, 20.0]),\n        np.array([150.0, 0.0, 0.0]),\n        np.array([150.0, 150.0, 0.0]),\n        np.array([120.0, 120.0, 120.0]),\n        np.array([100.0, 100.0, 100.0]),\n    ]\n    \n    # Construct elastic stiffness matrix C (inverse of compliance S) for plane stress\n    # S = [[1/E, -nu/E, 0], [-nu/E, 1/E, 0], [0, 0, 1/G]]\n    # G = E / (2*(1+nu))\n    C = np.zeros((3, 3))\n    C_factor = E / (1 - nu**2)\n    C[0, 0] = C_factor\n    C[0, 1] = nu * C_factor\n    C[1, 0] = nu * C_factor\n    C[1, 1] = C_factor\n    C[2, 2] = E / (2 * (1 + nu))\n\n    # Define yield surface normals\n    N = np.array([\n        [1.0, 0.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, -1.0],\n    ])\n    \n    # Define yield limits vector\n    r = np.full(6, R)\n\n    results = []\n    for sigma_trial in test_cases:\n        sigma_final, anticycle_flag = active_set_solver(sigma_trial, C, N, r)\n        result_list = sigma_final.tolist()\n        result_list.append(anticycle_flag)\n        results.append(result_list)\n\n    # Format the output as a single-line Python-style list of lists\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3593072"}]}