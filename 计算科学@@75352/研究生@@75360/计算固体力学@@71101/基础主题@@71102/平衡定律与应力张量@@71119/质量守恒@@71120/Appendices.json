{"hands_on_practices": [{"introduction": "连续介质力学中的质量守恒定律在拉格朗日描述下有一个简洁的表达式，即物质导数为零。然而，在数值模拟中，特别是显式动力学分析中，对连续性方程进行时间离散不可避免地会引入误差。这项实践 ([@problem_id:3550657]) 要求你从基本原理出发，推导一个二阶精度的预估-校正格式来更新密度场，并量化在自适应时间步长下产生的数值“质量漂移”。这项练习对于理解和开发可靠的计算程序至关重要，因为它揭示了数值积分精度与全局守恒律保持之间的直接联系。", "problem": "在计算固体力学中，考虑一个变形杆的一维拉格朗日离散化。设该杆初始占据一个长度为 $L$ 的参考区间，该区间被均匀地划分为 $N$ 个物质点，每个物质点关联一个参考子体积 $\\Delta V_0 = L/N$。初始质量密度是均匀的，等于 $\\rho_0$（单位为 $\\mathrm{kg}/\\mathrm{m}^3$）。速度场使得局部体积应变率（速度的散度）在空间上是均匀的并且是随时间变化的，记作 $s(t)$（单位为 $\\mathrm{s}^{-1}$），并由 $s(t) = k \\cos(\\omega t)$ 给出，其中 $k$ 是一个常数（单位为 $\\mathrm{s}^{-1}$），$\\omega$ 是一个角频率（单位为 $\\mathrm{rad}/\\mathrm{s}$，弧度/秒）。\n\n从任意物质区域的基本质量守恒定律（即该区域内质量的时间导数为零）出发，并使用拉格朗日描述，仅基于以物质时间导数表示的连续性方程，推导一个用于质量密度 $\\rho$ 的预测-校正显式格式。推导必须从第一性原理开始：质量守恒的积分形式和物质导数的定义。不要预先假设任何目标离散公式。作为推导的一部分，定义将参考体积映射到当前体积的变形雅可比行列式 $J$，并利用在拉格朗日框架下，质量守恒意味着在精确时间演化下乘积 $\\rho J$ 的不变性这一事实。\n\n在离散算法中，在每个时间步 $n$，让自适应时间步长 $\\Delta t_n$ 由以下规则控制\n$$\n\\Delta t_n = \\frac{\\Delta t_{\\max}}{1 + \\gamma \\lvert s(t_n) \\rvert},\n$$\n其中 $\\Delta t_{\\max}$（单位为 $\\mathrm{s}$）是一个用户指定的最大时间步长，$\\gamma$（无量纲）是一个自适应系数，$t_n$ 是当前时间。预测-校正格式必须构建为时间上二阶精度，且仅使用在 $t_n$ 和 $t_{n+1} = t_n + \\Delta t_n$ 时刻可用的值。\n\n实现您推导的格式来更新每个时间步的质量密度 $\\rho$ 和变形雅可比行列式 $J$，从 $\\rho(0) = \\rho_0$ 和 $J(0) = 1$ 开始。对于均匀的 $s(t)$，每个物质点都有相同的演化；然而，为了计算总质量，对 $N$ 个参考子体积进行聚合，使用每个子体积的当前质量 $\\rho(t) J(t) \\Delta V_0$。将时间 $t$ 的总质量定义为\n$$\nM(t) = \\sum_{i=1}^{N} \\rho(t) J(t) \\Delta V_0 = \\rho(t) J(t) L,\n$$\n初始质量为 $M(0) = \\rho_0 L$。\n\n对于每次模拟，运行直到最终时间 $T$（单位为 $\\mathrm{s}$），并以无量纲小数形式报告质量漂移\n$$\n\\delta = \\frac{M(T) - M(0)}{M(0)}.\n$$\n将输出 $\\delta$ 表示为小数（不带百分号）。使用以下参数值的测试套件来评估不同自适应时间步长情景下的算法。物理参数必须以其指定的单位进行解释。\n\n- 测试用例 1 (一般情况):\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.2$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 10.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.5$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.005$ $\\mathrm{s}$,\n  - $\\gamma = 2.0$。\n- 测试用例 2 (近常数时间步长和近不可压缩演化):\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.01$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 5.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.2$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.001$ $\\mathrm{s}$,\n  - $\\gamma = 0.5$。\n- 测试用例 3 (在更快的体积振荡下的强自适应性):\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.5$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 30.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.4$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.002$ $\\mathrm{s}$,\n  - $\\gamma = 5.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与给定的测试用例相同，例如 $[\\delta_1,\\delta_2,\\delta_3]$。每个 $\\delta_i$ 必须是上面定义的小数。不应产生任何其他输出。角频率 $\\omega$ 的单位是弧度，所有时间单位都是秒。长度必须是米，密度必须是千克/立方米，如指定。解决方案应是通用的，并且仅依赖于规定的物理定律和定义，从而为指定的测试套件提供正确的算法实现。", "solution": "此问题被评估为有效，因为它科学地基于连续介质力学的原理，问题设定良好，具有明确的目标和足够的数据，并以客观、正式的语言表达。它提出了一个计算力学中标准的、尽管是简化的问​​题，可以通过推导和实现数值方法来解决。\n\n所需数值格式的推导从质量守恒的基本原理开始。\n\n**1. 控制微分方程的推导**\n\n质量守恒定律指出，对于随变形体移动的任意物质体积 $\\mathcal{V}(t)$，其质量随时间保持恒定。此体积中的质量 $M$ 由密度场 $\\rho(\\mathbf{x}, t)$ 在当前体积 $\\mathcal{V}(t)$ 上的积分给出：\n$$ M = \\int_{\\mathcal{V}(t)} \\rho(\\mathbf{x}, t) \\, dV $$\n质量守恒意味着此质量的物质时间导数为零：\n$$ \\frac{dM}{dt} = \\frac{d}{dt} \\int_{\\mathcal{V}(t)} \\rho(\\mathbf{x}, t) \\, dV = 0 $$\n将雷诺输运定理 (Reynolds transport theorem) 应用于随时间变化的物质体积上的积分，我们得到：\n$$ \\frac{d}{dt} \\int_{\\mathcal{V}(t)} \\rho \\, dV = \\int_{\\mathcal{V}(t)} \\left( \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) \\right) dV = 0 $$\n其中 $\\mathbf{v}$ 是速度场。由于这对任意物质体积 $\\mathcal{V}(t)$ 都成立，被积函数必须为零，这便得到其欧拉形式的连续性方程：\n$$ \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) = 0 $$\n展开散度项可得 $\\nabla \\cdot (\\rho \\mathbf{v}) = (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v})$。将其代回，我们有：\n$$ \\frac{\\partial \\rho}{\\partial t} + (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0 $$\n密度的物质时间导数表示物质质点密度的变化率，定义为 $\\frac{D\\rho}{Dt} = \\frac{\\partial \\rho}{\\partial t} + \\mathbf{v} \\cdot \\nabla \\rho$。因此，连续性方程可以在拉格朗日框架中写为：\n$$ \\frac{D\\rho}{Dt} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0 $$\n问题指定体积应变率 $\\nabla \\cdot \\mathbf{v}$ 在空间上是均匀的，并由一个随时间变化的函数 $s(t) = k \\cos(\\omega t)$ 给出。因此，任何物质点密度的控制常微分方程（ODE）是：\n$$ \\frac{D\\rho}{Dt} = -\\rho(t) s(t) $$\n接下来，我们引入变形雅可比行列式 $J$。雅可比行列式 $J$ 定义为变形梯度张量 $\\mathbf{F}$ 的行列式，即 $J = \\det(\\mathbf{F})$。它提供了局部体积变化的度量，通过 $dV = J dV_0$ 将当前构型中的微分体积元素 $dV$ 与其在参考构型中的对应物 $dV_0$ 联系起来。雅可比行列式的物质时间导数由著名的关系式（刘维尔公式, Liouville's formula）给出：\n$$ \\frac{DJ}{Dt} = J (\\nabla \\cdot \\mathbf{v}) $$\n使用给定的体积应变率表达式，雅可比行列式的控制常微分方程是：\n$$ \\frac{DJ}{Dt} = J(t) s(t) $$\n对于精确的连续解，乘积 $\\rho J$ 是一个不变量。这可以通过求其物质时间导数来证明：\n$$ \\frac{D(\\rho J)}{Dt} = J \\frac{D\\rho}{Dt} + \\rho \\frac{DJ}{Dt} = J(-\\rho s(t)) + \\rho(J s(t)) = 0 $$\n由于 $\\rho(0) = \\rho_0$ 和 $J(0) = 1$，我们有 $\\rho(t)J(t) = \\rho_0 J(0) = \\rho_0$ 对于所有时间 $t$。这表示一个物质元素内的质量 $\\rho dV = \\rho J dV_0$ 是守恒的，因为它始终等于初始质量 $\\rho_0 dV_0$。数值格式可能无法完美地保持此不变量，从而导致“质量漂移”。\n\n**2. 预测-校正格式的推导**\n\n我们的任务是推导一个二阶显式预测-校正格式来求解 $\\rho$ 和 $J$ 的两个耦合常微分方程。我们将使用标准的二阶格式——霍恩（Heun）方法。让我们考虑一个通用的一阶常微分方程 $\\dot{y} = f(t, y)$。从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t_n$ 的更新如下：\n\n- **预测步：** 使用前向欧拉方法计算 $y_{n+1}$ 的初始估计值。记为 $y_{n+1}^*$。\n  $$ y_{n+1}^* = y_n + \\Delta t_n f(t_n, y_n) $$\n- **校正步：** 通过平均区间开始处的斜率 $f(t_n, y_n)$ 和使用预测值 $y_{n+1}^*$ 在区间末端得到的斜率，来计算最终值 $y_{n+1}$。这等效于应用梯形法则。\n  $$ y_{n+1} = y_n + \\frac{\\Delta t_n}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}^*) \\right] $$\n\n我们将此方法应用于我们的两个常微分方程。\n\n**对于雅可比行列式 $J$：**\n常微分方程是 $\\dot{J} = J s(t)$，所以 $f(t, J) = J s(t)$。\n- 预测：$J_{n+1}^* = J_n + \\Delta t_n (J_n s(t_n)) = J_n (1 + \\Delta t_n s(t_n))$。\n- 校正：\n  $$ J_{n+1} = J_n + \\frac{\\Delta t_n}{2} \\left[ J_n s(t_n) + J_{n+1}^* s(t_{n+1}) \\right] $$\n  $$ J_{n+1} = J_n + \\frac{\\Delta t_n}{2} \\left[ J_n s(t_n) + J_n(1 + \\Delta t_n s(t_n)) s(t_{n+1}) \\right] $$\n  $$ J_{n+1} = J_n \\left( 1 + \\frac{\\Delta t_n}{2} s(t_n) + \\frac{\\Delta t_n}{2} s(t_{n+1}) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n  $$ J_{n+1} = J_n \\left( 1 + \\frac{\\Delta t_n}{2} (s(t_n) + s(t_{n+1})) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n\n**对于密度 $\\rho$：**\n常微分方程是 $\\dot{\\rho} = -\\rho s(t)$，所以 $f(t, \\rho) = -\\rho s(t)$。\n- 预测：$\\rho_{n+1}^* = \\rho_n + \\Delta t_n (-\\rho_n s(t_n)) = \\rho_n (1 - \\Delta t_n s(t_n))$。\n- 校正：\n  $$ \\rho_{n+1} = \\rho_n + \\frac{\\Delta t_n}{2} \\left[ (-\\rho_n s(t_n)) + (-\\rho_{n+1}^* s(t_{n+1})) \\right] $$\n  $$ \\rho_{n+1} = \\rho_n - \\frac{\\Delta t_n}{2} \\left[ \\rho_n s(t_n) + \\rho_n(1 - \\Delta t_n s(t_n)) s(t_{n+1}) \\right] $$\n  $$ \\rho_{n+1} = \\rho_n \\left( 1 - \\frac{\\Delta t_n}{2} (s(t_n) + s(t_{n+1})) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n这两个更新公式构成了用于 $\\rho$ 和 $J$ 的最终数值格式。\n\n**3. 数值算法与评估**\n\n模拟从 $t=0$ 迭代进行到最终时间 $T$。\n1.  初始化状态变量：$t \\leftarrow 0$，$\\rho \\leftarrow \\rho_0$，$J \\leftarrow 1$。\n2.  当 $t < T$ 时循环：\n    a. 设当前时间为 $t_n=t$。\n    b. 计算应变率 $s(t_n) = k \\cos(\\omega t_n)$。\n    c. 计算自适应时间步长：$\\Delta t_n = \\frac{\\Delta t_{\\max}}{1 + \\gamma \\lvert s(t_n) \\rvert}$。\n    d. 为确保模拟在 $T$ 时刻精确结束，如果 $t_n + \\Delta t_n > T$，则将时间步长调整为 $\\Delta t_n = T - t_n$。\n    e. 计算步长结束时的时间：$t_{n+1} = t_n + \\Delta t_n$。\n    f. 计算未来时间的应变率：$s(t_{n+1}) = k \\cos(\\omega t_{n+1})$。\n    g. 使用推导的预测-校正公式将 $\\rho$ 和 $J$ 更新到它们在 $t_{n+1}$ 的值。\n    h. 更新当前时间：$t \\leftarrow t_{n+1}$。\n3.  循环终止后，最终值为 $\\rho(T)$ 和 $J(T)$。\n4.  计算质量漂移 $\\delta$。时间 $t$ 的总质量是 $M(t) = \\rho(t) J(t) L$。初始质量是 $M(0) = \\rho_0 L$。漂移为：\n    $$ \\delta = \\frac{M(T) - M(0)}{M(0)} = \\frac{\\rho(T)J(T)L - \\rho_0 L}{\\rho_0 L} = \\frac{\\rho(T)J(T)}{\\rho_0} - 1 $$\n    请注意，参数 $L$ 和 $N$ 是物理概念化的一部分，但由于问题的空间均匀性和抵消效应，它们不影响无量纲漂移 $\\delta$ 的最终值。\n\n实现将遵循此算法来处理所提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a predictor-corrector scheme for mass conservation\n    in computational solid mechanics and calculates the numerical mass drift.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.2, 'omega': 10.0,\n            'T': 0.5, 'dt_max': 0.005, 'gamma': 2.0\n        },\n        # Test case 2 (near-constant time step and near-incompressible evolution)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.01, 'omega': 5.0,\n            'T': 0.2, 'dt_max': 0.001, 'gamma': 0.5\n        },\n        # Test case 3 (strong adaptivity under faster volumetric oscillations)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.5, 'omega': 30.0,\n            'T': 0.4, 'dt_max': 0.002, 'gamma': 5.0\n        },\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Extract parameters for the current simulation\n        rho_0 = params['rho_0']\n        k = params['k']\n        omega = params['omega']\n        T = params['T']\n        dt_max = params['dt_max']\n        gamma = params['gamma']\n        \n        # Initialize simulation variables\n        t = 0.0\n        rho = rho_0\n        J = 1.0\n        \n        # Volumetric strain rate function\n        def s(time):\n            return k * np.cos(omega * time)\n            \n        # Set a small epsilon for floating point comparisons with the final time T\n        epsilon = 1e-9\n        \n        # Time-stepping loop\n        while t < T - epsilon:\n            # State at the beginning of the step (t_n)\n            t_n = t\n            rho_n = rho\n            J_n = J\n            \n            s_n = s(t_n)\n            \n            # Calculate adaptive time step\n            dt = dt_max / (1.0 + gamma * np.abs(s_n))\n            \n            # Ensure the final step lands exactly on T\n            if t_n + dt > T:\n                dt = T - t_n\n                \n            t_n_plus_1 = t_n + dt\n            \n            # Strain rate at the end of the step (t_{n+1})\n            s_n_plus_1 = s(t_n_plus_1)\n            \n            # Apply the second-order predictor-corrector (Heun's method) updates\n            common_term_1 = 0.5 * dt * (s_n + s_n_plus_1)\n            common_term_2 = 0.5 * (dt**2) * s_n * s_n_plus_1\n            \n            # Update density\n            rho = rho_n * (1.0 - common_term_1 + common_term_2)\n            \n            # Update Jacobian\n            J = J_n * (1.0 + common_term_1 + common_term_2)\n            \n            # Advance time\n            t = t_n_plus_1\n\n        # Calculate mass drift\n        # The conserved quantity in the exact solution is rho * J.\n        # Initial value: rho_0 * J(0) = rho_0 * 1.0\n        # Final value: rho(T) * J(T)\n        delta = (rho * J - rho_0) / rho_0\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3550657"}, {"introduction": "从时间积分转向空间离散，我们在有限元方法 (FEM) 中面临新的挑战。为了解决体积锁定等数值问题，工程实践中常采用选择性减缩积分技术，但这可能引入非物理的人工模式。这项实践 ([@problem_id:3550637]) 让你深入探究这一现象，即减缩积分如何在保持单元平均质量守恒的同时，催生出虚假的局部密度“沙漏”模式。通过这个练习，你将学会如何识别这些 spurious modes，并实现一种稳定化方案来抑制它们，从而确保模拟结果的物理真实性。", "problem": "考虑一个二维双线性四边形有限元，在其参考构型中占据一个单位正方形区域，面积为 $A_0 = 1\\,\\mathrm{m}^2$，厚度为单位米。设四个节点位于参数坐标 $(\\xi,\\eta) \\in \\{-1,1\\} \\times \\{-1,1\\}$ 处，顺序为：节点 1 在 $(-1,-1)$，节点 2 在 $(1,-1)$，节点 3 在 $(1,1)$，节点 4 在 $(-1,1)$。设每个节点 $i=1,\\dots,4$ 的节点体积应变值被指定为 $\\theta_i$，这被理解为小应变极限下位移场散度的最佳可用离散近似。在小应变范围内，变形梯度的雅可比行列式满足 $J \\approx 1 + \\theta$。质量守恒定律表明，当前质量密度 $\\rho$ 和参考质量密度 $\\rho_0$ 满足点态关系 $\\rho\\,J = \\rho_0$。\n\n在对体积约束采用选择性减缩积分的混合有限元格式中，$J \\approx 1$ 的施加仅使用单元中心 $(\\xi,\\eta)=(0,0)$ 来执行，而偏响应则可能用更多点进行积分。这种选择性施加可能会引入伪体积模式，这些模式不改变单元平均值，但在局部振荡，从而可能在保持单元平均约束的同时产生伪密度变化。\n\n您的任务是实现一个程序，对于单个双线性单元给定的一组节点体积应变模式 $\\{\\theta_i\\}_{i=1}^4$，严格基于基本原理执行以下步骤：\n\n1. 使用双线性形函数在单元上插值体积应变场。设双线性形函数为\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n插值后的体积应变为\n$$\n\\theta(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\theta_i.\n$$\n设置 $J(\\xi,\\eta) = 1 + \\theta(\\xi,\\eta)$，参考密度为 $\\rho_0 = 1000\\,\\mathrm{kg/m^3}$。\n\n2. 通过在单元中心 $(\\xi,\\eta)=(0,0)$ 处计算雅可比行列式，定义减缩（单点）施加的密度 $\\rho_{\\mathrm{red}}$：\n$$\nJ_c = J(0,0),\\quad \\rho_{\\mathrm{red}} = \\frac{\\rho_0}{J_c}.\n$$\n这对应于仅使用中心点来施加体积约束。\n\n3. 通过在标准的 $2\\times 2$ 高斯积分点集上计算质量守恒残差，来量化伪密度模式。使用高斯点 $(\\xi_g,\\eta_g)$，其中 $\\xi_g,\\eta_g\\in\\{-1/\\sqrt{3},\\,1/\\sqrt{3}\\}$，每个点的权重为 $w_g = 1$。在每个高斯点，计算\n$$\nr_g^{\\mathrm{red}} = \\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g) - \\rho_0,\n$$\n以及残差的方差\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 \\left(r_g^{\\mathrm{red}} - \\bar{r}^{\\mathrm{red}}\\right)^2,\\quad \\bar{r}^{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 r_g^{\\mathrm{red}}.\n$$\n同时报告减缩施加与全积分平均值之间的差异：\n$$\n\\Delta J = J_c - \\bar{J},\\quad \\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 J(\\xi_g,\\eta_g).\n$$\n使用小应变近似计算单元质量\n$$\nm_{\\mathrm{red}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g)\\,A_0/4,\n$$\n以及质量误差\n$$\ne_m^{\\mathrm{red}} = m_{\\mathrm{red}} - \\rho_0\\,A_0.\n$$\n将 $m_{\\mathrm{red}}$ 以 $\\mathrm{kg}$ 表示，$e_m^{\\mathrm{red}}$ 以 $\\mathrm{kg}$ 表示。\n\n4. 提出并实现一种稳定化方法，该方法在减少伪密度残差的同时保持质量。考虑在高斯点上进行以下保质量混合：\n$$\n\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g) = \\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J(\\xi_g,\\eta_g)} - \\frac{\\rho_0}{\\bar{J}}\\right),\n$$\n其中 $\\beta\\in[0,1]$ 是一个稳定化参数，$\\bar{J}$ 是 $2\\times 2$ 高斯积分的平均值。证明此选择保持单元质量，即，\n$$\n\\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g)\\,A_0/4 = \\rho_0\\,A_0,\n$$\n对于任何 $\\beta\\in[0,1]$，并减少残差方差。用 $\\beta=0.75$ 实现此方法。计算\n$$\nr_g^{\\mathrm{stab}} = \\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g) - \\rho_0,\\quad\n\\mathrm{Var}_{\\mathrm{stab}} = \\frac{1}{4}\\sum_{g=1}^4 \\left(r_g^{\\mathrm{stab}} - \\bar{r}^{\\mathrm{stab}}\\right)^2,\n$$\n以及质量误差\n$$\ne_m^{\\mathrm{stab}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g)\\,A_0/4 - \\rho_0\\,A_0.\n$$\n\n5. 使用以下节点体积应变模式（无量纲）的测试套件来评估上述各量。对于每种情况，设置单元面积 $A_0 = 1\\,\\mathrm{m^2}$ 和参考密度 $\\rho_0 = 1000\\,\\mathrm{kg/m^3}$：\n- 情况1（均匀压缩，理想工况）：$\\theta = [-0.02,-0.02,-0.02,-0.02]$。\n- 情况2（近不可压缩沙漏，边界情况）：$\\theta = [10^{-6},-10^{-6},10^{-6},-10^{-6}]$。\n- 情况3（中等沙漏，伪模式）：$\\theta = [0.05,-0.05,0.05,-0.05]$。\n- 情况4（强沙漏，物理合理性范围内的极端情况）：$\\theta = [0.2,-0.2,0.2,-0.2]$。\n\n6. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含四个值的列表：\n$$\n\\left[\\Delta J,\\ \\mathrm{Var}_{\\mathrm{red}},\\ \\mathrm{Var}_{\\mathrm{stab}},\\ e_m^{\\mathrm{red}}\\right].\n$$\n第一个量 $\\Delta J$ 是无量纲的，方差的单位是 $(\\mathrm{kg/m^3})^2$，质量误差的单位是 $\\mathrm{kg}$。最后一行必须具有以下形式\n$$\n\\big[\\,[d_1,v_{r1},v_{s1},e_{m1}],\\ [d_2,v_{r2},v_{s2},e_{m2}],\\ [d_3,v_{r3},v_{s3},e_{m3}],\\ [d_4,v_{r4},v_{s4},e_{m4}]\\,\\big].\n$$", "solution": "该问题被验证为科学上合理、适定且自洽。它使用既定原理和清晰定义，探讨了计算固体力学中的一个标准课题——有限元分析中由选择性减缩积分产生的伪模式。我们继续进行求解。\n\n问题的核心是分析在双线性四边形单元中对应变能的体积部分使用单点积分（选择性减缩积分）的后果，并评估一种稳定化技术。该分析取决于双线性形函数及其在参考域上积分的性质。\n\n节点体积应变 $\\{\\theta_i\\}_{i=1}^4$ 使用双线性形函数 $N_i(\\xi,\\eta)$ 在单元上进行插值：\n$$\n\\theta(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\theta_i\n$$\n代入给定的形函数并合并各项，得到一个关于 $\\xi$ 和 $\\eta$ 的双线性多项式：\n$$\n\\theta(\\xi,\\eta) = c_0 + c_1\\xi + c_2\\eta + c_3\\xi\\eta\n$$\n其中系数是节点值的线性组合：\n$c_0 = \\frac{1}{4}(\\theta_1+\\theta_2+\\theta_3+\\theta_4)$\n$c_1 = \\frac{1}{4}(-\\theta_1+\\theta_2+\\theta_3-\\theta_4)$\n$c_2 = \\frac{1}{4}(-\\theta_1-\\theta_2+\\theta_3+\\theta_4)$\n$c_3 = \\frac{1}{4}(\\theta_1-\\theta_2+\\theta_3-\\theta_4)$\n\n变形梯度的雅可比行列式的小应变近似为 $J(\\xi,\\eta) = 1 + \\theta(\\xi,\\eta)$。\n\n减缩积分方案在单元中心 $(\\xi,\\eta)=(0,0)$ 处计算雅可比行列式，以定义一个单一的、单元整体的密度。\n中心点的雅可比行列式为：\n$$\nJ_c = J(0,0) = 1 + \\theta(0,0) = 1 + c_0\n$$\n相应的减缩施加密度 $\\rho_{\\mathrm{red}}$ 在整个单元上是恒定的：\n$$\n\\rho_{\\mathrm{red}} = \\frac{\\rho_0}{J_c} = \\frac{\\rho_0}{1+c_0}\n$$\n\n为评估此近似的质量，我们将其与使用标准 $2\\times2$ 高斯积分规则计算的平均雅可比行列式 $\\bar{J}$ 进行比较。高斯点为 $(\\xi_g, \\eta_g)$，其中 $\\xi_g, \\eta_g \\in \\{\\pm a\\}$，$a=1/\\sqrt{3}$，所有权重均为 $w_g=1$。平均雅可比行列式为：\n$$\n\\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 w_g J(\\xi_g,\\eta_g) = \\frac{1}{4}\\sum_{g=1}^4 (1 + c_0 + c_1\\xi_g + c_2\\eta_g + c_3\\xi_g\\eta_g)\n$$\n由于高斯点的对称性，关于 $\\xi$ 或 $\\eta$ 的线性项之和为零：$\\sum \\xi_g = 0$ 且 $\\sum \\eta_g = 0$。对于双线性四边形单元，$2\\times2$ 高斯积分规则能将项 $c_3\\xi\\eta$ 精确地积分为其在单元上的真实平均值，即零。具体来说，$\\sum \\xi_g \\eta_g = a^2 - a^2 - a^2 + a^2 = 0$。因此，该和简化为：\n$$\n\\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 (1 + c_0) = \\frac{1}{4} \\cdot 4(1+c_0) = 1+c_0\n$$\n因此，对于未扭曲（矩形）域上的双线性单元，我们得出了一个关键结果，即 $J_c = \\bar{J}$。这直接意味着要报告的第一个量 $\\Delta J$ 对所有测试用例都恒等于零：\n$$\n\\Delta J = J_c - \\bar{J} = 0\n$$\n这个结果特定于理想几何形状和双线性插值；对于扭曲的单元，这个等式将不成立。\n\n接下来，我们为减缩方案在每个高斯点 $g$ 处计算质量守恒残差：\n$$\nr_g^{\\mathrm{red}} = \\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g) - \\rho_0 = \\frac{\\rho_0}{J_c} J(\\xi_g,\\eta_g) - \\rho_0\n$$\n单元上的平均残差为：\n$$\n\\bar{r}^{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 r_g^{\\mathrm{red}} = \\frac{1}{4}\\left(\\frac{\\rho_0}{J_c} \\sum_{g=1}^4 J_g - 4\\rho_0\\right) = \\frac{\\rho_0}{J_c}\\left(\\frac{1}{4}\\sum_{g=1}^4 J_g\\right) - \\rho_0 = \\frac{\\rho_0}{J_c}\\bar{J} - \\rho_0\n$$\n由于 $J_c = \\bar{J}$，平均残差总是为零：$\\bar{r}^{\\mathrm{red}} = 0$。\n残差的方差，它量化了伪振荡，则为：\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}} - \\bar{r}^{\\mathrm{red}})^2 = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}})^2\n$$\n代入 $r_g^{\\mathrm{red}}$ 的表达式并使用 $J_c=1+c_0$：\n$$\nr_g^{\\mathrm{red}} = \\frac{\\rho_0}{1+c_0} (1+c_0+c_1\\xi_g+c_2\\eta_g+c_3\\xi_g\\eta_g) - \\rho_0 = \\frac{\\rho_0}{1+c_0}(c_1\\xi_g+c_2\\eta_g+c_3\\xi_g\\eta_g)\n$$\n方差是通过对这四项在高斯点上的平方求和来计算的。在平方和中的交叉项（例如 $2c_1c_2\\xi_g\\eta_g$）在对称的高斯点模式上求和为零。推导出的最终方差公式为：\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\left(\\frac{\\rho_0}{1+c_0}\\right)^2 \\left( \\frac{1}{3}(c_1^2+c_2^2) + \\frac{1}{9}c_3^2 \\right)\n$$\n减缩方案下的总单元质量通过数值积分计算：\n$$\nm_{\\mathrm{red}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g)\\,\\frac{A_0}{4} = \\frac{A_0}{4} \\rho_{\\mathrm{red}} \\sum_{g=1}^4 J_g = A_0 \\rho_{\\mathrm{red}} \\bar{J}\n$$\n同样，由于 $J_c = \\bar{J}$ 且 $\\rho_{\\mathrm{red}} = \\rho_0/J_c$，质量是精确守恒的：\n$$\nm_{\\mathrm{red}} = A_0 \\frac{\\rho_0}{J_c} J_c = \\rho_0 A_0\n$$\n因此，质量误差也恒等于零：$e_m^{\\mathrm{red}} = m_{\\mathrm{red}} - \\rho_0 A_0 = 0$。\n\n所提出的稳定化方法在每个高斯点引入了一个混合密度：\n$$\n\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g) = \\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J(\\xi_g,\\eta_g)} - \\frac{\\rho_0}{\\bar{J}}\\right)\n$$\n我们可以证明该方案是保质量的。稳定化后的质量是：\n$$\nm_{\\mathrm{stab}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(g)\\,J(g)\\,\\frac{A_0}{4} = \\frac{A_0}{4} \\sum_{g=1}^4 \\left[\\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J_g} - \\frac{\\rho_0}{\\bar{J}}\\right)\\right]J_g\n$$\n$$\nm_{\\mathrm{stab}} = \\frac{A_0}{4} \\left( \\rho_{\\mathrm{red}}\\sum J_g + \\beta\\sum\\left(\\rho_0 - \\frac{\\rho_0 J_g}{\\bar{J}}\\right) \\right) = \\frac{A_0}{4} \\left( 4\\rho_{\\mathrm{red}}\\bar{J} + \\beta\\left(4\\rho_0 - \\frac{\\rho_0}{\\bar{J}}\\sum J_g\\right) \\right)\n$$\n$$\nm_{\\mathrm{stab}} = \\frac{A_0}{4} \\left( 4\\rho_{\\mathrm{red}}\\bar{J} + \\beta\\left(4\\rho_0 - \\frac{\\rho_0}{\\bar{J}}4\\bar{J}\\right) \\right) = A_0 \\rho_{\\mathrm{red}}\\bar{J} = m_{\\mathrm{red}} = \\rho_0 A_0\n$$\n因此，稳定化质量误差 $e_m^{\\mathrm{stab}}$ 也为零。\n\n在高斯点上的稳定化残差为 $r_g^{\\mathrm{stab}} = \\rho_{\\mathrm{stab}}(g)J_g - \\rho_0$。使用 $\\rho_{\\mathrm{stab}}$ 的定义和 $J_c=\\bar{J}$：\n$$\nr_g^{\\mathrm{stab}} = \\left[\\frac{\\rho_0}{\\bar{J}} + \\beta\\left(\\frac{\\rho_0}{J_g} - \\frac{\\rho_0}{\\bar{J}}\\right)\\right]J_g - \\rho_0 = \\rho_0\\left(\\frac{J_g}{\\bar{J}} + \\beta\\left(1 - \\frac{J_g}{\\bar{J}}\\right) - 1\\right)\n$$\n$$\nr_g^{\\mathrm{stab}} = \\rho_0(1-\\beta)\\left(\\frac{J_g}{\\bar{J}}-1\\right) = (1-\\beta)r_g^{\\mathrm{red}}\n$$\n这个优雅的结果表明，稳定化方案将局部质量残差统一按因子 $(1-\\beta)$ 进行了缩减。由于平均残差 $\\bar{r}^{\\mathrm{red}}$ 为零，$\\bar{r}^{\\mathrm{stab}}$ 也为零。因此，方差被缩减了 $(1-\\beta)^2$ 倍：\n$$\n\\mathrm{Var}_{\\mathrm{stab}} = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{stab}})^2 = (1-\\beta)^2 \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}})^2 = (1-\\beta)^2 \\mathrm{Var}_{\\mathrm{red}}\n$$\n当 $\\beta = 0.75$ 时，我们有 $\\mathrm{Var}_{\\mathrm{stab}} = (0.25)^2 \\mathrm{Var}_{\\mathrm{red}} = 0.0625\\,\\mathrm{Var}_{\\mathrm{red}}$。\n\n算法实现将为每个测试用例计算 $c_0, c_1, c_2, c_3$，然后将它们用于推导出的 $\\mathrm{Var}_{\\mathrm{red}}$ 公式。其他三个所需的输出量 $\\Delta J$, $\\mathrm{Var}_{\\mathrm{stab}}$ 和 $e_m^{\\mathrm{red}}$ 则直接得出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required.\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (uniform compression, happy path)\n        [-0.02, -0.02, -0.02, -0.02],\n        # Case 2 (near-incompressible hourglass, boundary case)\n        [1e-6, -1e-6, 1e-6, -1e-6],\n        # Case 3 (moderate hourglass, spurious mode)\n        [0.05, -0.05, 0.05, -0.05],\n        # Case 4 (strong hourglass, edge case)\n        [0.2, -0.2, 0.2, -0.2],\n    ]\n\n    # Global parameters\n    rho_0 = 1000.0  # kg/m^3\n    beta = 0.75     # stabilization parameter\n\n    results = []\n    for theta_nodes in test_cases:\n        t1, t2, t3, t4 = theta_nodes\n\n        # 1. Compute coefficients of the interpolated strain field\n        # theta(xi, eta) = c0 + c1*xi + c2*eta + c3*xi*eta\n        c0 = 0.25 * (t1 + t2 + t3 + t4)\n        c1 = 0.25 * (-t1 + t2 + t3 - t4)\n        c2 = 0.25 * (-t1 - t2 + t3 + t4)\n        c3 = 0.25 * (t1 - t2 + t3 - t4)\n\n        # 2. Compute J_c and Bar(J) and their difference Delta_J\n        # For a bilinear quad on a rectangular domain, J_c = Bar(J), so Delta_J = 0.\n        J_c = 1.0 + c0\n        delta_J = 0.0\n\n        # 3. Compute the variance of the residuals for the reduced scheme.\n        # Var_red = (rho_0 / J_c)^2 * ( (1/3)*(c1^2 + c2^2) + (1/9)*c3^2 )\n        # This is derived in the solution text.\n        if np.isclose(J_c, 0):\n            # Avoid division by zero, though not expected in these test cases.\n            var_red = float('inf')\n        else:\n            factor = (rho_0 / J_c)**2\n            term = (1.0/3.0) * (c1**2 + c2**2) + (1.0/9.0) * (c3**2)\n            var_red = factor * term\n\n        # 4. Compute the mass error for the reduced scheme.\n        # As derived, for this specific problem setup, the mass error is zero.\n        e_m_red = 0.0\n\n        # 5. Compute the variance for the stabilized scheme.\n        # Var_stab = (1 - beta)^2 * Var_red\n        var_stab = (1.0 - beta)**2 * var_red\n        \n        # Store the results for this case.\n        results.append([delta_J, var_red, var_stab, e_m_red])\n\n    # Format the final output string as specified.\n    # [[d1,vr1,vs1,em1], [d2,vr2,vs2,em2], ...]\n    case_strings = []\n    for res in results:\n        # Format each number in the sublist\n        num_strings = [f\"{val:.12g}\" for val in res]\n        # Join numbers into a sublist string \"[n1,n2,n3,n4]\"\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    # Join all case strings into the final output string\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3550637"}, {"introduction": "最后，我们将理论应用于更高级的场景，例如断裂力学或手术模拟，这些场景中网格的拓扑结构会发生改变。在这些动态拓扑问题中，简单地增删单元或节点很容易破坏系统的总质量守恒。这项实践 ([@problem_id:3550666]) 提供了一个动手指南，用于实现一种质量守恒的切割算法。你将学习如何在参考构型中精确地分割被切割路径穿过的单元，并根据子单元的参考面积重新分配节点质量，以确保即使在复杂的拓扑变化下，系统的总质量也能保持不变。", "problem": "给定一个使用线性三角形单元离散化的二维薄实体，用于有限元法 (FEM)。参考构型是一个离散化为结构化网格的方形域。该材料具有恒定的参考质量密度 $\\rho_0$ 和恒定的厚度 $t$。质量守恒定律指出，在使用参考质量度量的前提下，总质量在任何内部拓拓扑变化（如切割）下保持不变。您的任务是实现一个保守的“手术”切割操作，该操作通过指定的切割折线分割被相交的单元，并重新分配节点集总质量，以使节点质量总和与原始总质量保持相等。切割是在当前（可能已变形的）构型中给出的；为保持质量守恒，您必须严格在参考构型中执行相交和面积计算。\n\n使用的基本原理：\n- 质量守恒意味着每个材料单元的质量是恒定的，等于参考密度乘以参考体积。对于一个薄的平面应力实体，单元质量为 $m_e = \\rho_0 \\, t \\, A_0$，其中 $A_0$ 是参考构型中的单元面积，$\\rho_0$ 是参考密度，$t$ 是厚度。\n- 对于线性三角形单元，一致质量矩阵的行和集总法为每个顶点产生相等的质量贡献；也就是说，一个单元对其三个节点中每一个节点的集总质量贡献为 $m_e / 3$。\n- 在均匀变形梯度 $\\mathbf{F}$ 下，雅可比行列式 $J = \\det \\mathbf{F}$ 通过 $\\rho \\, J = \\rho_0$ 关联当前度量和参考度量，但用于计算的守恒质量度量是 $m_e = \\rho_0 \\, t \\, A_0$，它与 $\\mathbf{F}$ 无关。\n\n要实现的切割模型：\n- 切割由当前构型中的一条折线定义。为了实现质量守恒的分割，对于给定的均匀变形梯度 $\\mathbf{F}$，通过 $\\mathbf{X} = \\mathbf{F}^{-1} \\mathbf{x}$ 将当前构型中的每个折线顶点 $\\mathbf{x}$ 映射到参考构型。对于单位变形情况，即 $\\mathbf{F} = \\mathbf{I}$，切割折线已在参考构型中。\n- 在参考构型中执行分割。对每个切割线段，对每个三角形：\n  - 计算该线段与三角形三条边的交点。只有当交点严格位于线段和边的内部（在容差范围内排除端点），并且线段与边不共线时，才认为是一个真相交。\n  - 如果恰好有两个真相交点，它们必须位于共享一个顶点的三角形的两条不同边上。设共享顶点为 $\\mathbf{V}$，设 $\\mathbf{P}$ 位于边 $(\\mathbf{V}, \\mathbf{V}_1)$ 上，$\\mathbf{Q}$ 位于边 $(\\mathbf{V}, \\mathbf{V}_2)$ 上。用三个子三角形 $(\\mathbf{V}, \\mathbf{P}, \\mathbf{Q})$、$(\\mathbf{V}_1, \\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{V}_1, \\mathbf{Q}, \\mathbf{V}_2)$ 替换原三角形。这种划分在参考构型中精确地保持面积守恒。\n  - 如果真相交点少于两个，或者线段与某条三角形边共线，则不分割该三角形。\n- 逐线段地应用上述过程来处理折线，每处理完一个线段就更新网格。\n\n节点质量重新分配：\n- 在执行完所有切割并细分三角形后，通过对每个子三角形，将其三个顶点（包括任何新创建的节点）的质量贡献量 $\\rho_0 \\, t \\, A_{0,\\text{sub}} / 3$ 进行求和，来计算新的节点集总质量。\n- 新的节点质量总和必须等于从初始网格计算出的原始总质量。所有计算都必须使用参考构型面积。\n\n网格、材料和测试套件：\n- 参考域：单位正方形 $[0,1] \\times [0,1]$，离散化为 $N_x \\times N_y$ 个方形单元格的结构化网格，每个单元格通过从左下到右上的对角线分割成两个三角形。使用 $N_x = 3$ 和 $N_y = 3$，因此有 $(N_x+1)(N_y+1) = 16$ 个节点和 $2 N_x N_y = 18$ 个三角形。\n- 参考质量密度：$\\rho_0 = 7800 \\,\\text{kg/m}^3$。\n- 厚度：$t = 0.01 \\,\\text{m}$。\n- 用于高变形测试的变形梯度：\n  $$\\mathbf{F} = \\begin{bmatrix} 1.8  0.9 \\\\ 0.2  0.7 \\end{bmatrix},$$\n  其行列式为 $J = 1.08$。\n- 定义三个测试用例，每个用例包含当前构型中的一条切割折线和一个变形梯度 $\\mathbf{F}$：\n  1. 理想情况：在无变形情况下，横跨整个域的水平切割。使用 $\\mathbf{F} = \\mathbf{I}$ 和顶点为 $\\{(-0.2, 0.5), (1.2, 0.5)\\}$ 的折线。\n  2. 边界情况：沿着一条现有的网格边进行切割，使得许多线段与三角形边共线；这应该不会导致任何分割。使用 $\\mathbf{F} = \\mathbf{I}$ 和顶点为 $\\{(0, 0), (1, 1)\\}$ 的折线。\n  3. 复杂切割下的高变形：使用上述的 $\\mathbf{F}$ 和当前构型中顶点为 $\\{(-0.2, 0.2), (0.3, 0.6), (0.7, 0.4), (1.2, 0.8)\\}$ 的折线。对于此用例，在执行任何分割之前，使用 $\\mathbf{F}^{-1}$ 将折线映射到参考构型。\n\n要求的输出和单位：\n- 对于每个测试用例，计算切割前总质量与切割后节点质量总和之间的绝对差异，单位均为千克。将每个差异以 $\\text{kg}$ 为单位表示为四舍五入到 $12$ 位小数的十进制浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：$\"[a,b,c]\"$），其中 $a$、$b$ 和 $c$ 分别是测试用例1、2和3的差异，每个值都以 $\\text{kg}$ 为单位四舍五入到 $12$ 位小数。\n\n科学真实性和约束条件：\n- 所有的相交和面积计算都必须在参考构型中进行，以确保在切割过程中参考质量度量的精确守恒。\n- 相交处理必须排除在顶点处的退化相交和共线重叠；只有与边存在恰好两个真相交的三角形才会被分割。\n- 算法必须是确定性的和自包含的。不允许用户输入。", "solution": "用户提供的问题是有效的，因为它基于质量守恒原理，具有科学依据，其算法清晰且具有确定性，在数学上是适定的，并且陈述客观。它展示了计算力学中处理切割等拓扑变化同时保持总质量守恒的标准流程。\n\n解决方案通过实现指定的切割和质量重新分配算法来推进。对于每个测试用例，我们执行以下步骤：\n\n1.  **网格和质量初始化**：为参考单位正方形域 $[0,1] \\times [0,1]$ 生成一个线性三角形单元的结构化网格。该域被离散化为一个 $3 \\times 3$ 的单元格网格，每个单元格被细分为两个三角形，从而产生 $16$ 个节点和 $18$ 个三角形。使用给定的参考密度 $\\rho_0 = 7800 \\,\\text{kg/m}^3$ 和厚度 $t = 0.01 \\,\\text{m}$ 计算此初始构型的总质量。单个单元的质量为 $m_e = \\rho_0 \\, t \\, A_0$，其中 $A_0$ 是单元在参考构型中的面积。初始总质量 $M_{\\text{pre}}$ 是所有单元质量的总和。该值作为质量守恒的基准。\n\n2.  **切割折线变换**：每个测试用例都提供了一个由当前（可能已变形）构型中的顶点定义的切割折线，以及一个相关的均匀变形梯度 $\\mathbf{F}$。为确保质量相对于参考度量是守恒的，所有几何操作（相交、面积计算）都必须在参考构型中进行。因此，给定折线的每个顶点 $\\mathbf{x}$ 通过变换 $\\mathbf{X} = \\mathbf{F}^{-1} \\mathbf{x}$ 映射到其对应的参考位置 $\\mathbf{X}$。如果变形是单位变形（$\\mathbf{F}=\\mathbf{I}$），则折线已在参考构型中。\n\n3.  **迭代网格切割**：算法遍历映射到参考构型的折线的每个线段。对于每个线段，它遍历网格当前状态下的所有三角形。\n    *   **相交检测**：使用一个线段相交例程来查找切割线段与三角形三条边之间的所有“真相交”。真相交被定义为严格发生在切割线段和三角形边内部的交点，并使用数值容差来排除端点和顶点。线段与边共线的情况也被排除。\n    *   **分割准则**：当且仅当切割线段与三角形的边产生恰好两个真相交点时，该三角形才被标记为待分割。这两个交点必须位于共享一个公共顶点的两条不同边上。\n    *   **三角形细分**：如果一个三角形 $(\\mathbf{V}, \\mathbf{V}_1, \\mathbf{V}_2)$ 被分割，交点 $\\mathbf{P}$ 在边 $(\\mathbf{V}, \\mathbf{V}_1)$ 上，交点 $\\mathbf{Q}$ 在边 $(\\mathbf{V}, \\mathbf{V}_2)$ 上，则它被替换为指定的三个新子三角形：$(\\mathbf{V}, \\mathbf{P}, \\mathbf{Q})$、$(\\mathbf{V}_1, \\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{V}_1, \\mathbf{Q}, \\mathbf{V}_2)$。这种细分精确地划分了原始三角形的面积。新的交点 $\\mathbf{P}$ 和 $\\mathbf{Q}$ 被添加到全局节点列表中。使用一个映射来确保在相同几何位置创建的新节点由单个节点索引表示，从而保持网格拓扑结构。\n    *   **网格更新**：在检查完所有三角形与单个切割线段的关系后，更新网格。被分割的原始三角形被移除，新生成的子三角形被添加到网格的单元列表中。这个更新后的网格随后用于处理下一个切割线段。\n\n4.  **切割后质量计算与差异**：在处理完折线的所有线段后，得到最终的网格拓扑。通过对最终网格中所有三角形的贡献求和，计算出切割后的总质量 $M_{\\text{post}}$。对于每个参考面积为 $A_{0,\\text{sub}}$ 的子三角形，其质量 $m_{\\text{sub}} = \\rho_0 \\, t \\, A_{0,\\text{sub}}$ 被计算出来并平均分配给其三个顶点（集总质量），即每个节点 $m_{\\text{sub}}/3$。所有节点质量的总和即为 $M_{\\text{post}}$。\n\n5.  **最终结果**：为每个测试用例计算绝对差异 $|M_{\\text{post}} - M_{\\text{pre}}|$。由于在参考坐标系中采用了保持面积的精确细分方法，该差异预计在浮点精度范围内为零。最终输出是这些差异的列表，格式化为 $12$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A small tolerance for floating-point comparisons and geometric checks.\nTOL = 1e-9\n\ndef triangle_area(p1, p2, p3):\n    \"\"\"Computes the area of a triangle defined by three 2D points.\"\"\"\n    return 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\ndef find_segment_intersection(seg1_p1, seg1_p2, seg2_p1, seg2_p2):\n    \"\"\"\n    Finds the intersection of two line segments.\n    Returns the intersection point if it's a \"proper\" intersection, otherwise None.\n    A proper intersection occurs strictly inside both segments.\n    \"\"\"\n    r = seg1_p2 - seg1_p1\n    s = seg2_p2 - seg2_p1\n    q_minus_p = seg2_p1 - seg1_p1\n\n    denom = np.cross(r, s)\n    \n    # If denominator is close to zero, segments are parallel or colinear.\n    if abs(denom) < TOL:\n        return None\n        \n    u = np.cross(q_minus_p, s) / denom\n    v = np.cross(q_minus_p, r) / denom\n    \n    # A proper intersection must be strictly within both segments.\n    if TOL < u < 1.0 - TOL and TOL < v < 1.0 - TOL:\n        intersection_point = seg1_p1 + u * r\n        return intersection_point\n        \n    return None\n\nclass MeshCutter:\n    \"\"\"\n    Manages the mesh, cutting operations, and mass calculations.\n    \"\"\"\n    def __init__(self, Nx, Ny, rho0, t):\n        self.Nx = Nx\n        self.Ny = Ny\n        self.rho0 = rho0\n        self.t = t\n        self.nodes_orig = None\n        self.triangles_orig = None\n        self._generate_initial_mesh()\n        self.pre_cut_mass = self._calculate_total_mass(self.nodes_orig, self.triangles_orig)\n        \n        self.nodes = None\n        self.triangles = None\n\n    def _generate_initial_mesh(self):\n        \"\"\"Generates the initial structured triangular mesh on the unit square.\"\"\"\n        x = np.linspace(0, 1, self.Nx + 1)\n        y = np.linspace(0, 1, self.Ny + 1)\n        xv, yv = np.meshgrid(x, y)\n        self.nodes_orig = [np.array(p) for p in zip(xv.flatten(), yv.flatten())]\n        \n        self.triangles_orig = []\n        for j in range(self.Ny):\n            for i in range(self.Nx):\n                n00 = j * (self.Nx + 1) + i\n                n10 = j * (self.Nx + 1) + (i + 1)\n                n01 = (j + 1) * (self.Nx + 1) + i\n                n11 = (j + 1) * (self.Nx + 1) + (i + 1)\n                \n                self.triangles_orig.append([n00, n10, n11])\n                self.triangles_orig.append([n00, n11, n01])\n\n    def _calculate_total_mass(self, nodes, triangles):\n        \"\"\"Calculates the total mass of the mesh based on lumped nodal contributions.\"\"\"\n        if not nodes or not triangles:\n            return 0.0\n            \n        nodal_masses = np.zeros(len(nodes))\n        for tri_indices in triangles:\n            p1, p2, p3 = [nodes[i] for i in tri_indices]\n            area = triangle_area(p1, p2, p3)\n            mass_per_element = self.rho0 * self.t * area\n            lumped_mass_per_node = mass_per_element / 3.0\n            for idx in tri_indices:\n                nodal_masses[idx] += lumped_mass_per_node\n        return np.sum(nodal_masses)\n\n    def run_case(self, polyline_current, F_matrix):\n        \"\"\"Runs a single cutting test case.\"\"\"\n        self.nodes = self.nodes_orig[:]\n        self.triangles = [tri[:] for tri in self.triangles_orig]\n\n        if not np.allclose(F_matrix, np.identity(2)):\n            F_inv = np.linalg.inv(F_matrix)\n            ref_polyline = [F_inv @ p for p in polyline_current]\n        else:\n            ref_polyline = polyline_current\n\n        node_map = {tuple(np.round(n, 12)): i for i, n in enumerate(self.nodes)}\n\n        def get_or_add_node(p):\n            p_tuple = tuple(np.round(p, 12))\n            if p_tuple in node_map:\n                return node_map[p_tuple]\n            \n            new_idx = len(self.nodes)\n            self.nodes.append(p)\n            node_map[p_tuple] = new_idx\n            return new_idx\n\n        for i_seg in range(len(ref_polyline) - 1):\n            seg_p1, seg_p2 = ref_polyline[i_seg], ref_polyline[i_seg + 1]\n            \n            newly_created_triangles = []\n            triangles_to_remove_indices = set()\n\n            for i_tri, tri_indices in enumerate(self.triangles):\n                tri_coords = [self.nodes[idx] for idx in tri_indices]\n                \n                intersections = []\n                for j in range(3):\n                    edge_p1_idx, edge_p2_idx = tri_indices[j], tri_indices[(j + 1) % 3]\n                    edge_p1, edge_p2 = tri_coords[j], tri_coords[(j + 1) % 3]\n                    \n                    intersection_pt = find_segment_intersection(seg_p1, seg_p2, edge_p1, edge_p2)\n                    \n                    if intersection_pt is not None:\n                        is_duplicate = any(np.allclose(intersection_pt, existing_pt[1]) for existing_pt in intersections)\n                        if not is_duplicate:\n                            intersections.append(((edge_p1_idx, edge_p2_idx), intersection_pt))\n\n                if len(intersections) == 2:\n                    edge1_indices, P = intersections[0]\n                    edge2_indices, Q = intersections[1]\n\n                    shared_v_idx_set = set(edge1_indices)  set(edge2_indices)\n                    if not shared_v_idx_set:\n                        continue\n                    \n                    V_idx = shared_v_idx_set.pop()\n                    V1_idx = (set(edge1_indices) - {V_idx}).pop()\n                    V2_idx = (set(edge2_indices) - {V_idx}).pop()\n\n                    P_idx = get_or_add_node(P)\n                    Q_idx = get_or_add_node(Q)\n                    \n                    newly_created_triangles.append([V_idx, P_idx, Q_idx])\n                    newly_created_triangles.append([V1_idx, P_idx, Q_idx])\n                    newly_created_triangles.append([V1_idx, Q_idx, V2_idx])\n                    \n                    triangles_to_remove_indices.add(i_tri)\n\n            if triangles_to_remove_indices:\n                self.triangles = [tri for i, tri in enumerate(self.triangles) if i not in triangles_to_remove_indices]\n                self.triangles.extend(newly_created_triangles)\n\n        post_cut_mass = self._calculate_total_mass(self.nodes, self.triangles)\n        discrepancy = abs(post_cut_mass - self.pre_cut_mass)\n        return discrepancy\n\ndef solve():\n    RHO_0 = 7800.0\n    THICKNESS = 0.01\n\n    F_I = np.identity(2)\n    F_high = np.array([[1.8, 0.9], [0.2, 0.7]])\n\n    cut1 = [np.array([-0.2, 0.5]), np.array([1.2, 0.5])]\n    cut2 = [np.array([0.0, 0.0]), np.array([1.0, 1.0])]\n    cut3 = [np.array([-0.2, 0.2]), np.array([0.3, 0.6]), np.array([0.7, 0.4]), np.array([1.2, 0.8])]\n\n    test_cases = [\n        (cut1, F_I),\n        (cut2, F_I),\n        (cut3, F_high)\n    ]\n\n    results = []\n    \n    cutter = MeshCutter(Nx=3, Ny=3, rho0=RHO_0, t=THICKNESS)\n    for polyline, F in test_cases:\n        discrepancy = cutter.run_case(polyline, F)\n        results.append(discrepancy)\n\n    formatted_results = [\"{:.12f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3550666"}]}