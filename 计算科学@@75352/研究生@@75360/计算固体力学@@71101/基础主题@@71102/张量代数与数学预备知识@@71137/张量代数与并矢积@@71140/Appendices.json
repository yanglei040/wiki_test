{"hands_on_practices": [{"introduction": "看起来复杂的张量表达式通常可以简化为我们更熟悉的形式。本练习将演示如何分解一个二阶张量与一个并积的双点积，揭示其与标准矩阵和向量运算的直接关系[@problem_id:3604550]。掌握这项技能对于在进行计算实现之前简化方程，以及更深入地理解其内在结构至关重要。", "problem": "在计算固体力学（CSM）中，二阶张量及其缩并会自然地出现在功、能量和通量的评估中。设 $u, v \\in \\mathbb{R}^{3}$ 为列向量，并设 $A \\in \\mathbb{R}^{3 \\times 3}$ 为一个二阶张量。并矢积 $u \\otimes v$ 是一个二阶张量，其分量为 $(u \\otimes v)_{ij} = u_{i} v_{j}$，二阶张量的双点积 $X:A$ 在爱因斯坦求和约定（ESC）下定义为 $X:A = X_{ij} A_{ij}$。在由克罗内克（Kronecker）$\\delta_{ij}$ 定义的欧几里得度量的笛卡尔坐标系中，使用刚才所述的指标表示法和核心定义，将标量 $(u \\otimes v):A = u_{i} v_{j} A_{ij}$ 化简为由 $u$、$v$ 和 $A$ 构建的标准欧几里得内积形式。简要解释为什么该标量在任何正交基变换下都是不变的。然后，对下列给定的值计算该标量：\n$$\nu = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad\nv = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n-1  3  1 \\\\\n0  1  0\n\\end{pmatrix}.\n$$\n提供精确的标量值（不要四舍五入）。该量是无量纲的；不要报告单位。", "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- `u, v \\in \\mathbb{R}^{3}` 是列向量。\n- `A \\in \\mathbb{R}^{3 \\times 3}` 是一个二阶张量。\n- 并矢积由其分量 `(u \\otimes v)_{ij} = u_{i} v_{j}` 定义。\n- 双点积使用爱因斯坦求和约定（ESC）定义为 `X:A = X_{ij} A_{ij}`。\n- 该空间是一个笛卡尔坐标系，其欧几里得度量由克罗内克（Kronecker）$\\delta_{ij}$ 定义。\n- 待分析的标量是 `(u \\otimes v):A = u_{i} v_{j} A_{ij}`。\n- 为计算提供了以下具体值：\n$$\nu = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad\nv = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n-1  3  1 \\\\\n0  1  0\n\\end{pmatrix}\n$$\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题使用了张量代数和连续介质力学中关于并矢积和双点积的标准、正确的定义。这些运算在计算固体力学（CSM）中是基础。\n- **适定性：** 这是一个适定问题。它要求完成三个不同的任务：一个符号化简、一个性质（不变性）的解释以及一个数值计算。每个任务都提供了所有必要的信息。\n- **客观性：** 问题陈述使用了精确的数学语言，没有主观或含糊不清的术语。\n\n该问题是自洽的、一致的且科学上合理的。它不违反任何无效性标准。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整的解答。\n\n### 解答\n\n设标量为 $S$。问题要求对 $S = (u \\otimes v):A$ 进行化简和求值。\n\n**第1部分：表达式的化简**\n\n根据定义，双点积 `X:A` 是各分量逐元素乘积之和，即 $X_{ij} A_{ij}$。在这里，张量 $X$ 是并矢积 $u \\otimes v$，其分量由 $(u \\otimes v)_{ij} = u_{i} v_{j}$ 给出。\n\n将并矢积的分量代入双点积的定义，我们得到：\n$$\nS = (u \\otimes v):A = (u \\otimes v)_{ij} A_{ij} = u_{i} v_{j} A_{ij}\n$$\n爱因斯坦求和约定意味着对索引 $i$ 和 $j$ 从1到3进行求和。由于分量 $u_i$、$v_j$ 和 $A_{ij}$ 都是标量，它们的乘法是可交换的。我们可以重新排列这些项：\n$$\nS = u_{i} (A_{ij} v_{j})\n$$\n我们识别出括号中的项 $A_{ij} v_{j}$ 是矩阵-向量乘积 $Av$ 的第 $i$ 个分量的定义。让我们定义一个向量 $w$，使得 $w = Av$。$w$ 的分量由 $w_{i} = A_{ij} v_{j}$ 给出。\n\n将此代回 $S$ 的表达式中，我们有：\n$$\nS = u_{i} w_{i}\n$$\n这是向量 $u$ 和 $w$ 的标准欧几里得内积（或点积）的定义。因此，我们可以写成：\n$$\nS = u \\cdot w = u \\cdot (Av)\n$$\n在矩阵表示法中，对于列向量 $u$ 和 $v$ 以及矩阵 $A$，此内积表示为：\n$$\nS = u^{T}(Av)\n$$\n这就是将表达式化简为标准内积形式的所求结果。\n\n**第2部分：在正交基变换下的不变性**\n\n根据定义，标量在基变换下是不变的。我们可以对表达式 $S = u^{T} A v$ 显式地证明这一点。考虑一个从原始（未加撇）坐标系到新的（加撇）坐标系的正交基变换。该变换由一个正交矩阵 $Q$ 表示，它满足 $Q^{T}Q = QQ^{T} = I$，其中 $I$ 是单位矩阵。\n\n向量 $u$ 和 $v$ 以及二阶张量 $A$ 的分量变换如下：\n$$\nu' = Qu, \\quad v' = Qv, \\quad A' = QAQ^{T}\n$$\n新基中的标量 $S'$ 由相同的形式给出：\n$$\nS' = (u')^{T} A' v'\n$$\n将变换规则代入此表达式：\n$$\nS' = (Qu)^{T} (QAQ^{T}) (Qv)\n$$\n使用矩阵乘积转置的性质 $(XY)^{T} = Y^{T}X^{T}$，我们有 $(Qu)^{T} = u^{T}Q^{T}$。\n$$\nS' = (u^{T}Q^{T}) (QAQ^{T}) (Qv)\n$$\n根据矩阵乘法的结合律，我们可以重新组合各项：\n$$\nS' = u^{T} (Q^{T}Q) A (Q^{T}Q) v\n$$\n由于 $Q$ 是一个正交矩阵，因此 $Q^{T}Q = I$。将此代入 $S'$ 的表达式中：\n$$\nS' = u^{T} I A I v = u^{T} A v\n$$\n这恰好是原始基中标量 $S$ 的表达式。因此，$S' = S$，这证明了该标量在任何正交基变换下都是不变的。\n\n**第3部分：标量的计算**\n\n我们需要对给定的 $u$、$v$ 和 $A$ 计算 $S = u^{T}Av$：\n$$\nu = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad\nv = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n-1  3  1 \\\\\n0  1  0\n\\end{pmatrix}\n$$\n首先，我们计算矩阵-向量乘积 $w = Av$：\n$$\nw = Av = \\begin{pmatrix}\n2  -1  0 \\\\\n-1  3  1 \\\\\n0  1  0\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}\n= \\begin{pmatrix}\n(2)(0) + (-1)(1) + (0)(1) \\\\\n(-1)(0) + (3)(1) + (1)(1) \\\\\n(0)(0) + (1)(1) + (0)(1)\n\\end{pmatrix}\n= \\begin{pmatrix}\n-1 \\\\\n4 \\\\\n1\n\\end{pmatrix}\n$$\n接下来，我们计算内积 $S = u^{T}w$：\n$$\nS = u^{T}w = \\begin{pmatrix} 1  1  0 \\end{pmatrix}\n\\begin{pmatrix} -1 \\\\ 4 \\\\ 1 \\end{pmatrix}\n= (1)(-1) + (1)(4) + (0)(1)\n$$\n$$\nS = -1 + 4 + 0 = 3\n$$\n该标量的值是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3604550"}, {"introduction": "尽管符号恒等式是精确的，但它们在计算机的有限精度世界中的行为可能会出人意料。这个动手实践问题要求你首先推导一个涉及两个并积缩并的关键恒等式，然后设计一个数值实验来测试其稳健性[@problem_id:3604592]。通过探索极端尺度或相近数相消的场景，你将获得关于计算精度挑战的实用见解。", "problem": "考虑以下一项计算固体力学任务，重点是张量代数和并矢积。在具有标准基和内积的$3$维欧几里得空间中进行计算。仅使用以下基本定义：分量为 $a_i$ 和 $b_j$ 的向量 $a$ 和 $b$ 的并矢（外）积是二阶张量 $(a \\otimes b)_{ij} = a_i b_j$，两个二阶张量 $A$ 和 $B$ 的双点积为 $A:B = \\sum_{i=1}^{3} \\sum_{j=1}^{3} A_{ij} B_{ij}$，向量 $a$ 和 $b$ 的欧几里得点积为 $a \\cdot b = \\sum_{i=1}^{3} a_i b_i$。严格从这些定义出发，符号推导由向量 $a,b$ 和 $c,d$ 构成的两个并矢张量进行双点积运算所得到的标量。然后，遵循美国电气与电子工程师协会（IEEE）$754$ binary64 标准，设计并实现一个使用 $64$ 位浮点运算的数值实验，以评估有限精度行为。\n\n对于每个测试用例，你的程序必须通过两条路径计算两个标量：\n- 路径 $1$：由所提供的向量构造 $a \\otimes b$ 和 $c \\otimes d$，然后直接根据它们的分量计算双点积 $ (a \\otimes b) : (c \\otimes d)$。\n- 路径 $2$：由所提供的向量计算点积 $a \\cdot c$ 和 $b \\cdot d$，然后计算它们的乘积。\n\n对于每个测试用例，使用以下定义报告路径 $1$ 和路径 $2$ 所得标量之间的相对误差，以避免在退化情况下出现除以零的错误：\n$$\n\\mathrm{rel\\_err} = \\frac{\\left| x - y \\right|}{\\max\\left( \\left| x \\right|, \\left| y \\right|, \\varepsilon \\right)},\n$$\n其中 $x$ 是路径 $1$ 得到的标量，$y$ 是路径 $2$ 得到的标量，$\\varepsilon$ 是 IEEE $754$ binary64 算法的机器精度（无单位）。所有输出均为无单位实数。\n\n测试套件（每一项都是一个由四个$3$维向量 $(a,b,c,d)$ 组成的四元组，旨在探测典型行为、病态条件和边界情况）：\n- 情况 $1$（一般中等量级）：\n  $a = [\\,1.0,\\,2.0,\\,3.0\\,]$, $b = [\\,-1.0,\\,0.0,\\,2.0\\,]$, $c = [\\,0.5,\\,-1.0,\\,4.0\\,]$, $d = [\\,3.0,\\,-2.0,\\,1.0\\,]$。\n- 情况 $2$（带有微小扰动的近乎共线和反平行）：\n  $a = [\\,1.0,\\,0.0,\\,0.0\\,]$, $b = [\\,1.0,\\,0.0,\\,0.0\\,]$, $c = [\\,1.0,\\,10^{-16},\\,0.0\\,]$, $d = [\\,-1.0,\\,10^{-16},\\,0.0\\,]$。\n- 情况 $3$（具有相消的极端尺度，但避免溢出）：\n  $a = [\\,10^{150},\\,-10^{150},\\,10^{150}\\,]$, $b = [\\,10^{150},\\,2\\times 10^{150},\\,-3\\times 10^{150}\\,]$, $c = [\\,10^{-150},\\,-10^{-150},\\,10^{-150}\\,]$, $d = [\\,-10^{-150},\\,4\\times 10^{-150},\\,2\\times 10^{-150}\\,]$。\n- 情况 $4$（精确相消至接近零）：\n  $a = [\\,1.0,\\,1.0,\\,1.0\\,]$, $b = [\\,1.0,\\,-1.0,\\,0.0\\,]$, $c = [\\,1.0,\\,-1.0,\\,0.0\\,]$, $d = [\\,1.0,\\,1.0,\\,0.0\\,]$。\n- 情况 $5$（近乎正交且点积微小）：\n  $a = [\\,1.0,\\,0.0,\\,0.0\\,]$, $b = [\\,0.0,\\,1.0,\\,0.0\\,]$, $c = [\\,10^{-16},\\,1.0,\\,0.0\\,]$, $d = [\\,1.0,\\,10^{-16},\\,0.0\\,]$。\n- 情况 $6$（混合尺度和符号以测试求和与相消）：\n  $a = [\\,0.123456789,\\,-98765.4321,\\,3.1415926535\\,]$, $b = [\\,-2.718281828,\\,1.0,\\,10^{-12}\\,]$, $c = [\\,10^{12},\\,-10^{5},\\,2.0\\,]$, $d = [\\,-3.0,\\,4.0,\\,-5.0\\,]$。\n- 情况 $7$（含零向量的边界情况）：\n  $a = [\\,0.0,\\,0.0,\\,0.0\\,]$, $b = [\\,1.0,\\,2.0,\\,3.0\\,]$, $c = [\\,4.0,\\,5.0,\\,6.0\\,]$, $d = [\\,7.0,\\,8.0,\\,9.0\\,]$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含七个测试用例的相对误差，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots,r_7]$），其中每个 $r_i$ 是一个表示为浮点数的无单位实数。", "solution": "该问题要求对一个张量恒等式进行符号推导，并随后进行数值实验以研究有限精度算法的影响。完整过程详述如下。\n\n首先，我们进行符号推导。任务是求出运算 $(a \\otimes b) : (c \\otimes d)$ 的标量结果，其中 $a$、$b$、$c$ 和 $d$ 是 $3$ 维欧几里得空间中的向量，$\\otimes$ 表示并矢（或外）积，而 $:$ 表示双点积。我们已知分量形式的定义，并将直接使用它们。设向量在标准正交基中的分量表示为：$a = (a_1, a_2, a_3)$，$b = (b_1, b_2, b_3)$，以此类推。\n\n并矢积 $(a \\otimes b)$ 产生一个二阶张量，我们将其记为 $A$。其分量由定义给出：\n$$ A_{ij} = (a \\otimes b)_{ij} = a_i b_j $$\n类似地，并矢积 $(c \\otimes d)$ 产生一个二阶张量 $B$，其分量为：\n$$ B_{ij} = (c \\otimes d)_{ij} = c_i d_j $$\n索引 $i$ 和 $j$ 的范围是从 $1$ 到 $3$。\n\n接下来，我们应用两个二阶张量 $A$ 和 $B$ 的双点积定义：\n$$ A:B = \\sum_{i=1}^{3} \\sum_{j=1}^{3} A_{ij} B_{ij} $$\n将 $A$ 和 $B$ 的分量表达式代入此定义，我们得到：\n$$ (a \\otimes b) : (c \\otimes d) = \\sum_{i=1}^{3} \\sum_{j=1}^{3} (a_i b_j) (c_i d_j) $$\n由于各分量是标量，我们可以在求和式中重新排列各项：\n$$ (a \\otimes b) : (c \\otimes d) = \\sum_{i=1}^{3} \\sum_{j=1}^{3} a_i c_i b_j d_j $$\n$i$ 的求和与 $j$ 的求和是独立的。因此，我们可以将双重求和分解为两个单一求和的乘积：\n$$ (a \\otimes b) : (c \\otimes d) = \\left( \\sum_{i=1}^{3} a_i c_i \\right) \\left( \\sum_{j=1}^{3} b_j d_j \\right) $$\n我们识别出这两个求和是欧几里得点积的定义。第一项是 $a$ 和 $c$ 的点积，第二项是 $b$ 和 $d$ 的点积：\n$$ \\sum_{i=1}^{3} a_i c_i = a \\cdot c $$\n$$ \\sum_{j=1}^{3} b_j d_j = b \\cdot d $$\n将它们代回，我们得到最终的符号恒等式：\n$$ (a \\otimes b) : (c \\otimes d) = (a \\cdot c)(b \\cdot d) $$\n此推导证实，在精确算术中，问题陈述中描述的两条计算路径是等价的。\n\n该数值实验旨在评估此数学恒等式在有限精度算术（特别是 IEEE $754$ binary64 标准）的约束下的成立情况。我们通过两种不同的运算序列来计算同一个概念量。\n\n路径 $1$ 首先构建完整的张量表示，然后执行双点积来计算标量 $x$：\n$1$. 构造张量 $A = a \\otimes b$，这是一个 $3 \\times 3$ 矩阵，其元素为 $A_{ij} = a_i b_j$。\n$2$. 构造张量 $B = c \\otimes d$，这是一个 $3 \\times 3$ 矩阵，其元素为 $B_{ij} = c_i d_j$。\n$3$. 计算双点积 $x = A:B = \\sum_{i=1}^{3} \\sum_{j=1}^{3} A_{ij} B_{ij}$。这涉及对 $9$ 个项的求和。\n\n路径 $2$ 首先计算点积，然后将结果相乘来计算标量 $y$：\n$1$. 计算点积 $p_1 = a \\cdot c = \\sum_{i=1}^{3} a_i c_i$。这是对 $3$ 个项的求和。\n$2$. 计算点积 $p_2 = b \\cdot d = \\sum_{j=1}^{3} b_j d_j$。这也是对 $3$ 个项的求和。\n$3$. 计算最终乘积 $y = p_1 \\cdot p_2$。\n\n关键区别在于运算顺序。路径 $1$ 计算的是乘积之和，而路径 $2$ 计算的是和之积。在浮点运算中，由于舍入误差，这两者不保证相同，尤其是在对数量级差异巨大的数字求和（有效位损失）或中间计算导致灾难性抵消时。\n\n为了量化这种差异，我们计算结果 $x$ 和 $y$ 之间的相对误差。指定的公式是：\n$$ \\mathrm{rel\\_err} = \\frac{\\left| x - y \\right|}{\\max\\left( \\left| x \\right|, \\left| y \\right|, \\varepsilon \\right)} $$\n这里，$\\varepsilon$ 是所用算术标准的机器精度。对于 IEEE $754$ binary64（双精度浮点数），$\\varepsilon = 2^{-52}$，约等于 $2.22 \\times 10^{-16}$。在分母中包含 $\\varepsilon$ 是为了对计算进行正则化，防止在 $x$ 和 $y$ 均为零时出现除以零的情况，并在它们小于 $\\varepsilon$ 时提供一个有意义的误差尺度。\n\n该实现将使用 Python 的 NumPy 库来完成，该库为数组上的线性代数运算提供了遵循指定浮点标准的稳健而高效的函数。并矢积 $a \\otimes b$ 使用 `np.outer(a, b)` 计算。双点积 $A:B$ 等效于矩阵的弗罗贝尼乌斯内积，可通过逐元素相乘后求和来计算，即 `np.sum(A * B)`。点积 $a \\cdot c$ 使用 `np.dot(a, c)` 计算。机器精度 $\\varepsilon$ 通过 `np.finfo(np.float64).eps` 获取。程序将处理七个测试用例，计算相对误差，并按指定格式报告结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem by performing a symbolic\n    derivation and a numerical experiment on tensor products.\n    \"\"\"\n\n    # Get the machine epsilon for IEEE 754 binary64 floating-point arithmetic.\n    epsilon = np.finfo(np.float64).eps\n\n    # Test Suite: Each item is a quadruple of 3-vectors (a, b, c, d).\n    test_cases = [\n        # Case 1: general moderate magnitudes\n        (\n            [1.0, 2.0, 3.0], \n            [-1.0, 0.0, 2.0], \n            [0.5, -1.0, 4.0], \n            [3.0, -2.0, 1.0]\n        ),\n        # Case 2: nearly collinear and antiparallel with tiny perturbations\n        (\n            [1.0, 0.0, 0.0], \n            [1.0, 0.0, 0.0], \n            [1.0, 1e-16, 0.0], \n            [-1.0, 1e-16, 0.0]\n        ),\n        # Case 3: extreme scaling with cancellation but avoiding overflow\n        (\n            [1e150, -1e150, 1e150],\n            [1e150, 2e150, -3e150],\n            [1e-150, -1e-150, 1e-150],\n            [-1e-150, 4e-150, 2e-150]\n        ),\n        # Case 4: exact cancellation to near-zero\n        (\n            [1.0, 1.0, 1.0], \n            [1.0, -1.0, 0.0], \n            [1.0, -1.0, 0.0], \n            [1.0, 1.0, 0.0]\n        ),\n        # Case 5: nearly orthogonal with tiny dot products\n        (\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [1e-16, 1.0, 0.0],\n            [1.0, 1e-16, 0.0]\n        ),\n        # Case 6: mixed scales and signs to test summation and cancellation\n        (\n            [0.123456789, -98765.4321, 3.1415926535],\n            [-2.718281828, 1.0, 1e-12],\n            [1e12, -1e5, 2.0],\n            [-3.0, 4.0, -5.0]\n        ),\n        # Case 7: boundary with a zero vector\n        (\n            [0.0, 0.0, 0.0], \n            [1.0, 2.0, 3.0], \n            [4.0, 5.0, 6.0], \n            [7.0, 8.0, 9.0]\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        a_vec, b_vec, c_vec, d_vec = case\n        \n        # Ensure vectors are numpy arrays with the correct float type\n        a = np.array(a_vec, dtype=np.float64)\n        b = np.array(b_vec, dtype=np.float64)\n        c = np.array(c_vec, dtype=np.float64)\n        d = np.array(d_vec, dtype=np.float64)\n\n        # Route 1: (a ⊗ b) : (c ⊗ d)\n        # Construct the dyadic products (outer products)\n        A = np.outer(a, b)\n        B = np.outer(c, d)\n        # Compute the double contraction (Frobenius inner product)\n        x = np.sum(A * B)\n\n        # Route 2: (a ⋅ c) * (b ⋅ d)\n        # Compute the dot products\n        ac_dot = np.dot(a, c)\n        bd_dot = np.dot(b, d)\n        # Compute the final product\n        y = ac_dot * bd_dot\n\n        # Calculate the relative error using the specified formula\n        numerator = np.abs(x - y)\n        denominator = np.max([np.abs(x), np.abs(y), epsilon])\n        relative_error = numerator / denominator\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3604592"}, {"introduction": "连续介质力学的一个基石是物质坐标系无关性原理，该原理要求物理定律在观察者旋转下保持不变。本练习将这一原理从抽象理论转化为具体的计算验证[@problem_id:3604623]。你将构建一个自动化测试套件，以确认基本的张量运算和范数（特别是涉及并积的运算）在正交变换下保持不变。", "problem": "考虑配备有标准正交标架的三维欧几里得空间 $\\mathbb{R}^3$。令 $Q \\in \\mathbb{R}^{3 \\times 3}$ 为一个表示标准正交标架变换的正交矩阵，即 $Q^\\top Q = I$，其中 $I$ 是单位张量。对于向量 $a,b \\in \\mathbb{R}^3$，定义并矢（外）积 $a \\otimes b \\in \\mathbb{R}^{3 \\times 3}$ 为作用于向量 $v \\in \\mathbb{R}^3$ 的线性映射，其定义为 $(a \\otimes b) v = a \\, (b \\cdot v)$，其中 $\\cdot$ 表示欧几里得内积。二阶张量 $T \\in \\mathbb{R}^{3 \\times 3}$ 的 Frobenius 范数定义为 $\\|T\\|_F = \\sqrt{\\mathrm{trace}(T^\\top T)}$。$\\mathbb{R}^3$ 中的标准基记为 $\\{e_1, e_2, e_3\\}$。\n\n您的任务是实现一个完整的、可运行的程序，该程序仅基于这些定义和标准正交变换的基本性质，自动构建并验证一组张量恒等式。具体而言，对于每个测试用例，您的程序必须：\n- 生成或构造一个标准正交标架 $Q$ 以及 $\\mathbb{R}^3$ 中的向量 $a$ 和 $b$。\n- 对所有 $i,j \\in \\{1,2,3\\}$，构造旋转后的基向量的并矢 $Q e_i \\otimes Q e_j$。\n- 使用数值容差验证从定义中导出的以下陈述：\n    1. 恒等重构：单位张量 $I$ 可表示为任意标准正交基的并矢之和；明确检查 $\\sum_{i=1}^3 q_i \\otimes q_i = I$，其中 $q_i = Q e_i$ 是旋转后的基向量。\n    2. 变换一致性：由旋转后的向量构建并矢与在原始标架中构建并矢后进行变换这两种方式是一致的；明确检查所有 $Q e_i \\otimes Q e_j$ 与 $e_i \\otimes e_j$ 的基变换结果是否一致，并对一般向量对 $(a,b)$ 进行同样检查。\n    3. 标准正交变换下的内积不变性：验证向量的内积被保持。\n    4. 标准正交基变换下的 Frobenius 范数不变性：验证并矢的 Frobenius 范数在标准正交相似变换下不变，并与向量 $a$ 和 $b$ 的欧几里得范数相关。\n\n如果上述所有验证在相应的绝对或 Frobenius 范数意义下满足 $\\varepsilon = 10^{-12}$ 的数值容差，则认为该测试用例通过。不涉及任何物理单位。任何旋转的角度必须以弧度为单位。\n\n请实现以下测试套件，其中包括一般情况、边界情况和边缘情况，以确保覆盖率：\n- 测试用例 1：$Q$ 是使用固定随机种子 $0$ 从高斯矩阵生成的随机旋转；向量 $a$ 和 $b$ 是使用固定随机种子 $123$ 生成的随机高斯向量。\n- 测试用例 2：$Q = I$（单位矩阵）；向量 $a = [0.3,-0.7,1.1]$ 和 $b = [0.5,2.0,-1.5]$。\n- 测试用例 3：$Q$ 是绕 $z$ 轴旋转角度 $\\pi$（以弧度指定），即 $Q = \\mathrm{diag}(-1,-1,1)$；向量 $a = [1.0,2.0,3.0]$ 和 $b = [-1.0,0.0,4.0]$。\n- 测试用例 4：$Q$ 是使用随机种子 $42$ 生成的随机旋转；向量 $a = [0.0,0.0,0.0]$ 是零向量；向量 $b$ 是使用种子 $777$ 生成的随机高斯向量。\n- 测试用例 5：$Q$ 是使用随机种子 $99$ 生成的随机旋转；向量 $a$ 和 $b$ 是使用随机种子 $1001$ 生成的随机高斯向量。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，形式为方括号括起来的逗号分隔列表（例如，“[True,True,False,True,True]”），其中每个条目是一个布尔值，表示相应的测试用例是否通过了所有检查。", "solution": "该问题要求在三维欧几里得空间 $\\mathbb{R}^3$ 中，验证关于向量并矢积和标准正交标架间变换的几个基本张量代数恒等式。解决方案涉及为一组给定的测试用例实施一系列数值检查，每个测试用例由一个正交矩阵 $Q \\in \\mathbb{R}^{3 \\times 3}$ 和两个向量 $a, b \\in \\mathbb{R}^3$ 定义。\n\n首先，我们形式化数学对象和运算。空间为 $\\mathbb{R}^3$，其标准欧几里得内积记为 $\\cdot$。标准正交变换由一个正交矩阵 $Q$ 表示，它满足 $Q^\\top Q = Q Q^\\top = I$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。两个向量 $a, b \\in \\mathbb{R}^3$ 的并矢积是一个二阶张量 $a \\otimes b$。它作用于向量 $v \\in \\mathbb{R}^3$ 的方式定义为 $(a \\otimes b)v = a(b \\cdot v)$。如果向量表示为列矩阵，则 $a \\otimes b$ 的矩阵表示是外积 $ab^\\top$。所有数值计算都将使用此矩阵表示。矩阵 $T$ 的 Frobenius 范数由 $\\|T\\|_F = \\sqrt{\\mathrm{trace}(T^\\top T)}$ 给出。\n\n程序将为每个测试用例执行一系列检查，所有检查都必须通过，该用例才被视为有效。所有数值比较的容差为 $\\varepsilon = 10^{-12}$。\n\n验证步骤基于以下原理：\n\n1.  **从标准正交基重构单位张量：** 单位张量 $I$ 可以表示为任意标准正交基的向量的并矢之和。设 $\\{q_1, q_2, q_3\\}$ 为一个标准正交基，其中 $q_i = Q e_i$ 且 $\\{e_1, e_2, e_3\\}$ 是标准基。待验证的恒等式是 $\\sum_{i=1}^3 q_i \\otimes q_i = I$。在矩阵形式下，这是 $\\sum_{i=1}^3 q_i q_i^\\top = I$。这是成立的，因为如果 $Q$ 是以向量 $q_i$ 为列的矩阵，即 $Q = [q_1 | q_2 | q_3]$，那么该和等于矩阵乘积 $Q Q^\\top$。由于 $Q$ 是正交矩阵，因此 $Q Q^\\top=I$。数值检查将评估 $\\| (\\sum_{i=1}^3 q_i q_i^\\top) - I \\|_F  \\varepsilon$。\n\n2.  **张量变换的一致性：** 在由 $Q$ 表示的基变换下，二阶张量 $T$ 遵循相似变换 $T' = Q T Q^\\top$。我们必须验证，由变换后的向量构成的并矢 $(Qa) \\otimes (Qb)$ 等价于对原始并矢进行变换 $Q (a \\otimes b) Q^\\top$。\n    左侧的矩阵表示是 $(Qa)(Qb)^\\top = Q a b^\\top Q^\\top$。\n    右侧的矩阵表示是 $Q(ab^\\top)Q^\\top$。\n    因此恒等式得到证实。程序通过检查 $\\| (Qa)(Qb)^\\top - Q(ab^\\top)Q^\\top \\|_F  \\varepsilon$ 来进行数值验证，这既适用于标准基向量 $e_i, e_j$，也适用于一般向量 $a, b$。\n\n3.  **内积的不变性：** 根据定义，标准正交变换保持任意两个向量之间的内积。对于向量 $a, b$ 及其变换后的对应向量 $a' = Qa, b' = Qb$，必须有 $a' \\cdot b' = a \\cdot b$。证明如下：$a' \\cdot b' = (Qa)^\\top (Qb) = a^\\top Q^\\top Q b = a^\\top I b = a^\\top b = a \\cdot b$。数值测试将验证 $| (Qa) \\cdot (Qb) - a \\cdot b |  \\varepsilon$。\n\n4.  **Frobenius 范数的不变性：**\n    a. Frobenius 范数在正交相似变换下是不变的，即对于任意正交矩阵 $Q$ 有 $\\|Q T Q^\\top\\|_F = \\|T\\|_F$。证明依赖于迹运算的循环性质：$\\|Q T Q^\\top\\|_F^2 = \\mathrm{trace}((Q T Q^\\top)^\\top (Q T Q^\\top)) = \\mathrm{trace}(Q T^\\top Q^\\top Q T Q^\\top) = \\mathrm{trace}(Q T^\\top I T Q^\\top) = \\mathrm{trace}(Q T^\\top T Q^\\top)$。再次应用循环性质，$\\mathrm{trace}((Q)(T^\\top T Q^\\top)) = \\mathrm{trace}((T^\\top T Q^\\top)(Q)) = \\mathrm{trace}(T^\\top T I) = \\mathrm{trace}(T^\\top T) = \\|T\\|_F^2$。数值检查将评估 $| \\|Q(ab^\\top)Q^\\top\\|_F - \\|ab^\\top\\|_F |  \\varepsilon$。\n    b. 并矢积 $a \\otimes b$ 的 Frobenius 范数等于构成它的向量的欧几里得范数之积，即 $\\|a \\otimes b\\|_F = \\|a\\|_2 \\|b\\|_2$。证明：设 $T = ab^\\top$。则 $\\|T\\|_F^2 = \\mathrm{trace}(T^\\top T) = \\mathrm{trace}((ab^\\top)^\\top (ab^\\top)) = \\mathrm{trace}(b a^\\top a b^\\top)$。由于 $a^\\top a = \\|a\\|_2^2$ 是一个标量，我们有 $\\|T\\|_F^2 = \\mathrm{trace}(b (\\|a\\|_2^2) b^\\top) = \\|a\\|_2^2 \\mathrm{trace}(b b^\\top)$。利用循环性质，$\\mathrm{trace}(b b^\\top) = \\mathrm{trace}(b^\\top b) = \\|b\\|_2^2$。因此，$\\|T\\|_F^2 = \\|a\\|_2^2 \\|b\\|_2^2$，取平方根即可得到结果。数值验证将检查 $| \\|ab^\\top\\|_F - \\|a\\|_2 \\|b\\|_2 |  \\varepsilon$。\n\n实现涉及一个函数，该函数为给定的 $Q$、$a$ 和 $b$ 系统地执行这些检查。随机正交矩阵通过对一个元素从标准正态分布中抽取的 $3 \\times 3$ 矩阵应用 QR 分解来生成。提供的测试用例，包括特定的矩阵、向量和随机种子，被用来驱动验证过程。最终输出是一个布尔值列表，指示每个测试用例的通过/失败状态。", "answer": "```python\nimport numpy as np\n\ndef run_verifications(Q, a, b, tol=1e-12):\n    \"\"\"\n    Verifies a set of tensor identities for a given orthogonal matrix Q and vectors a, b.\n    \n    Args:\n        Q (np.ndarray): A 3x3 orthogonal matrix.\n        a (np.ndarray): A 3-element vector.\n        b (np.ndarray): A 3-element vector.\n        tol (float): The numerical tolerance for all checks.\n        \n    Returns:\n        bool: True if all verifications pass, False otherwise.\n    \"\"\"\n    I = np.identity(3)\n    e_basis = [np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0]), np.array([0.0, 0.0, 1.0])]\n    q_basis = [Q @ e for e in e_basis]\n\n    # Verification 1: Identity reconstruction (I = sum(q_i otimes q_i))\n    sum_dyadics = np.sum([np.outer(q_i, q_i) for q_i in q_basis], axis=0)\n    if np.linalg.norm(sum_dyadics - I, 'fro') >= tol:\n        return False\n\n    # Verification 2: Transformation consistency ((Qa) otimes (Qb) = Q(a otimes b)Q^T)\n    # Part (a): For basis vectors\n    for i in range(3):\n        for j in range(3):\n            e_i, e_j = e_basis[i], e_basis[j]\n            q_i, q_j = q_basis[i], q_basis[j]\n            dyadic_from_rotated = np.outer(q_i, q_j)\n            rotated_dyadic = Q @ np.outer(e_i, e_j) @ Q.T\n            if np.linalg.norm(dyadic_from_rotated - rotated_dyadic, 'fro') >= tol:\n                return False\n    \n    # Part (b): For general vectors a, b\n    a_prime, b_prime = Q @ a, Q @ b\n    dyadic_from_rotated_ab = np.outer(a_prime, b_prime)\n    dyadic_ab = np.outer(a, b)\n    rotated_dyadic_ab = Q @ dyadic_ab @ Q.T\n    if np.linalg.norm(dyadic_from_rotated_ab - rotated_dyadic_ab, 'fro') >= tol:\n        return False\n        \n    # Verification 3: Inner product invariance ((Qa) . (Qb) = a . b)\n    if abs(np.dot(a_prime, b_prime) - np.dot(a, b)) >= tol:\n        return False\n        \n    # Verification 4: Frobenius norm properties\n    # Part (a): Invariance under similarity transformation (||Q T Q^T|| = ||T||)\n    norm_rotated = np.linalg.norm(rotated_dyadic_ab, 'fro')\n    norm_original = np.linalg.norm(dyadic_ab, 'fro')\n    if abs(norm_rotated - norm_original) >= tol:\n        return False\n        \n    # Part (b): Relation to vector norms (||a otimes b|| = ||a|| ||b||)\n    norm_a = np.linalg.norm(a)\n    norm_b = np.linalg.norm(b)\n    # Handle the case where norm_a or norm_b is zero to avoid large relative error\n    # The absolute difference check is robust enough for this.\n    if abs(norm_original - (norm_a * norm_b)) >= tol:\n        return False\n        \n    return True\n\ndef generate_random_Q(seed):\n    \"\"\"Generates a random 3x3 orthogonal matrix from a given seed.\"\"\"\n    rng = np.random.default_rng(seed)\n    A = rng.standard_normal((3, 3))\n    Q, _ = np.linalg.qr(A)\n    return Q\n\ndef generate_random_vector(seed):\n    \"\"\"Generates a random 3-element vector from a given seed.\"\"\"\n    rng = np.random.default_rng(seed)\n    return rng.standard_normal(3)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run verifications, and print results.\n    \"\"\"\n    test_cases_params = [\n        {\n            \"Q_gen\": (generate_random_Q, 0),\n            \"a_gen\": (generate_random_vector, 123),\n            \"b_gen\": (generate_random_vector, 123), # Reusing seed as problem implies shared seed\n            \"b_is_separate\": False,\n        },\n        {\n            \"Q\": np.identity(3),\n            \"a\": np.array([0.3, -0.7, 1.1]),\n            \"b\": np.array([0.5, 2.0, -1.5]),\n        },\n        {\n            \"Q\": np.diag([-1.0, -1.0, 1.0]),\n            \"a\": np.array([1.0, 2.0, 3.0]),\n            \"b\": np.array([-1.0, 0.0, 4.0]),\n        },\n        {\n            \"Q_gen\": (generate_random_Q, 42),\n            \"a\": np.array([0.0, 0.0, 0.0]),\n            \"b_gen\": (generate_random_vector, 777),\n        },\n        {\n            \"Q_gen\": (generate_random_Q, 99),\n            \"a_gen\": (generate_random_vector, 1001),\n            \"b_gen\": (generate_random_vector, 1001), # Reusing seed\n            \"b_is_separate\": False,\n        }\n    ]\n\n    results = []\n    \n    # Correction for Test Case 1 and 5: generate a and b from same RNG but separately.\n    rng_1 = np.random.default_rng(123)\n    a1 = rng_1.standard_normal(3)\n    b1 = rng_1.standard_normal(3)\n    \n    rng_5 = np.random.default_rng(1001)\n    a5 = rng_5.standard_normal(3)\n    b5 = rng_5.standard_normal(3)\n    \n    # Test Case 1\n    Q1 = generate_random_Q(0)\n    results.append(run_verifications(Q1, a1, b1))\n    \n    # Test Case 2\n    Q2 = np.identity(3)\n    a2 = np.array([0.3, -0.7, 1.1])\n    b2 = np.array([0.5, 2.0, -1.5])\n    results.append(run_verifications(Q2, a2, b2))\n\n    # Test Case 3\n    Q3 = np.diag([-1.0, -1.0, 1.0])\n    a3 = np.array([1.0, 2.0, 3.0])\n    b3 = np.array([-1.0, 0.0, 4.0])\n    results.append(run_verifications(Q3, a3, b3))\n\n    # Test Case 4\n    Q4 = generate_random_Q(42)\n    a4 = np.array([0.0, 0.0, 0.0])\n    b4 = generate_random_vector(777)\n    results.append(run_verifications(Q4, a4, b4))\n    \n    # Test Case 5\n    Q5 = generate_random_Q(99)\n    results.append(run_verifications(Q5, a5, b5))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3604623"}]}