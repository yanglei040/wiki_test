{"hands_on_practices": [{"introduction": "在我们将一个状态方程（EoS）用于构建中子星模型之前，首要任务是确保其满足基本的热力学定律。这个练习将引导您完成一个至关重要的自洽性检验。您将首先从热力学第一定律和吉布斯-杜亥姆关系出发，推导出一个连接能量密度 $\\varepsilon$、压强 $P$ 和粒子数密度 $n$ 的恒等式。随后，您将编写一个程序，使用有限差分法对多种EoS表格进行数值验证，从而亲身体会数值误差的来源以及如何识别和量化一个EoS表格中的内在不自洽性 [@problem_id:3592988]。", "problem": "考虑在零温下，由重子数密度 $n$、能量密度 $\\varepsilon(n)$ 和压强 $P(n)$ 表征的单组分重子流体所模拟的冷催化中子星物质。从零温物质的热力学第一定律和 Gibbs-Duhem 关系出发，推导联系微分 $d\\varepsilon$ 与量 $\\varepsilon$、$P$ 和 $n$ 的热力学恒等式。然后，使用有限差分法对表格化的物态方程（EoS; Equation of State）数据实现该恒等式的数值验证。\n\n您必须基于以下基本原理进行推导：\n- 对于单一守恒粒子种类，零温下的热力学第一定律意味着 $d\\varepsilon = \\mu\\,dn$，其中 $\\mu$ 是每个粒子的化学势。\n- 广延变量的 Euler 关系在零温下得出 $\\varepsilon + P = \\mu n$。\n- 对于单组分流体，零温下的 Gibbs-Duhem 关系意味着 $dP = n\\,d\\mu$。\n\n任务：\n1. 从这些原理出发，推导出在零温下关联 $d\\varepsilon$ 与 $\\varepsilon$、$P$ 和 $n$ 的恒等式。\n2. 对于一个具有严格递增 $n_i$ 的表格化 EoS $(n_i, \\varepsilon_i, P_i)$，使用有限差分法实现 $d\\varepsilon/dn$ 的数值近似。对内部点使用二阶中心差分，\n   $$\\left.\\frac{d\\varepsilon}{dn}\\right|_{n_i} \\approx \\frac{\\varepsilon_{i+1} - \\varepsilon_{i-1}}{n_{i+1} - n_{i-1}},$$\n   在端点处使用一阶单边差分：\n   $$\\left.\\frac{d\\varepsilon}{dn}\\right|_{n_0} \\approx \\frac{\\varepsilon_{1} - \\varepsilon_{0}}{n_{1} - n_{0}},\\quad \\left.\\frac{d\\varepsilon}{dn}\\right|_{n_{N-1}} \\approx \\frac{\\varepsilon_{N-1} - \\varepsilon_{N-2}}{n_{N-1} - n_{N-2}}.$$\n3. 使用推导出的恒等式，定义逐点残差\n   $$R_i = \\left.\\frac{d\\varepsilon}{dn}\\right|_{n_i} - \\frac{\\varepsilon_i + P_i}{n_i}.$$\n   计算整个表格中的最大绝对相对失配，\n   $$\\delta_{\\max} = \\max_i \\frac{|R_i|}{\\left|\\dfrac{\\varepsilon_i + P_i}{n_i}\\right|},$$\n   并约定如果需要，在分母上加上一个可忽略的正则化因子 $10^{-30}$ 以避免除以零。\n\n单位：\n- 所有密度 $n$ 以 $\\mathrm{fm}^{-3}$ 为单位报告。\n- 所有能量密度 $\\varepsilon$ 和压强 $P$ 以 $\\mathrm{MeV}\\,\\mathrm{fm}^{-3}$ 为单位报告。\n- 在指定之处，使用 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\,\\mathrm{fm}$、中子静止质量 $m_n = 939.565\\,\\mathrm{MeV}$ 和重子质量 $m_b = 939.000\\,\\mathrm{MeV}$。\n\n测试套件：\n实现四个独立的表格化 EoS 案例，以数值方式验证该恒等式：\n- 案例 A（理想情况，细网格多方体）：一个由 $P(n) = K\\,n^\\Gamma$ 和 $\\varepsilon(n) = m_b n + \\dfrac{K}{\\Gamma - 1} n^\\Gamma$ 定义的冷多方物态方程，其中 $K = 300.0\\,\\mathrm{MeV}\\,\\mathrm{fm}^{\\Gamma - 3}$，$\\Gamma = 2.5$，并且 $n$ 从 $n_{\\min} = 0.02\\,\\mathrm{fm}^{-3}$ 到 $n_{\\max} = 0.90\\,\\mathrm{fm}^{-3}$ 均匀采样 $N = 200$ 个点。\n- 案例 B（边界敏感性，粗网格多方体）：与案例 A 相同的 EoS 参数，但在相同的 $n$ 范围内使用一个包含 $N = 10$ 个点的粗糙均匀网格。\n- 案例 C（实际的简并中子气体）：一个零温相对论性自由中子费米气体。对于每个 $n$，计算费米动量 $k_F = (3\\pi^2 n)^{1/3}$（单位为 $\\mathrm{fm}^{-1}$），转换为能量单位 $k_F^{(\\mathrm{MeV})} = (\\hbar c)\\,k_F$，并定义化学势 $\\mu = \\sqrt{(k_F^{(\\mathrm{MeV})})^2 + m_n^2}$（单位为 $\\mathrm{MeV}$）。自然单位下的能量密度和压强为\n  $$\\varepsilon^{(\\mathrm{MeV}^4)} = \\frac{1}{8\\pi^2}\\left[k_F^{(\\mathrm{MeV})}\\,\\mu\\,(2(k_F^{(\\mathrm{MeV})})^2 + m_n^2) - m_n^4 \\ln\\left(\\frac{k_F^{(\\mathrm{MeV})} + \\mu}{m_n}\\right)\\right],$$\n  $$P^{(\\mathrm{MeV}^4)} = \\frac{1}{24\\pi^2}\\left[k_F^{(\\mathrm{MeV})}\\,\\mu\\,(2(k_F^{(\\mathrm{MeV})})^2 - 3 m_n^2) + 3 m_n^4 \\ln\\left(\\frac{k_F^{(\\mathrm{MeV})} + \\mu}{m_n}\\right)\\right],$$\n  且必须通过除以 $(\\hbar c)^3$ 转换为 $\\mathrm{MeV}\\,\\mathrm{fm}^{-3}$。$n$ 从 $n_{\\min} = 10^{-4}\\,\\mathrm{fm}^{-3}$ 到 $n_{\\max} = 0.16\\,\\mathrm{fm}^{-3}$ 对数采样 $N = 200$ 个点。\n- 案例 D（边缘情况，扰动表格）：从案例 A 的多方体开始，使用一个包含 $N = 150$ 个点的中等网格，然后通过平滑、微小的乘法因子扰动表格化数值：\n  $$\\tilde{\\varepsilon}(n) = \\varepsilon(n)\\left[1 + \\delta \\cos(\\alpha n)\\right],\\quad \\tilde{P}(n) = P(n)\\left[1 + \\delta \\sin(\\alpha n)\\right],$$\n  其中 $\\delta = 10^{-4}$ 和 $\\alpha = 20.0\\,\\mathrm{fm}^3$ 的选择是为了在给定的 $n$ 范围内产生平缓的振荡。\n\n要求的最终输出格式：\n- 您的程序必须按 A、B、C、D 的顺序计算四个测试案例的 $\\delta_{\\max}$。\n- 程序必须生成一行输出，其中包含四个结果，形式为方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个以科学记数法打印的浮点数，小数点后有三位数字（格式如 $a.bcd\\times 10^{\\pm p}$ 显示为 $a.bcd\\mathrm{e}\\pm p$）。这些值是无量纲的，必须以小数形式报告。", "solution": "该问题要求推导一个适用于冷稠密重子物质的热力学恒等式，并使用几个表格化的物态方程（EoS）对其进行数值验证。问题陈述的有效性已经确认了其科学严谨性、完整性和清晰性。我们现在开始解答。\n\n解答分为两部分：首先，对所需热力学恒等式进行解析推导；其次，详细阐述为根据表格化数据验证此恒等式而设计的数值方案。\n\n**1. 热力学恒等式的推导**\n\n我们从为零温（$T=0$）下的单组分重子流体提供的基本热力学关系开始。涉及的变量有重子数密度（$n$）、能量密度（$\\varepsilon$）、压强（$P$）和化学势（$\\mu$）。\n\n问题陈述了三个基本关系：\n1.  对于具有单一守恒粒子类型的系统，在 $T=0$ 时的热力学第一定律：\n    $$d\\varepsilon = \\mu\\,dn$$\n2.  在 $T=0$ 时连接广延变量和强度变量的 Euler 关系：\n    $$\\varepsilon + P = \\mu n$$\n3.  在 $T=0$ 时的 Gibbs-Duhem 关系：\n    $$dP = n\\,d\\mu$$\n\n我们的目标是推导出一个恒等式，将微分 $d\\varepsilon$（或其关于 $n$ 的导数 $d\\varepsilon/dn$）与状态变量 $\\varepsilon$、$P$ 和 $n$ 联系起来。\n\n推导过程是直接的。Euler 关系给出了化学势 $\\mu$ 用其他变量表示的表达式。通过重新排列 Euler 关系 (2)，我们解出 $\\mu$：\n$$\\mu = \\frac{\\varepsilon + P}{n}$$\n这个表达式对于任何非零的重子数密度 $n > 0$ 都有效。\n\n接下来，我们将这个 $\\mu$ 的表达式代入热力学第一定律 (1)：\n$$d\\varepsilon = \\left( \\frac{\\varepsilon + P}{n} \\right) dn$$\n\n为了以更标准的形式得到所需的恒等式，我们可以将其表示为导数 $d\\varepsilon/dn$ 与状态变量之间的关系。两边除以微分 $dn$（对于 $dn \\neq 0$），我们得到热力学恒等式：\n$$\\frac{d\\varepsilon}{dn} = \\frac{\\varepsilon + P}{n}$$\n\n这个恒等式是热力学一致性的直接结果。它意味着对于任何描述零温、单组分物质的有效 EoS，能量密度随数密度变化的速率等于比焓（或化学势）。这为任何给定的 EoS 表格的热力学一致性提供了一个有力的、非平凡的检验。\n\n**2. 数值验证方案**\n\n第二个任务是实现一个数值程序，以验证这个恒等式在四种不同的 EoS 测试案例中的有效性。验证的核心是使用表格化的 EoS $(n_i, \\varepsilon_i, P_i)$ 计算恒等式的两边，并量化它们之间的差异。\n\n左侧（LHS），即 $\\frac{d\\varepsilon}{dn}$，是一个导数，必须从离散数据点进行数值近似。右侧（RHS），即 $\\frac{\\varepsilon + P}{n}$，可以在表格中的每个点直接计算。\n\n**数值微分**\n问题指定了用于在每个网格点 $i$ 近似导数 $\\left.\\frac{d\\varepsilon}{dn}\\right|_{n_i}$ 的有限差分公式：\n-   对于内部点（$i = 1, \\dots, N-2$），使用二阶中心差分公式。当两侧都有相邻点时，此公式提供更准确的近似：\n    $$\\left.\\frac{d\\varepsilon}{dn}\\right|_{n_i} \\approx \\frac{\\varepsilon_{i+1} - \\varepsilon_{i-1}}{n_{i+1} - n_{i-1}}$$\n-   对于第一个点（$i=0$），使用一阶前向差分：\n    $$\\left.\\frac{d\\varepsilon}{dn}\\right|_{n_0} \\approx \\frac{\\varepsilon_{1} - \\varepsilon_{0}}{n_{1} - n_{0}}$$\n-   对于最后一个点（$i=N-1$），使用一阶后向差分：\n    $$\\left.\\frac{d\\varepsilon}{dn}\\right|_{n_{N-1}} \\approx \\frac{\\varepsilon_{N-1} - \\varepsilon_{N-2}}{n_{N-1} - n_{N-2}}$$\n\n这些特定的公式可以使用 `numpy.gradient` 函数高效实现，该函数使用指定的差分方案计算数组的梯度，能正确处理内部点和边界点，并能应对非均匀网格间距。\n\n**量化差异**\n在每个点 $i$ 计算出数值导数 $(\\text{LHS})_i = \\left.\\frac{d\\varepsilon}{dn}\\right|_{n_i}$ 和解析表达式 $(\\text{RHS})_i = \\frac{\\varepsilon_i + P_i}{n_i}$ 后，我们定义逐点残差 $R_i$：\n$$R_i = (\\text{LHS})_i - (\\text{RHS})_i = \\left.\\frac{d\\varepsilon}{dn}\\right|_{n_i} - \\frac{\\varepsilon_i + P_i}{n_i}$$\n如果表格化的 EoS 是完美热力学一致的，并且数值导数是精确的，那么 $R_i$ 将为零。在实践中，由于有限差分近似的截断误差以及 EoS 表格中任何固有的不一致性，$R_i$ 将不为零。\n\n为了提供一个单一的、尺度不变的差异度量，我们计算最大绝对相对失配 $\\delta_{\\max}$：\n$$\\delta_{\\max} = \\max_i \\frac{|R_i|}{\\left|\\dfrac{\\varepsilon_i + P_i}{n_i}\\right|}$$\n在分母上添加一个小的正则化因子 $10^{-30}$，以防止在 RHS 可能为零的情况下出现除以零的错误，尽管对于给定的 EoS 模型，这种情况在物理上不太可能发生。\n\n**测试案例的实现**\n该数值方案将应用于四个不同的测试案例，每个案例都旨在探测数值验证的不同方面。\n\n-   **案例 A（多方 EoS，细网格）**：一个解析上一致的多方 EoS，$P(n) = K n^\\Gamma$ 和 $\\varepsilon(n) = m_b n + \\frac{K}{\\Gamma-1} n^\\Gamma$，在细网格（$N=200$）上采样。由于 EoS 是精确的，失配 $\\delta_{\\max}$ 将完全由有限差分公式的数值误差引起，在细网格上这个误差应该很小。\n\n-   **案例 B（多方 EoS，粗网格）**：与案例 A 相同的 EoS，但在粗网格（$N=10$）上采样。这将测试有限差分近似对网格间距的敏感性。我们预计与案例 A 相比，$\\delta_{\\max}$ 会显著增大，因为截断误差与网格间距成比例（对于中心差分为二次方，对于单边差分为线性）。\n\n-   **案例 C（相对论性费米气体）**：此案例使用一个物理上现实但更复杂的 EoS，用于描述无相互作用的相对论性中子气体。能量密度 $\\varepsilon$ 和压强 $P$ 由涉及费米动量 $k_F = (3\\pi^2 n)^{1/3}$ 的复杂积分表达式给出。所需的计算包括将 $k_F$ 转换为能量单位，并将最终的 $\\varepsilon$ 和 $P$ 从自然单位（$\\mathrm{MeV}^4$）通过除以 $(\\hbar c)^3$ 转换为指定的单位 $\\mathrm{MeV}\\,\\mathrm{fm}^{-3}$。这个 EoS 也是热力学自洽的，因此偏差同样代表数值误差。\n\n-   **案例 D（扰动 EoS）**：此案例从一个一致的多方 EoS 开始，并有意地对表格化的 $\\varepsilon_i$ 和 $P_i$ 值引入小的、平滑的、热力学不自洽的扰动。函数 $\\tilde{\\varepsilon}(n) = \\varepsilon(n)[1 + \\delta \\cos(\\alpha n)]$ 和 $\\tilde{P}(n) = P(n)[1 + \\delta \\sin(\\alpha n)]$（其中 $\\delta=10^{-4}$）将不再满足推导出的恒等式。由此产生的 $\\delta_{\\max}$ 应该不容忽视，其量级与扰动大小 $\\delta$ 相关，反映了所提供表格中存在的真实不一致性。\n\n最终的 Python 代码将实现生成这四个 EoS 表格的函数、一个用于为任何给定表格计算 $\\delta_{\\max}$ 的核心函数，以及一个主程序来协调计算并按指定格式打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem. It generates four EoS test cases,\n    computes the maximum relative mismatch for each, and prints the results.\n    \"\"\"\n    \n    # Define physical constants and parameters\n    HBARC = 197.3269804  # MeV fm\n    M_NEUTRON = 939.565  # MeV\n    M_BARYON = 939.000  # MeV\n    REG_FACTOR = 1e-30 # Regularization factor for division\n\n    def calculate_delta_max(n, eps, p):\n        \"\"\"\n        Calculates the maximum absolute relative mismatch for a given EoS table.\n\n        Args:\n            n (np.ndarray): Baryon number density in fm^-3.\n            eps (np.ndarray): Energy density in MeV fm^-3.\n            p (np.ndarray): Pressure in MeV fm^-3.\n\n        Returns:\n            float: The maximum absolute relative mismatch delta_max.\n        \"\"\"\n        # Calculate the LHS of the identity: d(epsilon)/dn\n        # np.gradient uses 2nd-order central differences for interior points\n        # and 1st-order one-sided differences for boundaries, handling\n        # non-uniform grid spacing correctly, as specified in the problem.\n        d_eps_dn_numerical = np.gradient(eps, n)\n\n        # Calculate the RHS of the identity: (epsilon + P) / n\n        rhs_analytical = (eps + p) / n\n\n        # Calculate the pointwise residual R_i\n        residuals = d_eps_dn_numerical - rhs_analytical\n\n        # Calculate the maximum absolute relative mismatch delta_max\n        # Add a small regularization factor to the denominator to avoid division by zero.\n        relative_mismatch = np.abs(residuals) / (np.abs(rhs_analytical) + REG_FACTOR)\n        delta_max = np.max(relative_mismatch)\n        \n        return delta_max\n\n    def generate_case_A():\n        \"\"\"Generates EoS table for Case A: fine grid polytrope.\"\"\"\n        K = 300.0\n        Gamma = 2.5\n        n = np.linspace(0.02, 0.90, 200)\n        p = K * n**Gamma\n        eps = M_BARYON * n + K / (Gamma - 1.0) * n**Gamma\n        return n, eps, p\n\n    def generate_case_B():\n        \"\"\"Generates EoS table for Case B: coarse grid polytrope.\"\"\"\n        K = 300.0\n        Gamma = 2.5\n        n = np.linspace(0.02, 0.90, 10)\n        p = K * n**Gamma\n        eps = M_BARYON * n + K / (Gamma - 1.0) * n**Gamma\n        return n, eps, p\n\n    def generate_case_C():\n        \"\"\"Generates EoS table for Case C: relativistic Fermi gas.\"\"\"\n        n = np.logspace(np.log10(1e-4), np.log10(0.16), 200)\n        \n        # Fermi momentum in fm^-1\n        kF = (3.0 * np.pi**2 * n)**(1.0/3.0)\n        \n        # Convert to energy units (MeV)\n        kF_mev = kF * HBARC\n        \n        mu = np.sqrt(kF_mev**2 + M_NEUTRON**2)\n        \n        # Expressions for energy density and pressure in MeV^4\n        term1 = kF_mev * mu * (2 * kF_mev**2 + M_NEUTRON**2)\n        term2 = M_NEUTRON**4 * np.log((kF_mev + mu) / M_NEUTRON)\n        eps_mev4 = (1.0 / (8.0 * np.pi**2)) * (term1 - term2)\n        \n        term3 = kF_mev * mu * (2 * kF_mev**2 - 3 * M_NEUTRON**2)\n        term4 = 3 * M_NEUTRON**4 * np.log((kF_mev + mu) / M_NEUTRON)\n        p_mev4 = (1.0 / (24.0 * np.pi**2)) * (term3 + term4)\n        \n        # Convert from MeV^4 to MeV fm^-3\n        eps = eps_mev4 / (HBARC**3)\n        p = p_mev4 / (HBARC**3)\n        \n        return n, eps, p\n\n    def generate_case_D():\n        \"\"\"Generates EoS table for Case D: perturbed polytrope.\"\"\"\n        K = 300.0\n        Gamma = 2.5\n        n = np.linspace(0.02, 0.90, 150)\n        delta = 1e-4\n        alpha = 20.0\n        \n        p_base = K * n**Gamma\n        eps_base = M_BARYON * n + K / (Gamma - 1.0) * n**Gamma\n        \n        # Apply perturbations\n        eps_pert = eps_base * (1.0 + delta * np.cos(alpha * n))\n        p_pert = p_base * (1.0 + delta * np.sin(alpha * n))\n        \n        return n, eps_pert, p_pert\n\n    # --- Main execution logic ---\n    results = []\n\n    # Case A\n    n_a, eps_a, p_a = generate_case_A()\n    results.append(calculate_delta_max(n_a, eps_a, p_a))\n\n    # Case B\n    n_b, eps_b, p_b = generate_case_B()\n    results.append(calculate_delta_max(n_b, eps_b, p_b))\n    \n    # Case C\n    n_c, eps_c, p_c = generate_case_C()\n    results.append(calculate_delta_max(n_c, eps_c, p_c))\n\n    # Case D\n    n_d, eps_d, p_d = generate_case_D()\n    results.append(calculate_delta_max(n_d, eps_d, p_d))\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.3e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3592988"}, {"introduction": "直接对托尔曼-奥本海默-沃尔科夫（TOV）方程进行数值积分在技术上可能具有挑战性，特别是在处理极端密度范围时。一种标准的处理方法是引入无量纲化的变量和重参数化的方程组，例如使用相对论焓作为积分变量。这个练习将让您通过解析推导，掌握如何为一个简化的多方状态方程计算焓，这是理解和实现先进TOV求解器的关键一步 [@problem_id:3592944]。", "problem": "一个处于流体静力学平衡状态的非旋转中子星遵循广义相对论中的托尔曼-奥本海默-沃尔科夫（TOV）方程。在计算核物理学中，将这些方程重新标度为几何化单位并引入无量纲变量，是一种改善数值条件、并实现不同实现之间的跨代码验证的标准技术。考虑一个具有正压物态方程（EOS）$P=K \\rho^{\\Gamma}$的冷中子星，其中$\\rho$是静质量密度，$K0$是多方常数，$\\Gamma1$是绝热指数。总能量密度由$\\epsilon(\\rho)=\\rho+\\frac{P(\\rho)}{\\Gamma-1}$建模，这与冷物质的相对论性$\\Gamma$律物态方程相符。在几何化单位$G=c=1$下进行计算。\n\n从定义TOV系统的广义相对论流体静力学平衡和质量连续性关系式出发，通过使用特征尺度$R_*$和$M_*$对半径$r$和引力质量$m$进行归一化，并用中心能量密度$\\epsilon_c$对压力$P$和能量密度$\\epsilon$进行归一化，来引入无量纲变量。定义无量纲焓变量\n$$\nh(P) \\equiv \\int_{0}^{P} \\frac{dP'}{\\epsilon(P')+P'} ,\n$$\n并选择$R_*$和$M_*$使得用$(x,\\mu,h)$（其中$x \\equiv r/R_*$和$\\mu \\equiv m/M_*$）表示的无量纲TOV系统在其系数中不显式出现$4\\pi$或$\\epsilon_c$。然后，对于上述物态方程，解析地计算$h(P)$，将其表示为$P$，$K$和$\\Gamma$的闭合形式函数。\n\n你的最终答案必须是$h(P)$关于$P$，$K$和$\\Gamma$的单个闭合形式解析表达式。无需四舍五入。焓$h$是无量纲的；不要在最终表达式中包含单位。", "solution": "用户希望为一个特定的相对论性多方物态方程（EOS）找到无量纲焓$h(P)$的闭合形式解析表达式。\n\n### 步骤1：提取已知条件\n- **系统**：一个处于流体静力学平衡状态的非旋转中子星。\n- **框架**：广义相对论，由托尔曼-奥本海默-沃尔科夫（TOV）方程描述。\n- **单位**：几何化单位，其中引力常数$G=1$，光速$c=1$。\n- **物态方程 (EOS)**：压力$P$和静质量密度$\\rho$之间的正压关系，由$P = K \\rho^{\\Gamma}$给出，其中$K  0$且$\\Gamma  1$。\n- **能量密度**：总能量密度$\\epsilon$与静质量密度$\\rho$和压力$P$的关系为$\\epsilon(\\rho) = \\rho + \\frac{P(\\rho)}{\\Gamma-1}$。\n- **无量纲焓**：待计算的量由积分定义\n$$\nh(P) \\equiv \\int_{0}^{P} \\frac{dP'}{\\epsilon(P')+P'}\n$$\n- **任务**：解析地计算此积分，并将$h(P)$表示为$P$，$K$和$\\Gamma$的闭合形式函数。关于无量纲变量$x$，$\\mu$和标度常数$R_*$，$M_*$的背景信息是为了说明$h(P)$的定义动机而提供的，但其计算本身并不需要这些信息。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题进行验证。\n- **科学依据**：该问题完全属于广义相对论天体物理学和计算核物理学领域。TOV方程、多方物态方程以及能量密度的特定形式是描述中子星中冷致密物质的标准（尽管是简化的）模型。焓的定义是求解恒星结构方程数值解时使用的一种已知技术。该问题在科学上是合理的。\n- **适定性**：任务是计算一个特定的定积分，其被积函数和积分路径都已明确定义。参数$K$和$\\Gamma$被限制在使物理模型合理且数学表达式有明确定义的值（$K0$, $\\Gamma1$）。存在唯一且有意义的解。\n- **客观性**：语言精确、技术性强，没有主观或含糊的术语。\n- **完整性**：提供了进行计算所需的所有信息：$h(P)$的定义、$\\epsilon$的关系式以及物态方程$P(\\rho)$。\n- **其他缺陷**：该问题并非微不足道，需要解析积分，并且不基于任何不成立的前提。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个完整的、有理有据的解答。\n\n### 解题推导\n目标是计算无量纲焓$h(P)$的积分：\n$$\nh(P) = \\int_{0}^{P} \\frac{dP'}{\\epsilon(P')+P'}\n$$\n首先，我们必须将被积函数的分母$\\epsilon(P') + P'$表示为单个变量的函数。最方便的是使用静质量密度$\\rho$作为主要变量。\n\n根据给定的能量密度关系，我们有：\n$$\n\\epsilon(P') + P' = \\left(\\rho' + \\frac{P'}{\\Gamma-1}\\right) + P' = \\rho' + P' \\left(1 + \\frac{1}{\\Gamma-1}\\right) = \\rho' + P' \\left(\\frac{\\Gamma-1+1}{\\Gamma-1}\\right) = \\rho' + \\frac{\\Gamma P'}{\\Gamma-1}\n$$\n现在，使用多方物态方程$P' = K(\\rho')^\\Gamma$，我们替换$P'$：\n$$\n\\epsilon(P') + P' = \\rho' + \\frac{\\Gamma K (\\rho')^\\Gamma}{\\Gamma-1}\n$$\n这将分母用静质量密度$\\rho'$表示。为了计算积分，我们还必须将积分变量从$P'$更改为$\\rho'$。通过对物态方程求导可以找到微分$dP'$：\n$$\ndP' = \\frac{d}{d\\rho'} \\left( K(\\rho')^\\Gamma \\right) d\\rho' = K\\Gamma(\\rho')^{\\Gamma-1} d\\rho'\n$$\n积分的上下限也必须转换。当$P'=0$时，因为$K0$，我们有$\\rho'=0$。当$P'=P$时，对应的静质量密度是$\\rho = (P/K)^{1/\\Gamma}$。我们把这个上限记为$\\rho_P$。\n\n将这些表达式代入$h(P)$的积分中：\n$$\nh(P) = \\int_{0}^{\\rho_P} \\frac{K\\Gamma(\\rho')^{\\Gamma-1} d\\rho'}{\\rho' + \\frac{\\Gamma K (\\rho')^\\Gamma}{\\Gamma-1}}\n$$\n我们可以从分母中提出一个因子$\\rho'$：\n$$\nh(P) = \\int_{0}^{\\rho_P} \\frac{K\\Gamma(\\rho')^{\\Gamma-1} d\\rho'}{\\rho' \\left(1 + \\frac{\\Gamma K}{\\Gamma-1} (\\rho')^{\\Gamma-1}\\right)}\n$$\n通过消去因子$\\rho'$来简化表达式：\n$$\nh(P) = \\int_{0}^{\\rho_P} \\frac{K\\Gamma(\\rho')^{\\Gamma-2}}{1 + \\frac{\\Gamma K}{\\Gamma-1} (\\rho')^{\\Gamma-1}} d\\rho'\n$$\n这个积分可以用换元法求解。让我们定义一个新变量$u$作为被积函数的分母：\n$$\nu = 1 + \\frac{\\Gamma K}{\\Gamma-1} (\\rho')^{\\Gamma-1}\n$$\n现在，我们求微分$du$：\n$$\ndu = \\frac{d}{d\\rho'} \\left( 1 + \\frac{\\Gamma K}{\\Gamma-1} (\\rho')^{\\Gamma-1} \\right) d\\rho' = \\frac{\\Gamma K}{\\Gamma-1} (\\Gamma-1) (\\rho')^{\\Gamma-2} d\\rho' = \\Gamma K (\\rho')^{\\Gamma-2} d\\rho'\n$$\n我们注意到我们被积函数的分子，$K\\Gamma(\\rho')^{\\Gamma-2}d\\rho'$，与$du = \\Gamma K (\\rho')^{\\Gamma-2}d\\rho'$完全相同。\n积分变换为：\n$$\nh(P) = \\int_{u(0)}^{u(\\rho_P)} \\frac{du}{u}\n$$\n新的积分上下限是：\n- 当$\\rho' = 0$时，$u(0) = 1 + \\frac{\\Gamma K}{\\Gamma-1} (0)^{\\Gamma-1} = 1$。（因为$\\Gamma1$，此式成立）。\n- 当$\\rho' = \\rho_P$时，$u(\\rho_P) = 1 + \\frac{\\Gamma K}{\\Gamma-1} \\rho_P^{\\Gamma-1}$。\n\n计算关于$u$的简单积分：\n$$\nh(P) = \\left[ \\ln|u| \\right]_{1}^{1 + \\frac{\\Gamma K}{\\Gamma-1} \\rho_P^{\\Gamma-1}} = \\ln\\left(1 + \\frac{\\Gamma K}{\\Gamma-1} \\rho_P^{\\Gamma-1}\\right) - \\ln(1)\n$$\n由于$\\ln(1)=0$，我们有：\n$$\nh(P) = \\ln\\left(1 + \\frac{\\Gamma K}{\\Gamma-1} \\rho_P^{\\Gamma-1}\\right)\n$$\n最后一步是按要求将结果用原始变量$P$表示。我们代回$\\rho_P = (P/K)^{1/\\Gamma}$：\n$$\n\\rho_P^{\\Gamma-1} = \\left(\\left(\\frac{P}{K}\\right)^{\\frac{1}{\\Gamma}}\\right)^{\\Gamma-1} = \\left(\\frac{P}{K}\\right)^{\\frac{\\Gamma-1}{\\Gamma}} = \\frac{P^{\\frac{\\Gamma-1}{\\Gamma}}}{K^{\\frac{\\Gamma-1}{\\Gamma}}}\n$$\n将此代入$h(P)$的表达式中：\n$$\nh(P) = \\ln\\left(1 + \\frac{\\Gamma K}{\\Gamma-1} \\frac{P^{\\frac{\\Gamma-1}{\\Gamma}}}{K^{\\frac{\\Gamma-1}{\\Gamma}}}\\right)\n$$\n包含$K$的项可以简化：$K / K^{\\frac{\\Gamma-1}{\\Gamma}} = K^{1 - \\frac{\\Gamma-1}{\\Gamma}} = K^{\\frac{\\Gamma - (\\Gamma-1)}{\\Gamma}} = K^{\\frac{1}{\\Gamma}}$。\n这得出了最终的闭合形式表达式：\n$$\nh(P) = \\ln\\left(1 + \\frac{\\Gamma}{\\Gamma-1} K^{\\frac{1}{\\Gamma}} P^{\\frac{\\Gamma-1}{\\Gamma}}\\right)\n$$\n这个表达式是无量纲焓$h$作为压力$P$和物态方程参数$K$和$\\Gamma$的函数的解析计算结果。", "answer": "$$\n\\boxed{\\ln\\left(1 + \\frac{\\Gamma}{\\Gamma-1} K^{\\frac{1}{\\Gamma}} P^{\\frac{\\Gamma-1}{\\Gamma}}\\right)}\n$$", "id": "3592944"}, {"introduction": "这项综合性实践练习将前面所学的知识融会贯通，让您体验计算核天体物理学家的完整工作流程。您将构建一个分段恒定声速的状态方程模型，并编写程序数值求解TOV方程以获得质量-半径关系。更进一步，您还将计算中子星的潮汐形变能力，并将您的理论预测与关于中子星最大质量和GW170817等事件给出的潮汐观测约束进行直接比较，从而完成从微观核物理到宏观天体物理观测的连接 [@problem_id:3592923]。", "problem": "要求您编写一个完整的程序，为冷、β平衡中子星物质的状态方程构建和测试分段常数声速平方模型。目标是评估所提供的测试套件中的每个模型，判断其是否同时满足最大引力质量约束和观测的潮汐形变能力约束。代码必须是完全自包含的，并产生如下文指定的单行输出。\n\n从以下经过充分检验的基本框架开始。\n\n1) 广义相对论流体静力学平衡由 Tolman–Oppenheimer–Volkoff 方程控制：对于恒星半径坐标 $r$、包围质量 $m(r)$、压强 $p(r)$ 和能量密度 $\\varepsilon(r)$，\n$$\n\\frac{dp}{dr} \\;=\\; - \\frac{\\left[\\varepsilon(r) + p(r)\\right] \\left[m(r) + 4\\pi r^3 p(r)\\right]}{r\\left[r - 2 m(r)\\right]} \\,,\n\\qquad\n\\frac{dm}{dr} \\;=\\; 4\\pi r^2 \\varepsilon(r) \\,,\n$$\n其中微分方程使用了几何单位制，即 $G = c = 1$。\n\n2) 无量纲四极潮汐勒夫数 $k_2$ 是通过对静态外部四极潮汐场下度规微扰函数的对数导数 $y(r)$ 的一阶微分方程进行积分得到的。将 $y(r)$ 的辅助微分方程写为\n$$\n\\frac{dy}{dr} \\;=\\; -\\frac{y^2 + y\\,F(r) + r^2 Q(r)}{r} \\,,\n$$\n其中\n$$\nF(r) \\;=\\; \\frac{1 - 4\\pi r^2 \\left[\\varepsilon(r) - p(r)\\right]}{1 - 2 m(r)/r} \\,,\n$$\n$$\nQ(r) \\;=\\; \\frac{4\\pi \\left[5\\varepsilon(r) + 9 p(r) + \\frac{\\varepsilon(r)+p(r)}{c_s^2(r)}\\right]}{1 - 2 m(r)/r}\n\\;-\\; \\frac{6}{r^2} \\;-\\; \\frac{4 \\left[m(r) + 4\\pi r^3 p(r)\\right]^2}{r^2 \\left[1 - 2 m(r)/r\\right]^2} \\,,\n$$\n其中 $c_s^2(r) = dp/d\\varepsilon$ 是声速的平方。施加正则中心边界条件 $y(0) = 2$。\n\n在恒星表面 $r = R$ 处，$p(R) = 0$ 且 $m(R) = M$，定义致密度 $C = M/R$ 并使用以下公式计算 $k_2$\n$$\nk_2 \\;=\\; \\frac{8 C^5}{5} (1-2C)^2 \\,\\frac{2 + 2C\\left[y(R) - 1\\right] - y(R)}{\n2 C \\left[6 - 3 y(R) + 3 C \\left(5 y(R) - 8\\right)\\right] + 4 C^3 \\left[13 - 11 y(R) + C \\left(3 y(R) - 2\\right) + 2 C^2 \\left(1 + y(R)\\right) \\right] + 3 (1 - 2C)^2 \\left[2 - y(R) + 2 C \\left(y(R) - 1\\right)\\right] \\ln(1 - 2C)} \\,.\n$$\n无量纲潮汐形变能力为\n$$\n\\Lambda \\;=\\; \\frac{2}{3} \\, k_2 \\, C^{-5} \\,.\n$$\n\n3) 通过锚定在低密度和高密度带上的分段常数声速平方构造来模拟状态方程 (EoS)。令 $\\varepsilon$ 表示能量密度，$p$ 表示压强，在转换为几何单位之前，二者的单位均为 MeV fm$^{-3}$。使用三个具有恒定 $c_s^2$ 值的密度区间：\n- 片段1：$\\varepsilon \\in [\\varepsilon_0, \\varepsilon_1]$，声速平方为 $c_{s,1}^2$，\n- 片段2：$\\varepsilon \\in [\\varepsilon_1, \\varepsilon_2]$，声速平方为 $c_{s,2}^2$，\n- 片段3：$\\varepsilon \\in [\\varepsilon_2, \\infty)$，声速平方为 $c_{s,3}^2$，\n其中\n$$\n\\frac{dp}{d\\varepsilon} \\;=\\; c_s^2 \\quad \\text{(在每个片段上为常数)} \\,.\n$$\n施加线性和连续性：\n- 在片段1上：$p(\\varepsilon) = c_{s,1}^2 \\left(\\varepsilon - \\varepsilon_0\\right)$，这强制在 $\\varepsilon = \\varepsilon_0$ 时表面压强为 $p=0$。\n- 在低密度锚点 $\\varepsilon_1$ 处，设置 $p(\\varepsilon_1) = p_1 \\in [p_{1,\\min}, p_{1,\\max}]$。\n- 在片段2上：对于 $\\varepsilon \\in [\\varepsilon_1,\\varepsilon_2]$，$p(\\varepsilon) = p(\\varepsilon_1) + c_{s,2}^2 \\left(\\varepsilon - \\varepsilon_1\\right)$。\n- 定义 $p(\\varepsilon_2) \\equiv p_2$ 并要求 $p_2 \\in [p_{2,\\min}, p_{2,\\max}]$ (高密度锚点)。\n- 在片段3上：对于 $\\varepsilon \\ge \\varepsilon_2$，$p(\\varepsilon) = p(\\varepsilon_2) + c_{s,3}^2 \\left(\\varepsilon - \\varepsilon_2\\right)$。\n因果性要求在所有片段上 $0  c_s^2 \\le 1$。\n\n使用以下科学上合理的锚点位置和范围：\n- 低密度锚点位于 $\\varepsilon_1 = 165$ MeV fm$^{-3}$，压强范围为 $p_{1,\\min} = 2$ MeV fm$^{-3}$ 和 $p_{1,\\max} = 5$ MeV fm$^{-3}$。\n- 高密度锚点位于 $\\varepsilon_2 = 750$ MeV fm$^{-3}$，压强范围为 $p_{2,\\min} = 150$ MeV fm$^{-3}$ 和 $p_{2,\\max} = 400$ MeV fm$^{-3}$。\n\n给定 $(c_{s,1}^2,c_{s,2}^2,c_{s,3}^2,p_1)$，通过施加连续性来确定 $\\varepsilon_0$ 和 $p_2$：\n$$\n\\varepsilon_0 \\;=\\; \\varepsilon_1 - \\frac{p_1}{c_{s,1}^2} \\,, \\qquad\np_2 \\;=\\; p_1 + c_{s,2}^2 \\, (\\varepsilon_2 - \\varepsilon_1) \\,.\n$$\n拒绝任何违反 $p_1 \\in [p_{1,\\min},p_{1,\\max}]$、$p_2 \\in [p_{2,\\min},p_{2,\\max}]$、$\\varepsilon_0 > 0$ 或 $c_s^2 \\notin (0,1]$ 的模型。\n\n4) 单位转换。在结构方程中使用几何单位制 $G = c = 1$，半径单位为 km，因此压强和能量密度的单位为 km$^{-2}$。通过以下公式将以 MeV fm$^{-3}$ 为单位指定的输入压强和能量密度转换为 km$^{-2}$：\n$$\nX_{\\mathrm{km}^{-2}} \\;=\\; \\left(\\frac{G}{c^4}\\right) \\, X_{\\mathrm{SI}} \\times \\left(10^6\\right) \\,,\n$$\n并注意 1 MeV fm$^{-3}$ 在国际单位制中对应于 $1.602176634 \\times 10^{32}$ J m$^{-3}$。取 $G = 6.67430 \\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$，$c = 2.99792458 \\times 10^8$ m s$^{-1}$，1 MeV $= 1.602176634 \\times 10^{-13}$ J，1 fm $= 10^{-15}$ m。使用 $M_{\\odot} \\equiv GM_{\\odot}/c^2 = 1.4766250385$ km 将质量转换为太阳质量。所有质量以 $M_{\\odot}$ 为单位，半径以 km 为单位。潮汐形变能力 $\\Lambda$ 是无量纲的。\n\n5) 对每个 EoS 模型要评估的观测和物理约束：\n- 最大质量约束：$M_{\\max} \\ge 2 \\, M_{\\odot}$。\n- 1.4 $M_{\\odot}$ 处的潮汐形变能力界限：$\\Lambda_{1.4} \\in [190,580]$。\n\n6) 数值程序。对于每个 EoS 模型：\n- 使用三个 $c_s^2$ 常数和锚点条件构建分段线性的 $p(\\varepsilon)$，并解析地反演以获得每个压强区间上的 $\\varepsilon(p)$ 和 $c_s^2(p)$。\n- 对于一个从 $\\varepsilon_2$ 延伸到足够大的最大值的中心能量密度序列 $\\varepsilon_c$，生成相应的中心压强 $p_c = p(\\varepsilon_c)$。对于每个 $p_c$，从一个小的半径 $r_0$（使用以 km 为单位的 $r_0$）开始，向外积分关于 $p(r)$、$m(r)$ 和 $y(r)$ 的耦合常微分方程，初始条件为 $m(r_0) \\approx \\frac{4\\pi}{3} \\varepsilon_c r_0^3$、$p(r_0) \\approx p_c$ 和 $y(r_0)=2$，当在 $r=R$ 处 $p=0$ 时停止。计算该模型的 $M=m(R)$、$C=M/R$、$k_2$ 和 $\\Lambda$。\n- 在序列上确定 $M_{\\max}$，并通过选择质量最接近 $1.4 \\, M_{\\odot}$ 的构型来估计 $\\Lambda_{1.4}$。\n- 返回一个布尔决策，当且仅当所有锚点条件都满足，并且 $M_{\\max} \\ge 2 \\, M_{\\odot}$ 和 $\\Lambda_{1.4} \\in [190,580]$ 同时成立时，该决策为真。\n\n测试套件和要求的输出：\n使用以下六个参数集 $(c_{s,1}^2,c_{s,2}^2,c_{s,3}^2,p_1)$，其中 $c_s^2$ 是无量纲的，$p_1$ 的单位是 MeV fm$^{-3}$：\n- 案例 1：$(0.4, 0.4, 0.9, 3.5)$\n- 案例 2：$(0.3, 0.3, 0.5, 2.5)$\n- 案例 3：$(0.5, 0.9, 0.9, 5.0)$\n- 案例 4：$(0.2, 0.6, 0.7, 2.0)$\n- 案例 5：$(0.6, 0.4, 0.95, 5.0)$\n- 案例 6：$(0.25, 0.35, 0.95, 2.5)$\n\n角度单位不适用。百分比不适用。程序内部的所有物理答案必须使用上述指定的单位。每个案例的最终决策必须是一个布尔值。\n\n最终输出格式：\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。例如，输出格式必须类似于 $[{\\tt True},{\\tt False},\\dots]$，不含多余的空格或文本。", "solution": "我们通过将广义相对论的基本结构方程与一个由低密度和高密度带锚定的、唯象但因果一致的致密物质物理学表示联系起来，从而构建算法。\n\n1) 物理基础和方程。Tolman–Oppenheimer–Volkoff 方程和潮汐响应方程构成了结构问题的主干。在几何单位制 $G=c=1$ 中，流体静力学平衡系统\n$$\n\\frac{dp}{dr} = - \\frac{\\left(\\varepsilon + p\\right)\\left[m + 4\\pi r^3 p\\right]}{r\\left(r - 2m\\right)},\n\\quad\n\\frac{dm}{dr} = 4\\pi r^2 \\varepsilon\n$$\n由状态方程 $p(\\varepsilon)$ 闭合，而主导阶的四极潮汐响应则被编码在 $y(r)$ 的一阶微分方程中，\n$$\n\\frac{dy}{dr} = -\\frac{y^2 + y\\,F + r^2 Q}{r}\n$$\n其中\n$$\nF = \\frac{1 - 4\\pi r^2 (\\varepsilon - p)}{1 - 2 m / r}, \\qquad\nQ = \\frac{4\\pi \\left[5\\varepsilon + 9p + \\frac{\\varepsilon + p}{c_s^2}\\right]}{1 - 2 m / r} - \\frac{6}{r^2} - \\frac{4 \\left(m + 4\\pi r^3 p\\right)^2}{r^2 \\left(1 - 2 m / r\\right)^2} \\,,\n$$\n中心条件为 $y(0)=2$。这些在中子星结构计算中是公认且经过广泛验证的。\n\n2) 分段常数声速状态方程。在能量密度 $\\varepsilon$ 的每个片段上，我们施加一个恒定的声速平方 $c_s^2 = dp/d\\varepsilon$，积分后在该片段上得到一个线性的 $p(\\varepsilon)$ 关系。标记三个片段：\n- 片段1在 $\\varepsilon \\in [\\varepsilon_0,\\varepsilon_1]$ 上，斜率为 $c_{s,1}^2$，\n- 片段2在 $\\varepsilon \\in [\\varepsilon_1,\\varepsilon_2]$ 上，斜率为 $c_{s,2}^2$，\n- 片段3在 $\\varepsilon \\ge \\varepsilon_2$ 上，斜率为 $c_{s,3}^2$。\n\n在 $\\varepsilon_1 = 165$ MeV fm$^{-3}$ 处施加低密度锚点，其中 $p(\\varepsilon_1) = p_1 \\in [2,5]$ MeV fm$^{-3}$。在片段1上强制 $p(\\varepsilon_0) = 0$，得到\n$$\np(\\varepsilon) = c_{s,1}^2(\\varepsilon - \\varepsilon_0), \\qquad \\varepsilon_0 = \\varepsilon_1 - \\frac{p_1}{c_{s,1}^2} \\,.\n$$\n进入片段2的连续性给出\n$$\np(\\varepsilon) = p_1 + c_{s,2}^2 (\\varepsilon - \\varepsilon_1) \\quad \\text{对于 } \\varepsilon \\in [\\varepsilon_1,\\varepsilon_2] \\,,\n$$\n并定义 $p(\\varepsilon_2) \\equiv p_2 = p_1 + c_{s,2}^2(\\varepsilon_2 - \\varepsilon_1)$。通过要求在 $\\varepsilon_2 = 750$ MeV fm$^{-3}$ 处 $p_2 \\in [150,400]$ MeV fm$^{-3}$ 来应用高密度锚点。最后，\n$$\np(\\varepsilon) = p_2 + c_{s,3}^2(\\varepsilon - \\varepsilon_2) \\quad \\text{对于 } \\varepsilon \\ge \\varepsilon_2 \\,.\n$$\n在每个片段上，逆关系 $\\varepsilon(p)$ 是平凡的：\n$$\n\\varepsilon(p) =\n\\begin{cases}\n\\varepsilon_0 + \\dfrac{p}{c_{s,1}^2},  p \\in [0,p_1], \\\\\n\\varepsilon_1 + \\dfrac{p - p_1}{c_{s,2}^2},  p \\in [p_1,p_2], \\\\\n\\varepsilon_2 + \\dfrac{p - p_2}{c_{s,3}^2},  p \\ge p_2.\n\\end{cases}\n$$\n因果性和热力学稳定性要求 $0  c_s^2 \\le 1$ 和单调的 $p(\\varepsilon)$，这在构造中得到了遵守。我们还要求 $\\varepsilon_0 > 0$，以便在正能量密度下达到无压强表面。\n\n3) 潮汐勒夫数和形变能力。在将结构和潮汐方程积分到表面 $r=R$ 并提取 $M = m(R)$ 和 $y(R)$ 之后，使用致密度 $C = M/R$ 通过以下公式计算 $k_2$\n$$\nk_2 \\;=\\; \\frac{8 C^5}{5} (1-2C)^2 \\,\\frac{2 + 2C\\left[y(R) - 1\\right] - y(R)}{\n2 C \\left[6 - 3 y(R) + 3 C \\left(5 y(R) - 8\\right)\\right] + 4 C^3 \\left[13 - 11 y(R) + C \\left(3 y(R) - 2\\right) + 2 C^2 \\left(1 + y(R)\\right) \\right] + 3 (1 - 2C)^2 \\left[2 - y(R) + 2 C \\left(y(R) - 1\\right)\\right] \\ln(1 - 2C)} \\,,\n$$\n然后\n$$\n\\Lambda \\;=\\; \\frac{2}{3} k_2 C^{-5} \\,.\n$$\n\n4) 单位和转换。结构方程在基于 km 的几何单位制中积分。EoS 输入以 MeV fm$^{-3}$ 指定，必须转换为 km$^{-2}$。转换通过以下方式实现：\n$$\nX_{\\mathrm{km}^{-2}} \\;=\\; \\left(\\frac{G}{c^4}\\right) \\, X_{\\mathrm{SI}} \\times \\left(10^6\\right),\n\\qquad X_{\\mathrm{SI}}\\;[\\mathrm{J\\,m}^{-3}] \\;=\\; X\\;[\\mathrm{MeV\\,fm}^{-3}] \\times \\left(1.602176634 \\times 10^{32}\\right),\n$$\n其中 $G = 6.67430 \\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$ 且 $c = 2.99792458 \\times 10^8$ m s$^{-1}$。太阳质量以 km 表示为 $M_{\\odot} = 1.4766250385$ km，因此质量通过 $M\\,[M_{\\odot}] = M\\,[\\mathrm{km}]/1.4766250385$ 进行转换。\n\n5) 数值设计。对于每个测试案例：\n- 验证锚点和因果性：检查 $p_1 \\in [2,5]$ MeV fm$^{-3}$，$p_2 \\in [150,400]$ MeV fm$^{-3}$，$\\varepsilon_0>0$ 和 $0  c_s^2 \\le 1$。\n- 为三个以 km$^{-2}$ 为单位的压强范围构建 $\\varepsilon(p)$ 和 $c_s^2(p)$。\n- 在 $[\\varepsilon_2, \\varepsilon_{\\max}]$ 范围内选择一个中心能量密度 $\\varepsilon_c$（单位 MeV fm$^{-3}$）的网格，其中 $\\varepsilon_{\\max}$ 足够大以超过最大质量区域；通过 $p(\\varepsilon_c)$ 映射到中心压强 $p_c$。对于每个 $p_c$，使用自适应步长 ODE 求解器，并设置压强为零的事件来定位表面，将 $(p(r),m(r),y(r))$ 的耦合系统从 $r_0$ 积分到无压强表面。使用 $r_0 = 10^{-4}$ km，$m(r_0) \\approx \\frac{4\\pi}{3}\\varepsilon_c r_0^3$，$p(r_0) \\approx p_c$ 和 $y(r_0)=2$。\n- 记录每个模型的 $(M,R,y(R))$，计算 $k_2$ 和 $\\Lambda$。将质量序列的最大值确定为 $M_{\\max}$，并从质量最接近 $1.4\\,M_{\\odot}$ 的模型中估计 $\\Lambda_{1.4}$。\n- 当且仅当锚点满足且 $M_{\\max} \\ge 2\\,M_{\\odot}$ 和 $\\Lambda_{1.4} \\in [190,580]$ 同时成立时，返回真。\n\n6) 测试套件覆盖范围。这六个案例探测了不同的行为：中低到高刚度组合、一个违反高密度压强锚点的案例，以及测试 $M_{\\max}$ 和 $\\Lambda_{1.4}$ 界限的案例。程序将决策编译成单行输出。\n\n最终程序实现了以上内容，使用了指定的常数，积分了方程，并打印了包含每个测试案例一个布尔值的列表的单行输出，格式符合要求。", "answer": "```python\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Constants for unit conversions and solar mass in geometric length units (km)\nG_SI = 6.67430e-11            # m^3 kg^-1 s^-2\nc_SI = 2.99792458e8           # m s^-1\nMEVFM_TO_SI = 1.602176634e32  # 1 MeV/fm^3 = 1.602176634e32 J/m^3 = N/m^2\n# Convert SI pressure/energy density to geometrized (km^-2): multiply by (G/c^4) and by 1e6 to go from m^-2 to km^-2\nSI_TO_KM2 = (G_SI / c_SI**4) * 1e6\nMEVFM_TO_KM2 = MEVFM_TO_SI * SI_TO_KM2  # factor to convert MeV/fm^3 to km^-2\n\nM_SUN_KM = 1.4766250385  # GM_sun/c^2 in km\n\n# Anchors in MeV/fm^3\nEPS1 = 165.0\nEPS2 = 750.0\nP1_MIN = 2.0\nP1_MAX = 5.0\nP2_MIN = 150.0\nP2_MAX = 400.0\n\n# Observational constraints\nM_MAX_MIN = 2.0            # Msun\nLAMBDA14_MIN = 190.0\nLAMBDA14_MAX = 580.0\n\n# Small radius to start integration (km)\nR0 = 1.0e-4\n\nclass PiecewiseCS2EOS:\n    \"\"\"\n    Piecewise-constant c_s^2 EOS anchored at two densities.\n    Internally stores parameters in both MeV/fm^3 (for construction) and km^-2 (for TOV).\n    \"\"\"\n    def __init__(self, cs1, cs2, cs3, p1_mevfm):\n        # Enforce causality bounds slightly inside [0,1]\n        self.cs1 = float(cs1)\n        self.cs2 = float(cs2)\n        self.cs3 = float(cs3)\n        self.p1 = float(p1_mevfm)\n        # Construct in MeV/fm^3\n        self.eps1 = EPS1\n        self.eps2 = EPS2\n        # Validity flags\n        self.valid = True\n        # Check p1 band\n        if not (P1_MIN = self.p1 = P1_MAX):\n            self.valid = False\n\n        # Check causal range\n        for v in (self.cs1, self.cs2, self.cs3):\n            if not (0.0  v = 1.0):\n                self.valid = False\n\n        # Compute epsilon0 ensuring p=0 at eps0 on seg1\n        if self.cs1 = 0.0:\n            self.valid = False\n        else:\n            self.eps0 = self.eps1 - self.p1 / self.cs1\n            if not (self.eps0 > 0.0):\n                self.valid = False\n\n        # Compute p2 from seg2 and check high-density band\n        self.p2 = self.p1 + self.cs2 * (self.eps2 - self.eps1)\n        if not (P2_MIN = self.p2 = P2_MAX):\n            self.valid = False\n\n        # Precompute conversions to km^-2\n        self.p1_km2 = self.p1 * MEVFM_TO_KM2\n        self.p2_km2 = self.p2 * MEVFM_TO_KM2\n        self.eps0_km2 = self.eps0 * MEVFM_TO_KM2 if self.valid else 0.0\n        self.eps1_km2 = self.eps1 * MEVFM_TO_KM2\n        self.eps2_km2 = self.eps2 * MEVFM_TO_KM2\n\n    def is_valid(self):\n        return self.valid\n\n    def p_of_eps_mevfm(self, eps_mevfm):\n        # Return pressure in MeV/fm^3 for a given epsilon in MeV/fm^3\n        e = eps_mevfm\n        if e  self.eps0:\n            # Below surface: not physical\n            return 0.0\n        if e = self.eps1:\n            return self.cs1 * (e - self.eps0)\n        elif e = self.eps2:\n            return self.p1 + self.cs2 * (e - self.eps1)\n        else:\n            return self.p2 + self.cs3 * (e - self.eps2)\n\n    def eps_and_cs2_of_p_km2(self, p_km2):\n        # Given pressure in km^-2, return (epsilon in km^-2, cs^2 dimensionless)\n        p = p_km2\n        # Determine interval by pressure in km^-2 using p1_km2 and p2_km2\n        if p = self.p1_km2:\n            # seg1: epsilon = eps0 + p/cs1\n            eps = self.eps0_km2 + p / self.cs1\n            cs2 = self.cs1\n        elif p = self.p2_km2:\n            eps = self.eps1_km2 + (p - self.p1_km2) / self.cs2\n            cs2 = self.cs2\n        else:\n            eps = self.eps2_km2 + (p - self.p2_km2) / self.cs3\n            cs2 = self.cs3\n        return eps, cs2\n\ndef tov_love_rhs(r, yvec, eos: PiecewiseCS2EOS):\n    \"\"\"\n    RHS for coupled ODEs: yvec = [p, m, y], with r in km, p in km^-2, m in km, y dimensionless.\n    \"\"\"\n    p, m, y = yvec\n    if p = 0.0:\n        # Outside star: derivatives don't matter; solver should stop via event.\n        return [0.0, 0.0, 0.0]\n    eps, cs2 = eos.eps_and_cs2_of_p_km2(p)\n    # Avoid division by zero near r=0; but we start at r0>0\n    denom = r * (r - 2.0 * m)\n    if denom == 0.0:\n        # Collapse or invalid region; return zeros to avoid blow-up\n        return [0.0, 0.0, 0.0]\n    dpdr = - (eps + p) * (m + 4.0 * np.pi * r**3 * p) / denom\n    dmdr = 4.0 * np.pi * r**2 * eps\n    # Tidal equation components\n    one_minus_2m_r = 1.0 - 2.0 * m / r\n    if one_minus_2m_r = 0.0:\n        F = 0.0\n        Q = 0.0\n    else:\n        F = (1.0 - 4.0 * np.pi * r**2 * (eps - p)) / one_minus_2m_r\n        Q = (4.0 * np.pi * (5.0 * eps + 9.0 * p + (eps + p) / cs2) / one_minus_2m_r\n             - 6.0 / r**2\n             - 4.0 * (m + 4.0 * np.pi * r**3 * p)**2 / (r**2 * one_minus_2m_r**2))\n    dydr = - (y*y + y * F + r*r * Q) / r\n    return [dpdr, dmdr, dydr]\n\ndef surface_event(r, yvec, eos):\n    # Event when pressure crosses zero\n    return yvec[0]\n\nsurface_event.terminal = True\nsurface_event.direction = -1.0\n\ndef integrate_star(p_c_km2, eos: PiecewiseCS2EOS):\n    \"\"\"\n    Integrate TOV+Love equations from r=R0 to surface for given central pressure p_c (km^-2).\n    Returns (M_km, R_km, yR) or (None, None, None) if fails.\n    \"\"\"\n    # Initial conditions at small radius\n    eps_c_km2, _ = eos.eps_and_cs2_of_p_km2(p_c_km2)\n    m0 = 4.0 * np.pi * eps_c_km2 * (R0**3) / 3.0\n    y0 = 2.0\n    yinit = [p_c_km2, m0, y0]\n\n    try:\n        sol = solve_ivp(\n            fun=lambda r, y: tov_love_rhs(r, y, eos),\n            t_span=(R0, 100.0),  # upper bound large enough; event will terminate earlier\n            y0=yinit,\n            method='RK45',\n            rtol=1e-6,\n            atol=1e-9,\n            events=lambda r, y: surface_event(r, y, eos),\n            max_step=0.2\n        )\n    except Exception:\n        return None, None, None\n\n    if sol.status  0:\n        return None, None, None\n    # If event not triggered, fail\n    if len(sol.t_events) == 0 or len(sol.t_events[0]) == 0:\n        return None, None, None\n\n    R = sol.t_events[0][0]\n    pR, M, yR = sol.y_events[0][0]\n    # Basic sanity checks\n    if not (R > 0.0 and M > 0.0 and (1.0 - 2.0 * M / R) > 0.0):\n        return None, None, None\n    return M, R, yR\n\ndef compute_k2_and_lambda(M_km, R_km, yR):\n    C = M_km / R_km\n    # Guard against unphysical compactness\n    if C = 0.0 or C >= 0.5:\n        return None, None\n    # Compute k2 using the standard expression\n    try:\n        term1 = (8.0 * C**5 / 5.0) * (1.0 - 2.0 * C)**2\n        num = 2.0 + 2.0 * C * (yR - 1.0) - yR\n        log_term = np.log(1.0 - 2.0 * C)\n        denom = (2.0 * C * (6.0 - 3.0 * yR + 3.0 * C * (5.0 * yR - 8.0))\n                 + 4.0 * C**3 * (13.0 - 11.0 * yR + C * (3.0 * yR - 2.0) + 2.0 * C**2 * (1.0 + yR))\n                 + 3.0 * (1.0 - 2.0 * C)**2 * (2.0 - yR + 2.0 * C * (yR - 1.0)) * log_term)\n        if denom == 0.0:\n            return None, None\n        k2 = term1 * num / denom\n        Lambda = (2.0 / 3.0) * k2 * (C**-5)\n        if not np.isfinite(k2) or not np.isfinite(Lambda):\n            return None, None\n        return k2, Lambda\n    except Exception:\n        return None, None\n\ndef evaluate_eos_case(cs1, cs2, cs3, p1_mevfm):\n    \"\"\"\n    Build EOS, validate anchors, compute Mmax and Lambda1.4, and test constraints.\n    Returns boolean decision.\n    \"\"\"\n    eos = PiecewiseCS2EOS(cs1, cs2, cs3, p1_mevfm)\n    if not eos.is_valid():\n        return False\n\n    # Build central energy density grid (MeV/fm^3) and corresponding central pressures (km^-2)\n    eps_c_values = np.linspace(EPS2, 3500.0, 60)  # MeV/fm^3\n    p_c_values = np.array([eos.p_of_eps_mevfm(eps_c) * MEVFM_TO_KM2 for eps_c in eps_c_values])\n\n    masses = []\n    radii = []\n    yR_list = []\n    for p_c in p_c_values:\n        # Ensure central pressure is positive and finite\n        if not np.isfinite(p_c) or p_c = 0.0:\n            masses.append(np.nan); radii.append(np.nan); yR_list.append(np.nan)\n            continue\n        M_km, R_km, yR = integrate_star(p_c, eos)\n        if M_km is None:\n            masses.append(np.nan); radii.append(np.nan); yR_list.append(np.nan)\n        else:\n            masses.append(M_km / M_SUN_KM)  # Msun\n            radii.append(R_km)             # km\n            yR_list.append(yR)\n\n    masses = np.array(masses)\n    radii = np.array(radii)\n    yR_list = np.array(yR_list)\n\n    # Filter out NaNs\n    valid_idx = np.where(np.isfinite(masses)  np.isfinite(radii)  np.isfinite(yR_list))[0]\n    if valid_idx.size == 0:\n        return False\n\n    Mmax = np.max(masses[valid_idx])\n\n    # Find index closest to 1.4 Msun\n    idx_14 = valid_idx[np.argmin(np.abs(masses[valid_idx] - 1.4))]\n    M_14 = masses[idx_14]\n    R_14 = radii[idx_14]\n    yR_14 = yR_list[idx_14]\n\n    k2_14, Lambda_14 = compute_k2_and_lambda(M_14 * M_SUN_KM, R_14, yR_14)\n    if k2_14 is None or Lambda_14 is None or not np.isfinite(Lambda_14):\n        return False\n\n    # Check constraints\n    cond_mass = (Mmax >= M_MAX_MIN)\n    cond_lambda = (LAMBDA14_MIN = Lambda_14 = LAMBDA14_MAX)\n    return bool(cond_mass and cond_lambda)\n\ndef solve():\n    # Define the test cases from the problem statement as tuples (cs1^2, cs2^2, cs3^2, p1[MeV/fm^3])\n    test_cases = [\n        (0.4, 0.4, 0.9, 3.5),\n        (0.3, 0.3, 0.5, 2.5),\n        (0.5, 0.9, 0.9, 5.0),\n        (0.2, 0.6, 0.7, 2.0),\n        (0.6, 0.4, 0.95, 5.0),\n        (0.25, 0.35, 0.95, 2.5),\n    ]\n\n    results = []\n    for cs1, cs2, cs3, p1 in test_cases:\n        res = evaluate_eos_case(cs1, cs2, cs3, p1)\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, comma-separated, no spaces\n    print(f\"[{','.join('True' if r else 'False' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3592923"}]}