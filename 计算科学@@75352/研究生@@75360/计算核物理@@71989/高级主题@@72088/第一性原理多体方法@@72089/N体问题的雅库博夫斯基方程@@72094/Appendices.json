{"hands_on_practices": [{"introduction": "在着手解决复杂的、完全的物理问题之前，验证数值求解器的基本正确性是至关重要的一步。本练习将演示如何构建一个简化的、可精确求解的“玩具模型”，用以测试积分核与归一化约定的实现，这是科学计算中的一项基本实践。通过将数值积分和求根的结果与解析解进行比较，我们可以获得对代码核心部分正确性的信心 [@problem_id:3608781]。", "problem": "您将构建一个完全指定的、精确可解的四体束缚态测试问题，该问题基于秩-$1$的Yamaguchi型可分相互作用以及法捷耶夫-雅库波夫斯基（FY）方程的简并核约化方法。目标是生成一个小型的可运行程序，通过将解析公式与数值积分和数值求根的结果进行比较，来同时检验积分核和归一化约定。所有量均在无量纲自然单位制下处理，因此不输入或返回任何物理单位。\n\n基本出发点是动量空间中的非相对论$A$体薛定谔方程、用于二体$t$算符的李普曼-施温格方程，以及$A=4$时的法捷耶夫-雅库波夫斯基（FY）分解。您将使用Yamaguchi型的秩-$1$可分势，\n$$\nV(\\mathbf{k},\\mathbf{k}') = -\\lambda\\, g(k)\\, g(k'), \\quad g(k) = \\frac{1}{k^2 + \\beta^2},\n$$\n其中 $\\lambda > 0$ 和 $\\beta > 0$，并采用标准的动量空间归一化，其测度为 $\\int \\frac{d^3k}{(2\\pi)^3}$。在无量纲单位制中进行计算，取 $\\hbar = 1$，并对约化质量进行缩放，使得对于能量 $E = -\\kappa^2$（其中 $\\kappa > 0$）的束缚态，自由二体预解式的分母为 $k^2 + \\kappa^2$。自由四体预解式采用雅可比变量，并进行相同的缩放。\n\n对于秩-$1$可分相互作用，从李普曼-施温格方程可知，二体$t$算符具有如下形式\n$$\nt(E) = |g\\rangle\\, \\tau(E)\\, \\langle g|, \\quad \\tau(E) = \\frac{-\\lambda}{1 + \\lambda\\, I_2(E)}, \\quad I_2(E) \\equiv \\langle g|G_0(E)|g\\rangle,\n$$\n其中 $G_0(E)$ 是自由二体预解式，对于束缚态能量 $E = -\\kappa^2$，圈积分为\n$$\nI_2(-\\kappa^2) = \\int \\frac{d^3k}{(2\\pi)^3}\\, \\frac{g(k)^2}{\\kappa^2 + k^2} = \\frac{1}{2\\pi^2} \\int_0^\\infty dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)}.\n$$\n\n在使用上述秩-$1$可分相互作用、针对$A=4$的全同无自旋玻色子和S波动力学的FY方程简并核约化中，假设如下：\n- 每个团拓扑中的雅库波夫斯基分量与相应雅可比动量下的二体形因子成正比，因此积分方程在一个由$g$张成的二维子空间上是封闭的。\n- 夹在相关雅可比变量的形因子之间的自由预解式 $G_0(E)$ 的投影，可以约化为与二体问题中出现的相同的标量圈积分 $I_2(-\\kappa^2)$。这是一个特意设定的简并核测试约定。\n- $3+1$型和$2+2$型两个雅库波夫斯基分量之间的置换结构由固定的$2\\times 2$整数矩阵\n$$\nP = \\begin{pmatrix} 3  2 \\\\ 1  4 \\end{pmatrix},\n$$\n表示，该矩阵编码了此简并模型中分量之间约化耦合的玻色子对称性权重。\n\n在这些假设下，齐次束缚态FY系统约化为代数特征值问题\n$$\n\\bigl[I - x(E)\\, P\\bigr]\\, \\mathbf{A} = 0, \\quad x(E) \\equiv -\\tau(E)\\, I_2(E),\n$$\n其非平凡解条件为\n$$\n\\det\\bigl[I - x(E)\\, P\\bigr] = 0.\n$$\n$P$的特征值需从第一性原理确定。将它们记为 $\\Lambda \\in \\{\\Lambda_1,\\Lambda_2\\}$。那么，每个通道中的束缚态条件为\n$$\nx(E) = \\frac{1}{\\Lambda}.\n$$\n使用 $x(E) = -\\tau(E)\\, I_2(E)$ 和 $\\tau(E) = -\\lambda/[1 + \\lambda I_2(E)]$，该条件约化为标量方程\n$$\n\\lambda\\, \\bigl[\\Lambda\\, J(E) - I_2(E)\\bigr] = 1,\n$$\n在 $J(E) \\equiv I_2(E)$ 的测试约定下，它简化为\n$$\n\\lambda\\, (\\Lambda - 1)\\, I_2(E) = 1.\n$$\n将其解释为一个关于$\\kappa$（其中$E=-\\kappa^2$）的方程，这就为每个对称通道$\\Lambda$定义了一个精确可解的四体束缚测试。当且仅当对应的$\\kappa$为严格正值时，存在具有物理束缚态的解。\n\n您的任务：\n1) 推导圈积分 $I_2(-\\kappa^2)$ 关于 $\\kappa$ 和 $\\beta$ 的解析表达式，从上面写出的三维积分开始。您的推导必须从积分定义开始，并采用合理的解析方法。\n2) 确定矩阵$P$的特征值$\\Lambda$。\n3) 使用第1项和第2项的结果，证明束缚态条件可以约化为关于$\\kappa$的标量方程，并且对于每个$\\Lambda$都有闭合形式的解。提供$\\kappa$作为$\\lambda$、$\\beta$和$\\Lambda$的函数的显式解析表达式，并陈述指示物理束缚态存在的$\\kappa$的正性条件。\n4) 实现一个程序，该程序：\n   - 通过对 $k \\in [0,\\infty)$ 进行数值积分，使用一维径向积分（带有指定测度）来数值计算 $I_2(-\\kappa^2)$。\n   - 对于每个通道$\\Lambda$，使用稳健的区间法，数值求解标量束缚态方程\n     $$\n     F_\\Lambda(\\kappa) \\equiv \\lambda\\, (\\Lambda - 1)\\, I_2(-\\kappa^2) - 1 = 0\n     $$\n     以获得 $\\kappa \\ge 0$ 的解。如果 $F_\\Lambda(0) \\le 0$，则声明该通道中不存在物理根。\n   - 将每个数值方法得到的$\\kappa$（如果存在）与第3项中的解析$\\kappa$进行比较，并同时在一个严格的绝对容差范围内检查归一化条件\n     $$\n     -\\tau(-\\kappa^2)\\, I_2(-\\kappa^2) = \\frac{1}{\\Lambda}\n     $$\n     是否满足。\n   - 对于每个测试案例和每个通道$\\Lambda$，报告一个布尔值，说明解析预测和数值预测是否一致：当且仅当（i）解析和数值过程都认为该通道中不存在束缚态，或者（ii）两者都找到了束缚态，并且$\\kappa$的绝对差在容差范围内，且归一化检查得到满足时，该值必须为$\\,\\text{True}\\,$；否则必须为$\\,\\text{False}\\,$。\n\n测试套件：\n使用以下四个无量纲参数集 $(\\lambda,\\beta)$：\n- 案例1：$\\lambda = 100.0$, $\\beta = 1.0$。\n- 案例2：$\\lambda = 20.0$, $\\beta = 1.0$。\n- 案例3：$\\lambda = 2\\pi \\times 1.0001$, $\\beta = 1.0$。\n- 案例4：$\\lambda = 300.0$, $\\beta = 2.0$。\n\n角度单位不适用，也没有要报告的物理单位。您的程序应为每个案例计算两个布尔值，对应于$P$的两个特征值所在的通道，固定顺序为先是较大特征值的通道，然后是较小特征值的通道。将四个案例产生的所有八个布尔值聚合到一行输出中，结果为一个无空格、逗号分隔的Python风格列表，例如：“[True,False,True,True,False,False,True,True]”。", "solution": "用户提供了一个在计算量子力学领域中定义明确的问题。我将按照规定，首先推导必要的解析表达式，然后构建一个数值程序来验证这些结果，从而解决此问题。\n\n### 任务1：圈积分 $I_2(-\\kappa^2)$ 的解析计算\n\n问题指定了能量为 $E = -\\kappa^2$ 的束缚态的二体圈积分为：\n$$\nI_2(-\\kappa^2) = \\frac{1}{2\\pi^2} \\int_0^\\infty dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)}\n$$\n其中 $\\kappa > 0$ 且 $\\beta > 0$。这个积分可以使用多种标准技术求解，例如围道积分或部分分式分解。我们将使用后者，因为它更容易理解。被积函数是 $k$ 的偶函数，所以我们可以将积分区间扩展到整个实轴，然后除以2。对于 $\\kappa \\neq \\beta$ 的情况，我们可以分解被积函数。\n一个更直接的方法是使用由部分分式导出的已知恒等式。我们可以写：\n$$\n\\frac{1}{k^2 + \\kappa^2} = \\frac{1}{\\beta^2 - \\kappa^2} \\left( \\frac{\\beta^2 - \\kappa^2 - (k^2+\\beta^2) + (k^2+\\kappa^2)}{k^2+\\kappa^2} \\right) = \\frac{1}{\\beta^2 - \\kappa^2} \\left( \\frac{(k^2+\\beta^2) - (k^2+\\kappa^2)}{k^2+\\kappa^2} \\right)\n$$\n这条路径也过于曲折。一个更稳健的方法是利用留数微积分得到的标准积分公式。我们使用：\n$$\n\\int_0^\\infty \\frac{dx}{(x^2+a^2)^2} = \\frac{\\pi}{4a^3}\n$$\n$$\n\\int_0^\\infty \\frac{dx}{(x^2+a^2)(x^2+b^2)} = \\frac{\\pi}{2ab(a+b)}\n$$\n我们首先根据非重复的分母进行分解：\n$$\n\\frac{1}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)} = \\frac{1}{(\\beta^2-\\kappa^2)} \\left( \\frac{1}{(k^2+\\beta^2)(k^2+\\kappa^2)} - \\frac{1}{(k^2+\\beta^2)^2} \\right) = \\dots\n$$\n一个更直接的分解是：\n$$\n\\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)} = \\frac{1}{\\beta^2-\\kappa^2} \\left[ \\frac{\\beta^2}{(k^2+\\beta^2)^2} - \\frac{\\kappa^2}{(k^2+\\kappa^2)(k^2+\\beta^2)} \\right]\n$$\n逐项积分：\n$$\nJ = \\frac{1}{\\beta^2 - \\kappa^2} \\left[ \\beta^2 \\int_0^\\infty \\frac{dk}{(k^2+\\beta^2)^2} - \\kappa^2 \\int_0^\\infty \\frac{dk}{(k^2+\\kappa^2)(k^2+\\beta^2)} \\right]\n$$\n使用标准积分公式：\n$$\nJ = \\frac{1}{\\beta^2 - \\kappa^2} \\left[ \\beta^2 \\left( \\frac{\\pi}{4\\beta^3} \\right) - \\kappa^2 \\left( \\frac{\\pi}{2\\beta\\kappa(\\beta+\\kappa)} \\right) \\right]\n$$\n$$\nJ = \\frac{1}{\\beta^2 - \\kappa^2} \\left[ \\frac{\\pi}{4\\beta} - \\frac{\\pi\\kappa}{2\\beta(\\beta+\\kappa)} \\right] = \\frac{\\pi}{2\\beta(\\beta^2 - \\kappa^2)} \\left[ \\frac{1}{2} - \\frac{\\kappa}{\\beta+\\kappa} \\right]\n$$\n$$\nJ = \\frac{\\pi}{2\\beta(\\beta-\\kappa)(\\beta+\\kappa)} \\left[ \\frac{\\beta+\\kappa-2\\kappa}{2(\\beta+\\kappa)} \\right] = \\frac{\\pi}{2\\beta(\\beta-\\kappa)(\\beta+\\kappa)} \\frac{\\beta-\\kappa}{2(\\beta+\\kappa)}\n$$\n这简化为：\n$$\nJ = \\frac{\\pi}{4\\beta(\\beta+\\kappa)^2}\n$$\n这个结果在 $\\kappa \\neq \\beta$ 时有效。在 $\\kappa = \\beta$ 的情况下，积分变为 $\\int_0^\\infty k^2/(k^2+\\beta^2)^3 dk = \\pi/(16\\beta^3)$。我们推导的公式给出 $\\lim_{\\kappa\\to\\beta} \\pi/(4\\beta(\\beta+\\kappa)^2) = \\pi/(4\\beta(2\\beta)^2) = \\pi/(16\\beta^3)$，这确认了该公式对所有 $\\kappa > 0, \\beta > 0$ 都有效。\n\n将此结果代回 $I_2$ 的定义：\n$$\nI_2(-\\kappa^2) = \\frac{1}{2\\pi^2} J = \\frac{1}{2\\pi^2} \\frac{\\pi}{4\\beta(\\beta+\\kappa)^2} = \\frac{1}{8\\pi\\beta(\\beta+\\kappa)^2}\n$$\n\n### 任务2：置换矩阵 $P$ 的特征值\n\n给定的置换结构矩阵是：\n$$\nP = \\begin{pmatrix} 3  2 \\\\ 1  4 \\end{pmatrix}\n$$\n特征值 $\\Lambda$ 通过求解特征方程 $\\det(P - \\Lambda I) = 0$ 得到：\n$$\n\\det \\begin{pmatrix} 3-\\Lambda  2 \\\\ 1  4-\\Lambda \\end{pmatrix} = (3-\\Lambda)(4-\\Lambda) - (2)(1) = 0\n$$\n$$\n\\Lambda^2 - 7\\Lambda + 12 - 2 = 0\n$$\n$$\n\\Lambda^2 - 7\\Lambda + 10 = 0\n$$\n对二次方程进行因式分解得到：\n$$\n(\\Lambda-5)(\\Lambda-2) = 0\n$$\n因此，特征值为 $\\Lambda_1 = 5$ 和 $\\Lambda_2 = 2$。\n\n### 任务3：束缚态动量 $\\kappa$ 的解析解\n\n具有特征值 $\\Lambda$ 的通道的束缚态条件由下式给出：\n$$\n\\lambda\\, (\\Lambda - 1)\\, I_2(-\\kappa^2) = 1\n$$\n代入推导出的 $I_2(-\\kappa^2)$ 的解析形式：\n$$\n\\lambda (\\Lambda - 1) \\frac{1}{8\\pi\\beta(\\beta+\\kappa)^2} = 1\n$$\n我们求解 $\\kappa$。整理各项得到：\n$$\n(\\beta+\\kappa)^2 = \\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}\n$$\n由于 $\\beta > 0$ 且我们寻求 $\\kappa > 0$ 的物理束缚态，我们取正平方根：\n$$\n\\beta+\\kappa = \\sqrt{\\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}}\n$$\n分离出 $\\kappa$ 得到显式解析表达式：\n$$\n\\kappa = \\sqrt{\\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}} - \\beta\n$$\n当且仅当其束缚动量 $\\kappa$ 为严格正值时，物理束缚态才存在。这导出以下条件：\n$$\n\\sqrt{\\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}} - \\beta > 0 \\implies \\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta} > \\beta^2\n$$\n因此，对于给定的通道 $\\Lambda$，当且仅当参数满足以下条件时，存在束缚态：\n$$\n\\lambda(\\Lambda-1) > 8\\pi\\beta^3\n$$\n\n### 任务4：数值验证方案\n\n最后一项任务是实现一个程序，用于对照数值过程验证解析结果。程序设计如下：\n\n1.  **遍历测试案例和通道**：程序遍历每个提供的 $(\\lambda, \\beta)$ 参数集，并对每个集合遍历两个特征值通道 $\\Lambda \\in \\{5, 2\\}$。\n\n2.  **解析预测**：对于每个 $(\\lambda, \\beta, \\Lambda)$ 组合，首先使用条件 $\\lambda(\\Lambda-1) > 8\\pi\\beta^3$ 解析地确定是否存在束缚态。如果存在，则使用推导的公式计算相应的 $\\kappa_{analytic}$。\n\n3.  **数值预测**：同时进行数值预测。\n    -   通过计算函数 $F_\\Lambda(\\kappa) \\equiv \\lambda\\, (\\Lambda - 1)\\, I_2(-\\kappa^2) - 1$ 在 $\\kappa=0$ 处的值来确定束缚态是否存在。只有当 $F_\\Lambda(0) > 0$ 时，才可能存在物理根 $\\kappa > 0$，因为 $F_\\Lambda(\\kappa)$ 是一个单调递减函数，当 $\\kappa \\to \\infty$ 时趋近于 $-1$。\n    -   在此数值检查中，$I_2(-\\kappa^2)$ 的值通过对一维积分（$k \\in [0, \\infty)$）使用 `scipy.integrate.quad` 进行数值积分来计算。\n    -   如果 $F_\\Lambda(0) > 0$，则通过对⽅程 $F_\\Lambda(\\kappa) = 0$ 应用一个稳健的区间求根算法 `scipy.optimize.brentq` 来找到数值根 $\\kappa_{numeric}$。搜索区间建立在 $0$ 和一个合适的上限之间，该上限处 $F_\\Lambda$ 变为负值。\n\n4.  **验证与比较**：比较解析和数值结果，为该通道生成一个布尔成功标志。\n    -   如果两种方法都认为不存在束缚态，则布尔值为 `True`。\n    -   如果两种方法都预测存在束缚态，则只有在满足两个进一步的条件（在 $10^{-9}$ 的严格容差内）时，布尔值才为 `True`：\n        1.  解析和数值束缚动量之间的绝对差 $|\\kappa_{analytic} - \\kappa_{numeric}|$ 必须在容差范围内。\n        2.  对于数值找到的 $\\kappa_{numeric}$，必须满足基本归一化条件 $-\\tau(-\\kappa^2) I_2(-\\kappa^2) = 1/\\Lambda$。项 $\\tau(-\\kappa_{numeric}^2)$ 和 $I_2(-\\kappa_{numeric}^2)$ 使用问题的定义和数值积分来计算。此检查验证了整个框架的一致性和数值根的准确性。\n    -   在所有其他情况下，例如存在性预测不匹配或容差检查失败，布尔值为 `False`。\n\n5.  **输出**：将得到的八个布尔标志（四个测试案例，每个案例两个通道）聚合起来，并以指定的列表格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the four-body test problem by comparing analytic and numerical results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 1.0),\n        (20.0, 1.0),\n        (2.0 * np.pi * 1.0001, 1.0),\n        (300.0, 2.0),\n    ]\n\n    # Eigenvalues of the permutation matrix P, ordered from larger to smaller.\n    Lambdas = [5, 2]\n\n    # Absolute tolerance for numerical comparisons.\n    TOL = 1e-9\n\n    results = []\n\n    def I2_integrand(k, kappa, beta):\n        \"\"\"\n        Integrand of the loop integral I_2(-kappa^2) as a function of k.\n        Normalization factor 1/(2*pi^2) is included.\n        \"\"\"\n        if k  0: return 0.0\n        # The expression is k^2 / ((2*pi^2) * (k^2+beta^2)^2 * (k^2+kappa^2))\n        den_term1 = k**2 + beta**2\n        den_term2 = k**2 + kappa**2\n        if den_term1 == 0 or den_term2 == 0:\n            return 0.0 # Avoid division by zero, although k>=0 makes this rare\n        return (k**2 / (den_term1**2 * den_term2)) / (2.0 * np.pi**2)\n\n    for lam, beta in test_cases:\n        for Lambda in Lambdas:\n            \n            # --- Analytic Prediction ---\n            # A physical bound state exists if lambda*(Lambda-1) > 8*pi*beta^3\n            analytic_exists = lam * (Lambda - 1.0) > 8.0 * np.pi * beta**3\n            \n            kappa_analytic = 0.0\n            if analytic_exists:\n                kappa_analytic = np.sqrt(lam * (Lambda - 1.0) / (8.0 * np.pi * beta)) - beta\n            \n            # --- Numeric Prediction ---\n            def F_Lambda_numeric(kappa, lam_val, beta_val, Lambda_val):\n                \"\"\"\n                The function F(kappa) = 0 to be solved. Uses numerical quadrature for I_2.\n                \"\"\"\n                if kappa  0: return np.inf \n                # Use high-precision settings for quad to meet the final tolerance TOL.\n                i2_val, _ = quad(I2_integrand, 0, np.inf, args=(kappa, beta_val),\n                                 epsabs=1e-13, epsrel=1e-13)\n                return lam_val * (Lambda_val - 1.0) * i2_val - 1.0\n\n            # Evaluate at kappa=0 to check for the existence of a physical root (kappa > 0).\n            F_at_zero = F_Lambda_numeric(0, lam, beta, Lambda)\n            numeric_exists = F_at_zero > 0\n            \n            # --- Comparison  Validation ---\n            # Case (i): Both methods agree that no bound state exists.\n            if not analytic_exists and not numeric_exists:\n                results.append(True)\n                continue\n\n            # Case (ii): Both methods agree that a bound state exists.\n            # Then proceed to check if the results match within tolerance.\n            if analytic_exists and numeric_exists:\n                # Find an upper bracket for the root-finding algorithm.\n                # A good guess is a value larger than the analytic solution.\n                upper_bound = max(1.0, 2.0 * kappa_analytic if kappa_analytic > 0 else 2.0 * beta)\n                \n                # Ensure the bracket is valid (F(upper_bound)  0).\n                f_upper = F_Lambda_numeric(upper_bound, lam, beta, Lambda)\n                while f_upper > 0:\n                    upper_bound *= 2.0\n                    f_upper = F_Lambda_numeric(upper_bound, lam, beta, Lambda)\n\n                # Find the numerical root for kappa.\n                kappa_numeric = brentq(F_Lambda_numeric, 0, upper_bound, \n                                       args=(lam, beta, Lambda), xtol=TOL, rtol=TOL)\n\n                # Check 1: Absolute difference in kappa between analytic and numeric solutions.\n                kappa_diff_check = abs(kappa_analytic - kappa_numeric)  TOL\n                \n                # Check 2: Normalization condition using the numerical kappa.\n                # -tau(-kappa^2) * I_2(-kappa^2) = 1/Lambda\n                i2_check, _ = quad(I2_integrand, 0, np.inf, args=(kappa_numeric, beta),\n                                   epsabs=1e-13, epsrel=1e-13)\n                tau_val = -lam / (1.0 + lam * i2_check)\n                norm_val = -tau_val * i2_check\n                norm_check = abs(norm_val - 1.0/Lambda)  TOL\n                \n                if kappa_diff_check and norm_check:\n                    results.append(True)\n                else:\n                    results.append(False)\n            else:\n                # Disagreement on existence.\n                results.append(False)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3608781"}, {"introduction": "在求解散射理论中的积分方程（如雅可布夫斯基方程）时，一个核心挑战是处理传播子核函数中存在的“移动奇点”。本练习提供了一种直接的、动手的方法，来学习如何在动量网格上离散化方程，并实现复数能量方法——一种数值处理这些奇点的标准技术。掌握这项技能对于构建稳定且准确的散射问题求解器至关重要 [@problem_id:3608810]。", "problem": "考虑一个 $N$ 体系统的耦合 Yakubovsky 方程组 (YE)，在球对称 $S$ 波近似下，该系统在动量空间中被简化为两个主导的 Yakubovsky 分量。目标是为相应的耦合积分方程构建动量空间网格离散化，并对由自由预解式产生的在壳点附近的移动奇点实现一种数值稳定的处理方法。出发点必须是 Lippmann–Schwinger 框架和 Yakubovsky 分量分解，其中自由预解式生成的分母在特定动量组合下可能为零，从而产生移动奇点。您将需要构建、离散化并求解一个能够捕捉这些特征的模型系统。\n\n从动量空间中散射的 Lippmann–Schwinger 积分方程和 Yakubovsky 分解出发，将两个分量 $F_1(k)$ 和 $F_2(k)$ 的耦合积分方程建模为\n$$\nF_a(k) = g_a(k) + \\sum_{b=1}^{2} \\int_{0}^{k_{\\max}} dq\\, q^2\\, K_{ab}(k,q)\\, F_b(q), \\quad a \\in \\{1,2\\},\n$$\n其中 $k$ 和 $q$ 表示径向动量，$k_{\\max}$ 是定义网格范围的最大动量，$g_a(k)$ 是驱动项，$K_{ab}(k,q)$ 是表示相互作用与自由预解式组合的有效核。假设模型核的形式为\n$$\nK_{ab}(k,q) = \\lambda_{ab}\\, V(k,q)\\, G_0(k,q;E),\n$$\n其中 $E$ 是总能量（无量纲，使用质量按比例缩放至 $m$ 的一致单位制），$\\lambda_{ab}$ 是控制通道耦合强度的无量纲耦合常数，$V(k,q)$ 是一个光滑的相互作用形状因子，以及\n$$\nG_0(k,q;E) = \\frac{1}{E - \\frac{k^2 + q^2}{2m} + i\\,\\epsilon}\n$$\n是自由预解式，带有一个小的虚部 $i\\,\\epsilon$，用于正则化由 $E = \\frac{k^2 + q^2}{2m}$ 定义的在壳轨迹上的移动奇点。这个移动奇点随 $k$ 变化；作为 $k$ 函数的在壳 $q$ 为 $q_{\\mathrm{on}}(k) = \\sqrt{2mE - k^2}$（当 $2mE \\ge k^2$ 时），否则不在积分域内。对于相互作用，使用一个光滑的球对称形状因子\n$$\nV(k,q) = \\exp\\!\\left(-\\frac{k^2 + q^2}{\\Lambda^2}\\right),\n$$\n其程参数为 $\\Lambda$。令驱动项为\n$$\ng_a(k) = \\exp\\!\\left(-\\frac{k^2}{\\Lambda_g^2}\\right),\n$$\n其中 $\\Lambda_g$ 为有限值。\n\n使用从 $[-1,1]$ 映射到 $[0,k_{\\max}]$ 的 Gauss–Legendre 求积法，在一维动量网格上离散化积分方程，并在权重中保留径向测度 $q^2\\,dq$。具体来说，构造 $N$ 个节点 $\\{k_i\\}_{i=1}^{N}$ 和权重 $\\{w_i\\}_{i=1}^{N}$，选择映射和权重使得积分近似为\n$$\n\\int_{0}^{k_{\\max}} dq\\, q^2\\, f(q) \\approx \\sum_{j=1}^{N} w_j\\, f(k_j),\n$$\n其中每个 $w_j$ 既包含 Gauss–Legendre 权重，也包含映射的雅可比行列式以及 $q^2$ 因子。写出与离散化耦合方程对应的块矩阵形式的线性系统：\n$$\n\\left[\\mathbf{I} - \\mathbf{K}\\right] \\mathbf{F} = \\mathbf{g},\n$$\n其中 $\\mathbf{F} \\in \\mathbb{C}^{2N}$ 堆叠了离散化的分量，$\\mathbf{g} \\in \\mathbb{C}^{2N}$ 堆叠了驱动项，而 $\\mathbf{K} \\in \\mathbb{C}^{2N \\times 2N}$ 由四个 $N \\times N$ 块组成，其元素为\n$$\n\\left(K_{ab}\\right)_{ij} = w_j\\, \\lambda_{ab}\\, V(k_i,k_j)\\, \\frac{1}{E - \\frac{k_i^2 + k_j^2}{2m} + i\\,\\epsilon}.\n$$\n您必须通过实现一种数值稳定的处理方法来直接处理在壳点附近的移动奇点。可接受的方法包括上述使用 $i\\,\\epsilon$ 的复能量正则化、主值减除方案或混合方法。您的程序应实现复能量正则化，并求解由此产生的关于 $\\mathbf{F}$ 的复线性系统。\n\n您的任务是：\n- 根据上述说明，从第一性原理推导离散化线性系统，论证求积法和测度的合理性，并解释对移动奇点的处理方法。\n- 实现一个完整的、可运行的程序，该程序能够构建网格、组装块矩阵、求解 $\\mathbf{F}$，并返回解的定量诊断信息。诊断信息必须是每个分量实部和虚部的平方可积范数，使用相同的求积权重计算：对于分量 $a$，计算\n$$\n\\| \\Re(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Re(F_a(k_i))\\right]^2 \\right)^{1/2}, \\quad\n\\| \\Im(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Im(F_a(k_i))\\right]^2 \\right)^{1/2}.\n$$\n不需要物理单位；所有量均为无量纲。\n\n提供一个包含三组参数的测试套件，用以探测移动奇点的不同区域：\n- 测试 1（理想情况，在壳点位于域内，适度正则化）：$N=64$, $k_{\\max}=4.0$, $m=1.0$, $E=8.0$, $\\epsilon=10^{-2}$, $\\Lambda=2.0$, $\\Lambda_g=2.0$, $\\lambda_{11}=0.5$, $\\lambda_{12}=0.2$, $\\lambda_{21}=0.2$, $\\lambda_{22}=0.5$。\n- 测试 2（近阈值能量，在壳点靠近下边界）：$N=64$, $k_{\\max}=4.0$, $m=1.0$, $E=0.1$, $\\epsilon=10^{-2}$, $\\Lambda=2.0$, $\\Lambda_g=2.0$, $\\lambda_{11}=0.5$, $\\lambda_{12}=0.2$, $\\lambda_{21}=0.2$, $\\lambda_{22}=0.5$。\n- 测试 3（使用更小虚部、更具挑战性的正则化）：$N=80$, $k_{\\max}=4.0$, $m=1.0$, $E=8.0$, $\\epsilon=10^{-6}$, $\\Lambda=2.0$, $\\Lambda_g=2.0$, $\\lambda_{11}=0.5$, $\\lambda_{12}=0.2$, $\\lambda_{21}=0.2$, $\\lambda_{22}=0.5$。\n\n对于每个测试用例，按以下顺序输出四个浮点数诊断信息\n$$\n\\left[ \\| \\Re(F_1) \\|_2,\\, \\| \\Re(F_2) \\|_2,\\, \\| \\Im(F_1) \\|_2,\\, \\| \\Im(F_2) \\|_2 \\right],\n$$\n将三个测试的结果合并成一个列表，作为整个程序运行的单一输出。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按规定顺序连接了三个测试得出的十二个浮点数（例如，$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12}]$）。不应打印任何其他文本。", "solution": "我们从动量空间中散射态的 Lippmann–Schwinger 公式出发，其中跃迁算符 $T$ 满足\n$$\nT = V + V G_0(E) T,\n$$\n其中 $V$ 是相互作用，$G_0(E)$ 是自由预解式。在 $N$ 体情景中，Yakubovsky 方程组 (YE) 将完整的波函数分解为分量 $F_a$，这些分量满足由划分和子团簇相互作用构成的耦合积分方程。在球对称和模型简化为两个主导分量的 $S$ 波近似下，关于径向动量的耦合方程为\n$$\nF_a(k) = g_a(k) + \\sum_{b=1}^{2}\\int_{0}^{k_{\\max}} dq\\, q^2\\, K_{ab}(k,q)\\, F_b(q),\n$$\n其中 $q^2$ 测度源于三维动量积分在球坐标系下的雅可比行列式。核\n$$\nK_{ab}(k,q) = \\lambda_{ab}\\, V(k,q)\\, G_0(k,q;E)\n$$\n捕捉了相互作用和传播的基本结构，其中\n$$\nG_0(k,q;E) = \\frac{1}{E - \\frac{k^2 + q^2}{2m} + i\\,\\epsilon}\n$$\n是模型自由预解式。分母 $E - \\frac{k^2 + q^2}{2m}$ 在在壳轨迹\n$$\nq_{\\mathrm{on}}(k) = \\sqrt{2mE - k^2}, \\quad \\text{当}\\quad 2mE \\ge k^2 \\text{时}\n$$\n上为零。该轨迹依赖于 $k$，因此称为“移动奇点”，这在 Yakubovsky 型核中很典型，其中旁观动量会改变奇异流形的位置。\n\n为构建动量空间网格离散化，我们应用 Gauss–Legendre 求积法。使用\n$$\nq(x) = \\frac{k_{\\max}}{2}\\,(x+1)\n$$\n将 $x \\in [-1,1]$ 映射到 $q \\in [0,k_{\\max}]$。设 $(x_j, \\omega_j)$ 为 $[-1,1]$ 上的 Gauss–Legendre 节点和权重，其中 $j \\in \\{1,\\dots,N\\}$。积分\n$$\n\\int_{0}^{k_{\\max}} dq\\, q^2\\, f(q)\n$$\n近似为\n$$\n\\sum_{j=1}^{N} w_j\\, f(q_j), \\quad \\text{其中} \\quad q_j = \\frac{k_{\\max}}{2}\\,(x_j+1), \\quad w_j = \\left(\\frac{k_{\\max}}{2}\\right)\\, \\omega_j\\, q_j^2.\n$$\n此处 $w_j$ 包含了映射的雅可比因子 $\\frac{k_{\\max}}{2}$ 和适用于 $S$ 波积分的 $q^2$ 测度。\n\n用 $k_i$ 表示“外部”动量的相同映射节点，离散化的耦合方程产生块线性系统\n$$\n\\left[\\mathbf{I} - \\mathbf{K}\\right] \\mathbf{F} = \\mathbf{g}, \\quad \\mathbf{F} \\in \\mathbb{C}^{2N},\\ \\mathbf{g} \\in \\mathbb{C}^{2N}.\n$$\n块矩阵 $\\mathbf{K}$ 具有 $N \\times N$ 的块，由\n$$\n\\left(K_{ab}\\right)_{ij} = w_j\\, \\lambda_{ab}\\, V(k_i,k_j)\\, \\frac{1}{E - \\frac{k_i^2 + k_j^2}{2m} + i\\,\\epsilon}\n$$\n给出，它忠实地离散化了\n$$\n\\int_{0}^{k_{\\max}} dq\\, q^2\\, K_{ab}(k_i,q)\\, F_b(q) \\approx \\sum_{j=1}^{N} \\left(K_{ab}\\right)_{ij} F_b(k_j).\n$$\n\n当对某些 $(i,j)$ 有 $E - \\frac{k_i^2 + k_j^2}{2m} = 0$ 时，即当 $k_j = q_{\\mathrm{on}}(k_i)$ 时，会出现移动奇点。不进行正则化的直接求积在数值上会不稳定。一种基于复分析的原则性方法（并广泛用于散射积分）是在能量中引入一个小的虚部 $i\\,\\epsilon$，即在预解式中用 $E + i\\,\\epsilon$ 替换 $E$。这得到\n$$\nG_0(k,q;E) \\to \\frac{1}{E - \\frac{k^2 + q^2}{2m} + i\\,\\epsilon},\n$$\n它有效地将单极点转换为宽度为 $\\epsilon$ 的洛伦兹分布，实现了因果格林函数，并提供了一个表现良好的数值被积函数。在极限 $\\epsilon \\to 0^+$ 下，解的实部趋近于主值贡献，而虚部则编码了与极点相关的在壳强度。替代方法包括解析主值减除法和对数奇点分离法，但复能量正则化对于数值计算而言简单而稳健。\n\n对于相互作用，我们选择一个光滑的、紫外调节的形状因子\n$$\nV(k,q) = \\exp\\!\\left(-\\frac{k^2 + q^2}{\\Lambda^2}\\right),\n$$\n和驱动项\n$$\ng_a(k) = \\exp\\!\\left(-\\frac{k^2}{\\Lambda_g^2}\\right),\n$$\n它们提供了良态的输入并模拟了有限程物理。\n\n算法步骤：\n- 在 $[-1,1]$ 上选择 $N$ 个 Gauss–Legendre 节点和权重 $(x_j,\\omega_j)$，将它们映射到 $[0,k_{\\max}]$ 以形成 $\\{k_j\\}$，并构造包含 $q^2$ 的径向权重 $\\{w_j\\}$。\n- 使用所选参数和复预解式 $G_0$ 构建 $\\mathbf{K}$ 的四个 $N \\times N$ 块。\n- 组装 $\\mathbf{I} - \\mathbf{K}$ 和向量 $\\mathbf{g}$（堆叠的 $g_1$ 和 $g_2$），并求解关于 $\\mathbf{F}$ 的复线性系统。\n- 计算每个分量的诊断信息：\n$$\n\\| \\Re(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Re(F_a(k_i))\\right]^2 \\right)^{1/2}, \\quad\n\\| \\Im(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Im(F_a(k_i))\\right]^2 \\right)^{1/2}.\n$$\n\n测试覆盖范围 rationale：\n- 测试 1 中 $E=8.0$ 和 $k_{\\max}=4.0$ 将在壳条件置于许多 $k_i$ 的积分域内，从而在保持 $\\epsilon=10^{-2}$ 足够大以确保数值稳定性的同时，检验了正则化方法。\n- 测试 2 中 $E=0.1$ 将在壳轨迹置于小 $k$ 值的下边界附近，探测了近阈值行为和边界敏感性。\n- 测试 3 使用 $\\epsilon=10^{-6}$，以一个更尖锐的准极点来挑战求解器，评估了复能量正则化在更奇异情况下的稳定性和收敛性。\n\n程序按照规定的单行格式输出十二个浮点数，从而能够在不同参数体系下进行验证和比较。不需要物理单位，因为在所选的标度下，所有量都是无量纲的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gauss_legendre_nodes_weights(n, a, b):\n    \"\"\"\n    Compute Gauss-Legendre nodes and weights mapped from [-1,1] to [a,b].\n    Returns nodes q_j and base weights w_base_j (Jacobian included but not q^2).\n    \"\"\"\n    # Legendre nodes and weights on [-1,1]\n    x, w = np.polynomial.legendre.leggauss(n)\n    # Map to [a,b]\n    q = 0.5 * (b - a) * (x + 1.0) + a\n    jac = 0.5 * (b - a)\n    w_base = w * jac\n    return q, w_base\n\ndef build_blocks(k_nodes, w_radial, params):\n    \"\"\"\n    Build the four N x N kernel blocks K11, K12, K21, K22.\n    w_radial are the full radial weights including q^2 factor.\n    params: dict containing m, E, eps, Lambda, lambdas\n    \"\"\"\n    N = len(k_nodes)\n    m = params[\"m\"]\n    E = params[\"E\"]\n    eps = params[\"eps\"]\n    Lam = params[\"Lambda\"]\n    lam11 = params[\"lam11\"]\n    lam12 = params[\"lam12\"]\n    lam21 = params[\"lam21\"]\n    lam22 = params[\"lam22\"]\n\n    # Precompute V(k_i, k_j) and resolvent\n    k_i = k_nodes[:, None]  # shape (N,1)\n    k_j = k_nodes[None, :]  # shape (1,N)\n    V = np.exp(-(k_i**2 + k_j**2) / (Lam**2))\n    denom = (E - (k_i**2 + k_j**2) / (2.0 * m)) + 1j * eps\n    G0 = 1.0 / denom\n\n    # Each block includes weights w_j (radial) on the right\n    W = w_radial[None, :]  # shape (1,N)\n\n    K11 = (lam11 * V * G0) * W\n    K12 = (lam12 * V * G0) * W\n    K21 = (lam21 * V * G0) * W\n    K22 = (lam22 * V * G0) * W\n\n    return K11, K12, K21, K22\n\ndef build_system(N, kmax, m, E, eps, Lambda, Lambda_g, lam11, lam12, lam21, lam22):\n    \"\"\"\n    Construct the block matrix (I - K) and RHS vector g for the coupled system.\n    \"\"\"\n    # Nodes and base weights on [0, kmax]\n    k_nodes, w_base = gauss_legendre_nodes_weights(N, 0.0, kmax)\n    # Radial weights include q^2 factor\n    w_radial = w_base * (k_nodes**2)\n\n    # Driving terms g1, g2\n    g1 = np.exp(-(k_nodes**2) / (Lambda_g**2))\n    g2 = np.exp(-(k_nodes**2) / (Lambda_g**2))\n\n    # Kernel blocks\n    params = {\n        \"m\": m, \"E\": E, \"eps\": eps, \"Lambda\": Lambda,\n        \"lam11\": lam11, \"lam12\": lam12, \"lam21\": lam21, \"lam22\": lam22\n    }\n    K11, K12, K21, K22 = build_blocks(k_nodes, w_radial, params)\n\n    # Assemble block matrix A = I - K\n    I = np.eye(N, dtype=complex)\n    A11 = I - K11\n    A12 = -K12\n    A21 = -K21\n    A22 = I - K22\n\n    # Stack into 2N x 2N\n    top = np.concatenate([A11, A12], axis=1)\n    bottom = np.concatenate([A21, A22], axis=1)\n    A = np.concatenate([top, bottom], axis=0)\n\n    # RHS vector g (stacked)\n    g = np.concatenate([g1, g2]).astype(complex)\n\n    return A, g, k_nodes, w_radial\n\ndef solve_case(case):\n    \"\"\"\n    Solve one test case and return diagnostics:\n    [||Re(F1)||2, ||Re(F2)||2, ||Im(F1)||2, ||Im(F2)||2]\n    \"\"\"\n    N = case[\"N\"]\n    kmax = case[\"kmax\"]\n    m = case[\"m\"]\n    E = case[\"E\"]\n    eps = case[\"eps\"]\n    Lambda = case[\"Lambda\"]\n    Lambda_g = case[\"Lambda_g\"]\n    lam11 = case[\"lam11\"]\n    lam12 = case[\"lam12\"]\n    lam21 = case[\"lam21\"]\n    lam22 = case[\"lam22\"]\n\n    A, g, k_nodes, w_radial = build_system(N, kmax, m, E, eps, Lambda, Lambda_g, lam11, lam12, lam21, lam22)\n\n    # Solve linear system\n    F = np.linalg.solve(A, g)\n\n    # Split components\n    F1 = F[:N]\n    F2 = F[N:]\n\n    # Compute norms using radial weights\n    re_F1 = np.real(F1)\n    re_F2 = np.real(F2)\n    im_F1 = np.imag(F1)\n    im_F2 = np.imag(F2)\n\n    # Quadrature-based L2 norms\n    n_re_F1 = float(np.sqrt(np.sum(w_radial * (re_F1**2))))\n    n_re_F2 = float(np.sqrt(np.sum(w_radial * (re_F2**2))))\n    n_im_F1 = float(np.sqrt(np.sum(w_radial * (im_F1**2))))\n    n_im_F2 = float(np.sqrt(np.sum(w_radial * (im_F2**2))))\n\n    return [n_re_F1, n_re_F2, n_im_F1, n_im_F2]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64, \"kmax\": 4.0, \"m\": 1.0, \"E\": 8.0, \"eps\": 1e-2,\n            \"Lambda\": 2.0, \"Lambda_g\": 2.0,\n            \"lam11\": 0.5, \"lam12\": 0.2, \"lam21\": 0.2, \"lam22\": 0.5\n        },\n        {\n            \"N\": 64, \"kmax\": 4.0, \"m\": 1.0, \"E\": 0.1, \"eps\": 1e-2,\n            \"Lambda\": 2.0, \"Lambda_g\": 2.0,\n            \"lam11\": 0.5, \"lam12\": 0.2, \"lam21\": 0.2, \"lam22\": 0.5\n        },\n        {\n            \"N\": 80, \"kmax\": 4.0, \"m\": 1.0, \"E\": 8.0, \"eps\": 1e-6,\n            \"Lambda\": 2.0, \"Lambda_g\": 2.0,\n            \"lam11\": 0.5, \"lam12\": 0.2, \"lam21\": 0.2, \"lam22\": 0.5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        diagnostics = solve_case(case)\n        results.extend(diagnostics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3608810"}, {"introduction": "实际的计算总是在有限的基组或网格上进行，这必然会引入截断误差。为了获得具有物理意义的结果，我们必须将计算外推到无限基组的极限。本练习将指导您完成这一关键的数据分析过程：使用一个具有物理动机的模型，对一系列在有限基组下的计算结果进行加权非线性回归，从而提取出高精度的物理可观测量 [@problem_id:3608760]。", "problem": "你必须编写一个完整、可运行的程序，该程序定量研究在最大总角动量 $j_{\\max}$ 的分波截断下，从 $N$ 体问题的雅可布斯基方程计算出的束缚态能量的收敛行为。该问题的基础是核系统的非相对论性薛定谔方程、$N$ 体波函数的法捷耶夫-雅可布斯基分解，以及在球谐函数中耦合到总角动量的分波展开。对于具有有限有效力程和紫外正则化的短程核相互作用，离心势垒会抑制高阶分波分量，而在 $j_{\\max}$ 处截断所遗漏的贡献会随着 $j_{\\max}$ 的增加而迅速衰减。在渐近区域，当包含额外的分波时，能量的增量变化很小，并且根据经验观察到其遵循指数趋势，这与大角动量的 Wentzel–Kramers–Brillouin (WKB) 抑制效应相符。\n\n你的程序必须：\n- 实现加权非线性回归，以从模型 $E(j_{\\max}) = E_{\\infty} + a \\exp(-b j_{\\max})$ 估计收敛（无限分波）能量 $E_{\\infty}$，其中 $a \\ge 0$，$b \\ge 0$ 且 $j_{\\max}$ 是无量纲的。\n- 通过将高阶分波的抑制与离心势垒及核相互作用的短程特性联系起来，论证指数模型的合理性（此论证必须在解答推导中呈现，而非在代码中）。\n- 使用提供的测试套件数据（能量及其不确定度），并以权重 $w_i = 1/\\sigma_i^2$ 进行加权最小二乘拟合，其中 $\\sigma_i$ 是在 $j_{\\max,i}$ 处的能量不确定度。\n- 通过截断值 $j_{\\mathrm{cut}}$ 排除预渐近区，即仅对 $j_{\\max} \\ge j_{\\mathrm{cut}}$ 的数据进行拟合，以减少模型偏差。\n- 返回 $E_{\\infty}$ 的估计值及其单标准差不确定度（加权拟合所得参数协方差矩阵中对应对角元素的平方根）。\n\n科学真实性与一致性：\n- 假设一个非相对论性核哈密顿量，其具有短程相互作用和一个确保雅可布斯基积分方程数值稳定性的正则化标度。高 $j$ 分量被离心势垒项 $j(j+1)/r^2$ 和势的有限力程所抑制。\n- 角度单位（对于解释为角动量量子数的 $j$）是无量纲的，不需要单位说明。\n- 能量必须以兆电子伏特（MeV）表示。所有报告的能量和不确定度都必须以 MeV 为单位打印，并四舍五入到六位小数。\n\n测试套件：\n对于每个案例，都给你一系列分波截断值 $j_{\\max}$、相应的束缚态能量 $E(j_{\\max})$（单位 MeV）和不确定度 $\\sigma$（单位 MeV），以及一个截断值 $j_{\\mathrm{cut}}$。\n\n- 案例 1（理想情况，表现良好的指数衰减）：\n  - $j_{\\max}$ 值：$[\\,2,\\,3,\\,4,\\,5,\\,6,\\,7,\\,8\\,]$\n  - 能量（MeV）：$[\\, -27.107517,\\, -27.673410,\\, -27.917189,\\, -28.032922,\\, -28.081851,\\, -28.103705,\\, -28.115192 \\,]$\n  - 不确定度（MeV）：$[\\, 0.03,\\, 0.02,\\, 0.02,\\, 0.015,\\, 0.015,\\, 0.015,\\, 0.015 \\,]$\n  - $j_{\\mathrm{cut}}$: $3$\n\n- 案例 2（边界情况，振幅很小且接近收敛的数据）：\n  - $j_{\\max}$ 值：$[\\,4,\\,6,\\,8,\\,10\\,]$\n  - 能量（MeV）：$[\\, -4.996900,\\, -4.999350,\\, -4.999760,\\, -4.999960 \\,]$\n  - 不确定度（MeV）：$[\\, 0.0005,\\, 0.0005,\\, 0.0005,\\, 0.0005 \\,]$\n  - $j_{\\mathrm{cut}}$: $0$\n\n- 案例 3（包含一个离群值和预渐近点的边缘情况，通过截断值和权重来缓解）：\n  - $j_{\\max}$ 值：$[\\,1,\\,2,\\,3,\\,4,\\,5,\\,6\\,]$\n  - 能量（MeV）：$[\\, -10.776940,\\, -11.269240,\\, -11.053740,\\, -11.727330,\\, -11.836830,\\, -11.900430 \\,]$\n  - 不确定度（MeV）：$[\\, 0.02,\\, 0.02,\\, 0.2,\\, 0.02,\\, 0.02,\\, 0.02 \\,]$\n  - $j_{\\mathrm{cut}}$: $3$\n\n算法要求：\n- 使用加权非线性最小二乘法拟合模型 $E(j_{\\max}) = E_{\\infty} + a \\exp(-b j_{\\max})$，其中边界条件为 $a \\ge 0$、$b \\ge 0$，而对 $E_{\\infty}$ 没有边界限制。\n- 在拟合前，使用 $j_{\\mathrm{cut}}$ 筛选数据集，使其满足 $j_{\\max} \\ge j_{\\mathrm{cut}}$。\n- 使用标准加权最小二乘公式计算参数协方差矩阵，并提取 $E_{\\infty}$ 的 $1\\sigma$ 不确定度，即 $\\sqrt{\\mathrm{Cov}(E_{\\infty}, E_{\\infty})}$。\n- 如果非线性拟合未能收敛，则执行一个后备搜索：在一个合理范围内扫描 $b$，并在固定的 $b$ 值下为 $E_{\\infty}$ 和 $a$ 求解加权线性最小二乘问题，选择使加权残差平方和最小的 $b$ 值；然后根据局部雅可比矩阵和权重矩阵估计 $E_{\\infty}$ 的不确定度。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表的列表形式的结果。每个内部列表包含对应案例的 $E_{\\infty}$ 及其不确定度，二者均以 MeV 为单位，并四舍五入到六位小数。例如，输出应类似于 $[[E_{\\infty,1},\\sigma_{E,1}],[E_{\\infty,2},\\sigma_{E,2}],[E_{\\infty,3},\\sigma_{E,3}]]$，其中所有数字都以十进制浮点数打印。\n\n所有在此问题陈述中的数学实体和数字均已按要求以 LaTeX 格式编写。", "solution": "该问题要求将一系列在不同分波截断水平 $j_{\\max}$ 下计算出的束缚态能量外推至无限分波极限（$j_{\\max} \\to \\infty$）。这是第一性原理核结构计算中的一项常见任务，其中基组截断对于计算可行性而言是必需的。解决方案涉及使用一个具有物理动机的模型，对所提供的数据执行加权非线性回归。\n\n### 外推模型的论证\n\n基态能量 $E$ 相对于基组中所包含的最大角动量 $j_{\\max}$ 的收敛性，由核相互作用的性质和薛定谔方程决定。此外推的模型由下式给出：\n$$\nE(j_{\\max}) = E_{\\infty} + a \\exp(-b j_{\\max})\n$$\n其中 $E(j_{\\max})$ 是在 $j_{\\max}$ 处截断计算的能量，$E_{\\infty}$ 是在无限基组极限下期望的收敛能量，$a$ 和 $b$ 是取决于核系统具体细节的正常数（$a \\ge 0$，$b \\ge 0$）。\n\n这种指数形式的合理性源于径向薛定谔方程在分波展开中有效势的行为。对于两体势，给定轨道角动量为 $l$ 的分波的径向方程包含一个离心项：\n$$\nV_{\\text{eff}}(r) = V(r) + \\frac{\\hbar^2 l(l+1)}{2\\mu r^2}\n$$\n其中 $V(r)$ 是核势，$\\mu$ 是折合质量。对于 $N$ 体问题，在涉及超角动量的超径向方程中也会出现类似的结构。总角动量 $j$ 是由轨道角动量和自旋角动量耦合而成，但对高阶基态的主要抑制作用来自于与高轨道角动量相关的离心势垒。\n\n让我们考虑这个势垒在大角动量情况下的影响，这对应于在高 $j_{\\max}$ 处被截断的分量。核势 $V(r)$ 是短程的，意味着当距离 $r$ 超过几飞米时，它们会迅速衰减为零。对于大的 $l$，离心项 $\\propto l(l+1)/r^2$ 产生了一个巨大的排斥势垒，阻止粒子在核势具有吸引力且很强的短距离内相互接近。\n\n高 $l$ 分波对总能量的贡献与波函数穿透到势区域的程度有关。根据 Wentzel–Kramers–Brillouin (WKB) 近似，隧穿通过势垒的概率是指数抑制的。在离心势垒下的经典禁区内，波函数振幅作为随 $l$ 增长的量的函数呈指数衰减。因此，增加一个具有大角动量 $j$（或 $l$）的分波所带来的能量贡献，预计会随 $j$ 呈指数下降。将这些贡献相加，得到的剩余截断误差也随截断值 $j_{\\max}$ 呈指数衰减。所提出的模型 $E(j_{\\max}) - E_{\\infty} = a \\exp(-b j_{\\max})$ 直接反映了这种指数抑制。施加条件 $j_{\\max} \\ge j_{\\mathrm{cut}}$ 是因为这种渐近指数行为仅在 $j_{\\max}$ 足够大，且可能不遵循简单趋势的预渐近效应已经消退后才有效。\n\n### 加权非线性最小二乘回归\n\n模型 $f(j; E_{\\infty}, a, b) = E_{\\infty} + a \\exp(-b j)$ 的参数 $E_{\\infty}$、$a$ 和 $b$ 是通过对所提供的数据 $(j_{\\max,i}, E_i \\pm \\sigma_i)$ 进行拟合来确定的。由于数据点具有不同的不确定度 $\\sigma_i$，因此采用加权最小二乘法是合适的。最优参数是那些最小化加权残差平方和（即卡方 $\\chi^2$ 统计量）的参数：\n$$\n\\chi^2(E_{\\infty}, a, b) = \\sum_{i \\in S} \\left( \\frac{E_i - f(j_{\\max,i}; E_{\\infty}, a, b)}{\\sigma_i} \\right)^2 = \\sum_{i \\in S} w_i \\left(E_i - (E_{\\infty} + a \\exp(-b j_{\\max,i}))\\right)^2\n$$\n求和遍及索引集 $S = \\{i \\mid j_{\\max,i} \\ge j_{\\mathrm{cut}}\\}$。权重定义为 $w_i = 1/\\sigma_i^2$，这给予不确定度较小的数据点更大的影响。最小化过程受约束条件 $a \\ge 0$ 和 $b \\ge 0$ 的限制。\n\n这是一个非线性优化问题，可以使用诸如 Levenberg-Marquardt 算法等数值算法求解，该算法在像 `scipy.optimize.curve_fit` 这样的科学计算库中有实现。\n\n### 不确定度估计\n\n拟合参数的不确定度源自协方差矩阵 $\\mathrm{Cov}$。对于非线性模型，在 $\\chi^2$ 最小值附近，协方差矩阵可以很好地由 $\\chi^2$ 函数的 Hessian 矩阵的逆矩阵经适当缩放来近似。一个标准的近似是：\n$$\n\\mathrm{Cov} \\approx (J^T W J)^{-1}\n$$\n其中 $W$ 是权重的对角矩阵（$W_{ii} = w_i = 1/\\sigma_i^2$），$J$ 是模型函数相对于参数的雅可比矩阵，在最佳拟合值处进行评估。雅可比矩阵的元素由模型函数的偏导数给出：\n$$\nJ_{ik} = \\frac{\\partial f(j_{\\max,i}; \\mathbf{p})}{\\partial p_k}\n$$\n其中 $\\mathbf{p} = (E_{\\infty}, a, b)$ 是参数矢量。这些导数是：\n$$\n\\frac{\\partial f}{\\partial E_{\\infty}} = 1\n$$\n$$\n\\frac{\\partial f}{\\partial a} = \\exp(-b j_{\\max,i})\n$$\n$$\n\\frac{\\partial f}{\\partial b} = -a j_{\\max,i} \\exp(-b j_{\\max,i})\n$$\n协方差矩阵是一个 $3 \\times 3$ 的矩阵，其对角元素 $\\mathrm{Cov}_{kk}$ 是拟合参数 $p_k$ 的方差 ($\\sigma_{p_k}^2$)。因此，外推能量 $E_{\\infty}$ 的单标准差不确定度是协方差矩阵第一个对角元素的平方根：\n$$\n\\sigma_{E_{\\infty}} = \\sqrt{\\mathrm{Cov}_{00}}\n$$\n此过程既提供了收敛能量的最优估计，也提供了基于数据和模型的统计不确定性度量。如果主非线性优化器未能收敛，问题中指定的后备程序（涉及对参数 $b$ 进行网格搜索）是一个稳健的替代方案。对于固定的 $b$，后备程序的线性部分求解加权正规方程，并且仍然可以使用在最终发现的最小值处的雅可比矩阵来计算不确定度。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.linalg import solve as linsolve\nfrom scipy.linalg import inv\n\ndef solve():\n    \"\"\"\n    Performs weighted nonlinear regression to extrapolate bound-state energies\n    and calculates the uncertainty on the extrapolated value.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"j_max\": np.array([2, 3, 4, 5, 6, 7, 8]),\n            \"energies\": np.array([-27.107517, -27.673410, -27.917189, -28.032922, -28.081851, -28.103705, -28.115192]),\n            \"uncertainties\": np.array([0.03, 0.02, 0.02, 0.015, 0.015, 0.015, 0.015]),\n            \"j_cut\": 3\n        },\n        {\n            \"j_max\": np.array([4, 6, 8, 10]),\n            \"energies\": np.array([-4.996900, -4.999350, -4.999760, -4.999960]),\n            \"uncertainties\": np.array([0.0005, 0.0005, 0.0005, 0.0005]),\n            \"j_cut\": 0\n        },\n        {\n            \"j_max\": np.array([1, 2, 3, 4, 5, 6]),\n            \"energies\": np.array([-10.776940, -11.269240, -11.053740, -11.727330, -11.836830, -11.900430]),\n            \"uncertainties\": np.array([0.02, 0.02, 0.2, 0.02, 0.02, 0.02]),\n            \"j_cut\": 3\n        }\n    ]\n\n    def exp_model(j, E_inf, a, b):\n        \"\"\"Exponential model for energy convergence.\"\"\"\n        return E_inf + a * np.exp(-b * j)\n\n    def fallback_fit(j, E, sigma, j_cut):\n        \"\"\"Fallback grid search method if curve_fit fails.\"\"\"\n        # Filter data\n        mask = j >= j_cut\n        j_filt = j[mask]\n        E_filt = E[mask]\n        sigma_filt = sigma[mask]\n        weights = 1.0 / sigma_filt**2\n\n        b_range = np.logspace(-2, 1, 100) # Scan b over a reasonable range\n        min_chi2 = np.inf\n        best_params = None\n\n        for b_val in b_range:\n            X = np.exp(-b_val * j_filt)\n            \n            # Weighted linear least squares for E_inf and a for a fixed b\n            # Model: E = E_inf * 1 + a * X\n            # Normal equations: (A.T @ W @ A) @ p = A.T @ W @ E\n            A = np.vstack([np.ones_like(X), X]).T\n            W = np.diag(weights)\n            \n            try:\n                lhs = A.T @ W @ A\n                rhs = A.T @ W @ E_filt\n                E_inf_val, a_val = linsolve(lhs, rhs)\n            except np.linalg.LinAlgError:\n                continue # Skip singular matrix cases\n\n            if a_val  0: # Enforce constraint a >= 0\n                continue\n                \n            residuals = E_filt - (E_inf_val + a_val * X)\n            chi2 = np.sum(weights * residuals**2)\n\n            if chi2  min_chi2:\n                min_chi2 = chi2\n                best_params = [E_inf_val, a_val, b_val]\n        \n        if best_params is None:\n            raise RuntimeError(\"Fallback fit also failed.\")\n\n        # Estimate covariance matrix at the discovered minimum\n        E_inf_opt, a_opt, b_opt = best_params\n        \n        # Jacobian matrix J_ik = df_i/dp_k\n        J = np.zeros((len(j_filt), 3))\n        J[:, 0] = 1.0  # d/dE_inf\n        J[:, 1] = np.exp(-b_opt * j_filt) # d/da\n        J[:, 2] = -a_opt * j_filt * np.exp(-b_opt * j_filt) # d/db\n\n        W = np.diag(weights)\n        \n        try:\n            pcov = inv(J.T @ W @ J)\n        except np.linalg.LinAlgError:\n            # If Hessian is singular, we cannot determine uncertainties\n            # Return NaN for uncertainty in this edge case.\n            pcov = np.full((3, 3), np.nan)\n\n        return np.array(best_params), pcov\n\n\n    results = []\n    for case in test_cases:\n        j_max = case[\"j_max\"]\n        energies = case[\"energies\"]\n        uncertainties = case[\"uncertainties\"]\n        j_cut = case[\"j_cut\"]\n\n        # Filter the data based on j_cut\n        mask = j_max >= j_cut\n        j_filtered = j_max[mask]\n        E_filtered = energies[mask]\n        sigma_filtered = uncertainties[mask]\n\n        # Provide reasonable initial guesses and bounds\n        if len(j_filtered)  3: # Need at least 3 points for a 3-param fit\n            if len(j_filtered) >= 2:\n                 # If not enough data, use fallback which can handle fewer points for LinLS part\n                 popt, pcov = fallback_fit(j_max, energies, uncertainties, j_cut)\n            else:\n                 # Cannot solve, append NaNs or handle error\n                results.append([np.nan, np.nan])\n                continue\n        else:\n            E_inf_guess = E_filtered[-1]\n            a_guess = np.abs(E_filtered[0] - E_filtered[-1])\n            # Handle case where a_guess is zero or negative\n            if a_guess  1e-9: a_guess = 1e-9\n            b_guess = 1.0\n            p0 = [E_inf_guess, a_guess, b_guess]\n            bounds = ([-np.inf, 0, 0], [np.inf, np.inf, np.inf])\n\n            try:\n                popt, pcov = curve_fit(\n                    exp_model,\n                    j_filtered,\n                    E_filtered,\n                    p0=p0,\n                    sigma=sigma_filtered,\n                    absolute_sigma=True,\n                    bounds=bounds,\n                    method='trf',\n                    max_nfev=5000\n                )\n            except RuntimeError:\n                # If curve_fit fails, use the fallback mechanism\n                popt, pcov = fallback_fit(j_max, energies, uncertainties, j_cut)\n\n        E_inf_estimate = popt[0]\n        # Uncertainty is the sqrt of the diagonal element of the covariance matrix\n        E_inf_uncertainty = np.sqrt(pcov[0, 0])\n\n        results.append([E_inf_estimate, E_inf_uncertainty])\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3608760"}]}