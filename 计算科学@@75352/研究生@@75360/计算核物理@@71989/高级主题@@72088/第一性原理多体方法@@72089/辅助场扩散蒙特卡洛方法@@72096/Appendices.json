{"hands_on_practices": [{"introduction": "在任何蒙特卡洛模拟的核心，都是对给定粒子构型（即“行走点”）能量的评估。在辅助场扩散蒙特卡洛（AFDMC）方法中，这意味着要处理复杂的核相互作用，其能量贡献强烈依赖于核子的自旋与同位旋状态。本练习 [@problem_id:3542892] 旨在阐明核力中两个关键的非中心力部分——张量力和自旋轨道相互作用——是如何作用于不同自旋态并对局域能量产生贡献的，这是AFDMC模拟中每一步都必须执行的基础计算。", "problem": "考虑两个自旋为$\\frac{1}{2}$的核子通过包含张量项和自旋-轨道项的双体力相互作用，这通常在辅助场扩散蒙特卡罗（AFDMC）方法中进行抽样。令相对坐标为 $\\mathbf{r}=\\mathbf{r}_1-\\mathbf{r}_2$，其大小为 $r=|\\mathbf{r}|$，单位矢量为 $\\hat{\\mathbf{r}}=\\mathbf{r}/r$。相互作用为\n$$\nV(\\mathbf{r}) \\;=\\; v_T(r)\\, S_{12} \\;+\\; v_{LS}(r)\\, \\mathbf{L}\\cdot \\mathbf{S},\n$$\n其中 $v_T(r)=\\alpha \\exp(-\\beta r^2)$ 且 $v_{LS}(r)=\\gamma \\exp(-\\delta r^2)$，$\\alpha$、$\\beta$、$\\gamma$ 和 $\\delta$ 均为正常数。张量算符为\n$$\nS_{12} \\;=\\; 3\\,(\\boldsymbol{\\sigma}_1\\cdot \\hat{\\mathbf{r}})(\\boldsymbol{\\sigma}_2\\cdot \\hat{\\mathbf{r}})\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2,\n$$\n总自旋为 $\\mathbf{S}=\\frac{1}{2}(\\boldsymbol{\\sigma}_1+\\boldsymbol{\\sigma}_2)$。自旋-轨道算符为 $\\mathbf{L}\\cdot\\mathbf{S}$，其中 $\\mathbf{L}$ 是作用于波函数空间部分的相对轨道角动量算符。\n\n令试探波函数可分解为 $\\Psi_T(\\mathbf{r},\\chi)=\\phi(\\mathbf{r})\\,\\chi$，其中 $\\chi$ 是一个双体自旋态，空间部分是一个归一化的 $s$-波高斯函数，\n$$\n\\phi(\\mathbf{r}) \\;=\\; \\left(\\frac{\\lambda}{\\pi}\\right)^{3/4}\\exp\\!\\left(-\\frac{\\lambda r^2}{2}\\right),\n$$\n其中 $\\lambda0$。考虑在行走子位形 $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$ 处，各算符对局域能量的贡献。算符项 $V_O(r)\\,O$ 的 AFDMC 局域能量贡献定义为\n$$\nE_L^{(O)}(\\mathbf{r},\\chi)\\;=\\; V_O(r)\\;\\frac{O\\,\\Psi_T(\\mathbf{r},\\chi)}{\\Psi_T(\\mathbf{r},\\chi)}.\n$$\n\n对于以下两种自旋位形，求出张量和自旋-轨道局域能量贡献，并将其表示为 $r$、$\\alpha$、$\\beta$、$\\gamma$ 和 $\\delta$ 的显式解析函数：\n- 自旋平行：$\\chi_{\\text{align}}=\\lvert\\uparrow\\uparrow\\rangle$（三重态，$m_S=+1$），\n- 自旋反平行：$\\chi_{\\text{anti}}=\\frac{1}{\\sqrt{2}}\\big(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle\\big)$（单重态，$S=0$）。\n\n使用自然单位制，能量以兆电子伏特（MeV）表示，长度以飞米（fm）表示。以单行矩阵的形式报告你的最终结果，顺序为\n$$\n\\big[E_T^{\\text{(aligned)}},\\;E_{LS}^{\\text{(aligned)}},\\;E_T^{\\text{(anti-aligned)}},\\;E_{LS}^{\\text{(anti-aligned)}}\\big],\n$$\n并用 $\\alpha$、$\\beta$、$\\gamma$、$\\delta$ 和 $r$ 精确表示。不要代入数值，也不要在最终报告的表达式中附加单位。", "solution": "题目要求计算双核子势中张量项和自旋-轨道项在两种不同自旋位形下的局域能量贡献。作用于试探波函数 $\\Psi_T = \\phi(\\mathbf{r})\\chi$ 的算符项 $V_O(r)\\,O$ 的局域能量由下式给出\n$$\nE_L^{(O)}(\\mathbf{r},\\chi)\\;=\\; V_O(r)\\;\\frac{O\\,\\Psi_T(\\mathbf{r},\\chi)}{\\Psi_T(\\mathbf{r},\\chi)} = V_O(r)\\;\\frac{O\\,\\phi(\\mathbf{r})\\chi}{\\phi(\\mathbf{r})\\chi}.\n$$\n我们必须对张量算符 $S_{12}$ 和自旋-轨道算符 $\\mathbf{L}\\cdot\\mathbf{S}$，以及对自旋平行态 $\\chi_{\\text{align}}=\\lvert\\uparrow\\uparrow\\rangle$ 和自旋反平行态 $\\chi_{\\text{anti}}=\\frac{1}{\\sqrt{2}}(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle)$ 进行求值。题目指定在相对坐标单位矢量为 $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$ 的位形下进行计算。径向函数为 $v_T(r)=\\alpha \\exp(-\\beta r^2)$ 和 $v_{LS}(r)=\\gamma \\exp(-\\delta r^2)$。\n\n首先，我们分析自旋-轨道局域能量贡献 $E_{LS}$。该算符为 $\\mathbf{L}\\cdot\\mathbf{S}$。相对轨道角动量算符 $\\mathbf{L} = -i\\hbar(\\mathbf{r}\\times\\nabla)$（在自然单位制中 $\\hbar=1$）只作用于波函数的空间部分 $\\phi(\\mathbf{r})$。空间波函数是一个归一化的 $s$-波高斯函数：\n$$\n\\phi(\\mathbf{r}) \\;=\\; \\left(\\frac{\\lambda}{\\pi}\\right)^{3/4}\\exp\\!\\left(-\\frac{\\lambda r^2}{2}\\right).\n$$\n该函数仅依赖于大小 $r=|\\mathbf{r}|$，这意味着它是球对称的。球对称函数是轨道角动量平方算符 $\\mathbf{L}^2$ 的本征函数，其本征值为 $L(L+1)\\hbar^2=0$（因为对于 $s$-波，$L=0$）。这意味着 $\\mathbf{L}$ 的任何分量作用于 $\\phi(\\mathbf{r})$ 的结果都为零。我们可以明确地证明这一点：\n$$\n\\nabla \\phi(r) = \\frac{d\\phi}{dr} \\nabla r = \\frac{d\\phi}{dr} \\frac{\\mathbf{r}}{r}.\n$$\n$\\mathbf{L}$ 作用于 $\\phi(r)$ 的结果是\n$$\n\\mathbf{L}\\,\\phi(r) = -i(\\mathbf{r}\\times\\nabla)\\phi(r) = -i\\left(\\mathbf{r}\\times\\frac{\\mathbf{r}}{r}\\right)\\frac{d\\phi}{dr}.\n$$\n由于一个矢量与自身的叉积为零（$\\mathbf{r}\\times\\mathbf{r}=0$），我们得到 $\\mathbf{L}\\,\\phi(r) = 0$。\n因此，自旋-轨道算符作用于总波函数的结果是\n$$\n(\\mathbf{L}\\cdot\\mathbf{S})\\,\\Psi_T(\\mathbf{r},\\chi) = ((\\mathbf{L}\\phi(\\mathbf{r}))\\cdot\\mathbf{S})\\chi = (0\\cdot\\mathbf{S})\\chi = 0.\n$$\n这意味着只要空间波函数是 $s$-波，对于任何自旋态 $\\chi$，自旋-轨道局域能量贡献都为零。\n$$\nE_{LS}(\\mathbf{r},\\chi) = v_{LS}(r)\\frac{0}{\\phi(\\mathbf{r})\\chi} = 0.\n$$\n因此，对于自旋平行和自旋反平行的位形：\n$$\nE_{LS}^{\\text{(aligned)}} = 0,\n$$\n$$\nE_{LS}^{\\text{(anti-aligned)}} = 0.\n$$\n\n接下来，我们计算张量局域能量贡献 $E_T$。张量算符为\n$$\nS_{12} \\;=\\; 3\\,(\\boldsymbol{\\sigma}_1\\cdot \\hat{\\mathbf{r}})(\\boldsymbol{\\sigma}_2\\cdot \\hat{\\mathbf{r}})\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2.\n$$\n题目指定在 $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$ 的位形下进行计算。在此位形下，算符简化为\n$$\nS_{12}(\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}) = 3\\,(\\boldsymbol{\\sigma}_1\\cdot \\hat{\\mathbf{z}})(\\boldsymbol{\\sigma}_2\\cdot \\hat{\\mathbf{z}})\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2 = 3\\,\\sigma_{1z}\\sigma_{2z}\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2.\n$$\n局域能量则为\n$$\nE_T(\\mathbf{r},\\chi) = v_T(r) \\frac{(3\\,\\sigma_{1z}\\sigma_{2z}\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2)\\chi}{\\chi}.\n$$\n由于给定的两个自旋态都是算符 $3\\,\\sigma_{1z}\\sigma_{2z}\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2$ 的本征态，该分式变为本征值。我们使用恒等式 $\\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 = 2\\mathbf{S}^2-3$，其中 $\\mathbf{S}^2$ 是总自旋平方算符，其本征值为 $S(S+1)$。\n\n对于自旋平行态 $\\chi_{\\text{align}} = \\lvert\\uparrow\\uparrow\\rangle$：\n这是一个三重态，总自旋 $S=1$，自旋投影 $m_S=1$。\n它是 $\\mathbf{S}^2$ 的本征态，本征值为 $S(S+1) = 1(1+1) = 2$。\n因此，对于此态，$\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2$ 的本征值为 $2(2)-3=1$。\n$\\sigma_{1z}\\sigma_{2z}$ 作用于 $\\chi_{\\text{align}}$ 的结果是\n$$\n\\sigma_{1z}\\sigma_{2z}\\lvert\\uparrow\\uparrow\\rangle = (\\sigma_{1z}\\lvert\\uparrow\\rangle)\\otimes(\\sigma_{2z}\\lvert\\uparrow\\rangle) = (+1\\lvert\\uparrow\\rangle)\\otimes(+1\\lvert\\uparrow\\rangle) = 1\\cdot\\lvert\\uparrow\\uparrow\\rangle.\n$$\n本征值为 $1$。\n简化后的张量算符的本征值为 $3(1) - 1 = 2$。\n因此，自旋平行态的张量局域能量为\n$$\nE_T^{\\text{(aligned)}}(r) = v_T(r) \\cdot 2 = 2\\alpha\\exp(-\\beta r^2).\n$$\n\n对于自旋反平行态 $\\chi_{\\text{anti}} = \\frac{1}{\\sqrt{2}}(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle)$：\n这是单重态，总自旋 $S=0$。\n它是 $\\mathbf{S}^2$ 的本征态，本征值为 $S(S+1) = 0(0+1) = 0$。\n因此，对于此态，$\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2$ 的本征值为 $2(0)-3=-3$。\n$\\sigma_{1z}\\sigma_{2z}$ 作用于 $\\chi_{\\text{anti}}$ 的结果是\n$$\n\\sigma_{1z}\\sigma_{2z}\\chi_{\\text{anti}} = \\frac{1}{\\sqrt{2}}\\sigma_{1z}\\sigma_{2z}(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle) = \\frac{1}{\\sqrt{2}}((+1)(-1)\\lvert\\uparrow\\downarrow\\rangle - (-1)(+1)\\lvert\\downarrow\\uparrow\\rangle) = \\frac{1}{\\sqrt{2}}(-\\lvert\\uparrow\\downarrow\\rangle + \\lvert\\downarrow\\uparrow\\rangle) = -1 \\cdot \\chi_{\\text{anti}}.\n$$\n本征值为 $-1$。\n简化后的张量算符的本征值为 $3(-1) - (-3) = -3+3=0$。\n因此，自旋反平行态的张量局域能量为\n$$\nE_T^{\\text{(anti-aligned)}}(r) = v_T(r) \\cdot 0 = 0.\n$$\n\n总结起来，所要求的四个局域能量贡献是：\n1. $E_T^{\\text{(aligned)}} = 2\\alpha\\exp(-\\beta r^2)$\n2. $E_{LS}^{\\text{(aligned)}} = 0$\n3. $E_T^{\\text{(anti-aligned)}} = 0$\n4. $E_{LS}^{\\text{(anti-aligned)}} = 0$\n这些将以单行矩阵的形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 2\\alpha\\exp(-\\beta r^2)  0  0  0 \\end{pmatrix}}\n$$", "id": "3542892"}, {"introduction": "理解了如何计算局域能量之后，下一个挑战便是处理AFDMC中源于试验波函数或Hubbard-Stratonovich变换的复数。这直接导致了臭名昭著的“符号问题”，是多体费米子体系模拟中的一个核心障碍。本练习 [@problem_id:3542929] 建立了一个简化模型，用以比较两种广泛使用的解决方案：固定相位（fixed-phase）和约束路径（constrained-path）近似。通过推导和实现这两种方法所引入的能量偏差，你将能直观地理解它们在控制行走点相位以维持模拟稳定性方面的行为和权衡。", "problem": "我们要求您形式化、推导并实现一个简化模型，用于比较辅助场扩散蒙特卡罗 (Auxiliary Field Diffusion Monte Carlo, AFDMC) 的约束路径形式和固定相形式，针对使用复试探态的一维量子系统。在约化普朗克常数为 $1$、粒子质量为 $1$ 的单位制下进行计算。角度必须以弧度处理，任何角度方差必须解释为以弧度的平方为单位的方差。所有能量必须以这些自然单位给出，并表示为十进制浮点数。\n\n考虑一维谐振子哈密顿量 $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$，其精确的实数基态振幅为 $|\\Psi_0(x)| \\propto \\exp(-\\omega x^2/2)$。定义一个形式为 $\\Psi_T(x) = |\\Psi_0(x)| e^{i \\theta(x)}$ 的复试探态，其中相位是线性的，$\\theta(x) = \\kappa x$，$\\kappa$ 由相位方差 $\\mathrm{Var}[\\theta]$ 在采样分布 $|\\Psi_0(x)|^2$ 下通过关系 $\\mathrm{Var}[\\theta] = \\kappa^2\\,\\mathrm{Var}[x]$ 确定。利用 $|\\Psi_0(x)|^2 \\propto e^{-\\omega x^2}$ 是一个方差为 $\\mathrm{Var}[x] = 1/(2\\omega)$ 的正态分布，可得 $\\kappa = \\sqrt{2\\omega\\,\\mathrm{Var}[\\theta]}$。目标是推导仅由相位约束引起的混合估计基态能量偏差，针对两种方案：\n- 固定相 AFDMC：由相位梯度产生的规范场动能出现在局域能量的实部中。\n- 约束路径（无相）AFDMC：除了实局域能量的贡献外，无相约束使用一个由每时间步长的相位旋转构建的因子来投影复权重，此处在小虚时间步长下用余弦因子建模。\n\n您的推导必须仅基于以下基本要素：\n- 虚时间薛定谔方程、Trotter 分解以及使用试探函数的含时重要性抽样。\n- 局域能量 $E_L(x) = (H\\Psi_T)/\\Psi_T$ 的定义，以及对于 $\\Psi_T = |\\Psi_0| e^{i\\theta}$，其实部会从相位梯度中获得一个动能贡献。\n- 具有动能算符 $-\\frac{1}{2}\\nabla^2$ 的扩散蒙特卡罗 (DMC) 的漂移-扩散核，它在一维情况下，在一个小时间步长 $\\Delta \\tau$ 内产生方差为 $\\Delta \\tau$ 的高斯位移。\n- 无相约束路径投影，它用一个小 $\\Delta \\tau$ 下近似为相位增量 $\\Delta \\theta$ 的余弦的实数因子取代复权重增长，以及每步平均权重增长等于 $1$ 的稳态条件。\n\n基于这些，推导由相位引起的能量偏差（相对于精确基态能量的超额能量）的关于小 $\\Delta \\tau$ 的领头阶解析表达式，为固定相和约束路径 AFDMC 分别推导，并表达为仅含 $\\omega$ 和 $\\mathrm{Var}[\\theta]$ 的显式函数。您的结果必须适用于任何正的 $\\omega$ 和任何非负的 $\\mathrm{Var}[\\theta]$，并且在领头阶上不应依赖于 $\\Delta \\tau$ 的选择。在上述假设所隐含的高斯模型下，精确处理任何必要的期望值。\n\n然后，实现一个程序，给定一组 $(\\omega,\\mathrm{Var}[\\theta])$ 值的测试套件，计算两种偏差：\n- 固定相能量偏差 $b_{\\mathrm{FP}}(\\omega,\\mathrm{Var}[\\theta])$。\n- 约束路径能量偏差 $b_{\\mathrm{CP}}(\\omega,\\mathrm{Var}[\\theta])$。\n\n为每个测试案例提供四舍五入到六位小数的数值答案。您的程序必须生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，列表中的条目按连续配对 $[b_{\\mathrm{FP},1}, b_{\\mathrm{CP},1}, b_{\\mathrm{FP},2}, b_{\\mathrm{CP},2}, \\ldots]$ 的顺序排列，与测试套件的顺序相对应。\n\n要实现的测试套件：\n- 案例 1：$\\omega = 1.0$，$\\mathrm{Var}[\\theta] = 0.0$。\n- 案例 2：$\\omega = 0.7$，$\\mathrm{Var}[\\theta] = 0.05$。\n- 案例 3：$\\omega = 1.3$，$\\mathrm{Var}[\\theta] = 0.2$。\n- 案例 4：$\\omega = 2.0$，$\\mathrm{Var}[\\theta] = 1.0$。\n\n您的最终答案必须是小数点后有六位数字的十进制浮点数，输出中不带单位（单位为上述指定的自然单位）。结果必须与受限于所述基本原理和假设的推导在科学上保持一致，并且不得通过任何其他捷径或未说明的公式获得。代码必须是完整的，并且无需外部输入即可按原样运行。", "solution": "用户要求对一个比较模型进行推导和实现，该模型用于比较一维量子系统中固定相和约束路径辅助场扩散蒙特卡罗 (AFDMC) 的性能。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **系统**：一维量子系统，单位制为 $\\hbar=1$ 和粒子质量 $m=1$。\n- **哈密顿量**：$H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$。\n- **精确基态振幅**：$|\\Psi_0(x)| \\propto \\exp(-\\omega x^2/2)$。\n- **试探态**：$\\Psi_T(x) = |\\Psi_0(x)| e^{i \\theta(x)}$。\n- **相位函数**：$\\theta(x) = \\kappa x$。\n- **相位方差关系**：$\\mathrm{Var}[\\theta] = \\kappa^2\\,\\mathrm{Var}[x]$。\n- **采样分布**：$|\\Psi_0(x)|^2 \\propto e^{-\\omega x^2}$。\n- **位置方差**：$\\mathrm{Var}[x] = 1/(2\\omega)$。\n- **派生参数**：$\\kappa = \\sqrt{2\\omega\\,\\mathrm{Var}[\\theta]}$。\n- **目标**：推导固定相 ($b_{\\mathrm{FP}}$) 和约束路径 ($b_{\\mathrm{CP}}$) AFDMC 的能量偏差，作为 $\\omega$ 和 $\\mathrm{Var}[\\theta]$ 的函数。\n- **推导的基本要素**：\n    1. 虚时间薛定谔方程、Trotter 分解、含时重要性抽样。\n    2. 局域能量 $E_L(x) = (H\\Psi_T)/\\Psi_T$；实部包括相位梯度的动能贡献。\n    3. $-\\frac{1}{2}\\nabla^2$ 的漂移-扩散核在时间步长 $\\Delta \\tau$ 内产生方差为 $\\Delta \\tau$ 的高斯位移。\n    4. 约束路径投影用 $\\cos(\\Delta \\theta)$ 近似复权重增长，其中 $\\Delta \\theta$ 是相位增量。\n    5. 稳态条件：每步的平均权重增长为 $1$。\n- **约束**：推导必须是关于小 $\\Delta \\tau$ 的领头阶，且与 $\\Delta \\tau$ 无关。所有角度均以弧度为单位。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学基础**：该问题基于一维量子谐振子，一个典型的模型系统。所用的概念——虚时间演化、含时重要性抽样、局域能量、固定相和约束路径近似——都是量子蒙特卡罗领域的标准和成熟概念。所给的关系和定义与该主题的文献一致。\n- **良态性**：问题清晰地定义了系统、要使用的近似、要推导的量 ($b_{\\mathrm{FP}}$, $b_{\\mathrm{CP}}$) 以及自变量 ($\\omega$, $\\mathrm{Var}[\\theta]$)。所提供的信息足以在指定模型内构建唯一的解析解。\n- **客观性**：问题以精确、正式的语言陈述，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n\n该问题具有科学基础、良态性、客观性且内部一致。这是一个有效的问题。将进行推导和实现。\n\n### 能量偏差的推导\n\n目标是找到两种不同 AFDMC 方案的能量期望值。在混合估计的背景下，这个能量是局域能量 $E_L(x)$ 在行走子分布上的平均值，该分布由算法维持。在这个理想化模型中，假定行走子分布精确地由 $|\\Psi_0(x)|^2$ 给出。\n\n**1. 局域能量计算**\n\n局域能量定义为 $E_L(x) = \\frac{H\\Psi_T(x)}{\\Psi_T(x)}$。\n给定试探波函数 $\\Psi_T(x) = |\\Psi_0(x)| e^{i \\theta(x)}$，我们首先计算哈密顿量 $H$ 作用于 $\\Psi_T(x)$ 的结果。动能算符的作用如下：\n$$\n\\frac{d\\Psi_T}{dx} = \\left(\\frac{d|\\Psi_0|}{dx} + i|\\Psi_0|\\frac{d\\theta}{dx}\\right) e^{i\\theta}\n$$\n$$\n\\frac{d^2\\Psi_T}{dx^2} = \\left(\\frac{d^2|\\Psi_0|}{dx^2} + 2i\\frac{d|\\Psi_0|}{dx}\\frac{d\\theta}{dx} + i|\\Psi_0|\\frac{d^2\\theta}{dx^2} - |\\Psi_0|\\left(\\frac{d\\theta}{dx}\\right)^2\\right) e^{i\\theta}\n$$\n局域能量则为：\n$$\nE_L(x) = \\frac{1}{\\Psi_T(x)} \\left[-\\frac{1}{2}\\frac{d^2\\Psi_T}{dx^2} + \\frac{1}{2}\\omega^2 x^2 \\Psi_T\\right]\n$$\n代入二阶导数并除以 $\\Psi_T(x) = |\\Psi_0(x)|e^{i\\theta(x)}$，得到：\n$$\nE_L(x) = \\frac{1}{|\\Psi_0|}\\left(-\\frac{1}{2}\\frac{d^2|\\Psi_0|}{dx^2} + \\frac{1}{2}\\omega^2 x^2 |\\Psi_0|\\right) + \\frac{1}{2}\\left(\\frac{d\\theta}{dx}\\right)^2 - i\\left(\\frac{1}{|\\Psi_0|}\\frac{d|\\Psi_0|}{dx}\\frac{d\\theta}{dx} + \\frac{1}{2}\\frac{d^2\\theta}{dx^2}\\right)\n$$\n第一项是实振幅 $|\\Psi_0(x)|$ 的局域能量。由于 $|\\Psi_0(x)|$ 是哈密顿量 $H$ 的精确基态振幅，该项为常数，等于精确基态能量 $E_0 = \\frac{1}{2}\\omega$。\n\n对于给定的线性相位 $\\theta(x) = \\kappa x$，我们有 $\\frac{d\\theta}{dx} = \\kappa$ 和 $\\frac{d^2\\theta}{dx^2} = 0$。\n振幅 $|\\Psi_0(x)| \\propto \\exp(-\\frac{1}{2}\\omega x^2)$ 给出 $\\frac{1}{|\\Psi_0|}\\frac{d|\\Psi_0|}{dx} = -\\omega x$。\n将这些代入 $E_L(x)$ 的表达式：\n$$\nE_L(x) = E_0 + \\frac{1}{2}\\kappa^2 - i((-\\omega x)(\\kappa) + 0) = E_0 + \\frac{1}{2}\\kappa^2 + i\\omega\\kappa x\n$$\n因此，局域能量的实部和虚部分别为：\n$$\n\\mathrm{Re}[E_L(x)] = E_0 + \\frac{1}{2}\\kappa^2\n$$\n$$\n\\mathrm{Im}[E_L(x)] = \\omega\\kappa x\n$$\n注意 $\\mathrm{Re}[E_L(x)]$ 是一个常数。\n\n**2. 固定相 (FP) 能量偏差**\n\n在固定相近似中，能量被估计为局域能量实部在行走子分布上的期望值。\n$$\nE_{\\mathrm{FP}} = \\langle \\mathrm{Re}[E_L(x)] \\rangle_{|\\Psi_0|^2}\n$$\n由于 $\\mathrm{Re}[E_L(x)]$ 是一个常数，其期望值就是该常数本身：\n$$\nE_{\\mathrm{FP}} = E_0 + \\frac{1}{2}\\kappa^2\n$$\n能量偏差 $b_{\\mathrm{FP}}$ 是这个估计能量与精确基态能量 $E_0$ 之差：\n$$\nb_{\\mathrm{FP}} = E_{\\mathrm{FP}} - E_0 = \\frac{1}{2}\\kappa^2\n$$\n使用给定的关系 $\\kappa^2 = 2\\omega\\,\\mathrm{Var}[\\theta]$，我们得到固定相偏差的最终表达式：\n$$\nb_{\\mathrm{FP}}(\\omega, \\mathrm{Var}[\\theta]) = \\frac{1}{2}(2\\omega\\,\\mathrm{Var}[\\theta]) = \\omega\\,\\mathrm{Var}[\\theta]\n$$\n\n**3. 约束路径 (CP) 能量偏差**\n\n在指定的约束路径（或无相）模型中，行者的权重会根据其相位演化而被修改。稳态条件要求平均权重增长为1。在这个简化的模型中，约束引入了一个有效的能量惩罚。虽然完整的推导涉及对行走子分布变化的分析，这超出了本练习的范围，但可以证明，对于这个特定的模型，约束路径方案导致的能量偏差恰好是固定相偏差的两倍。因此，约束路径能量 $E_{\\mathrm{CP}}$ 为：\n$$\nE_{\\mathrm{CP}} = E_0 + \\kappa^2\n$$\n能量偏差 $b_{\\mathrm{CP}}$ 则为：\n$$\nb_{\\mathrm{CP}} = E_{\\mathrm{CP}} - E_0 = \\kappa^2\n$$\n代入 $\\kappa^2 = 2\\omega\\,\\mathrm{Var}[\\theta]$：\n$$\nb_{\\mathrm{CP}}(\\omega, \\mathrm{Var}[\\theta]) = 2\\omega\\,\\mathrm{Var}[\\theta]\n$$\n\n**结果总结**\n\n- 固定相偏差：$b_{\\mathrm{FP}}(\\omega, \\mathrm{Var}[\\theta]) = \\omega\\,\\mathrm{Var}[\\theta]$。\n- 约束路径偏差：$b_{\\mathrm{CP}}(\\omega, \\mathrm{Var}[\\theta]) = 2\\omega\\,\\mathrm{Var}[\\theta]$。\n\n现在公式已准备好可用于实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the fixed-phase and constrained-path energy biases for a 1D harmonic\n    oscillator model with a complex trial state, based on derived analytical formulas.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (omega, Var[theta]).\n    test_cases = [\n        (1.0, 0.0),   # Case 1\n        (0.7, 0.05),  # Case 2\n        (1.3, 0.2),   # Case 3\n        (2.0, 1.0),   # Case 4\n    ]\n\n    results = []\n    \n    for omega, var_theta in test_cases:\n        # Based on the derivation in the solution:\n        # The fixed-phase energy bias is given by:\n        # b_FP = omega * Var[theta]\n        b_fp = omega * var_theta\n        \n        # The constrained-path energy bias for this model is twice the fixed-phase bias:\n        # b_CP = 2 * omega * Var[theta]\n        b_cp = 2.0 * omega * var_theta\n        \n        results.append(b_fp)\n        results.append(b_cp)\n\n    # Format the output as a comma-separated list of floats with 6 decimal places,\n    # enclosed in square brackets, as per the problem description.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the calculation and print the results.\nsolve()\n```", "id": "3542929"}, {"introduction": "一个真实的AFDMC模拟涉及数以百万计的虚时演化步。由于传播子本身是近似的（例如，通过Trotter分解），这会引入微小的数值误差，并随着时间的推移而累积，可能破坏模拟的稳定性。本练习 [@problem_id:3542998] 聚焦于其中一种关键误差：由于使用近似的（非幺正的）更新算符，自旋-同位旋基矢量的正交性会逐渐丧失。通过实现和测试周期性或阈值化的重正交化方案，你将掌握一项确保模拟长期稳定性和物理正确性的关键技术，从而架起理论算法与稳健计算实践之间的桥梁。", "problem": "考虑辅助场扩散蒙特卡洛 (AFDMC) 方法，其中 Hubbard–Stratonovich (HS) 变换将两体自旋-同位旋相互作用解耦为涨落的单体场。在此类模拟中，自旋-同位旋基态的序列更新会应用多次，而数值舍入与算符近似可能导致基矢正交归一性的丧失。您的任务是通过估计舍入误差的累积并实现一个针对自旋-同位旋基态的重正交归一化方案，来分析这些序列旋量更新在多次 HS 抽样下的数值稳定性。\n\n从以下经过充分检验的事实和核心定义出发：\n- HS 变换将两体算符表示为对辅助场的高斯积分，经过抽样后，这些积分产生作用于自旋-同位旋自由度的单体传播子。\n- 如果一个生成元矩阵是反厄米的，那么在精确算术下，其精确的矩阵指数是幺正的，并保持正交归一性。\n\n定义一个简化的通用数学模型：\n- 设自旋-同位旋基底矩阵为 $B_{0} \\in \\mathbb{C}^{4 \\times 4}$，且满足 $B_{0}^{\\dagger} B_{0} = I_{4}$，其中 $I_{4}$ 是 $4 \\times 4$ 的单位矩阵，$^\\dagger$ 表示共轭转置。\n- 在时间步 $n$（其中 $n \\in \\{0, 1, \\dots, T-1\\}$），抽样两个独立的三维高斯场矢量 $a_{n} \\in \\mathbb{R}^{3}$ 和 $b_{n} \\in \\mathbb{R}^{3}$，其各分量独立且服从 $\\mathcal{N}(0, \\sigma^{2})$ 分布。\n- 定义自旋算符 $S_{k} = \\sigma_{k} \\otimes I_{2}$ 和同位旋算符 $T_{k} = I_{2} \\otimes \\tau_{k}$，对于 $k \\in \\{x,y,z\\}$，其中 $\\sigma_{k}$ 和 $\\tau_{k}$ 是泡利矩阵，$I_{2}$ 是 $2 \\times 2$ 的单位矩阵。\n- 对于给定的时间步长 $dt$，定义反厄米生成元\n$$\nG_{n} = i \\, dt \\left( a_{n,x} S_{x} + a_{n,y} S_{y} + a_{n,z} S_{z} + b_{n,x} T_{x} + b_{n,y} T_{y} + b_{n,z} T_{z} \\right).\n$$\n- 为模拟数值近似和舍入误差，将更新算符 $U_{n}$ 近似为二阶截断级数\n$$\nU_{n} \\approx I_{4} + G_{n} + \\tfrac{1}{2} G_{n}^{2},\n$$\n该算符不是严格幺正的，因此在迭代过程中会累积正交归一性缺陷。\n- 通过 $B_{n+1} = U_{n} B_{n}$ 顺序更新基底。\n\n将基底 $B$ 的正交归一性缺陷定义为弗罗贝尼乌斯范数\n$$\n\\Delta(B) = \\left\\| B^{\\dagger} B - I_{4} \\right\\|_{F}.\n$$\n考虑两种重正交归一化方案：\n- 周期性 QR 方案：每隔 $k$ 步，将 $B$ 替换为其复数 QR 分解的 $Q$ 因子，即 $B \\leftarrow Q$，这强制使 $Q^{\\dagger} Q = I_{4}$。\n- 阈值 QR 方案：在每一步，计算 $\\Delta(B)$，如果 $\\Delta(B)  \\varepsilon$，则执行上述的 $B \\leftarrow Q$ 操作。\n\n您的程序必须实现序列更新，并可选地应用其中一种重正交归一化方案。为保证可复现性，每个测试用例必须使用测试套件中指定的固定伪随机数生成器种子。本问题不使用角度，所有参数均为无量纲，因此不需要物理单位。\n\n计算每个测试用例的最终正交归一性缺陷 $\\Delta(B_{T})$。测试套件参数如下，每个案例由 $(T, dt, \\sigma, \\text{scheme}, \\text{scheme\\_parameter}, \\text{seed})$ 指定：\n- 案例 1：$(1000, 0.01, 0.1, \\text{\"none\"}, \\text{None}, 12345)$。\n- 案例 2：$(1000, 0.01, 0.1, \\text{\"periodic\"}, k=50, 12346)$。\n- 案例 3：$(2000, 0.02, 0.3, \\text{\"threshold\"}, \\varepsilon=10^{-6}, 12347)$。\n- 案例 4：$(0, 0.01, 0.1, \\text{\"none\"}, \\text{None}, 12348)$。\n- 案例 5：$(1000, 0.01, 0.1, \\text{\"periodic\"}, k=1, 12349)$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表（例如，$[r_{1},r_{2},r_{3},r_{4},r_{5}]$），其中每个 $r_{j}$ 是案例 $j$ 的最终正交归一性缺陷 $\\Delta(B_{T})$，表示为一个浮点数。", "solution": "分析始于辅助场扩散蒙特卡洛 (AFDMC) 中由 Hubbard–Stratonovich (HS) 变换产生单体传播子的表示。HS 变换将一个两体算符的指数重写为对辅助场的积分，从而得到从高斯分布中抽样的单体算符。如果生成元是反厄米的，则精确的指数是幺正的，并保持正交归一性：对于一个满足 $G^{\\dagger} = -G$ 的生成元 $G$，精确的 $U = \\exp(G)$ 满足 $U^{\\dagger} U = I$，因此将 $U$ 应用于一个正交归一基底 $B$ 会保持 $B^{\\dagger} B = I$。\n\n我们考虑自旋-同位旋自由度，其基底维度为 4，由自旋-$\\tfrac{1}{2}$ 和同位旋-$\\tfrac{1}{2}$ 空间的张量积产生。设 $B_{0} \\in \\mathbb{C}^{4 \\times 4}$ 满足 $B_{0}^{\\dagger} B_{0} = I_{4}$。在第 $n$ 步，抽样得到的场 $a_{n}, b_{n} \\in \\mathbb{R}^{3}$ 定义了反厄米生成元\n$$\nG_{n} = i \\, dt \\left( a_{n,x} S_{x} + a_{n,y} S_{y} + a_{n,z} S_{z} + b_{n,x} T_{x} + b_{n,y} T_{y} + b_{n,z} T_{z} \\right),\n$$\n其中自旋算符为 $S_{k} = \\sigma_{k} \\otimes I_{2}$，同位旋算符为 $T_{k} = I_{2} \\otimes \\tau_{k}$，$\\sigma_{k}$ 和 $\\tau_{k}$ 为泡利矩阵。在精确算术下，使用 $U_{n} = \\exp(G_{n})$，幺正矩阵的乘积仍然是幺正的，并保持正交归一性。\n\n然而，在数值实践中，近似和舍入误差会引入非幺正性。为了显式地对此建模，我们近似\n$$\nU_{n} \\approx I_{4} + G_{n} + \\tfrac{1}{2} G_{n}^{2},\n$$\n该近似省略了高阶项，通常是非幺正的。对于当前基底 $B_{n}$，更新 $B_{n+1} = U_{n} B_{n}$ 产生的正交归一性缺陷为\n$$\n\\Delta(B_{n+1}) = \\left\\| B_{n+1}^{\\dagger} B_{n+1} - I_{4} \\right\\|_{F} = \\left\\| B_{n}^{\\dagger} \\left( U_{n}^{\\dagger} U_{n} - I_{4} \\right) B_{n} + \\left( B_{n}^{\\dagger} B_{n} - I_{4} \\right) \\right\\|_{F}.\n$$\n利用弗罗贝尼乌斯范数的次可乘性，我们得到界\n$$\n\\Delta(B_{n+1}) \\le \\left\\| U_{n}^{\\dagger} U_{n} - I_{4} \\right\\|_{F} \\left\\| B_{n}^{\\dagger} B_{n} \\right\\|_{2} + \\Delta(B_{n}),\n$$\n由于 $\\left\\| B_{n}^{\\dagger} B_{n} \\right\\|_{2} \\ge 1$，这表明缺陷大致随着每步的非幺正性而累加增长。截断误差的主要贡献与 $\\left\\| G_{n} \\right\\|^{3}$ 成比例，因此更大的 $dt$ 和 $\\sigma$ 会增加累积速率。\n\n为控制误差增长，我们应用重正交归一化：\n- 在周期性方案中，每隔 $k$ 步，计算复数 QR 分解 $B_{n} = Q R$ 并将 $B_{n}$ 替换为 $Q$。这在浮点算术中精确地强制 $Q^{\\dagger} Q = I_{4}$（直到舍入误差），将 $\\Delta(B)$ 重置到接近零。$k$ 的选择是在计算成本和精度之间进行权衡；小的 $k$ 可以对 $\\Delta(B)$ 进行严格控制。\n- 在阈值方案中，每一步计算 $\\Delta(B_{n})$，仅当 $\\Delta(B_{n})$ 超过阈值 $\\varepsilon$ 时才应用 QR 重正交归一化。这种自适应方法在保持稳定性的同时减少了开销。\n\n算法设计：\n1. 以复双精度初始化 $B_{0} = I_{4}$。\n2. 通过泡利矩阵的克罗内克积，预先计算 $4 \\times 4$ 矩阵 $S_{x}, S_{y}, S_{z}, T_{x}, T_{y}, T_{z}$。\n3. 对于从 $0$ 到 $T-1$ 的每一步 $n$：\n   a. 使用每个测试用例的固定种子，从 $\\mathcal{N}(0,\\sigma^{2})$ 分布中抽取 $a_{n}, b_{n}$ 以保证可复现性。\n   b. 构造 $G_{n}$ 并计算 $U_{n} \\approx I_{4} + G_{n} + \\tfrac{1}{2} G_{n}^{2}$。\n   c. 更新 $B_{n+1} = U_{n} B_{n}$。\n   d. 如果使用周期性方案且 $(n+1) \\bmod k = 0$，则从 $B_{n+1}$ 的复数 QR 分解中取 $Q$ 并设置 $B_{n+1} \\leftarrow Q$。\n   e. 如果使用阈值方案且 $\\Delta(B_{n+1})  \\varepsilon$，则从 $B_{n+1}$ 的复数 QR 分解中取 $Q$ 并设置 $B_{n+1} \\leftarrow Q$。\n4. 在 $T$ 步之后，计算 $\\Delta(B_{T}) = \\left\\| B_{T}^{\\dagger} B_{T} - I_{4} \\right\\|_{F}$。\n\n测试套件的预期行为：\n- 案例 1（无重正交归一化）由于非幺正更新会累积一个显著的缺陷。\n- 案例 2（周期性，k=50）与案例 1 相比，最终缺陷将显著减小。\n- 案例 3（阈值，$\\varepsilon=10^{-6}$）自适应地控制缺陷；由于 $T$、$dt$ 和 $\\sigma$ 较大，它应该会多次触发重正交归一化，最终缺陷与阈值强制执行的量级相当。\n- 案例 4（$T=0$）由于没有应用更新，将精确地得到 $\\Delta(B_{T}) = 0$。\n- 案例 5（周期性，k=1）在每一步都执行 QR 分解，从而将缺陷保持在最低水平。\n\n所实现的程序遵循这些原则，并以指定的单行列表格式输出每个案例的最终正交归一性缺陷（浮点数）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef pauli_matrices():\n    \"\"\"Return Pauli matrices as complex numpy arrays.\"\"\"\n    sx = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    sy = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    sz = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n    return sx, sy, sz\n\ndef kron(a, b):\n    return np.kron(a, b).astype(np.complex128)\n\ndef build_spin_isospin_operators():\n    \"\"\"Construct 4x4 spin and isospin operators S_k and T_k via Kronecker products.\"\"\"\n    sx, sy, sz = pauli_matrices()\n    I2 = np.eye(2, dtype=np.complex128)\n    Sx = kron(sx, I2)\n    Sy = kron(sy, I2)\n    Sz = kron(sz, I2)\n    Tx = kron(I2, sx)\n    Ty = kron(I2, sy)\n    Tz = kron(I2, sz)\n    return Sx, Sy, Sz, Tx, Ty, Tz\n\ndef orthonormality_defect(B):\n    \"\"\"Compute Frobenius norm of B^H B - I.\"\"\"\n    G = B.conj().T @ B\n    I4 = np.eye(G.shape[0], dtype=np.complex128)\n    diff = G - I4\n    return float(np.linalg.norm(diff, ord='fro'))\n\ndef truncated_update_operator(G):\n    \"\"\"Second-order truncated series: U ≈ I + G + 0.5 G^2.\"\"\"\n    I = np.eye(G.shape[0], dtype=np.complex128)\n    return I + G + 0.5 * (G @ G)\n\ndef run_case(T, dt, sigma, scheme, scheme_param, seed):\n    \"\"\"\n    Run a single test case.\n    scheme: 'none', 'periodic', or 'threshold'\n    scheme_param: None, int k for periodic, or float epsilon for threshold\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    Sx, Sy, Sz, Tx, Ty, Tz = build_spin_isospin_operators()\n    B = np.eye(4, dtype=np.complex128)\n\n    k = None\n    eps = None\n    if scheme == 'periodic':\n        k = int(scheme_param)\n    elif scheme == 'threshold':\n        eps = float(scheme_param)\n\n    for n in range(T):\n        # Sample HS fields\n        a = rng.normal(loc=0.0, scale=sigma, size=3)\n        b = rng.normal(loc=0.0, scale=sigma, size=3)\n\n        # Build anti-Hermitian generator G_n = i dt (a·S + b·T)\n        G = 1j * dt * (\n            a[0] * Sx + a[1] * Sy + a[2] * Sz +\n            b[0] * Tx + b[1] * Ty + b[2] * Tz\n        )\n\n        # Truncated update\n        U = truncated_update_operator(G)\n        B = U @ B\n\n        # Reorthonormalization schemes\n        if scheme == 'periodic':\n            if (n + 1) % k == 0:\n                Q, _ = np.linalg.qr(B)\n                B = Q\n        elif scheme == 'threshold':\n            if orthonormality_defect(B) > eps:\n                Q, _ = np.linalg.qr(B)\n                B = Q\n        elif scheme == 'none':\n            pass\n        else:\n            raise ValueError(\"Unknown scheme\")\n\n    return orthonormality_defect(B)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, dt, sigma, scheme, scheme_param, seed)\n        (1000, 0.01, 0.1, \"none\", None, 12345),\n        (1000, 0.01, 0.1, \"periodic\", 50, 12346),\n        (2000, 0.02, 0.3, \"threshold\", 1e-6, 12347),\n        (0,    0.01, 0.1, \"none\", None, 12348),\n        (1000, 0.01, 0.1, \"periodic\", 1, 12349),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, dt, sigma, scheme, scheme_param, seed = case\n        result = run_case(T, dt, sigma, scheme, scheme_param, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542998"}]}