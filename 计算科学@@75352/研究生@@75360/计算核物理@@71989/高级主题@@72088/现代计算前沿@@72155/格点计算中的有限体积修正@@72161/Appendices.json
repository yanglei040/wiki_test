{"hands_on_practices": [{"introduction": "有限体积修正源于不同的物理相互作用，因此具有不同的数学形式。本练习旨在培养一项关键技能：分离来自无质量粒子（如光子）的长程幂律修正，以及来自有质量粒子（如$\\pi$介子）的短程指数修正。这是理解有限体积效应构成的基础性练习 [@problem_id:3559421]。", "problem": "考虑一个非相对论性的双核子束缚态（氘核），置于边长为 $L$、具有周期性边界条件的有限立方空间体积中。通过有限体积中的非相对论性量子电动力学（NRQED$_L$）来包含长程电磁相互作用。NRQED$_L$ 定义为移除了光子场的空间零模以避免红外发散的非相对论性量子电动力学（NRQED）。强相互作用尾部由一个受π介子质量控制的汤川势（Yukawa potential）建模。任务是使用物理上合理的近似和对收敛级数与积分的数值评估，定量地分离和比较按 $1/L$ 标度变化的有限体积效应（源于电磁库仑尾）与按 $\\mathrm{e}^{-m_\\pi L}$ 标度变化的指数抑制效应（源于强相互作用尾）。\n\n将使用的基本依据和定义：\n- 在无限体积中，非相对论性氘核的结合能为 $B_0$（单位：$\\mathrm{MeV}$）。质子-中子系统的约化质量为 $\\mu = \\dfrac{m_p m_n}{m_p + m_n}$（单位：$\\mathrm{MeV}$），其中 $m_p$ 是质子质量，$m_n$ 是中子质量。渐近结合动量为 $\\,\\gamma = \\dfrac{\\sqrt{2 \\mu B_0}}{\\hbar c}\\,$（单位：$\\mathrm{fm}^{-1}$），其中 $\\hbar c$ 是约化普朗克常数与光速的乘积，表示为 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$。\n- 强相互作用的长程尾部由一个π介子质量为 $m_\\pi$（单位：$\\mathrm{MeV}$）的汤川势建模，其在坐标空间中的形式为 $\\,V_Y(r) = - C_Y \\,\\dfrac{\\hbar c}{4\\pi}\\,\\dfrac{\\mathrm{e}^{-\\mu_\\pi r}}{r}\\,$（单位：$\\mathrm{MeV}$），其中 $\\,\\mu_\\pi = \\dfrac{m_\\pi}{\\hbar c}\\,$（单位：$\\mathrm{fm}^{-1}$），$\\,C_Y\\,$ 是一个无量纲的耦合常数，$\\,r\\,$ 的单位是 $\\mathrm{fm}$。\n- 三维电磁库仑核是格林函数 $\\,G_C(\\mathbf{r}) = \\dfrac{1}{4\\pi r}\\,$，其在周期性边界条件下并移除零模后的有限体积修正是可以通过 Ewald 分裂方法处理。设 $\\,\\eta > 0\\,$ 为分裂参数。为正格子引入整数三元组 $\\,\\mathbf{n} = (n_x,n_y,n_z)\\,$，为倒格子引入 $\\,\\mathbf{m} = (m_x,m_y,m_z)\\,$，其中 $\\,r_{\\mathbf{n}} = \\|\\mathbf{n}\\|\\,$ 且 $\\,m_{\\mathbf{m}} = \\|\\mathbf{m}\\|\\,$。无量纲的 Ewald 求和常数\n$$\nc(\\eta) \\equiv \\sum_{\\mathbf{n}\\neq \\mathbf{0}} \\frac{\\operatorname{erfc}\\!\\left(\\sqrt{\\eta}\\, r_{\\mathbf{n}}\\right)}{r_{\\mathbf{n}}}\n\\;+\\;\n\\frac{1}{\\pi}\\sum_{\\mathbf{m}\\neq \\mathbf{0}} \\frac{\\exp\\!\\left(-\\frac{\\pi^2\\, m_{\\mathbf{m}}^2}{\\eta}\\right)}{m_{\\mathbf{m}}^2}\n\\;-\\;\n\\frac{2\\sqrt{\\eta}}{\\sqrt{\\pi}}\n$$\n当求和至收敛时，该常数与 $L$ 无关，并决定了 NRQED$_L$ 中点状带电粒子主要的 $1/L$ 有限体积能量移动。\n\n您必须推导并实现以下步骤和物理量：\n\n1. 氘核的电磁 $1/L$ 库仑尾能量移动：\n   - 将氘核视为一个净电荷为 $q=+1$ 的带电态。在 NRQED$_L$ 中，一个局域带电态的主要电磁有限体积能量移动由 Ewald 求和常数 $c(\\eta)$ 控制，并按 $1/L$ 标度变化。根据 $c(\\eta)$ 的定义，算法上展示如何通过截断格点求和（以保持计算可行性同时确保收敛）来数值计算这个无量纲常数，然后计算\n   $$\n   \\Delta E_{\\mathrm{EM}}(L) = \\frac{q^2\\,\\alpha\\,\\hbar c}{2\\,L}\\; c(\\eta)\n   $$\n   （单位：$\\mathrm{MeV}$），其中 $\\alpha$ 是精细结构常数。您不得假设或使用任何预先制表的 $c(\\eta)$ 值；相反，必须通过上述定义从第一性原理计算它。\n\n2. 使用镜像法和渐近束缚态波函数计算强相互作用的 $\\mathrm{e}^{-m_\\pi L}$ 尾部：\n   - 使用归一化的 s 波渐近氘核波函数 $\\,\\psi(r) = \\sqrt{\\dfrac{\\gamma}{2\\pi}}\\,\\dfrac{\\mathrm{e}^{-\\gamma r}}{r}\\,$ 来近似长距离处的概率密度。主要的强相互作用有限体积能量移动可以通过周期性镜像（位于位置 $\\,\\mathbf{R}_{\\mathbf{n}} = L\\,\\mathbf{n}\\,$, $\\,\\mathbf{n}\\neq \\mathbf{0}$）产生的汤川尾部的期望值来估计。对于给定距离 $R = \\|\\mathbf{R}_{\\mathbf{n}}\\|$ 的一个壳层，使用球面角平均恒等式\n   $$\n   \\left\\langle \\frac{\\mathrm{e}^{-\\mu_\\pi |\\mathbf{r}-\\mathbf{R}|}}{|\\mathbf{r}-\\mathbf{R}|} \\right\\rangle_{\\Omega} \\;=\\; \\frac{\\sinh\\!\\left(\\mu_\\pi\\, r_\\right)}{\\mu_\\pi\\, r_}\\;\\frac{\\mathrm{e}^{-\\mu_\\pi\\, r_>}}{r_>}\n   \\quad\\text{with}\\quad\n   r_ = \\min(r,R),\\; r_> = \\max(r,R),\n   $$\n   推导出来自一个镜像的能量移动中所包含的径向积分：\n   $$\n   I_1(R) = \\frac{\\mathrm{e}^{-\\mu_\\pi R}}{R} \\int_0^R \\! 2\\gamma\\, \\mathrm{e}^{-2\\gamma r}\\, \\frac{\\sinh(\\mu_\\pi r)}{\\mu_\\pi r}\\, \\mathrm{d}r,\n   \\qquad\n   I_2(R) = \\frac{\\sinh(\\mu_\\pi R)}{\\mu_\\pi R} \\int_R^\\infty \\! 2\\gamma\\, \\frac{\\mathrm{e}^{-(2\\gamma+\\mu_\\pi) r}}{r}\\, \\mathrm{d}r.\n   $$\n   解释如何使用标准求积法数值计算 $I_1(R)$，并证明 $I_2(R)$ 可以通过变量代换 $\\,t = (2\\gamma + \\mu_\\pi)\\,r\\,$ 使用指数积分 $\\,E_1(x) = \\int_x^\\infty \\dfrac{\\mathrm{e}^{-t}}{t}\\,\\mathrm{d}t\\,$ 以闭合形式求值。然后计算强相互作用镜像和\n   $$\n   \\Delta E_{\\mathrm{strong}}(L) \\;=\\; -\\,C_Y\\,(\\hbar c)\\,\\sum_{\\mathbf{n}\\neq \\mathbf{0}} \\left[ I_1\\!\\left(L\\|\\mathbf{n}\\|\\right) + I_2\\!\\left(L\\|\\mathbf{n}\\|\\right) \\right]\n   $$\n   （单位：$\\mathrm{MeV}$）。将镜像和截断到一个小的壳层立方体 $\\,\\|\\mathbf{n}\\|\\le N_{\\mathrm{img}}\\,$，并论证指数抑制效应证明了此截断的合理性。\n\n3. 由相同的长程库仑核控制的磁特性系数：\n   - 许多在领头阶由长程库仑核决定的 NRQED$_L$ 算子重整化共享相同的普适 $1/L$ 系数 $\\,c(\\eta)\\,$。定义无量纲量\n   $$\n   S_{\\mathrm{mag}}(L;\\eta) \\equiv c(\\eta),\n   $$\n   该量由相同的 Ewald 和计算得出，用以表示在磁算子重整化（例如泡利项）中将乘以 $\\,\\alpha / L\\,$ 的领头有限体积系数。数值上证明，一旦求和收敛，$\\,S_{\\mathrm{mag}}\\,$ 就与 $\\,L\\,$ 无关。\n\n科学和数值要求：\n- 仅使用上述基本依据和定义。不要使用任何未经从求和或积分推导而直接给出最终有限体积系数的快捷公式。\n- 物理和数值单位必须一致：能量移动以 $\\mathrm{MeV}$ 报告，长度以 $\\mathrm{fm}$ 报告。不使用角度。无量纲量（如 $\\,S_{\\mathrm{mag}}\\,$）不需要单位。\n- 提供一个包含四个具有不同 $L$ 值的测试用例的测试套件，以探索 $1/L$ 电磁尾部占主导地位以及 $\\mathrm{e}^{-m_\\pi L}$ 强相互作用尾部可见的区域。除非在特定案例中指明，否则所有测试均使用以下参数：\n  - $\\,\\alpha = 1/137.035999084\\,$,\n  - $\\,\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}\\,$,\n  - $\\,q = +1\\,$,\n  - $\\,m_p = 938.2720813\\,\\mathrm{MeV}\\,$,\n  - $\\,m_n = 939.5654133\\,\\mathrm{MeV}\\,$,\n  - $\\,B_0 = 2.224575\\,\\mathrm{MeV}\\,$,\n  - $\\,m_\\pi = 138.0\\,\\mathrm{MeV}\\,$,\n  - $\\,C_Y = 0.30\\,$,\n  - Ewald 参数 $\\,\\eta = 2.0\\,$,\n  - 库仑 Ewald 截断 $\\,N_{\\mathrm{Ewald}} = 6\\,$（包括所有整数格点向量 $\\,\\mathbf{n}\\,$ 和 $\\,\\mathbf{m}\\,$，其分量在 $[-6,6]$ 内，不包括原点），\n  - 强相互作用镜像截断 $\\,N_{\\mathrm{img}} = 2\\,$.\n- 四个测试用例：\n  1. $\\,L = 8.0\\,\\mathrm{fm}\\,$,\n  2. $\\,L = 12.0\\,\\mathrm{fm}\\,$,\n  3. $\\,L = 20.0\\,\\mathrm{fm}\\,$,\n  4. $\\,L = 40.0\\,\\mathrm{fm}\\,$.\n- 对于每个测试用例，计算并返回一个列表 $[\\Delta E_{\\mathrm{EM}}(L), \\Delta E_{\\mathrm{strong}}(L), S_{\\mathrm{mag}}(L;\\eta)]$，其中前两个条目是单位为 $\\mathrm{MeV}$ 的浮点数，最后一个条目是无量纲的浮点数。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由方括号括起来的、以逗号分隔的列表的列表（例如：\"[[...],[...],[...],[...]]\"）。\n\n您的推导应从所述的基本依据开始，解释每个项为何如此标度变化，并描述您为在给定截断下可靠且高效地评估求和与积分而实现的数值算法。", "solution": "用户提供了一个在计算核物理领域中定义明确的问题。该问题具有科学依据，需要应用计算有限体积修正的标准方法，并且所有必要的参数和定义都已提供。此问题被声明为 **有效**。\n\n解决方案按规定分三个阶段进行：\n1.  计算按 $1/L$ 标度变化的主要电磁有限体积能量移动 $\\Delta E_{\\mathrm{EM}}(L)$。\n2.  计算按 $\\mathrm{e}^{-m_\\pi L}$ 标度指数抑制的主要强相互作用有限体积能量移动 $\\Delta E_{\\mathrm{strong}}(L)$。\n3.  计算与 Ewald 常数 $c(\\eta)$ 相同的普适系数 $S_{\\mathrm{mag}}$。\n\n首先，我们根据给定的值定义并计算几个关键的物理参数：\n- 精细结构常数：$\\alpha = 1/137.035999084$\n- 约化普朗克常数-光速乘积：$\\hbar c = 197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}$\n- 质子质量：$m_p = 938.2720813\\,\\mathrm{MeV}$\n- 中子质量：$m_n = 939.5654133\\,\\mathrm{MeV}$\n- 氘核结合能：$B_0 = 2.224575\\,\\mathrm{MeV}$\n- π介子质量：$m_\\pi = 138.0\\,\\mathrm{MeV}$\n\n由此，我们推导出：\n- 双核子系统的约化质量：\n$$\n\\mu = \\frac{m_p m_n}{m_p + m_n} = \\frac{(938.2720813\\,\\mathrm{MeV})(939.5654133\\,\\mathrm{MeV})}{938.2720813\\,\\mathrm{MeV} + 939.5654133\\,\\mathrm{MeV}} \\approx 469.459415\\,\\mathrm{MeV}\n$$\n- 渐近结合动量 $\\gamma$：\n$$\n\\gamma = \\frac{\\sqrt{2 \\mu B_0}}{\\hbar c} = \\frac{\\sqrt{2 (469.459415\\,\\mathrm{MeV})(2.224575\\,\\mathrm{MeV})}}{197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}} \\approx 0.231597\\,\\mathrm{fm}^{-1}\n$$\n- 与π介子质量相关的动量标度 $\\mu_\\pi$：\n$$\n\\mu_\\pi = \\frac{m_\\pi}{\\hbar c} = \\frac{138.0\\,\\mathrm{MeV}}{197.3269804\\,\\mathrm{MeV}\\cdot\\mathrm{fm}} \\approx 0.699343\\,\\mathrm{fm}^{-1}\n$$\n\n### 1. 电磁 $1/L$ 库仑尾能量移动\n\n在一个移除了光子零模的周期性体积中，对于一个点状电荷 $+q$，其主要的电磁有限体积能量移动由以下公式给出：\n$$\n\\Delta E_{\\mathrm{EM}}(L) = \\frac{q^2\\,\\alpha\\,\\hbar c}{2\\,L}\\; c(\\eta)\n$$\n这种 $1/L$ 标度变化是无质量力载体（光子）的特征。此计算的核心是数值评估无量纲的 Ewald 常数 $c(\\eta)$：\n$$\nc(\\eta) \\equiv \\sum_{\\mathbf{n}\\neq \\mathbf{0}} \\frac{\\operatorname{erfc}\\!\\left(\\sqrt{\\eta}\\, r_{\\mathbf{n}}\\right)}{r_{\\mathbf{n}}}\n\\;+\\;\n\\frac{1}{\\pi}\\sum_{\\mathbf{m}\\neq \\mathbf{0}} \\frac{\\exp\\!\\left(-\\frac{\\pi^2\\, m_{\\mathbf{m}}^2}{\\eta}\\right)}{m_{\\mathbf{m}}^2}\n\\;-\\;\n\\frac{2\\sqrt{\\eta}}{\\sqrt{\\pi}}\n$$\n其中 $\\mathbf{n}=(n_x, n_y, n_z)$ 和 $\\mathbf{m}=(m_x, m_y, m_z)$ 是整数向量，且 $r_{\\mathbf{n}}=\\|\\mathbf{n}\\|$, $m_{\\mathbf{m}}=\\|\\mathbf{m}\\|$。参数 $\\eta$ 将求和分解为一个快速收敛的正空间和（通过互补误差函数 $\\operatorname{erfc}$）和一个快速收敛的倒空间和。$c(\\eta)$ 的结果与 $\\eta$ 无关。\n\n为了用 $\\eta=2.0$ 数值计算 $c(\\eta)$，我们截断求和。问题指定包含所有分量位于 $[-N_{\\mathrm{Ewald}}, N_{\\mathrm{Ewald}}] = [-6, 6]$ 内的整数向量，不包括零向量 $\\mathbf{0}=(0,0,0)$。算法如下：\n1. 初始化两个和，$S_n = 0$ 和 $S_m = 0$。\n2. 遍历从 $-6$ 到 $6$ 的立方整数网格 $i, j, k$。\n3. 对于每个三元组 $(i,j,k)$，如果它不是 $(0,0,0)$：\n   a. 计算模长的平方 $d^2 = i^2 + j^2 + k^2$ 和模长 $d = \\sqrt{d^2}$。\n   b. 将 $\\operatorname{erfc}(\\sqrt{\\eta} d) / d$ 加到 $S_n$。\n   c. 将 $\\exp(-\\pi^2 d^2 / \\eta) / d^2$ 加到 $S_m$。\n4. 计算最终常数为 $c(\\eta) = S_n + S_m/\\pi - 2\\sqrt{\\eta}/\\sqrt{\\pi}$。\n然后使用这个值来计算每个给定 $L$ 值的 $\\Delta E_{\\mathrm{EM}}(L)$。\n\n### 2. 强相互作用 $\\mathrm{e}^{-m_\\pi L}$ 尾部能量移动\n\n来自强力的主要有限体积修正源于核势的指数衰减尾部，此处用汤川势 $V_Y$ 建模。该能量移动被估计为所有氘核的周期性镜像与位于原点的原始氘核相互作用产生的势的期望值。\n$$\n\\Delta E_{\\mathrm{strong}}(L) \\approx \\sum_{\\mathbf{n}\\neq \\mathbf{0}} \\langle \\psi | V_Y(|\\mathbf{r}-\\mathbf{R}_{\\mathbf{n}}|) | \\psi \\rangle\n$$\n其中 $\\mathbf{R}_{\\mathbf{n}}=L\\mathbf{n}$ 是镜像的位置。s 波渐近氘核波函数为 $\\psi(r) = \\sqrt{\\gamma/(2\\pi)} \\mathrm{e}^{-\\gamma r}/r$。对于一个径向壳层，对角度积分后的概率密度为 $4\\pi r^2 |\\psi(r)|^2 \\mathrm{d}r = 2\\gamma \\mathrm{e}^{-2\\gamma r} \\mathrm{d}r$。\n\n对于距离为 $R = |\\mathbf{R}_{\\mathbf{n}}|$ 的单个镜像，其期望值涉及对氘核体积的积分，在对立体角 $\\Omega$ 进行平均后，该积分变为一个径向积分。来自镜像的势为 $V_Y(|\\mathbf{r}-\\mathbf{R}|) = -C_Y \\frac{\\hbar c}{4\\pi} \\frac{\\mathrm{e}^{-\\mu_\\pi |\\mathbf{r}-\\mathbf{R}|}}{|\\mathbf{r}-\\mathbf{R}|}$。使用提供的角度平均恒等式，一个镜像的贡献为：\n$$\n\\langle V_Y(R) \\rangle = \\int_0^\\infty 2\\gamma \\mathrm{e}^{-2\\gamma r} \\left( -C_Y \\frac{\\hbar c}{4\\pi} \\right) \\left\\langle \\frac{\\mathrm{e}^{-\\mu_\\pi |\\mathbf{r}-\\mathbf{R}|}}{|\\mathbf{r}-\\mathbf{R}|} \\right\\rangle_{\\Omega} \\mathrm{d}r\n$$\n$$\n\\langle V_Y(R) \\rangle = -C_Y \\frac{\\hbar c}{4\\pi} \\int_0^\\infty 2\\gamma \\mathrm{e}^{-2\\gamma r} \\left( \\frac{\\sinh(\\mu_\\pi r_)}{\\mu_\\pi r_} \\frac{\\mathrm{e}^{-\\mu_\\pi r_>}}{r_>} \\right) \\mathrm{d}r\n$$\n其中 $r_=\\min(r,R)$ 且 $r_>=\\max(r,R)$。在 $r=R$ 处分割积分可得：\n$$\n\\langle V_Y(R) \\rangle = -C_Y \\frac{\\hbar c}{4\\pi} \\left[ \\frac{\\mathrm{e}^{-\\mu_\\pi R}}{R} \\int_0^R \\! 2\\gamma \\mathrm{e}^{-2\\gamma r} \\frac{\\sinh(\\mu_\\pi r)}{\\mu_\\pi r} \\mathrm{d}r + \\frac{\\sinh(\\mu_\\pi R)}{\\mu_\\pi R} \\int_R^\\infty \\! 2\\gamma \\frac{\\mathrm{e}^{-(2\\gamma+\\mu_\\pi) r}}{r} \\mathrm{d}r \\right]\n$$\n方括号中的项对应于问题中提供的 $I_1(R)$ 和 $I_2(R)$ 的定义。问题陈述给出的总能量移动为 $\\Delta E_{\\mathrm{strong}}(L) = -C_Y(\\hbar c) \\sum [I_1 + I_2]$。此公式省略了源于汤川势定义的因子 $1/(4\\pi)$。为了忠实于问题陈述，我们将按给定的公式实现。\n\n积分的求值如下：\n- **$I_1(R)$**: 被积函数 $2\\gamma \\mathrm{e}^{-2\\gamma r} \\sinh(\\mu_\\pi r)/(\\mu_\\pi r)$ 是良态的，其在 $r=0$ 处的极限为 $2\\gamma$。这个定积分可以使用标准的数值求积程序（如 `scipy.integrate.quad`）来计算。\n- **$I_2(R)$**: 积分部分是 $\\int_R^\\infty 2\\gamma \\frac{\\mathrm{e}^{-(2\\gamma+\\mu_\\pi) r}}{r} \\mathrm{d}r$。令 $k = 2\\gamma+\\mu_\\pi$ 并代换 $t=kr$。则 $\\mathrm{d}t=k\\mathrm{d}r$。积分变为 $2\\gamma \\int_{kR}^\\infty \\frac{\\mathrm{e}^{-t}}{t/k} \\frac{\\mathrm{d}t}{k} = 2\\gamma \\int_{kR}^\\infty \\frac{\\mathrm{e}^{-t}}{t} \\mathrm{d}t$。这正是指数积分 $E_1(x)$ 的定义，因此积分的计算结果为 $2\\gamma E_1((2\\gamma+\\mu_\\pi)R)$，可以使用 `scipy.special.exp1` 计算。\n\n总的强相互作用能量移动 $\\Delta E_{\\mathrm{strong}}(L)$ 于是是关于镜像壳层的和，截断于分量在 $[-N_{\\mathrm{img}}, N_{\\mathrm{img}}] = [-2,2]$ 内的向量。这种截断是合理的，因为每个距离为 $R$ 的镜像的贡献都受到指数抑制，大致按 $\\mathrm{e}^{-\\mu_\\pi R}$ 标度变化。因此，来自更远镜像（$R=L\\sqrt{2}, L\\sqrt{3}, \\ldots$）的贡献与最近的镜像（$R=L$）相比可以忽略不计，尤其是在 $L$ 较大时。求和是通过找到指定范围内的所有唯一的模方 $\\|\\mathbf{n}\\|^2$，计算它们的重数，然后将贡献相加来完成的。\n\n### 3. 磁特性系数 $S_{\\mathrm{mag}}(L;\\eta)$\n\n问题定义了 $S_{\\mathrm{mag}}(L;\\eta) \\equiv c(\\eta)$。这反映了有效场论中的一个普遍原则，即不同的可观测量可能具有由相同的普适、长程几何系数决定的有限体积修正。由于 Ewald 常数 $c(\\eta)$ 是从对无量纲格矢的求和中计算出来的，并且与盒子大小 $L$ 无关，因此 $S_{\\mathrm{mag}}$ 也将与 $L$ 无关。我们的计算将通过计算一次 $c(\\eta)$ 并为所有四个测试用例报告相同的值来验证这一点。\n\n数值实现将使用指定的物理常数和计算参数值来为每个测试用例评估 $[\\Delta E_{\\mathrm{EM}}(L), \\Delta E_{\\mathrm{strong}}(L), S_{\\mathrm{mag}}(L;\\eta)]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, integrate\n\ndef solve():\n    \"\"\"\n    Solves the finite-volume corrections problem for the deuteron.\n    \"\"\"\n    # Define physical and numerical parameters from the problem statement.\n    alpha = 1 / 137.035999084\n    hbar_c = 197.3269804  # MeV*fm\n    q = 1.0\n    m_p = 938.2720813    # MeV\n    m_n = 939.5654133    # MeV\n    B0 = 2.224575        # MeV\n    m_pi = 138.0         # MeV\n    C_Y = 0.30\n    eta = 2.0\n    N_Ewald = 6\n    N_img = 2\n\n    # Test cases for L (in fm)\n    test_cases = [8.0, 12.0, 20.0, 40.0]\n\n    # --- Pre-calculate derived constants ---\n    mu_mass = (m_p * m_n) / (m_p + m_n)\n    gamma = np.sqrt(2 * mu_mass * B0) / hbar_c  # fm^-1\n    mu_pi = m_pi / hbar_c                      # fm^-1\n\n    # --- Stage 1  3: Ewald constant c(eta) for EM shift and S_mag ---\n    def compute_c_eta(p_eta, p_N_ewald):\n        \"\"\"\n        Computes the dimensionless Ewald sum constant c(eta).\n        \"\"\"\n        s_n_sum = 0.0\n        s_m_sum = 0.0\n        \n        # Iterate over a cubic grid of integers\n        for nx in range(-p_N_ewald, p_N_ewald + 1):\n            for ny in range(-p_N_ewald, p_N_ewald + 1):\n                for nz in range(-p_N_ewald, p_N_ewald + 1):\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    \n                    d_sq = float(nx**2 + ny**2 + nz**2)\n                    d = np.sqrt(d_sq)\n                    \n                    # Direct lattice sum part\n                    s_n_sum += special.erfc(np.sqrt(p_eta) * d) / d\n                    \n                    # Reciprocal lattice sum part\n                    s_m_sum += np.exp(-np.pi**2 * d_sq / p_eta) / d_sq\n        \n        c = s_n_sum + (1.0 / np.pi) * s_m_sum - (2.0 * np.sqrt(p_eta) / np.sqrt(np.pi))\n        return c\n\n    c_eta_val = compute_c_eta(eta, N_Ewald)\n    s_mag = c_eta_val # By definition in the problem\n\n    # --- Stage 2: Strong interaction shift ---\n\n    def e_strong_integrand(r, local_gamma, local_mu_pi):\n        \"\"\"Integrand for the I_1 integral.\"\"\"\n        if r == 0:\n            return 2.0 * local_gamma\n        return 2.0 * local_gamma * np.exp(-2.0 * local_gamma * r) * np.sinh(local_mu_pi * r) / (local_mu_pi * r)\n\n    def compute_i1_plus_i2(R, local_gamma, local_mu_pi):\n        \"\"\"Computes I_1(R) + I_2(R).\"\"\"\n        # I_1(R) calculation\n        integral_i1, _ = integrate.quad(e_strong_integrand, 0, R, args=(local_gamma, local_mu_pi))\n        i1 = (np.exp(-local_mu_pi * R) / R) * integral_i1\n        \n        # I_2(R) calculation\n        k = 2.0 * local_gamma + local_mu_pi\n        integral_i2 = 2.0 * local_gamma * special.exp1(k * R)\n        \n        # Guard against R=0 case for sinh(x)/x\n        if R == 0:\n            sinh_term = 1.0\n        else:\n            sinh_term = np.sinh(local_mu_pi * R) / (local_mu_pi * R)\n\n        i2 = sinh_term * integral_i2\n        \n        return i1 + i2\n\n    # Pre-compute multiplicities of image shells up to N_img\n    shell_multiplicities = {}\n    for nx in range(-N_img, N_img + 1):\n        for ny in range(-N_img, N_img + 1):\n            for nz in range(-N_img, N_img + 1):\n                if nx == 0 and ny == 0 and nz == 0:\n                    continue\n                norm_sq = nx**2 + ny**2 + nz**2\n                shell_multiplicities[norm_sq] = shell_multiplicities.get(norm_sq, 0) + 1\n\n    unique_shells = sorted(shell_multiplicities.keys())\n\n    # --- Main calculation loop for each test case ---\n    results = []\n    for L in test_cases:\n        # Calculate EM shift\n        delta_e_em = (q**2 * alpha * hbar_c / (2.0 * L)) * c_eta_val\n        \n        # Calculate strong shift\n        sum_i_total = 0.0\n        for norm_sq in unique_shells:\n            R = L * np.sqrt(norm_sq)\n            multiplicity = shell_multiplicities[norm_sq]\n            sum_i_total += multiplicity * compute_i1_plus_i2(R, gamma, mu_pi)\n\n        # Note: The factor 1/(4*pi) is omitted as per the problem's explicit formula\n        delta_e_strong = -C_Y * hbar_c * sum_i_total\n        \n        results.append([delta_e_em, delta_e_strong, s_mag])\n\n    # Final print statement in the exact required format.\n    # Using a more robust formatting to avoid scientific notation issues with str()\n    formatted_results = []\n    for res_list in results:\n        formatted_list = f\"[{res_list[0]:.12f},{res_list[1]:.12f},{res_list[2]:.12f}]\"\n        formatted_results.append(formatted_list)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3559421"}, {"introduction": "在上一个练习的基础上，本练习将关注有限体积修正的结构复杂性。对于具有内禀结构的粒子（如具有四极矩的氘核），有限体积效应并非各向同性。本练习将演示立方晶格盒子如何破坏旋转对称性，从而引入依赖于方向的伪影，并介绍一种强大的计算技术——通过对立方群进行平均，来系统地消除这些主要的各向异性误差 [@problem_id:3559434]。", "problem": "您的任务是设计并实现一个计算程序，用于研究在周期性立方盒子中，氘核四极矩和渐近D/S波比的有限体积修正。目标是建立对有限空间范围的主要依赖关系的模型，并通过对立方群旋转进行平均来减轻主导的各向异性，仅使用已被充分证实的物理原理作为出发点。\n\n从以下基本原理出发：\n\n1. 对于无限体积中束缚动量为 $\\kappa0$ 的浅束缚双核子束缚态（氘核），其渐近径向波函数以 $\\exp(-\\kappa r)$ 的形式衰减，并在相互作用范围之外满足亥姆霍兹方程。在空间周期为 $L$ 的周期性立方盒子中，长程场可以很好地通过镜像求和来近似，该求和通过与周期性镜像的相互作用来修正可观测量。\n\n2. 对于一个局域可观测量 $\\mathcal{O}$，在大 $L$ 下的领头有限体积修正来自于指数衰减的渐近束缚态尾部与其周期性镜像之间的重叠，并按以下形式的加权和进行标度：\n$$\n\\Delta \\mathcal{O}(L,\\hat{\\boldsymbol{n}}) \\propto \\sum_{\\boldsymbol{R}\\neq \\boldsymbol{0}} \\frac{e^{-\\kappa |\\boldsymbol{R}|}}{|\\boldsymbol{R}|} \\,\\mathcal{A}(\\hat{\\boldsymbol{n}},\\hat{\\boldsymbol{R}}),\n$$\n其中 $\\boldsymbol{R}$ 遍历连接原点与镜像的非零格点矢量，$\\hat{\\boldsymbol{R}}=\\boldsymbol{R}/|\\boldsymbol{R}|$，$\\hat{\\boldsymbol{n}}$ 表示氘核的自旋量子化轴。角向结构 $\\mathcal{A}$ 来自于束缚态的多极。\n\n3. 对于氘核，其渐近波函数包含一个S波和一个小的D波分量，它们的干涉在可观测量中引起了一个领头的四极角向依赖性。围绕 $\\hat{\\boldsymbol{n}}$ 的轴对称投影产生一个与勒让德多项式 $P_{2}(\\cos\\theta)$ 成正比的角向因子，其中 $\\cos\\theta = \\hat{\\boldsymbol{n}}\\cdot \\hat{\\boldsymbol{R}}$。\n\n4. 立方体的旋转对称群（正常八面体群）有 $24$ 个元素。对这些离散旋转进行群平均，会将任何角函数投影到立方群的平庸不可约表示上。因为三维空间中的 $\\ell=2$ 表示在立方群下分解为非平庸不可约表示，且不包含平庸表示，所以任何纯粹的 $\\ell=2$ 对象在立方旋转下的群平均都为零。\n\n仅使用以上几点，完成以下任务：\n\nA. 从亥姆霍兹渐近行为和周期性镜像论证出发，为有限体积氘核四极矩 $Q_{d}(L,\\hat{\\boldsymbol{n}})$ 构建一个领头阶、大 $L$ 的模型，该模型是一个各向同性分量和一个四极各向异性分量之和。您的模型必须具有以下形式：\n$$\nQ_{d}(L,\\hat{\\boldsymbol{n}}) \\equiv Q_{\\infty} + a_{Q}\\,S_{\\mathrm{iso}}(L) + b_{Q}\\,S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}}),\n$$\n其中\n$$\nS_{\\mathrm{iso}}(L) = \\sum_{i} \\frac{e^{-\\kappa r_{i}}}{r_{i}}, \\qquad\nS_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}}) = \\sum_{i} \\frac{e^{-\\kappa r_{i}}}{r_{i}}\\,P_{2}\\!\\big(\\hat{\\boldsymbol{n}}\\cdot \\hat{\\boldsymbol{R}}_{i}\\big),\n$$\n其中 $Q_{\\infty}$ 是无限体积四极矩，$a_{Q}$ 和 $b_{Q}$ 是常数，求和遍历一个在距离 $r_{i}$ 处经过审慎截断的镜像方向集 $\\hat{\\boldsymbol{R}}_{i}$。为了计算上的具体性和物理上的合理性，您必须使用前两个立方镜像壳层：\n- 六个轴向邻近镜像，距离为 $r=L$，方向为 $\\pm \\hat{\\boldsymbol{e}}_{x}$、$\\pm \\hat{\\boldsymbol{e}}_{y}$、$\\pm \\hat{\\boldsymbol{e}}_{z}$。\n- 十二个面-对角线镜像，距离为 $r=\\sqrt{2}\\,L$，方向与 $\\pm(\\hat{\\boldsymbol{e}}_{x}\\pm \\hat{\\boldsymbol{e}}_{y})$、$\\pm(\\hat{\\boldsymbol{e}}_{x}\\pm \\hat{\\boldsymbol{e}}_{z})$、$\\pm(\\hat{\\boldsymbol{e}}_{y}\\pm \\hat{\\boldsymbol{e}}_{z})$ 成比例，每个都归一化为单位长度。\n\nB. 使用相同的逻辑，为渐近D/S波比的有限体积形变构建一个领头阶模型，\n$$\n\\eta_{d}(L,\\hat{\\boldsymbol{n}}) \\equiv \\eta_{\\infty} + a_{\\eta}\\,S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}}),\n$$\n其中 $\\eta_{\\infty}$ 是无限体积比值，$a_{\\eta}$ 是一个常数，这与领头形变是四极性的并以 $e^{-\\kappa r}/r$ 形式衰减的观点一致。\n\nC. 证明将 $Q_{d}(L,\\hat{\\boldsymbol{n}})$ 和 $\\eta_{d}(L,\\hat{\\boldsymbol{n}})$ 对作用于 $\\hat{\\boldsymbol{n}}$ 的 $24$ 个立方体正常旋转进行平均，可以消除各向异性部分，剩下：\n$$\n\\overline{Q_{d}}(L) = Q_{\\infty} + a_{Q}\\,S_{\\mathrm{iso}}(L), \\qquad\n\\overline{\\eta_{d}}(L) = \\eta_{\\infty}.\n$$\n\nD. 实现一个程序，对于指定的参数，计算给定取向和三种盒子尺寸下的未平均值和平均值。使用以下数值参数（上述方程中的所有符号必须与这些值一致使用）：\n- 无限体积四极矩：$Q_{\\infty} = 0.2859$ 单位 $\\mathrm{fm}^{2}$。\n- 无限体积D/S波比：$\\eta_{\\infty} = 0.0256$（无量纲）。\n- 束缚动量：$\\kappa = 0.23$ 单位 $\\mathrm{fm}^{-1}$。\n- 系数：$a_{Q} = 0.20$ 单位 $\\mathrm{fm}^{3}$，$b_{Q} = 0.10$ 单位 $\\mathrm{fm}^{3}$，$a_{\\eta} = 0.50$ 单位 $\\mathrm{fm}$。\n- 取向：$\\hat{\\boldsymbol{n}}_{0} = (1,2,3)/\\sqrt{14}$。\n- 镜像方向：包括项目A中指定的前两个壳层。\n- 离散立方旋转平均必须通过构建立方体的 $24$ 个正常旋转矩阵并将其应用于 $\\hat{\\boldsymbol{n}}_{0}$ 来实现。\n\nE. 测试套件。对于三种盒子尺寸 $L\\in\\{4.0, 8.0, 20.0\\}$（单位 $\\mathrm{fm}$），为每个 $L$ 计算以下四个量：\n- $Q_{d}(L,\\hat{\\boldsymbol{n}}_{0})$，单位 $\\mathrm{fm}^{2}$，\n- $\\overline{Q_{d}}(L)$，单位 $\\mathrm{fm}^{2}$，\n- $\\eta_{d}(L,\\hat{\\boldsymbol{n}}_{0})$（无量纲），\n- $\\overline{\\eta_{d}}(L)$（无量纲）。\n\n您的程序应生成单行输出，其中包含十二个浮点数结果，按 $L$ 递增排序，并按上述方式为每个 $L$ 分组，形式为用方括号括起来的逗号分隔列表，例如，\n\"[Q_unavg_L1,Q_avg_L1,eta_unavg_L1,eta_avg_L1,Q_unavg_L2,Q_avg_L2,eta_unavg_L2,eta_avg_L2,Q_unavg_L3,Q_avg_L3,eta_unavg_L3,eta_avg_L3]\".\n所有四极矩必须以 $\\mathrm{fm}^{2}$ 为单位表示，所有D/S波比必须是无量纲的。将每个数字打印并四舍五入到八位小数。\n\n重要约束：\n- 角度是单位矢量之间的纯点积，因此不需要单位转换。\n- 您必须通过算法实现 $24$ 个正常立方旋转（不要硬编码平均结果）。\n- 输出必须是符合要求格式的单一行，仅包含数值列表。", "solution": "该问题要求在一个边长为 $L$ 的周期性立方体积内，为氘核四极矩 $Q_d$ 和渐近D/S波比 $\\eta_d$ 的有限体积修正，构想并实现一个计算模型。解决方案是根据指定的原理制定的。\n\n### A部分与B部分：$Q_d$ 和 $\\eta_d$ 的模型构建\n\n问题假定，对于像氘核这样的浅束缚态，领头的有限体积修正主要由粒子与其周期性镜像的相互作用主导。位于格点位移矢量 $\\boldsymbol{R}$ 处的镜像对局域可观测量的影响，其标度关系为 $\\frac{e^{-\\kappa |\\boldsymbol{R}|}}{|\\boldsymbol{R}|}$，其中 $\\kappa$ 是束缚动量。\n\n氘核拥有一个非零的内禀四极矩，它与有限体积的几何结构耦合。这种耦合引入了对自旋量子化轴 $\\hat{\\boldsymbol{n}}$ 的各向异性依赖。角向依赖由最低阶多极干涉项主导，对氘核而言，这是四极性的，由勒让德多项式 $P_2(\\cos\\theta)$ 描述，其中 $\\theta$ 是 $\\hat{\\boldsymbol{n}}$ 与镜像方向 $\\hat{\\boldsymbol{R}} = \\boldsymbol{R}/|\\boldsymbol{R}|$ 之间的夹角。\n\n基于这些原理，问题为有限体积四极矩 $Q_d(L, \\hat{\\boldsymbol{n}})$ 和D/S波比 $\\eta_d(L, \\hat{\\boldsymbol{n}})$ 提供了模型：\n$$\nQ_{d}(L,\\hat{\\boldsymbol{n}}) = Q_{\\infty} + a_{Q}\\,S_{\\mathrm{iso}}(L) + b_{Q}\\,S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})\n$$\n$$\n\\eta_{d}(L,\\hat{\\boldsymbol{n}}) = \\eta_{\\infty} + a_{\\eta}\\,S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})\n$$\n此处，$Q_{\\infty}$ 和 $\\eta_{\\infty}$ 是无限体积下的值，$a_Q$、$b_Q$ 和 $a_\\eta$ 是参数化有限体积效应强度的常数。函数 $S_{\\mathrm{iso}}(L)$ 和 $S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})$ 分别表示来自周期性镜像求和的各向同性和各向异性贡献。它们的定义如下：\n$$\nS_{\\mathrm{iso}}(L) = \\sum_{i} \\frac{e^{-\\kappa r_{i}}}{r_{i}}\n$$\n$$\nS_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}}) = \\sum_{i} \\frac{e^{-\\kappa r_{i}}}{r_{i}}\\,P_{2}\\!\\big(\\hat{\\boldsymbol{n}}\\cdot \\hat{\\boldsymbol{R}}_{i}\\big)\n$$\n其中对 $i$ 的求和遍历所包含的镜像矢量集 $\\boldsymbol{R}_i$，并有 $r_i = |\\boldsymbol{R}_i|$ 和 $\\hat{\\boldsymbol{R}}_i = \\boldsymbol{R}_i/r_i$。勒让德多项式为 $P_2(x) = \\frac{1}{2}(3x^2 - 1)$。\n\n计算被限制在立方晶格中最近邻镜像的前两个壳层：\n1.  **第一壳层**：六个轴向邻近镜像，距离为 $r_1=L$。矢量是 $(\\pm L, 0, 0)$ 的排列。相应的归一化方向矢量 $\\hat{\\boldsymbol{R}}_i$ 是 $(\\pm 1, 0, 0)$ 的排列。\n2.  **第二壳层**：十二个面-对角线镜像，距离为 $r_2=\\sqrt{L^2+L^2} = \\sqrt{2}L$。矢量是 $(\\pm L, \\pm L, 0)$ 的排列。相应的归一化方向矢量 $\\hat{\\boldsymbol{R}}_i$ 是 $(\\pm 1/\\sqrt{2}, \\pm 1/\\sqrt{2}, 0)$ 的排列。\n\n将这些代入求和的定义中，我们得到显式表达式：\n$$\nS_{\\mathrm{iso}}(L) = 6 \\frac{e^{-\\kappa L}}{L} + 12 \\frac{e^{-\\kappa \\sqrt{2}L}}{\\sqrt{2}L}\n$$\n$$\nS_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}}) = \\frac{e^{-\\kappa L}}{L} \\sum_{i \\in \\text{Shell 1}} P_2(\\hat{\\boldsymbol{n}}\\cdot\\hat{\\boldsymbol{R}}_i) + \\frac{e^{-\\kappa \\sqrt{2}L}}{\\sqrt{2}L} \\sum_{i \\in \\text{Shell 2}} P_2(\\hat{\\boldsymbol{n}}\\cdot\\hat{\\boldsymbol{R}}_i)\n$$\n这些表达式完成了 $Q_d$ 和 $\\eta_d$ 模型的构建。\n\n### C部分：立方群平均\n\n问题要求证明对立方体的 $24$ 个正常旋转进行平均可以消除各向异性贡献。一个可观测量 $\\mathcal{O}(\\hat{\\boldsymbol{n}})$ 在正常立方（八面体）群 $O$ 上的平均定义为：\n$$\n\\overline{\\mathcal{O}} = \\frac{1}{|O|} \\sum_{g \\in O} \\mathcal{O}(g\\hat{\\boldsymbol{n}}) = \\frac{1}{24} \\sum_{g \\in O} \\mathcal{O}(g\\hat{\\boldsymbol{n}})\n$$\n其中 $g\\hat{\\boldsymbol{n}}$ 是矢量 $\\hat{\\boldsymbol{n}}$ 经过旋转 $g$ 变换后的矢量。\n\n让我们将此应用于模型。$Q_{\\infty}$、$\\eta_{\\infty}$ 和 $S_{\\mathrm{iso}}(L)$ 这几项与 $\\hat{\\boldsymbol{n}}$ 无关，因此在平均过程中保持不变。唯一受影响的项是 $S_{\\mathrm{aniso}}(L, \\hat{\\boldsymbol{n}})$。其平均值为：\n$$\n\\overline{S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})} = \\sum_{i} \\frac{e^{-\\kappa r_{i}}}{r_{i}} \\left( \\frac{1}{24} \\sum_{g \\in O} P_{2}\\big((g\\hat{\\boldsymbol{n}})\\cdot \\hat{\\boldsymbol{R}}_{i}\\big) \\right)\n$$\n如问题所述，角函数 $P_2(\\hat{\\boldsymbol{a}} \\cdot \\hat{\\boldsymbol{b}})$ 是一个角动量为 $\\ell=2$ 的对象。用群论的语言来说，它根据旋转群 $SO(3)$ 的 $D^{(2)}$ 表示进行变换。当限制到立方子群 $O$ 时，该表示分解为 $O$ 的不可约表示。其分解为 $D^{(2)} \\rightarrow E_g \\oplus T_{2g}$。关键在于，此分解不包含平庸（标量）表示 $A_{1g}$。群平均算符 $\\frac{1}{|O|} \\sum_{g \\in O}$ 是到 $A_{1g}$ 不可约表示上的投影算符。由于 $\\ell=2$ 空间在 $A_{1g}$ 表示中没有分量，因此任何纯粹的 $\\ell=2$ 对象在立方群上的平均必为零。\n因此，对于任何固定的矢量 $\\hat{\\boldsymbol{R}}_i$，$P_2((g\\hat{\\boldsymbol{n}})\\cdot \\hat{\\boldsymbol{R}}_i)$ 在所有旋转 $g$ 上的平均为零。这意味着：\n$$\n\\overline{S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})} = 0\n$$\n因此，平均后的可观测量为：\n$$\n\\overline{Q_{d}}(L) = \\frac{1}{24} \\sum_{g \\in O} \\left( Q_{\\infty} + a_{Q}\\,S_{\\mathrm{iso}}(L) + b_{Q}\\,S_{\\mathrm{aniso}}(L,g\\hat{\\boldsymbol{n}}) \\right) = Q_{\\infty} + a_{Q}\\,S_{\\mathrm{iso}}(L) + b_{Q}\\,\\overline{S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})} = Q_{\\infty} + a_{Q}\\,S_{\\mathrm{iso}}(L)\n$$\n$$\n\\overline{\\eta_{d}}(L) = \\frac{1}{24} \\sum_{g \\in O} \\left( \\eta_{\\infty} + a_{\\eta}\\,S_{\\mathrm{aniso}}(L,g\\hat{\\boldsymbol{n}}) \\right) = \\eta_{\\infty} + a_{\\eta}\\,\\overline{S_{\\mathrm{aniso}}(L,\\hat{\\boldsymbol{n}})} = \\eta_{\\infty}\n$$\n这证明了立方平均系统地消除了领头阶的各向异性有限体积赝象。\n\n### D部分与E部分：计算实现\n\n计算过程涉及为指定的数值参数和测试用例实现上述推导出的公式。\n\n1.  **定义常数**：定义所有给定的参数（$Q_{\\infty}$、$\\eta_{\\infty}$、$\\kappa$、$a_Q$、$b_Q$、$a_\\eta$）。特定的取向矢量为 $\\hat{\\boldsymbol{n}}_0 = (1,2,3)/\\sqrt{14}$。\n2.  **生成镜像矢量**：生成并存储前两个壳层的 $18$ 个单位方向矢量 $\\hat{\\boldsymbol{R}}_i$。\n3.  **生成立方旋转矩阵**：生成正常立方群 $O$ 的 $24$ 个旋转矩阵。一种系统的方法是考虑单位矩阵列的所有排列，并结合保持行列式为 $+1$ 的符号翻转。\n4.  **计算求和**：\n    -   一个函数计算给定 $L$ 的 $S_{\\mathrm{iso}}(L)$。\n    -   一个函数计算给定 $L$ 和取向 $\\hat{\\boldsymbol{n}}$ 的 $S_{\\mathrm{aniso}}(L, \\hat{\\boldsymbol{n}})$。\n5.  **主循环**：计算迭代遍历盒子尺寸 $L \\in \\{4.0, 8.0, 20.0\\}$。对于每个 $L$：\n    a. 直接使用 $\\hat{\\boldsymbol{n}}_0$ 计算未平均的量 $Q_d(L, \\hat{\\boldsymbol{n}}_0)$ 和 $\\eta_d(L, \\hat{\\boldsymbol{n}}_0)$。\n    b. 通过显式执行数值平均来计算平均后的量。一个循环遍历 $24$ 个旋转矩阵 $g_j$。对于每一个，找到旋转后的矢量 $\\hat{\\boldsymbol{n}}_j = g_j \\hat{\\boldsymbol{n}}_0$，并计算 $S_{\\mathrm{aniso}}(L, \\hat{\\boldsymbol{n}}_j)$。然后确定这 $24$ 个值的平均值 ${\\overline{S_{\\mathrm{aniso}}}}^{\\text{num}}$。\n    c. 根据群论原理，${\\overline{S_{\\mathrm{aniso}}}}^{\\text{num}}$ 预期在数值上接近于零（在浮点精度范围内）。\n    d. 使用此数值平均值计算平均后的可观测量 $\\overline{Q_d}(L)$ 和 $\\overline{\\eta_d}(L)$。\n6.  **输出格式化**：将得到的十二个浮点数四舍五入到八位小数，并格式化为所需的单行字符串。\n\n此过程为问题中概述的物理原理提供了一个具体的计算检验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes finite-volume corrections for the deuteron quadrupole moment\n    and D-to-S ratio based on a periodic image sum model.\n    \"\"\"\n\n    # Part D: Define numerical parameters from the problem statement\n    Q_inf = 0.2859      # fm^2\n    eta_inf = 0.0256    # dimensionless\n    kappa = 0.23        # fm^-1\n    a_Q = 0.20          # fm^3\n    b_Q = 0.10          # fm^3\n    a_eta = 0.50        # fm\n    n0 = np.array([1, 2, 3]) / np.sqrt(14)\n    L_values = [4.0, 8.0, 20.0]  # fm\n\n    # Generate the 18 image direction vectors for the first two shells\n    R_hat_vectors = []\n    # Shell 1: distance L, 6 vectors\n    for i in range(3):\n        for sign in [-1, 1]:\n            vec = np.zeros(3)\n            vec[i] = sign\n            R_hat_vectors.append(vec)\n            \n    # Shell 2: distance sqrt(2)*L, 12 vectors\n    for i, j in itertools.combinations(range(3), 2):\n        for si in [-1, 1]:\n            for sj in [-1, 1]:\n                vec = np.zeros(3)\n                vec[i] = si\n                vec[j] = sj\n                R_hat_vectors.append(vec / np.sqrt(2))\n    \n    R_hat_vectors = np.array(R_hat_vectors)\n\n    # Generate the 24 proper cubic rotation matrices\n    def get_sgn_permutation(p):\n        \"\"\"Calculate the sign of a permutation.\"\"\"\n        inversions = 0\n        n = len(p)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] > p[j]:\n                    inversions += 1\n        return 1 if inversions % 2 == 0 else -1\n\n    rotation_matrices = []\n    permutations = list(itertools.permutations([0, 1, 2]))\n    \n    for p in permutations:\n        sgn_p = get_sgn_permutation(p)\n        P_matrix = np.zeros((3, 3))\n        for i in range(3):\n            P_matrix[p[i], i] = 1\n\n        for s1, s2, s3 in itertools.product([-1, 1], repeat=3):\n            if s1 * s2 * s3 * sgn_p == 1:\n                S_matrix = np.diag([s1, s2, s3])\n                R_matrix = P_matrix @ S_matrix\n                rotation_matrices.append(R_matrix.T) # Use transpose for R@v convention\n\n    # Helper function for Legendre polynomial P2(x)\n    def P2(x):\n        return 0.5 * (3 * x**2 - 1)\n\n    # Functions to calculate the sums\n    def calculate_S_iso(L, k):\n        term1 = np.exp(-k * L) / L\n        term2 = np.exp(-k * np.sqrt(2) * L) / (np.sqrt(2) * L)\n        return 6 * term1 + 12 * term2\n\n    def calculate_S_aniso(L, k, n_vec):\n        term1 = np.exp(-k * L) / L\n        term2 = np.exp(-k * np.sqrt(2) * L) / (np.sqrt(2) * L)\n        \n        s_aniso = 0.0\n        # Shell 1\n        for i in range(6):\n            dot_product = np.dot(n_vec, R_hat_vectors[i])\n            s_aniso += term1 * P2(dot_product)\n        \n        # Shell 2\n        for i in range(6, 18):\n            dot_product = np.dot(n_vec, R_hat_vectors[i])\n            s_aniso += term2 * P2(dot_product)\n            \n        return s_aniso\n\n    # Part E: Main calculation loop\n    results = []\n    for L in L_values:\n        # Calculate S_iso and S_aniso for the un-averaged case\n        S_iso_val = calculate_S_iso(L, kappa)\n        S_aniso_n0 = calculate_S_aniso(L, kappa, n0)\n        \n        # Un-averaged quantities\n        Qd_unavg = Q_inf + a_Q * S_iso_val + b_Q * S_aniso_n0\n        eta_unavg = eta_inf + a_eta * S_aniso_n0\n        \n        # Averaged quantities: must perform the average algorithmically\n        S_aniso_avg = 0.0\n        for R_mat in rotation_matrices:\n            n_rotated = R_mat @ n0\n            S_aniso_avg += calculate_S_aniso(L, kappa, n_rotated)\n        S_aniso_avg /= 24.0\n\n        Qd_avg = Q_inf + a_Q * S_iso_val + b_Q * S_aniso_avg\n        eta_avg = eta_inf + a_eta * S_aniso_avg\n        \n        # Append formatted results for this L\n        results.extend([\n            f\"{Qd_unavg:.8f}\",\n            f\"{Qd_avg:.8f}\",\n            f\"{eta_unavg:.8f}\",\n            f\"{eta_avg:.8f}\",\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3559434"}, {"introduction": "本练习将重点从有限体积修正的来源，转移到分析这些修正所用的 Lüscher 方法中一个关键的系统不确定性上。在实际计算中，必须截断无穷阶的分波，这可能会引入偏差。这个高级练习提供了一个模型来量化这种偏差，有助于培养如何选择运动学设置（不可约表示）以最小化被忽略的高阶分波污染的直觉 [@problem_id:3559431]。", "problem": "考虑两个相同的无自旋粒子在边长为 $L$ 的立方周期性盒子中发生弹性散射，使用由行列式方程 $\\det\\left(\\mathcal{K}^{-1}(E)+\\mathcal{F}(E,L)\\right)=0$ 推导出的有限体积量化条件进行分析。其中，$\\mathcal{K}(E)$ 是无限体积、分波对角的散射 $\\mathcal{K}$ 矩阵，$\\mathcal{F}(E,L)$ 则包含了有限体积的几何效应。在无限体积极限下，以轨道角动量 $l$ 标记的分波是解耦的；而在有限体积中，它们的贡献在适用于所选参考系的立方对称群的不可约表示 (irreps) 内发生混合。在行列式条件中截断至有限的分波集合，会在更高阶分波在同一不可约表示中有贡献时，给相移引入偏差。\n\n您将研究一个简化的单通道模型，该模型描述了一个宽的 $p$ 波 ($l=1$) 共振，其主要污染来自一个奇数高阶分波 $l=5$。质心能量 $E$ 被视为无量纲，质心动量为 $q(E)=\\sqrt{E}$ (无量纲)。宽共振附近的 $p$ 波相移由 Breit–Wigner 形式建模\n$$\n\\delta_1(E) = \\arctan\\left(\\frac{\\Gamma(E)}{E_R - E}\\right),\n\\quad\n\\Gamma(E) = \\gamma\\, q(E)^{3},\n$$\n其中 $E_R0$ 是共振能量，$\\gamma0$ 控制依赖于能量的宽度。背景 $l=5$ 相移被假定为小而平滑的，\n$$\n\\delta_5(E) = \\kappa_5\\, q(E)^{11},\n$$\n其中 $\\kappa_50$ 是一个小的常数。\n\n在固定的不可约表示 $\\Lambda$ 内，将对角的有限体积几何函数和领头的非对角混合项的简化形式定义为\n$$\n\\phi_{l,\\Lambda}(E,L) \\equiv \\frac{a_{l,\\Lambda}}{L^{3}\\, q(E)^{l+1}},\n\\quad\nF_{1,5}^{\\Lambda}(E,L) \\equiv \\frac{b_{\\Lambda}}{L^{3}\\, q(E)^3},\n$$\n其中 $a_{l,\\Lambda}0$ 和 $b_{\\Lambda}0$ 是依赖于不可约表示的无量纲常数，它们编码了几何约化的相对强度，而总体的 $L^{-3}$ 标度行为反映了典型的有限体积压低效应。\n\n在由 $\\{l=1\\}$ 张成的子空间中工作，并通过 Schur 补近似处理被忽略的高阶分波 $l=5$，投影到截断子空间上的精确行列式条件会引起对有效几何函数的一个能量依赖的修正，\n$$\n\\Delta \\phi_{\\Lambda}(E,L) \\equiv -\\frac{\\left(F_{1,5}^{\\Lambda}(E,L)\\right)^{2}}{\\cot\\delta_{5}(E)+\\phi_{5,\\Lambda}(E,L)} = -\\frac{\\left(b_{\\Lambda}/(L^{3}\\, q(E)^{3})\\right)^{2}}{\\cot\\left(\\delta_{5}(E)\\right)+a_{5,\\Lambda}/(L^{3}\\, q(E)^{6})}.\n$$\n在给定的不可约表示 $\\Lambda$ 中，真实的有限体积能级 $E^\\star$ 是以下方程的解\n$$\n\\cot\\delta_{1}(E^\\star) + \\phi_{1,\\Lambda}(E^\\star,L) + \\Delta \\phi_{\\Lambda}(E^\\star,L) = 0,\n$$\n其中 $\\cot\\delta_{1}(E) = \\frac{E_R - E}{\\Gamma(E)}$。如果忽略高阶分波并使用截断条件进行拟合，\n$$\n\\cot\\delta_{1}^{\\text{(trunc)}}(E) + \\phi_{1,\\Lambda}(E,L) = 0,\n$$\n那么从测得的能量 $E^\\star$ 推断出的相移是满足 $\\cot\\delta_{1}^{\\text{(trunc)}}(E^\\star) = -\\phi_{1,\\Lambda}(E^\\star,L)$ 的解 $\\delta_{1}^{\\text{(trunc)}}(E^\\star)$，并选择最接近真实值 $\\delta_1(E^\\star) \\in (0,\\pi)$ 的那个分支。\n\n您的任务是：\n1. 对于下方的每个测试用例，数值求解出满足精确条件的能量 $E^\\star$，然后评估定义为如下的相移偏差\n$$\n\\Delta\\delta \\equiv \\delta_{1}^{\\text{(trunc)}}(E^\\star) - \\delta_{1}(E^\\star),\n$$\n结果以弧度表示。使用约定 $\\delta_{1}(E) = \\arctan2\\left(\\Gamma(E),\\,E_R-E\\right)$ 将其映射到 $(0,\\pi)$，并选择 $\\delta_{1}^{\\text{(trunc)}}(E^\\star)$ 的分支以最小化 $|\\delta_{1}^{\\text{(trunc)}}(E^\\star)-\\delta_{1}(E^\\star)|$。\n\n2. 对于下方指定的参数的每个不可约表示选项 $\\Lambda\\in\\{0,1,2\\}$，计算每个测试用例在解出的 $E^\\star$ 处的污染度量，\n$$\n\\mathcal{M}_{\\Lambda}(E^\\star,L) \\equiv \\frac{\\left(F_{1,5}^{\\Lambda}(E^\\star,L)\\right)^{2}}{\\left|\\cot\\delta_{5}(E^\\star)+\\phi_{5,\\Lambda}(E^\\star,L)\\right|},\n$$\n然后将这些度量在所有测试用例上取平均值。确定平均值最小的两个不可约表示；按升序报告它们的整数代码。\n\n不可约表示参数化 (无量纲):\n- $\\Lambda=0$: $a_{1,0}=5.0$, $a_{5,0}=0.5$, $b_{0}=0.10$.\n- $\\Lambda=1$: $a_{1,1}=3.0$, $a_{5,1}=0.3$, $b_{1}=0.06$.\n- $\\Lambda=2$: $a_{1,2}=1.5$, $a_{5,2}=0.15$, $b_{2}=0.02$.\n\n测试套件 (无量纲输入; 角度以弧度为单位):\n- 用例 1: $(E_R,\\gamma,\\kappa_5,L,\\Lambda) = (1.00,\\,0.80,\\,0.020,\\,18,\\,0)$.\n- 用例 2 (边界情况: 非常宽且体积较小): $(E_R,\\gamma,\\kappa_5,L,\\Lambda) = (1.00,\\,1.10,\\,0.030,\\,12,\\,1)$.\n- 用例 3 (大体积): $(E_R,\\gamma,\\kappa_5,L,\\Lambda) = (1.00,\\,0.60,\\,0.020,\\,28,\\,2)$.\n\n算法要求:\n- 实现一个鲁棒的求根程序，在每个用例中通过寻找以下函数的零点来求解 $E^\\star$\n$$\nf(E) \\equiv \\frac{E_R - E}{\\gamma\\, q(E)^3} + \\frac{a_{1,\\Lambda}}{L^{3}\\, q(E)^{2}} - \\frac{\\left(\\frac{b_{\\Lambda}}{L^{3}\\, q(E)^{3}}\\right)^{2}}{\\frac{1}{\\tan\\left(\\kappa_5\\, q(E)^{11}\\right)} + \\frac{a_{5,\\Lambda}}{L^{3}\\, q(E)^{6}}},\n$$\n求解区间应在 $E_R$ 附近的一个合理范围内。如果找不到一个使函数值变号的区间，则在包含共振的一个有界区间内最小化 $|f(E)|$，并将最小值点视为 $E^\\star$。\n\n- 按规定计算 $\\delta_{1}(E^\\star)$ 和 $\\delta_{1}^{\\text{(trunc)}}(E^\\star)$，然后计算 $\\Delta\\delta$。\n\n输出规格:\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，即\n$$\n[\\Delta\\delta_1,\\,\\Delta\\delta_2,\\,\\Delta\\delta_3,\\,\\Lambda_{\\text{best},1},\\,\\Lambda_{\\text{best},2}],\n$$\n其中前三个条目是三个用例的偏差 (以弧度为单位的浮点数)，后两个条目是在所有三个用例中平均污染度量最小的两个不可约表示的整数代码。\n\n无需外部输入。所有量都是无量纲的，角度必须以弧度报告。", "solution": "该问题要求对一个有限体积中的双粒子散射模型进行数值求解，重点是量化由分波截断引起的系统误差。求解方法包括三个主要步骤：首先，数值求解一个超越方程以获得有限体积能谱；其次，计算由于截断而在提取散射相移时产生的偏差；第三，对不同的运动学设置（不可约表示，或 irreps），评估一个度量以量化来自更高阶分波的污染水平。\n\n理论基础是 Lüscher 方法及其扩展，该方法将有限体积中系统的离散能谱与无限体积散射振幅联系起来。在立方体积中，球对称性破缺为立方对称性，导致在无限体积中本应解耦的分波之间发生混合。我们获得了一个模型，其中主导的 $p$ 波 ($l=1$) 共振被一个小的 $l=5$ 分波污染。\n\n第一步是确定每个测试用例的离散能级 $E^\\star$。它们是精确量化条件的根，这是一个由以下公式给出的非线性方程：\n$$\n\\cot\\delta_{1}(E^\\star) + \\phi_{1,\\Lambda}(E^\\star,L) + \\Delta \\phi_{\\Lambda}(E^\\star,L) = 0\n$$\n其中所有项都是质心能量 $E$ 的函数。代入所给的定义，我们寻求函数 $f(E)$ 的根：\n$$\nf(E) \\equiv \\underbrace{\\frac{E_R - E}{\\gamma\\, q(E)^3}}_{\\cot\\delta_1(E)} + \\underbrace{\\frac{a_{1,\\Lambda}}{L^{3}\\, q(E)^{2}}}_{\\phi_{1,\\Lambda}(E,L)} - \\underbrace{\\frac{\\left(\\frac{b_{\\Lambda}}{L^{3}\\, q(E)^{3}}\\right)^{2}}{\\frac{1}{\\tan\\left(\\kappa_5\\, q(E)^{11}\\right)} + \\frac{a_{5,\\Lambda}}{L^{3}\\, q(E)^{6}}}}_{-\\Delta\\phi_\\Lambda(E,L)} = 0\n$$\n这里，$q(E) = \\sqrt{E}$。这是一个关于 $E$ 的超越方程，没有简单的解析解。因此，需要一个数值求根算法。问题指定了一个鲁棒的程序：我们首先尝试找到一个区间 $[E_a, E_b]$，使得 $f(E_a)$ 和 $f(E_b)$ 异号，然后使用像 Brent 方法 (`scipy.optimize.brentq`) 这样的有界求根算法来找到根 $E^\\star$。共振能量 $E_R$ 提供了一个寻找根的天然位置。如果由于根不存在或 $f(E)$ 中存在极点而导致区间法失败，我们退而求其次，在有界区间内找到使绝对值 $|f(E)|$ 最小的能量 $E^\\star$，使用诸如 `scipy.optimize.minimize_scalar` 的方法。\n\n一旦找到了给定测试用例的 $E^\\star$，第二个任务是计算相移偏差 $\\Delta\\delta$。这个偏差表示如果错误地假设系统只包含 $p$ 波，将会产生的误差。此能量下“真实”的 $p$ 波相移直接从其模型定义计算：\n$$\n\\delta_{1}(E^\\star) = \\arctan2\\left(\\Gamma(E^\\star),\\,E_R - E^\\star\\right)\n$$\n其中 $\\Gamma(E) = \\gamma\\,q(E)^3$。使用双参数反正切函数 `arctan2(y,x)`，对于宽度 $\\Gamma(E)$ 为正的共振，能正确地将角度映射到区间 $(0, \\pi)$。“截断”相移 $\\delta_{1}^{\\text{(trunc)}}(E^\\star)$，是使用简化（不正确）的量化条件从测得的 $E^\\star$ 推断出的值：\n$$\n\\cot\\delta_{1}^{\\text{(trunc)}}(E^\\star) = -\\phi_{1,\\Lambda}(E^\\star,L) = -\\frac{a_{1,\\Lambda}}{L^{3}\\, q(E^\\star)^{2}}\n$$\n为了找到 $\\delta_{1}^{\\text{(trunc)}}(E^\\star)$，我们必须对余切函数求逆。反余切函数是多值的，其解的形式为 $\\operatorname{arccot}(x) + n\\pi$，其中 $n$ 为任意整数。问题指定我们必须选择使绝对差 $|\\delta_{1}^{\\text{(trunc)}}(E^\\star) - \\delta_{1}(E^\\star)|$ 最小化的分支（即 $n$ 的值）。这可以通过首先计算主值 $\\delta_{\\text{base}} = \\arctan2(1, \\cot\\delta_{1}^{\\text{(trunc)}}(E^\\star)) \\in (0,\\pi)$，然后加上 $\\pi$ 的整数倍，使其最接近真实值 $\\delta_{1}(E^\\star)$ 来实现。偏差即为两者的差：\n$$\n\\Delta\\delta = \\delta_{1}^{\\text{(trunc)}}(E^\\star) - \\delta_{1}(E^\\star)\n$$\n\n第三个任务是评估三个标记为 $\\Lambda=0, 1, 2$ 的不可约表示中，哪一个最不容易受到 $l=5$ 分波的污染影响。这通过使用污染度量来完成：\n$$\n\\mathcal{M}_{\\Lambda}(E^\\star,L) \\equiv \\frac{\\left(F_{1,5}^{\\Lambda}(E^\\star,L)\\right)^{2}}{\\left|\\cot\\delta_{5}(E^\\star)+\\phi_{5,\\Lambda}(E^\\star,L)\\right|}\n$$\n该量精确地是修正项的绝对值 $|\\Delta\\phi_{\\Lambda}(E^\\star,L)|$，它直接衡量了更高阶分波对量化条件影响的大小。对于三个测试用例中的每一个，我们使用解出的能量 $E^\\star$ 及其相应参数（$L, \\kappa_5$）来为所有三个不可约表示选项 $\\Lambda \\in \\{0,1,2\\}$ 计算此度量。然后，将每个不可约表示的结果在三个测试用例上取平均。平均度量最小的两个不可约表示被认为是“最佳”或污染最少的，并按升序报告它们的整数代码。\n\n实现将通过首先为不可约表示和测试用例定义参数来组织此逻辑。对于每个测试用例，找到根 $E^\\star$。然后，使用这个 $E^\\star$ 值来计算该特定用例的相移偏差和三个污染度量（每个 $\\Lambda \\in \\{0, 1, 2\\}$ 一个）。处理完所有用例后，收集偏差，计算每个不可约表示的平均污染，并识别出最佳的两个不可约表示。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq, minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves the finite-volume scattering problem as described.\n    1. Finds the energy level E* for each test case by root-finding.\n    2. Calculates the phase shift bias for each case.\n    3. Calculates contamination metrics for each irrep across all cases,\n       averages them, and identifies the two best irreps.\n    \"\"\"\n\n    # Irrep parameters (dimensionless)\n    # Lambda: {a_{1,Lambda}, a_{5,Lambda}, b_{Lambda}}\n    irrep_params = {\n        0: {'a1': 5.0, 'a5': 0.5, 'b': 0.10},\n        1: {'a1': 3.0, 'a5': 0.3, 'b': 0.06},\n        2: {'a1': 1.5, 'a5': 0.15, 'b': 0.02},\n    }\n\n    # Test cases\n    # (E_R, gamma, kappa_5, L, Lambda_idx)\n    test_cases = [\n        (1.00, 0.80, 0.020, 18, 0),\n        (1.00, 1.10, 0.030, 12, 1),\n        (1.00, 0.60, 0.020, 28, 2),\n    ]\n\n    biases = []\n    # Store metrics as [[M0_c1, M1_c1, M2_c1], [M0_c2, ...], ...]\n    all_metrics = []\n\n    for case in test_cases:\n        E_R, gamma, kappa_5, L, Lambda_idx = case\n        params = irrep_params[Lambda_idx]\n        a1, a5, b = params['a1'], params['a5'], params['b']\n        L3 = L**3\n\n        def f(E):\n            \"\"\"The function whose root E_star is sought.\"\"\"\n            if E = 0:\n                return np.inf\n\n            q = np.sqrt(E)\n            q2 = E\n            q3 = q * q2\n            q6 = q3 * q3\n            q11 = q**11\n\n            term1 = (E_R - E) / (gamma * q3)  # cot(delta_1)\n            term2 = a1 / (L3 * q2)          # phi_{1,Lambda}\n            \n            # Correction term, -Delta phi_Lambda\n            delta5_arg = kappa_5 * q11\n            # Avoid poles of cot by checking argument's sine\n            if np.abs(np.sin(delta5_arg))  1e-12:\n                cot_delta5 = np.inf\n            else:\n                cot_delta5 = 1.0 / np.tan(delta5_arg)\n            \n            num_corr = (b / (L3 * q3))**2\n            den_corr = cot_delta5 + (a5 / (L3 * q6))\n            \n            if np.abs(den_corr)  1e-12: # Avoid division by zero\n                term3 = np.sign(num_corr) * np.inf\n            else:\n                term3 = num_corr / den_corr\n            \n            return term1 + term2 - term3\n        \n        # --- Find E_star ---\n        E_star = None\n        search_bracket = [0.1 * E_R, 2.0 * E_R]\n        try:\n            # First, attempt root-finding with a bracket\n            E_star = brentq(f, search_bracket[0], search_bracket[1], xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # Fallback: minimize the absolute value of the function\n            res = minimize_scalar(lambda E: np.abs(f(E)), bounds=search_bracket, method='bounded')\n            E_star = res.x\n\n        # --- Calculate Phase Shift Bias ---\n        q_star = np.sqrt(E_star)\n        \n        # True phase shift\n        Gamma_E_star = gamma * q_star**3\n        delta1_true = np.arctan2(Gamma_E_star, E_R - E_star)\n        \n        # Truncated phase shift\n        cot_delta1_trunc = -params['a1'] / (L3 * q_star**2)\n        # Principal value of arccot in (0, pi)\n        base_angle_trunc = np.arctan2(1.0, cot_delta1_trunc)\n        \n        # Choose branch closest to the true angle\n        k = np.round((delta1_true - base_angle_trunc) / np.pi)\n        delta1_trunc = base_angle_trunc + k * np.pi\n        \n        bias = delta1_trunc - delta1_true\n        biases.append(bias)\n\n        # --- Calculate Contamination Metrics for all irreps ---\n        case_metrics = []\n        for i in range(3): # Iterate through irreps Lambda = 0, 1, 2\n            p_eval = irrep_params[i]\n            a5_eval, b_eval = p_eval['a5'], p_eval['b']\n            \n            q2 = E_star\n            q3 = q_star * q2\n            q6 = q3 * q3\n            q11 = q_star**11\n\n            F_15_sq = (b_eval / (L3 * q3))**2\n            \n            delta5_arg_eval = kappa_5 * q11\n            if np.abs(np.sin(delta5_arg_eval))  1e-12:\n                cot_delta5_eval = np.inf\n            else:\n                cot_delta5_eval = 1.0 / np.tan(delta5_arg_eval)\n            \n            phi5_eval = a5_eval / (L3 * q6)\n            \n            den_metric = cot_delta5_eval + phi5_eval\n            \n            if np.abs(den_metric)  1e-12:\n                metric = np.inf\n            else:\n                metric = F_15_sq / np.abs(den_metric)\n            \n            case_metrics.append(metric)\n        all_metrics.append(case_metrics)\n        \n    # --- Determine the best irreps ---\n    metrics_array = np.array(all_metrics)\n    avg_metrics = np.mean(metrics_array, axis=0)\n    \n    # Pair metrics with their irrep index and sort\n    sorted_irreps = sorted(enumerate(avg_metrics), key=lambda x: x[1])\n    \n    best_irrep1_idx = sorted_irreps[0][0]\n    best_irrep2_idx = sorted_irreps[1][0]\n    \n    # Report in ascending order\n    best_irreps = sorted([best_irrep1_idx, best_irrep2_idx])\n    \n    # --- Format final output ---\n    final_results = biases + best_irreps\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3559431"}]}