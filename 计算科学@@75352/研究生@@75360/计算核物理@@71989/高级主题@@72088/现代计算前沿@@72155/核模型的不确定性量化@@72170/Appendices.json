{"hands_on_practices": [{"introduction": "核模型的参数，例如那些来自半经验质量公式的参数，通常具有不确定性。一个核心的挑战是理解这些输入不确定性如何传播到模型的预测（即可观测量）上。这个练习 [@problem_id:3610367] 将指导您使用一种强大的非侵入式方法，即多项式混沌展开（Polynomial Chaos Expansion, PCE），来解决这个问题。您将学习如何将一个模型输出表示为关于不确定参数的正交多项式级数，并通过数值投影来计算展开系数，从而高效地构建一个能够捕捉不确定性传播的代理模型。", "problem": "构建一个完整、可运行的程序，该程序为一个作为不确定参数函数的核模型可观测量建立多项式混沌展开（PCE），并通过相对于先验测度的投影来计算展开系数。其背景是计算核物理中的不确定性量化。从基本定义开始：PCE 将一个平方可积的随机可观测量表示为其先验概率测度下的一个标准正交多项式基的展开，其系数通过使用该测度导出的内积进行投影来获得。假设不确定参数的先验是独立的，每个先验都定义在一个闭区间上，并对每个参数使用与均匀概率测度相关的标准正交多项式族。在多维情况下，使用张量积基并按总阶数进行截断。相应地，将参数视为其支撑集区间上的随机变量，并构建一个多维乘积测度。通过在标准区间上使用张量积高斯求积（GQ）来数值近似所需的投影，从而实现系数计算。下面的可观测量定义是半经验质量公式在物理上合理的简化形式，并针对固定原子核进行表达。所有表示可观测量或其 PCE 系数的输出都必须以兆电子伏特（MeV）为单位。\n\n对于一个固定的原子核，通过以下从不确定参数到可观测量的确定性映射来定义可观测量：\n- 情况定义使用了标准的半经验质量模型分量：体积能系数、表面能系数和库仑能系数，分别表示为 $a_v$、$a_s$ 和 $a_c$。设 $A$ 为质量数，$Z$ 为质子数。考虑简化的结合能可观测量 $B$（单位为兆电子伏特 MeV），由 $B(a_v,a_s,a_c;A,Z) = a_v A - a_s A^{2/3} - a_c Z^2 A^{-1/3}$ 给出，当较少系数被建模为不确定时，使用其简化形式。\n\n建模和基的假设：\n- 将每个不确定参数视为在其指定区间上独立均匀分布，并对每个参数使用与此均匀概率测度相关的标准正交多项式基。使用多维张量积基的总阶数截断，即保留所有分量阶数之和小于或等于指定最大阶数的多重指标。\n- 通过在标准区间上使用张量积高斯求积来实现数值投影积分，并应用从参数支撑集到标准区间的适当线性映射。每个维度选择足够数量的求积节点，以便在不产生混叠的情况下，对可观测量与基函数之积进行积分，直至达到所需的多项式阶数。实现必须确保与标准正交基和先验概率测度一致的正确归一化。\n\n测试套件规范和要求的输出：\n对于每个测试用例，计算并输出完整的 PCE 系数列表，系数按总阶数递增排序，在每个总阶数内，按多重指标的字典序（第一个分量变化最慢）排序。系数必须以 MeV 为单位，作为浮点数报告。\n\n- 测试用例 $1$：一维，固定原子核，质量数 $A=56$，无库仑项。可观测量 $B(a_v;A)=a_v A$。$a_v$ 的先验：在 $[14.5,16.5]$ 上均匀分布。最大总阶数 $p=3$。\n\n- 测试用例 $2$：二维，固定原子核，质量数 $A=100$，无库仑项。可观测量 $B(a_v,a_s;A) = a_v A - a_s A^{2/3}$。先验：$a_v$ 在 $[14.0,16.0]$ 上均匀分布，$a_s$ 在 $[16.0,18.0]$ 上均匀分布。最大总阶数 $p=2$。\n\n- 测试用例 $3$：三维，固定原子核，质量数 $A=208$，质子数 $Z=82$。可观测量 $B(a_v,a_s,a_c;A,Z) = a_v A - a_s A^{2/3} - a_c Z^2 A^{-1/3}$。先验：$a_v$ 在 $[14.0,16.0]$ 上均匀分布，$a_s$ 在 $[16.0,18.0]$ 上均匀分布，$a_c$ 在 $[0.6,0.8]$ 上均匀分布。最大总阶数 $p=2$。\n\n- 测试用例 $4$：用于测试三维常数项投影的边界情况。与测试用例 $3$ 具有相同的可观测量和先验，最大总阶数 $p=0$。\n\n输出格式：\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身也是一个由方括号括起来的逗号分隔列表。例如，如果有 $4$ 个测试用例，最终输出必须看起来像 $[[c_{1,1},c_{1,2},\\dots],[c_{2,1},\\dots],[c_{3,1},\\dots],[c_{4,1},\\dots]]$，不含任何空格。每个 $c_{i,j}$ 是一个以 MeV 为单位的浮点数。\n\n角度单位不适用。所有数值输出均带有单位兆电子伏特（MeV）。", "solution": "该任务是为一个简化的核结合能可观测量构建多项式混沌展开（PCE），并通过投影计算其展开系数。这个问题定义明确，科学上根植于不确定性量化和核物理，并为其解决方案提供了完整的规范。我们首先建立数学框架，然后详细说明数值实现。\n\n### 1. 数学表述\n\n一个平方可积的随机可观测量 $M(\\mathbf{x})$，它是一个 $d$ 维独立随机参数向量 $\\mathbf{x} = (x_1, \\dots, x_d)$ 的函数，可以用多项式混沌展开来表示。假设每个参数 $x_i$ 在已知的区间 $[a_i, b_i]$ 上均匀分布，即 $x_i \\sim U(a_i, b_i)$。\n\n为了使用一套标准的多项式基，我们将每个物理参数 $x_i$ 转换到一个在区间 $[-1, 1]$ 上均匀分布的标准随机变量 $\\xi_i$。相应的概率密度函数是 $\\rho(\\xi_i) = 1/2$，其中 $\\xi_i \\in [-1, 1]$。仿射变换为：\n$$x_i(\\xi_i) = \\frac{b_i-a_i}{2} \\xi_i + \\frac{a_i+b_i}{2}$$\n现在，可观测量 $M(\\mathbf{x})$ 可以表示为标准变量的函数，$\\tilde{M}(\\boldsymbol{\\xi}) = M(\\mathbf{x}(\\boldsymbol{\\xi}))$。\n\n对于在 $[-1, 1]$ 上均匀分布的随机变量，其标准正交多项式基由缩放后的 Legendre 多项式组成。标准的 Legendre 多项式 $P_k(\\xi)$ 在 $[-1, 1]$ 上关于标准权重函数 $w(\\xi)=1$ 是正交的：$\\int_{-1}^1 P_k(\\xi) P_j(\\xi) d\\xi = \\frac{2}{2k+1}\\delta_{kj}$。\n由我们的概率测度 $\\rho(\\xi)d\\xi$ 导出的内积是 $\\langle f, g \\rangle = \\int_{-1}^1 f(\\xi) g(\\xi) \\frac{1}{2} d\\xi$。正确归一化的基多项式 $\\Psi_k(\\xi)$ 必须满足 $\\langle \\Psi_k, \\Psi_j \\rangle = \\delta_{kj}$。设 $\\Psi_k(\\xi) = c_k P_k(\\xi)$，我们发现：\n$$\\langle \\Psi_k, \\Psi_j \\rangle = c_k c_j \\int_{-1}^1 P_k(\\xi) P_j(\\xi) \\frac{1}{2} d\\xi = \\frac{c_k c_j}{2} \\frac{2}{2k+1} \\delta_{kj} = \\frac{c_k^2}{2k+1} \\delta_{kj}$$\n为使此式等于 $\\delta_{kj}$，我们需要 $c_k = \\sqrt{2k+1}$。因此，一维标准正交基函数是：\n$$\\Psi_k(\\xi) = \\sqrt{2k+1} P_k(\\xi)$$\n\n对于具有独立参数的 $d$ 维情况，基是由一维基的张量积构成的。基函数由一个多重指标 $\\boldsymbol{\\alpha} = (\\alpha_1, \\dots, \\alpha_d) \\in \\mathbb{N}_0^d$ 索引：\n$$\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) = \\prod_{i=1}^d \\Psi_{\\alpha_i}(\\xi_i) = \\prod_{i=1}^d \\sqrt{2\\alpha_i+1} P_{\\alpha_i}(\\xi_i)$$\nPCE 使用总阶数方案进行截断，保留所有其分量阶数之和不超过最大总阶数 $p$ 的基函数：$|\\boldsymbol{\\alpha}| = \\sum_{i=1}^d \\alpha_i \\le p$。可观测量的截断 PCE 为：\n$$\\tilde{M}(\\boldsymbol{\\xi}) \\approx \\sum_{|\\boldsymbol{\\alpha}| \\le p} c_{\\boldsymbol{\\alpha}} \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$$\n\n系数 $c_{\\boldsymbol{\\alpha}}$ 是通过将可观测量投影到每个基函数上找到的，使用的内积由超立方体 $[-1, 1]^d$ 上的联合概率测度 $\\rho(\\boldsymbol{\\xi})d\\boldsymbol{\\xi} = (1/2)^d d\\boldsymbol{\\xi}$ 导出：\n$$c_{\\boldsymbol{\\alpha}} = \\langle \\tilde{M}, \\Psi_{\\boldsymbol{\\alpha}} \\rangle = \\int_{[-1, 1]^d} \\tilde{M}(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) \\rho(\\boldsymbol{\\xi}) d\\boldsymbol{\\xi} = \\left(\\frac{1}{2}\\right)^d \\int_{[-1, 1]^d} \\tilde{M}(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) d\\boldsymbol{\\xi}$$\n\n### 2. 数值实现\n\n用于计算 $c_{\\boldsymbol{\\alpha}}$ 的多维积分是通过张量积高斯求积（GQ）法则进行数值计算的。具体来说，我们使用 Gauss-Legendre 求积。一维 $N_q$ 点 Gauss-Legendre 法则将积分近似为 $\\int_{-1}^1 f(\\xi) d\\xi \\approx \\sum_{j=1}^{N_q} f(\\xi_j) w_j$，其中 $\\xi_j$ 是求积节点，而 $w_j$ 是相应的权重。$d$ 维的张量积法则是：\n$$\\int_{[-1, 1]^d} g(\\boldsymbol{\\xi}) d\\boldsymbol{\\xi} \\approx \\sum_{j_1=1}^{N_q} \\dots \\sum_{j_d=1}^{N_q} g(\\xi_{j_1}, \\dots, \\xi_{j_d}) \\prod_{k=1}^d w_{j_k}$$\n将此应用于系数积分，我们得到：\n$$c_{\\boldsymbol{\\alpha}} \\approx \\left(\\frac{1}{2}\\right)^d \\sum_{j_1, \\dots, j_d} \\tilde{M}(\\xi_{j_1}, \\dots, \\xi_{j_d}) \\Psi_{\\boldsymbol{\\alpha}}(\\xi_{j_1}, \\dots, \\xi_{j_d}) \\prod_{k=1}^d w_{j_k}$$\n\n为了确保准确性，求积点数 $N_q$ 的选择必须足够大，以便能够精确地积分多项式被积函数 $\\tilde{M}(\\boldsymbol{\\xi}) \\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$。可观测量 $B$ 是其参数 $(a_v, a_s, a_c)$ 的线性函数。由于从 $\\xi_i$ 到 $x_i$ 的映射是线性的，$\\tilde{M}(\\boldsymbol{\\xi})$ 是 $\\boldsymbol{\\xi}$ 中总阶数为 $1$ 的多项式。基函数 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$ 是一个总阶数为 $|\\boldsymbol{\\alpha}|$ 的多项式。被积函数在任何单一维度 $i$ 上的最高阶数为 $1 + \\alpha_i$。由于总阶数为 $p$ 的展开中任何 $\\alpha_i$ 的最大值为 $p$，因此在任何一个维度上需要积分的最高多项式阶数为 $1+p$。一个 $N_q$ 点的 Gauss-Legendre 法则可以精确积分最高 $2N_q - 1$ 阶的多项式。因此，我们要求 $2N_q - 1 \\ge p + 1$，简化为 $N_q \\ge (p+2)/2$。为保证稳健性，我们选择 $N_q = p+1$，这对所有非负的 $p$ 都满足此条件。\n\n总体算法如下：\n1.  对于每个测试用例（维度 $d$、最大阶数 $p$、可观测量 $M$ 和先验）：\n2.  生成满足 $|\\boldsymbol{\\alpha}| \\le p$ 的多重指标集 $\\boldsymbol{\\alpha}$。首先按总阶数 $|\\boldsymbol{\\alpha}|$ 排序，然后按字典序排序。\n3.  设置每个维度的求积点数 $N_q = p + 1$。\n4.  获取 $N_q$ 个一维 Gauss-Legendre 节点和权重。\n5.  构建求积节点 $\\boldsymbol{\\xi}^{(j)}$ 的 $d$ 维网格和相应的乘积权重 $W^{(j)}$。\n6.  对于网格上的每个节点 $\\boldsymbol{\\xi}^{(j)}$，将其转换到物理参数空间 $\\mathbf{x}^{(j)}$。\n7.  在每个物理网格点上评估模型可观测量 $M(\\mathbf{x}^{(j)})$，以获得模型值的网格。\n8.  对于排序列表中的每个多重指标 $\\boldsymbol{\\alpha}$：\n    a. 在每个标准网格节点上评估基函数 $\\Psi_{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}^{(j)})$。\n    b. 通过对模型值网格和基函数值网格进行逐元素相乘来计算被积函数。\n    c. 通过将被积函数展平后的网格与乘积权重展平后的网格进行点积来近似积分。\n    d. 将积分结果乘以 $(0.5)^d$ 来计算系数 $c_{\\boldsymbol{\\alpha}}$。\n9.  收集每个测试用例计算出的系数，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes Polynomial Chaos Expansion coefficients for a simplified nuclear binding energy model.\n    \"\"\"\n\n    def generate_multi_indices(dim, max_degree):\n        \"\"\"\n        Generates multi-indices for a given dimension and maximum total degree.\n        The indices are sorted by total degree, then lexicographically.\n        \"\"\"\n        if dim == 0:\n            if max_degree >= 0:\n                return [()]\n            else:\n                return []\n        \n        if dim == 1:\n            return [(i,) for i in range(max_degree + 1)]\n\n        indices = []\n        for i in range(max_degree + 1):\n            sub_indices = generate_multi_indices(dim - 1, max_degree - i)\n            for sub_index in sub_indices:\n                indices.append((i,) + sub_index)\n        \n        # Sort by total degree, then lexicographically\n        indices.sort(key=lambda idx: (sum(idx), idx))\n        return indices\n\n    def compute_pce_coefficients(model_func, priors, dim, max_degree):\n        \"\"\"\n        Computes the PCE coefficients for a given model, priors, dimension, and max degree.\n        \"\"\"\n        # Step 1: Generate multi-indices\n        multi_indices = generate_multi_indices(dim, max_degree)\n\n        # Step 2: Determine quadrature rule\n        num_quad_points = max_degree + 1\n        nodes_1d, weights_1d = roots_legendre(num_quad_points)\n\n        # Step 3: Construct multi-dimensional quadrature grid\n        # 'ij' indexing creates grids that can be stacked correctly for our purpose.\n        xi_grids = np.meshgrid(*([nodes_1d] * dim), indexing='ij')\n        w_grids = np.meshgrid(*([weights_1d] * dim), indexing='ij')\n\n        # Create a single grid of product weights\n        product_weights_grid = np.prod(np.stack(w_grids, axis=-1), axis=-1)\n\n        # Step 4: Transform canonical nodes to physical parameter space\n        centers = np.array([(p[0] + p[1]) / 2.0 for p in priors])\n        half_widths = np.array([(p[1] - p[0]) / 2.0 for p in priors])\n        \n        physical_params_grid = []\n        for i in range(dim):\n             physical_params_grid.append(centers[i] + half_widths[i] * xi_grids[i])\n\n        # Step 5: Evaluate the model on the grid\n        model_values_grid = model_func(*physical_params_grid)\n\n        # Step 6: Compute coefficients\n        coefficients = []\n        for alpha in multi_indices:\n            # Evaluate the multi-dimensional basis polynomial on the grid\n            basis_values_grid = np.ones_like(model_values_grid)\n            for i in range(dim):\n                degree = alpha[i]\n                # Orthonormal Legendre polynomials: sqrt(2k+1) * P_k(x)\n                poly = legendre(degree)\n                norm_factor = np.sqrt(2 * degree + 1)\n                basis_values_grid *= (norm_factor * poly(xi_grids[i]))\n            \n            # Form the integrand\n            integrand_grid = model_values_grid * basis_values_grid\n            \n            # Approximate the integral using the quadrature rule\n            integral_val = np.sum(integrand_grid * product_weights_grid)\n            \n            # Final coefficient calculation\n            # c_alpha = (1/2)^d * integral\n            c_alpha = (0.5**dim) * integral_val\n            coefficients.append(c_alpha)\n        \n        return coefficients\n\n    # Define test cases\n    # (observable_lambda, priors_list, dimension, max_pce_degree)\n    test_cases = [\n        (lambda a_v: 56.0 * a_v, [(14.5, 16.5)], 1, 3),\n        (lambda a_v, a_s: 100.0 * a_v - (100.0**(2.0/3.0)) * a_s, \n         [(14.0, 16.0), (16.0, 18.0)], 2, 2),\n        (lambda a_v, a_s, a_c: 208.0 * a_v - (208.0**(2.0/3.0)) * a_s - (82.0**2 * 208.0**(-1.0/3.0)) * a_c,\n         [(14.0, 16.0), (16.0, 18.0), (0.6, 0.8)], 3, 2),\n        (lambda a_v, a_s, a_c: 208.0 * a_v - (208.0**(2.0/3.0)) * a_s - (82.0**2 * 208.0**(-1.0/3.0)) * a_c,\n         [(14.0, 16.0), (16.0, 18.0), (0.6, 0.8)], 3, 0),\n    ]\n\n    all_results = []\n    for model, priors, dim, p_max in test_cases:\n        coeffs = compute_pce_coefficients(model, priors, dim, p_max)\n        all_results.append(coeffs)\n    \n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join([f'{c:.15g}' for c in case_coeffs])}]\" for case_coeffs in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3610367"}, {"introduction": "在根据实验数据校准核模型时，至关重要的是要有一种可靠的方法来评估模型的预测能力并防止过拟合。交叉验证（Cross-Validation, CV）是完成此任务的标准工具，但其有效性取决于对数据结构特征的正确处理。这个练习 [@problem_id:3610428] 探讨了一个在核物理中至关重要的场景：当数据点在同位素链内存在系统性偏差（即相关性）时，简单的交叉验证方案可能会失效。通过比较两种不同的交叉验证方案，您将亲身体会到选择恰当的验证策略对于获得可靠的模型性能评估是多么重要。", "problem": "您的任务是编写一个完整且可运行的程序，用于比较两种交叉验证方案。这些方案用于校准一个线性能量密度泛函 (EDF) 类的代理模型，该模型用于预测原子核结合能残差。您的程序必须估计预测风险，并检测“留一核子法”(leave-one-nucleus-out)和“留一同位素链法”(leave-one-isotopic-chain-out)方案之间潜在的过拟合差异。\n\n模型和数据生成如下。\n\n1. 基本基础和建模假设：\n   - 假设可观测量是每个核子的结合能残差，记为 $y$，单位为兆电子伏特 (MeV)。假设一个线性代理模型，其特征映射为质子数 $Z$ 和中子数 $N$ 的最高二次多项式。对于一个给定的核 $(Z, N)$，定义特征向量\n     $$\\phi(Z,N) = \\begin{bmatrix} 1  Z  N  Z^2  N^2  ZN \\end{bmatrix}^{\\top}.$$\n   - 假设存在加性独立高斯噪声，其均值为零，标准差为 $\\sigma$（单位为 MeV），即 $\\epsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n   - 数据由一个固定但未知的线性参数向量 $\\beta^{\\star} \\in \\mathbb{R}^6$，加上一个仅依赖于 $Z$ 的未建模同位素链偏移 $g(Z)$，以及一个独立噪声 $\\epsilon$ 生成。即，\n     $$ y = \\phi(Z,N)^{\\top} \\beta^{\\star} + g(Z) + \\epsilon.$$\n   - 校准使用岭正则化最小二乘法，对系数带有高斯先验解释，其中截距项（对应于常数项的第一个分量）不被惩罚。对于给定的正则化强度 $\\lambda \\ge 0$，估计量 $\\hat{\\beta}_{\\lambda}$ 最小化\n     $$ \\sum_{i=1}^{n} \\left(y_i - \\phi(Z_i,N_i)^{\\top}\\beta\\right)^2 + \\lambda \\sum_{j=2}^{6} \\beta_j^2.$$\n\n2. 交叉验证方案和预测风险：\n   - 留一核子法交叉验证 (LONO-CV)：对每个数据点 $i$，在其余 $n-1$ 个数据点上拟合 $\\hat{\\beta}_{\\lambda}^{(-i)}$，并计算在被留出的点 $i$ 上的预测平方误差。对于 $\\lambda$ 的 LONO-CV 预测风险是这些在所有 $n$ 次留出中的预测平方误差的均值。\n   - 留一同位素链法交叉验证 (LOICO-CV)：对于由质子数 $Z$ 标识的每个不同同位素链，在所有不属于该链的核子上进行拟合，然后预测被留出的链，并累加该链中所有核子的预测平方误差。对于 $\\lambda$ 的 LOICO-CV 预测风险是所有被留出链上的所有预测平方误差的均值。此处，同位素链定义为具有相同质子数 $Z$ 和不同中子数 $N$ 的一组核子。\n\n3. 正则化网格和选择：\n   - 考虑正则化强度的离散网格\n     $$ \\Lambda = \\{\\, 0,\\, 10^{-6},\\, 10^{-3},\\, 10^{-1},\\, 1,\\, 10 \\,\\}. $$\n   - 对于每个交叉验证方案，选择使相应预测风险最小化的 $\\lambda \\in \\Lambda$。如果在风险值上出现绝对容差 $10^{-12}$ 内的平局，则选择这些平局中最小的 $\\lambda$。\n\n4. 过拟合检测标准：\n   - 定义一个过拟合检测指标，它是一个布尔值，计算方式如下\n     $$ \\text{overfit\\_detected} = \\left( \\lambda_{\\text{LONO}}^{\\star} = 0 \\right) \\wedge \\left( \\lambda_{\\text{LOICO}}^{\\star} > 0 \\right), $$\n     其中 $\\lambda_{\\text{LONO}}^{\\star}$ 和 $\\lambda_{\\text{LOICO}}^{\\star}$ 分别是 LONO-CV 和 LOICO-CV 下的最优选择。\n\n5. 数据集、真实参数和同位素链偏移：\n   - 使用以下核子集合 $(Z,N)$，按 $Z$ 分组成同位素链：\n     - $Z=20$: $N \\in \\{\\, 20,\\, 22,\\, 24,\\, 26 \\,\\}$,\n     - $Z=28$: $N \\in \\{\\, 28,\\, 30,\\, 32,\\, 34 \\,\\}$,\n     - $Z=50$: $N \\in \\{\\, 64,\\, 66,\\, 68,\\, 70 \\,\\}$,\n     - $Z=82$: $N \\in \\{\\, 120,\\, 122,\\, 124,\\, 126 \\,\\}$.\n   - 使用真实参数向量\n     $$ \\beta^{\\star} = \\begin{bmatrix} 5.0  -0.08  -0.10  5.0\\times 10^{-4}  3.0\\times 10^{-4}  2.0\\times 10^{-4} \\end{bmatrix}^{\\top} \\text{ MeV}, $$\n     和同位素链偏移\n     $$ g(20)=1.2 \\text{ MeV},\\quad g(28)=-1.0 \\text{ MeV},\\quad g(50)=0.5 \\text{ MeV},\\quad g(82)=-2.0 \\text{ MeV}.$$\n\n6. 测试套件：\n   - 您必须评估三个仅在噪声水平 $\\sigma$ 和用于生成高斯噪声的随机种子上有所不同的测试用例。对于每个测试用例 $t \\in \\{1,2,3\\}$，通过抽取独立的 $\\epsilon \\sim \\mathcal{N}(0,\\sigma^2)$ 来生成输出 $y$，并使用指定的种子以保证可复现性。使用：\n     - 用例 1：$\\sigma = 0.20$ MeV，随机种子 $123$，\n     - 用例 2：$\\sigma = 0.00$ MeV，随机种子 $456$，\n     - 用例 3：$\\sigma = 2.00$ MeV，随机种子 $789$。\n\n7. 每个测试用例所需的计算和输出：\n   - 对于每个测试用例，计算：\n     - 最优 LONO-CV 预测风险（均方预测误差），单位为兆电子伏特平方，记为 $R_{\\text{LONO}}^{\\star}$，\n     - 最优 LOICO-CV 预测风险（均方预测误差），单位为兆电子伏特平方，记为 $R_{\\text{LOICO}}^{\\star}$，\n     - 相应的最优正则化强度 $\\lambda_{\\text{LONO}}^{\\star}$ 和 $\\lambda_{\\text{LOICO}}^{\\star}$，来自网格 $\\Lambda$，\n     - 如上定义的过拟合检测布尔值。\n   - 所有风险必须表示为实数，单位为兆电子伏特平方 (MeV$^2$)。所有正则化强度必须表示为不带单位的实数。布尔值必须是字面量 True 或 False。\n\n8. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含所有三个测试用例的结果，形式为一个逗号分隔的列表的列表，不含空格，并用一对单独的方括号括起来。对于每个测试用例，输出列表\n     $$ \\left[ R_{\\text{LONO}}^{\\star},\\ R_{\\text{LOICO}}^{\\star},\\ \\lambda_{\\text{LONO}}^{\\star},\\ \\lambda_{\\text{LOICO}}^{\\star},\\ \\text{overfit\\_detected} \\right]. $$\n   - 因此，最终输出应如下所示\n     $$ \\big[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\big], $$\n     其中每个数值条目都以标准浮点字面量打印，布尔值打印为 True 或 False，并且该行中任何地方都不能有空格。\n\n您的解决方案必须从上述基本假设开始，并精确地实现所定义的两种交叉验证方案。不允许任何外部输入；所有常数和数据均在此处指定。给定随机种子后，程序必须是确定性的。全部逻辑必须嵌入在程序中，并且它必须只产生指定的一行输出。", "solution": "用户提供了一个核物理领域的计算问题，特别关注能量密度泛函（EDF）代理模型的不确定性量化。任务是比较两种交叉验证（CV）方案，即留一核子法（LONO-CV）和留一同位素链法（LOICO-CV），用于校准一个线性模型并检测潜在的过拟合。\n\n### 第1步：提取给定信息\n- **可观测量**：每个核子的结合能残差，$y$，单位为兆电子伏特（MeV）。\n- **代理模型**：一个带有多项式特征映射的线性模型。\n- **特征向量**：对于一个核 $(Z,N)$，$\\phi(Z,N) = \\begin{bmatrix} 1  Z  N  Z^2  N^2  ZN \\end{bmatrix}^{\\top}$。\n- **数据生成模型**：$y = \\phi(Z,N)^{\\top} \\beta^{\\star} + g(Z) + \\epsilon$。\n- **噪声模型**：$\\epsilon \\sim \\mathcal{N}(0,\\sigma^2)$，独立同分布的高斯噪声。\n- **真实参数**：$\\beta^{\\star} = \\begin{bmatrix} 5.0  -0.08  -0.10  5.0\\times 10^{-4}  3.0\\times 10^{-4}  2.0\\times 10^{-4} \\end{bmatrix}^{\\top}$ MeV。\n- **同位素链偏移**：$g(20)=1.2$ MeV, $g(28)=-1.0$ MeV, $g(50)=0.5$ MeV, $g(82)=-2.0$ MeV。\n- **校准方法**：岭正则化最小二乘法，最小化 $\\sum_{i=1}^{n} (y_i - \\phi(Z_i,N_i)^{\\top}\\beta)^2 + \\lambda \\sum_{j=2}^{6} \\beta_j^2$。截距项 $\\beta_1$ 不被惩罚。\n- **交叉验证方案**：\n    - **LONO-CV**：留一核子法交叉验证。风险是所有 $n$ 次留出中的预测平方误差的均值。\n    - **LOICO-CV**：留一同位素链法交叉验证。同位素链是具有相同 $Z$ 的核子集合。风险是所有被留出链的预测平方误差的均值。\n- **正则化网格**：$\\Lambda = \\{\\, 0,\\, 10^{-6},\\, 10^{-3},\\, 10^{-1},\\, 1,\\, 10 \\,\\}$。\n- **最优 $\\lambda$ 选择**：选择使 CV 风险最小化的 $\\lambda \\in \\Lambda$。如果风险值在 $10^{-12}$ 的绝对容差内出现平局，则选择最小的 $\\lambda$。\n- **过拟合指标**：$\\text{overfit\\_detected} = (\\lambda_{\\text{LONO}}^{\\star} = 0) \\wedge (\\lambda_{\\text{LOICO}}^{\\star} > 0)$。\n- **数据集**：\n    - $Z=20$: $N \\in \\{20, 22, 24, 26\\}$\n    - $Z=28$: $N \\in \\{28, 30, 32, 34\\}$\n    - $Z=50$: $N \\in \\{64, 66, 68, 70\\}$\n    - $Z=82$: $N \\in \\{120, 122, 124, 126\\}$\n- **测试用例**：\n    - 用例 1：$\\sigma = 0.20$ MeV，随机种子 $123$。\n    - 用例 2：$\\sigma = 0.00$ MeV，随机种子 $456$。\n    - 用例 3：$\\sigma = 2.00$ MeV，随机种子 $789$。\n- **要求输出**：对每个用例，输出一个列表 $[R_{\\text{LONO}}^{\\star}, R_{\\text{LOICO}}^{\\star}, \\lambda_{\\text{LONO}}^{\\star}, \\lambda_{\\text{LOICO}}^{\\star}, \\text{overfit\\_detected}]$，其中 $R$ 是以 MeV$^2$ 为单位的风险。\n- **最终格式**：单行 `[[...],[...],[...]]`，不含空格。\n\n### 第2步：使用提取的给定信息进行验证\n该问题是在核物理背景下设置的一个明确定义的统计建模和机器学习计算任务。\n- **科学上合理**：该问题使用了如能量密度泛函、代理建模和交叉验证等概念，这些都是计算物理中的标准方法。该模型是一个为计算练习而指定的简化模型，并非对基础物理的论断。作为一项建模研究，这在科学上是合理的。\n- **定义明确**：所有组件都已指定：数据生成过程、要拟合的模型、优化目标（带无惩罚截距项的岭回归）、交叉验证程序、超参数网格和评估指标。使用随机种子确保了可复现性。该问题允许一个唯一且可确定性计算的解。\n- **客观性**：问题陈述使用了精确的数学和算法定义，没有歧义或主观语言。\n- **无缺陷**：该问题不违反任何无效性标准。它是自包含、一致、数值上可行且结构清晰的。所有参数、常数和数据都已提供。\n\n### 第3步：结论和行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原则的解决方案设计\n\n问题的核心是为一个岭正则化线性模型实现并比较两种交叉验证策略。关键区别在于未建模的系统误差项 $g(Z)$，它在同一同位素链（相同 $Z$）的数据点之间引入了相关性。两种 CV 方案将以不同方式处理这种相关性。\n\n**1. 数据生成和模型设置**\n首先，我们构建包含 $n=16$ 个核 $(Z,N)$ 的数据集以及对应的设计矩阵 $\\mathbf{X}$，其中每一行是特征向量 $\\phi(Z,N)^{\\top}$。对于每个测试用例，根据模型 $y_i = \\phi(Z_i, N_i)^{\\top} \\beta^{\\star} + g(Z_i) + \\epsilon_i$ 生成响应向量 $\\mathbf{y}$，使用指定的真实参数 $\\beta^{\\star}$、同位素偏移 $g(Z)$、噪声水平 $\\sigma$ 和随机种子。\n\n**2. 岭回归求解器**\n校准需要解决一个岭回归问题，其中截距项 $\\beta_1$ 未被正则化。关于 $\\beta \\in \\mathbb{R}^6$ 的最小化目标函数是：\n$$ L(\\beta) = \\|\\mathbf{y} - \\mathbf{X}\\beta\\|_2^2 + \\lambda \\|\\beta_{2:6}\\|_2^2 = (\\mathbf{y} - \\mathbf{X}\\beta)^{\\top}(\\mathbf{y} - \\mathbf{X}\\beta) + \\beta^{\\top}\\mathbf{P}\\beta $$\n其中 $\\mathbf{P}$ 是一个对角惩罚矩阵 $\\mathbf{P} = \\lambda \\cdot \\text{diag}(0, 1, 1, 1, 1, 1)$。\n对 $\\beta$ 求梯度并令其为零，得到正规方程：\n$$ (\\mathbf{X}^{\\top}\\mathbf{X} + \\mathbf{P})\\beta = \\mathbf{X}^{\\top}\\mathbf{y} $$\n对于每个训练折和正则化强度 $\\lambda$，解此线性系统得到 $\\hat{\\beta}_{\\lambda}$。为此，我们使用一个稳健的线性代数求解器。\n\n**3. 交叉验证方案**\n目标是为来自网格 $\\Lambda$ 的不同 $\\lambda$ 值估计模型的预测风险。\n\n- **留一核子法 (LONO-CV)**：这是标准的留一法交叉验证。对于 $n$ 个数据点中的每一个，我们在其余 $n-1$ 个点上训练模型，并计算在单个被留出的点上的预测平方误差。对于给定的 $\\lambda$，LONO-CV 风险是这 $n$ 个平方误差的平均值。\n$$ R_{\\text{LONO}}(\\lambda) = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\phi(Z_i, N_i)^{\\top}\\hat{\\beta}_{\\lambda}^{(-i)})^2 $$\n其中 $\\hat{\\beta}_{\\lambda}^{(-i)}$ 是在没有数据点 $i$ 的情况下估计的参数向量。由于每个折的训练集几乎肯定包含与被留出点来自同一同位素链的其他核子，该方案允许模型“学习”该链的系统偏移 $g(Z)$。这可能导致对真实泛化误差的估计过于乐观，从而可能偏好一个未正则化的过拟合模型（$\\lambda=0$）。\n\n- **留一同位素链法 (LOICO-CV)**：该方案旨在考虑数据相关性结构。我们不是留出一个核子，而是留出属于同一同位素链的所有核子（即所有具有相同 $Z$ 的核子）。模型在剩余的链上进行训练，并在整个被留出的链上进行测试。对每个同位素链重复此过程。对于给定的 $\\lambda$，LOICO-CV 风险是所有 $n$ 个核子上平方误差的平均值。\n$$ R_{\\text{LOICO}}(\\lambda) = \\frac{1}{n} \\sum_{Z_k \\in \\text{Chains}} \\sum_{i \\in \\text{Chain } Z_k} (y_i - \\phi(Z_i, N_i)^{\\top}\\hat{\\beta}_{\\lambda}^{(-Z_k)})^2 $$\n其中 $\\hat{\\beta}_{\\lambda}^{(-Z_k)}$ 是在没有任何来自质子数为 $Z_k$ 的链的数据的情况下估计的。由于模型在一个其系统偏移 $g(Z_k)$ 在训练期间完全未见的链上进行测试，这为模型外推到新物理区域（即新的质子数）的能力提供了一个更真实的估计。这很可能会揭示模型的设定不当，并偏好一个非零的 $\\lambda$ 以防止对训练数据中存在的特定偏移进行过拟合。\n\n**4. 最优参数选择和过拟合检测**\n对于每个 CV 方案，我们计算每个 $\\lambda \\in \\Lambda$ 的风险。然后，我们确定最小风险，并选择相应的 $\\lambda$ 作为最优值（$\\lambda^{\\star}$）。问题指定了一个平局打破规则：如果多个 $\\lambda$ 值产生的风险在最小值的 $10^{-12}$ 范围内，则选择其中最小的 $\\lambda$。与这个选定的 $\\lambda^{\\star}$ 相关的风险是最优风险 $R^{\\star}$。\n\n最后，过拟合指标通过两个条件的逻辑与运算来计算：来自 LONO-CV 的最优 $\\lambda$ 为零，且来自 LOICO-CV 的最优 $\\lambda$ 大于零。这个条件正式地捕捉了这样一种情景：朴素的 CV 方案 (LONO) 建议不需要正则化，而更稳健的方案 (LOICO) 正确地识别出需要正则化以改善泛化能力，这是由于未建模的系统误差导致的典型过拟合迹象。\n\n整个过程对三个测试用例重复进行，改变噪声水平 $\\sigma$ 和随机种子。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the three test cases and prints the final result.\n    \"\"\"\n\n    def phi(Z, N):\n        \"\"\"Constructs the feature vector for a given nucleus (Z, N).\"\"\"\n        return np.array([1, Z, N, Z**2, N**2, Z*N], dtype=float)\n\n    def solve_ridge(X_train, y_train, lambda_reg):\n        \"\"\"\n        Solves ridge regression with a non-penalized intercept.\n        The objective is: ||y - X*beta||^2 + lambda * ||beta[1:]||^2\n        \"\"\"\n        num_features = X_train.shape[1]\n        # Create the penalty matrix P = lambda * diag(0, 1, 1, ...)\n        P = np.diag([0.0] + [lambda_reg] * (num_features - 1))\n        \n        # Solve the normal equations: (X.T*X + P)*beta = X.T*y\n        A = X_train.T @ X_train + P\n        b = X_train.T @ y_train\n        \n        try:\n            beta_hat = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # Fallback to pseudo-inverse if solve fails (for singular matrices. e.g. when lambda=0 and X is not full rank)\n            # This is generally not expected here but is good practice.\n            A_inv = np.linalg.pinv(A)\n            beta_hat = A_inv @ b\n            \n        return beta_hat\n\n    def select_optimal_lambda(lambdas, risks):\n        \"\"\"\n        Selects the optimal lambda according to the problem's criteria.\n        Chooses the smallest lambda in case of a tie in risk values.\n        \"\"\"\n        tolerance = 1e-12\n        min_risk_val = np.min(risks)\n        \n        # Find all lambdas whose risk is within tolerance of the minimum\n        candidate_lambdas = []\n        for lam, risk in zip(lambdas, risks):\n            if abs(risk - min_risk_val) = tolerance:\n                candidate_lambdas.append(lam)\n        \n        # From the candidates, choose the smallest lambda\n        optimal_lambda = min(candidate_lambdas)\n        \n        # Find the index of this optimal lambda to get its corresponding risk\n        optimal_lambda_index = lambdas.index(optimal_lambda)\n        optimal_risk = risks[optimal_lambda_index]\n        \n        return optimal_risk, optimal_lambda\n\n    def run_case(sigma, seed):\n        \"\"\"\n        Executes the full analysis for a single test case (sigma, seed).\n        \"\"\"\n        # 1. Define constants, data structures, and nuclei\n        nuclei_chains = {\n            20: [20, 22, 24, 26],\n            28: [28, 30, 32, 34],\n            50: [64, 66, 68, 70],\n            82: [120, 122, 124, 126]\n        }\n        nuclei = []\n        for z, ns in nuclei_chains.items():\n            for n in ns:\n                nuclei.append((z, n))\n        \n        num_nuclei = len(nuclei)\n\n        beta_star = np.array([5.0, -0.08, -0.10, 5.0e-4, 3.0e-4, 2.0e-4])\n        g_offsets = {20: 1.2, 28: -1.0, 50: 0.5, 82: -2.0}\n        lambdas = [0.0, 1e-6, 1e-3, 1e-1, 1.0, 10.0]\n\n        # 2. Generate data based on the model\n        rng = np.random.default_rng(seed)\n        X = np.array([phi(z, n) for z, n in nuclei])\n        y = np.zeros(num_nuclei)\n        for i, (z, n) in enumerate(nuclei):\n            true_model_val = X[i, :] @ beta_star\n            chain_offset = g_offsets[z]\n            noise = rng.normal(0, sigma) if sigma > 0 else 0.0\n            y[i] = true_model_val + chain_offset + noise\n\n        # 3. Leave-One-Nucleus-Out Cross-Validation (LONO-CV)\n        lono_risks = []\n        for lam in lambdas:\n            squared_errors = []\n            for i in range(num_nuclei):\n                X_train = np.delete(X, i, axis=0)\n                y_train = np.delete(y, i)\n                X_test_row = X[i, :]\n                y_test_val = y[i]\n                \n                beta_hat = solve_ridge(X_train, y_train, lam)\n                \n                y_pred = X_test_row @ beta_hat\n                squared_errors.append((y_pred - y_test_val)**2)\n            lono_risks.append(np.mean(squared_errors))\n        \n        R_lono_star, lambda_lono_star = select_optimal_lambda(lambdas, lono_risks)\n\n        # 4. Leave-One-Isotopic-Chain-Out Cross-Validation (LOICO-CV)\n        unique_Zs = sorted(nuclei_chains.keys())\n        loico_risks = []\n        for lam in lambdas:\n            all_fold_errors = []\n            for z_out in unique_Zs:\n                test_indices = [i for i, (z, n) in enumerate(nuclei) if z == z_out]\n                train_indices = [i for i, (z, n) in enumerate(nuclei) if z != z_out]\n                \n                X_train, y_train = X[train_indices], y[train_indices]\n                X_test, y_test = X[test_indices], y[test_indices]\n                \n                beta_hat = solve_ridge(X_train, y_train, lam)\n                \n                y_pred = X_test @ beta_hat\n                all_fold_errors.extend((y_pred - y_test)**2)\n            loico_risks.append(np.mean(all_fold_errors))\n            \n        R_loico_star, lambda_loico_star = select_optimal_lambda(lambdas, loico_risks)\n        \n        # 5. Overfitting Detection\n        overfit_detected = (lambda_lono_star == 0.0) and (lambda_loico_star > 0.0)\n        \n        return [R_lono_star, R_loico_star, lambda_lono_star, lambda_loico_star, overfit_detected]\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (0.20, 123),  # Case 1\n        (0.00, 456),  # Case 2\n        (2.00, 789),  # Case 3\n    ]\n\n    results = []\n    for sigma, seed in test_cases:\n        case_result = run_case(sigma, seed)\n        results.append(case_result)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_list in results:\n        str_list = list(map(str, res_list))\n        formatted_results.append(f\"[{','.join(str_list)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3610428"}, {"introduction": "不确定性量化不仅是关于分析现有模型的不确定性，更是一个能主动指导未来研究的强大工具。在确定了模型的关键不确定性来源之后，下一个合乎逻辑的问题是：我们应该进行哪些新的实验才能最有效地减少这些不确定性？这个练习 [@problem_id:3610361] 介绍了最优实验设计的概念，特别是 D-最优准则。您将学习如何使用费雪信息矩阵（Fisher Information Matrix, FIM）来量化一个实验对模型参数所能提供的信息量，并通过最大化其行列式来选择一组最优的测量方案，从而以最经济的方式获取最有价值的数据。", "problem": "考虑一个用于核观测量的线性化能量密度泛函 (EDF) 模型，其中，原子核 $i$ 的观测量对小参数扰动的响应写为 $y_i(\\theta) \\approx y_i(\\theta_0) + \\mathbf{x}_i^{\\top}(\\theta - \\theta_0)$，其中 $\\theta \\in \\mathbb{R}^p$ 表示模型参数，$\\mathbf{x}_i \\in \\mathbb{R}^p$ 是在 $\\theta_0$ 处计算的雅可比行向量。假设独立的观测噪声为高斯噪声 $n_i \\sim \\mathcal{N}(0,\\sigma_i^2)$，因此测量到的观测量满足 $y_i^{\\text{obs}} = y_i(\\theta) + n_i$。对于一个设计（选定的原子核集合）$\\mathcal{D}$，在此线性化高斯模型下的费雪信息矩阵 (FIM) 定义为\n$$\nI(\\theta;\\mathcal{D}) = \\sum_{i \\in \\mathcal{D}} \\frac{1}{\\sigma_i^2} \\mathbf{x}_i \\mathbf{x}_i^{\\top}.\n$$\nD-最优准则旨在最大化费雪信息矩阵的行列式，即\n$$\n\\max_{\\mathcal{D} \\subseteq \\mathcal{S},\\, |\\mathcal{D}|=K} \\det\\left(I(\\theta;\\mathcal{D})\\right),\n$$\n其中 $\\mathcal{S}$ 是候选原子核集合，而 $K$ 是选择预算。在本问题中，您将实现一个穷举搜索，为指定的候选集合和预算计算 D-最优设计。\n\n使用以下包含8个原子核的候选集合 $\\mathcal{S}$，索引从0到7，其质子数为 $Z$，中子数为 $N$，质量数为 $A = Z + N$：\n- 索引 0: $^{16}\\text{O}$，其中 $(Z,N,A) = (8,8,16)$。\n- 索引 1: $^{40}\\text{Ca}$，其中 $(Z,N,A) = (20,20,40)$。\n- 索引 2: $^{48}\\text{Ca}$，其中 $(Z,N,A) = (20,28,48)$。\n- 索引 3: $^{56}\\text{Fe}$，其中 $(Z,N,A) = (26,30,56)$。\n- 索引 4: $^{90}\\text{Zr}$，其中 $(Z,N,A) = (40,50,90)$。\n- 索引 5: $^{120}\\text{Sn}$，其中 $(Z,N,A) = (50,70,120)$。\n- 索引 6: $^{132}\\text{Sn}$，其中 $(Z,N,A) = (50,82,132)$。\n- 索引 7: $^{208}\\text{Pb}$，其中 $(Z,N,A) = (82,126,208)$。\n\n设参数维度为 $p=4$，将原子核 $i$ 的雅可比行向量 $\\mathbf{x}_i$ 定义为无量纲的特征向量\n$$\n\\mathbf{x}_i = \\begin{bmatrix}\n1 \\\\\nA_i^{-1/3} \\\\\n\\delta_i \\\\\nA_i^{-1}\n\\end{bmatrix}, \\quad \\delta_i = \\frac{N_i - Z_i}{A_i}.\n$$\n根据构造，$\\mathbf{x}_i$ 中的所有量都是无量纲的。因此，费雪信息矩阵 $I(\\theta;\\mathcal{D})$ 是无量纲的，需要报告的行列式 $\\det(I)$ 也是无量纲的。为保证数值稳定性，通过计算 $I$ 的特征值的乘积来计算 $\\det(I)$，其中小于阈值 $\\epsilon$ 的特征值被设置为 $0$：\n$$\n\\det(I) = \\prod_{j=1}^{p} \\max(\\lambda_j, \\epsilon), \\quad \\epsilon = 10^{-14}.\n$$\n如果 $|\\mathcal{D}|  p$，则 $I$ 是秩亏的，根据此规则，行列式应报告为 $0$。当多个设计在容差 $\\tau = 10^{-12}$ 内获得相同的行列式值时，通过选择字典序最小的索引列表来打破平局。\n\n实现一个程序，为以下测试套件计算 D-最优设计和相应的行列式：\n- 测试用例 1：选择预算 $K=4$，且对于所有 $i \\in \\{0,1,\\dots,7\\}$ 具有同方差 $\\sigma_i^2 = 1$。\n- 测试用例 2：选择预算 $K=5$，且具有由下式定义的异方差 $\\sigma_i^2$\n$$\n\\sigma_i^2 = \\begin{cases}\n0.25  \\text{if } i \\in \\{0,1,2,6,7\\}, \\\\\n1  \\text{otherwise,}\n\\end{cases}\n$$\n因此，在该集合中，双幻核选项的精度更高（方差更低）。\n- 测试用例 3：选择预算 $K=3$，且对于所有 $i \\in \\{0,1,\\dots,7\\}$ 具有同方差 $\\sigma_i^2 = 1$。\n\n您的程序必须为每个测试用例穷举所有 $\\binom{8}{K}$ 种组合，为每个组合计算费雪信息矩阵，通过带有阈值 $\\epsilon = 10^{-14}$ 的特征值乘积规则评估行列式，选择能最大化行列式的组合（按指定的平局打破容差 $\\tau = 10^{-12}$），并为每个测试用例返回所选索引和行列式。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个双元素列表，其中第一个元素是所选索引的列表（按升序排列，从零开始），第二个元素是浮点数形式的行列式值。例如，输出必须采用 $[[\\text{indices}_1,\\det_1],[\\text{indices}_2,\\det_2],[\\text{indices}_3,\\det_3]]$ 的形式。所有输出都是无量纲的。", "solution": "所提出的问题是计算物理学中一个适定性良好的练习，具体涉及用于核能量密度泛函 (EDF) 模型不确定性量化的 D-最优实验设计。任务是确定一个用于测量的原子核最优子集，该子集将最大程度地约束模型参数。这将通过最大化费雪信息矩阵 (FIM) 的行列式来完成，这是最优设计理论中的一种标准方法。\n\n该问题的基础是一个关于核观测量 $y_i$ 的线性化模型，该观测量依赖于一组模型参数 $\\theta \\in \\mathbb{R}^p$。该模型由下式给出\n$$\ny_i(\\theta) \\approx y_i(\\theta_0) + \\mathbf{x}_i^{\\top}(\\theta - \\theta_0)\n$$\n其中 $\\mathbf{x}_i$ 是观测量相对于参数的雅可比矩阵（梯度），在参考参数点 $\\theta_0$ 处计算。我们假设实验测量值 $y_i^{\\text{obs}}$ 受到独立的、零均值的高斯噪声 $n_i \\sim \\mathcal{N}(0, \\sigma_i^2)$ 的影响。\n\n在这些假设下，对于给定的一组实验（一个设计）$\\mathcal{D}$，其费雪信息矩阵为\n$$\nI(\\theta;\\mathcal{D}) = \\sum_{i \\in \\mathcal{D}} \\frac{1}{\\sigma_i^2} \\mathbf{x}_i \\mathbf{x}_i^{\\top}\n$$\nFIM 是估计参数协方差矩阵的逆矩阵，$I^{-1} = \\text{Cov}(\\hat{\\theta})$。D-最优性准则旨在最小化参数的置信椭球体积，这等同于最大化 FIM 的行列式 $\\det(I)$。因此，优化问题是：\n$$\n\\max_{\\mathcal{D} \\subseteq \\mathcal{S}, \\, |\\mathcal{D}|=K} \\det\\left(I(\\theta;\\mathcal{D})\\right)\n$$\n其中 $\\mathcal{S}$ 是一个包含 8 个原子核的候选集合，而 $K$ 是实验预算（要选择的原子核数量）。\n\n该问题指定了参数维度 $p=4$，并根据每个原子核 $i$ 的质子数 $Z_i$、中子数 $N_i$ 和质量数 $A_i = Z_i + N_i$ 定义了雅可比行向量 $\\mathbf{x}_i$：\n$$\n\\mathbf{x}_i = \\begin{bmatrix}\n1 \\\\\nA_i^{-1/3} \\\\\n\\delta_i \\\\\nA_i^{-1}\n\\end{bmatrix}, \\quad \\text{with} \\quad \\delta_i = \\frac{N_i - Z_i}{A_i}\n$$\n该向量的分量代表了具有物理动机的依赖关系：一个与体积性质相关的常数项，一个与 $A_i^{-1/3}$ 成正比的项（作为表面效应的代理），一个同位旋不对称项 $\\delta_i$，以及一个与 $A_i^{-1}$ 成正比的高阶项或曲率项。\n\n解决此优化问题的算法方法是穷举搜索。鉴于候选池的大小很小 ($|\\mathcal{S}|=8$)，对于给定的预算 $K \\in \\{3, 4, 5\\}$，枚举所有 $\\binom{8}{K}$ 种可能的设计在计算上是可行的。\n\n每个测试用例的流程如下：\n1.  枚举所有大小为 $K$ 的来自 $\\{0, 1, \\dots, 7\\}$ 的索引子集（设计）$\\mathcal{D}$。\n2.  对于每个设计 $\\mathcal{D}$：\n    a.  检查秩条件。FIM 是一个 $p \\times p$ 矩阵，是 $|\\mathcal{D}|$ 个秩为1的矩阵之和。如果 $|\\mathcal{D}|  p$，则 FIM 是奇异的，其行列式恰好为 $0$。问题规定在这种情况下行列式应报告为 $0$。对于 $K=3$ 和 $p=4$ 的测试用例，所有设计都将导致行列式为 $0$。\n    b.  如果 $|\\mathcal{D}| \\ge p$，通过初始化一个零矩阵并对每个选定原子核的贡献求和来构建 $4 \\times 4$ 的 FIM $I(\\mathcal{D})$：\n        $$\n        I(\\mathcal{D}) = \\sum_{i \\in \\mathcal{D}} w_i \\mathbf{x}_i \\mathbf{x}_i^{\\top}\n        $$\n        其中权重是精度，$w_i = 1/\\sigma_i^2$。\n    c.  计算 FIM 的行列式。为确保数值稳定性，问题指定了一个特定规则。首先，找到对称半正定 FIM 的特征值 $\\{\\lambda_j\\}_{j=1}^p$。然后，通过将这些特征值相乘来计算行列式，并由一个小的阈值 $\\epsilon = 10^{-14}$ 设置下限：\n        $$\n        \\det(I) = \\prod_{j=1}^{p} \\max(\\lambda_j, \\epsilon)\n        $$\n        这种正则化防止了行列式在应为正值时因浮点不精确而变成无法表示的极小数或零。\n3.  将计算出的行列式 $\\det(\\mathcal{D})$ 与迄今为止找到的最大行列式 $\\det_{\\max}$ 进行比较。指定了平局打破规则。如果多个设计的行列式在 $\\tau = 10^{-12}$ 的容差内相等，则选择具有字典序最小索引列表的设计。这可以通过按字典序处理设计（这是 Python `itertools.combinations` 的默认行为）来处理，并且仅当发现新的行列式严格大于当前最大值加上容差时才更新最优设计，即 $\\det(\\mathcal{D}_{\\text{new}}) > \\det_{\\max} + \\tau$。\n\n此过程应用于三个测试用例，它们在选择预算 $K$ 和噪声方差假设 $\\sigma_i^2$ 上有所不同。每个用例的最终输出将是字典序最小的最优设计及其对应的行列式。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport sys\n\ndef solve():\n    \"\"\"\n    Solves for the D-optimal experimental design for a linearized nuclear EDF model.\n\n    The program exhaustively searches over all combinations of nuclei to find the\n    subset that maximizes the determinant of the Fisher Information Matrix (FIM).\n    \"\"\"\n\n    # --- Problem Constants and Definitions ---\n\n    # Parameter dimension\n    P_DIM = 4\n    # Determinant computation threshold\n    EPSILON = 1e-14\n    # Tie-breaking tolerance\n    TAU = 1e-12\n\n    # Candidate set of nuclei S, indexed 0-7\n    # Data: (Z, N)\n    nuclei_data = [\n        (8, 8),     # 0: 16O\n        (20, 20),   # 1: 40Ca\n        (20, 28),   # 2: 48Ca\n        (26, 30),   # 3: 56Fe\n        (40, 50),   # 4: 90Zr\n        (50, 70),   # 5: 120Sn\n        (50, 82),   # 6: 132Sn\n        (82, 126),  # 7: 208Pb\n    ]\n\n    # Pre-compute Jacobian rows (feature vectors) x_i for all nuclei\n    x_vectors = []\n    for z, n in nuclei_data:\n        a = float(z + n)\n        delta = (n - z) / a\n        x_i = np.array([\n            1.0,\n            a**(-1.0/3.0),\n            delta,\n            a**(-1.0)\n        ])\n        x_vectors.append(x_i)\n\n    # --- Test Cases ---\n\n    test_cases = [\n        {\n            \"K\": 4,\n            \"variances\": np.ones(8)\n        },\n        {\n            \"K\": 5,\n            \"variances\": np.array([0.25 if i in {0, 1, 2, 6, 7} else 1.0 for i in range(8)])\n        },\n        {\n            \"K\": 3,\n            \"variances\": np.ones(8)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        K = case[\"K\"]\n        variances = case[\"variances\"]\n        weights = 1.0 / variances\n\n        best_design = []\n        max_det = -1.0\n\n        # Generate all combinations (designs) of size K\n        designs = combinations(range(len(nuclei_data)), K)\n\n        for design in designs:\n            current_det = 0.0\n            \n            # If K  p, the FIM is rank-deficient and det(I) is 0.\n            if K  P_DIM:\n                current_det = 0.0\n            else:\n                # Construct the Fisher Information Matrix (FIM)\n                fim = np.zeros((P_DIM, P_DIM))\n                for i in design:\n                    x_i = x_vectors[i]\n                    w_i = weights[i]\n                    # Add rank-1 update for nucleus i\n                    fim += w_i * np.outer(x_i, x_i)\n\n                # Compute eigenvalues. Use eigvalsh for symmetric matrices.\n                eigenvalues = np.linalg.eigvalsh(fim)\n                \n                # Compute determinant using the specified rule\n                # det(I) = product(max(lambda_j, epsilon))\n                stable_eigs = np.maximum(eigenvalues, EPSILON)\n                current_det = np.prod(stable_eigs)\n\n            # Update best design found so far.\n            # Update if the new determinant is larger than the current max by the tolerance TAU.\n            # This handles tie-breaking implicitly, as combinations are generated in\n            # lexicographical order. The first one to achieve a certain max_det value\n            # will be kept.\n            if current_det > max_det + TAU:\n                max_det = current_det\n                best_design = design\n\n        # Store the result for this test case\n        all_results.append([list(best_design), max_det])\n\n    # --- Format and Print Final Output ---\n    \n    # Manually construct the output string to match the exact format requirement,\n    # specifically with no spaces inside the list brackets.\n    result_strings = []\n    for res in all_results:\n        indices, det_val = res\n        # Convert the list of indices to a comma-separated string `[i1,i2,...]`\n        indices_str = f\"[{','.join(map(str, indices))}]\"\n        # Combine into the `[[indices],det]` format for one test case\n        result_strings.append(f\"[{indices_str},{det_val}]\")\n    \n    # Join all test case results and enclose in the outermost brackets\n    final_output_str = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n\n```", "id": "3610361"}]}