{"hands_on_practices": [{"introduction": "这个实践是构建势能面的基础。我们将从一个唯象模型出发，一步步地构建一个势能面。这个练习将演示如何将集体形变、对关联以及单粒子效应（如阻塞效应和准粒子排列）等核心概念转化为一个可计算的模型[@problem_id:3580482]。通过这个过程，你将掌握在形变参数空间 $(\\beta, \\gamma)$ 中，如何量化分析原子核的能量极小点、位垒高度和三轴不对称性等关键特性。", "problem": "要求您构建并分析一个简化的、但具有物理动机的奇A核势能面模型。该势能面位于集体四极形变平面内，由形变大小 $ \\beta $ 和三轴度角 $ \\gamma $ 参数化。您的程序必须实现一个总能量泛函 $ E(\\beta,\\gamma) $，它由集体偶偶核基线、奇质量核的阻塞惩罚以及准粒子排列（摇摆）贡献三部分组成，具体规定如下。总能量必须在 $(\\beta,\\gamma)$ 平面上的一个固定网格上进行计算，并且必须提取势能面的特定定量特征。\n\n定义和模型说明：\n- 集体偶偶核基线能量是四极不变量的一个 Landau 型展开，\n  $$ E_{\\mathrm{coll}}(\\beta,\\gamma) = A\\,\\beta^{2} + B\\,\\beta^{3}\\cos(3\\gamma) + C\\,\\beta^{4} + D\\,\\beta^{6}, $$\n  其中 $ A $、$ B $、$ C $ 和 $ D $ 是实数参数，且 $ A>0 $、$ C>0 $ 和 $ D\\ge 0 $ 以确保在较大 $ \\beta $ 时的稳定性。对 $ \\gamma $ 的依赖性通过标准不变量 $ \\cos(3\\gamma) $ 体现。\n- 奇质量核的阻塞惩罚被建模为由于对关联减弱而导致的各向同性能量增加，\n  $$ \\delta E_{\\mathrm{block}}(\\beta) = P_{0} + P_{2}\\,\\beta^{2}, $$\n  其中 $ P_{0}\\ge 0 $ 且 $ P_{2}\\ge 0 $。\n- 准粒子排列（摇摆）贡献在 $ \\beta $ 的领头阶上被建模为\n  $$ E_{\\mathrm{align}}(\\beta,\\gamma) = -K\\,\\beta\\,\\cos\\!\\big(3(\\gamma-\\gamma_{0})\\big), $$\n  其中 $ K\\ge 0 $ 设定了排列强度，$ \\gamma_{0}\\in[0,\\pi/3] $ 是一个相位，用于选择 $(\\beta,\\gamma)$ 平面中的排列主轴。\n\n总能量为\n$$ E(\\beta,\\gamma) = E_{\\mathrm{coll}}(\\beta,\\gamma) + \\delta E_{\\mathrm{block}}(\\beta) + E_{\\mathrm{align}}(\\beta,\\gamma), $$\n单位为兆电子伏特 (MeV)。形状变量满足 $ \\beta\\in[0,\\beta_{\\max}] $ 和 $ \\gamma\\in[0,\\pi/3] $。所有内部计算必须使用弧度表示的 $ \\gamma $。最终答案中报告的任何角度都必须以度表示。\n\n网格、单位和数值任务：\n- 使用一个均匀的张量积网格，其中 $ \\beta $ 在 $ [0,\\beta_{\\max}] $（$ \\beta_{\\max} = 0.6 $）上取 $ N_{\\beta} = 601 $ 个线性等距分布的点，$ \\gamma $ 在 $ [0,\\pi/3] $ 上取 $ N_{\\gamma} = 361 $ 个线性等距分布的点。网格上的角度以弧度为单位。\n- 对于测试套件中的每组参数，计算：\n  $1.$ 整个网格上的全局最小能量 $ E_{\\min} $（单位 MeV）以及该最小值点对应的角度 $ \\gamma_{\\min} $（以度报告）。\n  $2.$ 长轴位垒高度 $ B_{\\mathrm{prol}} $（单位 MeV），定义如下：限制在长轴 $ \\gamma=0 $ 上，构建一维函数 $ E_{\\mathrm{prol}}(\\beta)=E(\\beta,0) $，找出 $ E_{\\mathrm{prol}}(\\beta) $ 在网格上达到其最小值的索引 $ i^{\\star} $，然后将位垒定义为\n  $$ B_{\\mathrm{prol}} = \\max_{0\\le i\\le i^{\\star}} E_{\\mathrm{prol}}(\\beta_{i}) \\;-\\; E_{\\mathrm{prol}}(\\beta_{i^{\\star}}). $$\n  如果 $ i^{\\star}=0 $，则取 $ B_{\\mathrm{prol}} = 0 $。\n  $3.$ 在长轴最小值处的形变 $ \\beta_{i^{\\star}} $ 上的三轴各向异性振幅 $ \\mathcal{A} $（单位 MeV），定义为\n  $$ \\mathcal{A} = \\max_{\\gamma} E(\\beta_{i^{\\star}},\\gamma) \\;-\\; \\min_{\\gamma} E(\\beta_{i^{\\star}},\\gamma). $$\n\n测试套件：\n实现该模型并为以下三组参数集计算所要求的量。所有能量单位为 MeV，$ \\gamma_{0} $ 的角度单位为弧度。\n- 情况1（偶偶核基线，无阻塞，无排列）：$ A=5.0 $, $ B=-12.0 $, $ C=20.0 $, $ D=50.0 $, $ P_{0}=0.0 $, $ P_{2}=0.0 $, $ K=0.0 $, $ \\gamma_{0}=0.0 $。\n- 情况2（仅阻塞）：$ A=5.0 $, $ B=-12.0 $, $ C=20.0 $, $ D=50.0 $, $ P_{0}=0.8 $, $ P_{2}=2.5 $, $ K=0.0 $, $ \\gamma_{0}=0.0 $。\n- 情况3（有阻塞和排列）：$ A=5.0 $, $ B=-12.0 $, $ C=20.0 $, $ D=50.0 $, $ P_{0}=0.8 $, $ P_{2}=2.5 $, $ K=2.0 $, $ \\gamma_{0}=0.17453292519943 $。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为列表的列表：\n  对于每个情况，输出列表 $[E_{\\min}, \\gamma_{\\min}^{(\\mathrm{deg})}, B_{\\mathrm{prol}}, \\mathcal{A}]$，其中 $ E_{\\min} $、$ B_{\\mathrm{prol}} $ 和 $ \\mathcal{A} $ 是单位为 MeV 的浮点数，$ \\gamma_{\\min}^{(\\mathrm{deg})} $ 是以度为单位的角度。每个情况的所有四个数字都必须四舍五入到6位小数。\n- 因此，最终输出行必须看起来像\n  $$ \\big[ [x_{1},y_{1},z_{1},w_{1}], [x_{2},y_{2},z_{2},w_{2}], [x_{3},y_{3},z_{3},w_{3}] \\big], $$\n  其中每个 $ x_{k} $、$ y_{k} $、$ z_{k} $、$ w_{k} $ 是一个小数点后有6位的小数表示，并且文本字符串中不含单位。角度以十进制的小数形式表示（单位为度），能量以十进制的小数形式表示（单位为 MeV）。", "solution": "用户提供了一个计算核物理领域中有效且适定的问题。我将继续提供完整的解决方案。\n\n该问题要求为奇A核构建和分析一个势能面（PES），表示为 $E(\\beta, \\gamma)$。该势能面定义在两个集体四极形变坐标的平面上：形变大小 $\\beta$ 和三轴度角 $\\gamma$。总能量泛函是三个分量的总和：偶偶核芯的集体势 $E_{\\mathrm{coll}}(\\beta, \\gamma)$；奇核子的阻塞惩罚 $\\delta E_{\\mathrm{block}}(\\beta)$；以及准粒子排列贡献 $E_{\\mathrm{align}}(\\beta, \\gamma)$。\n\n总能量由下式给出：\n$$ E(\\beta,\\gamma) = E_{\\mathrm{coll}}(\\beta,\\gamma) + \\delta E_{\\mathrm{block}}(\\beta) + E_{\\mathrm{align}}(\\beta,\\gamma) $$\n各分量具体为：\n\\begin{align*}\nE_{\\mathrm{coll}}(\\beta,\\gamma) = A\\,\\beta^{2} + B\\,\\beta^{3}\\cos(3\\gamma) + C\\,\\beta^{4} + D\\,\\beta^{6} \\\\\n\\delta E_{\\mathrm{block}}(\\beta) = P_{0} + P_{2}\\,\\beta^{2} \\\\\nE_{\\mathrm{align}}(\\beta,\\gamma) = -K\\,\\beta\\,\\cos\\!\\big(3(\\gamma-\\gamma_{0})\\big)\n\\end{align*}\n通过组合这些项，完整的能量泛函可以写为：\n$$ E(\\beta,\\gamma) = P_{0} -K\\,\\beta\\,\\cos\\!\\big(3(\\gamma-\\gamma_{0})\\big) + (A + P_{2})\\,\\beta^{2} + B\\,\\beta^{3}\\cos(3\\gamma) + C\\,\\beta^{4} + D\\,\\beta^{6} $$\n\n求解方法包括以下步骤：\n1.  **网格离散化**：将连续域 $(\\beta, \\gamma) \\in [0, 0.6] \\times [0, \\pi/3]$ 离散化为一个均匀的张量积网格。我们定义一个 $\\beta$ 值的向量 $\\boldsymbol{\\beta} = \\{\\beta_i\\}$（$i=0, \\dots, N_{\\beta}-1$）和一个 $\\gamma$ 值的向量 $\\boldsymbol{\\gamma} = \\{\\gamma_j\\}$（$j=0, \\dots, N_{\\gamma}-1$）。问题指定 $N_{\\beta} = 601$ 和 $N_{\\gamma} = 361$。\n2.  **势能面计算**：在网格上的每个点 $(i,j)$ 计算总能量 $E(\\beta_i, \\gamma_j)$。通过为 $\\beta$ 和 $\\gamma$ 创建二维网格数组（我们表示为 $\\mathbf{B}$ 和 $\\mathbf{\\Gamma}$），并使用向量化数值库可以高效地完成此任务。然后逐元素计算能量 $E(\\mathbf{B}, \\mathbf{\\Gamma})$，得到一个二维数组 $\\mathbf{E}$，其中 $\\mathbf{E}_{ij} = E(\\beta_i, \\gamma_j)$。\n3.  **可观测量提取**：对于给定的参数集，一旦计算出离散的势能面 $\\mathbf{E}$，就提取所要求的物理量。\n\n    -   **全局最小值（$E_{\\min}$, $\\gamma_{\\min}$）**：通过取整个二维数组 $\\mathbf{E}$ 中的最小值来找到全局最小能量 $E_{\\min}$。定位此最小元素的索引 $(i_{\\min}, j_{\\min})$。对应的三轴度角为 $\\gamma_{\\min} = \\gamma_{j_{\\min}}$，然后将其从弧度转换为度进行报告。\n\n    -   **长轴位垒高度（$B_{\\mathrm{prol}}$）**：该量沿长轴（$\\gamma=0$）定义。我们首先提取一维能量剖面 $E_{\\mathrm{prol}}(\\beta_i) = E(\\beta_i, 0)$，它对应于矩阵 $\\mathbf{E}$ 的第一列。然后我们找到该一维剖面达到其最小值 $E_{\\mathrm{prol}}(\\beta_{i^{\\star}})$ 时的索引 $i^{\\star}$。位垒高度是从 $\\beta=0$ 到 $\\beta=\\beta_{i^{\\star}}$ 路径上遇到的最大能量与在 $\\beta_{i^{\\star}}$ 处的最小能量之差。\n        $$ B_{\\mathrm{prol}} = \\left( \\max_{0 \\le i \\le i^{\\star}} E_{\\mathrm{prol}}(\\beta_i) \\right) - E_{\\mathrm{prol}}(\\beta_{i^{\\star}}) $$\n        一个特殊条件规定，如果最小值出现在 $\\beta=0$ 处（即 $i^{\\star}=0$），则位垒为零。\n\n    -   **三轴各向异性（$\\mathcal{A}$）**：此量衡量在特定形变下能量沿 $\\gamma$ 方向的变化。该形变选择为上一步中找到的长轴最小值处的形变 $\\beta_{i^{\\star}}$。我们提取网格上所有 $\\gamma_j$ 对应的一维能量剖面 $E(\\beta_{i^{\\star}}, \\gamma_j)$。这对应于矩阵 $\\mathbf{E}$ 中索引为 $i^{\\star}$ 的行。各向异性 $\\mathcal{A}$ 是此一维切片中最大值和最小值之间的差。\n        $$ \\mathcal{A} = \\max_j E(\\beta_{i^{\\star}}, \\gamma_j) - \\min_j E(\\beta_{i^{\\star}}, \\gamma_j) $$\n\n该过程在一个程序中实现，该程序遍历三个指定的参数集，为每种情况计算并存储这四个可观测量。然后将最终输出格式化为列表的列表，所有数值按要求四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_pes_observables(params, beta_grid, gamma_grid):\n    \"\"\"\n    Computes observables from the potential energy surface for a single parameter set.\n    \"\"\"\n    A, B, C, D, P0, P2, K, g0 = params\n    \n    # Create 2D meshgrid for vectorized computation.\n    # BETA[i, j] = beta_grid[i], GAMMA[i, j] = gamma_grid[j]\n    BETA, GAMMA = np.meshgrid(beta_grid, gamma_grid, indexing='ij')\n\n    # Calculate the three energy components\n    E_coll = (A * BETA**2 \n              + B * BETA**3 * np.cos(3 * GAMMA) \n              + C * BETA**4\n              + D * BETA**6)\n    \n    delta_E_block = P0 + P2 * BETA**2\n    \n    E_align = -K * BETA * np.cos(3 * (GAMMA - g0))\n    \n    # Total energy surface\n    E_surface = E_coll + delta_E_block + E_align\n\n    # 1. Find global minimum energy and corresponding gamma\n    E_min = np.min(E_surface)\n    min_idx_flat = np.argmin(E_surface)\n    i_min, j_min = np.unravel_index(min_idx_flat, E_surface.shape)\n    gamma_min_rad = gamma_grid[j_min]\n    gamma_min_deg = np.rad2deg(gamma_min_rad)\n\n    # 2. Calculate prolate barrier height B_prol\n    # E_prol is the slice at gamma = 0, which is the first column of E_surface\n    E_prol = E_surface[:, 0]\n    i_star = np.argmin(E_prol)\n    \n    B_prol = 0.0\n    if i_star > 0:\n        E_prol_min = E_prol[i_star]\n        # Barrier is max energy on the path from beta=0 to beta=beta_i_star\n        E_max_on_path = np.max(E_prol[:i_star + 1])\n        B_prol = E_max_on_path - E_prol_min\n\n    # 3. Calculate triaxial anisotropy amplitude A at beta_i_star\n    # E_at_beta_istar is the slice at beta = beta_i_star, which is a row of E_surface\n    E_at_beta_istar = E_surface[i_star, :]\n    A_anisotropy = np.max(E_at_beta_istar) - np.min(E_at_beta_istar)\n\n    return E_min, gamma_min_deg, B_prol, A_anisotropy\n\ndef solve():\n    \"\"\"\n    Main function to drive the computation for all test cases and print the final result.\n    \"\"\"\n    # Define the grid\n    beta_max = 0.6\n    N_beta = 601\n    N_gamma = 361\n    beta_grid = np.linspace(0, beta_max, N_beta)\n    gamma_grid = np.linspace(0, np.pi / 3, N_gamma)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (even-even baseline)\n        (5.0, -12.0, 20.0, 50.0, 0.0, 0.0, 0.0, 0.0),\n        # Case 2 (blocking only)\n        (5.0, -12.0, 20.0, 50.0, 0.8, 2.5, 0.0, 0.0),\n        # Case 3 (blocking with alignment)\n        (5.0, -12.0, 20.0, 50.0, 0.8, 2.5, 2.0, 0.17453292519943),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_tuple = compute_pes_observables(params, beta_grid, gamma_grid)\n        all_results.append(list(result_tuple))\n\n    # Format the final output string as a list of lists with 6 decimal places.\n    formatted_cases = []\n    for case_results in all_results:\n        # Format each number in the list to a string with 6 decimal places\n        formatted_nums = [f\"{num:.6f}\" for num in case_results]\n        # Create the string representation of the inner list\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    # Create the final string representation of the list of lists\n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3580482"}, {"introduction": "实际的计算物理研究通常在离散的网格上产生势能面数据。本练习将介绍一系列关键的“后处理”技术，用于分析这些数据并从中提取物理信息[@problem_id:3580491]。你将学习如何通过插值获得网格之外的能量值，如何通过平滑处理来消除数值噪声，以及如何找到对应于核裂变等重要物理过程的最优路径。", "problem": "您将构建、分析和优化一个人造二维核势能面（PES）上的路径，以模拟计算核物理中涉及势能面插值、平滑和路径优化的任务。工作将基于无量纲的集体坐标 $q_1$ 和 $q_2$，例如，它们可以代表四极伸长和三轴性。能量必须以兆电子伏特（MeV）表示。所有角度（如果有）都是抽象的，不会出现在本问题中。您的程序必须是自包含的，不接受任何输入，并完全按照末尾指定的方式打印单行输出。\n\n从以下在域 $\\mathcal{D} = \\{(q_1,q_2) \\mid q_1 \\in [-1.0, 1.0], q_2 \\in [-0.6, 0.6]\\}$ 上的矩形网格上定义的、物理上合理的人造PES开始：\n$$\nV(q_1,q_2) = A\\,(q_1^2 - q_0^2)^2 + B\\,(1 + \\alpha\\,q_1)\\,q_2^2 + D_1 \\exp\\!\\left(-\\frac{(q_1 - s_1)^2}{2 w_x^2} - \\frac{q_2^2}{2 w_y^2}\\right) + D_2 \\exp\\!\\left(-\\frac{(q_1 - s_2)^2}{2 w_{2x}^2} - \\frac{(q_2 - y_2)^2}{2 w_{2y}^2}\\right),\n$$\n其中常数为 $A=12.0$ (MeV)，$q_0=0.7$，$B=3.5$ (MeV)，$\\alpha=0.6$，$D_1=1.8$ (MeV)，$s_1=0.0$，$w_x=0.35$，$w_y=0.35$，$D_2=-0.5$ (MeV)，$s_2=0.1$，$y_2=0.25$，$w_{2x}=0.25$，$w_{2y}=0.15$。使用一个均匀网格，其中 $q_1$ 从 $-1.0$ 到 $1.0$ 采样 $41$ 个点，$q_2$ 从 $-0.6$ 到 $0.6$ 采样 $25$ 个点。在此网格上评估 $V$ 以获得离散的PES（单位为MeV）。\n\n需要在此PES上实现的任务：\n\n1) 双三次插值：构建离散PES的双三次插值，并评估在点 $p_{\\mathrm{int}} = (q_1,q_2)=(0.0, 0.25)$ 处的插值能量。报告此能量（单位为MeV）。\n\n2) 高斯平滑：定义一个平滑后的PES $V_{\\sigma}$，作为离散PES与一个各向异性高斯核的卷积。该高斯核在 $q_1$ 和 $q_2$ 坐标方向上的标准差分别为 $(\\sigma_{q_1}, \\sigma_{q_2})$。高斯平滑必须直接应用于网格数据，其中标准差以 $q_1$ 和 $q_2$ 的物理坐标单位解释（在应用滤波器之前，使用网格间距将其转换为像素单位）。使用适合有限网格的反射或最近邻边界条件。\n\n3) 路径优化：设 $\\Gamma$ 为 $\\mathcal{D}$ 中从起点 $q^{\\mathrm{start}} = (-q_0, 0.0)$ 到终点 $q^{\\mathrm{end}} = (q_0, 0.0)$ 的任意连续路径。定义非负成本密度\n$$\nC(q_1,q_2) = V_{\\sigma}(q_1,q_2) - \\min_{\\mathcal{D}} V_{\\sigma} + \\varepsilon,\n$$\n其中 $\\varepsilon = 10^{-12}$ (MeV) 以确保严格为正。最优路径 $\\Gamma^\\star$ 最小化线积分\n$$\n\\mathcal{J}[\\Gamma] = \\int_{\\Gamma} C(q_1,q_2)\\, \\mathrm{d}\\ell,\n$$\n其中 $\\mathrm{d}\\ell$ 是 $(q_1,q_2)$ 平面中的欧几里得线元。通过将域在给定网格上离散化，并在诱导的具有8-邻域连接的加权图上计算最小线积分路径来近似此最优路径。使用等于沿边的成本密度的梯形法则乘以物理 $(q_1,q_2)$ 度量中的欧几里得边长的边权重：\n$$\nw_{u\\to v} = \\frac{C(u) + C(v)}{2}\\,\\Delta \\ell_{uv},\n$$\n其中 $\\Delta \\ell_{uv}$ 对于相邻网格点 $u$ 和 $v$ 之间的网格步长是 $\\sqrt{(\\Delta q_1)^2 + (\\Delta q_2)^2}$。计算出最优离散路径后，报告：\n- 总几何路径长度 $L$（沿路径的欧几里得步长 $\\Delta \\ell_{uv}$ 之和），以 $(q_1,q_2)$ 的坐标单位表示。\n- 势垒能量 $E_{\\max}$，定义为沿离散路径采样的未平滑PES $V$ 的最大值，单位为MeV。\n\n测试套件和输出：\n\n您必须评估三个测试用例，每个用例具有不同的各向异性高斯平滑，指定为 $(\\sigma_{q_1}, \\sigma_{q_2})$，单位为 $q_1$ 和 $q_2$ 的坐标单位：\n- 用例 1：$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.00, 0.00)$。\n- 用例 2：$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.08, 0.08)$。\n- 用例 3：$(\\sigma_{q_1}, \\sigma_{q_2}) = (0.15, 0.10)$。\n\n对于每个用例，计算并输出三元组 $[E_{\\mathrm{int}}, L, E_{\\max}]$，其中 $E_{\\mathrm{int}}$ 是在 $p_{\\mathrm{int}}$ 处的双三次插值能量，$L$ 是优化路径的长度，$E_{\\max}$ 是沿优化路径的势垒能量。能量单位必须是MeV，长度单位是无量纲的坐标单位。将每个浮点数四舍五入到六位小数。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含按用例顺序排列的三个三元组的逗号分隔列表，并用方括号括起来，不含空格。例如：\n\"[[Eint1,L1,Emax1],[Eint2,L2,Emax2],[Eint3,L3,Emax3]]\"\n所有数值条目必须是四舍五入到六位小数的浮点数，并以上述适当单位表示。不允许有其他输出。", "solution": "该问题要求构建和分析一个人造的二维核势能面（PES），然后优化该势能面上两点之间的路径。解决方案涉及一系列数值任务：网格求值、插值、图像处理（平滑）和基于图的路径寻找。整个过程针对三种不同的平滑场景执行。\n\n### 1. 势能面离散化\n\n先验的连续PES，记为 $V(q_1, q_2)$，是两个无量纲集体坐标 $q_1$ 和 $q_2$ 的函数。其解析形式由下式给出：\n$$\nV(q_1,q_2) = A\\,(q_1^2 - q_0^2)^2 + B\\,(1 + \\alpha\\,q_1)\\,q_2^2 + D_1 \\exp\\!\\left(-\\frac{(q_1 - s_1)^2}{2 w_x^2} - \\frac{q_2^2}{2 w_y^2}\\right) + D_2 \\exp\\!\\left(-\\frac{(q_1 - s_2)^2}{2 w_{2x}^2} - \\frac{(q_2 - y_2)^2}{2 w_{2y}^2}\\right)\n$$\n第一步是在指定的域 $\\mathcal{D} = \\{(q_1,q_2) \\mid q_1 \\in [-1.0, 1.0], q_2 \\in [-0.6, 0.6]\\}$ 上将此函数离散化。我们构建一个均匀网格，沿 $q_1$ 轴有 $N_{q_1}=41$ 个点，沿 $q_2$ 轴有 $N_{q_2}=25$ 个点。这得到的网格间距为 $\\Delta q_1 = (1.0 - (-1.0))/(41-1) = 0.05$ 和 $\\Delta q_2 = (0.6 - (-0.6))/(25-1) = 0.05$。函数 $V(q_1, q_2)$ 在此网格上的每个点 $(q_1, q_2)$ 进行求值，得到一个 $25 \\times 41$ 的能量值矩阵，我们将其表示为 $V_{\\mathrm{grid}}$。该矩阵是所有后续任务的基础数据集。\n\n### 2. 任务1：双三次插值\n\n目标是估计一个不一定在网格上的点的势能。双三次插值是实现此目的的标准方法，它将一个分段三次多项式曲面拟合到网格数据上，该曲面是连续的且具有连续的一阶偏导数。我们从离散的PES $V_{\\mathrm{grid}}$ 构建一个双三次插值器。这可以通过使用 `scipy.interpolate.RectBivariateSpline` 并设置样条次数 $k_x=3$ 和 $k_y=3$ 来完成。然后，在指定的点 $p_{\\mathrm{int}} = (0.0, 0.25)$ 对生成的插值函数进行求值，以找到能量 $E_{\\mathrm{int}}$。由于此任务与平滑参数无关，因此 $E_{\\mathrm{int}}$ 只计算一次，并用于所有三个测试用例。\n\n### 3. 任务2：各向异性高斯平滑\n\n为了研究表面粗糙度对路径优化的影响，需要对离散的PES进行平滑。平滑后的表面 $V_{\\sigma}$ 是通过将 $V_{\\mathrm{grid}}$ 与一个各向异性的二维高斯核进行卷积得到的。对于每个测试用例，核的标准差 $(\\sigma_{q_1}, \\sigma_{q_2})$ 以物理坐标单位给出。在应用卷积之前，必须将这些值转换为像素（或网格索引）单位：\n$$\n\\sigma_{\\mathrm{pix}, q_1} = \\frac{\\sigma_{q_1}}{\\Delta q_1}, \\quad \\sigma_{\\mathrm{pix}, q_2} = \\frac{\\sigma_{q_2}}{\\Delta q_2}\n$$\n卷积使用 `scipy.ndimage.gaussian_filter` 执行，并采用 `mode='reflect'` 边界条件来适当地处理有限网格的边缘。对三个测试用例中的每一个重复此过程，产生三个不同的平滑势能面。当 $(\\sigma_{q_1}, \\sigma_{q_2}) = (0.0, 0.0)$ 时，对应于不进行平滑，此时 $V_{\\sigma} = V$。\n\n### 4. 任务3：路径优化\n\n核心任务是找到从起点 $q^{\\mathrm{start}} = (-0.7, 0.0)$ 到终点 $q^{\\mathrm{end}} = (0.7, 0.0)$ 的最优路径 $\\Gamma^\\star$。该路径之所以是“最优的”，是因为它最小化了成本密度的线积分，即 $\\mathcal{J}[\\Gamma] = \\int_{\\Gamma} C(q_1,q_2)\\, \\mathrm{d}\\ell$。\n\n**a. 成本函数：**\n成本密度 $C(q_1, q_2)$ 从平滑后的势能 $V_{\\sigma}$ 推导得出。其定义为：\n$$\nC(q_1,q_2) = V_{\\sigma}(q_1,q_2) - \\min_{\\mathcal{D}} V_{\\sigma} + \\varepsilon\n$$\n这里，$\\min_{\\mathcal{D}} V_{\\sigma}$ 是域上平滑势能的全局最小值，而 $\\varepsilon = 10^{-12}$ MeV 是一个小的正常数，以确保成本严格为正，这是许多最短路径算法的要求。\n\n**b. 图的构建和边权重：**\n连续优化问题通过离散图上的最短路径问题来近似。图的节点对应于我们 $25 \\times 41$ 网格上的点。边将每个节点与其8个最近邻（摩尔邻域）连接起来。连接两个相邻节点 $u$ 和 $v$ 的边的权重，由该段上成本密度的线积分的梯形近似定义：\n$$\nw_{u\\to v} = \\frac{C(u) + C(v)}{2}\\,\\Delta \\ell_{uv}\n$$\n其中 $C(u)$ 和 $C(v)$ 是节点处的成本值，$\\Delta \\ell_{uv}$ 是它们在 $(q_1,q_2)$ 坐标平面中的欧几里得距离。对于轴向邻居，$\\Delta \\ell_{uv}$ 是 $\\Delta q_1$ 或 $\\Delta q_2$，而对于对角线邻居，它是 $\\sqrt{(\\Delta q_1)^2 + (\\Delta q_2)^2}$。\n\n**c. 路径寻找：**\n构建加权图后，采用Dijkstra算法来找到从对应于 $q^{\\mathrm{start}}$ 的节点到对应于 $q^{\\mathrm{end}}$ 的节点的具有最小累积权重的路径。`scipy.sparse.csgraph.dijkstra` 函数非常适合此任务，它操作图的稀疏矩阵表示以提高效率。\n\n**d. 路径分析：**\n该算法返回一个代表最优离散路径的节点序列。从此序列中，计算出两个关键指标：\n1.  **路径长度 ($L$)**：路径在 $(q_1, q_2)$ 平面中的总几何长度。这是构成路径的所有段的欧几里得距离 $\\Delta \\ell_{uv}$ 的总和。\n2.  **势垒能量 ($E_{\\max}$)**：沿路径遇到的最大能量。关键是，这是通过在计算出的路径上的每个节点上采样*原始、未平滑的*势能 $V_{\\mathrm{grid}}$ 并找到最大值来确定的。这代表了物理系统沿计算出的轨迹必须克服的真实能量势垒。\n\n从平滑到路径分析的整个序列，对三个指定的 $(\\sigma_{q_1}, \\sigma_{q_2})$ 对中的每一个都执行一遍。然后，将每个用例的最终结果 $[E_{\\mathrm{int}}, L, E_{\\max}]$ 按要求格式化并打印出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RectBivariateSpline\nfrom scipy.ndimage import gaussian_filter\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.csgraph import dijkstra\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and optimizes paths on a synthetic 2D potential energy surface.\n    \"\"\"\n    # Define physical and model constants\n    A = 12.0\n    q0 = 0.7\n    B = 3.5\n    alpha = 0.6\n    D1 = 1.8\n    s1 = 0.0\n    wx = 0.35\n    wy = 0.35\n    D2 = -0.5\n    s2 = 0.1\n    y2 = 0.25\n    w2x = 0.25\n    w2y = 0.15\n    epsilon = 1e-12\n\n    # Define the grid\n    nq1, nq2 = 41, 25\n    q1_range = [-1.0, 1.0]\n    q2_range = [-0.6, 0.6]\n    \n    q1_coords = np.linspace(q1_range[0], q1_range[1], nq1, dtype=np.float64)\n    q2_coords = np.linspace(q2_range[0], q2_range[1], nq2, dtype=np.float64)\n    \n    dq1 = q1_coords[1] - q1_coords[0]\n    dq2 = q2_coords[1] - q2_coords[0]\n    \n    Q1, Q2 = np.meshgrid(q1_coords, q2_coords)\n\n    # Define the Potential Energy Surface (PES) function\n    def pes_func(q1, q2):\n        term1 = A * (q1**2 - q0**2)**2\n        term2 = B * (1 + alpha * q1) * q2**2\n        term3 = D1 * np.exp(-((q1 - s1)**2 / (2 * wx**2)) - (q2**2 / (2 * wy**2)))\n        term4 = D2 * np.exp(-((q1 - s2)**2 / (2 * w2x**2)) - ((q2 - y2)**2 / (2 * w2y**2)))\n        return term1 + term2 + term3 + term4\n\n    # Evaluate the discrete PES on the grid\n    V_grid = pes_func(Q1, Q2)\n\n    # Task 1: Bicubic Interpolation\n    # This is performed once on the original PES, as it's independent of smoothing.\n    interp_func = RectBivariateSpline(q2_coords, q1_coords, V_grid, kx=3, ky=3)\n    p_int = (0.0, 0.25)\n    _E_int_val = interp_func(p_int[1], p_int[0], grid=False)\n    E_int = _E_int_val.item()\n\n    # Define the test cases for smoothing parameters\n    test_cases = [\n        (0.00, 0.00),\n        (0.08, 0.08),\n        (0.15, 0.10),\n    ]\n\n    results = []\n\n    for sigma_q1, sigma_q2 in test_cases:\n        # Task 2: Gaussian Smoothing\n        if sigma_q1 == 0.0 and sigma_q2 == 0.0:\n            # No smoothing needed for sigma=0\n            V_sigma_grid = V_grid\n        else:\n            # Convert physical sigma to pixel units for the filter\n            sigma_pix_q1 = sigma_q1 / dq1\n            sigma_pix_q2 = sigma_q2 / dq2\n            # Apply Gaussian filter with reflective boundary conditions\n            V_sigma_grid = gaussian_filter(V_grid, sigma=[sigma_pix_q2, sigma_pix_q1], mode='reflect')\n\n        # Task 3: Path Optimization\n        # a. Define the cost function grid\n        V_sigma_min = np.min(V_sigma_grid)\n        C_grid = V_sigma_grid - V_sigma_min + epsilon\n\n        # b. Construct the weighted graph for pathfinding\n        N = nq1 * nq2\n        graph = lil_matrix((N, N))\n        \n        for i in range(nq2):\n            for j in range(nq1):\n                node_idx = i * nq1 + j\n                cost_node = C_grid[i, j]\n                \n                # Connect to 8 nearest neighbors\n                for di in [-1, 0, 1]:\n                    for dj in [-1, 0, 1]:\n                        if di == 0 and dj == 0:\n                            continue\n                        \n                        ni, nj = i + di, j + dj\n                        \n                        if 0 = ni  nq2 and 0 = nj  nq1:\n                            neighbor_idx = ni * nq1 + nj\n                            cost_neighbor = C_grid[ni, nj]\n                            \n                            # Calculate Euclidean distance and trapezoidal weight\n                            edge_len = np.sqrt((di * dq2)**2 + (dj * dq1)**2)\n                            weight = (cost_node + cost_neighbor) / 2.0 * edge_len\n                            graph[node_idx, neighbor_idx] = weight\n\n        # c. Find shortest path using Dijkstra's algorithm\n        q_start = (-q0, 0.0)\n        q_end = (q0, 0.0)\n        \n        j_start_idx = np.where(np.isclose(q1_coords, q_start[0]))[0][0]\n        i_start_end_idx = np.where(np.isclose(q2_coords, q_start[1]))[0][0]\n        j_end_idx = np.where(np.isclose(q1_coords, q_end[0]))[0][0]\n        \n        start_node = i_start_end_idx * nq1 + j_start_idx\n        end_node = i_start_end_idx * nq1 + j_end_idx\n\n        _, predecessors = dijkstra(csgraph=graph.tocsr(), indices=start_node, return_predecessors=True, directed=False)\n\n        # d. Reconstruct path and compute metrics\n        path_indices = []\n        curr = end_node\n        if predecessors[curr] == -9999 and curr != start_node:\n             raise RuntimeError(f\"No path found from {start_node} to {end_node}\")\n             \n        while curr != -9999:\n            path_indices.append(curr)\n            if curr == start_node: break\n            curr = predecessors[curr]\n        path_indices.reverse()\n\n        path_coords_ij = [np.unravel_index(p_idx, (nq2, nq1)) for p_idx in path_indices]\n\n        # Calculate total path length L\n        L = 0.0\n        for k in range(len(path_indices) - 1):\n            i_u, j_u = path_coords_ij[k]\n            i_v, j_v = path_coords_ij[k+1]\n            q1_u, q2_u = q1_coords[j_u], q2_coords[i_u]\n            q1_v, q2_v = q1_coords[j_v], q2_coords[i_v]\n            L += np.sqrt((q1_v - q1_u)**2 + (q2_v - q2_u)**2)\n\n        # Calculate barrier energy E_max from the original, unsmoothed PES\n        path_energies_V = [V_grid[i, j] for i, j in path_coords_ij]\n        E_max = np.max(path_energies_V)\n\n        results.append([E_int, L, E_max])\n\n    # Format the final output string as specified\n    output_str = \",\".join(f\"[{v[0]:.6f},{v[1]:.6f},{v[2]:.6f}]\" for v in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3580491"}, {"introduction": "一个静态的势能面只是故事的一部分；核动力学过程，例如自发裂变，涉及到在势能面上的运动。本练习通过半经典的WKB近似来计算穿越势垒的遂穿作用量，从而填补了这一空白，而遂穿作用量是估算裂变半衰期的关键物理量[@problem_id:3580448]。你将实现多维遂穿公式，该公式同时包含了势能面 $E(\\mathbf{q})$ 和集体惯性张量 $B_{ij}(\\mathbf{q})$ 的贡献，连接了原子核的静态结构与动态演化。", "problem": "考虑一个用于在势能面（PES）上进行大幅度核运动的集体哈密顿量，其中集体坐标是轴对称质量四极和八极形变 $\\mathbf{q} \\equiv (q_{20}, q_{30})$，惯性由对称正定的集体惯性张量 $B_{ij}(\\mathbf{q})$ 描述。在半经典隧穿机制中，穿过势垒的概率幅由一个作用量积分决定。从半经典温策尔-克拉默斯-布里渊（WKB）近似和欧几里得（虚时间）路径积分形式出发，推导沿参数化路径 $\\mathbf{q}(s)$ 穿过经典禁区累积的隧穿作用量如何依赖于PES $E(\\mathbf{q})$、集体惯性张量 $B_{ij}(\\mathbf{q})$ 以及路径导数 $\\mathrm{d}\\mathbf{q}/\\mathrm{d}s$。清晰地陈述此推导在此背景下有效的必要假设。\n\n然后，实现一个程序，以数值方式计算沿分段线性路径的WKB作用量，并针对一个可分离二次势垒PES，通过与瞬子（欧几里得作用量的鞍点）计算结果进行对比来验证该结果。具体来说，考虑二维PES\n$$\nE(\\mathbf{q}) = V_b - \\frac{1}{2} k_b \\, q_{20}^2 + \\frac{1}{2} k_t \\, q_{30}^2,\n$$\n以及常数对角集体惯性张量\n$$\nB_{ij}(\\mathbf{q}) = \\begin{pmatrix} B_{20}  0 \\\\ 0  B_{30} \\end{pmatrix},\n$$\n和一个低于势垒顶 $V_b$ 的参考能量 $E_0$。能量 $V_b$、$E_0$ 和刚度 $k_b$、$k_t$ 必须以兆电子伏（MeV）为单位处理，集体坐标 $(q_{20}, q_{30})$ 是无量纲形变，惯性分量以 $\\mathrm{MeV}^{-1}$ 为单位。隧穿作用量是无量纲的。\n\n你的程序必须：\n- 使用高斯求积法数值评估沿给定分段线性路径 $\\mathbf{q}(s)$ 的WKB作用量，其中被积函数依赖于局部势垒高度 $E(\\mathbf{q}) - E_0$ 和由 $B_{ij}(\\mathbf{q})$ 在 $\\mathrm{d}\\mathbf{q}$ 上导出的二次型。该路径应限制在经典禁区内，其端点为沿指定路径求解 $E(\\mathbf{q}) = E_0$ 所确定的经典转折点。\n- 在相同假设下，解析地评估可分离二次势垒的瞬子作用量，并在适用时将其用作验证参考。\n- 报告以下测试套件的定量比较。\n\n测试套件（能量单位为MeV，惯性单位为 $\\mathrm{MeV}^{-1}$，形变为无量纲）：\n1. 一般情况（沿 $q_{30}=0$ 的直线最小路径）：\n   - $V_b = 6$, $E_0 = 1$, $k_b = 4$, $k_t = 3$, $B_{20} = 10$, $B_{30} = 10$。\n   - 路径：$\\mathbf{q}(s)$ 是一条沿 $q_{30}=0$ 的直线，从由 $E(q_{20},0) = E_0$ 决定的内转折点到外转折点。\n   - 输出此路径的WKB作用量以及与解析瞬子作用量的绝对差。\n2. 各向异性惯性（沿 $q_{30}=0$ 的直线最小路径）：\n   - $V_b = 6$, $E_0 = 2$, $k_b = 5$, $k_t = 3$, $B_{20} = 4$, $B_{30} = 16$。\n   - 路径：沿 $q_{30}=0$ 的路径，介于由 $E(q_{20},0) = E_0$ 给出的转折点之间。\n   - 输出WKB作用量以及与解析瞬子作用量的绝对差。\n3. 弯曲路径惩罚（在 $(q_{20}, q_{30})$ 平面内有斜率的非最小直线）：\n   - $V_b = 6$, $E_0 = 1$, $k_b = 4$, $k_t = 8$, $B_{20} = 10$, $B_{30} = 10$。\n   - 路径：$q_{30} = \\beta \\, q_{20}$ 且 $\\beta = 0.5$ 的直线，介于满足 $E(q_{20}, \\beta q_{20}) = E_0$ 的转折点之间。\n   - 输出一个布尔值，指示此弯曲路径上的WKB作用量是否超过在相同 $(V_b, E_0, k_b, B_{20})$ 条件下沿 $q_{30}=0$ 的直线路径的解析瞬子作用量。\n4. 近势垒极限（沿 $q_{30}=0$ 的直线最小路径，且 $E_0$ 非常接近 $V_b$）：\n   - $V_b = 10$, $E_0 = 9.999$, $k_b = 6$, $k_t = 3$, $B_{20} = 7$, $B_{30} = 7$。\n   - 路径：沿 $q_{30}=0$ 的路径，介于由 $E(q_{20},0) = E_0$ 给出的转折点之间。\n   - 输出WKB作用量与解析瞬子作用量之间的绝对差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”）。列表条目必须按顺序为：\n- 测试1的WKB作用量，浮点数，\n- 测试1与解析瞬子的绝对差，浮点数，\n- 测试2的WKB作用量，浮点数，\n- 测试2与解析瞬子的绝对差，浮点数，\n- 测试3的比较布尔值，\n- 测试4与解析瞬子的绝对差，浮点数。\n\n所有数值答案必须是无量纲的，并以原始十进制数报告（无百分号）。", "solution": "该问题要求推导用于粒子穿过多维势垒的半经典温策尔-克拉默斯-布里渊（WKB）作用量，该势垒由集体哈密顿量描述。推导之后，必须开发一个数值实现来计算特定路径和参数下的此作用量，并通过与瞬子路径的解析解进行比较来验证结果。\n\n### 1. 半经典隧穿作用量的推导\n\n起点是描述由集体坐标 $\\mathbf{q} \\equiv (q_i)$、坐标相关的惯性张量 $B_{ij}(\\mathbf{q})$ 和势能面（PES）$E(\\mathbf{q})$ 构成的系统的经典拉格朗日量。\n$$ L(\\mathbf{q}, \\dot{\\mathbf{q}}) = T - V = \\frac{1}{2} \\sum_{i,j} B_{ij}(\\mathbf{q}) \\dot{q}_i \\dot{q}_j - E(\\mathbf{q}) $$\n其中 $\\dot{q}_i = \\mathrm{d}q_i/\\mathrm{d}t$。\n\n隧穿是一个经典禁戒过程。通过进行到虚时间 $\\tau = it$ 的威克转动，在欧几里得时空中建立半经典描述。因此，时间导数变为 $\\mathrm{d}/\\mathrm{d}t = i\\,\\mathrm{d}/\\mathrm{d}\\tau$，因此 $\\dot{q}_i = i\\,\\mathrm{d}q_i/\\mathrm{d}\\tau$。动能项转换为：\n$$ T = \\frac{1}{2} \\sum_{i,j} B_{ij} (i\\,\\frac{\\mathrm{d}q_i}{\\mathrm{d}\\tau})(i\\,\\frac{\\mathrm{d}q_j}{\\mathrm{d}\\tau}) = -\\frac{1}{2} \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}\\tau} \\frac{\\mathrm{d}q_j}{\\mathrm{d}\\tau} \\equiv -T_E $$\n作用量积分 $\\int L\\,\\mathrm{d}t$ 变为 $iS_E$，其中 $S_E$ 是欧几里得作用量：\n$$ S_E = \\int L_E \\,\\mathrm{d}\\tau = \\int \\left( T_E + E(\\mathbf{q}) \\right) \\mathrm{d}\\tau $$\n假设系统以恒定能量 $E_0$ 隧穿。相应的欧几里得运动方程描述了一个在反转势 $V_{inverted} = -E(\\mathbf{q})$ 中运动的经典粒子，其总能量守恒为 $-E_0$。欧几里得形式下的能量守恒表示为：\n$$ H_E = T_E - E(\\mathbf{q}) = -E_0 $$\n这导致了在禁戒区沿经典轨迹有效的基本关系：\n$$ T_E = \\frac{1}{2} \\sum_{i,j} B_{ij}(\\mathbf{q}) \\frac{\\mathrm{d}q_i}{\\mathrm{d}\\tau} \\frac{\\mathrm{d}q_j}{\\mathrm{d}\\tau} = E(\\mathbf{q}) - E_0 $$\n此方程仅在经典禁戒区 $E(\\mathbf{q})  E_0$ 内有意义。\n\nWKB隧穿作用量出现在隧穿概率 $P \\propto e^{-2S/\\hbar}$ 的指数中，它被确定为欧几里得作用量 $S_E$（对于无量纲作用量，$\\hbar = 1$）。我们可以将 $S_E$ 表示为一种与时间参数化无关的形式。沿路径使用 $T_E = E(\\mathbf{q}) - E_0$，我们可以写出 $S_E = \\int (T_E + E(\\mathbf{q}))\\,\\mathrm{d}\\tau = \\int (E(\\mathbf{q}) - E_0 + E(\\mathbf{q}))\\,\\mathrm{d}\\tau$，但这并非最直接的途径。相反，利用欧几里得空间中的莫佩尔蒂原理，作用量由欧几里得动量沿路径的积分给出，$S_E = \\int \\mathbf{p}_E \\cdot \\mathrm{d}\\mathbf{q}$。通过用任意参数 $s$ 对路径 $\\mathbf{q}$ 进行重新参数化，即 $\\mathbf{q} = \\mathbf{q}(s)$，可以获得更方便的形式。\n能量守恒方程给出：\n$$ \\frac{1}{2} \\left(\\frac{\\mathrm{d}s}{\\mathrm{d}\\tau}\\right)^2 \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s} = E(\\mathbf{q}(s)) - E_0 $$\n解出 $\\mathrm{d}\\tau$：\n$$ \\mathrm{d}\\tau = \\mathrm{d}s / \\frac{\\mathrm{d}s}{\\mathrm{d}\\tau} = \\sqrt{\\frac{\\frac{1}{2} \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s}}{E(\\mathbf{q}(s)) - E_0}} \\,\\mathrm{d}s $$\n作用量可以表示为 $S = \\int 2T_E \\,\\mathrm{d}\\tau$。代入 $T_E$ 和 $\\mathrm{d}\\tau$ 的表达式：\n$$ S[\\mathbf{q}(s)] = \\int_{s_{start}}^{s_{end}} 2 \\left( E(\\mathbf{q}(s)) - E_0 \\right) \\sqrt{\\frac{\\frac{1}{2} \\sum_{i,j} B_{ij} \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s}}{E(\\mathbf{q}(s)) - E_0}} \\,\\mathrm{d}s $$\n$$ S[\\mathbf{q}(s)] = \\int_{s_{start}}^{s_{end}} \\sqrt{2 \\left(E(\\mathbf{q}(s)) - E_0\\right) \\left(\\sum_{i,j} B_{ij}(\\mathbf{q}(s)) \\frac{\\mathrm{d}q_i}{\\mathrm{d}s} \\frac{\\mathrm{d}q_j}{\\mathrm{d}s}\\right)} \\,\\mathrm{d}s $$\n这是沿任意参数化路径 $\\mathbf{q}(s)$ 从起点 $s_{start}$ 到终点 $s_{end}$（通常是 $E(\\mathbf{q}) = E_0$ 的经典转折点）的WKB隧穿作用量的最终表达式。\n\n此推导的关键假设是：\n1.  **半经典近似**：与集体运动的局域德布罗意波长相比，势能 $E(\\mathbf{q})$ 变化缓慢。\n2.  **绝热运动**：假设集体自由度 $\\mathbf{q}$ 与内核子激发解耦（无耗散）。\n3.  **集体模型的有效性**：核动力学可以由少数集体坐标很好地描述。\n4.  **虚时间形式**：隧穿振幅由虚时间中的单一经典路径（瞬子）主导。\n\n### 2. 可分离二次势垒的解析瞬子作用量\n\n瞬子是使作用量泛函 $S[\\mathbf{q}(s)]$ 最小化的路径。对于给定的PES $E(\\mathbf{q}) = V_b - \\frac{1}{2} k_b q_{20}^2 + \\frac{1}{2} k_t q_{30}^2$ 和对角惯性张量 $B_{ij}$，作用量为：\n$$ S = \\int \\sqrt{2 \\left(V_b - E_0 - \\frac{1}{2}k_b q_{20}^2 + \\frac{1}{2}k_t q_{30}^2\\right)\\left(B_{20}\\left(\\frac{\\mathrm{d}q_{20}}{\\mathrm{d}s}\\right)^2 + B_{30}\\left(\\frac{\\mathrm{d}q_{30}}{\\mathrm{d}s}\\right)^2\\right)} \\,\\mathrm{d}s $$\n为了最小化作用量，路径必须通过尽可能低的势能。项 $\\frac{1}{2}k_t q_{30}^2$ 会随着 $|q_{30}|$ 的增加而增加势能。因此，最小作用量路径（瞬子）必须位于 $q_{30}=0$ 轴上。\n设 $q_{30}(s)=0$，作用量得以简化。我们可以用 $q_{20}$ 本身来参数化路径，所以 $s=q_{20}$：\n$$ S_{inst} = \\int_{q_{20,a}}^{q_{20,b}} \\sqrt{2 \\left(V_b - E_0 - \\frac{1}{2}k_b q_{20}^2\\right) B_{20}} \\,\\mathrm{d}q_{20} $$\n经典转折点 $q_{20,a}$ 和 $q_{20,b}$ 可通过将平方根的参数设为零找到：\n$$ V_b - E_0 - \\frac{1}{2}k_b q_{20}^2 = 0 \\implies q_{20} = \\pm \\sqrt{\\frac{2(V_b - E_0)}{k_b}} \\equiv \\pm q_{20,m} $$\n该积分为标准积分：\n$$ S_{inst} = \\sqrt{2 B_{20}} \\int_{-q_{20,m}}^{q_{20,m}} \\sqrt{(V_b - E_0) - \\frac{k_b}{2} q_{20}^2} \\,\\mathrm{d}q_{20} $$\n该积分结果为 $\\frac{\\pi}{2} (V_b - E_0) \\sqrt{2/k_b}$。合并各项：\n$$ S_{inst} = \\sqrt{2 B_{20}} \\cdot \\frac{\\pi}{2} (V_b - E_0) \\sqrt{\\frac{2}{k_b}} = \\pi (V_b - E_0) \\sqrt{\\frac{B_{20}}{k_b}} $$\n这是瞬子作用量的解析公式，可作为数值计算的参考。\n\n### 3. 数值评估与测试用例\n\n对于两个转折点 $\\mathbf{q}_A$ 和 $\\mathbf{q}_B$ 之间的一般直线路径，我们使用参数化 $\\mathbf{q}(s) = \\mathbf{q}_A + s(\\mathbf{q}_B - \\mathbf{q}_A)$，其中 $s \\in [0, 1]$。路径导数 $\\mathrm{d}\\mathbf{q}/\\mathrm{d}s = \\mathbf{q}_B - \\mathbf{q}_A \\equiv \\Delta\\mathbf{q}$ 是一个常数。作用量积分变为：\n$$ S = \\sqrt{B_{20}(\\Delta q_{20})^2 + B_{30}(\\Delta q_{30})^2} \\int_0^1 \\sqrt{2\\left(E(\\mathbf{q}(s)) - E_0\\right)} \\,\\mathrm{d}s $$\n这个一维积分可以使用高斯求积法高效而准确地计算。\n\n**测试用例1、2和4：** 指定路径沿 $q_{30}=0$。这是瞬子路径。因此，数值WKB作用量计算应与解析瞬子公式在数值精度范围内一致。绝对差预计接近于零。\n\n**测试用例3：** 指定路径为 $q_{30} = 0.5 q_{20}$，这不是瞬子路径。根据最小作用量原理，任何非瞬子路径的作用量必须大于瞬子作用量。因此，我们预计沿这条“弯曲”路径（因 $q_{30} \\neq 0$ 而得名）的WKB作用量将大于使用相同势垒参数（$V_b, E_0, k_b, B_{20}$）计算的解析瞬子作用量。比较应得出 `True`。\n\n下面的程序实现了这些计算，使用 `scipy.integrate.quad` 进行数值积分。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef calculate_wkb_action(Vb, E0, kb, kt, B20, B30, path_type, beta=None):\n    \"\"\"\n    Numerically computes the WKB action along a specified straight-line path.\n\n    The path is parameterized by s in [0, 1] from turning point A to B.\n    \"\"\"\n    if Vb - E0  0:\n        return 0.0\n\n    if path_type == 'straight':\n        # Path along q30 = 0\n        if kb = 0: return np.inf\n        \n        q20_m = np.sqrt(2 * (Vb - E0) / kb)\n        qA = np.array([-q20_m, 0.0])\n        qB = np.array([q20_m, 0.0])\n\n    elif path_type == 'curved':\n        # Path along q30 = beta * q20\n        k_eff = kb - kt * beta**2\n        if k_eff = 0:\n            # No real turning points or path is not under a barrier\n            return np.inf\n        \n        q20_m = np.sqrt(2 * (Vb - E0) / k_eff)\n        qA = np.array([-q20_m, -beta * q20_m])\n        qB = np.array([q20_m, beta * q20_m])\n    else:\n        raise ValueError(\"Unknown path type\")\n\n    delta_q = qB - qA\n    B_metric_term = B20 * delta_q[0]**2 + B30 * delta_q[1]**2\n    if B_metric_term  0: return np.inf # Should not happen with positive B_ij\n    \n    # Define the integrand for the action integral\n    def integrand(s):\n        q20_s = qA[0] + s * delta_q[0]\n        q30_s = qA[1] + s * delta_q[1]\n        \n        potential_at_s = Vb - 0.5 * kb * q20_s**2 + 0.5 * kt * q30_s**2\n        energy_diff = potential_at_s - E0\n        \n        # Clamp to zero to handle potential floating-point inaccuracies\n        # at the endpoints where energy_diff should be exactly zero.\n        if energy_diff  0:\n            return 0.0\n            \n        return np.sqrt(2 * energy_diff)\n\n    integral_val, _ = quad(integrand, 0, 1)\n\n    action = np.sqrt(B_metric_term) * integral_val\n    return action\n\ndef calculate_instanton_action(Vb, E0, kb, B20):\n    \"\"\"\n    Analytically computes the instanton action for the separable quadratic barrier.\n    \"\"\"\n    if Vb - E0 = 0 or kb = 0 or B20  0:\n        return 0.0\n    return np.pi * (Vb - E0) * np.sqrt(B20 / kb)\n\ndef solve():\n    # Test suite: (Vb, E0, kb, kt, B20, B30)\n    test_cases = {\n        1: {'params': (6, 1, 4, 3, 10, 10), 'path': 'straight', 'beta': None},\n        2: {'params': (6, 2, 5, 3, 4, 16), 'path': 'straight', 'beta': None},\n        3: {'params': (6, 1, 4, 8, 10, 10), 'path': 'curved', 'beta': 0.5},\n        4: {'params': (10, 9.999, 6, 3, 7, 7), 'path': 'straight', 'beta': None},\n    }\n\n    results = []\n\n    # Test 1\n    case1 = test_cases[1]\n    Vb1, E01, kb1, _, B201, _ = case1['params']\n    wkb1 = calculate_wkb_action(*case1['params'], path_type=case1['path'])\n    inst1 = calculate_instanton_action(Vb1, E01, kb1, B201)\n    diff1 = np.abs(wkb1 - inst1)\n    results.extend([wkb1, diff1])\n\n    # Test 2\n    case2 = test_cases[2]\n    Vb2, E02, kb2, _, B202, _ = case2['params']\n    wkb2 = calculate_wkb_action(*case2['params'], path_type=case2['path'])\n    inst2 = calculate_instanton_action(Vb2, E02, kb2, B202)\n    diff2 = np.abs(wkb2 - inst2)\n    results.extend([wkb2, diff2])\n\n    # Test 3\n    case3 = test_cases[3]\n    Vb3, E03, kb3, _, B203, _ = case3['params']\n    wkb3_curved = calculate_wkb_action(*case3['params'], path_type=case3['path'], beta=case3['beta'])\n    inst3_straight = calculate_instanton_action(Vb3, E03, kb3, B203)\n    comp3 = wkb3_curved > inst3_straight\n    results.append(comp3)\n    \n    # Test 4\n    case4 = test_cases[4]\n    Vb4, E04, kb4, _, B204, _ = case4['params']\n    wkb4 = calculate_wkb_action(*case4['params'], path_type=case4['path'])\n    inst4 = calculate_instanton_action(Vb4, E04, kb4, B204)\n    diff4 = np.abs(wkb4 - inst4)\n    results.append(diff4)\n\n    # Format and print the final output\n    # Boolean must be 'True' or 'False' which str() handles correctly\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3580448"}]}