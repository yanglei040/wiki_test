{"hands_on_practices": [{"introduction": "对原子核转动带的分析始于从实验测量的跃迁能量中提取转动频率 $\\omega$。这项练习 [@problem_id:3543329] 提供了处理此任务所用基本数值方法的实践经验，特别是探索了不同有限差分估计量之间的权衡，及其在临界“回弯”区域附近对准确性的影响。", "problem": "在一个形变良好的偶偶核中，一个转动带表现出回弯现象，其中运动学转动惯量 (MOI) 随自旋迅速变化。转动频率由第一性原理通过摇摆关系定义为激发能对角动量的导数，即 $\\hbar\\omega(I)=\\frac{dE(I)}{dI}$，其中 $\\hbar$ 是约化普朗克常数，$E(I)$ 是自旋为 $I$ 时的能级能量。在谱学中，只有跃迁能量是直接测量的：$E_\\gamma(I\\to I-2)=E(I)-E(I-2)$。一项实际的计算任务是根据测得的离散 $E_\\gamma$ 值集合来估计 $\\hbar\\omega(I)$。\n\n现给出在 $I\\approx 18$ 附近一个疑似回弯区域测得的以下γ射线跃迁能量（所有能量的独立一倍标准偏差不确定度均为 $\\pm 2~\\mathrm{keV}$）：\n- $E_\\gamma(12\\to 10)=400~\\mathrm{keV}$，\n- $E_\\gamma(14\\to 12)=460~\\mathrm{keV}$，\n- $E_\\gamma(16\\to 14)=520~\\mathrm{keV}$，\n- $E_\\gamma(18\\to 16)=560~\\mathrm{keV}$，\n- $E_\\gamma(20\\to 18)=500~\\mathrm{keV}$，\n- $E_\\gamma(22\\to 20)=540~\\mathrm{keV}$。\n\n从定义 $\\hbar\\omega(I)=\\frac{dE}{dI}$ 出发，并仅基于测量的 $E_\\gamma$ 值使用一致的有限差分推理，确定下列哪些陈述是正确的。选择所有适用的选项。\n\nA. 根据 $\\hbar\\omega(I)=\\frac{dE}{dI}$ 和 $E_\\gamma(I\\to I-2)=E(I)-E(I-2)$，在步长为 $h=2$ 的自旋格点上，一个对称（中心）有限差分估计量是 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{4}$。利用所提供的数据，这给出 $\\hbar\\omega(18)\\approx 265~\\mathrm{keV}$，并且如果每个 $E_\\gamma$ 的独立标准偏差为 $2~\\mathrm{keV}$，则由此估计量算出的 $\\hbar\\omega(18)$ 的标准偏差约为 $0.71~\\mathrm{keV}$。\n\nB. 一个前向单边估计量仅使用 $E_\\gamma(I+2\\to I)$，通过 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I+2\\to I)}{2}$ 计算。在 $I=18$ 处，估计值为 $250~\\mathrm{keV}$；该单边估计量比对称估计量具有更小的统计方差，并且即使在剧烈回弯处也是无偏的。\n\nC. 对于平滑的转动带，在自旋步长 $h=2$ 时，对称估计量的截断误差与 $\\mathcal{O}(h^2)$ 成比例，而单边估计量的截断误差与 $\\mathcal{O}(h)$ 成比例。在回弯附近，位于 $I=18$ 的对称估计量实际上是平均了交会前后的局域频率，从而相对于任何一侧都引入了额外的偏差，尽管其测量噪声方差低于单边估计的方差。\n\nD. 使用数据，在 $I=18$ 处的后向单边估计量给出 $\\hbar\\omega\\approx 280~\\mathrm{keV}$，并且对称估计量等于在同一自旋处前向和后向单边估计的算术平均值。\n\nE. 正确的对称公式是 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{2}$，利用数据可得出 $\\hbar\\omega(18)\\approx 530~\\mathrm{keV}$，并且其截断误差比分母为 $\\dfrac{1}{4}$ 的版本更低。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于核结构物理的原理，特别是摇摆模型和转动带的唯象学。该问题提法得当，提供了使用标准数值方法（有限差分）进行定量分析所需的所有定义和数据。语言是客观的，数据在物理上是现实的。\n\n中心任务是使用离散的跃迁能量数据 $E_\\gamma(I \\to I-2) = E(I) - E(I-2)$ 来近似转动频率，其定义为能量对角动量的导数，即 $\\hbar\\omega(I) = \\frac{dE(I)}{dI}$。自旋 $I$ 是以 $\\hbar$ 为单位的无量纲量，能级间隔为 $\\Delta I = 2$。\n\n我们首先推导 $\\hbar\\omega(I)$ 所需的有限差分估计量。\n\n对于一阶导数 $f'(x)$，使用步长 $h$ 的标准中心差分公式是 $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$。在我们的情景中，函数是 $E(I)$，变量是 $I$，连接数据点以形成对称差分的最小步长是 $h=2$。因此，我们有：\n$$ \\hbar\\omega(I) = \\frac{dE}{dI}\\bigg|_I \\approx \\frac{E(I+2) - E(I-2)}{(I+2)-(I-2)} = \\frac{E(I+2) - E(I-2)}{4} $$\n我们可以用可测量的跃迁能量来表示分子：\n$ E(I+2) - E(I-2) = [E(I+2) - E(I)] + [E(I) - E(I-2)] = E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2) $。\n因此，**对称（中心）估计量**是：\n$$ \\hbar\\omega_S(I) \\approx \\frac{E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2)}{4} $$\n\n单边有限差分估计量可以用类似的方法推导。**前向估计量**使用点 $I$ 和 $I+2$：\n$$ \\hbar\\omega_F(I) = \\frac{dE}{dI}\\bigg|_I \\approx \\frac{E(I+2) - E(I)}{(I+2)-I} = \\frac{E(I+2) - E(I)}{2} = \\frac{E_\\gamma(I+2 \\to I)}{2} $$\n**后向估计量**使用点 $I-2$ 和 $I$：\n$$ \\hbar\\omega_B(I) = \\frac{dE}{dI}\\bigg|_I \\approx \\frac{E(I) - E(I-2)}{I-(I-2)} = \\frac{E(I) - E(I-2)}{2} = \\frac{E_\\gamma(I \\to I-2)}{2} $$\n\n对于自旋 $I=18$ 的相关数据是：\n- $E_\\gamma(18 \\to 16) = 560~\\mathrm{keV}$\n- $E_\\gamma(20 \\to 18) = 500~\\mathrm{keV}$\n每个独立测量的标准偏差为 $\\sigma_{E_\\gamma} = 2~\\mathrm{keV}$。\n\n现在，我们评估每个陈述。\n\n**A. 根据 $\\hbar\\omega(I)=\\frac{dE}{dI}$ 和 $E_\\gamma(I\\to I-2)=E(I)-E(I-2)$，在步长为 $h=2$ 的自旋格点上，一个对称（中心）有限差分估计量是 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{4}$。利用所提供的数据，这给出 $\\hbar\\omega(18)\\approx 265~\\mathrm{keV}$，并且如果每个 $E_\\gamma$ 的独立标准偏差为 $2~\\mathrm{keV}$，则由此估计量算出的 $\\hbar\\omega(18)$ 的标准偏差约为 $0.71~\\mathrm{keV}$。**\n\n提供的公式 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{4}$ 与我们推导的对称估计量 $\\hbar\\omega_S(I)$ 相符。\n使用 $I=18$ 的数据：\n$$ \\hbar\\omega_S(18) \\approx \\frac{E_\\gamma(18 \\to 16) + E_\\gamma(20 \\to 18)}{4} = \\frac{560~\\mathrm{keV} + 500~\\mathrm{keV}}{4} = \\frac{1060~\\mathrm{keV}}{4} = 265~\\mathrm{keV} $$\n这个计算是正确的。\n对于不确定度，设 $X = E_\\gamma(I \\to I-2)$ 和 $Y = E_\\gamma(I+2 \\to I)$，则 $\\hbar\\omega_S = (X+Y)/4$。给定 $\\sigma_X = \\sigma_Y = 2~\\mathrm{keV}$ 并且测量是独立的，方差是：\n$$ \\sigma^2_{\\omega_S} = \\left(\\frac{\\partial \\omega_S}{\\partial X}\\right)^2 \\sigma_X^2 + \\left(\\frac{\\partial \\omega_S}{\\partial Y}\\right)^2 \\sigma_Y^2 = \\left(\\frac{1}{4}\\right)^2 \\sigma_X^2 + \\left(\\frac{1}{4}\\right)^2 \\sigma_Y^2 = \\frac{1}{16} (\\sigma_X^2 + \\sigma_Y^2) $$\n$$ \\sigma^2_{\\omega_S} = \\frac{1}{16} ((2~\\mathrm{keV})^2 + (2~\\mathrm{keV})^2) = \\frac{1}{16} (4+4)~\\mathrm{keV}^2 = \\frac{8}{16}~\\mathrm{keV}^2 = 0.5~\\mathrm{keV}^2 $$\n标准偏差是 $\\sigma_{\\omega_S} = \\sqrt{0.5}~\\mathrm{keV} \\approx 0.7071~\\mathrm{keV}$。这被正确地报告为约 $0.71~\\mathrm{keV}$。\n该陈述的所有部分都是正确的。\n结论：**正确**。\n\n**B. 一个前向单边估计量仅使用 $E_\\gamma(I+2\\to I)$，通过 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I+2\\to I)}{2}$ 计算。在 $I=18$ 处，估计值为 $250~\\mathrm{keV}$；该单边估计量比对称估计量具有更小的统计方差，并且即使在剧烈回弯处也是无偏的。**\n\n公式 $\\hbar\\omega_F(I) \\approx \\frac{E_\\gamma(I+2 \\to I)}{2}$ 与我们的推导相符。\n使用 $I=18$ 的数据：\n$$ \\hbar\\omega_F(18) \\approx \\frac{E_\\gamma(20 \\to 18)}{2} = \\frac{500~\\mathrm{keV}}{2} = 250~\\mathrm{keV} $$\n这个计算是正确的。\n现在，我们评估统计方差。设 $Y = E_\\gamma(I+2 \\to I)$。$\\hbar\\omega_F = Y/2$ 的方差是：\n$$ \\sigma^2_{\\omega_F} = \\left(\\frac{1}{2}\\right)^2 \\sigma_Y^2 = \\frac{1}{4} (2~\\mathrm{keV})^2 = 1~\\mathrm{keV}^2 $$\n在A中，我们发现对称估计量的方差为 $\\sigma^2_{\\omega_S} = 0.5~\\mathrm{keV}^2$。因为 $1~\\mathrm{keV}^2 > 0.5~\\mathrm{keV}^2$，所以前向估计量具有*更大*的统计方差，而不是更小。陈述的这一部分是错误的。\n此外，声称该估计量是“无偏的”这一说法是不正确的。所有导数的有限差分近似都有截断误差，这是系统性偏差的一个来源。单边估计量的截断误差是 $\\mathcal{O}(h)$ 阶，其中 $h$ 是步长。只有当函数是完全线性的，它才是无偏的，但对于 $E(I)$ 并非如此。\n结论：**不正确**。\n\n**C. 对于平滑的转动带，在自旋步长 $h=2$ 时，对称估计量的截断误差与 $\\mathcal{O}(h^2)$ 成比例，而单边估计量的截断误差与 $\\mathcal{O}(h)$ 成比例。在回弯附近，位于 $I=18$ 的对称估计量实际上是平均了交会前后的局域频率，从而相对于任何一侧都引入了额外的偏差，尽管其测量噪声方差低于单边估计的方差。**\n\n关于截断误差缩放的陈述是数值分析的标准结果。泰勒级数展开显示，中心差分 $\\frac{f(x+h)-f(x-h)}{2h}$ 的误差是 $\\mathcal{O}(h^2)$，而单边差分 $\\frac{f(x+h)-f(x)}{h}$ 的误差是 $\\mathcal{O}(h)$。这里，步长 $h$ 是 $2$。这部分是正确的。\n回弯现象意味着转动性质的快速变化。在 $I=18$ 处，对称估计量使用 $E_\\gamma(18 \\to 16) = 560~\\mathrm{keV}$（回弯前）和 $E_\\gamma(20 \\to 18) = 500~\\mathrm{keV}$（回弯后）。对称公式平均了来自两侧的信息，这可能通过混合两种不同的物理机制而引入偏差。单边估计量将它们分离开来：$\\hbar\\omega_B(18) \\approx 280~\\mathrm{keV}$ 和 $\\hbar\\omega_F(18) \\approx 250~\\mathrm{keV}$。对称估计值为 $\\hbar\\omega_S(18) = 265~\\mathrm{keV}$，这是这两者的平均值，因此是“平均”了它们。这部分是正确的物理和数值解释。\n最后，对称估计量的测量噪声方差低于单边估计量的说法在选项B的分析中得到了证明。$\\sigma^2_{\\omega_S} = 0.5~\\mathrm{keV}^2$ 小于 $\\sigma^2_{\\omega_F} = \\sigma^2_{\\omega_B} = 1~\\mathrm{keV}^2$。\n该陈述中的所有主张都是正确的。\n结论：**正确**。\n\n**D. 使用数据，在 $I=18$ 处的后向单边估计量给出 $\\hbar\\omega\\approx 280~\\mathrm{keV}$，并且对称估计量等于在同一自旋处前向和后向单边估计的算术平均值。**\n\n后向估计量是 $\\hbar\\omega_B(I) \\approx \\frac{E_\\gamma(I \\to I-2)}{2}$。\n在 $I=18$ 处：\n$$ \\hbar\\omega_B(18) \\approx \\frac{E_\\gamma(18 \\to 16)}{2} = \\frac{560~\\mathrm{keV}}{2} = 280~\\mathrm{keV} $$\n这个计算是正确的。\n现在，我们检查估计量之间的关系。前向和后向估计量的算术平均值是：\n$$ \\frac{\\hbar\\omega_F(I) + \\hbar\\omega_B(I)}{2} = \\frac{1}{2} \\left( \\frac{E_\\gamma(I+2 \\to I)}{2} + \\frac{E_\\gamma(I \\to I-2)}{2} \\right) = \\frac{E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2)}{4} $$\n这恰好是对称估计量 $\\hbar\\omega_S(I)$ 的公式。此属性是一个数学恒等式。\n陈述的两个部分都是真的。\n结论：**正确**。\n\n**E. 正确的对称公式是 $\\hbar\\omega(I)\\approx \\dfrac{E_\\gamma(I\\to I-2)+E_\\gamma(I+2\\to I)}{2}$，利用数据可得出 $\\hbar\\omega(18)\\approx 530~\\mathrm{keV}$，并且其截断误差比分母为 $\\dfrac{1}{4}$ 的版本更低。**\n\n提议的公式是 $\\hbar\\omega(I) \\approx \\frac{E_\\gamma(I \\to I-2) + E_\\gamma(I+2 \\to I)}{2}$。\n正如开头所推导的，正确的对称估计量是 $\\hbar\\omega_S(I) \\approx \\frac{E_\\gamma(I+2 \\to I) + E_\\gamma(I \\to I-2)}{4}$。提议的公式差了一个因子 $2$。它是对 $2\\hbar\\omega(I)$ 的近似，而不是 $\\hbar\\omega(I)$。该公式不正确。\n计算 $\\hbar\\omega(18) \\approx \\frac{560 + 500}{2} = 530~\\mathrm{keV}$ 在算术上与不正确的公式一致。\n声称此公式具有更低的截断误差是错误的。分母为 $4$ 的公式是标准的二阶精度中心差分近似。分母为 $2$ 的公式根本不近似于 $\\hbar\\omega(I)$，因此它不可能是“更好”的近似。它在近似 $\\hbar\\omega(I)$ 时的误差大约是 $\\hbar\\omega(I)$ 本身，远大于正确公式的截断误差。\n结论：**不正确**。\n\n总之，选项 A、C 和 D 是正确的。", "answer": "$$\\boxed{ACD}$$", "id": "3543329"}, {"introduction": "获得转动频率后，下一步是量化回弯现象本身。这项计算实践 [@problem_id:3543269] 将指导你构建一个人工的转动带，然后对其进行分析以提取增量顺排角动量 $i_x(\\omega)$，这是一个关键的观测量，它分离出了由准粒子顺排贡献的自旋增益。这个过程模拟了对真实实验数据的标准分析流程。", "problem": "偶偶核中的转动带可以在摇转框架下进行研究，其中转动频率与激发能相对于自旋的导数有关。增量顺排作为转动频率的函数，是回弯现象的一种标准诊断方法。在本问题中，您将实现一个计算程序，使用 Harris 参数化来估计参考转动惯量，并为表现出受控回弯行为的合成带计算作为转动频率函数的增量顺排。您必须生成一个可运行的程序来解决以下问题。\n\n给定以约化普朗克常数（$\\hbar$）为单位的自旋 $I$ 标记的离散能级，其转动频率（单位为兆电子伏每$\\hbar$，即 MeV$/\\hbar$）可以通过测量到的激发能（单位为兆电子伏，即 MeV）的中心有限差分来近似。如果自旋步长为 $\\Delta I=2$（偶偶核），那么对于自旋为 $I$ 的内部能级，\n$$\n\\omega(I) \\approx \\frac{E(I+\\Delta I)-E(I-\\Delta I)}{2\\,\\Delta I},\n$$\n其中所有能量 $E(\\cdot)$ 的单位为 MeV，当 $I$ 以 $\\hbar$ 为单位计数且 $\\hbar$ 设为1时，得到的 $\\omega$ 单位为 MeV$/\\hbar$。作为转动频率函数的低频参考自旋由 Harris 展开建模：\n$$\nI_{\\mathrm{ref}}(\\omega) = J_0\\,\\omega + J_1\\,\\omega^3,\n$$\n其中 $J_0$ 的单位为 $\\hbar^2/\\mathrm{MeV}$，$J_1$ 的单位为 $\\hbar^4/\\mathrm{MeV}^3$。增量顺排定义为：\n$$\ni_x(\\omega) = I(\\omega) - I_{\\mathrm{ref}}(\\omega),\n$$\n并以 $\\hbar$ 为单位报告。\n\n您的任务是：\n- 使用由一组参数控制的回弯模型，为偶数自旋 $I \\in \\{0,2,4,\\dots,I_{\\max}\\}$ 生成合成转动带能量 $E(I)$。对于每组参数，通过求解隐式方程得到 $\\omega$ 来定义一个平滑的自旋-频率关系：\n$$\nI = J_0^{(\\mathrm{true})}\\,\\omega + J_1^{(\\mathrm{true})}\\,\\omega^3 + \\frac{i_{\\mathrm{align}}}{1+\\exp\\!\\left(-\\frac{\\omega-\\omega_c}{\\Delta\\omega}\\right)},\n$$\n其中 $J_0^{(\\mathrm{true})}$ 和 $J_1^{(\\mathrm{true})}$ 定义了低频参考，最后一项提供了一个 S 形的顺排增益，其大小为 $i_{\\mathrm{align}}$，中心位于 $\\omega_c$，宽度为 $\\Delta\\omega$。然后使用梯形法则，以自旋步长 $\\Delta I=2$ 对自旋进行数值积分来构建 $E(I)$：\n$$\nE(0)=0,\\quad E(I_k)=E(I_{k-1}) + \\frac{\\omega(I_k)+\\omega(I_{k-1})}{2}\\,\\Delta I,\n$$\n并向每个 $E(I)$ 添加一个确定性噪声项 $n(I)=A_{\\mathrm{noise}}\\sin\\!\\left(\\pi I/6\\right)$（单位为 MeV），其中角度使用弧度制。能量必须以 MeV 为单位报告。\n- 根据合成的 $E(I)$ 值，使用 $\\Delta I=2$ 的中心有限差分公式计算内部自旋处的离散转动频率 $\\omega(I)$：\n$$\n\\omega(I)=\\frac{E(I+2)-E(I-2)}{4}.\n$$\n- 仅使用由 $\\omega(I)\\le \\omega_{\\max}^{(\\mathrm{fit})}$ 定义的低频子集，通过将 $I$ 对回归量 $\\omega$ 和 $\\omega^3$ 进行线性最小二乘拟合来估计 $J_0$ 和 $J_1$：\n$$\nI \\approx J_0\\,\\omega + J_1\\,\\omega^3\\quad\\text{for}\\quad \\omega\\le \\omega_{\\max}^{(\\mathrm{fit})}.\n$$\n- 使用拟合得到的 $\\hat J_0$ 和 $\\hat J_1$ 计算所有可用内部频率下的增量顺排 $i_x(\\omega)$。然后，通过线性插值并对可用频率范围进行钳位处理，在三个指定的评估频率 $\\omega_{\\mathrm{eval}}\\in\\{0.20,0.30,0.40\\}$ MeV$/\\hbar$ 处计算 $i_x(\\omega)$ 的值。如果一个评估频率低于可用的最小离散 $\\omega$ 或高于最大离散 $\\omega$，则在插值前将其钳位到最近的可用 $\\omega$ 值。以 $\\hbar$ 为单位报告 $i_x(\\omega_{\\mathrm{eval}})$。\n- 将所有报告的浮点数输出四舍五入到三位小数。\n\n物理单位：自旋 $I$ 的单位为 $\\hbar$。能量 $E$ 的单位为 MeV。转动频率 $\\omega$ 的单位为 MeV$/\\hbar$。参数 $J_0$ 和 $J_1$ 的单位分别为 $\\hbar^2/\\mathrm{MeV}$ 和 $\\hbar^4/\\mathrm{MeV}^3$。增量顺排 $i_x$ 的单位为 $\\hbar$。\n\n测试套件和要求输出：\n- 您必须实现程序来处理以下三组参数；每组参数定义一个合成带以及一个拟合和评估任务。对于每组参数，您的程序必须输出一个包含五个浮点数的列表：拟合的 $\\hat J_0$、拟合的 $\\hat J_1$，以及三个值 $i_x(0.20)$、$i_x(0.30)$、$i_x(0.40)$，并按此顺序排列。程序必须将这三个列表聚合成一个单独的外层列表，并将其作为唯一的输出行打印。\n\n- 参数集：\n    1. 集合 A (理想情况):\n        - $J_0^{(\\mathrm{true})}=30.0$, $J_1^{(\\mathrm{true})}=80.0$, $i_{\\mathrm{align}}=8.0$, $\\omega_c=0.32$, $\\Delta\\omega=0.03$, $I_{\\max}=28$, $\\omega_{\\max}^{(\\mathrm{fit})}=0.28$, $A_{\\mathrm{noise}}=0.0$。\n    2. 集合 B (有噪声，能级较少):\n        - $J_0^{(\\mathrm{true})}=28.0$, $J_1^{(\\mathrm{true})}=60.0$, $i_{\\mathrm{align}}=7.0$, $\\omega_c=0.30$, $\\Delta\\omega=0.02$, $I_{\\max}=20$, $\\omega_{\\max}^{(\\mathrm{fit})}=0.26$, $A_{\\mathrm{noise}}=0.001$。\n    3. 集合 C (较弱、延迟的回弯):\n        - $J_0^{(\\mathrm{true})}=32.0$, $J_1^{(\\mathrm{true})}=70.0$, $i_{\\mathrm{align}}=4.0$, $\\omega_c=0.42$, $\\Delta\\omega=0.04$, $I_{\\max}=28$, $\\omega_{\\max}^{(\\mathrm{fit})}=0.30$, $A_{\\mathrm{noise}}=0.0$。\n\n算法约束和数值细节：\n- 对于给定的 $I$ 求解 $\\omega$ 的隐式方程，请在 $\\omega\\in[0,\\omega_{\\max}]$ 上使用一个稳健的求根区间法，并使用足够大的 $\\omega_{\\max}$ 以确保集合中所有 $I$ 的解都能被包围；如果需要，自动扩展区间。将 $I=0$ 作为 $\\omega=0$ 处理。\n- 使用关于 $I$ 的梯形法则，从解出的 $\\omega(I)$ 构建 $E(I)$。\n- 对于拟合，如果满足 $\\omega\\le\\omega_{\\max}^{(\\mathrm{fit})}$ 的点少于两个，则通过包含最小 $\\omega$ 的点来扩展拟合集，直到至少有两个点可用。\n- 对于在评估频率下对 $i_x(\\omega)$ 进行插值，请使用关于 $\\omega$ 的线性插值，并在边界处进行钳位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个内部列表的列表，每个内部列表按 A、B、C 的顺序对应一组参数，并包含五个四舍五入到三位小数的浮点数：$[\\hat J_0,\\hat J_1,i_x(0.20),i_x(0.30),i_x(0.40)]$。打印的行必须只包含此列表，不含任何额外文本。数字必须用上述指定的单位表示。", "solution": "用户提供了一个关于原子核物理的计算问题，涉及分析偶偶核转动带中的回弯现象。该问题具有科学依据，提法明确，并为多步数值计算过程提供了一套完整的指令。因此，该问题被认为是有效的。解决方案将按照所概述的任务顺序构建。\n\n问题的核心是模拟并分析一个转动带。这包括四个主要阶段：\n1.  基于自旋 $I$ 作为转动频率 $\\omega$ 函数的唯象模型，生成合成转动带能量 $E(I)$。\n2.  使用有限差分近似，从合成能量中计算离散转动频率 $\\omega(I)$，以模仿对实验数据的分析。\n3.  通过对转动带的低频部分进行线性最小二乘拟合，估计定义平滑参考转动惯量的 Harris 参数 $J_0$ 和 $J_1$。\n4.  计算和评估增量顺排 $i_x$，它量化了转动带自旋与平滑参考之间的偏差。\n\n每个步骤将按照指定的方式进行算法实现。\n\n**1. 合成带生成**\n\n合成数据的基础是自旋 $I$ 和转动频率 $\\omega$ 之间的关系。提供的模型是：\n$$\nI(\\omega) = J_0^{(\\mathrm{true})}\\,\\omega + J_1^{(\\mathrm{true})}\\,\\omega^3 + \\frac{i_{\\mathrm{align}}}{1+\\exp\\!\\left(-\\frac{\\omega-\\omega_c}{\\Delta\\omega}\\right)}\n$$\n这个方程定义了给定频率下的自旋。前两项 $J_0^{(\\mathrm{true})}\\,\\omega + J_1^{(\\mathrm{true})}\\,\\omega^3$ 代表了平滑、无相互作用转子的 Harris 参数化。第三项是一个逻辑斯谛函数，它引入了一个快速、局域化的自旋增长，称为顺排增益，其量值为 $i_{\\mathrm{align}}$，中心位于临界频率 $\\omega_c$ 附近。该项模拟了一对高 $j$ 核子与转动轴的顺排，这是回弯的微观原因。\n\n为了生成转动带，我们需要对于一组给定的离散偶数自旋 $I \\in \\{0, 2, 4, \\dots, I_{\\max}\\}$，求出其频率 $\\omega$。这需要对每个自旋 $I$ 求解隐式方程 $I = I(\\omega)$ 以得到 $\\omega$。对于 $I=0$，解是平凡的 $\\omega=0$。对于 $I0$，方程 $I(\\omega) - I = 0$ 必须进行数值求解。由于对于正参数，函数 $I(\\omega)$ 是单调递增的，因此对于任何 $I  0$ 都存在一个唯一的根 $\\omega  0$。一个稳健的求根算法，如 Brent-Dekker 方法，适合此任务。我们将定义函数 $f(\\omega, I) = I(\\omega) - I$ 并在一个搜索区间内（例如 $[0, 1.0]$ MeV$/\\hbar$）寻找它的根，如有必要则扩展该区间。\n\n一旦确定了每个自旋 $I$ 对应的平滑频率 $\\omega(I)$，就可以通过对基本关系 $dE = \\omega\\,dI$ 进行数值积分来构建相应的激发能 $E(I)$。使用梯形法则，对于自旋步长 $\\Delta I = 2$，能级 $I_k$ 的能量可以从前一个能级 $I_{k-1}$ 递归计算得出：\n$$\nE(I_k) = E(I_{k-1}) + \\int_{I_{k-1}}^{I_k} \\omega(I') dI' \\approx E(I_{k-1}) + \\frac{\\omega(I_k) + \\omega(I_{k-1})}{2} \\Delta I\n$$\n当 $I_k = 2k$，$I_{k-1}=2(k-1)$ 且 $\\Delta I = 2$ 时，这简化为 $E(2k) = E(2(k-1)) + \\omega(2k) + \\omega(2(k-1))$。转动带从 $E(0)=0$ 开始。\n\n最后，向每个计算出的能量 $E(I)$ 添加一个确定性噪声项 $n(I) = A_{\\mathrm{noise}}\\sin(\\pi I/6)$，以模拟实验不确定性或小的非转动效应。\n\n**2. 转动频率计算**\n\n从离散的合成能量集合 $\\{E(I)\\}$ 中，我们使用标准的中心有限差分近似来计算导数 $\\omega = dE/dI$，从而得到转动频率：\n$$\n\\omega(I) \\approx \\frac{E(I+\\Delta I/2) - E(I-\\Delta I/2)}{\\Delta I}\n$$\n对于自旋步长为 $\\Delta I=2$ 的偶偶核，频率通常在能级之间的中间自旋处计算。然而，本问题指定了一个以能级为中心的对称有限差分，这需要来自相邻能级的能量：\n$$\n\\omega(I) = \\frac{E(I+2) - E(I-2)}{4}\n$$\n此公式应用于转动带的所有内部自旋，即 $I \\in \\{2, 4, \\dots, I_{\\max}-2\\}$，在这些点上所需的能量值 $E(I\\pm2)$ 是可用的。\n\n**3. Harris 参数估计**\n\n下一步是拟合 Harris 参数 $J_0$ 和 $J_1$，以为转动带的行为建立一个参考。模型为 $I \\approx J_0 \\omega + J_1 \\omega^3$。这是一个线性回归问题，其中因变量是 $I$，自变量（回归量）是 $\\omega$ 和 $\\omega^3$。待确定的系数是 $\\hat J_0$ 和 $\\hat J_1$。\n\n拟合仅限于 $\\omega(I) \\le \\omega_{\\max}^{(\\mathrm{fit})}$ 的低频数据点，因为 Harris 参数化旨在描述顺排开始前的转动带。如果此条件产生的数据点少于两个，则通过包含频率最小的点来扩展该集合，直到至少有两个点可用，以确保问题是良定义的。\n\n拟合使用普通最小二乘法进行。我们求解矩阵方程 $A\\mathbf{x} = \\mathbf{b}$ 以得到参数向量 $\\mathbf{x} = [\\hat J_0, \\hat J_1]^T$，其中 $\\mathbf{b}$ 是自旋值 $I$ 的向量，$A$ 是设计矩阵，其列是对应的 $\\omega$ 和 $\\omega^3$ 值。最小二乘解由 $\\hat{\\mathbf{x}} = (A^T A)^{-1} A^T \\mathbf{b}$ 给出。\n\n**4. 增量顺排**\n\n增量顺排 $i_x$ 衡量在给定频率下，原子核相对于平滑 Harris 参考所获得的自旋。其定义为：\n$$\ni_x(\\omega) = I(\\omega) - I_{\\mathrm{ref}}(\\omega) = I(\\omega) - (\\hat J_0 \\omega + \\hat J_1 \\omega^3)\n$$\n使用拟合的参数 $\\hat J_0$ 和 $\\hat J_1$，我们为所有内部自旋使用其对应的离散频率 $\\{\\omega(I)\\}$ 计算出一组离散的顺排值 $\\{i_x(I)\\}$。\n\n最后的任务是确定在三个特定的评估频率 $\\omega_{\\mathrm{eval}} \\in \\{0.20, 0.30, 0.40\\}$ MeV$/\\hbar$ 处的顺排值。这通过对离散数据对 $(\\omega(I), i_x(I))$ 进行线性插值来实现。问题指定了钳位处理：如果一个评估频率超出了计算出的离散频率范围 $[\\min(\\omega), \\max(\\omega)]$，则使用最近边界点的顺排值。标准的插值函数，如 `numpy.interp`，自然地处理了这种行为。\n\n每组参数得到的五个值——拟合的 $\\hat J_0$ 和 $\\hat J_1$，以及三个插值得到的顺排值 $i_x(\\omega_{\\mathrm{eval}})$——被四舍五入到三位小数，并作为最终输出。整个过程被封装在一个程序中，该程序遍历所提供的测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Set A (happy path)\n        {\n            \"J0_true\": 30.0, \"J1_true\": 80.0, \"ialign\": 8.0, \n            \"wc\": 0.32, \"dw\": 0.03, \"I_max\": 28, \n            \"omega_max_fit\": 0.28, \"A_noise\": 0.0\n        },\n        # Set B (noisy, fewer levels)\n        {\n            \"J0_true\": 28.0, \"J1_true\": 60.0, \"ialign\": 7.0, \n            \"wc\": 0.30, \"dw\": 0.02, \"I_max\": 20, \n            \"omega_max_fit\": 0.26, \"A_noise\": 0.001\n        },\n        # Set C (weaker, delayed backbend)\n        {\n            \"J0_true\": 32.0, \"J1_true\": 70.0, \"ialign\": 4.0, \n            \"wc\": 0.42, \"dw\": 0.04, \"I_max\": 28, \n            \"omega_max_fit\": 0.30, \"A_noise\": 0.0\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = process_case(params)\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    output_str = \"[\" + \",\".join([\n        \"[{:.3f},{:.3f},{:.3f},{:.3f},{:.3f}]\".format(*res) \n        for res in all_results\n    ]) + \"]\"\n\n    print(output_str)\n\ndef _i_of_omega_model(omega, J0, J1, ialign, wc, dw):\n    \"\"\"The implicit model for I as a function of omega.\"\"\"\n    if omega == 0.0:\n        return 0.0\n    harris_term = J0 * omega + J1 * omega**3\n    alignment_term = ialign / (1.0 + np.exp(-(omega - wc) / dw))\n    return harris_term + alignment_term\n\ndef _find_omega_for_spin(I, params):\n    \"\"\"Solves the implicit equation I = I(omega) for omega.\"\"\"\n    if I == 0:\n        return 0.0\n\n    j0t, j1t, ia, wc, dw = params[\"J0_true\"], params[\"J1_true\"], params[\"ialign\"], params[\"wc\"], params[\"dw\"]\n\n    def root_func(omega):\n        return _i_of_omega_model(omega, j0t, j1t, ia, wc, dw) - I\n\n    # Robust root finding with expanding bracket\n    a, b = 1e-9, 1.0  # Start with a small interval [0, 1]\n    fa, fb = root_func(a), root_func(b)\n    \n    while np.sign(fa) == np.sign(fb):\n        b *= 2.0\n        if b > 100:  # Safety break\n            raise RuntimeError(f\"Could not bracket root for I={I}\")\n        fb = root_func(b)\n        \n    return brentq(root_func, a, b)\n\n\ndef process_case(params):\n    \"\"\"\n    Executes the full analysis workflow for a single parameter set.\n    \"\"\"\n    I_max = params[\"I_max\"]\n    spins = np.arange(0, I_max + 1, 2, dtype=float)\n\n    # 1. Generate synthetic band data\n    # 1a. Solve for smooth omega(I) for each spin\n    omega_smooth = np.array([_find_omega_for_spin(I, params) for I in spins])\n\n    # 1b. Integrate to get energies E(I) using trapezoidal rule\n    n_levels = len(spins)\n    E_synth = np.zeros(n_levels)\n    # E(I_k) = E(I_{k-1}) + (omega(I_k)+omega(I_{k-1}))/2 * deltaI, with deltaI=2\n    # E(2k) = E(2(k-1)) + omega_smooth[k] + omega_smooth[k-1]\n    for k in range(1, n_levels):\n        E_synth[k] = E_synth[k-1] + omega_smooth[k] + omega_smooth[k-1]\n\n    # 1c. Add deterministic noise\n    A_noise = params[\"A_noise\"]\n    if A_noise != 0.0:\n        noise = A_noise * np.sin(math.pi * spins / 6.0)\n        E_synth += noise\n\n    # 2. Compute discrete frequencies omega(I) from energies\n    # Interior spins are 2, 4, ..., I_max-2\n    I_interior = spins[1:-1]\n    \n    # E(I) is at index I/2. So E(I-2) -> index k-1, E(I+2) -> k+1 for spin I=2k\n    # omega(I=2k) = (E_synth[k+1] - E_synth[k-1]) / 4\n    omega_discrete = (E_synth[2:] - E_synth[:-2]) / 4.0\n\n    # 3. Fit Harris parameters J0 and J1\n    # 3a. Select low-frequency data for fitting\n    omega_max_fit = params[\"omega_max_fit\"]\n    fit_mask = omega_discrete = omega_max_fit\n    \n    # 3b. Ensure at least 2 points for the fit\n    if np.sum(fit_mask)  2:\n        # Sort by omega and take the first two points\n        sorted_indices = np.argsort(omega_discrete)\n        fit_indices = sorted_indices[:2]\n        I_fit = I_interior[fit_indices]\n        omega_fit = omega_discrete[fit_indices]\n    else:\n        I_fit = I_interior[fit_mask]\n        omega_fit = omega_discrete[fit_mask]\n\n    # 3c. Perform linear least squares fit: I = J0*w + J1*w^3\n    A = np.vstack([omega_fit, omega_fit**3]).T\n    b = I_fit\n    J_hat, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n    J0_hat, J1_hat = J_hat[0], J_hat[1]\n\n    # 4. Compute and interpolate incremental alignment i_x\n    # 4a. Calculate i_x for all interior points\n    I_ref = J0_hat * omega_discrete + J1_hat * omega_discrete**3\n    ix_discrete = I_interior - I_ref\n\n    # 4b. Interpolate at evaluation frequencies with clamping\n    omega_eval = np.array([0.20, 0.30, 0.40])\n    # np.interp handles clamping by default\n    ix_interpolated = np.interp(omega_eval, omega_discrete, ix_discrete)\n    \n    # 5. Collate and return results (will be rounded later)\n    return [J0_hat, J1_hat, ix_interpolated[0], ix_interpolated[1], ix_interpolated[2]]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3543269"}, {"introduction": "为了理解回弯的微观起源，我们必须转向理论模型，如曲柄平均场理论。这项高级练习 [@problem_id:3543335] 涉及实现一个曲柄 Bardeen-Cooper-Schrieffer (BCS) 求解器，以研究核子对关联与转动力之间的竞争如何决定回弯的发生。通过改变对力强度 $G$，你将直接观察到它在控制准粒子顺排发生的转动频率方面的关键作用。", "problem": "您需要实现一个自洽摇摆 Bardeen–Cooper–Schrieffer (BCS) 求解器，以量化在由等间距单粒子能级构成的有限体系中，对力强度如何控制回弯频率。该计算必须在一个简化但科学上一致的摇摆平均场模型中进行，其目标是对于每种对力强度，从角动量随转动频率变化的曲率中提取回弯频率。最终输出必须是包含一个浮点数列表的单行文本。\n\n本任务的基础是摇摆模型和 Bardeen–Cooper–Schrieffer 理论。考虑一个受摇摆影响的单粒子哈密顿量，\n$$\n\\hat{H}'(\\omega) = \\hat{H} - \\omega \\hat{J}_x,\n$$\n其中 $\\omega$ 是转动频率（单位为 $\\mathrm{MeV}/\\hbar$），$\\hat{J}_x$ 是沿摇摆轴的角动量算符。摇摆 Bardeen–Cooper–Schrieffer 准粒子谱是根据一组单粒子能级计算得出的，其能量 $\\{\\varepsilon_k\\}$ 因科里奥利项而发生移动，\n$$\ne_k(\\omega) = \\varepsilon_k - \\omega j_{x,k},\n$$\n其中 $j_{x,k}$ 是能级 $k$ 上 $\\hat{J}_x$ 的单粒子期望值（单位为 $\\hbar$）。对于一个具有恒定对力相互作用强度 $G$（单位为 $\\mathrm{MeV}$）的偶核体系，在每个 $\\omega$ 处的摇摆 Bardeen–Cooper–Schrieffer 能隙方程和粒子数方程为\n$$\n\\frac{1}{G} = \\sum_{k=1}^{M} \\frac{1}{2 E_k}, \\quad E_k = \\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2},\n$$\n$$\nN = 2 \\sum_{k=1}^{M} v_k^2, \\quad v_k^2 = \\frac{1}{2}\\left(1 - \\frac{e_k(\\omega) - \\lambda}{E_k}\\right),\n$$\n其中 $M$ 是双重简并能级的数量，$\\Delta$ 是对能隙，$\\lambda$ 是化学势，$N$ 是总粒子数（偶数）。当对关联坍缩（$\\Delta = 0$）时，必须使用具有阶梯函数形式占据数的正常相来满足粒子数约束。\n\n将摇摆 Bardeen–Cooper–Schrieffer 的劳斯函数 (Routhian) 期望值定义为\n$$\nE_{\\mathrm{R}}(\\omega) = 2 \\sum_{k=1}^M e_k(\\omega)\\, v_k^2 - \\frac{\\Delta^2}{G}.\n$$\n为强制满足关系式 $J(\\omega) = \\partial E(\\omega)/\\partial \\omega$ 作为角动量的工作定义，我们定义\n$$\nE(\\omega) \\equiv - E_{\\mathrm{R}}(\\omega),\n$$\n这样，对 $\\omega$ 求导即可得到摇摆定态解中的角动量，这与 Hellmann–Feynman 原理一致。您必须在 $\\omega$ 的均匀网格上，使用有限差分法从 $E(\\omega)$ 数值计算 $J(\\omega)$。\n\n回弯频率在数值上定义为离散导数 $dJ/d\\omega$ 达到显著局域最大值时的 $\\omega$ 值，这对应于排列角动量的最急剧增长。为稳健地探测此现象，您必须：\n- 在间距为 $\\delta \\omega$ 的均匀网格 $\\omega \\in [0, \\omega_{\\max}]$ 上计算 $E(\\omega)$，在每个 $\\omega$ 处求解摇摆 Bardeen–Cooper–Schrieffer 方程以得到 $(\\Delta(\\omega), \\lambda(\\omega))$，并通过 $\\partial E/\\partial \\omega$ 的中心有限差分近似来评估 $J(\\omega)$。\n- 计算离散导数 $dJ/d\\omega$，并通过一个短程移动平均对其进行平滑处理，以减少数值噪声。\n- 在网格内部识别平滑后 $dJ/d\\omega$ 的全局最大值索引，并且当且仅当峰的显著性超过由 $dJ/d\\omega$ 整体分布范围决定的最小对比度阈值时，才将对应的 $\\omega$ 声明为回弯频率。如果不存在显著的最大值，则返回一个哨兵值。\n\n使用以下科学上合理且自洽的模型参数：\n- （对简并）能级数：$M = 12$。\n- 单粒子能量：$\\varepsilon_k$ 在 $-2.75\\,\\mathrm{MeV}$ 到 $+2.75\\,\\mathrm{MeV}$ 之间等间距分布。\n- 单粒子摇摆矩阵元：对于 $k = 0, 1, \\ldots, 11$，$j_{x,k} = 0.5 + 0.05\\,k$，并在费米面附近设置两个闯入高 $j$ 能级 $j_{x,5} = 6.0$ 和 $j_{x,6} = 6.0$ 来模拟驱动排列的轨道。\n- 总粒子数：$N = 12$。\n- 转动频率网格：$\\omega \\in [0, 0.5]\\,\\mathrm{MeV}/\\hbar$，均匀间距 $\\delta\\omega = 0.005\\,\\mathrm{MeV}/\\hbar$。\n- 在 $\\Delta = 0$ 的正常相中，通过填充 $e_k(\\omega)$ 能级直至达到 $N/2$ 对粒子来强制满足粒子数方程，并在最高占据能级和最低未占能级之间选择 $\\lambda$；如果费米面上出现简并，则允许简并能级有分数占据以精确满足 $N$。\n\n程序必须在没有任何外部输入的情况下实现上述内容，并为固定测试套件中的每种对力强度生成回弯频率，格式化为单个列表。如果在网格内未检测到 $dJ/d\\omega$ 的显著最大值（即，相对于 $dJ/d\\omega$ 的分布范围，峰的显著性在统计上不显著），则为该对力强度返回哨兵值 $-1.0$。\n\n测试套件：\n- 对力强度值 $G$（单位为 $\\mathrm{MeV}$）：$[\\,0.15,\\,0.30,\\,0.50,\\,0.80\\,]$。\n- 对于列表中的每个 $G$，按上述方法计算回弯频率。\n- 将每个结果报告为浮点数，四舍五入到三位小数，单位为 $\\mathrm{MeV}/\\hbar$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：$[0.125,0.200,-1.000,0.310]$。\n- 每个条目对应测试套件中相应 $G$ 值的回弯频率，单位为 $\\mathrm{MeV}/\\hbar$，四舍五入到三位小数，当未检测到显著最大值时使用哨兵值 $-1.000$。", "solution": "所提供的问题是计算核物理领域一个良定且有科学依据的任务。所有参数和步骤都已明确指定，从而可以得到一个确定性且可验证的解。其基础物理基于摇摆 Bardeen–Cooper–Schrieffer (BCS) 模型，这是研究原子核转动性质的标准理论框架。因此，该问题被认为是**有效的**。\n\n解决方案涉及实现一个自洽摇摆 BCS 求解器，以确定作为转动频率 $\\omega$ 函数的对能隙 $\\Delta$ 和化学势 $\\lambda$。然后利用这些数据计算角动量 $J(\\omega)$ 及其导数 $dJ/d\\omega$，以识别回弯频率。其核心原理是 Hellmann–Feynman 定理，该定理将能量的导数与相应算符的期望值联系起来。\n\n**步骤 1：模型定义与参数化**\n该体系由一组 $M=12$ 个双重简并的单粒子能级定义，其能量为 $\\{\\varepsilon_k\\}$，角动量投影为 $\\{j_{x,k}\\}$。摇摆单粒子能量由 $e_k(\\omega) = \\varepsilon_k - \\omega j_{x,k}$ 给出。参数按规定固定：$\\varepsilon_k$ 在 $-2.75\\,\\mathrm{MeV}$ 到 $+2.75\\,\\mathrm{MeV}$ 之间线性分布；对于 $k \\in \\{0, \\ldots, 11\\}$，$j_{x,k} = 0.5 + 0.05\\,k$，其中在 $k=5, 6$ 处的闯入态具有 $j_{x,5}=6.0$ 和 $j_{x,6}=6.0$。该体系包含 $N=12$ 个粒子。计算是针对一系列对力强度 $G \\in [\\,0.15,\\,0.30,\\,0.50,\\,0.80\\,]\\,\\mathrm{MeV}$，在转动频率的均匀网格 $\\omega \\in [0, 0.5]\\,\\mathrm{MeV}/\\hbar$ 上进行的，步长为 $\\delta\\omega = 0.005\\,\\mathrm{MeV}/\\hbar$。\n\n**步骤 2：自洽摇摆 BCS 求解器**\n对于每个对力强度 $G$ 的值以及每个网格点 $\\omega$，我们必须求解一个关于对能隙平方 $\\Delta^2$ 和化学势 $\\lambda$ 的耦合非线性方程组：\n$$\n\\frac{2}{G} = \\sum_{k=1}^{M} \\frac{1}{\\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2}} \\quad (\\text{能隙方程})\n$$\n$$\nN = \\sum_{k=1}^{M} \\left(1 - \\frac{e_k(\\omega) - \\lambda}{\\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2}}\\right) \\quad (\\text{粒子数方程})\n$$\n这些方程通过数值方法求解。为确保稳健性和效率，我们采用一个标准的求根算法，具体是 `scipy.optimize.root`。我们求解变量 $(\\Delta^2, \\lambda)$，这自然地强制了物理约束 $\\Delta \\ge 0$。前一个频率步长的解 $(\\Delta^2(\\omega-\\delta\\omega), \\lambda(\\omega-\\delta\\omega))$ 作为当前步长的绝佳初始猜测值，确保了在整个频率网格上的平滑收敛。\n\n如果求解器未能在小的数值容差内找到 $\\Delta^2 > 0$ 的解，这标志着向正常（非配对）相的转变。在这种情况下，我们设置 $\\Delta=0$，并通过对无相互作用的费米气体强制执行粒子数守恒来确定 $\\lambda$：最低的 $N/2=6$ 个摇摆单粒子能级 $e_k(\\omega)$ 被填充。化学势 $\\lambda$ 被设置为最高占据能级和最低未占能级的中点。\n\n**步骤 3：角动量计算**\n在确定 $(\\Delta(\\omega), \\lambda(\\omega))$ 后，我们计算摇摆 BCS 劳斯函数：\n$$\nE_{\\mathrm{R}}(\\omega) = 2 \\sum_{k=1}^M e_k(\\omega)\\, v_k^2 - \\frac{\\Delta^2(\\omega)}{G}\n$$\n其中 $v_k^2 = \\frac{1}{2}\\left(1 - \\frac{e_k(\\omega) - \\lambda}{E_k}\\right)$ 是占据概率，$E_k = \\sqrt{(e_k(\\omega)-\\lambda)^2 + \\Delta^2}$ 是准粒子能量。能量 $E(\\omega)$ 定义为 $E(\\omega) = -E_{\\mathrm{R}}(\\omega)$，根据 Hellmann–Feynman 定理，这确保了总角动量由 $J_x(\\omega) = \\frac{\\partial E(\\omega)}{\\partial \\omega}$ 给出。我们在计算出的 $E(\\omega)$ 网格上，使用二阶中心有限差分近似来数值计算 $J_x(\\omega)$：\n$$\nJ_x(\\omega_i) \\approx \\frac{E(\\omega_{i+1}) - E(\\omega_{i-1})}{2\\delta\\omega}\n$$\n\n**步骤 4：回弯频率的识别**\n回弯的特征是角动量 $J_x$ 随频率 $\\omega$ 的快速增加，这表现为导数 $dJ_x/d\\omega$ 中的一个尖峰。该导数也通过中心有限差分计算。为减轻微分固有的数值噪声，得到的 $dJ_x/d\\omega$ 信号使用 3 点移动平均进行平滑处理。\n\n回弯频率 $\\omega_{\\text{bb}}$ 按照一个精确的算法步骤来识别：\n1.  定位平滑后的 $dJ_x/d\\omega$ 信号的全局最大值索引。\n2.  进行检查以确保该最大值出现在频率网格的内部，而不是在端点，因为端点不能代表模型动态范围内的物理转折点。\n3.  使用 `scipy.signal.peak_prominences` 计算此最大值的显著性。峰的显著性衡量它从周围信号中脱颖而出的程度。\n4.  将此显著性与一个动态阈值进行比较，该阈值定义为平滑后 $dJ_x/d\\omega$ 信号的标准差。这确保了只考虑统计上显著的峰。\n5.  如果全局最大值是一个内部峰，并且其显著性超过阈值，则将相应的频率 $\\omega$ 识别为回弯频率 $\\omega_{\\text{bb}}$。\n6.  如果对于给定的对力强度 $G$ 未找到此类显著峰，则分配哨兵值 $-1.0$。\n\n对测试套件中的每个 $G$ 值重复此整个过程，得出一系列回弯频率，这些频率量化了对关联对转动排列的影响。最终结果按要求格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\nfrom scipy.signal import find_peaks, peak_prominences\n\ndef solve():\n    \"\"\"\n    Main function to implement the self-consistent cranked BCS solver and find the backbending frequency.\n    \"\"\"\n\n    def get_bb_frequency(G, M, N, eps, jx, omega_grid, delta_omega):\n        \"\"\"\n        Calculates the backbending frequency for a single pairing strength G.\n        \"\"\"\n        routhians = []\n        # Initial guess for the solver at omega=0.\n        # lam=0 due to symmetry, delta ~ G.\n        # We solve for delta^2, so initial guess is G^2.\n        d2_prev, lam_prev = G**2, 0.0\n\n        for omega in omega_grid:\n            ek = eps - omega * jx\n\n            def bcs_equations(variables, G_val, ek_vals, N_val):\n                d2, lam = variables\n                if d2  0:\n                    d2 = 1e-12 # Enforce delta^2 >= 0\n                \n                ek_prime = ek_vals - lam\n                Ek = np.sqrt(ek_prime**2 + d2)\n                # Add a small value to denominator to prevent division by zero\n                Ek[Ek  1e-12] = 1e-12\n\n                # Gap Equation: sum(1/Ek) - 2/G = 0\n                eq1 = np.sum(1.0 / Ek) - 2.0 / G_val\n                # Number Equation: sum(1 - (ek-lam)/Ek) - N = 0\n                eq2 = np.sum(1.0 - ek_prime / Ek) - N_val\n\n                return [eq1, eq2]\n\n            # Solve for (delta^2, lambda)\n            sol = root(bcs_equations, [d2_prev, lam_prev], args=(G, ek, N), method='hybr', tol=1e-8)\n            \n            d2, lam = 0.0, 0.0\n\n            # Check for a converged, paired solution\n            if sol.success and sol.x[0] > 1e-8:\n                d2, lam = sol.x\n                d2 = max(0, d2)\n                \n                ek_prime = ek - lam\n                Ek = np.sqrt(ek_prime**2 + d2)\n                vk2 = np.zeros_like(Ek)\n                # Use np.divide to handle potential division by zero safely\n                non_zero_Ek = Ek != 0\n                vk2[non_zero_Ek] = 0.5 * (1 - ek_prime[non_zero_Ek] / Ek[non_zero_Ek])\n                \n                # Routhian for paired system\n                e_R = 2 * np.sum(ek * vk2) - d2 / G\n            else:\n                # Normal (unpaired) phase\n                d2 = 0.0\n                sorted_ek = np.sort(ek)\n                lam = 0.5 * (sorted_ek[N//2 - 1] + sorted_ek[N//2])\n                \n                # Occupation numbers (vk^2)\n                vk2 = (ek  lam).astype(float)\n                num_at_fermi = np.sum(ek == lam)\n                if num_at_fermi > 0:\n                    num_below_fermi = np.sum(ek  lam)\n                    needed_occ = (N/2 - num_below_fermi) / num_at_fermi\n                    vk2[ek == lam] = needed_occ\n\n                # Routhian for normal system\n                e_R = 2 * np.sum(ek * vk2)\n            \n            routhians.append(e_R)\n            d2_prev, lam_prev = d2, lam\n\n        E_omega = -np.array(routhians)\n        \n        # Angular momentum J(omega) = dE/domega\n        if len(E_omega)  3: return -1.0\n        J_omega = (E_omega[2:] - E_omega[:-2]) / (2 * delta_omega)\n        \n        # Derivative dJ/domega\n        if len(J_omega)  3: return -1.0\n        dJ_domega = (J_omega[2:] - J_omega[:-2]) / (2 * delta_omega)\n        omega_for_dJ = omega_grid[2:-2]\n\n        # Smooth dJ/domega with a 3-point moving average\n        if len(dJ_domega)  3: return -1.0\n        smoothed_dJ = np.convolve(dJ_domega, np.ones(3)/3.0, mode='valid')\n        omega_for_smoothed = omega_for_dJ[1:-1]\n\n        if len(smoothed_dJ)  3: return -1.0\n        \n        # --- Peak Detection Logic ---\n        # 1. Find global maximum\n        idx_max = np.argmax(smoothed_dJ)\n\n        # 2. Check if it's an interior peak\n        if idx_max == 0 or idx_max == len(smoothed_dJ) - 1:\n            return -1.0\n\n        # 3. Calculate prominence of the global maximum\n        all_peaks, properties = find_peaks(smoothed_dJ, prominence=0)\n        \n        is_a_peak = np.where(all_peaks == idx_max)[0]\n        if len(is_a_peak) == 0:\n            return -1.0 # Global max is not a distinct peak (e.g., on a plateau)\n\n        prominence_of_max = properties['prominences'][is_a_peak[0]]\n\n        # 4. Compare prominence to threshold (std dev of signal)\n        threshold = np.std(smoothed_dJ)\n        if prominence_of_max > threshold:\n            return omega_for_smoothed[idx_max]\n        else:\n            return -1.0\n\n    # --- Main Execution ---\n    # Model parameters\n    M = 12\n    N = 12\n    eps = np.linspace(-2.75, 2.75, M)\n    jx = 0.5 + 0.05 * np.arange(M)\n    jx[5] = 6.0\n    jx[6] = 6.0\n    \n    delta_omega = 0.005\n    omega_grid = np.arange(0, 0.5 + delta_omega, delta_omega)\n    \n    # Test suite from the problem statement\n    test_cases = [0.15, 0.30, 0.50, 0.80]\n\n    results = []\n    for G in test_cases:\n        bb_freq = get_bb_frequency(G, M, N, eps, jx, omega_grid, delta_omega)\n        results.append(bb_freq)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```", "id": "3543335"}]}