{"hands_on_practices": [{"introduction": "随机相近似（RPA）是描述原子核集体振动的基石理论。这项实践将理论付诸实践，让你为一个示意性但富有启发性的模型构建并求解RPA矩阵。通过将完整的RPA计算结果与精确的求和规则进行比较，你将更深入地理解该方法的近似之处以及集体性的物理起源 [@problem_id:3550542]。", "problem": "考虑一个由$A$个无相互作用的全同费米子组成的有限系统，它们在一个一维谐振子平均场中运动，该平均场的角频率为$\\Omega$，质量设为$m=1$，约化普朗克常数设为$\\hbar=1$（无量纲单位）。单粒子哈密顿量为 $h = p^2/2 + \\tfrac{1}{2}\\Omega^2 x^2$，其本征能量为 $\\varepsilon_n = \\Omega\\left(n + \\tfrac{1}{2}\\right)$，其中 $n \\in \\mathbb{N}_0$。假设自旋简并度为 $g$，因此每个轨道可以容纳 $g$ 个费米子，并填充 $n_F$ 个轨道，总粒子数为 $A = g\\,n_F$。考虑类等标量单极单体算符 $F = \\sum_{i=1}^{A} x_i^2$。为了在随机相近似（RPA）中模拟剩余集体性，引入一个示意性的可分离两体相互作用 $V = \\tfrac{\\kappa}{2} F^2$，其耦合常数 $\\kappa \\ge 0$ 为实数。\n\n你的任务是：\n1. 从第一性原理推导，然后实现一种计算方法，用于在由谐振子的 $n \\to n+2$ 激发构建的粒子-空穴基上，使用准玻色子近似计算算符 $F$ 的离散RPA谱和强度。在此基上，粒子-空穴能量差为 $\\Delta E_n = \\varepsilon_{n+2} - \\varepsilon_n = 2\\Omega$，$x^2$ 的单体矩阵元为 $\\langle n | x^2 | n+2 \\rangle = \\sqrt{(n+1)(n+2)}/(2\\Omega)$。通过将这些矩阵元乘以因子 $\\sqrt{g}$ 来计入自旋简并度 $g$。\n2. 构建RPA矩阵 $A$ 和 $B$ 为\n$$ A_{mn} = \\Delta E_m\\,\\delta_{mn} + \\kappa\\,f_m f_n,\\quad B_{mn} = \\kappa\\,f_m f_n, $$\n其中 $f_n = \\sqrt{g}\\,\\langle n | x^2 | n+2 \\rangle$。然后构建 $2N \\times 2N$ 的RPA矩阵\n$$ \\mathcal{M} = \\begin{pmatrix} A  B \\\\ -B  -A \\end{pmatrix}, $$\n对其进行对角化，选取正的本征频率 $\\omega_\\nu > 0$，并得到满足准玻色子归一化条件 $X^{(\\nu)T} X^{(\\nu)} - Y^{(\\nu)T} Y^{(\\nu)} = 1$ 的相应归一化本征矢量 $(X^{(\\nu)}, Y^{(\\nu)})$。\n3. 对每个RPA模式，计算 $F$ 的跃迁振幅 $T_\\nu = \\sum_n f_n\\left(X^{(\\nu)}_n + Y^{(\\nu)}_n\\right)$，以及相应的强度 $S_\\nu = |T_\\nu|^2$。然后计算离散RPA求和规则\n$$ m_k^{\\text{RPA}} = \\sum_\\nu \\omega_\\nu^{\\,k} S_\\nu, $$\n其中 $k \\in \\{-1,0,1\\}$。\n4. 从基本对易关系 $[x,[p,x]] = i$ 和正则对易关系出发，通过双对易子技术独立地评估能量加权求和规则 $m_1$。证明对于谐振子平均场和算符 $F = \\sum_i x_i^2$，可以得到\n$$ [F,[H,F]] = 4 \\sum_{i=1}^{A} x_i^2, $$\n因此\n$$ m_1^{\\text{DC}} = \\frac{1}{2}\\langle 0 | [F,[H,F]] | 0 \\rangle = 2 \\langle 0 | F | 0 \\rangle. $$\n用 $\\Omega$、 $g$ 和 $n_F$ 表示并计算 $\\langle 0 | F | 0 \\rangle$，并为 $m_1^{\\text{DC}}$ 提供一个显式的闭式表达式。\n5. 使用约束Hartree-Fock-Bogoliubov (HFB) 技术（此处由于是闭壳层且无配对，等同于Hartree-Fock）评估逆能量加权求和规则 $m_{-1}$：通过在平均场哈密顿量中加入 $+\\lambda F$ 来引入一个约束，推导微扰后的频率 $\\Omega'(\\lambda)$，在约束基态中计算 $\\langle F \\rangle(\\lambda)$，并使用介电定理得到\n$$ m_{-1}^{\\text{CHF}} = -\\frac{1}{2}\\left.\\frac{d\\langle F \\rangle(\\lambda)}{d\\lambda}\\right|_{\\lambda=0}. $$\n用 $\\Omega$、 $g$ 和 $n_F$ 显式地表示 $m_{-1}^{\\text{CHF}}$。\n\n你必须实现一个单一、完整、可运行的程序，该程序能够：\n- 构建并解决指定的RPA问题。\n- 计算 $m_{-1}^{\\text{RPA}}$、$m_{0}^{\\text{RPA}}$ 和 $m_{1}^{\\text{RPA}}$。\n- 解析地计算参考值 $m_{1}^{\\text{DC}}$ 和 $m_{-1}^{\\text{CHF}}$。\n- 报告每个测试用例的相对差异：\n  - $\\delta_1 = \\left|m_{1}^{\\text{RPA}} - m_{1}^{\\text{DC}}\\right| / m_{1}^{\\text{DC}}$，\n  - $\\delta_2 = \\left|m_{-1}^{\\text{RPA}} - m_{-1}^{\\text{CHF}}\\right| / m_{-1}^{\\text{CHF}}$。\n\n所需的科学和数学基础：\n- 量子力学的正则对易关系、线性响应理论以及RPA的准玻色子近似。\n- 谐振子中 $x^2$ 的期望值和矩阵元。\n- 约束Hartree-Fock-Bogoliubov (HFB) 的介电定理，它将静态极化率与 $m_{-1}$ 联系起来。\n\n单位：所有量均采用与 $\\hbar = 1$、$m = 1$ 一致的无量纲单位，能量以 $\\Omega$ 为单位。不需要进行物理单位转换。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件：\n使用以下参数集 $(n_F, g, \\Omega, \\kappa)$ 来测试不同的机制和边界情况：\n- 情况1（正常路径，中等集体性）：$(2, 2, 1.25, 0.5)$。\n- 情况2（增加的填充数，中等耦合）：$(3, 2, 1.0, 0.4)$。\n- 情况3（较大的 $n_F$，较弱的耦合）：$(5, 1, 2.2, 0.3)$。\n- 情况4（接近Tamm-Dancoff极限的边界）：$(3, 1, 1.8, 1\\times 10^{-6})$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,...]”），结果是每个情况的浮点数序列 $\\delta_1, \\delta_2$，按照上述测试用例的顺序排列，总共八个浮点数。", "solution": "用户提供了一个计算核物理领域的详细问题，要求在随机相近似（RPA）和其他理论框架内计算和比较谱求和规则。\n\n### 第1步：问题验证\n\n我将首先提取给定信息，并根据指定标准验证问题陈述。\n\n**提取的给定信息：**\n\n1.  **系统**：一个由 $A$ 个全同无相互作用费米子组成的系统，位于一维谐振子（HO）平均场中。\n2.  **常数**：质量 $m=1$，约化普朗克常数 $\\hbar=1$。\n3.  **平均场**：单粒子哈密顿量 $h = p^2/2 + \\tfrac{1}{2}\\Omega^2 x^2$，其本征能量为 $\\varepsilon_n = \\Omega(n + \\tfrac{1}{2})$，其中 $n \\in \\mathbb{N}_0$。\n4.  **构型**：自旋简并度 $g$。填充的轨道数为 $n_F$，因此总粒子数为 $A = g\\,n_F$。\n5.  **算符**：类等标量单极算符 $F = \\sum_{i=1}^{A} x_i^2$。\n6.  **剩余相互作用**：$V = \\tfrac{\\kappa}{2} F^2$，耦合常数 $\\kappa \\ge 0$ 为实数。\n7.  **RPA基**：形式为 $n \\to n+2$ 的粒子-空穴（p-h）激发，其中 $n \\in \\{0, 1, \\dots, n_F-1\\}$。\n8.  **矩阵元和能量**：\n    -   粒子-空穴能量差：$\\Delta E_n = \\varepsilon_{n+2} - \\varepsilon_n = 2\\Omega$。\n    -   $x^2$ 的单粒子矩阵元：$\\langle n | x^2 | n+2 \\rangle = \\sqrt{(n+1)(n+2)}/(2\\Omega)$。\n    -   RPA矩阵元定义：$f_n = \\sqrt{g}\\,\\langle n | x^2 | n+2 \\rangle$。\n9.  **RPA矩阵（$A, B$）和超矩阵（$\\mathcal{M}$）**：\n    -   $A_{mn} = \\Delta E_m\\,\\delta_{mn} + \\kappa\\,f_m f_n = 2\\Omega\\,\\delta_{mn} + \\kappa\\,f_m f_n$。\n    -   $B_{mn} = \\kappa\\,f_m f_n$。\n    -   $\\mathcal{M} = \\begin{pmatrix} A  B \\\\ -B  -A \\end{pmatrix}$。\n10. **RPA解及其性质**：\n    -   对角化 $\\mathcal{M}$ 以找到正的本征频率 $\\omega_\\nu > 0$。\n    -   具有准玻色子模方 $X^{(\\nu)T} X^{(\\nu)} - Y^{(\\nu)T} Y^{(\\nu)} = 1$ 的归一化本征矢量 $(X^{(\\nu)}, Y^{(\\nu)})$。\n    -   跃迁振幅：$T_\\nu = \\sum_n f_n\\left(X^{(\\nu)}_n + Y^{(\\nu)}_n\\right)$。\n    -   强度：$S_\\nu = |T_\\nu|^2$。\n    -   RPA求和规则：$m_k^{\\text{RPA}} = \\sum_\\nu \\omega_\\nu^{\\,k} S_\\nu$，其中 $k \\in \\{-1, 0, 1\\}$。\n11. **双对易子（DC）求和规则（$m_1^{\\text{DC}}$）**：\n    -   使用的恒等式：$[F,[H,F]] = 4 \\sum_{i=1}^{A} x_i^2 = 4F$。\n    -   公式：$m_1^{\\text{DC}} = \\frac{1}{2}\\langle 0 | [F,[H,F]] | 0 \\rangle = 2 \\langle 0 | F | 0 \\rangle$。\n12. **约束Hartree-Fock（CHF）求和规则（$m_{-1}^{\\text{CHF}}$）**：\n    -   约束哈密顿量：$H' = H_0 + \\lambda F$。\n    -   公式（介电定理）：$m_{-1}^{\\text{CHF}} = -\\frac{1}{2}\\left.\\frac{d\\langle F \\rangle(\\lambda)}{d\\lambda}\\right|_{\\lambda=0}$。\n13. **测试用例**：四种情景下的 $(n_F, g, \\Omega, \\kappa)$：\n    -   情况1：$(2, 2, 1.25, 0.5)$\n    -   情况2：$(3, 2, 1.0, 0.4)$\n    -   情况3：$(5, 1, 2.2, 0.3)$\n    -   情况4：$(3, 1, 1.8, 1\\times 10^{-6})$\n14. **最终输出**：每个情况的相对差异 $\\delta_1 = |m_1^{\\text{RPA}} - m_1^{\\text{DC}}| / m_1^{\\text{DC}}$ 和 $\\delta_2 = |m_{-1}^{\\text{RPA}} - m_{-1}^{\\text{CHF}}| / m_{-1}^{\\text{CHF}}$。\n\n**使用提取的给定信息进行验证：**\n\n1.  **科学或事实不健全**：该问题在量子力学和核多体理论的原理上有坚实的基础。RPA、对易子方法和约束平均场理论都是标准技术。谐振子是基石模型，可分离相互作用是广泛使用的示意模型。未发现违规之处。\n2.  **不可形式化或不相关**：该问题是一个形式化的定量任务，直接关系到核物理中的集体振动激发。它不是隐喻性的或不相关的。未发现违规之处。\n3.  **不完整或矛盾的设置**：该问题提供了构建和求解RPA方程所需的所有必要定义、常数和公式，以及用于比较的解析求和规则的推导。将粒子-空穴空间截断为仅包含 $n \\to n+2$ 激发是一个明确的模型定义，而非遗漏。未发现矛盾之处。\n4.  **不切实际或不可行**：无量纲单位的使用和指定的参数在物理上和计算上都是合理的。未发现违规之处。\n5.  **不适定或结构不良**：可分离相互作用的RPA方程是适定的，并导出一组唯一的集体模式。问题的结构旨在引导用户完成一系列逻辑推导和计算。未发现违规之处。\n6.  **伪深刻、琐碎或同义反复**：该问题在概念上很深刻，需要理解为什么来自不同有效理论方法（RPA、DC、CHF）的结果可能会有所不同。这些差异源于RPA固有的近似（例如，准玻色子对易关系、截断的模型空间），使得比较并非无足轻重。未发现违规之处。\n7.  **超出科学可验证性**：所有计算和推导都基于可验证的数学和物理原理。未发现违规之处。\n\n**结论与行动：**\n问题是**有效的**。这是理论和计算物理学中一个定义明确且具有挑战性的练习。我将继续推导解答并实现程序。\n\n### 第2步：基于原理的解决方案和算法设计\n\n解决方案需要结合解析推导和数值计算。我将首先确定参考求和规则的解析形式，然后概述RPA计算的数值步骤。\n\n**解析推导**\n\n**A. 能量加权求和规则（$m_1^{\\text{DC}}$）**\n问题提供了求和规则公式 $m_1^{\\text{DC}} = 2 \\langle 0 | F | 0 \\rangle$。任务是评估 $F = \\sum_i x_i^2$ 的基态期望值。基态 $|0\\rangle$ 是由最低的 $n_F$ 个谐振子轨道构成的Slater行列式，每个轨道被 $g$ 个费米子占据。\n\n$F$ 的期望值是所有已占据态上单粒子期望值的总和：\n$$ \\langle 0 | F | 0 \\rangle = \\sum_{\\text{occupied } k} \\langle k | x^2 | k \\rangle $$\n考虑到自旋简并度 $g$，这变为：\n$$ \\langle 0 | F | 0 \\rangle = g \\sum_{n=0}^{n_F-1} \\langle n | x^2 | n \\rangle $$\n对于一维谐振子态 $|n\\rangle$，期望值为 $\\langle n | x^2 | n \\rangle = \\frac{1}{\\Omega}\\left(n + \\frac{1}{2}\\right)$。\n代入此式并计算求和：\n$$ \\langle 0 | F | 0 \\rangle = \\frac{g}{\\Omega} \\sum_{n=0}^{n_F-1} \\left(n + \\frac{1}{2}\\right) = \\frac{g}{\\Omega} \\left( \\frac{(n_F-1)n_F}{2} + \\frac{n_F}{2} \\right) = \\frac{g}{\\Omega} \\frac{n_F^2}{2} = \\frac{g n_F^2}{2\\Omega} $$\n因此，双对易子求和规则为：\n$$ m_1^{\\text{DC}} = 2 \\langle 0 | F | 0 \\rangle = \\frac{g n_F^2}{\\Omega} $$\n\n**B. 逆能量加权求和规则（$m_{-1}^{\\text{CHF}}$）**\n此求和规则使用平均场基态的静态极化率进行评估。平均场哈密顿量受到约束场 $+\\lambda F$ 的微扰。单粒子哈密顿量变为：\n$$ h' = h + \\lambda x^2 = \\frac{p^2}{2} + \\frac{1}{2}\\Omega^2 x^2 + \\lambda x^2 = \\frac{p^2}{2} + \\frac{1}{2}(\\Omega^2 + 2\\lambda)x^2 $$\n这是一个频率被修正为 $\\Omega'(\\lambda) = \\sqrt{\\Omega^2 + 2\\lambda}$ 的谐振子的哈密顿量。\n\n期望值 $\\langle F \\rangle(\\lambda)$ 是在这个约束系统的基态中计算的。该状态是通过填充新谐振子的最低 $n_F$ 个轨道形成的。计算过程与 $\\langle 0|F|0\\rangle$ 的计算类似，只是将 $\\Omega$ 替换为 $\\Omega'(\\lambda)$：\n$$ \\langle F \\rangle(\\lambda) = \\frac{g n_F^2}{2\\Omega'(\\lambda)} = \\frac{g n_F^2}{2\\sqrt{\\Omega^2 + 2\\lambda}} $$\n根据问题中表述的介电定理，我们需要关于 $\\lambda$ 的导数：\n$$ \\frac{d\\langle F \\rangle(\\lambda)}{d\\lambda} = \\frac{g n_F^2}{2} \\frac{d}{d\\lambda}(\\Omega^2 + 2\\lambda)^{-1/2} = \\frac{g n_F^2}{2} \\left[ -\\frac{1}{2}(\\Omega^2 + 2\\lambda)^{-3/2} \\cdot 2 \\right] = -\\frac{g n_F^2}{2}(\\Omega^2 + 2\\lambda)^{-3/2} $$\n在 $\\lambda = 0$ 处求值：\n$$ \\left.\\frac{d\\langle F \\rangle(\\lambda)}{d\\lambda}\\right|_{\\lambda=0} = -\\frac{g n_F^2}{2\\Omega^3} $$\n那么约束求和规则为：\n$$ m_{-1}^{\\text{CHF}} = -\\frac{1}{2}\\left.\\frac{d\\langle F \\rangle(\\lambda)}{d\\lambda}\\right|_{\\lambda=0} = -\\frac{1}{2} \\left( -\\frac{g n_F^2}{2\\Omega^3} \\right) = \\frac{g n_F^2}{4\\Omega^3} $$\n\n**数值RPA计算**\n\n数值任务的核心是求解RPA矩阵方程 $\\mathcal{M}Z = \\omega Z$。\n\n1.  **设置**：对于给定的参数集 $(n_F, g, \\Omega, \\kappa)$，粒子-空穴空间的维度为 $N = n_F$。\n2.  **矩阵构建**：\n    -   首先，计算大小为 $N$ 的向量 $f$，其元素为 $f_n = \\sqrt{g} \\frac{\\sqrt{(n+1)(n+2)}}{2\\Omega}$，其中 $n=0, \\dots, N-1$。\n    -   矩阵 $A$ 和 $B$ 是 $N \\times N$ 的。利用相互作用的可分离性：\n        -   $B = \\kappa \\, f f^T$ （外积）。\n        -   $A = (2\\Omega) I_N + B$，其中 $I_N$ 是单位矩阵。\n    -   构建 $2N \\times 2N$ 的RPA矩阵 $\\mathcal{M} = \\begin{pmatrix} A  B \\\\ -B  -A \\end{pmatrix}$。\n3.  **对角化**：\n    -   求解 $\\mathcal{M}$ 的本征值问题。由于 $\\mathcal{M}$ 是一个实的、非对称的“哈密顿矩阵”，其本征值将成对出现，即 $\\pm \\omega$。我们使用标准的数值库函数（例如 `scipy.linalg.eig`）。\n4.  **提取物理可行解**：\n    -   遍历计算出的本征值和本征矢量。\n    -   只选择具有正实数本征值的解，$\\omega_\\nu > 0$。\n    -   对于每个这样的解，提取相应的本征矢量 $Z^{(\\nu)} = (X^{(\\nu)}_u, Y^{(\\nu)}_u)^T$。标准本征求解器得到的矢量通常是L2归一化的，即 $(X^{(\\nu)}_u)^\\dagger X^{(\\nu)_u} + (Y^{(\\nu)_u)^\\dagger Y^{(\\nu)_u} = 1$。\n5.  **归一化和强度计算**：\n    -   对于每个物理本征矢量，计算准玻色子模方的平方：$N_q^2 = (X^{(\\nu)}_u)^T X^{(\\nu)}_u - (Y^{(\\nu)}_u)^T Y^{(\\nu)}_u$。对于物理态，该值必须为正。\n    -   正确归一化的RPA振幅为 $X^{(\\nu)} = X^{(\\nu)}_u / \\sqrt{N_q^2}$ 和 $Y^{(\\nu)} = Y^{(\\nu)}_u / \\sqrt{N_q^2}$。\n    -   计算跃迁振幅 $T_\\nu = \\sum_{n=0}^{N-1} f_n(X^{(\\nu)}_n + Y^{(\\nu)}_n) = f^T(X^{(\\nu)} + Y^{(\\nu)})$。\n    -   计算跃迁强度 $S_\\nu = |T_\\nu|^2$。\n6.  **RPA求和规则计算**：\n    -   将所有物理模式 $\\nu$ 的贡献相加，得到RPA求和规则：\n        -   $m_1^{\\text{RPA}} = \\sum_\\nu \\omega_\\nu S_\\nu$\n        -   $m_{-1}^{\\text{RPA}} = \\sum_\\nu \\omega_\\nu^{-1} S_\\nu$\n7.  **比较**：\n    -   最后，使用解析推导的 $m_1^{\\text{DC}}$ 和 $m_{-1}^{\\text{CHF}}$ 作为参考，计算相对差异 $\\delta_1$ 和 $\\delta_2$。这些差异量化了在此特定RPA模型中所做近似（即将粒子-空穴对视为玻色子并截断粒子-空穴空间）的影响。\n\n这个详细的步骤构成了Python实现的基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n_F, g, Omega, kappa)\n        (2, 2, 1.25, 0.5),      # Case 1\n        (3, 2, 1.0, 0.4),       # Case 2\n        (5, 1, 2.2, 0.3),       # Case 3\n        (3, 1, 1.8, 1e-6),      # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        delta1, delta2 = solve_case(*case)\n        results.extend([delta1, delta2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef solve_case(nF, g, Omega, kappa):\n    \"\"\"\n    Solves the RPA problem for one set of parameters (nF, g, Omega, kappa).\n\n    Returns:\n        tuple[float, float]: The relative differences (delta1, delta2).\n    \"\"\"\n    # Dimension of the particle-hole space\n    N = nF\n\n    # Task 1  2: Construct and solve the RPA problem\n    # Vector of transition matrix elements f_n\n    n_values = np.arange(N)\n    f_vec = np.sqrt(g) * np.sqrt((n_values + 1) * (n_values + 2)) / (2 * Omega)\n\n    # Construct RPA matrices A and B\n    # The interaction is separable, so B is a rank-1 matrix.\n    B = kappa * np.outer(f_vec, f_vec)\n    \n    # The particle-hole energies are constant Delta_E = 2*Omega for all n\n    delta_E = 2 * Omega\n    A = delta_E * np.eye(N) + B\n\n    # Build the 2N x 2N RPA matrix M\n    M = np.block([\n        [A, B],\n        [-B, -A]\n    ])\n\n    # Diagonalize M to find eigenvalues (omega) and eigenvectors (X, Y)\n    eigenvalues, eigenvectors = eig(M)\n\n    # Task 3: Compute RPA sum rules\n    m_minus_1_rpa = 0.0\n    m_0_rpa = 0.0\n    m_1_rpa = 0.0\n\n    for i in range(2 * N):\n        omega_nu = eigenvalues[i]\n\n        # Select physical solutions, which have positive real eigenfrequencies\n        # A small tolerance is used to handle floating point inaccuracies\n        if np.isreal(omega_nu) and np.real(omega_nu) > 1e-9:\n            omega_nu = np.real(omega_nu)\n            \n            # Since M is real, eigenvectors can be chosen to be real\n            eigenvector = np.real(eigenvectors[:, i])\n\n            # Extract forward (X) and backward (Y) amplitudes\n            X_u = eigenvector[:N]\n            Y_u = eigenvector[N:]\n\n            # The eigenvectors from scipy.linalg.eig are L2-normalized: X_u.T @ X_u + Y_u.T @ Y_u = 1.\n            # We must re-normalize them to the quasi-boson norm: X.T @ X - Y.T @ Y = 1.\n            norm_q_sq = X_u.T @ X_u - Y_u.T @ Y_u\n\n            # Physical solutions must have a positive norm\n            if norm_q_sq > 0:\n                norm_q = np.sqrt(norm_q_sq)\n                X_norm = X_u / norm_q\n                Y_norm = Y_u / norm_q\n\n                # Compute transition amplitude T_nu and strength S_nu\n                T_nu = np.sum(f_vec * (X_norm + Y_norm))\n                S_nu = T_nu**2\n\n                # Accumulate the RPA sum rules\n                m_1_rpa += omega_nu * S_nu\n                m_0_rpa += S_nu\n                m_minus_1_rpa += S_nu / omega_nu\n\n    # Task 4: Compute the analytical energy-weighted sum rule (m1) from DC\n    m1_dc = g * (nF**2) / Omega\n\n    # Task 5: Compute the analytical inverse energy-weighted sum rule (m-1) from CHF\n    m_minus_1_chf = g * (nF**2) / (4 * Omega**3)\n\n    # Final step: Report the relative differences\n    # Handle the potential for division by zero if a reference sum rule is zero\n    delta1 = abs(m_1_rpa - m1_dc) / m1_dc if abs(m1_dc) > 1e-12 else 0.0\n    delta2 = abs(m_minus_1_rpa - m_minus_1_chf) / m_minus_1_chf if abs(m_minus_1_chf) > 1e-12 else 0.0\n    \n    return delta1, delta2\n\n# Execute the main function to produce the final output.\nsolve()\n```", "id": "3550542"}, {"introduction": "集体振动并非孤立存在；它们与原子核中的单个核子相互作用。本练习通过粒子-振动耦合模型探讨了这种至关重要的相互作用。你将计算一个简单的单粒子态在与一个声子耦合时如何发生谱强度碎裂和能量移动，从而为自能和准粒子等概念提供一个具体的例子 [@problem_id:3550593]。", "problem": "实现一个独立的程序，该程序在一个示意性粒子-声子耦合模型中，对一个与单个尖锐的集体振动声子线性耦合的单核子单粒子态进行建模，并计算在几个不同耦合强度下，诱导产生的准粒子质量移动和谱碎裂。系统处于零温，所有能量必须以兆电子伏特（MeV）表示。该模型必须从第一性原理出发，由多体哈密顿量和推迟格林函数的定义推导得出。\n\n使用以下基本基矢：\n- 一个费米子单粒子产生算符 $c^{\\dagger}$ 占据一个裸能量为 $\\epsilon_{0}$ 的单能级，一个玻色子声子产生算符 $b^{\\dagger}$ 激发一个能量为 $\\omega_{\\text{ph}}$ 的单个振动模式。\n- 示意性粒子-声子哈密顿量为\n$$\n\\hat{H} = \\epsilon_{0}\\, c^{\\dagger} c + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g\\, c^{\\dagger} c \\left(b + b^{\\dagger}\\right),\n$$\n其中 $g$ 是粒子-声子耦合强度。假设为单个核子，因此可以忽略超出该单能级的泡利阻塞效应。\n- 根据定义，将核子添加至空能级上的推迟单粒子格林函数（格林函数(GF)）为\n$$\nG(\\omega) = \\frac{1}{\\omega - \\epsilon_{0} - \\Sigma(\\omega)},\n$$\n其中 $\\Sigma(\\omega)$ 是推迟自能。在零温下单声子截断且忽略内禀宽度的情况下，自能来源于单个尖锐声子的虚发射和再吸收。\n- 谱函数定义为\n$$\nA(\\omega) = -\\frac{1}{\\pi}\\, \\operatorname{Im} G(\\omega + i\\eta),\n$$\n其中无穷小量 $\\eta \\to 0^{+}$。\n\n任务要求：\n1. 从哈密顿量、格林函数的定义以及戴森方程出发，将问题简化为一个能精确描述单声子子空间内动力学的有限维形式。利用此形式求得 $G(\\omega)$ 的孤立极点 $\\{\\omega_{i}\\}$ 及其留数 $\\{Z_{i}\\}$，其中每个留数是原始单粒子态在第 $i$ 个精确本征态中的权重。留数必须满足 $\\sum_{i} Z_{i} = 1$。\n2. 将具有最大留数的极点定义为准粒子极点，并将准粒子质量移动定义为\n$$\n\\Delta E \\equiv \\omega_{\\text{qp}} - \\epsilon_{0}.\n$$\n以 $\\text{MeV}$ 为单位报告 $\\Delta E$。\n3. 使用离散极点权重的香农熵定义谱碎裂的标量量化度量，\n$$\nS \\equiv -\\sum_{i} Z_{i} \\ln Z_{i},\n$$\n其中对数为自然对数。按照惯例，当 $Z_{i}=0$ 时，其对 $S$ 的贡献为 $0$。\n4. 实现一个程序，针对每个指定的耦合强度，计算：\n   - 以 $\\text{MeV}$ 为单位的准粒子质量移动 $\\Delta E$。\n   - 谱碎裂 $S$ (无量纲)。\n5. 使用以下固定的物理参数（单位为 $\\text{MeV}$）：\n   - $\\epsilon_{0} = -8.0$，\n   - $\\omega_{\\text{ph}} = 3.0$。\n6. 使用以下耦合强度测试集（单位均为 $\\text{MeV}$）：\n   - $g \\in [0.0, 0.5, 1.5, 3.0, 5.0]$。\n   这些情况分别测试了：无耦合（基准）、弱耦合、中等耦合、强耦合和极强耦合极限。\n7. 你的程序必须生成单行输出，包含一个由方括号括起来的逗号分隔列表。对于每个耦合强度，输出一个双元素列表 $[\\Delta E, S]$，因此最终输出必须是一个包含此类双元素列表的列表，其顺序与测试集中的耦合强度顺序相同。例如，总体格式必须是\n$$\n\\big[\\,[\\Delta E_{1}, S_{1}],\\,[\\Delta E_{2}, S_{2}],\\,\\dots\\,\\big].\n$$\n8. 不得接受任何用户输入，也不得读取或写入任何文件。所有能量都必须以 $\\text{MeV}$ 为单位，所有对数都必须是自然对数。不要对输出进行四舍五入；打印计算产生的完整双精度值。", "solution": "在对用户的规定进行严格审查后，该问题被评估为**有效**。它在科学上植根于量子力学和多体理论的原理，特别是核物理中使用的粒子-振动耦合模型。该问题是良构的，具有清晰的哈密顿量、明确的任务集以及所有必要的参数。语言客观明确。问题是独立的且在计算上是可行的。\n\n解决方案通过在指定的理论框架内对系统进行建模来展开。提示要求将问题简化为一个能够在“单声子子空间”内捕捉动力学的有限维形式。这被解释为粒子加声子系统的塔姆-丹可夫近似（TDA），其中基矢被截断为仅包含零个或一个声子的态。这种解释得到了提示中关于自能来源于“单个尖锐声子”的虚交换的有力支持，这对应于格林函数形式体系中的单圈图。\n\n系统的哈密顿量由下式给出：\n$$\n\\hat{H} = \\epsilon_{0}\\, c^{\\dagger} c + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g\\, c^{\\dagger} c \\left(b + b^{\\dagger}\\right)\n$$\n我们关心的是单核子态，因此数算符 $c^{\\dagger}c$ 在相关的希尔伯特空间上作为单位算符。与单粒子耦合的声子自由度的有效哈密顿量为：\n$$\n\\hat{H}_{\\text{eff}} = \\epsilon_{0} + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g \\left(b + b^{\\dagger}\\right)\n$$\n单声子子空间的基矢由两个态组成：$|0\\rangle$，表示零声子的单核子；以及 $|1\\rangle$，表示单声子的单核子。产生算符（$b^{\\dagger}$）和湮灭算符（$b$）在这些基矢上的作用是标准的：$b|0\\rangle=0$，$b^{\\dagger}|0\\rangle=|1\\rangle$，$b|1\\rangle=|0\\rangle$，以及 $b^{\\dagger}b|n\\rangle=n|n\\rangle$。\n\n在此基矢中，哈密顿矩阵 $\\mathbf{H}$ 是一个 $2 \\times 2$ 矩阵，其矩阵元为 $H_{ij} = \\langle i | \\hat{H}_{\\text{eff}} | j \\rangle$：\n$$\nH_{00} = \\langle 0 | \\epsilon_{0} + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g (b + b^{\\dagger}) | 0 \\rangle = \\epsilon_{0}\n$$\n$$\nH_{11} = \\langle 1 | \\epsilon_{0} + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g (b + b^{\\dagger}) | 1 \\rangle = \\epsilon_{0} + \\omega_{\\text{ph}}\n$$\n$$\nH_{01} = \\langle 0 | \\epsilon_{0} + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g (b + b^{\\dagger}) | 1 \\rangle = g \\langle 0 | b | 1 \\rangle = g\n$$\n$$\nH_{10} = \\langle 1 | \\epsilon_{0} + \\omega_{\\text{ph}}\\, b^{\\dagger} b + g (b + b^{\\dagger}) | 0 \\rangle = g \\langle 1 | b^{\\dagger} | 0 \\rangle = g\n$$\n得到的哈密顿矩阵为：\n$$\n\\mathbf{H} = \\begin{pmatrix} \\epsilon_{0}  & g \\\\ g & \\epsilon_{0} + \\omega_{\\text{ph}} \\end{pmatrix}\n$$\n格林函数的极点 $\\{\\omega_{i}\\}$ 是该矩阵的本征值。它们通过求解特征方程 $\\det(\\mathbf{H} - \\omega \\mathbf{I}) = 0$ 得到：\n$$\n(\\epsilon_{0} - \\omega)(\\epsilon_{0} + \\omega_{\\text{ph}} - \\omega) - g^2 = 0\n$$\n令 $x = \\omega - \\epsilon_{0}$。方程变为 $-x(\\omega_{\\text{ph}} - x) - g^2 = 0$，可简化为一个二次方程：\n$$\nx^2 - \\omega_{\\text{ph}} x - g^2 = 0\n$$\n$x$ 的解为 $x_{\\pm} = \\frac{\\omega_{\\text{ph}} \\pm \\sqrt{\\omega_{\\text{ph}}^2 + 4g^2}}{2}$。因此，两个极点为：\n$$\n\\omega_{\\pm} = \\epsilon_{0} + x_{\\pm} = \\epsilon_{0} + \\frac{\\omega_{\\text{ph}} \\pm \\sqrt{\\omega_{\\text{ph}}^2 + 4g^2}}{2}\n$$\n该结果与求解具有单圈自能 $\\Sigma(\\omega) = g^2 / (\\omega - (\\epsilon_{0} + \\omega_{\\text{ph}}))$ 的格林函数 $G(\\omega) = [\\omega - \\epsilon_{0} - \\Sigma(\\omega)]^{-1}$ 的极点所得结果相同。\n\n留数 $\\{Z_{i}\\}$ 是原始单粒子态在新的相互作用本征态中的权重。原始态是 $|0\\rangle$，即第一个基矢 $\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。对于每个本征值 $\\omega_{i}$，其对应的归一化本征矢量为 $\\Psi_{i} = \\begin{pmatrix} c_{i,0} \\\\ c_{i,1} \\end{pmatrix}$。留数定义为 $Z_{i} = |c_{i,0}|^2$。\n本征矢量方程 $(\\mathbf{H} - \\omega \\mathbf{I})\\Psi = 0$ 给出 $(\\epsilon_{0}-\\omega)c_0 + gc_1 = 0$。使用归一化条件 $c_0^2 + c_1^2 = 1$，我们得到：\n$$\nc_0^2 \\left(1 + \\frac{(\\epsilon_{0}-\\omega)^2}{g^2}\\right) = 1 \\implies Z = c_0^2 = \\frac{g^2}{g^2 + (\\omega - \\epsilon_{0})^2} = \\frac{g^2}{g^2 + x^2}\n$$\n两个极点 $\\omega_{\\pm}$ 的留数为：\n$$\nZ_{\\pm} = \\frac{g^2}{g^2 + x_{\\pm}^2}\n$$\n可以证明 $Z_{+} + Z_{-} = 1$，满足求和规则。\n\n准粒子极点 $\\omega_{\\text{qp}}$ 是具有最大留数的极点。我们比较 $Z_{-}$ 和 $Z_{+}$。由于 $Z \\propto 1/(g^2+x^2)$，较大的留数对应较小的 $|x|$。对于 $g > 0$，我们有 $|x_{-}| = |(\\omega_{\\text{ph}} - \\sqrt{\\omega_{\\text{ph}}^2 + 4g^2})/2| < |(\\omega_{\\text{ph}} + \\sqrt{\\omega_{\\text{ph}}^2 + 4g^2})/2| = |x_{+}|$。因此，$Z_{-} > Z_{+}$。准粒子极点是 $\\omega_{\\text{qp}} = \\omega_{-}$。\n\n准粒子质量移动 $\\Delta E$ 定义为 $\\omega_{\\text{qp}} - \\epsilon_{0}$：\n$$\n\\Delta E = \\omega_{-} - \\epsilon_{0} = x_{-} = \\frac{\\omega_{\\text{ph}} - \\sqrt{\\omega_{\\text{ph}}^2 + 4g^2}}{2}\n$$\n对于 $g = 0$ 的特殊情况，哈密顿量是对角的。极点为 $\\epsilon_{0}$ 和 $\\epsilon_{0} + \\omega_{\\text{ph}}$。原始粒子态 $|0\\rangle$ 本身就是一个能量为 $\\epsilon_{0}$ 的本征态。因此，准粒子极点是 $\\omega_{\\text{qp}} = \\epsilon_{0}$，其留数为 $Z=1$，这导致 $\\Delta E=0$。\n\n谱碎裂 $S$ 使用香农熵公式和两个留数 $Z_{-}$ 和 $Z_{+}$ 计算。令 $Z_{\\text{qp}} = Z_{-}$。则另一个留数为 $1 - Z_{\\text{qp}}$。\n$$\nS = - \\sum_{i} Z_{i} \\ln Z_{i} = - \\left( Z_{\\text{qp}} \\ln Z_{\\text{qp}} + (1-Z_{\\text{qp}}) \\ln(1-Z_{\\text{qp}}) \\right)\n$$\n当 $g=0$ 时，$Z_{\\text{qp}}=1$，所以 $S = -(1 \\ln 1 + 0 \\ln 0) = 0$。\n\n对于每个耦合强度 $g$ 的算法如下：\n1.  设置 $\\epsilon_{0} = -8.0$，$\\omega_{\\text{ph}} = 3.0$。\n2.  如果 $g = 0$，则 $\\Delta E = 0$ 且 $S = 0$。\n3.  如果 $g > 0$：\n    a. 计算质量移动：$\\Delta E = (\\omega_{\\text{ph}} - \\sqrt{\\omega_{\\text{ph}}^2 + 4g^2}) / 2$。\n    b. 计算准粒子留数：$Z_{\\text{qp}} = g^2 / (g^2 + (\\Delta E)^2)$。\n    c. 计算熵：$S = -(Z_{\\text{qp}} \\ln(Z_{\\text{qp}}) + (1-Z_{\\text{qp}}) \\ln(1-Z_{\\text{qp}}))$。\n4.  存储并格式化结果 $[\\Delta E, S]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the quasiparticle mass shift and spectral fragmentation for a\n    particle-phonon coupling model.\n    \"\"\"\n\n    # Fixed physical parameters in MeV\n    epsilon_0 = -8.0\n    omega_ph = 3.0\n\n    # Test suite of coupling strengths in MeV\n    g_values = [0.0, 0.5, 1.5, 3.0, 5.0]\n\n    results = []\n    for g in g_values:\n        if g == 0.0:\n            # No coupling case: The particle state is an eigenstate, no shift, no fragmentation.\n            delta_E = 0.0\n            entropy_S = 0.0\n        else:\n            # For g > 0, we apply the derived formulas.\n            \n            # 1. Calculate the quasiparticle mass shift (Delta E)\n            # This corresponds to the energy shift of the pole with the largest residue.\n            # Delta_E = x_ = (omega_ph - sqrt(omega_ph^2 + 4*g^2)) / 2\n            sqrt_term = np.sqrt(omega_ph**2 + 4 * g**2)\n            delta_E = (omega_ph - sqrt_term) / 2.0\n\n            # 2. Calculate the quasiparticle residue (Z_qp)\n            # This is the weight of the bare particle state in the quasiparticle eigenstate.\n            # Z_qp = g^2 / (g^2 + Delta_E^2)\n            residue_qp = g**2 / (g**2 + delta_E**2)\n            \n            # The residue of the other state. The sum of residues must be 1.\n            residue_other = 1.0 - residue_qp\n\n            # 3. Calculate the spectral fragmentation (S) using Shannon entropy\n            # S = - sum( Z_i * ln(Z_i) )\n            # We handle the terms to avoid log(0) issues, although for g > 0,\n            # both residues are strictly between 0 and 1.\n            term1 = -residue_qp * np.log(residue_qp) if residue_qp > 0 else 0.0\n            term2 = -residue_other * np.log(residue_other) if residue_other > 0 else 0.0\n            entropy_S = term1 + term2\n\n        results.append([delta_E, entropy_S])\n\n    # Format the final output according to the problem specification.\n    # e.g., [[-0.0, 0.0],[-0.08113883008418973, 0.16109337032338162],...]\n    # Using map(str, ...) on the list of lists correctly formats the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3550593"}, {"introduction": "真实的原子核计算必须遵循基本对称性，例如平移不变性。这项实践解决了一个常见的陷阱：物理激发（如巨偶极共振）被虚假的质心运动所污染。你将实现两种标准技术来消除这种非物理性的污染，这是做出可靠理论预测的一项关键技能 [@problem_id:3550546]。", "problem": "考虑有限原子核中在随机相近似（RPA）框架下的同位旋矢量电偶极集体振动。在平移不变的哈密顿量中，质心（CM）运动会表现为一个激发能任意接近于零的赝模。在实践中，一个未经修正的朴素偶极算符会与此赝模耦合，从而污染计算出的强度。物理上正确的观测量必须排除任何质心贡献。\n\n将RPA问题以线性代数形式建模。设存在一个维度为$M$的单粒子-单空穴空间，该空间可分解为质子和中子部分。在$\\mathbb{R}^M$中构造一组$K$个标准正交的激发矢量$\\{v_k\\}_{k=0}^{K-1}$，其中明确包含赝模质心本征矢量$v_s$。假设$v_s$是归一化的均匀矢量$v_s = \\frac{1}{\\sqrt{M}}(1,1,\\dots,1)^\\top$，它代表所有核子的等量平移。将朴素同位旋矢量偶极算符定义为一个矢量$d_{\\text{naive}}$，它为质子分量赋予$+1$，为中子分量赋予$-1$。对于一个算符$d$，由模式$v_k$所携带的偶极强度是振幅的平方$S_k(d) = |\\langle v_k, d \\rangle|^2 = |v_k^\\top d|^2$，总强度为$S_{\\text{tot}}(d) = \\sum_{k=0}^{K-1} S_k(d)$。\n\n存在两种科学上合理的方法来从同位旋矢量偶极强度中移除赝模质心污染：\n\n- 正交性强制：通过将算符投影到与$v_s$正交的子空间来修正算符，$d_{\\perp} = d_{\\text{naive}} - (v_s^\\top d_{\\text{naive}}) v_s$，从而使得$v_s^\\top d_{\\perp} = 0$。\n- 平移不变算符：使用平移不变的同位旋矢量偶极算符$d_{\\text{TI}}$，其单粒子形式会减去质心坐标。在质子-中子分解中，这会产生有效电荷$e_p = \\frac{N}{A}$（质子）和$e_n = -\\frac{Z}{A}$（中子），其中$Z$是质子数，$N$是中子数，$A = Z + N$是质量数。在此模型中，$d_{\\text{TI}}$为质子分量赋予$+\\frac{N}{A}$，为中子分量赋予$-\\frac{Z}{A}$，从而确保$v_s^\\top d_{\\text{TI}} = 0$。\n\n你的任务是设计并实现一个计算程序，对于给定的原子核$(Z,N)$，该程序能构造$K$个包含赝模质心矢量$v_s$的标准正交激发矢量，计算三种算符$d_{\\text{naive}}$、$d_{\\perp}$和$d_{\\text{TI}}$的偶极强度，并量化残余的赝模污染，其分数为\n$$\nf_{\\text{spur}}(d) = \\frac{S_s(d)}{S_{\\text{tot}}(d)},\n$$\n其中$S_s(d) = S_{k=s}(d)$是由赝模质心模式携带的强度。最终的数值输出必须是无量纲的浮点数和布尔值。\n\n在程序中实现以下精确、可复现的步骤：\n\n1. 构造赝模质心矢量$v_s \\in \\mathbb{R}^{M}$，作为归一化的均匀矢量$v_s = \\frac{1}{\\sqrt{M}}(1,1,\\dots,1)^\\top$。\n2. 从标准正态分布中生成$K-1$个$\\mathbb{R}^{M}$中的随机矢量，然后通过减去其在$v_s$上的投影来使每个矢量与$v_s$正交，并执行瘦$\\mathsf{QR}$分解以获得一个标准正交集$\\{q_j\\}_{j=0}^{K-2}$，该集合张成与$v_s$正交的子空间。\n3. 取$v_0 = v_s$和$v_{k} = q_{k-1}$（对于$k = 1,\\dots,K-1$）来构成激发集$\\{v_k\\}$。\n4. 定义$d_{\\text{naive}} \\in \\mathbb{R}^{M}$，为前$Z$个分量（质子）赋予$+1$，为其余$N$个分量（中子）赋予$-1$。\n5. 定义$d_{\\perp} = d_{\\text{naive}} - (v_s^\\top d_{\\text{naive}}) v_s$。\n6. 定义$d_{\\text{TI}}$，为前$Z$个分量赋予$+\\frac{N}{A}$，为其余$N$个分量赋予$-\\frac{Z}{A}$。\n7. 对于每个算符$d \\in \\{d_{\\text{naive}}, d_{\\perp}, d_{\\text{TI}}\\}$，计算强度$S_k(d) = |v_k^\\top d|^2$（对于$k=0,\\dots,K-1$）、总强度$S_{\\text{tot}}(d)$和赝模分数$f_{\\text{spur}}(d)$。\n8. 定义一个容差$\\varepsilon = 10^{-12}$和布尔值$b_{\\perp} = (f_{\\text{spur}}(d_{\\perp})  \\varepsilon)$及$b_{\\text{TI}} = (f_{\\text{spur}}(d_{\\text{TI}})  \\varepsilon)$。\n\n测试套件。使用以下三个必须在程序中硬编码的参数集：\n\n- 案例1：$Z=82$，$N=126$，$A=208$，$K=21$，种子$= 12345$。\n- 案例2：$Z=20$，$N=20$，$A=40$，$K=15$，种子$= 54321$。\n- 案例3：$Z=8$，$N=40$，$A=48$，$K=18$，种子$= 2023$。\n\n对于每个案例，程序必须计算并返回一个包含五个条目的列表，顺序必须为$[f_{\\text{spur}}(d_{\\text{naive}}), f_{\\text{spur}}(d_{\\perp}), f_{\\text{spur}}(d_{\\text{TI}}), b_{\\perp}, b_{\\text{TI}}]$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个由方括号括起来的三个案例结果的逗号分隔列表，每个案例结果本身也是一个由方括号括起来的逗号分隔列表。例如，输出必须看起来像$[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],[z_1,z_2,z_3,z_4,z_5]]$，其中插入了数值和布尔值。不需要物理单位，因为所有返回的值都是无量纲的。不使用角度。", "solution": "同位旋矢量电偶极振动反映了一种质子-中子异相集体运动。一个平移不变的哈密顿量拥有一个由对称性产生的、与质心（CM）平移相关的赝模态。在随机相近似（RPA）中，这个赝模态表现为一个能量接近于零的本征矢量，并与平移生成元成正比。当使用一个朴素偶极算符$\\hat{D} = \\sum_{i \\in p} z_i - \\sum_{j \\in n} z_j$而未减去质心运动时，该算符会与赝模耦合，在零能量处产生人为的强度。补救方法是强制实现平移不变性，可以通过从算符中明确投影掉质心分量，或者使用一个能赋予有效电荷以确保无质心耦合的平移不变算符。\n\n原理。基本基础是哈密顿量的平移不变性以及RPA模式的线性响应构造。质心赝模本征矢量是所有坐标的均匀平移。在一个离散化的单粒子-单空穴基中，我们将此赝模本征矢量建模为$v_s = \\frac{1}{\\sqrt{M}}(1,1,\\dots,1)^\\top$。算符$d$与归一化模式$v_k$的耦合振幅为$a_k(d) = v_k^\\top d$，偶极强度为$S_k(d) = |a_k(d)|^2$。因为强度是算符的二次方，投影算符以消除其沿$v_s$的分量会消除与赝模的任何耦合，而不会改变正交子空间内的物理耦合。另外，同位旋矢量偶极算符的平移不变性会产生众所周知的有效电荷$e_p = \\frac{N}{A}$和$e_n = -\\frac{Z}{A}$。其矢量形式为质子分量赋予$+\\frac{N}{A}$的权重，为中子分量赋予$-\\frac{Z}{A}$的权重。这种构造确保了$v_s^\\top d_{\\text{TI}} = 0$，因为权重之和为零：$Z \\cdot \\frac{N}{A} + N \\cdot \\left(-\\frac{Z}{A}\\right) = 0$。\n\n算法设计。\n\n1. 构造$v_s \\in \\mathbb{R}^{M}$为$v_s = \\frac{1}{\\sqrt{M}}(1,1,\\dots,1)^\\top$，保证$\\|v_s\\|_2 = 1$。\n2. 从标准正态分布中抽样生成$K-1$个随机列矢量$w_j \\in \\mathbb{R}^{M}$。通过对所有$j$设置$\\tilde{w}_j = w_j - (v_s^\\top w_j) v_s$来强制与$v_s$正交。这确保了$v_s^\\top \\tilde{w}_j = 0$。\n3. 计算$M \\times (K-1)$矩阵$\\tilde{W} = [\\tilde{w}_0,\\dots,\\tilde{w}_{K-2}]$的瘦$\\mathsf{QR}$分解，得到$\\tilde{W} = Q R$且$Q^\\top Q = I_{K-1}$。将$Q$的列作为张成与$v_s$正交的子空间的一个标准正交集$\\{q_j\\}_{j=0}^{K-2}$。\n4. 定义激发矢量$v_0 = v_s$和$v_k = q_{k-1}$（对于$k=1,\\dots,K-1$）。集合$\\{v_k\\}_{k=0}^{K-1}$根据构造是标准正交的。\n5. 将朴素算符$d_{\\text{naive}}$定义为一个$M$维矢量，前$Z$个条目（质子）为$+1$，其余$N$个条目（中子）为$-1$。如果$Z \\neq N$，该算符通常与$v_s$有非零重叠，因为$v_s^\\top d_{\\text{naive}} \\propto \\sum_i d_{\\text{naive},i} = Z - N$。\n6. 将朴素算符投影到与$v_s$正交的方向：$d_{\\perp} = d_{\\text{naive}} - (v_s^\\top d_{\\text{naive}}) v_s$。这保证了$v_s^\\top d_{\\perp} = 0$，因此$S_s(d_{\\perp}) = |v_s^\\top d_{\\perp}|^2 = 0$（在数值精度范围内）。\n7. 构造平移不变算符$d_{\\text{TI}}$，将其质子分量的条目设置为$+\\frac{N}{A}$，中子分量的条目设置为$-\\frac{Z}{A}$。分量之和为零，因此$v_s^\\top d_{\\text{TI}} = 0$且$S_s(d_{\\text{TI}}) = 0$（在数值精度范围内）。\n8. 对于每个算符$d \\in \\{d_{\\text{naive}}, d_{\\perp}, d_{\\text{TI}}\\}$，计算$S_k(d) = |v_k^\\top d|^2$（对于$k=0,\\dots,K-1$）和$S_{\\text{tot}}(d) = \\sum_{k=0}^{K-1} S_k(d)$。将赝模污染量化为\n$$\nf_{\\text{spur}}(d) = \\frac{S_s(d)}{S_{\\text{tot}}(d)}。\n$$\n因为$d_{\\perp}$和$d_{\\text{TI}}$与$v_s$正交，所以$f_{\\text{spur}}(d_{\\perp})$和$f_{\\text{spur}}(d_{\\text{TI}})$在数值上应该非常小，理想情况下接近于0。\n9. 定义一个数值容差$\\varepsilon = 10^{-12}$并报告布尔值$b_{\\perp} = (f_{\\text{spur}}(d_{\\perp})  \\varepsilon)$和$b_{\\text{TI}} = (f_{\\text{spur}}(d_{\\text{TI}})  \\varepsilon)$，以表明成功移除了赝模强度。\n\n测试套件原理。\n\n- 案例1（$Z=82$，$N=126$，$A=208$）：一个非对称原子核，代表一个重系统（如铅），其中$v_s^\\top d_{\\text{naive}} \\neq 0$；预计$d_{\\text{naive}}$会有显著的赝模污染。两种修正方法都应能抑制它。\n- 案例2（$Z=20$，$N=20$，$A=40$）：一个对称原子核，其中$Z = N$意味着$\\sum_i d_{\\text{naive},i} = 0$，因此$v_s^\\top d_{\\text{naive}} = 0$；朴素算符已经具有可忽略的赝模污染，这提供了一个边界检查。\n- 案例3（$Z=8$，$N=40$，$A=48$）：一个高度非对称的轻系统，其中朴素污染很强；两种修正方法都应能移除它。\n\n实现说明。\n\n- 通过$\\mathsf{QR}$进行的正交化确保了数值稳定性以及在浮点运算中得到一个精确的标准正交集。\n- 强度$S_k(d)$根据构造是非负的。分数$f_{\\text{spur}}(d)$是无量纲的，且位于$[0,1]$区间。\n- 由于将$d$乘以一个常数会使$S_s(d)$和$S_{\\text{tot}}(d)$都乘以相同的因子，所以$f_{\\text{spur}}(d)$在$d$的均匀缩放变换下是不变的。\n\n最终程序必须硬编码这三个案例，并生成单行输出，格式为$[[f_{\\text{naive}},f_{\\perp},f_{\\text{TI}},b_{\\perp},b_{\\text{TI}}]_{\\text{案例1}},[f_{\\text{naive}},f_{\\perp},f_{\\text{TI}},b_{\\perp},b_{\\text{TI}}]_{\\text{案例2}},[f_{\\text{naive}},f_{\\perp},f_{\\text{TI}},b_{\\perp},b_{\\text{TI}}]_{\\text{案例3}}]$，其中包含数值和布尔值。不需要物理单位，因为所有返回的值都是无量纲的。", "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5, scipy 1.11.4 (not used)\nimport numpy as np\n\ndef build_spurious_vector(M: int) - np.ndarray:\n    \"\"\"Return normalized uniform spurious CM vector of length M.\"\"\"\n    v = np.ones(M, dtype=float)\n    return v / np.linalg.norm(v)\n\ndef orthonormal_modes(M: int, K: int, seed: int) - np.ndarray:\n    \"\"\"\n    Construct K orthonormal excitation vectors in R^M that include the spurious CM vector.\n    v0 is the spurious vector; the remaining K-1 vectors are orthonormal and orthogonal to it.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    v_s = build_spurious_vector(M)\n    # Generate K-1 random vectors\n    W = rng.normal(size=(M, K-1))\n    # Orthogonalize each to v_s\n    proj_coeffs = v_s @ W  # shape (K-1,)\n    W_tilde = W - np.outer(v_s, proj_coeffs)\n    # QR decomposition to obtain orthonormal columns\n    Q, _ = np.linalg.qr(W_tilde, mode='reduced')  # Q is M x (K-1)\n    # Compose modes: first column is v_s, then Q's columns\n    V = np.empty((M, K), dtype=float)\n    V[:, 0] = v_s\n    V[:, 1:] = Q\n    # Sanity: ensure orthonormality\n    # V^T V should be identity; minor numerical deviations are acceptable\n    return V\n\ndef build_naive_operator(Z: int, N: int) - np.ndarray:\n    \"\"\"Naive isovector dipole operator: +1 for protons, -1 for neutrons.\"\"\"\n    A = Z + N\n    d = np.empty(A, dtype=float)\n    d[:Z] = 1.0\n    d[Z:] = -1.0\n    return d\n\ndef build_ti_operator(Z: int, N: int) - np.ndarray:\n    \"\"\"Translationally invariant isovector dipole operator with effective charges.\"\"\"\n    A = Z + N\n    d = np.empty(A, dtype=float)\n    d[:Z] = N / A\n    d[Z:] = -Z / A\n    return d\n\ndef project_operator(d: np.ndarray, v_s: np.ndarray) - np.ndarray:\n    \"\"\"Project operator d onto subspace orthogonal to v_s.\"\"\"\n    coeff = float(v_s @ d)\n    return d - coeff * v_s\n\ndef strengths(V: np.ndarray, d: np.ndarray) - np.ndarray:\n    \"\"\"Compute strengths S_k(d) = |v_k^T d|^2 for all modes.\"\"\"\n    amps = V.T @ d  # shape (K,)\n    return np.square(np.abs(amps))\n\ndef spurious_fraction(V: np.ndarray, d: np.ndarray, spur_index: int = 0) - float:\n    \"\"\"Compute spurious fraction f_spur(d) = S_spur / S_tot.\"\"\"\n    S = strengths(V, d)\n    S_tot = float(np.sum(S))\n    S_spur = float(S[spur_index])\n    # Guard against round-off leading to zero total strength\n    if S_tot == 0.0:\n        return 0.0\n    return S_spur / S_tot\n\ndef case_result(Z: int, N: int, K: int, seed: int, tol: float = 1e-12):\n    \"\"\"Compute [f_naive, f_proj, f_ti, b_proj, b_ti] for one test case.\"\"\"\n    A = Z + N\n    V = orthonormal_modes(A, K, seed)\n    v_s = V[:, 0]\n    d_naive = build_naive_operator(Z, N)\n    d_proj = project_operator(d_naive, v_s)\n    d_ti = build_ti_operator(Z, N)\n\n    f_naive = spurious_fraction(V, d_naive, spur_index=0)\n    f_proj = spurious_fraction(V, d_proj, spur_index=0)\n    f_ti = spurious_fraction(V, d_ti, spur_index=0)\n\n    b_proj = f_proj  tol\n    b_ti = f_ti  tol\n    return [f_naive, f_proj, f_ti, b_proj, b_ti]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Z, N, K, seed)\n        (82, 126, 21, 12345),  # Case 1: A=208\n        (20, 20, 15, 54321),   # Case 2: A=40, symmetric\n        (8, 40, 18, 2023),     # Case 3: A=48, asymmetric\n    ]\n\n    results = []\n    for Z, N, K, seed in test_cases:\n        results.append(case_result(Z, N, K, seed, tol=1e-12))\n\n    # Final print statement in the exact required format.\n    # Booleans and floats will be printed as Python literals; this matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3550546"}]}