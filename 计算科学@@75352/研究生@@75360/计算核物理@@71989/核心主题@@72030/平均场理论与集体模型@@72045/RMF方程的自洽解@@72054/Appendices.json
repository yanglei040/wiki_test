{"hands_on_practices": [{"introduction": "相对论平均场（RMF）计算的核心是求解介子场的克莱因-戈登方程。这项实践旨在通过高效的傅里叶方法，在周期性边界条件下解决这一基本问题 [@problem_id:3589493]。你将学习如何处理格林函数在原点的奇性，并通过与精确解和谱方法的比较来验证数值实现的准确性。", "problem": "考虑在相对论平均场（RMF）理论中出现的三维空间线性椭圆场方程，即非齐次克莱因-戈尔登（汤川）方程\n$$\n\\left(-\\Delta + m^2\\right)\\,\\phi(\\mathbf{r}) = s(\\mathbf{r}),\n$$\n其中 $\\Delta$ 是拉普拉斯算子，$m$ 是一个正常数质量参数，$\\phi(\\mathbf{r})$ 是场，而 $s(\\mathbf{r})$ 是一个给定的源。该算符在无限空间中的基本解（格林函数）是汤川核\n$$\nG(\\mathbf{r}) = \\frac{e^{-m r}}{4\\pi r},\\quad r = \\|\\mathbf{r}\\|.\n$$\n根据格林函数表示法，一个形式解是卷积\n$$\n\\phi(\\mathbf{r}) = \\int_{\\mathbb{R}^3} G(\\mathbf{r}-\\mathbf{r}')\\,s(\\mathbf{r}')\\,\\mathrm{d}^3\\mathbf{r}'.\n$$\n在计算环境中，通常将边长为 $L$ 的周期性立方域离散化，每个维度有 $N$ 个点，从而得到均匀的网格间距 $a = L/N$ 和单元体积 $\\Delta V = a^3$。在具有周期性边界条件的此类网格上，离散卷积近似为\n$$\n\\phi_{i,j,k} \\approx \\Delta V \\sum_{i',j',k'} G^{\\mathrm{per}}_{(i-i'),(j-j'),(k-k')} \\, s_{i',j',k'},\n$$\n其中 $G^{\\mathrm{per}}$ 是汤川核在离散环面上的周期性实现，它使用最小镜像约定来构建网格索引的差值，使得核函数依赖于包裹距离\n$$\nr_{i,j,k} = a\\,\\sqrt{(\\min(i,N-i))^2 + (\\min(j,N-j))^2 + (\\min(k,N-k))^2}.\n$$\n汤川核在 $r=0$ 处是奇异的。为了在网格上实现数值稳定的求积，应将原点处的核函数值替换为 $G$ 在围绕原点的体素上的平均值。一个简单而有效的近似是在一个半径为 $R$ 的球上进行球面平均，该球的体积等于立方体的单元体积，\n$$\n\\frac{4}{3}\\pi R^3 = \\Delta V,\\quad R = \\left(\\frac{3\\Delta V}{4\\pi}\\right)^{1/3}.\n$$\n通过这种选择，原点处的体素平均核函数值变为\n$$\nG_0 = \\frac{1}{\\Delta V}\\int_{0}^{R} \\frac{e^{-m r}}{4\\pi r} \\, 4\\pi r^2 \\,\\mathrm{d}r = \\frac{1}{\\Delta V}\\int_{0}^{R} e^{-m r}\\, r \\,\\mathrm{d}r = \\frac{1}{m^2 \\Delta V}\\left[1 - \\left(1 + m R\\right)e^{-m R}\\right],\n$$\n当 $m \\to 0$ 时，其极限简化为 $G_0 = \\frac{R^2}{2\\,\\Delta V}$。\n\n另外，同一个周期性问题也允许通过离散傅里叶变换得到谱方法解，该方法利用了恒等式\n$$\n\\widehat{\\phi}(\\mathbf{k}) = \\frac{\\widehat{s}(\\mathbf{k})}{k^2 + m^2},\\quad k^2 = k_x^2 + k_y^2 + k_z^2,\n$$\n其中 $\\mathbf{k}$ 是与周期性域相关的离散波数。这提供了一个一致的参考解，可以用来评估基于卷积的求积的准确性。\n\n你的任务是：\n- 从第一性原理出发，推导格林函数卷积表示法，以及与最小镜像约定和原点体素平均校正一致的离散周期性卷积。\n- 设计并实现一个求解器，该求解器通过对 $G^{\\mathrm{per}}$ 和 $s$ 进行离散傅里叶变换，并使用 $\\Delta V$ 进行适当的求积缩放，通过快速卷积计算网格上的 $\\phi$。\n- 实现一个谱方法求解器，在同一网格上通过 $\\widehat{\\phi}(\\mathbf{k}) = \\widehat{s}(\\mathbf{k})/(k^2+m^2)$ 计算 $\\phi$，使用离散波数 $k_x = 2\\pi\\,\\mathrm{fftfreq}(N,a)$ 以及类似的 $k_y$ 和 $k_z$。\n- 构建物理上合理的离散源用于测试：一个点状源，使用在原点处振幅为 $1/\\Delta V$ 的单个单元来近似狄拉克δ函数；以及一个归一化的周期性高斯函数 $s(\\mathbf{r}) = A \\exp\\left(-r^2/(2\\sigma^2)\\right)$，其中 $A$ 的选择应使离散积分 $\\sum s\\,\\Delta V$ 等于 $1$。\n\n本问题中的所有量均为无量纲量。\n\n误差度量定义如下：\n- 对于点状源，沿正 $x$ 轴，将卷积解与前 $M$ 个非零网格点（$i=1,\\dots,M$，其中 $r_i = i\\,a$）的解析汤川核值进行比较。报告平均绝对相对误差，\n$$\n\\varepsilon_{\\mathrm{pt}} = \\frac{1}{M}\\sum_{i=1}^{M} \\left|\\frac{\\phi_{i,0,0} - G(r_i)}{G(r_i)}\\right|.\n$$\n- 对于高斯源，报告卷积解和谱方法解在整个网格上的相对 $\\ell^2$ 误差，\n$$\n\\varepsilon_{\\mathrm{gauss}} = \\frac{\\left\\|\\phi_{\\mathrm{conv}} - \\phi_{\\mathrm{spec}}\\right\\|_2}{\\left\\|\\phi_{\\mathrm{spec}}\\right\\|_2},\n$$\n其中离散范数定义为\n$$\n\\left\\|f\\right\\|_2 = \\left(\\sum_{i,j,k} |f_{i,j,k}|^2\\,\\Delta V\\right)^{1/2}.\n$$\n\n测试套件规范：\n- 测试 $1$ (正常路径，点源)：$N=48$, $L=24$, $m=1.0$, $M=12$。\n- 测试 $2$ (正常路径，高斯源)：$N=48$, $L=24$, $m=1.0$, $\\sigma=1.5$。\n- 测试 $3$ (边缘情况，长程)：$N=48$, $L=24$, $m=0.1$, $\\sigma=2.0$。\n- 测试 $4$ (边缘情况，短程)：$N=48$, $L=24$, $m=5.0$, $\\sigma=0.5$。\n\n你的程序必须：\n- 在离散网格上构建具有原点体素平均值 $G_0$ 的周期性汤川核 $G^{\\mathrm{per}}$，并通过离散傅里叶变换执行快速卷积，同时使用 $\\Delta V$ 进行适当缩放。\n- 通过离散波数构建谱方法解，并按规定进行比较。\n- 产生四个浮点数结果，对应于测试 $1$–$4$ 的误差度量。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4\\right]$）。每个结果必须是一个浮点数。不应打印任何其他文本。", "solution": "该问题要求使用两种不同但相关的基于傅里叶变换的方法，在周期性立方域上数值求解非齐次克莱因-戈尔登方程，并对它们的准确性进行定量比较。\n\n### 原理与推导\n\n#### 1. 格林函数与卷积解\n控制方程是线性椭圆偏微分方程（PDE）：\n$$\n\\left(-\\Delta + m^2\\right)\\,\\phi(\\mathbf{r}) = s(\\mathbf{r})\n$$\n其中 $\\Delta = \\nabla^2$ 是拉普拉斯算子，$m$ 是一个正常数质量，$\\phi(\\mathbf{r})$ 是待求解的场，$s(\\mathbf{r})$ 是一个指定的源项。\n\n算符 $L_{\\mathbf{r}} = -\\Delta_{\\mathbf{r}} + m^2$ 的基本解，或称格林函数 $G(\\mathbf{r}, \\mathbf{r}')$，由以下方程定义：\n$$\nL_{\\mathbf{r}} G(\\mathbf{r}, \\mathbf{r}') = \\delta(\\mathbf{r} - \\mathbf{r}')\n$$\n其中 $\\delta(\\mathbf{r} - \\mathbf{r}')$ 是狄拉克δ函数。对于一个无限的、平移不变的域，格林函数仅依赖于位移矢量，即 $G(\\mathbf{r}, \\mathbf{r}') = G(\\mathbf{r}-\\mathbf{r}')$。在这种情况下，解是众所周知的汤川势：\n$$\nG(\\mathbf{r}) = \\frac{e^{-m r}}{4\\pi r}, \\quad r = \\|\\mathbf{r}\\|\n$$\n原始偏微分方程的解 $\\phi(\\mathbf{r})$ 可以使用格林函数形式化地表示。令 $L_{\\mathbf{r}'}$ 为作用在 $\\mathbf{r}'$ 坐标上的算符。通过应用格林第二恒等式并假设场在无穷远处消失，可以证明：\n$$\n\\phi(\\mathbf{r}) = \\int_{\\mathbb{R}^3} G(\\mathbf{r}-\\mathbf{r}') \\left(L_{\\mathbf{r}'} \\phi(\\mathbf{r}')\\right) \\mathrm{d}^3\\mathbf{r}'\n$$\n代入 $L_{\\mathbf{r}'} \\phi(\\mathbf{r}') = s(\\mathbf{r}')$，我们得到解的卷积表示：\n$$\n\\phi(\\mathbf{r}) = \\int_{\\mathbb{R}^3} G(\\mathbf{r}-\\mathbf{r}')\\,s(\\mathbf{r}')\\,\\mathrm{d}^3\\mathbf{r}' = (G * s)(\\mathbf{r})\n$$\n\n#### 2. 周期性网格上的离散化\n为了进行数值求解，我们将边长为 $L$ 的立方域离散化为一个 $N \\times N \\times N$ 的点网格。网格间距为 $a = L/N$，单个网格单元（体素）的体积为 $\\Delta V = a^3$。连续场 $\\phi(\\mathbf{r})$ 和 $s(\\mathbf{r})$ 由它们在网格点上的值 $\\phi_{i,j,k}$ 和 $s_{i,j,k}$ 表示。\n\n卷积积分由离散和近似：\n$$\n\\phi_{i,j,k} \\approx \\sum_{i',j',k'} G(\\mathbf{r}_{i,j,k}-\\mathbf{r}_{i',j',k'}) s_{i',j',k'} \\Delta V\n$$\n对于周期性边界条件，点与点之间的相互作用必须考虑域的环绕特性。两点之间的距离应为离散环面上的最短路径。这是通过使用**最小镜像约定**实现的。对于网格索引 $i \\in [0, N-1]$，包裹的一维距离是 $\\min(i, N-i)$。扩展到三维，从原点 $(0,0,0)$ 到点 $(i,j,k)$ 的周期性距离是：\n$$\nr_{i,j,k} = a\\,\\sqrt{(\\min(i,N-i))^2 + (\\min(j,N-j))^2 + (\\min(k,N-k))^2}\n$$\n这定义了在离散周期性卷积中使用的周期性核 $G^{\\mathrm{per}}$：\n$$\n\\phi_{i,j,k} = \\Delta V \\sum_{i',j',k'} G^{\\mathrm{per}}_{(i-i'),(j-j'),(k-k')} \\, s_{i',j',k'}\n$$\n其中索引是模 $N$ 计算的。\n\n#### 3. 原点奇异性正则化\n汤川核 $G(r) \\propto 1/r$ 在 $r=0$ 处是奇异的。在网格上进行朴素的求值会导致除以零。为了获得稳定且准确的数值求积，值 $G^{\\mathrm{per}}_{0,0,0}$ 被其在中心体素上的平均值所取代。我们将体积为 $\\Delta V$ 的立方体素近似为一个等效体积的球，其半径为 $R = (3\\Delta V / 4\\pi)^{1/3}$。平均核函数值 $G_0$ 为：\n$$\nG_0 = \\frac{1}{\\Delta V} \\int_{\\|\\mathbf{r}\\| \\le R} G(\\mathbf{r}) \\,\\mathrm{d}^3\\mathbf{r} = \\frac{1}{\\Delta V} \\int_0^R \\frac{e^{-m r}}{4\\pi r} 4\\pi r^2 \\,\\mathrm{d}r = \\frac{1}{\\Delta V} \\int_0^R r e^{-m r} \\,\\mathrm{d}r\n$$\n通过分部积分法计算该积分，得到原点处的正则化值：\n$$\nG_0 = \\frac{1}{m^2 \\Delta V}\\left[1 - \\left(1 + m R\\right)e^{-m R}\\right]\n$$\n\n#### 4. 使用傅里叶变换的快速卷积\n直接计算离散卷积和的计算成本很高，对于一个 $N \\times N \\times N$ 的网格需要 $O(N^6)$ 次操作。卷积定理提供了一条效率高得多的路径。该定理指出，两个函数卷积的傅里叶变换等于它们各自傅里叶变换的逐元素乘积：\n$$\n\\mathcal{F}\\{f * g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}\n$$\n将此应用于我们的离散周期性卷积，解 $\\phi$ 可通过以下方式计算：\n$$\n\\phi = \\Delta V \\cdot \\mathrm{IFFT}\\left( \\mathrm{FFT}(G^{\\mathrm{per}}) \\cdot \\mathrm{FFT}(s) \\right)\n$$\n其中 $\\mathrm{FFT}$ 和 $\\mathrm{IFFT}$ 分别表示快速傅里叶变换及其逆变换。这将计算复杂度降低到 $O(N^3 \\log N)$。\n\n#### 5. 谱方法解\n另一种方法是直接在傅里叶空间中求解偏微分方程。对原始方程 $(-\\Delta + m^2)\\,\\phi = s$ 应用傅里叶变换，并利用对拉普拉斯算子进行傅里叶变换相当于乘以 $k^2 = \\|\\mathbf{k}\\|^2$ 的性质，我们得到：\n$$\n(k^2 + m^2)\\,\\widehat{\\phi}(\\mathbf{k}) = \\widehat{s}(\\mathbf{k})\n$$\n其中 $\\widehat{\\phi}$ 和 $\\widehat{s}$ 分别是 $\\phi$ 和 $s$ 的傅里叶变换，$\\mathbf{k}$ 是波矢量。这给出了场傅里叶系数的代数解：\n$$\n\\widehat{\\phi}(\\mathbf{k}) = \\frac{\\widehat{s}(\\mathbf{k})}{k^2 + m^2}\n$$\n然后通过应用逆傅里叶变换找到实空间中的解：$\\phi = \\mathcal{F}^{-1}\\{\\widehat{\\phi}\\}$。在我们的离散网格上，波数 $\\mathbf{k} = (k_x, k_y, k_z)$ 由 $k_x = 2\\pi f_x$ 给出，其中 $f_x$ 是来自 `numpy.fft.fftfreq(N, a)` 的离散频率。由于 $m > 0$，分母 $k^2 + m^2$ 始终非零，确保了解的良定性。该谱方法在数学上等价于周期性卷积，并可作为验证实现的可靠参考。\n\n#### 6. 源与误差的定义\n问题指定了两种源类型用于测试：\n1.  **点源**：狄拉克δ函数的离散近似，$s_{i,j,k} = \\delta_{i0}\\delta_{j0}\\delta_{k0} / \\Delta V$。积分 $\\sum s \\Delta V = 1$。\n2.  **高斯源**：周期性高斯函数 $s(\\mathbf{r}) = A \\exp(-r^2/(2\\sigma^2))$，其中 $r$ 是周期性距离，$A$ 是归一化常数，确保 $\\sum s \\Delta V = 1$。\n\n误差度量为：\n1.  $\\varepsilon_{\\mathrm{pt}}$：对于点源，将解与沿一个轴的解析无限空间格林函数 $G(r)$ 进行比较。这测试了离散化的准确性以及周期性边界条件的影响。\n2.  $\\varepsilon_{\\mathrm{gauss}}$：对于高斯源，使用相对 $\\ell^2$ 范数将卷积解 $\\phi_{\\mathrm{conv}}$ 与谱方法解 $\\phi_{\\mathrm{spec}}$ 进行比较。这验证了两种实现的数值方法的一致性。\n\n下面的实现系统地对指定的测试套件执行了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(source_type, N, L, m, M, sigma):\n    \"\"\"\n    Computes the solution to the Klein-Gordon equation and the specified error metric.\n    \n    Args:\n        source_type (str): 'point' or 'gauss'.\n        N (int): Number of grid points per dimension.\n        L (float): Side length of the cubic domain.\n        m (float): Mass parameter.\n        M (int): Number of points for point-source error calculation.\n        sigma (float): Width of the Gaussian source.\n\n    Returns:\n        float: The calculated error.\n    \"\"\"\n    # Grid parameters\n    a = L / N\n    dV = a**3\n\n    # Create grid indices and distances using minimal image convention\n    i, j, k = np.ogrid[0:N, 0:N, 0:N]\n    ix = np.minimum(i, N - i)\n    iy = np.minimum(j, N - j)\n    ik = np.minimum(k, N - k)\n    r_grid = a * np.sqrt(ix**2 + iy**2 + ik**2)\n    \n    # 1. Construct the periodic Yukawa kernel G_per\n    # Voxel-averaged value at the origin\n    R = (3 * dV / (4 * np.pi))**(1/3)\n    if m > 1e-9: # Avoid division by zero for m -> 0\n        G0 = (1 - (1 + m * R) * np.exp(-m * R)) / (m**2 * dV)\n    else:\n        G0 = R**2 / (2 * dV) # Limit as m -> 0\n    \n    # Kernel on the grid\n    G_per = np.divide(np.exp(-m * r_grid), 4 * np.pi * r_grid, where=(r_grid != 0))\n    G_per[0, 0, 0] = G0\n\n    # 2. Construct the source term s\n    s = np.zeros((N, N, N), dtype=float)\n    if source_type == 'point':\n        s[0, 0, 0] = 1.0 / dV\n    elif source_type == 'gauss':\n        s_unnormalized = np.exp(-r_grid**2 / (2 * sigma**2))\n        integral_s = np.sum(s_unnormalized) * dV\n        s = s_unnormalized / integral_s\n\n    # 3. Compute solution via fast convolution (Method 1)\n    s_hat = np.fft.fftn(s)\n    G_per_hat = np.fft.fftn(G_per)\n    \n    phi_conv = dV * np.fft.ifftn(G_per_hat * s_hat)\n    phi_conv = np.real(phi_conv)\n\n    # 4. Calculate error based on source type\n    if source_type == 'point':\n        # Compare with analytical Yukawa kernel on x-axis\n        r_vals = a * np.arange(1, M + 1)\n        G_analytical = np.exp(-m * r_vals) / (4 * np.pi * r_vals)\n        phi_on_axis = phi_conv[1:M+1, 0, 0]\n        \n        relative_errors = np.abs((phi_on_axis - G_analytical) / G_analytical)\n        error = np.mean(relative_errors)\n        return error\n        \n    elif source_type == 'gauss':\n        # Compare with spectral solution (Method 2)\n        # Wave numbers\n        k_vals = 2 * np.pi * np.fft.fftfreq(N, a)\n        kx, ky, kz = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n        k2 = kx**2 + ky**2 + kz**2\n\n        phi_spec_hat = np.divide(s_hat, k2 + m**2, where=(k2 + m**2 != 0))\n        \n        phi_spec = np.fft.ifftn(phi_spec_hat)\n        phi_spec = np.real(phi_spec)\n\n        # Relative L2 error\n        norm_spec_sq = np.sum(phi_spec**2) * dV\n        norm_diff_sq = np.sum((phi_conv - phi_spec)**2) * dV\n        \n        if norm_spec_sq == 0:\n            return 0.0 if norm_diff_sq == 0 else 1.0\n\n        error = np.sqrt(norm_diff_sq / norm_spec_sq)\n        return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'point', 'N': 48, 'L': 24, 'm': 1.0, 'sigma': None,  'M': 12},\n        {'type': 'gauss', 'N': 48, 'L': 24, 'm': 1.0, 'sigma': 1.5,   'M': None},\n        {'type': 'gauss', 'N': 48, 'L': 24, 'm': 0.1, 'sigma': 2.0,   'M': None},\n        {'type': 'gauss', 'N': 48, 'L': 24, 'm': 5.0, 'sigma': 0.5,   'M': None},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_error(\n            source_type=case['type'],\n            N=case['N'],\n            L=case['L'],\n            m=case['m'],\n            M=case['M'],\n            sigma=case['sigma']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3589493"}, {"introduction": "在掌握了场方程求解器的基础上，这项实践将构建一个完整的自洽循环，尽管这是一个简化的模型 [@problem_id:3589504]。你将实现一个迭代过程：核密度产生介子场，而介子场反过来决定核子的波函数，从而形成新的密度。这项练习还突出了一个关键的数值陷阱——混叠效应（aliasing），并探讨了如何在非线性计算中减轻其影响。", "problem": "考虑一个立方周期性区域中的对称核物质的简化相对论平均场 (RMF) 模型，其中矢量介子场的类时分量被处理为与汤川核的卷积。在自然单位制中进行计算，取 $\\hbar = c = 1$，长度以飞米 (fm) 表示，动量以反飞米 (fm$^{-1}$) 表示。重子密度表示为 $\\rho(\\mathbf{r})$，核子静止质量为 $M$，矢量介子质量为 $m_\\omega$，矢量耦合为 $g_\\omega$。核子感受到的类时矢量势为 $V(\\mathbf{r})$，化学势（一个常数）为 $\\mu$。\n\n从静态极限下矢量介子的 RMF 场方程，即亥姆霍兹型方程\n$$\n\\left(-\\nabla^2 + m_\\omega^2\\right)\\,\\omega^0(\\mathbf{r}) = g_\\omega\\,\\rho(\\mathbf{r}),\n$$\n开始，定义玩具矢量势为 $V(\\mathbf{r}) = g_\\omega\\,\\omega^0(\\mathbf{r})$。证明 $V(\\mathbf{r})$ 可由与汤川核 $K(\\mathbf{r})$ 的卷积给出，\n$$\nV(\\mathbf{r}) = \\int \\mathrm{d}^3 r'\\,K(\\mathbf{r}-\\mathbf{r}')\\,\\rho(\\mathbf{r}'), \\quad K(\\mathbf{r}) = \\frac{g_\\omega^2}{4\\pi}\\frac{e^{-m_\\omega r}}{r},\n$$\n在傅里叶空间中等效地表示为\n$$\n\\tilde{V}(\\mathbf{k}) = \\tilde{K}(\\mathbf{k})\\,\\tilde{\\rho}(\\mathbf{k}), \\quad \\tilde{K}(\\mathbf{k}) = \\frac{g_\\omega^2}{\\mathbf{k}^2 + m_\\omega^2},\n$$\n其中波浪线表示傅里叶变换，$\\mathbf{k}$ 是波矢。\n\n假设核子单粒子能量由一个被 $V(\\mathbf{r})$ 平移的相对论色散关系给出，\n$$\nE(\\mathbf{k},\\mathbf{r}) = \\sqrt{\\mathbf{k}^2 + M^2} + V(\\mathbf{r}),\n$$\n并且化学势满足局域关系\n$$\n\\mu = \\sqrt{k_F(\\mathbf{r})^2 + M^2} + V(\\mathbf{r}),\n$$\n因此局域费米动量 $k_F(\\mathbf{r})$ 等于\n$$\nk_F(\\mathbf{r}) = \\sqrt{\\max\\left(0, \\left[\\mu - V(\\mathbf{r})\\right]^2 - M^2\\right)}.\n$$\n对于对称核物质，自旋-同位旋简并因子为 $\\gamma = 4$，则局域重子密度为\n$$\n\\rho(\\mathbf{r}) = \\frac{\\gamma}{6\\pi^2}\\,k_F(\\mathbf{r})^3.\n$$\n\n你的任务是为一个边长为 $L$、具有 $N^3$ 个均匀网格点的周期性立方盒子实现一个自洽求解器。该求解器必须：\n\n1. 将密度初始化为一个均匀背景，该背景由 $\\mu$ 计算得出，并加上一个以盒子中心为中心的高斯凸起，\n$$\n\\rho_{\\mathrm{init}}(\\mathbf{r}) = \\rho_{\\mathrm{bg}} + A\\exp\\left(-\\frac{|\\mathbf{r}|^2}{2\\sigma^2}\\right), \\quad \\rho_{\\mathrm{bg}} = \\frac{\\gamma}{6\\pi^2}\\left[\\max\\left(0,\\sqrt{\\mu^2 - M^2}\\right)\\right]^3,\n$$\n其中 $A$ 是凸起的振幅，$\\sigma$ 是其宽度。\n\n2. 迭代自洽循环：\n   - 使用谱形式 $\\tilde{V}(\\mathbf{k}) = \\tilde{K}(\\mathbf{k})\\tilde{\\rho}(\\mathbf{k})$ 和周期性边界条件，通过快速傅里叶变换 (FFT) 从 $\\rho(\\mathbf{r})$ 计算 $V(\\mathbf{r})$。\n   - 使用上面的局域费米动量表达式更新密度。\n   - 应用参数为 $\\alpha$ 的线性混合：\n     $$\n     \\rho^{(n+1)}(\\mathbf{r}) = (1 - \\alpha)\\,\\rho^{(n)}(\\mathbf{r}) + \\alpha\\,\\rho_{\\mathrm{new}}(\\mathbf{r}).\n     $$\n   - 当密度的最大绝对变化满足\n     $$\n     \\|\\rho_{\\mathrm{new}} - \\rho^{(n)}\\|_{\\infty}  \\varepsilon,\n     $$\n     或达到最大迭代次数时停止。\n\n3. 实现求解器的两个变体以研究混叠现象：\n   - 一个没有谱滤波的“直接”基于 FFT 的求解器。\n   - 一个使用三分之二规则的“去混叠”求解器：在构建 $\\rho_{\\mathrm{new}}(\\mathbf{r})$ 之后，将其变换到傅里叶空间，并将任何分量满足 $|k_i| > \\frac{2}{3}k_{\\mathrm{Ny}}$ 的所有模式设置为零，其中 $k_{\\mathrm{Ny}} = \\frac{\\pi N}{L}$ 是奈奎斯特波数，然后在混合前回变换到实空间。\n\n使用动量网格间距\n$$\n\\Delta k = \\frac{2\\pi}{L},\n$$\n对于每个测试用例，都必须以 fm$^{-1}$ 为单位报告该值。\n\n通过计算每个测试用例的以下内容来量化混叠效应和自洽性：\n- $\\Delta k$ 的值，单位为 fm$^{-1}$。\n- 收敛的直接矢量势和去混叠矢量势之间的相对差异，\n$$\n\\mathrm{err} = \\frac{\\|\\ V_{\\mathrm{direct}} - V_{\\mathrm{dealiased}}\\ \\|_2}{\\|\\ V_{\\mathrm{dealiased}}\\ \\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是网格上的欧几里得范数。\n- 一个布尔值，指示直接求解器是否达到不动点容差；以及一个布尔值，指示去混叠求解器是否达到不动点容差。\n\n为以下测试套件实现程序（所有长度单位为 fm，所有动量单位为 fm$^{-1}$）：\n\n- 情况 1 (理想情况，特征温和)：$N = 32$, $L = 30$, $\\sigma = 4$, $A = 0.05$, $M = 4.759$, $m_\\omega = 3.97$, $g_\\omega = 1.0$, $\\mu = 5.0$, $\\alpha = 0.4$, $\\varepsilon = 10^{-6}$, 最大迭代次数 $= 200$.\n- 情况 2 (中等分辨率，更陡峭的凸起)：$N = 24$, $L = 18$, $\\sigma = 2$, $A = 0.08$, $M = 4.759$, $m_\\omega = 3.97$, $g_\\omega = 1.0$, $\\mu = 5.0$, $\\alpha = 0.4$, $\\varepsilon = 10^{-6}$, 最大迭代次数 $= 200$.\n- 情况 3 (边界/边缘混叠，粗糙网格，陡峭的凸起)：$N = 16$, $L = 10$, $\\sigma = 1$, $A = 0.10$, $M = 4.759$, $m_\\omega = 3.97$, $g_\\omega = 1.0$, $\\mu = 5.0$, $\\alpha = 0.4$, $\\varepsilon = 10^{-6}$, 最大迭代次数 $= 200$.\n\n您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，本身是一个列表，包含按上述顺序排列的四个条目：\n$$\n\\left[\\left[\\Delta k_1, \\mathrm{err}_1, \\mathrm{success}_{\\mathrm{direct},1}, \\mathrm{success}_{\\mathrm{dealiased},1}\\right], \\left[\\Delta k_2, \\mathrm{err}_2, \\mathrm{success}_{\\mathrm{direct},2}, \\mathrm{success}_{\\mathrm{dealiased},2}\\right], \\left[\\Delta k_3, \\mathrm{err}_3, \\mathrm{success}_{\\mathrm{direct},3}, \\mathrm{success}_{\\mathrm{dealiased},3}\\right]\\right].\n$$\n所有报告的 $\\Delta k$ 必须以 fm$^{-1}$ 为单位，所有误差均为无单位浮点数。布尔值必须是字面上的 true/false 值。不得打印任何其他文本。", "solution": "在静态极限下，矢量介子的 RMF 描述源于将 Euler-Lagrange 方程应用于 RMF 拉格朗日密度函数的线性化矢量部分。在平均场不依赖时间的情况下，场方程简化为屏蔽泊松或亥姆霍兹型方程，\n$$\n\\left(-\\nabla^2 + m_\\omega^2\\right)\\,\\omega^0(\\mathbf{r}) = g_\\omega\\,\\rho(\\mathbf{r}),\n$$\n其中 $\\omega^0(\\mathbf{r})$ 是矢量场的类时分量，$m_\\omega$ 是矢量介子质量，$g_\\omega$ 是矢量耦合，而 $\\rho(\\mathbf{r})$ 是重子密度。在自由空间中的解是一个汤川卷积，\n$$\n\\omega^0(\\mathbf{r}) = \\int \\mathrm{d}^3 r'\\,\\frac{g_\\omega}{4\\pi}\\frac{e^{-m_\\omega |\\mathbf{r} - \\mathbf{r}'|}}{|\\mathbf{r} - \\mathbf{r}'|}\\,\\rho(\\mathbf{r}').\n$$\n由于核子矢量势为 $V(\\mathbf{r}) = g_\\omega \\omega^0(\\mathbf{r})$，它变为\n$$\nV(\\mathbf{r}) = \\int \\mathrm{d}^3 r'\\,K(\\mathbf{r}-\\mathbf{r}')\\,\\rho(\\mathbf{r}'), \\quad K(\\mathbf{r}) = \\frac{g_\\omega^2}{4\\pi}\\frac{e^{-m_\\omega r}}{r}.\n$$\n在一个边长为 $L$、具有 $N^3$ 个均匀网格点的周期性区域中，使用卷积定理可以通过快速傅里叶变换 (FFT) 高效地计算卷积。用波浪线表示傅里叶变换，\n$$\n\\tilde{V}(\\mathbf{k}) = \\tilde{K}(\\mathbf{k})\\,\\tilde{\\rho}(\\mathbf{k}), \\quad \\tilde{K}(\\mathbf{k}) = \\frac{g_\\omega^2}{\\mathbf{k}^2 + m_\\omega^2}.\n$$\n这里 $\\mathbf{k}$ 遍历与周期性边界条件一致的离散波矢，其分量为\n$$\nk_i = \\frac{2\\pi}{L}\\,n_i, \\quad n_i \\in \\left\\{-\\frac{N}{2},\\ldots,\\frac{N}{2}-1\\right\\}.\n$$\n在浮点 FFT 实现中，这些值可以方便地从返回离散频率的函数中获得，并乘以 $2\\pi$ 将单位长度的周期数转换为单位长度的弧度数。\n\n对于重子密度和自洽更新，我们使用相对论费米气体表达式，其中自旋-同位旋简并度 $\\gamma = 4$ 适用于对称核物质。位于位置 $\\mathbf{r}$ 的核子单粒子能量为\n$$\nE(\\mathbf{k},\\mathbf{r}) = \\sqrt{\\mathbf{k}^2 + M^2} + V(\\mathbf{r}),\n$$\n其中 $M$ 是核子质量。通过化学势条件定义局域费米动量\n$$\n\\mu = \\sqrt{k_F(\\mathbf{r})^2 + M^2} + V(\\mathbf{r}),\n$$\n我们得到\n$$\nk_F(\\mathbf{r}) = \\sqrt{\\max\\left(0, \\left[\\mu - V(\\mathbf{r})\\right]^2 - M^2\\right)}.\n$$\n局域密度随之而来\n$$\n\\rho(\\mathbf{r}) = \\frac{\\gamma}{6\\pi^2}\\,k_F(\\mathbf{r})^3.\n$$\n这个映射 $\\rho(\\mathbf{r}) \\mapsto V(\\mathbf{r}) \\mapsto \\rho(\\mathbf{r})$ 定义了一个非线性不动点问题。我们通过不动点迭代和线性混合来解决它：\n$$\n\\rho^{(n+1)}(\\mathbf{r}) = (1 - \\alpha)\\,\\rho^{(n)}(\\mathbf{r}) + \\alpha\\,\\rho_{\\mathrm{new}}(\\mathbf{r}),\n$$\n其中 $\\rho_{\\mathrm{new}}$ 是通过局域费米动量关系从 $V$ 得到的密度，$\\alpha \\in (0,1)$ 控制稳定性，$n$ 是迭代索引。使用无穷范数监测连续密度之间的差异来判断收敛性，\n$$\n\\|\\rho_{\\mathrm{new}} - \\rho^{(n)}\\|_{\\infty}  \\varepsilon.\n$$\n\n当非线性操作产生的光谱内容超出奈奎斯特波数 $k_{\\mathrm{Ny}} = \\frac{\\pi N}{L}$ 时，就会出现混叠，这些内容会在离散表示中折返到较低的模式中。动量间距为 $\\Delta k = \\frac{2\\pi}{L}$，更精细的分辨率（更小的 $\\Delta k$ 和更大的 $k_{\\mathrm{Ny}}$）可以减少混叠。为了表征混叠对自洽性的影响，我们实现了两个求解器变体：一个没有谱滤波的“直接”求解器和一个对更新后的密度 $\\rho_{\\mathrm{new}}$ 应用三分之二规则的“去混叠”求解器。三分之二规则将任何分量满足\n$$\n|k_i| > \\frac{2}{3}k_{\\mathrm{Ny}},\n$$\n的傅里叶模式置零，从而移除每个方向上最高的三分之一模式，减轻了由高频分量的非线性生成引起的混叠。该滤波器在混合之前应用于 $\\rho_{\\mathrm{new}}$，迭代的其余部分照常进行。\n\n我们通过计算收敛后的矢量势的相对差异来量化混叠：\n$$\n\\mathrm{err} = \\frac{\\|\\ V_{\\mathrm{direct}} - V_{\\mathrm{dealiased}}\\ \\|_2}{\\|\\ V_{\\mathrm{dealiased}}\\ \\|_2},\n$$\n其中一个较小的值表示混叠影响最小。我们还报告每个求解器是否在迭代预算内达到了不动点容差 $\\varepsilon$。初始密度由化学势 $\\mu$ 构建为一个均匀背景\n$$\n\\rho_{\\mathrm{bg}} = \\frac{\\gamma}{6\\pi^2}\\left(\\max\\left[0,\\sqrt{\\mu^2 - M^2}\\right]\\right)^3,\n$$\n并加上一个振幅为 $A$、宽度为 $\\sigma$、位于盒子中心的高斯凸起：\n$$\n\\rho_{\\mathrm{init}}(\\mathbf{r}) = \\rho_{\\mathrm{bg}} + A\\exp\\left(-\\frac{|\\mathbf{r}|^2}{2\\sigma^2}\\right).\n$$\n\n每个测试用例的算法步骤如下：\n- 在 $[-L/2, L/2)$ 上构建每边有 $N$ 个点的均匀立方网格。\n- 使用 FFT 频率约定构建离散波矢分量，并计算 $\\tilde{K}(\\mathbf{k}) = \\frac{g_\\omega^2}{\\mathbf{k}^2 + m_\\omega^2}$。\n- 初始化 $\\rho$ 为 $\\rho_{\\mathrm{init}}$。\n- 迭代：通过谱乘法计算 $V$；使用局域费米动量计算 $\\rho_{\\mathrm{new}}$；可选择对 $\\rho_{\\mathrm{new}}$ 应用三分之二谱滤波器；混合以更新 $\\rho$；检查收敛性。\n- 收敛或达到最大迭代次数后，记录是否达到容差，并计算直接和去混叠收敛的 $V$ 场之间的相对差异。\n- 报告 $\\Delta k = \\frac{2\\pi}{L}$ 和各项指标。\n\n提供的测试套件涵盖了三种情况：一个分辨率良好的情况，一个分辨率中等但特征更陡峭的情况，以及一个用于暴露混叠的粗糙网格且特征陡峭的情况。最终程序输出一行结果，汇总为列表的列表：\n$$\n\\left[\\left[\\Delta k_1, \\mathrm{err}_1, \\mathrm{success}_{\\mathrm{direct},1}, \\mathrm{success}_{\\mathrm{dealiased},1}\\right], \\left[\\Delta k_2, \\mathrm{err}_2, \\mathrm{success}_{\\mathrm{direct},2}, \\mathrm{success}_{\\mathrm{dealiased},2}\\right], \\left[\\Delta k_3, \\mathrm{err}_3, \\mathrm{success}_{\\mathrm{direct},3}, \\mathrm{success}_{\\mathrm{dealiased},3}\\right]\\right].\n$$\n所有 $\\Delta k$ 值必须以 fm$^{-1}$ 为单位，而误差是无量纲浮点数。布尔值是表示求解器收敛性的字面 true/false 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef k_grid_components(N, L):\n    # FFT frequencies in cycles per unit length, convert to radians per unit length\n    freqs = np.fft.fftfreq(N, d=L/N) * 2.0 * np.pi\n    kx = freqs\n    ky = freqs\n    kz = freqs\n    return kx, ky, kz\n\ndef yukawa_kernel_k(kx, ky, kz, g_omega, m_omega):\n    # Construct k^2 on the 3D grid using broadcasting\n    KX, KY, KZ = np.meshgrid(kx, ky, kz, indexing='ij')\n    k2 = KX**2 + KY**2 + KZ**2\n    # Spectral Yukawa kernel: g^2 / (k^2 + m^2)\n    return (g_omega**2) / (k2 + m_omega**2)\n\ndef fft_convolution(rho, kernel_k):\n    # Convolution via FFT: V_k = K_k * rho_k, V = ifft(V_k)\n    rho_k = np.fft.fftn(rho)\n    V_k = kernel_k * rho_k\n    V = np.fft.ifftn(V_k).real\n    return V\n\ndef two_thirds_filter(field, kx, ky, kz):\n    # Apply 2/3 de-aliasing rule in Fourier space (per-component cutoff)\n    field_k = np.fft.fftn(field)\n    kx_abs = np.abs(kx)\n    ky_abs = np.abs(ky)\n    kz_abs = np.abs(kz)\n    kx_ny = np.max(kx_abs)\n    ky_ny = np.max(ky_abs)\n    kz_ny = np.max(kz_abs)\n    kx_cut = (2.0/3.0) * kx_ny\n    ky_cut = (2.0/3.0) * ky_ny\n    kz_cut = (2.0/3.0) * kz_ny\n    mask_x = (kx_abs = kx_cut)\n    mask_y = (ky_abs = ky_cut)\n    mask_z = (kz_abs = kz_cut)\n    mask = (mask_x[:, None, None]  mask_y[None, :, None]  mask_z[None, None, :])\n    field_k_filtered = field_k * mask\n    return np.fft.ifftn(field_k_filtered).real\n\ndef local_density_from_potential(V, mu, M, gamma=4.0):\n    # k_F(r) = sqrt( max(0, (mu - V)^2 - M^2) )\n    term = (mu - V)**2 - M**2\n    kF = np.sqrt(np.maximum(0.0, term))\n    rho_new = (gamma / (6.0 * np.pi**2)) * (kF**3)\n    return rho_new\n\ndef initialize_density(N, L, mu, M, A, sigma, gamma=4.0):\n    # Background density from uniform Fermi momentum\n    kF_bg = np.sqrt(max(0.0, mu**2 - M**2))\n    rho_bg = (gamma / (6.0 * np.pi**2)) * (kF_bg**3)\n    # Coordinates centered at 0\n    x = np.linspace(-L/2.0, L/2.0, N, endpoint=False)\n    y = np.linspace(-L/2.0, L/2.0, N, endpoint=False)\n    z = np.linspace(-L/2.0, L/2.0, N, endpoint=False)\n    X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n    r2 = X**2 + Y**2 + Z**2\n    bump = A * np.exp(-r2 / (2.0 * sigma**2))\n    rho_init = rho_bg + bump\n    return rho_init\n\ndef self_consistent_solver(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter, dealiased):\n    # Prepare k-space components and kernel\n    kx, ky, kz = k_grid_components(N, L)\n    kernel_k = yukawa_kernel_k(kx, ky, kz, g_omega, m_omega)\n    # Initialize density\n    rho = initialize_density(N, L, mu, M, A, sigma)\n    success = False\n    for _ in range(max_iter):\n        # Compute vector potential via FFT convolution\n        V = fft_convolution(rho, kernel_k)\n        # Local density update\n        rho_new = local_density_from_potential(V, mu, M)\n        # Optional de-aliasing filter on the updated density\n        if dealiased:\n            rho_new = two_thirds_filter(rho_new, kx, ky, kz)\n        # Mixing\n        rho_mixed = (1.0 - alpha) * rho + alpha * rho_new\n        # Convergence check\n        res = np.max(np.abs(rho_new - rho))\n        rho = rho_mixed\n        if res  tol:\n            success = True\n            break\n    # Final potential from converged density\n    V_final = fft_convolution(rho, kernel_k)\n    return rho, V_final, success\n\ndef run_case(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter):\n    # Direct solver\n    rho_d, V_d, succ_d = self_consistent_solver(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter, dealiased=False)\n    # Dealiased solver\n    rho_f, V_f, succ_f = self_consistent_solver(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter, dealiased=True)\n    # Relative error between direct and dealiased potentials\n    num = np.linalg.norm((V_d - V_f).ravel())\n    den = np.linalg.norm(V_f.ravel())\n    rel_err = float(num / den) if den != 0.0 else 0.0\n    # Delta k\n    dk = 2.0 * np.pi / L\n    return [dk, rel_err, succ_d, succ_f]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter)\n        (32, 30.0, 4.0, 0.05, 4.759, 3.97, 1.0, 5.0, 0.4, 1e-6, 200),\n        (24, 18.0, 2.0, 0.08, 4.759, 3.97, 1.0, 5.0, 0.4, 1e-6, 200),\n        (16, 10.0, 1.0, 0.10, 4.759, 3.97, 1.0, 5.0, 0.4, 1e-6, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter = case\n        result = run_case(N, L, sigma, A, M, m_omega, g_omega, mu, alpha, tol, max_iter)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The boolean values need to be lowercase 'true'/'false' for JSON-like output.\n    formatted_results = []\n    for r in results:\n        # r is [dk, err, succ_d, succ_f]\n        formatted_results.append(f\"[{r[0]}, {r[1]}, {str(r[2]).lower()}, {str(r[3]).lower()}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3589504"}, {"introduction": "针对形变原子核的实际RMF计算可能非常耗时，且简单的迭代混合方法常常难以收敛。这项高级练习引入了一个描述形变核的有限维模型，并要求你实现一个更复杂的准牛顿求解器 [@problem_id:3589498]。通过将其性能与简单混合法进行比较，你将深入了解用于确保和加速复杂自洽场问题收敛的强大技术。", "problem": "考虑一个简化的、有限维的相对论平均场 (Relativistic Mean-Field, RMF) 模型，用于描述轴向形变的原子核。该模型允许受控地破坏轴向对称性，并引入总角动量在对称轴上的不同投影分量之间的耦合。从包含局域洛伦兹 (Lorentz) 标量场和类时洛伦兹 (Lorentz) 矢量场的狄拉克 (Dirac) 方程出发，并采用标准的 RMF 自洽定义：标量场等于标量密度乘以一个耦合常数，矢量场等于重子（类时）密度乘以另一个耦合常数。在本问题中，您将构建一个对应于两个 $K$ 分量（$K=\\frac{1}{2}$ 和 $K=\\frac{3}{2}$）的双扇区模型，并研究这些 $K$ 分量之间的耦合如何改变自洽场更新映射。您还将推导并实现一个基于场扇区结构的块结构拟牛顿 (quasi-Newton) 预条件子。\n\n模型假设与定义：\n\n- 态空间是两个 $K$ 扇区的直和，每个扇区都具有双分量狄拉克 (Dirac) 结构（大分量和小分量）。最终的哈密顿量是一个作用于旋量 $\\psi=\\left(u_{1/2},\\ell_{1/2},u_{3/2},\\ell_{3/2}\\right)^{\\mathsf{T}}$ 上的 $4\\times 4$ 厄米矩阵。扇区 $K$ 的自由动能狄拉克 (Dirac) 块近似为一个 $2\\times 2$ 矩阵，具有恒定的有效非对角耦合和恒定的静止质量。将静止质量记为 $m$，并将 $K=\\frac{1}{2}$ 和 $K=\\frac{3}{2}$ 扇区中的动能耦合分别记为 $p_{1/2}$ 和 $p_{3/2}$。\n\n- 一个洛伦兹 (Lorentz) 标量场 $S_{K}$ 和一个类时洛伦兹 (Lorentz) 矢量场 $V_{K}$ 在每个 $K$ 扇区内起作用。块哈密顿量为\n$$\nH_{K}=\\begin{pmatrix}\nm+V_{K}  p_{K} \\\\\np_{K}  -m+S_{K}\n\\end{pmatrix},\n$$\n对于 $K\\in\\left\\{\\tfrac{1}{2},\\tfrac{3}{2}\\right\\}$。\n\n- 对称性破缺通过一个连接同类狄拉克 (Dirac) 分量的对角扇区间块 $B$ 来耦合两个 $K$ 扇区。令 $\\beta$ 表示一个无量纲的形变振幅，$\\eta$ 表示一个无量纲的对称性破缺强度。扇区间块被建模为\n$$\nB=\\eta\\,\\beta\\,\\begin{pmatrix}\nc_{uu}  0 \\\\\n0  c_{\\ell\\ell}\n\\end{pmatrix},\n$$\n其中 $c_{uu}$ 和 $c_{\\ell\\ell}$ 是固定的无量纲常数，表示在对称性破缺下，上分量和下分量在扇区间的耦合强度。完整的哈密顿量是 $4\\times 4$ 矩阵\n$$\nH=\\begin{pmatrix}\nH_{1/2}  B \\\\\nB  H_{3/2}\n\\end{pmatrix}.\n$$\n\n- 该模型使用标准的 RMF 自洽性：场由占据态旋量的密度决定。对于 $H$ 的一个归一化本征矢量 $\\psi$，定义按扇区分辨的重子（类时矢量）密度和标量密度为\n$$\nn_{v,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}+|\\ell_{K}|^{2}\\right),\\quad\nn_{s,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}-|\\ell_{K}|^{2}\\right),\n$$\n其中求和遍历所有占据的正能本征态。自洽方程为\n$$\nS_{K}=g_{s}\\,n_{s,K},\\quad V_{K}=g_{v}\\,n_{v,K},\n$$\n其中标量和矢量耦合常数分别为 $g_{s}$ 和 $g_{v}$。\n\n- 自洽场更新映射 $g:\\mathbb{R}^{4}\\to\\mathbb{R}^{4}$ 将一个场矢量 $x=\\left(S_{1/2},V_{1/2},S_{3/2},V_{3/2}\\right)$ 变换为 $x_{\\text{new}}=g(x)$，其获取步骤如下：\n  1. 根据 $x$ 构建 $H$，\n  2. 对角化 $H$，\n  3. 选取能量最低的正能本征态，直到达到固定的占据数 $N_{\\text{occ}}$，\n  4. 计算 $n_{s,K}$ 和 $n_{v,K}$，\n  5. 设置 $S_{K}=g_{s}\\,n_{s,K}$ 和 $V_{K}=g_{v}\\,n_{v,K}$。\n\n- 自洽性的不动点方程为 $x=g(x)$。定义残差 $F(x)=x-g(x)$；一个解满足 $F(x^{\\star})=0$。\n\n您的任务：\n\n1. 实现上述模型，参数包括 $m$, $p_{1/2}$, $p_{3/2}$, $g_{s}$, $g_{v}$, $c_{uu}$, $c_{\\ell\\ell}$，形变 $\\beta$，对称性破缺强度 $\\eta$，以及占据数 $N_{\\text{occ}}$。使用无量纲公式，不要引入任何物理单位。\n\n2. 对于一个给定的 $x$，通过对称有限差分法数值计算 $g(x)$ 和雅可比矩阵 $\\mathrm{D}g(x)$。由此计算谱半径 $\\rho\\left(\\mathrm{D}g(x)\\right)$ 和弗罗贝尼乌斯范数 (Frobenius-norm) 比率\n$$\nr_{\\text{off}}=\\frac{\\left\\|\\begin{pmatrix}0  J_{12}\\\\ J_{21}  0\\end{pmatrix}\\right\\|_{F}}{\\|J\\|_{F}},\n$$\n其中 $J=\\mathrm{D}g(x)$ 被划分为对应于变量 $\\left(S_{1/2},V_{1/2}\\right)$ 和 $\\left(S_{3/2},V_{3/2}\\right)$ 的 $2\\times 2$ 块 $J_{ij}$。这个 $r_{\\text{off}}$ 量化了 $K$ 分量的扇区间耦合如何进入自洽更新映射：越大的 $r_{\\text{off}}$ 表示越强的交叉耦合。\n\n3. 为 $F(x)=0$ 实现两种求解器：\n   - 一个线性混合不动点迭代 $x_{k+1}=x_{k}-\\alpha\\,F(x_{k})$，其中 $\\alpha\\in(0,1]$ 是一个固定的阻尼系数。\n   - 一个拟牛顿预处理迭代 $x_{k+1}=x_{k}-M(x_{k})\\,F(x_{k})$，其中 $M(x)$ 是一个块结构预条件子，通过仅反转 $\\mathrm{D}F(x)$ 的 $2\\times 2$ 对角块来近似 $\\left(\\mathrm{D}F(x)\\right)^{-1}$。此处，$\\mathrm{D}F(x)=I-\\mathrm{D}g(x)$，所以您的 $M(x)$ 是块对角矩阵，其块为 $\\left(I-\\mathrm{D}g(x)\\big|_{\\text{sector }K}\\right)^{-1}$，通过数值计算得到；如果需要，通过添加一个小的单位矩阵正倍数来正则化任何接近奇异的块，以确保其可逆性。\n\n4. 对于每个测试用例，从 $x_{0}=0$ 开始，对每个求解器进行迭代，直到 $\\|F(x_{k})\\|_{2}\\varepsilon$ 或达到最大迭代次数。对两个求解器使用相同的停止准则，并记录每种方法所需的迭代次数。\n\n5. 在收敛解 $x^{\\star}$ 处（如果收敛失败，则在最后一次迭代处），计算如上定义的 $\\rho\\left(\\mathrm{D}g\\left(x^{\\star}\\right)\\right)$ 和 $r_{\\text{off}}\\left(x^{\\star}\\right)$。\n\n测试套件和所需常数：\n\n- 使用 $m=1.0$, $p_{1/2}=0.8$, $p_{3/2}=1.2$, $g_{s}=-0.6$, $g_{v}=0.7$, $c_{uu}=0.5$, $c_{\\ell\\ell}=0.3$, $N_{\\text{occ}}=2$, $\\alpha=0.2$, $\\varepsilon=1.0\\times 10^{-8}$ 和 $\\text{max\\_iter}=500$。\n\n- 将以下四个测试用例定义为元组 $(\\beta,\\eta)$：\n  1. $(0.0,0.0)$,\n  2. $(0.2,0.05)$,\n  3. $(0.2,0.2)$,\n  4. $(0.2,0.4)$.\n\n最终输出规格：\n\n- 对于每个测试用例，您的程序必须生成一个包含四个条目的列表：谱半径 $\\rho\\left(\\mathrm{D}g\\left(x^{\\star}\\right)\\right)$（浮点数），非对角块比率 $r_{\\text{off}}\\left(x^{\\star}\\right)$（浮点数），线性混合求解器的迭代次数（整数），以及块结构拟牛顿预处理求解器的迭代次数（整数）。\n\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的四元列表的列表，并用方括号括起来（例如，$[\\,[\\rho_{1},r_{1},n_{1}^{\\text{lin}},n_{1}^{\\text{qN}}],\\ldots,[\\rho_{4},r_{4},n_{4}^{\\text{lin}},n_{4}^{\\text{qN}}]\\,]$）。\n\n所有计算都是无量纲的；不要使用任何物理单位。不涉及角度。所有数字内部均以双精度浮点数表示；最终输出是上述的列表结构。", "solution": "该问题要求为一个简化的相对论平均场 (Relativistic Mean-Field, RMF) 模型实现并分析一个自洽解。核心任务是找到一个迭代映射的不动点，该不动点代表了核系统的自洽状态。我们将开发必要的组件：自洽映射、其雅可比矩阵以及两种迭代求解器，然后将它们应用于指定的测试用例。\n\n### 1. 理论和算法框架\n\n#### 1.1. 模型哈密顿量和态空间\n\n系统由一个作用在四分量旋量 $\\psi=\\left(u_{1/2},\\ell_{1/2},u_{3/2},\\ell_{3/2}\\right)^{\\mathsf{T}}$ 上的 $4 \\times 4$ 哈密顿矩阵描述。态空间是两个扇区的直和，由量子数 $K$ 标识，其中 $K \\in \\left\\{\\frac{1}{2}, \\frac{3}{2}\\right\\}$。\n\n完整的哈密顿量 $H$ 由扇区内块 $H_K$ 和扇区间耦合块 $B$ 构建：\n$$\nH=\\begin{pmatrix}\nH_{1/2}  B \\\\\nB  H_{3/2}\n\\end{pmatrix}\n$$\n对于 $K \\in \\left\\{\\frac{1}{2}, \\frac{3}{2}\\right\\}$，扇区内块 $H_K$ 由下式给出：\n$$\nH_{K}=\\begin{pmatrix}\nm+V_{K}  p_{K} \\\\\np_{K}  -m+S_{K}\n\\end{pmatrix}\n$$\n其中 $m$ 是核子静止质量，$p_K$ 是扇区 $K$ 的有效动能耦合，$S_K$ 和 $V_K$ 分别是洛伦兹 (Lorentz) 标量和类时矢量平均场。\n\n扇区间耦合块 $B$ 模拟对称性破缺效应：\n$$\nB=\\eta\\,\\beta\\,\\begin{pmatrix}\nc_{uu}  0 \\\\\n0  c_{\\ell\\ell}\n\\end{pmatrix}\n$$\n此处，$\\beta$ 是一个形变参数，$\\eta$ 是对称性破缺强度，$c_{uu}$ 和 $c_{\\ell\\ell}$ 是无量纲耦合常数。当 $\\eta=0$ 或 $\\beta=0$ 时，哈密顿量恢复为块对角形式，从而解耦 $K$ 扇区。\n\n#### 1.2. 自洽映射 $g(x)$\n\n在 RMF 理论中，自洽性要求平均场由核子自身产生。这个反馈回路被表述为一个不动点问题。设场矢量为 $x = \\left(S_{1/2}, V_{1/2}, S_{3/2}, V_{3/2}\\right)^{\\mathsf{T}} \\in \\mathbb{R}^4$。自洽映射 $g:\\mathbb{R}^{4}\\to\\mathbb{R}^{4}$ 从一个输入矢量 $x$ 计算出更新后的场矢量 $x_{\\text{new}} = g(x)$。计算 $g(x)$ 的算法如下：\n\n1.  **构建哈密顿量**：给定一个输入场矢量 $x = (S_{1/2}, V_{1/2}, S_{3/2}, V_{3/2})$，根据上述定义组装 $4 \\times 4$ 实对称哈密顿矩阵 $H$。\n2.  **对角化哈密顿量**：求解 $H$ 的本征系统：$H\\psi_i = E_i\\psi_i$。由于 $H$ 是厄米矩阵（在我们的例子中是实对称矩阵），其本征值 $E_i$ 是实数，本征矢量 $\\psi_i$ 可以选择为标准正交的。我们得到 4 对本征对。\n3.  **确定占据态**：通过填充能量最低的单粒子态来构成物理基态。根据模型的规定，我们选择具有最低正本征值的 $N_{\\text{occ}}$ 个本征态。\n4.  **计算密度**：从占据的本征矢量集合 $\\{\\psi_{\\text{occ}}\\}$ 中，我们计算按扇区分辨的标量和矢量密度：\n    $$\n    n_{s,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}-|\\ell_{K}|^{2}\\right) \\quad \\text{和} \\quad n_{v,K}=\\sum_{\\text{occ}}\\left(|u_{K}|^{2}+|\\ell_{K}|^{2}\\right)\n    $$\n    其中 $u_K$ 和 $\\ell_K$ 是 $K$ 扇区内旋量的上分量和下分量。\n5.  **计算新场**：使用源方程计算新的场矢量 $x_{\\text{new}}$：\n    $$\n    S_{K,\\text{new}} = g_{s}\\,n_{s,K} \\quad \\text{和} \\quad V_{K,\\text{new}} = g_{v}\\,n_{v,K}\n    $$\n    其中 $g_s$ 和 $g_v$ 是给定的耦合常数。得到的矢量为 $x_{\\text{new}} = (S_{1/2,\\text{new}}, V_{1/2,\\text{new}}, S_{3/2,\\text{new}}, V_{3/2,\\text{new}})^{\\mathsf{T}}$。一个自洽解 $x^\\star$ 满足不动点条件 $x^\\star = g(x^\\star)$。\n\n#### 1.3. 迭代求解器\n\n寻找不动点 $x^\\star$ 等价于寻找残差函数 $F(x) = x - g(x) = 0$ 的一个根。我们实现两种迭代方法来求解此方程。\n\n##### a) 线性混合\n这是一种带阻尼的不动点迭代。从一个初始猜测 $x_0$ 开始，迭代序列由下式生成：\n$$\nx_{k+1} = (1-\\alpha)x_k + \\alpha g(x_k) = x_k - \\alpha (x_k - g(x_k)) = x_k - \\alpha F(x_k)\n$$\n其中 $\\alpha \\in (0, 1]$ 是一个固定的阻尼因子，有助于稳定迭代过程。如果迭代矩阵的谱半径 $\\rho(I - \\alpha \\mathrm{D}F) = \\rho((1-\\alpha)I + \\alpha \\mathrm{D}g)$ 小于 1，则通常可以实现收敛。对于简单混合（$\\alpha=1$），此条件为 $\\rho(\\mathrm{D}g(x^\\star))  1$。\n\n##### b) 块结构拟牛顿法\n求解 $F(x)=0$ 的完整牛顿法是 $x_{k+1} = x_k - [\\mathrm{D}F(x_k)]^{-1} F(x_k)$，其中 $\\mathrm{D}F(x) = I - \\mathrm{D}g(x)$ 是残差的雅可比矩阵。该方法计算成本高昂，因为它需要在每一步计算并反转整个 $4 \\times 4$ 的雅可比矩阵。\n\n指定的拟牛顿法通过近似雅可比矩阵的逆来简化此过程。我们将雅可比矩阵 $\\mathrm{D}F(x)$ 划分为对应于两个 $K$ 扇区的 $2 \\times 2$ 块：\n$$\n\\mathrm{D}F(x) = \\begin{pmatrix} \\mathrm{D}F_{11}  \\mathrm{D}F_{12} \\\\ \\mathrm{D}F_{21}  \\mathrm{D}F_{22} \\end{pmatrix}\n$$\n预条件子 $M(x)$ 通过仅反转对角块并忽略非对角块来构造，从而近似 $(\\mathrm{D}F)^{-1}$：\n$$\nM(x) = \\begin{pmatrix} (\\mathrm{D}F_{11})^{-1}  0 \\\\ 0  (\\mathrm{D}F_{22})^{-1} \\end{pmatrix}\n$$\n迭代则由下式给出：\n$$\nx_{k+1} = x_{k} - M(x_k) F(x_k)\n$$\n该方法在线性响应的层面上有效地独立处理每个扇区内的自洽问题，而完整的非线性耦合保留在 $F(x_k)$ 中。预期它会比线性混合更有效，特别是当扇区间耦合（$\\mathrm{D}g$ 的非对角块）较弱时。为处理对角块中潜在的奇异性，在求逆之前会添加一个小的正则化项 $\\epsilon I$。\n\n#### 1.4. 数值雅可比矩阵和分析指标\n\n映射的雅可比矩阵 $J(x) = \\mathrm{D}g(x)$ 对拟牛顿求解器和解的分析都至关重要。为保证精度，它通过对称有限差分格式进行数值计算：\n$$\n\\frac{\\partial g_i}{\\partial x_j}(x) \\approx \\frac{g_i(x + h e_j) - g_i(x - h e_j)}{2h}\n$$\n其中 $h$ 是一个小步长，$e_j$ 是第 $j$ 个标准基矢量。\n\n在收敛解 $x^\\star$ 处，计算两个量：\n1.  **谱半径 $\\rho(\\mathrm{D}g(x^\\star))$**：这是不动点处雅可比矩阵的最大绝对本征值。它决定了简单不动点迭代（$x_{k+1}=g(x_k)$）的局部收敛速率。如果 $\\rho  1$，迭代会局部收敛。\n2.  **非对角块比率 $r_{\\text{off}}(x^\\star)$**：该指标量化了系统线性响应中扇区间耦合的强度。它被定义为雅可比矩阵 $J = \\mathrm{D}g(x^\\star)$ 的非对角块的弗罗贝尼乌斯范数 (Frobenius norm) 与整个雅可比矩阵的弗罗贝尼乌斯范数之比：\n    $$\n    r_{\\text{off}}=\\frac{\\left\\|\\begin{pmatrix}0  J_{12}\\\\ J_{21}  0\\end{pmatrix}\\right\\|_{F}}{\\|J\\|_{F}} = \\frac{\\sqrt{\\|J_{12}\\|_F^2 + \\|J_{21}\\|_F^2}}{\\|J\\|_F}\n    $$\n    $r_{\\text{off}}=0$ 的值表示在线性响应层面上扇区完全解耦，而较大的值表示扇区之间有更强的“串扰”，这会减慢简单混合方案的速度，并证明使用像拟牛顿法这样更复杂的求解器是合理的。\n\n### 2. 实现策略\n\n实现过程首先是为映射 $g(x)$ 定义一个函数。然后，在此基础上构建用于求解器和分析的封装函数。\n- 一个核心函数 `g_map` 实现第 1.2 节中描述的五个步骤。\n- 一个函数 `get_jacobian_Dg` 使用有限差分法计算 `g_map` 的雅可比矩阵。\n- 两个求解器函数 `linear_solver` 和 `qn_solver` 实现迭代方案。它们循环直到残差 $F(x)$ 的 $L_2$ 范数低于容差 $\\varepsilon$ 或达到最大迭代次数，然后返回最终解和迭代次数。\n- 一个 `analyze_solution` 函数从收敛的雅可比矩阵计算 $\\rho$ 和 $r_{\\text{off}}$。\n- 主脚本遍历由 $(\\beta, \\eta)$ 定义的四个测试用例，从 $x_0=0$ 开始为每个用例调用两个求解器，并收集所需的指标以进行最终的格式化输出。最终分析使用更稳健的拟牛顿求解器得到的收敛解。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import block_diag\n\n# Set a fixed seed for reproducibility of numerical results\nnp.random.seed(42)\n\ndef g_map(x, beta, eta, params):\n    \"\"\"\n    Computes the self-consistent field update map x_new = g(x).\n\n    Args:\n        x (np.ndarray): Current field vector [S_1/2, V_1/2, S_3/2, V_3/2].\n        beta (float): Deformation amplitude.\n        eta (float): Symmetry-breaking strength.\n        params (dict): Dictionary of model parameters.\n\n    Returns:\n        np.ndarray: The new field vector x_new.\n    \"\"\"\n    # Unpack fields and parameters\n    S_12, V_12, S_32, V_32 = x\n    m, p_12, p_32 = params['m'], params['p_12'], params['p_32']\n    c_uu, c_ll = params['c_uu'], params['c_ll']\n    N_occ = params['N_occ']\n    gs, gv = params['g_s'], params['g_v']\n\n    # 1. Build Hamiltonian\n    H_12 = np.array([[m + V_12, p_12], [p_12, -m + S_12]])\n    H_32 = np.array([[m + V_32, p_32], [p_32, -m + S_32]])\n    B = eta * beta * np.array([[c_uu, 0.0], [0.0, c_ll]])\n    H = np.block([[H_12, B], [B, H_32]])\n\n    # 2. Diagonalize Hamiltonian\n    # H is real symmetric, eigh is efficient and returns sorted eigenvalues\n    eigvals, eigvecs = np.linalg.eigh(H)\n\n    # 3. Identify Occupied States\n    pos_eig_indices = np.where(eigvals > 0)[0]\n    \n    # Ensure there are enough positive energy states\n    if len(pos_eig_indices)  N_occ:\n        # This case should not happen for the given parameters but is good practice\n        # to handle. We return the input vector to indicate a failure in the map.\n        return x\n\n    occupied_indices = pos_eig_indices[:N_occ]\n    occupied_vecs = eigvecs[:, occupied_indices]\n\n    # 4. Compute Densities\n    # occupied_vecs is (4, N_occ).\n    u_12 = occupied_vecs[0, :]\n    l_12 = occupied_vecs[1, :]\n    u_32 = occupied_vecs[2, :]\n    l_32 = occupied_vecs[3, :]\n\n    n_v_12 = np.sum(np.abs(u_12)**2 + np.abs(l_12)**2)\n    n_s_12 = np.sum(np.abs(u_12)**2 - np.abs(l_12)**2)\n    n_v_32 = np.sum(np.abs(u_32)**2 + np.abs(l_32)**2)\n    n_s_32 = np.sum(np.abs(u_32)**2 - np.abs(l_32)**2)\n\n    # 5. Compute New Fields\n    S_12_new = gs * n_s_12\n    V_12_new = gv * n_v_12\n    S_32_new = gs * n_s_32\n    V_32_new = gv * n_v_32\n\n    return np.array([S_12_new, V_12_new, S_32_new, V_32_new])\n\ndef get_jacobian_Dg(x, beta, eta, params):\n    \"\"\"\n    Computes the Jacobian of the g_map numerically using symmetric finite differences.\n    \"\"\"\n    n_dim = len(x)\n    J = np.zeros((n_dim, n_dim))\n    h = params.get('h_fd', 1e-7)\n    \n    for j in range(n_dim):\n        dx = np.zeros(n_dim)\n        dx[j] = h\n        g_plus = g_map(x + dx, beta, eta, params)\n        g_minus = g_map(x - dx, beta, eta, params)\n        J[:, j] = (g_plus - g_minus) / (2 * h)\n        \n    return J\n\ndef linear_solver(x0, beta, eta, params):\n    \"\"\"\n    Solves the fixed-point equation using linear mixing.\n    \"\"\"\n    x = x0.copy()\n    alpha = params['alpha']\n    max_iter = params['max_iter']\n    epsilon = params['epsilon']\n    \n    for i in range(max_iter):\n        g_x = g_map(x, beta, eta, params)\n        F_x = x - g_x\n        if np.linalg.norm(F_x)  epsilon:\n            return x, i + 1\n        x -= alpha * F_x\n        \n    return x, max_iter\n\ndef qn_solver(x0, beta, eta, params):\n    \"\"\"\n    Solves the fixed-point equation using the block-structured quasi-Newton method.\n    \"\"\"\n    x = x0.copy()\n    max_iter = params['max_iter']\n    epsilon = params['epsilon']\n    reg = params.get('reg', 1e-12)\n\n    for i in range(max_iter):\n        g_x = g_map(x, beta, eta, params)\n        F_x = x - g_x\n        \n        if np.linalg.norm(F_x)  epsilon:\n            return x, i + 1\n            \n        J_g = get_jacobian_Dg(x, beta, eta, params)\n        DF = np.eye(4) - J_g\n        \n        DF11 = DF[0:2, 0:2]\n        DF22 = DF[2:4, 2:4]\n        \n        try:\n            DF11_inv = np.linalg.inv(DF11 + reg * np.eye(2))\n            DF22_inv = np.linalg.inv(DF22 + reg * np.eye(2))\n        except np.linalg.LinAlgError:\n            # If inversion fails, fall back to a simple mixing step for this iteration\n            x -= params['alpha'] * F_x\n            continue\n\n        M = block_diag(DF11_inv, DF22_inv)\n        step = M @ F_x\n        x -= step\n        \n    return x, max_iter\n\ndef analyze_solution(x_star, beta, eta, params):\n    \"\"\"\n    Computes spectral radius and off-block ratio at the solution.\n    \"\"\"\n    J = get_jacobian_Dg(x_star, beta, eta, params)\n    \n    # Spectral radius\n    eigvals = np.linalg.eigvals(J)\n    rho = np.max(np.abs(eigvals))\n    \n    # Off-block ratio\n    J12 = J[0:2, 2:4]\n    J21 = J[2:4, 0:2]\n    \n    norm_off = np.sqrt(np.linalg.norm(J12, 'fro')**2 + np.linalg.norm(J21, 'fro')**2)\n    norm_full = np.linalg.norm(J, 'fro')\n    \n    r_off = norm_off / norm_full if norm_full > 0 else 0.0\n    \n    return rho, r_off\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    params = {\n        'm': 1.0, 'p_12': 0.8, 'p_32': 1.2,\n        'g_s': -0.6, 'g_v': 0.7,\n        'c_uu': 0.5, 'c_ll': 0.3,\n        'N_occ': 2, 'alpha': 0.2,\n        'epsilon': 1.0e-8, 'max_iter': 500,\n    }\n    \n    test_cases = [\n        (0.0, 0.0),    # case 1\n        (0.2, 0.05),   # case 2\n        (0.2, 0.2),    # case 3\n        (0.2, 0.4),    # case 4\n    ]\n\n    all_results = []\n    \n    for beta, eta in test_cases:\n        x0 = np.zeros(4)\n        \n        # Run both solvers\n        x_lin, n_lin = linear_solver(x0, beta, eta, params)\n        x_qn, n_qN = qn_solver(x0, beta, eta, params)\n        \n        # Use the converged solution for analysis. If both converge, they should be\n        # effectively identical. If one fails, use the one that converged.\n        # Here we use the result from the QN solver as it's generally more robust.\n        x_star = x_qn\n        \n        rho, r_off = analyze_solution(x_star, beta, eta, params)\n        \n        all_results.append([rho, r_off, n_lin, n_qN])\n\n    # Format the output string as required\n    result_str = \",\".join([\n        f\"[{res[0]:.8f},{res[1]:.8f},{res[2]},{res[3]}]\" for res in all_results\n    ])\n    \n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3589498"}]}