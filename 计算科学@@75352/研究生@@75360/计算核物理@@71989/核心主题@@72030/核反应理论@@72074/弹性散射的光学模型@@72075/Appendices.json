{"hands_on_practices": [{"introduction": "在光学模型中，求解带有复数势的径向薛定谔方程是计算散射可观测量的核心步骤。然而，势的虚部（吸收项）会给数值积分带来独特的挑战，可能导致解的指数增长和数值不稳定。本练习旨在通过分析对数微分传播方法的条件数，让你亲手探究这种不稳定性，并学习如何通过调整积分步长来保证计算结果的精度和可靠性 [@problem_id:3605853]。", "problem": "考虑一个核子从一个由光学模型描述的原子核上发生的径向弹性散射，其中中心势包含一个实部和一个吸收虚部。设约化质量近似为核子质量，因此比值 $\\hbar^2 / (2\\mu)$ 是一个常数 $20.735$，单位为 $\\mathrm{MeV \\cdot fm^2}$。对于具有轨道角动量 $\\ell$ 的分波，其约化径向波函数 $u(r)$ 的径向薛定谔方程为\n$$\n\\frac{d^2 u(r)}{dr^2} + K(r)\\,u(r) = 0,\n$$\n其中\n$$\nK(r) = \\frac{2\\mu E}{\\hbar^2} - \\frac{2\\mu V(r)}{\\hbar^2} - \\frac{\\ell(\\ell+1)}{r^2},\n$$\n这里 $E$ 是实验室能量，单位为 $\\mathrm{MeV}$，$r$ 是径向坐标，单位为 $\\mathrm{fm}$，$\\ell$ 是一个整数，$V(r)$ 是复光学势，单位为 $\\mathrm{MeV}$。中心势采用 Woods–Saxon 形式\n$$\nV(r) = V_{\\mathrm{r}}\\,f(r) + i\\,W\\,f(r), \\quad f(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)},\n$$\n其中 $V_{\\mathrm{r}}$ 是实部深度，单位为 $\\mathrm{MeV}$，$W$ 是虚部深度，单位为 $\\mathrm{MeV}$，使得吸收势有 $W  0$，$R = r_0 A^{1/3}$ 是对应质量数 $A$ 的半径，单位为 $\\mathrm{fm}$，$a$ 是弥散度，单位为 $\\mathrm{fm}$。\n\n定义对数导数 $Y(r) = \\frac{u'(r)}{u(r)}$。该对数导数满足 Riccati 方程\n$$\n\\frac{dY(r)}{dr} = -K(r) - Y(r)^2.\n$$\n一种常见的数值方法是在一个小的步长 $h$ 上传播 $Y(r)$，通过假设 $K(r)$ 在该步长内为常数，这使得局部方程简化为 $u''(r) + K\\,u(r) = 0$，其中 $K$ 为常数。设 $\\kappa = \\sqrt{K}$ 为 $K$ 的主平方根。在大小为 $h$ 的一个步长内，对数导数的精确常数-$K$ 更新是一个莫比乌斯变换\n$$\nY_{+} = \\frac{Y_{-}\\cos(\\kappa h) - \\kappa \\sin(\\kappa h)}{\\cos(\\kappa h) + \\frac{Y_{-}}{\\kappa}\\sin(\\kappa h)},\n$$\n其中 $Y_{-}$ 和 $Y_{+}$ 分别是步长开始和结束时的对数导数值。更新相对于 $Y_{-}$ 的敏感度（条件数）由导数的模 $\\left|\\frac{\\partial Y_{+}}{\\partial Y_{-}}\\right|$ 来量化。在对应于出射波的不动点 $Y = +\\,i\\,\\kappa$ 处进行计算，它简化为闭合形式\n$$\n\\left|\\frac{\\partial Y_{+}}{\\partial Y_{-}}\\right| = \\left|e^{i\\,\\kappa h}\\right|^{-2} = \\exp\\left(2\\,\\mathrm{Im}(\\kappa)\\,h\\right).\n$$\n此表达式表明，强吸收（导致 $\\mathrm{Im}(\\kappa) > 0$）会在每一步中引起数值扰动的指数放大，使得随着 $h$ 的增长，传播过程越来越病态。为强制施加一个条件数上限 $c_{\\max} > 1$，一种步长控制缓解措施是要求\n$$\n\\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right) \\le c_{\\max}\n\\quad\\Rightarrow\\quad\nh \\le \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa(r))},\n$$\n此要求对每个满足 $\\mathrm{Im}(\\kappa(r)) > 0$ 的 $r$ 逐点应用。\n\n您的任务是实现一个程序，对于给定的一组光学模型参数和统一的步长 $h$（单位为 $\\mathrm{fm}$），计算在一个径向区间 $[r_{\\min}, r_{\\max}]$ 上的条件数剖面\n$$\nC(r; h) = \\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right),\n$$\n并报告：\n- 最大条件数值 $C_{\\max}(h) = \\max_{r \\in [r_{\\min}, r_{\\max}]} C(r; h)$，为一个浮点数，以及\n- 推荐步长 $h_{\\mathrm{rec}}$（单位为 $\\mathrm{fm}$），该步长保证对所有 $r \\in [r_{\\min}, r_{\\max}]$ 都有 $C(r; h) \\le c_{\\max}$，计算公式为\n$$\nh_{\\mathrm{rec}} = \\min\\left(\\min_{r \\in [r_{\\min}, r_{\\max}],\\,\\mathrm{Im}(\\kappa(r))0} \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa(r))},\\, h_{\\mathrm{cap}}\\right),\n$$\n其中 $h_{\\mathrm{cap}}$ 是用户施加的上限（单位为 $\\mathrm{fm}$），以确保即使在没有吸收的情况下也能解析势的变化。使用 $h_{\\mathrm{cap}} = 0.5$（单位 $\\mathrm{fm}$），$r_{\\min} = 0.2$（单位 $\\mathrm{fm}$），以及 $r_{\\max} = 15.0$（单位 $\\mathrm{fm}$）。如果没有吸收，以至于对所有 $r$ 都有 $\\mathrm{Im}(\\kappa(r)) \\approx 0$，则 $h_{\\mathrm{rec}} = h_{\\mathrm{cap}}$。\n\n物理单位必须遵守：所有能量单位为 $\\mathrm{MeV}$，所有长度单位为 $\\mathrm{fm}$，步长必须以 $\\mathrm{fm}$ 为单位报告。不使用角度。您的程序应实现以下测试用例集并产生指定的输出：\n- 情况 1（理想路径，中等吸收）：$A = 40$，$E = 50$，$V_{\\mathrm{r}} = 50$，$W = -5$，$\\ell = 0$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n- 情况 2（离心势垒影响）：$A = 208$，$E = 30$，$V_{\\mathrm{r}} = 60$，$W = -20$，$\\ell = 6$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n- 情况 3（强吸收，势刚度）：$A = 208$，$E = 10$，$V_{\\mathrm{r}} = 50$，$W = -50$，$\\ell = 0$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n- 情况 4（无吸收边界）：$A = 40$，$E = 80$，$V_{\\mathrm{r}} = 40$，$W = 0$，$\\ell = 0$，$r_0 = 1.25$，$a = 0.65$，$h = 0.05$，$c_{\\max} = 10$。\n\n对于每种情况，计算如上定义的 $C_{\\max}(h)$ 和 $h_{\\mathrm{rec}}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式如下\n$$\n[\\;C_{\\max}^{(1)},\\,h_{\\mathrm{rec}}^{(1)},\\,C_{\\max}^{(2)},\\,h_{\\mathrm{rec}}^{(2)},\\,C_{\\max}^{(3)},\\,h_{\\mathrm{rec}}^{(3)},\\,C_{\\max}^{(4)},\\,h_{\\mathrm{rec}}^{(4)}\\;],\n$$\n其中每个条目都是一个使用标准十进制表示法的浮点数。", "solution": "问题陈述已经过验证，并被确定为是合理的。它在科学上基于计算核物理的原理，特别是弹性散射的光学模型。所有参数、定义和约束都定义良好、自洽且物理上合理，使得该问题是适定且可解的。因此，我们可以着手推导和实现解决方案。\n\n问题的核心是分析在使用对数导数方法积分径向薛定谔方程时的数值条件。条件数与局域波数 $\\kappa(r)$ 的虚部有关。我们的任务是为几组参数集计算两个量：在固定步长 $h$ 下，一个径向区间上的最大条件因子 $C_{\\max}(h)$，以及为将条件数保持在指定阈值 $c_{\\max}$ 以下而推荐的步长 $h_{\\mathrm{rec}}$。\n\n算法流程如下：\n\n首先，我们将所有相关物理量定义为径向坐标 $r$ 的函数。常数比值 $\\frac{\\hbar^2}{2\\mu}$ 给出为 $c_0 = 20.735 \\, \\mathrm{MeV \\cdot fm^2}$。\n\n描述核势形状的 Woods-Saxon 形状因子 $f(r)$ 由下式给出：\n$$\nf(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}\n$$\n其中核半径 $R$ 由质量数 $A$ 和半径参数 $r_0$ 决定，即 $R = r_0 A^{1/3}$。参数 $a$ 是弥散度。\n\n复光学势 $V(r)$ 是一个实部（折射）部分（深度为 $V_{\\mathrm{r}}$）和一个虚部（吸收）部分（深度为 $W$）的和：\n$$\nV(r) = (V_{\\mathrm{r}} + i\\,W) f(r)\n$$\n负的 $W$ 值对应于吸收，这在核反应理论中是标准做法。\n\n根据势，我们构造出现在径向薛定谔方程中的、与位置相关的波数平方 $K(r)$。其定义是：\n$$\nK(r) = \\frac{2\\mu E}{\\hbar^2} - \\frac{2\\mu V(r)}{\\hbar^2} - \\frac{\\ell(\\ell+1)}{r^2}\n$$\n使用提供的常数 $c_0$，这变为：\n$$\nK(r) = \\frac{E - V(r)}{c_0} - \\frac{\\ell(\\ell+1)}{r^2}\n$$\n这里，$E$ 是动能，涉及轨道角动量 $\\ell$ 的项是离心势。$K(r)$ 是一个复值函数。\n\n局域波数则是 $K(r)$ 的主平方根：\n$$\n\\kappa(r) = \\sqrt{K(r)}\n$$\n由于 $K(r)$ 是复数，$\\kappa(r)$ 也将是复数，形式为 $\\kappa(r) = \\mathrm{Re}(\\kappa(r)) + i\\,\\mathrm{Im}(\\kappa(r))$。虚部 $\\mathrm{Im}(\\kappa(r))$ 是问题的核心。如果 $\\mathrm{Im}(\\kappa(r)) > 0$，波函数表现出指数行为，这在数值积分的背景下会导致误差的放大。\n\n问题将步长为 $h$ 的条件数剖面 $C(r; h)$ 定义为：\n$$\nC(r; h) = \\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right)\n$$\n\n为了找到最大条件因子 $C_{\\max}(h)$ 和推荐步长 $h_{\\mathrm{rec}}$，我们必须在指定的径向区间 $[r_{\\min}, r_{\\max}] = [0.2, 15.0]$ 上评估这些函数。由于这些是连续函数，我们采用数值方法，将区间离散化为一个精细的点网格 $\\{r_j\\}$。我们将使用一个包含 $15000$ 个点的网格以确保高分辨率。\n\n为每个测试用例计算所需输出的算法如下：\n\n1.  **离散化定义域**：生成一个从 $r_{\\min} = 0.2 \\, \\mathrm{fm}$ 到 $r_{\\max} = 15.0 \\, \\mathrm{fm}$ 的径向点数组 $r_j$。\n2.  **在网格上计算函数值**：对于网格中的每个点 $r_j$，按顺序计算一系列值：$f(r_j)$、$V(r_j)$、$K(r_j)$，最后是 $\\kappa(r_j) = \\sqrt{K(r_j)}$。这将产生一个对应的复数 $\\kappa_j$ 值的网格。\n3.  **计算 $C_{\\max}(h)$**：\n    a. 提取每个 $\\kappa_j$ 值的虚部，得到一个数组 $\\mathrm{Im}(\\kappa_j)$。\n    b. 使用给定的步长 $h$，计算每个网格点的条件数值：$C_j = \\exp\\left(2 \\cdot \\mathrm{Im}(\\kappa_j) \\cdot h\\right)$。\n    c. 最大条件因子是 $C_j$ 数组中的最大值：$C_{\\max}(h) = \\max_j \\{C_j\\}$。\n4.  **计算 $h_{\\mathrm{rec}}$**：\n    a. 识别所有满足 $\\mathrm{Im}(\\kappa_j)$ 大于零的网格点 $r_j$（使用一个小的数值容差来处理浮点伪影）。\n    b. 如果不存在这样的点（即对于一个纯实势，其中 $K(r)$ 总是正的），问题规定 $h_{\\mathrm{rec}} = h_{\\mathrm{cap}}$，其中 $h_{\\mathrm{cap}} = 0.5 \\, \\mathrm{fm}$。\n    c. 如果存在 $\\mathrm{Im}(\\kappa_j) > 0$ 的点，为这些点中的每一个计算局部步长限制：\n    $$\n    h_{\\mathrm{lim}, j} = \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa_j)}\n    $$\n    d. 找到这些限制的最小值：$h_{\\mathrm{lim}}^{\\min} = \\min_j \\{h_{\\mathrm{lim}, j}\\}$。这个值是由吸收势施加的最强的步长约束。\n    e. 推荐的步长 $h_{\\mathrm{rec}}$ 是这个最小值和全局上限 $h_{\\mathrm{cap}}$ 中较小的一个：\n    $$\n    h_{\\mathrm{rec}} = \\min(h_{\\mathrm{lim}}^{\\min}, h_{\\mathrm{cap}})\n    $$\n\n对所提供的四个测试用例中的每一个都执行此程序，并将得到的 $(C_{\\max}(h), h_{\\mathrm{rec}})$ 对收集起来，并按指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the conditioning profile and recommended step size for the optical model\n    of elastic scattering as described in the problem statement.\n    \"\"\"\n    # Define the physical constant\n    HBAR2_OVER_2MU = 20.735  # MeV * fm^2\n\n    # Define the test suite of cases\n    # Each case is a tuple: (A, E, V_r, W, l, r_0, a, h, c_max)\n    test_cases = [\n        # Case 1 (happy path, moderate absorption)\n        (40, 50, 50, -5, 0, 1.25, 0.65, 0.05, 10),\n        # Case 2 (centrifugal barrier influence)\n        (208, 30, 60, -20, 6, 1.25, 0.65, 0.05, 10),\n        # Case 3 (strong absorption, potential stiffness)\n        (208, 10, 50, -50, 0, 1.25, 0.65, 0.05, 10),\n        # Case 4 (no absorption boundary)\n        (40, 80, 40, 0, 0, 1.25, 0.65, 0.05, 10),\n    ]\n\n    # Fixed parameters for the calculation\n    R_MIN = 0.2  # fm\n    R_MAX = 15.0  # fm\n    H_CAP = 0.5  # fm\n    NUM_POINTS = 15000  # Number of points in the radial grid\n\n    # Generate the radial grid for numerical evaluation\n    r_grid = np.linspace(R_MIN, R_MAX, NUM_POINTS)\n    \n    # List to store all final results\n    all_results = []\n\n    for case in test_cases:\n        A, E, V_r, W, l, r0, a, h, c_max = case\n\n        # Calculate the nuclear radius a.k.a. R\n        R_nuc = r0 * A**(1/3)\n\n        # Calculate the Woods-Saxon form factor f(r) over the grid\n        f_of_r = 1.0 / (1.0 + np.exp((r_grid - R_nuc) / a))\n\n        # Calculate the complex optical potential V(r)\n        V_of_r = (V_r + 1j * W) * f_of_r\n\n        # Calculate the centrifugal term. r_grid does not contain 0, so this is safe.\n        centrifugal_term = l * (l + 1) / (r_grid**2)\n\n        # Calculate the K(r) function\n        # K(r) = ( E - V(r) ) / (hbar^2/2mu) - l(l+1)/r^2\n        K_of_r = (E - V_of_r) / HBAR2_OVER_2MU - centrifugal_term\n\n        # Calculate kappa(r) = sqrt(K(r)) using the principal square root\n        kappa_of_r = np.sqrt(K_of_r)\n\n        # Extract the imaginary part of kappa(r)\n        im_kappa = np.imag(kappa_of_r)\n        \n        # --- Task 1: Compute C_max(h) ---\n        # C(r; h) = exp(2 * Im(kappa(r)) * h)\n        conditioning_profile = np.exp(2 * im_kappa * h)\n        C_max_val = np.max(conditioning_profile)\n        \n        # --- Task 2: Compute h_rec ---\n        # Find indices where Im(kappa) > 0 using a small tolerance\n        pos_im_kappa_indices = np.where(im_kappa > 1e-15)\n        \n        if pos_im_kappa_indices[0].size == 0:\n            # If no absorption, h_rec is capped by the user-defined maximum\n            h_rec_val = H_CAP\n        else:\n            # Filter for positive imaginary parts of kappa\n            im_kappa_positive = im_kappa[pos_im_kappa_indices]\n            \n            # h_allowed = ln(c_max) / (2 * Im(kappa(r)))\n            h_allowed = np.log(c_max) / (2 * im_kappa_positive)\n            \n            # Find the most restrictive (minimum) step size\n            h_min_allowed = np.min(h_allowed)\n            \n            # h_rec is the minimum of the calculated limit and the user cap\n            h_rec_val = min(h_min_allowed, H_CAP)\n            \n        all_results.append(C_max_val)\n        all_results.append(h_rec_val)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3605853"}, {"introduction": "光学模型中的复数势意味着其哈密顿量是非厄米的，这深刻地影响了其量子力学形式体系。本练习将引导你超越简单地求解方程，去探索非厄米系统的“左”和“右”本征态以及它们之间的双正交关系。通过实现两种不同的归一化方案并计算散射截面，你将亲手验证一个基本原理：物理可观测量不依赖于双正交基的具体选择，这揭示了理论的内在一致性 [@problem_id:3605869]。", "problem": "要求您设计并实现一个完整的数值程序，该程序演示了在用于核子-原子核弹性散射的光学模型 (OM) 中，非厄米散射的双正交归一化，并验证了可观测的微分散射截面在此类归一化选择下保持不变。背景设定为一个中心复数 Woods–Saxon 光学势以及一个中子的分波散射。您的推导基础必须从不含时薛定谔方程和非厄米哈密顿量的双正交性基本定义开始。\n\n从第一性原理出发，构建以下内容：\n- 考虑质量为 $m$ 的中子在分波 $l$ 中，从一个球对称复数光学势 $U(r)$ 上进行弹性散射的径向不含时薛定谔方程，径向区间为 $r \\in [0,R_{\\text{max}}]$。您必须从运动方程出发，并施加在原点处有限的正则性条件。使用 $m$ 等于中子质量。将折合质量视为 $m$（这对于非常重的靶核是有效的）。\n- 将光学模型势处理为 Woods–Saxon 形式 $U(r) = V f(r) + i W f(r)$，其中 $f(r) = [1 + \\exp((r - R)/a)]^{-1}$。使用 $R = r_0 A^{1/3}$。\n- 对于指定范围内的每个分波 $l$，计算含 $U(r)$ 的非厄米薛定谔方程的“右”径向解 $u_R(r)$ 和含 $U^*(r)$ 的伴随方程的“左”径向解 $u_L(r)$。在小 $r$ 处施加相同的正则边界条件，并使用适用于二阶微分方程的高精度三点法，沿着均匀网格向外积分至 $R_{\\text{max}}$。将双正交内积定义为 $\\langle u_L|u_R\\rangle = \\int_0^{R_{\\text{max}}} u_L^*(r)\\,u_R(r)\\,dr$。\n- 对每个 $l$ 归一化 $\\{u_L,u_R\\}$，使得 $\\langle u_L|u_R\\rangle = 1$ 成立。证明存在无穷多个这样的双正交归一化：对于应用于 $u_R$ 的任何非零标度因子 $\\alpha \\in \\mathbb{R}$，存在一个应用于 $u_L$ 的倒数复数标度，可以保持 $\\langle u_L|u_R\\rangle=1$。实现由 $\\alpha_1$ 和 $\\alpha_2$ 表征的两种不同归一化选择，并确保在这两种情况下，对于每个 $l$，都分别满足 $\\langle u_L|u_R\\rangle = 1$。\n- 从超出 $U(r)$ 作用范围的渐近区（使用一个势可忽略的匹配半径 $R_{\\text{match}}$），利用向外积分得到的 $u_R(r)$ 和自由空间渐近基，推导并计算每个分波的散射矩阵 $S_l$。由 $S_l$ 和勒让德多项式组装在壳散射振幅 $f(\\theta)$，然后计算微分散射截面 $d\\sigma/d\\Omega = |f(\\theta)|^2$。\n- 明确验证由 $\\alpha_1$ 和 $\\alpha_2$ 表征的归一化选择在任何角度下都不会改变可观测的 $d\\sigma/d\\Omega$。通过计算每个测试案例中，在指定的角度列表上两组 $d\\sigma/d\\Omega(\\theta)$ 之间的最大绝对差，来量化数值上的一致性。\n\n使用以下物理和数值单位：\n- 能量单位为兆电子伏 (MeV)。\n- 半径单位为飞米 (fm)。\n- 角度 $\\theta$ 单位为弧度。\n- 在自然单位制中，$c=1$，中子质量 $m$ 为 $939.565\\ \\text{MeV}$，且 $\\hbar c = 197.3269804\\ \\text{MeV fm}$；使用以 $\\text{MeV fm}$ 表示的 $\\hbar$。将 $d\\sigma/d\\Omega$ 表示为 $\\text{fm}^2/\\text{sr}$。\n\n测试套件：\n- 案例1（吸收性光学模型，多个分波）：$A=90$， $E=10$ MeV， $V=-50$ MeV， $W=-5$ MeV， $r_0=1.25$ fm， $a=0.65$ fm， $l_{\\max}=3$， $R_{\\text{max}}=20$ fm， $R_{\\text{match}}=18$ fm， 角度 $\\theta \\in \\{0.0, 0.5, 1.0, 1.5, \\pi\\}$， $\\alpha_1=0.5$， $\\alpha_2=3.0$。\n- 案例2（厄米极限，仅 s 波）：$A=208$， $E=5$ MeV， $V=-50$ MeV， $W=0$ MeV， $r_0=1.25$ fm， $a=0.65$ fm， $l_{\\max}=0$， $R_{\\text{max}}=20$ fm， $R_{\\text{match}}=18$ fm， 角度 $\\theta \\in \\{0.0, \\pi/3, 2\\pi/3, \\pi\\}$， $\\alpha_1=1.0$， $\\alpha_2=2.0$。\n- 案例3（强吸收，更高能量）：$A=40$， $E=50$ MeV， $V=-40$ MeV， $W=-20$ MeV， $r_0=1.25$ fm， $a=0.6$ fm， $l_{\\max}=4$， $R_{\\text{max}}=20$ fm， $R_{\\text{match}}=18$ fm， 角度 $\\theta \\in \\{0.0, 0.3, 0.9, 1.5, \\pi\\}$， $\\alpha_1=0.7$， $\\alpha_2=1.8$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表。列表中的每个条目是该案例下两种归一化选择计算出的 $d\\sigma/d\\Omega$ 之间的最大绝对差，单位为 $\\text{fm}^2/\\text{sr}$，按案例1、案例2、案例3的顺序排列。例如，输出格式如“[$x_1,x_2,x_3$]”，其中每个 $x_i$ 是一个浮点数。", "solution": "我们从中子从球对称复势上弹性散射的不含时薛定谔方程开始。在光速 $c=1$ 的自然单位制中，折合质量取为中子质量 $m$。对于分波 $l$ 和径向函数 $u(r)$，其径向方程为\n$$\n\\frac{d^2 u(r)}{dr^2} + \\left[k^2 - \\frac{2 m}{\\hbar^2} U(r) - \\frac{l(l+1)}{r^2}\\right] u(r) = 0,\n$$\n其中 $k$ 是由动能 $E$ 决定的渐近波矢\n$$\nE = \\frac{\\hbar^2 k^2}{2 m} \\quad \\Rightarrow \\quad k = \\sqrt{\\frac{2 m E}{\\hbar^2}}.\n$$\n光学模型 (OM) 势选择为复数 Woods–Saxon 形式，\n$$\nU(r) = V f(r) + i W f(r), \\quad f(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}, \\quad R = r_0 A^{1/3},\n$$\n其中 $V$ 和 $W$ 是实数参数，$A$ 是靶核质量数。离心项 $\\frac{l(l+1)}{r^2}$ 确保了在原点处的正则行为；正则解在 $r \\to 0$ 时满足 $u(r) \\sim r^{l+1}$。\n\n对于非厄米的 $U(r)$，哈密顿量 $H = T + U$ 不等于其伴随算符 $H^\\dagger = T + U^*$。右本征函数满足 $(T + U) u_R = E u_R$，而左本征函数满足 $(T + U^*) u_L = E u_L$。左右函数之间自然的双正交内积配对为\n$$\n\\langle u_L | u_R \\rangle = \\int_0^{R_{\\text{max}}} u_L^*(r)\\,u_R(r)\\,dr,\n$$\n其中 $R_{\\text{max}}$ 是一个有限的径向截断半径，在此半径之外势可以忽略不计，解趋于自由行为。对于散射态，此配对是在具有一致边界条件和网格的有限区间上定义的。\n\n双正交归一化和标度不变性：\n假设对于给定的 $l$，我们已经计算出一对函数 $(u_{L,0}, u_{R,0})$，其内积为\n$$\nI_0 = \\int_0^{R_{\\text{max}}} u_{L,0}^*(r)\\,u_{R,0}(r)\\,dr.\n$$\n对于任意非零实数标度 $\\alpha$，定义一个重新标度的函数对\n$$\nu_R(r) = \\alpha\\, u_{R,0}(r), \\quad u_L(r) = \\beta\\, u_{L,0}(r),\n$$\n其中选择 $\\beta$ 以使 $\\langle u_L|u_R\\rangle = 1$。由于\n$$\n\\langle u_L|u_R\\rangle = \\int_0^{R_{\\text{max}}} (\\beta u_{L,0})^*(r)\\,(\\alpha u_{R,0}(r))\\,dr\n= \\alpha\\,\\beta^*\\, I_0,\n$$\n通过选择\n$$\n\\beta^* = \\frac{1}{\\alpha I_0} \\quad \\Rightarrow \\quad \\beta = \\frac{1}{\\alpha I_0^*}.\n$$\n即可满足条件 $\\langle u_L|u_R\\rangle = 1$。因此，存在一个由 $\\alpha \\in \\mathbb{R}\\setminus\\{0\\}$ 索引的单参数双正交归一化族。\n\n从渐近匹配得到散射矩阵：\n在匹配半径 $R_{\\text{match}}$ 之外，当 $U(r)$ 可忽略时，径向解可以表示为自由球面波的叠加。对于每个 $l$，外部解可以用球汉克尔函数 $h_l^{(\\pm)}(x) = j_l(x) \\pm i y_l(x)$ 表示，其中 $x=kr$，$j_l$ 和 $y_l$ 分别是球贝塞尔函数和球诺伊曼函数。一种标准表示法使用\n$$\nu(r) \\propto h_l^{(-)}(kr) - S_l\\, h_l^{(+)}(kr),\n$$\n其中 $S_l$ 是分波散射矩阵元。对于向外积分的右行解，令 $u_m = u(R_{\\text{match}})$ 和 $u'_m = \\left.\\frac{du}{dr}\\right|_{r=R_{\\text{match}}}$。在匹配半径处定义对数导数\n$$\nL_l = \\frac{u'_m}{u_m}.\n$$\n令 $x_m = k R_{\\text{match}}$, $h_\\pm = h_l^{(\\pm)}(x_m)$ 和 $h'_\\pm = \\left.\\frac{dh_l^{(\\pm)}(x)}{dx}\\right|_{x=x_m}$。将 $u$ 和 $u'$ 与外部形式匹配，得到代数关系\n$$\nS_l = \\frac{k h'_-(x_m) - L_l\\, h_-(x_m)}{k h'_+(x_m) - L_l\\, h_+(x_m)}.\n$$\n该表达式依赖于比率 $L_l = u'_m/u_m$，而不依赖于 $u$ 的绝对归一化。因此，任何均匀标度变换 $u \\to \\alpha u$ 在 $L_l$ 中都会被抵消，从而使 $S_l$ 保持不变。由于可观测的微分散射截面 $d\\sigma/d\\Omega$ 是由 $\\{S_l\\}$ 构建的，因此它在这种重新标度下是不变的。\n\n散射振幅和微分散射截面：\n对于中心势，弹性散射振幅由分波展开给出\n$$\nf(\\theta) = \\frac{1}{2 i k} \\sum_{l=0}^{l_{\\max}} (2 l + 1)\\,\\left(S_l - 1\\right)\\,P_l(\\cos\\theta),\n$$\n其中 $P_l$ 是勒让德多项式，$\\theta$ 是以弧度为单位的散射角。可观测的微分散射截面为\n$$\n\\frac{d\\sigma}{d\\Omega}(\\theta) = |f(\\theta)|^2,\n$$\n当 $k$ 的单位为 $\\text{fm}^{-1}$ 时，其单位为 $\\text{fm}^2/\\text{sr}$。\n\n算法设计：\n- 计算常数：使用 $\\hbar c = 197.3269804\\ \\text{MeV fm}$ 和 $m = 939.565\\ \\text{MeV}$；则对于每个案例，$\\hbar = \\hbar c$ 且 $k = \\sqrt{2 m E}/\\hbar$。\n- 构建一个从小的 $r_0$（避免 $r=0$）到 $R_{\\text{max}}$ 的均匀径向网格 $r_n$，步长为 $h$。对于每个 $l$，构建\n$$\nQ_l(r) = k^2 - \\frac{2 m}{\\hbar^2} U(r) - \\frac{l(l+1)}{r^2},\n$$\n并使用 Numerov 方法积分 $u'' + Q_l u = 0$。对于具有平滑变化 $Q(r)$ 的二阶线性微分方程，该方法可提供高精度。施加正则初始条件 $u(r_0) = r_0^{l+1}$ 和 $u(r_0 + h) = (r_0 + h)^{l+1}$，并向外积分。\n- 对于左行解，从相同的正则初始条件出发，积分含 $U^*(r)$ 的伴随方程以获得 $u_L(r)$。使用数值积分（例如，梯形法则）计算内积\n$$\nI_0^{(l)} = \\int_0^{R_{\\text{max}}} u_L^*(r)\\,u_R(r)\\,dr\n$$\n。对于每个 $l$，构建两种归一化选择 $\\alpha_1$ 和 $\\alpha_2$，以及配对的标度因子 $\\beta_1^{(l)} = 1/(\\alpha_1 [I_0^{(l)}]^*)$ 和 $\\beta_2^{(l)} = 1/(\\alpha_2 [I_0^{(l)}]^*)$，使得对于每个 $l$，$\\langle u_L|u_R\\rangle = 1$ 对每个选择都分别成立。\n- 对于每种归一化选择，使用重新标度的 $u_R$ 和 $u'_R$（通过有限差分）计算在 $R_{\\text{match}}$ 处的对数导数 $L_l$。然后使用球贝塞尔函数和球诺伊曼函数构成 $h_l^{(\\pm)}$ 及其导数来计算 $S_l$。由于 $L_l$ 在均匀标度变换下是不变的，因此在两种归一化选择下 $S_l$ 在数值上将是相等的。\n- 从 $\\{S_l\\}$ 组装 $f(\\theta)$ 并为指定角度计算 $d\\sigma/d\\Omega(\\theta) = |f(\\theta)|^2$。对于每个测试案例，计算其角度列表中两组 $d\\sigma/d\\Omega(\\theta)$ 之间的最大绝对差；该值在数值上应非常接近 $0$，因为可观测量在双正交重新标度下是不变的。\n\n输出和单位：\n- 最终程序打印一行，包含一个含三个浮点值的列表，每个测试案例一个值，表示在两种归一化选择下，在所有角度上的 $d\\sigma/d\\Omega$ 的最大绝对差，单位为 $\\text{fm}^2/\\text{sr}$。角度单位为弧度，能量单位为 MeV，半径单位为 fm。\n\n此构造测试：\n- 案例1，一个典型的吸收性OM，包含多个分波和多个角度。\n- 案例2，厄米极限（$W=0$）和仅 s 波（$l_{\\max}=0$），作为一个边界情况。\n- 案例3，在更高能量和更多分波下的强吸收。\n\n不变性结果源于 $S_l$ 仅依赖于对数导数 $L_l$，这会抵消任何整体的 $u_R$ 标度变换，并且光学模型振幅和 $d\\sigma/d\\Omega$ 由 $\\{S_l\\}$ 决定，而与施加在 $\\{u_L,u_R\\}$ 上的双正交归一化无关。在数值上，任何微小的残余差异都仅源于有限离散化和浮点舍入误差，与截面的绝对标度相比应可忽略不计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn, lpmv\n\n# Physical constants in natural units (c=1)\nHBAR_C = 197.3269804  # MeV fm\nHBAR = HBAR_C         # MeV fm\nM_NEUTRON = 939.565   # MeV\n\ndef woods_saxon(r, V, W, R, a):\n    \"\"\"Complex Woods–Saxon potential U(r) = (V + i W) f(r).\"\"\"\n    f = 1.0 / (1.0 + np.exp((r - R) / a))\n    return (V + 1j * W) * f\n\ndef numerov_integrate(l, k, U_arr, r, m, hbar):\n    \"\"\"\n    Integrate u'' + Q(r) u = 0 with Q(r) = k^2 - (2m/hbar^2) U(r) - l(l+1)/r^2\n    using the Numerov method. Returns complex u(r).\n    \"\"\"\n    h = r[1] - r[0]\n    # Avoid division by zero at r=0: assume r[0] > 0\n    Q = k**2 - (2.0 * m / (hbar**2)) * U_arr - (l * (l + 1)) / (r**2)\n    N = len(r)\n    u = np.zeros(N, dtype=np.complex128)\n    # Regular initial conditions near the origin: u ~ r^{l+1}\n    u[0] = r[0]**(l + 1)\n    u[1] = r[1]**(l + 1)\n    # Numerov recurrence\n    # u_{n+1} = [2 u_n (1 - 5 h^2 Q_n/12) - u_{n-1} (1 + h^2 Q_{n-1}/12)] / (1 + h^2 Q_{n+1}/12)\n    h2 = h * h\n    for n in range(1, N - 1):\n        c1 = 2.0 * u[n] * (1.0 - (5.0 * h2 * Q[n] / 12.0))\n        c2 = u[n - 1] * (1.0 + (h2 * Q[n - 1] / 12.0))\n        denom = (1.0 + (h2 * Q[n + 1] / 12.0))\n        # Avoid zero denominator by small regularization (rare)\n        if denom == 0:\n            denom = 1e-16 + 0j\n        u[n + 1] = (c1 - c2) / denom\n    return u\n\ndef log_derivative(u, r, r_match_index):\n    \"\"\"Compute logarithmic derivative L = u'/u at r_match using central difference for u'.\"\"\"\n    h = r[1] - r[0]\n    n = r_match_index\n    # Use central difference where possible; fall back to one-sided at boundaries\n    if 1 = n = len(r) - 2:\n        uprime = (u[n + 1] - u[n - 1]) / (2.0 * h)\n    elif n == 0:\n        uprime = (u[1] - u[0]) / h\n    else:\n        uprime = (u[n] - u[n - 1]) / h\n    if u[n] == 0:\n        return np.inf + 0j\n    return uprime / u[n]\n\ndef S_l_from_match(l, k, L, r_match):\n    \"\"\"Compute S_l using matching formula with spherical Hankel functions at r_match.\"\"\"\n    x = k * r_match\n    # Spherical Hankel functions h^{(+)} = j + i y, h^{(-)} = j - i y\n    j = spherical_jn(l, x)\n    y = spherical_yn(l, x)\n    jp = spherical_jn(l, x, derivative=True)\n    yp = spherical_yn(l, x, derivative=True)\n    h_plus = j + 1j * y\n    h_minus = j - 1j * y\n    h_plus_p = jp + 1j * yp  # derivative with respect to x\n    h_minus_p = jp - 1j * yp\n    # S = (k h_- ' - L h_-)/(k h_+ ' - L h_+)\n    num = k * h_minus_p - L * h_minus\n    den = k * h_plus_p - L * h_plus\n    # Avoid division by zero\n    if den == 0:\n        return np.nan + 0j\n    return num / den\n\ndef scattering_amplitude(k, S_list, thetas):\n    \"\"\"Compute f(theta) = (1/(2ik)) sum_{l}(2l+1)(S_l - 1) P_l(cos theta).\"\"\"\n    fvals = []\n    cos_t = np.cos(thetas)\n    for ct in cos_t:\n        f = 0.0 + 0.0j\n        for l, S in enumerate(S_list):\n            P_l = lpmv(0, l, ct)  # Legendre polynomial P_l(ct)\n            f += (2 * l + 1) * (S - 1.0) * P_l\n        f *= 1.0 / (2.0j * k)\n        fvals.append(f)\n    return np.array(fvals, dtype=np.complex128)\n\ndef differential_cross_section(fvals):\n    \"\"\"Return dσ/dΩ = |f(theta)|^2 in fm^2/sr.\"\"\"\n    return np.abs(fvals)**2\n\ndef inner_product_biorth(uL, uR, r):\n    \"\"\"Compute ⟨uL|uR⟩ = ∫ uL^*(r) uR(r) dr using trapezoidal rule.\"\"\"\n    integrand = np.conjugate(uL) * uR\n    return np.trapz(integrand, r)\n\ndef compute_case(case):\n    \"\"\"\n    Compute the maximum absolute difference in dσ/dΩ between two bi-orthogonal normalizations.\n    case: dict with parameters.\n    \"\"\"\n    # Unpack parameters\n    A = case[\"A\"]\n    E = case[\"E\"]  # MeV\n    V = case[\"V\"]\n    W = case[\"W\"]\n    r0 = case[\"r0\"]\n    a = case[\"a\"]\n    lmax = case[\"lmax\"]\n    Rmax = case[\"Rmax\"]\n    Rmatch = case[\"Rmatch\"]\n    angles = np.array(case[\"angles\"], dtype=float)\n    alpha1 = case[\"alpha1\"]\n    alpha2 = case[\"alpha2\"]\n\n    # Compute derived parameters\n    R = r0 * (A ** (1.0 / 3.0))\n    m = M_NEUTRON  # MeV\n    hbar = HBAR    # MeV fm\n    k = np.sqrt(2.0 * m * E) / hbar  # fm^{-1}\n\n    # Radial grid\n    h = 0.01  # fm step\n    # Avoid r=0 to handle centrifugal term; start at a small r0g = h\n    r = np.arange(h, Rmax + h/2.0, h, dtype=float)\n    # Matching index closest to Rmatch\n    idx_match = int(np.argmin(np.abs(r - Rmatch)))\n    r_match = r[idx_match]\n\n    # Precompute potential on grid\n    U_arr = woods_saxon(r, V, W, R, a)\n    U_adj_arr = np.conjugate(U_arr)\n\n    # For each l, compute right and left solutions, and two normalizations\n    # Store S_l for both normalizations; invariance should hold\n    S_list_1 = []\n    S_list_2 = []\n\n    for l in range(lmax + 1):\n        # Integrate right and left equations\n        uR0 = numerov_integrate(l, k, U_arr, r, m, hbar)\n        uL0 = numerov_integrate(l, k, U_adj_arr, r, m, hbar)\n\n        # Compute inner product I0^l\n        I0 = inner_product_biorth(uL0, uR0, r)\n\n        # Build normalization 1: alpha1 for uR, beta1 = 1/(alpha1 * I0^*)\n        beta1 = 1.0 / (alpha1 * np.conjugate(I0))\n        uR1 = alpha1 * uR0\n        uL1 = beta1 * uL0\n        # Check inner product (not printed): should be ~1\n        # I1 = inner_product_biorth(uL1, uR1, r)\n\n        # Normalization 2: alpha2 for uR, beta2 similarly\n        beta2 = 1.0 / (alpha2 * np.conjugate(I0))\n        uR2 = alpha2 * uR0\n        uL2 = beta2 * uL0\n        # I2 = inner_product_biorth(uL2, uR2, r)\n\n        # Compute logarithmic derivatives at match for both uR variants\n        L1 = log_derivative(uR1, r, idx_match)\n        L2 = log_derivative(uR2, r, idx_match)\n\n        # Compute S_l for both normalizations\n        S1 = S_l_from_match(l, k, L1, r_match)\n        S2 = S_l_from_match(l, k, L2, r_match)\n\n        S_list_1.append(S1)\n        S_list_2.append(S2)\n\n    # Assemble amplitudes and cross sections for both normalizations\n    f1 = scattering_amplitude(k, S_list_1, angles)\n    f2 = scattering_amplitude(k, S_list_2, angles)\n    dsdo1 = differential_cross_section(f1)\n    dsdo2 = differential_cross_section(f2)\n\n    # Maximum absolute difference across angles\n    max_diff = float(np.max(np.abs(dsdo1 - dsdo2)))\n    return max_diff\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": 90, \"E\": 10.0, \"V\": -50.0, \"W\": -5.0,\n            \"r0\": 1.25, \"a\": 0.65,\n            \"lmax\": 3,\n            \"Rmax\": 20.0, \"Rmatch\": 18.0,\n            \"angles\": [0.0, 0.5, 1.0, 1.5, np.pi],\n            \"alpha1\": 0.5, \"alpha2\": 3.0\n        },\n        {\n            \"A\": 208, \"E\": 5.0, \"V\": -50.0, \"W\": 0.0,\n            \"r0\": 1.25, \"a\": 0.65,\n            \"lmax\": 0,\n            \"Rmax\": 20.0, \"Rmatch\": 18.0,\n            \"angles\": [0.0, np.pi/3, 2*np.pi/3, np.pi],\n            \"alpha1\": 1.0, \"alpha2\": 2.0\n        },\n        {\n            \"A\": 40, \"E\": 50.0, \"V\": -40.0, \"W\": -20.0,\n            \"r0\": 1.25, \"a\": 0.6,\n            \"lmax\": 4,\n            \"Rmax\": 20.0, \"Rmatch\": 18.0,\n            \"angles\": [0.0, 0.3, 0.9, 1.5, np.pi],\n            \"alpha1\": 0.7, \"alpha2\": 1.8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3605869"}, {"introduction": "光学势不仅是一个唯象的拟合工具，它还必须遵循物理学的基本原理，其中最重要的就是因果性。因果性要求一个系统的响应不能发生在其原因之前，这一原理在数学上体现为光学势的实部和虚部通过Kramers-Kronig色散关系相互关联。本练习将指导你对一个解析模型势进行数值检验，亲手验证其能量依赖性是否满足色散关系，从而深刻理解因果性如何约束光学势的物理形式 [@problem_id:3605865]。", "problem": "你的任务是通过数值检验一个依赖于能量的光学势的实部与虚部之间的 Kramers–Kronig 关系，来验证弹性散射的色散光学模型的一致性。验证将针对一个在复能量平面的上半平面解析的模型光学势进行，从而确保其因果性。\n\n从一个基本前提开始：一个因果响应函数 $U(E)$ 在上半平面是解析的，这意味着它的实部和虚部通过 Kramers–Kronig 关系相互关联。为了确保在无穷远处不能足够快地趋于零的函数能够收敛，我们使用在一个减除点 $E_0$ 处的减除色散关系：\n$$\n\\Re U(E) - \\Re U(E_0)\n= \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{-\\infty}^{+\\infty} \\Im U(E')\n\\left[\n\\frac{1}{E' - E} - \\frac{1}{E' - E_0}\n\\right]\\,\\mathrm{d}E' ,\n$$\n其中 $\\mathcal{P}$ 表示 Cauchy 主值。在计算中，该积分将在一个有限的能量窗口 $[E_{\\min}, E_{\\max}]$ 上进行近似计算，如果 $\\Im U(E)$ 足够局域化，使得窗口外的尾部可以忽略不计，那么这种近似是合理的。\n\n为了进行具有可量化基准真相的数值测试，我们使用以下解析光学势模型：\n$$\nU(E) = \\frac{A}{E - E_c + i\\,\\Gamma},\n$$\n其中 $A$ 是一个单位为 $\\mathrm{MeV}^2$ 的正常数，$E_c$ 是一个单位为 $\\mathrm{MeV}$ 的中心能量，$\\Gamma$ 是一个单位为 $\\mathrm{MeV}$ 的宽度参数。这得到：\n$$\n\\Re U(E) = A\\,\\frac{E - E_c}{(E - E_c)^2 + \\Gamma^2},\n\\qquad\n\\Im U(E) = -A\\,\\frac{\\Gamma}{(E - E_c)^2 + \\Gamma^2},\n$$\n两者的单位均为 $\\mathrm{MeV}$。根据解析性，对于无穷积分限，上述减除 Kramers–Kronig 关系必须精确成立；你将通过数值计算来检验，当主值积分被截断到 $[E_{\\min},E_{\\max}]$ 时，该关系是否在微小误差范围内成立。\n\n你的程序必须：\n- 为上述给出的解析模型实现 $\\Im U(E)$ 和 $\\Re U(E)$。\n- 对每个测试用例，为积分窗口内的一组能量 $E$ 计算减除色散关系的预测值\n$$\nD(E;E_0) \\equiv \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\Im U(E')\n\\left[\n\\frac{1}{E' - E} - \\frac{1}{E' - E_0}\n\\right]\\,\\mathrm{d}E'\n$$\n并将其与精确差值 $\\Re U(E) - \\Re U(E_0)$ 进行比较。\n- 在点 $E$ 和 $E_0$ 处使用 Cauchy 主值定义来计算积分。\n- 对每个测试用例，报告在给定的 $E$ 网格上的最大绝对偏差所对应的单个标量结果：\n$$\n\\max_{E\\in \\mathcal{E}} \\left| \\left(\\Re U(E) - \\Re U(E_0)\\right) - D(E;E_0) \\right|,\n$$\n以 $\\mathrm{MeV}$ 为单位表示。\n\n所有能量、宽度和势值都必须以 $\\mathrm{MeV}$ 为单位处理。你最终打印的输出必须是单位为 $\\mathrm{MeV}$ 的浮点数。\n\n测试套件：\n- 用例 1 (一般情况):\n  - $A = 150\\,\\mathrm{MeV}^2$, $E_c = 40\\,\\mathrm{MeV}$, $\\Gamma = 8\\,\\mathrm{MeV}$。\n  - 减除点 $E_0 = 30\\,\\mathrm{MeV}$。\n  - 积分窗口 $[E_{\\min},E_{\\max}] = [-160\\,\\mathrm{MeV},\\,240\\,\\mathrm{MeV}]$。\n  - 求值集合 $\\mathcal{E} = \\{10,\\,20,\\,30,\\,40,\\,50,\\,60,\\,80\\}\\,\\mathrm{MeV}$。\n- 用例 2 (边界情况，$E_0$ 等于一个求值能量):\n  - $A = 80\\,\\mathrm{MeV}^2$, $E_c = 50\\,\\mathrm{MeV}$, $\\Gamma = 12\\,\\mathrm{MeV}$。\n  - 减除点 $E_0 = 50\\,\\mathrm{MeV}$。\n  - 积分窗口 $[E_{\\min},E_{\\max}] = [-250\\,\\mathrm{MeV},\\,350\\,\\mathrm{MeV}]$。\n  - 求值集合 $\\mathcal{E} = \\{20,\\,40,\\,50,\\,60,\\,80,\\,100\\}\\,\\mathrm{MeV}$。\n- 用例 3 (极端情况，宽度非常窄):\n  - $A = 100\\,\\mathrm{MeV}^2$, $E_c = 10\\,\\mathrm{MeV}$, $\\Gamma = 0.5\\,\\mathrm{MeV}$。\n  - 减除点 $E_0 = 0\\,\\mathrm{MeV}$。\n  - 积分窗口 $[E_{\\min},E_{\\max}] = [-100\\,\\mathrm{MeV},\\,120\\,\\mathrm{MeV}]$。\n  - 求值集合 $\\mathcal{E} = \\{5,\\,9.5,\\,10.0,\\,10.5,\\,20,\\,40\\}\\,\\mathrm{MeV}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个结果，形式为一个用方括号括起来的逗号分隔列表，单位为 $\\mathrm{MeV}$，每个结果四舍五入到六位小数。例如，输出应如下所示：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$", "solution": "该问题要求对弹性散射理论中使用的模型光学势 $U(E)$ 的减除 Kramers–Kronig (KK) 色散关系进行数值验证。该验证过程涉及将该势的解析已知实部与通过对其虚部进行积分计算出的值进行比较。\n\n其基本原理是因果性。在物理学中，一个因果响应函数（即结果不会先于原因）在数学上表示为一个在复频率（或能量）平面的上半平面解析的函数。由 Titchmarsh 定理确立的这种解析性的一个直接推论是，函数的实部和虚部不是独立的，而是通过 Kramers–Kronig 关系相互关联。对于一个当 $|E| \\to \\infty$ 时不能足够快地趋于零的光学势 $U(E)$，我们使用一种减除形式的色散关系来确保积分的收敛性。在一个选定的减除能量 $E_0$ 处，该关系为：\n$$\n\\Re U(E) - \\Re U(E_0) = \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{-\\infty}^{+\\infty} \\Im U(E') \\left[ \\frac{1}{E' - E} - \\frac{1}{E' - E_0} \\right]\\,\\mathrm{dE'}\n$$\n其中 $\\mathcal{P}$ 表示积分的 Cauchy 主值。\n\n该问题提供了一个特定的势的解析模型，该模型在下半平面有一个单极点，从而满足因果性要求。该势由以下公式给出：\n$$\nU(E) = \\frac{A}{E - E_c + i\\,\\Gamma}\n$$\n其中 $A$ 是一个单位为 $\\mathrm{MeV}^2$ 的强度参数，$E_c$ 是一个单位为 $\\mathrm{MeV}$ 的共振能量，$\\Gamma$ 是一个单位为 $\\mathrm{MeV}$ 的宽度参数，且 $\\Gamma  0$。该势的实部和虚部分别为：\n$$\n\\Re U(E) = A\\,\\frac{E - E_c}{(E - E_c)^2 + \\Gamma^2}\n$$\n$$\n\\Im U(E) = -A\\,\\frac{\\Gamma}{(E - E_c)^2 + \\Gamma^2}\n$$\n\n任务是在一个有限的积分窗口 $[E_{\\min}, E_{\\max}]$ 上数值计算 KK 关系的右侧，记为 $D(E; E_0)$：\n$$\nD(E;E_0) \\equiv \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\Im U(E') \\left[ \\frac{1}{E' - E} - \\frac{1}{E' - E_0} \\right]\\,\\mathrm{dE'}\n$$\n并量化其与解析已知的左侧 $\\Re U(E) - \\Re U(E_0)$ 的偏差。在指定的求值能量集合 $\\mathcal{E}$ 上的最大绝对偏差是每个测试用例的最终结果。\n\n数值计算的挑战在于计算 Cauchy 主值积分。被积函数在 $E' = E$ 和 $E' = E_0$ 处有奇点。$D(E; E_0)$ 的积分可以分解为两个独立的主值积分：\n$$\nD(E; E_0) = \\frac{1}{\\pi} \\left( \\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\frac{\\Im U(E')}{E' - E}\\,\\mathrm{d}E' - \\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\frac{\\Im U(E')}{E' - E_0}\\,\\mathrm{d}E' \\right)\n$$\n每个积分都具有 $\\mathcal{P}\\int_a^b \\frac{g(x)}{x-c}\\,\\mathrm{d}x$ 的形式。这类积分可以使用专门的数值求积程序进行稳健的计算。Python 的 SciPy 库中的 `scipy.integrate.quad` 函数非常适合此任务，它提供了一个 `weight='cauchy'` 选项，该选项接受函数 $g(x)$ 和奇点位置 $c$（作为 `wvar`）作为参数来计算主值。\n\n整体算法按以下步骤进行：\n1.  对每个测试用例，定义参数 $(A, E_c, \\Gamma)$、减除点 $E_0$、积分窗口 $[E_{\\min}, E_{\\max}]$ 以及求值能量集合 $\\mathcal{E}$。\n2.  根据其解析公式实现计算 $\\Re U(E)$ 和 $\\Im U(E)$ 的函数。\n3.  使用一个循环遍历每个求值能量 $E \\in \\mathcal{E}$。\n4.  在循环内部，对每个 $E$：\n    a. 直接计算“精确”差值 $\\Delta_{\\text{exact}} = \\Re U(E) - \\Re U(E_0)$。\n    b. 计算色散积分项 $D(E; E_0)$。如果 $E = E_0$，则被积函数恒等于零，因此 $D(E_0; E_0) = 0$。否则，使用带有 Cauchy 权重的 `scipy.integrate.quad` 计算两个主值积分，并将其差值乘以 $1/\\pi$。\n    c. 计算绝对偏差 $|\\Delta_{\\text{exact}} - D(E; E_0)|$。\n5.  找出所有 $E \\in \\mathcal{E}$ 中这些偏差的最大值，并将其作为该测试用例的结果存储。这个微小但非零的结果量化了主要由将无穷积分范围截断到 $[E_{\\min}, E_{\\max}]$ 所引入的误差，因为模型函数 $\\Im U(E')$ 的尾部延伸至 $\\pm\\infty$。\n6.  对所有三个指定的测试用例重复此过程，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It verifies the dispersive optical model consistency by checking the\n    Kramers-Kronig relation for a model potential.\n    \"\"\"\n\n    def Re_U(E, A, Ec, Gamma):\n        \"\"\"\n        Calculates the real part of the model optical potential.\n        \n        Args:\n            E (float): Energy in MeV.\n            A (float): Strength parameter in MeV^2.\n            Ec (float): Centroid energy in MeV.\n            Gamma (float): Width parameter in MeV.\n        \n        Returns:\n            float: Real part of the potential in MeV.\n        \"\"\"\n        return A * (E - Ec) / ((E - Ec)**2 + Gamma**2)\n\n    def Im_U(E_prime, A, Ec, Gamma):\n        \"\"\"\n        Calculates the imaginary part of the model optical potential.\n\n        Args:\n            E_prime (float): Integration variable for energy in MeV.\n            A (float): Strength parameter in MeV^2.\n            Ec (float): Centroid energy in MeV.\n            Gamma (float): Width parameter in MeV.\n        \n        Returns:\n            float: Imaginary part of the potential in MeV.\n        \"\"\"\n        return -A * Gamma / ((E_prime - Ec)**2 + Gamma**2)\n\n    def calculate_dispersion_integral(E, E0, Emin, Emax, A, Ec, Gamma):\n        \"\"\"\n        Calculates the subtracted dispersion integral D(E; E0) using a\n        Cauchy principal value numerical integration.\n        D(E;E0) = (1/pi) * P.V. integral[Im_U(E') * (1/(E'-E) - 1/(E'-E0))] dE'\n        \"\"\"\n        # If the evaluation energy is the same as the subtraction point,\n        # the integrand is zero everywhere, so the integral is zero.\n        if E == E0:\n            return 0.0\n\n        # The function passed to quad should be Im_U(E'). The (1/(E'-c)) part\n        # is handled by the 'cauchy' weight.\n        args_for_Im_U = (A, Ec, Gamma)\n\n        # Calculate the first principal value integral, with singularity at E.\n        integral_1, _ = quad(Im_U, Emin, Emax, args=args_for_Im_U, weight='cauchy', wvar=E)\n        \n        # Calculate the second principal value integral, with singularity at E0.\n        integral_2, _ = quad(Im_U, Emin, Emax, args=args_for_Im_U, weight='cauchy', wvar=E0)\n\n        # Combine results according to the dispersion relation formula.\n        D_E_E0 = (1.0 / np.pi) * (integral_1 - integral_2)\n        return D_E_E0\n\n    def solve_case(params):\n        \"\"\"\n        Solves a single test case.\n        \n        Args:\n            params (dict): A dictionary containing all parameters for the case.\n            \n        Returns:\n            float: The maximum absolute deviation in MeV.\n        \"\"\"\n        A = params['A']\n        Ec = params['Ec']\n        Gamma = params['Gamma']\n        E0 = params['E0']\n        Emin, Emax = params['window']\n        E_set = params['E_set']\n        \n        max_deviation = 0.0\n\n        for E_eval in E_set:\n            # Calculate the expected difference from the analytic formula for Re(U).\n            exact_diff = Re_U(E_eval, A, Ec, Gamma) - Re_U(E0, A, Ec, Gamma)\n            \n            # Calculate the difference from the numerical dispersion integral.\n            numerical_D = calculate_dispersion_integral(E_eval, E0, Emin, Emax, A, Ec, Gamma)\n            \n            # Calculate the absolute deviation.\n            deviation = np.abs(exact_diff - numerical_D)\n            \n            # Update the maximum deviation found so far.\n            if deviation > max_deviation:\n                max_deviation = deviation\n                \n        return max_deviation\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": 150.0, \"Ec\": 40.0, \"Gamma\": 8.0,\n            \"E0\": 30.0,\n            \"window\": [-160.0, 240.0],\n            \"E_set\": [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 80.0]\n        },\n        {\n            \"A\": 80.0, \"Ec\": 50.0, \"Gamma\": 12.0,\n            \"E0\": 50.0,\n            \"window\": [-250.0, 350.0],\n            \"E_set\": [20.0, 40.0, 50.0, 60.0, 80.0, 100.0]\n        },\n        {\n            \"A\": 100.0, \"Ec\": 10.0, \"Gamma\": 0.5,\n            \"E0\": 0.0,\n            \"window\": [-100.0, 120.0],\n            \"E_set\": [5.0, 9.5, 10.0, 10.5, 20.0, 40.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats with 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3605865"}]}