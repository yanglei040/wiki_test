{"hands_on_practices": [{"introduction": "R矩阵理论的一大挑战在于将其抽象的参数与可测量的物理量联系起来。本练习旨在通过一个基础性的推导，揭示R矩阵参数与低能中子散射行为之间的直接联系。你将探索在低能极限下，如何从给定的R矩阵通道半径 $a$ 和代表遥远能级贡献的背景项 $R_0^\\infty$ 出发，推导出有效的势散射半径 $R'$ [@problem_id:421971]。这个实践将帮助你理解R矩阵形式理论如何描述现实世界中的散射现象。", "problem": "在核反应的R矩阵理论中，对于s波 ($l=0$) 中子从一个自旋为零的靶核上发生的单通道、非相对论性弹性散射，散射相移 $\\delta_0$ 与复合核系统的性质有关。这种关系可以通过无量纲的R矩阵参数 $R_0(E)$ 表示为：\n$$\n\\cot(\\delta_0 + k a) = \\frac{1}{k a R_0(E)}\n$$\n此处，$k$ 是中子波数，$a$ 是通道半径（靶核的有效半径），$E = \\frac{\\hbar^2 k^2}{2m}$ 是质心系能量，其中 $m$ 是折合质量。\n\nR矩阵参数 $R_0(E)$ 包含了来自复合核所有能级（共振）的贡献。在非常低的能量下，远离任何特定的共振时，其值主要由许多远处能级的集体效应所决定。这个贡献通常表示为一个近似恒定的背景项 $R_0^\\infty$。\n\n低能散射行为可以用一个有效势散射半径 $R'$ 来表征。该参数由相移的低能极限定义：\n$$\n\\lim_{k \\to 0} \\frac{\\delta_0}{k} = -R'\n$$\n这等价于零能量时的散射截面为 $\\sigma(E \\to 0) = 4\\pi (R')^2$。\n\n一个理论模型将背景R矩阵参数 $R_0^\\infty$ 与无量纲的s波中子强度函数 $S_0$ 联系起来。假设此关系由下式给出：\n$$\nR_0^\\infty = -\\zeta S_0\n$$\n其中 $\\zeta$ 是一个给定的、数量级为1的正无量纲常数。\n\n利用这些信息，推导有效势散射半径 $R'$ 关于通道半径 $a$、强度函数 $S_0$ 和常数 $\\zeta$ 的表达式。", "solution": "我们从s波散射的R矩阵关系式开始，\n$$\n\\cot(\\delta_0 + k a)\\;=\\;\\frac{1}{k\\,a\\,R_0(E)}\\,.\n$$\n在极低能量下，$k\\to0$，相移通过以下方式定义有效半径 $R'$\n$$\n\\delta_0\\;\\approx\\;-\\,k\\,R'\\,,\n\\quad\\Longrightarrow\\quad\n\\delta_0 + k a \\;=\\;k\\bigl(a - R'\\bigr)\\,.\n$$\n与此同时，背景R矩阵参数趋于常数\n$$\nR_0(E)\\;\\to\\;R_0^\\infty\\;=\\;-\\,\\zeta\\,S_0\\,.\n$$\n对于小宗量 $x=k(a-R')$，使用展开式\n$$\n\\cot x \\approx \\frac{1}{x}\\quad(|x|\\ll1)\\,,\n$$\n所以\n$$\n\\cot(\\delta_0 + ka)\n=\\cot\\bigl(k(a-R')\\bigr)\n\\approx \\frac{1}{k\\,(a-R')}\\,.\n$$\n将其与R矩阵形式相等，\n$$\n\\frac{1}{k\\,(a-R')}\n\\;=\\;\\frac{1}{k\\,a\\,R_0^\\infty}\n\\;\\Longrightarrow\\;\n\\frac{1}{a-R'}=\\frac{1}{a\\,R_0^\\infty}\n\\;\\Longrightarrow\\;\na-R'=a\\,R_0^\\infty\\,.\n$$\n因此\n$$\nR'=a - a\\,R_0^\\infty\n=a\\bigl(1 - R_0^\\infty\\bigr)\n=a\\bigl[1 - (-\\zeta S_0)\\bigr]\n=a\\,(1 + \\zeta S_0)\\,.\n$$", "answer": "$$\\boxed{a\\,(1 + \\zeta S_0)}$$", "id": "421971"}, {"introduction": "R矩阵理论的强大之处在于其灵活性，但这需要我们理解哪些是物理实体，哪些是模型构建中的人为参数。本练习深入探讨了物理可观测量的不变性原理，这是一个核心概念。你将处理一个情景：当改变非物理的通道半径 $a$ 时，必须如何相应地调整R矩阵的遥远能级参数 $R^\\infty$，以确保物理散射长度 $a_s$ 保持不变 [@problem_id:421956]。这个练习对于培养在不同模型参数选择下获得一致物理结果的能力至关重要。", "problem": "在维格纳-艾森巴德 (Wigner-Eisenbud) R矩阵核反应理论中，物理可观测量与已定义通道半径 $a$ 内的复合核性质相关联。对于单通道中的低能s波 ($l=0$) 中子散射，散射相移 $\\delta_0$ 与能量依赖的R矩阵 $R_0(E)$ 有关。在动能趋于零 ($E \\to 0$) 的极限下，此关系可用于定义s波散射长度 $a_s$，这是一个关键的物理可观测量。该关系由下式给出：\n$$a_s = a(1 - R_0(0))$$\n其中 $R_0(0)$ 是在零能量下计算的R矩阵。\n\n在许多实际应用中，R矩阵通过对几个邻近共振能级求和，并加上一个背景项 $R^\\infty$ 来近似，以计及所有远能级的集体效应。在没有显著低能共振的情况下，R矩阵可以仅用此背景项来近似，即 $R_0(0) \\approx R^\\infty$。\n\n通道半径 $a$ 在某种程度上是模型的一个任意参数。然而，物理散射长度 $a_s$ 必须独立于 $a$ 的选择。这意味着，如果我们改变通道半径，R矩阵模型的参数必须进行调整，以保持物理可观测量不变。\n\n假设通道半径从 $a$ 变为 $a+\\delta a$，变化量很小。为确保散射长度 $a_s$ 保持不变，远能级参数 $R^\\infty$ 必须相应地调整一个量 $\\delta R^\\infty$。假设 $\\delta a$ 是无穷小量，请根据初始参数 $a$、$R^\\infty$ 和变化量 $\\delta a$，求出所需变化量 $\\delta R^\\infty$ 的表达式。", "solution": "问题要求我们找出在通道半径发生微小变化 $\\delta a$ 时，为保持s波散射长度 $a_s$ 不变所需的 $\\delta R^\\infty$ 变化量。\n\n1.  **陈述不变性原理和控制方程。**\n    物理s波散射长度 $a_s$ 必须独立于非物理量通道半径 $a$ 的选择。在给定模型中，这些量之间的关系是：\n    $$a_s = a(1 - R^\\infty)$$\n    这里我们使用了近似 $R_0(0) \\approx R^\\infty$。\n\n2.  **引入微扰。**\n    我们考虑通道半径从其初始值 $a$ 变为新值 $a' = a + \\delta a$。为保持 $a_s$ 的不变性，远能级参数 $R^\\infty$ 必须从其初始值变为新值 $R'^\\infty = R^\\infty + \\delta R^\\infty$。\n\n3.  **建立不变性条件。**\n    用新参数计算的散射长度必须等于原始散射长度。设原始散射长度为 $a_s$，新散射长度为 $a_s'$。条件是 $a_s' = a_s$。\n    对初始和最终状态使用控制方程，我们得到：\n    $$a'(1 - R'^\\infty) = a(1 - R^\\infty)$$\n    代入 $a'$ 和 $R'^\\infty$ 的表达式：\n    $$(a + \\delta a)(1 - (R^\\infty + \\delta R^\\infty)) = a(1 - R^\\infty)$$\n\n4.  **展开方程。**\n    我们展开方程的左侧：\n    $$(a + \\delta a)(1 - R^\\infty - \\delta R^\\infty) = a(1 - R^\\infty - \\delta R^\\infty) + \\delta a(1 - R^\\infty - \\delta R^\\infty)$$\n    $$= a - a R^\\infty - a \\delta R^\\infty + \\delta a - \\delta a R^\\infty - \\delta a \\delta R^\\infty$$\n\n5.  **应用一阶近似。**\n    问题指明变化量 $\\delta a$ 是无穷小。因此，引起的变化量 $\\delta R^\\infty$ 也将是无穷小。两个无穷小量之积 $\\delta a \\delta R^\\infty$ 是二阶小量，在一阶分析中可以忽略。\n    展开后的方程变为：\n    $$a(1 - R^\\infty) - a \\delta R^\\infty + \\delta a (1 - R^\\infty) \\approx a(1 - R^\\infty)$$\n\n6.  **求解变化量 $\\delta R^\\infty$。**\n    我们可以从近似式两边消去项 $a(1 - R^\\infty)$：\n    $$-a \\delta R^\\infty + \\delta a (1 - R^\\infty) \\approx 0$$\n    整理各项以求解 $\\delta R^\\infty$：\n    $$a \\delta R^\\infty \\approx \\delta a (1 - R^\\infty)$$\n    最后，两边同除以 $a$（假设 $a \\neq 0$），我们得到远能级参数所需变化量的表达式：\n    $$\\delta R^\\infty = \\frac{1 - R^\\infty}{a} \\delta a$$\n    该表达式表示当通道半径发生无穷小变化时，为保持物理散射长度不变而对 $R^\\infty$ 所需的一阶修正。", "answer": "$$ \\boxed{\\frac{(1 - R^\\infty) \\delta a}{a}} $$", "id": "421956"}, {"introduction": "在实际的R矩阵分析中，尤其是在处理大量能级时，计算效率和数值稳定性是首要问题。本高级练习将引导你从理论推导走向计算实践，解决R矩阵计算中的一个核心挑战：能级矩阵的求逆。你将利用耦合项的低秩结构，推导并实现一种基于 Woodbury 矩阵恒等式的高效更新算法，从而在多能级、少通道的情况下，极大地加速R矩阵和碰撞矩阵的计算 [@problem_id:3585560]。这项实践对于理解和开发专业的R矩阵代码，以及处理大规模核数据评估具有直接的应用价值。", "problem": "考虑一个多能级、少通道的核反应R矩阵理论的表述，其中能级矩阵依赖于能量 $E$ 和耦合矢量。在Wigner–Eisenbud形式论中，若选择的通道边界条件使得边界常数等于移动函数，则能级矩阵可以写为\n$$\nA(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T},\n$$\n其中，$D(E)$ 是一个大小为 $N \\times N$ 的对角矩阵，其对角元对于每个能级指标 $\\lambda = 1,\\dots,N$ 为 $d_\\lambda(E) = E_\\lambda - E$；$U$ 是一个 $N \\times C$ 的矩阵，其列是对应于通道指标 $c = 1,\\dots,C$ 的能级-通道约化宽度振幅矢量 $\\gamma_c$；$W(E)$ 是一个 $C \\times C$ 的对角矩阵，其对角元为 $w_c(E) = i\\,P_c(E)$，其中 $i$ 是虚数单位，$P_c(E)$ 是通道 $c$ 在能量 $E$ 处的穿透因子。这种结构反映了耦合项的低秩性质，因为即使在 $N \\gg C$ 的情况下，$U\\,W(E)\\,U^{\\mathsf T}$ 的秩最多为 $C$。\n\n对于单通道中性s波情况，穿透因子可以建模为 $P(E) = k(E)\\,a$，其中 $k(E) = \\sqrt{2\\,\\mu\\,E}/\\hbar$ 是波数，$\\mu$ 是约化质量，$a$ 是通道半径，$\\hbar$ 是约化普朗克常数。使用计算核物理的常规单位，取 $\\hbar c = 197.3269804$ MeV·fm，这样 $k(E)$ 可以由以兆电子伏特 (MeV) 为单位的 $E$、以 MeV$/c^2$ 为单位的 $\\mu$ 和以飞米 (fm) 为单位的 $a$ 计算得出，从而得到一个无量纲的穿透因子 $P(E)$。对于多通道情况，为每个通道定义一个独特的 $P_c(E) = k_c(E)\\,a_c$，并对应相应的 $\\mu_c$ 和 $a_c$。\n\n通道-通道R矩阵定义为\n$$\nR(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U,\n$$\n这是一个 $C \\times C$ 的复对称矩阵。当边界常数等于移动函数（因此实色散位移被吸收）时，碰撞矩阵（也称为散射矩阵）简化为\n$$\nU(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\n其中 $I_C$ 是 $C \\times C$ 的单位矩阵，$P(E)^{1/2}$ 是对角元为 $\\sqrt{P_c(E)}$ 的对角矩阵。在理想的数学模型中，这个 $U(E)$ 是幺正的。\n\n你的任务是设计并实现一个程序，对于一组指定的能级能量 $E_\\lambda$、在 $U$ 中的约化宽度振幅以及通道参数 $(\\mu_c, a_c)$，使用两种对 $A(E)$ 的求逆策略计算多个能量点上的 $U(E)$：\n- 对 $A(E)$ 进行直接稠密求逆。\n- 一种求逆更新方法，该方法利用 $U\\,W(E)\\,U^{\\mathsf T}$ 的低秩结构，从 $D(E)$ 出发，并应用一个有原则的矩阵恒等式来避免对整个 $N \\times N$ 矩阵求逆。\n\n你必须：\n1. 从基础的线性代数和R矩阵定义出发，推导、实现并使用在数学上保证对对角矩阵进行低秩修正的高效求逆更新方法，而不依赖任何预先给出的简化公式。\n2. 对每个能量，使用两种求逆方法计算碰撞矩阵 $U(E)$，并将数值误差量化为两种 $U(E)$ 矩阵之间逐元素绝对差的最大值。\n3. 将每个测试案例的误差聚合为在指定能量集上的最大值。\n4. 所有能量以兆电子伏特 (MeV) 表示，质量以兆电子伏特每光速平方 (MeV$/c^2$) 表示，半径以飞米 (fm) 表示，并以无量纲浮点数报告最终误差。\n5. 确保数值稳定性，避免使用使 $D(E)$ 的任何对角元恰好为零的能量。\n\n测试套件和参数：\n- 案例1（单通道，离共振区和近共振区，中性s波）：\n  - 能级：$N=3$，能量为 $E_\\lambda = [0.2,\\,1.0,\\,3.0]$ MeV。\n  - 约化质量：$\\mu = 469.5$ MeV$/c^2$。\n  - 通道半径：$a = 5.0$ fm。\n  - 约化宽度振幅：$\\gamma = [0.06,\\,0.02,\\,0.01]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [0.05,\\,0.1999,\\,0.5,\\,1.0]$ MeV。\n- 案例2（单通道，近阈值）：\n  - 能级：$N=5$，能量为 $E_\\lambda = [0.01,\\,0.5,\\,1.5,\\,2.5,\\,4.0]$ MeV。\n  - 约化质量：$\\mu = 469.5$ MeV$/c^2$。\n  - 通道半径：$a = 5.0$ fm。\n  - 约化宽度振幅：$\\gamma = [0.03,\\,0.015,\\,0.008,\\,0.004,\\,0.002]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [10^{-6},\\,10^{-4},\\,10^{-2}]$ MeV。\n- 案例3（双通道，多能级）：\n  - 能级：$N=4$，能量为 $E_\\lambda = [0.4,\\,0.8,\\,1.6,\\,2.8]$ MeV。\n  - 通道1：$\\mu_1 = 469.5$ MeV$/c^2$，$a_1 = 4.5$ fm，约化宽度振幅 $\\gamma_1 = [0.05,\\,0.02,\\,0.03,\\,0.01]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 通道2：$\\mu_2 = 300.0$ MeV$/c^2$，$a_2 = 6.0$ fm，约化宽度振幅 $\\gamma_2 = [0.04,\\,0.015,\\,0.02,\\,0.008]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [0.3,\\,0.8,\\,1.6,\\,2.5]$ MeV。\n- 案例4（单通道，近共振区的病态情况）：\n  - 能级：$N=3$，能量为 $E_\\lambda = [1.0000,\\,1.5000,\\,2.0000]$ MeV。\n  - 约化质量：$\\mu = 469.5$ MeV$/c^2$。\n  - 通道半径：$a = 5.0$ fm。\n  - 约化宽度振幅：$\\gamma = [0.10,\\,0.05,\\,0.02]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [0.9999,\\,1.0001,\\,1.2]$ MeV。\n\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_j$ 是第 $j$ 个案例中，两种计算出的碰撞矩阵 $U(E)$ 在所有能量点上的最大逐元素绝对差，以无量纲浮点数报告。", "solution": "该问题要求使用两种不同的计算策略来计算核碰撞矩阵，记为 $U(E)$，这两种策略用于对能级矩阵 $A(E)$ 求逆。我们将比较这两种方法（直接求逆和高效的低秩更新）的结果，以量化数值误差。其理论基础是核反应的R矩阵理论。\n\n### 理论框架\n\n该问题背景是R矩阵理论的Wigner–Eisenbud形式论。关键物理量定义如下：\n\n1.  **能级矩阵, $A(E)$**: 一个 $N \\times N$ 的复矩阵，其中 $N$ 是所包含的共振能级数。\n    $$A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$$\n    -   $D(E)$ 是一个对角矩阵，其对角元为 $d_\\lambda(E) = E_\\lambda - E$，其中 $E_\\lambda$ 是能级能量，$E$ 是散射能量。\n    -   $U$ 是一个 $N \\times C$ 的实矩阵，其列是对应于 $C$ 个反应通道中每一个的约化宽度振幅矢量 $\\gamma_c$。元素 $U_{\\lambda c}$ 对应振幅 $\\gamma_{\\lambda c}$。\n    -   $W(E)$ 是一个 $C \\times C$ 的对角矩阵，其对角元为 $w_c(E) = i\\,P_c(E)$，其中 $i$ 是虚数单位，$P_c(E)$ 是通道 $c$ 的穿透因子。\n\n2.  **穿透因子, $P_c(E)$**: 对于一个处于 $s$ 波（$l=0$）通道的中性粒子，其穿透因子由 $P_c(E) = k_c(E)\\,a_c$ 给出。\n    -   $k_c(E)$ 是波数，$k_c(E) = \\sqrt{2\\mu_c E}/\\hbar$。使用给定的常数 $\\hbar c = 197.3269804 \\text{ MeV}\\cdot\\text{fm}$，并将约化质量 $\\mu_c$ 以 $\\text{MeV}/c^2$ 表示，能量 $E$ 以 MeV 表示，则波数的单位为 $\\text{fm}^{-1}$：\n        $$k_c(E) = \\frac{\\sqrt{2(\\mu_c c^2)E}}{\\hbar c}$$\n    -   $a_c$ 是以 fm 为单位的通道半径，这使得 $P_c(E)$ 成为一个无量纲的量。\n\n3.  **R矩阵, $R(E)$**: 一个 $C \\times C$ 的复对称矩阵，它将内部区域边界上的波函数值与其导数联系起来。它通过能级矩阵的逆来计算：\n    $$R(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$$\n\n4.  **碰撞矩阵, $U(E)$**: 一个 $C \\times C$ 的幺正矩阵，其元素 $U_{cc'}(E)$ 关联了入射波和出射波的振幅。在指定的边界条件下，它由以下公式给出：\n    $$U(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2}$$\n    -   $I_C$ 是 $C \\times C$ 的单位矩阵。\n    -   $P(E)^{1/2}$ 是对角元为 $\\sqrt{P_c(E)}$ 的对角矩阵。由于 $E > 0$ 和 $\\mu_c > 0$，$P_c(E)$ 是实数且非负，所以其平方根是明确定义的实数。\n\n### $A(E)^{-1}$ 的计算方法\n\n核心任务是计算 $R(E)$，这需要 $A(E)$ 的逆。我们将实现两种方法。\n\n**方法1：直接稠密求逆**\n\n这是最直接的方法。对于给定的能量 $E$：\n1.  构造 $N \\times N$ 的对角矩阵 $D(E)$。\n2.  构造 $N \\times C$ 的矩阵 $U$ 和 $C \\times C$ 的对角矩阵 $W(E)$。\n3.  计算完整的 $N \\times N$ 矩阵 $A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$。\n4.  使用标准的数值线性代数程序对 $A(E)$ 求逆，得到 $A(E)^{-1}$。\n5.  计算R矩阵：$R_{\\text{direct}}(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$。\n\n对于大的 $N$，这种方法的计算成本很高，矩阵求逆步骤的复杂度通常为 $\\mathcal{O}(N^3)$。如果 $A(E)$ 是病态的（这可能在共振能量 $E_\\lambda$ 附近发生），它也可能遭受数值不稳定的影响。\n\n**方法2：低秩更新求逆**\n\n该方法利用了这样一个事实：$U\\,W(E)\\,U^{\\mathsf T}$ 项是对简单对角矩阵 $D(E)$ 的一个低秩更新。更新的秩最多为 $C$（通道数），而 $C$ 通常远小于 $N$。我们可以推导出一种更高效的 $R(E)$ 表达式，而无需显式地构造或求逆完整的 $N \\times N$ 矩阵 $A(E)$。推导过程如下，从 $R(E)$ 的定义和 $A(E)$ 的逆开始：\n\n令 $x$ 是一个 $N \\times C$ 的矩阵，定义为 $x = A(E)^{-1}U$。根据定义，R矩阵为 $R(E) = U^{\\mathsf T}x$。\n我们可以通过乘以 $A(E)$ 来写出 $x$ 的方程：\n$$A(E)x = U$$\n代入 $A(E)$ 的表达式：\n$$(D(E) + U\\,W(E)\\,U^{\\mathsf T})x = U$$\n展开左侧：\n$$D(E)x + U\\,W(E)\\,(U^{\\mathsf T}x) = U$$\n注意到括号中的项 $U^{\\mathsf T}x$ 就是R矩阵 $R(E)$：\n$$D(E)x + U\\,W(E)\\,R(E) = U$$\n由于 $D(E)$ 是对角矩阵，其逆 $D(E)^{-1}$ 也是一个对角矩阵，对角元为 $1/(E_\\lambda - E)$，只要对所有 $\\lambda$ 都有 $E \\neq E_\\lambda$，计算就非常简单。我们可以解出 $x$：\n$$D(E)x = U - U\\,W(E)\\,R(E) = U(I_C - W(E)\\,R(E))$$\n$$x = D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))$$\n现在，将这个 $x$ 的表达式代回R矩阵的定义 $R(E) = U^{\\mathsf T}x$：\n$$R(E) = U^{\\mathsf T}\\,[D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))]$$\n$$R(E) = (U^{\\mathsf T}D(E)^{-1}U)\\,(I_C - W(E)\\,R(E))$$\n我们定义 $C \\times C$ 矩阵 $Z(E) = U^{\\mathsf T}D(E)^{-1}U$。这个矩阵是高效方法的核心。其元素由 $Z_{cd}(E) = \\sum_{\\lambda=1}^N \\frac{\\gamma_{\\lambda c} \\gamma_{\\lambda d}}{E_\\lambda - E}$ 给出。方程变为：\n$$R(E) = Z(E)\\,(I_C - W(E)\\,R(E)) = Z(E) - Z(E)\\,W(E)\\,R(E)$$\n我们现在可以用代数方法解出 $R(E)$：\n$$R(E) + Z(E)\\,W(E)\\,R(E) = Z(E)$$\n$$(I_C + Z(E)\\,W(E))\\,R(E) = Z(E)$$\n最后，假如矩阵 $(I_C + Z(E)W(E))$ 是可逆的，我们得到R矩阵的表达式：\n$$R_{\\text{update}}(E) = (I_C + Z(E)\\,W(E))^{-1} \\, Z(E)$$\n这个推导满足了从第一性原理出发的要求。其计算优势是显著的：最昂贵的步骤是求一个 $C \\times C$ 矩阵的逆，其复杂度为 $\\mathcal{O}(C^3)$。由于在许多实际应用中 $C \\ll N$，这远比直接方法的 $\\mathcal{O}(N^3)$ 复杂度高效。\n\n### 实现与误差分析\n\n用于比较的算法如下。对于每个测试案例：\n1.  初始化该案例的最大误差 $\\epsilon_{\\text{max}} = 0$。\n2.  遍历每个指定的散射能量 $E$。\n3.  在每个 $E$ 点，使用直接求逆方法计算碰撞矩阵 $U_{\\text{direct}}(E)$。\n4.  在同一个 $E$ 点，使用低秩更新方法计算 $U_{\\text{update}}(E)$。\n5.  计算逐元素绝对差矩阵 $\\Delta U(E) = |U_{\\text{direct}}(E) - U_{\\text{update}}(E)|$。\n6.  找到该差分矩阵中的最大项 $\\epsilon(E) = \\max_{ij} \\Delta U_{ij}(E)$。\n7.  更新案例最大误差：$\\epsilon_{\\text{max}} = \\max(\\epsilon_{\\text{max}}, \\epsilon(E))$。\n8.  遍历完所有能量后，该测试案例的最终结果是 $\\epsilon_{\\text{max}}$。\n\n此过程将对所有四个测试案例执行，并报告产生的最大误差。这种比较既可以验证推导出的低秩更新公式，也可以突显两种数学上等价的路径之间潜在的数值精度差异。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the R-matrix problem for four test cases, comparing direct and \n    low-rank update inversion methods for the collision matrix.\n    \"\"\"\n    HBAR_C = 197.3269804  # MeV·fm\n\n    def get_P_matrices(E, mu_vec, a_vec):\n        \"\"\"Calculates the diagonal P(E) and P(E)^(1/2) matrices.\"\"\"\n        C = len(mu_vec)\n        p_diag = np.zeros(C, dtype=np.float64)\n        for c in range(C):\n            # E can be zero or very close to it, sqrt will be handled correctly.\n            # The calculation is valid for E >= 0.\n            if E >= 0:\n                k_c = np.sqrt(2 * mu_vec[c] * E) / HBAR_C\n                p_diag[c] = k_c * a_vec[c]\n        \n        P_matrix = np.diag(p_diag)\n        P_sqrt_matrix = np.diag(np.sqrt(p_diag))\n        return P_matrix, P_sqrt_matrix\n\n    def calculate_U_direct(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using direct inversion.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n        \n        # Diagonal matrix D(E)\n        d_diag = E_levels - E\n        D_matrix = np.diag(d_diag)\n\n        # Diagonal matrix W(E)\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # Level matrix A(E)\n        A_matrix = D_matrix.astype(np.complex128) + U_mat @ W_matrix @ U_mat.T\n        \n        # R-matrix R(E)\n        try:\n            A_inv = np.linalg.inv(A_matrix)\n        except np.linalg.LinAlgError:\n            # This should not happen with the given test cases, but is good practice.\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = U_mat.T @ A_inv @ U_mat\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    def calculate_U_update(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using the low-rank update method.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n\n        # Inverse of D(E)\n        d_inv_diag = 1.0 / (E_levels - E)\n        D_inv_matrix = np.diag(d_inv_diag)\n        \n        # Z(E) matrix\n        Z_matrix = U_mat.T @ D_inv_matrix.astype(np.complex128) @ U_mat\n        \n        # W(E) matrix and P_sqrt\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # R-matrix R(E) using the derived formula\n        M_matrix = I_C + Z_matrix @ W_matrix\n        \n        try:\n            M_inv = np.linalg.inv(M_matrix)\n        except np.linalg.LinAlgError:\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = M_inv @ Z_matrix\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        { # Case 1\n            \"E_levels\": np.array([0.2, 1.0, 3.0]),\n            \"U_mat\": np.array([[0.06], [0.02], [0.01]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.05, 0.1999, 0.5, 1.0])\n        },\n        { # Case 2\n            \"E_levels\": np.array([0.01, 0.5, 1.5, 2.5, 4.0]),\n            \"U_mat\": np.array([[0.03], [0.015], [0.008], [0.004], [0.002]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([1e-6, 1e-4, 1e-2])\n        },\n        { # Case 3\n            \"E_levels\": np.array([0.4, 0.8, 1.6, 2.8]),\n            \"U_mat\": np.array([\n                [0.05, 0.04], [0.02, 0.015], [0.03, 0.02], [0.01, 0.008]\n            ]),\n            \"mu_vec\": np.array([469.5, 300.0]),\n            \"a_vec\": np.array([4.5, 6.0]),\n            \"energies\": np.array([0.3, 0.8, 1.6, 2.5])\n        },\n        { # Case 4\n            \"E_levels\": np.array([1.0, 1.5, 2.0]),\n            \"U_mat\": np.array([[0.10], [0.05], [0.02]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.9999, 1.0001, 1.2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_case_error = 0.0\n        for E in case[\"energies\"]:\n            U_direct = calculate_U_direct(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n            U_update = calculate_U_update(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n\n            # Quantify numerical error\n            error_E = np.max(np.abs(U_direct - U_update))\n            if error_E > max_case_error:\n                max_case_error = error_E\n        \n        results.append(max_case_error)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3585560"}]}