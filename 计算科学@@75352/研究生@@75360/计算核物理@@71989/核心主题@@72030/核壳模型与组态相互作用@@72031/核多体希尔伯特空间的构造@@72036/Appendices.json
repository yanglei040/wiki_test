{"hands_on_practices": [{"introduction": "在认识到希尔伯特空间的巨大规模后，一个实际问题随之而来：我们如何在计算机中高效地存储和访问这些状态？这个练习将指导你设计一个核心算法，它能将每个唯一的斯莱特行列式（以比特串形式表示）映射到一个唯一的整数索引。这个过程，也称为排序（ranking），是构建哈密顿量矩阵和执行任何大规模壳模型计算的计算基础 [@problem_id:3575545]。", "problem": "您正在为一个核壳模型多体基矢建模，其中的多体希尔伯特空间由占据固定单粒子轨道的质子和中子的Slater行列式构建。每个Slater行列式由两个占据位串表示：一个用于质子，一个用于中子。根据Fermi-Dirac反对称性，每个单粒子轨道可以未被占据或被占据，因此一个占据位串是一个长度等于单粒子轨道数的比特序列，其中1的个数恰好等于该类粒子的数量。\n\n形式上，假设质子空间有 $\\Omega_p$ 个单粒子轨道，中子空间有 $\\Omega_n$ 个单粒子轨道。令 $Z$ 为质子数，$N$ 为中子数，其中 $0 \\le Z \\le \\Omega_p$ 且 $0 \\le N \\le \\Omega_n$。一个质子基矢态是一个占据位串 $b^p \\in \\{0,1\\}^{\\Omega_p}$，其恰好有 $Z$ 个1；一个中子基矢态是 $b^n \\in \\{0,1\\}^{\\Omega_n}$，其恰好有 $N$ 个1。一个完整的多体基矢态是有序对 $(b^p,b^n)$。\n\n定义位串上的字典序，方法是从最左边的比特读到最右边的比特，并在它们第一个不同的位置进行比较，规定 $0  1$。定义序对 $(b^p,b^n)$ 上的字典序：首先按字典序比较质子位串 $b^p$，如果它们相等，再按字典序比较中子位串 $b^n$。\n\n您的任务是设计并实现一个从序对 $(b^p,b^n)$ 到连续整数索引的双射映射，该映射需保留这种字典序，并能为哈密顿量应用实现快速查找。该映射必须满足以下所有条件：\n\n- 它将每个有效的序对 $(b^p,b^n)$ 映射到 $\\{0,1,2,\\dots,D-1\\}$ 中的唯一整数索引，其中 $D$ 是给定 $\\Omega_p$、$\\Omega_n$、$Z$ 和 $N$ 的基矢态总数。\n- 它保留 $(b^p,b^n)$ 上的字典序：如果在字典序中 $(b^p_1,b^n_1)$ 在 $(b^p_2,b^n_2)$ 之前，那么 $(b^p_1,b^n_1)$ 的映射索引严格小于 $(b^p_2,b^n_2)$ 的映射索引。\n- 它提供从索引到 $(b^p,b^n)$ 的逆映射。\n- 它能够为哈密顿量应用实现快速查找，这意味着计算单个态的索引或逆索引的时间随位串长度线性扩展，即 $\\mathcal{O}(\\Omega_p + \\Omega_n)$，并且仅使用整数算术和预计算的常数。\n\n您可以使用的基本事实包括：费米子占据数为 $0$ 或 $1$，长度为 $\\Omega$ 且恰好有 $K$ 个1的不同占据构型的数量由二项式系数 $\\binom{\\Omega}{K}$ 给出，并且字典序可以通过计算前缀来表征。\n\n您必须编写一个完整的、可运行的程序，实现此映射及其逆映射，然后评估以下测试套件。所有位串都以显式的比特列表形式给出，列表最左边的元素对应于最左边的比特。每个测试所需的输出是一个布尔值，指示所述条件是否成立。此问题不涉及任何物理单位或角度。\n\n测试套件：\n\n- 测试 $1$ (正常路径，字典序保持性)：$\\Omega_p = 6$, $Z = 3$, $\\Omega_n = 5$, $N = 2$。令 $A^p = [0,0,1,1,1,0]$, $A^n = [0,1,0,1,0]$, $B^p = [0,1,0,1,1,0]$, $B^n = [0,0,1,1,0]$。计算 $(A^p,A^n)$ 和 $(B^p,B^n)$ 的索引。当且仅当 $(A^p,A^n)$ 的索引严格小于 $(B^p,B^n)$ 的索引时，输出true。\n\n- 测试 $2$ (往返双射)：$\\Omega_p = 6$, $Z = 3$, $\\Omega_n = 5$, $N = 2$。令 $C^p = [1,0,1,0,1,0]$, $C^n = [0,1,1,0,0]$。将 $(C^p,C^n)$ 映射到一个索引，然后将该索引映射回一个序对。当且仅当恢复的序对等于原始序对时，输出true。\n\n- 测试 $3$ (零粒子边界情况)：$\\Omega_p = 4$, $Z = 0$, $\\Omega_n = 3$, $N = 0$。令 $Z^p = [0,0,0,0]$, $Z^n = [0,0,0]$。将 $(Z^p,Z^n)$ 映射到一个索引。当且仅当该索引等于 $0$ 时，输出true。\n\n- 测试 $4$ (全占据边界情况)：$\\Omega_p = 5$, $Z = 5$, $\\Omega_n = 4$, $N = 4$。令 $F^p = [1,1,1,1,1]$, $F^n = [1,1,1,1]$。令 $D$ 为这些参数下的基矢态总数。将 $(F^p,F^n)$ 映射到一个索引。当且仅当该索引等于 $D - 1$ 时，输出true。\n\n- 测试 $5$ (哈密顿量应用下单体移动的快速查找)：$\\Omega_p = 6$, $Z = 3$, $\\Omega_n = 5$, $N = 2$。令 $D^p = [0,1,0,1,0,1]$, $D^n = [1,0,0,1,0]$。应用一个质子单体移动，将位置 $i=1$ 处的已占据轨道移动到位置 $j=2$ 处的未占据轨道，生成 $D^{p'} = [0,0,1,1,0,1]$，同时保持 $D^n$ 不变。使用您的映射计算 $(D^p,D^n)$ 和 $(D^{p'},D^n)$ 的索引。同时，构建一个从位串的整数打包表示到索引的哈希映射，并用它来检索 $(D^{p'},D^n)$ 的索引。当且仅当两种方法对 $(D^{p'},D^n)$ 产生的索引相同时，输出true。\n\n- 测试 $6$ (固定质子构型内的相邻中子构型)：$\\Omega_p = 5$, $Z = 2$, $\\Omega_n = 5$, $N = 3$。令质子构型固定为 $P^p = [0,1,0,0,1]$。令 $A^n = [0,0,1,1,1]$ 和 $B^n = [0,1,0,1,1]$。计算 $(P^p,A^n)$ 和 $(P^p,B^n)$ 的索引。当且仅当 $(P^p,B^n)$ 的索引等于 $(P^p,A^n)$ 的索引加 $1$ 时，输出true。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true1,true2,true3,true4,true5,true6]”）。所有布尔值必须使用编程语言的原生布尔字面量打印。", "solution": "用户提供的问题陈述已经过分析，并被确定为**有效**。它在科学上是合理的、良定的、客观的，提出了一个计算多体物理学中的标准问题。任务是创建一个从核壳模型态的基矢到连续整数集合的双射、保序映射，及其逆映射。\n\n### 基于原则的设计\n\n问题的核心是为保留字典序的组合构建一个映射，通常称为“排序”（ranking）函数。多体基矢态是有序对 $(b^p, b^n)$，它们总的字典序排序暗示了一种行主序索引方案。总索引可以表示为质子和中子位串各自索引的函数。\n\n#### 1. 将单个位串映射到索引（排序）\n\n首先，我们考虑单个核素的映射，例如，将一个长度为 $\\Omega_p$、有 $Z$ 个1的质子位串 $b^p$ 映射到一个整数索引。这类不同位串的总数是 $D_p = \\binom{\\Omega_p}{Z}$。目标是找到一个双射且保留字典序的函数 $\\mathcal{M}_{\\text{lex}}(b^p) \\to \\{0, 1, \\dots, D_p-1\\}$。\n\n位串 $b$ 的字典序索引恰好是字典序上小于 $b$ 的有效位串的数量。我们可以通过从左到右迭代位串来确定这个数量。\n\n设位串为 $b = (b_0, b_1, \\dots, b_{\\Omega-1})$，长度为 $\\Omega$，有 $K$ 个1。排序值（rank）是通过将在每个位置“跳过”的组合数量相加来构建的。组合数由二项式系数 $\\binom{n}{k}$ 给出，为了效率，我们可以预先计算并将其存储在查找表中。\n\n映射算法如下：\n初始化排序值为 $0$，待放置的1的数量为 $k=K$，可用位置数为 $\\omega=\\Omega$。从左到右迭代（位置 $i=0$ 到 $\\Omega-1$）：\n1. 可用位置数减一，$\\omega \\leftarrow \\omega - 1$。\n2. 检查比特 $b_i$。\n   - 如果 $b_i=0$：该字符串属于以当前前缀加一个0开头的组合块。这些都比在当前位置以1开头的组合的字典序小。我们不增加排序值，继续处理下一个比特。待放置的1的数量 $k$ 保持不变。\n   - 如果 $b_i=1$：该字符串的字典序大于所有在位置 $i$ 处为0（给定相同前缀）的有效组合。必须将这些较小编号的组合数量加到我们的排序值中。如果我们在位置 $i$ 放置一个0，那么我们需要在剩下的 $\\omega$ 个位置中放置剩余的 $k$ 个1。这样做的方法数是 $\\binom{\\omega}{k}$。我们将此值加到排序值上。由于我们现在放置了一个1，我们将待放置的剩余1的数量减一，$k \\leftarrow k - 1$。\n\n此过程唯一地确定了任何给定比特串的字典序排序值。对于一个有 $K$ 个1的位串 $b = (b_i)_{i=0}^{\\Omega-1}$，其索引为：\n$$\n\\text{Index}(b) = \\sum_{i=0}^{\\Omega-1} b_i \\cdot \\binom{\\Omega-1-i}{K - \\sum_{j=0}^{i-1} b_j}\n$$\n这种迭代公式是高效的，仅依赖于整数算术和预计算的二项式系数表，从而达到了要求的 $\\mathcal{O}(\\Omega)$ 复杂度。\n\n#### 2. 将索引映射到位串（逆排序）\n\n逆映射，或称逆排序（unranking），从其字典序索引重建位串。给定一个排序值 $I \\in \\{0, 1, \\dots, \\binom{\\Omega}{K}-1\\}$，我们从左到右逐一确定字符串 $b$ 的比特。\n\n在每个位置 $i=0, \\dots, \\Omega-1$：\n1. 我们确定 $b_i$ 应该是 $0$ 还是 $1$。\n2. 考虑一个假设的比特 $b_i=0$。完成该位串的可能有效方式（即将剩余的 $k$ 个1放置在剩余的 $\\omega$ 个位置中）的数量为 $\\binom{\\omega}{k}$。\n3. 将当前排序值 $I$ 与此计数进行比较。\n   - 如果 $I  \\binom{\\omega}{k}$：目标位串位于这块组合中。因此，$b_i$ 必须为 $0$。我们设置 $b_i=0$ 并转到下一个位置。排序值 $I$ 和剩余的1的数量 $k$ 不变。\n   - 如果 $I \\ge \\binom{\\omega}{k}$：目标位串的字典序大于所有在当前位置为0的组合。因此，$b_i$ 必须为 $1$。我们设置 $b_i=1$，从排序值中减去 $\\binom{\\omega}{k}$（$I \\leftarrow I - \\binom{\\omega}{k}$），并将待放置的1的数量减一（$k \\leftarrow k-1$）。\n4. 我们对所有位置重复此过程，以构建完整的位串。这也是一个 $\\mathcal{O}(\\Omega)$ 的过程。\n\n#### 3. 组合质子与中子空间\n\n基矢态是有序对 $(b^p, b^n)$。这些序对上的字典序首先通过比较 $b^p$ 来定义，仅当它们相同时才比较 $b^n$。这对应于一个二维矩阵的行主序布局，其中行由质子态索引，列由中子态索引。\n\n令 $\\mathcal{M}_p(b^p)$ 为质子态 $b^p$ 在其大小为 $D_p = \\binom{\\Omega_p}{Z}$ 的空间中的排序值，令 $\\mathcal{M}_n(b^n)$ 为中子态 $b^n$ 在其大小为 $D_n = \\binom{\\Omega_n}{N}$ 的空间中的排序值。序对 $(b^p, b^n)$ 的总索引 $I$ 由下式给出：\n$$\nI(b^p, b^n) = \\mathcal{M}_p(b^p) \\cdot D_n + \\mathcal{M}_n(b^n)\n$$\n基矢的总维度为 $D = D_p \\cdot D_n$。\n\n从总索引 $I$ 到序对 $(b^p, b^n)$ 的逆映射使用整数除法和模运算找到：\n$$\n\\mathcal{M}_p = I \\ // \\ D_n\n$$\n$$\n\\mathcal{M}_n = I \\ \\% \\ D_n\n$$\n然后，使用上面描述的单核素逆排序算法，从它们各自的排序值 $\\mathcal{M}_p$ 和 $\\mathcal{M}_n$ 重建单个位串 $b^p$ 和 $b^n$。组合系统的前向和逆向映射的时间复杂度均为 $\\mathcal{O}(\\Omega_p + \\Omega_n)$，满足所有问题要求。", "answer": "```python\nimport numpy as np\n\nclass NuclearBasisMapper:\n    \"\"\"\n    Manages the mapping between nuclear many-body basis states (represented by\n    proton and neutron occupancy bitstrings) and unique integer indices.\n\n    The mapping preserves lexicographical order and is designed for fast\n    computation, suitable for constructing and applying Hamiltonians in\n    shell-model calculations.\n    \"\"\"\n    _C = None\n    _MAX_OMEGA = 0\n\n    def __init__(self, omega_p, z, omega_n, n):\n        \"\"\"\n        Initializes the mapper for a given nuclear system.\n\n        Args:\n            omega_p (int): Number of single-particle orbitals for protons.\n            z (int): Number of protons.\n            omega_n (int): Number of single-particle orbitals for neutrons.\n            n (int): Number of neutrons.\n        \"\"\"\n        self.omega_p = omega_p\n        self.z = z\n        self.omega_n = omega_n\n        self.n_neutrons = n\n\n        max_omega_needed = max(omega_p, omega_n, 0)\n        self._precompute_binom(max_omega_needed)\n        \n        # Guard against invalid parameters (e.g., more particles than orbitals)\n        if not (0 = self.z = self.omega_p and 0 = self.n_neutrons = self.omega_n):\n             self.dim_p = 0\n             self.dim_n = 0\n        else:\n             self.dim_p = self._C[self.omega_p, self.z]\n             self.dim_n = self._C[self.omega_n, self.n_neutrons]\n\n        self.total_dim = self.dim_p * self.dim_n\n\n    @classmethod\n    def _precompute_binom(cls, max_val):\n        \"\"\"Precomputes binomial coefficients up to max_val.\"\"\"\n        if max_val = cls._MAX_OMEGA:\n            return\n        \n        cls._MAX_OMEGA = max_val\n        c = np.zeros((max_val + 1, max_val + 1), dtype=np.int64)\n        for i in range(max_val + 1):\n            c[i, 0] = 1\n            for j in range(1, i + 1):\n                c[i, j] = c[i - 1, j - 1] + c[i - 1, j]\n        cls._C = c\n\n    def _get_rank_lex(self, b_list, omega, k):\n        \"\"\"Calculates the lexicographical rank of a single bitstring.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        rank = 0\n        rem_k = k\n        rem_omega = omega\n        for bit in b_list:\n            rem_omega -= 1\n            if rem_k == 0:\n                break\n            \n            if bit == 1:\n                # This bit is 1, so we skip all combinations where this bit is 0.\n                # The number of such combinations is the number of ways to place\n                # the remaining rem_k particles in the remaining rem_omega slots.\n                if rem_omega >= rem_k:\n                    rank += self._C[rem_omega, rem_k]\n                rem_k -= 1\n        return rank\n\n    def _get_state_from_lex_rank(self, rank, omega, k):\n        \"\"\"Reconstructs a bitstring from its lexicographical rank.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        b = []\n        rem_k = k\n        current_rank = rank\n        \n        for i in range(omega):\n            rem_omega_suffix = omega - 1 - i\n            \n            # Optimization: if all remaining must be 1s or 0s\n            if rem_k == rem_omega_suffix + 1:\n                b.extend([1] * rem_k)\n                break\n            if rem_k == 0:\n                b.extend([0] * (rem_omega_suffix + 1))\n                break\n\n            # Number of combinations if we choose 0 at this position\n            comb_with_zero = self._C[rem_omega_suffix, rem_k]\n            \n            if current_rank  comb_with_zero:\n                b.append(0)\n            else:\n                b.append(1)\n                current_rank -= comb_with_zero\n                rem_k -= 1\n        return b\n\n    def get_index(self, b_p, b_n):\n        \"\"\"Computes the total index for a given proton-neutron state pair.\"\"\"\n        idx_p = self._get_rank_lex(b_p, self.omega_p, self.z)\n        idx_n = self._get_rank_lex(b_n, self.omega_n, self.n_neutrons)\n        return idx_p * self.dim_n + idx_n\n\n    def get_state(self, total_idx):\n        \"\"\"Recovers the proton-neutron state pair from a total index.\"\"\"\n        if total_idx >= self.total_dim:\n            raise ValueError(\"Total index is out of bounds.\")\n            \n        idx_p = total_idx // self.dim_n\n        idx_n = total_idx % self.dim_n\n        \n        b_p = self._get_state_from_lex_rank(idx_p, self.omega_p, self.z)\n        b_n = self._get_state_from_lex_rank(idx_n, self.omega_n, self.n_neutrons)\n        return (b_p, b_n)\n\ndef solve():\n    \"\"\"Runs the test suite specified in the problem statement.\"\"\"\n    \n    test_cases_params = [\n        (6, 3, 5, 2),  # Test 1\n        (6, 3, 5, 2),  # Test 2\n        (4, 0, 3, 0),  # Test 3\n        (5, 5, 4, 4),  # Test 4\n        (6, 3, 5, 2),  # Test 5\n        (5, 2, 5, 3),  # Test 6\n    ]\n\n    results = []\n\n    # Test 1: Lexicographic order preservation\n    omega_p, z, omega_n, n = test_cases_params[0]\n    mapper1 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    a_p, a_n = [0,0,1,1,1,0], [0,1,0,1,0]\n    b_p, b_n = [0,1,0,1,1,0], [0,0,1,1,0]\n    idx_A = mapper1.get_index(a_p, a_n)\n    idx_B = mapper1.get_index(b_p, b_n)\n    results.append(idx_A  idx_B)\n\n    # Test 2: Round-trip bijection\n    omega_p, z, omega_n, n = test_cases_params[1]\n    mapper2 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    c_p, c_n = [1,0,1,0,1,0], [0,1,1,0,0]\n    idx_C = mapper2.get_index(c_p, c_n)\n    rec_p, rec_n = mapper2.get_state(idx_C)\n    results.append(c_p == rec_p and c_n == rec_n)\n\n    # Test 3: Boundary case with zero particles\n    omega_p, z, omega_n, n = test_cases_params[2]\n    mapper3 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    z_p, z_n = [0,0,0,0], [0,0,0]\n    idx_Z = mapper3.get_index(z_p, z_n)\n    results.append(idx_Z == 0)\n\n    # Test 4: Boundary case with full occupancy\n    omega_p, z, omega_n, n = test_cases_params[3]\n    mapper4 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    f_p, f_n = [1,1,1,1,1], [1,1,1,1]\n    idx_F = mapper4.get_index(f_p, f_n)\n    D = mapper4.total_dim\n    results.append(idx_F == D - 1)\n\n    # Test 5: Fast lookup under a one-body move\n    omega_p, z, omega_n, n = test_cases_params[4]\n    mapper5 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    d_p, d_n = [0,1,0,1,0,1], [1,0,0,1,0]\n    d_p_prime = [0,0,1,1,0,1]\n    idx1 = mapper5.get_index(d_p_prime, d_n)\n    \n    # Simulate a hash map lookup as described\n    int_p_prime = int(\"\".join(map(str, d_p_prime)), 2)\n    int_n = int(\"\".join(map(str, d_n)), 2)\n    key = (int_p_prime, int_n)\n    hash_map = {key: idx1}\n    idx2 = hash_map[key]\n    results.append(idx1 == idx2)\n\n    # Test 6: Adjacent neutron configurations\n    omega_p, z, omega_n, n = test_cases_params[5]\n    mapper6 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    p_p = [0,1,0,0,1]\n    a_n, b_n = [0,0,1,1,1], [0,1,0,1,1] # These are adjacent in lex order\n    idx_A_pair = mapper6.get_index(p_p, a_n)\n    idx_B_pair = mapper6.get_index(p_p, b_n)\n    results.append(idx_B_pair == idx_A_pair + 1)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3575545"}, {"introduction": "一个正确构建的希尔伯特空间必须遵循基本的物理原理。这个练习提供了一个经典的、可解析求解的基准问题——两个核子处于一个单$j$壳层——来检验你的希尔伯特空间构建是否正确地实现了费米子反对称性和角动量耦合规则。通过解决这个问题，你将能够验证从计算上方便的M方案基到具有明确物理意义的角动量（$J$）耦合谱的转换是否正确，这是确保代码物理可靠性的关键一步 [@problem_id:3575541]。", "problem": "一个计算多体代码为限制在总单粒子角动量 $j = 7/2$ 的单个球形轨道上的系统构建希尔伯特空间，并对一个旋转不变的双体哈密顿量进行对角化。该哈密顿量在耦合的 $(J,T)$ 表象中由约化双体矩阵元 $V^{(T)}_{J}$ 指定，其中 $J$ 是总角动量，$T$ 是总同位旋。为了基准测试反对称性、角动量耦合和选择定则，考虑两个可解的双体测试案例：\n\n- 测试案例 I：两个全同中子占据 $j = 7/2$ 壳层。\n- 测试案例 II：一个质子和一个中子占据 $j = 7/2$ 壳层，并强制要求具有良好同位旋量子数 $T$。\n\n假设仅有的非零耦合双体矩阵元为\n$V^{(1)}_{0} = -2.0\\,\\mathrm{MeV}$，$V^{(1)}_{2} = -1.0\\,\\mathrm{MeV}$，$V^{(1)}_{4} = 0.0\\,\\mathrm{MeV}$，$V^{(1)}_{6} = 0.5\\,\\mathrm{MeV}$，\n以及\n$V^{(0)}_{1} = -1.5\\,\\mathrm{MeV}$，$V^{(0)}_{3} = -0.8\\,\\mathrm{MeV}$，$V^{(0)}_{5} = 0.2\\,\\mathrm{MeV}$，$V^{(0)}_{7} = 0.7\\,\\mathrm{MeV}$，\n且所有其他 $V^{(T)}_{J}$ 均为零。你可以以下几点作为基本出发点：粒子交换下的费米子反对称性、量子力学中角动量的标准相加法则、双核子系统中同位旋 $T$ 的含义，以及一个旋转不变的双体哈密顿量在 $(J,T)$ 表象中是块对角的这一事实。\n\n哪个选项为这两个测试案例提供了正确且完整的基准规范，包括：由反对称性和同位旋所决定的允许的耦合量子数 $(J,T)$ 集合，每个允许的 $J$（以及适用时的 $T$）的期望本征能量，以及一个维度检验，该检验将 $M$ 表象基矢的大小与 $J$ 耦合谱中磁简并度之和等同起来？\n\nA) 两个中子 (测试案例 I)：允许的总角动量 $J \\in \\{0,2,4,6\\}$ 且 $T=1$；期望本征能量 $E(J) = V^{(1)}_{J}$，即 $E(0) = -2.0\\,\\mathrm{MeV}$，$E(2) = -1.0\\,\\mathrm{MeV}$，$E(4) = 0.0\\,\\mathrm{MeV}$，$E(6) = 0.5\\,\\mathrm{MeV}$。$M$ 表象维度等于 $\\binom{8}{2} = 28$，这与 $\\sum_{J \\in \\{0,2,4,6\\}} (2J+1) = 1 + 5 + 9 + 13 = 28$ 相匹配。质子-中子 (测试案例 II)：允许的 $J \\in \\{0,1,2,3,4,5,6,7\\}$，对偶数 $J$ 有 $T=1$，对奇数 $J$ 有 $T=0$；期望本征能量 $E(J,T) = V^{(T)}_{J}$，即 $E(0,1) = -2.0\\,\\mathrm{MeV}$，$E(1,0) = -1.5\\,\\mathrm{MeV}$，$E(2,1) = -1.0\\,\\mathrm{MeV}$，$E(3,0) = -0.8\\,\\mathrm{MeV}$，$E(4,1) = 0.0\\,\\mathrm{MeV}$，$E(5,0) = 0.2\\,\\mathrm{MeV}$，$E(6,1) = 0.5\\,\\mathrm{MeV}$，$E(7,0) = 0.7\\,\\mathrm{MeV}$。$M$ 表象维度等于 $8 \\times 8 = 64$，这与 $\\sum_{J=0}^{7} (2J+1) = 64$ 相匹配。\n\nB) 两个中子 (测试案例 I)：允许的总角动量 $J \\in \\{0,2,4,6,7\\}$ 且 $T=1$；期望本征能量 $E(J) = V^{(1)}_{J}$，取 $E(7) = 0.7\\,\\mathrm{MeV}$；$M$ 表象维度等于 $\\binom{9}{2} = 36$，这与 $\\sum_{J \\in \\{0,2,4,6,7\\}} (2J+1) = 43$ 相匹配。质子-中子 (测试案例 II)：允许的 $J \\in \\{0,1,2,3,4,5,6,7\\}$，对偶数 $J$ 有 $T=0$，对奇数 $J$ 有 $T=1$；对所有 $J$，期望本征能量为 $E(J) = V^{(1)}_{J}$。\n\nC) 两个中子 (测试案例 I)：反对称性禁止 $J \\ge 4$，所以只有 $J \\in \\{0,2\\}$ 且 $T=1$ 出现，能量为 $E(0) = -2.0\\,\\mathrm{MeV}$ 和 $E(2) = -1.0\\,\\mathrm{MeV}$；$M$ 表象维度等于 $\\binom{8}{2} = 28$，这与 $(2\\cdot 0 + 1) + (2\\cdot 2 + 1) = 6$ 相匹配。质子-中子 (测试案例 II)：允许的 $J \\in \\{0,1,2,3,4,5,6,7\\}$ 且 $T$ 不受限制；期望本征能量等于对所有 $J$ 的平均值 $E(J) = \\tfrac{1}{2}\\left(V^{(0)}_{J} + V^{(1)}_{J}\\right)$。\n\nD) 两个中子 (测试案例 I)：允许的总角动量 $J \\in \\{1,3,5,7\\}$ 且 $T=1$；期望本征能量 $E(J) = V^{(1)}_{J}$；$M$ 表象维度等于 $\\sum_{J \\in \\{1,3,5,7\\}} (2J+1) = 32$，这与 $\\binom{8}{2} = 28$ 相匹配，一旦 $M$ 亚能级被相互作用分裂。质子-中子 (测试案例 II)：仅允许 $J \\in \\{1,3,5,7\\}$，且 $T=0$；期望本征能量 $E(J,T) = V^{(0)}_{J}$；$M$ 表象维度等于 $8 \\times 8 = 64$，这超过了 $\\sum_{J \\in \\{1,3,5,7\\}} (2J+1) = 32$，因为同位旋多重性。\n\n选择与基本约束完全一致，并且对这些基准测试中的谱和维度检验都给出正确预期的选项。", "solution": "问题陈述要求为一个核多体计算中的两个基准案例提供一个完整的规范：两个中子在 $j=7/2$ 壳层中，以及一个质子和一个中子在同一壳层中。此规范包括允许的耦合量子数 $(J,T)$、相应的本征能量以及基矢维度的验证。分析必须基于量子力学的基本原理，包括费米子反对称性和角动量相加。\n\n问题陈述已经过验证，并被发现是科学上合理的、提法恰当的、客观的且自洽的。因此，将推导出一个解。\n\n**基本原理**\n\n对于一个处于角动量为 $j$ 的相同单粒子轨道上的双核子系统，总波函数在交换两个粒子时必须是反对称的。波函数可以被看作是空间-自旋部分（由总角动量 $J$ 表征）和同位旋部分（由总同位旋 $T$ 表征）的乘积。\n\n设 $P_{12}$ 为粒子交换算符。空间-自旋部分 $|(j^2)JM\\rangle$ 在交换下的对称性由 $(-1)^{2j-J}$ 给出。对于每个核子的 $t=1/2$ 的同位旋部分 $|(t^2)TT_z\\rangle$，其对称性为 $(-1)^{2t-T} = (-1)^{1-T}$。\n\n为了使总波函数是反对称的，我们需要：\n$$ (P_{12}^{(J,M)}) \\times (P_{12}^{(T,T_z)}) = -1 $$\n$$ (-1)^{2j-J} \\times (-1)^{1-T} = -1 $$\n这意味着指数必须是奇数：\n$$ 2j - J + 1 - T = \\text{奇数} $$\n鉴于 $j=7/2$，$2j=7$ 是一个奇数。\n$$ (\\text{奇数}) - J + 1 - T = \\text{奇数} $$\n$$ (\\text{偶数}) - J - T = \\text{奇数} $$\n这个条件简化为要求 $J+T$ 必须是奇数。这是对于处于同一 $j$ 壳层中的两个核子的广义泡利原理。\n\n给定的哈密顿量在 $(J,T)$ 基矢中是对角的，这意味着具有确定 $J$ 和 $T$ 的态是本征态。因此，一个态 $|(j^2)JT\\rangle$ 的本征能量是相应的约化双体矩阵元，$E(J,T) = V^{(T)}_{J}$。\n\n**测试案例 I：两个全同中子在 $j=7/2$ 壳层中**\n\n1.  **允许的量子数 $(J,T)$**：\n    *   系统由两个中子组成。一个中子的同位旋投影为 $t_z = -1/2$。双中子系统的总同位旋投影为 $T_z = (-1/2) + (-1/2) = -1$。\n    *   总同位旋 $T$ 必须满足 $T \\ge |T_z|$，所以 $T \\ge 1$。对于一个双核子系统，$T$ 的可能值为 0 和 1。因此，唯一可能性是 $T=1$。\n    *   应用广义泡利原理，$J+T$ 必须是奇数。由于 $T=1$，我们有 $J+1 = \\text{奇数}$，这意味着 $J$ 必须是偶数。\n    *   通过耦合两个 $j=7/2$ 粒子得到的总角动量 $J$ 的可能值为 $J \\in \\{|7/2-7/2|, \\dots, 7/2+7/2\\} = \\{0, 1, 2, 3, 4, 5, 6, 7\\}$。\n    *   只选择 $J$ 的偶数值，我们发现对于 $j=7/2$ 壳层中的双中子系统，允许的总角动量为 $J \\in \\{0, 2, 4, 6\\}$。\n    *   因此，允许的态为 $(J,T) = (0,1), (2,1), (4,1), (6,1)$。\n\n2.  **期望本征能量**：\n    *   能量由 $E(J,T=1) = V^{(1)}_J$ 给出。\n    *   $E(J=0) = V^{(1)}_{0} = -2.0\\,\\mathrm{MeV}$。\n    *   $E(J=2) = V^{(1)}_{2} = -1.0\\,\\mathrm{MeV}$。\n    *   $E(J=4) = V^{(1)}_{4} = 0.0\\,\\mathrm{MeV}$。\n    *   $E(J=6) = V^{(1)}_{6} = 0.5\\,\\mathrm{MeV}$。\n\n3.  **维度检验**：\n    *   $j=7/2$ 壳层中的单粒子态数量为 $2j+1 = 2(7/2)+1 = 8$。\n    *   对于两个全同费米子，双粒子 $M$ 表象基矢的维度是将它们放置在这 8 个态中的方式数，即 $\\binom{8}{2} = \\frac{8 \\times 7}{2} = 28$。\n    *   $J$ 耦合基矢的维度是所有允许的 $J$ 值的磁简并度 $(2J+1)$ 之和：$\\sum_{J \\in \\{0,2,4,6\\}} (2J+1) = (2\\cdot0+1) + (2\\cdot2+1) + (2\\cdot4+1) + (2\\cdot6+1) = 1 + 5 + 9 + 13 = 28$。\n    *   维度匹配（$28=28$），这证实了允许的 $J$ 值集合的完备性。\n\n**测试案例 II：一个质子和一个中子在 $j=7/2$ 壳层中**\n\n1.  **允许的量子数 $(J,T)$**：\n    *   系统由一个质子（$t_z = +1/2$）和一个中子（$t_z = -1/2$）组成。总同位旋投影为 $T_z = (+1/2) + (-1/2) = 0$。\n    *   由于 $T \\ge |T_z|=0$，所以 $T=0$ 和 $T=1$ 都是可能的。\n    *   问题指定了“良好同位旋量子数 $T$”，并且哈密顿量是在 $(J,T)$ 基矢中给出的。我们将质子和中子视为单个粒子（核子）的态，并应用广义泡利原理：$J+T$ 必须是奇数。\n    *   $J$ 的可能值为 $J \\in \\{0, 1, 2, 3, 4, 5, 6, 7\\}$。\n    *   如果 $T=1$，则 $J+1=\\text{奇数}$，所以 $J$ 必须是偶数：$J \\in \\{0, 2, 4, 6\\}$。\n    *   如果 $T=0$，则 $J+0=\\text{奇数}$，所以 $J$ 必须是奇数：$J \\in \\{1, 3, 5, 7\\}$。\n    *   因此，对于每个可能的 $J$ 值，都有一个唯一的对应 $T$ 值。\n\n2.  **期望本征能量**：\n    *   能量为 $E(J,T) = V^{(T)}_J$。\n    *   对于 $T=1$（偶数 $J$）：\n        $E(0,1) = V^{(1)}_{0} = -2.0\\,\\mathrm{MeV}$。\n        $E(2,1) = V^{(1)}_{2} = -1.0\\,\\mathrm{MeV}$。\n        $E(4,1) = V^{(1)}_{4} = 0.0\\,\\mathrm{MeV}$。\n        $E(6,1) = V^{(1)}_{6} = 0.5\\,\\mathrm{MeV}$。\n    *   对于 $T=0$（奇数 $J$）：\n        $E(1,0) = V^{(0)}_{1} = -1.5\\,\\mathrm{MeV}$。\n        $E(3,0) = V^{(0)}_{3} = -0.8\\,\\mathrm{MeV}$。\n        $E(5,0) = V^{(0)}_{5} = 0.2\\,\\mathrm{MeV}$。\n        $E(7,0) = V^{(0)}_{7} = 0.7\\,\\mathrm{MeV}$。\n\n3.  **维度检验**：\n    *   对于可区分的粒子（质子和中子），$M$ 表象基矢是通过取 8 个质子态中的任意一个和 8 个中子态中的任意一个来形成的。总维度为 $8 \\times 8 = 64$。\n    *   $J$ 耦合基矢的维度是所有允许的 $(J,T)$ 对的简并度之和：$\\sum_{J=0,2,4,6}(2J+1) + \\sum_{J=1,3,5,7}(2J+1) = \\sum_{J=0}^{7}(2J+1)$。\n    *   这个和是 $\\sum_{J=0}^{N=7}(2J+1) = (N+1)^2 = (7+1)^2 = 64$。\n    *   维度匹配（$64=64$），这证实了所获得的状态空间的完备性。\n\n**选项评估**\n\n*   **选项 A**：这个选项为两个测试案例都提供了规范。\n    *   对于测试案例 I（两个中子），它正确地确定了 $J \\in \\{0,2,4,6\\}$ 且 $T=1$，列出了基于 $V^{(1)}_J$ 的正确本征能量，并执行了正确的维度检验：$\\binom{8}{2} = 28 = \\sum (2J+1)$。\n    *   对于测试案例 II（质子-中子），它正确地确定了对偶数 $J$ 有 $T=1$，对奇数 $J$ 有 $T=0$，相应地列出了来自 $V^{(1)}_J$ 和 $V^{(0)}_J$ 两者的正确本征能量，并执行了正确的维度检验：$8 \\times 8 = 64 = \\sum_{J=0}^{7} (2J+1)$。\n    *   这个选项中的每一项陈述都与我们推导出的结果完全一致。\n    *   **结论：正确。**\n\n*   **选项 B**：\n    *   对于测试案例 I，它错误地包含了 $J=7$，并提供了一个不正确的维度计算（$\\binom{9}{2}=36$）和一个不匹配的和（$\\sum(2J+1)=43$）。\n    *   对于测试案例 II，它错误地交换了同位旋的分配（对偶数 $J$ 为 $T=0$，对奇数 $J$ 为 $T=1$），并且对所有能量都只使用了 $V^{(1)}_J$。\n    *   **结论：不正确。**\n\n*   **选项 C**：\n    *   对于测试案例 I，它错误地将允许的 $J$ 值限制为 $\\{0,2\\}$，导致维度检验失败（$28 \\ne 6$）。\n    *   对于测试案例 II，它错误地陈述了对于给定的 $J$，$T$ 是不受限制的，并提出了一个不正确的能量公式，作为 $V^{(0)}$ 和 $V^{(1)}$ 的平均值。\n    *   **结论：不正确。**\n\n*   **选项 D**：\n    *   对于测试案例 I，它错误地只列出了奇数 $J$ 值，这违反了 $T=1$ 的反对称性，并提出了一个无意义的维度检验。\n    *   对于测试案例 II，它正确地确定了 $T=0$ 的态，但完全忽略了 $T=1$ 的态，导致了一个不完整的谱和失败的维度检验。\n    *   **结论：不正确。**\n\n基于对基本原理的严格应用，只有选项 A 为两个基准测试案例提供了完全正确且一致的规范。", "answer": "$$\\boxed{A}$$", "id": "3575541"}]}