{"hands_on_practices": [{"introduction": "应用任何新的计算方法的第一步是建立一个稳健且经过验证的实现。本练习将指导您完成一个简单的两体哈密顿量的相似性重整化群（SRG）演化过程。通过验证演化过程正确地保持了物理可观测量（如本征值和散射相移），您将建立对自己数值代码的信心，并对 SRG 的幺正特性获得基本的理解 [@problem_id:3589984]。", "problem": "考虑一个双体哈密顿量在动量空间、分波、三维、无自旋、$s$波通道中的相似性重整化群（SRG）演化。在此问题中，我们使用自然单位制，其中 $\\hbar = 1$，且约化质量被选择为 $2\\mu = 1$。在这些单位中，动能为 $T(k) = k^2$。我们在连续动量表象中进行计算，采用适用于三维$s$波散射的径向测度，其中积分的测度为 $k^2 \\, \\mathrm{d}k/(2\\pi^2)$。使用高斯-勒让德求积法将连续谱在一个有限网格上离散化，该网格映射到 $k \\in [0,k_{\\max}]$，其节点为 $\\{k_i\\}_{i=1}^N$，权重为 $\\{w_i\\}_{i=1}^N$。\n\n定义一个秩一可分离势 $V(k,k') = -\\lambda \\, g(k) \\, g(k')$，其中 $g(k) = 1/(k^2 + \\beta^2)$，且 $\\lambda > 0$、$\\beta > 0$ 为常数参数。完整的哈密顿量核为 $H(k,k') = T(k) \\, \\delta(k-k') + V(k,k')$. 使用动能生成元 $G = T$ 引入SRG流，因此SRG方程为\n$$\n\\frac{\\mathrm{d}H_s}{\\mathrm{d}s} = [\\eta_s, H_s], \\quad \\eta_s = [G,H_s],\n$$\n其中 $[\\cdot,\\cdot]$ 表示对易子。SRG参数 $s \\ge 0$ 是一个控制退耦的流参数。\n\n为了在离散化的连续谱中实现数值稳定的算符代数，我们使用由对角缩放矩阵 $S = \\mathrm{diag}\\left(\\sqrt{w_i \\, m_i}\\right)$ 定义的加权正交归一表示，其中 $m_i = k_i^2/(2\\pi^2)$。通过 $\\tilde{O} = S \\, O \\, S$ 将任何核 $O(k,k')$ 映射到其正交归一矩阵表示 $\\tilde{O}$。在这种正交归一表示中，动能算符是对角的，$\\tilde{T}_{ij} = k_i^2 \\, \\delta_{ij}$，并且标准的矩阵乘法对应于连续谱算符复合。\n\n对于散射问题，考虑在能量 $E = k_0^2$ 下的反应（K）矩阵，其中外部在壳动量 $k_0$ 等于网格点之一 $k_{i_0}$。在此表示中，主值预解式是对角的，定义为\n$$\n\\tilde{G}_0^{\\mathrm{P}}(E)_{jj} = \\begin{cases}\n\\frac{1}{E - k_j^2},  \\text{if } j \\ne i_0,\\\\\n0,  \\text{if } j = i_0,\n\\end{cases}\n$$\n这在奇异点处强制执行了柯西主值。正交归一表示中的K矩阵满足\n$$\n\\tilde{K} = \\tilde{V} + \\tilde{V} \\, \\tilde{G}_0^{\\mathrm{P}} \\, \\tilde{K},\n$$\n并且可以通过求解线性系统 $(I - \\tilde{V} \\, \\tilde{G}_0^{\\mathrm{P}}) \\, \\tilde{K} = \\tilde{V}$ 得到。物理在壳核函数值通过撤销缩放来恢复：\n$$\nK(k_{i_0}, k_{i_0}; E) = \\frac{\\tilde{K}_{i_0 i_0}}{w_{i_0} \\, m_{i_0}}.\n$$\n根据所选的归一化和单位，$s$波相移 $\\delta(k_0)$（以弧度为单位）与在壳K矩阵的关系为\n$$\n\\tan \\delta(k_0) = - \\mu \\, k_0 \\, K(k_0,k_0; E),\n$$\n其中 $\\mu = \\tfrac{1}{2}$。\n\n任务：\n1. 使用高斯-勒让德求积法，以 $N$ 个点在 $[0,k_{\\max}]$ 上离散化动量网格。构建缩放矩阵 $S$、正交归一动能矩阵 $\\tilde{T}$ 以及与可分离形式 $V(k,k')$ 对应的正交归一势能矩阵 $\\tilde{V}$。\n2. 使用动能生成元，实现从 $s=0$ 到目标 $s=s_{\\mathrm{target}}$ 的SRG演化，积分\n$$\n\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [[\\tilde{T}, \\tilde{H}_s], \\tilde{H}_s],\n$$\n从 $\\tilde{H}_0 = \\tilde{T} + \\tilde{V}$ 开始。确保数值积分在数值容差范围内保持厄米性。\n3. 通过检查不变量和收敛性来验证数值实现：\n   - 本征值不变性：在幺正SRG演化下，$\\tilde{H}_s$ 的谱必须是不变的。量化 $\\tilde{H}_{s=0}$ 和 $\\tilde{H}_{s=s_{\\mathrm{target}}}$ 的排序后本征值之间的最大绝对差。\n   - 相移不变性：使用如定义的主值K矩阵方法，计算在 $s=0$ 和 $s=s_{\\mathrm{target}}$ 时 $s$波相移 $\\delta(k_0)$（以弧度为单位），并量化其绝对差 $|\\delta_{s=0} - \\delta_{s=s_{\\mathrm{target}}}|$。\n   - 随网格分辨率的收敛性：在粗糙分辨率 $N_{\\mathrm{coarse}}$ 和更精细分辨率 $N_{\\mathrm{fine}}$ 下比较这两个误差度量，以测试误差是否随 $N$ 的增加而减小；报告布尔值，指示更精细的网格是否产生更小的误差。\n\n在自然单位制下使用以下固定的物理和数值参数：\n- $\\lambda = 5.0$, $\\beta = 1.0$。\n- $k_{\\max} = 8.0$。\n- 选择 $s_{\\mathrm{target}} = 0.02$。\n- 使用 $N_{\\mathrm{coarse}} = 32$ 和 $N_{\\mathrm{fine}} = 64$。\n- 对于相移，选择在壳动量为索引为 $i_0 = \\lfloor N/4 \\rfloor$ 的网格节点。相移必须以弧度表示。\n\n您的程序应为指定的测试套件计算以下内容：\n- 测试用例1（正常路径）：对于 $N = N_{\\mathrm{fine}}$，计算 $s=0$ 和 $s=s_{\\mathrm{target}}$ 之间的最大绝对本征值差异。\n- 测试用例2（正常路径）：对于 $N = N_{\\mathrm{fine}}$，计算 $k_0 = k_{i_0}$ 处 $s=0$ 和 $s=s_{\\mathrm{target}}$ 之间的绝对相移差（以弧度为单位）。\n- 测试用例3（本征值的收敛性检查）：计算 $N = N_{\\mathrm{coarse}}$ 和 $N = N_{\\mathrm{fine}}$ 的最大绝对本征值差异；返回一个布尔值，指示在 $N = N_{\\mathrm{fine}}$ 时误差是否更小。\n- 测试用例4（相移的收敛性检查）：计算 $N = N_{\\mathrm{coarse}}$ 和 $N = N_{\\mathrm{fine}}$ 的绝对相移差；返回一个布尔值，指示在 $N = N_{\\mathrm{fine}}$ 时误差是否更小。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述顺序包含四个测试用例的结果：\n$$\n[\\Delta E_{\\max}, \\Delta \\delta, \\mathrm{eig\\_conv}, \\mathrm{phase\\_conv}],\n$$\n其中 $\\Delta E_{\\max}$ 和 $\\Delta \\delta$ 是浮点数，$\\mathrm{eig\\_conv}$ 和 $\\mathrm{phase\\_conv}$ 是布尔值。", "solution": "该问题要求在一个离散化的动量空间中实现并验证双体哈密顿量的相似性重整化群（SRG）演化。验证过程包括检查SRG流下本征值和散射相移的不变性。解决方案分为四个阶段：（1）连续谱哈密顿量的离散化，（2）SRG流方程的数值积分，（3）物理可观测量（本征值和相移）的计算，以及（4）数值收敛性的分析。\n\n### 步骤1：离散化与矩阵表示\n\n为了便于数值计算，必须将连续动量空间哈密顿量表示为有限维矩阵。这通过使用高斯-勒让德求积法来离散化动量积分来实现。\n\n动量变量 $k \\in [0, k_{\\max}]$ 被离散化到 $N$ 个点 $\\{k_i\\}_{i=1}^N$ 的网格上。我们使用定义在区间 $[-1, 1]$ 上的 $N$ 点高斯-勒让德求积法则，其节点为 $\\{x_j'\\}_{j=1}^N$，权重为 $\\{w_j'\\}_{j=1}^N$。这些点通过变换 $k(x) = \\frac{k_{\\max}}{2}(x+1)$ 映射到区间 $[0, k_{\\max}]$。求积节点 $k_i$ 和权重 $w_i$ 于是为：\n$$\nk_i = \\frac{k_{\\max}}{2}(x_i' + 1)\n$$\n$$\nw_i = w_i' \\frac{k_{\\max}}{2}\n$$\n函数 $f(k)$ 的积分近似为 $\\int_0^{k_{\\max}} f(k) \\, \\mathrm{d}k \\approx \\sum_{i=1}^N w_i f(k_i)$。\n\n问题指定了一种正交归一表示，其中矩阵乘法对应于连续谱算符复合。$s$波散射的积分测度为 $m(k) \\mathrm{d}k = \\frac{k^2}{2\\pi^2} \\mathrm{d}k$。我们定义一个对角缩放矩阵 $S$，其元素为 $S_{ii} = \\sqrt{w_i m_i}$，其中 $m_i = m(k_i) = k_i^2/(2\\pi^2)$。\n\n算符 $\\hat{O}$ 的正交归一矩阵表示 $\\tilde{O}$ 由其在一组正交归一函数基底下的矩阵元给出。对于本问题中的算符，这导致以下矩阵形式：\n\n1.  **动能算符：** 动能 $\\hat{T}$ 是一个局域算符，其核为 $T(k, k') = k^2 \\delta(k-k')$。它在正交归一基底下的矩阵表示是对角的：\n    $$\n    \\tilde{T}_{ij} = k_i^2 \\delta_{ij}\n    $$\n    此矩阵记作 $\\tilde{T}$。\n\n2.  **势能算符：** 势是一个非局域的秩一可分离算符，其核为 $V(k,k') = -\\lambda g(k) g(k')$，其中 $g(k) = 1/(k^2 + \\beta^2)$。其矩阵表示是通过首先构建矩阵 $V_{ij} = V(k_i, k_j)$，然后应用缩放变换：$\\tilde{V} = SVS$ 来构造的。\n    设 $\\mathbf{g}$ 为一个列向量，其元素为 $g_i = g(k_i) = 1/(k_i^2+\\beta^2)$。则矩阵 $V$ 为 $V = -\\lambda \\mathbf{g} \\mathbf{g}^T$。\n    正交归一势矩阵 $\\tilde{V}$ 变为：\n    $$\n    \\tilde{V} = S (-\\lambda \\mathbf{g} \\mathbf{g}^T) S = -\\lambda (S\\mathbf{g})(S\\mathbf{g})^T\n    $$\n    令 $\\tilde{\\mathbf{g}} = S\\mathbf{g}$，其元素为 $\\tilde{g}_i = S_{ii} g_i = \\sqrt{w_i k_i^2/(2\\pi^2)} g_i$，则势矩阵为 $\\tilde{V} = -\\lambda \\tilde{\\mathbf{g}} \\tilde{\\mathbf{g}}^T$。\n\n流参数 $s=0$ 处的初始哈密顿量是 $\\tilde{H}_0 = \\tilde{T} + \\tilde{V}$。由于 $\\tilde{T}$ 是对角的，且 $\\tilde{V}$ 是实对称的，因此 $\\tilde{H}_0$ 是一个实对称（因而也是厄米共轭）的矩阵。\n\n### 步骤2：SRG演化\n\n哈密顿量矩阵 $\\tilde{H}_s$ 的SRG演化由常微分方程（ODE）控制：\n$$\n\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [[\\tilde{T}, \\tilde{H}_s], \\tilde{H}_s]\n$$\n与对角矩阵 $\\tilde{T}$ 的对易子可以高效计算：$([\\tilde{T}, \\tilde{H}_s])_{ij} = (\\tilde{T}_{ii} - \\tilde{T}_{jj})(\\tilde{H}_s)_{ij} = (k_i^2 - k_j^2)(\\tilde{H}_s)_{ij}$。令 $\\eta_s = [\\tilde{T}, \\tilde{H}_s]$。则ODE为 $\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s} = [\\eta_s, \\tilde{H}_s]$。\n\n这个矩阵ODE从 $s=0$ 到 $s=s_{\\mathrm{target}}$，以 $\\tilde{H}_0$ 为初始条件进行数值积分。我们采用一个标准的自适应步长ODE求解器，例如 `scipy.integrate.solve_ivp` 中的 `RK45`。由于生成元 $\\tilde{T}$ 是厄米共轭的，流是幺正的，并保持 $\\tilde{H}_s$ 的谱。算符 $\\eta_s$ 是反厄米共轭的，这确保了导数 $\\frac{\\mathrm{d}\\tilde{H}_s}{\\mathrm{d}s}$ 是厄米共轭的，因此 $\\tilde{H}_s$ 的厄米性在整个演化过程中得以保持。破坏矩阵对称性的小数值误差可以通过取最终矩阵的对称部分来修正：$\\tilde{H}_{s_{\\mathrm{target}}} \\leftarrow \\frac{1}{2}(\\tilde{H}_{s_{\\mathrm{target}}} + \\tilde{H}_{s_{\\mathrm{target}}}^T)$。\n\n### 步骤3：不变量的计算\n\n为了验证实现，我们检查SRG流的两个不变量：哈密顿量的本征值和在壳散射可观测量（相移）。\n\n1.  **本征值不变性：** $\\tilde{H}_s$ 的本征值必须与流参数 $s$ 无关。我们使用数值本征求解器计算初始哈密顿量 $\\tilde{H}_0$ 和最终演化哈密顿量 $\\tilde{H}_{s_{\\mathrm{target}}}$ 的本征值。将排序后的本征值列表进行比较，并计算最大绝对差作为误差度量：\n    $$\n    \\Delta E_{\\max} = \\max_i |\\lambda_i(s=0) - \\lambda_i(s=s_{\\mathrm{target}})|\n    $$\n\n2.  **相移不变性：** 作为物理可观测量，散射相移也必须是不变的。在壳动量 $k_0$ （对应能量 $E=k_0^2$）下的相移 $\\delta(k_0)$ 使用K矩阵形式主义计算。\n    首先，从演化后的哈密顿量中提取出演化后的势矩阵：$\\tilde{V}_s = \\tilde{H}_s - \\tilde{T}$。\n    K矩阵 $\\tilde{K}_s$ 通过求解Lippmann-Schwinger类型方程 $(I - \\tilde{V}_s \\tilde{G}_0^{\\mathrm{P}}) \\tilde{K}_s = \\tilde{V}_s$ 得到，其中 $\\tilde{G}_0^{\\mathrm{P}}$ 是对角主值预解式矩阵。对于选定的在壳动量 $k_0 = k_{i_0}$（其中 $i_0 = \\lfloor N/4 \\rfloor$ 是网格索引），其元素为：\n    $$\n    (\\tilde{G}_0^{\\mathrm{P}}(E))_{jj} = \\begin{cases}\n    \\frac{1}{E - k_j^2},  \\text{if } j \\ne i_0 \\\\\n    0,  \\text{if } j = i_0\n    \\end{cases}\n    $$\n    其中 $E = k_{i_0}^2$。这是一个关于矩阵 $\\tilde{K}_s$ 的线性方程组，可以进行数值求解。\n    物理在壳K矩阵元通过撤销基底缩放来恢复：\n    $$\n    K_s(k_{i_0}, k_{i_0}; E) = \\frac{(\\tilde{K}_s)_{i_0 i_0}}{w_{i_0} m_{i_0}} = \\frac{(\\tilde{K}_s)_{i_0 i_0}}{w_{i_0} k_{i_0}^2 / (2\\pi^2)}\n    $$\n    然后，$s$波相移 $\\delta_s(k_0)$ 由以下关系给出：\n    $$\n    \\delta_s(k_0) = \\arctan(-\\mu k_0 K_s(k_0, k_0; E))\n    $$\n    其中 $\\mu = 1/2$。此计算分别在 $s=0$ (使用 $\\tilde{H}_0$) 和 $s=s_{\\mathrm{target}}$ (使用 $\\tilde{H}_{s_{\\mathrm{target}}}$)下进行，并计算绝对差 $\\Delta \\delta = |\\delta_0 - \\delta_{s_{\\mathrm{target}}}|$。\n\n### 步骤4：数值流程与收敛性分析\n\n整个过程被封装在一个函数中，该函数以网格大小 $N$ 作为输入。此函数执行离散化、SRG演化以及两个误差度量 $\\Delta E_{\\max}$ 和 $\\Delta \\delta$ 的计算。\n\n为完成所需任务：\n- 调用该函数，参数为 $N=N_{\\mathrm{fine}}=64$。得到的 $\\Delta E_{\\max}$ 和 $\\Delta \\delta$ 是前两个必需的输出。\n- 也调用该函数，参数为 $N=N_{\\mathrm{coarse}}=32$。设误差为 $\\Delta E_{\\max}^{(\\mathrm{coarse})}$ 和 $\\Delta\\delta^{(\\mathrm{coarse})}$，精细网格上的误差为 $\\Delta E_{\\max}^{(\\mathrm{fine})}$ 和 $\\Delta\\delta^{(\\mathrm{fine})}$。\n- 收敛性检查是如下定义的布尔值：\n    - $\\mathrm{eig\\_conv} = (\\Delta E_{\\max}^{(\\mathrm{fine})}  \\Delta E_{\\max}^{(\\mathrm{coarse})})$\n    - $\\mathrm{phase\\_conv} = (\\Delta\\delta^{(\\mathrm{fine})}  \\Delta\\delta^{(\\mathrm{coarse})})$\n这四个值构成了最终输出。随着网格离散化更精细，误差减小，表明数值误差（来自求积、ODE积分和线性代数）是受控的，并如预期那样趋向于零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the SRG calculations and produce the final output.\n    \"\"\"\n\n    # Fixed physical and numerical parameters\n    LAMBDA = 5.0\n    BETA = 1.0\n    K_MAX = 8.0\n    S_TARGET = 0.02\n    MU = 0.5\n    N_COARSE = 32\n    N_FINE = 64\n\n    def run_srg_calculation(N: int):\n        \"\"\"\n        Performs the full SRG calculation for a given grid size N.\n\n        Args:\n            N (int): Number of momentum grid points.\n\n        Returns:\n            tuple: A tuple containing:\n                - delta_E_max (float): Maximum absolute eigenvalue difference.\n                - delta_phase_shift (float): Absolute phase shift difference.\n        \"\"\"\n        # --- 1. Discretization and Matrix Construction ---\n        \n        # Get Gauss-Legendre quadrature nodes and weights for [-1, 1]\n        x_nodes, x_weights = roots_legendre(N)\n        \n        # Map nodes and weights to [0, K_MAX]\n        k_nodes = K_MAX / 2.0 * (x_nodes + 1.0)\n        k_weights = K_MAX / 2.0 * x_weights\n\n        # Construct measure factor and scaling matrix S\n        m_i = k_nodes**2 / (2.0 * np.pi**2)\n        s_diag = np.sqrt(k_weights * m_i)\n        \n        # Kinetic energy matrix (diagonal)\n        t_tilde = np.diag(k_nodes**2)\n\n        # Potential energy matrix (rank-one separable)\n        g_vec = 1.0 / (k_nodes**2 + BETA**2)\n        g_tilde_vec = s_diag * g_vec\n        v_tilde = -LAMBDA * np.outer(g_tilde_vec, g_tilde_vec)\n        \n        # Initial Hamiltonian at s=0\n        h0_tilde = t_tilde + v_tilde\n\n        # --- 2. SRG Evolution ---\n        \n        def srg_ode(s, h_flat, t_diag_sq):\n            \"\"\"RHS of the SRG ODE for the ODE solver.\"\"\"\n            h_s = h_flat.reshape((N, N))\n            # Commutator [T, H] = T H - H T\n            # Since T is diagonal, (k_i^2 - k_j^2) H_ij\n            diff_t_sq = t_diag_sq[:, None] - t_diag_sq[None, :]\n            eta = diff_t_sq * h_s\n            # Commutator [eta, H]\n            dh_ds = eta @ h_s - h_s @ eta\n            return dh_ds.flatten()\n        \n        # Integrate the ODE\n        t_diag_sq = np.diag(t_tilde)\n        sol = solve_ivp(\n            srg_ode,\n            [0, S_TARGET],\n            h0_tilde.flatten(),\n            args=(t_diag_sq,),\n            method='RK45', \n            rtol=1e-8, \n            atol=1e-8\n        )\n        \n        # Evolved Hamiltonian at s=S_TARGET\n        hs_tilde_flat = sol.y[:, -1]\n        hs_tilde = hs_tilde_flat.reshape((N, N))\n        \n        # Enforce symmetry to remove numerical noise\n        hs_tilde = 0.5 * (hs_tilde + hs_tilde.T)\n\n        # --- 3. Invariant Checks ---\n        \n        # Eigenvalue invariance\n        evals0 = np.linalg.eigvalsh(h0_tilde)\n        evals_s = np.linalg.eigvalsh(hs_tilde)\n        delta_E_max = np.max(np.abs(evals0 - evals_s))\n        \n        def calculate_phase_shift(h_matrix):\n            \"\"\"Calculates the s-wave phase shift from a given Hamiltonian matrix.\"\"\"\n            v_matrix = h_matrix - t_tilde\n            i0 = N // 4  # On-shell index\n            k0 = k_nodes[i0]\n            E = k0**2\n            \n            # Principal value resolvent\n            g0p_diag = np.zeros(N)\n            for j in range(N):\n                if j != i0:\n                    g0p_diag[j] = 1.0 / (E - k_nodes[j]**2)\n            g0p = np.diag(g0p_diag)\n            \n            # Solve linear system for K-matrix: (I - V G0P) K = V\n            A = np.eye(N) - v_matrix @ g0p\n            try:\n                k_matrix = np.linalg.solve(A, v_matrix)\n            except np.linalg.LinAlgError:\n                return np.nan # In case of singularity\n            \n            # On-shell K-matrix element\n            k_onshell_tilde = k_matrix[i0, i0]\n            \n            # Rescale to physical value\n            w_i0 = k_weights[i0]\n            m_i0 = k0**2 / (2 * np.pi**2)\n            if w_i0 * m_i0 == 0: return np.nan\n            k_onshell_phys = k_onshell_tilde / (w_i0 * m_i0)\n            \n            # Calculate phase shift\n            tan_delta = -MU * k0 * k_onshell_phys\n            delta = np.arctan(tan_delta)\n            return delta\n        \n        # Phase shift invariance\n        delta_0 = calculate_phase_shift(h0_tilde)\n        delta_s = calculate_phase_shift(hs_tilde)\n        delta_phase_shift = np.abs(delta_0 - delta_s)\n        \n        return delta_E_max, delta_phase_shift\n\n    # --- 4. Run calculations and collect results ---\n    \n    # Run for coarse and fine grids\n    err_E_coarse, err_d_coarse = run_srg_calculation(N_COARSE)\n    err_E_fine, err_d_fine = run_srg_calculation(N_FINE)\n\n    # Prepare final results for output\n    # Test case 1: ΔE_max for N_fine\n    delta_E_max_fine = err_E_fine\n    # Test case 2: Δδ for N_fine\n    delta_phase_shift_fine = err_d_fine\n    # Test case 3: Eigenvalue error convergence\n    eig_conv = err_E_fine  err_E_coarse\n    # Test case 4: Phase shift error convergence\n    phase_conv = err_d_fine  err_d_coarse\n\n    results = [delta_E_max_fine, delta_phase_shift_fine, eig_conv, phase_conv]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3589984"}, {"introduction": "SRG 演化的目标是解耦低动量和高动量尺度，从而简化哈密顿量。然而，这种解耦效果的具体表现可能取决于所选择的基矢表示。本练习通过在动量空间基和简谐振子基中实现 SRG 流，并使用一个定量的“解耦度规”来比较它们的效果，从而探讨这种基矢依赖性 [@problem_id:3589981]。这将帮助您深入理解基矢选择如何影响 SRG 计算的效率和解释。", "problem": "考虑一个离散哈密顿算符，在两种不同的基（动量基和谐振子基）中进行相似性重整化群 (SRG) 演化。SRG 流根据基本算符动力学演化哈密顿量。具体而言，对于一个哈密顿算符 $H_s$，其演化参数为 $s$，生成元为 $G_s$，其 SRG 流方程由下式给出\n$$\n\\frac{d H_s}{d s} = \\left[ \\left[ G_s, H_s \\right], H_s \\right],\n$$\n其中 $[\\cdot,\\cdot]$ 表示对易子。在本问题中，生成元取为动能算符 $T$，并在流的演化过程中保持不变，即 $G_s = T$。\n\n您将实施一个计算实验来探究基的依赖性，方法是在每种基中演化 $H_s$，并比较一个用动量差截断表示的解耦度量。所有计算都将在自然单位制中进行，其中普朗克常数 $\\hbar = 1$ 且质量 $m = 1$，因此所有量都是无量纲的。\n\n通过标度关系 $\\lambda = s^{-1/4}$ 定义 SRG 流参数 $\\lambda$，因此演化到目标 $\\lambda$ 对应于将流方程从 $s = 0$ 积分到 $s = \\lambda^{-4}$。设解耦度量为\n$$\nD(\\lambda) = \\sum_{\\lvert p - p' \\rvert  \\Lambda} \\left\\lvert H_s(p,p') \\right\\rvert^2,\n$$\n其中 $\\Lambda$ 是一个固定阈值，求和遍及所有满足所述不等式的、与离散基标签相关联的动量对。在动量基中，离散动量是网格点 $p_i$；在谐振子基中，使用谐振子的维里定理为每个基态定义一个有效动量标度，第 $n$ 个基态被赋予\n$$\np_n = \\sqrt{m \\hbar \\omega \\left(n + \\tfrac{1}{2}\\right)} = \\sqrt{\\omega \\left(n + \\tfrac{1}{2}\\right)},\n$$\n该式在自然单位制下表征了该状态的典型动量标度。\n\n按如下方式构建初始离散哈密顿量 $H_0 = T + V$。\n\n1. 动量基：\n   - 使用一个由 $N$ 个动量点 $p_i$ 组成的一维网格，这些点在线性间隔 $[0, p_{\\max}]$ 内。\n   - 将动能矩阵定义为对角矩阵，$T_{ij} = \\delta_{ij} \\frac{p_i^2}{2 m} = \\delta_{ij} \\frac{p_i^2}{2}$。\n   - 在动量空间中定义一个对称、吸引人的可分离高斯相互作用，\n     $$\n     V_{ij} = -g \\exp\\left( -\\frac{p_i^2 + p_j^2}{\\Lambda_V^2} \\right),\n     $$\n     其中 $g$ 和 $\\Lambda_V$ 是无量纲参数。\n\n2. 谐振子基：\n   - 使用由非负整数 $n=0,1,2,\\dots,N-1$ 标记的 $N$ 个基态，并定义有效动量 $p_n = \\sqrt{\\omega \\left(n + \\tfrac{1}{2}\\right)}$。\n   - 将动能矩阵定义为对角矩阵，$T_{nm} = \\delta_{nm} \\frac{p_n^2}{2}$。\n   - 使用相同的函数依赖关系，但在有效动量处求值来定义一个相互作用矩阵，\n     $$\n     V_{nm} = -g \\exp\\left( -\\frac{p_n^2 + p_m^2}{\\Lambda_V^2} \\right).\n     $$\n\n在两种基中，都通过数值积分流方程（从 $s=0$ 到 $s=\\lambda^{-4}$）将 $H_0$ 演化为 $H_s$，其中生成元为 $T$。演化后，计算如上定义的解耦度量 $D(\\lambda)$，求和仅限于那些其指定动量满足 $\\lvert p - p' \\rvert  \\Lambda$ 的指标对。请注意，在此设置中，解耦度量没有物理单位，因为哈密顿量和动量标度在自然单位制下都是无量纲的。\n\n您的实现必须遵循以下原则：\n- 将哈密顿矩阵视为实对称矩阵；数值积分可能会产生微小的非对称性，应在演化结束时通过对称化来减轻。\n- 显式使用双对易子结构来计算 SRG 流方程的右侧。\n- 使用具有适当严格公差的自适应求解器，确保数值积分的稳定性和准确性。\n\n测试套件：\n为以下六个测试用例计算 $D(\\lambda)$。每个用例都是独立的，需要构建相应的基、建立 $H_0$、进行演化并计算 $D(\\lambda)$。\n\n- 用例 1（动量基，一般情况）：$N = 10$，$p_{\\max} = 5.0$，$g = 1.0$，$\\Lambda_V = 2.0$，$\\lambda = 2.0$，$\\Lambda = 2.0$。\n- 用例 2（谐振子基，一般情况）：$N = 10$，$\\omega = 1.0$，$g = 1.0$，$\\Lambda_V = 2.0$，$\\lambda = 2.0$，$\\Lambda = 2.0$。\n- 用例 3（动量基，强调非对角元）：$N = 12$，$p_{\\max} = 6.0$，$g = 1.0$，$\\Lambda_V = 2.0$，$\\lambda = 1.5$，$\\Lambda = 0.0$。\n- 用例 4（谐振子基，强调非对角元）：$N = 12$，$\\omega = 1.0$，$g = 1.0$，$\\Lambda_V = 2.0$，$\\lambda = 1.5$，$\\Lambda = 0.0$。\n- 用例 5（动量基，导致求和为零的极端截断）：$N = 8$，$p_{\\max} = 4.0$，$g = 1.0$，$\\Lambda_V = 2.0$，$\\lambda = 4.0$，$\\Lambda = 100.0$。\n- 用例 6（谐振子基，导致求和为零的极端截断）：$N = 8$，$\\omega = 1.0$，$g = 1.0$，$\\Lambda_V = 2.0$，$\\lambda = 4.0$，$\\Lambda = 100.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述测试用例顺序排列的六个解耦度量值，格式为方括号括起来的逗号分隔列表。例如，输出形式应为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6].\n$$\n每个条目必须是自然单位制下的浮点数，并且必须由您的实现计算得出。", "solution": "该问题要求在两种不同的基（离散动量基和谐振子 (HO) 基）中，为一维两体哈密顿量实现相似性重整化群 (SRG) 演化。目标是在演化哈密顿量后，为几个测试用例计算一个解耦度量 $D(\\lambda)$。\n\n哈密顿算符 $H_s$ 的 SRG 演化由以下微分方程控制：\n$$\n\\frac{d H_s}{d s} = \\left[ \\left[ G_s, H_s \\right], H_s \\right]\n$$\n其中 $s$ 是流参数，$[\\cdot,\\cdot]$ 是对易子，$G_s$ 是流的生成元。在本问题中，生成元是动能算符 $G_s = T$，它在整个演化过程中保持不变。演化从初始参数 $s=0$ 执行到最终值 $s = \\lambda^{-4}$，其中 $\\lambda$ 是一个指定的能量标度。\n\n初始哈密顿量为 $H_0 = T + V$，其中 $T$ 是动能，$V$ 是势能。我们将这些算符表示为所选基中的 $N \\times N$ 矩阵。\n\n首先，我们必须定义基并构建初始哈密顿矩阵 $H_0$。\n\n在**动量基**中，我们使用一个由 $N$ 个离散动量点 $p_i$ 组成的网格，这些点从 $0$ 到 $p_{\\max}$ 线性间隔。\n动能矩阵 $T$ 在此基中是对角的，其元素为：\n$$\nT_{ij} = \\delta_{ij} \\frac{p_i^2}{2m} = \\delta_{ij} \\frac{p_i^2}{2}\n$$\n因为我们在质量 $m=1$ 的自然单位制中工作。\n势能矩阵 $V$ 由一个对称、吸引人的可分离高斯相互作用定义：\n$$\nV_{ij} = -g \\exp\\left( -\\frac{p_i^2 + p_j^2}{\\Lambda_V^2} \\right)\n$$\n其中 $g$ 和 $\\Lambda_V$ 是给定参数。\n\n在**谐振子基**中，我们使用由 $n=0, 1, \\dots, N-1$ 索引的 $N$ 个基态。根据维里定理为每个状态分配一个有效动量 $p_n$：\n$$\np_n = \\sqrt{m \\hbar \\omega \\left(n + \\tfrac{1}{2}\\right)} = \\sqrt{\\omega \\left(n + \\tfrac{1}{2}\\right)}\n$$\n因为 $m=1$ 且 $\\hbar=1$。参数 $\\omega$ 是振子频率。动能和势能矩阵是使用这些有效动量构建的，类似于动量基的情况：\n$$\nT_{nm} = \\delta_{nm} \\frac{p_n^2}{2}\n$$\n$$\nV_{nm} = -g \\exp\\left( -\\frac{p_n^2 + p_m^2}{\\Lambda_V^2} \\right)\n$$\n\n任务的核心是数值积分 $H_s$ 的矩阵微分方程。该方程描述了哈密顿矩阵每个元素的演化。我们可以将 $N \\times N$ 矩阵 $H_s$ 表示为一个包含 $N^2$ 个元素的向量，并使用标准的 ODE 求解器。流方程的右侧 (RHS) 使用矩阵代数计算。令 $\\eta_s = [T, H_s] = TH_s - H_s T$。则 RHS 为 $[\\eta_s, H_s] = \\eta_s H_s - H_s \\eta_s$。由于初始哈密顿量 $H_0$ 是实对称的，生成元 $T$ 也是实对称的，因此在精确演化下，演化后的哈密顿量 $H_s$ 将保持实对称性。数值积分可能会引入微小的非对称性，因此我们通过取 $H_s \\to \\frac{1}{2}(H_s + H_s^T)$ 来对最终结果强制施加对称性。\n\n积分使用自适应步长 ODE 求解器（例如 `scipy.integrate.solve_ivp`）从 $s=0$ 到 $s_f = \\lambda^{-4}$ 进行，并使用严格的相对和绝对公差以确保准确性。\n\n在 $s=s_f$ 处获得最终哈密顿矩阵 $H_s$ 后，我们计算解耦度量 $D(\\lambda)$。此度量量化了耦合具有大动量差的态的非对角元的大小：\n$$\nD(\\lambda) = \\sum_{\\lvert p - p' \\rvert  \\Lambda} \\left\\lvert H_s(p,p') \\right\\rvert^2\n$$\n这里，$p$ 和 $p'$ 是基态的动量标签（即网格点 $p_i$ 或有效动量 $p_n$），$\\Lambda$ 是指定的动量截断值。求和遍及所有满足条件 $|p_i - p_j|  \\Lambda$ 的基指标对 $(i,j)$。由于 $H_s$ 是实矩阵，$|H_s(p,p')|^2$ 就是 $(H_s(i,j))^2$。\n\n实现将包含一个主循环，遍历六个测试用例。对每个用例，它将：\n1.  设置参数（$N$，$p_{\\max}$ 或 $\\omega$ 等）。\n2.  构建相应的动量向量 `p_vec`。\n3.  构建初始哈密顿矩阵 $H_0 = T + V$。\n4.  数值积分 SRG 流方程从 $s=0$ 到 $s_f = \\lambda^{-4}$，以找到 $H_s$。\n5.  对称化所得矩阵 $H_s$。\n6.  通过对相关矩阵元素的平方求和来计算解耦度量 $D(\\lambda)$。\n收集所有用例的最终结果，并按指定格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef srg_rhs(s, y, T_matrix, N):\n    \"\"\"\n    Computes the right-hand side of the SRG flow equation: dH/ds = [[T, H], H].\n    \n    Args:\n        s (float): The flow parameter (time).\n        y (np.ndarray): Flattened Hamiltonian matrix H_s.\n        T_matrix (np.ndarray): The constant kinetic energy matrix (generator).\n        N (int): The dimension of the matrices.\n        \n    Returns:\n        np.ndarray: The flattened time derivative of the Hamiltonian, dH/ds.\n    \"\"\"\n    H_s = y.reshape((N, N))\n    \n    # First commutator: eta = [T, H_s]\n    eta = T_matrix @ H_s - H_s @ T_matrix\n    \n    # Second commutator (double commutator): dH/ds = [eta, H_s]\n    dHds = eta @ H_s - H_s @ eta\n    \n    return dHds.flatten()\n\ndef compute_decoupling_metric(H_final, p_vec, Lambda_cut):\n    \"\"\"\n    Computes the decoupling metric D(lambda).\n    \n    Args:\n        H_final (np.ndarray): The evolved Hamiltonian matrix.\n        p_vec (np.ndarray): The vector of momentum labels for the basis.\n        Lambda_cut (float): The momentum difference cutoff.\n        \n    Returns:\n        float: The calculated decoupling metric.\n    \"\"\"\n    # Create a matrix of absolute momentum differences |p_i - p_j|\n    p_diff_matrix = np.abs(np.subtract.outer(p_vec, p_vec))\n    \n    # Create a boolean mask for elements where the difference is greater than the cutoff\n    mask = p_diff_matrix  Lambda_cut\n    \n    # Sum the square of the Hamiltonian matrix elements that meet the condition.\n    # Since H is real, |H|^2 is just H**2.\n    decoupling_metric = np.sum(H_final[mask]**2)\n    \n    return decoupling_metric\n\ndef run_srg_case(params):\n    \"\"\"\n    Runs a single SRG evolution case and computes the decoupling metric.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n        \n    Returns:\n        float: The final decoupling metric D(lambda).\n    \"\"\"\n    # Unpack parameters\n    N = params['N']\n    g = params['g']\n    Lambda_V = params['Lambda_V']\n    lam = params['lam']  # Renamed from lambda to avoid keyword conflict\n    Lambda_cut = params['Lambda']\n    basis = params['basis']\n\n    # 1. Construct momentum vector\n    if basis == 'momentum':\n        p_max = params['p_max']\n        p_vec = np.linspace(0, p_max, N)\n    elif basis == 'ho':\n        omega = params['omega']\n        n_indices = np.arange(N)\n        p_vec = np.sqrt(omega * (n_indices + 0.5))\n    else:\n        raise ValueError(f\"Unknown basis type: {basis}\")\n\n    # 2. Construct initial Hamiltonian H0 = T + V\n    p_squared = p_vec**2\n    T_matrix = np.diag(p_squared / 2.0)\n    \n    p_sum_sq_outer = np.add.outer(p_squared, p_squared)\n    V_matrix = -g * np.exp(-p_sum_sq_outer / (Lambda_V**2))\n    \n    H0 = T_matrix + V_matrix\n\n    # 3. Evolve H using SRG\n    s_final = lam**(-4)\n    y0 = H0.flatten()\n    \n    if s_final  0:\n        # Tighter tolerances for better accuracy as requested.\n        sol = solve_ivp(\n            srg_rhs, \n            [0, s_final], \n            y0, \n            args=(T_matrix, N), \n            method='RK45', \n            rtol=1e-8, \n            atol=1e-10\n        )\n        H_final_flat = sol.y[:, -1]\n        H_final = H_final_flat.reshape((N, N))\n    else: # Evolution to s=0 means H_final is H0\n        H_final = H0\n\n    # 4. Symmetrize the result to mitigate numerical asymmetries\n    H_final = 0.5 * (H_final + H_final.T)\n    \n    # 5. Compute the decoupling metric D(lambda)\n    D_lambda = compute_decoupling_metric(H_final, p_vec, Lambda_cut)\n    \n    return D_lambda\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (momentum basis, general case)\n        {'basis': 'momentum', 'N': 10, 'p_max': 5.0, 'g': 1.0, 'Lambda_V': 2.0, 'lam': 2.0, 'Lambda': 2.0},\n        # Case 2 (harmonic-oscillator basis, general case)\n        {'basis': 'ho', 'N': 10, 'omega': 1.0, 'g': 1.0, 'Lambda_V': 2.0, 'lam': 2.0, 'Lambda': 2.0},\n        # Case 3 (momentum basis, off-diagonal emphasis)\n        {'basis': 'momentum', 'N': 12, 'p_max': 6.0, 'g': 1.0, 'Lambda_V': 2.0, 'lam': 1.5, 'Lambda': 0.0},\n        # Case 4 (harmonic-oscillator basis, off-diagonal emphasis)\n        {'basis': 'ho', 'N': 12, 'omega': 1.0, 'g': 1.0, 'Lambda_V': 2.0, 'lam': 1.5, 'Lambda': 0.0},\n        # Case 5 (momentum basis, extreme cutoff)\n        {'basis': 'momentum', 'N': 8, 'p_max': 4.0, 'g': 1.0, 'Lambda_V': 2.0, 'lam': 4.0, 'Lambda': 100.0},\n        # Case 6 (harmonic-oscillator basis, extreme cutoff)\n        {'basis': 'ho', 'N': 8, 'omega': 1.0, 'g': 1.0, 'Lambda_V': 2.0, 'lam': 4.0, 'Lambda': 100.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_srg_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3589981"}, {"introduction": "在任何复杂的计算物理研究中，对不确定性进行严格分析对于结果的可信度至关重要。这个高级练习将引导您为 SRG 演化后的可观测量建立一个全面的误差预算。您将学习如何系统地估算并组合不同的误差来源，包括由基矢截断、数值积分以及对导出多体力截断所带来的误差，从而全面评估计算的精度 [@problem_id:3589919]。", "problem": "您的任务是为相似性重整化群 (SRG) 演化的束缚能代理 $E_A(\\lambda)$ 构建一个全面的数值误差预算，其中 $A$ 表示核子数，$\\lambda$ 是 SRG 分辨尺度。该计算设定必须是自洽且纯数学的，但同时要与计算核物理中使用的核心思想保持一致。请使用以下模型和定义。\n\n基本定义：\n- 相似性重整化群 (SRG) 流根据微分方程演化一个哈密顿量 $H_s$，其流参数为 $s$\n$$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$\n其中 $[\\cdot,\\cdot]$ 表示对易子，$\\eta_s$ 是一个生成元。在本任务中，请使用动能生成元 $\\eta_s = [T, H_s]$，其中 $T$ 是一个对角的动能代理。\n- 通过 $s = \\lambda^{-4}$ 将 SRG 分辨尺度 $\\lambda$ 与流参数关联起来。在本问题中，将 $\\lambda$ 视为无量纲量，并将能量单位视为兆电子伏 (MeV)。\n- 初始哈密顿量定义为 $H_0 = T + V$，其中 $T$ 是一个对角矩阵，$V$ 是一个秩一的吸引性可分相互作用 $V = -g \\, \\mathbf{u}\\mathbf{u}^\\top$，$g$ 是一个正常数耦合常数，$\\mathbf{u}$ 是一个固定的形状向量，其分量为 $u_i = \\exp\\!\\big(-\\frac{(i-1)^2}{2\\sigma^2}\\big)$，对于 $i = 1,2,\\dots,N$，$N$ 是基矢维度。对角矩阵 $T$ 的分量为 $T_{ii} = E_0 + (i-1)\\Delta$，其中 $E_0$ 和 $\\Delta$ 是固定的正常数（所有能量单位均为 MeV）。\n- 在分辨率 $\\lambda$ 下，SRG 演化的哈密顿量 $H_\\lambda$ 是通过将流从 $s=0$ 积分到 $s=\\lambda^{-4}$ 得到的。\n\n束缚能代理：\n- 对于二体系统 ($A=2$)，将束缚能代理定义为 $H_\\lambda$ 的最低本征值：\n$$E_2(\\lambda) = \\min \\mathrm{eig}(H_\\lambda).$$\n- 对于三体系统 ($A=3$)，使用代理\n$$E_3(\\lambda) = c_3 \\, E_2(\\lambda) + \\beta \\, \\|O(H_\\lambda)\\|_F,$$\n其中 $c_3$ 和 $\\beta$ 是固定的正常数，$O(H_\\lambda)$ 表示 $H_\\lambda$ 的非对角部分（即对角元设为零的矩阵），$\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。这种构造捕捉了一个定性特征：被忽略的感生三体力与非对角耦合强度相关，而该强度在 SRG 演化下会减小。\n\n误差预算组成部分：\n- 感生多体截断 ($A2$) 误差估计：\n  保持紧凑的数值容差和大的基矢。通过在两个相近的尺度 $\\lambda_{\\mathrm{low}}$ 和 $\\lambda_{\\mathrm{high}}$ 上评估 $E_A(\\lambda)$ 来衡量其对 $\\lambda$ 的敏感性；定义\n  $$\\varepsilon_{\\mathrm{trunc}} = \\frac{1}{2}\\left|E_A(\\lambda_{\\mathrm{high}}) - E_A(\\lambda_{\\mathrm{low}})\\right|.$$\n- 常微分方程 (ODE) 积分误差估计：\n  在固定的 $\\lambda^\\star$、基矢 $N_{\\mathrm{ref}}$ 和指定的生成元选择下，用一个紧凑容差和一个宽松容差计算 $E_A(\\lambda^\\star)$，并定义\n  $$\\varepsilon_{\\mathrm{ode}} = \\left|E_A^{\\mathrm{loose}}(\\lambda^\\star) - E_A^{\\mathrm{tight}}(\\lambda^\\star)\\right|.$$\n- 基矢截断误差估计：\n  在固定的 $\\lambda^\\star$ 和紧凑容差下，比较在目标基矢维度 $N_{\\mathrm{max}}$ 和一个更大的参考基矢 $N_{\\mathrm{ref}}$ 下的结果，并定义\n  $$\\varepsilon_{\\mathrm{basis}} = \\left|E_A^{N_{\\mathrm{max}}}(\\lambda^\\star) - E_A^{N_{\\mathrm{ref}}}(\\lambda^\\star)\\right|.$$\n- 将各误差分量进行正交叠加以获得总误差：\n  $$\\varepsilon_{\\mathrm{tot}} = \\sqrt{\\varepsilon_{\\mathrm{trunc}}^2 + \\varepsilon_{\\mathrm{ode}}^2 + \\varepsilon_{\\mathrm{basis}}^2}.$$\n\n数值和物理约定：\n- 所有能量必须以兆电子伏 (MeV) 表示。\n- 所有计算均使用以下固定模型参数：$E_0 = 1.0$，$\\Delta = 2.0$，$g = 6.0$，$\\sigma = 5.0$，$c_3 = 1.5$，$\\beta = 0.05$。\n- 使用紧凑和宽松的 ODE 积分容差，分别由 $(\\mathrm{rtol}, \\mathrm{atol})_{\\mathrm{tight}} = (10^{-10}, 10^{-12})$ 和 $(\\mathrm{rtol}, \\mathrm{atol})_{\\mathrm{loose}} = (10^{-6}, 10^{-8})$ 给出。\n- 对于截断误差估计，使用一个固定窗口 $\\delta\\lambda = 0.5$，即 $\\lambda_{\\mathrm{low}} = \\lambda^\\star - \\delta\\lambda$ 和 $\\lambda_{\\mathrm{high}} = \\lambda^\\star + \\delta\\lambda$，且 $\\lambda_{\\mathrm{low}}$ 必须严格为正。\n- 对于基矢截断比较，使用 $N_{\\mathrm{ref}} = 32$ 和每个测试用例指定的 $N_{\\mathrm{max}}$。\n\n测试套件：\n为以下参数集计算误差预算，每个参数集指定为 $(A, \\lambda^\\star, N_{\\mathrm{max}})$：\n- 用例 1：$(3, 2.0, 16)$\n- 用例 2：$(3, 1.5, 8)$\n- 用例 3：$(2, 2.5, 16)$\n- 用例 4：$(3, 3.0, 24)$\n\n对于每个用例，您必须输出列表 $[\\varepsilon_{\\mathrm{tot}}, \\varepsilon_{\\mathrm{trunc}}, \\varepsilon_{\\mathrm{ode}}, \\varepsilon_{\\mathrm{basis}}]$，单位为 MeV，并四舍五入到六位小数。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个与上述格式和顺序相同的子列表。例如，最终输出必须如下所示\n$$[\\,[x_1,x_2,x_3,x_4],\\,[y_1,y_2,y_3,y_4],\\,[z_1,z_2,z_3,z_4],\\,[w_1,w_2,w_3,w_4]\\,],$$\n其中每个 $x_i$、$y_i$、$z_i$ 和 $w_i$ 都是以 MeV 为单位且保留六位小数的浮点数。", "solution": "用户提供了一个有效且适定的问题，要求为相似性重整化群 (SRG) 演化的束缚能代理构建数值误差预算。该问题在科学上基于计算核物理的方法，提供了一个自洽的模型哈密顿量以及待计算量的明确定义。任务是数值上实现 SRG 演化，计算指定的能量代理，并将其组合以估计各种数值误差源。\n\n解决方案将遵循基于原理的设计进行开发，从基础物理和数学出发，然后详细说明计算算法。\n\n**1. 基本原理：相似性重整化群**\n\n问题的核心在于量子力学哈密顿量 H 的相似性重整化群 (SRG) 演化。该演化由哈密顿量 $H_s$ 作为流参数 $s \\ge 0$ 的函数的微分方程描述：\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n其中 $[\\cdot, \\cdot]$ 是对易子，$\\eta_s$ 是流的生成元。初始条件是裸哈密顿量 $H_{s=0} = H_0$。此流构成一个幺正变换 $H_s = U_s H_0 U_s^\\dagger$，它保持哈密顿量的本征谱不变。\n\n选择生成元是为了实现一个特定目标。在本问题中，生成元是 $\\eta_s = [T, H_s]$，其中 $T$ 是动能算符。这个被称为 Wegner 生成元的特定选择，会驱动哈密顿量在 $T$ 的本征基中趋向于带状对角形式。在这种情况下，SRG 的主要目的是实现低能（低动量）态与高能（高动量）态的解耦。\n\n流参数 $s$ 通过 $s = \\lambda^{-4}$ 与 SRG 分辨尺度 $\\lambda$ 相关。因此，从 $s=0$ 演化到有限的 $s_{\\mathrm{final}}$ 等价于演化到一个有限的分辨尺度 $\\lambda = s_{\\mathrm{final}}^{-1/4}$。$s$ 的单位是 能量$^{-2}$，所以 $\\lambda$ 的单位是能量。问题陈述指定将 $\\lambda$ 视为无量纲，这意味着所有能量尺度都是相对于一个选定的单位来度量的，这里是兆电子伏 (MeV)。\n\n**2. 模型哈密顿量**\n\n我们在维度为 $N$ 的有限维希尔伯特空间中工作。初始哈密顿量为 $H_0 = T + V$。\n- 动能 $T$ 是一个对角矩阵，其分量为 $T_{ii} = E_0 + (i-1)\\Delta$，$i=1, \\dots, N$。这代表了离散化的动能能级，起始能量为 $E_0$，能级间距为常数 $\\Delta$。\n- 势能 $V$ 是一个秩一的吸引性可分相互作用，由 $V = -g \\, \\mathbf{u}\\mathbf{u}^\\top$ 给出，其中 $g  0$ 是一个耦合常数。向量 $\\mathbf{u}$ 定义了势的形状因子，其分量为 $u_i = \\exp\\left(-\\frac{(i-1)^2}{2\\sigma^2}\\right)$。这种高斯形状因子抑制了具有大指标差异的态之间的耦合，模拟了在动量空间中局域的势。\n\n由于 $H_0$ 是一个实对称矩阵，并且当 $H_s$ 是对称的时生成元 $\\eta_s = [T, H_s]$ 是反对称的，因此演化后的哈密顿量 $H_s$ 对所有 $s$ 都保持实对称性。\n\n**3. SRG 流方程的数值积分**\n\nSRG 流方程是关于 $H_s$ 矩阵元的一阶常微分方程组 (ODEs)。为了进行数值求解，我们可以将 $N \\times N$ 矩阵 $H_s$ 展开成一个大小为 $N^2$ 的状态向量。ODE 的右侧 $\\frac{dH_s}{ds}$ 可以使用矩阵代数计算：\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s] = (T H_s - H_s T)H_s - H_s(T H_s - H_s T)\n$$\n我们使用数值 ODE 求解器（例如 `scipy.integrate` 库中的 `solve_ivp` 函数）将该系统从 $s=0$ 积分到 $s_{\\mathrm{final}} = \\lambda^{-4}$。积分的精度由相对和绝对容差 $(\\mathrm{rtol}, \\mathrm{atol})$ 控制。\n\n**4. 束缚能代理和误差估计**\n\n一旦获得演化后的哈密顿量 $H_\\lambda$，我们就计算束缚能代理。\n- 对于二体系统 ($A=2$)，代理是基态能量：$E_2(\\lambda) = \\min \\mathrm{eig}(H_\\lambda)$。由于 $H_\\lambda$ 是对称的，其本征值是实数，我们寻找最小的一个。\n- 对于三体系统 ($A=3$)，定义了一个玩具模型代理 $E_3(\\lambda) = c_3 \\, E_2(\\lambda) + \\beta \\, \\|O(H_\\lambda)\\|_F$。此处，$O(H_\\lambda)$ 是 $H_\\lambda$ 的非对角部分，$\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。该代理模拟了这样一种思想：SRG 演化通过抑制非对角耦合，也抑制了对显式三体力的需求，而 $\\|O(H_\\lambda)\\|_F$ 的大小可作为这种抑制程度的诊断指标。\n\n问题要求一个由三个部分组成的误差预算：\n- **多体截断误差 ($\\varepsilon_{\\mathrm{trunc}}$)**：$\\varepsilon_{\\mathrm{trunc}} = \\frac{1}{2}\\left|E_A(\\lambda_{\\mathrm{high}}) - E_A(\\lambda_{\\mathrm{low}})\\right|$。这衡量了结果对 SRG 分辨尺度 $\\lambda$ 的敏感性，$\\lambda$ 的敏感性是因忽略模型中未明确包含的感生多体力而产生误差的代理。对 $\\lambda$ 的依赖性越大，表明截断误差越大。\n- **ODE 积分误差 ($\\varepsilon_{\\mathrm{ode}}$)**：$\\varepsilon_{\\mathrm{ode}} = \\left|E_A^{\\mathrm{loose}}(\\lambda^\\star) - E_A^{\\mathrm{tight}}(\\lambda^\\star)\\right|$。这通过比较使用宽松和紧凑积分容差获得的结果来量化 ODE 求解器的数值误差。\n- **基矢截断误差 ($\\varepsilon_{\\mathrm{basis}}$)**：$\\varepsilon_{\\mathrm{basis}} = \\left|E_A^{N_{\\mathrm{max}}}(\\lambda^\\star) - E_A^{N_{\\mathrm{ref}}}(\\lambda^\\star)\\right|$。这通过比较目标基矢大小 $N_{\\mathrm{max}}$ 和一个更大的、更收敛的参考基矢 $N_{\\mathrm{ref}}$ 的结果来估计由模型空间的有限维度引起的误差。\n\n总估计误差是这些分量的正交和（平方和求根）：$\\varepsilon_{\\mathrm{tot}} = \\sqrt{\\varepsilon_{\\mathrm{trunc}}^2 + \\varepsilon_{\\mathrm{ode}}^2 + \\varepsilon_{\\mathrm{basis}}^2}$。\n\n**5. 算法实现策略**\n\n对于每个测试用例 $(A, \\lambda^\\star, N_{\\mathrm{max}})$，总体算法流程如下：\n1. 定义一个核心函数 `calculate_E_A_evolved(A, lambda_val, N, tol)`，它封装了给定参数集的整个计算过程：\n    a. 为给定的基矢大小 $N$ 构建初始哈密顿量 $H_0$ 和动能矩阵 $T$。\n    b. 计算最终流参数 $s_{\\mathrm{final}} = \\lambda_{\\mathrm{val}}^{-4}$。\n    c. 使用 `scipy.integrate.solve_ivp` 以指定的容差将 SRG 流 ODE 从 $s=0$ 积分到 $s_{\\mathrm{final}}$。\n    d. 从得到的演化后的哈密顿量 $H_\\lambda$ 中，计算相应的束缚能代理 $E_A(\\lambda)$。\n2. 为了提高效率，`calculate_E_A_evolved` 的结果被备忘（缓存）。这可以防止冗余计算，因为多个误差分量需要使用相同的参数进行计算（例如，$E_A^{N_{\\mathrm{ref}}, \\mathrm{tight}}(\\lambda^\\star)$ 同时用于 $\\varepsilon_{\\mathrm{ode}}$ 和 $\\varepsilon_{\\mathrm{basis}}$）。\n3. 对于每个测试用例，通过调用带备忘录的核心函数，并使用 $\\lambda$、 $N$ 和容差的适当参数（由误差分量的定义指定）来计算所需的能量代理。\n4. 根据计算出的能量值计算 $\\varepsilon_{\\mathrm{trunc}}$、$\\varepsilon_{\\mathrm{ode}}$ 和 $\\varepsilon_{\\mathrm{basis}}$。\n5. 将它们进行正交叠加以求得 $\\varepsilon_{\\mathrm{tot}}$。\n6. 为当前测试用例存储四个误差分量，四舍五入到六位小数。\n7. 处理完所有测试用例后，将收集到的结果格式化为指定的最终输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom math import sqrt\nfrom functools import lru_cache\n\n# Define global constants and parameters from the problem statement.\nE0 = 1.0  # MeV\nDELTA = 2.0  # MeV\nG = 6.0  # MeV\nSIGMA = 5.0\nC3 = 1.5\nBETA = 0.05\nTOL_TIGHT = (1e-10, 1e-12)\nTOL_LOOSE = (1e-6, 1e-8)\nDELTA_LAMBDA = 0.5\nN_REF = 32\n\n@lru_cache(maxsize=None)\ndef get_constants_for_N(N):\n    \"\"\"Pre-calculates and caches T and H0 for a given N.\"\"\"\n    i_indices = np.arange(N)\n    T_diag = E0 + i_indices * DELTA\n    T = np.diag(T_diag)\n    u_vec = np.exp(-(i_indices**2) / (2 * SIGMA**2))\n    V = -G * np.outer(u_vec, u_vec)\n    H0 = T + V\n    return T, H0\n\ndef srg_flow(s, H_flat, N, T):\n    \"\"\"\n    Defines the right-hand side of the SRG flow ODE.\n    dH/ds = [[T, H], H]\n    \"\"\"\n    H = H_flat.reshape((N, N))\n    eta = T @ H - H @ T\n    dHds = eta @ H - H @ eta\n    return dHds.flatten()\n\ndef get_E_A(H, A):\n    \"\"\"\n    Calculates the binding-energy proxy E_A from a given Hamiltonian H.\n    \"\"\"\n    # E_2(lambda) is the lowest eigenvalue of H_lambda.\n    # The Hamiltonian remains real-symmetric, so we can use eigh.\n    eigenvalues = np.linalg.eigh(H)[0]\n    E2 = np.min(eigenvalues)\n\n    if A == 2:\n        return E2\n    elif A == 3:\n        # E_3(lambda) = c_3 * E_2(lambda) + beta * ||O(H_lambda)||_F\n        O_H = H - np.diag(np.diag(H))\n        norm_O_H = np.linalg.norm(O_H, 'fro')\n        E3 = C3 * E2 + BETA * norm_O_H\n        return E3\n    else:\n        raise ValueError(\"Nucleon number A must be 2 or 3.\")\n\n@lru_cache(maxsize=None)\ndef calculate_E_A_evolved(A, lambda_val, N, tol):\n    \"\"\"\n    Calculates the SRG-evolved energy proxy E_A(lambda) for a given\n    nucleon number A, resolution scale lambda, basis size N, and ODE tolerance.\n    \"\"\"\n    T, H0 = get_constants_for_N(N)\n    \n    # s = lambda^{-4}\n    if lambda_val = 0:\n        raise ValueError(\"Lambda must be positive.\")\n    s_final = lambda_val**-4\n\n    sol = solve_ivp(\n        srg_flow,\n        [0, s_final],\n        H0.flatten(),\n        method='RK45',\n        args=(N, T),\n        rtol=tol[0],\n        atol=tol[1]\n    )\n\n    H_final = sol.y[:, -1].reshape((N, N))\n    return get_E_A(H_final, A)\n\ndef solve():\n    \"\"\"\n    Main function to execute the error budget calculation for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A, lambda_star, N_max)\n        (3, 2.0, 16),\n        (3, 1.5, 8),\n        (2, 2.5, 16),\n        (3, 3.0, 24),\n    ]\n\n    all_results = []\n    for A, lambda_star, N_max in test_cases:\n        # Define lambda values for truncation error calculation\n        lambda_low = lambda_star - DELTA_LAMBDA\n        lambda_high = lambda_star + DELTA_LAMBDA\n\n        # 1. Calculate induced many-body truncation error (eps_trunc)\n        # Use large basis N_ref and tight tolerances.\n        if A > 2:\n            E_high = calculate_E_A_evolved(A, lambda_high, N_REF, TOL_TIGHT)\n            E_low = calculate_E_A_evolved(A, lambda_low, N_REF, TOL_TIGHT)\n            eps_trunc = 0.5 * abs(E_high - E_low)\n        else: # No truncation error for A=2 proxy\n            eps_trunc = 0.0\n\n        # 2. Calculate ODE integration error (eps_ode)\n        # Fix lambda and basis (N_ref), vary tolerance.\n        E_tight_ref = calculate_E_A_evolved(A, lambda_star, N_REF, TOL_TIGHT)\n        E_loose_ref = calculate_E_A_evolved(A, lambda_star, N_REF, TOL_LOOSE)\n        eps_ode = abs(E_loose_ref - E_tight_ref)\n\n        # 3. Calculate basis truncation error (eps_basis)\n        # Fix lambda and tolerance, vary basis size.\n        E_tight_max = calculate_E_A_evolved(A, lambda_star, N_max, TOL_TIGHT)\n        # E_tight_ref is already cached from the eps_ode calculation.\n        eps_basis = abs(E_tight_max - E_tight_ref)\n\n        # 4. Calculate total error (eps_tot)\n        eps_tot = sqrt(eps_trunc**2 + eps_ode**2 + eps_basis**2)\n\n        case_results = [eps_tot, eps_trunc, eps_ode, eps_basis]\n        all_results.append(case_results)\n\n    # Format output string as a list of lists with numbers rounded to 6 decimal places.\n    sublist_strs = []\n    for res in all_results:\n        num_strs = [f\"{v:.6f}\" for v in res]\n        sublist_strs.append(f\"[{','.join(num_strs)}]\")\n    final_output = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3589919"}]}