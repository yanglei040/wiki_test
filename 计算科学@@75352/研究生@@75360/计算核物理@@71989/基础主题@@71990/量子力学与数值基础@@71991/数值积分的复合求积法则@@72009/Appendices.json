{"hands_on_practices": [{"introduction": "这项实践旨在将一种基础数值方法——复合辛普森法则——应用于核物理学中的一个实际问题：计算反应率。这个练习的核心是近似一个定义在无限域上的积分，这包含两个截然不同的步骤：截断积分域，从而引入*截断误差*；以及用求积法则近似剩余的定积分，从而引入*离散误差*。通过计算精确的解析解，本练习提供了一个独特的机会来量化和区分这两种基本的误差来源，这是计算科学中的一项关键技能。[@problem_id:3550859]", "problem": "考虑一个非相对论性的中子诱发反应率，其定义为微观截面、粒子速率和能量概率密度的乘积在能量空间上的期望值。令反应率为标量 $\\lambda$，由以下瑕积分给出\n$$\n\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE,\n$$\n其中 $E$ 是动能，$\\sigma(E)$ 是能量依赖的微观截面，$v(E)$ 是速率作为能量的函数，而 $\\phi_E(E;T)$ 是在绝对温度 $T$ 下的气体所对应的归一化 Maxwell–Boltzmann 能量概率密度。使用以下经过充分检验的物理定义作为基础：\n1. 非相对论性动能-速率关系 $E=\\tfrac{1}{2}m v^2$，其中 $m$ 是中子质量，这意味着 $v(E)=\\sqrt{2E/m}$。\n2. 三维空间中归一化的 Maxwell–Boltzmann 能量分布（能量上的概率密度），\n$$\n\\phi_E(E;T)=\\frac{2}{\\sqrt{\\pi}}\\frac{1}{(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)},\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度。\n3. 一个在 $[0,\\infty)$ 上光滑的参数化截面模型，\n$$\n\\sigma(E)=\\sigma_0+\\sigma_1 E+\\sigma_2 E^2,\n$$\n其中固定参数 $\\sigma_0$、$\\sigma_1$ 和 $\\sigma_2$ 的选择在物理上是合理的，并且在数值上是良态的。\n\n在计算核物理学中，人们通常将积分上限 $\\infty$ 替换为一个有限的截断能量 $E_{\\max}$，以获得一个可以通过复合求积法进行数值计算的截断积分。你的任务是，在 $[0,E_{\\max}]$ 上实现具有偶数个区间 $N$ 的复合辛普森法则，以近似计算\n$$\n\\lambda_{\\text{Simpson}}(E_{\\max},N)\\approx\\int_{0}^{E_{\\max}}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE,\n$$\n并为每个测试案例分别量化截断误差和离散化误差，其定义如下\n$$\n\\varepsilon_{\\text{trunc}}=\\left|\\lambda-\\lambda_{\\text{trunc}}(E_{\\max})\\right|,\\quad\n\\varepsilon_{\\text{disc}}=\\left|\\lambda_{\\text{Simpson}}(E_{\\max},N)-\\lambda_{\\text{trunc}}(E_{\\max})\\right|,\n$$\n其中 $\\lambda_{\\text{trunc}}(E_{\\max})=\\int_{0}^{E_{\\max}}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE$ 是截断积分，而 $\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE$ 是真实反应率。你必须根据给定的基本定义，从第一性原理出发计算 $\\lambda$ 和 $\\lambda_{\\text{trunc}}(E_{\\max})$，而不能对这两个量使用数值求积。所有积分必须用所提供的模型和物理常数来表示和计算。\n\n在国际单位制（SI）中使用以下固定常数：\n- 中子质量 $m=1.67492749804\\times 10^{-27}\\,\\mathrm{kg}$。\n- 玻尔兹曼常数 $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n- 截面参数 $\\sigma_0=1.0\\times 10^{-28}\\,\\mathrm{m^2}$，$\\sigma_1=5.0\\times 10^{-49}\\,\\mathrm{m^2/J}$，$\\sigma_2=2.0\\times 10^{-69}\\,\\mathrm{m^2/J^2}$。\n\n构建一个覆盖不同数值区域的测试套件。对于每个测试案例，指定一个元组 $(T,\\alpha,N)$，其中 $T$ 是绝对温度，$N$ 是复合辛普森法则的偶数区间数，且 $E_{\\max}=\\alpha\\,k_{\\mathrm{B}}T$。使用以下测试套件：\n- 案例 1：$(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;5.0,\\;N=\\;100)$。\n- 案例 2：$(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;1.0,\\;N=\\;100)$。\n- 案例 3：$(T=\\;600\\,\\mathrm{K},\\;\\alpha=\\;5.0,\\;N=\\;2)$。\n- 案例 4：$(T=\\;3000\\,\\mathrm{K},\\;\\alpha=\\;2.0,\\;N=\\;50)$。\n- 案例 5：$(T=\\;300\\,\\mathrm{K},\\;\\alpha=\\;0.1,\\;N=\\;20)$。\n\n对于每个测试案例，你的程序必须计算并返回一个四元组\n$$\n\\left[\\lambda,\\ \\lambda_{\\text{Simpson}}(E_{\\max},N),\\ \\varepsilon_{\\text{trunc}},\\ \\varepsilon_{\\text{disc}}\\right],\n$$\n其中所有四个量都以 $\\mathrm{m^3/s}$ 为单位，表示为实数值。本问题不涉及角度。最终输出必须将五个测试案例的结果聚合为单行，包含一个由这些四元组组成的逗号分隔列表，并用方括号括起来，例如\n$$\n\\left[\\,[a_1,b_1,c_1,d_1],\\,[a_2,b_2,c_2,d_2],\\,[a_3,b_3,c_3,d_3],\\,[a_4,b_4,c_4,d_4],\\,[a_5,b_5,c_5,d_5]\\,\\right],\n$$\n并且必须精确地作为单行打印。所有数值答案的单位必须是 $\\mathrm{m^3/s}$。", "solution": "此问题经评估有效。它在科学上基于非相对论性统计力学和核反应理论的原理，在数学上是适定的、客观的且自洽的。所有提供的物理模型、常数和定义都是标准且一致的。该任务是计算物理学中一个明确定义的练习，需要进行解析推导和数值实现。\n\n主要目标是计算中子诱发反应率 $\\lambda$，其由以下积分定义：\n$$\n\\lambda=\\int_{0}^{\\infty}\\sigma(E)\\,v(E)\\,\\phi_E(E;T)\\,dE\n$$\n我们还将计算其截断近似和数值近似，以及相关的误差。\n\n首先，我们通过代入给定的表达式来构建被积函数 $f(E) = \\sigma(E)\\,v(E)\\,\\phi_E(E;T)$：\n1. 截面：$\\sigma(E)=\\sigma_0+\\sigma_1 E+\\sigma_2 E^2$\n2. 速率：$v(E)=\\sqrt{2E/m}$\n3. Maxwell-Boltzmann 能量密度：$\\phi_E(E;T)=\\frac{2}{\\sqrt{\\pi}}\\frac{1}{(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)}$\n\n合并这些项后，被积函数 $f(E)$ 变为：\n$$\nf(E) = (\\sigma_0+\\sigma_1 E+\\sigma_2 E^2) \\left(\\sqrt{\\frac{2E}{m}}\\right) \\left(\\frac{2}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}\\sqrt{E}\\,e^{-E/(k_{\\mathrm{B}}T)}\\right)\n$$\n通过合并 $\\sqrt{E}$ 项来简化此表达式：\n$$\nf(E) = \\frac{2\\sqrt{2}}{\\sqrt{m\\pi}(k_{\\mathrm{B}}T)^{3/2}} (\\sigma_0+\\sigma_1 E+\\sigma_2 E^2) E e^{-E/(k_{\\mathrm{B}}T)}\n$$\n我们定义一个常数前置因子 $C_T = \\frac{2\\sqrt{2/m}}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}}$。被积函数可以写作：\n$$\nf(E) = C_T (\\sigma_0 E + \\sigma_1 E^2 + \\sigma_2 E^3) e^{-E/(k_{\\mathrm{B}}T)}\n$$\n\n**1. 真实反应率 $\\lambda$ 的解析计算**\n\n为了求得真实反应率 $\\lambda$，我们必须将 $f(E)$ 从 $0$ 积分到 $\\infty$。\n$$\n\\lambda = \\int_0^\\infty f(E) dE = C_T \\int_0^\\infty (\\sigma_0 E + \\sigma_1 E^2 + \\sigma_2 E^3) e^{-E/(k_{\\mathrm{B}}T)} dE\n$$\n这需要求解形如 $\\int_0^\\infty E^n e^{-aE} dE$ 的积分，其中 $a=1/(k_{\\mathrm{B}}T)$。这是一个与伽马函数 $\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt$ 相关的标准积分。使用换元法 $t=aE$，我们得到：\n$$\n\\int_0^\\infty E^n e^{-aE} dE = \\frac{1}{a^{n+1}} \\int_0^\\infty t^n e^{-t} dt = \\frac{\\Gamma(n+1)}{a^{n+1}} = \\frac{n!}{a^{n+1}}\n$$\n将此结果应用于我们积分的每一项，其中 $a=1/(k_{\\mathrm{B}}T)$：\n- $\\int_0^\\infty E^1 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{1!}{(1/k_{\\mathrm{B}}T)^2} = (k_{\\mathrm{B}}T)^2$\n- $\\int_0^\\infty E^2 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{2!}{(1/k_{\\mathrm{B}}T)^3} = 2(k_{\\mathrm{B}}T)^3$\n- $\\int_0^\\infty E^3 e^{-E/(k_{\\mathrm{B}}T)} dE = \\frac{3!}{(1/k_{\\mathrm{B}}T)^4} = 6(k_{\\mathrm{B}}T)^4$\n\n将这些结果代回 $\\lambda$ 的表达式中：\n$$\n\\lambda = C_T \\left[ \\sigma_0(k_{\\mathrm{B}}T)^2 + \\sigma_1(2(k_{\\mathrm{B}}T)^3) + \\sigma_2(6(k_{\\mathrm{B}}T)^4) \\right]\n$$\n$$\n\\lambda = \\frac{2\\sqrt{2/m}}{\\sqrt{\\pi}(k_{\\mathrm{B}}T)^{3/2}} (k_{\\mathrm{B}}T)^2 \\left[ \\sigma_0 + 2\\sigma_1(k_{\\mathrm{B}}T) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 \\right]\n$$\n$$\n\\lambda = \\frac{2\\sqrt{2k_{\\mathrm{B}}T/m}}{\\sqrt{\\pi}} \\left[ \\sigma_0 + 2\\sigma_1(k_{\\mathrm{B}}T) + 6\\sigma_2(k_{\\mathrm{B}}T)^2 \\right]\n$$\n这就是真实反应率 $\\lambda$ 的解析公式。\n\n**2. 截断反应率 $\\lambda_{\\text{trunc}}(E_{\\max})$ 的解析计算**\n\n截断率 $\\lambda_{\\text{trunc}}$ 是 $f(E)$ 从 $0$ 到有限截断能量 $E_{\\max} = \\alpha k_{\\mathrm{B}}T$ 的积分。\n$$\n\\lambda_{\\text{trunc}} = \\int_0^{E_{\\max}} f(E) dE\n$$\n这涉及到形如 $\\int_0^{E_{\\max}} E^n e^{-aE} dE$ 的积分，其与下不完全伽马函数 $\\gamma(s, x) = \\int_0^x t^{s-1} e^{-t} dt$ 相关。通过换元 $t=aE$，其中 $a=1/(k_{\\mathrm{B}}T)$，积分上限变为 $x=aE_{\\max} = \\frac{1}{k_{\\mathrm{B}}T}(\\alpha k_{\\mathrm{B}}T) = \\alpha$。\n$$\n\\int_0^{E_{\\max}} E^n e^{-aE} dE = \\frac{1}{a^{n+1}} \\int_0^{\\alpha} t^n e^{-t} dt = \\frac{\\gamma(n+1, \\alpha)}{a^{n+1}} = (k_{\\mathrm{B}}T)^{n+1} \\gamma(n+1, \\alpha)\n$$\n将此应用于 $\\lambda_{\\text{trunc}}$ 的积分项：\n$$\n\\lambda_{\\text{trunc}} = C_T \\left[ \\sigma_0(k_{\\mathrm{B}}T)^2 \\gamma(2, \\alpha) + \\sigma_1(k_{\\mathrm{B}}T)^3 \\gamma(3, \\alpha) + \\sigma_2(k_{\\mathrm{B}}T)^4 \\gamma(4, \\alpha) \\right]\n$$\n$$\n\\lambda_{\\text{trunc}} = \\frac{2\\sqrt{2k_{\\mathrm{B}}T/m}}{\\sqrt{\\pi}} \\left[ \\sigma_0 \\frac{\\gamma(2, \\alpha)}{1!} + \\sigma_1 (k_{\\mathrm{B}}T) \\frac{\\gamma(3, \\alpha)}{2!} + \\sigma_2 (k_{\\mathrm{B}}T)^2 \\frac{\\gamma(4, \\alpha)}{3!} \\right]\n$$\n引入因子 $n!$ 是为了展示其与正则化不完全伽马函数 $P(s,x) = \\gamma(s,x)/\\Gamma(s)$ 的联系，后者通常在科学计算库中实现。由于 $\\Gamma(n+1)=n!$，我们有 $\\gamma(n+1,\\alpha) = n!P(n+1, \\alpha)$。函数 $\\gamma(s,x)$ 可以使用标准库函数（例如 `scipy.special.gammainc` 和 `scipy.special.gamma`）来计算。\n\n**3. 通过复合辛普森法则进行数值计算, $\\lambda_{\\text{Simpson}}(E_{\\max},N)$**\n\n复合辛普森法则用于近似计算在偶数个区间 $N$ 上的定积分 $\\int_a^b g(x) dx$。区间 $[a, b]$ 被划分为 $N$ 个宽度为 $h=(b-a)/N$ 的子区间。其公式为：\n$$\n\\int_a^b g(x) dx \\approx \\frac{h}{3} \\left[ g(x_0) + 4\\sum_{i=1, i\\text{ odd}}^{N-1} g(x_i) + 2\\sum_{i=2, i\\text{ even}}^{N-2} g(x_i) + g(x_N) \\right]\n$$\n其中 $x_i = a+ih$。在我们的问题中，积分是针对 $\\lambda_{\\text{trunc}}(E_{\\max}, N)$ 的，因此 $g(E) = f(E)$，$a=0$，且 $b=E_{\\max}$。步长为 $h=E_{\\max}/N$。\n实现时将在 $N+1$ 个网格点 $E_i = i h$（$i=0, \\dots, N$）上计算被积函数 $f(E)$，并根据上述公式应用加权和。注意 $f(0)=0$。\n\n**4. 误差量化**\n\n两种误差来源定义如下：\n- 截断误差：$\\varepsilon_{\\text{trunc}} = \\left|\\lambda-\\lambda_{\\text{trunc}}(E_{\\max})\\right|$。此误差源于将无限积分上限替换为有限的截断值 $E_{\\max}$。\n- 离散化误差：$\\varepsilon_{\\text{disc}} = \\left|\\lambda_{\\text{Simpson}}(E_{\\max},N)-\\lambda_{\\text{trunc}}(E_{\\max})\\right|$。此误差源于使用数值求积法则来近似计算在 $[0, E_{\\max}]$ 上的定积分。\n\n将使用推导出的解析公式和辛普森法则的数值实现，为每个测试案例计算这些量。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\ndef solve():\n    \"\"\"\n    Computes neutron-induced reaction rates and associated errors for\n    a set of test cases using analytical and numerical methods.\n    \"\"\"\n    \n    # Fixed constants in SI units\n    M_N = 1.67492749804e-27  # Neutron mass (kg)\n    K_B = 1.380649e-23         # Boltzmann constant (J/K)\n    SIGMA_0 = 1.0e-28          # Cross section parameter (m^2)\n    SIGMA_1 = 5.0e-49          # Cross section parameter (m^2/J)\n    SIGMA_2 = 2.0e-69          # Cross section parameter (m^2/J^2)\n\n    # Test suite: (T in Kelvin, alpha, N panels)\n    test_cases = [\n        (600.0, 5.0, 100),\n        (600.0, 1.0, 100),\n        (600.0, 5.0, 2),\n        (3000.0, 2.0, 50),\n        (300.0, 0.1, 20),\n    ]\n\n    all_results = []\n\n    for T, alpha, N in test_cases:\n        # Characteristic energy\n        kT = K_B * T\n        \n        # --- Analytical Calculation of the True Reaction Rate (lambda) ---\n        # lambda = (2 * sqrt(2*kT/m) / sqrt(pi)) * [s0 + 2*s1*kT + 6*s2*kT^2]\n        \n        common_factor = (2.0 * np.sqrt(2.0 * kT / M_N)) / np.sqrt(np.pi)\n        poly_full = SIGMA_0 + 2.0 * SIGMA_1 * kT + 6.0 * SIGMA_2 * kT**2\n        lambda_true = common_factor * poly_full\n\n        # --- Analytical Calculation of the Truncated Rate (lambda_trunc) ---\n        # The true rate is composed of terms like:\n        # term_n = C_factor * sigma_n * (n+1)! * (kT)^(n+2)\n        # The truncated rate is term_n * P(n+2, alpha), where P is regularized inc. gamma.\n        # This simplifies to the following expression.\n        \n        lambda_trunc = common_factor * (\n            SIGMA_0 * gammainc(2, alpha) +\n            2 * SIGMA_1 * kT * gammainc(3, alpha) +\n            6 * SIGMA_2 * kT**2 * gammainc(4, alpha)\n        )\n        \n        # --- Numerical Calculation using Composite Simpson's Rule (lambda_simpson) ---\n        E_max = alpha * kT\n\n        # Define the integrand f(E) = sigma(E) * v(E) * phi_E(E)\n        # Simplified form: f(E) = c_T * (s0*E + s1*E^2 + s2*E^3) * exp(-E/kT)\n        c_T = (2.0 * np.sqrt(2.0 / M_N)) / (np.sqrt(np.pi) * kT**1.5)\n        \n        def integrand(E_vals):\n            # Vectorized integrand evaluation\n            # Handle E=0 case to avoid 0*inf from 1/sqrt(E) if original form used.\n            # The simplified form with E as factor is 0 at E=0.\n            if isinstance(E_vals, (int, float)):\n                if E_vals == 0: return 0.0\n            \n            poly_E = SIGMA_0 * E_vals + SIGMA_1 * E_vals**2 + SIGMA_2 * E_vals**3\n            return c_T * poly_E * np.exp(-E_vals / kT)\n\n        E_points = np.linspace(0, E_max, N + 1)\n        y_points = integrand(E_points)\n        \n        h = E_max / N\n        lambda_simpson = (h / 3.0) * (\n            y_points[0] + \n            4.0 * np.sum(y_points[1:-1:2]) + \n            2.0 * np.sum(y_points[2:-1:2]) + \n            y_points[-1]\n        )\n\n        # --- Error Calculation ---\n        eps_trunc = np.abs(lambda_true - lambda_trunc)\n        eps_disc = np.abs(lambda_simpson - lambda_trunc)\n\n        all_results.append([lambda_true, lambda_simpson, eps_trunc, eps_disc])\n    \n    # Format the final output string exactly as specified.\n    # e.g., [[a1,b1,c1,d1],[a2,b2,c2,d2],...]\n    formatted_quads = [f\"[{','.join(map(str, quad))}]\" for quad in all_results]\n    final_output_string = f\"[{','.join(formatted_quads)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3550859"}, {"introduction": "虽然标准求积法则对光滑函数效果很好，但它们难以处理具有奇性的被积函数。本问题探讨了一种常见情况，即积分区间端点处存在代数奇性，这在能量阈值附近的反应截面中经常出现。我们不直接应用更复杂的求积法则，而是采用一种坐标变换，即*分级网格*，来进行变量替换。一个精心选择的变换可以“展开”奇点，使得变换后坐标系中的新被积函数变得光滑且性质良好。这项理论练习展示了如何运用解析洞察力来预处理一个困难的积分，从而让诸如梯形法则这类简单高效的数值方法能够恢复其高阶精度。[@problem_id:3550921]", "problem": "在计算核物理中，反应率积分通常涉及能量相关的核截面，这些截面在阈值附近表现出代数端点奇点。考虑对热中子吸收率进行确定性评估\n$$\nI \\;=\\; \\int_{a}^{b} \\sigma(x)\\,\\phi(x)\\,dx,\n$$\n其中，$x$ 表示动能，$a$ 是一个阈能（$a \\geq 0$），$b > a$ 是一个有限上界，$\\phi(x)$ 是一个光滑有界的中子通量，且截面在阈值附近的行为如下\n$$\n\\sigma(x) \\;\\sim\\; C\\,(x-a)^{-\\alpha} \\quad \\text{as } x \\to a^{+},\n$$\n对于某个常数 $C>0$ 和 $0 < \\alpha < 1$。该端点奇点是可积的，但会降低等步长求积法则的性能。为了解决这个问题，采用由以下映射定义的分级网格\n$$\nx(t) \\;=\\; a + (b-a)\\,t^{p}, \\qquad t \\in [0,1], \\qquad p>0,\n$$\n并在变量 $t$ 的 $[0,1]$ 区间上应用具有 $N$ 个等长子区间的复化梯形法则来近似 $I$。\n\n从积分的换元公式和单个区间上梯形法则的泰勒展开余项出发，通过分析变换后被积函数在 $t=0$ 附近的正则性以及在 $N$ 个区间上产生的全局误差累积，来证明使用分级网格的合理性。然后，确定分级指数 $p$（作为 $\\alpha$ 的函数）的显式选择，该选择能够恢复复化梯形法则的标称二阶全局收敛率，即当 $N \\to \\infty$ 时，误差行为类似于 $\\mathcal{O}(N^{-2})$。\n\n将 $p$ 的最终答案表示为单个闭式解析表达式。无需进行数值四舍五入。", "solution": "带有端点奇点的积分可以通过分级映射 $x(t) = a + (b-a)\\,t^{p}$（其中 $t \\in [0,1]$ 且 $p>0$）进行变换。根据换元公式，\n$$\nI \\;=\\; \\int_{0}^{1} f(x(t))\\,x'(t)\\,dt,\n$$\n其中 $f(x) = \\sigma(x)\\,\\phi(x)$ 且\n$$\nx'(t) \\;=\\; p\\,(b-a)\\,t^{p-1}.\n$$\n在 $x=a$ 附近，我们有 $f(x) \\sim C\\,(x-a)^{-\\alpha}\\,\\phi(x)$，并且由于 $\\phi(x)$ 是光滑有界的，其在 $x=a$ 附近的行为不会引入额外的奇点。使用 $x-a = (b-a)\\,t^{p}$，变换后的被积函数变为\n$$\ng(t) \\;=\\; f(x(t))\\,x'(t) \\;\\sim\\; \\big(C\\,(b-a)^{-\\alpha}\\,t^{-\\alpha p}\\big)\\,\\big(p\\,(b-a)\\,t^{p-1}\\big)\n\\;=\\; C\\,p\\,(b-a)^{1-\\alpha}\\,t^{p(1-\\alpha)-1}.\n$$\n定义 $\\beta := p\\,(1-\\alpha)$。那么，在 $t=0$ 附近，\n$$\ng(t) \\;\\sim\\; K\\,t^{\\beta-1}, \\qquad K := C\\,p\\,(b-a)^{1-\\alpha}.\n$$\n\n我们现在分析将复化梯形法则应用于 $g(t)$ 的情况，其中 $[0,1]$ 区间被均匀划分为 $N$ 个长度为 $h=1/N$ 的等长子区间。对于一个足够光滑的函数，在单个区间 $[t_{i-1}, t_i]$（其中 $t_i = i\\,h$）上的局部截断误差由带余项的泰勒定理给出：\n$$\n\\varepsilon_{i} \\;=\\; -\\frac{h^{3}}{12}\\,g''(\\xi_{i}),\n$$\n对于某个 $\\xi_{i}\\in(t_{i-1},t_{i})$。尽管 $g$ 在 $t=0$ 处不是全局二阶连续可微的，我们仍然可以通过分析 $g''(t)$ 在 $t=0$ 附近的奇异行为来估计误差。对主阶行为 $g(t)\\sim K\\,t^{\\beta-1}$ 求导可得\n$$\ng'(t) \\;\\sim\\; K\\,(\\beta-1)\\,t^{\\beta-2}, \\qquad\ng''(t) \\;\\sim\\; K\\,(\\beta-1)\\,(\\beta-2)\\,t^{\\beta-3}.\n$$\n因此，对于 $i=1,2,\\dots,N$，在主阶意义下有 $\\xi_{i}\\approx t_{i}\\approx i/N$，局部误差遵循\n$$\n|\\varepsilon_{i}| \\;\\approx\\; \\frac{h^{3}}{12}\\,\\big|g''(\\xi_{i})\\big|\n\\;\\lesssim\\; C_{1}\\,N^{-3}\\,\\left(\\frac{i}{N}\\right)^{\\beta-3}\n\\;=\\; C_{1}\\,N^{-\\beta}\\,i^{\\beta-3},\n$$\n对于某个正常数 $C_1 > 0$，它吸收了 $K$ 和因子 $(\\beta-1)(\\beta-2)$。\n\n将局部误差求和，全局误差的大小（在量级上）有界于\n$$\n|E_{N}| \\;\\lesssim\\; C_{1}\\,N^{-\\beta}\\,\\sum_{i=1}^{N} i^{\\beta-3}.\n$$\n我们使用幂和的标准渐近性来估计该和。令 $\\gamma := \\beta-3$。那么\n- 如果 $\\gamma>-1$（即 $\\beta>2$），则 $\\sum_{i=1}^{N} i^{\\gamma} \\sim \\frac{N^{\\gamma+1}}{\\gamma+1}$，因此\n$$\n|E_{N}| \\;\\lesssim\\; C_{2}\\,N^{-\\beta}\\,N^{\\beta-2} \\;=\\; C_{2}\\,N^{-2},\n$$\n对于某个常数 $C_2>0$。\n- 如果 $\\gamma=-1$（即 $\\beta=2$），则 $\\sum_{i=1}^{N} i^{-1} \\sim \\ln N$，因此\n$$\n|E_{N}| \\;\\lesssim\\; C_{3}\\,N^{-2}\\,\\ln N,\n$$\n对于某个常数 $C_3>0$。\n- 如果 $\\gamma<-1$（即 $\\beta<2$），则 $\\sum_{i=1}^{N} i^{\\gamma}$ 关于 $N$ 一致有界，因此\n$$\n|E_{N}| \\;\\lesssim\\; C_{4}\\,N^{-\\beta},\n$$\n对于某个常数 $C_4>0$。\n\n因此，在分级网格上，变换后的复化梯形法则达到以下全局误差率\n$$\n|E_{N}| \\;=\\; \\mathcal{O}\\!\\left(N^{-\\min\\{2,\\,\\beta\\}}\\right),\n$$\n当 $\\beta=2$ 时带有一个对数因子。为了恢复梯形法则在二阶连续可微函数上所具有的标称二阶全局收敛率 $\\mathcal{O}(N^{-2})$，我们需要 $\\beta \\ge 2$。要避免对数因子并确保严格的 $\\mathcal{O}(N^{-2})$ 收敛，需要 $\\beta > 2$。然而，恢复标称阶数的阈值选择是\n$$\np\\,(1-\\alpha) \\;=\\; 2.\n$$\n这给出了\n$$\np \\;=\\; \\frac{2}{1-\\alpha}.\n$$\n在实践中，任何选择 $p \\ge \\frac{2}{1-\\alpha}$ 都可以确保至少 $\\mathcal{O}(N^{-2})$ 的收敛（可能带对数因子），而 $p=\\frac{2}{1-\\alpha}$ 确定了在变换后的设置中恢复标称阶数的阈值分级。\n\n因此，具有指数\n$$\np \\;=\\; \\frac{2}{1-\\alpha}\n$$\n的分级网格 $x=a+(b-a)\\,t^{p}$ 证明了该方法的合理性，并确定了在存在代数端点奇点 $f(x)\\sim (x-a)^{-\\alpha}$（其中 $0 < \\alpha < 1$）的情况下，为使复化梯形法则恢复二阶全局收敛性所需的分级。", "answer": "$$\\boxed{\\frac{2}{1-\\alpha}}$$", "id": "3550921"}, {"introduction": "这最后一个实践项目处理了核物理计算中的另一大挑战：被积函数包含多个狭窄的布莱特-维格纳共振峰。如果使用均匀网格，这些尖锐的峰值需要极其密集的网格划分，这在计算上是十分浪费的。解决方案是构建一个*自适应求积*算法。该方法通过估算每个子区间的局部误差，并对其进行细分直到满足预设的容差，从而仅在函数变化剧烈的区域自动加密积分网格。通过从零开始构建一个自适应高斯-勒让德积分器，您将开发出一个强大而实用的工具，它能高效地处理复杂函数，自动平衡精度与计算成本。这代表了从静态、固定步长方法到动态、智能数值算法的重大进步。[@problem_id:3550919]", "problem": "设计并实现一种自适应复合高斯-勒让德求积方法，用于在计算核物理中计算一维能量变量下的能量加权反应率积分。需要计算的积分是\n$$\nI \\;=\\; \\int_{E_\\min}^{E_\\max} \\sigma(E)\\,\\phi(E)\\,dE,\n$$\n其中 $\\sigma(E)$ 是一个具有多个共振结构的截面，$\\phi(E)$ 是一个代表中子通量密度的能量分布。目标是构建一个复合规则，该规则能自动在窄共振峰周围聚集区间，并通过自适应细分来控制局部截断误差。\n\n使用以下基于物理原理且被广泛接受的形式：\n\n- 具有多个 Breit–Wigner (洛伦兹) 共振的截面，\n$$\n\\sigma(E) \\;=\\; \\sum_{i=1}^{N_r} A_i \\,\\frac{\\left(\\frac{\\Gamma_i}{2}\\right)^2}{(E - E_i)^2 + \\left(\\frac{\\Gamma_i}{2}\\right)^2},\n$$\n其中 $E$ 是能量，$E_i$ 是共振中心，$\\Gamma_i$ 是半高全宽，$A_i$ 是振幅。$\\sigma(E)$ 的单位为靶恩 (barns)。\n\n- 中子通量密度选择为在有限区间上的归一化的类麦克斯韦-玻尔兹曼分布，\n$$\n\\phi(E) \\;=\\; C \\, E^{1/2} \\, \\exp\\!\\left(-\\frac{E}{kT}\\right),\n$$\n其中 $kT$ 是以电子伏特为单位的热能标度，$C$ 是一个归一化常数，使得\n$$\n\\int_{E_\\min}^{E_\\max} \\phi(E)\\, dE \\;=\\; 1.\n$$\n在此归一化下，$\\phi(E)$ 的单位是逆电子伏特，积分 $I$ 的单位是靶恩。您必须通过已知的归一化积分来精确处理 $C$：\n$$\n\\int_{E_\\min}^{E_\\max} E^{1/2}\\, e^{-E/(kT)}\\, dE \\;=\\; (kT)^{3/2}\\,\\Big[\\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\min}{kT}\\right)\\Big],\n$$\n其中 $\\gamma(\\cdot,\\cdot)$ 是下不完全伽马函数。因此，\n$$\nC \\;=\\; \\left[(kT)^{3/2}\\,\\Big(\\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\tfrac{3}{2},\\tfrac{E_\\min}{kT}\\right)\\Big)\\right]^{-1}.\n$$\n\n用于推导和算法设计的基本原理：\n\n- 黎曼积分定义以及光滑的被积函数可以通过在区间上的多项式插值来近似这一事实。\n- 勒让德多项式在 $[-1,1]$ 上的正交性，以及高斯-勒让德求积的性质，即用 $n$ 个节点可以精确地对最高 $2n-1$ 次的多项式进行积分。\n- 对于足够光滑的函数，通过区间二分法来减少误差，从而能够通过单个区间积分与两个子区间积分之和的差值来获得局部误差估计。\n- 使用不完全伽马函数进行归一化以确保物理单位的一致性。\n\n您的程序必须实现：\n\n- $n$ 阶复合高斯-勒让德求积，每个区间固定使用 $n=8$ 个节点。\n- 一种自适应加密策略，基于比较在 $[a,b]$ 上的单个 $n$ 节点区间估计值与在 $[a,m]$ 和 $[m,b]$ (其中 $m=(a+b)/2$) 上的两个 $n$ 节点区间估计值之和，以获得局部误差估计量。使用一个加密准则，如果估计的局部误差 $\\varepsilon_\\text{loc}$ 满足 $\\varepsilon_\\text{loc} \\le \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_\\text{panel}|)$，则接受该区间。绝对容差 $\\tau_\\text{abs}$ 和相对容差 $\\tau_\\text{rel}$ 均设置为 $\\tau_\\text{abs}=\\tau_\\text{rel}=10^{-8}$。\n- 通过在 $E_i \\pm m\\,(\\Gamma_i/2)$ (其中 $m \\in \\{-3,-2,-1,0,1,2,3\\}$) 且位于 $[E_\\min,E_\\max]$ 内的点设置断点来作为初始划分，从而自动在窄共振峰周围聚集区间。这些断点将与端点合并并排序。随后的自适应加密将基于这些种子区间进行。\n\n不涉及角度；未使用带角度单位的三角函数。所有能量单位均为电子伏特。最终数值结果必须以靶恩为单位报告。\n\n测试套件。您的程序必须为以下四种情况计算积分 $I$，每种情况由 $\\{E_\\min,E_\\max,kT; (E_i,\\Gamma_i,A_i)_{i=1}^{N_r}\\}$ 指定：\n\n- 情况 1 (单个宽共振峰):\n  - 区间 $[E_\\min,E_\\max] = [\\,0.0,\\,10.0\\,]$ eV, $kT=1.0$ eV.\n  - 共振: $N_r=1$, $(E_1,\\Gamma_1,A_1)=(\\,3.0,\\,1.0,\\,10.0\\,)$.\n\n- 情况 2 (多个峰，包括一个非常窄的峰):\n  - 区间 $[E_\\min,E_\\max] = [\\,0.0,\\,20.0\\,]$ eV, $kT=2.0$ eV.\n  - 共振: $N_r=3$, $(E_1,\\Gamma_1,A_1)=(\\,5.0,\\,0.2,\\,80.0\\,)$, $(E_2,\\Gamma_2,A_2)=(\\,12.0,\\,1.5,\\,30.0\\,)$, $(E_3,\\Gamma_3,A_3)=(\\,8.0,\\,0.05,\\,150.0\\,)$.\n\n- 情况 3 (边界附近的窄共振峰):\n  - 区间 $[E_\\min,E_\\max] = [\\,0.0,\\,5.0\\,]$ eV, $kT=0.5$ eV.\n  - 共振: $N_r=2$, $(E_1,\\Gamma_1,A_1)=(\\,0.1,\\,0.01,\\,200.0\\,)$, $(E_2,\\Gamma_2,A_2)=(\\,4.5,\\,0.02,\\,100.0\\,)$.\n\n- 情况 4 (重叠的共振峰):\n  - 区间 $[E_\\min,E_\\max] = [\\,5.0,\\,15.0\\,]$ eV, $kT=1.5$ eV.\n  - 共振: $N_r=3$, $(E_1,\\Gamma_1,A_1)=(\\,9.5,\\,0.4,\\,70.0\\,)$, $(E_2,\\Gamma_2,A_2)=(\\,10.0,\\,0.5,\\,65.0\\,)$, $(E_3,\\Gamma_3,A_3)=(\\,10.3,\\,0.3,\\,80.0\\,)$.\n\n最终输出格式。您的程序应生成一行输出，其中包含四个积分估计值，格式为用方括号括起来的逗号分隔列表，按情况 1 到 4 的顺序排列，例如\n$[\\;I_1,I_2,I_3,I_4\\;]$,\n其中每个 $I_j$ 是一个以靶恩为单位的浮点数。不要打印单位或任何其他文本；只打印列表字面量。根据 $\\sigma(E)$ 的单位和 $\\phi(E)$ 的归一化，数值答案应以靶恩为单位。", "solution": "该问题要求设计并实现一种自适应复合高斯-勒让德求积方案，以计算能量加权反应率积分 $I = \\int_{E_\\min}^{E_\\max} \\sigma(E)\\,\\phi(E)\\,dE$。这是一个结合了物理建模和数值分析的计算物理任务。解决方法包括精确定义被积函数，构建一个稳健的数值积分算法，并根据指定的测试用例进行实现。\n\n### 1. 被积函数：反应率核\n\n被积函数是截面 $\\sigma(E)$ 和中子通量密度 $\\phi(E)$ 这两个函数的乘积。\n\n**截面 $\\sigma(E)$：** 截面被建模为 $N_r$ 个 Breit-Wigner 共振峰的总和。每个共振峰是一个洛伦兹峰，中心位于能量 $E_i$ 处，半高全宽 (FWHM) 为 $\\Gamma_i$，振幅为 $A_i$。其公式由下式给出：\n$$\n\\sigma(E) = \\sum_{i=1}^{N_r} A_i \\,\\frac{\\left(\\frac{\\Gamma_i}{2}\\right)^2}{(E - E_i)^2 + \\left(\\frac{\\Gamma_i}{2}\\right)^2}\n$$\n该函数单位为靶恩。窄共振峰 (小的 $\\Gamma_i$) 的存在会产生函数值急剧变化的尖峰，这对数值积分构成了挑战。\n\n**中子通量密度 $\\phi(E)$：** 通量由一个截断在有限能量区间 $[E_\\min, E_\\max]$ 上的类麦克斯韦-玻尔兹曼分布描述。其函数形式为：\n$$\n\\phi(E) = C \\, E^{1/2} \\, \\exp\\!\\left(-\\frac{E}{kT}\\right)\n$$\n其中 $k$ 是玻尔兹曼常数，$T$ 是温度，$kT$ 代表一个热能标度。常数 $C$ 由归一化条件 $\\int_{E_\\min}^{E_\\max} \\phi(E)\\, dE = 1$ 确定。这确保了 $\\phi(E)$ 是在指定能量范围内的概率密度函数，单位为逆能量 (例如，$\\text{eV}^{-1}$)。因此，积分 $I$ 的单位正确地为靶恩。\n\n为了求出 $C$，我们必须计算归一化积分：\n$$\n\\int_{E_\\min}^{E_\\max} E^{1/2}\\, e^{-E/(kT)}\\, dE\n$$\n使用换元法 $u = E/(kT)$，我们有 $E = u(kT)$ 和 $dE = (kT)du$。积分变换为：\n$$\n\\int_{E_{\\min}/(kT)}^{E_{\\max}/(kT)} (u kT)^{1/2}\\, e^{-u}\\, (kT)du = (kT)^{3/2} \\int_{E_{\\min}/(kT)}^{E_{\\max}/(kT)} u^{1/2}\\, e^{-u}\\, du\n$$\n该定积分可以用下不完全伽马函数 $\\gamma(s,x) = \\int_0^x t^{s-1} e^{-t} dt$ 来表示。当 $s = 3/2$ 时，积分变为：\n$$\n(kT)^{3/2} \\left[ \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\min}{kT}\\right) \\right]\n$$\n归一化常数 $C$ 是该值的倒数：\n$$\nC = \\left[ (kT)^{3/2} \\left( \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\max}{kT}\\right) - \\gamma\\!\\left(\\frac{3}{2}, \\frac{E_\\min}{kT}\\right) \\right) \\right]^{-1}\n$$\n\n### 2. 数值积分方法\n\n对于具有尖锐、局部化特征的被积函数，标准的固定区间求积规则效率低下。需要一种自适应求积方法，它能在函数变化剧烈的区域自动加密积分网格。\n\n**高斯-勒让德求积：** 基本构件是 $n$ 点高斯-勒让德求积规则。对于指定的 $n=8$，该规则将函数 $g(x)$ 在标准区间 $[-1, 1]$ 上的积分近似为一个加权和：\n$$\n\\int_{-1}^{1} g(x)\\,dx \\approx \\sum_{i=1}^{n} w_i g(x_i)\n$$\n其中 $x_i$ 是 $n$ 阶勒让德多项式 $P_n(x)$ 的根，$w_i$ 是对应的权重。该规则对于最高 $2n-1 = 15$ 次的多项式是精确的。为了将其应用于任意区间 $[a, b]$，我们使用线性变换 $E(x) = \\frac{b-a}{2}x + \\frac{a+b}{2}$：\n$$\n\\int_{a}^{b} f(E)\\,dE = \\frac{b-a}{2} \\int_{-1}^{1} f(E(x))\\,dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{b-a}{2}x_i + \\frac{a+b}{2}\\right)\n$$\n\n**自适应细分与误差估计：** 自适应算法的核心在于误差估计和区间细分。对于给定的区间 $[a, b]$，我们计算积分的两个近似值：\n1. $I_1$：使用单个 $n$ 点规则在 $[a, b]$ 上估计的积分。\n2. $I_2$：通过在 $m=(a+b)/2$ 处二分区间，并将 $n$ 点规则应用于每个子区间 $[a,m]$ 和 $[m,b]$ 的结果相加，得到的更精确的估计值。\n\n较粗糙估计 $I_1$ 的局部误差估计为 $\\varepsilon_\\text{loc} = |I_2 - I_1|$。如果此误差满足指定的容差准则，则接受该区间，并将其贡献（更精确的值 $I_2$）加到总积分中。该准则是：\n$$\n\\varepsilon_\\text{loc} \\le \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_2|)\n$$\n其中 $\\tau_\\text{abs} = 10^{-8}$ 和 $\\tau_\\text{rel} = 10^{-8}$ 分别是绝对容差和相对容差。如果未满足该准则，则拒绝区间 $[a,b]$，并将两个子区间 $[a,m]$ 和 $[m,b]$ 添加到待处理的区间列表中。\n\n**初始区间植入：** 为了提高效率，算法会植入一组初始区间，这些区间已经集中在被积函数的难点部分——即窄共振峰周围。对于每个共振 $(E_i, \\Gamma_i, A_i)$，我们生成一组断点 $E_i \\pm m(\\Gamma_i/2)$，其中 $m \\in \\{-3, -2, -1, 0, 1, 2, 3\\}$。将这些点与区间端点 $E_\\min$ 和 $E_max$ 一起收集，限制在 $(E_\\min, E_\\max)$ 范围内，去除重复项并排序。这样就创建了 $[E_\\min, E_\\max]$ 的一个初始划分，该划分在共振峰附近密集，在其他地方稀疏。然后，自适应算法对这些初始区间中的每一个进行处理。\n\n### 3. 算法实现\n\n整个算法实现如下：\n1. 对于每个测试用例，获取参数 $\\{E_\\min, E_\\max, kT\\}$ 和共振列表。\n2. 使用涉及下不完全伽马函数的公式计算通量 $\\phi(E)$ 的归一化常数 $C$，该函数由 `SciPy` 等科学计算库提供。\n3. 构建被积函数 $f(E) = \\sigma(E)\\,\\phi(E)$。\n4. 根据共振位置和宽度生成初始的排序断点列表。这定义了初始的区间集合。\n5. 将总积分初始化为 $0$。\n6. 使用一个栈 (LIFO 数据结构) 来管理自适应求积的区间。初始时，将植入划分中的所有区间推入栈中。\n7. 当栈不为空时循环：\n    a. 从栈中弹出一个区间 $[a, b]$。\n    b. 计算单区间积分 $I_1$ 和双区间积分 $I_2$。\n    c. 计算误差估计 $\\varepsilon_\\text{loc} = |I_2 - I_1|$ 和容差 $T = \\max(\\tau_\\text{abs}, \\tau_\\text{rel}\\,|I_2|)$。\n    d. 如果 $\\varepsilon_\\text{loc} \\le T$，则将 $I_2$ 加到总积分中。\n    e. 否则，将两个子区间 $[a, (a+b)/2]$ 和 $[(a+b)/2, b]$ 推入栈中。\n8. 总积分的最终值即为该测试用例的结果。对所有四个用例重复此过程。实现使用 `NumPy` 进行高效的向量化计算，使用 `SciPy` 计算特殊函数 $\\gamma(s,x)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, gammainc\n\n# Global constants from the problem\nN_NODES = 8\nTOL_ABS = 1e-8\nTOL_REL = 1e-8\nINITIAL_BREAKPOINT_M = [-3, -2, -1, 0, 1, 2, 3]\n\n# Pre-compute Gauss-Legendre nodes and weights for the base rule\nLG_NODES, LG_WEIGHTS = np.polynomial.legendre.leggauss(N_NODES)\n\ndef _sigma(E, resonances):\n    \"\"\"\n    Computes the Breit-Wigner cross section.\n    E can be a scalar or a numpy array for vectorized computation.\n    \"\"\"\n    total_sigma = np.zeros_like(E, dtype=float)\n    for E_i, Gamma_i, A_i in resonances:\n        gamma_half_sq = (Gamma_i / 2.0)**2\n        total_sigma += A_i * gamma_half_sq / ((E - E_i)**2 + gamma_half_sq)\n    return total_sigma\n\ndef _phi(E, C, kT):\n    \"\"\"\n    Computes the normalized Maxwell-Boltzmann-like flux density.\n    E can be a scalar or a numpy array.\n    \"\"\"\n    E = np.asanyarray(E)\n    phi_val = np.zeros_like(E, dtype=float)\n    # The condition E > 0 prevents incorrect values or warnings for sqrt(0) or log(0)\n    # in more complex models, and correctly evaluates phi(0) = 0.\n    mask = E > 0\n    phi_val[mask] = C * np.sqrt(E[mask]) * np.exp(-E[mask] / kT)\n    return phi_val\n\ndef _integrate_panel(f, a, b):\n    \"\"\"\n    Computes the integral of a function f over a single panel [a, b]\n    using the pre-computed n-point Gaussian-Legendre rule.\n    \"\"\"\n    h = (b - a) / 2.0\n    c = (a + b) / 2.0\n    eval_points = c + h * LG_NODES\n    f_values = f(eval_points)\n    integral = h * np.sum(LG_WEIGHTS * f_values)\n    return integral\n\ndef compute_rate_integral(params):\n    \"\"\"\n    Computes the reaction rate integral for a given set of physical parameters.\n    \"\"\"\n    E_min, E_max, kT = params['E_min'], params['E_max'], params['kT']\n    resonances = params['resonances']\n\n    # 1. Calculate normalization constant C for phi(E)\n    s = 1.5\n    # The lower incomplete gamma function is needed: gamma(s,x)\n    # scipy.special.gammainc(s, x) computes the regularized version P(s,x).\n    # gamma(s,x) = P(s,x) * Gamma(s).\n    gamma_s = gamma(s)\n    \n    if kT == 0: return 0.0\n    x_max = E_max / kT\n    x_min = E_min / kT\n    \n    if E_min >= E_max: return 0.0\n\n    term_max = gammainc(s, x_max) * gamma_s if x_max > 0 else 0.0\n    term_min = gammainc(s, x_min) * gamma_s if x_min > 0 else 0.0\n    \n    norm_integral_part = term_max - term_min\n    norm_integral = (kT**1.5) * norm_integral_part\n    \n    C = 1.0 / norm_integral if norm_integral > 1e-100 else 0.0\n\n    # 2. Define the full integrand f(E)\n    def integrand(E):\n        return _sigma(E, resonances) * _phi(E, C, kT)\n\n    # 3. Generate initial breakpoints\n    breakpoints = {E_min, E_max}\n    for E_i, Gamma_i, _ in resonances:\n        for m in INITIAL_BREAKPOINT_M:\n            pt = E_i + m * (Gamma_i / 2.0)\n            if E_min  pt  E_max:\n                breakpoints.add(pt)\n    \n    sorted_breakpoints = sorted(list(breakpoints))\n\n    # 4. Perform adaptive quadrature using a stack (LIFO)\n    panel_stack = [(sorted_breakpoints[i], sorted_breakpoints[i+1]) for i in range(len(sorted_breakpoints)-1)]\n    \n    total_integral = 0.0\n    \n    max_panels_processed = 1_000_000 # Safety break\n    panel_count = 0\n\n    while panel_stack:\n        if panel_count > max_panels_processed:\n            raise RuntimeError(\"Exceeded maximum number of panel subdivisions. Tolerance may be too strict.\")\n\n        a, b = panel_stack.pop()\n        m = (a + b) / 2.0\n        \n        # Integral over one coarse panel\n        I1 = _integrate_panel(integrand, a, b)\n        \n        # Integral over two finer sub-panels\n        I_left = _integrate_panel(integrand, a, m)\n        I_right = _integrate_panel(integrand, m, b)\n        I2 = I_left + I_right\n        \n        error_est = abs(I2 - I1)\n        # Use the more accurate integral I2 for the relative tolerance check\n        tolerance = max(TOL_ABS, TOL_REL * abs(I2))\n\n        if error_est = tolerance:\n            # Panel is accepted. Add its contribution (the more accurate I2).\n            total_integral += I2\n            panel_count += 1\n        else:\n            # Panel is rejected. Push sub-panels onto stack for further refinement.\n            # Push right panel first, then left, so left sub-panel is processed first.\n            panel_stack.append((m, b))\n            panel_stack.append((a, m))\n\n    return total_integral\n\ndef solve():\n    \"\"\"\n    Main orchestrator function that defines test cases and prints results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'E_min': 0.0, 'E_max': 10.0, 'kT': 1.0, \n         'resonances': [(3.0, 1.0, 10.0)]},\n        # Case 2\n        {'E_min': 0.0, 'E_max': 20.0, 'kT': 2.0, \n         'resonances': [(5.0, 0.2, 80.0), (12.0, 1.5, 30.0), (8.0, 0.05, 150.0)]},\n        # Case 3\n        {'E_min': 0.0, 'E_max': 5.0, 'kT': 0.5, \n         'resonances': [(0.1, 0.01, 200.0), (4.5, 0.02, 100.0)]},\n        # Case 4\n        {'E_min': 5.0, 'E_max': 15.0, 'kT': 1.5, \n         'resonances': [(9.5, 0.4, 70.0), (10.0, 0.5, 65.0), (10.3, 0.3, 80.0)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_rate_integral(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3550919"}]}