{"hands_on_practices": [{"introduction": "在数值求解任何微分方程之前，我们必须首先离散化求解域。计算网格的选择并非无足轻重的技术细节，它深刻影响着解的准确性和效率。本练习 [@problem_id:3598244] 提供了一个对不同径向网格的动手比较，展示了每种网格如何适应于捕捉狄拉克旋量在原点附近和远距离处的不同物理行为，为建立稳定且准确的数值模拟打下关键的直觉基础。", "problem": "考虑在中心势场中，自旋-$\\frac{1}{2}$粒子的球对称狄拉克方程，该方程采用自然单位制，其中约化普朗克常数 $\\hbar$、光速 $c$ 均为1，质量 $m$ 被缩放为 $m=1$。在此单位制下，所有物理量均为无量纲。态矢量由一个双分量径向旋量 $(g(r), f(r))$ 表示，这两个分量通过使用旋量球谐函数分离变量后得到的一阶耦合系统联系起来。总角动量量子数 $j$ 和轨道角动量 $l$ 被编码在狄拉克角量子数 $\\kappa$ 中，其定义符合标准关系式：当 $j = l + \\frac{1}{2}$ 时，$\\kappa = -(l+1)$；当 $j = l - \\frac{1}{2}$ 时，$\\kappa = +l$。对于一个球对称矢量势 $V(r)$，约化径向狄拉克方程的形式为\n$$\n\\frac{d g}{d r} = -\\frac{\\kappa}{r} g(r) + \\left(m + E - V(r)\\right) f(r),\n\\qquad\n\\frac{d f}{d r} = +\\frac{\\kappa}{r} f(r) - \\left(m - E + V(r)\\right) g(r),\n$$\n其中 $m=1$，束缚态能量 $E$ 满足 $0  E  m$。\n\n对于在原点 $r=0$ 处有限的中心势，正则性要求上分量在 $r \\to 0$ 时的行为如同 $g(r) \\propto r^{l+1}$，而下分量则被一个更高次幂的 $r$ 所抑制。在大半径处，当 $V(r) \\to 0$ 且 $0  E  m$ 时，解以 $g(r) \\sim A \\exp(-\\lambda r)$ 的形式衰减，其渐近衰减率 $\\lambda$ 由自由狄拉克色散关系给出\n$$\n\\lambda = \\sqrt{m^2 - E^2}.\n$$\n你需要通过一个计算实验来评估径向网格的选择如何影响对弱束缚能量 $E$ 的近原点幂律行为和长程指数渐近行为的数值解析度。需要比较的三种网格类型是：\n- 均匀 $r$ 网格：$r_j = r_{\\min} + j \\Delta r$，其中 $j=0,1,\\dots,N-1$，$\\Delta r = \\frac{r_{\\max} - r_{\\min}}{N-1}$。\n- 基于 $x = \\ln r$ 的对数网格：$x_j = \\ln r_{\\min} + j \\Delta x$，其中 $\\Delta x = \\frac{\\ln r_{\\max} - \\ln r_{\\min}}{N-1}$，且 $r_j = \\exp(x_j)$。\n- 映射的切比雪夫网格：定义切比雪夫节点 $\\xi_j = \\cos\\left(\\frac{j \\pi}{N-1}\\right)$，映射 $u_j = \\frac{1+\\xi_j}{2} \\in [0,1]$，并设置 $r_j = r_{\\min} + (r_{\\max} - r_{\\min}) u_j^p$，其中聚集指数 $p > 1$ 用于将点集中在原点附近。\n\n使用以下球对称 Woods–Saxon (WS) 矢量势，这是一个在计算核物理中经过充分检验的模型：\n$$\nV(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)},\n$$\n其中 $V_0$ 是深度， $R$ 是半径， $a$ 是弥散度。请严格在上述指定的无量纲体系中进行计算。能量 $E$ 被设为一个参数，无需是 WS 势的精确本征值；在此任务中，它仅用于控制渐近衰减率和弱束缚的程度。\n\n算法要求：\n1. 使用一致的显式二阶龙格-库塔方法（中点法），在每个网格上从 $r_{\\min}$ 到 $r_{\\max}$ 向外积分该一阶耦合系统，局域步长为 $\\Delta r_j = r_{j+1} - r_j$。在 $r_{\\min}$ 处使用 $g(r_{\\min}) = r_{\\min}^{l+1}$ 和 $f(r_{\\min}) = 0$ 初始化正则解，其中 $l$ 根据关系式从 $\\kappa$ 计算得出：当 $\\kappa  0$ 时，$l = -\\kappa - 1$；当 $\\kappa > 0$ 时，$l = \\kappa$。\n2. 通过对数值解的前 $M$ 个点进行 $\\ln |g(r)|$ 对 $\\ln r$ 的最小二乘线性拟合，估算近原点幂律指数 $\\alpha_{\\text{est}}$，拟合得到的斜率即为指数的估计值。理论指数为 $\\alpha_{\\text{th}} = l + 1$。将近原点指数误差量化为\n$$\n\\varepsilon_{\\text{origin}} = |\\alpha_{\\text{est}} - \\alpha_{\\text{th}}|.\n$$\n3. 通过对数值解的后 $L$ 个点进行 $\\ln |g(r)|$ 对 $r$ 的最小二乘线性拟合，估算大半径指数衰减率 $\\lambda_{\\text{est}}$，拟合范围限定在 $|g(r)|$ 大于一个小的数值阈值的点，以避免下溢。理论衰减率为 $\\lambda_{\\text{th}} = \\sqrt{m^2 - E^2}$。将尾部误差量化为\n$$\n\\varepsilon_{\\text{tail}} = |\\lambda_{\\text{est}} - \\lambda_{\\text{th}}|.\n$$\n\n数值参数：\n- 对所有网格，使用 $r_{\\min} = 10^{-4}$、$r_{\\max} = 20$ 和 $N = 2000$ 个网格点。\n- 使用切比雪夫映射指数 $p = 2$。\n- 使用 Woods–Saxon 参数 $V_0 = 0.3$、$R = 5.0$ 和 $a = 0.6$。\n- 使用 $M = 100$ 个点用于近原点拟合， $L = 200$ 个点用于尾部拟合。\n- 在尾部拟合中使用小阈值 $\\tau = 10^{-12}$ 以排除 $|g(r)|  \\tau$ 的点。\n\n测试套件：\n计算以下六个测试案例的 $\\varepsilon_{\\text{origin}}$ 和 $\\varepsilon_{\\text{tail}}$，每个案例由三元组 $(\\text{grid}, \\kappa, E)$ 指定：\n1. $(\\text{uniform}, -1, 0.95)$\n2. $(\\text{log}, -1, 0.95)$\n3. $(\\text{chebyshev}, -1, 0.95)$\n4. $(\\text{uniform}, -2, 0.99)$\n5. $(\\text{log}, -2, 0.99)$\n6. $(\\text{chebyshev}, -2, 0.99)$\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表；每个元素对应一个测试案例，并且必须是一个双元素列表，按顺序包含近原点误差和尾部误差。例如，输出格式必须如下所示\n$$\n[\\,[\\varepsilon_{\\text{origin},1},\\varepsilon_{\\text{tail},1}],\\,[\\varepsilon_{\\text{origin},2},\\varepsilon_{\\text{tail},2}],\\,\\dots,\\, [\\varepsilon_{\\text{origin},6},\\varepsilon_{\\text{tail},6}]\\,].\n$$\n由于计算在指定的自然单位制中是完全无量纲的，并且所有角度都与此径向问题无关，因此不需要物理单位。", "solution": "用户提供了一个相对论量子力学中的计算问题，特别关注在中心 Woods-Saxon 势中径向狄拉克方程的数值解法。任务是比较三种不同径向网格（均匀、对数、切比雪夫映射）在解析波函数在小半径和大半径处的特征行为时的数值精度。\n\n### 第1步：问题验证\n\n首先，我将提取给定信息并验证问题陈述。\n\n**已知条件：**\n-   **方程组**：中心矢量势 $V(r)$ 中双分量旋量 $(g(r), f(r))$ 的约化径向狄拉克方程：\n    $$\n    \\frac{d g}{d r} = -\\frac{\\kappa}{r} g(r) + \\left(m + E - V(r)\\right) f(r)\n    $$\n    $$\n    \\frac{d f}{d r} = +\\frac{\\kappa}{r} f(r) - \\left(m - E + V(r)\\right) g(r)\n    $$\n-   **常数和单位**：自然单位制，$\\hbar=1$，$c=1$，粒子质量 $m=1$。束缚态能量 $E$ 满足 $0  E  m$。\n-   **狄拉克量子数 $\\kappa$**：定义为当 $j = l + \\frac{1}{2}$ 时 $\\kappa = -(l+1)$，当 $j = l - \\frac{1}{2}$ 时 $\\kappa = +l$。轨道角动量 $l$ 由 $\\kappa$ 推导得出：当 $\\kappa > 0$ 时 $l = \\kappa$，当 $\\kappa  0$ 时 $l = -\\kappa - 1$。\n-   **势**：球对称 Woods-Saxon 矢量势：\n    $$\n    V(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}\n    $$\n-   **渐近行为**：近原点 ($r \\to 0$)：$g(r) \\propto r^{\\alpha_{\\text{th}}}$，其中 $\\alpha_{\\text{th}} = l+1$。大半径 ($r \\to \\infty$)：$g(r) \\sim A \\exp(-\\lambda_{\\text{th}} r)$，其中 $\\lambda_{\\text{th}} = \\sqrt{m^2 - E^2}$。\n-   **网格类型**：\n    1.  **均匀网格**：$r_j = r_{\\min} + j \\Delta r$，$\\Delta r = \\frac{r_{\\max} - r_{\\min}}{N-1}$。\n    2.  **对数网格**：$r_j = \\exp(\\ln r_{\\min} + j \\Delta x)$，$\\Delta x = \\frac{\\ln r_{\\max} - \\ln r_{\\min}}{N-1}$。\n    3.  **切比雪夫映射网格**：$r_j = r_{\\min} + (r_{\\max} - r_{\\min}) \\left(\\frac{1+\\cos(j \\pi/(N-1))}{2}\\right)^p$。\n-   **数值参数**：\n    -   积分范围：$r_{\\min} = 10^{-4}$，$r_{\\max} = 20$。\n    -   网格点数：$N = 2000$。\n    -   切比雪夫映射指数：$p = 2$。\n    -   Woods-Saxon 参数：$V_0 = 0.3$，$R = 5.0$，$a = 0.6$。\n    -   拟合区域：$M = 100$ (原点)，$L = 200$ (尾部)。\n    -   尾部拟合阈值：$\\tau = 10^{-12}$。\n-   **算法**：\n    1.  使用显式二阶龙格-库塔（中点）方法积分方程组。\n    2.  在 $r_{\\min}$ 处使用 $g(r_{\\min}) = r_{\\min}^{l+1}$ 和 $f(r_{\\min}) = 0$ 初始化解。\n    3.  通过对 $\\ln|g(r)|$ vs. $\\ln r$ 进行最小二乘拟合来估算近原点指数 $\\alpha_{\\text{est}}$（前 $M$ 个点）。\n    4.  通过对 $\\ln|g(r)|$ vs. $r$ 进行最小二乘拟合来估算尾部衰减率 $\\lambda_{\\text{est}}$（后 $L$ 个点，且 $|g(r)| > \\tau$）。\n    5.  计算误差：$\\varepsilon_{\\text{origin}} = |\\alpha_{\\text{est}} - \\alpha_{\\text{th}}|$ 和 $\\varepsilon_{\\text{tail}} = |\\lambda_{\\text{est}} - \\lambda_{\\text{th}}|$。\n-   **测试套件**：由 $(\\text{grid}, \\kappa, E)$ 定义的六个案例：\n    1. $(\\text{uniform}, -1, 0.95)$\n    2. $(\\text{log}, -1, 0.95)$\n    3. $(\\text{chebyshev}, -1, 0.95)$\n    4. $(\\text{uniform}, -2, 0.99)$\n    5. $(\\text{log}, -2, 0.99)$\n    6. $(\\text{chebyshev}, -2, 0.99)$\n-   **输出格式**：一个单行的列表之列表：$[[\\varepsilon_{\\text{origin},1},\\varepsilon_{\\text{tail},1}], \\dots, [\\varepsilon_{\\text{origin},6},\\varepsilon_{\\text{tail},6}]]$。\n\n**验证结论：**\n-   **科学上合理**：该问题基于狄拉克方程，这是相对论量子力学的基石之一，并使用了标准模型势（Woods-Saxon）。指定的渐近行为是正确的。所选的单位制是标准做法。该问题在科学上是合理的。\n-   **适定的**：该任务是一个定义明确的计算实验。它涉及求解一个常微分方程组（ODEs）的初值问题，鉴于势和系数在 $r > 0$ 时的光滑性，该问题是适定的。分析程序（例如，最小二乘拟合）是明确的。\n-   **客观的**：问题以精确、定量的术语陈述，没有主观性。\n-   **完整性和一致性**：提供了所有必要的参数、方程和算法。没有矛盾之处。能量值 $E  m$ 与束缚态假设和指数衰减一致。积分通过从 $r_{\\min} > 0$ 开始，避免了在 $r=0$ 处的坐标奇点。\n\n该问题是**有效的**。这是一个计算物理学中标准且表述清晰的练习。\n\n### 第2步：求解设计\n\n解决方案将作为一个遵循指定环境的 Python 脚本来实现。整体结构将包含一个主循环，遍历六个测试案例。对于每个案例，脚本将执行网格生成、数值积分和误差分析。\n\n**1. 理论量：**\n对于每个测试案例 $(\\kappa, E)$，我们首先计算理论参考值。\n-   轨道角动量量子数 $l$ 从 $\\kappa$ 计算。由于所有测试案例的 $\\kappa  0$，公式为 $l = -\\kappa - 1$。\n-   理论近原点指数为 $\\alpha_{\\text{th}} = l+1$。\n-   理论大半径衰减率为 $\\lambda_{\\text{th}} = \\sqrt{m^2 - E^2}$，其中 $m=1$。\n\n**2. 网格生成：**\n一个函数将根据指定的类型（`'uniform'`、`'log'` 或 `'chebyshev'`），使用参数 $r_{\\min}$、$r_{\\max}$、$N$ 和 $p$ 来生成径向网格 `r`。非均匀网格（对数和切比雪夫映射）预计在 $r=0$ 附近提供更高的分辨率，这应能提高近原点分析的准确性。\n\n**3. ODE 系统与积分：**\n耦合的一阶狄拉克方程定义了待解系统。系统的右端项 (RHS) 将被封装在一个函数 `dirac_rhs(r, g, f, ...)` 中。\n积分将使用一个实现二阶龙格-库塔（中点）方法的循环来执行。对于从 $r_j$ 到 $r_{j+1}$ 的每一步，步长为 $\\Delta r_j = r_{j+1} - r_j$：\n设状态矢量为 $\\mathbf{y} = (g, f)^T$，RHS 函数为 $\\mathbf{F}(r, \\mathbf{y})$。\n1.  计算中点斜率：$\\mathbf{k}_1 = \\mathbf{F}(r_j, \\mathbf{y}_j)$。\n2.  估算中点状态：$\\mathbf{y}_{\\text{mid}} = \\mathbf{y}_j + \\frac{\\Delta r_j}{2} \\mathbf{k}_1$。\n3.  计算中点的最终斜率：$\\mathbf{k}_2 = \\mathbf{F}(r_j + \\frac{\\Delta r_j}{2}, \\mathbf{y}_{\\text{mid}})$。\n4.  更新状态：$\\mathbf{y}_{j+1} = \\mathbf{y}_j + \\Delta r_j \\mathbf{k}_2$。\n积分从 $r_0 = r_{\\min}$ 处的初始条件开始：$g_0 = r_{\\min}^{l+1}$ 和 $f_0 = 0$。生成的数组 `g_sol` 和 `f_sol` 将存储完整的数值解。\n\n**4. 误差分析：**\n两个独立的程序将分析数值解 `g_sol`。\n-   **近原点误差 ($\\varepsilon_{\\text{origin}}$)**：我们取解的前 $M$ 个点，$(r_j, g_j)$，$j=0, \\dots, M-1$。我们对变换后的数据 $(\\ln r_j, \\ln|g_j|)$ 进行线性回归。拟合的斜率给出 $\\alpha_{\\text{est}}$。误差则为 $\\varepsilon_{\\text{origin}} = |\\alpha_{\\text{est}} - \\alpha_{\\text{th}}|$。\n-   **尾部误差 ($\\varepsilon_{\\text{tail}}$)**：我们取解的后 $L$ 个点，$(r_j, g_j)$，$j=N-L, \\dots, N-1$。我们首先过滤掉 $|g_j|  \\tau=10^{-12}$ 的点，以避免对数中的数值噪声和下溢问题。在剩下的点上，我们对 $(r_j, \\ln|g_j|)$ 进行线性回归。这个拟合的斜率将是负数，它给出 $-\\lambda_{\\text{est}}$。误差则为 $\\varepsilon_{\\text{tail}} = |\\lambda_{\\text{est}} - \\lambda_{\\text{th}}|$。\n对于两次拟合，将使用 `numpy.polyfit(x, y, 1)` 来高效计算最佳拟合线的斜率。\n\n**5. 最终组装：**\n主函数将为六个指定的测试案例中的每一个协调这些步骤。每个案例产生的误差对 $(\\varepsilon_{\\text{origin}}, \\varepsilon_{\\text{tail}})$ 将被收集到一个列表的列表中。最后，这个数据结构将被格式化为所需的字符串表示形式，并打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Dirac equation on different grids and computes numerical errors.\n    \"\"\"\n    # Define the global parameters from the problem statement.\n    m = 1.0  # Scaled mass\n    r_min = 1e-4\n    r_max = 20.0\n    N = 2000\n    p = 2.0  # Chebyshev mapping exponent\n    V0 = 0.3\n    R = 5.0\n    a = 0.6\n    M = 100  # Number of points for origin fit\n    L = 200  # Number of points for tail fit\n    tau = 1e-12 # Threshold for tail fit\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('uniform', -1, 0.95),\n        ('log', -1, 0.95),\n        ('chebyshev', -1, 0.95),\n        ('uniform', -2, 0.99),\n        ('log', -2, 0.99),\n        ('chebyshev', -2, 0.99),\n    ]\n\n    def generate_grid(grid_type, N_pts, rmin, rmax, p_exp):\n        \"\"\"Generates the radial grid.\"\"\"\n        if grid_type == 'uniform':\n            return np.linspace(rmin, rmax, N_pts)\n        elif grid_type == 'log':\n            return np.geomspace(rmin, rmax, N_pts)\n        elif grid_type == 'chebyshev':\n            # Chebyshev nodes on [-1, 1]\n            xi = np.cos(np.pi * np.arange(N_pts) / (N_pts - 1))\n            # Map to u in [0, 1] (reversed to start from r_min)\n            u = (1.0 - xi) / 2.0\n            # Map to r in [r_min, r_max] with clustering\n            return rmin + (rmax - rmin) * (u ** p_exp)\n        else:\n            raise ValueError(\"Unknown grid type\")\n\n    def woods_saxon(r, V0_p, R_p, a_p):\n        \"\"\"Calculates the Woods-Saxon potential.\"\"\"\n        return -V0_p / (1.0 + np.exp((r - R_p) / a_p))\n\n    def dirac_rhs(r, g, f, kappa, E):\n        \"\"\"Computes the right-hand side of the radial Dirac equations.\"\"\"\n        V_r = woods_saxon(r, V0, R, a)\n        # Handle r=0 case, though integration starts at r_min > 0\n        if r == 0:\n            return 0.0, 0.0\n        dg_dr = -kappa / r * g + (m + E - V_r) * f\n        df_dr = kappa / r * f - (m - E + V_r) * g\n        return dg_dr, df_dr\n\n    def integrate_dirac(r_grid, kappa, E):\n        \"\"\"\n        Integrates the Dirac system using the midpoint (RK2) method.\n        \"\"\"\n        # Determine l from kappa\n        if kappa > 0:\n            l = kappa\n        else: # kappa  0\n            l = -kappa - 1\n\n        g_sol = np.zeros_like(r_grid)\n        f_sol = np.zeros_like(r_grid)\n\n        # Initial conditions at r_min\n        g_sol[0] = r_grid[0] ** (l + 1)\n        f_sol[0] = 0.0\n        \n        # Integration loop using RK2\n        for j in range(N - 1):\n            r_j = r_grid[j]\n            g_j, f_j = g_sol[j], f_sol[j]\n            h = r_grid[j+1] - r_j\n\n            # k1\n            k1_g, k1_f = dirac_rhs(r_j, g_j, f_j, kappa, E)\n            \n            # Midpoint evaluation\n            r_mid = r_j + h / 2.0\n            g_mid = g_j + h / 2.0 * k1_g\n            f_mid = f_j + h / 2.0 * k1_f\n\n            # k2\n            k2_g, k2_f = dirac_rhs(r_mid, g_mid, f_mid, kappa, E)\n\n            # Update\n            g_sol[j+1] = g_j + h * k2_g\n            f_sol[j+1] = f_j + h * k2_f\n            \n        return g_sol, f_sol\n\n    def calculate_errors(r_grid, g_sol, kappa, E):\n        \"\"\"\n        Calculates near-origin and tail errors from the numerical solution.\n        \"\"\"\n        # Theoretical values\n        if kappa > 0:\n            l = kappa\n        else:\n            l = -kappa - 1\n            \n        alpha_th = l + 1.0\n        lambda_th = np.sqrt(m**2 - E**2)\n\n        # Near-origin fit\n        r_origin = r_grid[:M]\n        g_origin = g_sol[:M]\n        \n        # Filter out any points where g is numerically zero to avoid log(0)\n        valid_origin_indices = np.where(np.abs(g_origin)>0)\n        log_r_origin = np.log(r_origin[valid_origin_indices])\n        log_g_origin = np.log(np.abs(g_origin[valid_origin_indices]))\n        \n        if len(log_r_origin)  2: # Not enough points for a fit\n            alpha_est = np.nan\n        else:\n            alpha_est = np.polyfit(log_r_origin, log_g_origin, 1)[0]\n        \n        eps_origin = np.abs(alpha_est - alpha_th)\n\n        # Tail fit\n        r_tail = r_grid[-L:]\n        g_tail = g_sol[-L:]\n        \n        valid_tail_indices = np.where(np.abs(g_tail) > tau)\n        r_tail_fit = r_tail[valid_tail_indices]\n        g_tail_fit = g_tail[valid_tail_indices]\n        \n        if len(r_tail_fit)  2: # Not enough points for a fit\n            lambda_est = np.nan\n        else:\n            log_g_tail = np.log(np.abs(g_tail_fit))\n            slope_tail = np.polyfit(r_tail_fit, log_g_tail, 1)[0]\n            lambda_est = -slope_tail\n        \n        eps_tail = np.abs(lambda_est - lambda_th)\n\n        return [eps_origin, eps_tail]\n\n    results = []\n    for case in test_cases:\n        grid_type, kappa, E = case\n        \n        # 1. Generate grid\n        r = generate_grid(grid_type, N, r_min, r_max, p)\n        \n        # 2. Integrate\n        g, f = integrate_dirac(r, kappa, E)\n        \n        # 3. Calculate errors\n        errors = calculate_errors(r, g, kappa, E)\n        results.append(errors)\n    \n    # Format the final output string\n    # e.g., [[err1, err2], [err3, err4]]\n    result_str = '[' + ','.join([f\"[{e[0]},{e[1]}]\" for e in results]) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "3598244"}, {"introduction": "一个数值解只有当它遵循其所模拟系统的基本物理定律时才是可信的。对于狄拉克方程，通过连续性方程表达的概率守恒是一个必须满足的检验标准。通过这项实践 [@problem_id:3598169]，您将为狄拉克径向方程实现一个数值求解器，并用它来计算和验证概率流的性质，从而巩固您对定态和散射现象的理解，同时验证代码的正确性。", "problem": "您的任务是推导并实现一个计算验证方法，用于检验球对称（中心）势中狄拉克方程解的径向概率流，该方法需适用于计算核物理领域。所有推导和计算都必须在自然单位制中进行，其中 $\\hbar = c = 1$，静止质量 $m=1$。在此单位制中，径向概率流密度 $j_r(r)$ 的单位是长度的平方分之一，穿过半径为 $r$ 的球面的总径向通量为 $J(r) = r^2 j_r(r)$，该通量是无量纲的。您的实现必须针对特定的测试案例对狄拉克径向方程进行数值积分，并返回布尔值结果以验证有物理基础的性质。最终输出必须是单行内容，包含一个用方括号括起来的、以逗号分隔的列表。\n\n从具有球对称（中心）势 $V(r)$ 且总角动量量子数由狄拉克量子数 $\\kappa$ 表征的不含时狄拉克方程出发，旋量 $\\psi(\\mathbf{r})$ 可以分解为径向函数 $F(r)$ 和 $G(r)$ 与旋量球谐函数的乘积。对于固定的能量 $E$、质量 $m$ 和势 $V(r)$，狄拉克方程可简化为关于径向函数 $F(r)$ 和 $G(r)$ 的耦合一阶常微分方程组，其通用形式为\n$$\n\\frac{dF}{dr} = -\\frac{\\kappa}{r} F + \\big(E - V(r) + m\\big) G, \\quad\n\\frac{dG}{dr} = +\\frac{\\kappa}{r} G - \\big(E - V(r) - m\\big) F.\n$$\n这些方程是通过在球坐标系下使用旋量球谐函数对狄拉克方程进行标准的分离变量法得到的。概率密度和概率流满足连续性方程，概率流密度由 $\\mathbf{j}(\\mathbf{r}) = \\psi^\\dagger(\\mathbf{r}) \\boldsymbol{\\alpha} \\psi(\\mathbf{r})$ 给出，其中 $\\boldsymbol{\\alpha}$ 表示标准表示法下的狄拉克矩阵矢量。径向分量 $j_r(r)$ 和总径向通量 $J(r)$ 可以利用旋量球谐函数的性质以及定态的连续性方程，用径向函数 $F(r)$ 和 $G(r)$ 表示。根据这些原理，必须证明对于在完整旋量中以 $(F(r)/r, i\\,G(r)/r)$ 形式出现的约化径向函数，穿过球面的总通量满足\n$$\nJ(r) = r^2 j_r(r) = 2 \\,\\mathrm{Im}\\!\\big(F^*(r)\\,G(r)\\big),\n$$\n并且对于具有实势 $V(r)$ 的定态，$J(r)$ 与 $r$ 无关。\n\n此外，对于具有相同实值 $E$ 和 $V(r)$ 的同一一阶方程组的任意两个线性无关解 $\\big(F_1(r),G_1(r)\\big)$ 和 $\\big(F_2(r),G_2(r)\\big)$，由下式定义的朗斯基行列式：\n$$\nW(r) = F_1(r)\\,G_2(r) - G_1(r)\\,F_2(r)\n$$\n是一个与 $r$ 无关的常数。这种守恒性是刘维尔公式在一阶线性系统中的推论，也是狄拉克径向系统中出现的系数矩阵的迹为零的结果。\n\n您的程序必须对以下测试套件中的狄拉克径向方程进行数值求解，并返回布尔值结果以验证其基本物理性质：\n\n- 测试案例 1 (束缚态通量为零)：使用方势阱中心势 $V(r) = -V_0$ for $0 \\le r  R$ and $V(r) = 0$ for $r \\ge R$，参数为 $V_0 = 5.0$，$R = 2.0$，静止质量 $m = 1.0$，能量 $E = 0.8$（低于 $m$），狄拉克量子数 $\\kappa = -1$（对应最低的总角动量通道）。使用原点附近的正则初始条件，将径向系统从一个很小的半径 $r_0 = 10^{-4}$ 向外积分到 $r_{\\max} = 10.0$。沿着积分网格计算总通量 $J(r)$，并验证网格上 $J(r)$ 的最大绝对值低于容差 $\\varepsilon = 10^{-6}$，这反映了实势中定态、可归一化束缚态的净通量为零。返回一个布尔值，指示是否满足 $\\max_r |J(r)|  \\varepsilon$。\n\n- 测试案例 2 (阈值附近的散射态通量守恒)：使用自由粒子情况 $V(r) = 0$，参数为 $m = 1.0$，能量 $E = 1.05$（略高于阈值），以及 $\\kappa = -1$。在原点附近构造一个复数初始条件以生成一个具有非零流的解，并如上所述向外积分至 $r_{\\max} = 10.0$。在网格上计算 $J(r)$，并通过检查 $\\max_r |J(r) - J(r_0)|$ 是否低于 $\\varepsilon = 10^{-6}$ 来验证其守恒性。返回一个布尔值，指示通量是否在容差范围内保持不变。\n\n- 测试案例 3 (朗斯基行列式守恒性验证)：使用弱高斯中心势 $V(r) = -V_0 \\exp\\big(-r^2/a^2\\big)$，参数为 $V_0 = 0.2$，$a = 1.0$，质量 $m = 1.0$，能量 $E = 1.5$，以及 $\\kappa = -1$。通过在 $r_0 = 10^{-4}$ 处使用复共轭初始条件构造两个线性无关的解，将两者都积分到 $r_{\\max} = 10.0$，并计算朗斯基行列式 $W(r)$。验证朗斯基行列式在整个网格上于容差 $\\varepsilon = 10^{-6}$ 内保持不变，即 $\\max_r |W(r) - W(r_0)|  \\varepsilon$。返回一个布尔值，指示该条件是否满足。\n\n实现要求：\n\n- 使用自然单位制，其中 $\\hbar=c=1$ 且 $m=1$。所有流 $j_r(r)$ 均隐式地以长度平方分之一为单位，通量 $J(r)$ 是无量纲的。程序必须计算并使用 $J(r) = 2\\,\\mathrm{Im}(F^*(r) G(r))$ 和 $j_r(r) = J(r)/r^2$。\n\n- 必须使用稳定的显式方法（如四阶龙格－库塔方法）对复数值的 $F(r)$ 和 $G(r)$ 进行数值积分，并采用固定的步长以确保测试的收敛性。对于束缚态情况，使用原点附近的正则初始条件（对于 $\\kappa = -1$，可取 $F(r_0) \\propto r_0$ 且 $G(r_0)$ 与 $r_0$ 或 $r_0^2$ 成正比，以符合正则性要求）；对于散射情况，使用复数值的初始条件。\n\n- 最终输出必须是单行内容，分别包含测试案例1、测试案例2和测试案例3的布尔结果，形式为用方括号括起来的、以逗号分隔的列表，例如，“[True,True,False]”。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3]”）。", "solution": "该问题要求对中心势中不含时狄拉克方程解的基本性质进行计算验证。具体而言，我们需要对三种不同物理情景下的狄拉克径向方程进行数值积分，并验证 (i) 束缚态概率通量的消失，(ii) 散射态通量的守恒性，以及 (iii) 朗斯基行列式的守恒性。\n\n### 1. 理论框架\n\n出发点是中心势 $V(r)$ 中狄拉克旋量的径向分量 $F(r)$ 和 $G(r)$ 所满足的耦合一阶常微分方程组。在自然单位制 ($\\hbar=c=m=1$) 中，这些方程为：\n$$\n\\frac{dF}{dr} = -\\frac{\\kappa}{r} F(r) + \\big(E - V(r) + 1\\big) G(r)\n$$\n$$\n\\frac{dG}{dr} = +\\frac{\\kappa}{r} G(r) - \\big(E - V(r) - 1\\big) F(r)\n$$\n其中 $E$ 是能量，$\\kappa$ 是狄拉克量子数。\n\n单位立体角的径向概率通量 $J(r)$ 定义为 $J(r) = r^2 j_r(r)$，其中 $j_r(r)$ 是概率流密度 $\\mathbf{j} = \\psi^\\dagger \\boldsymbol{\\alpha} \\psi$ 的径向分量。用径向函数 $F(r)$ 和 $G(r)$ 表示，通量由下式给出：\n$$\nJ(r) = 2 \\, \\mathrm{Im}\\big(F^*(r) G(r)\\big)\n$$\n\n对于实值势 $V(r)$ 中的定态，连续性方程 $\\nabla \\cdot \\mathbf{j} = 0$ 意味着穿过任何以原点为中心的球面的总通量必须是恒定的。这意味着 $\\frac{d}{dr}(r^2 j_r(r)) = 0$，由此得出 $J(r)$ 与 $r$ 无关的结论。我们可以直接从径向方程验证这一点。将 $J(r)$ 对 $r$ 求导得到：\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left(\\frac{dF^*}{dr} G + F^* \\frac{dG}{dr}\\right)\n$$\n代入导数的表达式（及其复共轭，注意 $E, V, \\kappa, m$ 均为实数）：\n$$\n\\frac{dF^*}{dr} = -\\frac{\\kappa}{r} F^* + (E - V + 1) G^*\n$$\n$$\n\\frac{dG}{dr} = \\frac{\\kappa}{r} G - (E - V - 1) F\n$$\n我们发现：\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left[ \\left(-\\frac{\\kappa}{r} F^* + (E-V+1)G^*\\right)G + F^*\\left(\\frac{\\kappa}{r}G - (E-V-1)F\\right) \\right]\n$$\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left[ -\\frac{\\kappa}{r}F^*G + (E-V+1)|G|^2 + \\frac{\\kappa}{r}F^*G - (E-V-1)|F|^2 \\right]\n$$\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left[ (E-V+1)|G|^2 - (E-V-1)|F|^2 \\right]\n$$\n由于 $|F|^2$、$|G|^2$、$E$、$V$ 以及质量 $m=1$ 都是实数量，$\\mathrm{Im}[\\cdot]$ 的参数是纯实数。因此，$\\frac{dJ}{dr} = 0$，证实了 $J(r)$ 是一个常数。\n\n对于同一径向系统的任意两个线性无关解 $(F_1, G_1)$ 和 $(F_2, G_2)$，朗斯基行列式定义为 $W(r) = F_1(r)G_2(r) - G_1(r)F_2(r)$。该径向系统可以写成矩阵形式 $\\frac{d\\mathbf{y}}{dr} = A(r)\\mathbf{y}$，其中 $\\mathbf{y} = [F, G]^T$，系数矩阵 $A(r)$ 的迹为 $\\mathrm{Tr}(A(r)) = -\\kappa/r + \\kappa/r = 0$。根据阿贝尔恒等式，朗斯基行列式的导数由 $\\frac{dW}{dr} = \\mathrm{Tr}(A(r))W(r)$ 给出，这意味着 $\\frac{dW}{dr} = 0$。因此，朗斯基行列式 $W(r)$ 必须是一个常数。\n\n### 2. 数值实现\n\n该解决方案的核心是一个用于求解两个复数值一阶常微分方程组的数值积分器。按照要求，我们实现了一个采用固定步长的四阶龙格－库塔 (RK4) 方法。\n\n#### 原点附近的初始条件\n方程在 $r=0$ 处是奇异的。我们必须从一个很小的半径 $r_0 > 0$ 开始积分，并采用与正则解相对应的初始条件。正则解要求旋量分量在原点处是有限的，根据给定的定义，这意味着 $F(r)/r$ 和 $G(r)/r$ 是有限的。对于 $\\kappa=-1$，大分量 $F(r)$ 对应于 s 波 ($l=0$)，小分量 $G(r)$ 对应于 p 波 ($l=1$)。这意味着在小 $r$ 处，有 $F(r) \\sim c_1 r$ 和 $G(r) \\sim c_2 r^2$ 的行为。将这些形式代入 $\\kappa=-1$ 的第二个径向方程中：\n$$\n\\frac{d(c_2 r^2)}{dr} = -\\frac{1}{r}(c_2 r^2) - (E - V(r) - 1)(c_1 r)\n$$\n$$\n2c_2 r = -c_2 r - (E - V(0) - 1) c_1 r\n$$\n$$\n3c_2 = -(E - V(0) - 1) c_1\n$$\n这提供了系数之间的关系：$c_2 = -\\frac{1}{3}(E-V(0)-1)c_1$。我们可以选择归一化常数 $c_1$，然后确定 $c_2$。对于从 $r_0$ 开始的数值积分，我们设定：\n$$\nF(r_0) = c_1 r_0 \\quad \\text{and} \\quad G(r_0) = -\\frac{1}{3}(E - V(r_0) - 1) c_1 r_0^2\n$$\n常数 $c_1$ 可以是实数或复数。\n\n### 3. 测试案例与验证\n\n程序执行三个测试，每个测试验证一种物理性质。所有案例都使用一个从 $r_0 = 10^{-4}$ 到 $r_{\\max} = 10.0$、包含 $N=20000$ 步的固定积分网格。所有检查的容差均为 $\\varepsilon = 10^{-6}$。\n\n**测试案例 1：束缚态通量为零**\n- **原理**：在实势中的可归一化定态束缚态具有零净概率流。这样的解可以用实值径向函数 $F(r)$ 和 $G(r)$ 来描述，此时 $J(r) = 2 \\, \\mathrm{Im}(F^*G) = 2 \\, \\mathrm{Im}(FG) = 0$。\n- **设置**：方势阱 $V(r) = -5.0$ (当 $r2.0$)，具有束缚态能量 $E = 0.8  m=1.0$ 和 $\\kappa=-1$。\n- **实现**：我们选择一个实数归一化常数 $c_1=1.0$。初始条件为 $F(r_0)=r_0$ 和 $G(r_0) = -\\frac{1}{3}(E-V(r_0)-1)r_0^2$。积分后，计算通量 $J(r)$。\n- **验证**：如果 $\\max_r |J(r)|  \\varepsilon$，则测试通过。\n\n**测试案例 2：散射态通量守恒**\n- **原理**：对于任何定态解（束缚态或散射态），根据连续性方程推导，通量 $J(r)$ 必须是常数。\n- **设置**：自由粒子 ($V(r)=0$)，散射能量 $E = 1.05 > m=1.0$，$\\kappa=-1$。为了产生非零流，需要一个复数解。\n- **实现**：我们选择一个复数归一化常数 $c_1 = 1.0 + 1.0j$。使用这个复数 $c_1$ 按上述方法计算初始条件 $F(r_0)$ 和 $G(r_0)$。积分后，在整个网格上计算通量 $J(r)$。\n- **验证**：如果守恒性成立，即 $\\max_r |J(r) - J(r_0)|  \\varepsilon$，则测试通过。\n\n**测试案例 3：朗斯基行列式守恒**\n- **原理**：这个测试验证朗斯基行列式对于两个线性无关解是常数的数学性质。\n- **设置**：弱高斯势 $V(r) = -0.2 \\exp(-r^2)$，散射能量 $E=1.5$，$\\kappa=-1$。\n- **实现**：执行两次积分。\n    1. 解 1：以 $c_1 = 1.0 + 1.0j$ 初始化。\n    2. 解 2：以 $c_2 = c_1^* = 1.0 - 1.0j$ 初始化。由于常微分方程组是线性的且系数为实数，因此对于所有 $r$，第二个解将是第一个解的复共轭，即 $(F_2(r), G_2(r)) = (F_1(r)^*, G_1(r)^*)$。\n- **验证**：如果朗斯基行列式的守恒性条件 $\\max_r |W(r) - W(r_0)|  \\varepsilon$ 成立，则测试通过，其中 $W(r) = F_1(r)G_2(r) - G_1(r)F_2(r)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Dirac radial equations for three test cases and verifies\n    physical properties of the solutions.\n    \"\"\"\n\n    # --- Core numerical components ---\n\n    def rk4_step(dydr, r, y, h, params):\n        \"\"\"\n        Performs a single step of the 4th-order Runge-Kutta method for a\n        system of complex-valued ODEs.\n        y is a numpy array of complex numbers.\n        \"\"\"\n        k1 = h * dydr(r, y, params)\n        k2 = h * dydr(r + 0.5 * h, y + 0.5 * k1, params)\n        k3 = h * dydr(r + 0.5 * h, y + 0.5 * k2, params)\n        k4 = h * dydr(r + h, y + k3, params)\n        return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\n    def dirac_radial_ode(r, y, params):\n        \"\"\"\n        Defines the system of Dirac radial ODEs dy/dr.\n        y = [F, G]\n        \"\"\"\n        F, G = y\n        E, m, kappa, V_func, V_params = params['E'], params['m'], params['kappa'], params['V_func'], params['V_params']\n        \n        # Avoid division by zero at the exact start, though r0 is small.\n        if r == 0:\n            return np.array([0j, 0j])\n\n        V_r = V_func(r, **V_params)\n        \n        dFdr = -kappa / r * F + (E - V_r + m) * G\n        dGdr = kappa / r * G - (E - V_r - m) * F\n        \n        return np.array([dFdr, dGdr])\n\n    def integrate_dirac(params):\n        \"\"\"\n        Integrates the Dirac radial equations from r0 to r_max.\n        \"\"\"\n        r0 = params['r0']\n        r_max = params['r_max']\n        n_steps = params['n_steps']\n        \n        r_grid = np.linspace(r0, r_max, n_steps)\n        h = r_grid[1] - r_grid[0]\n        \n        # Initialize arrays for solutions\n        sols = np.zeros((n_steps, 2), dtype=np.complex128)\n        \n        # Regular initial conditions at r0\n        c1 = params['c1']\n        V_at_r0 = params['V_func'](r0, **params['V_params'])\n        F0 = c1 * r0\n        # For kappa=-1, l=0, G behaves like r^2.\n        # This relation is derived from the ODEs for small r.\n        G0 = -1/3 * (params['E'] - V_at_r0 - params['m']) * c1 * r0**2 if params['kappa'] == -1 else 0j\n        sols[0] = [F0, G0]\n        \n        # Integration loop\n        for i in range(n_steps - 1):\n            sols[i+1] = rk4_step(dirac_radial_ode, r_grid[i], sols[i], h, params)\n            \n        return r_grid, sols[:, 0], sols[:, 1] # r, F, G\n\n    # --- Potential functions ---\n\n    def V_square_well(r, V0, R):\n        return -V0 if r  R else 0.0\n\n    def V_free(r):\n        return 0.0\n\n    def V_gaussian(r, V0, a):\n        return -V0 * np.exp(-r**2 / a**2)\n\n    # --- Main Test Case Logic ---\n    \n    results = []\n    \n    # Common parameters\n    r0 = 1e-4\n    r_max = 10.0\n    n_steps = 20000\n    m = 1.0\n    kappa = -1.0\n    epsilon = 1e-6\n\n    # Test Case 1: Bound-state flux vanishing\n    params1 = {\n        'V_func': V_square_well, 'V_params': {'V0': 5.0, 'R': 2.0},\n        'm': m, 'E': 0.8, 'kappa': kappa,\n        'r0': r0, 'r_max': r_max, 'n_steps': n_steps,\n        'c1': 1.0 + 0.0j # Real initial condition\n    }\n    r, F, G = integrate_dirac(params1)\n    J = 2 * (F.conj() * G).imag\n    result1 = np.max(np.abs(J))  epsilon\n    results.append(result1)\n\n    # Test Case 2: Scattering-state flux constancy\n    params2 = {\n        'V_func': V_free, 'V_params': {},\n        'm': m, 'E': 1.05, 'kappa': kappa,\n        'r0': r0, 'r_max': r_max, 'n_steps': n_steps,\n        'c1': 1.0 + 1.0j # Complex initial condition for non-zero flux\n    }\n    r, F, G = integrate_dirac(params2)\n    J = 2 * (F.conj() * G).imag\n    J0 = J[0]\n    result2 = np.max(np.abs(J - J0))  epsilon\n    results.append(result2)\n\n    # Test Case 3: Wronskian constancy\n    params3_base = {\n        'V_func': V_gaussian, 'V_params': {'V0': 0.2, 'a': 1.0},\n        'm': m, 'E': 1.5, 'kappa': kappa,\n        'r0': r0, 'r_max': r_max, 'n_steps': n_steps,\n    }\n    \n    # Solution 1\n    params3_1 = params3_base.copy()\n    params3_1['c1'] = 1.0 + 1.0j\n    r, F1, G1 = integrate_dirac(params3_1)\n    \n    # Solution 2 (complex conjugate initial condition)\n    params3_2 = params3_base.copy()\n    params3_2['c1'] = 1.0 - 1.0j\n    r, F2, G2 = integrate_dirac(params3_2)\n\n    # Verification: Wronskian constancy\n    W = F1 * G2 - G1 * F2\n    W0 = W[0]\n    wronskian_const = np.max(np.abs(W - W0))  epsilon\n    \n    result3 = wronskian_const\n    results.append(result3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n\n```", "id": "3598169"}, {"introduction": "根据量子力学的玻恩法则，粒子在空间中被找到的总概率必须为一，这意味着波函数必须被归一化。由于束缚态波函数的指数尾部延伸至无穷远，这一归一化过程需要稳健的数值积分技术。这项实践 [@problem_id:3598165] 将挑战您实现并比较专为半无限区间设计的先进求积方案，掌握这些方法对于获得物理上有意义的波函数和计算准确的期望值至关重要。", "problem": "考虑在球对称（中心）势中狄拉克方程的径向旋量分量，记为 $G(r)$ 和 $F(r)$，其中 $r$ 是无量纲自然单位（普朗克常数 $\\hbar$ 等于 $1$，光速 $c$ 等于 $1$，质量 $m$ 等于 $1$）下的径向坐标。物理归一化约束是概率守恒要求\n$$\n\\int_{0}^{\\infty}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)\\,dr = 1.\n$$\n对于现实核平均场势中的束缚态，径向分量在 $r=0$ 附近表现出正则行为，并在大 $r$ 处呈指数衰减。在数值计算中，必须在一个有限点集上通过求积对旋量进行归一化，并且应选择能反映 $G(r)$ 和 $F(r)$ 结构的网格，以确保稳定性和准确性。\n\n您的任务是设计并实现一个算法，该算法能够：\n- 通过从所选求积法计算归一化因子并相应地重新标度 $(G,F)$，将归一化积分 $\\int_{0}^{\\infty}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)\\,dr=1$ 强制到机器精度。\n- 比较三种为预期径向行为量身定制的非均匀求积方案：\n  1. 在 $[0,\\infty)$ 上的高斯-拉盖尔求積，其权重函数与主导指数包络相匹配，\n  2. 使用变换 $r=\\tau/(1-\\tau)$（其中 $\\tau\\in(0,1)$）以达到 $r\\to\\infty$ 的映射高斯-勒让德求积，\n  3. 基于指数包络的累积变换的定制映射，$r(s) = -\\ln(1-s)/\\beta$，其中 $s\\in[0,1]$ 且 $\\beta$ 从 $G,F$ 的衰减尺度中选取。\n\n为使比较精确且自洽，使用具有类狄拉克正则性和衰减性的函数来模拟狄拉克径向分量：\n$$\nG(r) = \\mathcal{A}\\,r^{\\nu}\\,e^{-\\alpha r},\\qquad\nF(r) = \\mathcal{A}\\,c_{\\mathrm{fd}}\\left(\\frac{d}{dr}G(r) + \\frac{\\kappa}{r}G(r)\\right),\n$$\n其中 $\\alpha>0$ 设定指数衰减尺度，$\\nu\\ge 1$ 确保原点处的正则性，$\\kappa$ 是进入径向耦合的狄拉克自旋-轨道量子数因子，而 $c_{\\mathrm{fd}}$ 是一个无量纲系数，模拟径向狄拉克方程中下分量的相对振幅。常数 $\\mathcal{A}$ 是一个任意振幅，它将在归一化过程中被消除。该模型捕捉了算法评估所需的定性结构，而无需调用特定的核势。在所述自然单位下，所有量均为无量纲。\n\n从狄拉克旋量的基本概率诠释和单位归一化要求出发，从第一性原理开发一个稳健的数值算法，包含以下要素：\n- 清晰推导如何确定并应用归一化因子，使得在所选方案内 $\\left(|G|^{2}+|F|^{2}\\right)$ 的离散化求积结果在机器精度内等于 $1$。\n- 根据 $\\left(|G|^{2}+|F|^{2}\\right)$ 的行为，有原则地选择与之匹配的非均匀网格，包括上述三种求积方案的节点和权重的变换。明确表达所有变量变换和雅可比式。\n- 一种数值稳定的求和策略（例如，补偿求和），以在累加求积和时最小化浮点舍入误差。\n\n您的程序必须实现以下三种求积方案：\n1. 高斯-拉盖尔求积：使用 $N_{\\mathrm{Lag}}$ 个节点 $\\{x_i,w_i\\}_{i=1}^{N_{\\mathrm{Lag}}}$，权重为 $e^{-x}$，作用于 $[0,\\infty)$。通过选择 $\\beta=2\\alpha$ 并进行变量替换 $x=\\beta r$ 来匹配包络，使得\n$$\n\\int_{0}^{\\infty}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)\\,dr\n= \\frac{1}{\\beta}\\int_{0}^{\\infty}e^{-x}\\,H(x)\\,dx \\approx \\frac{1}{\\beta}\\sum_{i=1}^{N_{\\mathrm{Lag}}}w_i\\,H(x_i),\n$$\n其中 $H(x)$ 定义为 $H(x)=e^{x}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)$，在 $r=x/\\beta$ 处求值。您必须为给定的 $G,F$ 模型显式推导 $H(x)$，以避免数值上溢。\n2. 在 $[0,1]$ 上的映射高斯-勒让德求积：使用 $N_{\\mathrm{Leg}}$ 个节点 $\\{\\xi_i,\\omega_i\\}$（在 $[-1,1]$上），映射 $\\tau=(\\xi+1)/2\\in[0,1]$ 和 $r(\\tau)=\\tau/(1-\\tau)$，使得\n$$\n\\int_{0}^{\\infty}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)\\,dr\n= \\int_{0}^{1}\\left(|G(r(\\tau))|^{2}+|F(r(\\tau))|^{2}\\right)\\frac{dr}{d\\tau}\\,d\\tau\n\\approx \\sum_{i=1}^{N_{\\mathrm{Leg}}}\\frac{\\omega_i}{2}\\left(|G(r(\\tau_i))|^{2}+|F(r(\\tau_i))|^{2}\\right)\\frac{1}{(1-\\tau_i)^{2}}.\n$$\n3. 在 $[0,1]$ 上的定制包络映射：使用 $N_{\\mathrm{Leg}}$ 个节点（在 $[-1,1]$上）映射到 $s=(\\xi+1)/2\\in[0,1]$，设置 $r(s)=-\\ln(1-s)/\\beta$，其中 $\\beta=2\\alpha$，使得\n$$\n\\int_{0}^{\\infty}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)\\,dr\n= \\int_{0}^{1}\\left(|G(r(s))|^{2}+|F(r(s))|^{2}\\right)\\frac{dr}{ds}\\,ds\n\\approx \\sum_{i=1}^{N_{\\mathrm{Leg}}}\\frac{\\omega_i}{2}\\left(|G(r(s_i))|^{2}+|F(r(s_i))|^{2}\\right)\\frac{1}{\\beta(1-s_i)}.\n$$\n\n归一化强制执行必须按以下步骤进行：对于任何选定的求积方案，从未归一化的 $(G,F)$ 计算原始积分 $I$，确定归一化因子 $S=1/\\sqrt{I}$，并重新标度 $(G,F)\\mapsto(SG,SF)$。当重新标度的 $(G,F)$ 在相同的求积法下重新积分时，结果必须在机器精度内为 $1$（意味着与 $1$ 的绝对偏差应达到或接近 $64$ 位算法的浮点舍入水平）。\n\n设计一个测试套件以探究不同行为：\n- 情况 A（理想情况）：$\\alpha=0.8$, $\\nu=2$, $\\kappa=1$, $c_{\\mathrm{fd}}=0.3$, $N_{\\mathrm{Lag}}=80$, $N_{\\mathrm{Leg}}=80$。\n- 情况 B（强局域化）：$\\alpha=2.5$, $\\nu=1$, $\\kappa=2$, $c_{\\mathrm{fd}}=0.6$, $N_{\\mathrm{Lag}}=100$, $N_{\\mathrm{Leg}}=100$。\n- 情况 C（长尾）：$\\alpha=0.2$, $\\nu=3$, $\\kappa=1$, $c_{\\mathrm{fd}}=0.1$, $N_{\\mathrm{Lag}}=120$, $N_{\\mathrm{Leg}}=120$。\n\n对于每个测试用例，为每种方案单独计算归一化因子，然后通过在所有三种方案下评估归一化积分来进行方案间的交叉验证。将一个测试用例的报告结果定义为在所有交叉验证和所有方案中与 $1$ 的最大绝对偏差。所有量均为无量纲，不涉及角度或百分比。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_{A},r_{B},r_{C}]$），其中每个 $r$ 是一个浮点数，代表相应情况下的最大绝对偏差。", "solution": "已对用户提供的问题进行分析，并确认其有效。该问题在科学上基于量子力学和数值分析，问题定义明确、客观，并为一项有意义的计算任务包含了完整且一致的需求集。\n\n### 1. 理论基础与归一化原理\n\n应用于狄拉克方程的量子力学基本假设要求，在整个空间中找到一个粒子的总概率为1。对于中心势中由径向分量 $G(r)$ 和 $F(r)$ 描述的粒子，这表示为归一化条件：\n$$\n\\int_{0}^{\\infty}\\left(|G(r)|^{2}+|F(r)|^{2}\\right)\\,dr = 1\n$$\n此处，$r$ 是径向坐标，所有量均采用无量纲自然单位（$\\hbar=c=m=1$）。项 $P(r) = |G(r)|^{2}+|F(r)|^{2}$ 是径向概率密度。\n\n在数值解中，$G(r)$ 和 $F(r)$ 函数通常是作为狄拉克方程的未归一化解求得的。令这些未归一化的分量为 $g(r)$ 和 $f(r)$。为强制执行物理概率约束，我们必须计算这些分量的归一化积分值：\n$$\nI = \\int_{0}^{\\infty}\\left(|g(r)|^{2}+|f(r)|^{2}\\right)\\,dr\n$$\n然后可以确定一个全局归一化常数 $S$，使得重新标度的函数 $G(r) = S \\cdot g(r)$ 和 $F(r) = S \\cdot f(r)$ 满足单位归一化条件。将这些代入积分可得：\n$$\n\\int_{0}^{\\infty}\\left(|S \\cdot g(r)|^{2}+|S \\cdot f(r)|^{2}\\right)\\,dr = S^2 \\int_{0}^{\\infty}\\left(|g(r)|^{2}+|f(r)|^{2}\\right)\\,dr = S^2 I = 1\n$$\n这意味着归一化常数为 $S = 1/\\sqrt{I}$。该算法的核心是为给定的模型函数精确计算积分 $I$。\n\n### 2. 模型波函数与概率密度\n\n问题为未归一化的径向分量提供了具有物理动机的模型函数，我们通过设置任意振幅 $\\mathcal{A}=1$ 将其表示为 $g(r)$ 和 $f(r)$：\n$$\ng(r) = r^{\\nu}\\,e^{-\\alpha r}\n$$\n$$\nf(r) = c_{\\mathrm{fd}}\\left(\\frac{d}{dr}g(r) + \\frac{\\kappa}{r}g(r)\\right)\n$$\n其中 $\\nu \\ge 1$ 确保原点处的正则性，$\\alpha > 0$ 控制指数衰减，而 $\\kappa$ 和 $c_{\\mathrm{fd}}$ 是分别与自旋-轨道相互作用和与下旋量分量的耦合相关的参数。\n\n首先，我们计算 $g(r)$ 的导数：\n$$\n\\frac{d}{dr}g(r) = \\frac{d}{dr}\\left(r^{\\nu}e^{-\\alpha r}\\right) = \\nu r^{\\nu-1}e^{-\\alpha r} - \\alpha r^{\\nu}e^{-\\alpha r} = g(r)\\left(\\frac{\\nu}{r}-\\alpha\\right)\n$$\n将此代入 $f(r)$ 的表达式：\n$$\nf(r) = c_{\\mathrm{fd}}\\left( g(r)\\left(\\frac{\\nu}{r}-\\alpha\\right) + \\frac{\\kappa}{r}g(r) \\right) = c_{\\mathrm{fd}} g(r) \\left(\\frac{\\nu+\\kappa}{r} - \\alpha\\right)\n$$\n那么，未归一化的径向概率密度 $P(r) = g(r)^2 + f(r)^2$（因为函数是实数）为：\n$$\nP(r) = \\left(r^{\\nu}e^{-\\alpha r}\\right)^2 + \\left[ c_{\\mathrm{fd}} r^{\\nu}e^{-\\alpha r} \\left(\\frac{\\nu+\\kappa}{r} - \\alpha\\right) \\right]^2\n$$\n$$\nP(r) = e^{-2\\alpha r} \\left[ r^{2\\nu} + c_{\\mathrm{fd}}^2 r^{2\\nu-2} \\left( (\\nu+\\kappa) - \\alpha r \\right)^2 \\right]\n$$\n该表达式是我们数值求积方法的被积函数。\n\n### 3. 数值求积方案\n\n$P(r)$ 从 $0$ 到 $\\infty$ 的积分使用三种不同的非均匀求积方案计算，这些方案旨在处理半无限域和被积函数的指数衰减。\n\n#### 3.1. 高斯-拉盖尔求积\n此方法是计算形如 $\\int_{0}^{\\infty} e^{-x} \\phi(x) dx$ 积分的理想选择。我们通过变量替换将我们的积分匹配到这种形式。令 $x = \\beta r$，其中选择 $\\beta = 2\\alpha$ 以匹配概率密度的指数衰减 $e^{-2\\alpha r}$。因此，$r = x/\\beta$ 且 $dr = dx/\\beta$。\n$$\nI = \\int_{0}^{\\infty} P(r) \\,dr = \\int_{0}^{\\infty} e^{-2\\alpha r} \\left[ \\dots \\right] \\,dr = \\int_{0}^{\\infty} e^{-x} \\left[ \\dots \\right]_{r=x/\\beta} \\frac{dx}{\\beta}\n$$\n积分变为：\n$$\nI = \\frac{1}{\\beta} \\int_{0}^{\\infty} e^{-x} H(x) \\,dx \\approx \\frac{1}{\\beta} \\sum_{i=1}^{N_{\\mathrm{Lag}}} w_i H(x_i)\n$$\n其中 $\\{x_i, w_i\\}$ 是标准高斯-拉盖尔求积的节点和权重。函数 $H(x)$ 定义为 $H(x) = e^x P(r)|_{r=x/\\beta}$。这种重构对于数值稳定性至关重要，因为它解析地消除了可能导致上溢或下溢的指数项。\n$$\nH(x) = e^x \\left( e^{-x} \\left[ \\left(\\frac{x}{\\beta}\\right)^{2\\nu} + c_{\\mathrm{fd}}^2 \\left(\\frac{x}{\\beta}\\right)^{2\\nu-2} \\left( (\\nu+\\kappa) - \\alpha \\frac{x}{\\beta} \\right)^2 \\right] \\right)\n$$\n当 $\\beta = 2\\alpha$ 时，这简化为一个数值稳定的类多项式表达式：\n$$\nH(x) = \\left(\\frac{x}{2\\alpha}\\right)^{2\\nu} + c_{\\mathrm{fd}}^2 \\left(\\frac{x}{2\\alpha}\\right)^{2\\nu-2} \\left( (\\nu+\\kappa) - \\frac{x}{2} \\right)^2\n$$\n\n#### 3.2. 映射的高斯-勒让德求积\n高斯-勒让德求积定义在有限区间上，通常是 $[-1,1]$。为了处理半无限域 $[0,\\infty)$，我们使用坐标变换。首先，我们通过 $\\tau = (\\xi+1)/2$ 将标准高斯-勒让德节点 $\\xi \\in [-1,1]$ 映射到 $\\tau \\in [0,1]$。然后，我们使用变换 $r(\\tau) = \\tau/(1-\\tau)$ 将 $\\tau$ 映射到径向坐标 $r \\in [0,\\infty)$。积分变换如下：\n$$\nI = \\int_{0}^{\\infty} P(r)\\,dr = \\int_{0}^{1} P(r(\\tau)) \\frac{dr}{d\\tau} \\,d\\tau\n$$\n变换的雅可比式是 $\\frac{dr}{d\\tau} = \\frac{1}{(1-\\tau)^2}$。然后我们应用高斯-勒让德求积法则，这涉及将积分变量从 $\\tau \\in [0,1]$ 变为 $\\xi \\in [-1,1]$（引入一个因子 $1/2$）：\n$$\nI \\approx \\sum_{i=1}^{N_{\\mathrm{Leg}}} \\frac{\\omega_i}{2} \\left( P(r(\\tau_i)) \\frac{1}{(1-\\tau_i)^2} \\right)\n$$\n其中 $\\{\\xi_i, \\omega_i\\}$ 是标准高斯-勒让德节点和权重，且 $\\tau_i = (\\xi_i+1)/2$。\n\n#### 3.3. 定制包络映射求积\n此方法也使用映射区间上的高斯-勒让德求积，但该映射是专门为匹配波函数的指数衰减而设计的。与前一方案类似，我们通过 $s = (\\xi+1)/2$ 将节点 $\\xi \\in [-1,1]$ 映射到 $s \\in [0,1]$。然后，径向坐标由一个从指数分布的累积函数导出的变换给出，$r(s) = -\\ln(1-s)/\\beta$，其中 $\\beta=2\\alpha$。这个变换将求积法中靠近 $s=1$ 处的密集网格点映射到 $r \\to \\infty$ 的区域。积分变换为：\n$$\nI = \\int_{0}^{\\infty} P(r)\\,dr = \\int_{0}^{1} P(r(s)) \\frac{dr}{ds} \\,ds\n$$\n雅可比式是 $\\frac{dr}{ds} = \\frac{1}{\\beta(1-s)}$。求积和为：\n$$\nI \\approx \\sum_{i=1}^{N_{\\mathrm{Leg}}} \\frac{\\omega_i}{2} \\left( P(r(s_i)) \\frac{1}{\\beta(1-s_i)} \\right)\n$$\n其中 $s_i = (\\xi_i+1)/2$。\n\n### 4. 数值稳定性与交叉验证\n\n在求积法则中对大量浮点项求和可能导致舍入误差的累积。为减轻此问题，按要求采用了补偿求和算法（Kahan 求和）。该算法维护一个运行的补偿项，以弥补每次加法中丢失的低位比特，从而显著提高最终和的准确性。\n\n为了对归一化过程进行稳健的评估，我们实现了一个交叉验证协议。对于每个测试用例：\n1.  使用三种求积方案之一（例如，高斯-拉盖尔求积）计算归一化因子 $S$。\n2.  然后，使用所有三种方案（高斯-拉盖尔求积、映射高斯-勒让德求积和定制映射求积）对重新标度的概率密度 $S^2 P(r)$ 进行积分。\n3.  计算这三个积分结果中每一个与 $1$ 的绝对偏差。\n重复此过程，使用另外两种方案中的每一种来计算初始归一化因子 $S$。该测试用例的最终报告结果是在所有 $3 \\times 3 = 9$ 次验证检查中发现的最大偏差。这确保了归一化不仅在单一方案内是自洽的，而且在不同数值积分方法之间也是准确和稳健的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_laguerre, roots_legendre\n\ndef kahan_sum(arr):\n    \"\"\"\n    Computes the sum of an array of floats using Kahan's compensated summation\n    algorithm to minimize numerical error.\n    \"\"\"\n    s = np.float64(0.0)\n    c = np.float64(0.0)\n    for x in arr:\n        y = np.float64(x) - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef solve():\n    \"\"\"\n    Main function to perform the normalization and cross-validation for the\n    Dirac radial components using three different quadrature schemes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, nu, kappa, c_fd, N_Lag, N_Leg)\n        (0.8, 2, 1, 0.3, 80, 80),   # Case A\n        (2.5, 1, 2, 0.6, 100, 100), # Case B\n        (0.2, 3, 1, 0.1, 120, 120)  # Case C\n    ]\n\n    final_results = []\n    for params in test_cases:\n        alpha, nu, kappa, c_fd, N_Lag, N_Leg = params\n        beta = 2.0 * alpha\n\n        def p_density(r, S_sq):\n            \"\"\"\n            Computes the normalized probability density S^2 * P(r).\n            P(r) = exp(-2*alpha*r) * [r^(2*nu) + c_fd^2 * r^(2*nu-2) * ((nu+kappa) - alpha*r)^2]\n            \"\"\"\n            r = np.asarray(r, dtype=np.float64)\n            # Use np.power for robust vectorized power calculations.\n            # The condition nu >= 1 ensures exponents are non-negative at r=0.\n            term1 = np.power(r, 2 * nu)\n            term2 = c_fd**2 * np.power(r, 2 * nu - 2) * np.power((nu + kappa) - alpha * r, 2)\n            return S_sq * np.exp(-2.0 * alpha * r) * (term1 + term2)\n\n        def h_func(x, S_sq):\n            \"\"\"\n            Computes the S^2 * H(x) function for Gauss-Laguerre quadrature.\n            H(x) = (x/beta)^(2*nu) + c_fd^2 * (x/beta)^(2*nu-2) * ((nu+kappa) - alpha*x/beta)^2\n            \"\"\"\n            x = np.asarray(x, dtype=np.float64)\n            x_over_beta = x / beta\n            term1 = np.power(x_over_beta, 2 * nu)\n            term2 = c_fd**2 * np.power(x_over_beta, 2 * nu - 2) * np.power((nu + kappa) - alpha * x_over_beta, 2)\n            return S_sq * (term1 + term2)\n\n        def integrate_laguerre(S_sq=1.0):\n            nodes, weights = roots_laguerre(N_Lag)\n            integrand_values = h_func(nodes, S_sq)\n            summation = kahan_sum(weights * integrand_values)\n            return (1.0 / beta) * summation\n        \n        def integrate_legendre_map(S_sq=1.0):\n            nodes_xi, weights_omega = roots_legendre(N_Leg)\n            tau = (nodes_xi + 1.0) / 2.0\n            # To avoid division by zero at tau=1, we can clip or use a safe expression\n            # However, for Gauss-Legendre nodes in (-1,1), tau is in (0,1), so 1-tau is never zero.\n            r = tau / (1.0 - tau)\n            jacobian = 1.0 / np.power(1.0 - tau, 2)\n            \n            integrand_values = p_density(r, S_sq)\n            sum_terms = (weights_omega / 2.0) * integrand_values * jacobian\n            return kahan_sum(sum_terms)\n\n        def integrate_envelope_map(S_sq=1.0):\n            nodes_xi, weights_omega = roots_legendre(N_Leg)\n            s = (nodes_xi + 1.0) / 2.0\n            # s is in (0,1), so 1-s is never zero.\n            r = -np.log(1.0 - s) / beta\n            jacobian = 1.0 / (beta * (1.0 - s))\n            \n            integrand_values = p_density(r, S_sq)\n            sum_terms = (weights_omega / 2.0) * integrand_values * jacobian\n            return kahan_sum(sum_terms)\n\n        integrators = [integrate_laguerre, integrate_legendre_map, integrate_envelope_map]\n        deviations = []\n\n        # Cross-validation loop\n        for norm_integrator in integrators:\n            # 1. Compute raw integral and normalization factor S^2\n            raw_integral = norm_integrator(S_sq=1.0)\n            # Ensure integrand is non-negative before taking square root\n            if raw_integral = 0:\n                S_sq = np.nan # Propagate error\n            else:\n                S_sq = 1.0 / raw_integral\n\n            # 2. Check normalization with all three schemes\n            for check_integrator in integrators:\n                if np.isnan(S_sq):\n                    deviations.append(np.nan)\n                    continue\n                normalized_integral = check_integrator(S_sq=S_sq)\n                dev = abs(normalized_integral - 1.0)\n                deviations.append(dev)\n\n        max_dev = max(deviations) if deviations and not np.isnan(np.sum(deviations)) else np.nan\n        final_results.append(max_dev)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in final_results)}]\")\n\nsolve()\n```", "id": "3598165"}]}