{"hands_on_practices": [{"introduction": "在部署复杂的迭代算法之前，对矩阵特征值所处的大致范围进行估计通常具有不可估量的价值。Gershgorin 圆盘定理提供了一种非常简单而有效的方法，可以直接根据矩阵的元素来界定谱。这个练习 [@problem_id:3568887] 将演示如何将该定理应用于一个核哈密顿量，不仅可以定位特征值，还可以做出实际决策，例如为位移-反演方法选择一个安全的位移值。", "problem": "一个用于截断组态空间的原子核壳模型哈密顿量，在单粒子基中表示为一个实对称矩阵 $H \\in \\mathbb{R}^{6 \\times 6}$（在其对应的复数表述中是厄米的），其矩阵元以兆电子伏特（MeV）为单位给出：\n$$\nH \\;=\\; \\begin{pmatrix}\n-8.1  -0.25  0.20  0  0.05  0 \\\\\n-0.25  -7.4  -0.15  0  0  0 \\\\\n0.20  -0.15  -7.9  0.05  0.10  0 \\\\\n0  0  0.05  4.3  -0.30  -0.10 \\\\\n0.05  0  0.10  -0.30  5.0  -0.20 \\\\\n0  0  0  -0.10  -0.20  6.2\n\\end{pmatrix}.\n$$\n使用数值线性代数的第一性原理工具，计算 $H$ 特征值的盖尔圆界，并构成所得一维盖尔圆区间的并集（该矩阵是厄米的，因此其谱为实数）。然后，为了执行一个既能保证安全（可逆分解）又能靶定与激发态相关的正能区的位移反演计算，请选择一个正位移 $\\sigma$，其值为相邻正盖尔圆区间之间最大有界开间隙的中点。以兆电子伏特（MeV）为单位给出此 $\\sigma$ 值，并四舍五入到四位有效数字。最终答案必须是单个实数。", "solution": "该问题要求为位移反演特征值算法计算一个合适的位移参数 $\\sigma$。这涉及到使用盖尔圆定理对给定哈密顿矩阵 $H$ 的特征值进行定位，在谱的正部识别出一个间隙，并找到该间隙的中点。\n\n给定的哈密顿矩阵是：\n$$\nH \\;=\\; \\begin{pmatrix}\n-8.1  -0.25  0.20  0  0.05  0 \\\\\n-0.25  -7.4  -0.15  0  0  0 \\\\\n0.20  -0.15  -7.9  0.05  0.10  0 \\\\\n0  0  0.05  4.3  -0.30  -0.10 \\\\\n0.05  0  0.10  -0.30  5.0  -0.20 \\\\\n0  0  0  -0.10  -0.20  6.2\n\\end{pmatrix}\n$$\n矩阵元单位为兆电子伏特（MeV）。由于 $H$ 是一个实对称矩阵，其特征值为实数。盖尔圆定理指出，矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的每个特征值都位于复平面内至少一个盖尔圆盘 $D(A_{ii}, R_i)$ 中，其中 $A_{ii}$ 是第 $i$ 个对角元，$R_i = \\sum_{j \\neq i} |A_{ij}|$ 是第 $i$ 行非对角元绝对值之和。对于像 $H$ 这样的实对称矩阵，特征值是实数，因此盖尔圆盘变成了实轴上的闭区间 $G_i = [H_{ii} - R_i, H_{ii} + R_i]$。\n\n首先，我们计算每一行 $i = 1, \\dots, 6$ 的半径 $R_i$：\n$R_1 = |-0.25| + |0.20| + |0| + |0.05| + |0| = 0.25 + 0.20 + 0 + 0.05 + 0 = 0.50$\n$R_2 = |-0.25| + |-0.15| + |0| + |0| + |0| = 0.25 + 0.15 + 0 + 0 + 0 = 0.40$\n$R_3 = |0.20| + |-0.15| + |0.05| + |0.10| + |0| = 0.20 + 0.15 + 0.05 + 0.10 + 0 = 0.50$\n$R_4 = |0| + |0| + |0.05| + |-0.30| + |-0.10| = 0 + 0 + 0.05 + 0.30 + 0.10 = 0.45$\n$R_5 = |0.05| + |0| + |0.10| + |-0.30| + |-0.20| = 0.05 + 0 + 0.10 + 0.30 + 0.20 = 0.65$\n$R_6 = |0| + |0| + |0| + |-0.10| + |-0.20| = 0 + 0 + 0 + 0.10 + 0.20 = 0.30$\n\n接下来，我们确定盖尔圆区间 $G_i = [H_{ii} - R_i, H_{ii} + R_i]$：\n$G_1 = [-8.1 - 0.50, -8.1 + 0.50] = [-8.60, -7.60]$\n$G_2 = [-7.4 - 0.40, -7.4 + 0.40] = [-7.80, -7.00]$\n$G_3 = [-7.9 - 0.50, -7.9 + 0.50] = [-8.40, -7.40]$\n$G_4 = [4.3 - 0.45, 4.3 + 0.45] = [3.85, 4.75]$\n$G_5 = [5.0 - 0.65, 5.0 + 0.65] = [4.35, 5.65]$\n$G_6 = [6.2 - 0.30, 6.2 + 0.30] = [5.90, 6.50]$\n\n$H$ 的全谱，记为 $\\Lambda(H)$，包含在这些区间的并集中：$\\Lambda(H) \\subseteq \\bigcup_{i=1}^6 G_i$。问题要求关注正能区，这对应于区间 $G_4$、$G_5$ 和 $G_6$。我们求这些正值区间的并集。\n\n区间 $G_4 = [3.85, 4.75]$ 和 $G_5 = [4.35, 5.65]$ 有重叠，因为 $G_5$ 的起点（$4.35$）小于 $G_4$ 的终点（$4.75$）。它们的并集是：\n$G_4 \\cup G_5 = [\\min(3.85, 4.35), \\max(4.75, 5.65)] = [3.85, 5.65]$。\n\n第三个正值区间是 $G_6 = [5.90, 6.50]$。这个区间与并集 $G_4 \\cup G_5$ 不相交，因为 $G_4 \\cup G_5$ 的上界（$5.65$）小于 $G_6$ 的下界（$5.90$）。\n\n因此，根据盖尔圆定理，包含正特征值的区域是两个不相交集合的并集：\n$[3.85, 5.65] \\cup [5.90, 6.50]$。\n\n问题要求找到“相邻正盖尔圆区间之间最大有界开间隙”的中点。在本例中，只有一个这样的间隙。这个间隙是我们找到的两个不相交集合之间的开区间：\n间隙 $= (5.65, 5.90)$。\n\n位移 $\\sigma$ 定义为该间隙的中点。\n$$\n\\sigma = \\frac{5.65 + 5.90}{2} = \\frac{11.55}{2} = 5.775\n$$\n这个 $\\sigma$ 值位于间隙内，确保了 $\\sigma$ 不是 $H$ 的特征值。因此，矩阵 $(H - \\sigma I)$ 是可逆的，这使得位移反演过程是良定义的。\n\n问题要求答案四舍五入到四位有效数字。数字 $5.775$ 已经恰好有四位有效数字（$5$、$7$、$7$、$5$）。因此，无需进一步四舍五入。位移的值是 $5.775$ MeV。", "answer": "$$\\boxed{5.775}$$", "id": "3568887"}, {"introduction": "尽管估计工具有用，但核心任务是计算精确的特征值近似值。Lanczos 算法是一种功能强大的迭代方法，它能为大型对称矩阵的极端特征值生成一系列越来越精确的近似值，即里兹值（Ritz values）。在此练习 [@problem_id:3568855] 中，您将为一个离散化的薛定谔方程实施 Lanczos 过程，并学习使用残差范数来评估结果的准确性，这是后验误差估计中的一个基本概念。", "problem": "考虑一个一维单核子哈密顿量的实对称矩阵表示，该表示是通过在有界域上对不含时薛定谔算符进行有限差分离散化并施加狄利克雷边界条件得到的。哈密顿矩阵定义如下。对于给定的内部网格点数 $N \\in \\mathbb{N}$ 和半域长度 $L \\in \\mathbb{R}_{>0}$，定义一个均匀网格，其网格间距为 $h = \\dfrac{2L}{N+1}$，覆盖内部点 $x_i = -L + i h$，其中 $i \\in \\{1,2,\\dots,N\\}$。动能算符通过标准的二阶中心差分进行离散化，生成一个三对角矩阵 $T \\in \\mathbb{R}^{N \\times N}$，其对角线元素为 $T_{ii} = \\dfrac{2}{h^2}$，第一副对角线元素为 $T_{i,i+1} = T_{i+1,i} = -\\dfrac{1}{h^2}$（对所有有效索引）。施加一个深度为 $V_0 \\in \\mathbb{R}_{\\ge 0}$、半宽为 $a \\in \\mathbb{R}_{\\ge 0}$ 的方势阱，其形式为：如果 $|x| \\le a$，则 $V(x) = -V_0$；否则 $V(x) = 0$。令 $D \\in \\mathbb{R}^{N \\times N}$ 为对角矩阵，其元素为 $D_{ii} = V(x_i)$。哈密顿量为 $H = T + D \\in \\mathbb{R}^{N \\times N}$。\n\n给定一个起始向量 $b \\in \\mathbb{R}^N$ 且 $\\|b\\|_2 = 1$，其 $m$ 维 Krylov 子空间定义为 $\\mathcal{K}_m(H,b) = \\operatorname{span}\\{b, Hb, H^2 b, \\dots, H^{m-1} b\\}$。使用从 $b$ 开始的 Lanczos 构造法，得到与 $\\mathcal{K}_m(H,b)$ 的一个标准正交基相关的三对角 Rayleigh-Ritz 矩阵 $T_m \\in \\mathbb{R}^{m \\times m}$。Ritz 值是 $T_m$ 的特征值。取最小的 Ritz 值来近似 $H$ 的最小特征值。令 $\\theta_m \\in \\mathbb{R}$ 表示 $T_m$ 的最小特征值，并令 $y_m \\in \\mathbb{R}^m$ 表示相应的单位范数特征向量。将 Ritz 向量 $v_m \\in \\mathbb{R}^N$ 定义为通过 Lanczos 基将 $y_m$ 投影回全空间的结果。该 Ritz 对的残差范数为 $\\|H v_m - \\theta_m v_m\\|_2$，它可作为最低特征值近似的后验精度估计。不需要物理单位；所有数值结果均以无量纲量报告。\n\n任务：实现一个程序，对于下面指定的每个测试用例，根据 $(N,L,V_0,a)$ 构造 $H$，将 $b$ 设置为 $\\mathbb{R}^N$ 中归一化的全一向量，构建 $m$ 步 Lanczos 三对角矩阵 $T_m$，计算最小 Ritz 值 $\\theta_m$，并通过残差范数 $\\|H v_m - \\theta_m v_m\\|_2$ 估计其精度。您必须完全按照定义计算残差范数，或者使用对于以 $b$ 初始化的 Lanczos 三对角化有效的等价恒等式进行计算。所有向量范数均使用欧几里得范数。\n\n您的实现对于给定的大小必须是通用的且数值稳定的。必须按此确切顺序执行以下三个测试用例：\n\n- 情况 1：$N = 40$，$L = 10$，$V_0 = 5$，$a = 2$，$m = 8$。\n- 情况 2：$N = 80$，$L = 8$，$V_0 = 10$，$a = 0.5$，$m = 20$。\n- 情况 3：$N = 12$，$L = 1$，$V_0 = 0$，$a = 0$，$m = 12$。\n\n对于所有情况，选择 $b$ 为归一化向量，其元素为 $b_i = 1$，其中 $i \\in \\{1,2,\\dots,N\\}$。\n\n最终输出格式：您的程序应生成单行输出，包含一个配对列表，每个测试用例一个配对，按给定顺序排列。每个配对必须是 $[\\theta_m,\\rho_m]$，其中 $\\theta_m$ 是最小 Ritz 值，$\\rho_m = \\|H v_m - \\theta_m v_m\\|_2$ 是残差范数。所有浮点数必须以科学计数法打印，并精确到 $10$ 位有效数字，输出中不得有任何空格。例如，一个包含两个用例的输出将类似于 $[[1.234567890e+00,9.876543210e-05],[\\dots,\\dots]]$，但使用此问题的适当值。程序不得读取任何输入，并且必须精确打印一行。\n\n您的答案必须是一个完整的、可运行的程序。", "solution": "该问题要求确定离散化的一维单核子哈密顿量的最低近似特征值（一个 Ritz 值）及其相关精度。此分析使用 Lanczos 算法进行，这是一种杰出的 Krylov 子空间方法，特别适用于寻找大型对称矩阵的极值特征值。\n\n首先，我们规范化哈密顿矩阵 $H$ 的构造。该物理系统由不含时薛定谔方程 $\\hat{H}\\psi = E\\psi$ 建模。对于一个质量为 $M$ 的单核子在势 $V(x)$ 中的运动，其哈密顿算符为 $\\hat{H} = -\\dfrac{\\hbar^2}{2M} \\dfrac{d^2}{dx^2} + V(x)$。通过采用一个单位制，使得常数项 $\\dfrac{\\hbar^2}{2M}$ 等于 $1$，该算符简化为 $\\hat{H} = -\\dfrac{d^2}{dx^2} + V(x)$。我们在有界域 $[-L, L]$ 上的均匀网格上离散化此算符，该网格有 $N$ 个内部点，并服从狄利克雷边界条件 $\\psi(-L) = \\psi(L) = 0$。\n\n网格间距定义为 $h = \\dfrac{2L}{N+1}$，内部网格点位于 $x_i = -L + i h$，其中 $i \\in \\{1, 2, \\dots, N\\}$。二阶导数算符使用二阶中心差分格式进行近似：$\\dfrac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\approx \\dfrac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{h^2}$。这种离散化得到了动能算符的矩阵表示 $T \\in \\mathbb{R}^{N \\times N}$，其元素为：\n$$\nT_{ij} = \\begin{cases}\n    \\dfrac{2}{h^2}  \\text{if } i = j \\\\\n    -\\dfrac{1}{h^2}  \\text{if } |i - j| = 1 \\\\\n    0  \\text{otherwise}\n\\end{cases}\n$$\n势能算符由一个对角矩阵 $D \\in \\mathbb{R}^{N \\times N}$ 表示，其对角元素由势函数在网格点上的值给出，即 $D_{ii} = V(x_i)$。指定的势是深度为 $V_0$、半宽为 $a$ 的方势阱：\n$$\nV(x_i) = \\begin{cases}\n    -V_0  \\text{if } |x_i| \\le a \\\\\n    0  \\text{otherwise}\n\\end{cases}\n$$\n总的离散化哈密顿量是动能和势能矩阵之和，得到实对称矩阵 $H = T + D \\in \\mathbb{R}^{N \\times N}$。\n\n接下来，我们采用 Lanczos 算法来近似 $H$ 的特征值。该算法为 Krylov 子空间 $\\mathcal{K}_m(H, b) = \\operatorname{span}\\{b, Hb, \\dots, H^{m-1}b\\}$ 构造一个标准正交基，其中 $b$ 是一个给定的起始向量。在此过程中，它生成一个标准正交向量序列 $\\{q_j\\}_{j=1}^m$ 和一个实对称三对角矩阵 $T_m \\in \\mathbb{R}^{m \\times m}$。过程如下：\n初始化：令 $q_0 = 0 \\in \\mathbb{R}^N$，$\\beta_0 = 0$，并将起始向量 $b$ 归一化以得到 $q_1 = b / \\|b\\|_2$。\n对于 $j=1, 2, \\dots, m$：\n1. 计算矩阵向量乘积 $w_j = H q_j$。\n2. 计算 $T_m$ 的对角元素：$\\alpha_j = q_j^T w_j$。\n3. 计算未归一化的下一个向量：$\\tilde{w}_j = w_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1}$。此步骤确保 $\\tilde{w}_j$ 与 $q_j$ 和 $q_{j-1}$ 正交。这个三项递推关系是 $H$ 对称性的结果，它保证了与所有先前的基向量 $q_k$（其中 $k<j$）的正交性，前提是使用精确算术。\n4. 计算 $T_m$ 的副对角线元素：$\\beta_j = \\|\\tilde{w}_j\\|_2$。\n5. 如果 $\\beta_j=0$，则该过程停止（幸运分解）。否则，计算下一个基向量：$q_{j+1} = \\tilde{w}_j / \\beta_j$。\n\n$m$ 步之后，我们得到一个 $m \\times m$ 的三对角矩阵 $T_m$，其对角线为 $\\{\\alpha_j\\}_{j=1}^m$，副对角线为 $\\{\\beta_j\\}_{j=1}^{m-1}$。$T_m$ 的特征值被称为 Ritz 值，它们是 $H$ 的特征值的近似。我们求解小规模特征问题 $T_m y_k = \\theta_k y_k$ 来获得 Ritz 值 $\\theta_k$。特别是，我们关注最小的 Ritz 值 $\\theta_{\\text{min}}$。\n\n问题的最后一部分是计算残差范数。对于一个 Ritz 对 $(\\theta_k, v_k)$，其中 $v_k = Q_m y_k$ 是 Ritz 向量，$Q_m$ 是以 $\\{q_j\\}$ 为列的矩阵，残差范数是 $\\|H v_k - \\theta_k v_k\\|_2$。对于 Lanczos 算法，有一个极其方便的恒等式，可以高效地计算这个范数，而无需构造高维的 Ritz 向量 $v_k$：\n$$\n\\|H v_k - \\theta_k v_k\\|_2 = |\\beta_m y_{k,m}|\n$$\n其中 $y_{k,m}$ 是与 Ritz 值 $\\theta_k$ 相关的特征向量 $y_k$ 的第 $m$ 个（最后一个）分量，而 $\\beta_m$ 是 Lanczos 算法在第 $m$ 步生成的标量。此公式避免了代价高昂的高维计算，是算法优雅和高效的体现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef compute_ritz_pair(N, L, V0, a, m):\n    \"\"\"\n    Constructs the Hamiltonian, runs the Lanczos algorithm, and computes the\n    lowest Ritz value and its residual norm.\n    \"\"\"\n    # Step 1: Construct the Hamiltonian matrix H\n    h = (2.0 * L) / (N + 1.0)\n    x = np.array([-L + (i + 1.0) * h for i in range(N)])\n\n    # Kinetic energy matrix T\n    diag_T = np.full(N, 2.0 / h**2)\n    off_diag_T = np.full(N - 1, -1.0 / h**2)\n    # Using numpy's diag for constructing the matrix is robust but can be memory intensive.\n    # For very large N, a sparse matrix representation or a matrix-free approach would be used.\n    # Here, N is small enough that dense representation is fine.\n    T = np.diag(diag_T) + np.diag(off_diag_T, k=1) + np.diag(off_diag_T, k=-1)\n\n    # Potential energy matrix D\n    V_values = -V0 * (np.abs(x) = a)\n    D = np.diag(V_values)\n\n    H = T + D\n\n    # Step 2: Initialize Lanczos algorithm\n    b = np.ones(N)\n    q = b / np.linalg.norm(b)\n    q_prev = np.zeros(N)\n    beta = 0.0\n\n    alphas = []\n    betas_off_diag = []\n\n    # Step 3: Perform m iterations of Lanczos algorithm\n    for j in range(m):\n        w = H @ q\n        alpha = np.dot(w, q)\n        alphas.append(alpha)\n\n        # The three-term recurrence ensures orthogonality in exact arithmetic.\n        # In practice, reorthogonalization might be needed for stability, but not for this problem.\n        w_hat = w - alpha * q - beta * q_prev\n        beta = np.linalg.norm(w_hat)\n\n        q_prev = q\n        # Handle breakdown (beta is numerically zero)\n        if beta > 1e-15:\n            q = w_hat / beta\n        else:\n            # If breakdown occurs, subsequent beta values would be zero.\n            # beta_m will be this zero value. The loop terminates.\n            break\n\n        if j  m - 1:\n            betas_off_diag.append(beta)\n    \n    # This is beta_m needed for the residual norm calculation\n    beta_m = beta\n    \n    # If the loop broke early due to lucky breakdown, the effective size of T_m is smaller.\n    current_m = len(alphas)\n    if current_m  m:\n        # The remaining T_m entries are effectively undefined, but we need\n        # a matrix of size 'current_m'. The lists are already of the correct size.\n        pass\n    \n    # Step 4: Solve the tridiagonal eigenproblem for T_m\n    if not betas_off_diag: # handles m=1 case\n        eigvals = np.array(alphas)\n        eigvecs = np.array([[1.0]])\n    else:\n        eigvals, eigvecs = eigh_tridiagonal(np.array(alphas), np.array(betas_off_diag))\n    \n    # Step 5: Identify the smallest Ritz value and its eigenvector\n    min_eig_idx = np.argmin(eigvals)\n    theta_m = eigvals[min_eig_idx]\n    y_m = eigvecs[:, min_eig_idx]\n    \n    # Step 6: Calculate the residual norm using the efficient formula\n    # The last component of the eigenvector y_m of the matrix T of size current_m\n    y_m_last = y_m[-1] if current_m > 0 else 0.0\n    rho_m = np.abs(beta_m * y_m_last)\n\n    return theta_m, rho_m\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, V0, a, m)\n        (40, 10.0, 5.0, 2.0, 8),\n        (80, 8.0, 10.0, 0.5, 20),\n        (12, 1.0, 0.0, 0.0, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, V0, a, m = case\n        theta_m, rho_m = compute_ritz_pair(N, L, V0, a, m)\n        results.append([theta_m, rho_m])\n\n    # Final print statement in the exact required format.\n    results_str = [f\"[{val[0]:.10e},{val[1]:.10e}]\" for val in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3568855"}, {"introduction": "任何迭代算法的一个关键方面是知道何时停止。一个简陋的停止准则可能导致计算资源的浪费或结果不准确。这最后一个练习 [@problem_id:3568857] 深入探讨了鲁棒停止准则背后的理论，通过谱隙将可计算的残差范数与真实的特征值误差联系起来。通过实现一个反迭代求解器，您将看到这个理论界限如何被用于在实际应用中保证所需的精度水平。", "problem": "您的任务是为一种迭代算法设计、论证并经验性地验证其停止准则。该算法旨在求解计算核物理领域中一个一维无量纲设定下的对称正定哈密顿矩阵的基态本征值。\n\n考虑在区间 $\\left[-L, L\\right]$ 上，具有狄利克雷边界条件的均匀网格上离散化的以下无量纲哈密顿量：\n- 连续算符为 $H = -\\frac{d^2}{dx^2} + \\alpha x^2$，其中 $\\alpha  0$。\n- 使用标准的二阶中心差分离散化，包含 $N$ 个内部点，网格间距为 $h = \\frac{2L}{N+1}$。离散哈密顿量是一个对称正定矩阵 $A \\in \\mathbb{R}^{N \\times N}$，其元素为：\n  - 主对角线元素 $a_{ii} = \\frac{2}{h^2} + \\alpha x_i^2$，\n  - 次对角线元素 $a_{i,i\\pm 1} = -\\frac{1}{h^2}$，\n  - 其中 $x_i = -L + i h$，对于 $i = 1, \\dots, N$。\n\n您必须：\n1. 实现一个迭代求解器，使用基于对称本征问题第一性原理的有原则的迭代方法，来求解 $A$ 的基态（最小本征对）。在每次迭代中，对于归一化向量 $x$，计算瑞利商 $\\mu = x^\\top A x$ 和残差 $r = A x - \\mu x$。仅使用基于残差的、有数学原理支持的停止条件。\n2. 使用一个有充分理由的、依赖于谱隙的界，推导出一个停止阈值（用残差范数表示），该阈值能保证最终的能量误差 $|\\mu - \\lambda_1|$ 严格小于一个预设目标。该目标与一个独立估计的谱隙成正比。具体来说，要求最终能量误差低于独立获得的估计谱隙 $\\Delta_{\\mathrm{est}}$ 的 $10^{-10}$ 倍。\n3. 使用一个辅助的对称本征值计算来获得谱隙的独立估计值 $\\Delta_{\\mathrm{est}}$，该计算能高精度地返回 $A$ 的两个最小本征值，并将它们的差值定义为 $\\Delta_{\\mathrm{est}}$。仅使用 $\\Delta_{\\mathrm{est}}$ 来设定停止阈值和定义验证用的归一化因子。\n4. 对每个测试用例进行经验性验证，在您的迭代停止时，相对于 $\\Delta_{\\mathrm{est}}$ 的已达能量误差满足要求 $|\\mu - \\lambda_1| / \\Delta_{\\mathrm{est}} \\le 10^{-10}$，其中 $\\lambda_1$ 是由直接对称本征求解器高精度计算得出的 $A$ 的真实最小本征值。\n\n您的程序必须实现以上内容，并运行以下参数三元组 $(N, L, \\alpha)$ 的测试套件：\n- 测试 1：$(N, L, \\alpha) = (140, 8, 1)$。\n- 测试 2：$(N, L, \\alpha) = (140, 15, 0.04)$。\n- 测试 3：$(N, L, \\alpha) = (120, 6, 3)$。\n- 测试 4：$(N, L, \\alpha) = (80, 10, 0.5)$。\n\n对每个测试用例：\n- 按规定构造 $A$。\n- 使用可靠的对称本征值程序，以 $10^{-12}$ 的绝对容差精度，计算 $A$ 的两个最小本征值，从而获得谱隙的独立估计值 $\\Delta_{\\mathrm{est}}$。\n- 运行您的基态迭代求解器，使用基于第一性原理推导出的停止阈值，以确保最终能量误差低于 $10^{-10}$ 乘以 $\\Delta_{\\mathrm{est}}$。\n- 使用直接对称本征求解器高精度计算真实的最小本征值 $\\lambda_1$，然后经验性地检验不等式 $|\\mu - \\lambda_1| / \\Delta_{\\mathrm{est}} \\le 10^{-10}$ 是否成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，如果您的迭代终止时经验性不等式 $|\\mu - \\lambda_1| / \\Delta_{\\mathrm{est}} \\le 10^{-10}$ 成立，则输出布尔值 `True`，否则输出 `False`。\n- 例如，对于四个测试用例，如果所有验证都通过，一个有效的输出形式为 $\\left[\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True}\\right]$。\n\n程序不应读取任何用户输入；所有参数均如上固定。不涉及角度。此无量纲化公式中没有物理单位。请确保数值实现对于所有四个测试都是稳定且科学合理的。", "solution": "该问题是有效的，因为它具有科学依据、问题适定且客观。它为计算量子力学和数值线性代数中的一个标准问题提供了完整且一致的设定。其中没有矛盾、歧义或违反科学原理之处。\n\n任务是找到离散化的一维量子谐振子哈密顿量 $H = -\\frac{d^2}{dx^2} + \\alpha x^2$ 的基态本征值，并为一个迭代求解器验证一个基于残差的停止准则。\n\n首先，我们将离散哈密顿矩阵 $A$ 形式化。定义域为区间 $[-L, L]$，用 $N$ 个内部点离散化。网格间距为 $h = \\frac{2L}{N+1}$。网格点为 $x_i = -L + i h$，其中 $i = 1, \\dots, N$。二阶导数算符 $-\\frac{d^2}{dx^2}$ 使用二阶中心差分格式来近似，这会产生一个三对角矩阵，其元素为 $(-\\frac{1}{h^2}, \\frac{2}{h^2}, -\\frac{1}{h^2})$。势能项 $\\alpha x^2$ 贡献一个对角矩阵。将它们结合起来，离散哈密顿量 $A \\in \\mathbb{R}^{N \\times N}$ 是一个对称三对角矩阵，其元素为：\n$$\na_{ij} =\n\\begin{cases}\n\\frac{2}{h^2} + \\alpha x_i^2  \\text{if } i = j \\\\\n-\\frac{1}{h^2}  \\text{if } |i - j| = 1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n由于 $\\alpha  0$，连续算符是正定的，其离散表示 $A$ 也是一个对称正定（SPD）矩阵。\n\n问题要求使用一种有原则的迭代方法来找到 $A$ 的最小本征值 $\\lambda_1$。完成此任务的一个合适选择是带有零位移的逆迭代法。对于一个 SPD 矩阵，所有本征值均为正，即 $\\lambda_1  0$。逆迭代法寻找最接近给定平移量 $\\sigma$ 的本征值。通过选择 $\\sigma=0$，该算法会收敛到与最小本征值 $\\lambda_1$ 对应的本征向量。算法流程如下：\n1. 从一个随机的归一化向量 $x_0$ 开始。\n2. 对于每次迭代 $k = 1, 2, \\dots$：\n   a. 求解线性系统 $A y_k = x_{k-1}$ 以得到 $y_k$。\n   b. 归一化所得向量：$x_k = y_k / \\|y_k\\|_2$。\n向量 $x_k$ 收敛到与 $\\lambda_1$ 相关的本征向量 $v_1$。\n\n问题的核心是推导一个停止准则。在每次迭代中，我们计算瑞利商 $\\mu_k = x_k^\\top A x_k$（本征值的估计值）和残差向量 $r_k = A x_k - \\mu_k x_k$。问题要求一个基于残差范数 $\\|r_k\\|_2$ 的停止准则，以保证最终能量误差 $|\\mu - \\lambda_1|$ 低于一个目标值。\n\n对于对称矩阵 $A$，Kaniel-Paige 不等式提供了一个强大的界，该界将瑞利商的误差与残差范数联系起来：\n$$\n|\\mu_k - \\lambda_1| \\le \\frac{\\|r_k\\|_2^2}{\\text{gap}(\\mu_k)}\n$$\n其中 $\\text{gap}(\\mu_k) = \\min_{j: \\lambda_j \\neq \\lambda_1} |\\lambda_j - \\mu_k|$。随着迭代的收敛，迭代向量 $x_k$ 接近真实的本征向量 $v_1$，其瑞利商 $\\mu_k$ 接近真实的本征值 $\\lambda_1$。因此，间隙项 $\\text{gap}(\\mu_k)$ 接近于第一和第二本征值之间的真实谱隙 $\\Delta = \\lambda_2 - \\lambda_1$。因此，对于一个充分收敛的迭代向量，我们有以下近似：\n$$\n|\\mu_k - \\lambda_1| \\approx \\frac{\\|r_k\\|_2^2}{\\Delta}\n$$\n问题为最终能量误差指定了一个目标：$|\\mu - \\lambda_1| \\le \\epsilon_{\\text{target}}$，其中 $\\epsilon_{\\text{target}} = 10^{-10} \\Delta_{\\text{est}}$。在此，$\\Delta_{\\text{est}}$ 是谱隙的一个独立的、高精度的估计值，$\\Delta_{\\text{est}} = \\tilde{\\lambda}_2 - \\tilde{\\lambda}_1$。\n\n为确保我们的误差满足此目标，我们强制执行从该界推导出的条件：\n$$\n\\frac{\\|r_k\\|_2^2}{\\Delta_{\\text{est}}} \\le 10^{-10} \\Delta_{\\text{est}}\n$$\n整理这个不等式，得到一个关于残差范数平方的条件：\n$$\n\\|r_k\\|_2^2 \\le 10^{-10} \\Delta_{\\text{est}}^2\n$$\n对两边取平方根，得到我们迭代求解器的最终停止准则：\n$$\n\\|r_k\\|_2 \\le 10^{-5} \\Delta_{\\text{est}}\n$$\n这是一个有数学原理支持的、基于残差的停止阈值，它直接依赖于矩阵的谱特性，符合题目要求。\n\n实现计划如下：\n1. 对于每个测试用例 $(N, L, \\alpha)$，构造对称三对角矩阵 $A$。\n2. 获取谱隙的独立估计值 $\\Delta_{\\text{est}}$。这通过使用专门的程序（如 `scipy.sparse.linalg.eigsh(A, k=2, which='SM')`）高精度计算 $A$ 的两个最小本征值来完成。$\\Delta_{\\text{est}}$ 是这两个本征值之差。\n3. 实现逆迭代算法。为了在每一步高效地求解系统 $A y_k = x_{k-1}$，我们预先计算 $A$ 的 Cholesky 分解（$A = C^\\top C$），对于 SPD 矩阵，该方法是数值稳定且高效的。然后通过两次三角代换来求解该系统。\n4. 迭代持续进行，直到残差范数 $\\|r_k\\|_2$ 小于推导出的阈值 $10^{-5} \\Delta_{\\text{est}}$。记录最终的瑞利商 $\\mu$。\n5. 最后，为了验证，使用直接的高精度求解器 `scipy.linalg.eigvalsh` 计算“真实”的最小本征值 $\\lambda_1$。然后检验经验验证条件 $|\\mu - \\lambda_1| / \\Delta_{\\text{est}} \\le 10^{-10}$ 是否成立。此检验的布尔结果即为该测试用例的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cho_factor, cho_solve, eigvalsh\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Main function to run the validation for the specified test cases.\n    \"\"\"\n    test_cases = [\n        (140, 8, 1),\n        (140, 15, 0.04),\n        (120, 6, 3),\n        (80, 10, 0.5),\n    ]\n\n    results = []\n\n    for N, L, alpha in test_cases:\n        # Step 1: Construct the Hamiltonian matrix A\n        h = 2 * L / (N + 1)\n        x_grid = np.linspace(-L + h, L - h, N)\n        \n        main_diag = 2 / h**2 + alpha * x_grid**2\n        off_diag = -1 / h**2 * np.ones(N - 1)\n        \n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # Step 2: Obtain an independent estimate of the spectral gap\n        # Use a high-accuracy sparse eigensolver to find the 2 smallest eigenvalues.\n        # We set tol=1e-14 to ensure accuracy well beyond the problem's 1e-12 requirement.\n        try:\n            est_eigvals = eigsh(A, k=2, which='SM', tol=1e-14)[0]\n        except Exception:\n            # eigsh can sometimes fail; fall back to a dense solver\n            est_eigvals = eigvalsh(A, subset_by_index=[0, 1])\n\n        est_eigvals.sort()\n        lambda1_est, lambda2_est = est_eigvals\n        delta_est = lambda2_est - lambda1_est\n\n        # Step 3: Run the iterative solver (Inverse Iteration) with the derived stopping criterion\n        stop_threshold = 1e-5 * delta_est\n\n        # Pre-compute the Cholesky factorization for efficient solves\n        c, low = cho_factor(A, lower=True)\n\n        # Initialize with a random vector\n        rng = np.random.default_rng(seed=(N * L * int(alpha*100)))\n        x_k = rng.random(size=N)\n        x_k /= np.linalg.norm(x_k)\n\n        final_mu = 0.0\n        max_iter = 200 # Sufficient for convergence in all test cases\n        \n        for _ in range(max_iter):\n            # Inverse iteration step: Solve Ay = x_k\n            y_k = cho_solve((c, low), x_k)\n            \n            # Normalize to get the next iterate\n            x_k = y_k / np.linalg.norm(y_k)\n\n            # Compute Rayleigh quotient and residual\n            Ax_k = A @ x_k\n            mu_k = np.dot(x_k.T, Ax_k)\n            r_k = Ax_k - mu_k * x_k\n            norm_r = np.linalg.norm(r_k)\n\n            # Check stopping criterion\n            if norm_r  stop_threshold:\n                final_mu = mu_k\n                break\n        else:\n             # This block executes if the loop completes without breaking\n             # Indicates failure to converge within max_iter\n             final_mu = mu_k # Use the last computed value\n\n        # Step 4: Empirically verify the error bound\n        # Compute the \"true\" ground-state eigenvalue using a direct solver\n        true_lambda1 = eigvalsh(A, subset_by_index=[0, 0])[0]\n\n        # Check if the final energy error satisfies the required inequality\n        achieved_error_ratio = np.abs(final_mu - true_lambda1) / delta_est\n        is_verified = achieved_error_ratio = 1e-10\n        results.append(is_verified)\n\n    # Final output format. Using str.lower() to get \"true/false\" from Python's \"True/False\"\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\n# The problem requires True/False, not true/false. Re-checking the example.\n# Example: `[True,True,True,True]`. So Python's default `str(bool)` is correct.\n# Reverting the string conversion to the simpler form.\ndef solve_correct_output():\n    # ... (same code as above)\n    results = []\n\n    for N, L, alpha in test_cases:\n        # Step 1: Construct the Hamiltonian matrix A\n        h = 2 * L / (N + 1)\n        x_grid = np.linspace(-L + h, L - h, N)\n        main_diag = 2 / h**2 + alpha * x_grid**2\n        off_diag = -1 / h**2 * np.ones(N - 1)\n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # Step 2: Get spectral gap estimate\n        try:\n            est_eigvals = eigsh(A, k=2, which='SM', tol=1e-14)[0]\n        except Exception:\n            est_eigvals = eigvalsh(A, subset_by_index=[0, 1])\n        est_eigvals.sort()\n        delta_est = est_eigvals[1] - est_eigvals[0]\n\n        # Step 3: Run iterative solver\n        stop_threshold = 1e-5 * delta_est\n        c, low = cho_factor(A, lower=True)\n        rng = np.random.default_rng(seed=(N * L * int(alpha*100)))\n        x_k = rng.random(size=N)\n        x_k /= np.linalg.norm(x_k)\n        final_mu = 0.0\n        max_iter = 200\n        for _ in range(max_iter):\n            y_k = cho_solve((c, low), x_k)\n            x_k = y_k / np.linalg.norm(y_k)\n            Ax_k = A @ x_k\n            mu_k = np.dot(x_k, Ax_k)\n            r_k = Ax_k - mu_k * x_k\n            if np.linalg.norm(r_k)  stop_threshold:\n                final_mu = mu_k\n                break\n        else:\n             final_mu = mu_k\n\n        # Step 4: Verification\n        true_lambda1 = eigvalsh(A, subset_by_index=[0, 0])[0]\n        achieved_error_ratio = np.abs(final_mu - true_lambda1) / delta_est\n        is_verified = achieved_error_ratio = 1e-10\n        results.append(is_verified)\n    \n    # Example format is [True,True,True,True], so map(str, results) is correct.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The provided code block in the answer tag must be a single runnable block.\n# The thought process of correcting the output format is internal.\n# The final code should be the correct one.\n# After re-reading the problem, the example format is [True,True,True,True]. Python's `str` on a boolean is 'True' or 'False'. So `map(str, results)` is correct.\n# So I will just use the final, corrected code block.\n```\nimport numpy as np\nfrom scipy.linalg import cho_factor, cho_solve, eigvalsh\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Main function to run the validation for the specified test cases.\n    \"\"\"\n    test_cases = [\n        (140, 8, 1),\n        (140, 15, 0.04),\n        (120, 6, 3),\n        (80, 10, 0.5),\n    ]\n\n    results = []\n\n    for N, L, alpha in test_cases:\n        # Step 1: Construct the Hamiltonian matrix A\n        h = 2 * L / (N + 1)\n        x_grid = np.linspace(-L + h, L - h, N)\n        \n        main_diag = 2 / h**2 + alpha * x_grid**2\n        off_diag = -1 / h**2 * np.ones(N - 1)\n        \n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n        # Step 2: Obtain an independent estimate of the spectral gap\n        # Use a high-accuracy sparse eigensolver to find the 2 smallest eigenvalues.\n        # We set tol=1e-14 to ensure accuracy well beyond the problem's 1e-12 requirement.\n        try:\n            est_eigvals = eigsh(A, k=2, which='SM', tol=1e-14)[0]\n        except Exception:\n            # eigsh can sometimes fail; fall back to a dense solver\n            est_eigvals = eigvalsh(A, subset_by_index=[0, 1])\n\n        est_eigvals.sort()\n        lambda1_est, lambda2_est = est_eigvals\n        delta_est = lambda2_est - lambda1_est\n\n        # Step 3: Run the iterative solver (Inverse Iteration) with the derived stopping criterion\n        stop_threshold = 1e-5 * delta_est\n\n        # Pre-compute the Cholesky factorization for efficient solves\n        c, low = cho_factor(A, lower=True)\n\n        # Initialize with a random vector\n        rng = np.random.default_rng(seed=(N * L * int(alpha*100)))\n        x_k = rng.random(size=N)\n        x_k /= np.linalg.norm(x_k)\n\n        final_mu = 0.0\n        max_iter = 200 # Sufficient for convergence in all test cases\n        \n        for _ in range(max_iter):\n            # Inverse iteration step: Solve Ay = x_k\n            y_k = cho_solve((c, low), x_k)\n            \n            # Normalize to get the next iterate\n            x_k = y_k / np.linalg.norm(y_k)\n\n            # Compute Rayleigh quotient and residual\n            Ax_k = A @ x_k\n            mu_k = np.dot(x_k.T, Ax_k)\n            r_k = Ax_k - mu_k * x_k\n            norm_r = np.linalg.norm(r_k)\n\n            # Check stopping criterion\n            if norm_r  stop_threshold:\n                final_mu = mu_k\n                break\n        else:\n             # This block executes if the loop completes without breaking\n             # Indicates failure to converge within max_iter\n             final_mu = mu_k # Use the last computed value\n\n        # Step 4: Empirically verify the error bound\n        # Compute the \"true\" ground-state eigenvalue using a direct solver\n        true_lambda1 = eigvalsh(A, subset_by_index=[0, 0])[0]\n\n        # Check if the final energy error satisfies the required inequality\n        achieved_error_ratio = np.abs(final_mu - true_lambda1) / delta_est\n        is_verified = achieved_error_ratio = 1e-10\n        results.append(is_verified)\n\n    # Final output format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3568857"}]}