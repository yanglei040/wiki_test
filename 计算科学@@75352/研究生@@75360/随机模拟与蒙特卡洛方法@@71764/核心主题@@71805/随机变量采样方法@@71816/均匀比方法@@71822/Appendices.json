{"hands_on_practices": [{"introduction": "要真正掌握均匀比方法，最好的起点是分析一个典型的案例。标准正态分布因其在数学上的易处理性和在统计学中的核心地位，成为了理想的练手对象。通过这个练习，你将完整地推导出其接受域 $A$ 的精确几何形状和最小边界矩形，从而对该方法的工作原理建立起具体而深入的直观认识。[@problem_id:3356654]", "problem": "考虑使用均匀比构造法，从实数线上由 $f(x)\\propto \\exp(-x^{2}/2)$ 给出的未归一化目标概率密度函数 (PDF) 中进行采样。在均匀比方法中，我们在 $(u,v)$-平面中的一个集合 $A$ 上进行均匀采样，并对于 $u>0$ 返回 $x=v/u$。仅从 $u>0$ 时的定义变量变换 $(x,u)\\mapsto (u,v)=(u,ux)$ 和确保目标密度与 $x$ 的边际密度成正比的可接纳条件出发，完成以下任务：\n\n1. 针对此目标，推导在 $(u,v)$-平面中描述可接纳集 $A$ 的精确解析不等式。\n2. 通过计算 $\\max u$ 和 $\\max|v|$，确定 $A$ 的紧凑轴对齐边界矩形。\n3. 计算在该边界矩形上均匀提出样本点，并且当且仅当提出的点位于 $A$ 中时接受该点的算法的精确接受概率。\n4. 在使用方差参数为 $\\sigma^{2}>0$ 的高斯提议分布 $q_{\\sigma}(x)=(2\\pi\\sigma^{2})^{-1/2}\\exp(-x^{2}/(2\\sigma^{2}))$ 的经典拒绝采样中，针对相同的未归一化目标 $f(x)\\propto \\exp(-x^{2}/2)$，找到能最小化拒绝界限的 $\\sigma$ 的选择和最小优函数常数 $M$，并计算相应的接受概率。\n\n将你的最终答案表示为一个单行矩阵（使用圆括号表示法），按顺序包含：$A$ 的解析描述、$\\max u$、$\\max|v|$、均匀比边界矩形方案的接受概率，以及最优高斯提议拒绝采样的接受概率。请给出精确表达式，不要进行数值近似。无需四舍五入，也不涉及物理单位。如果涉及角度，请用弧度表示。", "solution": "该问题是良定的，有科学依据，并包含了得到唯一解所需的所有信息。我们将按顺序处理四个部分。未归一化的目标概率密度函数由 $f(x) \\propto \\exp(-x^2/2)$ 给出。为了确定性且不失一般性，对于均匀比方法，我们选择特定的代表函数 $h(x) = \\exp(-x^2/2)$。\n\n首先，我们推导可接纳集 $A$ 的解析描述。均匀比方法从 $(u,v)$-平面中由下式定义的集合 $A$ 中均匀采样点 $(u,v)$：\n$$ A = \\left\\{ (u, v) \\in \\mathbb{R}^2 \\mid 0  u \\le \\sqrt{h(v/u)} \\right\\} $$\n将我们选择的 $h(x)$ 代入，得到：\n$$ 0  u \\le \\sqrt{\\exp\\left(-\\frac{(v/u)^2}{2}\\right)} $$\n这可以简化为：\n$$ 0  u \\le \\exp\\left(-\\frac{v^2}{4u^2}\\right) $$\n由于 $u > 0$，我们可以对不等式 $u \\le \\exp(-v^2/(4u^2))$ 两边取自然对数：\n$$ \\ln(u) \\le -\\frac{v^2}{4u^2} $$\n我们重新整理以分离出 $v^2$，两边乘以 $-4u^2$（这是一个负数，所以必须反转不等号）：\n$$ -4u^2 \\ln(u) \\ge v^2 $$\n即：\n$$ v^2 \\le -4u^2 \\ln(u) $$\n为了使这个不等式对于 $v \\in \\mathbb{R}$ 有解，右边必须是非负的。由于 $u^2 > 0$，我们需要 $-4\\ln(u) \\ge 0$，这意味着 $\\ln(u) \\le 0$。这对于 $u \\in (0, 1]$ 成立。因此，集合 $A$ 由以下条件描述：\n$$ 0  u \\le 1 \\quad \\text{and} \\quad v^2 \\le -4u^2 \\ln(u) $$\n\n第二，我们确定 $A$ 的紧凑轴对齐边界矩形。这需要找到集合 $A$ 上 $u$ 和 $|v|$ 的最大值。\n根据上面的推导，$u$ 的范围是 $(0, 1]$，所以 $u$ 的最大值是：\n$$ \\max u = 1 $$\n为了找到 $|v|$ 的最大值，我们需要在区间 $u \\in (0, 1]$ 上最大化表达式 $\\sqrt{-4u^2 \\ln(u)}$。这等价于最大化它的平方，即函数 $g(u) = -4u^2 \\ln(u)$。我们通过对 $u$求导并令其为零来找到最大值：\n$$ g'(u) = \\frac{d}{du}\\left(-4u^2 \\ln(u)\\right) = -4\\left(2u\\ln(u) + u^2\\frac{1}{u}\\right) = -4u(2\\ln(u) + 1) $$\n对于 $u \\in (0, 1]$，令 $g'(u) = 0$ 意味着 $2\\ln(u) + 1 = 0$，这给出 $\\ln(u) = -1/2$，所以 $u = \\exp(-1/2)$。\n为了确认这是一个最大值，我们可以检查二阶导数，或者注意到当 $u  \\exp(-1/2)$ 时 $g'(u) > 0$，当 $u > \\exp(-1/2)$ 时 $g'(u)  0$。函数 $g(u)$ 在端点 $u \\to 0^+$ 和 $u=1$ 处的值为 0。因此，全局最大值出现在 $u = \\exp(-1/2)$ 处。\n$g(u)$ 的最大值是：\n$$ g(\\exp(-1/2)) = -4(\\exp(-1/2))^2 \\ln(\\exp(-1/2)) = -4\\exp(-1)\\left(-\\frac{1}{2}\\right) = 2\\exp(-1) $$\n这是 $v^2$ 的最大值。因此， $|v|$ 的最大值是：\n$$ \\max|v| = \\sqrt{2\\exp(-1)} $$\n边界矩形是 $R = [0, 1] \\times [-\\sqrt{2\\exp(-1)}, \\sqrt{2\\exp(-1)}]$。\n\n第三，我们计算算法的接受概率。这是集合 $A$ 的面积与边界矩形 $R$ 的面积之比。\n边界矩形的面积是：\n$$ \\text{Area}(R) = (\\max u) \\times (2 \\max|v|) = 1 \\cdot 2\\sqrt{2\\exp(-1)} = 2\\sqrt{2\\exp(-1)} $$\n集合 $A$ 的面积由积分给出：\n$$ \\text{Area}(A) = \\iint_A du\\,dv = \\int_0^1 \\left( \\int_{-\\sqrt{-4u^2\\ln(u)}}^{\\sqrt{-4u^2\\ln(u)}} dv \\right) du = \\int_0^1 2\\sqrt{-4u^2\\ln(u)} \\,du = \\int_0^1 4u\\sqrt{-\\ln(u)} \\,du $$\n为了计算这个积分，我们使用换元法，令 $t = -\\ln(u)$，这意味着 $u = \\exp(-t)$ 且 $du = -\\exp(-t)dt$。积分上下限从 $u \\in (0, 1]$ 变为 $t \\in [\\infty, 0)$。\n$$ \\text{Area}(A) = \\int_\\infty^0 4\\exp(-t)\\sqrt{t} (-\\exp(-t)dt) = \\int_0^\\infty 4\\sqrt{t} \\exp(-2t) dt $$\n我们进行另一次换元，令 $s=2t$，所以 $t=s/2$ 且 $dt=ds/2$。\n$$ \\text{Area}(A) = \\int_0^\\infty 4\\sqrt{s/2} \\exp(-s) \\frac{ds}{2} = \\frac{4}{\\sqrt{2} \\cdot 2} \\int_0^\\infty s^{1/2} \\exp(-s) ds = \\sqrt{2} \\int_0^\\infty s^{3/2 - 1} \\exp(-s) ds $$\n该积分是伽马函数 $\\Gamma(3/2)$。使用 $\\Gamma(z+1)=z\\Gamma(z)$ 和 $\\Gamma(1/2)=\\sqrt{\\pi}$，我们有 $\\Gamma(3/2) = \\frac{1}{2}\\Gamma(1/2) = \\frac{\\sqrt{\\pi}}{2}$。\n$$ \\text{Area}(A) = \\sqrt{2} \\cdot \\frac{\\sqrt{\\pi}}{2} = \\frac{\\sqrt{2\\pi}}{2} $$\n接受概率 $P_{\\text{acc, RoU}}$ 是：\n$$ P_{\\text{acc, RoU}} = \\frac{\\text{Area}(A)}{\\text{Area}(R)} = \\frac{\\sqrt{2\\pi}/2}{2\\sqrt{2\\exp(-1)}} = \\frac{\\sqrt{2\\pi}}{4\\sqrt{2}\\sqrt{\\exp(-1)}} = \\frac{\\sqrt{\\pi}}{4}\\sqrt{\\exp(1)} = \\frac{\\sqrt{\\pi \\exp(1)}}{4} $$\n\n第四，我们分析拒绝采样方案。未归一化的目标是 $p^*(x) = \\exp(-x^2/2)$。提议分布是归一化的高斯密度 $q_{\\sigma}(x) = (2\\pi\\sigma^2)^{-1/2}\\exp(-x^2/(2\\sigma^2))$，其中 $\\sigma^2>0$。拒绝采样需要找到一个常数 $M$ 使得对所有 $x$都有 $p^*(x) \\le Mq_{\\sigma}(x)$。为了最大化接受率，我们必须找到这样的 $M$ 的最小值。\n$$ M = \\sup_{x \\in \\mathbb{R}} \\frac{p^*(x)}{q_{\\sigma}(x)} = \\sup_{x \\in \\mathbb{R}} \\frac{\\exp(-x^2/2)}{(2\\pi\\sigma^2)^{-1/2}\\exp(-x^2/(2\\sigma^2))} = \\sup_{x \\in \\mathbb{R}} \\sqrt{2\\pi\\sigma^2} \\exp\\left(x^2\\left(\\frac{1}{2\\sigma^2} - \\frac{1}{2}\\right)\\right) $$\n为了使 $M$ 为有限值，指数项必须为非正数，即 $\\frac{1}{2\\sigma^2} - \\frac{1}{2} \\le 0$，简化为 $\\sigma^2 \\ge 1$。\n如果 $\\sigma^2 > 1$，指数为负，表达式的上确界在 $x=0$ 处取得，给出 $M(\\sigma^2) = \\sqrt{2\\pi\\sigma^2}$。\n如果 $\\sigma^2 = 1$，指数为零，表达式为常数，$M(1) = \\sqrt{2\\pi}$。\n我们想找到使 $M$ 最小化的 $\\sigma$ 的选择。对于 $\\sigma^2 \\ge 1$，函数 $M(\\sigma^2) = \\sqrt{2\\pi\\sigma^2}$ 是关于 $\\sigma^2$ 的增函数。因此，其最小值在可能的最低值 $\\sigma^2=1$ 处取得。\n最优选择是 $\\sigma=1$，这得到最小优函数常数 $M = \\sqrt{2\\pi}$。\n拒绝采样的接受概率由公式 $P_{\\text{acc, RS}} = \\frac{\\int_{-\\infty}^{\\infty} p^*(x) dx}{M}$ 给出。\n未归一化目标的积分是一个标准高斯积分：\n$$ \\int_{-\\infty}^{\\infty} p^*(x) dx = \\int_{-\\infty}^{\\infty} \\exp(-x^2/2) dx = \\sqrt{2\\pi} $$\n因此，最优接受概率是：\n$$ P_{\\text{acc, RS}} = \\frac{\\sqrt{2\\pi}}{M} = \\frac{\\sqrt{2\\pi}}{\\sqrt{2\\pi}} = 1 $$\n这个结果是符合预期的，因为选择 $\\sigma=1$ 意味着提议分布与归一化的目标分布完全相同，从而将拒绝采样变成了直接采样。\n\n将四个所求的量汇总作为最终答案。\n1. $A$ 的解析描述: $0  u \\le 1 \\land v^2 \\le -4u^2\\ln(u)$\n2. $\\max u$: $1$\n3. $\\max|v|$: $\\sqrt{2\\exp(-1)}$\n4. 接受概率（均匀比）： $\\frac{\\sqrt{\\pi \\exp(1)}}{4}$\n5. 接受概率（拒绝采样）：$1$", "answer": "$$ \\boxed{ \\pmatrix{ 0  u \\le 1 \\land v^2 \\le -4u^2\\ln(u)  1  \\sqrt{2\\exp(-1)}  \\frac{\\sqrt{\\pi \\exp(1)}}{4}  1 } } $$", "id": "3356654"}, {"introduction": "在实际应用中，大多数目标概率密度函数并不像标准正态分布那样友好，我们往往无法解析地求出边界矩形。这个练习将带你进入一个更现实的场景：我们只能通过一个“神谕”（oracle）来获取对数密度及其导数的值。你将学习如何为对数凹密度函数设计一个稳健的数值算法来寻找边界矩形参数，从而搭建起从理论要求到实际执行的关键桥梁。[@problem_id:3356655]", "problem": "考虑一个一维、严格为正、可积的目标密度函数，该函数定义在实数轴上，且仅通过一个预言机（oracle）来描述，该预言机返回其未归一化的对数密度及其梯度。形式上，令 $g(x) \\propto f(x)$ 表示该密度的一个未归一化版本，并记 $\\ell(x) = \\log g(x)$。给定对 $\\ell(x)$ 和 $\\ell'(x)$ 的预言机访问权限，以及一个常数 $L \\in (0,\\infty)$，使得 $\\ell'(x)$ 是 $L$-利普希茨连续的，即对于所有 $x,y \\in \\mathbb{R}$，有 $\\lvert \\ell'(x) - \\ell'(y) \\rvert \\le L \\lvert x-y \\rvert$。在整个问题中，假设 $\\ell$ 是凹函数（对数凹目标），在 $\\mathbb{R}$ 上二次连续可微，且 $g$ 在 $\\mathbb{R}$ 上可积，因此该对数密度函数有唯一的最大值点。\n\n用于一维模拟的均匀比值法（ratio-of-uniforms）构造需要通过一个简单的矩形来界定可接受点对的集合。这个矩形可以使用以下量来选择：\n- $S_0 = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$，\n- $S_1 = \\sup_{x \\in \\mathbb{R}} \\lvert x \\rvert \\sqrt{g(x)}$。\n\n你的任务是推导、论证并实现一个稳健的数值方案，该方案仅使用 $\\ell$ 和 $\\ell'$ 以及利普希茨常数 $L$ 来高精度地计算 $S_0$ 和 $S_1$。你的推导必须从 $\\ell$ 的凹性和 $\\ell'$ 的利普希茨连续性出发，必须论证最大值点的存在性和唯一性，并为该数值方案提供非渐近的误差保证。\n\n具体来说，完成以下任务：\n1. 推导一个基于原理的全局区间套定与二分法方案，以定位：\n   - $\\ell(x)$ 的唯一最大值点 $x_\\star$，以及\n   - 函数 $r(x) = \\ell(x) + 2 \\log \\lvert x \\rvert$ 在区间 $(0,\\infty)$ 和 $(-\\infty,0)$ 上位于原点两侧的唯一最大值点。\n   你的推导必须证明在给定假设下，$x_\\star$ 是良定义且唯一的，并且 $r$ 在 $(0,\\infty)$ 和 $(-\\infty,0)$ 上的最大值点是良定义且唯一的。\n2. 根据区间套定与二分法方案，推导目标函数值的显式误差界：\n   - 证明如果 $x_\\star$ 的套定区间宽度为 $\\delta_x$，那么在二分点处目标函数 $\\ell$ 的误差由一个依赖于 $L$ 和 $\\delta_x$ 的量所界定。\n   - 证明如果 $r$ 的最大值点的套定区间不跨越原点，宽度为 $\\delta_x$，且与原点的最小绝对距离为 $a = \\min_{x \\text{ in bracket}} \\lvert x \\rvert$，那么在二分点处目标函数 $r$ 的误差由一个依赖于 $L$、$a$ 和 $\\delta_x$ 的量所界定。\n   使用这些界，为 $S_0 = \\exp(\\tfrac{1}{2}\\sup_x \\ell(x))$ 和 $S_1 = \\exp(\\tfrac{1}{2}\\sup_x r(x))$ 提供乘性误差保证。\n3. 在一个单一程序中实现你的方案，该程序仅使用预言机 $\\ell$ 和 $\\ell'$ 以及 $L$ 来计算 $S_0$ 和 $S_1$ 的数值近似。\n\n测试套件。你的程序必须为以下三个由预言机定义的对数凹目标计算 $S_0$ 和 $S_1$（每种情况都指定了 $\\ell$、$\\ell'$ 和 $L$）：\n\n- 情况 A（标准正态分布，未归一化）：\n  - $\\ell(x) = -\\tfrac{1}{2} x^2$,\n  - $\\ell'(x) = -x$,\n  - $L = 1$。\n- 情况 B（逻辑斯谛分布，已归一化）：\n  - $\\ell(x) = -x - 2 \\log\\!\\bigl(1 + e^{-x}\\bigr)$,\n  - $\\ell'(x) = -1 + \\dfrac{2}{1 + e^{x}}$,\n  - $L = \\tfrac{1}{2}$。\n- 情况 C（均值为 $\\mu = 1.5$、标准差为 $\\sigma = 0.5$ 的正态分布，未归一化）：\n  - $\\ell(x) = -\\dfrac{(x - \\mu)^2}{2 \\sigma^2} = -\\dfrac{(x - 1.5)^2}{0.5}$,\n  - $\\ell'(x) = -\\dfrac{x - \\mu}{\\sigma^2} = -\\dfrac{x - 1.5}{0.25} = -4(x-1.5)$,\n  - $L = \\dfrac{1}{\\sigma^2} = 4$。\n\n数值要求和保证：\n- 你的方案必须对一阶导数使用全局有效的区间套定与二分法，以定位唯一的临界点，利用凹性保证唯一性，并利用利普希茨连续性获得目标误差界。\n- 在求根时，对 $x$ 使用 $\\delta_x = 10^{-12}$ 的二分法容差。使用你推导的基于曲率的目标误差界，来验证计算点上 $\\ell$ 和 $r$ 的目标误差，并将这些误差传递到 $S_0$ 和 $S_1$ 的乘性误差界。你不需要打印误差界，但你的代码必须遵守能确保这些目标误差保证的停止规则。\n\n最终输出格式：\n- 对于情况 A、B、C 中的每一种，使用你的方案计算点对 $(S_0, S_1)$。\n- 你的程序应生成单行输出，其中包含按以下顺序排列的六个浮点数结果：$[S_{0,\\mathrm{A}}, S_{1,\\mathrm{A}}, S_{0,\\mathrm{B}}, S_{1,\\mathrm{B}}, S_{0,\\mathrm{C}}, S_{1,\\mathrm{C}}]$。该行必须是一个用方括号括起来的逗号分隔列表，不含任何额外文本。没有物理单位。不涉及角度。不要使用百分号；所有数字必须打印为十进制浮点值。", "solution": "当前问题要求我们设计并实现一个数值方案，用于计算一维均匀比值（ratio-of-uniforms）采样方法所需的边界常数 $S_0$ 和 $S_1$。这些常数定义为 $S_0 = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$ 和 $S_1 = \\sup_{x \\in \\mathbb{R}} \\lvert x \\rvert \\sqrt{g(x)}$，其中 $g(x)$ 是一个未归一化、严格为正、可积的目标密度函数。我们被提供了对对数密度 $\\ell(x) = \\log g(x)$ 及其导数 $\\ell'(x)$ 的预言机访问权限。关键假设是 $\\ell(x)$ 是凹函数且二次连续可微，其导数 $\\ell'(x)$ 对于一个已知的常数 $L > 0$ 是 $L$-利普希茨连续的。\n\n我们的推导和实现将分三个阶段进行：首先，我们分析计算 $S_0$ 和 $S_1$ 的优化问题的结构，并证明相关最大值点的存在性和唯一性。其次，我们基于这些性质开发一个稳健的数值算法。第三，我们为该算法推导非渐近误差界。\n\n**1. 最大化问题分析**\n\n计算 $S_0$ 和 $S_1$ 等价于找到从 $\\ell(x)$ 导出的某些函数的上确界。\n\n**1.1. $S_0$ 的最大值点**\n常数 $S_0$ 定义为 $S_0 = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$。这等价于找到 $g(x)$ 的最大值，或者更方便地，找到 $\\ell(x) = \\log g(x)$ 的最大值，因为对数函数是严格递增的。令 $x_\\star$ 为 $\\ell(x)$ 的最大值点。那么 $S_0 = \\sqrt{g(x_\\star)} = \\exp(\\frac{1}{2}\\ell(x_\\star))$。\n\n为了找到 $x_\\star$，我们通过求解 $\\ell'(x_\\star)=0$ 来寻找一个临界点。\n*   **存在性与唯一性**：函数 $\\ell(x)$ 是凹的，这意味着其二阶导数满足 $\\ell''(x) \\le 0$。附加假设 $g(x) = \\exp(\\ell(x))$ 在 $\\mathbb{R}$ 上可积，意味着当 $\\lvert x \\rvert \\to \\infty$ 时，$\\ell(x) \\to -\\infty$。一个在 $\\mathbb{R}$ 上连续且在两端趋于 $-\\infty$ 的函数必定会达到一个全局最大值。由于 $\\ell(x)$ 可微，这个最大值必定出现在 $\\ell'(x)=0$ 的临界点上。\n    为证明唯一性，考虑导数 $\\ell'(x)$。它的导数是 $\\ell''(x) \\le 0$。由于 $g(x)$ 必须是一个（在归一化意义下）正常的密度函数，而不是在无限区间上的常数函数，因此 $\\ell''(x)$ 不可能处处为零。所以，$\\ell'(x)$ 是一个严格递减函数。一个严格递减的连续函数最多只能穿过零轴一次。因此，$\\ell'(x_\\star)=0$ 的解 $x_\\star$ 是唯一的。\n\n**1.2. $S_1$ 的最大值点**\n常数 $S_1$ 定义为 $S_1 = \\sup_{x \\in \\mathbb{R}} \\lvert x \\rvert \\sqrt{g(x)}$。这等价于最大化函数 $h(x) = (\\lvert x \\rvert \\sqrt{g(x)})^2 = x^2 g(x)$。最大化 $h(x)$ 等价于最大化其对数，$r(x) = \\log(x^2 g(x)) = \\log(x^2) + \\log(g(x)) = 2\\log\\lvert x \\rvert + \\ell(x)$。函数 $r(x)$ 定义在 $\\mathbb{R} \\setminus \\{0\\}$ 上。我们分别在区间 $(-\\infty, 0)$ 和 $(0, \\infty)$ 上对其进行分析。\n\n$r(x)$ 的临界点通过求解 $r'(x)=0$ 得到。其导数为 $r'(x) = \\frac{2}{x} + \\ell'(x)$。\n*   **最大值点的存在性与唯一性**：我们来分析函数 $q(x) = r'(x) = \\ell'(x) + \\frac{2}{x}$。我们需要找到它的根。$q(x)$ 的导数是 $q'(x) = \\ell''(x) - \\frac{2}{x^2}$。因为 $\\ell''(x) \\le 0$，所以对于所有 $x \\neq 0$，显然有 $q'(x)  0$。因此，$q(x)$ 在 $(-\\infty, 0)$ 和 $(0, \\infty)$ 上都是严格递减的。这保证了 $q(x)$ 在这两个区间中每个区间内最多只有一个根。\n\n    我们来验证这些根的存在性。\n    *   在 $(0, \\infty)$ 上：当 $x \\to 0^+$ 时，$\\frac{2}{x} \\to \\infty$。由于 $\\ell'(x)$ 连续，它在 $x=0$ 附近有界，所以 $q(x) \\to \\infty$。当 $x \\to \\infty$ 时，我们有 $\\frac{2}{x} \\to 0$。由于 $\\exp(\\ell(x))$ 可积，为了使其积分（方差）有限，$x^2 \\exp(\\ell(x))$ 在 $x \\to \\infty$ 时必须趋于 $0$，这对一个密度函数来说是一个合理的物理假设。这意味着 $r(x) = \\ell(x) + 2\\log x \\to -\\infty$。一个在 $(0, \\infty)$ 上的连续函数，当 $x \\to \\infty$ 时趋于 $-\\infty$，并且当 $x \\to 0^{+}$ 时 $r(x) \\to -\\infty$，则必定达到一个最大值。在这个最大值点 $x_+$ 处，必有 $r'(x_+)=0$。因此，在 $(0, \\infty)$ 中存在一个 $q(x)$ 的唯一根。\n    *   在 $(-\\infty, 0)$ 上：存在一个对称的论证。当 $x \\to 0^-$ 时，$\\frac{2}{x} \\to -\\infty$，所以 $q(x) \\to -\\infty$。当 $x \\to -\\infty$ 时，$r(x) = \\ell(x) + 2\\log(-x) \\to -\\infty$。根据类似的推理，必定存在一个唯一最大值点 $x_-$，使得 $r'(x_-)=0$。\n\n$\\sup_x r(x)$ 的值就是 $\\max(r(x_+), r(x_-))$，且 $S_1 = \\exp(\\frac{1}{2} \\max(r(x_+), r(x_-)))$。\n\n**2. 数值方案：区间套定与二分法**\n\n$\\ell'(x)=0$ 和 $r'(x)=0$ 在各自定义域上的根的唯一性，使其成为通过区间套定方法（如二分法）进行求根的理想对象。\n\n*   **区间套定**：对于一个有唯一根的函数 $f(x)$，我们需要找到一个区间 $[a, b]$，使得 $f(a)$ 和 $f(b)$ 异号。\n    *   对于 $\\ell'(x)$：我们检查 $\\ell'(0)$。如果 $\\ell'(0) > 0$，则根 $x_\\star$ 是正数。我们设 $a=0$ 并找到一个 $b>0$ 使得 $\\ell'(b)0$。如果 $\\ell'(0)  0$，则 $x_\\star$ 是负数。我们设 $b=0$ 并找到一个 $a0$ 使得 $\\ell'(a)>0$。一个扩展搜索（例如，尝试点 $1, 2, 4, ...$ 或 $-1, -2, -4, ...$）保证能找到这样的点，因为当 $\\lvert x \\rvert \\to \\infty$ 时 $\\ell(x) \\to -\\infty$。\n    *   对于 $(0, \\infty)$ 上的 $r'(x)$：我们知道当 $x \\to 0^+$ 时 $r'(x) \\to \\infty$，且 $r'(x)$ 最终会变为负数。我们可以从一个很小的 $a > 0$（例如 $10^{-8}$）开始，以确保 $r'(a) > 0$，然后使用扩展搜索来找到一个 $b$ 使得 $r'(b)  0$。\n    *   对于 $(-\\infty, 0)$ 上的 $r'(x)$：我们知道当 $x \\to 0^-$ 时 $r'(x) \\to -\\infty$，且 $r'(x)$ 最终会变为正数。我们从一个很小的负数 $b  0$（例如 $-10^{-8}$）开始，以确保 $r'(b)  0$，然后使用扩展搜索来找到一个 $a$ 使得 $r'(a) > 0$。\n\n*   **二分法**：一旦为函数 $f$ 的一个根确定了套定区间 $[a,b]$，二分法算法就迭代地将区间减半，同时保持根被套定。经过 $k$ 次迭代后，区间的宽度为 $(b-a)/2^k$。我们持续进行直到区间宽度小于预设的容差 $\\delta_x$。最终区间的中点被作为根的估计值。\n\n**3. 误差分析**\n\n现在我们根据二分法求根器的容差 $\\delta_x$ 来推导函数值的界。\n\n*   **$\\ell(x)$ 中的误差**：设 $x_\\star$ 是真实的最大值点，$\\hat{x}$ 是我们通过对 $\\ell'(x)=0$ 应用二分法得到的数值估计。宽度为 $\\delta_x$ 的最终套定区间包含 $x_\\star$。如果我们将 $\\hat{x}$ 取为中点，则 $\\lvert \\hat{x} - x_\\star \\rvert \\le \\frac{\\delta_x}{2}$。根据泰勒定理，对于某个介于 $\\hat{x}$ 和 $x_\\star$ 之间的 $\\xi$：\n    $\\ell(\\hat{x}) = \\ell(x_\\star) + \\ell'(x_\\star)(\\hat{x} - x_\\star) + \\frac{1}{2}\\ell''(\\xi)(\\hat{x} - x_\\star)^2$。\n    由于 $\\ell'(x_\\star)=0$，目标函数中的误差为 $\\ell(x_\\star) - \\ell(\\hat{x}) = -\\frac{1}{2}\\ell''(\\xi)(\\hat{x} - x_\\star)^2$。\n    问题陈述 $\\ell'(x)$ 是 $L$-利普希茨的，且 $\\ell(x)$ 是凹的。这意味着对所有 $x$ 都有 $-L \\le \\ell''(x) \\le 0$。因此，$0 \\le -\\ell''(\\xi) \\le L$。误差的界为：\n    $$0 \\le \\ell(x_\\star) - \\ell(\\hat{x}) \\le \\frac{L}{2}(\\hat{x} - x_\\star)^2 \\le \\frac{L}{2} \\left(\\frac{\\delta_x}{2}\\right)^2 = \\frac{L \\delta_x^2}{8}$$\n    对于估计值 $\\hat{S}_0 = \\exp(\\frac{1}{2}\\ell(\\hat{x}))$ 的乘性误差为 $\\frac{S_0}{\\hat{S}_0} = \\exp(\\frac{1}{2}(\\ell(x_\\star) - \\ell(\\hat{x})))$，其界为：\n    $$1 \\le \\frac{S_0}{\\hat{S}_0} \\le \\exp\\left(\\frac{L \\delta_x^2}{16}\\right)$$\n\n*   **$r(x)$ 中的误差**：设 $x_r$ 是 $r(x)$ 的一个真实最大值点（即 $x_+$ 或 $x_-$），$\\hat{x}_r$ 是其数值估计。误差为 $r(x_r) - r(\\hat{x}_r) = -\\frac{1}{2}r''(\\xi)(\\hat{x}_r - x_r)^2$。\n    二阶导数为 $r''(x) = \\ell''(x) - \\frac{2}{x^2}$。由于 $-L \\le \\ell''(x) \\le 0$，我们有 $-L - \\frac{2}{x^2} \\le r''(x) \\le -\\frac{2}{x^2}  0$。\n    其大小为 $\\lvert r''(x) \\rvert = -\\ell''(x) + \\frac{2}{x^2} \\le L + \\frac{2}{x^2}$。\n    设 $x_r$ 的最终二分套定区间为 $[u, v]$，且该区间不包含 $0$。令 $a = \\min_{x \\in [u,v]} \\lvert x \\rvert > 0$。对于此区间中的任何 $\\xi$，我们有 $\\lvert r''(\\xi) \\rvert \\le L + \\frac{2}{a^2}$。因此，误差的界为：\n    $$0 \\le r(x_r) - r(\\hat{x}_r) \\le \\frac{1}{2}\\left(L + \\frac{2}{a^2}\\right)(\\hat{x}_r - x_r)^2 \\le \\frac{(L + 2/a^2)\\delta_x^2}{8}$$\n    对于 $\\hat{S}_1 = \\exp(\\frac{1}{2}\\sup r(\\hat{x}_r))$ 的乘性误差由一个类似的表达式界定，使用正负分支误差界的最大值。对于 $\\delta_x = 10^{-12}$ 的容差，这些误差在实际应用中可以忽略不计，从而证实了该方案的高精度。\n\n至此，完成了该数值方法的推导与论证。下面的实现将这种基于原理的方法编写为代码。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute S0 and S1 for the given test cases.\n    \"\"\"\n\n    def find_bracket(f, domain):\n        \"\"\"\n        Finds a bracketing interval [a, b] for a root of f.\n        \n        Args:\n            f: The function for which to find a root.\n            domain: A string, either 'R' (for ell'), 'pos' (for r' on (0, inf)),\n                    or 'neg' (for r' on (-inf, 0)).\n        \n        Returns:\n            A tuple (a, b) such that f(a) * f(b) = 0.\n        \"\"\"\n        if domain == 'R':\n            # For ell_prime'(x)\n            f0 = f(0.0)\n            if np.isclose(f0, 0.0):\n                return 0.0, 0.0\n            if f0 > 0:\n                # Root is positive\n                a, b = 0.0, 1.0\n                while f(b) > 0:\n                    b *= 2.0\n                return a, b\n            else:\n                # Root is negative\n                a, b = -1.0, 0.0\n                while f(a)  0:\n                    a *= 2.0\n                return a, b\n        elif domain == 'pos':\n            # For r_prime(x) on (0, inf), f(x) -> +inf as x -> 0+\n            a, b = 1e-8, 1.0\n            if f(a)  0: # a is already on the other side of the root\n                return 0, a\n            while f(b) > 0:\n                b *= 2.0\n            return a, b\n        elif domain == 'neg':\n            # For r_prime(x) on (-inf, 0), f(x) -> -inf as x -> 0-\n            a, b = -1.0, -1e-8\n            if f(b) > 0: # b is already on the other side of the root\n                return b, 0\n            while f(a)  0:\n                a *= 2.0\n            return a, b\n\n    def bisection(f, a, b, tol=1e-12):\n        \"\"\"\n        Simple bisection algorithm to find a root of f in [a, b].\n        \"\"\"\n        if a > b:\n            a, b = b, a\n        fa, fb = f(a), f(b)\n        if fa * fb > 0:\n            raise ValueError(\"Root not bracketed or multiple roots exist.\")\n        if np.isclose(fa, 0.0):\n            return a\n        if np.isclose(fb, 0.0):\n            return b\n\n        while (b - a) > tol:\n            c = a + (b - a) / 2.0\n            fc = f(c)\n            if np.isclose(fc, 0.0):\n                return c\n            if fa * fc  0:\n                b = c\n            else:\n                a = c\n                fa = fc\n        return a + (b - a) / 2.0\n\n    def compute_bounds(ell, ell_prime, L):\n        \"\"\"\n        Computes S0 and S1 for a given log-density oracle.\n        \"\"\"\n        tol = 1e-12\n\n        # --- Compute S0 ---\n        # Find maximizer of ell(x) by finding root of ell_prime(x)\n        f0 = ell_prime\n        bracket_x_star = find_bracket(f0, 'R')\n        x_star = bisection(f0, bracket_x_star[0], bracket_x_star[1], tol)\n        ell_max = ell(x_star)\n        s0 = np.exp(0.5 * ell_max)\n\n        # --- Compute S1 ---\n        # Find maximizers of r(x) = ell(x) + 2*log|x|\n        # This is done by finding roots of r'(x) = ell_prime(x) + 2/x\n        f1 = lambda x: ell_prime(x) + 2.0 / x\n\n        # Positive maximizer x_+\n        bracket_x_plus = find_bracket(f1, 'pos')\n        x_plus = bisection(f1, bracket_x_plus[0], bracket_x_plus[1], tol)\n        r_plus = ell(x_plus) + 2.0 * np.log(x_plus)\n        \n        # Negative maximizer x_-\n        bracket_x_minus = find_bracket(f1, 'neg')\n        x_minus = bisection(f1, bracket_x_minus[0], bracket_x_minus[1], tol)\n        r_minus = ell(x_minus) + 2.0 * np.log(np.abs(x_minus))\n\n        r_max = max(r_plus, r_minus)\n        s1 = np.exp(0.5 * r_max)\n\n        return s0, s1\n\n    # Test cases\n    # Case A: Standard Normal\n    ell_A = lambda x: -0.5 * x**2\n    ell_prime_A = lambda x: -x\n    L_A = 1.0\n\n    # Case B: Logistic\n    ell_B = lambda x: -x - 2.0 * np.log(1.0 + np.exp(-x))\n    ell_prime_B = lambda x: -1.0 + 2.0 / (1.0 + np.exp(x))\n    L_B = 0.5\n    \n    # Case C: Normal(mu=1.5, sigma=0.5)\n    mu_C, sigma_C = 1.5, 0.5\n    ell_C = lambda x: -((x - mu_C)**2) / (2.0 * sigma_C**2)\n    ell_prime_C = lambda x: -(x - mu_C) / (sigma_C**2)\n    L_C = 1.0 / (sigma_C**2)\n    \n    test_cases = [\n        (ell_A, ell_prime_A, L_A),\n        (ell_B, ell_prime_B, L_B),\n        (ell_C, ell_prime_C, L_C),\n    ]\n\n    results = []\n    for ell, ell_prime, L in test_cases:\n        s0, s1 = compute_bounds(ell, ell_prime, L)\n        results.extend([s0, s1])\n    \n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3356655"}, {"introduction": "在构建采样器的过程中，除了找到边界矩形，能够严格地 *验证* 一个给定的矩形是否是有效边界也同样至关重要。这个练习将介绍一种基于强凹性来推导严格上界的高级技术，该技术是开发可靠且理论正确的采样软件的核心技能。掌握这种方法能让你确保算法的正确性，而不仅仅是依赖于数值上的近似。[@problem_id:3356686]", "problem": "考虑一个由非负函数 $g:\\mathbb{R}\\to\\mathbb{R}_+$ 指定的目标概率密度函数（未归一化），并定义均匀比接受集（Ratio-of-Uniforms acceptance set）\n$$\nA \\;=\\; \\left\\{(u,v)\\in\\mathbb{R}^2 \\;:\\; 0  u \\le \\sqrt{g(v/u)} \\right\\}.\n$$\n为了实现一个有效的拒绝采样器，必须确定一个完全包围 $A$ 的矩形 $[0, U] \\times [-V, V]$。这要求 $U \\ge \\sup_x \\sqrt{g(x)}$ 且 $V \\ge \\sup_x \\lvert x \\rvert \\sqrt{g(x)}$。\n\n你的任务是推导并实现一个*认证*程序，该程序给定一个候选边界矩形 $[0, U] \\times [-V, V]$，以及关于 $g$ 的某些结构信息，能够以数学确定性（在浮点算术精度范围内）验证该矩形确实包围了集合 $A$。\n\n**假设**\n- 目标密度 $g(x)$ 是*偶函数*且*对数凹*。这意味着 $g(x) = g(-x)$ 且 $\\log g(x)$ 是一个凹函数。\n- $g(x)$ 在 $\\mathbb{R}$ 上可积且处处严格为正。\n- 你可以访问函数 $g(x)$ 本身，以及函数 $\\psi(x) = \\log(x) + \\tfrac{1}{2}\\log g(x)$ 及其一阶导数 $\\psi'(x)$ 和二阶导数 $\\psi''(x)$。$\\psi(x)$ 定义在 $(0, \\infty)$ 上。\n- 你知道一个常数 $\\beta > 0$，使得 $\\psi(x)$ 是*$\\beta$-强凹*的，即对于所有 $x > 0$，有 $\\psi''(x) \\le -\\beta$。\n\n**任务**\n1. 推导一个*解析*（非数值）表达式，用于计算 $\\sup_{x\\in\\mathbb{R}} \\sqrt{g(x)}$，该表达式仅利用上述关于 $g$ 的假设。\n2. 推导一个*认证上界*，用于计算 $\\sup_{x > 0} x\\sqrt{g(x)}$。该界必须表示为一个简单的解析表达式，其输入为：在任意点 $x_0 > 0$ 处对 $\\psi(x_0)$ 和 $\\psi'(x_0)$ 的求值，以及强凹性参数 $\\beta$。该界必须保证严格大于或等于真实的（但未知的）上确界。\n3. 将你的推导组合成一个认证程序，该程序接受一个候选矩形 $[0, U] \\times [-V, V]$ 和上述函数/参数，并返回一个布尔值：`True` 表示该矩形被认证为包围 $A$，`False` 则表示认证失败。\n4. 在Python 3中实现你的认证程序，并在下面提供的测试用例上运行它。你的实现必须使用牛顿法来寻找一个高精度的 $\\psi(x)$ 的近似最大值点 $x_0$，以便获得一个紧凑的认证上界。\n\n**测试用例**\n- **高斯情况**: $g(x) = \\exp(-x^2/2)$。$\\psi(x) = \\log x - x^2/4$。$\\beta = 1/2$。\n  - 测试 1：$U=1.0$, $V=0.86$\n  - 测试 2：$U=0.99$, $V=0.86$\n  - 测试 5：$U=1.0$, $V=\\sqrt{2}\\exp(-0.5)$\n- **广义高斯（四次）情况**: $g(x) = \\exp(-x^4/2)$。$\\psi(x) = \\log x - x^4/4$。$\\beta = 2\\sqrt{3}$。\n  - 测试 3：$U=1.0$, $V=0.78$\n  - 测试 4：$U=1.0$, $V=0.77$\n\n你的程序应生成一个单行输出，该行包含一个由五个布尔值组成的逗号分隔列表，括在方括号中，对应于按顺序排列的五个测试用例的结果。例如 `[True,False,True,False,True]`。", "solution": "总体程序是计算两个所需上确界 $U_{sup} = \\sup_{x\\in\\mathbb{R}} \\sqrt{g(x)}$ 和 $V_{sup} = \\sup_{x\\in\\mathbb{R}} |x|\\sqrt{g(x)}$ 的认证上界，然后验证给定的矩形尺寸 $U$ 和 $V$ 是否大于或等于这些认证上界。不满足此条件意味着此方法无法认证包围关系。\n\n### 认证上界的推导\n\n令候选矩形为 $[0, U] \\times [-V, V]$。如果 $U \\ge U_{sup}$ 和 $V \\ge V_{sup}$，则可以保证集合 $A = \\left\\{(u,v) : 0  u \\le \\sqrt{g(v/u)}\\right\\}$ 被该矩形包围。\n\n**1. $U_{sup}$ 的计算**\n\n我们需要找到 $U_{sup} = \\sup_{x \\in \\mathbb{R}} \\sqrt{g(x)}$。由于对数函数是单调递增的，这等价于找到 $\\sup_{x \\in \\mathbb{R}} \\log(\\sqrt{g(x)}) = \\frac{1}{2}\\sup_{x \\in \\mathbb{R}} \\log g(x)$。\n问题假设 $g(x)$ 是偶函数且对数凹。一个在 $\\mathbb{R}$ 上的对数凹函数，如果可积，其对数 $\\log g(x)$ 必然是凹函数，并在某处达到其唯一的最大值。由于 $g(x)$ 是偶函数，$\\log g(x)$ 也是偶函数，因此其最大值必须在 $x=0$ 处取得。\n所以，$\\sup_{x\\in\\mathbb{R}} \\log g(x) = \\log g(0)$。\n因此，$U_{sup} = \\sqrt{\\sup_{x\\in\\mathbb{R}} g(x)} = \\sqrt{g(0)}$。\n认证检查的第一部分是验证 $U \\ge \\sqrt{g(0)}$。\n\n**2. $V_{sup}$ 的认证上界**\n\n我们需要找到 $V_{sup} = \\sup_{x \\in \\mathbb{R}} |x|\\sqrt{g(x)}$。由于 $g(x)$ 和 $|x|$ 都是偶函数，它们的乘积也是偶函数，所以我们只需在 $x>0$ 上找到上确界：$V_{sup} = \\sup_{x > 0} x\\sqrt{g(x)}$。\n同样，我们转而处理对数：$\\log V_{sup} = \\sup_{x > 0} \\log(x\\sqrt{g(x)}) = \\sup_{x > 0} (\\log x + \\frac{1}{2}\\log g(x))$。\n这正是函数 $\\psi(x)$ 的上确界。令 $x^*$ 为 $\\psi(x)$ 的（未知）真实最大值点。我们有 $\\log V_{sup} = \\psi(x^*)$。\n问题假设 $\\psi(x)$ 是 $\\beta$-强凹的。对于一个 $\\beta$-强凹函数，有一个非常有用的性质，即对于任意点 $x_0 > 0$，其最大值 $\\psi(x^*)$ 满足以下不等式：\n$$ \\psi(x^*) \\le \\psi(x_0) + \\frac{(\\psi'(x_0))^2}{2\\beta} $$\n这个不等式为 $\\psi(x^*)$ 提供了一个严格的、可计算的*认证上界*。我们称此上界为 $\\psi_{max\\_bound}$。\n因此，我们可以得到 $V_{sup}$ 的认证上界：\n$$ V_{sup} = \\exp(\\psi(x^*)) \\le \\exp\\left(\\psi(x_0) + \\frac{(\\psi'(x_0))^2}{2\\beta}\\right) $$\n认证检查的第二部分是验证 $V \\ge \\exp(\\psi_{max\\_bound})$。为了得到一个紧凑的界，我们应该选择 $x_0$ 尽可能接近真实的最大值点 $x^*$（即 $\\psi'(x^*) = 0$ 的地方）。使用牛顿法可以快速找到一个非常精确的 $x_0$，使得 $\\psi'(x_0)$ 非常接近于零，从而使上界非常接近真实值。\n\n### 认证程序\n\n认证程序如下：\n1.  **检查 $U$**：计算 $U_{bound} = \\sqrt{g(0)}$。如果 $U  U_{bound}$（在浮点精度之外），则认证失败，返回 `False`。\n2.  **检查 $V$**：\n    a. 使用牛顿法迭代几次，从一个初始猜测 $x_{init}$ 开始，找到一个点 $x_0$，该点非常接近 $\\psi'(x) = 0$ 的根。例如，$x_{k+1} = x_k - \\psi'(x_k) / \\psi''(x_k)$。\n    b. 计算认证上界 $V_{bound} = \\exp\\left(\\psi(x_0) + \\frac{(\\psi'(x_0))^2}{2\\beta}\\right)$。\n    c. 如果 $V  V_{bound}$（在浮点精度之外），则认证失败，返回 `False`。\n3.  如果两个检查都通过，则认证成功，返回 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and applies a certified verification procedure for the\n    Ratio-of-Uniforms method bounding rectangle.\n    \"\"\"\n\n    def verify_enclosure(params):\n        \"\"\"\n        Performs the certified verification for a single test case.\n\n        Args:\n            params (dict): A dictionary containing all information for a test case:\n                - g (callable): The function g(x).\n                - psi (callable): The function psi(x) = log(x) + 0.5*log(g(x)).\n                - psi_prime (callable): The derivative of psi(x).\n                - psi_double_prime (callable): The second derivative of psi(x).\n                - beta (float): The strong concavity parameter for psi(x).\n                - U (float): The horizontal extent of the candidate rectangle.\n                - V (float): The vertical half-extent of the candidate rectangle.\n\n        Returns:\n            bool: True if the rectangle is certified to enclose the acceptance set,\n                  False otherwise.\n        \"\"\"\n        g = params[\"g\"]\n        psi = params[\"psi\"]\n        psi_prime = params[\"psi_prime\"]\n        psi_double_prime = params[\"psi_double_prime\"]\n        beta = params[\"beta\"]\n        U = params[\"U\"]\n        V = params[\"V\"]\n\n        # Step 1: Compute and check the U-bound\n        # U_bound = sqrt(g(0)) due to g being even and log-concave.\n        U_bound = np.sqrt(g(0.0))\n        if U  U_bound:\n            # Add a small tolerance for floating point comparisons\n            if not np.isclose(U, U_bound):\n                return False\n\n        # Step 2: Compute the certified V-bound\n        # First, find a high-precision estimate of the maximizer of psi(x)\n        # using Newton's method on psi'(x) = 0.\n        x0 = 1.1  # Initial guess, chosen to be > 0 and not exactly at the root.\n        num_iterations = 10\n        for _ in range(num_iterations):\n            x0 = x0 - psi_prime(x0) / psi_double_prime(x0)\n        \n        # Now, compute the certified upper bound on max(psi)\n        # bound = psi(x0) + (psi'(x0))^2 / (2*beta)\n        psi_val = psi(x0)\n        psi_prime_val = psi_prime(x0)\n        psi_max_bound = psi_val + (psi_prime_val**2) / (2.0 * beta)\n\n        # The certified upper bound for the supremum is exp(psi_max_bound)\n        V_bound = np.exp(psi_max_bound)\n\n        # Step 3: Check the V-bound\n        if V  V_bound:\n            # Add a small tolerance for floating point comparisons for equality case.\n            if not np.isclose(V, V_bound):\n                 return False\n\n        return True\n\n    # ---- Definition of Test Cases ----\n\n    # Case: Gaussian g(x) = exp(-x^2/2)\n    # psi(x) = log(x) - x^2/4\n    # psi'(x) = 1/x - x/2\n    # psi''(x) = -1/x^2 - 1/2\n    # beta = 1/2\n    g_gauss = lambda x: np.exp(-x**2 / 2.0)\n    psi_gauss = lambda x: np.log(x) - x**2 / 4.0\n    psi_prime_gauss = lambda x: 1.0/x - x/2.0\n    psi_double_prime_gauss = lambda x: -1.0/x**2 - 0.5\n    beta_gauss = 0.5\n    \n    # Case: Quartic g(x) = exp(-x^4/2)\n    # psi(x) = log(x) - x^4/4\n    # psi'(x) = 1/x - x^3\n    # psi''(x) = -1/x^2 - 3x^2\n    # beta = 2*sqrt(3)\n    g_quartic = lambda x: np.exp(-x**4 / 2.0)\n    psi_quartic = lambda x: np.log(x) - x**4 / 4.0\n    psi_prime_quartic = lambda x: 1.0/x - x**3\n    psi_double_prime_quartic = lambda x: -1.0/x**2 - 3.0*x**2\n    beta_quartic = 2.0 * np.sqrt(3.0)\n\n    test_cases = [\n        # Test 1 (Gaussian, happy path)\n        {\"g\": g_gauss, \"psi\": psi_gauss, \"psi_prime\": psi_prime_gauss, \n         \"psi_double_prime\": psi_double_prime_gauss, \"beta\": beta_gauss, \n         \"U\": 1.0, \"V\": 0.86},\n        # Test 2 (Gaussian, boundary failure)\n        {\"g\": g_gauss, \"psi\": psi_gauss, \"psi_prime\": psi_prime_gauss, \n         \"psi_double_prime\": psi_double_prime_gauss, \"beta\": beta_gauss, \n         \"U\": 0.99, \"V\": 0.86},\n        # Test 3 (Generalized Gaussian quartic, happy path)\n        {\"g\": g_quartic, \"psi\": psi_quartic, \"psi_prime\": psi_prime_quartic, \n         \"psi_double_prime\": psi_double_prime_quartic, \"beta\": beta_quartic, \n         \"U\": 1.0, \"V\": 0.78},\n        # Test 4 (Generalized Gaussian quartic, failure)\n        {\"g\": g_quartic, \"psi\": psi_quartic, \"psi_prime\": psi_prime_quartic, \n         \"psi_double_prime\": psi_double_prime_quartic, \"beta\": beta_quartic, \n         \"U\": 1.0, \"V\": 0.77},\n        # Test 5 (Gaussian, equality case)\n        {\"g\": g_gauss, \"psi\": psi_gauss, \"psi_prime\": psi_prime_gauss, \n         \"psi_double_prime\": psi_double_prime_gauss, \"beta\": beta_gauss, \n         \"U\": 1.0, \"V\": np.sqrt(2.0) * np.exp(-0.5)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = verify_enclosure(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3356686"}]}