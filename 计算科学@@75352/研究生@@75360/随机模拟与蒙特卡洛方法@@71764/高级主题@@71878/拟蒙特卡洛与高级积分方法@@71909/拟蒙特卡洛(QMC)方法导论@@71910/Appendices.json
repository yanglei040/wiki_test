{"hands_on_practices": [{"introduction": "拟蒙特卡洛方法始于构造低差异点集。第一个练习 [@problem_id:3313764] 提供了一个基础性的动手实践，您将根据其定义来构建一个哈尔顿序列，从而观察其均匀覆盖的特性，并将其应用于一个基本的数值积分任务。完成此练习将巩固您对这些确定性序列如何生成及其有效性原因的理解。", "problem": "在用于拟蒙特卡洛（QMC）方法的确定性低差异序列的背景下，考虑由根倒数函数构造的二维哈尔顿序列。以 $b$ 为底的根倒数函数，记为 $\\phi_{b}(n)$，其定义为：将正整数 $n$ 写成 $b$ 进制形式 $n = \\sum_{k=0}^{m} a_{k} b^{k}$，其中数字 $a_{k} \\in \\{0,1,\\dots,b-1\\}$，然后反转数字顺序得到 $\\phi_{b}(n) = \\sum_{k=0}^{m} a_{k} b^{-(k+1)}$。使用互质基数 $b_{1}=2$ 和 $b_{2}=3$ 的二维哈尔顿序列由点 $\\big(\\phi_{2}(n), \\phi_{3}(n)\\big)$ 给出，其中 $n \\in \\mathbb{N}$。\n\n任务：\n1. 仅使用上述定义，明确构造基数为 $b_{1}=2$ 和 $b_{2}=3$ 的二维哈尔顿序列的前 $10$ 个点。\n2. 基于均匀分布和差异度的基本概念，识别并论证这 $10$ 个点中至少两个与在 $[0,1]^{2}$ 上进行数值积分相关的可见结构模式，例如均匀覆盖、避免聚集或一维投影的规律性。您的讨论必须基于所构造点的定义和可观察属性，而非启发式论断。\n3. 令函数 $f:[0,1]^{2} \\to \\mathbb{R}$ 定义为 $f(x,y) = x y$。使用构造出的 $10$ 个哈尔顿点，构建积分 $I = \\int_{0}^{1} \\int_{0}^{1} x y \\, dx \\, dy$ 的QMC估计量 $\\widehat{I}_{10} = \\frac{1}{10} \\sum_{n=1}^{10} f\\big(\\phi_{2}(n), \\phi_{3}(n)\\big)$。以精确有理数形式给出绝对误差 $|\\widehat{I}_{10} - I|$。\n\n最终答案必须是以精确有理数形式给出的单个实数值。不需要四舍五入。", "solution": "问题陈述经核实具有科学依据、良定且客观。它提供了哈尔顿序列的正确标准定义，并基于此定义提出了一系列清晰、可回答的任务。所有必要的数据和定义都是自洽且一致的。\n\n根据问题陈述的要求，解答分为三个部分。\n\n### 第1部分：哈尔顿序列点的构造\n\n二维哈尔顿序列由点 $\\big(\\phi_{b_{1}}(n), \\phi_{b_{2}}(n)\\big)$（其中 $n \\in \\mathbb{N}$）构成，使用互质基数 $b_{1}=2$ 和 $b_{2}=3$。根倒数函数 $\\phi_{b}(n)$ 的计算方法是：将 $n$ 写成 $b$ 进制形式 $n = \\sum_{k=0}^{m} a_{k} b^{k}$，然后将数字围绕小数点进行反转，形成小数 $\\phi_{b}(n) = \\sum_{k=0}^{m} a_{k} b^{-(k+1)}$。我们计算该序列对于 $n=1, 2, \\ldots, 10$ 的前 $10$ 个点。\n\n下表详细说明了每个 $n$ 值的构造过程：\n| $n$ | $n$ 的二进制表示 | $\\phi_{2}(n)$ | $n$ 的三进制表示 | $\\phi_{3}(n)$ |\n|:---:|:-------------------:|:-------------:|:-------------------:|:-------------:|\n| $1$ | $(1)_{2}$ | $\\frac{1}{2}$ | $(1)_{3}$ | $\\frac{1}{3}$ |\n| $2$ | $(10)_{2}$ | $\\frac{1}{4}$ | $(2)_{3}$ | $\\frac{2}{3}$ |\n| $3$ | $(11)_{2}$ | $\\frac{3}{4}$ | $(10)_{3}$ | $\\frac{1}{9}$ |\n| $4$ | $(100)_{2}$ | $\\frac{1}{8}$ | $(11)_{3}$ | $\\frac{4}{9}$ |\n| $5$ | $(101)_{2}$ | $\\frac{5}{8}$ | $(12)_{3}$ | $\\frac{7}{9}$ |\n| $6$ | $(110)_{2}$ | $\\frac{3}{8}$ | $(20)_{3}$ | $\\frac{2}{9}$ |\n| $7$ | $(111)_{2}$ | $\\frac{7}{8}$ | $(21)_{3}$ | $\\frac{5}{9}$ |\n| $8$ | $(1000)_{2}$ | $\\frac{1}{16}$ | $(22)_{3}$ | $\\frac{8}{9}$ |\n| $9$ | $(1001)_{2}$ | $\\frac{9}{16}$ | $(100)_{3}$ | $\\frac{1}{27}$ |\n| $10$| $(1010)_{2}$| $\\frac{5}{16}$ | $(101)_{3}$ | $\\frac{10}{27}$ |\n\n前 $10$ 个点，记为 $P_{n} = \\big(\\phi_{2}(n), \\phi_{3}(n)\\big)$，是：\n$P_{1} = \\big(\\frac{1}{2}, \\frac{1}{3}\\big)$\n$P_{2} = \\big(\\frac{1}{4}, \\frac{2}{3}\\big)$\n$P_{3} = \\big(\\frac{3}{4}, \\frac{1}{9}\\big)$\n$P_{4} = \\big(\\frac{1}{8}, \\frac{4}{9}\\big)$\n$P_{5} = \\big(\\frac{5}{8}, \\frac{7}{9}\\big)$\n$P_{6} = \\big(\\frac{3}{8}, \\frac{2}{9}\\big)$\n$P_{7} = \\big(\\frac{7}{8}, \\frac{5}{9}\\big)$\n$P_{8} = \\big(\\frac{1}{16}, \\frac{8}{9}\\big)$\n$P_{9} = \\big(\\frac{9}{16}, \\frac{1}{27}\\big)$\n$P_{10} = \\big(\\frac{5}{16}, \\frac{10}{27}\\big)$\n\n### 第2部分：哈尔顿点的结构模式\n\n基于上面构造的 $10$ 个点，我们可以识别并论证以下结构模式，这些模式对于QMC方法的有效性至关重要。\n\n1.  **一维投影的规律性：**\n    第一个坐标的前 $10$ 个值的集合 $\\{\\phi_{2}(n)\\}_{n=1}^{10}$ 是 $\\{\\frac{1}{2}, \\frac{1}{4}, \\frac{3}{4}, \\frac{1}{8}, \\frac{5}{8}, \\frac{3}{8}, \\frac{7}{8}, \\frac{1}{16}, \\frac{9}{16}, \\frac{5}{16}\\}$。以 $b$ 为底的一维根倒数序列的一个关键特性是，前 $b^k-1$ 个点的集合 $\\{\\phi_b(n)\\}_{n=1}^{b^k-1}$ 是均匀分布点集 $\\{\\frac{1}{b^k}, \\frac{2}{b^k}, \\dots, \\frac{b^k-1}{b^k}\\}$ 的一个排列。例如，序列 $\\{\\phi_2(n)\\}$ 的前 $2^3-1=7$ 个点是 $\\{\\frac{1}{2}, \\frac{1}{4}, \\frac{3}{4}, \\frac{1}{8}, \\frac{5}{8}, \\frac{3}{8}, \\frac{7}{8}\\}$。这个集合恰好是 $\\{\\frac{1}{8}, \\frac{2}{8}, \\frac{3}{8}, \\frac{4}{8}, \\frac{5}{8}, \\frac{6}{8}, \\frac{7}{8}\\}$，只是顺序不同。这种对区间 $[0,1]$ 的高度结构化分层确保了一维投影分布得非常均匀。第二个坐标基于 $3$ 的幂次也具有相似的性质。例如，$\\{\\phi_3(n)\\}$ 的前 $3^2-1=8$ 个点是集合 $\\{\\frac{1}{9}, \\frac{2}{9}, \\dots, \\frac{8}{9}\\}$ 的一个排列。即使在 $10$ 个点的少量样本中，这种规律性也是可见的，它对精确的数值积分至关重要，因为它确保了区间的所有部分都得到系统性的采样。\n\n2.  **二维中的均匀覆盖与避免聚集：**\n    哈尔顿序列的构造旨在以一种高度均匀的方式填充单位正方形 $[0,1]^2$，避免了伪随机序列中出现的聚集现象。这可以通过划分单位正方形并计算每个区域中的点数来观察。我们将正方形 $[0,1]^2$ 在点 $(\\frac{1}{2}, \\frac{1}{2})$ 处划分为四个相等的象限：左下 (LL) $[0, \\frac{1}{2}) \\times [0, \\frac{1}{2})$，右下 (LR) $[\\frac{1}{2}, 1] \\times [0, \\frac{1}{2})$，左上 (UL) $[0, \\frac{1}{2}) \\times [\\frac{1}{2}, 1]$ 和右上 (UR) $[\\frac{1}{2}, 1] \\times [\\frac{1}{2}, 1]$。\n    前 $10$ 个点的分布如下（将边界上如 $x=\\frac{1}{2}$ 的点归入右侧或上侧区域）：\n    -   左下 (LL)：$P_4(\\frac{1}{8}, \\frac{4}{9})$、 $P_6(\\frac{3}{8}, \\frac{2}{9})$、 $P_{10}(\\frac{5}{16}, \\frac{10}{27})$ --- 总计：3 个点。\n    -   右下 (LR)：$P_1(\\frac{1}{2}, \\frac{1}{3})$、 $P_3(\\frac{3}{4}, \\frac{1}{9})$、 $P_9(\\frac{9}{16}, \\frac{1}{27})$ --- 总计：3 个点。\n    -   左上 (UL)：$P_2(\\frac{1}{4}, \\frac{2}{3})$、 $P_8(\\frac{1}{16}, \\frac{8}{9})$ --- 总计：2 个点。\n    -   右上 (UR)：$P_5(\\frac{5}{8}, \\frac{7}{9})$、 $P_7(\\frac{7}{8}, \\frac{5}{9})$ --- 总计：2 个点。\n    每个象限中的点数是 $(3, 3, 2, 2)$，这非常接近每个象限 $2.5$ 个点的理想均匀分布。这展示了该序列的低差异度性质：点被散开以均匀覆盖定义域，没有大的间隙或密集的团簇。这是使用互质基数的直接结果，它确保了每个维度中的填充模式不会以某种方式相关联从而产生规则但空的区域（如果基数不互质，这是一个已知问题）。\n\n### 第3部分：绝对误差的计算\n\n待估计的积分是 $I = \\int_{0}^{1} \\int_{0}^{1} f(x,y) \\, dx \\, dy$，其中 $f(x,y) = xy$。\n首先，我们计算积分的精确值：\n$$I = \\int_{0}^{1} \\int_{0}^{1} x y \\, dx \\, dy = \\left( \\int_{0}^{1} x \\, dx \\right) \\left( \\int_{0}^{1} y \\, dy \\right)$$\n$$I = \\left[ \\frac{x^2}{2} \\right]_{0}^{1} \\left[ \\frac{y^2}{2} \\right]_{0}^{1} = \\left(\\frac{1}{2} - 0\\right) \\left(\\frac{1}{2} - 0\\right) = \\frac{1}{4}$$\n\n接下来，我们使用构造的 $N=10$ 个哈尔顿点 $P_n = (\\phi_2(n), \\phi_3(n))$ 计算QMC估计量 $\\widehat{I}_{10}$：\n$$\\widehat{I}_{10} = \\frac{1}{10} \\sum_{n=1}^{10} f(P_n) = \\frac{1}{10} \\sum_{n=1}^{10} \\phi_{2}(n) \\phi_{3}(n)$$\n我们计算每个点的乘积：\n$f(P_1) = \\frac{1}{2} \\cdot \\frac{1}{3} = \\frac{1}{6}$\n$f(P_2) = \\frac{1}{4} \\cdot \\frac{2}{3} = \\frac{2}{12} = \\frac{1}{6}$\n$f(P_3) = \\frac{3}{4} \\cdot \\frac{1}{9} = \\frac{3}{36} = \\frac{1}{12}$\n$f(P_4) = \\frac{1}{8} \\cdot \\frac{4}{9} = \\frac{4}{72} = \\frac{1}{18}$\n$f(P_5) = \\frac{5}{8} \\cdot \\frac{7}{9} = \\frac{35}{72}$\n$f(P_6) = \\frac{3}{8} \\cdot \\frac{2}{9} = \\frac{6}{72} = \\frac{1}{12}$\n$f(P_7) = \\frac{7}{8} \\cdot \\frac{5}{9} = \\frac{35}{72}$\n$f(P_8) = \\frac{1}{16} \\cdot \\frac{8}{9} = \\frac{8}{144} = \\frac{1}{18}$\n$f(P_9) = \\frac{9}{16} \\cdot \\frac{1}{27} = \\frac{1}{16 \\cdot 3} = \\frac{1}{48}$\n$f(P_{10}) = \\frac{5}{16} \\cdot \\frac{10}{27} = \\frac{50}{432} = \\frac{25}{216}$\n\n现在我们将这些值相加：\n$$\\sum_{n=1}^{10} f(P_n) = \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{12} + \\frac{1}{18} + \\frac{35}{72} + \\frac{1}{12} + \\frac{35}{72} + \\frac{1}{18} + \\frac{1}{48} + \\frac{25}{216}$$\n为了将这些分数相加，我们找到一个公分母。$\\{6, 12, 18, 72, 48, 216\\}$ 的最小公倍数是 $432$。\n$$ \\sum_{n=1}^{10} f(P_n) = \\frac{72}{432} + \\frac{72}{432} + \\frac{36}{432} + \\frac{24}{432} + \\frac{210}{432} + \\frac{36}{432} + \\frac{210}{432} + \\frac{24}{432} + \\frac{9}{432} + \\frac{50}{432} $$\n$$ \\sum_{n=1}^{10} f(P_n) = \\frac{72+72+36+24+210+36+210+24+9+50}{432} = \\frac{743}{432} $$\nQMC估计量是：\n$$\\widehat{I}_{10} = \\frac{1}{10} \\left(\\frac{743}{432}\\right) = \\frac{743}{4320}$$\n\n最后，我们计算绝对误差 $|\\widehat{I}_{10} - I|$：\n$$ |\\widehat{I}_{10} - I| = \\left| \\frac{743}{4320} - \\frac{1}{4} \\right| $$\n为了进行减法，我们使用公分母 $4320$：\n$$ \\frac{1}{4} = \\frac{1 \\cdot 1080}{4 \\cdot 1080} = \\frac{1080}{4320} $$\n$$ |\\widehat{I}_{10} - I| = \\left| \\frac{743}{4320} - \\frac{1080}{4320} \\right| = \\left| \\frac{743 - 1080}{4320} \\right| = \\left| \\frac{-337}{4320} \\right| = \\frac{337}{4320} $$\n整数 $337$ 是一个质数，而 $4320$ 的质因数分解是 $2^5 \\cdot 3^3 \\cdot 5$。因此，分数 $\\frac{337}{4320}$ 是不可约的。", "answer": "$$\\boxed{\\frac{337}{4320}}$$", "id": "3313764"}, {"introduction": "除了哈尔顿序列，秩-1格点是拟蒙特卡洛方法的另一个基石，它建立在模算术之上。这个练习 [@problem_id:3313823] 将指导您构建一个简单的二维格点，并引入一个关键概念：星差异度，这是一种对均匀性的量化度量。通过计算一个基于网格的差异度，您将获得一个更形式化的工具来评估点集的质量。", "problem": "考虑一个用于拟蒙特卡洛 (QMC) 积分的二维秩-1格点集。该点集在维度 $s=2$ 下有 $n$ 个点，其生成向量为 $\\boldsymbol{z}=(z_1,z_2)\\in\\mathbb{Z}^2$，由节点 $\\boldsymbol{x}_k=\\left(\\left\\{\\frac{k z_1}{n}\\right\\},\\left\\{\\frac{k z_2}{n}\\right\\}\\right)$ 定义，其中 $k=0,1,\\dots,n-1$，$\\{\\cdot\\}$ 表示小数部分。取 $n=7$ 且 $\\boldsymbol{z}=(1,3)$。\n\n1. 计算并列出所有节点 $\\boldsymbol{x}_k$，其中 $k=0,1,\\dots,6$。\n2. 将锚定方格网格定义为 $\\mathcal{U}=\\{(u_1,u_2):u_1=i/7,\\ u_2=j/7,\\ i,j\\in\\{0,1,\\dots,7\\}\\}$，并且对于 $\\boldsymbol{u}=(u_1,u_2)\\in\\mathcal{U}$，锚定方格为 $[0,\\boldsymbol{u})=[0,u_1)\\times[0,u_2)$。令 $A(\\boldsymbol{u})=\\sum_{k=0}^{n-1}\\mathbf{1}_{[0,\\boldsymbol{u})}(\\boldsymbol{x}_k)$ 表示落在 $[0,\\boldsymbol{u})$ 内的节点数。仅使用上述定义，通过计算基于网格的锚定星偏差来评估其均匀性：\n$$\nD_{\\text{grid}}^{\\ast}(P)=\\max_{\\boldsymbol{u}\\in\\mathcal{U}}\\left|\\frac{A(\\boldsymbol{u})}{n}-u_1 u_2\\right|.\n$$\n\n以无舍入的最简分数形式报告 $D_{\\text{grid}}^{\\ast}(P)$ 的最终值。您的解答中必须包含完整的节点列表和所有中间推理过程，但最终答案必须是 $D_{\\text{grid}}^{\\ast}(P)$ 的单个数值，不带单位。", "solution": "我们从秩-1格点集和锚定星偏差的定义开始。对于 $n=7$ 和生成向量 $\\boldsymbol{z}=(1,3)$，节点为\n$$\n\\boldsymbol{x}_k=\\left(\\left\\{\\frac{k}{7}\\right\\},\\left\\{\\frac{3k}{7}\\right\\}\\right),\\quad k=0,1,\\dots,6.\n$$\n由于每个坐标都位于 $[0,1)$ 内，我们可以通过模1运算来明确计算它们。\n\n计算节点：\n- 对于 $k=0$：$\\boldsymbol{x}_0=\\left(0,\\ 0\\right)$。\n- 对于 $k=1$：$\\boldsymbol{x}_1=\\left(\\frac{1}{7},\\ \\frac{3}{7}\\right)$。\n- 对于 $k=2$：$\\boldsymbol{x}_2=\\left(\\frac{2}{7},\\ \\frac{6}{7}\\right)$。\n- 对于 $k=3$：$\\boldsymbol{x}_3=\\left(\\frac{3}{7},\\ \\left\\{\\frac{9}{7}\\right\\}\\right)=\\left(\\frac{3}{7},\\ \\frac{2}{7}\\right)$。\n- 对于 $k=4$：$\\boldsymbol{x}_4=\\left(\\frac{4}{7},\\ \\left\\{\\frac{12}{7}\\right\\}\\right)=\\left(\\frac{4}{7},\\ \\frac{5}{7}\\right)$。\n- 对于 $k=5$：$\\boldsymbol{x}_5=\\left(\\frac{5}{7},\\ \\left\\{\\frac{15}{7}\\right\\}\\right)=\\left(\\frac{5}{7},\\ \\frac{1}{7}\\right)$。\n- 对于 $k=6$：$\\boldsymbol{x}_6=\\left(\\frac{6}{7},\\ \\left\\{\\frac{18}{7}\\right\\}\\right)=\\left(\\frac{6}{7},\\ \\frac{4}{7}\\right)$。\n\n因此，节点集 $P=\\{\\boldsymbol{x}_k:k=0,\\dots,6\\}$ 为\n$$\n\\left\\{\n\\left(0,\\ 0\\right),\n\\left(\\frac{1}{7},\\ \\frac{3}{7}\\right),\n\\left(\\frac{2}{7},\\ \\frac{6}{7}\\right),\n\\left(\\frac{3}{7},\\ \\frac{2}{7}\\right),\n\\left(\\frac{4}{7},\\ \\frac{5}{7}\\right),\n\\left(\\frac{5}{7},\\ \\frac{1}{7}\\right),\n\\left(\\frac{6}{7},\\ \\frac{4}{7}\\right)\n\\right\\}.\n$$\n\n为了通过基于网格的锚定星偏差评估均匀性，我们对每个 $\\boldsymbol{u}=(i/7,j/7)$（其中 $i,j\\in\\{0,1,\\dots,7\\}$）计算偏差 $\\left|\\frac{A(i,j)}{7}-\\frac{i\\,j}{49}\\right|$，其中 $A(i,j)$ 是落入方格 $[0,\\boldsymbol{u})$ 内的点的数量。\n我们注意到以下结构性简化：\n- 如果 $i=0$ 或 $j=0$，则 $A(i,j)=0$，差值为 $0$。\n- 如果 $i=7$，由于 $\\gcd(3,7)=1$，$y$-坐标 $\\left\\{\\frac{3k}{7}\\right\\}$ 遍历了 $\\left\\{\\frac{t}{7}:t=0,\\dots,6\\right\\}$ 的一个排列。因此，对于 $i=7$，$A(7,j)=j$（其中 $j=0,\\dots,7$），且 $\\frac{A(7,j)}{7}-\\frac{7\\,j}{49}=0$。特别地，所有 $i=7$ 的方格产生的偏差均为零。\n- 如果 $j=7$，那么所有点的 $y$ 坐标都小于1，所以 $A(i,7)=i$ 且 $\\frac{A(i,7)}{7}-\\frac{i\\cdot 7}{49}=0$。\n\n因此，最大值必定出现在 $1\\leq i\\leq 6$ 和 $1\\leq j\\leq 6$ 的情况下。对于每个 $i$，前 $i$ 个点的 $y$-余数集合是序列 $(3k\\bmod 7)$（其中 $k=0,1,\\dots,6$）的前缀，该序列为\n$$\n(0,3,6,2,5,1,4).\n$$\n对于固定的 $i$，$A(i,j)$ 是该序列前 $i$ 项中严格小于 $j$ 的元素数量。\n\n我们现在计算当 $i=1,\\dots,6$ 和 $j=1,\\dots,6$ 时 $A(i,j)$ 的值以及由此产生的偏差。\n\n情况 $i=1$：前缀是 $(0)$，所以对于所有 $j\\geq 1$，$A(1,j)=1$。偏差为\n$$\n\\left|\\frac{A(1,j)}{7}-\\frac{1\\cdot j}{49}\\right|=\\left|\\frac{1}{7}-\\frac{j}{49}\\right|=\\frac{|7-j|}{49},\n$$\n它在 $j=1$ 时达到最大值 $\\frac{6}{49}$。\n\n情况 $i=2$：前缀是 $(0,3)$。计算小于 $j$ 的值的数量，得到 $A(2,1)=1$，$A(2,2)=1$，$A(2,3)=1$，$A(2,4)=2$，$A(2,5)=2$，$A(2,6)=2$。偏差为\n$$\n\\left|\\frac{A(2,j)}{7}-\\frac{2j}{49}\\right| \\in \\left\\{\\frac{5}{49},\\frac{3}{49},\\frac{1}{49},\\frac{6}{49},\\frac{4}{49},\\frac{2}{49}\\right\\},\n$$\n在 $j=4$ 时最大值为 $\\frac{6}{49}$。\n\n情况 $i=3$：前缀是 $(0,3,6)$。我们有 $A(3,1)=1$，$A(3,2)=1$，$A(3,3)=1$，$A(3,4)=2$，$A(3,5)=2$，$A(3,6)=2$。偏差为\n$$\n\\left|\\frac{A(3,j)}{7}-\\frac{3j}{49}\\right| \\in \\left\\{\\frac{4}{49},\\frac{1}{49},\\frac{2}{49},\\frac{2}{49},\\frac{1}{49},\\frac{4}{49}\\right\\},\n$$\n最大值为 $\\frac{4}{49}$。\n\n情况 $i=4$：前缀是 $(0,3,6,2)$。我们有 $A(4,1)=1$，$A(4,2)=1$，$A(4,3)=2$，$A(4,4)=3$，$A(4,5)=3$，$A(4,6)=3$。偏差为\n$$\n\\left|\\frac{A(4,j)}{7}-\\frac{4j}{49}\\right| \\in \\left\\{\\frac{3}{49},\\frac{1}{49},\\frac{2}{49},\\frac{5}{49},\\frac{1}{49},\\frac{3}{49}\\right\\},\n$$\n最大值为 $\\frac{5}{49}$。\n\n情况 $i=5$：前缀是 $(0,3,6,2,5)$。我们有 $A(5,1)=1$，$A(5,2)=1$，$A(5,3)=2$，$A(5,4)=3$，$A(5,5)=3$，$A(5,6)=4$。偏差为\n$$\n\\left|\\frac{A(5,j)}{7}-\\frac{5j}{49}\\right| \\in \\left\\{\\frac{2}{49},\\frac{3}{49},\\frac{1}{49},\\frac{1}{49},\\frac{4}{49},\\frac{2}{49}\\right\\},\n$$\n最大值为 $\\frac{4}{49}$。\n\n情况 $i=6$：前缀是 $(0,3,6,2,5,1)$。我们有 $A(6,1)=1$，$A(6,2)=2$，$A(6,3)=3$，$A(6,4)=4$，$A(6,5)=4$，$A(6,6)=5$。偏差为\n$$\n\\left|\\frac{A(6,j)}{7}-\\frac{6j}{49}\\right| \\in \\left\\{\\frac{1}{49},\\frac{2}{49},\\frac{3}{49},\\frac{4}{49},\\frac{2}{49},\\frac{1}{49}\\right\\},\n$$\n最大值为 $\\frac{4}{49}$。\n\n综合所有情况，并回顾当 $i\\in\\{0,7\\}$ 或 $j\\in\\{0,7\\}$ 时偏差为零的情况，在网格 $\\mathcal{U}$ 上 $\\left|\\frac{A(i,j)}{7}-\\frac{i\\,j}{49}\\right|$ 的总最大值为\n$$\nD_{\\text{grid}}^{\\ast}(P)=\\frac{6}{49}.\n$$\n例如，在 $(i,j)=(1,1)$ 和 $(i,j)=(2,4)$ 处达到此最大值。", "answer": "$$\\boxed{\\frac{6}{49}}$$", "id": "3313823"}, {"introduction": "像索博尔序列这样的数字序列的卓越性能源于其深层的代数性质，这些性质可以用沃尔什-佩利函数进行分析。这个计算实践 [@problem_id:3313778] 将挑战您连接理论与应用，通过为一个具有已知沃尔什展开式的函数实现QMC积分。您将基于混叠理论预测积分误差，然后通过数值方式验证您的预测，从而揭示数字序列中误差抵消的精确机制。", "problem": "您需要实现并验证一种基于 Walsh-Paley 系统和数字网格混叠的单位区间上准蒙特卡罗 (QMC) 积分的误差预测。该任务侧重于 Walsh 展开的基本原理和二进数字网格的结构，使用一维 Sobol' 网格来确保完全的可复现性和数值稳定性。\n\n本问题的基础包括以下定义和事实：\n- 以二为基数的 Walsh-Paley 函数，记为族 $\\{\\mathrm{wal}_k\\}_{k \\ge 0}$，在 $L^2$ 意义上构成 $[0,1)$ 上的一个标准正交系，其中 $\\mathrm{wal}_0(x) = 1$。对于 $k \\ge 1$，函数通过二进制数字的奇偶性相互作用定义。若 $x = \\sum_{j=1}^\\infty x_j 2^{-j}$ (其中 $x_j \\in \\{0,1\\}$) 且 $k = \\sum_{j=0}^\\infty k_j 2^j$ (其中 $k_j \\in \\{0,1\\}$)，则 $\\mathrm{wal}_k(x) = (-1)^{\\sum_{j=1}^\\infty x_j k_{j-1}}$。\n- 在 $[0,1)$ 上的一个包含 $N = 2^m$ 个点的二进数字网格具有以下性质：$\\mathrm{wal}_k$ 在这些点上的经验平均值，如果 $k$ 的前 $m$ 个二进制位为零（等价于 $2^m$ 整除 $k$），则等于 $1$，否则等于 $0$。这一事实源于数字网格的结构以及 Walsh 函数在二进分辨率的基本区间上的正交性。\n\n您将考虑在 $[0,1)$ 上具有已知有限 Walsh 展开的函数，\n$$\nf(x) = \\sum_{k=0}^{K_{\\max}} a_k \\,\\mathrm{wal}_k(x),\n$$\n其中 $K_{\\max}$ 是一个正整数，系数 $\\{a_k\\}$ 按测试用例指定。$f$ 在 $[0,1)$ 上的精确积分为\n$$\n\\int_0^1 f(x)\\,dx = a_0,\n$$\n因为对于所有 $k \\ge 1$，$\\int_0^1 \\mathrm{wal}_k(x)\\,dx = 0$，且 $\\int_0^1 \\mathrm{wal}_0(x)\\,dx = 1$。\n\n利用数字网格的性质，使用二进数字网格的前 $N = 2^m$ 个点对 $f$ 进行 QMC 估计，其结果等于\n$$\nQ_N(f) = \\sum_{k \\in \\mathcal{D}_m} a_k,\n$$\n其中 $\\mathcal{D}_m$ 是其前 $m$ 个二进制位为零的指标偶集，限制在 $\\{0,1,\\dots,K_{\\max}\\}$ 内。因此，混叠引起的积分误差为\n$$\nE_{\\text{alias}}(m) = Q_N(f) - \\int_0^1 f(x)\\,dx = \\sum_{\\substack{k \\in \\mathcal{D}_m \\\\ k \\ge 1}} a_k = \\sum_{j \\ge 1,\\, j 2^m \\le K_{\\max}} a_{j 2^m}.\n$$\n您的程序必须根据系数预测 $E_{\\text{alias}}(m)$，然后通过使用一维未加扰 Sobol' 网格的前 $N=2^m$ 个点计算 $f$ 的样本均值来对其进行经验验证。\n\n算法要求：\n1. 实现一个例程，用于计算任意整数 $k \\ge 0$ 和具有有限二进制表示的二进有理数 $x$ 的 $\\mathrm{wal}_k(x)$ 值。计算方法是通过计算 $x$ 的前 $L$ 个比特与 $k$ 的前 $L$ 个比特之间点积的奇偶性，其中 $L = \\lfloor \\log_2(K_{\\max}) \\rfloor + 1$。\n2. 使用指定的直到 $K_{\\max}$ 的有限 Walsh 系数来实现函数 $f(x)$。\n3. 生成一维未加扰 Sobol' 网格的前 $N = 2^m$ 个点，并计算经验估计量 $Q_N(f)$。\n4. 通过数字网格性质和精确积分 $a_0$，根据系数计算预测的混叠误差 $E_{\\text{alias}}(m)$。\n5. 对于每个测试用例，返回一个包含三个浮点数的列表：预测的混叠误差、经验误差以及它们之间的绝对差。\n\n要使用的系数族：\n- 块衰减模型：对于 $k \\ge 1$，$a_k = c \\, 2^{-\\beta \\, L(k)}$，其中 $L(k) = \\lfloor \\log_2(k) \\rfloor + 1$，参数为 $c > 0$ 和 $\\beta > 0$。$a_0$ 也会给定。\n- 稀疏幂模型：对于 $k \\ge 1$，如果 $k = 2^r$（对于某个整数 $r \\ge 0$），则 $a_k = c \\, 2^{-r}$，否则 $a_k = 0$。$a_0$ 也会给定。\n\n测试套件：\n- 情况1（正常路径）：块衰减模型，$a_0 = 0.25$，$c = 0.5$，$\\beta = 1.25$，$K_{\\max} = 256$，$m = 3$。\n- 情况2（边界条件）：块衰减模型，$a_0 = 0.10$，$c = 0.30$，$\\beta = 0.75$，$K_{\\max} = 64$，$m = 1$。\n- 情况3（尾部几乎消失的边缘情况）：块衰减模型，$a_0 = 0.20$，$c = 1.00$，$\\beta = 1.00$，$K_{\\max} = 256$，$m = 8$。\n- 情况4（稀疏性引起的分步衰减）：稀疏幂模型，$a_0 = 0.00$，$c = 0.40$，$K_{\\max} = 1024$，$m = 5$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个元素本身是按 $[E_{\\text{alias}}(m), E_{\\text{emp}}(m), |E_{\\text{alias}}(m) - E_{\\text{emp}}(m)|]$ 顺序排列的三个浮点数的列表。例如：“[[p1,e1,d1],[p2,e2,d2],...]”，所有值均为浮点数。此问题不涉及单位、角度或百分比；所有值都是无单位的实数。", "solution": "问题陈述已经过严格审查，并被确定为 **有效**。它在科学上基于准蒙特卡罗 (QMC) 积分理论，数学上自洽，且算法上是适定的。所提供的 Walsh-Paley 函数定义、二进数字网格的性质以及由此产生的混叠误差公式，均与该主题的既有文献一致。该问题构成了一个可靠的数值练习，用以验证 QMC 误差分析中的一个关键理论结果。\n\n解决方案通过实现指定的算法来计算和比较预测积分误差与经验积分误差。\n\n### 1. 理论框架\n\n问题围绕单位区间 $[0,1)$ 上函数 $f(x)$ 的积分展开，其中 $f(x)$ 具有已知的有限 Walsh-Paley 级数展开：\n$$\nf(x) = \\sum_{k=0}^{K_{\\max}} a_k \\,\\mathrm{wal}_k(x)\n$$\nWalsh-Paley 函数 $\\{\\mathrm{wal}_k\\}_{k \\ge 0}$ 构成了 $L^2([0,1))$ 的一个标准正交基。一个关键性质是 $\\int_0^1 \\mathrm{wal}_k(x)\\,dx = \\delta_{k0}$，其中 $\\delta_{k0}$ 是克罗内克 δ (Kronecker delta)。因此，$f(x)$ 的精确积分就是第一个 Walsh 系数：\n$$\n\\int_0^1 f(x)\\,dx = \\sum_{k=0}^{K_{\\max}} a_k \\int_0^1 \\mathrm{wal}_k(x)\\,dx = a_0 \\,\\mathrm{wal}_0(x) \\int_0^1 1 \\,dx = a_0\n$$\n使用点集 $\\{x_i\\}_{i=0}^{N-1}$ 的积分 QMC 估计量是样本均值 $Q_N(f) = \\frac{1}{N}\\sum_{i=0}^{N-1}f(x_i)$。对于一个包含 $N=2^m$ 个点的二进数字网格，例如未加扰的 Sobol' 序列，由于网格的均匀分布性质，Walsh 函数的样本均值表现出一种特定结构：\n$$\n\\frac{1}{N} \\sum_{i=0}^{N-1} \\mathrm{wal}_k(x_i) = \\begin{cases} 1  \\text{if } k \\equiv 0 \\pmod{N} \\\\ 0  \\text{if } k \\not\\equiv 0 \\pmod{N} \\end{cases}\n$$\n此性质成立，因为一维 Sobol' 序列的前 $N=2^m$ 个点是精度为 $m$ 的二进有理数，即 $x_i = p_i/2^m$。对于这类点，如果 $k$ 是 $N=2^m$ 的倍数，函数 $\\mathrm{wal}_k(x_i)$ 仅依赖于 $x_i$ 第 $m$ 位之后的所有比特，而这些比特全为零。这导致对所有 $i$ 都有 $\\mathrm{wal}_k(x_i)=1$。对于不是 $N$ 的倍数的 $k$，有限群上的特征理论保证了其和为零。\n\n将此代入 QMC 估计量表达式可得：\n$$\nQ_N(f) = \\frac{1}{N} \\sum_{i=0}^{N-1} \\sum_{k=0}^{K_{\\max}} a_k \\mathrm{wal}_k(x_i) = \\sum_{k=0}^{K_{\\max}} a_k \\left(\\frac{1}{N} \\sum_{i=0}^{N-1} \\mathrm{wal}_k(x_i)\\right) = \\sum_{\\substack{k=0 \\\\ k \\equiv 0 \\pmod{N}}}^{K_{\\max}} a_k\n$$\n积分误差是 QMC 估计值与真实积分值之间的差。问题将此定义为混叠误差 $E_{\\text{alias}}(m)$。术语“混叠”指的是满足条件 $k \\equiv 0 \\pmod N$ 的高频分量（其中 $k \\ge 1$）如何被采样过程错误地映射到常数分量（$k=0$）上。\n$$\nE_{\\text{alias}}(m) = Q_N(f) - a_0 = \\sum_{\\substack{k=1 \\\\ k \\equiv 0 \\pmod{N}}}^{K_{\\max}} a_k = \\sum_{j \\ge 1,\\, j 2^m \\le K_{\\max}} a_{j 2^m}\n$$\n这为误差提供了一个理论预测。经验误差 $E_{\\text{emp}}(m)$ 是通过使用生成的 Sobol' 点集进行数值积分直接计算得出的。根据理论，对于一个理想的数字网格，我们预期 $E_{\\text{alias}}(m) = E_{\\text{emp}}(m)$。核心任务是数值上验证这一等式。\n\n### 2. 算法实现\n\n**步骤1：系数生成**\n对于每个测试用例，我们首先生成 $k \\in \\{0, 1, \\dots, K_{\\max}\\}$ 的 Walsh 系数 $a_k$。\n- 对于**块衰减模型**，$a_0$ 已给定，对于 $k \\ge 1$，$a_k = c \\cdot 2^{-\\beta \\cdot L(k)}$，其中 $L(k) = \\lfloor \\log_2(k) \\rfloor + 1$。函数 $L(k)$ 对应于 $k$ 的二进制表示中的比特数。\n- 对于**稀疏幂模型**，$a_0$ 已给定，对于 $k \\ge 1$，如果 $k = 2^r$（对于某个整数 $r \\ge 0$），则 $a_k = c \\cdot 2^{-r}$，否则 $a_k=0$。\n\n**步骤2：预测误差计算 ($E_{\\text{alias}}$)**\n预测混叠误差 $E_{\\text{alias}}(m)$ 是通过对预先计算的系数 $a_k$ 在索引 $k$（为 $N=2^m$ 的非零倍数，且不大于 $K_{\\max}$）上求和来计算的。这是对推导公式的直接实现。\n\n**步骤3：经验误差计算 ($E_{\\text{emp}}$)**\n这涉及一个完整的 QMC 模拟。\n- **点集生成：** 生成一维未加扰 Sobol' 序列（即以2为基的 van der Corput 序列）的前 $N=2^m$ 个点。\n- **Walsh 函数求值：** 根据定义 $\\mathrm{wal}_k(x) = (-1)^{\\sum_{j=1}^L x_j k_{j-1}}$ 实现函数 `wal_k(x)`，其中 $x_j$ 是 $x$ 小数点后的二进制数字，$k_{j-1}$ 是整数 $k$ 的二进制数字。如指定，求和在 $L = \\lfloor \\log_2(K_{\\max}) \\rfloor + 1$ 比特处截断。$x$ 的二进制数字通过乘以2并取整数部分来迭代提取。\n- **被积函数求值：** 通过对 $k$ 从 $0$到 $K_{\\max}$ 求和 $a_k \\cdot \\mathrm{wal}_k(x)$ 的乘积来计算函数 $f(x)$。\n- **QMC 积分与误差：** QMC 估计 $Q_N(f)$ 是 $f(x_i)$ 在生成的 Sobol' 点上的平均值。然后，经验误差为 $E_{\\text{emp}}(m) = Q_N(f) - a_0$。\n\n**步骤4：验证**\n最后一步是计算绝对差 $|E_{\\text{alias}}(m) - E_{\\text{emp}}(m)|$。该值量化了理论预测与数值实验之间的一致性。由于二进有理数的数字网格性质的精确性以及 Walsh 展开的有限精度，这个差值预计将接近于零，仅受浮点算术精度的限制。\n\n下面的实现为每个提供的测试用例遵循了这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef wal_k(x, k, L):\n    \"\"\"\n    Computes the Walsh-Paley function wal_k(x) for a dyadic rational x.\n    \n    Args:\n        x (float): A point in [0, 1).\n        k (int): A non-negative integer index for the Walsh function.\n        L (int): The number of bits to consider for k's and x's binary expansions.\n        \n    Returns:\n        float: The value of wal_k(x), which is either 1.0 or -1.0.\n    \"\"\"\n    if k == 0:\n        return 1.0\n\n    exponent = 0\n    x_val = x\n    \n    # The definition is wal_k(x) = (-1)^(\\sum_{j=1 to inf} x_j * k_{j-1})\n    # We truncate the sum at L terms.\n    for j in range(1, L + 1):\n        # Get k_{j-1}, the (j-1)-th bit of k\n        k_bit = (k >> (j - 1)) & 1\n        \n        # Get x_j, the j-th bit of x's fractional part\n        x_val *= 2.0\n        x_j = 0\n        if x_val >= 1.0:\n            x_j = 1\n            x_val -= 1.0\n            \n        # Add to exponent if both bits are 1. We only care about parity.\n        if k_bit == 1 and x_j == 1:\n            exponent += 1\n            \n    return 1.0 if exponent % 2 == 0 else -1.0\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case to compute predicted and empirical errors.\n    \n    Args:\n        case_params (dict): A dictionary containing all parameters for the case.\n        \n    Returns:\n        list[float]: A list containing [predicted_error, empirical_error, absolute_difference].\n    \"\"\"\n    model = case_params['model']\n    a0 = case_params['a0']\n    K_max = case_params['K_max']\n    m = case_params['m']\n    \n    # 1. Generate Walsh coefficients a_k\n    coeffs = np.zeros(K_max + 1)\n    coeffs[0] = a0\n    if model == 'block':\n        c = case_params['c']\n        beta = case_params['beta']\n        for k in range(1, K_max + 1):\n            # L(k) = floor(log2(k)) + 1 is equivalent to k.bit_length() for k >= 1\n            L_k = k.bit_length()\n            coeffs[k] = c * (2.0 ** (-beta * L_k))\n    elif model == 'sparse':\n        c = case_params['c']\n        for k in range(1, K_max + 1):\n            # is_power_of_two check: k > 0 and (k & (k - 1) == 0)\n            if (k > 0) and ((k & (k - 1)) == 0):\n                r = k.bit_length() - 1\n                coeffs[k] = c * (2.0 ** (-r))\n    \n    # 2. Calculate predicted aliasing error E_alias\n    N = 2**m\n    E_alias = 0.0\n    # Sum over k = j * 2^m for j >= 1\n    for k_alias in range(N, K_max + 1, N):\n        E_alias += coeffs[k_alias]\n\n    # 3. Calculate empirical error E_emp\n    # 3a. Generate Sobol points (1D unscrambled = van der Corput sequence)\n    sobol_gen = qmc.Sobol(d=1, scramble=False)\n    sobol_points = sobol_gen.random(n=N).flatten()\n    \n    # 3b. Define L for Walsh function evaluation from K_max\n    L = K_max.bit_length() if K_max > 0 else 1\n\n    # 3c. Compute QMC estimate Q_N(f) by summing contributions from each Walsh function\n    qmc_estimate = 0.0\n    for k in range(K_max + 1):\n        if coeffs[k] != 0:\n            wal_sum_over_points = 0.0\n            for x_i in sobol_points:\n                wal_sum_over_points += wal_k(x_i, k, L)\n            qmc_estimate += coeffs[k] * (wal_sum_over_points / N)\n            \n    # 3d. Compute empirical error\n    E_emp = qmc_estimate - a0\n    \n    # 4. Calculate absolute difference\n    diff = abs(E_alias - E_emp)\n    \n    return [E_alias, E_emp, diff]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'model': 'block', 'a0': 0.25, 'c': 0.5, 'beta': 1.25, 'K_max': 256, 'm': 3},\n        {'model': 'block', 'a0': 0.10, 'c': 0.30, 'beta': 0.75, 'K_max': 64, 'm': 1},\n        {'model': 'block', 'a0': 0.20, 'c': 1.00, 'beta': 1.00, 'K_max': 256, 'm': 8},\n        {'model': 'sparse', 'a0': 0.00, 'c': 0.40, 'K_max': 1024, 'm': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function on a list provides the \"[v1, v2, v3]\" formatting.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3313778"}]}