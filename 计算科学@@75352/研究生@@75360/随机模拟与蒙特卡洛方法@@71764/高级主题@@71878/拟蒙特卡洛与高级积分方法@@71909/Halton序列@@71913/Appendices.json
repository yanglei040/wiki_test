{"hands_on_practices": [{"introduction": "在我们信任一个低差异序列之前，我们必须首先验证它是否确实比随机点更均匀地填充空间。第一个练习 [@problem_id:3310926] 提供了一种量化这种均匀性的直接方法。通过生成一个三维哈尔顿序列的初始点并将其投影到二维平面上，您将应用一种统计检验来评估这些点的分布情况，从而为“低差异”这一概念建立具体直观的认识。", "problem": "考虑一个以 $(2,3,5)$ 为基数的$3$维哈尔顿序列，它由根式逆构作法定义。对于每个整数 $n \\geq 1$，将 $n$ 写成 $b$ 进制形式 $n=\\sum_{k=0}^{K} a_k b^k$，其中数字 $a_k \\in \\{0,1,\\dots,b-1\\}$，并定义根式逆函数 $\\phi_b(n)=\\sum_{k=0}^{K} a_k b^{-(k+1)}$。$3$维哈尔顿序列的第 $n$ 个点是 $H_n = \\big(\\phi_2(n),\\phi_3(n),\\phi_5(n)\\big)$。\n\n设 $N=16$ 且 $m=4$。对于前 $N$ 个点 $\\{H_n\\}_{n=1}^{N}$ 的三个二维坐标投影 $(x,y)$、$(x,z)$ 和 $(y,z)$ 中的每一个，使用沿每个轴的区间 $[k/m,(k+1)/m)$（其中 $k \\in \\{0,1,2,3\\}$）将单位正方形 $[0,1)^2$ 划分成一个 $m \\times m$ 的由全等单元格组成的轴对齐网格。令 $C_{ij}^{(\\pi)}$ 表示对于投影 $\\pi \\in \\{xy,xz,yz\\}$ 落在单元格 $(i,j)$ 内的投影点计数，并令均匀分布下的期望计数为 $E = N/m^2$。\n\n定义投影 $\\pi$ 的皮尔逊卡方统计量为\n$$\n\\chi^2_{\\pi} \\;=\\; \\sum_{i=0}^{m-1}\\sum_{j=0}^{m-1} \\frac{\\big(C_{ij}^{(\\pi)} - E\\big)^2}{E}.\n$$\n定义聚合均匀性得分为各投影之和，\n$$\nS \\;=\\; \\chi^2_{xy} + \\chi^2_{xz} + \\chi^2_{yz}.\n$$\n\n请精确计算基数为 $(2,3,5)$ 的哈尔顿序列前 $N=16$ 个点的 $S$ 值。您的最终答案必须是一个不带单位的实数。不需要四舍五入。", "solution": "用户希望计算一个 $3$ 维哈尔顿序列前 $16$ 个点的聚合均匀性得分 $S$。\n\n### 第一步：问题验证\n问题陈述提供了一个完全指定、自洽的数学任务。所有术语，如哈尔顿序列、根式逆函数和皮尔逊卡方统计量，都得到了正式定义。给定的参数为 $N=16$ 个点，基数为 $(2,3,5)$，网格大小为 $m=4$。任务是基于这些定义计算一个单一的数值。该问题在科学上植根于拟蒙特卡洛方法和统计学领域。它提法得当、客观，且不包含矛盾或歧义。因此，该问题被认为是有效的。\n\n### 第二步：计算常数和公式\n点的总数为 $N=16$。\n网格是 $m \\times m$ 网格，其中 $m=4$。\n在均匀分布下，每个单元格的期望点数为 $E = \\frac{N}{m^2} = \\frac{16}{4^2} = \\frac{16}{16} = 1$。\n投影 $\\pi$ 的皮尔逊卡方统计量简化为：\n$$\n\\chi^2_{\\pi} = \\sum_{i=0}^{m-1}\\sum_{j=0}^{m-1} \\frac{\\big(C_{ij}^{(\\pi)} - E\\big)^2}{E} = \\sum_{i=0}^{3}\\sum_{j=0}^{3} \\frac{\\big(C_{ij}^{(\\pi)} - 1\\big)^2}{1} = \\sum_{i=0}^{3}\\sum_{j=0}^{3} \\big(C_{ij}^{(\\pi)} - 1\\big)^2\n$$\n聚合均匀性得分为 $S = \\chi^2_{xy} + \\chi^2_{xz} + \\chi^2_{yz}$。\n\n### 第三步：生成哈尔顿序列点并进行分箱\n我们需要生成哈尔顿序列的前 $N=16$ 个点，$H_n = (\\phi_2(n), \\phi_3(n), \\phi_5(n))$，其中 $n=1, \\dots, 16$。然后将坐标分配到网格单元格中。如果 $i = \\lfloor 4u \\rfloor$ 且 $j = \\lfloor 4v \\rfloor$，则点 $(u,v)$ 落在 $4 \\times 4$ 网格的单元格 $(i,j)$ 中。我们为每个点 $H_n = (x_n, y_n, z_n)$ 计算整数单元格索引 $(i_n, j_n, k_n)$，其中 $i_n = \\lfloor 4x_n \\rfloor$，$j_n = \\lfloor 4y_n \\rfloor$，$k_n = \\lfloor 4z_n \\rfloor$。\n\n下表总结了 $n=1, \\dots, 16$ 时各点的坐标及其对应的单元格索引。\n\n| $n$ | $x_n = \\phi_2(n)$ | $y_n = \\phi_3(n)$ | $z_n = \\phi_5(n)$ | $i_n = \\lfloor 4x_n \\rfloor$ | $j_n = \\lfloor 4y_n \\rfloor$ | $k_n = \\lfloor 4z_n \\rfloor$ |\n|-----|:-----------------:|:-----------------:|:-----------------:|:----------------------------:|:----------------------------:|:----------------------------:|\n| 1   | $1/2$             | $1/3$             | $1/5$             | $2$                          | $1$                          | $0$                          |\n| 2   | $1/4$             | $2/3$             | $2/5$             | $1$                          | $2$                          | $1$                          |\n| 3   | $3/4$             | $1/9$             | $3/5$             | $3$                          | $0$                          | $2$                          |\n| 4   | $1/8$             | $4/9$             | $4/5$             | $0$                          | $1$                          | $3$                          |\n| 5   | $5/8$             | $7/9$             | $1/25$            | $2$                          | $3$                          | $0$                          |\n| 6   | $3/8$             | $2/9$             | $6/25$            | $1$                          | $0$                          | $0$                          |\n| 7   | $7/8$             | $5/9$             | $11/25$           | $3$                          | $2$                          | $1$                          |\n| 8   | $1/16$            | $8/9$             | $16/25$           | $0$                          | $3$                          | $2$                          |\n| 9   | $9/16$            | $1/27$            | $21/25$           | $2$                          | $0$                          | $3$                          |\n| 10  | $5/16$            | $10/27$           | $2/25$            | $1$                          | $1$                          | $0$                          |\n| 11  | $13/16$           | $19/27$           | $7/25$            | $3$                          | $2$                          | $1$                          |\n| 12  | $3/16$            | $4/27$            | $12/25$           | $0$                          | $0$                          | $1$                          |\n| 13  | $11/16$           | $13/27$           | $17/25$           | $2$                          | $1$                          | $2$                          |\n| 14  | $7/16$            | $22/27$           | $22/25$           | $1$                          | $3$                          | $3$                          |\n| 15  | $15/16$           | $7/27$            | $3/25$            | $3$                          | $1$                          | $0$                          |\n| 16  | $1/32$            | $16/27$           | $8/25$            | $0$                          | $2$                          | $1$                          |\n\n### 第四步：构建计数矩阵\n我们为每个投影 $\\pi \\in \\{xy, xz, yz\\}$ 构建 $4 \\times 4$ 的计数矩阵 $C_{ij}^{(\\pi)}$。\n\n- **投影 $\\pi=xy$**：我们对点对 $(i_n, j_n)$ 进行计数。行索引对应于 $i$，列索引对应于 $j$。\n$$\nC^{(xy)} = \\begin{pmatrix}\n1   1   1   1 \\\\\n1   1   1   1 \\\\\n1   2   0   1 \\\\\n1   1   2   0\n\\end{pmatrix}\n$$\n条目总和为 $12 \\times 1 + 1 \\times 2 + 1 \\times 0 + 1 \\times 1 + 1 \\times 2 + 1 \\times 0 = 16$。\n\n- **投影 $\\pi=xz$**：我们对点对 $(i_n, k_n)$ 进行计数。行索引对应于 $i$，列索引对应于 $k$。\n$$\nC^{(xz)} = \\begin{pmatrix}\n0   2   1   1 \\\\\n2   1   0   1 \\\\\n2   0   1   1 \\\\\n1   2   1   0\n\\end{pmatrix}\n$$\n条目总和为 $16$。\n\n- **投影 $\\pi=yz$**：我们对点对 $(j_n, k_n)$ 进行计数。行索引对应于 $j$，列索引对应于 $k$。\n$$\nC^{(yz)} = \\begin{pmatrix}\n1   1   1   1 \\\\\n3   0   1   1 \\\\\n0   4   0   0 \\\\\n1   0   1   1\n\\end{pmatrix}\n$$\n条目总和为 $16$。\n\n### 第五步：计算卡方统计量\n我们使用公式 $\\chi^2_{\\pi} = \\sum_{i,j} (C_{ij}^{(\\pi)} - 1)^2$ 计算每个投影的卡方统计量。\n\n- 对于 $\\chi^2_{xy}$：\n矩阵 $C^{(xy)}$ 有十二个等于 $1$ 的条目，两个等于 $2$ 的条目，以及两个等于 $0$ 的条目。\n$$\n\\chi^2_{xy} = 12 \\times (1-1)^2 + 2 \\times (2-1)^2 + 2 \\times (0-1)^2 = 0 + 2 \\times 1 + 2 \\times 1 = 4\n$$\n\n- 对于 $\\chi^2_{xz}$：\n矩阵 $C^{(xz)}$ 有八个等于 $1$ 的条目，四个等于 $2$ 的条目，以及四个等于 $0$ 的条目。\n$$\n\\chi^2_{xz} = 8 \\times (1-1)^2 + 4 \\times (2-1)^2 + 4 \\times (0-1)^2 = 0 + 4 \\times 1 + 4 \\times 1 = 8\n$$\n\n- 对于 $\\chi^2_{yz}$：\n矩阵 $C^{(yz)}$ 有九个等于 $1$ 的条目，五个等于 $0$ 的条目，一个等于 $3$ 的条目，以及一个等于 $4$ 的条目。\n$$\n\\chi^2_{yz} = 9 \\times (1-1)^2 + 5 \\times (0-1)^2 + 1 \\times (3-1)^2 + 1 \\times (4-1)^2 = 0 + 5 \\times 1 + 1 \\times 4 + 1 \\times 9 = 5+4+9=18\n$$\n\n### 第六步：计算聚合均匀性得分\n最后，我们将各个卡方统计量相加，得到聚合得分 $S$。\n$$\nS = \\chi^2_{xy} + \\chi^2_{xz} + \\chi^2_{yz} = 4 + 8 + 18 = 30\n$$\n$S$ 的最终计算值为 $30$。", "answer": "$$\n\\boxed{30}\n$$", "id": "3310926"}, {"introduction": "哈尔顿序列通常能为积分估算带来惊人的准确性，但它们是万无一失的吗？这个思想实验 [@problem_id:3285819] 旨在揭示拟蒙特卡洛方法的一个关键弱点。您将构建一个特殊的“最坏情况”函数，它被巧妙地设计为恰好避开所有的采样点，从而导致积分估算的灾难性失败，这突显了理解被积函数与点集之间相互作用的重要性。", "problem": "考虑在单位区间上使用底为 $2$ 的 Halton 序列（即 van der Corput 序列）进行一维拟蒙特卡洛（QMC）积分。对于可积函数 $f:[0,1]\\to\\mathbb{R}$，使用 $N$ 个点的 QMC 估计量为\n$$\nQ_N \\;=\\; \\frac{1}{N}\\sum_{n=0}^{N-1} f\\big(h_n\\big),\n$$\n其中 $h_n$ 是通过将 $n$ 写成以 2 为底的数，反转其数字，然后将结果解释为二进制小数而得到的。取 $N=2^{10}$。\n\n定义一个光滑凸包函数 $g:(-\\infty,\\infty)\\to\\mathbb{R}$ 如下：\n$$\ng(t) \\;=\\; \\begin{cases}\n\\exp\\!\\Big(-\\dfrac{1}{t\\,(1-t)}\\Big),  \\text{若 } 0t1 \\\\\n0, \\text{否则}\n\\end{cases}\n$$\n令 $A = \\int_{0}^{1} g(t)\\,\\mathrm{d}t$。\n\n现在考虑一个精心制作的被积函数\n$$\nf(x) \\;=\\; \\frac{N}{A}\\, g\\big(N(1-x)\\big).\n$$\n令 $I=\\int_0^1 f(x)\\,\\mathrm{d}x$ 为该函数的精确积分。\n\n计算 QMC 估计中的绝对误差，即 $|I - Q_N|$。\n\n*提示：不需要显式计算 $g(t)$ 或积分 $A$。相反，请重点关注 QMC 样本点的位置以及函数 $f(x)$ 的支撑集。*", "solution": "问题要求计算一个特定函数 $f(x)$ 在区间 $[0,1]$ 上使用包含 $N=2^{10}$ 个点的拟蒙特卡洛（QMC）方法时的绝对积分误差 $|I - Q_N|$。积分为 $I=\\int_{0}^{1}f(x)\\,dx$，QMC 估计量为 $Q_N = \\frac{1}{N}\\sum_{n=0}^{N-1} f(h_n)$，其中 $\\{h_n\\}$ 是底为 2 的 Halton 序列。\n\n首先，我们必须确定 QMC 样本点集 $\\{h_n\\}_{n=0}^{N-1}$。问题陈述这些点是底为 $b=2$ 的 Halton 序列的前 $N=2^{10}$ 个点，该序列也称为 van der Corput 序列。对于整数 $n \\in \\{0, 1, \\dots, N-1\\}$，其以 2 为底的表示可以用 10 位（因为 $N=2^{10}$）写出，即 $n = \\sum_{j=0}^{9} a_j 2^j$，其中 $a_j \\in \\{0, 1\\}$。对应的 Halton 点 $h_n$ 是通过反转位 $a_j$ 的顺序并将结果解释为二进制小数得到的：\n$$\nh_n = \\sum_{j=0}^{9} a_j 2^{-(j+1)}\n$$\n底为 $b$ 的 Halton 序列的前 $N=b^m$ 个点的一个基本性质是，它们构成了以 b 为底的 $(0,m,1)$-网。在我们的情况中，$b=2$ 且 $m=10$，这意味着点集 $\\{h_n\\}_{n=0}^{N-1}$ 正好是所有分母为 $N$ 的分数的集合：\n$$\n\\{h_n\\}_{n=0}^{N-1} = \\left\\{\\frac{k}{N} \\;\\bigg|\\; k=0, 1, \\dots, N-1\\right\\}\n$$\n为了验证这一点，考虑一个任意点 $h_n$。将其乘以 $N=2^{10}$ 会得到一个整数：\n$$\nN h_n = 2^{10} \\sum_{j=0}^{9} a_j 2^{-(j+1)} = \\sum_{j=0}^{9} a_j 2^{9-j}\n$$\n设求和索引为 $k=9-j$。当 $j$ 从 $0$ 取到 $9$ 时，$k$ 从 $9$ 取到 $0$。该表达式变为 $N h_n = \\sum_{k=0}^{9} a_{9-k} 2^k$。这个整数的以 2 为底的表示是 $(a_0 a_1 \\dots a_9)_2$。原始整数 $n$ 的表示是 $(a_9 a_8 \\dots a_0)_2$。从 $n$ 到 $N h_n$ 的映射是整数集合 $\\{0, 1, \\dots, N-1\\}$ 上的一个位反转置换。由于这是一个置换，当 $n$ 遍历从 $0$ 到 $N-1$ 的所有整数时，$N h_n$ 也恰好一次性地覆盖了从 $0$ 到 $N-1$ 的所有整数。因此，点集 $\\{h_n\\}$ 确实是 $\\{k/N\\}_{k=0}^{N-1}$。\n\n接下来，我们分析被积函数 $f(x) = \\frac{N}{A}\\, g(N(1-x))$。函数 $g(t)$ 仅在 $t \\in (0,1)$ 时非零。因此，$f(x)$ 仅当其自变量 $N(1-x)$ 在区间 $(0,1)$ 内时才非零。这导致了以下不等式：\n$$\n0  N(1-x)  1\n$$\n左边的不等式 $0  N(1-x)$ 意味着 $0  1-x$，即 $x  1$。\n右边的不等式 $N(1-x)  1$ 意味着 $1-x  \\frac{1}{N}$，即 $x  1 - \\frac{1}{N}$。\n因此，$f(x)$ 的支撑集是开区间 $\\left(1-\\frac{1}{N}, 1\\right)$。对于此区间外的任何 $x$，$f(x)=0$。\n\n现在我们可以计算 QMC 估计量 $Q_N$：\n$$\nQ_N = \\frac{1}{N}\\sum_{n=0}^{N-1} f(h_n)\n$$\n我们需要在每个 QMC 点 $h_n = k/N$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）处计算 $f(x)$ 的值。为了使 $f(h_n)$ 可能非零，点 $h_n$ 必须位于 $f(x)$ 的支撑集内。我们必须检查是否有任何点 $k/N$ 落入区间 $\\left(1-\\frac{1}{N}, 1\\right)$：\n$$\n1-\\frac{1}{N}  \\frac{k}{N}  1\n$$\n将不等式的所有部分乘以 $N$（一个正数）得到：\n$$\nN-1  k  N\n$$\n因为 $k$ 必须是整数，所以不存在满足此严格不等式的整数 $k$。这意味着没有任何 QMC 样本点 $h_n$ 落入 $f(x)$ 非零的开区间。点 $h_n$ 都小于或等于支撑集的左边界 $1-\\frac{1}{N}$。具体来说，最大的点对应 $k=N-1$，即 $h_n = \\frac{N-1}{N} = 1-\\frac{1}{N}$。\n在这个边界点上，$g$ 的自变量是 $t = N(1-x) = N\\left(1 - \\left(1-\\frac{1}{N}\\right)\\right) = N\\left(\\frac{1}{N}\\right) = 1$。$g(t)$ 的定义指明它仅在 $0t1$ 时非零；在边界处 $t=1$，$g(1)=0$。因此，对于所有 $h_n$，我们都有 $f(h_n)=0$。\nQMC 估计量变为：\n$$\nQ_N = \\frac{1}{N}\\sum_{n=0}^{N-1} 0 = 0\n$$\n\n最后，我们计算精确积分 $I=\\int_0^1 f(x)\\,\\mathrm{d}x$。\n$$\nI = \\int_0^1 \\frac{N}{A}\\, g\\big(N(1-x)\\big) \\,\\mathrm{d}x\n$$\n我们进行变量代换。令 $t = N(1-x)$。那么 $x = 1 - \\frac{t}{N}$，$\\mathrm{d}x = -\\frac{1}{N}\\,\\mathrm{d}t$。积分限的变换为：当 $x=0$ 时，$t=N(1-0)=N$；当 $x=1$ 时，$t=N(1-1)=0$。\n$$\nI = \\frac{N}{A} \\int_{N}^{0} g(t) \\left(-\\frac{1}{N}\\right) \\,\\mathrm{d}t = \\frac{N}{A} \\frac{1}{N} \\int_{0}^{N} g(t) \\,\\mathrm{d}t = \\frac{1}{A} \\int_{0}^{N} g(t) \\,\\mathrm{d}t\n$$\n由于 $g(t)$ 仅在 $(0,1)$ 上非零，我们可以将积分限从 $[0,N]$ 缩小到 $[0,1]$：\n$$\nI = \\frac{1}{A} \\int_{0}^{1} g(t) \\,\\mathrm{d}t\n$$\n问题定义了 $A = \\int_{0}^{1} g(t)\\,\\mathrm{d}t$。因此，\n$$\nI = \\frac{1}{A} \\cdot A = 1\n$$\n\n绝对误差为：\n$$\n|I - Q_N| = |1 - 0| = 1\n$$", "answer": "$$\\boxed{1}$$", "id": "3285819"}, {"introduction": "从理论上的最坏情况转向实际挑战，这个练习 [@problem_id:3310947] 解决了在积分周期函数时可能出现的“共振”或“混叠”问题。您将发现被积函数中的某些频率如何与哈尔顿序列的基数“合谋”，产生巨大的系统性误差。最终目标不仅是识别问题，更是通过设计一种“抗共振”的基数分配方案来解决它，这是高阶拟蒙特卡洛实践者的一项关键技能。", "problem": "要求您通过在 $d$ 维单位超立方体上对可分离的三角被积函数 $f(\\mathbf{x})=\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_j\\big)$ 进行积分，来研究使用 Halton 序列的拟蒙特卡罗积分中的混叠现象。您必须从第一性原理出发来完成此项任务：独立变量乘积的积分定义、通过基-$b$ 根式逆定义的 Halton 序列，以及三角积分和有限几何级数求和的基本性质。\n\n您的任务如下。\n\n1. 推导积分的精确值\n$$\nI=\\int_{[0,1]^d}\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_j\\big)\\,\\mathrm{d}\\mathbf{x},\n$$\n仅从以下基本依据出发：\n- 对独立变量的可分离乘积的积分分解。\n- 对于任意整数 $m$，若 $m\\neq 0$ 则 $\\int_{0}^{1}\\cos(2\\pi m x)\\,\\mathrm{d}x=0$，若 $m=0$ 则等于 $1$ 这一事实。\n您的程序必须使用此结果来计算任何给定向量 $\\mathbf{m}=(m_1,\\dots,m_d)$ 的精确积分。\n\n2. 使用根式逆映射，实现具有两两互质整数基 $\\mathbf{b}=(b_1,\\dots,b_d)$ 的 $d$ 维 Halton 序列。对于每个坐标 $j$，第 $n$ 个点的坐标为\n$$\nx_{n,j}=\\phi_{b_j}(n)=\\sum_{r=0}^{\\infty} a_r(n;b_j)\\,b_j^{-(r+1)},\n$$\n其中 $n=\\sum_{r=0}^{R} a_r(n;b_j)\\,b_j^{r}$ 是 $n$ 的基-$b_j$ 展开，其数位 $a_r(n;b_j)\\in\\{0,1,\\dots,b_j-1\\}$ 且只有有限个非零数位。使用前 $N$ 个点 $\\{\\mathbf{x}_n\\}_{n=0}^{N-1}$ 构成拟蒙特卡罗估计量\n$$\n\\widehat{I}_N=\\frac{1}{N}\\sum_{n=0}^{N-1}\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_{n,j}\\big).\n$$\n\n3. 识别导致系统性非零样本均值的频率 $m_j$ 和基 $b_j$ 之间的共振（混叠）。您必须仅使用以下第一性原理进行推理：\n- 基为 $b$ 的一维 van der Corput 序列的前 $b^K$ 项以某种顺序枚举了有理数网格 $\\{0,1/b^K,\\dots,(b^K-1)/b^K\\}$ 这一事实。\n- 在均匀网格上的复指数的有限几何级数求和恒等式，即\n$$\n\\frac{1}{B}\\sum_{i=0}^{B-1} \\exp\\!\\big(2\\pi \\mathrm{i}\\, m\\, i/B\\big)=\n\\begin{cases}\n1, \\text{若 } B \\text{ 整除 } m,\\\\\n0, \\text{否则。}\n\\end{cases}\n$$\n使用这些原理，对于给定的 $N$、$b_j$ 和 $m_j$，判断坐标 $j$ 的贡献是否在前 $N$ 个样本上与基 $b_j$ 发生共振，即对于每个 $n\\in\\{0,\\dots,N-1\\}$，都导致 $\\cos\\!\\big(2\\pi m_j x_{n,j}\\big)=1$。您的程序必须输出一个布尔标志，当且仅当所有坐标在此标准下同时发生共振时，该标志为真。\n\n4. 反共振基分配：对于固定的频率向量 $\\mathbf{m}$ 和基的多重集 $\\{b_1,\\dots,b_d\\}$，设计一种基到维度的分配（即基在坐标间的排列），以最小化给定 $N$ 的共振坐标数量。在所有最小化共振坐标数量的分配中，您可以选择任意一种。您的程序必须计算原始分配下的估计量误差以及您的最佳反共振分配下的估计量误差。\n\n您必须实现一个完整的程序，为以下测试套件执行上述任务。对于每个测试用例，使用指定的维度 $d$、基 $\\mathbf{b}$、样本大小 $N$ 和频率向量 $\\mathbf{m}$ 运行估计器。使用任务1中推导出的精确积分作为基准真相。所有角度均以弧度为单位。没有物理单位。浮点数输出必须四舍五入到六位小数。\n\n测试套件：\n- 案例 A（理想路径，非共振）：$d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(1,1)$。此案例的必需输出：列表 $[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n- 案例 B（完全共振与反共振设计）：$d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(1024,2187)$。此案例的必需输出：列表 $[|\\widehat{I}_N-I|,|\\widehat{I}_N^{\\mathrm{anti}}-I|]$，其中 $\\widehat{I}_N^{\\mathrm{anti}}$ 使用您的最佳反共振基分配。\n- 案例 C（部分共振）：$d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(1024,1)$。必需输出：$[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n- 案例 D（边界条件 $N=1$）：$d=3$, $\\mathbf{b}=(2,3,5)$, $N=1$, $\\mathbf{m}=(7,11,13)$。必需输出：$[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n- 案例 E（零频率精确性）：$d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(0,0)$。必需输出：$[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含案例 A 到 E 的结果，按顺序排列。该输出是一个用方括号括起来的逗号分隔列表，每个案例的结果本身也是一个以上述形式指定的列表。例如：[[a1,a2,a3],[b1,b2],[c1,c2,c3],[d1,d2,d3],[e1,e2,e3]]。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **被积函数**: $f(\\mathbf{x})=\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_j\\big)$\n- **积分域**: $d$ 维单位超立方体, $[0,1]^d$。\n- **精确积分定义**: $I=\\int_{[0,1]^d}\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_j\\big)\\,\\mathrm{d}\\mathbf{x}$。\n- **积分计算的第一性原理**: 假定对独立变量的可分离乘积的积分可分解。\n- **积分计算的第二性原理**: 对于任意整数 $m$，若 $m=0$ 则 $\\int_{0}^{1}\\cos(2\\pi m x)\\,\\mathrm{d}x=1$，若 $m\\neq 0$ 则 $\\int_{0}^{1}\\cos(2\\pi m x)\\,\\mathrm{d}x=0$。\n- **Halton 序列定义**: 对于每个坐标 $j$，第 $n$ 个点的坐标为 $x_{n,j}=\\phi_{b_j}(n)=\\sum_{r=0}^{\\infty} a_r(n;b_j)\\,b_j^{-(r+1)}$，其中 $n=\\sum_{r=0}^{R} a_r(n;b_j)\\,b_j^{r}$ 是 $n$ 的基-$b_j$ 展开。基 $\\mathbf{b}=(b_1,\\dots,b_d)$ 是两两互质的整数。\n- **拟蒙特卡罗估计量**: $\\widehat{I}_N=\\frac{1}{N}\\sum_{n=0}^{N-1}\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_{n,j}\\big)$，使用前 $N$ 个点 $\\{\\mathbf{x}_n\\}_{n=0}^{N-1}$。\n- **共振分析的第一性原理**: 基为 $b$ 的一维 Halton 序列（van der Corput 序列）的前 $b^K$ 项以某种排列枚举了有理数网格 $\\{0,1/b^K,\\dots,(b^K-1)/b^K\\}$。\n- **共振分析的第二性原理**: 有限几何级数求和恒等式：$\\frac{1}{B}\\sum_{i=0}^{B-1} \\exp\\!\\big(2\\pi \\mathrm{i}\\, m\\, i/B\\big)$ 在 $B$ 整除 $m$ 时为 $1$，否则为 $0$。\n- **共振定义**: 如果对于每个 $n\\in\\{0,\\dots,N-1\\}$ 都有 $\\cos\\!\\big(2\\pi m_j x_{n,j}\\big)=1$，则坐标 $j$ 发生共振。\n- **反共振任务**: 为固定的 $\\mathbf{m}$ 和 $N$ 找到基 $\\mathbf{b}$ 的一个排列，以最小化共振坐标的数量。\n- **测试用例**:\n    - 案例 A: $d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(1,1)$。输出: $[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n    - 案例 B: $d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(1024,2187)$。输出: $[|\\widehat{I}_N-I|,|\\widehat{I}_N^{\\mathrm{anti}}-I|]$。\n    - 案例 C: $d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(1024,1)$。输出: $[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n    - 案例 D: $d=3$, $\\mathbf{b}=(2,3,5)$, $N=1$, $\\mathbf{m}=(7,11,13)$。输出: $[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n    - 案例 E: $d=2$, $\\mathbf{b}=(2,3)$, $N=1000$, $\\mathbf{m}=(0,0)$。输出: $[\\widehat{I}_N,|\\widehat{I}_N-I|,\\text{full\\_resonance}]$。\n- **格式化**: 浮点数四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题植根于数值分析这一成熟的数学领域，特别是拟蒙特卡罗（QMC）方法。Halton 序列、根式逆函数以及混叠（共振）分析都是标准课题。所提供的原理是正确的。\n2.  **良构性**：该问题是良构的。任务定义清晰，能够得出唯一或可证明可计算的结果。对于反共振分配，任何能实现最小共振数的排列都是可接受的，这不违反良构性。\n3.  **客观性**：语言精确、正式，没有主观性。所有术语都是标准的或有明确定义。\n4.  **自洽性与一致性**：该问题提供了执行所需任务的所有必要定义、原理和数据。没有内部矛盾。\n5.  **相关性**：该问题直接且根本上是关于 Halton 序列及其在 QMC 积分中的应用，这是随机模拟和蒙特卡罗方法的核心课题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个结构良好的数值分析练习，要求基于第一性原理进行推导和实现。现在将开始解答过程。\n\n### 推导与算法设计\n\n#### 任务 1：积分的精确值\n要计算的积分是 $I=\\int_{[0,1]^d}\\prod_{j=1}^{d}\\cos\\!\\big(2\\pi m_j x_j\\big)\\,\\mathrm{d}\\mathbf{x}$。被积函数 $f(\\mathbf{x}) = \\prod_{j=1}^{d} f_j(x_j)$，其中 $f_j(x_j) = \\cos(2\\pi m_j x_j)$，是变量 $x_1, \\dots, x_d$ 的一个可分离函数。对于此类函数，根据 Fubini 定理，在超立方体 $[0,1]^d$ 上的积分可以分解为一维积分的乘积：\n$$\nI = \\prod_{j=1}^{d} \\int_{0}^{1} \\cos(2\\pi m_j x_j) \\, \\mathrm{d}x_j\n$$\n问题给出了整数频率 $m$ 的一维积分值：\n$$\n\\int_{0}^{1} \\cos(2\\pi m x) \\, \\mathrm{d}x = \\begin{cases} 1  \\text{若 } m=0 \\\\ 0  \\text{若 } m \\neq 0 \\end{cases}\n$$\n这个结果很容易验证：如果 $m \\neq 0$，其反导数是 $\\frac{1}{2\\pi m}\\sin(2\\pi m x)$，在上下限 $x=0$ 和 $x=1$ 处的值均为 $0$。如果 $m=0$，被积函数为 $\\cos(0)=1$，且 $\\int_0^1 1\\,\\mathrm{d}x = 1$。\n\n要使积分的乘积不为零，每个因子都必须不为零。第 $j$ 个因子仅在 $m_j=0$ 时不为零，此时其值为 $1$。因此，当且仅当所有 $m_j=0$（对于 $j=1, \\dots, d$）时，整个乘积 $I$ 等于 $1$。只要有一个 $m_j$ 不为零，其对应的积分就是 $0$，这使得整个乘积 $I$ 等于 $0$。\n因此，精确积分的值为：\n$$\nI = \\begin{cases} 1  \\text{若 } \\mathbf{m} = \\mathbf{0} \\text{ (即对于所有 } j \\text{ 都有 } m_j=0) \\\\ 0  \\text{否则} \\end{cases}\n$$\n\n#### 任务 2：Halton 序列和 QMC 估计量\nHalton 序列的基础是根式逆函数 $\\phi_b(n)$。给定一个整数 $n \\ge 0$ 和一个基 $b \\ge 2$，我们首先找到 $n$ 的基-$b$ 表示：$n = \\sum_{r=0}^{R} a_r b^r$。根式逆是通过用 $b$ 的负幂次重新解释这个展开式得到的：\n$$\nx_n = \\phi_b(n) = \\sum_{r=0}^{R} a_r b^{-(r+1)}\n$$\n这个操作有效地将 $n$ 在基 $b$ 下的数位反转，并置于小数点后。例如，在基 $b=10$ 下，如果 $n=123$，则 $\\phi_{10}(123) = 0.321$。计算它的算法是：\n1. 初始化 `result = 0.0` 和 `f = 1.0 / b`。\n2. 当 `n  0` 时：\n   a. 获取最低有效位：`digit = n % b`。\n   b. 加上其贡献：`result += digit * f`。\n   c. 更新 `n`：`n //= b`。\n   d. 更新分数幂：`f /= b`。\n3. 返回 `result`。\n\n$d$ 维 Halton 序列使用一组 $d$ 个两两互质的基 $\\mathbf{b}=(b_1, \\dots, b_d)$。序列的第 $n$ 个点是 $\\mathbf{x}_n = (\\phi_{b_1}(n), \\phi_{b_2}(n), \\dots, \\phi_{b_d}(n))$。\n积分 $I$ 的 QMC 估计量是在前 $N$ 个 Halton 点（对于 $n=0, \\dots, N-1$）上计算的被积函数的样本均值：\n$$\n\\widehat{I}_N = \\frac{1}{N} \\sum_{n=0}^{N-1} f(\\mathbf{x}_n) = \\frac{1}{N} \\sum_{n=0}^{N-1} \\prod_{j=1}^{d} \\cos(2\\pi m_j x_{n,j})\n$$\n\n#### 任务 3：共振条件\n坐标 $j$ 的共振由严格条件 $\\cos(2\\pi m_j x_{n,j}) = 1$ 对所有 $n \\in \\{0, \\dots, N-1\\}$ 定义。这当且仅当余弦的参数是 $2\\pi$ 的整数倍时成立，即对于所有 $n \\in \\{0, \\dots, N-1\\}$，$m_j x_{n,j}$ 必须是整数。\n\n让我们分析点 $x_{n,j} = \\phi_{b_j}(n)$ 的结构。根据定义，对于任何 $n$，$\\phi_{b_j}(n)$ 是一个有理数，其分母是基 $b_j$ 的幂。让我们确定前 $N$ 个点的分母所需 $b_j$ 的最高次幂。\n一个整数 $n  N$ 在其基-$b_j$ 展开中最多有 $K$ 位数，其中 $K$ 是满足 $b_j^K \\ge N$ 的最小整数。对于 $N1$，这等于 $K=\\lceil\\log_{b_j}N\\rceil$。对于 $N=1$，我们只考虑 $n=0$，所以 $K=0$。\n根式逆 $\\phi_{b_j}(n)$ 是通过对项 $a_r b_j^{-(r+1)}$ 求和形成的。对于需要 $K$ 位数的 $n$（即 $b_j^{K-1} \\le n  b_j^K$），得到的点 $\\phi_{b_j}(n)$ 可以写成一个分母为 $b_j^K$ 的分数。具体来说，$\\phi_{b_j}(n) = \\text{整数} / b_j^K$。\n\n要使 $m_j \\phi_{b_j}(n)$ 对于所有 $n \\in \\{0, \\dots, N-1\\}$ 都是整数，$m_j$ 必须是所有这些点的分母的倍数。点集 $\\{\\phi_{b_j}(n)\\}_{n=0}^{N-1}$ 包括其最简分数形式分母高达 $b_j^K$ 的值。例如，对于 $N  b_j^{K-1}$，对应于 $n=b_j^{K-1}$ 的点是 $\\phi_{b_j}(b_j^{K-1}) = 1/b_j^K$。要使 $m_j \\cdot (1/b_j^K)$ 为整数，必要条件是 $m_j$ 是 $b_j^K$ 的倍数。这个条件也是充分的，因为如果 $m_j = c \\cdot b_j^K$（其中 $c$ 是整数），那么对于任何点 $x_{n,j} = \\text{整数} / b_j^K$，乘积 $m_j x_{n,j} = c \\cdot (\\text{整数})$ 是一个整数。\n\n因此，坐标 $j$ 的共振条件是 $m_j$ 能被 $b_j^K$ 整除，其中对于 $N1$，$K = \\lceil\\log_{b_j}N\\rceil$，对于 $N=1$，$K=0$。这可以表述为 $m_j \\equiv 0 \\pmod{b_j^K}$。一种基于整数的方法来找到 $N1$ 时的 $K$ 是，找到满足 $b_j^K \\ge N$ 的最小整数 $K$。\n\n#### 任务 4：反共振基分配\n给定一个频率向量 $\\mathbf{m}$ 和一个基的多重集，目标是找到基的一个排列，以最小化共振坐标对的数量。对于维度 $j$ 的频率 $m_j$ 和分配的基 $b'$，如果满足任务 3 中推导的条件，就会发生共振。\n算法如下：\n1. 识别频率 $\\{m_1, \\dots, m_d\\}$ 与给定基 $\\{b_1, \\dots, b_d\\}$ 的所有可能配对。这些对应于基的 $d!$ 种排列。\n2. 对于基的每一种排列，例如 $\\mathbf{b}'=(b'_{\\pi(1)}, \\dots, b'_{\\pi(d)})$，计算共振对 $(m_j, b'_{\\pi(j)})$ 的总数。\n3. 选择一个导致共振数最小的排列。\n4. 使用这个最优基分配计算 QMC 估计量 $\\widehat{I}_N^{\\mathrm{anti}}$。\n\n对于本问题中的案例，$d$ 很小（$2$ 或 $3$），使得对所有排列进行穷举搜索在计算上是微不足道的。对于 $d=2$，只有两种可能性：原始分配 $(b_1, b_2)$ 和交换后的分配 $(b_2, b_1)$。我们比较每种情况下的共振数，并选择较好的一种。", "answer": "```python\nimport numpy as np\nimport math\nfrom itertools import permutations\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def radical_inverse(n, b):\n        \"\"\"Computes the radical inverse of n in base b.\"\"\"\n        if n == 0:\n            return 0.0\n        res = 0.0\n        f = 1.0 / b\n        while n  0:\n            res += (n % b) * f\n            n //= b\n            f /= b\n        return res\n\n    def get_resonance_power_k(b, N):\n        \"\"\"Computes the integer power K for the resonance condition.\"\"\"\n        if N = 1:\n            return 0\n        # K is the smallest integer such that b^K = N.\n        # This is equivalent to ceil(log_b(N)).\n        # We use an integer loop to avoid floating point precision issues.\n        k = 0\n        power_of_b = 1\n        while power_of_b  N:\n            power_of_b *= b\n            k += 1\n        return k\n\n    def is_resonant(m, b, N):\n        \"\"\"Checks if a frequency m resonates with base b for N samples.\"\"\"\n        if m == 0:\n            # cos(0) = 1, always resonant in effect.\n            return True\n        k = get_resonance_power_k(b, N)\n        if k == 0:\n            return True\n        \n        # Using Python's arbitrary-precision integers\n        power_of_b = b**k\n        \n        # Check if m is a multiple of b^k\n        return m % power_of_b == 0\n\n    def calculate_estimator(d, b_vec, N, m_vec):\n        \"\"\"Calculates the QMC estimator I_hat_N.\"\"\"\n        total_sum = 0.0\n        \n        for n in range(N):\n            integrand_val = 1.0\n            for j in range(d):\n                x_nj = radical_inverse(n, b_vec[j])\n                term = np.cos(2 * np.pi * m_vec[j] * x_nj)\n                integrand_val *= term\n            total_sum += integrand_val\n        \n        return total_sum / N\n\n    def format_output(results_list):\n        \"\"\"Formats a list of results (floats, bools) into the required string format.\"\"\"\n        formatted_items = []\n        for item in results_list:\n            if isinstance(item, bool):\n                formatted_items.append(str(item).lower())\n            elif isinstance(item, float):\n                formatted_items.append(f\"{item:.6f}\")\n            else:\n                 formatted_items.append(str(item))\n        return f\"[{','.join(formatted_items)}]\"\n\n    all_case_results = []\n    \n    # Test cases defined in the problem\n    test_suite = [\n        {'case': 'A', 'd': 2, 'b': (2, 3), 'N': 1000, 'm': (1, 1)},\n        {'case': 'B', 'd': 2, 'b': (2, 3), 'N': 1000, 'm': (1024, 2187)},\n        {'case': 'C', 'd': 2, 'b': (2, 3), 'N': 1000, 'm': (1024, 1)},\n        {'case': 'D', 'd': 3, 'b': (2, 3, 5), 'N': 1, 'm': (7, 11, 13)},\n        {'case': 'E', 'd': 2, 'b': (2, 3), 'N': 1000, 'm': (0, 0)},\n    ]\n\n    for params in test_suite:\n        d, b_vec, N, m_vec = params['d'], params['b'], params['N'], params['m']\n        \n        I_exact = 1.0 if all(m == 0 for m in m_vec) else 0.0\n\n        if params['case'] in ['A', 'C', 'D', 'E']:\n            I_hat = calculate_estimator(d, b_vec, N, m_vec)\n            error = abs(I_hat - I_exact)\n            full_resonance = all(is_resonant(m_vec[j], b_vec[j], N) for j in range(d))\n            all_case_results.append([I_hat, error, full_resonance])\n\n        elif params['case'] == 'B':\n            # Original assignment\n            I_hat_orig = calculate_estimator(d, b_vec, N, m_vec)\n            error_orig = abs(I_hat_orig - I_exact)\n\n            # Anti-resonant assignment\n            base_permutations = list(permutations(b_vec))\n            min_resonances = d + 1\n            best_b_perm = None\n\n            for b_perm in base_permutations:\n                current_resonances = sum(is_resonant(m_vec[j], b_perm[j], N) for j in range(d))\n                if current_resonances  min_resonances:\n                    min_resonances = current_resonances\n                    best_b_perm = b_perm\n            \n            I_hat_anti = calculate_estimator(d, best_b_perm, N, m_vec)\n            error_anti = abs(I_hat_anti - I_exact)\n            \n            all_case_results.append([error_orig, error_anti])\n\n    final_output_str = f\"[{','.join(format_output(res) for res in all_case_results)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3310947"}]}