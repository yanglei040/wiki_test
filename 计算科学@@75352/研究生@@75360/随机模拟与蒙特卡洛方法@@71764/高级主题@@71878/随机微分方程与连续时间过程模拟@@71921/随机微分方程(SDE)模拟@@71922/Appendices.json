{"hands_on_practices": [{"introduction": "首个练习是基础性的。它将指导您通过经验性方法，验证经典的欧拉-丸山（Euler-Maruyama）法和米尔斯坦（Milstein）法的强收敛阶。这项实践对于建立数值误差行为的直观理解，以及培养验证随机微分方程求解器实现正确性的核心技能至关重要。", "problem": "考虑形式为 $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的一维 Itô 随机微分方程 (SDE)，其初始条件为 $X_0 = x_0$，其中 $W_t$ 是标准布朗运动，$a(\\cdot)$ 和 $b(\\cdot)$ 是足够光滑的函数。强收敛阶量化了路径近似误差如何随时间步长的减小而减小。在此任务中，您将实现蒙特卡洛估计量，以经验性地测量两种广泛使用的数值方案（欧拉-丸山 (EM) 方法和米尔斯坦 (Milstein) 方法）在终端时刻 $T$ 的强收敛阶。您必须使用嵌套布朗增量来耦合不同的时间步长，以确保一致的路径比较。\n\n从以下基本概念开始：\n- 一维 Itô SDE 的定义：$dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$，初始条件为 $X_0 = x_0$，其中 $W_t$ 是标准布朗运动。\n- 终端时刻 $T$ 的强误差概念，即量 $\\mathbb{E}\\left[\\,|\\,X_T - X_T^{(h)}\\,|\\,\\right]$，其中 $X_T$ 是精确解，$X_T^{(h)}$ 是时间步长为 $h$ 的数值近似解。\n- SDE 的数值方案可以从 Itô-Taylor 展开推导得出，且其截断会产生涉及 $a(\\cdot)$、$b(\\cdot)$ 和布朗增量的离散时间更新规则。\n\n您的程序必须：\n- 使用固定随机种子的蒙特卡洛抽样，以确保可复现性。\n- 在 $[0,T]$ 上构建一个具有 $N_{\\text{fine}}$ 个步长的最精细网格，并生成方差为 $T/N_{\\text{fine}}$ 的独立同分布正态增量。对于每个具有 $N$ 个步长的较粗网格，通过对精细网格增量的连续块求和来获得其布朗增量。这保证了所有离散化都使用相同的底层布朗路径。\n- 对于每种方案（欧拉-丸山和米尔斯坦）和每个测试用例，计算多个步长 $h = T/N$ 下终端时刻的平均绝对强误差，然后通过 $\\log\\big(\\text{error}(h)\\big)$ 对 $\\log(h)$ 进行线性回归，以其斜率来估计经验强收敛阶 $p$。\n\n使用以下三个科学上一致且涵盖不同情况的测试用例：\n- 测试用例 1 (几何布朗运动): $dX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t$，其中 $x_0 = 1.0$, $T = 1.0$, $\\mu = 0.3$, $\\sigma = 0.6$。终端时刻的精确值已知：$X_T = x_0 \\exp\\big((\\mu - \\tfrac{1}{2}\\sigma^2)T + \\sigma W_T\\big)$，其中 $W_T$ 是终端布朗值。\n- 测试用例 2 (Ornstein-Uhlenbeck 型，带加性噪声): $dX_t = \\alpha X_t\\,dt + \\beta\\,dW_t$，其中 $x_0 = 1.0$, $T = 1.0$, $\\alpha = -1.5$, $\\beta = 0.5$。不使用终端时刻的精确值；而是对于每种方案，使用同一方案在非常精细的时间步长下的结果作为参考路径来计算强误差。\n- 测试用例 3 (确定性极限): $dX_t = \\alpha X_t\\,dt$，其中 $x_0 = 1.2$, $T = 1.0$, $\\alpha = 0.8$。此处 $b(\\cdot)\\equiv 0$，终端时刻的精确值为 $X_T = x_0 e^{\\alpha T}$。\n\n蒙特卡洛和离散化参数：\n- 蒙特卡洛路径数 $M = 10000$。\n- 最精细网格大小 $N_{\\text{fine}} = 1024$。\n- 较粗网格 $N \\in \\{16, 32, 64, 128\\}$，因此 $h = T/N$ 跨越四个尺度。\n- 针对每个测试用例，对所有较粗网格使用来自最精细网格的嵌套增量。\n- 使用固定随机种子 $42$。\n\n计算要求：\n- 对于测试用例 1，通过将每个方案的终端近似值与使用最精细网格所蕴含的共享 $W_T$ 计算出的精确终端值进行比较，来计算每个 $N$ 的强误差。\n- 对于测试用例 2，通过将每个 $N$ 下方案的终端近似值与同一方案在最精细网格 $N_{\\text{fine}}$ 上的终端近似值进行比较，来计算强误差。\n- 对于测试用例 3，通过将每个方案的终端近似值与精确终端值进行比较，来计算每个 $N$ 的强误差。\n\n然后，对于每个测试用例和方案，通过对四个 $h$ 值下的 $\\log\\big(\\text{error}(h)\\big)$ 对 $\\log(h)$ 的最佳拟合线的斜率来估计经验强收敛阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个估计的阶数，形式为用逗号分隔并用方括号括起来的列表，顺序为 $[\\text{p\\_EM\\_1}, \\text{p\\_Milstein\\_1}, \\text{p\\_EM\\_2}, \\text{p\\_Milstein\\_2}, \\text{p\\_EM\\_3}, \\text{p\\_Milstein\\_3}]$，其中下标表示测试用例索引。\n- 每个条目都必须是浮点数。\n\n不涉及物理单位。不出现角度。不得使用百分比。\n\n测试套件覆盖范围的基本原理：\n- 测试用例 1 检验了具有已知精确解的乘性噪声，旨在探究欧拉-丸山和米尔斯坦方法在光滑系数下的典型强收敛阶。\n- 测试用例 2 检验了加性噪声，此情况下扩散项为常数且其导数项消失，从而揭示当随机积分在离散层面上对于常数扩散项是精确时，这些方案的行为。\n- 测试用例 3 是一个无噪声的边界条件，将 SDE 离散化简化为常微分方程离散化，测试强收敛阶是否与确定性数值积分行为一致。\n\n您的程序必须严格遵守指定的最终输出格式。", "solution": "该问题要求对应用于一维 Itô 随机微分方程 (SDE) 的欧拉-丸山和米尔斯坦数值方案的强收敛阶进行经验估计。强收敛阶（记为 $p$）表征了在终端时刻 $T$ 的路径近似误差随时间步长 $h$ 减小而减小的速率。\n\n一维 Itô SDE 由以下形式微分方程描述：\n$$ dX_t = a(X_t) \\, dt + b(X_t) \\, dW_t, \\quad X_0 = x_0 $$\n其中 $X_t$ 是随机过程，$a(\\cdot)$ 是漂移系数，$b(\\cdot)$ 是扩散系数，$W_t$ 是标准的一维布朗运动（维纳过程）。\n\n对于步长为 $h$ 的数值近似解 $X_T^{(h)}$，其在终端时刻 $T$ 的强误差定义为数值解与真实解之间的期望绝对差：\n$$ \\epsilon(h) = \\mathbb{E}\\left[ \\,|\\, X_T - X_T^{(h)} \\,|\\, \\right] $$\n如果对于较小的 $h$，有 $\\epsilon(h) = \\mathcal{O}(h^p)$，则称一个方案的强收敛阶为 $p$。取对数后，我们得到 $\\log(\\epsilon(h)) \\approx C + p \\log(h)$，这意味着 $p$ 可以通过对 $\\log(\\epsilon(h))$ 关于 $\\log(h)$ 进行线性回归的斜率来估计。我们将使用蒙特卡洛方法来估计该期望。\n\n### 数值方案\n\nSDE 的数值方案通常由过程 $X_t$ 的 Itô-Taylor 展开推导而来。\n\n**欧拉-丸山 (EM)** 方案是最简单的方法，通过截断 Itô-Taylor 展开得到。对于具有恒定步长 $h = t_{n+1} - t_n$ 的离散时间网格 $0 = t_0  t_1  \\dots  t_N = T$，其更新规则为：\n$$ X_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n $$\n其中 $X_n$ 是 $X_{t_n}$ 的近似值，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 是一个布朗增量，服从正态分布的随机变量 $\\mathcal{N}(0, h)$。在 $a$ 和 $b$ 满足适当的光滑性条件下，EM 方案的强收敛阶为 $p=0.5$。\n\n**米尔斯坦 (Milstein)** 方案在 Itô-Taylor 展开中包含了一个附加项，该项考虑了扩散项与其自身的相互作用。其更新规则是：\n$$ X_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left( (\\Delta W_n)^2 - h \\right) $$\n其中 $b'(x) = \\frac{db}{dx}$。这个修正项通常能提高精度，对于具有光滑系数的 SDE，米尔斯坦方案的强收敛阶为 $p=1.0$。\n\n### 模拟与估计方法论\n\n我们将为一组步长 $h_k = T/N_k$（其中 $N_k \\in \\{16, 32, 64, 128\\}$）估计强误差 $\\epsilon(h)$。期望值通过对 $M=10000$ 条模拟路径进行蒙特卡洛平均来近似：\n$$ \\epsilon(h) \\approx \\frac{1}{M} \\sum_{i=1}^{M} \\left| \\, X_T^{(i)} - X_{T,h}^{(i)} \\, \\right| $$\n其中 $X_T^{(i)}$ 是第 $i$ 条路径的参考解，$X_{T,h}^{(i)}$ 是数值近似解。\n\n为确保一致的路径比较，我们采用**嵌套增量**方法。在具有 $N_{\\text{fine}}=1024$ 个步长的精细网格上生成单个布朗路径。此精细路径的增量是独立同分布的随机变量 $\\Delta W_k^{\\text{fine}} \\sim \\mathcal{N}(0, T/N_{\\text{fine}})$。任何具有 $N$ 个步长（其中 $N$ 是 $N_{\\text{fine}}$ 的因子）的较粗网格的增量，都通过对 $R = N_{\\text{fine}}/N$ 个连续的精细增量求和来构建。这确保了所有离散化所使用的底层布朗运动是相同的，从而减小了误差估计的方差。\n\n然后，对于每个方案和测试用例，通过对数据对 $(\\log(h_k), \\log(\\epsilon(h_k)))$ 进行线性回归来估计收敛阶 $p$。该回归线的斜率提供了 $p$ 的经验估计。\n\n### 测试用例分析\n\n三个测试用例旨在探究方案在不同条件下的行为。\n\n**测试用例 1: 几何布朗运动**\n- SDE: $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$，其中 $X_0 = 1.0$, $T=1.0$, $\\mu=0.3$, $\\sigma=0.6$。\n- 系数: $a(x) = \\mu x$, $b(x) = \\sigma x$，以及 $b'(x) = \\sigma$。\n- EM 规则: $X_{n+1} = X_n(1 + \\mu h + \\sigma \\Delta W_n)$。\n- Milstein 规则: $X_{n+1} = X_n(1 + \\mu h + \\sigma \\Delta W_n) + \\frac{1}{2} \\sigma^2 X_n ((\\Delta W_n)^2 - h)$。\n- 参考解: 时刻 $T$ 的精确解为 $$X_T = X_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)T + \\sigma W_T\\right)$$ 其中 $W_T$ 是所有精细网格布朗增量之和。\n- 预期阶数: 这是一个具有乘性噪声的标准案例。理论阶数对于 EM 为 $p=0.5$，对于 Milstein 为 $p=1.0$。\n\n**测试用例 2: Ornstein-Uhlenbeck 型，带加性噪声**\n- SDE: $dX_t = \\alpha X_t \\, dt + \\beta \\, dW_t$，其中 $X_0 = 1.0$, $T=1.0$, $\\alpha=-1.5$, $\\beta=0.5$。\n- 系数: $a(x) = \\alpha x$, $b(x) = \\beta$ (常数)，以及 $b'(x) = 0$。\n- 由于 $b'(x) = 0$，米尔斯坦方案中的修正项消失。因此，米尔斯坦方案与欧拉-丸山方案相同：$X_{n+1} = X_n + \\alpha X_n h + \\beta \\Delta W_n$。\n- 参考解: 由于不使用精确解，参考解是使用同一方案在 $N_{\\text{fine}}=1024$ 步长的精细网格上进行的高精度数值模拟。\n- 预期阶数: 因为扩散系数 $b(x)$ 是常数，随机积分部分被两种方案精确离散化。近似误差仅来源于漂移项的离散化，这是一个一阶欧拉方法。因此，两种方案预计都将表现出 $p=1.0$ 的强收敛阶。\n\n**测试用例 3: 确定性极限**\n- SDE: $dX_t = \\alpha X_t \\, dt$，其中 $X_0 = 1.2$, $T=1.0$, $\\alpha=0.8$。\n- 这是一个常微分方程 (ODE)，因为扩散项为零，$b(x) \\equiv 0$，这也意味着 $b'(x) \\equiv 0$。\n- EM 和 Milstein 方案都简化为求解 ODE 的显式欧拉法：$X_{n+1} = X_n + \\alpha X_n h = X_n(1 + \\alpha h)$。\n- 参考解: 精确解为 $X_T = X_0 e^{\\alpha T}$。\n- 预期阶数: 求解 ODE 的显式欧拉法具有 $1.0$ 的收敛阶。因此，两种方案预计都将得到 $p \\approx 1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates the strong convergence order for the Euler-Maruyama and Milstein\n    schemes across three different SDE test cases.\n    \"\"\"\n    # Define global simulation parameters.\n    M = 10000\n    N_fine = 1024\n    Ns = np.array([16, 32, 64, 128])\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n    \n    results = []\n\n    # === Test Case 1: Geometric Brownian Motion ===\n    x0_1, T_1, mu_1, sigma_1 = 1.0, 1.0, 0.3, 0.6\n    h_values_1 = T_1 / Ns\n    \n    # Generate one set of fine Brownian increments for all paths\n    fine_dWs_1 = rng.normal(loc=0.0, scale=np.sqrt(T_1 / N_fine), size=(M, N_fine))\n    \n    # Calculate exact terminal value as reference\n    W_T_1 = np.sum(fine_dWs_1, axis=1)\n    exact_XT_1 = x0_1 * np.exp((mu_1 - 0.5 * sigma_1**2) * T_1 + sigma_1 * W_T_1)\n\n    em_errors_1, milstein_errors_1 = [], []\n    for N in Ns:\n        h = T_1 / N\n        R = N_fine // N\n        coarse_dWs = fine_dWs_1.reshape(M, N, R).sum(axis=2)\n        \n        # Euler-Maruyama simulation\n        X_em = np.full(M, x0_1)\n        for i in range(N):\n            dW = coarse_dWs[:, i]\n            X_em += mu_1 * X_em * h + sigma_1 * X_em * dW\n        em_errors_1.append(np.mean(np.abs(X_em - exact_XT_1)))\n\n        # Milstein simulation\n        X_milstein = np.full(M, x0_1)\n        for i in range(N):\n            dW = coarse_dWs[:, i]\n            X_milstein += mu_1 * X_milstein * h + sigma_1 * X_milstein * dW + \\\n                          0.5 * sigma_1 * sigma_1 * X_milstein * (dW**2 - h)\n        milstein_errors_1.append(np.mean(np.abs(X_milstein - exact_XT_1)))\n\n    p_em_1 = np.polyfit(np.log(h_values_1), np.log(em_errors_1), 1)[0]\n    p_milstein_1 = np.polyfit(np.log(h_values_1), np.log(milstein_errors_1), 1)[0]\n    results.extend([p_em_1, p_milstein_1])\n\n    # === Test Case 2: Ornstein-Uhlenbeck-type (Additive Noise) ===\n    x0_2, T_2, alpha_2, beta_2 = 1.0, 1.0, -1.5, 0.5\n    h_values_2 = T_2 / Ns\n\n    fine_dWs_2 = rng.normal(loc=0.0, scale=np.sqrt(T_2 / N_fine), size=(M, N_fine))\n    \n    # Reference solution is the fine-grid simulation.\n    # For additive noise, EM and Milstein are identical (b'(x)=0).\n    X_ref_2 = np.full(M, x0_2)\n    h_fine = T_2 / N_fine\n    for i in range(N_fine):\n        dW = fine_dWs_2[:, i]\n        X_ref_2 += alpha_2 * X_ref_2 * h_fine + beta_2 * dW\n        \n    errors_2 = []\n    for N in Ns:\n        h = T_2 / N\n        R = N_fine // N\n        coarse_dWs = fine_dWs_2.reshape(M, N, R).sum(axis=2)\n\n        X_num = np.full(M, x0_2)\n        for i in range(N):\n            dW = coarse_dWs[:, i]\n            X_num += alpha_2 * X_num * h + beta_2 * dW\n        \n        errors_2.append(np.mean(np.abs(X_num - X_ref_2)))\n    \n    p_2 = np.polyfit(np.log(h_values_2), np.log(errors_2), 1)[0]\n    # EM and Milstein orders are the same.\n    p_em_2 = p_2\n    p_milstein_2 = p_2\n    results.extend([p_em_2, p_milstein_2])\n\n    # === Test Case 3: Deterministic Limit (ODE) ===\n    x0_3, T_3, alpha_3 = 1.2, 1.0, 0.8\n    h_values_3 = T_3 / Ns\n\n    # Exact solution for the ODE\n    exact_XT_3 = x0_3 * np.exp(alpha_3 * T_3)\n\n    # For b=0, EM and Milstein are identical (Euler method for ODEs).\n    # The simulation is deterministic, so no Monte Carlo paths are needed.\n    errors_3 = []\n    for N in Ns:\n        h = T_3 / N\n        X_num = float(x0_3) # Use a scalar\n        for _ in range(N):\n            X_num += alpha_3 * X_num * h\n            \n        errors_3.append(np.abs(X_num - exact_XT_3))\n\n    p_3 = np.polyfit(np.log(h_values_3), np.log(errors_3), 1)[0]\n    # EM and Milstein orders are the same.\n    p_em_3 = p_3\n    p_milstein_3 = p_3\n    results.extend([p_em_3, p_milstein_3])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3339961"}, {"introduction": "从理论走向实践，我们常常会遇到一些微妙但至关重要的挑战。这个练习聚焦于米尔斯坦（Milstein）法 ([@problem_id:3339961]) 中的一个关键实现细节，即在浮点数运算中处理 $(\\Delta W_n)^2 - h$ 这一项时可能出现的数值不稳定性。掌握如何避免“灾难性抵消”（catastrophic cancellation）对于为高阶随机微分方程格式编写稳健且精确的代码至关重要。", "problem": "考虑标量随机微分方程 (SDE) $dX_t = a(X_t)\\,dt + \\sigma(X_t)\\,dW_t$，其中 $W_t$ 是一个维纳过程，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 表示在时间步长 $h = t_{n+1} - t_n$ 内的布朗增量。在用于 SDE 数值积分的 Milstein 格式中，出现了一个涉及 $(\\Delta W_n)^2 - h$ 的修正项。根据维纳增量的定义，$\\Delta W_n \\sim \\mathcal{N}(0,h)$，因此 $\\mathbb{E}\\big[(\\Delta W_n)^2\\big] = h$。\n\n要求您使用标准双精度浮点运算，为非常小的时间步长 $h$（具体来说是 $10^{-12} \\le h \\le 10^{-6}$）稳健地实现 Milstein 修正项。假设采用标准的浮点模型，其机器精度为 $\\varepsilon_{\\text{mach}}$，并使用典型的编译器和处理器默认设置（除非明确说明，否则不启用特殊模式）。布朗增量通过 $\\Delta W_n = \\sqrt{h}\\,Z_n$ 生成，其中 $Z_n \\sim \\mathcal{N}(0,1)$。\n\n请指出直接计算 $(\\Delta W_n)^2 - h$ 的潜在陷阱，并选择所有能够在保持 Milstein 项正确分布行为的同时，避免在 $h$ 非常小时发生灾难性抵消和精度损失的可靠保障措施。\n\n对于小的 $h$，以下哪种策略是避免灾难性抵消并保持 Milstein 修正项数值稳健性的可靠保障措施？\n\nA. 使用相同的抽样 $Z_n \\sim \\mathcal{N}(0,1)$ 来计算 $h\\,(Z_n^2 - 1)$，而不是从 $\\Delta W_n$ 构造 $(\\Delta W_n)^2 - h$。\n\nB. 在模拟过程中用 $0$ 替换 $(\\Delta W_n)^2 - h$，因为其期望为 $0$，从而消除减法中的数值误差。\n\nC. 使用积和熔加（fused multiply-add）运算将 $(\\Delta W_n)^2 - h$ 计算为 $\\mathrm{fma}(\\Delta W_n,\\Delta W_n,-h)$，或者在可用时使用扩展精度计算该差值。\n\nD. 从 $(-\\sqrt{h},\\sqrt{h})$ 上的均匀分布中抽样 $\\Delta W_n$，以避免平方运算，从而减少减法中的舍入误差。\n\nE. 计算缩放后的差值 $((\\Delta W_n)^2/h - 1)\\cdot h$，或等效地先计算 $(\\Delta W_n/\\sqrt{h})^2 - 1$（其结果应接近 $Z_n^2 - 1$），然后再乘以 $h$。", "solution": "该问题陈述在科学上是合理的、适定的和客观的。它探讨了随机微分方程数值解中一个著名且实际的问题。所提供的参数和背景是完整和一致的。该问题有效。\n\n核心问题是在时间步长 $h$ 非常小时，如何计算表达式 $ (\\Delta W_n)^2 - h $。我们已知布朗增量 $\\Delta W_n$ 是通过 $\\Delta W_n = \\sqrt{h} Z_n$ 生成的，其中 $Z_n \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。\n\n将此代入表达式，得到：\n$$ (\\Delta W_n)^2 - h = (\\sqrt{h} Z_n)^2 - h = h Z_n^2 - h $$\n由于 $Z_n \\sim \\mathcal{N}(0,1)$，$Z_n$ 的值通常是 $1$ 的量级。例如，大约 $68\\%$ 的抽样值会落在区间 $[-1, 1]$ 内，超过 $95\\%$ 的抽样值会落在 $[-2, 2]$ 内。因此，$Z_n^2$ 也是一个 $1$ 的量级的随机变量。（具体来说，$Z_n^2 \\sim \\chi^2(1)$，其均值为 $1$，方差为 $2$）。这意味着项 $(\\Delta W_n)^2 = h Z_n^2$ 的量级与 $h$ 非常接近。对于很小的 $h$（例如，$h \\approx 10^{-12}$），直接对两个几乎相等的数 $(\\Delta W_n)^2$ 和 $h$ 进行浮点减法，将导致大部分甚至所有有效数字的损失。这种现象被称为灾难性抵消，它会急剧降低结果的精度。\n\n目标是找到在数学上等价（即保持该项的分布）但在数值上稳定的策略。\n\n我们来逐一评估每个选项：\n\n**A. 使用相同的抽样 $Z_n \\sim \\mathcal{N}(0,1)$ 来计算 $h\\,(Z_n^2 - 1)$，而不是从 $\\Delta W_n$ 构造 $(\\Delta W_n)^2 - h$。**\n\n该策略依赖于代数重排：\n$$ (\\Delta W_n)^2 - h = h Z_n^2 - h = h(Z_n^2 - 1) $$\n在数学上，这两个表达式是等价的。在数值上，运算的顺序被改变了。我们首先计算 $Z_n^2 - 1$。由于 $Z_n^2$ 是 $1$ 的量级，减法 $Z_n^2 - 1$ 是两个 $1$ 量级的数之差。这个操作不会遭受灾难性抵消。然后将减法的结果乘以小数 $h$。乘法是一种数值稳定的运算。此方法成功地避免了两个小的、几乎相等的量相减，是标准的稳健实现方法。\n\n该策略是可靠的。**正确**。\n\n**B. 在模拟过程中用 $0$ 替换 $(\\Delta W_n)^2 - h$，因为其期望为 $0$，从而消除减法中的数值误差。**\n\n该项的期望确实为零：$\\mathbb{E}[(\\Delta W_n)^2 - h] = \\mathbb{E}[(\\Delta W_n)^2] - h = h - h = 0$。然而，$(\\Delta W_n)^2 - h$ 是一个随机变量，不是一个常数。其方差非零：\n$$ \\text{Var}((\\Delta W_n)^2 - h) = \\text{Var}(h Z_n^2 - h) = h^2 \\text{Var}(Z_n^2) = 2h^2 $$\n（因为 $Z_n^2 \\sim \\chi^2(1)$，其方差为 $2$）。Milstein 格式的更高阶强收敛性（阶数为 $1.0$，而 Euler-Maruyama 格式为 $0.5$）正是通过包含这个随机修正项来实现的。用一个随机变量的期望值（在此情况下为零）来替换它，会消除该项对路径方差的贡献，实际上是将 Milstein 格式降级为 Euler-Maruyama 格式。这违反了保持正确分布行为的要求。\n\n该策略在根本上是有缺陷的。**不正确**。\n\n**C. 使用积和熔加（fused multiply-add）运算将 $(\\Delta W_n)^2 - h$ 计算为 $\\mathrm{fma}(\\Delta W_n,\\Delta W_n,-h)$，或者在可用时使用扩展精度计算该差值。**\n\n积和熔加（FMA）运算计算形如 $ax+b$ 的表达式，在最后一步只产生一次舍入误差。它在加上 $b$ 之前，以完整的内部精度计算乘积 $ax$。在我们的例子中，这将以高精度计算 $(\\Delta W_n)^2$，然后减去 $h$，最后将最终结果舍入到标准双精度。这极大地减轻了灾难性抵消，因为减法本身是在一个有效精度高得多的环境下执行的（例如，标准双精度 FMA 的尾数有 106 位）。类似地，使用更高精度的浮点类型（例如 80 位扩展精度或 128 位四倍精度）来执行计算 $(\\Delta W_n)^2 - h$，会为尾数分配更多的比特，从而可以保留差值的有效数字。这两种都是在当前场景下提高数值精度的有效硬件级或库级技术。\n\n该策略是一个可靠且实用的保障措施。**正确**。\n\n**D. 从 $(-\\sqrt{h},\\sqrt{h})$ 上的均匀分布中抽样 $\\Delta W_n$，以避免平方运算，从而减少减法中的舍入误差。**\n\n该策略建议改变布朗增量的基本统计特性。维纳过程增量 $\\Delta W_n$ 必须是正态分布的，即 $\\Delta W_n \\sim \\mathcal{N}(0,h)$，方差为 $h$。一个从 $(-\\sqrt{h},\\sqrt{h})$ 上的均匀分布中抽取的随机变量 $U_n$ 的均值为 $0$，但其方差为：\n$$ \\text{Var}(U_n) = \\mathbb{E}[U_n^2] = \\frac{1}{2\\sqrt{h}}\\int_{-\\sqrt{h}}^{\\sqrt{h}} x^2 dx = \\frac{1}{2\\sqrt{h}} \\left[ \\frac{x^3}{3} \\right]_{-\\sqrt{h}}^{\\sqrt{h}} = \\frac{h}{3} $$\n方差相差了 $3$ 倍。此外，所有更高阶的矩也不同。从 Itô-Taylor 展开推导 Milstein 格式的过程，关键依赖于增量的高斯性质。改变分布会使整个格式的数学基础失效。这违反了保持正确分布行为的要求。\n\n该策略在理论上是无效的。**不正确**。\n\n**E. 计算缩放后的差值 $((\\Delta W_n)^2/h - 1)\\cdot h$，或等效地先计算 $(\\Delta W_n/\\sqrt{h})^2 - 1$（其结果应接近 $Z_n^2 - 1$），然后再乘以 $h$。**\n\n这是另一种形式的代数重排，概念上与策略 A 相同。\n$$ (\\Delta W_n)^2 - h = h \\cdot \\left(\\frac{(\\Delta W_n)^2}{h} - 1\\right) $$\n在数值上，我们首先计算 $(\\Delta W_n)^2$（一个 $\\mathcal{O}(h)$ 的数），然后除以 $h$。这个除法的结果 $(\\Delta W_n)^2/h$ 是一个 $\\mathcal{O}(1)$ 的数，等于 $Z_n^2$。然后我们减去 $1$，这是两个 $\\mathcal{O}(1)$ 的数之间的数值稳定运算。最后，将结果乘以 $h$。另一种表述方式，即先计算 $((\\Delta W_n)/\\sqrt{h})^2 - 1$，使这一点更加清晰。由于 $\\Delta W_n = \\sqrt{h}Z_n$，那么 $(\\Delta W_n)/\\sqrt{h} = Z_n$，表达式就变成 $(Z_n^2 - 1)$，然后再乘以 $h$。这与策略 A 中的计算完全相同。在两种解释中，通过对量级为 1 的量执行关键的减法，都避免了灾难性抵消。\n\n该策略是可靠的。**正确**。\n\n结论总结：\n- A: 正确\n- B: 不正确\n- C: 正确\n- D: 不正确\n- E: 正确\n\n可靠的保障措施是 A、C 和 E。", "answer": "$$\\boxed{ACE}$$", "id": "3081440"}, {"introduction": "在学会了如何衡量和分析数值误差之后，我们现在进入更高级的阶段：主动控制误差。这项实践要求您设计并实现一种自适应步长方案，这是一种在实际应用中高效达到目标精度的强大技术。通过这个练习，您将在理论误差分析和实用算法设计之间架起一座桥梁。", "problem": "要求您设计、论证并实现一个自适应时间步长方案，该方案使用欧拉-丸山积分法模拟一个标量随机微分方程（SDE），并通过漂移项和扩散项的敏感性推导出局部步长控制。该SDE的形式为\n$$\ndX_t = a(X_t)\\,dt + b(X_t)\\,dW_t\n$$\n其中 $W_t$ 是一个标准维纳过程。您的设计必须基于伊藤积分的基本原理以及欧拉-丸山方法的强误差性质。目标是确保在固定的最终时间 $T$ 时的均方强误差，\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]\n$$\n达到或低于指定的目标容差。\n\n从以下公认的基础出发：\n- 针对 $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的伊藤随机积分。\n- 欧拉-丸山方案作为一种一阶弱收敛、半阶强收敛方法，其全局均方强误差在小步长渐近下与步长成比例。\n- 局部均方单步误差依赖于 $a(\\cdot)$ 和 $b(\\cdot)$ 的局部变化，这些变化由它们的导数捕捉。\n\n设计要求：\n1. 基于在当前数值状态下评估的 $|a'(X_t)|$ 和 $|b'(X_t)|$ 大小的瞬时估计，设计一个自适应时间步长选择方法。您的设计应使用这些导数来调节步长，以控制在 $[0,T]$ 上的累积均方强误差，使其满足 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的指定目标容差 $\\varepsilon^2$。\n2. 您的方案必须可使用欧拉-丸山更新式\n$$\n\\hat{X}_{t+h} = \\hat{X}_t + a(\\hat{X}_t)\\,h + b(\\hat{X}_t)\\,\\Delta W\n$$\n实现，其中 $\\Delta W \\sim \\mathcal{N}(0,h)$，并且必须构造一个自适应的步长序列 $h$ 来精确覆盖区间 $[0,T]$（如有必要，调整最后一步）。\n3. 您的步长选择必须用可在运行时从 $a(\\cdot)$、$b(\\cdot)$、$a'(\\cdot)$、$b'(\\cdot)$ 及问题参数（包括 $\\varepsilon^2$ 和 $T$）计算的量来明确表示。您可以包含最小的正则化常数和安全因子，前提是您在解决方案中对它们进行论证。\n\n蒙特卡洛评估协议：\n- 使用相同的已实现维纳路径来耦合精确解 $X_T$ 和数值解 $\\hat{X}_T$，以估计强误差。对于每个模拟路径，为您的自适应步长序列抽取高斯增量 $\\Delta W \\sim \\mathcal{N}(0,h)$，并为该路径定义 $W_T := \\sum \\Delta W$。对于其闭式解仅依赖于 $W_T$ 的SDE，使用 $W_T$ 精确计算 $X_T$。使用许多独立路径上的平方误差的样本均值作为 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的蒙特卡洛估计。\n- 为随机数生成器固定一个确定性种子以保证可复现性。\n\n测试套件：\n实现您的算法，并在以下三个测试用例上进行评估。没有物理单位；将所有量视为无量纲。不出现角度。输出应为指定的无单位实数或布尔值。\n\n1. 几何布朗运动 (GBM)，参数为\n   - $a(x) = \\mu x$, $b(x) = \\sigma x$，导数为 $a'(x) = \\mu$, $b'(x) = \\sigma$,\n   - $X_0 = 1.0$, $T = 1.0$, $\\mu = 0.5$, $\\sigma = 0.7$, 目标 $\\varepsilon^2 = 5\\times 10^{-3}$,\n   - 在时间 $T$ 给定维纳终值 $W_T$ 的精确解：\n     $$\n     X_T = X_0 \\exp\\bigl((\\mu - \\tfrac{1}{2}\\sigma^2)T + \\sigma W_T\\bigr)\n     $$\n2. 几何布朗运动 (GBM)，参数为\n   - $a(x) = \\mu x$, $b(x) = \\sigma x$，导数为 $a'(x) = \\mu$, $b'(x) = \\sigma$,\n   - $X_0 = 0.5$, $T = 1.5$, $\\mu = 1.2$, $\\sigma = 1.5$, 目标 $\\varepsilon^2 = 2\\times 10^{-2}$,\n   - 精确解如上，使用给定参数。\n3. 常系数加性噪声SDE\n   - $a(x) = \\alpha$, $b(x) = \\beta$，导数为 $a'(x) = 0$, $b'(x) = 0$,\n   - $X_0 = -1.0$, $T = 2.0$, $\\alpha = 0.3$, $\\beta = 0.8$, 目标 $\\varepsilon^2 = 10^{-8}$,\n   - 精确解：\n     $$\n     X_T = X_0 + \\alpha T + \\beta W_T\n     $$\n\n蒙特卡洛配置：\n- 每个测试用例恰好使用 $N=4000$ 条独立路径。\n- 使用单个固定的伪随机数生成器种子，以确保不同运行之间的结果可复现。\n\n最终程序输出：\n- 对于每个测试用例，计算 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的蒙特卡洛估计，并将其与目标容差 $\\varepsilon^2$ 进行比较。\n- 您的程序应生成单行输出，其中包含一个Python风格的列表，内含三个布尔结果。每个布尔值表示估计的均方强误差是否未超过相应测试用例的目标容差。例如，输出格式必须与以下完全一样：\n\"[True,False,True]\"。", "solution": "任务是设计、论证并实现一个自适应时间步长方案，用于数值模拟形如 $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的标量随机微分方程（SDE）。该方案必须使用欧拉-丸山方法，并自适应步长 $h$ 以控制全局均方强误差 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$，使其低于指定的目标容差 $\\varepsilon^2$。步长控制必须基于漂移和扩散系数的导数 $a'(x)$ 和 $b'(x)$。\n\n### 自适应方案的基于原理的设计\n\n自适应步长控制器的设计基于一个启发式但标准的SDE强解误差累积模型。\n\n**1. 欧拉-丸山方法的强误差**\n\n对于一个恒定的步长 $h$，已知欧拉-丸山方法的强收敛阶为 $0.5$。这意味着在固定时间 $T$ 的全局均方强误差对于小 $h$ 来说与步长成线性关系：\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr] \\approx C \\cdot h\n$$\n常数 $C$ 依赖于时间区间 $T$以及沿解路径的系数 $a(x)$ 和 $b(x)$ 的性质。对于一个“刚性”或敏感性（由导数 $a'$ 和 $b'$ 捕捉）不断变化的过程，可以合理地假设 $C$ 可以表示为某个局部误差指示函数 $G(x)$ 在路径上的积分。这得出：\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr] \\approx h \\int_0^T \\mathbb{E}[G(X_s)] ds\n$$\n\n**2. 对自适应步长的推广**\n\n对于自适应方案，步长 $h$ 不再是恒定的，而是成为当前状态的函数，$h_t = h(X_t)$。我们通过用依赖于状态的步长 $h_s$ 替换积分内的常数 $h$ 来推广误差模型：\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr] \\approx \\int_0^T \\mathbb{E}[G(X_s) h_s] ds\n$$\n该模型假定总误差是局部误差贡献的总和，其中在时间 $s$ 的贡献“率”是 $G(X_s) h_s$。虽然这是对复杂误差传播动力学的简化，但该模型为I控制器（积分控制器）的设计提供了实践基础。\n\n**3. 通过误差均分的步长控制律**\n\n为了控制总误差以满足目标容差 $\\varepsilon^2$，我们采用误差均分原理。我们力求在整个模拟过程中保持瞬时误差率恒定。也就是说，我们施加条件：\n$$\nG(X_t) h_t = K\n$$\n其中 $K$ 是一个常数。将其代入我们的全局误差模型：\n$$\n\\int_0^T \\mathbb{E}[K] ds = K \\int_0^T ds = KT\n$$\n为了满足容差，我们设定 $KT = \\varepsilon^2$，这确定了常数 $K = \\varepsilon^2 / T$。这产生了自适应步长控制律：\n$$\nh_t = \\frac{\\varepsilon^2}{T \\cdot G(X_t)}\n$$\n\n**4. 误差指示函数 $G(x)$**\n\n问题要求控制器基于 $|a'(x)|$ 和 $|b'(x)|$。欧拉-丸山方案的局部误差源于在一个步长 $[t, t+h]$ 内将系数 $a(s)$ 和 $b(s)$ 近似为常数。这个近似误差的大小与系数的导数以及过程本身的变化有关，而后者是由扩散项 $b(x)$ 驱动的。用于局部误差的伊藤-泰勒展开中的主导项涉及诸如 $a'(x)b(x)$ 和 $b'(x)b(x)$ 的乘积。这启发我们设计一个结合了这些效应的误差指示函数。我们为 $G(x)$ 提出以下形式：\n$$\nG(x) = |b(x)| \\left( |a'(x)| + |b'(x)| \\right)\n$$\n这种形式捕捉了所要求的依赖关系：当导数大（高敏感性）或扩散项大（高波动性）时，步长将减小。为简单起见，比例常数取为 $1$，因为其效应可以被吸收到一个安全因子中。\n\n**5. 带正则化的最终控制算法**\n\n在实践中，我们引入一个安全因子 $\\gamma  1$（例如 $\\gamma=0.9$）以更保守，并增加满足容差的概率。此外，我们在分母上添加一个小的正则化参数 $\\delta > 0$，以防止当 $G(x)$ 为零或接近零时出现除以零或步长过大的情况。这对于像常系数情况这样的SDE至关重要，因为在这种情况下导数为零，欧拉-丸山方案是精确的，非常大的步长是合适的。\n\n在状态 $\\hat{X}_t$ 下最终可实现的步长规则是：\n$$\nh = \\frac{\\gamma \\cdot \\varepsilon^2}{T \\cdot (G(\\hat{X}_t) + \\delta)}\n$$\n其中 $G(\\hat{X}_t) = |b(\\hat{X}_t)| \\left( |a'(\\hat{X}_t)| + |b'(\\hat{X}_t)| \\right)$。\n\n单个路径模拟的完整算法是：\n1. 初始化 $t=0$，$\\hat{X}=\\hat{X}_0$，以及累积维纳增量 $W_T=0$。\n2. 当 $t  T$ 时：\n   a. 使用上述控制律计算步长 $h$。\n   b. 为确保模拟在 $T$ 处精确终止，裁剪步长：$h = \\min(h, T-t)$。\n   c. 执行欧拉-丸山更新：\n      i. 生成一个标准正态随机变量 $Z \\sim \\mathcal{N}(0,1)$。\n      ii. 计算维纳增量 $\\Delta W = Z \\sqrt{h}$。\n      iii. 更新状态：$\\hat{X} \\leftarrow \\hat{X} + a(\\hat{X})h + b(\\hat{X})\\Delta W$。\n   d. 更新总维纳增量：$W_T \\leftarrow W_T + \\Delta W$。\n   e. 时间推进：$t \\leftarrow t+h$。\n3. 模拟产生数值近似解 $\\hat{X}_T$ 和相应的总维纳增量 $W_T$。\n\n通过对许多独立路径运行此过程，并对数值解 $\\hat{X}_T$ 和精确解 $X_T(W_T)$ 之间的平方差进行平均，我们得到均方强误差 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的蒙特卡洛估计。", "answer": "```python\nimport numpy as np\nfrom typing import Callable, List, Tuple\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates an adaptive Euler-Maruyama scheme\n    for three SDE test cases.\n    \"\"\"\n\n    # Set a fixed seed for the random number generator for reproducibility.\n    np.random.seed(42)\n\n    def adaptive_sde_solver(\n        a: Callable[[float], float],\n        b: Callable[[float], float],\n        a_prime: Callable[[float], float],\n        b_prime: Callable[[float], float],\n        exact_sol: Callable[[float, float, float, float, float], float],\n        x0: float,\n        T: float,\n        target_error_sq: float,\n        num_paths: int,\n        p1: float, # mu or alpha\n        p2: float  # sigma or beta\n    ) - bool:\n        \"\"\"\n        Solves an SDE using an adaptive Euler-Maruyama scheme and evaluates if the\n        mean-square strong error meets the target tolerance.\n\n        Args:\n            a: Drift coefficient function a(x).\n            b: Diffusion coefficient function b(x).\n            a_prime: Derivative of the drift function a'(x).\n            b_prime: Derivative of the diffusion function b'(x).\n            exact_sol: Function to compute the exact solution at time T given W_T.\n            x0: Initial condition.\n            T: Final time.\n            target_error_sq: The target mean-square strong error (epsilon^2).\n            num_paths: The number of Monte Carlo paths to simulate.\n            p1: Parameter 1 for exact solution (mu or alpha).\n            p2: Parameter 2 for exact solution (sigma or beta).\n\n        Returns:\n            A boolean indicating whether the estimated mean-square error is\n            less than or equal to the target tolerance.\n        \"\"\"\n        \n        total_squared_error = 0.0\n        \n        # Controller parameters\n        gamma = 0.9  # Safety factor\n        delta = 1e-12 # Regularization parameter\n\n        for _ in range(num_paths):\n            t = 0.0\n            x_hat = x0\n            w_T = 0.0\n\n            while t  T:\n                # Calculate coefficients and their derivatives at the current state\n                a_val = a(x_hat)\n                b_val = b(x_hat)\n                ap_val = a_prime(x_hat)\n                bp_val = b_prime(x_hat)\n\n                # Calculate the error indicator G(x)\n                g_val = abs(b_val) * (abs(ap_val) + abs(bp_val))\n                \n                # Calculate the adaptive step size h\n                h = (gamma * target_error_sq) / (T * (g_val + delta))\n                \n                # Adjust the last step to land exactly on T\n                if t + h > T:\n                    h = T - t\n                \n                # Generate Wiener increment\n                dw = np.random.normal(0, np.sqrt(h))\n                \n                # Euler-Maruyama step\n                x_hat += a_val * h + b_val * dw\n                \n                # Accumulate Wiener increment for the exact solution\n                w_T += dw\n                \n                # Advance time\n                t += h\n            \n            x_hat_T = x_hat\n            x_exact_T = exact_sol(x0, T, w_T, p1, p2)\n            \n            total_squared_error += (x_hat_T - x_exact_T)**2\n            \n        mean_squared_error = total_squared_error / num_paths\n        \n        return mean_squared_error = target_error_sq\n\n    # --- Test Cases Definition ---\n    \n    # Common parameters\n    N_PATHS = 4000\n\n    # Case 1: Geometric Brownian Motion\n    p1_params = {\n        'mu': 0.5, 'sigma': 0.7, 'x0': 1.0, 'T': 1.0, \n        'eps2': 5e-3\n    }\n    a1 = lambda x: p1_params['mu'] * x\n    b1 = lambda x: p1_params['sigma'] * x\n    ap1 = lambda x: p1_params['mu']\n    bp1 = lambda x: p1_params['sigma']\n    def exact_gbm(x0, T, Wt, mu, sigma):\n        return x0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * Wt)\n    \n    # Case 2: Geometric Brownian Motion\n    p2_params = {\n        'mu': 1.2, 'sigma': 1.5, 'x0': 0.5, 'T': 1.5,\n        'eps2': 2e-2\n    }\n    a2 = lambda x: p2_params['mu'] * x\n    b2 = lambda x: p2_params['sigma'] * x\n    ap2 = lambda x: p2_params['mu']\n    bp2 = lambda x: p2_params['sigma']\n\n    # Case 3: Constant-coefficient SDE\n    p3_params = {\n        'alpha': 0.3, 'beta': 0.8, 'x0': -1.0, 'T': 2.0,\n        'eps2': 1e-8\n    }\n    a3 = lambda x: p3_params['alpha']\n    b3 = lambda x: p3_params['beta']\n    ap3 = lambda x: 0.0\n    bp3 = lambda x: 0.0\n    def exact_const_coeff(x0, T, Wt, alpha, beta):\n        return x0 + alpha * T + beta * Wt\n        \n    # --- Execution of Test Suite ---\n\n    results = []\n\n    # Run Case 1\n    p1 = p1_params\n    result1 = adaptive_sde_solver(\n        a1, b1, ap1, bp1, \n        exact_gbm,\n        p1['x0'], p1['T'], p1['eps2'], N_PATHS, p1['mu'], p1['sigma']\n    )\n    results.append(result1)\n\n    # Run Case 2\n    p2 = p2_params\n    result2 = adaptive_sde_solver(\n        a2, b2, ap2, bp2, \n        exact_gbm,\n        p2['x0'], p2['T'], p2['eps2'], N_PATHS, p2['mu'], p2['sigma']\n    )\n    results.append(result2)\n\n    # Run Case 3\n    p3 = p3_params\n    result3 = adaptive_sde_solver(\n        a3, b3, ap3, bp3,\n        exact_const_coeff,\n        p3['x0'], p3['T'], p3['eps2'], N_PATHS, p3['alpha'], p3['beta']\n    )\n    results.append(result3)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3339942"}]}