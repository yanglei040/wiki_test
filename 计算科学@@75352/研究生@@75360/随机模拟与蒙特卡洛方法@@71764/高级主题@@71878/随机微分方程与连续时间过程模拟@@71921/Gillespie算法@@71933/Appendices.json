{"hands_on_practices": [{"introduction": "吉莱斯皮算法的核心在于正确计算每个反应通道的“倾向函数”（propensity function），它决定了各个随机事件发生的相对速率。这项练习将指导您从化学反应的基本组合原理出发，编写一个通用的倾向函数计算器，使其能够处理从零阶到三阶的各种反应类型。掌握这项技能是构建任何精确随机模拟器的基础，因为它能确保您的模型正确地将化学计量关系转化为随机事件的发生概率。[@problem_id:3353359]", "problem": "考虑一个充分混合的连续时间马尔可夫链模型，该模型用于描述化学反应网络在随机质量作用动力学下的行为，正如随机模拟算法（SSA）（也称为 Gillespie 算法）所使用的那样。假设有 $d$ 个物种和 $R$ 个反应通道。系统状态是一个向量 $X \\in \\mathbb{N}^d$，其中 $X_i$ 是物种 $i$ 的拷贝数。每个反应通道 $r$ 由一个非负速率常数 $c_r$ 和一个反应物化学计量向量 $\\nu_r^- \\in \\mathbb{N}^d$ 表征，该向量指示反应发生时消耗的每种物种的分子数。反应级数是 $\\sum_{i=1}^d \\nu_{r,i}^-$ 的总和。在随机质量作用动力学下，瞬时反应倾向 $a_r(X)$ 是内禀速率常数 $c_r$ 与可从当前状态 $X$ 中根据 $\\nu_r^-$ 给出的所需多重性提取的反应物分子的不同无序选择数的乘积。如果对于任何物种 $i$ 有 $X_i  \\nu_{r,i}^-$, 那么 $a_r(X)$ 必须为零。\n\n任务。设计并实现一个稳健、通用的算法，该算法在给定任意非负整数状态向量 $X \\in \\mathbb{N}^d$ 和一个反应列表 $\\{(c_r,\\nu_r^-)\\}_{r=1}^R$（反应级数范围从0到3，含0和3）的情况下，根据上述原理返回所有反应倾向 $\\{a_r(X)\\}_{r=1}^R$。你的算法不能对个别反应模式进行特例处理；它必须通过上述计数原理进行推理，从而正确计算0到3级所有反应的反应物选择数。该算法在零级反应、拷贝数不足和重复的相同反应物等边缘情况下必须保持正确。\n\n实现约束。程序必须是自包含的，且不得读取任何输入。它必须为以下测试套件计算反应倾向。对于每个测试用例，物种按其在向量中的位置进行索引。每个反应指定为一个对 $(c_r,\\nu_r^-)$，其中 $\\nu_r^-$ 按物种顺序列出。\n\n测试用例A：\n- 物种数 $d = 4$，状态 $X = [6,5,3,0]$。\n- 反应（速率常数，反应物化学计量向量）：\n  - $(0.75,[0,0,0,0])$\n  - $(0.1,[1,0,0,0])$\n  - $(0.02,[1,1,0,0])$\n  - $(0.03,[0,2,0,0])$\n  - $(0.001,[1,1,1,0])$\n  - $(0.004,[2,1,0,0])$\n  - $(0.005,[3,0,0,0])$\n  - $(0.07,[0,0,2,0])$\n  - $(1.0,[0,0,0,1])$\n  - $(0.11,[0,1,1,0])$\n\n测试用例B：\n- 物种数 $d = 3$，状态 $X = [2,1,0]$。\n- 反应：\n  - $(0.5,[3,0,0])$\n  - $(0.5,[2,1,0])$\n  - $(0.5,[1,1,1])$\n  - $(0.5,[0,2,0])$\n  - $(2.0,[0,0,0])$\n  - $(1.25,[1,0,0])$\n  - $(0.2,[1,1,0])$\n\n测试用例C：\n- 物种数 $d = 2$，状态 $X = [50,40]$。\n- 反应：\n  - $(10^{-3},[2,0])$\n  - $(10^{-6},[3,0])$\n  - $(2\\times 10^{-4},[1,1])$\n  - $(10^{-6},[2,1])$\n  - $(10^{-7},[0,3])$\n  - $(3.14,[0,0])$\n  - $(0.01,[1,0])$\n\n输出规范。你的程序必须为每个测试用例计算所有反应倾向的列表，并按反应指定的顺序排列。然后，它必须生成单行输出，其中包含这三个列表，形式为一个用方括号括起来的逗号分隔列表，不含任何空白字符。具体来说，输出必须是 $[[\\cdot],[\\cdot],[\\cdot]]$ 的形式，其中每个内部方括号按顺序包含该测试用例的浮点数反应倾向，以小数或标准科学记数法表示。在此任务中，输出是无量纲的。最终打印的行必须只包含此聚合列表，不含其他任何内容。", "solution": "我们从充分混合反应网络的连续时间马尔可夫链描述开始，该网络遵循随机质量作用动力学。状态为 $X \\in \\mathbb{N}^d$，其中 $X_i$ 是物种 $i$ 的分子数。一个反应通道 $r$ 由一个速率常数 $c_r \\ge 0$ 和一个反应物化学计量向量 $\\nu_r^- \\in \\mathbb{N}^d$ 定义。反应级数是 $\\sum_{i=1}^d \\nu_{r,i}^-$。根据随机质量作用动力学的基本定义，反应倾向 $a_r(X)$ 等于 $c_r$ 与存在于 $X$ 中且符合 $\\nu_r^-$ 所需多重性的反应物分子的不同无序选择数的乘积。如果任何所需的多重性超过了可用的拷贝数，则不存在有效的选择，反应倾向必须为零。\n\n我们推导一个显式的计数规则。对于一个固定的反应通道 $r$，考虑物种 $i$，其有 $X_i$ 个不可区分的分子可用。我们必须选择 $\\nu_{r,i}^-$ 个物种 $i$ 的分子参与反应（如果 $\\nu_{r,i}^- = 0$，则不从此物种中选择任何分子）。因为同一物种的分子是不可区分的，且只有多重性重要，所以从 $X_i$ 个分子中选择 $\\nu_{r,i}^-$ 个分子​​的方法数是二项式系数\n$$\n\\binom{X_i}{\\nu_{r,i}^-} =\n\\begin{cases}\n\\dfrac{X_i!}{\\nu_{r,i}^-!\\,(X_i-\\nu_{r,i}^-)!},  \\text{if } 0 \\le \\nu_{r,i}^- \\le X_i, \\\\\n0,  \\text{if } \\nu_{r,i}^- > X_i.\n\\end{cases}\n$$\n跨物种的选择是独立选择，因此与 $\\nu_r^-$ 一致的不同无序选择总数是所有物种上的乘积：\n$$\nN_r(X) \\;=\\; \\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}.\n$$\n因此，根据随机质量作用动力学的定义原理，反应倾向是\n$$\na_r(X) \\;=\\; c_r \\, N_r(X) \\;=\\; c_r \\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}.\n$$\n这一个规则同时处理所有情况：\n- 零级反应的 $\\nu_r^-$ 各分量均为0，因此每个因子都是 $\\binom{X_i}{0} = 1$，且 $a_r(X) = c_r$。\n- 一级反应只有一个分量 $\\nu_{r,i}^- = 1$，得到 $a_r(X) = c_r X_i$。\n- 二级异质反应有两个不同物种的 $\\nu_{r,i}^- = 1$，得到 $a_r(X) = c_r X_i X_j$；二级同质反应对于单个物种有 $\\nu_{r,i}^- = 2$，得到 $a_r(X) = c_r \\binom{X_i}{2} = c_r X_i (X_i - 1)/2$。\n- 三级反应涵盖了跨物种的模式 $\\nu_{r,i}^- \\in \\{(3,0,\\dots),(2,1,0,\\dots),(1,1,1,0,\\dots)\\}$，当有足够的多重性时，该公式分别特化为 $a_r(X) = c_r \\binom{X_i}{3}$、 $a_r(X) = c_r \\binom{X_i}{2} X_j$ 和 $a_r(X) = c_r X_i X_j X_k$。如果任何所需的多重性超过了可用的 $X_i$，相应的二项式系数为零，因此 $a_r(X) = 0$。\n\n算法设计。该算法遍历反应 $r = 1,\\dots,R$。对于每个反应，它使用整数安全的二项式系数计算乘积 $\\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}$。具体来说，对于每个物种 $i$：\n- 如果 $\\nu_{r,i}^- = 0$，因子为 $1$。\n- 否则，如果 $\\nu_{r,i}^-  X_i$，乘积变为 $0$，我们可以提前终止计算。\n- 否则，将运行中的乘积乘以精确的整数值 $\\binom{X_i}{\\nu_{r,i}^-}$。\n最后，将整数乘积与浮点速率常数 $c_r$ 相乘，得到 $a_r(X)$。对于最高3级的反应，这种方法在数值上是稳健的，因为所有二项式系数的大小适中，可以精确表示为整数，唯一的浮点舍入来源是最后乘以 $c_r$ 的缩放操作。\n\n复杂度。对于每个反应，计算耗时 $O(d)$，并使用 $O(1)$ 的额外空间。对于给定的测试套件，这在计算上是微不足道的。\n\n现在我们评估指定的测试用例。\n\n测试用例A：$X = [6,5,3,0]$ 及所列反应。应用 $a_r(X) = c_r \\prod_i \\binom{X_i}{\\nu_{r,i}^-}$：\n- $(0.75,[0,0,0,0])$: $0.75 \\times 1 = 0.75$。\n- $(0.1,[1,0,0,0])$: $0.1 \\times \\binom{6}{1} = 0.6$。\n- $(0.02,[1,1,0,0])$: $0.02 \\times \\binom{6}{1}\\binom{5}{1} = 0.6$。\n- $(0.03,[0,2,0,0])$: $0.03 \\times \\binom{5}{2} = 0.3$。\n- $(0.001,[1,1,1,0])$: $0.001 \\times \\binom{6}{1}\\binom{5}{1}\\binom{3}{1} = 0.09$。\n- $(0.004,[2,1,0,0])$: $0.004 \\times \\binom{6}{2}\\binom{5}{1} = 0.3$。\n- $(0.005,[3,0,0,0])$: $0.005 \\times \\binom{6}{3} = 0.1$。\n- $(0.07,[0,0,2,0])$: $0.07 \\times \\binom{3}{2} = 0.21$。\n- $(1.0,[0,0,0,1])$: $1.0 \\times \\binom{0}{1} = 0$。\n- $(0.11,[0,1,1,0])$: $0.11 \\times \\binom{5}{1}\\binom{3}{1} = 1.65$。\n因此，反应倾向列表为 $[0.75,0.6,0.6,0.3,0.09,0.3,0.1,0.21,0.0,1.65]$。\n\n测试用例B：$X = [2,1,0]$:\n- $(0.5,[3,0,0])$: $0.5 \\times \\binom{2}{3} = 0$。\n- $(0.5,[2,1,0])$: $0.5 \\times \\binom{2}{2}\\binom{1}{1} = 0.5$。\n- $(0.5,[1,1,1])$: $0.5 \\times \\binom{2}{1}\\binom{1}{1}\\binom{0}{1} = 0$。\n- $(0.5,[0,2,0])$: $0.5 \\times \\binom{1}{2} = 0$。\n- $(2.0,[0,0,0])$: $2.0 \\times 1 = 2.0$。\n- $(1.25,[1,0,0])$: $1.25 \\times \\binom{2}{1} = 2.5$。\n- $(0.2,[1,1,0])$: $0.2 \\times \\binom{2}{1}\\binom{1}{1} = 0.4$。\n因此，反应倾向列表为 $[0.0,0.5,0.0,0.0,2.0,2.5,0.4]$。\n\n测试用例C：$X = [50,40]$:\n- $(10^{-3},[2,0])$: $10^{-3} \\times \\binom{50}{2} = 1.225$。\n- $(10^{-6},[3,0])$: $10^{-6} \\times \\binom{50}{3} = 0.0196$。\n- $(2\\times 10^{-4},[1,1])$: $(2\\times 10^{-4}) \\times \\binom{50}{1}\\binom{40}{1} = 0.4$。\n- $(10^{-6},[2,1])$: $10^{-6} \\times \\binom{50}{2}\\binom{40}{1} = 0.049$。\n- $(10^{-7},[0,3])$: $10^{-7} \\times \\binom{40}{3} = 0.000988$。\n- $(3.14,[0,0])$: $3.14 \\times 1 = 3.14$。\n- $(0.01,[1,0])$: $0.01 \\times \\binom{50}{1} = 0.5$。\n因此，反应倾向列表为 $[1.225,0.0196,0.4,0.049,0.000988,3.14,0.5]$。\n\n下面的程序实现了所描述的通用算法，将其应用于测试套件，并按要求以单行、无空格的格式打印三个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np  # numpy is available; not strictly needed but permitted.\n\ndef comb_nonneg(n: int, k: int) - int:\n    \"\"\"Return C(n,k) for integers n,k with the convention C(n,k)=0 if k>n or k0.\"\"\"\n    if k  0:\n        return 0\n    if k > n:\n        return 0\n    # For k==0 or k==n, math.comb handles correctly as 1\n    return math.comb(n, k)\n\ndef propensity_for_reaction(state, reactant_stoich, rate_constant) - float:\n    \"\"\"\n    Compute propensity a = c * product_i C(state[i], reactant_stoich[i]).\n    If any required multiplicity exceeds availability, propensity is zero.\n    \"\"\"\n    product = 1\n    for xi, si in zip(state, reactant_stoich):\n        c = comb_nonneg(int(xi), int(si))\n        if c == 0:\n            return 0.0\n        product *= c\n    return float(rate_constant) * float(product)\n\ndef compute_propensities(state, reactions):\n    \"\"\"\n    state: list[int] of species counts\n    reactions: list of tuples (rate_constant: float, reactant_stoich: list[int])\n    returns: list[float] propensities\n    \"\"\"\n    props = []\n    for rate, stoich in reactions:\n        props.append(propensity_for_reaction(state, stoich, rate))\n    return props\n\ndef format_float(x: float) - str:\n    \"\"\"\n    Format a float into a concise string without unnecessary whitespace,\n    using up to 12 significant digits, avoiding long binary tails.\n    \"\"\"\n    # Use general format; this trims trailing zeros and uses scientific notation when appropriate.\n    s = format(x, \".12g\")\n    return s\n\ndef format_list_no_spaces(lst):\n    \"\"\"Format a list of floats as [v1,v2,...] with no spaces.\"\"\"\n    return \"[\" + \",\".join(format_float(x) for x in lst) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case A\n    state_A = [6, 5, 3, 0]\n    reactions_A = [\n        (0.75, [0, 0, 0, 0]),\n        (0.1, [1, 0, 0, 0]),\n        (0.02, [1, 1, 0, 0]),\n        (0.03, [0, 2, 0, 0]),\n        (0.001, [1, 1, 1, 0]),\n        (0.004, [2, 1, 0, 0]),\n        (0.005, [3, 0, 0, 0]),\n        (0.07, [0, 0, 2, 0]),\n        (1.0, [0, 0, 0, 1]),\n        (0.11, [0, 1, 1, 0]),\n    ]\n\n    # Test case B\n    state_B = [2, 1, 0]\n    reactions_B = [\n        (0.5, [3, 0, 0]),\n        (0.5, [2, 1, 0]),\n        (0.5, [1, 1, 1]),\n        (0.5, [0, 2, 0]),\n        (2.0, [0, 0, 0]),\n        (1.25, [1, 0, 0]),\n        (0.2, [1, 1, 0]),\n    ]\n\n    # Test case C\n    state_C = [50, 40]\n    reactions_C = [\n        (1e-3, [2, 0]),\n        (1e-6, [3, 0]),\n        (2e-4, [1, 1]),\n        (1e-6, [2, 1]),\n        (1e-7, [0, 3]),\n        (3.14, [0, 0]),\n        (0.01, [1, 0]),\n    ]\n\n    test_cases = [\n        (state_A, reactions_A),\n        (state_B, reactions_B),\n        (state_C, reactions_C),\n    ]\n\n    results = []\n    for state, reactions in test_cases:\n        props = compute_propensities(state, reactions)\n        results.append(props)\n\n    # Prepare nested list formatting without spaces\n    inner = \",\".join(format_list_no_spaces(r) for r in results)\n    print(f\"[{inner}]\")\n\nsolve()\n```", "id": "3353359"}, {"introduction": "在您实现随机模拟算法（SSA）之后，验证其正确性是一个至关重要但又充满挑战的步骤，因为随机性可能会掩盖程序中的潜在错误。这项练习将挑战您作为一名严谨的科学家，评估一系列用于验证SSA实现的测试方案，而不是进行直接计算。通过辨别哪些测试在理论上是可靠的，您将学会如何系统地确保模拟结果的保真度，并避免常见的统计陷阱。[@problem_id:3353365]", "problem": "考虑为一个充分混合的反应网络实现随机模拟算法 (SSA)，该网络被建模为一个连续时间马尔可夫链，其状态为 $\\mathbf{X}(t) \\in \\mathbb{Z}_{\\ge 0}^n$，化学计量变化向量为 $\\boldsymbol{\\nu}_j \\in \\mathbb{Z}^n$，倾向函数为 $a_j(\\mathbf{x})$，且满足化学主方程 (CME)。一个团队提出了几种测试来验证他们 SSA 实现的正确性。您的任务是，基于 CME 的第一性原理以及 SSA 底层的连续时间马尔可夫链构造，识别出哪些提议的测试在理论上是合理的。在适当情况下，假设倾向函数是标准的质量作用类型，并且 SSA 使用的随机数是独立同分布的 Uniform($0,1$) 随机数。选择所有有效的测试。\n\nA. 守恒定律与非负性不变量测试：对于可逆单分子网络 $S_1 \\xrightleftharpoons[c_2]{c_1} S_2$，其倾向函数为 $a_1(\\mathbf{x}) = c_1 X_1$ 和 $a_2(\\mathbf{x}) = c_2 X_2$，在大量 SSA 轨迹上验证对于所有 $t \\ge 0$，都有 $X_1(t) + X_2(t) = X_1(0) + X_2(0)$，并且对于所有 $t \\ge 0$，都有 $X_1(t) \\ge 0$ 和 $X_2(t) \\ge 0$。\n\nB. 零倾向函数边界情况测试：在一个同时包含选项 A 中可逆单分子反应的网络中，加入一个双分子反应 $2 S_1 \\to S_2$，其质量作用倾向函数为 $a_3(\\mathbf{x}) = c_3 \\binom{X_1}{2}$。以 $X_1(0) = 1$, $X_2(0) = 0$ 初始化。验证反应 3 永远不会发生，直到某个其他反应改变了状态使得 $X_1 \\ge 2$，此时反应 3 的发生才变得可能。\n\nC. 单反应拟合优度测试：考虑单反应的生成过程 $\\varnothing \\to S_1$，其倾向函数为常数 $a(\\mathbf{x}) = c$，与 $\\mathbf{x}$ 无关。使用多条独立的 SSA 路径，对事件间等待时间进行柯尔莫哥洛夫-斯米尔诺夫 (KS) 拟合优度检验，以检验其是否服从速率为 $c$ 的指数分布；并进行卡方检验，以检验在长度为 $T$ 的固定时间窗口内的事件计数是否服从均值为 $c T$ 的泊松分布。\n\nD. 首事件选择概率测试：对于一个通用网络，其反应索引为 $j \\in \\{1, \\dots, m\\}$，倾向函数为 $a_j(\\mathbf{x})$，固定初始状态 $\\mathbf{X}(0) = \\mathbf{x}_0$。在多次独立运行中，在第一个反应发生后停止每个轨迹，并估计反应 $j$ 作为第一个发生的概率。验证该经验概率与 $a_j(\\mathbf{x}_0) / a_0(\\mathbf{x}_0)$ 一致，其中 $a_0(\\mathbf{x}) = \\sum_{i=1}^m a_i(\\mathbf{x})$。\n\nE. 通用网络中原始时间的指数拟合测试：对于一个具有状态依赖倾向函数的通用多反应网络，汇集沿完整 SSA 轨迹观察到的所有事件间等待时间 $\\tau_k$，并进行 KS 检验，以检验 $\\tau_k$ 是否为速率为 $a_0(\\mathbf{X}(0))$ 的独立同分布指数随机变量。\n\nF. 时间重标度拟合优度测试：对于一个通用多反应网络，计算变换后的事件间时间 $Z_k = \\int_{t_k}^{t_{k+1}} a_0(\\mathbf{X}(s)) \\, ds$，其中 $t_k$ 和 $t_{k+1}$ 是连续的反应时间，且 $a_0(\\mathbf{x}) = \\sum_{j=1}^m a_j(\\mathbf{x})$。进行 KS 检验，以检验 $Z_k$ 是否为速率为 1 的独立同分布指数随机变量，并辅以与速率为 1 的指数分布的分位数-分位数图进行对比。\n\nG. 最大倾向函数启发式检查：在每个反应步骤，验证发生的反应是所有反应中具有最大倾向函数 $a_j(\\mathbf{X})$ 的那个；标记任何有较小倾向函数反应发生的轨迹。\n\n选择所有在理论上有效、可用于验证 SSA 实现正确性的测试。", "solution": "问题陈述构成了随机模拟领域内一个有效且定义明确的询问。它要求评估几种用于验证随机模拟算法 (SSA)（也称为 Gillespie 算法）实现的提议测试的理论合理性。该问题在科学上植根于连续时间马尔可夫链和化学主方程的理论，这些是 SSA 的基础。问题是客观、明确的，并包含足够的信息以进行严谨的分析。\n\nSSA 是一种精确的模拟方法，用于模拟充分混合反应系统的随机时间演化。在每一步中，对于处于状态 $\\mathbf{x}$ 的系统，算法执行两个任务：\n1.  从速率为 $a_0(\\mathbf{x}) = \\sum_{j=1}^m a_j(\\mathbf{x})$ 的指数分布中抽取下一个事件发生的时间 $\\tau$。\n2.  从一个离散分布中抽取下一个反应的索引 $j$，其中选择反应 $j$ 的概率为 $a_j(\\mathbf{x}) / a_0(\\mathbf{x})$。\n\n新状态则是在时间 $t + \\tau$ 时的 $\\mathbf{x} + \\boldsymbol{\\nu}_j$。所有提议的测试都将根据这些第一性原理进行评估。\n\n**A. 守恒定律与非负性不变量测试**\n\n此测试提议验证可逆反应 $S_1 \\xrightleftharpoons[c_2]{c_1} S_2$ 的两个性质。\n1.  **守恒定律**：反应为 $S_1 \\to S_2$ 和 $S_2 \\to S_1$。化学计量变化向量为 $\\boldsymbol{\\nu}_1 = (-1, 1)^T$ 和 $\\boldsymbol{\\nu}_2 = (1, -1)^T$，其中状态为 $(X_1, X_2)^T$。对于任何发生的反应，分子总数 $X_1 + X_2$ 的变化为 $\\Delta(X_1 + X_2) = \\nu_{j,1} + \\nu_{j,2}$。对于 $j=1$ 和 $j=2$，这个和都为 0。因此，$X_1(t) + X_2(t)$ 是系统的运动常数，或称为守恒定律。一个正确的 SSA 实现必须保留所有此类线性守恒定律。验证 $X_1(t) + X_2(t) = X_1(0) + X_2(0)$ 是对状态更新步骤的有效测试。\n2.  **非负性**：状态变量 $X_1(t)$ 和 $X_2(t)$ 代表分子数量，必须是非负整数。质量作用倾向函数 $a_1(\\mathbf{x}) = c_1 X_1$ 和 $a_2(\\mathbf{x}) = c_2 X_2$ 的定义方式是，如果某个物种的数量为零（例如 $X_1 = 0$），则消耗该物种的任何反应的倾向函数也为零（$a_1 = 0$）。根据 SSA，倾向函数为零的反应被选择的概率为零。因此，一个正确的实现绝不允许发生会导致负粒子数的反应。检查 $X_1(t) \\ge 0$ 和 $X_2(t) \\ge 0$ 是一项基本且有效的测试。\n\n此选项的结论是**正确**。\n\n**B. 零倾向函数边界情况测试**\n\n此测试检验当一个反应的倾向函数恰好为零时算法的行为。反应 $2S_1 \\to S_2$ 的质量作用倾向函数为 $a_3(\\mathbf{x}) = c_3 \\binom{X_1}{2} = c_3 \\frac{X_1(X_1-1)}{2}$。如果系统以 $X_1(0) = 1$ 初始化，则初始倾向函数为 $a_3 = c_3 \\frac{1(1-1)}{2} = 0$。由于选择反应 $j$ 的概率是 $a_j(\\mathbf{x})/a_0(\\mathbf{x})$，选择反应 3 的概率是 $0/a_0(\\mathbf{x}) = 0$。反应 3 不会发生。只有当网络中的另一个反应首先将 $S_1$ 的粒子数增加到至少为 2 时，它才可能发生。这是一个关键的边界情况。一个有缺陷的实现（例如，对浮点运算或索引处理不当的实现）可能会错误地选择倾向函数为零的反应。这个测试旨在捕捉此类缺陷。\n\n此选项的结论是**正确**。\n\n**C. 单反应拟合优度测试**\n\n此测试考虑一个具有常数倾向函数 $a(\\mathbf{x}) = c$ 的简单生成过程 $\\varnothing \\to S_1$。\n1.  **事件间时间**：总倾向函数为 $a_0(\\mathbf{x}) = c$，是一个常数。根据 SSA，连续事件之间的时间间隔 $\\tau$ 必须从速率为 $a_0(\\mathbf{x}) = c$ 的指数分布中抽取。由于速率是恒定的，所有事件间时间都是来自 $\\text{Exponential}(c)$ 的独立同分布 (i.i.d.) 随机变量。柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验是一种标准的统计程序，用于检查数据样本是否来自指定的连续分布。因此，这是检验 SSA“何时”部分的有效方法。\n2.  **事件计数**：事件以恒定速率 $c$ 发生的过程是齐次泊松过程。对于这样的过程，在长度为 $T$ 的固定时间间隔内发生的事件数量遵循均值为 $\\lambda = cT$ 的泊松分布。卡方拟合优度检验是检验计数数据是否遵循特定离散分布（如泊松分布）的标准方法。这也是一种有效的验证方法。\n\n此选项的结论是**正确**。\n\n**D. 首事件选择概率测试**\n\n此测试关注反应选择规则。对于固定的初始状态 $\\mathbf{X}(0) = \\mathbf{x}_0$，总倾向函数固定为 $a_0(\\mathbf{x}_0) = \\sum_{j=1}^m a_j(\\mathbf{x}_0)$。根据 SSA 的选择规则，第一个发生的反应是反应 $j$ 的理论概率为：$P(j|\\mathbf{x}_0) = a_j(\\mathbf{x}_0) / a_0(\\mathbf{x}_0)$。通过运行许多独立的模拟并记录哪个反应首先发生，可以生成一个经验频率分布。将此经验分布与理论概率 $\\{P(j|\\mathbf{x}_0)\\}_{j=1}^m$ 进行比较（例如，使用卡方检验），为 SSA 实现的“哪个”部分提供了直接而有力的验证。\n\n此选项的结论是**正确**。\n\n**E. 通用网络中原始时间的指数拟合测试**\n\n此测试提议汇集通用网络轨迹中的所有事件间时间 $\\tau_k$，并检验它们是否服从速率为 $a_0(\\mathbf{X}(0))$ 的指数分布。这在理论上是不正确的。事件间时间 $\\tau_k$ 是从速率为 $a_0(\\mathbf{X}(t_{k-1}))$ 的指数分布中抽取的，其中 $\\mathbf{X}(t_{k-1})$ 是*在那个时刻*的状态。在通用网络中，状态 $\\mathbf{X}$ 会改变，所以总倾向函数 $a_0$ 是时间的函数，即 $a_0(t) \\equiv a_0(\\mathbf{X}(t))$。因此，等待时间 $\\tau_k$ 是从具有*不同*速率的指数分布中抽取的。它们是独立的但不是同分布的。将它们汇集在一起会产生一个混合分布，该分布通常不是指数分布。将这个混合分布与一个特定的指数分布（特别是使用从初始时间任意选择的速率）进行检验，在统计学和理论上都是没有根据的。\n\n此选项的结论是**错误**。\n\n**F. 时间重标度拟合优度测试**\n\n此测试是 E 的一个复杂且正确的替代方案。它使用了时间重标度定理。事件间时间 $\\tau_k = t_{k+1} - t_k$ 是从 $\\text{Exponential}(\\lambda_k)$ 中抽取的随机变量，其中速率为 $\\lambda_k = a_0(\\mathbf{X}(t_k))$。状态 $\\mathbf{X}(s)$ 在 $s \\in [t_k, t_{k+1})$ 期间是恒定的，因此在此区间内 $\\mathbf{X}(s) = \\mathbf{X}(t_k)$。提议的变换变量是 $Z_k = \\int_{t_k}^{t_{k+1}} a_0(\\mathbf{X}(s)) \\, ds$。由于被积函数是常数，这变为 $Z_k = a_0(\\mathbf{X}(t_k)) \\cdot (t_{k+1} - t_k) = \\lambda_k \\tau_k$。如果一个随机变量 $\\tau_k \\sim \\text{Exponential}(\\lambda_k)$，那么经过标度变换的随机变量 $Z_k = \\lambda_k \\tau_k$ 服从速率为 1 的指数分布。这对每一步 $k$ 都成立。因此，变换后的时间序列 $\\{Z_k\\}$ 应该是一个来自标准 $\\text{Exponential}(1)$ 分布的独立同分布随机变量样本。在状态依赖倾向函数的一般情况下，使用 KS 检验或 Q-Q 图来验证这一点是验证 SSA 计时方面的一个强大且理论上合理的方法。\n\n此选项的结论是**正确**。\n\n**G. 最大倾向函数启发式检查**\n\n此测试提议验证总是发生具有最大倾向函数的反应。这是对 SSA 的根本误解。SSA 是一个随机算法，而不是确定性算法。倾向函数决定的是反应的*概率*，而不是一个确定性的选择。反应 $j$ 以概率 $a_j(\\mathbf{x}) / a_0(\\mathbf{x})$ 被选择。虽然具有较大倾向函数的反应更有可能被选中，但任何具有非零倾向函数的反应都有非零的发生机会。例如，如果 $a_1(\\mathbf{x}) = 100$ 而 $a_2(\\mathbf{x}) = 1$，反应 2 就有大约 $1/101$ 的微小但非零的概率被选中。一个正确的 SSA 实现必须能够选择反应 2。将发生这种情况的轨迹标记为错误是不正确的。此测试描述的是一种贪心算法，而不是 SSA。\n\n此选项的结论是**错误**。\n\n总而言之，理论上有效的测试是 A、B、C、D 和 F。", "answer": "$$\\boxed{ABCDF}$$", "id": "3353365"}, {"introduction": "对于包含大量反应通道的复杂系统，基础的吉莱斯皮算法可能会变得效率低下。为了解决这个问题，研究人员开发了像“下一反应方法”（Next Reaction Method）这样的优化算法，它利用优先队列（如二叉堆）来高效管理事件调度。这项练习将引导您分析这种优化方法的计算复杂度，通过推导每个模拟事件的摊销成本，您将深刻理解算法性能如何依赖于反应网络的依赖结构，这对于为特定问题选择最高效的模拟策略至关重要。[@problem_id:3353273]", "problem": "考虑一个充分混合的化学反应网络，该网络被建模为一个连续时间马尔可夫链，其状态为 $X(t)$ in $\\mathbb{N}^{S}$，其中 $S$ 是物种数量，$M$ 是由 $i \\in \\{1,\\dots,M\\}$ 索引的 $M$ 个不同反应通道。每个反应通道 $i$ 都有一个倾向函数 $a_{i}(X(t))$ 和一个化学计量更新向量 $\\nu_{i} \\in \\mathbb{Z}^{S}$。该过程使用随机模拟算法（Stochastic Simulation Algorithm, SSA）进行精确模拟。假设我们实现下一反应方法（Next Reaction Method）的变体，将所有反应通道的预定下一次绝对事件时间 $\\{T_{i}\\}_{i=1}^{M}$ 存储在一个以 $T_{i}$ 为键的二叉堆中，以便可以高效地访问和更新最小时间。\n\n假定以下基础：\n- 状态 $X(t)$ 根据随机时间变换表示法演化，该表示法使用独立的单位速率泊松过程。预定的下一次事件时间 $T_{i}$ 满足以下条件：在给定当前状态和信息流的情况下，反应 $i$ 的下一次触发时间是最小的 $t  \\text{current time}$，使得积分风险达到指数阈值。\n- 一个最大出度为 $\\Delta$ 的依赖图描述了单个反应的触发如何改变其他反应 $j$ 的倾向 $a_{j}(X(t))$。具体来说，当任何反应 $i$ 触发时，最多有 $\\Delta$ 个其他反应的倾向函数被修改，因此需要更新它们预定的下一次事件时间。倾向变为零的反应将从堆中移除；倾向保持为正的反应将保留其条目并更新键值。已触发的反应本身将以新的绝对下一次事件时间重新调度，并保留在堆中。\n- 该二叉堆是一个标准的基于数组的二叉堆；单次提取最小值、删除、插入或键更新操作会沿着一条路径移动一个键，该路径的长度与堆的高度在同一数量级。根据基于比较的排序属性，堆的高度与 $\\log_{2}(\\text{heap size})$ 成正比。\n\n在这些假设下，在一个 SSA 事件步骤中，会发生以下堆维护操作：\n1. 一次提取最小值（extract-min）操作，以移除当前预定的最早事件时间 $T_{i}$。\n2. 一次插入（insert）操作（或键更新（key-update）操作），以将已触发反应的新预定时间写回堆中。\n3. 对于最多 $\\Delta$ 个依赖反应中的每一个，进行一次键更新（key-update）或删除（delete）操作，以反映它们新的预定时间，或者如果它们的倾向变为零则将其移除。\n\n根据上述基础，推导每个 SSA 事件中二叉堆筛选步骤的均摊数，并将其表示为关于 $M$ 和 $\\Delta$ 的封闭形式解析表达式，推导过程中不使用简化表达式，并假设在整个分析过程中堆的大小为 $M$。最终答案应表示为使用以 2 为底的对数的关于 $M$ 和 $\\Delta$ 的单一解析表达式，且最终答案中不得包含任何不等式或大 O 符号。无需四舍五入，也无需在最终答案中包含任何单位。", "solution": "该问题要求推导在下一反应方法类型的随机模拟算法（SSA）中，每个事件的二叉堆筛选步骤的均摊数。推导过程必须严格基于所提供的假设。\n\n首先，我们以“筛选步骤”为单位，确定单次堆操作的计算成本。该系统涉及 $M$ 个反应通道，并假设在整个分析过程中堆的大小为 $M$。一个包含 $M$ 个元素的标准二叉堆的最大高度由 $\\lfloor \\log_{2}(M) \\rfloor$ 给出。基本的堆操作——`extract-min`（提取最小值）、`insert`（插入）、`delete`（删除）和 `key-update`（键更新）——通过将元素沿着从根到叶或从叶到根的路径移动来工作。这个过程被称为筛选（或下滤/上滤/堆化），其复杂度由该路径的长度决定。在最坏情况下，筛选步骤（元素交换或比较）的数量等于堆的高度。\n\n问题要求最终表达式不含不等式，并使用以 2 为底的对数，其基础是堆高度“与 $\\log_{2}(\\text{heap size})$ 成正比”这一论断。这引导我们使用理想化的连续函数 $\\log_{2}(M)$ 来表示单次最坏情况堆操作的筛选步骤数。这种简化抽象了由向下取整函数 $\\lfloor \\log_{2}(M) \\rfloor$ 表示的堆高度的离散性，从而得到一个简洁的解析表达式。因此，在此分析中，一次堆操作的成本被视为 $\\log_{2}(M)$ 次筛选步骤。\n\n接下来，我们按照问题陈述中的规定，将单个 SSA 事件分解为其组成的堆维护操作，并计算其成本总和。\n\n1.  **事件选择**：算法必须确定下一个要发生的反应。在下一反应方法中，这对应于找到具有最小预定绝对时间 $T_{i}$ 的事件。这通过对堆执行一次 `extract-min` 操作来实现。该操作的成本，以筛选步骤计，为 $\\log_{2}(M)$。\n\n2.  **重新调度已触发的反应**：刚刚触发的反应通道必须被分配一个新的预定事件时间。计算出这个新时间后，相应的条目被放回堆中。此操作构成一次 `insert` 操作。此次插入的成本也是 $\\log_{2}(M)$ 次筛选步骤。\n\n3.  **更新依赖反应**：一个反应的触发可以改变其他反应的倾向 $a_{j}(X(t))$。问题陈述指出，一个最大出度为 $\\Delta$ 的依赖图描述了这些关系。这意味着在一个反应触发后，“最多 $\\Delta$ 个”其他反应的倾向被修改。每次这样的修改都需要对堆进行更新，以反映新的倾向以及因此产生的新的预定事件时间。此更新采用 `key-update` 或 `delete` 操作的形式。为了获得一个不含不等式的封闭形式解析表达式，我们必须分析由“最多”这一条件所暗示的最坏情况。因此，我们假设恰好有 $\\Delta$ 个依赖反应需要更新。这 $\\Delta$ 个操作中的每一个都会产生 $\\log_{2}(M)$ 次筛选步骤的成本。因此，更新所有依赖反应的总成本为 $\\Delta \\times \\log_{2}(M)$。\n\n最后，我们通过对这些单独操作的成本求和，来计算每个 SSA 事件的总筛选步骤数。在问题上下文中，“均摊数”一词指的是一个完整事件周期的总计算工作量。\n\n设 $N_{\\text{steps}}$ 为每个事件的总筛选步骤数。\n$$\nN_{\\text{steps}} = (\\text{Cost of extract-min}) + (\\text{Cost of insert}) + (\\text{Cost of dependent updates})\n$$\n代入上面推导出的成本：\n$$\nN_{\\text{steps}} = \\log_{2}(M) + \\log_{2}(M) + \\Delta \\log_{2}(M)\n$$\n提取公因式 $\\log_{2}(M)$：\n$$\nN_{\\text{steps}} = (1 + 1 + \\Delta) \\log_{2}(M)\n$$\n$$\nN_{\\text{steps}} = (2 + \\Delta) \\log_{2}(M)\n$$\n该表达式表示在给定模型下，单个 SSA 事件在最坏情况下的总筛选步骤数。它是一个关于 $M$ 和 $\\Delta$ 的封闭形式解析表达式，使用了以 2 为底的对数，并且不含不等式或渐近符号，符合要求。", "answer": "$$\n\\boxed{(2 + \\Delta) \\log_{2}(M)}\n$$", "id": "3353273"}]}