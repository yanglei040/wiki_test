{"hands_on_practices": [{"introduction": "在进行任何蒙特卡洛模拟之前，我们必须深刻理解其基础——标的资产的价格模型。本练习将带您回顾并推导金融工程中最核心的模型，即几何布朗运动（GBM）的精确解。通过计算资产价格在真实世界概率测度（$\\mathbb{P}$）和风险中性测度（$\\mathbb{Q}$）下的期望和方差，您将巩固对模型动态及其在定价中作用的基础理解。[@problem_id:3321531]", "problem": "考虑一个单一风险资产，其价格过程 $\\{S_{t}\\}_{t \\geq 0}$ 在一个带域流的概率空间 $(\\Omega,\\mathcal{F},\\{\\mathcal{F}_{t}\\}_{t \\geq 0},\\mathbb{P})$ 上由以下随机微分方程 (SDE) 建模\n$$\n\\mathrm{d}S_{t}=\\mu S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{P}}, \\quad S_{0}>0,\n$$\n其中 $\\mu \\in \\mathbb{R}$ 和 $\\sigma>0$ 是常数，$\\{W_{t}^{\\mathbb{P}}\\}_{t \\geq 0}$ 是在物理测度 $\\mathbb{P}$ 下的标准布朗运动。假设存在一个具有确定性短期利率 $r \\in \\mathbb{R}$ 的货币市场账户，并且无套利条件成立，因此存在一个等价鞅测度（风险中性测度）$\\mathbb{Q}$，在该测度下，折现后的资产价格是一个鞅。在 $\\mathbb{Q}$ 测度下，资产动态满足\n$$\n\\mathrm{d}S_{t}=r S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{Q}},\n$$\n其中 $\\{W_{t}^{\\mathbb{Q}}\\}_{t \\geq 0}$ 是在 $\\mathbb{Q}$ 测度下的标准布朗运动。\n\n仅使用适用于常系数扩散过程的基本随机分析工具和测度变换原理，完成以下任务：\n\n- 在固定时间 $T>0$ 时，根据 $S_{0}$、模型参数和驱动布朗运动，推导 $S_{T}$ 的精确路径解。\n- 计算在物理测度 $\\mathbb{P}$ 下的期望 $\\mathbb{E}_{\\mathbb{P}}[S_{T}]$ 和方差 $\\mathrm{Var}_{\\mathbb{P}}(S_{T})$。\n- 计算在风险中性测度 $\\mathbb{Q}$ 下的期望 $\\mathbb{E}_{\\mathbb{Q}}[S_{T}]$ 和方差 $\\mathrm{Var}_{\\mathbb{Q}}(S_{T})$。\n\n将你的最终答案表示为一个单行矩阵，依次包含 $\\mathbb{E}_{\\mathbb{P}}[S_{T}]$、$\\mathrm{Var}_{\\mathbb{P}}(S_{T})$、$\\mathbb{E}_{\\mathbb{Q}}[S_{T}]$ 和 $\\mathrm{Var}_{\\mathbb{Q}}(S_{T})$。不需要进行数值四舍五入；请提供闭式解析表达式。不需要物理单位。", "solution": "用户请求解决一个量化金融问题，该问题涉及推导几何布朗运动随机微分方程的解，并计算其在物理测度和风险中性测度下的前两阶矩。\n\n### 步骤 1：提取已知条件\n-   在物理测度 $\\mathbb{P}$ 下，资产价格 $S_t$ 的随机微分方程 (SDE)：$\\mathrm{d}S_{t}=\\mu S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{P}}$。\n-   初始资产价格：$S_{0}>0$。\n-   在 $\\mathbb{P}$ 下的漂移系数：$\\mu \\in \\mathbb{R}$ (常数)。\n-   波动率系数：$\\sigma>0$ (常数)。\n-   在 $\\mathbb{P}$ 下的驱动过程：$\\{W_{t}^{\\mathbb{P}}\\}_{t \\geq 0}$ 是一个标准布朗运动。\n-   确定性短期利率：$r \\in \\mathbb{R}$。\n-   在风险中性测度 $\\mathbb{Q}$ 下，资产价格 $S_t$ 的 SDE：$\\mathrm{d}S_{t}=r S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{Q}}$。\n-   在 $\\mathbb{Q}$ 下的驱动过程：$\\{W_{t}^{\\mathbb{Q}}\\}_{t \\geq 0}$ 是一个标准布朗运动。\n-   目标：推导 $S_T$ 的路径解，并计算量 $\\mathbb{E}_{\\mathbb{P}}[S_{T}]$、$\\mathrm{Var}_{\\mathbb{P}}(S_{T})$、$\\mathbb{E}_{\\mathbb{Q}}[S_{T}]$ 和 $\\mathrm{Var}_{\\mathbb{Q}}(S_{T})$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题描述了 Black-Scholes-Merton 模型，这是金融数学中一个基础且成熟的框架。伊藤分析、几何布朗运动和测度变换技术的使用是标准概念。该问题是科学合理的。\n-   **适定性**：该问题已完全指定，包含所有必要的参数（$\\mu, \\sigma, r, S_0$）和初始条件。目标明确。该 SDE 具有唯一的稳定解。该问题是适定的。\n-   **客观性**：该问题以精确的数学术语陈述，没有任何主观性或模糊性。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供完整的解答。\n\n### 路径解的推导\n在物理测度 $\\mathbb{P}$ 下，资产价格 $S_t$ 的 SDE 是一个几何布朗运动：\n$$\n\\mathrm{d}S_{t}=\\mu S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{P}}\n$$\n为了找到 $S_t$ 的显式解，我们对函数 $f(S_t) = \\ln(S_t)$ 应用伊藤引理。$f(S_t)$ 的偏导数是：\n$$\n\\frac{\\partial f}{\\partial t} = 0, \\quad \\frac{\\partial f}{\\partial S_t} = \\frac{1}{S_t}, \\quad \\frac{\\partial^2 f}{\\partial S_t^2} = -\\frac{1}{S_t^2}\n$$\n根据伊藤引理，$X_t = f(S_t) = \\ln(S_t)$ 的微分由下式给出：\n$$\n\\mathrm{d}X_t = \\left( \\frac{\\partial f}{\\partial t} + \\mu S_t \\frac{\\partial f}{\\partial S_t} + \\frac{1}{2} (\\sigma S_t)^2 \\frac{\\partial^2 f}{\\partial S_t^2} \\right) \\mathrm{d}t + \\sigma S_t \\frac{\\partial f}{\\partial S_t} \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n代入偏导数，我们得到：\n$$\n\\mathrm{d}(\\ln S_t) = \\left( 0 + \\mu S_t \\left(\\frac{1}{S_t}\\right) + \\frac{1}{2} \\sigma^2 S_t^2 \\left(-\\frac{1}{S_t^2}\\right) \\right) \\mathrm{d}t + \\sigma S_t \\left(\\frac{1}{S_t}\\right) \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n$$\n\\mathrm{d}(\\ln S_t) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) \\mathrm{d}t + \\sigma \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n这是 $\\ln(S_t)$ 的一个算术布朗运动。我们将此 SDE 从 $t=0$ 积分到 $t=T$：\n$$\n\\int_0^T \\mathrm{d}(\\ln S_t) = \\int_0^T \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) \\mathrm{d}t + \\int_0^T \\sigma \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n$$\n\\ln(S_T) - \\ln(S_0) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma (W_T^{\\mathbb{P}} - W_0^{\\mathbb{P}})\n$$\n由于标准布朗运动有 $W_0^{\\mathbb{P}} = 0$，我们得到：\n$$\n\\ln(S_T) = \\ln(S_0) + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T^{\\mathbb{P}}\n$$\n对两边取指数，得到 $S_T$ 的路径解：\n$$\nS_T = S_0 \\exp\\left(\\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T^{\\mathbb{P}}\\right)\n$$\n\n### 在物理测度 $\\mathbb{P}$ 下的矩\n在测度 $\\mathbb{P}$ 下，随机变量 $W_T^{\\mathbb{P}}$ 服从均值为 $0$、方差为 $T$ 的正态分布，即 $W_T^{\\mathbb{P}} \\sim N(0, T)$。因此，$\\ln(S_T)$ 是一个正态分布的随机变量：\n$$\n\\ln(S_T) \\sim N\\left(\\ln(S_0) + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T, \\sigma^2 T\\right)\n$$\n这意味着 $S_T$ 服从对数正态分布。对于一个对数正态分布的随机变量 $Y = \\exp(Z)$，其中 $Z \\sim N(m, s^2)$，其前两阶矩由以下公式给出：\n$$\n\\mathbb{E}[Y] = \\exp\\left(m + \\frac{1}{2}s^2\\right)\n$$\n$$\n\\mathrm{Var}(Y) = (\\exp(s^2)-1)\\exp(2m+s^2) = (\\mathbb{E}[Y])^2(\\exp(s^2)-1)\n$$\n对于在 $\\mathbb{P}$ 下的 $S_T$，我们确定 $m = \\ln(S_0) + (\\mu - \\frac{1}{2}\\sigma^2)T$ 和 $s^2 = \\sigma^2 T$。\n期望 $\\mathbb{E}_{\\mathbb{P}}[S_T]$ 是：\n$$\n\\mathbb{E}_{\\mathbb{P}}[S_T] = \\exp\\left( \\ln(S_0) + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\frac{1}{2}\\sigma^2 T \\right) = \\exp(\\ln(S_0) + \\mu T) = S_0 \\exp(\\mu T)\n$$\n方差 $\\mathrm{Var}_{\\mathbb{P}}(S_T)$ 是：\n$$\n\\mathrm{Var}_{\\mathbb{P}}(S_T) = (\\mathbb{E}_{\\mathbb{P}}[S_T])^2 (\\exp(s^2)-1) = (S_0 \\exp(\\mu T))^2 (\\exp(\\sigma^2 T) - 1) = S_0^2 \\exp(2\\mu T) (\\exp(\\sigma^2 T) - 1)\n$$\n\n### 在风险中性测度 $\\mathbb{Q}$ 下的矩\n在风险中性测度 $\\mathbb{Q}$ 下，$S_t$ 的 SDE 给出为：\n$$\n\\mathrm{d}S_{t}=r S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{Q}}\n$$\n该方程与在 $\\mathbb{P}$ 下的 SDE 具有相同的形式，只是漂移参数 $\\mu$ 被无风险利率 $r$ 替换。过程 $\\{W_{t}^{\\mathbb{Q}}\\}_{t \\geq 0}$ 是在 $\\mathbb{Q}$ 下的标准布朗运动，因此在 $\\mathbb{Q}$ 下有 $W_T^{\\mathbb{Q}} \\sim N(0, T)$。\n通过直接类比，用 $\\mathbb{Q}$-布朗运动表示的 $S_T$ 的路径解是：\n$$\nS_T = S_0 \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T^{\\mathbb{Q}}\\right)\n$$\n并且在 $\\mathbb{Q}$ 下 $\\ln(S_T)$ 的分布是：\n$$\n\\ln(S_T) \\sim N\\left(\\ln(S_0) + \\left(r - \\frac{1}{2}\\sigma^2\\right)T, \\sigma^2 T\\right)\n$$\n为了计算在 $\\mathbb{Q}$ 下的矩，我们可以使用与之前相同的公式，只需将 $\\mu$ 替换为 $r$。\n期望 $\\mathbb{E}_{\\mathbb{Q}}[S_T]$ 是：\n$$\n\\mathbb{E}_{\\mathbb{Q}}[S_T] = S_0 \\exp(r T)\n$$\n方差 $\\mathrm{Var}_{\\mathbb{Q}}(S_T)$ 是：\n$$\n\\mathrm{Var}_{\\mathbb{Q}}(S_T) = (\\mathbb{E}_{\\mathbb{Q}}[S_T])^2 (\\exp(\\sigma^2 T)-1) = (S_0 \\exp(r T))^2 (\\exp(\\sigma^2 T) - 1) = S_0^2 \\exp(2r T) (\\exp(\\sigma^2 T) - 1)\n$$\n这四个量构成了最终答案。", "answer": "$$\n\\boxed{\\begin{pmatrix} S_0 \\exp(\\mu T)  S_0^2 \\exp(2\\mu T) (\\exp(\\sigma^2 T) - 1)  S_0 \\exp(r T)  S_0^2 \\exp(2r T) (\\exp(\\sigma^2 T) - 1) \\end{pmatrix}}\n$$", "id": "3321531"}, {"introduction": "标准的蒙特卡洛模拟虽然强大，但收敛速度可能很慢，需要大量模拟路径才能达到所需精度。本练习介绍了一种经典的方差缩减技术——控制变量法，它能显著提高模拟效率。通过利用一个具有已知解析解的相关问题（例如欧式看涨期权的价格），我们可以大幅降低估计量的方差，从而在相同计算成本下获得更精确的结果。[@problem_id:3321573]", "problem": "考虑一个风险中性测度下的金融市场，其中标的资产价格过程 $\\{S_{t}\\}_{t \\in [0,T]}$ 服从几何布朗运动，其动态过程为 $dS_{t} = r S_{t}\\,dt + \\sigma S_{t}\\,dW_{t}$，其中 $S_{0} \\gt 0$，无风险利率 $r \\ge 0$，波动率 $\\sigma \\gt 0$ 和到期日 $T \\gt 0$ 均为常数，$\\{W_{t}\\}$ 是一个标准布朗运动。设 $K \\gt 0$ 为一个固定的执行价。对于一个给定的、至多为多项式增长的 Borel 可测收益函数 $g:\\mathbb{R}_{+}\\to\\mathbb{R}_{+}$，定义折现目标收益为 $Y := \\exp(-rT)\\,g(S_{T})$。你需要通过对 $\\{S_{T}\\}$ 进行蒙特卡洛模拟，来为价值为 $V := \\mathbb{E}[Y]$ 的衍生品定价。\n\n为了使用控制变量法减小方差，你决定使用折现欧式看涨期权收益 $X := \\exp(-rT)\\,(S_{T}-K)_{+}$ 作为控制变量，其风险中性期望可以通过 Black–Scholes 公式以解析解形式得知。将此已知量记为 $C_{\\mathrm{BS}}(S_{0},K,r,\\sigma,T)$。\n\n仅从无偏蒙特卡洛估计、方差、协方差和相关系数的定义出发，并基于上文所述的几何布朗运动模型和风险中性定价原理（不得假定任何额外的特定方差缩减公式），完成以下任务：\n\n- 构建一个使用 $X$ 和 $C_{\\mathrm{BS}}(S_{0},K,r,\\sigma,T)$ 的 $V$ 的无偏控制变量估计量。\n- 推导出使单样本控制变量的方差最小化的系数，并用 $Y$ 和 $X$ 的协方差和方差表示。\n- 将控制变量的最小化方差与 $Y$ 的方差之比，纯粹用 $Y$ 和 $X$ 之间的相关系数表示。\n\n你的最终答案必须是单个解析表达式或一行解析表达式。不需要数值近似，最终答案中也不需要单位。如果提供多个表达式，请将它们表示为单行矩阵。", "solution": "问题陈述已经过验证，被认为是有效的。它科学地基于金融数学和随机微积分的既定原则（Black-Scholes 模型，风险中性定价），是蒙特卡洛方法领域中一个良定的、客观的问题。该问题提供了一个自洽且一致的设定，允许按要求从第一性原理进行严谨的数学推导。\n\n任务是执行三项与蒙特卡洛定价背景下的控制变量方差缩减技术相关的推导。设 $Y := \\exp(-rT)\\,g(S_{T})$ 为折现目标收益，$X := \\exp(-rT)\\,(S_{T}-K)_{+}$ 为折现控制收益。我们已知它们的期望分别为 $V = \\mathbb{E}[Y]$（待估计的量）和 $\\mathbb{E}[X] = C_{\\mathrm{BS}}(S_{0},K,r,\\sigma,T)$（已知值）。\n\n首先，我们构建控制变量估计量。控制变量法的核心思想是利用关于 $X$ 的已知信息来为 $V$ 构建一个新的估计量。我们定义一个新的随机变量，即控制变量，记为 $Y_c(\\beta)$，它是 $Y$ 和中心化的控制变量 $(X - \\mathbb{E}[X])$ 的线性组合。对于任意实系数 $\\beta$，其形式为：\n$$\nY_c(\\beta) = Y - \\beta (X - \\mathbb{E}[X])\n$$\n使用问题中提供的记号，其中 $\\mathbb{E}[X]$ 已知为 $C_{\\mathrm{BS}}$，构建的变量为：\n$$\nY_c(\\beta) = Y - \\beta (X - C_{\\mathrm{BS}})\n$$\n为了成为 $V = \\mathbb{E}[Y]$ 的一个有效估计量，这个新的随机变量必须是无偏的，即其期望必须为 $V$。我们利用期望算子的线性性质来验证这一点：\n$$\n\\mathbb{E}[Y_c(\\beta)] = \\mathbb{E}[Y - \\beta (X - C_{\\mathrm{BS}})] = \\mathbb{E}[Y] - \\beta \\mathbb{E}[X - C_{\\mathrm{BS}}]\n$$\n$$\n\\mathbb{E}[Y_c(\\beta)] = \\mathbb{E}[Y] - \\beta (\\mathbb{E}[X] - \\mathbb{E}[C_{\\mathrm{BS}}])\n$$\n由于 $C_{\\mathrm{BS}}$ 是一个代表 $X$ 真实期望的常数，我们有 $\\mathbb{E}[X] = C_{\\mathrm{BS}}$ 和 $\\mathbb{E}[C_{\\mathrm{BS}}] = C_{\\mathrm{BS}}$。将这些代入可得：\n$$\n\\mathbb{E}[Y_c(\\beta)] = V - \\beta (C_{\\mathrm{BS}} - C_{\\mathrm{BS}}) = V - 0 = V\n$$\n这证实了对于常系数 $\\beta$ 的任何选择，$Y_c(\\beta)$ 都是 $V$ 的一个无偏估计量。这便完成了估计量的构建。然后，通过对 $N$ 个 $Y_c(\\beta)$ 的独立实现取样本均值，可以形成 $V$ 的蒙特卡洛估计。\n\n其次，我们推导使估计量方差最小化的系数 $\\beta^*$。蒙特卡洛估计量的效率由其方差决定。我们寻求选择 $\\beta$ 以最小化 $\\mathrm{Var}(Y_c(\\beta))$。\n控制变量的方差为：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y - \\beta (X - C_{\\mathrm{BS}}))\n$$\n由于加上或减去一个常数（$-\\beta C_{\\mathrm{BS}}$）不影响方差，上式可简化为：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y - \\beta X)\n$$\n使用两个随机变量线性组合的方差标准公式 $\\mathrm{Var}(A - B) = \\mathrm{Var}(A) + \\mathrm{Var}(B) - 2\\mathrm{Cov}(A,B)$，我们得到：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y) + \\mathrm{Var}(\\beta X) - 2\\mathrm{Cov}(Y, \\beta X)\n$$\n使用性质 $\\mathrm{Var}(cZ) = c^2\\mathrm{Var}(Z)$ 和 $\\mathrm{Cov}(Z_1, cZ_2) = c\\mathrm{Cov}(Z_1, Z_2)$（其中 c 为常数）：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y) + \\beta^2 \\mathrm{Var}(X) - 2\\beta \\mathrm{Cov}(Y, X)\n$$\n这个表达式是关于 $\\beta$ 的二次函数。为了找到使该方差最小化的值 $\\beta^*$，我们对其关于 $\\beta$ 求一阶导数，并令其为零：\n$$\n\\frac{d}{d\\beta} \\mathrm{Var}(Y_c(\\beta)) = 2\\beta \\mathrm{Var}(X) - 2\\mathrm{Cov}(Y, X)\n$$\n对于最优系数 $\\beta^*$，令导数为零：\n$$\n2\\beta^* \\mathrm{Var}(X) - 2\\mathrm{Cov}(Y, X) = 0\n$$\n解出 $\\beta^*$，我们得到：\n$$\n\\beta^* = \\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}\n$$\n二阶导数 $\\frac{d^2}{d\\beta^2}\\mathrm{Var}(Y_c(\\beta)) = 2\\mathrm{Var}(X)$ 是正的，因为 $\\sigma  0$ 意味着 $S_T$ 是一个非退化随机变量，因此收益 $X = \\exp(-rT)(S_T - K)_{+}$ 具有正方差。这证实了 $\\beta^*$ 对应一个最小值。\n\n第三，我们将最小化后的方差与原始方差之比用 $Y$ 和 $X$ 之间的相关系数来表示。最小化后的方差为 $\\mathrm{Var}(Y_c(\\beta^*))$。我们将 $\\beta^*$ 的表达式代入方差公式：\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) + (\\beta^*)^2 \\mathrm{Var}(X) - 2\\beta^* \\mathrm{Cov}(Y, X)\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) + \\left(\\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}\\right)^2 \\mathrm{Var}(X) - 2 \\left(\\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}\\right) \\mathrm{Cov}(Y, X)\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var(Y)} + \\frac{\\mathrm{Cov}(Y, X)^2}{\\mathrm{Var}(X)} - 2\\frac{\\mathrm{Cov}(Y, X)^2}{\\mathrm{Var}(X)}\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) - \\frac{\\mathrm{Cov}(Y, X)^2}{\\mathrm{Var}(X)}\n$$\n现在，我们使用 $Y$ 和 $X$ 之间的相关系数 $\\rho_{Y,X}$ 的定义：\n$$\n\\rho_{Y,X} = \\frac{\\mathrm{Cov}(Y, X)}{\\sqrt{\\mathrm{Var}(Y)\\mathrm{Var}(X)}}\n$$\n由此，我们可以写出 $\\mathrm{Cov}(Y, X)^2 = \\rho_{Y,X}^2 \\mathrm{Var}(Y) \\mathrm{Var}(X)$。将其代入最小化方差的表达式中，得到：\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) - \\frac{\\rho_{Y,X}^2 \\mathrm{Var}(Y) \\mathrm{Var}(X)}{\\mathrm{Var}(X)} = \\mathrm{Var}(Y) - \\rho_{Y,X}^2 \\mathrm{Var}(Y)\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) (1 - \\rho_{Y,X}^2)\n$$\n所求的控制变量的最小化方差与原始变量 $Y$ 的方差之比为：\n$$\n\\frac{\\mathrm{Var}(Y_c(\\beta^*))}{\\mathrm{Var}(Y)} = \\frac{\\mathrm{Var}(Y) (1 - \\rho_{Y,X}^2)}{\\mathrm{Var}(Y)} = 1 - \\rho_{Y,X}^2\n$$\n此结果表明，方差缩减的程度由目标收益和控制变量之间相关系数的平方决定。绝对相关系数 $|\\rho_{Y,X}|$ 越高，方差缩减的幅度就越大。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nY - \\beta(X - C_{\\mathrm{BS}})  \\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}  1 - \\rho_{Y,X}^2\n\\end{pmatrix}\n}\n$$", "id": "3321573"}, {"introduction": "对于路径依赖期权（如亚式期权或障碍期权），我们必须在离散时间点上模拟资产路径，这会引入一种系统性误差，即“离散化偏差”。本实践是一个动手编程练习，旨在演示如何应用理查森外推法来消除这种偏差。您将为两种不同的路径依赖期权实现该方法，并亲身体会如何根据支付函数的特性来调整误差修正的阶数。[@problem_id:3321511]", "problem": "考虑一个单资产模型的风险中性定价，其中标的价格过程由几何布朗运动（GBM）建模。在风险中性测度下，资产价格过程满足随机微分方程（SDE）$dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，初始值为$S_0$，其中$r$是连续复利无风险利率，$\\sigma$是波动率，$W_t$是标准布朗运动。其精确解满足$S_{t+\\Delta} = S_t \\exp\\left(\\left(r - \\tfrac{1}{2}\\sigma^2\\right)\\Delta + \\sigma \\sqrt{\\Delta} Z\\right)$，其中$Z \\sim \\mathcal{N}(0,1)$在各个时间步之间是独立的。\n\n一个到期日为$T$、支付函数$\\Phi$依赖于路径的欧式或有债权在时间0的定价为$V = \\mathrm{e}^{-rT} \\mathbb{E}[\\Phi(S_{[0,T]})]$，其中$\\Phi$可能依赖于整个轨迹$S_{[0,T]}$。在路径依赖支付的时间离散化蒙特卡洛（MC）模拟中，路径在一个网格尺寸为$h = T/N$的离散时间网格上被观察，并使用离散时间近似$\\Phi_h$。将弱误差（偏差）定义为$\\mathbb{E}[\\Phi_h] - \\mathbb{E}[\\Phi]$。对于GBM下时间离散化泛函的弱收敛，一个经过充分验证的事实是：\n- 对于通过在均匀时间网格上使用矩形法则平均计算的算术平均亚式期权，价格的弱误差为$O(h)$，即阶数为$\\alpha=1$。\n- 对于在均匀网格上采用朴素离散监控（即仅在网格点检查是否穿越障碍，不进行布朗桥修正）的向上敲出障碍期权，价格的弱误差为$O(h^{1/2})$，即阶数为$\\alpha = \\tfrac{1}{2}$，这是由于在观察时间点之间错过的障碍穿越事件的缩放特性所致。\n\n如果误差允许展开为$\\mathbb{E}[\\Phi_h] = \\mathbb{E}[\\Phi] + c h^{\\alpha} + o(h^{\\alpha})$（其中$c$为某个常数），理查森外推法可以消除主阶弱误差。给定通过加密比$r  1$计算出的估计值$P_h$和$P_{h/r}$，能够消除$h^{\\alpha}$项的外推估计量为\n$$\nP_{\\mathrm{RE}} = \\frac{r^{\\alpha} P_{h/r} - P_h}{r^{\\alpha} - 1}.\n$$\n你的任务是：\n- 从GBM模型和风险中性估值出发，解释弱收敛阶数$\\alpha$如何影响两种路径依赖支付（算术平均亚式看涨期权和采用朴素离散监控的向上敲出障碍看涨期权）的时间离散化MC价格的偏差。\n- 推导适用于弱收敛阶数$\\alpha$的理查森外推法公式，并具体说明如何使用公共随机数来实现它，以使粗网格和细网格的估计量以一致的方式共享底层的布朗路径增量。\n- 实现一个完整、可运行的程序，该程序：\n  1. 使用带有标准正态增量的精确转移方法，在离散时间点上精确地模拟GBM路径。\n  2. 通过将连续的细网格增量相加再除以$\\sqrt{r}$来构造粗网格的布朗增量，从而在粗、细网格之间使用公共随机数。\n  3. 通过MC方法使用两种网格尺寸$h$和$h/2$（即加密比$r=2$）为每种支付定价，并计算针对该支付的正确弱收敛阶数$\\alpha$调整的理查森外推值。\n  4. 使用风险中性贴现$\\mathrm{e}^{-rT}$。\n  5. 按下文指定格式生成最终输出。\n\n需要实现的支付：\n- 算术平均亚式看涨期权：$\\Phi_{\\text{Asian}} = \\max\\left(\\frac{1}{N} \\sum_{k=1}^{N} S_{t_k} - K,\\; 0\\right)$，其中$t_k = k h$。\n- 采用朴素离散监控的向上敲出障碍看涨期权：$\\Phi_{\\text{UO}} = \\mathbf{1}\\{\\max_{k=1,\\dots,N} S_{t_k}  B\\} \\max(S_T - K,\\; 0)$，其中$B$是障碍水平，指示函数仅在离散观察时间检查是否突破障碍。\n\n实现要求：\n- 理查森外推法使用加密比$r=2$。\n- 通过将细网格的增量配对，并通过按$\\sqrt{2}$缩放的平均值来获得粗网格的标准正态增量，从而在粗、细网格之间使用公共随机数，确保粗网格增量等于两个连续细网格增量在布朗时间上的和。\n- 在每个时间步使用$S_{t+\\Delta}$的精确GBM转移，以消除SDE离散化误差，使得只有路径函数的离散化对偏差有贡献。\n\n测试套件：\n提供以下三个测试用例，并使用固定的蒙特卡洛样本量和种子以保证可复现性。对每个测试，计算三个数：粗网格价格$P_h$，细网格价格$P_{h/2}$，以及理查森外推价格$P_{\\mathrm{RE}}$。\n\n- 测试A（算术平均亚式看涨期权，阶数$\\alpha = 1$）：\n  - 参数：$S_0 = 100$, $K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1$, $N_{\\text{coarse}} = 64$, 加密比$r=2$。\n  - 蒙特卡洛：路径数$M = 120000$, 随机种子 = 12345。\n\n- 测试B（向上敲出障碍看涨期权，离散监控，阶数$\\alpha = \\tfrac{1}{2}$）：\n  - 参数：$S_0 = 100$, $K = 100$, $B = 130$, $r = 0.03$, $\\sigma = 0.25$, $T = 1$, $N_{\\text{coarse}} = 64$, 加密比$r=2$。\n  - 蒙特卡洛：路径数$M = 120000$, 随机种子 = 54321。\n\n- 测试C（向上敲出障碍看涨期权，障碍实际无效，这是一个重要的边缘案例；该期权的行为几乎与普通看涨期权相同）：\n  - 参数：$S_0 = 100$, $K = 100$, $B = 1000$, $r = 0.03$, $\\sigma = 0.25$, $T = 1$, $N_{\\text{coarse}} = 64$, 加密比$r=2$。\n  - 蒙特卡洛：路径数$M = 120000$, 随机种子 = 67890。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。\n- 九个输出按以下顺序出现：首先是测试A的$[P_h, P_{h/2}, P_{\\mathrm{RE}}]$，然后是测试B的$[P_h, P_{h/2}, P_{\\mathrm{RE}}]$，最后是测试C的$[P_h, P_{h/2}, P_{\\mathrm{RE}}]$，连接成一个长度为9的列表。\n- 所有输出必须是浮点数（以货币单位表示，无特殊单位转换），并按规定使用风险中性贴现。", "solution": "此问题被评估为有效。它在科学上基于金融工程的成熟理论，特别是风险中性定价、资产价格的随机微分方程以及蒙特卡洛模拟方法。该问题定义明确，提供了所有必要的参数和定义。它要求推导和实现一种标准数值技术——理查森外推法，并将其应用于众所周知的人路径依赖期权。整个设置是自洽、一致且客观的。\n\n### 理论基础与算法设计\n\n#### 1. 风险中性定价与几何布朗运动\n\n在风险中性的世界里，衍生品的价格是其未来支付的贴现期望值。标的资产价格$S_t$由几何布朗运动（GBM）过程建模，该过程由以下随机微分方程（SDE）描述：\n$$\ndS_t = r S_t \\, dt + \\sigma S_t \\, dW_t\n$$\n这里，$S_t$是时间$t$的资产价格，$r$是恒定的无风险利率，$\\sigma$是恒定的波动率，$W_t$是标准维纳过程（布朗运动）。\n\n对于蒙特卡洛模拟，我们需要在离散时间网格$0=t_0, t_1, \\dots, t_N=T$上生成$S_t$的路径，时间步长均匀为$\\Delta t = T/N$。该SDE的精确解使我们能够在不引入任何SDE离散化误差的情况下模拟下一个时间步的价格。给定$S_{t_k}$，下一个时间步$S_{t_{k+1}}$的价格由下式给出：\n$$\nS_{t_{k+1}} = S_{t_k} \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_{k+1}\\right)\n$$\n其中$Z_1, Z_2, \\dots, Z_N$是独立同分布的标准正态随机变量，$Z_k \\sim \\mathcal{N}(0,1)$。\n\n一个到期日为$T$、支付函数为$\\Phi$的欧式或有债权的价格由风险中性估值公式给出：\n$$\nV_0 = e^{-rT} \\mathbb{E}[\\Phi(S_{[0,T]})]\n$$\n其中$\\mathbb{E}[\\cdot]$表示在风险中性测度下的期望。\n\n#### 2. 时间离散化支付中的弱误差\n\n对于路径依赖期权，支付函数$\\Phi$可能依赖于整个路径$S_{[0,T]}$。在离散时间模拟中，我们用一个仅依赖于离散网格点$\\{S_{t_k}\\}_{k=0}^N$上价格的函数$\\Phi_h$来近似$\\Phi$，其中$h = T/N$是网格尺寸。这种近似引入了时间离散化误差，也称为偏差或弱误差，定义为$\\mathbb{E}[\\Phi_h] - \\mathbb{E}[\\Phi]$。这个误差的阶数$\\alpha$取决于离散函数$\\Phi_h$如何收敛于连续函数$\\Phi$。\n\n- **算术平均亚式看涨期权：** 支付基于路径上的平均价格。连续时间的支付涉及一个积分：$\\max(\\frac{1}{T}\\int_0^T S_u du - K, 0)$。离散时间的近似使用求和：$\\Phi_{\\text{Asian}} = \\max(\\frac{1}{N}\\sum_{k=1}^N S_{t_k} - K, 0)$。这个求和是积分的矩形法则近似。该数值积分方案的误差阶数为$h$。这导致价格估计量的弱收敛阶数为$\\alpha=1$，意味着偏差与$h$成正比。\n\n- **向上敲出障碍看涨期权：** 支付取决于路径上的最大价格：$\\Phi_{\\text{UO}} = \\mathbf{1}\\{\\sup_{u \\in [0,T]} S_u  B\\} \\max(S_T - K, 0)$。朴素的离散监控方法仅在网格点检查障碍条件：$\\Phi_{\\text{UO},h} = \\mathbf{1}\\{\\max_{k=1,\\dots,N} S_{t_k}  B\\} \\max(S_T - K, 0)$。一个显著的误差来源是，连续路径$S_u$可能在观察点$t_k$和$t_{k+1}$*之间*穿过障碍$B$而未被检测到。在长度为$h$的短区间内发生此类未被检测到的穿越的概率与$\\sqrt{h}$成比例。这导致对真实敲出概率的系统性低估，从而高估了期权价格。最终的弱收敛阶数为$\\alpha = 1/2$，意味着偏差与$\\sqrt{h}$成正比。\n\n#### 3. 理查森外推法\n\n理查森外推法是一种通过消除主阶误差项来提高数值近似精度的技术。假设离散化支付估计量的期望值$P_h = e^{-rT}\\mathbb{E}[\\Phi_h]$允许关于步长$h$的幂次误差展开：\n$$\nP_h = V_0 + c h^{\\alpha} + O(h^{\\beta}) \\quad \\text{其中 } \\beta  \\alpha\n$$\n这里$V_0$是真实价格，$c$是一个常数，$\\alpha$是弱收敛阶数。\n\n我们可以使用两种不同的步长来计算价格：一个粗步长$h$和一个细步长$h/r$，其中加密比$r  1$。令$P_h$和$P_{h/r}$为我们蒙特卡洛模拟中对应的价格估计。我们有以下近似方程组：\n\\begin{align*}\nP_h \\approx V_0 + c h^{\\alpha} \\quad (1) \\\\\nP_{h/r} \\approx V_0 + c \\left(\\frac{h}{r}\\right)^{\\alpha} = V_0 + \\frac{c}{r^{\\alpha}} h^{\\alpha} \\quad (2)\n\\end{align*}\n我们的目标是消除未知的误差项$c h^{\\alpha}$，以获得对$V_0$更好的估计。我们将方程(2)乘以$r^{\\alpha}$：\n$$\nr^{\\alpha} P_{h/r} \\approx r^{\\alpha} V_0 + c h^{\\alpha} \\quad (3)\n$$\n从方程(3)中减去方程(1)得到：\n$$\nr^{\\alpha} P_{h/r} - P_h \\approx (r^{\\alpha} - 1) V_0\n$$\n解出$V_0$便得到理查森外推估计量$P_{\\mathrm{RE}}$：\n$$\nP_{\\mathrm{RE}} = \\frac{r^{\\alpha} P_{h/r} - P_h}{r^{\\alpha} - 1}\n$$\n这个估计量具有更高的精度阶数，其主误差项为$O(h^{\\beta})$。该公式的有效性关键取决于正确的弱收敛阶数$\\alpha$。对于亚式期权，我们使用$\\alpha=1$。对于离散监控的障碍期权，我们使用$\\alpha=1/2$。指定的加密比为$r=2$。\n\n#### 4. 使用公共随机数（CRN）的实现\n\n理查森外推法的有效性取决于$P_h$和$P_{h/r}$的准确估计。为了减小组合估计量$P_{\\mathrm{RE}}$的方差，使用公共随机数（CRN）至关重要。该技术通过使用相同的底层随机源为粗网格和细网格生成路径，来确保差异$P_{h/r} - P_h$具有较小的方差。\n\n我们首先为$M$条蒙特卡洛路径中的每一条生成一组$N_{\\text{fine}}$个标准正态变量$\\{Z_k\\}_{k=1}^{N_{\\text{fine}}}$。这里，$N_{\\text{fine}} = r \\times N_{\\text{coarse}}$。在我们的例子中，$r=2$，所以$N_{\\text{fine}} = 2 N_{\\text{coarse}}$。\n\n1.  **细网格路径模拟：** 使用步长为$h_{\\text{fine}} = T/N_{\\text{fine}}$的精确GBM转移公式和随机变量$Z_k$模拟一条具有$N_{\\text{fine}}$个步长的完整路径。记此路径为$\\{S_{t_k}^{\\text{fine}}\\}_{k=0}^{N_{\\text{fine}}}$。\n\n2.  **粗网格路径构建：** 粗网格路径从细网格路径中一致地构建。一个粗网格时间步长$h_{\\text{coarse}} = T/N_{\\text{coarse}} = r h_{\\text{fine}}$对应于$r$个细网格步长。粗网格点$t'_j = j h_{\\text{coarse}}$上的资产价格就是对应细网格点$t_k$（其中$k=j \\times r$）上的价格。因此，我们可以通过从模拟的细网格路径中每隔$r$个点选取一个点来获得粗网格路径：$\\{S_{t'_j}^{\\text{coarse}}\\} = \\{S_{t_{j \\times r}}^{\\text{fine}}\\}$。对于$r=2$，这意味着`S_coarse = S_fine[::2]`。这正确地实现了CRN方案，其中粗网格步长的布朗增量是底层细网格步长增量的按比例缩放之和，确保两条路径的终端价格$S_T$相同，这是CRN的一个关键特性。\n\n在模拟了$M$对（粗、细）路径后，我们计算平均支付，并将其贴现以获得价格估计值$P_h$和$P_{h/2}$，最后应用适当的理查森外推公式来计算$P_{\\mathrm{RE}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef price_with_richardson(\n    S0, K, r, sigma, T,\n    N_coarse, B, M, seed,\n    option_type, alpha\n):\n    \"\"\"\n    Prices a path-dependent option using Monte Carlo simulation with two grid sizes\n    and applies Richardson extrapolation to reduce the weak error (bias).\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity.\n        N_coarse (int): Number of time steps for the coarse grid.\n        B (float or None): Barrier level for barrier options.\n        M (int): Number of Monte Carlo paths.\n        seed (int): Random seed for reproducibility.\n        option_type (str): Type of option ('asian_call' or 'barrier_call').\n        alpha (float): Weak convergence order.\n\n    Returns:\n        tuple[float, float, float]: A tuple containing the coarse-grid price,\n                                     the fine-grid price, and the Richardson-\n                                     extrapolated price.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Grid parameters\n    refinement_ratio = 2\n    N_fine = refinement_ratio * N_coarse\n    h_fine = T / N_fine\n\n    # Generate all standard normal random numbers for all fine paths at once\n    Z = rng.standard_normal(size=(M, N_fine))\n\n    # --- Simulate all fine paths in a vectorized manner ---\n    # We use the exact log-normal solution for GBM\n    S_fine = np.zeros((M, N_fine + 1))\n    S_fine[:, 0] = S0\n    \n    # Calculate log-returns for each step\n    drift = (r - 0.5 * sigma**2) * h_fine\n    diffusion = sigma * np.sqrt(h_fine)\n    log_returns = drift + diffusion * Z\n    \n    # Cumulatively sum log-returns to get log-path, then exponentiate\n    log_paths = np.cumsum(log_returns, axis=1)\n    S_fine[:, 1:] = S0 * np.exp(log_paths)\n\n    # --- Extract coarse paths using Common Random Numbers (CRN) ---\n    # The coarse path consists of every `refinement_ratio`-th point of the fine path.\n    # This correctly implements CRN as the Brownian increments are nested.\n    S_coarse = S_fine[:, ::refinement_ratio]\n    \n    # --- Calculate payoffs for both grids ---\n    # Per problem definition, path-dependent features (avg, max) are computed\n    # over the discrete observation points t_1, ..., t_N.\n    # This corresponds to array slices [:, 1:].\n    \n    if option_type == 'asian_call':\n        # Fine grid payoff\n        avg_fine = np.mean(S_fine[:, 1:], axis=1)\n        payoff_fine = np.maximum(avg_fine - K, 0)\n        # Coarse grid payoff\n        avg_coarse = np.mean(S_coarse[:, 1:], axis=1)\n        payoff_coarse = np.maximum(avg_coarse - K, 0)\n    \n    elif option_type == 'barrier_call':\n        # Fine grid payoff\n        max_fine = np.max(S_fine[:, 1:], axis=1)\n        indicator_fine = (max_fine  B)\n        # Payoff is based on terminal price S_T = S_fine[:, -1]\n        payoff_fine = np.maximum(S_fine[:, -1] - K, 0) * indicator_fine\n        \n        # Coarse grid payoff\n        max_coarse = np.max(S_coarse[:, 1:], axis=1)\n        indicator_coarse = (max_coarse  B)\n        # Terminal price is identical due to CRN: S_coarse[:, -1] == S_fine[:, -1]\n        payoff_coarse = np.maximum(S_coarse[:, -1] - K, 0) * indicator_coarse\n    else:\n        raise ValueError(\"Unknown option type specified.\")\n\n    # --- Calculate discounted expected payoffs (prices) ---\n    discount_factor = np.exp(-r * T)\n    P_coarse = discount_factor * np.mean(payoff_coarse) # This is P_h\n    P_fine = discount_factor * np.mean(payoff_fine)     # This is P_{h/r}\n    \n    # --- Richardson Extrapolation ---\n    # P_RE = (r^alpha * P_{h/r} - P_h) / (r^alpha - 1)\n    P_RE = (refinement_ratio**alpha * P_fine - P_coarse) / (refinement_ratio**alpha - 1)\n    \n    return P_coarse, P_fine, P_RE\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A: Arithmetic-average Asian call, weak order alpha = 1.0\n        {'S0': 100, 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1, 'N_coarse': 64, \n         'B': None, 'M': 120000, 'seed': 12345, 'option_type': 'asian_call', 'alpha': 1.0},\n        \n        # Test B: Up-and-out barrier call, discrete monitoring, weak order alpha = 0.5\n        {'S0': 100, 'K': 100, 'B': 130, 'r': 0.03, 'sigma': 0.25, 'T': 1, 'N_coarse': 64, \n         'M': 120000, 'seed': 54321, 'option_type': 'barrier_call', 'alpha': 0.5},\n        \n        # Test C: Up-and-out barrier call, effectively inactive barrier, alpha = 0.5\n        {'S0': 100, 'K': 100, 'B': 1000, 'r': 0.03, 'sigma': 0.25, 'T': 1, 'N_coarse': 64, \n         'M': 120000, 'seed': 67890, 'option_type': 'barrier_call', 'alpha': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        p_coarse, p_fine, p_re = price_with_richardson(**params)\n        results.extend([p_coarse, p_fine, p_re])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3321511"}]}