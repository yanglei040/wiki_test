{
        "hands_on_practices": [
            {
                "introduction": "算法复杂度分析的第一步是学会精确地计算基本运算的数量。本练习提供了一个基础案例研究：稠密矩阵与向量的乘法。通过这个练习，你将学习如何推导确切的浮点运算（flop）次数，并利用大O符号的严格定义来证明其 $O(n^2)$ 的复杂度，为分析更复杂的算法打下坚实的基础。[@problem_id:3534517]",
                "problem": "考虑基本线性代数子程序 (BLAS) 意义下的稠密矩阵向量乘法，具体指运算 $y \\leftarrow A x$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $x, y \\in \\mathbb{R}^{n}$。在数值线性代数中使用的标准浮点运算 (flop) 成本模型下进行计算：每次标量浮点加法计为 $1$ flop，每次标量浮点乘法计为 $1$ flop；忽略数据移动、分支和循环开销。假设不使用熔合乘加运算。\n\n从 flop 计数的根本定义和 大O (Landau) 记号的正式定义出发，推导出一个直接的、面向行的稠密矩阵向量乘法实现的精确 flop 数量 $F(n)$。该实现通过使用单个累加器，将每个分量 $y_i$ 计算为矩阵 $A$ 的第 $i$ 行与向量 $x$ 的点积。然后，使用大O记号的正式定义，证明 $F(n)$ 属于集合 $O(n^{2})$。\n\n以单个关于 $n$ 的封闭形式表达式报告精确的 flop 数量。最终答案中不得包含不等式、方程或渐近记法。无需进行舍入。",
                "solution": "该问题经检验为自洽、一致且科学上合理。这是数值线性代数导论和计算复杂性分析中的一个标准问题。\n\n任务是确定稠密矩阵向量乘法 $y \\leftarrow A x$（其中 $A \\in \\mathbb{R}^{n \\times n}$，$x, y \\in \\mathbb{R}^{n}$）的精确浮点运算 (flop) 数量，然后正式证明该数量属于 $O(n^2)$。\n\n首先，我们推导精确的 flop 数量，记为 $F(n)$。该运算是针对向量 $y$ 的每个元素 $y_i$ 按分量定义的，其中 $i$ 的范围从 $1$ 到 $n$。第 $i$ 个分量的公式为：\n$$\ny_i = \\sum_{j=1}^{n} A_{ij} x_j\n$$\n这可以展开为：\n$$\ny_i = A_{i1}x_1 + A_{i2}x_2 + \\dots + A_{in}x_n\n$$\n我们根据指定的 flop 模型来分析计算单个分量 $y_i$ 的成本，在该模型中，一次标量加法和一次标量乘法都计为 $1$ flop。\n\n对于单个 $y_i$，计算涉及以下操作：\n1. 一系列 $n$ 次标量乘法：$A_{i1}x_1, A_{i2}x_2, \\dots, A_{in}x_n$。这贡献了 $n$ 次乘法 flop。\n2. 对乘法产生的 $n$ 个乘积求和。将 $n$ 个项相加需要 $n-1$ 次标量加法。例如，$(A_{i1}x_1 + A_{i2}x_2)$ 是一次加法，将 $A_{i3}x_3$ 与此和相加是第二次加法，以此类推，直到加上第 $n$ 个项，这构成了第 $(n-1)$ 次加法。使用单个累加器计算点积对应于这种顺序求和。这贡献了 $n-1$ 次加法 flop。\n\n计算单个分量 $y_i$ 的总 flop 数量是乘法 flop 和加法 flop 的总和：\n$$\n\\text{每个分量的 flop 数} = n + (n-1) = 2n-1\n$$\n由于向量 $y$ 有 $n$ 个分量（$y_1, y_2, \\dots, y_n$），并且每个分量的计算是独立的且成本相同，因此整个矩阵向量乘法的总 flop 数量 $F(n)$ 是分量数乘以每个分量的 flop 数：\n$$\nF(n) = n \\times (2n-1)\n$$\n展开此表达式，得到精确 flop 数量的最终封闭形式：\n$$\nF(n) = 2n^2 - n\n$$\n接下来，我们必须使用大O记号的正式定义来证明 $F(n)$ 属于集合 $O(n^2)$。如果存在一个正常数 $C$ 和一个自然数 $n_0$，使得对于所有 $n \\geq n_0$，不等式 $|f(n)| \\leq C |g(n)|$ 恒成立，那么函数 $f(n)$ 就属于 $O(g(n))$。\n\n在本例中，我们的函数是 $f(n) = F(n) = 2n^2 - n$，我们想证明它属于 $O(n^2)$，所以 $g(n) = n^2$。\n我们需要找到常数 $C > 0$ 和 $n_0 \\in \\mathbb{N}$，使得对于所有 $n \\geq n_0$：\n$$\n|2n^2 - n| \\leq C |n^2|\n$$\n由于 $n$ 代表矩阵的维度，$n$ 必须是正整数，所以 $n \\geq 1$。\n对于 $n \\geq 1$，项 $2n^2 - n = n(2n - 1)$ 是非负的，所以 $|2n^2 - n| = 2n^2 - n$。同样，对于 $n \\geq 1$，$|n^2| = n^2$。\n不等式变为：\n$$\n2n^2 - n \\leq C n^2\n$$\n为了找到一个合适的 $C$ 值，我们可以对不等式进行变换。因为对于 $n \\geq 1$ 有 $n^2 > 0$，所以我们可以将不等式两边同时除以 $n^2$：\n$$\n2 - \\frac{1}{n} \\leq C\n$$\n我们需要找到一个常数 $C$，使得从某个 $n_0$ 开始，对于所有的 $n$ 该不等式都成立。我们选择 $n_0 = 1$。对于所有 $n \\geq 1$，我们知道 $0  \\frac{1}{n} \\leq 1$。\n这意味着 $2 - \\frac{1}{n}  2$。\n因此，我们可以选择任何满足 $C \\geq 2$ 的常数。一个简单且有效的选择是 $C=2$。\n\n我们来验证我们的选择。我们选择 $C=2$ 和 $n_0=1$。我们必须证明对于所有 $n \\geq 1$，不等式 $2n^2 - n \\leq 2n^2$ 成立。\n两边同时减去 $2n^2$ 得到：\n$$\n-n \\leq 0\n$$\n这个不等式对所有正整数 $n$ 都成立，因此对于所有 $n \\geq 1$ 也必然成立。\n既然我们找到了满足定义的常数 $C=2$ 和整数 $n_0=1$，我们就正式证明了 $F(n) = 2n^2 - n$ 属于 $O(n^2)$。\n\n题目要求的最终答案是关于 $n$ 的单个封闭形式的精确 flop 数量。这就是我们推导出的函数 $F(n)$。",
                "answer": "$$\n\\boxed{2n^2 - n}\n$$",
                "id": "3534517"
            },
            {
                "introduction": "在掌握了基本计数技巧之后，我们现在来处理一个数值线性代数中的核心算法：Cholesky分解。这个实践将展示如何分析具有嵌套循环结构的算法，这是矩阵计算中的常见模式。通过仔细地对每一步的运算进行求和，我们将推导出稠密矩阵分解众所周知的 $O(n^3)$ 复杂度。[@problem_id:3534512]",
                "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稠密对称正定（SPD）矩阵。考虑一种无分块左向 Cholesky 分解算法，该算法计算一个对角线元素为正的下三角矩阵 $L$，使得 $A = L L^{\\top}$。该算法使用以下面向列的过程：\n- 对于 $k = 1, \\dots, n$：\n  - 计算对角线元素\n    $$L_{k k} = \\sqrt{A_{k k} - \\sum_{s=1}^{k-1} L_{k s}^{2}}.$$\n  - 对于每个 $i = k+1, \\dots, n$，计算\n    $$L_{i k} = \\frac{A_{i k} - \\sum_{s=1}^{k-1} L_{i s} L_{k s}}{L_{k k}}.$$\n采用标量运算成本模型，其中以下每种标量算术运算的成本为单位成本：加法、减法、乘法、除法和平方根。令 $T(n)$ 表示该算法在 $n \\times n$ 输入上执行的此类标量运算的总数。\n\n从第一性原理出发——即 Cholesky 分解的定义、上述算法步骤以及大O符号 $O(\\cdot)$ 的形式化渐近定义——推导 $T(n)$ 的闭式表达式，并用它来确定算法的渐近复杂度类别。您的推导必须明确说明每个内部计算中标量运算的次数，并在所有循环中精确地对它们求和。\n\n将您的最终答案表示为关于 $n$ 的单个简化解析表达式 $T(n)$（无单位）。最终答案中不要提供不等式或方程。",
                "solution": "问题要求推导对一个 $n \\times n$ 稠密对称正定（SPD）矩阵 $A$ 进行无分块左向 Cholesky 分解所需的标量算术运算的确切数量，记为 $T(n)$。我们还被要求确定该算法的渐近复杂度。允许的标量运算（每个成本为单位成本）是加法、减法、乘法、除法和平方根。\n\n该算法通过顺序计算下三角矩阵 $L$ 的列来进行。总成本 $T(n)$ 是外层循环每一步成本的总和，该循环从 $k=1$ 迭代到 $n$。设 $C_k$ 为该循环第 $k$ 次迭代期间执行的运算成本。那么，$T(n) = \\sum_{k=1}^{n} C_k$。\n\n在第 $k$ 次迭代中，执行两个主要计算：\n1. 对角线元素 $L_{kk}$ 的计算。\n2. 第 $k$ 列中非对角线元素 $L_{ik}$ 的计算，其中 $i = k+1, \\dots, n$。\n\n让我们分析在一次通用迭代 $k$ 中这些计算的成本。\n\n**计算 $L_{kk}$ 的成本**\n公式为 $L_{k k} = \\sqrt{A_{k k} - \\sum_{s=1}^{k-1} L_{k s}^{2}}$。\n当 $k=1$ 时，求和 $\\sum_{s=1}^{0}$ 为空，其值为 $0$。表达式简化为 $L_{11} = \\sqrt{A_{11}}$。这需要 $1$ 次平方根运算。\n当 $k > 1$ 时，计算涉及几个步骤：\n- 求和 $\\sum_{s=1}^{k-1} L_{k s}^{2}$ 需要计算 $k-1$ 个平方（$L_{ks}^2$），这需要 $k-1$ 次乘法。\n- 对这 $k-1$ 个项求和，需要 $k-2$ 次加法。\n- 然后，有 $1$ 次减法（$A_{kk} - \\dots$）。\n- 最后，有 $1$ 次平方根运算。\n因此，当 $k > 1$ 时，计算 $L_{kk}$ 的总成本是 $(k-1) + (k-2) + 1 + 1 = 2k-1$ 次运算。\n我们将计算 $L_{kk}$ 的成本表示为 $C_{kk}$。\n$C_{kk} = \\begin{cases} 1  \\text{若 } k=1 \\\\ 2k-1  \\text{若 } k > 1 \\end{cases}$。\n\n**计算 $L_{ik}$（其中 $i=k+1, \\dots, n$）的成本**\n对于一个固定的 $k$，一个关于 $i$ 的循环从 $k+1$ 运行到 $n$。这个循环有 $n-k$ 次迭代。在这个循环内部，元素 $L_{ik}$ 使用以下公式计算：\n$L_{i k} = \\frac{A_{i k} - \\sum_{s=1}^{k-1} L_{i s} L_{k s}}{L_{k k}}$。\n设 $c_{ik}$ 为计算单个元素 $L_{ik}$ 的成本。\n当 $k=1$ 时，求和为空。公式变为 $L_{i1} = \\frac{A_{i1}}{L_{11}}$。这需要 $1$ 次除法。\n当 $k > 1$ 时，计算涉及：\n- 求和 $\\sum_{s=1}^{k-1} L_{i s} L_{k s}$ 需要 $k-1$ 次乘法和 $k-2$ 次加法。\n- 然后，有 $1$ 次减法（$A_{ik} - \\dots$）。\n- 最后，有 $1$ 次除以 $L_{kk}$ 的除法。\n因此，当 $k > 1$ 时，计算一个元素 $L_{ik}$ 的总成本是 $(k-1) + (k-2) + 1 + 1 = 2k-1$ 次运算。\n所以，成本 $c_{ik}$ 是：\n$c_{ik} = \\begin{cases} 1  \\text{若 } k=1 \\\\ 2k-1  \\text{若 } k > 1 \\end{cases}$。\n\n在固定的步骤 $k$ 中，对 $i$ 的内层循环的总成本是 $(n-k) \\times c_{ik}$。\n\n**第 $k$ 次迭代的总成本 $C_k$**\n我们现在可以求出外层循环每次迭代 $k$ 的总成本 $C_k$。\n当 $k=1$ 时：\n$C_1 = C_{11} + \\sum_{i=2}^{n} c_{i1} = 1 + (n-1) \\times 1 = n$。\n当 $k > 1$ 时：\n$C_k = C_{kk} + \\sum_{i=k+1}^{n} c_{ik} = (2k-1) + (n-k) \\times (2k-1)$。\n提取公因式 $(2k-1)$，我们得到 $C_k = (1 + n-k)(2k-1) = (n-k+1)(2k-1)$。\n\n我们可以检查这个对于 $k>1$ 的通用公式是否也对 $k=1$ 成立：\n当 $k=1$ 时，该公式给出 $C_1 = (n-1+1)(2(1)-1) = n \\times 1 = n$。\n该公式是一致的。因此，我们可以将任何迭代 $k \\in \\{1, \\dots, n\\}$ 的成本表示为 $C_k = (n-k+1)(2k-1)$。\n\n**总运算次数 $T(n)$**\n总运算次数是所有迭代成本的总和：\n$$T(n) = \\sum_{k=1}^{n} C_k = \\sum_{k=1}^{n} (n-k+1)(2k-1).$$\n为了简化这个求和，我们进行换元。令 $j = n-k+1$。当 $k$ 从 $1$ 跑到 $n$ 时，新下标 $j$ 从 $n$ 递减到 $1$。$k$ 的变换是 $k = n-j+1$。\n将此代入求和中：\n$$T(n) = \\sum_{j=1}^{n} j \\cdot \\left( 2(n-j+1) - 1 \\right).$$\n求和内的项是 $j(2n - 2j + 2 - 1) = j(2n - 2j + 1) = 2nj - 2j^2 + j$。\n求和变为：\n$$T(n) = \\sum_{j=1}^{n} (2nj - 2j^2 + j) = \\sum_{j=1}^{n} (-2j^2 + (2n+1)j).$$\n使用求和的线性性质：\n$$T(n) = -2 \\sum_{j=1}^{n} j^2 + (2n+1) \\sum_{j=1}^{n} j.$$\n我们使用前 $n$ 个整数之和与前 $n$ 个平方数之和的标准公式：\n$\\sum_{j=1}^{n} j = \\frac{n(n+1)}{2}$\n$\\sum_{j=1}^{n} j^2 = \\frac{n(n+1)(2n+1)}{6}$\n将这些公式代入 $T(n)$ 的表达式中：\n$$T(n) = -2 \\left( \\frac{n(n+1)(2n+1)}{6} \\right) + (2n+1) \\left( \\frac{n(n+1)}{2} \\right).$$\n$$T(n) = -\\frac{n(n+1)(2n+1)}{3} + \\frac{n(n+1)(2n+1)}{2}.$$\n提取公因式 $n(n+1)(2n+1)$:\n$$T(n) = n(n+1)(2n+1) \\left( \\frac{1}{2} - \\frac{1}{3} \\right) = n(n+1)(2n+1) \\left( \\frac{3-2}{6} \\right) = \\frac{n(n+1)(2n+1)}{6}.$$\n这就是标量运算总数的闭式表达式。我们可以展开它以查看首项：\n$$T(n) = \\frac{1}{6} (n(2n^2 + 3n + 1)) = \\frac{1}{6} (2n^3 + 3n^2 + n) = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n.$$\n\n**渐近复杂度**\n$T(n)$ 的多项式表达式中的最高阶项决定了渐近复杂度。主导项是 $\\frac{1}{3}n^3$。\n根据大O符号的形式化定义，对于一个函数 $f(n)$ 是 $O(g(n))$，必须存在一个常数 $C>0$ 和一个整数 $n_0$，使得对于所有 $n \\ge n_0$，都有 $|f(n)| \\le C|g(n)|$。\n在我们的例子中，$T(n) = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n$。对于 $n \\ge 1$：\n$$T(n) = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n \\le \\frac{1}{3}n^3 + \\frac{1}{2}n^3 + \\frac{1}{6}n^3 = \\left(\\frac{1}{3} + \\frac{1}{2} + \\frac{1}{6}\\right)n^3 = \\frac{2+3+1}{6}n^3 = n^3.$$\n因此，我们可以选择 $C=1$ 和 $n_0=1$，这满足了定义。该算法的渐近复杂度是 $O(n^3)$。\n问题要求给出 $T(n)$ 的简化解析表达式。",
                "answer": "$$\\boxed{\\frac{n(n+1)(2n+1)}{6}}$$",
                "id": "3534512"
            },
            {
                "introduction": "最后，我们通过一个实际的计算练习来探讨大O符号的局限性。虽然渐近复杂度描述了算法的长期趋势，但它忽略了在实际问题规模下可能起决定性作用的“隐藏常数”。本练习将对两种不同的多项式求根算法进行建模和比较——其中一种具有更优的渐近复杂度，但隐藏常数更大——从而揭示在何种条件下，渐近更快的算法才真正变得更高效。[@problem_id:3534505]",
                "problem": "考虑一个 $n$ 次的首一多项式，记为 $p(x) = x^n + a_{n-1} x^{n-1} + \\cdots + a_0$。本文将从算法复杂度的角度，使用大O表示法比较两种在数值线性代数中计算其根的近似值的算法策略，但会以浮点运算（flops）成本模型明确追踪隐藏常数。\n\n策略A（通过特征值求解友矩阵）：构造与 $p(x)$ 相关的 $n \\times n$ 友矩阵 $C$，并使用专用于上Hessenberg矩阵的Francis隐式双步位移QR算法计算其特征值。一个标准且经过充分检验的事实是，QR算法应用于 $n \\times n$ 的Hessenberg矩阵，在最坏情况下需要 $\\Theta(n^3)$ 次浮点运算来计算所有特征值，并且众所周知，每次隐式双步位移的凸起追踪扫描成本为 $\\Theta(n^2)$ flops。在每次浮点加法或乘法计为一个工作单位的flops模型下，采用以下科学上合理的常数模型：一次扫描大约花费 $12 n^2$ flops，并且需要常数次 $\\Theta(n)$ 的扫描来完成整个过程。因此，策略A的总成本模型为\n$$\nT_{\\mathrm{A}}(n) = c_{\\mathrm{A}} n^3,\n$$\n其中 $c_{\\mathrm{A}} = 12$。\n\n策略B（多点求值与牛顿法优化）：为根选择 $n$ 个初始猜测值，例如在柯西半径圆上；然后应用 $k$ 步牛顿法来优化这些猜测值。每次牛顿迭代需要在所有 $n$ 个点上计算 $p(x)$ 和 $p'(x)$ 的值。多点求值可以使用带有基于快速傅里叶变换（FFT）的多项式算术的子乘积/余数树来执行。一个经过充分检验的事实是，使用FFT进行长度为 $L$ 的多项式乘法需要 $\\Theta(L \\log_2 L)$ 次运算。在flops模型下，假设长度为 $L$ 的单个实数FFT花费 $c_{\\mathrm{FFT}} L \\log_2 L$ flops，其中 $c_{\\mathrm{FFT}} = 5$，并且基于FFT的多项式乘法使用两次正向FFT、一次逆向FFT和一次线性时间的逐点乘法。这给出的近似乘法成本为 $20 L \\log_2 L + 2L$。子乘积/余数树有 $O(\\log_2 n)$ 个层级，每层的总多项式长度为 $O(n)$；为了模拟隐藏常数，通过定义 $n' = 2^{\\lceil \\log_2 n \\rceil}$ 并统一取 $L \\approx n'$，将长度填充到下一个2的幂次，以减少FFT常数因子的变异性。在 $n$ 个点上对 $p(x)$ 进行多点求值的总成本模型为\n$$\nT_{\\mathrm{eval}}(n) \\approx c_{\\mathrm{eval}}\\, n' \\left( \\log_2 n' \\right)^2,\n$$\n其中 $c_{\\mathrm{eval}} = 40$。每次牛顿迭代在 $n$ 个点上同时计算 $p$ 和 $p'$ 会使成本乘以2，而 $k$ 次牛顿迭代会使成本乘以 $k$，从而得到策略B的总成本\n$$\nT_{\\mathrm{B}}(n,k) = 2 k \\, T_{\\mathrm{eval}}(n) \\approx 80 k \\, n' \\left( \\log_2 n' \\right)^2.\n$$\n\n你的任务是实现一个程序，针对提供的一组 $(n,k)$ 对的测试套件，计算比率\n$$\nR(n,k) = \\frac{T_{\\mathrm{A}}(n)}{T_{\\mathrm{B}}(n,k)} = \\frac{c_{\\mathrm{A}} n^3}{80 k \\, n' \\left( \\log_2 n' \\right)^2},\n$$\n其中 $c_{\\mathrm{A}} = 12$ 且 $n' = 2^{\\lceil \\log_2 n \\rceil}$。这个比率量化了在适中的 $n$ 值下，大O渐进行为可能具有的误导性：$R(n,k) > 1$ 表明，在此显式常数模型下，对于给定的 $(n,k)$，策略A（友矩阵特征值）预计比策略B（多点求值加牛顿法）更昂贵，而 $R(n,k)  1$ 则表示相反情况。\n\n使用的基本依据：\n- 大O表示法的定义：对于函数 $f(n)$ 和 $g(n)$，$f(n) = O(g(n))$ 意味着存在正常数 $C$ 和 $n_0$，使得对所有 $n \\ge n_0$ 都有 $f(n) \\le C g(n)$。\n- 数值线性代数中的flops成本模型：将每次浮点加法或乘法计为1个成本单位；变换和FFT的成本通过其上述标准运算次数来计算。\n- 子乘积/余数树多点求值算法和基于FFT的多项式乘法是广为接受的算法构建模块，具有所指出的 $\\Theta(L \\log_2 L)$ 行为。\n\n测试套件：\n- 情况1：$(n,k) = (8,5)$，低次数，较多优化步数。\n- 情况2：$(n,k) = (32,3)$，中等次数，典型优化步数。\n- 情况3：$(n,k) = (100,4)$，非2的幂次的次数，以展示填充效果。\n- 情况4：$(n,k) = (128,2)$，较大的中等次数，较少优化步数。\n- 情况5：$(n,k) = (512,2)$，大次数，此时渐进行为应有利于策略B。\n\n对于每个测试用例，程序必须返回如上定义的单个浮点值 $R(n,k)$。由于输出是flop计数，因此没有物理单位。你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是按指定顺序对应测试用例的比率。\n\n约束和要求：\n- 在计算 $T_{\\mathrm{B}}(n,k)$ 时，通过 $n' = 2^{\\lceil \\log_2 n \\rceil}$ 实现到下一个2的幂次的填充。\n- 使用指定的常数 $c_{\\mathrm{A}} = 12$、$c_{\\mathrm{eval}} = 40$ 和 $c_{\\mathrm{FFT}} = 5$。\n- 在所有提供的测试用例中，通过对整数 $n' \\ge 2$ 使用 $\\log_2$ 来确保对数计算的数值稳定性。",
                "solution": "该问题已经过验证，并被确定为一个有效且定义明确的科学问题。所有必需的常数、公式和测试用例均已提供，其原理植根于数值线性代数和算法复杂度分析的既定概念。\n\n目标是计算两种多项式求根策略的运算成本比率 $R(n,k)$，其中 $n$ 是多项式的次数，$k$ 是第二种策略的优化迭代次数。这个比率用于比较一个渐近较慢的算法（策略A）与一个渐近较快的算法（策略B）在有限、中等 $n$ 值下的实际性能，突显了隐藏常数在大O表示法中的作用。\n\n策略A的成本，基于伴随矩阵的Francis $QR$算法，由下式给出\n$$T_{\\mathrm{A}}(n) = c_{\\mathrm{A}} n^3$$\n常数 $c_{\\mathrm{A}} = 12$。\n\n策略B的成本，基于使用FFT的多点求值和牛顿法，由下式给出\n$$T_{\\mathrm{B}}(n,k) = 80 k \\, n' \\left( \\log_2 n' \\right)^2$$\n其中 $n'$ 是大于或等于 $n$ 的最小的2的幂，形式上定义为\n$$n' = 2^{\\lceil \\log_2 n \\rceil}$$\n\n要计算的比率为\n$$R(n,k) = \\frac{T_{\\mathrm{A}}(n)}{T_{\\mathrm{B}}(n,k)} = \\frac{12 n^3}{80 k \\, n' \\left( \\log_2 n' \\right)^2}$$\n\n我们现在将为提供的五个测试用例中的每一个计算这个比率。\n\n**情况1：$(n,k) = (8,5)$**\n首先，我们确定 $n'$。由于 $n=8$ 是2的幂，$\\log_2 8 = 3$，且 $\\lceil \\log_2 8 \\rceil = 3$。\n$$n' = 2^3 = 8$$\n现在，我们计算成本 $T_{\\mathrm{A}}(8)$ 和 $T_{\\mathrm{B}}(8,5)$。\n$$T_{\\mathrm{A}}(8) = 12 \\times 8^3 = 12 \\times 512 = 6144$$\n$$T_{\\mathrm{B}}(8,5) = 80 \\times 5 \\times 8 \\times (\\log_2 8)^2 = 400 \\times 8 \\times 3^2 = 3200 \\times 9 = 28800$$\n比率为：\n$$R(8,5) = \\frac{6144}{28800} = 0.21333...$$\n由于 $R  1$，对于这个小次数，策略B更昂贵。\n\n**情况2：$(n,k) = (32,3)$**\n首先，我们确定 $n'$。由于 $n=32$ 是2的幂，$\\log_2 32 = 5$，且 $\\lceil \\log_2 32 \\rceil = 5$。\n$$n' = 2^5 = 32$$\n现在，我们计算成本 $T_{\\mathrm{A}}(32)$ 和 $T_{\\mathrm{B}}(32,3)$。\n$$T_{\\mathrmA}}(32) = 12 \\times 32^3 = 12 \\times 32768 = 393216$$\n$$T_{\\mathrm{B}}(32,3) = 80 \\times 3 \\times 32 \\times (\\log_2 32)^2 = 240 \\times 32 \\times 5^2 = 7680 \\times 25 = 192000$$\n比率为：\n$$R(32,3) = \\frac{393216}{192000} = 2.048$$\n由于 $R > 1$，策略A现在比策略B更昂贵。\n\n**情况3：$(n,k) = (100,4)$**\n首先，我们确定 $n'$。对于 $n=100$，我们有 $\\log_2 100 \\approx 6.6438$。因此，$\\lceil \\log_2 100 \\rceil = 7$。\n$$n' = 2^7 = 128$$\n现在，我们计算成本 $T_{\\mathrm{A}}(100)$ 和 $T_{\\mathrm{B}}(100,4)$。\n$$T_{\\mathrm{A}}(100) = 12 \\times 100^3 = 12 \\times 1000000 = 12000000$$\n$$T_{\\mathrm{B}}(100,4) = 80 \\times 4 \\times 128 \\times (\\log_2 128)^2 = 320 \\times 128 \\times 7^2 = 40960 \\times 49 = 2007040$$\n比率为：\n$$R(100,4) = \\frac{12000000}{2007040} \\approx 5.97895408...$$\n策略A的成本几乎是策略B的6倍。FFT从 $n=100$ 到 $n'=128$ 的填充是一个重要因素，但策略A的 $n^3$ 增长占主导地位。\n\n**情况4：$(n,k) = (128,2)$**\n首先，我们确定 $n'$。由于 $n=128$ 是2的幂，$\\log_2 128 = 7$，且 $\\lceil \\log_2 128 \\rceil = 7$。\n$$n' = 2^7 = 128$$\n现在，我们计算成本 $T_{\\mathrm{A}}(128)$ 和 $T_{\\mathrm{B}}(128,2)$。\n$$T_{\\mathrm{A}}(128) = 12 \\times 128^3 = 12 \\times 2097152 = 25165824$$\n$$T_{\\mathrm{B}}(128,2) = 80 \\times 2 \\times 128 \\times (\\log_2 128)^2 = 160 \\times 128 \\times 7^2 = 20480 \\times 49 = 1003520$$\n比率为：\n$$R(128,2) = \\frac{25165824}{1003520} = 25.0775$$\n\n**情况5：$(n,k) = (512,2)$**\n首先，我们确定 $n'$。由于 $n=512$ 是2的幂，$\\log_2 512 = 9$，且 $\\lceil \\log_2 512 \\rceil = 9$。\n$$n' = 2^9 = 512$$\n现在，我们计算成本 $T_{\\mathrm{A}}(512)$ 和 $T_{\\mathrm{B}}(512,2)$。\n$$T_{\\mathrm{A}}(512) = 12 \\times 512^3 = 12 \\times 134217728 = 1610612736$$\n$$T_{\\mathrm{B}}(512,2) = 80 \\times 2 \\times 512 \\times (\\log_2 512)^2 = 160 \\times 512 \\times 9^2 = 81920 \\times 81 = 6635520$$\n比率为：\n$$R(512,2) = \\frac{1610612736}{6635520} \\approx 242.730303...$$\n正如预期的那样，对于大的 $n$，渐近上更优的策略B的优势变得非常显著。\n\n以下程序将为给定的测试套件实现此计算。",
                "answer": "```python\n# 完整的、可运行的 Python 3 代码。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    根据提供的成本模型和测试用例，计算两种多项式求根算法的成本比率 R(n,k)。\n    \"\"\"\n    # 定义问题描述中的测试用例。\n    test_cases = [\n        (8, 5),    # 情况1：低次数\n        (32, 3),   # 情况2：中等次数，2的幂\n        (100, 4),  # 情况3：非2的幂的次数\n        (128, 2),  # 情况4：较大的中等次数\n        (512, 2),  # 情况5：大次数\n    ]\n\n    results = []\n    \n    # 策略A的常数\n    c_A = 12.0\n\n    for n, k in test_cases:\n        # 计算策略A的成本：T_A(n) = c_A * n^3\n        t_a = c_A * (n ** 3)\n\n        # 计算策略B的 n'：n' = 2^ceil(log2(n))\n        # 计算大于或等于n的最小的2的幂。\n        if n == 0:\n            # 尽管测试用例中没有，但处理log2的边界情况。\n            n_prime = 0\n        else:\n            ceil_log2_n = np.ceil(np.log2(n))\n            n_prime = 2**ceil_log2_n\n        \n        # n_prime的以2为底的对数现在是一个整数。\n        log2_n_prime = np.log2(n_prime)\n\n        # 计算策略B的成本：T_B(n,k) = 80 * k * n' * (log2(n'))^2\n        # 检查 n_prime  2 以避免log(1)为零导致除零错误，尽管测试用例可避免此情况。\n        if n_prime  2:\n            t_b = float('inf') # 定义为无限大成本以避免除以零\n        else:\n            t_b = 80.0 * k * n_prime * (log2_n_prime ** 2)\n\n        # 计算比率 R(n,k) = T_A / T_B\n        if t_b == 0:\n            # 处理除以零的情况，尽管根据问题约束这不应发生。\n            ratio = float('inf')\n        else:\n            ratio = t_a / t_b\n\n        results.append(ratio)\n\n    # 以精确要求的格式进行最终打印。\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```",
                "id": "3534505"
            }
        ]
    }