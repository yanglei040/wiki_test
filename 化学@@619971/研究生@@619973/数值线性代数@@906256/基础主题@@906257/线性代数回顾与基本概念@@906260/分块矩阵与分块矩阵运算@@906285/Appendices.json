{
        "hands_on_practices": [
            {
                "introduction": "本练习旨在探讨如何求解系数矩阵已具备简单块结构（特别是块双对角形式）的线性系统。通过推导块式前向替换公式并分析其计算成本，您将对如何利用块结构设计高效的专门算法建立起基础性的理解。该练习是建立块矩阵计算直觉的核心 [@problem_id:3535162]。",
                "problem": "设 $p \\in \\mathbb{N}$，并考虑一个分块下双对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其中 $n = \\sum_{i=1}^{p} n_i$，每个对角块 $A_i \\in \\mathbb{R}^{n_i \\times n_i}$ 均为方阵且非奇异，每个次对角块 $B_{i} \\in \\mathbb{R}^{n_{i+1} \\times n_{i}}$ 对于 $i = 1, \\dots, p-1$ 均为任意的稠密块。矩阵 $A$ 具有如下分块结构\n$$\nA \\;=\\;\n\\begin{pmatrix}\nA_1  0  \\cdots  0 \\\\\nB_1  A_2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  0 \\\\\n0  \\cdots  B_{p-1}  A_p\n\\end{pmatrix},\n$$\n我们希望求解分块线性系统 $A x = b$，其中 $x = \\begin{pmatrix} x_1^{\\top}  \\cdots  x_p^{\\top} \\end{pmatrix}^{\\top}$ 且 $b = \\begin{pmatrix} b_1^{\\top}  \\cdots  b_p^{\\top} \\end{pmatrix}^{\\top}$，并且 $x_i, b_i \\in \\mathbb{R}^{n_i}$。\n\n1. 仅使用分块和矩阵-向量乘法的定义，推导求解 $A x = b$ 的 $x_i$ 的前向替换递推式，而无需构造 $A^{-1}$。\n\n2. 假设每个稠密块 $A_i$ 的求解是通过以下方式进行的：首先对 $A_i$ 进行不带主元选择的高斯消元（LU）分解，然后进行前向替换和后向替换，以将 $A_i^{-1}$ 应用于单个右端项。采用以下计算成本模型：将一次浮点加法或乘法计为一次浮点运算（flop），并忽略除法和比较的成本。从第一性原理出发，推导一个精确表达式，该表达式是计算 $x$ 所需的总浮点运算次数的一个上界，用分块大小 $n_1, \\dots, n_p$ 表示。\n\n3. 考虑一个上分块双对角系统，它具有相同的对角块 $A_i \\in \\mathbb{R}^{n_i \\times n_i}$ 和任意的稠密上对角块 $C_i \\in \\mathbb{R}^{n_i \\times n_{i+1}}$，并推导求解 $A x = b$ 的后向替换递推式。除了所述的分块位置外，不假设任何其他特殊结构。\n\n你的最终答案必须是第2项中要求的浮点运算界的一个单一闭式解析表达式，仅用 $n_1, \\dots, n_p$ 表示。不要在最终答案中提供中间步骤。",
                "solution": "所述问题具有科学依据、良定、客观、完整且一致。它代表了数值线性代数中的一个标准分析。因此，该问题是有效的，并将提供一个解决方案。\n\n该问题由三部分组成。我们将按顺序解决它们。\n\n**第1部分：分块下双对角系统的前向替换递推式**\n\n给定分块线性系统 $A x = b$，其中 $A$ 是一个分块下双对角矩阵，其形式为：\n$$\nA \\;=\\;\n\\begin{pmatrix}\nA_1  0  \\cdots   0 \\\\\nB_1  A_2  0  \\cdots  0 \\\\\n0  B_2  A_3   \\vdots \\\\\n\\vdots   \\ddots  \\ddots  0 \\\\\n0  \\cdots  0  B_{p-1}  A_p\n\\end{pmatrix}\n$$\n向量 $x$ 和 $b$ 与 $A$ 共形分块：\n$$\nx = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_p \\end{pmatrix}, \\quad b = \\begin{pmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_p \\end{pmatrix}\n$$\n其中 $A_i \\in \\mathbb{R}^{n_i \\times n_i}$，$B_i \\in \\mathbb{R}^{n_{i+1} \\times n_i}$，$x_i, b_i \\in \\mathbb{R}^{n_i}$，且 $n = \\sum_{i=1}^{p} n_i$。\n\n通过执行分块矩阵-向量乘法 $A x$，我们得到一个分块方程组：\n\\begin{align*}\nA_1 x_1 = b_1 \\\\\nB_1 x_1 + A_2 x_2 = b_2 \\\\\nB_2 x_2 + A_3 x_3 = b_3 \\\\\n\\vdots \\\\\nB_{i-1} x_{i-1} + A_i x_i = b_i \\\\\n\\vdots \\\\\nB_{p-1} x_{p-1} + A_p x_p = b_p\n\\end{align*}\n\n该系统表现出顺序依赖性，允许使用前向替换过程来求解分块向量 $x_i$。\n\n从第一个方程开始，由于 $A_1$ 是非奇异的，我们可以解出 $x_1$：\n$$ x_1 = A_1^{-1} b_1 $$\n\n利用 $x_1$ 的这个结果，我们可以将其代入第二个方程并解出 $x_2$：\n$$ B_1 x_1 + A_2 x_2 = b_2 \\implies A_2 x_2 = b_2 - B_1 x_1 $$\n由于 $A_2$ 是非奇异的，我们有：\n$$ x_2 = A_2^{-1} (b_2 - B_1 x_1) $$\n\n这种模式会继续下去。假设 $x_1, x_2, \\dots, x_{i-1}$ 已知，我们可以使用第 $i$ 个方程解出 $x_i$：\n$$ B_{i-1} x_{i-1} + A_i x_i = b_i \\implies A_i x_i = b_i - B_{i-1} x_{i-1} $$\n由于对于所有 $i=1, \\dots, p$，$A_i$ 都是非奇异的，我们可以写出 $x_i$ 的一般递推关系：\n$$ x_i = A_i^{-1} (b_i - B_{i-1} x_{i-1}) \\quad \\text{对于 } i=2, \\dots, p $$\n\n完整的前向替换递推式为：\n1.  计算 $x_1 = A_1^{-1} b_1$。\n2.  对于 $i = 2, \\dots, p$，计算 $x_i = A_i^{-1} (b_i - B_{i-1} x_{i-1})$。\n\n**第2部分：浮点运算次数分析**\n\n我们使用第1部分中的递推式，遵循指定的成本模型（加法/乘法 = 1 flop，除法/比较免费），推导求解该系统所需的总浮点运算（flops）次数的表达式。这需要从第一性原理推导组成运算的浮点运算次数。\n\n**基本运算成本：**\n设 $M$ 是一个稠密的 $m \\times m$ 矩阵。\n1.  **$M$ 的 LU 分解（不带主元选择）：** 分解过程分 $m-1$ 步进行。在第 $k$ 步（$k=1, \\dots, m-1$），我们更新一个 $(m-k) \\times (m-k)$ 的子矩阵。$(m-k)^2$ 个元素中的每一个都通过一次乘法和一次减法进行更新（$M_{ij} \\leftarrow M_{ij} - L_{ik} M_{kj}$）。这需要 $2(m-k)^2$ 次浮点运算。计算乘子 $L_{ik}$ 的除法被忽略。总浮点运算次数为：\n    $$ F_{LU}(m) = \\sum_{k=1}^{m-1} 2(m-k)^2 = 2 \\sum_{j=1}^{m-1} j^2 = 2 \\frac{(m-1)m(2m-1)}{6} = \\frac{m(m-1)(2m-1)}{3} = \\frac{2m^3 - 3m^2 + m}{3} $$\n2.  **前向替换 ($Ly=c$)：** 对于单位下三角矩阵 $L$，$y_i = c_i - \\sum_{j=1}^{i-1} L_{ij} y_j$。对于每个 $i=2, \\dots, m$，这涉及 $i-1$ 次乘法和 $i-1$ 次加法/减法。总浮点运算次数为：\n    $$ F_{FS}(m) = \\sum_{i=2}^{m} 2(i-1) = 2 \\sum_{j=1}^{m-1} j = 2 \\frac{(m-1)m}{2} = m(m-1) = m^2-m $$\n3.  **后向替换 ($Ux=y$)：** 对于上三角矩阵 $U$，$x_i = (y_i - \\sum_{j=i+1}^{m} U_{ij} x_j)/U_{ii}$。对于每个 $i=m-1, \\dots, 1$，这涉及 $m-i$ 次乘法和 $m-i$ 次减法。除以 $U_{ii}$ 的操作被忽略。总浮点运算次数为：\n    $$ F_{BS}(m) = \\sum_{i=1}^{m-1} 2(m-i) = 2 \\sum_{j=1}^{m-1} j = m(m-1) = m^2-m $$\n4.  **矩阵-向量乘积 ($z=Qv$)：** 设 $Q$ 是 $m \\times k$ 矩阵，$v$ 是 $k \\times 1$ 向量。每个元素 $z_i = \\sum_{j=1}^{k} Q_{ij} v_j$ 需要 $k$ 次乘法和 $k-1$ 次加法。一个元素的总浮点运算次数是 $2k-1$。对于 $z$ 的所有 $m$ 个元素，总次数为：\n    $$ F_{MV}(m, k) = m(2k-1) $$\n5.  **向量减法 ($u-w$)：** 对于 $u, w \\in \\mathbb{R}^m$，这需要 $m$ 次浮点运算。\n\n**总浮点运算次数推导：**\n前向替换算法包含对 $i=1, \\dots, p$ 的一系列步骤。\n\n对于 $i=1$：我们求解 $A_1 x_1 = b_1$。成本包括 $A_1$ 的 LU 分解，然后是前向和后向替换。\n$$\n\\text{Cost(1)} = F_{LU}(n_1) + F_{FS}(n_1) + F_{BS}(n_1) = \\frac{n_1(n_1-1)(2n_1-1)}{3} + n_1(n_1-1) + n_1(n_1-1)\n$$\n$$\n\\text{Cost(1)} = n_1(n_1-1)\\left(\\frac{2n_1-1}{3} + 2\\right) = \\frac{n_1(n_1-1)(2n_1+5)}{3} = \\frac{2n_1^3+3n_1^2-5n_1}{3}\n$$\n\n对于 $i=2, \\dots, p$：我们计算 $x_i = A_i^{-1}(b_i - B_{i-1}x_{i-1})$。这可以分解为：\n(a) 计算矩阵-向量乘积 $v = B_{i-1} x_{i-1}$。这里，$B_{i-1}$ 是 $n_i \\times n_{i-1}$ 矩阵。\n    成本：$F_{MV}(n_i, n_{i-1}) = n_i(2n_{i-1}-1)$ 次浮点运算。\n(b) 计算更新后的右端项 $\\tilde{b}_i = b_i - v$。这是一个向量减法。\n    成本：$n_i$ 次浮点运算。\n(c) 求解系统 $A_i x_i = \\tilde{b}_i$。其成本在形式上与 $i=1$ 的情况相同。\n    成本：$F_{LU}(n_i) + F_{FS}(n_i) + F_{BS}(n_i) = \\frac{2n_i^3+3n_i^2-5n_i}{3}$ 次浮点运算。\n\n第 $i$ 步（其中 $i \\ge 2$）的总成本是这些成本的总和：\n$$\n\\text{Cost(i)} = \\left(n_i(2n_{i-1}-1) + n_i\\right) + \\frac{2n_i^3+3n_i^2-5n_i}{3} = 2n_i n_{i-1} + \\frac{2n_i^3+3n_i^2-5n_i}{3}\n$$\n\n总浮点运算次数是所有步骤成本的总和：\n$$ F = \\text{Cost(1)} + \\sum_{i=2}^{p} \\text{Cost(i)} $$\n$$ F = \\left(\\frac{2n_1^3+3n_1^2-5n_1}{3}\\right) + \\sum_{i=2}^{p} \\left(2n_i n_{i-1} + \\frac{2n_i^3+3n_i^2-5n_i}{3}\\right) $$\n我们可以将各项分组：\n$$ F = \\sum_{i=1}^{p} \\left(\\frac{2n_i^3+3n_i^2-5n_i}{3}\\right) + \\sum_{i=2}^{p} (2n_i n_{i-1}) $$\n对第二个和式重新索引得到最终表达式：\n$$ F = \\frac{1}{3}\\sum_{i=1}^{p} (2n_i^3 + 3n_i^2 - 5n_i) + 2\\sum_{i=1}^{p-1} n_{i+1} n_i $$\n这是在指定模型和稠密块条件下浮点运算次数的精确表达式，而不是一个上界。\n\n**第3部分：分块上双对角系统的后向替换递推式**\n\n现在考虑一个分块上双对角矩阵 $A$：\n$$\nA \\;=\\;\n\\begin{pmatrix}\nA_1  C_1  0  \\cdots  0 \\\\\n0  A_2  C_2   \\vdots \\\\\n\\vdots   \\ddots  \\ddots  0 \\\\\n0  \\cdots  0  A_{p-1}  C_{p-1} \\\\\n0  \\cdots  \\cdots  0  A_p\n\\end{pmatrix}\n$$\n其中 $C_i \\in \\mathbb{R}^{n_i \\times n_{i+1}}$。系统 $A x = b$ 展开为：\n\\begin{align*}\nA_1 x_1 + C_1 x_2 = b_1 \\\\\nA_2 x_2 + C_2 x_3 = b_2 \\\\\n\\vdots \\\\\nA_i x_i + C_i x_{i+1} = b_i \\\\\n\\vdots \\\\\nA_{p-1} x_{p-1} + C_{p-1} x_p = b_{p-1} \\\\\nA_p x_p = b_p\n\\end{align*}\n\n这种结构提示我们可以采用后向替换过程，从最后一个分块方程开始，向上回代。\n\n从最后一个方程开始，由于 $A_p$ 是非奇异的，我们解出 $x_p$：\n$$ x_p = A_p^{-1} b_p $$\n\n利用 $x_p$ 的这个结果，我们可以将其代入第 $(p-1)$ 个方程以解出 $x_{p-1}$：\n$$ A_{p-1} x_{p-1} + C_{p-1} x_p = b_{p-1} \\implies A_{p-1} x_{p-1} = b_{p-1} - C_{p-1} x_p $$\n由于 $A_{p-1}$ 是非奇异的，我们有：\n$$ x_{p-1} = A_{p-1}^{-1} (b_{p-1} - C_{p-1} x_p) $$\n\n这揭示了一般模式。假设 $x_{p}, x_{p-1}, \\dots, x_{i+1}$ 已知，我们可以用第 $i$ 个方程解出 $x_i$：\n$$ A_i x_i + C_i x_{i+1} = b_i \\implies A_i x_i = b_i - C_i x_{i+1} $$\n由于 $A_i$ 是非奇异的，一般递推式为：\n$$ x_i = A_i^{-1} (b_i - C_i x_{i+1}) \\quad \\text{对于 } i=p-1, \\dots, 1 $$\n\n完整的后向替换递推式为：\n1.  计算 $x_p = A_p^{-1} b_p$。\n2.  对于 $i = p-1$ 递减至 $1$，计算 $x_i = A_i^{-1} (b_i - C_i x_{i+1})$。",
                "answer": "$$\n\\boxed{\\frac{1}{3}\\sum_{i=1}^{p} (2n_i^3 + 3n_i^2 - 5n_i) + 2\\sum_{i=1}^{p-1} n_{i+1} n_i}\n$$",
                "id": "3535162"
            },
            {
                "introduction": "许多来自科学与工程领域的大规模问题会产生看似无明显结构的稀疏线性系统。本练习将展示一种强大的技术，它通过将矩阵的稀疏模式与其底层的有向图相关联来揭示其隐藏的结构。您将学习如何通过置换将一个矩阵变换为块上三角形式，这一过程能够极大地降低求解系统的计算成本 [@problem_id:3535135]。",
                "problem": "设 $A \\in \\mathbb{R}^{6 \\times 6}$ 是一个依赖于小参数 $\\varepsilon  0$ 的稀疏矩阵，\n$$\nA \\;=\\;\n\\begin{pmatrix}\n4  \\varepsilon  1  0  2\\varepsilon  0 \\\\\n0  5  0  1  0  0 \\\\\n1  0  3  \\varepsilon  0  3\\varepsilon \\\\\n0  1  0  6  2  0 \\\\\n0  0  0  2  7  3 \\\\\n0  0  0  0  3  8\n\\end{pmatrix}.\n$$\n该矩阵通过以下规则编码一个有向图：当且仅当 $A_{ij} \\neq 0$ 时，存在一条有向边 $i \\to j$。考虑将此有向图分解为强连通分量，并将其凝聚成一个有向无环图（DAG），该图是通过将每个强连通分量收缩为单个顶点，并保留由原图的边所导出的分量之间的边而得到的。\n\n- 仅使用矩阵的有向图、强连通分量和图凝聚产生的有向无环图的定义，推导在何种稀疏模式条件下存在一个置换矩阵 $P$，使得 $P A P^{\\top}$ 是分块上三角矩阵。通过凝聚DAG来解释这些条件。\n\n- 对于上述特定矩阵 $A$，确定其有向图的强连通分量，构造一个显式的置换矩阵 $P$ 使得 $P A P^{\\top}$ 成为分块上三角矩阵，并展示其分块结构\n$$\nP A P^{\\top} \\;=\\;\n\\begin{pmatrix}\nB  E \\\\\n0  C\n\\end{pmatrix},\n$$\n其中 $B \\in \\mathbb{R}^{2 \\times 2}$，$C \\in \\mathbb{R}^{4 \\times 4}$，以及 $E \\in \\mathbb{R}^{2 \\times 4}$。\n\n- 在数值线性代数中，人们常比较不同分解策略的运算量。考虑分解 $A$ 的两种策略：对完整的 $6 \\times 6$ 矩阵进行带部分主元的稠密高斯消去法，以及一种分块策略，该策略对于一个耦合量级至多为 $\\varepsilon$ 的近可约矩阵，对对角块 $B$ 和 $C$ 进行独立的稠密分解，并在一阶近似下忽略严格上三角块 $E$。使用经过验证的稠密LU分解的浮点运算次数（flop）计数公式，计算在 $\\varepsilon \\to 0$ 极限下的首项浮点运算次数缩减因子 $R$，定义为\n$$\nR \\;=\\; \\frac{\\text{分块对角分解 } B \\text{ 和 } C \\text{ 的浮点运算次数}}{\\text{对 } A \\text{ 进行稠密LU分解的浮点运算次数}}。\n$$\n将 $R$ 表示为一个精确的数值。无需四舍五入。",
                "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n-   一个依赖于小参数 $\\varepsilon  0$ 的稀疏矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n4  \\varepsilon  1  0  2\\varepsilon  0 \\\\\n0  5  0  1  0  0 \\\\\n1  0  3  \\varepsilon  0  3\\varepsilon \\\\\n0  1  0  6  2  0 \\\\\n0  0  0  2  7  3 \\\\\n0  0  0  0  3  8\n\\end{pmatrix}.\n$$\n-   有向图构造规则：当且仅当 $A_{ij} \\neq 0$ 时，存在一条边 $i \\to j$。\n-   待用概念：强连通分量（SCCs），凝聚成有向无环图（DAG）。\n-   任务1：推导在何种稀疏模式条件下存在一个置换矩阵 $P$，使得 $P A P^{\\top}$ 是分块上三角矩阵，并通过凝聚DAG来解释这些条件。\n-   任务2：对于给定矩阵 $A$，确定其强连通分量，构造一个显式的置换矩阵 $P$，并展示其分块结构 $P A P^{\\top} = \\begin{pmatrix} B  E \\\\ 0  C \\end{pmatrix}$，其中 $B \\in \\mathbb{R}^{2 \\times 2}$，$C \\in \\mathbb{R}^{4 \\times 4}$，$E \\in \\mathbb{R}^{2 \\times 4}$。\n-   任务3：计算首项浮点运算次数缩减因子 $R$，定义为对角分块 $B$ 和 $C$ 的分块对角分解的浮点运算次数与对完整矩阵 $A$ 进行稠密LU分解的浮点运算次数之比。$n \\times n$ 矩阵的稠密LU分解的浮点运算次数公式取为 $\\frac{2}{3}n^3$。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学性**：该问题基于数值线性代数和图论中公认的原理，包括矩阵-图对偶性、强连通性和LU分解等算法的复杂度分析。所有概念都是标准的、科学合理的。\n-   **良置性**：问题陈述清晰，结构完整。每个任务都要求一个具体的、可推导的结果。所提供的数据足以完成所有任务。\n-   **客观性**：问题以精确、形式化的数学语言陈述，没有任何主观性或歧义。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将提供完整解答。\n\n### 解答\n\n解答分为三部分，对应问题陈述中的三个任务。\n\n**第1部分：分块三角化的条件**\n\n如果存在一个置换矩阵 $P$ 使得 $P M P^{\\top}$ 是分块上三角矩阵，则称方阵 $M \\in \\mathbb{R}^{n \\times n}$ 是**可约的**。如果不存在这样的置换，则该矩阵是**不可约的**。\n\n理解可约性的关键在于与矩阵关联的有向图 $G(M)$。$G(M)$ 的顶点是整数 $\\{1, 2, \\dots, n\\}$，当且仅当矩阵项 $M_{ij} \\neq 0$ 时，存在一条从顶点 $i$ 到顶点 $j$ 的有向边（记为 $i \\to j$）。非零项的集合定义了矩阵的**稀疏模式**。\n\n数值线性代数中的一个基本定理指出，一个矩阵 $M$ 是不可约的，当且仅当其关联的有向图 $G(M)$ 是**强连通的**。一个有向图是强连通的，如果对于每一对有序顶点 $(i, j)$，都存在一条从 $i$ 到 $j$ 的有向边路径。\n\n因此，一个矩阵 $M$ 是可约的，当且仅当其有向图 $G(M)$ **不是**强连通的。所以，一个矩阵的稀疏模式能使其通过置换变为分块上三角形式的充要条件是，由其非零项定义的有向图不是强连通的。\n\n通过凝聚DAG对此条件的解释如下。如果一个图 $G(M)$ 不是强连通的，其顶点集可以被唯一地划分为一组强连通分量（SCCs），记为 $\\{S_1, S_2, \\dots, S_k\\}$，其中 $k  1$。**凝聚图**是通过将每个SCC $S_i$ 收缩为单个超顶点而形成的。当且仅当在原图 $G(M)$ 中存在从 $S_i$ 中的某个顶点到 $S_j$ 中的某个顶点的边时，超顶点 $S_i$ 和 $S_j$ 之间才存在有向边。根据构造，这个凝聚图是一个有向无环图（DAG）。\n\n由于凝聚图是一个DAG且有多个顶点（因为 $k1$），其顶点可以进行拓扑排序。拓扑排序提供了超顶点的一种排序，例如 $(S_{\\pi(1)}, S_{\\pi(2)}, \\dots, S_{\\pi(k)})$，使得如果存在从 $S_{\\pi(i)}$ 到 $S_{\\pi(j)}$ 的边，则 $i  j$。\n\n将 $M$ 转换为分块上三角形式的置换矩阵 $P$ 是通过根据此拓扑排序重新排列基向量（从而也是 $M$ 的行和列）来构造的。具体来说，将属于 $S_{\\pi(1)}$ 的 $G(M)$ 的顶点分组，然后是属于 $S_{\\pi(2)}$ 的顶点，依此类推。得到的置换矩阵 $P M P^{\\top}$ 将在其严格下三角部分有零块，因为拓扑排序确保了没有从后面的分量 $S_{\\pi(j)}$ 到前面的分量 $S_{\\pi(i)}$ 的边（其中 $ji$）。\n\n**第2部分：对特定矩阵 $A$ 的分析**\n\n首先，我们确定给定矩阵 $A$ 的有向图 $G(A)$。顶点为 $\\{1, 2, 3, 4, 5, 6\\}$。当 $\\varepsilon  0$ 时，由非零项 $A_{ij}$ 决定的边是：\n$1 \\to 1, 1 \\to 2, 1 \\to 3, 1 \\to 5$\n$2 \\to 2, 2 \\to 4$\n$3 \\to 1, 3 \\to 3, 3 \\to 4, 3 \\to 6$\n$4 \\to 2, 4 \\to 4, 4 \\to 5$\n$5 \\to 4, 5 \\to 5, 5 \\to 6$\n$6 \\to 5, 6 \\to 6$\n\n接下来，我们寻找强连通分量（SCCs）。\n- 存在从顶点1到3的路径（$1 \\to 3$ 因为 $A_{13}=1$）和从3到1的路径（$3 \\to 1$ 因为 $A_{31}=1$）。因此，顶点 $\\{1, 3\\}$ 在同一个SCC中。不存在从 $\\{1, 3\\}$ 到任何其他顶点再返回的路径。例如，$1 \\to 2$，但不存在从任何其他顶点回到1或3的路径。所以，一个SCC是 $S_1 = \\{1, 3\\}$。\n- 对于剩下的顶点 $\\{2, 4, 5, 6\\}$：\n    - $2 \\to 4$ ($A_{24}=1$) 和 $4 \\to 2$ ($A_{42}=1$)，所以 $2$ 和 $4$ 相互可达。\n    - $4 \\to 5$ ($A_{45}=2$) 和 $5 \\to 4$ ($A_{54}=2$)，所以 $4$ 和 $5$ 相互可达。\n    - $5 \\to 6$ ($A_{56}=3$) 和 $6 \\to 5$ ($A_{65}=3$)，所以 $5$ 和 $6$ 相互可达。\n- 根据传递性，$\\{2, 4, 5, 6\\}$ 中的所有顶点都是相互可达的。因此，第二个SCC是 $S_2 = \\{2, 4, 5, 6\\}$。\n强连通分量是 $S_1 = \\{1, 3\\}$ 和 $S_2 = \\{2, 4, 5, 6\\}$。\n\n现在，我们构造凝聚DAG。存在从 $S_1$ 到 $S_2$ 的边（例如，来自 $A_{12}=\\varepsilon$ 的 $1 \\to 2$）。不存在从 $S_2$ 到 $S_1$ 的边。凝聚DAG是 $S_1 \\to S_2$。\n\n凝聚DAG的一个拓扑排序是 $(S_1, S_2)$。为了得到分块上三角形式，我们重新排序顶点，先把 $S_1$ 中的顶点分组，然后是 $S_2$ 中的。一个有效的新排序是 $(1, 3, 2, 4, 5, 6)$。\n将标准基 $(e_1, e_2, e_3, e_4, e_5, e_6)$ 映射到新基 $(e_1, e_3, e_2, e_4, e_5, e_6)$ 的置换是通过一个置换矩阵 $P$ 实现的，该矩阵的行是新排序的基向量。具体来说，$P$ 的第一行是 $e_1^\\top$，第二行是 $e_3^\\top$，第三行是 $e_2^\\top$，以此类推。\n$$\nP = \\begin{pmatrix}\n1  0  0  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  1  0  0  0  0 \\\\\n0  0  0  1  0  0 \\\\\n0  0  0  0  1  0 \\\\\n0  0  0  0  0  1\n\\end{pmatrix}\n$$\n这个矩阵交换了第2行和第3行。执行相似变换 $P A P^{\\top}$（即交换第2行和第3行，然后交换第2列和第3列）得到：\n$$\nP A P^{\\top} \\;=\\; \\begin{pmatrix}\n4  1  \\varepsilon  0  2\\varepsilon  0 \\\\\n1  3  0  \\varepsilon  0  3\\varepsilon \\\\\n0  0  5  1  0  0 \\\\\n0  0  1  6  2  0 \\\\\n0  0  0  2  7  3 \\\\\n0  0  0  0  3  8\n\\end{pmatrix}\n$$\n该矩阵具有所需的分块上三角形式：\n$$\nP A P^{\\top} \\;=\\;\n\\begin{pmatrix}\nB  E \\\\\n0  C\n\\end{pmatrix}\n$$\n其中各分块为：\n$B = \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix} \\in \\mathbb{R}^{2 \\times 2}$\n$C = \\begin{pmatrix} 5  1  0  0 \\\\ 1  6  2  0 \\\\ 0  2  7  3 \\\\ 0  0  3  8 \\end{pmatrix} \\in \\mathbb{R}^{4 \\times 4}$\n$E = \\begin{pmatrix} \\varepsilon  0  2\\varepsilon  0 \\\\ 0  \\varepsilon  0  3\\varepsilon \\end{pmatrix} \\in \\mathbb{R}^{2 \\times 4}$\n左下角的 $4 \\times 2$ 块是零矩阵，这证实了分块上三角结构。\n\n**第3部分：浮点运算次数的缩减**\n\n一个 $n \\times n$ 稠密矩阵的LU分解所需的浮点运算次数（flops）由主项 $\\frac{2}{3}n^3$ 决定。\n\n对于第一种策略，即对完整的 $6 \\times 6$ 矩阵 $A$ 进行稠密LU分解，浮点运算次数为：\n$$\n\\text{flops}_A = \\frac{2}{3} \\times 6^3 = \\frac{2}{3} \\times 216 = 2 \\times 72 = 144\n$$\n\n对于第二种策略，即分块对角分解，我们对对角块 $B$ 和 $C$ 分别进行LU分解。\n- 分块 $B$ 是一个 $2 \\times 2$ 矩阵。其分解的浮点运算次数为：\n$$\n\\text{flops}_B = \\frac{2}{3} \\times 2^3 = \\frac{2}{3} \\times 8 = \\frac{16}{3}\n$$\n- 分块 $C$ 是一个 $4 \\times 4$ 矩阵。其分解的浮点运算次数为：\n$$\n\\text{flops}_C = \\frac{2}{3} \\times 4^3 = \\frac{2}{3} \\times 64 = \\frac{128}{3}\n$$\n分块策略的总浮点运算次数是每个分块的浮点运算次数之和：\n$$\n\\text{flops}_{\\text{block}} = \\text{flops}_B + \\text{flops}_C = \\frac{16}{3} + \\frac{128}{3} = \\frac{144}{3} = 48\n$$\n\n缩减因子 $R$ 是分块分解的浮点运算次数与全矩阵分解的浮点运算次数之比：\n$$\nR = \\frac{\\text{flops}_{\\text{block}}}{\\text{flops}_A} = \\frac{48}{144} = \\frac{1}{3}\n$$",
                "answer": "$$\\boxed{\\frac{1}{3}}$$",
                "id": "3535135"
            },
            {
                "introduction": "除了直接求解器，块操作在旨在提升精度与效率的高级迭代方法中也扮演着核心角色。本练习要求您实现一个块迭代精化方案，该方案能同时处理多个右端项，并利用奇异值分解 (SVD) 来压缩块残差。这种方法不仅减少了计算量，还提升了数值稳健性，是高性能计算中使用的前沿技术之一 [@problem_id:3535155]。",
                "problem": "考虑块线性系统 $A X = B$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$，$m \\geq 1$ 表示多个右端项。迭代求精是一种通过重复计算和校正块残差 $R = B - A X$ 来改进近似解 $X$ 的过程。在此问题中，您将设计一种块迭代求精方法，该方法同时作用于所有右端项，并利用残差中的块低秩结构来降低计算成本和提高数值鲁棒性。\n\n您必须使用的基础知识包括：块矩阵及其运算的定义；块残差 $R = B - A X$ 的定义；奇异值分解 (Singular Value Decomposition, SVD) 的概念，其定义如下。对于任何矩阵 $R \\in \\mathbb{R}^{n \\times m}$，存在正交矩阵 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$，以及一个对角线元素为非负（奇异值）的对角矩阵 $S \\in \\mathbb{R}^{n \\times m}$，使得 $R = U S V^\\top$。您还可以使用一个经过充分验证的事实：通过预先计算的分解（如 LU 分解 (lower-upper decomposition)）求解线性系统比在每次迭代中重新分解更有效。\n\n您的任务是：\n- 从第一性原理出发，推导如何从块残差的低秩分解中计算块校正，从而将对所有右端项的计算简化为对 $A$ 的少数求解。\n- 解释当残差具有快速衰减的奇异值时，压缩残差为何能提高鲁棒性并降低成本。\n- 实现一个完整的算法，该算法：\n  1. 使用较低的数值精度，一次性计算并存储 $A$ 的分解，并在残差上以更高精度执行迭代求精。\n  2. 在每次迭代中，通过秩揭示分解压缩块残差，并基于压缩表示应用校正。\n  3. 使用基于后向误差的停止准则。对于 $X$ 的第 $j$ 列 $x_j$ 和 $B$ 的第 $j$ 列 $b_j$，后向误差定义为 $\\eta_j = \\dfrac{\\lVert r_j \\rVert_2}{\\lVert A \\rVert_2 \\lVert x_j \\rVert_2 + \\lVert b_j \\rVert_2}$，其中 $\\lVert A \\rVert_2$ 是谱范数，$r_j = b_j - A x_j$。当 $\\max_j \\eta_j$ 低于预设容差时，算法应停止。\n- 确保所有块运算在数学上一致且在数值上是良态的。\n\n不涉及物理单位或角度单位。所有输出必须是纯数值的。\n\n您的程序必须实现上述算法并运行以下测试套件。为保证可复现性，请使用指定的随机种子。在每种情况下，计算并报告算法终止后的最终最大后向误差 $\\max_j \\eta_j$。\n\n测试套件：\n- 案例 1（理想情况，低秩右端项和良态 $A$）：\n  - 维度：$n = 50$，$m = 20$。\n  - 矩阵 $A$：设 $M \\in \\mathbb{R}^{n \\times n}$ 的元素来自种子为 $1$ 的标准正态分布，定义 $A = M^\\top M + n I$，其中 $I$ 是单位矩阵。\n  - 块右端项 $B$：设 $Q \\in \\mathbb{R}^{n \\times n}$ 是种子为 $2$ 的标准正态随机矩阵的 QR 分解得到的 Q 因子。设 $U_b \\in \\mathbb{R}^{n \\times r}$ 是 $Q$ 的前 $r = 3$ 列。设 $V \\in \\mathbb{R}^{m \\times r}$ 的元素来自种子为 $3$ 的标准正态分布。定义 $B = U_b V^\\top$。\n  - 算法参数：秩上限 $k_{\\max} = 5$，SVD 相对截断阈值 $\\tau = 10^{-12}$，停止容差 $\\varepsilon = 10^{-14}$，最大迭代次数 $N_{\\text{it}} = 5$。\n\n- 案例 2（边界情况，满秩右端项和中等条件数的非对称 $A$）：\n  - 维度：$n = 60$，$m = 60$。\n  - 矩阵 $A$：通过对种子分别为 $7$ 和 $8$ 的标准正态随机矩阵进行 QR 分解，生成正交矩阵 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{n \\times n}$。设奇异值 $s_i$ 在 $[0.05, 30]$ 区间内线性分布，其中 $i = 1, \\dots, n$。定义 $A = U \\operatorname{diag}(s) V^\\top$。\n  - 块右端项 $B$：元素来自种子为 $4$ 的标准正态分布。\n  - 算法参数：秩上限 $k_{\\max} = 15$，SVD 相对截断阈值 $\\tau = 10^{-2}$，停止容差 $\\varepsilon = 10^{-12}$，最大迭代次数 $N_{\\text{it}} = 8$。\n\n- 案例 3（边缘情况，病态 $A$ 和低秩右端项）：\n  - 维度：$n = 20$，$m = 10$。\n  - 矩阵 $A$：Hilbert 矩阵，$A_{i j} = \\dfrac{1}{i + j - 1}$，其中 $i, j = 1, \\dots, n$。\n  - 块右端项 $B$：设 $Q \\in \\mathbb{R}^{n \\times n}$ 是种子为 $5$ 的标准正态随机矩阵的 QR 分解得到的 Q 因子。设 $U_b \\in \\mathbb{R}^{n \\times r}$ 是 $Q$ 的前 $r = 2$ 列。设 $V \\in \\mathbb{R}^{m \\times r}$ 的元素来自种子为 $6$ 的标准正态分布。定义 $B = U_b V^\\top$。\n  - 算法参数：秩上限 $k_{\\max} = 3$，SVD 相对截断阈值 $\\tau = 10^{-6}$，停止容差 $\\varepsilon = 10^{-8}$，最大迭代次数 $N_{\\text{it}} = 20$。\n\n算法要求：\n- 以较低精度计算并存储 $A$ 的一个分解，并用它在整个求精过程中执行求解。以较高精度计算残差和秩揭示分解。\n- 在每次迭代中，通过秩揭示分解压缩块残差，并以一种将对 $A$ 的求解次数从 $m$ 减少到至多为截断秩 $k$ 的方式更新近似解。\n- 使用上述定义的后向误差准则作为停止条件。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是按案例 1、案例 2、案例 3 顺序排列的一个测试案例的最终最大后向误差（例如，“[result_case1,result_case2,result_case3]”）。",
                "solution": "我们考虑块线性系统 $A X = B$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$。块残差定义为 $R = B - A X \\in \\mathbb{R}^{n \\times m}$。迭代求精通过辅助系统 $A \\Delta X = R$ 从残差计算校正量 $\\Delta X$，并更新 $X \\leftarrow X + \\Delta X$。我们提出一种块算法，该算法通过低秩分解压缩残差以减少求解次数，利用了不同右端项之间的耦合关系。\n\n原理与推导：\n1. 对于每次迭代，我们从基本定义 $R = B - A X$ 开始。校正问题是 $A \\Delta X = R$。如果直接求解所有 $m$ 个右端项，我们将在每次迭代中求解一个具有 $m$ 列的系统。\n\n2. 为降低成本，我们使用残差的秩揭示分解。一个有原则的选择是奇异值分解 (SVD)，对于 $R \\in \\mathbb{R}^{n \\times m}$，其结果为 $R = U S V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$S \\in \\mathbb{R}^{n \\times m}$ 是具有非负奇异值的对角矩阵。我们用 $k$ 表示根据某个准则通过截断选择的数值秩；也就是说，我们写出一个近似 $R \\approx U_k S_k V_k^\\top$，其中 $U_k \\in \\mathbb{R}^{n \\times k}$ 具有正交列，$S_k \\in \\mathbb{R}^{k \\times k}$ 是对角矩阵，$V_k \\in \\mathbb{R}^{m \\times k}$ 具有正交列。这利用了一个经过充分验证的事实：截断小的奇异值可以在谱范数或 Frobenius 范数下产生接近最优的低秩近似。\n\n3. 将此压缩表示代入校正问题 $A \\Delta X = R$ 中，得到近似校正模型 $A \\Delta X \\approx U_k S_k V_k^\\top$。我们使用块运算来避免 $m$ 次求解。如果我们通过含 $k$ 个右端项的系统 $A Y = U_k$ 定义 $Y \\in \\mathbb{R}^{n \\times k}$，则校正量可以通过块乘法 $\\Delta X \\approx Y S_k V_k^\\top$ 组合而成。这是因为将 $A Y = U_k$ 代入 $A \\Delta X \\approx U_k S_k V_k^\\top$ 得到 $A \\Delta X \\approx A Y S_k V_k^\\top$，因此 $\\Delta X \\approx Y S_k V_k^\\top$。\n\n4. 计算上的好处源于求解 $A Y = U_k$ 仅需 $k$ 次求解，并且如果由于残差的低秩结构导致 $k \\ll m$，我们就能降低每次迭代的成本，同时仍然能同时校正所有 $m$ 个右端项。鲁棒性的好处来自 SVD 的稳定性以及对小的奇异分量的抑制，这些分量在直接应用时可能会放大舍入误差。\n\n5. 迭代求精通常使用混合精度来改进在较低精度下计算的近似解，方法是使用更高精度的残差进行求精。我们采用较低精度的 $A$ 分解来执行求解，并以较高精度计算残差和 SVD。这符合数值线性代数中经过充分验证的策略，即较高精度的残差计算可以校正较低精度求解的误差。\n\n6. 我们使用基于后向误差的停止准则。对于每一列 $j$，$r_j = b_j - A x_j$。全局后向误差为 $\\max_j \\eta_j$，其中\n   $$\\eta_j = \\frac{\\lVert r_j \\rVert_2}{\\lVert A \\rVert_2 \\lVert x_j \\rVert_2 + \\lVert b_j \\rVert_2}.$$\n   这里 $\\lVert A \\rVert_2$ 是谱范数，我们将其计算为 $A$ 的最大奇异值。该准则确保计算出的解是一个邻近问题的精确解，该邻近问题在块意义上具有小的相对扰动。\n\n算法设计：\n- 以较低精度预先计算 $A$ 的 LU 分解 (lower-upper (LU) factorization)，然后对所有求解使用此分解以避免重复分解。其合理性在于 LU 分解能够对多个右端项进行高效的三角求解。\n- 通过较低精度的分解求解 $A X^{(0)} \\approx B$ 来初始化 $X$。\n- 对于迭代 $t = 0, 1, \\dots$，计算高精度残差 $R^{(t)} = B - A X^{(t)}$。\n- 计算 $R^{(t)}$ 的 SVD，并基于奇异值的相对阈值通过截断选择一个数值秩 $k \\leq k_{\\max}$。这将得到 $U_k$、$S_k$、$V_k$。\n- 使用较低精度的分解求解 $A Y^{(t)} = U_k$。通过块乘法组合成 $\\Delta X^{(t)} = Y^{(t)} S_k V_k^\\top$。\n- 更新 $X^{(t+1)} = X^{(t)} + \\Delta X^{(t)}$。\n- 评估后向误差，当 $\\max_j \\eta_j \\leq \\varepsilon$ 或迭代次数达到 $N_{\\text{it}}$ 时停止。\n\n数值考量：\n- 秩截断阈值应是相对的，例如保留奇异值 $\\sigma_i$ 使得 $\\sigma_i \\geq \\tau \\sigma_1$，其中 $\\sigma_1$ 是残差的最大奇异值。这可以防止丢弃重要的子空间分量。\n- 如果残差在数值上为零，SVD 将显示所有奇异值都接近于零，并且后向误差此时已低于容差。\n- 使用一次性计算的 LU 分解，通过块三角求解可以高效地解决具有多个列 $U_k$ 的 $A Y = U_k$ 问题。\n- 谱范数 $\\lVert A \\rVert_2$ 通过对 $A$ 进行一次奇异值分解来计算，以避免重复计算。\n\n测试套件实现：\n- 案例 1 构建了一个具有良好条件数的对称正定矩阵 $A$ 和一个秩为 3 的块结构 $B$，预期会快速收敛和实现有效的低秩压缩。\n- 案例 2 构建了一个具有受控奇异值的非对称矩阵 $A$ 和一个完全随机的 $B$；预期残差的奇异值会适度衰减，而激进的截断则测试了边界情况。\n- 案例 3 使用了病态的 Hilbert 矩阵 $A$ 和秩为 2 的 $B$。较低精度的分解与较高精度的残差相结合，检验了算法的鲁棒性，并且求精迭代试图在存在病态条件的情况下减小后向误差。\n\n程序实现了以上算法，计算了每种情况下的最终最大后向误差，并以指定格式在单行中打印出这三个值。所有计算都是无单位的纯数值计算。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve, qr\n\ndef spectral_norm(A: np.ndarray) - float:\n    # Compute spectral norm as largest singular value\n    # Use full SVD for robustness; for moderate n this is fine.\n    s = np.linalg.svd(A, compute_uv=False)\n    return float(s[0])\n\ndef build_case1():\n    # Case 1: n=50, m=20, SPD A, low-rank B\n    n, m = 50, 20\n    rng_M = np.random.default_rng(1)\n    M = rng_M.standard_normal((n, n))\n    A = M.T @ M + n * np.eye(n, dtype=np.float64)\n\n    rng_Q = np.random.default_rng(2)\n    Q_rand = rng_Q.standard_normal((n, n))\n    Q, _ = qr(Q_rand, mode='economic')\n    r = 3\n    U_b = Q[:, :r]\n\n    rng_V = np.random.default_rng(3)\n    V = rng_V.standard_normal((m, r))\n    B = U_b @ V.T\n\n    params = {\n        \"rank_cap\": 5,\n        \"svd_tol\": 1e-12,\n        \"tol\": 1e-14,\n        \"max_iter\": 5,\n    }\n    return A, B, params\n\ndef build_case2():\n    # Case 2: n=60, m=60, general A with controlled singular values, full-rank B\n    n, m = 60, 60\n\n    rng_U = np.random.default_rng(7)\n    U_rand = rng_U.standard_normal((n, n))\n    U_q, _ = qr(U_rand, mode='economic')\n\n    rng_V = np.random.default_rng(8)\n    V_rand = rng_V.standard_normal((n, n))\n    V_q, _ = qr(V_rand, mode='economic')\n\n    # Singular values linearly spaced between 0.05 and 30\n    svals = np.linspace(0.05, 30.0, n)\n    A = (U_q @ (np.diag(svals) @ V_q.T)).astype(np.float64)\n\n    rng_B = np.random.default_rng(4)\n    B = rng_B.standard_normal((n, m))\n\n    params = {\n        \"rank_cap\": 15,\n        \"svd_tol\": 1e-2,\n        \"tol\": 1e-12,\n        \"max_iter\": 8,\n    }\n    return A, B, params\n\ndef build_case3():\n    # Case 3: n=20, m=10, Hilbert A, low-rank B\n    n, m = 20, 10\n    # Hilbert matrix\n    i = np.arange(1, n + 1, dtype=np.float64)\n    j = np.arange(1, n + 1, dtype=np.float64)\n    A = 1.0 / (i[:, None] + j[None, :] - 1.0)\n\n    rng_Q = np.random.default_rng(5)\n    Q_rand = rng_Q.standard_normal((n, n))\n    Q, _ = qr(Q_rand, mode='economic')\n    r = 2\n    U_b = Q[:, :r]\n\n    rng_V = np.random.default_rng(6)\n    V = rng_V.standard_normal((m, r))\n    B = U_b @ V.T\n\n    params = {\n        \"rank_cap\": 3,\n        \"svd_tol\": 1e-6,\n        \"tol\": 1e-8,\n        \"max_iter\": 20,\n    }\n    return A, B, params\n\ndef block_iterative_refinement(A: np.ndarray,\n                               B: np.ndarray,\n                               rank_cap: int,\n                               svd_tol: float,\n                               tol: float,\n                               max_iter: int) - float:\n    \"\"\"\n    Perform block iterative refinement with low-rank residual compression.\n\n    A: (n,n) float64\n    B: (n,m) float64\n    Returns the final maximum backward error across RHSs.\n    \"\"\"\n    n, m = B.shape\n    # Lower precision factorization\n    A32 = A.astype(np.float32)\n    lu, piv = lu_factor(A32)\n\n    # Initial solve in lower precision, cast to float64 for accumulation\n    X = lu_solve((lu, piv), B.astype(np.float32)).astype(np.float64)\n\n    # Precompute spectral norm for backward error\n    normA2 = spectral_norm(A)\n\n    # Iterative refinement\n    for it in range(max_iter):\n        R = B - A @ X  # residual in double precision\n\n        # Backward error computation\n        # Compute columnwise norms\n        r_norms = np.linalg.norm(R, axis=0)\n        x_norms = np.linalg.norm(X, axis=0)\n        b_norms = np.linalg.norm(B, axis=0)\n        # Avoid division by zero: if denominator is zero, set error as norm(r)\n        denom = normA2 * x_norms + b_norms\n        with np.errstate(divide='ignore', invalid='ignore'):\n            eta = np.where(denom  0, r_norms / denom, r_norms)\n        max_eta = float(np.max(eta))\n        if max_eta = tol:\n            break\n\n        # SVD of residual\n        # Use economical SVD to get U (n x min(n,m)), S (min(n,m)), Vh (min(n,m) x m)\n        U, S, Vh = np.linalg.svd(R, full_matrices=False)\n        # Determine truncated rank k: keep singular values above relative threshold, cap by rank_cap\n        if S.size == 0 or S[0] == 0.0:\n            # Residual is (near) zero; no correction needed\n            break\n        k_rel = int(np.sum(S = svd_tol * S[0]))\n        k = max(1, min(rank_cap, k_rel))\n        U_k = U[:, :k]\n        S_k = S[:k]\n        Vh_k = Vh[:k, :]\n\n        # Solve A Y = U_k with lower precision factorization\n        Y = lu_solve((lu, piv), U_k.astype(np.float32)).astype(np.float64)\n        # Assemble correction: ΔX = Y S_k Vh_k\n        # Compute W = S_k[:,None] * Vh_k (k x m), then ΔX = Y (n x k) @ W (k x m)\n        W = (S_k[:, None] * Vh_k)\n        dX = Y @ W\n\n        # Update\n        X += dX\n\n    # Final backward error\n    R = B - A @ X\n    r_norms = np.linalg.norm(R, axis=0)\n    x_norms = np.linalg.norm(X, axis=0)\n    b_norms = np.linalg.norm(B, axis=0)\n    denom = normA2 * x_norms + b_norms\n    with np.errstate(divide='ignore', invalid='ignore'):\n        eta = np.where(denom  0, r_norms / denom, r_norms)\n    max_eta = float(np.max(eta))\n    return max_eta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = []\n    cases.append(build_case1())\n    cases.append(build_case2())\n    cases.append(build_case3())\n\n    results = []\n    for (A, B, params) in cases:\n        res = block_iterative_refinement(\n            A=A,\n            B=B,\n            rank_cap=params[\"rank_cap\"],\n            svd_tol=params[\"svd_tol\"],\n            tol=params[\"tol\"],\n            max_iter=params[\"max_iter\"],\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```",
                "id": "3535155"
            }
        ]
    }