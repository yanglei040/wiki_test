{
        "hands_on_practices": [
            {
                "introduction": "对于不可对角化矩阵，若尔当块 (Jordan block) 是其最基本的构成单元。本练习将引导你通过矩阵指数的级数定义，亲手推导一个典型若尔当块的指数形式。这个基础性练习至关重要，它清晰地揭示了矩阵的幂零结构 (nilpotent structure) 如何在解中引入与指数项相乘的多项式因子，这是理解线性微分方程系统动态行为的关键。 [@problem_id:3591573]",
                "problem": "设 $J \\in \\mathbb{C}^{3 \\times 3}$ 是与特征值 $\\lambda \\in \\mathbb{C}$ 相关联的 $3 \\times 3$ 若尔当块，定义为 $J = \\lambda I + N$，其中 $I$ 是单位矩阵，$N$ 是一个幂零指数为 $3$ 的幂零矩阵，其第一超对角线上的元素为1，即：\n$$\nN = \\begin{pmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  0\n\\end{pmatrix}, \\quad N^{3} = 0.\n$$\n仅使用矩阵指数的幂级数定义以及矩阵多项式的基本性质（包括 $N$ 的幂零性和与 $I$ 的交换性），通过显式写出幂零级数，推导 $\\exp(J)$ 作为一个 $3 \\times 3$ 矩阵以 $\\exp(\\lambda)$ 表示的闭式表达式。然后，从第一性原理出发，解释为何 $\\exp(J)$ 的非零超对角线元素具有乘以 $\\exp(\\lambda)$ 的多项式前置因子，并确定本例中的这些前置因子。你的最终答案必须是单一的解析矩阵表达式，不需要四舍五入。使用 $\\exp(\\cdot)$ 而非 $e^{(\\cdot)}$ 来表示最终的指数。",
                "solution": "问题是推导矩阵指数 $\\exp(J)$ 的闭式表达式，其中 $J$ 是一个特征值为 $\\lambda$ 的 $3 \\times 3$ 若尔当块。\n\n首先，我们验证问题陈述。\n已知条件如下：\n- $J \\in \\mathbb{C}^{3 \\times 3}$ 是一个若尔当块。\n- 相关联的特征值为 $\\lambda \\in \\mathbb{C}$。\n- $J$ 定义为 $J = \\lambda I + N$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n- $N$ 是幂零矩阵 $N = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix}$。\n- 幂零条件为 $N^3=0$。\n\n任务是：\n1.  使用幂级数定义推导 $\\exp(J)$ 的闭式表达式。\n2.  利用 $N$ 是幂零的且与 $I$ 可交换的性质。\n3.  解释超对角线元素上的多项式前置因子。\n4.  确定这些前置因子。\n\n这个问题在科学上基于矩阵函数理论，特别是矩阵指数。它的提法是适定的，提供了所有必要信息且没有矛盾。语言客观而精确。因此，该问题被认为是有效的。\n\n我们从矩阵指数的幂级数定义开始：\n$$ \\exp(J) = \\sum_{k=0}^{\\infty} \\frac{J^k}{k!} $$\n代入 $J = \\lambda I + N$ 的定义：\n$$ \\exp(J) = \\sum_{k=0}^{\\infty} \\frac{(\\lambda I + N)^k}{k!} $$\n矩阵 $\\lambda I$ 是单位矩阵的标量倍，它与任何矩阵（包括 $N$）都可交换。即 $(\\lambda I)N = \\lambda(IN) = \\lambda N$ 且 $N(\\lambda I) = \\lambda(NI) = \\lambda N$。由于 $\\lambda I$ 和 $N$ 可交换，我们可以对可交换矩阵 $A$ 和 $B$ 应用性质 $\\exp(A+B) = \\exp(A)\\exp(B)$。令 $A = \\lambda I$ 和 $B = N$。\n$$ \\exp(J) = \\exp(\\lambda I) \\exp(N) $$\n我们分别计算每个指数项。\n\n对于项 $\\exp(\\lambda I)$：\n$$ \\exp(\\lambda I) = \\sum_{k=0}^{\\infty} \\frac{(\\lambda I)^k}{k!} = \\sum_{k=0}^{\\infty} \\frac{\\lambda^k I^k}{k!} $$\n由于对于所有整数 $k \\geq 0$ (约定 $I^0=I$) 都有 $I^k = I$，我们可以提出因子 $I$：\n$$ \\exp(\\lambda I) = \\left( \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} \\right) I = \\exp(\\lambda) I $$\n这是一个对角线上元素为 $\\exp(\\lambda)$ 的标量矩阵。\n\n对于项 $\\exp(N)$：\n$$ \\exp(N) = \\sum_{k=0}^{\\infty} \\frac{N^k}{k!} = \\frac{N^0}{0!} + \\frac{N^1}{1!} + \\frac{N^2}{2!} + \\frac{N^3}{3!} + \\dots $$\n按照约定，$N^0 = I$ 且 $0! = 1$。问题陈述 $N$ 是一个幂零指数为 $3$ 的幂零矩阵，意味着 $N^3 = 0$。这意味着所有更高次的幂也为零，即对于所有 $k \\geq 3$，$N^k = 0$。因此，$\\exp(N)$ 的无穷级数截断为一个有限和：\n$$ \\exp(N) = I + N + \\frac{1}{2!}N^2 $$\n我们计算 $N$ 的幂：\n$N^0 = I = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$\n$N^1 = N = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix}$\n$N^2 = N \\cdot N = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$\n$N^3 = N^2 \\cdot N = \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$，这是零矩阵。\n\n将这些矩阵代入 $\\exp(N)$ 的表达式中：\n$$ \\exp(N) = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} + \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} + \\frac{1}{2} \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} $$\n$$ \\exp(N) = \\begin{pmatrix} 1  1  \\frac{1}{2} \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} $$\n现在，我们结合结果来求 $\\exp(J)$：\n$$ \\exp(J) = \\exp(\\lambda I) \\exp(N) = (\\exp(\\lambda) I) \\exp(N) = \\exp(\\lambda) \\exp(N) $$\n$$ \\exp(J) = \\exp(\\lambda) \\begin{pmatrix} 1  1  \\frac{1}{2} \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} \\exp(\\lambda)  \\exp(\\lambda)  \\frac{1}{2}\\exp(\\lambda) \\\\ 0  \\exp(\\lambda)  \\exp(\\lambda) \\\\ 0  0  \\exp(\\lambda) \\end{pmatrix} $$\n这就是所要求的闭式表达式。\n\n接下来，我们从第一性原理出发，解释为何 $\\exp(J)$ 的非零超对角线元素具有乘以 $\\exp(\\lambda)$ 的多项式前置因子。\n从幂级数出发，并对可交换矩阵 $\\lambda I$ 和 $N$ 使用二项式定理：\n$$ J^k = (\\lambda I + N)^k = \\sum_{j=0}^{k} \\binom{k}{j} (\\lambda I)^{k-j} N^j = \\sum_{j=0}^{k} \\binom{k}{j} \\lambda^{k-j} N^j $$\n由于幂零性，$N^j = 0$ 对 $j \\ge 3$ 成立，所以对于任何 $k$，和在 $j=2$ 處截断：\n$$ J^k = \\binom{k}{0}\\lambda^k I + \\binom{k}{1}\\lambda^{k-1} N + \\binom{k}{2}\\lambda^{k-2} N^2 $$",
                "answer": "$$\n\\boxed{\\begin{pmatrix} \\exp(\\lambda)  \\exp(\\lambda)  \\frac{1}{2}\\exp(\\lambda) \\\\ 0  \\exp(\\lambda)  \\exp(\\lambda) \\\\ 0  0  \\exp(\\lambda) \\end{pmatrix}}\n$$",
                "id": "3591573"
            },
            {
                "introduction": "从单个矩阵块到更宏观的结构，许多复杂系统在数学上可以表示为分块矩阵。本练习旨在探索如何利用分块上三角结构来高效计算矩阵指数。你将推导其非对角块的著名计算公式，该公式引出了一个西尔维斯特方程 (Sylvester equation)，并进一步通过编程实现和比较两种不同的数值算法，从而深入理解谱分离 (spectral separation) 对算法稳定性的影响。 [@problem_id:3591556]",
                "problem": "给定一个形如下式的分块上三角矩阵\n$$\nA \\;=\\; \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix},\n$$\n其中 $B \\in \\mathbb{C}^{m \\times m}$，$C \\in \\mathbb{C}^{n \\times n}$，$E \\in \\mathbb{C}^{m \\times n}$，且 $m, n \\in \\mathbb{N}$。您的任务是为矩阵指数推导保结构公式，根据谱分离分析稳定性，并实现利用该三角结构来高效计算非对角块的算法。\n\n您可以使用的基本依据包括以下核心定义和事实：\n- 矩阵指数由绝对收敛级数定义\n$$\n\\exp(A) \\;=\\; \\sum_{k=0}^{\\infty} \\frac{A^{k}}{k!}.\n$$\n- 对于分块上三角矩阵 $A$，对于每个 $k \\in \\mathbb{N}$，其乘积 $A^{k}$ 也是分块上三角矩阵。\n- 如果 $L(X) = BX - XC$ 且 $\\operatorname{vec}(X)$ 将 $X$ 的列堆叠起来，那么 $\\operatorname{vec}(L(X)) = \\left(I_{n} \\otimes B - C^{\\top} \\otimes I_{m}\\right)\\operatorname{vec}(X)$，其中 $\\otimes$ 表示克罗内克积。\n- 对于一个方阵 $M$，其（矩阵）1-范数为 $\\|M\\|_{1} = \\max_{j} \\sum_{i} |M_{ij}|$.\n\n除这些基本事实外，不要假设任何其他公式。特别是，不要假设任何关于 $\\exp(A)$ 非对角块的现成公式；您必须按照下文的规定从第一性原理出发进行推导。\n\n您的任务：\n\n1. 仅从矩阵指数的级数定义出发，证明 $\\exp(A)$ 是分块上三角矩阵，并用 $B$、$E$ 和 $C$ 推导出 $\\exp(A)$ 的非对角块 $X$ 的显式分块级数表达式。然后，推导出 $X$ 的一个等价积分表示，该表示为对一个标量参数的积分。最后，利用积分符号下求导法推导出 $X$ 满足的一个 Sylvester 型线性矩阵方程。陈述在该方程有唯一解时 $B$ 和 $C$ 需要满足的条件，并讨论这些条件如何通过谱分离\n$$\n\\operatorname{sep}(B,C) \\;=\\; \\sigma_{\\min}\\!\\left(I_{n} \\otimes B \\;-\\; C^{\\top} \\otimes I_{m}\\right),\n$$\n与数值稳定性相关联，其中 $\\sigma_{\\min}$ 表示最小奇异值。您的分析应完全基于 $B$、$E$ 和 $C$，并且除非您明确证明，否则不应假设交换性。\n\n2. 提出两种利用分块上三角结构计算非对角块 $X$ 的算法：\n   - 一种基于求积的算法，使用在 $[0,1]$ 上的高斯求积来计算积分表示。\n   - 一种基于 Sylvester 方程求解的算法，首先计算 $\\exp(B)$ 和 $\\exp(C)$，然后求解 $X$ 的 Sylvester 型线性矩阵方程。\n对每种算法，讨论其以 $m$、$n$ 和所选求积点数为变量的大-$\\mathcal{O}$ 记法表示的计算成本，并评论其与 $\\operatorname{sep}(B,C)$ 相关的预期数值稳定性。\n\n3. 实现这两种算法，并与对完整块矩阵 $\\exp(A)$ 的稠密参考计算进行数值验证。对于下述每个测试用例，从 $(B,E,C)$ 构造 $A$，计算参考的 $\\exp(A)$，通过两种算法计算 $X$，组装相应的 $\\exp(A)$ 结构化近似，并报告：\n   - 基于 Sylvester 方程求解的组装结果相对于稠密参考的相对 1-范数误差，\n     $$\n     \\mathrm{err}_{\\mathrm{syl}} \\;=\\; \\frac{\\left\\|\\exp(A)_{\\mathrm{ref}} - \\begin{bmatrix}\\exp(B)  X_{\\mathrm{syl}} \\\\ 0  \\exp(C)\\end{bmatrix}\\right\\|_{1}}{\\left\\|\\exp(A)_{\\mathrm{ref}}\\right\\|_{1}}.\n     $$\n   - 基于积分求积的组装结果相对于稠密参考的相对 1-范数误差，\n     $$\n     \\mathrm{err}_{\\mathrm{int}} \\;=\\; \\frac{\\left\\|\\exp(A)_{\\mathrm{ref}} - \\begin{bmatrix}\\exp(B)  X_{\\mathrm{int}} \\\\ 0  \\exp(C)\\end{bmatrix}\\right\\|_{1}}{\\left\\|\\exp(A)_{\\mathrm{ref}}\\right\\|_{1}}.\n     $$\n   - 谱分离 $\\operatorname{sep}(B,C)$。\n\n对于基于积分的计算，使用在 $[0,1]$ 上的 $q = 64$ 阶高斯求积。您可以使用奇异值分解 (SVD) 来评估 $\\operatorname{sep}(B,C)$。\n\n测试套件包含以下四个用例。所有矩阵均为实数矩阵；您可以将 $\\mathbb{R}$ 视为 $\\mathbb{C}$ 的一个子域：\n- 用例 1 ($m = 2$, $n = 2$): \n  $$\n  B = \\begin{bmatrix} -1  2 \\\\ 0  -2 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} -\\tfrac{1}{2}  \\tfrac{1}{2} \\\\ 0  -3 \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 0.3  -0.2 \\\\ 0.1  0.4 \\end{bmatrix}.\n  $$\n- 用例 2 ($m = 2$, $n = 2$): 设 $\\delta = 10^{-6}$ 且\n  $$\n  B = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} \\delta  1 \\\\ 0  \\delta \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 1  0 \\\\ 0  -1 \\end{bmatrix}.\n  $$\n- 用例 3 ($m = 3$, $n = 1$): \n  $$\n  B = \\begin{bmatrix} 0.1  1  0 \\\\ 0  0.2  1 \\\\ 0  0  0.3 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} -0.25 \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 1 \\\\ 0.5 \\\\ -0.25 \\end{bmatrix}.\n  $$\n- 用例 4 ($m = 2$, $n = 2$): \n  $$\n  B = \\begin{bmatrix} 5  0 \\\\ 1  4 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} -3  1 \\\\ 0  -2 \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 0.2  -0.1 \\\\ 0.05  0.05 \\end{bmatrix}.\n  $$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由四个条目组成的逗号分隔列表，每个条目对应一个测试用例，并用方括号括起来。每个条目本身必须是一个包含三个科学记数法表示的浮点数的列表，代表 $[\\mathrm{err}_{\\mathrm{syl}}, \\mathrm{err}_{\\mathrm{int}}, \\operatorname{sep}(B,C)]$。例如：\n$$\n\\big[ [x_{1}, y_{1}, z_{1}], [x_{2}, y_{2}, z_{2}], [x_{3}, y_{3}, z_{3}], [x_{4}, y_{4}, z_{4}] \\big].\n$$\n\n不涉及物理单位。不出现角度。不得使用百分比；所有报告的量均为无量纲浮点数。程序必须完全自包含，除了打印这一行之外，不执行任何输入或输出。您可以使用的数值库由执行环境规范固定。",
                "solution": "该问题要求对计算分块上三角矩阵的指数进行全面的理论推导、算法设计和数值实现。我们将首先验证问题陈述的有效性，然后依次处理三个任务。\n\n该问题被确定为有效，因为它在科学上基于数值线性代数的既定原则，是适定的，具有清晰一致的给定条件和目标，并且不含任何主观或不可形式化的内容。所有定义和任务在指定领域内都是标准的。\n\n### 任务1：推导与分析\n\n设分块上三角矩阵为 $A = \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix}$，其中 $B \\in \\mathbb{C}^{m \\times m}$，$C \\in \\mathbb{C}^{n \\times n}$，$E \\in \\mathbb{C}^{m \\times n}$。\n\n**1. $\\exp(A)$ 的分块结构与非对角块的级数**\n\n我们首先研究 $A$ 的幂。已知 $A^k$ 是分块上三角矩阵。我们用归纳法来确定 $A^k$ 的形式。设 $A^k = \\begin{bmatrix} B^k  X_k \\\\ 0  C^k \\end{bmatrix}$。基本情况 $k=0$ 给出 $A^0 = I = \\begin{bmatrix} I_m  0 \\\\ 0  I_n \\end{bmatrix}$，因此 $X_0 = 0$。对于 $k=1$，$A^1 = A = \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix}$，因此 $X_1 = E$。\n假设该假设对整数 $k \\ge 1$ 成立。那么，\n$$\nA^{k+1} = A^k A = \\begin{bmatrix} B^k  X_k \\\\ 0  C^k \\end{bmatrix} \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix} = \\begin{bmatrix} B^{k+1}  B^k E + X_k C \\\\ 0  C^{k+1} \\end{bmatrix}.\n$$\n这证实了 $A^{k+1}$ 也是分块上三角矩阵，且 $X_{k+1} = B^k E + X_k C$。展开 $X_k$ 的这个递推关系，我们发现：\n$X_1 = E$\n$X_2 = BE + X_1C = BE + EC$\n$X_3 = B^2E + X_2C = B^2E + (BE+EC)C = B^2E + BEC + EC^2$\n通项是所有可能的 $B$ 和 $C$ 的乘积夹着 $E$ 的总和，其中 $B$ 和 $C$ 的因子总数为 $k-1$。这可以写成：\n$$\nX_k = \\sum_{j=0}^{k-1} B^{k-1-j} E C^j.\n$$\n矩阵指数由级数 $\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{A^k}{k!}$ 定义。代入 $A^k$ 的分块形式：\n$$\n\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{1}{k!} \\begin{bmatrix} B^k  X_k \\\\ 0  C^k \\end{bmatrix} = \\begin{bmatrix} \\sum_{k=0}^{\\infty} \\frac{B^k}{k!}  \\sum_{k=0}^{\\infty} \\frac{X_k}{k!} \\\\ 0  \\sum_{k=0}^{\\infty} \\frac{C^k}{k!} \\end{bmatrix}.\n$$\n识别出矩阵指数的级数，我们得到分块结构：\n$$\n\\exp(A) = \\begin{bmatrix} \\exp(B)  X \\\\ 0  \\exp(C) \\end{bmatrix},\n$$\n其中非对角块 $X$ 由级数给出：\n$$\nX = \\sum_{k=0}^{\\infty} \\frac{X_k}{k!} = \\sum_{k=1}^{\\infty} \\frac{1}{k!} \\left( \\sum_{j=0}^{k-1} B^{k-1-j} E C^j \\right).\n$$\n这是 $X$ 的显式分块级数表达式。注意，因为 $X_0=0$，所以 $X$ 的求和从 $k=1$ 开始。\n\n**2. $X$ 的积分表示**\n\n考虑矩阵值函数 $F(s) = \\exp(As)$（其中 $s \\in \\mathbb{R}$），可以推导出 $X$ 的一个更紧凑的表示。我们知道 $\\frac{dF}{ds} = A F(s)$ 且 $F(0) = I$。设 $F(s)$ 的分块结构为 $F(s) = \\begin{bmatrix} \\exp(Bs)  Y(s) \\\\ 0  \\exp(Cs) \\end{bmatrix}$。对 $s$ 求导得到：\n$$\n\\frac{dF}{ds} = \\begin{bmatrix} B\\exp(Bs)  Y'(s) \\\\ 0  C\\exp(Cs) \\end{bmatrix}.\n$$\n乘积 $AF(s)$ 为：\n$$\nA F(s) = \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix} \\begin{bmatrix} \\exp(Bs)  Y(s) \\\\ 0  \\exp(Cs) \\end{bmatrix} = \\begin{bmatrix} B\\exp(Bs)  B Y(s) + E \\exp(Cs) \\\\ 0  C\\exp(Cs) \\end{bmatrix}.\n$$\n令 $\\frac{dF}{ds}$ 和 $AF(s)$ 的 $(1,2)$ 块相等，得到一个关于 $Y(s)$ 的线性常微分方程：\n$$\nY'(s) = B Y(s) + E \\exp(Cs),\n$$\n初始条件为 $Y(0)=0$（来自 $F(0)=I$）。我们使用积分因子 $\\exp(-Bs)$ 来求解此方程。左乘 $\\exp(-Bs)$ 得到：\n$$\n\\exp(-Bs)Y'(s) - \\exp(-Bs)B Y(s) = \\exp(-Bs) E \\exp(Cs).\n$$\n左边是一个乘积的导数：$\\frac{d}{ds}(\\exp(-Bs)Y(s))$。从 $0$ 积分到一个参数 $t$：\n$$\n\\int_0^t \\frac{d}{ds}(\\exp(-Bs)Y(s)) ds = \\int_0^t \\exp(-Bs) E \\exp(Cs) ds.\n$$\n对左边应用微积分基本定理：\n$$\n\\exp(-Bt)Y(t) - \\exp(-B\\cdot 0)Y(0) = \\exp(-Bt)Y(t).\n$$\n因此，$Y(t) = \\exp(Bt) \\int_0^t \\exp(-Bs) E \\exp(Cs) ds = \\int_0^t \\exp(B(t-s)) E \\exp(Cs) ds$。\n$\\exp(A)$ 的非对角块 $X$ 对应于 $Y(1)$。\n$$\nX = Y(1) = \\int_0^1 \\exp(B(1-s)) E \\exp(Cs) ds.\n$$\n这就是所求的积分表示。\n\n**3. $X$ 的 Sylvester 方程**\n\n为推导 $X$ 的 Sylvester 方程，我们按照提示使用积分符号下求导法。考虑函数 $G(t) = \\exp(B(1-t)) E \\exp(Ct)$。积分表示为 $X = \\int_0^1 G(t) dt$。\n我们计算 $G(t)$ 对 $t$ 的导数：\n\\begin{align*}\n\\frac{dG}{dt} = \\frac{d}{dt} \\left( \\exp(B(1-t)) \\right) E \\exp(Ct) + \\exp(B(1-t)) E \\frac{d}{dt} \\left( \\exp(Ct) \\right) \\\\\n= \\exp(B(1-t))(-B) E \\exp(Ct) + \\exp(B(1-t)) E \\exp(Ct)C \\\\\n= -B G(t) + G(t) C.\n\\end{align*}\n现在，我们将此恒等式从 $t=0$ 积分到 $t=1$：\n$$\n\\int_0^1 \\frac{dG}{dt} dt = \\int_0^1 (-B G(t) + G(t) C) dt.\n$$\n左边计算结果为 $G(1) - G(0)$：\n$$\nG(1) - G(0) = \\exp(B(0)) E \\exp(C) - \\exp(B(1)) E \\exp(0) = E\\exp(C) - \\exp(B)E.\n$$\n右边可以根据积分的线性性拆分：\n$$\n\\int_0^1 (-B G(t) + G(t) C) dt = -B \\left(\\int_0^1 G(t) dt\\right) + \\left(\\int_0^1 G(t) dt\\right) C = -B X + X C.\n$$\n令两边结果相等得到 $E\\exp(C) - \\exp(B)E = -B X + X C$。整理后得到 Sylvester 方程：\n$$\nBX - XC = \\exp(B)E - E\\exp(C).\n$$\n该方程的形式为 $L(X) = F$，其中 $L(X) = BX-XC$ 是 Sylvester 算子，$F = \\exp(B)E - E\\exp(C)$。\n\n**4. 解的唯一性与数值稳定性**\n\n使用给定的恒等式，Sylvester 方程 $BX-XC=F$ 可以写成向量化的线性系统形式：\n$$\n(I_n \\otimes B - C^T \\otimes I_m) \\operatorname{vec}(X) = \\operatorname{vec}(F).\n$$\n对于任意右端项 $F$，该系统有唯一解的充要条件是系数矩阵 $K = I_n \\otimes B - C^T \\otimes I_m$ 可逆。一个矩阵可逆的充要条件是其所有特征值非零。$K$ 的特征值由 $\\lambda_i(B) - \\lambda_j(C)$ 给出，其中 $\\lambda_i(B) \\in \\Lambda(B)$ 和 $\\lambda_j(C) \\in \\Lambda(C)$ 是所有特征值对。因此，$X$ 的唯一解存在的充要条件是 $\\Lambda(B) \\cap \\Lambda(C) = \\emptyset$，即 $B$ 和 $C$ 的谱不相交。\n\n数值稳定性关注解 $X$ 对输入数据（$B$, $C$, $E$ 以及由此产生的 $F$）中扰动的敏感性。$K$ 的条件数决定了这种敏感性。条件数与 $K$ 的最小奇异值 $\\sigma_{\\min}(K)$ 的倒数成正比。谱分离 $\\operatorname{sep}(B, C)$ 正好被定义为这个值：\n$$\n\\operatorname{sep}(B, C) = \\sigma_{\\min}(I_n \\otimes B - C^T \\otimes I_m).\n$$\n较小的 $\\operatorname{sep}(B, C)$ 值意味着 $K$ 是病态的（接近奇异）。在这种情况下，求解 Sylvester 方程是数值不稳定的：在计算 $\\exp(B)$、$\\exp(C)$ 或 $E$ 时的微小误差，甚至矩阵本身的表示误差，都可能被一个与 $1/\\operatorname{sep}(B, C)$ 成比例的因子放大，导致计算出的解 $X$ 出现较大误差。\n\n### 任务2：算法\n\n**1. 基于求积的算法**\n该算法使用数值求积来近似计算积分 $X = \\int_0^1 \\exp(B(1-t)) E \\exp(Ct) dt$。具体来说，我们使用在 $[0,1]$ 上的 $q$ 点高斯求积。\n积分由加权和近似：$X \\approx \\sum_{i=1}^q w_i \\exp(B(1-t_i)) E \\exp(Ct_i)$，其中 $\\{t_i\\}$ 是 $[0,1]$ 上的求积节点，$\\{w_i\\}$ 是对应的权重。\n- **算法**：\n    1. 获取标准高斯-勒让德求积在 $[-1,1]$ 上的 $q$ 个节点 $\\{s_i\\}$ 和权重 $\\{\\hat{w}_i\\}$。\n    2. 将它们变换到区间 $[0,1]$：$t_i = (s_i+1)/2$，$w_i = \\hat{w}_i/2$。\n    3. 初始化 $X_{\\mathrm{int}} = 0_{m \\times n}$。\n    4. 对于 $i = 1, \\dots, q$：\n        a. 计算 $M_i = \\exp(B(1-t_i))$ 和 $N_i = \\exp(Ct_i)$。\n        b. 计算项 $T_i = w_i M_i E N_i$。\n        c. 累加结果：$X_{\\mathrm{int}} = X_{\\mathrm{int}} + T_i$。\n- **计算成本**：主要成本在于循环内部，该循环执行 $q$ 次。在循环中，我们计算两个矩阵指数 $\\exp(B(1-t_i))$ 和 $\\exp(Ct_i)$，其成本分别为 $O(m^3)$ 和 $O(n^3)$（使用如缩放与平方等标准方法）。矩阵乘积的成本为 $O(m^2n + mn^2)$。因此，总成本为 $O(q(m^3+n^3))$。\n- **数值稳定性**：该方法通常是稳定的。其准确性取决于高斯求积内蕴的多项式逼近能多好地捕捉被积函数的行为。该方法的稳定性不直接且灾难性地依赖于 $\\operatorname{sep}(B,C)$。即使 $\\Lambda(B) \\cap \\Lambda(C) \\neq \\emptyset$，积分也是良定义的，并且当 $q \\to \\infty$ 时该方法会收敛。当 $\\operatorname{sep}(B,C)$ 很小时，预计它比 Sylvester 方法更鲁棒。\n\n**2. 基于 Sylvester 方程求解的算法**\n该算法直接求解线性矩阵方程 $BX - XC = \\exp(B)E - E\\exp(C)$。\n- **算法**：\n    1. 计算 $\\exp(B)$ 和 $\\exp(C)$。\n    2. 构建右端项矩阵 $F = \\exp(B)E - E\\exp(C)$。\n    3. 求解 Sylvester 方程 $BX - XC = F$ 得到 $X_{\\mathrm{syl}}$。标准求解器如 `scipy.linalg.solve_sylvester` 使用 Bartels-Stewart 算法。\n- **计算成本**：步骤1的成本为 $O(m^3+n^3)$。步骤2的成本为 $O(m^2n+mn^2)$。步骤3，使用 Bartels-Stewart 算法，涉及对 $B$ 和 $C$ 进行 Schur 分解（成本为 $O(m^3+n^3)$），然后是一个回代过程（成本为 $O(mn(m+n))$）。总成本由矩阵指数和 Schur 分解主导，总复杂度为 $O(m^3+n^3)$。\n- **数值稳定性**：如任务1中所分析，此方法的稳定性关键性地依赖于 $\\operatorname{sep}(B,C)$。如果 $\\operatorname{sep}(B,C)$ 很小，由于底层的线性系统变得严重病态，预计该方法将非常不准确且数值不稳定。\n\n### 任务3：数值实现与验证\n\n实现将遵循任务2中描述的算法。我们将使用 `numpy` 进行矩阵代数运算，`scipy.linalg.expm` 用于参考指数和算法组件，`scipy.linalg.solve_sylvester` 用于 Sylvester 求解器，`numpy.polynomial.legendre.leggauss` 用于获取求积点，以及 `scipy.linalg.svd` 用于计算 $\\operatorname{sep}(B,C)$ 所需的奇异值。将计算并按要求格式化四个指定测试用例的结果。对测试用例的分析表明，用例2（其中 $\\delta=10^{-6}$）由于其非常小的谱分离，将凸显两种算法之间的稳定性差异。其他用例具有良好分离的谱，两种方法都应能产生准确的结果。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve_sylvester, svd\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    It derives and implements two algorithms to compute the off-diagonal block\n    of the exponential of a block upper triangular matrix.\n    \"\"\"\n    \n    # Define the quadrature order as specified in the problem statement.\n    q = 64\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([[-1.0, 2.0], [0.0, -2.0]]),\n            np.array([[-0.5, 0.5], [0.0, -3.0]]),\n            np.array([[0.3, -0.2], [0.1, 0.4]])\n        ),\n        (\n            np.array([[0.0, 1.0], [0.0, 0.0]]),\n            np.array([[1e-6, 1.0], [0.0, 1e-6]]),\n            np.array([[1.0, 0.0], [0.0, -1.0]])\n        ),\n        (\n            np.array([[0.1, 1.0, 0.0], [0.0, 0.2, 1.0], [0.0, 0.0, 0.3]]),\n            np.array([[-0.25]]),\n            np.array([[1.0], [0.5], [-0.25]])\n        ),\n        (\n            np.array([[5.0, 0.0], [1.0, 4.0]]),\n            np.array([[-3.0, 1.0], [0.0, -2.0]]),\n            np.array([[0.2, -0.1], [0.05, 0.05]])\n        )\n    ]\n\n    results = []\n    \n    # Get Gauss-Legendre quadrature nodes and weights for interval [-1, 1]\n    # np.polynomial.legendre.leggauss is part of numpy and its use is permitted.\n    s, w_hat = np.polynomial.legendre.leggauss(q)\n    # Transform nodes and weights to interval [0, 1]\n    t_quad = (s + 1.0) / 2.0\n    w_quad = w_hat / 2.0\n\n    for B, C, E in test_cases:\n        m, _ = B.shape\n        n, _ = C.shape\n\n        # 1. Construct the full matrix A and compute the reference solution.\n        A = np.block([\n            [B, E],\n            [np.zeros((n, m)), C]\n        ])\n        exp_A_ref = expm(A)\n        norm_ref = np.linalg.norm(exp_A_ref, ord=1)\n        \n        # Pre-compute diagonal blocks of the exponential.\n        exp_B = expm(B)\n        exp_C = expm(C)\n\n        # 2. Algorithm 1: Sylvester-solve-based method.\n        F = exp_B @ E - E @ exp_C\n        try:\n            # solve_sylvester solves A*X + X*B = Q.\n            # We have B_ours*X - X*C_ours = F.\n            # So, A=B_ours, B=-C_ours, Q=F.\n            X_syl = solve_sylvester(B, -C, F)\n        except Exception:\n            # In case of failure, though solve_sylvester is robust\n            X_syl = np.full((m, n), np.nan)\n            \n        exp_A_syl = np.block([\n            [exp_B, X_syl],\n            [np.zeros((n, m)), exp_C]\n        ])\n        err_syl = np.linalg.norm(exp_A_ref - exp_A_syl, ord=1) / norm_ref\n\n        # 3. Algorithm 2: Integral-quadrature-based method.\n        X_int = np.zeros((m, n))\n        for i in range(q):\n            ti = t_quad[i]\n            wi = w_quad[i]\n            # Integrand is exp(B(1-t)) * E * exp(Ct)\n            term = expm(B * (1.0 - ti)) @ E @ expm(C * ti)\n            X_int += wi * term\n\n        exp_A_int = np.block([\n            [exp_B, X_int],\n            [np.zeros((n, m)), exp_C]\n        ])\n        err_int = np.linalg.norm(exp_A_ref - exp_A_int, ord=1) / norm_ref\n\n        # 4. Compute spectral separation sep(B, C).\n        # sep(B,C) = sigma_min(I_n kron B - C^T kron I_m)\n        K = np.kron(np.eye(n), B) - np.kron(C.T, np.eye(m))\n        # scipy.linalg.svd returns singular values in descending order.\n        singular_values = svd(K, compute_uv=False)\n        sep_BC = singular_values[-1]\n\n        results.append([err_syl, err_int, sep_BC])\n    \n    # Format the final output string.\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]:.6e}, {res[1]:.6e}, {res[2]:.6e}]\"\n        if i  len(results) - 1:\n            output_str += \", \"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```",
                "id": "3591556"
            },
            {
                "introduction": "矩阵的特征值决定了系统的长期稳定性，但系统的短期动态行为可能隐藏着更多秘密。本计算练习将带你探索“瞬态增长”(transient growth) 这一重要现象，即一个稳定的线性系统（特征值均在左半平面）的解范数在衰减前可能经历巨大的短暂放大。你将通过编程构建并分析非正规矩阵 (nonnormal matrix)，将观测到的瞬态增长与“伪谱”(pseudospectrum) 这一强大的现代理论工具联系起来，从而体会到超越传统特征值分析的深刻洞察。 [@problem_id:3591545]",
                "problem": "您必须编写一个完整、可运行的程序，该程序构造显式的稳定但高度非正规的矩阵，并定量地展示矩阵指数中的巨大瞬态增长。该任务必须基于矩阵指数和 $\\varepsilon$-伪谱的核心定义，并且必须产生数值证据，将观察到的瞬态增长与 $\\varepsilon$-伪谱横坐标以及通过拉普拉斯变换围线计算的可计算的伪谱界限联系起来。所有量都是纯数学的且无量纲的，因此不涉及物理单位或角度。\n\n使用以下基本定义和事实作为您推导和计算的基础：\n\n- 对于任何复方阵 $A$ 和实标量 $t \\ge 0$，矩阵指数由幂级数 $e^{tA} = \\sum_{k=0}^{\\infty} \\frac{t^k}{k!} A^k$ 定义。\n- 谱横坐标为 $\\alpha(A) := \\max\\{\\operatorname{Re}(\\lambda) : \\lambda \\in \\sigma(A)\\}$，其中 $\\sigma(A)$ 表示 $A$ 的谱（特征值集合）。\n- 矩阵 $M$ 的算子 $2$-范数是 $\\|M\\|_2 := \\sigma_{\\max}(M)$，即最大奇异值。特别地，对于任何可逆矩阵 $B$，$\\|B^{-1}\\|_2 = 1 / \\sigma_{\\min}(B)$。\n- 对于 $\\varepsilon > 0$，$\\varepsilon$-伪谱是 $\\Lambda_{\\varepsilon}(A) := \\{ z \\in \\mathbb{C} : \\|(zI - A)^{-1}\\|_2 \\ge 1/\\varepsilon \\}$，而 $\\varepsilon$-伪谱横坐标是 $\\alpha_{\\varepsilon}(A) := \\sup\\{\\operatorname{Re}(z) : z \\in \\Lambda_{\\varepsilon}(A)\\}$。\n- 对于任何满足 $\\gamma > \\alpha(A)$ 的固定 $\\gamma \\in \\mathbb{R}$，矩阵指数的拉普拉斯变换表示为\n$$\ne^{tA} = \\frac{1}{2\\pi i} \\int_{\\gamma - i\\infty}^{\\gamma + i\\infty} e^{tz} (zI - A)^{-1} \\, dz,\n$$\n因此\n$$\n\\|e^{tA}\\|_2 \\le \\frac{e^{\\gamma t}}{2\\pi} \\int_{-\\infty}^{\\infty} \\|( \\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega.\n$$\n如果 $\\gamma > \\alpha_{\\varepsilon}(A)$，则对于所有 $\\omega \\in \\mathbb{R}$，$\\|( \\gamma + i\\omega)I - A \\|_2^{-1}  1/\\varepsilon$。将积分截断到 $|\\omega| \\le \\Omega$ 会得到一个可计算的界\n$$\n\\|e^{tA}\\|_2 \\le \\frac{e^{\\gamma t}}{2\\pi} \\int_{-\\Omega}^{\\Omega} \\|( \\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega,\n$$\n我们将把它作为截断围线上的上界进行数值计算。\n\n您的程序必须为指定的测试套件实现以下步骤：\n\n1. 构造三个测试矩阵 $A$，其维度和参数如所述，每个矩阵的 $\\sigma(A)$ 都严格位于左半平面：\n   - 情况 1：$A_1 = \\operatorname{diag}(-1, -2, -3)$。\n   - 情况 2：$A_2 = \\begin{bmatrix} -1  K_2 \\\\ 0  -10 \\end{bmatrix}$，其中 $K_2 = 300$。这是一个上三角矩阵，其巨大的超对角线元素造成了非正规性。\n   - 情况 3：$A_3 = -I + K_3 N$，其中 $I$ 是 $3 \\times 3$ 单位矩阵，$N$ 是一个 $3 \\times 3$ 的幂零矩阵，其第一超对角线上的元素为 1，其余元素为 0，且 $K_3 = 25$。显式地，$N = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{bmatrix}$。\n\n2. 对每个矩阵 $A$，通过在均匀时间网格 $t \\in [0, T]$（其中 $T = 8$，$N_t = 601$ 个点，包括端点）上计算 $\\| e^{tA} \\|_2$ 来计算观察到的瞬态增长。记录最大放大倍数\n   $$\n   M_{\\mathrm{obs}} := \\max_{t \\in \\{t_j\\}_{j=0}^{N_t-1}} \\| e^{tA} \\|_2\n   $$\n   以及达到最大值时的网格时间 $t^\\star$（如果存在多个，则选择网格上最小的那个 $t$）。同时计算谱横坐标 $\\alpha(A)$。\n\n3. 对每个矩阵 $A$ 和每个 $\\varepsilon \\in \\{ 10^{-1}, 5 \\cdot 10^{-2} \\}$，通过在复平面的矩形网格上对预解范数进行采样来近似 $\\alpha_{\\varepsilon}(A)$：\n   - 实轴范围：$\\operatorname{Re}(z) \\in [ -5 , 1.5 ]$，步长 $\\Delta x = 0.05$。\n   - 虚轴范围：$\\operatorname{Im}(z) \\in [ -20 , 20 ]$，步长 $\\Delta y = 0.1$。\n   在每个网格点 $z = x + i y$，计算 $\\|(zI - A)^{-1}\\|_2 = 1 / \\sigma_{\\min}(zI - A)$，如果该值至少为 $1/\\varepsilon$，则标记该点。将 $\\alpha_{\\varepsilon}(A)$ 估计为所有被标记点中最大的实部 $x$（如果没有点被标记，则报告最小的实部网格值 $-5$，这表示所选网格未能达到阈值，但对于指定的矩阵和 $\\varepsilon$ 值，这种情况不应发生）。\n\n4. 对每个矩阵 $A$，在时间 $t = t^\\star$ 处为 $\\varepsilon = 10^{-1}$ 形成一个截断的伪谱界，如下所示：\n   - 设置 $\\gamma = \\alpha_{\\varepsilon}(A) + \\delta$，其中 $\\delta = 2 \\cdot 10^{-2}$。这确保了 $\\gamma > \\alpha_{\\varepsilon}(A)$。\n   - 数值近似计算\n     $$\n     B_{\\varepsilon}(t^\\star) := \\frac{e^{\\gamma t^\\star}}{2\\pi} \\int_{-\\Omega}^{\\Omega} \\|(\\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega\n     $$\n     使用梯形法则，在 $[-\\Omega, \\Omega]$ 上使用 $\\Omega = 50$ 和一个包含 $N_\\omega = 1001$ 个节点的均匀网格。这个 $B_{\\varepsilon}(t^\\star)$ 是截断的布朗维奇围线上一个可计算的上界，它量化了由伪谱横坐标预测的增长。\n\n5. 对每个测试用例，生成一个恰好包含六个条目的结果列表：\n   - 观察到的最大放大倍数 $M_{\\mathrm{obs}}$（浮点数）。\n   - 达到最大放大倍数时的网格时间 $t^\\star$（浮点数）。\n   - 谱横坐标 $\\alpha(A)$（浮点数）。\n   - 针对 $\\varepsilon = 10^{-1}$ 的 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$（浮点数）。\n   - 针对 $\\varepsilon = 5 \\cdot 10^{-2}$ 的 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$（浮点数）。\n   - 针对 $\\varepsilon = 10^{-1}$ 的截断伪谱界 $B_{\\varepsilon}(t^\\star)$（浮点数）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个内部列表，每个内部列表按上述顺序包含六个浮点数。例如，输出必须看起来像\n$[ [ r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}, r_{1,6} ], [ r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}, r_{2,5}, r_{2,6} ], [ r_{3,1}, r_{3,2}, r_{3,3}, r_{3,4}, r_{3,5}, r_{3,6} ] ]$\n每个 $r_{i,j}$ 都作为 Python 浮点数打印。\n\n该测试套件探究了：\n- 一个正规的对角矩阵（基线，无瞬态增长）。\n- 一个 $2 \\times 2$ 的上三角、强非正规矩阵（显著的瞬态增长）。\n- 一个 $3 \\times 3$ 的若尔当型、强非正规矩阵（多项式加权的瞬态响应）。\n结果展示了非正规性如何使 $\\|e^{tA}\\|_2$ 远超 $e^{t \\alpha(A)}$，并将其与对于小 $\\varepsilon$ 值 $\\alpha_{\\varepsilon}(A)$ 变为非负数相联系，同时使用从 $\\Lambda_{\\varepsilon}(A)$ 构建的截断伪谱界来量化这种增长。",
                "solution": "该问题要求对由 $\\dot{\\boldsymbol{x}} = A \\boldsymbol{x}$ 控制的线性动力学系统中的瞬态增长现象进行数值演示，其解为 $\\boldsymbol{x}(t) = e^{tA} \\boldsymbol{x}(0)$。分析的关键在于矩阵指数 $e^{tA}$ 的性质，特别是其算子 $2$-范数 $\\|e^{tA}\\|_2$。对于一个由谱横坐标 $\\alpha(A)  0$ 定义的稳定矩阵 $A$，其长期行为是衰减，即 $\\lim_{t \\to \\infty} \\|e^{tA}\\|_2 = 0$。然而，如果 $A$ 是非正规的（即 $A^*A \\ne AA^*$），$\\|e^{tA}\\|_2$ 可能会表现出显著的瞬态增长，在衰减之前达到远大于 1 的值。这种行为无法仅通过特征值来预测。$\\varepsilon$-伪谱 $\\Lambda_{\\varepsilon}(A)$ 通过刻画特征值对扰动的敏感性，提供了一个更完整的图像。显著的瞬态增长与 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$ 相关联，即对于小的 $\\varepsilon$ 值，即使 $\\alpha(A)$ 是负的，$\\alpha_{\\varepsilon}(A)$ 也会是正的。这表明对 $A$ 的微小扰动可以将特征值移到右半平面，这是易于产生瞬态效应的非正规系统的一个标志。我们将通过构造和分析三个不同的矩阵来验证这些原理。\n\n首先，根据问题规范构造三个测试矩阵。\n情况 1：一个正规（对角）矩阵，预计不会表现出瞬态增长。\n$$\nA_1 = \\operatorname{diag}(-1, -2, -3) = \\begin{bmatrix} -1  0  0 \\\\ 0  -2  0 \\\\ 0  0  -3 \\end{bmatrix}\n$$\n情况 2：一个非正规上三角矩阵，其巨大的超对角线元素 $K_2=300$ 旨在产生显著的瞬态增长。\n$$\nA_2 = \\begin{bmatrix} -1  300 \\\\ 0  -10 \\end{bmatrix}\n$$\n情况 3：一个由幂零若尔当块构造的非正规矩阵。已知这种结构会导致多项式加权的增长。此处 $K_3=25$。\n$$\nA_3 = -I + 25 N = \\begin{bmatrix} -1  25  0 \\\\ 0  -1  25 \\\\ 0  0  -1 \\end{bmatrix}\n$$\n所有三个矩阵的特征值都完全位于严格的左半平面，意味着它们是渐近稳定的。\n\n其次，我们分析观察到的瞬态增长。对于每个矩阵 $A$，我们在一个离散时间网格 $t_j \\in [0, T]$（其中 $T=8$，$N_t=601$ 个点）上计算 $\\|e^{tA}\\|_2$。最大放大倍数是 $M_{\\mathrm{obs}} = \\max_{j} \\|e^{t_j A}\\|_2$，而 $t^\\star$ 是该最大值首次出现的时间。矩阵指数 $e^{tA}$ 使用 `scipy.linalg.expm` 函数计算，算子 $2$-范数通过 `numpy.linalg.norm` 找到。谱横坐标 $\\alpha(A) = \\max\\{\\operatorname{Re}(\\lambda) : \\lambda \\in \\sigma(A)\\}$ 也从 $A$ 的特征值计算得出。对于像 $A_1$ 这样的正规矩阵，我们预期在 $t^\\star=0$ 时 $M_{\\mathrm{obs}}=1$。对于非正规矩阵 $A_2$ 和 $A_3$，我们预计对于某个 $t^\\star > 0$ 会有 $M_{\\mathrm{obs}} \\gg 1$。\n\n第三，我们对 $\\varepsilon \\in \\{10^{-1}, 5 \\cdot 10^{-2}\\}$ 近似计算 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$。根据定义，$\\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\|(zI - A)^{-1}\\|_2 \\ge 1/\\varepsilon \\}$。预解式范数 $\\|(zI - A)^{-1}\\|_2$ 等于 $1/\\sigma_{\\min}(zI - A)$，其中 $\\sigma_{\\min}$ 是最小奇异值。因此，该条件等价于 $\\sigma_{\\min}(zI - A) \\le \\varepsilon$。我们将复平面的一个矩形区域离散化，网格点为 $z_{jk} = x_j + i y_k$，其中 $x_j \\in [-5, 1.5]$ 且 $y_k \\in [-20, 20]$。在每个点上，我们计算 $\\sigma_{\\min}(z_{jk}I - A)$ 并检查它是否小于或等于 $\\varepsilon$。然后，$\\alpha_{\\varepsilon}(A)$ 的值被估计为满足条件的所有网格点 $z_{jk}$ 中的最大实部 $x_j$。对于一个稳定的矩阵 $A$，一个正的 $\\alpha_{\\varepsilon}(A)$ 是潜在瞬态增长的强有力指标。\n\n第四，我们使用伪谱计算瞬态增长的定量界限。矩阵指数的拉普拉斯变换表示导致不等式 $\\|e^{tA}\\|_2 \\le \\frac{e^{\\gamma t}}{2\\pi} \\int_{-\\infty}^{\\infty} \\|((\\gamma + i\\omega)I - A)^{-1}\\|_2 \\, d\\omega$ 对任何 $\\gamma > \\alpha(A)$ 成立。通过选择一个比 $\\alpha_{\\varepsilon}(A)$ 稍大的 $\\gamma$，具体来说是 $\\gamma = \\alpha_{\\varepsilon}(A) + \\delta$，其中 $\\delta = 2 \\cdot 10^{-2}$ 且 $\\varepsilon = 10^{-1}$，我们将积分围线置于 $\\varepsilon$-伪谱的右侧。这个界限可以通过截断积分并进行数值计算来近似。我们在观察到的峰值时间 $t=t^\\star$ 计算截断的伪谱界：\n$$\nB_{\\varepsilon}(t^\\star) = \\frac{e^{\\gamma t^\\star}}{2\\pi} \\int_{-\\Omega}^{\\Omega} \\|(\\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega\n$$\n积分使用梯形法则在区间 $[-\\Omega, \\Omega]$（其中 $\\Omega=50$）上，通过一个包含 $N_{\\omega}=1001$ 个点的网格进行计算。被积函数 $\\|(\\gamma + i\\omega)I - A\\|_2^{-1}$ 再次被计算为 $1/\\sigma_{\\min}((\\gamma + i\\omega)I-A)$。这个界限 $B_{\\varepsilon}(t^\\star)$ 为最大观测放大 $M_{\\mathrm{obs}}$ 提供了一个理论估计，该估计直接源于伪谱的几何形状。\n\n最后，对于三个测试用例中的每一个，我们按指定顺序编制一个包含六个数值结果的列表：观察到的最大放大倍数 $M_{\\mathrm{obs}}$、最大放大倍数出现的时间 $t^\\star$、谱横坐标 $\\alpha(A)$、两个针对 $\\varepsilon = 10^{-1}$ 和 $\\varepsilon = 5 \\cdot 10^{-2}$ 估计的 $\\varepsilon$-伪谱横坐标，以及为 $\\varepsilon = 10^{-1}$ 计算的截断伪谱界 $B_{\\varepsilon}(t^\\star)$。这提供了一个全面的图景，将非正规性和伪谱的抽象理论与瞬态动力学的具体数值观测联系起来。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Constructs stable but nonnormal matrices and demonstrates transient growth in the matrix exponential,\n    connecting it to the epsilon-pseudospectrum.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    K2 = 300.0\n    K3 = 25.0\n    A1 = np.diag([-1.0, -2.0, -3.0])\n    A2 = np.array([[-1.0, K2], [0.0, -10.0]])\n    A3 = np.array([[-1.0, K3, 0.0], [0.0, -1.0, K3], [0.0, 0.0, -1.0]])\n\n    test_cases = [A1, A2, A3]\n\n    # Shared parameters for all cases\n    T = 8.0\n    Nt = 601\n    t_grid = np.linspace(0, T, Nt)\n\n    eps_vals = [1e-1, 5e-2]\n\n    x_range = np.arange(-5.0, 1.5 + 0.05, 0.05)\n    y_range = np.arange(-20.0, 20.0 + 0.1, 0.1)\n\n    delta_bound = 2e-2\n    Omega_bound = 50.0\n    N_omega_bound = 1001\n\n    all_results = []\n\n    for A in test_cases:\n        # Step 2: Compute observed transient growth\n        n = A.shape[0]\n        identity = np.eye(n)\n        \n        etA_norms = [np.linalg.norm(expm(A * t), ord=2) for t in t_grid]\n        \n        M_obs = np.max(etA_norms)\n        # Find the smallest t at which the maximum occurs\n        t_star_idx = np.argmax(etA_norms)\n        t_star = t_grid[t_star_idx]\n\n        alpha_A = np.max(np.real(np.linalg.eigvals(A)))\n\n        # Step 3: Approximate epsilon-pseudospectral abscissa\n        alpha_eps_results = []\n        for eps in eps_vals:\n            max_x = -5.0  # Default value if no point is found\n            \n            # Using np.linalg.svd is more numerically stable than inv\n            # We check for sigma_min(zI - A) = eps\n            for x in x_range[::-1]: # Search from right to left for efficiency\n                found_in_col = False\n                for y in y_range:\n                    z = x + 1j * y\n                    # Smallest singular value of (zI - A)\n                    s_min = np.linalg.svd(z * identity - A, compute_uv=False)[-1]\n                    if s_min = eps:\n                        max_x = x\n                        found_in_col = True\n                        break # Found for this x, go to the next (larger) x\n                if found_in_col:\n                    break # exit x-loop\n            alpha_eps_results.append(max_x)\n        \n        alpha_eps_1 = alpha_eps_results[0]\n        alpha_eps_2 = alpha_eps_results[1]\n\n        # Step 4: Compute truncated pseudospectral bound\n        eps_bound = 1e-1\n        alpha_eps_A_for_bound = alpha_eps_1\n        \n        gamma = alpha_eps_A_for_bound + delta_bound\n        \n        omega_grid = np.linspace(-Omega_bound, Omega_bound, N_omega_bound)\n        \n        integrand_values = []\n        for omega in omega_grid:\n            z = gamma + 1j * omega\n            # resolvent norm is 1 / sigma_min\n            s_min = np.linalg.svd(z * identity - A, compute_uv=False)[-1]\n            integrand_values.append(1.0 / s_min)\n            \n        integral = np.trapz(integrand_values, omega_grid)\n        \n        B_eps = (np.exp(gamma * t_star) / (2 * np.pi)) * integral\n\n        # Step 5: Collate results\n        case_results = [\n            M_obs,\n            t_star,\n            alpha_A,\n            alpha_eps_1,\n            alpha_eps_2,\n            B_eps\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Convert nested list to string with desired formatting\n    result_str = \"[\" + \", \".join([str(res) for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```",
                "id": "3591545"
            }
        ]
    }