{"hands_on_practices": [{"introduction": "在高能物理计算中，对运动学不变量的精确计算是所有后续分析的基石。然而，在粒子接近共线（即它们运动方向几乎相同）的极限情况下，直接使用定义进行计算可能会因浮点数的相消误差而导致灾难性的精度损失。本实践练习旨在通过对比一个直接计算方法和一个数值上更稳健的重缩放角度方法，来揭示这一关键问题，并强调在科学计算中采用鲁棒算法的重要性 [@problem_id:3538683]。", "problem": "考虑在度规符号为 $(+,-,-,-)$ 的闵可夫斯基空间中，对一对无质量四动量评估其运动学不变量，该不变量定义为 $s_{ij} = (p_i + p_j)^2$。在 Catani-Seymour (CS) 偶极子减除和 Frixione-Kunszt-Signer (FKS) 方案的背景下，$s_{ij}$ 在红外和共线极限附近的行为至关重要。您将对 $s_{ij}$ 接近机器精度值时的数值精度进行压力测试，并比较两种计算方法在评估一个依赖于 $s_{ij}$ 的简化偶极子因子时的稳定性。\n\n使用以下基本依据：\n- 对于四维矢量 $p^\\mu = (E, \\vec{p})$，其闵可夫斯基点积为 $p^2 = E^2 - \\|\\vec{p}\\|^2$。\n- 对于无质量动量，$E = \\|\\vec{p}\\|$ 且 $s_{ij} = 2\\,p_i \\cdot p_j = 2 E_i E_j \\left(1 - \\cos \\theta_{ij}\\right)$，其中 $\\theta_{ij}$ 是 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角。\n- 半角恒等式 $\\sin^2\\left(\\frac{\\theta}{2}\\right) = \\frac{1}{2}\\left(1 - \\cos \\theta\\right)$。\n\n为无质量动量定义两种 $s_{ij}$ 的计算方法：\n1. 直接不变量法：通过和 $(p_i + p_j)^2$ 的闵可夫斯基范数计算 $s_{ij}$，显式地构建空间分量以实现 $s_{ij} = (E_i + E_j)^2 - \\|\\vec{p}_i + \\vec{p}_j\\|^2$。当 $\\theta_{ij}$ 很小时，此评估需要减去两个几乎相等的大数。\n2. 重标度角方法：通过半角表示法 $s_{ij} = 4 E_i E_j \\sin^2\\left(\\frac{\\theta_{ij}}{2}\\right)$ 计算 $s_{ij}$，这避免了在共线极限下的灾难性抵消。\n\n定义简化偶极子因子 $D_{ij} = \\frac{1}{s_{ij}}$，它捕捉了与减除方案相关的主要共线敏感性。\n\n对于下方的每个测试用例，按如下方式在 $x$-$z$ 平面中构建无质量三动量：\n- 令 $\\vec{p}_i = (0, 0, E_i)$。\n- 令 $\\vec{p}_j = (E_j \\sin \\theta, 0, E_j \\cos \\theta)$。\n- 那么 $p_i = (E_i, \\vec{p}_i)$ 且 $p_j = (E_j, \\vec{p}_j)$。\n\n对于基准评估，使用 $s_{ij}^{\\text{true}} = 2 E_i E_j \\left(1 - \\cos \\theta\\right)$，其中对于非常小的角度，必须使用级数展开：\n$$\n1 - \\cos \\theta = \\frac{\\theta^2}{2} - \\frac{\\theta^4}{24} + \\frac{\\theta^6}{720} - \\frac{\\theta^8}{40320},\n$$\n对于较大的角度，使用精确的余弦值。\n\n为每个测试用例计算 $D_{ij}^{\\text{direct}}$ 和 $D_{ij}^{\\text{rescaled}}$ 相对于 $D_{ij}^{\\text{true}} = \\frac{1}{s_{ij}^{\\text{true}}}$ 的绝对相对误差。如果重标度角方法产生的绝对相对误差严格小于直接不变量法，则输出整数 $1$，否则输出 $0$。如果 $D_{ij}^{\\text{true}}$ 未定义或为无穷大（例如，当 $\\theta = 0$ 以致 $s_{ij}^{\\text{true}} = 0$ 时），则该用例输出 $0$。\n\n角度必须以弧度为单位提供，能量必须以吉电子伏特 (GeV) 为单位提供。不需要进行单位转换；计算纯粹是基于这些输入的无量纲比率和不变量。\n\n测试套件（能量单位为 GeV，角度单位为弧度）：\n- 用例 A（理想情况）：$(E_i, E_j, \\theta) = (100, 100, 10^{-3})$。\n- 用例 B（近共线，小角度）：$(E_i, E_j, \\theta) = (10^{3}, 10^{3}, 10^{-12})$。\n- 用例 C（接近机器精度）：$(E_i, E_j, \\theta) = (10^{3}, 10^{3}, 10^{-16})$。\n- 用例 D（极端能量比，接近机器精度）：$(E_i, E_j, \\theta) = (10^{9}, 1, 10^{-16})$。\n- 用例 E（精确共线作为边界）：$(E_i, E_j, \\theta) = (100, 35, 0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述测试套件的顺序排列，例如 $\\left[\\texttt{resultA},\\texttt{resultB},\\texttt{resultC},\\texttt{resultD},\\texttt{resultE}\\right]$，其中每个条目是 $0$ 或 $1$。", "solution": "问题陈述已经过分析并被认为是**有效的**。它在科学上基于狭义相对论和计算物理学的原理，专门解决了在共线极限下计算运动学不变量时遇到的数值稳定性问题——这是高能物理学中次领头阶 (NLO) 计算的一个关键方面。该问题是适定的，所有必要的数据、公式和评估标准都已明确定义。\n\n核心任务是比较两种计算运动学不变量 $s_{ij} = (p_i + p_j)^2$ 的方法的数值稳定性。这里的 $p_i$ 和 $p_j$ 是两个无质量四动量，在其空间动量 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角 $\\theta_{ij}$ 趋近于零（共线极限）的极限情况下进行计算。稳定性通过计算每种方法得到的简化偶极子因子 $D_{ij} = 1/s_{ij}$ 相对于高精度基准值的绝对相对误差来评估。\n\n无质量粒子的四动量由 $p^\\mu = (E, \\vec{p})$ 给出，其中能量 $E$ 等于三动量的大小，$E = \\|\\vec{p}\\|$。度规符号为 $(+, -, -, -)$。不变量 $s_{ij}$ 解析上等价于 $s_{ij} = 2 p_i \\cdot p_j = 2 E_i E_j (1 - \\cos \\theta_{ij})$。\n\n问题为 $s_{ij}$ 定义了三种计算方法：基准方法、直接不变量法和重标度角方法。\n\n**1. 基准计算 ($s_{ij}^{\\text{true}}$)**\n\n基准值基于公式 $s_{ij}^{\\text{true}} = 2 E_i E_j (1 - \\cos \\theta)$。对于非常小的 $\\theta$，对项 $(1 - \\cos \\theta)$ 的朴素计算会遭受灾难性抵消，因为 $\\cos \\theta$ 趋近于 $1$。为确保参考值的高精度，问题强制要求对于小角度使用 $1 - \\cos \\theta$ 的泰勒级数展开：\n$$\n1 - \\cos \\theta = \\frac{\\theta^2}{2!} - \\frac{\\theta^4}{4!} + \\frac{\\theta^6}{6!} - \\frac{\\theta^8}{8!} + \\mathcal{O}(\\theta^{10})\n$$\n在我们的实现中，我们将对角度 $\\theta  10^{-6}$ 弧度使用此级数，这是一个阈值，低于该阈值时，对 $(1 - \\cos \\theta)$ 的标准双精度浮点运算开始损失显著精度。对于 $\\theta \\ge 10^{-6}$，直接计算足够精确。\n\n**2. 方法 1：直接不变量法 ($s_{ij}^{\\text{direct}}$)**\n\n该方法通过直接实现四维矢量和的不变量的定义来计算 $s_{ij}$：\n$$\ns_{ij}^{\\text{direct}} = (p_i + p_j)^2 = (E_i + E_j)^2 - \\|\\vec{p}_i + \\vec{p}_j\\|^2\n$$\n无质量三动量在 $x$-$z$ 平面中构建：$\\vec{p}_i = (0, 0, E_i)$ 和 $\\vec{p}_j = (E_j \\sin \\theta, 0, E_j \\cos \\theta)$。它们的和是 $\\vec{p}_i + \\vec{p}_j = (E_j \\sin \\theta, 0, E_i + E_j \\cos \\theta)$。范数的平方是：\n$$\n\\|\\vec{p}_i + \\vec{p}_j\\|^2 = (E_j \\sin \\theta)^2 + (E_i + E_j \\cos \\theta)^2 = E_j^2 \\sin^2 \\theta + E_i^2 + 2 E_i E_j \\cos \\theta + E_j^2 \\cos^2 \\theta = E_i^2 + E_j^2 + 2 E_i E_j \\cos \\theta\n$$\n将此代入 $s_{ij}^{\\text{direct}}$ 的表达式中得到：\n$$\ns_{ij}^{\\text{direct}} = (E_i^2 + 2 E_i E_j + E_j^2) - (E_i^2 + E_j^2 + 2 E_i E_j \\cos \\theta)\n$$\n在共线极限 ($\\theta \\to 0$) 下，$\\cos \\theta \\to 1$，因此 $\\|\\vec{p}_i + \\vec{p}_j\\|^2 \\to (E_i + E_j)^2$。该计算涉及两个非常大且几乎相等的数的减法，这是灾难性抵消和严重精度损失的典型来源。因此，预计此方法在小 $\\theta$ 情况下表现不佳。\n\n**3. 方法 2：重标度角方法 ($s_{ij}^{\\text{rescaled}}$)**\n\n此方法使用三角半角恒等式 $1 - \\cos \\theta = 2 \\sin^2(\\frac{\\theta}{2})$ 重构 $s_{ij}$ 的表达式。\n$$\ns_{ij}^{\\text{rescaled}} = 2 E_i E_j (1 - \\cos \\theta) = 2 E_i E_j \\left(2 \\sin^2\\left(\\frac{\\theta}{2}\\right)\\right) = 4 E_i E_j \\sin^2\\left(\\frac{\\theta}{2}\\right)\n$$\n对于小 $\\theta$，自变量 $\\theta/2$ 也很小，且 $\\sin(\\theta/2) \\approx \\theta/2$。该计算涉及小数的乘法，这是数值稳定的并能保持相对精度。预计此方法即使对于极小的角度也高度精确。\n\n**评估与比较**\n\n对于每个测试用例，我们计算偶极子因子 $D_{ij}^{\\text{direct}} = 1/s_{ij}^{\\text{direct}}$ 和 $D_{ij}^{\\text{rescaled}} = 1/s_{ij}^{\\text{rescaled}}$，并将它们与基准值 $D_{ij}^{\\text{true}} = 1/s_{ij}^{\\text{true}}$ 进行比较。比较指标是绝对相对误差，例如，对于直接方法：\n$$\n\\text{err}_{\\text{direct}} = \\left| \\frac{D_{ij}^{\\text{direct}} - D_{ij}^{\\text{true}}}{D_{ij}^{\\text{true}}} \\right| = \\left| \\frac{1/s_{ij}^{\\text{direct}} - 1/s_{ij}^{\\text{true}}}{1/s_{ij}^{\\text{true}}} \\right| = \\left| \\frac{s_{ij}^{\\text{true}}}{s_{ij}^{\\text{direct}}} - 1 \\right|\n$$\n后一种形式在计算上更可取，因为当偶极子因子非常大时，它更稳定。如果 $\\text{err}_{\\text{rescaled}}  \\text{err}_{\\text{direct}}$，则记录整数 $1$，否则记录 $0$。对于 $\\theta = 0$ 的情况，$s_{ij}^{\\text{true}}=0$，使得 $D_{ij}^{\\text{true}}$ 为无穷大；问题规定对于此边界情况输出 $0$。\n\n**测试用例分析：**\n- **用例 A ($E_i=100, E_j=100, \\theta=10^{-3}$):** 角度小但不极端。两种方法都应提供合理的结果，但预计重标度角方法会更精确。\n- **用例 B ($E_i=10^3, E_j=10^3, \\theta=10^{-12}$):** 角度非常小。直接方法将遭遇显著的灾难性抵消，产生一个高度不精确或为零的结果。重标度角方法将保持精确。\n- **用例 C ($E_i=10^3, E_j=10^3, \\theta=10^{-16}$):** 角度接近双精度浮点数的机器精度。在标准浮点运算中，`1 - cos(theta)` 项的计算结果恰好为零，导致直接方法完全失效 ($s_{ij}^{\\text{direct}}=0$)。而计算 $\\sin(\\theta/2)$ 的重标度角方法将产生一个有效的非零结果。\n- **用例 D ($E_i=10^{9}, E_j=1, \\theta=10^{-16}$):** 与用例 C 类似，但具有极端的能量比。由于角度小，加上能量的巨大数值范围，直接方法将再次失效。重标度角方法保持稳健。\n- **用例 E ($E_i=100, E_j=35, \\theta=0$):** 这代表了精确的共线奇点。根据问题的规则，由于 $s_{ij}^{\\text{true}}=0$，输出为 $0$。\n\n基于此分析，我们预计对于所有 $\\theta$ 很小的情况（A、B、C、D），重标度角方法都将绝对优越，而用例 E 则由特定问题规则决定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical stability of two methods for calculating\n    the kinematic invariant s_ij in the collinear limit.\n    \"\"\"\n    # Test suite (E_i [GeV], E_j [GeV], theta [rad])\n    test_cases = [\n        (100.0, 100.0, 1.0e-3),   # Case A\n        (1.0e3, 1.0e3, 1.0e-12),  # Case B\n        (1.0e3, 1.0e3, 1.0e-16),  # Case C\n        (1.0e9, 1.0, 1.0e-16),    # Case D\n        (100.0, 35.0, 0.0),       # Case E\n    ]\n\n    results = []\n    \n    # Threshold for using Taylor series for 1 - cos(theta)\n    TAYLOR_THRESHOLD = 1.0e-6\n\n    for case in test_cases:\n        E_i, E_j, theta = case\n\n        # Per problem specification, if theta=0, output 0.\n        if theta == 0.0:\n            results.append(0)\n            continue\n\n        # 1. Ground-Truth Calculation (s_true)\n        # Use Taylor series for small theta to maintain high precision\n        if theta  TAYLOR_THRESHOLD:\n            theta2 = theta**2\n            theta4 = theta**4\n            theta6 = theta**6\n            theta8 = theta**8\n            # Series: theta^2/2 - theta^4/24 + theta^6/720 - theta^8/40320\n            one_minus_cos = theta2/2.0 - theta4/24.0 + theta6/720.0 - theta8/40320.0\n        else:\n            one_minus_cos = 1.0 - np.cos(theta)\n        \n        s_true = 2.0 * E_i * E_j * one_minus_cos\n        \n        # If s_true is zero (due to underflow), D_true is infinite/undefined. Output 0.\n        if s_true == 0.0:\n            results.append(0)\n            continue\n\n        # 2. Method 1: Direct Invariant (s_direct)\n        p_i_vec = np.array([0.0, 0.0, E_i])\n        p_j_vec = np.array([E_j * np.sin(theta), 0.0, E_j * np.cos(theta)])\n        p_sum_vec = p_i_vec + p_j_vec\n        p_sum_vec_norm_sq = np.dot(p_sum_vec, p_sum_vec)\n        s_direct = (E_i + E_j)**2 - p_sum_vec_norm_sq\n\n        # 3. Method 2: Rescaled-Angle (s_rescaled)\n        s_rescaled = 4.0 * E_i * E_j * (np.sin(theta / 2.0))**2\n\n        # 4. Comparison\n        # Handle cases where a method returns zero, implying infinite error.\n        if s_direct == 0.0:\n            # If direct method fails and rescaled doesn't, rescaled is better.\n            if s_rescaled != 0.0:\n                results.append(1)\n                continue\n            # If both fail, rescaled is not strictly better.\n            else:\n                results.append(0)\n                continue\n        \n        # If rescaled method fails (and direct didn't), it's not better.\n        if s_rescaled == 0.0:\n            results.append(0)\n            continue\n\n        # Calculate absolute relative errors using the stable form.\n        err_direct = abs(s_true / s_direct - 1.0)\n        err_rescaled = abs(s_true / s_rescaled - 1.0)\n        \n        if err_rescaled  err_direct:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3538683"}, {"introduction": "一旦我们掌握了如何可靠地进行数值计算，接下来的挑战便是如何验证一个复杂算法（如红外减除方案）的正确性。本实践将引导您实现一种重要的交叉验证技术：将一个复杂的局域减除方案（如 Catani-Seymour 或 FKS 方案）计算出的有限部分，与一个原理更简单、更直观的相空间切片方法得到的结果进行比较。在开发和调试高阶微扰计算程序时，这种验证是建立代码可信度的核心步骤 [@problem_id:3538697]。", "problem": "考虑一个玩具模型，用于在计算高能物理中处理红外发散的减除方案（如 Catani-Seymour 偶极减除和 Frixione-Kunszt-Signer (FKS) 减除）的背景下，对照相空间切片方法验证局域减除反项。假设实发射微分权重在一个由变量 $x \\in (0,1)$ 和 $z \\in (0,1)$ 构成的二维单位相空间上，由一个被积函数 $R(x,z)$ 建模，该函数具有软和共线奇异结构，当 $x \\to 0$ 和 $z \\to 1$ 时，这些结构分别由领头项近似。定义三个光滑函数\n$$\nA(x,z) = a_0 + a_1 x + a_2 (1 - z) + a_3 x (1 - z), \\quad\nB(x,z) = b_0 + b_1 x + b_2 (1 - z) + b_3 x (1 - z), \\quad\nG(x,z) = \\gamma\\, x^{r}\\, (1 - z)^{s},\n$$\n其参数 $a_0, a_1, a_2, a_3, b_0, b_1, b_2, b_3, \\gamma, r, s$ 为实数，其中 $\\gamma \\ge 0$，$r \\ge 0$，$s \\ge 0$。玩具模型的实发射被积函数为\n$$\nR(x,z) = \\frac{A(x,z)}{x} + \\frac{B(x,z)}{1 - z} + G(x,z).\n$$\n为模拟一个局域减除方案（本着 Catani-Seymour 或 Frixione-Kunszt-Signer 的精神），定义局域减除反项\n$$\nS_{\\text{soft}}(x,z) = \\frac{A(0,z)}{x}, \\qquad S_{\\text{coll}}(x,z) = \\frac{B(x,1)}{1 - z},\n$$\n其中 $A(0,z) = a_0 + a_2 (1 - z)$ 且 $B(x,1) = b_0 + b_1 x$。被减除的被积函数\n$$\nF(x,z) = R(x,z) - S_{\\text{soft}}(x,z) - S_{\\text{coll}}(x,z)\n$$\n在给定的多项式 $A(x,z)$ 和 $B(x,z)$ 下，必须在整个单位正方形上是有限的，前提是 $r \\ge 0$ 和 $s \\ge 0$。该减除方案的积分后有限余项定义为\n$$\nC_{\\text{sub}} = \\int_0^1 \\int_0^1 F(x,z)\\, \\mathrm{d}x\\, \\mathrm{d}z.\n$$\n独立地，定义一个在软和共线区域上都有红外截断 $\\delta \\in (0,1)$ 的相空间切片方案。实发射被积函数的切片积分为\n$$\nI_{\\text{slice}}(\\delta) = \\int_{0}^{1-\\delta} \\int_{\\delta}^{1} R(x,z)\\, \\mathrm{d}x\\, \\mathrm{d}z.\n$$\n为了分离出可与减除方案相比较的有限余项，考虑通过减去在互补变量上积分的领头奇异权重，来消除对截断值的对数依赖性：\n$$\nC_{\\text{slice}}(\\delta) = I_{\\text{slice}}(\\delta) - \\ln\\!\\left(\\frac{1}{\\delta}\\right)\\left(\\int_0^1 A(0,z)\\, \\mathrm{d}z + \\int_0^1 B(x,1)\\, \\mathrm{d}x\\right).\n$$\n交叉验证的目标是数值上证明，对于所描述的玩具模型，积分后有限余项的两种定义在极限 $\\delta \\to 0$ 下是等价的，即\n$$\n\\lim_{\\delta \\to 0} \\left[ C_{\\text{slice}}(\\delta) - C_{\\text{sub}} \\right] = 0.\n$$\n从以下基本点出发：红外发散表现为相对于红外安全检验函数的可积奇点，并且逐点减去领头奇异行为会使余项在整个相空间上可积。根据需要使用积分中值性质和控制收敛定理，但除了上述定义外，不要假定任何捷径公式。\n\n您的任务是编写一个完整的程序，该程序针对一组参数化的测试用例，计算 $C_{\\text{sub}}$ 和 $C_{\\text{slice}}(\\delta)$（其中截断值 $\\delta \\in \\{10^{-2}, 10^{-4}, 10^{-6}\\}$），并为每个测试用例和每个 $\\delta$ 返回绝对差 $\\left|C_{\\text{slice}}(\\delta) - C_{\\text{sub}}\\right|$。所有量都是无量纲的，因此不需要物理单位。角度没有出现，因此不需要指定角度单位。\n\n在指定定义域上稳健地实现数值积分。对于对数减除项，根据给定的多项式精确计算 $\\int_0^1 A(0,z)\\, \\mathrm{d}z$ 和 $\\int_0^1 B(x,1)\\, \\mathrm{d}x$。\n\n使用以下参数值测试套件，它探测了不同的奇异结构：\n- 测试用例1（仅软奇异行为）：$(a_0,a_1,a_2,a_3) = (2.0, 1.0, 0.5, 0.3)$，$(b_0,b_1,b_2,b_3) = (0.0, 0.0, 0.0, 0.0)$，$\\gamma = 0.2$，$r = 1.0$，$s = 1.0$。\n- 测试用例2（仅共线奇异行为）：$(a_0,a_1,a_2,a_3) = (0.0, 0.0, 0.0, 0.0)$，$(b_0,b_1,b_2,b_3) = (1.5, 0.4, 0.7, 0.2)$，$\\gamma = 0.3$，$r = 1.0$，$s = 1.0$。\n- 测试用例3（软和共线奇异行为组合）：$(a_0,a_1,a_2,a_3) = (1.0, 0.5, 0.2, 0.1)$，$(b_0,b_1,b_2,b_3) = (0.8, 0.3, 0.4, 0.1)$，$\\gamma = 0.25$，$r = 1.0$，$s = 0.5$。\n- 测试用例4（纯有限基线）：$(a_0,a_1,a_2,a_3) = (0.0, 0.0, 0.0, 0.0)$，$(b_0,b_1,b_2,b_3) = (0.0, 0.0, 0.0, 0.0)$，$\\gamma = 0.5$，$r = 0.0$，$s = 0.0$。\n\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个内部列表按顺序给出 $\\delta = 10^{-2}, 10^{-4}, 10^{-6}$ 的绝对差。例如，输出格式必须为\n$$\n[[\\text{d}_1(\\delta_1),\\text{d}_1(\\delta_2),\\text{d}_1(\\delta_3)],[\\text{d}_2(\\delta_1),\\text{d}_2(\\delta_2),\\text{d}_2(\\delta_3)],\\ldots]\n$$\n不含任何附加文本。", "solution": "该问题要求对一个用于处理高能物理计算中红外发散的局域减除方案的玩具模型进行数值验证。核心任务是证明，通过局域减除方法计算的实发射积分的有限部分 ($C_{\\text{sub}}$) 与通过相空间切片方法计算的有限部分 ($C_{\\text{slice}}(\\delta)$) 在切片截断值 $\\delta$ 趋近于零的极限下是等价的。\n\n首先，我们分析量 $C_{\\text{sub}}$，它是减除方案的积分后有限余项。其定义为：\n$$\nC_{\\text{sub}} = \\int_0^1 \\int_0^1 F(x,z)\\, \\mathrm{d}x\\, \\mathrm{d}z\n$$\n被积函数 $F(x,z)$ 是实发射被积函数 $R(x,z)$ 减去局域减除反项 $S_{\\text{soft}}(x,z)$ 和 $S_{\\text{coll}}(x,z)$：\n$$\nF(x,z) = R(x,z) - S_{\\text{soft}}(x,z) - S_{\\text{coll}}(x,z)\n$$\n代入 $R$、$S_{\\text{soft}}$ 和 $S_{\\text{coll}}$ 的定义：\n$$\nF(x,z) = \\left( \\frac{A(x,z)}{x} + \\frac{B(x,z)}{1 - z} + G(x,z) \\right) - \\frac{A(0,z)}{x} - \\frac{B(x,1)}{1 - z}\n$$\n通过重新整理各项，我们可以看到奇点是如何被局域抵消的：\n$$\nF(x,z) = \\frac{A(x,z) - A(0,z)}{x} + \\frac{B(x,z) - B(x,1)}{1-z} + G(x,z)\n$$\n让我们计算分子部分。给定 $A(x,z) = a_0 + a_1 x + a_2 (1 - z) + a_3 x (1 - z)$，我们有 $A(0,z) = a_0 + a_2(1-z)$。差值为：\n$$\nA(x,z) - A(0,z) = (a_0 + a_1 x + a_2 (1 - z) + a_3 x (1 - z)) - (a_0 + a_2(1-z)) = a_1 x + a_3 x (1-z) = x(a_1 + a_3(1-z))\n$$\n因此，$F(x,z)$ 的第一项简化为一个正则多项式：\n$$\n\\frac{A(x,z) - A(0,z)}{x} = a_1 + a_3(1-z)\n$$\n同样，对于第二项，有 $B(x,z) = b_0 + b_1 x + b_2 (1 - z) + b_3 x (1 - z)$ 和 $B(x,1) = b_0 + b_1 x$，差值为：\n$$\nB(x,z) - B(x,1) = (b_0 + b_1 x + b_2 (1 - z) + b_3 x (1 - z)) - (b_0 + b_1 x) = b_2(1-z) + b_3 x (1-z) = (1-z)(b_2 + b_3 x)\n$$\n这简化了第二项：\n$$\n\\frac{B(x,z) - B(x,1)}{1-z} = b_2 + b_3 x\n$$\n因此，被减除的被积函数 $F(x,z)$ 是在整个定义域 $[0,1] \\times [0,1]$ 上正则函数的和：\n$$\nF(x,z) = (a_1 + a_3(1-z)) + (b_2 + b_3 x) + \\gamma x^r (1-z)^s\n$$\n由于 $F(x,z)$ 是正则的，其积分 $C_{\\text{sub}}$ 可以解析计算。我们对每一项在 $x \\in [0,1]$ 和 $z \\in [0,1]$ 上积分：\n$$\n\\int_0^1 \\int_0^1 a_1 \\, \\mathrm{d}x \\mathrm{d}z = a_1\n$$\n$$\n\\int_0^1 \\int_0^1 a_3(1-z) \\, \\mathrm{d}x \\mathrm{d}z = a_3 \\left( \\int_0^1 \\! \\mathrm{d}x \\right) \\left( \\int_0^1 (1-z) \\mathrm{d}z \\right) = a_3 (1) \\left[z - \\frac{z^2}{2}\\right]_0^1 = \\frac{a_3}{2}\n$$\n$$\n\\int_0^1 \\int_0^1 b_2 \\, \\mathrm{d}x \\mathrm{d}z = b_2\n$$\n$$\n\\int_0^1 \\int_0^1 b_3 x \\, \\mathrm{d}x \\mathrm{d}z = b_3 \\left( \\int_0^1 x \\mathrm{d}x \\right) \\left( \\int_0^1 \\! \\mathrm{d}z \\right) = b_3 \\left[\\frac{x^2}{2}\\right]_0^1 (1) = \\frac{b_3}{2}\n$$\n$$\n\\int_0^1 \\int_0^1 \\gamma x^r (1-z)^s \\, \\mathrm{d}x \\mathrm{d}z = \\gamma \\left( \\int_0^1 x^r \\mathrm{d}x \\right) \\left( \\int_0^1 (1-z)^s \\mathrm{d}z \\right) = \\gamma \\left[\\frac{x^{r+1}}{r+1}\\right]_0^1 \\left[-\\frac{(1-z)^{s+1}}{s+1}\\right]_0^1 = \\frac{\\gamma}{(r+1)(s+1)}\n$$\n将这些结果相加，得到 $C_{\\text{sub}}$ 的解析表达式：\n$$\nC_{\\text{sub}} = a_1 + \\frac{a_3}{2} + b_2 + \\frac{b_3}{2} + \\frac{\\gamma}{(r+1)(s+1)}\n$$\n接下来，我们分析量 $C_{\\text{slice}}(\\delta)$，其定义为：\n$$\nC_{\\text{slice}}(\\delta) = I_{\\text{slice}}(\\delta) - \\ln\\!\\left(\\frac{1}{\\delta}\\right)\\left(\\int_0^1 A(0,z)\\, \\mathrm{d}z + \\int_0^1 B(x,1)\\, \\mathrm{d}x\\right)\n$$\n积分 $I_{\\text{slice}}(\\delta)$ 在一个排除了奇点的区域上进行，因此是有限的。然而，完整的被积函数 $R(x,z)$ 足够复杂，需要进行数值积分。积分区域为 $x \\in [\\delta, 1]$ 和 $z \\in [0, 1-\\delta]$。\n$$\nI_{\\text{slice}}(\\delta) = \\int_{0}^{1-\\delta} \\int_{\\delta}^{1} \\left( \\frac{A(x,z)}{x} + \\frac{B(x,z)}{1 - z} + G(x,z) \\right) \\, \\mathrm{d}x\\, \\mathrm{d}z\n$$\n对数减除项需要对领头奇异行为进行解析积分。令 $I_{\\text{log}} = \\int_0^1 A(0,z)\\, \\mathrm{d}z + \\int_0^1 B(x,1)\\, \\mathrm{d}x$。我们计算这两个积分：\n$$\n\\int_0^1 A(0,z)\\, \\mathrm{d}z = \\int_0^1 (a_0 + a_2(1-z)) \\, \\mathrm{d}z = \\left[a_0 z + a_2\\left(z-\\frac{z^2}{2}\\right)\\right]_0^1 = a_0 + \\frac{a_2}{2}\n$$\n$$\n\\int_0^1 B(x,1)\\, \\mathrm{d}x = \\int_0^1 (b_0 + b_1 x) \\, \\mathrm{d}x = \\left[b_0 x + b_1 \\frac{x^2}{2}\\right]_0^1 = b_0 + \\frac{b_1}{2}\n$$\n因此，对数项的系数是：\n$$\nI_{\\text{log}} = a_0 + \\frac{a_2}{2} + b_0 + \\frac{b_1}{2}\n$$\n每个测试用例的步骤如下：\n1.  使用给定的参数，通过推导出的解析公式计算 $C_{\\text{sub}}$ 的精确值。\n2.  计算对数系数 $I_{\\text{log}}$ 的精确值。\n3.  对于每个截断值 $\\delta \\in \\{10^{-2}, 10^{-4}, 10^{-6}\\}$：\n    a. 通过在定义域 $x \\in [\\delta, 1]$ 和 $z \\in [0, 1-\\delta]$ 上对 $R(x,z)$ 进行积分，数值计算 $I_{\\text{slice}}(\\delta)$。\n    b. 计算 $C_{\\text{slice}}(\\delta) = I_{\\text{slice}}(\\delta) - \\ln(1/\\delta) \\cdot I_{\\text{log}}$。\n    c. 计算绝对差 $|C_{\\text{slice}}(\\delta) - C_{\\text{sub}}|$。\n预期是，随着 $\\delta$ 变小，这个差值会减小，从而证实两种正则化方法之间的一致性。程序实现了这一过程。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes and compares finite remainders from subtraction and slicing schemes\n    for a toy model of infrared divergences.\n    \"\"\"\n    \n    # Test cases:\n    # (a_0, a_1, a_2, a_3), (b_0, b_1, b_2, b_3), gamma, r, s\n    test_cases = [\n        ((2.0, 1.0, 0.5, 0.3), (0.0, 0.0, 0.0, 0.0), 0.2, 1.0, 1.0),\n        ((0.0, 0.0, 0.0, 0.0), (1.5, 0.4, 0.7, 0.2), 0.3, 1.0, 1.0),\n        ((1.0, 0.5, 0.2, 0.1), (0.8, 0.3, 0.4, 0.1), 0.25, 1.0, 0.5),\n        ((0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0), 0.5, 0.0, 0.0),\n    ]\n\n    deltas = [1e-2, 1e-4, 1e-6]\n\n    # Helper functions for the integrand components\n    def A_func(x, z, a_params):\n        a0, a1, a2, a3 = a_params\n        return a0 + a1 * x + a2 * (1.0 - z) + a3 * x * (1.0 - z)\n\n    def B_func(x, z, b_params):\n        b0, b1, b2, b3 = b_params\n        return b0 + b1 * x + b2 * (1.0 - z) + b3 * x * (1.0 - z)\n\n    def G_func(x, z, gamma, r, s):\n        # Use np.power for safe handling of 0**0 = 1\n        return gamma * np.power(x, r) * np.power(1.0 - z, s)\n\n    # The full real-emission integrand R(x, z)\n    def R_integrand(x, z, a_params, b_params, gamma, r, s):\n        # The integration domain for I_slice ensures x  0 and 1-z  0,\n        # so direct division is safe.\n        term_A = A_func(x, z, a_params) / x\n        term_B = B_func(x, z, b_params) / (1.0 - z)\n        term_G = G_func(x, z, gamma, r, s)\n        return term_A + term_B + term_G\n\n    all_results = []\n    for case in test_cases:\n        a_params, b_params, gamma, r, s = case\n        a0, a1, a2, a3 = a_params\n        b0, b1, b2, b3 = b_params\n\n        # 1. Calculate C_sub analytically\n        c_sub = a1 + a3 / 2.0 + b2 + b3 / 2.0 + gamma / ((r + 1.0) * (s + 1.0))\n\n        # 2. Calculate the logarithmic coefficient I_log analytically\n        i_log = (a0 + a2 / 2.0) + (b0 + b1 / 2.0)\n\n        case_diffs = []\n        for delta in deltas:\n            # 3a. Numerically evaluate I_slice(delta)\n            # nquad integrates func(x,y,...) over ranges=[[xmin,xmax],[ymin,ymax],...]\n            # The order of variables in the function must match the order in ranges.\n            integrand_args = (a_params, b_params, gamma, r, s)\n            ranges = [[delta, 1.0], [0.0, 1.0 - delta]]\n            \n            # Using lambda to match the argument signature for nquad\n            # The function to integrate takes x and z as first arguments\n            i_slice, _ = integrate.nquad(lambda x, z: R_integrand(x, z, *integrand_args), ranges)\n\n            # 3b. Calculate C_slice(delta)\n            c_slice = i_slice - np.log(1.0 / delta) * i_log\n            \n            # 3c. Compute the absolute difference\n            diff = np.abs(c_slice - c_sub)\n            case_diffs.append(diff)\n        \n        all_results.append(case_diffs)\n\n    # Format the final output string\n    # e.g., [[d_1(d_1),d_1(d_2),d_1(d_3)],[d_2(d_1),d_2(d_2),d_2(d_3)],...]\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3538697"}, {"introduction": "在前两个实践的基础上，我们从具体实现和验证转向更高层次的算法设计。本练习将减除方案的构建视为一个算法挑战：对于一个多粒子末态中已识别出的所有奇异性结构，我们如何系统且高效地分配减除项（偶极子）来完全覆盖它们，同时避免遗漏或重复计算？通过将粒子和偶极子分别建模为图的节点和边，本实践旨在设计一种启发式算法，以最小化偶极子的数量来优化计算效率，同时确保减除的完备性和唯一性，这是实现自动化NLO计算的核心任务之一 [@problem_id:3538667]。", "problem": "给定一组无质量的部分子，其三动量被建模为单位方向向量和能量。考虑部分子对之间的不变质量，该质量由无质量粒子的标准高能物理公式定义，其中共线奇异结构与不变质量的倒数成正比。具体来说，对于标号为 $i$ 和 $j$ 的部分子，定义\n$$\ns_{ij} = 2\\,p_i \\cdot p_j = 2\\,E_i E_j \\left(1 - \\cos\\theta_{ij}\\right),\n$$\n其中 $E_i$ 是部分子 $i$ 的能量，$p_i = \\left(E_i,\\,E_i\\,\\vec{n}_i\\right)$（$\\vec{n}_i$ 是单位三维向量），$\\theta_{ij}$ 是 $\\vec{n}_i$ 和 $\\vec{n}_j$ 之间的夹角。每当 $s_{ij}$ 足够小时，就会出现与 $1/s_{ij}$ 成正比的共线奇异贡献。\n\n在诸如Catani-Seymour偶极形式论等用于处理红外发散的减除方案中，每个奇异结构 $1/s_{ij}$ 都由一个且仅一个形式为 $D_{ij,k}$ 的偶极项覆盖，其中 $i$ 是发射子，$j$ 是未分辨部分子，$k$ 是旁观子。在本问题中，您将把偶极子建模为图中以部分子为节点的边：一条边连接发射子 $i$ 和旁观子 $k$，并被理解为覆盖所有分配给发射子 $i$ 且以 $k$ 为旁观子的奇异对 $(i,j)$。\n\n您的任务是设计并实现一种启发式算法，该算法在给定一组部分子和一个奇异性阈值后，选择一组发射子-旁观子边，以满足以下条件：\n- 覆盖所有与 $s_{ij}  \\tau$（给定阈值 $\\tau$ 的单位为 $\\text{GeV}^2$）的对 $\\{i,j\\}$ 相关联的奇异结构，\n- 通过将每个无序对 $\\{i,j\\}$ 精确分配给一条发射子-旁观子边来避免双重减除，\n- 最小化不同边的数量。\n\n请使用以下具有科学依据的建模和约束条件：\n- 所有部分子都是无质量的，能量 $E_i$ 的单位是 $\\text{GeV}$。单位向量 $\\vec{n}_i$ 定义方向，角度必须以弧度处理。\n- 如果 $s_{ij}  \\tau$（其中 $\\tau > 0$ 是给定的阈值，单位为 $\\text{GeV}^2$），则对 $\\{i,j\\}$ 被声明为奇异的。\n- 为确保唯一性并避免双重减除，请为每个奇异无序对 $\\{i,j\\}$ 确定性地选择发射子，规则如下：如果 $E_i > E_j$，则发射子为 $i$；如果 $E_j > E_i$，则发射子为 $j$；如果 $E_i = E_j$，则选择索引较小者，即 $\\min(i,j)$，为发射子。\n- 对于给定的发射子 $i$，定义 $J_i$ 为所有未分辨伴子 $j$ 的集合，这些伴子满足 $\\{i,j\\}$ 是奇异的且发射子选择规则选择了 $i$。\n- 对于每个发射子 $i$，优先选择单个旁观子 $k_i$ 来覆盖所有 $j \\in J_i$ 的对 $(i,j)$，条件是 $k_i \\neq i$ 且 $k_i \\notin J_i$。在有效的候选者中，选择能使 $s_{ik_i}$ 最大化的 $k_i$，并尽可能避免与发射子近共线，即优先选择满足 $s_{ik_i} \\ge \\tau$ 的候选者；如果没有候选者满足 $s_{ik_i} \\ge \\tau$，仍然选择使 $s_{ik_i}$ 最大化的候选者。\n- 如果没有适用于所有 $J_i$ 的单个有效旁观子（例如，如果 $\\{i\\} \\cup J_i$ 包含了所有其他部分子，导致无法选择 $k_i$），则回退到成对选择旁观子：对于每个 $j \\in J_i$，在所有满足 $k \\neq i$ 和 $k \\neq j$ 的候选者中选择 $k_{ij}$，该 $k_{ij}$ 能使 $s_{ik}$ 最大化，同时优先选择满足 $s_{ik} \\ge \\tau$ 的候选者（如果存在）。将对 $(i,j)$ 分配给边 $(i,k_{ij})$。\n- 所选边的集合是在分配中使用的不同发射子-旁观子对 $(i,k)$ 的集合。该算法的目标是在确保对奇异对进行精确、无重复的一一覆盖的同时，最小化这些不同边的数量。\n\n实现这个启发式算法，并为每个测试用例计算以下输出：\n- 整数 $M$，等于所选不同边的数量，\n- 布尔值 $C$，如果所有奇异对都被精确分配到一条边（完全覆盖），则为 $\\text{True}$，否则为 $\\text{False}$，\n- 布尔值 $U$，如果没有奇异对被分配超过一次（无双重减除），则为 $\\text{True}$，否则为 $\\text{False}$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身是一个形式为 $[M,C,U]$ 的列表。\n\n角度以弧度为单位，能量以 $\\text{GeV}$ 为单位，阈值 $\\tau$ 以 $\\text{GeV}^2$ 为单位。请使用以下包含五个案例的测试套件：\n\n- 案例1（多个对共享一个发射子；可以分组到同一个旁观子下）：\n    - $N=4$ 个部分子，\n    - 能量 $[100,\\,80,\\,70,\\,50]$，单位 $\\text{GeV}$，\n    - 方向：$\\vec{n}_0=(0,0,1)$, $\\vec{n}_1=(\\sin 0.001,0,\\cos 0.001)$, $\\vec{n}_2=(\\sin 0.002,0,\\cos 0.002)$, $\\vec{n}_3=(0,0,-1)$,\n    - 阈值 $\\tau = 1.0$，单位 $\\text{GeV}^2$。\n\n- 案例2（单个奇异对）：\n    - $N=4$ 个部分子，\n    - 能量 $[50,\\,120,\\,110,\\,60]$，单位 $\\text{GeV}$，\n    - 方向：$\\vec{n}_0=(0,0,-1)$, $\\vec{n}_1=(0,0,1)$, $\\vec{n}_2=(\\sin 0.001,0,\\cos 0.001)$, $\\vec{n}_3=(0,1,0)$,\n    - 阈值 $\\tau = 1.0$，单位 $\\text{GeV}^2$。\n\n- 案例3（两个不相交的发射子组）：\n    - $N=5$ 个部分子，\n    - 能量 $[100,\\,90,\\,70,\\,80,\\,60]$，单位 $\\text{GeV}$，\n    - 方向：$\\vec{n}_0=(0,0,1)$, $\\vec{n}_1=(\\sin 0.001,0,\\cos 0.001)$, $\\vec{n}_2=(0,0,-1)$, $\\vec{n}_3=(1,0,0)$, $\\vec{n}_4=(\\cos 0.001,\\sin 0.001,0)$,\n    - 阈值 $\\tau = 1.0$，单位 $\\text{GeV}^2$。\n\n- 案例4（无奇异对；空覆盖）：\n    - $N=4$ 个部分子，\n    - 能量 $[100,\\,90,\\,70,\\,60]$，单位 $\\text{GeV}$，\n    - 方向：$\\vec{n}_0=(0,0,1)$, $\\vec{n}_1=(0,1,0)$, $\\vec{n}_2=(1,0,0)$, $\\vec{n}_3=(0,0,-1)$,\n    - 阈值 $\\tau = 1.0 \\times 10^{-4}$，单位 $\\text{GeV}^2$。\n\n- 案例5（旁观子与发射子附近存在冲突；启发式算法偏好非奇异的旁观子）：\n    - $N=5$ 个部分子，\n    - 能量 $[100,\\,80,\\,75,\\,90,\\,50]$，单位 $\\text{GeV}$，\n    - 方向：$\\vec{n}_0=(0,0,1)$, $\\vec{n}_1=(\\sin 0.001,0,\\cos 0.001)$, $\\vec{n}_2=(\\sin 0.002,0,\\cos 0.002)$, $\\vec{n}_3=(\\sin 0.0015,0,\\cos 0.0015)$, $\\vec{n}_4=(-1,0,0)$,\n    - 阈值 $\\tau = 1.0$，单位 $\\text{GeV}^2$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[M,C,U]$ 形式的列表，因此完整输出是按指定顺序排列的五个列表的列表。", "solution": "该问题要求为分配偶极减除项实现一种特定的启发式算法，以覆盖高能部分子相互作用简化模型中的红外共线奇异性。解决方案必须细致地遵循规定的规则来识别奇异对、分配发射子和选择旁观子，目标是在确保对所有奇异性进行完全且唯一的覆盖的同时，最小化不同偶极子（发射子-旁观子边）的数量。\n\n问题的核心在于两个无质量部分子 $i$ 和 $j$ 之间的不变质量 $s_{ij}$，它们的四动量分别为 $p_i = (E_i, E_i\\vec{n}_i)$ 和 $p_j = (E_j, E_j\\vec{n}_j)$。洛伦兹不变量积为 $p_i \\cdot p_j = E_i E_j - \\vec{p}_i \\cdot \\vec{p}_j = E_i E_j - E_i E_j (\\vec{n}_i \\cdot \\vec{n}_j)$。不变质量的平方定义为 $s_{ij} = (p_i+p_j)^2 = p_i^2 + p_j^2 + 2p_i \\cdot p_j$。对于无质量部分子，$p_i^2 = 0$，因此我们有 $s_{ij} = 2 p_i \\cdot p_j$。鉴于 $\\vec{n}_i \\cdot \\vec{n}_j = \\cos\\theta_{ij}$，其中 $\\theta_{ij}$ 是部分子运动方向之间的夹角，公式为：\n$$\ns_{ij} = 2E_i E_j (1 - \\cos\\theta_{ij})\n$$\n如果一对部分子 $\\{i, j\\}$ 的不变质量 $s_{ij}$ 低于给定阈值 $\\tau$，则该对被视为奇异的。当 $\\theta_{ij} \\to 0$ 时，导致 $s_{ij} \\to 0$，从而产生共线奇异性。\n\n该算法按四个不同步骤进行：\n\n**步骤1：识别奇异对**\n首先，我们遍历总共 $N$ 个部分子中所有唯一的无序部分子对 $\\{i, j\\}$（其中 $i  j$）。对于每对，我们使用提供的能量 $E_i$ 和方向单位向量 $\\vec{n}_i$ 计算 $s_{ij}$。如果 $s_{ij}  \\tau$，则该对 $\\{i, j\\}$ 被分类为奇异对，并添加到一个奇异对集合中。这个集合代表了减除方案必须覆盖的所有奇异性。\n\n**步骤2：发射子分配**\n对于每个奇异对 $\\{i, j\\}$，一个部分子被指定为‘发射子’，另一个被指定为‘未分辨’部分子。此分配是确定性的，遵循指定的规则以防止歧义和重复计数：\n- 如果 $E_i > E_j$，部分子 $i$ 是发射子。\n- 如果 $E_j > E_i$，部分子 $j$ 是发射子。\n- 如果 $E_i = E_j$，索引较小的部分子，即 $\\min(i, j)$，是发射子。\n处理完所有奇异对后，我们按其分配的发射子对未分辨部分子进行分组。这会产生一个映射，其中每个活跃的发射子 $i$ 与其未分辨伴子集合 $J_i$ 相关联。\n\n**步骤3：旁观子选择和边分配**\n此步骤实现了选择旁观子并形成构成偶极子的发射子-旁观子边 $(i, k)$ 的核心启发式算法。该过程对每个发射子 $i$ 及其对应的未分辨伴子集合 $J_i$ 执行。\n\n**主要策略：** 算法首先尝试找到一个能为所有未分辨伴子 $j \\in J_i$ 服务的单个旁观子 $k_i$。这是首选策略，因为它最小化了不同偶极边的数量。一个有效的旁观子 $k_i$ 必须不是发射子本身 ($k_i \\neq i$)，也必须不是未分辨部分子之一 ($k_i \\notin J_i$)。\n如果潜在的共同旁观子集合非空，我们选择最优的一个 $k_i$。选择标准有两方面：\n1.  优先选择与发射子的不变质量 $s_{ik}$ 不是奇异的旁观子 $k$，即 $s_{ik} \\ge \\tau$。\n2.  在首选候选者中（或者如果没有首选候选者，则在所有候选者中），我们选择使 $s_{ik}$ 最大化的那个。\n一旦选定 $k_i$，边 $(i, k_i)$ 就被添加到所选边的集合中，并且所有奇异对 $(i, j)$（其中 $j \\in J_i$）都被分配到这单个边上。\n\n**回退策略：** 如果对于一个发射子 $i$ 及其所有伴子 $J_i$ 找不到单个有效的旁观子（这种情况发生在 $\\{i\\} \\cup J_i$ 包含所有部分子时），算法将采取成对分配的方式。对于每个未分辨部分子 $j \\in J_i$，它会从所有可用的部分子（$k \\neq i$ 且 $k \\neq j$）中单独选择最佳的旁观子 $k_{ij}$，使用与主要策略相同的偏好逻辑。然后，每个对 $(i, j)$ 都被分配给其自己的边 $(i, k_{ij})$。这确保了覆盖，但可能会增加不同边的总数。\n\n**步骤4：计算指标**\n最后，在处理完所有发射子之后，我们计算所需的输出指标：\n- $M$：在分配过程中收集到的不同发射子-旁观子边 $(i, k)$ 的总数。这对应于所选边集合的大小。\n- $C$：一个布尔值，指示是否完全覆盖。如果步骤1中识别的每个奇异对都已精确分配给一条边，则为 `True`。我们的实现通过使用字典将每个唯一的奇异对映射到其分配的边来确保这一点。\n- $U$：一个布尔值，指示覆盖的唯一性（无双重减除）。如果没有任何奇异对被分配到多于一条边，则为 `True`。这一属性由基于字典的分配数据结构固有地满足，其中每个奇异对都作为唯一的键。\n\n以下 Python 程序实现了这个完整的算法，处理了五个提供的测试用例，并按规定格式化了输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the heuristic, and print results.\n    \"\"\"\n\n    def _process_case(energies_list, vecs_list, tau):\n        \"\"\"\n        Implements the heuristic for a single test case.\n        \"\"\"\n        N = len(energies_list)\n        energies = np.array(energies_list, dtype=float)\n        directions = np.array(vecs_list, dtype=float)\n\n        # Step 1: Identify all singular pairs {i, j}\n        singular_pairs = set()\n        for i in range(N):\n            for j in range(i + 1, N):\n                cos_theta = np.dot(directions[i], directions[j])\n                # Safeguard against floating point inaccuracies\n                if cos_theta > 1.0:\n                    cos_theta = 1.0\n                s_ij = 2 * energies[i] * energies[j] * (1 - cos_theta)\n                if s_ij  tau:\n                    singular_pairs.add(tuple(sorted((i, j))))\n\n        # Step 2: Determine emitters and group by emitter\n        emitters = {}  # emitter_idx -> set of unresolved_idx\n        for i, j in singular_pairs:\n            # Pair is sorted, so i  j\n            emitter, unresolved = -1, -1\n            if energies[i] > energies[j]:\n                emitter, unresolved = i, j\n            elif energies[j] > energies[i]:\n                emitter, unresolved = j, i\n            else:  # energies[i] == energies[j]\n                emitter, unresolved = i, j  # emitter is min(i,j)\n            \n            if emitter not in emitters:\n                emitters[emitter] = set()\n            emitters[emitter].add(unresolved)\n        \n        # Step 3: Select spectators and assign edges\n        selected_edges = set()\n        assignments = {}  # maps singular_pair tuple to edge tuple\n\n        def find_best_spectator(emitter_idx, candidates, energies_np, vecs_np, tau_val):\n            if not candidates:\n                return None\n            \n            good_candidates = []\n            bad_candidates = []\n\n            for k in candidates:\n                cos_theta_ik = np.dot(vecs_np[emitter_idx], vecs_np[k])\n                if cos_theta_ik > 1.0:\n                    cos_theta_ik = 1.0\n                s_ik = 2 * energies_np[emitter_idx] * energies_np[k] * (1 - cos_theta_ik)\n                \n                if s_ik >= tau_val:\n                    good_candidates.append((s_ik, k))\n                else:\n                    bad_candidates.append((s_ik, k))\n            \n            if good_candidates:\n                best = max(good_candidates, key=lambda x: x[0])\n                return best[1]\n            elif bad_candidates:\n                best = max(bad_candidates, key=lambda x: x[0])\n                return best[1]\n            \n            return None\n\n        all_parton_indices = set(range(N))\n\n        for i, J_i in emitters.items():\n            # Primary Strategy: common spectator\n            possible_common_spectators = all_parton_indices - {i} - J_i\n            \n            if possible_common_spectators:\n                k_i = find_best_spectator(i, list(possible_common_spectators), energies, directions, tau)\n                if k_i is not None:\n                    edge = (i, k_i)\n                    selected_edges.add(edge)\n                    for j in J_i:\n                        pair = tuple(sorted((i, j)))\n                        assignments[pair] = edge\n                else: # Should not happen if possible_common_spectators is non-empty\n                    pass\n            else:\n                # Fallback Strategy: pairwise spectators\n                for j in J_i:\n                    possible_pairwise_spectators = all_parton_indices - {i, j}\n                    k_ij = find_best_spectator(i, list(possible_pairwise_spectators), energies, directions, tau)\n                    if k_ij is not None:\n                        edge = (i, k_ij)\n                        selected_edges.add(edge)\n                        pair = tuple(sorted((i, j)))\n                        assignments[pair] = edge\n                    else: # Should not happen if N >= 3\n                        pass\n\n        # Step 4: Compute final metrics\n        M = len(selected_edges)\n        C = (set(assignments.keys()) == singular_pairs)\n        U = True  # Guaranteed by dict structure for assignments\n\n        return [M, C, U]\n\n    test_cases = [\n        # Case 1\n        {'E': [100, 80, 70, 50], 'vecs': [(0,0,1), (np.sin(0.001),0,np.cos(0.001)), (np.sin(0.002),0,np.cos(0.002)), (0,0,-1)], 'tau': 1.0},\n        # Case 2\n        {'E': [50, 120, 110, 60], 'vecs': [(0,0,-1), (0,0,1), (np.sin(0.001),0,np.cos(0.001)), (0,1,0)], 'tau': 1.0},\n        # Case 3\n        {'E': [100, 90, 70, 80, 60], 'vecs': [(0,0,1), (np.sin(0.001),0,np.cos(0.001)), (0,0,-1), (1,0,0), (np.cos(0.001),np.sin(0.001),0)], 'tau': 1.0},\n        # Case 4\n        {'E': [100, 90, 70, 60], 'vecs': [(0,0,1), (0,1,0), (1,0,0), (0,0,-1)], 'tau': 1.0e-4},\n        # Case 5\n        {'E': [100, 80, 75, 90, 50], 'vecs': [(0,0,1), (np.sin(0.001),0,np.cos(0.001)), (np.sin(0.002),0,np.cos(0.002)), (np.sin(0.0015),0,np.cos(0.0015)), (-1,0,0)], 'tau': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case['E'], case['vecs'], case['tau'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3538667"}]}