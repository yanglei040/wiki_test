{"hands_on_practices": [{"introduction": "这项实践是应用软共线有效理论（SCET）的基石。我们将从零开始构建一个完整的计算框架，对$e^+e^-$湮灭过程中的推力（thrust）分布执行次领头对数（NLL）级别的重求和。通过这个练习[@problem_id:3531711]，你将巩固对因子化、重整化群演化以及如何选择典型标度来最小化大对数等核心概念的理解。", "problem": "考虑电子-正电子湮灭成强子的双喷注极限，该过程由推力变量 $\\tau = 1 - T$ 表征，其中 $T$ 是推力。在软-共线有效理论 (SCET) 框架下，小 $\\tau$ 极限下的微分推力分布可因子化为一个硬函数 $H(Q,\\mu)$、两个相同的喷注函数 $J(p^2,\\mu)$ 和一个软函数 $S(k,\\mu)$，其中 $Q$ 是质心能量。在次领头对数精度 (NLL) 下，使用反常维度的单圈表达式，控制这些函数标度依赖性的重整化群 (RG) 方程具有以下通用形式\n$$\n\\mu \\frac{d}{d\\mu} \\ln F = \\gamma_F(\\mu),\n$$\n其中 $F \\in \\{H,J,S\\}$，$\\gamma_F(\\mu)$ 是由尖点部分和非尖点部分组成的反常维度。假设有以下单圈输入：\n- 夸克尖点反常维度为 $\\Gamma_{\\text{cusp}}(\\alpha_s) = \\Gamma_0 \\frac{\\alpha_s}{4\\pi}$，其中 $\\Gamma_0 = 4 C_F$。\n- 单圈非尖点反常维度满足 RG 一致性 $\\gamma_H^0 + 2 \\gamma_J^0 + \\gamma_S^0 = 0$，并取为 $\\gamma_H^0 = -12 C_F$，$\\gamma_J^0 = 6 C_F$，$\\gamma_S^0 = 0$。\n- 强耦合的单圈量子色动力学 (QCD) $\\beta$-函数为 $\\beta(\\alpha_s) = \\mu \\frac{d\\alpha_s}{d\\mu} = - \\beta_0 \\frac{\\alpha_s^2}{2\\pi}$，其中 $\\beta_0 = \\frac{11 C_A}{3} - \\frac{4 T_F n_f}{3}$。使用 $C_F = \\frac{4}{3}$，$C_A = 3$，$T_F = \\frac{1}{2}$ 和 $n_f = 5$，以及在 $M_Z = 91.1876\\,\\text{GeV}$ 处的边界条件 $\\alpha_s(M_Z) = 0.118$。\n\n对于双喷注极限中的推力 $\\tau$，喷注函数和软函数的特征变量分别取为 $p^2 \\sim Q^2 \\tau$ 和 $k \\sim Q \\tau$。使用喷注函数和软函数的单圈表达式，并选择典则标度以最小化大对数，\n$$\n\\mu_H = Q, \\quad \\mu_J = Q \\sqrt{\\tau}, \\quad \\mu_S = Q \\tau,\n$$\n建立并求解 RG 方程，将 $H$、$J$ 和 $S$ 从它们的典则标度演化到一个公共标度 $\\mu = Q$。将在典则标度处的单圈匹配值视为单位1，即 $H(Q,\\mu_H)=1$，$J(Q^2 \\tau,\\mu_J)=1$ 和 $S(Q \\tau,\\mu_S)=1$，从而使重求和内容完全通过 RG 演化核进入。为避免非物理的朗道极点行为，施加一个低标度截断 $\\mu_{\\text{min}} = 1\\,\\text{GeV}$，并通过在所有对数和跑动耦合计算中用 $\\mu_{\\text{min}}$ 替换任何小于 $\\mu_{\\text{min}}$ 的 $\\mu$ 来冻结 $\\alpha_s(\\mu)$ 和典则标度的跑动。\n\n使用以下明确的单圈反常维度微分形式进行到 $\\mu = Q$ 的演化：\n- 硬函数：\n$$\n\\mu \\frac{d}{d\\mu} \\ln H = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\gamma_H^0 \\right].\n$$\n- 喷注函数（单个喷注）：\n$$\n\\mu \\frac{d}{d\\mu} \\ln J = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ -2 \\Gamma_0 \\left( 2 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_J^0 \\right].\n$$\n- 软函数：\n$$\n\\mu \\frac{d}{d\\mu} \\ln S = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\left( \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_S^0 \\right].\n$$\n\n将 NLL 重求和推力分布定义为在公共标度 $\\mu=Q$ 处求值的演化函数的乘积，\n$$\n\\left(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau}\\right)_{\\text{NLL}}(\\tau;Q) \\equiv H(Q,\\mu=Q) \\left[J(Q^2 \\tau,\\mu=Q)\\right]^2 S(Q \\tau,\\mu=Q),\n$$\n此量是无量纲的。使用单圈跑动耦合\n$$\n\\alpha_s(\\mu) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\alpha_s(\\mu_0)\\beta_0}{2\\pi} \\ln\\!\\left(\\frac{\\mu}{\\mu_0}\\right)},\n$$\n以 $\\mu_0 = M_Z$ 为参考标度，对 RG 方程从典则起始标度 $(\\mu_H,\\mu_J,\\mu_S)$ 到 $Q$ 在 $\\ln\\mu$ 上进行数值积分。\n\n你的程序必须为以下 $(Q,\\tau)$ 对的测试组计算重求和值：\n- $Q = 91.1876\\,\\text{GeV}$，$\\tau \\in \\{0.001, 0.010, 0.050, 0.100, 0.250\\}$，\n- $Q = 500\\,\\text{GeV}$，$\\tau \\in \\{0.010, 0.100\\}$。\n\n所有输出都是无量纲的浮点数。你的程序应生成单行输出，包含用方括号括起来的逗号分隔的结果列表（例如 `[r_1,r_2,...]`），顺序与上述参数集相同。对任何隐式的角量使用弧度，尽管此处没有直接要求。通过按规定实现 $\\mu_{\\text{min}}$ 冻结来确保数值稳定性。最终输出应为 Python 生成的完整精度的浮点数，无需四舍五入。", "solution": "用户提供了一个计算高能物理问题，要求在软-共线有效理论 (SCET) 框架下，计算电子-正电子湮灭中次领头对数 (NLL) 精度的重求和推力分布。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n- **可观测量**：双喷注极限下的推力分布，$\\tau = 1-T \\ll 1$。\n- **框架**：软-共线有效理论 (SCET)。\n- **因子化**：$\\frac{d\\sigma}{d\\tau} \\propto H(Q,\\mu) J(p^2,\\mu)^2 S(k,\\mu)$。\n- **RG 方程**：$\\mu \\frac{d}{d\\mu} \\ln F = \\gamma_F(\\mu)$，其中 $F \\in \\{H,J,S\\}$。\n- **反常维度 (单圈)**：\n  - 尖点：$\\Gamma_{\\text{cusp}}(\\alpha_s) = \\Gamma_0 \\frac{\\alpha_s}{4\\pi}$，其中 $\\Gamma_0 = 4 C_F$。\n  - 非尖点：$\\gamma_H^0 = -12 C_F$，$\\gamma_J^0 = 6 C_F$，$\\gamma_S^0 = 0$。\n  - RG 一致性：$\\gamma_H^0 + 2 \\gamma_J^0 + \\gamma_S^0 = 0$。\n- **QCD 参数**：\n  - SU(3) 色因子：$C_F = 4/3$，$C_A = 3$，$T_F = 1/2$。\n  - 活性味数目：$n_f = 5$。\n  - QCD $\\beta$-函数：$\\beta(\\alpha_s) = - \\beta_0 \\frac{\\alpha_s^2}{2\\pi}$，其中 $\\beta_0 = \\frac{11 C_A}{3} - \\frac{4 T_F n_f}{3}$。\n  - 强耦合：在 $M_Z = 91.1876\\,\\text{GeV}$ 时 $\\alpha_s(M_Z) = 0.118$。\n- **SCET 标度**：\n  - 特征标度：$p^2 \\sim Q^2 \\tau$，$k \\sim Q \\tau$。\n  - 典则标度：$\\mu_H = Q$，$\\mu_J = Q \\sqrt{\\tau}$，$\\mu_S = Q \\tau$。\n- **演化和边界条件**：\n  - 初始值：$H(Q,\\mu_H)=1$，$J(Q^2\\tau,\\mu_J)=1$ 和 $S(Q\\tau,\\mu_S)=1$。\n  - 演化目标标度：$\\mu = Q$。\n- **红外截断**：$\\mu_{\\text{min}} = 1\\,\\text{GeV}$。在计算 $\\alpha_s$ 和定义典则标度时，任何小于 $\\mu_{\\text{min}}$ 的标度 $\\mu$ 都用 $\\mu_{\\text{min}}$ 替换。\n- **用于演化的明确反常维度**：\n  - $\\mu \\frac{d}{d\\mu} \\ln H = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\gamma_H^0 \\right]$。\n  - $\\mu \\frac{d}{d\\mu} \\ln J = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ -2 \\Gamma_0 \\left( 2 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_J^0 \\right]$。\n  - $\\mu \\frac{d}{d\\mu} \\ln S = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\left( \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_S^0 \\right]$。\n- **最终可观测量**：$(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau})_{\\text{NLL}} = H(Q,Q) [J(Q^2\\tau,Q)]^2 S(Q\\tau,Q)$。\n- **数值任务**：使用单圈跑动耦合 $\\alpha_s(\\mu) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\alpha_s(\\mu_0)\\beta_0}{2\\pi} \\ln(\\mu/\\mu_0)}$（以 $\\mu_0 = M_Z$ 为参考标度），将 RG 方程从典则标度积分到 $\\mu=Q$。\n- **测试用例**：$(Q, \\tau)$ 对：$(91.1876\\,\\text{GeV}, \\{0.001, 0.010, 0.050, 0.100, 0.250\\})$ 和 $(500\\,\\text{GeV}, \\{0.010, 0.100\\})$。\n\n**步骤2：利用提取的给定条件进行验证**\n\n1.  **科学依据**：该问题位于微扰 QCD 和有效场论 (SCET) 的核心领域，这些是高能对撞机上精密物理研究的标准工具。推力分布的因子化、RG 演化的概念、反常维度和跑动耦合都是基本且完善的原理。所提供的单圈反常维度构成了一个内部一致的集合，确保了最终的物理可观测量与任意的重整化标度 $\\mu$ 无关，这可以通过对反常维度求和来验证：$\\gamma_H + 2\\gamma_J + \\gamma_S=0$。物理和数值参数都是标准的。\n2.  **适定性**：该问题要求解一个具有明确初始条件和积分限的一阶常微分方程组。在 $\\mu_{\\text{min}}$ 处的红外冻结程序避免了单圈跑动耦合的非物理朗道极点，确保了解的数值稳定性和唯一性。\n3.  **客观性**：问题以精确、定量的术语陈述，没有模糊或主观的陈述。唯一解所需的所有输入都已提供。\n\n该问题在科学上是合理的、适定的、客观的、完整的和一致的。它没有违反任何无效标准。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将开发一个解决方案。\n\n### 解决方案\n\nNLL 重求和推力分布由演化到公共标度 $\\mu=Q$ 的硬函数、喷注函数和软函数的乘积给出：\n$$\n\\left(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau}\\right)_{\\text{NLL}}(\\tau;Q) = H(Q,\\mu=Q) \\left[J(Q^2 \\tau,\\mu=Q)\\right]^2 S(Q \\tau,\\mu=Q)\n$$\n这些函数从它们的典则标度 $\\mu_H$、$\\mu_J$、$\\mu_S$ 开始演化，在这些标度上它们的值被固定为1。演化由 RG 方程控制。对于一个从初始标度 $\\mu_i$ 演化到最终标度 $\\mu_f$ 的通用函数 $F$，其解为：\n$$\nF(\\mu_f) = F(\\mu_i) \\exp\\left( \\int_{\\mu_i}^{\\mu_f} \\frac{d\\mu}{\\mu} \\gamma_F(\\mu) \\right)\n$$\n给定初始条件 $H(Q,\\mu_H)=1$，$J(Q^2\\tau,\\mu_J)=1$ 和 $S(Q\\tau,\\mu_S)=1$，我们可以确定在 $\\mu=Q$ 处的因子。\n\n1.  **硬函数**：典则标度为 $\\mu_H = Q$。演化从 $\\mu_i = Q$ 到 $\\mu_f = Q$。积分区间为零，因此没有演化。\n    $$ H(Q,\\mu=Q) = H(Q,\\mu_H) \\exp(0) = 1 $$\n\n2.  **喷注函数和软函数**：喷注函数和软函数从它们的典则标度 $\\mu_J = Q\\sqrt{\\tau}$ 和 $\\mu_S = Q\\tau$ 演化到最终标度 $\\mu=Q$。问题指定了一个红外截断 $\\mu_{\\text{min}}=1\\,\\text{GeV}$，这可以防止演化从微扰理论失效的标度开始。因此，积分的有效起始标度为：\n    $$ \\mu_{J,\\text{start}} = \\max(\\mu_J, \\mu_{\\text{min}}) = \\max(Q\\sqrt{\\tau}, 1\\,\\text{GeV}) $$\n    $$ \\mu_{S,\\text{start}} = \\max(\\mu_S, \\mu_{\\text{min}}) = \\max(Q\\tau, 1\\,\\text{GeV}) $$\n    因此，在 $\\mu = Q$ 处的演化函数由下式给出：\n    $$ J(Q^2\\tau, Q) = \\exp\\left( \\int_{\\mu_{J,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_J(\\mu) \\right) $$\n    $$ S(Q\\tau, Q) = \\exp\\left( \\int_{\\mu_{S,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_S(\\mu) \\right) $$\n    其中 $\\gamma_J(\\mu)$ 和 $\\gamma_S(\\mu)$ 是问题陈述中给出的反常维度。\n\n结合这些结果，重求和分布的最终表达式为：\n$$\n\\left(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau}\\right)_{\\text{NLL}} = \\exp\\left( 2 \\int_{\\mu_{J,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_J(\\mu) + \\int_{\\mu_{S,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_S(\\mu) \\right)\n$$\n被积函数根据给定的反常维度定义如下：\n$$\n\\gamma_J(\\mu) = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ -2 \\Gamma_0 \\left( 2 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_J^0 \\right]\n$$\n$$\n\\gamma_S(\\mu) = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\left( \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_S^0 \\right]\n$$\n强耦合 $\\alpha_s(\\mu)$ 根据单圈 RG 方程跑动：\n$$\n\\alpha_s(\\mu) = \\frac{\\alpha_s(M_Z)}{1 + \\frac{\\alpha_s(M_Z)\\beta_0}{2\\pi} \\ln\\!\\left(\\frac{\\mu}{M_Z}\\right)}\n$$\n参数由给定的色因子和 $n_f=5$ 计算得出：\n- $C_F = 4/3$，$C_A = 3$，$T_F = 1/2$，$n_f = 5$。\n- $\\beta_0 = \\frac{11 C_A}{3} - \\frac{4 T_F n_f}{3} = \\frac{11 \\cdot 3}{3} - \\frac{4 \\cdot (1/2) \\cdot 5}{3} = 11 - \\frac{10}{3} = \\frac{23}{3}$。\n- $\\Gamma_0 = 4 C_F = 16/3$。\n- $\\gamma_J^0 = 6 C_F = 8$。\n- $\\gamma_S^0 = 0$。\n\n计算需要对指数项进行数值积分。对于每个测试用例 $(Q, \\tau)$，我们将：\n1.  计算起始标度 $\\mu_{J,\\text{start}}$ 和 $\\mu_{S,\\text{start}}$。\n2.  使用标准的求积方法，对喷注函数和软函数的两个定积分进行数值计算。\n3.  结合结果以计算重求和分布的最终值。\n两个积分中的积分变量 $\\mu$ 都从一个起始标度（总是 $\\ge \\mu_{\\text{min}}$）跑到 $Q$。因此，跑动耦合 $\\alpha_s(\\mu)$ 的自变量始终处于公式有效的微扰区域内。\n该实现将定义用于跑动耦合和被积函数的函数，然后使用 `scipy.integrate.quad` 来执行数值积分。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    # --- Define constants and parameters ---\n    # Color factors and QCD parameters\n    CF = 4.0 / 3.0\n    CA = 3.0\n    TF = 1.0 / 2.0\n    NF = 5\n\n    # One-loop beta function coefficient\n    BETA0 = (11.0 * CA / 3.0) - (4.0 * TF * NF / 3.0)\n\n    # One-loop anomalous dimensions\n    GAMMA0 = 4.0 * CF\n    GAMMA_H0 = -12.0 * CF\n    GAMMA_J0 = 6.0 * CF\n    GAMMA_S0 = 0.0\n\n    # Strong coupling and reference scale\n    ALPHA_S_MZ = 0.118\n    MZ = 91.1876  # GeV\n\n    # Infrared cutoff\n    MU_MIN = 1.0  # GeV\n\n    # --- Define physical functions ---\n\n    # One-loop running strong coupling constant\n    # The problem asks to freeze the running below MU_MIN. However, the integration\n    # variable mu in our setup will always be >= MU_MIN, so the freeze mechanism\n    # is only relevant for setting the lower integration bounds. For completeness,\n    # a fully robust alpha_s function would handle mu  MU_MIN explicitly, but\n    # it's not triggered here.\n    def alpha_s(mu):\n        \"\"\"Calculates the one-loop running coupling alpha_s at scale mu.\"\"\"\n        # Effective scale after applying the freeze cutoff\n        mu_eff = max(mu, MU_MIN)\n        log_mu_over_mz = np.log(mu_eff / MZ)\n        denominator = 1.0 + (ALPHA_S_MZ * BETA0 / (2.0 * np.pi)) * log_mu_over_mz\n        return ALPHA_S_MZ / denominator\n\n    # Integrand for the jet function evolution kernel\n    def integrand_jet(mu, Q, tau, log_tau):\n        \"\"\"Returns the integrand for the jet function RG evolution over d(mu).\"\"\"\n        term1 = -2.0 * GAMMA0 * (2.0 * np.log(Q / mu) + log_tau)\n        term2 = GAMMA_J0\n        kernel = (alpha_s(mu) / (4.0 * np.pi)) * (term1 + term2)\n        return kernel / mu\n\n    # Integrand for the soft function evolution kernel\n    def integrand_soft(mu, Q, tau, log_tau):\n        \"\"\"Returns the integrand for the soft function RG evolution over d(mu).\"\"\"\n        term1 = 4.0 * GAMMA0 * (np.log(Q / mu) + log_tau)\n        term2 = GAMMA_S0\n        kernel = (alpha_s(mu) / (4.0 * np.pi)) * (term1 + term2)\n        return kernel / mu\n\n    def compute_resummed_xs(Q, tau):\n        \"\"\"Computes the NLL-resummed thrust distribution for given Q and tau.\"\"\"\n        \n        # Hard function does not evolve, H(Q,Q) = 1.\n        log_H = 0.0\n\n        # --- Jet function evolution ---\n        mu_J_canonical = Q * np.sqrt(tau)\n        mu_J_start = max(mu_J_canonical, MU_MIN)\n        \n        log_J = 0.0\n        if mu_J_start  Q:\n            log_tau = np.log(tau)\n            log_J, _ = quad(integrand_jet, mu_J_start, Q, args=(Q, tau, log_tau))\n        \n        # --- Soft function evolution ---\n        mu_S_canonical = Q * tau\n        mu_S_start = max(mu_S_canonical, MU_MIN)\n\n        log_S = 0.0\n        if mu_S_start  Q:\n            log_tau = np.log(tau)\n            log_S, _ = quad(integrand_soft, mu_S_start, Q, args=(Q, tau, log_tau))\n\n        # Combine the evolved functions\n        # Final observable = H * J^2 * S\n        # In log space: log(H) + 2*log(J) + log(S)\n        total_log_exponent = log_H + 2.0 * log_J + log_S\n        \n        return np.exp(total_log_exponent)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Q = 91.1876 GeV\n        (91.1876, 0.001),\n        (91.1876, 0.010),\n        (91.1876, 0.050),\n        (91.1876, 0.100),\n        (91.1876, 0.250),\n        # Q = 500 GeV\n        (500.0, 0.010),\n        (500.0, 0.100),\n    ]\n\n    results = []\n    for Q_val, tau_val in test_cases:\n        result = compute_resummed_xs(Q_val, tau_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\nsolve()\n```", "id": "3531711"}, {"introduction": "在完成一次基本的重求和计算之后，关键的下一步是评估其理论不确定性。这项实践[@problem_id:3531739]旨在探究一个主要的不确定性来源：我们对量子色动力学（QCD）$\\beta$函数的不完全了解。通过比较使用不同圈数精度的跑动耦合常数$\\alpha_s$得到的结果，我们可以量化理论预测的稳定性，并深入了解微扰级数的收敛行为。", "problem": "要求您在软-共线有效理论（SCET）的框架内，对量子色动力学（QCD）中重求和指数对强耦合常数跑动的敏感性进行数值研究。该研究必须比较使用三圈和四圈截断的 QCD beta 函数得到的结果。您的程序必须为指定的测试用例计算 Sudakov 指数和一个简单的重求和分布，然后量化因改变跑动圈阶而引起的偏移。\n\n从以下基本要素开始：\n\n1. 强耦合常数的重整化群方程由关于重整化标度的微分方程给出：\n$$\n\\frac{d\\,\\alpha_s(\\mu)}{d\\ln \\mu} \\equiv \\beta(\\alpha_s) \\, ,\n$$\n其中 beta 函数的微扰展开在圈阶 $N \\in \\{3,4\\}$ 处截断，\n$$\n\\beta(\\alpha_s) = -2\\,\\alpha_s \\sum_{n=0}^{N-1} \\beta_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1},\n$$\n其中系数 $\\beta_n$ 是 QCD 中修正最小减法方案（记为 $\\overline{\\mathrm{MS}}$）的系数。在此问题中，所有标度下都必须使用固定的活性夸克味数 $n_f = 5$。这些系数为：\n- $ \\beta_0 = 11 - \\frac{2}{3} n_f $,\n- $ \\beta_1 = 102 - \\frac{38}{3} n_f $,\n- $ \\beta_2 = \\frac{2857}{2} - \\frac{5033}{18} n_f + \\frac{325}{54} n_f^2 $,\n- $ \\beta_3 = \\frac{149753}{6} + 3564\\,\\zeta_3 - \\left(\\frac{1078361}{162} + \\frac{6508}{27}\\,\\zeta_3\\right) n_f + \\left(\\frac{50065}{162} + \\frac{6472}{81}\\,\\zeta_3\\right) n_f^2 + \\frac{1093}{729} n_f^3 $,\n其中 $\\zeta_3$ 是 Apéry 常数，即 3 处的 Riemann zeta 函数。\n\n2. 对于一个通用的全局事件形状对数 $L \\equiv \\ln(1/v)$，本问题中的 Sudakov 辐射子定义为积分\n$$\nR(L;Q) = 2 \\int_{\\mu_L}^{Q} \\frac{d\\mu'}{\\mu'} \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu')) \\, \\ln\\left(\\frac{Q}{\\mu'}\\right),\n$$\n其中下限标度由 $\\mu_L \\equiv Q e^{-L}$ 给出，硬标度 $Q$ 在测试用例中指定。尖点反常维度展开为\n$$\n\\Gamma_{\\mathrm{cusp}}(\\alpha_s) = \\sum_{n=0}^{2} \\Gamma_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1},\n$$\n使用量子色动力学色因子 $C_A = 3$、$C_F = 4/3$、$T_F = 1/2$ 以及 $n_f = 5$。截至三圈的系数为\n- $ \\Gamma_0 = 4 C_F $,\n- $ \\Gamma_1 = 4 C_F \\left[ \\left(\\frac{67}{9} - \\frac{\\pi^2}{3}\\right) C_A - \\frac{20}{9} T_F n_f \\right] $,\n- $ \\Gamma_2 = 4 C_F \\left[ C_A^2 \\left(\\frac{245}{6} - \\frac{134\\pi^2}{27} + \\frac{11\\pi^4}{45} + \\frac{22}{3}\\zeta_3\\right) + C_A T_F n_f \\left(-\\frac{418}{27} + \\frac{40\\pi^2}{27} - \\frac{56}{3}\\zeta_3\\right) + C_F T_F n_f \\left(-\\frac{55}{3} + 16 \\zeta_3\\right) - \\frac{16}{27} T_F^2 n_f^2 \\right].\n$\n\n3. 将此问题的 Sudakov 指数定义为 $S(Q,L) \\equiv R(L;Q)$，并定义一个简单的重求和分布\n$$\nD(v;Q) = \\frac{1}{v} \\, \\exp\\left[-R(L;Q)\\right] \\, \\frac{dR(L;Q)}{dL},\n$$\n其中 $L \\equiv \\ln(1/v)$，且导数根据 $R(L;Q)$ 的定义以及 $\\mu_L$ 与 $L$ 的关系计算得出。\n\n4. 耦合的边界条件：在 $ \\mu_0 = M_Z = 91.1876 \\, \\mathrm{GeV} $ 处使用 $ \\alpha_s(\\mu_0) = 0.118 $。本问题中所有能量均以 $\\mathrm{GeV}$ 为单位。输出 $S$ 和 $D$ 是无量纲的。\n\n5. 本任务的假设：忽略夸克阈值匹配，并将 $n_f = 5$ 视为在所有标度下固定；使用 $\\overline{\\mathrm{MS}}$ 方案；严格按照给出的定义使用。不涉及角度。您必须在 $\\ln \\mu$ 中数值求解跑动耦合微分方程，并数值计算积分。不允许使用 $R(L;Q)$ 或跑动耦合的封闭形式“快捷”表达式；您必须直接实现这些定义。\n\n算法要求：\n- 通过分别在 $N=3$ 和 $N=4$ 处截断 beta 函数，实现跑动耦合的三圈和四圈版本，同时将尖点反常维度固定在三圈。这样可以分离出对跑动的敏感性。\n- 对于每个测试用例，使用三圈 beta 函数计算 $S_3 \\equiv S(Q,L)$ 和 $D_3 \\equiv D(v;Q)$，并使用四圈 beta 函数计算 $S_4$ 和 $D_4$。然后计算偏移量 $\\Delta S \\equiv S_4 - S_3$ 和 $\\Delta D \\equiv D_4 - D_3$。\n\n数值细节：\n- 使用可靠的数值积分方法，对所有关于 $\\ln \\mu$ 或 $\\mu$ 的积分进行求值，并设置足够的绝对和相对容差，以确保最终输出结果至少有六位小数的稳定精度。\n- 确保跑动耦合解的积分范围覆盖所有测试用例所需的整个域，即从测试套件中最小的 $ \\mu_L $ 到最大的 $ Q $。\n- 程序必须将报告的每个浮点数四舍五入到六位小数。\n\n测试套件：\n使用以下测试用例列表，每个用例由 $(Q, v)$ 指定，其中 $Q$ 的单位为 $\\mathrm{GeV}$，$v$ 为无量纲：\n- 测试 $1$：$Q = 91.1876$，$v = 0.1$。\n- 测试 $2$：$Q = 30.0$，$v = 0.1$。\n- 测试 $3$：$Q = 91.1876$，$v = 0.9$。\n- 测试 $4$：$Q = 30.0$，$v = 0.3$。\n\n对于每个测试用例，您的程序必须按此顺序输出一个包含六个条目的列表：\n$[\\Delta S, \\Delta D, S_3, S_4, D_3, D_4]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有四个测试用例的结果列表，按顺序排列，格式为方括号内由逗号分隔的列表，例如：\n$[[\\Delta S_1,\\Delta D_1,S_{3,1},S_{4,1},D_{3,1},D_{4,1}],[\\Delta S_2,\\Delta D_2,S_{3,2},S_{4,2},D_{3,2},D_{4,2}],\\ldots]$。\n所有浮点数必须四舍五入到六位小数。不应打印任何额外文本。", "solution": "该问题要求对量子色动力学（QCD）中重求和可观测量对跑动的强耦合常数 $\\alpha_s$ 的圈阶的敏感性进行数值研究。具体来说，我们要比较当 $\\alpha_s(\\mu)$ 分别使用三圈和四圈 QCD beta 函数演化时，Sudakov 指数 $S$ 和重求和分布 $D$ 的结果。该研究的框架是软-共线有效理论（SCET），所有定义、常数和参数均已提供，必须按规定使用。\n\n问题的核心在于三个组成部分之间的相互作用：\n1.  由重整化群方程（RGE）控制的强耦合常数 $\\alpha_s(\\mu)$ 的跑动。\n2.  Sudakov 辐射子 $R(L;Q)$，它对大对数 $L$ 进行重求和，由一个涉及 $\\alpha_s(\\mu)$ 和尖点反常维度 $\\Gamma_{\\mathrm{cusp}}(\\alpha_s)$ 的积分定义。\n3.  一个重求和微分分布 $D(v;Q)$，它涉及 Sudakov 指数及其相对于对数 $L$ 的导数。\n\n计算策略是数值化地实现这些组件，并严格遵守所提供的理论公式。\n\n首先，我们处理强耦合常数 $\\alpha_s$ 的跑动。它随重整化标度 $\\mu$ 的演化由 RGE 描述：\n$$\n\\frac{d\\,\\alpha_s(\\mu)}{d\\ln \\mu} = \\beta(\\alpha_s)\n$$\n$\\beta$-函数以 $\\alpha_s$ 的微扰级数形式给出：\n$$\n\\beta(\\alpha_s) = -2\\,\\alpha_s \\sum_{n=0}^{N-1} \\beta_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1}\n$$\n问题指定我们必须对该级数的两种不同截断进行计算：$N=3$（三圈）和 $N=4$（四圈）。对于固定的活性夸克味数 $n_f=5$ 的系数 $\\beta_n$ 已被提供。这个一阶常微分方程（ODE）使用在 $\\mu_0 = M_Z = 91.1876 \\, \\mathrm{GeV}$ 处的初始条件 $\\alpha_s(\\mu_0) = 0.118$ 进行数值求解。我们使用一个 ODE 求解器，例如 `scipy.integrate.solve_ivp`，来获得两个连续的耦合插值函数 $\\alpha_{s,3\\text{-loop}}(\\mu)$ 和 $\\alpha_{s,4\\text{-loop}}(\\mu)$，其定义域覆盖了与测试用例相关的所有标度范围。\n\n接下来，我们为通用的事件形状对数 $L = \\ln(1/v)$ 定义 Sudakov 辐射子 $R(L;Q)$。其定义为：\n$$\nR(L;Q) = 2 \\int_{\\mu_L}^{Q} \\frac{d\\mu'}{\\mu'} \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu')) \\, \\ln\\left(\\frac{Q}{\\mu'}\\right)\n$$\n其中积分下限是软标度 $\\mu_L = Q e^{-L} = Qv$。尖点反常维度 $\\Gamma_{\\mathrm{cusp}}(\\alpha_s)$ 由其三圈展开式给出：\n$$\n\\Gamma_{\\mathrm{cusp}}(\\alpha_s) = \\sum_{n=0}^{2} \\Gamma_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1}\n$$\n系数 $\\Gamma_n$ 依赖于 QCD 色因子 $C_A=3$、$C_F=4/3$、$T_F=1/2$ 以及 $n_f=5$。为了便于数值计算，我们对 $R(L;Q)$ 的积分进行变量替换。令 $t = \\ln \\mu'$，则有 $d\\mu'/\\mu' = dt$，积分变为：\n$$\nR(L;Q) = 2 \\int_{\\ln \\mu_L}^{\\ln Q} dt \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(e^t)) \\, (\\ln Q - t)\n$$\n这种形式适合于数值积分，我们为此使用 `scipy.integrate.quad`。然后将 Sudakov 指数定义为 $S(Q,L) = R(L;Q)$。\n\n最终的可观测量是重求和分布 $D(v;Q)$：\n$$\nD(v;Q) = \\frac{1}{v} \\, \\exp\\left[-R(L;Q)\\right] \\, \\frac{dR(L;Q)}{dL}\n$$\n一个关键步骤是计算导数 $\\frac{dR}{dL}$。对积分进行朴素的数值微分是一个不好的做法。相反，我们可以对 $R(L;Q)$ 的定义应用 Leibniz 积分法则：\n$$\n\\frac{dR}{dL} = \\frac{d}{dL} \\left( 2 \\int_{Q e^{-L}}^{Q} \\frac{d\\mu'}{\\mu'} \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu')) \\, \\ln\\left(\\frac{Q}{\\mu'}\\right) \\right)\n$$\n上限 $Q$ 与 $L$ 无关，因此只有下限有贡献：\n$$\n\\frac{dR}{dL} = -2 \\left( \\frac{d(Q e^{-L})}{dL} \\right) \\frac{1}{Q e^{-L}} \\Gamma_{\\mathrm{cusp}}(\\alpha_s(Q e^{-L})) \\ln\\left(\\frac{Q}{Q e^{-L}}\\right)\n$$\n$$\n\\frac{dR}{dL} = -2 (-Q e^{-L}) \\frac{1}{Q e^{-L}} \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu_L)) \\ln(e^L) = 2 L \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu_L))\n$$\n这个解析结果提供了一种直接且高度精确的计算导数的方法，仅需要在单一标度 $\\mu_L = Qv$ 处计算 $\\alpha_s$。\n\n总的计算流程如下：\n1.  定义所有物理常数（$\\pi$、$\\zeta_3$、色因子）。\n2.  实现计算 $n_f=5$ 时的 $\\beta_n$ 和 $\\Gamma_n$ 系数的函数。\n3.  构建三圈和四圈的 $\\beta$-函数以及三圈的 $\\Gamma_{\\mathrm{cusp}}$ 函数。\n4.  从在 $\\mu_0 = M_Z$ 处的初始条件出发，数值求解 $\\alpha_s(\\mu)$ 的 RGE，生成两个在所需能量范围内有效的插值函数 $\\alpha_{s,3}$ 和 $\\alpha_{s,4}$。\n5.  对于每个测试用例对 $(Q, v)$：\n    a. 计算 $L=\\ln(1/v)$ 和 $\\mu_L=Qv$。\n    b. 通过数值积分各自包含 $\\alpha_{s,3}(e^t)$ 和 $\\alpha_{s,4}(e^t)$ 的被积函数，计算 $S_3 = R(L;Q)$ 和 $S_4 = R(L;Q)$。\n    c. 计算 $(\\frac{dR}{dL})_3 = 2L \\Gamma_{\\mathrm{cusp}}(\\alpha_{s,3}(\\mu_L))$ 和 $(\\frac{dR}{dL})_4 = 2L \\Gamma_{\\mathrm{cusp}}(\\alpha_{s,4}(\\mu_L))$。\n    d. 计算 $D_3 = \\frac{1}{v} e^{-S_3} (\\frac{dR}{dL})_3$ 和 $D_4 = \\frac{1}{v} e^{-S_4} (\\frac{dR}{dL})_4$。\n    e. 计算差值 $\\Delta S = S_4 - S_3$ 和 $\\Delta D = D_4 - D_3$。\n    f. 按指定顺序存储六个结果，并四舍五入到六位小数。\n6.  最后，将所有测试用例的汇总结果格式化为所要求的单行输出。\n这一稳健的流程确保了问题的所有约束都得到满足，并为所研究的理论不确定性提供了精确的量化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, special\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print the results as specified.\n    \"\"\"\n    \n    # ------------------ Physical Constants and Coefficients ------------------\n    \n    # Fundamental constants\n    ZETA_3 = special.zeta(3)\n    PI = np.pi\n\n    # QCD parameters\n    NF = 5      # Number of active quark flavors\n    CA = 3.0    # SU(3) Casimir C_A\n    CF = 4.0/3.0  # SU(3) Casimir C_F\n    TF = 0.5    # SU(3) fundamental trace normalization\n\n    # Initial condition for alpha_s running\n    ALPHA_S_MZ = 0.118\n    MU_Z = 91.1876  # GeV\n    \n    # Beta function coefficients for QCD with NF flavors\n    BETA_COEFFS = [\n        11.0 - 2.0/3.0 * NF,\n        102.0 - 38.0/3.0 * NF,\n        2857.0/2.0 - 5033.0/18.0 * NF + 325.0/54.0 * NF**2,\n        (149753.0/6.0 + 3564.0*ZETA_3) - (1078361.0/162.0 + 6508.0/27.0*ZETA_3) * NF \n        + (50065.0/162.0 + 6472.0/81.0*ZETA_3) * NF**2 + 1093.0/729.0 * NF**3,\n    ]\n\n    # Cusp anomalous dimension coefficients\n    GAMMA_COEFFS = [\n        4.0 * CF,\n        4.0 * CF * ((67.0/9.0 - PI**2/3.0) * CA - 20.0/9.0 * TF * NF),\n        4.0 * CF * (\n            CA**2 * (245.0/6.0 - 134.0*PI**2/27.0 + 11.0*PI**4/45.0 + 22.0/3.0*ZETA_3)\n            + CA * TF * NF * (-418.0/27.0 + 40.0*PI**2/27.0 - 56.0/3.0*ZETA_3)\n            + CF * TF * NF * (-55.0/3.0 + 16.0*ZETA_3)\n            - 16.0/27.0 * TF**2 * NF**2\n        ),\n    ]\n\n    # ------------------ Physics Functions ------------------\n\n    def beta_func(alpha_s, n_loops):\n        \"\"\"QCD beta function up to n_loops.\"\"\"\n        term = 0.0\n        for i in range(n_loops):\n            term += BETA_COEFFS[i] * (alpha_s / (4*PI))**(i+1)\n        return -2.0 * alpha_s * term\n\n    def gamma_cusp_func(alpha_s):\n        \"\"\"3-loop cusp anomalous dimension.\"\"\"\n        res = 0.0\n        for i in range(len(GAMMA_COEFFS)):\n            res += GAMMA_COEFFS[i] * (alpha_s / (4.0 * PI))**(i + 1)\n        return res\n\n    def get_alpha_s_solver(n_loops):\n        \"\"\"Returns an interpolating function for alpha_s(mu).\"\"\"\n        def RGE_dalpha_dlnmu(ln_mu, alpha_s):\n            return beta_func(alpha_s, n_loops)\n\n        # Determine scale range for ODE solver\n        min_mu, max_mu = 1.0, 150.0 # Safe range covering all test cases\n        ln_mu0 = np.log(MU_Z)\n        \n        # We solve from mu_Z to both lower and higher scales\n        sol_down = integrate.solve_ivp(\n            RGE_dalpha_dlnmu, \n            (ln_mu0, np.log(min_mu)), \n            [ALPHA_S_MZ],\n            dense_output=True, \n            rtol=1e-10, atol=1e-12\n        )\n        sol_up = integrate.solve_ivp(\n            RGE_dalpha_dlnmu, \n            (ln_mu0, np.log(max_mu)), \n            [ALPHA_S_MZ],\n            dense_output=True, \n            rtol=1e-10, atol=1e-12\n        )\n        \n        def alpha_s_interpolated(mu):\n            ln_mu = np.log(mu)\n            if ln_mu  ln_mu0:\n                return sol_down.sol(ln_mu)[0]\n            else:\n                return sol_up.sol(ln_mu)[0]\n\n        return alpha_s_interpolated\n\n    # ------------------ Main Calculation Logic ------------------\n\n    def process_case(Q, v, alpha_s_func):\n        \"\"\"Calculates S and D for a single test case and alpha_s function.\"\"\"\n        L = np.log(1.0 / v)\n        mu_L = Q * v\n\n        # Calculate Sudakov exponent S = R(L, Q)\n        def integrand_R(ln_mu, Q_val, alpha_s_solver):\n            mu = np.exp(ln_mu)\n            alpha_s = alpha_s_solver(mu)\n            return 2.0 * gamma_cusp_func(alpha_s) * (np.log(Q_val) - ln_mu)\n        \n        ln_mu_L = np.log(mu_L)\n        ln_Q = np.log(Q)\n\n        # The integration can result in 0 if limits are equal.\n        if np.isclose(ln_mu_L, ln_Q):\n            S = 0.0\n        else:\n            S, _ = integrate.quad(\n                integrand_R, ln_mu_L, ln_Q, \n                args=(Q, alpha_s_func),\n                epsabs=1e-12, epsrel=1e-10\n            )\n\n        # Calculate dR/dL\n        alpha_s_at_mu_L = alpha_s_func(mu_L)\n        dR_dL = 2.0 * L * gamma_cusp_func(alpha_s_at_mu_L)\n\n        # Calculate distribution D(v, Q)\n        D = (1.0 / v) * np.exp(-S) * dR_dL\n        \n        return S, D\n\n    # ------------------ Execution Flow ------------------\n    \n    # Get alpha_s solvers for 3-loop and 4-loop running\n    alpha_s_3loop = get_alpha_s_solver(n_loops=3)\n    alpha_s_4loop = get_alpha_s_solver(n_loops=4)\n\n    test_cases = [\n        (91.1876, 0.1),  # Test 1\n        (30.0, 0.1),     # Test 2\n        (91.1876, 0.9),  # Test 3\n        (30.0, 0.3),     # Test 4\n    ]\n\n    all_results = []\n    for Q_val, v_val in test_cases:\n        S3, D3 = process_case(Q_val, v_val, alpha_s_3loop)\n        S4, D4 = process_case(Q_val, v_val, alpha_s_4loop)\n        \n        delta_S = S4 - S3\n        delta_D = D4 - D3\n        \n        case_results = [delta_S, delta_D, S3, S4, D3, D4]\n        \n        rounded_results = [round(x, 6) for x in case_results]\n        all_results.append(f\"[{','.join(map(str, rounded_results))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3531739"}, {"introduction": "许多重要的散射过程，例如大型强子对撞机（LHC）上的过程，在初态和末态都涉及多个色荷粒子，这导致在重整化群演化下出现非平庸的色空间混合。这项实践[@problem_id:3531771]将超越简单的标量演化，处理色空间中软函数矩阵的演化。掌握这一技能需要运用矩阵对角化等线性代数工具，是朝着计算真实强子对撞机可观测量迈出的关键一步。", "problem": "本题要求您在软共线有效理论 (SCET) 的框架内，为无质量 $2 \\to 2$ 部分子散射实现色空间软函数的单圈重整化群演化。任务的重点是通过反常维度矩阵编码的色混合，并评估基底依赖性。请在一个简化的、科学一致的场景下进行，其中色空间维度为二，运动学为欧几里得 (类空) 的，以使所有对数均为实数且不出现库仑相。演化必须通过对角化反常维度矩阵来数值化地执行。\n\n基本依据和定义：\n- 色空间中软函数 $S(\\mu)$ 的重整化群方程 (RGE) 为\n$$\n\\frac{d}{d \\ln \\mu} S(\\mu) = \\Gamma_S^\\dagger(\\alpha_s(\\mu)) \\, S(\\mu) + S(\\mu) \\, \\Gamma_S(\\alpha_s(\\mu)) \\, ,\n$$\n其中 $\\Gamma_S(\\alpha_s)$ 是色空间中的软反常维度矩阵，$\\alpha_s(\\mu)$ 是在重整化标度 $\\mu$ 下的强耦合常数。\n- 在单圈水平，假设\n$$\n\\Gamma_S(\\alpha_s(\\mu)) = \\frac{\\alpha_s(\\mu)}{\\pi} \\, \\Gamma_S^{(1)} \\, ,\n$$\n其中 $\\Gamma_S^{(1)}$ 是一个由色因子和运动学对数决定的常数矩阵。\n- 使用强耦合常数的单圈跑动方程，\n$$\n\\frac{d \\alpha_s(\\mu)}{d \\ln \\mu} = - \\beta_0 \\, \\frac{\\alpha_s^2(\\mu)}{2 \\pi} \\, ,\n$$\n其中\n$$\n\\beta_0 = \\frac{11 C_A - 4 T_F n_f}{3} \\, ,\n$$\n其中 $C_A = N_c$，$C_F = \\frac{N_c^2 - 1}{2 N_c}$，$T_F = \\frac{1}{2}$，$n_f$ 是活性夸克味的数目；取 $N_c = 3$。\n- 演化方程的解可以用演化算符 $U(\\mu_f,\\mu_0)$ 表示，\n$$\nS(\\mu_f) = U^\\dagger(\\mu_f,\\mu_0) \\, S(\\mu_0) \\, U(\\mu_f,\\mu_0) \\, ,\n$$\n其中\n$$\nU(\\mu_f,\\mu_0) = \\exp\\!\\left( K(\\mu_f,\\mu_0) \\, \\Gamma_S^{(1)} \\right) \\, ,\n$$\n其中标量系数 $K(\\mu_f,\\mu_0)$ 由下式给出\n$$\nK(\\mu_f,\\mu_0) = \\int_{\\ln \\mu_0}^{\\ln \\mu_f} \\frac{\\alpha_s(\\mu)}{\\pi} \\, d \\ln \\mu = \\frac{2}{\\beta_0} \\ln \\left( \\frac{\\alpha_s(\\mu_0)}{\\alpha_s(\\mu_f)} \\right) \\, .\n$$\n使用单圈表达式\n$$\n\\alpha_s(\\mu_f) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\beta_0 \\, \\alpha_s(\\mu_0)}{2 \\pi} \\, \\ln \\left( \\frac{\\mu_f}{\\mu_0} \\right)} \\, .\n$$\n- 在所选的欧几里得运动学 ($t  0$, $u  0$, $s > 0$) 中，定义实数对数\n$$\nL_s = \\ln \\left( \\frac{s}{\\mu_0^2} \\right) \\, , \\quad L_t = \\ln \\left( \\frac{-t}{\\mu_0^2} \\right) \\, , \\quad L_u = \\ln \\left( \\frac{-u}{\\mu_0^2} \\right) \\, , \\quad \\Delta_{tu} = L_t - L_u \\, .\n$$\n对单圈软反常维度矩阵使用以下对称、实数的 $2 \\times 2$ 模型，该模型与色混合及欧几里得运动学一致：\n$$\n\\Gamma_S^{(1)} =\n\\begin{pmatrix}\nC_F \\, \\Delta_{tu}  \\frac{C_F \\, C_A}{2 N_c} \\, (L_s + \\Delta_{tu}) \\\\\n\\frac{C_F \\, C_A}{2 N_c} \\, (L_s + \\Delta_{tu})  \\frac{C_A}{2} \\, L_s + \\left( C_F - \\frac{C_A}{2} \\right) \\Delta_{tu}\n\\end{pmatrix} \\, ,\n$$\n其中 $N_c = 3$，$C_F = \\frac{4}{3}$，以及 $C_A = 3$。\n\n计算任务：\n1. 按照上述规定，通过对从 $\\mu_0$ 到 $\\mu_f$ 的单圈跑动耦合常数进行积分来构建 $K(\\mu_f,\\mu_0)$。所有标度 $\\mu$ 必须以 $\\mathrm{GeV}$ 为单位提供和处理，所有运动学不变量 $s$、$t$、$u$ 以 $\\mathrm{GeV}^2$ 为单位。角度必须以弧度为单位。\n2. 使用给定的公式和常数构成矩阵 $\\Gamma_S^{(1)}$。数值对角化 $\\Gamma_S^{(1)}$ 来计算\n$$\nU(\\mu_f,\\mu_0) = V \\, \\mathrm{diag}\\!\\left( e^{K \\lambda_i} \\right) \\, V^{-1} \\, ,\n$$\n其中 $\\lambda_i$ 是特征值，$V$ 是 $\\Gamma_S^{(1)}$ 的特征向量矩阵。然后计算\n$$\nS(\\mu_f) = U^\\dagger \\, S(\\mu_0) \\, U \\, ,\n$$\n其中 $S(\\mu_0)$ 取为一个对称正定矩阵。\n3. 使用由旋转角 $\\theta$ 参数化的幺正 (正交) 色基底变换 $R(\\theta)$ 来评估基底依赖性，\n$$\nR(\\theta) =\n\\begin{pmatrix}\n\\cos \\theta  -\\sin \\theta \\\\\n\\sin \\theta  \\cos \\theta\n\\end{pmatrix} \\, .\n$$\n通过以下方式变换到旋转后的基底\n$$\n\\Gamma_S^{(1)\\prime} = R \\, \\Gamma_S^{(1)} \\, R^{-1} = R \\, \\Gamma_S^{(1)} \\, R^T \\, , \\quad S(\\mu_0)^\\prime = R \\, S(\\mu_0) \\, R^T \\, .\n$$\n使用相同的步骤在旋转后的基底中演化以获得 $S(\\mu_f)^\\prime$。变换回原始基底，\n$$\n\\widetilde{S}(\\mu_f) = R^T \\, S(\\mu_f)^\\prime \\, R \\, ,\n$$\n并通过弗罗贝尼乌斯范数量化基底一致性\n$$\n\\Delta = \\left\\| \\widetilde{S}(\\mu_f) - S(\\mu_f) \\right\\|_F \\, .\n$$\n如果演化是基底无关的，标量 $\\Delta$ 在数值上应该很小。\n4. 为保证数值稳定性和清晰度，所有矩阵运算均使用双精度实现。确保 $S(\\mu_0)$ 是对称正定的；取\n$$\nS(\\mu_0) = \\begin{pmatrix} 1.0  0.2 \\\\ 0.2  0.6 \\end{pmatrix} \\, .\n$$\n\n测试套件：\n提供一个程序，运行以下四个测试用例；对每个用例，计算如上定义的标量 $\\Delta$。所有标度以 $\\mathrm{GeV}$ 为单位，不变量以 $\\mathrm{GeV}^2$ 为单位，角度以弧度为单位。\n- 用例1 (一般混合，大演化范围)：\n  - $\\mu_0 = 2$，$\\mu_f = 100$，$\\alpha_s(\\mu_0) = 0.30$，$n_f = 5$，\n  - $s = 10^4$，$t = -2000$，$u = -8000$ (注意 $s + t + u = 0$)，\n  - $\\theta = 0.3$。\n- 用例2 (边界条件，无演化)：\n  - $\\mu_0 = 2$，$\\mu_f = 2$，$\\alpha_s(\\mu_0) = 0.30$，$n_f = 5$，\n  - $s = 10^4$，$t = -2000$，$u = -8000$，\n  - $\\theta = 0.5$。\n- 用例3 (更重的运动学，强演化)：\n  - $\\mu_0 = 10$，$\\mu_f = 1000$，$\\alpha_s(\\mu_0) = 0.25$，$n_f = 5$，\n  - $s = 2 \\times 10^6$，$t = -5 \\times 10^5$，$u = -1.5 \\times 10^6$，\n  - $\\theta = 0.2$。\n- 用例4 (从电弱标度开始，中等演化)：\n  - $\\mu_0 = 91.1876$，$\\mu_f = 1000$，$\\alpha_s(\\mu_0) = 0.118$，$n_f = 5$，\n  - $s = 10^5$，$t = -4 \\times 10^4$，$u = -6 \\times 10^4$，\n  - $\\theta = \\frac{\\pi}{4}$。\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应于按所列顺序的一个测试用例的标量 $\\Delta$，例如 $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$。角度必须以弧度为单位提供；标度以 $\\mathrm{GeV}$ 为单位；不变量以 $\\mathrm{GeV}^2$ 为单位。不应打印任何额外文本。", "solution": "本问题要求在软共线有效理论（SCET）框架内，为一个简化的 $2 \\to 2$ 无质量部分子散射过程实现色空间软函数的单圈重整化群（RG）演化，并数值验证其基底无关性。\n\n解决方案的核心是计算演化算符 $U(\\mu_f, \\mu_0) = \\exp(K(\\mu_f,\\mu_0) \\, \\Gamma_S^{(1)})$，并用它来演化初始软函数矩阵 $S(\\mu_0)$。\n\n首先，计算标量演化核 $K(\\mu_f,\\mu_0)$。这需要根据给定的 $\\beta_0$ 和初始条件 $\\alpha_s(\\mu_0)$，利用单圈跑动公式计算出末态标度处的耦合常数 $\\alpha_s(\\mu_f)$，然后代入 $K = \\frac{2}{\\beta_0} \\ln(\\alpha_s(\\mu_0)/\\alpha_s(\\mu_f))$。\n\n接着，根据问题提供的运动学不变量和色因子，构建 $2 \\times 2$ 的实对称反常维度矩阵 $\\Gamma_S^{(1)}$。\n\n演化算符 $U$ 是一个矩阵指数，通过对 $\\Gamma_S^{(1)}$ 进行对角化来高效计算。设 $\\Gamma_S^{(1)} = V \\Lambda V^T$，则 $U = V e^{K\\Lambda} V^T$。演化后的软函数为 $S(\\mu_f) = U^T S(\\mu_0) U$。\n\n为验证基底无关性，我们引入一个由角度 $\\theta$ 参数化的旋转矩阵 $R(\\theta)$。我们将初始矩阵 $S(\\mu_0)$ 和反常维度矩阵 $\\Gamma_S^{(1)}$ 都变换到一个新的旋转基底中（例如 $S(\\mu_0)' = R S(\\mu_0) R^T$）。然后在这个新基底中重复上述完整的演化过程，得到 $S(\\mu_f)'$。最后，将 $S(\\mu_f)'$ 旋转回原始基底，得到 $\\widetilde{S}(\\mu_f) = R^T S(\\mu_f)' R$。\n\n最终，计算原始演化结果 $S(\\mu_f)$ 和从旋转基底变换回来的结果 $\\widetilde{S}(\\mu_f)$ 之间的差异，用弗罗贝尼乌斯范数 $\\Delta = \\| \\widetilde{S}(\\mu_f) - S(\\mu_f) \\|_F$ 来量化。一个接近零的 $\\Delta$ 值即可证实计算的基底无关性。该算法将使用 NumPy 实现，以确保矩阵运算的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used as per the problem scope and numpy's capabilities.\n\ndef solve():\n    \"\"\"\n    Solves the problem of Renormalization Group Evolution for a SCET soft function,\n    and verifies its basis independence.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixing, large evolution range)\n        {'mu0': 2.0, 'muf': 100.0, 'alpha_s_mu0': 0.30, 'nf': 5,\n         's': 1.0e4, 't': -2000.0, 'u': -8000.0, 'theta': 0.3},\n        # Case 2 (boundary condition, no evolution)\n        {'mu0': 2.0, 'muf': 2.0, 'alpha_s_mu0': 0.30, 'nf': 5,\n         's': 1.0e4, 't': -2000.0, 'u': -8000.0, 'theta': 0.5},\n        # Case 3 (heavier kinematics, strong evolution)\n        {'mu0': 10.0, 'muf': 1000.0, 'alpha_s_mu0': 0.25, 'nf': 5,\n         's': 2.0e6, 't': -5.0e5, 'u': -1.5e6, 'theta': 0.2},\n        # Case 4 (electroweak scale start, moderate evolution)\n        {'mu0': 91.1876, 'muf': 1000.0, 'alpha_s_mu0': 0.118, 'nf': 5,\n         's': 1.0e5, 't': -4.0e4, 'u': -6.0e4, 'theta': np.pi / 4.0}\n    ]\n\n    results = []\n    \n    # Fundamental constants and initial condition\n    Nc = 3.0\n    CF = (Nc**2 - 1.0) / (2.0 * Nc)\n    CA = Nc\n    TF = 0.5\n    S_mu0 = np.array([[1.0, 0.2], [0.2, 0.6]], dtype=np.float64)\n\n    for case in test_cases:\n        mu0 = case['mu0']\n        muf = case['muf']\n        alpha_s_mu0 = case['alpha_s_mu0']\n        nf = case['nf']\n        s, t, u = case['s'], case['t'], case['u']\n        theta = case['theta']\n        \n        # 1. Compute the evolution kernel K(muf, mu0)\n        beta0 = (11.0 * CA - 4.0 * TF * nf) / 3.0\n        \n        K = 0.0\n        # Avoid log(1) for mu0=muf case to prevent potential floating point issues.\n        # Although log(1) is exactly 0, log(muf/mu0) is more robust if scales are identical.\n        if mu0 != muf:\n            log_mu_ratio = np.log(muf / mu0)\n            alpha_s_muf = alpha_s_mu0 / (1.0 + beta0 * alpha_s_mu0 / (2.0 * np.pi) * log_mu_ratio)\n            # This can also be written using alpha_s_muf to be more explicit\n            log_alpha_ratio = np.log(alpha_s_mu0 / alpha_s_muf)\n            K = (2.0 / beta0) * log_alpha_ratio\n\n        # 2. Form the anomalous dimension matrix Gamma_S^(1)\n        mu0_sq = mu0**2\n        Ls = np.log(s / mu0_sq)\n        Lt = np.log(-t / mu0_sq)\n        Lu = np.log(-u / mu0_sq)\n        Delta_tu = Lt - Lu\n        \n        Gamma_S1_11 = CF * Delta_tu\n        Gamma_S1_12 = (CF * CA / (2.0 * Nc)) * (Ls + Delta_tu)\n        Gamma_S1_22 = (CA / 2.0) * Ls + (CF - CA / 2.0) * Delta_tu\n        \n        Gamma_S1 = np.array([[Gamma_S1_11, Gamma_S1_12],\n                             [Gamma_S1_12, Gamma_S1_22]], dtype=np.float64)\n\n        # Function to compute evolved S from Gamma and S0\n        def evolve_S(Gamma, S0, K_val):\n            if K_val == 0.0:\n                return S0\n            # Diagonalize the real symmetric matrix Gamma\n            eigenvalues, V = np.linalg.eigh(Gamma)\n            # Compute evolution operator U = V * exp(K*Lambda) * V_inv\n            # For real symmetric, V is orthogonal, so V_inv = V.T\n            exp_K_lambda = np.diag(np.exp(K_val * eigenvalues))\n            U = V @ exp_K_lambda @ V.T\n            # Evolve S. Since U is real, U_dagger = U.T\n            S_evolved = U.T @ S0 @ U\n            return S_evolved\n\n        # 3. Evolve in the original basis\n        S_muf = evolve_S(Gamma_S1, S_mu0, K)\n        \n        # 4. Assess basis dependence\n        # Define rotation matrix R\n        R = np.array([[np.cos(theta), -np.sin(theta)],\n                      [np.sin(theta),  np.cos(theta)]], dtype=np.float64)\n        \n        # Transform to the rotated basis\n        Gamma_S1_prime = R @ Gamma_S1 @ R.T\n        S_mu0_prime = R @ S_mu0 @ R.T\n\n        # Evolve in the rotated basis\n        S_muf_prime = evolve_S(Gamma_S1_prime, S_mu0_prime, K)\n        \n        # Transform back to the original basis\n        S_muf_tilde = R.T @ S_muf_prime @ R\n        \n        # Quantify basis-consistency by the Frobenius norm\n        Delta = np.linalg.norm(S_muf_tilde - S_muf, 'fro')\n        results.append(Delta)\n    \n    # Final print statement in the exact required format.\n    # Use exponential notation for small numbers to maintain precision in string representation.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```", "id": "3531771"}]}