{"hands_on_practices": [{"introduction": "在圈积分的数值计算中，尤其是在使用 Passarino-Veltman (PV) 张量约化后，我们经常会遇到大项之间几乎完全抵消的情况。最终的物理结果是这些大项相减后得到的微小残余，这对求和的数值稳定性提出了极高的要求。这项实践练习 [@problem_id:3525479] 将通过编程实现并比较朴素求和、成对求和 (pairwise summation) 与 Kahan 补偿求和等算法，让你亲手量化不同算法在处理这种“灾难性相消”问题时的精度损失，从而深刻理解在科学计算中选择合适算法的重要性。", "problem": "考虑对相空间点上单圈积分中张量系数的贡献进行数值累加。在许多由单圈积分的 Passarino–Veltman (PV) 张量约化产生的情形中，会出现大小相近但符号相反的大量项相互抵消，而最终的系数是这些抵消后得到的微小残差。设贡献值为实数，建模为一个序列 $\\{x_i\\}_{i=1}^N$，求和后得到部分张量系数 $S = \\sum_{i=1}^N x_i$。在浮点数算术中，数值求和的稳定性在很大程度上取决于求和算法。\n\n我们将比较并量化两种补偿求和策略相对于朴素求和的数值优势：\n- 朴素求和：按遇到顺序直接累加 $s \\leftarrow s + x_i$。\n- 成对求和：一种平衡二叉树求和方法，通过重复对相邻对求和来减小动态范围效应。\n- Kahan 补偿求和：一种补偿算法，通过维护一个误差累加器来减少低位比特的损失。\n\n在双精度 (IEEE 754 binary64) 算术下进行，其有效数位（significand）为 $p = 53$ 位。为进行精度评估，定义算法的绝对误差为 $e = |S_{\\text{alg}} - S_{\\text{true}}|$，其中 $S_{\\text{alg}}$ 是计算得到的双精度和，而 $S_{\\text{true}}$ 是精确有理数和 $\\sum_i x_i$ 经过正确舍入后的双精度值。定义归一化方法如下：\n- 若 $|S_{\\text{true}}|  0$，使用相对误差 $r = e / |S_{\\text{true}}|$。\n- 若 $|S_{\\text{true}}| = 0$，使用标度 $L_1 = \\sum_{i=1}^N |x_i|$ 并取 $r = e / L_1$。\n根据 $r$，定义正确比特数为 $b = -\\log_2(r)$ (当 $r  0$ 时)，损失的比特数（相对于 53 位的有效数位）为 $\\ell = \\max(0,\\, p - b)$。若 $r = 0$，则设 $\\ell = 0$。\n\n实现这三种求和算法，并针对以下四个科学上合理的测试用例报告每种算法的 $\\ell$ 值。这些测试用例模拟了在 PV 约化和相空间采样后，对张量系数进行数值评估时遇到的近似抵消模式。在所有情况下，$x_i$ 都应构建为在可能时能被二进制浮点数精确表示的有理数（即整数和 2 的负整数次幂），以便获得精确的有理数基准真相。必须严格遵守序列的定义。\n\n测试套件：\n- 用例 A（带有缓慢变化偏移量的中度交替抵消）：设 $N = 20000$ 并定义\n  $$x_i = (-1)^i\\left(2^{-20} + (i+1)2^{-44}\\right), \\quad i = 0,1,\\dots,N-1.$$\n  这模拟了交替出现的大贡献值与一个产生非零残差的、缓慢变化的小项。\n- 用例 B（通过交错大小项导致的灾难性局部抵消）：设 $M = 8000$，并创建重复 $M$ 次的三元组模式：\n  $$\\{2^{30},\\, 2^{-40},\\, -2^{30}\\}.$$\n  每个三元组的精确和为 $2^{-40}$，但按朴素的遇到顺序，在 $2^{30}$ 之后立即加上 $2^{-40}$ 会导致严重的精度损失。\n- 用例 C（具有动态范围和对抗性顺序的精确零和）：设 $M = 7000$，并创建重复 $M$ 次的四元组模式：\n  $$\\{2^{30},\\, 2^{-45},\\, -2^{30},\\, -2^{-45}\\}.$$\n  精确和为 $0$，但朴素顺序下的舍入行为可能累积出非零残差。\n- 用例 D（可变大尺度与小残差）：设 $M = 6000$，对 $k = 1,2,\\dots,M$ 创建三元组\n  $$\\{2^{25} + k,\\, 2^{-50},\\, -(2^{25} + k)\\}.$$\n  每个三元组的精确和为 $2^{-50}$，用以测试在不同的大数值下的稳定性。\n\n要求：\n- 使用整数和 2 的负整数次幂将序列 $\\{x_i\\}$ 构建为精确有理数值。计算精确有理数和 $S_{\\text{exact}} = \\sum_i x_i$。然后将 $S_{\\text{true}}$ 设置为 $S_{\\text{exact}}$ 经过正确舍入后的双精度值。\n- 实现：\n  1. 朴素求和：按序列顺序 $s \\leftarrow s + x_i$。\n  2. 成对求和：以平衡树方式重复对相邻对求和，直至只剩一个值。\n  3. Kahan 补偿求和：使用补偿变量 $c$，通过 $y = x_i - c$, $t = s + y$, $c = (t - s) - y$, $s = t$ 进行更新。\n- 对每个用例中的每种方法，使用上述定义计算损失的比特数 $\\ell$。若 $S_{\\text{true}} = 0$，则使用前述的 $L_1$ 归一化。以浮点数形式报告 $\\ell$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个三元素列表，顺序为 [naive, pairwise, kahan]。因此，最终输出必须是一个包含四个内部列表的单一列表：\n  $$\\text{Output} = [[\\ell_{\\text{naive,A}},\\ell_{\\text{pairwise,A}},\\ell_{\\text{kahan,A}}], [\\ell_{\\text{naive,B}},\\ell_{\\text{pairwise,B}},\\ell_{\\text{kahan,B}}], [\\ell_{\\text{naive,C}},\\ell_{\\text{pairwise,C}},\\ell_{\\text{kahan,C}}], [\\ell_{\\text{naive,D}},\\ell_{\\text{pairwise,D}},\\ell_{\\text{kahan,D}}]].$$\n无需涉及物理单位或角度；数值必须以无量纲浮点数的形式报告。", "solution": "在 Passarino–Veltman (PV) 张量约化后，对单圈积分的张量系数贡献进行求和时，其核心数值问题源于将大小相近但符号相反的大量项合并时产生的浮点舍入误差。相空间积分可能产生序列 $\\{x_i\\}$，其中 $x_i$ 数值很大且符号交替，而所求的系数是微小的残差。这要求使用精细的数值求和方法。\n\n浮点算术原理：\n- IEEE 754 binary64 的有效数位（significand）有 $p = 53$ 位。设机器 epsilon 在相对意义上为 $\\varepsilon \\approx 2^{-53}$。\n- 朴素求和 $s \\leftarrow s + x_i$ 会累积舍入误差。当被加数数量级差异巨大时，较小的项可能被完全“吞噬”（其最低有效位消失），当后续的减法操作揭示了这一信息损失时，此现象称为灾难性抵消。\n- 成对求和通过首先对数量级相似的数进行求和，减小了中间值的动态范围，从而减少了误差的增长。\n- Kahan 补偿求和增加了一个校正项 $c$ 来携带前向的舍入残差，捕获丢失的低位比特，并在后续的加法中将其重新注入。\n\n精度度量设计：\n给定一个算法的双精度输出 $S_{\\text{alg}}$ 和基准真相 $S_{\\text{true}}$（定义为精确有理数和 $S_{\\text{exact}} = \\sum_i x_i$ 经过正确舍入后的双精度值），定义绝对误差 $e = |S_{\\text{alg}} - S_{\\text{true}}|$。我们按如下方式对误差进行归一化：\n- 若 $|S_{\\text{true}}|  0$，使用 $r = e / |S_{\\text{true}}|$。\n- 若 $|S_{\\text{true}}| = 0$，使用标度 $L_1 = \\sum_i |x_i|$ 并设 $r = e / L_1$。这反映了对于真实和为零的情况，绝对误差必须在一个有意义的标度下进行评估，以避免除以零并反映问题的条件数。\n根据 $r$，定义正确比特数为 $b = -\\log_2(r)$ (当 $r  0$ 时)。将 binary64 解释为在有效数位中提供 $p = 53$ 位，则损失的比特数为 $\\ell = \\max(0, p - b)$。若 $r = 0$，则设 $\\ell = 0$。此度量标准量化了相对于理想的最佳舍入双精度结果，有效损失了多少位精度。\n\n算法细节：\n- 朴素求和实现为一个简单的循环，按输入顺序累加一个运行总和。它对输入顺序和动态范围很敏感。\n- 成对求和执行一个平衡二叉树约减。将相邻的对相加形成一个新的、更短的列表，并重复此过程直到只剩下一个值。这使得中间和的大小与输入值更接近，从而降低了舍入误差的增长，尤其是在对抗性顺序下。\n- Kahan 补偿求和维护一个补偿项 $c$，用于捕获每次加法中的舍入误差。对于每个 $x_i$，我们计算 $y = x_i - c$ 和 $t = s + y$，然后更新 $c = (t - s) - y$ 和 $s = t$。此策略恢复了许多丢失的低位比特。\n\n有理数基准真相：\n为避免浮点舍入污染基准真相，我们使用精确有理数构建测试序列：整数和 2 的幂可以产生在二进制浮点数中精确表示的值。使用精确有理数算术（例如，分数），我们精确计算 $S_{\\text{exact}}$。然后，我们通过正确舍入将 $S_{\\text{exact}}$ 转换为双精度以获得 $S_{\\text{true}}$。这确保我们仅测量由求和引起的误差，而不是最终格式中的表示误差。\n\n测试套件原理：\n- 用例 A 使用 $x_i = (-1)^i(2^{-20} + (i+1)2^{-44})$，其中 $i = 0, \\dots, 19999$。$2^{-20}$ 项交替出现并大部分抵消；$(i+1)2^{-44}$ 项缓慢变化并产生一个小的残差，模拟了在张量约化中常见的一种情况，即一个主导的交替结构与一个平缓的净漂移共存。\n- 用例 B 使用重复的三元组 $\\{2^{30}, 2^{-40}, -2^{30}\\}$。每个三元组的真实和是 $2^{-40}$。在 $2^{30}$ 之后立即进行朴素加法加上 $2^{-40}$ 会丢失低位比特，因为 $2^{-40} \\ll \\varepsilon \\cdot 2^{30} \\approx 2^{30}2^{-53} = 2^{-23}$。成对求和在加上 $2^{-40}$ 之前有效地将 $2^{30}$ 与 $-2^{30}$ 分组，从而保留了小的残差。Kahan 补偿求和也通过补偿恢复了丢失的比特。\n- 用例 C 使用重复的四元组 $\\{2^{30}, 2^{-45}, -2^{30}, -2^{-45}\\}$，其和精确为零。这个顺序导致在 $2^{30}$ 之后加上 $2^{-45}$ 时会损失其贡献，而后面的 $-2^{-45}$ 加法在朴素求和中可能产生非零残差。由于 $S_{\\text{true}} = 0$，我们用 $L_1$ 进行归一化。\n- 用例 D 使用可变大尺度的三元组 $\\{2^{25} + k, 2^{-50}, -(2^{25} + k)\\}$，其中 $k = 1, \\dots, 6000$。这测试了算法在变化的、局部抵消并带有小残差的大数值下的鲁棒性。\n\n实现计划：\n- 将每个测试用例生成为精确有理数列表。计算它们对应的双精度值用于求和。\n- 实现三种求和方法。\n- 通过精确求和有理数并转换为双精度来计算 $S_{\\text{true}}$。\n- 精确计算 $L_1$ 并转换为双精度。\n- 使用上述定义为每种方法计算损失的比特数。\n- 生成单行输出：一个包含四个内部列表的列表，每个内部列表按 [naive, pairwise, kahan] 的顺序包含三个浮点数。\n\n该过程清晰地将算法求和误差与表示误差分离开来，并对在模拟计算高能物理中遇到的张量系数近似抵消贡献的场景下，各种补偿求和方法进行了严格的定量比较。", "answer": "```python\nimport math\nfrom fractions import Fraction\n\ndef naive_sum(arr):\n    s = 0.0\n    for x in arr:\n        s += x\n    return s\n\ndef pairwise_sum(arr):\n    # Balanced binary-tree summation without sorting\n    n = len(arr)\n    if n == 0:\n        return 0.0\n    work = arr[:]\n    while len(work)  1:\n        new_work = []\n        it = iter(work)\n        for a in it:\n            try:\n                b = next(it)\n                new_work.append(a + b)\n            except StopIteration:\n                new_work.append(a)\n        work = new_work\n    return work[0]\n\ndef kahan_sum(arr):\n    s = 0.0\n    c = 0.0\n    for x in arr:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef bits_lost(computed, true_value, l1_scale, significand_bits=53):\n    error = abs(computed - true_value)\n    if abs(true_value)  0.0:\n        ratio = error / abs(true_value)\n    else:\n        ratio = (error / l1_scale) if l1_scale  0.0 else 0.0\n    if ratio == 0.0:\n        return 0.0\n    bits_correct = -math.log2(ratio)\n    lost = significand_bits - bits_correct\n    if lost  0.0:\n        lost = 0.0\n    return lost\n\ndef case_A():\n    # N = 20000, x_i = (-1)^i (2^-20 + (i+1) 2^-44), i = 0..N-1\n    N = 20000\n    exact = []\n    for i in range(N):\n        sign = 1 if (i % 2 == 0) else -1\n        term = Fraction(1, 2**20) + Fraction(i + 1, 2**44)\n        exact.append(sign * term)\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef case_B():\n    # M = 8000, triads {2^30, 2^-40, -2^30}\n    M = 8000\n    exact = []\n    for _ in range(M):\n        exact.append(Fraction(2**30, 1))\n        exact.append(Fraction(1, 2**40))\n        exact.append(Fraction(-2**30, 1))\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef case_C():\n    # M = 7000, quads {2^30, 2^-45, -2^30, -2^-45}; true sum = 0\n    M = 7000\n    exact = []\n    for _ in range(M):\n        exact.append(Fraction(2**30, 1))\n        exact.append(Fraction(1, 2**45))\n        exact.append(Fraction(-2**30, 1))\n        exact.append(Fraction(-1, 2**45))\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef case_D():\n    # M = 6000, triads {2^25 + k, 2^-50, -(2^25 + k)}, k=1..M\n    M = 6000\n    exact = []\n    for k in range(1, M + 1):\n        H = Fraction(2**25 + k, 1)\n        exact.append(H)\n        exact.append(Fraction(1, 2**50))\n        exact.append(-H)\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef solve():\n    # Generate test cases\n    test_cases = [case_A(), case_B(), case_C(), case_D()]\n    results = []\n    for floats, true_val, l1_val in test_cases:\n        # Compute sums\n        s_naive = naive_sum(floats)\n        s_pair = pairwise_sum(floats)\n        s_kahan = kahan_sum(floats)\n        # Compute bits lost\n        b_naive = bits_lost(s_naive, true_val, l1_val)\n        b_pair = bits_lost(s_pair, true_val, l1_val)\n        b_kahan = bits_lost(s_kahan, true_val, l1_val)\n        results.append([b_naive, b_pair, b_kahan])\n    # Print final output in required format\n    # Single line: list of four inner lists [naive, pairwise, kahan] for each case\n    print(f\"[{','.join(str(lst) for lst in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3525479"}, {"introduction": "理论计算的精度不仅取决于算法本身，还受到输入物理参数不确定性的影响。例如，单圈积分中的 Passarino-Veltman (PV) 系数是运动学不变量（如 $s$ 和 $t$）的函数，而这些不变量在实验中总存在测量误差。本练习 [@problem_id:3525497] 将指导你通过数值方法估算 PV 系数对运动学不变量的敏感度，即计算它们之间的雅可比矩阵，并最终量化输入误差如何传递到计算结果中，这是连接理论预测与实验验证的关键一环。", "problem": "考虑一个具有无质量外腿和相等内线质量的单圈积分的阶-1三角 Passarino–Veltman (PV) 张量约化。设运动学不变量为序对 $\\mathbf{k} = (s,t)$，单位为 $\\mathrm{GeV}^2$，其中 $u$ 由动量守恒确定为 $u = -s - t$。定义相等的内线质量参数 $m^2$，单位为 $\\mathrm{GeV}^2$。使用 Feynman 参数，引入分母\n$$\n\\Delta(x,y;s,t,m^2) = m^2 - s\\,x\\,y - t\\,y\\,(1-x-y) - u\\,x\\,(1-x-y),\n$$\n其中 $(x,y)$ 位于标准三角域 $\\{(x,y)\\,|\\,0 \\le x \\le 1,\\; 0 \\le y \\le 1-x\\}$ 内，且 $u = -s - t$。用于阶-1约化的 PV 张量矩系数可由以下参数矩积分表示：\n$$\nC_0(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{1}{\\Delta(x,y;s,t,m^2)}, \\quad\nC_1(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{x}{\\Delta(x,y;s,t,m^2)},\n$$\n$$\nC_2(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{y}{\\Delta(x,y;s,t,m^2)}.\n$$\n这些积分以一种数学上受控的方式，模拟了阶-1 PV 系数对运动学不变量的依赖关系。假设在分母上添加一个小的正调节子 $\\varepsilon$ 以确保数值稳定性，即用 $\\Delta + \\varepsilon$ 替换 $\\Delta$，其中 $\\varepsilon$ 的单位为 $\\mathrm{GeV}^2$，且其值与物理尺度相比小到可以忽略。\n\n假设不变量 $\\mathbf{k} = (s,t)$ 的测量不确定度为 $(\\delta s, \\delta t)$，单位均为 $\\mathrm{GeV}^2$。系数向量 $\\mathbf{C} = (C_0,C_1,C_2)$ 关于不变量的雅可比矩阵是一个 $3 \\times 2$ 矩阵\n$$\nJ(\\mathbf{k}) =\n\\begin{bmatrix}\n\\frac{\\partial C_0}{\\partial s}  \\frac{\\partial C_0}{\\partial t} \\\\\n\\frac{\\partial C_1}{\\partial s}  \\frac{\\partial C_1}{\\partial t} \\\\\n\\frac{\\partial C_2}{\\partial s}  \\frac{\\partial C_2}{\\partial t}\n\\end{bmatrix}.\n$$\n对于小的不确定度，线性误差传播给出 $\\delta \\mathbf{C} \\approx J(\\mathbf{k})\\,\\delta \\mathbf{k}$，且最坏情况下的放大因子（在欧几里得范数下）由 $J$ 的诱导算子2-范数界定，即\n$$\n\\|\\delta \\mathbf{C}\\|_2 \\le \\|J(\\mathbf{k})\\|_2 \\,\\|\\delta \\mathbf{k}\\|_2,\n$$\n其中 $\\|J(\\mathbf{k})\\|_2$ 是 $J(\\mathbf{k})$ 的最大奇异值，$\\|\\cdot\\|_2$ 表示欧几里得范数。量 $\\|\\delta \\mathbf{C}\\|_2$ 的单位是 $\\mathrm{GeV}^{-2}$。\n\n任务：从 Feynman 参数表示和诱导范数的定义出发，设计并实现一个程序，该程序能够：\n- 通过在参数域上使用稳健的求积法，对带有调节子分母 $\\Delta + \\varepsilon$ 的积分进行数值计算，求得 $C_0(s,t;m^2)$、$C_1(s,t;m^2)$ 和 $C_2(s,t;m^2)$。\n- 使用关于 $s$ 和 $t$ 的中心有限差分来近似计算雅可比矩阵 $J(\\mathbf{k})$，步长的选择需要平衡截断误差和舍入误差。\n- 通过奇异值分解计算诱导算子2-范数 $\\|J(\\mathbf{k})\\|_2$。\n- 对于每个测试用例，返回两个浮点数：最坏情况下的界 $B = \\|J(\\mathbf{k})\\|_2 \\,\\sqrt{(\\delta s)^2 + (\\delta t)^2}$ 和线性估计 $L = \\|J(\\mathbf{k})\\,(\\delta s,\\delta t)\\|_2$，两者均以 $\\mathrm{GeV}^{-2}$ 为单位，并按默认的浮点表示进行舍入。\n\n使用以下测试套件，其中所有量纲的单位均为 $\\mathrm{GeV}^2$：\n- 案例1（一般情况）：$s = 1.0$, $t = 0.5$, $m^2 = 1.0$, $(\\delta s, \\delta t) = (1.0\\times 10^{-3}, 2.0\\times 10^{-3})$。\n- 案例2（近似抵消）：$s = 2.0$, $t = -1.2$, $m^2 = 1.0$, $(\\delta s, \\delta t) = (5.0\\times 10^{-4}, 5.0\\times 10^{-4})$。\n- 案例3（小不变量）：$s = 0.05$, $t = -0.02$, $m^2 = 1.0$, $(\\delta s, \\delta t) = (1.0\\times 10^{-4}, 1.0\\times 10^{-4})$。\n\n你的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的结果列表，列表中的每个元素是对应一个测试用例的序对 $[B,L]$。例如，输出格式必须为 $[[B_1,L_1],[B_2,L_2],[B_3,L_3]]$ 的形式，所有量的单位均为 $\\mathrm{GeV}^{-2}$。", "solution": "这个问题是有效的，因为它提出了一个自洽的、有科学依据且良定的计算任务。它要求对一组单圈积分系数进行数值评估，并分析它们对运动学参数的敏感度。所提供的与高能物理中 Passarino-Veltman 约化相关的物理背景是合理的，其数学表述是精确且无歧义的。该问题通过设计一个结合了数值求积、有限差分微分和奇异值分解的算法来解决。\n\n问题的核心是确定系数向量 $\\mathbf{C} = (C_0, C_1, C_2)$ 对运动学不变量 $\\mathbf{k} = (s, t)$ 变化的敏感度。这种敏感度由雅可比矩阵 $J(\\mathbf{k})$ 体现。该分析依赖于几个独立的计算步骤。\n\n首先，我们必须定义向量函数 $\\mathbf{C}(s,t; m^2)$，其分量由以下积分表达式给出：\n$$ C_0(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{1}{\\Delta_{reg}(x,y;s,t,m^2,\\varepsilon)} $$\n$$ C_1(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{x}{\\Delta_{reg}(x,y;s,t,m^2,\\varepsilon)} $$\n$$ C_2(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{y}{\\Delta_{reg}(x,y;s,t,m^2,\\varepsilon)} $$\n分母 $\\Delta_{reg}$ 是函数 $\\Delta(x,y;s,t,m^2) = m^2 - s\\,x\\,y - t\\,y\\,(1-x-y) - u\\,x\\,(1-x-y)$（其中 $u = -s - t$）加上一个小的正调节子 $\\varepsilon$ 来防止除以零并确保数值稳定性。积分在由 $0 \\le x \\le 1$ 和 $0 \\le y \\le 1-x$ 定义的二维单形域上进行。这些二重积分使用一种稳健的求积方法进行数值计算，具体是 `scipy.integrate` 库中的 `dblquad` 函数。该函数在指定域上执行累次积分。\n\n第二，必须计算 $3 \\times 2$ 的雅可比矩阵 $J(\\mathbf{k})$。其元素是对于 $i \\in \\{0, 1, 2\\}$ 的偏导数 $\\frac{\\partial C_i}{\\partial s}$ 和 $\\frac{\\partial C_i}{\\partial t}$。由于对这些积分进行解析微分十分繁琐，我们使用中心有限差分法来近似这些导数。这种方法在截断误差和舍入误差之间提供了良好的平衡。雅可比矩阵的两列计算如下：\n$$ \\frac{\\partial \\mathbf{C}}{\\partial s} \\approx \\frac{\\mathbf{C}(s+h, t) - \\mathbf{C}(s-h, t)}{2h} $$\n$$ \\frac{\\partial \\mathbf{C}}{\\partial t} \\approx \\frac{\\mathbf{C}(s, t+h) - \\mathbf{C}(s, t-h)}{2h} $$\n此处，$\\mathbf{C}(s,t)$ 是为给定 $(s,t)$ 计算 $(C_0, C_1, C_2)$ 的向量函数，$h$ 是一个小步长，对于双精度计算，其选择在 $10^{-6}$ 的量级。每个偏导数向量的计算都需要两次调用数值积分程序。\n\n第三，我们确定最坏情况下的不确定度放大因子，它由雅可比矩阵的诱导算子2-范数 $\\|J(\\mathbf{k})\\|_2$ 给出。这个范数等价于矩阵 $J$ 的最大奇异值。我们使用奇异值分解（SVD）来计算通过数值方法获得的 $3 \\times 2$ 雅可比矩阵的奇异值，该方法在 `numpy.linalg.svd` 中实现。最大值 $\\sigma_{max}$ 给出 $\\|J(\\mathbf{k})\\|_2$。\n\n最后，在所有组件都准备就绪后，我们为每个测试用例计算所需的两个量。设不确定度向量为 $\\delta\\mathbf{k} = (\\delta s, \\delta t)^T$。\n1.  最坏情况下的不确定度界 $B$ 计算为雅可比矩阵的2-范数与输入不确定度向量的欧几里得范数之积：\n    $$ B = \\|J(\\mathbf{k})\\|_2 \\|\\delta \\mathbf{k}\\|_2 = \\sigma_{max} \\sqrt{(\\delta s)^2 + (\\delta t)^2} $$\n2.  输出不确定度大小的线性估计 $L$，是将雅可比矩阵应用于输入不确定度向量后所得向量的欧几里得范数：\n    $$ L = \\|J(\\mathbf{k}) \\delta \\mathbf{k}\\|_2 $$\n这涉及到一个矩阵-向量乘积，然后是一个向量范数计算。\n\n整个过程被封装在一个程序中，该程序遍历所提供的测试用例，为每组参数 $(s, t, m^2, \\delta s, \\delta t)$ 执行数值计算，并将最终的 $(B, L)$ 对格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating error propagation bounds for one-loop\n    tensor integral coefficients.\n    \"\"\"\n    # Define problem constants and numerical parameters\n    # Small positive regulator ε to ensure numerical stability\n    REGULATOR_EPS = 1e-12\n    # Step size h for central finite differences\n    FD_STEP = 1e-6\n\n    # Define the test cases from the problem statement. All units are GeV^2.\n    test_cases = [\n        # (s, t, m^2, δs, δt)\n        # Case 1 (general case)\n        {'s': 1.0, 't': 0.5, 'm2': 1.0, 'ds': 1.0e-3, 'dt': 2.0e-3},\n        # Case 2 (near-cancellation)\n        {'s': 2.0, 't': -1.2, 'm2': 1.0, 'ds': 5.0e-4, 'dt': 5.0e-4},\n        # Case 3 (small invariants)\n        {'s': 0.05, 't': -0.02, 'm2': 1.0, 'ds': 1.0e-4, 'dt': 1.0e-4},\n    ]\n\n    def get_denominator(x, y, s, t, m2, eps):\n        \"\"\"\n        Calculates the regulated denominator Δ(x, y; s, t, m^2) + ε.\n        The variable u is fixed by u = -s - t.\n        \"\"\"\n        u = -s - t\n        delta = m2 - s * x * y - t * y * (1 - x - y) - u * x * (1 - x - y)\n        return delta + eps\n\n    def compute_C_vector(s, t, m2, eps):\n        \"\"\"\n        Numerically evaluates the coefficient vector C = [C0, C1, C2] using\n        2D numerical quadrature (scipy.integrate.dblquad).\n        \n        Note: dblquad integrates f(y, x), so the integrand must have y as the\n        first argument, followed by x. The integration limits are y from 0 to 1-x,\n        and x from 0 to 1.\n        \"\"\"\n        args = (s, t, m2, eps)\n        \n        # Integrand for C0\n        integrand0 = lambda y, x, *a: 1.0 / get_denominator(x, y, *a)\n        c0, _ = integrate.dblquad(integrand0, 0, 1, lambda x: 0, lambda x: 1 - x, args=args)\n        \n        # Integrand for C1\n        integrand1 = lambda y, x, *a: x / get_denominator(x, y, *a)\n        c1, _ = integrate.dblquad(integrand1, 0, 1, lambda x: 0, lambda x: 1 - x, args=args)\n        \n        # Integrand for C2\n        integrand2 = lambda y, x, *a: y / get_denominator(x, y, *a)\n        c2, _ = integrate.dblquad(integrand2, 0, 1, lambda x: 0, lambda x: 1 - x, args=args)\n        \n        return np.array([c0, c1, c2])\n\n    results = []\n    for case in test_cases:\n        s, t, m2, ds, dt = case['s'], case['t'], case['m2'], case['ds'], case['dt']\n        h = FD_STEP\n\n        # Step 1: Approximate the Jacobian J using central finite differences.\n        # Column 1: dC/ds\n        C_plus_s = compute_C_vector(s + h, t, m2, REGULATOR_EPS)\n        C_minus_s = compute_C_vector(s - h, t, m2, REGULATOR_EPS)\n        dC_ds = (C_plus_s - C_minus_s) / (2 * h)\n\n        # Column 2: dC/dt\n        C_plus_t = compute_C_vector(s, t + h, m2, REGULATOR_EPS)\n        C_minus_t = compute_C_vector(s, t - h, m2, REGULATOR_EPS)\n        dC_dt = (C_plus_t - C_minus_t) / (2 * h)\n        \n        # Construct the 3x2 Jacobian matrix\n        J = np.stack((dC_ds, dC_dt), axis=1)\n\n        # Step 2: Compute the induced 2-norm of J (largest singular value).\n        singular_values = np.linalg.svd(J, compute_uv=False)\n        norm_J_2 = singular_values[0]\n\n        # Step 3: Calculate the uncertainty bound B and linear estimate L.\n        delta_k = np.array([ds, dt])\n        \n        # Worst-case bound B\n        norm_delta_k_2 = np.linalg.norm(delta_k)\n        B = norm_J_2 * norm_delta_k_2\n\n        # Linear estimate L\n        delta_C = J @ delta_k\n        L = np.linalg.norm(delta_C)\n        \n        results.append((B, L))\n\n    # Final print statement in the exact required format.\n    res_strings = [f\"[{b},{l}]\" for b, l in results]\n    print(f\"[{','.join(res_strings)}]\")\n\nsolve()\n```", "id": "3525497"}, {"introduction": "在现代圈积分计算中，两种主流的约化方法——Passarino-Veltman (PV) 和 Ossola-Papadopoulos-Pittau (OPP)——各有优劣，其数值稳定性高度依赖于具体的运动学构型。这项高级实践旨在解决一个核心的策略性问题：如何自动为特定任务选择最佳工具。通过这项练习 [@problem_id:3525555]，你将学习构建一个基于 Gram 行列式的决策准则，该行列式是 Baikov 表象中运动学奇点的天然探针，从而能够智能地在运行时选择最稳健的约化路径，构建更为可靠的计算程序。", "problem": "您的任务是设计并实现一个运行时决策准则，该准则能够根据给定的单圈积分拓扑的外部四动量和内部质量，在 Ossola–Papadopoulos–Pittau (OPP) 被积函数约化和 Passarino–Veltman (PV) 张量约化之间做出选择。决策必须基于 Baikov 表示 (BR) 的子式的行为，目标是最大限度地减少因小格拉姆行列式（small Gram determinants）而导致 PV 约化中出现数值不稳定的情况。您的程序必须是该准则的一个完整的、可运行的实现。\n\n请从以下基础开始：\n\n- 一个单圈 $N$ 点张量积分依赖于外部四动量 $\\{p_i\\}$ 和内部质量 $\\{m_j\\}$，其中圈动量在四维时空中使用自然单位制进行积分。\n- 在度规符号为 $(+,-,-,-)$ 的闵可夫斯基空间中，标量积为 $p \\cdot q = p^0 q^0 - \\vec{p}\\cdot\\vec{q}$。\n- $r$ 个独立的外部四动量 $\\{p_1,\\dots,p_r\\}$ 的格拉姆矩阵定义为 $$G_{ij} = p_i \\cdot p_j, \\quad i,j=1,\\dots,r.$$\n- Baikov 表示将单圈积分用反传播子表示，其特征多项式的系数与外部动量格拉姆矩阵的主子式（主子矩阵的行列式）成比例。这些子式编码了运动学上的简并情况，如共线性和近奇异构型。\n- Passarino–Veltman (PV) 张量约化依赖于不同阶数下格拉姆行列式的逆；小的格拉姆行列式会导致大的数值抵消和精度损失。Ossola–Papadopoulos–Pittau (OPP) 被积函数约化避免了显式的格拉姆矩阵求逆，在近奇异运动学中通常更稳健。\n\n您的目标是根据 Baikov (格拉姆) 子式构建一个定量的、无量纲的稳定性分数，并用它来决定使用 PV 还是 OPP。您必须实现以下步骤：\n\n1.  接受一组外部四动量 $\\{p_i\\}_{i=1}^r$（其中 $r \\leq 4$），其能量和动量分量以吉电子伏特 (GeV) 表示，以及一组内部质量 $\\{m_j\\}$（以 GeV 表示）。对于本问题，假设所提供的动量已经是独立的；不执行基约化。\n2.  使用闵可夫斯基度规 $(+,-,-,-)$ 构建格拉姆矩阵 $G \\in \\mathbb{R}^{r \\times r}$，其元素为 $G_{ij} = p_i \\cdot p_j$。\n3.  定义一个运动学标度 $$s_0 = \\max\\left(\\max_{1\\le i,j\\le r} |G_{ij}|,\\; 1 \\right)$$ 单位为 $\\text{GeV}^2$。这为归一化设定了参考量级。\n4.  对于每个大小为 $|S|=k$ 的非空索引子集 $S \\subseteq \\{1,\\dots,r\\}$，构建主子矩阵 $G_S$ 及其行列式 $\\Delta_S = \\det(G_S)$。定义归一化子式 $$\\widehat{\\Delta}_S = \\frac{|\\Delta_S|}{s_0^{k}}.$$ 然后定义全局稳定性分数 $$\\mu = \\min_{S\\neq \\emptyset} \\left(\\widehat{\\Delta}_S\\right)^{1/k}.$$ 直观上，$\\mu$ 捕捉了主子式中最小的归一化几何平均标度，在近奇异运动学中会变小。\n5.  计算归一化的完整格拉姆行列式 $$\\widehat{\\Delta}_{\\text{full}} = \\frac{|\\det(G)|}{s_0^{r}}.$$ 同时计算条件数 $$\\kappa = \\frac{\\sigma_{\\max}(G)}{\\sigma_{\\min}(G)},$$ 其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $G$ 的最大和最小奇异值（如果 $r=1$，则将 $\\kappa$ 解释为 $1$）。\n6.  实现决策规则：如果同时满足 $\\mu \\ge \\tau$、$\\widehat{\\Delta}_{\\text{full}} \\ge \\epsilon$ 和 $\\kappa \\le \\kappa_{\\max}$，则选择 PV；否则选择 OPP。使用以下默认阈值：\n    -   $\\tau = 10^{-5}$\n    -   $\\epsilon = 10^{-8}$\n    -   $\\kappa_{\\max} = 10^{12}$\n    这些是无量纲阈值。\n\n您的程序必须硬编码以下四个测试用例，每个用例指定为由外部动量和内部质量组成的元组。所有四动量单位为 GeV，质量单位也为 GeV。角度未直接提供，所有涉及方向分量的计算必须隐式使用弧度。\n\n-   测试用例 1 (一般的、分离良好的运动学，预期对 PV 安全):\n    -   外部动量：\n        -   $p_1 = (200,\\,0,\\,0,\\,200)$\n        -   $p_2 = (250,\\,-120,\\,30,\\,-200)$\n        -   $p_3 = (180,\\,50,\\,-80,\\,100)$\n    -   内部质量: $[0.0,\\,91.1876,\\,0.0,\\,173.0]$\n-   测试用例 2 (近共线构型，预期倾向于 OPP):\n    -   外部动量：\n        -   $p_1 = (300,\\,0,\\,0,\\,300)$\n        -   $p_2 = (303,\\,1.5,\\,0,\\,303)$\n        -   $p_3 = (50,\\,-0.2,\\,0,\\,50)$\n    -   内部质量: $[0.0,\\,0.0,\\,0.0,\\,0.0]$\n-   测试用例 3 (临界稳定性案例):\n    -   外部动量：\n        -   $p_1 = (100,\\,0,\\,0,\\,100)$\n        -   $p_2 = (100,\\,0.5,\\,0,\\,99.5)$\n        -   $p_3 = (120,\\,-40,\\,0,\\,110)$\n    -   内部质量: $[80.379,\\,0.0,\\,0.0,\\,4.18]$\n-   测试用例 4 (类两点拓扑：单个独立外部动量):\n    -   外部动量：\n        -   $p_1 = (500,\\,0,\\,0,\\,0)$\n    -   内部质量: $[0.0,\\,125.1]$\n\n对于每个测试用例，输出一个整数决策代码：\n-   如果选择 PV 约化，输出 $1$。\n-   如果选择 OPP 约化，输出 $0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、逗号分隔的结果列表（例如，\"[1,0,1,1]\"）。不得有任何额外文本。所有计算均以 GeV 和 $\\text{GeV}^2$ 为单位（视情况而定），最终输出为无单位整数。请按照上述归一化描述，确保在存在小行列式时具有数值稳健性。", "solution": "对用户提供的问题陈述进行验证。\n\n### 步骤 1：提取给定信息\n- **任务**：设计并实现一个运行时决策准则，用于在 Ossola–Papadopoulos–Pittau (OPP) 和 Passarino–Veltman (PV) 这两种单圈积分约化方法之间进行选择。\n- **决策依据**：Baikov 表示 (BR) 子式的行为，这些子式与格拉姆行列式相关。\n- **物理背景**：四维时空中的单圈 $N$ 点张量积分，使用闵可夫斯基度规符号 $(+,-,-,-)$。标量积为 $p \\cdot q = p^0 q^0 - \\vec{p}\\cdot\\vec{q}$。\n- **输入**：\n    - 一组 $r$ 个独立的外部四动量 $\\{p_i\\}_{i=1}^r$，其中 $r \\le 4$，分量单位为 GeV。\n    - 一组内部质量 $\\{m_j\\}$，单位为 GeV。\n- **算法步骤**：\n    1.  **构建格拉姆矩阵**：$G \\in \\mathbb{R}^{r \\times r}$，其元素为 $G_{ij} = p_i \\cdot p_j$。\n    2.  **定义运动学标度**：$s_0 = \\max\\left(\\max_{1\\le i,j\\le r} |G_{ij}|,\\; 1 \\right)$，单位为 $\\text{GeV}^2$。\n    3.  **定义全局稳定性分数**：\n        - 对于每个大小为 $|S|=k$ 的非空索引子集 $S \\subseteq \\{1,\\dots,r\\}$，构建主子矩阵 $G_S$ 及其行列式 $\\Delta_S = \\det(G_S)$。\n        - 定义归一化子式 $\\widehat{\\Delta}_S = \\frac{|\\Delta_S|}{s_0^{k}}$。\n        - 全局稳定性分数为 $\\mu = \\min_{S\\neq \\emptyset} \\left(\\widehat{\\Delta}_S\\right)^{1/k}$。\n    4.  **定义附加度量**：\n        - 归一化完整格拉姆行列式：$\\widehat{\\Delta}_{\\text{full}} = \\frac{|\\det(G)|}{s_0^{r}}$。\n        - 条件数：$\\kappa = \\frac{\\sigma_{\\max}(G)}{\\sigma_{\\min}(G)}$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 是 $G$ 的最大和最小奇异值。对于 $r=1$，$\\kappa = 1$。\n    5.  **实现决策规则**：如果同时满足 $\\mu \\ge \\tau$、$\\widehat{\\Delta}_{\\text{full}} \\ge \\epsilon$ 和 $\\kappa \\le \\kappa_{\\max}$，则选择 PV。否则，选择 OPP。\n_   **阈值**：\n        - $\\tau = 10^{-5}$\n        - $\\epsilon = 10^{-8}$\n        - $\\kappa_{\\max} = 10^{12}$\n- **输出**：一个整数决策代码：PV 为 $1$，OPP 为 $0$。\n- **测试用例**：\n    - **用例 1**：$p_1 = (200,\\,0,\\,0,\\,200)$, $p_2 = (250,\\,-120,\\,30,\\,-200)$, $p_3 = (180,\\,50,\\,-80,\\,100)$；质量：$[0.0,\\,91.1876,\\,0.0,\\,173.0]$。\n    - **用例 2**：$p_1 = (300,\\,0,\\,0,\\,300)$, $p_2 = (303,\\,1.5,\\,0,\\,303)$, $p_3 = (50,\\,-0.2,\\,0,\\,50)$；质量：$[0.0,\\,0.0,\\,0.0,\\,0.0]$。\n    - **用例 3**：$p_1 = (100,\\,0,\\,0,\\,100)$, $p_2 = (100,\\,0.5,\\,0,\\,99.5)$, $p_3 = (120,\\,-40,\\,0,\\,110)$；质量：$[80.379,\\,0.0,\\,0.0,\\,4.18]$。\n    - **用例 4**：$p_1 = (500,\\,0,\\,0,\\,0)$；质量：$[0.0,\\,125.1]$。\n- **最终输出格式**：一个用方括号括起来的、逗号分隔的整数结果列表，例如 `[1,0,1,1]`。\n\n### 步骤 2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估。\n\n- **科学上合理**：问题陈述牢固地植根于计算高能物理的既定原则，特别是单圈积分约化理论。Passarino-Veltman 约化、OPP 约化、格拉姆行列式以及它们与运动学奇点的联系等概念都是标准且事实正确的。使用度规符号为 $(+,-,-,-)$ 的闵可夫斯基度规是标准惯例。\n- **定义明确 (Well-Posed)**：问题是定义明确的。它提供了一个完整的、确定性的算法，具有明确定义的输入（动量）、中间量（$\\mu$, $\\widehat{\\Delta}_{\\text{full}}$, $\\kappa$）以及基于固定阈值的精确决策规则。算法的确定性保证了对于任何给定输入都存在唯一解。假定外部动量独立的指令消除了一个潜在的歧义。内部质量已提供，但在决策逻辑中并未使用；这是一个可接受的简化，因为该准则明确基于外部运动学。\n- **客观性**：问题以客观、正式的语言陈述。决策准则纯粹是定量的，取决于计算出的度量和预定义的无量纲阈值。没有主观解释的余地。\n\n基于此分析，该问题没有表现出任何列出的缺陷（科学上不健全、非形式化、不完整、矛盾、不可行、定义不明确、过于简单或不可验证）。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n---\n\n目标是阐述并实现一个决策准则，用于在高能物理的两种单圈张量积分约化方法之间做出选择：Passarino-Veltman (PV) 方法和 Ossola–Papadopoulos–Pittau (OPP) 方法。选择由运动学构型的数值稳定性决定，该稳定性通过使用由外部动量构建的格拉姆矩阵的行列式进行评估。\n\n单圈积分复杂性的基本结构编码在其对外部四动量 $\\{p_i\\}$ 的依赖关系中。PV 约化技术系统地将张量积分分解为标量积分的基。此过程涉及对格拉姆矩阵 $G$ 进行求逆，其元素是外部动量的标量积，$G_{ij} = p_i \\cdot p_j$。当外部动量近乎线性相关时（例如，在共线或软粒子构型中），格拉姆矩阵的行列式 $\\det(G)$ 趋近于零。这由于项之间的大量抵消而导致 PV 过程中的数值不稳定性。OPP 方法在积分之前于被积函数层面进行操作，通常在这种奇异运动学区域中更为稳健。\n\n所提出的算法量化了这种“近奇异性”，以做出稳健的选择。步骤如下：\n\n**1. 格拉姆矩阵的构建**\n给定一组 $r$ 个外部四动量 $\\{p_1, \\dots, p_r\\}$，其中每个 $p_i = (p_i^0, p_i^1, p_i^2, p_i^3)$，我们首先构建 $r \\times r$ 的格拉姆矩阵 $G$。其元素是闵可夫斯基标量积：\n$$\nG_{ij} = p_i \\cdot p_j = p_i^0 p_j^0 - p_i^1 p_j^1 - p_i^2 p_j^2 - p_i^3 p_j^3\n$$\n该矩阵包含了关于外部状态的所有几何信息。\n\n**2. 通过运动学标度进行归一化**\n数值稳定性对过程的整体能量标度很敏感。为了创建一个无量纲且标度不变的稳定性度量，我们定义一个特征运动学标度 $s_0$：\n$$\ns_0 = \\max\\left(\\max_{1\\le i,j\\le r} |G_{ij}|,\\; 1 \\right)\n$$\n包含数值 $1$ 是为了处理所有 $|G_{ij}|$ 都小于 $1$ 的情况，防止归一化量被人为放大。所有行列式都将通过适当的 $s_0$ 次幂进行归一化。\n\n**3. 全局稳定性分数 $\\mu$**\n运动学奇点不仅可能源于整组动量变得线性相关，也可能源于任何子集。例如，在四点函数中，一个三点子拓扑可能是平面的，或者一个两点子拓扑可能涉及共线动量。圈积分的 Baikov 表示清楚地表明，格拉姆矩阵的主子式 $\\det(G_S)$ 是相关量，其中 $G_S$ 是动量子集 $S$ 的格拉姆矩阵。\n\n为了检测任何此类潜在的不稳定性，我们检查外部动量的所有非空子集。对于每个大小为 $k = |S|$ 的子集 $S \\subseteq \\{1, \\dots, r\\}$，我们计算相应主子矩阵的行列式 $\\Delta_S = \\det(G_S)$。然后我们构建一个归一化的无量纲量：\n$$\n\\widehat{\\Delta}_S = \\frac{|\\Delta_S|}{s_0^k}\n$$\n为了将这些度量组合成一个单一的分数，我们取一个类似几何平均的根，然后找出所有子集中的最小值。这个最小值 $\\mu$ 充当一个“最薄弱环节”探测器：\n$$\n\\mu = \\min_{S \\neq \\emptyset} \\left( \\widehat{\\Delta}_S \\right)^{1/k}\n$$\n$\\mu$ 的值很小表明至少有一个动量子集形成了近奇异构型，预示着 PV 约化可能存在问题。\n\n**4. 附加稳定性度量**\n虽然 $\\mu$ 是一个敏感的探针，但另外两个标准度量提供了补充信息：\n\n-   **归一化完整格拉姆行列式 $\\widehat{\\Delta}_{\\text{full}}$**：这是对 $r$ 个动量完整系统奇异性的直接度量。它是 $\\widehat{\\Delta}_S$ 在 $S=\\{1, \\dots, r\\}$ 时的特例。\n    $$\n    \\widehat{\\Delta}_{\\text{full}} = \\frac{|\\det(G)|}{s_0^r}\n    $$\n-   **条件数 $\\kappa$**：根据数值线性代数，矩阵的条件数衡量了线性方程组的解对数据中误差的敏感度。对于格拉姆矩阵 $G$，大的条件数表明 $G$ 接近奇异（不可逆）。它正式定义为 $G$ 的最大奇异值与最小奇异值之比：\n    $$\n    \\kappa = \\frac{\\sigma_{\\max}(G)}{\\sigma_{\\min}(G)}\n    $$\n    在只有一个外部动量（$r=1$）的特殊情况下，$G$ 是一个 $1 \\times 1$ 矩阵，我们定义 $\\kappa = 1$。\n\n**5. 决策规则**\n最终决策是通过将所有三个度量与预定义的无量纲阈值（$\\tau$, $\\epsilon$, $\\kappa_{\\max}$）同时进行检查而做出的。只有当运动学构型在所有方面都足够规则时，PV 方法才被认为是安全的。\n\n-   选择 PV（输出 $1$）如果：\n    $$\n    \\mu \\ge \\tau \\quad \\text{且} \\quad \\widehat{\\Delta}_{\\text{full}} \\ge \\epsilon \\quad \\text{且} \\quad \\kappa \\le \\kappa_{\\max}\n    $$\n-   否则，选择更稳健的 OPP 方法（输出 $0$）。\n\n阈值设置为 $\\tau = 10^{-5}$、$\\epsilon = 10^{-8}$ 和 $\\kappa_{\\max} = 10^{12}$。PV 方法是“有条件的”选择，而 OPP 是默认的“安全”后备方案。此逻辑确保任何运动学简并的迹象都会触发切换到更稳定的算法。内部质量 $\\{m_j\\}$ 不参与这个特定的运动学稳定性准则，尽管它们对积分计算的其他方面至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\n# from scipy is not required as numpy covers all needs.\n\ndef solve():\n    \"\"\"\n    Main function to run the decision criterion on all test cases.\n    \"\"\"\n\n    # --- Problem Constants ---\n    TAU = 1e-5\n    EPSILON = 1e-8\n    KAPPA_MAX = 1e12\n\n    # --- Test Cases ---\n    # Each case is a tuple: (list_of_momenta, list_of_masses)\n    # Momenta are lists/tuples of [p0, p1, p2, p3] in GeV.\n    # Masses are in GeV, but not used by this decision logic.\n    test_cases = [\n        # Test Case 1 (general well-separated kinematics, expected PV-safe)\n        (\n            [\n                (200.0, 0.0, 0.0, 200.0),\n                (250.0, -120.0, 30.0, -200.0),\n                (180.0, 50.0, -80.0, 100.0),\n            ],\n            [0.0, 91.1876, 0.0, 173.0],\n        ),\n        # Test Case 2 (near-collinear configuration, expected to prefer OPP)\n        (\n            [\n                (300.0, 0.0, 0.0, 300.0),\n                (303.0, 1.5, 0.0, 303.0),\n                (50.0, -0.2, 0.0, 50.0),\n            ],\n            [0.0, 0.0, 0.0, 0.0],\n        ),\n        # Test Case 3 (borderline stability case)\n        (\n            [\n                (100.0, 0.0, 0.0, 100.0),\n                (100.0, 0.5, 0.0, 99.5),\n                (120.0, -40.0, 0.0, 110.0)\n            ],\n            [80.379, 0.0, 0.0, 4.18],\n        ),\n        # Test Case 4 (two-point-like topology: single independent external momentum)\n        (\n            [(500.0, 0.0, 0.0, 0.0)],\n            [0.0, 125.1],\n        ),\n    ]\n\n    results = []\n    for momenta, _ in test_cases: # Internal masses are not used\n        decision = select_reduction_method(momenta, TAU, EPSILON, KAPPA_MAX)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef minkowski_dot(p1, p2):\n    \"\"\"\n    Computes the Minkowski dot product with signature (+, -, -, -).\n    \"\"\"\n    return p1[0] * p2[0] - p1[1] * p2[1] - p1[2] * p2[2] - p1[3] * p2[3]\n\ndef select_reduction_method(momenta, tau, epsilon, kappa_max):\n    \"\"\"\n    Implements the decision criterion for a single kinematic configuration.\n    \n    Args:\n        momenta (list of tuples/lists): The set of external four-momenta.\n        tau (float): Threshold for the global stability score.\n        epsilon (float): Threshold for the normalized full Gram determinant.\n        kappa_max (float): Threshold for the condition number.\n\n    Returns:\n        int: 1 for PV reduction, 0 for OPP reduction.\n    \"\"\"\n    momenta_np = [np.array(p, dtype=np.float64) for p in momenta]\n    r = len(momenta_np)\n\n    if r == 0:\n        return 0 # Default to OPP for trivial case\n\n    # 1. Construct the Gram matrix G\n    gram_matrix = np.zeros((r, r), dtype=np.float64)\n    for i in range(r):\n        for j in range(i, r):\n            dot_product = minkowski_dot(momenta_np[i], momenta_np[j])\n            gram_matrix[i, j] = dot_product\n            gram_matrix[j, i] = dot_product\n\n    # 2. Define the kinematic scale s0\n    s0 = np.max(np.abs(gram_matrix))\n    if s0  1.0:\n        s0 = 1.0\n\n    # 3. Compute the global stability score mu\n    mu = float('inf')\n    indices = range(r)\n    for k in range(1, r + 1):\n        for subset_indices in combinations(indices, k):\n            sub_matrix = gram_matrix[np.ix_(subset_indices, subset_indices)]\n            det_S = np.linalg.det(sub_matrix)\n            \n            # Avoid division by zero if s0 is extremely small (although prevented by max(..., 1))\n            norm_det_S = np.abs(det_S) / (s0**k)\n            \n            subset_score = norm_det_S**(1.0 / k)\n            if subset_score  mu:\n                mu = subset_score\n\n    # 4. Compute additional metrics: normalized full determinant and condition number\n    det_full = np.linalg.det(gram_matrix)\n    norm_det_full = np.abs(det_full) / (s0**r)\n\n    if r == 1:\n        kappa = 1.0\n    else:\n        # np.linalg.cond handles singular matrices by returning inf\n        kappa = np.linalg.cond(gram_matrix)\n\n    # 5. Apply the decision rule\n    if mu = tau and norm_det_full = epsilon and kappa = kappa_max:\n        return 1 # Choose PV\n    else:\n        return 0 # Choose OPP\n\n# Execute the main function\nsolve()\n```", "id": "3525555"}]}