{"hands_on_practices": [{"introduction": "在高能物理的格点计算中，我们经常需要计算矩阵的函数，例如哈密顿量的指数函数 $\\exp(-tH)$。直接计算这些函数通常成本高昂，因此使用多项式逼近是一种核心技术。这个练习 ([@problem_id:3525838]) 将引导您推导一个重要的误差界，它利用切比雪夫多项式和复分析中的伯恩斯坦椭圆理论，来量化多项式逼近矩阵函数时的精度。这个推导过程深刻地揭示了函数的光滑性如何转化为逼近误差的指数级收敛。", "problem": "在量子色动力学（QCD）和计算高能物理中相关模型的格点计算中，人们经常需要对一个大的厄米矩阵应用一个光滑函数，该矩阵代表一个离散化的哈密顿量或一个欧几里得狄拉克算符。设 $A \\in \\mathbb{C}^{N \\times N}$ 是一个厄米矩阵，并且可对角化为 $A = Q \\Lambda Q^{\\ast}$，其中 $Q$ 是酉矩阵，$\\Lambda = \\operatorname{diag}(\\lambda_{1},\\dots,\\lambda_{N})$。通过谱演算定义一个矩阵函数：对于一个定义在包含 $\\{\\lambda_{i}\\}_{i=1}^{N}$ 的区间上的标量函数 $f$，设 $f(A) = Q f(\\Lambda) Q^{\\ast}$，其中 $f(\\Lambda) = \\operatorname{diag}(f(\\lambda_{1}),\\dots,f(\\lambda_{N}))$。假设 $A$ 的谱位于一个已知的紧区间 $[a,b] \\subset \\mathbb{R}$ 内，其中 $a  b$，这对于具有物理有界能标的离散化正定算符来说是常见情况。\n\n考虑用一个在区间 $[a,b]$ 上由 Chebyshev 多项式构造的 $n$ 次多项式 $p_{n}(A)$ 来逼近 $f(A)$，使用标准仿射映射 $x = c + d t$（其中 $c = (a+b)/2$ 且 $d = (b-a)/2$）从 $t \\in [-1,1]$ 映到 $x \\in [a,b]$。假设 $f$ 在复 $t$-平面中一个参数为 $\\rho  1$ 的 Bernstein 椭圆上及其内部是解析的（该椭圆焦点为 $-1$ 和 $1$，半轴和等于 $\\rho$），并且对于该椭圆上所有的点 $t$，不等式 $|f(c + d t)| \\leq M$ 对某个常数 $M  0$ 一致成立。只要谱区间和椭圆的选择与能标一致，这些解析性和有界性假设对于物理上相关的函数是满足的，例如虚时传播子 $f(x) = \\exp(-\\beta x)$（其中 $\\beta  0$）或远离奇点的有理滤波器。\n\n从谱演算和谱范数的酉不变性出发，并利用复逼近理论中关于 Chebyshev 多项式和 Bernstein 椭圆上解析函数的成熟结论，推导算子2-范数误差 $\\|f(A) - p_{n}(A)\\|_{2}$ 的一个严格上界，该上界用椭圆参数 $\\rho$、界 $M$ 和多项式次数 $n$ 来表示。然后，给出 $\\|f(A) - p_{n}(A)\\|_{2}$ 的上界作为 $\\rho$、$M$ 和 $n$ 的函数的单个闭式解析表达式。你的最终答案必须是单个闭式解析表达式。不需要数值舍入。结果需纯符号表示。", "solution": "我们从一个厄米矩阵 $A \\in \\mathbb{C}^{N \\times N}$ 开始。根据谱定理，$A$ 存在一个酉对角化 $A = Q \\Lambda Q^{\\ast}$，其中 $Q$ 是酉矩阵，$\\Lambda = \\operatorname{diag}(\\lambda_{1},\\dots,\\lambda_{N})$，且 $\\lambda_{i} \\in \\mathbb{R}$。对于一个定义在包含谱集 $\\{\\lambda_{i}\\}$ 的集合上的标量函数 $f$，谱演算定义为\n$$\nf(A) = Q f(\\Lambda) Q^{\\ast}, \\quad f(\\Lambda) = \\operatorname{diag}(f(\\lambda_{1}),\\dots,f(\\lambda_{N})).\n$$\n设 $p_{n}$ 是一个 $n$ 次多项式。则 $p_{n}(A) = Q p_{n}(\\Lambda) Q^{\\ast}$，其中 $p_{n}(\\Lambda) = \\operatorname{diag}(p_{n}(\\lambda_{1}),\\dots,p_{n}(\\lambda_{N}))$。因此，\n$$\nf(A) - p_{n}(A) = Q \\left( f(\\Lambda) - p_{n}(\\Lambda) \\right) Q^{\\ast} = Q \\,\\operatorname{diag}\\big(f(\\lambda_{1}) - p_{n}(\\lambda_{1}),\\dots,f(\\lambda_{N}) - p_{n}(\\lambda_{N})\\big) Q^{\\ast}.\n$$\n谱范数 $\\|\\cdot\\|_{2}$ 是酉不变的，所以\n$$\n\\|f(A) - p_{n}(A)\\|_{2} = \\left\\| \\operatorname{diag}\\big(f(\\lambda_{1}) - p_{n}(\\lambda_{1}),\\dots,f(\\lambda_{N}) - p_{n}(\\lambda_{N})\\big) \\right\\|_{2}.\n$$\n对于一个对角矩阵，其算子2-范数等于对角线上元素绝对值的最大值。因此，\n$$\n\\|f(A) - p_{n}(A)\\|_{2} = \\max_{1 \\leq i \\leq N} |f(\\lambda_{i}) - p_{n}(\\lambda_{i})|.\n$$\n如果谱位于 $[a,b]$ 内，则\n$$\n\\|f(A) - p_{n}(A)\\|_{2} \\leq \\max_{x \\in [a,b]} |f(x) - p_{n}(x)|.\n$$\n这表明算子2-范数下的矩阵逼近误差由谱区间上的标量一致逼近误差所控制。因此，只需对 $\\max_{x \\in [a,b]} |f(x) - p_{n}(x)|$ 进行界定。\n\n我们通过仿射变换 $x = c + d t$（其中 $c = (a+b)/2$ 且 $d = (b-a)/2$）将区间 $[a,b]$ 映射到 $[-1,1]$。定义 $g(t) = f(c + d t)$，这样 $[a,b]$ 上的逼近问题就转化为在 $[-1,1]$ 上用一个关于 $t$ 的 $n$ 次多项式（比如 $q_{n}(t) = p_{n}(c + d t)$）来逼近 $g$。\n\n我们假设 $f$ 在复 $t$-平面中一个参数为 $\\rho  1$ 的 Bernstein 椭圆上及其内部是解析的，并且对于该椭圆上的所有 $t$，不等式 $|g(t)| \\leq M$ 一致成立。Bernstein 椭圆 $E_{\\rho}$ 是圆在 Joukowski 映射下的像，其焦点为 $-1$ 和 $1$。复逼近理论中关于 Chebyshev 展开的一个经典结果（该结果使用关于 Chebyshev 系数的 Cauchy 积分公式和最大模原理推导）指出，如果 $g$ 在 $E_{\\rho}$ 上及其内部解析且有界为 $M$，那么在 $[-1,1]$ 上对 $g$ 的最佳 $n$ 次多项式逼近的误差满足\n$$\n\\min_{\\deg(q_{n}) \\leq n} \\max_{t \\in [-1,1]} |g(t) - q_{n}(t)| \\leq \\frac{2 M \\,\\rho^{-n}}{\\rho - 1}.\n$$\n这个界可以通过将 $g$ 表示为其 Chebyshev 级数 $g(t) = \\sum_{k=0}^{\\infty} a_{k} T_{k}(t)$ 来建立，在解析性和有界性假设下证明对于 $k \\geq 1$ 有 $|a_{k}| \\leq \\frac{2 M}{\\rho^{k}}$，并使用几何级数界对从 $k = n+1$ 到无穷大的级数尾部求和。因子 $(\\rho - 1)^{-1}$ 来自于求和 $\\sum_{k=n+1}^{\\infty} \\rho^{-k} = \\rho^{-(n+1)} \\frac{1}{1 - \\rho^{-1}} = \\frac{\\rho^{-n}}{\\rho - 1}$，在一个由系数估计控制的常数前因子之内。\n\n转换回 $x \\in [a,b]$，对于通过复合得到的相应关于 $x$ 的多项式 $p_{n}$，我们有\n$$\n\\max_{x \\in [a,b]} |f(x) - p_{n}(x)| \\leq \\frac{2 M \\,\\rho^{-n}}{\\rho - 1}.\n$$\n将此与从谱演算和酉不变性导出的矩阵不等式相结合，得到\n$$\n\\|f(A) - p_{n}(A)\\|_{2} \\leq \\max_{x \\in [a,b]} |f(x) - p_{n}(x)| \\leq \\frac{2 M \\,\\rho^{-n}}{\\rho - 1}.\n$$\n因此，所需的算子2-范数误差的严格上界由以下闭式解析表达式给出\n$$\n\\frac{2 M \\,\\rho^{-n}}{\\rho - 1}.\n$$\n这个表达式仅依赖于 Bernstein 椭圆参数 $\\rho  1$、在映射变量下椭圆上 $f$ 的界 $M$ 以及多项式次数 $n$，并且由于厄米矩阵的谱特征，它与矩阵维数 $N$ 无关。", "answer": "$$\\boxed{\\frac{2 M \\,\\rho^{-n}}{\\rho - 1}}$$", "id": "3525838"}, {"introduction": "在求解大规模本征值问题时，将一个稀疏厄米矩阵约化为三对角形式是常见的预处理步骤。豪斯霍尔德变换（Householder reflectors）和吉文斯旋转（Givens rotations）是实现这一目标的两种标准方法。这个练习 ([@problem_id:3525905]) 要求您基于一个简化的性能模型，从第一性原理出发，推导这两种方法在分布式计算环境下的性能比。通过这个过程，您将学会如何量化分析算法在不同计算和通信成本下的表现，这是高性能计算中选择最优算法的关键技能。", "problem": "在计算高能物理学中的大规模特征值计算中，例如格点量子色动力学（QCD）中出现的那些计算，通常会将一个厄米矩阵约化为三对角形式，作为迭代特征求解器的预处理步骤。考虑一个 $n \\times n$ 的稀疏厄米矩阵 $A$，其均匀半带宽为 $b$（即，每列最多有 $2b+1$ 个以对角线为中心的非零元）。该矩阵使用一维行分块分布方式分布在分布式内存系统中的 $p$ 个进程上，每个进程拥有 $n/p$ 个连续行。假设 $b \\ll n$ 且 $b p \\ge n$，因此对于一个典型的列，长度为 $b$ 的行段会跨越 $s = b p / n$ 个进程。\n\n采用分布式内存的 $\\alpha$–$\\beta$–$\\gamma$ 性能模型，其中点对点消息的延迟成本为 $\\alpha$，通信一个字的成本为 $\\beta$，一次浮点运算的成本为 $\\gamma$。跨 $s$ 个进程的集体操作被建模为延迟成本 $\\alpha \\ln(s)$ 和与消息长度成正比的字成本，为方便起见使用自然对数。\n\n考虑两种标准正交/酉变换策略，用于将 $A$ 约化为三对角形式同时保持其厄米性：\n\n- Householder 反射：对于每个内部列，构造一个有效长度为 $b$ 的 Householder 向量，以消除带内的第一条次对角线下方的元素。然后将该反射对称地（从左侧和右侧）应用，但仅在带内应用，以保持稀疏性。\n\n- Givens 旋转：对于每个内部列，使用 $b-1$ 次 Givens 旋转来顺序消除带内的第一条次对角线下方的元素，并对称地应用每次旋转以保持厄米性。\n\n在本问题中，基于带状结构和一维行分块布局，对每个内部列使用以下主阶运算和通信模型：\n\n- Householder 反射：\n  - 浮点运算：约 $4 b^{2}$。\n  - 通信：一次全归约以形成范数，以及一次在 $s$ 个进程上对长度为 $b$ 的反射向量的广播，总延迟成本为 $2 \\alpha \\ln(s)$，字成本为 $2 \\beta b$。\n\n- Givens 旋转：\n  - 浮点运算：约 $6 b^{2}$（即 $b-1$ 次旋转，每次对称地触及 $\\mathcal{O}(b)$ 个元素，隐藏的常数因子累积为 $6$）。\n  - 通信：每次旋转，假设进行一次点对点交换以获取旋转参数并分发它们，延迟成本为 $\\alpha$，通信两个字；对于 $b-1$ 次旋转，每列产生的延迟成本约为 $\\alpha b$，字成本约为 $2 \\beta b$。\n\n忽略前 $b$ 列和后 $b$ 列的低阶边界效应，并为简化主阶比较，假设上述成本对 $n$ 列中的每一列都成立。\n\n令 $T_{\\mathrm{H}}$ 和 $T_{\\mathrm{G}}$ 分别表示基于 Householder 和 Givens 的三对角化的总模型运行时间。根据第一性原理和给定模型，推导出比率\n$$\nR \\equiv \\frac{T_{\\mathrm{H}}}{T_{\\mathrm{G}}}\n$$\n的闭式表达式，该表达式是关于 $n$、$b$、$p$、$\\alpha$、$\\beta$ 和 $\\gamma$ 的函数。将最终答案表示为关于这些参数的单个简化解析表达式。不需要进行数值评估。给出 $R$ 的最终表达式；最终答案中不需要中间步骤。", "solution": "问题要求计算对稀疏厄米矩阵 $A$ 进行基于 Householder ($T_{\\mathrm{H}}$) 和基于 Givens ($T_{\\mathrm{G}}$) 的三对角化所需的总运行时间的比率。矩阵大小为 $n \\times n$，半带宽为 $b$。计算在 $p$ 个进程上执行。解将基于所提供的 $\\alpha$–$\\beta$–$\\gamma$ 性能模型以及为每种方法指定的成本来推导。\n\n任何算法的总运行时间是浮点运算所用时间 ($T_{\\text{flop}}$) 和通信所用时间 ($T_{\\text{comm}}$) 的总和。问题为处理的矩阵的每列所产生的成本提供了简化模型。它进一步简化了分析，指出可以假设这些每列成本适用于矩阵的所有 $n$ 列。因此，每种方法的总时间是其每列成本的 $n$ 倍。\n\n首先，我们确定 Householder 反射方法每列的总时间，记为 $t_{\\mathrm{H}}$。\n浮点运算的时间是运算次数乘以每次运算的成本 $\\gamma$。\n$T_{\\text{flop, H per col}} = (4 b^{2}) \\gamma = 4 \\gamma b^{2}$。\n\n通信时间是延迟成本和字（或带宽）成本的总和。\n$T_{\\text{comm, H per col}} = 2 \\alpha \\ln(s) + 2 \\beta b$。\n这里，$s$ 是长度为 $b$ 的行段所跨越的进程数，给定为 $s = \\frac{bp}{n}$。\n\nHouseholder 方法每列的总时间是浮点运算时间和通信时间之和：\n$t_{\\mathrm{H}} = T_{\\text{flop, H per col}} + T_{\\text{comm, H per col}} = 4 \\gamma b^{2} + 2 \\alpha \\ln(s) + 2 \\beta b$。\n代入 $s$ 的表达式：\n$t_{\\mathrm{H}} = 4 \\gamma b^{2} + 2 \\alpha \\ln\\left(\\frac{bp}{n}\\right) + 2 \\beta b$。\n\nHouseholder 三对角化的总运行时间 $T_{\\mathrm{H}}$ 是这个每列成本的 $n$ 倍：\n$T_{\\mathrm{H}} = n \\cdot t_{\\mathrm{H}} = n \\left(4 \\gamma b^{2} + 2 \\beta b + 2 \\alpha \\ln\\left(\\frac{bp}{n}\\right)\\right)$。\n\n接下来，我们确定 Givens 旋转方法每列的总时间，记为 $t_{\\mathrm{G}}$。\n浮点运算的时间是：\n$T_{\\text{flop, G per col}} = (6 b^{2}) \\gamma = 6 \\gamma b^{2}$。\n\n通信时间，作为延迟和字成本的总和，是：\n$T_{\\text{comm, G per col}} = \\alpha b + 2 \\beta b$。\n\nGivens 方法每列的总时间是：\n$t_{\\mathrm{G}} = T_{\\text{flop, G per col}} + T_{\\text{comm, G per col}} = 6 \\gamma b^{2} + \\alpha b + 2 \\beta b$。\n这可以写成 $t_{\\mathrm{G}} = 6 \\gamma b^{2} + (\\alpha + 2 \\beta) b$。\n\nGivens 三对角化的总运行时间 $T_{\\mathrm{G}}$ 是这个每列成本的 $n$ 倍：\n$T_{\\mathrm{G}} = n \\cdot t_{\\mathrm{G}} = n \\left(6 \\gamma b^{2} + (\\alpha + 2 \\beta) b\\right)$。\n\n最后，我们计算比率 $R \\equiv \\frac{T_{\\mathrm{H}}}{T_{\\mathrm{G}}}$。\n$$\nR = \\frac{T_{\\mathrm{H}}}{T_{\\mathrm{G}}} = \\frac{n \\left(4 \\gamma b^{2} + 2 \\beta b + 2 \\alpha \\ln\\left(\\frac{bp}{n}\\right)\\right)}{n \\left(6 \\gamma b^{2} + (\\alpha + 2 \\beta) b\\right)}\n$$\n分子和分母中的因子 $n$ 被约去，这是预料之中的，因为我们是在每列的基础上比较效率。\n$$\nR = \\frac{4 \\gamma b^{2} + 2 \\beta b + 2 \\alpha \\ln\\left(\\frac{bp}{n}\\right)}{6 \\gamma b^{2} + (\\alpha + 2 \\beta) b}\n$$\n为简化表达式，我们可以从分母中提出因子 $b$。\n$$\nR = \\frac{4 \\gamma b^{2} + 2 \\beta b + 2 \\alpha \\ln\\left(\\frac{bp}{n}\\right)}{b \\left(6 \\gamma b + \\alpha + 2 \\beta\\right)}\n$$\n该表达式无法通过初等代数操作进一步简化。它就是比率 $R$ 作为给定参数 $n$、$b$、$p$、$\\alpha$、$\\beta$ 和 $\\gamma$ 的函数的最终闭式表达式。", "answer": "$$\\boxed{\\frac{4 \\gamma b^{2} + 2 \\beta b + 2 \\alpha \\ln\\left(\\frac{bp}{n}\\right)}{b\\left(6 \\gamma b + \\alpha + 2 \\beta\\right)}}$$", "id": "3525905"}, {"introduction": "性能建模的最终目的是指导算法的优化。这个实践 ([@problem_id:3525899]) 将前一个练习中的分析思想转化为一个具体的编程优化任务。您需要为一个在分布式系统上运行的QR算法构建性能模型，并编写程序来寻找最优的“块大小”参数，以最小化总计算时间。这个练习模拟了计算科学家在实际工作中面临的典型挑战：在计算、通信延迟和带宽这些相互竞争的因素之间找到最佳平衡点，从而最大化硬件资源的利用效率。", "problem": "你的任务是构建并使用一个有原则的性能模型，用于在分布式内存系统上通过带凸起追逐的隐式多移位$QR$算法计算大型实对称三对角矩阵的特征值。这类矩阵出现在计算高能物理中离散化厄米哈密顿量时，其三对角形式是在相似变换后得到的。你的程序必须选择一个整数凸起追逐块大小$b$，以优化浮点运算和进程间通信之间的权衡。\n\n起点是延迟-带宽-计算性能模型，该模型广泛用于大规模科学计算。它指出，在分布式内存系统上执行算法的时间可以近似为\n$$\nT \\approx \\alpha M + \\beta W + \\gamma F,\n$$\n其中$\\alpha$是消息延迟（单位：秒/消息），$M$是消息数量，$\\beta$是逆带宽（单位：秒/字），$W$是通信的字数，$\\gamma$是每次浮点运算的时间（单位：秒/浮点运算），$F$是浮点运算的次数。\n\n考虑一个$n \\times n$的实对称三对角输入矩阵，在$p$个进程上划分为$p$个连续的块。在带凸起追逐的隐式多移位$QR$算法中，一个大小为$b$的移位块会产生一条由$b$个凸起组成的链，该链在一次扫描中遍历整个矩阵。在一个简化的、保守的模型中：\n\n- 每次扫描的浮点运算工作量建模为\n$$\nF_{\\mathrm{sweep}}(b) = c_f \\, n \\, b,\n$$\n其中$c_f$是一个无量纲常数，捕捉了在三对角结构中应用和传播凸起期间，每个矩阵位置、每次移位所需的平均浮点运算次数。\n\n- 每次扫描的消息数量建模为\n$$\nM_{\\mathrm{sweep}}(b) = 2(p-1)\\,\\left\\lceil \\frac{p}{b} \\right\\rceil,\n$$\n这反映了凸起链跨越$p-1$个进程边界中的每一个，并且以因子$b$进行的聚合将不同通信回合的数量减少了大约相同的因子，其中向上取整函数考虑了离散的同步回合。因子$2$解释了每回合中晕圈交换或同步的前向和后向两个方向。\n\n- 每次扫描的通信字数建模为\n$$\nW_{\\mathrm{sweep}}(b) = 2(p-1)\\,c_w\\, b,\n$$\n其中$c_w$是一个无量纲常数，用于模拟每次边界交换的有效载荷大小，由于与凸起前沿及其在三对角结构中紧邻区域相关的晕圈数据，它随凸起大小$b$线性扩展。\n\n假设需要$S$次扫描来收敛并缩减所有特征值（这是一个输入参数），则总预测时间为\n$$\nT(b) = S\\left[\\alpha\\,M_{\\mathrm{sweep}}(b) + \\beta\\,W_{\\mathrm{sweep}}(b) + \\gamma\\,F_{\\mathrm{sweep}}(b)\\right].\n$$\n\n你的程序必须为每个提供的测试用例，在整数块大小$b \\in \\{1,2,\\dots,b_{\\max}\\}$上进行搜索，以找到使$T(b)$最小化的$b$值\n$$\nb_\\star = \\arg\\min_{b \\in \\{1,\\dots,b_{\\max}\\}} T(b),\n$$\n若有多个最小值，则选择最小的$b$。报告$b_\\star$和对应的$T(b_\\star)$。\n\n物理单位和输出要求：\n- $\\alpha$必须以“秒/消息”为单位使用。\n- $\\beta$必须以“秒/字”为单位使用。\n- $\\gamma$必须以“秒/浮点运算”为单位使用。\n- $T(b_\\star)$必须以秒为单位报告，并四舍五入到六位小数。\n\n测试套件：\n为以下参数集计算$b_\\star$和$T(b_\\star)$，这些参数集旨在探测不同的计算模式：\n1. $n=8192$, $p=32$, $S=8$, $\\alpha=5\\times 10^{-6}$ s/message, $\\beta=2\\times 10^{-9}$ s/word, $\\gamma=1.0\\times 10^{-12}$ s/flop, $c_f=12$, $c_w=8$, $b_{\\max}=64$.\n2. $n=16384$, $p=1$, $S=10$, $\\alpha=5\\times 10^{-6}$ s/message, $\\beta=2\\times 10^{-9}$ s/word, $\\gamma=1.0\\times 10^{-12}$ s/flop, $c_f=12$, $c_w=8$, $b_{\\max}=64$.\n3. $n=4096$, $p=16$, $S=12$, $\\alpha=50\\times 10^{-6}$ s/message, $\\beta=3\\times 10^{-9}$ s/word, $\\gamma=1.5\\times 10^{-12}$ s/flop, $c_f=10$, $c_w=6$, $b_{\\max}=32$.\n4. $n=16384$, $p=64$, $S=6$, $\\alpha=2\\times 10^{-6}$ s/message, $\\beta=1\\times 10^{-9}$ s/word, $\\gamma=5\\times 10^{-12}$ s/flop, $c_f=8$, $c_w=8$, $b_{\\max}=128$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述四个测试用例的顺序包含最佳块大小，后跟相应的总预测时间（单位：秒，保留六位小数），即\n$$\n[\\,b_\\star^{(1)},T(b_\\star^{(1)}),b_\\star^{(2)},T(b_\\star^{(2)}),b_\\star^{(3)},T(b_\\star^{(3)}),b_\\star^{(4)},T(b_\\star^{(4)})\\,].\n$$", "solution": "用户提供了一个关于分布式内存系统上数值算法的性能建模问题。一个关键的前提条件是验证问题陈述的科学合理性、清晰性和完整性。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n问题定义了一个性能模型，用于计算使用隐式多移位$QR$算法计算$n \\times n$矩阵特征值的总时间$T$。该模型依赖于一个整数凸起追逐块大小$b$。\n\n$S$次扫描的总时间由以下公式给出：\n$$\nT(b) = S\\left[\\alpha\\,M_{\\mathrm{sweep}}(b) + \\beta\\,W_{\\mathrm{sweep}}(b) + \\gamma\\,F_{\\mathrm{sweep}}(b)\\right]\n$$\n模型的组成部分定义如下：\n- 每次扫描的浮点运算次数：$F_{\\mathrm{sweep}}(b) = c_f \\, n \\, b$。\n- 每次扫描的消息数量：$M_{\\mathrm{sweep}}(b) = 2(p-1)\\,\\left\\lceil \\frac{p}{b} \\right\\rceil$。\n- 每次扫描的通信字数：$W_{\\mathrm{sweep}}(b) = 2(p-1)\\,c_w\\, b$。\n\n这里，$n$是矩阵维度，$p$是进程数，$S$是扫描次数，$\\alpha$是消息延迟，$\\beta$是逆带宽，$\\gamma$是每次浮点运算的时间，$c_f$和$c_w$是无量纲的建模常数。\n\n目标是找到最小化$T(b)$的最佳块大小$b_\\star$：\n$$\nb_\\star = \\arg\\min_{b \\in \\{1,2,\\dots,b_{\\max}\\}} T(b)\n$$\n平局打破规则指定在出现多个最小值点时选择最小的$b$。\n\n提供了四个具体的测试用例，包含了所有必要的参数值（$n, p, S, \\alpha, \\beta, \\gamma, c_f, c_w, b_{\\max}$）。\n\n**步骤2：使用提取的已知条件进行验证**\n1.  **科学依据**：该问题在高性能计算（HPC）和数值线性代数领域有充分的依据。延迟-带宽-计算模型（$T \\approx \\alpha M + \\beta W + \\gamma F$）是并行算法性能分析的一个标准（尽管简化）工具。将$F$、$M$和$W$作为块大小$b$的函数的特定模型，对于凸起追逐算法的行为是合理的抽象。问题背景——高能物理中离散化的哈密顿量导致三对角特征值问题——是真实可信的。该问题没有违反任何科学或数学原理。\n2.  **适定性**：该优化问题是适定的。目标函数$T(b)$在整数$b \\in \\{1, 2, \\dots, b_{\\max}\\}$的有限离散域上有明确定义。保证存在最小值。平局打破规则确保解$b_\\star$是唯一的。\n3.  **客观性**：问题使用精确、客观、形式化的数学语言陈述。所有术语都已定义，所有必需数据都已提供。没有主观或模糊的陈述。\n4.  **完整性与一致性**：问题是自洽的。它提供了得出解决方案所需的所有必要方程、参数和约束。没有内部矛盾。例如，当$p=1$时，$(p-1)$项变为零，从而正确地消除了通信成本，这与预期相符。\n5.  **可行性**：测试套件中提供的参数值对于现代分布式计算系统是物理上现实的。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。这是一个基于科学合理的性能模型的标准数值优化任务。我现在将着手解决。\n\n### 解决方案\n\n任务是为给定的参数集找到最小化总计算时间$T(b)$的最佳块大小$b_\\star$。需要最小化的函数是：\n$$\nT(b) = S\\left[\\alpha\\,M_{\\mathrm{sweep}}(b) + \\beta\\,W_{\\mathrm{sweep}}(b) + \\gamma\\,F_{\\mathrm{sweep}}(b)\\right]\n$$\n代入扫描分量的给定表达式，我们得到：\n$$\nT(b) = S \\left[ \\alpha \\cdot 2(p-1)\\left\\lceil \\frac{p}{b} \\right\\rceil + \\beta \\cdot 2(p-1)c_w b + \\gamma \\cdot c_f n b \\right]\n$$\n这个表达式可以重新整理以突出其对$b$的依赖关系：\n$$\nT(b) = \\left( 2 S \\alpha (p-1) \\right) \\left\\lceil \\frac{p}{b} \\right\\rceil + \\left( S(2\\beta(p-1)c_w + \\gamma c_f n) \\right) b\n$$\n该函数的结构揭示了并行算法设计中的一个基本权衡关系。\n1.  第一项，与$\\left\\lceil p/b \\right\\rceil$成正比，代表通信延迟所花费的总时间。这是$b$的一个单调不增的分段常数函数。增加块大小$b$可以聚合工作，减少通信回合数，从而分摊延迟成本。\n2.  第二项，与$b$成线性关系，代表通信带宽和浮点计算的组合成本。传输的数据量（$W_{\\mathrm{sweep}}$）和计算工作量（$F_{\\mathrm{sweep}}$）都被建模为随$b$线性扩展。这一项是单调递增的。\n\n最佳块大小$b_\\star$是能最好地平衡这两种相互竞争效应的整数值。对于小的$b$，延迟项占主导地位；而对于大的$b$，带宽和计算项占主导地位。$T(b)$的最小值通常位于一个中间值。\n\n当$p=1$时出现一个特殊情况。在这种单进程场景下，项$(p-1)$变为$0$，这正确地消除了两个通信项（$M_{\\mathrm{sweep}}$和$W_{\\mathrm{sweep}}$）。时间函数简化为：\n$$\nT(b) = S \\gamma c_f n b \\quad (\\text{对于 } p=1)\n$$\n这是一个关于$b$的纯线性递增函数。因此，对于任何单进程情况，最小时间将总是在最小可能的块大小处取得，即$b_\\star=1$。\n\n鉴于$b$的搜索空间是从$1$到$b_{\\max}$的小的有限整数集，找到最小值的最直接且稳健的方法是穷举搜索。每个测试用例的算法流程如下：\n1.  将目前找到的最小时间$T_{\\min}$初始化为无穷大，将最佳块大小$b_\\star$初始化为一个无效标记。\n2.  遍历从$1$到$b_{\\max}$的每个整数$b$。\n3.  对于每个$b$，使用提供的公式计算总时间$T(b)$。向上取整函数$\\lceil p/b \\rceil$使用标准数学库函数计算。\n4.  将计算出的$T(b)$与当前的最小值$T_{\\min}$进行比较。如果$T(b)  T_{\\min}$，则更新$T_{\\min} = T(b)$和$b_\\star = b$。严格不等式处理了指定的平局打破规则，确保选择实现最小时间的最小$b$。\n5.  在遍历所有可能的$b$值之后，最终的对$(b_\\star, T_{\\min})$即为该测试用例的解。\n\n最终的程序为四个参数集中的每一个实现了这个搜索过程，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the optimal block size 'b' that minimizes the total computation time T(b)\n    for a distributed eigenvalue algorithm, based on a given performance model.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each tuple contains: (n, p, S, alpha, beta, gamma, c_f, c_w, b_max)\n    test_cases = [\n        # Case 1\n        (8192, 32, 8, 5e-6, 2e-9, 1.0e-12, 12, 8, 64),\n        # Case 2\n        (16384, 1, 10, 5e-6, 2e-9, 1.0e-12, 12, 8, 64),\n        # Case 3\n        (4096, 16, 12, 50e-6, 3e-9, 1.5e-12, 10, 6, 32),\n        # Case 4\n        (16384, 64, 6, 2e-6, 1e-9, 5e-12, 8, 8, 128),\n    ]\n\n    results = []\n\n    def calculate_time(b, n, p, S, alpha, beta, gamma, c_f, c_w):\n        \"\"\"\n        Calculates the total predicted time T(b) for a given block size b.\n        \n        Args:\n            b (int): The bulge-chasing block size.\n            All other args are parameters from the test case.\n        \n        Returns:\n            float: The total predicted time T(b).\n        \"\"\"\n        # If p=1, there is no inter-process communication.\n        if p == 1:\n            M_sweep = 0.0\n            W_sweep = 0.0\n        else:\n            # Number of messages per sweep\n            M_sweep = 2.0 * (p - 1) * np.ceil(p / b)\n            # Number of words communicated per sweep\n            W_sweep = 2.0 * (p - 1) * c_w * b\n\n        # Floating-point operations per sweep\n        F_sweep = c_f * n * b\n\n        # Total time for S sweeps\n        total_time = S * (alpha * M_sweep + beta * W_sweep + gamma * F_sweep)\n        \n        return total_time\n\n    for case in test_cases:\n        n, p, S, alpha, beta, gamma, c_f, c_w, b_max = case\n        \n        min_time = float('inf')\n        best_b = -1\n\n        # Search over all allowed integer block sizes\n        for b in range(1, b_max + 1):\n            current_time = calculate_time(b, n, p, S, alpha, beta, gamma, c_f, c_w)\n            \n            # Update if a strictly smaller time is found.\n            # This handles the tie-breaking rule (favor smallest b).\n            if current_time  min_time:\n                min_time = current_time\n                best_b = b\n        \n        results.append(str(best_b))\n        results.append(f\"{min_time:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3525899"}]}