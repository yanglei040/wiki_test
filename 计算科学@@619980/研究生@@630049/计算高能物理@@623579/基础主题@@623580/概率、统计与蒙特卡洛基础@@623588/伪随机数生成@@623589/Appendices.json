{"hands_on_practices": [{"introduction": "伪随机数生成器（PRNG）虽然看起来能产生随机序列，但其背后隐藏着确定性的数学结构。在某些情况下，这种结构会与待解决的问题发生灾难性的相互作用。本练习将通过一个具体、可计算的例子，鲜明地展示一个看似良好的线性同余生成器（LCG）在特定蒙特卡洛积分任务中如何完全失效，从而强调理解生成器局限性的重要性 [@problem_id:3333392]。", "problem": "考虑由下式定义的乘法线性同余生成器 (LCG)：\n$$x_{k+1} \\equiv a\\,x_{k} \\pmod{m},$$\n其模数 $m = 2^{31}-1$，乘数 $a = 16807$，种子 $x_{0} \\in \\{1,2,\\dots,m-1\\}$。假设 $a$ 是模 $m$ 的一个原根，因此周期为 $m-1$。输出映射为 $u_{k} = x_{k}/m \\in (0,1)$，从而得到一个伪随机数生成器 (PRNG; pseudo-random number generator)。\n\n定义蒙特卡洛估计量\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} f(u_{k}),$$\n用于计算积分\n$$I = \\int_{0}^{1} f(u)\\,du,$$\n其中被积函数为\n$$f(u) = \\cos\\!\\big(2\\pi m\\,u\\big).$$\n\n从线性同余生成器和蒙特卡洛估计的核心定义出发，在不假设除给定信息外的任何特殊结构的情况下，构建确定渐近偏差的逻辑步骤\n$$b \\equiv \\lim_{n\\to\\infty} \\widehat{I}_{n} - I.$$\n你的最终答案必须是一个实数。如果需要任何中间数值近似，请勿四舍五入。最终答案不需要单位。", "solution": "目标是确定渐近偏差，其定义为 $b \\equiv \\lim_{n\\to\\infty} \\widehat{I}_{n} - I$。这需要计算两个量：积分的真实值 $I$，以及蒙特卡洛估计量的渐近极限 $\\lim_{n\\to\\infty} \\widehat{I}_{n}$。\n\n首先，我们计算积分 $I$ 的真实值。该积分定义为：\n$$I = \\int_{0}^{1} f(u)\\,du = \\int_{0}^{1} \\cos(2\\pi m u)\\,du$$\n为了计算这个积分，我们可以使用换元法。令 $v = 2\\pi m u$，这意味着 $du = \\frac{dv}{2\\pi m}$。积分上下限从 $u=0$ 变为 $v=0$，从 $u=1$ 变为 $v=2\\pi m$。\n$$I = \\int_{0}^{2\\pi m} \\cos(v) \\frac{dv}{2\\pi m} = \\frac{1}{2\\pi m} [\\sin(v)]_{0}^{2\\pi m}$$\n模数 $m$ 已知为 $m = 2^{31}-1$，它是一个整数。因此，积分上限 $2\\pi m$ 是 $2\\pi$ 的整数倍。正弦函数在所有 $\\pi$ 的整数倍处的值都为零。\n$$I = \\frac{1}{2\\pi m} (\\sin(2\\pi m) - \\sin(0)) = \\frac{1}{2\\pi m} (0 - 0) = 0$$\n因此，积分的精确值为 $I=0$。\n\n接下来，我们必须确定蒙特卡洛估计量的渐近极限 $\\lim_{n\\to\\infty} \\widehat{I}_{n}$。该估计量由下式给出：\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} f(u_{k})$$\n需要求值的函数是 $f(u) = \\cos(2\\pi m u)$。伪随机数 $u_k$ 是通过输出映射 $u_k = x_k/m$ 生成的，其中 $x_k$ 是来自线性同余生成器 (LCG) 的状态序列。\n我们来分析和中的单项 $f(u_k)$：\n$$f(u_k) = f(x_k/m) = \\cos\\left(2\\pi m \\frac{x_k}{m}\\right) = \\cos(2\\pi x_k)$$\nLCG 由 $x_{k+1} \\equiv a x_k \\pmod{m}$ 定义。种子 $x_0 \\in \\{1, 2, \\dots, m-1\\}$。由于模数 $m$ 是素数，且乘数 $a$ 是模 $m$ 的原根，序列 $\\{x_k\\}_{k \\ge 1}$ 会遍历集合 $\\{1, 2, \\dots, m-1\\}$ 中的所有整数。关键在于，每个状态 $x_k$ 都是一个整数。\n\n对于任意整数值 $j$，余弦函数在 $2\\pi j$ 处的值为：\n$$\\cos(2\\pi j) = 1$$\n由于对所有 $k \\ge 1$，每个状态 $x_k$ 都是整数，我们有：\n$$f(u_k) = \\cos(2\\pi x_k) = 1 \\quad \\text{for all } k \\ge 1$$\n蒙特卡洛和中的每一项都恰好等于 $1$。将此结果代回估计量 $\\widehat{I}_n$ 的表达式中：\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} 1 = \\frac{1}{n} \\cdot n = 1$$\n这个结果对任何样本量 $n \\ge 1$ 都成立。估计量序列是常数，即对所有 $n$ 都有 $\\widehat{I}_n = 1$。因此，其极限的计算是微不足道的：\n$$\\lim_{n\\to\\infty} \\widehat{I}_{n} = \\lim_{n\\to\\infty} 1 = 1$$\n问题陈述中提到生成器的周期是 $m-1$。这保证了序列 $\\{u_k\\}$ 是周期性的，从而确保极限 $\\lim_{n\\to\\infty} \\widehat{I}_n$ 存在且等于 $f(u_k)$ 在一个完整周期内的平均值。虽然这个信息对于严格证明极限的存在性很有用，但我们对 $f(u_k)$ 的直接计算表明每一项都恒等于 $1$，这使得极限的计算变得非常直接。\n\n最后，我们可以计算渐近偏差 $b$。\n$$b = \\lim_{n\\to\\infty} \\widehat{I}_{n} - I$$\n代入我们求得的值：\n$$b = 1 - 0 = 1$$\n渐近偏差恰好为 $1$。这说明了这个特定的伪随机数生成器对于这个特定的被积函数存在一个严重缺陷。生成的点 $u_k=x_k/m$ 的离散性质与函数 $f(u)=\\cos(2\\pi m u)$ 的高频特性完全对齐，导致蒙特卡洛方法系统性地仅在函数的最大值处进行采样。", "answer": "$$\\boxed{1}$$", "id": "3333392"}, {"introduction": "在上一个练习展示了生成器的结构性缺陷后，本练习将深入探讨导致这类缺陷的数学根源：线性。你将在xorshift生成器的背景下探索在$\\mathbb{F}_2$上的线性概念，并分析现代PRNG如何利用非线性输出函数来“打乱”输出、破坏线性相关性，从而提升其统计质量 [@problem_id:3333396]。理解这一点是掌握现代高质量生成器设计的关键。", "problem": "考虑一个基于固定字长 $w \\in \\mathbb{N}$ 的面向字的 xorshift 伪随机数生成器 (PRNG)，其内部状态为 $x \\in \\{0,1,\\dots,2^w-1\\}$。其更新规则应用一系列移位和异或操作，形式如下\n$$\nx \\leftarrow x \\oplus (x \\ll a), \\quad x \\leftarrow x \\oplus (x \\gg b), \\quad x \\leftarrow x \\oplus (x \\ll c),\n$$\n对于固定的、小于 $w$ 的正整数 $a$、 $b$ 和 $c$，其中 $\\ll$ 和 $\\gg$ 表示逻辑左移和右移，$\\oplus$ 表示按位异或。原始输出是更新后的字 $x$。假设我们输出一个置换后的字\n$$\ny \\equiv C \\cdot x \\pmod{2^w},\n$$\n对于一个固定的奇数 $C$，$1 \\leq C  2^w$。\n\n使用以下基本概念：\n\n- 包含两个元素的有限域 $\\mathbb{F}_2 = \\{0,1\\}$（加法和乘法在模 2 意义下进行），以及由 $w$ 比特字组成的向量空间 $\\mathbb{F}_2^w$（其上的运算为分量加法（按位异或）和标量乘法）。\n- 一个函数 $f:\\mathbb{F}_2^w \\to \\mathbb{F}_2^w$ 是 $\\mathbb{F}_2$-线性的，当且仅当对于所有 $u,v \\in \\mathbb{F}_2^w$ 和标量 $\\alpha \\in \\mathbb{F}_2$，都有 $f(u \\oplus v) = f(u) \\oplus f(v)$ 和 $f(\\alpha u) = \\alpha f(u)$。\n- 模 $2^w$ 的整数环，记作 $\\mathbb{Z}/2^w\\mathbb{Z}$，以及这样一个事实：模 $2^w$ 乘以 $C$ 是一个双射，当且仅当 $\\gcd(C,2^w)=1$。\n- 将双射应用于均匀分布的输出会保持字级别均匀性的原则。\n\n通过选择所有正确的陈述来回答以下多项选择题：\n\nA. 上述 xorshift 状态转移是 $\\mathbb{F}_2^w$ 上的一个线性变换，因此为检测二进制序列中的线性结构而设计的统计检验（例如，二进制矩阵秩和线性复杂度检验）可以揭示原始输出中的瑕疵。\n\nB. 对于奇数 $C$，映射 $f(x) = C \\cdot x \\bmod 2^w$ 在 $\\mathbb{F}_2^w$ 上是 $\\mathbb{F}_2$-线性的，因此它不能减轻 xorshift 生成器固有的线性瑕疵。\n\nC. 对于奇数 $C$，映射 $f(x) = C \\cdot x \\bmod 2^w$ 是 $\\mathbb{Z}/2^w\\mathbb{Z}$ 上的一个双射，并保持字级别的均匀性；此外，由于进位使得 $f$ 在 $\\mathbb{F}_2$ 上非线性，它可以减轻对 $\\mathbb{F}_2$-线性敏感的检验中的线性瑕疵。\n\nD. 将乘法置换应用于输出必然会使生成器的周期减少一个等于 $C$ 的因子，除非 $C=1$。\n\nE. 对于奇数 $C$，映射 $f(x) = C \\cdot x \\bmod 2^w$ 使得 $y$ 的每个输出比特都独立同分布于 $\\operatorname{Bernoulli}(1/2)$，而不管原始 xorshift 输出中存在的比特级缺陷。\n\n选择所有适用项。", "solution": "该问题要求我们评估关于一个面向字的 xorshift 伪随机数生成器 (PRNG) 和一个特定的乘法输出变换的五个陈述。首先，我们验证问题陈述的有效性。\n\n### 问题陈述验证\n\n**第1步：提取已知条件**\n- **生成器类型**：面向字的 xorshift PRNG。\n- **字长**：$w \\in \\mathbb{N}$。\n- **状态空间**：$x \\in \\{0, 1, \\dots, 2^w-1\\}$。\n- **状态更新规则**：一系列操作：$x \\leftarrow x \\oplus (x \\ll a)$，$x \\leftarrow x \\oplus (x \\gg b)$，$x \\leftarrow x \\oplus (x \\ll c)$，其中 $a, b, c$ 是小于 $w$ 的固定正整数。\n- **操作符**：$\\ll$ 和 $\\gg$ 是逻辑位移，$\\oplus$ 是按位异或。\n- **原始输出**：更新后的状态字 $x$。\n- **修改后输出**：一个置换后的字 $y \\equiv C \\cdot x \\pmod{2^w}$。\n- **乘数**：$C$ 是一个固定的奇数，$1 \\leq C  2^w$。\n- **基本概念**：\n    - 域 $\\mathbb{F}_2 = \\{0,1\\}$ 上的向量空间 $\\mathbb{F}_2^w$。\n    - $\\mathbb{F}_2^w$ 上 $\\mathbb{F}_2$-线性函数的定义。\n    - 整数环 $\\mathbb{Z}/2^w\\mathbb{Z}$。\n    - 乘以 $C$ 是 $\\mathbb{Z}/2^w\\mathbb{Z}$ 上的双射的条件是 $\\gcd(C, 2^w) = 1$。\n    - 将双射应用于均匀分布会保持字级别的均匀性。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学基础**：该问题描述了 xorshift 系列生成器以及一种提高其统计质量的常用技术（非线性输出混合）。这些是 PRNG 设计领域的标准概念。用于线性分析的 $\\mathbb{F}_2^w$ 和用于算术分析的 $\\mathbb{Z}/2^w\\mathbb{Z}$ 的数学框架是恰当且定义正确的。该问题是科学合理的。\n- **适定性**：该问题要求根据所提供的设置和基本原理来评估几个陈述的正确性。每个陈述都可以进行严格的有效性分析。\n- **客观性**：该问题以精确、正式的语言陈述，没有主观或含糊的术语。\n- **完整性和一致性**：问题陈述提供了分析生成器属性和评估选项所需的所有信息。没有矛盾之处。\n\n**第3步：结论与行动**\n问题陈述是有效的。我们将通过分析每个选项来推导解决方案。\n\n### 推导与选项分析\n\n设生成器的状态是向量空间 $\\mathbb{F}_2^w$ 中的一个向量。按位异或操作 $\\oplus$ 对应于 $\\mathbb{F}_2^w$ 中的向量加法。逻辑移位操作 $x \\ll a$ 和 $x \\gg b$ 是 $\\mathbb{F}_2^w$ 上的线性变换。它们可以由元素在 $\\mathbb{F}_2$ 中的 $w \\times w$ 矩阵表示。\n\n操作 $x \\leftarrow x \\oplus (x \\text{ shift } k)$ 可以写成 $x_{\\text{new}} = (I \\oplus S)x_{\\text{old}}$，其中 $I$ 是单位矩阵，$S$ 是移位操作的矩阵。线性变换的复合仍然是线性变换。因此，整个 xorshift 状态更新 $x_{n+1} = T(x_n)$ 是 $\\mathbb{F}_2^w$ 上的一个 $\\mathbb{F}_2$-线性变换。\n\n**A. 上述 xorshift 状态转移是 $\\mathbb{F}_2^w$ 上的一个线性变换，因此为检测二进制序列中的线性结构而设计的统计检验（例如，二进制矩阵秩和线性复杂度检验）可以揭示原始输出中的瑕疵。**\n\n如上所述，xorshift 生成器的状态转移是按位异或和移位操作的复合。设状态 $x$ 是 $\\mathbb{F}_2^w$ 中的一个向量。移位操作 $S(x)$ 是线性的，所以 $S(u \\oplus v) = S(u) \\oplus S(v)$。操作 $f(x) = x \\oplus S(x)$ 也是线性的：$f(u \\oplus v) = (u \\oplus v) \\oplus S(u \\oplus v) = (u \\oplus S(u)) \\oplus (v \\oplus S(v)) = f(u) \\oplus f(v)$。由于整个状态转移是这类线性函数的复合，它本身就是 $\\mathbb{F}_2^w$ 上的一个线性变换。\n这种固有的线性意味着输出字序列（如果我们以原始状态 $x$ 作为输出）满足 $\\mathbb{F}_2$ 上的一个线性递推关系。例如，对于任何 $w+1$ 个连续的原始输出序列 $x_n, x_{n+1}, \\dots, x_{n+w}$，存在一组非平凡的系数 $c_i \\in \\{0,1\\}$，使得 $\\bigoplus_{i=0}^w c_i x_{n+i} = 0$。这是一个巨大的统计缺陷。像二进制矩阵秩检验或线性复杂度检验这样的统计检验就是专门设计来检测这种线性关系的。像 xorshift 这样的 $\\mathbb{F}_2$-线性生成器会在这些检验中惨败。\n**结论：正确。**\n\n**B. 对于奇数 $C$，映射 $f(x) = C \\cdot x \\bmod 2^w$ 在 $\\mathbb{F}_2^w$ 上是 $\\mathbb{F}_2$-线性的，因此它不能减轻 xorshift 生成器固有的线性瑕疵。**\n\n为了检验 $\\mathbb{F}_2$-线性，我们必须验证是否对所有 $u, v \\in \\mathbb{F}_2^w$ 都有 $f(u \\oplus v) = f(u) \\oplus f(v)$。操作 $C \\cdot x \\pmod{2^w}$ 是整数乘法，而不是在 $\\mathbb{F}_2$ 上的按位操作。整数乘法涉及进位传播，当在 $\\mathbb{F}_2$ 上看待时，这是一个非线性操作。\n让我们考虑一个简单的反例。设 $w=4, C=3$。设 $u=1$ (二进制 `0001`) 和 $v=2$ (二进制 `0010`)。那么 $u \\oplus v = 3$ (二进制 `0011`)。\n- $f(u) = 3 \\cdot 1 \\pmod{16} = 3$ (二进制 `0011`)。\n- $f(v) = 3 \\cdot 2 \\pmod{16} = 6$ (二进制 `0110`)。\n- $f(u) \\oplus f(v) = 3 \\oplus 6 = 5$ (二进制 `0101`)。\n- $f(u \\oplus v) = f(3) = 3 \\cdot 3 \\pmod{16} = 9$ (二进制 `1001`)。\n由于 $f(u \\oplus v) = 9 \\neq 5 = f(u) \\oplus f(v)$，函数 $f(x)$ 不是 $\\mathbb{F}_2$-线性的。该陈述的前提是错误的。因为该映射实际上是非线性的，所以它有潜力减轻线性瑕疵，这与该陈述的结论相矛盾。\n**结论：不正确。**\n\n**C. 对于奇数 $C$，映射 $f(x) = C \\cdot x \\bmod 2^w$ 是 $\\mathbb{Z}/2^w\\mathbb{Z}$ 上的一个双射，并保持字级别的均匀性；此外，由于进位使得 $f$ 在 $\\mathbb{F}_2$ 上非线性，它可以减轻对 $\\mathbb{F}_2$-线性敏感的检验中的线性瑕疵。**\n\n这个陈述包含几个主张。\n1.  **双射**：映射 $f(x) = C \\cdot x$ 是 $\\mathbb{Z}/2^w\\mathbb{Z}$ 上的双射，当且仅当 $C$ 存在模 $2^w$ 的乘法逆元。这当且仅当 $\\gcd(C, 2^w) = 1$ 时成立。由于 $C$ 是奇数，其所有素因子都是奇数。$2^w$ 的唯一素因子是 2。因此，$\\gcd(C, 2^w) = 1$，该映射是一个双射。这个主张是正确的。\n2.  **均匀性**：如果假定原始输出 $x$ 在所有 $2^w$ 个字上是均匀分布的，那么将一个双射应用于这个集合会得到另一个包含 $2^w$ 个不同字的集合，这个集合也必须是均匀分布的。这个主张是正确的。\n3.  **非线性与减轻**：如选项 B 的分析所示，整数乘法涉及进位，使得函数 $f(x)$ 在 $\\mathbb{F}_2$ 上是非线性的。将非线性函数应用于线性生成器的输出是打破线性依赖关系的一种标准而有效的方法。得到的输出序列 $y_n = f(x_n)$ 将不满足原始序列 $x_n$ 所满足的简单线性递推关系。这改善了生成器在对 $\\mathbb{F}_2$-线性敏感的统计检验上的表现。这是现代 PRNG 设计（例如，PCG 和 xoshiro 系列）中的一个核心思想。这个主张是正确的。\n该陈述的所有部分都是正确的并且逻辑上是连贯的。\n**结论：正确。**\n\n**D. 将乘法置换应用于输出必然会使生成器的周期减少一个等于 $C$ 的因子，除非 $C=1$。**\n\nPRNG 的周期是其状态转移函数 $x_{n+1} = T(x_n)$ 的一个属性。输出函数 $y_n = f(x_n)$ 不会改变底层的状态序列 $\\{x_n\\}$。设状态序列的周期为 $P$，因此对于一个给定的循环，$x_{n+P} = x_n$。那么输出序列有 $y_{n+P} = f(x_{n+P}) = f(x_n) = y_n$。这意味着输出序列的周期必须是 $P$ 的一个因子。\n函数 $f(x)$ 是一个双射。如果输出周期是一个更小的值 $k  P$（其中 $k$ 整除 $P$），那将意味着对于循环中的所有 $n$，都有 $y_{n+k} = y_n$。这意味着 $f(x_{n+k}) = f(x_n)$。由于 $f$ 是一个双射，$f(a)=f(b)$ 当且仅当 $a=b$。因此，$x_{n+k} = x_n$，这与 $P$ 是状态序列的周期这一事实相矛盾。因此，输出序列的周期完全等于状态序列的周期。关于周期减少的陈述是错误的。\n**结论：不正确。**\n\n**E. 对于奇数 $C$，映射 $f(x) = C \\cdot x \\bmod 2^w$ 使得 $y$ 的每个输出比特都独立同分布于 $\\operatorname{Bernoulli}(1/2)$，而不管原始 xorshift 输出中存在的比特级缺陷。**\n\n这是一个非常强的断言。让我们分析一下该映射对最低有效位 (LSB) 的影响。设 $x_0$ 是 $x$ 的 LSB，$y_0$ 是 $y = C \\cdot x$ 的 LSB。在模 2 的整数算术中，乘积的 LSB 是 LSB 的乘积。所以，$y_0 \\equiv C_0 \\cdot x_0 \\pmod 2$，其中 $C_0$ 是 $C$ 的 LSB。由于 $C$ 是一个奇数，它的 LSB 是 $C_0=1$。因此，$y_0 \\equiv 1 \\cdot x_0 \\pmod 2$，这意味着 $y_0 = x_0$。\n输出 $y$ 的 LSB 与输入 $x$ 的 LSB 完全相同。乘法映射根本不改变 LSB。如果来自原始 xorshift 生成器的 LSB 序列存在统计缺陷（例如，周期短，或偏离 $1/2$ 的偏差），这些缺陷将直接传递给最终输出 $y$ 的 LSB。因此，该映射并不能修复所有的比特级缺陷，而且它肯定不能保证每个输出比特都变得完全随机。\n**结论：不正确。**\n\n最终结论：陈述 A 和 C 是正确的。", "answer": "$$\\boxed{AC}$$", "id": "3333396"}, {"introduction": "除了统计质量，现代高能物理对PRNG的一个关键要求是支持大规模并行计算。本练习将挑战你推导并实现“跳转”（skip-ahead）技术，它能让你高效地在生成器序列中向前跳跃任意步 [@problem_id:3529403]。这是为并行模拟创建独立、可复现的随机数流的基石，你将开发一个即使面对天文数字般的步长也依然高效的算法。", "problem": "您的任务是为线性同余生成器（LCG）形式化并实现一种高效的跳步方法。LCG是一种在计算高能物理（HEP）中广泛使用的伪随机数生成器，尤其适用于大规模蒙特卡洛事件生成，这类场景对可复现性、并行性和流分割至关重要。其基本过程是整数在正整数模下的LCG递推关系：\n- 状态更新由下式给出：$x_{t+1} = (a x_t + c) \\bmod m$，适用于所有整数 $t \\ge 0$，其中参数 $a$、$c$ 和 $m$ 是固定的整数，且 $m \\ge 2$，$x_t \\in \\{0,1,\\dots,m-1\\}$。\n\n从LCG的这个基本定义以及模算术的标准性质（例如模 $m$ 加法和乘法的结合律和分配律）出发，推导出一个关于 $a$、$c$、$m$、$x_t$ 和 $n$ 的 $x_{t+n}$ 的封闭形式表达式，推导过程中不得假设 $m$ 具有任何特殊的数论性质（不要假设素性或互素条件）。您的推导必须从递推定义开始，并且不得假定任何已知的封闭形式。所得公式必须对所有整数 $n \\ge 0$ 有效，包括 $a = 1$ 和 $c = 0$ 等特殊情况。\n\n然后，设计一个算法，能在关于 $n$ 的多对数时间内计算 $x_{t+n}$，具体来说，其渐近复杂度为 $\\mathcal{O}(\\log n)$ 次模 $m$ 算术运算，从而当 $n$ 大至 $10^{12}$ 时，计算上仍然可行。该算法必须避免使用模逆元，并且应对任意 $m$（包括 $m$ 是2的幂的情况）都是正确的。您的设计必须基于第一性原理，并清晰地指出被进行幂运算的代数结构。\n\n最后，将您的算法实现为一个完整的程序，为以下测试套件生成输出。每个测试用例都是独立的。对每个用例，计算所请求的单个结果，并将所有结果按指定的输出格式收集起来。\n\n测试套件：\n- 情况A（单位边界）：参数 $m = 97$，$a = 5$，$c = 3$，$x_t = 42$，$n = 0$。输出整数 $x_{t+n}$。\n- 情况B（单步检查）：参数 $m = 97$，$a = 5$，$c = 3$，$x_t = 42$，$n = 1$。输出整数 $x_{t+n}$。\n- 情况C（两步检查）：参数 $m = 97$，$a = 5$，$c = 3$，$x_t = 42$，$n = 2$。输出整数 $x_{t+n}$。\n- 情况D（小素数模下的大 $n$）：参数 $m = 97$，$a = 5$，$c = 3$，$x_t = 42$，$n = 10^{12}$。输出整数 $x_{t+n}$。\n- 情况E（实践中使用的2的幂模下的大 $n$）：参数 $m = 2^{48}$，$a = 25214903917$，$c = 11$，$x_t = 0$，$n = 10^{12}$。输出整数 $x_{t+n}$。\n- 情况F（乘法生成器边缘情况）：参数 $m = 2^{48}$，$a = 25214903917$，$c = 0$，$x_t = 1$，$n = 10^{12}$。输出整数 $x_{t+n}$。\n- 情况G（退化乘数 $a = 1$ 边缘情况）：参数 $m = 1{,}000{,}000{,}007$，$a = 1$，$c = 123{,}456{,}789$，$x_t = 987{,}654{,}321$，$n = 10^{12}$。输出整数 $x_{t+n}$。\n- 情况H（半群一致性性质，布尔值）：参数 $m = 2^{48}$，$a = 25214903917$，$c = 11$，$x_t = 123{,}456{,}789{,}012{,}345$，$n_1 = 10^{12} - 1{,}234{,}567$，$n_2 = 1{,}234{,}567$。计算语句“$x_{t+(n_1+n_2)}$ 等于先跳步 $n_1$ 再跳步 $n_2$ 的结果”的布尔真值，即判断\n$$\n\\bigl(x_{t+n_1}\\bigr) \\xrightarrow{\\text{跳步 } n_2} x_{t+n_1+n_2}\n\\quad \\text{是否等于} \\quad\nx_{t+(n_1+n_2)}\n$$\n当两者都由您的 $\\mathcal{O}(\\log n)$ 算法计算时。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含情况A到H的结果，按顺序排列，作为一个逗号分隔的列表，并用方括号括起来（例如，$[r_A,r_B,\\dots,r_H]$），其中每个 $r$ 是如上指定的整数或布尔值。不应打印任何额外文本。\n\n不涉及物理单位或角度单位。所有数值输出必须是指定的精确整数或布尔值。该算法必须通过采用 $\\mathcal{O}(\\log n)$ 的跳步策略，在现代机器上对于 $n = 10^{12}$ 的情况能在可行的时间内运行。", "solution": "该问题要求为线性同余生成器（LCG）推导并实现一个高效的跳步算法。LCG由以下递推关系定义：\n$$x_{t+1} = (a x_t + c) \\bmod m$$\n适用于整数 $t \\ge 0$，其中 $a$（乘数）、$c$（增量）和 $m$（模数）是固定的整数参数，且 $m \\ge 2$。生成器在时间 $t$ 的状态是 $x_t$，一个属于集合 $\\{0, 1, \\dots, m-1\\}$ 的整数。任务是在给定 $x_t$ 和一个大整数步长 $n$ 的情况下，以关于 $n$ 的多对数时间复杂度（具体为 $\\mathcal{O}(\\log n)$）找到 $x_{t+n}$。\n\n首先，我们通过展开递推关系来推导 $x_{t+n}$ 的封闭形式表达式。\n对于 $n=1$：\n$$x_{t+1} = a x_t + c$$\n对于 $n=2$：\n$$x_{t+2} = a x_{t+1} + c = a(a x_t + c) + c = a^2 x_t + ac + c$$\n对于 $n=3$：\n$$x_{t+3} = a x_{t+2} + c = a(a^2 x_t + ac + c) + c = a^3 x_t + a^2 c + ac + c$$\n观察这个模式，我们假设对于任何整数 $n \\ge 0$，状态 $x_{t+n}$ 由下式给出：\n$$x_{t+n} = a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)$$\n所有算术运算都是在模 $m$ 下进行的。我们用关于 $n$ 的数学归纳法来证明这个公式。\n\n**基础情况（$n=0$）：** 该公式给出 $x_{t+0} = a^0 x_t + c \\sum_{i=0}^{-1} a^i$。空和为 $0$，所以 $x_{t+0} = 1 \\cdot x_t + c \\cdot 0 = x_t$。这是正确的。\n**基础情况（$n=1$）：** 该公式给出 $x_{t+1} = a^1 x_t + c \\sum_{i=0}^{0} a^i = a x_t + c \\cdot a^0 = a x_t + c$。这与LCG的递推关系相符。\n\n**归纳步骤：** 假设该公式对某个整数 $k \\ge 0$ 成立：\n$$x_{t+k} = a^k x_t + c \\left(\\sum_{i=0}^{k-1} a^i\\right)$$\n我们现在求 $x_{t+k+1}$ 的表达式：\n$$x_{t+k+1} = a x_{t+k} + c$$\n代入 $x_{t+k}$ 的归纳假设：\n$$x_{t+k+1} = a \\left( a^k x_t + c \\sum_{i=0}^{k-1} a^i \\right) + c$$\n$$x_{t+k+1} = a^{k+1} x_t + a c \\sum_{i=0}^{k-1} a^i + c$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( a \\sum_{i=0}^{k-1} a^i + 1 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{i=0}^{k-1} a^{i+1} + a^0 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{j=1}^{k} a^{j} + a^0 \\right) = a^{k+1} x_t + c \\left( \\sum_{j=0}^{k} a^{j} \\right)$$\n这就是 $n=k+1$ 时的假设公式。归纳完成。$x_{t+n}$ 的封闭形式表达式为：\n$$x_{t+n} = \\left(a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)\\right) \\bmod m$$\n项 $\\sum_{i=0}^{n-1} a^i$ 是一个几何级数。如果 $a \\ne 1$，其和为 $\\frac{a^n-1}{a-1}$。使用这个公式需要计算 $(a-1) \\pmod m$ 的模乘法逆元，而如果 $\\gcd(a-1, m) \\ne 1$，该逆元可能不存在。问题明确禁止这种方法。如果 $a=1$，则级数和就是 $n$。我们需要一种普适的方法。\n\n为了在不使用模逆元的情况下达到 $\\mathcal{O}(\\log n)$ 的复杂度，我们可以将LCG更新表示为一个仿射变换，并对该变换使用平方求幂方法。函数 $f(x) = (ax+c) \\pmod m$ 将状态 $x_t$ 映射到 $x_{t+1}$。执行LCG $n$ 步等价于将此函数自身复合 $n$ 次：$f^n(x_t) = f(f(\\dots f(x_t)\\dots))$。\n\n这些仿射变换的代数结构可以用 $2 \\times 2$ 矩阵来捕捉。我们将状态 $x_t$ 扩充成一个向量 $\\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix}$。LCG的更新可以写成矩阵-向量乘积的形式：\n$$ \\begin{pmatrix} x_{t+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\n令 $T = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}$。应用变换 $n$ 次对应于将矩阵 $T$ 升至 $n$ 次幂：\n$$ \\begin{pmatrix} x_{t+n} \\\\ 1 \\end{pmatrix} = T^n \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\n可以使用平方求幂在 $\\mathcal{O}(\\log n)$ 时间内高效地计算出幂 $T^n$。其中的运算是模 $m$ 的 $2 \\times 2$ 矩阵乘法。\n$T^n$ 的结构是 $T^n = \\begin{pmatrix} a^n  c \\sum_{i=0}^{n-1} a^i \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} A_n  C_n \\\\ 0  1 \\end{pmatrix}$，其中 $A_n = a^n$ 和 $C_n = c \\sum_{i=0}^{n-1} a^i$ 是 $n$ 步的等效乘数和增量。\n与其实现完整的矩阵乘法，我们可以直接处理定义了仿射变换 $x \\mapsto Ax+C$ 的系数对 $(A, C)$。\n两个变换 $(A_1, C_1)$ 和 $(A_2, C_2)$ 的复合，即先应用前者再应用后者，结果是：\n$x \\xrightarrow{(A_1, C_1)} A_1 x + C_1 \\xrightarrow{(A_2, C_2)} A_2(A_1 x + C_1) + C_2 = (A_2 A_1) x + (A_2 C_1 + C_2)$。\n这为变换对定义了一个复合律：\n$$(A_2, C_2) \\circ (A_1, C_1) = (A_2 A_1, A_2 C_1 + C_2)$$\n该复合运算满足结合律。我们想要计算 $(a,c)^n$，即 $(a,c)$ 与自身复合 $n$ 次的结果。我们可以对这个对结构使用二进制指数算法（平方求幂）。\n\n计算 $(A_n, C_n) = (a, c)^n$ 的算法如下：\n1. 初始化结果对 $(A_{res}, C_{res})$ 为单位变换，即 $(1, 0)$（因为 $1 \\cdot x + 0 = x$）。\n2. 初始化累加器对 $(A_{acc}, C_{acc})$ 为基本变换 $(a, c)$。\n3. 当 $n > 0$ 时循环：\n   a. 如果 $n$ 是奇数，则将结果与累加器复合：$(A_{res}, C_{res}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{res}, C_{res})$。\n      - $A_{res}' = (A_{acc} \\cdot A_{res}) \\bmod m$\n      - $C_{res}' = (A_{acc} \\cdot C_{res} + C_{acc}) \\bmod m$\n   b. 将累加器自身复合（平方）：$(A_{acc}, C_{acc}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{acc}, C_{acc})$。\n      - $A_{acc}' = (A_{acc} \\cdot A_{acc}) \\bmod m$\n      - $C_{acc}' = (A_{acc} \\cdot C_{acc} + C_{acc}) \\bmod m$\n   c. 更新 $n$ 为 $n \\leftarrow \\lfloor n/2 \\rfloor$。\n4. 最终的对 $(A_{res}, C_{res})$ 就是 $(A_n, C_n)$。\n\n计算出 $(A_n, C_n)$ 后，最终状态 $x_{t+n}$ 计算如下：\n$$x_{t+n} = (A_n \\cdot x_t + C_n) \\bmod m$$\n整个过程涉及的模乘法和模加法次数与 $\\log_2 n$ 成正比，满足了复杂度要求。它避免了模逆元，并且对问题中指定的任意参数 $m, a, c$ 均有效。这种基于第一性原理、植根于仿射变换代数结构的方法，产生了一个健壮且高效的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem for a suite of test cases.\n    \"\"\"\n    \n    def lcg_skip_ahead(m, a, c, x0, n):\n        \"\"\"\n        Computes the n-th state of an LCG starting from x0 in O(log n) time.\n        The LCG is defined by x_next = (a * x + c) % m.\n\n        Args:\n            m (int): The modulus.\n            a (int): The multiplier.\n            c (int): The increment.\n            x0 (int): The initial state.\n            n (int): The number of steps to advance.\n\n        Returns:\n            int: The state x_n.\n        \"\"\"\n        if n == 0:\n            return x0\n\n        # The LCG recurrence x_next = a*x + c is an affine transformation.\n        # Advancing n steps is equivalent to composing this transformation n times.\n        # We can represent the transformation as a pair (A, C) for x -> A*x + C.\n        # The composition of (A1, C1) and (A2, C2) is (A2*A1, A2*C1 + C2).\n        # We use binary exponentiation (exponentiation by squaring) on this\n        # transformation pair to compute the n-step transformation (A_n, C_n).\n\n        # Ensure all initial parameters are within the modulus\n        a %= m\n        c %= m\n\n        # A_res, C_res store the resulting n-step transformation.\n        # Initialize to the identity transformation (A=1, C=0).\n        A_res, C_res = 1, 0  \n\n        # A_acc, C_acc store the transformation for the current power of 2.\n        # Initialize to the single-step transformation (a, c).\n        A_acc, C_acc = a, c\n        \n        k = n\n        while k > 0:\n            if k % 2 == 1:\n                # Compose the result with the current power-of-2 transformation.\n                # (A_res, C_res) -> (A_acc, C_acc) o (A_res, C_res)\n                # A_res' = A_acc * A_res\n                # C_res' = A_acc * C_res + C_acc\n                A_res_new = (A_acc * A_res) % m\n                C_res_new = (A_acc * C_res + C_acc) % m\n                A_res, C_res = A_res_new, C_res_new\n\n            # Square the power-of-2 transformation.\n            # (A_acc, C_acc) -> (A_acc, C_acc) o (A_acc, Cacc)\n            # A_acc' = A_acc * A_acc\n            # C_acc' = A_acc * C_acc + C_acc\n            A_acc_new = (A_acc * A_acc) % m\n            C_acc_new = (A_acc * C_acc + C_acc) % m\n            A_acc, C_acc = A_acc_new, C_acc_new\n            \n            k //= 2\n\n        # After the loop, (A_res, C_res) is the n-step transformation.\n        # Apply it to the initial state x0.\n        return (A_res * x0 + C_res) % m\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, a, c, x_t, n_or_n1, n2)\n        ('A', 97, 5, 3, 42, 0, None),\n        ('B', 97, 5, 3, 42, 1, None),\n        ('C', 97, 5, 3, 42, 2, None),\n        ('D', 97, 5, 3, 42, 10**12, None),\n        ('E', 2**48, 25214903917, 11, 0, 10**12, None),\n        ('F', 2**48, 25214903917, 0, 1, 10**12, None),\n        ('G', 1000000007, 1, 123456789, 987654321, 10**12, None),\n        ('H', 2**48, 25214903917, 11, 123456789012345, 10**12 - 1234567, 1234567),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_id, m, a, c, x_t, n1, n2 = case\n        \n        if case_id != 'H':\n            result = lcg_skip_ahead(m, a, c, x_t, n1)\n        else:\n            # Case H: Check semigroup property\n            n_total = n1 + n2\n            \n            # Compute x_{t + n1 + n2} directly\n            res_direct = lcg_skip_ahead(m, a, c, x_t, n_total)\n            \n            # Compute sequentially: skip by n1, then by n2\n            x_intermediate = lcg_skip_ahead(m, a, c, x_t, n1)\n            res_sequential = lcg_skip_ahead(m, a, c, x_intermediate, n2)\n            \n            result = (res_direct == res_sequential)\n            \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529403"}]}