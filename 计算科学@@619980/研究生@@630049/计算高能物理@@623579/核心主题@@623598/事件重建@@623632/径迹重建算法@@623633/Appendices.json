{"hands_on_practices": [{"introduction": "卡尔曼滤波器是现代径迹重建算法的基石。为了真正掌握其强大功能，亲手实践其核心步骤至关重要。第一个练习 [@problem_id:3539735] 提供了一个完整的单步预测-更新周期的具体数值算例，让你能够亲自计算更新后的径迹状态、其不确定性以及新测量点的拟合质量，从而巩固对这一基本过程的理解。", "problem": "在对撞机实验中，一个带电粒子径迹在两个硅探测器层之间被重建。在前一个表面到当前测量平面的一个小编步内，采用线性化的状态空间径迹模型，其状态向量为 $\\mathbf{x} = (u, t)^{\\mathsf{T}}$，其中 $u$ 是以 $\\mathrm{cm}$ 为单位的局部横向位置，$t = \\mathrm{d}u/\\mathrm{d}z$ 是局部斜率（无量纲）。过程模型是线性的，包含一个传输矩阵 $F$ 和一个表示微小多重散射涨落的过程噪声协方差 $Q$。在当前平面上的测量是一个单击中坐标 $y$，它通过一个测量矩阵 $H$ 与状态线性相关，测量噪声协方差为 $R$。所有噪声都假定为零均值高斯分布、相互独立，并具有给定的协方差。你需要执行一个从前一个滤波状态开始的预测-更新循环，以整合此次击中。\n\n使用以下数值输入：\n- 前一个滤波状态和协方差：$\\mathbf{x}_{0} = \\begin{pmatrix} 0.05 \\\\ 0.002 \\end{pmatrix}$，$P_{0} = \\begin{pmatrix} 1.0 \\times 10^{-4}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$。\n- 传输矩阵和过程噪声协方差：$F = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix}$，$Q = \\begin{pmatrix} 1.0 \\times 10^{-5}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$。\n- 测量模型和噪声协方差：$H = \\begin{pmatrix} 1  0 \\end{pmatrix}$，$R = 4.0 \\times 10^{-4}$。\n- 测量的击中坐标：$y = 0.115$（单位为 $\\mathrm{cm}$）。\n\n从状态传播和测量的贝叶斯线性高斯模型的第一性原理出发，推导并计算：\n1. 预测状态 $\\mathbf{x}^{-}$ 和预测协方差 $P^{-}$。\n2. 测量残差 $r$、新息协方差 $S$ 和用于更新的最优线性增益（卡尔曼增益）$K$。\n3. 整合击中后的更新状态 $\\mathbf{x}^{+}$ 和更新协方差 $P^{+}$。\n4. 此次击中贡献的增量卡方值 $\\Delta \\chi^{2}$。\n\n将增量卡方值 $\\Delta \\chi^{2}$ 作为你的最终数值答案。将答案四舍五入到四位有效数字。由于 $\\Delta \\chi^{2}$ 是无量纲的，最终答案不应报告单位。", "solution": "该问题要求执行线性卡尔曼滤波器的单个预测-更新循环，将一个新的测量值整合到带电粒子径迹的状态估计中。该过程基于线性高斯系统的贝叶斯推断原理。我们将首先验证问题陈述，然后系统地推导和计算所要求的量。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n- 前一个滤波状态向量：$\\mathbf{x}_{0} = \\begin{pmatrix} 0.05 \\\\ 0.002 \\end{pmatrix}$\n- 前一个滤波协方差矩阵：$P_{0} = \\begin{pmatrix} 1.0 \\times 10^{-4}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$\n- 传输矩阵：$F = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix}$\n- 过程噪声协方差矩阵：$Q = \\begin{pmatrix} 1.0 \\times 10^{-5}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$\n- 测量矩阵：$H = \\begin{pmatrix} 1  0 \\end{pmatrix}$\n- 测量噪声协方差（标量）：$R = 4.0 \\times 10^{-4}$\n- 测量的击中坐标（标量）：$y = 0.115$\n\n**步骤 2：使用提取的给定条件进行验证**\n- **科学依据：** 该问题描述了卡尔曼滤波器在高能物理中径迹重建的标准应用。线性状态空间模型对于小编步传播是一个常用且有效的近似。状态向量分量（$u$ 代表位置，$t$ 代表斜率）和矩阵（$F$ 代表线性传输，$Q$ 代表多重散射，$H$ 代表位置测量，$R$ 代表传感器分辨率）的物理解释在该领域都是标准的。数值对于硅探测器系统来说是物理上合理的。\n- **适定性：** 该问题提供了一套完整的初始条件和模型参数，足以执行一个卡尔曼滤波器循环。计算过程会导向一个唯一且稳定的解。\n- **客观性：** 问题陈述使用了精确的数学和物理术语，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n问题是有效的。这是一个适定的、有科学依据的、应用卡尔曼滤波器算法的练习。我们将继续进行求解。\n\n### 推导与计算\n\n卡尔曼滤波器循环包括两个主要步骤：预测步骤（将状态传播到新的测量表面）和更新步骤（使用新的测量来校正状态）。\n\n**1. 预测状态和协方差**\n\n状态使用传输矩阵 $F$ 从前一个表面传播到当前测量平面。过程噪声 $Q$ 解释了在此传输过程中增加的不确定性，例如由多重散射引起的不确定性。\n\n预测（先验）状态 $\\mathbf{x}^{-}$ 是传播后状态的期望值：\n$$\n\\mathbf{x}^{-} = F \\mathbf{x}_{0}\n$$\n预测（先验）协方差 $P^{-}$ 是传播后的前一个协方差与过程噪声协方差之和：\n$$\nP^{-} = F P_{0} F^{\\mathsf{T}} + Q\n$$\n代入给定值：\n$$\n\\mathbf{x}^{-} = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 0.05 \\\\ 0.002 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot (0.05) + 20 \\cdot (0.002) \\\\ 0 \\cdot (0.05) + 1 \\cdot (0.002) \\end{pmatrix} = \\begin{pmatrix} 0.05 + 0.04 \\\\ 0.002 \\end{pmatrix} = \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix}\n$$\n对于协方差：\n$$\nF P_{0} F^{\\mathsf{T}} = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\times 10^{-4}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 20  1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 1.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 20  1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} (1.0 \\times 10^{-4}) + (2.0 \\times 10^{-5})(20)  2.0 \\times 10^{-5} \\\\ 1.0 \\times 10^{-6}(20)  1.0 \\times 10^{-6} \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 1.0 \\times 10^{-4} + 4.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  1.0 \\times 10^{-6} \\end{pmatrix} = \\begin{pmatrix} 5.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  1.0 \\times 10^{-6} \\end{pmatrix}\n$$\n现在，加上过程噪声协方差 $Q$：\n$$\nP^{-} = \\begin{pmatrix} 5.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  1.0 \\times 10^{-6} \\end{pmatrix} + \\begin{pmatrix} 1.0 \\times 10^{-5}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}\n$$\n$$\nP^{-} = \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix}\n$$\n\n**2. 测量残差、新息协方差和卡尔曼增益**\n\n测量残差 $r$（或新息）是实际测量值 $y$ 与预测测量值 $H \\mathbf{x}^{-}$ 之间的差值。新息协方差 $S$ 是该残差的方差。卡尔曼增益 $K$ 是将预测与残差相结合的最优权重。\n\n残差 $r$ 为：\n$$\nr = y - H \\mathbf{x}^{-}\n$$\n新息协方差 $S$ 为：\n$$\nS = H P^{-} H^{\\mathsf{T}} + R\n$$\n卡尔曼增益 $K$ 为：\n$$\nK = P^{-} H^{\\mathsf{T}} S^{-1}\n$$\n代入数值：\n$$\nr = 0.115 - \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix} = 0.115 - 0.09 = 0.025\n$$\n对于新息协方差 $S$（在本例中为标量）：\n$$\nH P^{-} H^{\\mathsf{T}} = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 5.1 \\times 10^{-4}\n$$\n$$\nS = H P^{-} H^{\\mathsf{T}} + R = (5.1 \\times 10^{-4}) + (4.0 \\times 10^{-4}) = 9.1 \\times 10^{-4}\n$$\n对于卡尔曼增益 $K$（这是一个 $2 \\times 1$ 的向量）：\n$$\nP^{-} H^{\\mathsf{T}} = \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 5.1 \\times 10^{-4} \\\\ 2.0 \\times 10^{-5} \\end{pmatrix}\n$$\n$$\nK = P^{-} H^{\\mathsf{T}} S^{-1} = \\begin{pmatrix} 5.1 \\times 10^{-4} \\\\ 2.0 \\times 10^{-5} \\end{pmatrix} (9.1 \\times 10^{-4})^{-1} = \\frac{1}{9.1 \\times 10^{-4}} \\begin{pmatrix} 5.1 \\times 10^{-4} \\\\ 2.0 \\times 10^{-5} \\end{pmatrix} = \\frac{1}{9.1} \\begin{pmatrix} 5.1 \\\\ 0.2 \\end{pmatrix}\n$$\n\n**3. 更新状态和协方差**\n\n更新（后验）状态 $\\mathbf{x}^{+}$ 是通过加权残差校正后的预测状态。更新协方差 $P^{+}$ 是预测协方差减去从测量中获得的信息后的结果。\n\n更新状态 $\\mathbf{x}^{+}$ 为：\n$$\n\\mathbf{x}^{+} = \\mathbf{x}^{-} + K r\n$$\n更新协方差 $P^{+}$ 为：\n$$\nP^{+} = (I - K H) P^{-}\n$$\n代入数值：\n$$\n\\mathbf{x}^{+} = \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix} + \\frac{1}{9.1} \\begin{pmatrix} 5.1 \\\\ 0.2 \\end{pmatrix} (0.025) = \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix} + \\begin{pmatrix} \\frac{0.1275}{9.1} \\\\ \\frac{0.005}{9.1} \\end{pmatrix} \\approx \\begin{pmatrix} 0.09 + 0.01401 \\\\ 0.002 + 0.000549 \\end{pmatrix} = \\begin{pmatrix} 0.10401 \\\\ 0.002549 \\end{pmatrix}\n$$\n对于协方差：\n$$\nK H = \\frac{1}{9.1} \\begin{pmatrix} 5.1 \\\\ 0.2 \\end{pmatrix} \\begin{pmatrix} 1  0 \\end{pmatrix} = \\frac{1}{9.1} \\begin{pmatrix} 5.1  0 \\\\ 0.2  0 \\end{pmatrix}\n$$\n$$\nI - K H = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} - \\frac{1}{9.1} \\begin{pmatrix} 5.1  0 \\\\ 0.2  0 \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{5.1}{9.1}  0 \\\\ -\\frac{0.2}{9.1}  1 \\end{pmatrix} = \\begin{pmatrix} \\frac{4.0}{9.1}  0 \\\\ -\\frac{0.2}{9.1}  1 \\end{pmatrix}\n$$\n$$\nP^{+} = \\begin{pmatrix} \\frac{4.0}{9.1}  0 \\\\ -\\frac{0.2}{9.1}  1 \\end{pmatrix} \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix} \\approx \\begin{pmatrix} 2.24 \\times 10^{-4}  8.79 \\times 10^{-6} \\\\ 8.79 \\times 10^{-6}  1.56 \\times 10^{-6} \\end{pmatrix}\n$$\n\n**4. 增量卡方**\n\n增量卡方值 $\\Delta \\chi^2$ 量化了测量值与预测状态的兼容性。它是残差的马氏距离的平方，并由其协方差归一化。对于标量测量，其表达式为：\n$$\n\\Delta \\chi^{2} = r^{\\mathsf{T}} S^{-1} r = \\frac{r^2}{S}\n$$\n使用先前计算的值：\n$$\nr = 0.025\n$$\n$$\nS = 9.1 \\times 10^{-4}\n$$\n$$\n\\Delta \\chi^{2} = \\frac{(0.025)^2}{9.1 \\times 10^{-4}} = \\frac{6.25 \\times 10^{-4}}{9.1 \\times 10^{-4}} = \\frac{6.25}{9.1} \\approx 0.6868131868...\n$$\n四舍五入到四位有效数字，此次击中贡献的增量卡方值为 $0.6868$。", "answer": "$$\n\\boxed{0.6868}\n$$", "id": "3539735"}, {"introduction": "在真实的对撞机环境中，径迹并非孤立存在，而是淹没在由其他粒子和电子学噪声产生的大量“击中点”的海洋中。在应用卡尔曼滤波器之前，我们必须首先解决关键的“数据关联”问题：哪个击中点属于哪条径迹？本练习 [@problem_id:3539732] 将带你超越理想化的单径迹场景，挑战你实现一个稳健的、基于概率的框架来解决匹配的模糊性，并做出最优的分配决策。", "problem": "给定一组外推到单个探测器层的候选粒子径迹和该层中的一组测量命中。对于每个候选径迹，您有一个预测的二维位置和一个表示外推不确定性的协方差。探测器提供二维命中位置，并且测量噪声协方差是已知的。还有一个由泊松点过程（PPP）描述的针对虚假命中的均匀杂波模型。您的任务是基于一个有原则的概率模型计算径迹和命中之间的关联概率，然后根据最大后验（MAP）准则选择命中到径迹的一对一分配。\n\n基本和物理建模：\n- 假设测量模型为多元正态（MVN）：对于一个具有预测位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 和外推协方差 $\\mathbf{S}_i \\in \\mathbb{R}^{2 \\times 2}$ 的径迹，一个真实的关联命中 $\\mathbf{z}_j \\in \\mathbb{R}^2$ 的分布为 $\\mathcal{N}(\\mathbf{x}_i, \\mathbf{C}_i)$，其中 $\\mathbf{C}_i = \\mathbf{S}_i + \\mathbf{R}$ 且 $\\mathbf{R} \\in \\mathbb{R}^{2 \\times 2}$ 是测量噪声协方差。所有位置以毫米（mm）表示，协方差以平方毫米（$\\mathrm{mm}^2$）表示。\n- 假设在一个已知的传感器区域 $A$（单位为 $\\mathrm{mm}^2$）上存在均匀的杂波密度 $\\lambda$，每次读出的预期杂波命中数为 $\\Lambda$。那么 $\\lambda = \\Lambda / A$ 的单位是 $\\mathrm{mm}^{-2}$。\n- 每个径迹 $i$ 都有一个检测概率（PoD）$P_D^{(i)} \\in (0,1)$ 和一个先验存在概率 $P_T^{(i)} \\in (0,1)$。\n- 使用标准的门控规则，该规则采用平方马氏距离 $d_{ij}^2 = (\\mathbf{z}_j - \\mathbf{x}_i)^\\top \\mathbf{C}_i^{-1} (\\mathbf{z}_j - \\mathbf{x}_i)$ 和一个门限值 $\\gamma > 0$。仅当 $d_{ij}^2 \\le \\gamma$ 时，关联 $(i,j)$ 才是可接受的。\n\n关联概率：\n- 对于一个可接受的对 $(i,j)$，定义局部似然比 $L_{ij} = \\dfrac{P_D^{(i)} \\cdot \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i)}{\\lambda}$，其中 $\\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i)$ 是在 $\\mathbf{z}_j$ 处求值的MVN概率密度函数。对于不可接受的对，设置 $L_{ij} = 0$。\n- 对于径迹 $i$ 的漏检假设，定义 $L_{i0} = 1 - P_D^{(i)}$。\n- 那么，归一化的每个径迹的关联概率为 $p_{ij} = \\dfrac{L_{ij}}{L_{i0} + \\sum_k L_{ik}}$ 对于每个可接受的命中 $j$，以及 $p_{i0} = \\dfrac{L_{i0}}{L_{i0} + \\sum_k L_{ik}}$ 用于漏检。\n\n最大后验（MAP）分配：\n- 考虑联合分配，其中每个径迹要么分配给一个命中，要么分配为漏检，同时满足每个命中最多只能分配给一个径迹的约束。MAP分配在独立性假设和PPP杂波模型下最大化联合后验概率。在不考虑与分配无关的加性常数的情况下，这简化为最大化 $\\sum_i \\left[ \\log P_T^{(i)} + \\log L_{i,a(i)} \\right]$，其中 $a(i)$ 是为径迹 $i$ 选择的假设（可以是一个特定的命中 $j$ 或表示漏检的 $0$），并受限于命中之间的一对一约束。\n- 通过求解一个线性分配问题来实现此选择，该问题最小化负对数后验贡献的总和。使用一个成本矩阵，其条目对于可接受的对为 $c_{ij} = -\\left(\\log P_T^{(i)} + \\log P_D^{(i)} + \\log \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i) - \\log \\lambda\\right)$，对于不可接受的对为一个非常大的成本，对于漏检为 $c_{i,\\text{miss}} = -\\left(\\log P_T^{(i)} + \\log(1 - P_D^{(i)})\\right)$。通过为每个径迹提供一个唯一的漏检列来强制执行一对一约束。\n\n数值和单位要求：\n- 位置必须以毫米（mm）处理，协方差以平方毫米（$\\mathrm{mm}^2$）处理。此问题不涉及角度。\n- 最终输出由分配索引组成，这些索引是无量纲的、基于零的索引整数。使用 $-1$ 表示径迹的漏检。\n\n测试套件：\n提供四个具有科学上合理参数的测试用例。对于每个用例，您必须按所述计算MAP分配。\n\n- 测试用例 $1$（两个径迹，三个命中，宽门限）：\n  - 传感器区域：$A = 10000\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 0.5$，所以 $\\lambda = 0.00005\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限值：$\\gamma = 9.0$。\n  - 径迹：\n    - 径迹 $1$：$\\mathbf{x}_1 = [10.0, 10.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 0.5  0 \\\\ 0  0.5 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.9$，$P_T^{(1)} = 0.95$。\n    - 径迹 $2$：$\\mathbf{x}_2 = [20.0, 20.0]\\,\\mathrm{mm}$，$\\mathbf{S}_2 = \\begin{bmatrix} 0.7  0 \\\\ 0  0.7 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(2)} = 0.85$，$P_T^{(2)} = 0.9$。\n  - 命中：$\\mathbf{z}_1 = [9.6, 10.4]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [20.2, 19.7]\\,\\mathrm{mm}$，$\\mathbf{z}_3 = [50.0, 50.0]\\,\\mathrm{mm}$。\n\n- 测试用例 $2$（三个径迹，三个命中，竞争一个命中）：\n  - 传感器区域：$A = 400\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 0.2$，所以 $\\lambda = 0.0005\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 0.2  0 \\\\ 0  0.2 \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限值：$\\gamma = 4.0$。\n  - 径迹：\n    - 径迹 $1$：$\\mathbf{x}_1 = [0.0, 0.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 0.3  0 \\\\ 0  0.3 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.95$，$P_T^{(1)} = 0.99$。\n    - 径迹 $2$：$\\mathbf{x}_2 = [0.5, 0.0]\\,\\mathrm{mm}$，$\\mathbf{S}_2 = \\begin{bmatrix} 0.3  0 \\\\ 0  0.3 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(2)} = 0.95$，$P_T^{(2)} = 0.99$。\n    - 径迹 $3$：$\\mathbf{x}_3 = [5.0, 5.0]\\,\\mathrm{mm}$，$\\mathbf{S}_3 = \\begin{bmatrix} 0.3  0 \\\\ 0  0.3 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(3)} = 0.9$，$P_T^{(3)} = 0.9$。\n  - 命中：$\\mathbf{z}_1 = [0.2, -0.1]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [0.6, 0.1]\\,\\mathrm{mm}$，$\\mathbf{z}_3 = [5.1, 4.9]\\,\\mathrm{mm}$。\n\n- 测试用例 $3$（一个径迹，命中在门限外，低检测概率）：\n  - 传感器区域：$A = 10000\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 1.0$，所以 $\\lambda = 0.0001\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限值：$\\gamma = 9.0$。\n  - 径迹 $1$：$\\mathbf{x}_1 = [100.0, 100.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.2$，$P_T^{(1)} = 0.8$。\n  - 命中：$\\mathbf{z}_1 = [110.0, 110.0]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [90.0, 90.0]\\,\\mathrm{mm}$。\n\n- 测试用例 $4$（在门限处的边界门控）：\n  - 传感器区域：$A = 100\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 0.1$，所以 $\\lambda = 0.001\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 10^{-8}  0 \\\\ 0  10^{-8} \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限值：$\\gamma = 4.0$。\n  - 径迹 $1$：$\\mathbf{x}_1 = [0.0, 0.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.7$，$P_T^{(1)} = 0.9$。\n  - 命中：$\\mathbf{z}_1 = [2.0, 0.0]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [10.0, 0.0]\\,\\mathrm{mm}$。\n\n程序输出规范：\n- 对于每个测试用例，计算MAP分配，并生成一个整数列表，其长度等于径迹数，命中索引使用基于零的索引，-1表示漏检。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是每个测试用例的分配列表。例如，输出应类似于 $[\\,[a_{1,1}, a_{1,2}, \\dots], [a_{2,1}, \\dots], \\dots\\,]$，使用基于零的索引，-1代表漏检。", "solution": "我们从概率论和物理上真实的测量模型开始。一个外推到探测器层的候选径迹 $i$ 由一个预测位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 和一个外推协方差 $\\mathbf{S}_i \\in \\mathbb{R}^{2 \\times 2}$ 表示。一个测量的命中 $\\mathbf{z}_j \\in \\mathbb{R}^2$ 被建模为被协方差为 $\\mathbf{R} \\in \\mathbb{R}^{2 \\times 2}$ 的探测器噪声污染的真实位置。在标准假设下，一个关联命中的条件分布是多元正态（MVN）分布，$\\mathbf{z}_j \\mid \\text{径迹 } i \\sim \\mathcal{N}(\\mathbf{x}_i, \\mathbf{C}_i)$，其中 $\\mathbf{C}_i = \\mathbf{S}_i + \\mathbf{R}$。所有位置以毫米（mm）测量，协方差以平方毫米（$\\mathrm{mm}^2$）测量。\n\n为了确保物理和数值上的真实性，我们应用一个基于平方马氏距离的门控\n$$\nd_{ij}^2 = (\\mathbf{z}_j - \\mathbf{x}_i)^\\top \\mathbf{C}_i^{-1} (\\mathbf{z}_j - \\mathbf{x}_i),\n$$\n并且只考虑那些满足 $d_{ij}^2 \\le \\gamma$ 的关联 $(i,j)$，其中 $\\gamma > 0$ 是一个指定的门限值（例如，对应于MVN分布下的一个置信区域）。\n\n我们将虚假命中建模为传感器区域 $A$ 上的均匀泊松点过程（PPP），其期望计数为 $\\Lambda$，从而产生空间杂波密度 $\\lambda = \\Lambda / A$，单位为 $\\mathrm{mm}^{-2}$。该密度为评估一个命中是杂波而非源自特定径迹的可能性提供了参考。\n\n每个径迹 $i$ 都有一个检测概率（PoD）$P_D^{(i)} \\in (0,1)$ 和一个先验存在概率 $P_T^{(i)} \\in (0,1)$。给定一个命中 $\\mathbf{z}_j$，对于一个可接受的关联 $(i,j)$，其局部似然比根据贝叶斯法则和PPP杂波模型得出：\n$$\nL_{ij} = \\frac{P_D^{(i)} \\, \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i)}{\\lambda}.\n$$\n对于不可接受的 $(i,j)$（在门限之外），我们设置 $L_{ij} = 0$。径迹 $i$ 的漏检假设的似然比为\n$$\nL_{i0} = 1 - P_D^{(i)}.\n$$\n这些量是无量纲的，因为 $\\mathcal{N}(\\cdot)$ 和 $\\lambda$ 都是密度，而 $P_D^{(i)}$ 是无量纲的。\n\n对于每个径迹的关联概率，我们使用以下公式进行归一化\n$$\np_{ij} = \\frac{L_{ij}}{L_{i0} + \\sum_{k} L_{ik}}, \\quad p_{i0} = \\frac{L_{i0}}{L_{i0} + \\sum_{k} L_{ik}},\n$$\n这源于在径迹 $i$ 的互斥假设下的贝叶斯法则。\n\n全局最大后验（MAP）分配问题考虑将每个径迹分配给单个假设 $a(i)$（可以是一个特定的命中索引 $j$ 或表示漏检的 $0$），同时强制要求每个命中最多只能分配给一个径迹。在独立性假设下，并忽略与分配无关的常数，联合后验概率正比于\n$$\n\\prod_i \\left( P_T^{(i)} \\cdot L_{i,a(i)} \\right),\n$$\n因此我们寻求最大化\n$$\n\\sum_i \\left[ \\log P_T^{(i)} + \\log L_{i,a(i)} \\right].\n$$\n如果我们构建一个合适的成本矩阵，这就是一个线性分配问题。对于可接受的关联 $(i,j)$，定义成本\n$$\nc_{ij} = -\\left(\\log P_T^{(i)} + \\log P_D^{(i)} + \\log \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i) - \\log \\lambda \\right),\n$$\n对于不可接受的关联，将 $c_{ij}$ 设置为一个非常大的值，以有效禁止该配对。对于漏检，我们为每个径迹定义一个唯一的虚拟列，其成本为\n$$\nc_{i,\\text{miss}} = -\\left(\\log P_T^{(i)} + \\log(1 - P_D^{(i)})\\right).\n$$\n对于 $N$ 个径迹和 $M$ 个命中，我们通过附加 $N$ 个漏检列（每个径迹一个）来构建一个大小为 $N \\times (M + N)$ 的成本矩阵。这确保算法为每个径迹精确分配一个假设，并强制每个命中最多只能被分配一次。然后可以使用匈牙利算法（也称为 Kuhn–Munkres 算法）来找到最小化总成本的分配，这对应于MAP解。\n\n实现细节：\n- 为每个径迹计算 $\\mathbf{C}_i = \\mathbf{S}_i + \\mathbf{R}$。\n- 使用数值稳定的方法计算 $d_{ij}^2$，例如求解 $\\mathbf{C}_i \\mathbf{y} = \\mathbf{z}_j - \\mathbf{x}_i$ 得到 $\\mathbf{y}$，然后 $d_{ij}^2 = (\\mathbf{z}_j - \\mathbf{x}_i)^\\top \\mathbf{y}$。\n- 计算MVN密度\n$$\n\\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i) = \\frac{1}{2\\pi \\sqrt{\\det \\mathbf{C}_i}} \\exp\\left( -\\frac{1}{2} d_{ij}^2 \\right).\n$$\n- 使用一个大的有限成本（例如，$10^9$）来表示不允许的分配。通过不为门控外的配对计算对数密度来避免取 $\\log 0$。\n- 对于每个测试用例，构建成本矩阵，求解分配，并解码结果：如果一个径迹被分配给命中列 $j  M$，则输出 $j$；如果它被分配给其唯一的漏检列，则输出 $-1$。\n\n边缘情况：\n- 如果一个径迹的所有配对都在门限之外，它将被分配为漏检，因为可接受的命中成本实际上是无限的，而 $c_{i,\\text{miss}}$ 是有限的。\n- 如果平方马氏距离等于门限值（$d_{ij}^2 = \\gamma$），根据定义（$\\le \\gamma$），该关联是可接受的，并且密度也相应地做出贡献。\n- 当 $P_D^{(i)}$ 较低时，即使某些命中在门限内， $c_{i,\\text{miss}}$ 相对于命中关联也可能具有竞争力，这反映了低检测概率的底层物理原理。\n\n程序将计算四个提供的测试用例的分配，并打印包含一个分配列表的列表的单行，其中每个分配列表是一个整数列表，使用基于零的命中索引和-1表示漏检。此输出是无量纲的，因为它代表离散索引。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef mvn_density(diff: np.ndarray, C: np.ndarray):\n    \"\"\"\n    Compute the multivariate normal density N(z; x, C) at diff = z - x\n    where C is the covariance matrix.\n    \"\"\"\n    # Solve C y = diff to avoid explicit inverse for Mahalanobis distance\n    try:\n        y = np.linalg.solve(C, diff)\n    except np.linalg.LinAlgError:\n        # In case C is ill-conditioned, fall back to pseudo-inverse\n        y = np.linalg.pinv(C).dot(diff)\n    d2 = float(diff.T.dot(y))\n    detC = float(np.linalg.det(C))\n    if detC = 0:\n        # Numerical safeguard: if covariance is near-singular, use pseudo-det via SVD\n        s = np.linalg.svd(C, compute_uv=False)\n        detC = float(np.prod(s))\n        # If still zero, return an extremely small density\n        if detC == 0:\n            return 0.0, d2\n    norm_const = 1.0 / (2.0 * np.pi * np.sqrt(detC))\n    return norm_const * np.exp(-0.5 * d2), d2\n\ndef compute_cost_matrix(tracks, hits, R, gamma, lam):\n    \"\"\"\n    Build the cost matrix for MAP assignment.\n    tracks: list of dicts with keys x (2,), S (2x2), P_D, P_T\n    hits: list of 2D arrays\n    R: 2x2 measurement covariance\n    gamma: gating threshold\n    lam: clutter density (Lambda / A)\n    Returns:\n        cost_matrix: shape (N_tracks, N_hits + N_tracks)\n    \"\"\"\n    n_tracks = len(tracks)\n    n_hits = len(hits)\n    big_M = 1e9  # large cost for disallowed\n    cost = np.full((n_tracks, n_hits + n_tracks), big_M, dtype=float)\n    for i, trk in enumerate(tracks):\n        x = np.array(trk[\"x\"], dtype=float)\n        S = np.array(trk[\"S\"], dtype=float)\n        P_D = float(trk[\"P_D\"])\n        P_T = float(trk[\"P_T\"])\n        C = S + R\n        # Missed detection column for track i\n        miss_col = n_hits + i\n        # c_{i,miss} = - [ log P_T + log(1 - P_D) ]\n        miss_cost = - (np.log(P_T) + np.log(max(1e-12, 1.0 - P_D)))\n        cost[i, miss_col] = miss_cost\n        # Hit costs\n        for j, z in enumerate(hits):\n            z = np.array(z, dtype=float)\n            diff = z - x\n            density, d2 = mvn_density(diff, C)\n            if d2 = gamma and density > 0.0:\n                # c_{ij} = - [ log P_T + log P_D + log N - log lam ]\n                cij = - (np.log(P_T) + np.log(P_D) + np.log(density) - np.log(lam))\n                cost[i, j] = cij\n            else:\n                # inadmissible or negligible density\n                cost[i, j] = big_M\n    return cost\n\ndef map_assignment(tracks, hits, R, gamma, A, Lambda):\n    \"\"\"\n    Compute MAP assignment given tracks and hits.\n    Returns a list of ints per track: hit index (0-based) or -1 for missed detection.\n    \"\"\"\n    lam = Lambda / A\n    cost = compute_cost_matrix(tracks, hits, R, gamma, lam)\n    row_ind, col_ind = linear_sum_assignment(cost)\n    n_hits = len(hits)\n    assignment = [-1] * len(tracks)\n    for i, j in zip(row_ind, col_ind):\n        if j  n_hits:\n            # Assigned to hit j\n            assignment[i] = j\n        else:\n            # Assigned to missed detection (unique column per track)\n            assignment[i] = -1\n    return assignment\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"A\": 10000.0,\n            \"Lambda\": 0.5,\n            \"R\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float),\n            \"gamma\": 9.0,\n            \"tracks\": [\n                {\"x\": [10.0, 10.0], \"S\": np.array([[0.5, 0.0], [0.0, 0.5]], dtype=float), \"P_D\": 0.9, \"P_T\": 0.95},\n                {\"x\": [20.0, 20.0], \"S\": np.array([[0.7, 0.0], [0.0, 0.7]], dtype=float), \"P_D\": 0.85, \"P_T\": 0.9},\n            ],\n            \"hits\": [\n                [9.6, 10.4],\n                [20.2, 19.7],\n                [50.0, 50.0],\n            ],\n        },\n        # Test Case 2\n        {\n            \"A\": 400.0,\n            \"Lambda\": 0.2,\n            \"R\": np.array([[0.2, 0.0], [0.0, 0.2]], dtype=float),\n            \"gamma\": 4.0,\n            \"tracks\": [\n                {\"x\": [0.0, 0.0], \"S\": np.array([[0.3, 0.0], [0.0, 0.3]], dtype=float), \"P_D\": 0.95, \"P_T\": 0.99},\n                {\"x\": [0.5, 0.0], \"S\": np.array([[0.3, 0.0], [0.0, 0.3]], dtype=float), \"P_D\": 0.95, \"P_T\": 0.99},\n                {\"x\": [5.0, 5.0], \"S\": np.array([[0.3, 0.0], [0.0, 0.3]], dtype=float), \"P_D\": 0.9, \"P_T\": 0.9},\n            ],\n            \"hits\": [\n                [0.2, -0.1],\n                [0.6, 0.1],\n                [5.1, 4.9],\n            ],\n        },\n        # Test Case 3\n        {\n            \"A\": 10000.0,\n            \"Lambda\": 1.0,\n            \"R\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float),\n            \"gamma\": 9.0,\n            \"tracks\": [\n                {\"x\": [100.0, 100.0], \"S\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float), \"P_D\": 0.2, \"P_T\": 0.8},\n            ],\n            \"hits\": [\n                [110.0, 110.0],\n                [90.0, 90.0],\n            ],\n        },\n        # Test Case 4\n        {\n            \"A\": 100.0,\n            \"Lambda\": 0.1,\n            \"R\": np.array([[1e-8, 0.0], [0.0, 1e-8]], dtype=float),\n            \"gamma\": 4.0,\n            \"tracks\": [\n                {\"x\": [0.0, 0.0], \"S\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float), \"P_D\": 0.7, \"P_T\": 0.9},\n            ],\n            \"hits\": [\n                [2.0, 0.0],\n                [10.0, 0.0],\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        Lambda = case[\"Lambda\"]\n        R = case[\"R\"]\n        gamma = case[\"gamma\"]\n        tracks = case[\"tracks\"]\n        hits = case[\"hits\"]\n        assignment = map_assignment(tracks, hits, R, gamma, A, Lambda)\n        results.append(assignment)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3539732"}, {"introduction": "我们的重建模型的好坏取决于我们对探测器几何的了解程度。微小且未被建模的缺陷，例如准直误差，会给最终的物理测量带来系统性偏差。本练习 [@problem_id:3539729] 邀请你分析一个整体性的探测器旋转对重建横动量（$p_T$）的影响，它将向你展示如何利用基本的物理对称性来理解和约束这类系统效应。", "problem": "在具有螺线管磁场 $\\mathbf{B} = B\\,\\hat{\\mathbf{z}}$ 的对撞机探测器中，一个电荷为 $q$、横向动量为 $p_T$ 的带电粒子遵循一条螺旋轨迹。该轨迹在横向平面上的投影是一个半径为 $R$ 的圆，其半径 $R$ 与 $p_T$ 通过经过充分检验的关系式 $R = p_T/(|q| B)$ 相关联。考虑一个理想化的桶状径迹探测器，它由环绕束流轴的 $N$ 个圆柱形层面组成，这些层面的半径为 $\\{r_i\\}_{i=1}^N$。在横向平面上，某给定径迹上的击中点坐标记为 $(r_i,\\phi_i)$。\n\n假设存在一个微小的、相干的未对准，其中所有桶状层面都围绕束流轴刚性地旋转了同一个角度 $\\delta\\phi$，因此测量到的方位角为 $\\phi_i^{\\mathrm{meas}} = \\phi_i + \\delta\\phi$（对所有 $i$ 成立），而测量到的半径仍为 $r_i$。径迹是通过在均匀磁场中对五参数螺旋线 $(d_0, z_0, \\phi_0, \\cot\\theta, q/p)$ 进行无偏最大似然拟合来重建的，该过程可选择性地包含一个束斑约束，该约束仅固定 $(d_0, z_0)$，但不对初始方位角 $\\phi_0$ 施加任何绝对先验。\n\n从洛伦兹力定律和均匀磁场中横向动力学的旋转对称性出发，并且除了 $R = p_T/(|q| B)$ 之外不使用任何快捷公式，推导由相干旋转 $\\delta\\phi$ 引起的领先非平凡阶的分数偏差 $\\Delta p_T / p_T$（并说明该偏差是否在所有阶都为零）。然后，假设 $\\delta\\phi$ 是一个均值为零、标准差为 $\\sigma_{\\delta\\phi}$（单位为弧度）的微小系统性偏差，计算由 $\\sigma_{\\delta\\phi}$ 传播到重建 $p_T$ 上的相应领先阶分数系统不确定度 $\\sigma_{p_T}/p_T$。\n\n请以一个单行矩阵的形式给出你的最终答案，矩阵包含两个值：第一个是分数偏差 $\\Delta p_T/p_T$，第二个是分数系统不确定度 $\\sigma_{p_T}/p_T$。两个条目都应表示为符号的精确表达式，不要使用百分号。角度 $\\delta\\phi$ 和 $\\sigma_{\\delta\\phi}$ 以弧度为单位，无需四舍五入。", "solution": "用户要求推导由圆柱形径迹探测器的相干旋转未对准所引起的重建横向动量（$p_T$）的分数偏差和系统不确定度。\n\n### 问题验证\n\n#### 步骤 1：提取已知条件\n-   **物理设置**：一个电荷为 $q$ 的粒子在均匀螺线管磁场 $\\mathbf{B} = B\\,\\hat{\\mathbf{z}}$ 中运动。\n-   **轨迹**：在横向平面上的轨迹投影是一个半径为 $R$ 的圆。\n-   **控制关系**：横向动量 $p_T$ 通过 $R = p_T/(|q| B)$ 与半径相关联。\n-   **探测器几何结构**：一个理想化的桶状径迹探测器，具有 $N$ 个半径为 $\\{r_i\\}_{i=1}^N$ 的圆柱形层面。\n-   **真实击中点坐标**：在横向平面上，真实击中点位于 $(r_i, \\phi_i)$。\n-   **系统性未对准**：所有探测器层面都围绕束流轴（z轴）刚性地旋转了同一个角度 $\\delta\\phi$。\n-   **测量击中点坐标**：测量的方位角为 $\\phi_i^{\\mathrm{meas}} = \\phi_i + \\delta\\phi$，而半径 $r_i$ 被正确测量。\n-   **重建**：使用对五参数螺旋线的无偏最大似然拟合。束斑约束可以固定径迹起点参数 $(d_0, z_0)$，但不对初始方位角 $\\phi_0$ 进行约束。\n-   **任务 1**：推导在 $\\delta\\phi$ 的领先非平凡阶上的分数偏差 $\\Delta p_T / p_T = (p_T^{\\mathrm{rec}} - p_T) / p_T$。\n-   **任务 2**：假设 $\\delta\\phi$ 是一个均值为零、标准差为 $\\sigma_{\\delta\\phi}$ 的随机变量，计算分数系统不确定度 $\\sigma_{p_T}/p_T$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于带电粒子在磁场中的动力学原理和粒子径迹重建的标准概念。该设定是一个定义明确但理想化的常见实验问题模型。语言精确客观。问题是自洽的，不包含矛盾。从洛伦兹力和旋转对称性出发的指令为推导提供了清晰的路径，强调了基本原理而非程序化的拟合细节。该问题是适定的，旨在基于所提供的物理原理寻求一个唯一且有意义的解。\n\n#### 步骤 3：结论与行动\n问题是有效的。基于旋转对称性原理的严谨解是可能且适当的。\n\n### 推导\n\n分析始于控制粒子运动的基本原理以及指定未对准的几何后果。\n\n洛伦兹力定律 $\\mathbf{F} = q(\\mathbf{v} \\times \\mathbf{B})$ 决定了粒子的轨迹。当 $\\mathbf{B} = B\\,\\hat{\\mathbf{z}}$ 时，横向分量 $(v_x, v_y)$ 的运动方程为：\n$$\nm \\frac{d v_x}{dt} = q v_y B\n$$\n$$\nm \\frac{d v_y}{dt} = -q v_x B\n$$\n这些耦合微分方程描述了在横向平面上的匀速圆周运动。解是一个半径为 $R$ 的圆，由 $R = p_T / (|q| B)$ 给出，其中 $p_T = m v_T = m \\sqrt{v_x^2 + v_y^2}$。该物理系统具有绕z轴的旋转对称性。\n\n设粒子在横向（x,y）平面上的真实轨迹是一个以 $(x_c, y_c)$ 为中心、半径为 $R$ 的圆。该轨迹上一个半径为 $r_i$、角度为 $\\phi_i$ 的击中点 $(x_i, y_i)$ 满足方程：\n$$\n(x_i - x_c)^2 + (y_i - y_c)^2 = R^2\n$$\n其中 $x_i = r_i \\cos\\phi_i$ 且 $y_i = r_i \\sin\\phi_i$。\n\n指定的未对准是整个探测器系统围绕原点的一个角度为 $\\delta\\phi$ 的相干旋转。因此，第 $i$ 个击中点的测量坐标 $(x_i^{\\mathrm{meas}}, y_i^{\\mathrm{meas}})$ 是真实坐标旋转 $\\delta\\phi$ 后的结果：\n$$\n\\begin{pmatrix} x_i^{\\mathrm{meas}} \\\\ y_i^{\\mathrm{meas}} \\end{pmatrix}\n=\n\\begin{pmatrix} \\cos(\\delta\\phi)  -\\sin(\\delta\\phi) \\\\ \\sin(\\delta\\phi)  \\cos(\\delta\\phi) \\end{pmatrix}\n\\begin{pmatrix} x_i \\\\ y_i \\end{pmatrix}\n$$\n该变换对应于测量的极坐标 $(r_i^{\\mathrm{meas}}, \\phi_i^{\\mathrm{meas}}) = (r_i, \\phi_i + \\delta\\phi)$，与问题陈述一致。\n\n旋转是一种等距变换，意味着它保持距离不变。让我们来检验测量点集合的几何特性。我们将同样的旋转应用于真实圆的圆心，定义一个新的圆心 $(x_c^{\\mathrm{meas}}, y_c^{\\mathrm{meas}})$：\n$$\n\\begin{pmatrix} x_c^{\\mathrm{meas}} \\\\ y_c^{\\mathrm{meas}} \\end{pmatrix}\n=\n\\begin{pmatrix} \\cos(\\delta\\phi)  -\\sin(\\delta\\phi) \\\\ \\sin(\\delta\\phi)  \\cos(\\delta\\phi) \\end{pmatrix}\n\\begin{pmatrix} x_c \\\\ y_c \\end{pmatrix}\n$$\n一个测量击中点与旋转后圆心之间的距离平方为：\n$$\n(x_i^{\\mathrm{meas}} - x_c^{\\mathrm{meas}})^2 + (y_i^{\\mathrm{meas}} - y_c^{\\mathrm{meas}})^2\n$$\n使用矢量表示法 $\\mathbf{r}_i = (x_i, y_i)^T$ 和旋转矩阵 $\\mathbf{R}_{\\delta\\phi}$，该距离是 $(\\mathbf{R}_{\\delta\\phi} \\mathbf{r}_i - \\mathbf{R}_{\\delta\\phi} \\mathbf{r}_c) = \\mathbf{R}_{\\delta\\phi} (\\mathbf{r}_i - \\mathbf{r}_c)$ 的范数平方。由于旋转矩阵是正交的（$\\mathbf{R}_{\\delta\\phi}^T \\mathbf{R}_{\\delta\\phi} = \\mathbf{I}$），范数保持不变：\n$$\n\\| \\mathbf{R}_{\\delta\\phi} (\\mathbf{r}_i - \\mathbf{r}_c) \\|^2 = (\\mathbf{r}_i - \\mathbf{r}_c)^T \\mathbf{R}_{\\delta\\phi}^T \\mathbf{R}_{\\delta\\phi} (\\mathbf{r}_i - \\mathbf{r}_c) = \\| \\mathbf{r}_i - \\mathbf{r}_c \\|^2 = (x_i - x_c)^2 + (y_i - y_c)^2 = R^2\n$$\n这表明测量点的集合 $\\{ (x_i^{\\mathrm{meas}}, y_i^{\\mathrm{meas}}) \\}$ 完全位于一个与真实轨迹半径 *完全相同* 的圆上。唯一的变化是圆心从 $(x_c, y_c)$ 旋转到了 $(x_c^{\\mathrm{meas}}, y_c^{\\mathrm{meas}})$。\n\n问题陈述，径迹重建是使用无偏最大似然拟合进行的。当提供一组完全位于一个圆上的点时，无偏拟合算法将返回该圆的真实参数。因此，拟合半径 $R^{\\mathrm{fit}}$ 必须等于测量点所在圆的半径。\n$$\nR^{\\mathrm{fit}} = R\n$$\n重建的横向动量 $p_T^{\\mathrm{rec}}$ 是由这个拟合半径决定的：\n$$\np_T^{\\mathrm{rec}} = |q| B R^{\\mathrm{fit}}\n$$\n代入 $R^{\\mathrm{fit}} = R$，我们发现：\n$$\np_T^{\\mathrm{rec}} = |q| B R = p_T\n$$\n其中 $p_T$ 是粒子的真实横向动量。\n\n**第 1 部分：分数偏差**\n横向动量的偏差 $\\Delta p_T$ 是重建值与真实值之差：\n$$\n\\Delta p_T = p_T^{\\mathrm{rec}} - p_T = p_T - p_T = 0\n$$\n对于旋转角 $\\delta\\phi$ 的任何值，偏差都恒等于零。因此，分数偏差也恒等于零：\n$$\n\\frac{\\Delta p_T}{p_T} = 0\n$$\n由于偏差精确为零，在 $\\delta\\phi$ 的幂级数展开中所有项都为零。不存在“领先非平凡阶”，因为没有任何一阶是非平凡的。\n\n**第 2 部分：分数系统不确定度**\n由参数 $\\delta\\phi$ 的不确定度引起的 $p_T$ 测量中的系统不确定度可以通过不确定度传播来求得。由标准差为 $\\sigma_{\\delta\\phi}$ 的 $\\delta\\phi$ 值分布所导致的重建 $p_T$ 值分布的标准差 $\\sigma_{p_T}$，其一阶近似由下式给出：\n$$\n\\sigma_{p_T} = \\left| \\frac{\\partial p_T^{\\mathrm{rec}}}{\\partial (\\delta\\phi)} \\right| \\sigma_{\\delta\\phi}\n$$\n如上所述，$p_T^{\\mathrm{rec}}$ 是一个等于真实 $p_T$ 的常数，并且与 $\\delta\\phi$ 没有函数依赖关系。因此，其导数为零：\n$$\n\\frac{\\partial p_T^{\\mathrm{rec}}}{\\partial (\\delta\\phi)} = \\frac{\\partial p_T}{\\partial (\\delta\\phi)} = 0\n$$\n这意味着传播的不确定度为零：\n$$\n\\sigma_{p_T} = 0 \\cdot \\sigma_{\\delta\\phi} = 0\n$$\n因此，分数系统不确定度也为零：\n$$\n\\frac{\\sigma_{p_T}}{p_T} = 0\n$$\n这个结果是该问题旋转对称性的直接推论。探测器的全局旋转与物理事件本身的旋转是不可区分的，因此在旋转下不变的量（如曲率半径）不受此类未对准的影响，前提是重建算法不受破坏这种对称性的约束（例如，问题明确排除了对径迹绝对方向 $\\phi_0$ 的固定先验）。\n\n最终答案包含分数偏差和分数系统不确定度。两者均为零。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0  0 \\end{pmatrix}}\n$$", "id": "3539729"}]}