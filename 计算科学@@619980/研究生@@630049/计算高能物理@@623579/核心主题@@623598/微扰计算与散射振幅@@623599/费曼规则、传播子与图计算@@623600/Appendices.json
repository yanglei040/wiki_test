{"hands_on_practices": [{"introduction": "掌握圈图计算的第一步是解析求解标量“气泡”图，这是最简单也最基础的单圈费曼图。我们将利用维度正则化这一处理紫外发散的标准方法，它能够在保持规范不变性的前提下有效处理无穷大。通过完成这个解析计算 ([@problem_id:3515127])，你将深刻理解所有圈图计算中极点和对数项的来源，为后续更复杂的数值方法打下坚实基础。", "problem": "考虑四维闵可夫斯基时空中的一个无质量标量场论，以及一个外动量为 $p$ 的单圈两点（气泡）图。使用维数正规化，将圈动量积分解析延拓至 $d=4-2\\epsilon$ 维，并引入重整化标度 $\\mu$ 以保持积分的无量纲性。标量气泡积分定义为\n$$\nI(p^{2}) \\equiv \\mu^{2\\epsilon} \\int \\frac{d^{d}k}{(2\\pi)^{d}} \\frac{1}{\\big(k^{2}+i0\\big)\\big((k+p)^{2}+i0\\big)}\\,,\n$$\n其中 $p^{2} \\equiv p_{\\mu}p^{\\mu}$，无穷小量 $+i0$ 用于实现费曼规定。从量子场论的第一性原理出发，即用于传播子乘积的费曼参数表示法和经过充分检验的 $d$ 维高斯积分结果，推导出 $I(p^{2})$ 关于 $\\epsilon$、$\\mu$ 和 $p^{2}$ 的解析表达式。提取其在 $\\epsilon$ 中的完整极点结构，并明确给出有限的 $\\mathcal{O}(\\epsilon^{0})$ 项。您应该追踪在维数正规化中出现的欧拉-马歇罗尼常数 $\\gamma_{E}$ 和 $\\ln(4\\pi)$ 因子。假设 $p^{2}$ 是类空的，从而 $\\ln(-p^{2}-i0)$ 通过解析延拓是良定义的。\n\n请提供 $I(p^{2})$ 的单一闭式解析表达式，该表达式应包含到 $\\mathcal{O}(\\epsilon^{0})$ 的有限项。最终表达式中不需要进行数值取整，也不应包含单位。", "solution": "该问题要求使用维数正规化，在 $d=4-2\\epsilon$ 维中计算单圈无质量标量气泡积分 $I(p^2)$。该积分定义为：\n$$\nI(p^{2}) = \\mu^{2\\epsilon} \\int \\frac{d^{d}k}{(2\\pi)^{d}} \\frac{1}{\\big(k^{2}+i0\\big)\\big((k+p)^{2}+i0\\big)}\n$$\n\n首先，我们使用费曼参数恒等式来合并两个分母：\n$$\n\\frac{1}{A B} = \\int_{0}^{1} dx \\frac{1}{[xA + (1-x)B]^2}\n$$\n令 $A = (k+p)^2+i0$ 和 $B = k^2+i0$。分母变为：\n$$\n[x((k+p)^2+i0) + (1-x)(k^2+i0)]^2 = [k^2 + 2xk \\cdot p + xp^2 + i0]^2\n$$\n我们可以对圈动量 $k$ 进行配方。令 $l = k+xp$，则 $k = l-xp$。方括号中的项变为：\n$$\n(l-xp)^2 + 2x(l-xp)\\cdot p + xp^2 + i0 = l^2 - 2xl\\cdot p + x^2p^2 + 2xl\\cdot p - 2x^2p^2 + xp^2 + i0 = l^2 - x^2p^2 + xp^2 + i0 = l^2 + x(1-x)p^2 + i0\n$$\n积分 $I(p^2)$ 现在是：\n$$\nI(p^2) = \\mu^{2\\epsilon} \\int_0^1 dx \\int \\frac{d^d l}{(2\\pi)^d} \\frac{1}{[l^2 + x(1-x)p^2 + i0]^2}\n$$\n分母可以写成 $(l^2 - \\Delta + i0)^2$ 的形式，其中 $\\Delta = -x(1-x)p^2$。动量积分可以通过进行威克转动（$l_0 = i l_{E0}$）并使用闵可夫斯基空间积分的标准公式来计算：\n$$\n\\int \\frac{d^d l}{(2\\pi)^d} \\frac{1}{(l^2 - \\Delta + i0)^n} = \\frac{i(-1)^n}{(4\\pi)^{d/2}} \\frac{\\Gamma(n-d/2)}{\\Gamma(n)} (\\Delta)^{d/2-n}\n$$\n在我们的情况下，$n=2$ 且 $d=4-2\\epsilon$。因此，$d/2 = 2-\\epsilon$，$n-d/2 = 2-(2-\\epsilon) = \\epsilon$，以及 $d/2-n = (2-\\epsilon)-2 = -\\epsilon$。动量积分变为：\n$$\n\\int \\frac{d^d l}{(2\\pi)^d} \\frac{1}{[l^2 - \\Delta + i0]^2} = \\frac{i(-1)^2}{(4\\pi)^{2-\\epsilon}} \\frac{\\Gamma(\\epsilon)}{\\Gamma(2)} (\\Delta)^{-\\epsilon} = \\frac{i}{(4\\pi)^{2-\\epsilon}} \\Gamma(\\epsilon) (\\Delta)^{-\\epsilon}\n$$\n代入 $\\Delta = -x(1-x)p^2$：\n$$\n\\frac{i}{(4\\pi)^{2}} (4\\pi)^{\\epsilon} \\Gamma(\\epsilon) [-x(1-x)p^2]^{-\\epsilon}\n$$\n现在，我们将此结果代回到 $I(p^2)$ 的表达式中：\n$$\nI(p^2) = \\mu^{2\\epsilon} \\int_0^1 dx \\, \\left( \\frac{i}{(4\\pi)^2} (4\\pi)^{\\epsilon} \\Gamma(\\epsilon) [-x(1-x)p^2]^{-\\epsilon} \\right)\n$$\n$$\nI(p^2) = \\frac{i \\Gamma(\\epsilon)}{(4\\pi)^2} (4\\pi \\mu^2)^{\\epsilon} (-p^2)^{-\\epsilon} \\int_0^1 dx \\, [x(1-x)]^{-\\epsilon}\n$$\n剩下的关于费曼参数 $x$ 的积分是欧拉Beta函数：\n$$\n\\int_0^1 dx \\, x^{-\\epsilon} (1-x)^{-\\epsilon} = B(1-\\epsilon, 1-\\epsilon) = \\frac{\\Gamma(1-\\epsilon)\\Gamma(1-\\epsilon)}{\\Gamma(2-2\\epsilon)}\n$$\n所以 $I(p^2)$ 的完整表达式是：\n$$\nI(p^2) = \\frac{i}{(4\\pi)^2} \\Gamma(\\epsilon) \\left( \\frac{4\\pi \\mu^2}{-p^2} \\right)^{\\epsilon} \\frac{\\Gamma(1-\\epsilon)^2}{\\Gamma(2-2\\epsilon)}\n$$\n为了找到极点结构和有限项，我们对该表达式在 $\\epsilon$ 很小时进行展开。我们使用以下展开式：\n1. $\\Gamma(\\epsilon) = \\frac{1}{\\epsilon} - \\gamma_E + \\mathcal{O}(\\epsilon)$\n2. $\\left( \\frac{4\\pi \\mu^2}{-p^2} \\right)^{\\epsilon} = \\exp\\left[\\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right)\\right] = 1 + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) + \\mathcal{O}(\\epsilon^2)$\n3. $\\Gamma(1-\\epsilon) = 1 + \\epsilon\\gamma_E + \\mathcal{O}(\\epsilon^2)$，所以 $\\Gamma(1-\\epsilon)^2 = 1 + 2\\epsilon\\gamma_E + \\mathcal{O}(\\epsilon^2)$\n4. $\\Gamma(2-2\\epsilon) = (1-2\\epsilon)\\Gamma(1-2\\epsilon) \\approx (1-2\\epsilon)(1+2\\epsilon\\gamma_E) = 1+2\\epsilon\\gamma_E-2\\epsilon + \\mathcal{O}(\\epsilon^2)$。因此，$\\frac{1}{\\Gamma(2-2\\epsilon)} \\approx 1-(2\\epsilon\\gamma_E-2\\epsilon) = 1-2\\epsilon\\gamma_E+2\\epsilon + \\mathcal{O}(\\epsilon^2)$。\nGamma函数的比值为：\n$$\n\\frac{\\Gamma(1-\\epsilon)^2}{\\Gamma(2-2\\epsilon)} \\approx (1+2\\epsilon\\gamma_E)(1-2\\epsilon\\gamma_E+2\\epsilon) = 1 - 2\\epsilon\\gamma_E + 2\\epsilon + 2\\epsilon\\gamma_E + \\mathcal{O}(\\epsilon^2) = 1 + 2\\epsilon + \\mathcal{O}(\\epsilon^2)\n$$\n现在，我们将这些展开式相乘：\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} - \\gamma_E + \\mathcal{O}(\\epsilon) \\right] \\left[ 1 + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) + \\mathcal{O}(\\epsilon^2) \\right] \\left[ 1 + 2\\epsilon + \\mathcal{O}(\\epsilon^2) \\right]\n$$\n让我们首先将最后两个括号相乘：\n$$\n\\left[ 1 + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right] [1+2\\epsilon] = 1 + 2\\epsilon + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) + \\mathcal{O}(\\epsilon^2) = 1 + \\epsilon \\left[ 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right] + \\mathcal{O}(\\epsilon^2)\n$$\n最后，我们乘以 $\\Gamma(\\epsilon)$ 的展开式：\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} - \\gamma_E \\right] \\left[ 1 + \\epsilon \\left( 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right) \\right] + \\mathcal{O}(\\epsilon)\n$$\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} \\left( 1 + \\epsilon \\left( 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right) \\right) - \\gamma_E(1) \\right] + \\mathcal{O}(\\epsilon)\n$$\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} + 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) - \\gamma_E \\right] + \\mathcal{O}(\\epsilon)\n$$\n问题指明使用 $\\ln(-p^2-i0)$ 进行解析延拓。对于类空的 $p^2  0$，有 $-p^2>0$，因此 $\\ln(-p^2-i0) = \\ln(|-p^2|)$。我们的结果成立。最终的表达式，包括在 $\\epsilon=0$ 处的极点和所有 $\\mathcal{O}(\\epsilon^0)$ 的项，是：\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left( \\frac{1}{\\epsilon} - \\gamma_E + 2 + \\ln\\left(\\frac{4\\pi\\mu^2}{-p^2-i0}\\right) \\right)\n$$\n这个表达式包含了所需的极点结构和有限项。", "answer": "$$\\boxed{\\frac{i}{16\\pi^{2}} \\left( \\frac{1}{\\epsilon} - \\gamma_{E} + 2 + \\ln\\left(\\frac{4\\pi\\mu^{2}}{-p^{2}-i0}\\right) \\right)}$$", "id": "3515127"}, {"introduction": "实际的粒子物理计算通常涉及带自旋的粒子，这导致费曼积分的分子中出现圈动量，从而形成张量积分。Passarino-Veltman (PV) 方法是一个系统性的算法，它能将任意单圈张量积分表示为一组更简单的标量基底积分的线性组合。这项实践 ([@problem_id:3515188]) 将让你亲手体验自动化单圈计算程序的核心逻辑，通过实现一个简单的例子，你将理解复杂的张量结构是如何被系统地约化为一组可控的标量基础积分的。", "problem": "实现一个完整的、可运行的程序，该程序对特定的单圈张量积分执行基于原理的 Passarino–Veltman 约化，并使用费曼参数表示法，对照标量积分基对该约化进行数值验证。所有计算必须在维度正规化和常规圈积分归一化下进行。仅使用确定性数值积分；不要进行随机抽样。\n\n数学设定如下。考虑在 $d$ 维中的单圈 $N$ 点张量积分，其分母为 $D_i = (\\ell + q_i)^2 - m_i^2 + i0$，\n$$\nI_N^{\\mu_1\\cdots\\mu_r}(d) \\equiv \\mu^{4-d} \\int \\frac{d^d\\ell}{i\\pi^{d/2}} \\frac{\\ell^{\\mu_1}\\cdots \\ell^{\\mu_r}}{D_1 \\cdots D_N}\\,,\n$$\n其中 $\\mu$ 是重整化标度，度规为闵可夫斯基度规。标量积分是阶数 $r=0$ 时的 $I_N(d)$。Passarino–Veltman 约化将任意张量积分表示为由 $g^{\\mu\\nu}$ 和外动量 $q_i$ 构建的张量结构之和，其标量系数是标量积分基 $A_0$、$B_0$、$C_0$ 和 $D_0$ 的线性组合。\n\n使用 $d=4$ 和以下费曼参数表示法，这些表示法源于维度正规化中的基本费曼参数恒等式和动量平移。设 $x_i \\ge 0$ 且 $\\sum_i x_i = 1$，并定义 $Q^\\mu \\equiv \\sum_{i=1}^N x_i q_i^\\mu$ 和\n$$\n\\Delta \\equiv \\sum_{i=1}^N x_i\\,(q_i^2 - m_i^2) - Q^2 \\,.\n$$\n在上述归一化下，有\n$$\nB_0(p^2;m_1^2,m_2^2) = \\Delta_{\\text{div}} + B_0^{\\text{fin}}(p^2;m_1^2,m_2^2)\\,,\n\\quad\nB_0^{\\text{fin}}(p^2;m_1^2,m_2^2) = - \\int_0^1 dx\\, \\ln\\!\\left(\\frac{x\\,m_1^2 + (1-x)\\,m_2^2 - x(1-x)\\,p^2}{\\mu^2}\\right),\n$$\n$$\nC_0(q_1,q_2,q_3;m_1^2,m_2^2,m_3^2) = - \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta}\\,,\n$$\n$$\nD_0(q_1,q_2,q_3,q_4;m_1^2,m_2^2,m_3^2,m_4^2) = \\int_{x_1,x_2,x_3 \\ge 0,\\, x_1+x_2+x_3 \\le 1} \\frac{dx_1\\,dx_2\\,dx_3}{\\Delta^2}\\,,\n$$\n其中 $\\Delta_{\\text{div}}$ 表示维度正规化中的常规发散项，该项在适当的差值中会抵消；在下文的所有验证中，你必须仅在那些可抵消的组合中使用 $B_0^{\\text{fin}}$。对于测试套件中提供的严格离壳运动学，上述表示是良定义且有限的。\n\n实现 $N=3$ 且 $q_3^\\mu \\equiv 0$ 的 1 阶三角圈约化，使得 $q_1^\\mu$ 和 $q_2^\\mu$ 张成外空间。定义格拉姆矩阵 $G_{ij} \\equiv q_i \\cdot q_j$（其中 $i,j \\in \\{1,2\\}$）和标量 $\\Delta_i \\equiv q_i^2 - m_i^2$（其中 $\\Delta_3 \\equiv -m_3^2$）。矢量积分分解为\n$$\nI_3^\\mu = \\sum_{i=1}^2 C_i \\, q_i^\\mu\\,.\n$$\n与 $q_j^\\mu$ 缩并并使用基本恒等式 $2\\,\\ell \\cdot (q_j - q_3) = (D_j - D_3) - (\\Delta_j - \\Delta_3)$，推导并实现以下线性系统\n$$\n\\sum_{i=1}^2 G_{ji}\\, C_i = \\frac{1}{2}\\Big( B_0^{\\text{fin}}(\\text{不含 } j) - B_0^{\\text{fin}}(\\text{不含 } 3) - (\\Delta_j - \\Delta_3)\\, C_0 \\Big)\\,,\n\\quad j=1,2,\n$$\n其中 $B_0^{\\text{fin}}(\\text{不含 } j)$ 表示从 $\\{D_1,D_2,D_3\\}$ 中省略 $D_j$ 后，由剩下的两个分母构成的两点标量。求解此系统以获得 Passarino–Veltman 系数 $C_i$。\n\n通过独立计算缩并项 $q_j \\cdot I_3^\\mu$ 来进行验证，该计算通过从相同基础获得的 $I_3^\\mu$ 的费曼参数表示法进行。在合并分母并平移动量 $\\ell \\to \\ell' = \\ell + Q$ 后，奇数积分消失，得到\n$$\nI_3^\\mu = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, Q^\\mu \\,,\n\\quad Q^\\mu = x_1 q_1^\\mu + x_2 q_2^\\mu,\n$$\n因此\n$$\nq_1 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1^2 + x_2\\, q_1\\cdot q_2),\n\\quad\nq_2 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1\\cdot q_2 + x_2\\, q_2^2).\n$$\n将这些数值积分与 $\\sum_i G_{ji} C_i$（对于 $j=1,2$）进行比较。\n\n在所有测试中均使用严格离壳运动学，以确保在一般情况下积分为有限且格拉姆矩阵可逆。在自然单位制下工作，固定 $\\mu^2 = 1$；将所有输出报告为无单位的无量纲浮点数值。\n\n你必须实现确定性高斯-勒让德积分法在单位区间上的应用，并通过光滑、保体积的变换将其映射到单纯形上。避免任何随机方法。使用足够的积分阶数，以在指定处达到优于 $10^{-6}$ 的绝对精度。\n\n测试套件。你的程序必须运行以下三个测试，并将结果汇总到下面指定的单个输出列表中。\n\n- 测试 1 (一般三角圈，理想情况)：三点矢量积分，其中 $q_3^\\mu = 0$，不变量为 $q_1^2 = -1.1$、$q_2^2 = -0.9$、$q_1\\cdot q_2 = -0.25$，内部质量为 $m_1^2 = 2.0$、$m_2^2 = 2.7$、$m_3^2 = 3.3$。使用上述算法计算 $C_0$ 和两个 Passarino–Veltman 系数 $C_1$ 和 $C_2$。通过费曼参数公式计算 $q_1 \\cdot I_3$ 和 $q_2 \\cdot I_3$ 来进行验证，并检查其与重构的 $\\sum_i G_{ji} C_i$ 在绝对容差 $10^{-6}$ 内是否一致。记录两个布尔值以表示这两项验证。\n\n- 测试 2 (有限标量四角圈)：四点标量积分 $D_0$，其中 $q_4^\\mu = 0$，不变量为 $q_1^2 = -0.4$、$q_2^2 = -0.6$、$q_3^2 = -0.5$，两两点积为 $q_1\\cdot q_2 = -0.1$、$q_1\\cdot q_3 = -0.05$、$q_2\\cdot q_3 = -0.07$，内部质量为 $m_1^2 = 3.0$、$m_2^2 = 3.5$、$m_3^2 = 4.1$、$m_4^2 = 2.7$。使用三参数积分计算并记录 $D_0$ 的数值。\n\n- 测试 3 (近奇异格拉姆矩阵压力测试)：三点矢量积分，其中 $q_3^\\mu = 0$，不变量为 $q_1^2 = -1.0$、$q_2^2 = -1.0$、$q_1\\cdot q_2 = -0.999$，内部质量为 $m_1^2 = 3.0$、$m_2^2 = 3.0$、$m_3^2 = 3.0$。执行与测试 1 相同的验证，但由于病态条件，接受 $5\\times 10^{-4}$ 的绝对容差。记录一个布尔值，指示 $q_1 \\cdot I_3$ 的验证是否通过；对于此压力测试，仅检查 $q_1$ 投影即可。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。该列表必须按顺序包含：\n- 测试 1 的两个布尔值，\n- 测试 1 的 $C_0$ 浮点值，\n- 测试 2 的 $D_0$ 浮点值，\n- 测试 3 的布尔值。\n\n例如：“[true,true,0.12345,0.00678,false]”。所有布尔值必须为小写，浮点数必须为标准十进制表示法。不得打印任何其他文本。", "solution": "### 解题思路与关键公式\n\n此问题要求实现并数值验证 Passarino-Veltman (PV) 约化。该方法将单圈张量积分系统地表示为一组标量基底积分的线性组合。解决此问题的核心是使用费曼参数化和高斯-勒让德数值积分。\n\n**关键公式：**\n\n- **张量积分的通用公式**:\n$$\nI_N^{\\mu_1\\cdots\\mu_r}(d) \\equiv \\mu^{4-d} \\int \\frac{d^d\\ell}{i\\pi^{d/2}} \\frac{\\ell^{\\mu_1}\\cdots \\ell^{\\mu_r}}{D_1 \\cdots D_N}\n$$\n- **传播子分母**: $D_i = (\\ell + q_i)^2 - m_i^2 + i0$。\n- **费曼参数化定义**: 对于 $\\sum_i x_i = 1, x_i \\ge 0$:\n  - $Q^\\mu \\equiv \\sum_{i=1}^N x_i q_i^\\mu$\n  - $\\Delta \\equiv \\sum_{i=1}^N x_i\\,(q_i^2 - m_i^2) - Q^2$\n- **标量积分公式 ($d=4, \\mu^2 = 1$)**:\n  - $B_0(p^2;m_1^2,m_2^2) = \\Delta_{\\text{div}} + B_0^{\\text{fin}}(p^2;m_1^2,m_2^2)$\n  - $B_0^{\\text{fin}}(p^2;m_1^2,m_2^2) = - \\int_0^1 dx\\, \\ln\\!\\left(x\\,m_1^2 + (1-x)\\,m_2^2 - x(1-x)\\,p^2\\right)$\n  - $C_0(q_1,q_2,q_3;m_1^2,m_2^2,m_3^2) = - \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta}$\n  - $D_0(q_1,\\dots,q_4;m_1^2,\\dots,m_4^2) = \\int_{x_1,x_2,x_3 \\ge 0,\\, x_1+x_2+x_3 \\le 1} \\frac{dx_1\\,dx_2\\,dx_3}{\\Delta^2}$\n- **1 阶三角圈约化 ($N=3, q_3^\\mu=0$)**:\n  - 分解: $I_3^\\mu = \\sum_{i=1}^2 C_i \\, q_i^\\mu$\n  - 线性系统: $\\sum_{i=1}^2 G_{ji}\\, C_i = \\frac{1}{2}\\Big( B_0^{\\text{fin}}(\\text{不含 } j) - B_0^{\\text{fin}}(\\text{不含 } 3) - (\\Delta_j - \\Delta_3)\\, C_0 \\Big)$\n- **三角圈积分的验证公式**:\n  - $q_1 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1^2 + x_2\\, q_1\\cdot q_2)$\n  - $q_2 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1\\cdot q_2 + x_2\\, q_2^2)$\n\n### 实现方案\n\n该解法涉及开发一个 Python 程序，用以使用费曼参数化数值计算单圈标量积分，并应用这些结果来执行和验证 Passarino-Veltman 约化。实现的核心是一套用于在单纯形上进行积分的稳健数值积分函数。\n\n#### 单纯形上的数值积分\n\n$B_0$、$C_0$ 和 $D_0$ 的积分分别定义在线段、三角形和四面体上。为此，我们实现确定性高斯-勒让德积分。对于高维单纯形，我们采用 Duffy 变换将 n 维单位超立方体映射到 n 维单位单纯形。这将积分转换为一组在 $[0, 1]$ 上的嵌套一维积分，每个一维积分都可以通过一维积分法则处理。\n\n- **一维积分 ($B_0$)**：使用标准的高斯-勒让德法则计算 $[0, 1]$ 上的积分。\n- **二维积分 ($C_0$)**：积分区域是单位三角形。我们使用变换 $x_1 = u$, $x_2 = (1-u)v$，其中 $(u,v) \\in [0,1]^2$。这个在单位正方形上的积分是使用高斯-勒让德点的二维网格执行的。\n- **三维积分 ($D_0$)**：区域是单位四面体。我们使用变换 $x_1 = u$, $x_2 = (1-u)v$, $x_3 = (1-u)(1-v)w$，其中 $(u,v,w) \\in [0,1]^3$。这是在高斯-勒让德点的三维网格上计算的。\n\n选择一个高的积分阶数（例如，每维 $128$ 个点），以确保数值误差远低于 $10^{-6}$ 的目标精度。\n\n#### 标量积分的实现\n\n基于该积分框架，我们通过提供问题陈述中定义的各自的被积函数，来实现 $B_0^{\\text{fin}}$、$C_0$ 和 $D_0$ 的函数。\n\n#### Passarino-Veltman 约化与验证\n\n对于测试 1 和 3，我们实现 1 阶三角圈约化。\n\n1.  **计算标量基**：所需的标量积分 $C_0$ 和三个 $B_0^{\\text{fin}}$ 函数使用上述方法进行数值计算。\n2.  **求解线性系统**：构建格拉姆矩阵 $G_{ij} = q_i \\cdot q_j$ 和右侧向量。使用 `numpy.linalg.solve` 求解 $2 \\times 2$ 线性系统以获得 Passarino-Veltman 系数 $C_1$ 和 $C_2$。\n3.  **验证**：验证的核心是比较计算物理量 $q_j \\cdot I_3$ 的两种不同方法：一种是利用PV约化后的代数表达式，另一种是通过直接费曼参数积分计算。检查两种方法的结果是否在给定容差内一致。\n\n整个过程被封装在一个 `solve` 函数中，该函数运行三个指定的测试用例，收集结果，并以要求的格式打印它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Global cache for Legendre roots and weights to avoid recomputation\n_legendre_cache = {}\n\ndef get_legendre_params(order):\n    \"\"\"\n    Computes or retrieves from cache the Gauss-Legendre nodes and weights\n    for integration over the interval [0, 1].\n    \"\"\"\n    if order not in _legendre_cache:\n        nodes, weights = roots_legendre(order)\n        # Shift nodes from [-1, 1] to [0, 1]\n        nodes = 0.5 * (nodes + 1)\n        weights = 0.5 * weights\n        _legendre_cache[order] = (nodes, weights)\n    return _legendre_cache[order]\n\ndef quad_1d(func, order):\n    \"\"\"Performs 1D Gauss-Legendre quadrature over [0, 1].\"\"\"\n    nodes, weights = get_legendre_params(order)\n    # The function `func` is expected to be vectorized.\n    integral = np.sum(weights * func(nodes))\n    return integral\n\ndef quad_2d(func, order):\n    \"\"\"Performs 2D Gauss-Legendre quadrature over the unit triangle.\"\"\"\n    u_nodes, u_weights = get_legendre_params(order)\n    v_nodes, v_weights = get_legendre_params(order)\n    \n    # Create a grid of points in the unit square [0,1]x[0,1]\n    U, V = np.meshgrid(u_nodes, v_nodes, indexing='ij')\n    \n    # Apply Duffy transformation to map to the unit triangle\n    X1 = U\n    X2 = (1 - U) * V\n    \n    integrand_values = func(X1, X2)\n    \n    # Jacobian of the transformation\n    jacobian = 1 - U\n    \n    # Weight matrix for the 2D grid\n    W_matrix = np.outer(u_weights, v_weights)\n    \n    integral = np.sum(W_matrix * jacobian * integrand_values)\n    return integral\n\ndef quad_3d(func, order):\n    \"\"\"Performs 3D Gauss-Legendre quadrature over the unit tetrahedron.\"\"\"\n    nodes, weights = get_legendre_params(order)\n    \n    # Create a 3D grid of points in the unit cube [0,1]^3\n    U, V, W_grid = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n\n    # Apply Duffy transformation to map to the unit tetrahedron\n    X1 = U\n    X2 = (1 - U) * V\n    X3 = (1 - U) * (1 - V) * W_grid\n    \n    integrand_values = func(X1, X2, X3)\n    \n    # Jacobian of the transformation\n    jacobian = (1 - U)**2 * (1 - V)\n    \n    # Weight tensor for the 3D grid\n    W_tensor = np.einsum('i,j,k->ijk', weights, weights, weights)\n    \n    integral = np.sum(W_tensor * jacobian * integrand_values)\n    return integral\n\ndef B0_fin(p2, m1_2, m2_2, mu_2, order):\n    \"\"\"Computes the finite part of the scalar 2-point function B0.\"\"\"\n    def integrand(x):\n        # Argument of the logarithm in the B0 formula\n        arg = x * m1_2 + (1 - x) * m2_2 - x * (1 - x) * p2\n        # The kinematic space is chosen such that arg > 0\n        return -np.log(arg / mu_2)\n    return quad_1d(integrand, order)\n\ndef C0(q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, mu_2, order):\n    \"\"\"Computes the scalar 3-point function C0.\"\"\"\n    def integrand(x1, x2):\n        x3 = 1 - x1 - x2\n        Q_2 = x1**2 * q1_2 + x2**2 * q2_2 + 2 * x1 * x2 * q1q2\n        delta = (x1 * (q1_2 - m1_2) + \n                 x2 * (q2_2 - m2_2) + \n                 x3 * (-m3_2) - Q_2)\n        return -1.0 / delta\n    return quad_2d(integrand, order)\n\ndef D0(q1_2, q2_2, q3_2, q1q2, q1q3, q2q3, m1_2, m2_2, m3_2, m4_2, mu_2, order):\n    \"\"\"Computes the scalar 4-point function D0.\"\"\"\n    def integrand(x1, x2, x3):\n        x4 = 1 - x1 - x2 - x3\n        Q_2 = (x1**2 * q1_2 + x2**2 * q2_2 + x3**2 * q3_2 +\n               2 * x1 * x2 * q1q2 + 2 * x1 * x3 * q1q3 + 2 * x2 * x3 * q2q3)\n        delta = (x1 * (q1_2 - m1_2) + x2 * (q2_2 - m2_2) + \n                 x3 * (q3_2 - m3_2) + x4 * (-m4_2) - Q_2)\n        return 1.0 / delta**2\n    return quad_3d(integrand, order)\n\ndef validate_I3_projection(proj_idx, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, order):\n    \"\"\"Computes q_j . I3 directly from its Feynman parameter representation.\"\"\"\n    def integrand(x1, x2):\n        x3 = 1 - x1 - x2\n        Q_2 = x1**2 * q1_2 + x2**2 * q2_2 + 2 * x1 * x2 * q1q2\n        delta = (x1 * (q1_2 - m1_2) + \n                 x2 * (q2_2 - m2_2) + \n                 x3 * (-m3_2) - Q_2)\n        \n        if proj_idx == 1:\n            # Numerator for q1 . I3 is q1 . (x1*q1 + x2*q2)\n            num = x1 * q1_2 + x2 * q1q2\n        else: # proj_idx == 2\n            # Numerator for q2 . I3 is q2 . (x1*q1 + x2*q2)\n            num = x1 * q1q2 + x2 * q2_2\n        return num / delta\n    return quad_2d(integrand, order)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    QUAD_ORDER = 128\n    MU_2 = 1.0\n    results = []\n\n    # --- Test 1: Generic triangle ---\n    q1_2, q2_2, q1q2 = -1.1, -0.9, -0.25\n    m1_2, m2_2, m3_2 = 2.0, 2.7, 3.3\n    \n    # Calculate scalar C0 integral\n    c0_val = C0(q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    \n    # Calculate scalar B0 integrals needed for the PV reduction\n    p_12_2 = q1_2 + q2_2 - 2 * q1q2 # (q1-q2)^2\n    b0_excl1 = B0_fin(q2_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    b0_excl2 = B0_fin(q1_2, m1_2, m3_2, MU_2, QUAD_ORDER)\n    b0_excl3 = B0_fin(p_12_2, m1_2, m2_2, MU_2, QUAD_ORDER)\n    \n    # Construct the RHS of the linear system\n    delta1 = q1_2 - m1_2\n    delta2 = q2_2 - m2_2\n    delta3 = -m3_2\n    R1 = 0.5 * (b0_excl1 - b0_excl3 - (delta1 - delta3) * c0_val)\n    R2 = 0.5 * (b0_excl2 - b0_excl3 - (delta2 - delta3) * c0_val)\n    \n    # Perform validation by direct integration\n    val_I3_proj1 = validate_I3_projection(1, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, QUAD_ORDER)\n    val_I3_proj2 = validate_I3_projection(2, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, QUAD_ORDER)\n    \n    # Check agreement\n    valid1 = np.isclose(val_I3_proj1, R1, atol=1e-6, rtol=0)\n    valid2 = np.isclose(val_I3_proj2, R2, atol=1e-6, rtol=0)\n    \n    # Truncate floats for cleaner output\n    c0_str = f\"{c0_val:.5f}\"\n    \n    results.append(str(valid1).lower())\n    results.append(str(valid2).lower())\n    results.append(c0_str)\n\n    # --- Test 2: Scalar box integral D0 ---\n    q1_2, q2_2, q3_2 = -0.4, -0.6, -0.5\n    q1q2, q1q3, q2q3 = -0.1, -0.05, -0.07\n    m1_2, m2_2, m3_2, m4_2 = 3.0, 3.5, 4.1, 2.7\n    \n    d0_val = D0(q1_2, q2_2, q3_2, q1q2, q1q3, q2q3, m1_2, m2_2, m3_2, m4_2, MU_2, QUAD_ORDER)\n    d0_str = f\"{d0_val:.5f}\"\n    results.append(d0_str)\n\n    # --- Test 3: Near-singular Gram matrix ---\n    q1_2, q2_2, q1q2 = -1.0, -1.0, -0.999\n    m1_2, m2_2, m3_2 = 3.0, 3.0, 3.0\n    \n    c0_val_t3 = C0(q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    \n    p_12_2_t3 = q1_2 + q2_2 - 2 * q1q2\n    b0_excl1_t3 = B0_fin(q2_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    b0_excl3_t3 = B0_fin(p_12_2_t3, m1_2, m2_2, MU_2, QUAD_ORDER)\n    \n    delta1_t3 = q1_2 - m1_2\n    delta3_t3 = -m3_2\n    R1_t3 = 0.5 * (b0_excl1_t3 - b0_excl3_t3 - (delta1_t3 - delta3_t3) * c0_val_t3)\n    \n    val_I3_proj1_t3 = validate_I3_projection(1, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, QUAD_ORDER)\n    \n    valid3 = np.isclose(val_I3_proj1_t3, R1_t3, atol=5e-4, rtol=0)\n    results.append(str(valid3).lower())\n    \n    # Final print statement in the exact required format.\n    # The problem asks for standard decimal notation, not scientific.\n    # The example [true,true,0.12345,0.00678,false] confirms this.\n    # My string formatting above achieves this.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3515188"}, {"introduction": "在计算散射振幅之外，我们常常还需要计算它对物理参数的导数，以用于优化、误差估计等任务。自动微分 (Automatic Differentiation, AD) 是一种现代计算技术，它通过系统地应用链式法则，可以精确计算由计算机程序定义的函数的导数。本练习 ([@problem_id:3515172]) 将演示如何将AD应用于量子场论的振幅计算，从而实现高效、精确的梯度计算，避免手动推导或有限差分法的数值不稳定性。你还将研究像粒子产生阈值这样的物理奇点如何影响导数计算的数值稳定性，这是在实际应用中一个至关重要的考量。", "problem": "您需要使用自动微分来实现量子场论（QFT）中单圈标量气泡振幅的数值计算和微分，并评估在存在支割线和非解析性的情况下计算出的梯度的稳定性。您将使用费曼参数来表示该振幅，对粒子质量和曼德尔施塔姆不变量进行微分，并在阈值奇点附近将自动微分与有限差分进行比较。\n\n起点和物理背景：在一个标量理论中，等质量单圈二点函数（气泡图）源于两个标量传播子的乘积。使用费曼参数化，并舍去依赖于方案的加性常数，一个代表性的振幅可以写成费曼参数积分的形式\n$$\n\\mathcal{M}(s,m;\\mu,\\varepsilon) \\equiv \\int_{0}^{1} \\mathrm{d}x \\,\\ln\\!\\left(\\frac{m^{2} - s\\,x(1-x) - i\\,\\varepsilon}{\\mu^{2}}\\right),\n$$\n其中 $m$ 是标量质量，$s$ 是曼德尔施塔姆不变量，$\\mu$ 是一个参考重整化标度，$\\varepsilon$ 是一个实现因果性规定的正无穷小量。复数对数取其主支，支割线沿负实轴。该积分在 $s=4m^{2}$ 处有一个支点，这意味着在 $s$ 上存在一个非解析性阈值；当 $s\\to 4m^{2}$ 时，对于 $x=1/2$，被积函数的参数可以趋近于零，使得导数变得敏感且可能不稳定。\n\n您的任务：\n\n1. 使用对偶数实现前向模式自动微分，以便通过在基本运算层面应用链式法则，在数值被积函数内部执行微分。您必须同时获得梯度 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$。\n\n2. 在区间 $[0,1]$ 上使用具有固定节点数 $N$ 的高斯-勒让德求积法对积分进行数值计算。将节点从 $[-1,1]$ 映射到 $[0,1]$ 并使用相应的权重。您必须使用复数对数 $\\ln$ 的主支，并包含 $-i\\,\\varepsilon$ 规定。\n\n3. 使用带有小扰动 $\\delta m$ 和 $\\delta s$ 的对称差分来计算梯度 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$ 的有限差分近似值。通过计算相对误差，将自动微分结果与有限差分结果进行比较\n$$\nE_m \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|\\right)},\n\\quad\nE_s \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|\\right)}.\n$$\n定义一个稳定性阈值 $\\tau$，如果 $\\max(E_m,E_s) \\le \\tau$，则将该情况分类为数值稳定。\n\n4. 单位和数值参数：$m$ 的单位为 $\\mathrm{GeV}$，$s$ 的单位为 $\\mathrm{GeV}^{2}$，并使用 $\\mu=1\\,\\mathrm{GeV}$，以使对数的参数无量纲。在所有测试用例中，使用 $\\varepsilon=10^{-12}\\,\\mathrm{GeV}^{2}$。使用 $N=200$ 个求积节点。使用对称差分步长 $\\delta m=\\max(10^{-6},\\,10^{-6}\\,m)\\,\\mathrm{GeV}$ 和 $\\delta s=\\max(10^{-6},\\,10^{-6}\\,s)\\,\\mathrm{GeV}^{2}$。使用 $\\tau=10^{-3}$。\n\n5. 测试套件：对于以下参数集 $(m,s)$，在保持 $\\mu=1$ 和 $\\varepsilon=10^{-12}$ 固定的情况下，评估稳定性分类：\n   - 用例 1（低于阈值，理想情况）：$(m=0.5,\\,s=0.2)$。\n   - 用例 2（从下方接近阈值）：$(m=0.5,\\,s=0.999)$。\n   - 用例 3（在阈值处）：$(m=0.5,\\,s=1.0)$。\n   - 用例 4（略高于阈值）：$(m=0.5,\\,s=1.001)$。\n   - 用例 5（远高于阈值）：$(m=0.5,\\,s=10.0)$。\n   - 用例 6（小质量在阈值处）：$(m=0.1,\\,s=0.04)$。\n   - 用例 7（小质量略高于阈值）：$(m=0.1,\\,s=0.041)$。\n\n6. 最终输出格式：您的程序应生成一行输出，其中包含所有七个测试用例的稳定性结果，形式为一个用方括号括起来的逗号分隔列表，每个条目是一个布尔值，表示该用例是否稳定，顺序如上所列（例如，$\\texttt{[True,False,True, ...]}$）。不应打印任何其他文本。\n\n本问题陈述中所有数学实体必须用 LaTeX 表示。答案布尔值没有单位；所有内部计算必须一致使用指定的单位和复数对数的主支。解决方案必须从第一性原理构建：由费曼规则导出传播子，参数化为积分，以及通过对偶数方法以算法方式实现的在积分号下微分，而非通过封闭形式公式。", "solution": "### 问题分析与关键公式\n\n此问题要求使用自动微分（AD）来计算单圈标量气泡振幅对质量 $m$ 和曼德尔施塔姆不变量 $s$ 的导数，并评估其在粒子产生阈值 $s=4m^2$ 附近的数值稳定性。\n\n**振幅积分**：\n核心计算对象是费曼参数积分：\n$$\n\\mathcal{M}(s,m;\\mu,\\varepsilon) \\equiv \\int_{0}^{1} \\mathrm{d}x \\,\\ln\\!\\left(\\frac{m^{2} - s\\,x(1-x) - i\\,\\varepsilon}{\\mu^{2}}\\right)\n$$\n其中，所有参数和数学约定（如复对数的主支）均已明确定义。\n\n**稳定性比较**：\n稳定性是通过比较自动微分（AD）和有限差分（FD）两种方法计算出的梯度来衡量的。相对误差 $E_m$ 和 $E_s$ 定义为：\n$$\nE_m \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|\\right)},\n\\quad\nE_s \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|\\right)}.\n$$\n如果 $\\max(E_m, E_s) \\le \\tau=10^{-3}$，则认为计算是稳定的。\n\n### 实现方案：基于原理的设计\n\n解决方案将基于以下原理构建：\n\n1.  **自动微分（AD）**：我们将为多变量复函数实现前向模式 AD。这通过定义一个 `DualComplex` 数类型来实现，该类型扩展了复数以携带导数信息。对于函数 $f(m, s)$，此类型的对象将存储一个复数三元组：$(f, \\partial f/\\partial m, \\partial f/\\partial s)$。我们将为该对偶数类型重载所有标准算术运算（$+、-、\\times、\\div$）和基本函数（$\\ln$），在每一步实现链式法则。\n\n2.  **数值求积**：积分将使用高斯-勒让德求积法近似为加权和。定义在区间 $[-1, 1]$ 上的标准节点和权重将通过线性变换 $x = (t+1)/2$ 映射到积分域 $[0, 1]$。积分则为 $\\int_0^1 f(x) dx \\approx \\sum_i (w_i/2) f((t_i+1)/2)$。\n\n3.  **振幅及其梯度的评估**：\n    - **AD 方法**：为了通过 AD 计算梯度，输入参数 $m$ 和 $s$ 被初始化为种子 `DualComplex` 数：$m_{\\text{dual}} = (m, 1, 0)$ 和 $s_{\\text{dual}} = (s, 0, 1)$。然后，在每个求积节点 $x_i$ 上使用对偶数算术评估被积函数。得到的被积函数的 `DualComplex` 值乘以相应的求积权重并求和。最终的 `DualComplex` 和将在其值部分包含积分值 $\\mathcal{M}$，在其导数部分包含梯度 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$。这有效地执行了积分号下的微分。\n    - **FD 方法**：为进行比较，梯度也使用对称有限差分公式计算：$\\partial f/\\partial p \\approx (f(p+\\delta p) - f(p-\\delta p))/(2\\delta p)$。这需要使用标准复数算术在 $m$ 和 $s$ 的扰动值上多次评估原始积分。\n\n4.  **稳定性分析**：在阈值 $s=4m^2$ 附近，被积函数的行为变化迅速。在阈值以上，对数的参数穿过负实轴上的支割线，为积分引入了非解析性贡献。这可能导致 AD 和 FD 之间的差异，因为 FD 对函数值在有限步长 $\\delta$ 上的变化很敏感，而这个步长可能会跨越这个非解析区域，而 AD 则精确计算在单一点的导数。相对误差度量 $E_m$ 和 $E_s$ 量化了这种差异，并用于评估稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\nclass DualComplex:\n    \"\"\"\n    A class for forward-mode automatic differentiation of complex functions\n    with respect to two real variables 'm' and 's'.\n    \"\"\"\n    def __init__(self, val, d_m=0.0, d_s=0.0):\n        self.val = complex(val)\n        self.d_m = complex(d_m)\n        self.d_s = complex(d_s)\n\n    def __add__(self, other):\n        if isinstance(other, DualComplex):\n            return DualComplex(self.val + other.val, self.d_m + other.d_m, self.d_s + other.d_s)\n        # Addition with a scalar (real or complex)\n        return DualComplex(self.val + other, self.d_m, self.d_s)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, DualComplex):\n            return DualComplex(self.val - other.val, self.d_m - other.d_m, self.d_s - other.d_s)\n        # Subtraction with a scalar\n        return DualComplex(self.val - other, self.d_m, self.d_s)\n\n    def __rsub__(self, other):\n        return DualComplex(other - self.val, -self.d_m, -self.d_s)\n\n    def __mul__(self, other):\n        if isinstance(other, DualComplex):\n            # Product rule for two dual numbers\n            return DualComplex(self.val * other.val,\n                               self.val * other.d_m + other.val * self.d_m,\n                               self.val * other.d_s + other.val * self.d_s)\n        # Multiplication by a scalar\n        return DualComplex(self.val * other, self.d_m * other, self.d_s * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, DualComplex):\n            # Quotient rule for two dual numbers\n            val_inv = 1.0 / other.val\n            val_inv_sq = val_inv**2\n            return DualComplex(self.val * val_inv,\n                               (self.d_m * other.val - self.val * other.d_m) * val_inv_sq,\n                               (self.d_s * other.val - self.val * other.d_s) * val_inv_sq)\n        # Division by a scalar\n        other_inv = 1.0 / other\n        return DualComplex(self.val * other_inv, self.d_m * other_inv, self.d_s * other_inv)\n    \n    def __rtruediv__(self, other):\n        val_inv = 1.0 / self.val\n        val_inv_sq = val_inv**2\n        return DualComplex(other * val_inv,\n                           (-other * self.d_m) * val_inv_sq,\n                           (-other * self.d_s) * val_inv_sq)\n\n\ndef log_dual(z):\n    \"\"\"Computes the natural logarithm for a DualComplex number.\"\"\"\n    if not isinstance(z, DualComplex):\n        return np.log(complex(z))\n    \n    val_inv = 1.0 / z.val\n    # Chain rule: d(log(u))/dp = (1/u) * (du/dp)\n    return DualComplex(np.log(z.val), z.d_m * val_inv, z.d_s * val_inv)\n\n\ndef solve():\n    # Define the parameters from the problem statement.\n    MU = 1.0\n    EPSILON = 1e-12\n    N_NODES = 200\n    TAU = 1e-3\n    \n    test_cases = [\n        (0.5, 0.2),    # Case 1: below threshold\n        (0.5, 0.999),  # Case 2: near threshold from below\n        (0.5, 1.0),    # Case 3: at threshold\n        (0.5, 1.001),  # Case 4: just above threshold\n        (0.5, 10.0),   # Case 5: far above threshold\n        (0.1, 0.04),   # Case 6: small mass at threshold\n        (0.1, 0.041),  # Case 7: small mass just above threshold\n    ]\n\n    # Pre-compute Gauss-Legendre nodes and weights for [-1, 1]\n    t_nodes, std_weights = roots_legendre(N_NODES)\n    # Map nodes to [0, 1] and adjust weights\n    x_nodes = (t_nodes + 1.0) / 2.0\n    weights = std_weights / 2.0\n    \n    # --- Integrand function using standard complex numbers ---\n    def integrand(x, m, s):\n        arg = (m**2 - s * x * (1 - x) - 1j * EPSILON) / MU**2\n        return np.log(arg)\n\n    # --- Numerical integration function for FD ---\n    def calculate_amplitude_base(m, s):\n        integral_val = 0.0j\n        # Vectorized calculation\n        integral_val = np.sum(weights * integrand(x_nodes, m, s))\n        return integral_val\n\n    results = []\n    for m, s in test_cases:\n        # --- Automatic Differentiation Calculation ---\n        m_dual = DualComplex(m, 1.0, 0.0)\n        s_dual = DualComplex(s, 0.0, 1.0)\n        \n        total_dual = DualComplex(0.0)\n        # Vectorized calculation for AD\n        x = x_nodes\n        integrand_arg_dual = (m_dual*m_dual - s_dual * x * (1 - x) - 1j * EPSILON) / MU**2\n        # `log_dual` is not vectorized, so we still loop. A fully vectorized Dual number class\n        # would be more efficient, but this is sufficient and correct.\n        for i in range(N_NODES):\n            integrand_arg_i = (m_dual*m_dual - s_dual * x[i] * (1 - x[i]) - 1j * EPSILON) / MU**2\n            integrand_val_dual_i = log_dual(integrand_arg_i)\n            total_dual += integrand_val_dual_i * weights[i]\n\n        grad_m_ad = total_dual.d_m\n        grad_s_ad = total_dual.d_s\n\n        # --- Finite Difference Calculation ---\n        delta_m = max(1e-6, 1e-6 * m)\n        delta_s = max(1e-6, 1e-6 * s)\n\n        m_plus = calculate_amplitude_base(m + delta_m, s)\n        m_minus = calculate_amplitude_base(m - delta_m, s)\n        grad_m_fd = (m_plus - m_minus) / (2 * delta_m)\n\n        s_plus = calculate_amplitude_base(m, s + delta_s)\n        s_minus = calculate_amplitude_base(m, s - delta_s)\n        grad_s_fd = (s_plus - s_minus) / (2 * delta_s)\n        \n        # --- Comparison and Stability Check ---\n        # Note: |...| on complex numbers is their magnitude (np.abs)\n        err_m_denom = max(1e-12, np.abs(grad_m_fd))\n        e_m = np.abs(grad_m_ad - grad_m_fd) / err_m_denom\n\n        err_s_denom = max(1e-12, np.abs(grad_s_fd))\n        e_s = np.abs(grad_s_ad - grad_s_fd) / err_s_denom\n        \n        is_stable = max(e_m, e_s) = TAU\n        results.append(str(is_stable).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3515172"}]}