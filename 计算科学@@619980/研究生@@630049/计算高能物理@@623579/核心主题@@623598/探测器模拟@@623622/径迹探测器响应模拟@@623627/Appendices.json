{"hands_on_practices": [{"introduction": "模拟带电粒子在磁场中的螺旋路径是径迹重建的核心。在实践中，这个连续的路径被分解为离散的步长。本练习 ([@problem_id:3536223]) 将挑战你确定一个数值步进算法所允许的最大步长，旨在计算效率与维持径迹曲率（一个与粒子动量密切相关的关键参数）的指定精度之间取得平衡。", "problem": "在通过螺线管桶型探测器对带电粒子径迹进行计算传播时，一种常用的一阶步进器将磁场在路径长度为 $\\Delta s$ 的有限步长内近似为常数，其值等于该步长起点的磁场值。在一个桶型区域中，测得磁场大小的空间梯度为 $0.05\\ \\mathrm{T/m}$。假设在任何单一步长内，磁场大小都沿着步进方向线性变化。考虑一个横向动量为 $p_{T}=5\\ \\mathrm{GeV}/c$ 的单电荷粒子在横向平面内运动。径迹追踪代码将每一步的曲率大小的绝对误差限制在 $\\delta\\kappa_{\\max}=10^{-4}\\ \\mathrm{m^{-1}}$ 以下，该误差定义为真实的步长平均曲率与步进器的恒定磁场曲率之差。您可以假设最坏情况下的方向，即步进方向与磁场最陡峭增加的方向对齐。\n\n仅从洛伦兹力定律和带电粒子在磁场中曲率的定义出发，并将沿步长的磁场变化视为线性，推导出 $\\Delta s$ 的一个上界，以满足曲率误差的界限。然后，计算最大允许步长的数值。\n\n根据需要使用以下基本常数：光速 $c=2.99792458\\times 10^{8}\\ \\mathrm{m/s}$，基本电荷大小 $|e|=1.602176634\\times 10^{-19}\\ \\mathrm{C}$，以及 $1\\ \\mathrm{eV}=1.602176634\\times 10^{-19}\\ \\mathrm{J}$。请以厘米为单位表示 $\\Delta s$ 的最终答案，并四舍五入到三位有效数字。您的最终答案必须是一个实数。", "solution": "该问题要求基于曲率误差的约束，为粒子径迹追踪模拟推导步长 $\\Delta s$ 的一个上界。此问题是自洽的，其科学基础是经典电磁学和力学，并且是良定的。因此，该问题被认为是有效的，可以构建一个完整的解。\n\n这个问题的基础是洛伦兹力定律，它描述了电荷为 $q$、速度为 $\\vec{v}$ 的粒子在磁场 $\\vec{B}$ 中运动时所受的力 $\\vec{F}$：\n$$ \\vec{F} = q(\\vec{v} \\times \\vec{B}) $$\n对于在横向平面内垂直于磁场 $\\vec{B}$ 运动的粒子，力的大小为 $F = |q| v_T B$，其中 $v_T$ 是横向速率，B 是磁场大小。这个力充当向心力 $F_c = \\frac{mv_T^2}{R}$，使粒子做圆周运动。这个圆的半径是 $R$，$m$ 是相对论质量。用横向动量 $p_T = m v_T$ 表示，向心力为 $F_c = \\frac{p_T v_T}{R}$。\n\n令洛伦兹力与向心力相等，得到：\n$$ |q| v_T B = \\frac{p_T v_T}{R} $$\n曲率 $\\kappa$ 定义为曲率半径的倒数，即 $\\kappa = \\frac{1}{R}$。解出 $\\kappa$ 即可得到曲率、磁场和横向动量之间的基本关系：\n$$ \\kappa = \\frac{|q| B}{p_T} $$\n在高能物理学中，通常方便地以能量除以光速的单位（如 $\\mathrm{GeV}/c$）来表示动量。令 $E_T = p_T c$ 为横向能量。给定的横向动量为 $p_T = 5\\ \\mathrm{GeV}/c$，这意味着 $E_T = 5\\ \\mathrm{GeV}$。我们可以将曲率方程重写为：\n$$ \\kappa = \\frac{|q| c B}{p_T c} = \\frac{|q| c B}{E_T} $$\n此处，所有量都必须采用一致的单位制，例如国际单位制 (SI)。\n\n问题陈述磁场大小 $B$ 沿步进方向线性变化。步进方向与磁场最陡峭增加的方向对齐，因此梯度为 $G = 0.05\\ \\mathrm{T/m}$。设 $s$ 是沿步长的路径长度，从 $s=0$ 到 $s=\\Delta s$。沿步长任意点 $s$ 处的磁场为：\n$$ B(s) = B_0 + G s $$\n其中 $B_0$ 是步长起点 ($s=0$) 处的磁场。因此，真实曲率也沿步长线性变化：\n$$ \\kappa(s) = \\frac{|q| c (B_0 + G s)}{E_T} $$\n\n数值步进算法在该步长内将曲率近似为常数，使用步长开始时的磁场值 $B_0$。因此，步进器的曲率 $\\kappa_{step}$ 为：\n$$ \\kappa_{step} = \\kappa(0) = \\frac{|q| c B_0}{E_T} $$\n\n“真实的步长平均曲率” $\\bar{\\kappa}_{true}$ 是真实曲率函数 $\\kappa(s)$ 在区间 $[0, \\Delta s]$ 上的平均值：\n$$ \\bar{\\kappa}_{true} = \\frac{1}{\\Delta s} \\int_{0}^{\\Delta s} \\kappa(s) \\,ds = \\frac{1}{\\Delta s} \\int_{0}^{\\Delta s} \\frac{|q| c (B_0 + G s)}{E_T} \\,ds $$\n进行积分：\n$$ \\bar{\\kappa}_{true} = \\frac{|q| c}{E_T \\Delta s} \\left[ B_0 s + \\frac{1}{2} G s^2 \\right]_0^{\\Delta s} = \\frac{|q| c}{E_T \\Delta s} \\left( B_0 \\Delta s + \\frac{1}{2} G (\\Delta s)^2 \\right) $$\n$$ \\bar{\\kappa}_{true} = \\frac{|q| c}{E_T} \\left( B_0 + \\frac{1}{2} G \\Delta s \\right) $$\n这个结果等价于在步长中点 $s = \\frac{\\Delta s}{2}$ 处计算的真实曲率，这对于线性函数是符合预期的。\n\n每一步的曲率大小的绝对误差 $\\delta\\kappa$ 是真实平均曲率与步进器近似值之差：\n$$ \\delta\\kappa = |\\bar{\\kappa}_{true} - \\kappa_{step}| = \\left| \\frac{|q| c}{E_T} \\left( B_0 + \\frac{1}{2} G \\Delta s \\right) - \\frac{|q| c B_0}{E_T} \\right| $$\n$$ \\delta\\kappa = \\left| \\frac{|q| c B_0}{E_T} + \\frac{|q| c G \\Delta s}{2 E_T} - \\frac{|q| c B_0}{E_T} \\right| = \\frac{|q| c G \\Delta s}{2 E_T} $$\n问题对这个误差施加了一个上界，$\\delta\\kappa \\le \\delta\\kappa_{\\max}$，其中 $\\delta\\kappa_{\\max} = 10^{-4}\\ \\mathrm{m^{-1}}$。我们可以用它来找到最大允许步长 $\\Delta s_{\\max}$：\n$$ \\frac{|q| c G \\Delta s}{2 E_T} \\le \\delta\\kappa_{\\max} \\implies \\Delta s \\le \\frac{2 E_T \\delta\\kappa_{\\max}}{|q| c G} $$\n因此，步长的上界是：\n$$ \\Delta s_{\\max} = \\frac{2 E_T \\delta\\kappa_{\\max}}{|q| c G} $$\n为了对该表达式进行数值计算，我们必须使用 SI 单位。已知条件如下：\n-   单电荷粒子，因此 $|q|$ 是基本电荷， $|e| = 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$。\n-   横向能量 $E_T = 5\\ \\mathrm{GeV} = 5 \\times 10^9\\ \\mathrm{eV}$。为了转换为焦耳，我们使用 $1\\ \\mathrm{eV} = 1.602176634 \\times 10^{-19}\\ \\mathrm{J}$。所以，$E_T = 5 \\times 10^9 \\times (1.602176634 \\times 10^{-19})\\ \\mathrm{J}$。\n-   最大曲率误差 $\\delta\\kappa_{\\max} = 10^{-4}\\ \\mathrm{m^{-1}}$。\n-   磁场梯度 $G = 0.05\\ \\mathrm{T/m}$。\n-   光速 $c = 2.99792458 \\times 10^8\\ \\mathrm{m/s}$。\n\n将这些值代入 $\\Delta s_{\\max}$ 的表达式中：\n$$ \\Delta s_{\\max} = \\frac{2 \\times (5 \\times 10^9 \\times 1.602176634 \\times 10^{-19}\\ \\mathrm{J}) \\times (10^{-4}\\ \\mathrm{m^{-1}})}{(1.602176634 \\times 10^{-19}\\ \\mathrm{C}) \\times (2.99792458 \\times 10^8\\ \\mathrm{m/s}) \\times (0.05\\ \\mathrm{T/m})} $$\n基本电荷的数值 $1.602176634 \\times 10^{-19}$ 同时出现在分子（来自 eV 到 J 的转换）和分母（作为以库仑为单位的电荷）中。这些项可以消去，从而显著简化了计算：\n$$ \\Delta s_{\\max} = \\frac{2 \\times (5 \\times 10^9) \\times (10^{-4}\\ \\mathrm{m^{-1}})}{(2.99792458 \\times 10^8\\ \\mathrm{m/s}) \\times (0.05\\ \\mathrm{T/m})} $$\n$$ \\Delta s_{\\max} = \\frac{10 \\times 10^5}{(2.99792458 \\times 10^8) \\times 0.05} \\cdot \\frac{\\mathrm{J} \\cdot \\mathrm{m}^{-1}}{\\mathrm{C} \\cdot (\\mathrm{m/s}) \\cdot (\\mathrm{T/m})} $$\n让我们检查一下单位：$\\frac{[\\mathrm{J}][\\mathrm{m}^{-1}]}{[\\mathrm{C}][\\mathrm{m/s}][\\mathrm{T/m}]} = \\frac{[\\mathrm{N} \\cdot \\mathrm{m}][\\mathrm{m}^{-1}]}{[\\mathrm{C}][\\mathrm{m/s}][\\mathrm{N \\cdot s / (C \\cdot m)}][\\mathrm{m}^{-1}]} = \\frac{[\\mathrm{N}]}{[\\mathrm{N}][\\mathrm{m}^{-1}]} = [\\mathrm{m}]$。该表达式是有效的。\n\n继续进行数值计算：\n$$ \\Delta s_{\\max} = \\frac{10^6}{2.99792458 \\times 10^8 \\times 0.05}\\ \\mathrm{m} $$\n$$ \\Delta s_{\\max} = \\frac{10^6}{0.149896229 \\times 10^8}\\ \\mathrm{m} = \\frac{10^6}{1.49896229 \\times 10^7}\\ \\mathrm{m} $$\n$$ \\Delta s_{\\max} = \\frac{1}{14.9896229}\\ \\mathrm{m} \\approx 0.0667128\\ \\mathrm{m} $$\n问题要求结果以厘米为单位，所以我们乘以 $100$：\n$$ \\Delta s_{\\max} \\approx 6.67128\\ \\mathrm{cm} $$\n四舍五入到三位有效数字，我们得到：\n$$ \\Delta s_{\\max} \\approx 6.67\\ \\mathrm{cm} $$", "answer": "$$\\boxed{6.67}$$", "id": "3536223"}, {"introduction": "粒子穿过探测器并不保证能记录一个“击中”。探测器模块的效率取决于沉积电荷、电子学噪声和读出阈值之间的相互作用。本练习 ([@problem_id:3536201]) 将指导你推导并实现经典的“S形曲线”模型，该模型描述了击中概率作为电荷量的函数，是表征探测器性能的基本工具。", "problem": "考虑一个二元阈值径迹探测器模块，其中每个读出通道在沉积电荷与电子学噪声之和超过该通道的阈值时会产生一个击中。设沉积电荷用 $q$ 表示，单位为千电子电荷 $(\\mathrm{ke})$，其中 $1\\,\\mathrm{ke} = 10^{3}$ 个电子。每个通道的电子学噪声被建模为一个高斯随机变量 $n \\sim \\mathcal{N}(0,\\sigma_{n}^{2})$，其中 $\\sigma_{n}$ 的单位为 $\\mathrm{ke}$。模块中各个通道的阈值并不相同；相反，它们根据高斯分布 $T \\sim \\mathcal{N}(T_{0},\\sigma_{T}^{2})$ 弥散，其中 $T_{0}$ 和 $\\sigma_{T}$ 的单位均为 $\\mathrm{ke}$。假设 $n$ 和 $T$ 是统计独立的。\n\n对于一个固定阈值为 $T$ 的单通道，如果 $q + n > T$，则记录一次击中。因此，单通道响应，即在给定 $q$ 和 $T$ 的情况下的击中概率，被定义为含噪声信号超过阈值的事件。平均模块效率开启曲线，记为 $\\bar{\\epsilon}(q)$，是在阈值弥散上取平均的期望单通道响应，可以写成单通道响应与阈值分布的卷积：\n$$\n\\bar{\\epsilon}(q) = \\int_{-\\infty}^{+\\infty} \\epsilon(q \\mid T)\\, p_{T}(T)\\, dT,\n$$\n其中 $\\epsilon(q \\mid T)$ 是阈值为 $T$ 时的单通道响应，而 $p_{T}(T)$ 是 $T$ 的概率密度函数。累积分布函数 (CDF) 指的是概率密度函数从 $-\\infty$ 到一个给定值的积分。\n\n你的任务是，从高斯随机变量和独立性的基本定义出发，通过将卷积解释为独立高斯随机变量之和超过零的概率，来推导出 $\\bar{\\epsilon}(q)$ 的闭式表达式。然后实现一个程序，用于计算指定参数集和电荷样本下的 $\\bar{\\epsilon}(q)$。\n\n单位和数值规范：\n- 输入参数 $q$、$T_{0}$、$\\sigma_{n}$ 和 $\\sigma_{T}$ 的单位为 $\\mathrm{ke}$。\n- 输出 $\\bar{\\epsilon}(q)$ 是无单位的，并且必须以 $0$ 和 $1$ 之间的实数形式报告。\n- 所有报告的数值结果必须四舍五入到 $6$ 位小数。\n\n测试套件：\n为以下三个参数集和 $q$ 值列表计算 $\\bar{\\epsilon}(q)$。按给定顺序将所有 $q$ 的结果追加起来，并按所列顺序遍历所有测试用例。\n\n1. 一般情况（理想路径）：$T_{0} = 20$，$\\sigma_{n} = 0.8$，$\\sigma_{T} = 2$，其中 $q \\in \\{15, 18, 20, 22, 25\\}$。\n2. 无阈值弥散（边界情况）：$T_{0} = 20$，$\\sigma_{n} = 1$，$\\sigma_{T} = 0$，其中 $q \\in \\{19, 20, 21\\}$。\n3. 阈值弥散占主导（边缘情况）：$T_{0} = 20$，$\\sigma_{n} = 0.01$，$\\sigma_{T} = 5$，其中 $q \\in \\{10, 15, 20, 25, 30\\}$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表元素按指定的测试用例顺序，然后按 $q$ 值顺序排列（例如，$[r_{1},r_{2},\\dots]$）。每个 $r_{i}$ 必须是四舍五入到 $6$ 位小数的浮点数。", "solution": "问题要求推导平均模块效率 $\\bar{\\epsilon}(q)$ 的闭式表达式，并对指定参数进行数值评估。分析始于对问题陈述的严格验证。\n\n给定条件如下：\n- 沉积电荷：$q$ (单位为 $\\mathrm{ke}$)。\n- 每个通道的电子学噪声：$n$，一个高斯随机变量，其分布为 $n \\sim \\mathcal{N}(0, \\sigma_{n}^{2})$。\n- 每个通道的阈值：$T$，一个高斯随机变量，其分布为 $T \\sim \\mathcal{N}(T_{0}, \\sigma_{T}^{2})$。\n- 统计独立性：$n$ 和 $T$ 是独立的随机变量。\n- 对于固定阈值 $T$ 的击中条件：$q + n > T$。\n- 给定 $T$ 时的单通道响应：$\\epsilon(q \\mid T) = P(q + n > T \\mid T)$。\n- 平均模块效率：$\\bar{\\epsilon}(q) = \\int_{-\\infty}^{+\\infty} \\epsilon(q \\mid T)\\, p_{T}(T)\\, dT$，其中 $p_{T}(T)$ 是 $T$ 的概率密度函数 (PDF)。\n\n该问题具有科学依据，因为这个模型是探测器响应的标准表示方法。这是一个适定的问题，所有变量、参数和分布都已明确定义，确保可以推导出唯一的解。语言客观且正式。满足了有效问题的所有条件。\n\n推导过程如下。平均模块效率 $\\bar{\\epsilon}(q)$ 定义为单通道响应 $\\epsilon(q \\mid T)$ 在阈值 $T$ 的分布上的期望。\n$$\n\\bar{\\epsilon}(q) = E_{T}[\\epsilon(q \\mid T)] = E_{T}[P(q + n > T \\mid T)]\n$$\n根据全概率定律（或重复期望定律），这等价于发生击中的无条件概率：\n$$\n\\bar{\\epsilon}(q) = P(q + n > T)\n$$\n这种解释避免了对卷积积分进行直接且更复杂的计算。通过分析事件 $q + n > T$ 的概率可以解决该问题。为便于分析，我们重排不等式，将随机变量 $n$ 和 $T$ 组合在一起：\n$$\nq + n - T > 0\n$$\n我们定义一个新的随机变量 $S = n - T$。问题现在转变为求概率 $P(q + S > 0)$，这等价于 $P(S > -q)$。\n\n变量 $S$ 是两个独立高斯随机变量的线性组合。此类组合的性质是已经确立的。\n1. 随机变量 $n$ 服从分布 $n \\sim \\mathcal{N}(\\mu_{n}, \\sigma_{n}^{2})$，其中 $\\mu_{n}=0$。\n2. 随机变量 $T$ 服从分布 $T \\sim \\mathcal{N}(\\mu_{T}, \\sigma_{T}^{2})$，其中 $\\mu_{T}=T_{0}$。\n3. 随机变量 $-T$ 也是高斯型的。如果随机变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，那么 $aX+b \\sim \\mathcal{N}(a\\mu+b, a^2\\sigma^2)$。因此，$-T = (-1)T + 0$ 服从分布 $-T \\sim \\mathcal{N}(-T_{0}, (-1)^2\\sigma_{T}^{2}) = \\mathcal{N}(-T_{0}, \\sigma_{T}^{2})$。\n\n由于 $n$ 和 $T$ 是独立的，所以 $n$ 和 $-T$ 也是独立的。因此，和 $S = n + (-T)$ 是一个高斯随机变量。其均值 $\\mu_{S}$ 是其分量均值之和：\n$$\n\\mu_{S} = E[n - T] = E[n] - E[T] = 0 - T_{0} = -T_{0}\n$$\n其方差 $\\sigma_{S}^{2}$ 是其独立分量方差之和：\n$$\n\\sigma_{S}^{2} = \\mathrm{Var}(n - T) = \\mathrm{Var}(n) + \\mathrm{Var}(-T) = \\sigma_{n}^{2} + \\sigma_{T}^{2}\n$$\n因此，随机变量 $S$ 服从分布 $S \\sim \\mathcal{N}(-T_{0}, \\sigma_{n}^{2} + \\sigma_{T}^{2})$。我们定义一个有效总标准差 $\\sigma_{\\mathrm{eff}} = \\sqrt{\\sigma_{n}^{2} + \\sigma_{T}^{2}}$。\n\n我们现在计算概率 $P(S > -q)$。为此，我们通过定义一个新变量 $Z$ 来对变量 $S$ 进行标准化：\n$$\nZ = \\frac{S - \\mu_{S}}{\\sigma_{S}} = \\frac{S - (-T_{0})}{\\sigma_{\\mathrm{eff}}} = \\frac{S + T_{0}}{\\sigma_{\\mathrm{eff}}}\n$$\n变量 $Z$ 服从标准正态分布 $Z \\sim \\mathcal{N}(0, 1)$。我们将不等式 $S > -q$ 转换为关于 $Z$ 的不等式：\n$$\nS > -q \\implies S + T_{0} > -q + T_{0} \\implies \\frac{S + T_{0}}{\\sigma_{\\mathrm{eff}}} > \\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\n$$\n所以，我们有：\n$$\n\\bar{\\epsilon}(q) = P(S > -q) = P\\left(Z > \\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n对于标准正态变量 $Z$，概率 $P(Z > z)$ 由 $1 - \\Phi(z)$ 给出，其中 $\\Phi(z)$ 是标准正态分布的累积分布函数 (CDF)。\n$$\n\\bar{\\epsilon}(q) = 1 - \\Phi\\left(\\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n利用标准正态分布的对称性，$\\Phi(-z) = 1 - \\Phi(z)$。应用此性质，我们得到最终的紧凑表达式：\n$$\n\\bar{\\epsilon}(q) = \\Phi\\left(-\\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\\right) = \\Phi\\left(\\frac{q - T_{0}}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n代入 $\\sigma_{\\mathrm{eff}}$ 的定义，平均模块效率的闭式解为：\n$$\n\\bar{\\epsilon}(q) = \\Phi\\left(\\frac{q - T_{0}}{\\sqrt{\\sigma_{n}^{2} + \\sigma_{T}^{2}}}\\right)\n$$\n该表达式在探测器物理学中被称为“S曲线”或开启曲线。标准正态CDF与误差函数 $\\mathrm{erf}(x)$ 的关系为 $\\Phi(z) = \\frac{1}{2}\\left[1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right]$。这使得可以使用标准库函数进行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the mean module efficiency for given detector parameters and charge values.\n    \"\"\"\n\n    # Test suite:\n    # Each tuple contains (T0, sigma_n, sigma_T, list_of_q_values)\n    # All charge and threshold parameters are in units of kilo-electron charge (ke).\n    test_cases = [\n        # 1. General case (happy path)\n        (20.0, 0.8, 2.0, [15.0, 18.0, 20.0, 22.0, 25.0]),\n\n        # 2. No threshold dispersion (boundary case)\n        (20.0, 1.0, 0.0, [19.0, 20.0, 21.0]),\n\n        # 3. Dominant threshold dispersion (edge case)\n        (20.0, 0.01, 5.0, [10.0, 15.0, 20.0, 25.0, 30.0]),\n    ]\n\n    all_results = []\n\n    for T0, sigma_n, sigma_T, q_values in test_cases:\n        # The total effective standard deviation is the quadrature sum of the\n        # noise and threshold standard deviations.\n        # sigma_eff = sqrt(sigma_n^2 + sigma_T^2)\n        # Using np.hypot is numerically stable for cases where one term is much larger.\n        sigma_eff = np.hypot(sigma_n, sigma_T)\n\n        for q in q_values:\n            # The argument of the CDF. If sigma_eff is zero, this can lead to division by zero.\n            # However, sigma_eff can only be zero if both sigma_n and sigma_T are zero,\n            # which would make the response a step function. The test cases avoid this singularity.\n            if sigma_eff > 0:\n                z = (q - T0) / sigma_eff\n                # The mean efficiency is the CDF of the standard normal distribution\n                # evaluated at z.\n                efficiency = norm.cdf(z)\n            else:\n                # Handle the deterministic case where all noise/dispersion is zero.\n                # The response is a Heaviside step function.\n                efficiency = 1.0 if q > T0 else (0.5 if q == T0 else 0.0)\n\n            # Round the result to 6 decimal places as required.\n            all_results.append(round(efficiency, 6))\n\n    # Format the final output as a comma-separated list in brackets.\n    # Using map(str, ...) ensures float representation without scientific notation\n    # for small numbers after rounding.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3536201"}, {"introduction": "我们的物理测量的精度往往不是受到统计涨落的限制，而是受到系统不确定性的限制。径迹学中的一个关键例子就是我们对主要相互作用顶点的位置知识不完备。在最后一个练习 ([@problem_id:3536226]) 中，你将分析性地把一个测量不准的主顶点所带来的不确定性，传播到径迹的横向 ($d_0$) 和纵向 ($z_0$) 撞击参数上，从而直接洞悉探测器层面的不确定性如何影响关键的物理可观测量。", "problem": "考虑一个放置在均匀磁场中的径迹探测器，在相互作用点附近的小距离范围内，带电粒子的径迹可近似为直线。假设真实主顶点位于原点。测量的主顶点位置被建模为一个随机向量 $\\delta \\mathbf{r} = (\\delta x, \\delta y, \\delta z)$，它表示相对于原点的顶点位置的测量误差。该测量误差由一个多元正态分布建模，其均值向量为 $\\boldsymbol{\\mu}$（单位为米），协方差矩阵为 $\\Sigma$（单位为平方米），其中可能包含各分量之间的相关性。在稠密环境中，由于重建偏差和分辨率下降，$\\boldsymbol{\\mu}$ 和 $\\Sigma$ 都可能偏离理想的低密度情况下的值。\n\n在原点附近，一条径迹由一个穿过原点的直线表示，其单位方向向量为 $\\hat{\\mathbf{u}}(\\phi, \\theta) = (\\cos \\phi \\sin \\theta, \\sin \\phi \\sin \\theta, \\cos \\theta)$，其中 $\\phi$ 是横向平面内的方位角（单位为弧度），$\\theta$ 是从 $z$ 轴测量的极角（单位为弧度）。定义横向单位切向量和法向量分别为 $\\hat{\\mathbf{t}}(\\phi) = (\\cos \\phi, \\sin \\phi)$ 和 $\\hat{\\mathbf{n}}(\\phi) = (-\\sin \\phi, \\cos \\phi)$。\n\n带符号的横向碰撞参数 $d_0$ 定义为径迹与测量的主顶点之间的最近接近点的带符号横向距离，在右手坐标系中使用横向法向量 $\\hat{\\mathbf{n}}(\\phi)$ 作为符号约定。纵向碰撞参数 $z_0$ 定义为在横向最近接近点处径迹的 $z$ 坐标与测量的主顶点的 $z$ 坐标之差。\n\n假设主顶点位移和局部径迹曲率很小，从而碰撞参数偏差可以相对于 $\\delta \\mathbf{r}$ 进行线性化。将 $\\delta \\mathbf{r}$ 视为具有给定 $\\boldsymbol{\\mu}$ 和 $\\Sigma$ 的多元正态分布。对于一个径迹系综，计算：\n1. $d_0$ 偏差的系综平均值（单位为米）。\n2. $z_0$ 偏差的系综平均值（单位为米）。\n3. $d_0$ 偏差的系综均方根（RMS）（单位为米），定义为在主顶点分布和径迹样本上对 $d_0^2$ 进行系综平均后再开平方根。\n4. $z_0$ 偏差的系综均方根（RMS）（单位为米），定义与前者类似。\n\n角度必须以弧度为单位。所有距离必须以米为单位表示。你的程序不得执行任何事件级的蒙特卡洛采样；相反，你必须基于线性化和多元正态分布的性质使用解析传播。系综平均必须使用指定的权重在给定的有限径迹集上计算。\n\n测试套件：\n对于每个测试用例，会给出一组径迹角度和权重，以及 $\\boldsymbol{\\mu}$ 和 $\\Sigma$。协方差矩阵 $\\Sigma$ 是对称的，其元素以平方米为单位给出。在所有情况下，答案都以米为单位。\n\n- 测试用例 1（低密度基线）：\n  - $\\boldsymbol{\\mu} = (0,\\ 0,\\ 0)$。\n  - $\\Sigma$ 的元素：\n    - $\\Sigma_{xx} = (20 \\times 10^{-6})^2$，$\\Sigma_{yy} = (20 \\times 10^{-6})^2$，$\\Sigma_{zz} = (40 \\times 10^{-6})^2$，\n    - $\\Sigma_{xy} = \\Sigma_{xz} = \\Sigma_{yz} = 0$。\n  - 径迹（每条权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.0,\\ 1.3)$，\n    - $(\\phi,\\ \\theta) = (1.0,\\ 1.0)$，\n    - $(\\phi,\\ \\theta) = (2.3,\\ 0.8)$，\n    - $(\\phi,\\ \\theta) = (3.0,\\ \\frac{\\pi}{2})$，\n    - $(\\phi,\\ \\theta) = (4.2,\\ 1.2)$。\n\n- 测试用例 2（稠密环境，具有各向异性的横向分辨率和非零均值偏差）：\n  - $\\boldsymbol{\\mu} = (10 \\times 10^{-6},\\ -5 \\times 10^{-6},\\ 30 \\times 10^{-6})$。\n  - $\\Sigma$ 的元素：\n    - $\\Sigma_{xx} = (60 \\times 10^{-6})^2$，$\\Sigma_{yy} = (40 \\times 10^{-6})^2$，$\\Sigma_{zz} = (80 \\times 10^{-6})^2$，\n    - $\\Sigma_{xy} = 0.3 \\times (60 \\times 10^{-6}) \\times (40 \\times 10^{-6})$，\n    - $\\Sigma_{xz} = \\Sigma_{yz} = 0$。\n  - 径迹（每条权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.2,\\ 1.4)$，\n    - $(\\phi,\\ \\theta) = (1.1,\\ 0.9)$，\n    - $(\\phi,\\ \\theta) = (2.5,\\ 1.1)$，\n    - $(\\phi,\\ \\theta) = (3.7,\\ 1.2)$，\n    - $(\\phi,\\ \\theta) = (5.0,\\ 0.7)$，\n    - $(\\phi,\\ \\theta) = (0.8,\\ 1.3)$。\n\n- 测试用例 3（具有 $x$–$z$ 相关性的前向径迹混合）：\n  - $\\boldsymbol{\\mu} = (0,\\ 0,\\ 15 \\times 10^{-6})$。\n  - $\\Sigma$ 的元素：\n    - $\\Sigma_{xx} = (50 \\times 10^{-6})^2$，$\\Sigma_{yy} = (50 \\times 10^{-6})^2$，$\\Sigma_{zz} = (70 \\times 10^{-6})^2$，\n    - $\\Sigma_{xy} = -0.2 \\times (50 \\times 10^{-6}) \\times (50 \\times 10^{-6})$，\n    - $\\Sigma_{xz} = 0.2 \\times (50 \\times 10^{-6}) \\times (70 \\times 10^{-6})$，\n    - $\\Sigma_{yz} = 0$。\n  - 径迹（每条权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.0,\\ 0.25)$，\n    - $(\\phi,\\ \\theta) = (1.5,\\ 0.35)$，\n    - $(\\phi,\\ \\theta) = (\\pi,\\ 0.5)$，\n    - $(\\phi,\\ \\theta) = (4.0,\\ 0.9)$。\n\n- 测试用例 4（确定性偏差，零协方差）：\n  - $\\boldsymbol{\\mu} = (30 \\times 10^{-6},\\ -30 \\times 10^{-6},\\ -20 \\times 10^{-6})$。\n  - $\\Sigma$ 是零矩阵（所有元素为 $0$）。\n  - 径迹（每条权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.3,\\ 1.0)$，\n    - $(\\phi,\\ \\theta) = (2.7,\\ 1.2)$，\n    - $(\\phi,\\ \\theta) = (5.5,\\ 0.8)$。\n\n计算和输出规范：\n- 对于每个测试用例，计算上面列出的四个量：系综平均 $d_0$、系综平均 $z_0$、系综 RMS $d_0$、系综 RMS $z_0$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”），依次串联测试用例 1 的四个结果、测试用例 2 的四个结果、测试用例 3 的四个结果，以及测试用例 4 的四个结果。所有输出都必须以米为单位。", "solution": "该问题要求在给定主顶点位置测量误差的统计模型下，计算粒子径迹的横向（$d_0$）和纵向（$z_0$）碰撞参数的系综平均偏差和均方根（RMS）值。我们需要执行解析计算，将顶点测量的误差传播到碰撞参数。\n\n### 问题形式化\n\n真实主顶点位于原点 $\\mathbf{r}_{true} = (0, 0, 0)$。测量的主顶点位置 $\\mathbf{r}_v$ 与真实顶点之间存在一个随机位移向量 $\\delta \\mathbf{r} = (\\delta x, \\delta y, \\delta z)$。该位移被建模为一个3维多元正态分布 $\\delta \\mathbf{r} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\Sigma)$，其均值向量为 $\\boldsymbol{\\mu} = (\\mu_x, \\mu_y, \\mu_z)^T$，协方差矩阵为 $\\Sigma$。\n\n一条径迹被近似为一条穿过真实原点的直线，其单位方向向量为 $\\hat{\\mathbf{u}}(\\phi, \\theta) = (\\sin\\theta \\cos\\phi, \\sin\\theta \\sin\\phi, \\cos\\theta)$，其中 $\\phi$ 是方位角，$\\theta$ 是极角。\n\n### 碰撞参数的推导\n\n首先，我们将碰撞参数 $d_0$ 和 $z_0$ 表示为顶点位移分量 $\\delta x$、$\\delta y$ 和 $\\delta z$ 的线性函数。\n\n1.  **横向碰撞参数 ($d_0$)**：带符号的横向碰撞参数 $d_0$ 是在横向（$x$-$y$）平面内，径迹路径（穿过原点的直线）与测量的顶点横向位置 $\\mathbf{r}_{v,T} = (\\delta x, \\delta y)$ 之间的最近接近点的带符号距离。符号由其在横向法向量 $\\hat{\\mathbf{n}}(\\phi) = (-\\sin\\phi, \\cos\\phi)$ 上的投影决定。\n    $$d_0 = \\mathbf{r}_{v,T} \\cdot \\hat{\\mathbf{n}}(\\phi) = (\\delta x, \\delta y) \\cdot (-\\sin\\phi, \\cos\\phi)$$\n    $$d_0 = -\\delta x \\sin\\phi + \\delta y \\cos\\phi$$\n    这是 $\\delta \\mathbf{r}$ 的一个线性函数。我们可以写成 $d_0 = \\mathbf{c}_{d_0}^T \\delta \\mathbf{r}$，其中系数向量为 $\\mathbf{c}_{d_0} = (-\\sin\\phi, \\cos\\phi, 0)^T$。\n\n2.  **纵向碰撞参数 ($z_0$)**：纵向碰撞参数 $z_0$ 定义为 $z_0 = z_{track} - z_v$，其中 $z_v = \\delta z$ 是测量的顶点 $z$ 坐标，$z_{track}$ 是在横向最近接近点处径迹的 $z$ 坐标。从原点到该点的横向路径长度 $s_T$ 是 $\\mathbf{r}_{v,T}$ 在横向径迹方向 $\\hat{\\mathbf{t}}(\\phi) = (\\cos\\phi, \\sin\\phi)$ 上的投影：\n    $$s_T = \\mathbf{r}_{v,T} \\cdot \\hat{\\mathbf{t}}(\\phi) = \\delta x \\cos\\phi + \\delta y \\sin\\phi$$\n    沿着径迹对应的三维路径长度为 $s = s_T / \\sin\\theta$（假设 $\\sin\\theta \\neq 0$）。此时径迹的 $z$ 坐标为 $z_{track} = s \\cos\\theta = s_T \\cot\\theta$。\n    $$z_{track} = (\\delta x \\cos\\phi + \\delta y \\sin\\phi) \\cot\\theta$$\n    因此，$z_0$ 为：\n    $$z_0 = (\\delta x \\cos\\phi + \\delta y \\sin\\phi) \\cot\\theta - \\delta z$$\n    这也是 $\\delta \\mathbf{r}$ 的一个线性函数，可以写成 $z_0 = \\mathbf{c}_{z_0}^T \\delta \\mathbf{r}$，其系数向量为 $\\mathbf{c}_{z_0} = (\\cos\\phi \\cot\\theta, \\sin\\phi \\cot\\theta, -1)^T$。\n\n### 偏差和 RMS 计算\n\n对于一个通用量 $Q = \\mathbf{c}^T \\delta \\mathbf{r}$，其中 $\\delta \\mathbf{r} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\Sigma)$，其期望值（均值）和方差由随机向量仿射变换的标准法则给出：\n-   均值：$E[Q] = \\mathbf{c}^T E[\\delta \\mathbf{r}] = \\mathbf{c}^T \\boldsymbol{\\mu}$\n-   方差：$\\text{Var}(Q) = \\mathbf{c}^T \\text{Cov}(\\delta \\mathbf{r}) \\mathbf{c} = \\mathbf{c}^T \\Sigma \\mathbf{c}$\n\n均方值与均值和方差的关系为 $E[Q^2] = \\text{Var}(Q) + (E[Q])^2$。下标 $v$ 将表示对顶点分布的期望。\n\n**对于参数为 $(\\phi, \\theta)$ 的单条径迹：**\n\n-   **平均偏差**：\n    $$E_v[d_0] = \\mathbf{c}_{d_0}^T \\boldsymbol{\\mu} = -\\mu_x \\sin\\phi + \\mu_y \\cos\\phi$$\n    $$E_v[z_0] = \\mathbf{c}_{z_0}^T \\boldsymbol{\\mu} = (\\mu_x \\cos\\phi + \\mu_y \\sin\\phi) \\cot\\theta - \\mu_z$$\n\n-   **方差**：\n    $$\\text{Var}_v(d_0) = \\mathbf{c}_{d_0}^T \\Sigma \\mathbf{c}_{d_0} = \\Sigma_{xx} \\sin^2\\phi + \\Sigma_{yy} \\cos^2\\phi - 2\\Sigma_{xy} \\sin\\phi \\cos\\phi$$\n    $$\\text{Var}_v(z_0) = \\mathbf{c}_{z_0}^T \\Sigma \\mathbf{c}_{z_0} = \\cot^2\\theta(\\Sigma_{xx}\\cos^2\\phi + \\Sigma_{yy}\\sin^2\\phi + 2\\Sigma_{xy}\\sin\\phi\\cos\\phi) - 2\\cot\\theta(\\Sigma_{xz}\\cos\\phi + \\Sigma_{yz}\\sin\\phi) + \\Sigma_{zz}$$\n\n-   **均方值**：\n    $$E_v[d_0^2] = \\text{Var}_v(d_0) + (E_v[d_0])^2$$\n    $$E_v[z_0^2] = \\text{Var}_v(z_0) + (E_v[z_0])^2$$\n\n### 系综平均\n\n问题要求计算在顶点分布和一个包含 $N$ 条径迹 $\\{(\\phi_i, \\theta_i)\\}_{i=1}^N$ 的有限样本上平均的量，每条径迹的权重为 $w_i$。总权重为 $W = \\sum_{i=1}^N w_i$。一个量 $X$ 的系综平均值（表示为 $\\langle X \\rangle$）计算如下：\n$$\\langle X \\rangle = \\frac{1}{W} \\sum_{i=1}^N w_i E_v[X_i]$$\n其中 $X_i$ 是为第 $i$ 条径迹计算的量。\n\n所需的四个量是：\n1.  $d_0$ 偏差的系综平均值：$\\langle d_0 \\rangle = \\frac{1}{W} \\sum_{i=1}^N w_i E_v[d_{0, i}]$\n2.  $z_0$ 偏差的系综平均值：$\\langle z_0 \\rangle = \\frac{1}{W} \\sum_{i=1}^N w_i E_v[z_{0, i}]$\n3.  $d_0$ 的系综 RMS：$\\text{RMS}(d_0) = \\sqrt{\\langle d_0^2 \\rangle} = \\sqrt{\\frac{1}{W} \\sum_{i=1}^N w_i E_v[d_{0, i}^2]}$\n4.  $z_0$ 的系综 RMS：$\\text{RMS}(z_0) = \\sqrt{\\langle z_0^2 \\rangle} = \\sqrt{\\frac{1}{W} \\sum_{i=1}^N w_i E_v[z_{0, i}^2]}$\n\n这些公式为每个测试用例提供了一套完整的解析方法，无需蒙特卡洛模拟即可计算所需结果。实现过程包括将这些公式应用于给定的关于 $\\boldsymbol{\\mu}$、$\\Sigma$ 和径迹样本的数值数据。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n\n    def build_sigma(params):\n        \"\"\"\n        Builds the 3x3 symmetric covariance matrix from a dictionary of parameters.\n        \"\"\"\n        sigma = np.zeros((3, 3))\n        sigma[0, 0] = params.get('xx', 0.0)\n        sigma[1, 1] = params.get('yy', 0.0)\n        sigma[2, 2] = params.get('zz', 0.0)\n        sigma[0, 1] = sigma[1, 0] = params.get('xy', 0.0)\n        sigma[0, 2] = sigma[2, 0] = params.get('xz', 0.0)\n        sigma[1, 2] = sigma[2, 1] = params.get('yz', 0.0)\n        return sigma\n\n    def calculate_ensemble_stats(mu, sigma, tracks):\n        \"\"\"\n        Calculates ensemble statistics for a given mu, sigma, and set of tracks.\n        \"\"\"\n        sum_mean_d0 = 0.0\n        sum_mean_z0 = 0.0\n        sum_mean_sq_d0 = 0.0\n        sum_mean_sq_z0 = 0.0\n        total_weight = 0.0\n\n        mu_x, mu_y, mu_z = mu\n        s_xx, s_xy, s_xz = sigma[0, 0], sigma[0, 1], sigma[0, 2]\n        s_yy, s_yz = sigma[1, 1], sigma[1, 2]\n        s_zz = sigma[2, 2]\n\n        for phi, theta, weight in tracks:\n            sin_phi = np.sin(phi)\n            cos_phi = np.cos(phi)\n            \n            # Handle cot(theta) carefully for theta near multiples of pi.\n            # For this problem's inputs, this is safe.\n            sin_theta = np.sin(theta)\n            if np.isclose(sin_theta, 0):\n                # For tracks along the z-axis, cot(theta) is infinite.\n                # z0 definition is ill-defined. However, test cases avoid this.\n                # If needed, a special handling would be placed here.\n                # For this problem, we can assume sin_theta is not zero.\n                cot_theta = np.inf if np.cos(theta) > 0 else -np.inf\n            else:\n                cot_theta = np.cos(theta) / sin_theta\n\n            # Mean biases for this track\n            mean_d0 = -mu_x * sin_phi + mu_y * cos_phi\n            mean_z0 = (mu_x * cos_phi + mu_y * sin_phi) * cot_theta - mu_z\n\n            # Variances for this track\n            var_d0 = s_xx * sin_phi**2 + s_yy * cos_phi**2 - 2 * s_xy * sin_phi * cos_phi\n            \n            var_z0_term1 = (s_xx * cos_phi**2 + s_yy * sin_phi**2 + 2 * s_xy * sin_phi * cos_phi) * cot_theta**2\n            var_z0_term2 = -2 * (s_xz * cos_phi + s_yz * sin_phi) * cot_theta\n            var_z0_term3 = s_zz\n            var_z0 = var_z0_term1 + var_z0_term2 + var_z0_term3\n            \n            # Mean squares for this track\n            mean_sq_d0 = var_d0 + mean_d0**2\n            mean_sq_z0 = var_z0 + mean_z0**2\n\n            # Accumulate weighted sums\n            sum_mean_d0 += weight * mean_d0\n            sum_mean_z0 += weight * mean_z0\n            sum_mean_sq_d0 += weight * mean_sq_d0\n            sum_mean_sq_z0 += weight * mean_sq_z0\n            total_weight += weight\n\n        # Final ensemble averages\n        ensemble_mean_d0 = sum_mean_d0 / total_weight\n        ensemble_mean_z0 = sum_mean_z0 / total_weight\n        ensemble_mean_sq_d0 = sum_mean_sq_d0 / total_weight\n        ensemble_mean_sq_z0 = sum_mean_sq_z0 / total_weight\n\n        # RMS values\n        ensemble_rms_d0 = np.sqrt(ensemble_mean_sq_d0)\n        ensemble_rms_z0 = np.sqrt(ensemble_mean_sq_z0)\n\n        return [ensemble_mean_d0, ensemble_mean_z0, ensemble_rms_d0, ensemble_rms_z0]\n\n    # Test Case Definitions\n    test_cases = [\n        # Test Case 1\n        {\n            \"mu\": np.array([0.0, 0.0, 0.0]),\n            \"sigma_params\": {\n                'xx': (20e-6)**2, 'yy': (20e-6)**2, 'zz': (40e-6)**2,\n                'xy': 0.0, 'xz': 0.0, 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.0, 1.3, 1.0), (1.0, 1.0, 1.0), (2.3, 0.8, 1.0),\n                (3.0, np.pi/2, 1.0), (4.2, 1.2, 1.0)\n            ]\n        },\n        # Test Case 2\n        {\n            \"mu\": np.array([10e-6, -5e-6, 30e-6]),\n            \"sigma_params\": {\n                'xx': (60e-6)**2, 'yy': (40e-6)**2, 'zz': (80e-6)**2,\n                'xy': 0.3 * (60e-6) * (40e-6), 'xz': 0.0, 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.2, 1.4, 1.0), (1.1, 0.9, 1.0), (2.5, 1.1, 1.0),\n                (3.7, 1.2, 1.0), (5.0, 0.7, 1.0), (0.8, 1.3, 1.0)\n            ]\n        },\n        # Test Case 3\n        {\n            \"mu\": np.array([0.0, 0.0, 15e-6]),\n            \"sigma_params\": {\n                'xx': (50e-6)**2, 'yy': (50e-6)**2, 'zz': (70e-6)**2,\n                'xy': -0.2 * (50e-6) * (50e-6), 'xz': 0.2 * (50e-6) * (70e-6), 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.0, 0.25, 1.0), (1.5, 0.35, 1.0), (np.pi, 0.5, 1.0), (4.0, 0.9, 1.0)\n            ]\n        },\n        # Test Case 4\n        {\n            \"mu\": np.array([30e-6, -30e-6, -20e-6]),\n            \"sigma_params\": {\n                'xx': 0.0, 'yy': 0.0, 'zz': 0.0, 'xy': 0.0, 'xz': 0.0, 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.3, 1.0, 1.0), (2.7, 1.2, 1.0), (5.5, 0.8, 1.0)\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        mu = case['mu']\n        sigma = build_sigma(case['sigma_params'])\n        tracks = case['tracks']\n        results = calculate_ensemble_stats(mu, sigma, tracks)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3536226"}]}