{"hands_on_practices": [{"introduction": "任何基于直方图的分析，第一步都是将每个数据点分配到正确的区间中。虽然这看似简单，但浮点数的算术特性可能会在区间边界处导致歧义和错误。本练习 [@problem_id:3510256] 将指导你实现一个数值稳定的分箱（binning）分配函数，这是确保数据分析可靠性的关键基石。", "problem": "给定一个有序的实值区间边界数组 $b_0 < b_1 < \\cdots < b_M$（其中 $M \\ge 2$），它按照约定 $[b_i, b_{i+1})$（对于 $i \\in \\{0,1,\\dots,M-1\\}$）定义了半开直方图区间。在计算高能物理中，诸如横向动量 $p_T$ 等物理可观测量以吉电子伏特 (GeV) 为单位进行测量，而直方图构建需要在浮点数边界附近进行无歧义、可复现的区间分配。根据半开约定，任何满足 $b_i \\le x < b_{i+1}$ 的值 $x$ 必须被分配到区间索引 $i$，值 $x < b_0$ 为下溢值，值 $x \\ge b_M$ 为上溢值（即被排除在已定义的区间之外）。您的任务是实现一个数值稳定的分配函数，该函数遵循半开区间的定义，并避免对极其接近 $b_{i+1}$ 的值进行浮点边界误分类。\n\n从以下基础出发：\n- 电气和电子工程师协会 (IEEE) $754$ 浮点标准定义了实数轴上的可表示数，其间距与机器相关，包含了末位单元 (ULP) 的概念，并提供了后继/前驱函数 $\\operatorname{nextafter}(y, z)$，该函数返回紧邻 $y$ 且朝向 $z$ 方向的可表示数。\n- 当比较被恰当定义时，对有序数组进行单调二分搜索可以得到与全序比较和半开区间划分一致的索引。\n- 半开划分 $[b_i, b_{i+1})$ 是不相交的，并覆盖了区间 $[b_0, b_M)$。\n\n设计并实现一个分配函数，该函数：\n1. 对于每个输入值 $x$，当 $b_0 \\le x < b_M$ 时，返回一个有效的区间索引 $i \\in \\{0,\\dots,M-1\\}$，并从区间计数中排除下溢值（$x < b_0$）和上溢值（$x \\ge b_M$）。\n2. 确保在浮点表示中等于右边界 $b_{i+1}$ 的值被分配到下一个区间 $i+1$（与半开区间一致），并通过使用与 IEEE $754$ 语义一致的比较策略或边界处理方法，而不是临时的绝对容差，来防止对与 $b_{i+1}$ 相差一个 ULP 以内的值进行误分类。\n3. 对给定的测试数据，以整数形式生成每个区间的计数。\n\n将您的解决方案实现为一个完整的、可运行的程序。使用以下测试套件。所有可观测量均以吉电子伏特 (GeV) 为单位；计数是无量纲整数。在所有情况下，采用半开约定 $[b_i, b_{i+1})$，并从计数中排除下溢值（$x < b_0$）和上溢值（$x \\ge b_M$）。\n\n测试用例 1（正常路径，显式边界探测）：\n- 区间边界 $b = [0.0, 50.0, 100.0, 200.0]$ GeV。\n- 值 $x$ (GeV): $[0.0, 12.5, \\operatorname{nextafter}(50.0, -\\infty), 50.0, \\operatorname{nextafter}(50.0, +\\infty), 75.0, \\operatorname{nextafter}(100.0, -\\infty), 100.0, \\operatorname{nextafter}(100.0, +\\infty), 150.0, \\operatorname{nextafter}(200.0, -\\infty), 200.0, 250.0]$。\n\n测试用例 2（横向动量中典型的非均匀区间）：\n- 区间边界 $b = [0.5, 1.0, 2.0, 5.0, 10.0]$ GeV。\n- 值 $x$ (GeV): $[0.4999, 0.5, \\operatorname{nextafter}(0.5, +\\infty), \\operatorname{nextafter}(1.0, -\\infty), 1.0, \\operatorname{nextafter}(1.0, +\\infty), 1.5, \\operatorname{nextafter}(2.0, -\\infty), 2.0, 3.0, \\operatorname{nextafter}(5.0, -\\infty), 5.0, 7.5, \\operatorname{nextafter}(10.0, -\\infty), 10.0]$。\n\n测试用例 3（小上界范围的边界压力测试）：\n- 区间边界 $b = [0.0, 0.1, 1.0]$ GeV。\n- 值 $x$ (GeV): $[-10^{-12}, 0.0, \\operatorname{nextafter}(0.0, +\\infty), \\operatorname{nextafter}(0.1, -\\infty), 0.1, \\operatorname{nextafter}(0.1, +\\infty), \\operatorname{nextafter}(1.0, -\\infty), 1.0]$。\n\n测试用例 4（更宽的物理学驱动范围）：\n- 区间边界 $b = [0.0, 20.0, 50.0, 100.0, 200.0, 400.0]$ GeV。\n- 值 $x$ (GeV): $[0.0, \\operatorname{nextafter}(20.0, -\\infty), 20.0, 35.0, \\operatorname{nextafter}(50.0, -\\infty), 50.0, 75.0, \\operatorname{nextafter}(100.0, -\\infty), 100.0, 150.0, \\operatorname{nextafter}(200.0, -\\infty), 200.0, 300.0, \\operatorname{nextafter}(400.0, -\\infty), 400.0, 800.0]$。\n\n您的程序必须输出单行结果，该结果是包含在方括号内的逗号分隔列表。每个元素对应一个测试用例，并且必须是遵循半开分配的每个区间的计数列表，不包括下溢和上溢。具体来说，输出格式必须是：\n\"[$R_1, R_2, R_3, R_4$]\"\n其中 $R_k$ 是测试用例 $k$ 在区间顺序 $i = 0,1,\\dots,M-1$ 下的整数计数列表。例如，一个元素可能看起来像 \"[3,4,4]\"。不得打印任何其他文本。", "solution": "该问题要求实现一个数值稳定的直方图分箱函数。给定一个由 $M+1$ 个区间边界组成的有序数组 $b = \\{b_0, b_1, \\dots, b_M\\}$，其中 $b_0 < b_1 < \\cdots < b_M$，以及一组数据值 $\\{x\\}$，我们必须将每个值 $x$ 分配到一个唯一的区间索引 $i \\in \\{0, 1, \\dots, M-1\\}$。分箱约定由半开区间 $[b_i, b_{i+1})$ 定义，这意味着一个值 $x$ 属于区间 $i$ 当且仅当条件 $b_i \\le x < b_{i+1}$ 满足。在总范围 $[b_0, b_M)$ 之外的值，特别是下溢值（$x < b_0$）和上溢值（$x \\ge b_M$），将从计数中排除。主要挑战是确保该逻辑被稳健地遵守，特别是对于那些极其接近区间边界 $b_{i+1}$ 的浮点值，而不依赖临时的绝对容差。\n\n解决方案必须基于 IEEE $754$ 浮点算术的形式化属性。标准比较运算符（<, , , ）对所有可表示的浮点数都是良定义的。因此，正确实现严格不等式 $x  b_{i+1}$ 的关键在于正确使用这些基本运算符，而高质量的数值库正是这样做的。问题中提到的 $\\operatorname{nextafter}(y, z)$ 用于构造测试值，以便以机器精度探测这些边界条件。\n\n一个稳健而高效的算法可以建立在二分搜索的原则之上，因为区间边界是排序的。`NumPy` 库提供了一个高度优化且经过充分测试的函数 `numpy.digitize`，它正是为此目的而设计的。此函数为数组中的每个值找到 ULP 精度的分箱。\n\n具体的实现策略如下：\n\n1.  **使用 `numpy.digitize` 进行分箱索引**：我们将使用函数 `numpy.digitize(x, bins, right=False)`。`bins` 参数对应我们的边界数组 $b$，$x$ 是待分箱的值数组。参数 `right=False` 指定区间形式为 $[b_{i-1}, b_i)$，这与我们要求的约定 $[b_i, b_{i+1})$ 直接对应。该函数返回从1开始的索引。\n    - 对于满足 $b_i \\le x  b_{i+1}$（其中 $i \\in \\{0, \\dots, M-1\\}$）的值 $x$，`numpy.digitize` 返回索引 $i+1$。\n    - 对于下溢值 $x  b_0$，它返回 $0$。\n    - 对于上溢值 $x \\ge b_M$，它返回 $M+1$。\n\n2.  **索引转换**：从 `numpy.digitize` 返回的从1开始的索引可以转换为对我们更方便的从0开始的表示。通过从返回的索引数组中减去 $1$：\n    - 位于区间 $i$（对于 $i \\in \\{0, \\dots, M-1\\}$）中的值被映射到索引 $(i+1) - 1 = i$。\n    - 下溢值被映射到索引 $0 - 1 = -1$。\n    - 上溢值被映射到索引 $(M+1) - 1 = M$。\n    这创造了一个清晰的分隔：有效的区间索引落在范围 $[0, M-1]$ 内，而下溢和上溢则被映射到此范围之外的索引。\n\n3.  **筛选和计数**：现在我们可以分离出落在已定义区间内的值。我们创建一个布尔掩码来仅选择那些满足 $0 \\le i_{bin}  M$ 的索引 $i_{bin}$。应用此掩码后，我们得到一个包含所有在范围内值的有效、从0开始的区间编号数组。\n\n4.  **使用 `numpy.bincount` 进行聚合**：最后一步是计算每个区间索引的出现次数。函数 `numpy.bincount` 非常适合此任务。它接受一个非负整数数组，并返回一个数组，其中索引 $k$ 处的值是 $k$ 在输入数组中出现的次数。通过提供 `minlength=M` 参数，我们确保生成的计数数组的长度等于区间的数量，对于任何恰好为空的区间，其计数值为 $0$。这样就生成了所需的每个区间的计数。\n\n这种方法不仅计算效率高，而且在数值上是稳健的。它依赖于一个标准的、经过严格审查的库函数（`numpy.digitize`），该函数在浮点精度的极限情况下正确实现比较，从而满足了问题陈述的所有要求。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the histogram binning problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"b_edges\": [0.0, 50.0, 100.0, 200.0],\n            \"x_values\": [\n                0.0, \n                12.5, \n                np.nextafter(50.0, -np.inf), \n                50.0, \n                np.nextafter(50.0, np.inf), \n                75.0, \n                np.nextafter(100.0, -np.inf), \n                100.0, \n                np.nextafter(100.0, np.inf), \n                150.0, \n                np.nextafter(200.0, -np.inf), \n                200.0, \n                250.0\n            ]\n        },\n        {\n            \"b_edges\": [0.5, 1.0, 2.0, 5.0, 10.0],\n            \"x_values\": [\n                0.4999, \n                0.5, \n                np.nextafter(0.5, np.inf), \n                np.nextafter(1.0, -np.inf), \n                1.0, \n                np.nextafter(1.0, np.inf), \n                1.5, \n                np.nextafter(2.0, -np.inf), \n                2.0, \n                3.0, \n                np.nextafter(5.0, -np.inf), \n                5.0, \n                7.5, \n                np.nextafter(10.0, -np.inf), \n                10.0\n            ]\n        },\n        {\n            \"b_edges\": [0.0, 0.1, 1.0],\n            \"x_values\": [\n                -1e-12, \n                0.0, \n                np.nextafter(0.0, np.inf), \n                np.nextafter(0.1, -np.inf), \n                0.1, \n                np.nextafter(0.1, np.inf), \n                np.nextafter(1.0, -np.inf), \n                1.0\n            ]\n        },\n        {\n            \"b_edges\": [0.0, 20.0, 50.0, 100.0, 200.0, 400.0],\n            \"x_values\": [\n                0.0, \n                np.nextafter(20.0, -np.inf), \n                20.0, \n                35.0, \n                np.nextafter(50.0, -np.inf), \n                50.0, \n                75.0, \n                np.nextafter(100.0, -np.inf), \n                100.0, \n                150.0, \n                np.nextafter(200.0, -np.inf), \n                200.0, \n                300.0, \n                np.nextafter(400.0, -np.inf), \n                400.0, \n                800.0\n            ]\n        }\n    ]\n\n    def calculate_bin_counts(b_edges_np, x_values_np):\n        \"\"\"\n        Calculates per-bin counts for given edges and values.\n\n        Args:\n            b_edges_np (np.ndarray): Sorted array of bin edges.\n            x_values_np (np.ndarray): Array of values to bin.\n\n        Returns:\n            list: A list of integer counts for each bin.\n        \"\"\"\n        num_bins = len(b_edges_np) - 1\n        \n        # np.digitize uses right=False for [b[i-1], b[i]) interval convention.\n        # It returns 1-based bin indices.\n        # Underflows (x  b[0]) get index 0.\n        # Overflows (x = b[-1]) get index len(b).\n        digitized_indices = np.digitize(x_values_np, b_edges_np, right=False)\n        \n        # Convert to 0-based indices:\n        # A value in bin `i` gets index `i`.\n        # Underflows get index -1.\n        # Overflows get index num_bins.\n        bin_indices = digitized_indices - 1\n        \n        # Filter for indices that correspond to actual bins (0 to num_bins-1)\n        valid_mask = (bin_indices = 0)  (bin_indices  num_bins)\n        valid_indices = bin_indices[valid_mask]\n        \n        # Count occurrences of each valid bin index.\n        # minlength ensures all bins are represented in the output, even if empty.\n        counts = np.bincount(valid_indices, minlength=num_bins)\n        \n        return counts.tolist()\n\n    all_results = []\n    for case in test_cases:\n        b = np.array(case[\"b_edges\"], dtype=float)\n        x = np.array(case[\"x_values\"], dtype=float)\n        \n        counts = calculate_bin_counts(b, x)\n        all_results.append(counts)\n\n    # Format the final output string according to the specification.\n    # R_k is formatted as a string like \"[c1,c2,c3]\" with no spaces.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    \n    # The final output is a comma-separated list of these formatted strings,\n    # enclosed in a single pair of square brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3510256"}, {"introduction": "掌握了分箱的技术细节之后，一个关键的策略性问题随之而来：箱宽（bin width）应该设为多少？箱宽 $h$ 是一个至关重要的超参数，它深刻影响直方图表示底层数据分布的能力。本练习 [@problem_id:3510284] 将超越简单的启发式规则，介绍一种基于数据的、有原则的方法——最小二乘交叉验证（least-squares cross-validation），来确定最优的箱宽。", "problem": "给定一个大小为 $N$ 的单变量数据集，要求使用箱宽为 $h$ 的分段常数直方图估计器进行密度估计。请将以下定义视为基本依据。\n\n- 箱宽为 $h$ 的直方图密度估计器 $\\hat{f}_h(x)$ 的定义是：将实数轴划分为宽度为 $h$ 的相邻箱，并在每个箱内部分配一个恒定的密度值，该值等于箱内计数除以 $N h$。\n- 密度估计器的风险可以通过积分平方误差 (ISE) 来衡量，其定义为 $\\int \\left(\\hat{f}_h(x) - f(x)\\right)^2 \\, dx$，其中 $f(x)$ 是未知的真实密度。\n- 留一法交叉验证 (LOOCV) 为每个数据点 $x_i$ 构建一个密度估计器，该估计器在除 $x_i$ 之外的所有数据上进行拟合，我们将其表示为 $\\hat{f}_{-i,h}(x)$，以减轻在训练点上评估估计器所带来的偏差。\n\n任务：\n1. 从上述定义出发，并且不使用任何现成的简化公式，推导一个基于原则的最小二乘交叉验证 (LSCV) 准则，该准则基于 LOOCV 来估计直方图密度估计的 ISE。您的推导必须将 LOOCV 目标完全用数据集 $\\{x_i\\}_{i=1}^N$、箱宽 $h$ 以及在 $h$ 下产生的箱计数来表示。您应该明确分箱方案以及如何将数据点映射到其所在的箱。\n2. 实现一个程序，对于一个给定的有限箱宽候选集，使用您推导出的表达式为每个候选 $h$ 计算 LOOCV 损失，并返回使损失最小化的 $h$。如果多个 $h$ 达到相同的最小值（在数值上相等的情况下），则返回其中最小的 $h$。\n3. 分箱方案规范（必须完全遵循以获得满分）：\n   - 对于给定的 $h0$，定义锚点 $a = \\left\\lfloor \\frac{\\min_i x_i}{h} \\right\\rfloor h$。\n   - 将箱边界定义为 $a + k h$（其中 $k$ 为整数），并对所有箱使用形式为 $[a + k h, a + (k+1) h)$ 的半开区间，除了最后一个箱，它包含数据范围的右端点。在实践中，构建足够多的连续箱以覆盖所有 $x_i$，从而使每个点都恰好位于一个箱中。\n   - 通过 $b(i) = \\left\\lfloor \\frac{x_i - a}{h} \\right\\rfloor$ 将每个 $x_i$ 映射到其箱索引。\n4. 约束与假设：\n   - 假设 $N \\ge 2$。\n   - 您的实现必须是确定性的，并且不得依赖任何随机化。\n   - 本问题不涉及任何物理单位。\n5. 测试套件：\n   对于每个测试用例，您将得到一个数据集 $\\{x_i\\}$ 和一个箱宽候选集 $\\mathcal{H}$。对于每个测试用例，返回使您的 LOOCV 损失最小化的单个 $h \\in \\mathcal{H}$。\n   - 测试用例 1：\n     - 数据：$[\\,0.1,\\,0.2,\\,0.25,\\,0.9,\\,1.1,\\,1.2,\\,1.25,\\,2.0,\\,2.1,\\,2.2\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.1,\\,0.2,\\,0.5,\\,1.0\\,]$\n   - 测试用例 2：\n     - 数据：$[\\,-1.0,\\,-0.9,\\,-0.9,\\,0.0,\\,0.1,\\,0.1,\\,0.2,\\,1.5,\\,1.6\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.1,\\,0.25,\\,0.5,\\,1.0\\,]$\n   - 测试用例 3：\n     - 数据：$[\\,0.0,\\,0.49,\\,1.01\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.25,\\,0.5,\\,1.0\\,]$\n   - 测试用例 4：\n     - 数据：$[\\,3.0,\\,3.1,\\,3.2,\\,7.8,\\,7.9,\\,8.0,\\,8.1,\\,8.2\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.1,\\,0.2,\\,0.5,\\,1.0,\\,2.0\\,]$\n6. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号括起来的逗号分隔列表。例如，输出必须类似于 $[h_1,h_2,h_3,h_4]$，其中每个 $h_j$ 是为测试用例 $j$ 选择的箱宽，表示为十进制数。\n\n您的程序必须是一个完整的、可运行的实现，它不接受任何输入，并严格按照指定格式打印一行。它必须仅使用标准库和指定的数值库，并完全复现指定的分箱规则。每个测试用例的答案是一个浮点数（所选的 $h$）。", "solution": "目标是为选择直方图密度估计器的箱宽 $h$ 推导一个最小二乘交叉验证 (LSCV) 准则，并实现一个算法从候选集中找到最优的 $h$。\n\n推导从积分平方误差 (ISE) 开始，它衡量了真实密度 $f(x)$ 与直方图估计器 $\\hat{f}_h(x)$ 之间的差异。ISE 定义为：\n$$\nJ(h) = \\text{ISE} = \\int \\left( \\hat{f}_h(x) - f(x) \\right)^2 dx\n$$\n展开平方项，我们得到：\n$$\nJ(h) = \\int \\hat{f}_h(x)^2 dx - 2 \\int \\hat{f}_h(x) f(x) dx + \\int f(x)^2 dx\n$$\n交叉验证的目标是找到使 $J(h)$ 最小化的 $h$ 值。项 $\\int f(x)^2 dx$ 相对于 $h$ 是一个常数，在最小化过程中可以忽略。我们剩下需要最小化的是风险函数 $R(h)$：\n$$\nR(h) = \\int \\hat{f}_h(x)^2 dx - 2 \\int \\hat{f}_h(x) f(x) dx\n$$\n挑战在于 $R(h)$ 仍然依赖于未知的密度 $f(x)$。留一法交叉验证 (LOOCV) 方法通过用其留一法估计替换期望项 $\\mathbb{E}[\\hat{f}_h(X)] = \\int \\hat{f}_h(x) f(x) dx$，为 $R(h)$ 提供了一个近似无偏的估计。这涉及到对每个被排除的点 $x_i$ 上的留一法估计器 $\\hat{f}_{-i,h}(x)$ 的值进行平均。因此，我们记为 $L(h)$ 的 LSCV 目标函数是：\n$$\nL(h) = \\int \\hat{f}_h(x)^2 dx - \\frac{2}{N} \\sum_{i=1}^N \\hat{f}_{-i,h}(x_i)\n$$\n现在我们使用提供的分箱方案来推导 $L(h)$ 中两项的表达式。设箱的集合为 $\\{B_k\\}$，箱 $B_k$ 中数据点的数量为 $n_k$。数据点总数为 $N = \\sum_k n_k$。对于任何 $x \\in B_k$，直方图估计器定义为 $\\hat{f}_h(x) = \\frac{n_k}{Nh}$。每个箱的宽度为 $h$。\n\n第一项 $\\int \\hat{f}_h(x)^2 dx$ 是估计器的积分平方值。由于估计器是分段常数，我们可以将该积分写为所有箱上的总和：\n$$\n\\int \\hat{f}_h(x)^2 dx = \\sum_k \\int_{B_k} \\left( \\frac{n_k}{Nh} \\right)^2 dx = \\sum_k \\left( \\frac{n_k}{Nh} \\right)^2 \\cdot (\\text{$B_k$ 的宽度}) = \\sum_k \\frac{n_k^2}{N^2 h^2} h = \\frac{1}{N^2 h} \\sum_k n_k^2\n$$\n\n第二项涉及留一法估计器 $\\hat{f}_{-i,h}(x_i)$。该估计器是根据大小为 $N-1$ 的数据集（除 $x_i$ 外的所有点）构建的，但使用与全样本估计器 $\\hat{f}_h(x)$ 相同的分箱网格。设 $x_i$ 是箱 $B_{k_i}$ 中的一个点。对于完整数据集，此箱中的点数为 $n_{k_i}$。对于留一法估计器 $\\hat{f}_{-i,h}$，总点数为 $N-1$，而箱 $B_{k_i}$ 中的点数为 $n_{k_i}-1$。因此，估计器在 $x_i$ 处的值为：\n$$\n\\hat{f}_{-i,h}(x_i) = \\frac{\\text{箱 $B_{k_i}$ 中的计数（不含 } x_i)}{\\text{（不含 } x_i \\text{ 的总点数）} \\times h} = \\frac{n_{k_i} - 1}{(N-1)h}\n$$\n我们将此量对所有 $i=1, \\dots, N$ 求和：\n$$\n\\sum_{i=1}^N \\hat{f}_{-i,h}(x_i) = \\sum_{i=1}^N \\frac{n_{k_i} - 1}{(N-1)h}\n$$\n这个和可以按箱重新分组。对于每个箱 $B_k$，有 $n_k$ 个点，对于这些点中的每一个，该项为 $\\frac{n_k - 1}{(N-1)h}$。所以，和变为：\n$$\n\\sum_{i=1}^N \\hat{f}_{-i,h}(x_i) = \\sum_k n_k \\left( \\frac{n_k - 1}{(N-1)h} \\right) = \\frac{1}{(N-1)h} \\sum_k (n_k^2 - n_k)\n$$\n\n现在我们将这两个推导出的表达式代回目标函数 $L(h)$：\n$$\nL(h) = \\frac{1}{N^2 h} \\sum_k n_k^2 - \\frac{2}{N} \\left( \\frac{1}{(N-1)h} \\sum_k (n_k^2 - n_k) \\right)\n$$\n提出公因式并使用 $\\sum_k n_k = N$：\n$$\nL(h) = \\frac{1}{h} \\left[ \\frac{1}{N^2} \\sum_k n_k^2 - \\frac{2}{N(N-1)} \\left( \\sum_k n_k^2 - \\sum_k n_k \\right) \\right]\n$$\n$$\nL(h) = \\frac{1}{h} \\left[ \\frac{1}{N^2} \\sum_k n_k^2 - \\frac{2}{N(N-1)} \\left( \\sum_k n_k^2 - N \\right) \\right]\n$$\n$$\nL(h) = \\frac{1}{h} \\left[ \\left(\\frac{1}{N^2} - \\frac{2}{N(N-1)}\\right) \\sum_k n_k^2 + \\frac{2N}{N(N-1)} \\right]\n$$\n合并 $\\sum_k n_k^2$ 的系数：\n$$\n\\frac{1}{N^2} - \\frac{2}{N(N-1)} = \\frac{N-1 - 2N}{N^2(N-1)} = \\frac{-(N+1)}{N^2(N-1)}\n$$\n将其代回，我们得到：\n$$\nL(h) = \\frac{1}{h} \\left[ \\frac{-(N+1)}{N^2(N-1)} \\sum_k n_k^2 + \\frac{2}{N-1} \\right]\n$$\n将第二项乘以 $N^2/N^2$ 以获得公分母，得到 LSCV 损失函数的最终表达式：\n$$\nL(h) = \\frac{2N - (N+1)\\sum_k n_k^2 / N}{N(N-1)h}\n$$\n一个更简单的形式用于最小化（忽略常数分母并反转符号）是：\n$$\nL_{cv}(h) = \\frac{2}{ (N-1)h } - \\frac{N+1}{ N(N-1)h } \\sum_k \\left(\\frac{n_k}{N}\\right)^2\n$$\n然而，为了与实现匹配，我们将使用一个只依赖于 $N$, $h$, 和 $\\sum_k n_k^2$ 的形式。从我们之前的步骤：\n$$\nL(h) = \\frac{2N^2 - (N+1)\\sum_k n_k^2}{N^2(N-1)h}\n$$\n该表达式仅依赖于样本大小 $N$、箱宽 $h$ 以及由 $h$ 产生的箱计数 $\\{n_k\\}$。\n\n算法流程是遍历集合 $\\mathcal{H}$ 中的每个候选箱宽 $h$。对于每个 $h$，我们执行以下步骤：\n1. 计算分箱锚点 $a = \\lfloor \\frac{\\min_i x_i}{h} \\rfloor h$。\n2. 对于每个数据点 $x_i$，确定其箱索引 $b(i) = \\lfloor \\frac{x_i - a}{h} \\rfloor$。\n3. 通过计算每个唯一箱索引的出现次数来计算箱计数 $\\{n_k\\}$。\n4. 计算计数的平方和 $\\sum_k n_k^2$。\n5. 使用推导出的公式评估损失 $L(h)$。\n6. 最优的 $h$ 是导致 $L(h)$ 值最小的那个。如果出现平局，则选择最小的 $h$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LSCV problem for histogram density estimation across multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([0.1, 0.2, 0.25, 0.9, 1.1, 1.2, 1.25, 2.0, 2.1, 2.2]), [0.1, 0.2, 0.5, 1.0]),\n        (np.array([-1.0, -0.9, -0.9, 0.0, 0.1, 0.1, 0.2, 1.5, 1.6]), [0.1, 0.25, 0.5, 1.0]),\n        (np.array([0.0, 0.49, 1.01]), [0.25, 0.5, 1.0]),\n        (np.array([3.0, 3.1, 3.2, 7.8, 7.9, 8.0, 8.1, 8.2]), [0.1, 0.2, 0.5, 1.0, 2.0]),\n    ]\n\n    results = []\n    for data, candidates in test_cases:\n        N = data.shape[0]\n        min_loss = float('inf')\n        best_h = -1.0\n\n        # Iterate through each candidate bin width\n        for h in candidates:\n            # 1. Calculate the binning anchor\n            min_x = np.min(data)\n            a = np.floor(min_x / h) * h\n\n            # 2. Determine bin index for each data point\n            bin_indices = np.floor((data - a) / h)\n\n            # 3. Compute bin counts\n            # np.unique returns unique elements and their counts\n            _, counts = np.unique(bin_indices, return_counts=True)\n\n            # 4. Calculate the sum of squared counts\n            sum_nk_sq = np.sum(np.power(counts, 2))\n\n            # 5. Evaluate the LSCV loss L(h) using the derived formula\n            # L(h) = (2*N^2 - (N+1)*sum(n_k^2)) / (N^2*(N-1)*h)\n            # This is proportional to (2 - (N+1)/N^2 * sum(n_k^2)) / h\n            # The case N=1 is not possible due to problem constraints (N=2).\n            numerator = 2 * N - (N + 1) * sum_nk_sq / N\n            denominator = (N - 1) * h\n            loss = ( (1 / (N*N*h)) * sum_nk_sq ) - (2/(N*(N-1)*h)) * (sum_nk_sq - N)\n\n\n            # 6. Track the h that minimizes the loss\n            # The candidate list is sorted, so the first h to achieve the\n            # minimum will be the smallest one.\n            if loss  min_loss:\n                min_loss = loss\n                best_h = h\n        \n        results.append(best_h)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510284"}, {"introduction": "直方图不仅仅是一个视觉摘要，它的每个箱都代表一个遵循泊松（Poisson）统计的测量结果。一个常见的做法是为计数值为 $N$ 的箱指定一个大小为 $\\sqrt{N}$ 的对称误差棒，但理解这种近似的局限性至关重要。本练习 [@problem_id:3510291] 让你通过计算来探索这种方法的频率覆盖性质，并确定在何种计数范围内，这种误差棒的统计意义是可靠的。", "problem": "在计算高能物理学中，直方图中的分箱事件计数被建模为来自泊松过程的抽样。令 $N \\sim \\mathrm{Poisson}(\\lambda)$ 表示单个直方图分箱中的计数，其固定但未知的平均率 $\\lambda \\in [0,\\infty)$。对计数的统计不确定度的一个常见近似是高斯法则 $\\sigma = \\sqrt{n}$，它被对称地应用于在计数尺度上围绕观测计数值 $n \\in \\{0,1,2,\\dots\\}$ 构建一个区间。当这样的对称误差棒被用作潜在平均率 $\\lambda$ 的近似置信区间时，由于 $N$ 是离散的且 $\\lambda$ 是非负的，频率覆盖率可能会偏离指定名义覆盖率。\n\n定义由高斯法则在平均率尺度上导出的对称区间为\n$$\nI(n; z) = \\left[\\max\\{0,\\, n - z\\sqrt{n}\\},\\; n + z\\sqrt{n}\\right],\n$$\n其中 $z \\ge 0$ 是用于定义名义中心覆盖率的选定标准正态分位数。与 $z$ 相关的名义中心覆盖率为\n$$\nC_0(z) = \\Phi(z) - \\Phi(-z),\n$$\n其中 $\\Phi$ 是标准正态分布的累积分布函数。对于固定的 $\\lambda$，区间法则 $I(\\cdot; z)$ 的频率覆盖率为\n$$\nC(\\lambda; z) = \\sum_{k=0}^{\\infty} \\mathbf{1}\\{\\lambda \\in I(k; z)\\} \\, \\Pr(N=k \\mid \\lambda),\n$$\n其中 $\\Pr(N=k \\mid \\lambda) = e^{-\\lambda} \\lambda^k/k!$ 且 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n你需要确定在哪个计数范围内，使用 $\\sigma=\\sqrt{n}$ 的高斯近似所实现的覆盖误差小于指定的容差。对于给定的容差参数 $\\epsilon0$ 和指定的误差度量类型，将 $\\lambda$ 处的覆盖误差定义为绝对误差\n$$\nE_{\\mathrm{abs}}(\\lambda; z) = \\left|C(\\lambda; z) - C_0(z)\\right|\n$$\n或相对误差\n$$\nE_{\\mathrm{rel}}(\\lambda; z) = \\frac{\\left|C(\\lambda; z) - C_0(z)\\right|}{C_0(z)}.\n$$\n对于 $[0,\\Lambda_{\\max}]$ 上具有均匀步长 $\\Delta\\lambda$ 的给定网格 $\\{\\lambda_j\\}$，将最小阈值计数 $n_{\\min}$ 定义为满足以下条件的最小整数：对于所有网格点 $\\lambda_j \\ge n_{\\min}$，所选误差 $E(\\lambda_j; z)$ 小于或等于 $\\epsilon$。\n\n从上述基本定义出发，且不使用任何预先制表的近似值，编写一个程序，该程序：\n- 通过对所有满足 $\\lambda \\in I(k; z)$ 的 $k \\in \\{0,1,2,\\dots\\}$ 求和泊松概率质量函数来计算 $C(\\lambda; z)$，并对无穷级数进行有数学依据的截断，以保证截断后的余项可忽略不计。\n- 从第一性原理出发计算名义中心正态覆盖率 $C_0(z)$。\n- 在均匀网格 $\\{\\lambda_j\\}_{j=0}^{J}$（其中 $\\lambda_0 = 0$，$\\lambda_J = \\Lambda_{\\max}$ 且 $\\lambda_{j+1} - \\lambda_j = \\Delta\\lambda$）上评估 $E_{\\mathrm{abs}}$ 或 $E_{\\mathrm{rel}}$。\n- 找到最小整数 $n_{\\min}$，使得对于每个网格点 $\\lambda_j \\ge n_{\\min}$，误差小于或等于 $\\epsilon$。如果在扫描范围内不存在这样的整数，则返回 $-1$。\n\n你的实现必须避免任何外部输入，并且必须使用以下参数值测试套件：\n- 测试用例1（一般情况）：$z = 1.0$，相对误差，$\\epsilon = 0.10$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n- 测试用例2（更严容差）：$z = 1.0$，相对误差，$\\epsilon = 0.05$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n- 测试用例3（更宽区间）：$z = 2.0$，相对误差，$\\epsilon = 0.10$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n- 测试用例4（绝对误差）：$z = 1.0$，绝对误差，$\\epsilon = 0.02$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n\n你的程序应生成单行输出，其中包含四个阈值 $[n_{\\min}^{(1)}, n_{\\min}^{(2)}, n_{\\min}^{(3)}, n_{\\min}^{(4)}]$，以逗号分隔的列表形式并用方括号括起来，对应于按上述顺序列出的四个测试用例。所有值都必须是整数。不涉及物理单位。不涉及角度。所有容差均按要求指定为小数。算法必须以纯粹的数学和逻辑术语表达，并且必须易于理解并能在任何现代编程语言中实现；你必须严格按照指定的单行格式输出结果。", "solution": "该问题是有效的。它提出了一个定义明确的计算任务，该任务基于实验高能物理的统计方法。所有参数和定义都清晰、一致且科学合理。\n\n### 基于原理的解决方案设计\n\n核心任务是找到最小整数计数阈值 $n_{\\min}$，当计数值高于该阈值时，用于泊松均值 $\\lambda$ 的对称高斯启发式置信区间能达到指定的覆盖准确度水平。该算法分四个主要阶段进行：(1) 计算名义覆盖率 $C_0(z)$，(2) 在 $\\lambda$ 值的网格上计算实际频率覆盖率 $C(\\lambda; z)$，(3) 评估覆盖误差，以及 (4) 搜索阈值 $n_{\\min}$。\n\n#### 1. 名义覆盖率计算\n\n名义中心覆盖率 $C_0(z)$ 定义为标准正态分布在 $-z$ 和 $z$ 之间的曲线下面积。\n$$\nC_0(z) = \\Phi(z) - \\Phi(-z)\n$$\n其中 $\\Phi$ 是标准正态分布的累积分布函数 (CDF)。标准正态CDF可以用误差函数 $\\mathrm{erf}(x)$ 来表示，该函数在科学计算库中广泛可用。其关系为 $\\Phi(x) = \\frac{1}{2}\\left(1 + \\mathrm{erf}(x/\\sqrt{2})\\right)$。将此代入 $C_0(z)$ 的定义，并利用 $\\mathrm{erf}(-x) = -\\mathrm{erf}(x)$ 的性质，我们得到一个直接的公式：\n$$\nC_0(z) = \\frac{1}{2}\\left(1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right) - \\frac{1}{2}\\left(1 + \\mathrm{erf}\\left(\\frac{-z}{\\sqrt{2}}\\right)\\right) = \\frac{1}{2}\\left(\\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right) - \\mathrm{erf}\\left(\\frac{-z}{\\sqrt{2}}\\right)\\right) = \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\n$$\n该公式提供了一种从第一性原理出发，以数值稳定且高效的方式计算 $C_0(z)$ 的方法。\n\n#### 2. 频率覆盖率计算\n\n对于给定的平均率 $\\lambda$，频率覆盖率 $C(\\lambda; z)$ 是指随机区间 $I(N; z)$ 包含 $\\lambda$ 的概率。这是通过将所有观测计数 $k$ 的概率相加来计算的，其中相应的区间 $I(k; z)$ “覆盖”了 $\\lambda$。\n$$\nC(\\lambda; z) = \\sum_{k=0}^{\\infty} \\mathbf{1}\\{\\lambda \\in I(k; z)\\} \\, \\Pr(N=k \\mid \\lambda)\n$$\n问题描述中提到了截断一个无穷级数。然而，对于任何给定的 $\\lambda \\ge 0$，使得指示函数 $\\mathbf{1}\\{\\lambda \\in I(k; z)\\}$ 非零的整数 $k$ 的集合是有限的。我们可以确定求和的精确整数范围，从而避免任何由截断引起的近似。\n\n条件 $\\lambda \\in I(k; z)$ 等价于以下不等式组：\n$$\n\\max\\{0, k - z\\sqrt{k}\\} \\le \\lambda \\le k + z\\sqrt{k}\n$$\n对于 $\\lambda  0$，这可以简化为关于 $k$ 的一对不等式。通过令 $y = \\sqrt{k}$（因此 $y \\ge 0$），该不等式变为关于 $y$ 的二次不等式：\n1. $y^2 - zy - \\lambda \\le 0$\n2. $y^2 + zy - \\lambda \\ge 0$\n\n求解相应二次等式的根，并分析 $y = \\sqrt{k} \\ge 0$ 的不等式，可以得出 $\\sqrt{k}$ 的解范围：\n$$\n\\frac{-z + \\sqrt{z^2 + 4\\lambda}}{2} \\le \\sqrt{k} \\le \\frac{z + \\sqrt{z^2 + 4\\lambda}}{2}\n$$\n将这些界限平方，得到 $k$ 的范围：\n$$\nk_{\\min}(\\lambda, z) \\le k \\le k_{\\max}(\\lambda, z)\n$$\n其中 $k_{\\min}(\\lambda, z) = \\left(\\frac{-z + \\sqrt{z^2 + 4\\lambda}}{2}\\right)^2$ 且 $k_{\\max}(\\lambda, z) = \\left(\\frac{z + \\sqrt{z^2 + 4\\lambda}}{2}\\right)^2$。\n因此，求和是对所有满足 $\\lceil k_{\\min}(\\lambda, z) \\rceil \\le k \\le \\lfloor k_{\\max}(\\lambda, z) \\rfloor$ 的整数 $k$ 进行的。对于任何 $\\lambda  0$，这个范围是有限的。如果 $\\lceil k_{\\min} \\rceil  \\lfloor k_{\\max} \\rfloor$，则和为空，且 $C(\\lambda, z) = 0$。\n\n对于特殊情况 $\\lambda = 0$，覆盖条件 $0 \\in I(k; z)$ 简化为 $\\max\\{0, k - z\\sqrt{k}\\} = 0$，当且仅当 $k - z\\sqrt{k} \\le 0$（即 $k \\le z^2$）时成立。对于 $\\lambda=0$，泊松和中唯一的非零项是 $\\Pr(N=0 \\mid \\lambda=0) = 1$。由于 $k=0$ 总是满足 $k \\le z^2$（因为 $z \\ge 0$），区间 $I(0;z)=[0,0]$ 覆盖了 $\\lambda=0$，因此 $C(0;z) = 1$。\n\n该算法通过在确定的整数范围 $[\\lceil k_{\\min} \\rceil, \\lfloor k_{\\max} \\rfloor]$ 上迭代，并对泊松概率 $\\Pr(N=k \\mid \\lambda) = e^{-\\lambda}\\lambda^k/k!$ 求和来计算 $C(\\lambda; z)$，这些概率是使用数值稳定的库函数计算的。\n\n#### 3. 误差评估\n\n对于网格 $\\{\\lambda_j\\}$ 上的每个点，利用 $C_0(z)$ 和 $C(\\lambda_j; z)$，按指定方式计算误差：\n- 绝对误差: $E_{\\mathrm{abs}}(\\lambda_j; z) = |C(\\lambda_j; z) - C_0(z)|$\n- 相对误差: $E_{\\mathrm{rel}}(\\lambda_j; z) = |C(\\lambda_j; z) - C_0(z)| / C_0(z)$\n\n这将生成一个误差值数组，网格上的每个点 $\\lambda_j$ 对应一个值。\n\n#### 4. 阈值 $n_{\\min}$ 的确定\n\n最后一步是找到最小整数 $n_{\\min}$，使得对于每个网格点 $\\lambda_j \\ge n_{\\min}$，误差 $E(\\lambda_j; z)$ 不超过容差 $\\epsilon$。一个直接而高效的方法是从 $\\lambda$ 网格的末端开始反向搜索。\n\n1.  我们在网格上确定使误差条件 $E(\\lambda_{\\text{fail}}; z) \\le \\epsilon$ 不被满足的最大值，称之为 $\\lambda_{\\text{fail}}$。这可以通过反向遍历计算出的误差数组来找到。\n2.  如果不存在这样的 $\\lambda_{\\text{fail}}$（即所有 $\\lambda_j$ 的误差都在容差范围内），则该条件对所有 $\\lambda_j \\ge 0$ 都成立，最小整数阈值为 $n_{\\min} = 0$。\n3.  如果找到了这样的 $\\lambda_{\\text{fail}}$，任何有效的整数阈值 $n_{\\min}$ 都必须严格大于 $\\lambda_{\\text{fail}}$，以确保所有后续的网格点 $\\lambda_j \\ge n_{\\min}$ 都满足误差标准。满足此条件的最小整数是 $n_{\\min} = \\lfloor \\lambda_{\\text{fail}} \\rfloor + 1$。\n4.  最后，我们检查计算出的 $n_{\\min}$ 是否在扫描范围 $\\Lambda_{\\max}$ 之内。如果 $n_{\\min}  \\lfloor \\Lambda_{\\max} \\rfloor$，则意味着在指定的整数范围内不存在满足条件的阈值，结果为 $-1$。否则，计算出的 $n_{\\min}$ 就是答案。\n\n这种结构化方法通过严格遵守定义来确保正确性，并采用高效的搜索算法来找到最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Solves for the minimal threshold count n_min for four test cases.\n    \"\"\"\n    test_cases = [\n        # z, error_type, epsilon, Lambda_max, delta_lambda\n        (1.0, 'relative', 0.10, 200.0, 0.05),\n        (1.0, 'relative', 0.05, 200.0, 0.05),\n        (2.0, 'relative', 0.10, 200.0, 0.05),\n        (1.0, 'absolute', 0.02, 200.0, 0.05),\n    ]\n\n    results = []\n\n    for z, error_type, epsilon, Lambda_max, delta_lambda in test_cases:\n        # Step 1: Compute nominal coverage C_0(z)\n        # C_0(z) = Phi(z) - Phi(-z) = erf(z / sqrt(2))\n        c0 = erf(z / np.sqrt(2))\n\n        # Step 2: Set up the lambda grid and calculate coverage errors\n        num_points = int(round(Lambda_max / delta_lambda)) + 1\n        lambdas = np.linspace(0.0, Lambda_max, num_points)\n        errors = np.zeros_like(lambdas)\n\n        for i, lambda_val in enumerate(lambdas):\n            # Step 2a: Compute frequentist coverage C(lambda, z)\n            if lambda_val == 0.0:\n                # For lambda=0, P(N=0)=1. The interval I(0;z)=[0,0] covers lambda=0.\n                # For k0, P(N=k)=0. So C(0,z) = 1.\n                c_lambda_z = 1.0\n            else:\n                # For lambda  0, find the finite range of k for the sum.\n                # The condition is k - z*sqrt(k) = lambda = k + z*sqrt(k).\n                # This defines a range [k_min, k_max].\n                sqrt_term = np.sqrt(z**2 + 4 * lambda_val)\n                k_min_val = ((-z + sqrt_term) / 2)**2\n                k_max_val = ((z + sqrt_term) / 2)**2\n                \n                k_start = int(np.ceil(k_min_val))\n                k_end = int(np.floor(k_max_val))\n\n                if k_start  k_end:\n                    c_lambda_z = 0.0\n                else:\n                    k_range = np.arange(k_start, k_end + 1)\n                    # Sum Poisson probabilities over the determined range of k\n                    pmf_values = poisson.pmf(k_range, mu=lambda_val)\n                    c_lambda_z = np.sum(pmf_values)\n\n            # Step 2b: Compute the error E(lambda, z)\n            if error_type == 'absolute':\n                error = np.abs(c_lambda_z - c0)\n            else:  # 'relative'\n                # Avoid division by zero if c0 is zero, though not possible for z0\n                error = np.abs(c_lambda_z - c0) / c0 if c0 != 0 else 0.0\n            \n            errors[i] = error\n\n        # Step 3: Find the minimal threshold count n_min\n        # Find the index of the last lambda value where the error exceeds the tolerance.\n        last_bad_idx = -1\n        # Search backwards from the end of the grid.\n        for i in range(len(lambdas) - 1, -1, -1):\n            if errors[i]  epsilon:\n                last_bad_idx = i\n                break\n        \n        if last_bad_idx == -1:\n            # If no lambda value has an error  epsilon, the condition holds for all lambda = 0.\n            n_min = 0\n        else:\n            # The condition is violated up to lambda_fail = lambdas[last_bad_idx].\n            # n_min must be an integer  lambda_fail.\n            lambda_fail = lambdas[last_bad_idx]\n            n_min = int(np.floor(lambda_fail)) + 1\n        \n        # If the required n_min is outside the scanned range, no solution exists.\n        if n_min  int(Lambda_max):\n            results.append(-1)\n        else:\n            results.append(n_min)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510291"}]}