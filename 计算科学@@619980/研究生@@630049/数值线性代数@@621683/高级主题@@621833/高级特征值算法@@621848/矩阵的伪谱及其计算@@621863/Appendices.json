{"hands_on_practices": [{"introduction": "本练习将指导你构建计算伪谱的基础算法。通过在复平面上的一个矩形网格上系统地计算矩阵 $A - zI$ 的最小奇异值，我们可以绘制出一个“地形图”，其等高线即为伪谱的边界。这个实践旨在将伪譜的定义转化为一个具体的计算过程，是后续更高级分析的基石。[@problem_id:3568796]", "problem": "设 $A \\in \\mathbb{C}^{n \\times n}$ 是一个方阵，$I$ 是单位矩阵，$z \\in \\mathbb{C}$ 是一个复变量。$A - zI$ 的最小奇异值，记作 $\\sigma_{\\min}(A - zI)$，是研究伪谱的核心量。$A$ 的 $\\varepsilon$-伪谱定义为满足 $\\sigma_{\\min}(A - zI) \\le \\varepsilon$ 的点集 $z \\in \\mathbb{C}$。奇异值源于奇异值分解 (SVD)。对于矩阵 $B \\in \\mathbb{C}^{n \\times n}$，SVD 将其分解为 $B = U \\Sigma V^*$，其中 $U, V$ 是酉矩阵，$\\Sigma$ 是对角元为非负的对角矩阵 $\\sigma_1(B) \\ge \\sigma_2(B) \\ge \\cdots \\ge \\sigma_n(B) \\ge 0$。\n\n从这些定义出发，设计并实现一个算法，该算法能够：\n- 在复平面中构建一个由实数边界 $x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}$ 和整数分辨率 $N_x, N_y$ 定义的矩形网格；\n- 对每个网格点 $z = x + \\mathrm{i} y$，使用奇异值分解 (SVD) 计算 $\\sigma_{\\min}(A - zI)$；\n- 将计算出的 $\\sigma_{\\min}(A - zI)$ 值组装成一个与网格对应的二维数组；以及\n- 针对 $n$ 和总网格点数 $G := N_x N_y$，提供清晰的计算复杂度分析，并讨论在尊重不同 $z$ 值计算独立性的前提下的并行化机会。\n\n您的程序必须计算并返回以下测试套件的具体量化结果。为避免歧义，每个矩阵、边界和网格分辨率都被明确指定，所有要求的数值输出也已说明。此问题不涉及任何物理单位或角度。\n\n测试套件：\n1. 顺利路径非正规情况。设 $A_1 \\in \\mathbb{C}^{5 \\times 5}$ 为幂零 Jordan 块，\n$$\nA_1 = \\begin{bmatrix}\n0  1  0  0  0 \\\\\n0  0  1  0  0 \\\\\n0  0  0  1  0 \\\\\n0  0  0  0  1 \\\\\n0  0  0  0  0\n\\end{bmatrix}.\n$$\n使用一个矩形网格，其参数为 $x_{\\min} = -0.1$, $x_{\\max} = 0.1$, $y_{\\min} = -0.1$, $y_{\\max} = 0.1$, $N_x = 11$, $N_y = 11$。计算整个网格上 $\\sigma_{\\min}(A_1 - zI)$ 的最小值，并将其作为浮点数返回。\n\n2. 正规矩阵一致性检验。设 $A_2 \\in \\mathbb{C}^{4 \\times 4}$ 是对角矩阵，\n$$\nA_2 = \\mathrm{diag}(1,\\,2,\\,3,\\,4).\n$$\n考虑单点网格 $x_{\\min} = x_{\\max} = 2.5$, $y_{\\min} = y_{\\max} = 0$, $N_x = 1$, $N_y = 1$，因此 $z = 2.5$。使用 SVD 计算 $\\sigma_{\\min}(A_2 - zI)$ 并作为浮点数返回。独立地，使用 $A_2$ 的特征值计算量 $d := \\min_{i} |\\lambda_i(A_2) - z|$。返回绝对差 $|\\sigma_{\\min}(A_2 - zI) - d|$ 作为浮点数。\n\n3. 复杂度计算（SVD 调用次数）。设\n$$\nA_3 = \\begin{bmatrix}\n5  1  0 \\\\\n0  -1  1 \\\\\n0  0  2\n\\end{bmatrix} \\in \\mathbb{C}^{3 \\times 3}.\n$$\n使用一个矩形网格，其参数为 $x_{\\min} = -2$, $x_{\\max} = 2$, $y_{\\min} = -1$, $y_{\\max} = 1$, $N_x = 17$, $N_y = 19$。返回您的算法在整个网格上评估 $\\sigma_{\\min}(A_3 - zI)$ 所执行的 SVD 计算的整数次数。该值必须等于总网格点数 $G = N_x N_y$。\n\n4. 理想并行加速比。对于测试用例 3 中的网格，假设一个并行执行模型，有 $p = 8$ 个相同的处理器且开销可忽略不计，其中在每个网格点评估 $\\sigma_{\\min}(A - zI)$ 都是一个独立的任务。在完美负载均衡的情况下，相对于串行执行，理想加速比定义为 $S = \\min(G, p)$。返回 $S$ 作为整数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，以逗号分隔的列表形式，并用方括号括起来，顺序如上所述。例如，它应打印\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\n所有四个条目都必须是指定的类型：前两个是浮点数，第三个是整数，第四个是整数。", "solution": "该问题已经过验证，被认为是定义明确、有科学依据且自成体系的。它提出了数值线性代数中的一个标准任务——在复平面的网格上计算最小奇异值，以绘制矩阵的伪谱。所有的定义、矩阵和参数都得到了明确无误的陈述。因此，我们可以进行形式化的求解。\n\n**算法设计**\n\n该算法的核心是在一个离散的复数集合上进行系统性评估。\n\n1.  **网格构建**：在复平面中构建一个矩形点网格。网格点的实部 $x_j$ 是从 $x_{\\min}$ 到 $x_{\\max}$ 的 $N_x$ 个点的等差数列。类似地，虚部 $y_k$ 是从 $y_{\\min}$ 到 $y_{\\max}$ 的 $N_y$ 个点。这可以通过使用线性间隔数组来实现。网格点 $z_{jk}$ 由 $z_{jk} = x_j + \\mathrm{i} y_k$ 给出，其中 $j \\in \\{1, \\dots, N_x\\}$ 且 $k \\in \\{1, \\dots, N_y\\}$。网格中的总点数为 $G = N_x N_y$。\n\n2.  **迭代计算**：算法遍历 $G$ 个网格点中的每一个。对每个 $z = z_{jk}$，执行以下步骤：\n    a. 构造矩阵 $B(z) = A - zI$，其中 $I$ 是 $n \\times n$ 的单位矩阵。这是一个简单的矩阵减法运算。\n    b. 计算 $B(z)$ 的奇异值分解 (SVD)。SVD 提供分解式 $B(z) = U \\Sigma V^*$，其中 $U$ 和 $V$ 是酉矩阵，$\\Sigma$ 是一个对角矩阵，其对角线上包含奇异值 $\\sigma_i$，通常按非递增顺序排序：$\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_n \\ge 0$。\n    c. 提取最小奇异值 $\\sigma_{\\min}(B(z)) = \\sigma_n(B(z))$。在计算上，这通常是标准 SVD 库函数返回的奇异值数组的最后一个元素。为提高效率，应使用只计算奇异值而不计算酉矩阵 $U$ 和 $V$ 的 SVD 算法变体，因为后者在此问题中并非必需。\n\n3.  **数据组装**：将计算出的 $\\sigma_{\\min}(A - z_{jk}I)$ 值存储在一个大小为 $N_y \\times N_x$ 的二维数组中，记为 $\\mathcal{S}$。元素 $\\mathcal{S}_{k,j}$ 对应于在 $z_{jk} = x_j + \\mathrm{i} y_k$ 处计算的值。该矩阵 $\\mathcal{S}$ 表示函数 $f(z) = \\sigma_{\\min}(A - zI)$ 在指定域上的分布情况。\n\n**计算复杂度分析**\n\n该算法的主要计算成本是重复计算 SVD。\n- 计算一个通用的 $n \\times n$ 矩阵的 SVD 的复杂度是 $O(n^3)$。\n- 对于网格中的 $G = N_x N_y$ 个点，每个点都执行一次此计算。\n- 因此，该算法的总计算复杂度为 $O(G \\cdot n^3) = O(N_x N_y n^3)$。对于不小的 $n$，网格生成和矩阵减法（每个点 $O(n^2)$）的成本与 SVD 成本相比可以忽略不计。\n\n**并行化机会**\n\n一个关键的观察是，对于一个网格点 $z_1$ 计算 $\\sigma_{\\min}(A - z_1 I)$ 与对于任何其他网格点 $z_2$ 计算 $\\sigma_{\\min}(A - z_2 I)$ 是完全独立的。这一特性使该问题成为“易并行”问题。\n\n在一个具有 $p$ 个相同处理器且通信开销为零的理想并行执行模型中，这 $G$ 个独立任务（每个网格点一次 SVD）可以分配给这些处理器。\n- 总工作量与 $G$ 成正比。\n- 在完美负载均衡的情况下，使用 $p$ 个处理器完成任务所需的时间将与 $\\lceil G/p \\rceil$ 成正比。\n- 理想加速比 $S$ 是串行执行时间与并行执行时间之比。如果 $p \\le G$，加速比约等于 $p$。如果 $p > G$，我们无法使用比任务数量更多的处理器，因此加速比受限于 $G$。这就导出了问题中给出的理想加速比的简化公式：$S = \\min(G, p)$。\n\n**应用于测试套件**\n\n1.  **测试用例 1**：对于矩阵 $A_1$（一个 $5 \\times 5$ 的幂零 Jordan 块），在 $[-0.1, 0.1] \\times [-0.1, 0.1]$ 上的 $11 \\times 11$ 网格中，我们必须找到最小的 $\\sigma_{\\min}$ 值。网格生成包含点 $z=0 + 0\\mathrm{i}$。在此点，我们计算 $\\sigma_{\\min}(A_1 - 0 \\cdot I) = \\sigma_{\\min}(A_1)$。矩阵 $A_1$ 是奇异的（例如，其最后一行全是零），而一个矩阵是奇异的当且仅当其最小奇异值为零。因此，$\\sigma_{\\min}(A_1) = 0$。由于奇异值总是非负的，整个网格上的最小值必定是 $0.0$。\n\n2.  **测试用例 2**：矩阵 $A_2=\\mathrm{diag}(1,2,3,4)$ 是一个正规矩阵。正规矩阵的一个基本性质是，对于任何 $z \\in \\mathbb{C}$，有 $\\sigma_{\\min}(A_2 - zI) = \\min_i |\\lambda_i(A_2) - z|$，其中 $\\lambda_i(A_2)$ 是 $A_2$ 的特征值。\n    - $A_2$ 的特征值为 $\\lambda \\in \\{1, 2, 3, 4\\}$。\n    - 网格是单点 $z = 2.5$。\n    - 我们计算 $d = \\min(|1-2.5|, |2-2.5|, |3-2.5|, |4-2.5|) = \\min(1.5, 0.5, 0.5, 1.5) = 0.5$。\n    - 我们也计算 $\\sigma_{\\min}(A_2 - 2.5I)$。该矩阵为 $A_2 - 2.5I = \\mathrm{diag}(-1.5, -0.5, 0.5, 1.5)$。其奇异值是对角元的绝对值，即 $\\{1.5, 0.5, 0.5, 1.5\\}$。最小值为 $0.5$。\n    - 绝对差为 $|\\sigma_{\\min}(A_2 - 2.5I) - d| = |0.5 - 0.5| = 0.0$。\n\n3.  **测试用例 3**：SVD 计算的次数与网格点数 $G$ 相同。对于一个 $N_x=17$ 和 $N_y=19$ 的网格，总点数为 $G = 17 \\times 19 = 323$。\n\n4.  **测试用例 4**：给定来自测试用例 3 的 $G=323$ 个任务和 $p=8$ 个处理器，理想加速比定义为 $S = \\min(G, p)$。因此，$S = \\min(323, 8) = 8$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sigma_min_on_grid(A, x_min, x_max, y_min, y_max, Nx, Ny):\n    \"\"\"\n    Computes the smallest singular value of (A - zI) for each z on a grid.\n\n    Args:\n        A (np.ndarray): The input square matrix.\n        x_min, x_max (float): Bounds for the real part of z.\n        y_min, y_max (float): Bounds for the imaginary part of z.\n        Nx, Ny (int): Number of grid points along real and imaginary axes.\n\n    Returns:\n        np.ndarray: A 2D array of sigma_min values.\n    \"\"\"\n    n = A.shape[0]\n    I = np.eye(n, dtype=complex)\n    \n    # Ensure matrix A is complex for subsequent operations\n    A_complex = A.astype(complex)\n\n    x_vals = np.linspace(x_min, x_max, Nx)\n    y_vals = np.linspace(y_min, y_max, Ny)\n    \n    sigma_min_matrix = np.zeros((Ny, Nx))\n\n    for i, y in enumerate(y_vals):\n        for j, x in enumerate(x_vals):\n            z = x + 1j * y\n            B = A_complex - z * I\n            \n            # compute_uv=False is more efficient as we only need singular values.\n            # Singular values are returned in descending order.\n            s = np.linalg.svd(B, compute_uv=False)\n            sigma_min_matrix[i, j] = s[-1]\n            \n    return sigma_min_matrix\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement.\n    \"\"\"\n    \n    # --- Test Case 1: Happy-path non-normal case ---\n    # Define the 5x5 nilpotent Jordan block A1\n    A1 = np.diag(np.ones(4), k=1)\n    \n    # Grid parameters\n    x_min1, x_max1, y_min1, y_max1 = -0.1, 0.1, -0.1, 0.1\n    Nx1, Ny1 = 11, 11\n    \n    # The grid contains z=0. At z=0, sigma_min(A1-0*I) = sigma_min(A1) = 0\n    # since A1 is singular. As sigma_min is always non-negative, the minimum\n    # value over the grid must be 0. We compute it for rigor.\n    sigma_matrix1 = compute_sigma_min_on_grid(A1, x_min1, x_max1, y_min1, y_max1, Nx1, Ny1)\n    result1 = float(np.min(sigma_matrix1))\n\n    # --- Test Case 2: Normal matrix consistency check ---\n    A2 = np.diag([1, 2, 3, 4])\n    z2 = 2.5 + 0j\n    \n    # Compute sigma_min(A2 - zI) using SVD\n    B2 = A2.astype(complex) - z2 * np.eye(4, dtype=complex)\n    s2 = np.linalg.svd(B2, compute_uv=False)\n    sigma_min_from_svd = s2[-1]\n    \n    # Compute d = min_i |lambda_i(A2) - z|\n    eigenvalues_A2 = np.linalg.eigvals(A2)\n    d = np.min(np.abs(eigenvalues_A2 - z2))\n    \n    result2 = float(np.abs(sigma_min_from_svd - d))\n\n    # --- Test Case 3: Complexity accounting (SVD call count) ---\n    Nx3, Ny3 = 17, 19\n    # The number of SVD calls is the total number of grid points, G = Nx * Ny.\n    result3 = int(Nx3 * Ny3)\n\n    # --- Test Case 4: Ideal parallelization speedup ---\n    # G is the number of tasks from case 3. p is the number of processors.\n    G4 = result3\n    p4 = 8\n    # Ideal speedup S = min(G, p).\n    result4 = int(min(G4, p4))\n\n    # Assemble the final list of results\n    final_results = [result1, result2, result3, result4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3568796"}, {"introduction": "在掌握了基本计算方法后，本练习将其应用于一个著名且重要的例子：Wilkinson多项式的伴随矩阵。这个实践将展示为何伪谱对于理解高度非正规矩阵的特征值敏感性和瞬态行为至关重要。通过分析其伪谱的几何形状，你将揭示出简单特征值分析所忽略的关键信息。[@problem_id:3568831]", "problem": "设 $A \\in \\mathbb{C}^{n \\times n}$ 为 $n=20$ 次首一Wilkinson多项式的弗罗贝尼乌斯（Frobenius）伴随矩阵，该多项式为 $W_{20}(x) = \\prod_{j=1}^{20} (x - j)$，其根为整数 $1,2,\\dots,20$。考虑最小奇异值函数 $z \\mapsto \\sigma_{\\min}(A - z I)$，其中 $I$ 是单位矩阵，$z \\in \\mathbb{C}$。$A$ 在矩阵 $2$-范数下的 $\\varepsilon$-伪谱定义为集合 $\\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\sigma_{\\min}(A - z I) \\le \\varepsilon \\}$。该集合与所有满足 $\\|E\\|_2 \\le \\varepsilon$ 的扰动 $E$ 所对应的矩阵 $A + E$ 的特征值 $z$ 的集合重合。\n\n从奇异值、当 $A - zI$ 可逆时的预解范数 $\\|(A - zI)^{-1}\\|_2$ 以及 $\\varepsilon$-伪谱的基本定义出发，推导一个算法，用于在复平面的矩形网格上计算函数 $\\sigma_{\\min}(A - zI)$ 等高线的离散近似。利用这些等高线，通过其伪谱的几何形状，来推理并量化Wilkinson伴随矩阵特征值的极端敏感性及其非正规性。您的算法必须：\n\n- 构造以 $1,2,\\dots,20$ 为根的首一多项式的弗罗贝尼乌斯伴随矩阵 $A$。\n- 对于每个矩形网格窗口，在每个网格点 $z$ 上计算 $\\sigma_{\\min}(A - zI)$。\n- 对于每个测试用例中给定的阈值 $\\varepsilon$，计算：\n  1. 在网格上达到的 $\\sigma_{\\min}(A - zI)$ 的最小值。\n  2. 属于 $\\Lambda_{\\varepsilon}(A)$ 的网格点比例（以小数形式表示，而非百分比），即那些满足 $\\sigma_{\\min}(A - zI) \\le \\varepsilon$ 的点。\n  3. 满足 $\\sigma_{\\min}(A - zI) \\le \\varepsilon$ 的网格点集合的连通分量数量（在网格图上使用 $4$-邻域连通性），这可作为伪谱水平集连通性的离散代理。如果两个网格点的索引在实轴或虚轴方向上恰好相差一，则认为它们是相邻的。\n\n您的程序必须为以下测试套件实现此算法（每个窗口由实轴和虚轴边界、网格分辨率和 $\\varepsilon$ 指定）：\n\n- 测试用例 $1$（靠近 $8,9,10,11,12$ 的根簇）：\n  - 实轴边界：$[7, 12]$。\n  - 虚轴边界：$[-\\tfrac{3}{2}, \\tfrac{3}{2}]$。\n  - 网格分辨率：$41 \\times 41$ 点。\n  - 阈值：$\\varepsilon = 10^{-6}$。\n\n- 测试用例 $2$（靠近最小根 $1,2,3$ 的根簇）：\n  - 实轴边界：$[\\tfrac{1}{2}, \\tfrac{7}{2}]$。\n  - 虚轴边界：$[-1, 1]$。\n  - 网格分辨率：$41 \\times 41$ 点。\n  - 阈值：$\\varepsilon = 10^{-8}$。\n\n- 测试用例 $3$（围绕两个连续根 $10,11$ 的紧凑窗口）：\n  - 实轴边界：$[\\tfrac{39}{4}, \\tfrac{45}{4}]$。\n  - 虚轴边界：$[-\\tfrac{3}{4}, \\tfrac{3}{4}]$。\n  - 网格分辨率：$41 \\times 41$ 点。\n  - 阈值：$\\varepsilon = 10^{-7}$。\n\n科学真实性约束：\n\n- 所有量均为纯数学量；不适用任何物理单位。\n- 如果出现角度，应以弧度为单位，但本问题中不需要任何角度量。\n\n最终输出规范：\n\n- 您的程序应生成一行输出，其中包含按测试套件顺序汇总的结果。对于每个测试用例，按上述顺序输出三个值：该用例在网格上的最小 $\\sigma_{\\min}$，$\\sigma_{\\min} \\le \\varepsilon$ 的点的比例，以及连通分量的数量。最终输出应为方括号内的一个逗号分隔列表。例如，其形式应为 $[\\text{min}_1,\\text{frac}_1,\\text{comp}_1,\\text{min}_2,\\text{frac}_2,\\text{comp}_2,\\text{min}_3,\\text{frac}_3,\\text{comp}_3]$，其中每个 $\\text{min}_k$ 是一个浮点数，每个 $\\text{frac}_k$ 是一个小数，每个 $\\text{comp}_k$ 是一个整数。", "solution": "该问题要求分析与20次Wilkinson多项式相关的弗罗贝尼乌斯伴随矩阵的伪谱。此分析旨在通过计算来证明这个高度非正规矩阵的特征值的极端敏感性。我们将推导并随后实现一个有效的数值算法。\n\n研究的基本对象是矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的 $\\varepsilon$-伪谱，对于给定的 $\\varepsilon > 0$，其定义为集合\n$$ \\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\|(A - zI)^{-1}\\|_2 \\ge \\varepsilon^{-1} \\}. $$\n此处，$\\| \\cdot \\|_2$ 表示矩阵 $2$-范数（谱范数）。预解范数 $\\|(A - zI)^{-1}\\|_2$ 对所有不属于 $A$ 的谱 $\\Lambda(A)$ 的 $z$ 均有定义。连接预解范数与奇异值的一个关键性质是，对于任意方阵 $M$，$\\|M^{-1}\\|_2 = 1/\\sigma_{\\min}(M)$，其中 $\\sigma_{\\min}(M)$ 是 $M$ 的最小奇异值。这使得伪谱有了一个等价且在计算上更稳定的定义，该定义对所有 $z \\in \\mathbb{C}$ 都有效：\n$$ \\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\sigma_{\\min}(A - zI) \\le \\varepsilon \\}. $$\n该定义包含了特征值本身，对于任何 $\\lambda \\in \\Lambda(A)$，有 $\\sigma_{\\min}(A - \\lambda I) = 0$。函数 $z \\mapsto \\sigma_{\\min}(A - zI)$ 的值在复平面上形成一个曲面，而 $\\varepsilon$-伪谱则由该曲面低于高度 $\\varepsilon$ 的区域构成。\n\n解决该问题的算法步骤如下：\n\n**1. 构造Wilkinson伴随矩阵 $A$**\n\n问题指定了 $n=20$ 次的首一Wilkinson多项式，其根为整数 $1, 2, \\dots, 20$：\n$$ W_{20}(x) = \\prod_{j=1}^{20} (x - j). $$\n我们将此多项式展开为幂基形式：$W_{20}(x) = x^{20} + c_{19} x^{19} + \\dots + c_1 x + c_0$。此多项式的弗罗贝尼乌斯伴随矩阵 $A$ 具有以下形式：\n$$ A = \\begin{pmatrix}\n0  0  \\dots  0  -c_0 \\\\\n1  0  \\dots  0  -c_1 \\\\\n0  1  \\dots  0  -c_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n0  0  \\dots  1  -c_{19}\n\\end{pmatrix} \\in \\mathbb{C}^{20 \\times 20}. $$\n该矩阵 $A$ 的特征多项式恰好是 $W_{20}(x)$，因此其特征值为 $\\lambda_j = j$，其中 $j=1, 2, \\dots, 20$。系数 $c_k$ 可以从根通过数值计算得到。\n\n**2. 在网格上计算 $\\sigma_{\\min}(A-zI)$**\n\n对于每个测试用例，我们在复平面上定义一个具有指定实轴边界 $[x_{\\min}, x_{\\max}]$ 和虚轴边界 $[y_{\\min}, y_{\\max}]$ 的矩形窗口。该窗口被离散化为一个 $N_x \\times N_y$ 点的网格。在此问题中，所有网格的分辨率均为 $41 \\times 41$。\n网格点由 $z_{jk} = x_j + \\mathrm{i}y_k$ 给出，其中\n- $x_j = x_{\\min} + j \\frac{x_{\\max} - x_{\\min}}{N_x - 1}$，对于 $j=0, 1, \\dots, N_x-1$。\n- $y_k = y_{\\min} + k \\frac{y_{\\max} - y_{\\min}}{N_y - 1}$，对于 $k=0, 1, \\dots, N_y-1$。\n\n在每个网格点 $z_{jk}$，我们执行以下步骤：\n- 构造移位矩阵 $M_{jk} = A - z_{jk}I$。\n- 计算 $M_{jk}$ 的奇异值。其中最小的一个即为 $\\sigma_{\\min}(A - z_{jk}I)$。\n- 将此值存储在一个 $N_y \\times N_x$ 的矩阵 $S$ 中，其中 $S_{kj} = \\sigma_{\\min}(A - z_{jk}I)$。\n\n**3. 分析计算得到的伪谱数据**\n\n$\\sigma_{\\min}$ 值的矩阵 $S$ 包含了计算每个测试用例所需量的所有必要信息。\n\n**a. 网格上的最小 $\\sigma_{\\min}$:**\n这可以通过取整个矩阵 $S$ 中的最小值来找到：\n$$ \\sigma_{\\min}^{\\text{grid}} = \\min_{j,k} S_{kj}. $$\n\n**b. 属于 $\\Lambda_{\\varepsilon}(A)$ 的点的比例:**\n对于给定的阈值 $\\varepsilon$，我们识别出属于 $\\varepsilon$-伪谱离散近似的网格点。我们创建一个二元掩码 $B$，其中如果 $S_{kj} \\le \\varepsilon$ 则 $B_{kj}=1$，否则 $B_{kj}=0$。该比例是这类点的数量与总网格点数的比率：\n$$ f_{\\varepsilon} = \\frac{1}{N_x N_y} \\sum_{k=0}^{N_y-1} \\sum_{j=0}^{N_x-1} B_{kj}. $$\n\n**c. 连通分量的数量:**\n这需要将二元掩码 $B$ 视为一个网格图。图的顶点是满足 $B_{kj}=1$ 的网格索引 $(k, j)$。如果两个顶点 $(k, j)$ 和 $(k', j')$ 在网格上基于 $4$-邻域连通性是相邻的，即 $|k-k'| + |j-j'|=1$，则它们之间存在一条边。任务是计算此图中的连通分量数量。\n\n一个有效的算法是遍历网格的每个单元格。如果找到一个 $B_{kj}=1$ 且尚未作为某个分量的一部分被访问过的单元格 $(k,j)$，我们就增加一个分量计数器。然后，我们从 $(k,j)$ 开始启动一个图遍历算法，例如广度优先搜索（BFS）或深度优先搜索（DFS），以找到并标记属于同一分量的所有单元格。重复此过程，直到检查完所有单元格。\n\n- 初始化 `count = 0` 和一个大小为 $N_y \\times N_x$ 的布尔 `visited` 网格，全部设为 `false`。\n- 对于 $k$ 从 $0$ 到 $N_y-1$：\n    - 对于 $j$ 从 $0$ 到 $N_x-1$：\n        - 如果 $B_{kj}=1$ 且 `visited[k,j]` 为 `false`：\n            - 增加 `count`。\n            - 从 $(k,j)$ 开始进行BFS遍历：\n                - 创建一个队列并加入 $(k,j)$。将 `visited[k,j]` 标记为 `true`。\n                - 当队列不为空时：\n                    - 从队列中取出一个单元格 $(r,c)$。\n                    - 对于其 $4$ 个邻居 $(r',c')$ 中的每一个：\n                        - 如果邻居在边界内，$B_{r'c'}=1$，且 `visited[r',c']` 为 `false`：\n                            - 将 `visited[r',c']` 标记为 `true` 并将 $(r',c')$ 加入队列。\n\n遍历完所有单元格后，`count` 将保存连通分量的总数。整个过程应用于问题陈述中指定的三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for pseudospectra analysis.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (cluster of roots near 8,9,10,11,12)\n        {\n            \"real_bounds\": [7.0, 12.0],\n            \"imag_bounds\": [-1.5, 1.5],\n            \"resolution\": (41, 41),\n            \"epsilon\": 1e-6,\n        },\n        # Test case 2 (cluster near smallest roots 1,2,3)\n        {\n            \"real_bounds\": [0.5, 3.5],\n            \"imag_bounds\": [-1.0, 1.0],\n            \"resolution\": (41, 41),\n            \"epsilon\": 1e-8,\n        },\n        # Test case 3 (tight window around two consecutive roots 10,11)\n        {\n            \"real_bounds\": [9.75, 11.25],\n            \"imag_bounds\": [-0.75, 0.75],\n            \"resolution\": (41, 41),\n            \"epsilon\": 1e-7,\n        },\n    ]\n\n    # Pre-compute the companion matrix as it's the same for all cases.\n    n = 20\n    roots = np.arange(1, n + 1, dtype=float)\n    # np.poly gives coefficients of (x-r1)(x-r2)...\n    # For a monic polynomial x^n + c_{n-1}x^{n-1} + ... + c_0,\n    # the coeffs are [1, c_{n-1}, ..., c_0]\n    coeffs = np.poly(roots)\n    # The last column of the companion matrix is [-c_0, -c_1, ..., -c_{n-1}]^T.\n    neg_coeffs = -coeffs[1:][::-1]\n    \n    A = np.diag(np.ones(n - 1), k=-1)\n    A[:, -1] = neg_coeffs\n\n    results = []\n    \n    for case in test_cases:\n        min_sigma, fraction, components = analyze_pseudospectrum(\n            A,\n            case[\"real_bounds\"],\n            case[\"imag_bounds\"],\n            case[\"resolution\"],\n            case[\"epsilon\"],\n        )\n        results.extend([min_sigma, fraction, components])\n\n    # Format the final output string.\n    output_str = f\"[{','.join(f'{val:.8g}' if isinstance(val, float) else str(val) for val in results)}]\"\n    print(output_str)\n\ndef analyze_pseudospectrum(A, real_bounds, imag_bounds, resolution, epsilon):\n    \"\"\"\n    Computes pseudospectral properties for a given matrix A on a specified grid.\n    \"\"\"\n    # 1. Setup grid and evaluate sigma_min\n    nx, ny = resolution\n    x_space = np.linspace(real_bounds[0], real_bounds[1], nx)\n    y_space = np.linspace(imag_bounds[0], imag_bounds[1], ny)\n    \n    sigma_min_grid = np.zeros((ny, nx))\n    identity = np.eye(A.shape[0])\n    \n    for i in range(ny):\n        for j in range(nx):\n            z = x_space[j] + 1j * y_space[i]\n            M = A - z * identity\n            # svdvals returns singular values in descending order. The min is the last.\n            s = svdvals(M)\n            sigma_min_grid[i, j] = s[-1]\n            \n    # 2. Analyze grid data\n    # 2.a. Minimum sigma_min on the grid\n    min_sigma_on_grid = np.min(sigma_min_grid)\n    \n    # 2.b. Fraction of points inside the epsilon-pseudospectrum\n    threshold_mask = sigma_min_grid = epsilon\n    fraction_inside = np.sum(threshold_mask) / (nx * ny)\n    \n    # 2.c. Number of connected components\n    num_components = count_connected_components(threshold_mask)\n    \n    return min_sigma_on_grid, fraction_inside, num_components\n\ndef count_connected_components(mask):\n    \"\"\"\n    Counts connected components in a boolean mask using 4-neighbor connectivity.\n    \"\"\"\n    rows, cols = mask.shape\n    visited = np.zeros_like(mask, dtype=bool)\n    count = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if mask[r, c] and not visited[r, c]:\n                count += 1\n                q = collections.deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        if (0 = next_r  rows and \n                            0 = next_c  cols and \n                            mask[next_r, next_c] and not visited[next_r, next_c]):\n                            visited[next_r, next_c] = True\n                            q.append((next_r, next_c))\n    return count\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3568831"}, {"introduction": "简单的均匀网格法存在一个关键缺陷：我们如何能确定网格足够精细，以捕捉到所有伪谱的细节特征？本练习介绍了一种更高级的自适应算法，它利用 resolvent 范数的对数 $u(z) = \\log \\|(zI - A)^{-1}\\|_{2}$ 是次调和函数这一深刻的数学性质。通过这种方法，我们可以“认证”我们绘制的伪谱图没有遗漏非正规矩阵中常见的细长“指状”结构，从而得到更可靠的可视化结果。[@problem_id:3568841]", "problem": "给定一个矩阵 $A \\in \\mathbb{C}^{n \\times n}$。其 $\\varepsilon$-伪谱 $\\Lambda_{\\varepsilon}(A)$ 定义为\n$$\n\\Lambda_{\\varepsilon}(A) = \\left\\{ z \\in \\mathbb{C} \\;:\\; \\sigma_{\\min}(zI - A) \\le \\varepsilon \\right\\},\n$$\n其中 $\\sigma_{\\min}(zI - A)$ 表示矩阵 $zI - A$ 的最小奇异值，$I$ 是单位矩阵。等价地，因为当 $zI - A$ 可逆时，诱导矩阵2-范数满足 $\\left\\|(zI - A)^{-1}\\right\\|_{2} = 1 / \\sigma_{\\min}(zI - A)$，我们有\n$$\nz \\in \\Lambda_{\\varepsilon}(A) \\iff \\left\\|(zI - A)^{-1}\\right\\|_{2} \\ge \\frac{1}{\\varepsilon}。\n$$\n定义函数\n$$\nu(z) = \\log \\left\\|(zI - A)^{-1}\\right\\|_{2}。\n$$\n在数值线性代数和复分析中，一个已知且广泛使用的事实是：在集合 $\\{z \\in \\mathbb{C} \\mid zI - A \\text{ 可逆}\\}$ 上，$u(z)$ 是次调和的。次调和性意味着在分布意义下拉普拉斯算子 $\\Delta u(z) \\ge 0$，特别是，$u$ 遵循极大值原理：一个次调和函数在闭有界域上的极大值在边界上达到。\n\n你需要设计、实现并测试一种自适应网格加密策略，用于在复平面的一个矩形域上对 $u(z)$ 进行采样，以稳健地近似界定 $\\Lambda_{\\varepsilon}(A)$ 的水平集 $\\{z : u(z) = \\log(1/\\varepsilon)\\}$。目标是利用次调和性来验证网格没有漏掉伪谱的细长突起（“指状物”）。\n\n你的程序必须实现以下组件：\n\n- 一个用于数值计算 $u(z)$ 的例程，使用关系 $\\left\\|(zI - A)^{-1}\\right\\|_{2} = 1 / \\sigma_{\\min}(zI - A)$，其中 $\\sigma_{\\min}$ 通过奇异值分解（SVD）获得。\n- 在矩形域 $[x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}] \\subset \\mathbb{R}^{2}$ 上的一个大小为 $N_x \\times N_y$ 的均匀初始网格，使用 $(x,y)$ 坐标，其中 $z = x + \\mathrm{i} y$。\n- 一个基于五点有限差分拉普拉斯算子的离散极大值原理检查。设 $h_x = (x_{\\max} - x_{\\min})/(N_x - 1)$ 和 $h_y = (y_{\\max} - y_{\\min})/(N_y - 1)$。对于内部网格索引 $(i,j)$，定义离散拉普拉斯算子\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}。\n$$\n你必须在所有内部节点验证 $\\Delta_h u_{i,j} \\ge -\\tau$ 是否成立（其中 $\\tau  0$ 是一个指定的容差）；这种离散化的非负性被用作离散极大值原理在数值误差范围内成立的证明。\n- 针对每个网格单元的自适应边加密方案：设阈值 $T = \\log(1/\\varepsilon)$，如果一个单元所有四个角的 $u$ 值都严格小于 $T$，则递归地在其四条边上采样中点，以验证在整个单元边界上 $u(z)  T$。使用最大递归深度 $L$；如果在某条边上任何采样点的 $u(z) \\ge T$，则该边测试失败。如果所有四条边都通过测试，那么根据次调和函数的极大值原理，该单元的内部不可能包含 $u(z) \\ge T$ 的点，因此没有细长的伪谱“指状物”未被发现而穿过该单元。缓存先前计算的 $u(z)$ 值以避免冗余的SVD计算。\n- 每个测试用例的全局验证规则：返回一个布尔值，当且仅当以下两个条件都成立时为真：\n  1. 离散极大值原理检查在所有内部节点上通过（即 $\\Delta_h u_{i,j} \\ge -\\tau$）。\n  2. 对于每个四个角都满足 $u(z)  T$ 的单元，其所有四条边都已通过递归深度至多为 $L$ 的边加密验证低于 $T$。\n\n测试套件：\n实现三个测试用例，以检验不同的行为：\n\n- 测试用例1（正规，行为良好）：$A = \\mathrm{diag}(-2, -0.5, 1.5, 3.0)$，大小 $n = 4$，域 $[x_{\\min}, x_{\\max}] = [-4, 4]$，$ [y_{\\min}, y_{\\max}] = [-4, 4]$，网格 $N_x = N_y = 33$，$\\varepsilon = 0.3$，递归深度 $L = 3$，容差 $\\tau = 10^{-6}$。预期：验证应成功，因为 $\\Lambda_{\\varepsilon}(A)$ 由围绕特征值的近似圆形区域组成，没有细长的指状物。\n- 测试用例2（高度非正规，带指状物）：$A$ 是大小为 $n = 8$ 的Grcar矩阵（主对角线和前三条上对角线上为1，次对角线上为-1），域 $[x_{\\min}, x_{\\max}] = [-2.5, 2.5]$，$ [y_{\\min}, y_{\\max}] = [-2.5, 2.5]$，网格 $N_x = N_y = 31$，$\\varepsilon = 0.05$，递归深度 $L = 2$，容差 $\\tau = 10^{-6}$。预期：很可能出现细长的指状物；如果边检测到角点遗漏的、超过阈值的边界穿越，或离散拉普拉斯算子检查被违反，验证可能会失败。\n- 测试用例3（近正规）：$A = \\mathrm{diag}(-1, 0, 1, 2) + 0.01 U$，其中 $U$ 是对角线上方元素为1的严格上三角矩阵，大小 $n = 4$，域 $[x_{\\min}, x_{\\max}] = [-3, 3]$，$ [y_{\\min}, y_{\\max}] = [-3, 3]$，网格 $N_x = N_y = 33$，$\\varepsilon = 0.2$，递归深度 $L = 3$，容差 $\\tau = 10^{-6}$。预期：由于轻度的非正规性，验证应成功。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个方括号内的逗号分隔列表的结果（例如，$[result_1,result_2,result_3]$），其中每个 $result_k$ 是一个布尔值，指示测试用例 $k$ 的验证是否成功。", "solution": "该问题要求设计并实现一个针对方阵 $A \\in \\mathbb{C}^{n \\times n}$ 的 $\\varepsilon$-伪谱 $\\Lambda_{\\varepsilon}(A)$ 近似的验证算法。该算法利用函数 $u(z) = \\log \\left\\|(zI - A)^{-1}\\right\\|_{2}$ 的次调和性，来保证在指定域内，离散网格采样不会漏掉伪谱的“指状”结构。\n\n解法的原理是构建一个返回布尔证明的过程。当且仅当在复平面矩形域上的计算网格满足两个条件时，该证明为 `True`。首先，次调和性质的一个离散版本必须在整个网格上成立。其次，对于每个其角点位于目标伪谱区域之外的网格单元，必须验证该单元的整个边界也位于该区域之外。然后，次调和函数的极大值原理确保此类单元的内部也位于该区域之外。\n\n该解决方案可分解为以下逻辑组件。\n\n首先，我们定义一个函数来计算 $u(z)$。$\\varepsilon$-伪谱定义为 $\\Lambda_{\\varepsilon}(A) = \\left\\{ z \\in \\mathbb{C} \\;:\\; \\sigma_{\\min}(zI - A) \\le \\varepsilon \\right\\}$，其中 $\\sigma_{\\min}(\\cdot)$ 是最小奇异值。对于不属于 $A$ 谱的 $z$，预解式范数与之相关：$\\left\\|(zI - A)^{-1}\\right\\|_{2} = 1 / \\sigma_{\\min}(zI - A)$。因此，函数 $u(z)$ 由 $u(z) = \\log(1/\\sigma_{\\min}(zI - A)) = -\\log(\\sigma_{\\min}(zI - A))$ 给出。这通过数值计算实现：对于给定的 $z \\in \\mathbb{C}$，构建矩阵 $M = zI - A$，并使用标准的奇异值分解（SVD）算法找到其最小奇异值。为避免对同一 $z$ 值进行冗余且计算成本高昂的SVD计算（这可能在递归的边检查中发生），所有计算出的 $u(z)$ 值都存储在缓存中。\n\n其次，在指定的矩形域 $[x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$ 上建立一个均匀网格。该网格有 $N_x \\times N_y$ 个点，间距为 $h_x = (x_{\\max} - x_{\\min})/(N_x - 1)$ 和 $h_y = (y_{\\max} - y_{\\min})/(N_y - 1)$。在每个网格点 $z_{i,j} = (x_{\\min} + i h_x) + \\mathrm{i} (y_{\\min} + j h_y)$（其中 $i \\in \\{0, \\dots, N_x-1\\}$，$j \\in \\{0, \\dots, N_y-1\\}$）上计算函数 $u(z)$ 的值。\n\n第三，检查第一个验证条件。$u(z)$ 的理论次调和性意味着其拉普拉斯算子 $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\ge 0$。我们使用一个五点有限差分模板来验证该性质的离散模拟，该模板应用于每个内部网格节点 $(i,j)$，其中 $i \\in \\{1,\\dots,N_x-2\\}$ 且 $j \\in \\{1,\\dots,N_y-2\\}$。离散拉普拉斯算子为：\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\n其中 $u_{i,j}$ 表示在 $z_{i,j}$ 处的计算值。验证要求对所有内部节点，$\\Delta_h u_{i,j} \\ge -\\tau$ 成立，其中 $\\tau$ 是一个小的正容差，以考虑数值浮点误差。若此检查失败，则表明网格过粗，无法准确捕捉函数 $u(z)$ 的曲率。\n\n第四，检查第二个验证条件。这涉及对某些网格单元的边界进行自适应加密。一个单元是由四个相邻网格点 $(z_{i,j}, z_{i+1,j}, z_{i,j+1}, z_{i+1,j+1})$ 定义的小矩形。$\\varepsilon$-伪谱的边界对应于水平集 $\\left\\|(zI-A)^{-1}\\right\\|_2 = 1/\\varepsilon$，等价于 $u(z) = \\log(1/\\varepsilon)$。设此阈值为 $T = \\log(1/\\varepsilon)$。\n对于每个单元，我们首先检查其四个角点的 $u(z)$ 值。如果所有四个值都严格小于 $T$，则该单元是完全位于伪谱之外的候选者。根据次调和函数的极大值原理，如果对于单元边界上的所有 $z$，都有 $u(z)  T$，那么对其内部的所有 $z$，也有 $u(z)  T$。这将证明 $\\Lambda_\\varepsilon(A)$ 的任何部分都没有穿过该单元。\n为了验证边界上的 $u(z)  T$，我们检查四条边中的每一条。使用递归二分法进行边检查。对于连接点 $z_1$ 和 $z_2$ 的边，我们在中点 $z_m = (z_1+z_2)/2$ 计算 $u(z_m)$。如果 $u(z_m) \\ge T$，边检查失败。否则，我们递归地检查两个子边 $(z_1, z_m)$ 和 $(z_m, z_2)$。此递归进行到指定的最大深度 $L$。如果一条边的所有分段递归到最大深度都未发现任何点 $z$ 使得 $u(z) \\ge T$，则该边被验证。如果一个候选单元的所有四条边都得到验证，则该单元得到验证。\n\n最后，一个给定测试用例的全局验证结果为 `True` 当且仅当离散拉普拉斯算子检查对所有内部网格点通过，并且边加密检查对所有相关单元（即角点值低于 $T$ 的单元）通过。如果任一检查在任何点失败，则全局验证为 `False`。这个复合过程提供了一种鲁棒的方法来验证计算出的伪谱边界，防止因网格过粗而漏掉高度非正规矩阵特有的精细指状延伸。所提供的测试用例旨在针对具有不同非正规程度的矩阵来检验该算法。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svdvals\n\ndef compute_u(z, A, cache):\n    \"\"\"\n    Computes u(z) = log(||(zI - A)^-1||_2), caching the results.\n    \"\"\"\n    if z in cache:\n        return cache[z]\n    \n    n = A.shape[0]\n    M = z * np.identity(n) - A\n    \n    # Use scipy.linalg.svdvals for efficiency as we only need singular values.\n    # The smallest singular value is the last one if they are sorted.\n    # svdvals does not guarantee sorting, so we must take the minimum.\n    try:\n        singular_values = svdvals(M)\n        sigma_min = np.min(singular_values)\n    except np.linalg.LinAlgError:\n        # This can happen if the matrix contains inf or NaN, which is not expected\n        # here but good practice to handle.\n        sigma_min = 0.0\n\n    # If sigma_min is zero, u(z) is infinite.\n    if sigma_min  np.finfo(float).tiny: # Effectively zero\n        result = np.inf\n    else:\n        # u(z) = log(1/sigma_min) = -log(sigma_min)\n        result = -np.log(sigma_min)\n        \n    cache[z] = result\n    return result\n\ndef certify_edge(z1, z2, L, T, A, cache):\n    \"\"\"\n    Recursively checks if the edge between z1 and z2 is below threshold T.\n    L is the remaining recursion depth.\n    \"\"\"\n    if L == 0:\n        return True # Max depth reached without failure, certify this segment.\n    \n    zm = (z1 + z2) / 2.0\n    u_mid = compute_u(zm, A, cache)\n    \n    if u_mid >= T:\n        return False # Midpoint is above threshold, edge test fails.\n        \n    # Recursively check the two halves of the segment.\n    left_half_ok = certify_edge(z1, zm, L - 1, T, A, cache)\n    if not left_half_ok:\n        return False\n        \n    right_half_ok = certify_edge(zm, z2, L - 1, T, A, cache)\n    return right_half_ok\n\ndef run_certification_test(A, x_range, y_range, N_xy, epsilon, L, tau):\n    \"\"\"\n    Performs the full certification test for a given matrix and parameters.\n    \"\"\"\n    Nx, Ny = N_xy\n    xmin, xmax = x_range\n    ymin, ymax = y_range\n    \n    T = np.log(1.0 / epsilon)\n    hx = (xmax - xmin) / (Nx - 1)\n    hy = (ymax - ymin) / (Ny - 1)\n    \n    # Cache for memoizing u(z) computations\n    cache = {}\n    \n    # 1. Compute u(z) on the initial grid\n    u_grid = np.zeros((Ny, Nx))\n    x_coords = np.linspace(xmin, xmax, Nx)\n    y_coords = np.linspace(ymin, ymax, Ny)\n    \n    for j in range(Ny):\n        for i in range(Nx):\n            z = x_coords[i] + 1j * y_coords[j]\n            u_grid[j, i] = compute_u(z, A, cache)\n            \n    # 2. Perform discrete maximum principle check (Laplacian)\n    laplacian_check_passed = True\n    if Nx > 2 and Ny > 2:\n        hx2, hy2 = hx**2, hy**2\n        for j in range(1, Ny - 1):\n            for i in range(1, Nx - 1):\n                u_center = u_grid[j, i]\n                u_east = u_grid[j, i+1]\n                u_west = u_grid[j, i-1]\n                u_north = u_grid[j+1, i]\n                u_south = u_grid[j-1, i]\n                \n                laplacian_u = (u_east - 2*u_center + u_west)/hx2 + \\\n                              (u_north - 2*u_center + u_south)/hy2\n                \n                if laplacian_u  -tau:\n                    laplacian_check_passed = False\n                    break\n            if not laplacian_check_passed:\n                break\n    \n    # 3. Perform adaptive edge refinement check\n    edge_check_passed = True\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            u00 = u_grid[j, i]\n            u01 = u_grid[j+1, i]\n            u10 = u_grid[j, i+1]\n            u11 = u_grid[j+1, i+1]\n            \n            # If all four corners are below the threshold, certify the cell's boundary\n            if u00  T and u01  T and u10  T and u11  T:\n                z00 = x_coords[i] + 1j * y_coords[j]\n                z10 = x_coords[i+1] + 1j * y_coords[j]\n                z01 = x_coords[i] + 1j * y_coords[j+1]\n                z11 = x_coords[i+1] + 1j * y_coords[j+1]\n                \n                # Check bottom edge\n                if not certify_edge(z00, z10, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n                # Check top edge\n                if not certify_edge(z01, z11, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n                # Check left edge\n                if not certify_edge(z00, z01, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n                # Check right edge\n                if not certify_edge(z10, z11, L, T, A, cache):\n                    edge_check_passed = False\n                    break\n        if not edge_check_passed:\n            break\n            \n    return laplacian_check_passed and edge_check_passed\n\ndef solve():\n    # Test Case 1: Normal matrix\n    A1 = np.diag(np.array([-2.0, -0.5, 1.5, 3.0]))\n    \n    # Test Case 2: Grcar matrix (highly non-normal)\n    n2 = 8\n    A2 = (np.diag(np.ones(n2)) +\n          np.diag(np.ones(n2 - 1), 1) +\n          np.diag(np.ones(n2 - 2), 2) +\n          np.diag(np.ones(n2 - 3), 3) +\n          np.diag(-np.ones(n2 - 1), -1))\n\n    # Test Case 3: Nearly normal matrix\n    n3 = 4\n    D3 = np.diag(np.array([-1.0, 0.0, 1.0, 2.0]))\n    U3 = np.triu(np.ones((n3, n3)), k=1)\n    A3 = D3 + 0.01 * U3\n    \n    test_cases = [\n        {\n            \"A\": A1,\n            \"x_range\": (-4.0, 4.0), \"y_range\": (-4.0, 4.0), \"N_xy\": (33, 33),\n            \"epsilon\": 0.3, \"L\": 3, \"tau\": 1e-6\n        },\n        {\n            \"A\": A2,\n            \"x_range\": (-2.5, 2.5), \"y_range\": (-2.5, 2.5), \"N_xy\": (31, 31),\n            \"epsilon\": 0.05, \"L\": 2, \"tau\": 1e-6\n        },\n        {\n            \"A\": A3,\n            \"x_range\": (-3.0, 3.0), \"y_range\": (-3.0, 3.0), \"N_xy\": (33, 33),\n            \"epsilon\": 0.2, \"L\": 3, \"tau\": 1e-6\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_certification_test(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3568841"}]}