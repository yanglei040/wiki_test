{"hands_on_practices": [{"introduction": "在分块算法中，性能并非仅由计算量决定，数据在内存层次结构中的移动方式同样至关重要。不当的矩阵维度、分块大小和数据对齐方式可能导致灾难性的缓存冲突（cache conflicts），即多个数据块竞争有限的缓存组，从而导致命中率急剧下降。本练习将引导你对一个典型的分块矩阵乘法场景进行具体分析，通过计算揭示缓存冲突的根源，并探索如何通过数据填充（padding）这一常用技巧来有效规避此类问题。[@problem_id:3534917]", "problem": "考虑一个分块通用矩阵乘法 (GEMM)，计算 $C \\leftarrow C + A B$，其中 $A$、$B$ 和 $C$ 是 $n \\times n$ 的矩阵，以行主序存储，元素为双精度类型（每个元素占 $8$ 字节）。该分块算法使用大小为 $t \\times t$ 的方形分块。最内层核心计算 $C(i_{0}:i_{0}+t-1,\\, j_{0}:j_{0}+t-1) \\leftarrow C(i_{0}:i_{0}+t-1,\\, j_{0}:j_{0}+t-1) + A(i_{0}:i_{0}+t-1,\\, k_{0}:k_{0}+t-1)\\, B(k_{0}:k_{0}+t-1,\\, j_{0}:j_{0}+t-1)$，在分块内部迭代 $k$ 并将结果累加到 $C$ 中。\n\n假设一级数据缓存是一个组相联缓存，其相联度为 $a$，组数为 $S$，缓存行大小为 $B$ 字节。内存地址 $\\text{addr}$ 的组索引由广泛使用的组相联映射规则定义\n$$\n\\text{set}(\\text{addr}) \\;=\\; \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\bmod S.\n$$\n假设采用最近最少使用 (LRU) 替换策略，并对存储操作使用写分配。$A$、$B$ 和 $C$ 的基地址已对齐，使得对于每个数组，$\\left\\lfloor \\frac{\\text{base}}{B} \\right\\rfloor \\bmod S = 0$。\n\n给定以下机器和问题参数：\n- $a = 8$，$S = 64$，$B = 64$ 字节。\n- 元素大小 $E = 8$ 字节。\n- $n = 1024$。\n- 候选分块大小 $t = 64$。\n- 考虑第一个分块，其 $(i_{0}, j_{0}, k_{0}) = (0, 0, 0)$。\n\n任务：\n1. 使用组映射的定义，推导在内层核心中访问元素时其缓存组索引的闭式表达式，当：\n   - 在分块内访问 $A$ 的一列，对于固定的 $k$ 和变化的 $i$，即 $A(i, k)$，其中 $i \\in \\{0, \\dots, t-1\\}$ 且 $k \\in \\{0, \\dots, t-1\\}$。\n   - 在分块内访问 $B$ 的一列，对于固定的 $j$ 和变化的 $k$，即 $B(k, j)$，其中 $j \\in \\{0, \\dots, t-1\\}$ 且 $k \\in \\{0, \\dots, t-1\\}$。\n   - 在分块内访问 $C$ 的一个块，对于固定的 $j$ 和变化的 $i$，即 $C(i, j)$，其中 $i \\in \\{0, \\dots, t-1\\}$ 且 $j \\in \\{0, \\dots, t-1\\}$。\n2. 根据这些表达式，确定分块内计算中地址在缓存组间的分布，并识别任何病态相关性（例如，许多不同的缓存行映射到同一个组）。\n3. 在 LRU 策略下，使用以下理想化模型，估算由组冲突引起的分块内访问的冲突未命中率：如果 $L$ 个不同的缓存行映射到同一个组，并且必须在短重用窗口内驻留，那么会命中的引用比例最多为 $\\frac{a}{L}$，因此估计的冲突未命中率为 $1 - \\frac{a}{L}$。将此模型分别应用于 $A$ 列访问模式、$B$ 列访问模式以及分块内计算中的 $C$ 分块更新。\n4. 为了去除病态组映射的相关性，向 $B$ 的主维度引入一个 $p$（以元素为单位）的填充（在 $B$ 的地址公式中用 $n' = n + p$ 替换 $n$），使得每个 $k$ 步长在缓存行索引上的增量与 $S$ 互质，并且特别地，模 $S$ 不为零。确定实现此属性的最小正整数 $p$（以元素为单位）。将最终答案表示为 $p$ 的值。\n\n将最终填充表示为整数个元素。无需四舍五入。", "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**第 1 步：提取给定条件**\n- **算法**：分块通用矩阵乘法 (GEMM)，$C \\leftarrow C + A B$。\n- **矩阵**：$A, B, C$ 是 $n \\times n$ 的。\n- **存储**：行主序。\n- **数据类型**：双精度元素，元素大小 $E = 8$ 字节。\n- **分块**：大小为 $t \\times t$ 的方形分块。\n- **最内层核心**：计算一个分块的更新：使用 $A(i_{0}:i_{0}+t-1, k_{0}:k_{0}+t-1)$ 和 $B(k_{0}:k_{0}+t-1, j_{0}:j_{0}+t-1)$ 来更新 $C(i_{0}:i_{0}+t-1, j_{0}:j_{0}+t-1)$。\n- **缓存**：组相联，相联度 $a=8$，组数 $S=64$，缓存行大小 $B=64$ 字节。\n- **缓存策略**：最近最少使用 (LRU) 替换，写分配。\n- **组映射规则**：$\\text{set}(\\text{addr}) = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\bmod S$。\n- **基地址对齐**：对于每个数组（$A, B, C$），$\\left\\lfloor \\frac{\\text{base}}{B} \\right\\rfloor \\bmod S = 0$。\n- **问题参数**：$n = 1024$，$t = 64$。\n- **范围**：第一个分块，其 $(i_{0}, j_{0}, k_{0}) = (0, 0, 0)$。\n- **填充任务**：向 $B$ 的主维度引入填充 $p$，使得新维度为 $n' = n + p$。\n- **理想化未命中率模型**：对于映射到同一组（相联度为 $a$）的 $L$ 个不同缓存行，如果 $L > a$，则冲突未命中率估计为 $1 - \\frac{a}{L}$，否则为 $0$。\n\n**第 2 步：使用提取的给定条件进行验证**\n- **科学性**：该问题是计算机体系结构和高性能计算中的一个经典练习，涉及数值算法的缓存性能。它坚实地植根于计算机科学和数值线性代数原理。\n- **良构性**：该问题提供了所有必要的参数和一组明确的任务。定义是标准的，问题导向具体的、可计算的答案。\n- **客观性**：问题使用精确、客观的数学和计算术语进行陈述。\n\n**第 3 步：结论和行动**\n问题被认为是有效的。所有必需的信息都已提供，问题科学合理且良构。可以开始求解过程。\n\n### 求解\n\n一个以行主序存储、元素大小为 E 的 $n \\times n$ 矩阵 $M$ 中元素 $M(i,j)$ 的地址由下式给出\n$$\n\\text{addr}(M(i,j)) = \\text{Addr}_M + (i \\cdot n + j) \\cdot E\n$$\n其中 $\\text{Addr}_M$ 是矩阵的基地址。\n\n包含此地址的缓存行索引是\n$$\n\\text{line}(M(i,j)) = \\left\\lfloor \\frac{\\text{addr}(M(i,j))}{B} \\right\\rfloor = \\left\\lfloor \\frac{\\text{Addr}_M + (i \\cdot n + j) \\cdot E}{B} \\right\\rfloor\n$$\n那么缓存组索引是\n$$\n\\text{set}(M(i,j)) = \\text{line}(M(i,j)) \\bmod S\n$$\n对齐条件表明 $\\lfloor \\text{Addr}_M / B \\rfloor = K_M \\cdot S$，其中 $K_M$ 为某个整数。这意味着 $\\text{Addr}_M = K_M \\cdot S \\cdot B + \\delta_M$，其中 $0 \\le \\delta_M  B$。我们可以将行索引写为：\n$$\n\\text{line}(M(i,j)) = \\left\\lfloor \\frac{K_M S B + \\delta_M + (i \\cdot n + j) E}{B} \\right\\rfloor = K_M S + \\left\\lfloor \\frac{\\delta_M + (i \\cdot n + j) E}{B} \\right\\rfloor\n$$\n对此取模 $S$：\n$$\n\\text{set}(M(i,j)) = \\left\\lfloor \\frac{\\delta_M + (i \\cdot n + j) E}{B} \\right\\rfloor \\bmod S\n$$\n假设最简单的对齐形式，即基地址是缓存行大小的倍数，因此 $\\delta_M = 0$：\n$$\n\\text{set}(M(i,j)) = \\left\\lfloor \\frac{(i \\cdot n + j) E}{B} \\right\\rfloor \\bmod S\n$$\n让我们代入给定的参数：$n=1024$，$E=8$ 字节，$B=64$ 字节，$S=64$。\n比率 $\\frac{E}{B} = \\frac{8}{64} = \\frac{1}{8}$。组索引公式变为：\n$$\n\\text{set}(M(i,j)) = \\left\\lfloor \\frac{i \\cdot 1024 + j}{8} \\right\\rfloor \\bmod 64 = \\left\\lfloor i \\cdot \\frac{1024}{8} + \\frac{j}{8} \\right\\rfloor \\bmod 64 = \\left\\lfloor i \\cdot 128 + \\frac{j}{8} \\right\\rfloor \\bmod 64\n$$\n由于 $i$ 是整数，我们有：\n$$\n\\text{set}(M(i,j)) = \\left(i \\cdot 128 + \\left\\lfloor \\frac{j}{8} \\right\\rfloor\\right) \\bmod 64\n$$\n由于 $128$ 是 $64$ 的倍数 ($128 = 2 \\cdot 64$)，项 $i \\cdot 128$ 模 $64$ 总是为 $0$。因此，表达式简化为：\n$$\n\\text{set}(M(i,j)) = \\left\\lfloor \\frac{j}{8} \\right\\rfloor \\bmod 64\n$$\n这个简化表达式适用于任何主维度为 $n=1024$ 的矩阵 A、B、C。\n\n**任务 1：推导缓存组索引的闭式表达式。**\n我们正在考虑第一个分块，其中索引 $i, j, k$ 的范围是从 $0$ 到 $t-1=63$。\n\n- **矩阵 A**：我们关注的是 $\\text{set}(A(i,k))$，其中 $i, k \\in \\{0, \\dots, 63\\}$。在通用公式中，第二个索引对应于列。\n$$\n\\text{set}(A(i,k)) = \\left\\lfloor \\frac{k}{8} \\right\\rfloor \\bmod 64\n$$\n对于 $k \\in \\{0, \\dots, 63\\}$，$\\lfloor \\frac{k}{8} \\rfloor$ 的取值范围是 $\\{0, 1, \\dots, 7\\}$。模 64 不起作用。\n$$\n\\text{set}(A(i,k)) = \\left\\lfloor \\frac{k}{8} \\right\\rfloor\n$$\n\n- **矩阵 B**：我们关注的是 $\\text{set}(B(k,j))$，其中 $k, j \\in \\{0, \\dots, 63\\}$。\n$$\n\\text{set}(B(k,j)) = \\left\\lfloor \\frac{j}{8} \\right\\rfloor \\bmod 64\n$$\n对于 $j \\in \\{0, \\dots, 63\\}$，这简化为：\n$$\n\\text{set}(B(k,j)) = \\left\\lfloor \\frac{j}{8} \\right\\rfloor\n$$\n\n- **矩阵 C**：我们关注的是 $\\text{set}(C(i,j))$，其中 $i, j \\in \\{0, \\dots, 63\\}$。\n$$\n\\text{set}(C(i,j)) = \\left\\lfloor \\frac{j}{8} \\right\\rfloor \\bmod 64\n$$\n对于 $j \\in \\{0, \\dots, 63\\}$，这简化为：\n$$\n\\text{set}(C(i,j)) = \\left\\lfloor \\frac{j}{8} \\right\\rfloor\n$$\n\n**任务 2：分布和病态相关性。**\n推导出的表达式表明，三个 $t \\times t$ 分块中任一元素的组索引仅取决于该元素在分块内的列索引（A 的 k，B 和 C 的 j）。行索引（A 和 C 的 i，B 的 k）对组索引没有影响。这是因为内存中连续行之间的步长 $n \\cdot E = 1024 \\cdot 8 = 8192$ 字节，对应于 $\\frac{8192}{64} = 128$ 个缓存行的步长。由于 $128 \\bmod 64 = 0$，访问同一列但不同行的元素会导致缓存行映射到同一个组。\n\n列索引 k 和 j 的范围是从 0 到 63。项 $\\lfloor \\text{index}/8 \\rfloor$ 的取值将在 $\\{0, 1, 2, 3, 4, 5, 6, 7\\}$ 中。这意味着整个 A、B 和 C 分块的所有内存访问都只映射到前 8 个缓存组（组 0 到 7）。这是一种严重的病态相关性，将所有内存流量集中到可用缓存组的一小部分（$8/64 = 1/8$），这将导致大量的冲突未命中。\n\n**任务 3：估算冲突未命中率。**\n我们使用理想化模型：对于映射到同一组的 L 个不同缓存行，未命中率为 $1 - \\frac{a}{L}$。这里，相联度 a=8。我们需要为指定的访问模式找到 L。\n\n- **A 列访问**：对于固定的 $k \\in \\{0,..,63\\}$ 和 $i \\in \\{0,..,63\\}$ 的 $A(i, k)$。所有这些访问都映射到单个组 $\\lfloor k/8 \\rfloor$。$A(i,k)$ 的内存地址与 $A(i+1,k)$ 相隔 $n \\cdot E = 8192$ 字节。缓存行的步长是 $\\frac{n \\cdot E}{B} = \\frac{8192}{64} = 128$。由于我们访问 $t=64$ 个元素（从 i=0 到 i=63），每次访问都落在一个唯一的缓存行中。因此，访问了 $L=64$ 个不同的缓存行。所有 64 个行都映射到同一个组。\n冲突未命中率为 $1 - \\frac{a}{L} = 1 - \\frac{8}{64} = 1 - \\frac{1}{8} = \\frac{7}{8} = 0.875$。\n\n- **B 列访问**：对于固定的 $j \\in \\{0,..,63\\}$ 和 $k \\in \\{0,..,63\\}$ 的 $B(k, j)$。所有这些访问都映射到单个组 $\\lfloor j/8 \\rfloor$。$B(k,j)$ 和 $B(k+1,j)$ 之间的内存步长是 $n \\cdot E = 8192$ 字节，即 128 个缓存行。访问 64 个这样的元素涉及 $L=64$ 个不同的缓存行，所有这些行都映射到同一个组。\n冲突未命中率为 $1 - \\frac{a}{L} = 1 - \\frac{8}{64} = \\frac{7}{8} = 0.875$。\n\n- **C 列访问**：对于固定的 $j \\in \\{0,..,63\\}$ 和 $i \\in \\{0,..,63\\}$ 的 $C(i, j)$。这种情况与 A 列访问相同。我们有 $L=64$ 个不同的行映射到组 $\\lfloor j/8 \\rfloor$。\n冲突未命中率为 $1 - \\frac{a}{L} = 1 - \\frac{8}{64} = \\frac{7}{8} = 0.875$。\n\n**任务 4：确定填充。**\n为了去除矩阵 B 映射的相关性，我们在其主维度上增加 p 个元素的填充，因此新维度为 $n' = n + p = 1024 + p$。$B(k,j)$ 和 $B(k+1,j)$ 之间的字节步长变为 $n' \\cdot E = (1024+p) \\cdot 8$。缓存行的步长是 $S_L = \\frac{(1024+p) \\cdot 8}{64} = \\frac{1024+p}{8} = 128 + \\frac{p}{8}$。\n\n为了让组索引随 k 可预测地变化，行步长 $S_L$ 应该是一个整数。这要求 p 是 8 的倍数。设 $p = 8 p'$，其中 $p'$ 是一个正整数。那么行步长是 $S_L = 128 + p'$。\n\nk 每步进一次，组索引的变化由 $S_L \\bmod S$ 给出。我们希望这个步长与 S=64 互质，以确保连续的访问被映射到不同的组。\n我们需要 $\\text{gcd}(S_L, S) = 1$。\n$$\n\\text{gcd}(128 + p', 64) = 1\n$$\n使用性质 $\\text{gcd}(x+ky, y) = \\text{gcd}(x, y)$，并且由于 $128 = 2 \\cdot 64$：\n$$\n\\text{gcd}(p', 64) = 1\n$$\n我们需要找到最小的正整数填充 p。这对应于找到最小的正整数 $p'$ 使得 $\\text{gcd}(p', 64)=1$。与 $64 = 2^6$ 互质的最小正整数是 1。\n所以，我们选择 $p' = 1$。\n\n那么最小填充 p 是：\n$$\np = 8 \\cdot p' = 8 \\cdot 1 = 8\n$$\n当 p=8 时，行步长变为 $S_L = 129$。组步长是 $129 \\bmod 64 = 1$。这确保了随着 k 的递增，对 B 列的访问将映射到连续的缓存组，从而消除了 B 列访问内部的自冲突问题。\n所需的最小正整数填充是 8 个元素。", "answer": "$$\n\\boxed{8}\n$$", "id": "3534917"}, {"introduction": "虽然数据填充可以解决特定的缓存冲突问题，但更通用和强大的方法是设计一种从根本上适应分层存储器访问模式的数据布局（data layout）。本练习将视角从微观的冲突规避提升到宏观的数据结构设计。你将评估在递归QR分解算法中，不同的数据布局（如列主序、行主序、块状布局等）如何影响作为性能核心的BLAS-3核的访存效率，并理解为何现代高性能计算库普遍采用块状数据布局。[@problem_id:3534911]", "problem": "考虑一个对 $m \\times n$ 稠密矩阵 $A$ 进行的分块递归基于 Householder 的 $QR$ 分解，其中递归地分解一个宽度为 $b$ 的面板，然后通过 3 级基本线性代数子程序 (BLAS-3) 应用块反射器来更新拖尾矩阵。面板分解会构建一个反射器（例如 $V$）的紧凑表示和一个小的三角因子（例如 $T$），而拖尾更新则由形如 $A \\leftarrow A - W Y^{\\top}$ 的乘法组成，其中 $W$ 和 $Y$ 根据紧凑分块形式由 $V$、$T$ 和 $A$ 的切片构造而成。假设双精度元素的大小为 $s$ 字节，缓存行大小为 $L$ 字节。\n\n对于以列主序布局存储且前导维度为 $\\ell_d = m$ 的矩阵，元素 $A(i,j)$ 的地址具有线性化偏移量 $o_{\\mathrm{col}}(i,j) = i + j \\cdot \\ell_d$（以元素为单位）。对于以行主序布局存储且前导维度为 $\\ell_d = n$ 的矩阵，地址映射为 $o_{\\mathrm{row}}(i,j) = j + i \\cdot \\ell_d$。在列主序中沿列迭代的数据流步幅为 $1$（连续元素），而在行主序中其步幅为 $\\ell_d$ 个元素。当步幅 $p$（以元素为单位）满足 $p \\cdot s \\ge L$ 时，连续的访问会落到不同的缓存行上，从而降低有效的空间局部性，并相对于连续流造成显著的带宽浪费。\n\n在分块递归 $QR$ 分解中，面板 $A(:, j : j+b-1)$ 被重复分解，而拖尾更新则将一个或多个 BLAS-3 内核（通常是通用矩阵-矩阵乘法 $GEMM$）应用于其形状由当前递归划分决定的子矩阵上。当这些内核的输入在内存中布局得当时，即每个操作数的被访问子块是连续的或属于能装入缓存的小瓦片时，它们的效率最高，从而最大限度地减少了跨缓存行的跨步加载。\n\n使用上述地址映射和缓存行模型，研究列主序与行主序存储对这些分块递归 $QR$ 更新的影响，然后找出最有效的数据布局转换方法，该方法能在两种存储顺序下都减少跨步访问，同时在整个递归过程中保留 BLAS-3 内核的使用。选择最佳选项。\n\nA. 在分解前对 $A$ 进行一次性全局转置，将行主序布局转换为列主序布局，然后运行标准的分块递归 $QR$；这能确保面板列是连续的，从而减少步幅。\n\nB. 将 $A$ 转换为大小为 $b \\times b$ 的方形瓦片分块数据布局，每个瓦片内部的元素按列主序存储，瓦片之间按块列主序排列。在每个递归步骤中，将当前面板打包到连续的工作空间中，并使用作用于瓦片操作数的 BLAS-3 来驱动所有拖尾更新，这样无论最初的全局行主序或列主序布局如何，访问都被限制在瓦片或打包的面板内，并且是连续的。\n\nC. 在元素级别将 $A$ 转换为 Morton (Z序) 布局，以使递归子矩阵对缓存友好；直接在 Morton 布局的子矩阵上调用 BLAS-3 内核以利用局部性。\n\nD. 更改递归调度以首先处理较短的维度（例如，在列之前对行进行递归），而不修改数据布局，从而使有效的前导维度在递归过程中缩小，步幅自然减小。\n\nE. 全局性地将 $A$ 转换为面板主序布局，将矩阵存储为一系列宽度为 $b$ 的垂直面板，每个面板内部按列主序排列，并直接在这些面板子矩阵上调用 BLAS-3，无需任何打包操作。\n\n哪个选项在保留分块递归 $QR$ 过程中使用 BLAS-3 内核的同时，最鲁棒地最小化了列主序和行主序两种基准下的跨步访问？通过选择一个或多个字母作答。", "solution": "首先验证问题陈述，以确保其科学上合理、问题定义明确且客观。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- **算法：**对 $m \\times n$ 稠密矩阵 $A$ 进行分块递归基于 Householder 的 $QR$ 分解。\n- **过程：**递归地分解一个宽度为 $b$ 的面板，然后使用 3 级基本线性代数子程序 (BLAS-3) 将块反射器应用于拖尾矩阵。\n- **面板分解产物：**反射器的紧凑表示 $V$ 和一个小的三角因子 $T$。\n- **拖尾更新形式：**形如 $A \\leftarrow A - W Y^{\\top}$ 的矩阵乘法。\n- **数据元素大小：**双精度，大小为 $s$ 字节。\n- **缓存参数：**缓存行大小为 $L$ 字节。\n- **数据布局与寻址：**\n  - **列主序：**地址偏移量 $o_{\\mathrm{col}}(i,j) = i + j \\cdot \\ell_d$，前导维度为 $\\ell_d = m$。列步幅为 $1$。\n  - **行主序：**地址偏移量 $o_{\\mathrm{row}}(i,j) = j + i \\cdot \\ell_d$，前导维度为 $\\ell_d = n$。行步幅为 $1$。\n- **局部性差的条件：**当步幅为 $p$ 个元素的数据流满足 $p \\cdot s \\ge L$ 时，会经历较差的空间局部性。\n- **BLAS-3 效率：**像通用矩阵-矩阵乘法 ($GEMM$) 这样的内核在连续或能装入缓存的小瓦片化数据上效率最高。\n- **目标：**找出最有效的数据布局转换方法，以减少列主序和行主序存储下的跨步访问，同时保留 BLAS-3 内核的使用。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：**该问题牢固地植根于高性能数值线性代数。对分块递归 $QR$ 分解、用于块反射器的紧凑-WY 表示、对 BLAS-3 性能的依赖以及内存访问模型（列主序 vs. 行主序、缓存行、跨步访问）的描述都是该领域中标准和基本的概念。\n- **问题定义明确：**该问题定义明确。它要求根据明确的标准（在不同初始布局下最小化跨步访问并保持与 BLAS-3 内核的兼容性）在给出的选项中找出“最有效”的策略。这使得对所提出的方法进行确定性的分析和比较成为可能。\n- **客观性：**该问题以精确、技术性的语言陈述，没有主观性或模糊性。内存布局、步幅和缓存效应等概念都得到了客观的定义。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。这是设计高性能线性代数库时一个标准的、非平凡的问题。可以继续进行求解过程。\n\n**解题推导**\n\n分块递归 $QR$ 分解的核心性能挑战源于内存访问模式。该算法递归地对子矩阵进行操作。在标准的列主序或行主序布局中，子矩阵 $A(i:k, j:l)$ 在内存中并非连续存储。访问其元素需要等于整个矩阵前导维度的步幅，而这个步幅通常很大。这导致内存总线和缓存层次结构的利用率低下，这也是问题正确指出的一个症结。算法中计算上占主导地位的部分是拖尾矩阵更新，它通过 BLAS-3 内核（如 $GEMM$）实现。为了使这些内核达到峰值性能，其操作数子矩阵必须表现出高度的空间局部性。目标是找到一种数据布局策略，该策略能为递归各层次的子矩阵提供这种局部性，而不管原始矩阵是列主序还是行主序。\n\n**逐项分析选项**\n\n**A. 在分解前对 $A$ 进行一次性全局转置，将行主序布局转换为列主序布局，然后运行标准的分块递归 $QR$；这能确保面板列是连续的，从而减少步幅。**\n\n此选项建议通过将行主序情况转换为列主序情况来处理。标准的 $QR$ 分解逐列处理矩阵。在列主序布局中，一列内的元素是连续的（步幅为 $1$），这很有利。在行主序布局中，一列内的元素被 $\\ell_d = n$ 的步幅分隔，效率极低。转置一个行主序矩阵，相对于算法的访问模式而言，实际上使其变成了列主序。\n\n然而，这不是一个完整的解决方案。\n$1$. 全局转置是一个代价高昂的操作，涉及 $O(mn)$ 的数据移动。\n$2$. 更重要的是，它没有解决列主序布局*内部*子矩阵的跨步访问这一根本问题。递归算法对拖尾子矩阵进行操作，比如 $A(k:m, k':n)$。虽然该子矩阵的第一列是连续的，但后续列仍然被前导维度 $m$ 分隔，并且行是跨步的。标准的 BLAS-3 库通过将子操作数打包到连续缓冲区中来缓解此问题，但这会引入开销。该方法未能从根本上“在整个递归过程中……减少跨步访问”；它只是将问题规范化为标准的列主序情况，而这种情况本身就存在本问题旨在解决的局部性问题。\n\n**结论：错误**\n\n**B. 将 $A$ 转换为大小为 $b \\times b$ 的方形瓦片分块数据布局，每个瓦片内部的元素按列主序存储，瓦片之间按块列主序排列。在每个递归步骤中，将当前面板打包到连续的工作空间中，并使用作用于瓦片操作数的 BLAS-3 来驱动所有拖尾更新，这样无论最初的全局行主序或列主序布局如何，访问都被限制在瓦片或打包的面板内，并且是连续的。**\n\n此选项描述了“分块数据布局”或“瓦片布局”方法，这是像 PLASMA 和 MAGMA 这样的现代高性能库的基础。矩阵在物理上被重组为一组小的、连续的块（瓦片）。\n\n优点非常显著：\n$1$. **子矩阵的局部性：**$A$ 的任何子矩阵都可以表示为这些瓦片的集合。由于每个瓦片都是一小块连续的内存块，对子矩阵的 BLAS-3 操作可以分解为一系列在这些瓦片上进行的高效 BLAS-3 操作。这从根本上解决了拖尾矩阵更新的跨步访问问题，而这部分是算法中计算开销最大的部分。\n$2$. **布局无关性：**从列主序或行主序到瓦片格式的初始转换是一次性成本。转换之后，算法的性能就与原始布局无关。这使得该方法具有鲁棒性。\n$3$. **面板打包：**面板分解本身涉及的操作通常是内存受限的（2 级 BLAS）。瓦片布局中的面板由一列瓦片组成，这些瓦片不是连续的。如建议所述，将面板打包到临时连续工作空间中，可以使面板分解以最高效率执行，避免步幅。然后使用这个打包好的面板生成更新矩阵 $W$ 和 $Y$。\n\n这种方法直接满足了所有要求：它为任何子矩阵操作最小化了跨步访问，对两种原始布局都有效，并且其设计明确旨在最大化 BLAS-3 内核的性能。\n\n**结论：正确**\n\n**C. 在元素级别将 $A$ 转换为 Morton (Z序) 布局，以使递归子矩阵对缓存友好；直接在 Morton 布局的子矩阵上调用 BLAS-3 内核以利用局部性。**\n\nMorton 排序是一种空间填充曲线，它将多维数据映射到一维，同时保持局部性。对于矩阵，它排列元素，使得递归定义的象限在内存中几乎是连续的。这对于遵循四叉树分解模式的算法的缓存性能非常有利。\n\n然而，这个提议有一个关键缺陷：“直接调用 BLAS-3 内核”。标准的、高度优化的 BLAS-3 库（例如，Intel MKL、OpenBLAS、BLIS）是为规范的数据布局（特别是列主序和行主序）编写的。它们期望一个基指针和一个前导维度来描述矩阵。它们无法在以 Morton 顺序存储的数据上操作。要使用这种布局，就必须为 Morton 排序的数据专门开发一套定制的 BLAS-3 内核。这违反了问题中“保留 BLAS-3 内核的使用”这一约束，该约束意味着要利用现有的、广泛可用且高度优化的库。虽然理论上很有趣，但在这种情况下它不是一个实际的解决方案。\n\n**结论：错误**\n\n**D. 更改递归调度以首先处理较短的维度（例如，在列之前对行进行递归），而不修改数据布局，从而使有效的前导维度在递归过程中缩小，步幅自然减小。**\n\n这个选项在算法上是混乱的。$QR$ 分解具有固定的数据依赖关系：你必须处理第 $j$ 列以生成反射器，然后将其应用于第 $j+1$ 列到第 $n$ 列。你不能简单地“在列之前对行进行递归”。虽然对于一个矮胖矩阵（$m \\ll n$），可以选择对 $A^{\\top}$ 进行 $QR$ 分解（这计算了 $A$ 的 $LQ$ 分解），但那是一个不同的算法。此外，这并不能解决根本的布局问题。在一个对大小为 $m \\times n$ 的矩阵进行标准的列主序递归 $QR$ 分解中，第一个递归步骤处理一个大小为 $m \\times n$ 的子矩阵。下一个递归步骤操作一个大小约为 $(m-b) \\times (n-b)$ 的拖尾子矩阵。该子矩阵的前导维度仍然是原始的 $m$。它并不会“在递归过程中缩小”。访问行的步幅仍然很大。因此，这个建议是基于一个错误的前提。\n\n**结论：错误**\n\n**E. 全局性地将 $A$ 转换为面板主序布局，将矩阵存储为一系列宽度为 $b$ 的垂直面板，每个面板内部按列主序排列，并直接在这些面板子矩阵上调用 BLAS-3，无需任何打包操作。**\n\n这种布局使得每个面板 $A(:, j:j+b-1)$ 成为一个单一的连续内存块。这将使得通常是内存受限的面板分解步骤变得极快。\n\n然而，它使得计算上占主导地位的拖尾矩阵更新变得极其低效。拖尾矩阵，例如 $A(k:m, k':n)$，是由许多不同面板的切片组成的，这些面板在内存中非连续存储。例如，子矩阵 $A(k:m, k':k'+b-1)$ 将是一个面板的切片，而 $A(k:m, k'+b:k'+2b-1)$ 将是内存中完全不同且不相邻的另一个面板的切片。标准的 BLAS-3 调用无法在这样碎片化的数据结构上操作。人们不能“直接在这些面板子矩阵上调用 BLAS-3”。执行更新的唯一方法是在每次 BLAS-3 调用之前将拖尾矩阵的相关部分收集到一个连续的缓冲区中，然后将结果散布回去，这将产生过高的开销。这种布局以牺牲关键的、计算密集型部分为代价，优化了算法中错误的部分。\n\n**结论：错误**\n\n**结论**\n\n选项 B 是唯一一个为递归分块算法中的数据局部性问题提供全面且切实可行解决方案的选项。通过转换为瓦片数据布局，它确保了计算密集型的 BLAS-3 更新在密集的、连续的数据块上操作，从而最大化性能并使算法对初始存储格式具有鲁棒性。", "answer": "$$\\boxed{B}$$", "id": "3534911"}, {"introduction": "理论模型可以指导我们估算最优的分块大小，但实际硬件的复杂性使得精确预测变得困难。最终，衡量性能的唯一标准是真实世界的运行时间。这个练习将带你进入性能工程的最前沿：设计一个在线自动调优（online auto-tuning）系统的仿真实验。你将利用一个基于性能计数器的反馈控制律，在充满噪声的测量环境中动态调整LU分解的块大小，使其自动收敛到接近最优的性能点，而无需事先知道缓存的确切参数。[@problem_id:3534891]", "problem": "设计并实现一个完整的、可运行的程序，该程序在一个理想化的内存层次模型下，模拟一个用于分块 LU 分解（带部分主元）的在线块大小自适应实验。其目标是在执行期间，通过使用报告由缓存未命中派生的流量和已实现带宽的合成性能计数器，来调整块大小 $b$，并应用一个有原则的控制律，使其收敛到一个对于给定理想缓存容量 $M$（以元素为单位）和缓存行或块长度 $B$（以元素为单位）而言的次优块大小 $b^{\\star}(M,B)$。程序必须为提供的测试套件输出一行聚合的测试结果。\n\n该实验的基础必须是以下经过充分测试的核心模型和定义。\n\n- 外存（理想缓存）模型：一个容量为 $M$ 个元素、块长度为 $B$ 个元素的理想缓存，以 $B$ 个元素的对齐块为单位处理数据传输。计算成本由快速和慢速内存之间因缓存未命中引起的块传输次数来衡量。该模型假设全相联和最佳替换策略。\n- 分块线性代数：在对一个 $n \\times n$ 的稠密矩阵进行带部分主元的分块 LU 分解时，拖尾矩阵更新主导了成本，并且由宽度为 $b$ 的瓦片（tile）的矩阵-矩阵乘积组成。LU 分解的总浮点运算次数为 $\\tfrac{2}{3} n^{3}$，与 $b$ 无关，但数据移动量强烈依赖于 $b$。\n- 最佳分块启发式方法：为了捕捉瓦片复用，三个瓦片的工作集大小 $3 b^{2}$ 应能容纳在快速内存中，这启发式地表明 $b^{\\star} \\approx \\sqrt{M/3}$ 是一个次优的块大小，之后需将其调整到 $B$ 的一个可行的离散倍数并强制执行边界。\n\n为了使实验自包含且可测试，您将不实现 LU 分解。取而代之的是，您将在每次迭代中模拟一个固定大小的“工作单元”，以代表拖尾更新，并根据第一性原理合成性能计数器和时间模型，如下所示。\n\n- 符号和单位：\n  - $n$：问题大小（矩阵维度，一个正整数）。\n  - $M$：理想缓存容量，单位为元素（每个元素是 $8$ 字节的浮点数）。\n  - $B$：缓存块长度，单位为元素（一个正整数）。\n  - $b$：决策变量，面板宽度或瓦片大小（一个正整数，限制为 $B$ 的倍数）。\n  - $P$：峰值浮点吞吐量，单位为每秒浮点运算次数（一个正实数）。\n  - $\\mathrm{BW}$：峰值内存带宽，单位为每秒字节数（一个正实数）。\n  - $q$：容量未命中惩罚指数（一个正实数，在测试套件中使用 $q=2$）。\n  - $F$：每次迭代的浮点工作量，单位为浮点运算次数（一个依赖于 $n$ 的常数，与 $b$ 无关，用于模拟对于 LU 拖尾更新的一个可比块，其算术工作量在不同块大小下是固定的）。\n  - $\\phi(b;M)$：由于超出快速内存容量导致数据流量的容量放大因子。\n\n- 每次迭代的代理模型：\n  - 算术工作量：$F = n^{3}$ 次浮点运算。这个选择是每次迭代的一个固定正常数，以反映 LU 拖尾更新“块”的总算术工作量不依赖于 $b$。\n  - 数据移动量（以元素为单位）：对于能容纳在快速内存中的瓦片，标准的分块矩阵乘法模型得出的数据移动量与 $n^{3}/b$ 成正比。因此，我们定义基准元素流量为\n    $$X_{0}(b;n) = \\alpha \\frac{n^{3}}{b}, \\quad \\text{with } \\alpha = 2.$$\n  - 容量放大：定义\n    $$\\phi(b;M) = \\begin{cases}\n    1,  \\text{if } 3 b^{2} \\le M,\\\\\n    \\left( \\dfrac{3 b^{2}}{M} \\right)^{q},  \\text{if } 3 b^{2}  M.\n    \\end{cases}$$\n    总元素流量为 $X(b;n,M) = X_{0}(b;n) \\, \\phi(b;M)$。\n  - 未命中次数和字节数：每次未命中带来 $B$ 个元素，所以预期的未命中次数为\n    $$\\mathcal{M}(b;n,M,B) = \\frac{X(b;n,M)}{B}.$$\n    传输的总字节数为\n    $$\\mathrm{Bytes}(b;n,M) = 8 \\, X(b;n,M).$$\n  - 时间模型：观察到的每次迭代时间由加法模型给出\n    $$T(b;n,M,B,P,\\mathrm{BW}) = \\frac{F}{P} + \\frac{\\mathrm{Bytes}(b;n,M)}{\\mathrm{BW}}.$$\n    实现的带宽为\n    $$\\widehat{\\mathrm{BW}}(b) = \\frac{\\mathrm{Bytes}(b;n,M)}{T(b;n,M,B,P,\\mathrm{BW})}.$$\n\n- 带噪声的合成计数器：程序必须模拟反映测量不确定性的带噪声的计数器。设 $\\epsilon$ 为标准差为 $\\sigma$（一个小的正实数）的零均值高斯噪声。程序应产生带噪声的测量未命中次数 $\\widehat{\\mathcal{M}}(b) = \\mathcal{M}(b) (1+\\epsilon)$，然后使用这些带噪声的未命中次数来构成一个带噪声的时间估计\n  $$\\widehat{T}(b) = \\frac{F}{P} + \\frac{8 B \\widehat{\\mathcal{M}}(b)}{\\mathrm{BW}},$$\n  以及一个带噪声的已实现带宽\n  $$\\widehat{\\mathrm{BW}}_{\\mathrm{meas}}(b) = \\min\\left(\\mathrm{BW}, \\frac{8 B \\widehat{\\mathcal{M}}(b)}{\\widehat{T}(b)}\\right).$$\n\n控制目标和控制律。\n\n- 目标：在线调整 $b$ 以最小化未知的真实时间 $T(b)$，仅使用带噪声的、由计数器派生的 $\\widehat{T}(b)$、$\\widehat{\\mathcal{M}}(b)$ 和 $\\widehat{\\mathrm{BW}}_{\\mathrm{meas}}(b)$，而无需预先知道 $M$。\n- 可行集：将 $b$ 约束在离散集合 $\\{ B, 2B, 3B, \\dots, b_{\\max} \\}$ 中，其中 $b_{\\max}$ 是给定的上界，并确保 $b \\le n$。\n- 次优参考值：定义次优连续值 $b^{\\star}_{\\mathrm{cont}}(M) = \\sqrt{M/3}$ 和离散调整后的次优值\n  $$b^{\\star}(M,B) = \\operatorname{round}_{B}\\!\\Big( \\min\\{ b_{\\max}, \\max\\{ B, b^{\\star}_{\\mathrm{cont}}(M) \\}\\} \\Big),$$\n  其中 $\\operatorname{round}_{B}$ 调整到最接近的 $B$ 的倍数。\n\n- 控制律：实现一个由带噪声的估计时间驱动的两点极值寻求符号下降方案。在控制器迭代 $t$ 时，给定当前 $b_{t}$ 和探测振幅 $\\delta$（$B$ 的一个正倍数），形成两个探测点 $b_{t}^{+} = \\Pi(b_{t} + \\delta)$ 和 $b_{t}^{-} = \\Pi(b_{t} - \\delta)$，其中 $\\Pi$ 投影到可行的离散集上。通过合成计数器测量 $\\widehat{T}(b_{t}^{+})$ 和 $\\widehat{T}(b_{t}^{-})$。如果 $\\widehat{T}(b_{t}^{+})  \\widehat{T}(b_{t}^{-})$，则更新 $b_{t+1} = \\Pi(b_{t} + s)$；否则更新 $b_{t+1} = \\Pi(b_{t} - s)$，其中 $s$ 是 $B$ 的一个正整数倍，可以随时间减小以实现收敛（例如，对于某个正数 $s_{0},\\tau$，有 $s = \\max\\{B, \\lfloor s_{0}/(1+t/\\tau)\\rfloor\\}$）。该控制律使用有限差分方向导数估计的符号，在温和的单峰性假设下向最小值下降。\n\n测试套件和验收标准。\n\n为以下测试用例实现实验。在每种情况下，从 $b_{0}$ 开始运行控制器 $T_{\\mathrm{iters}}$ 次迭代，探测振幅 $\\delta = B$，初始步长 $s_{0} = 4B$，步长调度 $s = \\max\\{B, \\lfloor s_{0}/(1+t/10)\\rfloor\\}$，指数 $q=2$，以及指定的噪声标准差 $\\sigma$。对所有测试使用 $b_{\\max} = 512$。对于每种情况，如果最终的 $b$ 在 $b^{\\star}(M,B)$ 的相对容差 $\\rho = 0.15$ 内，即 $\\lvert b_{\\mathrm{final}} - b^{\\star}(M,B) \\rvert \\le \\rho \\, b^{\\star}(M,B)$，则宣布成功，并约定如果 $b^{\\star}(M,B)=B$，则使用绝对容差 $B$。\n\n- 情况 A（理想路径）：$(n,M,B,P,\\mathrm{BW},b_{0},T_{\\mathrm{iters}},\\sigma) = (\\,2048,\\,3\\cdot 128^{2},\\,8,\\,10^{12},\\,2\\cdot 10^{11},\\,32,\\,30,\\,0.02\\,)$.\n- 情况 B（起始值过大）：$(n,M,B,P,\\mathrm{BW},b_{0},T_{\\mathrm{iters}},\\sigma) = (\\,2048,\\,3\\cdot 32^{2},\\,8,\\,10^{12},\\,2\\cdot 10^{11},\\,256,\\,30,\\,0.02\\,)$.\n- 情况 C（非方形目标）：$(n,M,B,P,\\mathrm{BW},b_{0},T_{\\mathrm{iters}},\\sigma) = (\\,4096,\\,3\\cdot 200^{2},\\,8,\\,10^{12},\\,2\\cdot 10^{11},\\,16,\\,35,\\,0.03\\,)$.\n- 情况 D（大容量）：$(n,M,B,P,\\mathrm{BW},b_{0},T_{\\mathrm{iters}},\\sigma) = (\\,4096,\\,3\\cdot 400^{2},\\,8,\\,10^{12},\\,2\\cdot 10^{11},\\,64,\\,35,\\,0.02\\,)$.\n- 情况 E（边界情况, $b^{\\star} = B$)：$(n,M,B,P,\\mathrm{BW},b_{0},T_{\\mathrm{iters}},\\sigma) = (\\,1024,\\,3\\cdot 4^{2},\\,8,\\,10^{12},\\,2\\cdot 10^{11},\\,64,\\,30,\\,0.02\\,)$.", "solution": "该问题要求设计并实现一个仿真程序，以研究分块 LU 分解中块大小 $b$ 的在线自适应方案。目标是通过在理想化的内存层次模型中使用带噪声的性能计数器，动态调整 $b$ 以最小化执行时间。解决方案涉及指定性能模型、控制律和仿真框架。\n\n### 1. 性能与时间建模\n\n该仿真的基础是关于执行时间 $T(b)$ 作为块大小 $b$ 的函数的量化模型。该模型基于计算机体系结构和数值线性代数的第一性原理。总时间是计算所用时间和数据移动所用时间的总和：\n$$T(b) = T_{\\mathrm{compute}} + T_{\\mathrm{memory}}$$\n\n问题为 LU 分解的拖尾矩阵更新的“工作单元”指定了一个代理模型。\n\n**算术时间 ($T_{\\mathrm{compute}}$):**\n一个 $n \\times n$ LU 分解的总浮点运算（FLOPs）次数为 $\\mathcal{O}(n^3)$，并且这个算术工作量很大程度上与块大小 $b$ 无关。因此，问题将每次迭代的工作量建模为一个恒定值 $F = n^3$ FLOPs。给定峰值浮点吞吐量为 $P$ FLOPs/秒，计算时间为：\n$$T_{\\mathrm{compute}} = \\frac{F}{P} = \\frac{n^3}{P}$$\n\n**内存访问时间 ($T_{\\mathrm{memory}}$):**\n内存时间由慢速和快速内存之间传输的总数据量 $\\mathrm{Bytes}(b)$ 和峰值内存带宽 $\\mathrm{BW}$ 决定。\n$$T_{\\mathrm{memory}}(b) = \\frac{\\mathrm{Bytes}(b; n, M)}{\\mathrm{BW}}$$\n传输的总字节数取决于元素流量 $X(b; n, M)$，其中每个元素是一个 $8$ 字节的浮点数：\n$$\\mathrm{Bytes}(b; n, M) = 8 \\cdot X(b; n, M)$$\n元素流量 $X(b; n, M)$ 被建模为基准流量项 $X_0(b; n)$ 和容量放大因子 $\\phi(b; M)$ 的乘积。\n$$X(b; n, M) = X_0(b; n) \\cdot \\phi(b; M)$$\n\n**基准流量 ($X_0$):**\n对于主导 LU 分解的分块矩阵算法（如矩阵乘法），当进行最优分块时，$\\mathcal{O}(n^3)$ 计算的内存访问次数为 $\\mathcal{O}(n^3 / \\sqrt{M})$。对于一个次优的块大小 $b$，流量为 $\\mathcal{O}(n^3/b)$。问题将其形式化为：\n$$X_0(b; n) = \\alpha \\frac{n^3}{b}, \\quad \\text{with the constant } \\alpha = 2$$\n\n**容量放大 ($\\phi$):**\n该因子模拟了当算法的工作集超过缓存容量 $M$ 时的性能下降。对于 LU 核心的矩阵-矩阵乘法，工作集由三个 $b \\times b$ 的瓦片组成，需要 $3b^2$ 个元素的内存足迹。获得最佳性能的启发式方法是将此工作集保持在缓存内，即 $3b^2 \\le M$。如果违反此条件，缓存未命中次数将急剧增加。这通过惩罚函数 $\\phi(b; M)$ 进行建模：\n$$\\phi(b;M) = \\begin{cases}\n1,  \\text{if } 3 b^{2} \\le M, \\\\\n\\left( \\dfrac{3 b^{2}}{M} \\right)^{q},  \\text{if } 3 b^{2}  M.\n\\end{cases}$$\n这里，$q$ 是一个正指数，在测试中指定为 $q=2$，用于控制惩罚的严重程度。\n\n**完整的时间模型:**\n结合这些组件，得到每次迭代的真实、理想化执行时间的完整表达式：\n$$T(b; n, M, B, P, \\mathrm{BW}) = \\frac{n^3}{P} + \\frac{8 \\cdot \\left(2 \\frac{n^3}{b}\\right) \\cdot \\phi(b; M)}{\\mathrm{BW}}$$\n该函数预期是单峰的或具有一个明显的最小值。对于小的 $b$（其中 $3b^2 \\le M$ 且 $\\phi=1$），$T(b)$ 主要由 $1/b$ 项决定，并随着 $b$ 的增加而减少。对于大的 $b$（其中 $3b^2  M$），来自 $b^{2q}/b$ 的 $b^{2q-1}$ 项导致 $T(b)$ 迅速增加。最小时间预计出现在工作集恰好适合缓存的点附近，即 $b \\approx \\sqrt{M/3}$。\n\n### 2. 带噪声测量的仿真\n\n在线控制器无法访问真实时间 $T(b)$。相反，它依赖于硬件性能计数器，这些计数器会受到测量噪声的影响。该仿真通过生成带噪声的合成计数器数据来模拟这一点。\n\n缓存未命中的次数 $\\mathcal{M}(b)$ 是总元素流量除以缓存块长度 $B$：\n$$\\mathcal{M}(b;n,M,B) = \\frac{X(b;n,M)}{B}$$\n通过引入零均值高斯噪声 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^2)$ 来模拟一次带噪声的测量 $\\widehat{\\mathcal{M}}(b)$：\n$$\\widehat{\\mathcal{M}}(b) = \\mathcal{M}(b) \\cdot (1 + \\epsilon)$$\n然后，控制器使用这个带噪声的未命中次数来形成自己对总时间 $\\widehat{T}(b)$ 的估计。这反映了一种情景，即控制器可以测量数据移动但不能直接测量计算时间。内存时间分量是根据带噪声的未命中次数重构的：\n$$\\widehat{T}(b) = \\frac{F}{P} + \\frac{8 B \\widehat{\\mathcal{M}}(b)}{\\mathrm{BW}}$$\n这个 $\\widehat{T}(b)$ 作为控制算法试图最小化的带噪声的目标函数。\n\n### 3. 通过极值寻求进行在线控制\n\n目标是找到最小化未知真实时间 $T(b)$ 的块大小 $b$，仅使用对 $\\widehat{T}(b)$ 的序贯、带噪声的测量。问题指定了一个两点极值寻求控制方案，这是一种无模型、实时的优化方法。\n\n**可行集与投影:**\n块大小 $b$ 是一个决策变量，被约束在一个由缓存行大小 $B$ 的正整数倍组成的离散集合中。它还受到最大值 $b_{\\max}$ 和矩阵维度 $n$ 的限制。可行集为 $\\mathcal{B} = \\{ k B \\mid k \\in \\mathbb{Z}, 1 \\le k \\le \\lfloor\\min(b_{\\max}, n)/B\\rfloor \\}$。定义了一个投影算子 $\\Pi$，用于将任何整数映射到 $\\mathcal{B}$ 中最接近的值。\n\n**控制律:**\n控制器在离散时间步 $t=0, 1, 2, \\ldots$ 上运行。在每一步 $t$，给定当前块大小 $b_t$：\n1.  **探测：** 使用一个小的扰动 $\\delta$（指定为 $\\delta=B$）在 $b_t$ 周围探测两个相邻点。探测点为 $b_{t}^{+} = \\Pi(b_{t} + \\delta)$ 和 $b_{t}^{-} = \\Pi(b_{t} - \\delta)$。\n2.  **测量：** 在这两个探测点“测量”带噪声的时间估计，得到 $\\widehat{T}(b_{t}^{+})$ 和 $\\widehat{T}(b_{t}^{-})$。\n3.  **梯度估计：** 差值 $\\widehat{T}(b_{t}^{+}) - \\widehat{T}(b_{t}^{-})$ 的符号提供了目标函数局部梯度的带噪声的估计。\n4.  **更新：** 沿最陡下降方向更新块大小。取一个大小为 $s$ 的步长：\n    - 如果 $\\widehat{T}(b_{t}^{+})  \\widehat{T}(b_{t}^{-})$，函数似乎在减小，所以我们向正方向移动：$b_{t+1} = \\Pi(b_{t} + s)$。\n    - 否则，我们向负方向移动：$b_{t+1} = \\Pi(b_{t} - s)$。\n\n**步长调度:**\n步长 $s$ 会随时间减小，以使控制器能够收敛到一个稳定值，而不是在最小值附近振荡。指定的调度方案为：\n$$s = \\max\\left\\{B, \\left\\lfloor \\frac{s_{0}}{1+t/\\tau} \\right\\rfloor\\right\\}$$\n其中 $s_0$ 是初始步长，$\\tau$ 是控制衰减率的时间常数。在更新规则中使用 $\\Pi$ 确保 $b_{t+1}$ 保持在可行集 $\\mathcal{B}$ 中。\n\n### 4. 评估标准\n\n通过将其最终块大小 $b_{\\mathrm{final}}$ 与理论上的次优值 $b^{\\star}(M,B)$ 进行比较，来评估控制器的性能。该参考值源自 $3b^2 \\le M$ 的启发式方法。\n首先，计算一个连续的最优值：$b^{\\star}_{\\mathrm{cont}}(M) = \\sqrt{M/3}$。\n然后，将其限制在可行范围 $[B, b_{\\max}]$ 内，并调整到最接近的 $B$ 的倍数：\n$$b^{\\star}(M,B) = \\operatorname{round}_{B}\\!\\Big( \\min\\{ b_{\\max}, \\max\\{ B, b^{\\star}_{\\mathrm{cont}}(M) \\}\\} \\Big)$$\n其中 $\\operatorname{round}_{B}(x)$ 将 $x$ 四舍五入到最接近的 $B$ 的倍数。\n\n对于每个测试用例，如果最终块大小 $b_{\\mathrm{final}}$ 在参考值 $b^{\\star}(M,B)$ 的相对容差 $\\rho = 0.15$ 范围内，则仿真被宣告为“成功”：\n$$\\lvert b_{\\mathrm{final}} - b^{\\star}(M,B) \\rvert \\le \\rho \\cdot b^{\\star}(M,B)$$\n如果 $b^{\\star}(M,B) = B$，则适用一个特殊条件：检查是相对于 $B$ 的绝对容差，即 $\\lvert b_{\\mathrm{final}} - B \\rvert \\le B$。由于 $b_{\\mathrm{final}} \\ge B$，这简化为 $b_{\\mathrm{final}} \\le 2B$。\n\n整个程序将为一套测试用例执行此仿真，并为每个用例报告布尔成功标志。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the block-size adaptation experiment for all test cases.\n    \"\"\"\n\n    class ExperimentSimulator:\n        \"\"\"\n        Encapsulates the logic for a single block-size adaptation experiment.\n        \"\"\"\n        def __init__(self, n, M, B, P, BW, b0, T_iters, sigma, q, b_max):\n            # Problem parameters\n            self.n = n\n            self.M = M\n            self.B = B\n            self.P = P\n            self.BW = BW\n            self.b0 = b0\n            self.T_iters = T_iters\n            self.sigma = sigma\n            self.q = q\n            self.b_max = b_max\n            \n            # Derived constants\n            self.F = float(n**3)\n            self.alpha = 2.0\n            self.b_upper_bound = min(self.b_max, self.n)\n            self.b_max_feasible = (self.b_upper_bound // self.B) * self.B\n\n        def _project_b(self, b_val):\n            \"\"\"\n            Projects a block size candidate 'b_val' onto the feasible set.\n            The feasible set consists of multiples of B between B and a max value.\n            \"\"\"\n            # Round to the nearest multiple of B\n            b_rounded = self.B * round(float(b_val) / self.B)\n            # Clamp to the feasible range [B, b_max_feasible]\n            b_projected = max(self.B, min(self.b_max_feasible, b_rounded))\n            return int(b_projected)\n\n        def _capacity_amplification(self, b):\n            \"\"\"Calculates the capacity amplification factor phi(b; M).\"\"\"\n            working_set_size = 3.0 * b**2\n            if working_set_size = self.M:\n                return 1.0\n            else:\n                return (working_set_size / self.M)**self.q\n\n        def get_noisy_time_estimate(self, b):\n            \"\"\"\n            Simulates a noisy measurement of the execution time T-hat(b).\n            \"\"\"\n            # Baseline element traffic\n            x0 = self.alpha * (self.n**3) / b\n            # Total element traffic\n            phi = self._capacity_amplification(b)\n            x_total = x0 * phi\n            \n            # True miss count\n            true_misses = x_total / self.B\n            \n            # Simulate noisy miss measurement\n            noise = np.random.normal(loc=0.0, scale=self.sigma)\n            noisy_misses = true_misses * (1.0 + noise)\n            \n            # Calculate noisy time estimate based on noisy misses\n            t_compute = self.F / self.P\n            t_memory_noisy = (8.0 * self.B * noisy_misses) / self.BW\n            t_hat = t_compute + t_memory_noisy\n            \n            return t_hat\n\n        def run_controller(self):\n            \"\"\"\n            Runs the two-point extremum-seeking control loop.\n            \"\"\"\n            b = self.b0\n            delta = self.B\n            s0 = 4 * self.B\n            tau = 10.0\n\n            for t in range(self.T_iters):\n                # Calculate decaying step size s\n                s_raw = s0 / (1.0 + t / tau)\n                s = int(max(self.B, np.floor(s_raw)))\n\n                # Define and project probe points\n                b_plus = self._project_b(b + delta)\n                b_minus = self._project_b(b - delta)\n                \n                # If probes are identical, we are at an edge; can't get gradient info.\n                # A simple strategy is to make a small random move to escape.\n                # Or just don't move, step size reduction will handle convergence.\n                if b_plus == b_minus:\n                    continue\n\n                # Measure noisy time at probe points\n                t_hat_plus = self.get_noisy_time_estimate(b_plus)\n                t_hat_minus = self.get_noisy_time_estimate(b_minus)\n\n                # Update step based on estimated gradient\n                if t_hat_plus  t_hat_minus:\n                    b = self._project_b(b + s)\n                else:\n                    b = self._project_b(b - s)\n            \n            return b\n\n        def calculate_b_star(self):\n            \"\"\"Calculates the reference near-optimal block size b_star.\"\"\"\n            b_star_cont = (self.M / 3.0)**0.5\n            # Clamp to [B, b_upper_bound]\n            b_clamped = min(self.b_upper_bound, max(self.B, b_star_cont))\n            # Snap to the nearest multiple of B\n            b_star = self.B * round(b_clamped / self.B)\n            # Ensure it is at least B after rounding\n            b_star = max(self.B, b_star)\n            return int(b_star)\n\n        def check_success(self, b_final, b_star):\n            \"\"\"Checks if the final block size is within the tolerance.\"\"\"\n            rho = 0.15\n            if b_star == self.B:\n                # Special absolute tolerance case\n                return abs(b_final - b_star) = self.B\n            else:\n                # Relative tolerance case\n                return abs(b_final - b_star) = rho * b_star\n\n    # Test suite as defined in the problem\n    test_cases = [\n        # Case A (happy path)\n        {'n': 2048, 'M': 3*128**2, 'B': 8, 'P': 1e12, 'BW': 2e11, 'b0': 32, 'T_iters': 30, 'sigma': 0.02},\n        # Case B (start too large)\n        {'n': 2048, 'M': 3*32**2, 'B': 8, 'P': 1e12, 'BW': 2e11, 'b0': 256, 'T_iters': 30, 'sigma': 0.02},\n        # Case C (non-square target)\n        {'n': 4096, 'M': 3*200**2, 'B': 8, 'P': 1e12, 'BW': 2e11, 'b0': 16, 'T_iters': 35, 'sigma': 0.03},\n        # Case D (large capacity)\n        {'n': 4096, 'M': 3*400**2, 'B': 8, 'P': 1e12, 'BW': 2e11, 'b0': 64, 'T_iters': 35, 'sigma': 0.02},\n        # Case E (edge, b* = B)\n        {'n': 1024, 'M': 3*4**2, 'B': 8, 'P': 1e12, 'BW': 2e11, 'b0': 64, 'T_iters': 30, 'sigma': 0.02},\n    ]\n\n    # Global parameters from the problem statement\n    q = 2\n    b_max = 512\n    \n    # Due to the stochastic nature of the simulation, fix the seed for reproducibility.\n    # This ensures the output matches a specific run.\n    np.random.seed(42)\n\n    results = []\n    for params in test_cases:\n        simulator = ExperimentSimulator(**params, q=q, b_max=b_max)\n        \n        b_star = simulator.calculate_b_star()\n        b_final = simulator.run_controller()\n        success = simulator.check_success(b_final, b_star)\n        \n        results.append(str(success))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3534891"}]}