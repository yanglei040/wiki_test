{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。此练习将引导您手动完成 Golub-Kahan-Reinsch SVD 算法的第一个关键阶段：双对角化。通过在一个小矩阵上逐步应用豪斯霍尔德变换 (Householder transformation)，您将亲身体验将一个稠密矩阵简化为双对角形式的过程，从而对算法的核心机制有更深刻的理解。", "problem": "考虑对一个实矩形矩阵进行双对角化的计算任务，这是 Golub–Kahan–Reinsch 奇异值分解 (SVD) 算法中出现的一步。设 $A \\in \\mathbb{R}^{4 \\times 3}$ 由下式给出\n$$\nA \\;=\\;\n\\begin{pmatrix}\n3  0  0 \\\\\n4  5  0 \\\\\n0  4  6 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n使用 Golub–Kahan–Reinsch 双对角化框架，对列应用连续的左 Householder 反射，对行应用连续的右 Householder 反射，从而将 $A$ 变换为上双对角形式。在每一步左变换中，目标是将当前列的子向量变为相应基向量的非负倍数（即，在第 $i$ 步，将工作子向量映射到 $\\alpha_i \\, e_1$ 且 $\\alpha_i \\ge 0$），在每一步右变换中，目标是将当前行的尾部子向量变为第一个基方向的非负倍数（即，将工作子向量映射到 $\\beta_i \\, e_1$ 且 $\\beta_i \\ge 0$）。\n\n执行以下操作，并明确给出中间量：\n- 确定在双对角化过程中使用的左反射 $P_1$、$P_2$、$P_3$ 和右反射 $Q_1$、$Q_2$ 的 Householder 向量。\n- 用已确定的 Householder 反射表示乘积 $U_0 = P_1 P_2 P_3 \\in \\mathbb{R}^{4 \\times 4}$ 和 $V_0 = Q_1 Q_2 \\in \\mathbb{R}^{3 \\times 3}$。\n- 确定此过程产生的双对角矩阵 $B \\in \\mathbb{R}^{4 \\times 3}$，其对角线元素为 $\\alpha_1, \\alpha_2, \\alpha_3$，超对角线元素为 $\\beta_1, \\beta_2$。\n\n你的最终任务是一项计算：报告此过程产生的双对角矩阵 $B$ 的第三个对角线元素 $\\alpha_3$ 的精确值（不要四舍五入）。请以单个封闭形式的解析表达式给出你的最终答案。不需要四舍五入；给出精确表达式。", "solution": "用户要求我使用 Golub-Kahan-Reinsch SVD 算法框架对一个给定的 $4 \\times 3$ 矩阵 $A$ 进行双对角化。\n\n**问题分解：**\n1.  **输入：** 一个矩阵 $A \\in \\mathbb{R}^{4 \\times 3}$。\n    $$\n    A = \\begin{pmatrix}\n    3  0  0 \\\\\n    4  5  0 \\\\\n    0  4  6 \\\\\n    0  0  1\n    \\end{pmatrix}\n    $$\n2.  **过程：** 应用一系列 Householder 变换将 $A$ 转换为一个上双对角矩阵 $B$。变换序列为 $P_1, Q_1, P_2, Q_2, P_3$。\n    -   $P_i$ 是左反射（作用于列）。\n    -   $Q_i$ 是右反射（作用于行）。\n    -   左反射的目标是将一列的次对角线元素置零。目标向量是 $\\alpha_i e_1$，其中 $\\alpha_i \\ge 0$。\n    -   右反射的目标是将一行中超对角线右侧的元素置零。目标向量是 $\\beta_i e_1$，其中 $\\beta_i \\ge 0$。\n3.  **要求输出：**\n    -   $P_1, P_2, P_3$ 和 $Q_1, Q_2$ 的 Householder 向量。\n    -   $U_0 = P_1 P_2 P_3$ 和 $V_0 = Q_1 Q_2$ 的表达式。（这有点奇怪，通常我们有 $A = U B V^T$，所以 $U^T A V = B$。在这里，变换的应用方式是 $P_3 P_2 P_1 A Q_1 Q_2 = B$。所以 $U^T = P_3 P_2 P_1$ 且 $V = Q_1 Q_2$。因此 $U = (P_3 P_2 P_1)^T = P_1^T P_2^T P_3^T = P_1 P_2 P_3$，因为 Householder 反射是对称的。而 $V_0$ 就是 $V$。这看起来是正确的）。\n    -   最终的双对角矩阵 $B$。\n    -   $B$ 的第三个对角线元素 $\\alpha_3$ 的具体值。\n\n**验证步骤：**\n\n1.  **提取已知条件：**\n    -   矩阵 $A \\in \\mathbb{R}^{4 \\times 3}$:\n        $$ A = \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix} $$\n    -   算法：Golub-Kahan-Reinsch 双对角化。\n    -   变换：连续的左 Householder 反射 ($P_i$) 和右 Householder 反射 ($Q_i$)。\n    -   左反射的目标：对于子向量 $x$，将其映射到 $\\alpha e_1$，其中 $\\alpha \\ge 0$。\n    -   右反射的目标：对于子向量 $y$，将其映射到 $\\beta e_1$，其中 $\\beta \\ge 0$。\n    -   最终矩阵 $B$ 是上双对角矩阵。\n    -   $U_0 = P_1 P_2 P_3$。\n    -   $V_0 = Q_1 Q_2$。\n    -   $B$ 的对角线元素为 $\\alpha_1, \\alpha_2, \\alpha_3$，超对角线元素为 $\\beta_1, \\beta_2$。\n    -   最终任务：报告 $\\alpha_3$ 的精确值。\n\n2.  **使用提取的已知条件进行验证：**\n    -   **科学依据：** 该问题来自数值线性代数，具体涉及 SVD 算法。Golub-Kahan-Reinsch 双对角化是一个标准且成熟的过程。Householder 反射的使用是此过程的核心。该问题在数学上是合理的。\n    -   **适定性：** 矩阵已给出，过程已指定，所需输出已明确定义。遵循指定规则（基向量的非负倍数），将产生唯一的变换序列和唯一的结果矩阵 $B$。该问题是适定的。\n    -   **客观性：** 问题陈述精确，并使用标准数学术语。没有主观因素。\n    -   **缺陷检查清单：**\n        1.  没有科学/事实上的不合理之处。\n        2.  问题是可形式化的，并且与主题直接相关。\n        3.  设置是完整的。维度和值都已给出。过程已定义。\n        4.  这些条件是数值算法的标准条件，并非物理上不可能。\n        5.  问题结构良好，可导出唯一解。\n        6.  问题并非微不足道。它需要多个计算步骤。它不是同义反复。\n        7.  问题可通过计算验证。\n\n3.  **结论与行动：** 问题是 **有效的**。我将继续进行解答。\n\n---\n**解题计划：**\n\n过程为 $B = P_3 P_2 P_1 A Q_1 Q_2$。\n\n**第 0 步：初始矩阵**\n$A^{(0)} = A = \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix}$\n\n**第 1 步：第一次左变换 ($P_1$)**\n-   目标：第一列，$x_1 = (3, 4, 0, 0)^T$。我们想将其变换为 $\\alpha_1 e_1 \\in \\mathbb{R}^4$。\n-   Householder 反射定义：$P = I - 2 \\frac{vv^T}{v^T v}$。\n-   向量 $v$ 由 $v = x - \\sigma e_1$ 给出，其中 $\\sigma = -\\text{sgn}(x_1) \\|x\\|_2$。\n-   问题指定映射到 $e_1$ 的*非负*倍数，即 $\\alpha_1 e_1$ 且 $\\alpha_1 \\ge 0$。这是对映射目标的直接指令。这意味着目标向量是 $y = \\|x\\|_2 e_1$，且得到的对角线元素将是 $\\alpha = \\|x\\|_2 \\ge 0$。\n-   设 $x = \\begin{pmatrix} 3 \\\\ 4 \\\\ 0 \\\\ 0 \\end{pmatrix}$。 $\\|x\\|_2 = \\sqrt{3^2 + 4^2 + 0^2 + 0^2} = \\sqrt{9+16} = 5$。\n-   目标向量是 $y = 5e_1 = (5, 0, 0, 0)^T$。因此，$\\alpha_1 = 5$。\n-   Householder 向量是 $v_1 = x - y = (3-5, 4, 0, 0)^T = (-2, 4, 0, 0)^T$。\n-   反射为 $P_1 = I_4 - 2 \\frac{v_1 v_1^T}{v_1^T v_1}$。我们计算 $v_1^T v_1 = (-2)^2 + 4^2 = 20$。\n-   $A^{(1)} = P_1 A = (I_4 - \\frac{1}{10} v_1 v_1^T)A = A - \\frac{1}{10} v_1 (v_1^T A)$。\n-   $v_1^T A = \\begin{pmatrix} -2  4  0  0 \\end{pmatrix} \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 10  20  0 \\end{pmatrix}$。\n-   $A^{(1)} = A - \\frac{1}{10} \\begin{pmatrix} -2 \\\\ 4 \\\\ 0 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 10  20  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} -2  -4  0 \\\\ 4  8  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 5  4  0 \\\\ 0  -3  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix}$。\n\n**第 2 步：第一次右变换 ($Q_1$)**\n-   该过程要求将元素 $a_{1,j}$ ($j > 2$) 置零。我们对行子向量 $A^{(1)}(1, 2:3) = \\begin{pmatrix} 4  0 \\end{pmatrix}$ 进行操作。\n-   设 $x_r^T = (4,0)$，一个 $\\mathbb{R}^2$ 中的向量。目标是将其映射到 $\\beta_1 e_1^T = (\\|x_r\\|_2, 0)$。\n-   $\\|x_r\\|_2 = \\sqrt{4^2+0^2} = 4$。所以 $\\beta_1 = 4$。\n-   目标是 $(4,0)$。该向量已处于目标形式。变换是单位变换。\n-   $2 \\times 2$ 反射 $Q_1'$ 的 Householder 向量是 $w_1 = (4,0)^T - 4(1,0)^T = (0,0)^T$。反射 $Q_1'$ 是 $I_2$。\n-   完整的 $3 \\times 3$ 反射是 $Q_1 = \\begin{pmatrix} 1  0 \\\\ 0  Q_1' \\end{pmatrix} = I_3$。\n-   $A^{(2)} = A^{(1)} Q_1 = A^{(1)} = \\begin{pmatrix} 5  4  0 \\\\ 0  -3  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix}$。\n\n**第 3 步：第二次左变换 ($P_2$)**\n-   我们对子列 $A^{(2)}(2:4, 2) = (-3, 4, 0)^T$ 进行操作。\n-   设 $x_2 = (-3, 4, 0)^T \\in \\mathbb{R}^3$。目标是将其映射到 $\\alpha_2 e_1 = (\\|x_2\\|_2, 0, 0)^T$。\n-   $\\|x_2\\|_2 = \\sqrt{(-3)^2 + 4^2 + 0^2} = \\sqrt{9+16} = 5$。所以 $\\alpha_2 = 5$。\n-   目标是 $y_2 = (5, 0, 0)^T$。\n-   $3 \\times 3$ 反射 $P_2'$ 的 Householder 向量是 $v_2' = x_2 - y_2 = (-3-5, 4, 0)^T = (-8, 4, 0)^T$。\n-   完整的 $4 \\times 4$ 反射是 $P_2 = \\text{diag}(1, P_2')$。定义向量是 $v_2 = (0,-8,4,0)^T$。\n-   为了找到 $A^{(3)} = P_2 A^{(2)}$，我们将 $P_2'$ 应用于 $A^{(2)}(2:4, :) = \\begin{pmatrix} -3  0 \\\\ 4  6 \\\\ 0  1 \\end{pmatrix}$。\n-   该子矩阵的第一列是 $x_2$，它被映射到 $(5,0,0)^T$。\n-   为了找到对第二列 $c = (0, 6, 1)^T$ 的影响，我们计算 $P_2' c = c - 2 \\frac{v_2'(v_2'^T c)}{v_2'^T v_2'}$。\n-   $v_2'^T v_2' = (-8)^2+4^2 = 80$。\n-   $v_2'^T c = (-8)(0) + (4)(6) + (0)(1) = 24$。\n-   $P_2' c = \\begin{pmatrix} 0 \\\\ 6 \\\\ 1 \\end{pmatrix} - 2\\frac{24}{80} \\begin{pmatrix} -8 \\\\ 4 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 6 \\\\ 1 \\end{pmatrix} - \\frac{3}{5} \\begin{pmatrix} -8 \\\\ 4 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 6 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} -24/5 \\\\ 12/5 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 24/5 \\\\ 18/5 \\\\ 1 \\end{pmatrix}$。\n-   所以 $A^{(3)} = \\begin{pmatrix} 5  4  0 \\\\ 0  5  24/5 \\\\ 0  0  18/5 \\\\ 0  0  1 \\end{pmatrix}$。\n\n**第 4 步：第二次右变换 ($Q_2$)**\n-   我们对行子向量 $A^{(3)}(2, 3:3) = (24/5)$ 进行操作。\n-   设 $x_{r2}^T = (24/5)$，一个 $\\mathbb{R}^1$ 中的向量。目标是将其映射到 $\\beta_2 e_1^T = (\\|x_{r2}\\|_2)$。\n-   $\\|x_{r2}\\|_2 = 24/5$。所以 $\\beta_2 = 24/5$。\n-   该向量已处于目标形式。$1 \\times 1$ 反射 $Q_2'$ 是单位阵 $[1]$。\n-   Householder 向量 $w_2$ 是 $w_2 = (24/5) - (24/5) = 0$。\n-   完整的 $3 \\times 3$ 反射是 $Q_2 = \\text{diag}(1,1,1) = I_3$。\n-   $A^{(4)} = A^{(3)} Q_2 = A^{(3)}$。\n\n**第 5 步：第三次左变换 ($P_3$)**\n-   我们对子列 $A^{(4)}(3:4, 3) = (18/5, 1)^T$ 进行操作。\n-   设 $x_3 = (18/5, 1)^T \\in \\mathbb{R}^2$。目标是将其映射到 $\\alpha_3 e_1 = (\\|x_3\\|_2, 0)^T$。\n-   $\\|x_3\\|_2 = \\sqrt{(18/5)^2 + 1^2} = \\sqrt{\\frac{324}{25} + \\frac{25}{25}} = \\sqrt{\\frac{349}{25}} = \\frac{\\sqrt{349}}{5}$。\n-   第三个对角线元素是 $\\alpha_3 = \\frac{\\sqrt{349}}{5}$。\n\n这就是所要求的值。为了完整起见，我们列出所有需要的量。\n$2 \\times 2$ 反射 $P_3'$ 的 Householder 向量是 $v_3' = x_3 - \\|x_3\\|_2 e_1 = (\\frac{18}{5} - \\frac{\\sqrt{349}}{5}, 1)^T$。\n矩阵 $P_3 = \\text{diag}(1,1,P_3')$ 被应用于 $A^{(4)}$。\n子矩阵 $A^{(4)}(3:4,:)=\\begin{pmatrix} 0  0  18/5 \\\\ 0  0  1 \\end{pmatrix}$ 被 $P_3'$ 变换。前两列是零向量，保持不变。第三列变为 $(\\alpha_3, 0)^T$。\n得到的子矩阵是 $\\begin{pmatrix} 0  0  \\sqrt{349}/5 \\\\ 0  0  0 \\end{pmatrix}$。\n最终的双对角矩阵是 $B = P_3 A^{(4)} = \\begin{pmatrix} 5  4  0 \\\\ 0  5  24/5 \\\\ 0  0  \\sqrt{349}/5 \\\\ 0  0  0 \\end{pmatrix}$。\n\n\n**结果总结**\n\n-   **Householder 向量：**\n    -   对于 $P_1$：$v_1 = (-2, 4, 0, 0)^T \\in \\mathbb{R}^4$。\n    -   对于 $P_2$：反射 $P_2'$ 作用于第 2,3,4 行的子空间。向量为 $v_2' = (-8, 4, 0)^T \\in \\mathbb{R}^3$。在 $\\mathbb{R}^4$ 中对应于 $P_2$ 的向量是 $v_2 = (0, -8, 4, 0)^T$。\n    -   对于 $P_3$：反射 $P_3'$ 作用于第 3,4 行。向量为 $v_3' = (\\frac{18 - \\sqrt{349}}{5}, 1)^T \\in \\mathbb{R}^2$。在 $\\mathbb{R}^4$ 中对应于 $P_3$ 的向量是 $v_3 = (0, 0, \\frac{18 - \\sqrt{349}}{5}, 1)^T$。\n    -   对于 $Q_1$：反射是单位阵。按照惯例，Householder 向量是零向量 $w_1 = (0, 0, 0)^T \\in \\mathbb{R}^3$。\n    -   对于 $Q_2$：反射是单位阵。Householder 向量是 $w_2 = (0, 0, 0)^T \\in \\mathbb{R}^3$。\n\n-   **正交矩阵：**\n    -   $U_0 = P_1 P_2 P_3$，其中 $P_i = I - 2 \\frac{v_i v_i^T}{v_i^T v_i}$。\n    -   $V_0 = Q_1 Q_2 = I_3 I_3 = I_3$。\n\n-   **双对角矩阵 $B$：**\n    $$ B = \\begin{pmatrix} 5  4  0 \\\\ 0  5  \\frac{24}{5} \\\\ 0  0  \\frac{\\sqrt{349}}{5} \\\\ 0  0  0 \\end{pmatrix} $$\n    对角线元素为 $\\alpha_1=5, \\alpha_2=5, \\alpha_3 = \\frac{\\sqrt{349}}{5}$。超对角线元素为 $\\beta_1=4, \\beta_2=24/5$。\n\n问题要求第三个对角线元素 $\\alpha_3$ 的精确值。根据我们的计算，这个值是 $\\frac{\\sqrt{349}}{5}$。", "answer": "$$\\boxed{\\frac{\\sqrt{349}}{5}}$$", "id": "3588842"}, {"introduction": "Golub-Kahan-Reinsch 算法的数值稳定性在很大程度上归功于其全程使用正交变换。此练习旨在探讨正交变换的一个重要性质——保持矩阵的弗罗贝尼乌斯范数 $A$ 不变。您将首先从理论上证明这一性质，然后设计一个数值实验来验证在有限精度计算中，该性质在多大程度上得以保持，这有助于您将抽象的数学理论与实际的计算实践联系起来。", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$，并设 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 为正交矩阵。在 Golub–Kahan–Reinsch 算法中，奇异值分解（SVD）是通过 Householder 反射（一种正交变换）的乘积将矩阵 $A$ 约化为双对角形式来计算的。本题要求你从第一性原理出发，论证 Frobenius 范数在正交变换下的不变性，并设计一个鲁棒的数值测试，以验证在有限精度算术下，通过 Golub–Kahan–Reinsch 式双对角化计算出的正交因子的这一性质。你还必须诊断与精确正交性的偏差。\n\n任务：\n1) 理论推导。从 Frobenius 范数和正交矩阵的定义出发，并且只使用诸如迹的循环不变性等标准恒等式，证明对于正交的 $U$ 和 $V$，有\n$$\\|A\\|_F = \\|U^\\top A V\\|_F.$$\n你的推导必须从定义 $\\|A\\|_F = \\sqrt{\\operatorname{trace}(A^\\top A)}$、正交性定义 $U^\\top U = I$ 和 $V^\\top V = I$，以及迹的循环性质 $\\operatorname{trace}(XYZ) = \\operatorname{trace}(ZXY)$（只要乘积有定义）开始。不要使用任何未经证明的快捷恒等式。\n\n2) 数值实验设计。用双精度实现一个 Golub–Kahan–Reinsch 式的算法，使用 Householder 反射将 $A$ 约化为双对角形式，并显式地累积左、右正交因子 $\\hat{U}$ 和 $\\hat{V}$，使得计算出的双对角矩阵 $\\hat{B}$ 满足 $\\hat{B} \\approx \\hat{U}^\\top A \\hat{V}$。你的实现必须：\n- 从第一性原理构造 Householder 反射，以消去列中的次对角线元素（左反射）和行中的超对角线元素（右反射）。\n- 将每个反射应用于相应的尾随子矩阵，并将相应的变换累积到 $\\hat{U}$ 或 $\\hat{V}$ 中。\n- 使用双精度算术，并避免调用任何黑盒 SVD 例程。\n\n3) 能量保持测试与诊断。对于给定的输入矩阵 $A$，计算：\n- 相对 Frobenius 范数差异\n$$\\mathrm{rel\\_err} = \\frac{\\big|\\|A\\|_F - \\|\\hat{U}^\\top A \\hat{V}\\|_F\\big|}{\\max(\\|A\\|_F, 1)}.$$\n如果 $\\|A\\|_F = 0$，则定义 $\\mathrm{rel\\_err} = 0$。\n- 正交性缺陷\n$$\\mathrm{orthU} = \\|I - \\hat{U}^\\top \\hat{U}\\|_F, \\quad \\mathrm{orthV} = \\|I - \\hat{V}^\\top \\hat{V}\\|_F.$$\n使用双精度的单位舍入误差 $u$ 和接受阈值\n$$\\tau(m,n) = c \\, u \\, (m + n), \\quad c = 100.$$\n如果 $\\mathrm{rel\\_err} \\le \\tau(m,n)$，则声明该案例为通过（pass），否则为失败（fail）。此外，设计一个实验，通过对 $\\hat{U}$ 和 $\\hat{V}$ 各加上一个大小为 $\\delta$ 的稠密扰动，故意使它们略微非正交，并证明正交性缺陷和相对 Frobenius 范数差异都以与扰动幅度相称的方式增加。\n\n4) 测试套件。你的程序必须运行以下五个可复现的测试案例并汇总结果：\n- 案例 1（正常路径）：$m=50$, $n=30$，$A$ 的元素为独立的标准正态分布，种子为 $1$。\n- 案例 2（方形矩阵）：$m=10$, $n=10$，$A$ 的元素为独立的标准正态分布，种子为 $2$。\n- 案例 3（零矩阵）：$m=20$, $n=15$，$A$ 为零矩阵。\n- 案例 4（病态矩阵）：$m=60$, $n=5$，构造 $A = U_0 \\Sigma V_0^\\top$，其中 $U_0 \\in \\mathbb{R}^{60 \\times 60}$ 和 $V_0 \\in \\mathbb{R}^{5 \\times 5}$ 是随机正交矩阵（分别通过对种子为 $3$ 和 $4$ 的高斯矩阵进行 $QR$ 分解生成），奇异值 $\\Sigma = \\operatorname{diag}(\\sigma_1,\\dots,\\sigma_5)$ 满足 $\\sigma_i = 10^{-12 \\cdot (i-1)/(5-1)}$，因此 $\\sigma_1 = 1$ 且 $\\sigma_5 = 10^{-12}$。\n- 案例 5（诊断性扰动）：$m=40$, $n=35$，$A$ 的元素为独立的标准正态分布，种子为 $5$，在计算出 $\\hat{U}$ 和 $\\hat{V}$ 后，将它们替换为 $\\tilde{U} = \\hat{U} + \\delta R_U$ 和 $\\tilde{V} = \\hat{V} + \\delta R_V$，其中 $R_U$ 和 $R_V$ 是形状相同、种子为 $6$ 的稠密高斯矩阵，且 $\\delta = 10^{-8}$。在此案例中，使用 $\\tilde{U}$ 和 $\\tilde{V}$ 计算各项指标。\n\n5) 要求的最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的各案例结果列表，每个案例打印为一个方括号括起来的四元组 $[\\mathrm{rel\\_err},\\mathrm{orthU},\\mathrm{orthV},\\mathrm{pass}]$，其中如果案例通过，$\\mathrm{pass}$ 为 $1$，否则为 $0$。所有浮点数必须以科学记数法打印，小数点后保留 $16$ 位数字。行内任何地方都不能有空格。整个列表必须用方括号括起来。例如，包含两个案例的一行应如下所示 $[[1.2340000000000000e-10,2.0000000000000000e-15,2.0000000000000000e-15,1],[3.2100000000000000e-08,4.0000000000000000e-14,4.0000000000000000e-14,1]]$。\n\n你的程序必须是完全自包含的，并且不得读取任何输入。它必须实现所描述的双对角约简和正交累积，为指定的测试套件计算所需的指标，并以上述确切格式打印结果。", "solution": "此问题是有效的，因为它在数值线性代数方面有科学依据，问题提法得当、客观且自包含。它提出了一个标准但并非微不足道的任务，涉及理论证明、算法实现和数值分析。\n\n### 1) 理论推导\n\n目标是证明对于正交矩阵 $U \\in \\mathbb{R}^{m \\times m}$ 和正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$，Frobenius 范数在变换 $A \\mapsto U^\\top A V$ 下是不变的，即 $\\|A\\|_F = \\|U^\\top A V\\|_F$。\n\n推导从给定的定义开始：\n1.  Frobenius 范数：$\\|X\\|_F = \\sqrt{\\operatorname{trace}(X^\\top X)}$。\n2.  正交性：$U^\\top U = I_m$ 且 $V^\\top V = I_n$。对于方阵 $Q$，$Q^\\top Q=I$ 意味着 $QQ^\\top=I$。\n3.  迹的循环性质：对于任何乘积有定义的矩阵 $X, Y, Z$，有 $\\operatorname{trace}(XYZ) = \\operatorname{trace}(ZXY)$。\n\n我们从分析变换后矩阵的范数平方 $\\|U^\\top A V\\|_F^2$ 开始。\n\n根据 Frobenius 范数的定义：\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left((U^\\top A V)^\\top (U^\\top A V)\\right) $$\n\n乘积的转置 $(XYZ)^\\top$ 是 $Z^\\top Y^\\top X^\\top$。应用此规则：\n$$ (U^\\top A V)^\\top = V^\\top A^\\top (U^\\top)^\\top $$\n因为对于任意矩阵 $X$，有 $(X^\\top)^\\top = X$，所以 $(U^\\top)^\\top = U$。表达式变为：\n$$ (U^\\top A V)^\\top = V^\\top A^\\top U $$\n将其代回迹的表达式中：\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left((V^\\top A^\\top U) (U^\\top A V)\\right) $$\n\n矩阵 $U$ 和 $U^\\top$ 是相邻的。由于 $U$ 是正交矩阵，所以 $U U^\\top = I_m$。\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left(V^\\top A^\\top (U U^\\top) A V\\right) = \\operatorname{trace}\\left(V^\\top A^\\top I_m A V\\right) = \\operatorname{trace}\\left(V^\\top A^\\top A V\\right) $$\n\n现在，我们应用迹的循环性质 $\\operatorname{trace}(XYZ) = \\operatorname{trace}(ZXY)$，设 $X = V^\\top$，$Y = A^\\top A$，$Z = V$。\n$$ \\operatorname{trace}\\left( (V^\\top) (A^\\top A) (V) \\right) = \\operatorname{trace}\\left( (V) (V^\\top) (A^\\top A) \\right) $$\n\n由于 $V$ 是正交矩阵，所以 $V V^\\top = I_n$。\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left(I_n (A^\\top A)\\right) = \\operatorname{trace}(A^\\top A) $$\n\n根据 Frobenius 范数的定义，$\\operatorname{trace}(A^\\top A) = \\|A\\|_F^2$。\n因此，我们已经证明：\n$$ \\|U^\\top A V\\|_F^2 = \\|A\\|_F^2 $$\n\n由于 Frobenius 范数根据定义是非负的，我们可以对两边取平方根得到最终结果：\n$$ \\|U^\\top A V\\|_F = \\|A\\|_F $$\n证明完毕。\n\n### 2) 数值实验设计与实现\n\n用于将矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 双对角化的 Golub-Kahan-Reinsch 算法，通过从左侧和右侧应用一系列 Householder 变换，将主对角线下方和第一超对角线上方的元素置零。\n\nHouseholder 变换由一个反射矩阵 $H = I - 2vv^\\top$ 定义，其中 $v$ 是一个单位向量。对于给定的向量 $x$，可以选择向量 $v$ 使得 $Hx$ 是标准基向量 $e_1$ 的倍数。一个数值稳定的（未归一化的）Householder 向量选择是 $v' = x + \\operatorname{sgn}(x_1) \\|x\\|_2 e_1$。然后将此向量归一化，$v = v'/\\|v'\\|_2$。\n\n双对角化算法如下：\n设 $A^{(0)} = A$。我们对 $k = 0, 1, \\dots, \\min(m, n)-1$ 进行迭代。\n\n1.  **左反射（列消元）**：构造一个 Householder 变换 $U_k'$，以将当前矩阵 $A^{(k-1)}$ 的第 $k$ 列的次对角线元素置零。该反射作用于第 $k$ 行到第 $m-1$ 行。完整的变换 $U_k$ 是将 $U_k'$ 嵌入到一个 $m \\times m$ 的单位矩阵中。\n    $$ A^{(k-1/2)} = U_k A^{(k-1)} $$\n2.  **右反射（行消元）**：如果 $k  n-2$，构造一个 Householder 变换 $V_k'$，以将第 $k$ 行中从第 $k+2$ 列开始的元素置零。该反射作用于第 $k+1$ 列到第 $n-1$ 列。完整的变换 $V_k$ 是将 $V_k'$ 嵌入到一个 $n \\times n$ 的单位矩阵中。\n    $$ A^{(k)} = A^{(k-1/2)} V_k $$\n\n最终的双对角矩阵是 $\\hat{B} \\approx A^{(\\min(m,n))}$。累积的正交矩阵是 $\\hat{U} = U_0 U_1 \\dots$ 和 $\\hat{V} = V_0 V_1 \\dots$。实现将通过将 $\\hat{U}$ 和 $\\hat{V}$ 初始化为单位矩阵，并在每一步应用变换来显式构造它们。\n\n### 3) 能量保持测试与诊断\n\n理论证明表明，对于精确的正交矩阵 $\\hat{U}$ 和 $\\hat{V}$，Frobenius 范数是完全保持的。在有限精度算术中，$\\hat{U}$ 和 $\\hat{V}$ 只能是近似正交的，这会导致范数出现微小差异。\n\n量化此行为的指标是：\n-   **相对 Frobenius 范数差异**：该指标衡量矩阵“能量”的变化，并用原始能量进行归一化。\n    $$ \\mathrm{rel\\_err} = \\frac{\\big|\\|A\\|_F - \\|\\hat{U}^\\top A \\hat{V}\\|_F\\big|}{\\max(\\|A\\|_F, 1)} $$\n    分母项 $\\max(\\|A\\|_F, 1)$ 防止除以零，并为小范数矩阵提供了合理的相对误差。\n-   **正交性缺陷**：这些指标衡量计算出的因子 $\\hat{U}$ 和 $\\hat{V}$ 与完全正交的接近程度。\n    $$ \\mathrm{orthU} = \\|I - \\hat{U}^\\top \\hat{U}\\|_F, \\quad \\mathrm{orthV} = \\|I - \\hat{V}^\\top \\hat{V}\\|_F $$\n    对于完全正交的矩阵，这些缺陷将为零。在实践中，它们应该在机器精度乘以某个与矩阵维度相关的因子的数量级上。\n\n接受阈值 $\\tau(m,n) = c \\, u \\, (m + n)$，其中 $c=100$，$u$ 为双精度单位舍入误差，它为稳定算法的预期相对误差提供了一个合理的界限。如果 $\\mathrm{rel\\_err} \\le \\tau(m,n)$，则声明为通过。\n\n案例 5 中的诊断测试通过添加一个小的随机扰动，故意在 $\\hat{U}$ 和 $\\hat{V}$ 中引入非正交性。这预计会增加正交性缺陷和 Frobenius 范数差异，从而证明它们对正交性损失的敏感性。`orthU` 和 `orthV` 的量级预计将与扰动大小 $\\delta$ 大致成正比，而 `rel_err` 预计会显著增加，可能导致测试失败。", "answer": "```python\nimport numpy as np\n\ndef bidiagonalize(A_in):\n    \"\"\"\n    Performs Golub-Kahan-Reinsch bidiagonalization of a matrix A.\n\n    Args:\n        A_in (np.ndarray): The m x n matrix to bidiagonalize.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: The accumulated orthogonal matrices U (m x m) and V (n x n).\n    \"\"\"\n    m, n = A_in.shape\n    A = A_in.copy().astype(float)\n    U = np.eye(m, dtype=float)\n    V = np.eye(n, dtype=float)\n\n    for k in range(min(m, n)):\n        # Left (column) reflector to annihilate A[k+1:m, k]\n        # v is constructed from the k-th column of the trailing submatrix\n        x = A[k:m, k].copy()\n        norm_x = np.linalg.norm(x)\n\n        if norm_x > 0:\n            s_sign = np.copysign(1.0, x[0]) if x[0] != 0.0 else 1.0\n            s = s_sign * norm_x\n            x[0] += s\n            norm_v = np.linalg.norm(x)\n            if norm_v > 0:\n                v = x / norm_v\n\n                # Apply transformation to the trailing submatrix of A\n                sub_A = A[k:m, k:n]\n                sub_A -= 2 * np.outer(v, v.T @ sub_A)\n\n                # Accumulate transformation in U\n                sub_U = U[:, k:m]\n                sub_U -= 2 * np.outer(sub_U @ v, v.T)\n\n        # Right (row) reflector to annihilate A[k, k+2:n]\n        if k  n - 2:\n            # w is constructed from the k-th row of the trailing submatrix\n            y = A[k, k+1:n].copy()\n            norm_y = np.linalg.norm(y)\n\n            if norm_y > 0:\n                s_sign = np.copysign(1.0, y[0]) if y[0] != 0.0 else 1.0\n                s = s_sign * norm_y\n                y[0] += s\n                norm_w = np.linalg.norm(y)\n                if norm_w > 0:\n                    w = y / norm_w\n\n                    # Apply transformation to the trailing submatrix of A\n                    sub_A = A[k:m, k+1:n]\n                    sub_A -= 2 * np.outer(sub_A @ w, w.T)\n                    \n                    # Accumulate transformation in V\n                    sub_V = V[:, k+1:n]\n                    sub_V -= 2 * np.outer(sub_V @ w, w.T)\n\n    return U, V\n\ndef run_test_case(m, n, A_generator, seeds):\n    \"\"\"\n    Sets up and runs a single test case.\n\n    Args:\n        m (int): Number of rows.\n        n (int): Number of columns.\n        A_generator (str): Method to generate matrix A.\n        seeds (dict): Seeds for random number generation.\n\n    Returns:\n        list: A list containing [rel_err, orthU, orthV, is_pass].\n    \"\"\"\n    # 1. Generate matrix A based on case description\n    if A_generator == 'normal':\n        rng = np.random.default_rng(seeds['A'])\n        A = rng.standard_normal((m, n))\n    elif A_generator == 'zero':\n        A = np.zeros((m, n))\n    elif A_generator == 'ill-cond':\n        rng_U = np.random.default_rng(seeds['U0'])\n        rand_U = rng_U.standard_normal((m, m))\n        U0, _ = np.linalg.qr(rand_U)\n        \n        rng_V = np.random.default_rng(seeds['V0'])\n        rand_V = rng_V.standard_normal((n, n))\n        V0, _ = np.linalg.qr(rand_V)\n        \n        num_sv = min(m, n)\n        sigma_vals = [10.0**(-12.0 * i / (num_sv - 1)) for i in range(num_sv)]\n        Sigma = np.zeros((m, n))\n        np.fill_diagonal(Sigma, sigma_vals)\n        A = U0 @ Sigma @ V0.T\n    \n    # 2. Perform bidiagonalization\n    U_hat, V_hat = bidiagonalize(A)\n\n    # 3. Handle diagnostic perturbation (Case 5)\n    if 'perturb' in seeds:\n        delta = 1e-8\n        rng_pert = np.random.default_rng(seeds['perturb'])\n        R_U = rng_pert.standard_normal((m, m))\n        R_V = rng_pert.standard_normal((n, n))\n        U_hat += delta * R_U\n        V_hat += delta * R_V\n        \n    # 4. Compute metrics\n    norm_A_F = np.linalg.norm(A, 'fro')\n    \n    transformed_A = U_hat.T @ A @ V_hat\n    norm_transformed_A_F = np.linalg.norm(transformed_A, 'fro')\n    \n    if norm_A_F == 0.0:\n        rel_err = 0.0\n    else:\n        rel_err = abs(norm_A_F - norm_transformed_A_F) / max(norm_A_F, 1.0)\n        \n    orthU = np.linalg.norm(np.eye(m) - U_hat.T @ U_hat, 'fro')\n    orthV = np.linalg.norm(np.eye(n) - V_hat.T @ V_hat, 'fro')\n\n    # 5. Evaluate pass/fail criterion\n    u = np.finfo(float).eps / 2.0\n    c = 100.0\n    tau = c * u * (m + n)\n    is_pass = 1 if rel_err = tau else 0\n    \n    return [rel_err, orthU, orthV, is_pass]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'m': 50, 'n': 30, 'gen': 'normal', 'seeds': {'A': 1}},\n        {'m': 10, 'n': 10, 'gen': 'normal', 'seeds': {'A': 2}},\n        {'m': 20, 'n': 15, 'gen': 'zero',   'seeds': {}},\n        {'m': 60, 'n': 5,  'gen': 'ill-cond', 'seeds': {'U0': 3, 'V0': 4}},\n        {'m': 40, 'n': 35, 'gen': 'normal', 'seeds': {'A': 5, 'perturb': 6}},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case['m'], case['n'], case['gen'], case['seeds'])\n        results.append(result)\n\n    result_strings = []\n    for res in results:\n        rel_err, orthU, orthV, is_pass = res\n        s = f\"[{rel_err:.16e},{orthU:.16e},{orthV:.16e},{is_pass}]\"\n        result_strings.append(s)\n\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3588807"}, {"introduction": "在数值计算中，得到一个正确的答案固然重要，但保证每次运行都能得到完全相同的答案（即可复现性）同样至关重要。SVD 的定义本身存在一定的模糊性（例如奇异向量的符号），而算法的实现过程（如吉文斯旋转 (Givens rotation) 的符号选择）会引入更多的不确定性。这个高级练习将挑战您对这些细微之处的思考，通过分析和选择一套完备的约定，来确保 SVD 计算结果的确定性，这是开发健壮数值软件时必须考虑的关键问题。", "problem": "考虑用于计算实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的奇异值分解 (SVD) 的 Golub–Kahan–Reinsch 算法。该算法首先使用 Householder 反射进行正交双对角化，得到 $A = U_{0} B V_{0}^{\\top}$，其中 $B$ 是上双对角矩阵；然后对 $B$ 使用 Givens 旋转进行隐式位移正交 QR 型迭代，以对角化 $B$ 并产生 $B = \\widehat{U} \\Sigma \\widehat{V}^{\\top}$，从而得到最终的因子 $U = U_{0} \\widehat{U}$、$\\Sigma$ 和 $V = V_{0} \\widehat{V}$。根据奇异值分解 $A = U \\Sigma V^{\\top}$ 的定义可知，对于简单（两两不同）的奇异值，奇异向量在相应左右奇异向量对同时进行符号翻转的意义下是唯一的；而对于重复的奇异值，奇异子空间是唯一的，但在退化奇异子空间内的任何标准正交基都是可接受的。\n\n双对角 QR 迭代采用带有 Givens 旋转的凸起追逐法，并在超对角元素 $e_{k}$ 被视为数值上为零（$|e_{k}| \\le \\tau$，对于固定的阈值 $\\tau  0$）时进行紧缩（deflation）。在浮点运算中，会出现几种符号选择：\n- 在 Householder 反射中，构造的反射向量的符号。\n- 在 Givens 旋转中，余弦和正弦的符号选择。\n- 在紧缩时和紧缩附近，一个趋于零的 $e_{k}$ 如果不明确传播符号，可能会引起相邻对角元素的符号翻转。\n\n分析这些符号选择以及在紧缩过程中的潜在符号翻转如何影响计算出的 $U$ 和 $V$ 在不同运行和平台上的可复现性。然后，在假定使用相同算术和相同紧缩阈值 $\\tau$ 的前提下，确定下列哪几组约定足以确保对所有输入（包括具有重复奇异值的输入）都能得到确定性的输出 $U$、$\\Sigma$ 和 $V$。\n\n选择所有适用项。\n\nA. 在整个流程中强制执行一个完全指定的全局符号约定：\n   (1) 在双对角化中使用的每个 Householder 反射 $H = I - 2 v v^{\\top}$ 中，通过 $v = \\frac{x + \\alpha e_{1}}{\\|x + \\alpha e_{1}\\|}$ 从向量 $x$ 构造 $v$，其中 $\\alpha = \\operatorname{sign}(x_{1}) \\|x\\|$ 且决胜规则为 $\\operatorname{sign}(0) = +1$；如果 $x = 0$，则设 $H = I$。\n   (2) 双对角化后，通过左乘或右乘对角符号矩阵来吸收符号，使得双对角矩阵 $B$ 满足 $b_{ii} \\ge 0$ 和 $b_{i,i+1} \\ge 0$，并相应地更新累积的 $U_{0}$ 和 $V_{0}$。\n   (3) 在每个 Givens 旋转 $G = \\begin{bmatrix} c  s \\\\ -s  c \\end{bmatrix}$ 中，设 $r = \\sqrt{a^{2} + b^{2}} \\ge 0$，$c = a/r$，$s = b/r$，并在 $r=0$ 时使用确定性的决胜规则（取 $c=1, s=0$）。在紧缩时，当 $|e_{k}| \\le \\tau$ 时，设 $e_{k} = 0$ 并将任何负的对角符号传播到相邻的块中，以使工作中的双对角矩阵的对角元素保持非负。\n   (4) 收敛后，强制执行一个确定性的逐列符号约定：对每个索引 $i$，找到使 $|v_{j i}|$ 达到 $\\max_{\\ell} |v_{\\ell i}|$ 的最小索引 $j$，如果 $v_{j i}  0$，则同时翻转对 $(u_{i}, v_{i})$ 的符号。对于重复的奇异值，首先在每个退化奇异子空间内确定性地固定一个基（例如，对列向量执行带有字典序决胜规则的稳定标准正交化），然后应用相同的逐列符号约定。通过这些规则，$U$、$\\Sigma$ 和 $V$ 是确定性的。\n\nB. 只需强制 $\\Sigma$ 的对角元素为非负即可；不需要其他符号约定，因为 $U$ 和 $V$ 随后由 $\\Sigma$ 唯一确定。\n\nC. 在计算结束时通过可能翻转 $U$ 和 $V$ 的最后一列的符号来强制执行 $\\det(U) = +1$ 和 $\\det(V) = +1$，这足以确保一个确定性的 SVD，而无需考虑中间的符号选择和紧缩。\n\nD. 在计算出任何 SVD（通过任何反射和旋转序列）之后，进行后处理，翻转每个右奇异向量 $v_{i}$ 的符号，使其元素之和为正，即 $\\sum_{j} v_{j i}  0$；如果和为负，则用 $(-u_{i}, -v_{i})$ 替换 $(u_{i}, v_{i})$。为了保证确定性，无需对双对角化、Givens 旋转或紧缩施加额外的约束。\n\nE. 为了控制由紧缩引入的符号翻转，采用以下规则：每当一个超对角元素 $e_{k}$ 因紧缩被设为 $0$ 时，仅对尾部的对角元素 $b_{k+1,k+1}$ 进行符号调整（如果需要）以使其非负；所有其他的符号选择（Householder 和 Givens）可以保持无约束。这个在紧缩处的局部规则足以确保 $U$ 和 $V$ 是确定性的。", "solution": "该问题要求确定哪几组约定足以保证从 Golub-Kahan-Reinsch 算法中获得确定性的奇异值分解 (SVD) 输出 $A = U \\Sigma V^{\\top}$，前提是使用相同的浮点运算和紧缩阈值。\n\n数值 SVD 算法中非确定性的主要来源是：\n1.  **算法选择**：在计算过程中，存在一些数学上等价但可能导致不同数值结果的选择点。\n    -   在初始双对角化 $A = U_0 B V_0^\\top$ 中，Householder 反射 $H = I - 2vv^\\top/v^\\top v$ 是从向量 $x$ 构造的。反射向量通常选择为 $x \\pm \\|x\\|_2 e_1$。符号的选择会影响最终的 $U_0$ 和 $V_0$。\n    -   在双对角矩阵 $B$ 的迭代对角化过程中，使用 Givens 旋转 $G = \\begin{bmatrix} c  s \\\\ -s  c \\end{bmatrix}$。对 $(c, s)$ 的确定存在一个同时改变符号的自由度，因为 $(-c, -s)$ 也定义了一个有效的旋转（增加了 $\\pi$ 的角度）。这个选择会影响累积的正交矩阵 $\\widehat{U}$ 和 $\\widehat{V}$。\n    -   在紧缩期间，当一个超对角元素 $e_k$ 被设为零时，问题被分解。符号变化可以在已解耦的块之间传播而不违反双对角结构，这会影响中间矩阵，从而影响最终的 $U$ 和 $V$。\n2.  **基本非唯一性**：SVD 本身具有固有的非唯一性。\n    -   对于任何奇异值 $\\sigma_i$ 及其对应的奇异向量 $u_i, v_i$，对 $(-u_i, -v_i)$ 也是一个有效的组合，因为 $A(-v_i) = \\sigma_i(-u_i)$ 且 $A^\\top(-u_i) = \\sigma_i(-v_i)$。\n    -   如果一个奇异值 $\\sigma$ 的重数为 $k  1$，则 $U$ 和 $V$ 中对应的 $k$ 列分别为左右奇异子空间构成标准正交基。这些子空间的任何其他标准正交基也都是有效的。输入矩阵或运算中的微小扰动可能导致选择不同的基。\n\n一组约定要足以保证确定性，当且仅当它为每个选择点提供了唯一的规则，从而解决了算法选择和基本非唯一性两个问题。\n\n### 选项评估\n\n**A. 在整个流程中强制执行一个完全指定的全局符号约定。**\n这个选项提出了一套四部分的规则来确定性地固定所有选择。\n1.  **Householder 反射**：规则 $v = \\frac{x + \\alpha e_{1}}{\\|x + \\alpha e_{1}\\|}$，其中 $\\alpha = \\operatorname{sign}(x_{1}) \\|x\\|$ 且 $\\operatorname{sign}(0) = +1$，为双对角化的每一步提供了反射向量的唯一、确定性选择。这使得中间矩阵 $U_0$ 和 $V_0$ 是确定性的。\n2.  **规范双对角形式**：通过将符号吸收到已计算的 $U_0$ 和 $V_0$ 中，强制 $b_{ii} \\ge 0$ 和 $b_{i,i+1} \\ge 0$ 的规则创建了一个规范的中间问题。然后计算这个规范双对角矩阵的 SVD。这是确保迭代阶段的输入是确定性的关键一步。\n3.  **Givens 旋转和紧缩**：Givens 旋转的规则（$c = a/r, s = b/r$ 且 $r \\ge 0$）消除了旋转矩阵中的符号模糊性。在紧缩时对符号的指定处理确保了 QR 迭代过程中产生的双对角矩阵序列也是确定性的。因此，此阶段产生的正交因子 $\\widehat{U}$ 和 $\\widehat{V}$ 是确定性的。\n4.  **最终基和符号唯一性**：这部分解决了 SVD 的基本非唯一性问题。\n    -   对于重复的奇异值，它正确地指出了需要为每个退化子空间确定性地固定一个基。像“带有字典序决胜规则的稳定标准正交化”这样的方法是实现这一点的有效途径。没有这一步，即使算法收敛到正确的子空间，基向量在不同运行中也可能被不同地旋转。\n    -   对于 $(u_i, v_i)$ 对的简单符号模糊性，它提供了一个基于 $v_i$ 中最大绝对值元素的符号的确定性规则，并带有决胜规则。这固定了最终的符号。\n\n这套约定是全面的，解决了从初始步骤到最终输出的所有非确定性来源。因此，它足以确保确定性的输出 $U, \\Sigma, V$。\n**结论：正确。**\n\n**B. 只需强制 $\\Sigma$ 的对角元素为非负即可；不需要其他符号约定，因为 $U$ 和 $V$ 随后由 $\\Sigma$ 唯一确定。**\n这种说法根本上是有缺陷的。奇异值（$\\Sigma$ 的对角元素）非负是 SVD 标准定义的一部分，而不是一个可选的约定。更重要的是，声称 $U$ 和 $V$ 由 $\\Sigma$ 唯一确定是错误的。如前所述，对于给定的 $A$ 和 $\\Sigma$，在选择奇异向量对的符号和退化奇异子空间的基方面存在自由度。该选项也完全忽略了算法执行路径内的所有非确定性来源。\n**结论：错误。**\n\n**C. 在计算结束时强制执行 $\\det(U) = +1$ 和 $\\det(V) = +1$ 是足够的。**\n这个条件不足以确保确定性。考虑两对奇异向量 $(u_i, v_i)$ 和 $(u_j, v_j)$。我们可以用 $(-u_i, -v_i)$ 和 $(-u_j, -v_j)$ 替换它们。得到的新矩阵 $U'$ 和 $V'$ 与原始的 $U$ 和 $V$ 不同。然而，$\\det(U') = \\det(U)$ 和 $\\det(V') = \\det(V)$，因为每个行列式的符号都被翻转了两次。因此，多个不同的 $(U, V)$ 对可以满足这个行列式条件。此外，这个规则没有解决重复奇异值的基选择问题。例如，对于 $A=I_2$，$(U,V) = (I_2, I_2)$ 和 $(U,V) = (-I_2, -I_2)$ 都给出 $\\det(U)=\\det(V)=1$，但它们是不同的。\n**结论：错误。**\n\n**D. 在计算出任何 SVD 后，进行后处理，翻转每个右奇异向量的符号，使其元素之和为正。**\n这个规则是一个后处理步骤，用以修正每个 $(u_i, v_i)$ 对的符号模糊性。然而，它是不完整和不充分的。\n首先，它没有规定在 $\\sum_j v_{ji} = 0$ 的情况下该怎么做。一个确定性的规则需要一个决胜规则。\n其次，也是更关键的是，它完全没有解决对应于重复奇异值的子空间的基的非唯一性问题。在具有重复奇异值的矩阵上运行两次 SVD 算法可能会产生两个不同（但都有效）的奇异子空间标准正交基。将这个符号固定规则应用于这两个不同基中的向量不会使这两个基变得相同。它也忽略了计算过程中的所有算法选择点。\n**结论：错误。**\n\n**E. 为了控制由紧缩引入的符号翻转，采用一个局部规则……所有其他的符号选择（Householder 和 Givens）可以保持无约束。**\n这个选项只针对众多非确定性来源中的一个提出了规则。它明确指出 Householder 反射和 Givens 旋转的选择可以保持无约束。在初始双对角化（Householder）或迭代对角化（Givens）中的无约束选择将导致 $U$ 和 $V$ 的输出不确定。单个局部规则不足以确保整个算法的全局确定性。\n**结论：错误。**\n\n总之，只有选项 A 提供了一套完整而系统的规则，涵盖了所有算法选择点并解决了 SVD 的基本非唯一性，从而保证了确定性的结果。", "answer": "$$\\boxed{A}$$", "id": "3588838"}]}