{"hands_on_practices": [{"introduction": "理解投影算子的最佳方式之一是从其最核心的代数和几何属性出发进行构造。本练习 [@problem_id:3567668] 将引导你仅使用值域、零空间和幂等性这些基本定义，来推导出一个重要的斜投影算子的显式矩阵形式。通过这个过程，你将深刻理解抽象定义与具体矩阵表示之间的联系，并接触到广义逆的概念。", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 具有满列秩 $n$，且 $C \\in \\mathbb{R}^{n \\times m}$ 具有满行秩 $n$。假设 $C A \\in \\mathbb{R}^{n \\times n}$ 是可逆的。定义一个算子 $P \\in \\mathbb{R}^{m \\times m}$，它是一个投影算子，即满足 $P^{2} = P$，并附有斜投影条件 $\\operatorname{range}(P) = \\operatorname{range}(A)$ 和 $\\operatorname{null}(P) = \\operatorname{null}(C)$。仅从值域、零空间、投影算子和子空间上的双射性的核心定义出发，推导出一个用 $A$ 和 $C$ 表示的 $P$ 的显式闭式表达式。\n\n然后，从矩阵 $M$ 的广义逆 $G$ 的定义（即满足 $M G M = M$ 的任意矩阵）以及自反广义逆的定义（即额外满足 $G M G = G$）出发，通过确定一个 $C$ 的特定的自反广义逆 $G$ 使得 $P = G C$，将投影算子 $P$ 与 $C$ 的广义逆联系起来。\n\n仅使用这些定义性质来证明你所确定的 $G$ 的自反性。\n\n作为你的最终答案，提供你所推导出的投影算子 $P$ 的单一解析表达式。不需要数值近似。", "solution": "该问题是适定的。所提供的条件足以唯一确定投影算子 $P$。具体来说，空间 $\\mathbb{R}^m$可以分解为指定值域和零空间的直和，即 $\\mathbb{R}^m = \\operatorname{range}(A) \\oplus \\operatorname{null}(C)$。这是因为对于任意向量 $v \\in \\operatorname{range}(A) \\cap \\operatorname{null}(C)$，我们有 $v = Ax$（对于某个 $x \\in \\mathbb{R}^n$）和 $Cv = 0$。将前者代入后者得到 $C(Ax) = (CA)x = 0$。由于 $CA$ 是可逆的，必然有 $x=0$，这意味着 $v = A0 = 0$。因此，它们的交集是平凡的，该直和是有效的。\n\n我们现在推导投影算子 $P$ 的显式形式。根据定义，投影算子 $P$ 将任意向量 $y \\in \\mathbb{R}^m$ 映射到其在 $P$ 的值域中沿着 $P$ 的零空间的分量上。任意向量 $y \\in \\mathbb{R}^m$ 都有一个唯一的分解 $y = u + v$，其中 $u \\in \\operatorname{range}(P)$ 且 $v \\in \\operatorname{null}(P)$。投影算子的作用定义为 $Py = u$。\n\n根据题目陈述，我们有 $\\operatorname{range}(P) = \\operatorname{range}(A)$ 和 $\\operatorname{null}(P) = \\operatorname{null}(C)$。因此，对于任意 $y \\in \\mathbb{R}^m$，我们可以写出 $y = u + v$，其中 $u \\in \\operatorname{range}(A)$ 且 $v \\in \\operatorname{null}(C)$。投影后的向量是 $Py = u$。\n\n由于 $u \\in \\operatorname{range}(A)$，存在一个向量 $x \\in \\mathbb{R}^n$ 使得 $u = Ax$。因为 $A$ 具有满列秩 $n$，所以 $A$ 的列是线性无关的，因此对于任意给定的 $u \\in \\operatorname{range}(A)$，向量 $x$ 是唯一的。我们的目标是找到一个用已知向量 $y$ 表示 $x$ 的表达式。\n\n我们从分解式 $y = Ax + v$ 开始。我们可以将矩阵 $C$ 应用于该方程的两边：\n$$Cy = C(Ax + v)$$\n根据矩阵乘法的线性性质，这变为：\n$$Cy = C(Ax) + Cv$$\n根据问题定义，$v \\in \\operatorname{null}(C)$，这意味着 $Cv = 0$。方程简化为：\n$$Cy = (CA)x$$\n我们已知方阵 $CA \\in \\mathbb{R}^{n \\times n}$ 是可逆的。因此，我们可以通过左乘其逆矩阵 $(CA)^{-1}$ 来解出 $x$：\n$$x = (CA)^{-1}Cy$$\n现在我们可以将这个 $x$ 的表达式代回到投影向量的方程 $Py = Ax$ 中：\n$$Py = A \\left((CA)^{-1}Cy\\right)$$\n$$Py = [A(CA)^{-1}C]y$$\n由于此方程对任意向量 $y \\in \\mathbb{R}^m$ 都成立，所以方括号中的表达式必定是投影算子 $P$ 的矩阵表示。\n$$P = A(CA)^{-1}C$$\n为了严谨起见，我们可以验证这个 $P$ 满足投影算子的定义性质 $P^2 = P$：\n$$P^2 = \\left(A(CA)^{-1}C\\right) \\left(A(CA)^{-1}C\\right) = A(CA)^{-1}(CA)(CA)^{-1}C = A(CA)^{-1}I_n(CA)^{-1}C = A(CA)^{-1}C = P$$\n其中 $I_n$ 是 $n \\times n$ 的单位矩阵。\n\n接下来，我们将这个投影算子与 $C$ 的一个广义逆联系起来。如果矩阵 $G$ 满足 $MGM=M$，则称 $G$ 是矩阵 $M$ 的一个广义逆。如果此外还满足 $GMG=G$，则称其为自反广义逆。我们正在寻找 $C$ 的一个特定的自反广义逆 $G$，使得 $P = GC$。\n\n将我们推导出的表达式 $P = A(CA)^{-1}C$ 与形式 $P=GC$ 进行比较，我们可以确定 $G$ 为：\n$$G = A(CA)^{-1}$$\n现在我们必须验证这个 $G$ 是 $C$ 的一个自反广义逆。\n\n首先，我们检验广义逆条件 $CGC = C$：\n$$CGC = C \\left( A(CA)^{-1} \\right) C$$\n利用矩阵乘法的结合律，我们可以将各项组合为：\n$$CGC = (CA)(CA)^{-1}C$$\n由于 $(CA)(CA)^{-1} = I_n$，该表达式变为：\n$$CGC = I_n C = C$$\n此条件得到满足。\n\n其次，我们检验自反条件 $GCG = G$：\n$$GCG = \\left( A(CA)^{-1} \\right) C \\left( A(CA)^{-1} \\right)$$\n同样，利用结合律，我们将中间的项组合起来：\n$$GCG = A(CA)^{-1} \\left( C A(CA)^{-1} \\right)$$\n我们可以将括号内的项重组为 $C A (CA)^{-1} = (CA)(CA)^{-1} = I_n$。然而，一个更直接的方法是识别子表达式 $CG$：\n$$CG = C \\left(A(CA)^{-1}\\right) = (CA)(CA)^{-1} = I_n$$\n所以 $G$ 是 $C$ 的一个右逆。将 $CG=I_n$ 代回到自反条件的检验中：\n$$GCG = G(CG) = G I_n = G$$\n此条件也得到满足。\n\n因此，我们已经证明了 $G = A(CA)^{-1}$ 是 $C$ 的一个自反广义逆，并且投影算子 $P$ 可以表示为 $P = GC$。投影算子 $P$ 的显式闭式表达式仍然是 $P = A(CA)^{-1}C$。", "answer": "$$\n\\boxed{A(CA)^{-1}C}\n$$", "id": "3567668"}, {"introduction": "在理想的数学世界中，算子具有完美的性质，但在有限精度的计算机上，数值误差会破坏这些性质。本练习 [@problem_id:3567643] 探讨了一个在数值线性代数中至关重要的问题：如何修复一个因舍入误差而不再严格满足对称性和幂等性的近似正交投影。你将通过实现一个基于谱定理的优化算法，学习如何找到与受噪声污染的矩阵最接近的“真实”正交投影。", "problem": "考虑一个实数矩阵 $P \\in \\mathbb{R}^{n \\times n}$，它是投影算子的一个数值计算近似。在有限精度算术中，这样的 $P$ 可能轻微地非对称和轻微地非幂等。令 $P$ 的对称部分为 $P_s = \\frac{1}{2}(P + P^{\\top})$。投影算子是满足 $X^2 = X$ 的矩阵 $X$。正交投影算子是同时也是对称的投影算子，即 $X = X^{\\top}$ 且 $X^2 = X$。矩阵 $A$ 的弗罗贝尼乌斯范数 (Frobenius norm) 为 $\\|A\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$。\n\n您的任务是设计一个程序，对于每个提供的测试矩阵 $P$，评估两种修复策略的质量：\n- 简单对称化 $P_s$，以及\n- 通过弗罗贝尼乌斯范数意义下的最近正交投影算子进行优化修复。\n\n该程序必须源自并实现以下基本且经过充分检验的原理，不得依赖于预先封装的快捷公式：\n- 实对称矩阵的谱定理：任何实对称矩阵 $S$ 都允许进行特征分解 $S = Q \\Lambda Q^{\\top}$，其中 $Q$ 是正交矩阵，$\\Lambda$ 是实对角矩阵。\n- 弗罗贝尼乌斯范数是酉不变的，并且由内积 $\\langle A, B \\rangle = \\mathrm{trace}(A^{\\top} B)$ 导出。\n- 如果 $A = S + K$，其中 $S = S^{\\top}$ 且 $K = -K^{\\top}$，则 $\\|A\\|_F^2 = \\|S\\|_F^2 + \\|K\\|_F^2$ 且 $\\langle S, K \\rangle = 0$。\n\n您必须根据这些原理，推导出一个算法来计算给定实矩阵 $P$ 在弗罗贝尼乌斯范数意义下的最近正交投影算子，然后为每个测试用例计算以下三个量：\n- 简单对称化的幂等缺陷：$\\|P_s^2 - P_s\\|_F$，\n- 原始矩阵与其对称化矩阵之间的距离：$\\|P - P_s\\|_F$，\n- 原始矩阵与弗罗贝尼乌斯范数意义下的最近正交投影算子 $P_{\\star}$ 之间的距离：$\\|P - P_{\\star}\\|_F$。\n\n您的程序必须仅使用所列出的原理和标准的数值线性代数运算来实现您推导的计算 $P_{\\star}$ 的方法。\n\n测试套件：\n为下面每个明确给出的矩阵计算指定的三个量。所有条目均为普通实数。请确保使用书面上的精确数值。\n\n- 测试用例 1 ($4 \\times 4$):\n$$\nP^{(1)} =\n\\begin{bmatrix}\n1  0  0  0.001 \\\\\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n-0.001  0  0  0\n\\end{bmatrix}.\n$$\n\n- 测试用例 2 ($4 \\times 4$):\n$$\nP^{(2)} =\n\\begin{bmatrix}\n0.5  0  0.5  0.001 \\\\\n0  0.5  0.0005  0.5 \\\\\n0.5  -0.0005  0.5  0 \\\\\n0.001  0.5  0  0.5\n\\end{bmatrix}.\n$$\n\n- 测试用例 3 ($4 \\times 4$):\n$$\nP^{(3)} =\n\\begin{bmatrix}\n0.49  0.001  0  0 \\\\\n-0.001  0.51  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1\n\\end{bmatrix}.\n$$\n\n- 测试用例 4 ($5 \\times 5$):\n$$\nP^{(4)} =\n\\begin{bmatrix}\n0.5  0  0  0  0.0002 \\\\\n0  1  0  0  0 \\\\\n0  0  0  0  0 \\\\\n0  0  0  0.5  0 \\\\\n-0.0002  0  0  0  1\n\\end{bmatrix}.\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例必须按顺序产生一个包含三个浮点数的列表\n$[\\|P_s^2 - P_s\\|_F,\\ \\|P - P_s\\|_F,\\ \\|P - P_{\\star}\\|_F]$，\n最终输出必须是这些按测试用例顺序排列的列表的列表。例如，输出必须具有\n$[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$\n的形式，不含任何额外文本。角度和物理单位不适用；所有实数均以标准十进制浮点值报告。程序不得读取任何输入，并且必须是完全确定性的。", "solution": "该问题要求设计一个程序，用以评估两种修复方法的效果。这两种方法用于修复一个作为正交投影算子近似的数值计算矩阵 $P \\in \\mathbb{R}^{n \\times n}$。正交投影算子 $X$ 是一个既对称 ($X = X^{\\top}$) 又幂等 ($X^2 = X$) 的矩阵。这两种修复策略是：\n1.  简单对称化，得到 $P_s = \\frac{1}{2}(P + P^{\\top})$。\n2.  一种更精密的修复，通过寻找弗罗贝尼乌斯范数意义下的最近正交投影算子 $P_{\\star}$ 来实现。\n\n任务的核心是从第一性原理出发，推导出一个寻找 $P_{\\star}$ 的算法。这涉及到解决以下优化问题：\n$$\n\\min_{X} \\|P - X\\|_F \\quad \\text{subject to} \\quad X = X^{\\top} \\text{ and } X^2 = X.\n$$\n推导过程必须利用所提供的原理：实对称矩阵的谱定理、弗罗贝尼乌斯范数的性质，以及对称与斜对称矩阵的正交性。\n\n首先，让我们形式化推导最近正交投影算子 $P_{\\star}$ 的过程。我们旨在最小化目标函数 $f(X) = \\|P - X\\|_F^2$。每个实方阵 $P$ 都可以唯一地分解为其对称部分 $P_s = \\frac{1}{2}(P + P^{\\top})$ 和斜对称部分 $P_k = \\frac{1}{2}(P - P^{\\top})$，使得 $P = P_s + P_k$。候选矩阵 $X$ 是一个正交投影算子，因此必须是对称的。所以，差值 $P_s - X$ 也是对称的。我们可以将目标函数重写为：\n$$\n\\|P - X\\|_F^2 = \\|(P_s + P_k) - X\\|_F^2 = \\|(P_s - X) + P_k\\|_F^2.\n$$\n问题陈述中提供的原理指出，对于任何分解为其对称部分 $S$ 和斜对称部分 $K$ 的矩阵，其弗罗贝尼乌斯范数的平方为 $\\|S+K\\|_F^2 = \\|S\\|_F^2 + \\|K\\|_F^2$。这是因为对称矩阵和斜对称矩阵在弗罗贝尼乌斯内积下是正交的，即 $\\langle S, K \\rangle = \\mathrm{trace}(S^{\\top}K) = 0$。将此原理应用于表达式 $(P_s - X) + P_k$，其中 $(P_s - X)$ 是对称的，而 $P_k$ 是斜对称的，我们得到：\n$$\n\\|(P_s - X) + P_k\\|_F^2 = \\|P_s - X\\|_F^2 + \\|P_k\\|_F^2.\n$$\n项 $\\|P_k\\|_F^2$ 完全由输入矩阵 $P$ 决定，并且相对于 $X$ 的选择是一个常数。因此，最小化 $\\|P-X\\|_F^2$ 等价于最小化 $\\|P_s - X\\|_F^2$。这一洞见简化了问题：与 $P$ 最接近的正交投影算子等同于与其对称部分 $P_s$ 最接近的正交投影算子。我们的优化问题现在变为：\n$$\n\\min_{X} \\|P_s - X\\|_F \\quad \\text{subject to} \\quad X = X^{\\top} \\text{ and } X^2 = X.\n$$\n下一步采用实对称矩阵的谱定理，该定理指出任何此类矩阵 $S$ 都可以通过一个正交矩阵进行对角化。对于 $P_s$，我们有特征分解 $P_s = Q \\Lambda Q^{\\top}$，其中 $Q$ 是一个正交矩阵 ($Q^{\\top}Q = I$)，其列是 $P_s$ 的特征向量，$\\Lambda$ 是一个实对角矩阵，其对角线元素 $\\lambda_1, \\ldots, \\lambda_n$ 是对应的特征值。\n我们使用另一个提供的原理：弗罗贝尼乌斯范数是酉不变的。这意味着对于任何正交矩阵 $U$ 和 $V$，都有 $\\|A\\|_F = \\|UAV\\|_F$。将此应用于我们的目标函数，设 $U=Q^{\\top}$ 和 $V=Q$：\n$$\n\\|P_s - X\\|_F^2 = \\|Q \\Lambda Q^{\\top} - X\\|_F^2 = \\|Q^{\\top}(Q \\Lambda Q^{\\top} - X)Q\\|_F^2 = \\|\\Lambda - Q^{\\top}XQ\\|_F^2.\n$$\n我们定义一个新变量 $Y = Q^{\\top}XQ$。由于 $X$ 是一个正交投影算子且 $Q$ 是正交的，所以 $Y$ 也是一个正交投影算子：\n-   对称性: $Y^{\\top} = (Q^{\\top}XQ)^{\\top} = Q^{\\top}X^{\\top}Q = Q^{\\top}XQ = Y$。\n-   幂等性: $Y^2 = (Q^{\\top}XQ)(Q^{\\top}XQ) = Q^{\\top}X(QQ^{\\top})XQ = Q^{\\top}X^2Q = Q^{\\top}XQ = Y$。\n问题转化为寻找一个能最小化 $\\|\\Lambda - Y\\|_F^2$ 的正交投影算子 $Y$。\n$$\n\\|\\Lambda - Y\\|_F^2 = \\sum_{i,j=1}^{n} (\\Lambda_{ij} - Y_{ij})^2.\n$$\n由于 $\\Lambda$ 是对角的，上式可写为 $\\sum_{i=1}^{n} (\\lambda_i - Y_{ii})^2 + \\sum_{i \\neq j} Y_{ij}^2$。为了最小化这个和，任何非零的非对角元素 $Y_{ij}$ 都会严格增大该值。因此，最优的 $Y$ 必须是一个对角矩阵。一个同时也是投影算子 ($Y^2=Y$) 的对角矩阵 $Y$，其对角元素 $Y_{ii}$ 必须满足 $Y_{ii}^2 = Y_{ii}$，这意味着 $Y_{ii} \\in \\{0, 1\\}$。\n问题因此简化为对每个 $i$ 选择一个值 $Y_{ii} \\in \\{0, 1\\}$ 来最小化 $(\\lambda_i - Y_{ii})^2$。这可以通过简单的阈值处理实现：\n-   如果 $\\lambda_i \\ge 0.5$，选择 $Y_{ii}=1$ 可以最小化 $(\\lambda_i-1)^2$ 项。\n-   如果 $\\lambda_i  0.5$，选择 $Y_{ii}=0$ 可以最小化 $(\\lambda_i-0)^2$ 项。\n我们将这个最优对角投影算子称为 $\\Lambda_{\\star}$。其对角元素为 $(\\Lambda_{\\star})_{ii} = 1$（如果 $\\lambda_i \\ge 0.5$）或 $0$（如果 $\\lambda_i  0.5$）。\n找到最优的 $\\Lambda_{\\star}$ 后，我们变换回原始基，以找到最近的正交投影算子 $P_{\\star}$：\n$$\nP_{\\star} = Q \\Lambda_{\\star} Q^{\\top}.\n$$\n从给定矩阵 $P$ 计算 $P_{\\star}$ 的算法如下：\n1.  计算对称部分 $P_s = \\frac{1}{2}(P + P^{\\top})$。\n2.  对 $P_s$ 进行特征分解，找到其特征值 $\\Lambda$ 和特征向量 $Q$，使得 $P_s = Q \\Lambda Q^{\\top}$。\n3.  通过对特征值进行阈值处理来构建对角矩阵 $\\Lambda_{\\star}$：如果 $\\lambda_i \\ge 0.5$，则 $(\\Lambda_{\\star})_{ii} = 1$；否则为 $0$。\n4.  计算最近的正交投影算子 $P_{\\star} = Q \\Lambda_{\\star} Q^{\\top}$。\n\n对于每个测试矩阵 $P$，我们将计算以下三个量：\n1.  简单对称化的幂等缺陷：$\\|P_s^2 - P_s\\|_F$。这衡量了 $P_s$ 离幂等矩阵的距离。\n2.  原始矩阵与其对称化矩阵之间的距离：$\\|P - P_s\\|_F$。这即是斜对称部分 $\\|P_k\\|_F$ 的范数。\n3.  原始矩阵与最近正交投影算子之间的距离：$\\|P - P_{\\star}\\|_F$。这是 $P$ 与任何正交投影算子在弗罗贝尼乌斯范数下的最小可能距离。\n\n下面的 Python 代码为每个提供的测试用例实现了这个推导出的过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projector repair problem for a series of test matrices.\n    For each matrix P, it computes:\n    1. Idempotency defect of the symmetric part Ps: ||Ps^2 - Ps||_F\n    2. Distance from P to its symmetric part: ||P - Ps||_F\n    3. Distance from P to the nearest orthogonal projector P_star: ||P - P_star||_F\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        np.array([\n            [1.0, 0.0, 0.0, 0.001],\n            [0.0, 1.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0],\n            [-0.001, 0.0, 0.0, 0.0]\n        ]),\n        # Test case 2\n        np.array([\n            [0.5, 0.0, 0.5, 0.001],\n            [0.0, 0.5, 0.0005, 0.5],\n            [0.5, -0.0005, 0.5, 0.0],\n            [0.001, 0.5, 0.0, 0.5]\n        ]),\n        # Test case 3\n        np.array([\n            [0.49, 0.001, 0.0, 0.0],\n            [-0.001, 0.51, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 1.0]\n        ]),\n        # Test case 4\n        np.array([\n            [0.5, 0.0, 0.0, 0.0, 0.0002],\n            [0.0, 1.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.5, 0.0],\n            [-0.0002, 0.0, 0.0, 0.0, 1.0]\n        ])\n    ]\n\n    results = []\n    for P in test_cases:\n        # Compute the symmetric part Ps\n        Ps = 0.5 * (P + P.T)\n\n        # 1. Idempotency defect of Ps\n        idempotency_defect_ps = np.linalg.norm(Ps @ Ps - Ps, 'fro')\n\n        # 2. Distance from P to Ps\n        dist_p_ps = np.linalg.norm(P - Ps, 'fro')\n\n        # 3. Distance from P to the nearest orthogonal projector P_star\n        # The derivation shows we need to find the eigendecomposition of Ps\n        eigenvalues, Q = np.linalg.eigh(Ps)\n\n        # Threshold the eigenvalues to get the eigenvalues of the nearest projector\n        # in the diagonalized basis\n        lambda_star_diag = np.where(eigenvalues = 0.5, 1.0, 0.0)\n        Lambda_star = np.diag(lambda_star_diag)\n\n        # Construct the nearest orthogonal projector P_star\n        P_star = Q @ Lambda_star @ Q.T\n        \n        # Compute the distance from P to P_star\n        dist_p_pstar = np.linalg.norm(P - P_star, 'fro')\n        \n        results.append([idempotency_defect_ps, dist_p_ps, dist_p_pstar])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in results)}]\")\n\nsolve()\n```", "id": "3567643"}, {"introduction": "计算两个子空间的交集是许多应用中的一个基本任务，而投影算子为此提供了强有力的工具。本练习 [@problem_id:3567687] 将引导你探索两种构建交空间上的正交投影的方法：一种是基于正交补性质的直接“闭式”解法，另一种是经典的交替投影迭代算法。通过对比这两种截然不同的计算策略，你将对数值算法的设计及其稳定性有更深入的认识。", "problem": "给定两个线性子空间 $\\mathcal{U} \\subset \\mathbb{R}^n$ 和 $\\mathcal{V} \\subset \\mathbb{R}^n$，每个子空间由一个以基向量为列的矩阵指定。您的任务是设计一个程序，针对下方的每个测试用例，从基本原理出发构造到交集 $\\mathcal{U} \\cap \\mathcal{V}$ 上的正交投影算子，并将其与通过基于Dykstra交替投影算法的迭代方案所获得的投影算子进行比较。\n\n您可以使用的基本定义和事实作为出发点：\n- 一个具有标准正交列的矩阵 $Q \\in \\mathbb{R}^{n \\times k}$ 张成一个子空间 $\\mathcal{S} = \\operatorname{range}(Q) \\subset \\mathbb{R}^n$。到 $\\mathcal{S}$ 上的正交投影算子是一个线性映射 $P_{\\mathcal{S}} : \\mathbb{R}^n \\to \\mathbb{R}^n$，满足 $P_{\\mathcal{S}}^2 = P_{\\mathcal{S}}$ 和 $P_{\\mathcal{S}}^\\top = P_{\\mathcal{S}}$，并且 $P_{\\mathcal{S}} x$ 是 $\\mathcal{S}$ 中在欧几里得范数意义下距离 $x$ 的唯一最近点。\n- 对于子空间 $\\mathcal{S} \\subset \\mathbb{R}^n$，其正交补为 $\\mathcal{S}^\\perp = \\{ x \\in \\mathbb{R}^n : x^\\top y = 0 \\ \\forall y \\in \\mathcal{S} \\}$。对于所有子空间 $\\mathcal{U}, \\mathcal{V} \\subset \\mathbb{R}^n$，直和关系 $(\\mathcal{U} \\cap \\mathcal{V})^\\perp = \\mathcal{U}^\\perp + \\mathcal{V}^\\perp$ 成立。\n- Moore-Penrose伪逆是一种线性代数算子，它将求逆运算推广到秩亏矩阵，并可通过奇异值分解（SVD）来定义。对于任何矩阵 $A$，通过 $A A^{+}$ 的乘法可以得到到其列空间上的正交投影算子。\n\n您的程序必须：\n1.  根据为 $\\mathcal{U}$ 和 $\\mathcal{V}$ 提供的基矩阵，使用基于奇异值分解（SVD）的稳健过程为 $\\mathcal{U}$ 和 $\\mathcal{V}$ 构造数值稳定的标准正交基，并舍弃奇异值低于用户指定容差的方向。\n2.  为 $\\mathcal{U}^\\perp$ 和 $\\mathcal{V}^\\perp$（正交补）构造标准正交基，例如通过使用基于奇异值分解的方法计算 $U^\\top$ 和 $V^\\top$ 的零空间。\n3.  仅使用上述基本事实（不要假设任何不能从这些事实推导出的闭式公式），推导并实现一个关于到 $\\mathcal{U}^\\perp + \\mathcal{V}^\\perp$ 上的正交投影算子和Moore-Penrose伪逆的、用于计算到 $\\mathcal{U} \\cap \\mathcal{V}$ 上的正交投影算子的数值稳定表达式。\n4.  实现双集合Dykstra交替投影过程，仅使用到 $\\mathcal{U}$ 和 $\\mathcal{V}$ 上的正交投影算子将任意向量 $x \\in \\mathbb{R}^n$ 投影到 $\\mathcal{U} \\cap \\mathcal{V}$ 上。为了将线性算子与闭式投影算子进行比较，将迭代投影应用于每个标准基向量，从而逐列构建近似的投影矩阵。使用欧几里得范数下 $10^{-12}$ 的停止容差，最大迭代次数为 $2000$ 次。\n5.  对于每个测试用例，计算：\n   - 闭式投影算子与Dykstra构建的投影算子之差的弗罗贝尼乌斯范数，其应为一个非负实数。\n   - $\\mathcal{U} \\cap \\mathcal{V}$ 的维数，使用基于投影算子性质的适当数值稳定方法计算得出的整数。\n   - 闭式投影算子的弗罗贝尼乌斯范数幂等性残差，即 $\\lVert P^2 - P \\rVert_F$，其应为一个非负实数。\n\n测试套件：\n为以下五个测试用例提供结果。在每个用例中，矩阵的列是子空间的基向量；在形成投影算子之前，将它们转换为标准正交基。\n\n- 用例 $1$ ($n = 5$):\n  - $\\mathcal{U}$ 由 $U_1 = [u_{1,1}\\ u_{1,2}]$ 的列张成，其中 $u_{1,1} = [1,1,0,0,0]^\\top$，$u_{1,2} = [0,0,1,0,0]^\\top$。\n  - $\\mathcal{V}$ 由 $V_1 = [v_{1,1}\\ v_{1,2}\\ v_{1,3}]$ 的列张成，其中 $v_{1,1} = [1,0,0,0,0]^\\top$，$v_{1,2} = [0,1,1,0,0]^\\top$，$v_{1,3} = [0,0,0,1,0]^\\top$。\n\n- 用例 $2$ ($n = 4$):\n  - $\\mathcal{U}$ 由 $U_2 = [e_1\\ e_2]$ 的列张成，其中 $e_i$ 表示 $\\mathbb{R}^4$ 中单位矩阵的第 $i$ 列。\n  - $\\mathcal{V}$ 由 $V_2 = [e_1\\ e_2\\ e_3]$ 的列张成，在 $\\mathbb{R}^4$ 中。\n\n- 用例 $3$ ($n = 3$):\n  - $\\mathcal{U}$ 由 $U_3 = [e_1]$ 的列张成，在 $\\mathbb{R}^3$ 中。\n  - $\\mathcal{V}$ 由 $V_3 = [e_2]$ 的列张成，在 $\\mathbb{R}^3$ 中。\n\n- 用例 $4$ ($n = 3$):\n  - $\\mathcal{U}$ 由 $U_4 = [e_1\\ e_2\\ e_3]$ 的列张成，在 $\\mathbb{R}^3$ 中。\n  - $\\mathcal{V}$ 由 $V_4 = [e_1\\ e_2\\ e_3]$ 的列张成，在 $\\mathbb{R}^3$ 中。\n\n- 用例 $5$ ($n = 3$):\n  - $\\mathcal{U}$ 由 $U_5 = [e_1\\ e_2]$ 的列张成，在 $\\mathbb{R}^3$ 中。\n  - $\\mathcal{V}$ 由 $V_5 = [w_1\\ w_2]$ 的列张成，其中 $w_1 = [1,\\varepsilon,0]^\\top$ 和 $w_2 = [0,1,0]^\\top$，$\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的子列表列表，每个子列表对应一个测试用例，按用例1到5的顺序排列。对于每个用例，输出子列表 $[e, d, i]$，其中 $e$ 是两种投影算子构造方法之间的弗罗贝尼乌斯范数差（浮点数），$d$ 是计算出的 $\\mathcal{U} \\cap \\mathcal{V}$ 的维数（整数），$i$ 是闭式投影算子的弗罗贝尼乌斯范数幂等性残差（浮点数）。例如，一个有效的输出形状是 $[[e_1,d_1,i_1],[e_2,d_2,i_2],\\dots,[e_5,d_5,i_5]]$，其中符号由数值代替。不应打印任何额外文本。", "solution": "目标是构造并比较到两个线性子空间交集 $\\mathcal{U} \\cap \\mathcal{V} \\subset \\mathbb{R}^n$ 上的正交投影算子的两种表示方法。第一种方法是从线性代数基本原理推导出的闭式表达式。第二种是使用Dykstra交替投影算法构造的迭代算子。\n\n设两个子空间为 $\\mathcal{U}$ 和 $\\mathcal{V}$，分别由矩阵 $U_{basis} \\in \\mathbb{R}^{n \\times k_U}$ 和 $V_{basis} \\in \\mathbb{R}^{n \\times k_V}$ 指定，其列向量分别构成 $\\mathcal{U}$ 和 $\\mathcal{V}$ 的基。求解步骤如下：\n\n**1. 数值稳定的标准正交基构造**\n\n从一个生成向量矩阵 $A \\in \\mathbb{R}^{n \\times k}$ 中为子空间 $\\mathcal{S} = \\operatorname{range}(A)$ 寻找标准正交基的一种稳健方法是奇异值分解（SVD）。$A$ 的SVD分解为 $A = S \\Sigma V^\\top$，其中 $S \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{k \\times k}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times k}$ 是一个矩形对角矩阵，其对角线上的非负实数称为奇异值。\n\n矩阵 $A$ 的秩 $r$ 是其大于一个小的容差 $\\tau  0$ 的奇异值的数量。$S$ 的前 $r$ 列构成了 $A$ 的列空间（即 $\\mathcal{S}$）的一组标准正交基。设该基矩阵为 $Q_\\mathcal{S} = S[:, 1:r]$。$S$ 剩余的 $n-r$ 列，记为 $Q_{\\mathcal{S}^\\perp} = S[:, (r+1):n]$，构成了列空间的正交补 $\\mathcal{S}^\\perp$ 的一组标准正交基，这等价于 $A^\\top$ 的零空间。\n\n此过程应用于 $U_{basis}$ 和 $V_{basis}$，以获得 $\\mathcal{U}$ 的标准正交基 $Q_\\mathcal{U}$ 和 $\\mathcal{V}$ 的标准正交基 $Q_\\mathcal{V}$，以及 $\\mathcal{U}^\\perp$ 的基 $Q_{\\mathcal{U}^\\perp}$ 和 $\\mathcal{V}^\\perp$ 的基 $Q_{\\mathcal{V}^\\perp}$。为了数值稳定性和可复现性，使用容差 $\\tau = 10^{-12}$。\n\n**2. 交集 $\\mathcal{U} \\cap \\mathcal{V}$ 的闭式投影算子**\n\n到 $\\mathcal{U} \\cap \\mathcal{V}$ 上的正交投影算子 $P_{\\mathcal{U} \\cap \\mathcal{V}}$ 的推导依赖于以下基本性质：\n- 对于任何子空间 $\\mathcal{S}$，到其正交补上的投影算子是 $P_{\\mathcal{S}^\\perp} = I - P_\\mathcal{S}$，其中 $I$ 是单位矩阵。\n- 子空间的德摩根定律指出 $(\\mathcal{U} \\cap \\mathcal{V})^\\perp = \\mathcal{U}^\\perp + \\mathcal{V}^\\perp$。\n\n根据第一个性质，到交集 $\\mathcal{W} = \\mathcal{U} \\cap \\mathcal{V}$ 上的投影算子可以用到其补空间 $\\mathcal{W}^\\perp$ 上的投影算子来表示：\n$$P_{\\mathcal{U} \\cap \\mathcal{V}} = I - P_{(\\mathcal{U} \\cap \\mathcal{V})^\\perp}$$\n使用第二个性质，我们可以代入补空间的表达式：\n$$P_{\\mathcal{U} \\cap \\mathcal{V}} = I - P_{\\mathcal{U}^\\perp + \\mathcal{V}^\\perp}$$\n两个子空间之和 $\\mathcal{S}_1 + \\mathcal{S}_2$ 是由它们基的并集所张成的空间。如果 $Q_1$ 和 $Q_2$ 分别是其列构成 $\\mathcal{S}_1$ 和 $\\mathcal{S}_2$ 标准正交基的矩阵，则 $\\mathcal{S}_1 + \\mathcal{S}_2 = \\operatorname{range}([Q_1, Q_2])$。令 $C = [Q_{\\mathcal{U}^\\perp}, Q_{\\mathcal{V}^\\perp}]$ 是通过拼接 $\\mathcal{U}^\\perp$ 和 $\\mathcal{V}^\\perp$ 的基向量形成的矩阵。\n到任何矩阵 $A$ 的值域上的正交投影算子由 $A A^{+}$ 给出，其中 $A^{+}$ 是 $A$ 的Moore-Penrose伪逆。因此，到 $\\mathcal{U}^\\perp + \\mathcal{V}^\\perp$ 上的投影算子是：\n$$P_{\\mathcal{U}^\\perp + \\mathcal{V}^\\perp} = C C^{+}$$\n结合这些结果，得到交集上投影算子的最终闭式表达式：\n$$P_{\\mathcal{U} \\cap \\mathcal{V}} = I - [Q_{\\mathcal{U}^\\perp}, Q_{\\mathcal{V}^\\perp}] [Q_{\\mathcal{U}^\\perp}, Q_{\\mathcal{V}^\\perp}]^{+}$$\n这构成了主要的，或“闭式”的投影算子，我们记为 $P_{CF}$。\n\n**3. 通过Dykstra算法的迭代投影算子**\n\nDykstra算法是一种迭代方法，用于寻找一个向量在两个或多个凸集交集上的投影。由于子空间是凸集，该算法可用于寻找任意向量 $x \\in \\mathbb{R}^n$ 的 $P_{\\mathcal{U} \\cap \\mathcal{V}}x$。对于具有投影算子 $P_\\mathcal{U}$ 和 $P_\\mathcal{V}$ 的两个子空间 $\\mathcal{U}$ 和 $\\mathcal{V}$，投影一个点 $x$ 的算法如下：\n初始化：$y_0 = x$，以及修正项 $p_0 = \\mathbf{0}$，$q_0 = \\mathbf{0}$。\n对于 $k=1, 2, \\dots$:\n1. $x_k = P_\\mathcal{U}(y_{k-1} + p_{k-1})$\n2. $p_k = (y_{k-1} + p_{k-1}) - x_k$\n3. $y_k = P_\\mathcal{V}(x_k + q_{k-1})$\n4. $q_k = (x_k + q_{k-1}) - y_k$\n序列 $y_k$ 收敛于 $P_{\\mathcal{U} \\cap \\mathcal{V}}x$。迭代持续进行，直到变化量 $\\lVert y_k - y_{k-1} \\rVert_2$ 小于容差 $10^{-12}$，或达到最大迭代次数 $2000$ 次。\n\n为了构造完整的投影矩阵 $P_{Dykstra}$，此过程应用于 $n$ 个标准基向量 $e_i \\in \\mathbb{R}^n$ 中的每一个。得到的投影向量构成了 $P_{Dykstra}$ 的第 $i$ 列：\n$$P_{Dykstra} = [ \\operatorname{Dykstra}(e_1), \\operatorname{Dykstra}(e_2), \\dots, \\operatorname{Dykstra}(e_n) ]$$\n其中 $\\operatorname{Dykstra}(x)$ 表示输入为 $x$ 时算法的输出。\n\n**4. 评估指标**\n\n对于每个测试用例，计算三个量来评估和比较投影算子：\n1.  **弗罗贝尼乌斯范数差 ($e$)**：该指标衡量两个构造的投影算子之间的差异，即 $e = \\lVert P_{CF} - P_{Dykstra} \\rVert_F$。这个值应该接近于零，反映了Dykstra算法的收敛性。\n2.  **交集维数 ($d$)**：对于一个正交投影算子 $P$，其秩等于其迹，即 $\\operatorname{rank}(P) = \\operatorname{tr}(P)$，这给出了它所投影到的子空间的维数。因此，交集的维数计算为 $d = \\operatorname{dim}(\\mathcal{U} \\cap \\mathcal{V}) = \\operatorname{tr}(P_{CF})$。由于涉及数值计算，结果会四舍五入到最接近的整数。\n3.  **幂等性残差 ($i$)**：一个矩阵 $P$ 是投影算子的充要条件是它是幂等的，即 $P^2 = P$。残差的弗罗贝尼乌斯范数 $i = \\lVert P_{CF}^2 - P_{CF} \\rVert_F$ 衡量了计算出的闭式投影算子在多大程度上满足这一基本性质。这个值应该接近机器精度。", "answer": "```python\nimport numpy as np\n\ndef get_orthonormal_bases(A, tol):\n    \"\"\"\n    Computes orthonormal bases for the column space of A and its orthogonal complement.\n    Uses SVD for numerical stability.\n    \"\"\"\n    if A.size == 0 or A.shape[1] == 0:\n        return np.empty((A.shape[0], 0)), np.identity(A.shape[0])\n\n    U, s, _ = np.linalg.svd(A, full_matrices=True)\n    rank = np.sum(s  tol)\n    \n    Q = U[:, :rank]\n    Q_perp = U[:, rank:]\n    return Q, Q_perp\n\ndef get_intersection_projector(Q_U_perp, Q_V_perp, n, tol):\n    \"\"\"\n    Constructs the orthogonal projector onto the intersection U_cap_V\n    using the formula P = I - P_{U_perp + V_perp}.\n    \"\"\"\n    # Concatenate the bases for the orthogonal complements\n    if Q_U_perp.shape[1] == 0 and Q_V_perp.shape[1] == 0:\n        C = np.empty((n, 0))\n    elif Q_U_perp.shape[1] == 0:\n        C = Q_V_perp\n    elif Q_V_perp.shape[1] == 0:\n        C = Q_U_perp\n    else:\n        C = np.hstack((Q_U_perp, Q_V_perp))\n\n    # Projector onto the sum of the complements\n    if C.shape[1] == 0:\n        # Sum of complements is the {0} subspace, projector is zero matrix\n        P_sum_perp = np.zeros((n, n))\n    else:\n        # P = A A^+, numerically stable via pinv\n        P_sum_perp = C @ np.linalg.pinv(C, rcond=tol)\n    \n    # P_intersection = I - P_sum_perp\n    P_CF = np.identity(n) - P_sum_perp\n    return P_CF\n\ndef dykstra_projection(x, P_U, P_V, tol, max_iter):\n    \"\"\"\n    Projects a vector x onto the intersection of two subspaces U and V\n    using Dykstra's alternating projection algorithm.\n    \"\"\"\n    y = x.copy()\n    p = np.zeros_like(x)\n    q = np.zeros_like(x)\n\n    for _ in range(max_iter):\n        y_prev = y\n        \n        x_k = P_U @ (y_prev + p)\n        p = (y_prev + p) - x_k\n\n        y = P_V @ (x_k + q)\n        q = (x_k + q) - y\n\n        if np.linalg.norm(y - y_prev)  tol:\n            break\n            \n    return y\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    epsilon = 1e-8\n    e1_3, e2_3, e3_3 = np.identity(3).T\n    e1_4, e2_4, e3_4, e4_4 = np.identity(4).T\n\n    test_cases = [\n        # Case 1 (n=5)\n        (np.array([[1, 0], [1, 0], [0, 1], [0, 0], [0, 0]]), \n         np.array([[1, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1], [0, 0, 0]])),\n        # Case 2 (n=4)\n        (np.vstack([e1_4, e2_4]).T, np.vstack([e1_4, e2_4, e3_4]).T),\n        # Case 3 (n=3)\n        (e1_3.reshape(-1, 1), e2_3.reshape(-1, 1)),\n        # Case 4 (n=3)\n        (np.identity(3), np.identity(3)),\n        # Case 5 (n=3), with epsilon\n        (np.vstack([e1_3, e2_3]).T, np.array([[1, 0], [epsilon, 1], [0, 0]]))\n    ]\n\n    SVD_TOL = 1e-12\n    DYKSTRA_TOL = 1e-12\n    DYKSTRA_MAX_ITER = 2000\n\n    results = []\n\n    for U_basis, V_basis in test_cases:\n        n = U_basis.shape[0]\n\n        # 1  2. Get orthonormal bases for subspaces and their complements\n        Q_U, Q_U_perp = get_orthonormal_bases(U_basis, SVD_TOL)\n        Q_V, Q_V_perp = get_orthonormal_bases(V_basis, SVD_TOL)\n        \n        # 3. Construct the closed-form projector onto the intersection\n        P_CF = get_intersection_projector(Q_U_perp, Q_V_perp, n, SVD_TOL)\n\n        # 4. Construct projector using Dykstra's algorithm\n        P_U = Q_U @ Q_U.T\n        P_V = Q_V @ Q_V.T\n        P_Dykstra = np.zeros((n, n))\n        for i in range(n):\n            e_i = np.zeros(n)\n            e_i[i] = 1.0\n            col = dykstra_projection(e_i, P_U, P_V, DYKSTRA_TOL, DYKSTRA_MAX_ITER)\n            P_Dykstra[:, i] = col\n\n        # 5. Compute the required metrics\n        # Frobenius norm difference\n        e = np.linalg.norm(P_CF - P_Dykstra, 'fro')\n        \n        # Dimension of intersection (rank of projector = trace of projector)\n        d = int(np.round(np.trace(P_CF)))\n        \n        # Idempotence residual of the closed-form projector\n        i = np.linalg.norm(P_CF @ P_CF - P_CF, 'fro')\n\n        results.append([e, d, i])\n    \n    # Format and print the final output\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3567687"}]}