{"hands_on_practices": [{"introduction": "理解事后分层估计量的统计特性是有效应用该方法的第一步。本次练习将通过理论推导与计算模拟相结合的方式，帮助您建立对估计量方差的扎实理解。\n\n您将首先推导包含有限总体校正的精确条件方差公式，然后通过蒙特卡洛模拟来验证该公式，并评估在实践中常用的“代入式”方差估计量的准确性，从而将抽象理论与动手实践紧密相连。[@problem_id:3330424]", "problem": "考虑一个有限总体，它被划分为 $H$ 个事后层，用 $h \\in \\{1,\\dots,H\\}$ 进行索引。层 $h$ 包含 $N_h$ 个单元，其值为 $\\{y_{h,i}\\}_{i=1}^{N_h}$。从规模为 $N=\\sum_{h=1}^H N_h$ 的完整总体中，进行一次单阶段不重复简单随机抽样（SRSWOR），样本量为 $n$。抽样后，观测到的各层样本数为 $\\{n_h\\}_{h=1}^H$，且满足 $\\sum_{h=1}^H n_h = n$。定义总体事后分层权重为 $W_h = N_h/N$。总体均值的事后分层估计量为 $\\hat{\\mu}_{PS} = \\sum_{h=1}^H W_h \\,\\bar{Y}_{h}$，其中 $\\bar{Y}_{h}$ 是从层 $h$ 观测到的单元的样本均值。在已实现的 $\\{n_h\\}$ 的条件下进行分析。\n\n任务 A（推导）：从有限总体中不重复简单随机抽样（SRSWOR）的基本定义和全方差公式出发，用各层规模 $\\{N_h\\}$、已实现的各层样本量 $\\{n_h\\}$、有限总体事后分层权重 $\\{W_h\\}$ 以及有限总体的层内方差来表示精确的条件方差 $\\operatorname{Var}(\\hat{\\mu}_{PS}\\mid \\{n_h\\})$。你必须从一个经过充分检验的事实开始：即在一个规模为 $N_h$ 的单一有限层内进行不重复简单随机抽样，对于从 $n_h$ 个单元计算出的样本均值，其方差等于有限总体校正系数与按 $1/n_h$ 缩放的层内方差的乘积。不要预先假设或陈述最终表达式；请从第一性原理出发进行推导。\n\n任务 B（通过随机模拟进行评估）：当层内有限总体方差在实践中未知时，一个自然的置入估计量是将每个未知的层内方差替换为从该层观测单元计算出的相应无偏样本方差。请在已实现的 $\\{n_h\\}$ 条件下，通过蒙特卡洛（随机）模拟来评估该置入估计量的准确性，具体方法是将其平均值与任务 A 中推导出的精确条件方差进行比较。\n\n针对下方测试套件中的每个测试用例，精确实现以下步骤。\n\n1. 确定性总体构建。对于每个层 $h \\in \\{1,\\dots,H\\}$ 和每个单元索引 $i \\in \\{1,\\dots,N_h\\}$，通过测试套件中给定的针对具体用例的确定性公式生成有限总体值 $y_{h,i}$。这确保了总体是固定且已知的。\n\n2. 精确条件方差。令 $S_h^2$ 表示层 $h$ 内的有限总体方差，计算时分母为 $N_h-1$，即 $S_h^2 = \\frac{1}{N_h-1}\\sum_{i=1}^{N_h}\\left(y_{h,i}-\\mu_h\\right)^2$，其中 $\\mu_h = \\frac{1}{N_h}\\sum_{i=1}^{N_h} y_{h,i}$。使用你从任务 A 中得到的推导结果，计算在给定已实现的 $\\{n_h\\}$ 的条件下 $\\hat{\\mu}_{PS}$ 的精确条件方差 $V_{\\text{true}}$。\n\n3. 抽样分布的蒙特卡洛近似。在已实现的 $\\{n_h\\}$ 条件下，对以下实验进行 $R$ 次独立重复模拟：对于每个层 $h$，从该层的 $N_h$ 个单元中抽取一个大小为 $n_h$ 的不重复简单随机样本；当 $n_h \\ge 2$ 时，计算层的样本均值 $\\bar{Y}_h$ 和分母为 $n_h-1$ 的无偏层样本方差 $s_h^2$。当 $n_h = 1$ 时，按惯例设 $s_h^2 = 0$。对于每次重复 $r \\in \\{1,\\dots,R\\}$，计算：\n   - 事后分层估计量 $\\hat{\\mu}_{PS}^{(r)} = \\sum_{h=1}^H W_h \\bar{Y}_h^{(r)}$，\n   - 置入方差估计量 $\\hat{V}^{(r)} = \\sum_{h=1}^H W_h^2 \\left(1 - \\frac{n_h}{N_h}\\right)\\frac{s_h^{2\\,(r)}}{n_h}$。\n   最后，将 $\\{\\hat{\\mu}_{PS}^{(r)}\\}_{r=1}^R$ 的经验方差（分母为 $R-1$）作为蒙特卡洛方差 $V_{\\text{mc}}$ 进行计算，并计算蒙特卡洛平均置入方差 $\\overline{V}_{\\text{plug}} = \\frac{1}{R}\\sum_{r=1}^R \\hat{V}^{(r)}$。\n\n4. 准确性指标。针对每个测试用例，报告以下浮点数：\n   - $V_{\\text{true}}$；\n   - 蒙特卡洛方差的绝对相对误差，$|V_{\\text{mc}} - V_{\\text{true}}|/V_{\\text{true}}$；\n   - 置入估计量的相对偏差，$(\\overline{V}_{\\text{plug}} - V_{\\text{true}})/V_{\\text{true}}$。\n   所有比率必须以小数形式报告（而非百分比）。\n\n实现细节：\n- 随机性必须是可复现的。根据每个测试用例的指定，使用固定的伪随机种子。\n- 所有层内抽样必须是不重复的，并且在所有组合上是均匀的。\n- 所有计算都是无量纲的；不涉及物理单位。\n\n测试套件：\n为以下三个测试用例提供结果。对每个用例，使用指定的重复次数 $R$ 和种子。\n\n- 用例 1：\n  - $H = 3$，\n  - $(N_1,N_2,N_3) = (30,40,50)$，\n  - $(n_1,n_2,n_3) = (5,8,10)$，\n  - 总体生成器：对于每个 $h \\in \\{1,2,3\\}$ 和 $i \\in \\{1,\\dots,N_h\\}$，\n    $y_{h,i} = \\alpha_h + \\beta_h \\, i + \\gamma_h \\, (-1)^i$，其中\n    $(\\alpha_1,\\alpha_2,\\alpha_3) = (10,20,30)$，\n    $(\\beta_1,\\beta_2,\\beta_3) = (0.5,1.0,1.5)$，\n    $(\\gamma_1,\\gamma_2,\\gamma_3) = (3,2,1)$。\n  - 重复次数 $R = 20000$，\n  - 种子 $= 202401$。\n\n- 用例 2（包含一个层样本量为 $n_h=1$ 的边缘情况）：\n  - $H = 3$，\n  - $(N_1,N_2,N_3) = (20,25,35)$，\n  - $(n_1,n_2,n_3) = (1,4,7)$，\n  - 总体生成器：对于每个 $h \\in \\{1,2,3\\}$ 和 $i \\in \\{1,\\dots,N_h\\}$，\n    $y_{h,i} = \\alpha_h + \\beta_h \\, \\sqrt{i} + \\gamma_h \\, \\left((i \\bmod 3) - 1\\right)$，其中\n    $(\\alpha_1,\\alpha_2,\\alpha_3) = (5,8,12)$，\n    $(\\beta_1,\\beta_2,\\beta_3) = (2.0,1.0,0.5)$，\n    $(\\gamma_1,\\gamma_2,\\gamma_3) = (1,3,2)$。\n  - 重复次数 $R = 20000$，\n  - 种子 $= 202402$。\n\n- 用例 3（边界情况，其中一个层被完全抽样，以强调有限总体校正的作用）：\n  - $H = 2$，\n  - $(N_1,N_2) = (12,18)$，\n  - $(n_1,n_2) = (12,9)$，\n  - 总体生成器：对于每个 $h \\in \\{1,2\\}$ 和 $i \\in \\{1,\\dots,N_h\\}$，\n    $y_{h,i} = \\alpha_h + \\beta_h \\, i + \\gamma_h \\, \\frac{i^2}{N_h}$，其中\n    $(\\alpha_1,\\alpha_2) = (0,4)$，\n    $(\\beta_1,\\beta_2) = (1.0,0.5)$，\n    $(\\gamma_1,\\gamma_2) = (0.2,0.1)$。\n  - 重复次数 $R = 20000$，\n  - 种子 $= 202403$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含一个类似JSON的列表表示，该列表有三个元素（每个测试用例一个），其中每个元素是按上述第4项指定顺序排列的三个浮点数的列表，即\n$[ [V_{\\text{true}}, |V_{\\text{mc}}-V_{\\text{true}}|/V_{\\text{true}}, (\\overline{V}_{\\text{plug}}-V_{\\text{true}})/V_{\\text{true}}], \\dots ]$。\n例如，一个有效的形状是 $[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],[x_{31},x_{32},x_{33}]]$，不含任何额外文本。", "solution": "用户提供的问题被评估为有效。它在科学上基于抽样调查和蒙特卡洛模拟的原理，问题提法得当，目标明确，数据充分，并且没有任何在问题验证协议中列出的导致问题无效的缺陷。因此，我们可以继续提供完整的解决方案。\n\n问题分为两部分：任务 A，事后分层估计量条件方差的理论推导；任务 B，通过随机模拟对一个置入方差估计量进行数值评估。\n\n### 任务 A：条件方差的推导\n\n我们被要求推导精确的条件方差 $\\operatorname{Var}(\\hat{\\mu}_{PS}\\mid \\{n_h\\})$。总体均值的事后分层估计量由下式给出：\n$$\n\\hat{\\mu}_{PS} = \\sum_{h=1}^H W_h \\bar{Y}_{h}\n$$\n其中 $W_h = N_h/N$ 是已知的总体事后分层权重，而 $\\bar{Y}_h$ 是在层 h 中观测到的 $n_h$ 个单元的样本均值。\n\n推导在已实现的各层样本量 $\\{n_h\\}_{h=1}^H$ 的条件下进行。这意味着在整个推导过程中，我们将 $n_h$ 的值视为固定常数。随机性来源于在给定各层样本量的情况下，从每层中选择具体单元的过程。\n\n随机变量和的方差涉及协方差项。对 $\\hat{\\mu}_{PS}$ 应用方差算子：\n$$\n\\operatorname{Var}(\\hat{\\mu}_{PS}\\mid \\{n_h\\}) = \\operatorname{Var}\\left(\\sum_{h=1}^H W_h \\bar{Y}_h \\mid \\{n_h\\}\\right)\n$$\n使用加权和的方差通用公式 $\\operatorname{Var}(\\sum_{i} a_i X_i) = \\sum_{i} a_i^2 \\operatorname{Var}(X_i) + \\sum_{i \\neq j} a_i a_j \\operatorname{Cov}(X_i, X_j)$，我们得到：\n$$\n\\operatorname{Var}(\\hat{\\mu}_{PS}\\mid \\{n_h\\}) = \\sum_{h=1}^H W_h^2 \\operatorname{Var}(\\bar{Y}_h \\mid n_h) + \\sum_{h \\neq k} W_h W_k \\operatorname{Cov}(\\bar{Y}_h, \\bar{Y}_k \\mid \\{n_h\\})\n$$\n问题陈述了从总总体中抽取一个大小为 $n$ 的单阶段不重复简单随机样本（SRSWOR）。然而，为了分析事后分层估计量，标准的理论方法（也是以 $\\{n_h\\}$ 为条件所隐含的方法）是将抽样过程在概念上视为等同于从每个层 $h$ 中独立进行一次大小为 $n_h$ 的不重复简单随机抽样。在这个条件框架下，一个层中单元的选择独立于另一层中的选择。因此，对于 $h \\ne k$，样本均值 $\\bar{Y}_h$ 和 $\\bar{Y}_k$ 是条件独立的。这意味着它们的条件协方差为零：\n$$\n\\operatorname{Cov}(\\bar{Y}_h, \\bar{Y}_k \\mid \\{n_h\\}) = 0 \\quad \\text{for } h \\neq k\n$$\n因此，由于协方差项之和为零，方差表达式简化为：\n$$\n\\operatorname{Var}(\\hat{\\mu}_{PS}\\mid \\{n_h\\}) = \\sum_{h=1}^H W_h^2 \\operatorname{Var}(\\bar{Y}_h \\mid n_h)\n$$\n现在，我们必须找到 $\\operatorname{Var}(\\bar{Y}_h \\mid n_h)$ 的表达式。问题指导我们使用关于在规模为 $N_h$ 的单一有限总体层内，从大小为 $n_h$ 的不重复简单随机样本计算出的样本均值的方差的成熟结论。该方差由下式给出：\n$$\n\\operatorname{Var}(\\bar{Y}_h \\mid n_h) = \\left(1 - \\frac{n_h}{N_h}\\right) \\frac{S_h^2}{n_h}\n$$\n其中：\n-   $\\left(1 - \\frac{n_h}{N_h}\\right)$ 是有限总体校正（FPC），它考虑了从有限总体中进行不重复抽样这一事实。随着 $n_h$ 接近 $N_h$，关于均值的不确定性减小，当 $n_h = N_h$ 时完全消失。\n-   $S_h^2$ 是层 $h$ 中值 $\\{y_{h,i}\\}_{i=1}^{N_h}$ 的有限总体方差，定义时分母为 $N_h-1$，以使其与在抽样理论中的作用保持一致：\n    $$\n    S_h^2 = \\frac{1}{N_h-1}\\sum_{i=1}^{N_h}\\left(y_{h,i}-\\mu_h\\right)^2\n    $$\n    其中 $\\mu_h$ 是层 $h$ 的真实均值。\n\n将 $\\operatorname{Var}(\\bar{Y}_h \\mid n_h)$ 的表达式代回我们的求和式中，我们得到了事后分层估计量的精确条件方差的最终推导表达式：\n$$\n\\operatorname{Var}(\\hat{\\mu}_{PS}\\mid \\{n_h\\}) = \\sum_{h=1}^H W_h^2 \\left(1 - \\frac{n_h}{N_h}\\right) \\frac{S_h^2}{n_h}\n$$\n这就是我们将表示为 $V_{\\text{true}}$ 的表达式。它是总体层规模 $\\{N_h\\}$、层权重 $\\{W_h\\}$、已实现的样本量 $\\{n_h\\}$ 和（通常未知的）真实层内总体方差 $\\{S_h^2\\}$ 的函数。\n\n### 任务 B：模拟设计\n\n该模拟评估了一个“置入”方差估计量 $\\hat{V}$ 的性质，该估计量是通过将未知总体方差 $S_h^2$ 的一个估计值代入 $V_{\\text{true}}$ 的公式中形成的。基于大小为 $n_h$ 的样本的 $S_h^2$ 的标准无偏估计量是样本方差 $s_h^2$：\n$$\ns_h^2 = \\frac{1}{n_h-1}\\sum_{j=1}^{n_h}(y_{h,j}^{\\text{sample}} - \\bar{Y}_h)^2 \\quad \\text{for } n_h \\ge 2\n$$\n问题指定，按惯例，如果 $n_h=1$，则 $s_h^2=0$。因此，方差的置入估计量是：\n$$\n\\hat{V} = \\sum_{h=1}^H W_h^2 \\left(1 - \\frac{n_h}{N_h}\\right)\\frac{s_h^2}{n_h}\n$$\n对每个测试用例，模拟按以下步骤进行：\n\n1.  **总体构建**：根据测试用例中提供的确定性函数 $y_{h,i} = f(h,i)$，为每个层 $h$ 构建一个不可变的有限总体。这使得能够精确计算真实的总体参数。\n\n2.  **真实方差计算 ($V_{\\text{true}}$)**：对于每个层 $h$，从生成的总体值计算出真实的有限总体方差 $S_h^2$。这些值与给定的 $N_h$ 和 $n_h$ 一起，被用于任务 A 中推导出的公式，以计算精确的条件方差 $V_{\\text{true}}$。\n\n3.  **蒙特卡洛模拟**：生成大量的重复次数 $R$，以近似抽样分布。对于每次重复 $r \\in \\{1,\\dots,R\\}$：\n    a.  对每个层 $h \\in \\{1,\\dots,H\\}$，从层 $h$ 的总体中通过不重复简单随机抽样抽取一个大小为 $n_h$ 的新样本。\n    b.  从抽取的样本中为每个层计算样本均值 $\\bar{Y}_h^{(r)}$ 和样本方差 $s_h^{2,(r)}$。关键是，对于任何 $n_h=1$ 的层，应用 $s_h^2=0$ 的规则。\n    c.  计算并存储事后分层估计 $\\hat{\\mu}_{PS}^{(r)}$ 及其对应的置入方差估计 $\\hat{V}^{(r)} = \\sum_{h} W_h^2 (1 - n_h/N_h) s_h^{2,(r)}/n_h$。\n\n4.  **指标计算**：在所有 $R$ 次重复完成后：\n    a.  蒙特卡洛方差 $V_{\\text{mc}}$ 被计算为 $R$ 个存储的 $\\hat{\\mu}_{PS}^{(r)}$ 值的样本方差（分母为 $R-1$）。这可作为 $V_{\\text{true}}$ 的一个基于模拟的估计。\n    b.  平均置入方差 $\\overline{V}_{\\text{plug}}$ 被计算为 $R$ 个存储的 $\\hat{V}^{(r)}$ 值的算术平均值。这近似了置入估计量的期望值 $E[\\hat{V} \\mid \\{n_h\\}]$。\n    c.  计算指定的准确性指标：\n        -   $V_{\\text{true}}$\n        -   $|V_{\\text{mc}} - V_{\\text{true}}|/V_{\\text{true}}$：这衡量了蒙特卡洛模拟本身收敛到真实方差的程度。当 $R$ 很大时，这个值应该很小。\n        -   $(\\overline{V}_{\\text{plug}} - V_{\\text{true}})/V_{\\text{true}}$：这衡量了置入方差估计量的相对偏差。理论预测，当且仅当所有 $n_h \\ge 2$ 时，该估计量是无偏的 ($E[\\hat{V}] = V_{\\text{true}}$)。如果有任何 $n_h=1$，该估计量预计是有偏的，因为 $E[s_h^2 | n_h=1] = 0 \\neq S_h^2$。\n\n实现将使用固定的随机种子以保证可复现性，并将为所提供的三个测试用例中的每一个执行这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the post-stratification problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"H\": 3,\n            \"N_h\": (30, 40, 50),\n            \"n_h\": (5, 8, 10),\n            \"pop_gen_params\": {\n                \"alpha\": (10, 20, 30),\n                \"beta\": (0.5, 1.0, 1.5),\n                \"gamma\": (3, 2, 1)\n            },\n            \"pop_gen_func\": lambda h, i, p: p[\"alpha\"][h-1] + p[\"beta\"][h-1] * i + p[\"gamma\"][h-1] * (-1)**i,\n            \"R\": 20000,\n            \"seed\": 202401\n        },\n        {\n            \"H\": 3,\n            \"N_h\": (20, 25, 35),\n            \"n_h\": (1, 4, 7),\n            \"pop_gen_params\": {\n                \"alpha\": (5, 8, 12),\n                \"beta\": (2.0, 1.0, 0.5),\n                \"gamma\": (1, 3, 2)\n            },\n            \"pop_gen_func\": lambda h, i, p: p[\"alpha\"][h-1] + p[\"beta\"][h-1] * np.sqrt(i) + p[\"gamma\"][h-1] * ((i % 3) - 1),\n            \"R\": 20000,\n            \"seed\": 202402\n        },\n        {\n            \"H\": 2,\n            \"N_h\": (12, 18),\n            \"n_h\": (12, 9),\n            \"pop_gen_params\": {\n                \"alpha\": (0, 4),\n                \"beta\": (1.0, 0.5),\n                \"gamma\": (0.2, 0.1)\n            },\n            \"pop_gen_func\": lambda h, i, p, N_h: p[\"alpha\"][h-1] + p[\"beta\"][h-1] * i + p[\"gamma\"][h-1] * i**2 / N_h,\n            \"R\": 20000,\n            \"seed\": 202403\n        }\n    ]\n\n    results_all_cases = []\n\n    for case_idx, case in enumerate(test_cases):\n        H = case[\"H\"]\n        N_h_tuple = case[\"N_h\"]\n        n_h_tuple = case[\"n_h\"]\n        pop_gen_params = case[\"pop_gen_params\"]\n        pop_gen_func = case[\"pop_gen_func\"]\n        R = case[\"R\"]\n        seed = case[\"seed\"]\n\n        rng = np.random.default_rng(seed)\n\n        # 1. Deterministic population construction\n        populations = []\n        for h_idx in range(H):\n            h = h_idx + 1\n            N_h_val = N_h_tuple[h_idx]\n            indices = np.arange(1, N_h_val + 1)\n            if case_idx == 2: # Case 3 has a different generator signature\n                y_values = pop_gen_func(h, indices, pop_gen_params, N_h_val)\n            else:\n                y_values = pop_gen_func(h, indices, pop_gen_params)\n            populations.append(y_values)\n        \n        # 2. Exact conditional variance\n        N_h_arr = np.array(N_h_tuple, dtype=float)\n        n_h_arr = np.array(n_h_tuple, dtype=float)\n        \n        N_total = np.sum(N_h_arr)\n        W_h_arr = N_h_arr / N_total\n        \n        # Calculate true population variances S_h^2\n        S_h_sq_arr = np.array([np.var(pop, ddof=1) if len(pop) > 1 else 0 for pop in populations])\n        \n        # Finite Population Correction\n        fpc_arr = 1.0 - n_h_arr / N_h_arr\n        \n        # Calculate V_true\n        # Add a small epsilon to denominator to avoid division by zero warning if n_h=0, though not in test cases\n        \n        # If n_h_arr[h] is zero, the term is undefined. Here n_h >= 1.\n        # If S_h_sq_arr[h] is zero, the term is zero.\n        # If fpc_arr[h] is zero (n_h=N_h), the term is zero.\n        # The logic below handles these cases correctly.\n        V_true_terms = np.zeros_like(W_h_arr, dtype=float)\n        valid_n_h_mask = n_h_arr > 0\n        V_true_terms[valid_n_h_mask] = (W_h_arr[valid_n_h_mask]**2 * fpc_arr[valid_n_h_mask] * S_h_sq_arr[valid_n_h_mask]) / n_h_arr[valid_n_h_mask]\n        V_true = np.sum(V_true_terms)\n\n        # 3. Monte Carlo approximation\n        mu_ps_reps = np.zeros(R)\n        V_hat_reps = np.zeros(R)\n\n        for r in range(R):\n            mu_ps_r = 0.0\n            V_hat_r = 0.0\n            for h_idx in range(H):\n                # Draw SRSWOR sample for stratum h\n                sample = rng.choice(populations[h_idx], size=int(n_h_arr[h_idx]), replace=False)\n                \n                # Compute sample mean\n                y_bar_h = np.mean(sample)\n                \n                # Compute sample variance s_h^2, with rule for n_h = 1\n                s_h_sq_r = 0.0\n                if n_h_arr[h_idx] > 1:\n                    s_h_sq_r = np.var(sample, ddof=1)\n                \n                # Accumulate for mu_ps and V_hat for this replicate\n                mu_ps_r += W_h_arr[h_idx] * y_bar_h\n                \n                # The contribution to variance is zero if n_h = 0. Problem has n_h >= 1.\n                if n_h_arr[h_idx] > 0:\n                    V_hat_r += (W_h_arr[h_idx]**2 * fpc_arr[h_idx] * s_h_sq_r) / n_h_arr[h_idx]\n            \n            mu_ps_reps[r] = mu_ps_r\n            V_hat_reps[r] = V_hat_r\n\n        # Calculate Monte Carlo variance and average plug-in variance\n        V_mc = np.var(mu_ps_reps, ddof=1)\n        V_plug_bar = np.mean(V_hat_reps)\n\n        # 4. Accuracy metrics\n        # Avoid division by zero if V_true is zero\n        if V_true == 0:\n            rel_err_V_mc = 0.0 if V_mc == 0.0 else np.inf\n            rel_bias_V_plug = 0.0 if V_plug_bar == 0.0 else np.inf\n        else:\n            rel_err_V_mc = np.abs(V_mc - V_true) / V_true\n            rel_bias_V_plug = (V_plug_bar - V_true) / V_true\n\n        results_all_cases.append([V_true, rel_err_V_mc, rel_bias_V_plug])\n    \n    # Final print statement in the exact required format.\n    print(f\"{results_all_cases}\")\n\nsolve()\n```", "id": "3330424"}, {"introduction": "一个稳健的统计分析不仅要提供点估计和方差，还必须审视估计过程本身的稳定性。本次练习将引导您从理论出发，构建并实现一系列用于事后分层分析的诊断工具。\n\n您将学习如何量化单个观测值的影响力和不同分层的杠杆作用，例如计算有效样本量和识别极端权重。掌握这些诊断技术，能够帮助您识别潜在的不稳定性来源，从而得出更可靠的统计结论。[@problem_id:3330477]", "problem": "考虑一个有限总体，其被划分为 $H$ 个事后分层（单元）。设各单元的真实总体构成由单元比例向量 $\\{p_h\\}_{h=1}^H$ 给出，满足 $\\sum_{h=1}^H p_h = 1$ 且 $p_h \\in (0,1)$。从一个大小为 $n$ 的样本中，假设实现的各单元样本数量为 $\\{n_h\\}_{h=1}^H$，其中 $\\sum_{h=1}^H n_h = n$ 且 $n_h \\in \\mathbb{N}$，$n_h \\geq 1$。假设在每个单元 $h$ 内，样本为我们感兴趣的结果提供了单元均值 $\\bar{y}_h$ 和单元内样本方差估计 $\\hat{\\sigma}_h^2$。考虑总体均值的标准事后分层估计量，该估计量通过总体构成对单元均值进行加权汇总。\n\n您将构建诊断指标，以量化有多少观测单元和多少单元对该估计量有有效贡献，并使用指示潜在方差膨胀的杠杆值或影响度量来标记极端权重。这些诊断指标必须从以下基本原则出发，根据第一性原理推导得出：\n\n- 加权均值估计的 Horvitz–Thompson 特征：均值估计量表示为加权和的比率，其权重经过校准，使得加权样本能够再现已知的总体构成。\n- 平滑估计量方差的一阶泰勒线性化：在各单元间独立和单元内抽样的假设下，事后分层均值的渐近方差可以表示为依赖于 $p_h$、$n_h$ 和 $\\hat{\\sigma}_h^2$ 的特定于单元的贡献之和。\n\n仅根据给定的输入定义以下量，不引入任何外部参数：\n\n1. 由事后分层所隐含的观测层面权重，以及每个观测的相应归一化影响。此影响定义为估计量对该观测值扰动的敏感度，并经过缩放以使所有观测的总和为 $1$。使用此值来量化对估计量有贡献的有效观测单元数。\n\n2. 来自事后分层均值方差的一阶线性化的单元层面方差贡献，以及每个单元相应的归一化方差杠杆值。使用此值来量化有效贡献方差的单元数。\n\n3. 一种基于影响的诊断方法来标记极端观测：如果一个观测的归一化影响超过 $2/n$，则将其分类为极端观测。\n\n4. 一种基于杠杆值的诊断方法来标记方差方面的极端单元：如果一个单元的归一化方差杠杆值超过 $2/H$，则将其分类为极端单元。\n\n如果总线性化方差聚合为零，则按照惯例将方差杠杆向量定义为全零，并将有效贡献方差的单元数定义为 $H$。\n\n您的任务是实现一个程序，为每个测试用例计算一个列表，该列表按此确切顺序包含以下六个量：\n\n- 有效观测单元数，以实数表示。\n- 有效贡献方差的单元数，以实数表示。\n- 根据上述观测影响规则计数的极端观测数量（一个整数）。\n- 根据上述方差杠杆规则计数的极端单元数量（一个整数）。\n- 所有观测中最大的观测层面归一化影响值，以实数表示。\n- 所有单元中最大的单元层面归一化方差杠杆值，以实数表示。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，每个测试用G例的六元组显示为一个用方括号括起来的、无空格的逗号分隔列表。例如，输出格式必须严格为 $[ [a_1,a_2,a_3,a_4,a_5,a_6],[b_1,b_2,b_3,b_4,b_5,b_6],\\ldots ]$ 的形式，且其中没有任何空格。\n\n请使用以下参数值的测试套件，它涵盖了一个一般情况、一个应会引发极端观测权重的高度稀疏单元的情况，以及一个零方差单元的边界情况：\n\n- 测试用例 1:\n  - $H = 5$\n  - $p = [0.15, 0.25, 0.10, 0.30, 0.20]$\n  - $n_h = [60, 80, 40, 70, 50]$\n  - $n = 300$\n  - $\\hat{\\sigma}^2 = [1.0, 0.8, 1.2, 0.9, 1.1]$\n\n- 测试用例 2:\n  - $H = 4$\n  - $p = [0.40, 0.30, 0.20, 0.10]$\n  - $n_h = [10, 90, 80, 70]$\n  - $n = 250$\n  - $\\hat{\\sigma}^2 = [1.0, 0.8, 0.7, 0.6]$\n\n- 测试用例 3:\n  - $H = 3$\n  - $p = [0.50, 0.30, 0.20]$\n  - $n_h = [150, 1, 49]$\n  - $n = 200$\n  - $\\hat{\\sigma}^2 = [1.0, 0.0, 1.5]$\n\n您的程序不得读取任何输入；它必须嵌入上述测试套件，并以确切的所需格式打印单行输出。所有答案都是无单位的实数或整数。实现必须与上述基本原则的推导一致，并且必须完全依赖于给定的参数 $H$、$p$、$n_h$、$n$ 和 $\\hat{\\sigma}_h^2$。", "solution": "问题要求推导和计算一个总体均值的事后分层估计量的几个诊断量。推导将基于指定的第一性原理。设事后分层的数量为 $H$，总体单元比例为 $\\{p_h\\}_{h=1}^H$，实现的样本单元数量为 $\\{n_h\\}_{h=1}^H$，总样本大小为 $n = \\sum_{h=1}^H n_h$，单元内样本方差估计为 $\\{\\hat{\\sigma}_h^2\\}_{h=1}^H$。\n\n总体均值 $\\mu$ 的事后分层估计量由下式给出：\n$$ \\hat{\\mu}_{ps} = \\sum_{h=1}^H p_h \\bar{y}_h $$\n其中 $\\bar{y}_h$ 是单元 $h$ 中结果变量的样本均值。设样本中的单个观测值由 $i=1, \\dots, n$ 索引，并令 $c(i)$ 表示观测 $i$ 所属的单元。单元均值为 $\\bar{y}_h = \\frac{1}{n_h} \\sum_{i: c(i)=h} y_i$。将此代入估计量可得：\n$$ \\hat{\\mu}_{ps} = \\sum_{h=1}^H p_h \\left( \\frac{1}{n_h} \\sum_{i: c(i)=h} y_i \\right) = \\sum_{h=1}^H \\sum_{i: c(i)=h} \\frac{p_h}{n_h} y_i $$\n这表明估计量是单个观测值的加权和，$\\hat{\\mu}_{ps} = \\sum_{i=1}^n w_i y_i$，其中位于单元 $c(i)$ 中的观测 $i$ 的权重 $w_i$ 由下式给出：\n$$ w_i = w_{c(i)} = \\frac{p_{c(i)}}{n_{c(i)}} $$\n很容易验证这些权重经过校准，其和为 $1$：\n$$ \\sum_{i=1}^n w_i = \\sum_{h=1}^H \\sum_{i: c(i)=h} w_i = \\sum_{h=1}^H n_h \\left( \\frac{p_h}{n_h} \\right) = \\sum_{h=1}^H p_h = 1 $$\n\n在确定了这些权重之后，我们可以推导出所需的诊断量。\n\n**1. 观测层面的诊断和有效单元数**\n\n问题将观测的归一化影响定义为估计量对该观测值的敏感度，并经过缩放以使总和为 $1$。$\\hat{\\mu}_{ps}$ 对 $y_i$ 变化的敏感度是其偏导数：\n$$ \\frac{\\partial \\hat{\\mu}_{ps}}{\\partial y_i} = \\frac{\\partial}{\\partial y_i} \\sum_{j=1}^n w_j y_j = w_i $$\n由于权重 $w_i$ 的和已经是 $1$，它们本身就是归一化影响值，我们将其表示为 $\\text{infl}_i = w_i$。\n\n有效观测单元数 $n_{eff, obs}$ 可以使用 Kish 的有效样本量公式对一组和为 $1$ 的权重进行量化：\n$$ n_{eff, obs} = \\frac{\\left(\\sum_{i=1}^n w_i\\right)^2}{\\sum_{i=1}^n w_i^2} = \\frac{1}{\\sum_{i=1}^n w_i^2} $$\n平方权重的总和可以通过按单元对观测进行分组来计算：\n$$ \\sum_{i=1}^n w_i^2 = \\sum_{h=1}^H \\sum_{i: c(i)=h} \\left(\\frac{p_h}{n_h}\\right)^2 = \\sum_{h=1}^H n_h \\frac{p_h^2}{n_h^2} = \\sum_{h=1}^H \\frac{p_h^2}{n_h} $$\n因此，有效观测单元数为：\n$$ n_{eff, obs} = \\frac{1}{\\sum_{h=1}^H p_h^2 / n_h} $$\n如果一个观测的影响超过 $2/n$，则将其标记为极端。对于单元 $h$ 中的一个观测，此条件为 $\\text{infl}_i = p_h/n_h > 2/n$。如果此条件成立，则该单元中的所有 $n_h$ 个观测都被分类为极端观测。极端观测的总数是满足此标准的所有单元 $h$ 的 $n_h$ 之和。最大的观测层面影响就是 $\\max_{h} (p_h/n_h)$。\n\n**2. 单元层面的诊断和有效单元数**\n\n在给定实现的样本量 $n_h$ 并假设各单元间抽样独立的条件下，事后分层估计量的方差为：\n$$ \\text{Var}(\\hat{\\mu}_{ps}) = \\text{Var}\\left(\\sum_{h=1}^H p_h \\bar{y}_h\\right) = \\sum_{h=1}^H p_h^2 \\text{Var}(\\bar{y}_h) $$\n使用提供的单元内样本方差估计 $\\hat{\\sigma}_h^2$ 作为总体方差 $\\sigma_h^2$ 的估计，并使用公式 $\\text{Var}(\\bar{y}_h) \\approx \\hat{\\sigma}_h^2/n_h$，$\\hat{\\mu}_{ps}$ 的估计方差为：\n$$ \\hat{V}(\\hat{\\mu}_{ps}) = \\sum_{h=1}^H \\frac{p_h^2 \\hat{\\sigma}_h^2}{n_h} $$\n此表达式将总方差表示为特定于单元的贡献之和，$V_h = p_h^2 \\hat{\\sigma}_h^2 / n_h$。单元 $h$ 的“归一化方差杠杆值”（表示为 $\\lambda_h$）是其对总方差的贡献分数：\n$$ \\lambda_h = \\frac{V_h}{\\sum_{j=1}^H V_j} = \\frac{p_h^2 \\hat{\\sigma}_h^2 / n_h}{\\sum_{j=1}^H p_j^2 \\hat{\\sigma}_j^2 / n_j} $$\n这些杠杆值的和为 $1$（前提是总方差不为零）。有效贡献方差的单元数 $n_{eff, cell}$ 使用应用于单元层面杠杆值的相同 Kish 公式计算：\n$$ n_{eff, cell} = \\frac{1}{\\sum_{h=1}^H \\lambda_h^2} $$\n根据问题陈述，如果总方差 $\\sum_j V_j=0$，我们定义所有 $h$ 的 $\\lambda_h=0$，并且 $n_{eff, cell}=H$。\n如果一个单元的杠杆值超过 $2/H$，即 $\\lambda_h > 2/H$，则将其标记为极端。总数是满足此条件的单元数量。最大的单元层面杠杆值是 $\\max_h \\lambda_h$。\n\n**计算公式摘要：**\n1.  **有效观测单元数**：$n_{eff, obs} = 1 / (\\sum_{h=1}^H p_h^2 / n_h)$\n2.  **有效贡献方差的单元数**：\n    - 设 $V_h = p_h^2 \\hat{\\sigma}_h^2 / n_h$ 且 $V_{tot} = \\sum_h V_h$。\n    - 如果 $V_{tot} = 0$，则 $n_{eff, cell} = H$。\n    - 否则，$\\lambda_h = V_h / V_{tot}$ 且 $n_{eff, cell} = 1 / (\\sum_{h=1}^H \\lambda_h^2)$。\n3.  **极端观测数量**：$\\sum_{h=1}^H n_h \\cdot \\mathbf{1}(p_h/n_h > 2/n)$，其中 $\\mathbf{1}(\\cdot)$ 是指示函数。\n4.  **极端单元数量**：$\\sum_{h=1}^H \\mathbf{1}(\\lambda_h > 2/H)$，其中如果 $V_{tot}=0$，$\\lambda_h$ 定义为 $0$。\n5.  **最大观测层面归一化影响**：$\\max_{h} (p_h / n_h)$。\n6.  **最大单元层面归一化方差杠杆值**：$\\max_h \\lambda_h$，如果 $V_{tot}=0$ 则定义为 $0$。\n下面针对给定的测试用例实现了这些公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the post-stratification diagnostics problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        (5, [0.15, 0.25, 0.10, 0.30, 0.20], [60, 80, 40, 70, 50], 300, [1.0, 0.8, 1.2, 0.9, 1.1]),\n        # Test Case 2\n        (4, [0.40, 0.30, 0.20, 0.10], [10, 90, 80, 70], 250, [1.0, 0.8, 0.7, 0.6]),\n        # Test Case 3\n        (3, [0.50, 0.30, 0.20], [150, 1, 49], 200, [1.0, 0.0, 1.5]),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        H, p_list, n_h_list, n, sigma2_list = case\n        \n        p = np.array(p_list, dtype=float)\n        n_h = np.array(n_h_list, dtype=float)\n        sigma2 = np.array(sigma2_list, dtype=float)\n\n        # 1. Effective number of observational units\n        sum_sq_weights = np.sum(p**2 / n_h)\n        n_eff_obs = 1.0 / sum_sq_weights\n\n        # 3.  5. Observation-level diagnostics\n        obs_influences = p / n_h\n        # 5. Maximum observation-level normalized influence\n        max_obs_influence = np.max(obs_influences)\n        \n        # 3. Count of extreme observations\n        threshold_obs = 2.0 / n\n        extreme_obs_mask = obs_influences > threshold_obs\n        count_extreme_obs = int(np.sum(n_h[extreme_obs_mask]))\n\n        # 2., 4.,  6. Cell-level diagnostics\n        V_h = (p**2 * sigma2) / n_h\n        V_tot = np.sum(V_h)\n\n        if V_tot == 0:\n            # Special case as defined in the problem\n            # 2. Effective number of variance-contributing cells\n            n_eff_cell = float(H)\n            # 6. Maximum cell-level normalized variance-leverage\n            max_cell_leverage = 0.0\n            # 4. Count of extreme cells\n            count_extreme_cells = 0\n        else:\n            cell_leverages = V_h / V_tot\n            # 2. Effective number of variance-contributing cells\n            n_eff_cell = 1.0 / np.sum(cell_leverages**2)\n            # 6. Maximum cell-level normalized variance-leverage\n            max_cell_leverage = np.max(cell_leverages)\n            \n            # 4. Count of extreme cells\n            threshold_cell = 2.0 / H\n            count_extreme_cells = int(np.sum(cell_leverages > threshold_cell))\n            \n        result_tuple = [\n            n_eff_obs,\n            n_eff_cell,\n            count_extreme_obs,\n            count_extreme_cells,\n            max_obs_influence,\n            max_cell_leverage\n        ]\n        all_results.append(result_tuple)\n\n    # Final print statement in the exact required format.\n    # Format each list of results into \"[v1,v2,...]\" and join them.\n    formatted_results = []\n    for res_list in all_results:\n        # Using a general a number format that avoids scientific notation for\n        # some values and keeps precision, and converting ints to int strings.\n        s_list = []\n        for v in res_list:\n            if isinstance(v, int):\n                s_list.append(str(v))\n            else:\n                s_list.append(format(v, '.17g').rstrip('0').rstrip('.'))\n        \n        inner_str = \"[\" + \",\".join(s_list) + \"]\"\n        formatted_results.append(inner_str)\n    \n    final_output_string = \"[\" + \",\".join(formatted_results) + \"]\"\n    print(final_output_string.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3330477"}]}