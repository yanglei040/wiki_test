{"hands_on_practices": [{"introduction": "在理论基础之上，我们将转向一个关键的实际应用：诊断 MCMC 模拟的有效性。模拟的质量严重依赖于高质量的伪随机数，而随机数生成器 (RNG) 中即使是微小的缺陷也可能导致结果失效。本实践练习将指导你通过编程实现，探索谱分析工具如何成为强大的 MCMC 诊断利器，通过主动注入缺陷，你将学会识别其在谱域中的特征信号。[@problem_id:3346100]", "problem": "考虑一个由可逆马尔可夫链蒙特卡洛 (MCMC) 采样器生成的平稳标量时间序列，该采样器以标准正态分布为目标。设该时间序列表示为 $\\{Y_t\\}_{t=1}^n$，其中 $Y_t = g(X_t)$，而 $\\{X_t\\}$ 是一个马尔可夫链，其不变密度与 $\\exp(-x^2/2)$ 成正比。假设 $g(x) = x$，因此 $Y_t = X_t$。将 $\\{Y_t\\}$ 的谱密度 $S(\\omega)$ 定义为其自协方差函数 $\\gamma_k = \\mathrm{Cov}(Y_t,Y_{t+k})$ 的傅里叶变换，即 $S(\\omega) = \\sum_{k=-\\infty}^{\\infty} \\gamma_k e^{-i \\omega k}$，其中 $\\omega \\in [-\\pi,\\pi]$。零频谱密度 $S(0)$ 决定了样本均值 $\\bar{Y}_n$ 的渐近方差，即在适当的混合条件下，$\\mathrm{Var}(\\bar{Y}_n) \\approx S(0)/n$。\n\n您将通过向 MCMC 转移中注入网格伪影，并量化周期图 $I(\\omega)$ 在 $\\omega = 0$ 附近的偏差，来研究估计量 $\\hat{S}(0)$ 对随机数生成器 (RNG) 中缺陷的敏感性。具体而言：\n\n- 构建一个随机游走Metropolis采样器，其提议为 $Y = X + \\sigma Z$，其中 $Z$ 是标准正态分布。使用对称提议，使得Metropolis接受概率为 $\\alpha(X,Y) = \\min\\{1, \\exp(-(Y^2 - X^2)/2)\\}$。\n- 为了注入网格伪影，在应用接受规则之前，通过将 $Y$ 替换为 $Y_q = \\delta \\,\\mathrm{round}(Y/\\delta)$，将提议量化到间距为 $\\delta  0$ 的网格上。这种量化旨在模拟由有缺陷的RNG或确定性伪影引入的网格结构。\n- 考虑两种类型的RNG来驱动提议噪声：一个高质量的生成器和一个有缺陷的线性同余生成器，后者具有小模数且表现出短周期网格行为。请显式地实现这个有缺陷的生成器，并用它生成均匀分布变量，再通过您选择的方法将其转换为正态分布变量。\n\n您的任务是：\n\n1. 生成马尔可夫链，包括一个预烧期和随后的 $n$ 次迭代，并在减去其样本均值进行中心化后，提取时间序列 $\\{Y_t\\}_{t=1}^n$。\n2. 使用带有Bartlett核和有限带宽的滞后窗估计器来估计零频谱密度。该估计器必须从基本原理出发构建，即从中心化序列的自协方差估计和一个定义在有限滞后集上的显式锥削函数开始。不要假设任何快捷公式；使用自协方差和核加权的核心定义来构建估计器。\n3. 使用快速傅里叶变换 (FFT) 计算在离散傅里叶频率 $\\omega_j = 2\\pi j/n$（其中 $j=0,\\dots,\\lfloor n/2 \\rfloor$）处的周期图 $I(\\omega_j)$。通过构建比率 $R = \\bar{I}_{\\text{low}}/\\bar{I}_{\\text{mid}}$ 来量化零频附近的偏差，其中 $\\bar{I}_{\\text{low}}$ 是 $I(\\omega_j)$ 在 $J$ 个最小正频率上的平均值，而 $\\bar{I}_{\\text{mid}}$ 是在以 $j \\approx n/4$ 为中心的 $J$ 个频率上的平均值。\n4. 使用非重叠分批均值法，并设置随 $n$ 增长的批次大小，构建一个独立的 $S(0)$ 参考估计量。从分批均值及其方差的定义出发，推导并实现一个 $S(0)$ 的一致估计量。\n5. 设计一个决策规则，通过将 $S(0)$ 的Bartlett滞后窗估计与分批均值参考值以及近零周期图比率进行比较，来标记谱方差的欠离散。您的规则应生成一个布尔标志，当且仅当Bartlett估计值显著小于分批均值估计值，并且近零周期图比率表明低频功率受到抑制时，该标志为真。\n\n为保证可复现性和覆盖范围，请使用以下参数集 $(n,\\sigma,\\delta,\\text{rng},J)$ 的测试套件：\n\n- 测试 1 (理想路径): $(8192, 1.25, 0.0, \\text{good}, 16)$\n- 测试 2 (网格伪影，中等): $(8192, 1.25, 0.5, \\text{lcg}, 16)$\n- 测试 3 (网格伪影，强): $(8192, 1.25, 1.0, \\text{lcg}, 16)$\n- 测试 4 (边界情况，较短链): $(2048, 1.25, 0.0, \\text{good}, 8)$\n\n所有角度必须以弧度为单位；不涉及物理单位。对于每个测试用例，您的程序必须计算第5项中描述的布尔标志。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[true,false,true,false]”）。确切的输出必须是一个Python布尔值“True”或“False”的列表，其顺序与上述测试相对应。", "solution": "该问题要求研究谱方差估计器对马尔可夫链蒙特卡洛 (MCMC) 模拟中使用的随机数生成器 (RNG) 伪影的敏感性。这将通过实现一个Metropolis采样器、注入特定的伪影，并使用多种谱分析技术评估所得时间序列来完成。最终输出是一个基于这些分析来标记潜在问题的决策规则。\n\n### 1. MCMC 模拟框架\n\n构建一个随机游走Metropolis (RWM) 采样器以从目标分布生成时间序列 $\\{X_t\\}$，该分布的概率密度函数 $p(x) \\propto \\exp(-x^2/2)$，即标准正态分布 $\\mathcal{N}(0,1)$。可观察量为 $g(x)=x$，因此时间序列为 $Y_t = X_t$。\n\nRWM 算法流程如下：\n1.  给定当前状态 $X_t$，从提议分布 $q(Y|X_t)$ 生成一个提议 $Y$。我们使用正态随机游走：$Y = X_t + \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0,1)$，$\\sigma$ 是提议步长。\n2.  通过量化提议来引入一个可选的伪影：$Y_q = \\delta \\cdot \\mathrm{round}(Y/\\delta)$。如果 $\\delta = 0$，则不执行量化，且 $Y_q = Y$。\n3.  以概率 $\\alpha(X_t, Y_q) = \\min\\left(1, \\frac{p(Y_q)}{p(X_t)}\\right)$ 接受提议 $Y_q$。由于提议是对称的，Hastings比率为1。接受概率简化为 $\\alpha(X_t, Y_q) = \\min\\left(1, \\exp\\left(-\\frac{1}{2}(Y_q^2 - X_t^2)\\right)\\right)$。\n4.  如果提议被接受，则 $X_{t+1} = Y_q$。否则，链保持在当前状态，$X_{t+1} = X_t$。\n\n使用2000次迭代的预烧期，让链在收集 $n$ 个样本进行分析之前收敛到其平稳分布。链的初始状态为 $X_0 = 0$。\n\n### 2. 随机数生成器与伪影\n\n使用两种类型的RNG来为提议生成标准正态变量 $Z$。\n\n-   **高质量RNG**：`numpy.random.default_rng()` 生成器，它基于PCG64算法，作为高质量的“良好”RNG。\n-   **有缺陷的RNG**：实现一个具有小模数的线性同余生成器 (LCG) 来模拟有缺陷的RNG。LCG由递推关系 $S_{i+1} = (a S_i + c) \\pmod m$ 定义。我们选择已知会产生不良结果的参数：$a=1229$、$c=1$ 和 $m=2^{16}$。通过 $U_i = S_i / m$ 生成均匀变量 $U_i \\in [0, 1)$。然后使用Box-Muller变换将成对的这些均匀变量转换为标准正态变量：\n    $$Z_1 = \\sqrt{-2 \\ln U_1} \\cos(2\\pi U_2)$$\n    $$Z_2 = \\sqrt{-2 \\ln U_1} \\sin(2\\pi U_2)$$\n    短周期LCG和Box-Muller变换的这种组合已知会在产生的正态偏离量中产生结构性伪影。\n\n### 3. 谱分析与 $S(0)$ 的估计器\n\n主要目标是估计零频处的谱密度 $S(0) = \\sum_{k=-\\infty}^{\\infty} \\gamma_k$，其中 $\\gamma_k$ 是平稳过程在滞后 $k$ 时的自协方差。为了进行分析，首先通过减去样本均值 $\\bar{Y}_n = \\frac{1}{n}\\sum_{t=1}^n Y_t$ 来对原始时间序列 $\\{Y_t\\}_{t=1}^n$ 进行中心化。设中心化后的序列为 $\\{y_t\\}_{t=1}^n$，其中 $y_t = Y_t - \\bar{Y}_n$。\n\n#### 3.1. Bartlett滞后窗估计器\n\n该估计器基于样本自协方差的加权和。\n滞后 $k \\ge 0$ 处的样本自协方差估计为：\n$$ \\hat{\\gamma}_k = \\frac{1}{n} \\sum_{t=1}^{n-k} y_t y_{t+k} $$\n$S(0)$的Bartlett滞后窗估计器由下式给出：\n$$ \\hat{S}_B(0) = \\sum_{k=-(M-1)}^{M-1} \\lambda_B(k/M) \\hat{\\gamma}_k $$\n其中 $M$ 是截断滞后（带宽参数），$\\lambda_B(u) = 1 - |u|$（对于 $|u| \\le 1$，$0$ 其他情况）是Bartlett核。由于对称性 $\\hat{\\gamma}_k = \\hat{\\gamma}_{-k}$，估计器简化为：\n$$ \\hat{S}_B(0) = \\hat{\\gamma}_0 + 2 \\sum_{k=1}^{M-1} \\left(1 - \\frac{k}{M}\\right) \\hat{\\gamma}_k $$\n为保证一致性，截断滞后 $M$ 必须随 $n$ 增长，使得 $M \\to \\infty$ 且 $M/n \\to 0$。一个标准的选择是 $M = \\lfloor n^{1/3} \\rfloor$。\n\n#### 3.2. 非重叠分批均值 (NOBM) 估计器\n\n在弱混合条件下，NOBM方法为 $S(0)$ 提供了另一种一致的估计器。它作为一个更稳健的参考估计器。\n1.  将时间序列 $\\{Y_t\\}_{t=1}^n$ 分为 $a_n$ 个非重叠的批次，每批大小为 $m_n$。为简单起见，我们假设 $n = a_n m_n$。\n2.  计算每个批次的均值：\n    $$ B_j = \\frac{1}{m_n} \\sum_{i=1}^{m_n} Y_{(j-1)m_n + i} \\quad \\text{for} \\quad j = 1, \\dots, a_n $$\n3.  在平稳性和混合性下，对于大的 $m_n$，批次均值 $B_j$ 近似为独立的、同分布的正态随机变量，且 $\\mathrm{Var}(B_j) \\approx S(0)/m_n$。\n4.  总样本均值 $\\bar{Y}_n$ 的方差与批次均值的方差相关：$\\mathrm{Var}(\\bar{Y}_n) \\approx \\frac{1}{a_n} \\mathrm{Var}(B_j)$。\n5.  通过批次均值的样本方差来估计 $\\mathrm{Var}(B_j)$，我们得到一个 $S(0)$ 的估计器：\n    $$ \\hat{S}_{NOBM}(0) = m_n \\cdot \\frac{1}{a_n-1} \\sum_{j=1}^{a_n} (B_j - \\bar{Y}_n)^2 $$\n    其中 $\\bar{Y}_n$ 是总样本均值。\n为保证一致性，批次大小 $m_n$ 必须随 $n$ 增长。一个标准的选择是 $m_n = \\lfloor n^{1/2} \\rfloor$，这意味着 $a_n = \\lfloor n/m_n \\rfloor \\approx \\lfloor n^{1/2} \\rfloor$。\n\n#### 3.3. 周期图分析\n\n周期图是在离散傅里叶频率 $\\omega_j = 2\\pi j/n$ 处谱密度的估计器。它是根据中心化序列 $\\{y_t\\}$ 计算的：\n$$ I(\\omega_j) = \\frac{1}{n} \\left| \\sum_{t=1}^n y_t e^{-i \\omega_j t} \\right|^2 $$\n这可以通过快速傅里叶变换 (FFT) 高效计算。\n为了量化零频附近功率的抑制情况，我们计算比率 $R$：\n$$ R = \\frac{\\bar{I}_{\\text{low}}}{\\bar{I}_{\\text{mid}}} $$\n其中：\n-   $\\bar{I}_{\\text{low}} = \\frac{1}{J} \\sum_{j=1}^{J} I(\\omega_j)$ 是周期图在 $J$ 个最低正频率上的平均值。\n-   $\\bar{I}_{\\text{mid}} = \\frac{1}{J} \\sum_{k} I(\\omega_k)$ 是周期图在以索引 $j_{\\text{mid}} = \\lfloor n/4 \\rfloor$ 为中心的 $J$ 个频率上的平均值。\n\n对于具有正自相关的过程，我们预期 $S(0) > S(\\omega)$（对于 $\\omega > 0$），这通常会得出 $R > 1$。$R  1$ 的值表示相对于中频范围，低频功率异常地被压低，这是伪影的一个潜在迹象。\n\n### 4. 伪影检测的决策规则\n\n制定一个决策规则来标记可能存在缺陷的时间序列。该规则旨在检测谱方差中的欠离散，这是网格伪影的一个典型症状。当且仅当同时满足以下两个条件时，触发警报（标志为`True`）：\n\n1.  **估计器之间的差异**：Bartlett估计器显著小于更稳健的NOBM估计器。Bartlett估计器基于短程滞后相关性，对由量化改变的局部链行为敏感，而NOBM估计器则捕捉更长期的方差。我们将其形式化为：\n    $$ \\hat{S}_B(0)  0.5 \\cdot \\hat{S}_{NOBM}(0) $$\n2.  **受抑制的低频功率**：周期图比率 $R$ 表明在零频附近存在功率亏损。这通过以下条件量化：\n    $$ R  0.7 $$\n\n这个双管齐下的规则结合了来自时域（通过自协方差和分批）和频域（通过周期图）的证据，以做出稳健的决策。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting MCMC artifacts via spectral analysis.\n    \"\"\"\n\n    # Constants for the flawed Linear Congruential Generator (LCG)\n    LCG_A = 1229\n    LCG_C = 1\n    LCG_M = 2**16\n\n    # MCMC simulation parameters\n    N_BURN = 2000\n    X0 = 0.0\n\n    # Decision rule thresholds\n    BARTLETT_RATIO_THRESHOLD = 0.5\n    PERIODOGRAM_RATIO_THRESHOLD = 0.7\n\n    def lcg_generator(seed):\n        \"\"\"A generator for the flawed LCG yielding uniform variates.\"\"\"\n        state = seed\n        while True:\n            state = (LCG_A * state + LCG_C) % LCG_M\n            yield state / LCG_M\n\n    def box_muller_generator(uniform_gen):\n        \"\"\"A generator for normal variates using the Box-Muller transform.\"\"\"\n        while True:\n            u1 = next(uniform_gen)\n            u2 = next(uniform_gen)\n            if u1 == 0.0: continue\n            R = np.sqrt(-2 * np.log(u1))\n            theta = 2 * np.pi * u2\n            yield R * np.cos(theta)\n            yield R * np.sin(theta)\n\n    def generate_mcmc_series(n, sigma, delta, rng_type, seed):\n        \"\"\"\n        Generates a time series using a Random-Walk Metropolis sampler.\n        \"\"\"\n        if rng_type == 'good':\n            rng = np.random.default_rng(seed)\n            proposal_noise_gen = rng.standard_normal\n        elif rng_type == 'lcg':\n            uniform_gen = lcg_generator(seed=1) # Fixed seed for LCG\n            normal_gen = box_muller_generator(uniform_gen)\n            proposal_noise_gen = lambda: next(normal_gen)\n        else:\n            raise ValueError(\"Unknown RNG type\")\n\n        # Use a separate RNG for acceptance probability to avoid interaction\n        accept_rng = np.random.default_rng(seed + 1)\n\n        x = X0\n        # Burn-in phase\n        for _ in range(N_BURN):\n            z = proposal_noise_gen()\n            y = x + sigma * z\n            if delta > 0:\n                y = delta * np.round(y / delta)\n            \n            alpha = min(1.0, np.exp(-0.5 * (y**2 - x**2)))\n            if accept_rng.uniform()  alpha:\n                x = y\n        \n        # Sampling phase\n        series = np.zeros(n)\n        for i in range(n):\n            z = proposal_noise_gen()\n            y = x + sigma * z\n            if delta > 0:\n                y = delta * np.round(y / delta)\n\n            alpha = min(1.0, np.exp(-0.5 * (y**2 - x**2)))\n            if accept_rng.uniform()  alpha:\n                x = y\n            series[i] = x\n            \n        return series\n\n    def bartlett_estimator(series_centered, M):\n        \"\"\"Computes the Bartlett lag-window estimator for S(0).\"\"\"\n        n = len(series_centered)\n        if M >= n: M = n - 1\n\n        gamma_0 = np.var(series_centered) # equivalent to sum(y_t^2)/n\n        s0 = gamma_0\n        for k in range(1, M):\n            # Biased autocovariance estimator\n            gamma_k = np.dot(series_centered[:n-k], series_centered[k:]) / n\n            s0 += 2 * (1 - k / M) * gamma_k\n        return s0\n\n    def nobm_estimator(series, m_n):\n        \"\"\"Computes the Non-Overlapping Batch Means estimator for S(0).\"\"\"\n        n = len(series)\n        a_n = n // m_n\n        if a_n  2: return np.nan\n\n        # Reshape into a_n batches of size m_n and compute batch means\n        batches = series[:a_n * m_n].reshape((a_n, m_n))\n        batch_means = np.mean(batches, axis=1)\n\n        # Variance of batch means\n        var_batch_means = np.var(batch_means, ddof=1)\n        \n        # S(0) estimate\n        s0 = m_n * var_batch_means\n        return s0\n    \n    def periodogram_ratio(series_centered, J):\n        \"\"\"Computes the ratio of low-frequency to mid-frequency periodogram averages.\"\"\"\n        n = len(series_centered)\n        \n        # Compute periodogram using FFT\n        fft_vals = fft(series_centered)\n        periodogram = (np.abs(fft_vals)**2) / n\n\n        # Indices for low frequencies (positive frequencies only, j=1 to J)\n        i_low = periodogram[1:J+1]\n        \n        # Indices for mid frequencies\n        j_mid = n // 4\n        j_start = j_mid - (J - 1) // 2\n        j_end = j_mid + J // 2\n        i_mid = periodogram[j_start:j_end+1]\n\n        if len(i_low) == 0 or len(i_mid) == 0 or np.mean(i_mid) == 0:\n            return np.nan\n            \n        return np.mean(i_low) / np.mean(i_mid)\n\n    # Test cases from the problem statement\n    test_cases = [\n        (8192, 1.25, 0.0, 'good', 16),\n        (8192, 1.25, 0.5, 'lcg', 16),\n        (8192, 1.25, 1.0, 'lcg', 16),\n        (2048, 1.25, 0.0, 'good', 8),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        n, sigma, delta, rng_type, J = case\n        \n        # Seed for reproducibility of each test case\n        case_seed = 42 + i\n\n        series = generate_mcmc_series(n, sigma, delta, rng_type, seed=case_seed)\n        \n        # Center the series for estimators that require it\n        centered_series = series - np.mean(series)\n        \n        # Determine parameters for estimators\n        M_bartlett = int(n**(1/3))\n        m_nobm = int(n**(1/2))\n        \n        # Compute estimators\n        s0_bartlett = bartlett_estimator(centered_series, M_bartlett)\n        # NOBM uses the original series to correctly compute batch means vs grand mean\n        s0_nobm = nobm_estimator(series, m_nobm)\n        p_ratio = periodogram_ratio(centered_series, J)\n\n        # Apply decision rule\n        if np.isnan(s0_bartlett) or np.isnan(s0_nobm) or np.isnan(p_ratio):\n            flag = False # Could not compute, assume no artifact\n        else:\n            cond1 = s0_bartlett  BARTLETT_RATIO_THRESHOLD * s0_nobm\n            cond2 = p_ratio  PERIODOGRAM_RATIO_THRESHOLD        \n            flag = cond1 and cond2\n        \n        results.append(flag)\n\n    # Format the final output exactly as specified\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3346100"}, {"introduction": "最后一个练习将探讨现代计算统计学中一个更高级也更微妙的问题：如何确保并行运行的 MCMC 链是真正独立的。在实践中，共享的计算资源或有缺陷的并行随机数生成方案可能会在链之间引入虚假的耦合。在这个练习中，你将设计并实现一个复杂的诊断程序，通过结合分块估计和非参数置换检验，来检测这些可能污染最终统计推断的隐藏相关性。[@problem_id:3346140]", "problem": "给定一个包含 $m$ 个离散时间随机过程（链）$\\{X_t^{(i)}\\}_{t=1}^n$（其中 $i \\in \\{1,\\dots,m\\}$）的集合，每个过程旨在表示蒙特卡洛范式下一个平稳、遍历的马尔可夫链的独立实现。对于每个链，您关心的是零频率处的谱密度，记为 $S^{(i)}(0)$，它决定了样本均值的渐近方差。您的任务是设计并实现一个诊断工具，该工具通过比较各个链之间的估计值 $\\hat{S}^{(i)}(0)$，来检测由共享随机性或资源争用引起的隐藏耦合，这种耦合可能会在链之间产生同步的低频变异性。您必须通过比较注入同步和未注入同步的场景来验证该诊断工具。\n\n使用的基本基础和定义：\n\n- 一个离散时间、均值为零的二阶平稳过程 $\\{Y_t\\}$ 具有自协方差序列 $\\{\\gamma_k\\}_{k \\in \\mathbb{Z}}$，定义为 $\\gamma_k = \\mathrm{Cov}(Y_t, Y_{t+k})$，其谱密度 $S(\\omega)$ 定义为 $\\gamma_k$ 的傅里叶变换，即\n$$\nS(\\omega) = \\sum_{k=-\\infty}^{\\infty} \\gamma_k e^{-i \\omega k}, \\quad \\omega \\in [-\\pi,\\pi].\n$$\n- 零频率处的值满足\n$$\nS(0) = \\sum_{k=-\\infty}^{\\infty} \\gamma_k = \\gamma_0 + 2 \\sum_{k=1}^{\\infty} \\gamma_k.\n$$\n- 对于一个具有有限二阶矩的平稳、遍历过程，在标准混合条件下，当 $n \\to \\infty$ 时，样本均值 $\\bar{Y}_n = \\frac{1}{n} \\sum_{t=1}^n Y_t$ 的方差满足\n$$\n\\mathrm{Var}(\\bar{Y}_n) \\approx \\frac{1}{n} \\sum_{k=-\\infty}^{\\infty} \\gamma_k = \\frac{1}{n} S(0),\n$$\n这便将 $S(0)$ 与长期方差联系起来。\n\n需要实现的光谱方差估计：\n\n- 给定来自一个链的观测数据 $y_1,\\dots,y_n$，定义中心化序列 $z_t = y_t - \\bar{y}_n$，其中 $\\bar{y}_n = \\frac{1}{n} \\sum_{t=1}^n y_t$。\n- 滞后 $k \\in \\{0,1,\\dots,n-1\\}$ 处的样本自协方差为\n$$\n\\hat{\\gamma}_k = \\frac{1}{n} \\sum_{t=1}^{n-k} z_t z_{t+k}.\n$$\n- 一个使用对称窗 $w_k$ 和带宽 $b$ 的滞后窗估计量对零频率谱密度的估计如下\n$$\n\\hat{S}(0) = \\hat{\\gamma}_0 + 2 \\sum_{k=1}^b w_k \\hat{\\gamma}_k,\n$$\n其中 Bartlett 窗为 $w_k = 1 - \\frac{k}{b+1}$（对于 $k \\in \\{0,1,\\dots,b\\}$）和 $w_k = 0$（对于 $k  b$）。\n\n诊断设计约束：\n\n- 在链间独立的假设下，不同链的 $S(0)$ 的分块估计值不应随时间出现超出估计噪声的系统性同步。隐藏耦合（例如，由于共享随机性或同步减速）会引发共同的低频变异性，导致分块估计值 $\\hat{S}(0)$ 在链间协同变动。\n- 将每个链分割成 $B$ 个长度相等的非重叠连续块，每块长度为 $L = \\left\\lfloor \\frac{n}{B} \\right\\rfloor$。对于每个链 $i$ 和每个块 $b \\in \\{1,\\dots,B\\}$，使用该块的数据和带宽 $b^\\star = \\min\\{b, L-1\\}$ 的滞后窗估计量计算一个块级估计值 $\\hat{S}_b^{(i)}(0)$。\n- 构建一个 $B \\times m$ 矩阵，其 $(b,i)$ 项为 $\\hat{S}_b^{(i)}(0)$，并使用分块列的 $m \\times m$ 样本相关矩阵计算链间的平均非对角皮尔逊相关系数。将观测到的统计量记为\n$$\n\\bar{r}_{\\mathrm{obs}} = \\frac{2}{m(m-1)} \\sum_{1 \\le i  j \\le m} r_{ij},\n$$\n其中 $r_{ij}$ 是序列 $\\{\\hat{S}_b^{(i)}(0)\\}_{b=1}^B$ 和 $\\{\\hat{S}_b^{(j)}(0)\\}_{b=1}^B$ 之间的样本相关系数。\n- 为了在保留 $\\{\\hat{S}_b^{(i)}(0)\\}$ 的逐链边际分布的同时获得一个数据驱动的检测阈值，执行一个分块置换检验。该检验会打破同步性，但保持每个链内块的分布不变：在每个链内独立地置换 $B$ 个块，为第 $\\ell$ 个置换复制重新计算平均非对角相关系数 $\\bar{r}^{(\\ell)}$，并用 $R$ 次随机置换估计 $p$ 值\n$$\np = \\frac{1 + \\sum_{\\ell=1}^R \\mathbf{1}\\{\\bar{r}^{(\\ell)} \\ge \\bar{r}_{\\mathrm{obs}}\\}}{1 + R},\n$$\n对于选定的显著性水平 $\\alpha$，如果 $p  \\alpha$，则宣告检测到隐藏耦合。\n\n需要实现的数据生成机制：\n\n- 对每个链 $i \\in \\{1,\\dots,m\\}$，使用一个可能带有共享分量的一阶自回归模型来模拟一个过程：\n$$\nX_t^{(i)} = \\phi X_{t-1}^{(i)} + \\varepsilon_t^{(i)} + a \\, S_t,\\quad \\varepsilon_t^{(i)} \\sim \\mathcal{N}(0,\\sigma^2)\\ \\text{i.i.d. across } t \\text{ and } i,\n$$\n其中共享分量 $S_t$ 的演化方式为\n$$\nS_t = \\rho S_{t-1} + \\eta_t,\\quad \\eta_t \\sim \\mathcal{N}(0,\\sigma_c^2)\\ \\text{i.i.d.},\n$$\n初始条件为 $S_0 = 0$ 和 $X_0^{(i)} = 0$。参数 $a$ 控制链间隐藏耦合的强度：$a = 0$ 对应于独立情况，而 $a  0$ 则向所有链中注入共同的低频变异性。\n- 使用 $g(x) = x$ 作为感兴趣的函数；即，直接在 $\\{X_t^{(i)}\\}$ 上估计 $S(0)$。\n\n测试套件：\n\n在以下四个测试用例上实现并评估该诊断工具，每个用例指定为一个元组 $(m, n, \\phi, \\sigma, \\rho, \\sigma_c, a, b, B, R, \\alpha)$：\n\n1. 案例 A（独立性基线）：$(6, 12000, 0.6, 1.0, 0.98, 1.0, 0.0, 150, 12, 199, 0.01)$。\n2. 案例 B（微弱耦合）：$(6, 12000, 0.6, 1.0, 0.98, 1.0, 0.3, 150, 12, 199, 0.01)$。\n3. 案例 C（较强耦合）：$(6, 12000, 0.6, 1.0, 0.98, 1.0, 0.55, 150, 12, 199, 0.01)$。\n4. 案例 D（高持续性下的边界稳健性，无耦合）：$(6, 12000, 0.95, 1.0, 0.98, 1.0, 0.0, 300, 12, 199, 0.01)$。\n\n要求的输出：\n\n- 对于每个案例，如果诊断工具检测到隐藏耦合（即 $p  \\alpha$），则输出布尔值 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[$\\mathrm{False}$,$\\mathrm{True}$,$\\mathrm{True}$,$\\mathrm{False}$]”）。不涉及物理单位或角度；所有输出都是无单位的布尔值。\n\n实现要求：\n\n- 在每个块内使用带宽为 $b^\\star = \\min\\{b, L-1\\}$ 的 Bartlett 滞后窗估计量来估计 $S(0)$。\n- 对每个案例使用上文描述的置换检验，并进行恰好 $R$ 次置换。\n- 使用固定的随机种子以确保不同运行之间的可复现性。\n\n您的最终程序必须是一个完整的、可运行的脚本，该脚本实现所述的模拟、估计、诊断和测试套件，并按指定的确切格式在单行上打印包含四个布尔值的列表。不应打印任何额外的文本或格式。", "solution": "该问题要求设计并实现一个统计诊断工具，用以检测一组（$m$ 个）并行蒙特卡洛模拟链中的隐藏耦合。该诊断工具基于以下原理：如果链确实是独立的，那么它们在连续时间块上计算的长期方差估计值不应表现出系统性相关。反之，共享的随机性或资源争用会引发共同的低频变异性，导致这些估计值协同变动。我们将首先形式化数据生成过程，然后是谱方差的估计，接着是基于相关的诊断工具的设计及其通过置换检验进行的验证。\n\n**1. 数据生成过程**\n\n我们测试的基础是一个包含 $m$ 个随机过程（或称链）的模拟数据集。每个链被建模为一个一阶自回归过程 AR($1$)，并带有一个引入跨链耦合的加性共享分量。\n\n首先，生成一个共同冲击过程 $\\{S_t\\}_{t=1}^n$。这个过程本身是一个 AR($1$) 模型，旨在表示一个可能同时影响所有链的低频变异性来源。其定义如下：\n$$\nS_t = \\rho S_{t-1} + \\eta_t, \\quad \\text{for } t=1, \\dots, n\n$$\n初始条件为 $S_0 = 0$。新息 $\\eta_t$ 是独立同分布（i.i.d.）的高斯随机变量，均值为0，方差为 $\\sigma_c^2$，即 $\\eta_t \\sim \\mathcal{N}(0, \\sigma_c^2)$。参数 $\\rho \\in [0, 1)$ 控制共享冲击的持续性；接近 1 的 $\\rho$ 值会产生强烈的低频波动。\n\n接下来，对于每个链 $i \\in \\{1, \\dots, m\\}$，过程 $\\{X_t^{(i)}\\}_{t=1}^n$ 的生成方式如下：\n$$\nX_t^{(i)} = \\phi X_{t-1}^{(i)} + \\varepsilon_t^{(i)} + a \\, S_t, \\quad \\text{for } t=1, \\dots, n\n$$\n初始条件为 $X_0^{(i)} = 0$。新息 $\\varepsilon_t^{(i)}$ 是独立同分布的高斯随机变量，$\\varepsilon_t^{(i)} \\sim \\mathcal{N}(0, \\sigma^2)$，并且在时间 $t$ 和链 $i$ 上都是独立的。参数 $a \\ge 0$ 控制耦合的强度：\n- 如果 $a=0$，项 $a S_t$ 消失，链 $\\{X_t^{(i)}\\}$ 成为相互独立的 AR($1$) 过程。这对应于无耦合的原假设。\n- 如果 $a  0$，共享分量 $S_t$ 被注入到所有链中，从而在它们之间引发正相关。这对应于存在隐藏耦合的备择假设。\n\n**2. 分块谱方差估计**\n\n诊断量是零频率处的谱密度 $S(0)$，它与平稳过程样本均值的渐近方差成正比。我们不是一次性从整个链中估计 $S(0)$，而是为了捕捉时变的同步性，我们将每个长度为 $n$ 的链分成 $B$ 个长度为 $L = \\lfloor n/B \\rfloor$ 的不重叠块。\n\n对于每个链 $i$ 和每个块 $b \\in \\{1, \\dots, B\\}$，我们计算谱方差的块级估计值，记为 $\\hat{S}_b^{(i)}(0)$。设链 $i$ 的块 $b$ 的数据为 $\\{y_t\\}_{t=1}^L$。估计过程如下：\n\n- **中心化：** 通过减去块均值来中心化数据：$z_t = y_t - \\bar{y}_L$，其中 $\\bar{y}_L = \\frac{1}{L} \\sum_{t=1}^L y_t$。\n- **带宽选择：** 滞后窗估计量的带宽设置为 $b^\\star = \\min(b_{\\text{param}}, L-1)$，其中 $b_{\\text{param}}$ 是测试用例中提供的基本带宽参数。这确保了滞后数不超过块中的可用数据。\n- **样本自协方差：** 计算滞后 $k = 0, 1, \\dots, b^\\star$ 的样本自协方差 $\\hat{\\gamma}_k$：\n$$\n\\hat{\\gamma}_k = \\frac{1}{L} \\sum_{t=1}^{L-k} z_t z_{t+k}\n$$\n- **滞后窗估计量：** 使用 Bartlett 滞后窗估计量来估计长期方差 $S(0)$：\n$$\n\\hat{S}_b^{(i)}(0) = \\hat{\\gamma}_0 + 2 \\sum_{k=1}^{b^\\star} w_k \\hat{\\gamma}_k\n$$\n其中 Bartlett 窗权重由 $w_k = 1 - \\frac{k}{b^\\star+1}$ 给出（对于 $k \\in \\{1, \\dots, b^\\star\\}$）。\n\n此过程产生一个 $B \\times m$ 的估计矩阵，其中条目 $(b,i)$ 是 $\\hat{S}_b^{(i)}(0)$。序列 $\\{\\hat{S}_b^{(i)}(0)\\}_{b=1}^B$ 是一个时间序列，表示链 $i$ 的估计谱方差的演变。\n\n**3. 诊断检验统计量和置换检验**\n\n该诊断的核心思想是，如果链是耦合的（$a0$），它们的块级谱方差估计值的时间序列 $\\{\\hat{S}_b^{(i)}(0)\\}_{b=1}^B$ 将会趋于同步变动。我们使用平均非对角皮尔逊相关系数来量化这种协同变动。\n\n- **观测检验统计量：** 设 $M$ 是块级估计值 $\\hat{S}_b^{(i)}(0)$ 的 $B \\times m$ 矩阵。我们计算 $M$ 的列的 $m \\times m$ 样本相关矩阵。设 $r_{ij}$ 为第 $i$ 列和第 $j$ 列之间的相关系数。观测检验统计量 $\\bar{r}_{\\mathrm{obs}}$ 是该相关矩阵上（或下）三角元素的平均值：\n$$\n\\bar{r}_{\\mathrm{obs}} = \\frac{2}{m(m-1)} \\sum_{1 \\le i  j \\le m} r_{ij}\n$$\n 一个大的正值 $\\bar{r}_{\\mathrm{obs}}$ 表明存在同步性。\n\n- **用于显著性检验的置换检验：** 为了确定 $\\bar{r}_{\\mathrm{obs}}$ 是否具有统计显著性，我们将其与通过置换检验生成的零分布进行比较。这种非参数方法至关重要，因为 $\\bar{r}_{\\mathrm{obs}}$ 的理论分布很复杂。置换检验保留了每个链内谱方差估计的边际分布，但打破了链间的任何时间同步性。过程如下：\n    1. 对于大量的复制次数 $R$：\n    2. 对于每次复制 $\\ell \\in \\{1, \\dots, R\\}$，通过在原始矩阵 $M$ 的 $m$ 列中分别独立地置换 $B$ 个块估计值，创建一个新矩阵 $M^{(\\ell)}$。\n    3. 从这个置换后的矩阵 $M^{(\\ell)}$ 计算检验统计量 $\\bar{r}^{(\\ell)}$。\n    4. 集合 $\\{\\bar{r}^{(\\ell)}\\}_{\\ell=1}^R$ 构成了在无同步性原假设下检验统计量的经验分布。\n    5. $p$ 值估计为大于或等于观测统计量的置换统计量的比例，并进行调整以避免 $p$ 值为 0：\n$$\np = \\frac{1 + \\sum_{\\ell=1}^R \\mathbf{1}\\{\\bar{r}^{(\\ell)} \\ge \\bar{r}_{\\mathrm{obs}}\\}}{1 + R}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n- **决策：** 给定一个显著性水平 $\\alpha$，如果计算出的 $p$ 值小于 $\\alpha$，我们就拒绝独立性的原假设，并宣告检测到隐藏耦合。\n\n将此完整过程应用于问题中指定的四个测试用例中的每一个，为每个案例得出一个布尔结果（检测到则为 True，否则为 False）。固定的随机种子确保了模拟和置换检验是可复现的。", "answer": "```python\nimport numpy as np\n\ndef generate_data(m, n, phi, sigma, rho, sigma_c, a):\n    \"\"\"\n    Generates m chains of data according to the specified AR(1) model with a shared component.\n    \"\"\"\n    # Generate the shared component S_t\n    S = np.zeros(n + 1)\n    eta = np.random.normal(0, sigma_c, size=n)\n    for t in range(1, n + 1):\n        S[t] = rho * S[t - 1] + eta[t - 1]\n\n    # Generate the m chains X_t^(i)\n    X = np.zeros((m, n + 1))\n    epsilon = np.random.normal(0, sigma, size=(m, n))\n    for i in range(m):\n        for t in range(1, n + 1):\n            X[i, t] = phi * X[i, t - 1] + epsilon[i, t - 1] + a * S[t]\n\n    return X[:, 1:]  # Return m x n array, discarding initial zeros\n\ndef estimate_spectral_variance(series, bandwidth):\n    \"\"\"\n    Computes the Bartlett lag-window estimator for spectral variance at frequency zero.\n    \"\"\"\n    L = len(series)\n    if L  2:\n        return 0.0\n    \n    # Effective bandwidth cannot exceed L-1 lags\n    b_star = min(bandwidth, L - 1)\n    \n    # Center the series\n    z = series - np.mean(series)\n\n    # Compute sample autocovariances\n    # gamma_0\n    gamma_0 = np.sum(z * z) / L\n    \n    # gamma_k for k > 0\n    sum_term = 0.0\n    if b_star > 0:\n        for k in range(1, b_star + 1):\n            gamma_k = np.sum(z[:-k] * z[k:]) / L\n            w_k = 1.0 - k / (b_star + 1.0)\n            sum_term += w_k * gamma_k\n\n    return gamma_0 + 2.0 * sum_term\n\ndef avg_off_diag_corr(matrix):\n    \"\"\"\n    Computes the average off-diagonal Pearson correlation of a matrix's columns.\n    \"\"\"\n    m = matrix.shape[1]\n    if m  2:\n        return 0.0\n    \n    # rowvar=False treats columns as variables\n    corr_matrix = np.corrcoef(matrix, rowvar=False)\n    \n    # For a single variable or constant series, corrcoef can return nan or a scalar\n    if corr_matrix.ndim  2:\n        return 0.0\n\n    # Sum of off-diagonal elements\n    np.fill_diagonal(corr_matrix, 0)\n    sum_off_diag = np.sum(corr_matrix)\n    \n    return sum_off_diag / (m * (m - 1))\n\ndef run_diagnostic(params):\n    \"\"\"\n    Runs the full diagnostic test for a given set of parameters.\n    \"\"\"\n    m, n, phi, sigma, rho, sigma_c, a, b_param, B, R, alpha = params\n\n    # 1. Generate Data\n    chains = generate_data(m, n, phi, sigma, rho, sigma_c, a)\n\n    # 2. Blockwise Spectral Variance Estimation\n    L = n // B\n    if L == 0:\n      raise ValueError(\"Block length L must be positive.\")\n      \n    S_hat_matrix = np.zeros((B, m))\n\n    for i in range(m):\n        for j in range(B):\n            block_data = chains[i, j * L : (j + 1) * L]\n            S_hat_matrix[j, i] = estimate_spectral_variance(block_data, b_param)\n\n    # 3. Compute Observed Test Statistic\n    r_obs = avg_off_diag_corr(S_hat_matrix)\n\n    # 4. Perform Permutation Test\n    perm_r_values = np.zeros(R)\n    perm_S_hat_matrix = np.copy(S_hat_matrix)\n    \n    # Use a generator for permutations for efficiency and cleaner state management\n    rng = np.random.default_rng()\n\n    for l in range(R):\n        for i in range(m):\n            rng.shuffle(perm_S_hat_matrix[:, i])\n        perm_r_values[l] = avg_off_diag_corr(perm_S_hat_matrix)\n\n    # 5. Calculate p-value and make a decision\n    p_value = (1.0 + np.sum(perm_r_values >= r_obs)) / (1.0 + R)\n    detection = p_value  alpha\n    \n    return detection\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Set a fixed random seed for reproducibility\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (m, n, phi, sigma, rho, sigma_c, a, b, B, R, alpha)\n        (6, 12000, 0.6, 1.0, 0.98, 1.0, 0.0, 150, 12, 199, 0.01),   # Case A\n        (6, 12000, 0.6, 1.0, 0.98, 1.0, 0.3, 150, 12, 199, 0.01),   # Case B\n        (6, 12000, 0.6, 1.0, 0.98, 1.0, 0.55, 150, 12, 199, 0.01), # Case C\n        (6, 12000, 0.95, 1.0, 0.98, 1.0, 0.0, 300, 12, 199, 0.01)   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_diagnostic(case)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    # The boolean values are converted to lowercase strings for Python's `str()`\n    # and then capitalized to match the example format `[False,True,...]`\n    print(f\"[{','.join(map(lambda b: str(b).capitalize(), results))}]\")\n\nsolve()\n```", "id": "3346140"}]}