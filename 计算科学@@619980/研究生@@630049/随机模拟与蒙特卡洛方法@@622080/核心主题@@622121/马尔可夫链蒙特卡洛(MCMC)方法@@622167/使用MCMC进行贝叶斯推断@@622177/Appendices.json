{"hands_on_practices": [{"introduction": "掌握MCMC的第一步是学习如何处理和解释其输出。MCMC模拟器生成的大量样本构成了对后验分布的经验近似，我们可以利用这些样本来计算各种后验统计量，例如均值、中位数或可信区间。这个练习 [@problem_id:1319931] 提供了一个具体的例子，演示了如何从Metropolis-Hastings算法的输出样本中计算后验均值，这是从MCMC结果中提取有意义结论的一项基本技能。", "problem": "一位质量控制工程师正在评估一种新型半导体芯片的制造过程。该过程的质量由单个芯片是无缺陷的概率 $p$ 来表征。工程师对 $p$ 的先验信念是，它在离散集合 $S = \\{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9\\}$ 中取任何一个值的可能性都是相等的。\n\n为了更新这一信念，工程师测试了随机一批 $n=20$ 个芯片，并发现其中 $k=15$ 个是无缺陷的。无缺陷芯片的数量假定服从二项分布。\n\n为了分析给定数据下 $p$ 的后验分布，我们使用Metropolis-Hastings算法进行了一次马尔可夫链蒙特卡罗（MCMC）模拟。从后验分布中总共生成了5000个样本。在将前1000个样本作为“预烧”期丢弃后，对剩余的4000个样本进行了计数。集合 $S$ 中每个可能的 $p$ 值的计数如下：\n- $p=0.1$: 0 个样本\n- $p=0.2$: 0 个样本\n- $p=0.3$: 0 个样本\n- $p=0.4$: 0 个样本\n- $p=0.5$: 19 个样本\n- $p=0.6$: 301 个样本\n- $p=0.7$: 1690 个样本\n- $p=0.8$: 1845 个样本\n- $p=0.9$: 145 个样本\n\n使用这次模拟的结果，计算概率 $p$ 的估计后验均值。将你的答案四舍五入到三位有效数字。", "solution": "我们要求的是根据预烧期后的MCMC输出所估计的 $p$ 的后验均值。设 $N$ 为保留样本的总数，$N_{j}$ 为在 $p_{j} \\in S$ 处的样本计数。后验均值的蒙特卡罗估计量为\n$$\n\\hat{\\mu}=\\frac{1}{N}\\sum_{j} p_{j} N_{j}=\\sum_{j} p_{j}\\left(\\frac{N_{j}}{N}\\right).\n$$\n根据计数结果，$N=4000$，并且只有以下的 $N_{j}$ 非零：\n$$\nN_{0.5}=19,\\quad N_{0.6}=301,\\quad N_{0.7}=1690,\\quad N_{0.8}=1845,\\quad N_{0.9}=145.\n$$\n因此，\n$$\n\\hat{\\mu}=\\frac{0.5 \\cdot 19+0.6 \\cdot 301+0.7 \\cdot 1690+0.8 \\cdot 1845+0.9 \\cdot 145}{4000}.\n$$\n分步计算分子：\n$$\n0.5 \\cdot 19=9.5,\\quad 0.6 \\cdot 301=180.6,\\quad 0.7 \\cdot 1690=1183,\\quad 0.8 \\cdot 1845=1476,\\quad 0.9 \\cdot 145=130.5,\n$$\n$$\n9.5+180.6=190.1,\\quad 190.1+1183=1373.1,\\quad 1373.1+1476=2849.1,\\quad 2849.1+130.5=2979.6.\n$$\n因此，\n$$\n\\hat{\\mu}=\\frac{2979.6}{4000}=0.7449.\n$$\n四舍五入到三位有效数字，得到\n$$\n0.7449 \\approx 0.745.\n$$", "answer": "$$\\boxed{0.745}$$", "id": "1319931"}, {"introduction": "在掌握了如何解释MCMC输出之后，下一个重要的实践步骤是设计更高效的采样算法。除了简单的随机游走，我们可以利用目标后验分布的几何信息（如梯度）来构造更智能的提议分布，从而提高采样效率。这个练习 [@problem_id:3289331] 将指导你从朗之万随机微分方程（Langevin SDE）出发，推导出Metropolis调整的朗之万算法（MALA）的提议机制和接受概率，并将理论应用于一个具体的数值计算中。", "problem": "计算系统生物学中的一个核心任务是从含噪声的观测数据中对基因调控的随机模型进行参数推断。考虑一个双参数的转录-降解模型，其参数矢量 $\\theta \\in \\mathbb{R}^{2}$ 上的贝叶斯后验分布是光滑且严格为正的。假设我们希望构建一个马尔可夫链蒙特卡罗 (MCMC) 方法，该方法使用受过阻尼朗之万随机微分方程 (SDE) 启发的动力学来对该后验分布进行抽样。针对目标密度 $\\pi(\\theta)$ 的过阻尼朗之万 SDE 由下式给出\n$$\nd\\theta_{t} \\;=\\; \\frac{1}{2}\\,\\nabla \\log \\pi(\\theta_{t})\\,dt \\;+\\; dW_{t},\n$$\n其中 $W_{t}$ 是一个标准的二维维纳过程，$\\nabla \\log \\pi(\\theta)$ 表示关于 $\\theta$ 的梯度。\n\n任务：\n- 仅从上述 SDE 和 Metropolis-Hastings (MH) 算法的基本定义出发，推导一个形式为 $\\theta' = \\theta + \\frac{\\delta^{2}}{2}\\,\\nabla \\log \\pi(\\theta) + \\delta\\,\\eta$（其中 $\\eta \\sim \\mathcal{N}(0, I)$）的提议机制，并根据 $\\pi$、当前状态 $\\theta$、提议状态 $\\theta'$ 和高斯提议密度推导出相应的 MH 接受概率。首次出现时请定义所引入的任何缩略词。\n\n然后，将问题具体化到以下由随机基因表达模型的线性高斯近似产生的、具有科学现实性的后验分布。后验分布 $\\pi(\\theta)$ 与一个均值为 $\\mu$、协方差为 $\\Sigma$ 的高斯密度成正比：\n$$\n\\pi(\\theta) \\;\\propto\\; \\exp\\!\\left(-\\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu)\\right),\n$$\n其中\n$$\n\\mu = \\begin{pmatrix}0.5 \\\\ -0.3\\end{pmatrix}, \n\\qquad \n\\Sigma = \\begin{pmatrix}0.5  0.1 \\\\ 0.1  0.4\\end{pmatrix}.\n$$\n假设当前状态为\n$$\n\\theta = \\begin{pmatrix}0.6 \\\\ -0.2\\end{pmatrix},\n$$\n步长参数为 $\\delta = 0.2$，实现的高斯噪声抽样为\n$$\n\\eta = \\begin{pmatrix}0.5 \\\\ -1.2\\end{pmatrix}.\n$$\n使用您推导出的提议机制和通用的 MH 接受概率表达式，计算从 $\\theta$ 移动到提议状态 $\\theta'$ 的 Metropolis-Adjusted Langevin Algorithm (MALA) 接受概率。将最终答案表示为小数，并四舍五入到四位有效数字。", "solution": "首先，我们推导Metropolis调整的朗之万算法（Metropolis-Adjusted Langevin Algorithm, MALA）的提议机制和接受概率。\n\n**1. 提议机制**\n过阻尼朗之万随机微分方程（SDE）为：\n$$d\\theta_{t} = \\frac{1}{2}\\nabla \\log \\pi(\\theta_{t})\\,dt + dW_{t}$$\n使用步长为 $\\Delta t$ 的欧拉-丸山法（Euler-Maruyama method）对该SDE进行离散化，我们得到从状态 $\\theta$ 到新状态 $\\theta'$ 的更新规则：\n$$\\theta' \\approx \\theta + \\frac{1}{2}\\nabla \\log \\pi(\\theta) \\Delta t + \\Delta W_t$$\n其中，维纳过程的增量 $\\Delta W_t = W_{t+\\Delta t} - W_t$ 是一个均值为0、协方差为 $(\\Delta t)I$ 的高斯随机变量。我们可以将其写作 $\\Delta W_t = \\sqrt{\\Delta t} \\cdot \\eta$，其中 $\\eta \\sim \\mathcal{N}(0, I)$ 是一个标准正态随机向量。令离散化步长为 $\\delta = \\sqrt{\\Delta t}$，则 $\\Delta t = \\delta^2$。代入上式，我们得到MALA的提议机制：\n$$\\theta' = \\theta + \\frac{\\delta^2}{2}\\nabla \\log \\pi(\\theta) + \\delta\\eta$$\n这个提议是从一个高斯分布 $q(\\theta'|\\theta) = \\mathcal{N}(\\theta' | \\mu_{\\text{prop}}, \\delta^2 I)$ 中抽取的，其均值为 $\\mu_{\\text{prop}} = \\theta + \\frac{\\delta^2}{2}\\nabla \\log \\pi(\\theta)$。\n\n**2. 接受概率**\nMetropolis-Hastings (MH) 算法的接受概率为：\n$$\\alpha(\\theta', \\theta) = \\min\\left(1, \\frac{\\pi(\\theta')q(\\theta|\\theta')}{\\pi(\\theta)q(\\theta'|\\theta)}\\right)$$\n其中 $q(\\theta'|\\theta)$ 和 $q(\\theta|\\theta')$ 分别是正向和反向的提议密度。\n\n**3. 应用于具体问题**\n接下来，我们将此算法应用于给定的高斯后验分布。目标后验的对数梯度为 $g(\\theta) = \\nabla \\log \\pi(\\theta) = -\\Sigma^{-1}(\\theta - \\mu)$。给定的数值为：\n- $\\mu = \\begin{pmatrix}0.5 \\\\ -0.3\\end{pmatrix}$, $\\Sigma = \\begin{pmatrix}0.5  0.1 \\\\ 0.1  0.4\\end{pmatrix}$\n- $\\theta = \\begin{pmatrix}0.6 \\\\ -0.2\\end{pmatrix}$\n- $\\delta = 0.2$, $\\eta = \\begin{pmatrix}0.5 \\\\ -1.2\\end{pmatrix}$\n\n**计算步骤：**\n首先，计算 $\\Sigma^{-1}$：\n$\\det(\\Sigma) = (0.5)(0.4) - (0.1)(0.1) = 0.19$\n$\\Sigma^{-1} = \\frac{1}{0.19} \\begin{pmatrix}0.4  -0.1 \\\\ -0.1  0.5\\end{pmatrix}$\n\n计算在当前状态 $\\theta$ 的梯度 $g(\\theta)$:\n$\\theta - \\mu = \\begin{pmatrix}0.6 - 0.5 \\\\ -0.2 - (-0.3)\\end{pmatrix} = \\begin{pmatrix}0.1 \\\\ 0.1\\end{pmatrix}$\n$g(\\theta) = -\\Sigma^{-1}(\\theta - \\mu) = -\\frac{1}{0.19} \\begin{pmatrix}0.4  -0.1 \\\\ -0.1  0.5\\end{pmatrix} \\begin{pmatrix}0.1 \\\\ 0.1\\end{pmatrix} = -\\frac{1}{0.19} \\begin{pmatrix}0.03 \\\\ 0.04\\end{pmatrix}$\n\n计算提议状态 $\\theta'$：\n$\\theta' = \\theta + \\frac{\\delta^2}{2}g(\\theta) + \\delta\\eta = \\begin{pmatrix}0.6 \\\\ -0.2\\end{pmatrix} - \\frac{(0.2)^2}{2} \\frac{1}{0.19} \\begin{pmatrix}0.03 \\\\ 0.04\\end{pmatrix} + 0.2 \\begin{pmatrix}0.5 \\\\ -1.2\\end{pmatrix}$\n$\\theta' = \\begin{pmatrix}0.6 \\\\ -0.2\\end{pmatrix} - \\frac{0.02}{0.19} \\begin{pmatrix}0.03 \\\\ 0.04\\end{pmatrix} + \\begin{pmatrix}0.1 \\\\ -0.24\\end{pmatrix} = \\begin{pmatrix}0.7 \\\\ -0.44\\end{pmatrix} - \\frac{1}{19} \\begin{pmatrix}0.06 \\\\ 0.08\\end{pmatrix}$\n$\\theta' = \\frac{1}{19} \\begin{pmatrix}13.3 \\\\ -8.36\\end{pmatrix} - \\frac{1}{19} \\begin{pmatrix}0.06 \\\\ 0.08\\end{pmatrix} = \\frac{1}{19}\\begin{pmatrix}13.24 \\\\ -8.44\\end{pmatrix}$\n\n计算接受概率。我们需要计算对数接受比率 $\\log r = \\log\\pi(\\theta') - \\log\\pi(\\theta) + \\log q(\\theta|\\theta') - \\log q(\\theta'|\\theta)$。\n$\\log q(\\theta'|\\theta) - \\log q(\\theta|\\theta') = \\frac{1}{2\\delta^2} \\left( \\left\\| \\theta - \\left( \\theta' + \\frac{\\delta^2}{2}g(\\theta') \\right) \\right\\|^2 - \\left\\| \\theta' - \\left( \\theta + \\frac{\\delta^2}{2}g(\\theta) \\right) \\right\\|^2 \\right)$\n\n计算 $\\log(\\pi(\\theta')/\\pi(\\theta))$：\n$\\log\\frac{\\pi(\\theta')}{\\pi(\\theta)} = \\frac{1}{2} \\left[ (\\theta-\\mu)^T g(\\theta) - (\\theta'-\\mu)^T g(\\theta') \\right]$\n$(\\theta-\\mu)^T g(\\theta) = \\begin{pmatrix}0.1  0.1\\end{pmatrix} \\left(-\\frac{1}{0.19} \\begin{pmatrix}0.03 \\\\ 0.04\\end{pmatrix}\\right) = -\\frac{0.007}{0.19} \\approx -0.036842$\n计算 $g(\\theta')$:\n$\\theta'-\\mu = \\frac{1}{19}\\begin{pmatrix}13.24 \\\\ -8.44\\end{pmatrix} - \\begin{pmatrix}0.5 \\\\ -0.3\\end{pmatrix} = \\frac{1}{19}\\begin{pmatrix}13.24 - 9.5 \\\\ -8.44 + 5.7\\end{pmatrix} = \\frac{1}{19}\\begin{pmatrix}3.74 \\\\ -2.74\\end{pmatrix}$\n$g(\\theta') = -\\Sigma^{-1}(\\theta'-\\mu) = -\\frac{1}{0.19}\\begin{pmatrix}0.4  -0.1 \\\\ -0.1  0.5\\end{pmatrix}\\frac{1}{19}\\begin{pmatrix}3.74 \\\\ -2.74\\end{pmatrix} = -\\frac{1}{3.61}\\begin{pmatrix}1.77 \\\\ -1.744\\end{pmatrix}$\n$(\\theta'-\\mu)^T g(\\theta') = \\left(\\frac{1}{19}\\begin{pmatrix}3.74 \\\\ -2.74\\end{pmatrix}\\right)^T \\left(-\\frac{1}{3.61}\\begin{pmatrix}1.77 \\\\ -1.744\\end{pmatrix}\\right) = -\\frac{6.174436}{68.59} \\approx -0.166185$\n$\\log\\frac{\\pi(\\theta')}{\\pi(\\theta)} \\approx \\frac{1}{2}[ -0.036842 - (-0.166185) ] \\approx -0.064671$\n\n计算 $\\log(q(\\theta|\\theta')/q(\\theta'|\\theta))$：\n$\\left\\| \\theta' - \\left( \\theta + \\frac{\\delta^2}{2}g(\\theta) \\right) \\right\\|^2 = \\| \\delta\\eta \\|^2 = (0.2)^2 (0.5^2 + (-1.2)^2) = 0.04(0.25+1.44) = 0.0676$\n$\\theta-\\theta'-\\frac{\\delta^2}{2}g(\\theta') = -(\\theta'-\\theta) - \\frac{\\delta^2}{2}g(\\theta') \\approx - \\begin{pmatrix}0.09684 \\\\ -0.24421\\end{pmatrix} - 0.02\\begin{pmatrix}-0.4903 \\\\ 0.4831\\end{pmatrix} \\approx \\begin{pmatrix}-0.08703 \\\\ 0.23455\\end{pmatrix}$\n$\\left\\| \\theta - \\left( \\theta' + \\frac{\\delta^2}{2}g(\\theta') \\right) \\right\\|^2 \\approx (-0.08703)^2 + (0.23455)^2 \\approx 0.007574 + 0.055014 = 0.062588$\n$\\log\\frac{q(\\theta|\\theta')}{q(\\theta'|\\theta)} = \\frac{1}{2\\delta^2}(0.062588 - 0.0676) = \\frac{-0.005012}{0.08} \\approx 0.06265$\n\n最后，计算对数接受比率：\n$\\log r \\approx -0.064671 + 0.06265 = -0.002021$\n$\\alpha = \\min(1, \\exp(\\log r)) = \\exp(-0.002021) \\approx 0.99798$\n\n四舍五入到四位有效数字，结果是 $0.9980$。", "answer": "$$\\boxed{0.9980}$$", "id": "3289331"}, {"introduction": "最终，将理论知识转化为可工作的代码是MCMC实践的终极考验。在实际的科学问题中，我们常常会遇到由于概率值极小或极大而导致的数值下溢或上溢问题。这个练习 [@problem_id:3604531] 要求你为一个源自计算核物理的真实模型，从零开始实现一个数值稳定的Metropolis-Hastings采样器，通过在对数域（log-domain）中进行所有计算来应对这些挑战，从而确保算法的鲁棒性。", "problem": "您的任务是实现一个数值稳定的 Metropolis–Hastings 算法，为一个用于计算核物理的简单透射实验模型执行贝叶斯推断。您的实现必须是一个完整的、可运行的程序，并且所有可能遭受下溢或上溢的计算都必须在适当的对数域中执行。\n\n考虑单能束流在选定的束流能量下穿过薄靶的透射。设有效能量依赖性衰减由以下模型描述：\n$$\n\\Sigma(E;\\sigma_0,A) = \\sigma_0 + \\frac{A}{(E - E_r)^2 + \\gamma^2},\n$$\n其中 $E$ 是束流能量，$\\sigma_0 \\ge 0$ 和 $A \\ge 0$ 是待推断的未知非负参数，而 $E_r$ 和 $\\gamma$ 是已知常数。在能量 $E_i$ 处的预期透射计数由以下模型给出：\n$$\n\\lambda_i = I_0 \\exp\\left(-k \\, \\Sigma(E_i; \\sigma_0, A)\\right),\n$$\n其中 $I_0  0$ 和 $k  0$ 是已知的。在每个选定的 $E_i$ 处观测到的透射计数 $y_i$ 是相互独立的，并遵循均值为 $\\lambda_i$ 的泊松分布。\n\n您的任务是：\n- 通过对数变换 $\\theta = (\\theta_0,\\theta_1)$ 来表示未知数，其中 $\\sigma_0 = \\exp(\\theta_0)$ 和 $A = \\exp(\\theta_1)$，以强制其非负性。\n- 对 $\\theta_j$ 使用独立的高斯先验，其均值和标准差为给定值。\n- 在变换空间 $\\theta$ 中，使用高斯提议实现一个随机游走 Metropolis–Hastings 采样器。由于提议分布是对称的，Hastings 修正项被抵消。\n- 使用对数域算术计算所有接受决策，以确保数值稳定性。具体来说，不要直接在线性尺度上计算接受概率；而是将 $\\log u$ 与对数接受率进行比较，其中 $u$ 从 $(0,1)$ 上的均匀分布中抽取。\n- 通过对泊松对数概率求和来计算对数似然，且仅使用对数安全的量。如果直接计算 $\\lambda_i$ 再取对数 $\\log(\\lambda_i)$ 会有下溢风险，则不得这样做；而是应将 $\\log(\\lambda_i)$ 计算为 $\\log(I_0) - k \\,\\Sigma(E_i; \\sigma_0, A)$，并将 $-\\lambda_i$ 计算为 $-\\exp(\\log(\\lambda_i))$。为 $\\log(y_i!)$ 使用数值稳定的函数。\n\n使用以下测试套件，它指定了三种不同情况下的合成实验。在每种情况下，您都必须使用指定的全局种子和种子偏移量，通过所述的泊松模型生成合成数据 $y_i$，然后执行推断。\n\n所有测试的通用设置：\n- 能量 $E = [6.0, 6.3, 6.6, 6.9, 7.2]$。\n- 共振参数 $E_r = 6.6$ 和 $\\gamma = 0.05$。\n- 全局基础种子 $s = 12345$。对于测试用例索引 $c \\in \\{0,1,2\\}$，使用数据生成和采样的随机数生成器种子 $s + c$。\n\n测试用例 1 (中等情况):\n- $I_0 = 200000$, $k = 5.0$。\n- 用于数据生成的真实参数：$\\sigma_0^{\\mathrm{true}} = 0.3$, $A^{\\mathrm{true}} = 3.0$。\n- $\\theta$ 的先验：均值 $(\\mu_0,\\mu_1) = (\\log(0.3), \\log(3.0))$，标准差 $(\\tau_0,\\tau_1) = (1.0, 1.0)$。\n- $(\\theta_0,\\theta_1)$ 的提议标准差：$(0.05, 0.10)$。\n- Metropolis–Hastings 运行长度 $N = 12000$，老化期 $B = 2000$。\n\n测试用例 2 (极端衰减，预期有大量零值):\n- $I_0 = 5000000$, $k = 50.0$。\n- 用于数据生成的真实参数：$\\sigma_0^{\\mathrm{true}} = 0.1$, $A^{\\mathrm{true}} = 10.0$。\n- $\\theta$ 的先验：均值 $(\\mu_0,\\mu_1) = (\\log(0.2), \\log(2.0))$，标准差 $(\\tau_0,\\tau_1) = (1.0, 1.0)$。\n- $(\\theta_0,\\theta_1)$ 的提议标准差：$(0.10, 0.20)$。\n- Metropolis–Hastings 运行长度 $N = 12000$，老化期 $B = 2000$。\n\n测试用例 3 (几乎平坦的背景，无共振贡献):\n- $I_0 = 150000$, $k = 2.0$。\n- 用于数据生成的真实参数：$\\sigma_0^{\\mathrm{true}} = 0.25$, $A^{\\mathrm{true}} = 0.0$。\n- $\\theta$ 的先验：均值 $(\\mu_0,\\mu_1) = (\\log(0.2), \\log(1.0))$，标准差 $(\\tau_0,\\tau_1) = (1.0, 0.5)$。\n- $(\\theta_0,\\theta_1)$ 的提议标准差：$(0.05, 0.10)$。\n- Metropolis–Hastings 运行长度 $N = 12000$，老化期 $B = 2000$。\n\n要求：\n- 使用指定的种子生成合成计数并驱动采样器。\n- 为保证数值稳定性，所有接受决策必须完全在对数域中执行，即，如果 $\\log u  \\min\\{0, \\log \\pi(\\theta') - \\log \\pi(\\theta)\\}$，则接受，其中 $\\pi$ 是变换空间中未归一化的后验密度，且 $u \\sim \\mathrm{Uniform}(0,1)$。\n- 对于每个测试用例，根据老化期结束后的样本计算 $\\sigma_0$ 和 $A$ 的后验均值估计，以及整个运行过程中的总接受率。在此简化模型中，这些参数是无量纲的，因此不需要物理单位。\n- 角度单位不适用。\n- 最终结果必须汇总三个测试用例并打印为单行：一个逗号分隔的 Python 风格列表，按顺序包含每个用例的 $\\sigma_0$ 后验均值、$A$ 后验均值和接受率，即\n$$\n[\\overline{\\sigma_0}^{(1)}, \\overline{A}^{(1)}, \\alpha^{(1)}, \\overline{\\sigma_0}^{(2)}, \\overline{A}^{(2)}, \\alpha^{(2)}, \\overline{\\sigma_0}^{(3)}, \\overline{A}^{(3)}, \\alpha^{(3)}].\n$$\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]$）。数值结果必须是浮点数。\n\n测试套件覆盖意图：\n- 测试用例 1 是一个标准的、表现良好的情况。\n- 测试用例 2 强调对数域的稳定性，因为 $\\lambda_i$ 可能极小，从而产生许多零值。\n- 测试用例 3 探讨当共振贡献消失（$A \\approx 0$）时的可辨识性，并测试先验的影响。\n\n请实现程序以精确执行这些任务，并打印所需的单行输出。不允许用户输入，程序在指定种子下必须是完全确定性的。", "solution": "该问题要求实现一个 Metropolis-Hastings 马尔可夫链蒙特卡洛（MCMC）算法，以对核透射模型的参数进行贝叶斯推断。该解决方案必须是数值稳定的，特别是通过一致地使用对数域算术。整个过程可以分解为贝叶斯模型的构建、MCMC 采样算法的描述以及对生成样本的最终分析。\n\n### 1. 贝叶斯模型构建\n\n贝叶斯方法的核心是后验分布，它将关于参数的先验知识与来自观测数据的信息（似然）相结合。\n\n**参数变换：**\n待推断的物理参数是背景衰减 $\\sigma_0$ 和共振幅度 $A$，两者都必须是非负的。为了自然地强制执行此约束，我们在一个变换后的参数空间 $\\theta = (\\theta_0, \\theta_1)$ 中工作，其中：\n$$\n\\sigma_0 = \\exp(\\theta_0) \\quad \\text{和} \\quad A = \\exp(\\theta_1)\n$$\n此变换将每个 $\\theta_j$ 的整个实数轴 $(-\\infty, \\infty)$ 映射到 $\\sigma_0$ 和 $A$ 所需的正值域 $(0, \\infty)$。\n\n**似然函数：**\n观测数据由在一组能量 $E = \\{E_i\\}$ 下的计数 $y = \\{y_i\\}$ 组成。每个 $y_i$ 被建模为来自泊松分布的独立抽样，其均值 $\\lambda_i$ 依赖于参数 $\\theta$：\n$$\ny_i \\sim \\text{Poisson}(\\lambda_i(\\theta))\n$$\n对于数据集 $y$ 的完整似然是各个泊松概率的乘积：\n$$\np(y | \\theta) = \\prod_{i} \\frac{\\lambda_i(\\theta)^{y_i} e^{-\\lambda_i(\\theta)}}{y_i!}\n$$\n平均计数率 $\\lambda_i$ 由比尔-朗伯衰减定律确定：\n$$\n\\lambda_i(\\theta) = I_0 \\exp\\left(-k \\, \\Sigma(E_i; \\sigma_0, A)\\right)\n$$\n其中 $I_0$ 是入射束流强度， $k$ 是一个与靶厚度和数密度相关的常数。能量依赖的衰减截面 $\\Sigma$ 被建模为一个恒定背景加上一个洛伦兹共振：\n$$\n\\Sigma(E_i; \\sigma_0, A) = \\sigma_0 + \\frac{A}{(E_i - E_r)^2 + \\gamma^2}\n$$\n在这里，$E_r$ 和 $\\gamma$ 分别是代表共振能量和宽度的已知常数。\n\n**先验分布：**\n先验分布表示我们在观测数据之前对参数的了解。对于变换后的参数 $\\theta_j$，指定了独立的高斯先验：\n$$\np(\\theta) = p(\\theta_0)p(\\theta_1) = \\mathcal{N}(\\theta_0 | \\mu_0, \\tau_0^2) \\, \\mathcal{N}(\\theta_1 | \\mu_1, \\tau_1^2)\n$$\n其中 $(\\mu_0, \\mu_1)$ 是 $\\theta_0$ 和 $\\theta_1$ 的先验均值，$(\\tau_0, \\tau_1)$ 是先验标准差。\n\n### 2. 对数后验与数值稳定性\n\n后验分布 $\\pi(\\theta | y)$ 由贝叶斯定理给出：\n$$\n\\pi(\\theta | y) \\propto p(y | \\theta) \\, p(\\theta)\n$$\n出于计算目的，处理后验分布的对数要稳定和方便得多。由于 MCMC 算法仅依赖于后验密度的比率，因此可以忽略加法常数。\n$$\n\\log \\pi(\\theta | y) = \\log p(y | \\theta) + \\log p(\\theta) + \\text{constant}\n$$\n对数似然项为：\n$$\n\\log p(y | \\theta) = \\sum_i \\left( y_i \\log(\\lambda_i(\\theta)) - \\lambda_i(\\theta) - \\log(y_i!) \\right)\n$$\n为防止数值下溢/上溢，特别是在具有极端衰减的测试用例中（其中 $\\lambda_i$ 可能非常接近于零），我们必须仔细计算这些项：\n1.  $\\log(\\lambda_i(\\theta))$ 项直接从其定义计算，以避免首先计算一个可能非常小的 $\\lambda_i$：\n    $$\n    \\log(\\lambda_i(\\theta)) = \\log(I_0) - k \\, \\Sigma(E_i; \\exp(\\theta_0), \\exp(\\theta_1))\n    $$\n2.  $-\\lambda_i(\\theta)$ 项计算为 $-\\exp(\\log(\\lambda_i(\\theta)))$。\n3.  对数阶乘项 $\\log(y_i!)$ 通过数值稳定的对数伽马函数 $\\log \\Gamma(y_i+1)$ 计算。\n\n对数先验项是两个高斯对数概率密度之和（忽略归一化常数）：\n$$\n\\log p(\\theta) \\propto -\\frac{1}{2} \\left[ \\left(\\frac{\\theta_0 - \\mu_0}{\\tau_0}\\right)^2 + \\left(\\frac{\\theta_1 - \\mu_1}{\\tau_1}\\right)^2 \\right]\n$$\n\n### 3. Metropolis-Hastings 算法\n\n我们采用随机游走 Metropolis-Hastings (RWMH) 算法从后验分布 $\\pi(\\theta | y)$ 中抽取样本。\n\n1.  **初始化**：马尔可夫链在起始点 $\\theta^{(0)}$ 初始化，选择为先验的均值 $(\\mu_0, \\mu_1)$。\n2.  **迭代**：对于从 $0$ 到 $N-1$ 的每一步 $t$：\n    a.  **提议**：通过向当前状态 $\\theta^{(t)}$ 添加来自对称高斯分布的随机扰动来提议一个新的候选状态 $\\theta'$：\n        $$\n        \\theta' = \\theta^{(t)} + \\epsilon, \\quad \\text{其中} \\quad \\epsilon \\sim \\mathcal{N}(0, \\Sigma_p)\n        $$\n        提议协方差 $\\Sigma_p$ 是对角矩阵，其方差由指定的提议标准差给出。由于提议是对称的，Hastings 修正项为 1。\n\n    b.  **接受**：候选 $\\theta'$ 以概率 $\\alpha(\\theta', \\theta^{(t)}) = \\min\\left(1, \\frac{\\pi(\\theta'|y)}{\\pi(\\theta^{(t)}|y)}\\right)$ 被接受。为了稳定地实现此决策，我们计算比率的对数：\n        $$\n        \\log r = \\log\\pi(\\theta'|y) - \\log\\pi(\\theta^{(t)}|y)\n        $$\n        然后我们抽取一个均匀随机数 $u \\sim \\mathcal{U}(0,1)$，如果 $\\log u  \\log r$，则接受提议。问题指定了等效且稳健的条件：如果 $\\log u  \\min(0, \\log r)$，则接受。如果接受，我们设置 $\\theta^{(t+1)} = \\theta'$；否则，我们设置 $\\theta^{(t+1)} = \\theta^{(t)}$，链不移动。\n\n### 4. 数据模拟与后验分析\n\n对于三个测试用例中的每一个，我们首先模拟合成数据，然后执行推断。\n\n-   **数据生成**：对于给定的具有真实参数 $(\\sigma_0^{\\text{true}}, A^{\\text{true}})$ 的测试用例，我们为每个能量 $E_i$ 计算真实的平均计数 $\\lambda_i^{\\text{true}}$。然后通过从泊松分布 $y_i \\sim \\text{Poisson}(\\lambda_i^{\\text{true}})$ 中抽样来生成合成数据集 $\\{y_i\\}$，使用指定的随机数生成器种子以保证可复现性。\n\n-   **推断与分析**：\n    1.  RWMH 采样器运行 $N$ 次总迭代，以生成一个样本链 $\\{\\theta^{(t)}\\}_{t=0}^{N-1}$。\n    2.  初始的 $B$ 个样本（老化期）被丢弃，以确保剩余的样本代表平稳后验分布。\n    3.  老化期后的 $\\theta$ 样本被变换回原始参数空间：$(\\sigma_0^{(t)}, A^{(t)}) = (\\exp(\\theta_0^{(t)}), \\exp(\\theta_1^{(t)}))$。\n    4.  通过对这些样本求平均来估计后验均值：\n        $$\n        \\overline{\\sigma_0} = \\frac{1}{N-B} \\sum_{t=B}^{N-1} \\sigma_0^{(t)}, \\quad \\overline{A} = \\frac{1}{N-B} \\sum_{t=B}^{N-1} A^{(t)}\n        $$\n    5.  总接受率 $\\alpha$ 计算为在 $N$ 次迭代的总运行中接受的提议的比例。\n\n整个过程在一个程序中实现，对每个测试用例执行，并将最终结果汇总成指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Main function to run the full analysis for all test cases and print the final result.\n    \"\"\"\n\n    # Common settings for all test cases\n    common_settings = {\n        'E': np.array([6.0, 6.3, 6.6, 6.9, 7.2]),\n        'Er': 6.6,\n        'gamma': 0.05,\n        'N': 12000,\n        'B': 2000,\n        'base_seed': 12345\n    }\n\n    # Test suite definition\n    test_cases = [\n        {\n            # Test case 1: Moderate regime\n            'case_idx': 0,\n            'I0': 200000.0,\n            'k': 5.0,\n            'true_params': {'sigma0': 0.3, 'A': 3.0},\n            'prior_means': (np.log(0.3), np.log(3.0)),\n            'prior_stds': (1.0, 1.0),\n            'proposal_stds': (0.05, 0.10)\n        },\n        {\n            # Test case 2: Extreme attenuation\n            'case_idx': 1,\n            'I0': 5000000.0,\n            'k': 50.0,\n            'true_params': {'sigma0': 0.1, 'A': 10.0},\n            'prior_means': (np.log(0.2), np.log(2.0)),\n            'prior_stds': (1.0, 1.0),\n            'proposal_stds': (0.10, 0.20)\n        },\n        {\n            # Test case 3: Nearly flat background\n            'case_idx': 2,\n            'I0': 150000.0,\n            'k': 2.0,\n            'true_params': {'sigma0': 0.25, 'A': 0.0},\n            'prior_means': (np.log(0.2), np.log(1.0)),\n            'prior_stds': (1.0, 0.5),\n            'proposal_stds': (0.05, 0.10)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Combine common settings with case-specific settings\n        params = {**common_settings, **case}\n        \n        # Run the MCMC simulation for the current case\n        mean_sigma0, mean_A, acceptance_rate = run_mcmc_for_case(params)\n        \n        # Append results for this case\n        all_results.extend([mean_sigma0, mean_A, acceptance_rate])\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef sigma_attenuation(E, sigma0, A, Er, gamma):\n    \"\"\"\n    Computes the effective energy-dependent attenuation Sigma.\n    \"\"\"\n    return sigma0 + A / ((E - Er)**2 + gamma**2)\n\ndef log_posterior(theta, y, E, I0, k, Er, gamma, prior_means, prior_stds):\n    \"\"\"\n    Computes the log of the unnormalized posterior density.\n    All calculations are performed in the log domain for numerical stability.\n    \"\"\"\n    theta0, theta1 = theta\n    sigma0 = np.exp(theta0)\n    A = np.exp(theta1)\n    \n    # Log-prior calculation\n    log_prior_val = -0.5 * np.sum(((theta - prior_means) / prior_stds)**2)\n\n    # Log-likelihood calculation (vectorized over energies E)\n    Sigma_vec = sigma_attenuation(E, sigma0, A, Er, gamma)\n    log_lambda_vec = np.log(I0) - k * Sigma_vec\n    \n    # Poisson log-likelihood: y*log(lambda) - lambda - log(y!)\n    log_likelihood_val = np.sum(y * log_lambda_vec - np.exp(log_lambda_vec) - gammaln(y + 1))\n    \n    return log_likelihood_val + log_prior_val\n\ndef run_mcmc_for_case(params):\n    \"\"\"\n    Generates synthetic data and runs the Metropolis-Hastings sampler for a single test case.\n    \"\"\"\n    # Unpack parameters\n    E = params['E']\n    Er = params['Er']\n    gamma = params['gamma']\n    I0 = params['I0']\n    k = params['k']\n    true_params = params['true_params']\n    prior_means = np.array(params['prior_means'])\n    prior_stds = np.array(params['prior_stds'])\n    proposal_stds = np.array(params['proposal_stds'])\n    N = params['N']\n    B = params['B']\n    seed = params['base_seed'] + params['case_idx']\n\n    # Initialize random number generator with the specified seed\n    rng = np.random.default_rng(seed)\n\n    # --- 1. Generate Synthetic Data ---\n    sigma0_true = true_params['sigma0']\n    A_true = true_params['A']\n    \n    Sigma_true = sigma_attenuation(E, sigma0_true, A_true, Er, gamma)\n    lambda_true = I0 * np.exp(-k * Sigma_true)\n    y = rng.poisson(lambda_true)\n\n    # --- 2. Run Metropolis-Hastings Sampler ---\n    # Initialization\n    theta_current = np.array(prior_means)\n    log_post_current = log_posterior(theta_current, y, E, I0, k, Er, gamma, prior_means, prior_stds)\n\n    samples = np.zeros((N, 2))\n    n_accepted = 0\n\n    for i in range(N):\n        # Propose a new state (random walk)\n        theta_proposal = theta_current + rng.normal(0, proposal_stds)\n\n        # Calculate log posterior for the proposal\n        log_post_proposal = log_posterior(theta_proposal, y, E, I0, k, Er, gamma, prior_means, prior_stds)\n\n        # Acceptance step in log-domain\n        log_r = log_post_proposal - log_post_current\n        log_u = np.log(rng.uniform())\n\n        if log_u  log_r:\n            theta_current = theta_proposal\n            log_post_current = log_post_proposal\n            n_accepted += 1\n        \n        samples[i] = theta_current\n\n    # --- 3. Post-processing ---\n    # Discard burn-in samples\n    post_burn_in_samples = samples[B:]\n\n    # Transform samples from log-space (theta) to original space (sigma0, A)\n    sigma0_samples = np.exp(post_burn_in_samples[:, 0])\n    A_samples = np.exp(post_burn_in_samples[:, 1])\n\n    # Compute posterior means\n    mean_sigma0 = np.mean(sigma0_samples)\n    mean_A = np.mean(A_samples)\n\n    # Compute acceptance rate\n    acceptance_rate = n_accepted / N\n\n    return mean_sigma0, mean_A, acceptance_rate\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3604531"}]}