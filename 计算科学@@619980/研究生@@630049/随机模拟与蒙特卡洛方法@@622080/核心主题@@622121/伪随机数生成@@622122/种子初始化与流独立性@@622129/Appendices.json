{"hands_on_practices": [{"introduction": "在并行模拟中，为确保统计有效性，每个处理器都必须使用独立的随机数流。一种可靠的方法是从一个长序列中为每个处理器分配相距甚远的起始点或“种子”。本练习将指导您实现线性同余生成器（LCG）中高效“快速跳转”（skip-ahead）的核心算法。通过将LCG的单步迭代看作一个仿射变换，我们可以利用二元幂算法在对数时间内计算出未来数万亿步之后的状态，这是简单迭代无法企及的。掌握这项技术（[@problem_id:3338260]）是正确实现并行随机数生成和保证模拟结果有效性的基础。", "problem": "考虑由递推关系 $x_{k+1} = (a x_k + c) \\bmod m$ 在状态空间 $\\{0,1,\\dots,m-1\\}$ 上定义的线性同余生成器 (LCG)，其中 $m = 2^{48}$，$a = 25214903917$，$c = 11$。在随机模拟和蒙特卡洛方法 (MC) 中，通过确定性的向前跳转 (skip-ahead) 来实现种子初始化和流独立性，从而可以从单个生成器构建多个在指定窗口内不重叠的独立子流。\n\n从以下基本原理出发：\n- LCG 递推关系 $x_{k+1} = (a x_k + c) \\bmod m$ 在环 $\\mathbb{Z}/m\\mathbb{Z}$ 上定义了一个仿射映射 (affine map) $f(x) = (a x + c) \\bmod m$。\n- 仿射映射的复合是结合且封闭的：如果 $f(x) = (A x + C) \\bmod m$ 且 $g(x) = (B x + D) \\bmod m$，那么 $g \\circ f$ 也是 $\\mathbb{Z}/m\\mathbb{Z}$ 上的一个仿射映射。\n- 二进制幂 (也称为平方求幂) 将重复复合的次数减少到 $O(\\log t)$ 次复合。\n\n您的任务是：\n1. 从第一性原理出发，推导一个算法，该算法使用模 $m$ 的仿射映射的二进制幂运算，从给定的 $x_n$ 计算任意非负整数 $t$ 对应的 $x_{n+t}$。将您的推导具体应用于 $t = 10^{12}$ 的情况，并说明如何在不迭代递推关系 $10^{12}$ 次且不需求解在 $\\mathbb{Z}/2^{48}\\mathbb{Z}$ 中可能不存在的模逆元的情况下计算 $x_{n+10^{12}}$。\n2. 分析您的算法关于 $t$ 的时间和空间复杂度，并讨论这如何通过向前跳转支持蒙特卡洛模拟中的流独立性。\n3. 在一个完整的、可运行的程序中实现该算法，并将其应用于以下测试套件。每个测试用例产生一个布尔值或整数结果：\n   - 测试 1 (与朴素迭代对比的正确性)：设 $x_n = 42$ 且 $t = 1000$。分别通过您的向前跳转算法和直接迭代 LCG 计算 $x_{n+t}$，并返回一个布尔值，指示两个结果是否相等。\n   - 测试 2 (单位元边界)：设 $x_n = 1234567890123$ 且 $t = 0$。计算并返回 $x_{n+t}$ 的整数值。\n   - 测试 3 (单步边界)：设 $x_n = 1$ 且 $t = 1$。计算并返回 $x_{n+t}$ 的整数值。\n   - 测试 4 (从零开始的大步跳转)：设 $x_n = 0$ 且 $t = 10^{12}$。计算并返回 $x_{n+t}$ 的整数值。\n   - 测试 5 (窗口内的经验性子流独立性)：使用步长 $S = 10^{12}$ 定义两个子流。设初始种子为 $x_0 = 1234567890123$，通过您的向前跳转算法将第二个种子定义为 $x_0' = x_{0+S}$，然后通过直接迭代生成每个子流的前 $L = 1000$ 个状态。返回一个布尔值，指示两个子流的前 $L$ 个状态的集合是否不相交。\n\n您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的测试结果列表（例如，“[result1,result2,result3,result4,result5]”）。不涉及任何物理单位或角度；所有量都是指定环算术中的纯整数或布尔值。", "solution": "问题要求推导、分析并实现一个高效算法，用于在给定起始状态 $x_n$ 的情况下，计算线性同余生成器 (LCG) 的状态 $x_{n+t}$，而无需执行 $t$ 次迭代。这种技术被称为向前跳转 (skip-ahead) 或跳步 (jump-ahead)。\n\nLCG 由以下递推关系定义：\n$$x_{k+1} = (a x_k + c) \\bmod m$$\n参数为 $m = 2^{48}$，$a = 25214903917$，$c = 11$。\n\n### 1. 向前跳转算法的推导\n\n核心原理是将 LCG 递推表示为仿射变换的重复应用，然后使用高效算法计算该变换的 $t$ 次幂。\n\n**步骤 1：将 LCG 形式化为仿射映射**\n递推关系 $x_{k+1} = (ax_k + c) \\pmod m$ 可以表示为将函数 $f$ 应用于状态 $x_k$：\n$$x_{k+1} = f(x_k)$$\n其中 $f(x) = (ax + c) \\pmod m$。这是在模 $m$ 整数环 $\\mathbb{Z}/m\\mathbb{Z}$ 上的一个仿射变换。\n为了找到 $t$ 步之后的状态 $x_{n+t}$，我们必须将映射 $f$ 对初始状态 $x_n$ 应用总共 $t$ 次：\n$$x_{n+t} = f(f(\\dots f(x_n)\\dots)) = f^t(x_n)$$\n\n**步骤 2：仿射映射复合的代数**\n让我们分析两个此类仿射映射的复合。考虑两个映射，$g(x) = (A'x + C') \\pmod m$ 和 $h(x) = (Ax + C) \\pmod m$。它们的复合 $(g \\circ h)(x)$ 是：\n$$(g \\circ h)(x) = g(h(x)) = A'(Ax + C) + C' = (A'A)x + (A'C + C') \\pmod m$$\n两个仿射映射的复合是另一个仿射映射。我们可以对系数对 $(A, C)$ 定义一个复合运算。如果 $g$ 对应于对 $(A', C')$ 而 $h$ 对应于 $(A, C)$，它们的复合 $g \\circ h$ 对应于一个新的对：\n$$(A', C') \\circ (A, C) = (A'A \\pmod m, (A'C + C') \\pmod m)$$\n这个复合运算是结合的，这是求幂运算的一个关键属性。\n\n对 $x_{n+t}$ 的暴力计算将是 $f^t(x_n)$，这在计算上是昂贵的。通过归纳可以找到一个更直接的公式：\n$$x_{n+1} = ax_n + c$$\n$$x_{n+2} = a(ax_n+c)+c = a^2x_n + ac+c$$\n$$x_{n+3} = a(a^2x_n+ac+c)+c = a^3x_n + a^2c+ac+c$$\n$x_{n+t}$ 的一般形式是：\n$$x_{n+t} = \\left(a^t x_n + c \\sum_{i=0}^{t-1} a^i\\right) \\pmod m$$\n该和是一个几何级数，其闭式解为 $\\sum_{i=0}^{t-1} a^i = \\frac{a^t-1}{a-1}$。使用这个公式，我们会得到：\n$$x_{n+t} = \\left(a^t x_n + c \\frac{a^t-1}{a-1}\\right) \\pmod m$$\n这个公式需要除以 $a-1$，这意味着我们需要找到 $(a-1) \\pmod m$ 的模乘法逆元。对于 $m=2^{48}$ 和 $a=25214903917$，$a-1=25214903916$，这是一个偶数。由于 $m$ 也是偶数，$\\gcd(a-1, m) \\neq 1$，因此 $(a-1) \\pmod{2^{48}}$ 的模逆元不存在。因此，对于给定的参数，此方法无效，正如问题陈述中正确指出的那样。\n\n**步骤 3：仿射映射的二进制幂运算**\n避免模逆元的有效方法是，使用复合规则和二进制幂（也称为平方求幂）来计算复合映射 $f^t(x) = (A_t x + C_t) \\pmod m$ 的系数。\n\n目标是计算代表 $f^t$ 的系数对 $(A_t, C_t)$。这等同于在复合运算下，计算由其系数对 $(a, c)$ 表示的映射 $f$ 的 $t$ 次幂。\n\n计算 $(A_t, C_t) = (a, c)^t$ 的算法如下：\n设 $t$ 的二进制表示为 $t = \\sum_{i=0}^k b_i 2^i$，其中 $b_i \\in \\{0, 1\\}$。则 $f^t = \\prod_{i: b_i=1} f^{2^i}$。我们可以迭代地计算这个乘积。\n\n1.  **初始化**：\n    单位映射是 $id(x) = 1 \\cdot x + 0$，所以其系数对是 $(1, 0)$。这将是我们最终结果的累加器。\n    设 $(A_{res}, C_{res}) = (1, 0)$。\n    基础映射是 $f^1$，对应于系数对 $(a, c)$。\n    设 $(A_{base}, C_{base}) = (a, c)$。\n\n2.  **迭代**：我们从最低有效位到最高有效位处理 $t$ 的比特位。\n    当 $t > 0$ 时：\n    a. 如果 $t$ 的当前最低有效位是 $1$，我们将累加结果与当前基础映射复合：$(A_{res}, C_{res}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{res}, C_{res})$。使用复合规则，这变为：\n       - $A_{res, new} = (A_{base} \\cdot A_{res}) \\pmod m$\n       - $C_{res, new} = (A_{base} \\cdot C_{res} + C_{base}) \\pmod m$\n    b. 我们将基础映射平方以准备处理下一位，因为 $f^{2^{i+1}} = f^{2^i} \\circ f^{2^i}$：$(A_{base}, C_{base}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{base}, C_{base})$。这变为：\n       - $A_{base, new} = (A_{base} \\cdot A_{base}) \\pmod m$\n       - $C_{base, new} = (A_{base} \\cdot C_{base} + C_{base}) \\pmod m$\n    c. 我们通过右移来丢弃已处理的 $t$ 的比特位：$t \\leftarrow t \\gg 1$。\n\n3.  **最终化**：\n    循环结束后，系数对 $(A_{res}, C_{res})$ 将是 $(A_t, C_t)$。\n    然后通过将此映射应用于 $x_n$ 来计算最终状态 $x_{n+t}$：\n    $$x_{n+t} = (A_t \\cdot x_n + C_t) \\pmod m$$\n该算法仅使用模乘法和模加法计算结果，无需逆元。对于 $t = 10^{12}$，此算法非常高效，因为迭代次数与 $\\log_2(10^{12})$ 成正比。\n\n### 2. 复杂度分析及其在流独立性中的应用\n\n**时间复杂度**\n二进制幂算法迭代约 $\\log_2 t$ 次。在每次迭代内部，执行固定数量的模乘法和模加法来完成两个复合操作。所涉及的数都以 $m$ 为界，对于固定的 $m$，这些算术运算花费常数时间。因此，计算系数 $(A_t, C_t)$ 的时间复杂度是 $O(\\log t)$。计算出系数后，单次应用映射需要一次乘法和一次加法，这是一个 $O(1)$ 的操作。因此，向前跳转算法的总时间复杂度是 $O(\\log t)$。\n\n**空间复杂度**\n该算法需要固定数量的变量来存储累加器和基础映射的系数，以及输入参数。内存使用量不随 $t$ 扩展。因此，空间复杂度为 $O(1)$。\n\n**在蒙特卡洛模拟中对流独立性的支持**\n在并行蒙特卡洛模拟中，至关重要的是 $P$ 个并行进程中的每一个都生成与其他进程统计上独立的随机数序列。单个 LCG 产生一个长长的状态序列。为每个进程创建独立的“子流”的一种稳健方法是对这个主序列进行分区。\n\n我们可以为进程 $i$（对于 $i \\in \\{0, 1, \\dots, P-1\\}$）分配一个从种子 $x_S^{(i)} = x_{i \\cdot S}$ 开始的子流，其中 $S$ 是一个非常大的跳转距离或步长。例如，我们可以选择 $S=10^{12}$。\n- 进程 0 从 $x_0$ 开始。\n- 进程 1 从 $x_S$ 开始，其计算方式为 $f^S(x_0)$。\n- 进程 2 从 $x_{2S}$ 开始，其计算方式为 $f^S(x_S)$。\n- 以此类推，进程 $i$ 从 $x_{iS} = f^S(x_{(i-1)S})$ 开始。\n\n所推导的向前跳转算法及其 $O(\\log S)$ 的时间复杂度是实现此方法的关键技术。计算每个进程的起始种子几乎是瞬时的，即使对于像 $S=10^{12}$ 这样巨大的步长也是如此。如果没有这个算法，计算 $x_{i \\cdot S}$ 将需要 $i \\cdot S$ 次迭代，这在计算上是不可行的，也违背了并行的目的。\n\n通过选择一个远大于任何单个进程将消耗的随机变量数量的 $S$，我们可以确保不同进程使用的子流不会重叠，从而为它们的统计独立性提供实际保证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem by implementing the algorithm derived from\n    first principles and running the specified test cases.\n    \"\"\"\n    # Parameters of the LCG from the problem statement\n    m = 2**48\n    a = 25214903917\n    c = 11\n    # For m=2**k, modulo can be done with a bitwise AND, which is faster.\n    mask = m - 1\n\n    def power_map(t: int, a_base: int, c_base: int, mod_mask: int):\n        \"\"\"\n        Computes the coefficients (A_t, C_t) of the composed affine map f^t,\n        where f^t(x) = (A_t * x + C_t) mod m, using binary exponentiation.\n\n        The composition of g(x)=a1*x+c1 and h(x)=a2*x+c2 is g(h(x)) = (a1*a2)*x + (a1*c2+c1).\n        The corresponding operation on coefficient pairs is (a1, c1) o (a2, c2) -> (a1*a2, a1*c2+c1).\n        \"\"\"\n        if t == 0:\n            # Identity map: x -> 1*x + 0\n            return 1, 0\n\n        # Accumulator for the final map, initialized to identity.\n        final_a, final_c = 1, 0\n\n        # Current power of the base map, starts with f^1 = (a, c).\n        current_a, current_c = a_base, c_base\n        \n        power = t\n        while power > 0:\n            if power % 2 == 1:\n                # Accumulate this power: final_map - current_map o final_map\n                final_a, final_c = (\n                    (current_a * final_a)  mod_mask,\n                    (current_a * final_c + current_c)  mod_mask\n                )\n\n            # Square the current power map: current_map - current_map o current_map\n            current_a, current_c = (\n                (current_a * current_a)  mod_mask,\n                (current_a * current_c + current_c)  mod_mask\n            )\n            \n            power //= 2\n        \n        return final_a, final_c\n\n    def skip_ahead(x_n: int, t: int):\n        \"\"\"\n        Computes x_{n+t} from x_n by finding the composed map f^t and applying it.\n        \"\"\"\n        if t == 0:\n            return x_n\n        \n        A_t, C_t = power_map(t, a, c, mask)\n        return (A_t * x_n + C_t)  mask\n    \n    def lcg_step(x: int):\n        \"\"\"Performs a single step of the LCG.\"\"\"\n        return (a * x + c)  mask\n\n    results = []\n\n    # Test 1: correctness against naive iteration\n    x_n_1, t_1 = 42, 1000\n    res_skip_1 = skip_ahead(x_n_1, t_1)\n    res_iter_1 = x_n_1\n    for _ in range(t_1):\n        res_iter_1 = lcg_step(res_iter_1)\n    results.append(res_skip_1 == res_iter_1)\n\n    # Test 2: identity boundary (t=0)\n    x_n_2, t_2 = 1234567890123, 0\n    res_2 = skip_ahead(x_n_2, t_2)\n    results.append(res_2)\n\n    # Test 3: single-step boundary (t=1)\n    x_n_3, t_3 = 1, 1\n    res_3 = skip_ahead(x_n_3, t_3)\n    results.append(res_3)\n\n    # Test 4: large skip from zero\n    x_n_4, t_4 = 0, 10**12\n    res_4 = skip_ahead(x_n_4, t_4)\n    results.append(res_4)\n\n    # Test 5: empirical substream independence in a window\n    S_5 = 10**12\n    L_5 = 1000\n    x0_5 = 1234567890123\n    \n    # Generate first substream\n    stream1 = []\n    current_x1 = x0_5\n    for _ in range(L_5):\n        stream1.append(current_x1)\n        current_x1 = lcg_step(current_x1)\n        \n    # Find start of second substream and generate it\n    x0_prime_5 = skip_ahead(x0_5, S_5)\n    stream2 = []\n    current_x2 = x0_prime_5\n    for _ in range(L_5):\n        stream2.append(current_x2)\n        current_x2 = lcg_step(current_x2)\n\n    # Check for disjointness using sets for efficiency\n    set1 = set(stream1)\n    set2 = set(stream2)\n    results.append(set1.isdisjoint(set2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3338260"}, {"introduction": "仅仅创建并行流是不够的；我们还必须验证它们的独立性。用于划分生成器序列的不同方法，如“跨步法”（leapfrogging）和“快速跳转法”（skip-ahead），对流的质量可能产生截然不同的影响。本练习将让您直接动手比较这两种方法。您将实现这两种技术，并使用流之间的经验协方差作为量化工具，以检测不希望出现的跨流相关性。这项实践（[@problem_id:3338230]）凸显了并非所有并行化策略都是等效的，并让您掌握一种诊断可能导致并行模拟失效的根本问题的方法。", "problem": "您的任务是使用线性同余生成器 (LCG) 对并行化伪随机数生成中的跨流相关性进行编程诊断。LCG 由递推关系\n$$\nx_{n+1} = (a x_n + c) \\bmod m,\n$$\n定义，其输出变换为\n$$\nU_n = \\frac{x_n}{m}。\n$$\n我们考虑从一个基础 LCG 创建并行流的两种标准方法。\n\n1. 蛙跳分割 (Leapfrog splitting)：对于固定数量的流 $P$，流 $i$（其中 $0 \\le i  P$）使用子序列 $\\{x_{i}, x_{i+P}, x_{i+2P}, \\dots\\}$，因此其第 $t$ 个输出为 $U^{(i)}_t = x_{i + t P}/m$。\n\n2. 跳跃播种 (Skip-ahead seeding)：对于固定的步长 $L$，流 $i$ 的种子设置为 $x_{iL}$，然后每次前进一个步长，因此其第 $t$ 个输出为 $U^{(i)}_t = x_{iL + t}/m$。\n\n我们采用以下基本定义。\n\n- 对于 $i \\ne j$ 的两个流 $(U^{(i)}_t)$ 和 $(U^{(j)}_t)$，其独立性与条件 $\\operatorname{Cov}(U^{(i)}_t, U^{(j)}_t) = 0$ 相容（对于每个固定的 $t$），假设它们分布相同且方差有限。\n- 对于两个长度为 $T$ 的有限序列 $(u_t)$ 和 $(v_t)$，其经验（无偏）协方差估计量为\n$$\n\\widehat{\\operatorname{Cov}}(u,v) = \\frac{1}{T-1}\\sum_{t=1}^{T} \\left(u_t - \\bar u\\right)\\left(v_t - \\bar v\\right),\n$$\n其中 $\\bar u = \\frac{1}{T}\\sum_{t=1}^{T} u_t$ 且 $\\bar v = \\frac{1}{T}\\sum_{t=1}^{T} v_t$。\n\n您的程序必须针对下面列出的每个测试用例，使用蛙跳分割和跳跃播种两种方法构建索引为 $i=0$ 和 $j=1$ 的两个流。对于每种方法，估计\n$$\n\\widehat{\\operatorname{Cov}}\\left((U^{(0)}_t)_{t=1}^T, (U^{(1)}_t)_{t=1}^T\\right),\n$$\n并将所得的协方差估计值报告为实数。\n\n实现约束与推导要求：\n\n- 您必须通过复合仿射映射来实现 LCG 的通用 $k$ 步跳跃。利用仿射更新 $x \\mapsto a x + c \\pmod m$ 的重复应用可以表示为单个仿射映射 $x \\mapsto a_k x + c_k \\pmod m$ 这一事实，其中\n$$\n\\begin{pmatrix}\na_k  c_k\\\\\n0  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\na  c\\\\\n0  1\n\\end{pmatrix}^{k}\n\\pmod m.\n$$\n您必须使用在模 $m$ 下的重复平方求幂来计算它，这样做是有效的，因为矩阵乘法复合了仿射映射，而重复平方求幂是在环下进行幂运算的经过充分测试的方法。\n\n- 对于具有 $P$ 个流的蛙跳分割，流 $i$ 必须从 $x_i$ 开始，然后重复应用上面推导出的 $P$ 步仿射映射。对于步长为 $L$ 的跳跃播种，流 $i$ 必须从 $x_{iL}$ 开始，然后重复应用 $1$ 步仿射映射。\n\n- 在浮点运算中通过 $U = x/m$ 将状态转换为均匀分布值。\n\n测试套件：\n\n对于每个测试用例，使用 $P=4$ 个流，并估计索引为 $i=0$ 和 $j=1$ 的两个流之间的协方差。使用长度 $T=200000$。对于基础 LCG，使用公共初始种子 $x_0 = 42$。\n\n- 测试用例 1（理想情况，使用素数模数的乘法 LCG）：\n  - $m = 2147483647$, $a = 16807$, $c = 0$\n  - 跳跃播种步长 $L = 10^7$\n\n- 测试用例 2（使用合数模数的混合 LCG）：\n  - $m = 2147483648$, $a = 1103515245$, $c = 12345$\n  - 跳跃播种步长 $L = 10^6$\n\n- 测试用例 3（使用 2 的幂次模数的全周期混合 LCG）：\n  - $m = 1048576$, $a = 5$, $c = 1$\n  - 跳跃播种步长 $L = 65536$\n\n程序要求：\n\n- 您的程序必须为每个测试用例计算两个值：\n  - 蛙跳分割下流 $i=0$ 和 $j=1$ 之间的经验协方差估计值。\n  - 跳跃播种下流 $i=0$ 和 $j=1$ 之间的经验协方差估计值。\n- 最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中包含六个浮点数，顺序完全如下：\n  - $[\\text{蛙跳_案例1}, \\text{跳跃播种_案例1}, \\text{蛙跳_案例2}, \\text{跳跃播种_案例2}, \\text{蛙跳_案例3}, \\text{跳跃播种_案例3}]$\n\n不涉及物理单位。不使用角度。不需要百分比；所有报告的值都是标准十进制形式的实数。", "solution": "该问题要求对线性同余生成器 (LCG) 的两种并行化策略的跨流相关性进行编程诊断。这两种策略是蛙跳分割和跳跃播种。该诊断通过估计前两个流（索引为 $i=0$ 和 $j=1$）之间的经验协方差来执行。\n\nLCG 的核心是递推关系：\n$$\nx_{n+1} = (a x_n + c) \\bmod m\n$$\n其中 $x_n$ 是第 $n$ 步的整数状态，$a$、$c$ 和 $m$ 分别是乘数、增量和模数。输出的均匀随机变量为 $U_n = x_n/m$。这个递推关系是模 $m$ 整数环上的一个仿射变换。\n\n要将生成器从 $x_n$ 前进到 $x_{n+k}$，即前进 $k$ 步，我们可以将此仿射映射自身复合 $k$ 次。这种复合对应于矩阵求幂。状态更新可以用齐次坐标写成：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ 1 \\end{pmatrix} \\pmod m\n$$\n将其迭代 $k$ 次得到：\n$$\n\\begin{pmatrix} x_{n+k} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^k \\begin{pmatrix} x_n \\\\ 1 \\end{pmatrix} \\pmod m\n$$\n令 $k$ 步转移矩阵为 $M_k = \\begin{pmatrix} a_k  c_k \\\\ 0  1 \\end{pmatrix}$，其中 $M_k = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^k \\pmod m$。那么 $k$ 步更新就是 $x_{n+k} = (a_k x_n + c_k) \\bmod m$。矩阵 $M_k$ 可以通过使用平方求幂法高效计算，在模 $m$ 下执行矩阵乘法。由于第二行始终是 $(0, 1)$，我们只需要计算对 $(a, c)$ 的变换。如果我们有两个这样的变换 $(a', c')$ 和 $(a'', c'')$，它们的复合是：\n$$\n(a', c') \\circ (a'', c'') = (a'a'' \\pmod m, (a'c'' + c') \\pmod m)\n$$\n这对应于它们相关矩阵的乘法。单位变换是 $(1, 0)$。\n\n对于每个测试用例，实现将按以下步骤进行，这些用例提供了参数 $(m, a, c, L)$ 并固定了 $P=4$、$T=200000$ 和 $x_0=42$。\n\n**1. 蛙跳分割**\n对于这种具有 $P$ 个流的方法，流 $i$ 由序列 $\\{x_i, x_{i+P}, x_{i+2P}, \\dots\\}$ 组成。问题要求我们必须比较流 $i=0$ 和 $j=1$。\n\n- 首先，我们通过计算 $M_P = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^P \\pmod m$ 来计算 $P$ 步仿射映射 $(a_P, c_P)$。在此问题中，$P=4$。\n- 流 0 的种子是 $x_0$。\n- 流 1 的种子是 $x_1 = (a x_0 + c) \\bmod m$。\n- 我们通过从 $s_0^{(0)} = x_0$ 开始并重复应用 $P$ 步变换来为流 0 生成一个长度为 $T$ 的状态序列：$s_{t+1}^{(0)} = (a_P s_t^{(0)} + c_P) \\bmod m$，其中 $t = 0, \\dots, T-2$。\n- 类似地，我们通过从 $s_0^{(1)} = x_1$ 开始并应用相同的 $P$ 步变换来为流 1 生成一个长度为 $T$ 的状态序列。\n- 这两个状态序列通过除以 $m$ 转换为均匀分布变量。\n\n**2. 跳跃播种**\n对于这种步长为 $L$ 的方法，流 $i$ 从状态 $x_{iL}$ 开始，并使用原始的 1 步 LCG 进行。我们比较流 $i=0$ 和 $j=1$。\n\n- 流 0 的种子是 $x_{0 \\cdot L} = x_0$。\n- 流 1 的种子是 $x_{1 \\cdot L} = x_L$。为了找到这个种子，我们通过计算 $M_L = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}^L \\pmod m$ 来计算 $L$ 步仿射映射 $(a_L, c_L)$。然后种子是 $x_L = (a_L x_0 + c_L) \\bmod m$。\n- 我们通过从 $s_0^{(0)} = x_0$ 开始并重复应用 1 步变换来为流 0 生成一个长度为 $T$ 的状态序列：$s_{t+1}^{(0)} = (a s_t^{(0)} + c) \\bmod m$，其中 $t = 0, \\dots, T-2$。\n- 我们通过从 $s_0^{(1)} = x_L$ 开始并应用相同的 1 步变换来为流 1 生成一个长度为 $T$ 的状态序列。\n- 这两个状态序列通过除以 $m$ 转换为均匀分布变量。\n\n**3. 协方差估计**\n对于这两种方法中的每一种，我们都得到两个长度为 $T$ 的均匀分布变量序列，我们可以表示为 $(u_t)_{t=1}^T$ 和 $(v_t)_{t=1}^T$。然后我们使用提供的公式计算经验无偏协方差：\n$$\n\\widehat{\\operatorname{Cov}}(u,v) = \\frac{1}{T-1}\\sum_{t=1}^{T} \\left(u_t - \\bar u\\right)\\left(v_t - \\bar v\\right)\n$$\n其中 $\\bar u$ 和 $\\bar v$ 分别是各自序列的样本均值。这将对生成的流进行数值计算。\n\n对所有三个测试用例重复此过程，并报告六个得出的协方差估计值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases: (m, a, c, L)\n    test_cases = [\n        (2147483647, 16807, 0, 10**7),\n        (2147483648, 1103515245, 12345, 10**6),\n        (1048576, 5, 1, 65536)\n    ]\n    \n    # Common parameters\n    P = 4\n    T = 200000\n    x0 = 42\n    \n    results = []\n    \n    for m, a, c, L in test_cases:\n        # --- Leapfrog Splitting ---\n        \n        # 1. Compute P-step affine map (a_P, c_P)\n        a_P, c_P = mat_pow((a, c), P, m)\n        \n        # 2. Determine initial seeds for stream 0 and 1\n        seed0_leap = x0\n        seed1_leap = (a * x0 + c) % m\n        \n        # 3. Generate streams\n        stream0_leap = generate_sequence(seed0_leap, T, a_P, c_P, m)\n        stream1_leap = generate_sequence(seed1_leap, T, a_P, c_P, m)\n        \n        # 4. Calculate covariance\n        cov_leapfrog = calculate_covariance(stream0_leap, stream1_leap)\n        results.append(cov_leapfrog)\n        \n        # --- Skip-ahead Seeding ---\n        \n        # 1. Compute L-step affine map to find seed for stream 1\n        a_L, c_L = mat_pow((a, c), L, m)\n        \n        # 2. Determine initial seeds for stream 0 and 1\n        seed0_skip = x0\n        seed1_skip = (a_L * x0 + c_L) % m\n        \n        # 3. Generate streams using 1-step map\n        stream0_skip = generate_sequence(seed0_skip, T, a, c, m)\n        stream1_skip = generate_sequence(seed1_skip, T, a, c, m)\n        \n        # 4. Calculate covariance\n        cov_skipahead = calculate_covariance(stream0_skip, stream1_skip)\n        results.append(cov_skipahead)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef mat_mul(A, B, m):\n    \"\"\"\n    Composes two LCG affine maps represented by (a, c) tuples.\n    This corresponds to multiplying their transformation matrices modulo m.\n    If A is (a1, c1) and B is (a2, c2), the composition is\n    (a1*a2, a1*c2 + c1) mod m.\n    \"\"\"\n    a1, c1 = A\n    a2, c2 = B\n    new_a = (a1 * a2) % m\n    new_c = (a1 * c2 + c1) % m\n    return (new_a, new_c)\n\ndef mat_pow(A, k, m):\n    \"\"\"\n    Computes A^k mod m for an affine map A=(a,c) using exponentiation by squaring.\n    \"\"\"\n    # Identity transformation is (1, 0)\n    res = (1, 0)\n    # The exponentiation by squaring algorithm\n    base = A\n    while k > 0:\n        if k % 2 == 1:\n            res = mat_mul(res, base, m)\n        base = mat_mul(base, base, m)\n        k //= 2\n    return res\n\ndef generate_sequence(seed, length, a, c, m):\n    \"\"\"\n    Generates a sequence of random variates from an LCG.\n    Returns a numpy array of uniform variates in [0, 1).\n    \"\"\"\n    states = np.empty(length, dtype=np.uint64)\n    current_state = seed\n    for i in range(length):\n        states[i] = current_state\n        current_state = (a * current_state + c) % m\n    \n    # Convert states to uniforms\n    return states / m\n\ndef calculate_covariance(u, v):\n    \"\"\"\n    Computes the unbiased sample covariance between two sequences u and v.\n    \"\"\"\n    # ddof=1 for unbiased estimator (N-1 in denominator)\n    # np.cov returns the covariance matrix. We need the off-diagonal element.\n    cov_matrix = np.cov(u, v, ddof=1)\n    return cov_matrix[0, 1]\n\nsolve()\n```", "id": "3338230"}]}