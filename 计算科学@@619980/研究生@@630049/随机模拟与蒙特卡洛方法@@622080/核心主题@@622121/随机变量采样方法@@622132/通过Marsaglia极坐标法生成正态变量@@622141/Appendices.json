{"hands_on_practices": [{"introduction": "Marsaglia 极坐标方法的核心是拒绝采样。在投入资源实现一个算法之前，评估其效率至关重要。此练习将指导你从基本原理出发，计算获得一个有效正态样本对所需的平均尝试次数及其方差，从而量化该方法的计算成本。[@problem_id:3324394]", "problem": "考虑用于生成独立标准正态变量的 Marsaglia 极坐标法的接受阶段。在每次抽样中，从正方形 $[-1,1] \\times [-1,1]$ 中均匀抽取一对 $(V_1,V_2)$，如果 $S = V_1^2 + V_2^2  1$，则该抽样被接受。抽样被独立地重复进行，直到首次接受发生。令 $N$ 为获得第一个被接受的对所需的总抽样次数。\n\n从连续均匀分布和平面（勒贝格）测度的定义出发，推导出单次抽样的接受概率 $p$。然后，使用几何分布（即直到首次成功所需的独立同分布伯努利试验次数）的定义，并且不调用预先计算好的均值或方差公式，推导出期望值 $\\mathbb{E}[N]$ 和方差 $\\operatorname{Var}(N)$ 的以 $\\pi$ 表示的闭式解析表达式。您的推导应从您根据第一性原理证明的级数恒等式出发。\n\n请以精确解析表达式的形式给出 $\\mathbb{E}[N]$ 和 $\\operatorname{Var}(N)$ 的最终答案。无需四舍五入，也不涉及任何单位。", "solution": "用户希望通过验证问题陈述来开始解决问题。\n\n### 步骤 1：提取已知条件\n- 一对随机变量 $(V_1, V_2)$ 在正方形 $[-1, 1] \\times [-1, 1]$ 上均匀抽取。\n- 如果 $S = V_1^2 + V_2^2  1$，则一次抽样被接受。\n- 抽样是独立的，并重复进行直到首次接受。\n- 随机变量 $N$ 是获得第一个被接受的对所需的总抽样次数。\n- 接受概率 $p$ 的推导必须从连续均匀分布和平面测度的定义开始。\n- 期望值 $\\mathbb{E}[N]$ 和方差 $\\operatorname{Var}(N)$ 的推导必须从第一性原理出发，使用经过证明的级数恒等式，而不是调用几何分布的预先计算好的均值或方差公式。\n- $\\mathbb{E}[N]$ 和 $\\operatorname{Var}(N)$ 的最终答案必须是用 $\\pi$ 表示的精确解析表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于成熟的 Marsaglia 极坐标法，这是计算统计学和蒙特卡罗方法领域的一个标准算法。所有前提在事实上都是正确的。\n- **适定性：** 问题陈述清晰，所有量都有明确定义。问题要求推导一个由清晰的概率过程定义的随机变量的特定统计性质。存在一个唯一、稳定且有意义的解。\n- **客观性：** 问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n- **完备性与一致性：** 问题是自洽的。它提供了推导所要求量所需的所有必要信息（抽样域、接受准则、随机变量 $N$ 的定义）。不存在矛盾。\n- **其他缺陷：** 该问题没有表现出任何其他缺陷，如不切实际、无法形式化、不适定、同义反复或无法验证。要求从第一性原理推导结果是一种标准的教学工具，用于检验对基本原理的理解。\n\n### 步骤 3：结论与行动\n问题是有效的。将按要求提供解答。\n\n### 解题推导\n\n根据要求，解答分为两部分：首先，推导接受概率 $p$；其次，从第一性原理推导期望 $\\mathbb{E}[N]$ 和方差 $\\operatorname{Var}(N)$。\n\n**第 1 部分：接受概率 $p$ 的推导**\n\n随机变量对 $(V_1, V_2)$ 从正方形区域 $\\mathcal{C} = [-1, 1] \\times [-1, 1]$ 上的连续均匀分布中抽取。这个正方形的面积，即一个平面勒贝格测度，由下式给出\n$$\n\\text{Area}(\\mathcal{C}) = (1 - (-1)) \\times (1 - (-1)) = 2 \\times 2 = 4\n$$\n根据区域上连续均匀分布的定义，其联合概率密度函数 (PDF) $f_{V_1, V_2}(v_1, v_2)$ 在该区域内为常数，在区域外为零。该常数的值是该区域面积的倒数。\n$$\nf_{V_1, V_2}(v_1, v_2) =\n\\begin{cases}\n\\frac{1}{\\text{Area}(\\mathcal{C})} = \\frac{1}{4}  \\text{if } (v_1, v_2) \\in \\mathcal{C} \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n如果抽取的对 $(V_1, V_2)$ 满足条件 $S = V_1^2 + V_2^2  1$，则该抽样被接受。这个条件定义了一个以原点 $(0,0)$ 为中心、半径为 $r=1$ 的开圆盘 $\\mathcal{D}$。接受概率 $p$ 是从正方形 $\\mathcal{C}$ 中均匀选择的一个点位于圆盘 $\\mathcal{D}$ 内的概率。该概率通过在接受区域 $\\mathcal{D}$ 上对联合 PDF 进行积分来计算。\n$$\np = P(V_1^2 + V_2^2  1) = \\iint_{\\mathcal{D}} f_{V_1, V_2}(v_1, v_2) \\, dv_1 \\, dv_2\n$$\n圆盘 $\\mathcal{D}$ 完全包含在正方形 $\\mathcal{C}$ 内（因为对于 $\\mathcal{D}$ 中的任意点 $(v_1,v_2)$，我们有 $v_1^2  1$ 和 $v_2^2  1$，这意味着 $|v_1|  1$ 和 $|v_2|  1$）。因此，在整个积分域 $\\mathcal{D}$ 上，PDF 恒为 $\\frac{1}{4}$。\n$$\np = \\iint_{\\mathcal{D}} \\frac{1}{4} \\, dv_1 \\, dv_2 = \\frac{1}{4} \\iint_{\\mathcal{D}} \\, dv_1 \\, dv_2\n$$\n积分 $\\iint_{\\mathcal{D}} \\, dv_1 \\, dv_2$ 就是圆盘 $\\mathcal{D}$ 的面积。半径为 $r=1$ 的圆盘面积为 $\\pi r^2 = \\pi(1)^2 = \\pi$。\n因此，接受概率是接受区域面积与抽样区域面积之比：\n$$\np = \\frac{\\text{Area}(\\mathcal{D})}{\\text{Area}(\\mathcal{C})} = \\frac{\\pi}{4}\n$$\n\n**第 2 部分：$\\mathbb{E}[N]$ 和 $\\operatorname{Var}(N)$ 的推导**\n\n随机变量 $N$ 表示为获得首次成功所需的独立同分布伯努利试验的次数。每次试验都是一次抽样，而“成功”就是一次被接受的抽样。任何单次试验的成功概率为 $p = \\frac{\\pi}{4}$。这为 $N$ 定义了一个几何分布。$N$ 的概率质量函数 (PMF) 由下式给出\n$$\nP(N=k) = (1-p)^{k-1}p \\quad \\text{for } k \\in \\{1, 2, 3, \\ldots\\}\n$$\n为方便起见，令 $q = 1-p$。则 PMF 为 $P(N=k) = q^{k-1}p$。\n\n为了从第一性原理推导期望和方差，我们依赖于几何级数及其导数的公式。对于任何实数 $|x|  1$，几何级数为\n$$\n\\sum_{k=0}^{\\infty} x^k = \\frac{1}{1-x}\n$$\n对 $x$ 求导（这对 $|x|1$ 有效）得到\n$$\n\\frac{d}{dx} \\sum_{k=0}^{\\infty} x^k = \\sum_{k=1}^{\\infty} kx^{k-1} = \\frac{d}{dx} (1-x)^{-1} = ( -1)(1-x)^{-2}(-1) = \\frac{1}{(1-x)^2}\n$$\n再次求导得到\n$$\n\\frac{d}{dx} \\sum_{k=1}^{\\infty} kx^{k-1} = \\sum_{k=2}^{\\infty} k(k-1)x^{k-2} = \\frac{d}{dx} (1-x)^{-2} = (-2)(1-x)^{-3}(-1) = \\frac{2}{(1-x)^3}\n$$\n\n**$\\mathbb{E}[N]$ 的推导**\n根据离散随机变量期望值的定义：\n$$\n\\mathbb{E}[N] = \\sum_{k=1}^{\\infty} k \\cdot P(N=k) = \\sum_{k=1}^{\\infty} k q^{k-1} p = p \\sum_{k=1}^{\\infty} k q^{k-1}\n$$\n由于 $p = \\frac{\\pi}{4}$，我们有 $0  p  1$，这意味着 $0  q  1$。我们可以使用上面推导出的关于 $x=q$ 的一阶导数恒等式：\n$$\n\\mathbb{E}[N] = p \\left( \\frac{1}{(1-q)^2} \\right)\n$$\n代入 $1-q = 1-(1-p) = p$，我们得到：\n$$\n\\mathbb{E}[N] = p \\left( \\frac{1}{p^2} \\right) = \\frac{1}{p}\n$$\n最后，代入 $p = \\frac{\\pi}{4}$：\n$$\n\\mathbb{E}[N] = \\frac{1}{\\pi/4} = \\frac{4}{\\pi}\n$$\n\n**$\\operatorname{Var}(N)$ 的推导**\n方差定义为 $\\operatorname{Var}(N) = \\mathbb{E}[N^2] - (\\mathbb{E}[N])^2$。我们首先需要计算 $\\mathbb{E}[N^2]$。\n$$\n\\mathbb{E}[N^2] = \\sum_{k=1}^{\\infty} k^2 \\cdot P(N=k) = \\sum_{k=1}^{\\infty} k^2 q^{k-1} p = p \\sum_{k=1}^{\\infty} k^2 q^{k-1}\n$$\n我们使用恒等式 $k^2 = k(k-1) + k$ 来分解这个和：\n$$\n\\sum_{k=1}^{\\infty} k^2 q^{k-1} = \\sum_{k=1}^{\\infty} (k(k-1) + k) q^{k-1} = \\sum_{k=1}^{\\infty} k(k-1)q^{k-1} + \\sum_{k=1}^{\\infty} k q^{k-1}\n$$\n当 $k=1$ 时，和中的第一项为零，因此更精确的形式是 $\\sum_{k=2}^{\\infty} k(k-1)q^{k-1}$。\n第二个和是我们为求期望时计算过的那个：$\\sum_{k=1}^{\\infty} k q^{k-1} = \\frac{1}{(1-q)^2} = \\frac{1}{p^2}$。\n对于第一个和，我们使用二阶导数恒等式。\n$$\n\\sum_{k=2}^{\\infty} k(k-1)q^{k-1} = q \\sum_{k=2}^{\\infty} k(k-1)q^{k-2}\n$$\n使用我们关于 $x=q$ 的恒等式：\n$$\n\\sum_{k=2}^{\\infty} k(k-1)q^{k-1} = q \\left( \\frac{2}{(1-q)^3} \\right) = \\frac{2q}{(1-q)^3} = \\frac{2q}{p^3}\n$$\n现在，我们可以组装出 $\\mathbb{E}[N^2]$ 的表达式：\n$$\n\\mathbb{E}[N^2] = p \\left( \\frac{2q}{p^3} + \\frac{1}{p^2} \\right) = \\frac{2q}{p^2} + \\frac{1}{p}\n$$\n现在，我们计算方差：\n$$\n\\operatorname{Var}(N) = \\mathbb{E}[N^2] - (\\mathbb{E}[N])^2 = \\left( \\frac{2q}{p^2} + \\frac{1}{p} \\right) - \\left( \\frac{1}{p} \\right)^2 = \\frac{2q}{p^2} + \\frac{1}{p} - \\frac{1}{p^2}\n$$\n$$\n\\operatorname{Var}(N) = \\frac{2q + p - 1}{p^2}\n$$\n代入 $q=1-p$：\n$$\n\\operatorname{Var}(N) = \\frac{2(1-p) + p - 1}{p^2} = \\frac{2 - 2p + p - 1}{p^2} = \\frac{1-p}{p^2}\n$$\n最后，代入 $p = \\frac{\\pi}{4}$：\n$$\n\\operatorname{Var}(N) = \\frac{1 - \\frac{\\pi}{4}}{(\\frac{\\pi}{4})^2} = \\frac{\\frac{4-\\pi}{4}}{\\frac{\\pi^2}{16}} = \\frac{4-\\pi}{4} \\cdot \\frac{16}{\\pi^2} = \\frac{4(4-\\pi)}{\\pi^2} = \\frac{16-4\\pi}{\\pi^2}\n$$\n所要求的期望值和方差的表达式已经从第一性原理推导得出。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{4}{\\pi}  \\frac{16-4\\pi}{\\pi^2} \\end{pmatrix}}\n$$", "id": "3324394"}, {"introduction": "实现一个随机数生成器只是第一步，更关键的是验证其输出是否符合预期的统计特性。这个实践练习要求你不仅要编写 Marsaglia 极坐标方法的代码，还要设计并执行一套全面的统计检验方案。通过这套方案，你将学会如何系统地验证生成器输出的独立同分布 $\\mathcal{N}(0,1)$ 特性。[@problem_id:3324448]", "problem": "您需要实现并验证一个使用 Marsaglia 极坐标法生成独立同分布标准正态变量的生成器。您的程序必须：(i) 实现一个转换，将独立的在 $\\left[-1,1\\right]$ 上的均匀分布输入转换为一对输出 $Z_1,Z_2$，这对输出声称是独立同分布的标准正态随机变量；(ii) 设计并应用一个统计验证方案，以评估输出是否确实是独立同分布的 $\\mathcal{N}(0,1)$；(iii) 按照指定的布尔值报告所有测试的结果。\n\n该统计验证方案必须基于原则，并根据以下基本事实和定义构建：\n- 随机数生成的接受-拒绝逻辑和变量变换原理。\n- 概率积分变换：如果 $X$ 具有连续累积分布函数 (CDF) $F_X$，则 $U = F_X(X)$ 在 $\\left[0,1\\right]$ 上是均匀分布的。\n- 在边缘分布为 $\\mathcal{N}(0,1)$ 且相互独立的假设下：\n  - 如果 $\\left\\{Z_i\\right\\}_{i=1}^n$ 是独立同分布的 $\\mathcal{N}(0,1)$ 变量，则样本均值 $\\bar{Z}$ 近似服从 $\\mathcal{N}\\left(0,1/n\\right)$ 分布，统计量 $(n-1)S^2$ 服从自由度为 $n-1$ 的卡方分布，其中 $S^2$ 是无偏样本方差。\n  - Kolmogorov–Smirnov (KS) 单样本拟合优度检验可以应用于 $\\left[0,1\\right]$ 上的均匀分布数据，以检验其均匀性假设。\n  - 对于两个独立的服从正态分布的边缘变量，其样本皮尔逊相关系数 $r$ 允许进行学生 $t$ 变换 $T = r\\sqrt{\\frac{n-2}{1-r^2}}$，在零相关的原假设下，该变换服从自由度为 $n-2$ 的学生 $t$ 分布。\n  - 分位数-分位数 (QQ) 图将排序后的样本值与理论分位数进行比较。在不绘图的情况下，可以通过对排序后的样本值 $Y$ 和目标分布的理论分位数 $Q$ 进行最小二乘拟合 $Y = a + bQ$ 来获得一个定量代理指标；对于正确的 $\\mathcal{N}(0,1)$ 数据，我们期望 $a \\approx 0$ 且 $b \\approx 1$。\n\n您必须对每个测试用例生成的样本实施以下测试：\n- 矩检验：\n  - 对于每个边缘分布，分别使用 $\\bar{Z}$ 的渐近正态参考，在水平 $\\alpha$ 下检验样本均值：如果 $|\\bar{Z}| \\le z_{1-\\alpha/2}/\\sqrt{n}$，则接受，其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。\n  - 对于每个边缘分布，分别使用卡方参考检验样本方差：如果 $\\chi^2_{\\,\\alpha/2,n-1}/(n-1) \\le S^2 \\le \\chi^2_{\\,1-\\alpha/2,n-1}/(n-1)$，则接受，其中 $\\chi^2_{\\,p,\\nu}$ 是自由度为 $\\nu$ 的卡方分布的 $p$ 分位数。\n  - 如果两个边缘分布的均值和方差检验都同时通过，则整体矩检验通过。\n- 通过概率积分变换对变换后的边缘分布进行拟合优度检验：\n  - 对于每个边缘变量 $Z$，计算 $U = \\Phi(Z)$，其中 $\\Phi$ 是 $\\mathcal{N}(0,1)$ 的累积分布函数 (CDF)，并对 $U$ 在水平 $\\alpha$ 下与 $\\left[0,1\\right]$ 上的均匀分布进行单样本 KS 检验。每个边缘分布都会产生一个单独的布尔值表示是否接受。\n- 分位数-分位数指标 (不绘图)：\n  - 对于每个边缘分布，计算在概率 $p_i = \\frac{i-0.5}{n}$ (其中 $i=1,\\dots,n$) 处的理论标准正态分位数 $\\left\\{q_i\\right\\}_{i=1}^n$，并令 $\\left\\{y_i\\right\\}_{i=1}^n$ 为排序后的样本值。拟合最小二乘直线 $y_i \\approx a + b q_i$。每个边缘分布声明两个独立的通过条件：如果 $|b-1| \\le \\delta_b$ 则斜率通过，如果 $|a| \\le \\delta_a$ 则截距通过。通过逻辑与（conjunction）聚合边缘分布的结果，即两个边缘分布都必须通过斜率标准，聚合的斜率通过才为真，截距标准同理。\n- 独立性检验：\n  - 从生成的 $n$ 对数据中计算 $Z_1$ 和 $Z_2$ 之间的样本皮尔逊相关系数 $r$，并使用统计量 $T = r\\sqrt{\\frac{n-2}{1-r^2}}$ 在水平 $\\alpha$ 下检验 $H_0: \\rho = 0$。拒绝域基于自由度为 $n-2$ 的学生 $t$ 分布，是双边的。如果 $|T| \\le t_{1-\\alpha/2,n-2}$，则接受，其中 $t_{1-\\alpha/2,\\nu}$ 是自由度为 $\\nu$ 的学生 $t$ 分布的 $(1-\\alpha/2)$ 分位数。\n\n提供并使用以下参数值测试套件：\n- 测试用例 1 (标称正确生成器)：$n = 50000$，种子 $= 20231119$，显著性水平 $\\alpha = 0.01$，QQ 斜率容差 $\\delta_b = 0.03$，QQ 截距容差 $\\delta_a = 0.03$。\n- 测试用例 2 (边缘分布均值有偏)：$n = 30000$，种子 $= 123$，显著性水平 $\\alpha = 0.01$，QQ 斜率容差 $\\delta_b = 0.03$，QQ 截距容差 $\\delta_a = 0.03$，生成后向两个边缘分布注入一个恒定的偏差 $\\mu = 0.08$，以产生与 $\\mathcal{N}(0,1)$ 的偏差。\n- 测试用例 3 (相关输出)：$n = 40000$，种子 $= 98765$，显著性水平 $\\alpha = 0.01$，QQ 斜率容差 $\\delta_b = 0.03$，QQ 截距容差 $\\delta_a = 0.03$，通过设置 $Z_2 = \\rho Z_1 + \\sqrt{1-\\rho^2}\\,W$ 来构造相关性 $\\rho = 0.2$，其中 $W$ 是一个独立的标准正态样本。\n\n您的程序必须：\n- 实现 Marsaglia 极坐标法，从 $\\left[-1,1\\right]$ 上的独立均匀分布输入中每次迭代生成候选对 $(Z_1,Z_2)$，标称输出流不使用任何现有的正态随机数生成器。\n- 对于测试用例 2，在生成后添加指定的偏差 $\\mu$。\n- 对于测试用例 3，如上生成 $Z_1$，然后按规定构成 $Z_2$ 以强制实现相关性 $\\rho$。\n- 对于每个测试用例，按以下固定顺序计算六个布尔值：\n  [矩检验通过，对变换后的 $Z_1$ 进行的 KS 检验通过，对变换后的 $Z_2$ 进行的 KS 检验通过，QQ 斜率聚合检验通过，QQ 截距聚合检验通过，独立性检验通过]。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身是按指定顺序排列的六个布尔值的列表。例如，包含三个测试用例的输出必须类似于 $[[b_{11},b_{12},b_{13},b_{14},b_{15},b_{16}],[b_{21},\\dots,b_{26}],[b_{31},\\dots,b_{36}]]$，其中包含字面布尔值。\n\n不涉及角度，也不涉及物理单位。所有概率必须表示为小数 (例如，$0.01$)，而不是百分号。", "solution": "该问题要求实现并统计验证用于生成独立同分布 (i.i.d.) 标准正态随机变量的 Marsaglia 极坐标法。解决方案包括两个主要部分：生成算法本身和一个全面的、基于原则的验证套件。\n\n### Marsaglia 极坐标法\n\nMarsaglia 极坐标法是一种算法，它将一对在区间 $[-1, 1]$ 上均匀分布的独立随机变量转换为一对独立标准正态随机变量。它是 Box-Muller 变换的一种改进，避免了使用计算成本高昂的三角函数。\n\n该算法流程如下：\n1. 从 $[-1, 1]$ 上的均匀分布中生成两个独立的随机变量 $U_1$ 和 $U_2$。这可以看作是位于以原点为中心、边长为 $2$ 的正方形内一个随机点的坐标。\n2. 计算 $S = U_1^2 + U_2^2$。这是点 $(U_1, U_2)$ 到原点的距离的平方。\n3. 应用接受-拒绝步骤：如果 $S \\ge 1$ 或 $S = 0$，则点 $(U_1, U_2)$ 位于单位圆盘的外部或恰好在圆心。在这种情况下，该点对被拒绝，算法返回到步骤 1。否则，该点被接受。此过程确保我们从单位圆盘的内部（不包括原点）进行均匀采样。在任何一次试验中，接受的概率是单位圆盘的面积 ($\\pi$) 与正方形的面积 ($4$) 之比，即 $\\pi/4$。\n4. 如果点对 $(U_1, U_2)$ 被接受，则应用变换生成两个独立的标准正态变量 $Z_1$ 和 $Z_2$：\n$$ Z_1 = U_1 \\sqrt{\\frac{-2 \\ln S}{S}} $$\n$$ Z_2 = U_2 \\sqrt{\\frac{-2 \\ln S}{S}} $$\n\n此变换的有效性基于概率论中的变量变换定理。当 $(U_1, U_2)$ 在单位圆盘上均匀分布时，其半径的平方 $S$ 在 $[0,1]$ 上均匀分布。变换 $R = \\sqrt{-2 \\ln S}$ 产生一个服从瑞利分布的随机变量，这是二维标准正态向量模长的典型特征。通过将原始的均匀分量 $U_1$ 和 $U_2$ 乘以因子 $\\sqrt{-2 \\ln S / S}$，可以证明得到的 $(Z_1, Z_2)$ 服从相关系数为零的二元标准正态分布，而对于正态分布而言，零相关即意味着独立。\n\n### 统计验证方案\n\n为了验证生成的样本 $\\{ (Z_{1,i}, Z_{2,i}) \\}_{i=1}^n$ 确实是从 $\\mathcal{N}(0,1)$ 中抽取的独立同分布样本，需要进行一系列统计检验。这些检验对照原假设 ($H_0$)（即样本遵循目标分布）来审视样本数据的不同属性。显著性水平 $\\alpha$ 用于控制第一类错误（错误地拒绝了真实的原假设 $H_0$）的概率。\n\n1.  **矩检验**：该检验验证样本数据的前两个矩（均值和方差）是否与标准正态分布的理论值（即 $\\mu=0$ 和 $\\sigma^2=1$）一致。\n    - **均值检验**：根据中心极限定理，对于大样本量 $n$，样本均值 $\\bar{Z}$ 近似服从 $\\mathcal{N}(0, 1/n)$ 分布。如果观察到的样本均值与 0 没有统计学上的显著差异，则检验接受 $H_0$。条件是 $|\\bar{Z}| \\le z_{1-\\alpha/2} / \\sqrt{n}$，其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。此检验对两个边缘分布 $Z_1$ 和 $Z_2$ 分别执行。\n    - **方差检验**：对于从正态分布中抽取的样本，统计量 $(n-1)S^2/\\sigma^2$ 服从自由度为 $n-1$ 的卡方分布。在 $H_0$ 下，$\\sigma^2=1$，因此我们检验样本方差 $S^2$ 是否落在区间 $[\\frac{\\chi^2_{\\alpha/2, n-1}}{n-1}, \\frac{\\chi^2_{1-\\alpha/2, n-1}}{n-1}]$ 内，其中 $\\chi^2_{p, \\nu}$ 是自由度为 $\\nu$ 的卡方分布的 $p$-分位数。此检验也对两个边缘分布分别执行。\n    - 只有当所有四个独立检验（$Z_1$ 和 $Z_2$ 的均值和方差）都通过时，整体矩检验才算通过。\n\n2.  **拟合优度检验 (Kolmogorov-Smirnov 检验)**：该检验评估边缘分布的整体形状。它利用了概率积分变换 (PIT)，该变换指出，如果一个随机变量 $Z$ 具有连续累积分布函数 (CDF) $F_Z$，那么变量 $U = F_Z(Z)$ 在 $[0, 1]$ 上均匀分布。\n    - 对于每个边缘样本 $\\{Z_i\\}$，我们计算变换后的样本 $\\{U_i = \\Phi(Z_i)\\}$，其中 $\\Phi$ 是 $\\mathcal{N}(0,1)$ 分布的 CDF。\n    - 然后使用单样本 Kolmogorov-Smirnov (KS) 检验将 $\\{U_i\\}$ 的经验分布与 $[0,1]$ 上的理论均匀分布进行比较。如果检验的 p-value 大于或等于显著性水平 $\\alpha$，则接受 $H_0$。这为每个边缘分布 $Z_1$ 和 $Z_2$ 产生一个单独的布尔结果。\n\n3.  **分位数-分位数 (QQ) 指标**：这提供了一个定量评估，衡量样本分位数与标准正态分布的理论分位数匹配的程度，该方法对分布尾部的偏差尤为敏感。\n    - 将排序后的样本值 $\\{y_i\\}_{i=1}^n$ 与 $\\mathcal{N}(0,1)$ 分布的理论分位数 $\\{q_i\\}_{i=1}^n$ 进行回归。理论分位数在概率 $p_i = (i - 0.5)/n$（其中 $i=1, \\dots, n$）处计算。\n    - 使用普通最小二乘法拟合线性模型 $y_i \\approx a + b q_i$。对于真正服从 $\\mathcal{N}(0,1)$ 的数据，我们期望截距 $a \\approx 0$ 且斜率 $b \\approx 1$。\n    - 如果 $|a| \\le \\delta_a$ 且 $|b-1| \\le \\delta_b$，则检验通过，其中 $\\delta_a$ 和 $\\delta_b$ 是预定义的小容差。最终输出提供两个聚合的布尔值：一个用于斜率检验（仅当两个边缘分布都通过时才通过），另一个用于截距检验（仅当两个边缘分布都通过时才通过）。\n\n4.  **独立性检验**：该检验验证生成的变量 $Z_1$ 和 $Z_2$ 具有独立性这一关键属性。对于二元正态变量，独立性等价于零相关。\n    - 计算 $n$ 对 $(Z_{1,i}, Z_{2,i})$ 的样本皮尔逊相关系数 $r$。\n    - 在总体相关系数为零的原假设 ($\\rho=0$) 下，检验统计量 $T = r \\sqrt{\\frac{n-2}{1-r^2}}$ 服从自由度为 $n-2$ 的学生 $t$ 分布。\n    - 如果观察到的统计量的绝对值 $|T|$ 不超过临界值 $t_{1-\\alpha/2, n-2}$（即指定的 $t$ 分布的 $(1-\\alpha/2)$-分位数），则接受 $H_0$。\n\n通过结合这些检验，该验证方案为生成器的输出质量提供了稳健的评估，检查了正确的矩、正确的分布形状和独立性。测试用例旨在探究此方案的敏感性：测试用例 1 应通过所有检验，测试用例 2 应在与均值和分布形状相关的检验中失败，而测试用例 3 应在独立性检验中失败，但通过边缘分布检验。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, chi2, t, kstest, linregress, pearsonr\n\ndef marsaglia_generator(rng: np.random.Generator, n_pairs: int):\n    \"\"\"\n    Generates n_pairs of standard normal variates using the Marsaglia polar method.\n    \"\"\"\n    z_pairs = []\n    generated_count = 0\n    while generated_count  n_pairs:\n        # Generate candidates in batches for efficiency\n        # Acceptance rate is pi/4, so we need slightly more than n_pairs candidates\n        batch_size = int((n_pairs - generated_count) / (np.pi / 4.0) * 1.1) + 10\n        u1 = rng.uniform(-1, 1, size=batch_size)\n        u2 = rng.uniform(-1, 1, size=batch_size)\n        s = u1**2 + u2**2\n        \n        # Acceptance mask\n        mask = (s  1)  (s > 0)\n        \n        s_accepted = s[mask]\n        u1_accepted = u1[mask]\n        u2_accepted = u2[mask]\n        \n        factor = np.sqrt(-2 * np.log(s_accepted) / s_accepted)\n        \n        z1 = u1_accepted * factor\n        z2 = u2_accepted * factor\n        \n        for i in range(len(z1)):\n            if generated_count  n_pairs:\n                z_pairs.append((z1[i], z2[i]))\n                generated_count += 1\n            else:\n                break\n                \n    return np.array(z_pairs)\n\ndef run_validation_suite(z1, z2, n, alpha, delta_b, delta_a):\n    \"\"\"\n    Runs the full statistical validation suite on the generated samples.\n    \"\"\"\n    results = []\n\n    # 1. Moment Checks\n    mean1, mean2 = np.mean(z1), np.mean(z2)\n    var1, var2 = np.var(z1, ddof=1), np.var(z2, ddof=1)\n    \n    z_crit = norm.ppf(1 - alpha / 2)\n    mean_thresh = z_crit / np.sqrt(n)\n    mean1_pass = abs(mean1) = mean_thresh\n    mean2_pass = abs(mean2) = mean_thresh\n    \n    df = n - 1\n    chi2_lower_crit = chi2.ppf(alpha / 2, df)\n    chi2_upper_crit = chi2.ppf(1 - alpha / 2, df)\n    var_lower_thresh = chi2_lower_crit / df\n    var_upper_thresh = chi2_upper_crit / df\n    var1_pass = var_lower_thresh = var1 = var_upper_thresh\n    var2_pass = var_lower_thresh = var2 = var_upper_thresh\n\n    moment_pass = all([mean1_pass, mean2_pass, var1_pass, var2_pass])\n    results.append(moment_pass)\n    \n    # 2. Goodness-of-Fit (KS Test on PIT)\n    u1 = norm.cdf(z1)\n    u2 = norm.cdf(z2)\n    \n    ks_stat1, p_val1 = kstest(u1, 'uniform')\n    ks_stat2, p_val2 = kstest(u2, 'uniform')\n    \n    ks1_pass = p_val1 >= alpha\n    ks2_pass = p_val2 >= alpha\n    results.extend([ks1_pass, ks2_pass])\n\n    # 3. Quantile-Quantile Metrics\n    p_quantiles = (np.arange(1, n + 1) - 0.5) / n\n    theoretical_quantiles = norm.ppf(p_quantiles)\n    \n    y1_sorted = np.sort(z1)\n    y2_sorted = np.sort(z2)\n    \n    reg1 = linregress(theoretical_quantiles, y1_sorted)\n    reg2 = linregress(theoretical_quantiles, y2_sorted)\n    \n    slope1_pass = abs(reg1.slope - 1) = delta_b\n    slope2_pass = abs(reg2.slope - 1) = delta_b\n    \n    intercept1_pass = abs(reg1.intercept) = delta_a\n    intercept2_pass = abs(reg2.intercept) = delta_a\n\n    qq_slope_pass = slope1_pass and slope2_pass\n    qq_intercept_pass = intercept1_pass and intercept2_pass\n    results.extend([qq_slope_pass, qq_intercept_pass])\n\n    # 4. Independence Check\n    r, p_val_corr = pearsonr(z1, z2)\n    \n    # Handle perfect correlation case to avoid division by zero\n    if abs(r) == 1.0:\n        t_stat = np.inf if r != 0 else 0\n    else:\n        t_stat = r * np.sqrt((n - 2) / (1 - r**2))\n    \n    t_crit = t.ppf(1 - alpha / 2, n - 2)\n    independence_pass = abs(t_stat) = t_crit\n    results.append(independence_pass)\n\n    return [bool(res) for res in results]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'name': 'nominal', 'n': 50000, 'seed': 20231119, 'alpha': 0.01, 'delta_b': 0.03, 'delta_a': 0.03, 'params': {}},\n        {'name': 'biased', 'n': 30000, 'seed': 123, 'alpha': 0.01, 'delta_b': 0.03, 'delta_a': 0.03, 'params': {'mu': 0.08}},\n        {'name': 'correlated', 'n': 40000, 'seed': 98765, 'alpha': 0.01, 'delta_b': 0.03, 'delta_a': 0.03, 'params': {'rho': 0.2}},\n    ]\n\n    results = []\n    for case in test_cases:\n        rng = np.random.default_rng(case['seed'])\n        n = case['n']\n        \n        if case['name'] == 'nominal':\n            pairs = marsaglia_generator(rng, n)\n            z1, z2 = pairs[:, 0], pairs[:, 1]\n        elif case['name'] == 'biased':\n            pairs = marsaglia_generator(rng, n)\n            mu = case['params']['mu']\n            z1 = pairs[:, 0] + mu\n            z2 = pairs[:, 1] + mu\n        elif case['name'] == 'correlated':\n            # Generate n pairs (A, B) to serve as (Z1, W)\n            base_pairs = marsaglia_generator(rng, n)\n            z1_base = base_pairs[:, 0]\n            w = base_pairs[:, 1]\n            rho = case['params']['rho']\n            \n            z1 = z1_base\n            z2 = rho * z1 + np.sqrt(1 - rho**2) * w\n        \n        case_results = run_validation_suite(z1, z2, n, case['alpha'], case['delta_b'], case['delta_a'])\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3324448"}, {"introduction": "一个随机数生成算法的质量上限取决于其输入源的质量，这正是“垃圾进，垃圾出”原则的体现。此练习将深入探讨当底层的均匀分布随机数生成器存在缺陷时，这些缺陷如何通过 Marsaglia 方法传播并污染最终的正态分布输出。你将学习设计和应用高级诊断工具来检测这些隐藏的相关性，从而培养对蒙特卡洛模拟中潜在错误的批判性意识。[@problem_id:3324468]", "problem": "您的任务是研究依赖性如何从一个均匀随机输入序列通过用于生成正态变量的Marsaglia极坐标法进行传播，并设计和实现能够检测最终生成的正态对输出中所产生的相关性的诊断程序。实现必须是一个完整的、可运行的程序，并产生单行输出。\n\n从以下基础概念开始：\n\n- 一对独立同分布（i.i.d.）的标准正态随机变量 $(Z_1,Z_2)$ 的联合概率密度函数（PDF）为 $f(z_1,z_2) = \\frac{1}{2\\pi}\\exp\\!\\left(-\\frac{z_1^2+z_2^2}{2}\\right)$，其半径的平方 $R^2 = Z_1^2 + Z_2^2$ 服从自由度为 $2$ 的卡方分布，这等价于均值为 $2$ 的指数分布。在极坐标中，角度 $\\Theta = \\operatorname{atan2}(Z_2,Z_1)$ 在 $[-\\pi,\\pi)$ 上均匀分布，且与 $R$ 独立。\n- Marsaglia极坐标法是一种接受-拒绝方法，它将一对在 $[-1,1]$ 上的独立均匀变量转换为一对标准正态变量。该方法首先从单位圆盘内均匀接受点，然后应用适当的径向缩放，使得结果的分布与 $(Z_1,Z_2)$ 的分布相匹配。您必须实现标准的接受-拒绝映射以产生正确的正态分布，但不得假定任何超出输入序列所蕴含的虚假独立性。\n- 线性同余生成器（LCG）由递推关系 $X_{n+1} = (a X_n + c) \\bmod m$ 定义，其中包含整数模数 $m$、乘数 $a$、增量 $c$ 和种子 $X_0$。生成的均匀数为 $U_n = X_n / m \\in [0,1)$。\n- 随机变量中的依赖性在可测映射下得以保留：如果 $(U_1,U_2,U_3,\\dots)$ 是一个相依序列，而 $T$ 是一个确定性变换，那么 $(T(U_1,U_2),T(U_3,U_4),\\dots)$ 通常仍然是相依的。基于输入函数的接受-拒绝法也可能与输入依赖性相互作用，从而可能产生复杂的选择偏差。\n\n需要完成的任务：\n\n1. 实现Marsaglia极坐标法，该方法消耗一个在 $[-1,1]^2$ 上均匀分布的 $(V_1,V_2)$ 对的流，拒绝任何满足 $S = V_1^2 + V_2^2 \\ge 1$ 或 $S=0$ 的对，并使用能够产生 $(Z_1,Z_2)$ 正确分布的确定性缩放，将接受的对变换为标准正态对 $(Z_1,Z_2)$。您的实现不得假定独立性，除非输入生成器能保证这一点。\n2. 实现具有以下配置的均匀序列源：\n   - 使用现代数值库提供的置换同余生成器（PCG）作为独立基准。由此生成在 $[0,1)$ 上的独立同分布均匀数，并组成独立的对。\n   - 一个使用参数 $m=2^{31}$、$a=65539$、$c=0$（通常称为RANDU）的劣质线性同余生成器（LCG），以生成单个均匀流 $U_n$，并组成连续的对 $(U_{2k},U_{2k+1})$。\n   - 一种退化配对，通过为每个对设置 $U_{2k+1}=U_{2k}$ 来强制在每个候选对内产生完美相关，其中 $U_{2k}$ 使用相同的底层LCG流。\n3. 提出并实现诊断方法，以检测由Marsaglia极坐标法产生的 $(Z_1,Z_2)$ 中的诱导相关性或结构偏差：\n   - 对内Pearson相关性 $\\hat\\rho = \\operatorname{Corr}(Z_1,Z_2)$。\n   - 角度均匀性检验：计算 $\\Theta = \\operatorname{atan2}(Z_2,Z_1) \\in (-\\pi,\\pi]$，将其重新缩放到 $W = (\\Theta + \\pi)/(2\\pi) \\in [0,1)$，并对 $[0,1)$ 上的均匀分布执行单样本Kolmogorov–Smirnov（K-S）检验；报告其 $p$ 值。\n   - 扁平化输出序列 $Y = (Z_1^{(1)}, Z_2^{(1)}, Z_1^{(2)}, Z_2^{(2)}, \\dots)$ 的一阶自相关，定义为 $\\hat\\rho_1 = \\frac{\\sum_{t=1}^{N-1} (Y_t - \\bar Y)(Y_{t+1}-\\bar Y)}{\\sum_{t=1}^{N} (Y_t - \\bar Y)^2}$，其中 $N$ 是 $Y$ 的总长度。\n   - 基于标准正态边缘分布的分位数分箱，使用 $b \\times b$ 网格（$b=6$）进行卡方独立性检验：在由标准正态分布在概率 $i/b$（$i=0,1,\\dots,b$）处的分位数定义的网格上计算单元格计数，并计算卡方统计量 $\\sum_{i,j} \\frac{(O_{ij}-E_{ij})^2}{E_{ij}}$，自由度为 $(b-1)(b-1)$，其中 $E_{ij}$ 是根据边缘分布形成的独立性假设下的期望计数；报告其 $p$ 值。\n4. 为保证可复现性，请使用以下测试套件。每个案例指定了生成器配置、一个种子以及要生成的输出对的数量：\n   - 案例 A（独立基准）：PCG 种子 $= 20231011$，输出对数量 $= 40000$。\n   - 案例 B（LCG RANDU 连续对）：参数 $m=2^{31}$、$a=65539$、$c=0$，种子 $=1$，输出对数量 $= 40000$。\n   - 案例 C（退化等值对映射）：与案例 B 相同的 RANDU 参数，但在候选对中强制 $U_{2k+1}=U_{2k}$，种子 $=1$，输出对数量 $= 40000$。\n   - 案例 D（小样本独立合理性检查）：PCG 种子 $= 42$，输出对数量 $= 500$。\n5. 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[\\hat\\rho, p_{\\text{angle}}, \\hat\\rho_1, p_{\\chi^2}]$ 顺序的列表，因此最终输出是按A、B、C、D案例顺序排列的四个列表的列表，例如 $[[r_{A},p_{A},a_{A},q_{A}],[r_{B},p_{B},a_{B},q_{B}],[r_{C},p_{C},a_{C},q_{C}],[r_{D},p_{D},a_{D},q_{D}]]$。", "solution": "该问题要求研究输入序列的依赖性对用于生成标准正态随机变量的Marsaglia极坐标法输出结果的影响。为实现这一目标，需要实现该方法，从不同质量的随机数生成器中获取输入，并对输出应用一套统计诊断方法。\n\n该问题在科学上和数学上是适定的。它基于随机数生成和统计检验的既有理论。所有参数、算法和测试用例都得到了明确的规定，从而能够得到唯一且可验证的解。所选择的测试用例——一个高质量生成器、一个臭名昭著的劣质生成器和一个病态相关的生成器——为展示缺陷如何通过非线性变换传播提供了一个稳健的框架。\n\n**1. Marsaglia极坐标法的理论基础**\n\nMarsaglia极坐标法通过变换一对从单位圆盘内部均匀选取的随机变量 $(V_1, V_2)$，来生成一对独立的标准正态随机变量 $(Z_1, Z_2)$。一对独立同分布的标准正态变量的联合概率密度函数（PDF）在笛卡尔坐标系下由 $f(z_1, z_2) = \\frac{1}{2\\pi} e^{-(z_1^2 + z_2^2)/2}$ 给出。在极坐标系中，其中 $z_1 = r \\cos\\theta$ 且 $z_2 = r \\sin\\theta$，半径的平方 $R^2 = Z_1^2 + Z_2^2$ 服从均值为 $2$ 的指数分布（即自由度为 $2$ 的卡方分布），而角度 $\\Theta = \\operatorname{atan2}(Z_2, Z_1)$ 在 $[-\\pi, \\pi)$ 上均匀分布，且与 $R$ 独立。\n\n该方法按以下步骤进行：\n1. 生成一对在 $[0,1)$ 上的独立均匀变量 $(U_1, U_2)$。\n2. 将它们变换到在 $[-1,1]$ 上均匀分布：$V_1 = 2U_1 - 1$ 和 $V_2 = 2U_2 - 1$。对 $(V_1, V_2)$ 在正方形 $[-1,1]^2$ 上均匀分布。\n3. 计算 $S = V_1^2 + V_2^2$。\n4. 如果 $S=0$ 或 $S \\ge 1$，则拒绝该对并返回步骤 1。否则，接受。被接受的对 $(V_1, V_2)$ 在单位圆盘内部均匀分布。\n5. 如果我们将接受的点用极坐标表示，$V_1 = \\tilde{R} \\cos\\Phi$ 和 $V_2 = \\tilde{R} \\sin\\Phi$，那么角度 $\\Phi$ 在 $[0, 2\\pi)$ 上均匀分布，而半径的平方 $S = \\tilde{R}^2$ 在 $(0,1)$ 上均匀分布。该方法的核心是将这个平方半径 $S$ 变换为一个具有正确指数分布的新平方半径 $R^2$。所需的变换是 $R^2 = -2 \\ln S$。由于 $S \\sim U(0,1)$，变量 $Y = -2 \\ln S$ 的累积分布函数（CDF）为 $P(Y \\le y) = P(-2 \\ln S \\le y) = P(\\ln S \\ge -y/2) = P(S \\ge e^{-y/2}) = 1 - e^{-y/2}$，对于 $y0$。这是均值为 $2$ 的指数分布的CDF。\n6. 最终的标准正态变量是通过一个因子缩放原始坐标 $(V_1, V_2)$ 构建的，该因子将其半径替换为新生成的半径。新半径是 $R = \\sqrt{-2\\ln S}$。原始半径是 $\\tilde{R} = \\sqrt{S}$。缩放因子是 $R/\\tilde{R} = \\sqrt{-2\\ln S / S}$。\n    $$ Z_1 = V_1 \\cdot \\sqrt{\\frac{-2 \\ln S}{S}} $$\n    $$ Z_2 = V_2 \\cdot \\sqrt{\\frac{-2 \\ln S}{S}} $$\n    得到的对 $(Z_1, Z_2)$ 的角度与 $(V_1, V_2)$ 的角度相同，后者是均匀的。因此，只要输入均匀变量 $(U_1, U_2)$ 是独立同分布的，$(Z_1,Z_2)$ 就是一对独立同分布的标准正态变量。\n\n**2. 输入序列生成器**\n\n该问题指定了三种用于初始均匀序列的源，它们被设计为具有不同的依赖结构。\n\n-   **独立基准（PCG）：** 使用一个现代的、高质量的置换同余生成器（PCG）。它以其卓越的统计特性而闻名，其产生的变量流 $(U_0, U_1, U_2, \\dots)$ 在所有实际应用中都是在 $[0,1)$ 上独立同分布的均匀变量。配对形成为 $(U_{2k}, U_{2k+1})$。\n-   **劣质LCG（RANDU）：** 一种由递推关系 $X_{n+1} = (a X_n + c) \\pmod m$ 定义的线性同余生成器，参数为 $a=65539$，$c=0$ 和 $m=2^{31}$。均匀数为 $U_n = X_n / m$。该生成器因其连续值之间的强相关性而臭名昭著。例如，三元组 $(U_i, U_{i+1}, U_{i+2})$ 落在少数几个平面上。我们将其形成为对 $(U_{2k}, U_{2k+1})$，这将继承这种依赖性。\n-   **退化配对：** 这使用相同的RANDU生成器，但通过设置 $U_{2k+1} = U_{2k}$ 来强制在候选对内产生完美相关。因此，输入到Marsaglia方法的对的形式为 $(v,v)$，其中 $v = 2U_{2k}-1$。\n\n**3. 统计诊断**\n\n为了量化输出的正态对 $(Z_1^{(i)}, Z_2^{(i)})$ 的质量，实现了四种诊断检验。\n\n-   **对内Pearson相关性 ($\\hat\\rho$)：** 该指标衡量在每个生成的对中 $Z_1$ 和 $Z_2$ 之间的线性相关性。对于真正独立的标准正态变量，理论相关性为 $0$。\n-   **角度均匀性（K-S检验）：** 角度 $\\Theta_i = \\operatorname{atan2}(Z_2^{(i)}, Z_1^{(i)})$ 应在 $(-\\pi, \\pi]$ 上均匀分布。我们将角度重新缩放到 $W_i = (\\Theta_i + \\pi) / (2\\pi)$，使其位于 $[0,1)$，并对标准均匀分布执行单样本Kolmogorov-Smirnov（K-S）检验。得到的p值表示在基础分布为均匀分布的情况下观测到给定样本的可能性；一个小的p值表明非均匀性。\n-   **一阶自相关 ($\\hat\\rho_1$)：** 这用于检验扁平化输出序列 $Y = (Z_1^{(1)}, Z_2^{(1)}, Z_1^{(2)}, Z_2^{(2)}, \\dots)$ 中连续值之间的相关性。它对对内相关（例如，$Z_1^{(1)}$ 和 $Z_2^{(1)}$ 之间）和对间相关（例如，$Z_2^{(1)}$ 和 $Z_1^{(2)}$ 之间）都很敏感。该统计量计算为 $\\hat\\rho_1 = \\frac{\\sum_{t=1}^{N-1} (Y_t - \\bar Y)(Y_{t+1}-\\bar Y)}{\\sum_{t=1}^{N} (Y_t - \\bar Y)^2}$，其中 $N$ 是 $Y$ 的总长度。\n-   **卡方独立性检验 ($p_{\\chi^2}$):** 这是一种用于检验 $Z_1$ 和 $Z_2$ 之间独立性的非参数检验。联合样本空间被划分为一个 $b \\times b$ 的网格，其中 $b=6$。分箱边界由标准正态分布的分位数定义，使得每个边缘分箱的期望概率为 $1/b$。卡方统计量 $\\chi^2 = \\sum_{i,j} \\frac{(O_{ij}-E_{ij})^2}{E_{ij}}$ 比较每个单元格 $(i,j)$ 中的观测计数 $O_{ij}$ 与在独立性零假设下的期望计数 $E_{ij}$。一个大的 $\\chi^2$ 值（以及相应的小p值）表明与独立性存在显著偏差。自由度为 $(b-1)^2 = 25$。\n\n**4. 测试用例分析**\n\n-   **案例 A (PCG, $N=40000$)：** 作为基准，预计所有测试都将通过。$\\hat\\rho$ 和 $\\hat\\rho_1$ 应接近 $0$，K-S检验和 $\\chi^2$ 检验的p值应较高（例如 $ 0.05$），表明与独立同分布正态变量的理想属性没有统计上显著的偏差。\n-   **案例 B (RANDU, $N=40000$)：** 预计RANDU的已知缺陷会传播开来。非线性的接受-拒绝步骤和变换可能会掩盖或放大这些缺陷。我们预期至少有一个诊断会检测到统计上显著的异常，很可能是非零的 $\\hat\\rho_1$ 和 $\\chi^2$ 检验的低p值。\n-   **案例 C (退化, $N=40000$)：** 此案例作为一个阳性对照。由于 $V_1=V_2$，因此 $Z_1=Z_2$。因此，我们预期 $\\hat\\rho$ 将精确为 $1$。角度将聚集在 $\\pi/4$ 和 $-3\\pi/4$，导致K-S检验的p值极小。$\\chi^2$ 检验将显示所有数据都在对角线上，导致p值实际上为 $0$。一阶自相关 $\\hat\\rho_1$ 也将是大的正值。\n-   **案例 D (PCG, $N=500$)：** 这是一个小样本量的合理性检查。我们预期结果与案例A相似，但具有更大的统计方差。例如，估计的相关性可能离 $0$ 更远，p值可能由于抽样变异性而较低，但它们通常不应表明强烈拒绝零假设。\n\n实现将遵循这些原则，为每个案例生成随机变量并计算指定的四种诊断统计数据。", "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and diagnostics for all test cases.\n    \"\"\"\n\n    def lcg_randu_stream(seed):\n        \"\"\"Generator for the RANDU LCG.\"\"\"\n        m = 2**31\n        a = 65539\n        c = 0\n        x = seed\n        while True:\n            x = (a * x + c) % m\n            yield x / m\n\n    def pcg_stream(seed):\n        \"\"\"Generator for a PCG-based uniform stream.\"\"\"\n        rng = np.random.default_rng(seed)\n        while True:\n            yield rng.random()\n\n    def v_pairs_stream(u_stream_gen, seed, degenerate=False):\n        \"\"\"\n        Generator for V pairs on [-1,1]^2 from a uniform stream.\n        - `u_stream_gen`: A function that creates a uniform stream generator (e.g., lcg_randu_stream).\n        - `seed`: The seed for the uniform stream.\n        - `degenerate`: If True, sets V2 = V1.\n        \"\"\"\n        u_stream = u_stream_gen(seed)\n        while True:\n            u1 = next(u_stream)\n            if degenerate:\n                u2 = u1\n            else:\n                u2 = next(u_stream)\n            v1 = 2 * u1 - 1\n            v2 = 2 * u2 - 1\n            yield v1, v2\n\n    def generate_z_pairs(v_stream_producer, num_pairs):\n        \"\"\"\n        Generates N pairs of standard normal variates using the Marsaglia polar method.\n        - `v_stream_producer`: A function that returns a generator of (v1, v2) pairs.\n        \"\"\"\n        z_pairs = []\n        v_stream = v_stream_producer()\n        num_generated = 0\n        while num_generated  num_pairs:\n            v1, v2 = next(v_stream)\n            s = v1**2 + v2**2\n            if 0  s  1:\n                scale = np.sqrt(-2 * np.log(s) / s)\n                z1 = v1 * scale\n                z2 = v2 * scale\n                z_pairs.append([z1, z2])\n                num_generated += 1\n        return np.array(z_pairs)\n\n    def calculate_diagnostics(z_pairs):\n        \"\"\"Calculates the four diagnostic metrics for a set of Z pairs.\"\"\"\n        num_pairs = z_pairs.shape[0]\n        if num_pairs  2:\n            return [np.nan, np.nan, np.nan, np.nan]\n\n        z1 = z_pairs[:, 0]\n        z2 = z_pairs[:, 1]\n\n        # 1. Within-pair Pearson correlation\n        # Using np.corrcoef, check for constant input to avoid warnings.\n        if np.all(z1 == z1[0]) or np.all(z2 == z2[0]):\n             rho_corr = 1.0 if np.all(z1==z2) else np.nan\n        else:\n             rho_corr = np.corrcoef(z1, z2)[0, 1]\n\n        # 2. Angular uniformity K-S test\n        angles = np.arctan2(z2, z1)\n        angles_rescaled = (angles + np.pi) / (2 * np.pi)\n        # scipy.stats.kstest requires at least 2 data points\n        if angles_rescaled.size > 1:\n            ks_stat, p_ks = stats.kstest(angles_rescaled, 'uniform')\n        else:\n            p_ks = np.nan\n\n        # 3. Lag-1 autocorrelation of flattened sequence\n        y = z_pairs.flatten()\n        n_y = len(y)\n        if n_y > 1:\n            y_bar = np.mean(y)\n            num = np.sum((y[:-1] - y_bar) * (y[1:] - y_bar))\n            den = np.sum((y - y_bar)**2)\n            rho_lag1 = num / den if den != 0 else np.nan\n        else:\n            rho_lag1 = np.nan\n\n        # 4. Chi-square test for independence\n        b = 6\n        if num_pairs >= b*b: # Ensure enough data for a meaningful test\n            # Define bins using quantiles of standard normal distribution\n            q = np.arange(1, b) / b\n            bin_edges = stats.norm.ppf(q)\n            bins = [-np.inf] + bin_edges.tolist() + [np.inf]\n            \n            observed_counts, _, _ = np.histogram2d(z1, z2, bins=(bins, bins))\n            \n            # chi2_contingency can fail if all data lies in a way that gives 0 marginals\n            if np.sum(observed_counts) > 0 and np.all(observed_counts.sum(axis=0) > 0) and np.all(observed_counts.sum(axis=1) > 0):\n                chi2_stat, p_chi2, dof, expected = stats.chi2_contingency(observed_counts, correction=False)\n            else:\n                 p_chi2 = 0.0 # Extreme case, e.g., all on diagonal\n        else:\n            p_chi2 = np.nan\n\n        return [rho_corr, p_ks, rho_lag1, p_chi2]\n\n    test_cases = [\n        {'name': 'A', 'gen': pcg_stream, 'seed': 20231011, 'pairs': 40000, 'degen': False},\n        {'name': 'B', 'gen': lcg_randu_stream, 'seed': 1, 'pairs': 40000, 'degen': False},\n        {'name': 'C', 'gen': lcg_randu_stream, 'seed': 1, 'pairs': 40000, 'degen': True},\n        {'name': 'D', 'gen': pcg_stream, 'seed': 42, 'pairs': 500, 'degen': False}\n    ]\n\n    results = []\n    for case in test_cases:\n        v_stream_producer = lambda: v_pairs_stream(case['gen'], case['seed'], degenerate=case['degen'])\n        z_pairs = generate_z_pairs(v_stream_producer, case['pairs'])\n        diag_results = calculate_diagnostics(z_pairs)\n        results.append(diag_results)\n\n    # Format the final output string as a list of lists.\n    # The `str` representation of a Python list is the desired format \"[...]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3324468"}]}