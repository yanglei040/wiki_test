{"hands_on_practices": [{"introduction": "理论与实践相结合是掌握任何科学概念的最佳途径。本节的第一个练习将指导你从头开始构建一个 Beta 分布生成器。此练习的核心是利用一个基本原理：两个独立的 Gamma 分布随机变量的比率可以生成一个 Beta 分布随机变量。通过亲手实现此方法并使用诸如柯尔莫哥洛夫-斯米尔诺夫检验等关键验证技术来评估其在不同参数设置下的统计保真度，你将不仅加深对理论的理解，还将掌握验证随机数生成器质量的基本技能。[@problem_id:3292091]", "problem": "您的任务是构建一个稳健的贝塔分布随机变量生成器，并设计单元测试，在具有挑战性的参数体系下对该生成器进行压力测试。这项工作必须基于第一性原理和经过充分检验的事实，且不得依赖任何黑盒贝塔采样器。您的程序必须是一个完整的、可运行的实现，能在单行输出中为指定的测试套件生成最终结果。\n\n从以下基本原理开始：\n- 形状参数为 $a0$ 和 $b0$ 的贝塔分布，其概率密度函数在 $x\\in(0,1)$ 上为 $f(x)=\\dfrac{x^{a-1}(1-x)^{b-1}}{B(a,b)}$，其中 $B(a,b)$ 是贝塔函数。\n- 贝塔函数与伽马函数的关系为 $B(a,b)=\\dfrac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}$，伽马函数的定义为 $\\Gamma(s)=\\int_{0}^{\\infty}x^{s-1}e^{-x}\\,dx$（对于 $s0$）。\n- 形状为 $k0$ 且单位尺度为1的伽马分布，其密度函数在 $x0$ 上为 $g(x)=\\dfrac{x^{k-1}e^{-x}}{\\Gamma(k)}$。\n- 随机变量的独立性和变换，以及基于雅可比矩阵的变量替换，是推导变换后变量分布的有效工具。\n\n仅使用以上原理，推导出一个数学上正确的算法来生成 $\\operatorname{Beta}(a,b)$ 分布的随机变量，并予以实现。接下来，设计单元测试，在以下体系下验证您的生成器的统计保真度：\n1. 小形状参数体系：$a,b\\ll 1$。\n2. 大形状参数体系：$a,b\\gg 1$。\n3. 高度不对称形状参数体系：$a$ 或 $b$ 中一个 $\\ll 1$，另一个 $\\gg 1$。\n\n您的测试必须是量化的、可复现的、科学合理的。它们必须通过以下方式验证分布的保真度：\n- 样本均值相对于理论均值 $E[X]=\\dfrac{a}{a+b}$ 的准确性，使用的容差源自抽样标准误差 $\\sqrt{\\operatorname{Var}(X)/n}$，其中 $\\operatorname{Var}(X)=\\dfrac{ab}{(a+b)^2(a+b+1)}$，$n$ 是样本量。\n- 在指定情况下，使用 Kolmogorov–Smirnov (K-S) 拟合优度检验，与精确的 $\\operatorname{Beta}(a,b)$ 累积分布函数进行比较，并对 K-S 统计量设置明确的数值阈值。\n- 在不对称体系下的尾部概率检查：将经验尾部频率与指定阈值处的精确累积分布函数进行比较，如果绝对差异在二项式抽样标准误差容差范围内，则接受。\n\n设计一个包含以下案例的测试套件，每个案例都具有科学上合理的容差：\n- 案例 A (小形状参数)：$(a,b)=(0.1,0.1)$，样本量 $n=80000$，如果 K-S 统计量 $D$ 满足 $D\\leq 0.02$，则接受。\n- 案例 B (大形状参数)：$(a,b)=(100,100)$，样本量 $n=120000$，如果样本均值的绝对误差最多为抽样标准误差的 $5$ 倍，且样本方差的相对误差最多为 $0.15$，则接受。\n- 案例 C (不对称，左偏)：$(a,b)=(0.2,5)$，样本量 $n=100000$，同时接受以下两个条件：样本均值误差最多为抽样标准误差的 $5$ 倍，并且 $X\\leq 0.01$ 的经验频率与 $x=0.01$ 处的精确累积分布值之间的差异最多为 $4\\sqrt{p(1-p)/n}$，其中 $p$ 是 $x=0.01$ 处的精确累积概率。\n- 案例 D (不对称，右偏)：$(a,b)=(5,0.2)$，样本量 $n=100000$，同时接受以下两个条件：样本均值误差最多为抽样标准误差的 $5$ 倍，并且 $X\\geq 0.99$ 的经验频率与 $x=0.99$ 处的精确上尾概率之间的差异最多为 $4\\sqrt{p(1-p)/n}$，其中 $p$ 是 $x=0.99$ 处的精确上尾概率。\n- 案例 E (极小形状参数压力测试)：$(a,b)=(0.01,0.01)$，样本量 $n=120000$，如果 K-S 统计量 $D$ 满足 $D\\leq 0.03$，则接受。\n\n所有数值阈值（$0.02$, $0.03$, $5$, $0.15$, $4$）必须严格按照规定实现。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5]\"），每个结果是对应案例（按 A、B、C、D、E 顺序）的布尔值，表示测试是通过 (True) 还是失败 (False)。不得打印任何额外文本。", "solution": "该问题要求从第一性原理出发，在不使用预先存在的贝塔采样器的情况下，推导并实现一个贝塔分布 $\\operatorname{Beta}(a,b)$ 的随机变量生成器。然后，必须通过一系列针对特定参数体系的严格、量化的单元测试来验证该解决方案的保真度。\n\n生成贝塔变量的基本原理是其与伽马分布的关系。这种关系可以使用概率论中的变量替换法进行形式化推导。\n\n设 $Y_1$ 和 $Y_2$ 是两个独立的随机变量，服从单位尺度的伽马分布。具体而言，设 $Y_1 \\sim \\operatorname{Gamma}(a, 1)$ 和 $Y_2 \\sim \\operatorname{Gamma}(b, 1)$，其中 $a  0$ 和 $b  0$ 是形状参数。根据问题陈述，对于一个 $\\operatorname{Gamma}(k, 1)$ 变量 $Y$，其概率密度函数 (PDF) 为 $g(y) = \\frac{y^{k-1}e^{-y}}{\\Gamma(k)}$（对于 $y  0$）。\n\n$Y_1$ 和 $Y_2$ 各自的概率密度函数为：\n$$g_1(y_1) = \\frac{y_1^{a-1}e^{-y_1}}{\\Gamma(a)}, \\quad y_1  0$$\n$$g_2(y_2) = \\frac{y_2^{b-1}e^{-y_2}}{\\Gamma(b)}, \\quad y_2  0$$\n由于它们相互独立，其联合概率密度函数是它们各自概率密度函数的乘积：\n$$f_{Y_1, Y_2}(y_1, y_2) = \\frac{y_1^{a-1} y_2^{b-1} e^{-(y_1+y_2)}}{\\Gamma(a)\\Gamma(b)}, \\quad y_1  0, y_2  0$$\n\n我们定义一个新的随机变量 $X$ 作为变换 $X = \\frac{Y_1}{Y_1 + Y_2}$。为了求出 $X$ 的分布，我们引入一个辅助变量 $S = Y_1 + Y_2$。然后我们求出 $(X, S)$ 的联合分布，并对 $S$ 进行边缘化。\n\n从 $(x, s)$ 到 $(y_1, y_2)$ 的逆变换是：\n$$Y_1 = XS$$\n$$Y_2 = S - Y_1 = S - XS = S(1 - X)$$\n新变量的定义域由 $y_1  0$ 和 $y_2  0$ 确定。这意味着 $s  0$ 且 $0  x  1$。\n\n此变换的雅可比行列式是偏导数矩阵的行列式：\n$$J = \\det \\begin{pmatrix} \\frac{\\partial y_1}{\\partial x}  \\frac{\\partial y_1}{\\partial s} \\\\ \\frac{\\partial y_2}{\\partial x}  \\frac{\\partial y_2}{\\partial s} \\end{pmatrix} = \\det \\begin{pmatrix} s  x \\\\ -s  1-x \\end{pmatrix} = s(1-x) - x(-s) = s$$\n雅可比行列式的绝对值为 $|J| = s$，因为 $s  0$。\n\n$(X, S)$ 的联合概率密度函数由 $f_{X,S}(x, s) = f_{Y_1, Y_2}(xs, s(1-x))|J|$ 给出。代入 $y_1$、$y_2$ 和 $|J|$ 的表达式：\n$$f_{X,S}(x, s) = \\frac{(xs)^{a-1} (s(1-x))^{b-1} e^{-(xs + s(1-x))}}{\\Gamma(a)\\Gamma(b)} \\cdot s$$\n$$f_{X,S}(x, s) = \\frac{x^{a-1} s^{a-1} s^{b-1} (1-x)^{b-1} e^{-s}}{\\Gamma(a)\\Gamma(b)} \\cdot s$$\n$$f_{X,S}(x, s) = \\frac{x^{a-1}(1-x)^{b-1}}{\\Gamma(a)\\Gamma(b)} s^{a+b-1} e^{-s}$$\n此联合概率密度函数在 $0  x  1$ 和 $s  0$ 时有效。\n\n为了找到 $X$ 的边际概率密度函数 $f_X(x)$，我们将 $f_{X,S}(x, s)$ 对其整个定义域 $(0, \\infty)$ 上的 $s$ 进行积分：\n$$f_X(x) = \\int_{0}^{\\infty} \\frac{x^{a-1}(1-x)^{b-1}}{\\Gamma(a)\\Gamma(b)} s^{a+b-1} e^{-s} \\,ds$$\n涉及 $x$ 的项相对于 $s$ 是常数，因此我们将其提出：\n$$f_X(x) = \\frac{x^{a-1}(1-x)^{b-1}}{\\Gamma(a)\\Gamma(b)} \\int_{0}^{\\infty} s^{(a+b)-1} e^{-s} \\,ds$$\n该积分是伽马函数 $\\Gamma(a+b)$ 的定义。\n$$\\int_{0}^{\\infty} s^{(a+b)-1} e^{-s} \\,ds = \\Gamma(a+b)$$\n将其代回，我们得到：\n$$f_X(x) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} x^{a-1}(1-x)^{b-1}$$\n使用贝塔函数的定义 $B(a,b) = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}$，该概率密度函数变为：\n$$f_X(x) = \\frac{x^{a-1}(1-x)^{b-1}}{B(a,b)}, \\quad 0  x  1$$\n这正是形状参数为 $a$ 和 $b$ 的贝塔分布的概率密度函数，即 $X \\sim \\operatorname{Beta}(a,b)$。\n\n此推导提供了以下算法来生成一个 $\\operatorname{Beta}(a,b)$ 随机变量：\n1. 生成一个独立的随机变量 $Y_1 \\sim \\operatorname{Gamma}(a, 1)$。\n2. 生成一个独立的随机变量 $Y_2 \\sim \\operatorname{Gamma}(b, 1)$。\n3. 计算 $X = \\frac{Y_1}{Y_1 + Y_2}$。结果 $X$ 是一个 $\\operatorname{Beta}(a,b)$ 变量。\n\n该算法将使用高质量的伽马生成器（例如 `numpy.random.gamma`）来实现，然后接受指定的测试套件的检验。\n\n该测试套件在五个不同的案例中验证生成器的统计特性：\n- 案例 A：$(a,b)=(0.1,0.1)$，$n=80000$。一个 Kolmogorov-Smirnov (K-S) 检验将生成样本的经验累积分布函数 (CDF) 与理论贝塔 CDF 进行比较。如果 K-S 统计量 $D$ 最多为 $0.02$，则测试通过。\n- 案例 B：$(a,b)=(100,100)$，$n=120000$。这测试了大而对称的形状。如果满足两个条件，则测试通过：样本均值相对于理论均值 $E[X]=\\frac{a}{a+b}$ 的绝对误差在均值标准误差 $\\sqrt{\\operatorname{Var}(X)/n}$ 的 $5$ 倍以内，并且样本方差的相对误差最多为 $0.15$。理论方差为 $\\operatorname{Var}(X)=\\frac{ab}{(a+b)^2(a+b+1)}$。\n- 案例 C：$(a,b)=(0.2,5)$，$n=100000$。这测试了一个高度不对称的左偏分布。它将与案例 B 相同的均值准确性测试与尾部概率检查相结合。样本 $X \\leq 0.01$ 的经验频率与精确概率 $p = F(0.01; a, b)$ 进行比较。如果此差异最多为二项式比例标准误差的 $4$ 倍，即 $4\\sqrt{p(1-p)/n}$，则测试通过。\n- 案例 D：$(a,b)=(5,0.2)$，$n=100000$。这是与案例 C 对称的案例，测试一个右偏分布。它使用均值准确性测试和对上尾部的类似尾部检查：$X \\geq 0.99$ 的经验频率必须接近精确概率 $p = 1 - F(0.99; a, b)$，容差因子同样为 $4$。\n- 案例 E：$(a,b)=(0.01,0.01)$，$n=120000$。此案例用极小的形状参数对生成器进行压力测试，这会导致一个 U 形分布，其概率质量高度集中在 $0$ 和 $1$ 附近。与案例 A 一样，使用 K-S 检验，如果统计量 $D$ 最多为 $0.03$，则通过。\n\n该实现将按程序执行这些测试案例，并汇总布尔结果（True 表示通过，False 表示失败）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a Beta random variate generator.\n    \"\"\"\n    \n    # Use a fixed seed for reproducibility of the random number generation.\n    rng = np.random.default_rng(42)\n\n    def generate_beta(a, b, n, local_rng):\n        \"\"\"\n        Generates n random variates from a Beta(a,b) distribution.\n        \n        This function implements the algorithm based on Gamma variates:\n        If Y1 ~ Gamma(a, 1) and Y2 ~ Gamma(b, 1) are independent,\n        then X = Y1 / (Y1 + Y2) ~ Beta(a, b).\n        \n        Args:\n            a (float): The first shape parameter (alpha).\n            b (float): The second shape parameter (beta).\n            n (int): The number of variates to generate.\n            local_rng (numpy.random.Generator): The random number generator instance.\n        \n        Returns:\n            numpy.ndarray: An array of n Beta(a,b) random variates.\n        \"\"\"\n        # Generate Gamma(a, 1) variates\n        y1 = local_rng.gamma(shape=a, scale=1.0, size=n)\n        # Generate Gamma(b, 1) variates\n        y2 = local_rng.gamma(shape=b, scale=1.0, size=n)\n        \n        # The sum y1 + y2 should be non-zero as Gamma variates for a,b > 0 are positive.\n        # This prevents division by zero.\n        return y1 / (y1 + y2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 'A', 'type': 'ks', 'params': (0.1, 0.1), 'n': 80000, 'ks_threshold': 0.02},\n        {'id': 'B', 'type': 'mean_var', 'params': (100, 100), 'n': 120000, 'mean_tol_factor': 5.0, 'rel_var_tol': 0.15},\n        {'id': 'C', 'type': 'mean_tail', 'params': (0.2, 5), 'n': 100000, 'mean_tol_factor': 5.0, 'tail_type': 'left', 'tail_x': 0.01, 'tail_tol_factor': 4.0},\n        {'id': 'D', 'type': 'mean_tail', 'params': (5, 0.2), 'n': 100000, 'mean_tol_factor': 5.0, 'tail_type': 'right', 'tail_x': 0.99, 'tail_tol_factor': 4.0},\n        {'id': 'E', 'type': 'ks', 'params': (0.01, 0.01), 'n': 120000, 'ks_threshold': 0.03}\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b = case['params']\n        n = case['n']\n        samples = generate_beta(a, b, n, rng)\n        \n        test_passed = False\n        if case['type'] == 'ks':\n            ks_stat, _ = stats.kstest(samples, 'beta', args=(a, b))\n            test_passed = ks_stat = case['ks_threshold']\n        \n        elif case['type'] == 'mean_var':\n            theo_mean = a / (a + b)\n            theo_var = (a * b) / ((a + b)**2 * (a + b + 1))\n            \n            sample_mean = np.mean(samples)\n            sample_var = np.var(samples, ddof=0) # Population variance of sample\n            \n            mean_se = np.sqrt(theo_var / n)\n            mean_test = abs(sample_mean - theo_mean) = case['mean_tol_factor'] * mean_se\n            \n            rel_var_error = abs((sample_var - theo_var) / theo_var)\n            var_test = rel_var_error = case['rel_var_tol']\n            \n            test_passed = mean_test and var_test\n\n        elif case['type'] == 'mean_tail':\n            theo_mean = a / (a + b)\n            theo_var = (a * b) / ((a + b)**2 * (a + b + 1))\n            sample_mean = np.mean(samples)\n\n            mean_se = np.sqrt(theo_var / n)\n            mean_test = abs(sample_mean - theo_mean) = case['mean_tol_factor'] * mean_se\n            \n            x_thresh = case['tail_x']\n            if case['tail_type'] == 'left':\n                p_exact = stats.beta.cdf(x_thresh, a, b)\n                p_empirical = np.sum(samples = x_thresh) / n\n            else: # right\n                p_exact = stats.beta.sf(x_thresh, a, b)\n                p_empirical = np.sum(samples >= x_thresh) / n\n            \n            # The standard error of the binomial proportion estimate\n            # Check for p_exact being 0 or 1 to avoid NaN from sqrt of a negative number due to precision.\n            if 0.0  p_exact  1.0:\n                tail_tolerance = case['tail_tol_factor'] * np.sqrt(p_exact * (1.0 - p_exact) / n)\n            else:\n                tail_tolerance = 0.0\n            \n            tail_test = abs(p_empirical - p_exact) = tail_tolerance\n            \n            test_passed = mean_test and tail_test\n        \n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3292091"}, {"introduction": "在构建了基本的生成器之后，我们必须面对一个在科学计算中普遍存在的挑战：数值稳定性。当 Beta 分布的形状参数 $\\alpha$ 或 $\\beta$ 变得极大或极小时，直接计算 Gamma 变量的比率可能会导致浮点溢出或下溢，从而产生不准确的结果。这个练习将教你如何通过在对数域中进行计算，并使用“log-sum-exp”技巧来解决这个问题，从而构建一个在极端条件下也同样稳健的生成器。掌握此类数值稳定技术对于确保模拟的准确性和可靠性至关重要。[@problem_id:3292073]", "problem": "要求您设计、分析并实现一个鲁棒的贝塔分布随机变量生成器，该生成器基于独立伽玛变量的比率。目标是为分布为 $X \\sim \\mathrm{Beta}(\\alpha,\\beta)$ 的随机变量 $X$ 创建一个生成器，它通过变换 $X = \\dfrac{G_\\alpha}{G_\\alpha + G_\\beta}$ 从两个独立的伽玛变量 $G_\\alpha \\sim \\Gamma(\\alpha,1)$ 和 $G_\\beta \\sim \\Gamma(\\beta,1)$ 构建。该实现必须在极端形状参数下（特别是当 $\\alpha$ 或 $\\beta$ 非常大或非常小时）保持数值稳定。您的程序必须使用 log-sum-exp 恒等式实现 $X$ 的稳定计算，以避免灾难性抵消：\n$$\n\\log\\left(e^{u} + e^{v}\\right) = \\mathrm{LSE}(u,v) \\equiv \\max(u,v) + \\log\\!\\left( 1 + e^{-|u-v|} \\right),\n$$\n因此，当 $u = \\log G_\\alpha$ 和 $v = \\log G_\\beta$ 时，该比率可以计算为\n$$\nX = \\exp\\!\\left( \\log G_\\alpha - \\mathrm{LSE}(\\log G_\\alpha, \\log G_\\beta) \\right).\n$$\n\n请从伽玛分布（使用形状-尺度参数化）和贝塔分布的基本定义开始。假设 $G_\\alpha$ 和 $G_\\beta$ 是独立的，并请记住，数值稳定性必须被视为首要的设计约束。您必须从第一性原理出发，论证伽玛比率构造的正确性以及 log-sum-exp 技术的稳定性。\n\n您的程序必须：\n- 实现一个函数，对于给定的实数形状参数 $\\alpha0$、$\\beta0$ 和整数样本量 $n \\ge 1$，使用比率 $X=\\dfrac{G_\\alpha}{G_\\alpha+G_\\beta}$（其中 $G_\\alpha \\sim \\Gamma(\\alpha,1)$，$G_\\beta \\sim \\Gamma(\\beta,1)$）返回 $n$ 个来自 $\\mathrm{Beta}(\\alpha,\\beta)$ 的独立样本，并通过上述的 log-sum-exp 恒等式计算该比率。\n- 使用固定的伪随机数生成器种子以确保可复现性。\n- 为了验证，根据贝塔分布的已知解析性质计算蒙特卡洛诊断。具体来说，如果 $\\mu=\\dfrac{\\alpha}{\\alpha+\\beta}$ 和 $\\sigma^2=\\dfrac{\\alpha\\beta}{(\\alpha+\\beta)^2(\\alpha+\\beta+1)}$ 表示精确的均值和方差，那么样本均值 $\\bar{X}_n$ 的蒙特卡洛标准误为 $\\mathrm{SE}=\\sqrt{\\sigma^2/n}$。对于选定的测试用例，如果对于指定的常数 $c$ 满足 $|\\bar{X}_n-\\mu| \\le c \\cdot \\mathrm{SE}$，则声明测试通过。\n\n测试套件和要求的输出：\n- 使用以下五个测试用例，每个用例由 $(\\alpha,\\beta,n,c)$ 指定：\n  - 用例 A（常规路径）：$(\\alpha,\\beta,n,c)=(2.5,5.0,100000,5)$。\n  - 用例 B（两个形状参数均小于一）：$(\\alpha,\\beta,n,c)=(0.3,0.7,200000,5)$。\n  - 用例 C（非常大且平衡的形状参数）：$(\\alpha,\\beta,n,c)=(10^6,10^6,20000,10)$。\n  - 用例 D（高度不平衡的形状参数）：$(\\alpha,\\beta,n,c)=(10^{-6},10^{6},200000,6)$。\n  - 用例 E（内部的分位数精度）：$(\\alpha,\\beta,n)=(15.2,9.7,150000)$。对于此用例，评估在概率 $\\tau \\in \\{0.1,0.5,0.9\\}$ 处的经验分位数与 $\\mathrm{Beta}(\\alpha,\\beta)$ 的理论分位数 $q_\\tau$ 的对比情况。使用样本分位数 $\\hat{q}_\\tau$ 的渐近方差公式，\n    $$\n    \\mathrm{Var}(\\hat{q}_\\tau) \\approx \\frac{\\tau(1-\\tau)}{n\\,f(q_\\tau)^2},\n    $$\n    其中 $f$ 是 $\\mathrm{Beta}(\\alpha,\\beta)$ 的概率密度函数，如果满足\n    $$\n    \\max_{\\tau \\in \\{0.1,0.5,0.9\\}} \\left|\\hat{q}_\\tau - q_\\tau\\right| \\le 4 \\cdot \\sqrt{\\frac{\\tau(1-\\tau)}{n\\,f(q_\\tau)^2}},\n    $$\n    则声明测试通过。对于此用例，报告一个布尔值，指示所有三个分位数是否同时满足此界限。\n- 您的程序必须生成单行输出，其中包含用例 A 到 E 的结果，格式为方括号括起来的逗号分隔列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{True},\\text{True}]$。\n\n所有数值答案都必须是无量纲的实数。不涉及角度。不要将任何答案表示为百分比；如果出现任何比例，它必须是 $[0,1]$ 内的实数。\n\n科学真实性和覆盖范围：\n- 伽玛分布和贝塔分布必须严格按照概率论中的定义使用，其中伽玛变量的形状参数为 $\\alpha,\\beta0$，尺度参数为单位1。\n- 在计算 $X$ 时必须明确使用通过 log-sum-exp 恒等式实现的数值稳定化，以防止在 $\\alpha$ 或 $\\beta$ 极端时发生下溢或上溢。\n- 测试套件覆盖了典型、小形状参数、大形状参数、不平衡形状参数以及分位数精度等场景。", "solution": "从贝塔分布生成随机变量是随机模拟中的一项基本任务。本问题要求设计并实现一个用于生成 $X \\sim \\mathrm{Beta}(\\alpha,\\beta)$ 的生成器，该生成器基于独立伽玛变量的比率，并严格要求数值稳定性，特别是对于形状参数 $\\alpha$ 和 $\\beta$ 的极端值。\n\n**1. 理论基础：伽玛比率法**\n\n该方法的基础是概率论中一个已确立的定理，该定理连接了贝塔分布和伽玛分布。\n\n首先，让我们定义相关的分布。一个随机变量 $Y$ 如果服从形状参数为 $k0$ 且单位尺度参数为 ($\\theta=1$) 的伽玛分布，记作 $Y \\sim \\Gamma(k,1)$，其概率密度函数 (PDF) 为：\n$$f_Y(y; k, 1) = \\frac{1}{\\Gamma(k)} y^{k-1} e^{-y} \\quad \\text{for } y  0$$\n其中 $\\Gamma(k) = \\int_0^\\infty t^{k-1} e^{-t} dt$ 是伽玛函数。\n\n一个随机变量 $X$ 如果服从形状参数为 $\\alpha0$ 和 $\\beta0$ 的贝塔分布，记作 $X \\sim \\mathrm{Beta}(\\alpha, \\beta)$，其概率密度函数为：\n$$f_X(x; \\alpha, \\beta) = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha-1} (1-x)^{\\beta-1} \\quad \\text{for } x \\in (0, 1)$$\n其中 $B(\\alpha, \\beta) = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$ 是贝塔函数。\n\n该定理指出，如果 $G_\\alpha \\sim \\Gamma(\\alpha, 1)$ 和 $G_\\beta \\sim \\Gamma(\\beta, 1)$ 是两个独立的随机变量，则由比率定义的变量 $X$\n$$X = \\frac{G_\\alpha}{G_\\alpha + G_\\beta}$$\n服从 $\\mathrm{Beta}(\\alpha, \\beta)$ 分布。\n\n我们可以通过变量替换来证明这一结果。设独立变量 $(G_\\alpha, G_\\beta)$ 的联合概率密度函数为：\n$$f(g_\\alpha, g_\\beta) = f_{G_\\alpha}(g_\\alpha) f_{G_\\beta}(g_\\beta) = \\left(\\frac{1}{\\Gamma(\\alpha)} g_\\alpha^{\\alpha-1} e^{-g_\\alpha}\\right) \\left(\\frac{1}{\\Gamma(\\beta)} g_\\beta^{\\beta-1} e^{-g_\\beta}\\right)$$\n对于 $g_\\alpha, g_\\beta  0$。我们引入变换：\n$$X = \\frac{G_\\alpha}{G_\\alpha + G_\\beta} \\quad \\text{and} \\quad Y = G_\\alpha + G_\\beta$$\n逆变换为 $G_\\alpha = XY$ 和 $G_\\beta = Y(1-X)$。定义域 $(g_\\alpha, g_\\beta) \\in (0, \\infty) \\times (0, \\infty)$ 映射到 $(x, y) \\in (0, 1) \\times (0, \\infty)$。此逆变换的雅可比行列式为：\n$$J = \\det \\begin{pmatrix} \\frac{\\partial g_\\alpha}{\\partial x}  \\frac{\\partial g_\\alpha}{\\partial y} \\\\ \\frac{\\partial g_\\beta}{\\partial x}  \\frac{\\partial g_\\beta}{\\partial y} \\end{pmatrix} = \\det \\begin{pmatrix} y  x \\\\ -y  1-x \\end{pmatrix} = y(1-x) - (-y)x = y$$\n$(X, Y)$ 的联合概率密度函数为 $f_{X,Y}(x, y) = f(xy, y(1-x))|J|$：\n$$f_{X,Y}(x, y) = \\frac{1}{\\Gamma(\\alpha)\\Gamma(\\beta)} (xy)^{\\alpha-1} e^{-xy} (y(1-x))^{\\beta-1} e^{-y(1-x)} y$$\n$$f_{X,Y}(x, y) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{\\Gamma(\\alpha)\\Gamma(\\beta)} y^{\\alpha-1} y^{\\beta-1} y \\, e^{-xy - y(1-x)}$$\n$$f_{X,Y}(x, y) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{\\Gamma(\\alpha)\\Gamma(\\beta)} y^{\\alpha+\\beta-1} e^{-y}$$\n为了找到 $X$ 的边际概率密度函数，我们对所有可能的 $Y$ 值进行积分：\n$$f_X(x) = \\int_0^\\infty f_{X,Y}(x, y) dy = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{\\Gamma(\\alpha)\\Gamma(\\beta)} \\int_0^\\infty y^{\\alpha+\\beta-1} e^{-y} dy$$\n该积分是 $\\Gamma(\\alpha+\\beta)$ 的定义。因此：\n$$f_X(x) = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)} x^{\\alpha-1}(1-x)^{\\beta-1} = \\frac{1}{B(\\alpha, \\beta)} x^{\\alpha-1}(1-x)^{\\beta-1}$$\n这正是 $\\mathrm{Beta}(\\alpha, \\beta)$ 分布的概率密度函数，从而验证了该方法。\n\n**2. 数值稳定性与 Log-Sum-Exp 技术**\n\n当形状参数极端时，直接计算比率 $X = G_\\alpha / (G_\\alpha + G_\\beta)$ 在数值上是不稳定的。\n- 如果 $\\alpha$ 和 $\\beta$ 非常大（例如 $10^6$），伽玛变量 $G_\\alpha$ 和 $G_\\beta$ 可能会非常大，因为 $\\mathbb{E}[\\Gamma(k,1)] = k$。它们的和 $G_\\alpha + G_\\beta$ 可能会超出标准浮点表示的范围，导致上溢。\n- 如果 $\\alpha$ 非常小而 $\\beta$ 非常大（例如 $\\alpha=10^{-6}, \\beta=10^6$），那么 $G_\\alpha$ 将非常接近于零，并可能下溢为 $0.0$。这将错误地导致 $X=0$。类似地，如果 $\\alpha$ 大而 $\\beta$ 小，$G_\\beta$ 可能会下溢，导致 $X=1$。\n\n为了规避这些问题，我们在对数域中进行计算。令 $u = \\log G_\\alpha$ 和 $v = \\log G_\\beta$。那么 $X$ 可以写成：\n$$X = \\frac{e^u}{e^u + e^v}$$\n对 $X$ 取对数：\n$$\\log X = \\log(e^u) - \\log(e^u + e^v) = u - \\log(e^u + e^v)$$\n项 $\\log(e^u + e^v)$，被称为 log-sum-exp (LSE) 函数，如果 $u$ 或 $v$ 很大，仍然可能导致上溢。我们使用以下稳定的恒等式来计算它：\n$$\\mathrm{LSE}(u, v) = \\log(e^u + e^v) = \\max(u, v) + \\log(1 + e^{-|u - v|})$$\n这种形式是稳定的，因为指数的参数 $-|u-v|$ 总是非正数，从而防止了上溢。$e^{-|u-v|}$ 的值总是在 $[0, 1]$ 区间内，因此它与 $1$ 的和以及后续的对数运算都是良态的。\n\n因此，计算 $X$ 的稳定算法是：\n$$X = \\exp\\left( \\log G_\\alpha - \\mathrm{LSE}(\\log G_\\alpha, \\log G_\\beta) \\right)$$\n\n**3. 算法实现步骤**\n\n要从 $\\mathrm{Beta}(\\alpha, \\beta)$ 生成一个包含 $n$ 个样本的向量：\n1. 从 $\\Gamma(\\alpha, 1)$ 生成一个包含 $n$ 个样本的向量 $\\mathbf{g}_\\alpha$。\n2. 从 $\\Gamma(\\beta, 1)$ 生成一个包含 $n$ 个样本的向量 $\\mathbf{g}_\\beta$。\n3. 按元素计算自然对数：$\\mathbf{u} = \\log \\mathbf{g}_\\alpha$ 和 $\\mathbf{v} = \\log \\mathbf{g}_\\beta$。\n4. 按元素计算最大值：$\\mathbf{m} = \\max(\\mathbf{u}, \\mathbf{v})$。\n5. 计算 LSE 项：$\\mathbf{lse} = \\mathbf{m} + \\log(1 + \\exp(-|\\mathbf{u} - \\mathbf{v}|))$。\n6. 计算最终样本：$\\mathbf{x} = \\exp(\\mathbf{u} - \\mathbf{lse})$。向量 $\\mathbf{x}$ 包含了所需的贝塔变量。\n\n**4. 验证方法**\n\n生成的样本将根据贝塔分布的已知理论性质进行验证。\n\n**均值验证（用例 A-D）：** 中心极限定理指出，对于大样本量 $n$，样本均值 $\\bar{X}_n$ 近似服从均值为 $\\mu$、方差为 $\\sigma^2/n$ 的正态分布，其中 $\\mu$ 和 $\\sigma^2$ 是分布的真实均值和方差。\n- 真实均值：$\\mu = \\frac{\\alpha}{\\alpha+\\beta}$\n- 真实方差：$\\sigma^2 = \\frac{\\alpha\\beta}{(\\alpha+\\beta)^2(\\alpha+\\beta+1)}$\n样本均值的蒙特卡洛标准误为 $\\mathrm{SE} = \\sqrt{\\sigma^2/n}$。如果样本均值在真实均值的 $c$ 个标准误范围内，即 $|\\bar{X}_n - \\mu| \\le c \\cdot \\mathrm{SE}$，我们声明测试通过。\n\n**分位数验证（用例 E）：** 为了更强有力地测试分布的形状，我们比较经验分位数与理论分位数。顺序统计量的渐近理论为概率水平为 $\\tau$ 的样本分位数 $\\hat{q}_\\tau$ 提供了近似方差：\n$$\\mathrm{Var}(\\hat{q}_\\tau) \\approx \\frac{\\tau(1-\\tau)}{n f(q_\\tau)^2}$$\n其中 $q_\\tau$ 是真实分位数，而 $f$ 是分布的概率密度函数。如果在一组分位数上的最大绝对偏差被 $4$ 倍的渐近标准误所界定，我们声明测试通过：\n$$\\max_{\\tau \\in \\{0.1, 0.5, 0.9\\}} |\\hat{q}_\\tau - q_\\tau| \\le 4 \\cdot \\sqrt{\\frac{\\tau(1-\\tau)}{n f(q_\\tau)^2}}$$\n这个全面的验证框架确保了所实现的生成器不仅在数值上是稳定的，而且在统计上也是准确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Beta variate generator.\n    \"\"\"\n    \n    # Use a fixed seed for the pseudorandom number generator for reproducibility.\n    SEED = 42\n    RNG = np.random.default_rng(SEED)\n\n    def generate_beta_stable(alpha, beta, n, rng_instance):\n        \"\"\"\n        Generates n samples from Beta(alpha, beta) using the stable\n        ratio-of-gammas method with the log-sum-exp trick.\n\n        Args:\n            alpha (float): Shape parameter > 0.\n            beta (float): Shape parameter > 0.\n            n (int): Number of samples to generate >= 1.\n            rng_instance (numpy.random.Generator): A numpy random generator instance.\n\n        Returns:\n            numpy.ndarray: An array of n samples from the Beta distribution.\n        \"\"\"\n        # Generate n samples from two independent Gamma distributions.\n        # Scale parameter is 1 by default in numpy.random.gamma.\n        g_alpha = rng_instance.gamma(alpha, size=n)\n        g_beta = rng_instance.gamma(beta, size=n)\n\n        # Compute in the log domain to prevent overflow/underflow.\n        log_g_alpha = np.log(g_alpha)\n        log_g_beta = np.log(g_beta)\n\n        # Compute log(g_alpha + g_beta) robustly using log-sum-exp.\n        u = log_g_alpha\n        v = log_g_beta\n        m = np.maximum(u, v)\n        # LSE(u,v) = log(e^u + e^v)\n        log_sum_exp = m + np.log(1 + np.exp(-np.abs(u - v)))\n\n        # Compute log(X) = log(g_alpha / (g_alpha + g_beta))\n        # log(X) = log(g_alpha) - log(g_alpha + g_beta)\n        log_x = log_g_alpha - log_sum_exp\n        \n        # Exponentiate to get the final samples.\n        x = np.exp(log_x)\n        \n        return x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        {'type': 'mean', 'params': (2.5, 5.0, 100000, 5)},\n        # Case B (both shapes less than one)\n        {'type': 'mean', 'params': (0.3, 0.7, 200000, 5)},\n        # Case C (very large, balanced shapes)\n        {'type': 'mean', 'params': (10**6, 10**6, 20000, 10)},\n        # Case D (highly imbalanced shapes)\n        {'type': 'mean', 'params': (10**-6, 10**6, 200000, 6)},\n        # Case E (quantile accuracy)\n        {'type': 'quantile', 'params': (15.2, 9.7, 150000, 4)},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'mean':\n            alpha, beta, n, c = case['params']\n            \n            samples = generate_beta_stable(alpha, beta, n, RNG)\n            \n            sample_mean = np.mean(samples)\n            \n            # Theoretical properties\n            # Using np.longdouble for precision with extreme parameters\n            a_ld, b_ld = np.longdouble(alpha), np.longdouble(beta)\n            \n            mu = a_ld / (a_ld + b_ld)\n            \n            # Handle potential overflow in (alpha+beta+1) for large alpha/beta\n            if (a_ld + b_ld + 1) == np.inf:\n                 var = 0.0\n            else:\n                 var = (a_ld * b_ld) / ((a_ld + b_ld)**2 * (a_ld + b_ld + 1))\n            \n            se = np.sqrt(var / n)\n            \n            # Check pass condition\n            passed = np.abs(sample_mean - mu) = c * se\n            results.append(bool(passed))\n\n        elif case['type'] == 'quantile':\n            alpha, beta, n, c_q = case['params']\n            \n            samples = generate_beta_stable(alpha, beta, n, RNG)\n\n            taus = np.array([0.1, 0.5, 0.9])\n            \n            # Empirical quantiles\n            q_hats = np.quantile(samples, taus)\n            \n            # Theoretical properties\n            q_s = stats.beta.ppf(taus, a=alpha, b=beta)\n            f_q_s = stats.beta.pdf(q_s, a=alpha, b=beta)\n            \n            # Asymptotic standard error of the sample quantile\n            asymptotic_var = (taus * (1 - taus)) / (n * f_q_s**2)\n            bound = c_q * np.sqrt(asymptotic_var)\n\n            # Check if all quantiles pass the test simultaneously.\n            passed = np.all(np.abs(q_hats - q_s) = bound)\n            results.append(bool(passed))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3292073"}, {"introduction": "最后一个动手实践将带你深入探索 Beta 变量生成器的统计验证。标准的验证通常止步于检验样本均值和方差，但本练习要求更高层次的严谨性。你将需要从第一性原理出发，推导 Beta 分布的前四阶矩，并利用这些结果来计算样本方差估计量自身的理论方差。通过将你生成的样本与这一深刻的理论预测进行比较，你将对随机变量的矩以及蒙特卡洛验证的精妙之处有更透徹的理解，完成从基本的功能测试到严格的科学压力测试的进阶。[@problem_id:3292115]", "problem": "构建一个完整的、可运行的程序，通过验证经验均值和方差是否符合从第一性原理推导出的理论值，来对一个贝塔分布随机变量生成器在一系列参数对网格上进行压力测试。该程序必须是自包含的，并且只使用标准的数值计算库。您的实现必须遵循以下要求。\n\n1. 基本原理和生成器规范：\n   - 使用以下定义：如果 $X \\sim \\mathrm{Gamma}(\\alpha,1)$ 和 $Y \\sim \\mathrm{Gamma}(\\beta,1)$ 是独立的，那么 $T = \\dfrac{X}{X+Y}$ 服从 $\\mathrm{Beta}(\\alpha,\\beta)$ 分布。这里 $\\mathrm{Gamma}(\\alpha,1)$ 表示形状参数为 $\\alpha$、尺度参数为 1 的伽马分布。\n   - 通过将 $X$ 和 $Y$ 作为形状参数为 $\\alpha$ 和 $\\beta$ 的独立伽马分布随机变量进行抽样，并逐元素计算 $T = \\dfrac{X}{X+Y}$，来实现一个贝塔分布随机变量生成器。\n   - 不要调用任何内置的贝塔分布随机变量生成器。\n\n2. 源于核心定义的理论目标：\n   - 从贝塔分布的概率密度和贝塔函数 $B(\\alpha,\\beta)$ 出发，推导并使用原始矩恒等式\n     $$\\mathbb{E}[X^k] = \\prod_{j=0}^{k-1} \\frac{\\alpha + j}{\\alpha+\\beta + j}, \\quad k \\in \\{1,2,3,4\\},$$\n     来计算理论均值 $\\mu = \\mathbb{E}[X]$、理论方差 $\\sigma^2 = \\mathbb{E}[X^2] - \\mu^2$ 以及四阶中心矩\n     $$\\mu_4 = \\mathbb{E}[(X-\\mu)^4] = \\mathbb{E}[X^4] - 4 \\mu \\mathbb{E}[X^3] + 6 \\mu^2 \\mathbb{E}[X^2] - 3 \\mu^4.$$\n   - 对于来自大小为 $n$ 的独立同分布样本的无偏样本方差 $s^2$，使用其方差的通用恒等式\n     $$\\mathrm{Var}(s^2) = \\frac{1}{n}\\left(\\mu_4 - \\frac{n-3}{n-1}\\sigma^4\\right),$$\n     其中 $s^2$ 使用的分母是 $n-1$。\n\n3. 统计验证标准：\n   - 对于每个参数对 $(\\alpha,\\beta)$，生成 $n$ 个独立的 $\\mathrm{Beta}(\\alpha,\\beta)$ 样本，计算样本均值 $\\hat{\\mu}$ 和无偏样本方差 $s^2$（使用分母 $n-1$）。\n   - 定义标准化差异\n     $$Z_{\\mathrm{mean}} = \\frac{|\\hat{\\mu} - \\mu|}{\\sqrt{\\sigma^2/n}}, \\qquad Z_{\\mathrm{var}} = \\frac{|s^2 - \\sigma^2|}{\\sqrt{\\mathrm{Var}(s^2)}},$$\n     其中 $\\mu$、$\\sigma^2$ 和 $\\mathrm{Var}(s^2)$ 如上所定义。\n   - 使用中心极限定理（CLT）和大样本近似，如果 $Z_{\\mathrm{mean}} \\leq \\tau$ 和 $Z_{\\mathrm{var}} \\leq \\tau$ 同时成立，则宣布一个测试用例通过，其中阈值 $\\tau$ 在所有用例中固定不变。使用 $\\tau = 4.5$。\n\n4. 测试套件和覆盖范围：\n   - 对每个用例使用相同的样本大小 $n = 50000$。\n   - 使用以下 $(\\alpha,\\beta)$ 对的网格来探究平衡、不平衡、小形状参数和大形状参数的情形：\n     - $(\\alpha,\\beta) \\in \\{(0.1,0.1),(0.1,5.0),(5.0,0.1),(0.5,0.5),(1.0,1.0),(2.0,5.0),(5.0,2.0),(50.0,50.0),(100.0,1.0),(1.0,100.0)\\}$.\n   - 为确保可复现性，为随机数生成器固定一个确定性种子。\n\n5. 程序输入和输出：\n   - 程序必须是完全自包含的，且不得要求任何用户输入。\n   - 最终输出必须是单行，包含一个由方括号括起来的、逗号分隔的布尔值列表。每个布尔值按上述顺序对应一个测试用例，并且当且仅当该用例的两项标准化标准都通过时才为真。例如，像\n     $$[\\mathrm{True},\\mathrm{False},\\dots]$$\n     这样的输出表明了哪些 $(\\alpha,\\beta)$ 对通过或未通过测试。\n\n不涉及物理单位或角度单位。所有数值必须以固定小数形式表示。最终程序必须能在标准环境中直接运行，并且只能使用指定的库。答案必须仅为代码，并产生与指定格式完全一致的单行输出。", "solution": "该问题要求构建一个贝塔分布随机变量生成器并对其进行统计验证。生成器的实现基于一个基本原理，即两个独立的伽马分布随机变量之比服从贝塔分布。验证过程涉及将为不同参数集生成的大样本的经验均值和方差与其精确的理论值进行比较。\n\n对于每个参数对 $(\\alpha, \\beta)$，其过程涉及几个步骤：推导理论矩，生成样本，计算经验统计量，以及基于标准化差异的统计检验。\n\n首先，我们为验证建立理论基础。如果一个随机变量 $T$ 的概率密度函数由下式给出，则称其服从形状参数为 $\\alpha  0$ 和 $\\beta  0$ 的贝塔分布，记为 $T \\sim \\mathrm{Beta}(\\alpha, \\beta)$\n$$f(t; \\alpha, \\beta) = \\frac{t^{\\alpha-1}(1-t)^{\\beta-1}}{B(\\alpha, \\beta)}, \\quad t \\in [0, 1]$$\n其中 $B(\\alpha, \\beta) = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$ 是贝塔函数。\n\n生成器将基于以下性质构建：如果 $X \\sim \\mathrm{Gamma}(\\alpha, 1)$ 和 $Y \\sim \\mathrm{Gamma}(\\beta, 1)$ 是独立的随机变量，则它们的比率 $T = \\frac{X}{X+Y}$ 服从 $\\mathrm{Beta}(\\alpha, \\beta)$ 分布。\n\n为了进行验证，我们需要 $\\mathrm{Beta}(\\alpha, \\beta)$ 分布的前四阶原始矩。第 $k$ 阶原始矩 $\\mathbb{E}[T^k]$ 由下式给出：\n$$\\mathbb{E}[T^k] = \\int_0^1 t^k f(t; \\alpha, \\beta) dt = \\frac{1}{B(\\alpha, \\beta)} \\int_0^1 t^{\\alpha+k-1} (1-t)^{\\beta-1} dt = \\frac{B(\\alpha+k, \\beta)}{B(\\alpha, \\beta)}$$\n使用恒等式 $B(a, b) = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}$ 和性质 $\\Gamma(z+1)=z\\Gamma(z)$，我们可以将其表示为乘积形式：\n$$\\mathbb{E}[T^k] = \\frac{\\Gamma(\\alpha+k)\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\alpha+\\beta+k)} = \\frac{\\alpha(\\alpha+1)\\dots(\\alpha+k-1)}{(\\alpha+\\beta)(\\alpha+\\beta+1)\\dots(\\alpha+\\beta+k-1)} = \\prod_{j=0}^{k-1} \\frac{\\alpha + j}{\\alpha+\\beta + j}$$\n这种乘积形式在计算上很方便，因为它避免了直接计算伽马函数。\n\n对 $k \\in \\{1, 2, 3, 4\\}$ 使用此恒等式，我们计算必要的理论量：\n1. 理论均值 $\\mu$：\n$$\\mu = \\mathbb{E}[T^1] = \\frac{\\alpha}{\\alpha+\\beta}$$\n2. 理论方差 $\\sigma^2$：\n$$\\sigma^2 = \\mathbb{E}[T^2] - \\mu^2, \\quad \\text{其中} \\quad \\mathbb{E}[T^2] = \\frac{\\alpha(\\alpha+1)}{(\\alpha+\\beta)(\\alpha+\\beta+1)}$$\n3. 四阶中心矩 $\\mu_4$：\n$$\\mu_4 = \\mathbb{E}[(T-\\mu)^4] = \\mathbb{E}[T^4] - 4\\mu\\mathbb{E}[T^3] + 6\\mu^2\\mathbb{E}[T^2] - 3\\mu^4$$\n其中 $\\mathbb{E}[T^3]$ 和 $\\mathbb{E}[T^4]$ 从乘积公式计算得出。\n4. 无偏样本方差 $s^2$ 的方差。对于一个大小为 $n$ 的独立同分布（i.i.d.）样本， $s^2 = \\frac{1}{n-1}\\sum_{i=1}^n(T_i - \\hat{\\mu})^2$ 的方差由下式给出：\n$$\\mathrm{Var}(s^2) = \\frac{1}{n}\\left(\\mu_4 - \\frac{n-3}{n-1}\\sigma^4\\right)$$\n\n对于一个给定的 $(\\alpha, \\beta)$ 对，验证流程如下：\n1. 生成一个大小为 $n = 50000$ 的样本。这通过首先从 $\\mathrm{Gamma}(\\alpha, 1)$ 中抽取 $n$ 个样本形成向量 $X$，并从 $\\mathrm{Gamma}(\\beta, 1)$ 中抽取 $n$ 个样本形成向量 $Y$ 来完成。然后逐元素计算贝塔分布随机变量 $T = X / (X+Y)$。\n2. 从此样本中，计算样本均值 $\\hat{\\mu}$ 和无偏样本方差 $s^2$（分母为 $n-1$）。\n3. 中心极限定理表明，对于大样本 $n$，样本均值 $\\hat{\\mu}$ 近似服从均值为 $\\mu$、方差为 $\\sigma^2/n$ 的正态分布。类似地，样本方差 $s^2$ 近似服从均值为 $\\sigma^2$、方差为 $\\mathrm{Var}(s^2)$ 的正态分布。我们使用这些结果来定义两个标准化差异：\n$$Z_{\\mathrm{mean}} = \\frac{|\\hat{\\mu} - \\mu|}{\\sqrt{\\sigma^2/n}}, \\qquad Z_{\\mathrm{var}} = \\frac{|s^2 - \\sigma^2|}{\\sqrt{\\mathrm{Var}(s^2)}}$$\n4. 如果两个差异都低于指定的阈值 $\\tau = 4.5$，则宣布该测试用例通过。这个阈值对应一个非常严格的置信水平，因为一个标准正态变量的绝对值超过 $4.5$ 的概率极小（$P(|Z|  4.5) \\approx 6.8 \\times 10^{-6}$）。\n\n该实现将包含一个主循环，遍历指定的 $(\\alpha, \\beta)$ 对网格。对于每一对，它将计算理论矩，生成随机样本，计算经验统计量，并评估通过/失败标准。为随机数生成器设置一个固定的种子可以确保测试结果的可复现性。最终输出将是一个布尔值列表，每个值对应一个测试用例，表明其是否通过了验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and stress-tests a Beta variate generator.\n\n    The generator is based on the ratio of two Gamma variates. Its output\n    is validated by comparing the empirical mean and variance of large samples\n    against their theoretical values derived from first principles.\n    The test is performed across a grid of shape parameter pairs (alpha, beta).\n    \"\"\"\n\n    # 4. Test suite and coverage:\n    # Use a common sample size n = 50000 for every case.\n    N_SAMPLES = 50000\n    # Use the following grid of (α,β) pairs.\n    TEST_CASES = [\n        (0.1, 0.1), (0.1, 5.0), (5.0, 0.1), (0.5, 0.5), (1.0, 1.0),\n        (2.0, 5.0), (5.0, 2.0), (50.0, 50.0), (100.0, 1.0), (1.0, 100.0)\n    ]\n    # To ensure reproducibility, fix a deterministic seed.\n    RNG_SEED = 12345\n    # Use threshold τ = 4.5.\n    TAU = 4.5\n\n    rng = np.random.default_rng(RNG_SEED)\n    results = []\n\n    def _compute_theoretical_moments(alpha, beta, n):\n        \"\"\"\n        Computes theoretical moments for the Beta(alpha, beta) distribution.\n        \n        Args:\n            alpha (float): The alpha shape parameter.\n            beta (float): The beta shape parameter.\n            n (int): The sample size.\n\n        Returns:\n            A tuple containing:\n            - mu (float): Theoretical mean.\n            - sigma_sq (float): Theoretical variance.\n            - var_s_sq (float): Theoretical variance of the sample variance.\n        \"\"\"\n        # 2. Theoretical targets from core definitions:\n        # Use the raw moment identity.\n        e1 = (alpha) / (alpha + beta)\n        e2 = e1 * (alpha + 1) / (alpha + beta + 1)\n        e3 = e2 * (alpha + 2) / (alpha + beta + 2)\n        e4 = e3 * (alpha + 3) / (alpha + beta + 3)\n\n        mu = e1\n        sigma_sq = e2 - mu**2\n\n        # 2 ... and the fourth central moment\n        mu4 = e4 - 4 * mu * e3 + 6 * mu**2 * e2 - 3 * mu**4\n        \n        # 2 ... use the general identity for the variance of the unbiased sample variance s^2\n        if n > 1:\n            var_s_sq = (1 / n) * (mu4 - ((n - 3) / (n - 1)) * sigma_sq**2)\n        else:\n            var_s_sq = np.nan # Undefined for n=1\n            \n        return mu, sigma_sq, var_s_sq\n\n    def _generate_beta_samples(alpha, beta, n, generator):\n        \"\"\"\n        Generates beta variates using the Gamma ratio method.\n\n        Args:\n            alpha (float): The alpha shape parameter.\n            beta (float): The beta shape parameter.\n            n (int): The number of samples to generate.\n            generator (np.random.Generator): The random number generator instance.\n\n        Returns:\n            np.ndarray: An array of n beta variates.\n        \"\"\"\n        # 1. Fundamental base and generator specification:\n        # Use the definition that if X ~ Gamma(α,1) and Y ~ Gamma(β,1) are\n        # independent, then T = X/(X+Y) has a Beta(α,β) distribution.\n        x_samples = generator.gamma(shape=alpha, scale=1.0, size=n)\n        y_samples = generator.gamma(shape=beta, scale=1.0, size=n)\n        \n        # Avoid division by zero if both samples are zero, though highly unlikely.\n        denominator = x_samples + y_samples\n        # Set to a very small positive number where denominator is zero\n        denominator[denominator == 0] = 1e-300\n        \n        return x_samples / denominator\n\n    for alpha, beta in TEST_CASES:\n        # Compute theoretical targets\n        mu, sigma_sq, var_s_sq = _compute_theoretical_moments(alpha, beta, N_SAMPLES)\n        \n        # Generate samples\n        samples = _generate_beta_samples(alpha, beta, N_SAMPLES, rng)\n        \n        # Compute empirical statistics\n        mu_hat = np.mean(samples)\n        s_sq = np.var(samples, ddof=1) # Unbiased sample variance with n-1\n\n        # 3. Statistical verification criteria:\n        # Define the standardized discrepancies\n        std_err_mean = np.sqrt(sigma_sq / N_SAMPLES)\n        std_err_var = np.sqrt(var_s_sq)\n        \n        z_mean = np.abs(mu_hat - mu) / std_err_mean if std_err_mean > 0 else 0.0\n        z_var = np.abs(s_sq - sigma_sq) / std_err_var if std_err_var > 0 else 0.0\n\n        # Declare a test case as passing if both criteria are met\n        passed = (z_mean = TAU) and (z_var = TAU)\n        results.append(passed)\n\n    # 5. Program input and output:\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3292115"}]}