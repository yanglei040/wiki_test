{"hands_on_practices": [{"introduction": "在金字塔算法能够高速生成随机数之前，需要一个关键的预计算步骤来构建其层级结构。本练习聚焦于实现这一设置阶段，我们将目标分布划分为等面积的水平矩形。通过此练习 [@problem_id:3356972]，您将获得使用数值求根和积分技术的实践经验，这些技术构成了金字塔方法的几何基础。", "problem": "考虑一个定义在非负实数轴 $[0,\\infty)$ 上的非负、可积、单调不增的概率密度函数 $f$，其总质量为 $$S = \\int_{0}^{\\infty} f(x)\\,dx.$$ Ziggurat 方法通过将其质量划分为等目标面积的层，构建一组堆叠的矩形，以支持对 $f$ 的接受-拒绝采样。一种对此类层进行参数化的严谨方法是采用等面积垂直划分：对于给定的整数 $n \\ge 1$，定义一个横坐标序列 $$0 = x_0  x_1  \\dots  x_{n-1}  x_n$$ 和相应的纵坐标序列 $$y_i = f(x_i)\\quad \\text{for}\\quad i=0,1,\\dots,n,$$ 使得等面积条件 $$\\int_{x_{i-1}}^{x_i} f(x)\\,dx = A \\quad \\text{for all}\\quad i=1,2,\\dots,n$$ 成立，其中 $$A = \\frac{S}{n}.$$ 因为 $f$ 是可积且非增的，所以累积积分 $$F(x) = \\int_{0}^{x} f(u)\\,du$$ 是连续的，在 $f>0$ 的区间上是严格递增的，并且满足 $\\lim_{x\\to\\infty}F(x)=S$。因此，对于 $i=1,2,\\dots,n-1$，方程 $$F(x_i) - F(x_{i-1}) = A$$ 具有唯一的有限解 $x_i$。对于末尾索引 $i=n$，在精确数学中解为 $x_n = +\\infty$；在数值计算中，必须用一个有限的替代值来近似 $x_n$，该替代值需达到规定的尾部容差。\n\n您的任务是设计并实现一个构造性算法，使用数值求根和对 $f$ 的数值积分，来预计算满足上述性质的数组 $\\{x_i\\}_{i=0}^{n}$ 和 $\\{y_i\\}_{i=0}^{n}$。您的算法必须：\n\n- 通过对 $f$ 在 $[0,\\infty)$ 上进行数值积分来计算 $S$。\n- 设置 $A = S/n$。\n- 初始化 $x_0 = 0, y_0 = f(0)$。\n- 对于 $i=1,\\dots,n-1$，通过区间求根法求解方程 $$F(x_i) - F(x_{i-1}) - A = 0$$ 以得到 $x_i$，其中 $$F(x) = \\int_{0}^{x} f(u)\\,du,$$ 然后设置 $y_i = f(x_i)$。\n- 对于末尾索引 $i=n$，通过求解 $$F(x_n) = S - \\varepsilon$$ 来数值近似 $x_n$，其中 $\\varepsilon > 0$ 是一个指定的容差，然后设置 $y_n = f(x_n)$。\n- 通过计算 $$E = \\max_{1\\le i\\le n}\\left|\\int_{x_{i-1}}^{x_i} f(x)\\,dx - A\\right|$$ 来数值验证等面积条件在一个小的数值误差范围内成立。\n\n该算法必须为任何满足上述假设的 $f$ 通用实现，并且必须使用数值积分来进行积分计算，使用区间求根法来完成反演任务。\n\n测试套件：\n为以下测试用例实现并运行您的算法。在每个用例中，最终需要报告的量是上面定义的实数 $E$。\n\n- 用例 1 (正常路径): $f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\!\\big(-\\frac{x^2}{2}\\big)$ for $x\\ge 0$ (限制在 $[0,\\infty)$ 上的标准正态密度)，其中 $n=8$，尾部容差 $\\varepsilon = 10^{-12}$。\n- 用例 2 (平滑指数): $f(x) = e^{-x}$ for $x\\ge 0$ (速率为 $1$ 的指数密度)，其中 $n=64$，尾部容差 $\\varepsilon = 10^{-12}$。\n- 用例 3 (边界条件): $f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\!\\big(-\\frac{x^2}{2}\\big)$ for $x\\ge 0$，其中 $n=1$，尾部容差 $\\varepsilon = 10^{-12}$。\n- 用例 4 (大 $n$ 压力测试): $f(x) = e^{-x}$ for $x\\ge 0$，其中 $n=256$，尾部容差 $\\varepsilon = 10^{-12}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用逗号分隔并括在方括号中的结果列表，结果顺序与上面列出的用例顺序一致。确切地说，打印的行必须是以下形式\n$$[E_1,E_2,E_3,E_4],$$\n其中 $E_k$ 是为第 $k$ 个用例计算出的实数。不应打印任何其他文本。", "solution": "用户提供了一个来自随机模拟数值方法领域的、定义明确的问题陈述。任务是实现并测试一个构造性算法，用于预计算等面积垂直划分的参数，这是用于随机变量生成的 Ziggurat 方法的一个核心组成部分。该问题具有科学依据、形式化规定且内部一致。因此，它被认为是有效的。\n\n该问题要求为给定的在 $[0, \\infty)$ 上的非负、可积且单调不增的函数 $f(x)$，构造一个横坐标序列 $0 = x_0  x_1  \\dots  x_n$ 和相应的纵坐标序列 $y_i = f(x_i)$。该构造必须满足 $n$ 个垂直条带的等面积条件。\n\n算法流程如下：\n\n**1. 总质量和目标面积的计算**\n首先，使用数值积分计算函数 $f$ 在其定义域 $[0, \\infty)$ 上的总质量（积分）：\n$$\nS = \\int_{0}^{\\infty} f(x)\\,dx\n$$\n定义域被划分为 $n$ 个段，每个段旨在包含总质量的相等部分。因此，每个段的目标面积是：\n$$\nA = \\frac{S}{n}\n$$\n\n**2. 累积积分函数**\n构造的核心依赖于累积积分函数 $F(x)$，其定义为：\n$$\nF(x) = \\int_{0}^{x} f(u)\\,du\n$$\n由于 $f(x) \\ge 0$，$F(x)$ 是一个单调不减函数。又因为 $f$ 也被指定为非增函数，所以 $F(x)$ 是一个凹函数。在 $f(x) > 0$ 的区间上 $F(x)$ 的严格单调性保证了其反函数是良定义的，这对于找到横坐标 $x_i$至关重要。在此实现中，将使用数值积分来计算任意给定 $x$ 处的 $F(x)$。\n\n**3. 横坐标的迭代构造**\n横坐标 $x_i$ 是按顺序确定的。\n\n- **初始化**：序列从原点的边界条件开始：\n  $$\n  x_0 = 0, \\quad y_0 = f(0)\n  $$\n\n- **内部横坐标 ($i = 1, \\dots, n-1$)**：对于每个内部索引 $i$，横坐标 $x_i$ 由等面积条件定义。到 $x_i$ 为止的累积面积理想情况下应为 $i \\cdot A$。这导出了方程：\n  $$\n  F(x_i) = \\int_{0}^{x_i} f(u)\\,du = i \\cdot A\n  $$\n  必须解此方程以求得 $x_i$。我们可以定义一个函数 $g_i(x) = F(x) - iA$ 并找到它的根。由于 $F(x)$ 是单调的，存在唯一的根。我们采用一个区间求根算法，例如 Brent 方法，它既稳健又高效。要找到 $g_i(x) = 0$ 的根，我们必须提供一个区间 $[a, b]$ 使得 $g_i(a) \\cdot g_i(b)  0$。一个自然的下界是 $a = x_{i-1}$，因为 $x_i$ 序列必须是严格递增的。在这一点上，$F(x_{i-1}) \\approx (i-1)A$，这意味着 $g_i(x_{i-1}) = F(x_{i-1}) - iA \\approx (i-1)A - iA = -A  0$。可以通过扩展搜索找到一个上界 $b > x_{i-1}$，直到 $g_i(b) > 0$。一旦数值上确定了 $x_i$，相应的纵坐标就是 $y_i = f(x_i)$。\n\n- **末端横坐标 ($i=n$)**：在精确数学中，$x_n = \\infty$ 将确保最后一个段包含剩余的面积 $A$。对于数值计算，$x_n$ 由一个有限值近似，该值捕获了分布尾部几乎所有的剩余质量，只留下一个小的、预定的残余面积 $\\varepsilon$。条件是：\n  $$\n  \\int_{x_n}^{\\infty} f(x)\\,dx = \\varepsilon\n  $$\n  这等价于找到 $x_n$ 使得 $F(x_n) = S - \\varepsilon$。我们通过找到函数 $h(x) = F(x) - (S - \\varepsilon)$ 的根来求解 $x_n$。区间确定和求根的过程与用于内部横坐标的过程类似，使用 $x_{n-1}$ 作为搜索的下界。最后，$y_n = f(x_n)$。\n\n**4. 数值验证**\n最后一步是通过计算最大绝对误差 $E$ 来验证构造的准确性。对于每个段 $i \\in \\{1, \\dots, n\\}$，通过数值积分计算曲线下的实际面积：\n$$\nA_i = \\int_{x_{i-1}}^{x_i} f(x)\\,dx\n$$\n每个段的误差是 $|A_i - A|$。总误差度量 $E$ 是这些单个误差的最大值：\n$$\nE = \\max_{1 \\le i \\le n} |A_i - A|\n$$\n根据 $x_n$ 的定义，最后一段的面积 $A_n = F(x_n) - F(x_{n-1})$ 将约等于 $(S-\\varepsilon) - (n-1)A = (nA-\\varepsilon) - (n-1)A = A-\\varepsilon$。因此，其对误差的贡献是 $| (A-\\varepsilon) - A | = \\varepsilon$。因此，总误差 $E$ 预计至少为 $\\varepsilon$，并且如果其他段的积分和求根的数值误差较小，则 $E$ 将主要由 $\\varepsilon$ 决定。为确保这一点，数值积分程序的容差设置必须比 $\\varepsilon$ 更严格。\n\n此过程使用 `scipy` 库实现，特别是使用 `scipy.integrate.quad` 进行所有数值积分，并使用 `scipy.optimize.brentq` 进行区间求根。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\nfrom typing import Callable\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def compute_ziggurat_params(f: Callable[[float], float], n: int, epsilon: float) -> float:\n        \"\"\"\n        Constructs the Ziggurat partitions and computes the maximum area error.\n\n        Args:\n            f: The probability density function on [0, inf).\n            n: The number of partitions.\n            epsilon: The tail tolerance for the last partition.\n\n        Returns:\n            The maximum error E.\n        \"\"\"\n        # Define high-precision quadrature options to ensure numerical errors\n        # do not dominate the prescribed tolerance epsilon.\n        quad_opts = {'epsabs': 1e-14, 'epsrel': 1e-14}\n        \n        # Step 1: Compute the total mass S.\n        S, _ = quad(f, 0, np.inf, **quad_opts)\n\n        # Step 2: Compute the target area A.\n        A = S / n\n\n        # Initialize arrays for abscissae and ordinates.\n        x = np.zeros(n + 1)\n        y = np.zeros(n + 1)\n\n        # Step 3: Initialize x_0 and y_0.\n        x[0] = 0.0\n        y[0] = f(x[0])\n\n        memoized_F = {}\n        def F(val: float) -> float:\n            \"\"\"Cumulative integral F(x) with memoization for performance.\"\"\"\n            if val in memoized_F:\n                return memoized_F[val]\n            if val == 0:\n                return 0.0\n            res, _ = quad(f, 0, val, **quad_opts)\n            memoized_F[val] = res\n            return res\n\n        # Step 4: Compute interior abscissae x_i for i = 1, ..., n-1.\n        if n > 1:\n            for i in range(1, n):\n                target_F = i * A\n                \n                # Define the function whose root we need to find.\n                g = lambda val: F(val) - target_F\n                \n                # Bracket the root. The lower bound is the previous abscissa.\n                a = x[i-1]\n                \n                # The value at the lower bound should be negative.\n                # g(a) = F(x_{i-1}) - i*A ≈ (i-1)*A - i*A = -A\n                \n                # Perform an expanding search for the upper bound.\n                b = a + 1.0 \n                # In the rare case of starting at a root...\n                if g(a) == 0:\n                    a -= 1e-9 \n                \n                while g(b)  0:\n                    a = b\n                    b *= 1.5\n                \n                # Solve for x_i using Brent's method.\n                x[i] = brentq(g, a, b)\n                y[i] = f(x[i])\n\n        # Step 5: Compute the terminal abscissa x_n.\n        target_F_n = S - epsilon\n        \n        # Define the function for the terminal root-finding problem.\n        h = lambda val: F(val) - target_F_n\n        \n        # Bracket the root for x_n. Lower bound is x_{n-1}.\n        a_n = x[n-1]\n        \n        # Expanding search for the upper bound.\n        b_n = a_n + 1.0\n        # h(a_n) = F(x_{n-1}) - (S - epsilon) ≈ (n-1)*A - S + epsilon = -A + epsilon  0\n        if h(a_n) >= 0: # Handle edge case where n=1 and S-epsilon is very small\n            b_n = a_n\n            a_n -= 1.0\n            while h(a_n) >= 0: a_n -= 1.0\n\n        while h(b_n)  0:\n            a_n = b_n\n            b_n *= 1.5\n\n        # Solve for x_n.\n        x[n] = brentq(h, a_n, b_n)\n        y[n] = f(x[n])\n\n        # Step 6: Verify the equal-area condition numerically.\n        errors = []\n        for i in range(1, n + 1):\n            slice_area, _ = quad(f, x[i-1], x[i], **quad_opts)\n            errors.append(abs(slice_area - A))\n            \n        E = max(errors)\n        return E\n\n    # Test Suite\n    # Case 1: Standard normal density (half-normal)\n    f_normal = lambda x: (1.0 / np.sqrt(2.0 * np.pi)) * np.exp(-x**2 / 2.0)\n    \n    # Case 2: Standard exponential density\n    f_exp = lambda x: np.exp(-x)\n\n    test_cases = [\n        {'f': f_normal, 'n': 8, 'epsilon': 1e-12},\n        {'f': f_exp, 'n': 64, 'epsilon': 1e-12},\n        {'f': f_normal, 'n': 1, 'epsilon': 1e-12},\n        {'f': f_exp, 'n': 256, 'epsilon': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        E = compute_ziggurat_params(case['f'], case['n'], case['epsilon'])\n        results.append(E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3356972"}, {"introduction": "金字塔方法卓越的效率源于其运行时执行，它巧妙地避免了缓慢的浮点运算。本练习 [@problem_id:3357000] 深入探讨了这一效率的核心：一个使用快速整数位切片来选择金字塔层并生成坐标的映射。通过实现和验证此映射，您将理解该算法高性能的来源以及随机位与几何采样之间的相互作用。", "problem": "您正在实现 Ziggurat 方法中使用的核心纯整数映射原语，该方法用于将均匀分布的 $32$ 位整数转换为包含层索引和矩形内坐标的元组。请考虑以下一般要求。您必须设计一个从 $32$ 位均匀分布整数 $R \\in \\{0,1,\\dots,2^{32}-1\\}$ 到三元组 $(i,u,v)$ 的映射，其中 $i$ 是层索引，$(u,v)$ 是单位正方形内的坐标，这些坐标稍后将根据所选层的矩形宽度和高度进行缩放。该映射必须满足以下约束条件。\n\n1. 位切片设计：\n   - 选择非负整数 $b,m,n$，使得 $b + m + n = 32$。\n   - 该映射必须仅依赖于位切片、整数移位、掩码和比较。具体而言，在从 $R$ 中提取 $i,u,v$ 时，不得使用浮点乘法。\n   - 将 $(u,v)$ 解释为定点分数，即形式为 $u = U / 2^m$ 和 $v = V / 2^n$ 的有理数，其中整数 $U \\in \\{0,1,\\dots,2^m-1\\}$ 和 $V \\in \\{0,1,\\dots,2^n-1\\}$。\n\n2. 层数支持：\n   - 对于层数 $K = 2^b$ 的情况，该映射必须是在上述定点解释下，从 $\\{0,1,\\dots,2^{32}-1\\}$ 到 $\\{0,1,\\dots,K-1\\} \\times \\{0,1,\\dots,2^m-1\\} \\times \\{0,1,\\dots,2^n-1\\}$ 的一个双射，并且它必须能导出 $i$、$u$ 和 $v$ 之间的独立性。\n   - 对于层数 $K \\le 2^b$ 不是2的幂的情况，必须通过对层索引进行拒绝采样来扩展映射，使得 $i$ 在 $\\{0,1,\\dots,K-1\\}$ 上精确均匀分布，同时仍然只使用整数运算，并保持被接受的 $i$ 和定点坐标 $(u,v)$ 之间的独立性。拒绝采样必须仅基于切分出的索引比特位。\n\n3. 证明义务：\n   - 从一个 $32$ 位均匀整数在其状态空间上是均匀的，以及不同比特位是参数为 $1/2$ 的独立伯努利分布这两个基本事实出发，证明您的映射能够产生 $i$ 和 $(u,v)$ 在其离散网格上的边缘均匀性，并证明在 $K = 2^b$ 和拒绝采样情况 $K \\le 2^b$ 下的独立性性质。\n\n4. 程序要求：\n   - 为两种场景实现您的映射：\n     (a) $K = 2^b$，其中 $(b,m,n) = (8,12,12)$。\n     (b) $K = 250 \\le 2^8$，其中 $(b,m,n) = (8,12,12)$，仅使用对最高 $b$ 个比特的拒绝采样。\n   - 为进行测试，您将使用固定种子的蒙特卡洛模拟。所有随机性都来自 $32$ 位均匀整数的独立抽取。\n\n5. 统计测试套件和输出：\n   实现以下测试。每个测试必须根据指定的统计决策规则产生一个布尔值。使用显著性水平 $\\alpha = 0.01$。当需要进行卡方检验时，使用标准的卡方拟合优度检验或卡方独立性检验，不使用 Yates 连续性校正。\n\n   测试集 A（2的幂次方情况）：\n   - 参数：$K = 2^8$，$b = 8$，$m = 12$，$n = 12$，样本量 $N_A = 400000$。\n   - A1：通过具有相等期望计数的卡方拟合优度检验，检验层索引 $i$ 在 $\\{0,1,\\dots,255\\}$ 上的均匀性。输出布尔值 $T_{A1}$，指示在水平 $\\alpha$ 下原假设是否未被拒绝。\n   - A2：通过具有相等期望计数的卡方拟合优度检验，检验水平定点坐标 $U \\in \\{0,1,\\dots,4095\\}$ 的均匀性。输出布尔值 $T_{A2}$。\n   - A3：通过对 $256 \\times 16$ 列联表进行卡方独立性检验，检验 $i$ 和由 $U$ 的最高 $4$ 个比特定义的粗化水平坐标 $U_{\\mathrm{coarse}} \\in \\{0,1,\\dots,15\\}$ 之间的独立性。输出布尔值 $T_{A3}$。\n\n   测试集 B（2的幂次方情况下位切片的边界确定性）：\n   - 参数：$K = 2^8$，$b = 8$，$m = 12$，$n = 12$。\n   - B1：对于 $R = 0$，验证 $(i,U,V) = (0,0,0)$。输出布尔值 $T_{B1}$。\n   - B2：对于 $R = 2^{32}-1$，验证 $(i,U,V) = (255,4095,4095)$。输出布尔值 $T_{B2}$。\n\n   测试集 C（非2的幂次方情况，对索引比特进行拒绝采样）：\n   - 参数：$K = 250$，$b = 8$，$m = 12$，$n = 12$，样本量 $N_C = 300000$。\n   - C1：仅使用对索引比特的拒绝采样，通过具有相等期望计数的卡方拟合优度检验，检验 $i$ 在 $\\{0,1,\\dots,249\\}$ 上的均匀性。输出布尔值 $T_{C1}$。\n   - C2：通过具有相等期望计数的卡方拟合优度检验，检验 $U \\in \\{0,1,\\dots,4095\\}$ 的均匀性。输出布尔值 $T_{C2}$。\n   - C3：通过对 $250 \\times 16$ 列联表进行卡方独立性检验，检验 $i$ 和 $U_{\\mathrm{coarse}} \\in \\{0,1,\\dots,15\\}$ 之间的独立性。输出布尔值 $T_{C3}$。\n\n6. 最终输出格式：\n   您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[true1,true2,...]\"），顺序如下：\n   - $[T_{A1}, T_{A2}, T_{A3}, T_{B1}, T_{B2}, T_{C1}, T_{C2}, T_{C3}]$。\n\n所有角度都是无量纲的，不涉及物理单位。所有答案必须是布尔值，打印为 Python 字面量 true 或 false。整个程序必须在没有输入的情况下运行，使用其自身的内部测试套件和固定的随机种子以保证可复现性。确保所有与映射相关的计算仅使用整数位切片、移位、掩码、比较和整数算术。浮点运算仅可用于统计测试，且不影响映射设计本身。", "solution": "我们从离散均匀随机变量在二进制表示上的基本事实开始。设 $R$ 在 $\\{0,1,\\dots,2^{32}-1\\}$ 上均匀分布。那么：\n\n1. 从 $R$ 到其比特向量 $(B_{31},B_{30},\\dots,B_{0}) \\in \\{0,1\\}^{32}$（其中 $R = \\sum_{j=0}^{31} B_j 2^j$）的映射是 $\\{0,1,\\dots,2^{32}-1\\}$ 和 $\\{0,1\\}^{32}$ 之间的一个双射。因此，$R$ 的均匀性意味着比特向量在 $\\{0,1\\}^{32}$ 上是均匀分布的。\n\n2. 不同比特位的独立性：对于任意子集 $S \\subset \\{0,1,\\dots,31\\}$，比特 $(B_j)_{j \\in S}$ 是独立的，并且每个边缘分布 $B_j$ 都是参数为 $1/2$ 的伯努利分布。这源于比特向量在笛卡尔积 $\\{0,1\\}^{32}$ 上的均匀性。\n\n利用这些事实，我们通过位切片设计一个从 $R$ 到 $(i,u,v)$ 的纯整数映射。选择非负整数 $b,m,n$ 使得 $b+m+n=32$，并定义整数值坐标\n$$\nI(R) \\equiv \\left\\lfloor \\frac{R}{2^{32-b}} \\right\\rfloor, \\quad\nU(R) \\equiv \\left\\lfloor \\frac{R \\bmod 2^{32-b}}{2^n} \\right\\rfloor, \\quad\nV(R) \\equiv R \\bmod 2^n.\n$$\n等价地，使用移位和掩码操作，\n$$\nI(R) = R \\gg (32-b), \\quad\nU(R) = (R \\gg n) \\;\\\\amp;\\; (2^m-1), \\quad\nV(R) = R \\;\\\\amp;\\; (2^n-1),\n$$\n其中 $\\gg$ 是无符号整数的算术右移，$\\$ 是按位与。定点坐标为 $u(R) = U(R)/2^m$ 和 $v(R) = V(R)/2^n$。\n\n情况1：层数为2的幂 $K = 2^b$。\n我们断言映射\n$$\n\\Phi: \\{0,1,\\dots,2^{32}-1\\} \\to \\{0,1,\\dots,2^b-1\\} \\times \\{0,1,\\dots,2^m-1\\} \\times \\{0,1,\\dots,2^n-1\\},\n$$\n由 $\\Phi(R) = \\big(I(R), U(R), V(R)\\big)$ 给出，是一个双射。这是因为位切片将 $32$ 个比特划分为三个长度分别为 $b,m,n$ 的不相交的块；每个三元组 $(i,u,v)$ 都精确对应一个在这些位置上具有相应比特的 $R$。因此：\n- $I$ 的均匀性：由于 $\\Phi$ 是一个双射且 $R$ 在一个大小为 $2^{32}$ 的集合上均匀分布，因此 $I$ 的边缘分布在 $\\{0,\\dots,2^b-1\\}$ 上是均匀的，因为每个 $i$ 都出现在恰好 $2^{m+n} = 2^{32-b}$ 个原像中。\n- $U$ 和 $V$ 的均匀性：类似地，每个 $u$ 和每个 $v$ 分别出现在恰好 $2^{b+n}$ 和 $2^{b+m}$ 个原像中，从而在其各自的离散网格上产生均匀分布。\n- 独立性：因为比特块是不相交的，并且比特向量在 $\\{0,1\\}^{32}$ 上是均匀的，所以三元组 $(I,U,V)$ 可以分解为独立坐标的笛卡尔积。更明确地说，对于任何 $(i,u,v)$，\n$$\n\\mathbb{P}(I=i, U=u, V=v) = \\frac{1}{2^{32}} = \\frac{1}{2^b} \\cdot \\frac{1}{2^m} \\cdot \\frac{1}{2^n} = \\mathbb{P}(I=i)\\, \\mathbb{P}(U=u)\\, \\mathbb{P}(V=v).\n$$\n因此 $I$、$U$ 和 $V$ 是相互独立的，定点分数 $u = U/2^m$ 和 $v = V/2^n$ 也继承了这些性质。\n\n情况2：层数不为2的幂 $K \\le 2^b$，对索引比特进行拒绝采样。\n像之前一样定义 $I^\\ast(R) = \\left\\lfloor R/2^{32-b} \\right\\rfloor$，但现在仅当 $I^\\ast(R) \\in \\{0,1,\\dots,K-1\\}$ 时接受该抽样；否则，独立地重新抽取一个新的 $R$ 并重复此过程。接受后，使用同一个被接受的 $R$ 的较低 $m$ 和 $n$ 个比特来定义 $U(R)$ 和 $V(R)$，方法如上。\n\n我们现在证明：\n- 被接受的索引 $I$ 在 $\\{0,1,\\dots,K-1\\}$ 上是均匀的。确实，对于每个 $i \\in \\{0,\\dots,K-1\\}$，接受事件是 $\\{I^\\ast(R) = i\\}$，其概率为 $2^{32-b}/2^{32} = 2^{-b}$。在接受的条件下，$I=i$ 的概率是 $\\frac{2^{-b}}{K \\cdot 2^{-b}} = 1/K$。\n- $(U,V)$ 和 $I$ 之间的独立性：接受与否的决定仅取决于最高的 $b$ 个比特。根据不相交比特块的独立性，较低的 $m+n$ 个比特独立于最高的 $b$ 个比特。以接受事件（它仅是最高比特的函数）为条件，不会改变较低比特的分布；因此 $(U,V)$ 仍然独立于接受指示符以及实现的 $I$。特别地，$\\mathbb{P}(U=u, V=v \\mid I=i) = 2^{-(m+n)}$，所以 $(U,V)$ 在其网格上是均匀的，且独立于 $I$。\n- $U$ 和 $V$ 的均匀性：直接从上述独立性论证中得出。\n\n因此，这种拒绝采样方案保留了所需的均匀性和独立性，同时仅使用整数移位、掩码和比较。映射本身不使用浮点乘法；仅在解释定点分数时可能需要除以 $2^m$ 或 $2^n$，但这对于映射的正确性不是必需的，并且如果保留整数定点坐标，则可以避免。\n\n统计验证设计。\n为了对映射进行经验性验证，我们在显著性水平 $\\alpha = 0.01$ 下执行用于均匀性检验的卡方拟合優度检验和用于独立性检验的卡方检验。我们使用：\n- 测试集 A，针对 $K=2^8$，$(b,m,n)=(8,12,12)$ 和样本量 $N_A = 400000$，检验 $I$ 的均匀性、$U$ 的均匀性，以及 $I$ 与由 $U$ 的最高4位组成的粗化 $U_{\\mathrm{coarse}}$ 之间的独立性。\n- 测试集 B，针对确定性边界 $R=0$ 和 $R=2^{32}-1$，验证精确的位切片输出。\n- 测试集 C，针对 $K=250 \\le 2^8$ 并采用拒绝采样，$(b,m,n)=(8,12,12)$ 和样本量 $N_C = 300000$，检验 $I$ 的均匀性、$U$ 的均匀性，以及 $I$ 与 $U_{\\mathrm{coarse}}$ 之间的独立性。\n\n我们固定伪随机数生成器的种子以确保可复现性。预期的输出是布尔值：\n- 如果映射产生的分布在水平 $\\alpha$ 下与均匀性和独立性一致，$T_{A1}, T_{A2}, T_{A3}$ 应为 true。\n- 如果边界位切片实现正确，$T_{B1}, T_{B2}$ 应都为 true。\n- 对于基于拒绝采样的映射，$T_{C1}, T_{C2}, T_{C3}$ 应为 true。\n\n所有映射计算仅使用整数位切片。浮点运算仅出现在统计测试函数内部，不影响映射的均匀性属性。最终程序按指定顺序汇总八个布尔值，并按要求将它们打印在单行上。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chisquare, chi2_contingency\n\n# Mapping functions using integer-only bit slicing.\n\ndef slice_bits_power_of_two(R_uint32, b, m, n):\n    \"\"\"\n    Vectorized bit-slicing mapping for K = 2^b.\n    Input:\n        R_uint32: np.ndarray of dtype np.uint32\n        b, m, n: nonnegative integers with b+m+n = 32\n    Output:\n        i: np.ndarray of indices in [0, 2^b-1]\n        U: np.ndarray of ints in [0, 2^m-1] (fixed-point horizontal coordinate)\n        V: np.ndarray of ints in [0, 2^n-1] (fixed-point vertical coordinate)\n    \"\"\"\n    assert b + m + n == 32\n    R = R_uint32.astype(np.uint32)\n    if b == 0:\n        i = np.zeros_like(R, dtype=np.uint32)\n    else:\n        i = (R >> np.uint32(32 - b)).astype(np.uint32)\n    if n == 0:\n        V = np.zeros_like(R, dtype=np.uint32)\n        U = R  ((np.uint32(1)  np.uint32(m)) - np.uint32(1))\n    else:\n        V = (R  ((np.uint32(1)  np.uint32(n)) - np.uint32(1))).astype(np.uint32)\n        if m == 0:\n            U = np.zeros_like(R, dtype=np.uint32)\n        else:\n            U = ((R >> np.uint32(n))  ((np.uint32(1)  np.uint32(m)) - np.uint32(1))).astype(np.uint32)\n    return i, U, V\n\ndef slice_bits_with_rejection_K_le_2b(size, K, b, m, n, rng):\n    \"\"\"\n    Vectorized rejection scheme on the index bits only for K = 2^b.\n    Returns exactly 'size' accepted samples of (i, U, V).\n    \"\"\"\n    assert b + m + n == 32\n    assert 1 = K = (1  b)\n    i_out = np.empty(size, dtype=np.uint32)\n    U_out = np.empty(size, dtype=np.uint32)\n    V_out = np.empty(size, dtype=np.uint32)\n    filled = 0\n    # Use batches to reduce overhead; batch size chosen adaptively.\n    # Expected acceptance probability is K / 2^b.\n    acc_prob = K / (1  b)\n    # Choose a batch size that likely yields enough acceptances per batch.\n    base_batch = max(10000, int(1.5 * size / max(acc_prob, 1e-6)))\n    # Cap the batch size to keep memory reasonable\n    base_batch = min(base_batch, 1_000_000)\n\n    while filled  size:\n        # Determine how many more samples we need\n        needed = size - filled\n        # Adjust batch size for the last iteration\n        batch_size = min(base_batch, int(1.2 * needed / max(acc_prob, 1e-6)) + 10)\n        \n        R = rng.integers(0, 1  32, size=batch_size, dtype=np.uint32)\n        i, U, V = slice_bits_power_of_two(R, b, m, n)\n        mask = (i  K)\n        num_acc = int(mask.sum())\n        \n        if num_acc > 0:\n            # How many can we fit?\n            can_fit = min(num_acc, needed)\n            \n            i_out[filled:filled + can_fit] = i[mask][:can_fit]\n            U_out[filled:filled + can_fit] = U[mask][:can_fit]\n            V_out[filled:filled + can_fit] = V[mask][:can_fit]\n            filled += can_fit\n            \n    return i_out, U_out, V_out\n\n# Statistical tests.\n\ndef test_uniform_counts(values, num_categories, alpha=0.01):\n    \"\"\"\n    Chi-square goodness-of-fit test for uniformity over num_categories.\n    values: np.ndarray of nonnegative integers expected in [0, num_categories-1]\n    Returns True if p-value > alpha, else False.\n    \"\"\"\n    counts = np.bincount(values, minlength=num_categories).astype(np.int64)\n    # Ensure we restrict to exact length\n    counts = counts[:num_categories]\n    expected = np.full(num_categories, counts.sum() / num_categories)\n    stat, p = chisquare(counts, f_exp=expected)\n    return bool(p > alpha)\n\ndef test_independence(x, x_categories, y, y_categories, alpha=0.01):\n    \"\"\"\n    Chi-square test of independence on the contingency table formed by (x,y).\n    Returns True if p-value > alpha else False.\n    \"\"\"\n    # Build contingency table via flat indexing\n    flat = (x.astype(np.int64) * y_categories + y.astype(np.int64))\n    counts = np.bincount(flat, minlength=x_categories * y_categories).astype(np.int64)\n    table = counts.reshape((x_categories, y_categories))\n    chi2, p, dof, expected = chi2_contingency(table, correction=False)\n    return bool(p > alpha)\n\ndef main():\n    rng = np.random.default_rng(20250110)\n\n    # Test set A: K=2^8, (b,m,n)=(8,12,12), N_A=400000\n    b = 8\n    m = 12\n    n = 12\n    K_pow2 = 1  b\n    N_A = 400_000\n    R_A = rng.integers(0, 1  32, size=N_A, dtype=np.uint32)\n    i_A, U_A, V_A = slice_bits_power_of_two(R_A, b, m, n)\n\n    T_A1 = test_uniform_counts(i_A, K_pow2, alpha=0.01)\n    T_A2 = test_uniform_counts(U_A, 1  m, alpha=0.01)\n    # Coarse U: top 4 bits of U\n    U_A_coarse = (U_A >> np.uint32(m - 4)).astype(np.uint32)\n    T_A3 = test_independence(i_A, K_pow2, U_A_coarse, 1  4, alpha=0.01)\n\n    # Test set B: Boundary determinism for power-of-two case\n    R_low = np.uint32(0)\n    i_low, U_low, V_low = slice_bits_power_of_two(np.array([R_low], dtype=np.uint32), b, m, n)\n    T_B1 = bool((i_low[0] == 0) and (U_low[0] == 0) and (V_low[0] == 0))\n\n    R_high = np.uint32((1  32) - 1)\n    i_high, U_high, V_high = slice_bits_power_of_two(np.array([R_high], dtype=np.uint32), b, m, n)\n    T_B2 = bool((i_high[0] == (K_pow2 - 1)) and (U_high[0] == ((1  m) - 1)) and (V_high[0] == ((1  n) - 1)))\n\n    # Test set C: K=250 = 2^8, rejection on index bits only, N_C=300000\n    K_nonpow = 250\n    N_C = 300_000\n    i_C, U_C, V_C = slice_bits_with_rejection_K_le_2b(N_C, K_nonpow, b, m, n, rng)\n\n    T_C1 = test_uniform_counts(i_C, K_nonpow, alpha=0.01)\n    T_C2 = test_uniform_counts(U_C, 1  m, alpha=0.01)\n    U_C_coarse = (U_C >> np.uint32(m - 4)).astype(np.uint32)\n    T_C3 = test_independence(i_C, K_nonpow, U_C_coarse, 1  4, alpha=0.01)\n\n    results = [T_A1, T_A2, T_A3, T_B1, T_B2, T_C1, T_C2, T_C3]\n    # Convert Python bools to lowercase string literals for output\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3357000"}, {"introduction": "一个预先计算好的金字塔结构是为单一、特定的目标分布而优化的。但是，如果我们用它来对一个略有不同的分布进行采样，其性能会如何下降？本分析练习 [@problem_id:3357063] 探讨了这个关于稳健性的关键问题，要求您推导当为简单密度设计的包络被应用于更复杂的双峰目标时，其确切的接受概率。这项实践将加深您对金字塔包络与底层分布之间几何关系的理解。", "problem": "考虑$\\mathbb{R}$上的拉普拉斯密度 $g(x) = \\tfrac{1}{2}\\exp(-|x|)$。为 $g$ 构建一个单层、对称的 Ziggurat 包络，即矩形 $\\mathcal{R} = \\{(x,y): |x| \\leq w,\\ 0 \\leq y \\leq h\\}$，其中 $w > 0$ 是选定的，而 $h$ 设为 $h = g(w)$。采样过程是从 $\\mathcal{R}$ 中均匀抽取 $(X,Y)$，当且仅当对于目标密度 $f$ 满足 $Y \\leq f(X)$ 时，接受 $X$。根据设计，当 $f=g$ 时，该构造的接受概率为 $1$。\n\n现在，通过拉普拉斯密度的双组分位置混合定义一个特定的双峰目标密度，\n$$\nf(x) = (1-\\alpha)\\,g(x) + \\alpha\\,g(x-a),\n$$\n参数为 $\\alpha = \\tfrac{1}{3}$ 和 $a = \\ln 4$。设 Ziggurat 包络是基于原点的第一个峰构建的，其中 $w = \\ln 2$，因此 $h = g(w) = \\tfrac{1}{2}\\exp(-w)$。\n\n任务：\n- 仅使用基本原理，通过描述 $f$ 在 $x=0$ 和 $x=a$ 附近的局部行为，验证 $f$ 是双峰的。\n- 从拒绝采样中的接受定义出发，推导当目标为 $f$ 而不是 $g$ 时，此 Ziggurat 构造的接受概率的精确解析表达式。\n- 对给定参数，数值计算接受概率。将您的答案四舍五入到四位有效数字。\n\n您的最终答案必须是代表接受概率的单个实数（无单位）。", "solution": "首先验证问题，以确保其科学上合理、内容完整且提法恰当。\n\n### 步骤 1：提取已知条件\n- 基础密度：$g(x) = \\tfrac{1}{2}\\exp(-|x|)$\n- 目标密度：$f(x) = (1-\\alpha)\\,g(x) + \\alpha\\,g(x-a)$\n- Ziggurat 包络（矩形）：$\\mathcal{R} = \\{(x,y): |x| \\leq w,\\ 0 \\leq y \\leq h\\}$\n- 包络高度：$h = g(w)$\n- 参数 $\\alpha$：$\\alpha = \\tfrac{1}{3}$\n- 参数 $a$：$a = \\ln 4$\n- 参数 $w$：$w = \\ln 2$\n- 采样规则：从 $\\mathcal{R}$ 中均匀抽取 $(X,Y)$，如果 $Y \\leq f(X)$ 则接受 $X$。\n- 任务：验证 $f(x)$ 的双峰性，推导精确的接受概率，并将其数值计算到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述描述了一个使用简化的 Ziggurat 方法的拒绝采样场景。函数 $g(x)$ 和 $f(x)$ 是有效的概率密度（分别为拉普拉斯分布和两个拉普拉斯分布的混合）。所有参数都是明确定义的常数。任务是具体的、数学的，并且可以使用所提供的信息解决。该问题在概率论和数值方法方面有科学依据，提法恰当且客观。未发现任何缺陷。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解题推导\n\n首先，我们将目标密度 $f(x)$ 写成包含给定参数 $\\alpha = \\frac{1}{3}$ 和 $a = \\ln 4$ 的形式：\n$$f(x) = \\left(1-\\frac{1}{3}\\right)\\frac{1}{2}\\exp(-|x|) + \\frac{1}{3}\\frac{1}{2}\\exp(-|x-a|)$$\n$$f(x) = \\frac{1}{3}\\exp(-|x|) + \\frac{1}{6}\\exp(-|x - \\ln 4|)$$\n\n### 任务 1：验证双峰性\n要验证 $f(x)$ 是双峰的，我们必须证明它有两个局部极大值。函数 $|x|$ 在 $x=0$ 处有一个不可微的尖点，因此 $f(x)$ 在 $x=0$ 和 $x=a = \\ln 4$ 处不可微。我们分析其单侧导数。\n\n$f(x)$ 在 $x \\neq 0$ 和 $x \\neq a$ 处的导数为：\n$$\nf'(x) = \\begin{cases}\n\\frac{1}{3}\\exp(x) + \\frac{1}{6}\\exp(x-a)  \\text{当 } x  0 \\\\\n-\\frac{1}{3}\\exp(-x) + \\frac{1}{6}\\exp(x-a)  \\text{当 } 0  x  a \\\\\n-\\frac{1}{3}\\exp(-x) - \\frac{1}{6}\\exp(-(x-a))  \\text{当 } x > a\n\\end{cases}\n$$\n\n$x=0$ 处的行为：\n左导数为 $f'(0^-) = \\lim_{x\\to 0^-} f'(x) = \\frac{1}{3}\\exp(0) + \\frac{1}{6}\\exp(-a) = \\frac{1}{3} + \\frac{1}{6}\\exp(-\\ln 4) = \\frac{1}{3} + \\frac{1}{24} = \\frac{9}{24} > 0$。\n右导数为 $f'(0^+) = \\lim_{x\\to 0^+} f'(x) = -\\frac{1}{3}\\exp(0) + \\frac{1}{6}\\exp(-a) = -\\frac{1}{3} + \\frac{1}{24} = -\\frac{7}{24}  0$。\n由于导数从正变为负，因此 $x=0$ 是一个局部极大值。\n\n$x=a$ 处的行为：\n左导数为 $f'(a^-) = \\lim_{x\\to a^-} f'(x) = -\\frac{1}{3}\\exp(-a) + \\frac{1}{6}\\exp(0) = -\\frac{1}{3}\\cdot\\frac{1}{4} + \\frac{1}{6} = -\\frac{1}{12} + \\frac{2}{12} = \\frac{1}{12} > 0$。\n右导数为 $f'(a^+) = \\lim_{x\\to a^+} f'(x) = -\\frac{1}{3}\\exp(-a) - \\frac{1}{6}\\exp(0) = -\\frac{1}{12} - \\frac{1}{6} = -\\frac{3}{12}  0$。\n由于导数从正变为负，因此 $x=a$ 是一个局部极大值。\n\n在两个峰之间，对于 $x \\in (0, a)$，我们通过令 $f'(x)=0$ 来检查是否存在局部极小值：\n$$-\\frac{1}{3}\\exp(-x) + \\frac{1}{6}\\exp(x-a) = 0 \\implies \\exp(x-a) = 2\\exp(-x) \\implies \\exp(2x) = 2\\exp(a)$$\n当 $a=\\ln 4$ 时，我们有 $\\exp(2x) = 2 \\cdot 4 = 8$，所以 $2x = \\ln 8 = 3\\ln 2$，这给出 $x = \\frac{3}{2}\\ln 2$。\n由于 $a = 2\\ln 2$，这个临界点位于 $(0,a)$ 内。\n此区间内的二阶导数为 $f''(x) = \\frac{1}{3}\\exp(-x) + \\frac{1}{6}\\exp(x-a)$，它严格为正。因此，$x = \\frac{3}{2}\\ln 2$ 是一个局部极小值。\n$x=0$ 和 $x=a$ 处的两个局部极大值被一个局部极小值分开，这证实了 $f(x)$ 是双峰的。\n\n### 任务 2 和 3：推导并计算接受概率\n接受概率 $P_{acc}$ 是接受区域的面积与提议区域 $\\mathcal{R}$ 面积之比。\n提议区域是矩形 $\\mathcal{R} = \\{(x,y): |x| \\leq w, 0 \\leq y \\leq h\\}$。\n给定 $w = \\ln 2$，高度为 $h = g(w) = g(\\ln 2) = \\frac{1}{2}\\exp(-|\\ln 2|) = \\frac{1}{2}\\exp(-\\ln 2) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4}$。\n$\\mathcal{R}$ 的面积是 $\\text{Area}(\\mathcal{R}) = (2w)h = 2(\\ln 2)(\\frac{1}{4}) = \\frac{\\ln 2}{2}$。\n\n从 $\\mathcal{R}$ 中均匀抽取的点 $(X,Y)$ 在 $Y \\leq f(X)$ 时被接受。接受区域的面积由积分 $A_{acc} = \\int_{-w}^{w} \\min(h, f(x)) \\, dx$ 给出。\n我们需要确定在区间 $[-w, w] = [-\\ln 2, \\ln 2]$ 上何处 $f(x)  h$。\n\n对于 $x \\in [0, w] = [0, \\ln 2]$:\n在此范围内 $x \\in [0, a)$。导数为 $f'(x) = -\\frac{1}{3}\\exp(-x) + \\frac{1}{6}\\exp(x-a)$。我们发现对于 $x  \\frac{3}{2}\\ln 2$，$f'(x)0$。由于 $w = \\ln 2  \\frac{3}{2}\\ln 2$，因此 $f(x)$ 在 $[0, w]$ 上是递减的。\n此区间上的最小值为 $x=w$ 时：\n$f(w) = f(\\ln 2) = \\frac{1}{3}\\exp(-\\ln 2) + \\frac{1}{6}\\exp(-|\\ln 2 - \\ln 4|) = \\frac{1}{3}\\cdot\\frac{1}{2} + \\frac{1}{6}\\exp(\\ln 2 - \\ln 4) = \\frac{1}{6} + \\frac{1}{6}\\exp(-\\ln 2) = \\frac{1}{6} + \\frac{1}{12} = \\frac{3}{12} = \\frac{1}{4}$。\n由于 $f(w) = h$ 且 $f(x)$ 在 $[0, w]$ 上是递减的，我们有对于所有 $x \\in [0, w]$，$f(x) \\geq h$。\n\n对于 $x \\in [-w, 0] = [-\\ln 2, 0]$:\n在此范围内， $|x|=-x$ 且 $|x-a|=|x-2\\ln 2| = -(x-2\\ln 2) = a-x$。\n$f(x) = \\frac{1}{3}\\exp(x) + \\frac{1}{6}\\exp(x-a) = \\exp(x) \\left(\\frac{1}{3} + \\frac{1}{6}\\exp(-a)\\right) = \\exp(x) \\left(\\frac{1}{3} + \\frac{1}{24}\\right) = \\frac{3}{8}\\exp(x)$。\n我们找出 $f(x)=h$ 的位置：\n$\\frac{3}{8}\\exp(x) = \\frac{1}{4} \\implies \\exp(x) = \\frac{8}{12} = \\frac{2}{3} \\implies x = \\ln\\left(\\frac{2}{3}\\right)$。\n令 $x_0 = \\ln(2/3)$。注意 $-\\ln 2 = \\ln(1/2)  \\ln(2/3)  0$，所以 $x_0 \\in (-w, 0)$。\n函数 $\\frac{3}{8}\\exp(x)$ 是递增的。\n对于 $x \\in [-w, x_0)$，$f(x)  f(x_0)=h$。\n对于 $x \\in [x_0, 0]$，$f(x) \\geq f(x_0)=h$。\n\n综合这些发现，$A_{acc}$ 的积分可分为：\n$$ A_{acc} = \\int_{-w}^{x_0} f(x) \\, dx + \\int_{x_0}^{w} h \\, dx $$\n第一个积分区间为 $[-w, x_0] = [-\\ln 2, \\ln(2/3)]$，其中 $f(x) = \\frac{3}{8}\\exp(x)$：\n$$ \\int_{-\\ln 2}^{\\ln(2/3)} \\frac{3}{8}\\exp(x) \\, dx = \\left[ \\frac{3}{8}\\exp(x) \\right]_{-\\ln 2}^{\\ln(2/3)} = \\frac{3}{8}\\left(\\exp(\\ln(2/3)) - \\exp(-\\ln 2)\\right) = \\frac{3}{8}\\left(\\frac{2}{3} - \\frac{1}{2}\\right) = \\frac{3}{8}\\left(\\frac{4-3}{6}\\right) = \\frac{3}{8}\\cdot\\frac{1}{6} = \\frac{1}{16} $$\n第二个积分为：\n$$ \\int_{x_0}^{w} h \\, dx = h(w - x_0) = \\frac{1}{4}\\left(\\ln 2 - \\ln\\left(\\frac{2}{3}\\right)\\right) = \\frac{1}{4}\\left(\\ln 2 - (\\ln 2 - \\ln 3)\\right) = \\frac{1}{4}\\ln 3 $$\n总的接受面积为 $A_{acc} = \\frac{1}{16} + \\frac{1}{4}\\ln 3$。\n\n接受概率为：\n$$ P_{acc} = \\frac{A_{acc}}{\\text{Area}(\\mathcal{R})} = \\frac{\\frac{1}{16} + \\frac{\\ln 3}{4}}{\\frac{\\ln 2}{2}} = \\frac{2}{\\ln 2}\\left(\\frac{1+4\\ln 3}{16}\\right) = \\frac{1+4\\ln 3}{8\\ln 2} $$\n这就是精确的解析表达式。\n\n现在，我们进行数值计算：\n使用 $\\ln 2 \\approx 0.693147$ 和 $\\ln 3 \\approx 1.098612$，\n$$ P_{acc} = \\frac{1 + 4(1.098612)}{8(0.693147)} = \\frac{1 + 4.394448}{5.545176} = \\frac{5.394448}{5.545176} \\approx 0.972818 $$\n四舍五入到四位有效数字，接受概率为 $0.9728$。", "answer": "$$\n\\boxed{0.9728}\n$$", "id": "3357063"}]}