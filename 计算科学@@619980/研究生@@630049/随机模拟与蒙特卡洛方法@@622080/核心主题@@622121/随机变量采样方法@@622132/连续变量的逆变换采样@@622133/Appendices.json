{"hands_on_practices": [{"introduction": "本练习提供了推导分位数函数的实践机会，分位数函数是逆变换方法法的基石。通过聚焦于帕累托分布（一个研究重尾现象的关键模型），你不仅将掌握推导过程，还将深入了解模拟中极值如何随样本量扩展。[@problem_id:3314460] 该练习将抽象的数学工具与罕见且重要事件的实际分析联系起来。", "problem": "考虑一个帕累托分布，其尺度参数为 $x_m0$，形状参数为 $\\alpha0$。设 $X$ 是一个连续随机变量，其概率密度函数为：当 $x\\ge x_m$ 时，$f_X(x)=\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}$；当 $x  x_m$ 时，$f_X(x) = 0$。\n\n(a) 推导帕累托分布的分位数函数 $Q(u)$ 的闭式表达式。\n(b) 对于一个通过逆变换采样生成的随机变量 $X^{\\star} = Q(U)$（其中 $U \\sim \\mathrm{Uniform}(0, 1)$），在大小为 $n$ 的样本中，高分位数阈值 $\\tau_n$ 定义为满足关系 $\\mathbb{P}(X^{\\star}  \\tau_n) = 1/n$ 的值。求 $\\tau_n$ 关于 $n$、$x_m$ 和 $\\alpha$ 的闭式表达式。", "solution": "所述问题需要进行验证。\n\n**步骤1：提取已知条件**\n- **分布：** 帕累托分布。\n- **尺度参数：** $x_m  0$。\n- **形状参数：** $\\alpha  0$。\n- **随机变量：** $X$。\n- **概率密度函数 (PDF)：** 当 $x \\ge x_m$ 时，$f_X(x) = \\alpha x_m^{\\alpha} x^{-(\\alpha+1)}$；当 $x  x_m$ 时，$f_X(x) = 0$。\n- **累积分布函数 (CDF)：** $F_X(x) = \\mathbb{P}(X \\le x)$。\n- **分位数函数：** 对于 $u \\in (0, 1)$，$Q(u) = F_X^{-1}(u) = \\inf\\{x \\in \\mathbb{R}: F_X(x) \\ge u\\}$。\n- **(a) 部分：** 推导 $Q(u)$ 的显式闭式表达式。\n- **(b) 部分：** 在模拟中，通过 $X^{\\star} = Q(U)$ 生成随机变量，其中 $U \\sim \\mathrm{Uniform}(0, 1)$。对于样本量 $n \\in \\mathbb{N}$，高分位数阈值 $\\tau_n$ 由关系 $\\mathbb{P}(X^{\\star}  \\tau_n) = 1/n$ 定义。任务是找到 $\\tau_n$ 的闭式表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是概率论和随机模拟中的一个标准练习。它涉及明确定义的帕累托分布和成熟的逆变换采样方法。问题是适定的，因为所有必要的参数（$x_m, \\alpha$）、定义（PDF、CDF、分位数函数）和条件都已提供，从而可以得到唯一解。这些定义是标准的，语言客观而精确。所提供的PDF在给定的参数约束下是正确归一化的，因为 $\\int_{x_m}^{\\infty} \\alpha x_m^{\\alpha} x^{-(\\alpha+1)} \\, dx = \\alpha x_m^{\\alpha} [-\\frac{1}{\\alpha}x^{-\\alpha}]_{x_m}^{\\infty} = -x_m^{\\alpha}(0 - x_m^{-\\alpha}) = 1$。问题设定是自洽且逻辑一致的。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n**(a) 部分：分位数函数 $Q(u)$ 的推导**\n\n累积分布函数 (CDF) $F_X(x)$ 定义为概率密度函数 (PDF) $f_X(t)$ 从 $-\\infty$ 到 $x$ 的积分。帕累托分布的支撑集是 $[x_m, \\infty)$，因此对于任何 $x  x_m$，PDF 为 $f_X(x) = 0$，这意味着 $F_X(x) = 0$。\n\n对于 $x \\ge x_m$，CDF 计算如下：\n$$F_X(x) = \\int_{-\\infty}^{x} f_X(t) \\, dt = \\int_{x_m}^{x} \\alpha x_m^{\\alpha} t^{-(\\alpha+1)} \\, dt$$\n我们可以将常数因子提出并进行积分：\n$$F_X(x) = \\alpha x_m^{\\alpha} \\int_{x_m}^{x} t^{-(\\alpha+1)} \\, dt$$\n$t^k$ 的积分是 $\\frac{t^{k+1}}{k+1}$。这里，$k = -(\\alpha+1)$，所以 $k+1 = -\\alpha$。\n$$F_X(x) = \\alpha x_m^{\\alpha} \\left[ \\frac{t^{-\\alpha}}{-\\alpha} \\right]_{x_m}^{x}$$\n$$F_X(x) = -x_m^{\\alpha} \\left[ t^{-\\alpha} \\right]_{x_m}^{x}$$\n$$F_X(x) = -x_m^{\\alpha} (x^{-\\alpha} - x_m^{-\\alpha})$$\n$$F_X(x) = -x_m^{\\alpha} x^{-\\alpha} + x_m^{\\alpha} x_m^{-\\alpha}$$\n$$F_X(x) = 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}$$\n因此，完整的 CDF 是：\n$$F_X(x) = \\begin{cases} 0  \\text{对于 } x  x_m \\\\ 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}  \\text{对于 } x \\ge x_m \\end{cases}$$\n分位数函数 $Q(u)$ 是 CDF 的逆函数 $F_X^{-1}(u)$。由于 $F_X(x)$ 在其支撑集上是连续且严格递增的，我们可以通过设 $u = F_X(x)$（其中 $u \\in (0, 1)$）并求解 $x$ 来求得逆函数。这对应于 $x \\ge x_m$ 的情况。\n$$u = 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}$$\n重新整理各项以求解 $x$：\n$$\\left(\\frac{x_m}{x}\\right)^{\\alpha} = 1 - u$$\n两边取 $1/\\alpha$ 次方：\n$$\\frac{x_m}{x} = (1 - u)^{1/\\alpha}$$\n最后，分离出 $x$：\n$$x = \\frac{x_m}{(1-u)^{1/\\alpha}} = x_m (1 - u)^{-1/\\alpha}$$\n因此，帕累托分布的分位数函数是：\n$$Q(u) = x_m (1 - u)^{-1/\\alpha}, \\quad u \\in (0, 1)$$\n\n**(b) 部分：高分位数阈值 $\\tau_n$ 的推导**\n\n我们已知定义高分位数阈值 $\\tau_n$ 的条件：\n$$\\mathbb{P}(X^{\\star}  \\tau_n) = \\frac{1}{n}$$\n在逆变换采样中，随机变量 $X^{\\star}$ 是通过使用 (a) 部分推导出的分位数函数对一个标准均匀随机变量 $U \\sim \\mathrm{Uniform}(0, 1)$ 进行变换生成的，即 $X^{\\star} = Q(U)$。将此代入概率表达式中：\n$$\\mathbb{P}(Q(U)  \\tau_n) = \\frac{1}{n}$$\n分位数函数 $Q(u)$ 在 $u \\in (0,1)$ 上是一个严格递增函数。因此，我们可以将它的反函数，即 CDF $F_X$，应用于概率内部不等式的两侧，而不会改变不等号的方向：\n$$Q(U)  \\tau_n \\iff U  F_X(\\tau_n)$$\n概率表达式变为：\n$$\\mathbb{P}(U  F_X(\\tau_n)) = \\frac{1}{n}$$\n对于一个标准均匀随机变量 $U$，对任意 $p \\in [0, 1]$，概率 $\\mathbb{P}(U  p)$ 等于 $1 - p$。令 $p = F_X(\\tau_n)$。那么：\n$$1 - F_X(\\tau_n) = \\frac{1}{n}$$\n这意味着：\n$$F_X(\\tau_n) = 1 - \\frac{1}{n}$$\n这个方程表明，$\\tau_n$ 是分布 $X$ 对应于概率水平 $1 - 1/n$ 的分位数。根据分位数函数的定义，这意味着 $\\tau_n = Q(1 - 1/n)$。\n\n现在我们可以使用 (a) 部分推导出的 $Q(u)$ 的显式公式，代入 $u = 1 - 1/n$：\n$$\\tau_n = Q\\left(1 - \\frac{1}{n}\\right) = x_m \\left(1 - \\left(1 - \\frac{1}{n}\\right)\\right)^{-1/\\alpha}$$\n简化括号内的表达式：\n$$\\tau_n = x_m \\left(\\frac{1}{n}\\right)^{-1/\\alpha}$$\n使用指数性质 $(a^b)^c = a^{bc}$：\n$$\\tau_n = x_m (n^{-1})^{-1/\\alpha} = x_m n^{(-1)(-1/\\alpha)}$$\n$$\\tau_n = x_m n^{1/\\alpha}$$\n这就是高分位数阈值 $\\tau_n$ 的闭式解析表达式。\n\n该表达式揭示了从帕累托分布中抽取的极值如何随样本量 $n$ 而变化。阈值 $\\tau_n$ 是在大小为 $n$ 的样本中平均被超过一次的期望值，它随着 $n$ 呈幂律增长，指数是尾部指数的倒数 $1/\\alpha$。这种多项式增长是重尾分布的一个标志。较小的 $\\alpha$（更重的尾部）导致较大的指数 $1/\\alpha$，表明与具有较大 $\\alpha$（较轻的尾部）的分布相比，极值随样本量的增长更为迅速。这与轻尾分布（例如，指数分布、正态分布）形成鲜明对比，后者的分位数通常增长得慢得多，通常与 $n$ 呈对数关系。", "answer": "$$\\boxed{x_m n^{1/\\alpha}}$$", "id": "3314460"}, {"introduction": "现实世界的建模常常需要将一个分布限制在特定区间内，这个过程称为截断。本实践旨在挑战你为截断分布构建一个通用的采样器，这是任何模拟工具箱中都极为灵活的工具。[@problem_id:3314454] 你将实现截断分位数函数的核心公式，并学习处理有无闭式反累积分布函数（CDF）的情况，从而巩固你在解析处理和数值求根方面的技能。", "problem": "您被要求为截断连续分布设计并实现一个逆变换采样器。从基本定义开始：如果一个连续随机变量 $X$ 的累积分布函数 (CDF) 为 $F(x)$，那么对于一个服从 Uniform$(0,1)$ 分布的变量 $U$，随机变量 $X = F^{-1}(U)$ 的 CDF 为 $F(x)$。对于截断区间 $[a,b]$（其中 $-\\infty  a  b  \\infty$）且 $F$ 在 $[a,b]$ 上严格递增，截断 CDF 定义为\n$$\nF_T(x) = \\frac{F(x) - F(a)}{F(b) - F(a)}, \\quad x \\in [a,b].\n$$\n通过求解 $F_T(x) = u$ 得到 $x$，可以获得相应的截断分位数函数，其表达式为\n$$\nQ_T(u) = F^{-1}\\Big(F(a) + u\\big(F(b)-F(a)\\big)\\Big), \\quad u \\in [0,1].\n$$\n您的任务是：\n- 基于上述定义，从基本原理出发推导截断 CDF 和截断分位数函数，并清晰地阐明推理过程。\n- 实现一个通用的截断连续分布逆变换采样器。该采样器在给定基础 CDF $F$、其逆函数 $F^{-1}$（如果可用）以及截断边界 $a$ 和 $b$ 的情况下，为请求的 $u$ 值计算 $Q_T(u)$。当 $F^{-1}$ 的闭式解或库实现不可用时，通过在区间 $[a,b]$ 上使用稳健的求根方法求解 $F(x) = p$ 来对 $x$ 进行数值求逆，其中 $p = F(a) + u\\big(F(b)-F(a)\\big)$。\n- 确保实现能精确处理边界情况 $u=0$ 和 $u=1$，即 $Q_T(0)=a$ 和 $Q_T(1)=b$。\n\n使用以下测试套件。对于每种情况，为指定的 $u$ 值计算截断分位数列表 $[Q_T(u_1), Q_T(u_2), \\dots]$。\n\n- 测试用例 1（具有闭式逆函数的理想情况）：基础分布为速率 $\\lambda = 0.7$ 的指数分布，其基础 CDF 在 $[0,\\infty)$ 上为 $F(x) = 1 - e^{-\\lambda x}$。截断至 $[a,b]=[0.2,1.5]$。在 $u \\in \\{0,\\,0.3,\\,0.6,\\,1\\}$ 处求值。\n- 测试用例 2（使用库逆函数，非对称截断）：基础分布为标准正态分布 $\\mathcal{N}(0,1)$，其基础 CDF 为 $F(x)$，截断至 $[a,b]=[-0.5,\\,1.0]$。在 $u \\in \\{0,\\,0.5,\\,1\\}$ 处求值。\n- 测试用例 3（解析多项式 CDF）：基础概率密度函数 (PDF) 在 $[0,1]$ 上为 $f(x)=3x^2$，因此基础 CDF 为 $F(x)=x^3$。截断至 $[a,b]=[0.2,\\,0.8]$。在 $u \\in \\{0,\\,0.25,\\,0.5,\\,0.75,\\,1\\}$ 处求值。\n- 测试用例 4（仅数值求逆）：基础 PDF 在 $[0,1]$ 上与 $e^{-x^3}$ 成正比，其基础 CDF 为\n$$\nF(x) = \\frac{\\int_0^x e^{-t^3}\\,dt}{\\int_0^1 e^{-t^3}\\,dt}.\n$$\n等价地，使用下不完全伽马函数 $\\gamma(s,z)$，$F(x) = \\frac{\\gamma\\!\\left(\\frac{1}{3},\\,x^3\\right)}{\\gamma\\!\\left(\\frac{1}{3},\\,1\\right)}$。截断至 $[a,b]=[0.1,\\,0.9]$。在 $u \\in \\{0,\\,0.5,\\,1\\}$ 处求值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个内部的浮点数列表。确切格式为：\n$$\n\\big[ [Q_{T,1}(u_1),\\dots], [Q_{T,2}(u_1),\\dots], [Q_{T,3}(u_1),\\dots], [Q_{T,4}(u_1),\\dots] \\big]\n$$\n不含多余的空白字符或文本。例如，一个有效的结构格式是\n$$\n[[x_{11},x_{12}],[x_{21},x_{22}],[x_{31},x_{32},x_{33}],[x_{41},x_{42}]]\n$$\n其中每个 $x_{ij}$ 是一个浮点数。", "solution": "出发点是连续随机变量 $X$ 的累积分布函数 (CDF) $F(x)$ 的定义，即 $F(x) = \\mathbb{P}(X \\le x)$。逆变换采样原理指出，如果 $U \\sim \\text{Uniform}(0,1)$，那么 $X = F^{-1}(U)$ 的 CDF 为 $F(x)$。这是由单调性得出的：对于任意 $x$，$\\mathbb{P}(X \\le x) = \\mathbb{P}(F^{-1}(U) \\le x) = \\mathbb{P}(U \\le F(x)) = F(x)$。\n\n当将一个具有 CDF $F$ 的基础分布截断到区间 $[a,b]$ 时，我们考虑条件分布 $\\mathcal{L}(X \\mid a \\le X \\le b)$。对于任意 $x \\in [a,b]$，根据条件概率的定义，\n$$\nF_T(x) = \\mathbb{P}(X \\le x \\mid a \\le X \\le b) = \\frac{\\mathbb{P}(a \\le X \\le x)}{\\mathbb{P}(a \\le X \\le b)} = \\frac{F(x) - F(a)}{F(b) - F(a)}.\n$$\n这证明了截断 CDF 的公式，并确保了 $F_T(a)=0$ 和 $F_T(b)=1$。为了获得截断分位数函数，我们设 $F_T(x) = u$ 并求解 $x$：\n$$\nu = \\frac{F(x) - F(a)}{F(b) - F(a)} \\quad \\Longrightarrow \\quad F(x) = F(a) + u\\big(F(b) - F(a)\\big).\n$$\n由于 $F$ 在 $[a,b]$ 上是严格递增的，我们可以对其求逆以得到\n$$\nQ_T(u) = F^{-1}\\Big(F(a) + u\\big(F(b)-F(a)\\big)\\Big), \\quad u \\in [0,1].\n$$\n这种表示法直接恢复了边界情况：对于 $u=0$，$Q_T(0) = F^{-1}(F(a)) = a$；对于 $u=1$，$Q_T(1) = F^{-1}(F(b)) = b$。\n\n实现方面的算法设计：\n- 输入：基础 CDF $F$、可选的基础分位数函数 $F^{-1}$（如果可用）、截断边界 a, b", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.optimize import brentq\nfrom scipy.special import gammainc\n\ndef truncated_quantiles(F, Finv_or_none, a, b, u_values):\n    \"\"\"\n    Compute truncated quantiles Q_T(u) = F^{-1}(F(a) + u*(F(b)-F(a))) for u in u_values.\n    If Finv_or_none is None, perform numerical inversion on [a,b].\n    \"\"\"\n    Fa = F(a)\n    Fb = F(b)\n    results = []\n    for u in u_values:\n        # Handle exact endpoints\n        if u == 0.0:\n            results.append(float(a))\n            continue\n        if u == 1.0:\n            results.append(float(b))\n            continue\n        p = Fa + u * (Fb - Fa)\n        if Finv_or_none is not None:\n            x = Finv_or_none(p)\n        else:\n            # Numerically invert F(x) = p on [a,b] via Brent's method\n            # F is strictly increasing on [a,b], so a unique root exists.\n            func = lambda x: F(x) - p\n            # If func(a) == 0 or func(b) == 0, brentq will handle it, but we guarded above.\n            x = brentq(func, a, b, maxiter=100, rtol=1e-12)\n        results.append(float(x))\n    return results\n\ndef format_nested_list(nested):\n    \"\"\"\n    Format nested list of floats without spaces: [[a,b],[c,d,e],...]\n    \"\"\"\n    def fmt_float(x):\n        # Use repr to avoid trailing spaces and ensure a precise representation.\n        return repr(float(x))\n    inner_strs = []\n    for inner in nested:\n        inner_str = \"[\" + \",\".join(fmt_float(x) for x in inner) + \"]\"\n        inner_strs.append(inner_str)\n    return \"[\" + \",\".join(inner_strs) + \"]\"\n\ndef solve():\n    # Test Case 1: Exponential with rate lambda=0.7, truncated [0.2, 1.5], u in {0,0.3,0.6,1}\n    lam = 0.7\n    F_exp = lambda x: 1.0 - np.exp(-lam * x)\n    Finv_exp = lambda p: -np.log(1.0 - p) / lam\n    a1, b1 = 0.2, 1.5\n    u1 = [0.0, 0.3, 0.6, 1.0]\n    res1 = truncated_quantiles(F_exp, Finv_exp, a1, b1, u1)\n\n    # Test Case 2: Standard Normal, truncated [-0.5, 1.0], u in {0,0.5,1}\n    F_norm = lambda x: norm.cdf(x)\n    Finv_norm = lambda p: norm.ppf(p)\n    a2, b2 = -0.5, 1.0\n    u2 = [0.0, 0.5, 1.0]\n    res2 = truncated_quantiles(F_norm, Finv_norm, a2, b2, u2)\n\n    # Test Case 3: Polynomial base f(x)=3x^2 on [0,1], F(x)=x^3, truncated [0.2,0.8], u in {0,0.25,0.5,0.75,1}\n    F_poly = lambda x: x**3\n    Finv_poly = lambda p: p**(1.0/3.0)\n    a3, b3 = 0.2, 0.8\n    u3 = [0.0, 0.25, 0.5, 0.75, 1.0]\n    res3 = truncated_quantiles(F_poly, Finv_poly, a3, b3, u3)\n\n    # Test Case 4: Base PDF ∝ exp(-x^3) on [0,1], F(x) = gammainc(1/3, x^3) / gammainc(1/3, 1), truncated [0.1,0.9], u in {0,0.5,1}\n    denom = gammainc(1.0/3.0, 1.0)  # gammainc is the regularized lower incomplete gamma; denom is P(1/3,1)\n    F_expnegx3 = lambda x: gammainc(1.0/3.0, x**3) / denom\n    a4, b4 = 0.1, 0.9\n    u4 = [0.0, 0.5, 1.0]\n    # No closed-form inverse; use numerical inversion on [a,b]\n    res4 = truncated_quantiles(F_expnegx3, None, a4, b4, u4)\n\n    results = [res1, res2, res3, res4]\n\n    # Final print statement in the exact required format.\n    print(format_nested_list(results))\n\nsolve()\n```", "id": "3314454"}, {"introduction": "一个已实现的采样器只有在正确时才有用，而对于逆变换采样，其正确性取决于分位数函数的非递减性。本实践引入了一个严格的质量控制框架，指导你测试单调性并量化由数值误差引入的采样偏差。[@problem_id:3314471] 通过分析有缺陷的实现，你将培养对数值方法细微之处的敏锐洞察力，并理解验证在计算科学中的重要性。", "problem": "您的任务是评估一个用于连续分布的数值实现分位数函数是否为非递减函数，并量化偏离非递减行为在进行逆变换采样时所引起的抽样偏差。\n\n假设目标分布的支撑集在区间 $[0,1]$ 上，其累积分布函数为 $F(x) = x^{\\alpha}$，其中 $x \\in [0,1]$，形状参数 $\\alpha = 2$。相应的精确分位数函数为 $Q^{\\star}(u) = u^{1/\\alpha}$，其中 $u \\in [0,1]$。逆变换采样的定义是生成 $U \\sim \\mathrm{Uniform}(0,1)$，并设 $X = Q(U)$，其中 $Q$ 为一个分位数函数。如果 $Q$ 是一个相对于 $F$ 满足广义逆性质的右连续、非递减函数，那么 $X$ 的分布与目标分布一致。如果 $Q$ 不是非递减的，那么 $U$ 在 $Q$ 作用下的前推分布会偏离目标分布，从而导致抽样偏差。\n\n设计并实现一个程序来执行以下操作：\n\n1.  对于一个 $u$ 值的网格，通过检查离散前向差分为非负来验证给定数值分位数函数 $Q(u)$ 的单调性。具体来说，对于一个网格 $\\{u_i\\}_{i=0}^{N-1}$（其中 $u_0 = 0$， $u_{N-1} = 1$，且 $u_i$ 均匀分布），计算 $\\Delta_i = Q(u_{i+1}) - Q(u_i)$（$i = 0, \\dots, N-2$），并按如下方式定义一个带有容差 $\\tau$ 的非递减测试：\n    -   当且仅当对所有 $i$ 都有 $\\Delta_i \\ge -\\tau$ 时，函数通过单调性测试。\n    -   将违规计数定义为满足 $\\Delta_i  -\\tau$ 的索引 $i$ 的数量。\n    -   将违规幅度定义为 $\\sum_{\\{i: \\Delta_i  -\\tau\\}} (-\\Delta_i)$。\n\n2.  量化使用 $Q(u)$ 进行逆变换采样所引起的抽样偏差，该偏差通过在 $x$ 空间中指定的一组直方图箱上，导出分布与目标分布之间的总变差距离来衡量。设直方图由 $B$ 个箱组成，其边界为 $\\{b_j\\}_{j=0}^{B}$，覆盖区间 $[x_{\\min}, x_{\\max}]$，其中 $x_{\\min} \\le 0$ 且 $x_{\\max} \\ge 1$。按如下方式定义目标箱概率：\n    $$p^{\\text{true}}_j = F(\\min\\{1, b_{j+1}\\}) - F(\\max\\{0, b_j\\}), \\quad j = 0, \\dots, B-1,$$\n    约定当 $x \\le 0$ 时 $F(x) = 0$，当 $x \\ge 1$ 时 $F(x) = 1$。这将 $[0,1]$ 之外的质量赋为零。通过将 $u$ 中的均匀网格经由 $Q(u)$ 映射到 $x$，并计算落入每个箱中的分数（如果 $Q(u)$ 产生此类值，则包括 $[0,1]$ 之外的任何质量），来定义导出箱概率。计算总变差距离\n    $$\\mathrm{TV} = \\frac{1}{2} \\sum_{j=0}^{B-1} \\left| p^{\\text{gen}}_j - p^{\\text{true}}_j \\right|,$$\n    其中 $p^{\\text{gen}}_j$ 是导出箱概率。\n\n3.  在相同的目标分布（$\\alpha=2$）下，根据上述测试评估三个数值分位数实现 $Q(u)$：\n    -   情况 A（基准，精确）：$Q_{\\mathrm{A}}(u) = u^{1/2}$。\n    -   情况 B（振荡扰动）：$Q_{\\mathrm{B}}(u) = u^{1/2} + \\varepsilon \\sin(2\\pi k u)$，其中 $\\varepsilon = 0.02$， $k = 5$。\n    -   情况 C（分段反转）：对于参数 $a = 0.3$ 和 $b = 0.5$，定义\n        $$Q_{\\mathrm{C}}(u) = \\begin{cases}\n        u^{1/2},  u \\notin [a,b], \\\\\n        \\left(a + b - u\\right)^{1/2},  u \\in [a,b].\n        \\end{cases}$$\n        这在 $[a,b]$ 上引入了一个严格递减的段，同时保持了连续性。\n\n使用以下固定参数构成测试套件：\n-   单调性网格：在 $[0,1]$ 上的 $N = 200001$ 个均匀间隔点，容差 $\\tau = 10^{-12}$。\n-   偏差评估：\n    -   使用 $[0,1]$ 上的 $M = 200000$ 个均匀间隔点，通过 $Q(u)$ 映射，作为大型无随机性逆变换样本的代理。\n    -   直方图规格：$B = 400$ 个箱，其边界在 $[x_{\\min}, x_{\\max}]$ 上均匀间隔，其中 $x_{\\min} = -0.05$，$x_{\\max} = 1.05$。\n\n您的程序必须为 A、B 和 C 三种情况中的每一种计算以下四个输出：\n-   一个单调性标志，如果通过非递减测试则为 $1$，否则为 $0$。\n-   违规计数，为一个整数。\n-   违规幅度，为一个浮点数。\n-   总变差距离 $\\mathrm{TV}$，为一个浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由三个列表组成的列表，每个列表对应一种情况（按 A、B、C 顺序），每个内部列表的形式为 $[\\text{标志}, \\text{计数}, \\text{违规幅度}, \\text{TV}]$。整个输出必须是格式为\n$[ [\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot] ]$\n的单行，其中的数值条目以标准十进制字符串打印。", "solution": "目标是验证一个连续概率分布的三个数值实现的分位数函数（表示为 $Q(u)$），并量化当这些函数非单调递减时引入的抽样偏差。此评估对于可靠应用逆变换采样方法至关重要，该方法是蒙特卡洛模拟的基石。\n\n该问题的理论基础是概率积分变换及其逆变换。对于具有严格递增累积分布函数（CDF）$F(x)$ 的连续随机变量 $X$，随机变量 $U = F(X)$ 在 $[0,1]$ 上均匀分布。逆变换采样方法利用了其逆过程：如果 $U$ 从均匀分布 $\\mathrm{Uniform}(0,1)$ 中抽取，则随机变量 $X = F^{-1}(U)$ 将具有 CDF $F(x)$。函数 $F^{-1}(u)$ 即为分位数函数 $Q(u)$。该方法有效性的一个关键性质是分位数函数 $Q(u)$ 必须是非递减的。如果违反此条件，从 $U$ 到 $X$ 的映射将无法正确保持概率测度，生成的样本 $X$ 的分布将偏离目标分布 $F(x)$。\n\n此分析的目标分布由 CDF $F(x) = x^{\\alpha}$ 定义，其中 $x \\in [0,1]$，参数 $\\alpha=2$。该分布的支撑集为区间 $[0,1]$。定义当 $x \\le 0$ 时 $F(x)=0$，当 $x \\ge 1$ 时 $F(x)=1$。相应的精确分位数函数为 $Q^{\\star}(u) = F^{-1}(u) = u^{1/\\alpha} = u^{1/2}$，其中 $u \\in [0,1]$。\n\n对于所提供的三个分位数函数实现中的每一个，分析都分两个主要步骤进行。\n\n**步骤 1：单调性验证**\n\n如果对于任何 $u_1  u_2$，都有 $Q(u_1) \\le Q(u_2)$ 成立，则函数 $Q(u)$ 是非递减的。为在数值上验证此性质，我们将定义域 $[0,1]$ 离散化为一个包含 $N=200001$ 个点的精细均匀网格 $\\{u_i\\}_{i=0}^{N-1}$，其中 $u_i = i/(N-1)$。然后，我们计算前向差分序列 $\\Delta_i = Q(u_{i+1}) - Q(u_i)$，其中 $i=0, \\dots, N-2$。理论上，所有的 $\\Delta_i$ 都必须为非负。然而，为了适应有限精度浮点运算，我们引入了一个小容差 $\\tau = 10^{-12}$。当且仅当对所有 $i$ 都有 $\\Delta_i \\ge -\\tau$ 时，函数 $Q(u)$ 被认为通过了单调性测试。\n\n从这个测试中，我们导出三个度量：\n1.  一个二元单调性标志：如果测试通过（所有 $\\Delta_i \\ge -\\tau$），则为 $1$，否则为 $0$。\n2.  违规计数：这是一个整数，表示条件失败（即 $\\Delta_i  -\\tau$）的总索引数 $i$。\n3.  违规幅度：这是一个浮点数，量化了递减的总程度，计算为总和 $\\sum_{\\{i: \\Delta_i  -\\tau\\}} (-\\Delta_i)$。\n\n**步骤 2：抽样偏差量化**\n\n当分位数函数 $Q(u)$ 不是非递减时，使用它进行逆变换采样会引入偏差。我们通过测量由 $Q(u)$ 导出的分布与真实目标分布之间的统计距离来量化此偏差。所使用的度量是总变差（TV）距离，定义为：\n$$\n\\mathrm{TV} = \\frac{1}{2} \\sum_{j=0}^{B-1} | p^{\\text{gen}}_j - p^{\\text{true}}_j |\n$$\n其中 $\\{p^{\\text{gen}}_j\\}$ 和 $\\{p^{\\text{true}}_j\\}$ 是分配给指定范围内 $B$ 个直方图箱的概率。\n\n箱概率计算如下：\n-   **目标概率 ($p^{\\text{true}}$)**：这些概率从精确的 CDF $F(x)$ 解析计算得出。对于一组 $B=400$ 个直方图箱，其边界 $\\{b_j\\}_{j=0}^{B}$ 在 $[x_{\\min}, x_{\\max}] = [-0.05, 1.05]$ 上均匀间隔，第 $j$ 个箱中的真实概率是 $p^{\\text{true}}_j = F(b_{j+1}) - F(b_j)$。问题对 $F(x)$ 在 $[0,1]$ 之外的定义，通过 $p^{\\text{true}}_j = F(\\min\\{1, b_{j+1}\\}) - F(\\max\\{0, b_j\\})$ 来体现，正确地将所有概率质量分配到区间 $[0,1]$。\n-   **生成概率 ($p^{\\text{gen}}$)**：通过将来自 $[0,1]$ 的 $M=200000$ 个点的确定性均匀网格 $\\{u_k\\}$ 通过数值分位数函数 $Q(u)$ 映射，得到一组生成值 $\\{x_k = Q(u_k)\\}$ 来确定这些概率。概率 $p^{\\text{gen}}_j$ 是这 $M$ 个点中落入每个直方图箱 $j$ 的比例。这个确定性过程将函数 $Q(u)$ 的结构性偏差与随机采样的随机性分离开来。\n\n**分位数函数案例分析**\n\n该程序应用于三个不同的函数：\n\n1.  **情况 A：$Q_{\\mathrm{A}}(u) = u^{1/2}$**。这是精确、正确的分位数函数。它在 $(0,1]$ 上是严格递增的，因此我们预期它将通过单调性测试（标志=1，计数=0，幅度=0.0），并表现出一个非零但非常小的 TV 距离，这完全归因于数值离散化和分箱效应。\n\n2.  **情况 B：$Q_{\\mathrm{B}}(u) = u^{1/2} + \\varepsilon \\sin(2\\pi k u)$**，其中 $\\varepsilon = 0.02$， $k=5$。此函数向真实分位数函数添加了一个小的、高频的振荡。其导数为 $Q'_{\\mathrm{B}}(u) = \\frac{1}{2}u^{-1/2} + 2\\pi k \\varepsilon \\cos(2\\pi k u)$。第二项可以为负，并且对于某些 $u$ 值，它可能超过第一项，导致 $Q'_{\\mathrm{B}}(u)  0$。因此，我们预期此函数将无法通过单调性测试，从而产生非零的违规计数和幅度，以及相应的非零 TV 距离。\n\n3.  **情况 C：$Q_{\\mathrm{C}}(u)$**，当 $u \\notin [0.3, 0.5]$ 时为 $u^{1/2}$，当 $u \\in [0.3, 0.5]$ 时为 $(0.3 + 0.5 - u)^{1/2}$。此函数用一个反向映射区间 $[0.3, 0.5]$ 的段替换了正确分位数函数的一部分。在此区间上，$Q_{\\mathrm{C}}(u) = (0.8 - u)^{1/2}$，其导数严格为负。这代表了对非递减性质的重大结构性违规。我们预计会有较大的违规计数和幅度，以及显著的 TV 距离，反映了严重的抽样偏差。\n\n以下程序实现了这整个验证和量化过程。它定义了三个分位数函数，为每个函数计算了四个指定的度量，并以要求的格式呈现结果。程序使用 `NumPy`，因其强大而高效的数组操作，这对于处理问题规范所要求的大型点网格至关重要。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs monotonicity and bias analysis on three numerical quantile functions.\n    \"\"\"\n    # Problem parameters\n    ALPHA = 2.0\n    # Case B parameters\n    EPSILON = 0.02\n    K = 5\n    # Case C parameters\n    A = 0.3\n    B = 0.5\n    # Monotonicity test parameters\n    N_MONO = 200001\n    TAU = 1e-12\n    # Bias evaluation parameters\n    M_BIAS = 200000\n    B_HIST = 400\n    X_MIN = -0.05\n    X_MAX = 1.05\n\n    # --- Define Quantile Functions ---\n    def Q_A(u):\n        # Case A: Exact quantile function\n        return np.sqrt(u)\n\n    def Q_B(u):\n        # Case B: Oscillatory perturbation\n        return np.sqrt(u) + EPSILON * np.sin(2 * np.pi * K * u)\n\n    def Q_C(u):\n        # Case C: Segment reversal\n        res = np.sqrt(u)\n        mask = (u >= A)  (u = B)\n        res[mask] = np.sqrt(A + B - u[mask])\n        return res\n\n    # --- Define Target CDF ---\n    def F_target(x):\n        # Target CDF: F(x) = x^alpha on [0,1], 0 below, 1 above.\n        # np.clip handles the domain correctly.\n        x_clipped = np.clip(x, 0, 1)\n        return x_clipped**ALPHA\n\n    def evaluate_quantile_function(Q_func):\n        \"\"\"\n        Runs the full analysis for a given quantile function Q.\n        \n        Returns:\n            list: [monotonicity_flag, violation_count, violation_magnitude, tv_distance]\n        \"\"\"\n        # --- 1. Monotonicity Test ---\n        u_mono = np.linspace(0.0, 1.0, N_MONO)\n        x_vals_mono = Q_func(u_mono)\n        \n        # Compute forward differences\n        deltas = np.diff(x_vals_mono)\n        \n        # Find violations\n        violations_mask = deltas  -TAU\n        violation_count = int(np.sum(violations_mask))\n        \n        monotonicity_flag = 1 if violation_count == 0 else 0\n        \n        # Sum of magnitudes of violations\n        if violation_count > 0:\n            violation_magnitude = float(-np.sum(deltas[violations_mask]))\n        else:\n            violation_magnitude = 0.0\n\n        # --- 2. Bias Evaluation ---\n        # Define histogram bins\n        bin_edges = np.linspace(X_MIN, X_MAX, B_HIST + 1)\n\n        # Calculate target bin probabilities (p_true)\n        # The problem defines F(min{1,b_{j+1}})-F(max{0,b_j}). Our F_target does this.\n        # F_target applies np.clip internally.\n        p_true = F_target(bin_edges[1:]) - F_target(bin_edges[:-1])\n\n        # Calculate generated bin probabilities (p_gen)\n        # Use a deterministic grid for u as a proxy for a large sample\n        u_bias = np.linspace(0.0, 1.0, M_BIAS)\n        x_generated = Q_func(u_bias)\n        \n        # Histogram the generated values\n        counts, _ = np.histogram(x_generated, bins=bin_edges)\n        p_gen = counts / M_BIAS\n\n        # Calculate Total Variation Distance\n        tv_distance = float(0.5 * np.sum(np.abs(p_gen - p_true)))\n\n        return [monotonicity_flag, violation_count, violation_magnitude, tv_distance]\n\n    # --- Run Analysis for All Cases ---\n    results = []\n    for Q_func in [Q_A, Q_B, Q_C]:\n        result_vector = evaluate_quantile_function(Q_func)\n        results.append(result_vector)\n        \n    # --- Format and Print Output ---\n    # The output must be a single line in the specified format.\n    # Ex: [[1,0,0.0,1.2e-5],[0,3,0.1,0.2],[...]]\n    output_str = \",\".join(f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3314471"}]}