{"hands_on_practices": [{"introduction": "理论的基石是深刻理解任何计算方法的前提。在深入研究高斯过程的数值模拟之前，通过解析方法推导一个经典案例的 Karhunen-Loève (KL) 展开至关重要。本练习将指导您完成对标准布朗运动的 KL 展开的完整推导，布朗运动是随机过程理论的基石。通过将相关的 Fredholm 积分方程转化为一个二阶常微分方程并求解其边界值问题，您将亲手揭示随机过程与其谱表示之间的深刻联系。[@problem_id:3340706]", "problem": "考虑在区间 $[0,1]$ 上的标准布朗运动 $B(t)$，其定义为一个中心化高斯过程，协方差函数为 $K(s,t)=\\min(s,t)$。一个零均值、平方可积高斯过程的卡尔胡宁-洛维（KL）展开将该过程表示为一个无穷级数，该级数由确定性的标准正交函数和独立的标准正态系数构成。从KL展开通过协方差算子的谱分解的基本定义出发，推导在 $L^{2}([0,1])$ 上以 $K(s,t)=\\min(s,t)$ 为核的积分算子 $T$ 的标准正交特征函数和特征值，即求解满足以下条件的函数 $\\phi(s)$ 和标量 $\\lambda$：\n$$\n\\lambda\\,\\phi(s)=\\int_{0}^{1}K(s,t)\\,\\phi(t)\\,dt,\\quad s\\in[0,1].\n$$\n仅使用经过充分检验的事实和定义：与 $K$ 相关的协方差算子是紧的、自伴的和正定的，其标准正交特征函数构成 $L^{2}([0,1])$ 中的一个完备基；对于一个中心化高斯过程 $X(t)$，其特征对为 $\\{(\\lambda_{k},\\phi_{k})\\}$，KL展开为 $X(t)=\\sum_{k=1}^{\\infty}\\sqrt{\\lambda_{k}}\\,Z_{k}\\,\\phi_{k}(t)$，其中 $\\{Z_{k}\\}$ 是独立的标准正态随机变量。推导积分方程所蕴含的边界条件，求解由此得到的常微分方程，并在 $L^{2}([0,1])$ 中将特征函数归一化。然后，将 $B(t)$ 在 $[0,1]$ 上的KL展开明确地写成一个关于 $t$ 的单个闭合形式级数，其系数是独立的标准正态随机变量。\n\n将您的最终答案表示为 $B(t)$ 的一个解析表达式（不要提供中间步骤或单独的特征值/特征函数公式）。无需四舍五入，且不涉及物理单位。将您的最终答案明确地表述为一个关于 $t$ 的级数。", "solution": "该问题要求解标准布朗运动在区间 $[0,1]$ 上的卡尔胡宁-洛维（KL）展开。这需要找到与其协方差函数相关的积分算子的特征值和标准正交特征函数。\n\n### 步骤 1：提取已知条件\n- 过程：在区间 $[0,1]$ 上的标准布朗运动 $B(t)$。\n- 统计特性：$B(t)$ 是一个中心化高斯过程，意味着其均值为 $E[B(t)] = 0$。\n- 协方差函数：$K(s,t) = \\text{cov}(B(s), B(t)) = \\min(s,t)$，其中 $s,t \\in [0,1]$。\n- 控制方程：协方差算子的特征对 $(\\lambda, \\phi)$ 满足第二类Fredholm积分方程：\n$$ \\lambda\\,\\phi(s)=\\int_{0}^{1}K(s,t)\\,\\phi(t)\\,dt,\\quad s\\in[0,1] $$\n- 卡尔胡宁-洛维展开公式：对于一个中心化高斯过程 $X(t)$，其特征对为 $\\{(\\lambda_{k},\\phi_{k})\\}$，展开式为 $X(t)=\\sum_{k=1}^{\\infty}\\sqrt{\\lambda_{k}}\\,Z_{k}\\,\\phi_{k}(t)$，其中 $\\{Z_{k}\\}$ 是独立的标准正态随机变量。\n\n### 步骤 2：使用已知条件进行验证\n- **科学基础**：该问题牢固地植根于随机过程理论，特别是高斯过程的分析。布朗运动的概念、其协方差函数、卡尔胡宁-洛维展开以及相关的积分方程都是数学和物理学中标准的、成熟的课题。\n- **适定性**：协方差核 $K(s,t) = \\min(s,t)$ 是连续、对称和正定的。相关的积分算子是 $L^2([0,1])$ 上的一个希尔伯特-施密特算子，这保证了它是紧的和自伴的。根据Mercer定理，存在一个可数的正特征值集合以及相应的连续特征函数的完备标准正交基。因此，该问题是适定的，并且有唯一解。\n- **客观性**：该问题以精确的数学语言陈述，没有任何主观或模糊的术语。\n- **完备性与一致性**：问题陈述提供了所有必要信息：过程、其定义域、协方差函数、待解的积分方程以及所需展开式的一般形式。其中没有矛盾。\n\n### 步骤 3：结论与行动\n该问题是有效的。它是随机过程理论中一个标准的、适定的问题。我将继续进行求解。\n\n### 特征值问题的推导\n我们必须求解的积分方程是：\n$$ \\lambda \\phi(s) = \\int_{0}^{1} \\min(s,t) \\phi(t) dt $$\n根据最小函数的定义，我们可以在 $s$ 处拆分积分：\n$$ \\lambda \\phi(s) = \\int_{0}^{s} t \\phi(t) dt + \\int_{s}^{1} s \\phi(t) dt $$\n该方程对所有 $s \\in [0,1]$ 成立。我们可以通过对 $s$ 求导，将此积分方程转化为一个常微分方程（ODE）。使用莱布尼茨积分法则，$\\frac{d}{dx} \\int_{a(x)}^{b(x)} f(x,t) dt = f(x,b(x))b'(x) - f(x,a(x))a'(x) + \\int_{a(x)}^{b(x)} \\frac{\\partial f}{\\partial x} dt$，对第一项求导得到 $s\\phi(s)$。对于第二项，我们有 $\\frac{d}{ds} (s \\int_s^1 \\phi(t) dt) = \\int_s^1 \\phi(t)dt + s(-\\phi(s))$。\n\n对 $\\lambda\\phi(s)$ 的方程关于 $s$ 求导，得到：\n$$ \\lambda \\phi'(s) = s \\phi(s) + \\left( \\int_{s}^{1} \\phi(t) dt - s \\phi(s) \\right) = \\int_{s}^{1} \\phi(t) dt $$\n再次对 $s$ 求导：\n$$ \\lambda \\phi''(s) = -\\phi(s) $$\n这给出了二阶线性齐次常微分方程：\n$$ \\phi''(s) + \\frac{1}{\\lambda} \\phi(s) = 0 $$\n\n### 边界条件的推导\n我们需要两个边界条件来解这个常微分方程。\n首先，计算原始积分方程在 $s=0$ 处的值：\n$$ \\lambda \\phi(0) = \\int_{0}^{1} \\min(0,t)\\,\\phi(t)\\,dt = \\int_{0}^{1} 0 \\cdot \\phi(t) dt = 0 $$\n由于正定算子的特征值 $\\lambda$ 必须是正数（因此非零），我们必须有 $\\phi(0) = 0$。\n\n其次，计算一阶导数方程 $\\lambda \\phi'(s) = \\int_{s}^{1} \\phi(t) dt$ 在 $s=1$ 处的值：\n$$ \\lambda \\phi'(1) = \\int_{1}^{1} \\phi(t) dt = 0 $$\n同样，由于 $\\lambda \\neq 0$，我们必须有 $\\phi'(1)=0$。\n\n### 求解边值问题\n我们求解常微分方程 $\\phi''(s) + \\frac{1}{\\lambda} \\phi(s) = 0$，其边界条件为 $\\phi(0)=0$ 和 $\\phi'(1)=0$。\n设 $\\omega^2 = \\frac{1}{\\lambda}$。由于 $\\lambda>0$，$\\omega$ 是实数。$\\phi''(s) + \\omega^2 \\phi(s) = 0$ 的通解是：\n$$ \\phi(s) = A \\sin(\\omega s) + C \\cos(\\omega s) $$\n应用第一个边界条件 $\\phi(0)=0$：\n$$ \\phi(0) = A \\sin(0) + C \\cos(0) = C = 0 $$\n解的形式必须为 $\\phi(s) = A \\sin(\\omega s)$。\n\n现在，应用第二个边界条件 $\\phi'(1)=0$。导数为 $\\phi'(s) = A \\omega \\cos(\\omega s)$。\n$$ \\phi'(1) = A \\omega \\cos(\\omega) = 0 $$\n为了得到非平凡解，我们需要 $A \\neq 0$。同时 $\\omega=1/\\sqrt{\\lambda} \\neq 0$。因此，我们必须有 $\\cos(\\omega)=0$。\n当 $\\omega$ 是 $\\pi/2$ 的奇数倍时，此条件得到满足：\n$$ \\omega_k = \\frac{(2k-1)\\pi}{2} \\quad \\text{for } k = 1, 2, 3, \\ldots $$\n那么特征值 $\\lambda_k$ 由下式给出：\n$$ \\lambda_k = \\frac{1}{\\omega_k^2} = \\frac{1}{\\left(\\frac{(2k-1)\\pi}{2}\\right)^2} = \\frac{4}{(2k-1)^2\\pi^2} $$\n相应的未归一化特征函数是 $\\phi_k(s) = A_k \\sin(\\omega_k s) = A_k \\sin\\left(\\frac{(2k-1)\\pi s}{2}\\right)$。\n\n### 特征函数的归一化\n特征函数必须在 $L^2([0,1])$ 中构成一个标准正交集，因此我们需要 $\\int_0^1 \\phi_k(s)^2 ds = 1$。\n$$ \\int_0^1 \\left(A_k \\sin\\left(\\frac{(2k-1)\\pi s}{2}\\right)\\right)^2 ds = 1 $$\n$$ A_k^2 \\int_0^1 \\sin^2\\left(\\frac{(2k-1)\\pi s}{2}\\right) ds = 1 $$\n使用恒等式 $\\sin^2(\\theta) = \\frac{1-\\cos(2\\theta)}{2}$：\n$$ \\int_0^1 \\sin^2\\left(\\omega_k s\\right) ds = \\int_0^1 \\frac{1 - \\cos(2\\omega_k s)}{2} ds = \\frac{1}{2} \\left[s - \\frac{\\sin(2\\omega_k s)}{2\\omega_k}\\right]_0^1 $$\n由于 $2\\omega_k = (2k-1)\\pi$，我们有 $\\sin(2\\omega_k s)|_{s=1} = \\sin((2k-1)\\pi) = 0$。该积分的计算结果为：\n$$ \\frac{1}{2} \\left(1 - \\frac{\\sin((2k-1)\\pi)}{(2k-1)\\pi}\\right) - 0 = \\frac{1}{2} $$\n将此结果代回归一化条件：\n$$ A_k^2 \\cdot \\frac{1}{2} = 1 \\implies A_k^2 = 2 $$\n选择正根，$A_k = \\sqrt{2}$。标准正交特征函数为：\n$$ \\phi_k(s) = \\sqrt{2} \\sin\\left(\\frac{(2k-1)\\pi s}{2}\\right) $$\n\n### 构建卡尔胡宁-洛维展开\n中心化高斯过程 $B(t)$ 的KL展开由 $B(t) = \\sum_{k=1}^{\\infty} \\sqrt{\\lambda_k} Z_k \\phi_k(t)$ 给出，其中 $Z_k$ 是独立同分布的标准正态随机变量。我们代入推导出的特征值和特征函数（使用 $t$ 作为变量）：\n- 特征值：$\\lambda_k = \\frac{4}{(2k-1)^2\\pi^2}$\n- 特征函数：$\\phi_k(t) = \\sqrt{2} \\sin\\left(\\frac{(2k-1)\\pi t}{2}\\right)$\n特征值的平方根是 $\\sqrt{\\lambda_k} = \\frac{2}{(2k-1)\\pi}$。\n综合这些结果，标准布朗运动在 $[0,1]$ 上的KL展开为：\n$$ B(t) = \\sum_{k=1}^{\\infty} \\left( \\frac{2}{(2k-1)\\pi} \\right) Z_k \\left( \\sqrt{2} \\sin\\left(\\frac{(2k-1)\\pi t}{2}\\right) \\right) $$\n$$ B(t) = \\sum_{k=1}^{\\infty} \\frac{2\\sqrt{2}}{(2k-1)\\pi} Z_k \\sin\\left(\\frac{(2k-1)\\pi t}{2}\\right) $$\n该表达式将标准布朗运动 $B(t)$ 表示为一个无穷级数，该级数由确定性的正弦函数和随机、不相关的正态系数构成。", "answer": "$$\n\\boxed{B(t) = \\sum_{k=1}^{\\infty} \\frac{2\\sqrt{2}}{(2k-1)\\pi} Z_k \\sin\\left(\\frac{(2k-1)\\pi t}{2}\\right)}\n$$", "id": "3340706"}, {"introduction": "对于大多数协方差核，像前面布朗运动那样的解析解是无法得到的，这使得数值方法成为不可或缺的工具。本练习介绍了一种强大的数值技术——伽辽金法 (Galerkin method)，用于逼近连续协方差算子的特征对。您将使用傅里叶余弦基来构建一个有限维子空间，并通过数值积分将一个无限维的积分算子问题转化为一个有限维的广义特征值问题。这个实践不仅能加深您对算子谱理论的理解，还能让您掌握一种将连续数学问题离散化以进行计算分析的通用策略。[@problem_id:3340711]", "problem": "给定区间 $[0,1]$ 上的零均值高斯过程，其协方差核为 $K(s,t)=\\exp(-|s-t|)$。考虑相关的协方差算子 $T:L^2([0,1])\\to L^2([0,1])$，定义为 $(Tf)(s)=\\int_0^1 K(s,t)f(t)\\,dt$。K 的 Mercer 展开将 $K(s,t)$ 表示为 $T$ 的特征函数乘积之和，并由相应的特征值加权。您的任务是使用有限维子空间构建此算子的 Galerkin 近似，计算其主特征对，并定量评估截断近似 Mercer 展开的收敛性。\n\n从以下基础出发：\n- 对于连续、对称、半正定的 $K$，协方差算子 $T$ 在 $L^2([0,1])$ 上是紧的、自伴的且正的。\n- Mercer 展开表明 $K(s,t)=\\sum_{k=1}^\\infty \\lambda_k \\psi_k(s)\\psi_k(t)$，其中 $\\{\\lambda_k\\}_{k\\ge 1}$ 是 $T$ 的非负特征值，$\\{\\psi_k\\}_{k\\ge 1}$ 是由 $T$ 的特征函数组成的 $L^2([0,1])$ 的一个标准正交基。\n\n使用以下规范实现 Galerkin 方法：\n- 使用在 $[0,1]$ 上的标准正交傅里叶余弦基，定义为 $\\phi_0(s)=1$ 和 $\\phi_k(s)=\\sqrt{2}\\cos(\\pi k s)$（对于 $k\\ge 1$）。维度为 $m$ 的子空间是 $V_m=\\text{span}\\{\\phi_0,\\phi_1,\\ldots,\\phi_{m-1}\\}$。\n- 通过 $[0,1]$ 上的 $n$ 点 Gauss–Legendre 求积法来近似所需的积分。令 $\\{x_i,w_i\\}_{i=1}^n$ 表示 $[0,1]$ 上的求积节点和权重。\n- 组装 Galerkin 矩阵\n$$A_{ij}=\\int_0^1\\int_0^1 \\phi_i(s)K(s,t)\\phi_j(t)\\,ds\\,dt,\\quad M_{ij}=\\int_0^1 \\phi_i(s)\\phi_j(s)\\,ds,$$\n使用求积近似\n$$A_{ij}\\approx \\sum_{p=1}^n\\sum_{q=1}^n w_p w_q\\, \\phi_i(x_p)\\,K(x_p,x_q)\\,\\phi_j(x_q),\\quad M_{ij}\\approx \\sum_{p=1}^n w_p\\,\\phi_i(x_p)\\,\\phi_j(x_p).$$\n- 计算广义对称正定特征问题 $A v=\\lambda M v$，特征值按非增序排列，特征向量为 $M$-标准正交。构造近似特征函数 $\\psi_k(s)\\approx \\sum_{j=0}^{m-1} v_{j}^{(k)}\\phi_j(s)$。\n- 对于给定的截断秩 $r$，构造截断近似 Mercer 展开\n$$K_r(s,t)=\\sum_{k=1}^{r}\\lambda_k\\,\\psi_k(s)\\,\\psi_k(t),$$\n并通过 $[0,1]\\times[0,1]$ 上的加权 $L^2$ 范数来度量近似误差：\n$$\\text{err}(m,n,r)=\\left(\\int_0^1\\int_0^1 \\left(K(s,t)-K_r(s,t)\\right)^2\\,ds\\,dt\\right)^{1/2},$$\n通过求积近似为\n$$\\text{err}(m,n,r)\\approx \\left(\\sum_{p=1}^n\\sum_{q=1}^n w_p w_q \\left(K(x_p,x_q)-K_r(x_p,x_q)\\right)^2\\right)^{1/2}.$$\n\n实现约束：\n- 积分必须如上所述，使用 $[0,1]$ 上的 Gauss–Legendre 求积法进行近似。\n- 如果 $r=0$，则定义 $K_r$ 恒为 $0$，并相应地计算误差。\n- 如果 $r$ 超过 $V_m$ 的维度，则将 $r$ 截断为可用的特征对数量。\n- 所有角度（如果存在）必须以弧度为单位。不涉及物理单位。\n\n测试套件：\n为以下每组参数 $(m,n,r)$ 计算 $\\text{err}(m,n,r)$：\n- $(5,64,3)$\n- $(10,128,6)$\n- $(20,256,12)$\n- $(5,64,0)$\n- $(5,64,20)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果应与上述测试套件的顺序一致。例如，输出必须类似于 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_k$ 是一个浮点数，表示相应测试用例的 $\\text{err}(m,n,r)$。", "solution": "该问题要求对区间 $[0,1]$ 上的零均值高斯过程，使用指定的协方差核 $K(s,t)=\\exp(-|s-t|)$，进行 Karhunen-Loève 展开的数值近似。这是通过 Galerkin 方法完成的，这是一种将无限维算子问题转换为有限维矩阵问题的标准技术。然后评估所得近似的准确性。\n\n该问题的基础是 Mercer's theorem，该定理适用于协方差算子 $T:L^2([0,1])\\to L^2([0,1])$，其定义为 $(Tf)(s)=\\int_0^1 K(s,t)f(t)\\,dt$。由于核 $K(s,t)$ 是连续、对称且半正定的，因此算子 $T$ 是紧的、自伴的且正的。Mercer's theorem 指出，该核可以表示为一个绝对且一致收敛的级数：\n$$\nK(s,t)=\\sum_{k=1}^\\infty \\lambda_k \\psi_k(s)\\psi_k(t)\n$$\n其中 $\\{\\lambda_k\\}_{k\\ge 1}$ 是 $T$ 的非负特征值，$\\{\\psi_k\\}_{k\\ge 1}$ 是由特征函数组成的 $L^2([0,1])$ 的相应标准正交基。特征对 $(\\lambda_k, \\psi_k)$ 是积分特征值方程的解：\n$$\n(T\\psi_k)(s) = \\int_0^1 K(s,t)\\psi_k(t)\\,dt = \\lambda_k \\psi_k(s)\n$$\n\nGalerkin 方法通过将问题限制在有限维子空间 $V_m \\subset L^2([0,1])$ 上来近似解。我们寻求一个近似特征函数 $\\psi^{(m)}(s) \\in V_m$，它可以表示为张成该子空间的基函数的线性组合：\n$$\n\\psi^{(m)}(s) = \\sum_{j=0}^{m-1} v_j \\phi_j(s)\n$$\n$V_m$ 的基被指定为 $[0,1]$ 上的标准正交傅里叶余弦基的前 $m$ 个元素：\n$$\n\\phi_0(s)=1, \\quad \\phi_k(s)=\\sqrt{2}\\cos(\\pi k s) \\text{ for } k\\ge 1\n$$\n将近似 $\\psi^{(m)}$ 代入特征值方程，并将结果投影到每个基函数 $\\phi_i(s)$ 上（对于 $i=0, \\dots, m-1$），得到问题的弱形式：\n$$\n\\int_0^1 \\phi_i(s) \\left( \\int_0^1 K(s,t) \\sum_{j=0}^{m-1} v_j \\phi_j(t) \\,dt \\right) \\,ds = \\lambda \\int_0^1 \\phi_i(s) \\left( \\sum_{j=0}^{m-1} v_j \\phi_j(s) \\right) \\,ds\n$$\n根据积分的线性性质，这可以重写为：\n$$\n\\sum_{j=0}^{m-1} \\left(\\int_0^1\\int_0^1 \\phi_i(s)K(s,t)\\phi_j(t)\\,ds\\,dt\\right) v_j = \\lambda \\sum_{j=0}^{m-1} \\left(\\int_0^1 \\phi_i(s)\\phi_j(s)\\,ds\\right) v_j\n$$\n这是一个形式为 $A\\mathbf{v} = \\lambda M\\mathbf{v}$ 的广义矩阵特征值问题，其中 $\\mathbf{v} = [v_0, \\dots, v_{m-1}]^T$ 是系数向量。矩阵 $A$ 和 $M$ 的元素定义如下：\n$$\nA_{ij}=\\int_0^1\\int_0^1 \\phi_i(s)K(s,t)\\phi_j(t)\\,ds\\,dt, \\quad M_{ij}=\\int_0^1 \\phi_i(s)\\phi_j(s)\\,ds\n$$\n由于所选的基 $\\{\\phi_j\\}$ 是标准正交的，精确的质量矩阵 $M$ 将是单位矩阵，即 $M_{ij} = \\delta_{ij}$。然而，问题指定这些积分要使用 $[0,1]$ 上的 $n$ 点 Gauss-Legendre 求积法进行数值近似。令 $\\{x_p, w_p\\}_{p=1}^n$ 为求积节点和权重。然后将矩阵组装为：\n$$\nA_{ij}\\approx \\sum_{p=1}^n\\sum_{q=1}^n w_p w_q\\, \\phi_i(x_p)\\,K(x_p,x_q)\\,\\phi_j(x_q)\n$$\n$$\nM_{ij}\\approx \\sum_{p=1}^n w_p\\,\\phi_i(x_p)\\,\\phi_j(x_p)\n$$\n由此产生的数值质量矩阵 $M$ 将是单位矩阵的一个紧密近似，但在广义特征问题 $A\\mathbf{v} = \\lambda M\\mathbf{v}$ 中使用它可以校正由求积法在内积中引入的误差。\n\n求解这个 $m \\times m$ 的广义对称特征问题，可以得到 $m$ 个近似特征对 $(\\lambda_k, \\mathbf{v}^{(k)})$。特征值按降序排列，$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_m \\ge 0$。特征向量 $\\mathbf{v}^{(k)}$ 被归一化为 $M$-标准正交，即 $(\\mathbf{v}^{(k)})^T M \\mathbf{v}^{(l)} = \\delta_{kl}$。每个特征向量为近似特征函数提供了系数：$\\psi_k(s) \\approx \\sum_{j=0}^{m-1} v_j^{(k)} \\phi_j(s)$。\n\n利用这些近似特征对，我们构造秩为 $r$ 的截断 Mercer 展开：\n$$\nK_r(s,t)=\\sum_{k=1}^{r}\\lambda_k\\,\\psi_k(s)\\,\\psi_k(t)\n$$\n其中如果 $r > m$，则 $r$ 被截断为 $m$；如果 $r=0$，则 $K_r(s,t) \\equiv 0$。近似误差通过域 $[0,1] \\times [0,1]$ 上的加权均方根误差来量化：\n$$\n\\text{err}(m,n,r)=\\left(\\int_0^1\\int_0^1 \\left(K(s,t)-K_r(s,t)\\right)^2\\,ds\\,dt\\right)^{1/2}\n$$\n该积分也使用 $n$ 点求积法计算：\n$$\n\\text{err}(m,n,r)\\approx \\left(\\sum_{p=1}^n\\sum_{q=1}^n w_p w_q \\left(K(x_p,x_q)-K_r(x_p,x_q)\\right)^2\\right)^{1/2}\n$$\n$K_r(s,t)$ 在求积节点 $(x_p, x_q)$ 处的值是使用计算出的特征值和在这些节点上求值的特征函数来计算的。对测试套件中提供的每组参数 $(m,n,r)$ 重复整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Computes the approximation error of the truncated Mercer expansion for\n    a given covariance kernel using the Galerkin method.\n    \"\"\"\n    test_cases = [\n        (5, 64, 3),\n        (10, 128, 6),\n        (20, 256, 12),\n        (5, 64, 0),\n        (5, 64, 20),\n    ]\n\n    results = []\n    for m, n, r in test_cases:\n        # Step 1: Gauss-Legendre quadrature nodes and weights for [0, 1]\n        lg_nodes, lg_weights = roots_legendre(n)\n        nodes = 0.5 * (lg_nodes + 1.0)\n        weights = 0.5 * lg_weights\n\n        # Step 2: Evaluate basis functions at quadrature nodes\n        # Phi_mat is an n x m matrix where Phi_mat[p, j] = phi_j(x_p)\n        Phi_mat = np.zeros((n, m))\n        Phi_mat[:, 0] = 1.0\n        for j in range(1, m):\n            Phi_mat[:, j] = np.sqrt(2.0) * np.cos(j * np.pi * nodes)\n\n        # Step 3: Assemble the kernel matrix K(s,t) at quadrature nodes\n        # K_mat is an n x n matrix where K_mat[p, q] = exp(-|x_p - x_q|)\n        s_nodes, t_nodes = np.meshgrid(nodes, nodes)\n        K_mat = np.exp(-np.abs(s_nodes - t_nodes))\n\n        # Step 4: Assemble Galerkin matrices A and M using numerical quadrature\n        # A_ij = sum_{p,q} w_p w_q phi_i(x_p) K(x_p,x_q) phi_j(x_q)\n        # M_ij = sum_p w_p phi_i(x_p) phi_j(x_p)\n        A = np.einsum('p,pi,pq,q,qj->ij', weights, Phi_mat, K_mat, weights, Phi_mat)\n        M = np.einsum('p,pi,pj->ij', weights, Phi_mat, Phi_mat)\n\n        # Step 5: Solve the generalized eigenvalue problem A v = lambda M v\n        # eigh returns eigenvalues in ascending order, so we reverse them.\n        eigvals, eigvecs = eigh(A, M)\n        eigvals = eigvals[::-1]\n        eigvecs = eigvecs[:, ::-1]\n\n        # Step 6: Define the effective rank of truncation\n        # If r > m, we can only use the m available eigenpairs.\n        r_eff = min(r, m)\n\n        # Step 7: Construct the truncated kernel approximation K_r\n        if r_eff == 0:\n            K_r_mat = np.zeros((n, n))\n        else:\n            # Select top r_eff eigenpairs\n            top_eigvals = eigvals[:r_eff]\n            top_eigvecs = eigvecs[:, :r_eff]\n\n            # Approximate eigenfunctions evaluated at nodes: Psi = Phi * V\n            # Psi_approx is an n x r_eff matrix\n            Psi_approx = Phi_mat @ top_eigvecs\n            \n            # K_r(s,t) = sum_{k=1..r} lambda_k psi_k(s) psi_k(t)\n            # At nodes: K_r_mat = Psi * diag(lambda) * Psi^T\n            K_r_mat = Psi_approx @ np.diag(top_eigvals) @ Psi_approx.T\n        \n        # Step 8: Calculate the approximation error\n        # err^2 = sum_{p,q} w_p w_q (K(p,q) - K_r(p,q))^2\n        diff_mat = K_mat - K_r_mat\n        error_sq = np.einsum('p,q,pq,pq->', weights, weights, diff_mat, diff_mat)\n        error = np.sqrt(error_sq)\n        \n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{res:.12f}' for res in results)}]\")\n\nsolve()\n\n```", "id": "3340711"}, {"introduction": "从理论和数值方法过渡到实际应用，本练习将指导您设计并实现一个完整的仿真流程，用于在离散网格上模拟具有 Matérn 核的高斯过程。该方法采用最直接的路径：构建协方差矩阵并计算其特征分解。除了实现 KL 展开的截断求和，本练习还强调了在科学计算中至关重要的现实考量：计算复杂度和内存占用。通过分析这些性能指标，您将学会如何在保证仿真精度的同时，评估和设计一个在计算资源方面切实可行的仿真方案。[@problem_id:3340755]", "problem": "考虑一个定义在紧区间 $[0,1]$ 上的零均值高斯过程 (GP)，其协方差函数由 Matérn 核给出。令 $X(t)$ 表示该 GP，令 $k(r)$ 表示其在分离度 $r = |t - s|$ 处求值的协方差函数。Matérn 核定义为\n$$\nk_{\\text{Matérn}}(r; \\nu, \\ell, \\sigma^2) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left( \\frac{\\sqrt{2\\nu}\\, r}{\\ell} \\right)^\\nu K_\\nu\\!\\left( \\frac{\\sqrt{2\\nu}\\, r}{\\ell} \\right),\n$$\n其中 $\\nu > 0$ 是平滑度参数，$\\ell > 0$ 是长度尺度，$\\sigma^2 > 0$ 是边际方差，$\\Gamma(\\cdot)$ 是伽马函数，而 $K_\\nu(\\cdot)$ 是第二类修正贝塞尔函数。在对角线上，通过连续性设置 $k_{\\text{Matérn}}(0;\\nu,\\ell,\\sigma^2) = \\sigma^2$。\n\n根据 Karhunen-Loève (KL) 展开，在适当的正则性条件下，紧凑域上的零均值 GP（其协方差算子为 $C$）可以表示为\n$$\nX(t) \\stackrel{d}{=} \\sum_{i=1}^{\\infty} \\sqrt{\\lambda_i}\\, \\xi_i \\, \\phi_i(t),\n$$\n其中 $\\{(\\lambda_i, \\phi_i)\\}_{i\\ge1}$ 是协方差算子 $C$ 的特征对（其中 $\\lambda_i \\ge 0$），而 $\\{\\xi_i\\}_{i\\ge1}$ 是独立同分布的标准正态随机变量。将展开截断至 $m$ 项可得到一个近似\n$$\nX_m(t) = \\sum_{i=1}^{m} \\sqrt{\\lambda_i}\\, \\xi_i \\, \\phi_i(t).\n$$\n\n您的任务是设计并实现一个仿真流程，该流程使用由离散协方差矩阵导出的 KL 展开，在 $[0,1]$ 上的一个包含 $n=2000$ 个点的均匀网格上近似 $X_m(t)$ 的一次实现。该流程必须遵循以下基于第一性原理的设计：\n\n1. 在 $[0,1]$ 上构建一个均匀网格 $\\{t_j\\}_{j=1}^{n}$，并形成 $n \\times n$ 的协方差矩阵 $K$，其元素为 $K_{ij} = k_{\\text{Matérn}}(|t_i - t_j|;\\nu,\\ell,\\sigma^2)$。\n\n2. 使用适合大型矩阵的迭代方法，计算对称正定矩阵 $K$ 的前 $m$ 个特征对 $\\{(\\lambda_i, v_i)\\}_{i=1}^{m}$。将 $v_i$ 解释为在网格点上采样的特征函数 $\\phi_i(t)$ 的离散对应物。\n\n3. 对 $i=1,\\dots,m$ 独立抽取 $\\xi_i \\sim \\mathcal{N}(0,1)$，并通过以下方式合成一个截断的 KL 样本 $y \\in \\mathbb{R}^{n}$：\n$$\ny = \\sum_{i=1}^{m} \\sqrt{\\lambda_i}\\, \\xi_i \\, v_i.\n$$\n\n4. 使用基于代数运算的单位成本模型为该流程提供复杂度估计，其中使用以下近似：\n   - 构建密集协方差矩阵的成本约为 $n^2$ 次成对计算。\n   - 迭代特征求解器需要进行 $s$ 次矩阵-向量乘法，对于密集矩阵，每次的成本约为 $n^2$。假设 $s = 30$。\n   - 采样和合成 $y$ 的成本约为 $n m$。\n\n   在此模型下，报告一个标量计数\n   $$\n   C_{\\text{ops}} = 2 n^2 + s n^2 + n m,\n   $$\n   其中因子 $2$ 解释了在构建 $K$ 时距离评估和核函数评估的单独贡献。\n\n5. 使用以下有原则的近似方法，为该流程提供以兆字节 (MB) 为单位的峰值内存使用量表示的内存占用估计：\n   - 在协方差构建期间，假设内存中同时存在三个密集的 $n \\times n$ 数组（用于距离矩阵、一个中间缩放参数和协方差矩阵），每个数组都以 64 位浮点格式存储。\n   - 此外，还需考虑存储 $m$ 个主要特征向量（一个 $n \\times m$ 的密集数组）、$m$ 个主要特征值（一个长度为 $m$ 的数组）、网格点（长度为 $n$）和合成样本（长度为 $n$）。\n   - 使用每个 64 位浮点数 8 字节，峰值内存（以字节为单位）为\n     $$\n     M_{\\text{bytes}} = 8 \\left( 3 n^2 + n m + m + 2n \\right),\n     $$\n     峰值内存（以兆字节为单位）为 $M_{\\text{MB}} = M_{\\text{bytes}} / 2^{20}$。\n\n6. 作为 KL 截断质量的度量，报告解释方差比\n   $$\n   R = \\frac{\\sum_{i=1}^{m} \\lambda_i}{\\operatorname{trace}(K)},\n   $$\n   其中，对于指定的 Matérn 核，$\\operatorname{trace}(K) = \\sum_{j=1}^{n} K_{jj} = n \\sigma^2$。\n\n您的程序必须实现上述流程，并为以下参数集 $(\\nu,\\ell,\\sigma^2,m)$ 的测试套件生成结果：\n- 测试 1 (正常路径): $(\\nu,\\ell,\\sigma^2,m) = (1.5, 0.2, 1.0, 25)$。\n- 测试 2 (截断中的边界情况): $(\\nu,\\ell,\\sigma^2,m) = (0.5, 0.2, 1.0, 1)$。\n- 测试 3 (短长度尺度边缘情况): $(\\nu,\\ell,\\sigma^2,m) = (1.5, 0.05, 1.0, 25)$。\n- 测试 4 (更平滑的过程): $(\\nu,\\ell,\\sigma^2,m) = (2.5, 0.5, 1.0, 50)$。\n\n对于每个测试，计算并返回如上定义的三元组 $(M_{\\text{MB}}, C_{\\text{ops}}, R)$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，三元组按测试顺​​序展开，即\n$$\n\\left[ M_{\\text{MB}}^{(1)}, C_{\\text{ops}}^{(1)}, R^{(1)}, M_{\\text{MB}}^{(2)}, C_{\\text{ops}}^{(2)}, R^{(2)}, M_{\\text{MB}}^{(3)}, C_{\\text{ops}}^{(3)}, R^{(3)}, M_{\\text{MB}}^{(4)}, C_{\\text{ops}}^{(4)}, R^{(4)} \\right].\n$$\n所有数值输出必须表示为实数（浮点数）。不涉及物理单位；内存必须按照上述公式以兆字节表示。不出现角度，也不需要百分比，因为解释方差比是介于 0 和 1 之间（含两端）的小数。\n\n您的实现必须是一个完整的、可在现代编程语言中运行的程序，并且不得需要任何用户输入、外部文件或网络访问。", "solution": "问题陈述已经过严格验证，被认为是有效的。它提出了一个科学上合理、适定且完整的任务，植根于随机过程（特别是高斯过程 (GP)）及其通过 Karhunen-Loève (KL) 展开表示的既定原则。求解所需的所有参数、常数和公式都得到了明确无误的定义。该任务是科学计算和计算统计学中的一个标准练习。\n\n解决方案涉及实现指定的仿真和分析流程。该方法论被分解为问题陈述中定义的步骤。\n\n**1. 协方差矩阵构建**\n\n仿真的基础是 GP 的协方差结构，该结构在网格上被离散化。在区间 $[0,1]$ 上构建一个包含 $n=2000$ 个点的均匀网格 $\\{t_j\\}_{j=1}^{n}$。网格点定义为 $t_j = (j-1)/(n-1)$，其中 $j=1, \\dots, n$。\n\n根据此网格，形成一个 $n \\times n$ 的距离矩阵 $D$，其元素为 $D_{ij} = |t_i - t_j|$。\n\n然后通过将 Matérn 核应用于距离矩阵的每个元素来构建协方差矩阵 $K$：$K_{ij} = k_{\\text{Matérn}}(D_{ij}; \\nu, \\ell, \\sigma^2)$。Matérn 核由以下公式给出：\n$$\nk_{\\text{Matérn}}(r; \\nu, \\ell, \\sigma^2) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left( \\frac{\\sqrt{2\\nu}\\, r}{\\ell} \\right)^\\nu K_\\nu\\!\\left( \\frac{\\sqrt{2\\nu}\\, r}{\\ell} \\right)\n$$\n其中 $r$ 是分离度，$\\nu > 0$ 是平滑度参数，$\\ell > 0$ 是长度尺度，$\\sigma^2 > 0$ 是边际方差。$\\Gamma(\\cdot)$ 是伽马函数，$K_\\nu(\\cdot)$ 是第二类修正贝塞尔函数。对于参数 $r=0$ 的情况，核函数的值取其极限 $k_{\\text{Matérn}}(0) = \\sigma^2$。这种特殊处理是必要的，因为该公式涉及像 $r^\\nu$ 和 $K_\\nu(Ar)$ 这样的项，在数值上可能导致类似 $0 \\times \\infty$ 的不定形式。最终得到的矩阵 $K$ 是对称正定的。\n\n**2. 协方差矩阵的特征分解**\n\n连续的 KL 展开涉及协方差算子的特征对。在这种离散设置中，我们求解协方差矩阵 $K$ 的特征对。问题要求求解前 $m$ 个主要特征对，它们对应于 $m$ 个最大的特征值。这些特征对 $\\{(\\lambda_i, v_i)\\}_{i=1}^{m}$ 是为对称矩阵 $K$ 计算的。特征值 $\\lambda_i$ 是实数且为正，特征向量 $v_i \\in \\mathbb{R}^n$ 是标准正交的。向量 $v_i$ 是在网格点 $\\{t_j\\}$ 上求值的特征函数 $\\phi_i(t)$ 的离散模拟。\n\n对于一个大小为 $n=2000$ 的大型密集矩阵，完全的特征分解计算成本会很高 ($O(n^3)$)。由于只需要前 $m$ 个特征对（$m \\ll n$），因此如问题所述，迭代方法是合适的。像 Lanczos 方法这样的算法对此目的非常高效，我们将使用此类求解器的库实现。\n\n**3. GP 实现的合成**\n\n截断的 KL 展开提供了一种从 GP 中合成近似样本的方法。单个实现由向量 $y \\in \\mathbb{R}^n$ 表示，通过以下公式合成：\n$$\ny = \\sum_{i=1}^{m} \\sqrt{\\lambda_i}\\, \\xi_i \\, v_i\n$$\n这里，$\\{\\xi_i\\}_{i=1}^{m}$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。虽然此步骤在概念上是流程的一部分，但输出指标（它们是确定性的）并不需要具体的随机样本 $y$。\n\n**4. 计算复杂度估计**\n\n问题提供了一个单位成本模型来估计代数运算的数量。总成本 $C_{\\text{ops}}$ 由三个主要阶段的成本之和给出：\n$$\nC_{\\text{ops}} = 2 n^2 + s n^2 + n m\n$$\n其中：\n- $2n^2$ 负责构建 $n \\times n$ 的距离矩阵，然后是 $n \\times n$ 的协方差矩阵。\n- $sn^2$ 模拟了迭代特征求解器的成本，假设它对密集的 $n \\times n$ 矩阵 $K$ 执行 $s=30$ 次矩阵-向量乘法。\n- $nm$ 表示从 $m$ 个长度为 $n$ 的特征向量合成样本向量 $y$ 的成本。\n\n对于每个测试用例，将使用 $n=2000$，$s=30$ 和指定的 $m$ 值来评估此公式。\n\n**5. 内存占用估计**\n\n提供了一个模型来估计以兆字节 (MB) 为单位的峰值内存使用量。以字节为单位的内存 $M_{\\text{bytes}}$ 为：\n$$\nM_{\\text{bytes}} = 8 \\left( 3 n^2 + n m + m + 2n \\right)\n$$\n这些项对应于以下各项的存储：\n- 在构建 $K$ 期间使用的三个 $n \\times n$ 数组（例如，距离、核函数参数、最终协方差值），以 64 位浮点数（8 字节）存储。这是 $3n^2$。\n- $m$ 个计算出的特征向量，形成一个 $n \\times m$ 数组：$nm$。\n- $m$ 个计算出的特征值：$m$。\n- 网格点数组（$n$）和最终合成的样本数组（$n$）：$2n$。\n\n以兆字节为单位的最终值计算为 $M_{\\text{MB}} = M_{\\text{bytes}} / 2^{20}$。将为每个测试用例评估此公式。\n\n**6. 解释方差比**\n\n为评估 $m$ 项 KL 截断的质量，计算了解释方差比 $R$。它是前 $m$ 个分量捕获的总方差的分数：\n$$\nR = \\frac{\\sum_{i=1}^{m} \\lambda_i}{\\operatorname{trace}(K)}\n$$\n协方差矩阵的迹 $\\operatorname{trace}(K) = \\sum_{j=1}^{n} K_{jj}$ 代表了离散化过程中的总方差。对于 Matérn 核，对角线元素是恒定的，$K_{jj} = k_{\\text{Matérn}}(0) = \\sigma^2$。因此，迹简化为 $\\operatorname{trace}(K) = n \\sigma^2$。分子是在步骤 2 中计算出的 $m$ 个最大特征值的总和。\n$$\nR = \\frac{\\sum_{i=1}^{m} \\lambda_i}{n \\sigma^2}\n$$\n将为每组参数计算此数量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma, kv\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Implements the GP simulation pipeline and computes specified metrics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (nu, ell, sigma2, m)\n        (1.5, 0.2, 1.0, 25),  # Test 1\n        (0.5, 0.2, 1.0, 1),   # Test 2\n        (1.5, 0.05, 1.0, 25), # Test 3\n        (2.5, 0.5, 1.0, 50),  # Test 4\n    ]\n\n    # Global parameters\n    n = 2000\n    s = 30\n\n    results = []\n\n    def matern_kernel(r, nu, ell, sigma2):\n        \"\"\"\n        Computes the Matérn kernel.\n        \n        Args:\n            r (np.ndarray): Separation distances.\n            nu (float): Smoothness parameter.\n            ell (float): Length-scale parameter.\n            sigma2 (float): Marginal variance.\n            \n        Returns:\n            np.ndarray: Covariance values.\n        \"\"\"\n        # The formula is undefined for r=0, but the limit is sigma2.\n        # We need to handle this to avoid 0 * inf = nan.\n        r_is_zero = (r == 0)\n        \n        # To avoid division by zero or warnings, we work with a \"safe\" r.\n        # The values for r=0 will be overwritten later.\n        r_safe = np.where(r_is_zero, 1.0, r)\n        \n        # Calculate the argument for the Bessel function\n        arg = np.sqrt(2 * nu) * r_safe / ell\n        \n        # Matern formula components\n        term1 = sigma2 * (2**(1 - nu) / gamma(nu))\n        term2 = arg**nu\n        term3 = kv(nu, arg)\n        \n        # Combine terms for r > 0\n        k = term1 * term2 * term3\n        \n        # Apply the known limit for r = 0\n        if k.ndim > 0:\n            k[r_is_zero] = sigma2\n        elif r_is_zero:\n            k = sigma2\n            \n        return k\n\n    for case in test_cases:\n        nu, ell, sigma2, m = case\n\n        # 4. Complexity estimate\n        c_ops = float(2 * n**2 + s * n**2 + n * m)\n\n        # 5. Memory footprint estimate\n        m_bytes = 8 * (3 * n**2 + n * m + m + 2 * n)\n        m_mb = float(m_bytes / (2**20))\n\n        # 1. Construct covariance matrix\n        t = np.linspace(0, 1, n)\n        # Create the distance matrix using broadcasting\n        dist_matrix = np.abs(t[:, None] - t)\n        \n        K = matern_kernel(dist_matrix, nu, ell, sigma2)\n\n        # 2. Compute leading m eigenpairs\n        # eigsh is suitable for large, symmetric matrices.\n        # 'LA' specifies to find the largest (Largest Algebraic) eigenvalues.\n        if m > 0:\n            eigenvalues, _ = eigsh(K, k=m, which='LA')\n        else: # Handle m=0 case, though not in test suite.\n            eigenvalues = np.array([])\n\n        # 6. Explained variance ratio\n        # Denominator is trace(K) = n * sigma^2\n        trace_K = n * sigma2\n        if trace_K > 0:\n            r_explained_variance = float(np.sum(eigenvalues) / trace_K)\n        else:\n            r_explained_variance = 0.0\n\n        results.extend([m_mb, c_ops, r_explained_variance])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.6f}' for val in results)}]\")\n\nsolve()\n```", "id": "3340755"}]}