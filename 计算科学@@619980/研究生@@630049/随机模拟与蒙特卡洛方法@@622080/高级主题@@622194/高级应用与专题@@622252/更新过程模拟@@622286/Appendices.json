{"hands_on_practices": [{"introduction": "更新过程的模拟始于其最核心的定义：事件（或“更新”）以随机的时间间隔相继发生。本练习的目标是指导你从第一性原理出发，构建一个事件驱动的模拟算法。这种方法通过逐个生成更新事件来精确地复现过程的样本路径，是理解和应用更新过程的基础。[@problem_id:3343949]", "problem": "为更新计数过程设计并实现一个可证明正确的事件驱动模拟算法。设 $\\{X_i\\}_{i \\geq 1}$ 为独立同分布的到达间隔时间，其累积分布函数为 $F$，并定义更新时刻 $T_n = \\sum_{i=1}^n X_i$，约定 $T_0 = 0$。更新计数过程为 $N(t) = \\max\\{n \\geq 0 : T_n \\le t\\}$，适用于 $t \\ge 0$。您的任务是推导、论证并实现一个算法，该算法在给定有限期限 $T$ 的情况下，模拟所有的更新时刻 $\\{T_n : T_n \\le T\\}$，并在指定的查询时间 $t \\in [0,T]$ 评估 $N(t)$。该算法必须是事件驱动的，即仅在更新时刻推进模拟时间，并且必须：\n- 使用正确的停止规则，在下一个提议的时刻将超过期限时停止，即当 $T_{n+1} > T$ 时。\n- 当到达间隔分布是格点支撑的或在 $0$ 处有原子时，能正确处理平局情况，以便同时发生的更新都被计数，并且在精确更新时间的查询包含截至该时间（包括该时间）的所有更新（即，使用约定 $N(t) = \\max\\{n : T_n \\le t\\}$）。\n- 通过固定下面指定的伪随机数生成器种子来确保可复现性。\n\n基本出发点：您的推导必须基于更新时刻 $T_n$ 和计数过程 $N(t)$ 的定义、到达间隔时间 $X_i \\sim F$ 的独立同分布特性，以及事件驱动的更新规则 $T_{n+1} = T_n + X_{n+1}$。\n\n您的程序必须：\n- 为每个指定的到达间隔分布 $F$ 实现采样器。\n- 模拟更新时间集合 $\\{T_n \\le T\\}$，包括当 $X_i = 0$ 发生时的重复时刻，并使用定义 $N(t) = \\max\\{n : T_n \\le t\\}$ 在提供的查询时间列表上评估 $N(t)$。\n- 使用以种子 $s = 20231019$ 初始化的伪随机数生成器。\n- 生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，不含空格，其中每个测试用例的结果本身是与查询时间顺序相同的整数列表（例如，两个测试用例的输出可能看起来像 $[[1,2],[3]]$）。\n\n假设：假设 $F$ 是 $[0,\\infty)$ 上的一个正则分布，且 $\\mathbb{P}(X_1 = 0)  1$，因此在时间 $0$ 发生无限次更新的概率为 $0$。\n\n测试套件。对于每个测试用例 $k \\in \\{1,2,3,4,5\\}$，给定一个到达间隔分布、一个期限 $T^{(k)}$ 以及一个有序的查询时间列表 $\\mathcal{Q}^{(k)} \\subset [0,T^{(k)}]$。对于每个测试用例，程序必须按查询顺序输出列表 $\\bigl[N(t) : t \\in \\mathcal{Q}^{(k)}\\bigr]$。\n\n- 测试用例 1（连续）：$F$ 是速率为 $\\lambda = 1.7$ 的指数分布；$T^{(1)} = 5.0$；$\\mathcal{Q}^{(1)} = [0.0, 1.0, 2.5, 5.0]$。\n- 测试用例 2（确定性格点）：$F$ 是确定性的，其中 $X_i \\equiv c$，$c = 0.5$；$T^{(2)} = 3.0$；$\\mathcal{Q}^{(2)} = [1.0, 1.5, 3.0]$。\n- 测试用例 3（离散格点）：$F$ 是离散的，其中 $\\mathbb{P}(X_i = 0.25) = 0.2$，$\\mathbb{P}(X_i = 0.5) = 0.5$，$\\mathbb{P}(X_i = 0.75) = 0.3$；$T^{(3)} = 2.0$；$\\mathcal{Q}^{(3)} = [0.25, 1.0, 2.0]$。\n- 测试用例 4（零膨胀连续）：$F$ 在 $0$ 处有一个概率为 $p_0 = 0.3$ 的原子，否则是速率为 $\\lambda = 2.0$ 的指数分布；$T^{(4)} = 1.0$；$\\mathcal{Q}^{(4)} = [0.0, 1.0]$。\n- 测试用例 5（边界）：$F$ 是速率为 $\\lambda = 1.0$ 的指数分布；$T^{(5)} = 0.0$；$\\mathcal{Q}^{(5)} = [0.0]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，不含空格，其中每个元素是对应一个测试用例的整数列表，顺序与上述指定相同。例如，所需格式类似于 $[[a_{1,1},a_{1,2},\\dots],[a_{2,1},\\dots],\\dots]$，行内没有任何空格。\n\n本问题中没有物理单位。所有数值答案必须以整数形式生成。伪随机数种子必须设置为 $s = 20231019$，并且平局情况下的包含约定如上所述。", "solution": "该问题要求为更新计数过程 $N(t)$ 设计并实现一个直至有限期限 $T$ 的事件驱动模拟算法。该解决方案必须从基本原理推导而来，并且是可证明正确的。\n\n**1. 基本原理和定义**\n\n更新过程由一系列独立同分布 (IID) 的非负随机变量 $\\{X_i\\}_{i \\geq 1}$ 定义，这些变量表示到达间隔时间，具有共同的累积分布函数 (CDF) $F$。\n\n更新时刻 $T_n$ 是指更新发生的时刻。它们被定义为前 $n$ 个到达间隔时间之和：\n$$T_n = \\sum_{i=1}^{n} X_i \\quad \\text{for } n \\geq 1$$\n按照惯例，过程从时间 $0$ 开始，因此我们定义 $T_0 = 0$。\n\n更新计数过程 $N(t)$ 统计截至时间 $t$（包括 $t$）已发生的更新次数。其形式化定义为：\n$$N(t) = \\max\\{n \\geq 0 : T_n \\le t\\}$$\n\n**2. 算法推导：事件驱动模拟**\n\n目标是模拟更新过程 $\\{T_n\\}_{n \\ge 0}$ 的一次实现（一个样本路径），并用它在指定的查询时间评估 $N(t)$。题目强制要求采用事件驱动的模拟方法，这是对此类系统而言最自然、最高效的方法。在这种范式中，模拟时钟不是连续推进，而是从一个事件时间“跳”到下一个。对于更新过程，唯一的事件就是更新本身。\n\n该算法的核心是生成更新时刻序列 $\\{T_n\\}$ 的迭代过程。在任何时刻，模拟的状态都可以由最后一次更新的时间 $T_n$ 来表征。下一个状态 $T_{n+1}$ 通过生成一个新的到达间隔时间 $X_{n+1}$ 并更新时间来得到。\n\n_状态变量_：\n- $t_{current}$：模拟的当前时间，对应于最近生成的更新时刻。\n- `epochs`：一个列表，用于存储生成的更新时刻序列 $\\{T_0, T_1, T_2, \\dots\\}$。\n\n_算法步骤_：\n1.  **初始化**：\n    模拟从时间 $0$ 的第 $0$ 次更新开始。\n    - 初始化当前时间：$t_{current} = T_0 = 0$。\n    - 初始化时刻列表：`epochs` $= [0.0]$。\n    - 使用指定的种子 $s=20231019$ 初始化一个伪随机数生成器 (PRNG)，以确保可复现性。所有随机变量必须从这唯一的 PRNG 实例中抽取。\n\n2.  **事件生成循环**：\n    模拟通过一次生成一个更新来推进。循环持续进行，直到下一个潜在的更新会发生在模拟期限 $T$ 之后。\n    - 采用 `while True` 循环结构。\n    - **生成到达间隔时间**：在循环内部，从到达间隔分布 $F$ 中抽取一个样本 $x$。这是通过使用针对给定 CDF $F$ 的特定采样器来完成的。\n    - **计算下一个时刻**：下一个潜在更新的时间是 $t_{next} = t_{current} + x$。根据 $T_n$ 的定义，如果 $t_{current} = T_n$，那么 $t_{next} = T_n + X_{n+1} = T_{n+1}$。\n    - **停止规则**：如果下一个事件发生在期限 $T$ 之外，模拟必须停止。因此，如果 $t_{next}  T$，循环终止。这正确地实现了模拟所有时刻 $\\{T_n : T_n \\leq T\\}$ 的要求。\n    - **更新状态**：如果 $t_{next} \\le T$，则该更新有效。模拟状态更新如下：\n        - 当前时间推进到新的时刻：$t_{current} = t_{next}$。\n        - 记录新的时刻：将 $t_{current}$ 追加到 `epochs` 列表中。\n\n这个过程生成一个列表 `epochs`，包含 $[T_0, T_1, \\dots, T_k]$，其中 $k = \\max\\{n : T_n \\le T\\}$。根据构造，此列表按非递减顺序排序。$X_i=0$ 的可能性被自然地处理，因为它导致 $T_{n+1} = T_n$ 并在 `epochs` 列表中追加一个重复的时间，从而正确地增加了在该特定时间的更新计数。\n\n**3. 计数过程 $N(t)$ 的评估**\n\n一旦生成了更新时刻列表 $[T_0, T_1, \\dots, T_k]$，我们就可以对任何查询时间 $t \\in [0, T]$ 评估 $N(t)$。根据其定义，$N(t) = \\max\\{n \\geq 0 : T_n \\le t\\}$。\n\n给定已排序的 `epochs` 列表，$N(t)$ 对应于满足 `epochs[n]` $\\le t$ 的最大索引 $n$。这等同于查找 `epochs` 中小于或等于 $t$ 的元素数量，然后减 $1$（因为索引 $n$ 是从 $0$ 开始的，并且对应于 $n+1$ 个元素 $T_0, \\dots, T_n$）。\n\n这个搜索可以使用二分搜索算法高效执行。具体来说，右侧二分搜索（如 `numpy.searchsorted` 的 `side='right'`）可以找到保持排序顺序的 $t$ 的插入点。这个插入点恰好是数组中小于或等于 $t$ 的元素计数。设此计数为 $c$。那么，$N(t) = c - 1$。这种方法是稳健的，并能按照 $T_n \\le t$ 条件的要求，正确处理与更新时刻重合的查询时间。\n\n**4. 到达间隔时间采样器**\n\n生成到达间隔时间 $X_i$ 需要为指定的分布实现采样器。这通常通过使用逆变换采样方法或利用基于标准、已验证算法的内置库函数来完成。\n\n- **指数分布 ($\\text{Exp}(\\lambda)$)**：其 CDF 为 $F(x) = 1 - e^{-\\lambda x}$。通过逆变换法，可以生成一个样本 $X = F^{-1}(U) = -\\frac{1}{\\lambda}\\ln(1-U)$，其中 $U \\sim \\text{Uniform}(0,1)$。这等同于从 `numpy.random.Generator.exponential(scale=1/lambda)` 采样。\n\n- **确定性分布 ($X=c$)**：采样器只返回常数 $c$。\n\n- **离散分布**：对于具有概率质量函数 $\\mathbb{P}(X=v_j) = p_j$ 的离散分布，通过抽取 $U \\sim \\text{Uniform}(0,1)$ 并找到索引 $j$ 使得 $\\sum_{i=1}^{j-1} p_i \\le U  \\sum_{i=1}^{j} p_i$ 来生成样本。这可以通过 `numpy.random.Generator.choice(values, p=probabilities)` 高效实现。\n\n- **零膨胀混合分布**：一个在 $0$ 处有概率为 $p_0$ 的原子与一个概率为 $1-p_0$ 的连续分布 $G$ 的混合。通过首先生成 $U \\sim \\text{Uniform}(0,1)$ 来抽取样本。如果 $U  p_0$，样本为 $0$。否则，从分布 $G$ 中抽取一个样本。\n\n这种系统化的方法，建立在更新过程的数学定义之上，并采用标准的、正确的模拟技术，保证了实现是有效且可复现的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the renewal process simulation.\n    \"\"\"\n\n    def simulate_renewal_process(sampler, T, query_times, rng):\n        \"\"\"\n        Simulates a renewal process and evaluates N(t) at query times.\n\n        Args:\n            sampler (function): A function that takes an rng instance and returns a\n                                sample from the interarrival distribution F.\n            T (float): The simulation time horizon.\n            query_times (list of float): A list of times t to evaluate N(t).\n            rng (np.random.Generator): The random number generator instance.\n\n        Returns:\n            list of int: A list of the values of N(t) for each query time.\n        \"\"\"\n        t_current = 0.0\n        epochs = [0.0]  # Store T_0, T_1, ...\n\n        while True:\n            interarrival = sampler(rng)\n            t_next = t_current + interarrival\n\n            if t_next  T:\n                break\n            \n            t_current = t_next\n            epochs.append(t_current)\n\n        # Convert to numpy array for efficient search\n        np_epochs = np.array(epochs)\n        \n        results = []\n        for t in query_times:\n            # N(t) = max{n = 0 : T_n = t}\n            # np.searchsorted with side='right' finds the number of elements = t.\n            # This count is n+1. So, N(t) is count - 1.\n            count = np.searchsorted(np_epochs, t, side='right')\n            n_t = count - 1\n            results.append(int(n_t))\n            \n        return results\n\n    # Define samplers for each test case\n    def sampler_case1(rng):\n        return rng.exponential(scale=1.0 / 1.7)\n\n    def sampler_case2(rng):\n        return 0.5\n\n    def sampler_case3(rng):\n        values = [0.25, 0.5, 0.75]\n        probabilities = [0.2, 0.5, 0.3]\n        return rng.choice(values, p=probabilities)\n\n    def sampler_case4(rng):\n        p0 = 0.3\n        if rng.random()  p0:\n            return 0.0\n        else:\n            return rng.exponential(scale=1.0 / 2.0)\n\n    def sampler_case5(rng):\n        return rng.exponential(scale=1.0 / 1.0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'sampler': sampler_case1, 'T': 5.0, 'query_times': [0.0, 1.0, 2.5, 5.0]},\n        {'sampler': sampler_case2, 'T': 3.0, 'query_times': [1.0, 1.5, 3.0]},\n        {'sampler': sampler_case3, 'T': 2.0, 'query_times': [0.25, 1.0, 2.0]},\n        {'sampler': sampler_case4, 'T': 1.0, 'query_times': [0.0, 1.0]},\n        {'sampler': sampler_case5, 'T': 0.0, 'query_times': [0.0]},\n    ]\n    \n    # Initialize a single PRNG instance for reproducibility across all tests.\n    rng = np.random.default_rng(20231019)\n    \n    all_results = []\n    for case in test_cases:\n        result_list = simulate_renewal_process(\n            case['sampler'], case['T'], case['query_times'], rng\n        )\n        all_results.append(result_list)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[1,2],[3,4,5]]\n    inner_strs = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output_str = f\"[{','.join(inner_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3343949"}, {"introduction": "虽然模拟单个样本路径很有用，但我们常常更关心过程的平均行为，这由更新函数 $m(t) = \\mathbb{E}[N(t)]$ 描述。这个函数满足一个积分形式的更新方程，但该方程通常难以获得解析解。本练习将引导你将连续的更新方程离散化，推导并实现一个基于数值卷积的递归算法来求解 $m(t)$ 的近似值。[@problem_id:3343983]", "problem": "考虑一个更新过程，其更新间隔时间是独立同分布的，累积分布函数为 $F$。令 $N(t)$ 表示到时间 $t$ 为止的更新次数，更新函数为 $m(t) = \\mathbb{E}[N(t)]$。根据基础更新理论，更新函数满足更新方程\n$$\nm(t) = F(t) + \\int_{0}^{t} m(t - s) \\, \\mathrm{d}F(s),\n$$\n其中该积分被理解为 Lebesgue-Stieltjes 积分。你的任务是推导、实现并验证一个由 $F$ 在离散化网格 $\\{0, d, 2d, \\dots\\}$ 上（格距为 $d  0$）的格点近似产生的数值卷积方案，然后量化离散化偏差作为 $d$ 和 $t$ 的函数。\n\n推导要求：\n- 从更新方程出发，通过 $F$ 的增量为网格单元分配概率，从而在网格 $\\{0, d, 2d, \\dots\\}$ 上构造 $F$ 的格点近似。将这些网格概率记为 $\\{p_k\\}_{k \\ge 1}$，其中 $p_k$ 对应于区间 $((k-1)d, kd]$。\n- 使用基于网格的近似，将更新方程转换为序列 $\\{m_k\\}_{k \\ge 0}$ 的离散卷积关系，其中 $m_k$ 近似于 $m(kd)$ 且 $m_0 = 0$。\n- 实现一个算法，求解此离散卷积关系直至索引 $K = \\lfloor t/d \\rfloor$。该算法必须仅依赖于 $F$ 的网格增量和卷积项的数值稳定累加。\n\n偏差量化：\n- 将格距为 $d$ 时在时间 $t$ 的离散化偏差定义为\n$$\nB(d, t) = \\left| m_d(t) - m(t) \\right|,\n$$\n其中 $m_d(t)$ 是使用格点方案在 $t$ 处求值的基于网格的近似（可取 $m_d(t) := m_{\\lfloor t/d \\rfloor}$），而 $m(t)$ 是当存在闭式解时的真实更新函数；否则，使用在满足 $h_{\\mathrm{ref}} \\ll d$ 的严格更精细的格距 $h_{\\mathrm{ref}}$ 上的参考计算，以获得 $m_{\\mathrm{ref}}(t)$，并设 $m(t) := m_{\\mathrm{ref}}(t)$。\n\n测试套件：\n实现你的程序，为以下五个测试用例计算 $B(d, t)$。在所有情况下，都在 $t$ 是 $d$ 的精确整数倍的时间点上生成结果，因此 $t = Kd$（$K$ 为某个整数）。\n\n1. 指数分布的更新间隔时间，速率 $\\lambda = 0.7$；使用 $t = 8.0$ 和 $d = 0.5$。真实的更新函数是 $m(t) = \\lambda t$。\n2. 指数分布的更新间隔时间，速率 $\\lambda = 0.7$；使用 $t = 8.0$ 和 $d = 0.1$。真实的更新函数是 $m(t) = \\lambda t$。\n3. 确定性的更新间隔时间 $c = 2.0$；使用 $t = 10.0$ 和 $d = 0.5$。真实的更新函数是 $m(t) = \\lfloor t/c \\rfloor$。\n4. Pareto 分布的更新间隔时间，尺度 $x_m = 1.0$，形状 $\\alpha = 2.5$；使用 $t = 20.0$ 和 $d = 0.5$。不假设 $m(t)$ 有简单的闭式解；而是使用更精细的网格 $h_{\\mathrm{ref}} = 0.01$ 进行参考计算，以获得 $m_{\\mathrm{ref}}(t)$，并设 $m(t) := m_{\\mathrm{ref}}(t)$。\n5. 指数分布的更新间隔时间，速率 $\\lambda = 1.5$；使用 $t = 0.5$ 和 $d = 0.5$。真实的更新函数是 $m(t) = \\lambda t$。\n\n算法约束：\n- 你必须在网格上使用数值稳定的求和方法，精确求解离散卷积关系直至索引 $K$。在实现中，你不得假设或使用任何闭式生成函数解。\n- 当 $m(t)$ 的闭式解可用时，将其用作真值；否则，使用严格更精细的格距 $h_{\\mathrm{ref}}$ 计算参考解。\n- 你的实现必须仅依赖于基本的数值运算和线性代数来累加卷积项。如果提及任何基于变换的方法，例如快速傅里叶变换（Fast Fourier Transform, FFT），你必须在首次出现时写出其全名，但并不要求你使用它。\n\n最终输出：\n- 你的程序应生成一行输出，其中包含按上述顺序列出的五个测试用例的偏差 $\\{B(d, t)\\}$，形式为方括号内以逗号分隔的列表，例如 $[b_1,b_2,b_3,b_4,b_5]$。\n- 所有输出必须是浮点数。\n\n此问题不涉及物理单位。不涉及角度。不要求使用百分比。", "solution": "该问题要求推导并实现一个数值方案，用于在离散格点上求解更新方程，并为几个测试用例量化由此产生的离散化偏差。\n\n### 1. 离散更新方程的推导\n\n该问题的基石是关于更新函数 $m(t) = \\mathbb{E}[N(t)]$ 的积分更新方程：\n$$\nm(t) = F(t) + \\int_{0}^{t} m(t - s) \\, \\mathrm{d}F(s)\n$$\n此处，$F(t)$ 是独立同分布（i.i.d.）更新间隔时间的累积分布函数（CDF）。该积分为一个表示卷积的 Lebesgue-Stieltjes 积分，可写为 $m(t) = F(t) + (m * \\mathrm{d}F)(t)$。\n\n为了推导数值方案，我们在格距为 $d  0$ 的格点上对时间轴进行离散化，格点由点集 $\\{t_n = nd\\}_{n \\ge 0}$ 定义。我们寻求一个近似值 $m_n \\approx m(t_n) = m(nd)$。根据定义，$m(0) = 0$，因此我们设定 $m_0 = 0$。\n\n连续的更新间隔时间分布被格点 $\\{d, 2d, 3d, \\dots\\}$ 上的离散概率质量函数 $\\{p_k\\}_{k \\ge 1}$ 所取代。概率 $p_k$ 定义为一个连续更新间隔时间落入区间 $((k-1)d, kd]$ 内的概率：\n$$\np_k := F(kd) - F((k-1)d), \\quad k = 1, 2, 3, \\dots\n$$\n假设更新间隔时间为非负，$F(0)=0$，则有 $\\sum_{k=1}^{\\infty} p_k = \\lim_{N \\to \\infty} F(Nd) - F(0) = 1$。\n\n我们现在通过在网格点 $t_n = nd$ 上求值来离散化更新方程：\n$$\nm(nd) = F(nd) + \\int_{0}^{nd} m(nd - s) \\, \\mathrm{d}F(s)\n$$\n每一项都由其离散对应项替代：\n1.  $m(nd)$ 由 $m_n$ 近似。\n2.  $F(nd)$，即第一次更新在时间 $nd$ 之前发生的概率，由其离散模拟 $F_d(n) = \\sum_{k=1}^{n} p_k$ 替代。\n3.  积分项是一个卷积。我们可以通过将积分域划分为区间 $[(k-1)d, kd]$ 来近似它：\n    $$\n    \\int_{0}^{nd} m(nd - s) \\, \\mathrm{d}F(s) = \\sum_{k=1}^{n} \\int_{(k-1)d}^{kd} m(nd - s) \\, \\mathrm{d}F(s)\n    $$\n    在每个区间 $((k-1)d, kd]$ 内，我们用一个常数值来近似函数 $m(nd-s)$，例如，取其在有效时间参数右端点的值 $m(nd - kd) = m((n-k)d)$，该值由 $m_{n-k}$ 近似。这得到：\n    $$\n    \\int_{0}^{nd} m(nd - s) \\, \\mathrm{d}F(s) \\approx \\sum_{k=1}^{n} m_{n-k} \\int_{(k-1)d}^{kd} \\mathrm{d}F(s) = \\sum_{k=1}^{n} m_{n-k} p_k\n    $$\n合并这些项，我们得到离散更新方程：\n$$\nm_n = \\sum_{k=1}^{n} p_k + \\sum_{k=1}^{n} m_{n-k} p_k, \\quad n \\ge 1\n$$\n其初始条件为 $m_0 = 0$。这是序列 $\\{m_n\\}$ 的一个递归公式。\n\n### 2. 算法实现\n\n离散更新方程提供了一种直接计算序列 $\\{m_n\\}$ 直至所需索引 $K = \\lfloor t/d \\rfloor$ 的方法。\n\n该算法流程如下：\n1.  给定时间范围 $t$、格距 $d$ 以及累积分布函数 $F(t)$。\n2.  确定最大索引 $K = \\lfloor t/d \\rfloor$。如果 $K=0$，则 $m_d(t) = 0$。\n3.  预先计算概率 $p_k = F(kd) - F((k-1)d)$，其中 $k = 1, \\dots, K$。\n4.  初始化一个大小为 $K+1$ 的数组用于存储更新函数值 $m$，并设 $m_0 = 0$。\n5.  对 $n = 1, \\dots, K$ 迭代计算 $m_n$。在每个步骤 $n$ 中：\n    a. 计算离散CDF值 $F_d(n) = \\sum_{k=1}^{n} p_k$。这可以通过一个运行总和高效完成。\n    b. 计算离散卷积和 $C_n = \\sum_{k=1}^{n} m_{n-k} p_k$。这可以写成向量点积 $\\mathbf{m}_{0:n-1} \\cdot \\mathbf{p}_{n:1}$，其中 $\\mathbf{m}_{0:n-1} = [m_0, m_1, \\dots, m_{n-1}]$ 且 $\\mathbf{p}_{n:1} = [p_n, p_{n-1}, \\dots, p_1]$。\n    c. 于是 $m_n$ 的值为 $m_n = F_d(n) + C_n$。\n6.  最终的近似值为 $m_d(t) = m_K$。\n\n这种直接求和算法的计算复杂度为 $O(K^2)$。对于需要非常大的 $K$ 的问题，基于像快速傅里叶变换（Fast Fourier Transform, FFT）这类方法的更快算法可以降低卷积的复杂度，但对于本问题中的参数，直接的 $O(K^2)$ 方法是足够的，并且它直接源自推导出的递推关系。正项的累加是数值稳定的。\n\n### 3. 偏差量化与测试用例\n\n离散化偏差定义为 $B(d, t) = |m_d(t) - m(t)|$，其中 $m_d(t) = m_{\\lfloor t/d \\rfloor}$ 是由我们的数值方案得到的值，$m(t)$ 是真值。\n\n五个测试用例如下处理：\n\n1.  **指数分布 ($\\lambda = 0.7, t = 8.0, d = 0.5$):**\n    CDF 为 $F(t) = 1 - e^{-\\lambda t}$。真实的更新函数为 $m(t) = \\lambda t = 0.7 \\times 8.0 = 5.6$。我们计算 $m_{16}$ 并求出偏差 $|m_{16} - 5.6|$。\n\n2.  **指数分布 ($\\lambda = 0.7, t = 8.0, d = 0.1$):**\n    与案例1类似，但网格更精细。$m(t) = 5.6$。我们计算 $m_{80}$ 并求出偏差 $|m_{80} - 5.6|$。\n\n3.  **确定性分布 ($c = 2.0, t = 10.0, d = 0.5$):**\n    CDF 是一个阶跃函数：当 $t  c$ 时 $F(t) = 0$，当 $t \\ge c$ 时 $F(t) = 1$。由于 $d$ 能整除 $c$，离散概率质量为 $p_4 = 1$（因为 $k=c/d=4$），而当 $k \\ne 4$ 时 $p_k=0$。离散过程精确地复制了连续过程，因此偏差应为零。真实的更新函数为 $m(t) = \\lfloor t/c \\rfloor = \\lfloor 10.0/2.0 \\rfloor = 5$。\n\n4.  **Pareto 分布 ($x_m = 1.0, \\alpha = 2.5, t = 20.0, d = 0.5$):**\n    当 $x \\ge x_m$ 时，CDF 为 $F(x) = 1 - (x_m/x)^\\alpha$。$m(t)$ 没有可用的闭式解。我们首先使用相同的算法，但采用更精细得多的格距 $h_{\\mathrm{ref}} = 0.01$，计算一个高分辨率的参考值 $m_{\\mathrm{ref}}(t)$。然后，我们用 $d=0.5$ 计算近似值 $m_d(t)$。偏差为 $|m_d(t) - m_{\\mathrm{ref}}(t)|$。\n\n5.  **指数分布 ($\\lambda = 1.5, t = 0.5, d = 0.5$):**\n    这是一个 $K=1$ 的简单情况。真值为 $m(t) = \\lambda t = 1.5 \\times 0.5 = 0.75$。近似值为 $m_1 = p_1 = F(0.5) - F(0) = 1-e^{-1.5 \\times 0.5} = 1-e^{-0.75}$。偏差为 $|(1 - e^{-0.75}) - 0.75|$。\n\n实现将包含一个用于离散更新方程的通用求解器，然后将其应用于每个特定案例以计算偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a numerical convolution scheme for the\n    renewal equation and quantifies discretization bias.\n    \"\"\"\n\n    # --- CDF Definitions ---\n    def cdf_exp(lmbda: float):\n        \"\"\"Returns the CDF of an exponential distribution.\"\"\"\n        def F(t: float) - float:\n            if t  0:\n                return 0.0\n            return 1.0 - np.exp(-lmbda * t)\n        return F\n\n    def cdf_det(c: float):\n        \"\"\"Returns the CDF of a deterministic distribution.\"\"\"\n        def F(t: float) - float:\n            return 1.0 if t = c else 0.0\n        return F\n\n    def cdf_pareto(xm: float, alpha: float):\n        \"\"\"Returns the CDF of a Pareto distribution.\"\"\"\n        def F(x: float) - float:\n            if x  xm:\n                return 0.0\n            return 1.0 - (xm / x)**alpha\n        return F\n\n    # --- Core Numerical Solver ---\n    def solve_discrete_renewal(t: float, d: float, F: callable) - float:\n        \"\"\"\n        Solves the discrete renewal equation on a lattice.\n        \n        Args:\n            t: The time horizon.\n            d: The grid span.\n            F: The CDF of the interarrival times.\n\n        Returns:\n            The approximated renewal function value m_d(t).\n        \"\"\"\n        if t == 0 or d == 0:\n            return 0.0\n        \n        K = int(round(t / d))\n\n        if K == 0:\n            return 0.0\n\n        p = np.zeros(K + 1)\n        for k in range(1, K + 1):\n            p[k] = F(k * d) - F((k - 1) * d)\n\n        m = np.zeros(K + 1)\n        # m[0] = 0.0 is implicitly set by np.zeros\n\n        F_d = 0.0\n        for n in range(1, K + 1):\n            F_d += p[n]\n            # Convolution sum: sum_{k=1 to n} m_{n-k} * p_k\n            # This is equivalent to sum_{j=0 to n-1} m_j * p_{n-j}\n            conv_sum = np.dot(m[:n], p[n:0:-1])\n            m[n] = F_d + conv_sum\n            \n        return m[K]\n\n    # --- Test Case Configuration ---\n    test_cases = [\n        {'id': 1, 'dist': 'exp', 'params': {'lmbda': 0.7}, 't': 8.0, 'd': 0.5},\n        {'id': 2, 'dist': 'exp', 'params': {'lmbda': 0.7}, 't': 8.0, 'd': 0.1},\n        {'id': 3, 'dist': 'det', 'params': {'c': 2.0}, 't': 10.0, 'd': 0.5},\n        {'id': 4, 'dist': 'pareto', 'params': {'xm': 1.0, 'alpha': 2.5}, 't': 20.0, 'd': 0.5, 'h_ref': 0.01},\n        {'id': 5, 'dist': 'exp', 'params': {'lmbda': 1.5}, 't': 0.5, 'd': 0.5},\n    ]\n\n    results = []\n    \n    # --- Processing Test Cases ---\n    for case in test_cases:\n        t, d, dist = case['t'], case['d'], case['dist']\n        params = case['params']\n        \n        m_true = 0.0\n        F = None\n\n        if dist == 'exp':\n            lmbda = params['lmbda']\n            F = cdf_exp(lmbda)\n            m_true = lmbda * t\n        elif dist == 'det':\n            c = params['c']\n            F = cdf_det(c)\n            m_true = np.floor(t / c)\n        elif dist == 'pareto':\n            xm, alpha = params['xm'], params['alpha']\n            F = cdf_pareto(xm, alpha)\n            h_ref = case['h_ref']\n            m_true = solve_discrete_renewal(t, h_ref, F)\n        \n        m_approx = solve_discrete_renewal(t, d, F)\n        \n        bias = np.abs(m_approx - m_true)\n        results.append(bias)\n\n    # --- Final Output ---\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3343983"}, {"introduction": "掌握了正向模拟（即从给定模型生成数据）之后，我们可以挑战更复杂的逆向问题：如何从观测数据中推断出生成这些数据的模型参数？本练习将向你介绍一种强大的技术——模拟矩估计法 (Simulated Method of Moments, SMM)。你将通过模拟不同候选模型的行为，并将其统计矩与“真实”数据的统计矩进行匹配，从而完成对更新过程模型的标定。[@problem_id:3344008]", "problem": "您的任务是使用模拟矩法（Simulated Method of Moments, SMM）校准一个更新到达模型。更新过程由独立的同分布到达间隔时间 $\\{X_i\\}_{i \\ge 1}$ 定义，其共同分布为 $F$，到达时刻为 $S_n = \\sum_{i=1}^n X_i$，计数过程为 $N(t) = \\max\\{n \\ge 0: S_n \\le t\\}$。对于一个固定的观测时域 $T  0$，我们可以通过模拟在时间 $t=0$ 的一个更新时刻开始的更新过程的独立副本，来获得计数 $N(T)$ 的独立观测值。\n\n您的目标是通过使用模拟矩法（SMM）匹配模拟和经验的摘要统计量，从稀疏计数数据中推断到达间隔分布 $F$。考虑一个由两个族组成的参数模型类：\n\n- Gamma 分布族：$X \\sim \\mathrm{Gamma}(k,\\theta)$，其中形状参数 $k0$，尺度参数 $\\theta0$。\n- Lognormal 分布族：$X \\sim \\mathrm{LogNormal}(\\mu,\\sigma)$，其中 $\\log X \\sim \\mathcal{N}(\\mu,\\sigma^2)$，$\\sigma0$。\n\n给定 $T0$ 和 $M \\in \\mathbb{N}$。假设我们观测到 $M$ 个独立的计数 $N_1(T),\\dots,N_M(T)$，每个计数都是在时间 $t=0$ 从一个新的更新时刻开始，在区间 $[0,T]$ 内的更新次数。定义经验矩向量 $\\widehat{m} = (\\widehat{\\mathrm{mean}}, \\widehat{\\mathrm{var}}, \\widehat{p}_0)$，其中 $\\widehat{\\mathrm{mean}}$ 是 $M$ 个观测计数的样本均值，$\\widehat{\\mathrm{var}}$ 是总体样本方差（除以 $M$），而 $\\widehat{p}_0$ 是 $M$ 个观测中零计数的比例。对于某个族内的任何候选参数 $\\vartheta$，令 $g_T(\\vartheta)$ 表示从 $R$ 次对 $N(T)$ 的独立模拟中计算出的模拟矩向量 $(\\mathrm{mean}, \\mathrm{var}, p_0)$，该模拟使用由 $\\vartheta$ 指定的到达间隔分布的更新模型。考虑 SMM 准则\n$$\nJ(\\vartheta) \\equiv \\| g_T(\\vartheta) - \\widehat{m} \\|_2^2,\n$$\n使用单位权重。校准后的参数 $\\hat{\\vartheta}$ 是 $J(\\vartheta)$ 在一个预设的候选值网格上的任何最小化子。\n\n您的程序必须从基本定义和原则出发，实现以下内容：\n\n1. 使用更新过程的核心定义和直接模拟来为每个独立副本生成 $N(T)$。每个副本必须通过从指定的候选分布中抽取到达间隔时间 $X_1,X_2,\\dots$ 并计算完全更新次数，直到部分和超过 $T$ 为止来进行模拟。\n2. 根据下面每个测试案例指定的真实模型，从您生成的合成数据集中计算经验矩 $\\widehat{m}$。使用指定的种子以确保可复现性。\n3. 对于校准，对于每个族中的每个候选参数 $\\vartheta$，模拟 $R$ 个 $N(T)$ 的独立副本并计算 $g_T(\\vartheta)$。然后评估 $J(\\vartheta)$ 并选择最小化子。如果准则值完全相等，程序必须根据下面定义的枚举顺序选择字典序最早的候选者。\n\n分布族和参数网格。您必须搜索以下有限网格：\n\n- Gamma 分布族（族索引 $0$）：形状参数网格 $k \\in \\{0.5, 1.0, 1.5, 2.0, 3.0\\}$ 和尺度参数网格 $\\theta \\in \\{0.5, 0.75, 1.0, 1.5, 2.0, 5.0\\}$。按 $k$ 的升序枚举候选者，在每个 $k$ 值内再按 $\\theta$ 的升序枚举。\n- Lognormal 分布族（族索引 $1$）：均值网格 $\\mu \\in \\{-1.0, -0.5, -0.2, 0.0, 0.2\\}$ 和标准差网格 $\\sigma \\in \\{0.4, 0.6, 0.8, 1.0\\}$。按 $\\mu$ 的升序枚举候选者，在每个 $\\mu$ 值内再按 $\\sigma$ 的升序枚举。\n\n模拟矩的重复次数。对于每个候选者，使用 $R = 5000$ 次模拟来评估 $g_T(\\vartheta)$。为了 SMM 部分的可复现性，对于数据集索引 $d \\in \\{0,1,2\\}$ 和全局候选索引 $c \\in \\mathbb{N}$，您必须使用种子 $777000 + 1000 d + c$ 为该候选者的随机数生成器设定种子。全局候选索引 $c$ 从 Gamma 分布族的第一个候选者开始为 $0$，当您按照指定的枚举顺序遍历 Gamma 网格时加 $1$，并继续在 Lognormal 网格中按照其指定的枚举顺序递增。\n\n经验数据生成。对于下面的每个测试案例，使用指定的真实到达间隔分布族、参数、窗口长度 $T$ 和种子独立生成 $M$ 个观测计数。仅在生成经验数据时，在生成 $M$ 个计数之前使用指定的种子为随机数生成器设定种子。\n\n测试套件。您的程序必须为以下三个数据集解决校准问题。每个数据集由一个真实模型、一个观测窗口长度、一个独立窗口数和一个种子定义。\n\n- 测试案例 1（理想情况；Gamma 真实分布）：真实到达间隔分布 $X \\sim \\mathrm{Gamma}(k^{\\star},\\theta^{\\star})$，其中 $k^{\\star} = 2.0$ 和 $\\theta^{\\star} = 0.75$，窗口长度 $T = 1.0$，窗口数 $M = 400$，经验数据种子 $20231105$。\n- 测试案例 2（备选分布族；Lognormal 真实分布）：真实到达间隔分布 $X \\sim \\mathrm{LogNormal}(\\mu^{\\star},\\sigma^{\\star})$，其中 $\\mu^{\\star} = -0.2$ 和 $\\sigma^{\\star} = 0.6$，窗口长度 $T = 1.0$，窗口数 $M = 400$，经验数据种子 $20231106$。\n- 测试案例 3（边界稀疏性；指数分布真实情况，作为形状为 1 的 Gamma 分布）：真实到达间隔分布 $X \\sim \\mathrm{Gamma}(k^{\\star},\\theta^{\\star})$，其中 $k^{\\star} = 1.0$ 和 $\\theta^{\\star} = 5.0$，窗口长度 $T = 1.0$，窗口数 $M = 2000$，经验数据种子 $20231107$。\n\n附加实现要求。\n\n- 对于所有方差，使用总体方差约定，即除以样本大小（而不是 $M-1$ 或 $R-1$）。\n- 程序不得要求任何用户输入，并且在给定指定的种子和网格的情况下必须是完全确定性的。\n- 程序必须通过指定的字典序枚举顺序选择最小化候选者以打破平局。\n- 族索引必须是整数：Gamma 分布族 $=0$，Lognormal 分布族 $=1$。\n\n最终输出格式。您的程序应产生一行输出，包含一个方括号内的逗号分隔列表形式的结果。此列表的第 $i$ 个元素对应于测试案例 $i$，并且其本身必须是 $[f,\\;p_1,\\;p_2,\\;m,\\;v,\\;p0,\\;J]$ 形式的列表，其中 $f$ 是整数族索引， $p_1$ 和 $p_2$ 是两个校准后的参数，对于 Gamma 是 $(k,\\theta)$ 顺序，对于 Lognormal 是 $(\\mu,\\sigma)$ 顺序， $m$ 是在所选参数下 $N(T)$ 的拟合模拟均值， $v$ 是拟合的模拟方差， $p0$ 是拟合的模拟零概率， $J$ 是最小化的 SMM 准则值。所有数值输出必须是十进制数或整数。最后一行必须看起来像一个包含三个方括号列表的方括号列表，例如 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$，用实际数字代替占位符。", "solution": "该问题提出了一个在计算统计学领域中定义明确且科学合理的任务：使用模拟矩法（SMM）校准一个更新过程模型。问题的所有组成部分——更新过程的定义、统计矩、SMM准则、候选参数网格、模拟参数和种子设定协议——都以足够的清晰度和内部一致性进行了规定，从而能够得到一个唯一的、可验证的解。该问题基于随机模拟和统计推断的既定原则，没有科学缺陷、歧义或矛盾。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n问题的核心是为一个更新过程估计其到达间隔时间分布 $F_\\vartheta$ 的参数 $\\vartheta$。更新过程的特征是一系列到达时刻 $S_n = \\sum_{i=1}^n X_i$，其中到达间隔时间 $\\{X_i\\}_{i \\ge 1}$ 是独立同分布（i.i.d.）的正随机变量，共同分布为 $F_\\vartheta$。在区间 $[0, T]$ 内的更新次数由计数过程 $N(T) = \\max\\{n \\ge 0 : S_n \\le T\\}$ 给出。我们假设过程在时间 $t=0$ 时以一次更新开始，所以 $S_0=0$。\n\n估计过程使用模拟矩法（SMM）执行。该方法通过将从观测数据计算出的矩与在不同参数假设下通过模拟模型生成的矩进行匹配来操作。\n\n首先，我们定义一个摘要统计量（矩）向量来表征该过程。对于给定的一组 $M$ 个观测计数 $\\{N_j(T)\\}_{j=1}^M$，我们计算经验矩向量：\n$$\n\\widehat{m} = (\\widehat{\\mathrm{mean}}, \\widehat{\\mathrm{var}}, \\widehat{p}_0)\n$$\n其中 $\\widehat{\\mathrm{mean}} = \\frac{1}{M}\\sum_{j=1}^M N_j(T)$ 是样本均值，$\\widehat{\\mathrm{var}} = \\frac{1}{M}\\sum_{j=1}^M (N_j(T) - \\widehat{\\mathrm{mean}})^2$ 是样本的总体方差，而 $\\widehat{p}_0 = \\frac{1}{M}\\sum_{j=1}^M \\mathbf{1}\\{N_j(T)=0\\}$ 是零计数的样本比例。\n\n其次，对于来自指定参数族的候选参数向量 $\\vartheta$，我们生成一个对应的模拟矩向量 $g_T(\\vartheta)$。这是通过使用到达间隔分布 $F_\\vartheta$ 对更新过程进行 $R$ 次独立重复模拟，获得计数 $\\{N_r(T;\\vartheta)\\}_{r=1}^R$，然后从这个模拟样本中计算均值、方差和零比例来实现的。\n\n第三，SMM 估计量 $\\hat{\\vartheta}$ 是使经验矩和模拟矩之间差异最小化的参数向量。问题指定了一个带有单位权重矩阵的二次损失函数：\n$$\nJ(\\vartheta) = \\| g_T(\\vartheta) - \\widehat{m} \\|_2^2 = (\\mathrm{mean}(\\vartheta) - \\widehat{\\mathrm{mean}})^2 + (\\mathrm{var}(\\vartheta) - \\widehat{\\mathrm{var}})^2 + (p_0(\\vartheta) - \\widehat{p}_0)^2\n$$\n对最小化子 $\\hat{\\vartheta}$ 的搜索是在为 Gamma 和 Lognormal 这两个分布族预定的有限参数网格上进行的。\n\n对于 3 个指定的测试案例中的每一个，算法按以下步骤进行：\n1.  **生成经验数据**：对于给定的测试案例 $d \\in \\{0, 1, 2\\}$，我们使用指定的真实模型（分布族和参数）、观测窗口 $T$、样本大小 $M$ 和一个专用种子来生成 $M$ 个独立的 $N(T)$ 观测值。此步骤的核心是一个模拟 $N(T)$ 的函数，它通过从真实分布中迭代抽取到达间隔时间 $X_i$ 并将它们相加，直到总时间超过 $T$ 为止。在超过阈值之前的总和中的项数即为 $N(T)$ 的值。\n2.  **计算经验矩**：从生成的 $M$ 个计数中，我们计算目标矩向量 $\\widehat{m} = (\\widehat{\\mathrm{mean}}, \\widehat{\\mathrm{var}}, \\widehat{p}_0)$。\n3.  **通过 SMM 进行校准**：我们遍历 Gamma 和 Lognormal 分布族预定义网格中的每个候选参数 $\\vartheta$。候选者按指定的字典序列出，这定义了一个全局候选索引 $c$。\n    a. 对于每个候选者 $\\vartheta$ 和测试案例 $d$，设定一个唯一的种子：$s = 777000 + 1000 d + c$。\n    b. 使用此种子，我们在参数为 $\\vartheta$ 的模型下模拟 $R=5000$ 个独立的 $N(T)$ 实现。\n    c. 从这 $R$ 次模拟中，我们计算模拟矩向量 $g_T(\\vartheta)$。\n    d. 我们评估目标函数 $J(\\vartheta) = \\| g_T(\\vartheta) - \\widehat{m} \\|_2^2$。\n    e. 我们跟踪产生迄今为止发现的 $J(\\vartheta)$ 最小值的候选者。指定的枚举顺序和用于改进的严格不等式检查确保任何平局都通过选择字典序优先的候选者来解决。\n4.  **存储和报告结果**：检查完所有候选者后，记录该测试案例的最佳拟合分布族索引、其参数、相应的模拟矩和最小化的 $J$ 值。对所有 3 个测试案例重复此过程，并将结果汇总到一个最终列表中。\n\n到达间隔时间的两个参数族是：\n-   **Gamma 分布**（族索引 $0$）：$X \\sim \\mathrm{Gamma}(k, \\theta)$，其中形状参数 $k0$，尺度参数 $\\theta0$。参数网格为 $k \\in \\{0.5, 1.0, 1.5, 2.0, 3.0\\}$ 和 $\\theta \\in \\{0.5, 0.75, 1.0, 1.5, 2.0, 5.0\\}$。\n-   **Lognormal 分布**（族索引 $1$）：$X \\sim \\mathrm{LogNormal}(\\mu, \\sigma)$，其中 $\\log X \\sim \\mathcal{N}(\\mu, \\sigma^2)$。参数网格为 $\\mu \\in \\{-1.0, -0.5, -0.2, 0.0, 0.2\\}$ 和 $\\sigma \\in \\{0.4, 0.6, 0.8, 1.0\\}$。\n\n该实现依赖 `numpy` 从这些分布中生成随机数（`numpy.random.Generator.gamma` 和 `numpy.random.Generator.lognormal`）以及用于高效计算矩的数组操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Simulated Method of Moments (SMM) to calibrate a renewal process model.\n    \"\"\"\n\n    def simulate_n_t(rng, family, params, T, num_reps):\n        \"\"\"\n        Simulates num_reps independent realizations of the renewal count N(T).\n\n        Args:\n            rng (numpy.random.Generator): The random number generator.\n            family (int): 0 for Gamma, 1 for Lognormal.\n            params (tuple): Distribution parameters.\n            T (float): Observation window length.\n            num_reps (int): Number of independent simulations.\n\n        Returns:\n            numpy.ndarray: An array of num_reps counts.\n        \"\"\"\n        counts = np.zeros(num_reps, dtype=int)\n        for i in range(num_reps):\n            current_time = 0.0\n            num_events = 0\n            while True:\n                if family == 0:  # Gamma\n                    k, theta = params\n                    interarrival_time = rng.gamma(k, theta)\n                else:  # Lognormal\n                    mu, sigma = params\n                    interarrival_time = rng.lognormal(mu, sigma)\n\n                if current_time + interarrival_time = T:\n                    current_time += interarrival_time\n                    num_events += 1\n                else:\n                    break\n            counts[i] = num_events\n        return counts\n\n    def compute_moments(counts):\n        \"\"\"\n        Computes the mean, population variance, and proportion of zeros.\n\n        Args:\n            counts (numpy.ndarray): An array of observed counts.\n\n        Returns:\n            tuple: (mean, variance, p0).\n        \"\"\"\n        mean = np.mean(counts)\n        var = np.var(counts)  # Population variance (ddof=0 is default)\n        p0 = np.mean(counts == 0)\n        return mean, var, p0\n\n    # Define test cases\n    test_cases = [\n        {\n            \"true_family\": 0, \"true_params\": (2.0, 0.75), \"T\": 1.0, \n            \"M\": 400, \"seed\": 20231105\n        },\n        {\n            \"true_family\": 1, \"true_params\": (-0.2, 0.6), \"T\": 1.0,\n            \"M\": 400, \"seed\": 20231106\n        },\n        {\n            \"true_family\": 0, \"true_params\": (1.0, 5.0), \"T\": 1.0,\n            \"M\": 2000, \"seed\": 20231107\n        },\n    ]\n\n    # Define parameter grids\n    gamma_k_grid = [0.5, 1.0, 1.5, 2.0, 3.0]\n    gamma_theta_grid = [0.5, 0.75, 1.0, 1.5, 2.0, 5.0]\n    lognormal_mu_grid = [-1.0, -0.5, -0.2, 0.0, 0.2]\n    lognormal_sigma_grid = [0.4, 0.6, 0.8, 1.0]\n\n    candidates = []\n    # Gamma family (index 0)\n    for k in gamma_k_grid:\n        for theta in gamma_theta_grid:\n            candidates.append({\"family\": 0, \"params\": (k, theta)})\n    # Lognormal family (index 1)\n    for mu in lognormal_mu_grid:\n        for sigma in lognormal_sigma_grid:\n            candidates.append({\"family\": 1, \"params\": (mu, sigma)})\n            \n    R = 5000  # Number of replications for SMM\n    all_results = []\n\n    for d, case in enumerate(test_cases):\n        # 1. Generate \"empirical\" data\n        rng_empirical = np.random.default_rng(case[\"seed\"])\n        empirical_counts = simulate_n_t(\n            rng_empirical, case[\"true_family\"], case[\"true_params\"], case[\"T\"], case[\"M\"]\n        )\n        m_hat = compute_moments(empirical_counts)\n        \n        min_J = np.inf\n        best_result = None\n\n        # 2. SMM Calibration\n        for c, cand in enumerate(candidates):\n            # Set seed for SMM simulation\n            smm_seed = 777000 + 1000 * d + c\n            rng_smm = np.random.default_rng(smm_seed)\n\n            # Simulate for the candidate\n            sim_counts = simulate_n_t(\n                rng_smm, cand[\"family\"], cand[\"params\"], case[\"T\"], R\n            )\n            g_theta = compute_moments(sim_counts)\n\n            # Calculate SMM criterion J\n            J = (g_theta[0] - m_hat[0])**2 + \\\n                (g_theta[1] - m_hat[1])**2 + \\\n                (g_theta[2] - m_hat[2])**2\n\n            if J  min_J:\n                min_J = J\n                p1, p2 = cand[\"params\"]\n                m, v, p0 = g_theta\n                best_result = [cand[\"family\"], p1, p2, m, v, p0, J]\n\n        all_results.append(best_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3344008"}]}