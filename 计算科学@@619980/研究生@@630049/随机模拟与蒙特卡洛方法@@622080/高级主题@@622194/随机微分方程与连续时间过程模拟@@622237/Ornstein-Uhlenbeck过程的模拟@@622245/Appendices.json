{"hands_on_practices": [{"introduction": "在我们深入研究Ornstein-Uhlenbeck (OU) 过程的复杂应用之前，我们必须首先理解模拟中最基本的误差来源。欧拉-丸山（Euler-Maruyama）法通过离散的时间步长来近似连续路径，这不可避免地会引入误差。这个练习提供了一个放大镜，让我们在误差的源头——单个模拟步骤——来审视它。通过精确计算单步均方误差，我们不仅可以量化这种近似的精确度，还能揭示模拟参数（如时间步长 $\\Delta$）与过程动态（如均值回归速率 $\\kappa$）之间的关键相互作用 [@problem_id:3344350]。", "problem": "考虑由随机微分方程 (SDE) $dX_{t} = -\\kappa \\left(X_{t} - \\mu \\right) \\, dt + \\sigma \\, dW_{t}$ 定义的 Ornstein–Uhlenbeck (OU) 过程，其中 $\\kappa > 0$ 是均值回归率，$\\mu \\in \\mathbb{R}$ 是长期均值，$\\sigma > 0$ 是扩散系数，而 $W_{t}$ 是一个标准维纳过程。您将从 $t = 0$ 开始，在初始条件为 $X_{0} = \\mu$ 的情况下，模拟该过程在长度为 $\\Delta > 0$ 的单步上的行为。考虑两种单步近似方法：\n\n- 通过求解在 $[0,\\Delta]$ 上的线性 SDE 得到的精确离散化。\n- 由相同的底层维纳增量驱动的 Euler–Maruyama 方法，以形成强耦合。\n\n从 SDE 和 Euler–Maruyama 格式的定义出发，推导单步强均方误差 $E\\!\\left[\\left(X_{\\Delta}^{\\mathrm{EM}} - X_{\\Delta}^{\\mathrm{exact}}\\right)^{2}\\right]$ 作为 $\\kappa$、$\\sigma$ 和 $\\Delta$ 的闭式函数，并将其与精确单步条件方差 $\\operatorname{Var}\\!\\left(X_{\\Delta} \\mid X_{0} = \\mu \\right)$ 进行比较。将相对误差 $R(\\kappa \\Delta)$ 定义为单步强均方误差与 $\\operatorname{Var}\\!\\left(X_{\\Delta} \\mid X_{0} = \\mu \\right)$ 的比率，并提供一个用 $\\kappa$ 和 $\\Delta$ 表示 $R(\\kappa \\Delta)$ 的单一闭式解析表达式。根据此表达式，确定使相对误差最大的 $\\kappa \\Delta$ 的范围。\n\n您的最终答案必须是 $R(\\kappa \\Delta)$ 的单一解析表达式，用 $\\kappa$ 和 $\\Delta$ 书写。无需进行数值舍入。", "solution": "Ornstein–Uhlenbeck (OU) 过程由线性随机微分方程 $dX_{t} = -\\kappa \\left(X_{t} - \\mu \\right) \\, dt + \\sigma \\, dW_{t}$ 决定。对于此类线性 SDE，可以通过积分因子法获得单步的精确解。在区间 $[0,\\Delta]$ 上，初始条件为 $X_{0} = \\mu$ 时，其温和解为\n$$\nX_{\\Delta}^{\\mathrm{exact}} = \\mu + \\sigma \\int_{0}^{\\Delta} \\exp\\!\\left(-\\kappa (\\Delta - s)\\right) \\, dW_{s}.\n$$\n这是通过令 $Y_{t} = X_{t} - \\mu$ 得到的，它满足 $dY_{t} = -\\kappa Y_{t} \\, dt + \\sigma \\, dW_{t}$，然后应用积分因子 $\\exp(\\kappa t)$。\n\n将 Euler–Maruyama 单步格式应用于相同的 SDE，并由相同的维纳增量驱动以实现强耦合，得到\n$$\nX_{\\Delta}^{\\mathrm{EM}} = X_{0} - \\kappa \\left(X_{0} - \\mu\\right) \\Delta + \\sigma \\left(W_{\\Delta} - W_{0}\\right).\n$$\n当 $X_{0} = \\mu$ 时，这简化为\n$$\nX_{\\Delta}^{\\mathrm{EM}} = \\mu + \\sigma \\left(W_{\\Delta} - W_{0}\\right) = \\mu + \\sigma \\int_{0}^{\\Delta} 1 \\, dW_{s}.\n$$\n因此，在共同驱动 $W$ 下的单步强误差是\n$$\nE_{\\Delta} := X_{\\Delta}^{\\mathrm{EM}} - X_{\\Delta}^{\\mathrm{exact}} = \\sigma \\int_{0}^{\\Delta} \\left(1 - \\exp\\!\\left(-\\kappa (\\Delta - s)\\right)\\right) \\, dW_{s}.\n$$\n根据 Itô 等距性，单步强均方误差是\n$$\n\\mathrm{MSE}(\\Delta) := E\\!\\left[\\left(E_{\\Delta}\\right)^{2}\\right] = \\sigma^{2} \\int_{0}^{\\Delta} \\left(1 - \\exp\\!\\left(-\\kappa (\\Delta - s)\\right)\\right)^{2} \\, ds.\n$$\n为了计算该积分，进行变量替换 $u = \\Delta - s$，因此 $s = \\Delta - u$, $ds = -du$，并且当 $s$ 从 $0$ 变到 $\\Delta$ 时，$u$ 从 $\\Delta$ 变到 $0$。因此\n$$\n\\int_{0}^{\\Delta} \\left(1 - \\exp\\!\\left(-\\kappa (\\Delta - s)\\right)\\right)^{2} \\, ds\n= \\int_{0}^{\\Delta} \\left(1 - \\exp(-\\kappa u)\\right)^{2} \\, du.\n$$\n展开平方项并逐项积分，\n$$\n\\int_{0}^{\\Delta} \\left(1 - 2 \\exp(-\\kappa u) + \\exp(-2 \\kappa u)\\right) \\, du\n= \\Delta - 2 \\int_{0}^{\\Delta} \\exp(-\\kappa u) \\, du + \\int_{0}^{\\Delta} \\exp(-2 \\kappa u) \\, du.\n$$\n对于 $\\alpha > 0$，使用 $\\int_{0}^{\\Delta} \\exp(-\\alpha u) \\, du = \\frac{1 - \\exp(-\\alpha \\Delta)}{\\alpha}$，我们得到\n$$\n\\int_{0}^{\\Delta} \\left(1 - \\exp(-\\kappa u)\\right)^{2} \\, du\n= \\Delta - \\frac{2 \\left(1 - \\exp(-\\kappa \\Delta)\\right)}{\\kappa}\n+ \\frac{1 - \\exp(-2 \\kappa \\Delta)}{2 \\kappa}.\n$$\n因此，\n$$\n\\mathrm{MSE}(\\Delta) = \\sigma^{2} \\left[ \\Delta - \\frac{2 \\left(1 - \\exp(-\\kappa \\Delta)\\right)}{\\kappa}\n+ \\frac{1 - \\exp(-2 \\kappa \\Delta)}{2 \\kappa} \\right].\n$$\n\n接下来，计算给定 $X_{0} = \\mu$ 的精确单步条件方差。从精确解可知，\n$$\nX_{\\Delta}^{\\mathrm{exact}} - \\mu = \\sigma \\int_{0}^{\\Delta} \\exp\\!\\left(-\\kappa (\\Delta - s)\\right) \\, dW_{s},\n$$\n并且根据 Itô 等距性，\n$$\n\\operatorname{Var}\\!\\left(X_{\\Delta} \\mid X_{0} = \\mu \\right)\n= \\sigma^{2} \\int_{0}^{\\Delta} \\exp\\!\\left(-2 \\kappa (\\Delta - s)\\right) \\, ds\n= \\sigma^{2} \\int_{0}^{\\Delta} \\exp(-2 \\kappa u) \\, du\n= \\sigma^{2} \\frac{1 - \\exp(-2 \\kappa \\Delta)}{2 \\kappa}.\n$$\n\n将相对误差 $R(\\kappa \\Delta)$ 定义为以下比率\n$$\nR(\\kappa \\Delta) := \\frac{\\mathrm{MSE}(\\Delta)}{\\operatorname{Var}\\!\\left(X_{\\Delta} \\mid X_{0} = \\mu \\right)}.\n$$\n代入上述表达式并化简得到\n$$\nR(\\kappa \\Delta) = \\frac{\\Delta - \\frac{2 \\left(1 - \\exp(-\\kappa \\Delta)\\right)}{\\kappa}\n+ \\frac{1 - \\exp(-2 \\kappa \\Delta)}{2 \\kappa}}{\\frac{1 - \\exp(-2 \\kappa \\Delta)}{2 \\kappa}}\n= \\frac{2 \\kappa \\Delta - 4 \\left(1 - \\exp(-\\kappa \\Delta)\\right) + \\left(1 - \\exp(-2 \\kappa \\Delta)\\right)}{1 - \\exp(-2 \\kappa \\Delta)}.\n$$\n等价地，引入无量纲参数 $\\theta := \\kappa \\Delta$，\n$$\nR(\\theta) = \\frac{2 \\theta - 3 + 4 \\exp(-\\theta) - \\exp(-2 \\theta)}{1 - \\exp(-2 \\theta)}.\n$$\n\n为了确定相对误差最大的范围，我们考察其极限行为。当 $\\theta \\to 0$ 时，使用展开式 $\\exp(-\\theta) = 1 - \\theta + \\frac{\\theta^{2}}{2} - \\frac{\\theta^{3}}{6} + \\cdots$ 和 $\\exp(-2 \\theta) = 1 - 2 \\theta + 2 \\theta^{2} - \\frac{4}{3} \\theta^{3} + \\cdots$ 可得 $R(\\theta) \\sim \\frac{1}{3} \\theta^{2} \\to 0$。当 $\\theta \\to \\infty$ 时，$\\exp(-\\theta)$ 和 $\\exp(-2 \\theta)$ 趋于零，因此 $R(\\theta) \\sim \\frac{2 \\theta - 3}{1} = 2 \\theta - 3$，该值无界增长。因此，当 $\\kappa \\Delta$ 很大时，即时间步长 $\\Delta$ 相对于均值回归时间尺度 $1 / \\kappa$ 很大时，相对误差最大。", "answer": "$$\\boxed{\\frac{2 \\kappa \\Delta - 3 + 4 \\exp\\!\\left(-\\kappa \\Delta\\right) - \\exp\\!\\left(-2 \\kappa \\Delta\\right)}{1 - \\exp\\!\\left(-2 \\kappa \\Delta\\right)}}$$", "id": "3344350"}, {"introduction": "基于我们对离散化误差的理解，这项练习将探讨其在一个实际场景中的微妙而重大的后果。我们研究了当分析师使用近似模拟产生的数据来估计底层连续时间模型的参数时，会发生什么情况。这个实践揭示了离散化误差不仅仅是降低了精度，如果估计过程天真地假设数据来自真实过程，它还会引入系统性误差——即偏差。这项练习强调了将模拟方法与用于分析的统计方法对齐的至关重要性 [@problem_id:3344342]。", "problem": "考虑由随机微分方程 (SDE) $dX_{t} = \\theta (\\mu - X_{t}) \\, dt + \\sigma \\, dW_{t}$ 定义的 Ornstein–Uhlenbeck (OU) 过程，其中 $\\theta > 0$、$\\mu \\in \\mathbb{R}$、$\\sigma > 0$ 且 $W_{t}$ 是一个标准维纳过程。假设使用固定时间步长 $\\Delta > 0$ 的 Euler–Maruyama (EM) 格式来模拟 $\\{X_{n\\Delta}\\}_{n=0}^{N}$，即 $X_{(n+1)\\Delta} = X_{n\\Delta} + \\theta(\\mu - X_{n\\Delta}) \\Delta + \\sigma \\sqrt{\\Delta} \\,\\varepsilon_{n}$，其中 $\\varepsilon_{n}$ 是独立的标准正态随机变量。然后，分析师忽略数据是由 Euler–Maruyama 格式生成这一事实，对 $\\{X_{n\\Delta}\\}$ 拟合一个一阶自回归 (AR(1)) 模型，并通过精确离散化映射 $\\hat{\\theta} = -\\Delta^{-1} \\ln(\\hat{\\varphi})$ 将估计的自回归系数 $\\hat{\\varphi}$ 转换为连续时间均值回归率。假设样本量 $N$ 任意大，从而估计的变异性可以忽略不计，且 $\\hat{\\varphi}$ 收敛于数据生成模型的伪真自回归系数。\n\n仅使用 EM 格式的基本定义、OU 过程的精确离散时间转移以及光滑函数的渐近级数，推导对 EM 模拟数据使用精确离散化映射所引起的渐近偏差 $B(\\Delta) = \\hat{\\theta} - \\theta$ 中关于 $\\Delta$ 的领头阶项。将你的最终结果以关于 $\\Delta$ 的领头阶项（即 $B(\\Delta)$ 中 $\\Delta$ 的最小正次幂的系数）的单一闭式解析表达式形式给出，用 $\\theta$ 和 $\\Delta$ 表示。不包含单位，也不要四舍五入。", "solution": "本题要求解在估计 Ornstein-Uhlenbeck (OU) 过程的均值回归参数 $\\theta$ 时，当估计基于由 Euler-Maruyama (EM) 格式生成的数据，但参数映射假设为精确离散化的情况下，所产生的渐近偏差的领头阶项。\n\nOU 过程由以下随机微分方程 (SDE) 描述：\n$$dX_{t} = \\theta (\\mu - X_{t}) \\, dt + \\sigma \\, dW_{t}$$\n其中 $\\theta > 0$、$\\mu \\in \\mathbb{R}$、$\\sigma > 0$ 且 $W_{t}$ 是一个标准维纳过程。\n\n题目指出，该过程是使用固定时间步长 $\\Delta > 0$ 的 Euler-Maruyama 格式进行模拟的。其离散时间更新规则由下式给出：\n$$X_{(n+1)\\Delta} = X_{n\\Delta} + \\theta(\\mu - X_{n\\Delta}) \\Delta + \\sigma \\sqrt{\\Delta} \\,\\varepsilon_{n}$$\n其中 $\\varepsilon_{n}$ 是来自标准正态分布 $\\varepsilon_{n} \\sim N(0, 1)$ 的独立随机变量。\n\n该方程可以重新整理，以凸显其作为一阶自回归 (AR(1)) 模型的结构：\n$$X_{(n+1)\\Delta} = \\theta\\mu\\Delta + (1 - \\theta\\Delta) X_{n\\Delta} + \\sigma \\sqrt{\\Delta} \\,\\varepsilon_{n}$$\n这是一个标准 AR(1) 过程，形式为 $Y_{n+1} = c + \\phi Y_n + e_{n+1}$，其中 $Y_n = X_{n\\Delta}$，常数项为 $c = \\theta\\mu\\Delta$，自回归系数为 $\\phi = 1 - \\theta\\Delta$，新息项为 $e_{n+1} = \\sigma \\sqrt{\\Delta} \\,\\varepsilon_{n}$。\n\n题目规定样本量 $N$ 任意大，这意味着任何统计估计的变异性都可以忽略。分析师对模拟数据 $\\{X_{n\\Delta}\\}$ 拟合一个 AR(1) 模型。在大样本极限下，估计的自回归系数（记作 $\\hat{\\varphi}$）将收敛于数据生成过程的真实自回归系数。在本例中，数据由 EM 格式生成，因此伪真参数为：\n$$\\hat{\\varphi} = 1 - \\theta\\Delta$$\n\n然而，分析师使用从 OU 过程的*精确*离散化推导出的映射，将此估计系数 $\\hat{\\varphi}$ 转换为连续时间参数的估计值 $\\hat{\\theta}$。OU SDE 在时间间隔 $\\Delta$ 上的精确解给出了以下精确的 AR(1) 表示：\n$$X_{(n+1)\\Delta} = \\mu(1 - e^{-\\theta\\Delta}) + e^{-\\theta\\Delta} X_{n\\Delta} + \\text{噪声项}$$\n从这个精确形式中，连续时间参数 $\\theta$ 和精确离散时间自回归系数 $\\varphi_{\\text{exact}} = e^{-\\theta\\Delta}$ 之间的真实关系是 $\\theta = -\\frac{1}{\\Delta} \\ln(\\varphi_{\\text{exact}})$。\n\n分析师错误地将此映射应用于从 EM 模拟数据中获得的系数 $\\hat{\\varphi}$：\n$$\\hat{\\theta} = -\\frac{1}{\\Delta} \\ln(\\hat{\\varphi})$$\n代入 $\\hat{\\varphi}$ 的表达式：\n$$\\hat{\\theta} = -\\frac{1}{\\Delta} \\ln(1 - \\theta\\Delta)$$\n渐近偏差定义为 $B(\\Delta) = \\hat{\\theta} - \\theta$。因此，\n$$B(\\Delta) = -\\frac{1}{\\Delta} \\ln(1 - \\theta\\Delta) - \\theta$$\n为了找到偏差在 $\\Delta$ 较小时的领头阶项，我们对对数项在 $\\Delta = 0$ 附近进行泰勒级数展开。$\\ln(1-x)$ 在 $x=0$ 附近的泰勒级数为：\n$$\\ln(1-x) = -x - \\frac{x^2}{2} - \\frac{x^3}{3} - \\dots = -\\sum_{k=1}^{\\infty} \\frac{x^k}{k}$$\n令 $x = \\theta\\Delta$，我们有：\n$$\\ln(1 - \\theta\\Delta) = -(\\theta\\Delta) - \\frac{(\\theta\\Delta)^2}{2} - \\frac{(\\theta\\Delta)^3}{3} - O(\\Delta^4)$$\n$$\\ln(1 - \\theta\\Delta) = -\\theta\\Delta - \\frac{\\theta^2\\Delta^2}{2} - O(\\Delta^3)$$\n现在我们将此展开式代回 $\\hat{\\theta}$ 的表达式中：\n$$\\hat{\\theta} = -\\frac{1}{\\Delta} \\left( -\\theta\\Delta - \\frac{\\theta^2\\Delta^2}{2} - O(\\Delta^3) \\right)$$\n$$\\hat{\\theta} = \\theta + \\frac{\\theta^2\\Delta}{2} + O(\\Delta^2)$$\n那么偏差 $B(\\Delta)$ 为：\n$$B(\\Delta) = \\hat{\\theta} - \\theta = \\left( \\theta + \\frac{\\theta^2\\Delta}{2} + O(\\Delta^2) \\right) - \\theta$$\n$$B(\\Delta) = \\frac{\\theta^2\\Delta}{2} + O(\\Delta^2)$$\n偏差 $B(\\Delta)$ 展開式中的领头阶项是具有 $\\Delta$ 最小正次幂的项。该项为 $\\frac{\\theta^2\\Delta}{2}$。这代表了对于小的时间步长 $\\Delta$ 而言，偏差的主要部分。", "answer": "$$\\boxed{\\frac{\\theta^2 \\Delta}{2}}$$", "id": "3344342"}, {"introduction": "当我们关注的是整个路径的属性，而不仅仅是其终点时，离散化误差就变得尤为棘手。这个动手实践项目解决了一个典型挑战：估计一个过程触及某个壁垒的概率，这个量常常被朴素的模拟所低估。在这个练习中，您不仅将量化这种向下偏差，还将亲手实现一种精巧的修正技术，从而学会如何弥合离散模拟与底层连续现实之间的鸿沟 [@problem_id:3344309]。", "problem": "考虑由随机微分方程定义的奥恩斯坦-乌伦贝克过程 $$dX_t=-\\kappa\\left(X_t-\\mu\\right)\\,dt+\\sigma\\,dW_t,$$ 其中 $W_t$ 是标准维纳过程，$\\kappa>0$ 是均值回归速率，$\\mu\\in\\mathbb{R}$ 是长期均值，$\\sigma>0$ 是扩散系数。目标是使用蒙特卡洛模拟（Monte Carlo (MC)）估计概率 $$\\mathbb{P}\\!\\left(\\max_{0\\le s\\le T}X_s\\ge b\\right)$$，其中 $b\\in\\mathbb{R}$ 是一个固定的阈值。讨论通过离散化路径检测壁垒穿越时，由时间离散化引起的系统性向下偏差，并实现一种通过在采样时间点之间使用基于原则的穿越概率校正来减少此偏差的精化方法。您必须从随机模拟的第一性原理出发，并构建您算法选择所需的所有推导。\n\n要求您实现并比较三种估计该概率的蒙特卡洛方法：\n1.  **粗略估计器**：使用欧拉-丸山方法在离散网格上模拟，并仅在网格点上检查穿越。\n2.  **精化估计器**：在粗略估计器基础上，通过解析公式校正区间内的穿越，以减少偏差。\n3.  **高保真参考**：使用OU过程的精确转移律在精细网格上模拟，作为基准。\n\n最终，请提供一个Python 3函数，为给定的测试用例返回这三种方法的估计概率。", "solution": "该问题要求估计奥恩斯坦-乌伦贝克（OU）过程 $X_t$ 在给定时间范围 $[0, T]$ 内超过某个壁垒 $b$ 的概率。OU过程由随机微分方程（SDE）描述：\n$$dX_t = -\\kappa(X_t - \\mu)dt + \\sigma dW_t, \\quad X_0 = x_0$$\n其中 $\\kappa > 0$ 是均值回归速率，$\\mu$ 是长期均值，$\\sigma > 0$ 是波动率，而 $W_t$ 是标准维纳过程。我们的任务是使用三种不同的蒙特卡洛（MC）方法来估计 $\\mathbb{P}(\\max_{0 \\le s \\le T} X_s \\ge b)$，以突显并解决离散化偏差问题。时间区间 $[0, T]$ 被离散化为 $N$ 个步长为 $\\Delta t = T/N$ 的步骤，得到时间网格 $t_i = i \\Delta t$，其中 $i = 0, 1, \\dots, N$。\n\n这三种方法是：1) 基于欧拉-丸山模拟的离散时间最大值的粗略估计量，2) 对此估计量的精化版本，该版本校正了网格点之间错过的壁垒穿越，以及 3) 在精细网格上使用OU过程的精确转移律计算的高保真参考估计量。\n\n**方法 1：通过欧拉-丸山的粗略估计量**\n\n欧拉-丸山方法是数值积分SDE的基本方案。将其应用于OU过程的SDE，得到离散时间更新规则：\n$$X_{t_{i+1}} = X_{t_i} - \\kappa(X_{t_i} - \\mu)\\Delta t + \\sigma \\Delta W_i$$\n其中 $\\Delta W_i = W_{t_{i+1}} - W_{t_i}$ 是维纳过程的增量。这些增量是独立同分布的正态随机变量，均值为0，方差为 $\\Delta t$。我们可以写成 $\\Delta W_i = \\sqrt{\\Delta t} Z_i$，其中 $Z_i \\sim \\mathcal{N}(0, 1)$ 是独立的标准正态随机变量。\n\n模拟过程是通过生成大量的路径（$N_{\\text{paths}}$）来进行的。对于每个路径，我们生成一系列状态 $X_0, X_{t_1}, \\dots, X_{t_N}$。最简单的穿越概率MC估计量是基于仅在这些离散时间点上观察过程的值。我们为每个路径 $j$ 定义一个指示变量：\n$$I_j = \\mathbb{I}\\left(\\max_{0 \\le i \\le N} X_{t_i}^{(j)} \\ge b\\right)$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。粗略估计量 $\\hat{p}_{\\text{coarse}}$ 是这些指示变量的样本均值：\n$$\\hat{p}_{\\text{coarse}} = \\frac{1}{N_{\\text{paths}}} \\sum_{j=1}^{N_{\\text{paths}}} I_j$$\n\n**离散化偏差分析**\n\n这个粗略估计量是系统性偏倚的。OU过程的样本路径是连续的。路径有可能在两个网格点 $t_i$ 和 $t_{i+1}$ 之间越过壁垒 $b$，然后返回到壁垒以下，使得 $X_{t_i}  b$ 和 $X_{t_{i+1}}  b$，但 $\\max_{s \\in [t_i, t_{i+1}]} X_s \\ge b$。在 $t_i$ 点进行的离散时间最大值检查将无法检测到这种穿越。\n\n形式上，离散时间最大值超过壁垒的事件 $E_{\\text{discrete}} = \\{\\max_{0 \\le i \\le N} X_{t_i} \\ge b\\}$ 是我们感兴趣的真实事件（即连续时间最大值超过壁垒的事件 $E_{\\text{continuous}} = \\{\\max_{0 \\le s \\le T} X_s \\ge b\\}$）的一个子集。也就是说，$E_{\\text{discrete}} \\subseteq E_{\\text{continuous}}$。这意味着离散事件的概率小于或等于连续事件的概率：\n$$\\mathbb{P}(E_{\\text{discrete}}) \\le \\mathbb{P}(E_{\\text{continuous}})$$\n估计量 $\\hat{p}_{\\text{coarse}}$ 是 $\\mathbb{P}(E_{\\text{discrete}})$ 的一致估计量，而不是 $\\mathbb{P}(E_{\\text{continuous}})$ 的。因此，$\\hat{p}_{\\text{coarse}}$ 系统性地低估了真实的穿越概率，表现出一种随着时间步长 $\\Delta t$ 趋于0而减小的向下偏差。\n\n**方法 2：带区间校正的精化估计量**\n\n为了减轻这种偏差，我们可以通过考虑在区间 $[t_i, t_{i+1}]$ 内发生穿越的概率来精化估计量，该概率以观察到的端点 $X_{t_i} = u$ 和 $X_{t_{i+1}} = v$ 为条件。\n\n对于小的时间间隔 $\\Delta t$，OU过程的漂移和扩散系数可以近似为常数。具体来说，我们将 $s \\in [t_i, t_{i+1}]$ 上的过程 $X_s$ 近似为一个从 $X_{t_i}=u$ 开始、具有恒定波动率 $\\sigma$ 的布朗运动。漂移项 $-\\kappa(X_s-\\mu)$ 是 $dt$ 阶，而扩散部分 $\\sigma dW_s$ 是 $\\sqrt{dt}$ 阶。对于小的 $\\Delta t$，路径的局部行为由扩散项主导。这证明了将过程局部近似为 $Y_s = u + \\sigma(W_s - W_{t_i})$ 的合理性。\n\n我们需要的是，在给定过程始于 $Y_{t_i} = u$ 并终于 $Y_{t_{i+1}} = v$ 的条件下，该过程穿越壁垒 $b$ 的概率。这是布朗桥的一个经典结果。让我们分析过程 $B_\\tau = W_{t_i+\\tau} - W_{t_i}$，其中 $\\tau \\in [0, \\Delta t]$。$B_\\tau$ 是一个从 $B_0=0$ 开始的标准维纳过程。该过程是 $Y_{t_i+\\tau} = u + \\sigma B_\\tau$。端点条件 $Y_{t_{i+1}}=v$ 固定了维纳增量：$B_{\\Delta t} = (v-u)/\\sigma$。穿越事件是 $\\max_{0 \\le \\tau \\le \\Delta t} Y_{t_i+\\tau} \\ge b$，这等价于 $\\max_{0 \\le \\tau \\le \\Delta t} B_\\tau \\ge (b-u)/\\sigma$。\n\n在给定 $B_T = x  a$ 的条件下，标准维纳过程 $B_\\tau$ 在 $[0, T]$ 上的最大值超过水平 $a  0$ 的概率由下式给出：\n$$\\mathbb{P}(\\max_{0 \\le \\tau \\le T} B_\\tau \\ge a \\mid B_T = x) = \\exp\\left(-\\frac{2a(a-x)}{T}\\right)$$\n映射我们的变量，我们有 $T=\\Delta t$，$a = (b-u)/\\sigma$，以及 $x=(v-u)/\\sigma$。我们需要考虑两个端点都在壁垒以下的情况，即 $u  b$ 和 $v  b$。在这种情况下，$a > 0$ 和 $a-x = (b-u)/\\sigma - (v-u)/\\sigma = (b-v)/\\sigma > 0$。因此，区间内的穿越概率 $p_{\\text{int}}(u, v)$ 可以近似为：\n$$p_{\\text{int}}(u, v) = \\exp\\left(-\\frac{2\\frac{b-u}{\\sigma}\\frac{b-v}{\\sigma}}{\\Delta t}\\right) = \\exp\\left(-\\frac{2(b-u)(b-v)}{\\sigma^2 \\Delta t}\\right)$$\n\n精化估计量 $\\hat{p}_{\\text{refined}}$ 是通过为每个路径计算一个概率而不是一个二元指示变量来构建的。对于路径 $j$，其对总概率的贡献是：\n$$p_j = 1 - \\left(1 - I_j\\right) \\prod_{i=0}^{N-1} \\left(1 - p_{\\text{int}}(X_{t_i}^{(j)}, X_{t_{i+1}}^{(j)})\\right)$$\n其中，如果 $X_{t_i}^{(j)} \\ge b$ 或 $X_{t_{i+1}}^{(j)} \\ge b$，则 $p_{\\text{int}}$ 被定义为0。这个公式计算了在离散点或离散点之间发生至少一次穿越的概率。精化估计量是：\n$$\\hat{p}_{\\text{refined}} = \\frac{1}{N_{\\text{paths}}} \\sum_{j=1}^{N_{\\text{paths}}} p_j$$\n\n**方法 3：高保真参考估计量**\n\nOU过程是一个线性SDE，因此它允许有一个精确的离散时间转移律。从 $X_t$ 到 $X_{t+\\Delta t}$ 的转移由下式给出：\n$$X_{t+\\Delta t} = \\mu + (X_t - \\mu)e^{-\\kappa\\Delta t} + \\sigma\\sqrt{\\frac{1-e^{-2\\kappa\\Delta t}}{2\\kappa}} Z$$\n其中 $Z \\sim \\mathcal{N}(0, 1)$。这个精确的更新规则允许我们模拟OU过程的路径，而不会产生由欧拉-丸山方案引入的偏差。通过在一个非常精细的时间网格（即小的 $\\Delta t_{\\text{fine}}$）上使用这个精确的转移律，我们可以生成高保真的路径。然后，我们可以通过在这些精细路径上取离散时间最大值来获得对真实穿越概率的一个非常准确的估计：\n$$\\hat{p}_{\\text{fine}} = \\frac{1}{N_{\\text{paths}}} \\sum_{j=1}^{N_{\\text{paths}}} \\mathbb{I}\\left(\\max_{0 \\le i \\le N_{\\text{fine}}} X_{t_i}^{(j)} \\ge b\\right)$$\n这个估计量仍然有由离散化（即使是在精细网格上）引起的微小偏差，但通过选择足够小的 $\\Delta t_{\\text{fine}}$，这个偏差可以忽略不计，从而使其成为一个可靠的参考基准，用于评估粗略和精化估计量的性能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case A (happy path)\n        {\n            \"params\": {\"kappa\": 1.5, \"mu\": 0.0, \"sigma\": 0.5, \"x0\": 0.0, \"T\": 1.0, \"b\": 1.0},\n            \"coarse_grid\": {\"dt\": 0.05, \"N_paths\": 100000, \"seed\": 42},\n            \"fine_grid\": {\"dt\": 0.005, \"N_paths\": 40000, \"seed\": 1042},\n        },\n        # Test case B (boundary condition)\n        {\n            \"params\": {\"kappa\": 1.0, \"mu\": 0.0, \"sigma\": 0.5, \"x0\": 0.3, \"T\": 1.0, \"b\": 0.3},\n            \"coarse_grid\": {\"dt\": 0.1, \"N_paths\": 100000, \"seed\": 43},\n            \"fine_grid\": {\"dt\": 0.01, \"N_paths\": 40000, \"seed\": 1043},\n        },\n        # Test case C (rare event with coarse sampling)\n        {\n            \"params\": {\"kappa\": 1.5, \"mu\": 0.0, \"sigma\": 0.5, \"x0\": 0.0, \"T\": 1.0, \"b\": 2.0},\n            \"coarse_grid\": {\"dt\": 0.1, \"N_paths\": 100000, \"seed\": 44},\n            \"fine_grid\": {\"dt\": 0.01, \"N_paths\": 40000, \"seed\": 1044},\n        },\n        # Test case D (short horizon with fast mean reversion)\n        {\n            \"params\": {\"kappa\": 4.0, \"mu\": 0.0, \"sigma\": 1.0, \"x0\": -1.0, \"T\": 0.5, \"b\": 0.0},\n            \"coarse_grid\": {\"dt\": 0.05, \"N_paths\": 100000, \"seed\": 45},\n            \"fine_grid\": {\"dt\": 0.005, \"N_paths\": 40000, \"seed\": 1045},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p = case[\"params\"]\n        cg = case[\"coarse_grid\"]\n        fg = case[\"fine_grid\"]\n\n        # --- Coarse grid simulations ---\n        rng_coarse = np.random.default_rng(cg[\"seed\"])\n        N_coarse = int(p[\"T\"] / cg[\"dt\"])\n\n        # Generate paths using Euler-Maruyama\n        paths_coarse = np.zeros((cg[\"N_paths\"], N_coarse + 1))\n        paths_coarse[:, 0] = p[\"x0\"]\n        \n        for i in range(N_coarse):\n            Z = rng_coarse.standard_normal(cg[\"N_paths\"])\n            drift = -p[\"kappa\"] * (paths_coarse[:, i] - p[\"mu\"]) * cg[\"dt\"]\n            diffusion = p[\"sigma\"] * np.sqrt(cg[\"dt\"]) * Z\n            paths_coarse[:, i+1] = paths_coarse[:, i] + drift + diffusion\n\n        # --- 1. Coarse Estimator ---\n        max_discrete = np.max(paths_coarse, axis=1)\n        p_coarse = np.mean(max_discrete >= p[\"b\"])\n        results.append(p_coarse)\n\n        # --- 2. Refined Estimator ---\n        # Paths that did not cross at discrete points\n        sub_barrier_paths_mask = max_discrete  p[\"b\"]\n        sub_barrier_paths = paths_coarse[sub_barrier_paths_mask]\n        \n        # This is the probability of crossing for each path. Initialize to 1 for paths that already crossed.\n        path_probabilities = np.ones(cg[\"N_paths\"])\n\n        # Calculate interval crossing probabilities only for paths that were always below the barrier at nodes\n        if sub_barrier_paths.shape[0] > 0:\n            u = sub_barrier_paths[:, :-1]\n            v = sub_barrier_paths[:, 1:]\n            \n            # This is p_i(u,v) = exp(-2*(b-u)*(b-v) / (sigma^2 * dt))\n            # The exponent is always non-positive since u,v  b\n            exponent = -2.0 * (p[\"b\"] - u) * (p[\"b\"] - v) / (p[\"sigma\"]**2 * cg[\"dt\"])\n            p_interval_cross = np.exp(np.maximum(exponent, -700)) # clip to avoid underflow being exactly 0\n            \n            # Probability of NOT crossing in any interval for a given path\n            # is the product of (1 - p_interval_cross) over all intervals\n            # log(P(no_cross)) = sum(log(1-p_interval_cross))\n            # Use log-sum-exp trick for numerical stability via log1p\n            log_prob_no_cross = np.sum(np.log1p(-p_interval_cross), axis=1)\n            \n            # Probability of at least one crossing for these paths\n            # P_path_cross = 1 - P(no_cross)\n            p_path_cross = 1.0 - np.exp(log_prob_no_cross)\n            \n            path_probabilities[sub_barrier_paths_mask] = p_path_cross\n\n        p_refined = np.mean(path_probabilities)\n        results.append(p_refined)\n        \n        # --- 3. Fine Grid Reference Estimator ---\n        rng_fine = np.random.default_rng(fg[\"seed\"])\n        N_fine = int(p[\"T\"] / fg[\"dt\"])\n\n        # Generate paths using exact transition\n        paths_fine = np.zeros((fg[\"N_paths\"], N_fine + 1))\n        paths_fine[:, 0] = p[\"x0\"]\n        \n        exp_k_dt = np.exp(-p[\"kappa\"] * fg[\"dt\"])\n        # Variance term\n        if p[\"kappa\"] > 1e-9:\n            var = (p[\"sigma\"]**2 / (2 * p[\"kappa\"])) * (1 - np.exp(-2 * p[\"kappa\"] * fg[\"dt\"]))\n        else: # Taylor expansion for small kappa to avoid 0/0\n            var = p[\"sigma\"]**2 * fg[\"dt\"]\n\n        std_dev = np.sqrt(var)\n\n        for i in range(N_fine):\n            Z = rng_fine.standard_normal(fg[\"N_paths\"])\n            mean = p[\"mu\"] + (paths_fine[:, i] - p[\"mu\"]) * exp_k_dt\n            paths_fine[:, i+1] = mean + std_dev * Z\n\n        p_fine = np.mean(np.max(paths_fine, axis=1) >= p[\"b\"])\n        results.append(p_fine)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3344309"}]}