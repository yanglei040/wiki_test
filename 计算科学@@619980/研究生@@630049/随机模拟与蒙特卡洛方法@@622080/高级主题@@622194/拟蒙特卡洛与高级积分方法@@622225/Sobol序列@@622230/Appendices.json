{"hands_on_practices": [{"introduction": "要真正理解Sobol'序列，没有什么比从头开始构建一个更好的方法了。这项练习将引导你完成核心步骤，揭开其神秘面纱：你将使用从本原多项式派生的方向数，并利用格雷码（Gray code）通过逐位运算将它们组合起来。通过具体的计算，你将巩固对理论概念的理解。[@problem_id:3345407]", "problem": "考虑从第一性原理出发，构造以 $2$ 为基数的二维 Sobol' 序列。此构造使用以下要素。\n\n- 每个坐标（维度）的方向数 $v_j=m_j/2^j$ 由有限域 $\\mathbb{F}_2$ 上的一个本原多项式和一组初始奇数 $m_j$ 生成。对于一个维度，其 $m$ 次本原多项式为 $p(x) = x^m + a_1 x^{m-1} + \\cdots + a_{m-1} x + 1$，$a_k \\in \\{0,1\\}$。对于 $j \\leq m$，初始奇数 $m_1,\\dots,m_m$ 满足 $1 \\leq m_j  2^j$ 已被指定。对于 $j > m$，后续的整数 $m_j$ 通过以下递归关系生成\n$$\nm_j = \\bigoplus_{k=1}^{m-1} (2^k a_k m_{j-k}) \\oplus (2^m m_{j-m}) \\oplus m_{j-m},\n$$\n其中 $\\oplus$ 表示整数上的按位异或（XOR）运算。\n\n- 给定维度 $d \\in \\{1,2\\}$ 的方向数 $\\{v_j^{(d)}\\}_{j \\geq 1}$，维度 $d$ 中的第 $n$ 个坐标由索引 $n$ 的格雷码（Gray code）得到，即 $G(n) = n \\oplus (n \\gg 1)$，其中 $\\gg$ 表示右位移，$\\oplus$ 表示非负整数上的按位异或。如果 $G(n)$ 的二进制展开为 $G(n) = \\sum_{j \\geq 1} g_j(n) 2^{j-1}$，其中比特位 $g_j(n) \\in \\{0,1\\}$，则\n$$\nx_n^{(d)} \\;=\\; \\bigoplus_{j \\geq 1} g_j(n) \\, v_j^{(d)}.\n$$\n\n使用上述基本定义，根据以下具体且完全指定的选择，显式构造前 $8$ 个二维 Sobol' 点 $(x_n^{(1)}, x_n^{(2)})$，其中 $n = 1,2,\\dots,8$。\n\n- 对于维度 $1$，使用 $1$ 次本原多项式 $p_1(x) = x + 1$，以及标准的初始奇数，这意味着对于所有 $j \\geq 1$ 都有 $v_j^{(1)} = 2^{-j}$。\n\n- 对于维度 $2$，使用 $3$ 次本原多项式 $p_2(x) = x^3 + x + 1$，因此 $m = 3$ 且 $(a_1,a_2) = (0,1)$。取初始奇数 $(m_1,m_2,m_3) = (1,3,5)$，因此 $v_1^{(2)} = \\frac{1}{2}$，$v_2^{(2)} = \\frac{3}{4}$ 以及 $v_3^{(2)} = \\frac{5}{8}$。根据需要，通过上述异或递归关系生成 $v_4^{(2)}$。\n\n通过展示以 $2$ 为基数的显式按位操作来执行所有步骤，包括：\n- 对每个 $n$ 计算格雷码比特位 $g_j(n)$，\n- 在二进制展开中计算方向数的异或组合以获得每个坐标。\n\n提供所有坐标的最简分式形式的精确有理数值。无需四舍五入。对于最终答案，按 $n = 1,2,\\dots,8$ 的顺序列出 $8$ 个二维点，并将它们平铺成一个单行矩阵\n$$\n\\bigl[x_1^{(1)} \\; \\; x_1^{(2)} \\; \\; x_2^{(1)} \\; \\; x_2^{(2)} \\; \\; \\dots \\; \\; x_8^{(1)} \\; \\; x_8^{(2)}\\bigr].\n$$", "solution": "问题陈述经确认为自洽、逻辑一致且数学上适定的。构造指定的二维 Sobol' 序列所需的所有必要定义、常数和初始条件均已提供。因此，该问题可按所述方式求解。我将继续详细推导前 $8$ 个点。\n\n任务的核心是计算维度 $d \\in \\{1,2\\}$ 和索引 $n \\in \\{1, 2, \\dots, 8\\}$ 的坐标 $x_n^{(d)}$。其公式为\n$$x_n^{(d)} = \\bigoplus_{j \\geq 1} g_j(n) v_j^{(d)}$$\n其中 $g_j(n)$ 是 $n$ 的格雷码 $G(n) = \\sum_{j \\geq 1} g_j(n) 2^{j-1}$ 二进制展开中的比特位，$\\{v_j^{(d)}\\}$ 是维度 $d$ 的方向数。运算符 $\\oplus$ 表示对二进有理数的二进制表示进行的按位异或（XOR）。\n\n首先，我们为每个维度建立所需的方向数。由于我们需要计算到 $n=8$ 的点，我们必须找到 $G(8)$ 的比特位。索引 $n=8$ 是 $(1000)_2$。其格雷码是 $G(8) = 8 \\oplus (8 \\gg 1) = 8 \\oplus 4 = 12 = (1100)_2$。由于 $12 = 1 \\cdot 2^3 + 1 \\cdot 2^2$，非零比特 $g_j(n)$ 的最高索引是 $j=4$（对于 $g_4(8)=1$）。因此，我们需要两个维度的方向数直到 $v_4^{(d)}$。\n\n**维度 1：**\n问题指定，对于维度 $1$，方向数为 $v_j^{(1)} = 2^{-j}$，对所有 $j \\geq 1$ 成立。我们列出前四个：\n- $v_1^{(1)} = \\frac{1}{2} = (0.1)_2$\n- $v_2^{(1)} = \\frac{1}{4} = (0.01)_2$\n- $v_3^{(1)} = \\frac{1}{8} = (0.001)_2$\n- $v_4^{(1)} = \\frac{1}{16} = (0.0001)_2$\n\n**维度 2：**\n对于维度 $2$，本原多项式为 $p_2(x) = x^3 + x + 1$。这对应于 $m=3$ 的次数和形式为 $p(x) = x^m + a_1 x^{m-1} + \\dots + a_{m-1}x + 1$ 中的系数 $(a_1, a_2) = (0,1)$。\n初始方向数由 $(m_1, m_2, m_3) = (1, 3, 5)$ 给出：\n- $v_1^{(2)} = \\frac{m_1}{2^1} = \\frac{1}{2} = (0.1)_2$\n- $v_2^{(2)} = \\frac{m_2}{2^2} = \\frac{3}{4} = (0.11)_2$\n- $v_3^{(2)} = \\frac{m_3}{2^3} = \\frac{5}{8} = (0.101)_2$\n\n我们必须使用为 $j>m=3$ 提供的递归关系来计算 $v_4^{(2)}$。该递归关系是为整数 $m_j=v_j 2^j$ 定义的。对于 $p_2(x) = x^3 + x + 1$，我们有 $m=3$，$a_1=0$，$a_2=1$。递归关系为：\n$$m_j = (2^1 a_1 m_{j-1}) \\oplus (2^2 a_2 m_{j-2}) \\oplus (2^3 m_{j-3}) \\oplus m_{j-3}$$\n$$m_j = (4 m_{j-2}) \\oplus (8 m_{j-3}) \\oplus m_{j-3}$$\n对于 $j=4$：\n$$m_4 = (4 m_2) \\oplus (8 m_1) \\oplus m_1 = 4(3) \\oplus 8(1) \\oplus 1 = 12 \\oplus 9 = (1100)_2 \\oplus (1001)_2 = (0101)_2 = 5$$\n所以，方向数是 $v_4^{(2)} = \\frac{5}{16} = (0.0101)_2$。\n\n现在我们计算 $n=1, \\dots, 8$ 的点 $(x_n^{(1)}, x_n^{(2)})$。\n\n**n=1**：$1=(1)_2$。$G(1)=1 \\oplus 0 = 1=(1)_2$。所以 $g_1(1)=1$，其他的 $g_j(1)=0$。\n$x_1^{(1)} = v_1^{(1)} = \\frac{1}{2}$。\n$x_1^{(2)} = v_1^{(2)} = \\frac{1}{2}$。\n第 1 个点：$(\\frac{1}{2}, \\frac{1}{2})$。\n\n**n=2**：$2=(10)_2$。$G(2)=2 \\oplus 1 = 3=(11)_2$。所以 $g_1(2)=1, g_2(2)=1$。\n$x_2^{(1)} = v_1^{(1)} \\oplus v_2^{(1)} = \\frac{1}{2} \\oplus \\frac{1}{4} = (0.1)_2 \\oplus (0.01)_2 = (0.11)_2 = \\frac{3}{4}$。\n$x_2^{(2)} = v_1^{(2)} \\oplus v_2^{(2)} = \\frac{1}{2} \\oplus \\frac{3}{4} = (0.10)_2 \\oplus (0.11)_2 = (0.01)_2 = \\frac{1}{4}$。\n第 2 个点：$(\\frac{3}{4}, \\frac{1}{4})$。\n\n**n=3**：$3=(11)_2$。$G(3)=3 \\oplus 1 = 2=(10)_2$。所以 $g_2(3)=1$。\n$x_3^{(1)} = v_2^{(1)} = \\frac{1}{4}$。\n$x_3^{(2)} = v_2^{(2)} = \\frac{3}{4}$。\n第 3 个点：$(\\frac{1}{4}, \\frac{3}{4})$。\n\n**n=4**：$4=(100)_2$。$G(4)=4 \\oplus 2 = 6=(110)_2$。所以 $g_2(4)=1, g_3(4)=1$。\n$x_4^{(1)} = v_2^{(1)} \\oplus v_3^{(1)} = \\frac{1}{4} \\oplus \\frac{1}{8} = (0.010)_2 \\oplus (0.001)_2 = (0.011)_2 = \\frac{3}{8}$。\n$x_4^{(2)} = v_2^{(2)} \\oplus v_3^{(2)} = \\frac{3}{4} \\oplus \\frac{5}{8} = (0.110)_2 \\oplus (0.101)_2 = (0.011)_2 = \\frac{3}{8}$。\n第 4 个点：$(\\frac{3}{8}, \\frac{3}{8})$。\n\n**n=5**：$5=(101)_2$。$G(5)=5 \\oplus 2 = 7=(111)_2$。所以 $g_1(5)=1, g_2(5)=1, g_3(5)=1$。\n$x_5^{(1)} = v_1^{(1)} \\oplus v_2^{(1)} \\oplus v_3^{(1)} = (v_1^{(1)} \\oplus v_2^{(1)}) \\oplus v_3^{(1)} = \\frac{3}{4} \\oplus \\frac{1}{8} = (0.110)_2 \\oplus (0.001)_2 = (0.111)_2 = \\frac{7}{8}$。\n$x_5^{(2)} = v_1^{(2)} \\oplus v_2^{(2)} \\oplus v_3^{(2)} = (v_1^{(2)} \\oplus v_2^{(2)}) \\oplus v_3^{(2)} = \\frac{1}{4} \\oplus \\frac{5}{8} = (0.010)_2 \\oplus (0.101)_2 = (0.111)_2 = \\frac{7}{8}$。\n第 5 个点：$(\\frac{7}{8}, \\frac{7}{8})$。\n\n**n=6**：$6=(110)_2$。$G(6)=6 \\oplus 3 = 5=(101)_2$。所以 $g_1(6)=1, g_3(6)=1$。\n$x_6^{(1)} = v_1^{(1)} \\oplus v_3^{(1)} = \\frac{1}{2} \\oplus \\frac{1}{8} = (0.100)_2 \\oplus (0.001)_2 = (0.101)_2 = \\frac{5}{8}$。\n$x_6^{(2)} = v_1^{(2)} \\oplus v_3^{(2)} = \\frac{1}{2} \\oplus \\frac{5}{8} = (0.100)_2 \\oplus (0.101)_2 = (0.001)_2 = \\frac{1}{8}$。\n第 6 个点：$(\\frac{5}{8}, \\frac{1}{8})$。\n\n**n=7**：$7=(111)_2$。$G(7)=7 \\oplus 3 = 4=(100)_2$。所以 $g_3(7)=1$。\n$x_7^{(1)} = v_3^{(1)} = \\frac{1}{8}$。\n$x_7^{(2)} = v_3^{(2)} = \\frac{5}{8}$。\n第 7 个点：$(\\frac{1}{8}, \\frac{5}{8})$。\n\n**n=8**：$8=(1000)_2$。$G(8)=8 \\oplus 4 = 12=(1100)_2$。所以 $g_3(8)=1, g_4(8)=1$。\n$x_8^{(1)} = v_3^{(1)} \\oplus v_4^{(1)} = \\frac{1}{8} \\oplus \\frac{1}{16} = (0.0010)_2 \\oplus (0.0001)_2 = (0.0011)_2 = \\frac{3}{16}$。\n$x_8^{(2)} = v_3^{(2)} \\oplus v_4^{(2)} = \\frac{5}{8} \\oplus \\frac{5}{16} = (0.1010)_2 \\oplus (0.0101)_2 = (0.1111)_2 = \\frac{15}{16}$。\n第 8 个点：$(\\frac{3}{16}, \\frac{15}{16})$。\n\n计算出的坐标，以精确的最简分数形式表示为：\n- $n=1: (\\frac{1}{2}, \\frac{1}{2})$\n- $n=2: (\\frac{3}{4}, \\frac{1}{4})$\n- $n=3: (\\frac{1}{4}, \\frac{3}{4})$\n- $n=4: (\\frac{3}{8}, \\frac{3}{8})$\n- $n=5: (\\frac{7}{8}, \\frac{7}{8})$\n- $n=6: (\\frac{5}{8}, \\frac{1}{8})$\n- $n=7: (\\frac{1}{8}, \\frac{5}{8})$\n- $n=8: (\\frac{3}{16}, \\frac{15}{16})$\n\n将这些点收集到一个平铺的单行矩阵中作为最终答案。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}  \\frac{1}{2}  \\frac{3}{4}  \\frac{1}{4}  \\frac{1}{4}  \\frac{3}{4}  \\frac{3}{8}  \\frac{3}{8}  \\frac{7}{8}  \\frac{7}{8}  \\frac{5}{8}  \\frac{1}{8}  \\frac{1}{8}  \\frac{5}{8}  \\frac{3}{16}  \\frac{15}{16}\n\\end{pmatrix}\n}\n$$", "id": "3345407"}, {"introduction": "在学会如何构建一个序列之后，下一个合乎逻辑的问题是“它的质量如何？”。这项练习引入了 $t$ 值，这是衡量数字网（digital net）质量的一个关键指标。通过研究一个数字网的生成矩阵与其 $t$ 值之间的关系，你将深入了解是什么将一个高质量（低 $t$ 值）序列与一个较差的序列区分开来。[@problem_id:3345448]", "problem": "考虑由 $m \\times m$ 二进制生成矩阵 $\\{C_{j}\\}_{j=1}^{s}$ 生成的二进制（$b=2$）数字网，其中 $m \\in \\mathbb{N}$ 且 $s \\in \\mathbb{N}$。在 Sobol' 构造中，方向数的选择决定了生成矩阵的元素。一个维度为 $s$、大小为 $N=2^{m}$ 的点集是通过将每个索引向量 $n \\in \\{0,1\\}^{m}$ 映射到坐标而得到的，这些坐标的 $m$ 个二进制数字是在相应生成矩阵下 $n$ 的线性映像。$[0,1)^{s}$ 中的一个基本区间是通过固定坐标 $j$ 的前 $d_{j}$ 个二进制数字来指定的，其中 $j=1,\\dots,s$，且 $d_{j} \\in \\{0,1,\\dots,m\\}$。\n\n从以下基本事实出发：\n- 在一个由 $C_{1},\\dots,C_{s}$ 生成的二进制数字网中，固定坐标 $j$ 的前 $d_{j}$ 个二进制数字会在二元有限域上施加线性约束 $R n = r$，其中 $R$ 是由每个 $C_{j}$ 的前 $d_{j}$ 行堆叠而成的矩阵，而 $r$ 是由所选数字决定的右侧项。\n- $R n = r$ 的解 $n \\in \\{0,1\\}^{m}$ 的数量等于 $2^{m - \\operatorname{rank}(R)}$，并且仅取决于 $R$ 在二元有限域上的秩。\n- 一个点集是数字 $(t,m,s)$-网，当且仅当对于所有满足 $\\sum_{j=1}^{s} d_{j} = m - t$ 的非负整数 $d_{1},\\dots,d_{s}$ 选择，每个这样的基本区间都恰好包含 $2^{t}$ 个点。\n\n仅使用这些基本事实，在维度 $s=2$ 的情况下，推导一种从生成矩阵计算 $t$ 值的方法，并将其应用于以下两种 $m=4$ 且 $C_{1}$ 固定的情景。在两种情景中，令\n$$\nC_{1} \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1\n\\end{pmatrix}.\n$$\n情景 A 使用的方向数产生\n$$\nC_{2}^{(A)} \\;=\\;\n\\begin{pmatrix}\n0  0  0  1 \\\\\n0  0  1  1 \\\\\n0  1  0  1 \\\\\n1  0  0  1\n\\end{pmatrix},\n$$\n而情景 B 使用不同的方向数产生\n$$\nC_{2}^{(B)} \\;=\\;\n\\begin{pmatrix}\n0  0  0  1 \\\\\n0  0  1  1 \\\\\n0  1  0  1 \\\\\n0  1  1  1\n\\end{pmatrix}.\n$$\n\n通过推导并应用上述基本事实所隐含的基于秩的方法，分别计算对应于情景 A 和情景 B 的 $t$ 值 $t_{A}$ 和 $t_{B}$。将最终答案表示为一个行矩阵，其元素为 $t_{A}$ 和 $t_{B}$。无需四舍五入。给出你的推理，说明从情景 A 到情景 B 方向数的变化如何改变了计算出的 $t$ 值。", "solution": "该问题要求基于一组特定的公理化定义，推导一种计算数字网质量参数 $t$ 的方法，并将此方法应用于两种情景。所有运算均在二元有限域 $\\mathbb{F}_2$ 上进行。\n\n首先，我们推导计算 $t$ 值的方法。问题提供了三个基本事实：\n1. 基本区间是通过固定每个坐标 $j=1, \\dots, s$ 的前 $d_j$ 个二进制数字来指定的。对输入索引向量 $n \\in \\{0,1\\}^m$ 的约束构成一个线性系统 $R n = r$，其中 $R$ 是由每个生成矩阵 $C_j$ 的前 $d_j$ 行堆叠而成的矩阵。\n2. 落入这样一个基本区间的网中点的数量由 $2^{m - \\operatorname{rank}(R)}$ 给出，其中秩是在 $\\mathbb{F}_2$ 上计算的。\n3. 一个点集构成一个数字 $(t,m,s)$-网，当且仅当对于所有满足 $\\sum_{j=1}^{s} d_j = m - t$ 的非负整数 $d_1, \\dots, d_s$ 选择，每个对应的基本区间都恰好包含 $2^t$ 个点。\n\n为了推导该方法，我们结合这些事实。对于一个点集要成为 $(t,m,s)$-网，指定区间内的点的数量必须是 $2^t$。根据事实2，这个数量也是 $2^{m - \\operatorname{rank}(R)}$。令这两个表达式相等，得到：\n$$2^t = 2^{m - \\operatorname{rank}(R)}$$\n这意味着对矩阵 $R$ 的秩有以下条件：\n$$t = m - \\operatorname{rank}(R) \\implies \\operatorname{rank}(R) = m - t$$\n这个秩条件必须对所有由满足 $\\sum_{j=1}^{s} d_j = m - t$ 的 $d_1, \\dots, d_s$ 选择所构造的矩阵 $R$ 成立。矩阵 $R$ 是由总共 $k = \\sum d_j = m-t$ 行堆叠而成的。为使其秩等于 $m-t$，其行向量组必须线性无关。\n\n对于一组给定的生成矩阵，质量参数 $t$ 定义为使该点集满足 $(t,m,s)$-网性质的最小非负整数。因此，要计算 $t$ 值，我们必须找到最小的非负整数 $t$，使得对于所有满足 $\\sum_{j=1}^{s} d_j = m - t$ 的非负整数 $d_1, \\dots, d_s$ 选择，从生成矩阵 $\\{C_j\\}$ 中取出的相应 $m-t$ 个行向量组是线性无关的。\n\n推导出的方法如下：\n我们从 $t=0$ 开始测试整数值 $t$。对于每个 $t$，我们检查是否对于所有的划分 $d_1 + \\dots + d_s = m-t$，由每个 $C_j$ 的前 $d_j$ 行构成的矩阵 $R$ 都是满秩的，即 $\\operatorname{rank}(R) = m-t$。使此条件成立的最小 $t$ 就是该网的 $t$ 值。\n\n现在，我们将此方法应用于所提供的两种情景，其中 $m=4$ 且 $s=2$。\n\n**情景 A：计算 $t_A$**\n生成矩阵为 $C_1 = I_4$ 和 $C_2 = C_2^{(A)}$。\n$$ C_{1} = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix}, \\quad C_{2}^{(A)} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  1  1 \\\\ 0  1  0  1 \\\\ 1  0  0  1 \\end{pmatrix} $$\n我们从测试 $t=0$ 开始。为此，我们必须验证对于所有满足 $d_1+d_2=m-t = 4-0 = 4$ 的非负整数 $d_1, d_2$，相应的矩阵 $R(d_1, d_2)$ 的秩为 $4$。$(d_1, d_2)$ 可能的组合为 $(0,4), (1,3), (2,2), (3,1), (4,0)$。\n- 对于 $(d_1, d_2) = (4,0)$：$R(4,0) = C_1 = I_4$。秩显然为 $4$。\n- 对于 $(d_1, d_2) = (0,4)$：$R(0,4) = C_2^{(A)}$。其行列式为 $\\det(C_2^{(A)}) = 1 \\pmod 2$。因此，秩为 $4$。\n- 对于 $(d_1, d_2) = (3,1)$：$R(3,1)$ 由 $C_1$ 的前 $3$ 行和 $C_2^{(A)}$ 的第 $1$ 行组成。该矩阵为 $\\begin{pmatrix} 1000 \\\\ 0100 \\\\ 0010 \\\\ 0001 \\end{pmatrix} = I_4$。秩为 $4$。\n- 对于 $(d_1, d_2) = (1,3)$：$R(1,3)$ 由 $C_1$ 的第 $1$ 行和 $C_2^{(A)}$ 的前 $3$ 行组成。该矩阵为 $M = \\begin{pmatrix} 1000 \\\\ 0001 \\\\ 0011 \\\\ 0101 \\end{pmatrix}$。我们发现 $\\det(M) = 1 \\pmod 2$。秩为 $4$。\n- 对于 $(d_1, d_2) = (2,2)$：$R(2,2)$ 由 $C_1$ 的前 $2$ 行和 $C_2^{(A)}$ 的前 $2$ 行组成。该矩阵为 $M = \\begin{pmatrix} 1000 \\\\ 0100 \\\\ 0001 \\\\ 0011 \\end{pmatrix}$。我们发现 $\\det(M) = 1 \\pmod 2$。秩为 $4$。\n\n由于该条件对所有 4 的划分都成立，因此该网是 $(0,4,2)$-网。由于 $t$ 必须是满足此条件的最小非负整数，我们得出结论 $t_A=0$。\n\n**情景 B：计算 $t_B$**\n生成矩阵为 $C_1 = I_4$ 和 $C_2 = C_2^{(B)}$。\n$$ C_{1} = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix}, \\quad C_{2}^{(B)} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  1  1 \\\\ 0  1  0  1 \\\\ 0  1  1  1 \\end{pmatrix} $$\n设 $C_2^{(B)}$ 的行向量为 $c_{2,i}^{(B)}$。我们在 $C_2^{(B)}$ 的行向量中发现一个线性相关性：\n$c_{2,1}^{(B)} + c_{2,2}^{(B)} + c_{2,3}^{(B)} = (0,0,0,1)+(0,0,1,1)+(0,1,0,1) = (0,1,1,1) = c_{2,4}^{(B)}$。\n这意味着 $C_2^{(B)}$ 的四个行向量是线性相关的。\n\n我们测试 $t=0$。我们检查 $d_1+d_2=4$ 的划分。\n- 对于 $(d_1, d_2) = (0,4)$：$R(0,4) = C_2^{(B)}$。如前所示，其行向量是线性相关的，所以其秩小于 $4$。（秩为 $3$，因为前三行是线性无关的）。$t=0$ 的条件不成立。因此，$t_B  0$。\n\n接下来，我们测试 $t=1$。为此，我们必须验证对于所有满足 $d_1+d_2=m-t = 4-1 = 3$ 的非负整数 $d_1, d_2$，相应的矩阵 $R(d_1, d_2)$ 的秩为 $3$。可能的组合为 $(0,3), (1,2), (2,1), (3,0)$。\n- 对于 $(d_1, d_2) = (3,0)$：$R(3,0)$ 由 $C_1$ 的前 $3$ 行组成，它们是标准基向量，因此是线性无关的。秩为 $3$。\n- 对于 $(d_1, d_2) = (0,3)$：$R(0,3)$ 由 $C_2^{(B)}$ 的前 $3$ 行组成。该矩阵为 $\\begin{pmatrix} 0001 \\\\ 0011 \\\\ 0101 \\end{pmatrix}$。这些行是线性无关的。秩为 $3$。\n- 对于 $(d_1, d_2) = (2,1)$：$R(2,1)$ 由 $C_1$ 的前 $2$ 行和 $C_2^{(B)}$ 的第 $1$ 行组成。这些行是 $\\{(1,0,0,0), (0,1,0,0), (0,0,0,1)\\}$，它们是线性无关的。秩为 $3$。\n- 对于 $(d_1, d_2) = (1,2)$：$R(1,2)$ 由 $C_1$ 的第 $1$ 行和 $C_2^{(B)}$ 的前 $2$ 行组成。这些行是 $\\{(1,0,0,0), (0,0,0,1), (0,0,1,1)\\}$，它们是线性无关的。秩为 $3$。\n\n由于该条件对所有 3 的划分都成立，因此该网是 $(1,4,2)$-网。因为 $t=0$ 的条件不成立，所以使条件成立的最小整数是 $t=1$。因此，$t_B=1$。\n\n$t$ 值从 $t_A=0$ 变为 $t_B=1$ 是生成矩阵 $C_2$ 修改的直接结果。在情景 A 中，所有在 $C_1$ 和 $C_2^{(A)}$ 之间划分的 4 个行向量的组合都是线性无关的。在情景 B 中，$C_2^{(B)}$ 的第四行的选择方式使得 $C_2^{(B)}$ 自身的行向量之间产生了线性相关性。这个特定的相关性 $c_{2,4}^{(B)} = c_{2,1}^{(B)} + c_{2,2}^{(B)} + c_{2,3}^{(B)}$ 导致 $C_2^{(B)}$ 的秩为 $3$ 而不是 $4$，从而违反了 $(0,4,2)$-网所需满足的条件。这一失败迫使 $t$ 值至少为 $1$。后续分析表明，$(1,4,2)$-网的条件得到满足，从而确定 $t_B=1$。", "answer": "$$\\boxed{\\begin{pmatrix} 0  1 \\end{pmatrix}}$$", "id": "3345448"}, {"introduction": "Sobol'序列功能强大，但并非无懈可击。这项高级练习利用精密的对偶网（dual-net）理论，构建了一个能专门针对序列结构中弱点的“最坏情况”被积函数，从而探索其局限性。然后，你将通过计算验证两种强大的补救措施——加扰（scrambling）和被积函数重参数化（integrand reparameterization），来了解如何克服这些弱点。[@problem_id:3345410]", "problem": "你的任务是使用二元有限域 $\\mathbb{F}_2$ 上的数字网理论和 Walsh 函数，为二维 Sobol' 序列构建、分析并计算验证一个病态情况，然后演示两种缓解策略：通过随机二元线性映射进行加扰和被积函数的再参数化。在维度 $s=2$ 的情况下，使用 $N=2^{m}$ 个点（其中 $m \\ge 1$ 为整数）。使用纯数学单位；不涉及任何物理单位。\n\n基本基底和设置：\n- 一个基底为 2 的二维 Sobol' 型数字网可以由 $\\mathbb{F}_2$ 上的两个生成矩阵 $G_1 \\in \\{0,1\\}^{m \\times m}$ 和 $G_2 \\in \\{0,1\\}^{m \\times m}$ 表示。对于每个索引 $i \\in \\{0,1,\\dots,2^m-1\\}$，令 $\\mathbf{b}(i) \\in \\{0,1\\}^m$ 为 $i$ 的长度为 $m$ 的二进制展开，从最低有效位到最高有效位排列。定义二进制坐标向量 $\\mathbf{y}_d(i) = G_d \\mathbf{b}(i)$（在 $\\mathbb{F}_2$ 上），并通过 $x_d(i) = \\sum_{j=1}^m y_{d,j}(i)\\,2^{-j}$ 定义实数坐标，其中 $d \\in \\{1,2\\}$。点集为 $\\{(x_1(i),x_2(i)) : i=0,1,\\dots,2^m-1\\} \\subset [0,1)^2$。\n- 对于本问题，使用 $G_1 = I_m$（$m \\times m$ 单位矩阵），以及逐项定义为 $(G_2)_{j,k} = 1$（若 $k \\le j$）和 $(G_2)_{j,k} = 0$（否则）的 $G_2$。这是一个可逆的下三角矩阵选择，并能产生 Sobol' 族中的一个有效数字网。\n- 定义一维 Walsh 函数 $\\mathrm{wal}_k:[0,1) \\to \\{-1,+1\\}$，通过二进制二进展开：如果 $x = \\sum_{j=1}^\\infty x_j\\,2^{-j}$（其中 $x_j \\in \\{0,1\\}$）且 $k = \\sum_{j=0}^\\infty k_j\\,2^j$（其中 $k_j \\in \\{0,1\\}$），那么\n$$\n\\mathrm{wal}_k(x) = (-1)^{\\sum_{j=1}^\\infty k_{j-1} x_j}\n$$\n其中求和在 $\\mathbb{Z}$ 中进行，指数模 2。在实践中，对于 $N=2^m$，由于点的精度为 $m$ 位，将 $k$ 截断为 $m$ 位，将 $x$ 截断为 $m$ 个小数位。对于维度 2，令 $\\mathbf{k}_1,\\mathbf{k}_2 \\in \\{0,1\\}^m$ 为 $k_1$ 和 $k_2$ 的位向量。二维测试被积函数为\n$$\nf(x_1,x_2)=\\mathrm{wal}_{k_1}(x_1)\\,\\mathrm{wal}_{k_2}(x_2)=(-1)^{\\langle \\mathbf{k}_1,\\mathbf{x}_1\\rangle \\oplus \\langle \\mathbf{k}_2,\\mathbf{x}_2\\rangle},\n$$\n其中 $\\mathbf{x}_d$ 表示 $x_d$ 的前 $m$ 个二进制小数位，$\\langle \\cdot,\\cdot\\rangle$ 表示在 $\\mathbb{F}_2$ 上的点积，$\\oplus$ 是 $\\mathbb{F}_2$ 中的加法。\n\n使用的核心事实：\n- 任何非恒定 Walsh 函数在 $[0,1)$ 上的积分为 0。因此，对于任何 $(k_1,k_2)\\neq (0,0)$，\n$$\n\\int_{[0,1]^2} f(x_1,x_2)\\,\\mathrm{d}x_1\\,\\mathrm{d}x_2 = 0.\n$$\n- 对于具有生成矩阵 $G_1,G_2$ 的数字网的 $N=2^m$ 个点，被积函数 $f$ 在该点集上的拟蒙特卡罗平均值等于 1，当且仅当满足对偶网条件：\n$$\nG_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 = \\mathbf{0} \\in \\mathbb{F}_2^m,\n$$\n否则该平均值等于 0。\n- Matoušek 式线性加扰使用非奇异下三角二元矩阵 $L_1,L_2 \\in \\{0,1\\}^{m\\times m}$ 来形成新的生成矩阵 $G'_1=L_1 G_1$ 和 $G'_2=L_2 G_2$。对于同一个 $f$，加扰后的平均值仅在 $G_1'^\\top \\mathbf{k}_1 \\oplus G_2'^\\top \\mathbf{k}_2=\\mathbf{0}$ 时等于 1，这对于固定的 $(\\mathbf{k}_1,\\mathbf{k}_2)$ 和随机的 $L_1,L_2$ 来说是罕见的；否则该平均值等于 0。\n- 通过一个可逆的下三角二元矩阵 $P \\in \\{0,1\\}^{m\\times m}$ 对被积函数的第一个坐标进行位线性再参数化，相当于在指数中用 $P^\\top \\mathbf{k}_1$ 替换 $\\mathbf{k}_1$，从而对于通用的 $P$ 打破对偶网条件，使平均值趋于 0。\n\n任务：\n1. 通过选择 $\\mathbf{k}_2 = \\mathbf{e}_r$（$\\mathbb{F}_2^m$ 中的第 $r$ 个标准基向量，其中 $1 \\le r \\le m$）和 $\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r$，构建一个对由给定 $G_1,G_2$ 定义的到 $(x_1,x_2)$ 上的特定投影最敏感的测试被积函数 $f$。这将使得 $G_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2=\\mathbf{0}$，从而迫使未加扰的拟蒙特卡罗平均值为 1，而真实积分值仍为 0。\n2. 实现两种缓解策略：\n   - 线性加扰：选择随机的非奇异下三角矩阵 $L_1$ 和 $L_2$，并使用 $G'_1=L_1G_1$ 和 $G'_2=L_2G_2$ 为相同的 $(\\mathbf{k}_1,\\mathbf{k}_2)$ 计算加扰后的平均值。如果 $G_1'^\\top \\mathbf{k}_1 \\oplus G_2'^\\top \\mathbf{k}_2 \\ne \\mathbf{0}$，则加扰后的平均值必须为 0。\n   - 被积函数再参数化：选择一个可逆的下三角矩阵 $P$，并在指数中用 $P^\\top \\mathbf{k}_1$ 替换 $\\mathbf{k}_1$，同时使用原始的 $G_1,G_2$。如果 $G_1^\\top P^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 \\ne \\mathbf{0}$，则平均值必须为 0。\n3. 对于以下参数值测试套件，计算绝对误差 $|\\,\\text{QMC average} - 0\\,|$：\n   - 测试用例 1：$m=10$，$r=6$，无加扰，无再参数化。\n   - 测试用例 2：$m=10$，$r=6$，应用加扰，为保证可复现性，为 $L_1,L_2$ 使用固定的随机种子 $123$。\n   - 测试用例 3：$m=10$，$r=6$，应用被积函数再参数化，为保证可复现性，为 $P$ 使用固定的随机种子 $456$。\n   - 测试用例 4（边界条件）：$m=5$，$r=3$，无加扰，无再参数化。\n你的程序必须生成单行输出，包含测试用例的绝对误差，形式为方括号内的逗号分隔列表（例如，\"[error1,error2,error3,error4]\"）。所有值必须打印为标准十进制浮点数。\n\n答案不涉及物理单位和角度；它纯粹是数学问题。最终的程序必须完整且可按规定运行，并且不得需要用户输入或外部文件。", "solution": "该问题要求为一个二维 Sobol' 型数字网构建和分析一个病态测试用例，然后演示两种缓解策略。整个分析利用了有限域 $\\mathbb{F}_2$ 上的数字网和 Walsh 函数的理论框架，这使得可以直接计算拟蒙特卡罗（QMC）积分误差，而无需显式生成点集。\n\n问题的核心在于数字网理论中的一个基本结果，该结果将特定类别函数的 QMC 积分误差与“对偶”空间中的一个条件联系起来。测试被积函数是一个二维 Walsh 函数，$f(x_1, x_2) = \\mathrm{wal}_{k_1}(x_1)\\,\\mathrm{wal}_{k_2}(x_2)$。对于任何整数波数 $(k_1, k_2) \\neq (0,0)$，真实积分为 $\\int_{[0,1]^2} f(x_1, x_2)\\,\\mathrm{d}x_1\\,\\mathrm{d}x_2 = 0$。使用一个包含 $N=2^m$ 个点的数字网对该积分的 QMC 近似由 $\\frac{1}{N} \\sum_{i=0}^{N-1} f(x_1(i), x_2(i))$ 给出。\n\n问题提供了关键的“核心事实”，即如果满足特定的对偶网条件，此 QMC 平均值恰好为 1，否则恰好为 0。令 $\\mathbf{k}_1, \\mathbf{k}_2 \\in \\mathbb{F}_2^m$ 为波数 $k_1$ 和 $k_2$ 的二进制表示，并令 $G_1, G_2 \\in \\{0,1\\}^{m \\times m}$ 为数字网的生成矩阵。QMC 平均值为 1 当且仅当：\n$$\nG_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 = \\mathbf{0} \\in \\mathbb{F}_2^m\n$$\n其中所有运算都在有限域 $\\mathbb{F}_2$ 中执行。否则，平均值为 0。因此，绝对积分误差为 $|\\text{QMC average} - 0|$，其值要么是 1 要么是 0。我们的任务简化为对四个测试用例中的每一个检查此代数条件。\n\n为数字网指定的生成矩阵是 $G_1 = I_m$（$m \\times m$ 单位矩阵）和 $G_2$（一个 $m \\times m$ 下三角矩阵，其中如果 $k \\le j$ 则 $(G_2)_{j,k} = 1$，否则为 0）。两个矩阵在 $\\mathbb{F}_2$ 上都是可逆的。\n\n**1. 病态情况的构建（测试用例 1 和 4）**\n\n第一个任务是构建一个对于给定的 $G_1, G_2$ 是“病态”的被积函数（即选择 $\\mathbf{k}_1, \\mathbf{k}_2$）。这意味着我们必须选择 $\\mathbf{k}_1, \\mathbf{k}_2$ 以满足对偶网条件，从而迫使 QMC 误差达到最大值（1）。问题指导我们将 $\\mathbf{k}_2$ 设置为 $\\mathbf{e}_r$，即 $\\mathbb{F}_2^m$ 中的第 $r$ 个标准基向量（在第 $r$ 个位置为 1，其余为 0），并将 $\\mathbf{k}_1$ 设置为 $G_2^\\top \\mathbf{e}_r$。\n\n我们来验证这个选择是否满足条件：\n$G_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 = (I_m)^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top (\\mathbf{e}_r)$\n由于 $I_m^\\top = I_m$ 且矩阵乘法是结合的，这变为：\n$G_2^\\top \\mathbf{e}_r \\oplus G_2^\\top \\mathbf{e}_r$\n在 $\\mathbb{F}_2$ 中，任何向量与自身相加都会得到零向量（$\\mathbf{v} \\oplus \\mathbf{v} = \\mathbf{0}$）。因此，条件得到满足：\n$G_2^\\top \\mathbf{e}_r \\oplus G_2^\\top \\mathbf{e}_r = \\mathbf{0}$\n\n对于这个构建的被积函数，QMC 平均值为 1，绝对误差为 1。这适用于测试用例 1（$m=10, r=6$）和测试用例 4（$m=5, r=3$）。参数 $m$ 和 $r$ 改变了具体的向量 $\\mathbf{k}_1$ 和 $\\mathbf{k}_2$，但代数结果保持不变。误差确定性地为 1。\n\n**2. 通过线性加扰进行缓解（测试用例 2）**\n\n该策略通过应用 Matoušek 式线性加扰来修改点集。原始生成矩阵 $G_1, G_2$ 被替换为加扰矩阵 $G'_1 = L_1 G_1$ 和 $G'_2 = L_2 G_2$，其中 $L_1$ 和 $L_2$ 是 $\\mathbb{F}_2$ 上的随机、非奇异、下三角矩阵。被积函数（由 $\\mathbf{k}_1, \\mathbf{k}_2$ 定义）与病态情况中的保持不变。\n\n加扰后的网的对偶网条件为：\n$(G'_1)^\\top \\mathbf{k}_1 \\oplus (G'_2)^\\top \\mathbf{k}_2 = \\mathbf{0}$\n代入 $G'_1 = L_1 G_1$ 和 $G'_2 = L_2 G_2$：\n$(L_1 G_1)^\\top \\mathbf{k}_1 \\oplus (L_2 G_2)^\\top \\mathbf{k}_2 = G_1^\\top L_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top L_2^\\top \\mathbf{k}_2 = \\mathbf{0}$\n我们使用与之前相同的病态选择 $\\mathbf{k}_1, \\mathbf{k}_2$：$\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r$ 和 $\\mathbf{k}_2 = \\mathbf{e}_r$。条件变为：\n$(I_m)^\\top L_1^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top L_2^\\top \\mathbf{e}_r = L_1^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top (L_2^\\top \\mathbf{e}_r) = \\mathbf{0}$\n该方程必须成立才能使误差为 1。然而，$L_1$ 和 $L_2$ 是随机选择的。这个特定的向量线性组合得到零向量的可能性极小。对于几乎所有的 $L_1, L_2$ 选择，该条件都将不成立。因此，QMC 平均值将为 0，绝对误差也将为 0。解决方案的计算部分将针对提供的特定随机种子验证这一点。\n\n**3. 通过被积函数再参数化进行缓解（测试用例 3）**\n\n该策略保持点集不变，但修改了被积函数。这等效于用一个不同的 Walsh 函数来测试原始网，该函数由一个新的波向量 $(\\mathbf{k}'_1, \\mathbf{k}_2)$ 表征。变换定义为 $\\mathbf{k}'_1 = P^\\top \\mathbf{k}_1$，其中 $P$ 是一个随机的、可逆的、下三角矩阵。\n\n原始网和新波向量的对偶网条件为：\n$G_1^\\top \\mathbf{k}'_1 \\oplus G_2^\\top \\mathbf{k}_2 = \\mathbf{0}$\n代入 $\\mathbf{k}'_1 = P^\\top \\mathbf{k}_1$ 并使用病态选择 $\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r, \\mathbf{k}_2 = \\mathbf{e}_r$：\n$G_1^\\top (P^\\top \\mathbf{k}_1) \\oplus G_2^\\top \\mathbf{k}_2 = I_m^\\top P^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top \\mathbf{e}_r = \\mathbf{0}$\n这简化为：\n$P^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top \\mathbf{e}_r = \\mathbf{0}$\n可以将其在 $\\mathbb{F}_2$ 中因式分解为：\n$(P^\\top \\oplus I_m) (G_2^\\top \\mathbf{e}_r) = \\mathbf{0}$\n此条件表明向量 $G_2^\\top \\mathbf{e}_r$ 必须在矩阵 $(P^\\top \\oplus I_m)$ 的零空间中。由于 $P$ 是一个对角线为 1 的随机下三角矩阵，所以 $P^\\top$ 是一个随机上三角矩阵。矩阵 $P^\\top \\oplus I_m$ 的对角线将为零，上三角部分为随机项。对于像 $G_2^\\top \\mathbf{e}_r$ 这样的非零向量，它落入一个随机生成矩阵的零空间的可能性非常小。因此，该条件极有可能不成立。QMC 平均值将为 0，误差也将为 0。这一预测将通过使用指定的随机种子进行计算来证实。\n\n**计算总结**\n\n解决方案将通过为每个测试用例创建指定的矩阵和向量，并显式检查相关的对偶网条件来实现。\n- 用例 1（$m=10, r=6$，无缓解）：误差为 $1.0$。\n- 用例 2（$m=10, r=6$，加扰）：检查 $L_1^\\top (G_2^\\top \\mathbf{e}_6) \\oplus G_2^\\top (L_2^\\top \\mathbf{e}_6) = \\mathbf{0}$。预期误差为 $0.0$。\n- 用例 3（$m=10, r=6$，再参数化）：检查 $(P^\\top \\oplus I_{10}) (G_2^\\top \\mathbf{e}_6) = \\mathbf{0}$。预期误差为 $0.0$。\n- 用例 4（$m=5, r=3$，无缓解）：误差为 $1.0$。\n\n该实现将通过将其对角线设置为 1 并从 $\\{0, 1\\}$ 中随机选择严格下三角项，来生成随机矩阵 $L_1, L_2, P$ 作为非奇异下三角矩阵。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes integration errors for four test cases involving a pathological\n    integrand for a 2D Sobol' sequence and two mitigation strategies.\n    The error is determined by checking an algebraic condition (the dual-net condition)\n    over the finite field F_2.\n    \"\"\"\n\n    def make_random_lt_matrix(m, rng):\n        \"\"\"\n        Generates a random m x m nonsingular lower-triangular matrix over F_2.\n        Nonsingularity is guaranteed by setting the diagonal to all 1s.\n        The strictly lower triangular part is filled with random 0s or 1s.\n        \"\"\"\n        mat = np.identity(m, dtype=int)\n        for i in range(1, m):\n            for j in range(i):\n                mat[i, j] = rng.integers(0, 2)\n        return mat\n\n    def calculate_qmc_average(m, r, scramble_seed, reparam_seed):\n        \"\"\"\n        Calculates the QMC average (0 or 1) based on the dual-net condition.\n        The absolute error is equal to this average since the true integral is 0.\n        \n        Args:\n            m (int): Number of bits, defines the number of points N = 2^m.\n            r (int): Index (1-based) for constructing the pathological wave vector.\n            scramble_seed (int or None): Seed for random scrambling matrices.\n            reparam_seed (int or None): Seed for random reparameterization matrix.\n            \n        Returns:\n            float: The absolute error of the QMC approximation (1.0 or 0.0).\n        \"\"\"\n        # Define generating matrices G1 and G2 over F_2.\n        # G1 is the m x m identity matrix.\n        G1 = np.identity(m, dtype=int)\n        # G2 is the m x m lower-triangular matrix of ones.\n        G2 = np.tril(np.ones((m, m), dtype=int))\n\n        # Construct the pathological wave vectors k1 and k2.\n        # k2 is the r-th standard basis vector (using 0-based indexing for r-1).\n        k2 = np.zeros(m, dtype=int)\n        k2[r - 1] = 1\n        \n        # k1 is constructed to satisfy the dual-net condition for the base case.\n        # All matrix and vector operations are implicitly mod 2.\n        k1 = (G2.T @ k2) % 2\n        \n        # Initialize effective matrices and wave vectors\n        G1_T = G1.T\n        G2_T = G2.T\n        k1_eff = k1\n        k2_eff = k2\n\n        if scramble_seed is not None:\n            # Case 2: Linear Scrambling\n            rng = np.random.default_rng(scramble_seed)\n            L1 = make_random_lt_matrix(m, rng)\n            L2 = make_random_lt_matrix(m, rng)\n            \n            # Scrambled matrices G' = L*G. Their transposes are G.T * L.T\n            G1_scrambled = (L1 @ G1) % 2\n            G2_scrambled = (L2 @ G2) % 2\n            G1_T = G1_scrambled.T\n            G2_T = G2_scrambled.T\n            # Wave vectors k1, k2 are unchanged\n            \n        elif reparam_seed is not None:\n            # Case 3: Integrand Reparameterization\n            rng = np.random.default_rng(reparam_seed)\n            P = make_random_lt_matrix(m, rng)\n            \n            # Generating matrices G1, G2 are unchanged\n            # The wave vector k1 is replaced by k1' = P.T @ k1\n            k1_eff = (P.T @ k1) % 2\n            # k2 is unchanged\n\n        # Check the dual-net condition: G1_eff.T @ k1_eff + G2_eff.T @ k2_eff == 0 (mod 2)\n        test_vector = (G1_T @ k1_eff + G2_T @ k2_eff) % 2\n\n        # If the test_vector is the zero vector, the condition holds.\n        if np.all(test_vector == 0):\n            qmc_average = 1.0\n        else:\n            qmc_average = 0.0\n            \n        # The true integral is 0, so the absolute error is |qmc_average - 0|.\n        return qmc_average\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, r, scramble_seed, reparam_seed)\n        (10, 6, None, None),      # Case 1: m=10, r=6, no mitigation\n        (10, 6, 123, None),       # Case 2: m=10, r=6, scrambling\n        (10, 6, None, 456),       # Case 3: m=10, r=6, reparameterization\n        (5, 3, None, None),       # Case 4: m=5, r=3, no mitigation\n    ]\n\n    results = []\n    for m, r, s_seed, p_seed in test_cases:\n        error = calculate_qmc_average(m, r, s_seed, p_seed)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3345410"}]}