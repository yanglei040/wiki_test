{"hands_on_practices": [{"introduction": "要真正掌握无U形转弯采样器（NUTS），第一步是亲手实现其核心动态。这项练习将引导你模拟哈密顿轨迹中的几个关键步骤，包括使用蛙跳积分器进行演化，并应用NUTS中的两个基本准则：切片有效性检验和U形转弯检验[@problem_id:3355983]。通过这个具体的编码实践，你将对采样器如何构建和验证轨迹获得直观的感受。", "problem": "给定一个二维高斯目标分布，其均值向量为 $\\mu \\in \\mathbb{R}^2$，对称正定 (SPD) 精度矩阵为 $\\Sigma^{-1} \\in \\mathbb{R}^{2 \\times 2}$。这导出了由下式定义的势能函数 $U(q)$：\n$$\nU(q) = \\frac{1}{2} (q - \\mu)^{\\top} \\Sigma^{-1} (q - \\mu),\n$$\n其梯度为\n$$\n\\nabla U(q) = \\Sigma^{-1} (q - \\mu).\n$$\n在哈密顿蒙特卡洛 (HMC) 中，一个对称正定质量矩阵 $M \\in \\mathbb{R}^{2 \\times 2}$ 定义了动能\n$$\nK(p) = \\frac{1}{2} p^{\\top} M^{-1} p,\n$$\n以及哈密顿量\n$$\nH(q, p) = U(q) + K(p).\n$$\n步长为 $\\epsilon > 0$ 的标准蛙跳积分器通过以下方式更新 $(q, p)$：\n$$\np_{\\text{half}} = p - \\frac{\\epsilon}{2} \\nabla U(q), \\quad\nq_{\\text{new}} = q + \\epsilon M^{-1} p_{\\text{half}}, \\quad\np_{\\text{new}} = p_{\\text{half}} - \\frac{\\epsilon}{2} \\nabla U(q_{\\text{new}}).\n$$\n\n考虑 No-U-Turn 采样器 (NUTS) 在单一方向 $v = +1$ 且深度为 $j = 2$ 的树构建过程。该过程从根状态 $(q_0, p_0)$ 开始，执行 $2^j = 4$ 次前向蛙跳步，为 $k \\in \\{1,2,3,4\\}$ 生成 4 个叶节点状态 $(q^{(k)}, p^{(k)})$。设切片变量 $u$ 通过以下方式从根节点确定性地构建：\n$$\nu = s \\cdot \\exp\\big(-H(q_0, p_0)\\big),\n$$\n其中给定的切片因子为 $s \\in (0, 1)$。\n\n对于每个叶节点 $k$，定义位移\n$$\n\\Delta q^{(k)} = q^{(k)} - q_0,\n$$\n并使用标准准则执行 No-U-Turn 检查，该准则根据当前边界状态（负端为根节点，正端为叶节点）进行评估：\n$$\n\\text{U-turn}^{(k)} = \\Big( \\Delta q^{(k)} \\cdot p_0  0 \\Big) \\ \\text{or} \\ \\Big( \\Delta q^{(k)} \\cdot p^{(k)}  0 \\Big).\n$$\n同时，通过以下方式确定叶节点的切片有效性：\n$$\n\\text{valid}^{(k)} = \\Big( \\exp\\big(-H(q^{(k)}, p^{(k)})\\big) \\ge u \\Big).\n$$\n\n你的任务是针对一个二维高斯目标分布，为下列每个参数集（测试套件）实现上述的两级树构建。从根节点开始精确执行 4 次前向蛙跳步，并报告每个叶节点的状态 $(q^{(k)}, p^{(k)})$、其哈密顿量 $H(q^{(k)}, p^{(k)})$、其 No-U-Turn 检查 $\\text{U-turn}^{(k)}$ 以及其切片有效性 $\\text{valid}^{(k)}$。\n\n使用以下测试套件，其中每个案例指定了 $(\\mu, \\Sigma^{-1}, M, q_0, p_0, \\epsilon, s)$:\n\n- 案例 1 (理想路径，各向同性目标和质量):\n  - $\\mu = [0, 0]$\n  - $\\Sigma^{-1} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$\n  - $M = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$\n  - $q_0 = [-0.5, 0.5]$\n  - $p_0 = [0.3, -0.1]$\n  - $\\epsilon = 0.25$\n  - $s = 0.5$\n\n- 案例 2 (各向异性目标和质量，中等步长):\n  - $\\mu = [0, 0]$\n  - $\\Sigma^{-1} = \\begin{bmatrix} 0.25  0 \\\\ 0  4.0 \\end{bmatrix}$\n  - $M = \\begin{bmatrix} 1.0  0 \\\\ 0  2.0 \\end{bmatrix}$\n  - $q_0 = [1.0, -1.0]$\n  - $p_0 = [-0.2, 0.4]$\n  - $\\epsilon = 0.2$\n  - $s = 0.3$\n\n- 案例 3 (相关目标和非对角质量，小步长；边缘情况覆盖):\n  - $\\mu = [0, 0]$\n  - $\\Sigma^{-1} = \\begin{bmatrix} 1.0  0.3 \\\\ 0.3  1.5 \\end{bmatrix}$\n  - $M = \\begin{bmatrix} 1.0  0.5 \\\\ 0.5  2.0 \\end{bmatrix}$\n  - $q_0 = [0.7, -2.0]$\n  - $p_0 = [0.8, 0.1]$\n  - $\\epsilon = 0.1$\n  - $s = 0.8$\n\n你的程序必须为每个案例计算 4 个叶节点条目的列表。每个叶节点条目必须是列表\n$$\n[q^{(k)}_1, q^{(k)}_2, p^{(k)}_1, p^{(k)}_2, H(q^{(k)}, p^{(k)}), \\text{U-turn}^{(k)}, \\text{valid}^{(k)}],\n$$\n其中 $q^{(k)}_1$ 和 $q^{(k)}_2$ 是 $q^{(k)}$ 的分量，$p^{(k)}_1$ 和 $p^{(k)}_2$ 是 $p^{(k)}$ 的分量。\n\n最终输出格式要求：你的程序应生成单行输出，其中包含用方括号括起来、以逗号分隔的结果列表。顶层列表必须恰好包含三个元素，每个测试案例一个，并且每个元素都必须是上述四个叶节点条目的列表。例如，打印出的字符串必须像这样\n$$\n[\\text{case1\\_leaves}, \\text{case2\\_leaves}, \\text{case3\\_leaves}],\n$$\n前后不能有任何附加文本。\n\n本问题不涉及物理单位或角度。所有计算都是纯数学的。", "solution": "该问题是有效的。它基于哈密顿蒙特卡洛 (HMC) 和 No-U-Turn 采样器 (NUTS) 算法的可靠原理，提出了一个定义明确的计算任务。所有提供的参数和方程都是标准的、完整的且一致的。我现在将开始解答。\n\n问题的核心是模拟一段有限长度的哈密顿轨迹，并在每一步评估特定的准则。我们得到了一个哈密顿系统的基本组成部分，该系统是为从二维高斯概率分布中采样而量身定制的。\n\n首先，我们定义数学对象。目标概率密度与 $\\exp(-U(q))$ 成正比，其中 $U(q)$ 是势能。对于均值为 $\\mu$、协方差为 $\\Sigma$（或精度为 $\\Sigma^{-1}$）的多元高斯分布，势能由负对数密度给出（不考虑加性常数）：\n$$\nU(q) = \\frac{1}{2} (q - \\mu)^{\\top} \\Sigma^{-1} (q - \\mu)\n$$\n模拟动力学所需的势能梯度为：\n$$\n\\nabla U(q) = \\Sigma^{-1} (q - \\mu)\n$$\n系统动力学通过动量变量 $p$ 进行增强，并通过质量矩阵 $M$ 定义动能：\n$$\nK(p) = \\frac{1}{2} p^{\\top} M^{-1} p\n$$\n系统的总能量是哈密顿量 $H(q, p)$，它是势能和动能之和：\n$$\nH(q, p) = U(q) + K(p) = \\frac{1}{2} (q - \\mu)^{\\top} \\Sigma^{-1} (q - \\mu) + \\frac{1}{2} p^{\\top} M^{-1} p\n$$\n哈密顿方程描述了 $(q, p)$ 随时间的演化，理论上它会使 $H(q, p)$ 守恒。对于数值模拟，我们使用一个辛积分器，如蛙跳积分器，它能近似哈密顿方程的解，并表现出良好的长期能量守恒特性。步长为 $\\epsilon$ 的蛙跳积分器的一个单步由三个阶段定义：\n1.  动量的半步更新：$p_{\\text{half}} = p - \\frac{\\epsilon}{2} \\nabla U(q)$\n2.  位置的整步更新：$q_{\\text{new}} = q + \\epsilon M^{-1} p_{\\text{half}}$\n3.  动量的最终半步更新：$p_{\\text{new}} = p_{\\text{half}} - \\frac{\\epsilon}{2} \\nabla U(q_{\\text{new}})$\n\n问题要求我们从初始状态 $(q_0, p_0)$ 开始，模拟一条包含 $2^j = 2^2 = 4$ 次前向蛙跳步的轨迹。这将为 $k \\in \\{1, 2, 3, 4\\}$ 生成一个包含 4 个叶节点状态 $(q^{(k)}, p^{(k)})$ 的序列，其中 $(q^{(k)}, p^{(k)})$ 是经过 $k$ 次蛙跳步之后的状态。\n\n对于每个叶节点，我们必须执行两个与 NUTS 算法相关的检查。\n首先，我们确定一个切片变量 $u$。这是一个阈值，用于确保采样器探索具有足够高概率的区域。它是根据初始状态的能量计算的：\n$$\nu = s \\cdot \\exp\\big(-H(q_0, p_0)\\big)\n$$\n其中 $s \\in (0, 1)$ 是一个给定的随机因子，此处为确定性地提供。如果一个状态 $(q, p)$ 满足 $\\exp(-H(q, p)) \\ge u$，则认为它对于该切片是有效的，这等价于 $H(q, p) \\le H(q_0, p_0) - \\log s$。我们为每个叶节点检查这一点：\n$$\n\\text{valid}^{(k)} = \\Big( \\exp\\big(-H(q^{(k)}, p^{(k)})\\big) \\ge u \\Big)\n$$\n其次，No-U-Turn 条件旨在当路径开始折返时停止轨迹构建过程，因为折返会导致低效的探索。问题指定了一个简化的检查方法，其中每个叶节点状态 $(q^{(k)}, p^{(k)})$ 都与根状态 $(q_0, p_0)$ 进行比较。从根节点出发的位移向量是 $\\Delta q^{(k)} = q^{(k)} - q_0$。如果轨迹在段的开始或结束时，正朝向其位移的起点移动，则检测到 U 型转弯。在数学上，这表示为：\n$$\n\\text{U-turn}^{(k)} = \\Big( (\\Delta q^{(k)} \\cdot p_0)  0 \\Big) \\ \\text{or} \\ \\Big( (\\Delta q^{(k)} \\cdot p^{(k)})  0 \\Big)\n$$\n其中 $\\cdot$ 表示标准点积。注意，$p_0$ 是初始动量，表示从 $q_0$ 开始的轨迹段的初始行进方向。\n\n每个测试案例的总体算法如下：\n1.  初始化参数：$\\mu, \\Sigma^{-1}, M, q_0, p_0, \\epsilon, s$。\n2.  计算逆质量矩阵 $M^{-1}$。\n3.  计算初始哈密顿量 $H(q_0, p_0)$ 和切片变量 $u$。\n4.  初始化当前状态 $(q_{curr}, p_{curr}) = (q_0, p_0)$。\n5.  从 1 到 4 迭代 $k$：\n    a. 对 $(q_{curr}, p_{curr})$ 应用一次蛙跳步以获得新状态，我们将其标记为 $(q^{(k)}, p^{(k)})$。\n    b. 为下一次迭代更新 $(q_{curr}, p_{curr}) = (q^{(k)}, p^{(k)})$。\n    c. 计算哈密顿量 $H(q^{(k)}, p^{(k)})$。\n    d. 计算位移 $\\Delta q^{(k)} = q^{(k)} - q_0$。\n    e. 评估 U 型转弯条件 $\\text{U-turn}^{(k)}$。\n    f. 评估切片有效性条件 $\\text{valid}^{(k)}$。\n    g. 为当前叶节点 $k$ 存储结果列表 $[q^{(k)}_1, q^{(k)}_2, p^{(k)}_1, p^{(k)}_2, H(q^{(k)}, p^{(k)}), \\text{U-turn}^{(k)}, \\text{valid}^{(k)}]$。\n6.  将 4 个叶节点的结果收集到当前测试案例的列表中。\n7.  对所有测试案例重复此过程，并按指定格式化最终输出。\n\n所有向量和矩阵运算将使用 `numpy` 库来实现。$M$ 的逆矩阵通过 `numpy.linalg.inv` 计算，矩阵-向量乘积使用 `@` 运算符。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem.\n\ndef solve():\n    \"\"\"\n    Implements the NUTS tree-building procedure for a 2D Gaussian target.\n    For each test case, it performs 4 forward leapfrog steps and computes\n    metrics for each of the 4 leaf states.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma_inv\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"M\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"q0\": np.array([-0.5, 0.5]),\n            \"p0\": np.array([0.3, -0.1]),\n            \"epsilon\": 0.25,\n            \"s\": 0.5,\n        },\n        # Case 2\n        {\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma_inv\": np.array([[0.25, 0.0], [0.0, 4.0]]),\n            \"M\": np.array([[1.0, 0.0], [0.0, 2.0]]),\n            \"q0\": np.array([1.0, -1.0]),\n            \"p0\": np.array([-0.2, 0.4]),\n            \"epsilon\": 0.2,\n            \"s\": 0.3,\n        },\n        # Case 3\n        {\n            \"mu\": np.array([0.0, 0.0]),\n            \"Sigma_inv\": np.array([[1.0, 0.3], [0.3, 1.5]]),\n            \"M\": np.array([[1.0, 0.5], [0.5, 2.0]]),\n            \"q0\": np.array([0.7, -2.0]),\n            \"p0\": np.array([0.8, 0.1]),\n            \"epsilon\": 0.1,\n            \"s\": 0.8,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        mu = case[\"mu\"]\n        Sigma_inv = case[\"Sigma_inv\"]\n        M = case[\"M\"]\n        q0 = case[\"q0\"]\n        p0 = case[\"p0\"]\n        epsilon = case[\"epsilon\"]\n        s = case[\"s\"]\n        \n        M_inv = np.linalg.inv(M)\n\n        def grad_U(q_vec):\n            return Sigma_inv @ (q_vec - mu)\n\n        def U(q_vec):\n            diff = q_vec - mu\n            return 0.5 * diff.T @ Sigma_inv @ diff\n\n        def K(p_vec):\n            return 0.5 * p_vec.T @ M_inv @ p_vec\n\n        def H(q_vec, p_vec):\n            return U(q_vec) + K(p_vec)\n\n        def leapfrog(q_curr, p_curr):\n            p_half = p_curr - (epsilon / 2.0) * grad_U(q_curr)\n            q_new = q_curr + epsilon * (M_inv @ p_half)\n            p_new = p_half - (epsilon / 2.0) * grad_U(q_new)\n            return q_new, p_new\n\n        # Initial calculations\n        H0 = H(q0, p0)\n        u = s * np.exp(-H0)\n\n        case_leaves = []\n        q_current, p_current = q0, p0\n        \n        # Perform 4 leapfrog steps\n        for _ in range(4):\n            q_k, p_k = leapfrog(q_current, p_current)\n            \n            # Update current state for the next iteration\n            q_current, p_current = q_k, p_k\n\n            # Calculate metrics for the leaf\n            H_k = H(q_k, p_k)\n            delta_q_k = q_k - q0\n            \n            # U-Turn check\n            uturn_check = (np.dot(delta_q_k, p0)  0) or (np.dot(delta_q_k, p_k)  0)\n            \n            # Slice validity check\n            valid_slice = (np.exp(-H_k) >= u)\n            \n            leaf_entry = [\n                q_k[0], q_k[1], \n                p_k[0], p_k[1], \n                H_k, \n                uturn_check, \n                valid_slice\n            ]\n            case_leaves.append(leaf_entry)\n            \n        all_results.append(case_leaves)\n\n    # Custom string formatting to match the output requirements precisely\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(map(format_list, item))}]\"\n        if isinstance(item, bool):\n            return str(item)\n        if isinstance(item, float):\n            return f\"{item:.8f}\" # Use a reasonable precision\n        return str(item)\n\n    # The problem asks for a string representation that `str()` on a list would produce.\n    # The provided print statement in the problem skeleton does this.\n    # Let's use it directly.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3355983"}, {"introduction": "虽然上一个练习建立了算法的数学框架，但将其直接翻译成代码时可能会因有限精度算术的限制而失败。这项实践揭示了一个常见的数值陷阱——在计算能量较大的状态时，切片检验中的指数函数会发生下溢（underflow），导致采样器失效[@problem_id:3356001]。你将通过推导并实现一个基于对数域的、数值稳定的检验方法，来学习如何编写出生产级别的、可靠的科学计算软件。", "problem": "考虑无U形转弯采样器 (No-U-Turn Sampler, NUTS)，它是哈密顿蒙特卡洛 (Hamiltonian Monte Carlo, HMC) 的一种自适应扩展。在哈密顿蒙特卡洛 (HMC) 中，我们处理的是位置和动量变量的联合密度，该密度与 $\\exp(-H(\\mathbf{q},\\mathbf{p}))$ 成正比，其中 $H(\\mathbf{q},\\mathbf{p})$ 是哈密顿量。NUTS 中一个常见的接受机制使用一个切片变量 $u$，该变量从 $(0,\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})))$ 中均匀抽取，其中 $(\\mathbf{q}_{0},\\mathbf{p}_{0})$ 表示轨迹的初始状态。切片检验要求对于轨迹上的一个提议状态 $(\\mathbf{q},\\mathbf{p})$，必须满足 $u \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$。\n\n在有限精度算术（IEEE 754 双精度）中，当 $H$ 很大时，$\\exp(-H)$ 的值可能会下溢为零。而计算诸如 $\\exp(-H(\\mathbf{q},\\mathbf{p}))/\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))$ 之类比率的实现可能会产生不定式 $0/0$，这是一个非数值（not-a-number），并且即使在精确的数学检验应该接受的情况下，也可能被错误地标记为发散。\n\n使用以下具体的数值情景：\n- 设 $H(\\mathbf{q}_{0},\\mathbf{p}_{0}) = 1000$ 且 $H(\\mathbf{q},\\mathbf{p}) = 1001.5$。\n- 设 $U \\sim \\text{Uniform}(0,1)$ 且假定一次具体的抽取 $U = 0.2$。\n\n请执行以下操作：\n1. 使用切片检验的设置，解释为什么在这种情景下，计算 $u = U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))$ 并检验 $u \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$ 在有限精度下会失败，尽管基于底层数学原理的精确接受决策是确定的。\n2. 从第一性原理推导一个数值稳定的切片检验，该检验通过在对数域中运算来避免计算 $\\exp(-H)$。用 $\\ln U$、$H(\\mathbf{q},\\mathbf{p})$ 和 $H(\\mathbf{q}_{0},\\mathbf{p}_{0})$ 来表示该检验。\n3. 对于给定的数值，计算稳定的检验统计量 $T = \\ln U + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0})$。\n\n将你计算出的 $T$ 的最终数值答案四舍五入到十位有效数字。由于所有量都是无量纲的，因此不需要物理单位。你的最终答案必须是 $T$ 的单个四舍五入值。", "solution": "问题陈述具有科学依据、良构且客观。它探讨了在实现如无U形转弯采样器 (NUTS) 这类复杂的蒙特卡洛方法时一个真实且重要的数值稳定性问题。所有必要的数据和定义都已提供，且没有矛盾之处。因此，该问题是有效的，可以构建解答。\n\n问题分为三个部分，将按顺序进行解答。\n\n### 第一部分：朴素切片检验的失败\n\n哈密顿蒙特卡洛 (HMC) 及其变体（如 NUTS）中的切片采样机制旨在维持相对于目标分布的细致平衡条件。系统的状态由位置 $\\mathbf{q}$ 和动量 $\\mathbf{p}$ 描述，其哈密顿量为 $H(\\mathbf{q},\\mathbf{p})$。目标概率密度与 $\\exp(-H(\\mathbf{q},\\mathbf{p}))$ 成正比。\n\n引入一个切片变量 $u$，它从区间 $(0, \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})))$ 上的均匀分布中抽取，其中 $(\\mathbf{q}_{0},\\mathbf{p}_{0})$ 是轨迹的初始状态。这等价于首先抽取一个标准均匀随机变量 $U \\sim \\text{Uniform}(0,1)$，然后设置 $u = U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))$。\n\n沿着模拟的哈密顿轨迹，一个提议状态 $(\\mathbf{q},\\mathbf{p})$ 如果位于由条件 $u \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$ 定义的切片内，则被认为是有效的。代入 $u$ 的表达式，接受条件为：\n$$U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})) \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$$\n\n让我们使用有限精度算术（具体来说是 IEEE 754 双精度）和给定的数值来分析这个条件：$H(\\mathbf{q}_{0},\\mathbf{p}_{0}) = 1000$ 和 $H(\\mathbf{q},\\mathbf{p}) = 1001.5$。\n\n在 IEEE 754 双精度中，最小的正规格化数约为 $2.225 \\times 10^{-308}$。这个数的自然对数是 $\\ln(2.225 \\times 10^{-308}) \\approx -708.4$。任何比这个数小的数，例如当 $x > 708.4$ 时的 $\\exp(-x)$，都将下溢为零。\n\n对于初始状态，我们需要计算 $\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})) = \\exp(-1000)$。因为 $-1000  -708.4$，这个值在双精度算术中会下溢为 $0$。\n$$ \\exp(-1000) \\to 0.0 $$\n\n对于提议状态，我们需要计算 $\\exp(-H(\\mathbf{q},\\mathbf{p})) = \\exp(-1001.5)$。因为 $-1001.5  -708.4$，这个值也会下溢为 $0$。\n$$ \\exp(-1001.5) \\to 0.0 $$\n\n对于给定的抽取值 $U=0.2$，朴素的有限精度实现的切片检验变为：\n$$ 0.2 \\times \\exp(-1000) \\leq \\exp(-1001.5) $$\n$$ 0.2 \\times 0.0 \\leq 0.0 $$\n$$ 0.0 \\leq 0.0 $$\n这个不等式成立，因此提议状态被接受。\n\n现在，让我们来检验精确的数学条件。它等价于 $U \\leq \\exp(H(\\mathbf{q}_{0},\\mathbf{p}_{0}) - H(\\mathbf{q},\\mathbf{p}))$。\n$$ 0.2 \\leq \\exp(1000 - 1001.5) $$\n$$ 0.2 \\leq \\exp(-1.5) $$\n由于 $\\exp(-1.5) \\approx 0.22313016$，条件是 $0.2 \\leq 0.22313016$，这是成立的。\n\n在这个特定案例中，朴素检验和精确检验都得出了相同的结果（接受）。然而，朴素方法的失败在于其无差别的行为。考虑一个具有更高哈密顿量的不同提议状态，比如 $H(\\mathbf{q}',\\mathbf{p}') = 2000$。\n朴素的有限精度检验将是：\n$$ 0.2 \\times \\exp(-1000) \\leq \\exp(-2000) \\implies 0.0 \\leq 0.0 $$\n这是成立的，从而导致接受。\n然而，精确的数学检验将是：\n$$ 0.2 \\leq \\exp(1000 - 2000) = \\exp(-1000) $$\n由于 $\\exp(-1000)$ 是一个极小的正数，条件 $0.2 \\leq \\exp(-1000)$ 是不成立的。该状态应该被拒绝。\n\n因此，失败之处在于，朴素实现会接受*任何*使 $\\exp(-H)$ 下溢的状态，完全没有按算法要求去惩罚高能量（大 $H$）的状态。这破坏了细致平衡条件，导致采样器不正确。问题中提到的另一种形式，即计算比率 $\\exp(-H)/\\exp(-H_0)$，将导致不定式 $0/0$，这也是一种实现上的失败。\n\n### 第二部分：数值稳定检验的推导\n\n为了避免与显式计算 $\\exp(-H)$ 相关的数值下溢，我们可以在对数域中进行运算。接受条件是：\n$$U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0})) \\leq \\exp(-H(\\mathbf{q},\\mathbf{p}))$$\n由于 $U$、$\\exp(-H_{0})$ 和 $\\exp(-H)$ 都是严格为正的量，我们可以对不等式两边取自然对数而不改变其方向。自然对数函数 $\\ln(x)$ 在 $x>0$ 时是单调递增的。\n$$ \\ln\\left(U \\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))\\right) \\leq \\ln\\left(\\exp(-H(\\mathbf{q},\\mathbf{p}))\\right) $$\n使用对数性质 $\\ln(ab) = \\ln(a) + \\ln(b)$，左边变为：\n$$ \\ln(U) + \\ln\\left(\\exp(-H(\\mathbf{q}_{0},\\mathbf{p}_{0}))\\right) \\leq \\ln\\left(\\exp(-H(\\mathbf{q},\\mathbf{p}))\\right) $$\n使用性质 $\\ln(\\exp(x)) = x$，我们简化两边：\n$$ \\ln(U) - H(\\mathbf{q}_{0},\\mathbf{p}_{0}) \\leq -H(\\mathbf{q},\\mathbf{p}) $$\n这个不等式就是数值稳定的切片检验。它涉及哈密顿量 $H$ 和 $H_0$ 以及均匀变量的对数 $\\ln(U)$，这些都不会遇到指数函数那样的下溢问题。所涉及的数（$1000$、$1001.5$ 和 $\\ln(0.2)$）都在标准浮点类型的可表示范围内。\n\n为了与问题中给出的检验统计量 $T$ 相匹配，我们可以通过将所有项移到一边来重排不等式：\n$$ \\ln(U) + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0}) \\leq 0 $$\n这表明，稳定的检验是计算统计量 $T = \\ln(U) + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0})$，并且当且仅当 $T \\leq 0$ 时接受提议状态。\n\n### 第三部分：检验统计量的计算\n\n我们被要求针对给定的数值情景计算稳定检验统计量 $T$ 的值。\n公式为：\n$$ T = \\ln U + H(\\mathbf{q},\\mathbf{p}) - H(\\mathbf{q}_{0},\\mathbf{p}_{0}) $$\n提供的值是：\n- $U = 0.2$\n- $H(\\mathbf{q}_{0},\\mathbf{p}_{0}) = 1000$\n- $H(\\mathbf{q},\\mathbf{p}) = 1001.5$\n\n将这些值代入 $T$ 的表达式中：\n$$ T = \\ln(0.2) + 1001.5 - 1000 $$\n$$ T = \\ln(0.2) + 1.5 $$\n0.2 的自然对数是：\n$$ \\ln(0.2) \\approx -1.60943791243410037 $$\n现在，我们计算 $T$：\n$$ T \\approx -1.60943791243410037 + 1.5 $$\n$$ T \\approx -0.10943791243410037 $$\n问题要求将结果四舍五入到十位有效数字。前十位有效数字是 $1, 0, 9, 4, 3, 7, 9, 1, 2, 4$。第十一位有效数字是 $3$。由于 $3  5$，我们向下舍入（即截断）。\n$$ T \\approx -0.1094379124 $$\n对于稳定检验，由于 $T \\approx -0.1094379124 \\leq 0$，提议状态被正确接受，这与精确数学分析得出的结论相符。", "answer": "$$ \\boxed{-0.1094379124} $$", "id": "3356001"}, {"introduction": "U形转弯准则的有效性在很大程度上取决于目标分布的几何特性。这项练习通过一个精心设计的反例，展示了在各向异性（ill-conditioned）问题中，一个朴素的、基于欧几里得度量的U形转弯检验为何会失效，无法有效阻止轨迹折返[@problem_id:3355985]。你将实现一个更广义的、考虑了质量矩阵$M$的检验准则，它能正确地适应问题的几何结构，从而揭示黎曼流形哈密顿蒙特卡洛（Riemannian Manifold HMC）方法背后提升效率的核心思想。", "problem": "考虑一个在哈密顿蒙特卡洛 (HMC) 中用于从高斯目标分布采样的可分哈密顿系统。该目标具有二次势能 $U(\\theta) = \\tfrac{1}{2} \\theta^\\top \\Lambda \\theta$，其中 $\\Lambda$ 是一个正定精度矩阵；动能为 $K(p) = \\tfrac{1}{2} p^\\top M^{-1} p$，其中 $M$ 是一个正定质量矩阵。哈密顿方程为 $d\\theta/dt = M^{-1} p$ 和 $dp/dt = -\\Lambda \\theta$。对于对角的 $M$ 和 $\\Lambda$，每个坐标都独立地演化，如同一个谐振子。无U形转弯采样器 (NUTS) 使用一个停止规则来防止沿着模拟轨迹回溯。经典的欧几里得NUTS规则检查轨迹位移与端点动量之间的内积符号。在强各向异性设置中（例如，当 $M$ 的条目数量级差异巨大时），这种欧几里得规则可能无法检测到实际的回溯，因为它没有考虑质量矩阵如何缩放物理速度。您的任务是构建一个反例来展示这种失败，并实现一个使用由质量矩阵所隐含的物理速度的广义停止检验。\n\n从上述基本定义开始，在一个完整的、可运行的程序中实现以下步骤：\n\n1. 对于对角的 $M$ 和对角的 $\\Lambda$，使用线性哈密顿系统的精确解来计算对称轨迹段的端点。令 $\\omega_i = \\sqrt{\\Lambda_i / M_i}$ 表示第 $i$ 个坐标的角频率。对于给定的初始状态 $(\\theta_0, p_0)$ 和积分时间 $T$（解释为三角函数的参数，以弧度为单位），定义在时间 $+T$ 时的端点 $(\\theta^+, p^+)$ 以及在时间 $-T$ 时的端点 $(\\theta^-, p^-)$。同时定义位移 $\\Delta \\theta = \\theta^+ - \\theta^-$。您的程序必须为对角的 $M$ 和对角的 $\\Lambda$ 精确计算这些量。\n\n2. 实现两种停止检验：\n   - 欧几里得NUTS停止检验：如果内积 $\\Delta \\theta^\\top p^+$ 或 $\\Delta \\theta^\\top p^-$ 中任意一个严格为负，则声明“停止”。\n   - 广义M加权停止检验：如果内积 $\\Delta \\theta^\\top M^{-1} p^+$ 或 $\\Delta \\theta^\\top M^{-1} p^-$ 中任意一个严格为负，则声明“停止”。此检验使用物理速度 $v = M^{-1} p$ 而不是原始动量。\n\n3. 构建一个科学上合理的反例，其中 $M$ 中的强各向异性导致欧几里得检验未能阻止回溯，而 M 加权检验正确地检测到了回溯。为该反例使用以下参数值：\n   - $M = \\mathrm{diag}(10^{-4}, 1)$，\n   - $\\Lambda = \\mathrm{diag}(1, 1)$，\n   - $\\theta_0 = [1, 1]^\\top$，\n   - $p_0 = [0.01, 1.262]^\\top$，\n   - $T = \\pi / (2 \\cdot 100)$。\n\n   三角函数内的角度必须以弧度为单位。选择这些值是为了产生高度不同的角频率，具体为 $\\omega_1 = 100$ 和 $\\omega_2 = 1$，这会在动力学中引发强各向异性。\n\n4. 提供两个额外的测试用例以确保覆盖率：\n   - 各向同性“理想路径”用例，其中 $M = \\mathrm{diag}(1, 1)$ 和 $\\Lambda = \\mathrm{diag}(1, 1)$，具有适中的 $T$ 和初始状态，证明欧几里得检验和 M 加权检验结果一致：\n     - $M = \\mathrm{diag}(1, 1)$，\n     - $\\Lambda = \\mathrm{diag}(1, 1)$，\n     - $\\theta_0 = [0.3, -0.8]^\\top$，\n     - $p_0 = [0.7, 0.2]^\\top$，\n     - $T = 0.7$。\n   - 具有极端各向异性但动量仅与慢维度对齐的边缘用例（因此由于积分时间非常短，两种检验结果一致且都不会停止）：\n     - $M = \\mathrm{diag}(10^{-6}, 1)$，\n     - $\\Lambda = \\mathrm{diag}(1, 1)$，\n     - $\\theta_0 = [0.0, 1.0]^\\top$，\n     - $p_0 = [0.0, 0.1]^\\top$，\n     - $T = 0.01$。\n\n5. 对于每个测试用例，您的程序必须计算并返回一个包含三个布尔值的列表：\n   - 欧几里得停止决策（如果欧几里得检验指示停止，则为真，否则为假），\n   - M 加权停止决策（如果广义检验指示停止，则为真，否则为假），\n   - 一个失败标志，当且仅当欧几里得检验不停止而 M 加权检验停止时为真。\n\n6. 最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，每个测试用例的结果本身也格式化为一个带方括号的、逗号分隔的布尔值列表。例如，对于三个测试用例，输出应类似于 $[[\\text{False},\\text{True},\\text{True}],[\\text{False},\\text{False},\\text{False}],[\\text{False},\\text{False},\\text{False}]]$。\n\n不应读取任何用户输入。三角函数内的角度必须以弧度为单位，并且使用的任何数值都必须视为无量纲。对于对角的 $M$ 和对角的 $\\Lambda$，所有计算必须相对于闭式解是精确的；此程序中不要使用数值积分器。", "solution": "该问题要求实现和比较无U形转弯采样器 (NUTS) 的两种停止准则，NUTS 是一种用于哈密顿蒙特卡洛 (HMC) 的算法。其背景是从多元高斯分布中采样，对于该分布，哈密顿动力学具有闭式解。我们必须展示一个场景，其中标准的欧几里得停止准则失败，而一个广义的、质量矩阵感知的准则成功。\n\n首先，我们建立理论基础。该系统由势能 $U(\\theta) = \\frac{1}{2} \\theta^\\top \\Lambda \\theta$ 和动能 $K(p) = \\frac{1}{2} p^\\top M^{-1} p$ 定义。矩阵 $\\Lambda$（精度）和 $M$（质量）被给定为正定和对角的。哈密顿量为 $H(\\theta, p) = U(\\theta) + K(p)$。哈密顿运动方程为：\n$$\n\\frac{d\\theta}{dt} = \\frac{\\partial H}{\\partial p} = M^{-1} p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial \\theta} = -\\Lambda \\theta\n$$\n由于 $M$ 和 $\\Lambda$ 是对角的，其元素分别为 $M_i$ 和 $\\Lambda_i$，该系统解耦为每个坐标 $i$ 的一组独立方程：\n$$\n\\frac{d\\theta_i}{dt} = \\frac{p_i}{M_i}\n$$\n$$\n\\frac{dp_i}{dt} = -\\Lambda_i \\theta_i\n$$\n通过对第一个方程关于时间 $t$ 求导并代入第二个方程，我们得到了每个坐标 $\\theta_i$ 的简谐振子方程：\n$$\n\\frac{d^2\\theta_i}{dt^2} = \\frac{1}{M_i}\\frac{dp_i}{dt} = -\\frac{\\Lambda_i}{M_i}\\theta_i\n$$\n令 $\\omega_i = \\sqrt{\\Lambda_i / M_i}$ 为第 $i$ 个坐标的角频率，方程变为 $\\ddot{\\theta}_i + \\omega_i^2 \\theta_i = 0$。给定 $t=0$ 时的初始条件 $(\\theta_{i,0}, p_{i,0})$，该系统的精确解是相空间中的一个旋转：\n$$\n\\theta_i(t) = \\theta_{i,0} \\cos(\\omega_i t) + \\frac{p_{i,0}}{M_i \\omega_i} \\sin(\\omega_i t)\n$$\n$$\np_i(t) = p_{i,0} \\cos(\\omega_i t) - M_i \\omega_i \\theta_{i,0} \\sin(\\omega_i t)\n$$\n使用关系式 $\\omega_i = \\sqrt{\\Lambda_i / M_i}$，我们可以写出 $M_i \\omega_i = \\sqrt{M_i \\Lambda_i}$。解可以表示为：\n$$\n\\begin{pmatrix} \\theta_i(t) \\\\ p_i(t) \\end{pmatrix} = \\begin{pmatrix} \\cos(\\omega_i t)  \\frac{1}{\\sqrt{M_i\\Lambda_i}}\\sin(\\omega_i t) \\\\ -\\sqrt{M_i\\Lambda_i}\\sin(\\omega_i t)  \\cos(\\omega_i t) \\end{pmatrix} \\begin{pmatrix} \\theta_{i,0} \\\\ p_{i,0} \\end{pmatrix}\n$$\nNUTS 算法构建一个平衡二叉树的轨迹段来探索状态空间。当检测到U形转弯时，它会停止扩展轨迹。一个对称轨迹段的定义是从初始状态 $(\\theta_0, p_0)$ 向前和向后积分时间 $T$。这会产生一个最左点 $(\\theta^-, p^-) = (\\theta(-T), p(-T))$ 和一个最右点 $(\\theta^+, p^+) = (\\theta(T), p(T))$。轨迹段的跨度是向量 $\\Delta \\theta = \\theta^+ - \\theta^-$。\n\n停止准则旨在检测轨迹何时开始折返。\n1.  **欧几里得NUTS停止检验：** 该检验检查轨迹是否正在扩展。如果任一端点的动量指回轨迹段的起点，则停止。在数学上，如果满足以下条件，它会声明停止：\n    $$\n    (\\Delta \\theta)^\\top p^+  0 \\quad \\text{或} \\quad (\\Delta \\theta)^\\top p^-  0\n    $$\n2.  **广义M加权停止检验：** 在各向异性设置中（其中 $M$ 的元素差异很大），动量 $p$ 与物理速度 $v = d\\theta/dt$ 并不对齐。需要检查的正确物理量是速度。广义检验在内积中使用 $v = M^{-1}p$。如果满足以下条件，它会声明停止：\n    $$\n    (\\Delta \\theta)^\\top (M^{-1}p^+)  0 \\quad \\text{或} \\quad (\\Delta \\theta)^\\top (M^{-1}p^-)  0\n    $$\n    当 $M$ 是单位矩阵的标量倍数，即 $M = cI$ 时，此检验等同于欧几里得检验，因为 $M^{-1}p = (1/c)p$。然而，在强各向异性的情况下，它们可能产生不同的结果。\n\n程序将为给定的三个测试用例实现 $\\theta(t)$ 和 $p(t)$ 的精确解析解。对于每个用例，它将计算轨迹端点 $(\\theta^\\pm, p^\\pm)$、位移 $\\Delta \\theta$，并应用两种停止检验。主要的反例被构建为，一个高频坐标完成半个周期（$\\omega_1 T = \\pi/2$），导致其动量 $p_1$ 反转。由于质量 $M_1$ 非常小， $p_1$ 的大小也很小。欧几里得内积由另一个慢速移动的坐标主导，因此未能检测到这种反转。M 加权检验通过大的 $M_1^{-1}$ 缩放 $p_1$，揭示了大的负物理速度 $v_1$，并正确地发出停止信号。另外两个用例作为对照组，一个用于各向同性系统，另一个用于动力学不会触发停止的各向异性系统。\n\n最终输出将是一个列表的列表，其中每个内部列表包含三个布尔值，分别对应于欧几里得检验、M加权检验的结果，以及一个失败标志（当且仅当前者失败而后者成功时为真）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants  # Only for np.pi, not strictly necessary but adheres to library list.\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing three test cases for the NUTS stopping criteria.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Counterexample\n        {\n            \"M_diag\": np.array([1e-4, 1.0]),\n            \"Lambda_diag\": np.array([1.0, 1.0]),\n            \"theta0\": np.array([1.0, 1.0]),\n            \"p0\": np.array([0.01, 1.262]),\n            \"T\": np.pi / (2.0 * 100.0),\n        },\n        # Case 2: Isotropic \"happy path\"\n        {\n            \"M_diag\": np.array([1.0, 1.0]),\n            \"Lambda_diag\": np.array([1.0, 1.0]),\n            \"theta0\": np.array([0.3, -0.8]),\n            \"p0\": np.array([0.7, 0.2]),\n            \"T\": 0.7,\n        },\n        # Case 3: Aligned edge case\n        {\n            \"M_diag\": np.array([1e-6, 1.0]),\n            \"Lambda_diag\": np.array([1.0, 1.0]),\n            \"theta0\": np.array([0.0, 1.0]),\n            \"p0\": np.array([0.0, 0.1]),\n            \"T\": 0.01,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        # Step 1: Compute trajectory endpoints using the exact solution.\n        theta_plus, p_plus, theta_minus, p_minus = solve_hamiltonian(\n            params[\"theta0\"], params[\"p0\"], params[\"M_diag\"], params[\"Lambda_diag\"], params[\"T\"]\n        )\n\n        # Step 2: Implement and run the stopping tests.\n        delta_theta = theta_plus - theta_minus\n        \n        # Euclidean test\n        dot_plus_euc = np.dot(delta_theta, p_plus)\n        dot_minus_euc = np.dot(delta_theta, p_minus)\n        stop_euc = (dot_plus_euc  0) or (dot_minus_euc  0)\n\n        # M-weighted test\n        M_inv_diag = 1.0 / params[\"M_diag\"]\n        v_plus = M_inv_diag * p_plus\n        v_minus = M_inv_diag * p_minus\n        \n        dot_plus_m_w = np.dot(delta_theta, v_plus)\n        dot_minus_m_w = np.dot(delta_theta, v_minus)\n        stop_m_weighted = (dot_plus_m_w  0) or (dot_minus_m_w  0)\n\n        # Step 3: Determine the failure flag.\n        failure = (not stop_euc) and stop_m_weighted\n        \n        results.append([stop_euc, stop_m_weighted, failure])\n    \n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is '[[], [], []]'\n    # which we can manipulate to match the required output format.\n    formatted_output = str(results).replace(\" \", \"\")\n    print(formatted_output)\n\ndef solve_hamiltonian(theta0, p0, M_diag, Lambda_diag, T):\n    \"\"\"\n    Computes the exact solution of the Hamiltonian system for diagonal M and Lambda.\n\n    Args:\n        theta0 (np.ndarray): Initial position vector.\n        p0 (np.ndarray): Initial momentum vector.\n        M_diag (np.ndarray): Diagonal elements of the mass matrix M.\n        Lambda_diag (np.ndarray): Diagonal elements of the precision matrix Lambda.\n        T (float): Integration time.\n\n    Returns:\n        tuple: A tuple containing (theta+, p+, theta-, p-).\n    \"\"\"\n    # Angular frequencies\n    omega = np.sqrt(Lambda_diag / M_diag)\n    \n    # Precompute trigonometric terms for t = T\n    cos_omega_T = np.cos(omega * T)\n    sin_omega_T = np.sin(omega * T)\n    \n    # Scaling factor for momentum term in theta's solution\n    mom_scaling = 1.0 / (M_diag * omega) # which is 1.0 / np.sqrt(M_diag * Lambda_diag)\n    \n    # Scaling factor for position term in p's solution\n    pos_scaling = M_diag * omega # which is np.sqrt(M_diag * Lambda_diag)\n\n    # Calculate state at t = +T\n    theta_plus = theta0 * cos_omega_T + p0 * mom_scaling * sin_omega_T\n    p_plus = p0 * cos_omega_T - theta0 * pos_scaling * sin_omega_T\n\n    # Calculate state at t = -T\n    # cos(-x) = cos(x), sin(-x) = -sin(x)\n    theta_minus = theta0 * cos_omega_T - p0 * mom_scaling * sin_omega_T\n    p_minus = p0 * cos_omega_T + theta0 * pos_scaling * sin_omega_T\n    \n    return theta_plus, p_plus, theta_minus, p_minus\n\nsolve()\n```", "id": "3355985"}]}