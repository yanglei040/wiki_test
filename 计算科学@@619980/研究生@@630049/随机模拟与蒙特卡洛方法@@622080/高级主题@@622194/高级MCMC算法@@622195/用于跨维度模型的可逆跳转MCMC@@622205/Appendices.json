{"hands_on_practices": [{"introduction": "在可逆跳转马尔可夫链蒙特卡罗（RJMCMC）中，为了在不同维度的模型空间之间移动时维持细致平衡条件，计算雅可比行列式是至关重要的一步。本练习 [@problem_id:3336823] 通过一个简单、基础的“分裂”移动变换，让您能够专注于掌握这一核心数学机制，为更复杂的应用打下坚实基础。", "problem": "考虑一个用于跨维模型的可逆跳转马尔可夫链蒙特卡洛 (RJMCMC) 中的分裂移动。设原始参数向量为 $(\\mu,\\sigma,u)$，其中 $\\mu \\in \\mathbb{R}$ 是一个位置参数，$\\sigma \\in \\mathbb{R}_{+}$ 是一个尺度参数，而 $u \\in \\mathbb{R}$ 是为平衡维度而引入的辅助变量。该分裂移动通过以下变换将 $(\\mu,\\sigma,u)$ 映射到 $(\\mu_{1},\\mu_{2},\\sigma)$：\n$$\n\\mu_{1} = \\mu - \\delta u, \\qquad \\mu_{2} = \\mu + (1-\\delta)u, \\qquad \\sigma' = \\sigma,\n$$\n其中 $\\delta \\in (0,1)$ 是一个固定的调节常数。在 RJMCMC 的 Metropolis–Hastings 接受率中，变量替换公式需要用到从 $(\\mu,\\sigma,u)$ 到 $(\\mu_{1},\\mu_{2},\\sigma)$ 这个映射的雅可比行列式。\n\n根据可微变换 $T: \\mathbb{R}^{k} \\to \\mathbb{R}^{k}$ 的雅可比行列式是其偏导数雅可比矩阵的行列式这一基本定义，计算上述定义的映射 $(\\mu, \\sigma, u) \\mapsto (\\mu_{1}, \\mu_{2}, \\sigma)$ 的雅可比行列式。请将您的最终答案表示为以 $\\delta$ 表示的闭式表达式。无需四舍五入。", "solution": "用户要求计算在可逆跳转马尔可夫链蒙特卡洛 (RJMCMC) 的分裂移动中使用的一个特定变换的雅可比行列式。\n\n首先验证该问题，以确保其有科学依据、适定且客观。\n\n**步骤 1：提取已知条件**\n- **背景**：用于跨维模型的 RJMCMC 中的分裂移动。\n- **原始参数空间**：输入向量为 $(\\mu, \\sigma, u)$，其定义域为 $\\mu \\in \\mathbb{R}$，$\\sigma \\in \\mathbb{R}_{+}$ 和 $u \\in \\mathbb{R}$。\n- **目标参数空间**：输出向量为 $(\\mu_{1}, \\mu_{2}, \\sigma')$，其中 $\\sigma'=\\sigma$。\n- **变换方程**：\n  $$ \\mu_{1} = \\mu - \\delta u $$\n  $$ \\mu_{2} = \\mu + (1-\\delta)u $$\n  $$ \\sigma' = \\sigma $$\n- **常数**：$\\delta$ 是一个固定常数，其中 $\\delta \\in (0,1)$。\n- **目标**：计算映射 $(\\mu, \\sigma, u) \\mapsto (\\mu_{1}, \\mu_{2}, \\sigma')$ 的雅可比行列式。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上是合理的，因为它描述了在成熟的 RJMCMC 算法中使用的一种标准的维度匹配变换。它是适定的，因为该变换是一个可微函数，其雅可比行列式可以被唯一地计算出来。该问题使用精确的数学语言进行了客观陈述。没有会妨碍求解的矛盾、歧义或缺失信息。问题陈述中 $(\\mu_{1},\\mu_{2},\\sigma)$ 与定义的 $\\sigma'=\\sigma$ 之间的微小符号差异对于构建问题是无关紧要的。\n\n**结论**：该问题有效。\n\n**求解推导**\n设变换表示为 $T$。输入变量为 $(\\mu, \\sigma, u)$，输出变量为 $(\\mu_{1}, \\mu_{2}, \\sigma')$。该变换由以下公式给出：\n$$ \\mu_{1}(\\mu, \\sigma, u) = \\mu - \\delta u $$\n$$ \\mu_{2}(\\mu, \\sigma, u) = \\mu + (1-\\delta)u $$\n$$ \\sigma'(\\mu, \\sigma, u) = \\sigma $$\n\n此变换的雅可比行列式是雅可比矩阵 $J$ 的行列式，其元素是输出变量关于输入变量的偏导数。雅可比矩阵定义如下：\n$$\nJ = \\frac{\\partial(\\mu_{1}, \\mu_{2}, \\sigma')}{\\partial(\\mu, \\sigma, u)} =\n\\begin{pmatrix}\n\\frac{\\partial \\mu_{1}}{\\partial \\mu} & \\frac{\\partial \\mu_{1}}{\\partial \\sigma} & \\frac{\\partial \\mu_{1}}{\\partial u} \\\\\n\\frac{\\partial \\mu_{2}}{\\partial \\mu} & \\frac{\\partial \\mu_{2}}{\\partial \\sigma} & \\frac{\\partial \\mu_{2}}{\\partial u} \\\\\n\\frac{\\partial \\sigma'}{\\partial \\mu} & \\frac{\\partial \\sigma'}{\\partial \\sigma} & \\frac{\\partial \\sigma'}{\\partial u}\n\\end{pmatrix}\n$$\n我们现在计算每个偏导数：\n\n对于第一行，对应于 $\\mu_1$：\n$$ \\frac{\\partial \\mu_{1}}{\\partial \\mu} = \\frac{\\partial}{\\partial \\mu}(\\mu - \\delta u) = 1 $$\n$$ \\frac{\\partial \\mu_{1}}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma}(\\mu - \\delta u) = 0 $$\n$$ \\frac{\\partial \\mu_{1}}{\\partial u} = \\frac{\\partial}{\\partial u}(\\mu - \\delta u) = -\\delta $$\n\n对于第二行，对应于 $\\mu_2$：\n$$ \\frac{\\partial \\mu_{2}}{\\partial \\mu} = \\frac{\\partial}{\\partial \\mu}(\\mu + (1-\\delta)u) = 1 $$\n$$ \\frac{\\partial \\mu_{2}}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma}(\\mu + (1-\\delta)u) = 0 $$\n$$ \\frac{\\partial \\mu_{2}}{\\partial u} = \\frac{\\partial}{\\partial u}(\\mu + (1-\\delta)u) = 1 - \\delta $$\n\n对于第三行，对应于 $\\sigma'$：\n$$ \\frac{\\partial \\sigma'}{\\partial \\mu} = \\frac{\\partial}{\\partial \\mu}(\\sigma) = 0 $$\n$$ \\frac{\\partial \\sigma'}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma}(\\sigma) = 1 $$\n$$ \\frac{\\partial \\sigma'}{\\partial u} = \\frac{\\partial}{\\partial u}(\\sigma) = 0 $$\n\n将这些偏导数组合成雅可比矩阵 $J$：\n$$\nJ =\n\\begin{pmatrix}\n1 & 0 & -\\delta \\\\\n1 & 0 & 1-\\delta \\\\\n0 & 1 & 0\n\\end{pmatrix}\n$$\n雅可比行列式，记作 $\\det(J)$，可以使用代数余子式展开来计算。沿包含两个零的第二列展开，可以简化计算：\n$$\n\\det(J) = (0) \\cdot C_{12} + (0) \\cdot C_{22} + (1) \\cdot C_{32}\n$$\n其中 $C_{ij}$ 是第 $i$ 行第 $j$ 列元素的代数余子式。这可以简化为：\n$$\n\\det(J) = C_{32} = (-1)^{3+2} M_{32} = -M_{32}\n$$\n其中 $M_{32}$ 是对应于元素 $a_{32}$ 的余子式，通过计算去掉第 3 行和第 2 列后形成的子矩阵的行列式得到：\n$$\nM_{32} = \\det \\begin{pmatrix} 1 & -\\delta \\\\ 1 & 1-\\delta \\end{pmatrix}\n$$\n计算这个 $2 \\times 2$ 行列式：\n$$\nM_{32} = (1)(1-\\delta) - (-\\delta)(1) = 1 - \\delta + \\delta = 1\n$$\n将此结果代回到 $\\det(J)$ 的表达式中：\n$$\n\\det(J) = -M_{32} = -1\n$$\n因此，雅可比行列式为 $-1$。它是一个常数值，与调节参数 $\\delta$ 无关。Metropolis-Hastings 接受率中的要求是雅可比行列式的绝对值，即 $|-1| = 1$。然而，问题要求的是行列式本身。", "answer": "$$\n\\boxed{-1}\n$$", "id": "3336823"}, {"introduction": "在掌握了基础的雅可比行列式计算之后，我们将探讨一个更贴近实际应用的场景。本练习 [@problem_id:3336794] 涉及一个高斯混合模型的分裂移动，这是一个更复杂的多参数变换。通过解决这个问题，您将学会如何处理高维映射，并了解如何利用变换的结构特性（如块对角性）来简化计算过程。", "problem": "考虑一个单变量$K$分量高斯混合模型，其参数为 $\\Theta_{K}=\\{(w_{k},\\mu_{k},\\sigma_{k}): k=1,\\dots,K\\}$，其中 $w_{k}\\in(0,1)$，$\\sum_{k=1}^{K} w_{k}=1$，$\\mu_{k}\\in\\mathbb{R}$ 且 $\\sigma_{k}>0$。您在可逆跳转马尔可夫链蒙特卡洛（RJMCMC）中设计一个分裂移动（split move），通过将单个分量 $(w,\\mu,\\sigma)$ （为减少符号混乱，此处省略了索引）分裂为两个新分量 $(w_{1},\\mu_{1},\\sigma_{1})$ 和 $(w_{2},\\mu_{2},\\sigma_{2})$，从而将模型维度从 $K$ 增加到 $K+1$。为了避免标签切换问题，对均值施加了打破对称性的排序约束。\n\n为确保维度匹配和双射关系，您引入了辅助变量 $(\\lambda,u,\\psi)$，其中 $\\lambda\\in(0,1)$、$u\\in(0,1)$ 和 $\\psi\\in\\mathbb{R}$，以及一个固定的调节常数 $\\alpha>0$。分裂变换由以下映射定义：\n- 权重：\n$$\nw_{1}=w\\,\\lambda,\\qquad w_{2}=w\\,(1-\\lambda).\n$$\n- 通过正向分离得到的有序均值：\n$$\n\\mu_{1}=\\mu-\\delta,\\qquad \\mu_{2}=\\mu+\\delta,\\qquad \\delta=\\sigma\\,\\alpha\\,u,\n$$\n从而通过构造强制满足 $\\mu_{1} < \\mu_{2}$。\n- 通过乘法耦合的尺度：\n$$\n\\sigma_{1}=\\sigma\\,\\exp\\!\\left(\\frac{\\psi}{2}\\right),\\qquad \\sigma_{2}=\\sigma\\,\\exp\\!\\left(-\\frac{\\psi}{2}\\right).\n$$\n\n从蒙特卡洛方法中变换的基本变量替换原理以及可逆跳转马尔可夫链蒙特卡洛（RJMCMC）中的维度匹配要求出发，推导以下变换的雅可比行列式的绝对值：\n$$\n(w,\\mu,\\sigma,\\lambda,u,\\psi)\\ \\mapsto\\ (w_{1},w_{2},\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2}),\n$$\n并将其简化为仅含 $w$、$\\sigma$ 和 $\\alpha$ 的单个闭式表达式。您的最终答案必须是单个解析表达式。不需要数值近似。", "solution": "该问题要求推导在可逆跳转马尔可夫链蒙特卡洛（RJMCMC）分裂移动中使用的特定变换的雅可比行列式的绝对值。\n\n该变换将当前分量参数和一组辅助变量 $(w,\\mu,\\sigma,\\lambda,u,\\psi)$ 映射为两个新分量的一组新参数 $(w_{1},w_{2},\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2})$。输入变量的定义域是 $\\mathbb{R}^6$ 的一个子集，陪域也是 $\\mathbb{R}^6$ 的一个子集。该变换由以下方程组定义：\n$w_{1}=w\\lambda$\n$w_{2}=w(1-\\lambda)$\n$\\mu_{1}=\\mu-\\sigma\\alpha u$\n$\\mu_{2}=\\mu+\\sigma\\alpha u$\n$\\sigma_{1}=\\sigma\\exp(\\frac{\\psi}{2})$\n$\\sigma_{2}=\\sigma\\exp(-\\frac{\\psi}{2})$\n\n此变换的雅可比矩阵是一个 $6 \\times 6$ 的矩阵 $J$，其中第 $i$ 行第 $j$ 列的元素是第 $i$ 个输出变量关于第 $j$ 个输入变量的偏导数。我们需要计算从输入变量向量 $\\mathbf{x} = (w,\\mu,\\sigma,\\lambda,u,\\psi)$ 到输出变量向量 $\\mathbf{y} = (w_{1},w_{2},\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2})$ 的映射的 $|\\det(J)|$。\n\n雅可比矩阵由下式给出：\n$$\nJ = \\frac{\\partial(w_{1},w_{2},\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2})}{\\partial(w,\\mu,\\sigma,\\lambda,u,\\psi)}\n$$\n\n为了简化行列式的计算，我们可以根据输入变量在变换方程中的作用对它们进行重新排序。这揭示了映射的潜在结构。一个合适的排序是 $(w, \\lambda, \\mu, u, \\sigma, \\psi)$。我们将对应于这个新输入变量排序的雅可比矩阵记为 $J'$。矩阵中列的重新排序仅影响其行列式的符号。由于我们关心的是行列式的绝对值，因此 $|\\det(J)|=|\\det(J')|$。\n\n重新排序后的雅可比矩阵 $J'$ 是：\n$$\nJ' = \\frac{\\partial(w_{1},w_{2},\\mu_{1},\\mu_{2},\\sigma_{1},\\sigma_{2})}{\\partial(w,\\lambda,\\mu,u,\\sigma,\\psi)}\n$$\n让我们计算 $J'$ 的每个元素的偏导数。\n\n对于权重 $(w_1, w_2)$：\n$\\frac{\\partial w_{1}}{\\partial w} = \\lambda$，$\\frac{\\partial w_{1}}{\\partial \\lambda} = w$。其他导数为零。\n$\\frac{\\partial w_{2}}{\\partial w} = 1-\\lambda$，$\\frac{\\partial w_{2}}{\\partial \\lambda} = -w$。其他导数为零。\n\n对于均值 $(\\mu_1, \\mu_2)$：\n$\\frac{\\partial \\mu_{1}}{\\partial \\mu} = 1$，$\\frac{\\partial \\mu_{1}}{\\partial u} = -\\sigma\\alpha$，$\\frac{\\partial \\mu_{1}}{\\partial \\sigma} = -\\alpha u$。其他导数为零。\n$\\frac{\\partial \\mu_{2}}{\\partial \\mu} = 1$，$\\frac{\\partial \\mu_{2}}{\\partial u} = \\sigma\\alpha$，$\\frac{\\partial \\mu_{2}}{\\partial \\sigma} = \\alpha u$。其他导数为零。\n\n对于尺度 $(\\sigma_1, \\sigma_2)$：\n$\\frac{\\partial \\sigma_{1}}{\\partial \\sigma} = \\exp(\\frac{\\psi}{2})$，$\\frac{\\partial \\sigma_{1}}{\\partial \\psi} = \\frac{\\sigma}{2}\\exp(\\frac{\\psi}{2})$。其他导数为零。\n$\\frac{\\partial \\sigma_{2}}{\\partial \\sigma} = \\exp(-\\frac{\\psi}{2})$，$\\frac{\\partial \\sigma_{2}}{\\partial \\psi} = -\\frac{\\sigma}{2}\\exp(-\\frac{\\psi}{2})$。其他导数为零。\n\n将这些导数组合成矩阵 $J'$：\n$$\nJ' =\n\\begin{pmatrix}\n  \\frac{\\partial w_1}{\\partial w} & \\frac{\\partial w_1}{\\partial \\lambda} & \\frac{\\partial w_1}{\\partial \\mu} & \\frac{\\partial w_1}{\\partial u} & \\frac{\\partial w_1}{\\partial \\sigma} & \\frac{\\partial w_1}{\\partial \\psi} \\\\\n  \\frac{\\partial w_2}{\\partial w} & \\frac{\\partial w_2}{\\partial \\lambda} & \\frac{\\partial w_2}{\\partial \\mu} & \\frac{\\partial w_2}{\\partial u} & \\frac{\\partial w_2}{\\partial \\sigma} & \\frac{\\partial w_2}{\\partial \\psi} \\\\\n  \\frac{\\partial \\mu_1}{\\partial w} & \\frac{\\partial \\mu_1}{\\partial \\lambda} & \\frac{\\partial \\mu_1}{\\partial \\mu} & \\frac{\\partial \\mu_1}{\\partial u} & \\frac{\\partial \\mu_1}{\\partial \\sigma} & \\frac{\\partial \\mu_1}{\\partial \\psi} \\\\\n  \\frac{\\partial \\mu_2}{\\partial w} & \\frac{\\partial \\mu_2}{\\partial \\lambda} & \\frac{\\partial \\mu_2}{\\partial \\mu} & \\frac{\\partial \\mu_2}{\\partial u} & \\frac{\\partial \\mu_2}{\\partial \\sigma} & \\frac{\\partial \\mu_2}{\\partial \\psi} \\\\\n  \\frac{\\partial \\sigma_1}{\\partial w} & \\frac{\\partial \\sigma_1}{\\partial \\lambda} & \\frac{\\partial \\sigma_1}{\\partial \\mu} & \\frac{\\partial \\sigma_1}{\\partial u} & \\frac{\\partial \\sigma_1}{\\partial \\sigma} & \\frac{\\partial \\sigma_1}{\\partial \\psi} \\\\\n  \\frac{\\partial \\sigma_2}{\\partial w} & \\frac{\\partial \\sigma_2}{\\partial \\lambda} & \\frac{\\partial \\sigma_2}{\\partial \\mu} & \\frac{\\partial \\sigma_2}{\\partial u} & \\frac{\\partial \\sigma_2}{\\partial \\sigma} & \\frac{\\partial \\sigma_2}{\\partial \\psi}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n  \\lambda & w & 0 & 0 & 0 & 0 \\\\\n  1-\\lambda & -w & 0 & 0 & 0 & 0 \\\\\n  0 & 0 & 1 & -\\sigma\\alpha & -\\alpha u & 0 \\\\\n  0 & 0 & 1 & \\sigma\\alpha & \\alpha u & 0 \\\\\n  0 & 0 & 0 & 0 & \\exp(\\frac{\\psi}{2}) & \\frac{\\sigma}{2}\\exp(\\frac{\\psi}{2}) \\\\\n  0 & 0 & 0 & 0 & \\exp(-\\frac{\\psi}{2}) & -\\frac{\\sigma}{2}\\exp(-\\frac{\\psi}{2})\n\\end{pmatrix}\n$$\n该矩阵是分块上三角矩阵：\n$$\nJ' = \\begin{pmatrix} A & \\mathbf{0} & \\mathbf{0} \\\\ \\mathbf{0} & B & C \\\\ \\mathbf{0} & \\mathbf{0} & D \\end{pmatrix}\n$$\n其中 $A$、$B$、$C$ 和 $D$ 是 $2 \\times 2$ 矩阵。分块上三角矩阵的行列式是其对角线上分块矩阵的行列式的乘积。\n$$\n\\det(J') = \\det(A) \\det(B) \\det(D)\n$$\n对角线上的分块矩阵是：\n$$\nA = \\frac{\\partial(w_1,w_2)}{\\partial(w,\\lambda)} = \\begin{pmatrix} \\lambda & w \\\\ 1-\\lambda & -w \\end{pmatrix}\n$$\n$$\nB = \\frac{\\partial(\\mu_1,\\mu_2)}{\\partial(\\mu,u)} = \\begin{pmatrix} 1 & -\\sigma\\alpha \\\\ 1 & \\sigma\\alpha \\end{pmatrix}\n$$\n$$\nD = \\frac{\\partial(\\sigma_1,\\sigma_2)}{\\partial(\\sigma,\\psi)} = \\begin{pmatrix} \\exp(\\frac{\\psi}{2}) & \\frac{\\sigma}{2}\\exp(\\frac{\\psi}{2}) \\\\ \\exp(-\\frac{\\psi}{2}) & -\\frac{\\sigma}{2}\\exp(-\\frac{\\psi}{2}) \\end{pmatrix}\n$$\n我们计算每个分块的行列式：\n$$\n\\det(A) = (\\lambda)(-w) - (w)(1-\\lambda) = -w\\lambda - w + w\\lambda = -w\n$$\n$$\n\\det(B) = (1)(\\sigma\\alpha) - (-\\sigma\\alpha)(1) = \\sigma\\alpha + \\sigma\\alpha = 2\\sigma\\alpha\n$$\n$$\n\\det(D) = \\left(\\exp\\left(\\frac{\\psi}{2}\\right)\\right)\\left(-\\frac{\\sigma}{2}\\exp\\left(-\\frac{\\psi}{2}\\right)\\right) - \\left(\\frac{\\sigma}{2}\\exp\\left(\\frac{\\psi}{2}\\right)\\right)\\left(\\exp\\left(-\\frac{\\psi}{2}\\right)\\right) = -\\frac{\\sigma}{2} - \\frac{\\sigma}{2} = -\\sigma\n$$\n$J'$的行列式是这些行列式的乘积：\n$$\n\\det(J') = \\det(A) \\cdot \\det(B) \\cdot \\det(D) = (-w)(2\\sigma\\alpha)(-\\sigma) = 2w\\sigma^2\\alpha\n$$\n问题要求的是行列式的绝对值。根据问题陈述，参数满足 $w \\in (0,1)$、$\\sigma > 0$，且调节常数 $\\alpha > 0$。因此，表达式 $2w\\sigma^2\\alpha$ 是严格为正的。\n$$\n|\\det(J)| = |\\det(J')| = |2w\\sigma^2\\alpha| = 2w\\sigma^2\\alpha\n$$\n如题目所要求，该表达式简化为仅与 $w$、$\\sigma$ 和 $\\alpha$ 相关的函数。辅助随机变量 $\\lambda$、 $u$ 和 $\\psi$ 未出现在雅可比行列式的最终表达式中。", "answer": "$$\n\\boxed{2w\\sigma^2\\alpha}\n$$", "id": "3336794"}, {"introduction": "这个练习是本章的综合实践，将带领您从纸笔计算走向实际的编程实现 [@problem_id:3336810]。您需要将RJMCMC的所有理论组成部分——似然、先验、提议分布和包含雅可比项的接受率——整合到一个完整的高斯混合模型采样器中。完成这项任务将使您对整个算法的工作流程有一个全面、深入的实践理解。", "problem": "要求您为具有共享协方差矩阵的有限高斯混合模型设计并实现一个完整的可逆跳跃马尔可夫链蒙特卡罗（RJMCMC）移动方案，该方案使用一种映射，为所有未受影响的组分保留指数族自然参数，并且仅扰动所选组分的低维子空间。您的解决方案必须从马尔可夫链蒙特卡罗和 RJMCMC 接受率的基本原理出发。您必须推导并实现分裂和合并移动中使用的确定性维度匹配变换的雅可比行列式，并验证其稳定性。\n\n考虑一个二维高斯混合模型，其具有一个共享的、已知的协方差矩阵 $ \\Sigma \\in \\mathbb{R}^{2 \\times 2} $。具有 $ K $ 个组分的模型参数为 $ \\Theta_K = \\{ (\\mu_k)_{k=1}^K, \\alpha \\in \\mathbb{R}^K \\} $，其中 $ \\mu_k \\in \\mathbb{R}^2 $ 是组分 $ k $ 的均值，$ \\alpha \\in \\mathbb{R}^K $ 是混合权重的无约束 logits。权重为 $ w_k = \\exp(\\alpha_k) \\big/ \\sum_{\\ell=1}^K \\exp(\\alpha_\\ell) $。数据似然为\n$$\np(x_1,\\dots,x_n \\mid \\Theta_K, K) = \\prod_{i=1}^n \\sum_{k=1}^K w_k \\,\\mathcal{N}(x_i \\mid \\mu_k, \\Sigma).\n$$\n假设使用以下先验：\n- logits 的独立高斯先验 $ \\alpha \\sim \\mathcal{N}(0, \\sigma_\\alpha^2 I_K) $，其中 $ \\sigma_\\alpha^2 = 4 $。\n- 组分均值的独立高斯先验 $ \\mu_k \\sim \\mathcal{N}(m_0, \\tau^2 I_2) $，其中 $ m_0 = (0,0)^\\top $ 且 $ \\tau^2 = 9 $。\n- 组分数 $ K \\in \\{1, 2\\} $ 的均匀先验。\n\n具有共享协方差的高斯均值的指数族自然参数是 $ \\eta_k = \\Sigma^{-1} \\mu_k $。您的 RJ 映射必须保留所有未被分裂或合并的组分的 $ \\eta_k $（等价于 $ \\mu_k $）。\n\n您必须实现 $ K = 1 $ 和 $ K = 2 $ 之间的跨维分裂和合并移动。使用以下固定设置：\n- 共享协方差 $ \\Sigma = \\mathrm{diag}(0.25, 0.25) $。\n- 维度 $ d = 2 $。\n- 令 $ v = (1,0)^\\top $ 和 $ v_\\perp = (0,1)^\\top $。定义 $ e_1 = (1,0)^\\top $ 和 $ e_2 = (0,1)^\\top $。\n- 定义所选组分 $ j $ 的均值分裂映射为\n$$\n\\mu_{j,1} = \\mu_j + R u, \\qquad \\mu_{j,2} = \\mu_j + S u,\n$$\n其中 $ u = (u_1,u_2)^\\top \\sim \\mathcal{N}(0, I_2) $，$ R = s\\, v e_1^\\top $，$ S = - s\\, v e_1^\\top + t\\, v_\\perp e_2^\\top $，且尺度为 $ s = 0.5 $ 和 $ t = 0.5 $。此映射仅为每个子均值扰动一个低维子空间：$ \\mu_{j,1} $ 仅沿 $ v $ 扰动，而 $ \\mu_{j,2} $ 沿 $ v $ 和 $ v_\\perp $ 扰动，每个方向具有秩一结构。\n- 定义 logits 的分裂映射为\n$$\n\\alpha_{j,1} = \\alpha_j + u_\\alpha, \\qquad \\alpha_{j,2} = \\alpha_j - u_\\alpha,\n$$\n其中 $ u_\\alpha \\sim \\mathcal{N}(0, \\sigma_{u\\alpha}^2) $，且 $ \\sigma_{u\\alpha} = 0.75 $。所有其他 logits 和均值保持不变。\n\n对于合并移动，使用上述变换所隐含的逆映射：\n- logits 的逆映射为 $ \\alpha_j = \\tfrac{1}{2}(\\alpha_{j,1} + \\alpha_{j,2}) $ 和 $ u_\\alpha = \\tfrac{1}{2}(\\alpha_{j,1} - \\alpha_{j,2}) $。\n- 令 $ \\Delta \\mu = \\mu_{j,2} - \\mu_{j,1} $。当 $ S - R \\in \\mathbb{R}^{2 \\times 2} $ 可逆时，使用\n$$\nu = (S - R)^{-1} \\Delta \\mu, \\qquad \\mu_j = \\mu_{j,1} - R u,\n$$\n这可以精确地恢复原像。均值映射的雅可比行列式是 $ \\lvert \\det(S - R) \\rvert $，logit 分裂映射的雅可比行列式是 $ 2 $，因此分裂的总雅可比因子是\n$$\n\\lvert J_{\\text{split}} \\rvert = \\lvert \\det(S - R) \\rvert \\times 2 = 4st。\n$$\n在给定的 $ s $ 和 $ t $ 下，这是一个等于 $ 1.0 $ 的常数，这最小化了雅可比行列式的变异性。\n\n在每个 $K2$ 的状态，以概率 $ p_{\\mathrm{sp}} = 1/2 $ 提议一次分裂移动；要分裂的组分从 $ K $ 个组分中均匀选择；并抽取独立的辅助变量 $ u \\sim \\mathcal{N}(0, I_2) $ 和 $ u_\\alpha \\sim \\mathcal{N}(0, \\sigma_{u\\alpha}^2) $。在每个 $ K > 1 $ 的状态，以概率 $ p_{\\mathrm{mg}} = 1/2 $ 提议一次合并移动；要合并的无序对从 $ \\binom{K}{2} $ 个对中均匀选择；通过逆映射确定性地恢复反向分裂的辅助变量。\n\n从状态 $ (K, \\Theta_K) $ 到 $ (K+1, \\Theta_{K+1}) $ 并带有辅助变量 $ u $ 的分裂提议的通用 RJMCMC 接受概率为\n$$\n\\alpha_{\\mathrm{sp}} = \\min\\left\\{ 1, \\frac{ \\pi(K+1, \\Theta_{K+1} \\mid x_{1:n}) }{ \\pi(K, \\Theta_K \\mid x_{1:n}) } \\cdot \\frac{ p_{\\mathrm{mg}} \\cdot \\frac{1}{\\binom{K+1}{2}} }{ p_{\\mathrm{sp}} \\cdot \\frac{1}{K} \\cdot g(u) } \\cdot \\lvert J_{\\mathrm{split}} \\rvert \\right\\},\n$$\n其中 $ \\pi $ 是未归一化的后验，$ g(u) $ 是分裂中使用的辅助变量的联合密度。从 $ (K+1, \\Theta_{K+1}) $ 到 $ (K, \\Theta_K) $ 的相应合并移动的接受概率为\n$$\n\\alpha_{\\mathrm{mg}} = \\min\\left\\{ 1, \\frac{ \\pi(K, \\Theta_{K} \\mid x_{1:n}) }{ \\pi(K+1, \\Theta_{K+1} \\mid x_{1:n}) } \\cdot \\frac{ p_{\\mathrm{sp}} \\cdot \\frac{1}{K} \\cdot g(u) }{ p_{\\mathrm{mg}} \\cdot \\frac{1}{\\binom{K+1}{2}} } \\cdot \\frac{1}{\\lvert J_{\\mathrm{split}} \\rvert} \\right\\},\n$$\n其中 $ u $ 通过逆映射恢复。\n\n数据生成和常数：\n- 设置 $ n = 60 $，并使用固定种子按如下方式生成数据：从 $ \\mathcal{N}((-2,0)^\\top, \\Sigma) $ 中抽取 $ n/2 $ 个点，从 $ \\mathcal{N}((2,0)^\\top, \\Sigma) $ 中抽取 $ n/2 $ 个点，使用固定的伪随机种子 $ 42 $。\n- 在 $ K=1 $，$ \\mu_1 = (0,0)^\\top $，$ \\alpha_1 = 0 $ 处初始化。\n\n您的程序必须计算以下四个测试案例，并将结果汇总到一行中：\n- 案例 A（标准分裂情况）：从 $ K=1 $ 的初始状态开始，使用固定的伪随机种子 $ 123 $ 为 $ u $ 和 $ u_\\alpha $ 抽取的辅助变量，提议对组分 $ j=1 $ 进行分裂，并计算分裂接受概率 $ \\alpha_{\\mathrm{sp}} $（浮点数）。\n- 案例 B（逆向合并）：使用案例 A 中提议的确切分裂后状态（不要重新采样），计算合并由分裂创建的两个组分的接受概率 $ \\alpha_{\\mathrm{mg}} $。返回此浮点数。\n- 案例 C（边界条件）：从任何 $ K=2 $ 的状态（例如，案例 A 中的分裂后状态）尝试进行分裂移动。由于 $ K_{\\max} = 2 $，此移动是不允许的；返回浮点数 $ 0.0 $。\n- 案例 D（雅可比行列式的稳定性）：计算指定映射的绝对行列式 $ \\lvert J_{\\mathrm{split}} \\rvert $ 并将其作为浮点数返回。\n\n如果使用任何三角函数，所有角度都应视为弧度；不涉及物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $ [r_1, r_2, r_3, r_4] $，其中每个 $ r_i $ 是一个对应于案例 A-D 的浮点数。", "solution": "该问题要求为贝叶斯有限高斯混合模型设计并实现一个可逆跳跃马尔可夫链蒙特卡罗（RJMCMC）方案。具体来说，我们要构建模型在 $K=1$ 和 $K=2$ 个组分之间的跨维移动，推导相关变换的雅可比行列式，并计算特定测试案例的接受概率。\n\n### 1. 问题验证\n首先对问题陈述的科学合理性、完整性和一致性进行了验证。\n\n- **给定条件**：问题提供了模型的完整规范，包括 $K$ 组分高斯混合的数据似然、一个共享且已知的协方差矩阵 $\\Sigma = \\mathrm{diag}(0.25, 0.25)$、组分均值 $\\mu_k \\sim \\mathcal{N}(m_0, \\tau^2 I_2)$ 和混合 logits $\\alpha \\sim \\mathcal{N}(0, \\sigma_\\alpha^2 I_K)$ 的先验，以及组分数 $K \\in \\{1,2\\}$ 的均匀先验。所有常数（$m_0, \\tau^2, \\sigma_\\alpha^2$）都已指定。\n- **RJMCMC 方案**：定义了一个具体的分裂/合并提议机制。这包括均值和 logits 的确定性变换、辅助变量 $u$ 和 $u_\\alpha$ 的分布、移动提议概率 $p_{\\mathrm{sp}}$ 和 $p_{\\mathrm{mg}}$，以及接受率的公式。雅可比行列式也已提供为 $\\lvert J_{\\text{split}} \\rvert = 4st = 1.0$。\n- **验证结论**：该问题具有科学依据，采用了计算统计学中的标准方法（贝叶斯 GMMs, RJMCMC）。这是一个适定问题，为指定的计算任务提供了所有必要的信息以获得唯一解。语言客观而精确。所提供的雅可比行列式值经过验证，确认无误。因此，该问题被认为是**有效的**。\n\n### 2. 贝叶斯模型与后验\nMCMC 模拟的目标是后验分布 $p(K, \\Theta_K \\mid x_{1:n})$。未归一化的后验，记作 $\\pi(K, \\Theta_K \\mid x_{1:n})$，由似然与先验的乘积给出：\n$$\n\\pi(K, \\Theta_K \\mid x_{1:n}) = p(x_{1:n} \\mid \\Theta_K, K) p(\\Theta_K \\mid K) p(K)\n$$\n其中：\n1.  **似然**：$p(x_{1:n} \\mid \\Theta_K, K) = \\prod_{i=1}^n \\sum_{k=1}^K w_k \\,\\mathcal{N}(x_i \\mid \\mu_k, \\Sigma)$。混合权重为 $w_k = \\frac{\\exp(\\alpha_k)}{\\sum_{\\ell=1}^K \\exp(\\alpha_\\ell)}$。\n2.  **参数先验**：$p(\\Theta_K \\mid K) = \\left( \\prod_{k=1}^K p(\\mu_k) \\right) p(\\alpha)$。先验是独立的高斯分布：$p(\\mu_k) = \\mathcal{N}(\\mu_k \\mid m_0, \\tau^2 I_2)$ 和 $p(\\alpha) = \\mathcal{N}(\\alpha \\mid 0, \\sigma_\\alpha^2 I_K)$。\n3.  **模型先验**：$p(K)$ 在 $\\{1, 2\\}$ 上是均匀的，所以 $p(K=1) = p(K=2) = 1/2$。\n\n### 3. RJMCMC 框架\nRJMCMC 将 MCMC 扩展到从不同维度的空间中采样。对于从状态 $(K, \\Theta_K)$ 到 $(K+1, \\Theta_{K+1})$ 的移动，我们引入辅助随机变量 $u$，其从密度 $g(u)$ 中抽取，并定义一个确定性的可逆变换 $T$：\n$$\n\\Theta_{K+1} = T( \\Theta_K, u )\n$$\n维度匹配得以保证，因为 $\\mathrm{dim}(\\Theta_{K+1}) = \\mathrm{dim}(\\Theta_K) + \\mathrm{dim}(u)$。这种“分裂”移动的接受概率为：\n$$\n\\alpha_{\\mathrm{sp}} = \\min \\left\\{ 1, \\frac{\\pi(K+1, \\Theta_{K+1} \\mid x)}{\\pi(K, \\Theta_K \\mid x)} \\cdot \\frac{q((K, \\Theta_K) \\mid (K+1, \\Theta_{K+1}))}{q((K+1, \\Theta_{K+1}) \\mid (K, \\Theta_K))} \\cdot \\left| \\frac{\\partial \\Theta_{K+1}}{\\partial (\\Theta_K, u)} \\right| \\right\\}\n$$\n其中 $q$ 项是提议概率，最后一项是变换的雅可比行列式。\n\n对于此问题，$K=1 \\to K=2$ 分裂的提议概率比为：\n$$\n\\frac{q(\\text{merge})}{q(\\text{split})} = \\frac{p_{\\mathrm{mg}} \\cdot \\frac{1}{\\binom{2}{2}}}{p_{\\mathrm{sp}} \\cdot \\frac{1}{1} \\cdot g(u, u_\\alpha)} = \\frac{p_{\\mathrm{mg}}}{p_{\\mathrm{sp}} \\cdot g(u, u_\\alpha)}\n$$\n由于 $p_{\\mathrm{sp}}=p_{\\mathrm{mg}}=1/2$，这简化为 $1/g(u, u_\\alpha)$。分裂的接受概率为：\n$$\n\\alpha_{\\mathrm{sp}} = \\min\\left\\{ 1, \\frac{ \\pi(2, \\Theta_2 \\mid x) }{ \\pi(1, \\Theta_1 \\mid x) } \\cdot \\frac{1}{g(u, u_\\alpha)} \\cdot \\lvert J_{\\text{split}} \\rvert \\right\\}\n$$\n对于逆向的合并移动，接受概率为：\n$$\n\\alpha_{\\mathrm{mg}} = \\min\\left\\{ 1, \\frac{ \\pi(1, \\Theta_1 \\mid x) }{ \\pi(2, \\Theta_2 \\mid x) } \\cdot g(u, u_\\alpha) \\cdot \\frac{1}{\\lvert J_{\\text{split}} \\rvert} \\right\\}\n$$\n注意，模型先验的比率 $p(K=2)/p(K=1) = 1$，所以它从后验比率中消去。\n\n### 4. 雅可比行列式推导\n变换是从 $(\\mu_j, \\alpha_j, u, u_\\alpha)$ 到 $(\\mu_{j,1}, \\mu_{j,2}, \\alpha_{j,1}, \\alpha_{j,2})$，其中状态的维度分别为 $(2, 1, 2, 1)$ 和 $(2, 2, 1, 1)$。两边的总维度均为 $6$。增广变换 $T_{\\text{aug}}$ 为：\n$$\n(\\mu_{j,1}, \\mu_{j,2}, \\alpha_{j,1}, \\alpha_{j,2}) = T_{\\text{aug}}(\\mu_j, u, \\alpha_j, u_\\alpha) = (\\mu_j + Ru, \\mu_j + Su, \\alpha_j + u_{\\alpha}, \\alpha_j - u_{\\alpha})\n$$\n此变换的雅可比矩阵是块对角的：\n$$\nJ_{\\text{aug}} = \\frac{\\partial(\\mu_{j,1}, \\mu_{j,2}, \\alpha_{j,1}, \\alpha_{j,2})}{\\partial(\\mu_j, u, \\alpha_j, u_\\alpha)} = \\begin{pmatrix}\n\\frac{\\partial(\\mu_{j,1}, \\mu_{j,2})}{\\partial(\\mu_j, u)}  \\mathbf{0} \\\\\n\\mathbf{0}  \\frac{\\partial(\\alpha_{j,1}, \\alpha_{j,2})}{\\partial(\\alpha_j, u_\\alpha)}\n\\end{pmatrix}\n$$\n左上角的块对应于均值变换：\n$$\n\\frac{\\partial(\\mu_j+Ru, \\mu_j+Su)}{\\partial(\\mu_j, u)} = \\begin{pmatrix} I_2  R \\\\ I_2  S \\end{pmatrix}\n$$\n其行列式为 $\\det(S-R)$。给定 $R = \\begin{pmatrix} s  0 \\\\ 0  0 \\end{pmatrix}$ 和 $S = \\begin{pmatrix} -s  0 \\\\ 0  t \\end{pmatrix}$，我们有 $S-R = \\begin{pmatrix} -2s  0 \\\\ 0  t \\end{pmatrix}$，所以 $\\det(S-R) = -2st$。\n右下角的块对应于 logit 变换：\n$$\n\\frac{\\partial(\\alpha_j+u_\\alpha, \\alpha_j-u_\\alpha)}{\\partial(\\alpha_j, u_\\alpha)} = \\begin{pmatrix} 1  1 \\\\ 1  -1 \\end{pmatrix}\n$$\n其行列式为 $1(-1) - 1(1) = -2$。\n完整雅可比矩阵 $J_{\\text{aug}}$ 的行列式是各块行列式的乘积：$\\det(J_{\\text{aug}}) = (-2st)(-2) = 4st$。所需的绝对值为 $\\lvert J_{\\text{split}} \\rvert = 4st$。对于 $s=0.5$ 和 $t=0.5$，这个值为 $1.0$。雅可比行列式为 $1$ 在数值上是稳定的，并简化了接受率。\n\n### 5. 实现策略\n为了计算所需的量，我们实现了计算对数后验和 RJMCMC 接受率的函数。所有计算都在对数空间中执行，以保持数值稳定性。\n\n- **对数后验**：$\\log \\pi(K, \\Theta_K | x) = \\log p(x | \\Theta_K, K) + \\log p(\\Theta_K | K)$。\n- **对数似然**：$\\log p(x | \\Theta_K, K) = \\sum_{i=1}^n \\log \\left( \\sum_{k=1}^K w_k \\mathcal{N}(x_i | \\mu_k, \\Sigma) \\right)$。内部求和使用 `logsumexp` 函数计算以保证鲁棒性：$\\sum_{i=1}^n \\mathrm{logsumexp}_{k} (\\log w_k + \\log \\mathcal{N}(x_i | \\mu_k, \\Sigma))$。\n- **对数先验**：这是所有参数的对数先验之和：$\\sum_k \\log p(\\mu_k) + \\log p(\\alpha)$。\n- **接受率**：对于分裂移动，比率项（在 $\\min$ 函数内部）的对数为：\n$$\n\\log R_{\\text{sp}} = (\\log\\pi_2 - \\log\\pi_1) - \\log g(u, u_\\alpha) + \\log \\lvert J_{\\text{split}} \\rvert\n$$\n其中 $\\log\\pi_1$ 和 $\\log\\pi_2$ 分别是 $K=1$ 和 $K=2$ 状态的对数后验。\n对于合并移动，对数比率就是 $\\log R_{\\text{mg}} = -\\log R_{\\text{sp}}$。最终的接受概率是 $\\alpha_{\\text{sp}} = \\min(1, \\exp(\\log R_{\\text{sp}}))$ 和 $\\alpha_{\\text{mg}} = \\min(1, \\exp(\\log R_{\\text{mg}}))$。\n\n四个测试案例计算如下：\n- **案例 A (分裂)**：从初始状态 $K=1$ 开始，使用种子 $123$ 抽取的辅助变量，计算 $\\alpha_{\\text{sp}}$。\n- **案例 B (合并)**：从案例 A 中提议的状态出发，计算逆向移动的 $\\alpha_{\\text{mg}}$。即 $\\min(1, \\exp(-\\log R_{\\text{sp}}))$。\n- **案例 C (边界)**：从 $K=2$ 进行分裂移动是不可能的，因为 $K_{\\max}=2$。提议概率为零，因此接受概率为 $0.0$。\n- **案例 D (雅可比行列式)**：计算 $\\lvert J_{\\text{split}} \\rvert = 4st = 4(0.5)(0.5) = 1.0$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import logsumexp\nfrom scipy.stats import multivariate_normal\n\ndef solve():\n    \"\"\"\n    Implements the RJMCMC move scheme and computes the results for the four test cases.\n    \"\"\"\n    # Define constants from the problem statement\n    D = 2\n    SIGMA_VAL = 0.25\n    SIGMA = np.diag([SIGMA_VAL] * D)\n    SIGMA_ALPHA2 = 4.0\n    M0 = np.array([0., 0.])\n    TAU2 = 9.0\n    PRIOR_MU_COV = np.eye(D) * TAU2\n    S_SCALE = 0.5\n    T_SCALE = 0.5\n    SIGMA_UALPHA = 0.75\n    N = 60\n    DATA_SEED = 42\n    P_SP = 0.5\n    P_MG = 0.5\n    AUX_SEED = 123\n    INITIAL_MU_VEC = np.array([0., 0.])\n    INITIAL_ALPHA_VEC = np.array([0.])\n    INITIAL_MUS = np.array([INITIAL_MU_VEC])\n    \n    # Helper function for log posterior calculation\n    def compute_log_posterior(X, mus, alphas, K):\n        # 1. Log-Likelihood Calculation\n        log_w = alphas - logsumexp(alphas)\n        \n        log_likelihood_per_point = np.zeros(X.shape[0])\n        for i, x_i in enumerate(X):\n            terms = np.zeros(K)\n            for k in range(K):\n                terms[k] = log_w[k] + multivariate_normal.logpdf(x_i, mean=mus[k], cov=SIGMA)\n            log_likelihood_per_point[i] = logsumexp(terms)\n        \n        log_lik = np.sum(log_likelihood_per_point)\n\n        # 2. Log-Prior Calculation\n        log_prior = 0.0\n        # Prior on means\n        for k in range(K):\n            log_prior += multivariate_normal.logpdf(mus[k], mean=M0, cov=PRIOR_MU_COV)\n        # Prior on logits\n        prior_alpha_cov = np.eye(K) * SIGMA_ALPHA2\n        log_prior += multivariate_normal.logpdf(alphas, mean=np.zeros(K), cov=prior_alpha_cov)\n        \n        return log_lik + log_prior\n\n    # Case D: Compute Jacobian determinant\n    jacobian_det = 4 * S_SCALE * T_SCALE\n    \n    # Generate data as specified\n    rng_data = np.random.default_rng(DATA_SEED)\n    mu_true1 = np.array([-2., 0.])\n    mu_true2 = np.array([2., 0.])\n    data1 = rng_data.multivariate_normal(mu_true1, SIGMA, size=N // 2)\n    data2 = rng_data.multivariate_normal(mu_true2, SIGMA, size=N // 2)\n    X = np.vstack((data1, data2))\n\n    # --- Case A: Split Move ---\n    # From initial state (K=1)\n    K1 = 1\n    log_post1 = compute_log_posterior(X, INITIAL_MUS, INITIAL_ALPHA_VEC, K1)\n    \n    # Generate auxiliary variables from seed 123\n    rng_aux = np.random.default_rng(AUX_SEED)\n    u_aux = rng_aux.standard_normal(D)\n    u_alpha_aux = rng_aux.normal(0, SIGMA_UALPHA)\n    \n    # Define split mapping matrices\n    v = np.array([1., 0.])\n    v_perp = np.array([0., 1.])\n    e1 = np.array([1., 0.])\n    e2 = np.array([0., 1.])\n    R = S_SCALE * np.outer(v, e1)\n    S = -S_SCALE * np.outer(v, e1) + T_SCALE * np.outer(v_perp, e2)\n    \n    # Create proposed state (K=2)\n    K2 = 2\n    mu_j1 = INITIAL_MU_VEC + R @ u_aux\n    mu_j2 = INITIAL_MU_VEC + S @ u_aux\n    mus2 = np.array([mu_j1, mu_j2])\n    \n    alpha_j1 = INITIAL_ALPHA_VEC[0] + u_alpha_aux\n    alpha_j2 = INITIAL_ALPHA_VEC[0] - u_alpha_aux\n    alphas2 = np.array([alpha_j1, alpha_j2])\n\n    # Log posterior of proposed state\n    log_post2 = compute_log_posterior(X, mus2, alphas2, K2)\n    \n    # Log density of auxiliary variables\n    log_g_u = multivariate_normal.logpdf(u_aux, mean=np.zeros(D), cov=np.eye(D)) + \\\n              multivariate_normal.logpdf(u_alpha_aux, mean=0, cov=SIGMA_UALPHA**2)\n              \n    # Log Jacobian\n    log_J = np.log(jacobian_det)\n\n    # Proposal probabilities ratio for K=1 - K=2 (is 1, log is 0)\n    log_prop_ratio = np.log(P_MG / (1/1)) - np.log(P_SP / (1/1))\n    \n    # Log of the term inside min{1, .} for the split acceptance probability\n    log_alpha_sp_ratio = log_post2 - log_post1 + log_prop_ratio - log_g_u + log_J\n    alpha_sp = min(1.0, np.exp(log_alpha_sp_ratio))\n    \n    # --- Case B: Merge Move ---\n    # The merge move is the exact reverse of the split move.\n    # The log ratio is the negative of the split's log ratio.\n    log_alpha_mg_ratio = -log_alpha_sp_ratio\n    alpha_mg = min(1.0, np.exp(log_alpha_mg_ratio))\n\n    # --- Case C: Boundary Condition ---\n    # Attempting a split from K=2 when K_max=2 is disallowed.\n    # The proposal probability for such a move is 0.\n    alpha_split_from_2 = 0.0\n\n    # Aggregate results for printing\n    results = [alpha_sp, alpha_mg, alpha_split_from_2, jacobian_det]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3336810"}]}