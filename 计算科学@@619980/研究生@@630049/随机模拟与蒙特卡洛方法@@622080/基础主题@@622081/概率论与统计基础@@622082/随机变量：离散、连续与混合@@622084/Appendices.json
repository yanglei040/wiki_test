{"hands_on_practices": [{"introduction": "在构建复杂的模拟算法之前，我们必须首先理解为何那些看似简单的、朴素的方法会失败。第一个练习将挑战你分析在模拟混合随机变量时一个常见的错误：忽略其离散部分。通过精确计算这种错误方法所引入的偏差，你将更深刻地体会到混合分布的独特结构，并理解为何必须采用能够同时处理离散原子和连续部分的正确抽样技术。[@problem_id:3333837]", "problem": "考虑一个在 $[0,\\infty)$ 上的混合随机变量 $X$，其定义为其概率测度可分解为一个离散原子和一个绝对连续部分。该原子位于 $x=0$ 处，质量为 $\\alpha \\in (0,1)$，即 $\\mathbb{P}(X=0)=\\alpha$。在 $X>0$ 的条件下，其连续部分服从速率为 $\\lambda>0$ 的指数分布，因此在 $(0,\\infty)$ 上的密度为 $f(x)=(1-\\alpha)\\lambda \\exp(-\\lambda x)$。因此，累积分布函数 $F$ 满足 $F(0)=\\alpha$，并且对于 $x>0$，有 $F(x)=\\alpha+(1-\\alpha)(1-\\exp(-\\lambda x))$。\n\n你的任务是使用蒙特卡洛模拟来估计量 $\\theta=\\mathbb{E}[\\exp(-\\beta X)]$，其中 $\\beta>0$ 是一个固定的常数。一位实践者未意识到在跳跃点需要进行显式随机化，他实现了一个忽略该原子的朴素逆变换采样方案：他通过将绝对连续部分归一化使其总质量为1，构建了一个连续的代理累积分布函数，即对于 $x\\geq 0$，$F_{\\mathrm{cont}}(x)=(1-\\alpha)^{-1}(F(x)-\\alpha)=1-\\exp(-\\lambda x)$，然后通过 $X_{\\mathrm{naive}}=F_{\\mathrm{cont}}^{-1}(U)$（其中 $U\\sim \\mathrm{Uniform}(0,1)$）生成样本。换句话说，这个朴素的模拟器从速率为 $\\lambda$ 的纯指数分布中采样 $X_{\\mathrm{naive}}$，并省略了本应以概率 $\\alpha$ 选取 $x=0$ 处原子的随机化步骤。\n\n请仅从混合随机变量、其累积分布函数以及期望作为关于概率测度的积分的定义出发，推导当样本数量趋于无穷大时，所得蒙特卡洛估计量的确切偏差。也就是说，推导出下式的闭式表达式：\n$$\n\\mathrm{Bias}=\\lim_{n\\to\\infty}\\left(\\mathbb{E}\\left[\\frac{1}{n}\\sum_{i=1}^{n}\\exp(-\\beta X_{\\mathrm{naive},i})\\right]-\\theta\\right),\n$$\n其中 $X_{\\mathrm{naive},i}$ 是来自上述朴素逆变换方案的独立同分布抽样。将你的最终答案表示为以 $\\alpha$、$\\lambda$ 和 $\\beta$ 表示的单个闭式解析表达式。无需四舍五入。", "solution": "首先验证问题，以确保其具有科学依据、是良定的且客观的。\n\n**步骤1：提取已知条件**\n- 一个混合随机变量 $X$ 定义在支撑集 $[0, \\infty)$ 上。\n- 其概率测度在 $x=0$ 处有一个离散原子，质量为 $\\mathbb{P}(X=0)=\\alpha$，其中 $\\alpha \\in (0,1)$。\n- 其绝对连续部分定义在 $(0, \\infty)$ 上，概率密度为 $f(x)=(1-\\alpha)\\lambda \\exp(-\\lambda x)$，其中 $\\lambda>0$。这对应于变量 $X$ 在 $X>0$ 条件下的密度为 $\\lambda \\exp(-\\lambda x)$。\n- 累积分布函数（CDF）在 $x=0$ 时为 $F(x) = \\alpha$，在 $x>0$ 时为 $F(x)=\\alpha+(1-\\alpha)(1-\\exp(-\\lambda x))$。\n- 待估计的量为 $\\theta=\\mathbb{E}[\\exp(-\\beta X)]$，其中 $\\beta>0$ 为一固定常数。\n- 一个朴素的蒙特卡洛采样方案从速率为 $\\lambda$ 的纯指数分布中生成样本 $X_{\\mathrm{naive}}$。问题陈述这是通过 $X_{\\mathrm{naive}}=F_{\\mathrm{cont}}^{-1}(U)$ 完成的，其中 $U\\sim \\mathrm{Uniform}(0,1)$ 且 $F_{\\mathrm{cont}}(x)=1-\\exp(-\\lambda x)$。\n- 任务是推导蒙特卡洛估计量的渐近偏差：\n$$\n\\mathrm{Bias}=\\lim_{n\\to\\infty}\\left(\\mathbb{E}\\left[\\frac{1}{n}\\sum_{i=1}^{n}\\exp(-\\beta X_{\\mathrm{naive},i})\\right]-\\theta\\right)\n$$\n其中 $X_{\\mathrm{naive},i}$ 是独立同分布（i.i.d.）的抽样。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：问题基于概率论的既定原理，特别是关于混合随机变量、期望和蒙特卡洛模拟的原理。CDF、概率密度、原子和逆变换采样的概念都是标准的。\n- **良定性**：问题是良定的。它要求一个确定的、可计算的量（渐近偏差），基于明确定义的分布和参数。参数 $\\alpha$、$\\lambda$ 和 $\\beta$ 受到约束，确保所要求的期望是有限且良定的。\n- **客观性**：语言精确、数学化，不含主观内容。\n- **一致性与完整性**：提供的信息是自洽的。CDF $F(x)$ 正确地结合了 $x=0$ 处的点质量与在 $(0, \\infty)$ 上的给定密度的积分：$\\mathbb{P}(X \\le x) = \\mathbb{P}(X=0) + \\int_0^x (1-\\alpha)\\lambda \\exp(-\\lambda t) dt = \\alpha + (1-\\alpha)[-\\exp(-\\lambda t)]_0^x = \\alpha + (1-\\alpha)(1-\\exp(-\\lambda x))$，这与提供的 $F(x)$ 相匹配。所有必要信息都已给出。\n\n**步骤3：结论与行动**\n问题有效。现在开始求解过程。\n\n估计量 $\\hat{\\theta}_n = \\frac{1}{n}\\sum_{i=1}^{n} g(X_i)$ 对于参数 $\\theta = \\mathbb{E}[g(X)]$ 的偏差定义为 $\\mathbb{E}[\\hat{\\theta}_n] - \\theta$。在本题中，估计量是使用样本 $X_{\\mathrm{naive},i}$ 而非正确的样本 $X_i$ 构建的。需要计算的量是渐近偏差。\n\n首先，我们简化偏差的表达式。估计量为 $\\hat{\\theta}_{\\mathrm{naive}, n} = \\frac{1}{n}\\sum_{i=1}^{n}\\exp(-\\beta X_{\\mathrm{naive},i})$。根据期望的线性性质以及样本 $X_{\\mathrm{naive},i}$ 是独立同分布的，其期望为：\n$$\n\\mathbb{E}\\left[\\hat{\\theta}_{\\mathrm{naive}, n}\\right] = \\mathbb{E}\\left[\\frac{1}{n}\\sum_{i=1}^{n}\\exp(-\\beta X_{\\mathrm{naive},i})\\right] = \\frac{1}{n}\\sum_{i=1}^{n}\\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive},i})] = \\frac{1}{n} \\cdot n \\cdot \\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] = \\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})]\n$$\n这个期望不依赖于样本大小 $n$。因此，偏差相对于 $n$ 是一个常数。因此，问题中偏差定义里的极限就是偏差本身：\n$$\n\\mathrm{Bias} = \\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] - \\theta = \\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] - \\mathbb{E}[\\exp(-\\beta X)]\n$$\n问题简化为计算两个期望并求它们的差。\n\n**1. 计算真实期望值，$\\theta = \\mathbb{E}[\\exp(-\\beta X)]$**\n\n对于混合随机变量 $X$，其函数 $g(X)$ 的期望是通过对概率测度 $dP_X(x)$ 积分 $g(x)$ 来计算的。该测度由一个离散部分（一个点质量）和一个连续部分组成。\n$$\n\\theta = \\mathbb{E}[\\exp(-\\beta X)] = \\int_{[0,\\infty)} \\exp(-\\beta x) \\, dP_X(x)\n$$\n这个积分可以分解为来自 $x=0$ 处原子的贡献与在 $(0,\\infty)$ 上对连续部分的积分之和：\n$$\n\\theta = \\exp(-\\beta \\cdot 0) \\cdot \\mathbb{P}(X=0) + \\int_0^{\\infty} \\exp(-\\beta x) f(x) \\, dx\n$$\n使用给定的值 $\\mathbb{P}(X=0)=\\alpha$ 和 $f(x)=(1-\\alpha)\\lambda \\exp(-\\lambda x)$（对于 $x>0$）：\n$$\n\\theta = \\exp(0) \\cdot \\alpha + \\int_0^{\\infty} \\exp(-\\beta x) (1-\\alpha)\\lambda \\exp(-\\lambda x) \\, dx\n$$\n$$\n\\theta = 1 \\cdot \\alpha + (1-\\alpha)\\lambda \\int_0^{\\infty} \\exp(-(\\lambda+\\beta)x) \\, dx\n$$\n该积分计算如下：\n$$\n\\int_0^{\\infty} \\exp(-(\\lambda+\\beta)x) \\, dx = \\left[ \\frac{\\exp(-(\\lambda+\\beta)x)}{-(\\lambda+\\beta)} \\right]_0^{\\infty} = 0 - \\frac{1}{-(\\lambda+\\beta)} = \\frac{1}{\\lambda+\\beta}\n$$\n由于 $\\lambda>0$ 和 $\\beta>0$，这意味着 $\\lambda+\\beta>0$，因此积分收敛。\n将此结果代回 $\\theta$ 的表达式中：\n$$\n\\theta = \\alpha + (1-\\alpha) \\lambda \\frac{1}{\\lambda+\\beta} = \\alpha + (1-\\alpha) \\frac{\\lambda}{\\lambda+\\beta}\n$$\n\n**2. 计算朴素期望值，$\\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})]$**\n\n问题陈述 $X_{\\mathrm{naive}}$ 是从速率为 $\\lambda$ 的纯指数分布中抽样的。这与应用于 $F_{\\mathrm{cont}}(x) = 1-\\exp(-\\lambda x)$ 的逆变换方法一致。$X_{\\mathrm{naive}}$ 的概率密度函数为 $f_{\\mathrm{naive}}(x) = \\lambda \\exp(-\\lambda x)$，其中 $x \\ge 0$。\n期望计算如下：\n$$\n\\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] = \\int_0^{\\infty} \\exp(-\\beta x) f_{\\mathrm{naive}}(x) \\, dx = \\int_0^{\\infty} \\exp(-\\beta x) \\lambda \\exp(-\\lambda x) \\, dx\n$$\n$$\n\\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] = \\lambda \\int_0^{\\infty} \\exp(-(\\lambda+\\beta)x) \\, dx\n$$\n这与之前遇到的积分形式相同，只是乘以了 $\\lambda$：\n$$\n\\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] = \\lambda \\left( \\frac{1}{\\lambda+\\beta} \\right) = \\frac{\\lambda}{\\lambda+\\beta}\n$$\n这个结果也可以看作是速率为 $\\lambda$ 的指数分布的矩生成函数 $M(t)=\\frac{\\lambda}{\\lambda-t}$ 在 $t=-\\beta$ 处的值。\n\n**3. 计算偏差**\n\n最后，我们用朴素计算的期望减去真实期望 $\\theta$ 来计算偏差。\n$$\n\\mathrm{Bias} = \\mathbb{E}[\\exp(-\\beta X_{\\mathrm{naive}})] - \\theta = \\frac{\\lambda}{\\lambda+\\beta} - \\left( \\alpha + (1-\\alpha) \\frac{\\lambda}{\\lambda+\\beta} \\right)\n$$\n分配负号：\n$$\n\\mathrm{Bias} = \\frac{\\lambda}{\\lambda+\\beta} - \\alpha - (1-\\alpha) \\frac{\\lambda}{\\lambda+\\beta}\n$$\n将包含分数的项组合在一起：\n$$\n\\mathrm{Bias} = \\left(1 - (1-\\alpha)\\right) \\frac{\\lambda}{\\lambda+\\beta} - \\alpha\n$$\n$$\n\\mathrm{Bias} = (1 - 1 + \\alpha) \\frac{\\lambda}{\\lambda+\\beta} - \\alpha\n$$\n$$\n\\mathrm{Bias} = \\alpha \\frac{\\lambda}{\\lambda+\\beta} - \\alpha\n$$\n提出公因式 $\\alpha$：\n$$\n\\mathrm{Bias} = \\alpha \\left( \\frac{\\lambda}{\\lambda+\\beta} - 1 \\right)\n$$\n将括号内的项通分：\n$$\n\\mathrm{Bias} = \\alpha \\left( \\frac{\\lambda - (\\lambda+\\beta)}{\\lambda+\\beta} \\right) = \\alpha \\left( \\frac{\\lambda - \\lambda - \\beta}{\\lambda+\\beta} \\right) = \\alpha \\left( \\frac{-\\beta}{\\lambda+\\beta} \\right)\n$$\n因此，偏差的最终表达式为：\n$$\n\\mathrm{Bias} = -\\frac{\\alpha\\beta}{\\lambda+\\beta}\n$$\n偏差为负，这符合预期。朴素采样器忽略了 $x=0$ 处的原子，而函数 $g(x)=\\exp(-\\beta x)$ 在此点达到其最大值 $g(0)=1$。由于仅从 $x>0$ 且 $g(x)<1$ 的连续部分进行采样，朴素估计量会系统性地低估真实均值。", "answer": "$$\n\\boxed{-\\frac{\\alpha\\beta}{\\lambda+\\beta}}\n$$", "id": "3333837"}, {"introduction": "现在我们理解了朴素方法的陷阱，接下来让我们构建一个更高效的估计器。本练习将指导你构造一个分层蒙特卡洛估计器，该技术天然适用于混合随机变量，因为其离散原子和连续部分构成了清晰的层。你将从第一性原理出发推导最优样本分配规则——并揭示一个关于零方差分层的重要洞见——然后通过代码实现这个优化后的估计器，将理论转化为一个实用的、能有效降低方差的工具。[@problem_id:3333855]", "problem": "请使用基本定义和原理，为混合随机变量构建并分析一个分层蒙特卡洛估计器。设$X$是一个混合随机变量，在$0$处有一个离散原子，并在$(0,\\infty)$上有一个连续部分。具体来说，假设$\\mathbb{P}(X=0)=p$，并且在$X>0$的条件下，$X$的条件分布在$(0,\\infty)$上具有概率密度函数$g$；等价地，$X$具有一个混合分布，在$0$处有质量$p$，在$(0,\\infty)$上有密度$(1-p)g(x)$。给定一个可测函数$h:(0,\\infty)\\to\\mathbb{R}$，并已定义$h(0)$，你的任务是通过在集合$\\{X=0\\}$和$\\{X>0\\}$上进行分层，为$\\mathbb{E}[h(X)]$推导一个分层估计器，并在成本约束下优化各层之间的样本分配，以最小化方差。\n\n请基于以下基本定义和经过充分检验的事实进行推导：\n- 全期望定律：$\\mathbb{E}[h(X)] = \\mathbb{E}[h(X)\\mid X=0]\\mathbb{P}(X=0) + \\mathbb{E}[h(X)\\mid X>0]\\mathbb{P}(X>0)$。\n- 对于一个在各层内使用独立样本的分层估计器，其在$\\{X=0\\}$的样本分配数为$n_0$，在$\\{X>0\\}$的样本分配数为$n_1$，层权重为$w_0=\\mathbb{P}(X=0)$和$w_1=\\mathbb{P}(X>0)$，则无偏估计器为$\\widehat{\\mu} = w_0 \\widehat{\\mu}_0 + w_1 \\widehat{\\mu}_1$，其中$\\widehat{\\mu}_i$是$h(X)$在第$i\\in\\{0,1\\}$层内的样本均值。\n- 在独立性假设下，分层估计器的方差为$\\mathrm{Var}(\\widehat{\\mu}) = \\sum_{i\\in\\{0,1\\}} \\frac{w_i^2 \\sigma_i^2}{n_i}$，其中$\\sigma_i^2$是$h(X)$的层内方差。\n- 一个固定的计算预算由线性成本约束$\\sum_{i\\in\\{0,1\\}} c_i n_i \\le B$建模，其中$c_0$和$c_1$是已知的正单位样本成本，B是固定的预算（解释为总允许成本）。\n\n你的任务：\n- 对于给定的$p$、$g$和可测函数$h$，从第一性原理出发，推导出在预算约束$\\sum_{i\\in\\{0,1\\}} c_i n_i \\le B$下最小化$\\mathrm{Var}(\\widehat{\\mu})$的最优分配法则$(n_0^\\star,n_1^\\star)$。\n- 将你的推导具体化到给定的混合结构中（其中$\\{X=0\\}$是一个原子），并清楚地说明在这种情况下最优分配会发生什么变化。\n- 构建一个使用所推导的最优分配的可实现的分层估计器。如果在最优分配下某个层不需要抽样，请解释原因以及你的估计器在这种情况下如何简化。\n- 实现该估计器，并为下面的每个测试用例计算其值。每个测试用例使用一个固定的伪随机数生成器种子$s$，以使输出具有确定性。通过为从0开始的测试用例索引$k$使用种子$s+k$，确保测试用例之间使用独立的流。\n\n测试套件（每个用例指定$p$、连续部分$g$、函数$h$、预算$B$（无单位成本）以及单位样本成本$c_0,c_1$）：\n- 用例1：$p=\\frac{1}{3}$，$g$是速率为$\\lambda=2$的指数分布（在$(0,\\infty)$上的密度为$g(x)=2 e^{-2x}$），$h(x)=x + \\mathbf{1}\\{x>1\\}$，预算$B=1000$，成本$c_0=1, c_1=1$，种子$s=12345$。\n- 用例2：$p=0.99$，$g$是形状为$k=3$、尺度为$\\theta=1$的伽马分布（在$(0,\\infty)$上的密度为$g(x)=\\frac{x^{k-1}e^{-x/\\theta}}{\\Gamma(k)\\theta^k}$），$h(x)=x^2$，预算$B=200$，成本$c_0=1, c_1=1$，种子$s=12345$。\n- 用例3：$p=0.05$，$g$是参数为$\\mu=0$和$\\sigma=1$的对数正态分布（即对于$Y\\sim g$，有$\\log Y\\sim \\mathcal{N}(0,1)$），$h(x)=\\mathbf{1}\\{x>2\\}$，预算$B=500$，成本$c_0=1, c_1=1$，种子$s=12345$。\n- 用例4：$p=1$，$g$是速率为$\\lambda=1$的指数分布（在$(0,\\infty)$上的密度为$g(x)=e^{-x}$），$h(x)=\\sqrt{x+1}-1$，预算$B=50$，成本$c_0=1, c_1=1$，种子$s=12345$。\n\n对于每个用例，除了计算使用最优分配的分层估计器值外，还需使用从定义中推导出的解析公式（如果可用）计算$\\mathbb{E}[h(X)]$的精确值：\n- 对于速率为$\\lambda$的指数分布，$\\mathbb{E}[Y]=\\frac{1}{\\lambda}$且对于$t>0$，$\\mathbb{P}(Y>t)=e^{-\\lambda t}$。\n- 对于形状为$k$、尺度为$\\theta$的伽马分布，$\\mathbb{E}[Y^2]=\\theta^2 k(1+k)$。\n- 对于参数为$\\mu$和$\\sigma$的对数正态分布，对于$t>0$，$\\mathbb{P}(Y>t)=1-\\Phi\\left(\\frac{\\ln t - \\mu}{\\sigma}\\right)$，其中$\\Phi$是标准正态分布的累积分布函数。\n\n你的程序必须：\n- 根据你的推导实现最优分配计算和分层估计器。\n- 对于每个测试用例，输出最优层样本数$(n_0^\\star,n_1^\\star)$（整数）、分层估计器值（浮点数）和根据给定解析公式计算的精确值（浮点数）。\n- 使用指定的种子使模拟结果具有确定性。\n- 确保满足预算约束$\\sum_{i\\in\\{0,1\\}} c_i n_i \\le B$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。对于顺序为1,2,3,4的每个用例，依次追加四个条目：$n_0^\\star$, $n_1^\\star$, 分层估计器值, 和精确值。例如，包含两个用例的输出应类似于$[n_{0,1}^\\star,n_{1,1}^\\star,\\widehat{\\mu}_1,\\mu_1,n_{0,2}^\\star,n_{1,2}^\\star,\\widehat{\\mu}_2,\\mu_2]$；请为所有四个用例扩展此模式。", "solution": "该问题要求推导并实现一个用于混合随机变量的分层蒙特卡洛估计器。解决方案分两个阶段进行：首先，对最优样本分配及由此产生的估计器进行形式化推导；其次，将此框架应用于所提供的具体测试用例。\n\n### 基于原理的推导与设计\n\n设$X$为一个混合随机变量，其分布为$\\mathbb{P}(X=0)=p$，当$X>0$时，其条件概率密度函数为$g(x)$，定义在$(0, \\infty)$上。我们的任务是为给定的函数$h$估计$\\mathbb{E}[h(X)]$。\n\n问题指定将样本空间分层为两个层：$S_0 = \\{x | x=0\\}$ 和 $S_1 = \\{x | x>0\\}$。相应的层权重是这些事件的概率：\n$w_0 = \\mathbb{P}(X \\in S_0) = \\mathbb{P}(X=0) = p$\n$w_1 = \\mathbb{P}(X \\in S_1) = \\mathbb{P}(X>0) = 1-p$\n\n全期望定律给出了我们希望估计的精确值：\n$$\n\\mathbb{E}[h(X)] = \\mathbb{E}[h(X) | X \\in S_0] w_0 + \\mathbb{E}[h(X) | X \\in S_1] w_1\n$$\n令$\\mu_i = \\mathbb{E}[h(X) | X \\in S_i]$为$h(X)$在第$i$层中的条件均值。则$\\mathbb{E}[h(X)] = \\mu_0 w_0 + \\mu_1 w_1$。\n\n$\\mathbb{E}[h(X)]$的分层蒙特卡洛估计器由$\\widehat{\\mu} = w_0 \\widehat{\\mu}_0 + w_1 \\widehat{\\mu}_1$给出，其中$\\widehat{\\mu}_i$是基于从第$i$层抽取的$n_i$个样本计算出的$h(X)$的样本均值。假设样本独立，此估计器的方差为：\n$$\n\\mathrm{Var}(\\widehat{\\mu}) = \\frac{w_0^2 \\sigma_0^2}{n_0} + \\frac{w_1^2 \\sigma_1^2}{n_1}\n$$\n其中$\\sigma_i^2 = \\mathrm{Var}(h(X) | X \\in S_i)$是$h(X)$在第$i$层内的方差。\n\n**1. 最优样本分配**\n\n我们的目标是在线性预算约束$\\sum_{i=0,1} c_i n_i \\le B$下最小化此方差，其中$c_i > 0$是第$i$层中每个样本的成本，$B$是总预算。为最小化方差，我们应使用全部预算，因此约束变为等式：$c_0 n_0 + c_1 n_1 = B$。\n\n这是一个约束优化问题，可以使用拉格朗日乘子法解决。拉格朗日函数为：\n$$\nL(n_0, n_1, \\lambda) = \\left( \\frac{w_0^2 \\sigma_0^2}{n_0} + \\frac{w_1^2 \\sigma_1^2}{n_1} \\right) + \\lambda(c_0 n_0 + c_1 n_1 - B)\n$$\n将关于$n_0$和$n_1$的偏导数设为零，得到：\n$$\n\\frac{\\partial L}{\\partial n_i} = -\\frac{w_i^2 \\sigma_i^2}{n_i^2} + \\lambda c_i = 0 \\implies n_i^2 = \\frac{w_i^2 \\sigma_i^2}{\\lambda c_i} \\implies n_i = \\frac{w_i \\sigma_i}{\\sqrt{\\lambda c_i}}\n$$\n这意味着最优分配$n_i^\\star$与$w_i \\sigma_i / \\sqrt{c_i}$成正比。为求出比例常数，我们将其代入预算约束中：\n$$\n\\sum_{i=0,1} c_i \\left( \\frac{w_i \\sigma_i}{\\sqrt{\\lambda c_i}} \\right) = B \\implies \\frac{1}{\\sqrt{\\lambda}} \\sum_{i=0,1} w_i \\sigma_i \\sqrt{c_i} = B \\implies \\frac{1}{\\sqrt{\\lambda}} = \\frac{B}{\\sum_{j=0,1} w_j \\sigma_j \\sqrt{c_j}}\n$$\n将此结果代回$n_i$的表达式，得到最优分配（对于实数值$n_i$）：\n$$\nn_i^\\star = B \\frac{w_i \\sigma_i / \\sqrt{c_i}}{\\sum_{j=0,1} w_j \\sigma_j \\sqrt{c_j}}\n$$\n\n**2. 混合分布的特化**\n\n现在我们将此通用结果应用于我们的特定分层。\n- **层 $S_0 = \\{X=0\\}$：** 从该层抽取的样本总是$X=0$。因此，$h(X)$的值总是常数$h(0)$。常数的方差为零。因此，层内方差$\\sigma_0^2$为：\n    $$\n    \\sigma_0^2 = \\mathrm{Var}(h(X) | X=0) = 0\n    $$\n- **层 $S_1 = \\{X>0\\}$：** 从该层抽取的样本遵循密度为$g(x)$的分布。方差$\\sigma_1^2$是$h(Y)$的方差，其中$Y \\sim g$，即$\\sigma_1^2 = \\mathrm{Var}(h(Y))$。\n\n$\\sigma_0 = 0$这一事实极大地简化了最优分配。将$\\sigma_0=0$代入分配公式：\n$$\nn_0^\\star = B \\frac{w_0 (0) / \\sqrt{c_0}}{w_0 (0) \\sqrt{c_0} + w_1 \\sigma_1 \\sqrt{c_1}} = 0\n$$\n$$\nn_1^\\star = B \\frac{w_1 \\sigma_1 / \\sqrt{c_1}}{w_0 (0) \\sqrt{c_0} + w_1 \\sigma_1 \\sqrt{c_1}} = B \\frac{w_1 \\sigma_1 / \\sqrt{c_1}}{w_1 \\sigma_1 \\sqrt{c_1}} = \\frac{B}{c_1}\n$$\n此推导在$w_1 \\sigma_1 > 0$时成立，即$p<1$且$h(X)$在$(0, \\infty)$上不为常数。由于样本量必须是整数，我们向下取整以确保满足预算约束：\n$$\nn_0^\\star = 0 \\quad \\text{和} \\quad n_1^\\star = \\left\\lfloor \\frac{B}{c_1} \\right\\rfloor\n$$\n这个结果是直观的：由于层$S_0$中的结果是确定性的，因此没有不确定性需要减少。所有的模拟预算都应分配给层$S_1$，因为它是唯一的方差来源。\n\n**3. 最终的估计器**\n\n在最优分配$n_0^\\star=0$的情况下，我们不对层$S_0$进行任何抽样。我们不使用样本均值$\\widehat{\\mu}_0$，而是使用精确的条件期望$\\mu_0 = \\mathbb{E}[h(X)|X=0] = h(0)$。对于层$S_1$，我们从密度$g(x)$生成$n_1^\\star$个样本$Y_1, \\dots, Y_{n_1^\\star}$，并计算样本均值$\\widehat{\\mu}_1 = \\frac{1}{n_1^\\star} \\sum_{j=1}^{n_1^\\star} h(Y_j)$。\n\n最终的分层估计器是：\n$$\n\\widehat{\\mu} = w_0 \\mu_0 + w_1 \\widehat{\\mu}_1 = p \\cdot h(0) + (1-p) \\frac{1}{n_1^\\star} \\sum_{j=1}^{n_1^\\star} h(Y_j)\n$$\n\n**4. 边界情况：$p=1$**\n\n如果$p=1$，随机变量$X$确定性地为$0$。因此，$\\mathbb{E}[h(X)] = h(0)$是精确值。不需要进行估计。在这种情况下，$w_0=1$，$w_1=0$。分层估计器的方差为$\\mathrm{Var}(\\widehat{\\mu}) = \\frac{1^2 \\cdot 0^2}{n_0} + \\frac{0^2 \\cdot \\sigma_1^2}{n_1} = 0$，对于任何非零的$n_0, n_1$都成立。由于在没有任何抽样的情况下方差已经是零，最小化方差（和成本）的最优分配是$n_0^\\star = 0$和$n_1^\\star = 0$。估计器的值就是精确值$h(0)$。\n\n**5. 精确值的解析计算**\n\n对于每个测试用例，精确值是$\\mu = \\mathbb{E}[h(X)] = p \\cdot h(0) + (1-p) \\mathbb{E}[h(Y)]$，其中$Y \\sim g$。$h(0)$和$\\mathbb{E}[h(Y)]$的值计算如下：\n- **用例1：** $p=\\frac{1}{3}$，$Y \\sim \\text{Exp}(\\lambda=2)$，$h(x)=x + \\mathbf{1}\\{x>1\\}$。$h(0)=0$。$\\mathbb{E}[h(Y)] = \\mathbb{E}[Y] + \\mathbb{P}(Y>1) = \\frac{1}{\\lambda} + e^{-\\lambda} = \\frac{1}{2} + e^{-2}$。\n    $\\mu = (1-\\frac{1}{3})(\\frac{1}{2} + e^{-2}) = \\frac{1}{3} + \\frac{2}{3}e^{-2}$。\n- **用例2：** $p=0.99$，$Y \\sim \\text{Gamma}(k=3, \\theta=1)$，$h(x)=x^2$。$h(0)=0$。$\\mathbb{E}[h(Y)] = \\mathbb{E}[Y^2] = \\theta^2 k(k+1) = 1^2 \\cdot 3(4) = 12$。\n    $\\mu = (1-0.99)(12) = 0.12$。\n- **用例3：** $p=0.05$，$Y \\sim \\text{Lognormal}(\\mu_{ln}=0, \\sigma_{ln}=1)$，$h(x)=\\mathbf{1}\\{x>2\\}$。$h(0)=0$。$\\mathbb{E}[h(Y)] = \\mathbb{P}(Y>2) = 1-\\Phi(\\frac{\\ln(2)-\\mu_{ln}}{\\sigma_{ln}}) = 1-\\Phi(\\ln 2)$，其中$\\Phi$是标准正态CDF。\n    $\\mu = (1-0.05)(1-\\Phi(\\ln 2))$。\n- **用例4：** $p=1$，$h(x)=\\sqrt{x+1}-1$。$h(0)=0$。分布是在0处的一个点质量。\n    $\\mu = \\mathbb{E}[h(X)] = h(0) = 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes stratified Monte Carlo estimates for a mixed random variable\n    based on optimal allocation derived from first principles.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'p': 1/3,\n            'g': {'type': 'exponential', 'lambda': 2},\n            'h': lambda x: x + (x > 1).astype(float),\n            'B': 1000, 'c0': 1, 'c1': 1, 's': 12345\n        },\n        {\n            'p': 0.99,\n            'g': {'type': 'gamma', 'k': 3, 'theta': 1},\n            'h': lambda x: x**2,\n            'B': 200, 'c0': 1, 'c1': 1, 's': 12345\n        },\n        {\n            'p': 0.05,\n            'g': {'type': 'lognormal', 'mu': 0, 'sigma': 1},\n            'h': lambda x: (x > 2).astype(float),\n            'B': 500, 'c0': 1, 'c1': 1, 's': 12345\n        },\n        {\n            'p': 1,\n            'g': {'type': 'exponential', 'lambda': 1},\n            'h': lambda x: np.sqrt(x + 1) - 1,\n            'B': 50, 'c0': 1, 'c1': 1, 's': 12345\n        }\n    ]\n\n    results = []\n    \n    for k, case in enumerate(test_cases):\n        p = case['p']\n        g_params = case['g']\n        h = case['h']\n        B, c0, c1 = case['B'], case['c0'], case['c1']\n        seed = case['s']\n\n        # h(0) is needed for both estimator and exact value.\n        h_at_0 = h(np.array([0.0]))[0]\n        \n        # --- Optimal Allocation and Estimation ---\n        n0_star, n1_star = 0, 0\n        estimator_val = h_at_0  # Default for p=1\n\n        # The optimal allocation is n0=0, n1=floor(B/c1) unless p=1.\n        if p == 1:\n            # If p=1, X=0 deterministically. No sampling needed.\n            n0_star = 0\n            n1_star = 0\n            estimator_val = h_at_0\n        else:\n            # Allocate entire budget to stratum 1 (the continuous part).\n            n0_star = 0\n            n1_star = int(np.floor(B / c1))\n\n            if n1_star > 0:\n                rng = np.random.default_rng(seed + k)\n                samples_g = np.array([])\n                \n                if g_params['type'] == 'exponential':\n                    # scale = 1/lambda\n                    samples_g = rng.exponential(scale=1.0/g_params['lambda'], size=n1_star)\n                elif g_params['type'] == 'gamma':\n                    # shape=k, scale=theta\n                    samples_g = rng.gamma(shape=g_params['k'], scale=g_params['theta'], size=n1_star)\n                elif g_params['type'] == 'lognormal':\n                    # mean=mu, sigma=sigma\n                    samples_g = rng.lognormal(mean=g_params['mu'], sigma=g_params['sigma'], size=n1_star)\n                \n                h_samples = h(samples_g)\n                mu1_hat = np.mean(h_samples)\n                estimator_val = p * h_at_0 + (1 - p) * mu1_hat\n            else: # If budget is too small (n1_star = 0)\n                # No samples can be drawn, the estimator cannot be computed with sampling.\n                # In this problem setting, B/c1 >= 50, so n1_star > 0.\n                # If it were 0, the best one could do is use the known part.\n                estimator_val = p * h_at_0\n\n        # --- Analytic Calculation of Exact Value ---\n        exact_val = 0.0\n        \n        if g_params['type'] == 'exponential':\n            # E[h(Y)] for Y ~ Exp(lambda) and h(x) = x + 1_{x>1}\n            # E[Y] + P(Y>1) = 1/lambda + exp(-lambda)\n            lam = g_params['lambda']\n            E_hY = 1.0/lam + np.exp(-lam)\n        elif g_params['type'] == 'gamma':\n            # E[Y^2] for Y ~ Gamma(k, theta) = theta^2 * k * (k+1)\n            k_shape = g_params['k']\n            theta_scale = g_params['theta']\n            E_hY = (theta_scale**2) * k_shape * (k_shape + 1)\n        elif g_params['type'] == 'lognormal':\n            # E[1_{Y>2}] for Y ~ Lognormal(mu, sigma) = P(Y>2)\n            # P(Y>2) = 1 - Phi((ln(2)-mu)/sigma)\n            mu_ln = g_params['mu']\n            sigma_ln = g_params['sigma']\n            E_hY = 1.0 - norm.cdf((np.log(2) - mu_ln) / sigma_ln)\n\n        if p == 1:\n            exact_val = h_at_0\n        else:\n            exact_val = p * h_at_0 + (1 - p) * E_hY\n        \n        results.extend([n0_star, n1_star, estimator_val, exact_val])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.7f}' if isinstance(x, float) else str(x) for x in results)}]\")\n\nsolve()\n```", "id": "3333855"}, {"introduction": "为完善你的技能，最后一个练习聚焦于对模拟策略的量化分析与比较。你将应用奈曼分配（Neyman allocation）来设计一个最优分层估计器，并在理论层面将其方差与标准蒙特卡洛方法的方差进行比较，而无需实际运行模拟。这个练习将巩固你对分层抽样如何带来显著效率提升的理解（尤其是在涉及稀有事件的情境下），并让你有能力对模拟方案的设计做出明智的决策。[@problem_id:3333778]", "problem": "设 $X$ 是一个混合随机变量，具有两个互斥的层：一个原子层和一个连续层。原子层以概率 $\\theta \\in (0,1)$ 被选中，此时 $X$ 等于三个原子 $\\{a_1,a_2,a_3\\} = \\{0.1,0.5,0.9\\}$ 中的一个，其条件概率为 $\\pi = (\\pi_1,\\pi_2,\\pi_3) = (0.5,0.3,0.2)$。连续层以概率 $1-\\theta$ 被选中，此时 $X$ 服从支撑在区间 $[0,1]$ 上的贝塔分布 $\\mathrm{Beta}(2,5)$。考虑目标事件集 $A = \\{0.5,1.1\\} \\cup [0.6,0.8]$，该集合包含孤立点和一个区间。\n\n您的任务是通过对原子集和连续补集进行分层来构建概率 $\\mathbb{P}(X \\in A)$ 的估计量，并应用 Neyman 配置在等成本抽样预算下最小化分层估计量的方差。然后，在原子概率质量稀少的情况下，将分层估计量与普通蒙特卡罗（Monte Carlo (MC)）抽样进行比较。\n\n请在以下纯数学和算法的框架内进行。\n\n1. 定义指示随机变量 $Z = \\mathbf{1}\\{X \\in A\\}$。普通蒙特卡罗估计量使用从 $X$ 的完整混合分布中抽取的独立同分布样本。分层估计量将抽样在原子层和连续层之间进行划分，样本数量在单位样本成本相等的条件下使用 Neyman 配置进行分配。\n2. 对于下面的每个测试用例，计算：\n   - 使用混合结构和贝塔累积分布函数计算 $\\mathbb{P}(X \\in A)$ 的精确值。\n   - 使用大小为 $n$ 的独立样本的普通蒙特卡罗估计量的理论方差。\n   - 在总样本量同样为 $n$ 的情况下，根据 Neyman 配置的分层估计量的理论方差，其中分配是在原子层和连续层之间进行的。\n   - 方差比，定义为分层方差除以普通蒙特卡罗方差。\n   - 根据 Neyman 配置，在满足总预算的情况下，分配给原子层和连续层的整数样本数。\n\n基本原理：使用混合随机变量、条件概率、指示随机变量以及独立抽样下样本均值方差的定义。原子层仅包含位于 $\\{0.1,0.5,0.9\\}$ 的点质量，而连续层相对于勒贝格测度是绝对连续的。在单位样本成本相等的情况下，Neyman 配置可以在固定总样本量 $n$ 的条件下最小化分层估计量的方差。\n\n抽样预算和成本：假设各层的单位样本成本相等，总样本量固定为 $n = 10000$ 个样本。所有计算都是无单位的实数；将任何数值答案表示为实值小数。\n\n测试套件：评估原子概率质量 $\\theta$ 的以下四种参数体系：\n- 情况1：$\\theta = 0.0005$。\n- 情况2：$\\theta = 0.01$。\n- 情况3：$\\theta = 0.2$。\n- 情况4：$\\theta = 0.5$。\n\n答案规格：对于每个测试用例，按以下顺序生成一个包含六个条目的列表：\n- 精确概率 $\\mathbb{P}(X \\in A)$，作为浮点数。\n- 普通蒙特卡罗方差，作为浮点数。\n- Neyman 配置下的分层方variance，作为浮点数。\n- 方差比（分层方差除以普通蒙特卡罗方差），作为浮点数。\n- 分配给原子层的整数样本数。\n- 分配给连续层的整数样本数。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，其中每个元素是按上述顺序排列的一个测试用例的列表（例如，$[\\text{case1},\\text{case2},\\text{case3},\\text{case4}]$）。不应打印任何额外文本。", "solution": "该问题要求对普通蒙特卡罗（MC）抽样和分层抽样进行比较分析，以估计混合随机变量的事件概率。我们将首先建立该问题的数学框架，包括精确概率，然后推导普通MC估计量和分层估计量的方差。\n\n设 $X$ 为混合随机变量。样本空间被划分为两个层：一个原子层，由指示符 $S=1$ 表示；一个连续层，由 $S=2$ 表示。选中这些层的概率由 $\\mathbb{P}(S=1) = \\theta$ 和 $\\mathbb{P}(S=2) = 1-\\theta$ 给出。\n\n如果 $S=1$（原子层），$X$ 从集合 $\\{a_1, a_2, a_3\\} = \\{0.1, 0.5, 0.9\\}$ 中取一个值，条件概率为 $\\pi = (\\pi_1, \\pi_2, \\pi_3) = (0.5, 0.3, 0.2)$。\n\n如果 $S=2$（连续层），$X$ 服从贝塔分布，$X \\sim \\mathrm{Beta}(\\alpha, \\beta)$，参数为 $\\alpha=2$ 和 $\\beta=5$，支撑区间为 $[0,1]$。\n\n目标事件集为 $A = \\{0.5, 1.1\\} \\cup [0.6, 0.8]$。我们感兴趣的是估计 $p = \\mathbb{P}(X \\in A)$。待估计的量是指示随机变量 $Z = \\mathbf{1}\\{X \\in A\\}$ 的期望，即 $p = \\mathbb{E}[Z]$。\n\n**1. 精确概率 $\\mathbb{P}(X \\in A)$**\n\n根据全概率定律，精确概率 $p$ 由以下混合公式给出：\n$$p = \\mathbb{P}(X \\in A | S=1)\\mathbb{P}(S=1) + \\mathbb{P}(X \\in A | S=2)\\mathbb{P}(S=2)$$\n设 $p_1 = \\mathbb{P}(X \\in A | S=1)$ 和 $p_2 = \\mathbb{P}(X \\in A | S=2)$。各层的权重为 $W_1 = \\mathbb{P}(S=1) = \\theta$ 和 $W_2 = \\mathbb{P}(S=2) = 1-\\theta$。则概率为 $p = W_1 p_1 + W_2 p_2$。\n\n首先，我们计算层内概率 $p_1$。在原子层中，$X$ 可以是 $0.1$、$0.5$ 或 $0.9$。我们检查这些值中有哪些位于集合 $A = \\{0.5, 1.1\\} \\cup [0.6, 0.8]$ 中。\n- $X=0.1$：$0.1 \\notin A$。\n- $X=0.5$：$0.5 \\in A$。\n- $X=0.9$：$0.9 \\notin A$。\n因此，事件 $X \\in A$ 仅在 $X=0.5$ 时发生。其条件概率为 $\\pi_2$。\n$$p_1 = \\mathbb{P}(X=0.5 | S=1) = \\pi_2 = 0.3$$\n\n接下来，我们计算层内概率 $p_2$。在连续层中，$X \\sim \\mathrm{Beta}(2,5)$。对于连续随机变量，取任何单个值的概率为 $0$。因此，$\\mathbb{P}(X \\in \\{0.5, 1.1\\} | S=2) = 0$。概率 $p_2$ 完全由 $A$ 的区间部分决定。\n$$p_2 = \\mathbb{P}(X \\in [0.6, 0.8] | S=2)$$\n设 $F_{\\beta}(x; \\alpha, \\beta)$ 为贝塔分布的累积分布函数 (CDF)。则：\n$$p_2 = F_{\\beta}(0.8; 2, 5) - F_{\\beta}(0.6; 2, 5)$$\n通过计算评估，$p_2 \\approx 0.02677028$。\n\n总概率为 $p = \\theta(0.3) + (1-\\theta)p_2$。该值取决于测试用例参数 $\\theta$。\n\n**2. 普通蒙特卡罗估计量方差**\n\n$p$ 的普通MC估计量为 $\\hat{p}_{MC} = \\frac{1}{n} \\sum_{i=1}^n Z_i$，其中 $Z_i$ 是 $Z = \\mathbf{1}\\{X \\in A\\}$ 的独立同分布样本。由于 $Z$ 是参数为 $p$ 的伯努利随机变量，其方差为 $\\mathrm{Var}(Z) = p(1-p)$。估计量的方差为：\n$$\\mathrm{Var}(\\hat{p}_{MC}) = \\frac{\\mathrm{Var}(Z)}{n} = \\frac{p(1-p)}{n}$$\n对于每个 $\\theta$ 值，将使用相应的 $p$ 值计算此方差。总样本量给定为 $n=10000$。\n\n**3. 使用 Neyman 配置的分层估计量方差**\n\n$p$ 的分层估计量为 $\\hat{p}_{strat} = W_1 \\hat{p}_1 + W_2 \\hat{p}_2$，其中 $\\hat{p}_j$ 是层 $j$ 内指示变量的样本均值，基于从该层抽取的 $n_j$ 个样本。该估计量的方差为：\n$$\\mathrm{Var}(\\hat{p}_{strat}) = \\frac{W_1^2 \\sigma_1^2}{n_1} + \\frac{W_2^2 \\sigma_2^2}{n_2}$$\n其中 $n_1+n_2=n$，$\\sigma_j^2$ 是层 $j$ 内指示变量的方差。\n$$\\sigma_1^2 = \\mathrm{Var}(Z|S=1) = p_1(1-p_1) = 0.3(1-0.3) = 0.21$$\n$$\\sigma_2^2 = \\mathrm{Var}(Z|S=2) = p_2(1-p_2) \\approx 0.02677028 \\times (1 - 0.02677028) \\approx 0.02605301$$\n\n在固定总样本量 $n$ 和单位样本成本相等的情况下，Neyman 配置可以最小化 $\\mathrm{Var}(\\hat{p}_{strat})$。层 $j$ 的样本量 $n_j$ 按比例分配给 $W_j \\sigma_j$：\n$$n_j = n \\frac{W_j \\sigma_j}{\\sum_{k=1}^2 W_k \\sigma_k}$$\n其中 $\\sigma_j = \\sqrt{p_j(1-p_j)}$。对于我们的两个层：\n$$n_1 = n \\frac{W_1 \\sigma_1}{W_1 \\sigma_1 + W_2 \\sigma_2} \\quad \\text{and} \\quad n_2 = n \\frac{W_2 \\sigma_2}{W_1 \\sigma_1 + W_2 \\sigma_2}$$\n由于样本数必须是整数，我们计算理想的实值分配 $n_1^*$，并将其四舍五入到最接近的整数。剩余的样本分配给另一个层，以保持总预算 $n$ 不变。\n$$n_1 = \\text{round}(n_1^*) \\quad \\text{and} \\quad n_2 = n - n_1$$\n使用这些整数分配，分层估计量的方差使用通用方差公式计算：\n$$\\mathrm{Var}(\\hat{p}_{strat}) = \\frac{W_1^2 \\sigma_1^2}{n_1} + \\frac{W_2^2 \\sigma_2^2}{n_2}$$\n\n**4. 计算摘要和方差比**\n\n对于每个测试用例的 $\\theta$ 值，我们执行以下计算：\n1.  计算层权重 $W_1 = \\theta$ 和 $W_2 = 1-\\theta$。\n2.  计算精确概率 $p = W_1 p_1 + W_2 p_2$。\n3.  计算普通MC方差 $\\mathrm{Var}(\\hat{p}_{MC}) = p(1-p)/n$。\n4.  基于 $W_1, \\sigma_1, W_2, \\sigma_2$ 计算 Neyman 配置比例。\n5.  确定总预算为 $n=10000$ 的整数样本数 $n_1$ 和 $n_2$。\n6.  计算最终的分层方差 $\\mathrm{Var}(\\hat{p}_{strat})$。\n7.  计算方差比 $\\mathrm{Var}(\\hat{p}_{strat}) / \\mathrm{Var}(\\hat{p}_{MC})$。\n\n所需的常数是：\n- $n = 10000$\n- $p_1 = 0.3$\n- $\\sigma_1 = \\sqrt{0.3 \\times 0.7} = \\sqrt{0.21} \\approx 0.45825757$\n- $p_2 = F_{\\beta}(0.8; 2, 5) - F_{\\beta}(0.6; 2, 5) \\approx 0.02677028$\n- $\\sigma_2 = \\sqrt{p_2(1-p_2)} \\approx 0.16140944$\n\n在提供的测试套件中，为每个 $\\theta$ 值实施这些步骤。结果展示了 Neyman 配置如何调整抽样工作。当 $\\theta$ 很小时，原子层很稀有但方差较高（$\\sigma_1 > \\sigma_2$），因此其抽样强度会比其权重 $W_1$ 所建议的要高。随着 $\\theta$ 的增加，分配越来越能反映层的权重。在所有有效情况下，采用 Neyman 配置的分层抽样预计将产生小于或等于普通蒙特卡罗抽样的方差，从而导致方差比小于或等于 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Calculates exact probability, MC variance, stratified variance, variance ratio,\n    and sample allocations for a mixed random variable problem under four parameter regimes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0005, # Case 1\n        0.01,   # Case 2\n        0.2,    # Case 3\n        0.5,    # Case 4\n    ]\n\n    # --- Problem Constants ---\n    # Total sample size\n    n = 10000\n\n    # Atomic stratum properties\n    # Atoms: {0.1, 0.5, 0.9} with probs (0.5, 0.3, 0.2)\n    # Target set A = {0.5, 1.1} U [0.6, 0.8]\n    # Only atom 0.5 is in A.\n    p1 = 0.3  # P(X in A | atomic) = P(X=0.5)\n    sigma1_sq = p1 * (1 - p1)\n    sigma1 = np.sqrt(sigma1_sq)\n\n    # Continuous stratum properties\n    # X ~ Beta(2, 5) on [0, 1]\n    # Target set A = {0.5, 1.1} U [0.6, 0.8]\n    # For a continuous RV, P(X=x) = 0.\n    alpha, beta_param = 2, 5\n    p2 = beta.cdf(0.8, alpha, beta_param) - beta.cdf(0.6, alpha, beta_param) # P(X in [0.6, 0.8])\n    sigma2_sq = p2 * (1 - p2)\n    sigma2 = np.sqrt(sigma2_sq)\n    \n    results = []\n    for theta in test_cases:\n        # --- Calculations for the current test case (theta) ---\n\n        # Stratum weights\n        w1 = theta\n        w2 = 1 - theta\n\n        # 1. Exact probability P(X in A)\n        p_exact = w1 * p1 + w2 * p2\n\n        # 2. Plain Monte Carlo variance\n        var_mc = (p_exact * (1 - p_exact)) / n\n\n        # 3. Neyman allocation\n        # Denominator for allocation formula\n        alloc_denom = w1 * sigma1 + w2 * sigma2\n        \n        # Ideal (real-valued) allocation for stratum 1\n        n1_ideal = n * (w1 * sigma1) / alloc_denom\n        \n        # 5. Integer sample counts\n        # Round n1 and derive n2 to respect the total budget\n        n1_alloc = int(np.round(n1_ideal))\n        n2_alloc = n - n1_alloc\n\n        # Handle edge cases where rounding might lead to a zero allocation, although\n        # not expected for the given parameters.\n        if n1_alloc == 0: n1_alloc = 1; n2_alloc = n - 1\n        if n2_alloc == 0: n2_alloc = 1; n1_alloc = n - 1\n\n        # 4. Stratified variance under Neyman allocation\n        # Calculated using the actual integer allocations\n        var_strat = (w1**2 * sigma1_sq / n1_alloc) + (w2**2 * sigma2_sq / n2_alloc)\n        \n        # 5. Variance ratio\n        variance_ratio = var_strat / var_mc\n        \n        # Compile results for the case\n        case_results = [\n            p_exact,\n            var_mc,\n            var_strat,\n            variance_ratio,\n            n1_alloc,\n            n2_alloc,\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format [list1, list2, ...] is produced by str() on a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3333778"}]}