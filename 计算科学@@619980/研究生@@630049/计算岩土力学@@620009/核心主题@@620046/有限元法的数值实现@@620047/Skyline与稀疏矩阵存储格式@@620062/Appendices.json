{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式就是动手计算。本练习旨在通过一个具体的例子，让你亲手计算和体会“天际线存储”方案相较于传统存储方式的优势。通过这个练习 ([@problem_id:3559724])，你将深入理解天际线高度的定义，并量化其在节约内存方面的效率。", "problem": "一个线性、各向同性、小应变的三维弹性问题在结构化网格上使用有限元（FE）方法进行离散化，得到一个全局刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$。由于弹性势能双线性形式的对称性，$K$ 是对称正定（SPD）的。在天际线存储格式中，假定每列 $j$ 中的非零结构从该列的对角线元素开始，一直连续到该列的第一个非零元素。根据定义，设天际线高度 $h_j$ 表示在列 $j$ 的下三角部分（包括对角线元素）中存储的条目数量。\n\n对于 $n=12$，一个特定的排序产生如下的天际线高度：$\\{h_j\\}_{j=1}^{12} = \\{1,\\,2,\\,4,\\,5,\\,6,\\,6,\\,5,\\,5,\\,4,\\,3,\\,2,\\,1\\}$。请仅利用 $K$ 的对称性和天际线存储的定义，推导出在天际线存储格式下存储的浮点条目的确切总数，并将其与存储 $K$ 的整个下三角所需的条目数量进行对比。\n\n将存储缩减因子 $R$（定义为天际线存储条目数与完整下三角存储条目数之比）报告为一个精确的最简分数。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是合理的。这是一个适定、自洽的问题，其基础是计算力学和数值线性代数的标准原理。我们可以开始求解。\n\n问题要求我们为给定的稀疏矩阵结构计算存储缩减因子 $R$。该因子定义为使用天际线格式存储的条目数与使用完整下三角表示法存储的条目数之比。所讨论的矩阵是全局刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$，其中 $n=12$。矩阵 $K$ 是对称的，这是允许使用天际线存储等高效存储方案的基本属性，在这种方案中，只需存储下（或上）三角部分，包括对角线。\n\n首先，我们计算在指定的天际线存储格式下存储的浮点条目总数，记为 $N_{\\text{sky}}$。问题将每列 $j$ 的天际线高度 $h_j$ 定义为该列在矩阵下三角部分中存储的条目数，包括对角线元素 $K_{jj}$。因此，存储的条目总数是所有列的天际线高度之和。\n给定维度 $n=12$ 和天际线高度序列 $\\{h_j\\}_{j=1}^{12} = \\{1,\\,2,\\,4,\\,5,\\,6,\\,6,\\,5,\\,5,\\,4,\\,3,\\,2,\\,1\\}$，存储的条目总数为：\n$$N_{\\text{sky}} = \\sum_{j=1}^{n} h_j$$\n代入给定的值：\n$$N_{\\text{sky}} = 1 + 2 + 4 + 5 + 6 + 6 + 5 + 5 + 4 + 3 + 2 + 1$$\n进行求和：\n$$N_{\\text{sky}} = (1+2+4+5+6) + (6+5+5+4+3+2+1)$$\n$$N_{\\text{sky}} = 18 + 26$$\n$$N_{\\text{sky}} = 44$$\n因此，天际线存储格式需要存储 $44$ 个浮点数。\n\n接下来，我们计算存储矩阵 $K$ 的整个下三角（包括主对角线）所需的条目数。我们用 $N_{\\text{full}}$ 表示这个数量。对于一个一般的 $n \\times n$ 矩阵，其下三角部分的元素数量是从 $j=1$ 到 $j=n$ 的各列中元素数量的总和。第 $j$ 列在下三角部分（包括对角线元素）有 $j$ 个元素。这意味着我们需要计算从 $1$ 到 $n$ 的整数和。\n$$N_{\\text{full}} = \\sum_{j=1}^{n} j$$\n这是一个等差数列的和，其公式为：\n$$N_{\\text{full}} = \\frac{n(n+1)}{2}$$\n对于给定的矩阵维度 $n=12$：\n$$N_{\\text{full}} = \\frac{12(12+1)}{2} = \\frac{12 \\times 13}{2} = 6 \\times 13 = 78$$\n所以，存储一个 $12 \\times 12$ 矩阵的完整下三角需要 $78$ 个浮点数。\n\n最后，我们计算存储缩减因子 $R$，它被定义为天际线存储条目数与完整下三角存储条目数之比。\n$$R = \\frac{N_{\\text{sky}}}{N_{\\text{full}}}$$\n代入已计算出的 $N_{\\text{sky}}$ 和 $N_{\\text{full}}$ 的值：\n$$R = \\frac{44}{78}$$\n为了以精确的最简分数形式给出答案，我们求出分子和分母的最大公约数。$44$ 和 $78$ 都是偶数。\n$$R = \\frac{2 \\times 22}{2 \\times 39} = \\frac{22}{39}$$\n分子的质因数分解是 $22 = 2 \\times 11$。分母的质因数分解是 $39 = 3 \\times 13$。由于没有共同的质因数，分数 $\\frac{22}{39}$ 是最简形式。\n\n存储缩减因子 $R$ 表示对于此特定矩阵结构，天际线存储方案相比于简单地存储整个下三角的效率。$R  1$ 的值表示存储需求的减少。在这里，$R = \\frac{22}{39} \\approx 0.564$，表明天际线方案所使用的存储空间大约是完整下三角方案所需的 $56.4\\%$。", "answer": "$$\\boxed{\\frac{22}{39}}$$", "id": "3559724"}, {"introduction": "在掌握了天际线存储的基本计算后，我们来探讨一个更深入的问题：工程建模决策如何影响矩阵的稀疏特性。本练习 ([@problem_id:3559721]) 通过对比两种常见的边界条件施加方法——“消元法”和“罚函数法”，揭示了不同的物理建模策略如何直接改变刚度矩阵的天际线高度，从而影响计算效率。这有助于你从更高维度理解理论与实践的联系。", "problem": "一个矩形土体域的二维平面应变弹性模型通过四节点四边形有限元的均匀网格进行离散化。节点按从下到上、从左到右的顺序逐行编号。该网格包含 $3 \\times 3$ 个节点，生成 $2 \\times 2$ 个单元。每个节点有两个位移自由度 (DOF)：水平位移 $u$ 和竖直位移 $v$。单元连接关系（以节点编号表示）如下：\n- 单元 $1$: $\\{1,2,5,4\\}$\n- 单元 $2$: $\\{2,3,6,5\\}$\n- 单元 $3$: $\\{4,5,8,7\\}$\n- 单元 $4$: $\\{5,6,9,8\\}$\n\n假设采用标准有限元组装：全局对称刚度矩阵 $K$ 中，对于在至少一个单元中同时出现的节点所关联的任意一对自由度，都有一个对应的非零块。基础（无约束）自由度排序为 $[u_1,v_1,u_2,v_2,\\dots,u_9,v_9]$，因此总自由度数 $n=18$。\n\n本质（狄利克雷）边界条件规定左边界节点 $\\{1,4,7\\}$ 的水平位移 $u$ 和竖直位移 $v$ 均为零。考虑两种施加策略：\n\n1. 通过消元法进行强施加：通过消除相应的行和列，从系统中移除受约束的自由度，并按其原始相对顺序对剩余的自由自由度进行重新编号，从而获得一个简化系统，其组装连接关系仅限于自由自由度。\n\n2. 罚函数法耦合到单个接地自由度：保留所有原始 $n$ 个自由度，并引入一个额外的标量接地自由度 $g$（索引为 $n+1$），附加在原始排序之后。通过一个大的罚刚度 $\\alpha$ 将每个受约束的自由度连接到 $g$ 来施加本质边界条件（$\\alpha$ 的大小不影响稀疏模式）。这仅在 $g$ 与受约束自由度之间以及 $g$ 自身之间引入非零项；不添加其他罚项。\n\n对于使用天际线存储方案存储的对称矩阵，定义第 $j$ 列的天际线高度为 $h_j = j - r_j + 1$，其中 $r_j$ 是第 $j$ 列中第一个非零元（包括对角线元素）的行索引。定义矩阵天际线高度 $H$ 为 $H = \\max_{1 \\leq j \\leq N} h_j$（对于一个 $N \\times N$ 矩阵）。\n\n仅使用上述网格连接关系和两种施加策略，确定策略1的简化系统的天际线高度 $H_{\\text{elim}}$ 和策略2的增广系统的天际线高度 $H_{\\text{pen}}$。然后计算由罚函数耦合引起的带宽增量，定义为 $\\Delta = H_{\\text{pen}} - H_{\\text{elim}}$。\n\n以单个整数形式提供 $\\Delta$。无需四舍五入。$\\Delta$ 没有物理单位。", "solution": "用户希望解决此问题，解决方案如下。\n首先验证问题，以确保其具有科学依据、良定性和客观性。\n\n**步骤 1：问题验证**\n\n逐字提取给定条件：\n- 一个矩形土体域的二维平面应变弹性模型通过四节点四边形有限元的均匀网格进行离散化。\n- 节点按从下到上、从左到右的顺序逐行编号。\n- 该网格包含 $3 \\times 3$ 个节点，生成 $2 \\times 2$ 个单元。\n- 每个节点有两个位移自由度 (DOF)：水平位移 $u$ 和竖直位移 $v$。\n- 单元连接关系（以节点编号表示）：\n  - 单元 $1$: $\\{1,2,5,4\\}$\n  - 单元 $2$: $\\{2,3,6,5\\}$\n  - 单元 $3$: $\\{4,5,8,7\\}$\n  - 单元 $4$: $\\{5,6,9,8\\}$\n- 全局对称刚度矩阵 $K$ 中，对于在至少一个单元中同时出现的节点所关联的任意一对自由度，都有一个对应的非零块。\n- 基础（无约束）自由度排序为 $[u_1,v_1,u_2,v_2,\\dots,u_9,v_9]$，因此总自由度数 $n=18$。\n- 本质（狄利克雷）边界条件规定左边界节点 $\\{1,4,7\\}$ 的水平位移 $u$ 和竖直位移 $v$ 均为零。\n- 策略 1 (消元法)：从系统中移除受约束的自由度。\n- 策略 2 (罚函数法)：保留所有原始自由度，并增加一个索引为 $n+1=19$ 的额外标量接地自由度 $g$。\n- 第 $j$ 列的天际线高度：$h_j = j - r_j + 1$，其中 $r_j$ 是第 $j$ 列中第一个非零元的索引。\n- 矩阵天际线高度 $H = \\max_{j} h_j$。\n- 任务：计算 $\\Delta = H_{\\text{pen}} - H_{\\text{elim}}$。\n\n根据验证标准对问题进行审查：\n- **科学依据**：该问题是线性弹性有限元法 (FEM) 的一个标准应用，是计算岩土力学和结构工程的基石。所使用的所有概念——刚度矩阵、单元组装、通过消元法和罚函数法施加边界条件以及天际线存储——都是成熟且科学合理的。\n- **良定性**：该问题对网格、连接关系、自由度排序和边界条件给出了完整而明确的描述。两种施加策略和天际线高度的定义是精确的。这使得问题有唯一的、可计算的解。\n- **客观性**：该问题以精确、正式的语言陈述，没有任何主观或模棱两可的术语。\n\n**结论**：问题有效。\n\n**步骤 2：求解**\n\n目标是计算通过两种不同方法施加本质边界条件所得到的刚度矩阵的天际线高度，然后求出它们的差值。\n\n自由度 (DOF) 的排序方式为：对于节点 $i$，其自由度为 $2i-1$（水平，$u_i$）和 $2i$（竖直，$v_i$）。总自由度数为 $n = 2 \\times 9 = 18$。刚度矩阵 $K$ 是一个 $18 \\times 18$ 的对称矩阵。如果自由度 $p$ 和 $q$ 对应的节点在同一个单元内，则矩阵项 $K_{pq}$ 可能为非零。\n\n天际线高度 $H$ 是列高 $h_j = j - r_j + 1$ 的最大值，其中 $r_j$ 是第 $j$ 列中第一个非零元的行索引。由于对称性，第 $j$ 列的第一个非零元对应于第 $j$ 行的第一个非零元。对于与节点 $k$ 关联的第 $j$ 列，第一个非零行 $r_j$ 由与节点 $k$ 共享一个单元的最小索引节点 $i_{min}$ 决定。具体来说，第一个非零行将是 $2 \\cdot i_{min} - 1$。\n\n首先，我们根据单元连接关系，确定每个节点 $k \\in \\{1, \\dots, 9\\}$ 的最小连接节点索引 $i_{\\text{min}}(k)$：\n- E1: $\\{1,2,5,4\\}$, E2: $\\{2,3,6,5\\}$, E3: $\\{4,5,8,7\\}$, E4: $\\{5,6,9,8\\}$.\n- 节点 1 连接到 $\\{2,4,5\\}$。$i_{\\text{min}}(1)=1$。\n- 节点 2 连接到 $\\{1,3,4,5,6\\}$。$i_{\\text{min}}(2)=1$。\n- 节点 3 连接到 $\\{2,5,6\\}$。$i_{\\text{min}}(3)=2$。\n- 节点 4 连接到 $\\{1,2,5,7,8\\}$。$i_{\\text{min}}(4)=1$。\n- 节点 5 连接到 $\\{1,2,3,4,6,7,8,9\\}$。$i_{\\text{min}}(5)=1$。\n- 节点 6 连接到 $\\{2,3,5,8,9\\}$。$i_{\\text{min}}(6)=2$。\n- 节点 7 连接到 $\\{4,5,8\\}$。$i_{\\text{min}}(7)=4$。\n- 节点 8 连接到 $\\{4,5,6,7,9\\}$。$i_{\\text{min}}(8)=4$。\n- 节点 9 连接到 $\\{5,6,8\\}$。$i_{\\text{min}}(9)=5$。\n\n**策略 1：消元法与 $H_{\\text{elim}}$ 的计算**\n\n本质边界条件施加于节点 $\\{1,4,7\\}$。对应的自由度是 $\\{1,2\\}$, $\\{7,8\\}$ 和 $\\{13,14\\}$。这 $6$ 个自由度被消除。\n剩余的自由节点是 $\\{2,3,5,6,8,9\\}$。自由自由度是 $\\{3,4,5,6,9,10,11,12,15,16,17,18\\}$。\n这 12 个自由自由度从 1 到 12 顺序重新编号，形成一个简化的 $12 \\times 12$ 系统。\n- 旧自由度 $\\{3,4\\}$ (节点 2) $\\rightarrow$ 新自由度 $\\{1,2\\}$\n- 旧自由度 $\\{5,6\\}$ (节点 3) $\\rightarrow$ 新自由度 $\\{3,4\\}$\n- 旧自由度 $\\{9,10\\}$ (节点 5) $\\rightarrow$ 新自由度 $\\{5,6\\}$\n- 旧自由度 $\\{11,12\\}$ (节点 6) $\\rightarrow$ 新自由度 $\\{7,8\\}$\n- 旧自由度 $\\{15,16\\}$ (节点 8) $\\rightarrow$ 新自由度 $\\{9,10\\}$\n- 旧自由度 $\\{17,18\\}$ (节点 9) $\\rightarrow$ 新自由度 $\\{11,12\\}$\n\n为找到简化矩阵的天际线，我们确定与每个自由节点相连的最小索引的*自由*节点。\n- 自由节点 2 连接到自由节点 $\\{3,5,6\\}$。与 2 连接的最小自由节点是 2 本身。\n- 自由节点 3 连接到自由节点 $\\{2,5,6\\}$。最小自由节点是 2。\n- 自由节点 5 连接到自由节点 $\\{2,3,6,8,9\\}$。最小自由节点是 2。\n- 自由节点 6 连接到自由节点 $\\{2,3,5,8,9\\}$。最小自由节点是 2。\n- 自由节点 8 连接到自由节点 $\\{5,6,9\\}$。最小自由节点是 5。\n- 自由节点 9 连接到自由节点 $\\{5,6,8\\}$。最小自由节点是 5。\n\n现在我们找出新的 $12 \\times 12$ 系统中每一列 $j$ 的第一个非零行 $r'_j$。\n- 对于新列 $\\{1,2\\}$ (原节点 2)：最小连接的自由节点是 2。其新自由度从 1 开始。因此，$r'_1=1, r'_2=1$。\n- 对于新列 $\\{3,4\\}$ (原节点 3)：最小连接的自由节点是 2。其新自由度从 1 开始。因此，$r'_3=1, r'_4=1$。\n- 对于新列 $\\{5,6\\}$ (原节点 5)：最小连接的自由节点是 2。其新自由度从 1 开始。因此，$r'_5=1, r'_6=1$。\n- 对于新列 $\\{7,8\\}$ (原节点 6)：最小连接的自由节点是 2。其新自由度从 1 开始。因此，$r'_7=1, r'_8=1$。\n- 对于新列 $\\{9,10\\}$ (原节点 8)：最小连接的自由节点是 5。其新自由度从 5 开始。因此，$r'_9=5, r'_{10}=5$。\n- 对于新列 $\\{11,12\\}$ (原节点 9)：最小连接的自由节点是 5。其新自由度从 5 开始。因此，$r'_{11}=5, r'_{12}=5$。\n\n列高 $h'_j = j - r'_j + 1$：\n- $h'_1 = 1-1+1=1$, $h'_2=2-1+1=2$\n- $h'_3 = 3-1+1=3$, $h'_4=4-1+1=4$\n- $h'_5 = 5-1+1=5$, $h'_6=6-1+1=6$\n- $h'_7 = 7-1+1=7$, $h'_8=8-1+1=8$\n- $h'_9 = 9-5+1=5$, $h'_{10}=10-5+1=6$\n- $h'_{11} = 11-5+1=7$, $h'_{12}=12-5+1=8$\n最大天际线高度为 $H_{\\text{elim}} = \\max(\\{1,2,3,4,5,6,7,8,5,6,7,8\\}) = 8$。\n\n**策略 2：罚函数耦合与 $H_{\\text{pen}}$ 的计算**\n\n系统增加一个自由度，得到一个 $19 \\times 19$ 的矩阵。原始 $18 \\times 18$ 子矩阵的稀疏模式得以保留。第 $j=1, \\dots, 18$ 列的列高由无约束连接关系决定。\n与节点 $k$ 关联的第 $j$ 列的第一个非零行 $r_j$ 是 $r_j = 2 \\cdot i_{\\text{min}}(k) - 1$。\n- 对于 $k=1$ (列 1,2): $i_{\\text{min}}(1)=1 \\Rightarrow r_{1,2}=1$。$h_{1,2} = \\{1,2\\}$。\n- 对于 $k=2$ (列 3,4): $i_{\\text{min}}(2)=1 \\Rightarrow r_{3,4}=1$。$h_{3,4} = \\{3,4\\}$。\n- 对于 $k=3$ (列 5,6): $i_{\\text{min}}(3)=2 \\Rightarrow r_{5,6}=3$。$h_{5,6} = \\{3,4\\}$。\n- 对于 $k=4$ (列 7,8): $i_{\\text{min}}(4)=1 \\Rightarrow r_{7,8}=1$。$h_{7,8} = \\{7,8\\}$。\n- 对于 $k=5$ (列 9,10): $i_{\\text{min}}(5)=1 \\Rightarrow r_{9,10}=1$。$h_{9,10} = \\{9,10\\}$。\n- 对于 $k=6$ (列 11,12): $i_{\\text{min}}(6)=2 \\Rightarrow r_{11,12}=3$。$h_{11,12} = \\{9,10\\}$。\n- 对于 $k=7$ (列 13,14): $i_{\\text{min}}(7)=4 \\Rightarrow r_{13,14}=7$。$h_{13,14} = \\{7,8\\}$。\n- 对于 $k=8$ (列 15,16): $i_{\\text{min}}(8)=4 \\Rightarrow r_{15,16}=7$。$h_{15,16} = \\{9,10\\}$。\n- 对于 $k=9$ (列 17,18): $i_{\\text{min}}(9)=5 \\Rightarrow r_{17,18}=9$。$h_{17,18} = \\{9,10\\}$。\n前 18 列的最大高度为 $\\max(2,4,4,8,10,10,8,10,10) = 10$。\n\n现在，我们分析增加的第 19 列。该列包含将接地自由度 $g$ 与受约束自由度及其自身耦合的非零项。受约束的自由度是 $\\{1,2,7,8,13,14\\}$。\n第 19 列中，行 $\\{1,2,7,8,13,14\\}$ 和行 19 的元素为非零。\n第 19 列的第一个非零行是 $r_{19} = \\min(\\{1,2,7,8,13,14,19\\}) = 1$。\n第 19 列的天际线高度是 $h_{19} = 19 - r_{19} + 1 = 19 - 1 + 1 = 19$。\n罚函数系统的总天际线高度是所有列高的最大值：\n$H_{\\text{pen}} = \\max(10, 19) = 19$。\n\n**最终计算**\n\n带宽增量是两个天际线高度之差：\n$\\Delta = H_{\\text{pen}} - H_{\\text{elim}} = 19 - 8 = 11$。", "answer": "$$\\boxed{11}$$", "id": "3559721"}, {"introduction": "前面的练习让你了解了天际线存储是什么以及它为何重要。现在，我们将解决一个更根本的问题：在有限元程序中，我们如何在不显式构造整个刚度矩阵的情况下，直接从单元连接性信息中高效地预估出天际线剖面？本练习 ([@problem_id:3559651]) 要求你设计并分析一种基于有限元组装基本原理的算法，这是深入理解和开发高性能计算力学软件的核心技能之一。请注意，本练习中“天际线高度”的定义 ($h_j = j - r_j$) 与前两个练习略有不同，它表示的是列的“半带宽”。请根据本题的定义进行计算。", "problem": "给定一个在计算岩土力学中由有限元离散化产生的全局、对称、正定刚度矩阵。该矩阵不被显式提供。取而代之，只给定单元到全局自由度 (DOF) 的连接关系。在天际线存储中，对于每一列 $j$（使用基于 $1$ 的索引），存储对角线元素以及从最低非零行 $r_j$ 到第 $j$ 行的所有元素。列 $j$ 的天际线高度为 $h_j = j - r_j$。你的任务是设计并实现一个算法，该算法直接根据单元连接关系计算完整的天际线高度数组 $\\{h_j\\}_{j=1}^N$，而无需首先构建图邻接矩阵。将你的算法及其正确性建立在有限元组装的基本法则之上：每个单元刚度矩阵都为其所有局部自由度对在全局矩阵中贡献非零项。\n\n从一个基本事实出发：一个具有局部自由度索引集 $\\mathcal{G}_e \\subset \\{1,\\dots,N\\}$ 的典型有限元会为所有 $i \\in \\mathcal{G}_e$ 和 $j \\in \\mathcal{G}_e$ 贡献非零项 $K_{ij}$（根据对称性，下三角部分已足够），推导一个基于原理的算法，仅使用单元连接集来计算所有 $j \\in \\{1,\\dots,N\\}$ 的 $r_j$。不要构建邻接矩阵或任何显式图；直接根据组装规则进行推理。根据单元数量 $E$ 和局部自由度数量 $p_e = |\\mathcal{G}_e|$ 来分析算法复杂度。你的分析必须包含与一个基准方法的比较，该方法枚举所有单元自由度对 $(i,j)$（其中 $i \\le j$）来更新 $r_j$。\n\n你的程序必须实现所推导的算法，并计算反映渐近复杂度的简单操作计数。使用以下操作模型使分析具体且可测试：\n- 初始化一个长度为 $N$ 的数组用于存放 $r_j$ 值，并将每个值设为 $j$：将此计为 $N$ 次基本操作。\n- 对于每个单元 $e$，设 $p_e$ 为其局部自由度数。通过一次 $p_e$ 次迭代的扫描计算最小自由度 $m_e = \\min \\mathcal{G}_e$：将此计为 $p_e$ 次基本操作。\n- 对于每个单元 $e$ 和每个 $j \\in \\mathcal{G}_e$，尝试更新 $r_j \\leftarrow \\min(r_j, m_e)$：将此计为 $p_e$ 次基本操作（每次尝试计为一次），无论值是否改变。\n- 处理完所有单元后，通过一次遍历计算天际线高度 $h_j = j - r_j$：将此计为 $N$ 次基本操作。\n- 通过一次遍历计算最大高度 $\\max_j h_j$：将此计为 $N$ 次基本操作。\n\n对于基准的对枚举方法，其操作计数定义如下：\n- 如上所述，初始化一个长度为 $N$ 的数组用于存放 $r_j$ 值：$N$ 次操作。\n- 对于每个具有 $p_e$ 个局部自由度的单元 $e$，枚举所有下三角对 $(i,j)$（其中 $i \\le j$），并执行 $r_j \\leftarrow \\min(r_j, i)$：将此计为 $p_e(p_e+1)/2$ 次基本操作。\n- 通过一次遍历计算 $\\{h_j\\}_{j=1}^N$ 和 $\\max_j h_j$：各需 $N + N$ 次操作。\n\n对于每个测试用例，你的程序必须计算：\n- 所有 $j \\in \\{1,\\dots,N\\}$ 的天际线高度 $h_j$。\n- 最大天际线高度 $\\max_j h_j$。\n- 带宽，定义为 $\\max_j h_j + 1$。\n- 天际线存储总长度 $L = \\sum_{j=1}^N (h_j + 1)$。\n- 按规定计算的你的算法的实测基本操作计数。\n- 按规定计算的基准基本操作计数。\n\n你的实现不得构建任何邻接矩阵或全局稀疏矩阵。它必须仅根据单元连接关系计算天际线高度，并由有限元组装原理证明其合理性。\n\n测试套件。使用以下四个测试用例。每个用例由 $N$ 和一个单元连接集列表指定，每个连接集都是全局自由度索引的集合。所有索引都是基于 $1$ 的，且在 $\\{1,\\dots,N\\}$ 范围内。\n\n- 用例 A (理想路径，重叠单元链)：$N = 7$，单元 $\\{\\{1,2,3\\},\\{3,4,5\\},\\{5,6,7\\}\\}$。\n- 用例 B (不同局部尺寸的重叠)：$N = 10$，单元 $\\{\\{2,3,5,7\\},\\{1,4,5\\},\\{5,8,9\\},\\{6,9,10\\}\\}$。\n- 用例 C (单个大单元，边界情况)：$N = 6$，单元 $\\{\\{1,2,3,4,5,6\\}\\}$。\n- 用例 D (存在不连通的自由度，边缘情况)：$N = 8$，单元 $\\{\\{2,3\\},\\{5,7\\}\\}$。\n\n最终输出格式。你的程序应生成单行输出，包含一个由方括号括起来的、用逗号分隔且无空格的结果列表。每个测试用例的结果本身必须是包含以下六个整数的列表：\n$[N,\\max_j h_j,\\max_j h_j + 1,L,\\text{measured},\\text{baseline}]$。\n因此，最终打印输出必须类似于\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$\n其中四个用例结果按 A, B, C, D 的顺序排列。", "solution": "该问题是有效的，因为它科学地基于有限元法（FEM）的原理，问题陈述清晰，具有明确的目标和充足的数据，并使用了精确、客观的语言。因此，我们可以继续进行解法的推导和实现。\n\n### 基于原理的算法推导\n\n问题的核心是直接根据单元连接数据确定全局刚度矩阵 $K$ 的天际线轮廓。矩阵 $K$ 是一个 $N \\times N$ 的对称正定矩阵，其中 $N$ 是自由度（DOF）的总数。\n\n有限元组装（FEM assembly）的基本原理指出，全局刚度矩阵是由单元刚度矩阵叠加而成的。全局矩阵中存在一个非零项 $K_{ij}$，当且仅当至少有一个单元 $e$ 将自由度 $i$ 和自由度 $j$ 耦合。对于标准的单元公式，该单元内的所有自由度都是相互耦合的。设 $\\mathcal{G}_e \\subset \\{1, 2, \\dots, N\\}$ 为与单元 $e$ 相关联的全局自由度索引集。那么，对于任何两个自由度 $i, j \\in \\mathcal{G}_e$，项 $K_{ij}$（以及根据对称性得到的 $K_{ji}$）都会从单元 $e$ 的刚度矩阵中获得一个非零贡献。因此，$K_{ij} \\neq 0$ 当且仅当存在一个单元 $e$ 使得 $\\{i, j\\} \\subseteq \\mathcal{G}_e$。\n\n列 $j$ 的天际线存储方案需要存储从第一个非零行 $r_j$ 到对角线 $j$ 的所有元素。$r_j$ 的值正式定义为：\n$$\nr_j = \\min \\{ i \\mid 1 \\le i \\le j \\text{ and } K_{ij} \\neq 0 \\}\n$$\n条件 $K_{jj} \\neq 0$（由于正定性）确保了 $r_j$ 是良定义的且 $r_j \\le j$。结合这些定义，我们可以用单元连接关系来表示 $r_j$：\n$$\nr_j = \\min \\left( \\{j\\} \\cup \\{ i \\mid 1 \\le i  j \\text{ and } \\exists e \\text{ s.t. } \\{i, j\\} \\subseteq \\mathcal{G}_e \\} \\right)\n$$\n\n**基准算法分析**\n\n对这一定义的直接解释导出了基准算法。我们初始化一个行索引数组，称之为 $\\mathbf{r}$，使得对于所有 $j \\in \\{1, \\dots, N\\}$，$r_j = j$。然后，对于每个单元 $e$，我们遍历所有自由度对 $(i, j) \\in \\mathcal{G}_e \\times \\mathcal{G}_e$ 且满足 $i \\le j$。对于每个这样的对，我们有一个已知的非零项 $K_{ij}$，这意味着列 $j$ 的行索引最多为 $i$。因此，我们执行更新：\n$$\nr_j \\leftarrow \\min(r_j, i)\n$$\n如果一个单元有 $p_e = |\\mathcal{G}_e|$ 个自由度，则存在 $p_e(p_e+1)/2$ 个这样的对 $(i,j)$ 满足 $i \\le j$。对所有 $E$ 个单元求和，此类更新的总数是 $\\sum_{e=1}^E p_e(p_e+1)/2$。核心循环的复杂度是 $O(\\sum_e p_e^2)$。根据问题模型，总操作计数为 $3N + \\sum_{e=1}^E \\frac{p_e(p_e+1)}{2}$。\n\n**所提出的算法推导**\n\n我们可以通过从不同角度重新审视更新规则，推导出一种更高效的算法。对于任何给定的单元 $e$，它为其所有自由度对贡献非零刚度项。这意味着对于任何特定的自由度 $j \\in \\mathcal{G}_e$，它都与所有其他自由度 $i \\in \\mathcal{G}_e$ 相连接。\n\n令 $m_e = \\min \\mathcal{G}_e$ 为单元 $e$ 内的最小自由度索引。由于 $m_e \\in \\mathcal{G}_e$，它与 $\\mathcal{G}_e$ 中的每一个其他自由度 $j$ 相连。这意味着对于每个 $j \\in \\mathcal{G}_e$，都存在一个非零项 $K_{m_e, j}$ (假设 $m_e \\le j$) 或 $K_{j, m_e}$ (假设 $j \\le m_e$)。当考虑矩阵的下三角部分中第 $j$ 列时，涉及 $m_e$ 的非零项将位于第 $\\min(j, m_e)$ 行。\n\n关键在于，对于任何列 $j \\in \\mathcal{G}_e$，单元 $e$ 可能贡献的最小行索引是 $m_e$。单元 $\\mathcal{G}_e$ 中没有其他自由度 $i$ 能为列 $j$ 提供更小的行索引，因为根据定义 $m_e \\le i$。因此，对于每个 $j \\in \\mathcal{G}_e$，我们可以*仅*根据其所属单元的最小自由度来更新其最小行索引：\n$$\nr_j \\leftarrow \\min(r_j, m_e)\n$$\n对所有 $j \\in \\mathcal{G}_e$ 应用此更新，并对每个单元 $e$ 重复此过程，将得到所有 $r_j$ 的正确最终值。\n\n由此产生的算法如下：\n1. 初始化一个长度为 $N$ 的数组 $\\mathbf{r}$，使得 $r_j = j$ 对于 $j=1, \\dots, N$。\n2. 对于每个单元 $e=1, \\dots, E$：\n   a. 找到单元中的最小自由度索引：$m_e = \\min \\mathcal{G}_e$。\n   b. 对于每个自由度 $j \\in \\mathcal{G}_e$，执行更新：$r_j \\leftarrow \\min(r_j, m_e)$。\n3. 处理完所有单元后，计算天际线高度：$h_j = j - r_j$。\n\n**所提出算法的复杂度分析**\n\n对于每个单元 $e$，该算法执行两个步骤：找到 $p_e$ 个自由度中的最小值，然后执行 $p_e$ 次更新。这两个步骤都耗时 $O(p_e)$。因此，在所有 $E$ 个单元上的总工作量为 $\\sum_{e=1}^E O(p_e) = O(\\sum_e p_e)$。包括初始化和最终计算在内的总复杂度为 $O(N + \\sum_e p_e)$。根据问题模型，操作计数为 $N$ (初始化) $+ \\sum_e (p_e + p_e)$ (循环) $+ N$ (高度) $+ N$ (最大高度) $= 3N + 2\\sum_{e=1}^E p_e$。\n\n这在渐近意义上优于基准算法的 $O(N + \\sum_e p_e^2)$ 复杂度。所提出算法的成本与单元自由度总数呈线性关系，而基准算法则与单元大小呈二次方关系。对于 $p_e$ 较大的高阶有限元，这一优势非常显著。对于较小的 $p_e$（例如 $p_e=2$），基准算法可能稍微更高效，因为其每个单元的操作计数 $p_e(p_e+1)/2$ 可能小于所提出方法的 $2 p_e$ 计数（该计数包括寻找最小值的成本）。具体来说，当 $p_e  3$ 时，$p_e(p_e+1)/2  2p_e$。当 $p_e=3$ 时，计数相等。当 $p_e > 3$ 时，所提出的算法更优。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite using 1-based indexing as given in the problem.\n    test_cases_1_based = [\n        {'N': 7, 'elements': [{1, 2, 3}, {3, 4, 5}, {5, 6, 7}]},\n        {'N': 10, 'elements': [{2, 3, 5, 7}, {1, 4, 5}, {5, 8, 9}, {6, 9, 10}]},\n        {'N': 6, 'elements': [{1, 2, 3, 4, 5, 6}]},\n        {'N': 8, 'elements': [{2, 3}, {5, 7}]}\n    ]\n\n    results = []\n    for case in test_cases_1_based:\n        N = case['N']\n        # Convert 1-based element DOFs to 0-based for numpy array indexing.\n        elements_0_based = [\n            [dof - 1 for dof in sorted(list(elem))] for elem in case['elements']\n        ]\n        result = compute_skyline_metrics(N, elements_0_based)\n        results.append(result)\n\n    # Format the final output as a single-line string.\n    # The string representation of a list is already in the required format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\ndef compute_skyline_metrics(N, elements):\n    \"\"\"\n    Computes skyline metrics for a single test case.\n\n    Args:\n        N (int): The total number of Degrees of Freedom (DOFs).\n        elements (list of list of int): A list of element connectivity sets,\n                                        using 0-based indexing.\n\n    Returns:\n        list: A list of integers [N, max_h, bandwidth, L, measured_ops, baseline_ops].\n    \"\"\"\n    if N == 0:\n        return [0, 0, 1, 0, 0, 0]\n\n    # --- Proposed Algorithm Implementation ---\n    \n    # Initialize r_j = j.\n    # In 0-based indexing, this corresponds to r[j] = j for j = 0 to N-1.\n    r = np.arange(N)\n    \n    # Per the problem's operation counting model:\n    # 1. Initialize 'r' array: N operations\n    measured_ops = N\n    \n    p_e_list = []\n    for elem_dofs in elements:\n        p_e = len(elem_dofs)\n        p_e_list.append(p_e)\n        if p_e == 0:\n            continue\n            \n        # 2a. Compute m_e = min(G_e): p_e operations\n        m_e = elem_dofs[0]  # Assumes elements are pre-sorted\n        measured_ops += p_e\n        \n        # 2b. Update r_j for each j in G_e: p_e operations\n        for j in elem_dofs:\n            r[j] = min(r[j], m_e)\n        measured_ops += p_e\n\n    # 3. Compute skyline heights h_j = j - r_j: N operations\n    h = np.arange(N) - r\n    measured_ops += N\n    \n    # 4. Compute max skyline height: N operations\n    if h.size > 0:\n        max_h = int(np.max(h))\n    else:\n        max_h = 0\n    measured_ops += N\n    \n    # --- Calculation of Other Metrics ---\n\n    # Bandwidth = max_h + 1\n    bandwidth = max_h + 1\n    \n    # Total skyline storage length L = sum(h_j + 1)\n    L = int(np.sum(h + 1))\n    \n    # --- Baseline Operation Count Calculation ---\n    \n    # Initialization: N ops\n    baseline_ops = N\n    # Loop over elements: sum(p_e * (p_e + 1) / 2) ops\n    for p_e in p_e_list:\n        baseline_ops += p_e * (p_e + 1) // 2\n    # Final steps: N + N ops\n    baseline_ops += N + N\n\n    return [N, max_h, bandwidth, L, int(measured_ops), int(baseline_ops)]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3559651"}]}