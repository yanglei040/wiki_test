{"hands_on_practices": [{"introduction": "本构算法的实现是计算塑性力学的核心。本练习将引导您推导并实现一个带有非线性运动硬化（Armstrong-Frederick模型）的J2塑性模型的隐式积分算法。掌握一致切线模量的推导对于确保有限元求解器中牛顿迭代法的二次收敛至关重要，这是开发和使用高级材料模型的一项基本技能。[@problem_id:3529165]", "problem": "考虑一个材料点，该点在不排水条件下经历小应变单剪。该材料点所在的土壤采用 von Mises (J2) 弹塑性模型进行建模，该模型包含 Armstrong–Frederick 型非线性运动硬化，并处于一个边界面框架内，其中运动硬化通过动态恢复达到饱和。不排水条件意味着体积应变增量为零，因此在加载过程中只有剪切响应发生演化。目标是推导、实现并测试用于本构方程后向欧拉积分的一致性算法切线。\n\n基本基础包括以下经过充分检验的定义和定律：\n- 小应变可加性：$d\\boldsymbol{\\varepsilon} = d\\boldsymbol{\\varepsilon}^{e} + d\\boldsymbol{\\varepsilon}^{p}$。\n- 偏量响应的线弹性各向同性：$\\boldsymbol{s} = 2 G \\boldsymbol{\\varepsilon}^{e}_{\\text{dev}}$，其中 $G$ 是剪切模量。\n- 带有运动偏移的 Von Mises (J2) 屈服函数：$f = \\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| - \\sigma_{y}$，其中 $\\sigma_{y}$ 是当前屈服应力（在本问题中视为常数），$\\boldsymbol{s}$ 是偏应力张量，$\\boldsymbol{\\alpha}$ 是背应力张量。\n- 相关联流动：$d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} = d p \\, \\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = d p \\, \\sqrt{\\dfrac{3}{2}} \\, \\dfrac{\\boldsymbol{s} - \\boldsymbol{\\alpha}}{\\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\|}$，其中塑性乘子 $d p \\ge 0$。\n- Armstrong–Frederick 非线性运动硬化：$d\\boldsymbol{\\alpha} = c \\, d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} - \\gamma \\, \\boldsymbol{\\alpha} \\, d p$，其中 $c$ 是运动硬化模量，$\\gamma$ 是控制饱和的动态恢复参数（这些参数是常数）。\n- 此处的边界面解释是通过动态恢复项下 $\\boldsymbol{\\alpha}$ 的饱和来实现的，这限制了屈服面的平移。\n\n将响应限制在只有 $\\boldsymbol{12}$ 分量非零的单剪情况，并假设所有量在这一维偏量子空间中保持共线。设工程剪切应变为 $\\gamma$，剪切应力为 $\\tau$，因此 $\\tau = G \\gamma^{e}$，其中 $\\gamma^{e} = \\gamma - \\gamma^{p}$。设背应力分量为 $a = \\alpha_{12}$。单剪中的 J2 等效范数给出 $\\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| = \\sqrt{3} \\, \\left| \\tau - a \\right|$。\n\n在每个应变增量 $d \\gamma$ 处使用后向欧拉（隐式）校正子：\n- 试探应力：$\\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d \\gamma$。\n- 后向欧拉和相关联流动下的塑性流动在单剪中产生 $d \\gamma^{p} = \\sqrt{3} \\, d p \\, \\operatorname{sign}(\\tau - a)$，在增量结束时。\n- 使用后向欧拉的单剪 Armstrong–Frederick 更新：$a_{\\text{new}} = \\dfrac{a_{\\text{prev}} + c \\, \\sqrt{\\dfrac{3}{4}} \\, d p \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})}{1 + \\gamma \\, d p}$。\n- 应力校正子：$\\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\, \\sqrt{3} \\, d p \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})$。\n- 一致性条件：$\\sqrt{3} \\, \\left| \\tau_{\\text{new}} - a_{\\text{new}} \\right| = \\sigma_{y}$。\n\n任务 1. 从上述基本基础出发，在一维单剪子空间中使用后向欧拉离散化，推导一个关于塑性乘子增量 $d p$ 的标量非线性残差方程，该方程强制执行一致性条件，且仅用增量开始时的已知量（$\\tau_{\\text{prev}}$, $a_{\\text{prev}}$）、试探应力 $\\tau_{\\text{tr}}$ 和材料参数（$G$, $\\sigma_{y}$, $c$, $\\gamma$）表示。然后，通过计算残差相对于 $d p$ 的导数，推导 $d p$ 的牛顿更新公式。\n\n任务 2. 从相同的后向欧拉积分出发，推导一致性算法剪切切线 $C_{\\text{alg}} = \\dfrac{d \\tau_{\\text{new}}}{d \\gamma}$，该切线在所选积分方案内将应力响应对应变增量进行线性化。用 $G$、$c$、$\\gamma$、$a_{\\text{prev}}$ 和增量的收敛 $d p$ 来表示 $C_{\\text{alg}}$。\n\n任务 3. 实现一个程序，为一组应变增量执行以下操作：\n- 按顺序施加每个剪切应变增量 $d \\gamma$。\n- 在每个增量处，计算 $\\tau_{\\text{tr}}$，并使用试探屈服函数 $f_{\\text{tr}} = \\sqrt{3} \\, \\left| \\tau_{\\text{tr}} - a_{\\text{prev}} \\right| - \\sigma_{y}$ 进行弹性检验。如果 $f_{\\text{tr}} \\le 0$，则该步为弹性步，无需牛顿迭代；设置 $d p = 0$，$\\tau_{\\text{new}} = \\tau_{\\text{tr}}$，$a_{\\text{new}} = a_{\\text{prev}}$，且 $C_{\\text{alg}} = G$。\n- 如果 $f_{\\text{tr}}  0$，则对推导出的残差使用牛顿法求解 $d p$。使用从线性运动硬化情况（$\\gamma = 0$）推导出的数值上合理的初始猜测，限制 $d p \\ge 0$，并对残差范数使用 $\\epsilon = 10^{-10}$ 的容差，最大迭代次数为 $50$ 次。更新 $\\tau_{\\text{new}}$、$a_{\\text{new}}$，并根据任务 2 计算 $C_{\\text{alg}}$。\n- 跟踪每个增量所需的牛顿迭代次数。\n\n您的程序应通过报告每个测试用例在所有增量中观察到的牛顿迭代最大次数（作为整数）来评估严重不排水软化循环下的牛顿收敛性。所有应力单位必须是千帕（kPa），应变为无量纲，不出现角度。最终输出中不要求任何物理量；仅需要迭代次数。\n\n测试套件。使用以下四个测试用例，每个用例由一个元组 $(G, \\sigma_{y}, c, \\gamma, \\text{increments})$ 定义，其中 $G$ 的单位是 $\\text{kPa}$，$\\sigma_{y}$ 的单位是 $\\text{kPa}$，$c$ 的单位是 $\\text{kPa}$，$\\gamma$ 的单位是 $\\text{(strain)}^{-1}$，应变增量是无量纲的：\n- 用例 1（一般循环加载）：$(G = 50000, \\sigma_{y} = 100, c = 15000, \\gamma = 80, \\text{increments} = [0.002, 0.002, -0.004, 0.004, -0.004, 0.004])$。\n- 用例 2（由强动态恢复引起的严重软化）：$(G = 30000, \\sigma_{y} = 60, c = 5000, \\gamma = 600, \\text{increments} = [0.004, -0.008, 0.008, -0.008, 0.008])$。\n- 用例 3（具有非常小增量的近弹性状态）：$(G = 40000, \\sigma_{y} = 200, c = 10000, \\gamma = 50, \\text{increments} = [0.0005, -0.0005, 0.0005, -0.0005])$。\n- 用例 4（接近屈服并发生反向加载的边界情况）：$(G = 35000, \\sigma_{y} = 80, c = 8000, \\gamma = 200, \\text{increments} = [0.0012, 0.0012, -0.0024])$。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例顺序列出结果。例如，如果各增量上的最大牛顿迭代次数为 $n_{1}$、$n_{2}$、$n_{3}$ 和 $n_{4}$，您的程序必须精确输出：$[n_{1},n_{2},n_{3},n_{4}]$。", "solution": "用户提供的问题要求推导并实现一个用于一维单剪 von Mises 弹塑性模型（包含非线性 Armstrong–Frederick 运动硬化）的后向欧拉返回映射算法。解决方案分为三个部分，与问题陈述中指定的任务相对应。\n\n### 任务 1：残差方程和牛顿更新的推导\n\n目标是找到塑性乘子增量，记为 $dp$，它能确保增量结束时的状态（“新”状态）满足屈服条件，也称为一致性条件。这通过构建一个残差方程 $R(dp) = 0$ 来实现，该方程通常使用牛顿法进行数值求解。\n\n设增量开始时的状态变量为剪切应力 $\\tau_{\\text{prev}}$ 和背应力 $a_{\\text{prev}}$。增量由总剪切应变增量 $d\\gamma$ 驱动。\n\n**1. 试探状态：**\n首先，假设整个应变增量 $d\\gamma$ 都是弹性的，计算一个弹性试探状态。\n试探应力 $\\tau_{\\text{tr}}$ 为：\n$$ \\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d\\gamma $$\n在试探步骤中，背应力保持不变：$a_{\\text{tr}} = a_{\\text{prev}}$。\n\n**2. 屈服检验：**\n如果试探状态位于屈服面之外，则发生塑性。单剪中的屈服函数为 $f = \\sqrt{3} |\\tau - a| - \\sigma_y$。试探屈服函数为：\n$$ f_{\\text{tr}} = \\sqrt{3} |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y $$\n如果 $f_{\\text{tr}} \\le 0$，则该步为弹性步。最终状态即为试探状态，且 $dp=0$。如果 $f_{\\text{tr}} > 0$，则需要进行塑性校正。\n\n**3. 塑性校正（返回映射）：**\n最终状态 $(\\tau_{\\text{new}}, a_{\\text{new}})$ 必须满足本构方程和一致性条件，所有这些都使用后向欧拉格式进行离散化。\n流动方向由相对应力的符号确定。我们假设此符号保持不变，并由试探状态给出：\n$$ S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}}) $$\n使用提供的后向欧拉更新规则：\n$$ \\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S $$\n$$ a_{\\text{new}} = \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} $$\n步骤结束时的一致性条件要求：\n$$ \\sqrt{3} |\\tau_{\\text{new}} - a_{\\text{new}}| = \\sigma_y $$\n假设符号 $S$ 保持不变，则上式变为：\n$$ \\tau_{\\text{new}} - a_{\\text{new}} = S \\frac{\\sigma_y}{\\sqrt{3}} $$\n现在，将 $\\tau_{\\text{new}}$ 和 $a_{\\text{new}}$ 的表达式代入一致性条件：\n$$ \\left( \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S \\right) - \\left( \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} \\right) = S \\frac{\\sigma_y}{\\sqrt{3}} $$\n为了构建残差方程，我们将所有项移到一边。设相对应力为 $\\xi = \\tau - a$。\n一致性条件是 $\\xi_{\\text{new}} = S\\sigma_y/\\sqrt{3}$。让我们将 $\\xi_{\\text{new}}$ 表示为 $dp$ 的函数：\n$$ \\xi_{\\text{new}} = \\tau_{\\text{new}} - a_{\\text{new}} = (\\tau_{\\text{tr}} - G\\sqrt{3} S dp) - \\frac{a_{\\text{prev}} + c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\n将 $\\xi_{\\text{new}}$ 与其目标值相减得到残差，或者直接将项重新排列以求解 $dp$。一个方便的残差形式是：\n$$ R(dp) = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - G\\sqrt{3} dp - \\frac{(c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma) dp}{1+\\gamma dp} = 0 $$\n注意 $f_{\\text{tr}}/\\sqrt{3} = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y/\\sqrt{3}$。所以残差可以写成：\n$$ R(dp) = \\frac{f_{\\text{tr}}}{\\sqrt{3}} - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{1+\\gamma dp} \\right) dp = 0 $$\n\n**4. 牛顿更新公式：**\n为了使用牛顿法求解 $R(dp)=0$，我们需要 $R$ 相对于 $dp$ 的导数，记为 $R'(dp)$。\n设项 $K = c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma$。\n$$ R(dp) = \\frac{f_{\\text{tr}}}{\\sqrt{3}} - G\\sqrt{3} dp - K \\frac{dp}{1+\\gamma dp} $$\n$$ R'(dp) = \\frac{d R}{d(dp)} = -G\\sqrt{3} - K \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) $$\n使用商法则 $\\frac{d}{dx}(\\frac{u}{v}) = \\frac{u'v-uv'}{v^2}$：\n$$ \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) = \\frac{1(1+\\gamma dp) - dp(\\gamma)}{(1+\\gamma dp)^2} = \\frac{1}{(1+\\gamma dp)^2} $$\n所以，残差的导数为：\n$$ R'(dp) = -G\\sqrt{3} - \\frac{K}{(1+\\gamma dp)^2} = - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2} \\right) $$\n在第 $k$ 次迭代中，$dp$ 的 Newton-Raphson 更新为：\n$$ dp_{k+1} = dp_k - \\frac{R(dp_k)}{R'(dp_k)} $$\n\n### 任务 2：一致性算法切线的推导\n\n一致性算法切线 $C_{\\text{alg}}$ 是更新后的应力 $\\tau_{\\text{new}}$ 相对于总应变增量 $d\\gamma$ 的导数。\n$$ C_{\\text{alg}} = \\frac{d\\tau_{\\text{new}}}{d(d\\gamma)} $$\n我们有 $\\tau_{\\text{new}} = \\tau_{\\text{prev}} + G d\\gamma - G\\sqrt{3}S\\,dp$。对 $d\\gamma$ 求导：\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\frac{d(dp)}{d(d\\gamma)} $$\n这里，$S = \\operatorname{sign}(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}})$ 在试探步骤确定加载方向后，在增量内被视为常数。塑性乘子 $dp$ 是 $d\\gamma$ 的一个隐函数，通过残差方程 $R(dp, d\\gamma) = 0$ 确定。我们对 $R=0$ 使用隐式微分：\n$$ dR = \\frac{\\partial R}{\\partial(dp)} d(dp) + \\frac{\\partial R}{\\partial(d\\gamma)} d(d\\gamma) = 0 $$\n这给出了 $\\frac{d(dp)}{d(d\\gamma)} = - \\left( \\frac{\\partial R}{\\partial(dp)} \\right)^{-1} \\frac{\\partial R}{\\partial(d\\gamma)}$。\n我们已经找到了 $\\frac{\\partial R}{\\partial(dp)} = R'(dp)$。现在我们求 $\\frac{\\partial R}{\\partial(d\\gamma)}$：\n$$ \\frac{\\partial R}{\\partial(d\\gamma)} = \\frac{\\partial}{\\partial(d\\gamma)}\\left( |\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - \\dots \\right) = \\frac{\\partial}{\\partial(d\\gamma)}\\left( S(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}) \\right) = SG $$\n因此：\n$$ \\frac{d(dp)}{d(d\\gamma)} = - \\frac{SG}{R'(dp)} = \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n将此代入 $C_{\\text{alg}}$ 的表达式中：\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\left( \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) $$\n因为 $S^2=1$：\n$$ C_{\\text{alg}} = G - \\frac{G^2\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n这可以重新整理成一个更紧凑的形式：\n$$ C_{\\text{alg}} = G \\left( 1 - \\frac{G\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) = G \\frac{\\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n$$ C_{\\text{alg}} = \\frac{G (c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma)}{G\\sqrt{3}(1+\\gamma dp)^2 + c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma} $$\n这个 $C_{\\text{alg}}$ 的表达式使用了增量收敛后的 $dp$ 值。对于弹性步（$dp=0$），该表达式必须简化为 $G$。在塑性情况下，$S$ 和 $a_{\\text{prev}}$ 是已知量，所以表达式是完全定义的。如果 $dp=0$，则 $S$ 无关紧要，因为 dp 的导数的分子在概念上将为零。弹性切线就是 $G$。\n\n### 任务 3：实现\n推导出的方程在一个 Python 程序中实现。对于每个应变增量，主要逻辑遵循以下步骤：\n1. 计算试探应力 $\\tau_{\\text{tr}}$ 和试探屈服函数 $f_{\\text{tr}}$。\n2. 如果 $f_{\\text{tr}} \\le 0$，则该步为弹性步。更新 $\\tau_{\\text{new}} = \\tau_{\\text{tr}}$，$a_{\\text{new}} = a_{\\text{prev}}$。牛顿迭代次数为 $0$。\n3. 如果 $f_{\\text{tr}} > 0$，则该步为塑性步。\n    a. 确定符号 $S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}})$。\n    b. 从线性硬化情况（$\\gamma=0$）计算 $dp$ 的初始猜测值：$dp_0 = f_{\\text{tr}} / (3G + 1.5c)$。\n    c. 启动 Newton-Raphson 循环，使用任务 1 中推导的残差 $R(dp)$ 及其导数 $R'(dp)$ 求解 $R(dp) = 0$ 以得到 $dp$。\n    d. 在每次迭代中限制 $dp \\ge 0$。\n    e. 当 $|R(dp)|$ 低于容差（$\\epsilon=10^{-10}$）或达到最大迭代次数（$50$）时停止。\n    f. 统计迭代次数。\n    g. 使用收敛的 $dp$ 更新 $\\tau_{\\text{new}}$ 和 $a_{\\text{new}}$。\n4. 跟踪每个测试用例在所有增量中的最大牛顿迭代次数。\n5. 报告最大迭代次数的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases defined as (G, sigma_y, c, gamma, increments)\n    # G in kPa, sigma_y in kPa, c in kPa, gamma dimensionless, increments dimensionless\n    test_cases = [\n        # Case 1: general cyclic loading\n        (50000.0, 100.0, 15000.0, 80.0, [0.002, 0.002, -0.004, 0.004, -0.004, 0.004]),\n        # Case 2: severe softening due to strong dynamic recovery\n        (30000.0, 60.0, 5000.0, 600.0, [0.004, -0.008, 0.008, -0.008, 0.008]),\n        # Case 3: near-elastic regime with very small increments\n        (40000.0, 200.0, 10000.0, 50.0, [0.0005, -0.0005, 0.0005, -0.0005]),\n        # Case 4: boundary case near yield with reversal\n        (35000.0, 80.0, 8000.0, 200.0, [0.0012, 0.0012, -0.0024]),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_iters = run_simulation(*params)\n        results.append(max_iters)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(G, sigma_y, c, gamma, increments):\n    \"\"\"\n    Performs the elastoplastic simulation for a single test case.\n\n    Args:\n        G (float): Shear modulus.\n        sigma_y (float): Yield stress.\n        c (float): Kinematic hardening modulus.\n        gamma (float): Dynamic recovery parameter.\n        increments (list of float): Sequence of shear strain increments.\n\n    Returns:\n        int: The maximum number of Newton iterations over all increments.\n    \"\"\"\n    tau_prev = 0.0\n    a_prev = 0.0\n    max_newton_iterations = 0\n    sqrt3 = np.sqrt(3.0)\n\n    for d_gamma in increments:\n        # --- ELASTIC PREDICTOR ---\n        tau_tr = tau_prev + G * d_gamma\n        xi_tr = tau_tr - a_prev\n\n        # Trial yield function\n        # A small tolerance is used for the elastic check to handle floating point inaccuracies\n        f_tr = sqrt3 * np.abs(xi_tr) - sigma_y\n\n        if f_tr = 1e-12:\n            # Elastic step\n            tau_new = tau_tr\n            a_new = a_prev\n            current_iterations = 0\n        else:\n            # --- PLASTIC CORRECTOR ---\n            S = np.sign(xi_tr)\n            \n            # Initial guess for dp from the linear hardening case (gamma = 0)\n            dp0_denom = 3.0 * G + 1.5 * c\n            dp = f_tr / dp0_denom if dp0_denom > 1e-12 else 0.0\n            \n            # Clamp initial guess to be non-negative\n            dp = max(0.0, dp)\n\n            # Newton-Raphson iteration for plastic multiplier dp\n            tol = 1e-10\n            max_iter_newton = 50\n            current_iterations = 0\n\n            for i in range(max_iter_newton):\n                current_iterations += 1\n                \n                # Pre-calculate hardening-recovery term for residual and derivative\n                K = c * sqrt3 / 2.0 - S * a_prev * gamma\n                \n                denom = 1.0 + gamma * dp\n\n                # Residual function R(dp)\n                residual = f_tr / sqrt3 - sqrt3 * G * dp - K * dp / denom\n                \n                if np.abs(residual)  tol:\n                    break\n\n                # Derivative of the residual R'(dp)\n                residual_prime = -sqrt3 * G - K / (denom**2)\n\n                if np.abs(residual_prime)  1e-12:\n                    # Jacobian is singular, break to avoid division by zero\n                    # This may indicate convergence issues, but the algorithm will proceed with the last dp.\n                    break\n                \n                # Newton update\n                dp_update = -residual / residual_prime\n                dp += dp_update\n                \n                # Clamp dp to be non-negative. This handles cases of elastic unloading\n                # detected during the iterative correction.\n                dp = max(0.0, dp)\n            \n            # --- Update state variables ---\n            tau_new = tau_tr - G * sqrt3 * dp * S\n            a_new = (a_prev + c * sqrt3 / 2.0 * dp * S) / (1.0 + gamma * dp)\n\n        if current_iterations > max_newton_iterations:\n            max_newton_iterations = current_iterations\n        \n        # update for next increment\n        tau_prev = tau_new\n        a_prev = a_new\n        \n    return max_newton_iterations\n\n# Execute the simulation and print the results.\nsolve()\n```", "id": "3529165"}, {"introduction": "应变软化行为在数值模拟中常导致病态的网格依赖性。本练习将通过裂缝带模型（crack-band model）来解决这一挑战，这是一种广泛用于正则化软化行为的技术。您将学习如何标定一个软化本构律，使其耗散的能量与材料的断裂能（$G_f$）匹配，从而确保模拟的失效行为对于网格尺寸是客观的。[@problem_id:3529154]", "problem": "给定一个带缺口试件的单轴拉伸模型，该模型由一个一维串联系统表示：一个弹性杆段与一个发生软化的裂纹带有限元串联。弹性段的杨氏模量为 $E$，横截面积为 $A$，长度为 $L_r = L_{\\text{tot}} - h$，其中 $L_{\\text{tot}}$ 是试件总长， $h$ 是裂纹带的单元特征长度。裂纹带单元遵循一个关于等效塑性应变 $\\varepsilon_p$ 的软化定律 $\\sigma(\\varepsilon_p)$，相应的内聚力-分离定律 $T(w)$ 通过 $w = h \\, \\varepsilon_p$ 和 $T(w) = \\sigma(\\varepsilon_p)$ 关联。抗拉强度为 $f_t$，目标I型断裂能为 $G_f$。\n\n基本原理：\n- 裂纹带能量等效原理指出，单位面积上耗散的能量等于材料的断裂能。在一个特征长度为 $h$ 的连续体单元中，要求是\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}.\n$$\n- 裂纹带单元的内聚力-分离定律 $T(w)$ 必须满足\n$$\n\\int_{0}^{w_{\\text{end}}} T(w) \\, dw = G_f,\n$$\n其中 $w = h \\, \\varepsilon_p$ 且 $T(w) = \\sigma(\\varepsilon_p)$。\n- 对于一个长度为 $L_r$ 的弹性段与一个内聚力单元串联，在施加的末端位移 $\\Delta$ 下，平衡关系为\n$$\nF = A \\, T(w), \\quad \\Delta = \\frac{L_r}{E A} \\, F + w,\n$$\n弹性加载直至在 $\\Delta_y = \\frac{f_t L_r}{E}$ 和 $F_y = f_t A$ 时发生屈服。\n\n你的任务：\n1. 为两种形式的软化定律 $\\sigma(\\varepsilon_p)$ 进行标定，以使裂纹带能量等效成立：\n   - 线性软化：$\\sigma(\\varepsilon_p) = f_t \\, \\max\\!\\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}, 0\\right)$，对于 $0 \\le \\varepsilon_p \\le \\varepsilon_f$。\n   - 指数软化：$\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)$，对于 $0 \\le \\varepsilon_p  \\infty$。\n   从基本原理推导标定参数 $\\varepsilon_f$ 和 $\\varepsilon_c$，不要使用快捷公式。\n\n2. 使用标定后的 $T(w)$，通过在每个测试案例中比较两种不同裂纹带单元尺寸 $h$ 下直至完全破坏所需的总外功，来验证带缺口试件模型的网格客观性。总外功应等于在裂纹面积上耗散的断裂能，即 $A \\, G_f$ 焦耳。通过组合达到 $\\Delta_y$ 的弹性加载功和屈服后软化功来计算总功。弹性段的卸载和内聚软化可能会表现出回弹（snap-back）现象；因此，你的计算必须对非单调的力-位移行为具有鲁棒性，并且不能依赖于对 $\\Delta(w)$ 的反算。\n\n3. 通过为每个 $h$ 计算 $\\int \\sigma(\\varepsilon_p) \\, d\\varepsilon_p$ 并将其与 $\\frac{G_f}{h}$ 进行比较，来数值验证标定结果。同时，为每个 $h$ 计算直至破坏的总外功，并将其与 $A \\, G_f$ 进行比较。\n\n单位与数值要求：\n- 使用国际单位制 (SI)：$E$ 的单位为帕斯卡 (Pa)，$A$ 为平方米 ($\\mathrm{m}^2$)，$L_{\\text{tot}}$、$L_r$ 和 $h$ 为米 ($\\mathrm{m}$)，$f_t$ 为帕斯卡 (Pa)，$G_f$ 为焦耳每平方米 ($\\mathrm{J/m^2}$)，$w$ 为米 ($\\mathrm{m}$)，$\\varepsilon_p$ 无量纲，$\\Delta$ 为米 ($\\mathrm{m}$)，$F$ 为牛顿 (N)，总外功为焦耳 (J)。\n- 报告差异时，应以无量纲小数表示，而不是百分号。例如，报告 $0.001$ 表示 $0.1\\%$ 的差异。\n- 你的程序应该为每个测试案例计算四个相对误差中的最大值：两个来自软化定律面积检查（每个 $h$ 一个），两个来自网格客观性功检查（每个 $h$ 一个）。\n\n测试套件：\n- 测试案例 1（线性软化，理想情况）：\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$。\n- 测试案例 2（指数软化，理想情况）：\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$。\n- 测试案例 3（线性软化，边界单元尺寸）：\n  - $E = 20 \\times 10^9$ Pa, $f_t = 2 \\times 10^6$ Pa, $G_f = 80$ $\\mathrm{J/m^2}$, $A = 1 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 0.2$ $\\mathrm{m}$, $h_1 = 0.001$ $\\mathrm{m}$, $h_2 = 0.05$ $\\mathrm{m}$。\n\n算法指导：\n- 对于线性软化，内聚定律为 $T(w) = f_t \\left(1 - \\frac{w}{w_f}\\right)$，适用范围 $0 \\le w \\le w_f$，其中 $w_f = h \\, \\varepsilon_f$。对于指数软化，内聚定律为 $T(w) = f_t \\exp\\!\\left(-\\frac{w}{w_c}\\right)$，适用范围 $w \\ge 0$，其中 $w_c = h \\, \\varepsilon_c$。\n- 将屈服前弹性功计算为 $W_{\\text{el}} = \\frac{1}{2} \\frac{F_y^2}{k_r}$，其中 $F_y = f_t A$ 且 $k_r = \\frac{E A}{L_r}$。\n- 通过以 $w$ 为参数，并对 $F(w) \\, \\frac{d\\Delta}{dw}$ 关于 $w$ 进行积分来计算屈服后功，其中 $F(w) = A \\, T(w)$ 且 $\\frac{d\\Delta}{dw} = 1 + \\frac{L_r}{E} \\frac{dT}{dw}$。\n- 对于线性软化，积分范围为 $w \\in [0, w_f]$。对于指数软化，积分范围为 $w \\in [0, w_{\\text{end}}]$，其中 $w_{\\text{end}}$ 足够大（例如 $w_{\\text{end}} = 12 \\, w_c$），并验证尾部贡献可以忽略不计。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”），其中每个结果是按上述方法计算的相应测试案例的最大相对误差。", "solution": "该问题陈述是有效的。其科学基础是计算断裂力学的原理，特别是裂纹带模型。所有参数、定义和约束均已提供，构成了一个适定且自洽的问题。对于像混凝土这样的准脆性材料，其数值是物理上现实的。任务定义清晰，计算上可行。我们将进行完整求解。\n\n解答包括三个主要部分：首先，基于断裂能准则对线性和指数软化定律的参数进行解析标定。其次，建立破坏所需的总外功的公式，包括网格客观性的解析证明。第三，描述用于验证这些发现的数值步骤。\n\n### 1. 软化定律的标定\n\n标定的基本原理是裂纹带能量等效，即单元内单位体积耗散的能量，在整个塑性应变历史上积分，必须等于通过特征单元长度 $h$ 归一化的断裂能 $G_f$：\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}\n$$\n这里，$\\sigma(\\varepsilon_p)$ 是作为等效塑性应变 $\\varepsilon_p$ 函数的软化应力。\n\n#### 1.1. 线性软化定律\n线性软化定律由下式给出：\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right), \\quad \\text{for} \\quad 0 \\le \\varepsilon_p \\le \\varepsilon_f\n$$\n其中 $f_t$ 是抗拉强度，$\\varepsilon_f$ 是应力降至零时的极限塑性应变。我们将其代入能量等效积分中：\n$$\n\\int_{0}^{\\varepsilon_f} f_t \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right) \\, d\\varepsilon_p = f_t \\left[\\varepsilon_p - \\frac{\\varepsilon_p^2}{2\\varepsilon_f}\\right]_{0}^{\\varepsilon_f} = f_t \\left(\\varepsilon_f - \\frac{\\varepsilon_f^2}{2\\varepsilon_f}\\right) = \\frac{1}{2} f_t \\varepsilon_f\n$$\n将其等同于所需的耗散能量密度：\n$$\n\\frac{1}{2} f_t \\varepsilon_f = \\frac{G_f}{h}\n$$\n求解标定参数 $\\varepsilon_f$ 可得：\n$$\n\\varepsilon_f = \\frac{2 G_f}{h f_t}\n$$\n\n#### 1.2. 指数软化定律\n指数软化定律由下式给出：\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right), \\quad \\text{for} \\quad \\varepsilon_p \\ge 0\n$$\n其中 $\\varepsilon_c$ 是一个特征塑性应变。理论上塑性应变延伸至无穷大，因此 $\\varepsilon_{p,\\text{end}} = \\infty$。能量等效积分为：\n$$\n\\int_{0}^{\\infty} f_t \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right) \\, d\\varepsilon_p = f_t \\left[-\\varepsilon_c \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)\\right]_{0}^{\\infty} = f_t \\left(0 - (-\\varepsilon_c)\\right) = f_t \\varepsilon_c\n$$\n将其等同于目标能量密度：\n$$\nf_t \\varepsilon_c = \\frac{G_f}{h}\n$$\n求解标定参数 $\\varepsilon_c$ 可得：\n$$\n\\varepsilon_c = \\frac{G_f}{h f_t}\n$$\n\n这种基于能量的标定的一个关键推论是，特征裂纹张开 $w = h \\varepsilon_p$ 变得与网格尺寸 $h$ 无关。对于线性软化，最终裂纹张开为 $w_f = h \\varepsilon_f = h \\frac{2G_f}{h f_t} = \\frac{2G_f}{f_t}$。对于指数软化，特征裂纹张开为 $w_c = h \\varepsilon_c = h \\frac{G_f}{h f_t} = \\frac{G_f}{f_t}$。这将断裂能 $G_f$ 体现为内聚裂纹的一个属性，与数值离散化 $h$ 无关。\n\n### 2. 网格客观性与总功计算\n\n网格客观性要求，导致结构失效所耗散的总能量是一个恒定的材料属性，与网格尺寸 $h$ 无关。对于这个单轴试件，消耗的总能量必须等于断裂能 $G_f$ 乘以裂纹面积 $A$，即 $A G_f$。我们通过计算从初始加载到完全破坏对系统所做的总外功 $W_{\\text{total}}$ 来验证这一点。\n\n总功是初始弹性加载阶段所做的功 $W_{\\text{el}}$ 与屈服后软化阶段所做的功 $W_{\\text{post-yield}}$ 之和。\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}}\n$$\n\n#### 2.1. 弹性功 ($W_{\\text{el}}$)\n系统进行弹性加载，直到力达到屈服力 $F_y = f_t A$。在此阶段，裂纹张开 $w$ 为零，总位移 $\\Delta$ 完全由长度为 $L_r$ 的杆的弹性变形引起。\n$$\n\\Delta = \\frac{L_r}{E A} F\n$$\n屈服时，位移为 $\\Delta_y = \\frac{L_r f_t}{E}$。所做的功是力-位移三角形的面积：\n$$\nW_{\\text{el}} = \\frac{1}{2} F_y \\Delta_y = \\frac{1}{2} (f_t A) \\left( \\frac{L_r f_t}{E} \\right) = \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.2. 屈服后功 ($W_{\\text{post-yield}}$)\n屈服后，裂纹张开 $w$ 从 0 开始增加，而力 $F$ 根据软化定律减小。总位移由 $\\Delta(w) = \\frac{L_r}{EA}F(w) + w$ 给出。力为 $F(w) = A T(w)$，其中 $T(w) = \\sigma(w/h)$ 是内聚应力。外功由积分 $\\int F d\\Delta$ 给出。为了处理可能的回弹（非单调 $\\Delta$），我们相对于裂纹张开 $w$ 对积分进行参数化：\n$$\nd\\Delta = \\frac{d\\Delta}{dw} dw = \\left(1 + \\frac{L_r}{EA} \\frac{dF}{dw}\\right) dw = \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\n屈服后功则为：\n$$\nW_{\\text{post-yield}} = \\int_{w=0}^{w=w_{\\text{end}}} F(w) \\, d\\Delta = \\int_{0}^{w_{\\text{end}}} A T(w) \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\n$$\nW_{\\text{post-yield}} = A \\int_{0}^{w_{\\text{end}}} T(w) dw + \\frac{A L_r}{E} \\int_{0}^{w_{\\text{end}}} T(w) \\frac{dT}{dw} dw\n$$\n第一项 $A \\int T(w) dw$ 根据定义是总断裂能 $A G_f$。第二项积分可以通过识别出 $T(w) dT = \\frac{1}{2} d(T^2)$ 来求解：\n$$\n\\int_{w=0}^{w=w_{\\text{end}}} T(w) \\frac{dT}{dw} dw = \\int_{T(0)}^{T(w_{\\text{end}})} T dT = \\frac{1}{2} [T^2]_{T=f_t}^{T=0} = -\\frac{1}{2} f_t^2\n$$\n这对于任何满足 $T(0)=f_t$ 和 $T(w_{\\text{end}})=0$ 的软化定律都成立。代回可得：\n$$\nW_{\\text{post-yield}} = A G_f + \\frac{A L_r}{E} \\left(-\\frac{1}{2} f_t^2\\right) = A G_f - \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.3. 总功与网格客观性\n将弹性功和屈服后功分量相加，得到总功：\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}} = \\left(\\frac{A L_r f_t^2}{2E}\\right) + \\left(A G_f - \\frac{A L_r f_t^2}{2E}\\right) = A G_f\n$$\n这个解析结果证明，使试件破坏所需的总外功恰好是 $A G_f$，而与单元尺寸 $h$（其包含在 $L_r = L_{\\text{tot}}-h$ 中）、弹性模量 $E$ 或经过能量标定的软化定律的具体形式无关。这证实了裂纹带模型的公式是网格客观的。\n\n### 3. 数值验证步骤\n\n数值实现将验证解析结果。对于每个测试案例和每个 $h \\in \\{h_1, h_2\\}$ 值，将计算以下量。\n\n1.  **软化定律面积检查**：\n    - 计算标定参数（$\\varepsilon_f$ 或 $\\varepsilon_c$）。\n    - 使用 `scipy.integrate.quad` 对积分 $\\int \\sigma(\\varepsilon_p) d\\varepsilon_p$ 进行数值计算。对于指数情况，积分上限为 $\\varepsilon_{p,\\text{end}} = 12 \\varepsilon_c$。\n    - 将数值结果与理论目标 $G_f/h$ 进行比较，并计算相对误差为 $| \\text{数值} - \\text{目标} | / \\text{目标}$。\n\n2.  **总功检查**：\n    - 使用解析公式计算弹性功 $W_{\\text{el}}$。\n    - 定义屈服后功的被积函数 $F(w)(d\\Delta/dw)$。\n    - 通过将此函数关于 $w$ 从 $0$ 积分到 $w_{\\text{end}}$（线性情况为 $w_f$，指数情况为 $12w_c$）来计算 $W_{\\text{post-yield}}$。\n    - 计算总数值功 $W_{\\text{total,num}} = W_{\\text{el}} + W_{\\text{post-yield,num}}$。\n    - 将此结果与理论目标 $A G_f$ 进行比较，并计算相对误差。\n\n最后，对于每个测试案例，报告四个计算出的相对误差（$h_1, h_2$ 的面积检查和 $h_1, h_2$ 的功检查）中的最大值。由于解析解的精确性，这些误差预计会非常小，仅由数值积分精度和浮点运算引起。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: linear softening, happy path\n        {\n            'type': 'linear',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 2: exponential softening, happy path\n        {\n            'type': 'exponential',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 3: linear softening, boundary element sizes\n        {\n            'type': 'linear',\n            'E': 20e9, 'ft': 2e6, 'Gf': 80.0, 'A': 1e-3, 'L_tot': 0.2, \n            'h_values': [0.001, 0.05]\n        }\n    ]\n\n    results = []\n\n    for case_params in test_cases:\n        case_errors = []\n        softening_type = case_params['type']\n        E = case_params['E']\n        ft = case_params['ft']\n        Gf = case_params['Gf']\n        A = case_params['A']\n        L_tot = case_params['L_tot']\n        h_values = case_params['h_values']\n\n        for h in h_values:\n            L_r = L_tot - h\n\n            # 1. Calibrate and perform area check\n            if softening_type == 'linear':\n                # Calibration\n                eps_f = (2 * Gf) / (h * ft)\n                w_f = h * eps_f\n\n                # Area check\n                sigma_func = lambda eps_p: ft * (1 - eps_p / eps_f)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_f)\n                \n                # Post-yield work calculation\n                T_func = lambda w: ft * (1 - w / w_f)\n                dTdw_func = lambda w: -ft / w_f\n                w_end = w_f\n            \n            elif softening_type == 'exponential':\n                # Calibration\n                eps_c = Gf / (h * ft)\n                w_c = h * eps_c\n\n                # Area check (truncated)\n                eps_end_factor = 12.0\n                eps_end = eps_end_factor * eps_c\n                sigma_func = lambda eps_p: ft * np.exp(-eps_p / eps_c)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_end)\n\n                # Post-yield work calculation\n                T_func = lambda w: ft * np.exp(-w / w_c)\n                dTdw_func = lambda w: (-ft / w_c) * np.exp(-w / w_c)\n                w_end = eps_end_factor * w_c\n\n            area_target = Gf / h\n            rel_err_area = abs(area_num - area_target) / area_target\n            case_errors.append(rel_err_area)\n            \n            # 2. Compute total work and perform check\n            # Elastic work\n            W_el = (A * L_r * ft**2) / (2 * E)\n\n            # Post-yield work integrand: F(w) * d(Delta)/dw\n            work_integrand = lambda w: (A * T_func(w)) * (1 + (L_r / E) * dTdw_func(w))\n            \n            # Integrate to get post-yield work\n            W_post_yield_num, _ = integrate.quad(work_integrand, 0, w_end)\n            \n            W_total_num = W_el + W_post_yield_num\n            \n            # Target total work\n            W_target = A * Gf\n            \n            rel_err_work = abs(W_total_num - W_target) / W_target\n            case_errors.append(rel_err_work)\n\n        results.append(max(case_errors))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3529154"}, {"introduction": "材料软化在物理上是必需的，但它也给数值计算带来了严峻的稳定性挑战，常常导致模拟失败。最后一个练习将通过推导一个自适应时间步长算法来解决这个实际问题。我们的目标是控制单个时间步内材料强度的退化速率，以保证应力返回映射算法的鲁棒性和计算效率。[@problem_id:3529137]", "problem": "考虑一个在计算岩土力学中，由偏应力第二不变量（J2）控制、并带有各向同性软化的小应变关联塑性模型。设内部软化变量定义为单位体积的累积塑性功，记为 $\\kappa$，其演化规律为 $d\\kappa/dt = \\dot{W}_p$，其中 $\\dot{W}_p$ 是单位体积的塑性功耗散率。屈服应力是 $\\kappa$ 的函数，写作 $\\sigma_y = \\sigma_y(\\kappa)$，并经历软化过程，其局部特征由斜率 $h = d\\sigma_y/d\\kappa$ 描述，在软化区 $h  0$。假设在一个时间增量 $\\Delta t$ 内，塑性功耗散率 $\\dot{W}_p$ 和软化斜率 $h$ 可被视为局部常数，并且应力更新的返回映射算法应通过限制每一步的屈服应力退化来保持良态。从塑性功的基本定义和软化规律的泰勒展开出发，推导一个自动时间步长上限，以确保在一个时间步长内屈服应力的相对减小不超过一个预定分数 $\\theta \\in (0,1)$，即增量的大小满足条件 $|\\Delta \\sigma_y| \\le \\theta \\, \\sigma_y$。该上限必须用 $\\dot{W}_p$、$\\sigma_y$、 $h$ 和 $\\theta$ 表示，并且必须与 $\\kappa$ 作为单位体积塑性功的定义相一致。提出第二个基于能量考虑的上限，其基础是将塑性功增量限制为某个特征软化功能量尺度的一个分数 $\\eta \\in (0,1)$，并将这两个上限与用户指定的最大步长 $\\Delta t_{\\text{user}}$ 结合成一个单一的选择规则，该规则在以下边缘情况下是稳健的：纯弹性步（$\\dot{W}_p = 0$）、非软化或硬化（$h \\ge 0$）以及屈服应力 $\\sigma_y$ 趋近于零。\n\n您的程序必须实现所推导的选择规则，并为下面测试套件中的每个测试用例返回所选的 $\\Delta t$。所有物理量必须采用国际单位制（SI）。最终选择的时间步长以秒为单位表示。不涉及角度。输出必须是浮点数。\n\n测试套件（每个用例是一个元组 $(\\sigma_y, \\dot{W}_p, h, \\theta, \\eta, \\Delta t_{\\text{user}})$，除无量纲的 $\\theta$ 和 $\\eta$ 外，所有单位均为国际单位制）：\n- 用例1（一般软化，中等速率）：($200\\times 10^{6}, 5\\times 10^{8}, -0.2, 0.05, 0.05, 1.0$)。\n- 用例2（纯弹性增量）：($150\\times 10^{6}, 0.0, -0.3, 0.10, 0.10, 1.0$)。\n- 用例3（近乎理想塑性，非常弱的软化）：($200\\times 10^{6}, 1\\times 10^{8}, -1\\times 10^{-6}, 0.05, 0.05, 0.5$)。\n- 用例4（强软化，高塑性功耗散率）：($50\\times 10^{6}, 1\\times 10^{9}, -0.5, 0.10, 0.10, 0.5$)。\n- 用例5（接近破坏，屈服应力小）：($1\\times 10^{5}, 1\\times 10^{8}, -0.2, 0.05, 0.05, 1.0$)。\n- 用例6（非软化/硬化指示）：($100\\times 10^{6}, 1\\times 10^{7}, +0.1, 0.10, 0.10, 2.0$)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果是对应于相应测试用例的所选 $\\Delta t$（以秒为单位），顺序与上面列出的顺序相同。", "solution": "该问题被验证为具有科学依据、提法恰当且客观。它提出了计算塑性力学中一个标准但并非无足轻重的任务：为软化材料模型推导并实现一个时间步长控制算法。\n\n目标是为涉及小应变、关联J2各向同性软化塑性模型的数值模拟推导一个稳健的时间步长 $\\Delta t$ 选择规则。该规则必须防止在单个步骤内发生过度的材料退化，并能处理各种物理和数值上的边缘情况。\n\n该模型由一个屈服应力 $\\sigma_y$ 定义，它是内变量 $\\kappa$ 的函数。这个内变量 $\\kappa$ 代表单位体积的累积塑性功，其演化由速率方程控制：\n$$ \\frac{d\\kappa}{dt} = \\dot{W}_p $$\n其中 $\\dot{W}_p$ 是单位体积的塑性功耗散率。材料发生软化，意味着其屈服应力随塑性变形而降低。这由软化模量 $h$ 来表征，其定义为屈服应力相对于累积塑性功的斜率：\n$$ h = \\frac{d\\sigma_y}{d\\kappa} $$\n在软化区，$h  0$。问题假设对于给定的时间增量 $\\Delta t$，$\\dot{W}_p$ 和 $h$ 都可以被视为局部常数。\n\n推导过程分三部分进行：首先基于物理准则推导两个不同的时间步长上限，然后将它们组合成一个单一的稳健选择规则。\n\n首先，我们从单个步骤内屈服应力的相对减小必须受限这一约束条件出发，推导时间步长上限 $\\Delta t_1$。该条件给出为：\n$$ |\\Delta \\sigma_y| \\le \\theta \\, \\sigma_y $$\n其中 $\\sigma_y$ 是该步骤开始时的屈服应力，$\\theta \\in (0,1)$ 是用户定义的容差。屈服应力的变化量 $\\Delta \\sigma_y$ 可以使用一阶泰勒展开来近似：\n$$ \\Delta \\sigma_y \\approx \\frac{d\\sigma_y}{d\\kappa} \\Delta \\kappa = h \\Delta \\kappa $$\n塑性功的增量 $\\Delta \\kappa$ 是通过将其速率 $\\dot{W}_p$ 在时间步长 $\\Delta t$ 上积分得到的。在 $\\dot{W}_p$ 是常数的假设下，我们有：\n$$ \\Delta \\kappa \\approx \\dot{W}_p \\Delta t $$\n将此代入 $\\Delta \\sigma_y$ 的表达式中，得到：\n$$ \\Delta \\sigma_y \\approx h \\dot{W}_p \\Delta t $$\n要发生软化，必须有塑性变形（$\\dot{W}_p > 0$）和负的软化模量（$h  0$）。在这种情况下，$\\Delta \\sigma_y$ 是负的。对其大小的约束变为：\n$$ |h \\dot{W}_p \\Delta t| \\le \\theta \\, \\sigma_y $$\n由于 $\\dot{W}_p > 0$ 且 $h  0$，我们有 $|h| = -h$。该不等式为：\n$$ (-h) \\dot{W}_p \\Delta t \\le \\theta \\, \\sigma_y $$\n对 $\\Delta t$ 求解，得到第一个上限：\n$$ \\Delta t_1 = \\frac{\\theta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n这个上限仅在软化激活时才有意义，即 $h  0$ 且 $\\dot{W}_p > 0$。如果这两个条件中的任何一个不满足，此约束就不相关。\n\n第二，我们提出并推导一个基于能量考虑的次要时间步长上限 $\\Delta t_2$。这个上限的基础是将塑性功增量 $\\Delta W_p = \\Delta \\kappa$ 限制为某个特征软化功能量尺度 $W_c$ 的一个分数 $\\eta \\in (0,1)$。对于 $W_c$，一个具有物理意义的选择是，在假设软化模量 $h$ 为常数的情况下，将当前屈服应力 $\\sigma_y$ 降至零所需的单位体积塑性功。其计算方式如下：\n$$ W_c = -\\frac{\\sigma_y}{h} $$\n$W_c$ 的单位是帕斯卡，或焦耳/立方米，这与 $\\kappa$ 的定义是一致的。该约束可表述为：\n$$ \\Delta W_p \\le \\eta \\, W_c $$\n代入 $\\Delta W_p \\approx \\dot{W}_p \\Delta t$ 和 $W_c$ 的表达式：\n$$ \\dot{W}_p \\Delta t \\le \\eta \\left(-\\frac{\\sigma_y}{h}\\right) $$\n对 $\\Delta t$ 求解，得到第二个上限：\n$$ \\Delta t_2 = \\frac{\\eta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n这个上限的形式与 $\\Delta t_1$ 相似，也仅在 $h  0$ 且 $\\dot{W}_p > 0$ 时激活。\n\n最后，我们将这两个推导出的上限与用户指定的最大时间步长 $\\Delta t_{\\text{user}}$ 结合起来，形成一个单一、稳健的选择规则。所选的时间步长 $\\Delta t$ 必须是所有适用上限中的最小值。该规则还必须对边缘情况具有稳健性。\n\n完整的选择规则如下：\n1. 检查非软化的先决条件。如果没有塑性功耗散率（$\\dot{W}_p \\le 0$）或者材料没有软化（$h \\ge 0$），则基于退化的控制不是必需的。在这种情况下，时间步长仅受用户偏好的限制：\n$$ \\text{如果 } \\dot{W}_p \\le 0 \\text{ 或 } h \\ge 0, \\text{ 则 } \\Delta t = \\Delta t_{\\text{user}}。 $$\n这涵盖了纯弹性步、理想塑性（$h=0$）和硬化（$h>0$）。\n\n2. 如果软化是激活的（$\\dot{W}_p > 0$ 且 $h  0$），则计算两个推导出的上限。对完全退化的材料（$\\sigma_y \\le 0$）进行检查应得到一个为 $0$ 的时间步长以停止模拟，尽管所有测试用例都具有 $\\sigma_y > 0$：\n$$ \\Delta t_1 = \\frac{\\theta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n$$ \\Delta t_2 = \\frac{\\eta \\, \\sigma_y}{(-h) \\dot{W}_p} $$\n最终的时间步长是这两个上限和用户指定的最大值中最严格的一个：\n$$ \\Delta t = \\min(\\Delta t_1, \\Delta t_2, \\Delta t_{\\text{user}}) $$\n这个规则对于趋近于零的 $\\sigma_y$ 是稳健的，因为在这个极限下，$\\Delta t_1$ 和 $\\Delta t_2$ 都正确地趋近于 $0$，从而强制使用小的时间步长来精确捕捉材料破坏的最后阶段。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the appropriate time step based on a J2 plasticity model\n    with isotropic softening for a suite of test cases.\n    \"\"\"\n\n    # Test suite: (sigma_y, W_p_dot, h, theta, eta, dt_user)\n    # All values are in SI units, except for dimensionless theta and eta.\n    test_cases = [\n        # Case 1 (general softening, moderate rate)\n        (200e6, 5e8, -0.2, 0.05, 0.05, 1.0),\n        # Case 2 (purely elastic increment)\n        (150e6, 0.0, -0.3, 0.10, 0.10, 1.0),\n        # Case 3 (near-perfect plasticity, very weak softening)\n        (200e6, 1e8, -1e-6, 0.05, 0.05, 0.5),\n        # Case 4 (strong softening, high plastic work rate)\n        (50e6, 1e9, -0.5, 0.10, 0.10, 0.5),\n        # Case 5 (approaching failure, small yield stress)\n        (1e5, 1e8, -0.2, 0.05, 0.05, 1.0),\n        # Case 6 (non-softening/hardening indicator)\n        (100e6, 1e7, 0.1, 0.10, 0.10, 2.0),\n    ]\n\n    def compute_timestep(sigma_y, W_p_dot, h, theta, eta, dt_user):\n        \"\"\"\n        Computes the time step based on the derived selection rule.\n\n        Args:\n            sigma_y (float): Current yield stress (Pa).\n            W_p_dot (float): Plastic work rate per unit volume (Pa/s).\n            h (float): Softening modulus (dimensionless).\n            theta (float): Relative yield stress degradation tolerance (dimensionless).\n            eta (float): Relative plastic work increment tolerance (dimensionless).\n            dt_user (float): User-specified maximum time step (s).\n\n        Returns:\n            float: The selected time step (s).\n        \"\"\"\n        # Edge Case: If plastic work rate is zero or negative (elastic step)\n        # or if the material is not softening (h >= 0, i.e., hardening or perfect plasticity),\n        # the softening-based time step controls are not applicable.\n        # The only limit is the user-specified maximum time step.\n        if W_p_dot = 0 or h >= 0:\n            return dt_user\n\n        # Main Case: Softening is active (W_p_dot > 0 and h  0).\n        \n        # Edge Case: If yield stress is already zero or negative, the material\n        # has failed. The time step should be zero to halt further evolution.\n        if sigma_y = 0:\n            return 0.0\n        \n        # Calculate the denominator for the time step bounds.\n        # This is guaranteed to be positive since h  0 and W_p_dot > 0.\n        denominator = (-h) * W_p_dot\n        \n        # Calculate the first time step bound, dt1, based on limiting the\n        # relative change in yield stress.\n        dt1 = (theta * sigma_y) / denominator\n        \n        # Calculate the second time step bound, dt2, based on the\n        # energetic criterion.\n        dt2 = (eta * sigma_y) / denominator\n        \n        # The final selected time step is the minimum of the two calculated\n        # bounds and the user-specified maximum.\n        dt_selected = min(dt1, dt2, dt_user)\n        \n        return dt_selected\n\n    results = []\n    for case in test_cases:\n        result = compute_timestep(*case)\n        results.append(result)\n\n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) is necessary to convert all float results to strings\n    # before joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529137"}]}