{"hands_on_practices": [{"introduction": "本章节的第一个练习将显式时间积分过程分解为其最基本的组成部分：单个时间步的计算。通过手动为一个简单的二自由度系统计算状态更新，你将具体理解位移和速度如何根据中心差分格式演化[@problem_id:3523947]。这个基础练习旨在为你掌握更复杂的动态模拟打下坚实的基础。", "problem": "一个水平分层土层被理想化为一个两自由度的集总质量模型，在两个节点处具有平移运动。无阻尼、小振幅、线性弹性动力学的半离散运动方程由牛顿第二定律给出，其形式为 $\\,\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)\\,$，其中 $\\,\\mathbf{M}\\,$ 是对角（集总）质量矩阵，$\\,\\mathbf{K}\\,$ 是线性刚度矩阵，$\\,\\mathbf{f}(t)\\,$ 是外荷载向量。在离散时间 $\\,t^{n}\\,$，提供以下数据：\n- 质量矩阵 $\\,\\mathbf{M} = \\mathrm{diag}(2000,\\,1000)\\,$，单位为 $\\mathrm{kg}$。\n- 刚度矩阵 $\\,\\mathbf{K} = \\begin{pmatrix} 5 \\times 10^{6}  0 \\\\ 0  5 \\times 10^{6} \\end{pmatrix}\\,$，单位为 $\\mathrm{N/m}$。\n- 时间步 $\\,\\Delta t = 0.01\\,$，单位为 $\\mathrm{s}$。\n- 当前和前一时间步的位移：$\\,\\mathbf{u}^{n} = \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix}\\,$（单位为 $\\mathrm{m}$）和 $\\,\\mathbf{u}^{n-1} = \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix}\\,$（单位为 $\\mathrm{m}$）。\n- 在 $\\,t^{n}\\,$ 时的外荷载向量：$\\,\\mathbf{f}^{n} = \\begin{pmatrix} 3 \\times 10^{5} \\\\ 0 \\end{pmatrix}\\,$，单位为 $\\mathrm{N}$。\n\n从 $\\,\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)\\,$ 和时间导数的中心差分有限差分定义出发，推导并实现一个显式中心差分步，以计算下一步位移 $\\,\\mathbf{u}^{n+1}\\,$ 和中间步速度 $\\,\\dot{\\mathbf{u}}^{\\,n+1/2}\\,$。\n\n将您的最终数值答案表示为一个单行矩阵，其中包含按顺序排列的四个条目：$\\,u_{1}^{n+1}\\,$, $\\,u_{2}^{n+1}\\,$, $\\,\\dot{u}_{1}^{\\,n+1/2}\\,$, $\\,\\dot{u}_{2}^{\\,n+1/2}\\,$。位移使用米（$\\mathrm{m}$），速度使用米每秒（$\\mathrm{m/s}$）。无需四舍五入。最终的方框答案中不要包含单位。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个计算动力学中的适定问题，提供了所有必要的数据，没有内部矛盾或科学谬误。\n\n该两自由度系统的控制半离散运动方程如下：\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{f}(t)\n$$\n该方程在离散时间步 $t^n$ 进行计算，得到：\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}^{n} + \\mathbf{K}\\,\\mathbf{u}^{n} = \\mathbf{f}^{n}\n$$\n其中 $\\ddot{\\mathbf{u}}^{n} = \\ddot{\\mathbf{u}}(t^n)$，$\\mathbf{u}^{n} = \\mathbf{u}(t^n)$，且 $\\mathbf{f}^{n} = \\mathbf{f}(t^n)$。\n\n中心差分法对时间 $t^n$ 的加速度向量使用一个二阶有限差分近似，该近似以时间步 $n$ 为中心：\n$$\n\\ddot{\\mathbf{u}}^{n} \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^{n} + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n$$\n其中 $\\mathbf{u}^{n+1}$ 和 $\\mathbf{u}^{n-1}$ 分别是时间 $t^{n+1} = t^n + \\Delta t$ 和 $t^{n-1} = t^n - \\Delta t$ 时的位移向量。\n\n将此近似代入运动方程，得到全离散更新方程：\n$$\n\\mathbf{M} \\left( \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^{n} + \\mathbf{u}^{n-1}}{(\\Delta t)^2} \\right) + \\mathbf{K}\\mathbf{u}^{n} = \\mathbf{f}^{n}\n$$\n我们的目标是求解下一个时间步的位移 $\\mathbf{u}^{n+1}$。我们重新整理方程以分离出 $\\mathbf{u}^{n+1}$：\n$$\n\\mathbf{M} (\\mathbf{u}^{n+1} - 2\\mathbf{u}^{n} + \\mathbf{u}^{n-1}) = (\\Delta t)^2 (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\n$$\n\\mathbf{M}\\mathbf{u}^{n+1} = \\mathbf{M}(2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\n由于质量矩阵 $\\mathbf{M}$ 是一个对角（集总）矩阵，它很容易求逆。左乘 $\\mathbf{M}^{-1}$ 得到位移的显式更新公式：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{M}^{-1} \\left[ \\mathbf{M}(2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n}) \\right]\n$$\n或者，这可以写成：\n$$\n\\mathbf{u}^{n+1} = (2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 \\mathbf{M}^{-1} (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\n我们已知以下数据：\n- $\\mathbf{M} = \\begin{pmatrix} 2000  0 \\\\ 0  1000 \\end{pmatrix}\\,\\mathrm{kg}$\n- $\\mathbf{K} = \\begin{pmatrix} 5 \\times 10^{6}  0 \\\\ 0  5 \\times 10^{6} \\end{pmatrix}\\,\\mathrm{N/m}$\n- $\\Delta t = 0.01\\,\\mathrm{s}$\n- $\\mathbf{u}^{n} = \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix}\\,\\mathrm{m}$\n- $\\mathbf{u}^{n-1} = \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix}\\,\\mathrm{m}$\n- $\\mathbf{f}^{n} = \\begin{pmatrix} 3 \\times 10^{5} \\\\ 0 \\end{pmatrix}\\,\\mathrm{N}$\n\n首先，我们计算代表内力的项，$\\mathbf{f}_{\\text{int}}^{n} = \\mathbf{K}\\mathbf{u}^{n}$：\n$$\n\\mathbf{K}\\mathbf{u}^{n} = \\begin{pmatrix} 5 \\times 10^{6}  0 \\\\ 0  5 \\times 10^{6} \\end{pmatrix} \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix} = \\begin{pmatrix} (5 \\times 10^{6})(0.02) \\\\ (5 \\times 10^{6})(-0.01) \\end{pmatrix} = \\begin{pmatrix} 1 \\times 10^{5} \\\\ -5 \\times 10^{4} \\end{pmatrix}\\,\\mathrm{N}\n$$\n接下来，我们计算有效力向量，$\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n}$：\n$$\n\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n} = \\begin{pmatrix} 3 \\times 10^{5} \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1 \\times 10^{5} \\\\ -5 \\times 10^{4} \\end{pmatrix} = \\begin{pmatrix} 2 \\times 10^{5} \\\\ 5 \\times 10^{4} \\end{pmatrix}\\,\\mathrm{N}\n$$\n现在，我们计算项 $2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}$：\n$$\n2\\mathbf{u}^{n} - \\mathbf{u}^{n-1} = 2 \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix} - \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix} = \\begin{pmatrix} 0.04 \\\\ -0.02 \\end{pmatrix} - \\begin{pmatrix} 0.015 \\\\ -0.012 \\end{pmatrix} = \\begin{pmatrix} 0.025 \\\\ -0.008 \\end{pmatrix}\\,\\mathrm{m}\n$$\n逆质量矩阵是：\n$$\n\\mathbf{M}^{-1} = \\begin{pmatrix} 1/2000  0 \\\\ 0  1/1000 \\end{pmatrix} = \\begin{pmatrix} 0.0005  0 \\\\ 0  0.001 \\end{pmatrix}\\,\\mathrm{kg^{-1}}\n$$\n我们现在计算类加速度项，并预乘以 $(\\Delta t)^2$：\n$$\n(\\Delta t)^2 \\mathbf{M}^{-1} (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n}) = (0.01)^2 \\begin{pmatrix} 0.0005  0 \\\\ 0  0.001 \\end{pmatrix} \\begin{pmatrix} 2 \\times 10^{5} \\\\ 5 \\times 10^{4} \\end{pmatrix}\n$$\n$$\n= 10^{-4} \\begin{pmatrix} 0.0005 \\times (2 \\times 10^{5}) \\\\ 0.001 \\times (5 \\times 10^{4}) \\end{pmatrix} = 10^{-4} \\begin{pmatrix} 100 \\\\ 50 \\end{pmatrix} = \\begin{pmatrix} 0.01 \\\\ 0.005 \\end{pmatrix}\\,\\mathrm{m}\n$$\n最后，我们将这些结果代入 $\\mathbf{u}^{n+1}$ 的更新公式中：\n$$\n\\mathbf{u}^{n+1} = (2\\mathbf{u}^{n} - \\mathbf{u}^{n-1}) + (\\Delta t)^2 \\mathbf{M}^{-1} (\\mathbf{f}^{n} - \\mathbf{K}\\mathbf{u}^{n})\n$$\n$$\n\\mathbf{u}^{n+1} = \\begin{pmatrix} 0.025 \\\\ -0.008 \\end{pmatrix} + \\begin{pmatrix} 0.01 \\\\ 0.005 \\end{pmatrix} = \\begin{pmatrix} 0.035 \\\\ -0.003 \\end{pmatrix}\\,\\mathrm{m}\n$$\n因此，在时间 $t^{n+1}$ 时位移向量的分量是 $u_1^{n+1} = 0.035\\,\\mathrm{m}$ 和 $u_2^{n+1} = -0.003\\,\\mathrm{m}$。\n\n接下来，我们计算中间步速度向量 $\\dot{\\mathbf{u}}^{\\,n+1/2}$，它由以 $t^{n+1/2}$ 为中心的中心差分近似定义：\n$$\n\\dot{\\mathbf{u}}^{\\,n+1/2} = \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t}\n$$\n代入已知和计算出的值：\n$$\n\\dot{\\mathbf{u}}^{\\,n+1/2} = \\frac{1}{0.01} \\left( \\begin{pmatrix} 0.035 \\\\ -0.003 \\end{pmatrix} - \\begin{pmatrix} 0.02 \\\\ -0.01 \\end{pmatrix} \\right)\n$$\n$$\n\\dot{\\mathbf{u}}^{\\,n+1/2} = 100 \\begin{pmatrix} 0.015 \\\\ 0.007 \\end{pmatrix} = \\begin{pmatrix} 1.5 \\\\ 0.7 \\end{pmatrix}\\,\\mathrm{m/s}\n$$\n在时间 $t^{n+1/2}$ 时速度向量的分量是 $\\dot{u}_1^{\\,n+1/2} = 1.5\\,\\mathrm{m/s}$ 和 $\\dot{u}_2^{\\,n+1/2} = 0.7\\,\\mathrm{m/s}$。\n\n最终所求的量是四个标量：$u_{1}^{n+1}$、$u_{2}^{n+1}$、$\\dot{u}_{1}^{\\,n+1/2}$ 和 $\\dot{u}_{2}^{\\,n+1/2}$。这些值是 $u_1^{n+1} = 0.035$，$u_2^{n+1} = -0.003$，$\\dot{u}_1^{\\,n+1/2} = 1.5$，以及 $\\dot{u}_2^{\\,n+1/2} = 0.7$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.035  -0.003  1.5  0.7 \\end{pmatrix}}\n$$", "id": "3523947"}, {"introduction": "在单步计算的基础上，这项实践将挑战你为一个一维土体实现一个完整的动态模拟[@problem_id:3523936]。你不仅将在多个时间步上应用中心差分法，还将学习一种至关重要的验证技术：监测系统的能量。这个练习强调了能量守恒如何成为检验数值解稳定性和准确性的有力工具。", "problem": "考虑一个一维线性弹性土体块，其被建模为长度为 $L$、横截面积为 $A$、质量密度为 $\\rho$、杨氏模量为 $E$ 的杆。其左端固定，右端在有限时间内承受给定的瞬态法向牵引力 $T(t)$。使用包含 $N_{\\mathrm{e}}$ 个等长单元、集中质量且无阻尼的标准线性有限元半离散化方法，其半离散运动方程为\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}}(t) = \\mathbf{f}(t),\n$$\n其中 $\\mathbf{u}(t)$ 是自由度的节点位移向量，$\\mathbf{M}$ 是对角集中质量矩阵，$\\mathbf{K}$ 是刚度矩阵，$\\mathbf{f}(t)$ 是由右边界牵引力引起的外部节点力向量。设牵引力定义为正弦函数 $T(t) = T_{0}\\,\\sin(2\\pi f\\,t)$（当 $0 \\le t \\le t_{\\mathrm{load}}$ 时），其中 $t_{\\mathrm{load}} = n_{\\mathrm{cycles}}/f$；当 $t  t_{\\mathrm{load}}$ 时，$T(t) = 0$。相应的节点力仅作用于最右侧的自由度，其大小为 $F(t) = A\\,T(t)$。采用从静止状态开始初始化的中心差分显式时间积分方法，对运动进行积分，直至最终时间 $t_{\\mathrm{end}} = t_{\\mathrm{load}} + t_{\\mathrm{free}}$。\n\n从牛顿第二定律、一致性有限元半离散化和中心差分格式出发，完成以下任务：\n- 从第一性原理出发，推导节点位移 $\\mathbf{u}^{n+1}$ 关于 $\\mathbf{u}^{n}$、$\\mathbf{u}^{n-1}$、时间步长 $\\Delta t$ 和半离散算子的显式更新公式，假设为集中质量和零阻尼。\n- 使用基于弹性波速 $c = \\sqrt{E/\\rho}$ 和最小单元长度 $h = L/N_{\\mathrm{e}}$ 的 Courant-Friedrichs-Lewy (CFL) 型估计来指定一个稳定的时间步长，取 $\\Delta t = \\alpha \\, h / c$，其中给定安全系数 $\\alpha \\in (0,1]$。\n- 将整数时间 $t^{n} = n\\,\\Delta t$ 时的离散动能和应变能定义为\n$$\n\\mathcal{T}^{n} = \\tfrac{1}{2}\\,\\dot{\\mathbf{u}}^{n\\top}\\mathbf{M}\\,\\dot{\\mathbf{u}}^{n},\\qquad\n\\mathcal{U}^{n} = \\tfrac{1}{2}\\,\\mathbf{u}^{n\\top}\\mathbf{K}\\,\\mathbf{u}^{n},\n$$\n其中整数时间的节点速度通过中心差分近似为 $\\dot{\\mathbf{u}}^{n} \\approx \\left(\\mathbf{u}^{n+1} - \\mathbf{u}^{n-1}\\right)/(2\\,\\Delta t)$。\n- 对于无载荷阶段 $t \\ge t_{\\mathrm{load}}$，将由时间积分引起的数值能量误差量化为总离散机械能 $\\mathcal{E}^{n} = \\mathcal{T}^{n} + \\mathcal{U}^{n}$ 相对于其在载荷卸除时刻值的最大相对漂移。具体而言，令 $n_{0} = \\lceil t_{\\mathrm{load}}/\\Delta t \\rceil$ 并定义\n$$\n\\varepsilon_{\\max} = \\max_{n \\ge n_{0}} \\frac{\\left|\\mathcal{E}^{n} - \\mathcal{E}^{n_{0}}\\right|}{\\mathcal{E}^{n_{0}}}.\n$$\n\n实现一个完整、可运行的程序，该程序组装一维有限元模型，使用中心差分格式推进求解，计算时间历程 $\\{\\mathcal{T}^{n}\\}$ 和 $\\{\\mathcal{U}^{n}\\}$，并报告如上定义的数值能量误差 $\\varepsilon_{\\max}$。\n\n使用以下参数集的测试套件。所有参数均采用国际单位制 (SI)：长度单位为米，面积单位为平方米，质量密度单位为千克每立方米，杨氏模量单位为帕斯卡，牵引力单位为帕斯卡，时间单位为秒，频率单位为赫兹。对于每个测试，使用 $\\Delta t = \\alpha \\, h / c$ 计算时间步长，其中 $h = L/N_{\\mathrm{e}}$ 和 $c = \\sqrt{E/\\rho}$，并设置 $t_{\\mathrm{end}} = t_{\\mathrm{load}} + t_{\\mathrm{free}}$。\n\n- 测试 A (理想情况):\n  - $N_{\\mathrm{e}} = 50$, $L = 10.0$, $A = 1.0$, $\\rho = 2000.0$, $E = 1.0\\times 10^{8}$,\n  - $T_{0} = 1.0\\times 10^{5}$, $f = 10.0$, $n_{\\mathrm{cycles}} = 5$,\n  - $\\alpha = 0.8$, $t_{\\mathrm{free}} = 1.0$。\n\n- 测试 B (接近稳定边界):\n  - $N_{\\mathrm{e}} = 50$, $L = 10.0$, $A = 1.0$, $\\rho = 2000.0$, $E = 1.0\\times 10^{8}$,\n  - $T_{0} = 1.0\\times 10^{5}$, $f = 15.0$, $n_{\\mathrm{cycles}} = 8$,\n  - $\\alpha = 0.99$, $t_{\\mathrm{free}} = 1.0$。\n\n- 测试 C (较粗的网格和不同的材料):\n  - $N_{\\mathrm{e}} = 20$, $L = 10.0$, $A = 1.0$, $\\rho = 1800.0$, $E = 8.0\\times 10^{7}$,\n  - $T_{0} = 5.0\\times 10^{4}$, $f = 5.0$, $n_{\\mathrm{cycles}} = 4$,\n  - $\\alpha = 0.6$, $t_{\\mathrm{free}} = 1.5$。\n\n您的程序必须：\n- 为均匀的线性单元网格组装集中质量矩阵和刚度矩阵，\n- 通过消除相应的自由度来施加左端的固定边界条件，\n- 将右端牵引力 $T(t)$ 作为节点力 $F(t) = A\\,T(t)$ 施加在最右侧的自由度上，\n- 从静止状态 $\\mathbf{u}^{0} = \\mathbf{0}$ 和 $\\dot{\\mathbf{u}}^{0} = \\mathbf{0}$ 开始初始化，\n- 使用中心差分法积分至 $t_{\\mathrm{end}}$，\n- 在每个整数时间 $t^{n}$ 计算并存储 $\\mathcal{T}^{n}$ 和 $\\mathcal{U}^{n}$，\n- 在 $t \\in [t_{\\mathrm{load}}, t_{\\mathrm{end}}]$ 上计算 $\\varepsilon_{\\max}$。\n\n最终输出格式：\n- 程序应生成单行输出，其中包含数值能量误差结果，格式为方括号内的逗号分隔列表，顺序与上述测试一致。每个条目必须是对应于该测试用例的 $\\varepsilon_{\\max}$ 的浮点十进制数。例如，输出应类似于 $[\\varepsilon_{\\max}^{(A)},\\varepsilon_{\\max}^{(B)},\\varepsilon_{\\max}^{(C)}]$，不含其他文本。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它具有科学依据、提法恰当、客观，并包含推导唯一且有意义的解所需的所有必要信息。该问题是计算固体力学领域一个标准且重要的练习。\n\n### 1. 理论公式\n\n该问题要求使用有限元法 (FEM) 进行空间离散化和中心差分法进行时间积分，对一维线性弹性杆进行动力学分析。\n\n#### 1.1. 有限元半离散化\n\n连续系统被离散为 $N_{\\mathrm{e}}$ 个线性有限元，每个单元的长度为 $h = L/N_{\\mathrm{e}}$。这会产生一个包含 $N_{\\mathrm{e}}+1$ 个节点的系统。对于连接两个节点的单个单元，其单元刚度矩阵 $\\mathbf{k}^{(e)}$ 和单元集中质量矩阵 $\\mathbf{m}_{\\text{lumped}}^{(e)}$ 分别为：\n$$\n\\mathbf{k}^{(e)} = \\frac{EA}{h}\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix},\n\\qquad\n\\mathbf{m}_{\\text{lumped}}^{(e)} = \\frac{\\rho A h}{2}\n\\begin{pmatrix}\n1  0 \\\\\n0  1\n\\end{pmatrix}\n$$\n整体刚度矩阵 $\\mathbf{K}_{\\text{global}}$ 和质量矩阵 $\\mathbf{M}_{\\text{global}}$ 通过对所有 $N_{\\mathrm{e}}$ 个单元的贡献求和来组装。左端 ($x=0$) 的固定边界条件意味着节点0的位移为零。该自由度被消除，将系统简化为对应于节点 $1, \\dots, N_{\\mathrm{e}}$ 的 $N_{\\mathrm{e}}$ 个自由度。由此得到的简化矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$ (大小为 $N_{\\mathrm{e}} \\times N_{\\mathrm{e}}$) 如下：\n\n刚度矩阵 $\\mathbf{K}$ 是一个三对角矩阵，定义为：\n$$\nK_{ij} = \\frac{EA}{h} \\begin{cases}\n2  \\text{if } i=j, \\quad i \\in \\{0, \\dots, N_{\\mathrm{e}}-2\\} \\\\\n1  \\text{if } i=j=N_{\\mathrm{e}}-1 \\\\\n-1  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n集中质量矩阵 $\\mathbf{M}$ 是一个对角矩阵，其对角元为：\n$$\nM_{ii} = \\begin{cases}\n\\rho A h  \\text{if } i \\in \\{0, \\dots, N_{\\mathrm{e}}-2\\} \\\\\n\\frac{\\rho A h}{2}  \\text{if } i=N_{\\mathrm{e}}-1\n\\end{cases}\n$$\n这些索引 $i, j$ 的范围从 $0$ 到 $N_{\\mathrm{e}}-1$，对应于物理节点 $1$ 到 $N_{\\mathrm{e}}$。自由节点位移向量 $\\mathbf{u}(t)$ 的半离散运动方程为 $\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}}(t) = \\mathbf{f}(t)$。\n\n#### 1.2. 中心差分时间积分\n\n我们用一个恒定的时间步长 $\\Delta t$ 来离散化时间，使得 $t^n = n\\,\\Delta t$。中心差分法将在时间 $t^n$ 的位移的二阶时间导数（加速度）近似为：\n$$\n\\ddot{\\mathbf{u}}^n \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n$$\n将此近似代入半离散运动方程 $\\mathbf{M}\\,\\ddot{\\mathbf{u}}^n + \\mathbf{K}\\,\\mathbf{u}^n = \\mathbf{f}^n$，得到：\n$$\n\\mathbf{M}\\left(\\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\\right) + \\mathbf{K}\\,\\mathbf{u}^n = \\mathbf{f}^n\n$$\n为了求出下一个时间步的位移 $\\mathbf{u}^{n+1}$，我们重新整理该方程。这是一种显式格式，因为 $\\mathbf{u}^{n+1}$ 可以直接从 $t^n$ 和 $t^{n-1}$ 时刻的已知量求解。\n$$\n\\mathbf{M}\\,\\mathbf{u}^{n+1} = (\\Delta t)^2 \\left( \\mathbf{f}^n - \\mathbf{K}\\,\\mathbf{u}^n \\right) + 2\\mathbf{M}\\,\\mathbf{u}^n - \\mathbf{M}\\,\\mathbf{u}^{n-1}\n$$\n由于 $\\mathbf{M}$ 是对角（集中）矩阵，其逆矩阵 $\\mathbf{M}^{-1}$ 也是对角的且易于计算。两边乘以 $\\mathbf{M}^{-1}$ 得到显式更新公式：\n$$\n\\mathbf{u}^{n+1} = (\\Delta t)^2 \\mathbf{M}^{-1} \\left( \\mathbf{f}^n - \\mathbf{K}\\,\\mathbf{u}^n \\right) + 2\\mathbf{u}^n - \\mathbf{u}^{n-1}\n$$\n外力向量 $\\mathbf{f}^n$ 只有一个非零分量，位于对应最右侧节点的分量上，其大小为 $F(t^n) = A\\,T(t^n)$。\n\n#### 1.3. 初始化\n\n该格式从静止状态初始化，即 $\\mathbf{u}(0) = \\mathbf{u}^0 = \\mathbf{0}$ 和 $\\dot{\\mathbf{u}}(0) = \\dot{\\mathbf{u}}^0 = \\mathbf{0}$。更新公式需要一个在 $t^{-1}=-\\Delta t$ 时刻的“虚拟”位移 $\\mathbf{u}^{-1}$。我们通过在 $t^0=0$ 附近对 $\\mathbf{u}^{-1}$ 进行泰勒展开来获得：\n$$\n\\mathbf{u}^{-1} = \\mathbf{u}^0 - \\Delta t\\,\\dot{\\mathbf{u}}^0 + \\frac{(\\Delta t)^2}{2}\\ddot{\\mathbf{u}}^0\n$$\n在给定的初始条件 $\\mathbf{u}^0=\\mathbf{0}$ 和 $\\dot{\\mathbf{u}}^0=\\mathbf{0}$ 下，这简化为 $\\mathbf{u}^{-1} = \\frac{(\\Delta t)^2}{2}\\ddot{\\mathbf{u}}^0$。初始加速度 $\\ddot{\\mathbf{u}}^0$ 从 $t=0$ 时的运动方程中求得：$\\ddot{\\mathbf{u}}^0 = \\mathbf{M}^{-1}(\\mathbf{f}^0 - \\mathbf{K}\\mathbf{u}^0)$。外力函数为 $T(t) = T_0 \\sin(2\\pi f t)$，所以在 $t=0$ 时，$T(0)=0$ 且 $\\mathbf{f}^0=\\mathbf{0}$。又因为 $\\mathbf{u}^0=\\mathbf{0}$，这给出 $\\ddot{\\mathbf{u}}^0=\\mathbf{0}$。因此，所需的起始位移为 $\\mathbf{u}^{-1} = \\mathbf{0}$。积分从 $\\mathbf{u}^{-1} = \\mathbf{0}$ 和 $\\mathbf{u}^{0} = \\mathbf{0}$ 开始。\n\n#### 1.4. 稳定性和时间步长选择\n\n中心差分法是条件稳定的。对于用线性单元和集中质量矩阵离散化的一维波动方程，其稳定性由 Courant-Friedrichs-Lewy (CFL) 条件控制。临界时间步长与波穿过最小单元所需的时间有关。材料中的 P 波波速为 $c = \\sqrt{E/\\rho}$，单元长度为 $h = L/N_{\\mathrm{e}}$。稳定性极限为 $\\Delta t \\le h/c$。问题指定了一个基于此极限并带有安全系数 $\\alpha \\in (0, 1]$ 的时间步长：\n$$\n\\Delta t = \\alpha \\frac{h}{c} = \\alpha \\frac{L/N_{\\mathrm{e}}}{\\sqrt{E/\\rho}}\n$$\n这一选择确保了积分的数值稳定性。\n\n#### 1.5. 能量和误差计算\n\n在时间 $t^n$ 的离散动能 $\\mathcal{T}^n$ 和应变能 $\\mathcal{U}^n$ 定义为：\n$$\n\\mathcal{T}^{n} = \\tfrac{1}{2}\\,\\dot{\\mathbf{u}}^{n\\top}\\mathbf{M}\\,\\dot{\\mathbf{u}}^{n} \\quad \\text{其中} \\quad \\dot{\\mathbf{u}}^{n} = \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n-1}}{2\\,\\Delta t}\n$$\n$$\n\\mathcal{U}^{n} = \\tfrac{1}{2}\\,\\mathbf{u}^{n\\top}\\mathbf{K}\\,\\mathbf{u}^{n}\n$$\n总离散机械能为 $\\mathcal{E}^n = \\mathcal{T}^n + \\mathcal{U}^n$。外力施加到 $t_{\\mathrm{load}}$ 为止。对于 $t \\ge t_{\\mathrm{load}}$，系统是无阻尼且无外力的，其总能量在理想情况下应守恒。数值积分会引入误差，导致计算出的总能量发生漂移。通过将任意步 $n \\ge n_0$ 的总能量与参考能量 $\\mathcal{E}^{n_0}$ 进行比较来量化此数值误差，其中 $n_0 = \\lceil t_{\\mathrm{load}}/\\Delta t \\rceil$ 是移除载荷后的第一个时间步。最大相对能量误差为：\n$$\n\\varepsilon_{\\max} = \\max_{n \\ge n_{0}} \\frac{\\left|\\mathcal{E}^{n} - \\mathcal{E}^{n_{0}}\\right|}{\\mathcal{E}^{n_{0}}}\n$$\n在给定的步长 $n$ 计算 $\\mathcal{T}^n$ 需要来自下一步的位移 $\\mathbf{u}^{n+1}$，这在时间步进循环中更新后是可用的。\n\n### 2. 算法流程\n\n对每个给定的测试用例，通过以下步骤实现数值解：\n1.  **设置**：计算派生参数，如单元长度 $h$、波速 $c$ 和时间步长 $\\Delta t$。确定达到 $t_{\\text{end}}$ 所需的总步数 $N_{\\text{steps}}$。\n2.  **矩阵组装**：构建 $N_{\\mathrm{e}} \\times N_{\\mathrm{e}}$ 的简化刚度矩阵 $\\mathbf{K}$ 和简化集中质量矩阵 $\\mathbf{M}$ 的对角线。\n3.  **初始化**：将位移向量 $\\mathbf{u}^{\\text{prev}}$ (代表 $\\mathbf{u}^{n-1}$) 和 $\\mathbf{u}^{\\text{curr}}$ (代表 $\\mathbf{u}^{n}$) 初始化为大小为 $N_{\\mathrm{e}}$ 的零向量。\n4.  **时间积分**：从 $n=0$ 循环到 $N_{\\text{steps}}-1$：\n    a. 确定当前时间 $t^n = n\\,\\Delta t$。\n    b. 组装力向量 $\\mathbf{f}^n$。它在所有分量上都为零，除了最后一个分量，如果 $t^n \\le t_{\\mathrm{load}}$，其值为 $A T(t^n)$，否则为 $0$。\n    c. 使用中心差分更新公式计算下一个位移 $\\mathbf{u}^{\\text{next}}$ (代表 $\\mathbf{u}^{n+1}$)。\n    d. 使用 $\\mathbf{u}^{\\text{curr}}$ 计算并存储应变能 $\\mathcal{U}^n$。\n    e. 使用速度 $\\dot{\\mathbf{u}}^n = (\\mathbf{u}^{\\text{next}} - \\mathbf{u}^{\\text{prev}})/(2\\Delta t)$ 计算并存储动能 $\\mathcal{T}^n$。\n    f. 为下一次迭代更新位移向量：$\\mathbf{u}^{\\text{prev}} \\leftarrow \\mathbf{u}^{\\text{curr}}$ 和 $\\mathbf{u}^{\\text{curr}} \\leftarrow \\mathbf{u}^{\\text{next}}$。\n5.  **误差计算**：循环结束后，确定索引 $n_0 = \\lceil t_{\\mathrm{load}}/\\Delta t \\rceil$。提取参考能量 $\\mathcal{E}^{n_0}$。计算所有时间步 $n \\ge n_0$ 的最大相对能量误差 $\\varepsilon_{\\max}$。\n6.  **输出**：存储该测试用例计算出的 $\\varepsilon_{\\max}$。对所有测试用例重复此过程，并按指定格式输出结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(params):\n    \"\"\"\n    Solves the 1D wave equation for a single test case.\n    \"\"\"\n    # 1. Unpack parameters and calculate derived quantities\n    Ne, L, A, rho, E, T0, f, n_cycles, alpha, t_free = params\n\n    h = L / Ne  # Element length\n    c = np.sqrt(E / rho)  # Elastic wave speed\n    dt = alpha * h / c  # Time step\n\n    t_load = n_cycles / f\n    t_end = t_load + t_free\n    n_steps = int(np.ceil(t_end / dt))\n    \n    # 2. Assemble stiffness and mass matrices for free DOFs\n    \n    # Stiffness matrix K (Ne x Ne)\n    k_elem_stiff = E * A / h\n    K = np.zeros((Ne, Ne))\n    diag_val = 2 * k_elem_stiff\n    off_diag_val = -k_elem_stiff\n    \n    diag = np.full(Ne, diag_val)\n    diag[-1] = k_elem_stiff  # Last node is connected to only one element\n    \n    off_diag = np.full(Ne - 1, off_diag_val)\n    \n    K = np.diag(diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # Mass matrix M (lumped, diagonal)\n    m_diag = np.full(Ne, rho * A * h)\n    m_diag[-1] = 0.5 * rho * A * h  # End node has half the mass of an internal node\n    m_inv_diag = 1.0 / m_diag\n    \n    # 3. Initialization\n    u_prev = np.zeros(Ne) # Displacement at n-1\n    u_curr = np.zeros(Ne) # Displacement at n\n    \n    # Arrays to store energy history\n    kinetic_energy_hist = np.zeros(n_steps)\n    strain_energy_hist = np.zeros(n_steps)\n    \n    # Pre-compute constant for update rule\n    dt_sq = dt**2\n\n    # 4. Time integration loop\n    for n in range(n_steps):\n        t = n * dt\n        \n        # Assemble force vector f\n        f_vec = np.zeros(Ne)\n        if t = t_load:\n            # Sinusoidal traction applied at the rightmost free node\n            traction = T0 * np.sin(2 * np.pi * f * t)\n            f_vec[-1] = A * traction\n        \n        # Central difference update rule\n        # u_next = dt^2 * M_inv @ (f - K @ u_curr) + 2*u_curr - u_prev\n        # Since M_inv is diagonal, we use element-wise product.\n        internal_force = K @ u_curr\n        accel_term = m_inv_diag * (f_vec - internal_force)\n        u_next = dt_sq * accel_term + 2 * u_curr - u_prev\n\n        # Calculate energies at step n\n        # Strain energy: U^n = 1/2 * u_n^T * K * u_n\n        strain_energy_hist[n] = 0.5 * np.dot(u_curr, K @ u_curr)\n        \n        # Kinetic energy: T^n = 1/2 * v_n^T * M * v_n\n        v_n = (u_next - u_prev) / (2 * dt)\n        kinetic_energy_hist[n] = 0.5 * np.sum(m_diag * v_n**2)\n        \n        # Update displacements for the next step\n        u_prev = u_curr\n        u_curr = u_next\n        \n    # 5. Compute numerical energy error\n    total_energy_hist = kinetic_energy_hist + strain_energy_hist\n    \n    n0 = int(np.ceil(t_load / dt))\n    \n    # Ensure n0 is a valid index\n    if n0 >= n_steps:\n      # This can happen if t_load is very close to t_end\n      # In this case, there are no steps after the load is removed to measure error.\n      return 0.0\n\n    energy_ref = total_energy_hist[n0]\n    \n    if energy_ref == 0.0:\n        # If reference energy is zero, drift is considered zero.\n        return 0.0\n        \n    energy_free_phase = total_energy_hist[n0:]\n    \n    relative_error = np.abs(energy_free_phase - energy_ref) / energy_ref\n    \n    eps_max = np.max(relative_error)\n    \n    return eps_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A: Happy path\n        (50, 10.0, 1.0, 2000.0, 1.0e8, 1.0e5, 10.0, 5, 0.8, 1.0),\n        # Test B: Near stability boundary\n        (50, 10.0, 1.0, 2000.0, 1.0e8, 1.0e5, 15.0, 8, 0.99, 1.0),\n        # Test C: Coarser mesh and different material\n        (20, 10.0, 1.0, 1800.0, 8.0e7, 5.0e4, 5.0, 4, 0.6, 1.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3523936"}, {"introduction": "显式方法功能强大，但其稳定的时间步长往往非常小，从而限制了计算效率。最后的这项练习介绍了一种常用的加速技术——质量缩放（mass scaling），它可以增大时间步长[@problem_id:3523973]。你将学会如何审慎地应用这一技术，通过建立和使用定量指标来评估计算加速是否对系统动态响应的物理真实性造成不可接受的扭曲，从而在计算成本和工程精度之间取得平衡。", "problem": "考虑一个在计算岩土力学中使用的线性、无阻尼、小应变、双自由度（DOF）土柱理想化模型。设集中质量矩阵为 $M\\in\\mathbb{R}^{2\\times 2}$，对称正定刚度矩阵为 $K\\in\\mathbb{R}^{2\\times 2}$，外部节点力向量为 $f(t)\\in\\mathbb{R}^{2}$。动力学遵循牛顿第二定律 $M\\,\\ddot{u}(t)+K\\,u(t)=f(t)$，其中位移为 $u(t)\\in\\mathbb{R}^{2}$，速度为 $\\dot{u}(t)\\in\\mathbb{R}^{2}$，加速度为 $\\ddot{u}(t)\\in\\mathbb{R}^{2}$。将使用由 $\\dot{u}(t)$ 和 $\\ddot{u}(t)$ 的有限差分近似推导出的二阶精确中心差分格式进行显式时间积分；不假设任何阻尼。根据广义特征问题 $K\\phi_i=\\omega_i^2 M\\phi_i$（其中角频率 $\\omega_i0$，振型 $\\phi_i$ 被归一化），最大允许显式时间步长受最高角频率的限制。为保证显式格式的计算稳定性，使用根据此界限推断的临界时间步长的一部分。角度必须以弧度处理。\n\n为了增大稳定显式时间步长 $\\Delta t$，有时会应用质量缩放：$M\\rightarrow \\gamma M$，其中 $\\gamma\\geq 1$。这会统一减小所有角频率，从而增加临界时间步长。然而，过度的缩放会扭曲动力响应。您的任务是使用一个有原则的度量标准来评估候选缩放因子 $\\gamma$，以确保主导响应具有可接受的保真度。\n\n定义以下量：\n\n- 离散时间 $t_n$ 的动能为 $E_k(t_n)=\\frac{1}{2}\\,\\dot{u}(t_n)^{\\top} M\\,\\dot{u}(t_n)$，应变能为 $E_s(t_n)=\\frac{1}{2}\\,u(t_n)^{\\top} K\\,u(t_n)$。\n- 在静态荷载方向 $r\\in\\mathbb{R}^{2}$ 下，第 $i$ 阶振型的振型参与因子为 $\\nu_i=|\\phi_i^{\\top} M\\,r|$，归一化参与权重为 $w_i=\\nu_i/\\sum_j \\nu_j$。将具有最大 $w_i$ 的振型索引确定为主导振型索引 $i^\\star$。\n- 设频率失真度量为 $d_f(\\gamma)=\\left|\\frac{\\omega_{i^\\star}(\\gamma)}{\\omega_{i^\\star}(1)}-1\\right|$，其中 $\\omega_{i^\\star}(\\gamma)$ 是质量缩放 $M\\rightarrow \\gamma M$ 后的主导振型频率。\n- 设能量比度量为 $R_{\\max}(\\gamma)=\\max_{n} \\frac{E_k(t_n)}{E_s(t_n)}$，它是在模拟时间窗口内，使用带有缩放质量的显式中心差分法和临界界限的稳定时间步长分数计算得出的。\n\n基于这些，为候选 $\\gamma$ 采用以下接受标准：\n- 频率保真度：$d_f(\\gamma)\\leq \\varepsilon_f$。\n- 能量平衡：$R_{\\max}(\\gamma)\\leq \\beta_{\\max}$。\n- 振型参与保持：未缩放系统和缩放系统之间归一化参与权重的变化，$\\max_i |w_i(\\gamma)-w_i(1)|$，不超过一个小的容差 $\\tau_p$。\n\n使用以下基于物理的配置和单位实现显式中心差分积分，确保科学真实性：\n\n- 质量矩阵 $M=\\mathrm{diag}(m_1,m_2)$，其中 $m_1=\\$20000\\,$\\mathrm{kg}$，$m_2=\\$15000\\,$\\mathrm{kg}$。\n- 刚度参数 $k_1=\\$1.0\\times 10^{8}\\,$\\mathrm{N/m}$，$k_2=\\$0.5\\times 10^{8}\\,$\\mathrm{N/m}$，以及\n  $$K=\\begin{bmatrix}k_1+k_2  -k_2 \\\\ -k_2  k_2\\end{bmatrix}.$$\n- 荷载方向 $r=\\begin{bmatrix}0\\\\ 1\\end{bmatrix}$，力时程 $f(t)=q(t)\\,r$，其中\n  $$q(t)=\\begin{cases}A\\,\\sin\\!\\left(\\frac{\\pi\\,t}{T_p}\\right),  0\\le t\\le T_p,\\\\ 0,  tT_p,\\end{cases}$$\n  振幅 $A=\\$1.0\\times 10^{5}\\,$\\mathrm{N}$，脉冲持续时间 $T_p=\\$0.05\\,$\\mathrm{s}$。角度以弧度为单位。\n- 初始条件：$u(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix}$ 和 $\\dot{u}(0)=\\begin{bmatrix}0\\\\0\\end{bmatrix}$。\n- 总模拟时间 $T_{\\mathrm{end}}=\\$0.20\\,$\\mathrm{s}$。\n\n采用显式时间步长 $\\Delta t(\\gamma)=\\eta\\,\\Delta t_{\\mathrm{cr}}(\\gamma)$，其中 $\\Delta t_{\\mathrm{cr}}(\\gamma)$ 是根据质量缩放为 $\\gamma M$ 的系统的最大角频率计算出的临界时间步长界限，分数为 $\\eta=\\$0.95$。\n\n使用容差 $\\varepsilon_f=\\$0.10$（无量纲），$\\beta_{\\max}=\\$0.60$（无量纲），以及 $\\tau_p=\\$1.0\\times 10^{-12}$（无量纲）。对每个候选 $\\gamma$ 执行以下步骤：\n- 计算度量所需的 $(K,\\gamma M)$ 和 $(K,M)$ 的广义特征对。\n- 使用 $w_i(1)$ 确定 $i^\\star$。\n- 计算 $d_f(\\gamma)$。\n- 使用 $\\gamma M$ 和 $\\Delta t(\\gamma)$ 进行显式中心差分模拟，以获得在 $[0,T_{\\mathrm{end}}]$ 上的 $R_{\\max}(\\gamma)$。\n- 计算参与变化 $\\max_i |w_i(\\gamma)-w_i(1)|$。\n\n当且仅当所有三个标准都满足时，返回一个布尔值，指示 $\\gamma$ 是否可接受。\n\n测试套件：\n评估以下 $\\gamma$ 值的可接受性：\n- $\\gamma_1=\\$1.00$（基线，理想情况），\n- $\\gamma_2=\\$1.01$（近基线，小缩放），\n- $\\gamma_3=\\$1.21$（中等缩放，低于频率容差界限），\n- $\\gamma_4=\\$1.23456790$（接近频率容差极限的边界情况），\n- $\\gamma_5=\\$2.25$（较大缩放），\n- $\\gamma_6=\\$4.00$（强缩放，边缘情况）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_i$ 必须是一个布尔值，对应于 $\\gamma_i$ 在指定度量和容差下是否可接受。输出中不允许有任何其他文本。物理单位已在上面指定，但最终输出是无量纲的布尔值。", "solution": "所提供的问题要求对双自由度（2-DOF）系统的显式动力学模拟中的不同质量缩放因子 $\\gamma$ 进行全面验证。该验证基于三个标准：振型参与保持、主导振型的频率保真度以及动态能量平衡。该系统由二阶常微分方程 $M\\,\\ddot{u}(t)+K\\,u(t)=f(t)$ 控制，其中 $M$ 是质量矩阵，$K$ 是刚度矩阵，$u(t)$ 是位移向量，$f(t)$ 是外力向量。我们将为每个给定的 $\\gamma$ 系统地实施检查。\n\n首先，我们根据所提供的参数建立系统的矩阵。质量矩阵 $M$ 是一个对角（集中）矩阵，刚度矩阵 $K$ 表示两个自由度之间的耦合。\n对于 $\\gamma=1$ 的未缩放质量矩阵是 $M_{\\mathrm{base}} = \\mathrm{diag}(m_1, m_2)$，其中 $m_1=\\$20000\\,$\\mathrm{kg}$，$m_2=\\$15000\\,$\\mathrm{kg}$。\n$$ M_{\\mathrm{base}} = \\begin{bmatrix} 20000  0 \\\\ 0  15000 \\end{bmatrix} \\, \\mathrm{kg} $$\n刚度矩阵由 $k_1=\\$1.0\\times 10^{8}\\,$\\mathrm{N/m}$ 和 $k_2=\\$0.5\\times 10^{8}\\,$\\mathrm{N/m}$ 构造成：\n$$ K = \\begin{bmatrix} k_1+k_2  -k_2 \\\\ -k_2  k_2 \\end{bmatrix} = \\begin{bmatrix} 1.5\\times 10^8  -0.5\\times 10^8 \\\\ -0.5\\times 10^8  0.5\\times 10^8 \\end{bmatrix} \\, \\mathrm{N/m} $$\n质量缩放应用为 $M(\\gamma) = \\gamma M_{\\mathrm{base}}$。\n\n验证包括两个主要部分：基于系统特征属性的准静态分析，以及使用显式中心差分格式的完整动力学模拟。\n\n第一步是分析未缩放（$\\gamma=1$）和缩放（$\\gamma$）系统的特征结构。这是通过求解广义特征问题 $K\\phi_i=\\omega_i^2 M\\phi_i$ 来获得角频率 $\\omega_i$ 和特征向量（振型）$\\phi_i$ 来实现的。对于 $M=M(\\gamma)$，该问题的解产生 $\\omega_i(\\gamma)$ 和 $\\phi_i(\\gamma)$。特征向量被归一化，使得 $\\phi_i^\\top M \\phi_j = \\delta_{ij}$，这是一种标准的质量正交归一化。\n\n第一个接受标准是关于振型参与保持。对于静态荷载方向 $r$，振型参与因子 $\\nu_i$ 为 $\\nu_i = |\\phi_i^{\\top} M\\,r|$，归一化权重为 $w_i = \\nu_i/\\sum_j \\nu_j$。对于质量缩放的特定形式 $M \\to \\gamma M$，矩阵束 $(K, M)$ 的特征向量 $\\phi_i$ 保持不变。由于质量归一化约定，新的特征向量 $\\phi_i(\\gamma)$ 与未缩放的特征向量 $\\phi_i(1)$ 的关系为 $\\phi_i(\\gamma) = \\phi_i(1)/\\sqrt{\\gamma}$。因此，归一化参与权重是不变的：$w_i(\\gamma) = w_i(1)$。因此，在给定 $\\tau_p=\\$1.0\\times 10^{-12}$ 的情况下，检查 $\\max_i |w_i(\\gamma)-w_i(1)| \\le \\tau_p$ 将在数值精度范围内得到满足。\n\n第二个标准是频率保真度。主导振型（由 $i^\\star$ 索引）是具有最高参与权重 $w_{i^\\star}(1)$ 的振型。质量缩放 $\\gamma$ 将所有角频率减小一个因子 $1/\\sqrt{\\gamma}$，即 $\\omega_i(\\gamma) = \\omega_i(1)/\\sqrt{\\gamma}$。频率失真度量为 $d_f(\\gamma)=\\left|\\frac{\\omega_{i^\\star}(\\gamma)}{\\omega_{i^\\star}(1)}-1\\right| = |1/\\sqrt{\\gamma}-1|$。只有当 $d_f(\\gamma) \\leq \\varepsilon_f$ 时，候选 $\\gamma$ 才是可接受的，其中 $\\varepsilon_f=\\$0.10$。这对 $\\gamma$ 施加了一个上限：$\\gamma \\le (1/(1-\\varepsilon_f))^2 \\approx \\$1.2345679$。\n\n第三个标准涉及通过动力学模拟评估的能量平衡。系统的响应是使用显式二阶中心差分法计算的。在时间步 $n+1$ 处位移向量 $u$ 的更新规则源自运动方程的有限差分近似：\n$$ u_{n+1} = (\\Delta t)^2 M(\\gamma)^{-1} (f_n - K u_n) + 2u_n - u_{n-1} $$\n其中 $u_n = u(t_n)$，$f_n = f(t_n)$，$\\Delta t$ 是时间步长。该格式使用初始条件 $u(0)=0$ 和 $\\dot{u}(0)=0$ 进行初始化。这导致初始加速度 $\\ddot{u}(0)=0$ 和虚拟位移 $u_{-1}=u_0=0$。模拟进行总时间 $T_{\\mathrm{end}}=\\$0.20\\,$\\mathrm{s}$。必须选择时间步长 $\\Delta t(\\gamma)$ 以确保数值稳定性。此格式的临界时间步长为 $\\Delta t_{\\mathrm{cr}}(\\gamma) = 2/\\omega_{\\max}(\\gamma)$，其中 $\\omega_{\\max}(\\gamma)$ 是缩放系统的最高自振频率。我们使用一个稳定的时间步长 $\\Delta t(\\gamma) = \\eta\\,\\Delta t_{\\mathrm{cr}}(\\gamma)$，其中 $\\eta=0.95$。\n\n在整个模拟过程中，我们在每个时间步 $t_n$ 监控动能和应变能：\n$$ E_k(t_n)=\\frac{1}{2}\\,\\dot{u}(t_n)^{\\top} M(\\gamma)\\,\\dot{u}(t_n) \\quad \\text{和} \\quad E_s(t_n)=\\frac{1}{2}\\,u(t_n)^{\\top} K\\,u(t_n) $$\n速度 $\\dot{u}(t_n)$ 使用中心差分计算：$\\dot{u}_n = (u_{n+1} - u_{n-1})/(2\\Delta t)$。能量比度量是在模拟期间观察到的动能与应变能的最大比率，$R_{\\max}(\\gamma)=\\max_{n} \\{E_k(t_n)/E_s(t_n)\\}$。仅当 $E_s(t_n)$ 不可忽略时才计算此比率，以避免除以零。接受标准是 $R_{\\max}(\\gamma) \\leq \\beta_{\\max}$，其中 $\\beta_{\\max}=\\$0.60$。\n\n当且仅当所有三个标准都满足时，缩放因子 $\\gamma$ 才被视为可接受。为了提高计算效率，实现将对每个测试用例 $\\gamma_i$ 顺序评估这些标准，一旦某个标准被违反就立即返回 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to evaluate mass scaling factors and print results.\n    \"\"\"\n    \n    # Define physical configuration and simulation parameters\n    m1 = 20000.0\n    m2 = 15000.0\n    k1 = 1.0e8\n    k2 = 0.5e8\n    \n    M_base = np.diag([m1, m2])\n    K = np.array([[k1 + k2, -k2], [-k2, k2]])\n    \n    r = np.array([0., 1.])\n    A = 1.0e5\n    T_p = 0.05\n    T_end = 0.20\n    \n    # Define time integration and acceptance criteria parameters\n    eta = 0.95\n    eps_f = 0.10\n    beta_max = 0.60\n    tau_p = 1.0e-12\n\n    test_cases = [1.00, 1.01, 1.21, 1.23456790, 2.25, 4.00]\n\n    def q_force(t, A_amp, T_pulse):\n        \"\"\"Calculates the time-dependent part of the force.\"\"\"\n        if 0 = t = T_pulse:\n            return A_amp * np.sin(np.pi * t / T_pulse)\n        return 0.0\n\n    def get_eigenpairs(K_mat, M_mat):\n        \"\"\"\n        Solves the generalized eigenvalue problem K*phi = omega^2*M*phi.\n        Returns angular frequencies (omega) and mass-normalized eigenvectors (phi).\n        \"\"\"\n        eigvals, eigvecs = eigh(K_mat, M_mat)\n        omegas = np.sqrt(eigvals)\n        return omegas, eigvecs\n\n    def is_acceptable(gamma, M_base_mat, K_mat, r_vec, A_amp, T_pulse, T_sim_end, \n                      eta_frac, eps_f_tol, beta_max_tol, tau_p_tol):\n        \"\"\"\n        Checks if a given mass scaling factor gamma is acceptable based on three criteria.\n        \"\"\"\n        # --- 1. Eigen-analysis and Fidelity Checks ---\n        \n        # Unscaled system (gamma=1)\n        omegas_1, phis_1 = get_eigenpairs(K_mat, M_base_mat)\n        nu_1 = np.array([np.abs(phi.T @ M_base_mat @ r_vec) for phi in phis_1.T])\n        w_1 = nu_1 / np.sum(nu_1)\n        \n        # Scaled system\n        M_scaled = gamma * M_base_mat\n        omegas_g, phis_g = get_eigenpairs(K_mat, M_scaled)\n\n        # Criterion 3: Modal participation retention\n        nu_g = np.array([np.abs(phi.T @ M_scaled @ r_vec) for phi in phis_g.T])\n        w_g = nu_g / np.sum(nu_g)\n        participation_change = np.max(np.abs(w_g - w_1))\n        if participation_change > tau_p_tol:\n            return False\n            \n        # Criterion 1: Frequency fidelity\n        i_star = np.argmax(w_1)\n        omega_star_1 = omegas_1[i_star]\n        omega_star_g = omegas_g[i_star]\n        d_f = np.abs(omega_star_g / omega_star_1 - 1.0)\n        if d_f > eps_f_tol:\n            return False\n\n        # --- 2. Dynamic Simulation for Energy Check ---\n        omega_max_g = np.max(omegas_g)\n        dt_crit = 2.0 / omega_max_g\n        dt = eta_frac * dt_crit\n        num_steps = int(np.ceil(T_sim_end / dt))\n        \n        M_inv = np.linalg.inv(M_scaled)\n        \n        # Initial conditions: u(0)=0, u_dot(0)=0 => uddot(0)=0.\n        # Startup u(-1) = u(0) - dt*udot(0) + dt^2/2*uddot(0) = 0.\n        u_curr = np.zeros(2)\n        u_prev = np.zeros(2)\n        \n        R_max = 0.0\n        \n        for n in range(num_steps + 1):\n            t = n * dt\n            \n            # Force at current time step\n            f_n = q_force(t, A_amp, T_pulse) * r_vec\n            \n            # Central Difference displacement update\n            u_next = dt**2 * M_inv @ (f_n - K_mat @ u_curr) + 2 * u_curr - u_prev\n            \n            # Velocity at current step n\n            u_dot_curr = (u_next - u_prev) / (2.0 * dt)\n            \n            # Energies at current step n\n            E_s = 0.5 * u_curr.T @ K_mat @ u_curr\n            E_k = 0.5 * u_dot_curr.T @ M_scaled @ u_dot_curr\n            \n            # Update max energy ratio, avoiding division by zero\n            if E_s > 1e-15:\n                R_n = E_k / E_s\n                if R_n > R_max:\n                    R_max = R_n\n\n            # Advance time step\n            u_prev, u_curr = u_curr, u_next\n        \n        # Criterion 2: Energy balance\n        if R_max > beta_max_tol:\n            return False\n            \n        # All criteria passed\n        return True\n\n    results = []\n    for gamma in test_cases:\n        is_acc = is_acceptable(gamma, M_base, K, r, A, T_p, T_end, eta, eps_f, beta_max, tau_p)\n        results.append(is_acc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3523973"}]}