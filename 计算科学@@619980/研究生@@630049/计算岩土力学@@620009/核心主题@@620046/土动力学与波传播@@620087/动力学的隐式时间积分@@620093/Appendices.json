{"hands_on_practices": [{"introduction": "要有效运用一种数值方法，首先必须理解其精度的来源。本练习将引导你通过泰勒展开，亲自推导 Newmark-β 积分方法的局部截断误差，从而揭示积分参数 $\\beta$ 和 $\\gamma$ 是如何控制算法的精度阶次的。这项基本功训练有助于你深刻理解不同 Newmark 族成员（如平均加速度法和线性加速度法）的理论特性及其适用场景。[@problem_id:3532505]", "problem": "在计算地质力学中，考虑一个半离散土动力学模型的单自由度（DOF）分量，其运动学关系满足 $u'(t)=v(t)$ 和 $v'(t)=a(t)$。带有参数 $\\beta$ 和 $\\gamma$ 的 Newmark 时间积分法族通过以下标准运动学关系，在一个步长为 $\\Delta t>0$ 的均匀时间网格 $t_{n}$ 上更新位移、速度和加速度：\n$$\nu_{n+1}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\,a_{n+1},\\qquad\nv_{n+1}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\,a_{n+1}\\right),\n$$\n其中 $u_{n}\\equiv u(t_{n})$，$v_{n}\\equiv v(t_{n})$，$a_{n}\\equiv a(t_{n})$。定义由位移更新导出的算法加速度 $a_{n+1}^{\\text{alg}}$ 为通过代数求解位移关系式得到的 $a_{n+1}$ 的值：\n$$\na_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(u_{n+1}-u_{n}-\\Delta t\\,v_{n}\\right)-\\frac{\\frac{1}{2}-\\beta}{\\beta}\\,a_{n}.\n$$\n\n假设在一个步长内的精确位移是关于时间 $t_{n}$ 的四次多项式，\n$$\nu(t_{n}+\\tau)=u_{n}+v_{n}\\,\\tau+\\frac{1}{2}a_{n}\\,\\tau^{2}+\\frac{1}{6}j_{n}\\,\\tau^{3}+\\frac{1}{24}s_{n}\\,\\tau^{4},\n$$\n其中 $j_{n}\\equiv u^{(3)}(t_{n})$（急动度）和 $s_{n}\\equiv u^{(4)}(t_{n})$（跃度）在该时间步长内为常数。令 $u_{n+1}^{\\text{exact}}=u(t_{n}+\\Delta t)$，$v_{n+1}^{\\text{exact}}=v(t_{n}+\\Delta t)$，$a_{n+1}^{\\text{exact}}=a(t_{n}+\\Delta t)$。\n\n1. 仅使用运动学恒等式 $u'=v$ 和 $v'=a$，将 $u_{n+1}^{\\text{exact}}$、$v_{n+1}^{\\text{exact}}$ 和 $a_{n+1}^{\\text{exact}}$ 在 $t_{n}$ 处进行泰勒级数展开，直到控制局部截断误差的第一个非零项。\n2. 将这些展开式代入 Newmark 运动学更新公式，以获得单步局部误差 $E_{u}=u_{n+1}^{\\text{NM}}-u_{n+1}^{\\text{exact}}$、$E_{v}=v_{n+1}^{\\text{NM}}-v_{n+1}^{\\text{exact}}$ 和 $E_{a}=a_{n+1}^{\\text{alg}}-a_{n+1}^{\\text{exact}}$，表示为关于 $\\Delta t$ 的渐近级数，并保留每一项的第一个非零项。\n3. 根据这些表达式，验证关联 $\\beta$ 和 $\\gamma$ 的阶数条件，并确定唯一的参数对 $(\\beta,\\gamma)$，使得 Newmark 更新对于任意随时间呈三次变化的位移 $u(t)$（即当 $s_{n}=0$ 但 $j_{n}$ 可能非零时）在一个步长内是精确的，且该精确性对 $u_{n+1}$、$v_{n+1}$ 和 $a_{n+1}$ 同时成立。\n\n将你的最终答案表示为参数对 $(\\beta,\\gamma)$，使用 $\\mathrm{pmatrix}$ 格式的单行向量，无单位，不进行四舍五入。", "solution": "该问题陈述是分析常微分方程数值积分器的一个有效练习，特别是应用于计算动力学中的 Newmark-$\\beta$ 方法。它有科学依据，提法得当且客观。所有必要信息均已提供，任务定义明确。\n\n解答过程按问题陈述要求分为三部分。\n\n### 第一部分：精确解的泰勒级数展开\n\n给定在时间步 $[t_n, t_{n+1}]$ 内的精确位移是关于时间增量 $\\tau = t - t_n$ 的四次多项式：\n$$u(t_{n}+\\tau)=u_{n}+v_{n}\\,\\tau+\\frac{1}{2}a_{n}\\,\\tau^{2}+\\frac{1}{6}j_{n}\\,\\tau^{3}+\\frac{1}{24}s_{n}\\,\\tau^{4}$$\n其中 $u_n=u(t_n)$，$v_n=u'(t_n)$，$a_n=u''(t_n)$，$j_n=u^{(3)}(t_n)$，$s_n=u^{(4)}(t_n)$。\n\n使用运动学恒等式 $v(t) = u'(t)$ 和 $a(t) = v'(t)$，我们对 $u(t_n+\\tau)$ 的表达式关于 $\\tau$ 求导，以求得速度和加速度。\n\n速度为：\n$$v(t_{n}+\\tau) = \\frac{d}{d\\tau}u(t_{n}+\\tau) = v_{n}+a_{n}\\,\\tau+\\frac{1}{2}j_{n}\\,\\tau^{2}+\\frac{1}{6}s_{n}\\,\\tau^{3}$$\n\n加速度为：\n$$a(t_{n}+\\tau) = \\frac{d}{d\\tau}v(t_{n}+\\tau) = a_{n}+j_{n}\\,\\tau+\\frac{1}{2}s_{n}\\,\\tau^{2}$$\n\n为了求出时间步末端的精确值，我们令 $\\tau = \\Delta t$：\n$u_{n+1}^{\\text{exact}} = u(t_{n}+\\Delta t) = u_{n}+v_{n}\\,\\Delta t+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}$\n$v_{n+1}^{\\text{exact}} = v(t_{n}+\\Delta t) = v_{n}+a_{n}\\,\\Delta t+\\frac{1}{2}j_{n}\\,\\Delta t^{2}+\\frac{1}{6}s_{n}\\,\\Delta t^{3}$\n$a_{n+1}^{\\text{exact}} = a(t_{n}+\\Delta t) = a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}$\n\n### 第二部分：局部截断误差\n\n局部截断误差是在单一步长内产生的误差，假设步长开始时的所有值（$u_n$、$v_n$、$a_n$）都是精确的。为了求出 Newmark 更新的这一误差，我们将精确加速度 $a_{n+1}^{\\text{exact}}$ 代入该格式的方程中。\n\n**位移误差 ($E_u$)**\nNewmark 位移更新公式为：\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\,a_{n+1}$$\n将 $a_{n+1}$ 替换为 $a_{n+1}^{\\text{exact}}$：\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)$$\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\left(\\frac{1}{2}-\\beta+\\beta\\right)a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}$$\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}$$\n局部误差 $E_u = u_{n+1}^{\\text{NM}} - u_{n+1}^{\\text{exact}}$ 为：\n$$E_{u} = \\left(u_{n}+\\Delta t\\,v_{n}+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}\\right) - \\left(u_{n}+v_{n}\\,\\Delta t+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}\\right)$$\n$$E_{u} = \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3} + \\left(\\frac{1}{2}\\beta - \\frac{1}{24}\\right)s_{n}\\,\\Delta t^{4}$$\n假设 $j_n \\neq 0$，第一个非零项为 $E_{u} \\approx \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3}$。\n\n**速度误差 ($E_v$)**\nNewmark 速度更新公式为：\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\,a_{n+1}\\right)$$\n将 $a_{n+1}$ 替换为 $a_{n+1}^{\\text{exact}}$：\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)\\right)$$\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\left(1-\\gamma+\\gamma\\right)a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}$$\n$$v_{n+1}^{\\text{NM}}=v_{n}+a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}$$\n局部误差 $E_v = v_{n+1}^{\\text{NM}} - v_{n+1}^{\\text{exact}}$ 为：\n$$E_{v} = \\left(v_{n}+a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}\\right) - \\left(v_{n}+a_{n}\\,\\Delta t+\\frac{1}{2}j_{n}\\,\\Delta t^{2}+\\frac{1}{6}s_{n}\\,\\Delta t^{3}\\right)$$\n$$E_{v} = \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2} + \\left(\\frac{1}{2}\\gamma - \\frac{1}{6}\\right)s_{n}\\,\\Delta t^{3}$$\n假设 $j_n \\neq 0$，第一个非零项为 $E_{v} \\approx \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2}$。\n\n**加速度误差 ($E_a$)**\n算法加速度 $a_{n+1}^{\\text{alg}}$ 是通过将位移 $u_{n+1}$ 代入整理后的位移更新公式来定义的。为了求出其局部误差，我们代入精确位移 $u_{n+1}^{\\text{exact}}$：\n$$a_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(u_{n+1}^{\\text{exact}}-u_{n}-\\Delta t\\,v_{n}\\right)-\\frac{\\frac{1}{2}-\\beta}{\\beta}\\,a_{n}$$\n根据 $u_{n+1}^{\\text{exact}}$ 的展开式，我们有：\n$$u_{n+1}^{\\text{exact}}-u_{n}-\\Delta t\\,v_{n} = \\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}$$\n将此代入 $a_{n+1}^{\\text{alg}}$ 的表达式中：\n$$a_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}\\right) - \\left(\\frac{1}{2\\beta}-1\\right)a_n$$\n$$a_{n+1}^{\\text{alg}}=\\frac{a_{n}}{2\\beta}+\\frac{j_{n}}{6\\beta}\\Delta t+\\frac{s_{n}}{24\\beta}\\Delta t^{2} - \\frac{a_{n}}{2\\beta} + a_n$$\n$$a_{n+1}^{\\text{alg}}=a_{n} + \\frac{1}{6\\beta}j_{n}\\,\\Delta t + \\frac{1}{24\\beta}s_{n}\\,\\Delta t^{2}$$\n局部误差 $E_a = a_{n+1}^{\\text{alg}} - a_{n+1}^{\\text{exact}}$ 为：\n$$E_{a} = \\left(a_{n} + \\frac{1}{6\\beta}j_{n}\\,\\Delta t + \\frac{1}{24\\beta}s_{n}\\,\\Delta t^{2}\\right) - \\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)$$\n$$E_{a} = \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t + \\left(\\frac{1}{24\\beta}-\\frac{1}{2}\\right)s_{n}\\,\\Delta t^{2}$$\n假设 $j_n \\neq 0$，第一个非零项为 $E_{a} \\approx \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t$。\n\n### 第三部分：三次位移精确性的阶数条件\n\n问题要求该方法对于任何随时间呈三次变化的位移都是精确的。一个三次多项式 $u(t)$ 的四阶导数恒为零，即 $u^{(4)}(t) = s(t) = 0$。在我们的记法中，这意味着 $s_n=0$。为使该方法“精确”，当 $s_n=0$ 时，局部截断误差 $E_u$、$E_v$ 和 $E_a$ 必须全部为零。\n\n在误差表达式中令 $s_n=0$ 可得：\n$$E_{u} = \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3}$$\n$$E_{v} = \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2}$$\n$$E_{a} = \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t$$\n\n为了使这些误差对于任何三次位移都为零（即对于任何常数 $j_n \\neq 0$），每个表达式中 $j_n$ 的系数都必须为零。\n\n1.  对于 $E_u=0$：\n    $$\\beta - \\frac{1}{6} = 0 \\implies \\beta = \\frac{1}{6}$$\n2.  对于 $E_v=0$：\n    $$\\gamma - \\frac{1}{2} = 0 \\implies \\gamma = \\frac{1}{2}$$\n3.  对于 $E_a=0$（假设 $\\beta \\neq 0$）：\n    $$\\frac{1}{6\\beta} - 1 = 0 \\implies 1 = 6\\beta \\implies \\beta = \\frac{1}{6}$$\n\n关于 $\\beta$ 的条件在位移和加速度误差分析之间是一致的。为了同时满足所有三个精确性条件，我们必须有 $\\beta = \\frac{1}{6}$ 和 $\\gamma = \\frac{1}{2}$。这对参数对应于“线性加速度法”，已知该方法对于加速度随时间线性变化的系统是精确的（三次位移即属于这种情况）。\n\n因此，唯一的参数对 $(\\beta, \\gamma)$ 是 $\\left(\\frac{1}{6}, \\frac{1}{2}\\right)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6}  \\frac{1}{2}\n\\end{pmatrix}\n}\n$$", "id": "3532505"}, {"introduction": "理论上的精度并不能保证数值解的有效性，稳定性是另一个必须考量的关键因素。在这个计算实践中，你将构建一个层状土柱的有限元模型，并利用它来展示条件稳定积分格式（如线性加速度法）在时间步长过大时如何引发高频模式的数值不稳定。通过亲手实现并观察这一“吹飞”现象，你将具体地理解 Courant-Friedrichs-Lewy (CFL) 条件的实际意义，以及一致质量矩阵与集中质量矩阵对稳定性极限的不同影响。[@problem_id:3532530]", "problem": "考虑一维分层土柱的无阻尼轴向振动，该土柱被建模为由双节点线性杆单元组成的有限元链，其刚度随空间变化，形成刚-软-刚的三明治结构。其运动由半离散运动方程 $M \\ddot{u}(t) + K u(t) = 0$ 控制，其中 $M$ 是质量矩阵，$K$ 是刚度矩阵，$u(t)$ 是节点位移向量。该土柱底部节点为固定基底，顶部自由。您的任务是通过构建一个反例来演示 Newmark 线性加速度法的条件稳定性，在该反例中，当时间步长超过一个数值确定的稳定性阈值时，高频模态会发散。同时，诊断使用一致质量矩阵与集中质量矩阵对不稳定性的影响。\n\n您必须从第一性原理出发来构建模型和算法：\n\n1. 从牛顿第二定律以及运动学关系 $v(t) = \\frac{du}{dt}$ 和 $a(t) = \\frac{dv}{dt}$ 出发，为通过线性有限元离散化的杆的轴向振动写出半离散方程 $M \\ddot{u}(t) + K u(t) = 0$。使用双节点单元刚度 $k_e = \\frac{E A}{L_e}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$、一致单元质量 $m_e^{\\mathrm{cons}} = \\frac{\\rho A L_e}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$ 和集中单元质量 $m_e^{\\mathrm{lump}} = \\frac{\\rho A L_e}{2}\\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$。\n\n2. 将总长度为 $L_{\\mathrm{tot}} = 12\\,\\mathrm{m}$ 的土柱离散为 $N_e = 30$ 个等长单元，单元长度为 $L_e = \\frac{L_{\\mathrm{tot}}}{N_e}\\,\\mathrm{m}$。横截面积为 $A = 1\\,\\mathrm{m}^2$。所有层的质量密度均为 $\\rho = 2000\\,\\mathrm{kg/m^3}$。杨氏模量在底部刚性层 $z \\in [0\\,\\mathrm{m},4\\,\\mathrm{m}]$ 中为 $E = 10\\times 10^9\\,\\mathrm{Pa}$，在中间软土层 $z \\in (4\\,\\mathrm{m},8\\,\\mathrm{m}]$ 中为 $E = 10\\times 10^6\\,\\mathrm{Pa}$，在顶部刚性层 $z \\in (8\\,\\mathrm{m},12\\,\\mathrm{m}]$ 中为 $E = 10\\times 10^9\\,\\mathrm{Pa}$。在 $z=0$ 处施加固定基底（第一个节点位移为零），在 $z=12\\,\\mathrm{m}$ 处为自由顶部。\n\n3. 实现采用线性加速度参数 $\\beta = \\frac{1}{6}$ 和 $\\gamma = \\frac{1}{2}$ 的隐式 Newmark-$\\beta$ 法。从运动学定义推导离散的预测-校正关系，并使用 $M \\, a_{n+1} + K \\, u_{n+1} = 0$（无外力）来强制执行新时刻的动力平衡。制定并实现算法，该算法在给定时间 $t_n$ 的 $(u_n, v_n, a_n)$ 时，计算 $t_{n+1} = t_n + \\Delta t$ 时的 $(u_{n+1}, v_{n+1}, a_{n+1})$。\n\n4. 通过推导无量纲状态向量 $\\begin{bmatrix}u_n \\\\ \\Delta t\\, v_n\\end{bmatrix}$ 的二维放大映射来分析具有自振频率 $\\omega$ 的单自由度情形。该映射由无量纲步长 $h = \\omega \\Delta t$ 参数化，并使用给定的 $\\beta$ 和 $\\gamma$。数值确定最大的 $h_{\\mathrm{lim}}$，使得放大矩阵的谱半径不超过 $1$；这定义了 Newmark 线性加速度法的条件稳定性阈值。由此，计算多自由度系统对应的临界时间步长 $\\Delta t_{\\mathrm{lim}} = \\frac{h_{\\mathrm{lim}}}{\\omega_{\\max}}$，其中 $\\omega_{\\max}$ 是从广义特征值问题 $K \\phi = \\omega^2 M \\phi$ 中获得的最大自振频率。此步骤必须对一致质量模型和集中质量模型分别执行，因为 $\\omega_{\\max}$ 取决于 $M$。\n\n5. 在 $t=0$ 时，用所选质量模型的最高频率模态初始化系统，并缩放到单位 $M$-范数：设置 $u_0 = \\phi_{\\max}/\\sqrt{\\phi_{\\max}^\\top M \\phi_{\\max}}$，$v_0 = 0$，并从动力平衡 $M a_0 + K u_0 = 0$ 确定 $a_0$。积分 $N_{\\mathrm{steps}} = 300$ 步。定义 $M$-范数振幅增长率 $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\frac{\\|u_n\\|_{M}}{\\|u_0\\|_{M}}$，其中 $\\|u\\|_{M} = \\sqrt{u^\\top M u}$。\n\n6. 构建一个测试套件，使用三个无量纲乘子 $c \\in \\{0.8, 1.0, 1.2\\}$ 为每个质量模型（一致和集中，分别计算）指定时间步长为 $\\Delta t = c \\, \\Delta t_{\\mathrm{lim}}$。对于每个 $c$：\n   - 情况 A：一致质量矩阵。\n   - 情况 B：集中质量矩阵。\n   对于每种情况，如果 $R \\ge 10$，则声明“发散”（布尔值 $true$），否则声明“不发散”（布尔值 $false$）。\n\n7. 物理单位：所有长度以 $\\mathrm{m}$ 报告，密度以 $\\mathrm{kg/m^3}$ 报告，模量以 $\\mathrm{Pa}$ 报告，时间以 $\\mathrm{s}$ 报告。最终输出仅包含布尔值，因此输出值无需单位注释。\n\n8. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含三个条目，每个 $c$ 值对应一个，每个条目本身必须是一个双元素列表 $[b_{\\mathrm{cons}}, b_{\\mathrm{lump}}]$，分别包含一致质量和集中质量情况的布尔值。例如，一个有效的输出格式是 $[[true,false],[false,false],[true,true]]$。\n\n您的程序必须实现所有必要的步骤，组装有限元模型，从单自由度放大矩阵计算稳定性阈值，对多自由度系统针对指定情况运行 Newmark 积分，并以上述确切格式输出结果。", "solution": "该问题要求通过构建一个计算反例来演示 Newmark-$\\beta$ 线性加速度法的条件稳定性。我们使用有限元方法模拟一维分层土柱的轴向振动。通过用系统的最高频率模态激励系统，并观察在理论稳定性极限以下、之上和临界点处的时间步长下的行为来测试稳定性。该分析将针对一致质量矩阵和集中质量矩阵两种 formulation 分别进行。\n\n半离散化系统无阻尼自由振动的控制方程为：\n$$\nM \\ddot{u}(t) + K u(t) = 0\n$$\n其中 $M$ 是全局质量矩阵，$K$ 是全局刚度矩阵，$u(t)$ 是节点位移向量。$\\ddot{u}(t)$ 是节点加速度向量。\n\n首先，我们构建有限元模型。总长度为 $L_{\\mathrm{tot}} = 12\\,\\mathrm{m}$ 的土柱被离散为 $N_e = 30$ 个双节点线性杆单元，每个单元长度为 $L_e = L_{\\mathrm{tot}} / N_e = 0.4\\,\\mathrm{m}$。这导致了 $N_n = N_e + 1 = 31$ 个节点。整个土柱的横截面积为 $A = 1\\,\\mathrm{m}^2$，质量密度为 $\\rho = 2000\\,\\mathrm{kg/m^3}$。杨氏模量 $E$ 随深度 $z$ 变化。\n对于每个单元，我们根据其位置确定其材料属性。如果一个单元的中点位于某一层内，则认为该单元属于该层。刚度分布如下：\n-   刚性层 ($E = 10 \\times 10^9\\,\\mathrm{Pa}$): $z \\in [0\\,\\mathrm{m}, 4\\,\\mathrm{m}]$，对应单元 $1$ 到 $10$。\n-   软土层 ($E = 10 \\times 10^6\\,\\mathrm{Pa}$): $z \\in (4\\,\\mathrm{m}, 8\\,\\mathrm{m}]$，对应单元 $11$ 到 $20$。\n-   刚性层 ($E = 10 \\times 10^9\\,\\mathrm{Pa}$): $z \\in (8\\,\\mathrm{m}, 12\\,\\mathrm{m}]$，对应单元 $21$ 到 $30$。\n\n单元刚度矩阵 $k_e$ 由下式给出：\n$$\nk_e = \\frac{EA}{L_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n考虑两种不同的单元质量矩阵：一致质量矩阵 $m_e^{\\mathrm{cons}}$ 和集中（对角）质量矩阵 $m_e^{\\mathrm{lump}}$。\n$$\nm_e^{\\mathrm{cons}} = \\frac{\\rho A L_e}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} \\quad \\text{和} \\quad m_e^{\\mathrm{lump}} = \\frac{\\rho A L_e}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n$$\n全局矩阵 $K$ 和 $M$（包括一致和集中两种情况）是通过将所有 $N_e = 30$ 个单元的贡献相加来组装的。系统在基底（$z=0$）处固定，这对应于将第一个节点的位移设置为零（$u_1=0$）。此边界条件通过从全局矩阵中移除第一行和第一列来施加，从而得到 $30 \\times 30$ 大小的简化矩阵。\n\n接下来，我们使用 Newmark-$\\beta$ 方法处理时间积分。线性加速度法指定的参数是 $\\beta = 1/6$ 和 $\\gamma = 1/2$。从时间步 $n$到 $n+1$ 的位移 $u$ 和速度 $v$ 的更新规则是：\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + (\\Delta t)^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right]\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1-\\gamma) a_n + \\gamma a_{n+1} \\right]\n$$\n为了找到未知的加速度 $a_{n+1}$，我们在时间 $t_{n+1}$ 施加运动方程：$M a_{n+1} + K u_{n+1} = 0$。将 $u_{n+1}$ 的表达式代入此方程，得到关于 $a_{n+1}$ 的线性系统：\n$$\n\\left( M + \\beta (\\Delta t)^2 K \\right) a_{n+1} = -K \\left[ u_n + \\Delta t \\, v_n + (\\Delta t)^2 \\left( \\frac{1}{2} - \\beta \\right) a_n \\right]\n$$\n在每个时间步求解该系统以找到 $a_{n+1}$，然后通过更新规则计算 $u_{n+1}$ 和 $v_{n+1}$。\n\n该方法的稳定性是有条件的。对于具有自振频率 $\\omega$ 的单自由度（SDOF）系统，稳定性由放大矩阵的谱半径控制，该矩阵将状态向量从一个时间步映射到下一个。对于线性加速度法（$\\beta=1/6, \\gamma=1/2$），该方法在振幅衰减方面是无条件稳定的（它没有数值阻尼），但对于大的时间步长，谱半径可能超过 $1$，导致数值不稳定性。稳定性极限出现在无量纲时间步长 $h = \\omega \\Delta t$。当 $h^2 \\le 12$ 时，放大矩阵的特征值保持在单位圆上。对于 $h^2 > 12$，一个特征值变为实数且其模大于 $1$，导致指数增长。因此，稳定性极限是 $h_{\\text{lim}} = \\sqrt{12}$。\n\n对于多自由度（MDOF）系统，稳定性由系统的最高自振频率 $\\omega_{\\max}$ 控制。临界时间步长由下式给出：\n$$\n\\Delta t_{\\mathrm{lim}} = \\frac{h_{\\mathrm{lim}}}{\\omega_{\\max}} = \\frac{\\sqrt{12}}{\\omega_{\\max}}\n$$\n$\\omega_{\\max}$ 通过求解广义特征值问题 $K \\phi = \\omega^2 M \\phi$ 找到。由于 $\\omega_{\\max}$ 取决于质量矩阵 $M$，我们必须为一致质量和集中质量 formulation 分别计算 $\\Delta t_{\\mathrm{lim}}$。通常，一致质量矩阵会导致更高的 $\\omega_{\\max}$，从而导致更严格（更小）的 $\\Delta t_{\\mathrm{lim}}$，相比于集中质量矩阵。\n\n为了演示不稳定性，我们用系统的最高频率模态来初始化系统，因为不稳定性在该模态下最为显著。初始位移设置为相应的特征向量 $\\phi_{\\max}$，并缩放至单位 $M$-范数：$u_0 = \\phi_{\\max} / \\sqrt{\\phi_{\\max}^\\top M \\phi_{\\max}}$。初始速度为零，$v_0 = 0$。初始加速度由运动方程得到：$a_0 = -M^{-1}K u_0 = -\\omega_{\\max}^2 u_0$。然后，系统使用时间步长 $\\Delta t = c \\cdot \\Delta t_{\\mathrm{lim}}$（其中乘子 $c \\in \\{0.8, 1.0, 1.2\\}$）积分 $N_{\\mathrm{steps}} = 300$ 步。\n\n使用比率 $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\frac{\\|u_n\\|_{M}}{\\|u_0\\|_{M}}$ 来监测振幅增长。由于 $\\|u_0\\|_{M}=1$，这简化为 $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\|u_n\\|_{M}$。如果 $R \\ge 10$，则宣布“发散”。对于 $c \\le 1.0$，该方法是稳定的，我们预期 $R \\approx 1$。对于 $c > 1.0$，该方法不稳定，我们预计会出现指数增长，导致 $R \\ge 10$。以下程序实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the problem of demonstrating conditional stability of the Newmark-beta method\n    for a 1D layered soil column.\n    \"\"\"\n\n    # 1. Define physical and numerical parameters\n    L_TOT = 12.0  # m\n    N_E = 30\n    L_E = L_TOT / N_E  # m\n    A = 1.0  # m^2\n    RHO = 2000.0  # kg/m^3\n    E_STIFF = 10e9  # Pa\n    E_SOFT = 10e6  # Pa\n    N_NODES = N_E + 1\n    N_DOF = N_NODES - 1  # After applying fixed base BC\n\n    NEWMARK_BETA = 1/6\n    NEWMARK_GAMMA = 1/2\n    N_STEPS = 300\n    BLOWUP_RATIO = 10.0\n    C_MULTIPLIERS = [0.8, 1.0, 1.2]\n\n    # Stability limit for linear acceleration method (h_lim = omega * dt_lim)\n    H_LIM = np.sqrt(12.0)\n\n    # 2. Assemble FEM matrices\n    K_global = np.zeros((N_NODES, N_NODES))\n    M_cons_global = np.zeros((N_NODES, N_NODES))\n    M_lump_global = np.zeros((N_NODES, N_NODES))\n\n    # Element mass matrices (constant for all elements)\n    m_e_cons = (RHO * A * L_E / 6.0) * np.array([[2, 1], [1, 2]])\n    m_e_lump = (RHO * A * L_E / 2.0) * np.array([[1, 0], [0, 1]])\n\n    for i in range(N_E):\n        # Determine Young's modulus based on element midpoint\n        midpoint_z = (i + 0.5) * L_E\n        if 4.0  midpoint_z = 8.0:\n            E = E_SOFT\n        else:\n            E = E_STIFF\n\n        # Element stiffness matrix\n        k_e = (E * A / L_E) * np.array([[1, -1], [-1, 1]])\n\n        # Assemble into global matrices\n        nodes = np.array([i, i + 1])\n        K_global[np.ix_(nodes, nodes)] += k_e\n        M_cons_global[np.ix_(nodes, nodes)] += m_e_cons\n        M_lump_global[np.ix_(nodes, nodes)] += m_e_lump\n\n    # 3. Apply boundary condition (fixed base at z=0, node 0)\n    K = K_global[1:, 1:]\n    M_cons = M_cons_global[1:, 1:]\n    M_lump = M_lump_global[1:, 1:]\n\n    mass_matrices = {\n        'consistent': M_cons,\n        'lumped': M_lump\n    }\n\n    final_results = []\n\n    for c in C_MULTIPLIERS:\n        case_results = []\n        for mass_type in ['consistent', 'lumped']:\n            M = mass_matrices[mass_type]\n\n            # 4. Solve generalized eigenvalue problem for max frequency and mode\n            eigvals, eigvecs = eigh(K, M)\n            omega_sq_max = np.max(eigvals)\n            omega_max = np.sqrt(omega_sq_max)\n            phi_max = eigvecs[:, np.argmax(eigvals)]\n\n            # 5. Set time step and initial conditions\n            dt_lim = H_LIM / omega_max\n            dt = c * dt_lim\n\n            # ICs: a) Normalize highest mode to unit M-norm\n            m_norm_phi_max = np.sqrt(phi_max.T @ M @ phi_max)\n            u = phi_max / m_norm_phi_max\n            # ICs: b) Zero velocity, c) Eqm acceleration\n            v = np.zeros(N_DOF)\n            a = -omega_sq_max * u\n\n            # 6. Perform Newmark time integration\n            max_m_norm = 1.0  # Initial norm is 1.0\n\n            # Pre-compute effective stiffness matrix\n            K_eff = M + NEWMARK_BETA * dt**2 * K\n            K_eff_inv = np.linalg.inv(K_eff)\n\n            for _ in range(N_STEPS):\n                # Solve for new acceleration\n                f_eff = -K @ (u + dt * v + (0.5 - NEWMARK_BETA) * dt**2 * a)\n                a_new = K_eff_inv @ f_eff\n                \n                # Update displacement and velocity\n                u_new = u + dt * v + dt**2 * ((0.5 - NEWMARK_BETA) * a + NEWMARK_BETA * a_new)\n                v_new = v + dt * ((1.0 - NEWMARK_GAMMA) * a + NEWMARK_GAMMA * a_new)\n\n                u, v, a = u_new, v_new, a_new\n\n                # Calculate M-norm and update maximum\n                current_m_norm = np.sqrt(u.T @ M @ u)\n                if current_m_norm > max_m_norm:\n                    max_m_norm = current_m_norm\n\n            # 7. Check for blow-up and record result\n            is_blowup = max_m_norm >= BLOWUP_RATIO\n            case_results.append(is_blowup)\n        \n        final_results.append(case_results)\n\n    # 8. Format and print the final output\n    output_str = ','.join([f\"[{str(sub[0]).lower()},{str(sub[1]).lower()}]\" for sub in final_results])\n    print(f\"[{output_str}]\")\n\n\nsolve()\n\n```", "id": "3532530"}, {"introduction": "在工程实践中，我们不仅关心名义参数下的系统响应，更关心响应如何随参数不确定性而变化。本练习将带领你从标准的动力学模拟走向更高级的灵敏度分析，你将推导并实现直接微分法，以计算系统响应对物理参数（质量、刚度）和数值参数（$\\beta$, $\\gamma$）的梯度。掌握这项技术能让你量化不确定性传播，为结构的稳健设计和可靠性评估提供关键的定量依据。[@problem_id:3532506]", "problem": "一个受基底加速度激励的单自由度线性地质力学振子，其运动由牛顿第二定律决定\n$$\nM \\, \\ddot{u}(t) + C \\, \\dot{u}(t) + K \\, u(t) = f(t),\n$$\n其中 $M$ 是质量，$C$ 是粘性阻尼系数，$K$ 是刚度，$u(t)$ 是相对位移，$\\dot{u}(t)$ 是速度，$\\ddot{u}(t)$ 是加速度，$f(t)$ 是外力。对于一个单自由度基底激励系统，取\n$$\nf(t) = - M \\, a_g(t),\n$$\n其中 $a_g(t)$ 是给定的地面加速度。考虑使用参数为 $\\beta$ 和 $\\gamma$、均匀时间步长为 $\\Delta t$ 的隐式 Newmark-$\\beta$ 时间积分法，初始条件为 $u(0)=0$，$\\dot{u}(0)=0$。使用一致初始加速度 $\\ddot{u}(0) = \\frac{f(0) - C \\, \\dot{u}(0) - K \\, u(0)}{M}$。\n\n基准物理参数为\n$$\nM_0 = 1000 \\,\\, \\text{kg}, \\quad K_0 = 10^7 \\,\\, \\text{N/m}, \\quad \\zeta_0 = 0.05,\n$$\n并定义基准阻尼系数为\n$$\nC_0 = 2 \\, \\zeta_0 \\, \\sqrt{K_0 \\, M_0}.\n$$\n通过三个无量纲标量 $a_m$、$a_c$ 和 $a_k$ 引入参数不确定性和设计缩放，使得\n$$\nM = a_m \\, M_0, \\quad C = a_c \\, C_0, \\quad K = a_k \\, K_0.\n$$\n地面加速度规定为\n$$\na_g(t) = 0.5 \\, g \\, \\sin(2\\pi f \\, t),\n$$\n其中 $g = 9.81 \\,\\, \\text{m/s}^2$ 且 $f = 5 \\,\\, \\text{Hz}$。使用均匀时间步长 $\\Delta t = 0.001 \\,\\, \\text{s}$ 和总时长 $T = 1.0 \\,\\, \\text{s}$。\n\n任务：\n1. 从隐式 Newmark-$\\beta$ 方法的基本定义和运动方程出发，推导出每个时间步的离散平衡更新方程，以及从 $u_n$、$\\dot{u}_n$ 和 $\\ddot{u}_n$ 计算 $u_{n+1}$、$\\dot{u}_{n+1}$ 和 $\\ddot{u}_{n+1}$ 所需的关联等效系统。\n2. 对全离散方程应用链式法则，推导出一阶灵敏度递推关系，该关系随时间传播位移响应相对于参数 $(\\beta, \\gamma, a_m, a_c, a_k)$ 的梯度。确保灵敏度初始条件与给定的初始条件和外力一致。\n3. 将最终时刻的位移定义为标量响应泛函，\n$$\nJ(\\beta, \\gamma, a_m, a_c, a_k) = u_N,\n$$\n其中 $N = T / \\Delta t$ 是时间步数。推导通过灵敏度递推计算梯度 $\\nabla J = \\left[\\frac{\\partial J}{\\partial \\beta}, \\frac{\\partial J}{\\partial \\gamma}, \\frac{\\partial J}{\\partial a_m}, \\frac{\\partial J}{\\partial a_c}, \\frac{\\partial J}{\\partial a_k}\\right]$ 所需的表达式。\n4. 假设参数 $(a_m, a_c, a_k)$ 的不确定性是相互独立的，并由已知的标准差 $(\\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k})$ 表征。使用一阶线性化方法，估计响应泛函的标准差，\n$$\n\\sigma_J \\approx \\sqrt{\\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2 }.\n$$\n\n实现一个完整的、可运行的程序，对下面的每个测试案例，计算并报告：\n- 最终位移 $J$（单位：米），\n- 梯度分量 $\\frac{\\partial J}{\\partial \\beta}$、$\\frac{\\partial J}{\\partial \\gamma}$、$\\frac{\\partial J}{\\partial a_m}$、$\\frac{\\partial J}{\\partial a_c}$、$\\frac{\\partial J}{\\partial a_k}$（所有分量单位均为米，因为参数是无量纲的），\n- 估计的标准差 $\\sigma_J$（单位：米）。\n\n所有位移和派生量必须以米表示。如果您的实现中出现角度，必须使用弧度。不要使用百分号；任何小数都必须以十进制形式报告。\n\n测试套件（三个案例）：\n- A案例（平均加速度法，基准缩放）：$(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(0.25, 0.5, 1.0, 1.0, 1.0, 0.05, 0.05, 0.05\\right)$。\n- B案例（线性加速度法变体，减小阻尼缩放）：$(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(\\frac{1}{6}, 0.5, 1.0, 0.2, 1.0, 0.1, 0.05, 0.05\\right)$。\n- C案例（非经典参数集，增大刚度和质量缩放）：$(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(0.3, 0.6, 1.2, 1.0, 1.5, 0.02, 0.02, 0.02\\right)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例对应一个包含七个浮点数的子列表，顺序如下：\n$$\n\\left[ J, \\, \\frac{\\partial J}{\\partial \\beta}, \\, \\frac{\\partial J}{\\partial \\gamma}, \\, \\frac{\\partial J}{\\partial a_m}, \\, \\frac{\\partial J}{\\partial a_c}, \\, \\frac{\\partial J}{\\partial a_k}, \\, \\sigma_J \\right].\n$$\n因此，总输出必须是\n$$\n\\big[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\big].\n$$", "solution": "该问题要求对一个受基底激励的单自由度（SDOF）线性振子，推导并实现一种直接微分灵敏度分析方法，该振子使用隐式 Newmark-$\\beta$ 方法进行时间积分。最终目标是计算最终时刻的位移、其相对于系统和数值参数的梯度，以及响应标准差的一阶估计。\n\n运动控制方程为：\n$$\nM \\ddot{u}(t) + C \\dot{u}(t) + K u(t) = f(t)\n$$\n其中由基底加速度 $a_g(t)$ 引起的激励项为 $f(t) = -M a_g(t)$。初始条件为 $u(0)=0$ 和 $\\dot{u}(0)=0$。一致初始加速度为 $\\ddot{u}(0) = (f(0) - C\\dot{u}(0) - K u(0))/M$。给定 $f(t) = -M \\cdot 0.5g \\sin(2\\pi f t)$，则 $f(0)=0$，这导致 $\\ddot{u}(0)=0$。因此，初始状态为 $(u_0, \\dot{u}_0, \\ddot{u}_0)=(0,0,0)$。\n\n系统参数由应用于基准值 $(M_0, C_0, K_0)$ 的缩放因子 $(a_m, a_c, a_k)$ 定义。\n$M = a_m M_0$，$C = a_c C_0$，$K = a_k K_0$。\n\n令 $\\mathbf{p} = (\\beta, \\gamma, a_m, a_c, a_k)$ 为灵敏度分析的参数向量。\n\n### 任务1：离散平衡更新 (Newmark-$\\beta$ 方法)\n\n隐式 Newmark-$\\beta$ 方法基于 $t_n$ 时刻的状态和 $t_{n+1}$ 时刻的加速度 $\\ddot{u}_{n+1}$ 来定义时间步 $t_{n+1} = t_n + \\Delta t$ 的位移 $u_{n+1}$ 和速度 $\\dot{u}_{n+1}$：\n$$\nu_{n+1} = u_n + \\Delta t \\dot{u}_n + \\left(\\frac{1}{2} - \\beta\\right) \\Delta t^2 \\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1} \\\\\n\\dot{u}_{n+1} = \\dot{u}_n + (1 - \\gamma) \\Delta t \\ddot{u}_n + \\gamma \\Delta t \\ddot{u}_{n+1}\n$$\n运动方程必须在时刻 $t_{n+1}$ 成立：\n$$\nM \\ddot{u}_{n+1} + C \\dot{u}_{n+1} + K u_{n+1} = f_{n+1}\n$$\n为了求解第 $n+1$ 步的未知量，我们首先用未知位移 $u_{n+1}$ 和第 $n$ 步的已知量来表示 $\\ddot{u}_{n+1}$ 和 $\\dot{u}_{n+1}$。从第一个 Newmark 方程中，我们分离出 $\\ddot{u}_{n+1}$：\n$$\n\\ddot{u}_{n+1} = \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} \\dot{u}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n\n$$\n将此代入速度更新方程，得到用 $u_{n+1}$ 表示的 $\\dot{u}_{n+1}$：\n$$\n\\dot{u}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (u_{n+1} - u_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right) \\dot{u}_n + \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right) \\ddot{u}_n\n$$\n现在，将 $\\ddot{u}_{n+1}$ 和 $\\dot{u}_{n+1}$ 的表达式代入运动方程，得到一个关于单一未知数 $u_{n+1}$ 的线性系统：\n$$\n\\left(K + \\frac{\\gamma}{\\beta \\Delta t} C + \\frac{1}{\\beta \\Delta t^2} M\\right) u_{n+1} = f_{n+1} + M\\left(\\dots\\right) + C\\left(\\dots\\right)\n$$\n这就是离散平衡更新，可以写成等效系统的形式：\n$$\n\\hat{K} u_{n+1} = \\hat{f}_{n+1}\n$$\n等效刚度 $\\hat{K}$ 为：\n$$\n\\hat{K} = K + \\frac{\\gamma}{\\beta \\Delta t} C + \\frac{1}{\\beta \\Delta t^2} M\n$$\n等效力 $\\hat{f}_{n+1}$ 聚合了 $t_{n+1}$ 时刻的外力和所有依赖于 $t_n$ 时刻状态的项：\n$$\n\\hat{f}_{n+1} = f_{n+1} + M \\left[ \\frac{1}{\\beta \\Delta t^2} u_n + \\frac{1}{\\beta \\Delta t} \\dot{u}_n + \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n \\right] + C \\left[ \\frac{\\gamma}{\\beta \\Delta t} u_n + \\left(\\frac{\\gamma}{\\beta} - 1\\right) \\dot{u}_n + \\Delta t \\left(\\frac{\\gamma}{2\\beta} - 1\\right) \\ddot{u}_n \\right]\n$$\n求解过程是先解出 $u_{n+1} = \\hat{K}^{-1} \\hat{f}_{n+1}$，然后使用上面推导的关系更新 $\\ddot{u}_{n+1}$ 和 $\\dot{u}_{n+1}$。\n\n### 任务2：一阶灵敏度递推\n\n我们使用直接微分法（DDM）来求解响应相对于通用参数 $p \\in \\mathbf{p}$ 的灵敏度。这涉及到对离散方程组关于 $p$ 求导。令 $(\\cdot)^{,p}$ 表示导数 $\\frac{\\partial (\\cdot)}{\\partial p}$。\n\n对等效系统 $\\hat{K} u_{n+1} = \\hat{f}_{n+1}$ 关于 $p$ 求导，得到：\n$$\n\\hat{K}^{,p} u_{n+1} + \\hat{K} u_{n+1}^{,p} = \\hat{f}_{n+1}^{,p}\n$$\n重新整理以求解位移灵敏度 $u_{n+1}^{,p}$：\n$$\n\\hat{K} u_{n+1}^{,p} = \\hat{f}_{n+1}^{,p} - \\hat{K}^{,p} u_{n+1}\n$$\n求解位移灵敏度时，使用的是与主分析中相同的等效刚度算子 $\\hat{K}$。右侧是灵敏度问题的伪力，它依赖于主分析的解 $(u_{n+1})$ 和上一步的灵敏度 $(u_n^{,p}, \\dot{u}_n^{,p}, \\ddot{u}_n^{,p})$。\n\n一旦计算出 $u_{n+1}^{,p}$，就通过对其各自的更新公式求导来更新速度和加速度灵敏度：\n$$\n\\ddot{u}_{n+1}^{,p} = \\frac{\\partial}{\\partial p} \\left[ \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} \\dot{u}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n \\right]\n$$\n$$\n\\dot{u}_{n+1}^{,p} = \\frac{\\partial}{\\partial p} \\left[ \\dot{u}_n + (1 - \\gamma) \\Delta t \\ddot{u}_n + \\gamma \\Delta t \\ddot{u}_{n+1} \\right]\n$$\n展开这些公式可得到显式更新规则。例如，对于 $\\ddot{u}_{n+1}^{,p}$：\n$$\n\\ddot{u}_{n+1}^{,p} = \\frac{\\partial c_0}{\\partial p}(u_{n+1}-u_n) + c_0(u_{n+1}^{,p} - u_n^{,p}) - \\frac{\\partial c_2}{\\partial p}\\dot{u}_n - c_2\\dot{u}_{n}^{,p} - \\frac{\\partial c_3}{\\partial p}\\ddot{u}_n - c_3\\ddot{u}_{n}^{,p}\n$$\n其中 $c_0=\\frac{1}{\\beta\\Delta t^2}$，$c_2=\\frac{1}{\\beta\\Delta t}$，以及 $c_3=\\frac{1}{2\\beta}-1$。\n\n灵敏度的初始条件通过对主分析的初始条件求导得到：\n$u_0 = 0 \\implies u_0^{,p} = 0$。\n$\\dot{u}_0 = 0 \\implies \\dot{u}_0^{,p} = 0$。\n$\\ddot{u}_0 = 0 \\implies \\ddot{u}_0^{,p} = 0$。\n灵敏度分析从零状态开始，并在每个步骤中由伪力项驱动。\n\n总体算法如下：\n对每个时间步 $n=0, 1, \\dots, N-1$：\n1. 求解主系统：计算 $\\hat{K}$ 和 $\\hat{f}_{n+1}$，解出 $u_{n+1}$，然后更新 $\\dot{u}_{n+1}$ 和 $\\ddot{u}_{n+1}$。\n2. 对每个参数 $p \\in \\mathbf{p}$：\n    a. 计算灵敏度伪力 $F_{sens} = \\hat{f}_{n+1}^{,p} - \\hat{K}^{,p} u_{n+1}$。该力包含在第 $n+1$ 步对参数直接微分产生的项，以及从第 $n$ 步传播过来的灵敏度项。\n    b. 求解位移灵敏度：$u_{n+1}^{,p} = \\hat{K}^{-1} F_{sens}$。\n    c. 使用微分后的更新公式更新速度和加速度灵敏度 $\\dot{u}_{n+1}^{,p}$ 和 $\\ddot{u}_{n+1}^{,p}$。\n\n### 任务3：响应泛函的梯度\n\n标量响应泛函是最终时刻的位移：\n$$\nJ(\\mathbf{p}) = u_N, \\quad \\text{其中 } N = T / \\Delta t\n$$\n该泛函的梯度 $\\nabla J$ 是一个向量，其分量是 $J$ 对 $\\mathbf{p}$ 中每个参数的偏导数：\n$$\n\\nabla J = \\left[ \\frac{\\partial J}{\\partial p_1}, \\frac{\\partial J}{\\partial p_2}, \\dots \\right] = \\left[ \\frac{\\partial u_N}{\\partial p_1}, \\frac{\\partial u_N}{\\partial p_2}, \\dots \\right]\n$$\n梯度的分量恰好是在最终时间步 $N$ 计算出的位移灵敏度 $u_N^{,p_i}$。灵敏度分析直接得出了所需的梯度向量。\n$$\n\\nabla J = \\left[u_N^{,\\beta}, \\, u_N^{,\\gamma}, \\, u_N^{,a_m}, \\, u_N^{,a_c}, \\, u_N^{,a_k}\\right]\n$$\n\n### 任务4：不确定性传播\n\n鉴于缩放参数 $(a_m, a_c, a_k)$ 的不确定性是相互独立的，并由标准差 $(\\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k})$ 表征，我们可以使用 $J$ 在参数均值附近的一阶泰勒级数展开来估计响应泛函的标准差 $\\sigma_J$。$J$ 的方差 $\\sigma_J^2$ 近似为：\n$$\n\\sigma_J^2 \\approx \\sum_{i} \\sum_{j} \\frac{\\partial J}{\\partial p_i} \\frac{\\partial J}{\\partial p_j} \\text{Cov}(p_i, p_j)\n$$\n由于假设参数 $a_m, a_c, a_k$ 相互独立，它们的协方差为零，即当 $i \\neq j$ 时 $\\text{Cov}(a_i, a_j) = 0$。方差简化为：\n$$\n\\sigma_J^2 \\approx \\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2\n$$\n响应的估计标准差是该方差的平方根：\n$$\n\\sigma_J \\approx \\sqrt{\\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2 }\n$$\n所需的偏导数是在任务3中计算出的梯度 $\\nabla J$ 的分量。", "answer": "```python\nimport numpy as np\n\ndef run_analysis(params):\n    \"\"\"\n    Performs the Newmark-beta time integration and sensitivity analysis\n    for a single-degree-of-freedom system.\n    \"\"\"\n    beta, gamma, a_m, a_c, a_k, sigma_am, sigma_ac, sigma_ak = params\n\n    # Baseline physical parameters\n    M0 = 1000.0  # kg\n    K0 = 1.0e7   # N/m\n    zeta0 = 0.05 # damping ratio\n    C0 = 2.0 * zeta0 * np.sqrt(K0 * M0)\n\n    # Scaled parameters\n    M = a_m * M0\n    C = a_c * C0\n    K = a_k * K0\n\n    # Ground motion parameters\n    g = 9.81  # m/s^2\n    f_exc = 5.0  # Hz\n    omega_exc = 2.0 * np.pi * f_exc\n\n    def ag(t):\n        return 0.5 * g * np.sin(omega_exc * t)\n\n    def force(t, M_val):\n        return -M_val * ag(t)\n\n    # Time integration parameters\n    dt = 0.001  # s\n    T_total = 1.0  # s\n    N_steps = int(T_total / dt)\n    t_space = np.linspace(0, T_total, N_steps + 1)\n\n    # State vectors (displacement, velocity, acceleration)\n    u = np.zeros(N_steps + 1)\n    u_dot = np.zeros(N_steps + 1)\n    u_ddot = np.zeros(N_steps + 1)\n    \n    # Initial conditions are all zero\n    # u[0], u_dot[0], u_ddot[0] are already 0.0\n\n    # Sensitivity state vectors\n    # Parameters for sensitivity: [beta, gamma, am, ac, ak]\n    param_keys = ['beta', 'gamma', 'am', 'ac', 'ak']\n    num_params = len(param_keys)\n    \n    # Derivatives of u, u_dot, u_ddot w.r.t. parameters\n    du_dp = np.zeros((N_steps + 1, num_params))\n    dudot_dp = np.zeros((N_steps + 1, num_params))\n    duddot_dp = np.zeros((N_steps + 1, num_params))\n\n    # Newmark constants and their derivatives\n    c0 = 1.0 / (beta * dt**2)\n    c1 = gamma / (beta * dt)\n    c2 = 1.0 / (beta * dt)\n    c3 = 1.0 / (2.0 * beta) - 1.0\n    c4 = gamma / beta - 1.0\n    c5 = dt * (gamma / (2.0 * beta) - 1.0)\n\n    dc_dp = {\n        'beta': [\n            -c0 / beta, # dc0/dbeta\n            -c1 / beta, # dc1/dbeta\n            -c2 / beta, # dc2/dbeta\n            -1.0 / (2.0 * beta**2), # dc3/dbeta\n            -gamma / beta**2, # dc4/dbeta\n            -dt * gamma / (2.0 * beta**2) # dc5/dbeta\n        ],\n        'gamma': [0, c2, 0, 0, 1.0 / beta, dt / (2.0 * beta)]\n    }\n\n    # Effective stiffness for the primary analysis\n    K_hat = K + c1 * C + c0 * M\n    inv_K_hat = 1.0 / K_hat\n\n    # Time stepping loop\n    for n in range(N_steps):\n        # --- Primary Analysis ---\n        f_next = force(t_space[n+1], M)\n        \n        A_n = c0 * u[n] + c2 * u_dot[n] + c3 * u_ddot[n]\n        B_n = c1 * u[n] + c4 * u_dot[n] + c5 * u_ddot[n]\n        \n        f_hat = f_next + M * A_n + C * B_n\n        \n        u[n+1] = inv_K_hat * f_hat\n        u_ddot[n+1] = c0 * (u[n+1] - u[n]) - c2 * u_dot[n] - c3 * u_ddot[n]\n        u_dot[n+1] = u_dot[n] + (1.0 - gamma) * dt * u_ddot[n] + gamma * dt * u_ddot[n+1]\n\n        # --- Sensitivity Analysis ---\n        for j, p_key in enumerate(param_keys):\n            # Derivatives of M, C, K, f w.r.t parameter p\n            dM_dp, dC_dp, dK_dp, df_dp = 0, 0, 0, 0\n            if p_key == 'am':\n                dM_dp = M0\n                df_dp = -M0 * ag(t_space[n+1])\n            elif p_key == 'ac':\n                dC_dp = C0\n            elif p_key == 'ak':\n                dK_dp = K0\n\n            # Derivatives of Newmark constants w.r.t. p\n            dc0_dp, dc1_dp, dc2_dp, dc3_dp, dc4_dp, dc5_dp = (0,)*6\n            if p_key in dc_dp:\n                dc0_dp, dc1_dp, dc2_dp, dc3_dp, dc4_dp, dc5_dp = dc_dp[p_key]\n                \n            # Derivative of effective stiffness\n            dKhat_dp = dK_dp + dc1_dp * C + c1 * dC_dp + dc0_dp * M + c0 * dM_dp\n\n            # Compute RHS for sensitivity equation: f_sens = df_hat/dp - dK_hat/dp * u_n+1\n            \n            # Terms propagating sensitivities from step n\n            propagated_A = c0 * du_dp[n, j] + c2 * dudot_dp[n, j] + c3 * duddot_dp[n, j]\n            propagated_B = c1 * du_dp[n, j] + c4 * dudot_dp[n, j] + c5 * duddot_dp[n, j]\n            \n            # Terms from direct differentiation\n            direct_A = dc0_dp * u[n] + dc2_dp * u_dot[n] + dc3_dp * u_ddot[n]\n            direct_B = dc1_dp * u[n] + dc4_dp * u_dot[n] + dc5_dp * u_ddot[n]\n            \n            dfhat_dp = (df_dp + dM_dp * A_n + M * (direct_A + propagated_A) +\n                        dC_dp * B_n + C * (direct_B + propagated_B))\n            \n            f_sens = dfhat_dp - dKhat_dp * u[n+1]\n            \n            # Solve for displacement sensitivity\n            du_dp[n+1, j] = inv_K_hat * f_sens\n            \n            # Update acceleration and velocity sensitivities\n            d_gamma_dp = 1.0 if p_key == 'gamma' else 0.0\n            \n            duddot_dp[n+1, j] = (dc0_dp * (u[n+1] - u[n]) + \n                                 c0 * (du_dp[n+1, j] - du_dp[n, j]) -\n                                 dc2_dp * u_dot[n] - c2 * dudot_dp[n, j] -\n                                 dc3_dp * u_ddot[n] - c3 * duddot_dp[n, j])\n            \n            dudot_dp[n+1, j] = (dudot_dp[n, j] - \n                                d_gamma_dp * dt * u_ddot[n] + (1.0 - gamma) * dt * duddot_dp[n, j] +\n                                d_gamma_dp * dt * u_ddot[n+1] + gamma * dt * duddot_dp[n+1, j])\n\n    # Final displacement\n    J = u[-1]\n    \n    # Gradient of J\n    grad_J = du_dp[-1, :] # [dJ/dbeta, dJ/dgamma, dJ/dam, dJ/dac, dJ/dak]\n    \n    # Standard deviation of J\n    dJ_dam = grad_J[2]\n    dJ_dac = grad_J[3]\n    dJ_dak = grad_J[4]\n    \n    sigma_J_sq = (dJ_dam**2 * sigma_am**2 + \n                  dJ_dac**2 * sigma_ac**2 + \n                  dJ_dak**2 * sigma_ak**2)\n    sigma_J = np.sqrt(sigma_J_sq)\n    \n    return [J, *grad_J, sigma_J]\n\ndef solve():\n    test_cases = [\n        (0.25, 0.5, 1.0, 1.0, 1.0, 0.05, 0.05, 0.05),\n        (1.0/6.0, 0.5, 1.0, 0.2, 1.0, 0.1, 0.05, 0.05),\n        (0.3, 0.6, 1.2, 1.0, 1.5, 0.02, 0.02, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_analysis(case)\n        results.append(f\"[{','.join(f'{x:.6e}' for x in case_results)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3532506"}]}