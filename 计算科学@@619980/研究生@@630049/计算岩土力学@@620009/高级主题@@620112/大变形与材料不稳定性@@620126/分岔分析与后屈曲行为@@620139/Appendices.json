{"hands_on_practices": [{"introduction": "von Mises 桁架是研究几何非线性和稳定性的经典模型。本练习的核心是从第一性原理出发，通过分析势能函数的性质来确定结构的失稳类型。此外，本练习还要求推导结构对初始几何缺陷的敏感度，这是评估真实结构在荷载作用下行为的关键一步，对于培养分析问题的核心能力至关重要。[@problem_id:3503342]", "problem": "一个对称的二杆铰接桁架（通常称为 von Mises 桁架）由两根相同的直杆组成，其杨氏模量为 $E$，截面积为 $A$。这两根杆件在一个顶点节点连接，并通过位于坐标 $(-a,0)$ 和 $(+a,0)$ 的两个销钉支座支撑。顶点节点初始位于 $(0,h)$，受到一个向下的恒定垂直力 $P$ 的作用。设顶点节点的当前坐标为 $(x,y)$。每根杆只承受轴向力，其轴向应变能由二次格林-拉格朗日伸长能 $U_{i} = \\frac{E A}{2 L_{i0}} (l_{i} - L_{i0})^{2}$ 建模，其中 $L_{i0}$ 是杆 $i$ 的参考（初始）长度，$l_{i}$ 是其当前长度。假设应变很小，但允许大位移（几何非线性）。系统的总势能为\n$$\n\\Pi(x,y;P) \\;=\\; \\sum_{i=1}^{2} \\frac{E A}{2 L_{i0}} \\big(l_{i} - L_{i0}\\big)^{2} \\;-\\; P\\,(y - h),\n$$\n其中 $l_{1} = \\sqrt{(x+a)^{2} + y^{2}}$ 且 $l_{2} = \\sqrt{(x-a)^{2} + y^{2}}$。\n\n第一部分：考虑完美结构，其中 $L_{10} = L_{20} = l_{0}$，且 $l_{0} = \\sqrt{a^{2} + h^{2}}$。从 $\\Pi$ 相对于 $(x,y)$ 的驻值条件和从 $\\Pi$ 推导出的二阶变分（切线）条件出发，确定当荷载参数 $P$ 从零开始变化时，沿对称平衡路径 $x=0$遇到的第一个失稳的性质。通过分析沿对称路径的垂直方向标量切线何时失去正定性，来对失稳类型进行分类。\n\n第二部分：现在引入一个小的几何缺陷，仅将左杆的参考长度更改为 $L_{10} = l_{0} + \\delta$，同时保持右杆的参考长度为 $L_{20} = l_{0}$，其中 $|\\delta| \\ll l_{0}$。使用一个微扰分析，该分析同时强制两个方向的平衡以及垂直方向的折叠（极限点）条件，推导折叠点荷载对缺陷的一阶灵敏度，$S := \\left.\\frac{d P^{\\star}}{d \\delta}\\right|_{\\delta=0}$，其中 $(x^{\\star},y^{\\star},P^{\\star})$ 表示完美结构的折叠点构型。\n\n使用以下参数值对 $S$ 进行数值计算：\n- $E = 210 \\times 10^{9}\\,\\mathrm{Pa}$，\n- $A = 4.0 \\times 10^{-4}\\,\\mathrm{m}^{2}$，\n- $a = 1.0\\,\\mathrm{m}$，\n- $h = 0.5\\,\\mathrm{m}$。\n\n说明：\n- 从总势能 $\\Pi$ 出发，并从第一性原理推导所有需要的平衡和稳定条件。不要先验地假设任何目标公式。\n- 在第一部分中，为失稳类型提供清晰的分类和理由。\n- 在第二部分中，计算与完美结构的第一个失稳点相关的 $\\delta=0$ 处的 $S$。用 $\\mathrm{kN/mm}$ 单位表示你的最终数值答案，并四舍五入到四位有效数字。\n- 最终答案只报告 $S$ 的标量数值。不要在最终答案框中包含分类文本。", "solution": "该问题分为两部分。第一部分要求分析完美二杆桁架的第一个失稳。第二部分要求计算临界荷载对几何缺陷的灵敏度。分析将从给定的总势能函数 $\\Pi$ 开始。\n\n**第一部分：完美结构的失稳分析**\n\n对于完美结构，两根杆的参考长度相同：$L_{10} = L_{20} = l_{0}$，其中 $l_{0} = \\sqrt{a^{2} + h^{2}}$。总势能为\n$$\n\\Pi(x,y;P) = \\frac{EA}{2l_0} \\left( (\\sqrt{(x+a)^{2} + y^{2}} - l_{0})^{2} + (\\sqrt{(x-a)^{2} + y^{2}} - l_{0})^{2} \\right) - P(y - h)\n$$\n平衡构型由 $\\Pi$ 相对于节点坐标 $(x,y)$ 的驻值条件求得：\n$$\n\\frac{\\partial \\Pi}{\\partial x} = \\frac{EA}{l_0} \\left[ \\left(1-\\frac{l_0}{l_1}\\right)(x+a) + \\left(1-\\frac{l_0}{l_2}\\right)(x-a) \\right] = 0\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial y} = \\frac{EA}{l_0} \\left[ \\left(1-\\frac{l_0}{l_1}\\right)y + \\left(1-\\frac{l_0}{l_2}\\right)y \\right] - P = 0\n$$\n其中 $l_{1} = \\sqrt{(x+a)^{2} + y^{2}}$ 且 $l_{2} = \\sqrt{(x-a)^{2} + y^{2}}$。\n\n我们分析对称平衡路径，其定义为 $x=0$。对于 $x=0$，我们有 $l_{1} = l_{2} = l = \\sqrt{a^{2}+y^{2}}$。\n第一个平衡方程变为 $\\frac{EA}{l_0} [ (1-l_0/l)a + (1-l_0/l)(-a) ] = 0$，该方程恒成立。因此，$x=0$ 确实是对于任何荷载 $P$ 的一条平衡路径。\n第二个平衡方程给出了沿此路径的荷载 $P$ 和垂直坐标 $y$ 之间的关系：\n$$\nP(y) = \\frac{2EAy}{l_0}\\left(1 - \\frac{l_0}{l}\\right) = \\frac{2EAy}{l_0}\\left(1 - \\frac{\\sqrt{a^{2}+h^{2}}}{\\sqrt{a^{2}+y^{2}}}\\right)\n$$\n平衡点的稳定性由势能的海森矩阵 $H_{ij} = \\frac{\\partial^2 \\Pi}{\\partial u_i \\partial u_j}$（其中 $u=(x,y)$）的正定性决定。\n$$\n\\Pi_{xx} = \\frac{EA}{l_0} \\left[ 2 - l_0\\left(\\frac{1}{l_1}+\\frac{1}{l_2}\\right) + l_0 \\frac{(x+a)^2}{l_1^3} + l_0 \\frac{(x-a)^2}{l_2^3} \\right]\n$$\n$$\n\\Pi_{yy} = \\frac{EA}{l_0} \\left[ 2 - l_0\\left(\\frac{1}{l_1}+\\frac{1}{l_2}\\right) + l_0 y^2\\left(\\frac{1}{l_1^3}+\\frac{1}{l_2^3}\\right) \\right]\n$$\n$$\n\\Pi_{xy} = -\\frac{EA l_0 y}{l_0} \\left[ \\frac{x+a}{l_1^3} + \\frac{x-a}{l_2^3} \\right]\n$$\n在对称路径上（$x=0$，$l_1=l_2=l$），这些分量简化为：\n$$\n\\Pi_{xx}(0,y) = \\frac{2EA}{l_0} \\left( 1 - \\frac{l_0}{l} + \\frac{l_0 a^2}{l^3} \\right)\n$$\n$$\n\\Pi_{yy}(0,y) = \\frac{2EA}{l_0} \\left( 1 - \\frac{l_0}{l} + \\frac{l_0 y^2}{l^3} \\right)\n$$\n$$\n\\Pi_{xy}(0,y) = 0\n$$\n由于海森矩阵在对称路径上是对角的，当任一对角元素消失时，稳定性丧失。\n1.  **对称（叉式）分岔:** $\\Pi_{xx}(0,y) = 0$。这发生在 $1 - \\frac{l_0}{l} + \\frac{l_0 a^2}{l^3} = 0$时，可简化为 $l^3 - l_0 l^2 + l_0 a^2 = 0$。设杆长的解为 $l_B$。\n2.  **极限点（折叠分岔）:** $\\Pi_{yy}(0,y) = 0$。此条件对应于 $dP/dy = 0$。它发生在 $1 - \\frac{l_0}{l} + \\frac{l_0 y^2}{l^3} = 0$时。使用 $y^2 = l^2 - a^2$，这可简化为 $l^3 - l_0 l^2 + l_0 (l^2 - a^2) = 0$，得出 $l^3 = l_0 a^2$。设此临界长度为 $l_L = (l_0 a^2)^{1/3}$。\n\n当桁架从其初始状态 $(y=h, l=l_0)$ 加载时，首先满足哪个条件决定了第一个失稳。随着 $P$ 增加，$y$ 从 $h$ 减小，$l$ 从 $l_0$ 减小。我们必须比较 $l_B$ 和 $l_L$ 与 $l_0$ 的大小。\n\n对于极限点，$l_L^3 = l_0 a^2$。而 $l_0^3 = l_0(a^2+h^2)$。对于 $h>0$，$a^2  a^2+h^2$，所以 $l_0 a^2  l_0 (a^2+h^2)$，这意味着 $l_L^3  l_0^3$，即 $l_L  l_0$。因此，极限点在加载路径上是可以达到的。\n\n对于分岔点，考虑函数 $g(l) = l^3 - l_0 l^2 + l_0 a^2$。在 $l=l_0$ 时，$g(l_0) = l_0^3 - l_0^3 + l_0 a^2 = l_0 a^2 > 0$。其导数为 $g'(l) = 3l^2 - 2l_0 l = l(3l-2l_0)$。对于 $l > 2l_0/3$，$g(l)$ 是递增的。由于当 $l \\to 0$ 时 $g(l) \\to l_0 a^2 > 0$ 且 $g(l_0)>0$，我们需要检查 $l  l_0$ 的行为。由于 $g(l)$ 在 $(2l_0/3, \\infty)$ 上是递增的，并且在 $l=l_0$ 时为正，因此在区间 $[0, l_0]$ 中不存在根 $l_B  l_0$。这意味着从 $l=l_0$ 开始并减小 $l$，分岔条件永远不会满足。因此，第一个失稳必定是极限点。\n\n**第一部分结论：** 第一个失稳是对称路径上的一个极限点（折叠点），也称为对称突跳。临界构型记为 $(x^\\star, y^\\star, P^\\star)$，其中 $x^\\star = 0$。临界杆长为 $l^\\star = l_L = (l_0 a^2)^{1/3}$，临界垂直坐标为 $y^\\star = \\sqrt{(l^\\star)^2 - a^2} = \\sqrt{(l_0 a^2)^{2/3} - a^2}$。\n\n**第二部分：缺陷灵敏度分析**\n\n我们通过设置 $L_{10} = l_0 + \\delta$ 和 $L_{20} = l_0$ 来引入几何缺陷 $\\delta$。总势能现在是 $\\delta$ 的函数：\n$$\n\\Pi(x,y;P,\\delta) = \\frac{EA}{2(l_0+\\delta)} (l_{1} - (l_0+\\delta))^{2} + \\frac{EA}{2 l_{0}} (l_{2} - l_{0})^{2} - P(y - h)\n$$\n我们寻求极限点荷载对缺陷的灵敏度 $S = dP/d\\delta$，在 $\\delta=0$ 处进行评估。这可以通过对系统平衡方程关于 $\\delta$ 进行全微分，并在完美结构的临界点 $(x^\\star, y^\\star, P^\\star)$（其中 $\\delta=0$）处求值来找到。\n\n第二个平衡方程是 $\\Pi_y(x,y,P,\\delta) = 0$。对 $\\delta$ 微分：\n$$\n\\frac{\\partial \\Pi_y}{\\partial x}\\dot{x} + \\frac{\\partial \\Pi_y}{\\partial y}\\dot{y} - \\dot{P} + \\frac{\\partial \\Pi_y}{\\partial\\delta} = 0\n$$\n即 $\\Pi_{yx}\\dot{x} + \\Pi_{yy}\\dot{y} - \\dot{P} + \\Pi_{y,\\delta} = 0$。\n\n我们在完美临界点 $(x^\\star, y^\\star, P^\\star) = (0, y^\\star, P^\\star)$ 处评估此方程。在此点，我们知道 $\\Pi_{yx}^\\star = \\Pi_{xy}(0, y^\\star) = 0$ 且 $\\Pi_{yy}^\\star = 0$。方程急剧简化：\n$$\n0 \\cdot \\dot{x} + 0 \\cdot \\dot{y} - \\dot{P} + \\Pi_{y,\\delta}|_{\\star} = 0\n$$\n因此，灵敏度为：\n$$\nS = \\dot{P} = \\Pi_{y,\\delta}|_{\\star}\n$$\n我们需要计算 $\\Pi_y$ 对 $\\delta$ 的偏导数，保持 $(x,y,P)$ 不变，然后在其临界点处求值。\n$$\n\\Pi_y = \\frac{EA}{l_0+\\delta}(l_1 - (l_0+\\delta))\\frac{y}{l_1} + \\frac{EA}{l_0}(l_2-l_0)\\frac{y}{l_2} - P = \\left( \\frac{EA y}{l_1} - \\frac{EA y}{l_0+\\delta} \\right) + \\text{不依赖于 } \\delta \\text{ 的项}\n$$\n对 $\\delta$ 的偏导数为：\n$$\n\\Pi_{y,\\delta} = \\frac{\\partial}{\\partial\\delta} \\left( -\\frac{EAy}{l_0+\\delta} \\right) = - EAy \\cdot (-1) \\cdot (l_0+\\delta)^{-2} = \\frac{EAy}{(l_0+\\delta)^2}\n$$\n在完美临界点 $(x^\\star,y^\\star,P^\\star)$ 处求值，其中 $x=0$，$y=y^\\star$，且 $\\delta=0$：\n$$\nS = \\frac{EA y^\\star}{(l_0)^2}\n$$\n现在，我们代入给定的数值：\n- $E = 210 \\times 10^{9}\\,\\mathrm{Pa}$\n- $A = 4.0 \\times 10^{-4}\\,\\mathrm{m}^{2}$\n- $a = 1.0\\,\\mathrm{m}$\n- $h = 0.5\\,\\mathrm{m}$\n\n首先，我们计算必要的几何量：\n$EA = (210 \\times 10^9) \\times (4.0 \\times 10^{-4}) = 8.4 \\times 10^7\\,\\mathrm{N}$。\n$l_0 = \\sqrt{a^2+h^2} = \\sqrt{(1.0)^2 + (0.5)^2} = \\sqrt{1.25}\\,\\mathrm{m}$。\n$l_0^2 = 1.25\\,\\mathrm{m}^2$。\n临界垂直坐标 $y^\\star$ 由下式给出：\n$y^\\star = \\sqrt{(l_0 a^2)^{2/3} - a^2} = \\sqrt{(\\sqrt{1.25} \\cdot 1.0^2)^{2/3} - 1.0^2} = \\sqrt{(1.25)^{1/3} - 1}\\,\\mathrm{m}$。\n$y^\\star \\approx \\sqrt{1.077217 - 1} = \\sqrt{0.077217} \\approx 0.27788\\,\\mathrm{m}$。\n\n现在我们计算灵敏度 $S$：\n$$\nS = \\frac{(8.4 \\times 10^7\\,\\mathrm{N}) \\cdot (0.27788\\,\\mathrm{m})}{1.25\\,\\mathrm{m}^2} \\approx 18673542\\,\\mathrm{N/m}\n$$\n题目要求答案以 $\\mathrm{kN/mm}$ 为单位。我们进行单位换算：\n$1\\,\\mathrm{N/m} = 1 \\frac{10^{-3}\\,\\mathrm{kN}}{10^3\\,\\mathrm{mm}} = 10^{-6}\\,\\mathrm{kN/mm}$。\n因此，\n$$\nS \\approx 18673542 \\times 10^{-6}\\,\\mathrm{kN/mm} \\approx 18.673542\\,\\mathrm{kN/mm}\n$$\n四舍五入到四位有效数字，我们得到 $S = 18.67\\,\\mathrm{kN/mm}$。\n正号表示正缺陷（$\\delta > 0$，即左杆更长）会增加结构在突跳前所能承受的最大荷载。\n\n**修正：** 初始推导中，对 $\\Pi_{xy}$ 和 $\\Pi_y$ 对 $\\delta$ 的导数出现了符号错误。\n$\\Pi_{xy} = -\\frac{EA}{l_0} l_0 y \\left[ \\frac{x+a}{l_1^3} + \\frac{x-a}{l_2^3} \\right]$。\n$\\Pi_y$ 对 $\\delta$ 的偏导数： $\\frac{\\partial}{\\partial\\delta} \\left( \\frac{EAy}{l_1} - \\frac{EAy}{l_0+\\delta} \\right) = -EAy(-1)(l_0+\\delta)^{-2} = \\frac{EAy}{(l_0+\\delta)^2}$。\n灵敏度 $S$ 确实是正的。然而，物理直觉表明，使一根杆变长应该会降低对称结构的承载能力。让我们重新检查问题设定：$P$ 是向下的力，但公式中是 $P(y-h)$，其中 $y$ 减小。这使得 $-P(y-h)$ 随着力的增加和位移的增加而减小。我们假设 $P>0$。\n然后，平衡方程是 $\\frac{\\partial \\Pi}{\\partial y} = \\dots - P = 0$，所以 $P = \\frac{2EAy}{l_0}(1-\\frac{l_0}{l})$。当 $y  h$ 时，$y$ 是正的，但小于 $h$。当 $l  l_0$ 时，$1 - l_0/l$ 是负的。$y$ 也是正的。这表明 $P$ 是负的。这意味着 $P$ 是一个向上的力。\n问题陈述是“受到一个向下的恒定垂直力 $P$ 的作用”。总势能中的项应为 $+P(h-y)$ 或 $-P u_y$，其中 $u_y = h-y$ 是向下的位移。原公式 $-P(y-h)$ 等于 $-P(y) - (-Ph) = -Py + Ph$。这对应于一个向上的力 $P$。\n这是一个缺陷，但我们将遵循公式。如果 $P$ 是向上的力，那么正的灵敏度意味着缺陷会增加最大承载力。\n如果我们将 $P$ 视为向下的力，那么势能项应该是 $+P(h-y)$，这将使 $P$ 的符号反转，最终 $S$ 为负。\n$P(y) = -\\frac{2EAy}{l_0}(1 - \\frac{l_0}{l})$。 $y^\\star$ 为正，所以 $P^\\star > 0$（向下的力）。\n那么，灵敏度将是 $S = -\\frac{EA y^\\star}{l_0^2}$。\n$$\nS \\approx -18.673542\\,\\mathrm{kN/mm}\n$$\n四舍五入到四位有效数字，我们得到 $S = -18.67\\,\\mathrm{kN/mm}$。这个结果在物理上更为合理：缺陷降低了承载能力。我们将以此为最终答案。", "answer": "$$\n\\boxed{-18.67}\n$$", "id": "3503342"}, {"introduction": "为了精确地模拟分岔和后屈曲行为，必须使用如牛顿-拉夫逊（Newton-Raphson）法等强大的数值求解器。然而，这些求解器的收敛性，尤其是在临界点附近，极大地依赖于所使用的切线刚度矩阵。本练习旨在推导“一致性算法切线（consistent algorithmic tangent）”，并阐明为何它是保证数值方法在非线性分析中具有二次收敛速度的关键，从而为后续的复杂计算实践奠定基础。[@problem_id:3503188]", "problem": "考虑一个一维小应变弹塑性本构模型，该模型旨在嵌入到对可能在轴向压缩下经历分岔和后屈曲的岩土力学柱进行的有限元法（FEM）分析中。弹性响应是线性的，杨氏模量为 $E$，塑性模型是相关联的，具有一维von Mises型屈服函数和线性各向同性硬化模量 $H \\geq 0$。令 $\\sigma$ 表示柯西应力，$\\varepsilon$ 表示总应变，$\\varepsilon^{p}$ 表示塑性应变。本构关系为\n$$\n\\sigma = E \\left( \\varepsilon - \\varepsilon^{p} \\right), \\quad f(\\sigma, \\alpha) = |\\sigma| - \\left( \\sigma_{y0} + H \\alpha \\right) \\le 0,\n$$\n其中 $\\alpha$ 是标量硬化变量，在一维情况下 $\\alpha = \\varepsilon^{p}$，$\\sigma_{y0}  0$ 是初始屈服应力。演化方程由相关联流动法则和硬化定律给出\n$$\n\\dot{\\varepsilon}^{p} = \\dot{\\lambda} \\, \\text{sign}(\\sigma), \\quad \\dot{\\alpha} = \\dot{\\lambda}, \\quad \\dot{\\lambda} \\ge 0,\n$$\n以及Karush-Kuhn-Tucker条件\n$$\nf \\le 0, \\quad \\dot{\\lambda} \\ge 0, \\quad \\dot{\\lambda} f = 0.\n$$\n考虑一个标准后向欧拉返回映射算法，作用于从步骤 $n$ 到步骤 $n+1$ 的一个时间增量。给定 $\\varepsilon_{n+1}$ 和已知的 $(\\varepsilon^{p}_{n}, \\alpha_{n})$，构建弹性试探应力\n$$\n\\sigma^{\\text{tr}} = E \\left( \\varepsilon_{n+1} - \\varepsilon^{p}_{n} \\right),\n$$\n并计算 $f^{\\text{tr}} = |\\sigma^{\\text{tr}}| - \\left( \\sigma_{y0} + H \\alpha_{n} \\right)$。如果 $f^{\\text{tr}} \\le 0$，则该步骤为弹性步骤，且 $\\sigma_{n+1} = \\sigma^{\\text{tr}}$；否则，发生塑性修正，增量 $\\Delta \\lambda  0$ 强制满足离散一致性条件 $f_{n+1} = 0$ 和更新\n$$\n\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\lambda \\, \\text{sign}(\\sigma^{\\text{tr}}), \\quad \\alpha_{n+1} = \\alpha_{n} + \\Delta \\lambda, \\quad \\sigma_{n+1} = E \\left( \\varepsilon_{n+1} - \\varepsilon^{p}_{n+1} \\right).\n$$\n假设单调递增压缩，使得在塑性区中 $\\sigma^{\\text{tr}}  0$ 且 $\\text{sign}(\\sigma^{\\text{tr}}) = +1$。从该返回映射算法出发，推导一维情况下的“一致算法切线” $\\mathbb{C}^{\\text{alg}}$，其定义为在激活塑性（$f_{n+1} = 0$）条件下，导数 $d \\sigma_{n+1} / d \\varepsilon_{n+1}$。然后，解释为什么在求解后屈曲分析中分岔点附近的全局平衡方程时，需要一致算法切线来实现牛顿-拉夫逊法（NRM）的二次方收敛，以及如果使用非一致切线（例如，割线或弹性近似）会发生何种收敛性退化。\n\n将一维一致算法切线的最终答案表示为包含 $E$ 和 $H$ 的闭式解析表达式。不需要进行数值计算，最终表达式中不应包含单位。", "solution": "#### 第一部分：一致算法切线的推导\n\n一致算法切线，此处表示为 $\\mathbb{C}^{\\text{alg}}$，定义为增量结束时的应力 $\\sigma_{n+1}$ 相对于增量结束时的总应变 $\\varepsilon_{n+1}$ 的导数：\n$$\n\\mathbb{C}^{\\text{alg}} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}}\n$$\n该导数必须从定义最终状态 $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\alpha_{n+1})$ 的代数方程组计算得出，其中 $\\varepsilon_{n+1}$ 是给定的，历史变量 $(\\varepsilon^{p}_{n}, \\alpha_{n})$ 是已知的。我们考虑激活塑性的情况，即执行了塑性修正。\n\n问题假设单调递增压缩，因此我们可以设定 $\\sigma^{\\text{tr}} > 0$。因此，更新后的应力 $\\sigma_{n+1}$ 也将为正。这简化了方程：$\\text{sign}(\\sigma^{\\text{tr}}) = 1$ 且 $|\\sigma_{n+1}| = \\sigma_{n+1}$。步骤 $n+1$ 状态的控制方程组为：\n1.  **应力更新**： $\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})$\n2.  **塑性应变更新**： $\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\lambda$\n3.  **硬化变量更新**： $\\alpha_{n+1} = \\alpha_{n} + \\Delta\\lambda$\n4.  **离散屈服条件（一致性）**： $f_{n+1} = \\sigma_{n+1} - (\\sigma_{y0} + H \\alpha_{n+1}) = 0$\n\n为了求得 $\\mathbb{C}^{\\text{alg}}$，我们对该方程组关于 $\\varepsilon_{n+1}$ 求导，并将上一步的 $(\\varepsilon^{p}_{n}, \\alpha_{n})$ 视为常数。项 $\\Delta\\lambda$ 是 $\\varepsilon_{n+1}$ 的函数，必须对其进行微分。\n\n对每个方程取全微分：\n1.  $d\\sigma_{n+1} = E (d\\varepsilon_{n+1} - d\\varepsilon^{p}_{n+1})$\n2.  $d\\varepsilon^{p}_{n+1} = d(\\Delta\\lambda)$ (因为 $d\\varepsilon^{p}_{n} = 0$)\n3.  $d\\sigma_{n+1} - H d\\alpha_{n+1} = 0$ (因为 $d\\sigma_{y0}=0$)\n4.  $d\\alpha_{n+1} = d(\\Delta\\lambda)$ (因为 $d\\alpha_{n} = 0$)\n\n从方程(3)和(4)中，我们找到了应力微分和塑性乘子微分之间的关系：\n$$\nd\\sigma_{n+1} = H d\\alpha_{n+1} = H d(\\Delta\\lambda)\n$$\n从方程(2)中，我们有 $d\\varepsilon^{p}_{n+1} = d(\\Delta\\lambda)$。我们可以将这些结合起来，以关联塑性应变增量和应力增量：\n$$\nd\\varepsilon^{p}_{n+1} = \\frac{1}{H} d\\sigma_{n+1}\n$$\n此表达式在 $H > 0$ 时有效。如果 $H=0$（理想塑性），则 $d\\sigma_{n+1}=0$，意味着切线为零。推导出的公式将反映这一点。现在将其代入应力更新方程(1)的微分形式中：\n$$\nd\\sigma_{n+1} = E \\left( d\\varepsilon_{n+1} - \\frac{1}{H} d\\sigma_{n+1} \\right)\n$$\n重新整理以求解比率 $d\\sigma_{n+1} / d\\varepsilon_{n+1}$：\n$$\nd\\sigma_{n+1} = E d\\varepsilon_{n+1} - \\frac{E}{H} d\\sigma_{n+1}\n$$\n$$\nd\\sigma_{n+1} \\left( 1 + \\frac{E}{H} \\right) = E d\\varepsilon_{n+1}\n$$\n$$\nd\\sigma_{n+1} \\left( \\frac{H+E}{H} \\right) = E d\\varepsilon_{n+1}\n$$\n最后，我们得到一致算法切线的表达式：\n$$\n\\mathbb{C}^{\\text{alg}} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = E \\frac{H}{E+H} = \\frac{EH}{E+H}\n$$\n该模量代表了由后向欧拉算法产生的离散应力-应变响应的切线。它等价于弹性模量 $E$ 和塑性硬化模量 $H$ 的调和平均值。\n\n#### 第二部分：一致切线在NRM收敛中的作用\n\n在非线性有限元法（FEM）分析中，主要目标是求解通常为非线性的全局平衡方程组：\n$$\n\\mathbf{R}(\\mathbf{u}) = \\mathbf{F}^{\\text{ext}} - \\mathbf{F}^{\\text{int}}(\\mathbf{u}) = \\mathbf{0}\n$$\n其中 $\\mathbf{u}$ 是全局节点位移向量，$\\mathbf{R}(\\mathbf{u})$ 是残差向量，$\\mathbf{F}^{\\text{ext}}$ 是外部节点力向量，$\\mathbf{F}^{\\text{int}}(\\mathbf{u})$ 是内部节点力向量。内部节点力向量通过在域上对应力场进行积分计算得出：$\\mathbf{F}^{\\text{int}} = \\int_V \\mathbf{B}^T \\boldsymbol{\\sigma} \\, dV$，其中 $\\mathbf{B}$ 是应变-位移矩阵。\n\n牛顿-拉夫逊法是求解此非线性系统的迭代过程。从一个估计值 $\\mathbf{u}_i$ 开始，通过线性化系统来找到一个更好的估计值 $\\mathbf{u}_{i+1}$：\n$$\n\\mathbf{R}(\\mathbf{u}_i) + \\frac{d\\mathbf{R}}{d\\mathbf{u}}\\bigg|_{\\mathbf{u}_i} (\\mathbf{u}_{i+1} - \\mathbf{u}_i) = \\mathbf{0}\n$$\n这导出了迭代更新格式：\n$$\n\\mathbf{K}_T(\\mathbf{u}_i) \\Delta\\mathbf{u}_{i+1} = \\mathbf{R}(\\mathbf{u}_i)\n$$\n其中 $\\Delta\\mathbf{u}_{i+1} = \\mathbf{u}_{i+1} - \\mathbf{u}_i$，$\\mathbf{K}_T$ 是全局切线刚度矩阵，定义为残差的精确雅可比矩阵：\n$$\n\\mathbf{K}_T = -\\frac{d\\mathbf{R}}{d\\mathbf{u}} = \\frac{d\\mathbf{F}^{\\text{int}}}{d\\mathbf{u}} = \\int_V \\mathbf{B}^T \\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\varepsilon}} \\mathbf{B} \\, dV\n$$\n数值分析的一个基本定理指出，只要迭代中使用的切线矩阵（$\\mathbf{K}_T$）是所求根函数（残差 $\\mathbf{R}$）的精确雅可比矩阵，牛顿-拉夫逊法就表现出渐近二次收敛率。\n\n在本文所考虑的隐式、时间离散化背景下，一个材料点的应力 $\\boldsymbol{\\sigma}_{n+1}$ 不是当前应变 $\\boldsymbol{\\varepsilon}_{n+1}$ 的一个简单的显式函数。相反，它是算法过程（返回映射）的结果。因此，精确雅可比矩阵所需的导数 $\\frac{d\\boldsymbol{\\sigma}}{d\\boldsymbol{\\varepsilon}}$ 正是一致算法切线，即 $\\mathbb{C}^{\\text{alg}} = d\\boldsymbol{\\sigma}_{n+1}/d\\boldsymbol{\\varepsilon}_{n+1}$。\n\n使用一致算法切线可确保全局切线刚度矩阵 $\\mathbf{K}_T$ 是离散化平衡方程的真实雅可比矩阵。这保证了全局NRM迭代的二次方收敛，意味着在接近解时，每次迭代解的正确位数大约会翻倍。\n\n如果使用非一致切线，该方法就变成了拟牛顿法或修正牛顿法。例如：\n- **使用弹性切线 ($E$)**: 这是一种常见的简化方法。刚度矩阵更容易计算。然而，所使用的矩阵不再是真实的雅可比矩阵，收敛率从二次方退化到至多线性。\n- **使用连续弹塑性切线**: 在这个特定的一维案例中，连续切线恰好与一致切线相同。然而，对于更复杂的多维模型（例如，非关联塑性），连续切线和一致切线是不同的。在使用与一致切线不同的连续切线时，也会导致二次方`converged`收敛性的丧失。\n\n在表征后屈曲行为的分岔点或极限点附近，使用非一致切线的后果尤其严重。\n- **收敛性退化**: 在这些高度非线性的区域，最需要NRM的二次方收敛。线性收敛可能慢到无法接受，或者完全失效。\n- **无法预测失稳**: 分岔的条件是 $\\det(\\mathbf{K}_T) = 0$。如果使用近似切线（例如，弹性切线），在会导致塑性屈曲的条件下，所得到的矩阵可能永远不会奇异，因此分析将无法正确预测失稳。\n- **缺乏鲁棒性**: 使用一致切线显著提高了数值解的鲁棒性，使其能够追踪复杂的平衡路径，包括后屈曲中常见的“回弹”（snap-backs）和“突跳”（snap-throughs），而这对于非一致切线来说几乎是不可能的。\n\n总之，一致算法切线是离散化本构律的精确线性化，其使用是维持牛顿-拉夫逊法二次方收敛率的必要条件，从而确保复杂非线性模拟的效率和鲁棒性。", "answer": "$$\n\\boxed{\\frac{EH}{E+H}}\n$$", "id": "3503188"}, {"introduction": "将理论分析与数值方法相结合是计算力学的核心。本练习将回归到 von Mises 桁架问题，但目标是利用计算方法完整地追踪其复杂的后屈曲平衡路径，包括解析方法难以捕捉的“突跳”（snap-through）现象。你将通过实施弧长法（arc-length method）——一种能够稳健地追踪极限点和复杂路径的先进数值技术——来验证和深化对非线性结构行为的理解。[@problem_id:3503289]", "problem": "考虑对称的两杆 von Mises 桁架：两根初始长度为 $l_0$ 的相同直杆，将位于 $(0,h)$ 的顶部节点连接到位于 $(-a,0)$ 和 $(a,0)$ 的两个固定销支座。顶部节点发生垂直位移 $u$，向下为正。每根杆的轴向刚度为 $EA$（杨氏模量乘以面积），单位为牛顿（$\\mathrm{N}$）。假设轴向响应为线性弹性，采用工程应变，并且运动学对于大位移但小应变是几何精确的，因此每根杆的内轴力为 $N = EA \\, e$，其中 $e = (l - l_0)/l_0$ 是工程应变，$l = \\sqrt{a^2 + (h - u)^2}$ 是当前的杆长。设外部载荷 $P$ 是施加在顶部节点的垂直点载荷，向上为正，单位为牛顿（$\\mathrm{N}$）。在平衡状态下，两根杆内力的垂直分量必须与所施加的载荷相平衡。\n\n从第一性原理出发，基于工程应变和力平衡的定义，推导精确的载荷-位移关系 $P(u)$ 及其切线刚度 $K_t(u) = dP/du$，用 $a$、$h$ 和 $EA$ 表示。使用这些表达式定义残差 $r(u,\\lambda) = f_{\\text{int}}(u) - \\lambda$，其中 $f_{\\text{int}}(u)$ 是精确的内载荷函数，$\\lambda$ 是一个标量载荷参数，使得实际载荷为 $P = \\lambda$。控制方程为 $r(u,\\lambda) = 0$。\n\n为该单自由度系统实现一个球面弧长法（Crisfield-Riks 型），以稳健地追踪通过极限点的平衡路径 $P(u)$。使用带有切线 $K_t(u)$ 的 $r(u,\\lambda)$ 线性化，并强制执行球面约束\n$$\n(\\Delta u)^2 + \\alpha \\, (\\Delta \\lambda)^2 = s^2,\n$$\n其中 $\\Delta u$ 和 $\\Delta \\lambda$ 表示当前弧长步内的累积增量，$s  0$ 是预设的弧长半径，$\\alpha  0$ 是一个根据初始切线选择的缩放因子，用于对约束进行无量纲化。从 $u=0, \\lambda=0$ 的平凡平衡点开始，直到当前高度 $y = h - u$ 达到下限 $y_{\\min}$，超过该下限后模型不再继续推进。位移以米（$\\mathrm{m}$）表示，载荷以牛顿（$\\mathrm{N}$）表示。不使用角度；不需要角度单位。\n\n验证要求：在弧长求解器产生的每个收敛的平衡状态 $(u_i, \\lambda_i)$ 处，计算精确的内力函数 $f_{\\text{int}}(u_i)$。计算相对平衡误差\n$$\n\\varepsilon_i = \\frac{| \\lambda_i - f_{\\text{int}}(u_i) |}{\\max\\{1, |f_{\\text{int}}(u_i)|\\}}.\n$$\n对于每个测试用例，报告在达到停止点 $y \\le y_{\\min}$ 之前所有收敛状态中的最大 $\\varepsilon_i$。\n\n您在推导和实现中必须使用的基本原理：\n- 顶部节点的力平衡。\n- 工程应变定义 $e = (l - l_0)/l_0$ 和轴向力 $N = EA \\, e$。\n- 当前杆长的精确几何关系 $l = \\sqrt{a^2 + (h - u)^2}$。\n- 用于求解带有球面约束的 $r(u,\\lambda)=0$ 的弧长约束和牛顿线性化。\n\n您必须在一个完整的、可运行的程序中实现以下内容：\n- 从上述原理推导出的精确函数 $f_{\\text{int}}(u)$ 和 $K_t(u)$。\n- 一个稳健的单自由度球面弧长求解器，每步包含牛顿迭代，同时强制满足 $r(u,\\lambda)=0$ 和球面约束。\n- 一个在追踪的路径上累积最大 $\\varepsilon_i$ 的验证程序。\n\n测试套件和参数：\n- 使用以下三组参数，单位为米（$\\mathrm{m}$）和牛顿（$\\mathrm{N}$），其中弧长半径 $s$ 根据您为 $\\alpha$ 选择的缩放方式而无量纲：\n    - 案例 1：$(a,h,EA,s,n_{\\text{steps}},y_{\\min}/h) = (1.0, 1.0, 1.0\\times 10^5, 0.08, 60, 0.02)$。\n    - 案例 2：$(a,h,EA,s,n_{\\text{steps}},y_{\\min}/h) = (1.0, 0.3, 2.0\\times 10^5, 0.06, 80, 0.02)$。\n    - 案例 3：$(a,h,EA,s,n_{\\text{steps}},y_{\\min}/h) = (0.6, 1.2, 5.0\\times 10^6, 0.07, 60, 0.02)$。\n\n需强制执行的数值细节：\n- 选择 $\\alpha = 1/c^2$，其中 $c = |K_t(0)|$，即通过初始切线刚度的大小进行缩放，从而使弧长约束无量纲化。\n- 对由 $\\max\\{1, |\\lambda|, |f_{\\text{int}}(u)|\\}$ 缩放后的残差 $|r(u,\\lambda)|$ 使用 $10^{-12}$ 的牛顿迭代容差。\n- 每个弧长步最多使用 $30$ 次牛顿迭代。\n- 当 $y = h - u$ 首次满足 $y \\le y_{\\min}$ 或达到指定的步数 $n_{\\text{steps}}$ 后，停止追踪。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个案例的最大相对平衡误差，格式为方括号内以逗号分隔的列表（例如，“[x1,x2,x3]”），其中每个 $x_i$ 是一个浮点数。输出行中不得有任何额外文本。\n\n所有数值必须以上述指定单位表示，最终报告的量是无单位的相对误差（无量纲浮点数）。", "solution": "### 控制函数的推导\n\n首先，我们推导内力函数 $f_{\\text{int}}(u)$ 和切线刚度 $K_t(u)$ 的精确表达式。\n\n**1. 内力, $f_{\\text{int}}(u)$**\n\n顶部节点位于坐标 $(0, h-u)$。一根杆（例如右边那根）对节点的力矢量沿着杆的轴线方向。从支座 $(a, 0)$ 到节点 $(0, h-u)$ 的矢量是 $\\vec{v} = (-a, h-u)$。该矢量的长度是当前的杆长，$l(u) = \\sqrt{(-a)^2 + (h-u)^2} = \\sqrt{a^2 + (h-u)^2}$。\n\n每根杆的轴向力（拉力为正）由下式给出：\n$$N(u) = EA \\cdot e = EA \\frac{l(u) - l_0}{l_0}$$\n其中 $l_0 = \\sqrt{a^2 + h^2}$ 是杆的初始无应力长度。\n\n由于对称性，两根杆的轴向力相同。桁架对节点施加的总垂直内力是两根杆垂直力分量的总和。单根杆力的垂直分量为 $N \\frac{h-u}{l(u)}$。因此，总内力（向上为正）是：\n$$f_{\\text{int}}(u) = 2 N(u) \\frac{h-u}{l(u)}$$\n代入 $N(u)$ 和 $l(u)$ 的表达式：\n$$f_{\\text{int}}(u) = 2 \\left(EA \\frac{l(u) - l_0}{l_0}\\right) \\frac{h-u}{l(u)} = 2\\frac{EA}{l_0} (h-u) \\left(1 - \\frac{l_0}{l(u)}\\right)$$\n显式地，这是：\n$$f_{\\text{int}}(u) = 2\\frac{EA}{l_0} (h-u) \\left(1 - \\frac{l_0}{\\sqrt{a^2 + (h-u)^2}}\\right)$$\n在平衡时，此内力与施加载荷 $P=\\lambda$ 相平衡，因此 $f_{\\text{int}}(u) = \\lambda$。\n\n**2. 切线刚度, $K_t(u)$**\n\n切线刚度是内力关于位移的导数：$K_t(u) = \\frac{df_{\\text{int}}}{du}$。\n我们重写 $f_{\\text{int}}(u) = 2\\frac{EA}{l_0} \\left( (h-u) - l_0 \\frac{h-u}{l(u)} \\right)$。\n我们使用链式法则和商法则。第一项 $(h-u)$ 的导数是 $-1$。对于第二项，我们需要 $\\frac{h-u}{l(u)}$ 的导数：\n$$ \\frac{d}{du}\\left(\\frac{h-u}{\\sqrt{a^2 + (h-u)^2}}\\right) = \\frac{(-1)\\sqrt{a^2+(h-u)^2} - (h-u) \\frac{-2(h-u)}{2\\sqrt{a^2+(h-u)^2}}}{a^2+(h-u)^2} $$\n$$ = \\frac{-l(u) + \\frac{(h-u)^2}{l(u)}}{l(u)^2} = \\frac{-l(u)^2 + (h-u)^2}{l(u)^3} = \\frac{-(a^2+(h-u)^2) + (h-u)^2}{l(u)^3} = \\frac{-a^2}{l(u)^3} $$\n将此代入 $K_t(u)$ 的导数中：\n$$ K_t(u) = \\frac{df_{\\text{int}}}{du} = 2\\frac{EA}{l_0} \\left( -1 - l_0 \\left(\\frac{-a^2}{l(u)^3}\\right) \\right) = 2\\frac{EA}{l_0} \\left( \\frac{l_0 a^2}{l(u)^3} - 1 \\right) $$\n$$ K_t(u) = 2EA \\left( \\frac{a^2}{l(u)^3} - \\frac{1}{l_0} \\right) $$\n其中 $l(u) = \\sqrt{a^2 + (h-u)^2}$ 和 $l_0 = \\sqrt{a^2 + h^2}$。\n\n### 弧长法的实现\n\n数值解通过求解包含残差方程 $r(u, \\lambda) = f_{\\text{int}}(u) - \\lambda = 0$ 和球面弧长约束 $(\\Delta u)^2 + \\alpha (\\Delta \\lambda)^2 = s^2$ 的方程组来追踪平衡路径 $(u, \\lambda)$。该算法的实现将遵循一个标准的预测-修正方案，使用牛顿-拉夫逊法进行修正。最终的实现是一个 Python 脚本，它将执行所需的计算并以指定格式报告最大相对误差。", "answer": "```python\nimport numpy as np\nimport math\n\ndef get_fint(u, a, h, EA, l0):\n    \"\"\"\n    Calculates the exact internal force f_int(u).\n    f_int is the upward vertical force from the truss on the joint.\n    \"\"\"\n    val_in_sqrt = a**2 + (h - u)**2\n    if val_in_sqrt  0:\n        return np.nan\n    l = np.sqrt(val_in_sqrt)\n\n    if abs(l)  1e-12:\n        return 0.0\n\n    term1 = 2.0 * EA / l0\n    term2 = h - u\n    term3 = 1.0 - l0 / l\n    return term1 * term2 * term3\n\ndef get_kt(u, a, h, EA, l0):\n    \"\"\"\n    Calculates the exact tangent stiffness K_t(u) = d(f_int)/du.\n    \"\"\"\n    val_in_sqrt = a**2 + (h - u)**2\n    if val_in_sqrt  1e-12:\n        return np.nan\n    l = np.sqrt(val_in_sqrt)\n    l_cubed = l**3\n\n    if abs(l_cubed)  1e-12:\n        return np.nan\n        \n    return 2.0 * EA * (a**2 / l_cubed - 1.0 / l0)\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case using the spherical arc-length method.\n    \"\"\"\n    a, h, EA, s, n_steps, y_min_ratio = params\n    \n    l0 = np.sqrt(a**2 + h**2)\n    y_stop = y_min_ratio * h\n    \n    tol = 1e-12\n    max_newton_iter = 30\n    \n    u_path = [0.0]\n    lambda_path = [0.0]\n    max_rel_error = 0.0\n    \n    u_i, lambda_i = 0.0, 0.0\n    \n    k_t0 = get_kt(u_i, a, h, EA, l0)\n    if abs(k_t0)  1e-12:\n        raise ValueError(\"Initial stiffness is zero, cannot define alpha.\")\n    c = np.abs(k_t0)\n    alpha = 1.0 / (c**2)\n\n    for i in range(n_steps):\n        # --- PREDICTOR ---\n        k_t_i = get_kt(u_i, a, h, EA, l0)\n        \n        denom = np.sqrt(1.0 + alpha * k_t_i**2)\n        du_pred = s / denom\n        dlambda_pred = k_t_i * du_pred\n\n        if i > 0:\n            du_prev_step = u_path[-1] - u_path[-2]\n            dlambda_prev_step = lambda_path[-1] - lambda_path[-2]\n            dot_prod = du_pred * du_prev_step + dlambda_pred * dlambda_prev_step\n            if dot_prod  0:\n                du_pred = -du_pred\n                dlambda_pred = -dlambda_pred\n        \n        u_j = u_i + du_pred\n        lambda_j = lambda_i + dlambda_pred\n\n        # --- CORRECTOR (Newton-Raphson loop) ---\n        converged = False\n        for j in range(max_newton_iter):\n            fint_j = get_fint(u_j, a, h, EA, l0)\n            kt_j = get_kt(u_j, a, h, EA, l0)\n            \n            if math.isnan(fint_j) or math.isnan(kt_j):\n                break\n\n            r_j = fint_j - lambda_j\n            \n            norm = max(1.0, abs(lambda_j), abs(fint_j))\n            if abs(r_j) / norm  tol:\n                converged = True\n                break\n\n            delta_u_j = u_j - u_i\n            delta_lambda_j = lambda_j - lambda_i\n\n            A = 1.0 + alpha * kt_j**2\n            B = 2.0 * (delta_u_j + alpha * kt_j * (delta_lambda_j + r_j))\n            C = delta_u_j**2 + alpha * (delta_lambda_j + r_j)**2 - s**2\n\n            discriminant = B**2 - 4.0 * A * C\n            if discriminant  0:\n                break\n            \n            sqrt_D = np.sqrt(discriminant)\n            du1 = (-B + sqrt_D) / (2.0 * A)\n            du2 = (-B - sqrt_D) / (2.0 * A)\n\n            dlambda1 = r_j + kt_j * du1\n            dlambda2 = r_j + kt_j * du2\n\n            vec_prev_total = np.array([delta_u_j, delta_lambda_j])\n            \n            vec_new_total1 = np.array([delta_u_j + du1, delta_lambda_j + dlambda1])\n            vec_new_total2 = np.array([delta_u_j + du2, delta_lambda_j + dlambda2])\n\n            dot1 = np.dot(vec_prev_total, vec_new_total1)\n            dot2 = np.dot(vec_prev_total, vec_new_total2)\n\n            if j == 0 and i == 0:\n                if np.linalg.norm([du1, dlambda1])  np.linalg.norm([du2, dlambda2]):\n                    du_corr, dlambda_corr = du1, dlambda1\n                else:\n                    du_corr, dlambda_corr = du2, dlambda2\n            else:\n                if dot1 > dot2:\n                    du_corr, dlambda_corr = du1, dlambda1\n                else:\n                    du_corr, dlambda_corr = du2, dlambda2\n            \n            u_j += du_corr\n            lambda_j += dlambda_corr\n\n        if not converged:\n            break\n\n        # --- POST-STEP ---\n        u_i, lambda_i = u_j, lambda_j\n        u_path.append(u_i)\n        lambda_path.append(lambda_i)\n        \n        f_int_final = get_fint(u_i, a, h, EA, l0)\n        rel_error = abs(lambda_i - f_int_final) / max(1.0, abs(f_int_final))\n        if rel_error > max_rel_error:\n            max_rel_error = rel_error\n            \n        if (h - u_i) = y_stop:\n            break\n            \n    return max_rel_error\n\ndef solve():\n    test_cases = [\n        (1.0, 1.0, 1.0e5, 0.08, 60, 0.02),\n        (1.0, 0.3, 2.0e5, 0.06, 80, 0.02),\n        (0.6, 1.2, 5.0e6, 0.07, 60, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        max_error = solve_case(case)\n        results.append(max_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3503289"}]}