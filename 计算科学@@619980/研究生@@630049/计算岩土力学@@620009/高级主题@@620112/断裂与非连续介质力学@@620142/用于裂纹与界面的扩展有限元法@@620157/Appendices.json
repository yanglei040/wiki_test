{"hands_on_practices": [{"introduction": "在编写任何代码之前，至关重要的是要理解扩展有限元法（XFEM）近似的结构。本练习的核心在于，对于一个包含裂纹尖端的单元，如何分配其自由度，这其中结合了标准、亥维赛（Heaviside）函数和裂纹尖端函数的富集。通过正确计算自由度的总数 [@problem_id:3524336]，您将巩固对单位分解框架以及如何避免诸如线性相关等数值问题的策略的理解。", "problem": "考虑在单位分解扩展有限元方法 (Partition of Unity Extended Finite Element Method, XFEM) 框架下，一个用于均质、各向同性岩石基质的平面应变问题的四节点双线性四边形单元。该单元的节点物理坐标为 $\\boldsymbol{x}_1=(0,0)$、$\\boldsymbol{x}_2=(L,0)$、$\\boldsymbol{x}_3=(L,L)$ 和 $\\boldsymbol{x}_4=(0,L)$，其中 $L0$ 是边长。一条无牵引力裂纹从左侧边界上的点 $(0,0.5L)$ 进入该单元，并终止于完全位于单元内部的裂纹尖端 $\\boldsymbol{x}_{\\mathrm{tip}}=(0.3L,0.3L)$。每个节点的力学未知量是位移分量 $u_x$ 和 $u_y$。增强位移近似是通过使用亥维赛阶跃函数 (Heaviside step function) $H$ 来表示裂纹面上的位移跳跃，以及四个线性无关的近尖端渐近分支函数 (near-tip asymptotic branch functions) $F_1$、$F_2$、$F_3$、$F_4$ 来表示奇异的裂纹尖端场来构造的。在单位分解构造中，每个增强函数乘以增强节点处的标准形函数，并引入一个未知系数向量，其大小等于位移分量的数量。\n\n为避免过度增强和病态问题，采用以下选择策略：\n- 仅将四个近尖端分支增强附加到节点 $1$ 和 $2$（底部边缘的两个节点，与进入的裂纹路径对齐且最靠近裂纹尖端区域）。\n- 仅将亥维赛增强附加到节点 $3$ 和 $4$（顶部边缘的两个节点），因为它们的节点支承域被裂纹穿过，但它们远离尖端主导区。\n- 不要将亥维赛增强和近尖端分支增强同时赋予同一个节点。\n\n根据上述选择策略，并考虑到在二维问题中每个节点都带有 $u_x$ 和 $u_y$ 位移，计算该单元在增强后的总自由度数。论证为何这种选择策略能产生一个与物理场一致的、稳定且非冗余的增强近似。将最终答案表示为一个纯计数（无量纲）。无需四舍五入。", "solution": "该问题要求计算一个在扩展有限元方法 (XFEM) 框架下为模拟裂纹而增强的四节点四边形单元的总自由度数 (DOFs)。在XFEM中，总位移场 $\\boldsymbol{u}(\\boldsymbol{x})$ 被近似为标准有限元 (FE) 部分和增强部分之和。对于有裂纹的问题，一个增强节点可以有与跳跃函数（亥维赛函数）和/或奇异裂纹尖端分支函数相关的额外自由度。\n\nXFEM位移近似对具有裂纹的单元的一般形式为：\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\sum_{i \\in I_s} N_i(\\boldsymbol{x})\\boldsymbol{u}_i + \\sum_{j \\in I_H} N_j(\\boldsymbol{x}) H(\\boldsymbol{x}) \\boldsymbol{a}_j + \\sum_{k \\in I_T} N_k(\\boldsymbol{x}) \\left( \\sum_{\\alpha=1}^{N_f} F_\\alpha(\\boldsymbol{x}) \\boldsymbol{b}_{k\\alpha} \\right)\n$$\n其中：\n- $N_i(\\boldsymbol{x})$ 是与节点 $i$ 相关的标准有限元形函数。\n- $\\boldsymbol{u}_i$ 是节点 $i$ 的标准自由度向量。\n- $I_s$ 是单元中所有节点的集合。\n- $H(\\boldsymbol{x})$ 是亥维赛阶跃函数，对于其支承域被裂纹切割的节点 ($j \\in I_H$)，该函数非零。$\\boldsymbol{a}_j$ 是亥维赛函数的增强自由度向量。\n- $F_\\alpha(\\boldsymbol{x})$ 是近尖端渐近分支函数，用于其支承域包含裂纹尖端的节点 ($k \\in I_T$) 。$\\boldsymbol{b}_{k\\alpha}$ 是与节点 $k$ 和分支函数 $\\alpha$ 相关的增强自由度向量。$N_f$ 是分支函数的数量。\n- 在二维问题中，未知量是大小为2的向量，对应于位移分量 $u_x$ 和 $u_y$。例如，$\\boldsymbol{u}_i = \\{u_{ix}, u_{iy}\\}$。\n\n我们将根据问题陈述中提供的具体增强策略，通过对标准部分和两种增强类型的贡献求和来计算总自由度数。\n\n1.  **标准自由度：**\n    该单元是一个具有节点 $1, 2, 3, 4$ 的四节点双线性四边形。在标准有限元列式中，每个节点都有与之相关的自由度。对于二维力学问题（平面应变），每个节点有 $2$ 个自由度（$u_x$ 和 $u_y$）。\n    - 节点数：$4$。\n    - 每个节点的标准自由度：$2$。\n    - 标准自由度总数 = (节点数) $\\times$ (每个节点的标准自由度) = $4 \\times 2 = 8$。\n\n2.  **增强自由度（亥维赛函数）：**\n    亥维赛函数 $H(\\boldsymbol{x})$ 用于模拟裂纹面上的位移不连续性。问题陈述指出，亥维赛增强仅附加到节点 $3$ 和 $4$。\n    - 亥维赛增强的节点数：$2$（节点 $3$ 和 $4$）。\n    - 每个节点的增强函数数量：$1$（函数 $H(\\boldsymbol{x})$）。\n    - 每个增强函数的自由度：$2$（每个位移分量一个，即向量 $\\boldsymbol{a}_j = \\{a_{jx}, a_{jy}\\}$）。\n    - 亥维赛增强的总自由度 = (增强节点数) $\\times$ (函数数量) $\\times$ (每个函数的自由度) = $2 \\times 1 \\times 2 = 4$。\n\n3.  **增强自由度（近尖端分支函数）：**\n    近尖端分支函数 $F_\\alpha(\\boldsymbol{x})$ 用于捕捉裂纹尖端的奇异应力和应变场。问题指定使用四个线性无关的分支函数（$F_1, F_2, F_3, F_4$）。这些增强仅附加到节点 $1$ 和 $2$。\n    - 尖端增强的节点数：$2$（节点 $1$ 和 $2$）。\n    - 每个节点的增强函数数量：$4$（函数 $F_1, F_2, F_3, F_4$）。\n    - 每个增强函数的自由度：$2$（每个位移分量一个，即向量 $\\boldsymbol{b}_{k\\alpha}$）。\n    - 尖端增强的总自由度 = (增强节点数) $\\times$ (函数数量) $\\times$ (每个函数的自由度) = $2 \\times 4 \\times 2 = 16$。\n\n4.  **总自由度：**\n    单元的总自由度数是标准自由度与所有增强自由度之和。\n    - 总自由度 = (标准自由度) + (亥维赛自由度) + (尖端自由度)\n    - 总自由度 = $8 + 4 + 16 = 28$。\n\n**增强策略的合理性论证：**\n所提供的策略旨在确保一个稳定且非冗余的列式，避免所得到的线性方程组出现病态问题。这是通过防止基函数之间的线性相关性来实现的。\n\n- **线性相关性问题：** 有限元形函数的单位分解 (PU) 特性表明，对于单元中的任意点 $\\boldsymbol{x}$，都有 $\\sum_i N_i(\\boldsymbol{x}) = 1$。如果一个单元中的所有节点都用同一个函数（例如 $G(\\boldsymbol{x})$）进行增强，那么基函数的增强部分将包含项 $\\sum_i N_i(\\boldsymbol{x}) G(\\boldsymbol{x}) = G(\\boldsymbol{x})$。如果函数 $G(\\boldsymbol{x})$ 已经可以由标准有限元基函数（或另一组增强函数）重现，这就会引入线性相关性，导致刚度矩阵奇异。\n\n- **亥维赛函数与尖端函数的冗余性：** 对于各向同性弹性材料中的裂纹，一套标准的四个分支函数（例如 $F_\\alpha \\in \\{\\sqrt{r}\\sin(\\frac{\\theta}{2}), \\sqrt{r}\\cos(\\frac{\\theta}{2}), \\sqrt{r}\\sin(\\frac{\\theta}{2})\\sin(\\theta), \\sqrt{r}\\cos(\\frac{\\theta}{2})\\sin(\\theta)\\}$）可以在尖端附近表示裂纹面 ($\\theta = \\pm\\pi$) 上的位移跳跃。因此，将亥维赛增强 $H(\\boldsymbol{x})$ 添加到一个已经用全套尖端函数增强的节点上是多余的。由尖端增强基函数所张成的函数空间已经包含了亥维赛函数旨在模拟的跳跃行为。用两套函数同时增强一个节点（或覆盖尖端的一组节点）会引入线性相关性和数值不稳定性。\n\n- **所选策略的稳定性：** 该问题指定了一种通过划分增强任务来避免此问题的策略：\n    1.  靠近尖端的节点（$1$ 和 $2$）用分支函数（$F_\\alpha$）进行增强，以捕捉复杂的奇异场。\n    2.  其支承域被裂纹切割但远离尖端主导区的节点（$3$ 和 $4$）用亥维赛函数（$H$）进行增强，以模拟位移跳跃。\n这种分离确保了基函数保持线性无关。尖端函数处理奇异性（包括尖端处的跳跃），而亥维赛函数处理远离尖端的常规跳跃。这种分工与底层物理原理一致，并导向一个适定且稳定的数值系统。", "answer": "$$\\boxed{28}$$", "id": "3524336"}, {"introduction": "实现 XFEM 的核心在于如何正确地在被不连续面“切割”的单元上进行积分。由于包含富集函数的被积函数是不连续的，标准的求积法则会失效。这个编程练习 [@problem_id:3524345] 将指导您掌握基本的子三角剖分技术，以精确计算经亥维赛函数富集的形函数的积分，这是组装 XFEM 系统矩阵的一项基石技能。", "problem": "考虑一个在计算岩土力学中用于裂缝和界面的扩展有限元法（XFEM）中的四节点双线性四边形有限元。裂缝由水平集函数 $\\phi(x,y)=y$ 表示，不连续性富集使用亥维赛函数 $H(\\phi)$，其中当 $\\phi0$ 时 $H(\\phi)=1$，当 $\\phi0$ 时 $H(\\phi)=0$。该方形单元是轴对齐的，由四个角节点定义，其物理坐标 $(x,y)$ 按左下、右下、右上、左上的顺序排列。在母域 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 上的双线性形函数 $N_I(\\xi,\\eta)$（$I=1,2,3,4$）是标准的四节点四边形基函数。设单元映射对于轴对齐矩形是线性的（仿射），其中 $(x,y)$ 由 $x=x_c+\\frac{L_x}{2}\\xi$ 和 $y=y_c+\\frac{L_y}{2}\\eta$ 给出，其中 $x_c=\\frac{x_{\\min}+x_{\\max}}{2}$，$y_c=\\frac{y_{\\min}+y_{\\max}}{2}$，$L_x=x_{\\max}-x_{\\min}$，$L_y=y_{\\max}-y_{\\min}$。雅可比行列式是常数，等于 $J=\\frac{L_x L_y}{4}$。\n\n你的任务是编写一个完整的、可运行的程序，对于每个给定的测试用例，计算以下内容：\n- 裂缝正侧（$\\{(x,y)\\mid y0\\}$）和负侧（$\\{(x,y)\\mid y0\\}$）相对于单元面积的面积分数。线 $y=0$ 的测度为零，对面积没有贡献。\n- 积分 $\\int_{\\Omega_e} N_I(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$，$I=1,2,3,4$，其中 $\\Omega_e$ 表示物理坐标中的单元域。积分必须通过对单元在裂缝正侧的部分（即多边形区域 $\\Omega_e^+=\\Omega_e\\cap\\{y\\ge 0\\}$，注意边界 $y=0$ 的测度为零）进行子三角剖分，将 $\\Omega_e^+$ 分解为三角形，并应用一个对最高二次多项式精确的三角形求积法则来执行。\n\n使用的基本原理：\n- 亥维赛函数定义：当 $\\phi0$ 时 $H(\\phi)=1$，当 $\\phi0$ 时 $H(\\phi)=0$。\n- 母正方形上的双线性四边形形函数 $N_I(\\xi,\\eta)$ 以及到轴对齐矩形的 $(x,y)$ 坐标的仿射映射。\n- 具有常数雅可比行列式 $J$ 的仿射映射下的积分变换。\n- 足以精确积分二次多项式的精确三角形求积阶。\n\n子三角剖分要求：\n- 用半平面 $y\\ge 0$ 裁剪单元的凸多边形，以获得多边形 $\\Omega_e^+$。\n- 将 $\\Omega_e^+$ 三角剖分为完全覆盖它的不重叠三角形。\n- 对于每个三角形，使用一个标准的3点求积法则，该法则对最高二次多项式是精确的，具有重心坐标点和权重。函数 $f$ 在三角形 $T$ 上的积分必须执行为 $\\int_T f(x,y)\\,\\mathrm{d}A = |T|\\sum_{k=1}^{3} w_k f(x_k,y_k)$，其中 $|T|$ 是三角形面积，$(x_k,y_k)$ 是求积点，$w_k$ 是权重，使得 $\\sum_k w_k=1$ 并且该法则对二次多项式是精确的。\n\n形函数：\n- 在母域 $(\\xi,\\eta)\\in[-1,1]^2$ 上使用标准的四节点双线性四边形基函数：$N_1(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta)$，$N_2(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta)$，$N_3(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta)$，$N_4(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta)$。通过 $\\xi=\\frac{2(x-x_c)}{L_x}$ 和 $\\eta=\\frac{2(y-y_c)}{L_y}$ 反向映射到 $(\\xi,\\eta)$，来计算物理坐标 $(x,y)$ 处的 $N_I$。\n\n测试套件：\n为保证覆盖率，包括以下五个方形单元，每个单元由节点坐标 $(x,y)$ 按顺序定义：左下、右下、右上、左上。\n1. 情况1：$\\{(-1,-1),(1,-1),(1,1),(-1,1)\\}$（裂缝穿过中心；对称分割）。\n2. 情况2：$\\{(2,0.2),(3,0.2),(3,1.2),(2,1.2)\\}$（完全位于 $y=0$ 上方）。\n3. 情况3：$\\{(-0.5,-2.0),(0.5,-2.0),(0.5,-1.0),(-0.5,-1.0)\\}$（完全位于 $y=0$ 下方）。\n4. 情况4：$\\{(0.0,-0.2),(1.0,-0.2),(1.0,0.8),(0.0,0.8)\\}$（非对称地跨越 $y=0$）。\n5. 情况5：$\\{(0.0,0.0),(1.0,0.0),(1.0,1.0),(0.0,1.0)\\}$（边界情况，裂缝与底边 $y=0$ 重合；正侧为整个单元，负侧面积为零）。\n\n输出规格：\n- 对于上述顺序中的每个测试用例，计算：\n  - $f_{\\text{pos}}=\\frac{|\\Omega_e^+|}{|\\Omega_e|}$，\n  - $f_{\\text{neg}}=\\frac{|\\Omega_e^-|}{|\\Omega_e|}$，其中 $\\Omega_e^-=\\Omega_e\\cap\\{y\\le 0\\}$ 且 $|\\cdot|$ 表示面积，\n  - $I_1=\\int_{\\Omega_e} N_1(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$,\n  - $I_2=\\int_{\\Omega_e} N_2(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$,\n  - $I_3=\\int_{\\Omega_e} N_3(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$,\n  - $I_4=\\int_{\\Omega_e} N_4(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A$。\n- 你的程序应该生成单行输出，包含所有测试用例的结果，格式为方括号内以逗号分隔的列表。对于按顺序 $k=1,2,3,4,5$ 的情况 $k$，将六个值 $[f_{\\text{pos}},f_{\\text{neg}},I_1,I_2,I_3,I_4]$ 追加到最终列表中，因此最终输出是按测试套件顺序排列的30个浮点数的扁平列表。\n\n所有值都是无量纲的，必须以浮点数形式报告。此问题不涉及角度，因此不需要角度单位。程序必须完全自包含，不得读取输入文件；它应按上述规定嵌入测试套件，并以要求的格式精确打印最终答案。", "solution": "用户提供的问题被评估为有效，因为它在科学上基于计算力学的原理，特别是扩展有限元法（XFEM）。该问题定义明确、客观，并包含推导唯一且可验证解所需的所有必要信息。因此，我们将进行完整的推导和实现。\n\n该问题要求计算一个被裂缝切割的四节点四边形单元的面积分数和富集形函数积分。裂缝由水平集函数 $\\phi(x,y) = y$ 定义，对应于 $y=0$ 处的一条水平线。富集基于亥维赛函数 $H(\\phi)$，当 $\\phi  0$ 时为1，当 $\\phi  0$ 时为0。因此，每个标准形函数 $N_I$ 的目标积分为：\n$$ I_I = \\int_{\\Omega_e} N_I(x,y)\\,H(\\phi(x,y))\\,\\mathrm{d}A $$\n其中 $\\Omega_e$ 是有限元的域。根据 $H(\\phi(x,y)) = H(y)$ 的定义，积分简化为在单元中 $y0$ 的部分上进行积分：\n$$ I_I = \\int_{\\Omega_e \\cap \\{y0\\}} N_I(x,y)\\,\\mathrm{d}A = \\int_{\\Omega_e^+} N_I(x,y)\\,\\mathrm{d}A $$\n域 $\\Omega_e^+$ 是单元中 $y$ 坐标为正的部分。问题指明线 $y=0$ 的测度为零，对面积或积分没有贡献。\n\n每个测试用例的求解过程包括以下步骤：\n1.  **几何表征**：定义单元的几何形状并确定积分域 $\\Omega_e^+$。\n2.  **面积分数计算**：计算单元面积 $|\\Omega_e|$、正部分面积 $|\\Omega_e^+|$ 和负部分面积 $|\\Omega_e^-|$，然后求得分数 $f_{\\text{pos}} = |\\Omega_e^+|/|\\Omega_e|$ 和 $f_{\\text{neg}} = |\\Omega_e^-|/|\\Omega_e|$。\n3.  **数值积分**：对域 $\\Omega_e^+$ 进行三角剖分，并在每个三角形上应用3点求积法则来计算积分 $I_I$。\n\n让我们详细说明每个步骤。\n\n**1. 几何表征和裁剪**\n对于每个测试用例，单元是一个由四个角节点定义的轴对齐正方形或矩形。让这些节点的坐标定义单元的边界：$x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}$。单元域为 $\\Omega_e = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$。积分域为 $\\Omega_e^+ = \\Omega_e \\cap \\{(x,y) | y  0\\}$。由于单元是轴对齐矩形，所得的域 $\\Omega_e^+$ 也是一个矩形（或为空）。我们可以通过考虑单元的y范围来确定 $\\Omega_e^+$：\n- 如果 $y_{\\min} \\ge 0$，整个单元位于正半平面。因此，$\\Omega_e^+ = \\Omega_e$。\n- 如果 $y_{\\max} \\le 0$，整个单元位于负半平面。因此，$\\Omega_e^+$ 是一个空集，其面积为 $0$。\n- 如果 $y_{\\min}  0  y_{\\max}$，单元被线 $y=0$ 切割。域 $\\Omega_e^+$ 是一个由 $[x_{\\min}, x_{\\max}] \\times [0, y_{\\max}]$ 定义的矩形。\n\n**2. 面积分数计算**\n单元的总面积为 $|\\Omega_e| = (x_{\\max}-x_{\\min})(y_{\\max}-y_{\\min}) = L_x L_y$。正部分的面积 $|\\Omega_e^+|$ 可以从定义 $\\Omega_e^+$ 的多边形的顶点计算。一种通用方法是针对具有顶点 $(x_1, y_1), (x_2, y_2), \\dots, (x_n, y_n)$ 的多边形的鞋带公式：\n$$ |\\Omega_e^+| = \\frac{1}{2} \\left| \\sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \\right| \\quad (\\text{其中 } (x_{n+1}, y_{n+1}) = (x_1, y_1)) $$\n负部分的面积为 $|\\Omega_e^-| = |\\Omega_e| - |\\Omega_e^+|$。面积分数则为：\n$$ f_{\\text{pos}} = \\frac{|\\Omega_e^+|}{|\\Omega_e|} \\quad \\text{和} \\quad f_{\\text{neg}} = \\frac{|\\Omega_e^-|}{|\\Omega_e|} = 1 - f_{\\text{pos}} $$\n\n**3. 数值积分**\n积分 $I_I$ 在 $\\Omega_e^+$ 上计算。如果 $|\\Omega_e^+| = 0$，则对所有 $I$ 都有 $I_I=0$。否则，我们进行三角剖分和求积。\n\n**3.1 三角剖分：**\n域 $\\Omega_e^+$ 是一个凸矩形，可以简单地三角剖分为两个三角形。设矩形 $\\Omega_e^+$ 的顶点按逆时针顺序为 $v_1, v_2, v_3, v_4$。我们可以形成两个三角形，$T_1 = (v_1, v_2, v_3)$ 和 $T_2 = (v_1, v_3, v_4)$。\n\n**3.2 求积法则：**\n问题指定了一个对最高二次多项式精确的三角形3点求积法则。对于一个具有顶点 $p_1, p_2, p_3$ 的三角形 $T$，函数 $f(x,y)$ 的积分近似为：\n$$ \\int_T f(x,y) \\, \\mathrm{d}A \\approx |T| \\sum_{k=1}^{3} w_k f(q_k) $$\n其中 $|T|$ 是三角形的面积。指定的法则使用位于三角形边中点的求积点 $q_k$ 和相等的权重 $w_k = 1/3$。\n$$ q_1 = \\frac{p_1+p_2}{2}, \\quad q_2 = \\frac{p_2+p_3}{2}, \\quad q_3 = \\frac{p_3+p_1}{2} $$\n在 $\\Omega_e^+$ 上的总积分是其构成三角形上的积分之和：\n$$ I_I = \\int_{T_1} N_I(x,y) \\, \\mathrm{d}A + \\int_{T_2} N_I(x,y) \\, \\mathrm{d}A $$\n\n**3.3 形函数求值：**\n为了在求积点 $(x_q, y_q)$ 处评估形函数 $N_I(x,y)$，我们必须首先将该点从物理域映射到母域 $(\\xi_q, \\eta_q) \\in [-1,1]^2$。映射由以下公式给出：\n$$ \\xi_q = \\frac{2(x_q-x_c)}{L_x} \\quad \\text{和} \\quad \\eta_q = \\frac{2(y_q-y_c)}{L_y} $$\n其中 $L_x = x_{\\max}-x_{\\min}$，$L_y = y_{\\max}-y_{\\min}$，$x_c = (x_{\\min}+x_{\\max})/2$，$y_c = (y_{\\min}+y_{\\max})/2$。注意，这些参数指的是原始的、未裁剪的单元。计算 $(\\xi_q,\\eta_q)$ 后，我们使用标准的双线性形函数：\n\\begin{align*}\nN_1(\\xi_q, \\eta_q) = \\frac{1}{4}(1-\\xi_q)(1-\\eta_q) \\\\\nN_2(\\xi_q, \\eta_q) = \\frac{1}{4}(1+\\xi_q)(1-\\eta_q) \\\\\nN_3(\\xi_q, \\eta_q) = \\frac{1}{4}(1+\\xi_q)(1+\\eta_q) \\\\\nN_4(\\xi_q, \\eta_q) = \\frac{1}{4}(1-\\xi_q)(1+\\eta_q)\n\\end{align*}\n被积函数 $N_I(x,y)$ 是 $(x,y)$ 的双线性函数，即二次多项式。所选的求积法则对此类多项式是精确的，因此数值积分将产生精确结果，直到浮点精度。\n\n对提供的五个测试用例中的每一个都实现了整个过程。对于单元完全位于裂缝上方或下方的情况，计算会显著简化。如果单元完全位于下方（$y_{\\max} \\le 0$），则 $f_{\\text{pos}}=0$，$f_{\\text{neg}}=1$，并且所有 $I_I=0$。如果它完全位于上方（$y_{\\min} \\ge 0$），则 $f_{\\text{pos}}=1$，$f_{\\text{neg}}=0$。在这种情况下，积分 $\\int_{\\Omega_e} N_I \\mathrm{d}A$ 可以解析计算：\n$$ \\int_{\\Omega_e} N_I \\mathrm{d}A = \\int_{-1}^{1}\\int_{-1}^{1} N_I(\\xi, \\eta) J \\mathrm{d}\\xi \\mathrm{d}\\eta = J \\int_{-1}^{1}\\int_{-1}^{1} N_I(\\xi, \\eta) \\mathrm{d}\\xi \\mathrm{d}\\eta = J \\times 1 = \\frac{L_x L_y}{4} $$\n因此，对于一个完全为正的单元，每个积分 $I_I$ 等于单元面积的四分之一。这为数值实现提供了一个有用的验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    # Test suite: 5 square elements defined by corner nodes (x,y)\n    # Order: bottom-left, bottom-right, top-right, top-left.\n    test_cases = [\n        # Case 1: Symmetric split\n        [(-1.0, -1.0), (1.0, -1.0), (1.0, 1.0), (-1.0, 1.0)],\n        # Case 2: Entirely above y=0\n        [(2.0, 0.2), (3.0, 0.2), (3.0, 1.2), (2.0, 1.2)],\n        # Case 3: Entirely below y=0\n        [(-0.5, -2.0), (0.5, -2.0), (0.5, -1.0), (-0.5, -1.0)],\n        # Case 4: Asymmetric straddle of y=0\n        [(0.0, -0.2), (1.0, -0.2), (1.0, 0.8), (0.0, 0.8)],\n        # Case 5: Boundary case on y=0\n        [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n    ]\n    \n    all_results = []\n    for case_nodes in test_cases:\n        results = compute_for_element(case_nodes)\n        all_results.extend(results)\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{val:.15f}' for val in all_results)}]\"\n    print(output_str)\n\ndef compute_for_element(nodes):\n    \"\"\"\n    Computes area fractions and enriched integrals for a single element.\n\n    Args:\n        nodes (list of tuples): A list of four (x, y) coordinates for the\n                                element nodes in the order: BL, BR, TR, TL.\n\n    Returns:\n        list: A list of six float values: [f_pos, f_neg, I1, I2, I3, I4].\n    \"\"\"\n    nodes_arr = np.array(nodes, dtype=float)\n    x_coords, y_coords = nodes_arr[:, 0], nodes_arr[:, 1]\n    \n    x_min, x_max = np.min(x_coords), np.max(x_coords)\n    y_min, y_max = np.min(y_coords), np.max(y_coords)\n\n    L_x = x_max - x_min\n    L_y = y_max - y_min\n    \n    if L_x == 0 or L_y == 0: # Degenerate element\n        return [0.0] * 6\n\n    element_area = L_x * L_y\n    \n    # 1. Determine the vertices of the positive polygon Omega_e^+\n    positive_polygon_verts = []\n    if y_max = 0:\n        # Element is entirely below or on the crack line\n        positive_area = 0.0\n    elif y_min >= 0:\n        # Element is entirely above or on the crack line\n        positive_polygon_verts = [(x_min, y_min), (x_max, y_min), (x_max, y_max), (x_min, y_max)]\n        positive_area = element_area\n    else: # y_min  0  y_max\n        # Element is cut by the crack\n        positive_polygon_verts = [(x_min, 0), (x_max, 0), (x_max, y_max), (x_min, y_max)]\n        positive_area = L_x * y_max\n        \n    # 2. Calculate area fractions\n    f_pos = positive_area / element_area\n    f_neg = 1.0 - f_pos\n\n    # 3. Calculate integrals I1, I2, I3, I4\n    integrals = np.zeros(4)\n    if not positive_polygon_verts:\n        return [f_pos, f_neg, 0.0, 0.0, 0.0, 0.0]\n        \n    # --- Triangulation and Quadrature ---\n    # The positive polygon is always a rectangle, so we can split it into two triangles.\n    # Vertices v1, v2, v3, v4 in CCW order\n    v1, v2, v3, v4 = [np.array(p) for p in positive_polygon_verts]\n    triangles = [(v1, v2, v3), (v1, v3, v4)]\n\n    # Element mapping parameters\n    x_c = (x_min + x_max) / 2.0\n    y_c = (y_min + y_max) / 2.0\n    \n    for tri_verts in triangles:\n        p1, p2, p3 = tri_verts\n        \n        # Triangle area using cross product\n        tri_area = 0.5 * np.abs(np.cross(p2 - p1, p3 - p1))\n        \n        # 3-point quadrature: midpoints of sides, weights are 1/3\n        q_points = [\n            (p1 + p2) / 2.0,\n            (p2 + p3) / 2.0,\n            (p3 + p1) / 2.0,\n        ]\n        \n        n_vals_at_q_points = np.zeros((3, 4))\n        for i, q_point in enumerate(q_points):\n            x_q, y_q = q_point\n            \n            # Map physical coords (x_q, y_q) to parent coords (xi, eta)\n            xi = 2.0 * (x_q - x_c) / L_x if L_x != 0 else 0\n            eta = 2.0 * (y_q - y_c) / L_y if L_y != 0 else 0\n            \n            # Evaluate shape functions N_I(xi, eta)\n            N1 = 0.25 * (1 - xi) * (1 - eta)\n            N2 = 0.25 * (1 + xi) * (1 - eta)\n            N3 = 0.25 * (1 + xi) * (1 + eta)\n            N4 = 0.25 * (1 - xi) * (1 + eta)\n            n_vals_at_q_points[i, :] = [N1, N2, N3, N4]\n\n        # Sum contributions from quadrature points\n        # (weight is 1/3 for all points)\n        avg_n_vals = np.mean(n_vals_at_q_points, axis=0)\n        integrals += tri_area * avg_n_vals\n        \n    return [f_pos, f_neg] + integrals.tolist()\n    \n# Run the solver\nsolve()\n\n```", "id": "3524345"}, {"introduction": "超越线弹性断裂力学的范畴，这个高级实践将探索 XFEM 在内聚力断裂中的应用，这在岩土力学中是一种常见情景。您将实现一个能够捕捉复杂非线性行为（包括“突弹回落”失稳）的模型。本练习 [@problem_id:3524303] 强调了精确数值积分的关键作用，并要求您对不同的求积方案进行基准测试，从而揭示它们对预测复杂荷载-位移响应精度的影响。", "problem": "考虑一个将单个扩展有限元法 (XFEM) 切割单元简化为标量平衡问题的无量纲代理模型，该问题分离了具有回弹 (snap-back) 特征的黏聚界面的数值积分。其推导始于虚功原理和一个黏聚区模型。\n\n一个双线性牵引-分离律由以下无量纲参数定义：初始界面刚度 $K_0$、峰值黏聚牵引力 $\\sigma_c$ 和最终张开位移 $\\delta_f$。将峰值牵引力下的弹性张开位移定义为 $\\delta_p = \\sigma_c / K_0$。牵引-分离律 $t(\\delta)$ 及其导数 $t'(\\delta)$ 为\n$$\nt(\\delta) = \\begin{cases}\nK_0 \\, \\delta,  0 \\le \\delta \\le \\delta_p,\\\\\n\\sigma_c \\left(1 - \\dfrac{\\delta - \\delta_p}{\\delta_f - \\delta_p}\\right),  \\delta_p  \\delta \\le \\delta_f,\\\\\n0,  \\delta  \\delta_f,\n\\end{cases}\n\\qquad\nt'(\\delta) = \\begin{cases}\nK_0,  0 \\le \\delta \\le \\delta_p,\\\\\n-\\dfrac{\\sigma_c}{\\delta_f - \\delta_p},  \\delta_p  \\delta \\le \\delta_f,\\\\\n0,  \\delta  \\delta_f.\n\\end{cases}\n$$\n\n设切割单元内部的黏聚线段由 $s \\in [0,1]$ 参数化，其长度为 $L_\\Gamma = 1$。沿界面的位移跳跃（张开）场被建模为 $\\delta(s) = \\alpha(s) \\, w$，其中 $w \\ge 0$ 是一个标量幅值，$\\alpha(s)$ 是一个预设的形函数，用于模拟切割单元内的非均匀加密：\n$$\n\\alpha(s) = 1 + \\beta \\, (2s - 1),\n$$\n其中 $\\beta \\in [0,1)$ 控制空间变化。注意 $\\int_0^1 \\alpha(s) \\, ds = 1$。\n\n合黏聚力是线积分\n$$\nF_\\mathrm{coh}(w) = \\int_0^1 t\\big(\\alpha(s)\\, w\\big) \\, ds,\n\\quad\n\\frac{dF_\\mathrm{coh}}{dw}(w) = \\int_0^1 t'\\big(\\alpha(s)\\, w\\big) \\, \\alpha(s) \\, ds.\n$$\n\n将此界面与一个刚度为 $K_b$ 的线性“体”弹簧串联，代表了从切割单元看，周围介质的远场体积刚度。在施加的总位移 $U \\ge 0$下，串联的相容性与平衡条件给出，其中 $\\overline{\\alpha} = \\int_0^1 \\alpha(s)\\, ds = 1$，\n$$\nP = K_b \\, (U - \\overline{\\alpha} \\, w) \\quad \\text{和} \\quad P = F_\\mathrm{coh}(w),\n$$\n这得到了关于未知数 $w$ 的标量平衡方程：\n$$\nR(w; U) := K_b \\, (U - \\overline{\\alpha} \\, w) - F_\\mathrm{coh}(w) = 0.\n$$\n对于每个施加的 $U$，反作用力为 $P(U) = K_b \\, (U - \\overline{\\alpha} \\, w(U))$。当黏聚行为相对于 $K_b$ 充分软化时，载荷-位移曲线 $P(U)$ 会表现出回弹段（负斜率区域）。\n\n在数值实现中，$F_\\mathrm{coh}(w)$ 和 $\\dfrac{dF_\\mathrm{coh}}{dw}(w)$ 必须通过在 $[0,1]$ 上的数值积分来近似。对用于切割界面积分的以下三类数值积分方案进行基准测试：\n\n1. 子三角剖分（复合高斯积分）：将 $[0,1]$ 划分为 $n_\\mathrm{sub}$ 个相等的子区间，并在每个子区间上应用 $q$ 点高斯-勒让德积分；然后将贡献求和。\n\n2. 矩匹配积分（固定横坐标）：选择 $m$ 个内点 $s_i = \\dfrac{i - 1/2}{m}$（其中 $i=1,\\dots,m$），并通过求解线性矩匹配系统来确定权重 $w_i$\n$$\n\\sum_{i=1}^m w_i \\, s_i^k = \\int_0^1 s^k \\, ds = \\frac{1}{k+1}, \\quad k = 0,1,\\dots,m-1.\n$$\n然后近似 $\\int_0^1 f(s)\\, ds \\approx \\sum_{i=1}^m w_i \\, f(s_i)$。\n\n3. 广义高斯积分：在 $[0,1]$ 上应用标准的 $n$ 点高斯-勒让德积分。\n\n任务是实现一个位移控制求解器，用于求解在给定区间内的一组均匀间隔的位移 $U_j$ 处的 $w(U)$。该求解器使用带回溯线搜索的牛顿法，其中残差 $R(w;U)$、切线（导数）$\\dfrac{\\partial R}{\\partial w}(w;U) = -K_b \\overline{\\alpha} - \\dfrac{dF_\\mathrm{coh}}{dw}(w)$ 和反力 $P(U)$ 都通过指定的数值积分方案计算。一个高分辨率的“参考”解 $P_\\mathrm{ref}(U)$ 使用子三角剖分（$n_\\mathrm{sub} = 400$ 和 $q = 3$）来定义。\n\n为所有非边界情况定义以下固定的无量纲参数：\n- $K_b = 20$，\n- $\\sigma_c = 1$，\n- $K_0 = 2000$，\n- $\\delta_p = \\sigma_c/K_0$，\n- $\\delta_f = 5 \\, \\delta_p$，\n- $\\beta = 0.5$，\n- $U \\in [0, 0.004]$ 在 $N_U = 200$ 个均匀间隔点上采样。\n\n定义计算出的载荷-位移曲线 $P(U_j)$ 相对于参考解 $P_\\mathrm{ref}(U_j)$ 的均方根误差 (RMSE) 为\n$$\n\\mathrm{RMSE} = \\sqrt{ \\frac{1}{N_U} \\sum_{j=1}^{N_U} \\left( P(U_j) - P_\\mathrm{ref}(U_j) \\right)^2 }.\n$$\n\n测试套件。对于基准实验，计算以下七个案例的 RMSE：\n- 案例1（子三角剖分）：$n_\\mathrm{sub} = 1$，$q = 2$，$\\beta = 0.5$。\n- 案例2（子三角剖分）：$n_\\mathrm{sub} = 4$，$q = 2$，$\\beta = 0.5$。\n- 案例3（广义高斯积分）：$n = 3$，$\\beta = 0.5$。\n- 案例4（矩匹配积分）：$m = 3$，$\\beta = 0.5$。\n- 案例5（广义高斯积分）：$n = 8$，$\\beta = 0.5$。\n- 案例6（矩匹配积分）：$m = 8$，$\\beta = 0.5$。\n- 案例7（均匀张开的边界情况）：广义高斯积分，$n = 2$，但设置 $\\beta = 0$ 以强制 $\\alpha(s) \\equiv 1$，从而使被积函数在界面上空间恒定，且所有三种积分族对于0次多项式都变得精确。\n\n你的程序必须：\n- 实现基于残差的牛顿求解器，并使用线搜索来求解每个 $U_j$，其中的残差和切线（导数）通过指定的数值积分方案进行评估。\n- 使用上面定义的高分辨率参考积分来生成 $P_\\mathrm{ref}(U_j)$。\n- 对于测试套件中的每个案例，计算并记录 $P(U_j)$ 相对于 $P_\\mathrm{ref}(U_j)$ 的 RMSE。\n- 全程使用无量纲单位，并以无量纲浮点数报告 RMSE。\n\n最终输出格式。程序应生成单行输出，其中包含七个案例的 RMSE 值，格式为逗号分隔的十进制数列表，保留六位小数，并用方括号括起来，顺序为案例1到案例7（例如，\"[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901,0.000000]\"）。", "solution": "经评估，问题陈述有效。它在科学上植根于计算断裂力学原理，定量上是适定的、客观的且自洽的。它提出了一个非平凡的数值基准测试任务，这是计算岩土力学领域评估数值方法的标准任务。因此，我们可以着手提供一个解答。\n\n该问题要求实现并比较几种用于简化黏聚界面问题的数值积分方案，该问题表现出回弹失稳。该模型由一个黏聚界面与一个线性体积弹簧串联组成，其行为由双线性牵引-分离律描述。目标是计算全局载荷-位移响应 $P(U)$，并对照高保真度参考解来量化不同数值积分规则的准确性。\n\n问题的核心在于求解在不同指定总位移 $U$ 下，关于黏聚张开幅值 $w$ 的标量非线性平衡方程：\n$$\nR(w; U) = K_b (U - \\overline{\\alpha} w) - F_\\mathrm{coh}(w) = 0\n$$\n这里，$K_b$ 是体积弹簧的刚度，$\\overline{\\alpha} = \\int_0^1 \\alpha(s) ds = 1$ 是张开形函数的平均值。关键项，即合黏聚力 $F_\\mathrm{coh}(w)$，是界面域 $s \\in [0,1]$ 上的一个积分：\n$$\nF_\\mathrm{coh}(w) = \\int_0^1 t\\big(\\delta(s)\\big) \\, ds = \\int_0^1 t\\big(\\alpha(s)\\, w\\big) \\, ds\n$$\n其中 $t(\\delta)$ 是分段线性黏聚牵引-分离律，$\\delta(s) = \\alpha(s) w$ 是局部张开位移，而 $\\alpha(s) = 1 + \\beta(2s-1)$ 定义了其空间变化。\n\n为求解 $R(w; U) = 0$，我们采用牛顿法，这是一个迭代格式，由下式给出：\n$$\nw_{k+1} = w_k - \\left[ \\frac{\\partial R}{\\partial w}(w_k; U) \\right]^{-1} R(w_k; U)\n$$\n切向刚度 $\\frac{\\partial R}{\\partial w}$ 需要黏聚力的导数，这可以通过在积分号下求导得到：\n$$\n\\frac{\\partial R}{\\partial w}(w; U) = -K_b \\overline{\\alpha} - \\frac{dF_\\mathrm{coh}}{dw}(w) = -K_b - \\int_0^1 t'\\big(\\alpha(s)\\, w\\big) \\, \\alpha(s) \\, ds\n$$\n其中 $t'(\\delta)$ 是黏聚律的切线（导数）。因为被积函数 $t(\\alpha(s)w)$ 是非光滑的（由于 $t(\\delta)$ 的双线性性质），并且其函数形式随着 $w$ 的增加而改变，所以 $F_\\mathrm{coh}$ 和 $\\frac{dF_\\mathrm{coh}}{dw}$ 的积分通常没有闭式解，必须进行数值计算。\n\n该基准测试评估了三类用于近似积分 $\\int_0^1 f(s) ds \\approx \\sum_{i=1}^N w_i f(s_i)$ 的数值积分规则：\n1.  **子三角剖分（复合高斯积分）**：将区间 $[0,1]$ 划分为 $n_\\mathrm{sub}$ 个相等的子区间。在每个子区间上，将标准点和权重从 $[-1,1]$ 映射到该子区间后，应用 $q$ 点高斯-勒让德积分规则。这是一种稳健且常用的方法，用于对具有局部非光滑性的函数进行积分。\n2.  **矩匹配积分**：此自定义规则将积分点 $s_i$ 固定为 $[0,1]$ 的 $m$ 个等长划分的中点。然后，通过强制该规则精确积分前 $m$ 个单项式（$s^k$ for $k=0, \\dots, m-1$）来确定权重 $w_i$。这导出一个用于求解权重的范德蒙线性系统：$\\sum_{i=1}^m w_i s_i^k = 1/(k+1)$。\n3.  **广义高斯积分**：这是应用于整个区间 $[0,1]$ 的标准 $n$ 点高斯-勒让德积分。虽然它对光滑（多项式）函数非常精确，但对于非光滑的被积函数，其性能可能会下降。\n\n总体求解算法流程如下：\n首先，为 $N_U = 200$ 个均匀分布在 $[0, 0.004]$ 区间内的点 $U_j$ 生成一条高分辨率的参考载荷-位移曲线 $P_\\mathrm{ref}(U_j)$。这是通过使用一个高度精细的复合高斯规则（$n_\\mathrm{sub}=400, q=3$）完成的，从而确保对积分进行非常精确的近似。\n\n对于七个测试案例中的每一个，都使用指定的低阶数值积分规则计算一条新的 $P(U_j)$ 曲线。对于每个位移步 $U_j$，使用牛顿法求解非线性方程 $R(w; U_j) = 0$ 以得到 $w_j$。上一步的解 $w_{j-1}$ 作为当前步的初始猜测，这种技术被称为路径跟踪。牛顿求解器中加入了回溯线搜索以实现全局收敛，当系统响应高度非线性时，尤其是在峰值载荷附近和切向刚度急剧变化的回弹期间，这一点至关重要。\n\n一旦找到收敛解 $w_j$，外部反作用力就可计算为 $P_j = K_b(U_j - w_j)$。在计算出给定案例的完整 $P(U_j)$ 曲线后，使用均方根误差 (RMSE) 对照参考解来衡量其准确性：\n$$\n\\mathrm{RMSE} = \\sqrt{ \\frac{1}{N_U} \\sum_{j=1}^{N_U} \\left( P(U_j) - P_\\mathrm{ref}(U_j) \\right)^2 }\n$$\n该实现将构建在一个 Python 类中，该类封装了物理参数、所选的数值积分方案和数值求解器。这允许通过为参考案例和七个测试案例分别实例化该类来清晰地执行基准研究，最终收集并报告所得的 RMSE 值。$\\beta=0$ 的特殊情况用作验证测试，因为此时被积函数变为常数，所有指定的数值积分规则都应得到精确积分，从而产生接近于零的 RMSE。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark of quadrature schemes for a cohesive interface problem.\n    \"\"\"\n\n    class CohesiveModelSolver:\n        \"\"\"\n        Solves the cohesive interface problem for a given set of parameters and quadrature rule.\n        \"\"\"\n        def __init__(self, Kb, sigma_c, K0, delta_f, beta,\n                     quad_type, quad_params, U_range, N_U,\n                     newton_tol=1e-12, newton_max_iter=30, line_search_eta_min=1e-6):\n            \n            self.Kb = Kb\n            self.sigma_c = sigma_c\n            self.K0 = K0\n            self.delta_f = delta_f\n            self.beta = beta\n            self.delta_p = self.sigma_c / self.K0\n            \n            self.U_pts = np.linspace(U_range[0], U_range[1], N_U)\n            \n            self.newton_tol = newton_tol\n            self.newton_max_iter = newton_max_iter\n            self.line_search_eta_min = line_search_eta_min\n\n            self.quad_pts, self.quad_wts = self._generate_quadrature(quad_type, quad_params)\n            \n            # Pre-calculate alpha values at quadrature points\n            self.alpha_vals = self.alpha(self.quad_pts)\n\n        def _generate_quadrature(self, quad_type, quad_params):\n            \"\"\"Generates quadrature points and weights for the interval [0, 1].\"\"\"\n            if quad_type == 'subtriangulation':\n                n_sub, q = quad_params\n                pts, wts = np.polynomial.legendre.leggauss(q)\n                sub_len = 1.0 / n_sub\n                all_pts = []\n                all_wts = []\n                for i in range(n_sub):\n                    a, b = i * sub_len, (i + 1) * sub_len\n                    all_pts.extend((b - a) / 2.0 * pts + (a + b) / 2.0)\n                    all_wts.extend((b - a) / 2.0 * wts)\n                return np.array(all_pts), np.array(all_wts)\n\n            elif quad_type == 'moment_fitted':\n                m = quad_params\n                pts = (np.arange(m) + 0.5) / m\n                V = np.vander(pts, increasing=True).T\n                b = 1.0 / (np.arange(m) + 1.0)\n                wts = solve_linear_system(V, b)\n                return pts, wts\n\n            elif quad_type == 'generalized_gaussian':\n                n = quad_params\n                pts, wts = np.polynomial.legendre.leggauss(n)\n                # Map from [-1, 1] to [0, 1]\n                mapped_pts = 0.5 * (pts + 1.0)\n                mapped_wts = 0.5 * wts\n                return mapped_pts, mapped_wts\n\n            else:\n                raise ValueError(f\"Unknown quadrature type: {quad_type}\")\n\n        def alpha(self, s):\n            \"\"\"Opening shape function.\"\"\"\n            return 1.0 + self.beta * (2.0 * s - 1.0)\n\n        def t(self, delta):\n            \"\"\"Bilinear traction-separation law (vectorized).\"\"\"\n            traction = np.zeros_like(delta, dtype=float)\n            \n            mask1 = (delta > 0)  (delta = self.delta_p)\n            traction[mask1] = self.K0 * delta[mask1]\n            \n            mask2 = (delta > self.delta_p)  (delta = self.delta_f)\n            traction[mask2] = self.sigma_c * (1.0 - (delta[mask2] - self.delta_p) / (self.delta_f - self.delta_p))\n            \n            return traction\n\n        def t_prime(self, delta):\n            \"\"\"Tangent of the traction-separation law (vectorized).\"\"\"\n            tangent = np.zeros_like(delta, dtype=float)\n            \n            mask1 = (delta > 0)  (delta = self.delta_p)\n            tangent[mask1] = self.K0\n            \n            mask2 = (delta > self.delta_p)  (delta = self.delta_f)\n            tangent[mask2] = -self.sigma_c / (self.delta_f - self.delta_p)\n            \n            return tangent\n\n        def F_coh(self, w):\n            \"\"\"Resultant cohesive force.\"\"\"\n            delta_vals = self.alpha_vals * w\n            traction_vals = self.t(delta_vals)\n            return np.dot(traction_vals, self.quad_wts)\n\n        def dF_coh_dw(self, w):\n            \"\"\"Derivative of the resultant cohesive force.\"\"\"\n            delta_vals = self.alpha_vals * w\n            tangent_vals = self.t_prime(delta_vals)\n            return np.dot(tangent_vals * self.alpha_vals, self.quad_wts)\n        \n        def _solve_w_for_U(self, U, w_guess):\n            \"\"\"Solves R(w; U) = 0 using Newton's method with line search.\"\"\"\n            w = w_guess\n            for _ in range(self.newton_max_iter):\n                # Calculate residual\n                res = self.Kb * (U - w) - self.F_coh(w)\n                \n                if np.abs(res)  self.newton_tol:\n                    return w\n\n                # Calculate tangent stiffness\n                dR_dw = -self.Kb - self.dF_coh_dw(w)\n                \n                if abs(dR_dw)  1e-15: # Avoid division by zero\n                    return w\n\n                # Newton step\n                dw = -res / dR_dw\n                \n                # Backtracking line search\n                eta = 1.0\n                step_accepted = False\n                while eta > self.line_search_eta_min:\n                    w_new = w + eta * dw\n                    if w_new  0: # Enforce physical constraint w >= 0\n                        eta /= 2.0\n                        continue\n                    \n                    res_new = self.Kb * (U - w_new) - self.F_coh(w_new)\n                    \n                    if np.abs(res_new)  np.abs(res):\n                        w = w_new\n                        step_accepted = True\n                        break\n                    \n                    eta /= 2.0\n                \n                if not step_accepted:\n                    # Line search failed, exit Newton loop\n                    break\n\n            return w\n\n        def compute_P_U_curve(self):\n            \"\"\"Computes the full load-displacement P(U) curve.\"\"\"\n            w = 0.0\n            P_vals = []\n            for U in self.U_pts:\n                w = self._solve_w_for_U(U, w)\n                P = self.Kb * (U - w)\n                P_vals.append(P)\n            return np.array(P_vals)\n\n    # --- Fixed Parameters ---\n    Kb = 20.0\n    sigma_c = 1.0\n    K0 = 2000.0\n    delta_p = sigma_c / K0\n    delta_f = 5.0 * delta_p\n    beta_std = 0.5\n    U_range = [0, 0.004]\n    N_U = 200\n\n    # --- Reference Solution ---\n    ref_solver = CohesiveModelSolver(Kb, sigma_c, K0, delta_f, beta_std,\n                                     quad_type='subtriangulation', quad_params=(400, 3),\n                                     U_range=U_range, N_U=N_U)\n    P_ref = ref_solver.compute_P_U_curve()\n\n    # --- Test Suite ---\n    test_cases = [\n        {'name': 'Case 1', 'quad_type': 'subtriangulation', 'quad_params': (1, 2), 'beta': beta_std},\n        {'name': 'Case 2', 'quad_type': 'subtriangulation', 'quad_params': (4, 2), 'beta': beta_std},\n        {'name': 'Case 3', 'quad_type': 'generalized_gaussian', 'quad_params': 3, 'beta': beta_std},\n        {'name': 'Case 4', 'quad_type': 'moment_fitted', 'quad_params': 3, 'beta': beta_std},\n        {'name': 'Case 5', 'quad_type': 'generalized_gaussian', 'quad_params': 8, 'beta': beta_std},\n        {'name': 'Case 6', 'quad_type': 'moment_fitted', 'quad_params': 8, 'beta': beta_std},\n        {'name': 'Case 7', 'quad_type': 'generalized_gaussian', 'quad_params': 2, 'beta': 0.0},\n    ]\n\n    rmse_results = []\n    for case in test_cases:\n        solver = CohesiveModelSolver(Kb, sigma_c, K0, delta_f, case['beta'],\n                                     case['quad_type'], case['quad_params'],\n                                     U_range=U_range, N_U=N_U)\n        P_case = solver.compute_P_U_curve()\n        \n        rmse = np.sqrt(np.mean((P_case - P_ref)**2))\n        rmse_results.append(rmse)\n\n    # --- Final Output ---\n    formatted_results = [f\"{r:.6f}\" for r in rmse_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3524303"}]}