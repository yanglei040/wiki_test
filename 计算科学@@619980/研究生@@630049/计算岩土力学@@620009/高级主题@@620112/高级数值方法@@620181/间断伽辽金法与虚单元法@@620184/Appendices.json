{"hands_on_practices": [{"introduction": "在离散化双曲型方程（如弹性波方程）时，一个核心问题是数值格式如何传播不同波长的波。色散分析是评估数值格式精度的经典方法，它将数值相速度与精确相速度进行比较。本练习将通过推导一维弹性杆的数值色散关系，直接比较中心通量和迎风通量这两种常用数值通量的性质，从而揭示间断Galerkin方法的基本表现。[@problem_id:3518428]", "problem": "考虑均匀一维弹性杆中的小振幅纵波，其由线性弹性动力学的一阶对称双曲形式控制：\n- 动量平衡：$\\rho\\, v_{t} = \\sigma_{x}$，\n- 运动学和本构关系：$\\sigma_{t} = E\\, v_{x}$，\n其中 $v(x,t)$ 是质点速度，$\\sigma(x,t)$ 是轴向应力，$\\rho$ 是质量密度，$E$ 是杨氏模量。波速为 $c = \\sqrt{E/\\rho}$。将该系统写为 $q_{t} + B\\, q_{x} = 0$ 的形式，其中 $q = \\begin{pmatrix} v \\\\ \\sigma \\end{pmatrix}$ 且 $B = \\begin{pmatrix} 0  -\\rho^{-1} \\\\ -E  0 \\end{pmatrix}$。\n\n使用尺寸为 $h$ 的均匀网格和周期性边界条件对空间域进行离散化。使用多项式次数为 $k=0$（每个单元内为分片常数）的间断 Galerkin (DG) 方法。令 $I_{j}$ 表示第 $j$ 个单元，令 $q_{j}(t)$ 为 $q$ 在 $I_{j}$ 上的单元平均值。半离散 DG 格式为\n$$\nh\\, \\frac{d q_{j}}{dt} + \\widehat{f}\\!\\left(q_{j}^{-}, q_{j+1}^{+}\\right) - \\widehat{f}\\!\\left(q_{j-1}^{-}, q_{j}^{+}\\right) = 0,\n$$\n其中数值通量 $\\widehat{f}$ 近似了单元交界面处的物理通量 $f(q) = B\\, q$。考虑两种标准选择：\n- 中心通量：$\\widehat{f}_{\\mathrm{c}}(q^{-},q^{+}) = \\tfrac{1}{2}\\, B\\, (q^{-} + q^{+})$，\n- 迎风（精确黎曼）通量：$\\widehat{f}_{\\mathrm{u}}(q^{-},q^{+}) = B^{+} q^{-} + B^{-} q^{+}$，其中 $B = R \\Lambda R^{-1}$ 是特征分解，$\\Lambda = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}) = \\mathrm{diag}(c,-c)$ 且 $B^{\\pm} = R\\, \\Lambda^{\\pm} R^{-1}$，$\\Lambda^{+} = \\mathrm{diag}(c,0)$，$\\Lambda^{-} = \\mathrm{diag}(0,-c)$。\n\n假设一个 Bloch 波拟设 $q_{j}(t) = \\widehat{q}\\, \\exp\\!\\left( \\mathrm{i}\\, j\\, \\theta - \\mathrm{i}\\, \\omega\\, t \\right)$，其中无量纲波数为 $\\theta = \\kappa h$，$\\kappa$ 是物理波数。对每种通量选择，计算半离散数值色散关系 $\\omega(\\theta)$，然后将归一化数值相速度定义为\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{|\\Re(\\omega(\\theta))|}{c\\, \\kappa} = \\frac{h\\, |\\Re(\\omega(\\theta))|}{c\\, \\theta}.\n$$\n\n对 $\\frac{c_{\\mathrm{p, num}}}{c}$ 在 $\\theta = 0$ 附近进行泰勒展开，其形式为\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = 1 - \\alpha\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}),\n$$\n并确定以下情况的系数 $\\alpha$：\n- 中心通量，以及\n- 迎风通量。\n\n将你的最终答案以一个单行矩阵的形式给出，其中包含两个精确系数 $\\alpha$（中心通量在前，迎风通量在后）。无需四舍五入。", "solution": "我们从均匀一维弹性杆的一阶对称双曲系统开始：\n$$\nq_{t} + B\\, q_{x} = 0, \\quad q = \\begin{pmatrix} v \\\\ \\sigma \\end{pmatrix}, \\quad B = \\begin{pmatrix} 0  -\\rho^{-1} \\\\ -E  0 \\end{pmatrix}.\n$$\n$B$ 的特征值为 $\\lambda_{1} = c$ 和 $\\lambda_{2} = -c$，其中 $c = \\sqrt{E/\\rho}$。这可以通过计算 $\\det(\\lambda I - B) = \\lambda^{2} - E/\\rho = \\lambda^{2} - c^{2}$ 来验证，因此 $\\lambda = \\pm c$。\n\n我们将空间域离散化为尺寸为 $h$ 的单元组成的均匀网格 $\\{I_{j}\\}$。使用多项式次数为 $k=0$（每个单元内为分片常数）的间断 Galerkin 方法和周期性边界条件，在单元 $I_{j}$ 上对检验函数为常数 $1$ 的半离散平衡方程为\n$$\nh\\, \\frac{d q_{j}}{dt} + \\widehat{f}\\!\\left(q_{j}^{-}, q_{j+1}^{+}\\right) - \\widehat{f}\\!\\left(q_{j-1}^{-}, q_{j}^{+}\\right) = 0,\n$$\n其中 $\\widehat{f}$ 是在交界面 $x_{j \\pm 1/2}$ 处近似物理通量 $f(q) = B q$ 的数值通量，上标 $-$ 和 $+$ 分别表示从左侧和右侧的迹。对于 $k=0$，$q_{j}^{-} = q_{j}^{+} = q_{j}$。\n\n我们采用 Bloch 波拟设：\n$$\nq_{j}(t) = \\widehat{q}\\, \\exp\\!\\left(\\mathrm{i}\\, j\\, \\theta - \\mathrm{i}\\, \\omega\\, t\\right), \\quad \\theta = \\kappa h,\n$$\n从而 $q_{j+1} = e^{\\mathrm{i}\\theta}\\, q_{j}$ 且 $q_{j-1} = e^{-\\mathrm{i}\\theta}\\, q_{j}$。将此拟设代入半离散格式，得到定义每种通量选择的数值色散关系 $\\omega(\\theta)$ 的代数特征问题。\n\n中心通量。对于中心通量，\n$$\n\\widehat{f}_{\\mathrm{c}}(q_{j}, q_{j+1}) = \\tfrac{1}{2}\\, B\\, (q_{j} + q_{j+1}) = \\tfrac{1}{2}\\, B\\, (1 + e^{\\mathrm{i}\\theta})\\, q_{j},\n$$\n且\n$$\n\\widehat{f}_{\\mathrm{c}}(q_{j-1}, q_{j}) = \\tfrac{1}{2}\\, B\\, (q_{j-1} + q_{j}) = \\tfrac{1}{2}\\, B\\, (e^{-\\mathrm{i}\\theta} + 1)\\, q_{j}.\n$$\n因此，\n$$\nh\\, \\frac{d q_{j}}{dt} + \\tfrac{1}{2}\\, B\\, \\big[(1 + e^{\\mathrm{i}\\theta}) - (e^{-\\mathrm{i}\\theta} + 1)\\big]\\, q_{j} = 0\n\\;\\;\\Longrightarrow\\;\\;\n- \\mathrm{i}\\, \\omega\\, h\\, q_{j} + \\mathrm{i}\\, B\\, \\sin\\theta\\, q_{j} = 0.\n$$\n因此，离散空间算子的特征值是 $B$ 的特征值乘以 $\\sin\\theta$，数值色散关系为\n$$\n\\omega_{\\mathrm{c}}(\\theta) = \\pm \\frac{c}{h}\\, \\sin\\theta.\n$$\n归一化数值相速度为\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{|\\Re(\\omega_{\\mathrm{c}})|}{c\\, \\kappa} = \\frac{(c/h)\\, |\\sin\\theta|}{c\\, \\kappa} = \\frac{\\sin\\theta}{\\theta},\n$$\n其中我们使用了 $\\kappa = \\theta/h$ 并考虑 $0 \\le \\theta \\le \\pi$ 以使 $\\sin\\theta \\ge 0$。对小 $\\theta$ 进行展开，\n$$\n\\sin\\theta = \\theta - \\frac{\\theta^{3}}{3!} + \\frac{\\theta^{5}}{5!} - \\cdots,\n$$\n得到\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{\\sin\\theta}{\\theta} = 1 - \\frac{\\theta^{2}}{3!} + \\frac{\\theta^{4}}{5!} - \\cdots = 1 - \\frac{1}{6}\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}).\n$$\n因此，对于中心通量，$\\alpha_{\\mathrm{c}} = \\frac{1}{6}$。\n\n迎风通量。对于迎风（精确黎曼）通量，记 $B = R \\Lambda R^{-1}$，其中 $\\Lambda = \\mathrm{diag}(c,-c)$，并定义 $B^{\\pm} = R \\Lambda^{\\pm} R^{-1}$，其中 $\\Lambda^{+} = \\mathrm{diag}(c,0)$ 且 $\\Lambda^{-} = \\mathrm{diag}(0,-c)$。那么\n$$\n\\widehat{f}_{\\mathrm{u}}(q_{j}, q_{j+1}) = B^{+} q_{j} + B^{-} q_{j+1} = \\big(B^{+} + B^{-} e^{\\mathrm{i}\\theta}\\big)\\, q_{j},\n$$\n且\n$$\n\\widehat{f}_{\\mathrm{u}}(q_{j-1}, q_{j}) = B^{+} q_{j-1} + B^{-} q_{j} = \\big(B^{+} e^{-\\mathrm{i}\\theta} + B^{-}\\big)\\, q_{j}.\n$$\n因此，半离散方程变为\n$$\n- \\mathrm{i}\\, \\omega\\, h\\, q_{j} + \\Big[B^{+}\\big(1 - e^{-\\mathrm{i}\\theta}\\big) + B^{-}\\big(e^{\\mathrm{i}\\theta} - 1\\big)\\Big]\\, q_{j} = 0.\n$$\n在特征变量 $w = R^{-1} q$ 中进行对角化，从而上述方程简化为关于右行和左行特征场 $w_{+}$ 和 $w_{-}$ 的两个解耦的标量关系：\n- 对于速度为 $+c$ 的 $+$ 场：\n$$\n- \\mathrm{i}\\, \\omega\\, h + c \\big(1 - e^{-\\mathrm{i}\\theta}\\big) = 0\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{+}(\\theta) = \\mathrm{i}\\, \\frac{c}{h}\\, \\big(1 - e^{-\\mathrm{i}\\theta}\\big) = - \\frac{c}{h}\\, \\sin\\theta + \\mathrm{i}\\, \\frac{c}{h}\\, \\big(1 - \\cos\\theta\\big).\n$$\n- 对于速度为 $-c$ 的 $-$ 场：\n$$\n- \\mathrm{i}\\, \\omega\\, h - c \\big(e^{\\mathrm{i}\\theta} - 1\\big) = 0\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{-}(\\theta) = - \\mathrm{i}\\, \\frac{c}{h}\\, \\big(e^{\\mathrm{i}\\theta} - 1\\big) = \\frac{c}{h}\\, \\sin\\theta + \\mathrm{i}\\, \\frac{c}{h}\\, \\big(1 - \\cos\\theta\\big).\n$$\n两个分支具有相同的实部大小，\n$$\n|\\Re(\\omega_{\\mathrm{u}}(\\theta))| = \\frac{c}{h}\\, \\sin\\theta,\n$$\n并且具有非负虚部 $\\Im(\\omega_{\\mathrm{u}}(\\theta)) = \\frac{c}{h}\\, (1 - \\cos\\theta)$，这反映了数值耗散。因此，通过实部定义的归一化数值相速度，其大小与中心通量情况下的相同：\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{h\\, |\\Re(\\omega_{\\mathrm{u}}(\\theta))|}{c\\, \\theta} = \\frac{\\sin\\theta}{\\theta} = 1 - \\frac{1}{6}\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}).\n$$\n因此，对于迎风通量，$\\alpha_{\\mathrm{u}} = \\frac{1}{6}$。\n\n结论。对于具有均匀网格尺寸 $h$ 的一维弹性杆的分片常数（$k=0$）间断 Galerkin 离散化，中心数值通量和迎风数值通量在归一化相速度的小 $\\theta$ 展开中，都得到相同的领先阶色散误差系数，\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = 1 - \\alpha\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}), \\quad \\alpha_{\\mathrm{c}} = \\alpha_{\\mathrm{u}} = \\frac{1}{6}.\n$$\n迎风通量通过 $\\omega(\\theta)$ 的非零虚部额外引入了数值耗散，但这并不改变从实部导出的领先阶色散系数。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{6}  \\frac{1}{6} \\end{pmatrix}}$$", "id": "3518428"}, {"introduction": "虚拟单元法(VEM)和间断Galerkin(DG)方法的一大优势在于它们能灵活处理复杂几何形状和不连续性，例如岩体中的裂缝。本练习将引导您将VEM用于处理连续的体块区域，并结合DG思想设计一个界面单元来模拟裂缝。这是一个将理论付诸实践的典型例子，旨在解决计算地球力学中的一个常见且重要的问题。[@problem_id:3518433]", "problem": "考虑一个均质、各向同性岩石区域的二维标量反平面剪切模型，其中平面外位移场表示为 $u$。在没有裂缝的情况下，弹性势能由 Sobolev 空间 $H^1(\\Omega)$ 上的双线性形式表示，\n$$\na(u,v) = \\int_{\\Omega} \\mu \\, \\nabla u \\cdot \\nabla v \\, d\\Omega,\n$$\n其中 $\\mu$ 是一个正的剪切模量，为进行归一化，取作无量纲常数。裂缝被视为一个低维界面 $\\Gamma$，位移在该界面上可能不连续。一个内聚能对跨越 $\\Gamma$ 的跳跃 $[u]$ 进行惩罚，从而产生一个附加的双线性形式\n$$\nc(u,v) = \\int_{\\Gamma} \\kappa \\, [u] \\,[v] \\, ds,\n$$\n其中 $\\kappa \\ge 0$ 是一个无量纲的界面刚度参数，$[u]$ 表示 $u$ 从 $\\Gamma$ 左侧到右侧的跳跃。该设置与界面的间断 Galerkin (DG) 表示和体区域的虚单元法 (VEM) 表示相容。\n\n使用多边形单元上的最低阶虚单元法 (VEM) 来离散化体区域的双线性形式。对于每个具有 $N$ 个顶点 $\\{\\boldsymbol{x}_i\\}_{i=1}^N$（按逆时针顺序排列）和面积 $|E|$ 的多边形单元 $E$，定义其一致 VEM 刚度贡献\n$$\n\\boldsymbol{K}^{\\text{cons}}_E = |E| \\, \\boldsymbol{G}_E^\\top \\boldsymbol{G}_E,\n$$\n其中 $2 \\times N$ 矩阵 $\\boldsymbol{G}_E$ 的列为\n$$\n\\boldsymbol{g}_i = \\frac{1}{|E|} \\left( \\frac{1}{2} \\left( \\ell_{i-1} \\boldsymbol{n}_{i-1} + \\ell_i \\boldsymbol{n}_i \\right) \\right), \\quad i=1,\\dots,N,\n$$\n其中 $\\ell_i$ 是边 $i$ 的长度，$\\boldsymbol{n}_i$ 是其单位外法向量（索引模 $N$）。通过一个控制 VEM 空间非多项式分量的稳定项来增强该一致项。令 $\\boldsymbol{R}_E$ 为一个 $N \\times 2$ 矩阵，其第 $i$ 行为 $\\boldsymbol{x}_i - \\boldsymbol{x}_c$，其中 $\\boldsymbol{x}_c$ 是 $E$ 的形心，并令 $\\boldsymbol{1}$ 为全一的 $N$ 维向量。定义\n$$\n\\boldsymbol{c}_E = \\frac{1}{N} \\boldsymbol{R}_E^\\top \\boldsymbol{1}, \\quad \\boldsymbol{P}_E = \\frac{1}{N} \\boldsymbol{1}\\boldsymbol{1}^\\top + \\left( \\boldsymbol{R}_E - \\boldsymbol{1}\\boldsymbol{c}_E^\\top \\right) \\boldsymbol{G}_E.\n$$\n使用一个正的稳定化参数 $\\tau_E$，VEM 稳定项为\n$$\n\\boldsymbol{K}^{\\text{stab}}_E = \\tau_E \\, (\\boldsymbol{I} - \\boldsymbol{P}_E)^\\top (\\boldsymbol{I} - \\boldsymbol{P}_E),\n$$\n单元刚度为\n$$\n\\boldsymbol{K}_E = \\boldsymbol{K}^{\\text{cons}}_E + \\boldsymbol{K}^{\\text{stab}}_E.\n$$\n\n将裂缝表示为一条与两个相邻多边形单元公共边重合的折线 $\\Gamma$，并使用与界面上线性形函数一致的对称内部罚函数来离散化 $c(u,v)$。对于一个长度为 $L$、每侧有两个节点的单一平直界面段，其局部节点跳跃向量排序为 $[u_{L,1}, u_{L,2}, u_{R,1}, u_{R,2}]$，界面单元刚度为\n$$\n\\boldsymbol{K}_\\Gamma = \\kappa L \\begin{bmatrix}\n\\frac{1}{3}  \\frac{1}{6}  -\\frac{1}{3}  -\\frac{1}{6} \\\\\n\\frac{1}{6}  \\frac{1}{3}  -\\frac{1}{6}  -\\frac{1}{3} \\\\\n-\\frac{1}{3}  -\\frac{1}{6}  \\frac{1}{3}  \\frac{1}{6} \\\\\n-\\frac{1}{6}  -\\frac{1}{3}  \\frac{1}{6}  \\frac{1}{3}\n\\end{bmatrix}.\n$$\n\n构建一个单位正方形区域 $[0,1] \\times [0,1]$，该区域被划分为两个凸四边形：\n- 左单元 $E_L$，顶点按逆时针顺序为 $(0,0), (0.5,0), (0.5,1), (0,1)$。\n- 右单元 $E_R$，顶点按逆时针顺序为 $(0.5,0), (1,0), (1,1), (0.5,1)$。\n\n将位于 $x=0.5$ 的公共垂直边视为裂缝界面 $\\Gamma$。为允许位移在 $\\Gamma$ 上发生跳跃，在组装全局矩阵时，不要合并两个单元在界面处的自由度 (DOF)；而是应为每侧保留独立的自由度，并仅通过 $\\boldsymbol{K}_\\Gamma$ 将它们耦合起来。\n\n在 $x=0$ 和 $x=1$ 的外部边界顶点（即 $(0,0), (0,1), (1,0), (1,1)$）上施加齐次 Dirichlet 边界条件 $u=0$，方法是从全局系统中消去相应的自由度。所有量均为无量纲。\n\n实现一个程序，该程序：\n1. 使用给定的多边形几何形状，通过上述 VEM 公式为一阶 VEM 构建 $\\boldsymbol{K}_{E_L}$ 和 $\\boldsymbol{K}_{E_R}$。\n2. 在裂缝界面上使用独立的自由度组装全局刚度矩阵，并按照 $[u_{L, \\text{bottom}}, u_{L, \\text{top}}, u_{R, \\text{bottom}}, u_{R, \\text{top}}]$（对应于每侧的节点 $(0.5,0), (0.5,1)$）的顺序添加界面贡献 $\\boldsymbol{K}_\\Gamma$。\n3. 通过消去边界自由度来应用齐次 Dirichlet 边界条件。\n4. 对每个测试用例，计算所得对称正定矩阵的最大特征值。\n\n测试套件：\n- 用例 1：$\\kappa = 0.0$，两个单元的 $\\tau_E = 1.0$。\n- 用例 2：$\\kappa = 10^3$，两个单元的 $\\tau_E = 1.0$。\n- 用例 3：$\\kappa = 10^6$，两个单元的 $\\tau_E = 1.0$。\n- 用例 4：$\\kappa = 10^3$，两个单元的 $\\tau_E = 10.0$。\n\n您的程序应生成单行输出，其中包含四个用例的最大特征值，格式为用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。所有输出均以无单位的无量纲浮点数表示。", "solution": "经过仔细审查，问题陈述被认定是有效的。它描述了计算地质力学中一个适定的问题，该问题基于成熟的弹性力学和数值方法（虚单元法和间断 Galerkin 法）原理。所提供的公式和几何设置是一致且完整的，能够得出唯一解。根据归一化声明和提供的 VEM 刚度公式的暗示，剪切模量 $\\mu$ 取 $\\mu=1$。\n\n总体方法是首先使用指定的虚单元法 (VEM) 公式为两个矩形单元 $E_L$ 和 $E_R$ 构建局部刚度矩阵。同时，构建界面刚度矩阵 $\\boldsymbol{K}_\\Gamma$。然后将这些局部矩阵组装成一个全局刚度矩阵。最后，通过消除外部边界上的自由度 (DOF) 来施加齐次 Dirichlet 边界条件，并计算所得简化系统矩阵的最大特征值。\n\n**1. 离散化与自由度**\n\n区域 $\\Omega = [0,1] \\times [0,1]$ 被划分为两个矩形单元：\n- $E_L$：顶点 $\\{(0,0), (0.5,0), (0.5,1), (0,1)\\}$\n- $E_R$：顶点 $\\{(0.5,0), (1,0), (1,1), (0.5,1)\\}$\n\n由于存在裂缝，在界面 $\\Gamma$（$x=0.5$ 处）上的自由度是重复的。为所有 8 个自由度建立一个全局编号系统：\n1. $(0,0)$ 处的 $u_1$\n2. $(0,1)$ 处的 $u_2$\n3. 单元 $E_L$ 上 $(0.5,0)$ 处的 $u_3$ (裂缝左侧)\n4. 单元 $E_L$ 上 $(0.5,1)$ 处的 $u_4$ (裂缝左侧)\n5. 单元 $E_R$ 上 $(0.5,0)$ 处的 $u_5$ (裂缝右侧)\n6. 单元 $E_R$ 上 $(0.5,1)$ 处的 $u_6$ (裂缝右侧)\n7. $(1,0)$ 处的 $u_7$\n8. $(1,1)$ 处的 $u_8$\n\n单元 $E_L$（顶点 $(0,0), (0.5,0), (0.5,1), (0,1)$）的局部到全局自由度映射为 $\\{1, 2, 3, 4\\} \\to \\{1, 3, 4, 2\\}$。\n对于单元 $E_R$（顶点 $(0.5,0), (1,0), (1,1), (0.5,1)$），映射为 $\\{1, 2, 3, 4\\} \\to \\{5, 7, 8, 6\\}$。\n\n**2. VEM 单元刚度矩阵计算**\n\n我们为一个代表性单元 $E_L$ 计算刚度矩阵 $\\boldsymbol{K}_E$。$E_L$ 和 $E_R$ 两个单元是全等的矩形，因此它们的局部刚度矩阵是相同的。\n\n对于 $E_L$，顶点为 $\\boldsymbol{x}_1=(0,0), \\boldsymbol{x}_2=(0.5,0), \\boldsymbol{x}_3=(0.5,1), \\boldsymbol{x}_4=(0,1)$。\n顶点数为 $N=4$。面积为 $|E_L| = 0.5 \\times 1 = 0.5$。形心为 $\\boldsymbol{x}_c = (0.25, 0.5)$。\n\n边长和外法向量如下：\n- 边 1: $\\ell_1 = 0.5, \\boldsymbol{n}_1 = (0, -1)$\n- 边 2: $\\ell_2 = 1.0, \\boldsymbol{n}_2 = (1, 0)$\n- 边 3: $\\ell_3 = 0.5, \\boldsymbol{n}_3 = (0, 1)$\n- 边 4: $\\ell_4 = 1.0, \\boldsymbol{n}_4 = (-1, 0)$\n\n矩阵 $\\boldsymbol{G}_E$ 的列为 $\\boldsymbol{g}_i = \\frac{1}{2|E|} (\\ell_{i-1} \\boldsymbol{n}_{i-1} + \\ell_i \\boldsymbol{n}_i)$。由于 $|E_L| = 0.5$，前置因子 $\\frac{1}{2|E_L|}$ 为 $1$。\n- $\\boldsymbol{g}_1 = \\ell_4\\boldsymbol{n}_4 + \\ell_1\\boldsymbol{n}_1 = 1(-1,0) + 0.5(0,-1) = (-1, -0.5)$\n- $\\boldsymbol{g}_2 = \\ell_1\\boldsymbol{n}_1 + \\ell_2\\boldsymbol{n}_2 = 0.5(0,-1) + 1(1,0) = (1, -0.5)$\n- $\\boldsymbol{g}_3 = \\ell_2\\boldsymbol{n}_2 + \\ell_3\\boldsymbol{n}_3 = 1(1,0) + 0.5(0,1) = (1, 0.5)$\n- $\\boldsymbol{g}_4 = \\ell_3\\boldsymbol{n}_3 + \\ell_4\\boldsymbol{n}_4 = 0.5(0,1) + 1(-1,0) = (-1, 0.5)$\n所以，$\\boldsymbol{G}_{E_L} = \\begin{pmatrix} -1  1  1  -1 \\\\ -0.5  -0.5  0.5  0.5 \\end{pmatrix}$。\n\n一致性刚度矩阵为 $\\boldsymbol{K}^{\\text{cons}}_E = |E| \\boldsymbol{G}_E^\\top \\boldsymbol{G}_E$：\n$$ \\boldsymbol{K}^{\\text{cons}}_{E_L} = 0.5 \\begin{pmatrix} -1  -0.5 \\\\ 1  -0.5 \\\\ 1  0.5 \\\\ -1  0.5 \\end{pmatrix} \\begin{pmatrix} -1  1  1  -1 \\\\ -0.5  -0.5  0.5  0.5 \\end{pmatrix} = \\begin{pmatrix} 0.625  -0.375  -0.625  0.375 \\\\ -0.375  0.625  0.375  -0.625 \\\\ -0.625  0.375  0.625  -0.375 \\\\ 0.375  -0.625  -0.375  0.625 \\end{pmatrix} $$\n\n为进行稳定化，我们计算投影矩阵 $\\boldsymbol{P}_E$。\n中心化坐标矩阵为 $\\boldsymbol{R}_{E_L} = \\begin{pmatrix} -0.25  -0.5 \\\\ 0.25  -0.5 \\\\ 0.25  0.5 \\\\ -0.25  0.5 \\end{pmatrix}$。\n对于中心对称多边形，$\\boldsymbol{c}_E = \\frac{1}{N}\\boldsymbol{R}_E^\\top\\boldsymbol{1} = \\boldsymbol{0}$。\n因此，$\\boldsymbol{P}_E = \\frac{1}{N} \\boldsymbol{1}\\boldsymbol{1}^\\top + \\boldsymbol{R}_E \\boldsymbol{G}_E$。\n$$ \\boldsymbol{P}_{E_L} = \\frac{1}{4}\\begin{pmatrix} 1  1  1  1 \\\\ 1  1  1  1 \\\\ 1  1  1  1 \\\\ 1  1  1  1 \\end{pmatrix} + \\begin{pmatrix} 0.5  0  -0.5  0 \\\\ 0  0.5  0  -0.5 \\\\ -0.5  0  0.5  0 \\\\ 0  -0.5  0  0.5 \\end{pmatrix} = \\begin{pmatrix} 0.75  0.25  -0.25  0.25 \\\\ 0.25  0.75  0.25  -0.25 \\\\ -0.25  0.25  0.75  0.25 \\\\ 0.25  -0.25  0.25  0.75 \\end{pmatrix} $$\n稳定化矩阵是 $\\boldsymbol{K}^{\\text{stab}}_E = \\tau_E (\\boldsymbol{I} - \\boldsymbol{P}_E)^\\top (\\boldsymbol{I} - \\boldsymbol{P}_E)$。\n$$ \\boldsymbol{I} - \\boldsymbol{P}_{E_L} = \\begin{pmatrix} 0.25  -0.25  0.25  -0.25 \\\\ -0.25  0.25  -0.25  0.25 \\\\ 0.25  -0.25  0.25  -0.25 \\\\ -0.25  0.25  -0.25  0.25 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\end{pmatrix} \\begin{pmatrix} 0.25  -0.25  0.25  -0.25 \\end{pmatrix} $$\n$$ \\boldsymbol{K}^{\\text{stab}}_{E_L} = \\tau_E \\begin{pmatrix} 0.25 \\\\ -0.25 \\\\ 0.25 \\\\ -0.25 \\end{pmatrix} (4) \\begin{pmatrix} 0.25  -0.25  0.25  -0.25 \\end{pmatrix} = \\tau_E \\begin{pmatrix} 0.25  -0.25  0.25  -0.25 \\\\ -0.25  0.25  -0.25  0.25 \\\\ 0.25  -0.25  0.25  -0.25 \\\\ -0.25  0.25  -0.25  0.25 \\end{pmatrix} $$\n总的单元刚度为 $\\boldsymbol{K}_E = \\boldsymbol{K}^{\\text{cons}}_E + \\boldsymbol{K}^{\\text{stab}}_E$。\n\n**3. 界面刚度矩阵**\n\n裂缝 $\\Gamma$ 的长度为 $L=1$。涉及的自由度为 $\\{u_3, u_4, u_5, u_6\\}$，对应于 $\\{u_{L, \\text{bottom}}, u_{L, \\text{top}}, u_{R, \\text{bottom}}, u_{R, \\text{top}}\\}$。界面刚度矩阵为：\n$$ \\boldsymbol{K}_\\Gamma = \\kappa (1) \\begin{bmatrix}\n\\frac{1}{3}  \\frac{1}{6}  -\\frac{1}{3}  -\\frac{1}{6} \\\\\n\\frac{1}{6}  \\frac{1}{3}  -\\frac{1}{6}  -\\frac{1}{3} \\\\\n-\\frac{1}{3}  -\\frac{1}{6}  \\frac{1}{3}  \\frac{1}{6} \\\\\n-\\frac{1}{6}  -\\frac{1}{3}  \\frac{1}{6}  \\frac{1}{3}\n\\end{bmatrix} $$\n\n**4. 组装与边界条件**\n\n组装全局 $8 \\times 8$ 刚度矩阵。在自由度 $\\{1, 2, 7, 8\\}$ 上施加的齐次 Dirichlet 边界条件意味着这些行和列将被消去。问题简化为求解对应于自由度 $\\{3, 4, 5, 6\\}$ 的 $4 \\times 4$ 子矩阵的特征值问题。该矩阵 $\\boldsymbol{K}_{final}$ 是通过对 $E_L$、$E_R$ 和 $\\Gamma$ 对这些自由度的贡献求和得到的。\n\n- 来自 $E_L$ 影响自由度 $\\{3,4\\}$ 的子矩阵对应于 $\\boldsymbol{K}_{E_L}$ 的局部节点 $\\{2,3\\}$。\n- 来自 $E_R$ 影响自由度 $\\{5,6\\}$ 的子矩阵对应于 $\\boldsymbol{K}_{E_R}$ 的局部节点 $\\{1,4\\}$。\n- $\\boldsymbol{K}_\\Gamma$ 耦合所有四个自由度。\n\n设 $\\boldsymbol{A}$ 为一个体单元对界面自由度的 $2 \\times 2$ 贡献。由于对称性，这个矩阵对两个单元是相同的。\n对于 $E_L$，我们提取局部节点 {2,3} 的子矩阵。对于 $E_R$，提取局部节点 {1,4} 的子矩阵。在这两种情况下，得到的矩阵都是：\n$$ \\boldsymbol{A} = \\begin{pmatrix} 0.625+0.25\\tau_E  0.375-0.25\\tau_E \\\\ 0.375-0.25\\tau_E  0.625+0.25\\tau_E \\end{pmatrix} $$\n设 $\\boldsymbol{B} = \\kappa \\begin{pmatrix} 1/3  1/6 \\\\ 1/6  1/3 \\end{pmatrix}$。那么 $\\boldsymbol{K}_\\Gamma = \\begin{pmatrix} \\boldsymbol{B}  -\\boldsymbol{B} \\\\ -\\boldsymbol{B}  \\boldsymbol{B} \\end{pmatrix}$。\n最终的 $4 \\times 4$ 矩阵是 $\\boldsymbol{K}_{final} = \\begin{pmatrix} \\boldsymbol{A}  \\boldsymbol{0} \\\\ \\boldsymbol{0}  \\boldsymbol{A} \\end{pmatrix} + \\boldsymbol{K}_\\Gamma = \\begin{pmatrix} \\boldsymbol{A}+\\boldsymbol{B}  -\\boldsymbol{B} \\\\ -\\boldsymbol{B}  \\boldsymbol{A}+\\boldsymbol{B} \\end{pmatrix}$。\n\n**5. 特征值分析**\n\n这个块循环矩阵的特征值是 $(\\boldsymbol{A}+\\boldsymbol{B}) - \\boldsymbol{B} = \\boldsymbol{A}$ 和 $(\\boldsymbol{A}+\\boldsymbol{B}) + \\boldsymbol{B} = \\boldsymbol{A}+2\\boldsymbol{B}$ 的特征值。\n\n$\\boldsymbol{A}$ 的特征值：形式为 $\\begin{pmatrix} a  b \\\\ b  a \\end{pmatrix}$ 的 $2 \\times 2$ 矩阵的特征值为 $a+b$ 和 $a-b$。\n- $\\lambda_1(\\boldsymbol{A}) = (0.625+0.25\\tau_E) + (0.375-0.25\\tau_E) = 1.0$\n- $\\lambda_2(\\boldsymbol{A}) = (0.625+0.25\\tau_E) - (0.375-0.25\\tau_E) = 0.25 + 0.5\\tau_E$\n\n$\\boldsymbol{A}+2\\boldsymbol{B}$ 的特征值：该矩阵具有相同的结构。\n- $\\lambda_1(\\boldsymbol{A}+2\\boldsymbol{B}) = (a+2\\kappa/3) + (b+2\\kappa/6) = (a+b) + 2\\kappa(1/3+1/6) = 1.0 + \\kappa$\n- $\\lambda_2(\\boldsymbol{A}+2\\boldsymbol{B}) = (a+2\\kappa/3) - (b+2\\kappa/6) = (a-b) + 2\\kappa(1/3-1/6) = 0.25 + 0.5\\tau_E + \\kappa/3$\n\n$\\boldsymbol{K}_{final}$ 的四个特征值是 $\\{1.0, \\quad 0.25+0.5\\tau_E, \\quad 1.0+\\kappa, \\quad 0.25+0.5\\tau_E+\\kappa/3 \\}$。\n最大特征值为 $\\lambda_{\\max} = \\max(1.0+\\kappa, 0.25+0.5\\tau_E+\\kappa/3)$。\n\n**6. 测试用例计算**\n\n- **用例 1:** $\\kappa = 0.0$, $\\tau_E = 1.0$。\n$\\lambda_{\\max} = \\max(1.0+0, 0.25+0.5(1)+0) = \\max(1.0, 0.75) = 1.0$。\n\n- **用例 2:** $\\kappa = 10^3$, $\\tau_E = 1.0$。\n$\\lambda_{\\max} = \\max(1.0+1000, 0.25+0.5(1)+1000/3) = \\max(1001, 0.75+333.33...) = 1001.0$。\n\n- **用例 3:** $\\kappa = 10^6$, $\\tau_E = 1.0$。\n$\\lambda_{\\max} = \\max(1.0+10^6, 0.25+0.5(1)+10^6/3) = \\max(1000001, 0.75+333333.33...) = 1000001.0$。\n\n- **用例 4:** $\\kappa = 10^3$, $\\tau_E = 10.0$。\n$\\lambda_{\\max} = \\max(1.0+1000, 0.25+0.5(10)+1000/3) = \\max(1001, 5.25+333.33...) = 1001.0$。\n\n这些解析结果将由数值实现来验证。", "answer": "```python\nimport numpy as np\n\ndef compute_polygon_properties(vertices):\n    \"\"\"Computes area and centroid of a polygon.\"\"\"\n    N = len(vertices)\n    x = vertices[:, 0]\n    y = vertices[:, 1]\n    \n    # Shoelace formula for area\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    \n    # Formula for centroid\n    # This calculation is for the general polygon, robust for this problem.\n    sum_val_x = 0\n    sum_val_y = 0\n    for i in range(N):\n        xi, yi = vertices[i]\n        xi1, yi1 = vertices[(i + 1) % N]\n        cross_prod = xi * yi1 - xi1 * yi\n        sum_val_x += (xi + xi1) * cross_prod\n        sum_val_y += (yi + yi1) * cross_prod\n    \n    centroid_x = sum_val_x / (6 * area)\n    centroid_y = sum_val_y / (6 * area)\n    \n    return area, np.array([centroid_x, centroid_y])\n\ndef compute_vem_stiffness(vertices, tau):\n    \"\"\"\n    Computes the lowest-order VEM stiffness matrix for a polygonal element.\n    \"\"\"\n    N = len(vertices)\n    area, centroid = compute_polygon_properties(vertices)\n\n    # Compute edge lengths and normals\n    edges = np.roll(vertices, -1, axis=0) - vertices\n    edge_lengths = np.linalg.norm(edges, axis=1)\n    normals = np.array([edges[:, 1], -edges[:, 0]]).T / edge_lengths[:, np.newaxis]\n\n    # Compute G matrix\n    G = np.zeros((2, N))\n    for i in range(N):\n        i_prev = (i - 1 + N) % N\n        term1 = edge_lengths[i_prev] * normals[i_prev, :]\n        term2 = edge_lengths[i] * normals[i, :]\n        G[:, i] = (1.0 / (2.0 * area)) * (term1 + term2)\n\n    # Consistent stiffness matrix\n    K_cons = area * (G.T @ G)\n    \n    # Stabilization stiffness matrix\n    ones_N = np.ones((N, 1))\n    R = vertices - centroid\n    c = (1.0 / N) * (R.T @ ones_N)\n    \n    # Projector P\n    P = (1.0 / N) * (ones_N @ ones_N.T) + (R - ones_N @ c.T) @ G\n    \n    # Stabilization matrix\n    I = np.identity(N)\n    K_stab = tau * ((I - P).T @ (I - P))\n    \n    return K_cons + K_stab\n\ndef compute_interface_stiffness(kappa, L):\n    \"\"\"\n    Computes the symmetric interior penalty interface stiffness matrix.\n    \"\"\"\n    M_local = L * np.array([\n        [1/3, 1/6],\n        [1/6, 1/3]\n    ])\n    K_gamma = kappa * np.block([\n        [ M_local, -M_local],\n        [-M_local,  M_local]\n    ])\n    return K_gamma\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (0.0, 1.0),\n        (10**3, 1.0),\n        (10**6, 1.0),\n        (10**3, 10.0),\n    ]\n\n    # Define geometry and DOF mappings\n    vertices_L = np.array([[0.0, 0.0], [0.5, 0.0], [0.5, 1.0], [0.0, 1.0]])\n    vertices_R = np.array([[0.5, 0.0], [1.0, 0.0], [1.0, 1.0], [0.5, 1.0]])\n    \n    # 0-based indices for assembly\n    # Global DOFs: [0,1,2,3,4,5,6,7] for nodes (0,0), (0,1), (0.5,0)L, (0.5,1)L, (0.5,0)R, (0.5,1)R, (1,0), (1,1)\n    map_L = [0, 2, 3, 1] \n    map_R = [4, 6, 7, 5]\n    \n    # Fracture DOFs: [u_L_bottom, u_L_top, u_R_bottom, u_R_top]\n    # Mapped to global indices [2, 3, 4, 5]\n    map_gamma = [2, 3, 4, 5]\n    \n    # Boundary DOFs to eliminate: (0,0), (0,1), (1,0), (1,1)\n    # Corresponding global indices: [0, 1, 6, 7]\n    free_dofs = [2, 3, 4, 5]\n    \n    fracture_length = 1.0\n\n    results = []\n    for kappa, tau in test_cases:\n        \n        # 1. Compute element stiffness matrices\n        K_L = compute_vem_stiffness(vertices_L, tau)\n        K_R = compute_vem_stiffness(vertices_R, tau)\n\n        # 2. Assemble global stiffness matrix (bulk part)\n        K_global = np.zeros((8, 8))\n        \n        # Assemble K_L\n        for i in range(4):\n            for j in range(4):\n                K_global[map_L[i], map_L[j]] += K_L[i, j]\n        \n        # Assemble K_R\n        for i in range(4):\n            for j in range(4):\n                K_global[map_R[i], map_R[j]] += K_R[i, j]\n\n        # 3. Add interface contribution\n        K_gamma = compute_interface_stiffness(kappa, fracture_length)\n        for i in range(4):\n            for j in range(4):\n                K_global[map_gamma[i], map_gamma[j]] += K_gamma[i, j]\n                \n        # 4. Apply homogeneous Dirichlet BCs by extraction\n        K_final = K_global[np.ix_(free_dofs, free_dofs)]\n        \n        # 5. Compute the largest eigenvalue\n        # eigvalsh is for symmetric matrices and is more efficient\n        eigenvalues = np.linalg.eigvalsh(K_final)\n        largest_eigenvalue = np.max(eigenvalues)\n        results.append(largest_eigenvalue)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3518433"}, {"introduction": "为了将DG和VEM方法应用于大规模实际问题，高效的并行计算实现至关重要。本练习聚焦于一种核心并行化技术：静态凝聚（或称局部求解），它将单元内部的自由度消除，从而在网格骨架（即单元交界面）上形成一个规模更小、更适合并行组装的方程组。您将从基本控制方程出发，推导局部舒尔补系统，并模拟其并行组装过程，以理解该方法的可扩展性基础。[@problem_id:3518426]", "problem": "开发一个完整的、可运行的程序，该程序实现一种基于面的并行组装策略，适用于非结构化多边形网格上的非连续伽辽金 (DG) 和虚拟单元法 (VEM) 离散化，应用于计算地球力学中标量扩散问题。从基本守恒定律和本构关系出发，推导单元局部消元（局部求解）以在面迹线上产生舒尔补 (Schur complement)，并设计数据结构以支持跨分区的基于面的通信。目标问题是表示多孔介质中达西流的稳态扩散模型，表述如下：在多边形域中，求解标量势 $u$，使得 $-\\nabla \\cdot (\\kappa \\nabla u) = 0$ 成立，并在边界上给定狄利克雷 (Dirichlet) 边界数据。所有量均为无量纲，因此报告无量纲值。\n\n您必须实现：\n- 一种基于面的混合组装方法，其中未知量是内部面上的迹（每个面一个标量）。边界面的狄利克雷值是给定的，并在局部进行消元。\n- 对于每个多边形单元 $E$，执行局部静态凝聚，消去单元内部未知量，以面迹线表示，从而得到一个单元局部的舒尔补，该舒尔补贡献于全局面系统。使用与一阶虚拟单元或模拟离散化相一致的传输率模型：对于一个导率为 $\\kappa_E$、面集合为 $\\mathcal{F}(E)$、面长为 $\\lvert f \\rvert$、单元质心到面 $f$ 的距离为 $d_{E,f}$ 的单元 $E$，面到单元的通量贡献使用系数 $T_{E,f} = \\kappa_E \\, \\lvert f \\rvert / d_{E,f}$。\n- 一次并行组装模拟：将单元集合划分到多个分区中，每个分区仅使用局部单元和面信息独立组装其贡献，然后将这些贡献求和以构成全局系统。通信是基于面的：不同分区中的单元共享的内部面需要对其贡献进行求和。\n- 一次串行组装，在单次处理中组装相同的全局系统。\n- 对串行和并行组装得到的全局线性系统进行求解，以获得内部面迹线上的未知量，并对结果进行比较。\n\n设计能明确编码以下内容的数据结构：\n- 一个全局面列表，其中包含相邻单元索引的元组 $(c_L, c_R)$（其中 $-1$ 表示边界）、面长 $\\lvert f \\rvert$、一个布尔标志（如果 $c_R = -1$ 则指示狄利克雷边界条件）以及当边界条件存在时相关的狄利克雷值 $g$。\n- 一个全局单元列表，其中包含导率 $\\kappa_E$、关联的面索引列表以及到每个关联面的相应距离列表 $d_{E,f}$。\n\n推导约束：\n- 从质量守恒和具有导率 $\\kappa$ 的多孔介质中标量流动的达西定律出发，即 $\\boldsymbol{q} = -\\kappa \\nabla u$ 和 $\\nabla \\cdot \\boldsymbol{q} = 0$。\n- 使用最低阶虚拟单元或模拟有限差分原理来定义每个单元的传输率 $T_{E,f}$，使其与跨面的局部通量平衡相一致。\n- 通过消去单元平均未知量 $u_E$，推导面迹线上的单元局部凝聚关系（舒尔补），不得使用任何非从这些原理推导出的快捷公式或预推导表达式。\n- 确保在给定数据下，最终组装的全局系统是对称正定的。\n\n测试套件：\n实现您的程序以运行以下三个测试用例。在所有用例中，量均为无量纲。每个测试用例都如上所述定义了面和单元。\n\n- 测试用例 A (正常路径，多单元内部通信)：边长为 $0.5$ 的四个相等方形单元离散化的单位正方形。外边界上的面为狄利克雷边界，其值为：左边界 $g = 1.0$，右边界 $g = 0.0$，下边界 $g = 0.0$，上边界 $g = 0.0$。内部面没有狄利克雷数据。所有单元的导率 $\\kappa_E = 1.0$。对每个单元，其到各个面的距离均为 $0.25$，所有面长均为 $0.5$。面和单元如下：\n  - 面: \n    - 面 $f_0$: $(0, -1)$，长度 $0.5$，狄利克雷值 $1.0$ \n    - 面 $f_1$: $(0, -1)$，长度 $0.5$，狄利克雷值 $0.0$ \n    - 面 $f_2$: $(0, 1)$，长度 $0.5$，内部面 \n    - 面 $f_3$: $(0, 2)$，长度 $0.5$，内部面 \n    - 面 $f_4$: $(1, -1)$，长度 $0.5$，狄利克雷值 $0.0$ \n    - 面 $f_5$: $(1, -1)$，长度 $0.5$，狄利克雷值 $0.0$ \n    - 面 $f_6$: $(1, 3)$，长度 $0.5$，内部面 \n    - 面 $f_7$: $(2, -1)$，长度 $0.5$，狄利克雷值 $1.0$ \n    - 面 $f_8$: $(2, 3)$，长度 $0.5$，内部面 \n    - 面 $f_9$: $(2, -1)$，长度 $0.5$，狄利克雷值 $0.0$ \n    - 面 $f_{10}$: $(3, -1)$，长度 $0.5$，狄利克雷值 $0.0$ \n    - 面 $f_{11}$: $(3, -1)$，长度 $0.5$，狄利克雷值 $0.0$\n  - 单元:\n    - 单元 $0$: $\\kappa=1.0$，面 $[0, 1, 2, 3]$，距离 $[0.25, 0.25, 0.25, 0.25]$\n    - 单元 $1$: $\\kappa=1.0$，面 $[2, 4, 5, 6]$，距离 $[0.25, 0.25, 0.25, 0.25]$\n    - 单元 $2$: $\\kappa=1.0$，面 $[7, 3, 8, 9]$，距离 $[0.25, 0.25, 0.25, 0.25]$\n    - 单元 $3$: $\\kappa=1.0$，面 $[8, 6, 11, 10]$，距离 $[0.25, 0.25, 0.25, 0.25]$\n  - 为并行组装将单元划分为两个分区：分区 0 包含单元 $[0, 3]$；分区 1 包含单元 $[1, 2]$。\n\n- 测试用例 B (边界主导的边界情况)：边长为 $1.0$ 的单个方形单元；所有四个面均为狄利克雷边界，其值为：左 $1.0$，右 $0.0$，下 $0.0$，上 $0.0$。导率 $\\kappa = 1.0$。面长为 $1.0$，到面的距离为 $0.5$。没有内部面，因此全局系统中没有未知量。分区：单个分区，包含唯一的单元。\n\n- 测试用例 C (带有扭曲几何形状和导率对比的病态条件边界情况)：两个相邻单元共享一个短的内部面。单元 $0$ 的导率 $\\kappa = 2.5$，其面的长度为 $[1.0, 1.0, 0.2, 1.0]$，距离为 $[0.5, 0.5, 0.05, 0.5]$，其中第三个面是短的内部面。其三个边界面的狄利克雷值按边界面的相同顺序为 $[1.0, 0.0, 0.0]$。单元 $1$ 的导率 $\\kappa = 0.5$，其面的长度为 $[0.2, 1.5, 1.0, 1.0]$，距离为 $[0.02, 0.7, 0.6, 0.8]$，其中第一个面是共享的短内部面，其余面的狄利克雷值为 $[0.0, 0.0, 0.0]$。共享的内部面是唯一的未知量。分区：两个分区，每个分区包含一个单元。\n\n输出要求：\n- 对于每个测试用例，计算三个量：\n  1. 串行组装的全局矩阵与并行组装的全局矩阵之差的弗罗贝尼乌斯范数 (Frobenius norm)（一个非负浮点数）。\n  2. 内部面迹线上对应的串行解和并行解之差的无穷范数（一个非负浮点数；如果没有未知量，则使用 $0.0$）。\n  3. 针对内部面未知量组装的全局矩阵的 2-范数条件数（一个正浮点数；如果没有未知量，则使用 $1.0$）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序为 $[\\text{A\\_mat\\_diff}, \\text{A\\_sol\\_diff}, \\text{A\\_cond}, \\text{B\\_mat\\_diff}, \\text{B\\_sol\\_diff}, \\text{B\\_cond}, \\text{C\\_mat\\_diff}, \\text{C\\_sol\\_diff}, \\text{C\\_cond}]$。\n\n所有计算都是无量纲的。角度和百分比不适用。不需要用户输入；程序必须能够“按原样”运行。", "solution": "用户要求开发一个程序，用于模拟标量扩散问题的基于面的并行组装，该模拟基于类似于最低阶虚拟单元法 (VEM) 或模拟有限差分 (MFD) 方法的离散化。任务的核心是推导并实现单元局部静态凝聚（舒尔补），并将这些局部贡献正确地组装成一个全局方程系统，用于求解网格内部面上的未知势值。\n\n### 从第一性原理推导\n\n控制物理是在域 $\\Omega$ 内的稳态扩散方程，代表达西流：\n$$-\\nabla \\cdot \\boldsymbol{q} = 0 \\quad \\text{in } \\Omega$$\n其中通量 $\\boldsymbol{q}$ 由达西定律给出：\n$$\\boldsymbol{q} = -\\kappa \\nabla u$$\n此处，$u$ 是标量势，$\\kappa$ 是材料导率。\n\n我们首先将守恒定律应用于单个多边形单元（或元素）$E$。对控制方程在 $E$ 上积分并应用散度定理，得到通量守恒的积分表述：\n$$-\\int_E \\nabla \\cdot \\boldsymbol{q} \\, dV = 0 \\implies \\int_{\\partial E} \\boldsymbol{q} \\cdot \\boldsymbol{n}_E \\, dS = 0$$\n其中 $\\partial E$ 是单元的边界，$\\boldsymbol{n}_E$ 是 $\\partial E$ 上的向外单位法向量场。\n\n边界 $\\partial E$ 由一组平面组成，记为 $\\mathcal{F}(E)$。因此，积分可以写成在这些面上的总和：\n$$\\sum_{f \\in \\mathcal{F}(E)} \\int_f \\boldsymbol{q} \\cdot \\boldsymbol{n}_{E,f} \\, dS = 0$$\n其中 $\\boldsymbol{n}_{E,f}$ 是单元 $E$ 在面 $f$ 上的向外法线。令 $Q_{E,f}^{\\text{out}} = \\int_f \\boldsymbol{q} \\cdot \\boldsymbol{n}_{E,f} \\, dS$ 为通过面 $f$ 离开单元 $E$ 的总通量。单元 $E$ 的离散守恒定律是：\n$$\\sum_{f \\in \\mathcal{F}(E)} Q_{E,f}^{\\text{out}} = 0$$\n\n为了继续，我们需要对通量 $Q_{E,f}^{\\text{out}}$ 进行离散近似。问题指定了一个最低阶近似方案，其中每个单元 $E$ 有一个未知势 $u_E$（单元平均势），每个面 $f$ 有一个未知势 $u_f$（面平均势）。通过面 $f$ 离开单元 $E$ 的通量近似为与单元中心和面之间的势差成正比：\n$$Q_{E,f}^{\\text{out}} \\approx T_{E,f} (u_E - u_f)$$\n系数 $T_{E,f}$ 是传输率，给定为 $T_{E,f} = \\kappa_E |f| / d_{E,f}$，其中 $\\kappa_E$ 是单元的导率， $|f|$ 是面 $f$ 的长度， $d_{E,f}$ 是从单元质心到面的法向距离。\n\n将此通量近似代入单元 $E$ 的离散守恒定律中：\n$$\\sum_{f \\in \\mathcal{F}(E)} T_{E,f} (u_E - u_f) = 0$$\n该方程允许我们执行所要求的静态凝聚。我们通过用面势 $\\{u_f\\}_{f \\in \\mathcal{F}(E)}$ 表示单元内部未知量 $u_E$ 来消去它：\n$$u_E \\sum_{f \\in \\mathcal{F}(E)} T_{E,f} = \\sum_{f \\in \\mathcal{F}(E)} T_{E,f} u_f \\implies u_E = \\frac{\\sum_{f \\in \\mathcal{F}(E)} T_{E,f} u_f}{\\sum_{g \\in \\mathcal{F}(E)} T_{E,g}}$$\n令 $T_E^{\\text{tot}} = \\sum_{g \\in \\mathcal{F}(E)} T_{E,g}$。那么 $u_E = \\frac{1}{T_E^{\\text{tot}}} \\sum_{f \\in \\mathcal{F}(E)} T_{E,f} u_f$。\n\n现在，我们将 $u_E$ 的这个表达式代回到通量近似中，以获得单元 $E$ 的出流通量与其面上的势之间的直接关系。对于一个面 $f_i \\in \\mathcal{F}(E)$：\n$$Q_{E,f_i}^{\\text{out}} = T_{E,f_i} (u_E - u_{f_i}) = T_{E,f_i} \\left( \\frac{1}{T_E^{\\text{tot}}} \\sum_{f_j \\in \\mathcal{F}(E)} T_{E,f_j} u_{f_j} - u_{f_i} \\right)$$\n$$Q_{E,f_i}^{\\text{out}} = \\sum_{f_j \\in \\mathcal{F}(E)} \\left( \\frac{T_{E,f_i} T_{E,f_j}}{T_E^{\\text{tot}}} - T_{E,f_i}\\delta_{ij} \\right) u_{f_j}$$\n其中 $\\delta_{ij}$ 是克罗内克 (Kronecker) delta。这定义了单元 $E$ 的狄利克雷-诺伊曼 (Dirichlet-to-Neumann) 映射，它将面势（狄利克雷数据）与面通量（诺伊曼数据）联系起来。这由一个矩阵 $K_E$ 表示，其项为 $(K_E)_{ij} = \\frac{T_{E,f_i} T_{E,f_j}}{T_E^{\\text{tot}}} - T_{E,f_i}\\delta_{ij}$。出流通量向量 $\\boldsymbol{Q}_E^{\\text{out}}$ 通过 $\\boldsymbol{Q}_E^{\\text{out}} = K_E \\boldsymbol{u}_E^{\\text{faces}}$ 与面势向量 $\\boldsymbol{u}_E^{\\text{faces}}$ 相关。这个矩阵 $K_E$ 是局部舒尔补。它是对称且半负定的。\n\n### 全局组装\n\n全局方程系统是通过在所有内部面上强制通量连续性来形成的。对于由两个单元 $E_L$ 和 $E_R$ 共享的内部面 $f_k$，离开 $E_L$ 的通量必须与离开 $E_R$ 的通量大小相等、方向相反。即，$Q_{E_L, f_k}^{\\text{out}} = -Q_{E_R, f_k}^{\\text{out}}$，这给出了组装条件：\n$$Q_{E_L, f_k}^{\\text{out}} + Q_{E_R, f_k}^{\\text{out}} = 0$$\n一般来说，对于任何内部面 $f_k$，来自所有相邻单元的出流通量之和必须为零：$\\sum_{E \\sim f_k} Q_{E, f_k}^{\\text{out}} = 0$。\n\n代入舒尔补关系：\n$$\\sum_{E \\sim f_k} \\left( \\sum_{f_j \\in \\mathcal{F}(E)} (K_E)_{kj} u_{f_j} \\right) = 0$$\n这个表达式导致从局部贡献组装全局矩阵。然而，由于每个 $K_E$ 都是半负定的，得到的全局矩阵也将是半负定的，而这个问题的标准刚度矩阵是正定的。为了解决这个问题，我们定义一个局部刚度贡献矩阵 $S_E = -K_E$。$S_E$ 的项是：\n$$(S_E)_{ij} = T_{E,f_i}\\delta_{ij} - \\frac{T_{E,f_i} T_{E,f_j}}{T_E^{\\text{tot}}}$$\n这个矩阵 $S_E$ 是半正定的。我们的组装方程可以用 $S_E$ 重写：\n$$\\sum_{E \\sim f_k} \\left( -\\sum_{f_j \\in \\mathcal{F}(E)} (S_E)_{kj} u_{f_j} \\right) = 0 \\implies \\sum_{E \\sim f_k} \\left( \\sum_{f_j \\in \\mathcal{F}(E)} (S_E)_{kj} u_{f_j} \\right) = 0$$\n\n最终的全局线性系统 $A \\boldsymbol{u}_{\\text{int}} = \\boldsymbol{b}$ 是为未知内部面势向量 $\\boldsymbol{u}_{\\text{int}}$ 组装的，过程如下。全局刚度矩阵 $A$ 是通过对所有单元局部刚度矩阵 $S_E$ 的贡献求和来构造的：\n$$A_{kl} = \\sum_{\\text{cells } E} (S_E)_{kl}$$\n其中 $k$ 和 $l$ 是内部面的全局索引，而 $(S_E)_{kl}$ 是局部矩阵中对应于这对面的项（如果单元 $E$ 不同时包含这两个面，则为零）。\n\n狄利克雷边界条件被并入右侧向量 $\\boldsymbol{b}$。当一个面 $f_j$ 是边界​​面时，其势 $u_{f_j}$ 是一个已知值 $g_j$。来自求和的项 $(S_E)_{kj} u_{f_j} = (S_E)_{kj} g_j$ 被移到右侧。对于每个内部面 $f_k$ 的方程：\n$$\\sum_{f_l \\text{ interior}} A_{kl} u_l = -\\sum_{\\text{cells } E} \\sum_{f_j \\in \\mathcal{F}(E) \\text{ boundary}} (S_E)_{kj} g_j$$\n因此，全局右侧向量的第 $k$ 个条目 $b_k$ 是：\n$$b_k = -\\sum_{\\text{cells } E} \\sum_{f_j \\in \\mathcal{F}(E) \\text{ boundary}} (S_E)_{kj} g_j$$\n\n### 并行组装策略\n\n基于面的组装天然是并行的。单元集合被划分到各个处理器上。每个处理器为其分配的单元计算刚度矩阵 $S_E$。然后，它将这些局部贡献组装成全局矩阵 $A_p$ 和向量 $\\boldsymbol{b}_p$ 的局部版本。由于一个面可以被不同处理器上的单元共享，最终的全局系统通过对所有处理器的贡献求和得到：$A = \\sum_p A_p$ 和 $\\boldsymbol{b} = \\sum_p \\boldsymbol{b}_p$。这个求和代表了通信步骤。该模拟将串行（一个分区）和并行（多个分区）地构造 $A$ 和 $\\boldsymbol{b}$，并验证它们是相同的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, process, and report results for all test cases.\n    \"\"\"\n    # Test Case A: 4-cell square mesh, demonstrating interior face communication.\n    test_case_A = {\n        \"faces\": [\n            {\"adj_cells\": (0, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},  # f0\n            {\"adj_cells\": (0, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f1\n            {\"adj_cells\": (0, 1), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f2 (interior)\n            {\"adj_cells\": (0, 2), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f3 (interior)\n            {\"adj_cells\": (1, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f4\n            {\"adj_cells\": (1, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f5\n            {\"adj_cells\": (1, 3), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f6 (interior)\n            {\"adj_cells\": (2, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},  # f7\n            {\"adj_cells\": (2, 3), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f8 (interior)\n            {\"adj_cells\": (2, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f9\n            {\"adj_cells\": (3, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f10\n            {\"adj_cells\": (3, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f11\n        ],\n        \"cells\": [\n            {\"kappa\": 1.0, \"face_indices\": [0, 1, 2, 3], \"face_distances\": [0.25, 0.25, 0.25, 0.25]}, # c0\n            {\"kappa\": 1.0, \"face_indices\": [2, 4, 5, 6], \"face_distances\": [0.25, 0.25, 0.25, 0.25]}, # c1\n            {\"kappa\": 1.0, \"face_indices\": [7, 3, 8, 9], \"face_distances\": [0.25, 0.25, 0.25, 0.25]}, # c2\n            {\"kappa\": 1.0, \"face_indices\": [8, 6, 11, 10], \"face_distances\": [0.25, 0.25, 0.25, 0.25]},# c3\n        ],\n        \"partitions\": [[0, 3], [1, 2]],\n    }\n\n    # Test Case B: Single cell with all Dirichlet boundaries (no unknowns).\n    test_case_B = {\n        \"faces\": [\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},\n        ],\n        \"cells\": [{\"kappa\": 1.0, \"face_indices\": [0, 1, 2, 3], \"face_distances\": [0.5, 0.5, 0.5, 0.5]}],\n        \"partitions\": [[0]],\n    }\n\n    # Test Case C: Two cells with conductivity contrast and skewed geometry.\n    test_case_C = {\n        \"faces\": [\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},  # f0\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f1\n            {\"adj_cells\": (0, 1), \"length\": 0.2, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f2 (interior)\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f3\n            {\"adj_cells\": (1, -1), \"length\": 1.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f4\n            {\"adj_cells\": (1, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f5\n            {\"adj_cells\": (1, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f6\n        ],\n        \"cells\": [\n            {\"kappa\": 2.5, \"face_indices\": [0, 1, 2, 3], \"face_distances\": [0.5, 0.5, 0.05, 0.5]},\n            {\"kappa\": 0.5, \"face_indices\": [2, 4, 5, 6], \"face_distances\": [0.02, 0.7, 0.6, 0.8]},\n        ],\n        \"partitions\": [[0], [1]],\n    }\n    \n    test_cases_data = [test_case_A, test_case_B, test_case_C]\n    \n    final_results = []\n    for test_data in test_cases_data:\n        results = process_case(test_data)\n        final_results.extend(results)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in final_results)}]\")\n\ndef process_case(test_data):\n    \"\"\"\n    Runs a single test case: performs serial and parallel assembly, solves, and computes metrics.\n    \"\"\"\n    faces = test_data[\"faces\"]\n    cells = test_data[\"cells\"]\n    partitions = test_data[\"partitions\"]\n\n    interior_face_indices = [i for i, f in enumerate(faces) if not f[\"is_dirichlet\"]]\n    num_unknowns = len(interior_face_indices)\n    interior_face_map = {face_idx: i for i, face_idx in enumerate(interior_face_indices)}\n\n    # Handle case with no unknowns as per problem specification.\n    if num_unknowns == 0:\n        return [0.0, 0.0, 1.0]\n\n    # Serial Assembly: all cells in one partition.\n    serial_partition = list(range(len(cells)))\n    A_serial, b_serial = assemble_partition(serial_partition, faces, cells, num_unknowns, interior_face_map)\n\n    # Parallel Assembly Simulation: Sum contributions from each partition.\n    A_parallel = np.zeros_like(A_serial)\n    b_parallel = np.zeros_like(b_serial)\n    for partition_cells in partitions:\n        A_part, b_part = assemble_partition(partition_cells, faces, cells, num_unknowns, interior_face_map)\n        A_parallel += A_part\n        b_parallel += b_part\n    \n    # Solve linear systems for interior face potentials.\n    sol_serial = np.linalg.solve(A_serial, b_serial)\n    sol_parallel = np.linalg.solve(A_parallel, b_parallel)\n\n    # Compute required metrics.\n    mat_diff = np.linalg.norm(A_serial - A_parallel, 'fro')\n    sol_diff = np.linalg.norm(sol_serial - sol_parallel, np.inf) if num_unknowns > 0 else 0.0\n    cond_num = np.linalg.cond(A_serial, 2) if num_unknowns > 0 else 1.0\n\n    return [mat_diff, sol_diff, cond_num]\n\ndef assemble_partition(partition_cells, faces, cells, num_unknowns, interior_face_map):\n    \"\"\"\n    Assembles the stiffness matrix and RHS vector for a given partition of cells.\n    \"\"\"\n    A_part = np.zeros((num_unknowns, num_unknowns))\n    b_part = np.zeros(num_unknowns)\n\n    for cell_idx in partition_cells:\n        cell = cells[cell_idx]\n        \n        # 1. Calculate local transmissibilities for faces of the current cell.\n        local_face_indices = cell[\"face_indices\"]\n        num_local_faces = len(local_face_indices)\n        T = np.zeros(num_local_faces)\n        for i, face_idx in enumerate(local_face_indices):\n            T[i] = cell[\"kappa\"] * faces[face_idx][\"length\"] / cell[\"face_distances\"][i]\n        \n        T_tot = np.sum(T)\n\n        if T_tot == 0:  # Avoid division by zero for degenerate cells\n            continue\n\n        # 2. Form local stiffness matrix (contribution to the Schur complement system).\n        # S_ij = T_i * delta_ij - (T_i * T_j) / T_tot\n        S_local = np.diag(T) - np.outer(T, T) / T_tot\n\n        # 3. Assemble local contributions into the partition's global matrix and vector.\n        for i in range(num_local_faces):\n            glob_idx_i = local_face_indices[i]\n            \n            # Check if the row 'i' corresponds to an interior face (an unknown).\n            if not faces[glob_idx_i][\"is_dirichlet\"]:\n                unknown_idx_i = interior_face_map[glob_idx_i]\n\n                for j in range(num_local_faces):\n                    glob_idx_j = local_face_indices[j]\n                    \n                    s_ij = S_local[i, j]\n\n                    if not faces[glob_idx_j][\"is_dirichlet\"]:\n                        # Column 'j' corresponds to an interior face. Add to stiffness matrix.\n                        unknown_idx_j = interior_face_map[glob_idx_j]\n                        A_part[unknown_idx_i, unknown_idx_j] += s_ij\n                    else:\n                        # Column 'j' corresponds to a Dirichlet face. Add to RHS vector.\n                        dirichlet_val = faces[glob_idx_j][\"dirichlet_val\"]\n                        b_part[unknown_idx_i] -= s_ij * dirichlet_val\n\n    return A_part, b_part\n\n# Execute the main function.\nsolve()\n```", "id": "3518426"}]}