{"hands_on_practices": [{"introduction": "辛积分器的主要优势在于其在处理哈密顿系统时卓越的长期性能。本练习通过模拟一个棒状星系晕的简化模型，直接比较了一种二阶辛分裂法和一种标准的四阶Runge-Kutta方法 [@problem_id:3493173]。通过追踪能量（雅可比积分）和其他绝热不变量在数千个动力学周期内的守恒情况，您将定量地理解为什么保持相空间几何结构对于长期宇宙学模拟的保真度至关重要。", "problem": "考虑在一个旋转参考系中，一个用于棒旋暗物质晕的二维玩具模型的长时间数值积分。该系统由一个在旋转参考系中自治的哈密顿量建模，其正则坐标为 $q = (x,y)$，正则动量为 $p = (p_x,p_y)$，表达式如下\n$$\nH(q,p) \\equiv \\frac{1}{2}\\left(p_x^2 + p_y^2\\right) + \\frac{1}{2}\\left(\\omega_x^2 x^2 + \\omega_y^2 y^2\\right) - \\Omega \\left( x p_y - y p_x \\right),\n$$\n其中 $\\omega_x$ 和 $\\omega_y$ 是各向异性谐振子背景（代表三轴或棒状形变）的特征频率，$\\Omega$ 是棒的恒定模式转速。运动方程为哈密顿方程 $\\dot{q} = \\partial H/\\partial p$ 和 $\\dot{p} = -\\partial H/\\partial q$。量 $H$ 是旋转参考系中的雅可比积分，并被连续动力学精确守恒。\n\n在数值宇宙学中，一个核心目标是在积分哈密顿系统时保持长时间结构（相空间体积和不变量）。辛积分器旨在保持辛结构，并且通过后向误差分析，能够精确守恒一个修正的哈密顿量，而通用的非辛积分器则不具备此特性。在近可积区域，我们还监测绝热不变量，例如类作用量。对于上述模型，定义类作用量诊断量\n$$\nJ_x(t) \\equiv \\frac{\\frac{1}{2}p_x(t)^2 + \\frac{1}{2}\\omega_x^2 x(t)^2}{\\omega_x}, \\quad\nJ_y(t) \\equiv \\frac{\\frac{1}{2}p_y(t)^2 + \\frac{1}{2}\\omega_y^2 y(t)^2}{\\omega_y},\n$$\n当 $\\Omega = 0$ 且 $\\omega_x = \\omega_y$ 时，它们是解耦的各向同性情况下的精确不变量。在一般的旋转、各向异性设置中，$J_x$ 和 $J_y$ 不是精确不变量，但可作为数值保真度的绝热诊断量。\n\n任务。编写一个完整、可运行的程序，该程序：\n- 为上述哈密顿量实现两个积分器：\n  1) 一个二阶对称Strang分裂辛方法，通过将 $H = T + U + G$ 分裂得到，其中 \n  $T(p) = \\frac{1}{2}(p_x^2 + p_y^2)$，$U(q) = \\frac{1}{2}(\\omega_x^2 x^2 + \\omega_y^2 y^2)$，以及 $G(q,p) = -\\Omega (x p_y - y p_x)$；以及\n  2) 一个应用于完整哈密顿方程的标准显式四阶Runge–Kutta方法。\n- 使用所有测试用例共享的以下固定初始条件：$x(0) = 1.0$，$y(0) = 0.2$，$p_x(0) = 0.0$，$p_y(0) = 0.9$（无量纲）。\n- 对于每个数值轨迹，在整个积分时间区间 $[0,T]$ 上计算两个标量误差诊断：\n  1) 雅可比积分的最大相对偏差，\n  $$\n  \\epsilon_H \\equiv \\max_{0 \\le t \\le T} \\frac{\\left| H(t) - H(0) \\right|}{\\left| H(0) \\right| + 10^{-12}},\n  $$\n  以及\n  2) 作用量之和 $J_x + J_y$ 的均方根相对偏差，\n  $$\n  \\epsilon_J \\equiv \\left[ \\frac{1}{N+1}\\sum_{n=0}^{N} \\left( \\frac{J_x(t_n) + J_y(t_n) - \\left[J_x(0) + J_y(0)\\right]}{\\left|J_x(0) + J_y(0)\\right| + 10^{-12}} \\right)^2 \\right]^{1/2},\n  $$\n  其中 $t_n = n \\,\\Delta t$ 且 $N = \\lfloor T/\\Delta t \\rfloor$。\n- 积分使用固定的时间步长 $\\Delta t$ 进行，无自适应控制，并且所有量均为无量纲。\n\n积分器规范。Strang分裂辛方法必须由 $T$、$U$ 和 $G$ 的精确流构建：\n- 在 $\\tau$ 上的 $T$-流：$q \\mapsto q + p\\,\\tau$, $p \\mapsto p$。\n- 在 $\\tau$ 上的 $U$-流：$q \\mapsto q$, $p \\mapsto p - \\nabla U(q)\\,\\tau$，其中 $\\nabla U(q) = (\\omega_x^2 x, \\omega_y^2 y)$。\n- 在 $\\tau$ 上的 $G$-流：同时旋转 $q \\mapsto R(\\Omega \\tau)\\,q$ 和 $p \\mapsto R(\\Omega \\tau)\\,p$，其中 $R(\\theta)$ 是平面旋转，其矩阵为 $R(\\theta) = \\begin{pmatrix}\\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix}$。\n对称二阶方法的一个时间步长 $\\Delta t$ 必须是 $U(\\Delta t/2) \\circ G(\\Delta t/2) \\circ T(\\Delta t) \\circ G(\\Delta t/2) \\circ U(\\Delta t/2)$ 的复合。\n\nRunge–Kutta规范。四阶Runge–Kutta方法必须应用于具有以下形式的完整哈密顿方程\n$$\n\\dot{x} = p_x + \\Omega y, \\quad \\dot{y} = p_y - \\Omega x, \\quad\n\\dot{p}_x = -\\omega_x^2 x + \\Omega p_y, \\quad \\dot{p}_y = -\\omega_y^2 y - \\Omega p_x.\n$$\n\n测试套件。您的程序必须运行以下六个测试用例，每个用例由元组 $(\\text{method}, \\omega_x, \\omega_y, \\Omega, T, \\Delta t)$ 定义：\n- 用例 1：$(\\text{S2},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.05)$。\n- 用例 2：$(\\text{RK4},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.05)$。\n- 用例 3：$(\\text{S2},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.20)$。\n- 用例 4：$(\\text{RK4},\\, 1.0,\\, 1.2,\\, 0.3,\\, 1000.0,\\, 0.20)$。\n- 用例 5：$(\\text{S2},\\, 1.0,\\, 1.0,\\, 0.0,\\, 1000.0,\\, 0.05)$。\n- 用例 6：$(\\text{RK4},\\, 1.0,\\, 1.0,\\, 0.0,\\, 1000.0,\\, 0.05)$。\n\n输出。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于按上述顺序排列的每个用例，附加两个浮点数 $(\\epsilon_H, \\epsilon_J)$，因此最终输出按以下顺序包含 12 个数字\n$$\n[\\epsilon_H^{(1)},\\epsilon_J^{(1)}, \\epsilon_H^{(2)},\\epsilon_J^{(2)}, \\ldots, \\epsilon_H^{(6)},\\epsilon_J^{(6)}].\n$$\n\n注意。\n- 所有量均为无量纲，因此不需要物理单位。\n- 角度假定为弧度。\n- 程序必须是自包含的，不得读取任何输入，也不得访问外部文件或网络。", "solution": "用户要求编写一个程序，使用两种不同的数值积分器来求解一个二维哈密顿系统的运动方程，这是一个与星系动力学相关的玩具模型。这两种积分器是：二阶辛Strang分裂方法（S2）和标准四阶Runge-Kutta方法（RK4）。目标是比较它们在长时间积分中保持系统不变量的性能。\n\n系统状态由正则坐标 $q = (x, y)$ 和正则动量 $p = (p_x, p_y)$ 描述。所有量都是无量纲的。状态向量可以表示为一个 4 维向量 $z(t) = (x(t), y(t), p_x(t), p_y(t))$。动力学由哈密顿量决定：\n$$\nH(q,p) = \\frac{1}{2}\\left(p_x^2 + p_y^2\\right) + \\frac{1}{2}\\left(\\omega_x^2 x^2 + \\omega_y^2 y^2\\right) - \\Omega \\left( x p_y - y p_x \\right)\n$$\n该哈密顿量是系统在以恒定模式转速 $\\Omega$ 旋转的参考系中的雅可比积分。参数 $\\omega_x$ 和 $\\omega_y$ 是背景势的特征频率。运动方程是哈密顿方程，$\\dot{z} = \\mathbf{J} \\nabla H$，其中 $\\mathbf{J}$ 是标准辛矩阵。\n\n解决方案涉及实现指定的两个数值积分器和两个诊断误差度量 $\\epsilon_H$ 和 $\\epsilon_J$。\n\n**1. 辛积分器：二阶Strang分裂（S2）**\n\n辛积分器是一类几何数值方法，旨在保持哈密顿系统的辛结构。此特性确保了相空间体积的守恒，并带来出色的长期稳定性，特别是对一个被精确守恒的“影子”哈密顿量，其误差有界。\n\n问题指定将哈密顿量分裂为三部分，$H = T + U + G$，其中：\n- $T(p) = \\frac{1}{2}(p_x^2 + p_y^2)$：动能。\n- $U(q) = \\frac{1}{2}(\\omega_x^2 x^2 + \\omega_y^2 y^2)$：来自各向异性谐振子的势能。\n- $G(q,p) = -\\Omega (x p_y - y p_x)$：源于旋转参考系中科里奥利力的项。\n\n这些子哈密顿量中的每一个都生成一个可以被精确积分的流。通过复合这些精确流来构建大小为 $\\Delta t$ 的单个时间步。指定的对称Strang分裂复合为：\n$$\n\\Phi_{\\Delta t}^{\\text{S2}} = \\phi_U(\\Delta t/2) \\circ \\phi_G(\\Delta t/2) \\circ \\phi_T(\\Delta t) \\circ \\phi_G(\\Delta t/2) \\circ \\phi_U(\\Delta t/2)\n$$\n其中 $\\phi_K(\\tau)$ 表示哈密顿量为 $K$ 的子系统在时间间隔 $\\tau$ 内的精确流。各个流如下：\n- **流 $\\phi_T(\\tau)$：** $\\dot{q} = \\partial T/\\partial p = p$ 和 $\\dot{p} = -\\partial T/\\partial q = 0$ 的解。这是一个自由粒子漂移：$q(t_0+\\tau) = q(t_0) + p(t_0)\\tau$，$p(t_0+\\tau) = p(t_0)$。\n- **流 $\\phi_U(\\tau)$：** $\\dot{q} = 0$ 和 $\\dot{p} = -\\nabla U(q)$ 的解。这是一个冲量：$q(t_0+\\tau) = q(t_0)$，$p(t_0+\\tau) = p(t_0) - \\nabla U(q(t_0))\\tau$，其中 $\\nabla U(q) = (\\omega_x^2 x, \\omega_y^2 y)$。\n- **流 $\\phi_G(\\tau)$：** $H=G$ 的哈密顿方程的解。这对应于坐标向量 $q$ 和动量向量 $p$ 的同时旋转。状态向量 $q$ 和 $p$ 通过应用旋转矩阵 $R(\\theta) = \\begin{pmatrix}\\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix}$ 进行更新，旋转角为 $\\theta = \\Omega \\tau$。\n\n实现按指定顺序组合这些变换，以将状态向量 $z$推进一个时间步 $\\Delta t$。\n\n**2. 非辛积分器：四阶Runge-Kutta（RK4）**\n\n显式四阶Runge-Kutta方法是一种广泛使用的通用求解器，用于求解形式为 $\\dot{z} = f(t, z)$ 的常微分方程组。对于此问题，函数 $f$ 源自完整的哈密顿方程：\n$$\nf(z) = \\begin{pmatrix} \\dot{x} \\\\ \\dot{y} \\\\ \\dot{p}_x \\\\ \\dot{p}_y \\end{pmatrix} = \\begin{pmatrix} p_x + \\Omega y \\\\ p_y - \\Omega x \\\\ -\\omega_x^2 x + \\Omega p_y \\\\ -\\omega_y^2 y - \\Omega p_x \\end{pmatrix}\n$$\n从 $z_n$ 到 $z_{n+1}$ 经过一个时间步 $\\Delta t$ 的单步计算如下：\n$$\n\\begin{align*}\nk_1 = f(z_n) \\\\\nk_2 = f(z_n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 = f(z_n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 = f(z_n + \\Delta t k_3) \\\\\nz_{n+1} = z_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n虽然对于给定的步长，RK4 具有很高的精度，但它不保持辛结构，在长时间积分中通常会导致能量和其他守恒量出现长期漂移。\n\n**3. 诊断和主循环**\n\n对于每个测试用例，程序将状态向量初始化为 $z(0) = (1.0, 0.2, 0.0, 0.9)$。然后，它以固定的步长 $\\Delta t$ 从 $t=0$ 到 $t=T$ 进行积分。在模拟期间，哈密顿量 $H(t)$ 和作用量之和 $J_x(t) + J_y(t)$ 的值在每个时间步 $t_n = n \\Delta t$（$n = 0, \\ldots, N$，其中 $N = \\lfloor T/\\Delta t \\rfloor$）被存储。\n\n积分完成后，计算两个误差度量：\n- 雅可比积分的最大相对偏差 $\\epsilon_H$，量化了系统类能不变量的守恒情况。\n- 作用量之和的均方根相对偏差 $\\epsilon_J$，衡量了一个绝热不变量的保持情况，该不变量仅在系统的简化、解耦版本中精确守恒。\n\n代码的结构是循环遍历六个指定的测试用例，为每个用例运行相应的模拟，计算两个诊断量，并收集结果以供最终输出。使用 NumPy 库进行高效的向量和数组操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef hamiltonian(z, wx2, wy2, Omega):\n    \"\"\"Computes the Hamiltonian H(q,p).\"\"\"\n    x, y, px, py = z\n    T = 0.5 * (px**2 + py**2)\n    U = 0.5 * (wx2 * x**2 + wy2 * y**2)\n    G = -Omega * (x * py - y * px)\n    return T + U + G\n\ndef actions(z, wx, wy):\n    \"\"\"Computes the action-like diagnostics J_x and J_y.\"\"\"\n    x, y, px, py = z\n    # Add a small epsilon to denominators to avoid division by zero if wx or wy is 0\n    eps = 1e-16\n    jx = (0.5 * px**2 + 0.5 * wx**2 * x**2) / (wx + eps)\n    jy = (0.5 * py**2 + 0.5 * wy**2 * y**2) / (wy + eps)\n    return jx, jy\n\n# --- S2 Integrator Components ---\ndef flow_T(z, dt):\n    \"\"\"Exact flow for H=T(p).\"\"\"\n    x, y, px, py = z\n    x_new = x + px * dt\n    y_new = y + py * dt\n    return np.array([x_new, y_new, px, py])\n\ndef flow_U(z, wx2, wy2, dt):\n    \"\"\"Exact flow for H=U(q).\"\"\"\n    x, y, px, py = z\n    px_new = px - wx2 * x * dt\n    py_new = py - wy2 * y * dt\n    return np.array([x, y, px_new, py_new])\n\ndef flow_G(z, Omega, dt):\n    \"\"\"Exact flow for H=G(q,p).\"\"\"\n    theta = Omega * dt\n    c, s = np.cos(theta), np.sin(theta)\n    x, y, px, py = z\n    x_new = c * x + s * y\n    y_new = -s * x + c * y\n    px_new = c * px + s * py\n    py_new = -s * px + c * py\n    return np.array([x_new, y_new, px_new, py_new])\n\ndef s2_step(z, wx2, wy2, Omega, dt):\n    \"\"\"One step of the second-order Strang splitting integrator.\"\"\"\n    dt_half = 0.5 * dt\n    z_new = flow_U(z, wx2, wy2, dt_half)\n    z_new = flow_G(z_new, Omega, dt_half)\n    z_new = flow_T(z_new, dt)\n    z_new = flow_G(z_new, Omega, dt_half)\n    z_new = flow_U(z_new, wx2, wy2, dt_half)\n    return z_new\n\n# --- RK4 Integrator Components ---\ndef rk4_derivatives(z, wx2, wy2, Omega):\n    \"\"\"Computes the time derivative of the state vector for RK4.\"\"\"\n    x, y, px, py = z\n    dx_dt = px + Omega * y\n    dy_dt = py - Omega * x\n    dpx_dt = -wx2 * x + Omega * py\n    dpy_dt = -wy2 * y - Omega * px\n    return np.array([dx_dt, dy_dt, dpx_dt, dpy_dt])\n\ndef rk4_step(z, wx2, wy2, Omega, dt):\n    \"\"\"One step of the fourth-order Runge-Kutta integrator.\"\"\"\n    k1 = rk4_derivatives(z, wx2, wy2, Omega)\n    k2 = rk4_derivatives(z + 0.5 * dt * k1, wx2, wy2, Omega)\n    k3 = rk4_derivatives(z + 0.5 * dt * k2, wx2, wy2, Omega)\n    k4 = rk4_derivatives(z + dt * k3, wx2, wy2, Omega)\n    return z + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef run_simulation(method, wx, wy, Omega, T, dt, initial_state):\n    \"\"\"Runs a full simulation for a given method and parameters.\"\"\"\n    z = initial_state.copy()\n    wx2, wy2 = wx**2, wy**2\n    \n    num_steps = int(T / dt)\n    \n    # Store history for diagnostics\n    H_history = np.zeros(num_steps + 1)\n    J_sum_history = np.zeros(num_steps + 1)\n\n    # Initial values at t=0\n    H_history[0] = hamiltonian(z, wx2, wy2, Omega)\n    jx, jy = actions(z, wx, wy)\n    J_sum_history[0] = jx + jy\n\n    # Integration loop\n    for i in range(num_steps):\n        if method == 'S2':\n            z = s2_step(z, wx2, wy2, Omega, dt)\n        elif method == 'RK4':\n            z = rk4_step(z, wx2, wy2, Omega, dt)\n        \n        H_history[i + 1] = hamiltonian(z, wx2, wy2, Omega)\n        jx, jy = actions(z, wx, wy)\n        J_sum_history[i + 1] = jx + jy\n\n    # Calculate diagnostics\n    H0 = H_history[0]\n    J_sum0 = J_sum_history[0]\n    \n    # Epsilon H\n    eps_H_num = np.abs(H_history - H0)\n    eps_H_den = np.abs(H0) + 1e-12\n    epsilon_H = np.max(eps_H_num / eps_H_den)\n\n    # Epsilon J\n    eps_J_num = J_sum_history - J_sum0\n    eps_J_den = np.abs(J_sum0) + 1e-12\n    sq_rel_dev = (eps_J_num / eps_J_den)**2\n    epsilon_J = np.sqrt(np.mean(sq_rel_dev))\n    \n    return epsilon_H, epsilon_J\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, omega_x, omega_y, Omega, T, dt)\n        ('S2', 1.0, 1.2, 0.3, 1000.0, 0.05),\n        ('RK4', 1.0, 1.2, 0.3, 1000.0, 0.05),\n        ('S2', 1.0, 1.2, 0.3, 1000.0, 0.20),\n        ('RK4', 1.0, 1.2, 0.3, 1000.0, 0.20),\n        ('S2', 1.0, 1.0, 0.0, 1000.0, 0.05),\n        ('RK4', 1.0, 1.0, 0.0, 1000.0, 0.05),\n    ]\n\n    initial_state = np.array([1.0, 0.2, 0.0, 0.9])\n    \n    results = []\n    for case in test_cases:\n        method, wx, wy, Omega, T, dt = case\n        eps_H, eps_J = run_simulation(method, wx, wy, Omega, T, dt, initial_state)\n        results.append(eps_H)\n        results.append(eps_J)\n\n    # Final print statement in the exact required format.\n    # Using 'g' format for clean representation of small and regular numbers.\n    print(f\"[{','.join(f'{r:.7g}' for r in results)}]\")\n\nsolve()\n```", "id": "3493173"}, {"introduction": "在观察了辛积分的实际好处之后，我们现在深入探讨其基本的数学定义。一个映射是辛的，如果其雅可比矩阵 $J$ 保持典范辛形式 $S$ 不变，即满足条件 $J^T S J = S$。本练习将指导您实现一个数值诊断工具，该工具通过近似计算积分器单步映射的雅可比矩阵，并计算其与此精确条件的偏差 [@problem_id:3493143]。这种动手验证将一个抽象的代数性质转化为一个具体的、可测量的量，从而证实我们对不同数值方案的理论预期。", "problem": "设计并实现一个程序，用于数值诊断由数值宇宙学中使用的 N 体哈密顿积分器生成的离散时间映射的辛性。该诊断必须通过计算量 $J^{\\top} S J - S$ 来评估与典范辛条件的偏差，其中 $J$ 是积分器单步映射的雅可比矩阵，$S$ 是典范辛形式。程序必须为每个测试案例报告一个标量偏差，方法是取 $J^{\\top} S J - S$ 的矩阵范数，并将此范数在一组随机相空间状态上进行聚合。\n\n使用以下适合该背景的基本基础：\n- 对于位置 $q$ 和动量 $p$，采用典范形式的哈密顿力学，其中 $dq/dt = \\partial H / \\partial p$ 和 $dp/dt = -\\partial H / \\partial q$。\n- 对于具有无量纲参数的 $N$ 个物体，使用带 Plummer 软化的引力哈密顿量：$H(q,p) = \\sum_{i=1}^{N} \\frac{\\|p_i\\|^2}{2 m_i} - \\sum_{1 \\le i  j \\le N} \\frac{G m_i m_j}{\\sqrt{\\|q_i - q_j\\|^2 + \\epsilon_s^2}}$。\n- 在相空间坐标 $x = (q,p)$ 上，典范辛形式的分块矩阵表示为 $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$，其中 $I$ 是与 $q$（位置）维度相等的单位矩阵。\n- 一个映射是辛映射，当且仅当其雅可比矩阵 $J$ 满足 $J^{\\top} S J = S$。\n\n程序必须执行以下操作：\n1. 构建一个无量纲的 N 体系统，其中 $G = 1$ 且对所有 $i$ 都有 $m_i = 1$，在 $2$ 维空间中工作。所有量都是无单位的，不需要物理单位。\n2. 为哈密顿系统实现两个单步积分器：\n   - 一种时间可逆的二阶辛格式（速度 Verlet/蛙跳法）。\n   - 一种标准的显式四阶龙格-库塔方法。\n3. 对于给定的积分器、时间步长 $h$ 和随机状态 $x = (q,p)$，通过中心有限差分来近似单步映射的雅可比矩阵 $J$。在 $x$ 的每个典范坐标方向上使用 $10^{-7}$ 的固定微扰来计算 $J$ 的列。\n4. 将该状态下单步映射的典范辛性偏差计算为弗罗贝尼乌斯范数 $\\|J^{\\top} S J - S\\|_F$。\n5. 为每个测试案例生成一组随机状态：\n   - 位置 $q_i$ 在正方形 $[-1,1]^2$ 内均匀抽取。\n   - 动量 $p_i$ 在 $[-0.5,0.5]^2$ 内均匀抽取。\n   - 对于 $N \\ge 2$，通过拒绝采样强制实施 $\\delta = 0.2$ 的最小成对间距，以避免接近奇异的构型。\n   - 在引力势中使用 Plummer 软化 $\\epsilon_s = 0.01$。\n6. 对于每个测试案例，计算每个随机状态的辛性偏差，并报告这些偏差的中位数作为该测试案例的结果。\n\n覆盖性设计：\n- 使用以下参数值测试套件，该套件涵盖了不同条件，包括标称情况、更大的时间步长和自由粒子（$N=1$）的边界情况：\n  - 案例1：积分器类型 $=$ 蛙跳法, $N = 3$, $h = 0.005$, 状态数 $M = 4$, 随机种子 $= 42$。\n  - 案例2：积分器类型 $=$ 蛙跳法, $N = 3$, $h = 0.1$, 状态数 $M = 4$, 随机种子 $= 43$。\n  - 案例3：积分器类型 $=$ 蛙跳法, $N = 3$, $h = 0.3$, 状态数 $M = 4$, 随机种子 $= 44$。\n  - 案例4：积分器类型 $=$ 四阶龙格-库塔, $N = 3$, $h = 0.005$, 状态数 $M = 4$, 随机种子 $= 45$。\n  - 案例5：积分器类型 $=$ 四阶龙格-库塔, $N = 3$, $h = 0.1$, 状态数 $M = 4$, 随机种子 $= 46$。\n  - 案例6：积分器类型 $=$ 四阶龙格-库塔, $N = 3$, $h = 0.3$, 状态数 $M = 4$, 随机种子 $= 47$。\n  - 案例7：积分器类型 $=$ 蛙跳法, $N = 1$, $h = 0.3$, 状态数 $M = 4$, 随机种子 $= 48$。\n  - 案例8：积分器类型 $=$ 四阶龙格-库塔, $N = 1$, $h = 0.3$, 状态数 $M = 4$, 随机种子 $= 49$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试套件完全一致（例如 $[r_1,r_2,\\dots,r_8]$），其中每个 $r_k$ 是第 k 个测试案例中 $M$ 个随机状态下 $J^{\\top} S J - S$ 的弗罗贝尼乌斯范数的中位数。所有结果都必须报告为无单位的浮点数。", "solution": "该问题要求设计并实现一种数值诊断方法，以评估由 N 体哈密顿积分器生成的离散时间映射的辛性。这涉及到评估典范辛结构的保持性，这是哈密顿动力学的一个基本几何性质。\n\n\n首先，我们建立理论框架。一个在 $D$ 维空间中的 N 体系统，在相空间中由状态向量 $x = (q, p)$ 描述，其中 $q = (q_1, \\dots, q_N)$ 是广义位置，$p = (p_1, \\dots, p_N)$ 是共轭动量。相空间的总维度是 $2DN$。对于此问题，我们考虑 $D=2$ 个空间维度，因此相空间的维度为 $4N$。系统的动力学由哈密顿函数 $H(q,p)$ 控制。运动方程是哈密顿典范方程：\n$$\n\\frac{dq_i}{dt} = \\frac{\\partial H}{\\partial p_i}, \\quad \\frac{dp_i}{dt} = -\\frac{\\partial H}{\\partial q_i}\n$$\n问题指定了一个用于 N 体的无量纲引力哈密顿量，带有 Plummer 软化 $\\epsilon_s$，引力常数 $G=1$ 且粒子质量 $m_i=1$：\n$$\nH(q,p) = \\sum_{i=1}^{N} \\frac{\\|p_i\\|^2}{2} - \\sum_{1 \\le i  j \\le N} \\frac{1}{\\sqrt{\\|q_i - q_j\\|^2 + \\epsilon_s^2}}\n$$\n系统在时间间隔 $h$ 内的时间演化由流映射 $\\phi_h$ 描述，使得 $x(t+h) = \\phi_h(x(t))$。数值积分器提供了对此映射的近似，我们将其表示为单步映射 $\\Phi_h$。精确流 $\\phi_h$ 的一个关键性质是它是一个辛变换。这意味着其雅可比矩阵 $J = D\\phi_h$ 满足辛条件：\n$$\nJ^{\\top} S J = S\n$$\n此处，$S$ 是典范辛形式，一个在相空间坐标 $x=(q,p)$ 上定义的分块矩阵，形式如下：\n$$\nS = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}\n$$\n其中 $I$ 是 $2N \\times 2N$ 的单位矩阵，$0$ 是 $2N \\times 2N$ 的零矩阵。如果一个积分器的单步映射 $\\Phi_h$ 也是一个辛变换，则该积分器被称为辛积分器。这类积分器对于长期模拟（如在数值宇宙学中）至关重要，因为它们能保守一个“影子”哈密顿量，从而带来出色的长期能量稳定性和相空间体积的保持。\n\n任务是为两种不同的积分器诊断此性质：\n\n1.  **蛙跳法（速度 Verlet）**：这是一种二阶、时间可逆的积分器，众所周知是辛的。其单步映射 $\\Phi_h^{\\text{LF}}$ 由以下序列给出：\n    \n    $p_{n+1/2} = p_n + a(q_n) \\frac{h}{2}$\n    \n    $q_{n+1} = q_n + p_{n+1/2} h$\n    \n    $p_{n+1} = p_{n+1/2} + a(q_{n+1}) \\frac{h}{2}$\n    \n    其中 $a(q) = -\\nabla_q V(q)$ 是从势能 $V(q)$ 推导出的加速度。由于此映射是辛的，其精确的雅可比矩阵应满足辛条件。\n\n2.  **显式四阶龙格-库塔法（RK4）**：这是一种通用的高阶积分器。对于自治系统 $\\dot{x} = f(x)$，其单步映射 $\\Phi_h^{\\text{RK4}}$ 为：\n    \n    $k_1 = f(x_n)$\n    \n    $k_2 = f(x_n + \\frac{h}{2} k_1)$\n    \n    $k_3 = f(x_n + \\frac{h}{2} k_2)$\n    \n    $k_4 = f(x_n + h k_3)$\n    \n    $x_{n+1} = x_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n    \n    其中 $f(x) = f(q,p) = (\\dot{q}, \\dot{p}) = (\\partial H/\\partial p, -\\partial H/\\partial q) = (p, a(q))$。通常，RK4 映射不是辛的，因此提供了一个对比点。\n\n诊断协议如下。对于给定积分器的单步映射 $\\Phi_h$ 和相空间中的一个状态 $x$，我们首先计算雅可比矩阵 $J = D\\Phi_h(x)$。由于对 $J$ 进行解析推导非常繁琐，我们使用中心有限差分法对其进行数值近似。$J$ 的第 j 列近似为：\n$$\nJ_{\\cdot, j} \\approx \\frac{\\Phi_h(x + \\delta e_j) - \\Phi_h(x - \\delta e_j)}{2\\delta}\n$$\n其中 $e_j$ 是第 j 个典范基向量，$\\delta = 10^{-7}$ 是指定的小微扰。\n\n在计算出数值雅可比矩阵 $J$ 后，我们通过构建矩阵 $\\Delta = J^{\\top} S J - S$ 来评估与辛条件的偏差。对于一个完美的辛映射和一个精确的雅可比矩阵，$\\Delta$ 将是零矩阵。对于非辛映射或近似的雅可比矩阵，$\\Delta$ 将非零。此偏差的大小通过一个标量值来量化，即弗罗贝尼乌斯范数：\n$$\n\\|\\Delta\\|_F = \\sqrt{\\sum_{i,j} |\\Delta_{ij}|^2}\n$$\n偏差可能依赖于状态。为了获得给定参数集（积分器类型, $N$, $h$）的代表性度量，会生成一个包含 $M$ 个随机相空间状态的系综。对每个状态，计算其偏差范数。一个测试案例最终报告的值是这 $M$ 个范数的中位数。中位数是一种稳健的统计度量，相比于均值，它对潜在的异常值不那么敏感。初始状态通过从均匀分布中抽取位置 $q_i$ 和动量 $p_i$ 生成，并采用拒绝采样步骤来强制 $N \\ge 2$ 时粒子的最小间距为 $\\delta=0.2$，以避免力计算中出现近奇异点。\n\n对于辛蛙跳积分器，其理论映射是精确辛的。因此，测得的偏差预计会很小，主要来源于浮点运算和有限差分雅可比计算中的近似误差。相反，对于非辛 RK4 积分器，偏差是该方法固有的，预计会显著更大，并且依赖于时间步长 $h$。$N=1$（自由粒子）的特殊情况可作为一个有价值的健全性检查，因为其运动是平凡的（$p(t) = \\text{const}, q(t) = q_0 + p_0 t$），并且两种积分器都能得出精确的辛解，因此预测两者都会有接近于零的偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the symplecticity diagnostics for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (integrator_type, N, h, M, seed)\n        ('leapfrog', 3, 0.005, 4, 42),\n        ('leapfrog', 3, 0.1, 4, 43),\n        ('leapfrog', 3, 0.3, 4, 44),\n        ('rk4', 3, 0.005, 4, 45),\n        ('rk4', 3, 0.1, 4, 46),\n        ('rk4', 3, 0.3, 4, 47),\n        ('leapfrog', 1, 0.3, 4, 48),\n        ('rk4', 1, 0.3, 4, 49),\n    ]\n\n    G = 1.0\n    EPSILON_S = 0.01\n    FINITE_DIFF_PERT = 1e-7\n    MIN_SEP = 0.2\n\n    def get_acceleration(q, n_particles):\n        \"\"\"\n        Calculates the acceleration of N particles.\n        q has shape (n_particles, 2).\n        Returns acceleration of shape (n_particles, 2).\n        \"\"\"\n        if n_particles == 1:\n            return np.zeros_like(q)\n\n        # Vectorized calculation of pairwise forces\n        # q shape: (N, D) - (1, N, D) and (N, 1, D)\n        # diff shape: (N, N, D) where diff[i, j, :] is q[j] - q[i]\n        diff = q[None, :, :] - q[:, None, :]\n\n        # dist_sq shape: (N, N) where dist_sq[i, j] is ||q[j] - q[i]||^2\n        dist_sq = np.sum(diff**2, axis=-1)\n\n        # inv_r3 shape: (N, N) where inv_r3[i, j] = (dist_sq[i, j] + eps^2)^(-3/2)\n        # We use mass=1 and G=1. Force on i from j is - (q_i - q_j) / r^3\n        # accel on i is sum_j (q_j-q_i)/r^3\n        with np.errstate(divide='ignore', invalid='ignore'):\n            inv_r3 = (dist_sq + EPSILON_S**2)**(-1.5)\n        np.fill_diagonal(inv_r3, 0.0) # No self-force\n\n        # accel[i,:] = sum_j (q_j-q_i)*inv_r3[i,j]\n        # diff is qj-qi, so we need to sum over axis 1 (j)\n        accel = np.sum(diff * inv_r3[:, :, None], axis=1) * G\n        \n        return accel\n\n    def leapfrog_step(x, h, n_particles):\n        \"\"\"\n        Performs one step of the velocity Verlet/leapfrog integrator.\n        x is a flat array of shape (4*n_particles,).\n        \"\"\"\n        dim = 2 * n_particles\n        q0 = x[:dim].reshape((n_particles, 2))\n        p0 = x[dim:].reshape((n_particles, 2))\n\n        a0 = get_acceleration(q0, n_particles)\n        p_half = p0 + a0 * h / 2.0\n        q1 = q0 + p_half * h\n        a1 = get_acceleration(q1, n_particles)\n        p1 = p_half + a1 * h / 2.0\n        \n        return np.concatenate((q1.flatten(), p1.flatten()))\n\n    def rk4_step(x, h, n_particles):\n        \"\"\"\n        Performs one step of the RK4 integrator.\n        x is a flat array of shape (4*n_particles,).\n        \"\"\"\n        dim = 2 * n_particles\n\n        def f(state_vec):\n            q_vec = state_vec[:dim].reshape((n_particles, 2))\n            p_vec = state_vec[dim:].reshape((n_particles, 2))\n            \n            dq_dt = p_vec\n            dp_dt = get_acceleration(q_vec, n_particles)\n            \n            return np.concatenate((dq_dt.flatten(), dp_dt.flatten()))\n\n        k1 = f(x)\n        k2 = f(x + 0.5 * h * k1)\n        k3 = f(x + 0.5 * h * k2)\n        k4 = f(x + h * k3)\n        \n        x_next = x + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        return x_next\n\n    def generate_random_state(rng, n_particles, min_sep):\n        \"\"\"\n        Generates a single random state (q, p) with rejection sampling for q.\n        \"\"\"\n        dim_pos = 2 * n_particles\n        q_flat = np.zeros(dim_pos)\n\n        if n_particles >= 2:\n            while True:\n                q = rng.uniform(-1.0, 1.0, size=(n_particles, 2))\n                \n                # Check pairwise separation\n                diff = q[None, :, :] - q[:, None, :]\n                dist_sq = np.sum(diff**2, axis=-1)\n                np.fill_diagonal(dist_sq, np.inf)\n                \n                if np.sqrt(np.min(dist_sq)) > min_sep:\n                    q_flat = q.flatten()\n                    break\n        else: # n_particles == 1\n            q = rng.uniform(-1.0, 1.0, size=(n_particles, 2))\n            q_flat = q.flatten()\n\n        p = rng.uniform(-0.5, 0.5, size=(n_particles, 2))\n        p_flat = p.flatten()\n\n        return np.concatenate((q_flat, p_flat))\n\n    def compute_jacobian(one_step_map, x, h, n_particles, pert):\n        \"\"\"\n        Computes the Jacobian of the one-step map using central finite differences.\n        \"\"\"\n        phase_space_dim = 4 * n_particles\n        jacobian = np.zeros((phase_space_dim, phase_space_dim))\n        \n        for j in range(phase_space_dim):\n            e_j = np.zeros(phase_space_dim)\n            e_j[j] = 1.0\n            \n            x_plus = x + pert * e_j\n            x_minus = x - pert * e_j\n            \n            map_plus = one_step_map(x_plus, h, n_particles)\n            map_minus = one_step_map(x_minus, h, n_particles)\n\n            jacobian[:, j] = (map_plus - map_minus) / (2 * pert)\n            \n        return jacobian\n\n    results = []\n    integrators = {'leapfrog': leapfrog_step, 'rk4': rk4_step}\n\n    for case in test_cases:\n        integrator_type, N, h, M, seed = case\n        \n        rng = np.random.default_rng(seed)\n        one_step_map = integrators[integrator_type]\n        \n        phase_space_dim = 4 * N\n        pos_dim = 2 * N\n        \n        # Construct the symplectic matrix S\n        I = np.identity(pos_dim)\n        Z = np.zeros((pos_dim, pos_dim))\n        S = np.block([[Z, I], [-I, Z]])\n        \n        deviations = []\n        for _ in range(M):\n            # 1. Generate a random state\n            x0 = generate_random_state(rng, N, MIN_SEP)\n            \n            # 2. Compute the Jacobian at this state\n            J = compute_jacobian(one_step_map, x0, h, N, FINITE_DIFF_PERT)\n            \n            # 3. Compute the deviation matrix and its norm\n            deviation_matrix = J.T @ S @ J - S\n            deviation_norm = np.linalg.norm(deviation_matrix, 'fro')\n            deviations.append(deviation_norm)\n            \n        # 4. Report the median deviation for the test case\n        median_deviation = np.median(deviations)\n        results.append(median_deviation)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493143"}, {"introduction": "现实世界中的宇宙学模拟通常涉及非自治哈密顿量，其势能随宇宙时间演化。本练习将蛙跳法（leapfrog method）扩展到此类系统，比较了在现代宇宙学代码中标准的“踢-漂移-踢”（Kick-Drift-Kick, KDK）和“漂移-踢-漂移”（Drift-Kick-Drift, DKD）两种变体 [@problem_id:3493161]。您将研究评估随时间变化的尺度因子 $a(t)$ 的不同策略——即时计算或从预先计算的表格中查找——如何影响积分的相位精度，从而揭示在设计高保真度宇宙学积分器时那些微妙但重要的选择。", "problem": "考虑一个与数值宇宙学中随动坐标相关的一维非自治哈密顿系统，其哈密顿量 $H(\\mathbf{q},\\mathbf{p},a(t))$ 特化为一个空间自由度。设哈密顿量是可分离的，形式为 $H(q,p,a(t)) = T(p) + S(a(t)) V(q)$，其中 $T(p) = \\frac{1}{2} p^2$，$V(q) = \\frac{1}{2} \\omega_0^2 q^2$，以及 $S(a(t)) = a(t)^{-3}$。正则运动方程为 $q' = \\partial H/\\partial p = p$ 和 $p' = -\\partial H/\\partial q = -S(a(t)) \\omega_0^2 q$，其中撇号表示对宇宙时 $t$ 的导数。尺度因子 $a(t)$ 遵循一个包含物质和宇宙学常数的空间平坦宇宙的弗里德曼方程，由 $a'(t) = H_0 a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$ 给出，其中 $H_0$ 是当前纪元的哈勃参数，且 $\\Omega_m + \\Omega_\\Lambda = 1$。\n\n本问题要求您比较此非自治哈密顿系统的“踢-漂移-踢”（KDK）和“漂移-踢-漂移”（DKD）蛙跳法次序，并描述两种获取 $a(t)$ 的策略所产生的相位误差差异：(i) 使用与蛙跳法子步同步的一阶显式格式进行在线演化；(ii) 使用通过高精度数值解弗里德曼方程得到的 $a(t)$ 表格，并在所需时间点进行插值。您必须实现这两种积分器和两种 $a(t)$ 策略，然后量化相对于一个高精度参考解的相位误差。该参考解在求解 $(q(t),p(t))$ 动力学时，于一个高阶常微分方程求解器中使用了表格化的 $a(t)$。\n\n基本原理：\n- 对于可分离的哈密顿量 $H(q,p,a(t))$，哈密顿方程为 $q' = p$ 和 $p' = -S(a(t)) \\omega_0^2 q$。\n- 在平坦宇宙中，弗里德曼方程为 $a'(t) = H_0 a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$，其中 $\\Omega_\\Lambda = 1 - \\Omega_m$。\n- 辛蛙跳积分器可以按 KDK（漂移半步、踢整步、漂移半步）或 DKD（踢半步、漂移整步、踢半步）的次序排列。对于随时间变化的 $S(a(t))$，KDK 在步长中点时间 $t + h/2$ 计算“踢”的作用，而 DKD 则使用端点时间 $t$ 和 $t + h$，其中 $h$ 是时间步长。\n\n定义和单位：\n- 使用无量纲单位，令 $H_0 = 1$，因此时间 $t$ 以 $H_0^{-1}$ 为单位进行度量。\n- 角度必须以弧度报告。\n- 设瞬时有效频率为 $\\omega_{\\mathrm{eff}}(t) = \\omega_0 \\sqrt{S(a(t))} = \\omega_0 a(t)^{-3/2}$。定义在时间 $t$ 的瞬时角变量为 $\\theta(t) = \\operatorname{atan2}(\\omega_{\\mathrm{eff}}(t) q(t), p(t))$，单位为弧度。\n\n积分器规格：\n- 使用表格化 $a(t)$ 的 KDK，步长为 $h$：\n  1. 在时间 $t_n + h/2$ 计算 $q_{\\mathrm{half}} = q_n + p_n \\, h/2$。\n  2. 从表格中评估 $a_{\\mathrm{mid}} = a(t_n + h/2)$。施加“踢”：$p_{n+1} = p_n - \\omega_0^2 S(a_{\\mathrm{mid}}) q_{\\mathrm{half}} h$。\n  3. 完成“漂移”：$q_{n+1} = q_{\\mathrm{half}} + p_{n+1} \\, h/2$。推进时间 $t_{n+1} = t_n + h$。\n- 使用表格化 $a(t)$ 的 DKD，步长为 $h$：\n  1. 评估 $a_n = a(t_n)$ 并施加半“踢”：$p_{\\mathrm{half}} = p_n - \\omega_0^2 S(a_n) q_n \\, h/2$。\n  2. “漂移”整步：$q_{n+1} = q_n + p_{\\mathrm{half}} h$，推进时间 $t_{n+1} = t_n + h$。\n  3. 评估 $a_{n+1} = a(t_{n+1})$ 并施加最后的半“踢”：$p_{n+1} = p_{\\mathrm{half}} - \\omega_0^2 S(a_{n+1}) q_{n+1} \\, h/2$。\n- 使用与子步同步的一阶显式演化进行在线 $a(t)$ 计算的 KDK：\n  1. 计算 $q_{\\mathrm{half}} = q_n + p_n \\, h/2$。\n  2. 更新 $a_{\\mathrm{half}} = a_n + (h/2) f(a_n)$，其中 $f(a) = a \\sqrt{\\Omega_m a^{-3} + \\Omega_\\Lambda}$。\n  3. 使用 $a_{\\mathrm{half}}$ 施加“踢”：$p_{n+1} = p_n - \\omega_0^2 S(a_{\\mathrm{half}}) q_{\\mathrm{half}} h$。\n  4. 完成“漂移”：$q_{n+1} = q_{\\mathrm{half}} + p_{n+1} \\, h/2$。\n  5. 更新 $a_{n+1} = a_{\\mathrm{half}} + (h/2) f(a_{\\mathrm{half}})$。\n- 使用与子步同步的一阶显式演化进行在线 $a(t)$ 计算的 DKD：\n  1. 在 $a_n$ 处施加半“踢”：$p_{\\mathrm{half}} = p_n - \\omega_0^2 S(a_n) q_n \\, h/2$。\n  2. “漂移”整步：$q_{n+1} = q_n + p_{\\mathrm{half}} h$。\n  3. 更新 $a_{n+1} = a_n + h f(a_n)$。\n  4. 在 $a_{n+1}$ 处施加最后的半“踢”：$p_{n+1} = p_{\\mathrm{half}} - \\omega_0^2 S(a_{n+1}) q_{n+1} \\, h/2$。\n\n参考解：\n- 通过使用高阶常微分方程求解器和严格的容差，在区间 $[t_0, t_{\\mathrm{end}}]$ 上求解 $a'(t) = a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$（其中 $H_0 = 1$），获得一个高精度的表格化 $a(t)$。\n- 利用此表格化的 $a(t)$，通过以严格的容差求解系统 $q'(t) = p(t)$ 和 $p'(t) = -\\omega_0^2 a(t)^{-3} q(t)$，计算出 $(q(t),p(t))$ 的高精度参考解。使用相同的 $t_0$ 和 $t_{\\mathrm{end}}$ 以及初始条件 $(q_0,p_0)$。\n\n相位误差度量：\n- 对于每个积分器和 $a(t)$ 策略，使用相应的 $a(t_{\\mathrm{end}})$（对于在线演化，使用演化后的 $a$；对于表格化，使用表格化的 $a(t_{\\mathrm{end}})$）计算最终角度 $\\theta_{\\mathrm{num}}(t_{\\mathrm{end}})$。\n- 使用参考的 $(q,p)$ 和表格化的 $a(t_{\\mathrm{end}})$ 计算参考角度 $\\theta_{\\mathrm{ref}}(t_{\\mathrm{end}})$。\n- 报告绝对的、经过 $2\\pi$ 包裹的差值 $\\Delta \\theta = \\left| \\mathrm{wrap}\\left(\\theta_{\\mathrm{num}} - \\theta_{\\mathrm{ref}}\\right) \\right|$，其中 $\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\bmod 2\\pi) - \\pi$，单位为弧度。\n\n测试套件：\n对于每个测试用例，设置 $\\omega_0 = 1.0$, $H_0 = 1$, $t_0 = 0.0$，以及 $\\Omega_\\Lambda = 1 - \\Omega_m$。程序必须为每个用例计算四个相位误差\n$[\\Delta \\theta_{\\mathrm{KDK,on-the-fly}}, \\Delta \\theta_{\\mathrm{DKD,on-the-fly}}, \\Delta \\theta_{\\mathrm{KDK,tab}}, \\Delta \\theta_{\\mathrm{DKD,tab}}]$。\n使用以下测试用例，时间单位为 $H_0^{-1}$，角度单位为弧度：\n- 用例 1: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.02, 2.0, 0.5, 1.0, 0.0, 0.3)$。\n- 用例 2: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.05, 2.0, 0.5, 1.0, 0.0, 0.3)$。\n- 用例 3: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.02, 2.0, 0.1, 1.0, 0.0, 0.3)$。\n- 用例 4: $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m) = (0.02, 1.0, 0.5, 0.7, 0.2, 0.3)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含按测试用例排序的相位误差结果，每个用例贡献四个值，顺序为 $[\\Delta \\theta_{\\mathrm{KDK,on-the-fly}}, \\Delta \\theta_{\\mathrm{DKD,on-the-fly}}, \\Delta \\theta_{\\mathrm{KDK,tab}}, \\Delta \\theta_{\\mathrm{DKD,tab}}]$，并聚合成一个用方括号括起来的逗号分隔列表。例如，最终输出必须类似于 $[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{2,1},\\dots,r_{4,4}]$，其中每个 $r_{i,j}$ 是一个以弧度为单位的浮点数。", "solution": "该问题要求对一个一维非自治哈密顿系统的四种数值积分方案进行比较，该模型与数值宇宙学相关。哈密顿量被指定为 $H(q,p,a(t)) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega_0^2 a(t)^{-3} q^2$，代表一个谐振子，其势能强度随时间变化，受宇宙尺度因子 $a(t)$ 控制。$a(t)$ 的演化由包含物质和宇宙学常数的平坦宇宙的弗里德曼方程决定。比较的重点是二阶辛蛙跳积分器的两个变体——“踢-漂移-踢”（KDK）和“漂移-踢-漂移”（DKD），每个变体都用两种不同策略来处理随时间变化的尺度因子 $a(t)$：第一种是使用预先计算的高精度 $a(t)$ 表格；第二种是在线演化 $a(t)$，与相空间变量 $(q,p)$ 同步进行。比较的主要度量是在积分结束时的相位误差。\n\n首先，一个高精度的参考解对于量化近似数值方案的误差是必不可少的。这个“基准真相”是通过使用高阶自适应常微分方程（ODE）求解器，分两步建立的。具体来说，是使用 `scipy.integrate.solve_ivp` 中实现的 Dormand-Prince 8(5,3) 方法（`DOP853`），并采用严格的误差容差（例如 $10^{-13}$）。第一步是求解弗里德曼方程，$a'(t) = H_0 a(t) \\sqrt{\\Omega_m a(t)^{-3} + \\Omega_\\Lambda}$，其中 $\\Omega_m + \\Omega_\\Lambda = 1$ 且 $H_0=1$，从初始时间 $t_0$ 和初始尺度因子 $a_0$ 到最终时间 $t_{\\mathrm{end}}$。这会产生尺度因子的连续表示 $a_{\\mathrm{ref}}(t)$。第二步，使用这个参考函数 $a_{\\mathrm{ref}}(t)$ 来求解振子的正则运动方程：\n$$\nq'(t) = \\frac{\\partial H}{\\partial p} = p(t)\n$$\n$$\np'(t) = -\\frac{\\partial H}{\\partial q} = -\\omega_0^2 a(t)^{-3} q(t)\n$$\n这样就得到了参考轨迹 $(q_{\\mathrm{ref}}(t), p_{\\mathrm{ref}}(t))$。最终状态 $(q_{\\mathrm{ref}}(t_{\\mathrm{end}}), p_{\\mathrm{ref}}(t_{\\mathrm{end}}))$ 和相应的尺度因子 $a_{\\mathrm{ref}}(t_{\\mathrm{end}})$ 作为所有比较的基准。\n\n问题的核心在于实现和比较四种基于蛙跳法的方案。蛙跳积分器是一种几何积分器，对于自治哈密顿系统，它是一种辛积分器，以其出色的长期能量和相位守恒特性而闻名。对于非自治可分离哈密顿量 $H=T(p)+V(q,t)$，在一个时间步长 $h$ 内的演化可以形式化地表示为 KDK 的 $\\exp(h(\\hat{T} + \\hat{V}))\\approx \\exp(h\\hat{T}/2)\\exp(h\\hat{V})\\exp(h\\hat{T}/2)$，或 DKD 的 $\\exp(h\\hat{V}/2)\\exp(h\\hat{T})\\exp(h\\hat{V}/2)$，其中 $\\hat{T}$ 和 $\\hat{V}$ 分别是动能和势能部分的刘维尔算符。“漂移”（Drift）操作对应于在 $T(p)$ 下的演化，“踢”（Kick）操作对应于在 $V(q,t)$ 下的演化。\n\n四种方法的具体规格如下：\n1.  **使用表格化 $a(t)$ 的 KDK**：此方案使用预先计算的高精度 $a_{\\mathrm{ref}}(t)$。对于从 $t_n$ 到 $t_{n+1}=t_n+h$ 的一步，KDK 积分器执行一个半步漂移、一个整步踢和另一个半步漂移。其时间对称性表明应在时间中点 $t_{n+1/2} = t_n + h/2$ 评估含时项。\n    $$\n    q_{n+1/2} = q_n + p_n \\frac{h}{2} \\quad (\\text{漂移})\n    $$\n    $$\n    p_{n+1} = p_n - \\omega_0^2 a(t_{n+1/2})^{-3} q_{n+1/2} h \\quad (\\text{踢})\n    $$\n    $$\n    q_{n+1} = q_{n+1/2} + p_{n+1} \\frac{h}{2} \\quad (\\text{漂移})\n    $$\n2.  **使用表格化 $a(t)$ 的 DKD**：此方案也使用 $a_{\\mathrm{ref}}(t)$。DKD 次序包括一个半步踢、一个整步漂移和一个最后的半步踢。这需要在时间步的开始和结束时评估势能。\n    $$\n    p_{n+1/2} = p_n - \\omega_0^2 a(t_n)^{-3} q_n \\frac{h}{2} \\quad (\\text{踢})\n    $$\n    $$\n    q_{n+1} = q_n + p_{n+1/2} h \\quad (\\text{漂移})\n    $$\n    $$\n    p_{n+1} = p_{n+1/2} - \\omega_0^2 a(t_{n+1})^{-3} q_{n+1} \\frac{h}{2} \\quad (\\text{踢})\n    $$\n3.  **在线演化 $a(t)$ 的 KDK**：在这里，$a(t)$ 不是预先计算的，而是与 $(q,p)$ 一起演化。问题指定了一个同步的、二阶类蛙跳法更新 $a(t)$ 的方式。\n    - $(q,p)$ 的前半步漂移：$q_{n+1/2} = q_n + p_n h/2$。\n    - $a$ 的前半步：$a_{n+1/2} = a_n + (h/2) \\, a'(a_n)$。\n    - 使用 $a_{n+1/2}$ 对 $(q,p)$ 进行整步踢：$p_{n+1} = p_n - \\omega_0^2 a_{n+1/2}^{-3} q_{n+1/2} h$。\n    - $(q,p)$ 的后半步漂移：$q_{n+1} = q_{n+1/2} + p_{n+1} h/2$。\n    - $a$ 的后半步：$a_{n+1} = a_{n+1/2} + (h/2) \\, a'(a_{n+1/2})$。\n    该方法耦合了一个用于 $(q,p,a)$ 的二阶积分器，应表现出良好的稳定性。\n4.  **在线演化 $a(t)$ 的 DKD**：在此变体中，$a(t)$ 的更新是一个简单的一阶前向欧拉步：$a_{n+1} = a_n + h \\, a'(a_n)$。这个更新不是时间对称的，并且其阶数低于用于 $(q,p)$ 的 DKD 积分器，这会引入一个额外的、且可能占主导地位的误差和不稳定性来源。完整过程是：\n    - 使用 $a_n$ 对 $(q,p)$ 进行前半步踢：$p_{n+1/2} = p_n - \\omega_0^2 a_n^{-3} q_n h/2$。\n    - 对 $q$ 进行整步漂移：$q_{n+1} = q_n + p_{n+1/2} h$。\n    - 对 $a$ 进行整步欧拉：$a_{n+1} = a_n + h \\, a'(a_n)$。\n    - 使用 $a_{n+1}$ 对 $(q,p)$ 进行后半步踢：$p_{n+1} = p_{n+1/2} - \\omega_0^2 a_{n+1}^{-3} q_{n+1} h/2$。\n\n这些方案的性能通过相位误差来评估。对于一个振子，其状态可以用振幅和相位来描述。我们定义一个瞬时有效频率 $\\omega_{\\mathrm{eff}}(t) = \\omega_0 a(t)^{-3/2}$ 和一个相应的角变量 $\\theta(t) = \\operatorname{atan2}(\\omega_{\\mathrm{eff}}(t) q(t), p(t))$。误差是数值方案得到的最终角度 $\\theta_{\\mathrm{num}}(t_{\\mathrm{end}})$ 与参考角度 $\\theta_{\\mathrm{ref}}(t_{\\mathrm{end}})$ 之间的绝对差。这个差值被包裹到区间 $[-\\pi, \\pi]$ 内，以表示两个最终相位矢量之间的最短角度：$\\Delta \\theta = \\left| \\mathrm{wrap}\\left(\\theta_{\\mathrm{num}} - \\theta_{\\mathrm{ref}}\\right) \\right|$，其中 $\\mathrm{wrap}(\\phi) = ((\\phi + \\pi) \\bmod 2\\pi) - \\pi$。对于在线演化方法，$\\omega_{\\mathrm{eff}}$ 使用该方案演化出的 $a(t_{\\mathrm{end}})$ 值计算，而对于表格化方法，则使用参考值 $a_{\\mathrm{ref}}(t_{\\mathrm{end}})$。\n\n整体算法通过遍历指定的测试用例来执行。对于每个用例，参数 $(h, t_{\\mathrm{end}}, a_0, q_0, p_0, \\Omega_m)$ 用于生成参考解。然后，四种积分器中的每一种都在时间区间 $[t_0, t_{\\mathrm{end}}]$ 上运行。计算并存储每种方法的最终相位误差。最终输出将这些误差聚合成一个单一的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    \n    # -- Test cases as specified in the problem --\n    test_cases = [\n        (0.02, 2.0, 0.5, 1.0, 0.0, 0.3),  # Case 1\n        (0.05, 2.0, 0.5, 1.0, 0.0, 0.3),  # Case 2\n        (0.02, 2.0, 0.1, 1.0, 0.0, 0.3),  # Case 3\n        (0.02, 1.0, 0.5, 0.7, 0.2, 0.3),  # Case 4\n    ]\n\n    # -- Global constants --\n    omega0 = 1.0\n    H0 = 1.0\n    t0 = 0.0\n    \n    # -- Helper Functions --\n\n    def wrap_angle(phi):\n        \"\"\"Wraps an angle to the interval [-pi, pi].\"\"\"\n        return (phi + np.pi) % (2 * np.pi) - np.pi\n\n    def f_a_ode(t, a_vec, H0, Om_m, Om_L):\n        \"\"\"ODE for the scale factor a(t) for solve_ivp.\"\"\"\n        a = a_vec[0]\n        return [H0 * a * np.sqrt(Om_m * a**(-3) + Om_L)]\n    \n    def f_a_prime(a, H0, Om_m, Om_L):\n        \"\"\"Derivative of a(t) for on-the-fly integrators.\"\"\"\n        return H0 * a * np.sqrt(Om_m * a**(-3) + Om_L)\n    \n    def f_qp_ode(t, y, omega0, a_func):\n        \"\"\"ODE system for (q,p) for solve_ivp.\"\"\"\n        q, p = y\n        a_val = a_func(t)[0]\n        dq_dt = p\n        dp_dt = -omega0**2 * a_val**(-3) * q\n        return [dq_dt, dp_dt]\n\n    # -- Integrator Implementations --\n\n    def kdk_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L):\n        t, a, q, p = t0, a0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n        \n        for _ in range(num_steps):\n            q_half = q + p * h_actual / 2.0\n            a_half = a + (h_actual / 2.0) * f_a_prime(a, H0, Om_m, Om_L)\n            p_new = p - omega0**2 * a_half**(-3) * q_half * h_actual\n            q_new = q_half + p_new * h_actual / 2.0\n            a_new = a_half + (h_actual / 2.0) * f_a_prime(a_half, H0, Om_m, Om_L)\n            a, q, p = a_new, q_new, p_new\n        return q, p, a\n\n    def dkd_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L):\n        t, a, q, p = t0, a0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n\n        for _ in range(num_steps):\n            p_half = p - (h_actual / 2.0) * omega0**2 * a**(-3) * q\n            q_new = q + h_actual * p_half\n            a_new = a + h_actual * f_a_prime(a, H0, Om_m, Om_L)\n            p_new = p_half - (h_actual / 2.0) * omega0**2 * a_new**(-3) * q_new\n            a, q, p = a_new, q_new, p_new\n        return q, p, a\n\n    def kdk_tabulated(h, t_end, q0, p0, omega0, a_func):\n        t, q, p = t0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n\n        for _ in range(num_steps):\n            t_mid = t + h_actual / 2.0\n            q_half = q + p * h_actual / 2.0\n            a_mid = a_func(t_mid)\n            p_new = p - omega0**2 * a_mid**(-3) * q_half * h_actual\n            q_new = q_half + p_new * h_actual / 2.0\n            q, p = q_new, p_new\n            t += h_actual\n        return q, p\n\n    def dkd_tabulated(h, t_end, q0, p0, omega0, a_func):\n        t, q, p = t0, q0, p0\n        num_steps = int(round((t_end - t0) / h))\n        h_actual = (t_end - t0) / num_steps\n        \n        for _ in range(num_steps):\n            a_start = a_func(t)\n            p_half = p - (h_actual / 2.0) * omega0**2 * a_start**(-3) * q\n            q_new = q + h_actual * p_half\n            t_next = t + h_actual\n            a_end_step = a_func(t_next)\n            p_new = p_half - (h_actual / 2.0) * omega0**2 * a_end_step**(-3) * q_new\n            q, p = q_new, p_new\n            t = t_next\n        return q, p\n\n    results = []\n    TOL = 1e-13\n\n    for case in test_cases:\n        h, t_end, a0, q0, p0, Om_m = case\n        Om_L = 1.0 - Om_m\n\n        # 1. Generate high-accuracy reference solution\n        sol_a = solve_ivp(\n            f_a_ode, [t0, t_end], [a0], args=(H0, Om_m, Om_L),\n            dense_output=True, method='DOP853', rtol=TOL, atol=TOL\n        )\n        a_ref_func_ivp = sol_a.sol\n        \n        # Create a simple interpolator for leapfrog versions\n        t_dense = np.linspace(t0, t_end, 2000)\n        a_dense = a_ref_func_ivp(t_dense)[0]\n        a_ref_func_interp = interp1d(t_dense, a_dense, kind='cubic', fill_value=\"extrapolate\")\n\n        sol_qp_ref = solve_ivp(\n            f_qp_ode, [t0, t_end], [q0, p0], args=(omega0, a_ref_func_ivp),\n            dense_output=True, method='DOP853', rtol=TOL, atol=TOL\n        )\n        q_ref_end, p_ref_end = sol_qp_ref.y[:, -1]\n        a_ref_end = a_ref_func_ivp(t_end)[0]\n        \n        omega_eff_ref = omega0 * a_ref_end**(-1.5)\n        theta_ref = np.arctan2(omega_eff_ref * q_ref_end, p_ref_end)\n\n        # 2. Run numerical schemes and compute errors\n\n        # KDK, on-the-fly\n        q_kdk_fly, p_kdk_fly, a_kdk_fly = kdk_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L)\n        omega_eff_kdk_fly = omega0 * a_kdk_fly**(-1.5)\n        theta_kdk_fly = np.arctan2(omega_eff_kdk_fly * q_kdk_fly, p_kdk_fly)\n        error_kdk_fly = abs(wrap_angle(theta_kdk_fly - theta_ref))\n        results.append(error_kdk_fly)\n\n        # DKD, on-the-fly\n        q_dkd_fly, p_dkd_fly, a_dkd_fly = dkd_on_fly(h, t_end, a0, q0, p0, H0, omega0, Om_m, Om_L)\n        omega_eff_dkd_fly = omega0 * a_dkd_fly**(-1.5)\n        theta_dkd_fly = np.arctan2(omega_eff_dkd_fly * q_dkd_fly, p_dkd_fly)\n        error_dkd_fly = abs(wrap_angle(theta_dkd_fly - theta_ref))\n        results.append(error_dkd_fly)\n\n        # KDK, tabulated\n        q_kdk_tab, p_kdk_tab = kdk_tabulated(h, t_end, q0, p0, omega0, a_ref_func_interp)\n        omega_eff_kdk_tab = omega0 * a_ref_end**(-1.5)\n        theta_kdk_tab = np.arctan2(omega_eff_kdk_tab * q_kdk_tab, p_kdk_tab)\n        error_kdk_tab = abs(wrap_angle(theta_kdk_tab - theta_ref))\n        results.append(error_kdk_tab)\n        \n        # DKD, tabulated\n        q_dkd_tab, p_dkd_tab = dkd_tabulated(h, t_end, q0, p0, omega0, a_ref_func_interp)\n        omega_eff_dkd_tab = omega0 * a_ref_end**(-1.5)\n        theta_dkd_tab = np.arctan2(omega_eff_dkd_tab * q_dkd_tab, p_dkd_tab)\n        error_dkd_tab = abs(wrap_angle(theta_dkd_tab - theta_ref))\n        results.append(error_dkd_tab)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3493161"}]}