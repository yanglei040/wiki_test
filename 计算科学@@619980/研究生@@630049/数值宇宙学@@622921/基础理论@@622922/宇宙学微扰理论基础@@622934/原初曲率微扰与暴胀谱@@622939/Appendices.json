{"hands_on_practices": [{"introduction": "任何数值演化的第一步都是设定初始条件。对于宇宙学扰动，我们使用“Bunch-Davies真空”作为初始状态，它在形式上定义于无限的过去。本练习旨在探讨一个实际问题：当我们在一个有限但很大的亚视界尺度上开始模拟时，会对结果产生何种影响 [@problem_id:3482615]。这是一个关于数值收敛性和预测稳健性的关键训练，是进行任何严肃宇宙学模拟的基石。", "problem": "您需要量化和校准在数值计算原初曲率功率谱时的精度损失，该损失源于 Mukhanov–Sasaki 模函数在有限的亚视界比 $X_0 \\equiv k/(aH)$（而非精确的无限亚视界极限）下进行初始化。您的任务是编写一个完整的、可运行的程序，对于由 $z''/z(\\tau)$ 给定的一组指定的背景动力学，确定能够使 $P_{\\mathcal{R}}(k)$ 相对于用一个大得多的 $X_{\\mathrm{ref}}$ 计算的高保真参考值的相对误差小于 $0.001$ 的最小 $X_0$。\n\n基本方程和模型假设：\n- 原初曲率扰动模由满足 Mukhanov–Sasaki 方程的 $v_k(\\tau)$ 定义\n$$\nv_k''(\\tau) + \\Big(k^2 - \\frac{z''(\\tau)}{z(\\tau)}\\Big) v_k(\\tau) = 0,\n$$\n其中 $'$ 表示对共形时间 $\\tau$ 的导数。\n- 曲率扰动为 $ \\mathcal{R}_k(\\tau) = v_k(\\tau)/z(\\tau)$，其在冻结时的功率谱为\n$$\nP_{\\mathcal{R}}(k) = \\frac{k^3}{2\\pi^2} \\left| \\mathcal{R}_k(\\tau_{\\mathrm{end}}) \\right|^2.\n$$\n- 亚视界 Bunch–Davies 初始条件施加于一个有限的 $\\tau_0$，此时 $X_0 \\equiv k/(aH)$ 具有指定的值。在深亚视界区，初始条件为\n$$\nv_k(\\tau_0) = \\frac{e^{-i k \\tau_0}}{\\sqrt{2k}}, \\quad v_k'(\\tau_0) = -i \\sqrt{\\frac{k}{2}} e^{-i k \\tau_0}.\n$$\n- 我们采用的单位制中，约化普朗克质量、光速和哈勃常数标度均设为1：$M_{\\mathrm{Pl}} = c = \\hbar = H_0 = 1$。程序中的所有量均为无量纲。\n- 我们假设一个恒定的早期第一慢滚参数 $\\epsilon_0 \\in (0,1)$，以及对于恒定 $\\epsilon_0$ 的共形时间到哈勃穿越的映射关系为\n$$\naH = -\\frac{1}{(1-\\epsilon_0)\\,\\tau}, \\quad \\Rightarrow \\quad \\frac{k}{aH} = -k(1-\\epsilon_0)\\,\\tau.\n$$\n因此，对应于目标 $X_0$ 的初始化时间为\n$$\n\\tau_0 = -\\frac{X_0}{(1-\\epsilon_0)\\,k}.\n$$\n我们在一个后期时间 $\\tau_{\\mathrm{end}}$ 评估功率谱，此时 $X_{\\mathrm{end}} \\equiv k/(aH) = 10^{-3}$，即\n$$\n\\tau_{\\mathrm{end}} = -\\frac{X_{\\mathrm{end}}}{(1-\\epsilon_0)\\,k}.\n$$\n\n背景设定：\n- 定义一个具有恒定 $\\epsilon_0$ 的基准背景，其满足\n$$\na(\\tau) \\propto (-\\tau)^{p}, \\quad p \\equiv -\\frac{1}{1-\\epsilon_0}.\n$$\n- 定义\n$$\nz(\\tau) = (-\\tau)^{p}\\,\\Big(1 + g_b(\\tau)\\Big),\n$$\n其中特征函数 $g_b(\\tau)$ 是在 $\\ln(-\\tau)$ 中呈对数正态形状的局域性凸起，\n$$\ng_b(\\tau) = A \\exp\\!\\left[-\\frac{1}{2}\\left(\\frac{s(\\tau)}{\\sigma}\\right)^2\\right], \\quad s(\\tau) \\equiv \\ln\\!\\left(\\frac{-\\tau}{\\tau_f}\\right),\n$$\n其振幅为 $A$，宽度为 $\\sigma$。特征中心位于 $\\tau_f \\equiv 1/k$，以使特征处于模 $k$ 的视界穿越处附近。\n- 对于此 $z(\\tau)$，可以证明\n$$\n\\frac{z''}{z}(\\tau) = \\frac{1}{\\tau^2}\\left[ p(p-1) + \\frac{g_b}{1+g_b}\\left(\\frac{s^2}{\\sigma^4} - \\frac{1-s}{\\sigma^2} - \\frac{2 p s}{\\sigma^2}\\right) \\right],\n$$\n其中 $g_b = g_b(\\tau)$ 且 $s = s(\\tau)$。当 $A=0$ 时，该式简化为 $\\frac{z''}{z} = \\frac{p(p-1)}{\\tau^2}$。\n\n数值任务：\n- 对于下述每个测试用例，您必须：\n  1. 通过从 $\\tau_{\\mathrm{ref}} = -X_{\\mathrm{ref}}/[(1-\\epsilon_0)k]$（其中 $X_{\\mathrm{ref}} = 2000$）积分到 $\\tau_{\\mathrm{end}}$，计算一个高保真参考值 $P_{\\mathcal{R}}^{\\mathrm{ref}}(k)$。\n  2. 对于一组候选初始化比 $X_0 \\in \\{5, 10, 20, 50, 100, 200, 500, 1000\\}$，计算 $P_{\\mathcal{R}}(k; X_0)$ 和相对误差\n     $$\n     \\Delta(X_0) \\equiv \\left| \\frac{P_{\\mathcal{R}}(k; X_0) - P_{\\mathcal{R}}^{\\mathrm{ref}}(k)}{P_{\\mathcal{R}}^{\\mathrm{ref}}(k)} \\right|.\n     $$\n  3. 确定满足 $\\Delta(X_0)  0.001$ 的最小 $X_0$。如果所有候选值都不满足该标准，则该测试用例返回 $-1$。\n\n科学依据：\n- 从 Mukhanov–Sasaki 方程、曲率扰动及其功率的定义、亚视界 Bunch–Davies 初始条件以及对于恒定 $\\epsilon_0$ 时 $\\tau$ 与 $k/(aH)$ 之间的映射关系出发。\n- 不要使用目标快捷方式；按原样对方程进行二阶积分。\n- 此问题不涉及角度。\n- 如上所述，程序中的所有量均为无量纲。\n\n测试套件：\n为以下四个测试用例提供结果，在所有用例中特征中心均位于 $\\tau_f = 1/k$：\n1. 用例1（基准，理想情况）：$\\epsilon_0 = 0.01$, $A = 0.0$, $\\sigma = 0.5$, $k = 0.1$。\n2. 用例2（视界穿越附近的适度特征）：$\\epsilon_0 = 0.01$, $A = 0.5$, $\\sigma = 0.3$, $k = 0.1$。\n3. 用例3（较大的慢滚参数）：$\\epsilon_0 = 0.10$, $A = 0.0$, $\\sigma = 0.5$, $k = 1.0$。\n4. 用例4（尖锐特征和长波模）：$\\epsilon_0 = 0.01$, $A = 0.8$, $\\sigma = 0.1$, $k = 0.01$。\n\n精度和输出：\n- 您的程序必须使用一个稳健的数值常微分方程求解器，并采用足够严格的容差来解析动力学过程并产生可靠的参考基线。\n- 您的程序应生成单行输出，其中包含每个测试用例的最小 $X_0$，按上述顺序列出，格式为用方括号括起来的逗号分隔列表（例如，`[x1,x2,x3,x4]`）。每个条目必须是来自候选集的一个整数，或者如果没有任何候选值满足 $0.001$ 的要求，则为 $-1$。", "solution": "用户提供的问题陈述已经过分析，并被确定为**有效**。这是一个形式良好、有科学依据的数值宇宙学问题，没有矛盾、歧义或不合理的假设。任务是编写一个程序，量化在有限亚视界尺度（而非渐近过去）初始化模函数演化时，原初功率谱中产生的数值误差。\n\n将通过以下步骤实现解决方案：\n1.  **定义计算框架**：将设计一个名为 `PrimordialSpectrumCalculator` 的类，以封装单个宇宙学模型的参数和物理原理。该类将包含用于计算势能项 $z''/z$、背景函数 $z(\\tau)$ 以及求解 Mukhanov-Sasaki 方程以求得给定初始化尺度的功率谱的方法。\n2.  **实现物理模型**：\n    *   将求解复值的 Mukhanov-Sasaki 方程 $v_k'' + (k^2 - z''/z)v_k = 0$。这个二阶常微分方程 (ODE) 将被转换为状态向量 $Y = [v_k, v_k']$ 的一阶常微分方程组。\n    *   $z''/z(\\tau)$ 项将完全按照问题陈述中的规定实现，它依赖于慢滚参数 $\\epsilon_0$ 和特征参数 $A$ 与 $\\sigma$。\n    *   $v_k(\\tau_0)$ 和 $v_k'(\\tau_0)$ 的 Bunch-Davies 初始条件将在起始共形时间 $\\tau_0$ 应用。\n3.  **数值积分**：\n    *   将使用 `scipy.integrate.solve_ivp` 函数进行数值积分。选择一个高阶方法 (`DOP853`) 和严格的相对和绝对容差 ($10^{-12}$)，以确保 ODE 求解器本身的数值精度相比于所研究的误差源（有限的初始化时间）可以忽略不计。\n    *   对于一组给定的模型参数（$\\epsilon_0, A, \\sigma, k$）和一个初始化比率 $X_0 = k/(aH)|_0$，模函数 $v_k$ 将从 $\\tau_0 = -X_0/((1-\\epsilon_0)k)$ 演化到后期时间 $\\tau_{\\mathrm{end}} = -X_{\\mathrm{end}}/((1-\\epsilon_0)k)$，其中 $X_{\\mathrm{end}} = 10^{-3}$。\n4.  **功率谱计算**：\n    *   在最终时间 $\\tau_{\\mathrm{end}}$，从 ODE 解中提取 $v_k(\\tau_{\\mathrm{end}})$ 的值。\n    *   使用提供的公式计算函数 $z(\\tau_{\\mathrm{end}})$。\n    *   计算曲率扰动 $\\mathcal{R}_k(\\tau_{\\mathrm{end}}) = v_k(\\tau_{\\mathrm{end}})/z(\\tau_{\\mathrm{end}})$。\n    *   然后功率谱计算为 $P_{\\mathcal{R}}(k) = \\frac{k^3}{2\\pi^2} |\\mathcal{R}_k(\\tau_{\\mathrm{end}})|^2$。\n5.  **误差分析与搜索**：\n    *   对于四个测试用例中的每一个，通过将初始化比率设为一个大值 $X_{\\mathrm{ref}} = 2000$ 来计算一个高保真参考功率谱 $P_{\\mathcal{R}}^{\\mathrm{ref}}$。\n    *   然后，程序将遍历排序后的候选初始化比率列表 $X_0 \\in \\{5, 10, 20, 50, 100, 200, 500, 1000\\}$。\n    *   对于每个候选值 $X_0$，计算功率谱 $P_{\\mathcal{R}}(k; X_0)$ 并评估相对误差 $\\Delta(X_0) = |(P_{\\mathcal{R}}(k; X_0) - P_{\\mathcal{R}}^{\\mathrm{ref}})/P_{\\mathcal{R}}^{\\mathrm{ref}}|$。\n    *   将候选集中第一个（因此也是最小的）满足 $\\Delta(X_0)  0.001$ 的 $X_0$ 值记录为该测试用例的结果。\n    *   如果没有候选值 $X_0$ 满足精度要求，则记录一个值 $-1$。\n6.  **输出生成**：四个测试用例的最终结果将被编译成一个单一字符串，格式为用方括号括起来的逗号分隔的整数列表，如规范所示。\n\n实现将构建在一个单一的 `solve()` 函数内，以确保其自包含并遵守指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    class PrimordialSpectrumCalculator:\n        \"\"\"\n        A class to encapsulate the physics and numerical methods for computing\n        the primordial power spectrum for a given cosmological model.\n        \"\"\"\n        def __init__(self, epsilon_0, A, sigma, k):\n            self.epsilon_0 = float(epsilon_0)\n            self.A = float(A)\n            self.sigma = float(sigma)\n            self.k = float(k)\n\n            # Derived parameters from the model\n            self.p = -1.0 / (1.0 - self.epsilon_0)\n            self.tau_f = 1.0 / self.k\n            self.X_end = 1e-3\n            self.tau_end = -self.X_end / ((1.0 - self.epsilon_0) * self.k)\n\n        def _zpp_over_z(self, tau):\n            \"\"\"Computes the z''/z term in the Mukhanov-Sasaki equation.\"\"\"\n            if self.A == 0.0:\n                return (self.p * (self.p - 1.0)) / (tau**2)\n\n            s = np.log(-tau / self.tau_f)\n            g_b = self.A * np.exp(-0.5 * (s / self.sigma)**2)\n            \n            term1 = self.p * (self.p - 1.0)\n            \n            # This term can be zero if g_b is zero (as tau - -inf)\n            if g_b   1e-100: # Practically zero\n                 g_ratio_term = 0.0\n            else:\n                g_ratio = g_b / (1.0 + g_b)\n                bracket_term = (s**2 / self.sigma**4) - ((1.0 - s) / self.sigma**2) - (2.0 * self.p * s / self.sigma**2)\n                g_ratio_term = g_ratio * bracket_term\n            \n            potential = (1.0 / tau**2) * (term1 + g_ratio_term)\n            return potential\n\n        def _z_func(self, tau):\n            \"\"\"Computes the value of the background function z(tau).\"\"\"\n            if self.A == 0.0:\n                return (-tau)**self.p\n\n            s = np.log(-tau / self.tau_f)\n            g_b = self.A * np.exp(-0.5 * (s / self.sigma)**2)\n            return (-tau)**self.p * (1.0 + g_b)\n\n        def _ode_system(self, tau, y):\n            \"\"\"The system of first-order ODEs for [v, v'].\"\"\"\n            v, v_prime = y\n            potential_val = self._zpp_over_z(tau)\n            \n            # v'' = -(k^2 - z''/z) * v\n            dv_prime_dtau = -(self.k**2 - potential_val) * v\n            dv_dtau = v_prime\n            \n            return np.array([dv_dtau, dv_prime_dtau], dtype=complex)\n\n        def compute_power_spectrum(self, X_0):\n            \"\"\"\n            Solves the Mukhanov-Sasaki equation and computes the power spectrum\n            for a given initialization ratio X_0.\n            \"\"\"\n            tau_0 = -X_0 / ((1.0 - self.epsilon_0) * self.k)\n            \n            # Bunch-Davies initial conditions for the mode function\n            v0 = np.exp(-1j * self.k * tau_0) / np.sqrt(2.0 * self.k)\n            v0_prime = -1j * np.sqrt(self.k / 2.0) * np.exp(-1j * self.k * tau_0)\n            y0 = np.array([v0, v0_prime], dtype=complex)\n\n            t_span = [tau_0, self.tau_end]\n            \n            # Use a robust, high-precision ODE solver\n            sol = solve_ivp(\n                self._ode_system,\n                t_span,\n                y0,\n                method='DOP853',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            # Extract final value of the mode function\n            v_end = sol.y[0, -1]\n            \n            z_at_end = self._z_func(self.tau_end)\n            \n            R_k_end = v_end / z_at_end\n            P_R = (self.k**3) / (2.0 * np.pi**2) * np.abs(R_k_end)**2\n            \n            return P_R\n            \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon_0, A, sigma, k)\n        (0.01, 0.0, 0.5, 0.1),   # Case 1\n        (0.01, 0.5, 0.3, 0.1),   # Case 2\n        (0.10, 0.0, 0.5, 1.0),   # Case 3\n        (0.01, 0.8, 0.1, 0.01),  # Case 4\n    ]\n\n    # Constants for the numerical task\n    X_ref = 2000.0\n    candidate_X0s = [5, 10, 20, 50, 100, 200, 500, 1000]\n    error_threshold = 0.001\n    \n    results = []\n    for case in test_cases:\n        epsilon_0, A, sigma, k = case\n        calculator = PrimordialSpectrumCalculator(epsilon_0, A, sigma, k)\n\n        # 1. Compute the high-fidelity reference value\n        p_r_ref = calculator.compute_power_spectrum(X_ref)\n\n        # 2. Search for the minimal X_0 that satisfies the error criterion\n        min_X0 = -1\n        for X0_candidate in candidate_X0s:\n            p_r_candidate = calculator.compute_power_spectrum(float(X0_candidate))\n            \n            if p_r_ref == 0:\n                # This case is physically unlikely and indicates a potential issue,\n                # but we handle it robustly.\n                error = np.inf if p_r_candidate != 0 else 0.0\n            else:\n                error = np.abs((p_r_candidate - p_r_ref) / p_r_ref)\n\n            if error   error_threshold:\n                min_X0 = X0_candidate\n                break\n        \n        results.append(min_X0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3482615"}, {"introduction": "设定好初始条件后，我们便可以追踪一个扰动模从亚视界尺度拉伸至超视界尺度的完整演化过程。本练习将模拟共动曲率扰动 $\\mathcal{R}_k$ 的演化，并检验其在最简单模型中著名的超视界守恒性，同时也会探索这种守恒性被破坏的情形 [@problem_id:3482626]。这是计算最终功率谱的核心环节，揭示了暴胀如何将微观量子涨落“冻结”为宏观的密度扰动。", "problem": "您的任务是构建一个数值实验，以演化在两种情景下共动曲率微扰模式 $ {\\cal R}_k $ 在暴胀期间穿越视界的过程：一种是绝热单场情形，另一种是受双场启发的轻微非绝热情形。目标是使用一个科学上合理的、能够捕捉视界出口附近和之后主导物理过程的玩具模型，来量化 $ {\\cal R}_k $ 守恒的偏离程度，并将其表示为共动波数 $ k $ 的函数。\n\n使用以下基本基础：\n\n- 在准德西特背景下，正则归一化变量 $ u_k = z \\, {\\cal R}_k $ 在共形时间 $ \\eta $ 中的 Mukhanov–Sasaki 方程为\n$$\nu_k'' + \\left(c_s^2 k^2 - \\frac{z''}{z}\\right) u_k = 0 ,\n$$\n其中撇号表示对 $ \\eta $ 的微分。对于具有常数慢滚参数 $ \\epsilon \\ll 1 $ 和常数哈勃率 $ H $ 的正则单场慢滚暴胀，采用 $ c_s = 1 $ 和 $ a(\\eta) = -\\frac{1}{H \\eta} $（其中 $ \\eta  0 $）。在约化普朗克单位（约化普朗克质量为一）下，令\n$$\nz(\\eta) = a(\\eta) \\sqrt{2 \\epsilon}, \\quad \\text{因此} \\quad \\frac{z''}{z} = \\frac{2}{\\eta^2}.\n$$\n\n- 在视界深处（$ k |\\eta| \\gg 1 $），在 Bunch–Davies 真空中初始化该模式：\n$$\nu_k(\\eta_i) \\approx \\frac{e^{-i k \\eta_i}}{\\sqrt{2 k}}, \\quad u_k'(\\eta_i) \\approx -i k \\, u_k(\\eta_i),\n$$\n在满足 $ k |\\eta_i| \\gg 1 $ 的某个合适的早期初始共形时间 $ \\eta_i $。\n\n- 视界穿越发生在 $ k = a H $ 时，对于所采用的背景，这发生在 $ \\eta_\\text{cross} = -\\frac{1}{k} $。\n\n- 对于绝热情形，使用齐次的 Mukhanov–Sasaki 方程演化 $ u_k $，计算 $ {\\cal R}_k = u_k / z $，并量化从视界穿越 $ \\eta_\\text{cross} $ 到视界出口后的某个固定晚期时间 $ \\eta_\\text{late} $ 的振幅分数变化：\n$$\n\\Delta_{\\text{ad}}(k) = \\frac{\\left|{\\cal R}_k(\\eta_\\text{late})\\right| - \\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}{\\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}.\n$$\n\n- 对于轻微非绝热情形，由于场空间中的恒定转向率，对一个小的超视界从等曲率到曲率的转移进行建模。如上计算出 $ \\left|{\\cal R}_k(\\eta_\\text{cross})\\right| $ 后，假设在视界穿越时有一个等曲率振幅 $ S_k(N_\\text{cross}) = \\sigma \\left|{\\cal R}_k(\\eta_\\text{cross})\\right| $，其中 $ \\sigma \\ll 1 $ 是一个小比率。对于 $ N $（e-折叠数），使用一个标准的超视界唯象耦合\n$$\n\\frac{d {\\cal R}_k}{dN} \\approx 2 \\Theta \\, S_k, \\quad \\frac{d S_k}{dN} \\approx -\\mu \\, S_k ,\n$$\n其中 $ \\Theta $ 是恒定转向率（以哈勃率为单位），$ \\mu  0 $ 是熵衰减率。在从 $ \\eta_\\text{cross} $ 到 $ \\eta_\\text{late} $ 的 $ \\Delta N $ e-折叠期间，这会产生一个振幅的附加变化\n$$\n\\delta {\\cal R}_k \\approx \\frac{2 \\Theta}{\\mu} S_k(N_\\text{cross}) \\left(1 - e^{-\\mu \\Delta N}\\right),\n$$\n对于所采用的背景，其中 $ \\Delta N = \\ln\\left(\\frac{a(\\eta_\\text{late})}{a(\\eta_\\text{cross})}\\right) = \\ln\\left(\\frac{|\\eta_\\text{cross}|}{|\\eta_\\text{late}|}\\right) $。将非绝热情形的分数偏差定义为\n$$\n\\Delta_{\\text{nonad}}(k) = \\frac{\\left(\\left|{\\cal R}_k(\\eta_\\text{late})\\right| + \\delta {\\cal R}_k\\right) - \\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}{\\left|{\\cal R}_k(\\eta_\\text{cross})\\right|}.\n$$\n\n数值和建模说明：\n\n- 完全在约化普朗克单位下进行计算，设 $ H = 1 $，因此所有量都是无量纲的。\n- 使用 $ \\epsilon = 0.01 $，$ \\Theta = 0.01 $，$ \\mu = 0.2 $，$ \\sigma = 0.05 $。\n- 对于下面测试套件中的每个共动波数 $ k $，将 Mukhanov–Sasaki 方程从 $ \\eta_i = -\\frac{50}{k} $ 积分到 $ \\eta_\\text{cross} = -\\frac{1}{k} $，然后继续到 $ \\eta_\\text{late} = -10^{-3} $。在 $ \\eta_i $ 处使用上述初始条件。按照上面的定义计算 $ \\Delta_{\\text{ad}}(k) $ 和 $ \\Delta_{\\text{nonad}}(k) $。\n- 如果出现任何角度，都必须以弧度为单位。然而，所要求的输出是无量纲的浮点数；最终答案中不需要物理单位。\n\n测试套件：\n\n- 使用 $ k \\in \\{0.05, 0.5, 5.0, 50.0\\} $，它探测了晚期穿越、典型穿越和早期穿越，覆盖了非常小的 $ k $ 处的边界和非常大的 $ k $ 处的边缘。\n\n最终输出规格：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[\\Delta_{\\text{ad}}(0.05), \\Delta_{\\text{nonad}}(0.05), \\Delta_{\\text{ad}}(0.5), \\Delta_{\\text{nonad}}(0.5), \\Delta_{\\text{ad}}(5.0), \\Delta_{\\text{nonad}}(5.0), \\Delta_{\\text{ad}}(50.0), \\Delta_{\\text{nonad}}(50.0)]。\n$$\n每个条目必须是一个浮点数。", "solution": "用户提供了一个有效的、适定的数值宇宙学问题。该问题在科学上基于标准的暴胀微扰理论，并提供了一整套方程、参数和数值计算指令。任务是计算共动曲率微扰 $\\mathcal{R}_k$ 在一系列共动波数 $k$ 下的分数变化，涵盖两种情景：标准的绝热演化和一个唯象的非绝热情况。\n\n解决此问题的算法设计如下：\n\n首先，我们处理正则归一化变量 $u_k = z \\mathcal{R}_k$ 的演化。其动力学由 Mukhanov-Sasaki 方程决定，对于给定的准德西特背景，该方程简化为关于共形时间 $\\eta$ 的二阶线性常微分方程（ODE）：\n$$\nu_k'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_k = 0\n$$\n这里，撇号表示对 $\\eta$ 的微分。变量 $u_k(\\eta)$ 是复数。为了数值求解这个方程，我们将 $u_k$ 分解为其实部和虚部，$u_k(\\eta) = u_{k,R}(\\eta) + i u_{k,I}(\\eta)$。由于常微分方程的系数是实数，实部和虚部解耦，各自独立地满足相同的常微分方程：\n$$\nu_{k,R}'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_{k,R} = 0\n$$\n$$\nu_{k,I}'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_{k,I} = 0\n$$\n这两个二阶常微分方程中的每一个都被转换为一个由两个一阶常微分方程组成的系统，以便进行数值积分。对于满足该方程的通用实函数 $y(\\eta)$，我们定义一个状态向量 $\\mathbf{y}(\\eta) = [y(\\eta), y'(\\eta)]^T$。那么，这个一阶常微分方程系统就是：\n$$\n\\frac{d\\mathbf{y}}{d\\eta} = \\begin{bmatrix} y' \\\\ y'' \\end{bmatrix} = \\begin{bmatrix} y' \\\\ -\\left(k^2 - \\frac{2}{\\eta^2}\\right) y \\end{bmatrix}\n$$\n问题指定了 Bunch-Davies 初始条件，设置在视界深处的初始时间 $\\eta_i = -50/k$。这个条件对应于 $k|\\eta_i| = 50 \\gg 1$。初始状态由下式给出：\n$$\nu_k(\\eta_i) = \\frac{e^{-i k \\eta_i}}{\\sqrt{2 k}} = \\frac{e^{i 50}}{\\sqrt{2 k}}, \\quad u_k'(\\eta_i) = -i k u_k(\\eta_i)\n$$\n将这些分解为实部和虚部，为这两个常微分方程系统提供了初始条件：\n$$\nu_{k,R}(\\eta_i) = \\frac{\\cos(50)}{\\sqrt{2k}}, \\quad u_{k,R}'(\\eta_i) = \\frac{k\\sin(50)}{\\sqrt{2k}}\n$$\n$$\nu_{k,I}(\\eta_i) = \\frac{\\sin(50)}{\\sqrt{2k}}, \\quad u_{k,I}'(\\eta_i) = -\\frac{k\\cos(50)}{\\sqrt{2k}}\n$$\n对于测试套件中的每个波数 $k$，我们将这两个系统从 $\\eta_i = -50/k$ 积分到一个晚期时间 $\\eta_{\\text{late}} = -10^{-3}$，对于所有指定的 $k$ 来说，这都远在视界穿越之后。数值积分使用一个高精度的自适应步长求解器进行，具体是 `scipy.integrate.solve_ivp`。我们要求解器在两个特定点上提供解：视界穿越时 $\\eta_{\\text{cross}} = -1/k$ 和最终时间 $\\eta_{\\text{late}}$。\n\n根据 $u_{k,R}$ 和 $u_{k,I}$ 的数值解，我们重构了复模式函数 $u_k$ 及其在 $\\eta_{\\text{cross}}$ 和 $\\eta_{\\text{late}}$ 的模 $|u_k| = \\sqrt{u_{k,R}^2 + u_{k,I}^2}$。\n\n然后通过其定义 $\\mathcal{R}_k = u_k / z$ 恢复共动曲率微扰 $\\mathcal{R}_k$。泵浦场 $z(\\eta)$ 由 $z(\\eta) = a(\\eta)\\sqrt{2\\epsilon} = -\\frac{\\sqrt{2\\epsilon}}{H\\eta}$ 给出。在 $H=1$ 的情况下，其模为 $|z(\\eta)| = \\frac{\\sqrt{2\\epsilon}}{|\\eta|}$。因此，曲率微扰的模为 $|\\mathcal{R}_k(\\eta)| = |u_k(\\eta)| / |z(\\eta)|$。\n\n计算出 $|\\mathcal{R}_k(\\eta_{\\text{cross}})|$ 和 $|\\mathcal{R}_k(\\eta_{\\text{late}})|$ 后，我们计算绝热情况下的分数变化：\n$$\n\\Delta_{\\text{ad}}(k) = \\frac{|\\mathcal{R}_k(\\eta_{\\text{late}})| - |\\mathcal{R}_k(\\eta_{\\text{cross}})|}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|}\n$$\n对于非绝热情况，一个超视界贡献 $\\delta \\mathcal{R}_k$ 被加到 $\\mathcal{R}_k$ 的振幅上。这个贡献模拟了从一个等曲率模式的转移，并按如下方式计算：\n$$\n\\delta{\\cal R}_k = \\frac{2 \\Theta \\sigma}{\\mu} |\\mathcal{R}_k(\\eta_{\\text{cross}})| \\left(1 - e^{-\\mu \\Delta N}\\right)\n$$\n其中视界穿越和晚期时间之间的 e-折叠数是 $\\Delta N = \\ln(|\\eta_{\\text{cross}}|/|\\eta_{\\text{late}}|) = \\ln(\\frac{1/k}{10^{-3}}) = \\ln(1000/k)$。给定的参数为 $\\Theta=0.01$，$\\sigma=0.05$ 和 $\\mu=0.2$。那么，非绝热情况的分数偏差定义为：\n$$\n\\Delta_{\\text{nonad}}(k) = \\frac{\\left(|\\mathcal{R}_k(\\eta_{\\text{late}})| + \\delta \\mathcal{R}_k\\right) - |\\mathcal{R}_k(\\eta_{\\text{cross}})|}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|} = \\Delta_{\\text{ad}}(k) + \\frac{\\delta \\mathcal{R}_k}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|}\n$$\n第二项简化为 $\\frac{2 \\Theta \\sigma}{\\mu} (1 - e^{-\\mu \\Delta N})$。\n\n将此过程系统地应用于测试套件中的每个 $k$ 值 $\\{0.05, 0.5, 5.0, 50.0\\}$，然后将得到的 $\\Delta_{\\text{ad}}(k)$ 和 $\\Delta_{\\text{nonad}}(k)$ 值收集并格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the fractional change in the comoving curvature perturbation R_k\n    for both adiabatic and non-adiabatic scenarios across a range of wavenumbers k.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, Theta, mu, sigma, H, wavenumbers)\n        (0.01, 0.01, 0.2, 0.05, 1.0, [0.05, 0.5, 5.0, 50.0])\n    ]\n\n    for case in test_cases:\n        epsilon, Theta, mu, sigma, H, k_values = case\n        \n        results = []\n\n        # Pre-compute constants to optimize the loop\n        sqrt_2_epsilon = np.sqrt(2.0 * epsilon)\n        cos50 = np.cos(50.0)\n        sin50 = np.sin(50.0)\n        non_ad_coeff = (2.0 * Theta * sigma) / mu\n\n        def mukhanov_sasaki_system(eta, y, k):\n            \"\"\"\n            Defines the system of first-order ODEs for the Mukhanov-Sasaki equation.\n            y[0] = u_k, y[1] = u_k'\n            The equation is u_k'' + (k^2 - 2/eta^2) * u_k = 0\n            \"\"\"\n            potential = k**2 - 2.0 / eta**2\n            return [y[1], -potential * y[0]]\n\n        for k in k_values:\n            # 1. Define integration and evaluation time points\n            eta_i = -50.0 / k\n            eta_cross = -1.0 / k\n            eta_late = -1.0e-3\n            \n            # 2. Set up initial conditions based on the Bunch-Davies vacuum approximation\n            # The normalization factor 1/sqrt(2k)\n            norm = 1.0 / np.sqrt(2.0 * k)\n            \n            # Real part of u_k and its derivative\n            uR_i = cos50 * norm\n            uR_prime_i = k * sin50 * norm\n            y0_R = [uR_i, uR_prime_i]\n\n            # Imaginary part of u_k and its derivative\n            uI_i = sin50 * norm\n            uI_prime_i = -k * cos50 * norm\n            y0_I = [uI_i, uI_prime_i]\n\n            # 3. Points in time where the solution is to be evaluated\n            t_eval_points = [eta_cross, eta_late]\n\n            # 4. Numerically integrate the ODE for both real and imaginary parts\n            sol_R = solve_ivp(\n                fun=lambda t, y: mukhanov_sasaki_system(t, y, k),\n                t_span=(eta_i, eta_late),\n                y0=y0_R,\n                t_eval=t_eval_points,\n                args=(k,),\n                method='RK45',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            sol_I = solve_ivp(\n                fun=lambda t, y: mukhanov_sasaki_system(t, y, k),\n                t_span=(eta_i, eta_late),\n                y0=y0_I,\n                t_eval=t_eval_points,\n                args=(k,),\n                method='RK45',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            # 5. Extract the solutions at eta_cross and eta_late\n            uR_at_eval_points = sol_R.y[0]\n            uI_at_eval_points = sol_I.y[0]\n\n            # 6. Reconstruct the magnitude of u_k\n            u_mag_cross = np.sqrt(uR_at_eval_points[0]**2 + uI_at_eval_points[0]**2)\n            u_mag_late = np.sqrt(uR_at_eval_points[1]**2 + uI_at_eval_points[1]**2)\n\n            # 7. Calculate the magnitude of R_k = u_k / z\n            # |z(eta)| = sqrt(2*epsilon) / |eta| since H=1\n            z_mag_cross = sqrt_2_epsilon / abs(eta_cross)\n            z_mag_late = sqrt_2_epsilon / abs(eta_late)\n            \n            R_k_mag_cross = u_mag_cross / z_mag_cross\n            R_k_mag_late = u_mag_late / z_mag_late\n            \n            # 8. Compute the fractional change for the adiabatic case\n            delta_ad = (R_k_mag_late - R_k_mag_cross) / R_k_mag_cross\n            results.append(delta_ad)\n\n            # 9. Compute the fractional change for the non-adiabatic case\n            # The number of e-folds between horizon crossing and late time\n            delta_N = np.log(abs(eta_cross) / abs(eta_late))\n            \n            # The super-horizon contribution to R_k, normalized by |R_k(cross)|\n            non_ad_term = non_ad_coeff * (1.0 - np.exp(-mu * delta_N))\n            \n            delta_nonad = delta_ad + non_ad_term\n            results.append(delta_nonad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3482626"}, {"introduction": "扰动模的演化本质上是一个量子过程，可以类比于在时变背景下的粒子创生。这项高级实践将暴胀势中的一个“特征”建模为一次“量子猝灭”，并将由此产生的模动力学与Bogoliubov系数的计算联系起来 [@problem_id:3482635]。这个练习提供了一种强大的物理直觉，将原初谱的生成与弯曲时空中的量子场论这一迷人领域深刻地联系在一起。", "problem": "考虑单场暴胀中标量曲率扰动的正则量子化，其中 Mukhanov 变量 $u_k(\\tau)$ 服从以下线性微分方程\n$$\nu_k''(\\tau) + \\left(k^2 - \\frac{z''(\\tau)}{z(\\tau)}\\right) u_k(\\tau) = 0,\n$$\n式中 $\\tau  0$ 为共形时间，$k$ 为共动波数，$z(\\tau) \\equiv a(\\tau) \\sqrt{2 \\epsilon(\\tau)}\\, M_{\\mathrm{pl}}$，其中 $a(\\tau)$ 为标度因子，$\\epsilon(\\tau)$ 为第一慢滚参数，$M_{\\mathrm{pl}}$ 为约化普朗克质量。在具有恒定哈勃参数 $H$ 和恒定慢滚参数 $\\epsilon$ 的精确 de Sitter 时空中，背景满足 $a(\\tau) = -1/(H \\tau)$，并且在没有特征的情况下，$\\epsilon(\\tau)$ 是恒定的，因此 $z(\\tau) \\propto 1/\\tau$ 且 $z''(\\tau)/z(\\tau) = 2/\\tau^2$。然而，假设 $z(\\tau)$ 被一个模拟量子淬火的局域光滑特征所调制：\n$$\nz(\\tau) = \\frac{C}{\\tau} \\, f(\\tau), \\quad f(\\tau) = 1 + A \\exp\\left(-\\frac{(\\tau - \\tau_0)^2}{2 \\sigma^2}\\right),\n$$\n其中 $C \\equiv \\sqrt{2 \\epsilon}\\, M_{\\mathrm{pl}}/H$ 为常数，$A$ 为振幅，$\\tau_0  0$ 为中心时间，$\\sigma  0$ 为宽度。这个淬火通过以下方式改变了线性振子 $u_k$ 的有效频率：\n$$\n\\frac{z''(\\tau)}{z(\\tau)} = \\frac{f''(\\tau)}{f(\\tau)} - \\frac{2 f'(\\tau)}{f(\\tau)} \\frac{1}{\\tau} + \\frac{2}{\\tau^2}.\n$$\n初始态是 Bunch–Davies 真空，定义在遥远的过去 $k^2 \\gg z''/z$ 处，这给出了次视界条件\n$$\nu_k(\\tau_i) = \\frac{e^{- i k \\tau_i}}{\\sqrt{2 k}}, \\qquad u_k'(\\tau_i) = - i k \\, u_k(\\tau_i),\n$$\n于某个足够早的负共形时间 $\\tau_i$。\n\n您的任务是：\n1. 实现背景 $z(\\tau)$，并根据给定的 $f(\\tau)$、$f'(\\tau)$ 和 $f''(\\tau)$ 解析地计算 $\\frac{z''(\\tau)}{z(\\tau)}$。\n2. 对于给定集合中的每个共动波数 $k$，对 Mukhanov–Sasaki 方程中的 $u_k(\\tau)$ 进行数值积分，从 $\\tau = \\tau_i$ 积分到晚期时间 $\\tau = \\tau_f$，其中 $|k \\tau_f| \\ll 1$，以使曲率扰动冻结。\n3. 在淬火后的次视界窗口（时间 $\\tau  \\tau_0$ 满足 $k |\\tau| \\gg 1$ 且特征被指数抑制），将动力学视为一个近似的含时谐振子，并通过将数值积分得到的 $u_k(\\tau)$ 投影到适用于 $k^2 \\gg z''/z$ 的平面波基 $\\{e^{- i k \\tau}, e^{+ i k \\tau}\\}$ 上，用最小二乘法提取 Bogoliubov 系数 $(\\alpha_k, \\beta_k)$。使用与 Bunch–Davies 模函数一致的归一化。报告激发幅度 $|\\beta_k|^2$，以便与凝聚态物质中的量子淬火动力学进行概念性比较。\n4. 计算曲率扰动 $\\mathcal{R}_k(\\tau) = u_k(\\tau)/z(\\tau)$ 和晚期无量纲曲率功率谱\n$$\nP_{\\mathcal{R}}(k) = \\frac{k^3}{2 \\pi^2} \\left| \\frac{u_k(\\tau_f)}{z(\\tau_f)} \\right|^2,\n$$\n并与没有淬火（$A = 0$）的光滑基线进行比较。通过均方根分数偏差\n$$\n\\Delta_{\\mathrm{rms}} = \\left[ \\frac{1}{N_k} \\sum_{i=1}^{N_k} \\left( \\frac{P_{\\mathcal{R}}^{\\mathrm{quench}}(k_i)}{P_{\\mathcal{R}}^{(0)}(k_i)} - 1 \\right)^2 \\right]^{1/2},\n$$\n来量化淬火引起的振荡调制，其中 $P_{\\mathcal{R}}^{(0)}(k)$ 是在 $A=0$ 及相同的 $(\\tau_i, \\tau_f)$ 和 $k$ 集合下计算的，而 $N_k$ 是集合中波数的数量。\n\n使用 $H = 1$ 和 $M_{\\mathrm{pl}} = 1$ 的单位制。所有时间 $\\tau$ 以哈勃参数的倒数 $H^{-1}$ 为单位，所有波数 $k$ 以 $H$ 为单位，最终报告的 $\\Delta_{\\mathrm{rms}}$ 值为无量纲浮点数。\n\n测试套件：\n- 在波数集合 $k \\in \\{0.01, 0.02, 0.035, 0.05, 0.065, 0.08, 0.1\\}$ 上积分，固定 $\\tau_i = -200$ 和 $\\tau_f = -0.1$。\n- 使用恒定的慢滚参数 $\\epsilon = 0.01$。\n- 评估四组淬火参数集：\n  (i) $(A, \\sigma, \\tau_0) = (0.2, 1.5, -50)$，\n  (ii) $(A, \\sigma, \\tau_0) = (0.0, 1.5, -50)$，\n  (iii) $(A, \\sigma, \\tau_0) = (0.5, 0.5, -30)$，\n  (iv) $(A, \\sigma, \\tau_0) = (-0.2, 2.0, -80)$。\n- 对于每组参数集，计算在指定 $k$ 值范围内的 $\\Delta_{\\mathrm{rms}}$。预期的边界行为是，情况 (ii) 会产生一个接近零的值，因为没有淬火，而情况 (i)、(iii) 和 (iv) 会产生非零值，反映了 $P_{\\mathcal{R}}(k)$ 的激发和振荡。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含上述四个测试用例的四个 $\\Delta_{\\mathrm{rms}}$ 结果，形式为用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。每个条目必须是一个浮点数。不应打印任何其他文本。", "solution": "我们从单场暴胀中曲率扰动的正则作用量开始，\n$$\nS = \\frac{1}{2} \\int d\\tau\\, d^3 x \\left[ (u')^2 - (\\nabla u)^2 + \\frac{z''}{z} u^2 \\right],\n$$\n其中 $u(\\tau, \\mathbf{x})$ 是 Mukhanov 变量，$z(\\tau) \\equiv a(\\tau) \\sqrt{2 \\epsilon(\\tau)}\\, M_{\\mathrm{pl}}$。对该作用量进行变分可得到傅里叶模式 $u_k(\\tau)$ 的运动方程，\n$$\nu_k''(\\tau) + \\left(k^2 - \\frac{z''(\\tau)}{z(\\tau)} \\right) u_k(\\tau) = 0.\n$$\n这是一个具有含时有效频率平方的线性振子\n$$\n\\omega_k^2(\\tau) \\equiv k^2 - \\frac{z''(\\tau)}{z(\\tau)}.\n$$\n在具有恒定慢滚参数 $\\epsilon$ 的精确 de Sitter 时空中，背景满足 $a(\\tau) = -1/(H \\tau)$ 且 $z(\\tau) \\propto 1/\\tau$，从而得到 $\\frac{z''}{z} = \\frac{2}{\\tau^2}$。Bunch–Davies 真空是在遥远的过去 $k^2 \\gg z''/z$ 处选择的唯一绝热真空，它给出了初始条件\n$$\nu_k(\\tau_i) = \\frac{e^{- i k \\tau_i}}{\\sqrt{2 k}}, \\qquad u_k'(\\tau_i) = - i k \\, u_k(\\tau_i),\n$$\n对于足够负的 $\\tau_i$。\n\n我们在 $z(\\tau)$ 中引入一个局域调制，\n$$\nz(\\tau) = \\frac{C}{\\tau} \\, f(\\tau), \\quad f(\\tau) = 1 + A \\exp\\left(-\\frac{(\\tau - \\tau_0)^2}{2 \\sigma^2}\\right),\n$$\n其中 $C = \\sqrt{2 \\epsilon}\\, M_{\\mathrm{pl}}/H$。该调制的动机是暴胀背景对慢滚的瞬时偏离，在振子语言中，它构成了有效频率的一次量子淬火。为了自洽地计算 $\\frac{z''}{z}$，我们对 $z(\\tau)$ 进行解析微分：\n$$\nz'(\\tau) = C \\left( \\frac{f'(\\tau)}{\\tau} - \\frac{f(\\tau)}{\\tau^2} \\right), \\quad\nz''(\\tau) = C \\left( \\frac{f''(\\tau)}{\\tau} - \\frac{2 f'(\\tau)}{\\tau^2} + \\frac{2 f(\\tau)}{\\tau^3} \\right).\n$$\n因此，\n$$\n\\frac{z''(\\tau)}{z(\\tau)} = \\frac{f''(\\tau)}{f(\\tau)} - \\frac{2 f'(\\tau)}{f(\\tau)} \\frac{1}{\\tau} + \\frac{2}{\\tau^2}.\n$$\n设 $g(\\tau) \\equiv \\exp\\left(-\\frac{(\\tau - \\tau_0)^2}{2 \\sigma^2}\\right)$，我们有 $f(\\tau) = 1 + A g(\\tau)$，$f'(\\tau) = A g'(\\tau)$，$f''(\\tau) = A g''(\\tau)$，以及\n$$\ng'(\\tau) = - \\frac{\\tau - \\tau_0}{\\sigma^2} g(\\tau), \\qquad g''(\\tau) = \\left( \\frac{(\\tau - \\tau_0)^2}{\\sigma^4} - \\frac{1}{\\sigma^2} \\right) g(\\tau).\n$$\n\n数值方案：\n1. 固定 $H = 1$ 和 $M_{\\mathrm{pl}} = 1$，并选择常数 $\\epsilon = 0.01$，因此 $C = \\sqrt{2 \\epsilon} = \\sqrt{0.02}$。时间和波数分别以 $H^{-1}$ 和 $H$ 为单位。\n2. 对于每个测试用例 $(A, \\sigma, \\tau_0)$ 和集合 $k \\in \\{0.01, 0.02, 0.035, 0.05, 0.065, 0.08, 0.1\\}$ 中的每个波数 $k$，将 Mukhanov–Sasaki 方程从 $\\tau = \\tau_i = -200$ 积分到 $\\tau = \\tau_f = -0.1$。我们通过将二阶复常微分方程重写为 $(\\Re u_k, \\Im u_k, \\Re u_k', \\Im u_k')$ 的一阶系统来演化一个实部和虚部的实数系统。有效势通过上面 $\\frac{z''}{z}$ 的解析表达式计算。\n3. 为了提取 Bogoliubov 系数 $(\\alpha_k, \\beta_k)$，选择一个时间窗口 $\\tau \\in [\\tau_{\\mathrm{start}}, \\tau_{\\mathrm{end}}]$，其中 $\\tau_{\\mathrm{start}} = \\tau_0 + 3 \\sigma$，且 $\\tau_{\\mathrm{end}} = \\min(\\tau_0 + 10 \\sigma, -2)$，确保我们已经远过特征区域，但对于适中的 $k$ 仍安全地处于次视界机制中。在此窗口内，由于 $k^2 \\gg z''/z$ 意味着 $\\omega_k(\\tau) \\approx k$，且绝热基近似为平面波，模近似服从\n$$\nu_k(\\tau) \\approx \\frac{1}{\\sqrt{2 k}} \\left( \\alpha_k e^{- i k \\tau} + \\beta_k e^{+ i k \\tau} \\right),\n$$\n我们在窗口中的多个点上对 $u_k(\\tau)$ 进行采样，并通过复数最小二乘投影计算 $(\\alpha_k, \\beta_k)$：相对于复数 $\\alpha_k$ 和 $\\beta_k$ 最小化 $\\sum_j \\left| u_k(\\tau_j) \\sqrt{2 k} - \\alpha_k e^{- i k \\tau_j} - \\beta_k e^{+ i k \\tau_j} \\right|^2$。激发数是 $|\\beta_k|^2$，这与凝聚态淬火动力学中的情况类似，其中振子频率的突然变化会产生激发对。\n4. 评估晚期曲率扰动 $\\mathcal{R}_k(\\tau_f) = u_k(\\tau_f)/z(\\tau_f)$ 和曲率功率谱\n$$\nP_{\\mathcal{R}}(k) = \\frac{k^3}{2 \\pi^2} \\left| \\frac{u_k(\\tau_f)}{z(\\tau_f)} \\right|^2,\n$$\n针对淬火情况和基线 $A = 0$ 情况（使用相同的 $k$ 集合和 $(\\tau_i, \\tau_f)$）。计算均方根分数偏差\n$$\n\\Delta_{\\mathrm{rms}} = \\left[ \\frac{1}{N_k} \\sum_{i=1}^{N_k} \\left( \\frac{P_{\\mathcal{R}}^{\\mathrm{quench}}(k_i)}{P_{\\mathcal{R}}^{(0)}(k_i)} - 1 \\right)^2 \\right]^{1/2}.\n$$\n\n科学推理与预期：\n- 函数 $\\frac{z''}{z}$ 在模方程中充当含时势。局域调制对应于有效频率 $\\omega_k(\\tau)$ 的瞬时变化，类似于凝聚态物质中的量子淬火，其中参数的突然改变会激发模式的分布。在暴胀背景下，这会在正频和负频分量之间产生混合，由 Bogoliubov 系数 $(\\alpha_k, \\beta_k)$ 参数化。在视界深处，绝热基可以很好地用频率为常数 $k$ 的平面波来近似，这为最小二乘提取法提供了依据。\n- 曲率功率谱 $P_{\\mathcal{R}}(k)$ 在视界穿越后是恒定的。一个瞬时特征会在 $P_{\\mathcal{R}}(k)$ 中作为 $k$ 的函数印上振荡调制，因为由非零 $\\beta_k$ 引起的相位和振幅混合随 $k$ 而变化。因此，$A \\neq 0$ 的情况会表现出非零的 $\\Delta_{\\mathrm{rms}}$，而光滑情况 $A = 0$ 则会得到 $\\beta_k \\approx 0$ 和 $\\Delta_{\\mathrm{rms}} \\approx 0$。\n- 边缘情况：一个窄而强的特征（小 $\\sigma$，大 $|A|$）会更显著地激发更宽范围的 $k$，从而增加 $\\Delta_{\\mathrm{rms}}$。一个在遥远过去（大 $|\\tau_0|$）或振幅较温和的特征会产生较小的调制，因为模在 $k^2 \\gg z''/z$ 时经历淬火，从而最小化了混合。\n\n算法摘要：\n- 解析地实现 $f(\\tau)$、$f'(\\tau)$、$f''(\\tau)$、$z(\\tau)$ 和 $z''/z$。\n- 使用初始 Bunch–Davies 条件，对每个 $k$ 将 $(\\Re u_k, \\Im u_k, \\Re u_k', \\Im u_k')$ 的一阶系统从 $\\tau_i$ 积分到 $\\tau_f$。\n- 在淬火后的次视界窗口中，通过将 $u_k(\\tau)$ 投影到 $\\{e^{- i k \\tau}, e^{+ i k \\tau}\\}$ 上，用最小二乘法提取 $(\\alpha_k, \\beta_k)$。\n- 计算每个测试用例在 $\\tau_f$ 时的 $P_{\\mathcal{R}}(k)$ 以及相对于光滑基线的 $\\Delta_{\\mathrm{rms}}$。\n- 以指定的单行格式输出四个 $\\Delta_{\\mathrm{rms}}$ 值。\n\n所有输出均为无量纲浮点数。时间单位为 $H^{-1}$，波数单位为 $H$。最终格式是单行文本，包含一个用方括号括起来的逗号分隔列表，其中按给定测试用例的顺序包含四个 $\\Delta_{\\mathrm{rms}}$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Constants (units: H = 1, M_pl = 1)\nH = 1.0\nMpl = 1.0\nepsilon = 0.01\nC = np.sqrt(2.0 * epsilon) * Mpl / H\n\n# Time domain for integration\ntau_i = -200.0\ntau_f = -0.1\n\n# Wavenumber set\nk_values = np.array([0.01, 0.02, 0.035, 0.05, 0.065, 0.08, 0.1], dtype=float)\n\ndef f_gauss(tau, A, sigma, tau0):\n    \"\"\"Gaussian modulation f(τ) = 1 + A * exp(-(τ-τ0)^2 / (2 σ^2)).\"\"\"\n    if A == 0.0:\n        return 1.0, 0.0, 0.0\n    g = np.exp(-((tau - tau0) ** 2) / (2.0 * sigma ** 2))\n    f = 1.0 + A * g\n    # Derivatives of g:\n    gp = - (tau - tau0) / (sigma ** 2) * g\n    gpp = ((tau - tau0) ** 2 / (sigma ** 4) - 1.0 / (sigma ** 2)) * g\n    # Derivatives of f:\n    fp = A * gp\n    fpp = A * gpp\n    return f, fp, fpp\n\ndef z_and_V(tau, A, sigma, tau0):\n    \"\"\"Return z(τ) and V(τ) = z''/z.\"\"\"\n    f, fp, fpp = f_gauss(tau, A, sigma, tau0)\n    # z(τ) = C * f / τ\n    z = C * f / tau\n    # V = z''/z = f''/f - 2 (f'/f)/τ + 2/τ^2\n    if A == 0.0:\n        V = 2.0 / (tau ** 2)\n    else:\n        # Handle small numerical issues if f ~ 0: clamp f\n        f_safe = np.where(np.abs(f)  1e-12, 1e-12, f)\n        V = (fpp / f_safe) - 2.0 * (fp / f_safe) / tau + 2.0 / (tau ** 2)\n    return z, V\n\ndef mode_rhs(tau, y, k, A, sigma, tau0):\n    \"\"\"\n    First-order real system for u'' + (k^2 - V) u = 0.\n    y = [u_re, u_im, v_re, v_im] with v = u'.\n    \"\"\"\n    u_re, u_im, v_re, v_im = y\n    # Compute V = z''/z\n    _, V = z_and_V(tau, A, sigma, tau0)\n    # u'' = - (k^2 - V) u\n    coeff = -(k ** 2 - V)\n    du_re = v_re\n    du_im = v_im\n    dv_re = coeff * u_re\n    dv_im = coeff * u_im\n    return np.array([du_re, du_im, dv_re, dv_im], dtype=float)\n\ndef bd_initial_conditions(k):\n    \"\"\"Bunch–Davies initial conditions at tau_i.\"\"\"\n    phase = -k * tau_i\n    u0 = np.exp(1j * phase) / np.sqrt(2.0 * k)\n    up0 = -1j * k * u0\n    return np.array([u0.real, u0.imag, up0.real, up0.imag], dtype=float)\n\ndef integrate_mode(k, A, sigma, tau0):\n    \"\"\"Integrate the mode equation and return solution with dense output.\"\"\"\n    y0 = bd_initial_conditions(k)\n    # Integrate with dense output for sampling later\n    sol = solve_ivp(\n        fun=lambda t, y: mode_rhs(t, y, k, A, sigma, tau0),\n        t_span=(tau_i, tau_f),\n        y0=y0,\n        method='RK45',\n        rtol=1e-8,\n        atol=1e-9,\n        dense_output=True,\n    )\n    return sol\n\ndef compute_power_spectrum(sol, A, sigma, tau0, k):\n    \"\"\"Compute P_R(k) at tau_f for given solution and parameters.\"\"\"\n    Yf = sol.sol(tau_f)\n    u_f = Yf[0] + 1j * Yf[1]\n    z_f, _ = z_and_V(tau_f, A, sigma, tau0)\n    R_f = u_f / z_f\n    P_R = (k ** 3) / (2.0 * np.pi ** 2) * (np.abs(R_f) ** 2)\n    return P_R\n\ndef compute_baseline_P0(k_values):\n    \"\"\"Compute baseline P_R(k) with A = 0.\"\"\"\n    P0 = []\n    for k in k_values:\n        sol0 = integrate_mode(k, A=0.0, sigma=1.0, tau0=-50.0)  # sigma, tau0 irrelevant when A=0\n        P0.append(compute_power_spectrum(sol0, A=0.0, sigma=1.0, tau0=-50.0, k=k))\n    return np.array(P0, dtype=float)\n\ndef run_case(A, sigma, tau0, P0, k_values):\n    \"\"\"Run a quench case and compute RMS fractional deviation Δ_rms.\"\"\"\n    P = []\n    for k in k_values:\n        sol = integrate_mode(k, A=A, sigma=sigma, tau0=tau0)\n        Pk = compute_power_spectrum(sol, A=A, sigma=sigma, tau0=tau0, k=k)\n        P.append(Pk)\n    P = np.array(P, dtype=float)\n    \n    # Avoid division by zero if P0 is zero\n    safe_P0 = np.where(P0 == 0, 1.0, P0)\n    ratio = P / safe_P0\n    \n    delta_rms = np.sqrt(np.mean((ratio - 1.0) ** 2))\n    \n    return float(delta_rms)\n\ndef solve():\n    # Define test cases\n    test_cases = [\n        (0.2, 1.5, -50.0),   # (i) moderate amplitude, moderate width\n        (0.0, 1.5, -50.0),   # (ii) baseline: no quench\n        (0.5, 0.5, -30.0),   # (iii) strong, narrow quench earlier\n        (-0.2, 2.0, -80.0),  # (iv) negative amplitude, wide, far past\n    ]\n\n    # Baseline P0 computed once for the given k_values\n    P0 = compute_baseline_P0(k_values)\n\n    results = []\n    for (A, sigma, tau0) in test_cases:\n        delta_rms = run_case(A, sigma, tau0, P0, k_values)\n        results.append(delta_rms)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3482635"}]}