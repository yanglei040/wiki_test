{"hands_on_practices": [{"introduction": "横向无迹（TT）投影算符是分离宇宙学扰动中张量部分（例如引力波）的关键数学工具。本练习旨在引导您在傅里叶空间中推导此投影算符，并通过编写一个数值单元测试来验证其核心代数性质——幂等性与正交性。掌握TT投影算符的实现是进行完整SVT分解的基础 [@problem_id:3485224]。", "problem": "你需要实现并单元测试在数值宇宙学中用于线性微扰的标量、矢量、张量分解的横向无迹 (TT) 投影算符。工作在具有欧几里得度规的平直背景下的三维傅里叶空间中。考虑一个实对称二阶张量 $S_{ij}$，它代表波矢为 $k_i \\neq 0$ 的微扰模式的傅里叶振幅。TT 子空间由横向性和无迹性约束定义，即 $k_i T_{ij} = 0$ 和 $\\delta^{ij} T_{ij} = 0$，其中 $\\delta_{ij}$ 是克罗内克δ。TT 投影算符是作用于对称张量向量空间上的唯一线性自伴映射，它使 TT 子空间保持不变，并相对于弗罗贝尼乌斯内积湮灭其正交补。\n\n从此背景下的第一性原理出发，即：\n- 平直背景上线性微扰的傅里叶空间表示，\n- 通过亥姆霍兹定理对矢量进行横向和纵向分解的定义，\n- TT 子空间由 $k_i T_{ij} = 0$ 和 $\\delta^{ij} T_{ij} = 0$ 表征，\n推导出一个作用于对称张量上的、显式的、算法上可实现的 TT 投影算符表达式。使用此表达式实现一个函数，该函数将任意实对称 $3\\times 3$ 张量 $S_{ij}$ 映射到其对应的 TT 投影张量 $T^{\\mathrm{TT}}_{ij}$，给定一个非零波矢 $k_i$。\n\n然后，设计一个单元测试，对几个非平凡的测试用例，在数值上以机器精度验证以下两个属性：\n- 幂等性：应用投影算符两次与应用一次产生相同的结果，即 $T^{\\mathrm{TT}}_{ij} - \\left(T^{\\mathrm{TT}}\\right)^{\\mathrm{TT}}_{ij}$ 的弗罗贝尼乌斯范数相对于弗罗贝尼乌斯范数尺度而言可以忽略不计。\n- 投影的正交性：TT 分量相对于弗罗贝尼乌斯内积与残差正交，即 $\\sum_{i,j} T^{\\mathrm{TT}}_{ij}\\,\\left(S_{ij} - T^{\\mathrm{TT}}_{ij}\\right)$ 相对于范数之积可以忽略不计。\n\n对于数值比较，在以下缩放意义上使用 $10^{-12}$ 的容差：对任意张量 $A_{ij}$，定义弗罗贝尼乌斯范数 $\\|A\\| = \\sqrt{\\sum_{i,j} A_{ij}^2}$。如果 $\\|T^{\\mathrm{TT}} - \\left(T^{\\mathrm{TT}}\\right)^{\\mathrm{TT}}\\| \\le 10^{-12} \\max\\{1,\\|T^{\\mathrm{TT}}\\|\\}$，则声明幂等性测试通过；如果 $\\left|\\sum_{i,j} T^{\\mathrm{TT}}_{ij}\\,\\left(S_{ij} - T^{\\mathrm{TT}}_{ij}\\right)\\right| \\le 10^{-12} \\max\\{1,\\|T^{\\mathrm{TT}}\\|\\,\\|S - T^{\\mathrm{TT}}\\|\\}$，则声明正交性测试通过。\n\n你的程序必须：\n- 从一个固定的随机种子生成一个实对称输入张量 $S_{ij}$，以确保测试是确定性的。\n- 对每个测试用例，构造 $S_{ij}$ 和 $k_i$，计算 TT 投影，并执行上述两个测试。\n- 为每个测试用例返回一个布尔值，当且仅当幂等性和正交性检查都通过时，该值为真。\n\n测试套件（每个用例是一个由波矢 $k_i$ 和一个随机种子组成的对）：\n- 用例 1：$k = (1,2,3)$，种子 $42$。\n- 用例 2：$k = (0,0,1)$，种子 $7$。\n- 用例 3：$k = (-3.5, 2.25, 0.5)$，种子 $123456$。\n- 用例 4：$k = (10^3, -2\\times 10^3, 3\\times 10^3)$，种子 $2023$。\n\n所有量都是无量纲的，因此不需要物理单位。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。每个结果必须是一个布尔值，对应一个测试用例的综合通过/失败状态（幂等性和正交性），顺序与上述测试套件一致。", "solution": "在三维傅里叶空间中为对称二阶张量构造横向无迹 (TT) 投影算符是宇宙学微扰理论中的一个标准步骤。给定一个与波矢 $k_i \\neq 0$ 相关联的实对称张量 $S_{ij}$。目标是推导并实现一个投影算符，将 $S_{ij}$ 映射到其 TT 分量 $T^{\\mathrm{TT}}_{ij}$，该分量满足横向性条件 $k^i T^{\\mathrm{TT}}_{ij} = 0$ 和无迹性条件 $\\delta^{ij} T^{\\mathrm{TT}}_{ij} = 0$。由于我们在具有欧几里得度规的平直背景上，我们可以使用克罗内克δ $\\delta_{ij}$，无需区分协变和逆变指标。\n\n我们的推导过程是构造性的。我们将首先定义一个强制实现横向性的投影算符，然后对其进行修改以强制实现无迹性，同时确保横向性属性得以保留。\n\n设 $k_i$ 为波矢。其模为 $k = \\sqrt{k_j k_j}$。我们定义波矢方向上的单位向量为 $\\hat{k}_i = k_i/k$。我们构造的基本构件是空间投影算符 $P_{ij}$，它将任意向量投影到与 $\\hat{k}_i$ 正交的平面上。其定义为：\n$$\nP_{ij} = \\delta_{ij} - \\hat{k}_i \\hat{k}_j\n$$\n该算符是幂等的（$P_{ik} P_{kj} = P_{ij}$）且自伴。它会湮灭任何平行于 $\\hat{k}_i$ 的向量，因为 $P_{ij} \\hat{k}_j = (\\delta_{ij} - \\hat{k}_i \\hat{k}_j) \\hat{k}_j = \\hat{k}_i - \\hat{k}_i (\\hat{k}_j \\hat{k}_j) = \\hat{k}_i - \\hat{k}_i = 0$。因此，对于任意张量 $A_{...j...}$，与 $k^j$ 缩并等价于与 $k \\hat{k}^j$ 缩并。所以，$k^j P_{ji} = 0$。\n\n为使一个普通对称张量 $S_{ij}$ 横向，我们必须确保其与 $k_i$ 的任何缩并都为零。我们可以通过将投影算符 $P_{ij}$ 应用于 $S_{ij}$ 的两个指标来实现这一点：\n$$\nS'_{ij} = P_{ik} S_{kl} P_{lj}\n$$\n由于 $P_{ij}$ 是对称的，$P_{lj} = P_{jl}$。在矩阵表示法中，这对应于 $S' = PSP$。所得张量 $S'_{ij}$ 对两个指标都是横向的。例如，与 $k^i$ 缩并：\n$$\nk^i S'_{ij} = k^i P_{ik} S_{kl} P_{lj} = (k \\hat{k}^i) P_{ik} S_{kl} P_{lj} = 0\n$$\n因为 $k^i P_{ik} = 0$。如果 $S_{ij}$ 是对称的，那么张量 $S'_{ij}$ 也是对称的。\n\n张量 $S'_{ij}$ 是横向的，但通常不是无迹的。我们必须在保持其横向性的同时移除它的迹。让我们计算 $S'_{ij}$ 的迹：\n$$\n\\text{Tr}(S') = \\delta^{ij} S'_{ij} = \\delta^{ij} P_{ik} S_{kl} P_{lj} = P_{ik} S_{kl} P_{ki} = P_{ik} P_{il} S_{kl}\n$$\n我们可以简化 $P_{ik} P_{il}$ 项：\n$$\nP_{ik} P_{il} = (\\delta_{ik} - \\hat{k}_i \\hat{k}_k)(\\delta_{il} - \\hat{k}_i \\hat{k}_l) = \\delta_{kl} - \\hat{k}_i \\hat{k}_k \\delta_{il} - \\hat{k}_i \\hat{k}_l \\delta_{ik} + \\hat{k}_i \\hat{k}_k \\hat{k}_i \\hat{k}_l = \\delta_{kl} - \\hat{k}_l \\hat{k}_k - \\hat{k}_k \\hat{k}_l + (\\hat{k}_i \\hat{k}_i)\\hat{k}_k \\hat{k}_l\n$$\n由于 $\\hat{k}_i \\hat{k}_i = 1$，这可以简化为：\n$$\nP_{ik} P_{il} = \\delta_{kl} - \\hat{k}_k \\hat{k}_l = P_{kl}\n$$\n因此，$S'_{ij}$ 的迹为 $\\text{Tr}(S') = P_{kl} S_{kl}$。\n\n要从 $S'_{ij}$ 生成一个无迹张量，我们可以减去一个与横向投影算符 $P_{ij}$ 本身成比例的张量。对于某个标量 $C$，形式为 $C \\cdot P_{ij}$ 的张量是横向的（$k^i P_{ij} = 0$），因此从 $S'_{ij}$ 中减去它会保持横向性。设最终的 TT 张量为：\n$$\nT^{\\mathrm{TT}}_{ij} = S'_{ij} - C \\cdot P_{ij}\n$$\n我们通过要求 $T^{\\mathrm{TT}}_{ij}$ 的迹为零来确定常数 $C$：\n$$\n\\delta^{ij} T^{\\mathrm{TT}}_{ij} = \\delta^{ij} S'_{ij} - C \\cdot \\delta^{ij} P_{ij} = 0\n$$\n投影算符 $P_{ij}$ 的迹为 $\\delta^{ij} P_{ij} = \\delta^{ij}(\\delta_{ij} - \\hat{k}_i \\hat{k}_j) = \\delta^{ij}\\delta_{ij} - \\hat{k}_i \\hat{k}_i = 3 - 1 = 2$。\n代入此结果，我们得到：\n$$\n\\text{Tr}(S') - 2C = 0 \\implies C = \\frac{1}{2}\\text{Tr}(S') = \\frac{1}{2} P_{kl} S_{kl}\n$$\n将所有项代回，我们得到 TT 投影张量的最终显式表达式：\n$$\nT^{\\mathrm{TT}}_{ij} = P_{ik} S_{kl} P_{lj} - \\frac{1}{2} P_{ij} (P_{ab} S_{ab})\n$$\n此表达式定义了 TT 投影算符在对称张量 $S_{ij}$ 上的作用。我们可以将投影算符 $\\Lambda_{ij}^{~kl}$ 写为：\n$$\n\\Lambda_{ij}^{~kl} = P_{im} P_{jn} \\delta_m^k \\delta_n^l - \\frac{1}{2} P_{ij} P^{kl}\n$$\n这里默认为重复指标求和。这是一种更形式化的表示，但分步过程对于实现更为直接。\n\n算法实现将遵循以下步骤：\n1.  给定波矢 $k_i$，计算其模 $k$ 和单位向量 $\\hat{k}_i = k_i/k$。\n2.  构造横向投影矩阵 $P_{ij} = \\delta_{ij} - \\hat{k}_i \\hat{k}_j$。\n3.  给定输入对称张量 $S_{ij}$，计算中间横向张量 $S'_{ij} = P_{ik} S_{km} P_{mj}$。这是一个矩阵乘积 $S' = PSP$。\n4.  计算标量迹项 $s' = P_{ab} S_{ab}$。这是弗罗贝尼乌斯内积 $\\langle P, S \\rangle_F = \\text{Tr}(P^T S) = \\text{Tr}(PS)$。\n5.  构造最终的横向无迹张量 $T^{\\mathrm{TT}}_{ij} = S'_{ij} - \\frac{1}{2} s' P_{ij}$。\n\n单元测试将数值上验证此投影算符的两个基本性质。首先是幂等性，即对一个已经投影过的张量再次应用投影算符，其结果保持不变：$\\Pi(\\Pi(S)) = \\Pi(S)$。其次是正交性，即投影后的张量 $T^{\\mathrm{TT}}_{ij}$ 与残差 $S_{ij} - T^{\\mathrm{TT}}_{ij}$ 就弗罗贝尼乌斯内积而言是正交的：$\\langle T^{\\mathrm{TT}}, S - T^{\\mathrm{TT}} \\rangle_F = 0$。这些测试根据正交投影算符的定义属性来确认实现的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef project_tt(S, k):\n    \"\"\"\n    Computes the transverse-traceless (TT) projection of a symmetric 3x3 tensor.\n\n    Args:\n        S (np.ndarray): A real, symmetric 3x3 numpy array.\n        k (np.ndarray): A 3-element numpy array representing the wavevector.\n\n    Returns:\n        np.ndarray: The TT projection of S, a 3x3 numpy array.\n    \"\"\"\n    if np.all(k == 0):\n        raise ValueError(\"Wavevector k must be non-zero.\")\n\n    # 1. Compute unit vector k_hat\n    k_norm = np.linalg.norm(k)\n    k_hat = k / k_norm\n\n    # 2. Construct the transverse projector matrix P\n    # P_ij = delta_ij - k_hat_i * k_hat_j\n    P = np.eye(3) - np.outer(k_hat, k_hat)\n\n    # 3. Compute the intermediate transverse tensor S_prime = P S P\n    # Since P is symmetric (P.T = P), P S P.T = P S P\n    S_prime = P @ S @ P\n\n    # 4. Compute the scalar trace term s_prime = Tr(P S)\n    # This is equivalent to sum_{a,b} P_ab * S_ab\n    s_prime_scalar = np.trace(P @ S)\n\n    # 5. Construct the final TT tensor T_tt = S_prime - 0.5 * s_prime * P\n    T_tt = S_prime - 0.5 * s_prime_scalar * P\n    \n    return T_tt\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the TT projector.\n    \"\"\"\n    # Test suite: (k_vector, random_seed)\n    test_cases = [\n        ((1, 2, 3), 42),\n        ((0, 0, 1), 7),\n        ((-3.5, 2.25, 0.5), 123456),\n        ((1e3, -2e3, 3e3), 2023),\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for k_val, seed in test_cases:\n        # Set up the deterministic environment for the test case\n        rng = np.random.default_rng(seed)\n        k = np.array(k_val, dtype=np.float64)\n\n        # Generate a real, symmetric 3x3 tensor S\n        A = rng.random((3, 3))\n        S = (A + A.T) / 2.0\n\n        # Compute the TT projection\n        T_tt = project_tt(S, k)\n\n        # --- Idempotency Test ---\n        # T_tt_tt should be equal to T_tt\n        T_tt_tt = project_tt(T_tt, k)\n        \n        diff_idem = T_tt - T_tt_tt\n        norm_diff_idem = np.linalg.norm(diff_idem, 'fro')\n        norm_T_tt = np.linalg.norm(T_tt, 'fro')\n        \n        idempotency_passed = norm_diff_idem = tolerance * max(1.0, norm_T_tt)\n\n        # --- Orthogonality Test ---\n        # T_tt should be orthogonal to the residual (S - T_tt)\n        residual = S - T_tt\n        \n        # Frobenius inner product: sum(A_ij * B_ij)\n        inner_product = np.sum(T_tt * residual)\n        norm_residual = np.linalg.norm(residual, 'fro')\n\n        orthogonality_passed = abs(inner_product) = tolerance * max(1.0, norm_T_tt * norm_residual)\n        \n        # The test case passes if and only if both checks pass\n        results.append(idempotency_passed and orthogonality_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\".replace('True', 'true').replace('False', 'false'))\n\nsolve()\n```", "id": "3485224"}, {"introduction": "在学习如何分解一个混合场之前，从零开始构建纯分量场是一种极具启发性的方法。本练习将指导您生成在统计上纯粹的标量、螺线矢量和横向无迹张量高斯随机场 [@problem_id:3485117]。通过验证这些场的纯度，您将加深对傅里叶空间中各个分量定义的理解，为后续的分解任务打下坚实的直观基础。", "problem": "考虑一个边长为 $L$ 的三维周期性立方体区域，其中场在均匀的 $N \\times N \\times N$ 网格上通过其离散傅里叶变换表示。您将构建三个统计上独立的高斯随机场，它们分别是纯标量、纯无散矢量和纯横向无迹（TT, transverse-traceless）张量分量，然后使用傅里叶空间投影算子和范数比率来验证它们的纯度。\n\n基本基础：\n- 离散傅里叶表示使用波矢量 $\\mathbf{k} = (k_x,k_y,k_z)$，其分量 $k_\\alpha \\in \\frac{2\\pi}{L}\\mathbb{Z}$ 与离散快速傅里叶变换一致。对于周期性晶格上的任何实场，其傅里叶系数满足厄米共轭对称性。\n- 傅里叶空间中矢量场的 Helmholtz 分解使用纵向投影算子 $L_{ij}(\\mathbf{k}) = \\frac{k_i k_j}{k^2}$ 和螺线管（无散）投影算子 $\\Lambda_{ij}(\\mathbf{k}) = \\delta_{ij} - \\frac{k_i k_j}{k^2}$，其中 $k^2 \\equiv \\mathbf{k}\\cdot\\mathbf{k} \\neq 0$。\n- 傅里叶空间中对称二阶场 $h_{ij}$ 的横向无迹投影算子由下式给出\n$$\nP^{\\mathrm{TT}}_{ij,kl}(\\mathbf{k}) = \\Lambda_{ik}(\\mathbf{k})\\Lambda_{jl}(\\mathbf{k}) - \\tfrac{1}{2}\\Lambda_{ij}(\\mathbf{k})\\Lambda_{kl}(\\mathbf{k})\n$$\n其中 $k^2 \\neq 0$。\n- 具有功率谱 $P(\\mathbf{k})$ 的高斯随机场可以通过在傅里叶空间中对高斯白噪声场应用一个与 $\\sqrt{P(\\mathbf{k})}$ 成正比的谱滤波器来生成。实现系综具有预设的功率谱。\n\n您的任务：\n1. 通过在傅里叶空间中用预设的标量谱 $P_\\Phi(k)$ 过滤高斯白噪声来生成一个标量势场 $\\Phi(\\mathbf{x})$，并验证其梯度是纯纵向的（即其螺线管分量为零）。\n2. 通过在傅里叶空间中用螺线管投影算子 $\\Lambda_{ij}(\\mathbf{k})$ 投影高斯白噪声矢量来生成一个无散矢量场 $\\mathbf{v}(\\mathbf{x})$，并验证其纵向分量为零。\n3. 生成一个对称张量场 $h_{ij}(\\mathbf{x})$，使用 $P^{\\mathrm{TT}}_{ij,kl}(\\mathbf{k})$ 将其投影到横向无迹，并验证其横向性和无迹性。此外，通过将 TT 投影算子重新应用于 $h_{ij}$ 并量化差异来验证一致性。\n\n验证指标：\n- 将 $\\Phi$ 的傅里叶空间梯度定义为 $g_i(\\mathbf{k}) = i k_i \\Phi(\\mathbf{k})$。\n- 任何矢量 $w_i(\\mathbf{k})$ 的螺线管分量为 $w^{\\mathrm{sol}}_i(\\mathbf{k}) = \\Lambda_{ij}(\\mathbf{k}) w_j(\\mathbf{k})$，纵向分量为 $w^{\\mathrm{long}}_i(\\mathbf{k}) = L_{ij}(\\mathbf{k}) w_j(\\mathbf{k})$。\n- 对于张量 $h_{ij}$，将其散度定义为 $d_j(\\mathbf{k}) = k_i h_{ij}(\\mathbf{k})$，其迹定义为 $\\mathrm{tr}(\\mathbf{k}) = h_{ii}(\\mathbf{k})$。\n- 对于网格上的任何复数场 $X$，令 $\\|X\\|^2$ 表示其模的平方在所有网格点（以及分量索引，如有）上的总和。在下面的所有比率中，将 $\\mathbf{k}=\\mathbf{0}$ 模式从任何需要除以 $k^2$ 的计算中排除；需要时，将相应的投影模式设置为零。\n\n为每个测试用例计算以下五个纯度比率：\n- $R_{\\mathrm{scalar}} = \\dfrac{\\| \\Lambda \\cdot \\mathbf{g} \\|^2}{\\| \\mathbf{g} \\|^2}$。\n- $R_{\\mathrm{vector}} = \\dfrac{\\| L \\cdot \\mathbf{V} \\|^2}{\\| \\mathbf{V} \\|^2}$，其中 $\\mathbf{V}(\\mathbf{k})$ 是生成的 $\\mathbf{v}(\\mathbf{x})$ 的傅里叶变换。\n- $R_{\\mathrm{div}} = \\dfrac{\\| \\mathbf{d} \\|^2}{\\| h \\|^2}$ 用于张量。\n- $R_{\\mathrm{trace}} = \\dfrac{\\| \\mathrm{tr} \\|^2}{\\| h \\|^2}$ 用于张量。\n- $R_{\\mathrm{TT}} = \\dfrac{\\| h - P^{\\mathrm{TT}}[h] \\|^2}{\\| h \\|^2}$ 用于张量，其中 $P^{\\mathrm{TT}}[h]$ 是在傅里叶空间中逐模式应用于 $h$ 的 TT 投影。\n\n谱形状：\n在整个过程中使用无量纲单位。对于每个测试用例，使用以下依赖于 $k=\\|\\mathbf{k}\\|$ 的无量纲谱：\n- 标量势谱 $P_\\Phi(k) = A \\big/ \\big( 1 + (k/k_0)^4 \\big)$。\n- 矢量场谱 $S_v(k) = B \\exp\\big( - (k/k_0)^2 \\big)$。\n- 张量场谱 $S_h(k) = C \\,(k/k_0)^2 \\exp\\big( - (k/k_0)^2 \\big)$。\n\n算法约束：\n- 在实空间中生成高斯白噪声场，并使用快速傅里叶变换自动获得具有厄米共轭对称性的傅里叶系数。在傅里叶空间中应用适当的投影算子和 $\\sqrt{\\text{spectrum}}$ 滤波器，如果需要，再变换回实空间。所有验证必须在傅里叶空间中执行，以避免离散化歧义。\n- 在 $\\mathbf{k}=\\mathbf{0}$ 处，投影后将矢量和张量傅里叶系数设置为零，因为投影算子在该点未定义。\n\n测试套件：\n提供三个具有不同参数和随机种子的测试用例。为每个案例按如下方式指定 $N$、$L$、$A$、$B$、$C$ 和 $k_0$：\n- 案例 1：$N=16$, $L=1$, $A=1.0$, $B=1.0$, $C=1.0$, $k_0=12.0$, 随机种子 $s_1=12345$。\n- 案例 2：$N=8$, $L=1$, $A=1.0$, $B=0.5$, $C=1.5$, $k_0=9.0$, 随机种子 $s_2=54321$。\n- 案例 3：$N=20$, $L=1$, $A=2.0$, $B=0.8$, $C=0.7$, $k_0=10.0$, 随机种子 $s_3=2025$。\n\n输出规范：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按每个测试用例的顺序，将五个纯度比率 $[R_{\\mathrm{scalar}}, R_{\\mathrm{vector}}, R_{\\mathrm{div}}, R_{\\mathrm{trace}}, R_{\\mathrm{TT}}]$ 连接为浮点数。例如，最终输出格式必须为\n$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12},r_{13},r_{14},r_{15}]$\n每个测试用例有 $5$ 个条目，总共有 $15$ 个条目。所有量都是无量纲的。不要进行四舍五入，并打印原始的 Python 浮点数表示。", "solution": "用户提供的问题被评估为有效。它在科学上基于宇宙学微扰理论和傅里叶分析的原理，问题陈述良好，具有完整且一致的参数集，并且其表述是客观的。任务是在周期性3D晶格上数值构建并验证高斯随机场的纯标量、矢量和张量模式，这是数值宇宙学中一个标准且不简单的练习。\n\n### 1. 理论框架与原理\n\n该问题围绕3D流形上场的标量-矢量-张量（SVT）分解展开，这是物理学中的一个基本工具，尤其在宇宙学中用于对度规和物质微扰进行分类。在平直的周期性空间中，这种分解最自然地在傅里叶空间中执行，其中导数变成了与波矢量 $\\mathbf{k}$ 的代数乘法。\n\n一个场可以分解为在旋转群 SO(3) 下不可约变换的分量。对于矢量场，这是 Helmholtz 分解，分解为一个纵向（无旋）部分和一个螺线管（无散）部分。对于对称二阶张量场，分解更为复杂，但在许多物理应用中（如引力波），最重要的分量是横向无迹（TT）部分。\n\n数值任务的核心是构建“纯”场，即完全属于这些分量之一的场（例如，纯纵向梯度、纯螺线管矢量或纯TT张量）。这是通过在傅里叶空间中使用投影算子来实现的。\n\n### 2. 算法实现\n\n整体算法通过生成高斯白噪声、将其变换到傅里叶空间、应用适当的谱滤波器和投影算子，然后计算验证指标来执行。\n\n**2.1. 傅里叶空间网格**\n建立一个大小为 $N \\times N \\times N$、物理边长为 $L$ 的均匀立方体网格。使用 `numpy.fft.fftfreq` 构建相应的波矢量 $\\mathbf{k} = (k_x, k_y, k_z)$。对于长度为 $L$ 的 $N$ 点网格，采样间距为 $d = L/N$。波数则为 $k_\\alpha = 2\\pi f_\\alpha$，其中 $f_\\alpha$ 是由 `numpy.fft.fftfreq(N, d=L/N)` 返回的频率。我们计算波矢量网格 `k_vecs`、其大小的平方 `k_squared` 和其大小 `k_norm`。一个关键步骤是处理 $\\mathbf{k}=\\mathbf{0}$ 模式，在该模式下，涉及除以 $k^2$ 的投影算子是奇异的。通过仅在 $k^2  0$ 的地方应用投影算子来管理此问题。\n\n**2.2. 纯标量模式（纵向梯度）**\n标量势 $\\Phi(\\mathbf{x})$ 是一个作为标量变换的场。它在实空间中的梯度 $\\nabla\\Phi$ 是一个矢量场。\n1.  **生成**：我们生成一个实空间高斯白噪声场，其功率谱是平坦的。它的傅里叶变换 `noise_phi_k` 具有必要的厄米共轭对称性。为了赋予它所需的功率谱 $P_\\Phi(k)$，我们通过乘以 $\\sqrt{P_\\Phi(k)}$ 对其进行滤波。这产生了标量势的傅里叶表示 $\\Phi(\\mathbf{k})$。\n2.  **梯度**：傅里叶空间中的梯度是 $\\mathbf{g}(\\mathbf{k}) = i \\mathbf{k} \\Phi(\\mathbf{k})$。\n3.  **验证**：梯度场本质上是无旋的（$\\nabla \\times \\nabla\\Phi = 0$）。在傅里叶空间中，这意味着 $\\mathbf{k} \\times \\mathbf{g}(\\mathbf{k}) = \\mathbf{k} \\times (i\\mathbf{k}\\Phi(\\mathbf{k})) = i(\\mathbf{k} \\times \\mathbf{k})\\Phi(\\mathbf{k}) = \\mathbf{0}$。无旋场是纯纵向的。因此，其在螺线管（横向）子空间上的投影必须为零。我们计算螺线管分量 $\\mathbf{g}^{\\mathrm{sol}}(\\mathbf{k}) = \\Lambda_{ij}(\\mathbf{k}) g_j(\\mathbf{k})$ 并计算比率 $R_{\\mathrm{scalar}} = \\|\\mathbf{g}^{\\mathrm{sol}}\\|^2 / \\|\\mathbf{g}\\|^2$。理论上，该比率应为零；在数值上，它将是一个反映浮点精度的小数。\n\n**2.3. 纯矢量模式（螺线管场）**\n无散矢量场是纯螺线管场。\n1.  **生成**：我们从三个独立的、每个分量一个的高斯白噪声场生成的随机矢量场开始。傅里叶变换后，我们得到一个随机矢量场 $\\mathbf{V}^{\\mathrm{noise}}(\\mathbf{k})$。然后我们应用螺线管投影算子，$\\mathbf{V}^{\\mathrm{proj}}(\\mathbf{k}) = \\Lambda_{ij}(\\mathbf{k}) V_j^{\\mathrm{noise}}(\\mathbf{k})$。根据构造，对于 $\\mathbf{k} \\neq \\mathbf{0}$，所得场是无散的。最后，我们应用谱滤波器 $\\sqrt{S_v(k)}$ 得到最终场 $\\mathbf{V}(\\mathbf{k})$。按要求将 $\\mathbf{k}=\\mathbf{0}$ 模式设置为零。\n2.  **验证**：由于 $\\mathbf{V}(\\mathbf{k})$ 被构造成纯螺线管场，其纵向分量必须为零。我们计算这个分量 $\\mathbf{V}^{\\mathrm{long}}(\\mathbf{k}) = L_{ij}(\\mathbf{k}) V_j(\\mathbf{k})$，以及比率 $R_{\\mathrm{vector}} = \\|\\mathbf{V}^{\\mathrm{long}}\\|^2 / \\|\\mathbf{V}\\|^2$。这个比率在数值上应接近于零。\n\n**2.4. 纯张量模式（横向无迹场）**\n一个横向无迹（TT）对称张量场 $h_{ij}$ 在傅里叶空间中对于 $\\mathbf{k} \\neq \\mathbf{0}$ 满足两个条件：横向性（$k_i h_{ij}(\\mathbf{k}) = 0$）和无迹性（$h_{ii}(\\mathbf{k}) = 0$）。\n1.  **生成**：我们从9个独立的高斯白噪声场生成一个通用的二阶张量场。在傅里叶空间中，我们首先将其对称化：$h^{\\mathrm{sym}}_{ij} = \\frac{1}{2}(h_{ij} + h_{ji})$。然后我们应用 TT 投影算子 $P^{\\mathrm{TT}}_{ij,kl}$。为了计算效率，这是按顺序实现的：\n    a. 使张量在两个指数上都横向：$h^{\\mathrm{T}}_{ij} = \\Lambda_{ik}\\Lambda_{jl}h^{\\mathrm{sym}}_{kl}$。\n    b. 在保持横向性的同时移除迹：$h^{\\mathrm{TT}}_{ij} = h^{\\mathrm{T}}_{ij} - \\frac{1}{2}\\Lambda_{ij} h^{\\mathrm{T}}_{kk}$。\n    所得场 $h^{\\mathrm{TT}}(\\mathbf{k})$ 是已投影的。然后我们应用谱滤波器 $\\sqrt{S_h(k)}$ 得到最终场 $h(\\mathbf{k})$。\n2.  **验证**：我们计算三个比率：\n    *   $R_{\\mathrm{div}}$: 测量散度 $d_j = k_i h_{ij}$ 相对于张量本身范数的范数。由于 $h$ 是横向的，该值应接近于零。\n    *   $R_{\\mathrm{trace}}$: 测量迹 $\\mathrm{tr} = h_{ii}$ 相对于张量范数的范数。由于 $h$ 是无迹的，该值应接近于零。\n    *   $R_{\\mathrm{TT}}$: 测试投影算子的幂等性。由于 $h(\\mathbf{k})$ 已经在 TT 子空间中，再次对其投影不应改变它：$P^{\\mathrm{TT}}[h] = h$。该比率测量差异的相对范数，$\\|h - P^{\\mathrm{TT}}[h]\\|^2 / \\|h\\|^2$，其值在数值上也应接近于零，从而验证了投影算子的实现。\n\n在所有计算中，范数 $\\|X\\|^2$ 计算为模的平方在所有网格点和分量索引上的总和，即 `numpy.sum(numpy.abs(X)**2)`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_for_case(params):\n    \"\"\"\n    Generates and validates scalar, vector, and tensor fields for a single test case.\n\n    Args:\n        params (dict): A dictionary containing the parameters N, L, A, B, C, k0, and seed.\n\n    Returns:\n        list: A list of the five computed purity ratios.\n    \"\"\"\n    N, L, A, B, C, k0, seed = params['N'], params['L'], params['A'], params['B'], params['C'], params['k0'], params['seed']\n    rng = np.random.default_rng(seed)\n\n    # 1. Setup k-space grid\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vecs = np.array([kx, ky, kz])\n    k_squared = kx**2 + ky**2 + kz**2\n    k_norm = np.sqrt(k_squared)\n    \n    k_is_nonzero = k_squared > 1e-12 # Use tolerance for float comparison\n    \n    k_squared_inv = np.zeros_like(k_squared, dtype=float)\n    np.divide(1.0, k_squared, out=k_squared_inv, where=k_is_nonzero)\n\n    # --- Part 1: Scalar Field ---\n    \n    noise_phi_real = rng.standard_normal(size=(N, N, N))\n    noise_phi_k = np.fft.fftn(noise_phi_real)\n    \n    P_phi = A / (1 + (k_norm / k0)**4)\n    phi_k = noise_phi_k * np.sqrt(P_phi)\n    \n    g_k = 1j * k_vecs * phi_k\n    \n    k_dot_g = np.einsum('i...,i...->...', k_vecs, g_k)\n    g_long = k_vecs * k_squared_inv * k_dot_g\n    g_sol = g_k - g_long\n    \n    norm_g_sq = np.sum(np.abs(g_k)**2)\n    norm_g_sol_sq = np.sum(np.abs(g_sol)**2)\n    R_scalar = norm_g_sol_sq / norm_g_sq if norm_g_sq > 0 else 0.0\n\n    # --- Part 2: Vector Field ---\n\n    noise_v_real = rng.standard_normal(size=(3, N, N, N))\n    noise_v_k = np.fft.fftn(noise_v_real, axes=(1, 2, 3))\n\n    k_dot_noise_v = np.einsum('i...,i...->...', k_vecs, noise_v_k)\n    V_proj_k = noise_v_k - k_vecs * k_squared_inv * k_dot_noise_v\n    V_proj_k[:, np.logical_not(k_is_nonzero)] = 0.0\n\n    S_v = B * np.exp(-(k_norm / k0)**2)\n    V_k = V_proj_k * np.sqrt(S_v)\n    \n    k_dot_V = np.einsum('i...,i...->...', k_vecs, V_k)\n    V_long = k_vecs * k_squared_inv * k_dot_V\n    \n    norm_V_sq = np.sum(np.abs(V_k)**2)\n    norm_V_long_sq = np.sum(np.abs(V_long)**2)\n    R_vector = norm_V_long_sq / norm_V_sq if norm_V_sq > 0 else 0.0\n\n    # --- Part 3: Tensor Field ---\n    \n    def project_to_TT(T_k):\n        \"\"\"Applies the TT projection operator to a tensor field T_k in Fourier space.\"\"\"\n        # Projector onto the space transverse to k: Lambda_ij = delta_ij - k_i k_j / k^2\n        k_outer_k_over_ksq = np.einsum('i...,j...->ij...', k_vecs, k_vecs, optimize=True) * k_squared_inv\n        Lambda_ij = np.identity(3)[:, :, np.newaxis, np.newaxis, np.newaxis] - k_outer_k_over_ksq\n\n        # Project T_k to be transverse on both indices: h_T = Lambda . T_k . Lambda\n        T_transverse = np.einsum('ik...,kl...,lj...->ij...', Lambda_ij, T_k, Lambda_ij, optimize=True)\n        \n        # Get the trace part to be removed, which is 0.5 * Lambda_ij * (Lambda_kl * T_kl).\n        # The term (Lambda_kl * T_kl) is the trace of the projected tensor.\n        trace_term = np.einsum('kl...,kl...->...', Lambda_ij, T_k, optimize=True)\n        \n        # Subtract the trace part\n        h_TT = T_transverse - 0.5 * np.einsum('ij...,...->ij...', Lambda_ij, trace_term, optimize=True)\n        \n        h_TT[:, :, np.logical_not(k_is_nonzero)] = 0.0\n        return h_TT\n\n    noise_h_real = rng.standard_normal(size=(3, 3, N, N, N))\n    noise_h_k = np.fft.fftn(noise_h_real, axes=(2, 3, 4))\n    h_sym_k = 0.5 * (noise_h_k + noise_h_k.transpose(1, 0, 2, 3, 4))\n    \n    h_TT_k = project_to_TT(h_sym_k)\n    \n    S_h = C * (k_norm / k0)**2 * np.exp(-(k_norm / k0)**2)\n    np.nan_to_num(S_h, copy=False, nan=0.0)\n    h_k = h_TT_k * np.sqrt(S_h)\n\n    norm_h_sq = np.sum(np.abs(h_k)**2)\n\n    d_j = np.einsum('i...,ij...->j...', k_vecs, h_k, optimize=True)\n    norm_d_sq = np.sum(np.abs(d_j)**2)\n    R_div = norm_d_sq / norm_h_sq if norm_h_sq > 0 else 0.0\n\n    tr = np.einsum('ii...->...', h_k, optimize=True)\n    norm_tr_sq = np.sum(np.abs(tr)**2)\n    R_trace = norm_tr_sq / norm_h_sq if norm_h_sq > 0 else 0.0\n    \n    h_reprojected = project_to_TT(h_k)\n    diff_h = h_k - h_reprojected\n    norm_diff_h_sq = np.sum(np.abs(diff_h)**2)\n    R_TT = norm_diff_h_sq / norm_h_sq if norm_h_sq > 0 else 0.0\n\n    return [R_scalar, R_vector, R_div, R_trace, R_TT]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 16, 'L': 1, 'A': 1.0, 'B': 1.0, 'C': 1.0, 'k0': 12.0, 'seed': 12345},\n        {'N': 8,  'L': 1, 'A': 1.0, 'B': 0.5, 'C': 1.5, 'k0': 9.0,  'seed': 54321},\n        {'N': 20, 'L': 1, 'A': 2.0, 'B': 0.8, 'C': 0.7, 'k0': 10.0, 'seed': 2025},\n    ]\n\n    results = []\n    for params in test_cases:\n        case_results = solve_for_case(params)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3485117"}]}