{"hands_on_practices": [{"introduction": "在数值宇宙学中，一个基本任务是求解描述物质、辐射和暗能量等宇宙组分能量密度演化的微分方程组。由于这些组分随宇宙膨胀的标度行为不同（例如，辐射密度 $\\rho_r \\propto a^{-4}$ 而物质密度 $\\rho_m \\propto a^{-3}$），导致方程组在某些时期（如早期辐射主导时期）呈现出“数值刚性”。本实践将引导你实现这一演化过程，并通过比较标准求解器与专为刚性问题设计的求解器，来量化刚性效应，从而深刻理解为特定物理问题选择正确数值算法的重要性。", "problem": "要求您构建一个完整的、可运行的程序，在一个空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克 (Friedmann–Lemaître–Robertson–Walker, FLRW) 宇宙中，使用 e-折叠变量 $N=\\ln a$ 作为自变量，数值演化非相对论物质、辐射和暗能量的能量密度。目标有两方面：一是使用一个数值常微分方程求解器，以 $N$ 为自变量来实现演化；二是通过比较一个非刚性求解器和一个刚性求解器，来量化在辐射主导的极小标度因子 $a\\sim 10^{-8}$ 附近的数值刚度。\n\n基本原理：\n- 对于能量密度为 $\\rho$、压强为 $p$ 的均匀流体，其连续性方程为 $d\\rho/dt + 3H(\\rho + p)=0$，其中 $H$ 是哈勃参数，$t$ 是宇宙时。\n- 定义状态方程参数 $w(a) = p/\\rho$，连续性方程可推得 $d\\ln \\rho/d\\ln a = -3(1+w(a))$。\n- 选择 $N=\\ln a$ 作为自变量。则 $d\\rho/dN = -3(1+w(a))\\rho$。\n\n模型假设：\n- 三个无相互作用的组分各自按照其状态方程独立演化：物质的 $w_m = 0$，辐射的 $w_r = 1/3$，以及暗能量的状态方程由 Chevallier–Polarski–Linder (CPL) 参数化描述，其形式为 $w(a) = w_0 + w_a (1-a)$，其中 $w_0$ 和 $w_a$ 是常数。\n- 所有密度均归一化至今天的临界密度，使其成为无量纲量。用 $\\Omega_{m0}$、$\\Omega_{r0}$ 和 $\\Omega_{DE0}$ 表示在今天（$a=1$）的值，其中 $\\Omega_{DE0} = 1 - (\\Omega_{m0} + \\Omega_{r0})$。\n\n以自变量 $N=\\ln a$ 演化的方程：\n- 物质：$d\\rho_m/dN = -3 \\rho_m$。\n- 辐射：$d\\rho_r/dN = -4 \\rho_r$。\n- 暗能量：$d\\rho_{DE}/dN = -3\\bigl(1 + w(a)\\bigr)\\rho_{DE}$，其中 $w(a)=w_0+w_a(1-a)$ 且 $a = e^N$。\n\n量化刚度：\n- 令 $J(N)$ 为右端项关于状态向量 $(\\rho_m,\\rho_r,\\rho_{DE})$ 的雅可比矩阵。对于这个自治状态线性系统，$J(N)$ 是一个对角矩阵，其特征值为\n$$\n\\lambda_m(N) = -3,\\quad \\lambda_r(N) = -4,\\quad \\lambda_{DE}(N) = -3\\bigl(1 + w(a)\\bigr).\n$$\n- 在给定的 $N$ 处，定义一个瞬时刚度指标\n$$\nS(N) = \\frac{\\max\\{|\\lambda_m(N)|,|\\lambda_r(N)|,|\\lambda_{DE}(N)|\\}}{\\max\\left(\\min\\{|\\lambda_m(N)|,|\\lambda_r(N)|,|\\lambda_{DE}(N)|\\}, \\varepsilon\\right)},\n$$\n其中 $\\varepsilon$ 是一个小的正数，用于避免在 $|\\lambda_{DE}(N)|$ 为零的情况下（例如当 $w(a)=-1$ 时）出现除以零的错误。使用 $\\varepsilon = 10^{-12}$。\n- 通过比较一个非刚性显式求解器与一个刚性隐式求解器在从 $N=0$ 积分到 $N=\\ln(10^{-8})$ 时所用的右端项求值次数，来定义一个经验数值刚度分数。具体而言，使用相同的容差，分别用 5(4) 阶龙格-库塔法（\"RK45\"）和后向差分公式（\"BDF\"）各积分一次，并计算\n$$\nR = \\frac{\\text{右端项求值次数 (RK45)}}{\\text{右端项求值次数 (BDF)}}。\n$$\n$R1$ 的值表示刚性求解器用更少的右端项求值次数达到了相同的精度，这在刚性区间是典型情况。\n\n数值设置：\n- 自变量定义域：$N \\in [\\ln(10^{-8}), 0]$。实现从 $N=0$ 向下积分到 $N=\\ln(10^{-8})$。\n- $N=0$ 时的初始条件（即 $a=1$ 时）：$\\rho_m(0)=\\Omega_{m0}$，$\\rho_r(0)=\\Omega_{r0}$，$\\rho_{DE}(0)=\\Omega_{DE0}$，其中 $\\Omega_{DE0} = 1 - (\\Omega_{m0}+\\Omega_{r0})$。\n- 对两个求解器使用相同的绝对和相对容差：相对容差 $\\mathrm{rtol} = 10^{-10}$，绝对容差 $\\mathrm{atol} = 10^{-12}$。两个求解器使用相同的右端项及其雅可比矩阵。\n\n每个测试案例需要计算的输出：\n- 令 $N_{\\min}=\\ln(10^{-8})$ 和 $a_{\\min}=10^{-8}$。对于下面的每个参数集，计算：\n  1. 比率 $\\rho_r(N_{\\min})/\\rho_m(N_{\\min})$，以浮点数形式表示。\n  2. 瞬时刚度指标 $S(N_{\\min})$，以浮点数形式表示。\n  3. 经验数值刚度分数 $R$，以浮点数形式表示。\n\n所有三个输出都是无量纲的，必须以浮点数形式报告，并四舍五入到六位有效数字。\n\n测试套件（四个测试案例）：\n- 案例 1 (基准Λ-冷暗物质模型): $\\Omega_{m0}=0.315$, $\\Omega_{r0}=9.2\\times 10^{-5}$, $w_0=-1.0$, $w_a=0.0$。\n- 案例 2 (今天呈魅影状态的温和演化暗能量): $\\Omega_{m0}=0.30$, $\\Omega_{r0}=9.2\\times 10^{-5}$, $w_0=-0.95$, $w_a=-0.10$。\n- 案例 3 (早期与宇宙学常数有强烈偏离): $\\Omega_{m0}=0.30$, $\\Omega_{r0}=9.2\\times 10^{-5}$, $w_0=-1.0$, $w_a=0.50$。\n- 案例 4 (今天辐射可忽略不计的边缘案例): $\\Omega_{m0}=0.30$, $\\Omega_{r0}=1.0\\times 10^{-10}$, $w_0=-1.0$, $w_a=0.0$。\n\n实现要求：\n- 使用一个标准的数值常微分方程接口，该接口需支持显式 5(4) 阶龙格-库塔方法和隐式后向差分公式方法，并能提供用户自定义的雅可比矩阵。对于每种方法，从 $N=0$ 积分到 $N_{\\min}$，并统计右端项求值次数以计算 $R$。\n- 使用 $a=a_{\\min}$ 和 $\\varepsilon=10^{-12}$ 处的解析特征值来计算 $S(N_{\\min})$。\n- 从 $N_{\\min}$ 处的数值解计算 $\\rho_r(N_{\\min})/\\rho_m(N_{\\min})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由四个内部列表组成的逗号分隔列表，每个内部列表对应一个测试案例，无空格，且严格按照测试套件的顺序排列。每个内部列表必须按上述顺序包含三个浮点数，并四舍五入到六位有效数字。例如：\n\"[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33],[x41,x42,x43]]\"", "solution": "所提出的问题是数值宇宙学中一个有效且定义明确的练习，它基于标准宇宙学模型。该问题要求数值积分一个常微分方程组(ODEs)，该方程组描述了物质、辐射和暗能量的能量密度的演化。此问题在科学上是合理的，所有参数和方程都是该领域的标准。它在计算上是可行的，并且为获得唯一解提供了所有必要信息。\n\n其理论框架是空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克 (Friedmann–Lemaître–Robertson–Walker, FLRW) 宇宙模型。对于一个压强为 $p$ 的理想流体组分，其能量密度 $\\rho$ 的演化由连续性方程 $d\\rho/dt + 3H(\\rho+p) = 0$ 决定。通过引入状态方程参数 $w=p/\\rho$，并将自变量从宇宙时 $t$ 更改为 e-折叠数 $N = \\ln a$（其中 $a$ 是宇宙学标度因子），连续性方程对每个组分转化为一个一阶常微分方程：\n$$\n\\frac{d\\rho}{dN} = -3(1+w)\\rho\n$$\n宇宙被建模为三个无相互作用组分的混合物：\n1.  **非相对论物质**（冷暗物质和重子物质），其压强可忽略不计，因此 $w_m = 0$。\n2.  **辐射**（光子和相对论性中微子），其状态方程为 $w_r = 1/3$。\n3.  **暗能量**，一个具有负压强的组分，导致宇宙加速膨胀。其状态方程由 Chevallier–Polarski–Linder (CPL) 参数化描述，$w(a) = w_0 + w_a(1-a)$，其中 $w_0$ 和 $w_a$ 是常数。当 $a=e^N$ 时，此为 $w(N) = w_0 + w_a(1-e^N)$。\n\n能量密度 $\\rho_m$、$\\rho_r$ 和 $\\rho_{DE}$ 被归一化至今天（$N=0$, $a=1$）的临界密度，因此它们的初始值是今天的密度参数 $\\Omega_{m0}$、$\\Omega_{r0}$ 和 $\\Omega_{DE0}$。平坦宇宙的假设施加了约束 $\\Omega_{m0} + \\Omega_{r0} + \\Omega_{DE0} = 1$。\n\n这导出了以下关于状态向量 $\\vec{\\rho}(N) = [\\rho_m(N), \\rho_r(N), \\rho_{DE}(N)]^T$ 的耦合一阶常微分方程组：\n$$\n\\frac{d\\rho_m}{dN} = -3(1+w_m)\\rho_m = -3\\rho_m\n$$\n$$\n\\frac{d\\rho_r}{dN} = -3(1+w_r)\\rho_r = -3(1+1/3)\\rho_r = -4\\rho_r\n$$\n$$\n\\frac{d\\rho_{DE}}{dN} = -3(1+w(e^N))\\rho_{DE} = -3\\left(1 + w_0 + w_a(1-e^N)\\right)\\rho_{DE}\n$$\n这些方程需要在定义域 $N \\in [\\ln(10^{-8}), 0]$ 上进行数值求解，从 $N=0$ 处的初始条件开始向后积分：$\\rho_m(0) = \\Omega_{m0}$、$\\rho_r(0) = \\Omega_{r0}$ 和 $\\rho_{DE}(0) = \\Omega_{DE0}$。\n\n问题的关键在于研究该系统的数值刚度。当一个常微分方程系统中存在两个或多个尺度差异巨大的自变量区间，因变量在这些区间上发生变化时，就会出现刚度。它由系统右端项函数的雅可比矩阵 $J_{ij} = \\partial f_i / \\partial \\rho_j$ 的特征值来表征。对于给定的系统，雅可比矩阵是对角的：\n$$\nJ(N) = \\begin{pmatrix} -3  0  0 \\\\ 0  -4  0 \\\\ 0  0  -3(1+w(e^N)) \\end{pmatrix}\n$$\n特征值就是对角线上的元素：$\\lambda_m = -3$、$\\lambda_r = -4$ 和 $\\lambda_{DE}(N) = -3(1+w(e^N))$。系统的刚度与这些特征值绝对值的最大值与最小值之比有关。我们用瞬时刚度指标来量化这一点：\n$$\nS(N) = \\frac{\\max\\{|\\lambda_m|, |\\lambda_r|, |\\lambda_{DE}(N)|\\}}{\\max(\\min\\{|\\lambda_m|, |\\lambda_r|, |\\lambda_{DE}(N)|\\}, \\varepsilon)}\n$$\n其中 $\\varepsilon = 10^{-12}$ 用于防止除以零，这对于标准的 $\\Lambda$CDM 模型尤其重要，因为在该模型中 $w_0=-1$ 且 $w_a=0$，使得对所有 $N$ 都有 $\\lambda_{DE}(N) = 0$。\n\n算法方法包括对每个测试案例执行以下步骤：\n1.  初始化参数（$\\Omega_{m0}$、$\\Omega_{r0}$、$w_0$、$w_a$）、$N=0$ 时 $\\vec{\\rho}$ 的初始条件，以及积分区间 $N \\in [\\ln(10^{-8}), 0]$。\n2.  定义常微分方程组的右端项 (RHS) 函数及其解析雅可比矩阵。\n3.  使用 `scipy.integrate.solve_ivp` 中的两种不同求解器，将系统从 $N=0$ 数值积分到 $N_{\\min} = \\ln(10^{-8})$：\n    a. 一种显式 5(4) 阶龙格-库塔方法 (`RK45`)，对非刚性问题效率很高。\n    b. 一种基于后向差分公式的隐式方法 (`BDF`)，专为刚性问题设计，并可以利用提供的雅可比矩阵来提高性能。\n4.  两次积分均使用相同的高精度容差（$\\mathrm{rtol} = 10^{-10}$，$\\mathrm{atol} = 10^{-12}$）以确保解的准确性。\n5.  记录每次求解器运行的 RHS 求值次数 (`nfev`)。\n6.  根据在 $N_{\\min}$ 处计算出的解，计算辐射能量密度与物质能量密度之比 $\\rho_r(N_{\\min})/\\rho_m(N_{\\min})$。\n7.  使用在 $a_{\\min}=e^{N_{\\min}}=10^{-8}$ 处的特征值解析公式计算瞬时刚度指标 $S(N_{\\min})$。\n8.  计算经验数值刚度分数 $R$，即 `RK45` 的 `nfev` 与 `BDF` 的 `nfev` 之比。大的 $R  1$ 值表明 `BDF` 求解器效率显著更高，从而证实了系统的刚性。\n9.  然后将计算出的三个浮点值四舍五入到六位有效数字，用于最终输出。对所有四个提供的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically evolves energy densities in an FLRW universe and quantifies\n    numerical stiffness for different cosmological models.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (baseline Lambda Cold Dark Matter)\n        (0.315, 9.2e-5, -1.0, 0.0),\n        # Case 2 (mildly evolving dark energy with phantom today)\n        (0.30, 9.2e-5, -0.95, -0.10),\n        # Case 3 (strong early-time deviation from cosmological constant)\n        (0.30, 9.2e-5, -1.0, 0.50),\n        # Case 4 (edge case with negligible radiation today)\n        (0.30, 1.0e-10, -1.0, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Omega_m0, Omega_r0, w0, wa = case\n        Omega_DE0 = 1.0 - (Omega_m0 + Omega_r0)\n\n        # Numerical setup\n        N_min = np.log(1e-8)\n        N_span = [0, N_min]\n        rho0 = np.array([Omega_m0, Omega_r0, Omega_DE0])\n        rtol = 1e-10\n        atol = 1e-12\n\n        def rhs(N, rho, w0_val, wa_val):\n            \"\"\"Right-hand side of the ODE system d(rho)/dN.\"\"\"\n            rho_m, rho_r, rho_de = rho\n            a = np.exp(N)\n            w_de = w0_val + wa_val * (1 - a)\n            \n            drho_m_dN = -3.0 * rho_m\n            drho_r_dN = -4.0 * rho_r\n            drho_de_dN = -3.0 * (1.0 + w_de) * rho_de\n            \n            return np.array([drho_m_dN, drho_r_dN, drho_de_dN])\n\n        def jac(N, rho, w0_val, wa_val):\n            \"\"\"Jacobian of the RHS function.\"\"\"\n            a = np.exp(N)\n            w_de = w0_val + wa_val * (1.0 - a)\n            \n            J = np.zeros((3, 3))\n            J[0, 0] = -3.0\n            J[1, 1] = -4.0\n            J[2, 2] = -3.0 * (1.0 + w_de)\n            return J\n\n        # --- Integration with non-stiff solver (RK45) ---\n        sol_rk45 = solve_ivp(\n            fun=rhs,\n            t_span=N_span,\n            y0=rho0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol,\n            args=(w0, wa)\n        )\n        nfev_rk45 = sol_rk45.nfev\n        rho_final = sol_rk45.y[:, -1]\n\n        # --- Integration with stiff solver (BDF) ---\n        sol_bdf = solve_ivp(\n            fun=rhs,\n            t_span=N_span,\n            y0=rho0,\n            method='BDF',\n            jac=jac,\n            rtol=rtol,\n            atol=atol,\n            args=(w0, wa)\n        )\n        nfev_bdf = sol_bdf.nfev\n\n        # --- Compute the three required outputs ---\n\n        # 1. Ratio rho_r / rho_m at N_min\n        rho_m_final, rho_r_final, _ = rho_final\n        ratio_rho = rho_r_final / rho_m_final if rho_m_final != 0 else np.inf\n\n        # 2. Instantaneous stiffness indicator S(N_min)\n        a_min = 1e-8\n        epsilon = 1e-12\n        w_de_min = w0 + wa * (1.0 - a_min)\n        \n        lambda_m_abs = 3.0\n        lambda_r_abs = 4.0\n        lambda_de_abs = np.abs(-3.0 * (1.0 + w_de_min))\n        \n        abs_lambdas = np.array([lambda_m_abs, lambda_r_abs, lambda_de_abs])\n        max_lambda = np.max(abs_lambdas)\n        min_lambda = np.min(abs_lambdas)\n        \n        stiffness_indicator = max_lambda / max(min_lambda, epsilon)\n\n        # 3. Empirical numerical stiffness score R\n        stiffness_score = nfev_rk45 / nfev_bdf if nfev_bdf != 0 else np.inf\n\n        # Format results to six significant figures\n        def format_six_sf(value):\n            return float(f'{value:.6g}')\n\n        case_results = [\n            format_six_sf(ratio_rho),\n            format_six_sf(stiffness_indicator),\n            format_six_sf(stiffness_score)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3470916"}, {"introduction": "理论上精确的弗里德曼方程在有限精度的计算机上进行数值计算时，会遇到微妙的挑战。当计算哈勃参数 $H(a)$ 时，我们需要将辐射、物质和暗能量等项的贡献相加，而在宇宙演化的极端时期（极早期或遥远未来），这些项的量级可能相差悬殊。本实践将揭示这种“大数吃小数”现象如何导致严重的精度损失，并指导你实现一种补偿求和算法来显著提升计算结果的准确性，确保数值模拟的物理真实性。", "problem": "要求您研究使用有限精度算术计算哈勃膨胀率作为宇宙尺度因子函数的数值稳定性，并实现一种鲁棒的补偿求和策略，以减轻对数量级差异巨大的项求和时的浮点抵消问题。工作在一个空间均匀且各向同性的宇宙中，其膨胀由包含理想流体组分的弗里德曼方程所支配。无量纲膨胀率定义为 $E(a) \\equiv H(a)/H_{0}$，其中 $a$ 是归一化为今天 $a=1$ 的宇宙学尺度因子，$H(a)$ 是哈勃参数，$H_{0}$ 是其当前值。假设以下组分对总能量收支有贡献：密度参数为 $\\Omega_{r}$ 的辐射，密度参数为 $\\Omega_{m}$ 的非相对论性物质，密度参数为 $\\Omega_{k}$ 的空间曲率，以及由常数状态方程参数 $w$ 和密度参数 $\\Omega_{\\mathrm{de}}$ 表征的暗能量。在 $a=1$ 时的总能量收支满足 $\\Omega_{r} + \\Omega_{m} + \\Omega_{k} + \\Omega_{\\mathrm{de}} = 1$。对于常数 $w$，根据膨胀宇宙中的标准理想流体连续性方程，能量密度按 $a$ 的幂次进行标度。\n\n从广义相对论的弗里德曼方程和理想流体连续性方程出发，可以将无量纲膨胀率表示为\n$$\nE(a)^{2} = \\Omega_{r}\\, a^{-4} + \\Omega_{m}\\, a^{-3} + \\Omega_{k}\\, a^{-2} + \\Omega_{\\mathrm{de}}\\, a^{-3(1+w)}.\n$$\n在实际的数值宇宙学计算中，$\\Omega_{k}$ 通常不是直接指定的，而是通过残差闭合来计算的\n$$\n\\Omega_{k} = 1 - \\left(\\Omega_{r} + \\Omega_{m} + \\Omega_{\\mathrm{de}}\\right).\n$$\n当在 $a$ 的极端值处计算 $E(a)$ 时，各项之间可能相差许多数量级，在有限精度下进行朴素的浮点求和可能会遭受严重的舍入和抵消误差。您的任务是在单精度下量化此效应，并实现一种补偿求和策略，以在不改变物理模型的情况下减少误差。\n\n您必须实现一个程序，该程序：\n- 通过使用从双精度残差获得的 $\\Omega_{k}$，按任何合理的顺序在双精度下对各组分求和，计算一个双精度的高精度参考值 $E_{\\mathrm{ref}}(a)$。\n- 通过以下方式计算一个朴素的单精度估计值 $E_{\\mathrm{naive}}(a)$：\n  - 将所有输入参数和 $a$ 转换为单精度，从单精度残差计算 $\\Omega_{k}$，在单精度下形成四个贡献项，并以固定的从左到右的顺序对它们求和以获得单精度的 $E(a)^{2}$，然后取平方根。如果仅仅由于有限精度，中间的单精度贡献项之和为负，则在取平方根之前将其设为零。\n- 计算一个改进的单精度估计值 $E_{\\mathrm{comp}}(a)$，该方法与朴素方法的唯一区别在于如何聚合四个贡献项：使用一种补偿求和策略来最小化抵消，例如，按数量级从小到大的顺序对各贡献项求和，并使用单遍补偿求和（例如 Kahan 风格的补偿），所有计算均在单精度下进行，然后取平方根。如上所述，如果补偿和仅仅由于舍入而为负，则在取平方根之前将其设为零。\n\n对于下面的每个测试用例，在从 $a_{\\min}$ 到 $a_{\\max}$（含）的对数间隔网格上评估 $a$ 值，并报告朴素和补偿单精度方法在整个网格上的最大相对误差，其中给定 $a$ 处的相对误差为\n$$\n\\varepsilon(a) = \\frac{\\left|E_{\\mathrm{method}}(a) - E_{\\mathrm{ref}}(a)\\right|}{E_{\\mathrm{ref}}(a)}.\n$$\n此问题中的所有量都是无量纲的；因此，答案中不需要物理单位。\n\n测试套件规范：\n- 对每个测试用例，在 $a \\in \\left[10^{-8}, 10^{4}\\right]$ 范围内使用一个包含 $N=200$ 个对数间隔点的网格。\n- 对于每个测试用例，程序必须按顺序输出两个浮点数：朴素单精度求和的最大相对误差和补偿单精度求和的最大相对误差。\n\n测试用例：\n1. 包含少量辐射组分和宇宙学常数的标准晚期宇宙组分：\n   - $\\Omega_{r} = 8.24\\times 10^{-5}$，$\\Omega_{m} = 0.315$，$\\Omega_{\\mathrm{de}} = 0.6849176$，$w = -1$，$a_{\\min} = 10^{-8}$，$a_{\\max} = 10^{4}$。\n2. 暗能量主导且物质和辐射极小的极度倾斜的能量收支：\n   - $\\Omega_{r} = 1\\times 10^{-12}$，$\\Omega_{m} = 1\\times 10^{-6}$，$\\Omega_{\\mathrm{de}} = 0.999999$，$w = -1$，$a_{\\min} = 10^{-8}$，$a_{\\max} = 10^{4}$。\n3. $w  -1$ 且辐射可忽略的魅影暗能量：\n   - $\\Omega_{r} = 1\\times 10^{-10}$，$\\Omega_{m} = 0.05$，$\\Omega_{\\mathrm{de}} = 0.95$，$w = -1.1$，$a_{\\min} = 10^{-8}$，$a_{\\max} = 10^{4}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含六个结果，格式为一个由方括号括起来的逗号分隔列表，顺序如下：\n  - $[\\varepsilon_{\\max}^{\\mathrm{naive}}(\\mathrm{用例}\\,1), \\varepsilon_{\\max}^{\\mathrm{comp}}(\\mathrm{用例}\\,1), \\varepsilon_{\\max}^{\\mathrm{naive}}(\\mathrm{用例}\\,2), \\varepsilon_{\\max}^{\\mathrm{comp}}(\\mathrm{用例}\\,2), \\varepsilon_{\\max}^{\\mathrm{naive}}(\\mathrm{用例}\\,3), \\varepsilon_{\\max}^{\\mathrm{comp}}(\\mathrm{用例}\\,3)]$。\n- 每个条目必须是浮点数。程序不得打印任何其他文本。", "solution": "用户请求解决一个涉及计算哈勃膨胀率的数值宇宙学问题，重点在于减轻浮点误差。\n\n### **问题陈述验证**\n\n**1. 提取给定条件：**\n- **模型**：空间均匀且各向同性的宇宙。\n- **控制方程**：弗里德曼方程。\n- **定义**：无量纲膨胀率 $E(a) \\equiv H(a)/H_{0}$。\n- **组分**：辐射（$\\Omega_{r}$）、物质（$\\Omega_{m}$）、曲率（$\\Omega_{k}$）和暗能量（$\\Omega_{\\mathrm{de}}$，具有常数状态方程参数 $w$）。\n- **约束条件**：$\\Omega_{r} + \\Omega_{m} + \\Omega_{k} + \\Omega_{\\mathrm{de}} = 1$。\n- **$E(a)^{2}$ 的公式**：$E(a)^{2} = \\Omega_{r}\\, a^{-4} + \\Omega_{m}\\, a^{-3} + \\Omega_{k}\\, a^{-2} + \\Omega_{\\mathrm{de}}\\, a^{-3(1+w)}$。\n- **$\\Omega_{k}$ 的计算**：$\\Omega_{k} = 1 - \\left(\\Omega_{r} + \\Omega_{m} + \\Omega_{\\mathrm{de}}\\right)$。\n- **数值任务**：\n    1.  **$E_{\\mathrm{ref}}(a)$**：以双精度计算。\n    2.  **$E_{\\mathrm{naive}}(a)$**：将输入转换为单精度，计算各项，从左到右求和。将负和钳位到 $0$。\n    3.  **$E_{\\mathrm{comp}}(a)$**：与朴素法相同，但使用补偿策略求和（按数量级排序，然后进行 Kahan 求和）。将负和钳位到 $0$。\n- **误差度量**：最大相对误差 $\\varepsilon_{\\max} = \\max_a \\left|E_{\\mathrm{method}}(a) - E_{\\mathrm{ref}}(a)\\right|/E_{\\mathrm{ref}}(a)$。\n- **网格**：在 $a \\in \\left[10^{-8}, 10^{4}\\right]$ 范围内的 $N=200$ 个对数间隔点。\n- **测试用例**：\n    1. $\\Omega_{r} = 8.24\\times 10^{-5}$，$\\Omega_{m} = 0.315$，$\\Omega_{\\mathrm{de}} = 0.6849176$，$w = -1$。\n    2. $\\Omega_{r} = 1\\times 10^{-12}$，$\\Omega_{m} = 1\\times 10^{-6}$，$\\Omega_{\\mathrm{de}} = 0.999999$，$w = -1$。\n    3. $\\Omega_{r} = 1\\times 10^{-10}$，$\\Omega_{m} = 0.05$，$\\Omega_{\\mathrm{de}} = 0.95$，$w = -1.1$。\n- **输出**：一个包含六个逗号分隔浮点数的单行 `[...]`。\n\n**2. 使用提取的给定条件进行验证：**\n- **科学依据**：该问题基于标准宇宙学模型，特别是弗里德曼方程。辐射（$\\rho_r \\propto a^{-4}$）、物质（$\\rho_m \\propto a^{-3}$）、曲率（$\\rho_k \\propto a^{-2}$）和具有常数 $w$ 的暗能量（$\\rho_{\\mathrm{de}} \\propto a^{-3(1+w)}$）的能量密度标度关系是正确的。所提供的 $E(a)^2$ 方程是这些原理的直接且正确的结果。\n- **适定性**：问题定义明确。输入已指定，计算方法描述清晰，期望的输出精确。存在唯一、稳定的数值解。\n- **客观性**：语言精确，无主观性。给定的测试用例参数是现代宇宙学中使用的物理上合理的数值。\n- **完整性与一致性**：问题提供了所有必要的数据和方程。测试用例适用于平坦宇宙（在精确算术中 $\\Omega_k = 0$），这与当前的宇宙学观测一致。使用残差计算 $\\Omega_k$ 是标准做法，并引入了问题旨在研究的那种浮点细微问题。\n- **可行性**：所要求的计算是标准的，并且在指定的环境中是可行的。尺度因子 $a$ 的范围很大，这正是使数值稳定性问题突出并使问题变得有趣的原因。\n\n**3. 结论与行动：**\n该问题是**有效的**。这是一个将数值分析应用于物理宇宙学基本计算的适定且科学上合理的练习。任务是量化在处理有限精度算术时，鲁棒的求和算法相对于朴素方法的改进程度。我现在将着手解决。\n\n### **基于原理的设计与求解**\n\n该问题要求我们计算无量纲哈勃膨胀率 $E(a)$，它描述了宇宙的膨胀。其演化由各组分的能量密度决定，如弗里德曼方程所示。\n\n**1. 物理模型与控制方程**\n一个均匀且各向同性的宇宙的膨胀历史由弗里德曼方程描述。用无量纲密度参数 $\\Omega_i$（组分 $i$ 在今天的能量密度分数）表示，无量纲膨胀率 $E(a) = H(a)/H_0$ 由下式给出：\n$$\nE(a)^{2} = \\Omega_{r}\\, a^{-4} + \\Omega_{m}\\, a^{-3} + \\Omega_{k}\\, a^{-2} + \\Omega_{\\mathrm{de}}\\, a^{-3(1+w)}\n$$\n其中 $a$ 是尺度因子，下标 $r$、$m$、$k$ 和 $\\mathrm{de}$ 分别指辐射、非相对论性物质、空间曲率和暗能量。密度参数定义在 $a=1$ 时，并且必须总和为一，$\\Omega_{r} + \\Omega_{m} + \\Omega_{k} + \\Omega_{\\mathrm{de}} = 1$。问题指定 $\\Omega_k$ 由此闭合关系确定。尺度因子 $a$ 上的指数反映了每个组分的能量密度如何因宇宙膨胀而被稀释。\n\n**2. 数值挑战：有效位损失**\n问题的核心在于 $E(a)^2$ 求和的数值计算。尺度因子 $a$ 跨越十二个数量级，从 $10^{-8}$（早期、炎热、致密的宇宙）到 $10^{4}$（遥远的未来）。这导致和中的四项具有巨大差异的数量级。\n\n例如，在早期宇宙（$a \\ll 1$），辐射项 $\\Omega_{r}a^{-4}$ 占主导地位。在 $a=10^{-8}$ 时，此项的数量级约为 $\\sim 10^{-5} \\times (10^{-8})^{-4} = 10^{27}$，而暗能量项（对于 $w=-1$）约为 $\\sim 0.7$。当使用有限精度算术，如单精度（`float32`）时，将一个非常小的数加到一个非常大的数上会导致较小的数被有效丢弃。这种现象，称为“淹没”或“有效位损失”，会导致精度损失。一个朴素的求和 `A + B + C + D` 极易受此误差影响。\n\n**3. 算法实现策略**\n为了量化和减轻这种误差，我们实现了三种不同的计算方法：\n\n- **参考解 ($E_{\\mathrm{ref}}$)**：这是我们的“基准真相”。所有计算都使用双精度算术（`numpy.float64`），它提供大约 $15-17$ 位十进制数字的精度。这种高精度最小化了舍入误差，为比较单精度方法提供了一个可靠的基准。由于可用精度高，求和顺序不那么关键。\n\n- **朴素单精度解 ($E_{\\mathrm{naive}}$)**：在这里，所有参数和中间计算都被转换为单精度（`numpy.float32`），它只有大约 $7$ 位十进制数字的精度。构成 $E(a)^2$ 的四项以固定的从左到右的顺序求和。预计该方法会因淹没而遭受显著的精度损失，尤其是在尺度因子范围的极端情况下。根据规定，如果舍入误差导致和为负，则在取平方根之前将其钳位到 $0$，这是为了物理真实性而必需的步骤。\n\n- **补偿单精度解 ($E_{\\mathrm{comp}}$)**：该方法也使用单精度，但采用更复杂的求和策略来减少误差。该策略结合了两种启发式方法：\n    1.  **排序**：首先将四项按其绝对值的升序排序。从最小到最大求和是减少舍入误差的一种通用技术，因为它倾向于使运行总和与下一个要相加的项在数量级上更接近。\n    2.  **Kahan 求和**：然后对排序后的项应用单遍补偿求和算法，特别是 Kahan 求和算法。该算法维护一个额外的浮点变量，即*补偿项*（`c`），它累积每次加法的舍入误差。然后将捕获的误差在下一步重新引入到和中。Kahan 算法对于运行总和 `s` 和新项 `x` 的核心逻辑是：\n        - `y = x - c`（用先前的误差校正项）\n        - `t = s + y`（将校正后的项加到和中；此处可能发生误差）\n        - `c = (t - s) - y`（计算新的误差）\n        - `s = t`（更新和）\n    这个过程有效地跟踪了“丢失”的低位比特，并显著提高了最终和的准确性。如果由于残余舍入误差而变为负数，最终的和也会被钳位到 $0$。\n\n最后，相对于双精度参考解，在 $a$ 值的网格上计算朴素和补偿方法的最大相对误差。这量化了每种单精度策略的性能。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical cosmology problem by computing and comparing Hubble expansion rates.\n\n    This function iterates through a set of predefined cosmological test cases. For each case,\n    it calculates the dimensionless Hubble expansion rate E(a) over a logarithmic grid of\n    scale factors 'a' using three distinct methods:\n    1. A high-precision reference method using double-precision floating-point numbers.\n    2. A naive method using single-precision numbers and a standard left-to-right summation.\n    3. An improved method using single-precision numbers but with a compensated summation\n       (sorting terms by magnitude and applying Kahan's algorithm).\n\n    It then calculates the maximum relative error of the naive and compensated methods against\n    the reference result and stores these errors. Finally, it prints all collected errors\n    in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # (Omega_r, Omega_m, Omega_de, w, a_min, a_max)\n        (8.24e-5, 0.315, 0.6849176, -1.0, 1e-8, 1e4),\n        (1e-12, 1e-6, 0.999999, -1.0, 1e-8, 1e4),\n        (1e-10, 0.05, 0.95, -1.1, 1e-8, 1e4)\n    ]\n    N = 200\n    results = []\n\n    for case in test_cases:\n        Omega_r_in, Omega_m_in, Omega_de_in, w_in, a_min, a_max = case\n        a_grid = np.logspace(np.log10(a_min), np.log10(a_max), N)\n\n        # 1. High-precision reference calculation (double precision)\n        E_ref = np.zeros_like(a_grid, dtype=np.float64)\n        Or, Om, Ode, w = np.float64(Omega_r_in), np.float64(Omega_m_in), np.float64(Omega_de_in), np.float64(w_in)\n        Ok = np.float64(1.0) - (Or + Om + Ode)\n        w_exp = np.float64(-3.0) * (np.float64(1.0) + w)\n        for i, a_val in enumerate(a_grid):\n            a = np.float64(a_val)\n            term_r = Or * np.power(a, -4.0)\n            term_m = Om * np.power(a, -3.0)\n            term_k = Ok * np.power(a, -2.0)\n            term_de = Ode * np.power(a, w_exp)\n            E_sq = term_r + term_m + term_k + term_de\n            E_ref[i] = np.sqrt(E_sq if E_sq > 0 else 0.0)\n\n        # 2. Naive single-precision calculation\n        E_naive = np.zeros_like(a_grid, dtype=np.float32)\n        Or_32, Om_32, Ode_32, w_32 = np.float32(Omega_r_in), np.float32(Omega_m_in), np.float32(Omega_de_in), np.float32(w_in)\n        Ok_32 = np.float32(1.0) - (Or_32 + Om_32 + Ode_32)\n        w_exp_32 = np.float32(-3.0) * (np.float32(1.0) + w_32)\n        for i, a_val in enumerate(a_grid):\n            a_32 = np.float32(a_val)\n            term_r = Or_32 * np.power(a_32, np.float32(-4.0))\n            term_m = Om_32 * np.power(a_32, np.float32(-3.0))\n            term_k = Ok_32 * np.power(a_32, np.float32(-2.0))\n            term_de = Ode_32 * np.power(a_32, w_exp_32)\n            # Naive left-to-right summation\n            E_sq_32 = term_r + term_m + term_k + term_de\n            E_naive[i] = np.sqrt(E_sq_32 if E_sq_32 > 0 else np.float32(0.0))\n\n        # 3. Compensated single-precision calculation\n        E_comp = np.zeros_like(a_grid, dtype=np.float32)\n        for i, a_val in enumerate(a_grid):\n            a_32 = np.float32(a_val)\n            term_r = Or_32 * np.power(a_32, np.float32(-4.0))\n            term_m = Om_32 * np.power(a_32, np.float32(-3.0))\n            term_k = Ok_32 * np.power(a_32, np.float32(-2.0))\n            term_de = Ode_32 * np.power(a_32, w_exp_32)\n            \n            terms = [term_r, term_m, term_k, term_de]\n            \n            # Sort terms by increasing absolute magnitude\n            sorted_terms = sorted(terms, key=abs)\n            \n            # Kahan compensated summation\n            s = np.float32(0.0)\n            c = np.float32(0.0)\n            for x in sorted_terms:\n                y = x - c\n                t = s + y\n                c = (t - s) - y\n                s = t\n            E_sq_32 = s\n            E_comp[i] = np.sqrt(E_sq_32 if E_sq_32 > 0 else np.float32(0.0))\n\n        # Calculate maximum relative errors, avoiding division by zero if E_ref is zero\n        \n        # Naive error\n        err_naive = np.zeros_like(E_ref)\n        # E_ref should not be zero for these cosmological parameters\n        non_zero_mask = E_ref != 0\n        err_naive[non_zero_mask] = np.abs(E_naive[non_zero_mask] - E_ref[non_zero_mask]) / E_ref[non_zero_mask]\n        max_err_naive = np.max(err_naive)\n        \n        # Compensated error\n        err_comp = np.zeros_like(E_ref)\n        err_comp[non_zero_mask] = np.abs(E_comp[non_zero_mask] - E_ref[non_zero_mask]) / E_ref[non_zero_mask]\n        max_err_comp = np.max(err_comp)\n\n        results.extend([max_err_naive, max_err_comp])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3470934"}, {"introduction": "在探索标准宇宙学模型之外的可能性时，研究人员常常会遇到状态方程参数 $w(a)$ 穿越 $w=-1$ 这一“幽灵分界线”的奇异暗能量模型。对这类模型进行数值演化时，直接使用标准的能量密度演化方程会在穿越点附近导致数值不稳定甚至出现奇点。本实践旨在解决这一前沿问题，你将学习如何通过变换演化变量（演化能量密度的对数 $\\ln\\rho$ 而非其本身）来“正则化”问题，从而实现对这类物理模型的稳定、精确积分。", "problem": "考虑一个由 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规描述的空间均匀且各向同性的宇宙。对于具有能量密度 $\\rho(a)$ 和压强 $p(a)$ 的单一完美流体，假设其状态方程为 $p(a) = w(a)\\,\\rho(a)$，其中 $w(a)$ 作为标度因子 $a$ 的函数可能会穿越值 -1。用 $N = \\ln a$ 表示 e-折叠数。仅从 FLRW 时空中完美流体的能量守恒出发，并进行从宇宙时到 $N$ 的变量替换，设计一个数值程序，该程序能够在 $w(a) = -1$ 的穿越点上演化 $\\rho(a)$ 而不引入数值奇异点。该设计必须使用能量密度的对数作为演化变量，并且必须在穿越点附近实现一个平滑化的 $w(N)$。\n\n你的程序必须实现以下几个部分：\n\n- 一个用于状态方程参数的平滑穿越模型，\n  $$w_{\\mathrm{smooth}}(N; A, N_c, \\Delta) = -1 + A\\,\\tanh\\!\\left(\\frac{N - N_c}{\\Delta}\\right),$$\n  其中 $A$ 是偏离 -1 的振幅，$N_c$ 是发生 $w = -1$ 穿越时的 e-折叠数，$\\Delta$ 是平滑宽度。\n\n- 一个用于比较的不连续阶跃模型，\n  $$w_{\\mathrm{step}}(N; A, N_c) = -1 + A\\,\\mathrm{sgn}(N - N_c),$$\n  约定 $\\mathrm{sgn}(0) = 0$，因此 $w_{\\mathrm{step}}(N_c; A, N_c) = -1$。\n\n- 一个正则化积分器，它使用 $N$ 作为自变量和上面定义的 $w_{\\mathrm{smooth}}(N)$ 来演化能量密度的对数。在区间 $N \\in [N_i, N_f]$ 上使用步长为 $h_{\\mathrm{reg}}$ 的固定步长四阶 Runge–Kutta (RK4) 格式。\n\n- 一个朴素比较器，它在相同区间上使用步长为 $h_{\\mathrm{naive}}$ 的固定步长显式欧拉格式，并利用 $w_{\\mathrm{step}}(N)$ 直接演化能量密度。\n\n初始化与归一化：\n- 使用 $a_i$ 作为初始标度因子，$a_f$ 作为最终标度因子，其中 $N_i = \\ln a_i$，$N_f = \\ln a_f$。\n- 将能量密度初始化为 $\\rho(a_i) = \\rho_i$，并将所有输出表示为相对于 $\\rho_i$ 的无量纲量。不需要物理单位。\n\n解析检验：\n- 对于平滑模型 $w_{\\mathrm{smooth}}(N)$，其源项的积分是可以精确求解的。利用这一点提供 $\\rho(a_f)$ 的解析表达式，并与正则化积分器得到的数值结果进行比较。\n\n测试套件：\n用指定的参数实现并运行以下四个测试用例。在所有情况下，取 $\\rho_i = 1$ 和 $a_i = 10^{-4}$，因此 $N_i = \\ln(10^{-4})$；以及 $a_f = 1$，因此 $N_f = 0$。\n\n1. 正常路径正则化演化：\n   - $A = 0.2$, $N_c = -2.0$, $\\Delta = 0.2$, $h_{\\mathrm{reg}} = 0.01$。\n   - 使用正则化积分器计算最终的无量纲能量密度 $\\rho(a_f)$。\n\n2. 边界情况 $w = -1$：\n   - $A = 0.0$, $N_c = -2.0$, $\\Delta = 0.2$, $h_{\\mathrm{reg}} = 0.01$。\n   - 使用正则化积分器计算比率 $\\rho(a_f)/\\rho(a_i)$。\n\n3. 粗略朴素格式的不稳定性检查：\n   - $A = 1.0$, $N_c = -1.0$, $h_{\\mathrm{naive}} = 0.5$（对于阶跃模型，平滑宽度 $\\Delta$ 无关紧要）。\n   - 使用带有 $w_{\\mathrm{step}}(N)$ 的朴素显式欧拉格式进行演化。返回一个布尔值，指示是否有任何步骤产生了 $\\rho  0$ 的情况。\n\n4. 与解析解的精度检查：\n   - $A = 0.5$, $N_c = -2.0$, $\\Delta = 0.05$, $h_{\\mathrm{reg}} = 0.01$。\n   - 计算正则化数值解 $\\rho(a_f)$ 与从平滑模型导出的精确解析解 $\\rho(a_f)$ 之间的绝对相对误差。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个测试用例的结果，形式为用逗号分隔并用方括号括起来的列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。\n- 结果应按上述测试用例的顺序列出，分别为：一个浮点数、一个浮点数、一个布尔值和一个浮点数。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它在标准宇宙学模型中有科学依据，包含了所有必要的参数和定义，是自洽且适定的，能够为每个指定任务导出一个唯一且有意义的解。该问题解决了一个计算宇宙学中的相关数值挑战——流体密度在穿越魅影分界线（$w = -1$）时的稳定演化——并被构建为一个清晰、客观且可验证的练习。\n\n我们首先建立基本的理论框架。在 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中，对于能量密度为 $\\rho$、压强为 $p$ 的完美流体，其能量-动量守恒由连续性方程描述：\n$$\n\\dot{\\rho} + 3H(\\rho + p) = 0\n$$\n其中点号表示对宇宙时 $t$ 的导数，$H = \\dot{a}/a$ 是哈勃参数，$a$ 为标度因子。使用状态方程 $p(a) = w(a)\\rho(a)$，上式变为：\n$$\n\\dot{\\rho} + 3\\frac{\\dot{a}}{a}(1 + w(a))\\rho = 0\n$$\n整理各项可得：\n$$\n\\frac{d\\rho}{\\rho} = -3(1 + w(a))\\frac{da}{a}\n$$\n问题指定使用 e-折叠数 $N = \\ln a$ 作为自变量。其微分关系为 $dN = d(\\ln a) = da/a$。将此代入方程，得到能量密度作为 $N$ 的函数的主要常微分方程 (ODE)：\n$$\n\\frac{d\\rho}{\\rho dN} = -3(1 + w(N))\n$$\n这可以写作：\n$$\n\\frac{d\\rho}{dN} = -3(1 + w(N))\\rho(N)\n$$\n当 $w(N)$ 趋近于 $-1$ 时，会出现一个潜在的数值问题。如果以一种涉及除以 $(1+w)$ 的方式来构建问题，就会出现奇异点。如下文所示，使用显式数值方法直接演化 $\\rho$ 的“朴素”方法也可能导致不稳定性。\n\n一个更稳健的“正则化”方法，如问题所建议，是演化能量密度的对数 $y(N) = \\ln \\rho(N)$。对 $y(N)$ 关于 $N$ 求导可得：\n$$\n\\frac{dy}{dN} = \\frac{d(\\ln\\rho)}{dN} = \\frac{1}{\\rho}\\frac{d\\rho}{dN}\n$$\n代入我们之前得到的 $d\\rho/dN$ 的表达式，我们得到正则化的 ODE：\n$$\n\\frac{dy}{dN} = -3(1 + w(N))\n$$\n这种表述方式是有利的，因为等式右侧不再与被演化的变量 $\\rho$ 成正比。当 $w(N) \\to -1$ 时，导数 $dy/dN \\to 0$，这正确地意味着 $\\ln\\rho$（以及 $\\rho$）变为常数。该方程在穿越点上是稳定且非刚性的。\n\n对于正则化积分器，我们使用平滑的状态方程参数：\n$$\nw_{\\mathrm{smooth}}(N) = -1 + A\\tanh\\left(\\frac{N - N_c}{\\Delta}\\right)\n$$\n将此代入正则化的 ODE，得到：\n$$\n\\frac{dy}{dN} = -3\\left(1 + \\left(-1 + A\\tanh\\left(\\frac{N - N_c}{\\Delta}\\right)\\right)\\right) = -3A\\tanh\\left(\\frac{N - N_c}{\\Delta}\\right)\n$$\n这个 ODE $y'(N) = f(N)$，在区间 $N \\in [N_i, N_f]$ 上，使用初始条件 $y(N_i) = \\ln \\rho_i$ 和固定步长的四阶 Runge-Kutta (RK4) 格式进行数值求解。对于从 $N_k$ 到 $N_{k+1} = N_k + h_{\\mathrm{reg}}$ 的一步，更新公式为：\n$$\ny_{k+1} = y_k + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n其中 $f(N) = -3A\\tanh\\left(\\frac{N - N_c}{\\Delta}\\right)$ 并且\n$$\n\\begin{aligned}\nk_1 = h_{\\mathrm{reg}} f(N_k) \\\\\nk_2 = h_{\\mathrm{reg}} f(N_k + h_{\\mathrm{reg}}/2) \\\\\nk_3 = h_{\\mathrm{reg}} f(N_k + h_{\\mathrm{reg}}/2) \\\\\nk_4 = h_{\\mathrm{reg}} f(N_k + h_{\\mathrm{reg}})\n\\end{aligned}\n$$\n\n对于朴素比较器，我们使用带有不连续阶跃模型的 $\\rho(N)$ 的直接 ODE：\n$$\nw_{\\mathrm{step}}(N) = -1 + A\\,\\mathrm{sgn}(N - N_c)\n$$\n该 ODE 为：\n$$\n\\frac{d\\rho}{dN} = -3\\left(1 + \\left(-1 + A\\,\\mathrm{sgn}(N - N_c)\\right)\\right)\\rho = -3A\\,\\mathrm{sgn}(N - N_c)\\,\\rho\n$$\n步长为 $h_{\\mathrm{naive}}$ 的显式欧拉格式给出的更新规则是：\n$$\n\\rho_{k+1} = \\rho_k + h_{\\mathrm{naive}} \\left(-3A\\,\\mathrm{sgn}(N_k - N_c)\\,\\rho_k\\right) = \\rho_k \\left(1 - 3 A h_{\\mathrm{naive}}\\,\\mathrm{sgn}(N_k - N_c)\\right)\n$$\n如果不稳定性，例如能量密度变为非物理的负值（$\\rho  0$），可能在更新因子 $(1 - 3 A h_{\\mathrm{naive}}\\,\\mathrm{sgn}(N_k - N_c))$ 变为负数时发生。这是显式欧拉方法在处理某些 ODE 和步长时的已知局限性。对于测试用例 3，当 $A=1.0$ 且 $h_{\\mathrm{naive}}=0.5$ 时，该因子为 $1 - 1.5\\,\\mathrm{sgn}(N_k - N_c)$。对于任何满足 $N_k  N_c$ 的步骤，$\\mathrm{sgn}(\\cdot)=1$，因子为 $-0.5$，导致 $\\rho$ 改变符号并变为负值。\n\n最后，我们为平滑模型推导精确的解析解以进行精度检查。我们将正则化的 ODE 从 $N_i$ 积分到 $N_f$：\n$$\n\\int_{y(N_i)}^{y(N_f)} dy = \\int_{N_i}^{N_f} -3A\\tanh\\left(\\frac{N - N_c}{\\Delta}\\right) dN\n$$\n$$\n\\ln(\\rho(N_f)) - \\ln(\\rho(N_i)) = -3A\\Delta \\left[ \\ln\\left(\\cosh\\left(\\frac{N - N_c}{\\Delta}\\right)\\right) \\right]_{N_i}^{N_f}\n$$\n$$\n\\ln\\left(\\frac{\\rho(N_f)}{\\rho(N_i)}\\right) = -3A\\Delta \\left( \\ln\\left(\\cosh\\left(\\frac{N_f - N_c}{\\Delta}\\right)\\right) - \\ln\\left(\\cosh\\left(\\frac{N_i - N_c}{\\Delta}\\right)\\right) \\right)\n$$\n$$\n\\ln\\left(\\frac{\\rho(N_f)}{\\rho(N_i)}\\right) = 3A\\Delta \\ln\\left(\\frac{\\cosh\\left(\\frac{N_i - N_c}{\\Delta}\\right)}{\\cosh\\left(\\frac{N_f - N_c}{\\Delta}\\right)}\\right)\n$$\n对两边取指数，得到最终能量密度的精确解：\n$$\n\\rho(N_f) = \\rho(N_i) \\left( \\frac{\\cosh\\left(\\frac{N_i - N_c}{\\Delta}\\right)}{\\cosh\\left(\\frac{N_f - N_c}{\\Delta}\\right)} \\right)^{3A\\Delta}\n$$\n该表达式将用于在测试用例 4 中验证 RK4 积分器的精度。\n\n现在将根据这些推导，对四个测试用例中的每一个进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Executes the four test cases specified in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n\n    # --- Global Parameters ---\n    a_i = 1e-4\n    a_f = 1.0\n    rho_i = 1.0\n    \n    N_i = np.log(a_i)\n    N_f = np.log(a_f)\n\n    # --- Helper Functions ---\n\n    def run_regularized_rk4(A, Nc, Delta, h_reg):\n        \"\"\"\n        Implements the regularized integrator using a 4th-order Runge-Kutta scheme.\n        Evolves y = ln(rho) from N_i to N_f.\n        \"\"\"\n        y = np.log(rho_i) # Initial condition y_i = ln(rho_i)\n\n        # The right-hand side of the ODE dy/dN = f(N, y)\n        # In this regularized case, f is independent of y.\n        def f(N):\n            return -3.0 * A * np.tanh((N - Nc) / Delta)\n\n        # Determine the number of steps and create the grid of N values\n        num_steps = int(round((N_f - N_i) / h_reg))\n        N_vals = np.linspace(N_i, N_f, num_steps + 1)\n        # The actual step size resulting from the linspace grid\n        h_actual = N_vals[1] - N_vals[0]\n\n        for i in range(num_steps):\n            N_k = N_vals[i]\n            \n            # RK4 steps for y' = f(N)\n            k1 = h_actual * f(N_k)\n            k2 = h_actual * f(N_k + 0.5 * h_actual)\n            # Since f is independent of y, k2 and k3 are identical\n            k3 = k2 \n            k4 = h_actual * f(N_k + h_actual)\n            \n            y += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n        \n        return np.exp(y) # Return final rho = exp(y_f)\n\n    def run_naive_euler(A, Nc, h_naive):\n        \"\"\"\n        Implements the naive comparator using an explicit Euler scheme.\n        Evolves rho directly and checks for instability (rho  0).\n        \"\"\"\n        rho = rho_i\n        instability_detected = False\n\n        # The right-hand side of the ODE drho/dN = g(N, rho)\n        def g(N, current_rho):\n            # The problem specifies sgn(0)=0, which np.sign provides.\n            return -3.0 * A * np.sign(N - Nc) * current_rho\n            \n        num_steps = int(round((N_f - N_i) / h_naive))\n        N_vals = np.linspace(N_i, N_f, num_steps + 1)\n        h_actual = N_vals[1] - N_vals[0]\n\n        for i in range(num_steps):\n            N_k = N_vals[i]\n            \n            # Explicit Euler step\n            rho += h_actual * g(N_k, rho)\n            \n            if rho  0:\n                instability_detected = True\n                # We can break early as the condition is met.\n                break\n        \n        return instability_detected\n\n    def calculate_analytic(A, Nc, Delta):\n        \"\"\"\n        Calculates the exact final energy density using the derived analytic formula.\n        \"\"\"\n        # Exponent term\n        exponent = 3.0 * A * Delta\n        \n        # Numerator and denominator of the base\n        # Using cosh with large arguments is fine within float64 limits here.\n        num_arg = (N_i - Nc) / Delta\n        den_arg = (N_f - Nc) / Delta\n        \n        base = np.cosh(num_arg) / np.cosh(den_arg)\n        \n        rho_f_exact = rho_i * (base**exponent)\n        \n        return rho_f_exact\n\n    # --- Test Cases ---\n    results = []\n\n    # Case 1: Happy path regularized evolution\n    params_1 = {'A': 0.2, 'Nc': -2.0, 'Delta': 0.2, 'h_reg': 0.01}\n    rho_f_1 = run_regularized_rk4(**params_1)\n    results.append(rho_f_1)\n\n    # Case 2: Boundary case w = -1\n    params_2 = {'A': 0.0, 'Nc': -2.0, 'Delta': 0.2, 'h_reg': 0.01}\n    rho_f_2 = run_regularized_rk4(**params_2)\n    # The problem asks for the ratio rho(a_f)/rho(a_i)\n    ratio_2 = rho_f_2 / rho_i\n    results.append(ratio_2)\n\n    # Case 3: Instability check for a coarse naive scheme\n    params_3 = {'A': 1.0, 'Nc': -1.0, 'h_naive': 0.5}\n    instability_3 = run_naive_euler(**params_3)\n    results.append(instability_3)\n\n    # Case 4: Accuracy check against the analytic solution\n    params_4 = {'A': 0.5, 'Nc': -2.0, 'Delta': 0.05, 'h_reg': 0.01}\n    rho_f_numerical_4 = run_regularized_rk4(**params_4)\n    rho_f_analytic_4 = calculate_analytic(A=params_4['A'], Nc=params_4['Nc'], Delta=params_4['Delta'])\n    relative_error_4 = np.abs(rho_f_numerical_4 - rho_f_analytic_4) / rho_f_analytic_4\n    results.append(relative_error_4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3470966"}]}