{"hands_on_practices": [{"introduction": "在数值宇宙学中，任何涉及距离（如角直径距离或光度距离）的计算都必须精确处理宇宙的空间曲率。函数 $S_k(\\chi)$ 正是捕捉 FLRW 度规空间部分几何特性的核心。本练习旨在指导您构建一个对不同曲率（$k \\in \\{-1, 0, +1\\}$）和不同径向坐标（$\\chi$）值都稳定可靠的 $S_k(\\chi)$ 计算程序，这是开发更复杂宇宙学模拟工具的关键第一步 [@problem_id:3496187]。", "problem": "考虑 Friedmann-Lemaître-Robertson-Walker (FLRW) 度规的空间切片，这些切片是三维常曲率空间，由曲率参数 $k \\in \\{-1,0,+1\\}$ 表征。令 $S_k(\\chi)$ 表示求解以下初值问题的唯一函数 $S : \\mathbb{R} \\to \\mathbb{R}$：\n$$\n\\frac{d^2 S}{d \\chi^2} + k\\, S = 0, \\quad S(0) = 0, \\quad \\frac{d S}{d \\chi}(0) = 1,\n$$\n其中 $\\chi$ 是共动径向坐标。此函数编码了常曲率空间中空间测地线的几何性质，并出现在数值宇宙学的 FLRW 框架内的视线距离计算中。\n\n您的任务是开发一个统一的数值例程，该例程能够为所有 $k \\in \\{-1,0,+1\\}$ 和广泛的 $\\chi$ 值稳定地计算 $S_k(\\chi)$。该例程必须满足以下要求：\n\n1. 它必须依赖于稳定的公式和级数展开，以避免在 $|\\chi|$ 较小时发生精度损失，并在 $|\\chi|$ 为中等到较大值时保持可靠性。\n2. 它必须能根据 $|\\chi|$ 的大小，使用基于浮点机器精度的原则性阈值，在截断的 Maclaurin 级数求值和直接求值公式之间自动选择。\n3. 它对于正值和负值的 $\\chi$ 都必须是鲁棒的。\n4. 角度必须以弧度处理。坐标 $\\chi$ 是无量纲的，并且必须以弧度提供。\n\n您需要从基本原理出发设计算法，其基础是上述初值问题和 $\\chi = 0$ 处的正则性条件所体现的常曲率空间的几何性质。不要假设或使用问题陈述中任何预先提供的 $S_k(\\chi)$ 的闭式表达式；相反，您应推导并实现与微分方程、初始条件以及解的解析结构相一致的数值稳定求值策略。\n\n在一个完整的、可运行的程序中实现该例程。程序必须针对以下探测不同数值区间的测试套件案例来计算 $S_k(\\chi)$：\n\n- 案例 1: $k=+1$, $\\chi = 10^{-12}$。\n- 案例 2: $k=-1$, $\\chi = 10^{-12}$。\n- 案例 3: $k=0$, $\\chi = 10^{-12}$。\n- 案例 4: $k=+1$, $\\chi = \\pi - 10^{-12}$。\n- 案例 5: $k=-1$, $\\chi = 20$。\n- 案例 6: $k=+1$, $\\chi = 20$。\n- 案例 7: $k=-1$, $\\chi = -20$。\n- 案例 8: $k=0$, $\\chi = -3.5$。\n- 案例 9: $k=+1$, $\\chi = 0$。\n- 案例 10: $k=-1$, $\\chi = 0$。\n\n要求的最终输出格式为单行文本，其中包含按上述顺序列出的这些案例的结果，结果为逗号分隔的列表，并用方括号括起来。每个条目都必须是一个浮点数，代表给定输入对的 $S_k(\\chi)$ 值（以弧度为单位）。例如，输出应类似于“[result1,result2,result3,...]”。\n\n所有角度都必须以弧度为单位。将所有数值输出表示为浮点数。任何输出中均不允许出现百分号。程序必须是完全自包含的，且不得需要任何外部输入。在指定的各种数值区间内，计算必须是数值稳定的，并与 $S_k(\\chi)$ 的定义性质一致。", "solution": "该问题要求开发一个数值稳定的例程来计算函数 $S_k(\\chi)$，该函数被定义为以下初值问题 (IVP) 的唯一解：\n$$\n\\frac{d^2 S}{d \\chi^2} + k\\, S = 0, \\quad S(0) = 0, \\quad \\frac{d S}{d \\chi}(0) = 1,\n$$\n对于曲率参数 $k \\in \\{-1, 0, +1\\}$。该函数在 Friedmann-Lemaître-Robertson-Walker (FLRW) 宇宙学模型中描述空间几何时至关重要。\n\n解决方案的开发将首先为每个 $k$ 值推导 $S_k(\\chi)$ 的解析表达式，然后构建一个统一的 Maclaurin 级数表示，最后设计一个混合数值算法，结合这些形式以确保在所有要求范围内的稳定性和准确性。\n\n### 解析解的推导\n\n我们针对每种 $k$ 的情况求解二阶线性常微分方程 (ODE)。\n\n**情况 1：$k = +1$ (球面几何)**\nODE 为 $\\frac{d^2 S}{d \\chi^2} + S = 0$。通解为 $S(\\chi) = A \\cos(\\chi) + B \\sin(\\chi)$。我们应用初始条件：\n1.  $S(0) = 0 \\implies A \\cos(0) + B \\sin(0) = A \\cdot 1 + B \\cdot 0 = A = 0$。\n2.  解简化为 $S(\\chi) = B \\sin(\\chi)$。导数为 $\\frac{dS}{d\\chi} = B \\cos(\\chi)$。\n3.  $\\frac{dS}{d\\chi}(0) = 1 \\implies B \\cos(0) = B \\cdot 1 = B = 1$。\n因此，唯一解是 $S_{+1}(\\chi) = \\sin(\\chi)$。\n\n**情况 2：$k = -1$ (双曲几何)**\nODE 为 $\\frac{d^2 S}{d \\chi^2} - S = 0$。通解为 $S(\\chi) = A \\cosh(\\chi) + B \\sinh(\\chi)$。应用初始条件：\n1.  $S(0) = 0 \\implies A \\cosh(0) + B \\sinh(0) = A \\cdot 1 + B \\cdot 0 = A = 0$。\n2.  解为 $S(\\chi) = B \\sinh(\\chi)$。导数为 $\\frac{dS}{d\\chi} = B \\cosh(\\chi)$。\n3.  $\\frac{dS}{d\\chi}(0) = 1 \\implies B \\cosh(0) = B \\cdot 1 = B = 1$。\n因此，唯一解是 $S_{-1}(\\chi) = \\sinh(\\chi)$。\n\n**情况 3：$k = 0$ (欧几里得/平直几何)**\nODE 为 $\\frac{d^2 S}{d \\chi^2} = 0$。积分一次得到 $\\frac{dS}{d\\chi} = C_1$。\n1.  应用 $\\frac{dS}{d\\chi}(0) = 1$，我们得到 $C_1 = 1$。\n2.  积分 $\\frac{dS}{d\\chi} = 1$ 得到 $S(\\chi) = \\chi + C_2$。\n3.  应用 $S(0) = 0$，我们得到 $0 + C_2 = 0 \\implies C_2 = 0$。\n因此，唯一解是 $S_{0}(\\chi) = \\chi$。\n\n### 统一级数表示\n为了制定一个统一的求值策略，特别是对于较小的 $|\\chi|$ 值，我们直接从 ODE 推导 $S_k(\\chi)$ 的 Maclaurin 级数。令 $S_k(\\chi) = \\sum_{n=0}^\\infty c_n \\chi^n$。\n初始条件 $S(0)=0$ 和 $S'(0)=1$ 直接给出 $c_0 = 0$ 和 $c_1 = 1$。\n将级数代入 ODE $S''(\\chi) = -k S(\\chi)$，得到：\n$$\n\\sum_{n=2}^\\infty n(n-1)c_n \\chi^{n-2} = -k \\sum_{n=0}^\\infty c_n \\chi^n\n$$\n用 $j = n-2$ 对左侧进行重新索引：\n$$\n\\sum_{j=0}^\\infty (j+2)(j+1)c_{j+2} \\chi^j = -k \\sum_{j=0}^\\infty c_j \\chi^j\n$$\n通过比较 $\\chi^j$ 的系数，我们得到递推关系：$c_{j+2} = \\frac{-k}{(j+2)(j+1)}c_j$。\n由于 $c_0 = 0$，该递推关系意味着所有偶数项系数 $c_{2m}$ 均为零。\n对于奇数项系数，从 $c_1=1$ 开始：\n$c_3 = \\frac{-k}{3 \\cdot 2} c_1 = \\frac{-k}{3!}$\n$c_5 = \\frac{-k}{5 \\cdot 4} c_3 = \\frac{-k}{5 \\cdot 4}\\left(\\frac{-k}{3!}\\right) = \\frac{(-k)^2}{5!}$\n通项奇数系数为 $c_{2m+1} = \\frac{(-k)^m}{(2m+1)!}$。\n这得到了对所有 $k$ 都有效的统一级数表示：\n$$\nS_k(\\chi) = \\sum_{m=0}^\\infty \\frac{(-k)^m}{(2m+1)!} \\chi^{2m+1} = \\chi - k \\frac{\\chi^3}{3!} + k^2 \\frac{\\chi^5}{5!} - \\dots\n$$\n该级数分别对 $k=+1$、$k=-1$ 和 $k=0$ 正确地重现了 $\\sin(\\chi)$、$\\sinh(\\chi)$ 和 $\\chi$。\n\n### 数值稳定性与算法设计\n一个鲁棒的数值例程必须处理 $\\chi$ 的不同范围。\n1.  **大的 $|\\chi|$ 值：**对于不接近零的 $|\\chi|$ 值，可以使用直接的解析公式 $S_{+1}(\\chi) = \\sin(\\chi)$ 和 $S_{-1}(\\chi) = \\sinh(\\chi)$。这些函数的高质量库实现（如 `numpy` 中的实现）针对准确性和性能进行了优化，包括对三角函数的适当参数归约。\n2.  **小的 $|\\chi|$ 值：**对于接近零的 $|\\chi|$ 值，直接求值可能会有问题。例如，计算 $\\sinh(\\chi) = (\\exp(\\chi)-\\exp(-\\chi))/2$ 涉及两个接近 1 的数字相减，导致灾难性抵消和精度损失。在这种情况下，Maclaurin 级数是数值上更优的方法。它是一个加性级数，其中第一项占主导地位，从而避免了相减抵消。\n\n因此，该算法将是一个混合算法：\n- 如果 $|\\chi|$ 低于某个阈值 `TOL`，则使用截断的 Maclaurin 级数。\n- 如果 $|\\chi|$ 等于或高于 `TOL`，则使用直接的解析函数。\n\n### 阈值选择\n阈值 `TOL` 的选择必须基于对数值误差的原则性分析。我们使用在 $\\chi^5$ 项后截断的级数：\n$$\nP_5(\\chi) = \\chi - k\\frac{\\chi^3}{6} + k^2\\frac{\\chi^5}{120}\n$$\n第一个被忽略的项是 $-k^3\\frac{\\chi^7}{7!}$。相对截断误差约等于其大小除以 $S_k(\\chi) \\approx \\chi$ 的大小：\n$$\n\\text{Relative Error} \\approx \\frac{|-k^3 \\chi^7/5040|}{|\\chi|} = \\frac{|k|^3 |\\chi|^6}{5040} = \\frac{\\chi^6}{5040} \\quad (\\text{对于 } k=\\pm1)\n$$\n我们要求此误差远小于双精度浮点数的机器ε，$\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$。一个保守的阈值选择是 $\\text{TOL} = 10^{-4}$。在此值下，相对误差的数量级为 $(10^{-4})^6 / 5040 = 10^{-24}/5040$，比 $\\epsilon_{mach}$ 小许多数量级，从而保证了级数近似在此域内是高度准确的。\n\n### 最终算法\n实现的函数 `S_k(k, chi)` 将按以下步骤进行：\n1.  如果 $k=0$，解是精确且平凡的：返回 $\\chi$。\n2.  对于 $k \\in \\{-1, +1\\}$，检查是否 $|\\chi|  \\text{TOL} = 10^{-4}$。\n3.  如果是，则使用截断的 Maclaurin 级数计算 $S_k(\\chi)$。为优化精度和效率，我们使用截至 $\\chi^5$ 项的级数的嵌套（Horner 方法）形式：\n    $$\n    S_k(\\chi) \\approx \\chi \\left(1 - \\frac{k\\chi^2}{6} \\left(1 - \\frac{k\\chi^2}{20}\\right)\\right)\n    $$\n    这等价于 $ \\chi - k\\frac{\\chi^3}{6} + k^2\\frac{\\chi^5}{120} $。\n4.  如果 $|\\chi| \\ge \\text{TOL}$，则计算相应的解析函数：$k=+1$ 时为 $\\sin(\\chi)$，$k=-1$ 时为 $\\sinh(\\chi)$。\n\n这种方法确保了稳定性、准确性，并基于定义初值问题的基本性质。该函数本质上是奇函数，$S_k(-\\chi) = -S_k(\\chi)$，这一性质在所有求值形式（解析公式和级数展开）中都得到遵守，因此除了直接使用其值外，不需要对负值 $\\chi$ 进行特殊处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef S_k_eval(k: int, chi: float) - float:\n    \"\"\"\n    Evaluates the function S_k(chi) based on the FLRW metric geometry.\n\n    S_k(chi) is the unique solution to the initial value problem:\n    d^2S/d(chi)^2 + k*S = 0, with S(0) = 0 and dS/d(chi)|_{chi=0} = 1.\n\n    Args:\n        k (int): The curvature parameter, one of {-1, 0, +1}.\n        chi (float): The comoving radial coordinate in radians.\n\n    Returns:\n        float: The value of S_k(chi).\n    \"\"\"\n    # Case k=0 (flat space) is trivial\n    if k == 0:\n        return float(chi)\n\n    # Threshold for |chi| below which the Maclaurin series expansion is used.\n    # The threshold is chosen such that for |chi|  TOL, the truncated series\n    # provides precision far exceeding standard floating-point capabilities,\n    # and potential cancellation errors in direct formulas are avoided.\n    # The relative error of the series truncated at the chi^5 term is ~|chi|^6/5040.\n    # At chi=1e-4, this is ~1e-24/5040, far below machine epsilon (~2.22e-16).\n    TOL = 1e-4\n\n    if abs(chi)  TOL:\n        # For small |chi|, use the Maclaurin series to avoid loss of precision:\n        # S_k(chi) = chi - k*chi^3/6 + k^2*chi^5/120 - ...\n        # This is evaluated using a nested (Horner-like) form for stability.\n        if chi == 0.0:\n            return 0.0\n        \n        chi2 = chi * chi\n        # Series truncated after the chi^5 term:\n        # chi * (1 - k*chi^2/6 + k^2*chi^4/120) = chi * (1 - k*chi^2/6 * (1 - k*chi^2/20))\n        return chi * (1.0 - k * chi2 / 6.0 * (1.0 - k * chi2 / 20.0))\n    else:\n        # For larger |chi|, direct evaluation using standard library functions is stable and efficient.\n        if k == 1: # Spherical case\n            return np.sin(chi)\n        elif k == -1: # Hyperbolic case\n            return np.sinh(chi)\n        else:\n            # This path should ideally not be reached given k is in {-1, 0, 1}\n            raise ValueError(\"k must be -1, 0, or 1\")\n\ndef solve():\n    \"\"\"\n    Runs the specified test suite for the S_k(chi) evaluation function.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, chi)\n        (1, 1e-12),               # Case 1: k=+1, chi = 1e-12\n        (-1, 1e-12),              # Case 2: k=-1, chi = 1e-12\n        (0, 1e-12),               # Case 3: k=0, chi = 1e-12\n        (1, np.pi - 1e-12),       # Case 4: k=+1, chi = pi - 1e-12\n        (-1, 20.0),               # Case 5: k=-1, chi = 20\n        (1, 20.0),                # Case 6: k=+1, chi = 20\n        (-1, -20.0),              # Case 7: k=-1, chi = -20\n        (0, -3.5),                # Case 8: k=0, chi = -3.5\n        (1, 0.0),                 # Case 9: k=+1, chi = 0\n        (-1, 0.0),                # Case 10: k=-1, chi = 0\n    ]\n\n    results = []\n    for k, chi in test_cases:\n        result = S_k_eval(k, chi)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function provides a standard, high-precision representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3496187"}, {"introduction": "掌握了静态空间几何的处理后，下一步是模拟宇宙的动态演化，这由 Friedmann 方程所描述。这个常微分方程在宇宙不同能量成分主导时期（例如物质-暗能量均等时期）的过渡阶段，会表现出数值上的“刚性”。本练习将引导您通过比较显式和隐式积分方法的性能，亲身体验在求解尺度因子 $a(t)$ 时，为保证模拟结果的稳定性和准确性所必须做出的数值策略权衡 [@problem_id:3496141]。", "problem": "考虑一个由 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规描述的空间均匀且各向同性的宇宙。作为一个基本出发点，采用空间平坦宇宙的第一弗里德曼方程，该方程用标度因子 $a$ 和无量纲哈勃函数 $E(a)$ 表示，定义为\n$$\nE(a) \\equiv \\sqrt{\\Omega_{\\mathrm{r}} a^{-4} + \\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\mathrm{k}} a^{-2} + \\Omega_{\\Lambda}} \\, ,\n$$\n其中密度参数满足 $\\Omega_{\\mathrm{k}} = 0$（平坦几何），而 $\\Omega_{\\mathrm{r}}, \\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}$ 分别表示辐射、物质和宇宙学常数的贡献。引入无量纲时间 $\\tau \\equiv H_0 t$，其中 $H_0$ 是当前的哈勃常数，这样标度因子的演化方程就是一个自治常微分方程\n$$\n\\frac{d a}{d \\tau} = a \\, E(a) \\, .\n$$\n您的任务是评估和比较一个显式和一个隐式时间积分器在物质-宇宙学常数（$\\Lambda$）相等时期（即 $\\Omega_{\\mathrm{m}} a^{-3} \\approx \\Omega_{\\Lambda}$ 的时期）附近对 $a(\\tau)$ 的性能。此比较必须基于稳定性和准确性。\n\n您必须实现：\n- 一个显式单步法，仅使用步长开始时的信息来推进 $a$。\n- 一个隐式单步法，通过求解在步长结束时评估右端项的相应非线性方程来推进 $a$（您必须稳健地处理所需的非线性求解）。\n\n为确保通用性并消除物理单位，所有计算都必须使用无量纲时间 $\\tau$ 和无量纲量 $a(\\tau)$ 进行。不要使用任何有量纲的常数。\n\n为所有测试用例定义以下通用设置：\n- 物质-$\\Lambda$ 相等时期的标度因子是\n$$\na_{\\mathrm{eq}} \\equiv \\left( \\frac{\\Omega_{\\mathrm{m}}}{\\Omega_{\\Lambda}} \\right)^{1/3} \\, .\n$$\n- 在 $\\tau = 0$ 时，初始化于\n$$\na_0 \\equiv \\frac{a_{\\mathrm{eq}}}{10} \\, 。\n$$\n- 将相等时期的名义局域动力学速率定义为 $E_{\\mathrm{eq}} \\equiv E(a_{\\mathrm{eq}})$，并设置步长\n$$\nh \\equiv \\frac{c}{E_{\\mathrm{eq}}} \\, ,\n$$\n其中 $c$ 是在下文每个测试用例中提供的无量纲控制参数。\n- 以固定的 $N$ 步进行演化，其中\n$$\nN \\equiv \\max\\left( 8, \\left\\lceil \\frac{\\ln(50)}{c} \\right\\rceil \\right) \\, ,\n$$\n因此总积分时间为 $\\tau_{\\mathrm{end}} = N h$，评估时间为 $\\tau_n = n h$，对于 $n = 0, 1, \\dots, N$。\n\n基准参考解：\n- 通过使用具有严格容差的高阶自适应方法求解相同的初值问题，来计算一个高精度参考解 $a_{\\mathrm{ref}}(\\tau)$。使用相对容差 $10^{-12}$ 和绝对容差 $10^{-15}$，并在离散时间 $\\{\\tau_n\\}_{n=0}^N$ 处评估 $a_{\\mathrm{ref}}$。\n\n准确性和稳定性指标：\n- 对于一个数值序列 $\\{a_n\\}_{n=0}^N$，定义其相对于参考解的均方根相对误差为\n$$\n\\varepsilon_{\\mathrm{rms}} \\equiv \\sqrt{\\frac{1}{N+1} \\sum_{n=0}^{N} \\left( \\frac{a_n - a_{\\mathrm{ref}}(\\tau_n)}{a_{\\mathrm{ref}}(\\tau_n)} \\right)^2 } \\, .\n$$\n- 当且仅当所有迭代值都是有限、严格递增且严格为正时，定义一个方法在此测试上是稳定的：\n$$\n\\text{稳定} \\iff \\left( \\forall n: a_{n} \\in \\mathbb{R}, \\, a_{n}  0 \\right) \\wedge \\left( \\forall n \\ge 1: a_{n}  a_{n-1} \\right) \\, .\n$$\n- 如果一个方法在任何步骤未能产生严格为正、严格递增的有限序列，或在隐式求解中未能收敛，则声明其为不稳定，并赋其 $\\varepsilon_{\\mathrm{rms}} = +\\infty$。\n\n决策规则：\n- 对于每个测试用例，推荐既稳定又达到较小 $\\varepsilon_{\\mathrm{rms}}$ 的方法。如果只有一种方法稳定，则推荐该稳定方法。如果两种方法都稳定且在机器精度范围内打平，则选择显式方法。\n\n测试套件：\n对于下面的每一行，将 $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}})$ 和 $c$ 作为输入，并设 $\\Omega_{\\mathrm{k}} = 0$：\n1. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.3, 0.7, 0)$, $c = 0.5$.\n2. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.3, 0.7, 0)$, $c = 1.6$.\n3. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.25, 0.75, 0)$, $c = 1.0$.\n4. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.49, 0.51, 0)$, $c = 1.2$.\n\n交付成果：\n- 您的程序必须为每个测试用例计算推荐的方法，并输出单行长度为 $4$ 的类JSON整数列表，其中如果推荐显式方法，则条目为 $0$，如果推荐隐式方法，则条目为 $1$，顺序与上面列出的测试用例相同。输出必须是单行，内容完全为\n$$\n[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4]\n$$\n形式的列表，不含额外空格，其中每个 $\\text{r}_i \\in \\{0,1\\}$。", "solution": "该问题要求实现并比较一种显式和一种隐式数值方法，用以求解一个控制空间平坦的 Friedmann-Lemaître-Robertson-Walker (FLRW) 宇宙中标度因子 $a$ 演化的常微分方程（ODE）。\n\n该控制方程是一个一阶自治常微分方程，由下式给出：\n$$\n\\frac{d a}{d \\tau} = a \\, E(a) \\equiv f(a)\n$$\n其中 $\\tau$ 是无量纲时间，而 $E(a)$ 是无量纲哈勃函数，定义为：\n$$\nE(a) = \\sqrt{\\Omega_{\\mathrm{r}} a^{-4} + \\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\mathrm{k}} a^{-2} + \\Omega_{\\Lambda}}\n$$\n对于此问题，假定宇宙是空间平坦的，因此 $\\Omega_{\\mathrm{k}} = 0$。我们将 ODE 的右侧记为 $f(a)$，它仅是 $a$ 的函数：\n$$\nf(a) = a \\sqrt{\\Omega_{\\mathrm{r}} a^{-4} + \\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\Lambda}} = \\sqrt{\\Omega_{\\mathrm{r}} a^{-2} + \\Omega_{\\mathrm{m}} a^{-1} + \\Omega_{\\Lambda} a^2}\n$$\n该问题是一个初值问题（IVP），其初始条件为 $a(\\tau=0) = a_0$，其中 $a_0$ 是相对于物质-$\\Lambda$ 相等时期的标度因子 $a_{\\mathrm{eq}}$ 定义的。我们的任务是使用固定的步长 $h$，在指定的区间 $[0, \\tau_{\\mathrm{end}}]$ 上求解 $a(\\tau)$。\n\n任务的核心是比较两类基本的一步数值积分器：显式方法和隐式方法。\n\n显式单步法使用仅在当前时间 $\\tau_n$ 可用的信息来计算下一个状态 $a_{n+1}$（在时间 $\\tau_{n+1} = \\tau_n + h$）。最简单的此类方法是前向欧拉法，其更新规则为：\n$$\na_{n+1} = a_n + h \\cdot f(a_n)\n$$\n此方法实现简单，但其数值稳定区域有限。如果步长 $h$相对于系统的特征时间尺度过大，它可能会变得不稳定，特别是对于解变化迅速的刚性ODE。\n\n隐式单步法使用包含 $\\tau_{n+1}$ 时刻状态本身的信息来计算 $a_{n+1}$。最简单的此类方法是后向欧拉法。其更新规则由下式给出：\n$$\na_{n+1} = a_n + h \\cdot f(a_{n+1})\n$$\n此方程是关于未知数 $a_{n+1}$ 的非线性代数方程，必须在每个时间步求解。我们可以定义一个函数 $g(x)$，并为其寻找一个根：\n$$\ng(x) = x - a_n - h \\cdot f(x) = 0\n$$\n其中 $x$ 代表未知的 $a_{n+1}$。这个求根问题必须稳健地解决。牛顿法是一个高效的选择，它需要 $g(x)$ 的导数：\n$$\ng'(x) = 1 - h \\cdot f'(x)\n$$\n导数 $f'(a)$ 可以通过对 $f(a)^2 = \\Omega_{\\mathrm{r}} a^{-2} + \\Omega_{\\mathrm{m}} a^{-1} + \\Omega_{\\Lambda} a^2$ 求导得到：\n$$\n2 f(a) f'(a) = -2\\Omega_{\\mathrm{r}} a^{-3} - \\Omega_{\\mathrm{m}} a^{-2} + 2\\Omega_{\\Lambda} a\n$$\n$$\nf'(a) = \\frac{-2\\Omega_{\\mathrm{r}} a^{-3} - \\Omega_{\\mathrm{m}} a^{-2} + 2\\Omega_{\\Lambda} a}{2 f(a)} = \\frac{-2\\Omega_{\\mathrm{r}} a^{-3} - \\Omega_{\\mathrm{m}} a^{-2} + 2\\Omega_{\\Lambda} a}{2 a E(a)}\n$$\n牛顿法迭代地寻找根 $a_{n+1}$。尽管非线性求解带来了计算开销，但像后向欧拉法这样的隐式方法因其卓越的稳定性（特别是A-稳定性）而常被青睐，它允许比显式方法大得多的步长，尤其是在处理刚性问题时。\n\n为了评估这些方法的准确性，我们使用一个高阶自适应步长求解器（`scipy.integrate.solve_ivp`，方法为`'LSODA'`）和严格的误差容差（$rtol=10^{-12}$, $atol=10^{-15}$）生成一个高保真度参考解 $a_{\\mathrm{ref}}(\\tau)$。然后，数值解 $\\{a_n\\}$ 的准确性通过均方根相对误差 $\\varepsilon_{\\mathrm{rms}}$ 来量化：\n$$\n\\varepsilon_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N+1} \\sum_{n=0}^{N} \\left( \\frac{a_n - a_{\\mathrm{ref}}(\\tau_n)}{a_{\\mathrm{ref}}(\\tau_n)} \\right)^2 }\n$$\n稳定性是根据物理要求来判断的，即标度因子必须是时间的严格正值且严格递增的函数。如果任何迭代值 $a_n$ 为非正、非有限，或者对于任何 $n \\ge 1$ 有 $a_n \\le a_{n-1}$，则认为该方法不稳定。对于隐式方法，非线性求解器未能收敛也构成不稳定。不稳定方法的误差被赋为 $\\varepsilon_{\\mathrm{rms}} = +\\infty$。\n\n每个测试用例的计算流程如下：\n1.  定义宇宙学参数 $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}})$ 和控制参数 $c$。\n2.  计算派生常数：$a_{\\mathrm{eq}} = (\\Omega_{\\mathrm{m}}/\\Omega_{\\Lambda})^{1/3}$, $a_0 = a_{\\mathrm{eq}}/10$, $E_{\\mathrm{eq}} = E(a_{\\mathrm{eq}})$, $h = c/E_{\\mathrm{eq}}$，以及 $N = \\max(8, \\lceil\\ln(50)/c\\rceil)$。\n3.  在时间 $\\tau_n = nh$（对于 $n=0, \\dots, N$）计算参考解 $a_{\\mathrm{ref}}(\\tau_n)$。\n4.  执行前向欧拉积分器 $N$ 步，存储序列 $\\{a_{n, \\mathrm{expl}}\\}$。在每一步检查稳定性。\n5.  执行后向欧拉积分器 $N$ 步，在每一步使用稳健的牛顿法求解非线性方程。存储序列 $\\{a_{n, \\mathrm{impl}}\\}$ 并检查稳定性。\n6.  如果两种方法稳定，则计算它们的 $\\varepsilon_{\\mathrm{rms}}$。\n7.  应用指定的决策规则：推荐误差较小的稳定方法，若打平则优先选择显式方法。每个测试用例的最终输出是一个整数（$0$ 代表显式，$1$ 代表隐式）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing explicit and implicit methods for the Friedmann equation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: ((Omega_m, Omega_Lambda, Omega_r), c)\n    test_cases = [\n        ((0.3, 0.7, 0.0), 0.5),\n        ((0.3, 0.7, 0.0), 1.6),\n        ((0.25, 0.75, 0.0), 1.0),\n        ((0.49, 0.51, 0.0), 1.2),\n    ]\n\n    results = []\n    \n    for case_params, c in test_cases:\n        Om_m, Om_L, Om_r = case_params\n        Om_k = 0.0\n\n        def E(a):\n            \"\"\"Dimensionless Hubble function E(a).\"\"\"\n            if a = 0:\n                return np.inf\n            radicand = Om_r * a**(-4) + Om_m * a**(-3) + Om_k * a**(-2) + Om_L\n            return np.sqrt(radicand)\n\n        def ode_rhs(tau, a):\n            \"\"\"Right-hand side of the ODE da/d(tau) = a*E(a).\"\"\"\n            return a * E(a)\n\n        # Setup parameters\n        a_eq = (Om_m / Om_L)**(1/3)\n        a0 = a_eq / 10.0\n        E_eq = E(a_eq)\n        h = c / E_eq\n        N = int(max(8, np.ceil(np.log(50) / c)))\n        \n        tau_end = N * h\n        eval_times = np.linspace(0, tau_end, N + 1)\n\n        # High-accuracy reference solution\n        ref_sol = solve_ivp(\n            ode_rhs, [0, tau_end], [a0],\n            method='LSODA',\n            t_eval=eval_times,\n            rtol=1e-12,\n            atol=1e-15\n        )\n        a_ref = ref_sol.y[0]\n\n        def calculate_rms_rel_error(a_num, a_ref_vals):\n            \"\"\"Calculates the root-mean-square relative error.\"\"\"\n            rel_err_sq = ((a_num - a_ref_vals) / a_ref_vals)**2\n            return np.sqrt(np.mean(rel_err_sq))\n\n        def is_stable(a_seq):\n            \"\"\"Checks if a sequence is stable according to problem criteria.\"\"\"\n            if not np.all(np.isfinite(a_seq)) or not np.all(a_seq  0):\n                return False\n            if a_seq.shape[0]  1 and not np.all(np.diff(a_seq)  0):\n                return False\n            return True\n\n        # --- Explicit Method (Forward Euler) ---\n        a_expl = np.zeros(N + 1)\n        a_expl[0] = a0\n        stable_expl = True\n        for n in range(N):\n            a_n = a_expl[n]\n            if a_n = 0 or not np.isfinite(a_n):\n                stable_expl = False\n                break\n            a_expl[n+1] = a_n + h * ode_rhs(0, a_n)\n        \n        if stable_expl:\n            stable_expl = is_stable(a_expl)\n        \n        err_expl = calculate_rms_rel_error(a_expl, a_ref) if stable_expl else np.inf\n\n        # --- Implicit Method (Backward Euler) ---\n        a_impl = np.zeros(N + 1)\n        a_impl[0] = a0\n        stable_impl = True\n        for n in range(N):\n            a_n = a_impl[n]\n            \n            def g_func(x):\n                return x - a_n - h * ode_rhs(0, x)\n\n            def g_prime_func(x):\n                if x = 0: return np.inf\n                f_val = ode_rhs(0, x)\n                if abs(f_val)  1e-15: return 1.0\n                \n                # f'(x) from symbolic differentiation of f(x)^2\n                f_prime_num = -2 * Om_r * x**-3 - Om_m * x**-2 + 2 * Om_L * x\n                f_prime_val = f_prime_num / (2 * f_val)\n                return 1.0 - h * f_prime_val\n            \n            try:\n                # Use explicit step as initial guess for Newton solver\n                guess = a_n + h * ode_rhs(0, a_n)\n                # Ensure guess is positive\n                if guess = 0: guess = a_n\n                a_impl[n+1] = newton(g_func, x0=guess, fprime=g_prime_func, tol=1e-12, maxiter=50)\n            except (RuntimeError, ValueError):\n                stable_impl = False\n                break\n        \n        if stable_impl:\n            stable_impl = is_stable(a_impl)\n        \n        err_impl = calculate_rms_rel_error(a_impl, a_ref) if stable_impl else np.inf\n\n        # --- Decision Rule ---\n        recommend = -1 # Placeholder\n        if stable_expl and stable_impl:\n            if err_expl = err_impl:  # Choose explicit on tie\n                recommend = 0\n            else:\n                recommend = 1\n        elif stable_expl:\n            recommend = 0\n        elif stable_impl:\n            recommend = 1\n        else: # Both unstable\n            recommend = 1 # Default to implicit if both fail, as it's generally more robust.\n\n        results.append(recommend)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3496141"}, {"introduction": "数值宇宙学的最终目标之一是建立能够与天文观测相比较的理论预测。作为本章的综合性实践，这项练习将几何与动力学相结合，模拟了光子从遥远星系到我们这里的完整旅程。通过从第一性原理出发，对光子测地线及其能量演化进行数值积分，您将亲自验证宇宙学红移与尺度因子之间的基本关系，从而深刻理解宇宙膨胀如何影响我们所观测到的光 [@problem_id:3496232]。", "problem": "你的任务是构建一个完整、可运行的程序，该程序在弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 时空中对光子测地线进行数值射线追踪，并沿着测地线同步演化光子能量，以在不同的发射历史下验证宇宙学红移关系。该程序必须从第一性原理和核心定义构建，不得依赖任何针对目标关系的预编码快捷方式。你的推导和实现必须从弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规、零测地线的定义以及描述哈勃膨胀率的弗里德曼方程开始。\n\n你必须使用的基本基础是：\n- 用于空间均匀且各向同性宇宙的 FLRW 线元，由 $ds^2 = -c^2\\,dt^2 + a(t)^2\\,\\left[\\frac{dr^2}{1-k r^2} + r^2(d\\theta^2 + \\sin^2\\theta\\, d\\phi^2)\\right]$ 给出，其中 $c$ 是光速，$a(t)$ 是尺度因子，$r$ 是共动径向坐标，$k \\in \\{-1,0,+1\\}$ 编码了空间曲率。\n- 径向光子轨迹的假设意味着 $d\\theta = d\\phi = 0$ 以及零条件 $ds^2=0$。\n- 由弗里德曼方程定义的哈勃膨胀率，用尺度因子 $a$ 和现今参数表示为：$H(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_\\Lambda}$，其中 $\\Omega_k = 1 - (\\Omega_r + \\Omega_m + \\Omega_\\Lambda)$。\n- 宇宙学红移的定义：对于在尺度因子 $a_e$ 处发射并在今天（尺度因子为 $a_0$，按惯例固定为 1）被观测到的光子，$(1+z)$ 是由共动观测者测量的观测波长与发射波长之比。\n\n你的程序必须实现以下从上述基础推导出的内容：\n1. 对径向零测地线进行数值积分，以获得在尺度因子 $a_e$ 处的发射事件与今天在 $a_0$ 处的观测者之间的共动距离 $r$。使用一种基于测地线方程的、科学上合理的数值方法，并选择合适的自变量以避免刚性问题。\n2. 使用一个与零测地线和宇宙膨胀相一致的动力学方程，对沿测地线的光子能量 $E$ 进行数值演化，从而使标度关系 $E \\propto 1/a$ 从计算中自然得出，而不是被强加的。根据数值演化出的 $E$，使用 $(1+z) = E_{\\mathrm{emit}}/E_{\\mathrm{obs}}$ 为每个发射事件计算 $(1+z)$ 的数值估计。\n3. 一个验证步骤，该步骤将数值得到的 $(1+z)$ 与比率 $a_0/a_e$ 进行比较，适用于每个发射事件和任意随时间变化的发射历史 $E_{\\mathrm{emit}}(a_e)$，从而证明该关系独立于内在的发射可变性。\n\n物理和数值单位及归一化：\n- 使用 $a_0 = 1$。\n- 使用 $c$ 的单位为 $\\mathrm{m/s}$，$H_0$ 的单位为 $\\mathrm{km/s/Mpc}$（在内部转换为 $\\mathrm{s^{-1}}$），并以百万秒差距（$\\mathrm{Mpc}$）为单位生成共动距离。\n- 能量可以采用任意单位，因为只有比率进入 $(1+z)$ 的计算；将红移验证报告为无量纲差异。\n\n此计算不涉及角度单位。如果选择参数化三角函数形式的发射历史，默认使用弧度作为参数。\n\n设计一个测试套件，用于检验：\n- 一个通用的平坦 Lambda-冷暗物质宇宙学模型。\n- 一个纯物质主导的平坦宇宙学模型。\n- 一个探索早期宇宙的玩具辐射主导平坦宇宙学模型。\n- 一个晚期由宇宙学常数主导的宇宙学模型。\n\n对于每个测试用例，在一个指定的发射尺度因子范围 $a_e \\in [a_{\\min}, a_{\\max}]$ 内，使用数值上合理的间距采样多个发射事件。对于每个发射事件，使用由 $E_{\\mathrm{emit}}(a) = E_0 \\left(1 + A \\sin(\\alpha \\ln a) + B\\, a^\\beta\\right)$ 定义的、具有时变发射能量的非平凡发射历史，其中 $E_0$、$A$、$B$、$\\alpha$ 和 $\\beta$ 是特定于用例的参数。你的程序必须：\n- 将 $E(a)$ 从 $a_e$ 数值演化到 $a_0$，并计算 $(1+z)_{\\mathrm{num}} = E_{\\mathrm{emit}}(a_e)/E_{\\mathrm{obs}} - 1$。\n- 计算 $(1+z)_{\\mathrm{theory}} = a_0/a_e - 1$。\n- 对于每个测试用例，报告其所有发射事件中的最大绝对差异 $\\max |(1+z)_{\\mathrm{num}} - (1+z)_{\\mathrm{theory}}|$，以及该用例中最早发射事件的共动距离（以 $\\mathrm{Mpc}$ 表示）。\n\n明确指定以下测试套件：\n- 测试用例 1 (平坦 Lambda-冷暗物质模型): $H_0 = 70\\,\\mathrm{km/s/Mpc}$, $\\Omega_m = 0.3$, $\\Omega_r = 9\\times 10^{-5}$, $\\Omega_\\Lambda = 0.69991$ (因此 $\\Omega_k = 0$), 发射尺度因子 $a_e \\in [0.2, 0.95]$, 参数为 $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 5$, $\\beta = 0.3$。\n- 测试用例 2 (平坦物质主导模型): $H_0 = 50\\,\\mathrm{km/s/Mpc}$, $\\Omega_m = 1$, $\\Omega_r = 0$, $\\Omega_\\Lambda = 0$ (因此 $\\Omega_k = 0$), 发射尺度因子 $a_e \\in [0.05, 0.9]$, 参数为 $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 3$, $\\beta = 0.5$。\n- 测试用例 3 (平坦玩具辐射主导模型): $H_0 = 70\\,\\mathrm{km/s/Mpc}$, $\\Omega_r = 9.999\\times 10^{-1}$, $\\Omega_m = 10^{-4}$, $\\Omega_\\Lambda = 0$ (因此 $\\Omega_k = 0$), 发射尺度因子 $a_e \\in [10^{-6}, 10^{-4}]$, 参数为 $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 8$, $\\beta = 0.2$。\n- 测试用例 4 (平坦晚期宇宙学常数主导模型): $H_0 = 70\\,\\mathrm{km/s/Mpc}$, $\\Omega_m = 10^{-2}$, $\\Omega_r = 9\\times 10^{-5}$, $\\Omega_\\Lambda = 0.98991$ (因此 $\\Omega_k = 0$), 发射尺度因子 $a_e \\in [0.8, 0.999]$, 参数为 $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 4$, $\\beta = 0.7$。\n\n每个测试用例至少使用 5 个发射事件样本，在指定的 $a_e$ 区间内适当间隔，以探测低红移和高红移以及数值敏感区域。\n\n你的程序应生成单行输出，其中包含八个结果（每个测试用例两个，按四个测试用例的顺序排列）：四个最大绝对差异，后跟四个共动距离。格式必须是方括号内以逗号分隔的列表，例如 $[\\delta_1,D_1,\\delta_2,D_2,\\delta_3,D_3,\\delta_4,D_4]$，其中每个 $\\delta_i$ 是无量纲浮点数，每个 $D_i$ 是以 $\\mathrm{Mpc}$ 为单位的浮点数。", "solution": "该问题要求从第一性原理，特别是弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规和光子测地线方程，对宇宙学红移关系进行数值验证。这是通过为几种宇宙学模型数值积分光子能量和路径的运动方程来完成的。任务的核心是证明众所周知的能量-红移关系 $E \\propto 1/a(t)$（其中 $E$ 是光子能量，$a(t)$ 是尺度因子）是从时空的基础几何中自然产生的，而不是被先验地假设。\n\n解决方案分为两个主要推导部分，然后是它们的数值实现：\n1.  在尺度因子 $a_e$ 处发射光子的物体的共动距离的推导与计算。\n2.  控制光子能量沿其测地线演化的微分方程的推导和数值积分。\n\n**1. 共动距离计算**\n\n出发点是 FLRW 线元：\n$$ds^2 = -c^2\\,dt^2 + a(t)^2\\,\\left[\\frac{dr^2}{1-k r^2} + r^2(d\\theta^2 + \\sin^2\\theta\\, d\\phi^2)\\right]$$\n对于一个沿径向轨迹从发射体传播到位于原点的观测者的光子，我们有 $d\\theta = 0$ 和 $d\\phi = 0$。光子的零条件是 $ds^2 = 0$。这将度规方程简化为：\n$$c^2\\,dt^2 = a(t)^2 \\frac{dr^2}{1-kr^2}$$\n取平方根并重新排列，我们将坐标时间 $dt$ 和共动径向坐标 $dr$ 的无穷小变化联系起来：\n$$c \\frac{dt}{a(t)} = \\pm \\frac{dr}{\\sqrt{1-kr^2}}$$\n当光子从 $r_e$ 处的发射体向 $r=0$ 处的观测者传播时，其径向坐标减小，因此 $dr  0$。我们选择负号以保持两边都为正：\n$$\\frac{dr}{\\sqrt{1-kr^2}} = -c \\frac{dt}{a(t)}$$\n问题中指定的测试用例适用于平坦宇宙，其中曲率参数 $k=0$。这个简化得到 $dr = -c\\,dt/a(t)$。\n为了计算到发射体的总共动距离 $r_e$，我们从发射时间 $t_e$ 积分到观测时间 $t_0$：\n$$r_e = \\int_0^{r_e} dr' = \\int_{t_e}^{t_0} \\frac{c\\,dt}{a(t)}$$\n为了进行数值积分，将积分变量从时间 $t$ 更改为尺度因子 $a$ 更为方便。使用哈勃参数的定义 $H = \\dot{a}/a = (1/a)(da/dt)$，我们可以写出 $dt = da/(aH)$。将此代入积分中得到：\n$$r_e = \\int_{a_e}^{a_0} \\frac{c\\,da}{a(t) \\cdot a(t) H(a)} = c \\int_{a_e}^{a_0} \\frac{da}{a^2 H(a)}$$\n问题指定观测者在“今天”，所以我们设置 $a_0 = 1$。哈勃参数的演化由弗里德曼方程给出：\n$$H(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_\\Lambda}$$\n所有测试用例使用的参数都使得 $\\Omega_k = 1 - (\\Omega_r + \\Omega_m + \\Omega_\\Lambda) = 0$。因此，到最早发射事件（$a_e = a_{\\min}$）的共动距离由以下定积分计算：\n$$r(a_{\\min}) = c \\int_{a_{\\min}}^{1} \\frac{da}{a^2 H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}}$$\n通过提出常数，我们可以将其写成一种便于计算的形式：\n$$r(a_{\\min}) = \\frac{c}{H_0} \\int_{a_{\\min}}^{1} \\frac{da}{a^2 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}}$$\n如果 $c$ 以 $\\mathrm{km/s}$ 表示，$H_0$ 以 $\\mathrm{km/s/Mpc}$ 表示，则前置因子 $c/H_0$（哈勃距离）的单位是 $\\mathrm{Mpc}$，并且该积分为无量纲。共动距离使用 `scipy.integrate.quad` 函数进行数值计算。\n\n**2. 光子能量演化**\n\n为了验证红移关系，我们必须从测地线方程推导光子能量 $E$ 的演化，而不假设 $E \\propto 1/a$ 的结果。由一个四维速度为 $U^\\mu$ 的共动观测者测量的光子能量是 $E = -g_{\\mu\\nu} P^\\mu U^\\nu$，其中 $P^\\mu = dx^\\mu/d\\lambda$ 是光子的四维动量，$\\lambda$ 是一个仿射参数。\n对于一个共动观测者，在 $(t, r, \\theta, \\phi)$ 坐标系中，$U^\\mu = (1, 0, 0, 0)$，并且度规分量 $g_{tt}=-c^2$。能量为 $E = -g_{tt} P^t U^t = c^2 P^t = c^2 (dt/d\\lambda)$。因此，能量演化由四维动量的时间分量 $P^t$ 的演化决定。\n测地线方程是：\n$$\\frac{dP^\\mu}{d\\lambda} + \\Gamma^\\mu_{\\alpha\\beta} P^\\alpha P^\\beta = 0$$\n对于时间分量（$\\mu=t$），方程为 $\\frac{dP^t}{d\\lambda} + \\Gamma^t_{\\alpha\\beta} P^\\alpha P^\\beta = 0$。对于径向测地线，只有 $P^t$ 和 $P^r$ 非零。唯一相关的克里斯托费尔符号是 $\\Gamma^t_{rr}$。对于 FLRW 度规，它是 $\\Gamma^t_{rr} = \\frac{a\\dot{a}}{c^2(1-kr^2)}$。测地线方程变为：\n$$\\frac{dP^t}{d\\lambda} + \\Gamma^t_{rr} (P^r)^2 = 0$$\n零条件 $g_{\\mu\\nu}P^\\mu P^\\nu=0$ 得到 $-c^2 (P^t)^2 + g_{rr} (P^r)^2 = 0$，这意味着 $(P^r)^2 = \\frac{c^2}{g_{rr}} (P^t)^2 = \\frac{c^2(1-kr^2)}{a^2} (P^t)^2$。将此代入测地线方程：\n$$\\frac{dP^t}{d\\lambda} + \\left(\\frac{a\\dot{a}}{c^2(1-kr^2)}\\right) \\left(\\frac{c^2(1-kr^2)}{a^2} (P^t)^2\\right) = 0$$\n$$\\frac{dP^t}{d\\lambda} + \\frac{\\dot{a}}{a} (P^t)^2 = 0$$\n为了得到 $P^t$ 作为时间 $t$ 函数的方程，我们使用链式法则：$\\frac{d}{d\\lambda} = \\frac{dt}{d\\lambda}\\frac{d}{dt} = P^t\\frac{d}{dt}$。\n$$P^t \\frac{dP^t}{dt} + \\frac{\\dot{a}}{a} (P^t)^2 = 0$$\n假设 $P^t \\neq 0$，我们除以 $P^t$ 得到一个线性常微分方程（ODE）：\n$$\\frac{dP^t}{dt} + \\frac{\\dot{a}}{a} P^t = 0 \\quad \\implies \\quad \\frac{1}{P^t}\\frac{dP^t}{dt} = -\\frac{1}{a}\\frac{da}{dt}$$\n这表明 $d(\\ln P^t)/dt = -d(\\ln a)/dt$，积分后得到 $P^t \\propto 1/a$。因为 $E \\propto P^t$，所以我们有 $E \\propto 1/a$。\n为了将其构建为对尺度因子 $a$ 的数值积分形式，我们写出：\n$$\\frac{dE}{da} = \\frac{dE}{dt}\\frac{dt}{da}$$\n从 $E \\propto 1/a$ 可知，$dE/dt = d(k/a)/dt = -k \\dot{a}/a^2 = -(Ea)\\dot{a}/a^2 = -E(\\dot{a}/a) = -EH$。\n而 $dt/da = 1/\\dot{a} = 1/(aH)$。所以，\n$$\\frac{dE}{da} = (-EH) \\left(\\frac{1}{aH}\\right) = -\\frac{E}{a}$$\n这个一阶常微分方程 $\\frac{dE}{da} = -E/a$ 是需要数值求解的动力学方程。\n\n**3. 数值实现**\n\n对于每个测试用例和每个指定的发射尺度因子 $a_e$，我们执行以下操作：\n1.  使用提供的发射历史函数设置能量 $E(a_e)$ 的初始条件：$E_{\\mathrm{emit}}(a_e) = E_0 \\left(1 + A \\sin(\\alpha \\ln a_e) + B a_e^\\beta\\right)$。\n2.  使用 `scipy.integrate.solve_ivp` 和高精度容差，在区间 $[a_e, 1]$ 上数值求解常微分方程 $\\frac{dE}{da} = -E/a$。在 $a=1$ 处的最终值是观测到的能量 $E_{\\mathrm{obs}}$。\n3.  计算数值红移 $z_{\\mathrm{num}} = E_{\\mathrm{emit}}(a_e)/E_{\\mathrm{obs}} - 1$。\n4.  计算理论红移 $z_{\\mathrm{theory}} = a_0/a_e - 1 = 1/a_e - 1$。\n5.  计算绝对差 $|z_{\\mathrm{num}} - z_{\\mathrm{theory}}|$。报告在给定测试用例的所有采样 $a_e$ 值中的最大差异。\n\n这个过程严格测试了 FLRW 几何对光子传播的直接影响，其数值结果应该在数值求解器的精度范围内证实理论红移关系。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Numerically ray-traces photon geodesics in FLRW spacetime to verify\n    the cosmological redshift relation from first principles.\n    \"\"\"\n    # Physical constants\n    # Speed of light in km/s\n    C_KM_S = 299792.458\n\n    # Test case definitions\n    # (H0, Omega_m, Omega_r, Omega_Lambda, a_range, E_params)\n    test_cases = [\n        # Case 1: Flat Lambda-Cold Dark Matter\n        (70.0, 0.3, 9e-5, 0.69991, (0.2, 0.95), (1.0, 0.2, 0.1, 5.0, 0.3)),\n        # Case 2: Flat matter-dominated\n        (50.0, 1.0, 0.0, 0.0, (0.05, 0.9), (1.0, 0.2, 0.1, 3.0, 0.5)),\n        # Case 3: Flat toy radiation-dominated\n        (70.0, 1e-4, 0.9999, 0.0, (1e-6, 1e-4), (1.0, 0.2, 0.1, 8.0, 0.2)),\n        # Case 4: Flat late-time cosmological-constant dominated\n        (70.0, 1e-2, 9e-5, 0.98991, (0.8, 0.999), (1.0, 0.2, 0.1, 4.0, 0.7)),\n    ]\n\n    results = []\n\n    for h0, om_m, om_r, om_l, a_range, e_params in test_cases:\n        a_min, a_max = a_range\n        om_k = 1.0 - (om_m + om_r + om_l)  # All cases are flat, so om_k is 0\n\n        # Define the normalized Hubble parameter function H(a)/H0\n        def hubble_normalized(a):\n            term_r = om_r * a**-4\n            term_m = om_m * a**-3\n            term_k = om_k * a**-2\n            term_l = om_l\n            return np.sqrt(term_r + term_m + term_k + term_l)\n\n        # 1. Calculate comoving distance to the earliest emission event (a_min)\n        # Integrand for comoving distance calculation\n        def dist_integrand(a):\n            return 1.0 / (a**2 * hubble_normalized(a))\n        \n        # Hubble distance in Mpc\n        hubble_dist_mpc = C_KM_S / h0\n        \n        # Use quad for high-precision integration\n        dist_integral, _ = integrate.quad(dist_integrand, a_min, 1.0, epsabs=1e-14, epsrel=1e-14)\n        \n        comoving_dist_mpc = hubble_dist_mpc * dist_integral\n\n        # 2. Verify redshift relation by evolving photon energy\n        e0, A, B, alpha, beta = e_params\n\n        # Time-varying emitted energy function\n        def e_emit_func(a):\n            return e0 * (1.0 + A * np.sin(alpha * np.log(a)) + B * a**beta)\n            \n        # ODE for energy evolution: dE/da = -E/a\n        def energy_ode(a, E):\n            return -E / a\n\n        # Set up emission event samples\n        num_samples = 10\n        # For large scale factor ranges, log spacing is more appropriate\n        if a_max / a_min  100:\n            a_e_samples = np.logspace(np.log10(a_min), np.log10(a_max), num_samples)\n        else:\n            a_e_samples = np.linspace(a_min, a_max, num_samples)\n            \n        discrepancies = []\n        for a_e in a_e_samples:\n            # Initial condition: energy at emission\n            e_initial = e_emit_func(a_e)\n            \n            # Solve the ODE from a_e to a_0=1\n            sol = integrate.solve_ivp(\n                energy_ode,\n                t_span=[a_e, 1.0],\n                y0=[e_initial],\n                rtol=1e-13,\n                atol=1e-13,\n                dense_output=True,\n                method='RK45'\n            )\n            e_observed = sol.y[0, -1]\n            \n            # Numerical redshift\n            z_numerical = e_initial / e_observed - 1.0\n            \n            # Theoretical redshift for a_0=1\n            z_theoretical = 1.0 / a_e - 1.0\n            \n            # Store the absolute discrepancy\n            discrepancies.append(np.abs(z_numerical - z_theoretical))\n            \n        max_discrepancy = np.max(discrepancies)\n        \n        results.extend([max_discrepancy, comoving_dist_mpc])\n\n    # Format the final output as a single comma-separated list in brackets\n    output_str = ','.join(f\"{x:.12g}\" for x in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3496232"}]}