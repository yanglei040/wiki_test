{"hands_on_practices": [{"introduction": "“朋友的朋友” (Friends-of-Friends, FOF) 算法是识别宇宙中粒子过度密集区域的一种基本方法，其原理类似于渗流理论。虽然简单的基于位置的链接标准对于孤立的暗晕效果很好，但在密集环境中，它可能会错误地将正在快速飞掠过彼此的独立暗晕合并在一起。本练习 [@problem_id:3480804] 将展示如何通过引入速度信息（即在相空间中操作）来显著提高暗晕识别的准确性，这是构建可靠暗晕目录的关键第一步。", "problem": "本题提供一个用于执行实时暗晕寻找与分析的演示设置，旨在说明如何通过用相空间信息增强组态空间的朋友的朋友 (FOF) 算法来改善对近距离飞掠事件的分离效果。该设置在一个周期性立方体盒子中模拟宇宙学粒子分布，并要求在粒子流式读入内存时增量式地构建 FOF 群组。目标是在两种不同的连接判据下计算群组，并根据已知的生成标签评估其定量纯度，以展示相空间 FOF 在处理近距离飞掠时的优越性。\n\n基本原理和定义：\n- 假设存在一个边长为 $L_{\\mathrm{box}}$ 的周期性立方体盒子，其中位置以 $h^{-1}\\,\\mathrm{Mpc}$ 为共动单位，速度以 $\\mathrm{km}\\,\\mathrm{s}^{-1}$ 为单位。必须使用最小镜像约定来强制执行周期性边界条件。\n- 朋友的朋友 (FOF) 群组是在一个二元邻居关系下相互连接的粒子集合。该邻居关系必须如此定义：如果任意两个粒子相连，它们就属于由两两之间的连接所定义的无向图的同一个连通分量。\n- 实时处理意味着粒子被顺序读入，并且随着边的发现而执行群组合并操作，无需一次性存储完整的配对图。最终的分组结果必须与通过构建完整图得到的结果相同，这是并查集（不相交集）结构在边插入操作下保持连通性的一个特性。\n\n您必须实现两种 FOF 变体：\n1. 组态空间 FOF：如果两个粒子 $i$ 和 $j$ 在组态空间中的欧几里得距离（考虑周期性边界条件计算）小于指定的空间连接长度 $l_{\\mathrm{pos}}$（单位为 $h^{-1}\\,\\mathrm{Mpc}$），则认为它们是相连的。必须使用最小镜像约定来计算在边长为 $L_{\\mathrm{box}}$ 的周期性盒子内的距离。\n2. 相空间 FOF：两个粒子 $i$ 和 $j$ 是否相连由一个组合距离决定，该距离同时考虑了组态空间距离和速度空间距离，并使用特征尺度 $l_{\\mathrm{pos}}$（单位为 $h^{-1}\\,\\mathrm{Mpc}$）和 $l_{\\mathrm{vel}}$（单位为 $\\mathrm{km}\\,\\mathrm{s}^{-1}$）。该组合度量必须是一个恰当的无量纲量，当速度差相对于 $l_{\\mathrm{vel}}$ 可以忽略不计时，它应退化为组态空间 FOF，并且应对单位具有鲁棒性。位置计算使用相同的周期性边界约定。如果组合相空间距离低于阈值 1，则粒子被视为相连。\n\n数据集生成：\n- 对于每个测试用例，您必须从 $K$ 个不同的暗晕中生成粒子。暗晕 $k$ 有一个中心位置 $\\boldsymbol{x}_k$（单位 $h^{-1}\\,\\mathrm{Mpc}$）、一个中心速度 $\\boldsymbol{v}_k$（单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$）、一个位置标准差 $\\sigma_{\\mathrm{pos}}$（单位 $h^{-1}\\,\\mathrm{Mpc}$）、一个速度标准差 $\\sigma_{\\mathrm{vel}}$（单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$）以及粒子数 $N_k$。粒子位置必须从一个以 $\\boldsymbol{x}_k$ 为中心、各向同性标准差为 $\\sigma_{\\mathrm{pos}}$ 的三维正态分布中独立抽取，然后包裹进边长为 $L_{\\mathrm{box}}$ 的周期性盒子中。速度必须从一个以 $\\boldsymbol{v}_k$ 为中心、各向同性标准差为 $\\sigma_{\\mathrm{vel}}$ 的三维正态分布中抽取。根据其所属的暗晕，为每个粒子分配一个真实标签 $k\\in\\{0,1,\\dots,K-1\\}$。\n\n纯度度量：\n- 计算分组结果相对于真实标签的微观平均纯度。如果恢复的群组集合为 $\\{G_m\\}$，其中 $|G_m|$ 是群组 $m$ 的大小，$n_{m,i}$ 是 $G_m$ 中真实标签为 $i$ 的粒子数量，则定义微观平均纯度为\n$$\nP_{\\mathrm{micro}} \\equiv \\frac{1}{N} \\sum_{m} \\max_{i} n_{m,i},\n$$\n其中 $N$ 是所有群组中的总粒子数。该量是无量纲的。对于每个测试用例，报告组态空间 FOF 和相空间 FOF 的 $P_{\\mathrm{micro}}$ 值，并报告其提升量 $\\Delta P \\equiv P_{\\mathrm{micro}}^{\\mathrm{phase}} - P_{\\mathrm{micro}}^{\\mathrm{config}}$。\n\n周期性边界条件：\n- 对于位置，使用最小镜像约定。对于沿某一轴的任意坐标差 $\\Delta x$，计算其周期性差值，该差值是区间 $(-L_{\\mathrm{box}}/2, L_{\\mathrm{box}}/2]$ 内与 $\\Delta x$ 模 $L_{\\mathrm{box}}$ 同余的唯一值。\n\n流式处理约束：\n- 实时实现分组：按顺序处理粒子，如果满足连接判据，则添加与先前读入粒子的连接。维护一个带有路径压缩和按大小或按秩合并的并查集（不相交集）结构，以便在发现边时合并分量。不要一次性构建完整的配对图。\n\n单位：\n- 位置必须以 $h^{-1}\\,\\mathrm{Mpc}$ 为单位处理，速度以 $\\mathrm{km}\\,\\mathrm{s}^{-1}$ 为单位。报告的任何度量都必须是无量纲的。不涉及角度单位。\n\n测试套件和参数：\n- 使用固定的随机种子以保证可复现性。\n- 对于所有测试用例，盒子大小均为 $L_{\\mathrm{box}} = 1.0$ $h^{-1}\\,\\mathrm{Mpc}$。\n- 测试用例 1 (理想情况，暗晕分离良好)：$K=3$，中心 $\\boldsymbol{x}_k = (0.1,0.1,0.1),(0.7,0.5,0.4),(0.3,0.8,0.2)$，中心速度 $\\boldsymbol{v}_k = (0,0,0),(300,0,0),(-250,0,0)$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)，粒子数 $N_k = 60,60,60$，标准差 $\\sigma_{\\mathrm{pos}}=0.015$ (单位 $h^{-1}\\,\\mathrm{Mpc}$) 和 $\\sigma_{\\mathrm{vel}}=30$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)，连接尺度 $l_{\\mathrm{pos}}=0.05$ (单位 $h^{-1}\\,\\mathrm{Mpc}$) 和 $l_{\\mathrm{vel}}=150$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)。\n- 测试用例 2 (近距离飞掠，组态空间重叠但在速度上可分)：$K=3$，中心 $\\boldsymbol{x}_k = (0.5,0.5,0.5),(0.535,0.5,0.5),(0.8,0.2,0.2)$，中心速度 $\\boldsymbol{v}_k = (300,0,0),(-300,0,0),(50,0,0)$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)，粒子数 $N_k = 80,80,60$，标准差 $\\sigma_{\\mathrm{pos}}=0.012$ (单位 $h^{-1}\\,\\mathrm{Mpc}$) 和 $\\sigma_{\\mathrm{vel}}=25$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)，连接尺度 $l_{\\mathrm{pos}}=0.05$ (单位 $h^{-1}\\,\\mathrm{Mpc}$) 和 $l_{\\mathrm{vel}}=150$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)。\n- 测试用例 3 (靠近空间阈值的边界情况，伴有中等速度偏移)：$K=3$，中心 $\\boldsymbol{x}_k = (0.4,0.4,0.4),(0.45,0.4,0.4),(0.2,0.7,0.5)$，中心速度 $\\boldsymbol{v}_k = (200,0,0),(20,0,0),(80,0,0)$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)，粒子数 $N_k = 70,70,60$，标准差 $\\sigma_{\\mathrm{pos}}=0.015$ (单位 $h^{-1}\\,\\mathrm{Mpc}$) 和 $\\sigma_{\\mathrm{vel}}=35$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)，连接尺度 $l_{\\mathrm{pos}}=0.05$ (单位 $h^{-1}\\,\\mathrm{Mpc}$) 和 $l_{\\mathrm{vel}}=150$ (单位 $\\mathrm{km}\\,\\mathrm{s}^{-1}$)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个包含三个浮点数的列表 $[P_{\\mathrm{micro}}^{\\mathrm{config}}, P_{\\mathrm{micro}}^{\\mathrm{phase}}, \\Delta P]$，数值四舍五入到三位小数。例如，打印的输出必须精确地为 `[[0.995,0.998,0.003],[\\dots],[\\dots]]` 的形式，位于单行且无任何附加文本。", "solution": "这个问题是有效的，因为它科学地植根于计算宇宙学的原理，特别是暗晕寻找算法。它是一个良构问题，提供了所有必要的参数、定义和约束，以推导出唯一且可验证的解。问题陈述是客观的，并使用了该领域的标准、可形式化的术语。\n\n目标是实现并比较朋友的朋友 (FOF) 暗晕寻找算法的两种变体：一个标准的组态空间版本和一个增强的相空间版本。将使用微观平均纯度度量来量化这种比较，以证明相空间方法在解决飞掠遭遇事件（其中暗晕在空间上接近但在运动学上不同）方面的优越性。实现必须遵循使用并查集数据结构的实时处理模型。\n\n首先，我们定义生成粒子数据的方法。对于给定测试用例中的每个（共 $K$ 个）真实暗晕，我们生成 $N_k$ 个粒子。属于暗晕 $k$ 的每个粒子的位置 $\\boldsymbol{x}$ 从一个均值为 $\\boldsymbol{x}_k$（暗晕中心）、标准差为 $\\sigma_{\\mathrm{pos}}$ 的三维各向同性正态分布中抽取。然后使用取模运算将这些生成的位置映射到边长为 $L_{\\mathrm{box}}$ 的周期性立方体盒子中，确保坐标位于 $[0, L_{\\mathrm{box}})$ 范围内。每个粒子的速度 $\\boldsymbol{v}$ 同样从一个均值为 $\\boldsymbol{v}_k$、标准差为 $\\sigma_{\\mathrm{vel}}$ 的三维各向同性正态分布中抽取。每个粒子被分配一个真实整数标签 $k \\in \\{0, 1, ..., K-1\\}$。\n\nFOF 算法的核心是配对连接条件。我们必须计算任意两个粒子 $i$ 和 $j$ 之间的距离。对于位置 $\\boldsymbol{x}_i$ 和 $\\boldsymbol{x}_j$，矢量差 $\\Delta\\boldsymbol{x} = \\boldsymbol{x}_i - \\boldsymbol{x}_j$ 必须考虑周期性边界条件。我们使用最小镜像约定。对于 $\\Delta\\boldsymbol{x}$ 的每个分量 $\\Delta x_c$，其周期性差值是区间 $(-L_{\\mathrm{box}}/2, L_{\\mathrm{box}}/2]$ 内的唯一值。这可以通过 $\\Delta x_{p,c} = \\Delta x_c - L_{\\mathrm{box}} \\cdot \\mathrm{round}(\\Delta x_c / L_{\\mathrm{box}})$ 计算，并进行特殊检查，将任何等于 $-L_{\\mathrm{box}}/2$ 的结果映射到 $+L_{\\mathrm{box}}/2$，以严格遵守该区间。组态空间中的欧几里得距离平方则为 $d_{\\mathrm{pos}}^2 = \\|\\Delta\\boldsymbol{x}_p\\|^2$。速度空间距离是速度空间中标准的欧几里得距离平方，$d_{\\mathrm{vel}}^2 = \\|\\boldsymbol{v}_i - \\boldsymbol{v}_j\\|^2$。\n\n我们实现两种连接判据：\n1.  **组态空间 FOF**：如果两个粒子的物理距离小于连接长度 $l_{\\mathrm{pos}}$，则它们相连。为避免计算成本高昂的平方根，我们使用距离的平方：$d_{\\mathrm{pos}}^2  l_{\\mathrm{pos}}^2$。\n2.  **相空间 FOF**：问题指定了一个无量纲的组合度量。一个满足所有给定约束的标准选择是归一化距离的平方和。如果满足条件\n    $$\n    \\left(\\frac{d_{\\mathrm{pos}}}{l_{\\mathrm{pos}}}\\right)^2 + \\left(\\frac{d_{\\mathrm{vel}}}{l_{\\mathrm{vel}}}\\right)^2 \\le 1\n    $$\n    ，则两个粒子相连。这等效于 $d_{\\mathrm{pos}}^2 / l_{\\mathrm{pos}}^2 + d_{\\mathrm{vel}}^2 / l_{\\mathrm{vel}}^2 \\le 1$。当速度差 $d_{\\mathrm{vel}}$ 相对于速度尺度 $l_{\\mathrm{vel}}$ 可以忽略不计时，该度量能正确地退化为组态空间判据。\n\n为满足实时处理约束，我们采用一个并查集 (DSU) 或不相交集数据结构，并使用路径压缩和按大小合并进行优化。算法流程如下：\n1.  初始化 DSU 结构，使得总共 $N$ 个粒子每个都自成一个集合。\n2.  从 $0$ 到 $N-1$ 遍历每个粒子 $i$。\n3.  对于每个 $i$，遍历所有先前已处理的粒子 $j$（从 $0$ 到 $i-1$）。\n4.  对于每对粒子 $(i, j)$，根据所选的 FOF 判据检查它们是否相连。\n5.  如果它们相连，则对包含 $i$ 和 $j$ 的集合执行 `union` 操作。\n这个过程不需要存储完整的配对图，从而体现了实时算法的内存效率。对两种 FOF 判据分别进行一次独立的运行。\n\n最后，我们为每个分组结果计算微观平均纯度 $P_{\\mathrm{micro}}$。在给定 FOF 运行的 DSU 结构最终确定后，我们通过查找每个粒子的根代表来识别出不同的群组。对于每个结果群组 $G_m$，我们统计其中来自每个真实暗晕的成员粒子数量，得到计数 $n_{m,i}$。然后使用以下公式计算纯度：\n$$\nP_{\\mathrm{micro}} = \\frac{1}{N} \\sum_{m} \\max_{i} n_{m,i}\n$$\n其中总和遍历所有恢复的群组 $\\{G_m\\}$，$N$ 是总粒子数。我们为组态空间 FOF ($P_{\\mathrm{micro}}^{\\mathrm{config}}$) 和相空间 FOF ($P_{\\mathrm{micro}}^{\\mathrm{phase}}$) 分别计算此纯度，并报告其提升量 $\\Delta P = P_{\\mathrm{micro}}^{\\mathrm{phase}} - P_{\\mathrm{micro}}^{\\mathrm{config}}$。使用固定的随机种子为提供的每个测试用例执行计算，以保证可复现性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FOF analysis for all test cases and print the results.\n    \"\"\"\n\n    class UnionFind:\n        \"\"\"\n        A disjoint-set union (DSU) data structure with path compression and union by size.\n        \"\"\"\n        def __init__(self, n):\n            self.parent = np.arange(n)\n            self.size = np.ones(n, dtype=int)\n\n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                if self.size[root_i]  self.size[root_j]:\n                    root_i, root_j = root_j, root_i\n                self.parent[root_j] = root_i\n                self.size[root_i] += self.size[root_j]\n\n    def generate_particles(params, rng):\n        \"\"\"\n        Generates particle data based on halo parameters for a single test case.\n        \"\"\"\n        L_box = params['L_box']\n        all_pos, all_vel, all_labels = [], [], []\n        \n        particle_idx = 0\n        for k in range(params['K']):\n            N_k = params['N_k'][k]\n            pos = rng.normal(loc=params['x_k'][k], scale=params['sigma_pos'], size=(N_k, 3))\n            vel = rng.normal(loc=params['v_k'][k], scale=params['sigma_vel'], size=(N_k, 3))\n            \n            # Wrap positions into the periodic box [0, L_box)\n            pos %= L_box\n            \n            all_pos.append(pos)\n            all_vel.append(vel)\n            all_labels.append(np.full(N_k, k, dtype=int))\n            particle_idx += N_k\n\n        return np.vstack(all_pos), np.vstack(all_vel), np.concatenate(all_labels)\n\n    def run_fof(positions, velocities, L_box, l_pos, l_vel=None):\n        \"\"\"\n        Performs on-the-fly FOF grouping using a Union-Find structure.\n        \"\"\"\n        n_particles = positions.shape[0]\n        uf = UnionFind(n_particles)\n        l_pos_sq = l_pos**2\n        \n        is_phase_space = l_vel is not None\n        if is_phase_space:\n            l_vel_sq = l_vel**2\n\n        for i in range(n_particles):\n            for j in range(i):\n                # Configuration-space distance\n                delta_pos = positions[i] - positions[j]\n                # Minimal image convention for (-L_box/2, L_box/2]\n                wrapped_delta = delta_pos - L_box * np.round(delta_pos / L_box)\n                # Ensure the interval is (-L/2, L/2] by adjusting the lower bound\n                wrapped_delta[wrapped_delta == -L_box / 2] = L_box / 2\n                d_pos_sq = np.sum(wrapped_delta**2)\n\n                if is_phase_space:\n                    # Phase-space FOF\n                    delta_vel = velocities[i] - velocities[j]\n                    d_vel_sq = np.sum(delta_vel**2)\n                    \n                    if (d_pos_sq / l_pos_sq) + (d_vel_sq / l_vel_sq) = 1.0:\n                        uf.union(i, j)\n                else:\n                    # Configuration-space FOF\n                    if d_pos_sq  l_pos_sq:\n                        uf.union(i, j)\n        return uf\n        \n    def calculate_purity(uf, labels, K):\n        \"\"\"\n        Calculates the micro-averaged purity of the found groups.\n        \"\"\"\n        n_particles = len(labels)\n        if n_particles == 0:\n            return 1.0\n\n        groups = {}\n        for i in range(n_particles):\n            root = uf.find(i)\n            if root not in groups:\n                groups[root] = []\n            groups[root].append(i)\n        \n        sum_max_n = 0\n        for root in groups:\n            group_indices = groups[root]\n            group_labels = labels[group_indices]\n            \n            if len(group_labels) > 0:\n                # Count occurrences of each ground-truth label in this group\n                counts = np.bincount(group_labels, minlength=K)\n                sum_max_n += np.max(counts)\n                \n        return sum_max_n / n_particles\n\n    def process_case(params, rng):\n        \"\"\"\n        Processes a single test case: generates particles, runs both FOFs, computes purities.\n        \"\"\"\n        positions, velocities, labels = generate_particles(params, rng)\n        \n        # Configuration-space FOF\n        uf_config = run_fof(positions, velocities, params['L_box'], params['l_pos'])\n        p_config = calculate_purity(uf_config, labels, params['K'])\n        \n        # Phase-space FOF\n        uf_phase = run_fof(positions, velocities, params['L_box'], params['l_pos'], l_vel=params['l_vel'])\n        p_phase = calculate_purity(uf_phase, labels, params['K'])\n        \n        delta_p = p_phase - p_config\n        \n        return [p_config, p_phase, delta_p]\n\n    test_cases = [\n        # Test Case 1 (happy path, well-separated halos)\n        {\n            'L_box': 1.0, 'K': 3,\n            'x_k': np.array([[0.1, 0.1, 0.1], [0.7, 0.5, 0.4], [0.3, 0.8, 0.2]]),\n            'v_k': np.array([[0, 0, 0], [300, 0, 0], [-250, 0, 0]]),\n            'N_k': [60, 60, 60],\n            'sigma_pos': 0.015, 'sigma_vel': 30.0,\n            'l_pos': 0.05, 'l_vel': 150.0\n        },\n        # Test Case 2 (close flyby, overlap in config-space)\n        {\n            'L_box': 1.0, 'K': 3,\n            'x_k': np.array([[0.5, 0.5, 0.5], [0.535, 0.5, 0.5], [0.8, 0.2, 0.2]]),\n            'v_k': np.array([[300, 0, 0], [-300, 0, 0], [50, 0, 0]]),\n            'N_k': [80, 80, 60],\n            'sigma_pos': 0.012, 'sigma_vel': 25.0,\n            'l_pos': 0.05, 'l_vel': 150.0\n        },\n        # Test Case 3 (boundary case near spatial threshold)\n        {\n            'L_box': 1.0, 'K': 3,\n            'x_k': np.array([[0.4, 0.4, 0.4], [0.45, 0.4, 0.4], [0.2, 0.7, 0.5]]),\n            'v_k': np.array([[200, 0, 0], [20, 0, 0], [80, 0, 0]]),\n            'N_k': [70, 70, 60],\n            'sigma_pos': 0.015, 'sigma_vel': 35.0,\n            'l_pos': 0.05, 'l_vel': 150.0\n        }\n    ]\n\n    # Fixed random seed for reproducibility\n    seed = 42\n    rng = np.random.default_rng(seed)\n\n    all_results = []\n    for case_params in test_cases:\n        result = process_case(case_params, rng)\n        all_results.append(result)\n    \n    # Format the output string exactly as specified\n    inner_strings = [f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3480804"}, {"introduction": "当 “朋友的朋友” 算法识别出一个候选暗晕后，并非其所有成员粒子都必然在引力上束缚于该结构。一些粒子可能只是碰巧路过，或是正在逃离该结构的“闯入者”。本练习 [@problem_id:3480808] 将指导你实现一个迭代式的解绑（unbinding）程序。这是一个至关重要的“清理”步骤，通过计算每个粒子的总比能 $e = k + \\Phi$ 来判断它是否真正束缚于暗晕，从而确保我们分析的是一个物理上真实存在的天体。", "problem": "给定一小组代表候选暗物质晕的粒子，它们嵌入在一个更大的宿主环境中。您必须使用牛顿引力和宿主场的局部潮汐近似，实现一个实时解绑程序：计算每个粒子的比结合能，迭代地移除未束缚的粒子，并返回最终的束缚粒子集合。所有量都必须在物理上一致的单位体系中处理，并且数值算法必须从第一性原理推导。\n\n使用的基本原理：\n- 在膨胀宇宙中，牛顿引力动力学在晕尺度上可以很好地被非相对论动力学近似。一个点质量系统的引力势定义为 $ \\Phi(\\boldsymbol{r}) = - G \\sum_{j} \\dfrac{m_j}{\\left\\lVert \\boldsymbol{r} - \\boldsymbol{r}_j \\right\\rVert} $，其中 $ G $ 是引力常数，$ \\boldsymbol{r}_j $ 是源位置。为防止离散表示中的发散，采用Plummer等效平滑，通过将 $ \\left\\lVert \\boldsymbol{r} - \\boldsymbol{r}_j \\right\\rVert $ 替换为 $ \\sqrt{\\left\\lVert \\boldsymbol{r} - \\boldsymbol{r}_j \\right\\rVert^2 + \\epsilon^2} $，其中 $ \\epsilon $ 是一个很小的平滑长度。\n- 对于宿主环境，使用潮汐张量 $ \\mathbf{T} = \\nabla \\nabla \\Phi_{\\text{host}}(\\boldsymbol{r}) \\big\\vert_{\\boldsymbol{r} = \\boldsymbol{r}_{\\text{com}}} $，通过二次展开来近似晕中心附近的势。对于位于位置 $ \\boldsymbol{R}_{\\text{host}} $ 的点质量宿主，相对于晕的质心位置 $ \\boldsymbol{r}_{\\text{com}} $，潮汐张量为 $ \\mathbf{T} = \\dfrac{G M_{\\text{host}}}{R^3} \\left( 3 \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top - \\mathbf{I} \\right) $，其中 $ R = \\left\\lVert \\boldsymbol{R}_{\\text{host}} - \\boldsymbol{r}_{\\text{com}} \\right\\rVert $，$ \\hat{\\boldsymbol{n}} = \\dfrac{\\boldsymbol{R}_{\\text{host}} - \\boldsymbol{r}_{\\text{com}}}{R} $，$ \\mathbf{I} $ 是单位矩阵。对于位移 $ \\boldsymbol{x} = \\boldsymbol{r} - \\boldsymbol{r}_{\\text{com}} $，相应的局部潮汐势为 $ \\Phi_{\\text{tid}}(\\boldsymbol{x}) \\approx \\dfrac{1}{2} \\boldsymbol{x}^\\top \\mathbf{T} \\boldsymbol{x} $。\n- 相对于晕整体运动的比动能为 $ k(\\boldsymbol{v}) = \\dfrac{1}{2} \\left\\lVert \\boldsymbol{v} - \\boldsymbol{v}_{\\text{com}} \\right\\rVert^2 $，其中 $ \\boldsymbol{v}_{\\text{com}} $ 是当前束缚粒子集合的质量加权质心速度。\n\n定义和判据：\n- 每个粒子的比总能为 $ e_i = \\dfrac{1}{2} \\left\\lVert \\boldsymbol{v}_i - \\boldsymbol{v}_{\\text{com}} \\right\\rVert^2 + \\Phi_{\\text{self}}(\\boldsymbol{r}_i) + \\Phi_{\\text{tid}}(\\boldsymbol{r}_i - \\boldsymbol{r}_{\\text{com}}) $，其中 $ \\Phi_{\\text{self}}(\\boldsymbol{r}_i) = - G \\sum_{j \\neq i} \\dfrac{m_j}{\\sqrt{\\left\\lVert \\boldsymbol{r}_i - \\boldsymbol{r}_j \\right\\rVert^2 + \\epsilon^2}} $。当且仅当 $e_i  0$ 时，粒子被认为是束缚的。\n- 实时解绑步骤会重复计算当前束缚集合中所有粒子的 $ e_i $，移除所有 $ e_i \\ge 0 $ 的粒子，并更新 $ \\boldsymbol{r}_{\\text{com}} $、$ \\boldsymbol{v}_{\\text{com}} $ 和 $ \\mathbf{T} $，直到没有更多粒子被移除或束缚集合为空。\n\n单位：\n- 使用 $ \\boldsymbol{r} $ 单位为 $ \\mathrm{kpc} $，$ \\boldsymbol{v} $ 单位为 $ \\mathrm{km}/\\mathrm{s} $，$ m $ 单位为 $ M_{\\odot} $，以及 $ G = 4.30091 \\times 10^{-6} \\, \\mathrm{kpc} \\, (\\mathrm{km}/\\mathrm{s})^2 \\, M_{\\odot}^{-1} $。能量 $ e_i $ 的单位必须是 $ (\\mathrm{km}/\\mathrm{s})^2 $，并被视为比能（单位质量的能量）。任何角度（如果存在）必须通过向量归一化隐式解释，不需要显式单位；所有方向都是无量纲的单位向量。\n\n算法要求：\n- 仅使用当前束缚的粒子计算质量加权质心位置 $ \\boldsymbol{r}_{\\text{com}} = \\dfrac{\\sum_i m_i \\boldsymbol{r}_i}{\\sum_i m_i} $ 和质心速度 $ \\boldsymbol{v}_{\\text{com}} = \\dfrac{\\sum_i m_i \\boldsymbol{v}_i}{\\sum_i m_i} $。\n- 对于给定的当前束缚集合，计算带有平滑长度 $ \\epsilon $ 的自引力势 $ \\Phi_{\\text{self}}(\\boldsymbol{r}_i) $。\n- 根据宿主质量和从当前 $ \\boldsymbol{r}_{\\text{com}} $ 到宿主位置 $ \\boldsymbol{R}_{\\text{host}} $ 的向量，计算宿主潮汐张量 $ \\mathbf{T} $。\n- 计算当前集合中每个粒子的 $ e_i $，并移除那些 $ e_i \\ge 0 $ 的粒子。迭代此过程，直到收敛或达到最大迭代次数。\n\n测试套件：\n提供三个测试用例来检验不同情况。在每个案例中，指定所有粒子的位置、速度和质量数组，平滑长度 $ \\epsilon $，宿主质量 $ M_{\\text{host}} $ 和宿主位置向量 $ \\boldsymbol{R}_{\\text{host}} $。\n\n- 测试用例1（紧凑，弱潮汐，预计大部分保持束缚）：\n  - $ N = 5 $\n  - 位置（单位 $ \\mathrm{kpc} $）：\n    - $ \\boldsymbol{r}_0 = (0.0, 0.0, 0.0) $\n    - $ \\boldsymbol{r}_1 = (0.3, 0.1, 0.0) $\n    - $ \\boldsymbol{r}_2 = (-0.2, -0.1, 0.1) $\n    - $ \\boldsymbol{r}_3 = (0.1, -0.3, 0.2) $\n    - $ \\boldsymbol{r}_4 = (-0.1, 0.2, -0.2) $\n  - 速度（单位 $ \\mathrm{km}/\\mathrm{s} $）：\n    - $ \\boldsymbol{v}_0 = (0.0, 0.0, 0.0) $\n    - $ \\boldsymbol{v}_1 = (8.0, 0.0, 0.0) $\n    - $ \\boldsymbol{v}_2 = (-5.0, 2.0, 1.0) $\n    - $ \\boldsymbol{v}_3 = (3.0, -4.0, 2.0) $\n    - $ \\boldsymbol{v}_4 = (-2.0, 1.0, -3.0) $\n  - 质量（单位 $ M_{\\odot} $）：全部等于 $ 1.0 \\times 10^8 $\n  - 平滑长度 $ \\epsilon = 0.1 \\, \\mathrm{kpc} $\n  - 宿主质量 $ M_{\\text{host}} = 1.0 \\times 10^{12} \\, M_{\\odot} $\n  - 宿主位置 $ \\boldsymbol{R}_{\\text{host}} = (300.0, 0.0, 0.0) \\, \\mathrm{kpc} $\n  - 最大迭代次数 $ 10 $\n\n- 测试用例2（中等潮汐，一些外部粒子会解绑）：\n  - $ N = 6 $\n  - 位置（单位 $ \\mathrm{kpc} $）：\n    - $ \\boldsymbol{r}_0 = (0.0, 0.0, 0.0) $\n    - $ \\boldsymbol{r}_1 = (0.3, 0.1, 0.0) $\n    - $ \\boldsymbol{r}_2 = (-0.2, -0.1, 0.1) $\n    - $ \\boldsymbol{r}_3 = (0.1, -0.3, 0.2) $\n    - $ \\boldsymbol{r}_4 = (-0.1, 0.2, -0.2) $\n    - $ \\boldsymbol{r}_5 = (2.0, 0.0, 0.0) $\n  - 速度（单位 $ \\mathrm{km}/\\mathrm{s} $）：\n    - $ \\boldsymbol{v}_0 = (0.0, 0.0, 0.0) $\n    - $ \\boldsymbol{v}_1 = (6.0, 0.0, 0.0) $\n    - $ \\boldsymbol{v}_2 = (-4.0, 1.5, 0.5) $\n    - $ \\boldsymbol{v}_3 = (2.5, -3.0, 1.5) $\n    - $ \\boldsymbol{v}_4 = (-1.5, 0.5, -2.5) $\n    - $ \\boldsymbol{v}_5 = (50.0, 0.0, 0.0) $\n  - 质量（单位 $ M_{\\odot} $）：全部等于 $ 2.0 \\times 10^8 $\n  - 平滑长度 $ \\epsilon = 0.05 \\, \\mathrm{kpc} $\n  - 宿主质量 $ M_{\\text{host}} = 1.0 \\times 10^{12} \\, M_{\\odot} $\n  - 宿主位置 $ \\boldsymbol{R}_{\\text{host}} = (50.0, 0.0, 0.0) \\, \\mathrm{kpc} $\n  - 最大迭代次数 $ 10 $\n\n- 测试用例3（混合质量，临界束缚）：\n  - $ N = 4 $\n  - 位置（单位 $ \\mathrm{kpc} $）：\n    - $ \\boldsymbol{r}_0 = (0.0, 0.0, 0.0) $\n    - $ \\boldsymbol{r}_1 = (0.5, 0.0, 0.0) $\n    - $ \\boldsymbol{r}_2 = (0.0, 0.5, 0.0) $\n    - $ \\boldsymbol{r}_3 = (0.0, 0.0, 0.5) $\n  - 速度（单位 $ \\mathrm{km}/\\mathrm{s} $）：\n    - $ \\boldsymbol{v}_0 = (0.0, 0.0, 0.0) $\n    - $ \\boldsymbol{v}_1 = (12.0, 0.0, 0.0) $\n    - $ \\boldsymbol{v}_2 = (0.0, 12.0, 0.0) $\n    - $ \\boldsymbol{v}_3 = (0.0, 0.0, 12.0) $\n  - 质量（单位 $ M_{\\odot} $）：\n    - $ m_0 = 3.0 \\times 10^8 $\n    - $ m_1 = 1.0 \\times 10^8 $\n    - $ m_2 = 2.0 \\times 10^8 $\n    - $ m_3 = 1.5 \\times 10^8 $\n  - 平滑长度 $ \\epsilon = 0.1 \\, \\mathrm{kpc} $\n  - 宿主质量 $ M_{\\text{host}} = 5.0 \\times 10^{11} \\, M_{\\odot} $\n  - 宿主位置 $ \\boldsymbol{R}_{\\text{host}} = (1000.0, 1000.0, 0.0) \\, \\mathrm{kpc} $\n  - 最大迭代次数 $ 10 $\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果必须是该测试用例中，经过实时解绑程序后仍然束缚的粒子的零基索引列表，并按升序排序。例如，打印的输出应类似于 $ [ [0,1,2], [0,1], [0] ] $，并根据指定测试套件的实际结果进行调整。", "solution": "该问题要求为一个代表暗物质子晕的粒子集合实现一个迭代解绑算法。该子晕受到其自身引力和一个更大宿主环境的潮汐力作用。这个过程是计算宇宙学中的一项标准技术，用于识别在N体模拟中形成的结构中的引力束缚成分。\n\n该解决方案基于在与子晕一同运动的局部非惯性参考系中的能量守恒原理。如果一个粒子相对于系统质心的总比能为负，则该粒子被认为是束缚于该系统的。粒子 $i$ 的总比能 $e_i$ 是其比动能 $k_i$、其自引力势能 $\\Phi_{\\text{self}}(\\boldsymbol{r}_i)$ 和其潮汐势能 $\\Phi_{\\text{tid}}(\\boldsymbol{x}_i)$ 的总和。\n\n该算法按以下步骤迭代进行：\n\n1.  **初始化**：该过程开始时假设所有 $N$ 个初始粒子构成候选的束缚群组。启动一个迭代循环，该循环将连续优化此集合。当束缚粒子集在迭代之间不再变化、集合变空或达到指定的最大迭代次数后，循环终止。\n\n2.  **整体属性计算**：在每次迭代中，我们首先确定*当前*束缚粒子集合的整体属性。这些是质量加权的质心位置 $\\boldsymbol{r}_{\\text{com}}$ 和速度 $\\boldsymbol{v}_{\\text{com}}$：\n    $$ \\boldsymbol{r}_{\\text{com}} = \\frac{\\sum_{j \\in \\text{bound}} m_j \\boldsymbol{r}_j}{\\sum_{j \\in \\text{bound}} m_j}, \\quad \\boldsymbol{v}_{\\text{com}} = \\frac{\\sum_{j \\in \\text{bound}} m_j \\boldsymbol{v}_j}{\\sum_{j \\in \\text{bound}} m_j} $$\n    这些值定义了计算束缚能的参考系的原点和运动状态。\n\n3.  **能量计算**：对于当前束缚集合中的每个粒子 $i$，通过对三个分量求和来计算其总比能 $e_i$：\n\n    a.  **比动能**：这是相对于晕整体运动的单位质量动能。对于速度为 $\\boldsymbol{v}_i$ 的粒子，其比动能为：\n        $$ k_i = \\frac{1}{2} \\left\\lVert \\boldsymbol{v}_i - \\boldsymbol{v}_{\\text{com}} \\right\\rVert^2 $$\n\n    b.  **比自引力势能**：这是粒子 $i$ 因当前束缚集合中所有*其他*粒子 $j$ 的引力吸引而产生的单位质量引力势能。为避免零距离处的奇点，使用了Plummer等效平滑长度 $\\epsilon$。\n        $$ \\Phi_{\\text{self}}(\\boldsymbol{r}_i) = - G \\sum_{j \\in \\text{bound}, j \\neq i} \\frac{m_j}{\\sqrt{\\left\\lVert \\boldsymbol{r}_i - \\boldsymbol{r}_j \\right\\rVert^2 + \\epsilon^2}} $$\n        此处，$G$ 是引力常数，$G = 4.30091 \\times 10^{-6} \\, \\mathrm{kpc} \\, (\\mathrm{km}/\\mathrm{s})^2 \\, M_{\\odot}^{-1}$。\n\n    c.  **比潮汐势能**：宿主星系的引力场通过其潮汐张量在局部进行近似，该张量描述了作用于子晕上的差动力。对于位于位置 $\\boldsymbol{R}_{\\text{host}}$ 的点质量宿主 $M_{\\text{host}}$，潮汐张量 $\\mathbf{T}$ 由下式给出：\n        $$ \\mathbf{T} = \\frac{G M_{\\text{host}}}{R^3} \\left( 3 \\hat{\\boldsymbol{n}} \\hat{\\boldsymbol{n}}^\\top - \\mathbf{I} \\right) $$\n        其中 $R = \\left\\lVert \\boldsymbol{R}_{\\text{host}} - \\boldsymbol{r}_{\\text{com}} \\right\\rVert$ 是从子晕质心到宿主的距离，$\\hat{\\boldsymbol{n}} = (\\boldsymbol{R}_{\\text{host}} - \\boldsymbol{r}_{\\text{com}})/R$ 是该方向上的单位向量，$ \\mathbf{I} $ 是 $3 \\times 3$ 的单位矩阵。对于相对于质心的位置 $\\boldsymbol{x}_i = \\boldsymbol{r}_i - \\boldsymbol{r}_{\\text{com}}$ 的粒子 $i$，其潮汐势能为：\n        $$ \\Phi_{\\text{tid}}(\\boldsymbol{x}_i) = \\frac{1}{2} \\boldsymbol{x}_i^\\top \\mathbf{T} \\boldsymbol{x}_i $$\n\n4.  **束缚判据与迭代**：粒子 $i$ 的总比能是总和 $e_i = k_i + \\Phi_{\\text{self}}(\\boldsymbol{r}_i) + \\Phi_{\\text{tid}}(\\boldsymbol{x}_i)$。如果一个粒子的总能量为非负，即 $e_i \\ge 0$，则认为它是未束缚的。\n    在为当前集合中的所有粒子计算完 $e_i$ 后，识别并移除任何未束缚的粒子。这将创建一个新的、更小的束缚粒子集合。然后算法带着这个新集合返回到步骤2。如果在一次迭代后没有粒子被移除，系统已收敛到一个稳定的、自束缚的构型，算法终止，并返回最终的束缚粒子集合。\n\n该实现将利用 `numpy` 进行高效的矢量化计算，包括距离、质心和矩阵向量运算，这对于N体算法的性能至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... (Not used in this implementation)\n\ndef perform_unbinding(positions, velocities, masses, epsilon, m_host, r_host, max_iter):\n    \"\"\"\n    Performs an iterative unbinding procedure on a set of particles.\n    \n    Args:\n        positions (np.ndarray): Particle positions (N, 3) in kpc.\n        velocities (np.ndarray): Particle velocities (N, 3) in km/s.\n        masses (np.ndarray): Particle masses (N,) in M_sun.\n        epsilon (float): Softening length in kpc.\n        m_host (float): Host mass in M_sun.\n        r_host (np.ndarray): Host position (3,) in kpc.\n        max_iter (int): Maximum number of iterations.\n        \n    Returns:\n        list: A sorted list of indices of the finally bound particles.\n    \"\"\"\n    G = 4.30091e-6  # kpc * (km/s)^2 / M_sun\n    \n    num_particles = len(positions)\n    is_bound_mask = np.ones(num_particles, dtype=bool)\n    \n    for _ in range(max_iter):\n        num_bound_before = np.sum(is_bound_mask)\n        \n        if num_bound_before == 0:\n            break\n            \n        current_indices = np.where(is_bound_mask)[0]\n        \n        # Get data for currently bound particles\n        m_bound = masses[is_bound_mask]\n        r_bound = positions[is_bound_mask]\n        v_bound = velocities[is_bound_mask]\n\n        # Step 1: Compute center of mass position and velocity\n        m_total = np.sum(m_bound)\n        r_com = np.sum(m_bound[:, np.newaxis] * r_bound, axis=0) / m_total\n        v_com = np.sum(m_bound[:, np.newaxis] * v_bound, axis=0) / m_total\n        \n        # Step 2: Calculate energy components for each bound particle\n        \n        # Specific Kinetic Energy\n        v_rel = v_bound - v_com\n        kinetic_energy = 0.5 * np.sum(v_rel**2, axis=1)\n        \n        # Specific Self-Potential Energy\n        if num_bound_before > 1:\n            diffs = r_bound[:, np.newaxis, :] - r_bound[np.newaxis, :, :]\n            dist_sq = np.sum(diffs**2, axis=2)\n            dists_soft = np.sqrt(dist_sq + epsilon**2)\n            \n            # Create a matrix of potential contributions: pot_matrix[i, j] is pot from j onto i\n            pot_matrix = -G * m_bound[np.newaxis, :] / dists_soft\n            np.fill_diagonal(pot_matrix, 0) # Exclude self-potential (j != i)\n            self_potential = np.sum(pot_matrix, axis=1)\n        else:\n            self_potential = np.zeros(1)\n\n        # Specific Tidal Potential Energy\n        R_vec = r_host - r_com\n        R = np.linalg.norm(R_vec)\n        if R == 0: # Avoid division by zero if halo is at host center\n            tidal_tensor = np.zeros((3, 3))\n        else:\n            n_hat = R_vec / R\n            n_outer = np.outer(n_hat, n_hat)\n            tidal_tensor = (G * m_host / R**3) * (3 * n_outer - np.identity(3))\n        \n        # Displacement vectors from COM\n        x_disp = r_bound - r_com\n        # Einstein summation for x^T * T * x for all particles\n        tidal_potential = 0.5 * np.einsum('ij,jk,ik->i', x_disp, tidal_tensor, x_disp)\n\n        # Step 3: Total energy and identifying unbound particles\n        total_energy = kinetic_energy + self_potential + tidal_potential\n        is_unbound_in_subset = total_energy >= 0\n        \n        # Step 4: Update the bound set and check for convergence\n        unbound_global_indices = current_indices[is_unbound_in_subset]\n\n        if len(unbound_global_indices) == 0:\n            # Converged\n            break\n        \n        is_bound_mask[unbound_global_indices] = False\n    \n    return np.where(is_bound_mask)[0].tolist()\n\ndef solve():\n    \"\"\"\n    Solves the unbinding problem for the defined test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (compact, weak tide)\n        {\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.3, 0.1, 0.0], [-0.2, -0.1, 0.1], \n                [0.1, -0.3, 0.2], [-0.1, 0.2, -0.2]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 0.0, 0.0], [8.0, 0.0, 0.0], [-5.0, 2.0, 1.0], \n                [3.0, -4.0, 2.0], [-2.0, 1.0, -3.0]\n            ]),\n            \"masses\": np.full(5, 1.0e8),\n            \"epsilon\": 0.1,\n            \"m_host\": 1.0e12,\n            \"r_host\": np.array([300.0, 0.0, 0.0]),\n            \"max_iter\": 10\n        },\n        # Test case 2 (moderate tide, some unbinding)\n        {\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.3, 0.1, 0.0], [-0.2, -0.1, 0.1], \n                [0.1, -0.3, 0.2], [-0.1, 0.2, -0.2], [2.0, 0.0, 0.0]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 0.0, 0.0], [6.0, 0.0, 0.0], [-4.0, 1.5, 0.5], \n                [2.5, -3.0, 1.5], [-1.5, 0.5, -2.5], [50.0, 0.0, 0.0]\n            ]),\n            \"masses\": np.full(6, 2.0e8),\n            \"epsilon\": 0.05,\n            \"m_host\": 1.0e12,\n            \"r_host\": np.array([50.0, 0.0, 0.0]),\n            \"max_iter\": 10\n        },\n        # Test case 3 (mixed masses, borderline)\n        {\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [0.0, 0.5, 0.0], [0.0, 0.0, 0.5]\n            ]),\n            \"velocities\": np.array([\n                [0.0, 0.0, 0.0], [12.0, 0.0, 0.0], [0.0, 12.0, 0.0], [0.0, 0.0, 12.0]\n            ]),\n            \"masses\": np.array([3.0e8, 1.0e8, 2.0e8, 1.5e8]),\n            \"epsilon\": 0.1,\n            \"m_host\": 5.0e11,\n            \"r_host\": np.array([1000.0, 1000.0, 0.0]),\n            \"max_iter\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        bound_indices = perform_unbinding(**case)\n        results.append(bound_indices)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3480808"}, {"introduction": "一个静态的暗晕目录本身已经很有用，但宇宙学模拟的真正威力在于追踪这些结构如何随宇宙时间成长、合并和演化。最后一个练习 [@problem_id:3480850] 聚焦于构建“合并树”这一核心任务，通过暗晕在连续时间步之间共享的粒子来建立它们之间的联系。你将亲手实现识别“祖先”与“后代”的逻辑，计算诸如质量吸积率等关键演化属性，并精确锁定一个暗晕首次落入更大宿主结构等重要事件。", "problem": "考虑代表小型宇宙学区域的多个玩具数据集在时间 $t_0$ 和 $t_1$ 的两次连续模拟输出。在每个数据集中，每个暗物质晕都由其唯一标识符、一组粒子标识符、其质量、其共动位置矢量和其维里半径来表征。假设粒子质量为常数 $m_p = 10^{10}\\ M_\\odot$，因此晕的质量 $M(h)$ 由 $M(h) = |P(h)| \\cdot m_p$ 给出，其中 $P(h)$ 是其粒子标识符的集合。时间以十亿年 (Gyr) 为单位，位置以共动百万秒差距 (Mpc) 为单位，维里半径以共动百万秒差距 (Mpc) 为单位，质量以太阳质量 ($M_\\odot$) 为单位。\n\n你必须仅使用以下基本定义，即时计算前身-后代链接、构建分支、记录首次落入时间，并计算质量吸积率：\n\n- 前身-后代优值：对于在 $t_0$ 时的前身晕 $p$ 和在 $t_1$ 时的候选后代晕 $d$，定义 $S(p,d) = |P(p) \\cap P(d)|$。一个前身晕 $p$ 会前向链接到能使 $S(p,d)$ 最大化的后代晕 $d$，前提是满足分数重叠判据 $S(p,d)/|P(p)| \\ge f_{\\min}$，其中 $f_{\\min} = 0.5$。平局情况按 $S(p,d)$ 较大、然后 $M(d)$ 较大、然后 $d$ 的标识符较小的顺序打破。\n- 每个后代的主前身：对于给定的后代晕 $d$，在上一步中选择 $d$ 的所有前身晕中，选择具有最大 $S(p,d)$ 的那个作为主前身。平局情况按 $M(p)$ 较大、然后 $p$ 的标识符较小的顺序打破。如果没有前身晕选择 $d$，则视 $d$ 为新形成的晕，为了计算吸积，其有效前身质量为 $M_0(d) = 0$。\n- 质量吸积率：对于每个后代晕 $d$，将其在 $t_1$ 时的质量定义为 $M_1(d)$，其主前身在 $t_0$ 时的质量定义为 $M_0(d)$（如果没有主前身则为 $0$）。质量吸积率为 $\\dot{M}(d) = \\big(M_1(d) - M_0(d)\\big)/\\Delta t$，其中 $\\Delta t = t_1 - t_0$。$\\dot{M}(d)$ 以 $M_\\odot/\\mathrm{Gyr}$ 为单位表示。\n- 子晕识别和首次落入时间：在给定的时间 $t$，如果存在一个不同的晕 $H$ 满足 $M(H)  M(h)$ 和 $\\|\\mathbf{x}(h) - \\mathbf{x}(H)\\| \\le R_{\\mathrm{vir}}(H)$，则晕 $h$ 是一个子晕。对于在 $t_1$ 时的后代晕 $d$，如果 $d$ 在 $t_1$ 时是一个子晕，而其主前身（如果存在）在 $t_0$ 时不是子晕，则将其首次落入时间定义为 $t_1$。否则，返回 $-1$。落入时间以 $\\mathrm{Gyr}$ 为单位表示。\n\n实现一个严格遵守这些定义的算法。除这些定义外，不要假设任何其他公式。\n\n程序必须独立处理以下四个数据集（测试套件）并汇总结果。对于每个数据集，使用 $t_0 = 0.0\\ \\mathrm{Gyr}$，$t_1 = 1.0\\ \\mathrm{Gyr}$，因此 $\\Delta t = 1.0\\ \\mathrm{Gyr}$。\n\n数据集 A (具有首次落入的理想情况)：\n- $t_0$ 时的晕：\n  - id $10$，$P = \\{1,2,3,4,5,6\\}$，位置 $(0.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.25\\ \\mathrm{Mpc}$。\n  - id $20$，$P = \\{100,101,102,103,104,105,106,107\\}$，位置 $(1.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.30\\ \\mathrm{Mpc}$。\n- $t_1$ 时的晕：\n  - id $11$，$P = \\{1,2,3,4,5,200,201\\}$，位置 $(0.9,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.27\\ \\mathrm{Mpc}$。\n  - id $21$，$P = \\{100,101,102,103,104,105,106,300,301\\}$，位置 $(1.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.32\\ \\mathrm{Mpc}$。\n\n数据集 B (边界平局情况和新形成的晕)：\n- $t_0$ 时的晕：\n  - id $30$，$P = \\{1,2,3,4\\}$，位置 $(0.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n  - id $40$，$P = \\{10,11,12,13\\}$，位置 $(2.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n- $t_1$ 时的晕：\n  - id $31$，$P = \\{1,2,50,51\\}$，位置 $(0.1,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n  - id $41$，$P = \\{3,4,60,61\\}$，位置 $(2.1,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n\n数据集 C (并合：两个前身晕到一个后代晕)：\n- $t_0$ 时的晕：\n  - id $50$，$P = \\{1,2,3,4,5\\}$，位置 $(0.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.26\\ \\mathrm{Mpc}$。\n  - id $60$，$P = \\{10,11,12,13,14\\}$，位置 $(0.3,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.26\\ \\mathrm{Mpc}$。\n- $t_1$ 时的晕：\n  - id $51$，$P = \\{1,2,3,10,11,12,200\\}$，位置 $(0.15,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.27\\ \\mathrm{Mpc}$。\n\n数据集 D (未满足链接阈值和宿主诱导的首次落入)：\n- $t_0$ 时的晕：\n  - id $70$，$P = \\{1,2,3,4\\}$，位置 $(0.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n  - id $80$，$P = \\{20,21,22,23\\}$，位置 $(10.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n  - id $90$，$P = \\{1000,1001,1002,1003,1004,1005,1006,1007,1008,1009\\}$，位置 $(2.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.50\\ \\mathrm{Mpc}$。\n- $t_1$ 时的晕：\n  - id $71$，$P = \\{1,100,101,102\\}$，位置 $(0.05,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n  - id $81$，$P = \\{20,21,22,23\\}$，位置 $(10.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.24\\ \\mathrm{Mpc}$。\n  - id $91$，$P = \\{1000,1001,1002,1003,1004,1005,1006,1007,1008,1009\\}$，位置 $(0.0,0.0,0.0)$ $\\mathrm{Mpc}$，$R_{\\mathrm{vir}} = 0.50\\ \\mathrm{Mpc}$。\n\n对于每个数据集，执行链接和分析，然后通过按升序对 $t_1$ 晕的标识符进行排序来生成一个有序结果，并按此顺序为每个 $t_1$ 晕 $d$ 将序对 $\\big(\\dot{M}(d), t_{\\mathrm{infall}}(d)\\big)$ 附加到一个扁平化的输出列表中。在这里，$t_{\\mathrm{infall}}(d)$ 为 $t_1$ 当且仅当 $d$ 按照上述判据经历了首次落入，否则为 $-1$。$\\dot{M}$ 以 $M_\\odot/\\mathrm{Gyr}$ 为单位表示，$t_{\\mathrm{infall}}$ 以 $\\mathrm{Gyr}$ 为单位表示。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，依次列出数据集 A、数据集 B、数据集 C 和数据集 D 的结果，每个数据集按指定的 $t_1$ 标识符顺序贡献其序对。列表元素必须是数字（浮点数或整数）。不应打印任何额外文本。\n\n该测试套件旨在涵盖：\n- 一个具有清晰链接和首次落入事件的标准案例。\n- 分数重叠阈值上的边界平局情况，导致确定性的平局打破和一个新形成的晕。\n- 一次并合，其中两个前身晕链接到一个后代晕，并且必须选择主前身。\n- 一个前身晕未满足链接阈值，并检测到宿主诱导的首次落入的案例。", "solution": "我们从提供的定义中阐述的基本原理出发。每个晕由其粒子成员来表征，晕的质量由此得出，为 $M = |P| \\cdot m_p$，其中 $m_p = 10^{10}\\ M_\\odot$。从时间 $t_0$ 到 $t_1$ 的前向链接是通过最大化粒子重叠优值 $S(p,d) = |P(p)\\cap P(d)|$ 来定义的，且需满足条件 $S/|P(p)| \\ge f_{\\min}$，其中 $f_{\\min} = 0.5$。后代晕的主前身是在那些选择了它的前身晕中，通过相同的 $S$、 $M$ 和标识符平局打破规则来选择的。子晕的识别遵循相对于更大质量宿主晕的几何判据。后代晕 $d$ 的质量吸积率为 $\\dot{M}(d) = \\big(M_1(d)-M_0(d)\\big)/\\Delta t$，其中 $M_0(d)$ 是主前身的质量（若无则为 $0$），且 $\\Delta t = t_1 - t_0 = 1.0\\ \\mathrm{Gyr}$。如果后代晕在 $t_1$ 时是一个子晕，而其主前身在 $t_0$ 时不是子晕，则首次落入时间为 $t_1$，否则设为 $-1$。\n\n现在我们将此应用于每个数据集。\n\n数据集 A：\n- 参数：$t_0 = 0.0\\ \\mathrm{Gyr}$，$t_1 = 1.0\\ \\mathrm{Gyr}$，$\\Delta t = 1.0\\ \\mathrm{Gyr}$。\n- $t_0$ 时的晕：id $10$，$|P| = 6 \\Rightarrow M = 6\\times 10^{10}\\ M_\\odot$；id $20$，$|P| = 8 \\Rightarrow M = 8\\times 10^{10}\\ M_\\odot$。\n- $t_1$ 时的晕：id $11$，$|P| = 7 \\Rightarrow M = 7\\times 10^{10}\\ M_\\odot$；id $21$，$|P| = 9 \\Rightarrow M = 9\\times 10^{10}\\ M_\\odot$。\n\n链接优值：\n- 对于前身晕 10 到后代晕，$S(10,11) = |\\{1,2,3,4,5,6\\}\\cap \\{1,2,3,4,5,200,201\\}| = 5$，所以 $S/|P(10)| = 5/6 \\approx 0.833 \\ge 0.5$。$S(10,21) = 0$。因此 $10 \\to 11$。\n- 对于前身晕 20 到后代晕，$S(20,21) = |\\{100,\\dots,107\\}\\cap \\{100,101,102,103,104,105,106,300,301\\}| = 7$，所以 $S/|P(20)| = 7/8 = 0.875 \\ge 0.5$。$S(20,11) = 0$。因此 $20 \\to 21$。\n\n$t_1$ 时的主要前身晕：\n- 对于后代晕 11，只有前身晕 10 选择了它，所以主前身是 10。\n- 对于后代晕 21，只有前身晕 20 选择了它，所以主前身是 20。\n\n质量吸积率：\n- $\\dot{M}(11) = \\big(7\\times 10^{10} - 6\\times 10^{10}\\big)/1.0 = 1\\times 10^{10}\\ M_\\odot/\\mathrm{Gyr}$。\n- $\\dot{M}(21) = \\big(9\\times 10^{10} - 8\\times 10^{10}\\big)/1.0 = 1\\times 10^{10}\\ M_\\odot/\\mathrm{Gyr}$。\n\n首次落入：\n- $t_1$ 时的子晕测试：对于 11 相对于 21，$\\|\\mathbf{x}(11)-\\mathbf{x}(21)\\| = \\sqrt{(0.9-1.0)^2} = 0.1\\ \\mathrm{Mpc} \\le R_{\\mathrm{vir}}(21) = 0.32\\ \\mathrm{Mpc}$ 且 $M(21)  M(11)$，所以 11 在 $t_1$ 时是一个子晕。在 $t_0$ 时，对于 10 相对于 20，距离 $\\sqrt{(0.0-1.0)^2} = 1.0\\ \\mathrm{Mpc}  R_{\\mathrm{vir}}(20) = 0.30\\ \\mathrm{Mpc}$，所以不是子晕。因此，对于 11，首次落入时间为 $t_1 = 1.0\\ \\mathrm{Gyr}$。\n- 对于 21，在 $t_1$ 时没有质量更大的晕，所以不是子晕；首次落入时间为 -1。\n\n按 $t_1$ 标识符 $(11, 21)$ 排序，输出为 $\\big(1\\times 10^{10}, 1.0\\big)$ 和 $\\big(1\\times 10^{10}, -1\\big)$。\n\n数据集 B：\n- $t_0$ 时的晕 30 和 40 各有 $|P| = 4 \\Rightarrow 4\\times 10^{10}\\ M_\\odot$。$t_1$ 时的晕 31 和 41 各有 $|P| = 4 \\Rightarrow 4\\times 10^{10}\\ M_\\odot$。\n- 前身晕 30 的链接优值：$S(30,31) = |\\{1,2,3,4\\}\\cap \\{1,2,50,51\\}| = 2$，$S/|P| = 2/4 = 0.5$；$S(30,41) = |\\{1,2,3,4\\}\\cap \\{3,4,60,61\\}| = 2$，$S/|P| = 0.5$。$S$ 和 $M(d)$ 相同，出现平局；按较小的后代标识符打破平局，所以 $30 \\to 31$。\n- 前身晕 40 与两个后代晕的交集都为零，因此没有形成链接。\n- 主前身：31 的主前身是 30；41 没有主前身（新形成的）。\n- 质量吸积率：$\\dot{M}(31) = (4\\times 10^{10} - 4\\times 10^{10})/1.0 = 0$，$\\dot{M}(41) = (4\\times 10^{10} - 0)/1.0 = 4\\times 10^{10}$。\n- 首次落入：在 $t_0$ 和 $t_1$ 时，晕之间的距离都远大于 $R_{\\mathrm{vir}}$，且没有质量更大的宿主晕，所以两者都不是子晕。两者的首次落入时间均为 -1。\n\n按 $t_1$ 标识符 $(31, 41)$ 排序，输出为 $\\big(0, -1\\big)$ 和 $\\big(4\\times 10^{10}, -1\\big)$。\n\n数据集 C：\n- $t_0$ 时的晕 50 和 60 各有 $|P| = 5 \\Rightarrow 5\\times 10^{10}\\ M_\\odot$。$t_1$ 时的晕 51 有 $|P| = 7 \\Rightarrow 7\\times 10^{10}\\ M_\\odot$。\n- 链接优值：$S(50,51) = |\\{1,2,3,4,5\\}\\cap \\{1,2,3,10,11,12,200\\}| = 3$，所以 $3/5 = 0.6 \\ge 0.5$。$S(60,51) = |\\{10,11,12,13,14\\}\\cap \\{1,2,3,10,11,12,200\\}| = 3$，所以 $0.6 \\ge 0.5$。两个前身晕都链接到 51。\n- 51 的主前身选择：$S$ 和 $M$ 相同，出现平局，按较小的标识符打破平局，所以主前身是 50。\n- 质量吸积率：$\\dot{M}(51) = (7\\times 10^{10} - 5\\times 10^{10})/1.0 = 2\\times 10^{10}$。\n- 首次落入：在 $t_1$ 时没有质量更大的宿主晕，所以不是子晕；首次落入时间为 -1。\n\n按 $t_1$ 标识符 $(51)$ 排序，输出为 $\\big(2\\times 10^{10}, -1\\big)$。\n\n数据集 D：\n- $t_0$ 时的晕：70 和 80，$|P| = 4 \\Rightarrow 4\\times 10^{10}\\ M_\\odot$；90，$|P| = 10 \\Rightarrow 1\\times 10^{11}\\ M_\\odot$。\n- $t_1$ 时的晕：71，$|P| = 4 \\Rightarrow 4\\times 10^{10}\\ M_\\odot$；81，$|P| = 4 \\Rightarrow 4\\times 10^{10}\\ M_\\odot$；91，$|P| = 10 \\Rightarrow 1\\times 10^{11}\\ M_\\odot$。\n- 链接优值：\n  - 前身晕 70 到 71：$S(70,71) = |\\{1,2,3,4\\}\\cap \\{1,100,101,102\\}| = 1$，所以 $1/4 = 0.25  0.5$，无链接。到其他晕的交集为零。\n  - 前身晕 80 到 81：$S(80,81) = 4$，所以 $4/4 = 1.0 \\ge 0.5$，链接 $80 \\to 81$。\n  - 前身晕 90 到 91：$S(90,91) = 10$，所以 $10/10 = 1.0 \\ge 0.5$，链接 $90 \\to 91$。\n- 主前身：71 没有主前身（新形成的），81 的主前身是 80，91 的主前身是 90。\n- 质量吸积率：$\\dot{M}(71) = (4\\times 10^{10} - 0)/1.0 = 4\\times 10^{10}$，$\\dot{M}(81) = (4\\times 10^{10} - 4\\times 10^{10})/1.0 = 0$，$\\dot{M}(91) = (1\\times 10^{11} - 1\\times 10^{11})/1.0 = 0$。\n- 首次落入：\n  - 对于 $t_1$ 时的 71，到 91 的距离是 $\\|\\mathbf{x}(71)-\\mathbf{x}(91)\\| = \\sqrt{(0.05-0.0)^2} = 0.05\\ \\mathrm{Mpc} \\le R_{\\mathrm{vir}}(91) = 0.50\\ \\mathrm{Mpc}$，且 $M(91)  M(71)$，所以 71 在 $t_1$ 时是一个子晕。在 $t_0$ 时，前身晕 70 相对于 90 的距离为 $\\sqrt{(0.0-2.0)^2} = 2.0\\ \\mathrm{Mpc}  0.50\\ \\mathrm{Mpc}$，所以不是子晕。首次落入时间为 $t_1 = 1.0\\ \\mathrm{Gyr}$。\n  - 对于 81，没有质量更大且邻近的宿主晕，所以不是子晕；首次落入时间为 -1。\n  - 对于 91，没有质量更大的宿主晕；首次落入时间为 -1。\n\n按 $t_1$ 标识符 $(71, 81, 91)$ 排序，输出为 $\\big(4\\times 10^{10}, 1.0\\big)$、$\\big(0, -1\\big)$ 和 $\\big(0, -1\\big)$。\n\n按 A、B、C、D 的顺序聚合所有数据集的结果，并在每个数据集中按 $t_1$ 标识符升序将序对扁平化，得到最终的数字列表：\n- 数据集 A：$\\left[1.0\\times 10^{10},\\ 1.0,\\ 1.0\\times 10^{10},\\ -1.0\\right]$。\n- 数据集 B：$\\left[0.0,\\ -1.0,\\ 4.0\\times 10^{10},\\ -1.0\\right]$。\n- 数据集 C：$\\left[2.0\\times 10^{10},\\ -1.0\\right]$。\n- 数据集 D：$\\left[4.0\\times 10^{10},\\ 1.0,\\ 0.0,\\ -1.0,\\ 0.0,\\ -1.0\\right]$。\n\n这些值就是程序必须按照指定顺序输出的单个扁平化列表，其中 $\\dot{M}$ 的单位是 $M_\\odot/\\mathrm{Gyr}$，时间的单位是 $\\mathrm{Gyr}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef euclidean_distance(x, y):\n    return float(np.linalg.norm(np.array(x) - np.array(y)))\n\ndef link_progenitors_to_descendants(t0_halos, t1_halos, f_min=0.5):\n    \"\"\"\n    Forward link each progenitor (at t0) to at most one descendant (at t1)\n    based on shared particle count S(p,d) and threshold S/|P(p)| >= f_min.\n    Ties: higher S, then higher descendant mass, then smaller descendant id.\n    Returns:\n        forward_link: dict {prog_id: desc_id}\n        S_matrix: dict {(prog_id, desc_id): S}\n    \"\"\"\n    S_matrix = {}\n    forward_link = {}\n\n    for p in t0_halos:\n        best = None  # tuple (S, M_desc, -id_desc, desc_id)\n        best_desc_id = None\n        Pp = set(p['particles'])\n        for d in t1_halos:\n            Pd = set(d['particles'])\n            S = len(Pp.intersection(Pd))\n            S_matrix[(p['id'], d['id'])] = S\n        \n        for d in t1_halos:\n            S = S_matrix[(p['id'], d['id'])]\n            num_p_particles = len(p['particles'])\n            frac = S / num_p_particles if num_p_particles > 0 else 0\n            if frac >= f_min:\n                cand = (S, d['mass'], -d['id'], d['id'])\n                if best is None or cand > best:\n                    best = cand\n                    best_desc_id = d['id']\n        if best_desc_id is not None:\n            forward_link[p['id']] = best_desc_id\n    return forward_link, S_matrix\n\ndef main_progenitor_per_descendant(t0_halos, t1_halos, forward_link, S_matrix):\n    \"\"\"\n    Among progenitors that forward-linked to a given descendant, select main progenitor:\n    highest S, then higher progenitor mass, then smaller progenitor id.\n    Returns:\n        main_prog: dict {desc_id: prog_id or None}\n    \"\"\"\n    desc_candidates = {d['id']: [] for d in t1_halos}\n    t0_id_to_halo = {h['id']: h for h in t0_halos}\n    \n    for p_id, d_id in forward_link.items():\n        S = S_matrix[(p_id, d_id)]\n        p_mass = t0_id_to_halo[p_id]['mass']\n        desc_candidates[d_id].append((S, p_mass, -p_id, p_id))\n    \n    main_prog = {}\n    for d in t1_halos:\n        did = d['id']\n        cands = desc_candidates[did]\n        if not cands:\n            main_prog[did] = None\n        else:\n            cands.sort(reverse=True)\n            main_prog[did] = cands[0][3]\n    return main_prog\n\ndef is_subhalo_at_time(target, halos_same_time):\n    \"\"\"\n    Determine if 'target' halo is a subhalo among halos at the same time:\n    exists host H with M(H) > M(target) and distance = Rvir(H).\n    \"\"\"\n    x_t = target['pos']\n    m_t = target['mass']\n    for H in halos_same_time:\n        if H['id'] == target['id']:\n            continue\n        if H['mass'] > m_t:\n            d = euclidean_distance(x_t, H['pos'])\n            if d = H['rvir']:\n                return True\n    return False\n\ndef analyze_dataset(t0_halos, t1_halos, t0, t1, f_min=0.5):\n    \"\"\"\n    Perform linking, main progenitor selection, accretion rate, and first infall detection.\n    Returns a flat list ordered by ascending t1 halo id:\n        [dotM(d1), infall_time_or_minus1(d1), dotM(d2), infall_time_or_minus1(d2), ...]\n    \"\"\"\n    forward_link, S_matrix = link_progenitors_to_descendants(t0_halos, t1_halos, f_min=f_min)\n    main_prog = main_progenitor_per_descendant(t0_halos, t1_halos, forward_link, S_matrix)\n    t0_map = {h['id']: h for h in t0_halos}\n    dt = t1 - t0\n    results = []\n    \n    for d in sorted(t1_halos, key=lambda h: h['id']):\n        d_id = d['id']\n        M1 = float(d['mass'])\n        p_id = main_prog[d_id]\n        \n        if p_id is None:\n            M0 = 0.0\n            sub_at_t0 = False\n        else:\n            progenitor_halo = t0_map[p_id]\n            M0 = float(progenitor_halo['mass'])\n            sub_at_t0 = is_subhalo_at_time(progenitor_halo, t0_halos)\n            \n        dotM = (M1 - M0) / dt\n        \n        sub_at_t1 = is_subhalo_at_time(d, t1_halos)\n        \n        if sub_at_t1 and not sub_at_t0:\n            t_infall = float(t1)\n        else:\n            t_infall = -1.0\n            \n        results.append(float(dotM))\n        results.append(float(t_infall))\n        \n    return results\n\ndef build_halo(id_, particles, pos, rvir, mp=1.0e10):\n    return {\n        'id': id_,\n        'particles': list(particles),\n        'pos': tuple(pos),\n        'rvir': float(rvir),\n        'mass': float(len(particles) * mp),\n    }\n\ndef solve():\n    mp = 1.0e10\n    # Dataset A\n    A_t0 = [\n        build_halo(10, [1,2,3,4,5,6], (0.0,0.0,0.0), 0.25, mp),\n        build_halo(20, [100,101,102,103,104,105,106,107], (1.0,0.0,0.0), 0.30, mp),\n    ]\n    A_t1 = [\n        build_halo(11, [1,2,3,4,5,200,201], (0.9,0.0,0.0), 0.27, mp),\n        build_halo(21, [100,101,102,103,104,105,106,300,301], (1.0,0.0,0.0), 0.32, mp),\n    ]\n    # Dataset B\n    B_t0 = [\n        build_halo(30, [1,2,3,4], (0.0,0.0,0.0), 0.24, mp),\n        build_halo(40, [10,11,12,13], (2.0,0.0,0.0), 0.24, mp),\n    ]\n    B_t1 = [\n        build_halo(31, [1,2,50,51], (0.1,0.0,0.0), 0.24, mp),\n        build_halo(41, [3,4,60,61], (2.1,0.0,0.0), 0.24, mp),\n    ]\n    # Dataset C\n    C_t0 = [\n        build_halo(50, [1,2,3,4,5], (0.0,0.0,0.0), 0.26, mp),\n        build_halo(60, [10,11,12,13,14], (0.3,0.0,0.0), 0.26, mp),\n    ]\n    C_t1 = [\n        build_halo(51, [1,2,3,10,11,12,200], (0.15,0.0,0.0), 0.27, mp),\n    ]\n    # Dataset D\n    D_t0 = [\n        build_halo(70, [1,2,3,4], (0.0,0.0,0.0), 0.24, mp),\n        build_halo(80, [20,21,22,23], (10.0,0.0,0.0), 0.24, mp),\n        build_halo(90, [1000,1001,1002,1003,1004,1005,1006,1007,1008,1009], (2.0,0.0,0.0), 0.50, mp),\n    ]\n    D_t1 = [\n        build_halo(71, [1,100,101,102], (0.05,0.0,0.0), 0.24, mp),\n        build_halo(81, [20,21,22,23], (10.0,0.0,0.0), 0.24, mp),\n        build_halo(91, [1000,1001,1002,1003,1004,1005,1006,1007,1008,1009], (0.0,0.0,0.0), 0.50, mp),\n    ]\n\n    t0 = 0.0\n    t1 = 1.0\n    all_results = []\n    \n    all_results.extend(analyze_dataset(A_t0, A_t1, t0, t1, f_min=0.5))\n    all_results.extend(analyze_dataset(B_t0, B_t1, t0, t1, f_min=0.5))\n    all_results.extend(analyze_dataset(C_t0, C_t1, t0, t1, f_min=0.5))\n    all_results.extend(analyze_dataset(D_t0, D_t1, t0, t1, f_min=0.5))\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3480850"}]}