{"hands_on_practices": [{"introduction": "在对任何偏微分方程进行数值求解时，首要步骤都是将其离散化，即将连续的方程转化为计算机可以处理的代数方程组。本练习将重点介绍有限差分法，这是一种最常用的离散化技术。我们将应用该方法处理在$f(R)$引力理论中至关重要的拉普拉斯算子（Laplacian operator），为构建更复杂的数值求解器奠定坚实的基础 [@problem_id:3487331]。", "problem": "考虑一个 $f(R)$ 类型的修正引力理论的准静态、次视界极限，其中标量场 $f_{R}$ 遵循一个与物质密度衬度耦合的椭圆型偏微分方程（PDE）。在标度因子为 $a$ 的共动笛卡尔坐标 $\\boldsymbol{x}=(x,y,z)$ 中，该方程的形式为\n$$\n\\nabla^{2} f_{R}(\\boldsymbol{x}) \\;=\\; \\frac{a^{2}}{3}\\Big[\\,\\delta R\\big(f_{R}(\\boldsymbol{x})\\big) \\;-\\; 8\\pi G\\,\\delta\\rho(\\boldsymbol{x})\\,\\Big],\n$$\n其中 $\\delta R\\big(f_{R}\\big)$ 表示作为 $f_{R}$ 的局域泛函的里奇标量扰动，$G$ 是牛顿引力常数，而 $\\delta\\rho$ 是物质密度扰动。\n\n您将在一个表示固定标度因子 $a$ 的单个宇宙学时间切片的均匀三维笛卡尔网格上对此方程进行离散化。设网格由点 $\\boldsymbol{x}_{i,j,k}=(x_{i},y_{j},z_{k})$ 定义，其均匀间距为 $\\Delta x=\\Delta y=\\Delta z=h$，并令 $f_{R\\,i,j,k}$ 表示 $f_{R}$ 在网格点 $(i,j,k)$ 处的值。类似地，定义 $\\delta\\rho_{i,j,k}$ 并在局域将 $\\delta R$ 计算为 $\\delta R\\!\\big(f_{R\\,i,j,k}\\big)$。\n\n从笛卡尔坐标下拉普拉斯算子的定义以及光滑函数在均匀网格上的泰勒展开出发，推导在内部网格点 $(i,j,k)$ 处拉普拉斯算子 $\\nabla^{2} f_{R}$ 的一个二阶精度的中心有限差分格式。仅使用导数的基本定义和泰勒展开来确定您所推导格式的精度阶数。然后，使用您的拉普拉斯算子近似以及 $\\delta R$ 和 $\\delta\\rho$ 的局域计算值，写出在点 $(i,j,k)$ 处该椭圆型方程的离散形式。\n\n您的最终答案必须是给出在 $(i,j,k)$ 处 $\\nabla^{2} f_{R}$ 的二阶精度有限差分格式的单个闭式解析表达式。不需要单位。不要四舍五入；给出精确的符号表达式。", "solution": "出发点是笛卡尔坐标中拉普拉斯算子的定义，\n$$\n\\nabla^{2} f_{R} \\;=\\; \\frac{\\partial^{2} f_{R}}{\\partial x^{2}} \\;+\\; \\frac{\\partial^{2} f_{R}}{\\partial y^{2}} \\;+\\; \\frac{\\partial^{2} f_{R}}{\\partial z^{2}}.\n$$\n在每个方向上间距均为 $h$ 的均匀网格上，我们通过使用从泰勒展开推导出的中心有限差分公式来为每个二阶导数构建二阶精度的近似。\n\n考虑一个定义在均匀点 $x_{i}=x_{0}+i h$ 上的一维光滑函数 $g$。关于 $x_{i}$ 的泰勒展开为\n\\begin{align*}\ng(x_{i}+h) = g(x_{i}) \\;+\\; h\\,g'(x_{i}) \\;+\\; \\frac{h^{2}}{2}\\,g''(x_{i}) \\;+\\; \\frac{h^{3}}{6}\\,g^{(3)}(x_{i}) \\;+\\; \\frac{h^{4}}{24}\\,g^{(4)}(\\xi_{+}), \\\\\ng(x_{i}-h) = g(x_{i}) \\;-\\; h\\,g'(x_{i}) \\;+\\; \\frac{h^{2}}{2}\\,g''(x_{i}) \\;-\\; \\frac{h^{3}}{6}\\,g^{(3)}(x_{i}) \\;+\\; \\frac{h^{4}}{24}\\,g^{(4)}(\\xi_{-}),\n\\end{align*}\n其中 $\\xi_{+}$ 和 $\\xi_{-}$ 分别位于区间 $(x_{i},x_{i}+h)$ 和 $(x_{i}-h,x_{i})$ 内。将这两个展开式相加并减去 $2 g(x_{i})$ 可得\n$$\ng(x_{i}+h) - 2 g(x_{i}) + g(x_{i}-h) \\;=\\; h^{2} g''(x_{i}) \\;+\\; \\frac{h^{4}}{12}\\,g^{(4)}(\\xi),\n$$\n其中 $\\xi$ 位于 $x_{i}-h$ 和 $x_{i}+h$ 之间。两边同除以 $h^{2}$ 得到二阶导数的中心差分近似，\n$$\n\\frac{g(x_{i}+h) - 2 g(x_{i}) + g(x_{i}-h)}{h^{2}} \\;=\\; g''(x_{i}) \\;+\\; \\mathcal{O}\\!\\left(h^{2}\\right).\n$$\n这表明中心二阶差分是二阶精度的。\n\n将此构造独立地应用于每个笛卡尔方向上的 $f_{R}$。记 $f_{R\\,i,j,k} \\equiv f_{R}(x_{i},y_{j},z_{k})$。则\n\\begin{align*}\n\\frac{\\partial^{2} f_{R}}{\\partial x^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i+1,j,k} - 2 f_{R\\,i,j,k} + f_{R\\,i-1,j,k}}{h^{2}}, \\\\\n\\frac{\\partial^{2} f_{R}}{\\partial y^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i,j+1,k} - 2 f_{R\\,i,j,k} + f_{R\\,i,j-1,k}}{h^{2}}, \\\\\n\\frac{\\partial^{2} f_{R}}{\\partial z^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i,j,k+1} - 2 f_{R\\,i,j,k} + f_{R\\,i,j,k-1}}{h^{2}}.\n\\end{align*}\n将这三个近似相加，得到均匀笛卡尔网格上拉普拉斯算子的标准二阶精度七点有限差分格式：\n$$\n\\nabla^{2} f_{R}\\big|_{(i,j,k)} \\;\\approx\\; \\frac{f_{R\\,i+1,j,k} + f_{R\\,i-1,j,k} + f_{R\\,i,j+1,k} + f_{R\\,i,j-1,k} + f_{R\\,i,j,k+1} + f_{R\\,i,j,k-1} - 6 f_{R\\,i,j,k}}{h^{2}},\n$$\n其截断误差为 $\\mathcal{O}\\!\\left(h^{2}\\right)$，继承自一维二阶导数近似。\n\n为了离散化该椭圆型标量场方程，我们在点 $(i,j,k)$ 处对右侧进行局域求值，使用函数依赖关系 $\\delta R\\!\\big(f_{R\\,i,j,k}\\big)$ 和采样的密度衬度 $\\delta\\rho_{i,j,k}$。在一个内部网格点处得到的离散方程为\n$$\n\\frac{f_{R\\,i+1,j,k} + f_{R\\,i-1,j,k} + f_{R\\,i,j+1,k} + f_{R\\,i,j-1,k} + f_{R\\,i,j,k+1} + f_{R\\,i,j,k-1} - 6 f_{R\\,i,j,k}}{h^{2}}\n\\;=\\;\n\\frac{a^{2}}{3}\\Big[\\,\\delta R\\!\\big(f_{R\\,i,j,k}\\big) \\;-\\; 8\\pi G\\,\\delta\\rho_{i,j,k}\\,\\Big],\n$$\n对于光滑的 $f_{R}$，该方程在 $h$ 上具有二阶精度。\n\n所要求的最终表达式，即在 $(i,j,k)$ 处 $\\nabla^{2} f_{R}$ 的二阶精度有限差分格式，是上式所示的分子除以 $h^{2}$。", "answer": "$$\\boxed{\\frac{f_{R\\,i+1,j,k}+f_{R\\,i-1,j,k}+f_{R\\,i,j+1,k}+f_{R\\,i,j-1,k}+f_{R\\,i,j,k+1}+f_{R\\,i,j,k-1}-6 f_{R\\,i,j,k}}{h^{2}}}$$", "id": "3487331"}, {"introduction": "$f(R)$引力理论的核心挑战在于其场方程的非线性特性，这正是“筛选机制”（screening mechanisms）等关键物理现象的根源。本练习将介绍一种强大且高效的数值方法——牛顿-多重网格法（Newton-multigrid method），专门用于求解这些复杂的非线性椭圆型偏微分方程。掌握此方法是开发研究级修改引力模拟代码的关键一步，它将数值效率与处理强非线性的能力完美结合 [@problem_id:3487385]。", "problem": "考虑一个无量纲标量场方程，它表示方形域上度规 $f(R)$ 引力在准静态极限下的 $f_{R}$ 标量。令 $u(x,y)$ 表示无量纲场 $u \\equiv f_{R} / \\bar{f}_{R}$，其中 $\\bar{f}_{R}$ 是一个均匀背景值。在与宇宙学结构形成相关的高曲率区域，修正的爱因斯坦方程的迹可以导出一个示意形式如下的非线性椭圆偏微分方程 (PDE)：\n$$\n\\nabla^{2} u = \\kappa \\left( u^{-n} - 1 \\right) + s(x,y),\n$$\n其中 $\\kappa > 0$ 是一个无量纲耦合常数，编码了对广义相对论修正的强度；$n > 0$ 控制非线性程度；$s(x,y)$ 是一个与物质密度扰动成正比的无量纲源项。假设在单位方形域 $[0,1] \\times [0,1]$ 上，边界 $\\partial \\Omega$ 满足 Dirichlet 边界条件 $u = 1$。任何三角函数内的角度都必须解释为弧度。\n\n从基本原理和经过充分检验的数值方法出发，为该非线性椭圆偏微分方程构建一个 Newton–多重网格 V-循环求解器。设计必须从以下几点开始：\n- 椭圆算子的定义以及在均匀网格上对 $\\nabla^{2}$ 的有限差分近似。\n- 将 Newton 法（也称为 Newton–Raphson 法）应用于非线性残差，以产生一系列线性化校正问题。\n- 在每个 Newton 步中，使用多重网格 V-循环来近似求解线性化系统 $J(u) \\, \\delta u = -R(u)$，其中 $R(u)$ 是离散非线性残差，$J(u)$ 是离散化算子的 Jacobian 矩阵。\n\n您的构建必须指明：\n1. 在大小为 $N \\times N$、间距为 $h$ 的均匀网格上，使用 $\\nabla^{2}$ 的二阶中心有限差分近似来表示离散残差 $R(u)$，并考虑边界节点上 $u=1$ 的 Dirichlet 边界条件。\n2. 局部非线性项的 Jacobian 矩阵组装，包括其关于 $u$ 的导数的解析表达式，该导数项贡献于 $J(u)$ 的对角线。\n3. 每个网格层级上的松弛格式，用作线性化系统的光滑子。使用加权 Jacobi 方法，松弛参数为 $\\omega \\in (0,1)$。\n4. 粗网格校正，包括：\n   - 将残差全加权限制到下一个更粗的网格。\n   - 将粗网格校正双线性延长回更细的网格。\n   - 在粗网格上使用限制后的 $u$ 进行重新线性化，以一致地组装粗网格 Jacobian 矩阵的对角线。\n5. 基于残差下降的鲁棒收敛准则。令 $\\| R(u) \\|_{2}$ 表示使用网格间距 $h$ 计算的离散 $L^{2}$ 范数。在初始猜测值 $u^{(0)}$ 处定义初始残差范数 $\\| R(u^{(0)}) \\|_{2}$。如果以下两个条件同时成立，则 Newton 迭代视为收敛：\n   - 下降比 $\\rho \\equiv \\| R(u^{(k)}) \\|_{2} / \\| R(u^{(0)}) \\|_{2}$ 满足 $\\rho \\le \\theta$，其中 $\\theta$ 是一个指定的阈值。\n   - 绝对残差范数满足 $\\| R(u^{(k)}) \\|_{2} \\le \\varepsilon$，其中 $\\varepsilon$ 是一个指定的容差。\n使用最大 Newton 迭代次数以防止无限循环。实施简单的线搜索或步长阻尼，以在更新期间保持内部节点上 $u$ 的正性。\n\n离散化要求：\n- 使用大小为 $N \\times N$ 的均匀网格，其中 $N = 2^{\\ell} + 1$（对于某个整数 $\\ell \\ge 3$），以便可以进行标准粗化直至 $3 \\times 3$ 的网格。\n- 在内部节点上对 $\\nabla^{2}$ 使用二阶中心有限差分，离散模板为 $[1,1,-4,1,1]/h^{2}$。\n- 源项 $s(x,y)$ 必须指定为\n$$\ns(x,y) = A \\left[ \\sin(2\\pi x) \\sin(2\\pi y) + \\tfrac{1}{4} \\sin(4\\pi x) \\sin(2\\pi y) \\right],\n$$\n其中振幅 $A$ 是一个无量纲标量。角度以弧度为单位。\n\nNewton–多重网格规格：\n- Jacobian 矩阵 $J(u)$ 是离散拉普拉斯算子与来自非线性项导数的对角线贡献之和。对于非线性项 $\\kappa(u^{-n} - 1)$，其关于 $u$ 的导数是 $\\kappa n u^{-n-1}$，这在网格上贡献了一个逐点的对角项。在需要时，通过将 $u$ 计算为 $\\max(u,\\epsilon)$ 来使用一个小的正数 $\\epsilon$ 以避免在 $u^{-n}$ 和 $u^{-n-1}$ 中出现除以零的错误。\n- 在每个层级上使用加权 Jacobi 光滑，松弛因子为 $\\omega$，并固定前光滑迭代次数为 $\\nu_{1}$，后光滑迭代次数为 $\\nu_{2}$。\n- 对网格间的传输使用全加权限制和双线性延长。\n- 在最粗层级上，用在该网格上进行额外的松弛迭代来代替粗网格求解。\n\n收敛准则和输出：\n- 将残差的离散 $L^{2}$ 范数计算为\n$$\n\\| R(u) \\|_{2} = \\left( h^{2} \\sum_{i,j} R(u)_{i,j}^{2} \\right)^{1/2}.\n$$\n- 对于每个测试用例，报告求解器是否在最大 Newton 迭代次数内满足收敛准则（$\\rho \\le \\theta$ 和 $\\| R(u) \\|_{2} \\le \\varepsilon$）。每个用例的输出必须是一个布尔值，$\\mathrm{True}$ 表示成功收敛，$\\mathrm{False}$ 表示未成功。\n\n测试套件：\n提供一个程序，为以下参数集运行求解器。在所有情况下，都施加 Dirichlet 边界条件 $u=1$，初始猜测值为 $u^{(0)} \\equiv 1$，$s(x,y)$ 中的角度以弧度为单位，最终输出必须是单行，包含用方括号括起来的、以逗号分隔的结果列表。\n\n- 用例 1 (理想路径): $N=65$, $\\kappa=1.0$, $n=1.0$, $A=0.1$, $\\omega=0.8$, $\\nu_{1}=3$, $\\nu_{2}=3$, 最大 Newton 迭代次数 $=20$, $\\theta=10^{-6}$, $\\varepsilon=10^{-8}$。\n- 用例 2 (更强的非线性): $N=33$, $\\kappa=2.0$, $n=2.0$, $A=0.3$, $\\omega=0.75$, $\\nu_{1}=4$, $\\nu_{2}=4$, 最大 Newton 迭代次数 $=25$, $\\theta=10^{-6}$, $\\varepsilon=10^{-8}$。\n- 用例 3 (近线性区域): $N=65$, $\\kappa=0.2$, $n=1.0$, $A=0.05$, $\\omega=0.8$, $\\nu_{1}=3$, $\\nu_{2}=3$, 最大 Newton 迭代次数 $=15$, $\\theta=10^{-7}$, $\\varepsilon=10^{-9}$。\n- 用例 4 (较粗网格，中等非线性): $N=17$, $\\kappa=1.5$, $n=1.5$, $A=0.2$, $\\omega=0.7$, $\\nu_{1}=4$, $\\nu_{2}=4$, 最大 Newton 迭代次数 $=20$, $\\theta=10^{-6}$, $\\varepsilon=10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[b_{1},b_{2},b_{3},b_{4}]$），其中每个 $b_{i}$ 是一个布尔值，表示相应测试用例的收敛情况。", "solution": "用户要求为在 $f(R)$ 引力背景下出现的非线性椭圆偏微分方程 (PDE) 构建一个 Newton–多重网格求解器。我将首先验证问题陈述，如果有效，则给出一个数值算法的有条理的推导，最后是完整的实现。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n-   **PDE**: $\\nabla^{2} u = \\kappa \\left( u^{-n} - 1 \\right) + s(x,y)$。\n-   **参数**: $\\kappa > 0$, $n > 0$。\n-   **场**: $u(x,y)$。\n-   **域**: $\\Omega = [0,1] \\times [0,1]$。\n-   **边界条件 (BC)**: Dirichlet, $u=1$ on $\\partial \\Omega$。\n-   **源项**: $s(x,y) = A \\left[ \\sin(2\\pi x) \\sin(2\\pi y) + \\tfrac{1}{4} \\sin(4\\pi x) \\sin(2\\pi y) \\right]$，角度参数以弧度为单位。\n-   **离散化**:\n    -   网格: 均匀 $N \\times N$, $N = 2^{\\ell} + 1$ for $\\ell \\ge 3$。\n    -   网格间距: $h = 1/(N-1)$。\n    -   拉普拉斯算子近似: 二阶中心有限差分，模板 $[1,1,-4,1,1]/h^2$。\n-   **求解方法**: Newton–多重网格 V-循环。\n    -   **Newton法**: 求解线性化系统 $J(u) \\, \\delta u = -R(u)$ 以获得校正量 $\\delta u$。\n    -   **非线性残差, $R(u)$**: $\\nabla^2 u - \\kappa(u^{-n}-1) - s(x,y)$ 的离散形式。\n    -   **Jacobian矩阵, $J(u)$**: $J(u) = \\text{Laplacian}_h + \\text{diag}(\\kappa n u^{-n-1})$。包括正则化 $u \\rightarrow \\max(u, \\epsilon)$。\n    -   **线搜索**: 简单的步长阻尼以维持 $u > 0$。\n-   **多重网格组件**:\n    -   **光滑子**: 带松弛因子 $\\omega$ 的加权 Jacobi 方法。\n    -   **扫描次数**: $\\nu_1$ 次前光滑，$\\nu_2$ 次后光滑迭代。\n    -   **网格传输**: 全加权限制，双线性延长。\n    -   **最粗网格**: 通过额外的松弛迭代求解。\n    -   **粗网格算子**: 使用限制后的解 $u_c$ 重新线性化。\n-   **收敛准则**:\n    -   相对残差下降: $\\| R(u^{(k)}) \\|_{2} / \\| R(u^{(0)}) \\|_{2} \\le \\theta$。\n    -   绝对残差容差: $\\| R(u^{(k)}) \\|_{2} \\le \\varepsilon$。\n    -   最大Newton迭代次数。\n-   **$L^2$ 范数定义**: $\\| R(u) \\|_{2} = \\left( h^{2} \\sum_{i,j} R(u)_{i,j}^{2} \\right)^{1/2}$，求和遍及内部节点。\n-   **初始猜测**: $u^{(0)} \\equiv 1$。\n-   **测试用例**: 提供了四个不同的参数集。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n问题具有科学依据，描述了现代宇宙学（$f(R)$ 引力）中使用的简化模型的标准数值方法。该 PDE 是一种著名的非线性椭圆方程（Lane-Emden-Fowler 型）。问题是适定的；带有 Dirichlet 边界条件的方程预计有唯一解，并且所用的数值策略是处理非线性的 Newton 法和处理所得线性系统的多重网格法（也可以使用全近似格式或 FAS，但指定的 Newton–多重网格方法也是有效的）的标准而鲁棒的组合。语言是客观的，所有参数、方法和准则都以数学精度进行了陈述。\n\n验证未发现任何缺陷。该问题并非不合理、不完整、矛盾或不适定。所要求的任务是数值分析和计算物理学中一个标准但并非无足轻重的课题。\n\n**步骤 3：结论与行动**\n\n问题是有效的。将构建一个解决方案。\n\n### 算法构建\n\n问题的核心是找到满足该 PDE 的解 $u(x,y)$。我们将使用有限差分进行离散化，并使用 Newton 法求解得到的非线性代数方程组，其中每个线性步骤都由一个多重网格 V-循环加速。\n\n**1. 离散化与非线性残差**\n\n我们定义一个均匀网格，点坐标为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$，$h=1/(N-1)$。令 $u_{i,j} \\approx u(x_i, y_j)$。该 PDE 可以重写为残差方程 $R(u) = 0$，其中\n$$\nR(u) \\equiv \\nabla^2 u - \\kappa(u^{-n} - 1) - s(x,y) = 0.\n$$\n使用拉普拉斯算子的二阶中心有限差分近似，内部节点 $(i,j)$ 的离散残差为：\n$$\nR(u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} - \\kappa\\left(u_{i,j}^{-n} - 1\\right) - s_{i,j} = 0.\n$$\n对于边界节点，$u_{i,j}=1$，残差未定义。我们寻求一个网格函数 $u$，使得对于所有内部节点 $i,j \\in \\{1, \\dots, N-2\\}$，都有 $R(u)_{i,j}=0$。\n\n**2. 求解非线性系统的 Newton 法**\n\nNewton 法通过迭代找到 $R(u)=0$ 的根。给定一个近似解 $u^{(k)}$，通过求解线性化系统来找到下一个近似解 $u^{(k+1)} = u^{(k)} + \\delta u$：\n$$\nR(u^{(k+1)}) \\approx R(u^{(k)}) + J(u^{(k)}) \\delta u = 0,\n$$\n其中 $J(u)$ 是 $R(u)$ 的 Jacobian 矩阵。这导出了关于校正量 $\\delta u$ 的线性系统：\n$$\nJ(u^{(k)}) \\delta u = -R(u^{(k)}).\n$$\nJacobian 矩阵是偏导数矩阵，$J_{ab} = \\partial R_a / \\partial u_b$，其中 $a$ 和 $b$ 是遍历所有网格点的索引。该算子由两部分组成：离散拉普拉斯算子和非线性项的导数。项 $-\\kappa(u^{-n}-1)$ 在点 $(i,j)$ 处关于 $u$ 的导数是 $+\\kappa n u_{i,j}^{-n-1}$。这只影响 Jacobian 矩阵的对角元素。因此，Jacobian 算子作用于网格函数 $\\delta u$ 的结果是：\n$$\n(J(u)\\delta u)_{i,j} = (\\nabla_h^2 \\delta u)_{i,j} + \\left(\\kappa n u_{i,j}^{-n-1}\\right) \\delta u_{i,j}.\n$$\n在解出 $\\delta u$ 后，我们用一个带阻尼的步长来更新解：$u^{(k+1)} = u^{(k)} + \\alpha \\delta u$，其中 $\\alpha \\in (0,1]$ 是一个阻尼因子，选择它的目的是确保所有内部节点上的 $u^{(k+1)}_{i,j} > 0$。\n\n**3. 用于求解线性系统的多重网格 V-循环**\n\n在每个 Newton 步中，我们必须求解一个形式为 $Ax=b$ 的线性系统，其中 $A=J(u^{(k)})$，$x=\\delta u$，$b=-R(u^{(k)})$。这通过使用几何多重网格方法的一个 V-循环来近似完成。\n\n一个 V-循环包含以下递归步骤，从细网格（层级 $\\ell$）移动到粗网格（层级 $\\ell-1$）：\n\n1.  **前光滑**：对当前网格上的系统 $Ax=b$ 应用 $\\nu_1$ 次光滑子（加权 Jacobi）迭代，以得到一个近似解 $x'$。对于一个通用线性系统 $Ax=b$ 的加权 Jacobi 迭代是：\n    $$\n    x^{(m+1)} = (1-\\omega)x^{(m)} + \\omega D^{-1}(b - (A-D)x^{(m)}),\n    $$\n    其中 $D$ 是 $A$ 的对角线。对于我们特定的 Jacobian 矩阵 $J(u)$，对角线元素是 $J_{ii} = -4/h^2 + \\kappa n u_{i,j}^{-n-1}$。\n\n2.  **粗网格校正**：\n    -   计算线性系统的残差：$r' = b - Ax'$。\n    -   将残差限制到下一个更粗的网格：$r_c = \\mathcal{R}(r')$。我们使用**全加权限制**，即一个 $3\\times3$ 细网格点块的加权平均。\n    -   粗网格上的问题是 $A_c e_c = r_c$，其中 $e_c$ 是误差 $e' = x-x'$ 的粗网格表示。问题陈述要求我们在粗网格上**重新线性化**。这意味着我们将当前的非线性解 $u$ 限制得到 $u_c = \\mathcal{R}(u)$，然后组装粗网格算子 $A_c = J(u_c)$。\n    -   通过在粗网格上调用 V-循环来递归地求解 $A_c e_c = r_c$。在最粗层级（一个 $3\\times3$ 网格），通过应用更多次的光滑迭代来求解该系统。\n    -   将误差校正延长回细网格：$e' = \\mathcal{P}(e_c)$。我们使用**双线性延长（插值）**。\n    -   校正细网格解：$x'' = x' + e'$。\n\n3.  **后光滑**：以 $x''$ 为初始猜测，对 $Ax=b$ 应用 $\\nu_2$ 次光滑子迭代，以获得该层级的最终近似解。\n\n**4. 收敛准则**\n\n当非线性残差 $R(u^{(k)})$ 的 $L^2$ 范数足够小时，外部的 Newton 循环终止。离散 $L^2$ 范数定义为 $\\|R(u)\\|_{2} = \\sqrt{h^2 \\sum_{i,j} (R(u)_{i,j})^2}$。必须满足两个条件：\n1.  相对下降：当前残差范数与初始残差范数之比，$\\rho = \\|R(u^{(k)})\\|_2 / \\|R(u^{(0)})\\|_2$，必须小于阈值 $\\theta$。\n2.  绝对容差：当前残差范数 $\\|R(u^{(k)})\\|_2$ 必须小于容差 $\\varepsilon$。\n还强制设置了最大迭代次数以防止不终止。每个测试用例的布尔结果反映了这些准则是否被满足。", "answer": "```python\nimport numpy as np\nfrom math import log2\n\n# A small constant to prevent division by zero in u^(-n) terms.\nU_EPSILON = 1e-12\n\ndef _create_levels_data(N_finest):\n    \"\"\"Creates a list of dictionaries holding data for each grid level.\"\"\"\n    if N_finest  3 or log2(N_finest - 1) != int(log2(N_finest - 1)):\n        raise ValueError(\"N must be of the form 2**l + 1 for integer l >= 1.\")\n    l_finest = int(log2(N_finest - 1))\n    levels_data = []\n    # Levels go from finest (l_finest) down to coarsest (l=1, N=3)\n    for l in range(l_finest, 0, -1):\n        N = 2**l + 1\n        h = 1.0 / (N - 1)\n        levels_data.append({'N': N, 'h': h})\n    return levels_data\n\ndef _setup_source_term(N, A):\n    \"\"\"Initializes the source term s(x,y) on the grid.\"\"\"\n    x_coords = np.linspace(0.0, 1.0, N)\n    xx, yy = np.meshgrid(x_coords, x_coords)\n    s = A * (np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy) + 0.25 * np.sin(4 * np.pi * xx) * np.sin(2 * np.pi * yy))\n    return s\n\ndef _calculate_residual(u, s, h, kappa, n):\n    \"\"\"Calculates the nonlinear residual R(u) on the interior of the grid.\"\"\"\n    res = np.zeros_like(u)\n    u_reg = np.maximum(u, U_EPSILON)\n    \n    lap_u = (u[:-2, 1:-1] + u[2:, 1:-1] + u[1:-1, :-2] + u[1:-1, 2:] - 4 * u[1:-1, 1:-1]) / h**2\n    nonlinear_term = kappa * (u_reg[1:-1, 1:-1]**(-n) - 1.0)\n    \n    res[1:-1, 1:-1] = lap_u - nonlinear_term - s[1:-1, 1:-1]\n    return res\n\ndef _calculate_l2_norm(r, h):\n    \"\"\"Calculates the discrete L2 norm of a grid function over interior points.\"\"\"\n    return np.sqrt(h**2 * np.sum(r[1:-1, 1:-1]**2))\n\ndef _calculate_jacobian_diag_inner(u_inner, h, kappa, n):\n    \"\"\"Calculates the diagonal of the Jacobian J(u) on interior points.\"\"\"\n    u_reg_inner = np.maximum(u_inner, U_EPSILON)\n    diag_inner = -4.0 / h**2 + kappa * n * u_reg_inner**(-n-1)\n    return diag_inner\n\ndef _apply_J(x, u, h, kappa, n):\n    \"\"\"Applies the Jacobian operator J(u) to a grid function x.\"\"\"\n    res = np.zeros_like(x)\n    lap_x_inner = (x[:-2, 1:-1] + x[2:, 1:-1] + x[1:-1, :-2] + x[1:-1, 2:] - 4 * x[1:-1, 1:-1]) / h**2\n    \n    u_reg_inner = np.maximum(u[1:-1, 1:-1], U_EPSILON)\n    jac_diag_term_inner = (kappa * n * u_reg_inner**(-n-1)) * x[1:-1, 1:-1]\n    \n    res[1:-1, 1:-1] = lap_x_inner + jac_diag_term_inner\n    return res\n\ndef _relax(x, b, u, h, kappa, n, omega, nu):\n    \"\"\"Performs nu sweeps of weighted Jacobi relaxation for J(u)x=b.\"\"\"\n    diag_J_inner = _calculate_jacobian_diag_inner(u[1:-1, 1:-1], h, kappa, n)\n\n    for _ in range(nu):\n        lap_x_term = (x[:-2, 1:-1] + x[2:, 1:-1] + x[1:-1, :-2] + x[1:-1, 2:])\n        \n        x_jacobi_inner = (b[1:-1, 1:-1] - lap_x_term / h**2) / diag_J_inner\n        \n        x[1:-1, 1:-1] = (1.0 - omega) * x[1:-1, 1:-1] + omega * x_jacobi_inner\n    return x\n\ndef _restrict(f):\n    \"\"\"Performs full-weighting restriction from a fine grid f to a coarse grid c.\"\"\"\n    Nf = f.shape[0]\n    Nc = (Nf - 1) // 2 + 1\n    c = np.zeros((Nc, Nc))\n    \n    # Interior points\n    c[1:-1, 1:-1] = ( f[1:-2:2, 1:-2:2] + f[1:-2:2, 3::2] + f[3::2, 1:-2:2] + f[3::2, 3::2] + # corners (w=1)\n                    (f[1:-2:2, 2:-1:2] + f[3::2, 2:-1:2] + f[2:-1:2, 1:-2:2] + f[2:-1:2, 3::2]) * 2.0 + # edges (w=2)\n                     f[2:-1:2, 2:-1:2] * 4.0 ) / 16.0 # center (w=4)\n\n    # Boundaries\n    c[0, :] = f[0, ::2]\n    c[-1, :] = f[-1, ::2]\n    c[:, 0] = f[::2, 0]\n    c[:, -1] = f[::2, -1]\n    \n    return c\n    \ndef _prolongate(c):\n    \"\"\"Performs bilinear prolongation from a coarse grid c to a fine grid f.\"\"\"\n    Nc = c.shape[0]\n    Nf = (Nc - 1) * 2 + 1\n    f = np.zeros((Nf, Nf))\n    \n    f[::2, ::2] = c\n    f[1::2, ::2] = (c[:-1, :] + c[1:, :]) / 2.0\n    f[::2, 1::2] = (c[:, :-1] + c[:, 1:]) / 2.0\n    f[1::2, 1::2] = (c[:-1, :-1] + c[1:, :-1] + c[:-1, 1:] + c[1:, 1:]) / 4.0\n    return f\n\ndef _v_cycle(level_idx, b, levels_u, levels_data, params):\n    \"\"\"A single multigrid V-cycle to approximately solve J(u)x = b.\"\"\"\n    kappa, n = params['kappa'], params['n']\n    omega, nu1, nu2 = params['omega'], params['nu1'], params['nu2']\n    \n    u = levels_u[level_idx]\n    h = levels_data[level_idx]['h']\n    \n    x = np.zeros_like(b)\n\n    if level_idx == len(levels_data) - 1: # Coarsest level\n        coarsest_sweeps = 2 * (nu1 + nu2) * (level_idx + 1)\n        x = _relax(x, b, u, h, kappa, n, omega, coarsest_sweeps)\n        return x\n\n    # 1. Pre-smoothing\n    x = _relax(x, b, u, h, kappa, n, omega, nu1)\n\n    # 2. Coarse-grid correction\n    res_fine = b - _apply_J(x, u, h, kappa, n)\n    res_coarse = _restrict(res_fine)\n    \n    correction_coarse = _v_cycle(level_idx + 1, res_coarse, levels_u, levels_data, params)\n    \n    correction_fine = _prolongate(correction_coarse)\n    x += correction_fine\n\n    # 3. Post-smoothing\n    x = _relax(x, b, u, h, kappa, n, omega, nu2)\n    \n    return x\n\ndef run_case(N, kappa, n, A, omega, nu1, nu2, max_newton, theta, epsilon_conv):\n    \"\"\"Runs the Newton-MG solver for a single test case.\"\"\"\n    try:\n        levels_data = _create_levels_data(N)\n    except ValueError as e:\n        print(f\"Error setting up grid: {e}\")\n        return False\n        \n    h_finest = levels_data[0]['h']\n\n    u = np.ones((N, N))\n    s = _setup_source_term(N, A)\n\n    r0 = _calculate_residual(u, s, h_finest, kappa, n)\n    norm_r0 = _calculate_l2_norm(r0, h_finest)\n    if norm_r0  epsilon_conv:\n        return True\n\n    for _ in range(max_newton):\n        r_k = _calculate_residual(u, s, h_finest, kappa, n)\n        norm_r_k = _calculate_l2_norm(r_k, h_finest)\n\n        if norm_r_k = epsilon_conv and norm_r_k / norm_r0 = theta:\n            return True\n\n        b = -r_k\n        \n        levels_u = [u]\n        for i in range(len(levels_data) - 1):\n            levels_u.append(_restrict(levels_u[-1]))\n\n        mg_params = {'kappa': kappa, 'n': n, 'omega': omega, 'nu1': nu1, 'nu2': nu2}\n\n        delta_u = _v_cycle(0, b, levels_u, levels_data, mg_params)\n        \n        alpha = 1.0\n        for _ in range(10): # Line search iterations\n            u_new = u + alpha * delta_u\n            if np.min(u_new[1:-1, 1:-1]) > U_EPSILON:\n                break\n            alpha /= 2.0\n        else: # If loop completes without break\n            return False # Failed to find a positive update\n\n        u = u_new\n\n    return False\n\ndef solve():\n    test_cases = [\n        {'N': 65, 'kappa': 1.0, 'n': 1.0, 'A': 0.1, 'omega': 0.8, 'nu1': 3, 'nu2': 3, 'max_newton': 20, 'theta': 1e-6, 'epsilon_conv': 1e-8},\n        {'N': 33, 'kappa': 2.0, 'n': 2.0, 'A': 0.3, 'omega': 0.75, 'nu1': 4, 'nu2': 4, 'max_newton': 25, 'theta': 1e-6, 'epsilon_conv': 1e-8},\n        {'N': 65, 'kappa': 0.2, 'n': 1.0, 'A': 0.05, 'omega': 0.8, 'nu1': 3, 'nu2': 3, 'max_newton': 15, 'theta': 1e-7, 'epsilon_conv': 1e-9},\n        {'N': 17, 'kappa': 1.5, 'n': 1.5, 'A': 0.2, 'omega': 0.7, 'nu1': 4, 'nu2': 4, 'max_newton': 20, 'theta': 1e-6, 'epsilon_conv': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        converged = run_case(**case)\n        results.append(str(converged))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3487385"}, {"introduction": "仅仅编写出求解器是不够的，我们还必须严格检验其输出结果是否物理上自洽且准确。本练习将演示如何实施一系列关键的检验程序，这些程序基于守恒律和比安基恒等式（Bianchi identity）等基本物理原理。此外，它还将指导你验证一个核心的理论预测：在适当的参数极限下（即 $|f_{R0}| \\to 0$），你的数值解能否正确地回归到广义相对论的结果，从而确保模拟的物理可靠性 [@problem_id:3487398]。", "problem": "开发一个完整的程序，在一维周期性域上，针对$f(R)$型修正引力的一个简单玩具模型中的准静态标量自由度，进行解的质量和一致性检验，并演示当 $f_{R0} \\to 0$ 时数值上恢复广义相对论（GR）极限。该程序必须是自洽的，并按指定格式生成单行输出。\n\n您必须从以下经过充分测试的、适用于牛顿规范下类$f(R)$模型的准静态、亚水平尺度极限的场内容出发。令 $a$ 表示标度因子，$G$ 为牛顿引力常数，$\\delta \\rho$ 为共动物质密度扰动，$\\delta f_R$ 为标量场（scalaron）扰动，$\\Phi$ 和 $\\Psi$ 为两个Bardeen势：\n- 标量场（亥姆霍兹型）方程：\n$$\n\\left(\\nabla^2 - a^2 m^2(a)\\right)\\, \\delta f_R \\;=\\; \\frac{a^2}{3}\\, \\delta \\rho \\, .\n$$\n- 修正的泊松方程：\n$$\n\\nabla^2 \\Psi \\;=\\; 4 \\pi G a^2 \\, \\delta \\rho \\;-\\; \\frac{1}{2}\\, \\nabla^2 \\delta f_R \\, .\n$$\n- 引力滑移关系：\n$$\n\\Phi - \\Psi \\;=\\; \\delta f_R \\, .\n$$\n由此，透镜组合满足比安基恒等式层面的一致性条件：\n$$\n\\nabla^2(\\Phi + \\Psi) \\;=\\; 8 \\pi G a^2 \\, \\delta \\rho \\, .\n$$\n\n采用一个长度为 $L$ 的一维周期性盒子，盒内有 $N$ 个点的均匀网格，并使用快速傅里叶变换（FFT）以谱方法求解椭圆方程。在单一历元 $a = 1$ 下工作，并采用 $4 \\pi G a^2 = 1$ 的单位制，使得标准的广义相对论泊松方程为 $\\nabla^2 \\Psi_{\\mathrm{GR}} = \\delta \\rho$。使用一个均值为零的单模物质扰动：\n$$\n\\delta \\rho(x) \\;=\\; A \\, \\sin(k_{\\star} x) \\, ,\n$$\n其中 $k_{\\star} = 2\\pi / L$，振幅为 $A$。使用足够大的 $N$ 以解析此正弦波。通过在傅里叶空间中进行代数除法，在周期性边界条件下用谱方法求解 $\\delta f_R$ 和 $\\Psi$，并注意处理 $k=0$ 模式，以确保场保持零均值。\n\n为了以一种具有正确广义相对论定性极限的方式来参数化$f(R)$模型，使用一个玩具但科学上合理的有效质量标度关系，\n$$\nm(a) \\;=\\; \\frac{H_0}{\\sqrt{|f_{R0}|}} \\, a^{-3/2} \\, ,\n$$\n并在所选单位制中设定 $H_0 = 1$，因此在 $a=1$ 时有 $m = 1/\\sqrt{|f_{R0}|}$。这反映了 $|f_{R0}| \\to 0$ 意味着标量场质量很大，并随着 $\\delta f_R \\to 0$ 恢复到广义相对论极限这一事实。\n\n实现以下定量诊断，每个都表示为一个无量纲数：\n1. 标量场方程和修正泊松方程的残差范数。将实空间中的残差定义为\n$$\n\\mathcal{R}_f \\equiv \\nabla^2 \\delta f_R - a^2 m^2 \\delta f_R - \\frac{a^2}{3} \\delta \\rho \\, ,\n\\quad\n\\mathcal{R}_P \\equiv \\nabla^2 \\Psi - 4 \\pi G a^2 \\delta \\rho + \\frac{1}{2} \\nabla^2 \\delta f_R \\, .\n$$\n报告归一化的均方根（RMS）范数，\n$$\n\\|\\mathcal{R}_f\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_f^2 \\rangle}}{\\sqrt{\\left\\langle \\left(\\frac{a^2}{3}\\delta \\rho \\right)^2 \\right\\rangle}} \\, ,\n\\quad\n\\|\\mathcal{R}_P\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_P^2 \\rangle}}{\\sqrt{\\langle (4\\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, ,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示在周期性域上的平均。\n\n2. 标量场方程的类能不变量检验。定义\n$$\nQ \\equiv \\int_0^L \\left[ (\\partial_x \\delta f_R)^2 + a^2 m^2 (\\delta f_R)^2 \\right] \\, dx \\, ,\n\\qquad\nS \\equiv \\int_0^L \\left( \\frac{a^2}{3} \\delta \\rho \\, \\delta f_R \\right) \\, dx \\, .\n$$\n使用周期性边界条件，场方程意味着平衡条件 $Q + S = 0$。报告无量纲偏差\n$$\n\\mathcal{E}_{\\mathrm{bal}} \\equiv \\frac{|Q + S|}{|Q| + |S|} \\, .\n$$\n\n3. 使用导出的透镜方程进行比安基恒等式层面的透镜一致性检验，\n$$\n\\mathcal{R}_L \\equiv \\nabla^2(\\Phi + \\Psi) - 8 \\pi G a^2 \\delta \\rho \\, ,\n\\quad\n\\|\\mathcal{R}_L\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_L^2 \\rangle}}{\\sqrt{\\langle (8 \\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, .\n$$\n\n4. 广义相对论恢复误差，\n$$\n\\mathcal{E}_{\\mathrm{GR}} \\equiv \\frac{\\sqrt{\\left\\langle \\left( \\nabla^2 \\Psi - 4 \\pi G a^2 \\delta \\rho \\right)^2 \\right\\rangle}}{\\sqrt{\\langle (4 \\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, ,\n$$\n当 $f_{R0} \\to 0$ 时，此值必须趋近于 $0$。\n\n所有场都应通过谱微分在离散网格上求值：在网格上计算离散傅里葉模式 $k_n = 2\\pi n/L$（其中$n$为整数），逐个模式构建代数解，然后逆变换回实空间。仔细处理 $k=0$ 模式以避免除以 $0$。\n\n使用以下测试套件，周期性盒子长度 $L = 2\\pi$，网格大小 $N = 256$，振幅 $A = 1$，标度因子 $a = 1$，以及 $4\\pi G a^2 = 1$：\n- 情况1：$f_{R0} = -10^{-4}$。\n- 情况2：$f_{R0} = -10^{-6}$。\n- 情况3：$f_{R0} = -10^{-8}$。\n- 情况4：$f_{R0} = -10^{-12}$。\n\n对每种情况，求解 $\\delta f_R$, $\\Psi$ 和 $\\Phi$，计算五种诊断量 $\\|\\mathcal{R}_f\\|$, $\\|\\mathcal{R}_P\\|$, $\\|\\mathcal{R}_L\\|$, $\\mathcal{E}_{\\mathrm{bal}}$ 和 $\\mathcal{E}_{\\mathrm{GR}}$，并按以下顺序将结果汇总为单一的扁平列表\n$$\n\\left[ \\|\\mathcal{R}_f\\|_1, \\|\\mathcal{R}_P\\|_1, \\|\\mathcal{R}_L\\|_1, \\mathcal{E}_{\\mathrm{bal},1}, \\mathcal{E}_{\\mathrm{GR},1}, \\ldots, \\|\\mathcal{R}_f\\|_4, \\|\\mathcal{R}_P\\|_4, \\|\\mathcal{R}_L\\|_4, \\mathcal{E}_{\\mathrm{bal},4}, \\mathcal{E}_{\\mathrm{GR},4} \\right] \\, .\n$$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[r1,r2,r3,...]”）。所有报告的量都是无量纲浮点数。角度没有出现，因此不需要角度单位。输出中不得报告任何物理单位；所采用的单位制是计算内部使用的，并且诊断量通过构造是无量纲的。\n\n设计算法时应使其数值稳定，并利用拉普拉斯算子的谱对角化。确保在有限的$|f_{R0}|$下，残差范数相对于$1$很小，并且$\\mathcal{E}_{\\mathrm{GR}}$随着$|f_{R0}|$的减小而减小，从而说明广义相对论极限的数值恢复。", "solution": "该问题要求对一个耦合线性椭圆偏微分方程组进行数值求解，该方程组描述了$f(R)$修正引力玩具模型中的一个标量自由度。求解将在一个一维周期性域上进行，其解的质量必须通过一套定量诊断来验证。一个关键目标是演示广义相对论（GR）极限的数值恢复。\n\n指导求解的基本原理是使用基于快速傅里葉变换（FFT）的谱方法。这种方法非常适合求解周期性域上的常系数线性偏微分方程。原因是构成傅里葉级数基的复指数函数是微分算子的本征函数。因此，傅里葉变换将拉普拉斯算子 $\\nabla^2 = d^2/dx^2$ 对角化。对于一个傅里葉变换为 $\\hat{g}(k)$ 的函数 $g(x)$，其二阶导数的变换由简单的代数关系 $\\widehat{\\nabla^2 g}(k) = (ik)^2 \\hat{g}(k) = -k^2 \\hat{g}(k)$ 给出，其中 $k$ 是波数。这个性质将微分方程转化为一组针对每个傅里葉模式 $k$ 的独立代数方程，这些方程可以轻松求解。\n\n让我们概述一下系统化的步骤。\n\n首先，我们建立计算域和离散化。我们在长度为 $L$ 的周期性域上使用一个包含 $N$ 个点 $x_j = j (L/N)$（$j = 0, 1, \\ldots, N-1$）的均匀网格。相应的离散傅里葉波数由 $k_n = (2\\pi/L)n$ 给出，其中整数 $n$ 根据FFT算法的要求进行适当排列。我们使用 `numpy.fft.fftfreq` 工具来按标准顺序生成这些波数。问题指定了物理参数：标度因子 $a=1$，盒子长度 $L=2\\pi$，网格大小 $N=256$，以及物质扰动振幅 $A=1$。采用的单位制中，$4\\pi G a^2 = 1$ 且 $H_0 = 1$。物质扰动是一个单一的正弦模式，$\\delta \\rho(x) = A \\sin(k_{\\star} x)$，其中 $k_{\\star} = 2\\pi/L = 1$。这个源项的均值为零，因此其 $k=0$ 的傅里葉模式为零。\n\n求解过程是在傅里葉空间中解给定的方程。\n\n1.  **求解标量场方程：**\n    标量场扰动 $\\delta f_R$ 的控制方程是一个亥姆霍兹型方程：\n    $$ \\left(\\nabla^2 - a^2 m^2\\right)\\, \\delta f_R \\;=\\; \\frac{a^2}{3}\\, \\delta \\rho $$\n    在傅里葉空间中，它变为：\n    $$ \\left(-k^2 - a^2 m^2\\right)\\, \\widehat{\\delta f_R}(k) \\;=\\; \\frac{a^2}{3}\\, \\widehat{\\delta \\rho}(k) $$\n    其中 $\\widehat{\\delta f_R}$ 和 $\\widehat{\\delta \\rho}$ 分别是 $\\delta f_R$ 和 $\\delta \\rho$ 的傅里葉变换。质量参数 $m$ 由 $m = H_0/\\sqrt{|f_{R0}|} \\, a^{-3/2}$ 给出，在给定参数下简化为 $m^2 = 1/|f_{R0}|$。标量场傅里葉模式的代数解是：\n    $$ \\widehat{\\delta f_R}(k) \\;=\\; -\\frac{(a^2/3) \\widehat{\\delta \\rho}(k)}{k^2 + a^2 m^2} $$\n    由于 $\\widehat{\\delta \\rho}(k=0) = 0$，所以 $k=0$ 模式 $\\widehat{\\delta f_R}(k=0)$ 也为零，这保证了 $\\delta f_R$ 具有零均值。通过应用逆FFT可以恢复实空间场 $\\delta f_R(x)$。\n\n2.  **求解修正的泊松方程：**\n    引力势 $\\Psi$ 的方程是：\n    $$ \\nabla^2 \\Psi \\;=\\; 4 \\pi G a^2 \\, \\delta \\rho \\;-\\; \\frac{1}{2}\\, \\nabla^2 \\delta f_R $$\n    变换到傅里葉空间得到：\n    $$ -k^2 \\hat{\\Psi}(k) \\;=\\; (4 \\pi G a^2) \\, \\widehat{\\delta \\rho}(k) \\;-\\; \\frac{1}{2}\\,(-k^2 \\widehat{\\delta f_R}(k)) $$\n    $$ \\hat{\\Psi}(k) \\;=\\; -\\frac{4 \\pi G a^2}{k^2} \\, \\widehat{\\delta \\rho}(k) \\;-\\; \\frac{1}{2}\\, \\widehat{\\delta f_R}(k) $$\n    对于 $k \\neq 0$ 的模式，该方程可以直接求解。对于 $k=0$ 模式，第一项是 $0/0$ 的形式。我们通过施加势具有零均值的物理条件来解决这个不定性，这意味着 $\\hat{\\Psi}(k=0)=0$。然后通过逆FFT找到实空间势 $\\Psi(x)$。\n\n3.  **计算第二个势 $\\Phi$：**\n    第二个Bardeen势 $\\Phi$ 由引力滑移关系确定：\n    $$ \\Phi(x) \\;=\\; \\Psi(x) + \\delta f_R(x) $$\n    这只是将在实空间中已计算出的两个场简单相加。\n\n在确定了场 $\\delta f_R$、$\\Psi$ 和 $\\Phi$ 之后，我们计算四个所需的诊断量。为确保高精度并避免引入有限差分误差，诊断所需的所有空间导数也通过谱方法计算（即，在傅里葉空间中进行乘法，然后进行逆FFT）。所有平均值 $\\langle \\cdot \\rangle$ 都作为网格点上的均值计算，而积分 $\\int_0^L (\\cdot) dx$ 则通过平均值乘以域长度 $L$ 来计算。\n\n1.  **残差范数 $\\|\\mathcal{R}_f\\|$ 和 $\\|\\mathcal{R}_P\\|$**：这些检验验证了数值解能高精度地满足原始微分方程。残差 $\\mathcal{R}_f$ 和 $\\mathcal{R}_P$ 是使用谱方法计算的导数在实空间中计算的。由于求解方法是基于在傅里葉空间中代数地满足这些方程，残差应该在浮点精度范围内为零。它们的归一化RMS范数测试了数值求解器的自洽性。\n\n2.  **能量平衡 $\\mathcal{E}_{\\mathrm{bal}}$**：这个诊断量验证了一个从标量场方程推导出的类守恒定律。通过将标量场方程乘以 $\\delta f_R$ 并在周期性域上积分（使用分部积分法），可以推导出恒等式 $Q+S=0$，其中 $Q$ 和 $S$ 是指定的积分。无量纲比率 $\\mathcal{E}_{\\mathrm{bal}} = |Q+S|/(|Q|+|S|)$ 应接近于零，这反映了场解和数值积分的准确性。\n\n3.  **透镜一致性 $\\|\\mathcal{R}_L\\|$**：这个检验验证了一个基本恒等式 $\\nabla^2(\\Phi + \\Psi) = 8 \\pi G a^2 \\delta \\rho$，这是底层场方程的直接推论。与其他残差范数类似，$\\|\\mathcal{R}_L\\|$ 应接近机器精度，为整个求解系统的内部一致性提供了强有力的检验。\n\n4.  **GR恢复误差 $\\mathcal{E}_{\\mathrm{GR}}$**：这个关键诊断量化了计算出的势 $\\Psi$ 与标准广义相对论中预期解（其中 $\\nabla^2 \\Psi_{\\mathrm{GR}} = 4 \\pi G a^2 \\delta \\rho$）之间的偏差。误差 $\\mathcal{E}_{\\mathrm{GR}}$ 是GR残差 $\\nabla^2 \\Psi - 4\\pi G a^2 \\delta \\rho$ 的归一化RMS。从修正的泊松方程可知，该残差等于 $-\\frac{1}{2}\\nabla^2\\delta f_R$。在极限 $|f_{R0}| \\to 0$ 下，标量场质量 $m \\to \\infty$，这会抑制标量场 $\\delta f_R \\to 0$。因此，预计 $\\mathcal{E}_{\\mathrm{GR}}$ 将趋近于 $0$，从而证明成功恢复了GR极限。\n\n该实现遍历了指定的 $f_{R0}$ 值（从 $-10^{-4}$ 到 $-10^{-12}$），为每种情况计算这五个诊断量，并将结果汇总到一个列表中以供输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the f(R) toy model equations and computes diagnostics for a suite of test cases.\n    \"\"\"\n\n    def solve_case(f_R0, L, N, A, G_eff, H0, a):\n        \"\"\"\n        Computes the solution and diagnostics for a single f(R) parameter case.\n        \"\"\"\n        # 1. Setup grid and constants\n        x = np.linspace(0, L, N, endpoint=False)\n        dx = L / N\n        k = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define source term and its Fourier transform\n        k_star = 2 * np.pi / L\n        delta_rho = A * np.sin(k_star * x)\n        delta_rho_k = fft(delta_rho)\n\n        # 3. Model parameters\n        a_sq = a**2\n        m_sq = H0**2 / np.abs(f_R0) * a**(-3)\n        \n        # 4. Solve for the scalaron field delta_fR\n        # The equation in Fourier space is: (-k^2 - a^2*m^2) * delta_fR_k = (a^2/3) * delta_rho_k\n        denominator_fR = k**2 + a_sq * m_sq\n        delta_fR_k = -((a_sq / 3.0) * delta_rho_k) / denominator_fR\n        \n        # k=0 mode of delta_rho_k is zero (up to machine precision) for a pure sine wave,\n        # and the denominator is non-zero, so delta_fR_k[0] is correctly ~0.\n        delta_fR = ifft(delta_fR_k).real\n\n        # 5. Solve for the gravitational potential Psi\n        # The equation in Fourier space is: -k^2 * Psi_k = G_eff * delta_rho_k + 0.5 * k^2 * delta_fR_k\n        # This simplifies to: Psi_k = - (G_eff * delta_rho_k / k^2) - 0.5 * delta_fR_k\n        Psi_k = np.zeros_like(k, dtype=np.complex128)\n        k_nonzero_mask = k != 0\n        \n        # For k != 0, solve algebraically.\n        Psi_k[k_nonzero_mask] = - (G_eff * delta_rho_k[k_nonzero_mask]) / k[k_nonzero_mask]**2 - 0.5 * delta_fR_k[k_nonzero_mask]\n        \n        # Psi_k[0] remains 0, enforcing a zero mean for the potential.\n        Psi = ifft(Psi_k).real\n\n        # 6. Compute the second potential Phi\n        Phi = Psi + delta_fR\n\n        # 7. Compute diagnostics\n        \n        # Helper functions for spectral derivatives and norms\n        def laplacian(field_real):\n            field_k = fft(field_real)\n            lap_field_k = -k**2 * field_k\n            return ifft(lap_field_k).real\n\n        def grad(field_real):\n            field_k = fft(field_real)\n            grad_field_k = 1j * k * field_k\n            return ifft(grad_field_k).real\n\n        def rms(field):\n            return np.sqrt(np.mean(field**2))\n\n        # Diagnostic 1: Residual Norms\n        lap_delta_fR = laplacian(delta_fR)\n        R_f = lap_delta_fR - a_sq * m_sq * delta_fR - (a_sq / 3.0) * delta_rho\n        norm_source_f = rms((a_sq / 3.0) * delta_rho)\n        norm_R_f = rms(R_f) / norm_source_f if norm_source_f > 0 else 0.0\n\n        lap_Psi = laplacian(Psi)\n        R_P = lap_Psi - G_eff * delta_rho + 0.5 * lap_delta_fR\n        norm_source_P = rms(G_eff * delta_rho)\n        norm_R_P = rms(R_P) / norm_source_P if norm_source_P > 0 else 0.0\n\n        # Diagnostic 2: Energy Balance\n        grad_delta_fR = grad(delta_fR)\n        integrand_Q = grad_delta_fR**2 + a_sq * m_sq * delta_fR**2\n        Q = np.sum(integrand_Q) * dx\n        \n        integrand_S = (a_sq / 3.0) * delta_rho * delta_fR\n        S = np.sum(integrand_S) * dx\n        \n        denominator_E_bal = np.abs(Q) + np.abs(S)\n        E_bal = np.abs(Q + S) / denominator_E_bal if denominator_E_bal > 0 else 0.0\n\n        # Diagnostic 3: Lensing Consistency\n        Phi_plus_Psi = Phi + Psi\n        lap_Phi_plus_Psi = laplacian(Phi_plus_Psi)\n        R_L = lap_Phi_plus_Psi - 2.0 * G_eff * delta_rho\n        norm_source_L = rms(2.0 * G_eff * delta_rho)\n        norm_R_L = rms(R_L) / norm_source_L if norm_source_L > 0 else 0.0\n        \n        # Diagnostic 4: GR Recovery Error\n        R_GR = lap_Psi - G_eff * delta_rho\n        E_GR = rms(R_GR) / norm_source_P if norm_source_P > 0 else 0.0\n\n        return [norm_R_f, norm_R_P, norm_R_L, E_bal, E_GR]\n\n\n    # Define the test cases from the problem statement.\n    L = 2 * np.pi\n    N = 256\n    A = 1.0\n    a = 1.0\n    G_eff = 1.0  # Corresponds to 4*pi*G*a^2 = 1\n    H0 = 1.0\n    \n    test_cases = [\n        -1e-4,\n        -1e-6,\n        -1e-8,\n        -1e-12,\n    ]\n\n    results = []\n    for f_R0 in test_cases:\n        case_results = solve_case(f_R0, L, N, A, G_eff, H0, a)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3487398"}]}