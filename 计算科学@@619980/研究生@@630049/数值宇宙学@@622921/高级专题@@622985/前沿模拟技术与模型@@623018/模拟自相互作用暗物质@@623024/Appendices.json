{"hands_on_practices": [{"introduction": "任何数值模拟的第一步都是在理论与计算之间架起一座桥梁。这个练习将指导你完成一个基础但至关重要的任务：将一个具有物理意义的可观测量——单位质量的自相互作用截面（$\\sigma/m$）——从其物理单位（如 $\\mathrm{cm}^2/\\mathrm{g}$）转换为模拟代码内部使用的无量纲“代码单位”。通过掌握这种单位换算，你将能够确保模拟中的物理方程在数值上是一致且稳定的，这是所有计算天体物理学家的必备技能 [@problem_id:3488395]。", "problem": "在自相互作用暗物质（Self-Interacting Dark Matter, SIDM）的数值宇宙学模拟中，散射概率通常取决于单位质量的散射截面，记为 $(\\sigma/m)$，其量纲为面积/质量。考虑一个程序，其内部单位制使用 $1$ 千秒差距（$\\mathrm{kpc}$）作为基本长度单位， $1 \\times 10^{10}$ 太阳质量（$\\mathrm{M}_{\\odot}$）作为基本质量单位，以及 $1$ 千米/秒（$\\mathrm{km/s}$）作为基本速度单位。SIDM 的一个常用物理值为 $(\\sigma/m) = 1\\ \\mathrm{cm}^{2}\\ \\mathrm{g}^{-1}$。\n\n从量纲分析和 $(\\sigma/m)$ 的单位为 $L^{2}M^{-1}$ 这个核心定义出发，推导物理值 $(\\sigma/m) = 1\\ \\mathrm{cm}^{2}\\ \\mathrm{g}^{-1}$ 到由给定基本单位所隐含的程序单位的转换关系。使用公认的常数 $1\\ \\mathrm{kpc} = 3.085677581 \\times 10^{21}\\ \\mathrm{cm}$ 和 $1\\ \\mathrm{M}_{\\odot} = 1.98847 \\times 10^{33}\\ \\mathrm{g}$，并将程序单位下的 $(\\sigma/m)$ 视为物理 $(\\sigma/m)$ 与 $L^{2}M^{-1}$ 的程序单位的比值，该程序单位为 $L_{0}^{2}/M_{0}$，其中 $L_{0} = 1\\ \\mathrm{kpc}$ 且 $M_{0} = 1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}$。\n\n计算在模拟中使用的相应 $(\\sigma/m)$ 的程序值。将你的最终答案表示为一个无量纲数，并将结果四舍五入到五位有效数字。", "solution": "该问题要求将自相互作用暗物质单位质量散射截面 $(\\sigma/m)$ 的物理值从物理单位转换为数值模拟程序的内部无量纲单位。这是计算物理学和天体物理学中的一个标准流程，以确保运动方程以一种一致且数值稳定的方式求解。\n\n我们关心的量是单位质量的散射截面，我们将其记为 $(\\sigma/m)$。它的物理量纲是面积除以质量，可以写作 $L^{2}M^{-1}$，其中 $L$ 代表长度，$M$ 代表质量。\n\n给定的物理值为 $(\\sigma/m)_{\\text{phys}} = 1\\ \\mathrm{cm}^2\\ \\mathrm{g}^{-1}$。\n\n模拟程序的内部单位制由一组基本单位定义。对于本问题，相关的基本单位是：\n- 基本长度单位，$L_0 = 1\\ \\mathrm{kpc}$。\n- 基本质量单位，$M_0 = 1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}$。\n（注意：对于此特定转换，所提供的基本速度单位 $V_0 = 1\\ \\mathrm{km/s}$ 并非必需，因为 $(\\sigma/m)$ 的量纲仅涉及长度和质量。）\n\n根据这些基本单位，我们可以构建程序中 $(\\sigma/m)$ 量的内部单位，我们将其记为 $(\\sigma/m)_{\\text{code\\_unit}}$。该单位由量纲 $L^2M^{-1}$ 导出：\n$$ (\\sigma/m)_{\\text{code\\_unit}} = \\frac{L_0^2}{M_0} = \\frac{(1\\ \\mathrm{kpc})^2}{1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}} $$\n\n问题将无量纲的程序值（我们记为 $(\\sigma/m)_{\\text{code}}$）定义为物理值与该量的程序基本单位的比值。\n$$ (\\sigma/m)_{\\text{code}} = \\frac{(\\sigma/m)_{\\text{phys}}}{(\\sigma/m)_{\\text{code\\_unit}}} $$\n\n代入物理值和程序单位的表达式可得：\n$$ (\\sigma/m)_{\\text{code}} = \\frac{1\\ \\mathrm{cm}^2\\ \\mathrm{g}^{-1}}{\\frac{(1\\ \\mathrm{kpc})^2}{1 \\times 10^{10}\\ \\mathrm{M}_{\\odot}}} = \\frac{(1\\ \\mathrm{cm}^2\\ \\mathrm{g}^{-1}) \\cdot (1 \\times 10^{10}\\ \\mathrm{M}_{\\odot})}{(1\\ \\mathrm{kpc})^2} $$\n\n为了计算此表达式并确保其无量纲，我们必须将所有单位转换为一个一致的体系，例如，将 $\\mathrm{kpc}$ 转换为 $\\mathrm{cm}$，将 $\\mathrm{M}_{\\odot}$ 转换为 $\\mathrm{g}$。问题提供了必要的转换因子：\n- $1\\ \\mathrm{kpc} = 3.085677581 \\times 10^{21}\\ \\mathrm{cm}$\n- $1\\ \\mathrm{M}_{\\odot} = 1.98847 \\times 10^{33}\\ \\mathrm{g}$\n\n我们将这些转换因子代入 $(\\sigma/m)_{\\text{code}}$ 的表达式中：\n$$ (\\sigma/m)_{\\text{code}} = \\frac{(1\\ \\mathrm{cm}^2 \\cdot \\mathrm{g}^{-1}) \\cdot (1 \\times 10^{10} \\cdot (1.98847 \\times 10^{33}\\ \\mathrm{g}))}{(3.085677581 \\times 10^{21}\\ \\mathrm{cm})^2} $$\n\n现在我们来简化这个表达式。首先，计算分子：\n$$ \\text{分子} = 1 \\cdot (1 \\times 10^{10}) \\cdot (1.98847 \\times 10^{33})\\ \\mathrm{cm}^2 = 1.98847 \\times 10^{43}\\ \\mathrm{cm}^2 $$\n接下来，计算分母：\n$$ \\text{分母} = (3.085677581 \\times 10^{21})^2\\ \\mathrm{cm}^2 = (3.085677581)^2 \\times 10^{42}\\ \\mathrm{cm}^2 $$\n$$ \\text{分母} \\approx 9.521406856 \\times 10^{42}\\ \\mathrm{cm}^2 $$\n\n现在，我们计算这个比值。分子和分母中的单位 $\\mathrm{cm}^2$ 如预期那样抵消，从而得到一个无量纲数。\n$$ (\\sigma/m)_{\\text{code}} = \\frac{1.98847 \\times 10^{43}}{9.521406856 \\times 10^{42}} = \\frac{1.98847}{9.521406856} \\times 10 $$\n$$ (\\sigma/m)_{\\text{code}} \\approx 0.2088425178 \\times 10 $$\n$$ (\\sigma/m)_{\\text{code}} \\approx 2.088425178 $$\n\n问题要求将最终答案四舍五入到五位有效数字。前五位有效数字是 $2.0884$。第六位数字是 $2$，小于 $5$，所以我们向下舍入。\n$$ (\\sigma/m)_{\\text{code}} \\approx 2.0884 $$\n\n因此，在指定的程序单位下，物理值 $(\\sigma/m) = 1\\ \\mathrm{cm}^{2}\\ \\mathrm{g}^{-1}$ 对应一个约为 $2.0884$ 的无量纲值。", "answer": "$$\\boxed{2.0884}$$", "id": "3488395"}, {"introduction": "在将物理参数转换为代码单位后，下一步自然是实现相互作用的核心物理过程。此练习将引导你为自相互作用暗物质（SIDM）设计并实现一个基于蒙特卡洛方法的粒子对散射模块 [@problem_id:3488392]。你将从动力学理论出发，利用基于核函数的密度估计（类似于平滑粒子流体动力学 SPH 中的方法），推导出在单个时间步内任意一对粒子发生散射的概率。这个练习不仅能加深你对 SIDM 物理模型的理解，还能锻炼你将连续的物理定律转化为离散的、统计上一致的数值算法的能力。", "problem": "你需要在一个最小化的三维N体框架内，使用蒙特卡洛方法，为自相互作用暗物质（SIDM）设计并实现一个统计上一致的散射模块。目标是基于动力学理论和核密度估计，推导、论证并实现单个时间步内每对粒子的散射概率。\n\n使用以下基本依据和定义：\n- 一个粒子穿过具有数密度的背景场时的瞬时碰撞率，正比于散射截面与相对速度的乘积。对于基于质量的描述，一个粒子相对于局部质量密度的碰撞率，正比于单位质量的截面与局部质量密度。\n- 粒子位置处的局部质量密度可以通过光滑粒子流体动力学（SPH）方法，使用一个在体积上积分为1的核函数来估计。\n- 三维空间中的三次样条核函数是归一化的，并具有紧支撑；其值是无量纲间距 $q = r/h$ 的函数，其中 $r$ 是粒子对间距，$h$ 是光滑长度。\n\n任务：\n1. 从动力学理论和基于核函数的密度估计算法出发，推导出一个数学上一致的表达式，用于计算单个时间步内由单个邻近粒子贡献的期望碰撞次数。由此，推导出一个在时间步内最多发生一次散射事件的每对粒子概率，该概率对粒子对标签是对称的，并且在小概率极限下有效。\n2. 指定并实现三维三次样条核函数 $W(r,h)$，其中 $r$ 是间距，$h$ 是光滑长度，其分段定义如下：\n   - 令 $q = r/h$。\n   - 对于 $0 \\le q \\le 1$， $$W(r,h) = \\frac{1}{\\pi h^3}\\left(1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3\\right).$$\n   - 对于 $1 < q \\le 2$， $$W(r,h) = \\frac{1}{\\pi h^3}\\left(\\frac{1}{4}(2 - q)^3\\right).$$\n   - 对于 $q > 2$， $$W(r,h) = 0.$$\n3. 实现一个蒙特卡洛方案，对每个无序粒子对 $(i,j)$ 执行以下操作：\n   - 计算间距 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$ 和相对速度 $v_{ij} = \\lVert \\mathbf{v}_i - \\mathbf{v}_j \\rVert$。\n   - 计算 $W(r_{ij}, h)$，并将时间步内至少发生一次散射的粒子对概率设为由该对中每个粒子贡献的低概率独立事件的并集。\n   - 确保所有每个子步的粒子对概率都保持在用户指定的小值范围内，以维持小概率机制。如果整个时间步中所有粒子对的最大概率超过此界限，则将时间步均匀地划分为 $N_{\\text{sub}}$ 个相等的部分，使得每个子步的粒子对概率不超过该界限。每个子步和每对粒子都使用独立的伯努利试验。\n4. 科学单位、实现约束和数值一致性：\n   - 全程使用国际单位制（SI单位）：\n     - 质量单位为千克（$\\mathrm{kg}$）。\n     - 位置单位为米（$\\mathrm{m}$）。\n     - 速度单位为米/秒（$\\mathrm{m/s}$）。\n     - 光滑长度单位为米（$\\mathrm{m}$）。\n     - 时间单位为秒（$\\mathrm{s}$）。\n     - 单位质量的截面单位为平方米/千克（$\\mathrm{m^2/kg}$）。\n   - 核函数 $W(r,h)$ 的单位是体积的倒数（$\\mathrm{m^{-3}}$）。每对粒子的概率必须是无量纲的。\n   - 为便于测试，随机抽样必须是确定性的；将伪随机种子固定为一个常数。\n5. 程序要求：\n   - 在单个程序中实现以上功能，无需外部输入。\n   - 对每个测试用例，计算在时间步内所有无序粒子对中实际发生的散射事件总数，必要时使用子步方案。将每个测试用例的结果表示为一个整数。\n\n测试套件：\n- 除非另有说明，所有测试用例都使用相同的粒子集。共有 $N=8$ 个粒子，质量相等，为 $m_i = 2.0 \\times 10^{38}\\ \\mathrm{kg}$，光滑长度为 $h = 1.5 \\times 10^{20}\\ \\mathrm{m}$，位置如下\n  $$\\mathbf{r}_0 = (0,0,0),\\quad \\mathbf{r}_1 = (2.0\\times 10^{20},0,0),\\quad \\mathbf{r}_2 = (-1.0\\times 10^{20},1.0\\times 10^{20},0),$$\n  $$\\mathbf{r}_3 = (0,-2.0\\times 10^{20},1.0\\times 10^{20}),\\quad \\mathbf{r}_4 = (3.0\\times 10^{20},1.0\\times 10^{20},-1.0\\times 10^{20}),$$\n  $$\\mathbf{r}_5 = (-2.0\\times 10^{20},-2.0\\times 10^{20},0),\\quad \\mathbf{r}_6 = (1.0\\times 10^{20},-1.0\\times 10^{20},2.0\\times 10^{20}),$$\n  $$\\mathbf{r}_7 = (-1.0\\times 10^{19},2.0\\times 10^{20},-1.0\\times 10^{20}).$$\n- 对于测试用例1-3，速度如下\n  $$\\mathbf{v}_0 = (1.0\\times 10^{5},0,0),\\quad \\mathbf{v}_1 = (-5.0\\times 10^{4},2.0\\times 10^{4},0),\\quad \\mathbf{v}_2 = (2.0\\times 10^{5},-1.0\\times 10^{5},5.0\\times 10^{4}),$$\n  $$\\mathbf{v}_3 = (0,-8.0\\times 10^{4},1.0\\times 10^{5}),\\quad \\mathbf{v}_4 = (-1.0\\times 10^{5},3.0\\times 10^{4},-2.0\\times 10^{4}),$$\n  $$\\mathbf{v}_5 = (5.0\\times 10^{4},-1.0\\times 10^{5},0),\\quad \\mathbf{v}_6 = (0,1.0\\times 10^{5},-1.0\\times 10^{5}),$$\n  $$\\mathbf{v}_7 = (1.0\\times 10^{4},-2.0\\times 10^{4},3.0\\times 10^{4}).$$\n- 测试用例1（理想情况）：单位质量截面 $\\sigma/m = 0.1\\ \\mathrm{m^2/kg}$，时间步 $\\Delta t = 3.154\\times 10^{13}\\ \\mathrm{s}$（一百万年），每个子步的概率上限 $p_{\\max} = 0.1$。\n- 测试用例2（边界情况：无散射）：单位质量截面 $\\sigma/m = 0.0\\ \\mathrm{m^2/kg}$，时间步 $\\Delta t = 3.154\\times 10^{13}\\ \\mathrm{s}$，与测试用例1使用相同的 $p_{\\max}$、位置和速度。\n- 测试用例3（边缘情况：概率较大，需要子步）：单位质量截面 $\\sigma/m = 1.0\\ \\mathrm{m^2/kg}$，时间步 $\\Delta t = 1.577\\times 10^{16}\\ \\mathrm{s}$（五亿年），与测试用例1使用相同的 $p_{\\max}$、位置和速度。\n- 测试用例4（边缘情况：相对速度为零）：与测试用例1相同，但所有速度均相同，即对所有 $i$，$\\mathbf{v}_i = (0,0,0)$，以确保所有粒子对的 $v_{ij} = 0$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含按测试用例1-4顺序排列的结果，结果为用方括号括起来的逗号分隔列表。例如，输出必须类似于 $$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],$$ 其中每个 $\\text{result}_k$ 是一个整数，等于相应测试用例中实际发生的散射事件总数。", "solution": "我们从一个物理图像开始：自相互作用暗物质（SIDM）粒子会经历稀有的弹性散射，其特征是单位质量的截面，记为 $\\sigma/m$，单位为 $\\mathrm{m^2/kg}$。在离散化的N体表示中，具有质量 $\\{m_i\\}$ 和速度 $\\{\\mathbf{v}_i\\}$ 的宏观粒子作为底层连续分布的样本。为了将离散粒子与连续场联系起来，我们采用光滑粒子流体动力学（SPH）核函数 $W(r,h)$，它在三维空间中的单位是 $\\mathrm{m^{-3}}$，归一化后积分为1，并且是紧支撑的，截断半径为 $2h$。\n\n基于原理的推导：\n1. 一个粒子穿过质量密度为 $\\rho$ 的背景场时的瞬时碰撞率，在由单位质量截面定义的比例关系下，由下式给出：\n   $$\\Gamma \\propto \\frac{\\sigma}{m}\\,\\rho\\,v,$$\n   其中 $v$ 是一个代表性的相对速度。在我们的离散设置中，粒子 $i$ 位置处的局部质量密度通过核密度估计来估算：\n   $$\\rho_i = \\sum_{j} m_j\\,W(|\\mathbf{r}_i - \\mathbf{r}_j|,h).$$\n   这个密度估计的单位是正确的，因为 $m_j$ 的单位是 $\\mathrm{kg}$，$W$ 的单位是 $\\mathrm{m^{-3}}$。\n\n2. 在一个微小时间步 $\\Delta t$ 内，粒子 $i$ 因单个邻近粒子 $j$ 的贡献而经历的期望碰撞次数，正比于邻近粒子对局部密度的质量贡献，并使用粒子 $i$ 和 $j$ 之间的相对速度进行评估。因此，在 $\\Delta t$ 内由 $j$ 对 $i$ 贡献的期望碰撞次数为\n   $$\\lambda_{ij} = \\frac{\\sigma}{m}\\,m_j\\,v_{ij}\\,W(|\\mathbf{r}_i - \\mathbf{r}_j|,h)\\,\\Delta t.$$\n   数量 $\\lambda_{ij}$ 是无量纲的：$\\sigma/m$ 的单位是 $\\mathrm{m^2/kg}$，$m_j$ 是 $\\mathrm{kg}$，$v_{ij}$ 是 $\\mathrm{m/s}$，$W$ 是 $\\mathrm{m^{-3}}$，而 $\\Delta t$ 是 $\\mathrm{s}$，所以乘积的单位是 $\\mathrm{m^2/kg}\\cdot \\mathrm{kg}\\cdot \\mathrm{m/s}\\cdot \\mathrm{m^{-3}}\\cdot \\mathrm{s} = \\mathrm{m^0} = 1.$\n\n3. 在小概率机制下，散射事件是稀有的，可以建模为每对粒子的独立伯努利试验。当考虑无序对 $(i,j)$ 时，我们必须避免重复计数。事件“$i$ 因 $j$ 而散射”的概率约为 $\\lambda_{ij}$，事件“$j$ 因 $i$ 而散射”的概率约为 $\\lambda_{ji}$。在小概率极限下，该对粒子中至少发生一次散射的并集概率是\n   $$P_{\\text{pair}} \\approx \\lambda_{ij} + \\lambda_{ji},$$\n   因为当 $\\lambda_{ij} \\ll 1$ 和 $\\lambda_{ji} \\ll 1$ 时，重叠概率 $\\lambda_{ij}\\lambda_{ji}$ 是可以忽略不计的。这种构造对称地处理了粒子对。\n\n4. 确保每个子步的概率较小：\n   - 为了维持独立稀有事件近似的有效性，我们对每个子步的粒子对概率施加一个上限 $p_{\\max}$。给定一个完整步长的粒子对概率 $P_{\\text{pair}}$，我们选择子步的数量为\n     $$N_{\\text{sub}} = \\max\\left(1,\\left\\lceil \\frac{\\max_{\\text{pairs}} P_{\\text{pair}}}{p_{\\max}} \\right\\rceil\\right),$$\n     并运行 $N_{\\text{sub}}$ 个相同的子步，每个子步的粒子对概率为\n     $$p_{\\text{sub}} = \\frac{P_{\\text{pair}}}{N_{\\text{sub}}},$$\n     从而确保 $p_{\\text{sub}} \\le p_{\\max} \\ll 1$。在 $N_{\\text{sub}}$ 个子步中，期望的粒子对事件数仍然是 $P_{\\text{pair}}$，同时每个子步都使伯努利近似受控。\n\n算法设计：\n- 输入为质量 $\\{m_i\\}$、位置 $\\{\\mathbf{r}_i\\}$、速度 $\\{\\mathbf{v}_i\\}$、光滑长度 $h$、单位质量截面 $\\sigma/m$、时间步 $\\Delta t$ 和概率上限 $p_{\\max}$，全部使用国际单位制。\n- 实现三维三次样条核函数：\n  - 定义 $q = r/h$。\n  - 对于 $0 \\le q \\le 1$, $W(r,h) = \\frac{1}{\\pi h^3}\\left(1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3\\right)$。\n  - 对于 $1 < q \\le 2$, $W(r,h) = \\frac{1}{\\pi h^3}\\left(\\frac{1}{4}(2 - q)^3\\right)$。\n  - 对于 $q > 2$, $W(r,h) = 0$。\n- 对于每个无序对 $(i,j)$ 且 $i < j$：\n  - 计算 $r_{ij}$ 和 $v_{ij}$。\n  - 计算 $W_{ij} = W(r_{ij},h)$。\n  - 如果 $W_{ij} = 0$ 或 $v_{ij} = 0$，则设置 $P_{\\text{pair}} = 0$。\n  - 否则，计算 $\\lambda_{ij} = \\frac{\\sigma}{m} m_j v_{ij} W_{ij} \\Delta t$ 和 $\\lambda_{ji} = \\frac{\\sigma}{m} m_i v_{ij} W_{ij} \\Delta t$，然后设置 $P_{\\text{pair}} = \\lambda_{ij} + \\lambda_{ji}$。\n- 使用上限 $p_{\\max}$ 和所有粒子对中的最大 $P_{\\text{pair}}$ 来计算 $N_{\\text{sub}}$。运行 $N_{\\text{sub}}$ 个子步；在每个子步中，对每对粒子以概率 $p_{\\text{sub}} = P_{\\text{pair}}/N_{\\text{sub}}$ 执行一次伯努利试验。将所有粒子对和所有子步中成功的次数相加，作为散射事件的总数。\n- 使用固定的伪随机种子以确保确定性输出。\n\n测试套件覆盖范围：\n- 测试用例1验证了在天体物理上合理的参数下，概率较小且非零的理想情况。\n- 测试用例2设置 $\\sigma/m = 0$，从物理上强制概率为零，从而产生零次散射事件。\n- 测试用例3缩放 $\\sigma/m$ 和 $\\Delta t$ 以强制某些 $P_{\\text{pair}}$ 值超过上限，从而验证子步划分并产生更多的事件。\n- 测试用例4将所有速度设置为相等，强制所有粒子对的 $v_{ij} = 0$，因此事件数为零。\n\n输出：\n- 程序将测试用例1-4的整数计数汇总到一个列表中，并以 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$ 的格式打印一行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cubic_spline_kernel(r: float, h: float) -> float:\n    \"\"\"\n    Three-Dimensional cubic spline SPH kernel W(r,h) with compact support 2h.\n    Parameters:\n        r: separation in meters\n        h: smoothing length in meters\n    Returns:\n        W: kernel value in m^{-3}\n    \"\"\"\n    if h = 0.0:\n        return 0.0\n    q = r / h\n    inv_pi_h3 = 1.0 / (np.pi * h**3)\n    if 0 = q = 1.0:\n        return inv_pi_h3 * (1.0 - 1.5 * q**2 + 0.75 * q**3)\n    elif 1.0  q = 2.0:\n        return inv_pi_h3 * (0.25 * (2.0 - q)**3)\n    else:  # q  0 (unphysical) or q > 2\n        return 0.0\n\ndef calculate_scatters(masses, positions, velocities, h, sigma_over_m, dt, p_max, rng):\n    \"\"\"\n    Calculates the total number of scattering events for a given set of particles,\n    implementing the Monte Carlo SIDM scattering algorithm.\n    \"\"\"\n    num_particles = len(masses)\n    pair_full_probs = []\n    max_full_prob = 0.0\n\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            rij = np.linalg.norm(positions[i] - positions[j])\n            vij = np.linalg.norm(velocities[i] - velocities[j])\n            wij = cubic_spline_kernel(rij, h)\n\n            p_pair = 0.0\n            if wij > 0 and vij > 0:\n                # Symmetrized pairwise probability: P_pair = lambda_ij + lambda_ji\n                p_pair = (sigma_over_m * masses[j] * vij * wij * dt) + \\\n                         (sigma_over_m * masses[i] * vij * wij * dt)\n            \n            pair_full_probs.append(p_pair)\n            if p_pair > max_full_prob:\n                max_full_prob = p_pair\n    \n    if max_full_prob == 0:\n        return 0\n\n    n_sub = int(np.ceil(max_full_prob / p_max)) if max_full_prob > p_max else 1\n    \n    total_scatters = 0\n    for _ in range(n_sub):\n        for p_full in pair_full_probs:\n            p_sub = p_full / n_sub\n            if rng.random()  p_sub:\n                total_scatters += 1\n                \n    return total_scatters\n\ndef run_all_tests():\n    \"\"\"\n    Executes all test cases as specified in the problem and prints the results.\n    \"\"\"\n    # Fixed seed for reproducibility\n    rng = np.random.RandomState(42)\n\n    # Common particle data\n    N = 8\n    mass_val = 2.0e38  # kg\n    masses = np.full(N, mass_val)\n    h = 1.5e20  # m\n    positions = np.array([\n        [0, 0, 0], [2.0e20, 0, 0], [-1.0e20, 1.0e20, 0],\n        [0, -2.0e20, 1.0e20], [3.0e20, 1.0e20, -1.0e20],\n        [-2.0e20, -2.0e20, 0], [1.0e20, -1.0e20, 2.0e20],\n        [-1.0e19, 2.0e20, -1.0e20]\n    ], dtype=np.float64)  # m\n    velocities_base = np.array([\n        [1.0e5, 0, 0], [-5.0e4, 2.0e4, 0], [2.0e5, -1.0e5, 5.0e4],\n        [0, -8.0e4, 1.0e5], [-1.0e5, 3.0e4, -2.0e4],\n        [5.0e4, -1.0e5, 0], [0, 1.0e5, -1.0e5],\n        [1.0e4, -2.0e4, 3.0e4]\n    ], dtype=np.float64)  # m/s\n    p_max_global = 0.1\n    results = []\n\n    # Test Case 1: Ideal case\n    sigma_over_m_1 = 0.1\n    dt_1 = 3.154e13\n    results.append(calculate_scatters(masses, positions, velocities_base, h, sigma_over_m_1, dt_1, p_max_global, rng))\n\n    # Test Case 2: No scattering\n    sigma_over_m_2 = 0.0\n    dt_2 = 3.154e13\n    results.append(calculate_scatters(masses, positions, velocities_base, h, sigma_over_m_2, dt_2, p_max_global, rng))\n\n    # Test Case 3: High probability, needs sub-stepping\n    sigma_over_m_3 = 1.0\n    dt_3 = 1.577e16\n    results.append(calculate_scatters(masses, positions, velocities_base, h, sigma_over_m_3, dt_3, p_max_global, rng))\n    \n    # Test Case 4: Zero relative velocity\n    velocities_zero = np.zeros_like(velocities_base)\n    results.append(calculate_scatters(masses, positions, velocities_zero, h, sigma_over_m_1, dt_1, p_max_global, rng))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nrun_all_tests()\n```", "id": "3488392"}]}