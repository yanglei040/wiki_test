{"hands_on_practices": [{"introduction": "这第一个实践是我们动手探索的基石。你将构建一个完整但简化的蒙特卡洛流程，用于在平坦天空（flat-sky）近似下重建CMB透镜势 [@problem_id:3467573]。这项练习将让你全面掌握从生成模拟数据、实现二次估计器到校正主要统计偏差的整个工作流程，从而巩固你的理解。", "problem": "您的任务是设计一个独立的蒙特卡洛（Monte Carlo）流程，用于使用二次估计器在平坦天空（flat-sky）上进行宇宙微波背景（CMB）引力透镜重建。目标是生成具有已知输入偏转势功率谱 $C_L^{\\phi\\phi}$ 的引力透镜CMB温度图，重建引力透镜势，并在减去平均场（mean-field）和重建噪声偏置后，展示恢复出无偏估计 $\\hat C_L^{\\phi\\phi}$。您的程序必须实现以下内容，这些内容以纯数学术语表达，并使用弧度作为角度单位。\n\n从基本原理和经过充分检验的公式出发：\n\n1. 平坦天空上的引力透镜重映射由标量偏转势 $\\phi(\\boldsymbol{x})$ 定义，其中偏转场为 $\\boldsymbol{d}(\\boldsymbol{x}) = \\nabla \\phi(\\boldsymbol{x})$。观测到的引力透镜温度场满足 $T_{\\mathrm{obs}}(\\boldsymbol{x}) = T_{\\mathrm{unl}}\\!\\left(\\boldsymbol{x} + \\boldsymbol{d}(\\boldsymbol{x})\\right) + n(\\boldsymbol{x})$，其中 $n(\\boldsymbol{x})$ 表示仪器噪声。在小偏转体系下工作，使用一阶泰勒展开 $T_{\\mathrm{obs}}(\\boldsymbol{x}) \\approx T_{\\mathrm{unl}}(\\boldsymbol{x}) + \\nabla T_{\\mathrm{unl}}(\\boldsymbol{x}) \\cdot \\nabla \\phi(\\boldsymbol{x}) + n(\\boldsymbol{x})$。此展开是二次估计器的基础，因为它在未透镜化的CMB中原本独立的傅里叶模式之间引入了由引力透镜驱动的耦合。\n\n2. 未透镜化的CMB温度 $T_{\\mathrm{unl}}(\\boldsymbol{x})$ 和势 $\\phi(\\boldsymbol{x})$ 被建模为在边长为 $L_{\\mathrm{box}}$（以弧度为单位）的方形周期性天区上的统计各向同性高斯随机场，该天区表示在一个 $N \\times N$ 的网格上。各向同性功率谱 $C_\\ell^{TT}$ 和 $C_L^{\\phi\\phi}$ 定义了相应傅里叶模式的二阶统计量。仪器噪声在实空间中被建模为每个像素方差为 $\\sigma_n^2$ 的不相关高斯噪声，对应于傅里叶空间中的白噪声功率谱。\n\n3. 引力透镜重建是根据观测到的温度 $T_{\\mathrm{obs}}(\\boldsymbol{x})$，使用由两个滤波后的温度场和一个空间梯度构建的二次估计器进行的，其动机源于从泰勒展开中导出的模式耦合。该估计器产生一个重建的势图 $\\hat\\phi(\\boldsymbol{x})$（或其傅里叶表示 $\\hat\\phi(\\boldsymbol{L})$）。估计器存在两种必须被移除的偏置：\n   - 平均场偏置源于任何各向异性，如掩模或各向异性噪声，并表现为非零的平均值 $\\langle \\hat\\phi(\\boldsymbol{L}) \\rangle$。它必须通过对许多具有相同各向异性的未透镜化模拟进行蒙特卡洛平均来估计和减去。\n   - 即使当 $C_L^{\\phi\\phi} = 0$ 时，$N^{(0)}$（非连通）重建噪声偏置也会出现在自谱 $\\langle |\\hat\\phi(\\boldsymbol{L})|^2 \\rangle$ 中。它必须通过未透镜化的蒙特卡洛模拟来估计，并在能带功率（band power）中减去。\n\n4. 由于二次估计器在有限、带有掩模的天区上的解析归一化可能很复杂，您必须使用与已知的模拟输入势的交叉谱来校准估计器的响应，在 $L = |\\boldsymbol{L}|$ 的分箱中计算响应因子 $R_L$。这允许通过 $\\hat C_L^{\\phi\\phi} \\approx \\left(C_L^{\\mathrm{auto}} - N^{(0)}_L\\right)/R_L^2$ 进行无偏恢复，其中 $C_L^{\\mathrm{auto}}$ 是减去平均场后的重建自谱的能带功率，而 $N^{(0)}_L$ 是估计的噪声偏置能带功率。\n\n数值设置和约束：\n\n- 在一个边长为 $L_{\\mathrm{box}}$（以弧度为单位）、具有 $N \\times N$ 像素的方形、周期性平坦天区上工作。所有角度必须以弧度处理。\n- 使用离散傅里叶变换，其波矢量为 $\\boldsymbol{k} = (k_x, k_y)$，分量为 $k_i = 2\\pi n_i / L_{\\mathrm{box}}$，其中整数索引 $n_i$ 由 $N \\times N$ 网格的傅里叶变换约定定义。\n- 通过在傅里叶空间中对白色高斯场进行滤波，生成与其功率谱一致的高斯随机场 $T_{\\mathrm{unl}}$ 和 $\\phi$。\n- 实现一个圆形的 apodized 掩模 $M(\\boldsymbol{x})$，在天区边界附近使用余弦锥化以引入平均场。该掩模的特征在于一个 apodization 分数 $f_{\\mathrm{apod}}$（相对于半尺寸），即锥化宽度等于 $f_{\\mathrm{apod}} \\times L_{\\mathrm{box}}/2$。\n- 使用一阶泰勒近似来对温度进行引力透镜处理：$T_{\\mathrm{lens}}(\\boldsymbol{x}) \\approx T_{\\mathrm{unl}}(\\boldsymbol{x}) + \\nabla T_{\\mathrm{unl}}(\\boldsymbol{x}) \\cdot \\nabla \\phi(\\boldsymbol{x})$。\n- 使用由 $C_\\ell^{TT}$ 和包含白噪声的总温度功率谱构建的各向同性滤波器，从两个反向滤波的温度场及其梯度构建二次估计器。在傅里叶空间中计算重建，并在 $L$ 的分箱中形成能带功率。\n\n测试套件和验收标准：\n\n实现三个测试用例，每个用例由一个元组 $(A_\\phi, \\sigma_n, f_{\\mathrm{apod}})$ 指定：\n- 用例 1 (happy path): $(3\\times 10^{-7}, 5\\times 10^{-6}, 0.10)$。\n- 用例 2 (无引力透镜边界): $(0, 5\\times 10^{-6}, 0.10)$。\n- 用例 3 (高噪声边缘): $(3\\times 10^{-7}, 2\\times 10^{-5}, 0.20)$。\n\n在所有用例中使用固定的 $N$ 和 $L_{\\mathrm{box}}$，以及一个物理上合理并在高 $\\ell$ 处衰减的固定 $C_\\ell^{TT}$ 形状。将重建的谱分箱到适量数量的 $L$ 箱中，覆盖引力透镜信号不可忽略的低到中等 $L$ 范围。\n\n对于每个用例：\n- 使用具有相同掩模和噪声的未透镜化蒙特卡洛模拟，估计并减去平均场和 $N^{(0)}$。使用足够多的蒙特卡洛实现以使减法稳定。\n- 对于有透镜的模拟，通过重建场与输入 $\\phi$ 的交叉谱来校准估计器响应 $R_L$。对于 $A_\\phi=0$，跳过响应校准，并根据定义设置 $R_L=1$。\n- 在每个分箱中使用 $\\hat C_L^{\\phi\\phi} = \\left(C_L^{\\mathrm{auto}} - N^{(0)}_L\\right)/R_L^2$ 形成无偏估计 $\\hat C_L^{\\phi\\phi}$。\n\n验收标准：\n- 用例 1 和用例 3：令 $C_{L,\\,\\mathrm{model}}^{\\phi\\phi}$ 为通过对理论 $C_L^{\\phi\\phi}$ 进行分箱平均计算得到的输入模型能带功率。计算每个分箱的分数偏差为 $$\\Delta = \\frac{\\left|\\hat C_L^{\\phi\\phi} - C_{L,\\,\\mathrm{model}}^{\\phi\\phi}\\right|}{C_{L,\\,\\mathrm{model}}^{\\phi\\phi} + \\epsilon}$$ 其中 $\\epsilon$ 是一个小的正则化项以避免除以零。如果 $\\Delta$ 在具有不可忽略输入信号的分箱上的中位数低于一个容差，则接受。用例 1 使用 0.6，用例 3 使用 0.8。\n- 用例 2：当 $A_\\phi = 0$ 时，如果减去平均场和 $N^{(0)}$ 后的重建能带功率在所有分箱中的最大绝对值小于最大 $N^{(0)}$ 能带功率的 0.2 倍，则接受。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是一个布尔值，指示相应测试用例是否满足验收标准。", "solution": "用户提供的问题被评估为**有效**。它描述了数值宇宙学领域内一项科学上合理且定义明确的任务，特别关注宇宙微波背景（CMB）引力透镜重建。该问题是自洽的，所有必要的物理模型、数值程序和测试标准都已清晰定义。未发现矛盾、事实错误或不可行的要求。该任务涉及实现一个标准的、尽管简化的蒙特卡洛（Monte Carlo）流程，这是一个不简单但可行的难题。\n\n因此，我将继续提供一个完整的解决方案。该方案的结构遵循CMB引力透镜分析流程的逻辑顺序，从理论原理到数值实现和验证。\n\n### 1. 理论框架和模型\n\n分析在一个边长为 $L_{\\mathrm{box}}$ 的方形、周期性、平坦天区上进行，该天区被离散化为一个 $N \\times N$ 的网格。所有角度单位均为弧度。\n\n基本场，即未透镜化的CMB温度 $T_{\\mathrm{unl}}(\\boldsymbol{x})$ 和引力透镜势 $\\phi(\\boldsymbol{x})$，被建模为统计上各向同性且均匀的高斯随机场。它们的统计特性完全由其角功率谱 $C_\\ell^{TT}$ 和 $C_L^{\\phi\\phi}$ 定义。场 $F(\\boldsymbol{x})$ 与其功率谱 $C_L^F$ 之间的关系由其傅里叶模式 $\\tilde{F}(\\boldsymbol{L})$ 的两点相关函数给出：\n$$\n\\langle \\tilde{F}(\\boldsymbol{L}) \\tilde{F}^*(\\boldsymbol{L}') \\rangle = (2\\pi)^2 \\delta^{(2)}(\\boldsymbol{L} - \\boldsymbol{L}') C_L^F\n$$\n其中 $\\boldsymbol{L}$ 是二维波矢量（或多极矢量），且 $L = |\\boldsymbol{L}|$。\n\n观测到的CMB温度 $T_{\\mathrm{obs}}(\\boldsymbol{x})$ 是未透镜化的温度场经引力透镜势的梯度 $\\boldsymbol{d}(\\boldsymbol{x}) = \\nabla\\phi(\\boldsymbol{x})$ 重映射后，加上仪器噪声 $n(\\boldsymbol{x})$：\n$$\nT_{\\mathrm{obs}}(\\boldsymbol{x}) = T_{\\mathrm{unl}}(\\boldsymbol{x} + \\nabla\\phi(\\boldsymbol{x})) + n(\\boldsymbol{x})\n$$\n对于此分析，我们使用此关系的一阶泰勒展开，它在小偏转角时有效：\n$$\nT_{\\mathrm{obs}}(\\boldsymbol{x}) \\approx T_{\\mathrm{unl}}(\\boldsymbol{x}) + \\nabla T_{\\mathrm{unl}}(\\boldsymbol{x}) \\cdot \\nabla \\phi(\\boldsymbol{x}) + n(\\boldsymbol{x})\n$$\n此展开揭示了CMB模式和引力透镜势之间的耦合，这是二次估计器的基础。仪器噪声 $n(\\boldsymbol{x})$ 被建模为一个具有白噪声功率谱的高斯随机场，源于像素方差为 $\\sigma_n^2$ 的不相关噪声。\n\n### 2. 数值模拟流程\n\n**a. 离散化和场生成：**\n我们定义一个波矢量网格 $\\boldsymbol{L} = (L_x, L_y)$，其中 $L_i = 2\\pi n_i/L_{\\mathrm{box}}$，整数索引为 $n_i$。高斯随机场在傅里叶空间中通过创建复高斯随机数网格并根据期望的功率谱进行缩放来生成。对于一个 $N \\times N$ 网格上的离散傅里叶变换（DFT），傅里叶系数 $\\tilde{F}_{\\boldsymbol{L}}$ 的方差与连续功率谱 $C_L^F$ 的关系为：\n$$\n\\langle |\\tilde{F}_{\\boldsymbol{L}}|^2 \\rangle = \\frac{N^4}{L_{\\mathrm{box}}^2} C_L^F\n$$\n生成的傅里叶场必须满足实数条件 $\\tilde{F}(\\boldsymbol{L}) = \\tilde{F}^*(-\\boldsymbol{L})$，这在生成具有独立实部和虚部的复数并执行逆FFT时可以自然处理。\n\n**b. 引力透镜和观测：**\n泰勒近似的引力透镜是通过首先独立生成 $T_{\\mathrm{unl}}$ 和 $\\phi$ 图来实现的。它们的梯度 $\\nabla T_{\\mathrm{unl}}$ 和 $\\nabla \\phi$ 在傅里叶空间中通过属性 $\\mathcal{F}[\\nabla F(\\boldsymbol{x})] = i\\boldsymbol{L} \\tilde{F}(\\boldsymbol{L})$ 高效计算。然后根据泰勒展开在实空间中组合这些场。添加高斯白噪声，最后，将一个带有余弦锥化边缘的圆形 apodization 掩模 $M(\\boldsymbol{x})$ 应用于最终的图，以产生观测数据 $T_{\\mathrm{obs}}(\\boldsymbol{x})$。该掩模对于引入非平凡的平均场偏置至关重要，这在实际观测中很常见。\n\n### 3. 使用二次估计器进行引力透镜重建\n\n**a. 估计器公式：**\n二次估计器通过关联成对的温度模式来重建引力透镜势。一种实用且稳健的实现方式是使用滤波后温度场的对称组合。我们在傅里叶空间中定义两个滤波后的图：\n$$\n\\tilde{M}_1(\\boldsymbol{\\ell}) = \\frac{\\tilde{T}_{\\mathrm{obs}}(\\boldsymbol{\\ell})}{C_\\ell^{\\mathrm{tot}}} \\quad \\text{和} \\quad \\tilde{M}_2(\\boldsymbol{\\ell}) = \\frac{\\tilde{T}_{\\mathrm{obs}}(\\boldsymbol{\\ell}) C_\\ell^{TT}}{C_\\ell^{\\mathrm{tot}}}\n$$\n其中 $C_\\ell^{\\mathrm{tot}} = C_\\ell^{TT} + N_\\ell$ 是观测数据的总功率谱，包括信号和噪声。偏转场 $\\boldsymbol{d}(\\boldsymbol{x})$ 的一个估计器在实空间中构造如下：\n$$\n\\hat{\\boldsymbol{d}}_{\\mathrm{est}}(\\boldsymbol{x}) = M_1(\\boldsymbol{x}) \\nabla M_2(\\boldsymbol{x}) + M_2(\\boldsymbol{x}) \\nabla M_1(\\boldsymbol{x})\n$$\n引力透镜势 $\\phi$ 与其偏转场 $\\boldsymbol{d}$ 的关系为 $\\nabla^2\\phi = \\nabla \\cdot \\boldsymbol{d}$。在傅里叶空间中，这变为 $-L^2 \\tilde{\\phi}(\\boldsymbol{L}) = i\\boldsymbol{L} \\cdot \\tilde{\\boldsymbol{d}}(\\boldsymbol{L})$。因此，未归一化的重建势在傅里叶空间中为：\n$$\n\\hat{\\phi}_{\\mathrm{unnorm}}(\\boldsymbol{L}) = \\frac{i\\boldsymbol{L} \\cdot \\tilde{\\boldsymbol{d}}_{\\mathrm{est}}(\\boldsymbol{L})}{L^2}\n$$\n\n**b. 偏置减法和校准：**\n原始重建 $\\hat{\\phi}_{\\mathrm{unnorm}}$ 是有偏的。我们必须校正两种主要的加性偏置和一种乘性偏置。\n\n1.  **平均场偏置 ($\\hat{\\phi}_{MF}$):** 来自掩模的各向异性导致估计器即使对于未透镜化的天空也具有非零期望值，即 $\\langle \\hat{\\phi}_{\\mathrm{unnorm}} \\rangle \\neq 0$。这就是平均场，通过对大量（$N_{\\mathrm{MC}}$）使用相同掩模的未透镜化、含噪声的模拟进行重建并取平均来估计。这个平均值 $\\hat{\\phi}_{\\mathrm{MF}}(\\boldsymbol{L})$ 随后从所有后续的重建中减去。\n\n2.  **重建噪声偏置 ($N^{(0)}$):** 重建的自功率谱 $\\langle |\\hat{\\phi}|^2 \\rangle$ 包含一个由未透镜化CMB模式的偶然相关性引起的大加性偏置。这就是 $N^{(0)}$ 偏置。其功率谱 $N_L^{(0)}$ 是通过计算来自同一组 $N_{\\mathrm{MC}}$ 个未透镜化模拟的、已减去平均场的重建的平均功率谱来估计的。\n\n3.  **响应校准 ($R_L$):** 由于滤波、掩模和近似，估计器对真实势的响应不为1。响应因子 $R_L$ 是通过将来自有透镜模拟（具有已知输入势 $\\phi_{\\mathrm{in}}$）的重建与输入势本身进行交叉相关来确定的。响应是交叉谱与输入模型功率谱的比值：\n    $$\n    R_L = \\frac{\\langle \\mathrm{Re}[\\hat{\\phi}_{\\mathrm{sub}}(\\boldsymbol{L}) \\phi_{\\mathrm{in}}^*(\\boldsymbol{L})] \\rangle_L}{C_{L, \\mathrm{model}}^{\\phi\\phi}}\n    $$\n    其中 $\\hat{\\phi}_{\\mathrm{sub}}$ 是减去了平均场的重建。\n\n### 4. 最终无偏功率谱\n\n引力透镜势功率谱的最终无偏估计 $\\hat{C}_L^{\\phi\\phi}$ 是通过结合这些校正构建的。对于一个有透镜的“数据”模拟，我们计算其减去平均场后的重建的自功率谱 $C_L^{\\mathrm{auto}}$。最终的谱为：\n$$\n\\hat{C}_L^{\\phi\\phi} = \\frac{C_L^{\\mathrm{auto}} - N_L^{(0)}}{R_L^2}\n$$\n功率谱在多极矩幅度 $L$ 的离散分箱中计算。然后根据问题陈述中为每个测试用例定义的验收标准对结果进行评估。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the CMB lensing reconstruction pipeline for all test cases.\n    \"\"\"\n\n    # --- Numerical and Physical Setup ---\n    N = 256  # Grid size\n    L_BOX_DEG = 5.0  # Box side length in degrees\n    L_BOX_RAD = np.deg2rad(L_BOX_DEG)  # Box side length in radians\n    PIX_SIZE_RAD = L_BOX_RAD / N\n    N_MC = 100  # Number of Monte Carlo simulations for bias/noise estimation\n    L_BINS = 10  # Number of bins for power spectra\n    EPSILON = 1e-30  # Small regularization constant\n\n    # Fourier space grids for multipole vectors L = (Lx, Ly)\n    _kx = np.fft.fftfreq(N, d=PIX_SIZE_RAD) * 2 * np.pi\n    _ky = np.fft.fftfreq(N, d=PIX_SIZE_RAD) * 2 * np.pi\n    ELL_X, ELL_Y = np.meshgrid(_kx, _ky, indexing='ij')\n    ELL_MAG = np.sqrt(ELL_X**2 + ELL_Y**2)\n    ELL_MAG[0, 0] = 1.0  # Avoid division by zero at DC mode (L=0)\n\n    # Binning setup for power spectra\n    l_max_ana = np.pi / PIX_SIZE_RAD # Theoretical Nyquist limit\n    bin_edges = np.linspace(2, min(l_max_ana, 800), L_BINS + 1)\n        \n    def get_fiducial_spectra(ell_mag, noise_var):\n        \"\"\"Defines the fiducial power spectra C_TT and C_tot.\"\"\"\n        c_ell_tt = np.zeros_like(ell_mag)\n        valid_ells = ell_mag > 1\n        c_ell_tt[valid_ells] = 1.0 / (ell_mag[valid_ells]**2 + 50**2)\n        n_ell_tt = noise_var * PIX_SIZE_RAD**2\n        return c_ell_tt, c_ell_tt + n_ell_tt\n\n    def get_phi_power_spectrum(ell_mag, A_phi):\n        \"\"\"Defines the input lensing potential power spectrum C_phiphi.\"\"\"\n        c_ell_pp = np.zeros_like(ell_mag)\n        valid_ells = ell_mag > 1\n        c_ell_pp[valid_ells] = A_phi / (ell_mag[valid_ells] * (ell_mag[valid_ells] + 1.0))\n        return c_ell_pp\n\n    def generate_gaussian_field(c_ell_2d):\n        \"\"\"Generates a 2D Gaussian random field from a given power spectrum.\"\"\"\n        noise = (np.random.normal(size=(N, N)) + 1j * np.random.normal(size=(N, N))) / np.sqrt(2)\n        fourier_map = noise * np.sqrt(c_ell_2d * (N**4 / L_BOX_RAD**2))\n        fourier_map[0, 0] = 0.0 # Fluctuation field has zero mean\n        return np.fft.ifft2(fourier_map).real\n\n    def get_mask(f_apod):\n        \"\"\"Creates a circular mask with cosine apodization.\"\"\"\n        y, x = np.indices((N, N))\n        center_x, center_y = N // 2, N // 2\n        r = np.sqrt((x - center_x)**2 + (y - center_y)**2)\n        \n        r_max = N / 2.0\n        taper_width = f_apod * r_max\n        inner_radius = r_max - taper_width\n        \n        mask = np.zeros((N, N))\n        mask[r <= inner_radius] = 1.0\n        taper_region = (r > inner_radius) & (r <= r_max)\n        mask[taper_region] = 0.5 * (1 + np.cos(np.pi * (r[taper_region] - inner_radius) / taper_width))\n        return mask\n\n    def apply_lensing(t_unl, phi):\n        \"\"\"Lenses a temperature map using the first-order Taylor expansion.\"\"\"\n        t_unl_k = np.fft.fft2(t_unl)\n        phi_k = np.fft.fft2(phi)\n\n        grad_t_x = np.fft.ifft2(1j * ELL_X * t_unl_k).real\n        grad_t_y = np.fft.ifft2(1j * ELL_Y * t_unl_k).real\n        d_x = np.fft.ifft2(1j * ELL_X * phi_k).real\n        d_y = np.fft.ifft2(1j * ELL_Y * phi_k).real\n        \n        return t_unl + grad_t_x * d_x + grad_t_y * d_y\n\n    def get_binned_power(field_k, ell_map):\n        \"\"\"Computes the binned 1D power spectrum from a 2D Fourier field.\"\"\"\n        power_2d = np.abs(field_k)**2 * (L_BOX_RAD**2 / N**4)\n        \n        bin_indices = np.digitize(ell_map.flatten(), bin_edges)\n        # Bincount needs non-negative integer indices. Digitize provides 1-based, 0 for < min.\n        # Max index is len(bin_edges). We need to handle this.\n        valid_indices = (bin_indices > 0) & (bin_indices <= L_BINS)\n        weights_flat = power_2d.flatten()[valid_indices]\n        indices_flat = bin_indices[valid_indices] - 1 # to 0-based\n        \n        binned_power = np.bincount(indices_flat, weights=weights_flat, minlength=L_BINS)\n        bin_counts = np.bincount(indices_flat, minlength=L_BINS)\n        \n        return np.divide(binned_power, bin_counts, out=np.zeros_like(binned_power), where=bin_counts!=0)\n\n    def quadratic_estimator(t_obs, c_ell_tt, c_ell_tot):\n        \"\"\"Implements the symmetric quadratic estimator for phi.\"\"\"\n        t_obs_k = np.fft.fft2(t_obs)\n        \n        M1_k = t_obs_k / (c_ell_tot + EPSILON)\n        M2_k = t_obs_k * c_ell_tt / (c_ell_tot + EPSILON)\n        \n        M1 = np.fft.ifft2(M1_k).real\n        M2 = np.fft.ifft2(M2_k).real\n\n        grad_M1_x = np.fft.ifft2(1j * ELL_X * M1_k).real\n        grad_M1_y = np.fft.ifft2(1j * ELL_Y * M1_k).real\n        grad_M2_x = np.fft.ifft2(1j * ELL_X * M2_k).real\n        grad_M2_y = np.fft.ifft2(1j * ELL_Y * M2_k).real\n\n        d_est_x = M1 * grad_M2_x + M2 * grad_M1_x\n        d_est_y = M1 * grad_M2_y + M2 * grad_M1_y\n        \n        d_est_x_k = np.fft.fft2(d_est_x)\n        d_est_y_k = np.fft.fft2(d_est_y)\n\n        phi_k_unnorm = (1j * ELL_X * d_est_x_k + 1j * ELL_Y * d_est_y_k) / (ELL_MAG**2 + EPSILON)\n        phi_k_unnorm[0, 0] = 0.0\n        return phi_k_unnorm\n\n    def run_case(A_phi, sigma_n, f_apod):\n        \"\"\"Executes one full test case.\"\"\"\n        c_ell_tt, c_ell_tot = get_fiducial_spectra(ELL_MAG, sigma_n**2)\n        mask = get_mask(f_apod)\n        \n        # --- Monte Carlo for Mean-Field and N0 Bias ---\n        phi_mf_k_sum = np.zeros((N, N), dtype=complex)\n        for _ in range(N_MC):\n            t_unl = generate_gaussian_field(c_ell_tt)\n            noise = np.random.normal(0, sigma_n, (N, N))\n            t_obs_unlensed = (t_unl + noise) * mask\n            phi_mf_k_sum += quadratic_estimator(t_obs_unlensed, c_ell_tt, c_ell_tot)\n        phi_mf_k = phi_mf_k_sum / N_MC\n\n        n0_power_sum = np.zeros(L_BINS)\n        for _ in range(N_MC):\n            t_unl = generate_gaussian_field(c_ell_tt)\n            noise = np.random.normal(0, sigma_n, (N, N))\n            t_obs_unlensed = (t_unl + noise) * mask\n            phi_rec_k = quadratic_estimator(t_obs_unlensed, c_ell_tt, c_ell_tot)\n            phi_rec_k_mf_sub = phi_rec_k - phi_mf_k\n            n0_power_sum += get_binned_power(phi_rec_k_mf_sub, ELL_MAG)\n        n0_binned = n0_power_sum / N_MC\n        \n        # --- Main \"Data\" Simulation and Reconstruction ---\n        c_ell_pp_in = get_phi_power_spectrum(ELL_MAG, A_phi)\n        t_unl_main = generate_gaussian_field(c_ell_tt)\n        phi_in = generate_gaussian_field(c_ell_pp_in)\n        \n        t_lensed = apply_lensing(t_unl_main, phi_in) if A_phi > 0 else t_unl_main\n        noise_main = np.random.normal(0, sigma_n, (N, N))\n        t_obs_lensed = (t_lensed + noise_main) * mask\n        \n        phi_rec_lensed_k = quadratic_estimator(t_obs_lensed, c_ell_tt, c_ell_tot)\n        phi_rec_lensed_mf_sub_k = phi_rec_lensed_k - phi_mf_k\n        c_auto_binned = get_binned_power(phi_rec_lensed_mf_sub_k, ELL_MAG)\n        \n        # --- Calibration and Final Spectrum ---\n        c_model_binned = get_binned_power(np.sqrt(c_ell_pp_in * (N**4 / L_BOX_RAD**2) + EPSILON), ELL_MAG)\n\n        if A_phi > 0:\n            phi_in_k = np.fft.fft2(phi_in)\n            cross_power_2d = np.real(phi_rec_lensed_mf_sub_k * np.conj(phi_in_k)) * (L_BOX_RAD**2 / N**4)\n            c_cross_binned = get_binned_power(np.sqrt(cross_power_2d.clip(min=0)), ELL_MAG) # Hack to use binner\n            \n            # Recalculate cross-power without the hack\n            bin_indices = np.digitize(ELL_MAG.flatten(), bin_edges)\n            valid_indices = (bin_indices > 0) & (bin_indices <= L_BINS)\n            weights_flat = cross_power_2d.flatten()[valid_indices]\n            indices_flat = bin_indices[valid_indices] - 1\n            binned_cross = np.bincount(indices_flat, weights=weights_flat, minlength=L_BINS)\n            bin_counts = np.bincount(indices_flat, minlength=L_BINS)\n            c_cross_binned = np.divide(binned_cross, bin_counts, out=np.zeros_like(binned_cross), where=bin_counts!=0)\n            \n            r_binned = np.divide(c_cross_binned, c_model_binned, out=np.ones_like(c_model_binned), where=c_model_binned > EPSILON)\n            c_reco_binned = (c_auto_binned - n0_binned) / (r_binned**2 + EPSILON)\n        else:\n            c_reco_binned = c_auto_binned - n0_binned\n\n        # --- Acceptance Criteria ---\n        if A_phi > 0:\n            significant_bins = c_model_binned > 0.1 * np.max(c_model_binned[np.isfinite(c_model_binned)])\n            if not np.any(significant_bins): return False\n            dev = np.abs(c_reco_binned - c_model_binned) / (c_model_binned + EPSILON)\n            median_dev = np.median(dev[significant_bins])\n            tolerance = 0.6 if sigma_n < 1.1e-5 else 0.8\n            return median_dev < tolerance\n        else:\n            max_abs_residual = np.max(np.abs(c_reco_binned))\n            max_n0 = np.max(n0_binned[np.isfinite(n0_binned)])\n            if max_n0 == 0: return True # If N0 is zero, any residual is ok\n            return max_abs_residual < 0.2 * max_n0\n\n    # Define test cases\n    test_cases = [\n        (3e-7, 5e-6, 0.10),\n        (0, 5e-6, 0.10),\n        (3e-7, 2e-5, 0.20),\n    ]\n\n    results = []\n    for case in test_cases:\n        A_phi, sigma_n, f_apod = case\n        results.append(run_case(A_phi, sigma_n, f_apod))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3467573"}, {"introduction": "获得测量结果后，量化其不确定性是至关重要的下一步。本实践深入探讨如何推导和验证透镜功率谱“频段功率”（bandpower）估计的协方差矩阵 [@problem_id:3467597]。通过将解析理论与数值验证相结合，你将学会如何计算重建功率谱的误差棒，这是实验宇宙学中的一项基本技能。", "problem": "你的任务是在数值宇宙学使用的标准近似下，使用二次估计框架，推导、实现和验证宇宙微波背景（CMB）引力透镜势功率谱的带功率估计（记为 $\\hat{C}_b^{\\phi\\phi}$）的协方差。带功率是由引力透镜势 $\\phi$ 的多极矩 $L$ 构建的，重建的谱包含来自真实信号 $C_L^{\\phi\\phi}$、高斯非关联噪声偏差 $N_L^{(0)}$ 和关联非高斯偏差 $N_L^{(1)}$ 的贡献。你的程序必须计算包含样本方差和噪声的带功率解析协方差，并与蒙特卡洛系综进行对比以进行数值验证。\n\n从以下基本基础出发：\n- 重建的引力透镜势谐波系数定义了一个重建谱，其均值为信号与偏差之和。\n- 在各向同性高斯近似和部分天区覆盖率 $f_{\\mathrm{sky}}$ 的条件下，不同多极矩 $L$ 的模式近似独立，有效模式数与 $(2L+1) f_{\\mathrm{sky}}$ 成比例。\n- 带功率是通过对 $L$ 的不相交区间（bin）内的估计量进行平均而形成的。\n\n你必须：\n1. 在离散多极矩网格上定义一个科学上合理的信号和噪声模型：\n   - 引力透镜势功率谱 $C_L^{\\phi\\phi}$ 被建模为 $L$ 的衰减函数：对于 $L \\ge 2$， $C_L^{\\phi\\phi} = A_{\\phi} \\exp(-L/L_d) / [L(L+1)]$，其中 $A_{\\phi} > 0$ 且 $L_d > 0$；对于 $L  2$， $C_L^{\\phi\\phi} = 0$。\n   - 高斯非关联噪声偏差 $N_L^{(0)}$ 被建模为 $N_L^{(0)} = N_0 \\left[1 + (L/L_0)^2\\right]$，其中 $N_0 > 0$ 且 $L_0 > 0$。\n   - 关联非高斯偏差 $N_L^{(1)}$ 被建模为 $N_L^{(1)} = \\alpha_1 C_L^{\\phi\\phi}$，其中 $\\alpha_1 \\ge 0$。\n   - 每个多极矩的总重建谱为 $C_L^{\\mathrm{tot}} = C_L^{\\phi\\phi} + N_L^{(0)} + N_L^{(1)}$。\n\n2. 通过在每个区间 $b$ 内对多极矩 $L$ 上的 $\\hat{C}_L$ 进行均匀平均来定义带功率 $\\hat{C}_b^{\\phi\\phi}$。区间被指定为 $L$ 的包含端点的整数范围。\n\n3. 在各向同性高斯近似和部分天区覆盖率 $f_{\\mathrm{sky}}$ 的条件下，从第一性原理推导带功率的解析协方差，并明确考虑 $C_L^{\\phi\\phi}$、$N_L^{(0)}$ 和 $N_L^{(1)}$ 的贡献以及模式的有限采样。\n\n4. 通过从与高斯近似和部分天区覆盖率 $f_{\\mathrm{sky}}$ 一致的适当分布中抽取 $\\hat{C}_L$ 的系综，为每次实现构建带功率，并估计整个系综的样本协方差，以此来实现蒙特卡洛验证。系综应足够大以确保估计稳定，并且抽样在不同 $L$ 和不同实现之间必须是独立的。\n\n5. 对比解析协方差与蒙特卡洛协方差的对角元素（方差）和非对角元素（协方差）。你的程序必须返回布尔值，以表明对角元素的最大相对偏差是否在指定容差内，以及最大的非对角元素的绝对值与一个代表性的对角尺度相比是否足够小。\n\n你的实现必须是自包含的，并在以下测试套件的参数值上运行。对于每个测试用例，完全按照指定的方式构建 $L$ 网格和区间：\n\n- 测试用例 1 (一般情况):\n  - $f_{\\mathrm{sky}} = 0.4$\n  - $A_{\\phi} = 1.0 \\times 10^{-7}$\n  - $L_d = 200$\n  - $N_0 = 5.0 \\times 10^{-8}$\n  - $L_0 = 150$\n  - $\\alpha_1 = 0.1$\n  - 多极矩范围: $L \\in \\{10, 11, \\dots, 300\\}$\n  - 区间: 8个等宽区间，将整个范围 $[10,300]$ 划分为不相交的连续整数区间。\n  - 蒙特卡洛实现次数: $6000$\n\n- 测试用例 2 (边界：小天区覆盖率):\n  - $f_{\\mathrm{sky}} = 0.05$\n  - $A_{\\phi} = 1.2 \\times 10^{-7}$\n  - $L_d = 300$\n  - $N_0 = 1.0 \\times 10^{-7}$\n  - $L_0 = 100$\n  - $\\alpha_1 = 0.2$\n  - 多极矩范围: $L \\in \\{20, 21, \\dots, 400\\}$\n  - 区间: 10个等宽区间，将整个范围 $[20,400]$ 划分为不相交的连续整数区间。\n  - 蒙特卡洛实现次数: $8000$\n\n- 测试用例 3 (边缘情况：单-$L$ 区间，噪声主导，无 $N^{(1)}$):\n  - $f_{\\mathrm{sky}} = 0.7$\n  - $A_{\\phi} = 8.0 \\times 10^{-8}$\n  - $L_d = 80$\n  - $N_0 = 3.0 \\times 10^{-7}$\n  - $L_0 = 120$\n  - $\\alpha_1 = 0.0$\n  - 多极矩集合: $L \\in \\{20, 60, 100\\}$\n  - 区间: 三个区间，每个区间恰好包含一个指定的多极矩: $[20,20]$, $[60,60]$, $[100,100]$。\n  - 蒙特卡洛实现次数: $20000$\n\n每个测试用例的验证标准:\n- 根据指定的近似和模型，计算解析带功率协方差矩阵。\n- 从带功率的蒙特卡洛系综中计算样本协方差矩阵。\n- 设 $\\Delta_{\\mathrm{diag}}$ 为解析方差和蒙特卡洛方差在所有区间上的最大相对偏差，定义为 $\\left| \\mathrm{Var}_{\\mathrm{MC}}(b) - \\mathrm{Var}_{\\mathrm{ana}}(b) \\right| / \\mathrm{Var}_{\\mathrm{ana}}(b)$ 在所有区间上的最大值。\n- 设 $\\Delta_{\\mathrm{off}}$ 为蒙特卡洛协方差的最大非对角元素绝对值除以解析对角方差的平均值。\n- 如果 $\\Delta_{\\mathrm{diag}} \\le 0.12$ 且 $\\Delta_{\\mathrm{off}} \\le 0.10$，则该测试用例通过。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果都是一个布尔值，表示相应的测试用例是否在指定标准下通过。不涉及物理单位；所有量纲均为无量纲。不使用角度。", "solution": "该问题要求推导和验证宇宙微波背景（CMB）引力透镜势功率谱带功率估计 $\\hat{C}_b^{\\phi\\phi}$ 的协方差。这项工作将在标准的二次估计框架内完成，并采用数值宇宙学中几种常见的近似方法。\n\n首先，我们定义构成每个多极矩 $L$ 上总重建功率谱的信号和噪声分量的理论模型。真实的引力透镜势功率谱由下式给出\n$$C_L^{\\phi\\phi} = \\frac{A_{\\phi} \\exp(-L/L_d)}{L(L+1)} \\quad \\text{for } L \\ge 2,$$\n其中对于 $L  2$，$C_L^{\\phi\\phi} = 0$。重建过程会引入噪声，其被建模为两个主要分量：高斯非关联噪声偏差 $N_L^{(0)}$ 和关联非高斯偏差 $N_L^{(1)}$。它们的函数形式为：\n$$N_L^{(0)} = N_0 \\left[1 + \\left(\\frac{L}{L_0}\\right)^2\\right]$$\n$$N_L^{(1)} = \\alpha_1 C_L^{\\phi\\phi}$$\n在单个多极矩 $L$ 上的功率谱估计量（记为 $\\hat{C}_L$）是一个随机变量，其期望值是真实信号与所有偏差项之和。这就是总重建功率 $C_L^{\\mathrm{tot}}$：\n$$\\langle \\hat{C}_L \\rangle = C_L^{\\mathrm{tot}} = C_L^{\\phi\\phi} + N_L^{(0)} + N_L^{(1)} = (1 + \\alpha_1)C_L^{\\phi\\phi} + N_L^{(0)}$$\n\n在底层CMB场是高斯的假设下，对于大量的模式，估计量 $\\hat{C}_L$ 近似服从高斯分布。$\\hat{C}_L$ 的方差由总功率 $C_L^{\\mathrm{tot}}$ 和该多极矩可用的独立模式数决定。对于全天观测，有 $2L+1$ 个模式。对于覆盖天区比例为 $f_{\\mathrm{sky}}$ 的观测，有效模式数减少到 $(2L+1)f_{\\mathrm{sky}}$。因此，该估计量的方差由标准功率谱方差公式给出，并根据天区覆盖率进行了调整：\n$$\\mathrm{Var}(\\hat{C}_L) = \\frac{2}{(2L+1)f_{\\mathrm{sky}}} (C_L^{\\mathrm{tot}})^2$$\n该框架下的一个关键假设是，不同多极矩 $L$ 和 $L'$ 处的估计量是不相关的。当忽略掩模（mask）引起的模式耦合时，这是一个很好的近似。因此，我们可以将多极矩估计量的协方差写为：\n$$\\mathrm{Cov}(\\hat{C}_L, \\hat{C}_{L'}) = \\delta_{LL'} \\mathrm{Var}(\\hat{C}_L)$$\n其中 $\\delta_{LL'}$ 是克罗内克（Kronecker）δ函数。\n\n为了减小方差，通过对 $L$ 空间中不相交区间内的多极矩估计量进行平均来构建带功率。对于一个给定的区间 $b$，它包含一个多极矩集合 $\\mathcal{L}_b$，其中有 $N_b = |\\mathcal{L}_b|$ 个成员，带功率估计量 $\\hat{C}_b$ 定义为简单平均：\n$$\\hat{C}_b = \\frac{1}{N_b} \\sum_{L \\in \\mathcal{L}_b} \\hat{C}_L$$\n两个带功率估计量 $\\hat{C}_b$ 和 $\\hat{C}_{b'}$ 之间的协方差可以利用协方差算子的线性性质推导得出：\n$$\\mathrm{Cov}(\\hat{C}_b, \\hat{C}_{b'}) = \\mathrm{Cov}\\left( \\frac{1}{N_b} \\sum_{L \\in \\mathcal{L}_b} \\hat{C}_L, \\frac{1}{N_{b'}} \\sum_{L' \\in \\mathcal{L}_{b'}} \\hat{C}_{L'} \\right)$$\n$$= \\frac{1}{N_b N_{b'}} \\sum_{L \\in \\mathcal{L}_b} \\sum_{L' \\in \\mathcal{L}_{b'}} \\mathrm{Cov}(\\hat{C}_L, \\hat{C}_{L'})$$\n代入 $\\mathrm{Cov}(\\hat{C}_L, \\hat{C}_{L'})$ 的表达式：\n$$\\mathrm{Cov}(\\hat{C}_b, \\hat{C}_{b'}) = \\frac{1}{N_b N_{b'}} \\sum_{L \\in \\mathcal{L}_b} \\sum_{L' \\in \\mathcal{L}_{b'}} \\delta_{LL'} \\mathrm{Var}(\\hat{C}_L)$$\n对该表达式的分析根据区间是否相同分为两种情况。\n\n情况1：非对角元素（$b \\neq b'$）。\n问题指定区间是不相交的，即 $\\mathcal{L}_b \\cap \\mathcal{L}_{b'} = \\emptyset$。在双重求和中，由克罗内克δ函数强加的条件 $L = L'$ 永远无法满足，因为 $L$ 来自 $\\mathcal{L}_b$ 而 $L'$ 来自 $\\mathcal{L}_{b'}$，它们没有共同的元素。因此，求和中的每一项都为零。\n$$\\mathrm{Cov}(\\hat{C}_b, \\hat{C}_{b'}) = 0 \\quad \\text{for } b \\neq b'$$\n在这些假设下，解析带功率协方差矩阵是对角的。\n\n情况2：对角元素（$b = b'$）。\n这给出了带功率估计量 $\\hat{C}_b$ 的方差。这里，$b' = b$，所以 $\\mathcal{L}_{b'} = \\mathcal{L}_b$ 且 $N_{b'} = N_b$。双重求和塌缩为单个求和：\n$$\\mathrm{Var}(\\hat{C}_b) = \\mathrm{Cov}(\\hat{C}_b, \\hat{C}_b) = \\frac{1}{N_b^2} \\sum_{L \\in \\mathcal{L}_b} \\sum_{L' \\in \\mathcal{L}_b} \\delta_{LL'} \\mathrm{Var}(\\hat{C}_L) = \\frac{1}{N_b^2} \\sum_{L \\in \\mathcal{L}_b} \\mathrm{Var}(\\hat{C}_L)$$\n代入 $\\mathrm{Var}(\\hat{C}_L)$ 的公式，我们得到解析带功率方差的最终表达式：\n$$\\mathrm{Var}_{\\mathrm{ana}}(b) = \\mathrm{Var}(\\hat{C}_b) = \\frac{1}{N_b^2} \\sum_{L \\in \\mathcal{L}_b} \\frac{2}{(2L+1)f_{\\mathrm{sky}}} \\left((1 + \\alpha_1)C_L^{\\phi\\phi} + N_L^{(0)}\\right)^2$$\n\n为了验证这一解析结果，我们进行蒙特卡洛模拟。这包括以下步骤：\n1. 对于指定网格上的每个多极矩 $L$，计算估计量的均值 $C_L^{\\mathrm{tot}}$ 和方差 $\\mathrm{Var}(\\hat{C}_L)$。\n2. 生成一个由 $N_{\\mathrm{MC}}$ 次实现构成的、包含全套多极矩估计量 $\\{\\hat{C}_L\\}$ 的大系综。对于每次实现 $i$ 和每个多极矩 $L$，从一个独立的、均值为 $\\mu=C_L^{\\mathrm{tot}}$、方差为 $\\sigma^2=\\mathrm{Var}(\\hat{C}_L)$ 的正态分布 $\\mathcal{N}$ 中抽取一个值 $\\hat{C}_{L,i}$。\n3. 对于 $N_{\\mathrm{MC}}$ 次实现中的每一次，通过对模拟的 $\\hat{C}_{L,i}$ 值在其各自的区间内进行平均，计算带功率向量 $\\{\\hat{C}_{b,i}\\}$。\n4. 从 $N_{\\mathrm{MC}}$ 个带功率向量构成的系综中，计算样本协方差矩阵 $\\mathrm{Cov}_{\\mathrm{MC}}(b, b')$。对于一组带功率向量 $\\{\\mathbf{v}_i\\}_{i=1}^{N_{\\mathrm{MC}}}$，其中 $\\mathbf{v}_i = (\\hat{C}_{1,i}, \\dots, \\hat{C}_{N_{\\text{bins}},i})$，样本协方差通过标准的统计方法计算，通常使用无偏估计量。\n\n验证过程包括将解析推导的对角协方差矩阵与蒙特卡洛模拟得出的样本协方差矩阵进行比较。\n- 通过最大相对偏差 $\\Delta_{\\mathrm{diag}} = \\max_{b} |\\mathrm{Var}_{\\mathrm{MC}}(b) - \\mathrm{Var}_{\\mathrm{ana}}(b)| / \\mathrm{Var}_{\\mathrm{ana}}(b)$ 来比较对角元素（方差）。这用于检验方差公式的准确性。\n- 解析协方差的非对角元素为零。由于其有限的样本量，蒙特卡洛模拟会产生微小但不为零的非对角元素。它们的量级通过 $\\Delta_{\\mathrm{off}}$ 进行评估，即 $\\mathrm{Cov}_{\\mathrm{MC}}$ 的最大非对角元素绝对值，并用解析方差的平均值进行归一化。这用于检验多极矩独立性假设的有效性。\n\n如果 $\\Delta_{\\mathrm{diag}}$ 和 $\\Delta_{\\mathrm{off}}$ 均低于它们各自的阈值，则认为解析模型及其所基于的假设对于给定的参数是经过验证的。", "answer": "```python\nimport numpy as np\nfrom scipy.special import xlogy # Not strictly needed, but can avoid warnings for L(L+1)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases for CMB lensing bandpower covariance validation.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general case)\n        {\n            \"f_sky\": 0.4, \"A_phi\": 1.0e-7, \"L_d\": 200, \"N_0\": 5.0e-8,\n            \"L_0\": 150, \"alpha_1\": 0.1, \"L_min\": 10, \"L_max\": 300,\n            \"n_bins\": 8, \"n_mc\": 6000\n        },\n        # Test Case 2 (boundary: small sky fraction)\n        {\n            \"f_sky\": 0.05, \"A_phi\": 1.2e-7, \"L_d\": 300, \"N_0\": 1.0e-7,\n            \"L_0\": 100, \"alpha_1\": 0.2, \"L_min\": 20, \"L_max\": 400,\n            \"n_bins\": 10, \"n_mc\": 8000\n        },\n        # Test Case 3 (edge case: single-L bins, noise dominated, no N(1))\n        {\n            \"f_sky\": 0.7, \"A_phi\": 8.0e-8, \"L_d\": 80, \"N_0\": 3.0e-7,\n            \"L_0\": 120, \"alpha_1\": 0.0, \"Ls\": np.array([20, 60, 100]),\n            \"n_bins\": 3, \"n_mc\": 20000\n        }\n    ]\n\n    results = []\n    \n    # Custom seed for reproducibility\n    # Using np.random.RandomState for compatibility with older numpy versions\n    # although default_rng is preferred in modern numpy. `np.random` functions are also fine.\n    rng = np.random.RandomState(seed=12345)\n\n    for case in test_cases:\n        # 1. Setup Models and Multipole Grid\n        f_sky = case[\"f_sky\"]\n        \n        # Define power spectrum and noise models\n        def c_l_phi_phi(L, A_phi, L_d):\n            # The model is for L = 2. The provided L ranges satisfy this.\n            return A_phi * np.exp(-L / L_d) / (L * (L + 1))\n\n        def n_l_0(L, N_0, L_0):\n            return N_0 * (1 + (L / L_0)**2)\n\n        if \"Ls\" in case: # Case 3 with an explicit list of Ls\n            L_grid = case[\"Ls\"]\n            bins = [[L] for L in L_grid]\n        else: # Cases 1 and 2 with L ranges and binning\n            L_min, L_max, n_bins = case[\"L_min\"], case[\"L_max\"], case[\"n_bins\"]\n            L_grid = np.arange(L_min, L_max + 1)\n            \n            # Partition L_grid into n_bins\n            n_L = len(L_grid)\n            base_width = n_L // n_bins\n            remainder = n_L % n_bins\n            \n            bin_sizes = [base_width + 1] * remainder + [base_width] * (n_bins - remainder)\n            \n            bins = []\n            current_idx = 0\n            for size in bin_sizes:\n                bins.append(L_grid[current_idx : current_idx + size])\n                current_idx += size\n        \n        A_phi, L_d = case[\"A_phi\"], case[\"L_d\"]\n        N_0, L_0 = case[\"N_0\"], case[\"L_0\"]\n        alpha_1 = case[\"alpha_1\"]\n\n        cl_phi_phi_vals = c_l_phi_phi(L_grid, A_phi, L_d)\n        nl0_vals = n_l_0(L_grid, N_0, L_0)\n        \n        cl_tot = (1 + alpha_1) * cl_phi_phi_vals + nl0_vals\n        var_cl = 2 * cl_tot**2 / ((2 * L_grid + 1) * f_sky)\n\n        # 2. Analytic Bandpower Covariance\n        analytic_variances = np.zeros(len(bins))\n        for i, bin_L_values in enumerate(bins):\n            N_b = len(bin_L_values)\n            # Find indices of L_values in the full L_grid\n            indices = np.where(np.isin(L_grid, bin_L_values))[0]\n            \n            # Sum variances of C_L within the bin\n            sum_var_cl = np.sum(var_cl[indices])\n            analytic_variances[i] = sum_var_cl / (N_b**2)\n\n        # 3. Monte Carlo Validation\n        n_mc = case[\"n_mc\"]\n        \n        # Generate all MC realizations for all L's at once\n        mc_cl_realizations = rng.normal(loc=cl_tot, scale=np.sqrt(var_cl), size=(n_mc, len(L_grid)))\n        \n        # Calculate bandpowers for each realization\n        mc_bandpowers = np.zeros((n_mc, len(bins)))\n        for i, bin_L_values in enumerate(bins):\n            indices = np.where(np.isin(L_grid, bin_L_values))[0]\n            # Average over the C_L realizations in the bin\n            mc_bandpowers[:, i] = np.mean(mc_cl_realizations[:, indices], axis=1)\n            \n        # Calculate the sample covariance matrix\n        # rowvar=False because each column is a variable (a bin), and each row is an observation\n        mc_cov = np.cov(mc_bandpowers, rowvar=False)\n\n        # 4. Comparison and Validation\n        mc_variances = np.diag(mc_cov)\n        \n        # Delta_diag: Max relative deviation of variances\n        delta_diag = np.max(np.abs(mc_variances - analytic_variances) / analytic_variances)\n        \n        # Delta_off: Max absolute off-diagonal element of MC cov, normalized\n        # Set diagonal to zero to easily find max off-diagonal element\n        off_diag_mc_cov = mc_cov.copy()\n        np.fill_diagonal(off_diag_mc_cov, 0)\n        max_abs_off_diag = np.max(np.abs(off_diag_mc_cov))\n        mean_analytic_var = np.mean(analytic_variances)\n        \n        # Handle case where mean_analytic_var could be zero (unlikely but safe)\n        delta_off = max_abs_off_diag / mean_analytic_var if mean_analytic_var  0 else 0\n\n        # Check against validation criteria\n        diag_passed = delta_diag = 0.12\n        off_diag_passed = delta_off = 0.10\n        \n        results.append(diag_passed and off_diag_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\")\n\nsolve()\n```", "id": "3467597"}, {"introduction": "真实的观测不可避免地是不完整的，这需要使用一个“掩模”（mask），从而使功率谱估计变得复杂。最后一个实践将介绍在完整球形天空上处理掩模数据的形式化数学框架 [@problem_id:3467517]。你将推导模式耦合矩阵以及对“伪谱”（pseudo-spectrum）进行去偏以恢复对真实透镜功率谱的无偏估计的步骤。", "problem": "考虑使用由滤波后的CMB场构建的二次估计量$\\hat{\\phi}(\\hat{\\boldsymbol{n}})$来重建球面上宇宙微波背景（CMB）的标量引力透镜势$\\phi(\\hat{\\boldsymbol{n}})$。假设全天估计量已被归一化，使得在没有掩模和各向异性的情况下，其谐空间响应是各向同性的，并由一个已知的标量响应函数$R_{L}$给出，因此在引力透镜的领头阶上，$\\langle \\hat{\\phi}_{LM} \\rangle = R_{L}\\,\\phi_{LM}$。\n\n令观测到的天区乘以一个标量的、边缘柔化的窗函数$W(\\hat{\\boldsymbol{n}})$，该函数在掩模区域为零，在未掩模区域为一。定义掩模后的重建场$\\widetilde{\\phi}(\\hat{\\boldsymbol{n}}) \\equiv W(\\hat{\\boldsymbol{n}})\\,\\hat{\\phi}(\\hat{\\boldsymbol{n}})$，其球谐系数为$\\widetilde{\\phi}_{LM}$。掩模后重建的伪功率谱定义为$\\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\equiv \\frac{1}{2L+1}\\sum_{M} |\\widetilde{\\phi}_{LM}|^{2}$。该掩模具有谐系数$W_{LM}$和相关的功率谱$C_{L}^{WW} \\equiv \\frac{1}{2L+1}\\sum_{M} |W_{LM}|^{2}$。\n\n从球面上的球谐分析和球谐函数乘积的Gaunt积分的第一性原理出发，并将$\\hat{\\phi}$视为一个标量场，执行以下操作：\n\n1. 推导由掩模$W(\\hat{\\boldsymbol{n}})$引起的系综平均伪谱$\\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle$与重建的真实谱$\\langle C_{L'}^{\\hat{\\phi}\\hat{\\phi}} \\rangle$之间的耦合关系。用掩模功率谱$C_{L''}^{WW}$和Wigner 3j符号表示伪-$C_{\\ell}$耦合矩阵$M_{LL'}$。\n\n2. 考虑由多极矩范围$\\{L \\in b\\}$上的顶帽型分箱$b$定义的频段功率，其分箱宽度为$\\Delta_{b} \\equiv \\sum_{L \\in b} 1$。定义分箱伪谱$\\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\equiv \\frac{1}{\\Delta_{b}}\\sum_{L \\in b} \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}}$以及类似的$C_{b}^{\\phi\\phi} \\equiv \\frac{1}{\\Delta_{b}}\\sum_{L \\in b} C_{L}^{\\phi\\phi}$和分箱响应因子$R_{b}^{2} \\equiv \\frac{1}{\\Delta_{b}}\\sum_{L \\in b} R_{L}^{2}$。使用第一部分推导的标量场耦合关系和领头阶重建关系$\\langle C_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = R_{L}^{2}\\,C_{L}^{\\phi\\phi} + N_{L}^{(0)} + N_{L}^{(1)}$（其中$N_{L}^{(0)}$和$N_{L}^{(1)}$分别是二次估计量的不相连偏置和次级偏置），得到在领头阶上连接$\\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle$与$C_{b'}^{\\phi\\phi}$的频段功率耦合矩阵$K_{bb'}$。\n\n3. 考虑到掩模引起的平均场和标准的二次估计量偏置$N_{L}^{(0)}$和$N_{L}^{(1)}$，并假设它们经过频段平均的掩模版本$\\widetilde{N}_{b}^{(0)}$、$\\widetilde{N}_{b}^{(1)}$以及残余平均场频段功率$\\widetilde{B}_{b}^{\\mathrm{MF}}$可从模拟中获知，推导一个关于频段功率引力透镜势谱$C_{b}^{\\phi\\phi}$的无偏估计量的闭式解析表达式。该表达式应使用频段功率耦合矩阵$K_{bb'}$的逆和测量的掩模伪频段功率$\\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}}$来表示。\n\n你的最终答案必须是无偏估计量$\\hat{C}_{b}^{\\phi\\phi}$的单个闭式解析表达式，用关于多极矩、Wigner 3j符号和掩模谱$C_{L}^{WW}$的显式求和形式写出。不需要进行数值评估，也不应进行任何四舍五入。", "solution": "该问题要求分三部分进行推导，内容涉及从掩模天区估计CMB引力透镜势功率谱。我们将首先验证问题陈述，然后为每个部分提供逐步推导。\n\n### 问题验证\n问题陈述是CMB数据分析中的一个标准练习，具体涉及存在天空掩模时的功率谱估计。所有给定条件都是数值宇宙学领域的标准定义。\n- **给定条件**: 标量引力透镜势$\\phi(\\hat{\\boldsymbol{n}})$，二次估计量$\\hat{\\phi}(\\hat{\\boldsymbol{n}})$，全天响应函数$R_L$，窗函数$W(\\hat{\\boldsymbol{n}})$，掩模场$\\widetilde{\\phi}(\\hat{\\boldsymbol{n}})$，伪功率谱$\\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}}$，掩模功率谱$C_{L}^{WW}$，真实重建谱的关系式$\\langle C_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = R_{L}^{2}\\,C_{L}^{\\phi\\phi} + N_{L}^{(0)} + N_{L}^{(1)}$，以及分箱量（$\\Delta_b$, $\\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}}$, $C_{b}^{\\phi\\phi}$, $R_{b}^{2}$）和偏置项（$\\widetilde{N}_{b}^{(0)}$, $\\widetilde{N}_{b}^{(1)}$, $\\widetilde{B}_{b}^{\\mathrm{MF}}$）的定义。\n- **验证结论**：该问题是**有效的**。它在科学上基于已建立的宇宙学数据分析技术（“MASTER”算法形式），问题设定良好，有通向唯一解的清晰路径，并以客观、正式的语言表述。这是该领域一个非平凡但标准的推导。\n\n### 第一部分：伪-$C_{\\ell}$耦合矩阵$M_{LL'}$的推导\n我们从掩模场的定义$\\widetilde{\\phi}(\\hat{\\boldsymbol{n}}) = W(\\hat{\\boldsymbol{n}})\\hat{\\phi}(\\hat{\\boldsymbol{n}})$开始。这个乘积场的球谐系数$\\widetilde{\\phi}_{LM}$由$W(\\hat{\\boldsymbol{n}})$和$\\hat{\\phi}(\\hat{\\boldsymbol{n}})$的系数的卷积给出。\n两个标量场$A(\\hat{\\boldsymbol{n}})$和$B(\\hat{\\boldsymbol{n}})$乘积的系数由下式给出：\n$$ (AB)_{LM} = \\sum_{l_1 m_1 l_2 m_2} A_{l_1 m_1} B_{l_2 m_2} \\int Y_{LM}^{*}(\\hat{\\boldsymbol{n}}) Y_{l_1 m_1}(\\hat{\\boldsymbol{n}}) Y_{l_2 m_2}(\\hat{\\boldsymbol{n}}) d\\Omega $$\n该积分为一个Gaunt积分，可以用Wigner 3j符号表示：\n$$ \\int Y_{l_1 m_1} Y_{l_2 m_2} Y_{l_3 m_3} d\\Omega = \\sqrt{\\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\\pi}} \\begin{pmatrix} l_1  l_2  l_3 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} l_1  l_2  l_3 \\\\ m_1  m_2  m_3 \\end{pmatrix} $$\n使用$Y_{LM}^* = (-1)^M Y_{L,-M}$，掩模场的系数为：\n$$ \\widetilde{\\phi}_{LM} = \\sum_{l_1 m_1 l_2 m_2} W_{l_1 m_1} \\hat{\\phi}_{l_2 m_2} (-1)^M \\sqrt{\\frac{(2l_1+1)(2l_2+1)(2L+1)}{4\\pi}} \\begin{pmatrix} l_1  l_2  L \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} l_1  l_2  L \\\\ m_1  m_2  -M \\end{pmatrix} $$\n伪功率谱定义为$\\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\equiv \\frac{1}{2L+1}\\sum_{M} |\\widetilde{\\phi}_{LM}|^{2}$。我们关心的是其系综平均$\\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle$。因此我们计算$\\langle \\widetilde{\\phi}_{LM}\\widetilde{\\phi}_{LM}^{*} \\rangle$。场$\\hat{\\phi}$是一个统计各向同性的随机场，因此其谐系数具有性质$\\langle \\hat{\\phi}_{l_2 m_2} \\hat{\\phi}_{l_4 m_4}^{*} \\rangle = \\delta_{l_2 l_4} \\delta_{m_2 m_4} C_{l_2}^{\\hat{\\phi}\\hat{\\phi}}$，其中$C_{l_2}^{\\hat{\\phi}\\hat{\\phi}}$是重建的功率谱。窗函数$W$是一个固定的、确定性的函数。\n$$ \\langle \\widetilde{\\phi}_{LM}\\widetilde{\\phi}_{LM}^{*} \\rangle = \\sum_{\\substack{l_1 m_1 l_2 m_2 \\\\ l_3 m_3 l_4 m_4}} W_{l_1 m_1} W_{l_3 m_3}^{*} \\langle \\hat{\\phi}_{l_2 m_2} \\hat{\\phi}_{l_4 m_4}^{*} \\rangle (\\text{Gaunt products}) $$\n$$ \\langle |\\widetilde{\\phi}_{LM}|^2 \\rangle = \\sum_{l_1 m_1, l_2 m_2, l_3 m_3} W_{l_1 m_1} W_{l_3 m_3}^{*} C_{l_2}^{\\hat{\\phi}\\hat{\\phi}} \\left( \\mathcal{G}^{LM}_{l_1 m_1, l_2 m_2} \\right) \\left( \\mathcal{G}^{LM}_{l_3 m_3, l_2 m_2} \\right)^* $$\n现在我们对$M$求和并除以$2L+1$：\n$$ \\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{l_2} C_{l_2}^{\\hat{\\phi}\\hat{\\phi}} \\left[ \\sum_{l_1 m_1, l_3 m_3} \\frac{W_{l_1 m_1} W_{l_3 m_3}^{*}}{2L+1} \\sum_{M, m_2} \\mathcal{G}^{LM}_{l_1 m_1 l_2 m_2} (\\mathcal{G}^{LM}_{l_3 m_3 l_2 m_2})^* \\right] $$\n方括号中的项是耦合矩阵。内部对$M, m_2$的求和可以使用Wigner 3j符号的正交关系进行简化：\n$$ \\sum_{m_2, M} \\begin{pmatrix} l_1  l_2  L \\\\ m_1  m_2  -M \\end{pmatrix} \\begin{pmatrix} l_3  l_2  L \\\\ m_3  m_2  -M \\end{pmatrix} = \\frac{\\delta_{l_1 l_3} \\delta_{m_1 m_3}}{2l_1+1} $$\n代入Gaunt符号的完整表达式并使用此恒等式，对$M,m_2$的求和变为：\n$$ \\frac{(2l_1+1)(2l_2+1)(2L+1)}{4\\pi} \\begin{pmatrix} l_1  l_2  L \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} l_3  l_2  L \\\\ 0  0  0 \\end{pmatrix} \\frac{\\delta_{l_1 l_3} \\delta_{m_1 m_3}}{2l_1+1} $$\n将其代回，$\\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle$的表达式变为：\n$$ \\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{l_2} C_{l_2}^{\\hat{\\phi}\\hat{\\phi}} \\sum_{l_1 m_1, l_3 m_3} \\frac{W_{l_1 m_1} W_{l_3 m_3}^{*}}{2L+1} \\left( \\frac{(2l_2+1)(2L+1)}{4\\pi} \\begin{pmatrix} l_1  l_2  L \\\\ 0  0  0 \\end{pmatrix}^2 \\delta_{l_1 l_3} \\delta_{m_1 m_3} \\right) $$\n克罗内克$\\delta$符号简化了对$l_3, m_3$的求和：\n$$ \\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{l_2} C_{l_2}^{\\hat{\\phi}\\hat{\\phi}} \\sum_{l_1 m_1} |W_{l_1 m_1}|^2 \\frac{(2l_2+1)}{4\\pi} \\begin{pmatrix} l_1  l_2  L \\\\ 0  0  0 \\end{pmatrix}^2 $$\n使用掩模功率谱的定义$C_{l_1}^{WW} = \\frac{1}{2l_1+1}\\sum_{m_1} |W_{l_1 m_1}|^2$，我们得到：\n$$ \\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{l_2} C_{l_2}^{\\hat{\\phi}\\hat{\\phi}} \\sum_{l_1} (2l_1+1)C_{l_1}^{WW} \\frac{(2l_2+1)}{4\\pi} \\begin{pmatrix} l_1  l_2  L \\\\ 0  0  0 \\end{pmatrix}^2 $$\n这具有$\\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{L'} M_{LL'} C_{L'}^{\\hat{\\phi}\\hat{\\phi}}$的形式。通过识别各项（$L' \\leftrightarrow l_2$, $L'' \\leftrightarrow l_1$），我们找到耦合矩阵：\n$$ M_{LL'} = \\sum_{L''} \\frac{(2L'+1)(2L''+1)}{4\\pi} C_{L''}^{WW} \\begin{pmatrix} L  L'  L'' \\\\ 0  0  0 \\end{pmatrix}^2 $$\n\n### 第二部分：频段功率耦合矩阵$K_{bb'}$的推导\n分箱伪谱定义为$\\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}}$。其系综平均为：\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\langle \\widetilde{C}_{L}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L'} M_{LL'} \\langle C_{L'}^{\\hat{\\phi}\\hat{\\phi}} \\rangle $$\n问题陈述在领头阶上，$\\langle C_{L'}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = R_{L'}^2 C_{L'}^{\\phi\\phi}$（我们暂时忽略偏置项）。\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L'} M_{LL'} R_{L'}^2 C_{L'}^{\\phi\\phi} $$\n为了用频段功率$C_{b'}^{\\phi\\phi}$来表示，我们将对$L'$的求和划分为不同的分箱$b'$：\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{b'} \\sum_{L' \\in b'} M_{LL'} R_{L'}^2 C_{L'}^{\\phi\\phi} $$\n我们现在做一个标准近似，即底层的谱$C_{L'}^{\\phi\\phi}$在一个分箱$b'$内的多极矩上变化缓慢，因此对于所有$L' \\in b'$，有$C_{L'}^{\\phi\\phi} \\approx C_{b'}^{\\phi\\phi}$。这使我们可以将$C_{b'}^{\\phi\\phi}$从内层求和中提出来：\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle \\approx \\sum_{b'} \\left( \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L' \\in b'} M_{LL'} R_{L'}^2 \\right) C_{b'}^{\\phi\\phi} $$\n这就给出了关系式$\\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{b'} K_{bb'} C_{b'}^{\\phi\\phi}$，其中频段功率耦合矩阵$K_{bb'}$为：\n$$ K_{bb'} = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L' \\in b'} M_{LL'} R_{L'}^2 $$\n将第一部分中$M_{LL'}$的表达式代入，得到频段功率耦合矩阵的最终形式：\n$$ K_{bb'} = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L' \\in b'} R_{L'}^2 \\left( \\sum_{L''} \\frac{(2L'+1)(2L''+1)}{4\\pi} C_{L''}^{WW} \\begin{pmatrix} L  L'  L'' \\\\ 0  0  0 \\end{pmatrix}^2 \\right) $$\n\n### 第三部分：无偏估计量$\\hat{C}_{b}^{\\phi\\phi}$的推导\n我们现在构建观测到的分箱伪谱的完整正向模型，包括所有指定的偏置项。总的真实重建谱为$\\langle C_{L'}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = R_{L'}^2 C_{L'}^{\\phi\\phi} + N_{L'}^{(0)} + N_{L'}^{(1)}$。\n此完整谱上的模式耦合作用为：\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle_{\\text{no MF}} = \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L'} M_{LL'} (R_{L'}^2 C_{L'}^{\\phi\\phi} + N_{L'}^{(0)} + N_{L'}^{(1)}) $$\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle_{\\text{no MF}} = \\left( \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L'} M_{LL'} R_{L'}^2 C_{L'}^{\\phi\\phi} \\right) + \\left( \\frac{1}{\\Delta_{b}} \\sum_{L \\in b} \\sum_{L'} M_{LL'} (N_{L'}^{(0)} + N_{L'}^{(1)}) \\right) $$\n第一项是分箱的、耦合的信号，我们发现它等于$\\sum_{b'} K_{bb'} C_{b'}^{\\phi\\phi}$。第二项表示掩模耦合的二次估计量偏置。根据问题陈述，这些偏置的分箱掩模版本，记为$\\widetilde{N}_{b}^{(0)}$和$\\widetilde{N}_{b}^{(1)}$，是已知的。因此该项等于$\\widetilde{N}_{b}^{(0)} + \\widetilde{N}_{b}^{(1)}$。\n此外，我们必须考虑掩模引起的平均场。它对伪谱的贡献$\\widetilde{B}_{b}^{\\mathrm{MF}}$线性地加到总伪谱上。\n因此，测得的分箱伪谱期望值的完整模型为：\n$$ \\langle \\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}} \\rangle = \\sum_{b'} K_{bb'} C_{b'}^{\\phi\\phi} + \\widetilde{N}_{b}^{(0)} + \\widetilde{N}_{b}^{(1)} + \\widetilde{B}_{b}^{\\mathrm{MF}} $$\n为了构建$C_{b}^{\\phi\\phi}$的无偏估计量，我们首先解这个关于真实频段功率向量$\\mathbf{C}^{\\phi\\phi}$（其元素为$C_b^{\\phi\\phi}$）的线性方程组。在矩阵表示法中，$\\mathbf{K}$是元素为$K_{bb'}$的矩阵，$\\widetilde{\\mathbf{C}}$的元素为$\\widetilde{C}_{b}^{\\hat{\\phi}\\hat{\\phi}}$，$\\mathbf{B}$是总偏置向量，其元素为$B_b = \\widetilde{N}_{b}^{(0)} + \\widetilde{N}_{b}^{(1)} + \\widetilde{B}_{b}^{\\mathrm{MF}}$：\n$$ \\langle \\widetilde{\\mathbf{C}} \\rangle = \\mathbf{K} \\mathbf{C}^{\\phi\\phi} + \\mathbf{B} $$\n求解$\\mathbf{C}^{\\phi\\phi}$：\n$$ \\mathbf{C}^{\\phi\\phi} = \\mathbf{K}^{-1} (\\langle \\widetilde{\\mathbf{C}} \\rangle - \\mathbf{B}) $$\n通过将系综平均$\\langle \\widetilde{\\mathbf{C}} \\rangle$替换为单次测量值$\\widetilde{\\mathbf{C}}$，我们得到一个无偏估计量$\\hat{\\mathbf{C}}^{\\phi\\phi}$：\n$$ \\hat{\\mathbf{C}}^{\\phi\\phi} = \\mathbf{K}^{-1} (\\widetilde{\\mathbf{C}} - \\mathbf{B}) $$\n此估计量的期望值为$\\langle \\hat{\\mathbf{C}}^{\\phi\\phi} \\rangle = \\mathbf{K}^{-1} (\\langle \\widetilde{\\mathbf{C}} \\rangle - \\mathbf{B}) = \\mathbf{K}^{-1} (\\mathbf{K} \\mathbf{C}^{\\phi\\phi} + \\mathbf{B} - \\mathbf{B}) = \\mathbf{C}^{\\phi\\phi}$，这证实了它是无偏的。\n对于单个分箱$b$，将其写出：\n$$ \\hat{C}_{b}^{\\phi\\phi} = \\sum_{b'} (K^{-1})_{bb'} \\left( \\widetilde{C}_{b'}^{\\hat{\\phi}\\hat{\\phi}} - \\widetilde{N}_{b'}^{(0)} - \\widetilde{N}_{b'}^{(1)} - \\widetilde{B}_{b'}^{\\mathrm{MF}} \\right) $$\n该表达式通过校正测量的伪谱频段功率中的模式耦合和所有相关偏置，提供了引力透镜功率谱频段功率的无偏估计。最终答案要求将矩阵$K$的完整定义代入此表达式。", "answer": "$$ \\boxed{ \\hat{C}_{b}^{\\phi\\phi} = \\sum_{b'} \\left( \\left[ \\frac{1}{\\Delta_{b_1}} \\sum_{L_1 \\in b_1} \\sum_{L_2 \\in b_2} R_{L_2}^2 \\left( \\sum_{L_3} \\frac{(2L_2+1)(2L_3+1)}{4\\pi} C_{L_3}^{WW} \\begin{pmatrix}L_1  L_2  L_3 \\\\ 0  0  0\\end{pmatrix}^2 \\right) \\right]_{b_1, b_2}^{-1} \\right)_{b,b'} \\left( \\widetilde{C}_{b'}^{\\hat{\\phi}\\hat{\\phi}} - \\widetilde{N}_{b'}^{(0)} - \\widetilde{N}_{b'}^{(1)} - \\widetilde{B}_{b'}^{\\mathrm{MF}} \\right) } $$", "id": "3467517"}]}