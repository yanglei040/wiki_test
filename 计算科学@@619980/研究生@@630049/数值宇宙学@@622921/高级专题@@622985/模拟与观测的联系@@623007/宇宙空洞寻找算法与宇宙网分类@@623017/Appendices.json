{"hands_on_practices": [{"introduction": "宇宙网的表征需要测量宇宙学密度场的局部几何性质。本练习将聚焦于实现该任务的一个基本工具：使用傅里叶方法计算场的梯度和Hessian矩阵。你将通过在傅里叶空间中实现高斯平滑和微分，亲身体会这些算符的工作原理，并理解平滑尺度如何影响导数的计算结果。[@problem_id:3502022]", "problem": "给定一个代表在均匀周期性网格上采样的德劳内三角剖分场估计器 (Delaunay Tessellation Field Estimator, DTFE) 重建的二维标量场，你需要实现傅里叶空间中的高斯平滑，并量化它对梯度和黑塞矩阵（Hessian）引起的衰减。使用通过快速傅里叶变换 (FFT) 计算的离散傅里叶变换 (DFT)，并利用以下基本事实：(i) 实数空间中的卷积对应于傅里叶空间中的乘法；(ii) 方差为 $\\sigma^2$ 的高斯函数的傅里叶变换是另一个高斯函数，在波数域中的乘子为 $\\exp(-k^2\\sigma^2/2)$，其中 $k^2 = k_x^2+k_y^2$；(iii) 对于关于 $x$ 和 $y$ 的偏导数，微分在傅里叶空间中分别对应于乘以 $\\mathrm{i}k_x$ 和 $\\mathrm{i}k_y$。对于通过将原始场 $\\phi$ 与方差为 $\\sigma^2$ 的高斯核进行卷积得到的平滑场 $\\phi_{\\sigma}$，其傅里叶系数满足 $\\widehat{\\phi_{\\sigma}}(\\boldsymbol{k}) = \\widehat{\\phi}(\\boldsymbol{k})\\exp(-k^2\\sigma^2/2)$。傅里叶空间中的梯度和黑塞矩阵可由这些性质推导得出。在宇宙网分类的背景下，黑塞矩阵的特征值用于识别空洞和其他结构，高斯平滑通过阻尼高波数模式来修改它们的振幅。\n\n你的任务是编写一个完整的程序，该程序能够：\n- 在一个边长 $L = 1$、在 $N \\times N$（其中 $N = 64$）网格上采样的周期性方形域上，构建指定的测试场 $\\phi(x,y)$。\n- 通过乘以 $\\exp(-k^2\\sigma^2/2)$，在傅里叶空间中实现方差为 $\\sigma^2$ 的高斯平滑。\n- 通过傅里叶空间微分计算梯度 $\\nabla \\phi$ 和黑塞矩阵 $\\nabla \\nabla \\phi$。\n- 对于单模场，估计梯度大小的均方根 (RMS) 和最小黑塞矩阵特征值的RMS的衰减因子，并将它们与该模式（波数大小为 $k_0$）的理论因子 $\\exp(-k_0^2\\sigma^2/2)$ 进行比较。\n- 对于双模叠加场，估计梯度大小的RMS和黑塞矩阵的弗罗贝尼乌斯范数 (Frobenius norm) 的RMS的衰减因子，并将每个因子与一个纯粹由傅里叶空间能量加权计算的预测比率进行比较：\n$$\nR_{\\mathrm{grad,pred}}(\\sigma) \\equiv \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^2\\,|\\widehat{\\phi}(\\boldsymbol{k})|^2\\, \\exp(-k^2\\sigma^2)}{\\sum_{\\boldsymbol{k}} k^2\\,|\\widehat{\\phi}(\\boldsymbol{k})|^2}}, \\quad\nR_{\\mathrm{H,pred}}(\\sigma) \\equiv \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^4\\,|\\widehat{\\phi}(\\boldsymbol{k})|^2\\, \\exp(-k^2\\sigma^2)}{\\sum_{\\boldsymbol{k}} k^4\\,|\\widehat{\\phi}(\\boldsymbol{k})|^2}}.\n$$\n此处 $k^2 = k_x^2+k_y^2$，求和遍及网格上所有的离散傅里叶模式。使用弗罗贝尼乌斯范数 $\\|\\nabla \\nabla \\phi\\|_{F} = \\sqrt{\\phi_{xx}^{2} + 2\\phi_{xy}^{2} + \\phi_{yy}^{2}}$ 确保了多模场的线性谱加权。\n\n定义与假设：\n- 德劳内三角剖分场估计器 (Delaunay Tessellation Field Estimator, DTFE)：一种从离散样本重建连续密度类场的方法。在本任务中，您将在一个已网格化的、代表DTFE输出的场上进行操作。\n- 快速傅里叶变换 (Fast Fourier Transform, FFT)：一种高效计算离散傅里叶变换 (DFT) 的算法。\n- 计算域为 $[0,1)\\times[0,1)$，具有周期性边界条件。\n- 所有量都是无量纲的；不需要物理单位。\n- 角度（当通过三角函数隐式出现时）以弧度为单位。\n\n实现以下测试套件。对于每种情况，在网格上构建指定的场 $\\phi(x,y)$ 并执行上述操作。\n\n- 测试 $1$ (单模，基准衰减)：\n  - 场：$\\phi(x,y) = A\\cos(2\\pi n_x x)$，其中 $A = 1$， $n_x = 4$。\n  - 平滑方差：$\\sigma^2$，其中 $\\sigma = 0.05$。\n  - RMS梯度大小和RMS最小黑塞特征值的预测衰减因子：$\\exp(-k_0^2\\sigma^2/2)$，其中 $k_0 = 2\\pi n_x$。\n  - 输出两个浮点数：测量的梯度RMS比率与预测因子之间的相对误差，以及测量的RMS最小特征值比率与预测因子之间的相对误差。\n\n- 测试 $2$ (单位平滑边界)：\n  - 场与测试 $1$ 相同。\n  - 平滑方差：$\\sigma^2$，其中 $\\sigma = 0.0$。\n  - 预测衰减因子：$1$。\n  - 输出两个浮点数，同测试 $1$。\n\n- 测试 $3$ (更高频率，更强衰减)：\n  - 场：$\\phi(x,y) = A\\cos(2\\pi n_x x)$，其中 $A = 1$， $n_x = 8$。\n  - 平滑方差：$\\sigma^2$，其中 $\\sigma = 0.12$。\n  - 预测衰减因子：$\\exp(-k_0^2\\sigma^2/2)$，其中 $k_0 = 2\\pi n_x$。\n  - 输出两个浮点数，同测试 $1$。\n\n- 测试 $4$ (双模叠加，谱能量预测)：\n  - 场：$\\phi(x,y) = A_1\\cos(2\\pi n_1 x) + A_2\\cos(2\\pi n_2 y)$，其中 $A_1 = 1$, $n_1 = 3$, $A_2 = 0.8$, $n_2 = 5$。\n  - 平滑方差：$\\sigma^2$，其中 $\\sigma = 0.07$。\n  - 预测的梯度RMS比率 $R_{\\mathrm{grad,pred}}(\\sigma)$ 和预测的黑塞矩阵弗罗贝尼乌斯RMS比率 $R_{\\mathrm{H,pred}}(\\sigma)$，使用未平滑的 $\\widehat{\\phi}$，通过上述傅里叶空间加权和计算。\n  - 输出两个浮点数：测量的梯度RMS比率与 $R_{\\mathrm{grad,pred}}(\\sigma)$ 之间的相对误差，以及测量的黑塞矩阵弗罗贝尼乌斯RMS比率与 $R_{\\mathrm{H,pred}}(\\sigma)$ 之间的相对误差。\n\n对于每个测试，将测量比率定义为：\n- 梯度RMS比率：$\\|\\nabla \\phi_{\\sigma}\\|$ 的RMS除以 $\\|\\nabla \\phi\\|$ 的RMS，其中 $\\|\\nabla \\phi\\| = \\sqrt{\\phi_x^2 + \\phi_y^2}$。\n- 单模测试的最小黑塞特征值RMS比率：$\\nabla \\nabla \\phi_{\\sigma}$ 的逐点最小特征值的RMS除以 $\\nabla \\nabla \\phi$ 的逐点最小特征值的RMS。\n- 双模测试的黑塞矩阵弗罗贝尼乌斯RMS比率：弗罗贝尼乌斯范数 $\\|\\nabla \\nabla \\phi_{\\sigma}\\|_{F}$ 的RMS除以 $\\|\\nabla \\nabla \\phi\\|_{F}$ 的RMS。\n\n所有基于FFT的导数和平滑必须在周期域上一致地实现。所有测试均使用 $N = 64$ 和 $L = 1$。最终程序必须按顺序计算以下八个浮点数：\n$[\\,$测试$\\,1$梯度相对误差, 测试$\\,1$最小特征值相对误差, 测试$\\,2$梯度相对误差, 测试$\\,2$最小特征值相对误差, 测试$\\,3$梯度相对误差, 测试$\\,3$最小特征值相对误差, 测试$\\,4$梯度相对误差, 测试$\\,4$黑塞-弗罗贝尼乌斯相对误差$\\,]$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}]$）。每个结果必须是浮点数。不需要外部输入，所有计算都是无量纲的，无需单位转换。若有角度，则其构造上单位为弧度。", "solution": "该问题被评估为有效。它在科学上基于傅里叶分析原理及其在数值场论中的应用，是一个适定问题，提供了所有必要的参数和定义，并以客观、正式的语言陈述。它提出了一个非凡但可行的计算任务，该任务测试了对这些原理的理解和实现。\n\n解决方案通过以系统化的方式实现指定的数值方法来推进。首先，我们建立计算网格和相应的傅里叶空间坐标（波数）。然后，我们定义一组函数，使用傅里叶空间微分来计算场的梯度和黑塞矩阵。这些函数将构成我们分析的核心。我们还将实现高斯平滑操作，作为傅里叶空间中的一个乘法运算。最后，我们将处理每个测试用例，方法是构建指定的场，应用平滑和微分算子，计算所需的均方根 (RMS) 度量，并将结果与其理论预测进行比较。\n\n**1. 网格与波数表示**\n\n问题定义在一个二维周期域 $[0, L) \\times [0, L)$ 上，边长 $L = 1$，在 $N \\times N$ 个点的均匀网格上采样，其中 $N=64$。网格坐标 $(x_j, y_l)$ 由下式给出：\n$$ x_j = j \\frac{L}{N}, \\quad y_l = l \\frac{L}{N} \\quad \\text{其中 } j, l \\in \\{0, 1, \\dots, N-1\\} $$\n离散傅里叶变换 (DFT) 将此实空间网格上的函数映射到离散波数网格上的系数。波数 $(k_x, k_y)$ 由网格大小 $N$ 和域长度 $L$ 决定。对于使用快速傅里叶变换 (FFT) 算法实现的DFT，相应的频率由标准库函数提供（例如，`numpy.fft.fftfreq`）。通过将这些频率乘以 $2\\pi$ 来获得波数：\n$$ k_{x,m} = 2\\pi f_m, \\quad k_{y,n} = 2\\pi f_n $$\n其中 $f_m$ 和 $f_n$ 是对于具有采样间距 $d = L/N$ 的 $N$ 点变换的离散频率。我们为 $k_x$、$k_y$ 以及波数大小的平方 $k^2 = k_x^2 + k_y^2$ 构建二维数组，这些数组将被重复使用。\n\n**2. 傅里叶空间算子**\n\n这个问题的基础在于傅里叶变换的性质。设 $\\widehat{\\phi}(\\boldsymbol{k})$ 表示标量场 $\\phi(\\boldsymbol{x})$ 的DFT，其中 $\\boldsymbol{k} = (k_x, k_y)$。\n\n**a. 高斯平滑：**\n场 $\\phi$ 与方差为 $\\sigma^2$ 的高斯核的卷积，等价于将其傅里叶变换 $\\widehat{\\phi}(\\boldsymbol{k})$ 乘以高斯函数的傅里叶变换。这以滤波器形式给出：\n$$ S(\\boldsymbol{k}, \\sigma) = \\exp\\left(-\\frac{k^2 \\sigma^2}{2}\\right) $$\n因此，平滑场 $\\phi_\\sigma$ 的傅里叶变换是：\n$$ \\widehat{\\phi_\\sigma}(\\boldsymbol{k}) = \\widehat{\\phi}(\\boldsymbol{k}) S(\\boldsymbol{k}, \\sigma) $$\n然后通过应用逆DFT恢复平滑场 $\\phi_\\sigma(\\boldsymbol{x})$。\n\n**b. 微分：**\n傅里叶变换的微分性质指出，偏导数的变换等价于将原始变换乘以相应的虚波数。\n$$ \\mathcal{F}\\left[\\frac{\\partial \\phi}{\\partial x}\\right] = \\mathrm{i}k_x \\widehat{\\phi}(\\boldsymbol{k}), \\quad \\mathcal{F}\\left[\\frac{\\partial \\phi}{\\partial y}\\right] = \\mathrm{i}k_y \\widehat{\\phi}(\\boldsymbol{k}) $$\n二阶导数通过应用此规则两次得到：\n$$ \\mathcal{F}\\left[\\frac{\\partial^2 \\phi}{\\partial x^2}\\right] = (\\mathrm{i}k_x)^2 \\widehat{\\phi}(\\boldsymbol{k}) = -k_x^2 \\widehat{\\phi}(\\boldsymbol{k}) $$\n$$ \\mathcal{F}\\left[\\frac{\\partial^2 \\phi}{\\partial y^2}\\right] = (\\mathrm{i}k_y)^2 \\widehat{\\phi}(\\boldsymbol{k}) = -k_y^2 \\widehat{\\phi}(\\boldsymbol{k}) $$\n$$ \\mathcal{F}\\left[\\frac{\\partial^2 \\phi}{\\partial x \\partial y}\\right] = (\\mathrm{i}k_x)(\\mathrm{i}k_y) \\widehat{\\phi}(\\boldsymbol{k}) = -k_x k_y \\widehat{\\phi}(\\boldsymbol{k}) $$\n为了计算梯度矢量 $\\nabla\\phi = (\\phi_x, \\phi_y)$ 或黑塞张量 $\\nabla\\nabla\\phi$，我们首先计算 $\\phi$ 的DFT，乘以适当的波数因子（例如 $\\mathrm{i}k_x$, $-k_x^2$），然后应用逆DFT返回到实数空间。由于浮点不精确性，得到的场可能含有可忽略的虚部，必须将其丢弃。\n\n**3. 可观测量计算**\n\n该问题要求对原始场 $\\phi$ 和平滑场 $\\phi_\\sigma$ 计算若干量。\n\n**a. RMS值：** 在 $N \\times N$ 网格上，量 $Q$ 的均方根计算如下：\n$$ \\text{RMS}(Q) = \\sqrt{\\frac{1}{N^2} \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} Q(x_j, y_l)^2} $$\n\n**b. 梯度大小：** 梯度的大小是 $\\|\\nabla\\phi\\| = \\sqrt{\\phi_x^2 + \\phi_y^2}$。我们计算其在整个网格上的RMS值。\n\n**c. 黑塞矩阵特征值 (单模测试)：** 在每个网格点上，黑塞矩阵是一个 $2 \\times 2$ 对称矩阵：\n$$ H(\\boldsymbol{x}) = \\begin{pmatrix} \\phi_{xx}(\\boldsymbol{x})  \\phi_{xy}(\\boldsymbol{x}) \\\\ \\phi_{xy}(\\boldsymbol{x})  \\phi_{yy}(\\boldsymbol{x}) \\end{pmatrix} $$\n其特征值由公式 $\\lambda_{\\pm} = \\frac{1}{2}\\left( \\text{Tr}(H) \\pm \\sqrt{(\\text{Tr}(H))^2 - 4\\det(H)} \\right)$ 给出，简化为：\n$$ \\lambda_{\\pm} = \\frac{1}{2}\\left( (\\phi_{xx} + \\phi_{yy}) \\pm \\sqrt{(\\phi_{xx}-\\phi_{yy})^2 + 4\\phi_{xy}^2} \\right) $$\n我们关心的是最小特征值 $\\lambda_{-}$。我们计算最小特征值场，然后计算其RMS值。\n\n**d. 黑塞矩阵弗罗贝尼乌斯范数 (双模测试)：** 黑塞矩阵的弗罗贝尼乌斯范数由下式给出：\n$$ \\|\\nabla\\nabla\\phi\\|_F = \\sqrt{\\phi_{xx}^2 + \\phi_{yy}^2 + 2\\phi_{xy}^2} $$\n我们计算弗罗贝尼乌斯范数场，然后计算其RMS值。\n\n**4. 理论预测与误差计算**\n\n测量的衰减，由RMS值的比率（例如 $\\text{RMS}(\\|\\nabla\\phi_\\sigma\\|)/\\text{RMS}(\\|\\nabla\\phi\\|)$）量化，将与理论预测进行比较。\n\n**a. 单模场：** 对于由单一波数大小 $k_0$ 主导的场，例如 $\\phi(x,y) = A\\cos(2\\pi n_x x)$（其 $k_0 = 2\\pi n_x$），每个微分操作都只是将场的振幅乘以一个与 $k_0$ 相关的因子。平滑引入一个额外的乘法因子 $\\exp(-k_0^2\\sigma^2/2)$。因此，梯度和所有黑塞矩阵分量的振幅都由这个相同的因子衰减。由于RMS与振幅成正比，这些量（梯度大小、黑塞矩阵特征值）中任何一个的RMS值比率预计为：\n$$ R_{\\text{pred}}(\\sigma) = \\exp\\left(-\\frac{k_0^2 \\sigma^2}{2}\\right) $$\n\n**b. 双模场：** 对于模式的叠加，上述简单预测不成立。该问题提供了谱能量加权预测。RMS梯度大小的预测比率为：\n$$ R_{\\mathrm{grad,pred}}(\\sigma) = \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^{2}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}\\, \\exp(-k^{2}\\sigma^{2})}{\\sum_{\\boldsymbol{k}} k^{2}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}}} $$\n该公式用 $k^2$（来自梯度）和平滑因子对每个模式的功率 $|\\widehat{\\phi}(\\boldsymbol{k})|^2$ 的贡献进行加权。分母是未平滑场的总“梯度功率”。类似地，RMS黑塞矩阵弗罗贝尼乌斯范数的预测比率为：\n$$ R_{\\mathrm{H,pred}}(\\sigma) = \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^{4}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}\\, \\exp(-k^{2}\\sigma^{2})}{\\sum_{\\boldsymbol{k}} k^{4}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}}} $$\n$k^4$ 加权因子的出现是因为弗罗贝尼乌斯范数的平方是二阶导数的平方和，而每个二阶导数在傅里叶空间中贡献一个 $k^2$ 因子，导致功率的整体 $k^4$ 缩放。\n\n每个测试的最终输出是测量比率和预测比率之间的相对误差：\n$$ \\text{相对误差} = \\frac{|\\text{测量比率} - \\text{预测比率}|}{|\\text{预测比率}|} $$\n\n这个系统化的过程将对所有四个测试用例实施，以获得所需的八个输出值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Fourier-space smoothing and differentiation.\n    \"\"\"\n\n    def compute_derivatives(phi_hat, kx, ky):\n        \"\"\"Computes gradient and Hessian components in real space from a Fourier-space field.\"\"\"\n        # Gradient components\n        phi_x_hat = 1j * kx * phi_hat\n        phi_y_hat = 1j * ky * phi_hat\n        phi_x = np.fft.ifftn(phi_x_hat).real\n        phi_y = np.fft.ifftn(phi_y_hat).real\n\n        # Hessian components\n        phi_xx_hat = -kx**2 * phi_hat\n        phi_yy_hat = -ky**2 * phi_hat\n        phi_xy_hat = -kx * ky * phi_hat\n        phi_xx = np.fft.ifftn(phi_xx_hat).real\n        phi_yy = np.fft.ifftn(phi_yy_hat).real\n        phi_xy = np.fft.ifftn(phi_xy_hat).real\n        \n        return phi_x, phi_y, phi_xx, phi_yy, phi_xy\n\n    def get_rms(field):\n        \"\"\"Computes the root-mean-square of a 2D field.\"\"\"\n        return np.sqrt(np.mean(field**2))\n\n    def run_analysis(phi, sigma, kx, ky, k_sq, test_type, phi_hat=None):\n        \"\"\"\n        Performs the core analysis for a given field and smoothing parameter.\n        `test_type` can be 'single_mode' or 'two_mode'.\n        \"\"\"\n        N, _ = phi.shape\n        \n        # --- Unsmoothed Field Analysis ---\n        if phi_hat is None:\n            phi_hat = np.fft.fftn(phi)\n        \n        phi_x, phi_y, phi_xx, phi_yy, phi_xy = compute_derivatives(phi_hat, kx, ky)\n\n        # --- Smoothed Field Analysis ---\n        smoothing_kernel = np.exp(-k_sq * sigma**2 / 2.0)\n        phi_sigma_hat = phi_hat * smoothing_kernel\n        \n        phi_sigma_x, phi_sigma_y, phi_sigma_xx, phi_sigma_yy, phi_sigma_xy = \\\n            compute_derivatives(phi_sigma_hat, kx, ky)\n\n        # --- Compute Ratios ---\n        # Gradient RMS ratio\n        grad_mag = np.sqrt(phi_x**2 + phi_y**2)\n        grad_mag_sigma = np.sqrt(phi_sigma_x**2 + phi_sigma_y**2)\n        measured_ratio_grad = get_rms(grad_mag_sigma) / get_rms(grad_mag) if get_rms(grad_mag) != 0 else 0\n\n        # Hessian ratio (depends on test type)\n        if test_type == 'single_mode':\n            # Minimum eigenvalue of Hessian\n            trace = phi_xx + phi_yy\n            discriminant = np.sqrt(np.maximum(0, (phi_xx - phi_yy)**2 + 4 * phi_xy**2))\n            min_eig = 0.5 * (trace - discriminant)\n\n            trace_sigma = phi_sigma_xx + phi_sigma_yy\n            discriminant_sigma = np.sqrt(np.maximum(0, (phi_sigma_xx - phi_sigma_yy)**2 + 4 * phi_sigma_xy**2))\n            min_eig_sigma = 0.5 * (trace_sigma - discriminant_sigma)\n\n            measured_ratio_hess = get_rms(min_eig_sigma) / get_rms(min_eig) if get_rms(min_eig) != 0 else 0\n            \n        elif test_type == 'two_mode':\n            # Frobenius norm of Hessian\n            frob_norm = np.sqrt(phi_xx**2 + 2 * phi_xy**2 + phi_yy**2)\n            frob_norm_sigma = np.sqrt(phi_sigma_xx**2 + 2 * phi_sigma_xy**2 + phi_sigma_yy**2)\n            measured_ratio_hess = get_rms(frob_norm_sigma) / get_rms(frob_norm) if get_rms(frob_norm) != 0 else 0\n\n        return measured_ratio_grad, measured_ratio_hess, phi_hat\n\n\n    # --- Simulation Parameters ---\n    N = 64\n    L = 1.0\n\n    # --- Grid and Wavenumber Setup ---\n    grid_coords = np.linspace(0, L, N, endpoint=False)\n    xx, yy = np.meshgrid(grid_coords, grid_coords, indexing='ij')\n\n    k_freq = np.fft.fftfreq(N, d=L / N)\n    kx_base = 2 * np.pi * k_freq\n    ky_base = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(kx_base, ky_base, indexing='ij')\n    k_sq = kx**2 + ky**2\n\n    # --- Test Suite ---\n    test_cases = [\n        # Test 1: single mode, baseline attenuation\n        {'type': 'single_mode', 'A': 1.0, 'nx': 4, 'sigma': 0.05},\n        # Test 2: identity smoothing\n        {'type': 'single_mode', 'A': 1.0, 'nx': 4, 'sigma': 0.0},\n        # Test 3: higher frequency\n        {'type': 'single_mode', 'A': 1.0, 'nx': 8, 'sigma': 0.12},\n        # Test 4: two-mode superposition\n        {'type': 'two_mode', 'A1': 1.0, 'n1': 3, 'A2': 0.8, 'n2': 5, 'sigma': 0.07}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Construct the field\n        if case['type'] == 'single_mode':\n            phi = case['A'] * np.cos(2 * np.pi * case['nx'] * xx)\n        else: # two_mode\n            phi = case['A1'] * np.cos(2 * np.pi * case['n1'] * xx) + \\\n                  case['A2'] * np.cos(2 * np.pi * case['n2'] * yy)\n        \n        # Run analysis\n        measured_grad_ratio, measured_hess_ratio, phi_hat = run_analysis(\n            phi, case['sigma'], kx, ky, k_sq, case['type']\n        )\n\n        # Compute predictions and relative errors\n        if case['type'] == 'single_mode':\n            sigma = case['sigma']\n            if sigma == 0.0:\n                pred_ratio_grad = 1.0\n                pred_ratio_hess = 1.0\n            else:\n                k0 = 2 * np.pi * case['nx']\n                pred_ratio = np.exp(-k0**2 * sigma**2 / 2.0)\n                pred_ratio_grad = pred_ratio\n                pred_ratio_hess = pred_ratio\n        else: # two_mode\n            sigma = case['sigma']\n            power_spectrum = np.abs(phi_hat)**2\n            \n            # Grad prediction\n            grad_numerator = np.sum(k_sq * power_spectrum * np.exp(-k_sq * sigma**2))\n            grad_denominator = np.sum(k_sq * power_spectrum)\n            pred_ratio_grad = np.sqrt(grad_numerator / grad_denominator) if grad_denominator != 0 else 0\n\n            # Hessian prediction\n            hess_numerator = np.sum(k_sq**2 * power_spectrum * np.exp(-k_sq * sigma**2))\n            hess_denominator = np.sum(k_sq**2 * power_spectrum)\n            pred_ratio_hess = np.sqrt(hess_numerator / hess_denominator) if hess_denominator != 0 else 0\n\n        # Relative errors\n        rel_err_grad = np.abs(measured_grad_ratio - pred_ratio_grad) / pred_ratio_grad\n        rel_err_hess = np.abs(measured_hess_ratio - pred_ratio_hess) / pred_ratio_hess\n        \n        results.extend([rel_err_grad, rel_err_hess])\n\n    # Final print statement\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3502022"}, {"introduction": "宇宙结构横跨广泛的尺度范围，因此单一的分析尺度可能会遗漏或错误识别结构。本练习将深入探讨多尺度网络分类的核心理论（例如在NEXUS+算法中使用的理论）。通过分析一个理想化的纤维状结构，你将推导出一个尺度归一化响应函数的信噪比如何在其内在尺寸相关的尺度上达到峰值，从而证明多尺度融合方法的必要性。[@problem_id:3502092]", "problem": "考虑一个在三维（3D）域上定义的宇宙学物质密度对比度场 $\\delta(\\mathbf{x})$。定义对数密度场 $u(\\mathbf{x}) = \\ln(1 + \\delta(\\mathbf{x}))$。对于高斯尺度空间表示，令 $G_s(\\mathbf{x})$ 表示一个宽度（标准差）为 $s$ 的归一化各向同性高斯核，并定义平滑场 $u(\\mathbf{x}; s) = \\big(G_s * u\\big)(\\mathbf{x})$。对于每个尺度 $s$，定义梯度 $\\mathbf{g}(\\mathbf{x}; s) = \\nabla u(\\mathbf{x}; s)$ 和海森矩阵 $H(\\mathbf{x}; s) = \\nabla\\nabla u(\\mathbf{x}; s)$，其特征值为 $\\lambda_1(\\mathbf{x}; s) \\ge \\lambda_2(\\mathbf{x}; s) \\ge \\lambda_3(\\mathbf{x}; s)$，并有相应的标准正交特征向量。在采用高斯核的尺度空间理论中，尺度归一化的 n 阶导数是通过将原始 n 阶导数乘以 $s^n$ 来获得的，以补偿特征随尺度 $s$ 的稀释效应。\n\n像 NEXUS+ 这样的多尺度宇宙网分类器在每个尺度 $s$ 上考虑一个由 $\\lambda_i(\\mathbf{x}; s)$ 以及可能由 $\\mathbf{g}(\\mathbf{x}; s)$ 构建的形态特定响应函数，然后在不同尺度间融合信息。为了尺度选择的目的，纤维状结构可以被理想化为各向异性的高斯脊。考虑以下解析测试案例\n$$\nu(\\mathbf{x}) = u_0 \\exp\\left(-\\frac{x^2 + y^2}{2 R^2}\\right)\\exp\\left(-\\frac{z^2}{2 L^2}\\right),\n$$\n其中 $L \\gg R$，$R$ 表征纤维在横向 $\\{x,y\\}$ 方向上的半宽，而 $L$ 是其沿 $z$ 轴的延伸范围。$u(\\mathbf{x})$ 与 $G_s(\\mathbf{x})$ 的卷积产生另一个各向异性高斯函数，其方差在横向方向上更新为 $R^2 + s^2$，沿 $z$ 轴方向更新为 $L^2 + s^2$，且中心振幅减小（这是尺度空间分析中一个经过充分验证的事实）：在 $\\mathbf{x}=\\mathbf{0}$ 处，\n$$\nu(\\mathbf{0}; s) = u_0 \\left(\\frac{R^2}{R^2 + s^2}\\right)\\left(\\frac{L^2}{L^2 + s^2}\\right)^{1/2}.\n$$\n计算在纤维中心 $\\mathbf{x}=\\mathbf{0}$ 处 $u(\\mathbf{x}; s)$ 的海森矩阵特征值，并使用两个最压缩（负）的特征值的乘积来定义一个尺度归一化的纤维响应 $R_{\\mathrm{fil}}(s)$，以捕捉两个高曲率的横向方向，例如\n$$\nR_{\\mathrm{fil}}(s) = s^2 \\,[\\lambda_2(\\mathbf{0}; s)\\,\\lambda_3(\\mathbf{0}; s)]\\,\\Theta(-\\lambda_2(\\mathbf{0}; s))\\,\\Theta(-\\lambda_3(\\mathbf{0}; s)),\n$$\n其中 $\\Theta(\\cdot)$ 是亥维赛阶跃函数，确保只有压缩曲率有贡献。假设 $L \\gg R$，因此 $\\lambda_1(\\mathbf{0}; s)$（沿 $z$ 轴方向）的量级远小于横向特征值。此外，将背景建模为功率谱为常数 $P_0$ 的平稳高斯白噪声，并使用傅里叶空间推理来确定尺度归一化海森分量的方差如何随 $s$ 变化。\n\n使用这些要素，并从上述关于高斯尺度空间和导数归一化的基本定义和事实出发，推导：\n\n- 在 $\\mathbf{x}=\\mathbf{0}$ 处，$R_{\\mathrm{fil}}(s)$ 对 $R$、$L$、$u_0$ 和 $s$ 的参数依赖性；\n- 尺度归一化海森矩阵的噪声方差随 $s$ 的标度关系；\n- 由此产生的信噪比（Signal-to-Noise Ratio, SNR）作为 $s$ 的函数的定性行为，以及预期的最优尺度 $s_\\star$ 相对于 $R$ 的关系。\n\n在此基础上，选择最准确描述 NEXUS+ 如何融合多尺度密度和导数（梯度/海森矩阵）信息以加强特征检测，以及为何这种方法优于单尺度滤波的选项。\n\nA. NEXUS+ 在每个尺度 $s$ 上计算对数密度 $u(\\mathbf{x}; s)$ 的海森矩阵，从适当的特征值组合（例如，对于纤维，使用两个最负特征值的乘积）形成一个尺度归一化的形态强度，可选择性地使用相关的特征向量来编码方向，并通过取这些强度在所有尺度 $s$ 上的逐点最大值来融合尺度。这起到了尺度选择器的作用，选择信噪比达到峰值的 $s \\approx R$；相对于单尺度滤波，多尺度融合在控制噪声的同时，增加了对异构尺寸特征场的检测概率。\n\nB. NEXUS+ 对所有尺度 $s$ 上的原始密度 $u(\\mathbf{x}; s)$ 进行平均以增强信号，然后在固定尺度 $s$ 下选择梯度幅度 $\\|\\mathbf{g}(\\mathbf{x}; s)\\|$ 最大的位置作为纤维，声称平均和梯度峰值能统一改善所有尺度上的检测。\n\nC. NEXUS+ 在单个预定尺度 $s^\\ast$ 下通过拉普拉斯算子 $\\nabla^2 u(\\mathbf{x}; s^\\ast)$ 的符号来确定结构类型，并通过降低检测阈值来引入多尺度敏感性，这之所以足够是因为对数变换已经抑制了动态范围偏差。\n\nD. NEXUS+ 依赖于在单个母小波尺度下对原始密度对比度 $\\delta(\\mathbf{x})$ 进行的小波硬阈值处理，并通过与暗晕星表交叉匹配来精炼输出，这使得导数信息对于纤维检测变得不必要，因为暗晕追踪了宇宙网。", "solution": "用户要求对问题陈述进行严格验证，然后进行完整推导并评估所提供的选项。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   **场与变换：**\n    -   密度对比度场：3D 空间中的 $\\delta(\\mathbf{x})$。\n    -   对数密度场：$u(\\mathbf{x}) = \\ln(1 + \\delta(\\mathbf{x}))$。\n    -   高斯核：标准差为 $s$ 的 $G_s(\\mathbf{x})$。\n    -   平滑场：$u(\\mathbf{x}; s) = (G_s * u)(\\mathbf{x})$。\n-   **导数与特征值：**\n    -   梯度：$\\mathbf{g}(\\mathbf{x}; s) = \\nabla u(\\mathbf{x}; s)$。\n    -   海森矩阵：$H(\\mathbf{x}; s) = \\nabla\\nabla u(\\mathbf{x}; s)$。\n    -   海森矩阵特征值：$\\lambda_1(\\mathbf{x}; s) \\ge \\lambda_2(\\mathbf{x}; s) \\ge \\lambda_3(\\mathbf{x}; s)$。\n-   **尺度空间概念：**\n    -   n 阶导数的尺度归一化：乘以 $s^n$。\n    -   NEXUS+ 中的多尺度融合：结合跨尺度 $s$ 的形态特定响应。\n-   **纤维测试案例：**\n    -   解析形式：$u(\\mathbf{x}) = u_0 \\exp\\left(-\\frac{x^2 + y^2}{2 R^2}\\right)\\exp\\left(-\\frac{z^2}{2 L^2}\\right)$，其中 $L \\gg R$。\n    -   中心处的平滑场：$u(\\mathbf{0}; s) = u_0 \\left(\\frac{R^2}{R^2 + s^2}\\right)\\left(\\frac{L^2}{L^2 + s^2}\\right)^{1/2}$。\n    -   平滑场 $u(\\mathbf{x}; s)$ 是一个各向异性高斯函数，其方差为 $R^2+s^2$（横向）和 $L^2+s^2$（纵向）。\n-   **纤维响应函数定义：**\n    -   $R_{\\mathrm{fil}}(s) = s^2 \\,[\\lambda_2(\\mathbf{0}; s)\\,\\lambda_3(\\mathbf{0}; s)]\\,\\Theta(-\\lambda_2(\\mathbf{0}; s))\\,\\Theta(-\\lambda_3(\\mathbf{0}; s))$。\n-   **噪声模型：**\n    -   功率谱为常数 $P_0$ 的平稳高斯白噪声。\n-   **任务：**\n    1.  推导 $R_{\\mathrm{fil}}(s)$ 的参数依赖性。\n    2.  推导尺度归一化海森矩阵的噪声方差随 $s$ 的标度关系。\n    3.  推导信噪比 (SNR) 的定性行为和最优尺度 $s_\\star$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据：** 该问题在计算宇宙学和尺度空间理论方面有坚实的科学基础。使用对数密度、高斯平滑以及海森矩阵进行宇宙网分类（T-web 或 NEXUS 方法）是标准且有据可查的技术。对纤维的解析模型是一种常见且适当的理想化处理。噪声模型和傅里叶分析是性能评估的标准工具。该问题没有违反任何科学原理。\n-   **良定性：** 该问题是良定的。它提供了执行所需推导的所有必要定义、方程和约束。所提出的问题能够导出一个基于所提供框架的唯一且有意义的解。\n-   **客观性：** 语言精确、数学化，没有主观或模糊的术语。\n\n**步骤 3：结论与行动**\n\n问题陈述有效。这是一个形式良好、准确代表了一类宇宙网搜寻算法理论基础的问题。可以开始求解过程。\n\n### 推导\n\n#### 1. $R_{\\mathrm{fil}}(s)$ 的参数依赖性\n\n平滑场 $u(\\mathbf{x}; s)$ 是两个高斯函数卷积的结果。其函数形式为：\n$$ u(\\mathbf{x}; s) = u(\\mathbf{0}; s) \\exp\\left(-\\frac{x^2+y^2}{2(R^2+s^2)} - \\frac{z^2}{2(L^2+s^2)}\\right) $$\n为了找到在原点 $\\mathbf{x}=\\mathbf{0}$ 处的海森矩阵特征值，我们计算该点的二阶偏导数。\n由于函数的偶对称性，在 $\\mathbf{x}=\\mathbf{0}$ 处，海森矩阵的非对角元素 $H_{ij} = \\frac{\\partial^2 u}{\\partial x_i \\partial x_j}$（$i \\ne j$）均为零。\n对角元素为：\n$$ H_{xx}(\\mathbf{0}; s) = \\left. \\frac{\\partial^2 u(\\mathbf{x}; s)}{\\partial x^2} \\right|_{\\mathbf{x}=\\mathbf{0}} = u(\\mathbf{0}; s) \\left( -\\frac{1}{R^2+s^2} \\right) $$\n根据对称性，$H_{yy}(\\mathbf{0}; s) = H_{xx}(\\mathbf{0}; s)$。\n$$ H_{zz}(\\mathbf{0}; s) = \\left. \\frac{\\partial^2 u(\\mathbf{x}; s)}{\\partial z^2} \\right|_{\\mathbf{x}=\\mathbf{0}} = u(\\mathbf{0}; s) \\left( -\\frac{1}{L^2+s^2} \\right) $$\n由于海森矩阵在原点处是对角的，其特征值即为对角线元素。假设为超密结构（$u_0  0$），这些特征值为负。问题陈述 $L \\gg R$，这意味着 $L^2+s^2 > R^2+s^2$，因此 $\\frac{1}{L^2+s^2}  \\frac{1}{R^2+s^2}$。这意味着 $|H_{zz}|  |H_{xx}|$。\n按 $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$ 排序的特征值为：\n$$ \\lambda_1(\\mathbf{0}; s) = -\\frac{u(\\mathbf{0}; s)}{L^2+s^2} $$\n$$ \\lambda_2(\\mathbf{0}; s) = \\lambda_3(\\mathbf{0}; s) = -\\frac{u(\\mathbf{0}; s)}{R^2+s^2} $$\n特征值 $\\lambda_2$ 和 $\\lambda_3$ 对应于纤维的两个高曲率横向方向。因为当 $u_0  0$ 时它们为负，亥维赛函数 $\\Theta(-\\lambda_i)$ 等于 $1$。\n纤维响应函数为：\n$$ R_{\\mathrm{fil}}(s) = s^2 \\,[\\lambda_2(\\mathbf{0}; s)\\,\\lambda_3(\\mathbf{0}; s)] = s^2 \\left( -\\frac{u(\\mathbf{0}; s)}{R^2+s^2} \\right)^2 = \\frac{s^2 [u(\\mathbf{0}; s)]^2}{(R^2+s^2)^2} $$\n代入给定的 $u(\\mathbf{0}; s)$ 表达式：\n$$ [u(\\mathbf{0}; s)]^2 = u_0^2 \\left(\\frac{R^2}{R^2 + s^2}\\right)^2 \\left(\\frac{L^2}{L^2 + s^2}\\right) $$\n因此，$R_{\\mathrm{fil}}(s)$ 的参数依赖性为：\n$$ R_{\\mathrm{fil}}(s) = \\frac{s^2}{(R^2+s^2)^2} \\left[ u_0^2 \\frac{R^4}{(R^2+s^2)^2} \\frac{L^2}{L^2+s^2} \\right] = \\frac{u_0^2 R^4 L^2 s^2}{(R^2+s^2)^4 (L^2+s^2)} $$\n\n#### 2. 尺度归一化海森矩阵的噪声方差的标度关系\n\n设噪声场为 $n(\\mathbf{x})$，是功率谱为 $P_n(k) = P_0$ 的高斯白噪声。平滑后的噪声场为 $n(\\mathbf{x}; s) = (G_s * n)(\\mathbf{x})$。\n在傅里叶空间中，$\\tilde{n}(\\mathbf{k}; s) = \\tilde{G}_s(\\mathbf{k}) \\tilde{n}(\\mathbf{k})$，其中 $\\tilde{G}_s(\\mathbf{k}) = \\exp(-\\frac{1}{2}s^2 k^2)$。\n噪声场的海森矩阵的 $(i,j)$ 分量为 $H_{ij}^{(n)} = \\frac{\\partial^2 n(\\mathbf{x}; s)}{\\partial x_i \\partial x_j}$。在傅里叶空间中，此操作对应于乘以 $(-k_i k_j)$。\n$$ \\tilde{H}_{ij}^{(n)}(\\mathbf{k}; s) = -k_i k_j \\tilde{G}_s(\\mathbf{k}) \\tilde{n}(\\mathbf{k}) $$\n该分量的功率谱为：\n$$ P_{H_{ij}^{(n)}}(\\mathbf{k}; s) = \\langle |\\tilde{H}_{ij}^{(n)}(\\mathbf{k}; s)|^2 \\rangle = (k_i k_j)^2 |\\tilde{G}_s(\\mathbf{k})|^2 \\langle |\\tilde{n}(\\mathbf{k})|^2 \\rangle = (k_i k_j)^2 \\exp(-s^2 k^2) P_0 $$\n$H_{ij}^{(n)}$ 在任意点 $\\mathbf{x}$ 的方差是其功率谱的积分：\n$$ \\mathrm{Var}[H_{ij}^{(n)}] = \\int \\frac{d^3k}{(2\\pi)^3} P_{H_{ij}^{(n)}}(\\mathbf{k}; s) = P_0 \\int \\frac{d^3k}{(2\\pi)^3} (k_i k_j)^2 e^{-s^2 k^2} $$\n进行变量替换 $\\mathbf{q} = s\\mathbf{k}$，则 $\\mathbf{k} = \\mathbf{q}/s$ 且 $d^3k = s^{-3}d^3q$。\n$$ \\mathrm{Var}[H_{ij}^{(n)}] = P_0 \\int \\frac{s^{-3} d^3q}{(2\\pi)^3} \\left(\\frac{q_i}{s} \\frac{q_j}{s}\\right)^2 e^{-q^2} = P_0 s^{-3} s^{-4} \\int \\frac{d^3q}{(2\\pi)^3} (q_i q_j)^2 e^{-q^2} $$\n该积分为一个常数，因此 $\\mathrm{Var}[H_{ij}^{(n)}] \\propto s^{-7}$。\n问题要求的是*尺度归一化*海森矩阵的方差，即 $s^2 H_{ij}^{(n)}$。\n$$ \\mathrm{Var}[s^2 H_{ij}^{(n)}] = s^4 \\mathrm{Var}[H_{ij}^{(n)}] \\propto s^4 s^{-7} = s^{-3} $$\n尺度归一化海森分量的方差随 $s$ 的变化关系为 $s^{-3}$。\n\n#### 3. 信噪比的定性行为和最优尺度 $s_\\star$\n\n检测过程的信噪比可以建模为信号响应与噪声水平的比值。我们使用尺度归一化的特征值大小作为信号，$S(s) = s^2|\\lambda_3(\\mathbf{0}; s)|$，并使用相应噪声分量的标准差作为噪声，$N(s) = \\sqrt{\\mathrm{Var}[s^2 H_{33}^{(n)}]}}$。\n\n信号项：\n$$ S(s) = s^2|\\lambda_3| = s^2 \\frac{u(\\mathbf{0}; s)}{R^2+s^2} = s^2 \\frac{1}{R^2+s^2} \\left( u_0 \\frac{R^2}{R^2+s^2} \\left(\\frac{L^2}{L^2+s^2}\\right)^{1/2} \\right) $$\n对于 $s \\sim R \\ll L$，因子 $(L^2/(L^2+s^2))^{1/2} \\approx 1$。\n$$ S(s) \\approx u_0 R^2 \\frac{s^2}{(R^2+s^2)^2} $$\n该信号函数 $S(s)$ 在 $s \\to 0$ 时趋近于 $0$（如 $s^2$），在 $s \\to \\infty$ 时也趋近于 $0$（如 $s^{-2}$）。因此它有一个峰值。对 $s$ 求导并令其为零，可得 $(R^2+s^2) - 2s^2 = 0$，解得 $s^2=R^2$，即 $s=R$。对于尺寸为 $R$ 的特征，其尺度归一化信号在平滑尺度 $s=R$ 时最大化。\n\n噪声项：\n从推导 2 可知，噪声方差为 $\\mathrm{Var}[s^2 H_{ij}^{(n)}] \\propto s^{-3}$。噪声标准差为：\n$$ N(s) \\propto \\sqrt{s^{-3}} = s^{-3/2} $$\n随着平滑尺度 $s$ 的增加，噪声水平单调下降。\n\n信噪比 (SNR)：\n$$ \\mathrm{SNR}(s) = \\frac{S(s)}{N(s)} \\propto \\frac{s^2 / (R^2+s^2)^2}{s^{-3/2}} = \\frac{s^{7/2}}{(R^2+s^2)^2} $$\n此函数也有一个峰值。对于 $s \\ll R$，$\\mathrm{SNR}(s) \\propto s^{7/2}$。对于 $s \\gg R$，$\\mathrm{SNR}(s) \\propto s^{7/2}/s^4 = s^{-1/2}$。为求最大值，将其导数设为零，得到 $\\frac{7}{2}(R^2+s^2) - 4s^2 = 0$，简化为 $s^2 = \\frac{7}{3}R^2$，因此 $s_\\star = \\sqrt{7/3} R \\approx 1.53 R$。\n\n关键的定性结论是，对于一个内在尺寸为 $R$ 的特征，使用尺度归一化导数进行检测的信噪比在一个与 $R$ 成正比的最优尺度 $s_\\star$ 处达到最大值。真实的密度场包含具有广泛尺寸谱的结构。因此，单尺度滤波器是次优的。一个在所有尺度上计算响应并将其融合（例如，通过取逐点最大值）的多尺度算法，可以对这个谱系中的各种特征实现近乎最优的检测。\n\n### 逐项分析选项\n\n**A. NEXUS+ 在每个尺度 $s$ 上计算对数密度 $u(\\mathbf{x}; s)$ 的海森矩阵，从适当的特征值组合（例如，对于纤维，使用两个最负特征值的乘积）形成一个尺度归一化的形态强度，可选择性地使用相关的特征向量来编码方向，并通过取这些强度在所有尺度 $s$ 上的逐点最大值来融合尺度。这起到了尺度选择器的作用，选择信噪比达到峰值的 $s \\approx R$；相对于单尺度滤波，多尺度融合在控制噪声的同时，增加了对异构尺寸特征场的检测概率。**\n-   此选项正确描述了过程的每个阶段：在多个尺度上使用对数密度的海森矩阵；从特征值形成尺度归一化的响应；通过取最大响应来融合尺度；以及其背后的原理。其原理，即此过程选择信噪比达到峰值的最优尺度 $s \\approx R$，从而对具有不同尺寸特征的场改进了单尺度方法的检测效果，这正是推导所证明的。\n-   **结论：正确。**\n\n**B. NEXUS+ 对所有尺度 $s$ 上的原始密度 $u(\\mathbf{x}; s)$ 进行平均以增强信号，然后在固定尺度 $s$ 下选择梯度幅度 $\\|\\mathbf{g}(\\mathbf{x}; s)\\|$ 最大的位置作为纤维，声称平均和梯度峰值能统一改善所有尺度上的检测。**\n-   这个描述从根本上是错误的。NEXUS+ 是一种基于海森矩阵的方法，而不是基于梯度的。梯度幅度的峰值识别的是与海森矩阵特征值不同的特征（例如，边界）。它不是对场 $u(\\mathbf{x}; s)$ 进行跨尺度平均，而是融合一个派生出的*响应函数*。最后，提及*固定 s* 与多尺度融合原则相矛盾。\n-   **结论：不正确。**\n\n**C. NEXUS+ 在单个预定尺度 $s^\\ast$ 下通过拉普拉斯算子 $\\nabla^2 u(\\mathbf{x}; s^\\ast)$ 的符号来确定结构类型，并通过降低检测阈值来引入多尺度敏感性，这之所以足够是因为对数变换已经抑制了动态范围偏差。**\n-   这是不正确的。拉普拉斯算子（$\\nabla^2 u = \\lambda_1+\\lambda_2+\\lambda_3$）不足以区分形态（例如，一个符号为 $(-, -, +)$ 的纤维和一个符号为 $(-, +, +)$ 的片状结构可能具有相同符号的拉普拉斯算子）。需要完整的特征值集合。它错误地声称使用了*单个预定尺度*，这与 NEXUS+ 多尺度方法的理念背道而驰。降低阈值并不是实现多尺度敏感性的正确方法。\n-   **结论：不正确。**\n\n**D. NEXUS+ 依赖于在单个母小波尺度下对原始密度对比度 $\\delta(\\mathbf{x})$ 进行的小波硬阈值处理，并通过与暗晕星表交叉匹配来精炼输出，这使得导数信息对于纤维检测变得不必要，因为暗晕追踪了宇宙网。**\n-   此选项将 NEXUS+ 算法与一种完全不同的方法（小波阈值处理）相混淆。NEXUS+ 基于高斯尺度空间和微分几何（海森矩阵），而非小波。它还错误地指出导数信息是不必要的，而实际上这正是该方法的核心。声称暗晕完美追踪了宇宙网以至于场分析变得多余，也是一种严重的过度简化。\n-   **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3502092"}, {"introduction": "寻找宇宙空洞的算法大致可分为拉格朗日方法和欧拉方法，每种方法都为宇宙的低密度区域提供了独特的视角。这个综合性练习将要求你实现并比较两种代表性算法：基于拉格朗日壳层穿越的ORIGAMI，以及作用于欧拉密度场的“分水岭”算法。通过这个练习，你将对这两大类空洞寻找算法的实际差异和概念基础有更深刻的理解。[@problem_id:3502019]", "problem": "给定一个合成的三维粒子分布，它代表了边长为 $L$ 的周期性立方体盒子中某个时刻的 N 体快照。初始粒子构型是 $N^3$ 个粒子的均匀拉格朗日格点，其位置为 $\\mathbf{q} \\in [0,L)^3$。欧拉位置 $\\mathbf{x}$ 是通过一阶拉格朗日微扰（泽尔多维奇近似）得到的，即 $\\mathbf{x}(\\mathbf{q}) = \\mathbf{q} + \\mathbf{s}(\\mathbf{q})$，其中位移场 $\\mathbf{s}(\\mathbf{q}) = -D \\nabla \\phi(\\mathbf{q})$ 来自一个由尺度为 $R_s$ 的高斯核平滑的随机高斯势 $\\phi$。假设在所有时刻都采用周期性边界条件。\n\n您的任务是从第一性原理出发，实现并比较两种寻找空洞的方法：\n\n1. 使用 Order-ReversIng Galaxy Morphology Identification (ORIGAMI) 进行拉格朗日空洞分类，定义如下。对于每个主轴 $\\alpha \\in \\{x,y,z\\}$，考虑在固定的正交坐标上平行于 $\\alpha$ 的一维粒子线。如果一条线上的粒子按其初始拉格朗日坐标沿 $\\alpha$ 轴排序时，其欧拉坐标沿 $\\alpha$ 轴的序列不是严格递增的，则称该粒子沿 $\\alpha$ 轴发生了壳层穿越。在本问题中，通过在每条线上寻找欧拉坐标的离散差为负的相邻粒子对来检测沿 $\\alpha$ 轴的壳层穿越。如果一个粒子在所有三个轴上检测到的壳层穿越次数为零，则将其分类为拉格朗日空洞粒子。拉格朗日空洞分数是指被分类为空洞粒子的比例（在 $[0,1]$ 范围内的无量纲小数）。\n\n2. 在通过网格质点（CIC）质量分配得到的密度场上计算欧拉分水岭空洞体积。通过使用 CIC 权重沉积粒子质量，在 $N^3$ 网格上构建欧拉密度 $\\rho(\\mathbf{x})$。定义密度对比度 $\\delta(\\mathbf{x}) = \\rho(\\mathbf{x})/\\bar{\\rho} - 1$，其中 $\\bar{\\rho}$ 是平均密度。在周期性边界条件下，使用六邻域（面相邻）比较来识别 $\\rho$ 的局部极小值。通过最速下降法将每个网格单元分配到一个盆地，从而执行离散分水岭分割：如果六个面相邻邻居中有密度严格更低的邻居，则从每个单元迭代地移动到该密度最低的邻居；如果没有严格更低的邻居存在，则该单元格是汇点（局部极小值或平台极小值）。用其汇点单元格的索引来标记盆地。将欧拉分水岭空洞体积分数定义为那些盆地汇点密度对比度 $\\delta_{\\mathrm{sink}}$ 小于指定阈值 $\\delta_v$ （无量纲小数）的网格单元的比例，即由足够低密度的极小值点生成的盆地。\n\n您必须使用的基本基础和假设是：\n\n- 一阶拉格朗日微扰（泽尔多维奇近似）：$\\mathbf{x}(\\mathbf{q}) = \\mathbf{q} - D \\nabla \\phi(\\mathbf{q})$，其中 $D$ 是某个标量增长幅度。\n- 立方体域上的周期性边界条件。\n- 质量守恒和网格质点（CIC）沉积：每个等质量粒子根据其在网格单元内的分数偏移，以三线性权重对其周围的八个网格顶点产生贡献。\n- 密度对比度的定义：$\\delta(\\mathbf{x}) = \\rho(\\mathbf{x})/\\bar{\\rho} - 1$。\n\n您必须通过生成一个实空间高斯随机场，并应用尺度为 $R_s$ 的傅里叶空间高斯平滑来产生高斯势 $\\phi$。位移幅度由一个参数 $A$ 设定，该参数乘以平滑后势场的梯度，即 $\\mathbf{s} = -A \\nabla \\phi$。使用周期性傅里叶波数 $\\mathbf{k} = (k_x,k_y,k_z)$，其中 $k_\\alpha = 2\\pi n_\\alpha / L$，整数 $n_\\alpha$ 与 $N^3$ 网格上的离散傅里叶变换一致。\n\n实现细节和约束：\n\n- 在生成 $\\phi$ 时，为每个测试用例使用可复现的随机数种子。\n- 通过将粒子位置沿每个轴环绕到 $[0,L)$ 区间内来强制执行周期性边界条件。\n- 对于沿每个轴的 ORIGAMI 壳层穿越检测，沿格点逐行操作，并标记任何欧拉坐标沿该轴的差为负的相邻对中的两个粒子。对每个粒子，计算至少检测到一个相邻对反转的轴的数量；拉格朗日空洞粒子的该计数为零。\n- 对于分水岭算法，使用六个面相邻邻居。如果场是完全平坦的，以至于不存在严格的极小值，则将任何没有严格更低邻居的单元格视为汇点（平台极小值），并依此进行处理。\n\n您的程序必须处理以下测试套件，其中 $N$ 是每个维度的网格分辨率，$L$ 是盒子大小（单位为共动 $h^{-1}\\,\\mathrm{Mpc}$；不应打印单位），$A$ 是位移幅度，$R_s$ 是与 $L$ 具有相同物理单位的高斯平滑尺度，$\\delta_v$ 是汇点密度对比度的分水岭空洞阈值，$\\mathrm{seed}$ 是伪随机种子：\n\n- 测试用例 1 (理想情况，弱非线性): $(N,L,A,R_s,\\delta_v,\\mathrm{seed}) = (16,100.0,0.5,5.0,-0.5,42)$。\n- 测试用例 2 (中等非线性): $(16,100.0,1.5,3.0,-0.3,123)$。\n- 测试用例 3 (较强非线性): $(16,100.0,3.0,2.0,0.0,7)$。\n- 测试用例 4 (边缘阈值高，小网格): $(8,100.0,0.1,2.0,0.5,31415)$。\n\n对于每个测试用例，计算并返回三个量：\n\n- 拉格朗日空洞分数 $f_{\\mathrm{L}}$（小数）。\n- 欧拉分水岭空洞体积分数 $f_{\\mathrm{E}}$（小数）。\n- 绝对失配 $m = |f_{\\mathrm{E}} - f_{\\mathrm{L}}|$（小数）。\n\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个测试用例一个，每个内部列表按 $[f_{\\mathrm{L}},f_{\\mathrm{E}},m]$ 排序，并表示为十进制浮点数。例如，一个有效的输出格式类似于 `[[0.9,0.6,0.3],[...],...]`。不应打印其他任何文本。\n\n注意：所有要求的量都是无量纲小数。不使用角度。百分比必须表示为小数，而不是使用百分号。", "solution": "该问题要求在一个合成的宇宙学粒子分布上，实现并比较两种不同的空洞寻找算法。粒子位置是使用泽尔多维奇近似（一个一阶拉格朗日微扰理论模型）生成的。分析将分三个主要阶段进行：首先，生成粒子快照；其次，应用拉格朗日空间的 ORIGAMI 分类；第三，应用欧拉空间的分水岭算法。\n\n### I. 粒子分布的生成\n\n宇宙的初始状态被建模为一个由 $N^3$ 个粒子组成的均匀立方格点，其初始（拉格朗日）位置为 $\\mathbf{q}$。网格间距为 $\\Delta q = L/N$，由 $(i,j,k)$ 索引的粒子的位置为 $\\mathbf{q}_{ijk} = ((i+0.5)\\Delta q, (j+0.5)\\Delta q, (k+0.5)\\Delta q)$，其中 $i,j,k \\in \\{0, 1, ..., N-1\\}$。\n\n从拉格朗日位置 $\\mathbf{q}$ 到最终（欧拉）位置 $\\mathbf{x}$ 的演化由泽尔多维奇近似描述：\n$$\n\\mathbf{x}(\\mathbf{q}) = \\mathbf{q} + \\mathbf{s}(\\mathbf{q})\n$$\n其中 $\\mathbf{s}(\\mathbf{q})$ 是位移场。位移场由标量势 $\\phi(\\mathbf{q})$ 的梯度导出，并由幅度参数 $A$ 进行缩放：\n$$\n\\mathbf{s}(\\mathbf{q}) = -A \\nabla \\phi(\\mathbf{q})\n$$\n势 $\\phi(\\mathbf{q})$ 是一个空间随机高斯场，在特征尺度 $R_s$ 上进行了平滑。该场是在傅里叶空间中计算生成的。\n\n1.  **傅里叶空间网格**：我们定义一个波矢量网格 $\\mathbf{k} = (k_x, k_y, k_z)$，对应于 $N^3$ 格点的离散傅里叶模式。其分量由 $k_\\alpha = 2\\pi n_\\alpha/L$ 给出，其中 $n_\\alpha$ 是从 $-N/2$ 到 $N/2-1$ 的整数。\n\n2.  **生成势场**：首先通过在实空间中创建一个白噪声网格并执行快速傅里叶变换（FFT）来生成一个未平滑的势。记为 $\\hat{\\phi}_{\\text{raw}}(\\mathbf{k})$。此过程确保满足实数条件 $\\hat{\\phi}(\\mathbf{k}) = \\hat{\\phi}^{*}(-\\mathbf{k})$，从而使其逆变换为一个实值场。\n\n3.  **平滑**：通过在傅里叶空间中与高斯滤波器 $W(|\\mathbf{k}|) = \\exp(-|\\mathbf{k}|^2 R_s^2 / 2)$ 相乘来平滑该场。\n    $$\n    \\hat{\\phi}(\\mathbf{k}) = \\hat{\\phi}_{\\text{raw}}(\\mathbf{k}) W(|\\mathbf{k}|)\n    $$\n    直流分量 $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0})$ 设置为零，以确保平均位移为空。\n\n4.  **计算位移**：实空间中的梯度算子 $\\nabla$ 对应于傅里叶空间中的乘以 $i\\mathbf{k}$。因此，位移场的傅里叶变换为：\n    $$\n    \\hat{\\mathbf{s}}(\\mathbf{k}) = -A (i\\mathbf{k}) \\hat{\\phi}(\\mathbf{k})\n    $$\n    然后对 $\\hat{\\mathbf{s}}(\\mathbf{k})$ 的每个分量应用逆 FFT，以获得拉格朗日网格上的实空间位移场 $\\mathbf{s}(\\mathbf{q})$。\n\n5.  **最终位置**：欧拉位置计算为 $\\mathbf{x} = \\mathbf{q} + \\mathbf{s}$，并使用模运算符折叠回边长为 $L$ 的周期性盒子中：$x_\\alpha' = x_\\alpha \\pmod L$。\n\n### II. 通过 ORIGAMI 计算拉格朗日空洞分数 ($f_L$)\n\nORIGAMI 方法根据初始拉格朗日格点的形变对宇宙网的区域进行分类。空洞区域是指那些已经膨胀但尚未发生壳层穿越（即不同物质流相交的地方）的区域。\n\n1.  **壳层穿越检测**：我们沿每个主轴 $\\alpha \\in \\{x,y,z\\}$ 独立评估壳层穿越。对于给定的轴，我们考虑最初与该轴对齐的 $N^2$ 条一维粒子线。对于每条线，粒子按其初始拉格朗日坐标（例如 $q_x$）排序。如果结构未沿此轴发生壳层穿越，则相应的欧拉坐标 $x_x$ 也应单调递增。如果线上任何相邻粒子对的顺序发生反转，则检测到壳层穿越。\n    具体来说，对于按初始 $q_\\alpha$ 坐标排序的一条粒子线 $p_0, p_1, \\ldots, p_{N-1}$，如果对于任何 $i \\in \\{0, \\ldots, N-2\\}$ 有 $x_\\alpha(p_{i+1})  x_\\alpha(p_i)$，我们就检测到一个穿越。\n\n2.  **粒子分类**：根据问题的规定，如果粒子 $p_i$ 和 $p_{i+1}$ 之间发生此类顺序反转，则两个粒子都被标记为沿 $\\alpha$ 轴发生了壳层穿越。对每条线和每个轴重复此过程。我们维持一个每个粒子的计数 $C_{sc}$，它跟踪一个粒子被标记为发生壳层穿越的轴的数量。\n\n3.  **空洞分数计算**：如果一个粒子在三个轴上都未参与任何壳层穿越事件，即其壳层穿越轴计数 $C_{sc}=0$，则该粒子被分类为“拉格朗日空洞粒子”。拉格朗日空洞分数 $f_L$ 是空洞粒子的总数除以粒子总数 $N^3$。\n    $$\n    f_L = \\frac{\\text{粒子数为 } C_{sc}=0 \\text{ 的粒子总数}}{N^3}\n    $$\n\n### III. 欧拉分水岭空洞体积分数 ($f_E$)\n\n此方法将欧拉密度场中的低密度盆地识别为空洞。\n\n1.  **密度场构建**：将连续密度场离散化到 $N^3$ 网格上。使用网格质点（CIC）方案将粒子质量分配到网格点上。对于每个粒子，其质量（取为 $m_p=1$）根据其在子网格中的位置，使用三线性插值权重分配到周围的 8 个网格顶点。将所有 $N^3$ 个粒子的贡献相加，得到一个网格化质量场，我们记为 $\\rho_{\\text{grid}}$。\n\n2.  **密度对比度**：密度对比度 $\\delta$ 定义为 $\\delta(\\mathbf{x}) = \\rho(\\mathbf{x})/\\bar{\\rho} - 1$。由于我们在 $N^3$ 网格中为 $N^3$ 个粒子选择 $m_p=1$，每个网格单元的平均质量为 $\\bar{m}=1$。因此，密度对比度可以直接从网格化质量计算为 $\\delta = \\rho_{\\text{grid}} - 1$。\n\n3.  **分水岭分割**：分水岭算法将网格划分为与局部密度极小值相关联的盆地。\n    -   **汇点**：汇点是指没有任何一个面相邻邻居的密度比它严格更低的网格单元。汇点对应于局部极小值或平台区域的极小值。\n    -   **最速下降**：对于每个网格单元，通过迭代地移动到密度最低的邻居来追踪一条最速下降路径，直到到达一个汇点。\n    -   **盆地分配**：网格中的每个单元都被分配给其下降路径终止处的汇点所在的盆地。这会创建一个 `basin_map`，其中每个单元都用其对应汇点的索引进行标记。\n\n4.  **空洞体积分数**：如果一个盆地的汇点密度对比度 $\\delta_{\\text{sink}}$ 低于给定的阈值 $\\delta_v$，则该盆地被分类为空洞。欧拉分水岭空洞体积分数 $f_E$ 是属于这些空洞盆地的网格单元的比例。\n    $$\n    f_E = \\frac{\\text{汇点密度对比度 } \\delta_{\\text{sink}}  \\delta_v \\text{ 的盆地中的网格单元数}}{N^3}\n    $$\n\n最后，两种方法之间的绝对失配计算为 $m = |f_E - f_L|$。", "answer": "```python\nimport numpy as np\n\ndef generate_displacement_field(N, L, A, Rs, seed):\n    \"\"\"\n    Generates a 3D displacement field using the Zel'dovich approximation.\n    \"\"\"\n    np.random.seed(seed)\n\n    # 1. Generate Gaussian random potential in Fourier space\n    # Generate real-space white noise and FFT to get a k-space field\n    # that satisfies the reality condition.\n    noise = np.random.randn(N, N, N)\n    phi_k = np.fft.fftn(noise)\n\n    # 2. Define k-space grid and apply smoothing\n    k_vec = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n    ksq = kx**2 + ky**2 + kz**2\n    ksq[0, 0, 0] = 1.0  # Avoid division by zero, will be set to 0 later\n    \n    smoothing_filter = np.exp(-ksq * Rs**2 / 2.0)\n    phi_k_smoothed = phi_k * smoothing_filter\n    phi_k_smoothed[0, 0, 0] = 0.0  # Set DC mode to zero\n\n    # 3. Calculate gradient in k-space and transform back\n    grad_phi_x_k = 1j * kx * phi_k_smoothed\n    grad_phi_y_k = 1j * ky * phi_k_smoothed\n    grad_phi_z_k = 1j * kz * phi_k_smoothed\n\n    s_x = np.real(np.fft.ifftn(grad_phi_x_k))\n    s_y = np.real(np.fft.ifftn(grad_phi_y_k))\n    s_z = np.real(np.fft.ifftn(grad_phi_z_k))\n\n    # Displacement field s = -A * grad(phi)\n    return -A * s_x, -A * s_y, -A * s_z\n\ndef compute_lagrangian_void_fraction(x, y, z, N):\n    \"\"\"\n    Computes Lagrangian void fraction using the ORIGAMI method.\n    \"\"\"\n    # sc_on_axis[i,j,k,ax] is True if particle (i,j,k) shell-crossed on axis ax\n    sc_on_axis = np.zeros((N, N, N, 3), dtype=bool)\n\n    # Axis 0 (x)\n    # The order reversal needs to account for periodic boundaries\n    # A simple diff is not enough. We check d(x_i) = x_{i+1} - x_i.\n    # If wrapped around, e.g., x_{i+1} is small and x_i is large, d(x_i) is negative.\n    # But this could be a large positive jump. The particle that \"jumped\"\n    # across the boundary did so in the positive direction.\n    # A reversal means x_i > x_{i+1} without wrapping.\n    # Let's consider the displacement dx = x_i - x_{i-1}.\n    # We account for periodicity by checking dx, dx+L, and dx-L, and taking the one with smallest magnitude.\n    # However, the problem statement is simpler: \"寻找欧拉坐标的离散差为负的相邻粒子对\".\n    # This implies a simple diff check is sufficient, as the positions are already wrapped in [0,L).\n    # A large jump across the boundary (e.g., from L-e to e) will yield a negative diff,\n    # but this is not a shell crossing. A true shell crossing happens locally.\n    # The problem description is slightly ambiguous for periodic data.\n    # The simplest interpretation is that the particle positions are not unwrapped,\n    # and a negative difference `x[i+1]-x[i]` flags a crossing.\n    # Let's follow this simpler interpretation.\n    \n    # Axis 0 (x)\n    diffs_x = np.diff(x, axis=0)  0\n    sc_on_axis[:-1, :, :, 0] |= diffs_x\n    sc_on_axis[1:, :, :, 0] |= diffs_x\n\n    # Axis 1 (y)\n    diffs_y = np.diff(y, axis=1)  0\n    sc_on_axis[:, :-1, :, 1] |= diffs_y\n    sc_on_axis[:, 1:, :, 1] |= diffs_y\n\n    # Axis 2 (z)\n    diffs_z = np.diff(z, axis=2)  0\n    sc_on_axis[:, :, :-1, 2] |= diffs_z\n    sc_on_axis[:, :, 1:, 2] |= diffs_z\n\n    # Count number of axes with shell-crossing for each particle\n    num_crossed_axes = np.sum(sc_on_axis, axis=3)\n    \n    # Void particles are those with zero shell-crossed axes\n    num_void_particles = np.sum(num_crossed_axes == 0)\n    \n    return num_void_particles / (N**3)\n\ndef compute_eulerian_void_fraction(x_p, y_p, z_p, N, L, delta_v):\n    \"\"\"\n    Computes Eulerian void fraction using a watershed algorithm on a CIC density field.\n    \"\"\"\n    # 1. CIC mass assignment\n    rho_grid = np.zeros((N, N, N), dtype=np.float64)\n    dx = L / N\n    \n    # Flatten particle positions\n    x_flat, y_flat, z_flat = x_p.flatten(), y_p.flatten(), z_p.flatten()\n\n    # Normalized coordinates\n    px_norm = x_flat / dx\n    py_norm = y_flat / dx\n    pz_norm = z_flat / dx\n    \n    i = np.floor(px_norm).astype(int)\n    j = np.floor(py_norm).astype(int)\n    k = np.floor(pz_norm).astype(int)\n    \n    tx = px_norm - i\n    ty = py_norm - j\n    tz = pz_norm - k\n    \n    i = i % N\n    j = j % N\n    k = k % N\n    \n    i_plus_1 = (i + 1) % N\n    j_plus_1 = (j + 1) % N\n    k_plus_1 = (k + 1) % N\n\n    # Trilinear weights\n    wx = [1 - tx, tx]\n    wy = [1 - ty, ty]\n    wz = [1 - tz, tz]\n\n    indices_i = [i, i_plus_1]\n    indices_j = [j, j_plus_1]\n    indices_k = [k, k_plus_1]\n    \n    for a in range(2):\n        for b in range(2):\n            for c in range(2):\n                weight = wx[a] * wy[b] * wz[c]\n                np.add.at(rho_grid, (indices_i[a], indices_j[b], indices_k[c]), weight)\n\n    # 2. Density contrast\n    delta = rho_grid - 1.0\n    delta_flat = delta.flatten()\n\n    # 3. Watershed segmentation\n    basin_map = -np.ones(N**3, dtype=int)\n    indices_flat_grid = np.arange(N**3).reshape(N,N,N)\n\n    # Find sinks first\n    sinks = []\n    for idx in range(N**3):\n        i, j, k = np.unravel_index(idx, (N, N, N))\n        is_sink = True\n        for di, dj, dk in [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]:\n            ni, nj, nk = (i + di) % N, (j + dj) % N, (k + dk) % N\n            if delta[ni, nj, nk]  delta[i, j, k]:\n                is_sink = False\n                break\n        if is_sink:\n            sinks.append(idx)\n            basin_map[idx] = idx\n\n    # Iteratively assign cells to basins\n    changed = True\n    while changed:\n        changed = False\n        for idx in range(N**3):\n            if basin_map[idx] != -1:\n                continue\n\n            i, j, k = np.unravel_index(idx, (N, N, N))\n            neighbors_indices = []\n            neighbors_deltas = []\n            for di, dj, dk in [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]:\n                ni, nj, nk = (i + di) % N, (j + dj) % N, (k + dk) % N\n                neighbors_indices.append(indices_flat_grid[ni, nj, nk])\n                neighbors_deltas.append(delta[ni, nj, nk])\n\n            min_delta_neighbor = min(neighbors_deltas)\n            min_neighbor_idx = neighbors_indices[np.argmin(neighbors_deltas)]\n\n            if basin_map[min_neighbor_idx] != -1:\n                basin_map[idx] = basin_map[min_neighbor_idx]\n                changed = True\n    \n    # 4. Compute void fraction\n    unique_sinks = np.unique(basin_map)\n    sink_deltas = delta_flat[unique_sinks]\n    \n    void_sinks = unique_sinks[sink_deltas  delta_v]\n    \n    is_in_void_basin = np.isin(basin_map, void_sinks)\n    f_E = np.sum(is_in_void_basin) / (N**3)\n    \n    return f_E\n\ndef solve():\n    test_cases = [\n        (16, 100.0, 0.5, 5.0, -0.5, 42),\n        (16, 100.0, 1.5, 3.0, -0.3, 123),\n        (16, 100.0, 3.0, 2.0, 0.0, 7),\n        (8, 100.0, 0.1, 2.0, 0.5, 31415),\n    ]\n\n    results = []\n    for N, L, A, Rs, delta_v, seed in test_cases:\n        # Generate initial Lagrangian grid\n        grid_1d = (np.arange(N) + 0.5) * L / N\n        q_x, q_y, q_z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n        # Generate displacement field\n        s_x, s_y, s_z = generate_displacement_field(N, L, A, Rs, seed)\n        \n        # Calculate Eulerian positions\n        x = (q_x + s_x) % L\n        y = (q_y + s_y) % L\n        z = (q_z + s_z) % L\n\n        # Calculate Lagrangian void fraction\n        f_L = compute_lagrangian_void_fraction(x, y, z, N)\n\n        # Calculate Eulerian void fraction\n        f_E = compute_eulerian_void_fraction(x, y, z, N, L, delta_v)\n        \n        # Calculate mismatch\n        m = abs(f_E - f_L)\n        \n        results.append([f_L, f_E, m])\n    \n    # Print results in the required format\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3502019"}]}