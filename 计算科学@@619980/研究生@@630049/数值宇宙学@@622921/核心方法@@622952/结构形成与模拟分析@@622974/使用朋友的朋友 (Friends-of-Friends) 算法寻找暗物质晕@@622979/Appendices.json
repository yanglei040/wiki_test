{"hands_on_practices": [{"introduction": "在将“朋友的朋友”（Friends-of-Friends, FoF）算法应用于复杂的宇宙学数据之前，验证其正确性至关重要。本练习将指导您使用合成粒子构型（例如完美的晶格和随机点集）来设计单元测试，对于这些构型，预期的暗晕数量可以从第一性原理推导出来 [@problem_id:3474766]。通过将您的代码输出与这些已知答案进行比较，您可以对您的FoF核心逻辑实现建立信心。", "problem": "您的任务是设计单元测试，以验证一个在周期性立方体域中运行的友邻算法 (Friends-of-Friends, FoF) 暗物质晕寻找器，该测试需使用模拟常见数值宇宙学输入的合成立方点集。FoF 算法的规则是：如果两个粒子的最小镜像分离距离小于或等于一个连接长度，则将它们连接起来，而暗物质晕则定义为在该连接关系的传递闭包下的连通分量。本问题中所有距离都是无量纲的，并以立方体盒子边长为单位表示，设为 $L = 1$。\n\n基本依据和定义：\n- 考虑一个体积为 $V = L^3 = 1$ 的周期性立方体盒子中的 $N$ 个粒子。\n- 平均粒子间分离距离定义为 $l_{\\mathrm{bar}} = \\left(\\frac{V}{N}\\right)^{1/3} = N^{-1/3}$。\n- FoF 连接长度为 $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$，其中 $b > 0$ 是一个无量纲控制参数。\n- 令 $\\mathbf{x}_i \\in [0,1)^3$ 表示第 $i$ 个粒子的位置。\n- 两个粒子 $i$ 和 $j$ 之间的最小镜像分离距离由向量 $\\Delta \\mathbf{x}_{ij}$ 的欧几里得范数给出，其中每个坐标差 $\\Delta x = x_j - x_i$ 通过 $\\Delta x \\mapsto \\Delta x - L \\,\\left\\lfloor \\Delta x/L + \\frac{1}{2} \\right\\rfloor$ 映射到区间 $[-\\frac{L}{2}, \\frac{L}{2})$ 内。如果 $\\|\\Delta \\mathbf{x}_{ij}\\| \\le l_{\\mathrm{link}}$，则称粒子 $i$ 和 $j$ 为友邻 (friends)。一个暗物质晕是基于友邻关系构建的图中一个连通分量内的粒子集合。FoF 暗物质晕计数 $H$ 是连通分量的数量。\n\n待测试的合成立方点集：\n1. 周期性盒子中的均匀泊松点集（均匀随机位置）。\n2. 一个完美的 $n \\times n \\times n$ 立方晶格点集，点间距为 $a = \\frac{L}{n}$，位于单元中心 $\\left(\\frac{i + \\frac{1}{2}}{n}, \\frac{j + \\frac{1}{2}}{n}, \\frac{k + \\frac{1}{2}}{n}\\right)$。\n3. 一个类玻璃结构，通过抖动晶格构造，具有有界位移。其定义为从晶格位置开始，在每个坐标上添加一个确定的、有界的、交替的偏移量 $\\pm \\epsilon$，以使最近邻的轴对齐分离距离不小于 $a - 2\\epsilon$。这模拟了一种抑制近距离粒子对的蓝噪声或弛豫构型。\n\n您的程序必须：\n- 实现一个在周期性盒子中使用最小镜像约定和 $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$ 的 FoF 成团寻找器。\n- 为下面的每个测试用例构建合成立方点集。\n- 对于每个测试用例，仅通过几何推理和上述定义推导出预期的 FoF 暗物质晕计数 $H_{\\mathrm{exp}}$。对于泊松点集的情况，预期计数必须从结果是确定性的极端参数体系中推导出来：要么 $b = 0$（无连接），要么 $l_{\\mathrm{link}} \\ge \\frac{\\sqrt{3}}{2} L$（根据最小镜像度量，每对粒子都被连接）。\n- 将您实现中计算出的暗物质晕计数 $H_{\\mathrm{comp}}$ 与推导出的 $H_{\\mathrm{exp}}$进行比较，并报告测试是否通过，即 $H_{\\mathrm{comp}} = H_{\\mathrm{exp}}$ 是否成立。\n\n测试套件和参数：\n始终设 $L = 1$，并使用给定的确切参数。对于晶格，设置 $n$ 以使 $N = n^3$。对于类玻璃结构，使用指定的 $\\epsilon$ 进行抖动构造。\n\n- 情况 1 (晶格，低于邻居阈值): $n = 2$，因此 $N = 8$，$a = \\frac{1}{2}$，$b = 0.9$。计算 $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$，其中 $l_{\\mathrm{bar}} = \\frac{1}{2}$。推导出 $H_{\\mathrm{exp}}$。\n- 情况 2 (晶格，处于邻居阈值边界): $n = 2$，因此 $N = 8$，$a = \\frac{1}{2}$，$b = 1.0$。如上计算 $l_{\\mathrm{link}}$。推导出 $H_{\\mathrm{exp}}$。\n- 情况 3 (类玻璃结构，低于抖动阈值): $n = 3$，因此 $N = 27$，$a = \\frac{1}{3}$，$\\epsilon = 0.05$，$b = 0.6$。计算 $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$，其中 $l_{\\mathrm{bar}} = \\frac{1}{3}$。使用最近邻分离距离的界限来推导出 $H_{\\mathrm{exp}}$。\n- 情况 4 (类玻璃结构，处于抖动阈值边界): $n = 3$，因此 $N = 27$，$a = \\frac{1}{3}$，$\\epsilon = 0.05$，选择 $b$ 以使 $l_{\\mathrm{link}} = a - 2\\epsilon$。根据此等式数值推导出 $H_{\\mathrm{exp}}$。\n- 情况 5 (泊松分布，零连接长度): $N = 10$，$b = 0$。推导出 $H_{\\mathrm{exp}}$。\n- 情况 6 (泊松分布，超连接状态): $N = 10$，$b = 2.0$。计算 $l_{\\mathrm{link}}$ 并与最大可能的最小镜像分离距离 $\\frac{\\sqrt{3}}{2}L$ 进行比较。推导出 $H_{\\mathrm{exp}}$。\n\n答案规格：\n- 对于每种情况，计算一个布尔值，指示计算出的暗物质晕计数是否等于推导出的预期计数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[True,False,True,True,False,True]”）。\n\n科学真实性：\n- 使用最小镜像度量处理周期性边界。\n- 使用不相交集并查集 (union-find) 或等效方法计算 FoF 友邻关系下的连通分量。\n- 对于泊松点集的情况，使用确定性体系（$b = 0$ 或 $l_{\\mathrm{link}} \\ge \\frac{\\sqrt{3}}{2} L$）以确保预期结果不是随机的。\n\n除了无量纲距离外，不涉及任何角度或物理单位。所有输出都是无量纲和无单位的数字或布尔值。最终输出必须是如上所述的布尔值。", "solution": "用户提供了一个问题，要求使用周期性立方盒中的几种合成粒子分布来验证友邻算法 (Friends-of-Friends, FoF) 暗物质晕寻找器。任务是实现 FoF 算法，从第一性原理为每个测试用例推导出预期的暗物质晕数量 ($H_{\\mathrm{exp}}$)，并将其与计算确定的暗物质晕计数 ($H_{\\mathrm{comp}}$) 进行比较。\n\n首先，需要一个用于在周期性域中寻找 FoF 暗物质晕的算法。问题指定了一个边长为 $L=1$ 的立方盒。计算距离时必须使用最小镜像约定。如果粒子对 $(i, j)$（位置为 $\\mathbf{x}_i, \\mathbf{x}_j$）的最小镜像分离距离 $\\|\\Delta\\mathbf{x}_{ij}\\|$ 小于或等于连接长度 $l_{\\mathrm{link}}$，则它们被连接。暗物质晕是由这些连接定义的图中的一个连通分量。实现这一功能的一种高效方法是使用支持周期性边界条件的 k-d 树数据结构，以找到连接长度内的所有粒子对，对于典型分布，这是一个 $O(N \\log N)$ 或更优的操作，优于朴素的 $O(N^2)$ 对搜索。`scipy.spatial.cKDTree` 提供了此功能。一旦识别出连接对，就可以使用不相交集并查集 (Disjoint-Set Union, DSU) 或并查集 (Union-Find) 算法找到连通分量，这非常高效。\n\n问题的核心在于为六个测试用例中的每一个分析推导出预期的暗物质晕计数 $H_{\\mathrm{exp}}$。\n\n**情况 1：晶格，低于邻居阈值**\n- 参数：一个每边 $n=2$ 个点的完美立方晶格，总共 $N=n^3=8$ 个粒子。晶格间距为 $a=L/n=1/2$。平均粒子间分离距离为 $l_{\\mathrm{bar}} = N^{-1/3} = 8^{-1/3} = 1/2$。连接参数为 $b=0.9$。\n- 连接长度：$l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 0.9 \\times (1/2) = 0.45$。\n- 几何分析：对于立方晶格，任意两点之间的最小分离距离是沿坐标轴的最近邻距离，即 $a=0.5$。所有其他分离距离都更大（例如，面对角线距离 $\\sqrt{2}a$，体对角线距离 $\\sqrt{3}a$）。\n- 推导：由于连接长度 $l_{\\mathrm{link}} = 0.45$ 严格小于最小粒子分离距离 $a=0.5$，没有两个粒子可以被连接。每个粒子都孤立在自己的暗物质晕中。\n- 预期暗物质晕计数：$H_{\\mathrm{exp}} = N = 8$。\n\n**情况 2：晶格，处于邻居阈值边界**\n- 参数：与情况 1 相同，但 $b=1.0$。\n- 连接长度：$l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 1.0 \\times (1/2) = 0.5$。\n- 几何分析：连接长度恰好等于最近邻距离，$l_{\\mathrm{link}} = a = 0.5$。\n- 推导：每个粒子都将与其六个最近邻连接（对于边界情况可能会更少，但在周期性盒子中，所有粒子都有六个邻居）。例如，位于 $(1/4, 1/4, 1/4)$ 的粒子与 $(3/4, 1/4, 1/4)$ 连接。这将创建一个图，其中任何粒子都可以通过沿晶格轴的连接到达任何其他粒子。因此，所有 8 个粒子形成一个单一的连通分量。\n- 预期暗物质晕计数：$H_{\\mathrm{exp}} = 1$。\n\n**情况 3：类玻璃结构，低于抖动阈值**\n- 参数：一个抖动晶格，其中 $n=3$，$N=27$，$a=1/3$，$l_{\\mathrm{bar}}=1/3$。抖动是一个大小为 $\\epsilon=0.05$ 的确定性偏移 $\\pm\\epsilon$。连接参数为 $b=0.6$。\n- 连接长度：$l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 0.6 \\times (1/3) = 0.2$。\n- 几何分析：类玻璃构型是通过对索引为 $(i,j,k)$ 的晶格点进行坐标位移 $(\\pm\\epsilon, \\pm\\epsilon, \\pm\\epsilon)$ 来构建的，符号取决于索引的奇偶性，例如，$x$ 方向的偏移为 $(-1)^i\\epsilon$。最小轴对齐分离距离出现在索引为 $(i,j,k)$ 和 $(i+1,j,k)$ 的邻居之间，其中 $i$ 为偶数。该分离距离为 $d_{min} = a - 2\\epsilon = 1/3 - 2(0.05) = 1/3 - 0.1 \\approx 0.2333$。非轴对齐邻居之间的分离距离更大。因此，此构型中任意两个粒子之间的最小分离距离是 $a-2\\epsilon$。\n- 推导：连接长度为 $l_{\\mathrm{link}} = 0.2$。由于 $l_{\\mathrm{link}}  d_{min}$，没有两个粒子可以被连接。\n- 预期暗物质晕计数：$H_{\\mathrm{exp}} = N = 27$。\n\n**情况 4：类玻璃结构，处于抖动阈值边界**\n- 参数：与情况 3 相同，但 $l_{\\mathrm{link}}$ 设置为最小分离距离，$l_{\\mathrm{link}} = a - 2\\epsilon = 1/3 - 0.1 = 7/30 \\approx 0.2333$。\n- 推导：如果粒子间的分离距离恰好为 $l_{\\mathrm{link}}$，则它们被连接。这种情况发生在轴对齐的邻居 $(i,j,k)$ 和 $(i',j',k')$ 之间，且位移减小了它们的分离距离。偏移 $(-1)^p \\epsilon$ 意味着对于偶数索引 $p$，偏移为 $+\\epsilon$，奇数索引为 $-\\epsilon$。因此，索引对 $(p, p+1)$ 之间的距离是 $a - 2\\epsilon$ 当 $p$ 是偶数时，而 $a+2\\epsilon$ 当 $p$ 是奇数时。对于 $n=3$（索引 0, 1, 2），仅在 $(0,1)$ 对之间建立连接。因此，每个维度中的索引被划分为 $\\{0,1\\}$ 和 $\\{2\\}$。\n- 连通分量是基于这些索引分区的笛卡尔积形成的：\n  1. $\\{0,1\\}^3$：$2^3=8$ 个粒子，全部互连，形成 1 个暗物质晕。\n  2. $\\{2\\}\\times\\{0,1\\}^2$：$1\\times2^2=4$ 个粒子，全部互连，形成 1 个暗物质晕。根据对称性，共有 3 个这样的暗物质晕（分别对应 $i=2$, $j=2$, $k=2$）。\n  3. $\\{2\\}^2\\times\\{0,1\\}$：$1^2\\times2=2$ 个粒子，相互连接，形成 1 个暗物质晕。根据对称性，共有 3 个这样的暗物质晕。\n  4. $\\{2\\}^3$：$1^3=1$ 个粒子，孤立，形成 1 个暗物质晕。\n- 总暗物质晕数：$1 + 3 + 3 + 1 = 8$。\n- 预期暗物质晕计数：$H_{\\mathrm{exp}} = 8$。\n\n**情况 5：泊松分布，零连接长度**\n- 参数：一个包含 $N=10$ 个粒子的均匀随机（泊松）分布，其中 $b=0$。\n- 连接长度：$l_{\\mathrm{link}} = 0$。\n- 推导：只有当粒子间分离距离为 $0$ 时，它们才被连接。对于连续随机分布，任意两个粒子占据完全相同位置的概率为零。因此，不会形成任何连接。每个粒子都是一个孤立的暗物质晕。\n- 预期暗物质晕计数：$H_{\\mathrm{exp}} = N = 10$。\n\n**情况 6：泊松分布，超连接状态**\n- 参数：一个包含 $N=10$ 个粒子的泊松分布，其中 $b=2.0$。\n- 连接长度：$l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 2.0 \\times 10^{-1/3} \\approx 2.0 / 2.154 \\approx 0.928$。\n- 几何分析：在边长为 $L=1$ 的周期性盒子中，根据最小镜像约定，任意两点之间的最大可能分离距离对应于位移向量 $(L/2, L/2, L/2)$。该距离为 $d_{max} = \\sqrt{(1/2)^2 + (1/2)^2 + (1/2)^2} = \\sqrt{3/4} = \\sqrt{3}/2 \\approx 0.866$。\n- 推导：连接长度 $l_{\\mathrm{link}} \\approx 0.928$ 大于最大可能分离距离 $d_{max} \\approx 0.866$。这意味着盒子中的任意一对粒子都将被连接，无论其位置如何。整个粒子集合形成一个包罗万象的单一暗物质晕。\n- 预期暗物质晕计数：$H_{\\mathrm{exp}} = 1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import cKDTree\n\ndef fof_finder(positions, l_link, L=1.0):\n    \"\"\"\n    Finds Friends-of-Friends halos in a periodic box.\n\n    Args:\n        positions (np.ndarray): Array of shape (N, 3) with particle positions.\n        l_link (float): The linking length.\n        L (float): The side length of the periodic cubic box.\n\n    Returns:\n        int: The number of halos found.\n    \"\"\"\n    N = positions.shape[0]\n    if N == 0:\n        return 0\n\n    # Use cKDTree for efficient periodic neighbor search.\n    # The 'boxsize' argument handles the minimum image convention correctly.\n    tree = cKDTree(positions, boxsize=L)\n    pairs = tree.query_pairs(r=l_link, p=2.0)  # p=2.0 for Euclidean distance\n\n    # Use a Disjoint-Set Union (DSU) or Union-Find algorithm\n    # to find connected components from the list of pairs.\n    parent = list(range(N))\n    \n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n\n    for i, j in pairs:\n        union(i, j)\n\n    # The number of halos is the number of unique roots in the DSU structure.\n    n_halos = len({find(i) for i in range(N)})\n    \n    return n_halos\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final result.\n    \"\"\"\n    L = 1.0\n\n    test_cases = [\n        # Case 1: Lattice, below-neighbor threshold\n        {'type': 'lattice', 'n': 2, 'b': 0.9, 'H_exp': 8},\n        # Case 2: Lattice, at-neighbor threshold boundary\n        {'type': 'lattice', 'n': 2, 'b': 1.0, 'H_exp': 1},\n        # Case 3: Glass-like, below jitter threshold\n        {'type': 'glass', 'n': 3, 'epsilon': 0.05, 'b': 0.6, 'H_exp': 27},\n        # Case 4: Glass-like, at jitter threshold boundary\n        {'type': 'glass', 'n': 3, 'epsilon': 0.05, 'l_link_special': 'a-2e', 'H_exp': 8},\n        # Case 5: Poisson, zero linking length\n        {'type': 'poisson', 'N': 10, 'b': 0.0, 'H_exp': 10},\n        # Case 6: Poisson, super-linking regime\n        {'type': 'poisson', 'N': 10, 'b': 2.0, 'H_exp': 1},\n    ]\n\n    results = []\n    \n    # Use a fixed seed for reproducible Poisson distributions\n    np.random.seed(42)\n\n    for case in test_cases:\n        positions = None\n        l_link = 0.0\n\n        if case['type'] == 'lattice':\n            n = case['n']\n            N = n**3\n            l_bar = N**(-1/3.0)\n            l_link = case['b'] * l_bar\n            \n            indices = np.arange(n)\n            grid = np.meshgrid(indices, indices, indices, indexing='ij')\n            positions = (np.vstack([g.ravel() for g in grid]).T + 0.5) / n\n\n        elif case['type'] == 'glass':\n            n = case['n']\n            epsilon = case['epsilon']\n            N = n**3\n            a = L / n\n            \n            if 'l_link_special' in case and case['l_link_special'] == 'a-2e':\n                l_link = a - 2 * epsilon\n            else:\n                l_bar = N**(-1/3.0)\n                l_link = case['b'] * l_bar\n\n            indices = np.arange(n)\n            ii, jj, kk = np.meshgrid(indices, indices, indices, indexing='ij')\n            indices_flat = np.vstack([ii.ravel(), jj.ravel(), kk.ravel()]).T\n            \n            positions = np.zeros((N, 3))\n            for p_idx, (i, j, k) in enumerate(indices_flat):\n                pos_x = (i + 0.5) / n + epsilon * ((-1)**i)\n                pos_y = (j + 0.5) / n + epsilon * ((-1)**j)\n                pos_z = (k + 0.5) / n + epsilon * ((-1)**k)\n                positions[p_idx] = [pos_x, pos_y, pos_z]\n        \n        elif case['type'] == 'poisson':\n            N = case['N']\n            l_bar = N**(-1/3.0)\n            l_link = case['b'] * l_bar\n            \n            positions = np.random.rand(N, 3)\n\n        # Run the FoF finder and get the computed halo count\n        H_comp = fof_finder(positions, l_link, L)\n        \n        # Compare with the expected count and store the boolean result\n        results.append(H_comp == case['H_exp'])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474766"}, {"introduction": "宇宙学模拟几乎普遍采用周期性边界条件（Periodic Boundary Conditions, PBC）来表示一个统计上均匀的宇宙。本练习专注于在FoF算法中正确实现PBC这一关键任务，因为暗晕常常会跨越模拟盒的边界 [@problem_id:3474763]。您将分析一个精心设计的场景，以了解链接长度（$l_{\\mathrm{link}}$）的选择如何决定一个暗晕是被正确地跨边界统一起来，还是被人为地分裂。", "problem": "给定一个边长为 $L=1$ 的立方周期性模拟盒子（无量纲单位，因此所有位置和距离都以盒子长度为单位表示）。考虑使用朋友的朋友 (Friends-of-Friends, FoF) 算法进行晕寻找，其定义如下：对于一组位置为 $\\{\\mathbf{x}_i\\}$ 的粒子，如果两个粒子 $i$ 和 $j$ 之间的距离 $d_{ij}$ 小于或等于一个选定的连接长度 $l_\\mathrm{link}$，则用一条边将它们连接起来。FoF 晕是最终形成图的连通分量。在周期性边界条件下，必须使用最小镜像约定来计算距离：对于每个笛卡尔分量，使用位移 $\\delta_\\alpha = \\Delta_\\alpha - L \\cdot \\mathrm{round}(\\Delta_\\alpha / L)$，其中 $\\Delta_\\alpha$ 是该分量上的朴素差值，然后使用欧几里得范数 $d_{ij} = \\sqrt{\\delta_x^2 + \\delta_y^2 + \\delta_z^2}$。\n\n构建一个确定性测试，其中一个物理晕跨越盒子边界，并分析 $l_\\mathrm{link}$ 的选择如何决定粒子是正确地环绕连接还是虚假地连接。使用以下固定的粒子位置集合：\n- 跨边界物理晕 $H_1$：六个粒子，位于\n  $(x,y,z) \\in \\{(0.98,0.5,0.5),(0.985,0.5,0.5),(0.99,0.5,0.5),(0.01,0.5,0.5),(0.015,0.5,0.5),(0.02,0.5,0.5)\\}$。\n  该晕在 $x$ 方向上跨越周期性边界，物理上是连续的。\n- 独立的晕 $H_2$ 和 $H_3$：各有三个粒子，分别位于\n  $(x,y,z) \\in \\{(0.34,0.5,0.5),(0.35,0.5,0.5),(0.36,0.5,0.5)\\}$ 和\n  $(x,y,z) \\in \\{(0.64,0.5,0.5),(0.65,0.5,0.5),(0.66,0.5,0.5)\\}$。\n\n按照描述，实现一个带有周期性边界条件的朋友的朋友晕寻找器，使用闭球规则（即，如果 $d_{ij} \\le l_\\mathrm{link}$ 则连接）。对于以下连接长度 $l_\\mathrm{link}$ 的测试套件，计算算法恢复的晕（连通分量）的数量：\n1. $l_\\mathrm{link} = 0.004$。\n2. $l_\\mathrm{link} = 0.010$。\n3. $l_\\mathrm{link} = 0.025$。\n4. $l_\\mathrm{link} = 0.280$。\n\n你的程序必须：\n- 使用最小镜像约定在周期性边界条件下计算 $d_{ij}$。\n- 通过连接 $d_{ij} \\le l_\\mathrm{link}$ 的粒子对来构建 FoF 图。\n- 按照测试套件的顺序，为每个 $l_\\mathrm{link}$ 返回连通分量的计数。\n\n以无量纲单位作答（所有长度都以 $L=1$ 为单位度量）。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件一致（例如，\"[result1,result2,result3,result4]\"）。每种情况的输出必须是代表找到的晕数量的整数。此测试套件包括一个一般情况、$l_\\mathrm{link}$ 的边界条件，以及一个边界情况，即 $l_\\mathrm{link}$ 等于导致跨周期性环绕发生虚假合并的最小晕间距。", "solution": "该问题要求在一个立方周期性模拟盒子内，对一组指定的粒子实现并应用朋友的朋友 (Friends-of-Friends, FoF) 晕寻找算法。目标是确定该算法在一系列不同的连接长度 $l_\\mathrm{link}$ 下识别出的晕的数量。该解决方案基于周期性距离计算和基于图的聚类原理。\n\n1. **周期性边界条件与最小镜像约定 (MIC)**\n\n在计算宇宙学中，模拟通常采用一个带有周期性边界条件 (PBC) 的有限体积（通常是立方体）来表示一个统计上均匀且各向同性的宇宙，从而避免虚假的边界效应。在 PBC 下，一个粒子从盒子的一个面离开后会立即从对面的面重新进入。这需要一种特殊的距离度量。标准的欧几里得距离是不够的，因为它无法识别出盒子相对两侧的两个粒子在物理上可能很近。\n\n正确的方法是最小镜像约定 (MIC)。对于边长为 $L$ 的立方盒子，计算位于位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 的两个粒子之间的距离如下。首先，计算朴素位移矢量：$\\mathbf{\\Delta} = \\mathbf{x}_i - \\mathbf{x}_j$。然后调整该矢量的每个分量 $\\Delta_\\alpha$（其中 $\\alpha \\in \\{x, y, z\\}$），以找到其在周期性空间中的最短表示：\n$$\n\\delta_\\alpha = \\Delta_\\alpha - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta_\\alpha}{L}\\right)\n$$\n`round` 函数将其参数映射到最近的整数。此操作有效地检查了“跨越边界”的距离是否更短。最终的 MIC 距离 $d_{ij}$ 是这个修正后的位移矢量 $\\mathbf{\\delta}$ 的标准欧几里得范数：\n$$\nd_{ij} = \\sqrt{\\delta_x^2 + \\delta_y^2 + \\delta_z^2}\n$$\n对于本问题，盒子边长指定为 $L=1$。\n\n2. **朋友的朋友 (FoF) 算法**\n\nFoF 算法是粒子模拟中用于识别引力束缚结构（晕）的一种广泛使用的方法。它是一种单链接层次聚类，可以用图论优雅地描述：\n- **顶点**：模拟中的每个粒子都被视为图中的一个顶点。\n- **边**：如果任意两个顶点 $i$ 和 $j$ 之间的距离 $d_{ij}$（使用 MIC 计算）小于或等于一个预定义的连接长度 $l_\\mathrm{link}$，则在它们之间创建一条无向边。即，如果 $d_{ij} \\le l_\\mathrm{link}$，则存在一条边。\n- **晕**：FoF 晕就是最终形成图的连通分量。连通分量是一组顶点，其中集合内的任意两个顶点之间都存在路径，并且集合中的任何顶点都与集合外的任何顶点没有连接。\n\n3. **算法实现与测试用例分析**\n\n实现遵循一个清晰的流程。对于每个给定的 $l_\\mathrm{link}$，我们分析问题中定义的 $N=12$ 个粒子的连通性。\na. 构建一个 $N \\times N$ 的邻接矩阵来表示该图。\nb. 对于每一对唯一的粒子 $(i, j)$，使用 $L=1$ 的 MIC 计算距离 $d_{ij}$。\nc. 如果 $d_{ij} \\le l_\\mathrm{link}$，则在邻接矩阵中记录一条边。\nd. 然后在该矩阵上运行一个连通分量算法，以计算不相交子图的数量，这对应于晕的数量。\n\n粒子集旨在测试算法的行为，特别是其对周期性边界的处理以及对 $l_\\mathrm{link}$ 的敏感性。该集合包含三个预期的物理晕：$H_1$、$H_2$ 和 $H_3$。\n- **晕内距离**：构成 $H_1$ 的粒子在 $x$ 方向上跨越周期性边界形成一条链，最大的连接距离为 $d=0.02$（在 $x=0.99$ 和 $x=0.01$ 之间）。$H_2$ 和 $H_3$ 中的粒子形成简单的链，连接距离为 $d=0.01$。\n- **晕间距离**：晕 $H_2$ 和 $H_3$ 之间的最小距离为 $d=0.28$。$H_1$ 与任何其他晕之间的最小距离为 $d=0.32$。\n\n我们现在分析具体的测试用例：\n\n- **情况 1: $l_\\mathrm{link} = 0.004$**\n    这个连接长度小于整个数据集中最小的连续粒子间距（$0.005$）。因此，任何粒子对之间都不会形成连接。12 个粒子中的每一个都是孤立的，并被计为它自己的一个晕。\n    结果：$12$ 个晕。\n\n- **情况 2: $l_\\mathrm{link} = 0.010$**\n    这个长度足以连接间距不超过 $0.01$ 的粒子。\n    - 在 $H_1$ 中，间距为 $0.005$ 的连接形成了，但关键的周期性连接 $0.02$ 没有被跨越（$0.02 > 0.010$）。这将预期的 $H_1$ 晕分裂成两个独立的群组：一个包含 $x \\in \\{0.98, 0.985, 0.99\\}$ 的粒子，另一个包含 $x \\in \\{0.01, 0.015, 0.02\\}$ 的粒子。所以 $H_1$ 被解析为 $2$ 个晕。\n    - 在 $H_2$ 和 $H_3$ 中，粒子间距均为 $0.01$。由于 $0.01 \\le l_\\mathrm{link}$，每个群组中的粒子都成功连接，各自形成一个晕。\n    晕的总数是 $2$（来自 $H_1$）$+ 1$（来自 $H_2$）$+ 1$（来自 $H_3$）$= 4$。\n\n- **情况 3: $l_\\mathrm{link} = 0.025$**\n    这个长度现在足够大，可以跨越预期晕内部的所有“物理”连接。\n    - 在 $H_1$ 中，周期性连接 $0.02$ 现在被跨越（$0.02 \\le 0.025$）。所有 $6$ 个粒子都连接成一个单一的晕。\n    - $H_2$ 和 $H_3$ 各自像之前一样形成一个单一的晕。\n    - 最小的晕间距是 $0.28$，大于 $l_\\mathrm{link}$，因此不同晕之间没有发生虚假合并。这种情况正确地识别了 $3$ 个物理上独立的群组。\n    晕的总数是 $1 + 1 + 1 = 3$。\n\n- **情况 4: $l_\\mathrm{link} = 0.280$**\n    这个连接长度被有意选择得足够大，以导致虚假的灾难性合并。\n    - 与 $l_\\mathrm{link} = 0.025$ 时一样，$H_1, H_2, H_3$ 中各自的所有粒子都被连接起来，因此每个群组最初形成一个单一的群组。\n    - 然而，$H_2$ 和 $H_3$ 之间的最小距离恰好是 $0.28$（在 $x=0.36$ 和 $x=0.64$ 的粒子之间）。由于 $0.28 \\le 0.280$，该算法连接了这两个原本独立的晕，将它们合并成一个大的虚假物体。\n    - $H_1$ 保持独立，因为它到任何其他粒子的最小距离（$0.32$）大于 $l_\\mathrm{link}$。\n    晕的总数是 $1$（来自 $H_1$）$+ 1$（来自合并的 $H_2 \\cup H_3$）$= 2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Implements a Friends-of-Friends (FoF) halo finder with periodic boundary\n    conditions and tests it on a predefined particle set and suite of\n    linking lengths.\n    \"\"\"\n    \n    # Define the physical parameters and particle positions from the problem statement.\n    L = 1.0\n    particles = np.array([\n        # H1: Across-edge physical halo (6 particles)\n        [0.98, 0.5, 0.5], [0.985, 0.5, 0.5], [0.99, 0.5, 0.5],\n        [0.01, 0.5, 0.5], [0.015, 0.5, 0.5], [0.02, 0.5, 0.5],\n        # H2: Distinct halo (3 particles)\n        [0.34, 0.5, 0.5], [0.35, 0.5, 0.5], [0.36, 0.5, 0.5],\n        # H3: Distinct halo (3 particles)\n        [0.64, 0.5, 0.5], [0.65, 0.5, 0.5], [0.66, 0.5, 0.5]\n    ])\n    num_particles = particles.shape[0]\n\n    # The problem specifies a test suite of linking lengths.\n    # This corresponds to the `test_cases` in the provided boilerplate.\n    test_cases = [0.004, 0.010, 0.025, 0.280]\n\n    results = []\n\n    def pbc_distance(pos1, pos2, box_size):\n        \"\"\"\n        Computes the Euclidean distance between two points in a periodic box\n        using the Minimum Image Convention (MIC).\n        \n        Args:\n            pos1 (np.ndarray): Position vector of the first particle.\n            pos2 (np.ndarray): Position vector of the second particle.\n            box_size (float): The side length of the cubic periodic box.\n            \n        Returns:\n            float: The MIC distance between the two particles.\n        \"\"\"\n        delta = pos1 - pos2\n        # Apply minimum image convention to each component of the vector\n        delta_mic = delta - box_size * np.round(delta / box_size)\n        return np.linalg.norm(delta_mic)\n\n    # Iterate through each linking length in the test suite\n    for l_link in test_cases:\n        # 1. Build the adjacency matrix for the graph of particles.\n        # An edge exists if the distance between two particles is = l_link.\n        adj_matrix = np.zeros((num_particles, num_particles), dtype=int)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                dist = pbc_distance(particles[i], particles[j], L)\n                if dist = l_link:\n                    adj_matrix[i, j] = 1\n                    adj_matrix[j, i] = 1\n        \n        # 2. Find the number of connected components in the graph.\n        # Each component corresponds to one FoF halo.\n        # We use scipy's optimized function for this standard graph problem.\n        n_halos, _ = connected_components(\n            csgraph=adj_matrix, \n            directed=False, \n            return_labels=True\n        )\n        results.append(n_halos)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474763"}, {"introduction": "FoF算法可以看作是在一个图中寻找连通分量，其中粒子是顶点，“朋友”对是边。在识别出所有链接对之后，挑战在于如何高效地将它们分组到暗晕中。本练习介绍了并查集（Disjoint-Set Union, DSU）算法，这是一种优雅且高度优化的数据结构，非常适合此任务。您需要实现该算法来完成暗晕的识别过程 [@problem_id:3474741]。", "problem": "给定一个立方的周期性区域和一组粒子位置，这代表了宇宙学 $N$ 体模拟的一个快照。如果两个粒子 $i$ 和 $j$ 的周期性欧几里得距离小于或等于一个连接长度 $\\ell$，则在这两个粒子之间建立一条边，从而构建一个“友邻”（Friends-of-Friends，FoF）图。连接长度定义为 $\\ell = b \\, L \\, N^{-1/3}$，其中 $L$ 是立方盒子的边长，$N$ 是粒子数，$b$ 是一个缩放平均粒子间距的无量纲连接参数。任务是设计并实现一个带有按秩合并和路径压缩的并查集（Disjoint-Set Union，DSU；也称为 union-find）算法，用以合并所有的 FoF 边，并识别 FoF 图中的不相交的晕（halo）成分，并分析其均摊时间复杂度。该图是无向图，并且必须使用最小镜像约定来处理周期性边界条件。\n\n基本基础：\n- 使用最小镜像约定的周期性欧几里得距离：对于两个位置 $\\mathbf{x}_i, \\mathbf{x}_j \\in [0,L)^3$，定义位移 $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。最小镜像位移为 $\\Delta \\mathbf{x}' = \\Delta \\mathbf{x} - L \\, \\mathrm{round}(\\Delta \\mathbf{x} / L)$，分量式应用，周期性欧几里得距离为 $d_{ij} = \\|\\Delta \\mathbf{x}'\\|_2$。\n- 友邻（FoF）定义：如果 $d_{ij} \\leq \\ell$，则在 $i$ 和 $j$ 之间放置一条边。\n- 带有按秩合并和路径压缩的并查集（DSU；union-find）操作。\n\n您的程序必须：\n- 实现一个带有按秩合并和路径压缩的 DSU。\n- 使用最小镜像周期性距离，从给定的位置和连接参数构建 FoF 边集。\n- 使用 DSU 合并边，以产生不相交的晕成分。\n- 对于每个测试用例，输出边的数量 $E$、晕的数量（连通分量）$H$ 以及按降序排列的晕大小列表。\n\n解决方案中需要解决的分析要求：\n- 从 DSU 定义和 Tarjan 的均摊界出发，分析为什么在 $N$ 个顶点中合并 $E$ 条边的按秩合并和路径压缩算法的均摊时间复杂度为 $O(N \\alpha(N) + E)$，其中 $\\alpha(N)$ 是反阿克曼函数，$E$ 是 FoF 边的数量。分析必须基于第一性原理，并避免使用未从基本定义推导出的简便公式。\n\n不使用角度单位。输出中不需要物理单位，因为最终答案是计数和大小。\n\n测试套件：\n- 案例 $\\mathbf{A}$（一般覆盖，多个小晕，重复项）：\n    - $L = 1.0$, $N = 10$, $b = 0.25$,\n    - 位置（每个坐标在 $[0, L)$ 范围内）：\n      $\\{(0.10,0.10,0.10),(0.15,0.12,0.09),(0.11,0.08,0.12),(0.80,0.80,0.80),(0.81,0.79,0.82),(0.78,0.82,0.81),(0.50,0.50,0.50),(0.50,0.50,0.500001),(0.30,0.70,0.20),(0.05,0.95,0.95)\\}$。\n- 案例 $\\mathbf{B}$（边界条件：无边）：\n    - $L = 1.0$, $N = 5$, $b = 0.05$,\n    - 位置：\n      $\\{(0.00,0.00,0.00),(0.50,0.50,0.50),(0.90,0.10,0.10),(0.10,0.90,0.10),(0.10,0.10,0.90)\\}$。\n- 案例 $\\mathbf{C}$（所有粒子通过邻居链相连）：\n    - $L = 1.0$, $N = 8$, $b = 0.30$,\n    - 位置：\n      $\\{(0.00,0.50,0.50),(0.10,0.50,0.50),(0.20,0.50,0.50),(0.30,0.50,0.50),(0.40,0.50,0.50),(0.50,0.50,0.50),(0.60,0.50,0.50),(0.70,0.50,0.50)\\}$。\n- 案例 $\\mathbf{D}$（周期性环绕连接产生两个晕）：\n    - $L = 1.0$, $N = 4$, $b = 0.25$,\n    - 位置：\n      $\\{(0.99,0.50,0.50),(0.01,0.50,0.50),(0.50,0.99,0.50),(0.50,0.01,0.50)\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result_1,result_2,result_3,result_4]$）。\n- 每个 $result_k$（对于测试用例 $k$）必须是 $[E,H,S]$ 形式的列表，其中 $E$ 是边的整数数量，$H$ 是晕的整数数量，$S$ 是按降序排序的成分大小的整数列表。", "solution": "经评估，用户提供的问题是有效的。它在计算宇宙学和算法设计领域有科学依据，定义和数据齐全，问题阐述清晰，并以客观、正式的语言表达。因此，我们可以着手提供完整的解决方案。\n\n该问题要求实现友邻（FoF）晕寻找算法。这涉及三个主要阶段：\n$1$. 通过识别所有周期性欧几里得距离小于或等于指定连接长度 $\\ell$ 的粒子对，来构建 FoF 图。\n$2$. 利用带有按秩合并和路径压缩的并查集（DSU）数据结构，高效地找到该图的连通分量，这些连通分量代表了晕。\n$3$. 分析基于 DSU 的合并过程的均摊时间复杂度。\n\n### 第 1 部分：算法框架\n\n#### 1.1 周期性距离和连接长度\n\n模拟区域是一个边长为 $L$ 的立方盒子，具有周期性边界条件。对于区域 $[0,L)^3$ 中的任意两个粒子，其位置矢量为 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，位移矢量为 $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。周期性边界条件通过最小镜像约定来处理，这确保我们总是考虑两个粒子之间可能的最短距离，包括环绕的镜像。粒子 $j$ 相对于粒子 $i$ 的最近镜像的位移矢量，对每个维度 $k \\in \\{x, y, z\\}$ 分别计算：\n$$\n\\Delta x'_k = \\Delta x_k - L \\cdot \\mathrm{round}\\left(\\frac{\\Delta x_k}{L}\\right)\n$$\n函数 $\\mathrm{round}(v)$ 将 $v$ 四舍五入到最近的整数。那么，周期性欧几里得距离的平方是：\n$$\nd_{ij}^2 = \\|\\Delta \\mathbf{x}'\\|_2^2 = (\\Delta x'_x)^2 + (\\Delta x'_y)^2 + (\\Delta x'_z)^2\n$$\n如果两个粒子 $i$ 和 $j$ 的间距小于或等于连接长度 $\\ell$，则它们被认为是“友邻”，并在 FoF 图中它们之间放置一条边。连接长度是相对于平均粒子间距定义的：\n$$\n\\ell = b \\cdot L \\cdot N^{-1/3}\n$$\n其中 $N$ 是粒子总数，$b$ 是一个无量纲连接参数。为避免计算成本高的平方根运算，我们比较距离的平方：如果 $d_{ij}^2 \\leq \\ell^2$，则存在一条边。边集的构建需要检查所有唯一的粒子对，这是一个 $O(N^2)$ 的操作。\n\n#### 1.2 带优化的并查集（DSU）\n\nDSU 数据结构非常适合用于确定图的连通分量。它维护一个不相交集合的集合，支持两个主要操作：\n- **`find(i)`**：返回包含元素 $i$ 的集合的唯一标识符（根节点）。\n- **`union(i, j)`**：合并包含元素 $i$ 和 $j$ 的两个集合。\n\n为了在均摊基础上实现近乎恒定时间的性能，采用了两种启发式方法：\n\n$1$. **路径压缩**：在 `find(i)` 操作期间，找到集合的根之后，会再次遍历从 $i$ 到根的路径。此路径上的每个节点的父指针都会更新为直接指向根。这极大地扁平化了树结构，加快了后续对该路径中元素的 `find` 操作。\n\n$2$. **按秩合并**：每个集合的根都关联一个 `rank`（秩），该秩是以此节点为根的树的高度的上界。在执行 `union(i, j)` 操作时，将具有较低秩的树的根附加为具有较高秩的树的根的子节点。如果秩相等，则任意选择一个作为新根，并将其秩加一。这种启发式方法可以防止树变得不必要地高和不平衡。\n\n整个过程如下：\n1. 初始化 DSU 结构，包含 $N$ 个粒子，每个粒子最初都在其自己的集合中。\n2. 对于预先计算的 FoF 边列表中的每条边 $(i, j)$，调用 `union(i, j)`。\n3. 处理完所有边后，剩余的不相交集合对应于晕。晕的数量是不同根的数量，每个晕的大小是追溯到给定根的粒子数。\n\n### 第 2 部分：均摊时间复杂度分析\n\n我们分析对 $N$ 个元素执行一系列 DSU 操作的时间复杂度，该序列包括用于初始化结构的 $N$ 次 `Make-Set` 操作，以及随后的 $M$ 次混合的 `Find` 和 `Union` 操作。在此问题的背景下，我们合并 $E$ 条边，这对应于 $E$ 次 `Union` 操作。每次 `Union` 操作涉及两次 `Find` 操作。因此，操作总数 $M$ 与 $E$ 成正比。\n\n该分析由 Robert Tarjan 首创，依赖于增长极其缓慢的反阿克曼函数，记作 $\\alpha(N)$。阿克曼函数 $A(m, n)$ 定义如下：\n$$\nA(m, n) = \\begin{cases}\nn+1  \\text{if } m=0 \\\\\nA(m-1, 1)  \\text{if } m0 \\text{ and } n=0 \\\\\nA(m-1, A(m, n-1))  \\text{if } m0 \\text{ and } n0\n\\end{cases}\n$$\n反阿克曼函数 $\\alpha(N)$ 定义为使得 $A(k,k)$ 相对于 $N$ 增长最快的值 $k$。对于物理世界中任何可想象的输入大小 $N$，都有 $\\alpha(N)  5$。\n\n一次操作的均摊成本是其实际成本加上在数据结构状态上定义的势函数 $\\Phi$ 的变化量。该分析的威力在于证明了 `Find` 操作虽然偶尔开销很大，但会使势 $\\Phi$ 减少，其减少量足以在长期内“支付”其成本。\n\nTarjan 分析的一个关键见解是，一个包含 $N$ 次 `Make-Set` 操作和 $M$ 次 `Find`/`Union` 操作的序列的总成本有界于 $O(M\\alpha(N) + N)$。\n\n我们被要求证明合并过程的特定形式 $O(E + N\\alpha(N))$。让我们将分析框架如下：\n1.  **初始化**：创建 $N$ 个不相交集合需要 $O(N)$ 的时间。\n2.  **合并边**：我们执行 $E$ 次 `Union` 操作。单次 `Union(i, j)` 操作包括 `Find(i)`、`Find(j)` 和一次常数时间的父指针修改（链接）。因此，总成本主要由 $2E$ 次 `Find` 操作和链接操作决定。\n\n让我们考虑所有操作完成的总工作量。每次 `Union` 的链接成本是 $O(1)$，为总复杂度贡献了 $O(E)$ 项。剩余的成本来自于 `Find` 操作期间遍历父指针。路径压缩使这一点变得复杂，因为后续在同一路径上的 `Find` 操作会变得更便宜。\n\n均摊分析可以通过将成本“分摊”到操作或节点上来构建。得出 $O(E + N\\alpha(N))$ 界限的一种方法是考虑由路径压缩引起的父指针修改总数。在对 $N$ 个元素执行的任何 `Find` 操作序列中，此类修改的总数有界于 $O(N\\alpha(N))$。这代表了在扁平化树方面的总“投资”。\n\n这 $2E$ 次 `Find` 调用中的每一次都会遍历一条到根的路径。我们可以核算这次遍历的成本。从节点 $u$ 到其父节点 $p(u)$ 的每一步都可以通过每次 `Find` 操作的恒定“费用”或通过路径压缩累积的“信用”来支付。在计入了由 $O(N\\alpha(N))$ 路径压缩预算支付的工作后，所有 $2E$ 次 `Find` 调用中遍历所有路径的总成本与 `Find` 调用本身的数量成正比，即 $O(E)$。\n\n综合这些组成部分：\n- $N$ 次初始 `Make-Set` 调用的成本：$O(N)$。\n- $E$ 次 `Union` 调用内部的常数时间链接操作的成本：$O(E)$。\n- 所有 `Find` 调用期间指针遍历的总成本，将路径压缩工作分摊到节点上：$O(N\\alpha(N))$。\n- 未被路径压缩覆盖的额外遍历成本：$O(E)$。\n\n将这些加起来，得到的总复杂度为 $O(N + E + N\\alpha(N))$。由于在任何非平凡图中，为保证连通性有 $E \\ge N-1$，或者我们感兴趣的是 $E$ 很大的情况，因此这通常被简化。特定的形式 $O(E + N\\alpha(N))$ 正确地反映了成本随边数大致线性扩展，外加一个几乎与顶点数呈线性关系的项，反映了路径压缩的总工作量。这种形式正确地将遍历边（$E$）的成本与对集合进行的结构性工作（$N\\alpha(N)$）分离开来。请注意，此处实现的*整个晕寻找算法*的总复杂度由 $O(N^2)$ 的找边步骤主导；$O(E + N\\alpha(N))$ 的分析仅适用于基于 DSU 的合并部分，正如问题所要求的那样。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"A Disjoint-Set Union (DSU) data structure with Union by Rank and Path Compression.\"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the DSU with n elements.\n        Each element is its own parent, and all ranks are initially 0.\n        \"\"\"\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, i):\n        \"\"\"\n        Finds the representative (root) of the set containing element i,\n        with path compression.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j, using union by rank.\n        Returns True if a merge occurred, False otherwise.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n\n        if root_i != root_j:\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n            return True\n        return False\n\ndef find_halos(L, N, b, positions):\n    \"\"\"\n    Identifies halos in a particle distribution using the Friends-of-Friends (FoF)\n    algorithm with a DSU data structure.\n\n    Args:\n        L (float): The side length of the cubic, periodic box.\n        N (int): The number of particles.\n        b (float): The dimensionless linking parameter.\n        positions (np.ndarray): An (N, 3) array of particle positions.\n\n    Returns:\n        list: A list containing [E, H, S], where E is the number of edges,\n              H is the number of halos, and S is a list of halo sizes sorted\n              in descending order.\n    \"\"\"\n    if N == 0:\n        return [0, 0, []]\n\n    # Calculate squared linking length\n    linking_length = b * L * (N ** (-1.0/3.0))\n    l_sq = linking_length ** 2\n\n    # Build the FoF edge list\n    edges = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            delta = positions[j] - positions[i]\n            # Apply minimal-image convention for periodic boundary conditions\n            delta -= L * np.round(delta / L)\n            dist_sq = np.sum(delta**2)\n\n            if dist_sq = l_sq:\n                edges.append((i, j))\n    \n    num_edges = len(edges)\n\n    # Use DSU to find connected components (halos)\n    dsu = DSU(N)\n    for u, v in edges:\n        dsu.union(u, v)\n\n    # Count halos and their sizes\n    halo_sizes = {}\n    for i in range(N):\n        root = dsu.find(i)\n        halo_sizes[root] = halo_sizes.get(root, 0) + 1\n\n    num_halos = len(halo_sizes)\n    sorted_sizes = sorted(halo_sizes.values(), reverse=True)\n\n    return [num_edges, num_halos, sorted_sizes]\n\ndef solve():\n    \"\"\"\n    Solves the provided test cases and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'L': 1.0, 'N': 10, 'b': 0.25,\n         'positions': np.array([\n             (0.10, 0.10, 0.10), (0.15, 0.12, 0.09), (0.11, 0.08, 0.12),\n             (0.80, 0.80, 0.80), (0.81, 0.79, 0.82), (0.78, 0.82, 0.81),\n             (0.50, 0.50, 0.50), (0.50, 0.50, 0.500001),\n             (0.30, 0.70, 0.20), (0.05, 0.95, 0.95)])},\n        # Case B\n        {'L': 1.0, 'N': 5, 'b': 0.05,\n         'positions': np.array([\n             (0.00, 0.00, 0.00), (0.50, 0.50, 0.50), (0.90, 0.10, 0.10),\n             (0.10, 0.90, 0.10), (0.10, 0.10, 0.90)])},\n        # Case C\n        {'L': 1.0, 'N': 8, 'b': 0.30,\n         'positions': np.array([\n             (0.00, 0.50, 0.50), (0.10, 0.50, 0.50), (0.20, 0.50, 0.50),\n             (0.30, 0.50, 0.50), (0.40, 0.50, 0.50), (0.50, 0.50, 0.50),\n             (0.60, 0.50, 0.50), (0.70, 0.50, 0.50)])},\n        # Case D\n        {'L': 1.0, 'N': 4, 'b': 0.25,\n         'positions': np.array([\n             (0.99, 0.50, 0.50), (0.01, 0.50, 0.50),\n             (0.50, 0.99, 0.50), (0.50, 0.01, 0.50)])}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_halos(case['L'], case['N'], case['b'], case['positions'])\n        results.append(str(result).replace(\" \", \"\"))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3474741"}]}