{"hands_on_practices": [{"introduction": "黎曼问题的精确解是 Godunov 型方法的理论基石。本实践将从第一性原理出发，推导并实现这一精确解，旨在帮助你深入理解包含激波、接触间断和稀疏波的完整波系结构。掌握精确求解器的实现是验证近似求解器和理解其背后物理过程的关键一步。[@problem_id:3484431]", "problem": "为一维理想气体欧拉方程实现一个精确黎曼求解器，该求解器适用于数值宇宙学中的高分辨率 Godunov 型方法。您必须从守恒律和自相似性的第一性原理出发。黎曼问题由两个恒定的状态（左态和右态）组成，它们在时间 $t=0$ 时被位于位置 $x=0$ 处的一个间断所分隔。对于理想气体，压力 $p$、质量密度 $\\rho$ 和速度 $u$ 通过理想气体状态方程相关联，其比热比为 $\\gamma$。一维欧拉方程表达了质量、动量和能量的守恒。假设初始数据是分段恒定的，对于 $x  0$ 为左态 $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$，对于 $x > 0$ 为右态 $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$，且常数 $\\gamma > 1$。所有量均采用一致的无量纲单位制（无需物理单位），并且您必须确保在计算的所有中间状态中，密度和压力均为正值。\n\n从跨激波的守恒关系（Rankine–Hugoniot 条件）和由欧拉方程及理想气体定律推导出的自相似稀疏波关系出发，推导出一个标量非线性方程，其唯一根为中间（星区）压力 $p_\\star$。然后推导出相关的星区速度 $u_\\star$。您的求解器必须对两侧的激波和稀疏波都具有鲁棒性，并且必须能在给定的相似坐标 $\\xi = x/t$ 处正确地对自相似解进行采样。对于此问题，您必须计算在 $\\xi = 0$ 处的密度 $\\rho(\\xi)$。\n\n您的程序必须：\n- 给定 $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$、$(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$ 和 $\\gamma$，通过求解由守恒和自相似性所蕴含的非线性方程，计算精确的星区压力 $p_\\star$ 和速度 $u_\\star$。\n- 根据完整的波形分类（每侧是激波还是稀疏波），在 $\\xi = 0$ 处对精确的自相似解进行采样，并返回密度 $\\rho(\\xi{=}0)$。\n- 使用一种数值上稳定且收敛的求根方法，该方法不预先假设特定的波形。能鲁棒地处理强激波和强稀疏波，以及左右两态几乎相等的情况。\n\n测试套件：\n提供以下四个独立测试案例的结果，所有单位均为无量纲代码单位：\n- 案例1 (Sod 型)：$\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1.0)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (0.125, 0.0, 0.1)$。\n- 案例2 (Lax 型)：$\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (0.445, 0.698, 3.528)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (0.5, 0.0, 0.571)$。\n- 案例3 (强激波)：$\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1000.0)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, 0.0, 0.01)$。\n- 案例4 (近平衡移动接触间断)：$\\gamma = 1.4$, $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.1, 1.0)$, $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, 0.1, 1.0)$。\n\n对于每个案例，输出三个浮点数：星区压力 $p_\\star$、星区速度 $u_\\star$ 以及在 $\\xi = 0$ 处采样的密度，记为 $\\rho(\\xi{=}0)$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。结果按案例顺序排列，每个案例内按 $(p_\\star, u_\\star, \\rho(\\xi{=}0))$ 的顺序排列。例如，您的输出必须具有以下形式\n$[\\;p_{\\star,1},u_{\\star,1},\\rho_1(0),\\;p_{\\star,2},u_{\\star,2},\\rho_2(0),\\;p_{\\star,3},u_{\\star,3},\\rho_3(0),\\;p_{\\star,4},u_{\\star,4},\\rho_4(0)\\;]$。\n\n注意：\n- 您绝不能硬编码 $p_\\star$、$u_\\star$ 或 $\\rho(\\xi{=}0)$ 的任何目标值。它们必须根据所述的第一性原理关系计算得出。\n- 确保您的算法能正确选择激波分支与稀疏波分支，并对强间断保持鲁棒性。", "solution": "用户提出的问题是计算流体动力学中一个适定的标准任务：为带理想气体状态方程的一维欧拉方程实现一个精确黎曼求解器。该问题具有科学依据，没有矛盾，并为获得唯一解提供了所有必要信息。因此，该问题被认为是有效的。\n\n黎曼问题的解是自相似的，这意味着它仅依赖于相似坐标 $\\xi = x/t$。其结构由两个外部状态（左态 L 和右态 R）组成，它们被一个由三道波组成的内部结构所分隔：一道左行波、一个接触间断和一道右行波。波与波之间的区域是恒定状态，被称为“星区”（$\\star_{\\mathrm{L}}$ 和 $\\star_{\\mathrm{R}}$）。\n\n跨过以速度 $u_\\star$ 移动的中心接触间断时，压力和速度都是连续的：$p_{\\star \\mathrm{L}} = p_{\\star \\mathrm{R}} = p_\\star$ 且 $u_{\\star \\mathrm{L}} = u_{\\star \\mathrm{R}} = u_\\star$。然而，密度通常是不连续的。左行波和右行波可以是激波或稀疏波，这取决于星区压力 $p_\\star$ 是大于还是小于相邻外部状态的压力。\n\n问题的核心是求解两个未知量 $p_\\star$ 和 $u_\\star$。这可以通过适当的波关系（激波使用 Rankine-Hugoniot 条件，稀疏波使用等熵关系）将星区状态与每个初始状态联系起来，并强制星区中的压力和速度相等来实现。\n\n这个过程会导出两个关于 $u_\\star$ 作为 $p_\\star$ 函数的独立方程，一个从左态推导，一个从右态推导：\n$u_\\star = u_{\\mathrm{L}} \\pm f_{\\mathrm{L}}(p_\\star, \\rho_{\\mathrm{L}}, p_{\\mathrm{L}})$\n$u_\\star = u_{\\mathrm{R}} \\mp f_{\\mathrm{R}}(p_\\star, \\rho_{\\mathrm{R}}, p_{\\mathrm{R}})$\n\n一种鲁棒的表述方式是定义一个函数 $f_k(p, \\rho_k, p_k, \\gamma)$，它表示流体速度跨越连接状态 $k$ 到星区的波时发生的变化，其中 $k \\in \\{\\mathrm{L, R}\\}$。令 $u_\\star$ 的两个表达式相等，可以得到一个关于 $p_\\star$ 的单一非线性标量方程：\n$$W(p_\\star) \\equiv f_\\mathrm{L}(p_\\star) + f_\\mathrm{R}(p_\\star) + u_\\mathrm{R} - u_\\mathrm{L} = 0$$\n函数 $f_k$ 有两种不同的形式。\n\n**1. 激波 ($p_\\star > p_k$)**：Rankine-Hugoniot 跳跃条件得出：\n$$f_k(p_\\star) = (p_\\star - p_k) \\left[ \\frac{2 / ((\\gamma+1)\\rho_k)}{p_\\star + \\frac{\\gamma-1}{\\gamma+1}p_k} \\right]^{1/2}$$\n\n**2. 稀疏波 ($p_\\star \\le p_k$)**：等熵关系和黎曼不变量给出：\n$$f_k(p_\\star) = \\frac{2 a_k}{\\gamma-1} \\left[ \\left(\\frac{p_\\star}{p_k}\\right)^{\\frac{\\gamma-1}{2\\gamma}} - 1 \\right]$$\n其中 $a_k = \\sqrt{\\gamma p_k / \\rho_k}$ 是状态 $k$ 中的声速。\n\n函数 $W(p)$ 是单调且凹的，使其适合通过 Newton-Raphson 迭代法求解。迭代步为 $p_{n+1} = p_n - W(p_n) / W'(p_n)$，其中 $W'(p) = f'_\\mathrm{L}(p) + f'_\\mathrm{R}(p)$。导数 $f'_k(p)$ 分别是：\n- 对于激波：$f'_k(p) = \\left(1 - \\frac{p-p_k}{2(B_k+p)}\\right) \\left( \\frac{A_k}{p+B_k} \\right)^{1/2}$，其中 $A_k=\\frac{2}{(\\gamma+1)\\rho_k}$ 且 $B_k=\\frac{\\gamma-1}{\\gamma+1}p_k$。\n- 对于稀疏波：$f'_k(p) = \\frac{1}{\\rho_k a_k} \\left(\\frac{p}{p_k}\\right)^{-\\frac{\\gamma+1}{2\\gamma}}$。\n\n一旦求得 $p_\\star$，星区速度 $u_\\star$ 通过对两侧表达式取平均值来计算：\n$$u_\\star = \\frac{1}{2}(u_\\mathrm{L} + u_\\mathrm{R}) + \\frac{1}{2}(f_\\mathrm{R}(p_\\star) - f_\\mathrm{L}(p_\\star))$$\n\n最后一步是在 $\\xi = x/t = 0$ 处对解进行采样，以找到密度 $\\rho(\\xi=0)$。这需要确定自相似解的哪个区域包含点 $\\xi=0$。这些区域由各种波的速度界定。其逻辑如下：\n- 接触间断以速度 $u_\\star$ 移动。\n- 如果 $\\xi=0 \\le u_\\star$，采样点位于接触间断的左侧。状态取决于左行波的结构（激波或稀疏波）及其速度。\n- 如果 $\\xi=0 > u_\\star$，采样点位于接触间断的右侧。状态取决于右行波。\n- 如果 $\\xi=0 = u_\\star$，该点位于接触间断上，密度在此处不连续。这个问题通过极限行为来解决：区域取决于我们是从 $\\xi  u_\\star$ 还是 $\\xi > u_\\star$ 接近。采纳的约定是 $\\xi \\le u_\\star$ 对应于左侧解结构。\n\n所需的波速为：\n- **激波速度**：$S_k = u_k \\mp \\sqrt{\\frac{(\\gamma+1)p_\\star + (\\gamma-1)p_k}{2\\rho_k}}$（左行波取 $-$，右行波取 $+$）。\n- **稀疏波头速度**：$S_{Hk} = u_k \\mp a_k$。\n- **稀疏波尾速度**：$S_{Tk} = u_\\star \\mp a_{\\star k}$，其中 $a_{\\star k} = \\sqrt{\\gamma p_\\star / \\rho_{\\star k}}$。\n- 星区密度 $\\rho_{\\star k}$ 是计算 $a_{\\star k}$ 所需的，并取决于波的类型：\n    - 激波：$\\rho_{\\star k} = \\rho_k \\frac{p_\\star/p_k + (\\gamma-1)/(\\gamma+1)}{(\\gamma-1)/(\\gamma+1) \\cdot p_\\star/p_k + 1}$\n    - 稀疏波：$\\rho_{\\star k} = \\rho_k (p_\\star/p_k)^{1/\\gamma}$\n\n如果采样点 $\\xi=0$ 落在稀疏扇内部，则必须根据扇内的连续解来计算密度。对于左侧扇区（1-族），$\\xi = u-a$ 且黎曼不变量 $u + \\frac{2a}{\\gamma-1} = \\text{const}$ 成立。对于 $\\xi=0$，我们求出当地声速 $a$，然后计算密度 $\\rho = \\rho_\\mathrm{L} (a/a_\\mathrm{L})^{2/(\\gamma-1)}$。类似的逻辑也适用于右侧扇区。\n\n下面的实现将此逻辑封装在一个鲁棒的程序中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Riemann solver on the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    \n    # Small tolerance for floating point comparisons and to prevent division by zero.\n    TOL = 1e-9\n\n    def wave_function(p, rho_k, p_k, gamma):\n        \"\"\"\n        Computes the velocity contribution function f_k(p) for either a shock or rarefaction wave.\n        p: pressure to evaluate at (p_star).\n        rho_k, p_k: density and pressure in the initial state k (L or R).\n        gamma: ratio of specific heats.\n        \"\"\"\n        if p_k = 0 or rho_k = 0:\n            raise ValueError(\"Pressure and density must be positive.\")\n        \n        a_k = np.sqrt(gamma * p_k / rho_k)\n\n        if p > p_k:  # Shock wave\n            A_k = 2.0 / ((gamma + 1.0) * rho_k)\n            B_k = (gamma - 1.0) / (gamma + 1.0) * p_k\n            return (p - p_k) * np.sqrt(A_k / (p + B_k))\n\n        else:  # Rarefaction wave\n            g1 = (gamma - 1.0) / (2.0 * gamma)\n            return (2.0 * a_k / (gamma - 1.0)) * ((p / p_k)**g1 - 1.0)\n\n    def wave_function_derivative(p, rho_k, p_k, gamma):\n        \"\"\"\n        Computes the derivative f'_k(p) for the Newton-Raphson solver.\n        \"\"\"\n        if p_k = 0 or rho_k = 0 or p = 0:\n            raise ValueError(\"Pressure and density must be positive.\")\n            \n        a_k = np.sqrt(gamma * p_k / rho_k)\n\n        if p > p_k: # Shock wave\n            A_k = 2.0 / ((gamma + 1.0) * rho_k)\n            B_k = (gamma - 1.0) / (gamma + 1.0) * p_k\n            \n            term1 = np.sqrt(A_k / (p + B_k))\n            term2 = (p - p_k) / (2.0 * (p + B_k))\n            return term1 * (1.0 - term2)\n            \n        else: # Rarefaction wave\n            g1 = -(gamma + 1.0) / (2.0 * gamma)\n            return (1.0 / (rho_k * a_k)) * (p / p_k)**g1\n\n    def solve_for_star_pressure(state_L, state_R, gamma):\n        \"\"\"\n        Solves for the star pressure p_star using Newton-Raphson iteration.\n        The function to solve is W(p) = f_L(p) + f_R(p) + u_R - u_L = 0.\n        \"\"\"\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n        \n        def pressure_func(p):\n            return wave_function(p, rho_L, p_L, gamma) + wave_function(p, rho_R, p_R, gamma) + (u_R - u_L)\n\n        def pressure_func_deriv(p):\n            return wave_function_derivative(p, rho_L, p_L, gamma) + wave_function_derivative(p, rho_R, p_R, gamma)\n\n        p_guess = 0.5 * (p_L + p_R)\n        p_star = max(TOL, p_guess)\n        \n        max_iter = 20\n        for _ in range(max_iter):\n            f_val = pressure_func(p_star)\n            df_val = pressure_func_deriv(p_star)\n            \n            dp = f_val / df_val if abs(df_val) > TOL else 0.0\n            p_star -= dp\n            \n            p_star = max(TOL, p_star)\n\n            if abs(dp) = TOL * p_star or abs(dp) = TOL:\n                break\n\n        return p_star\n\n    def solve_riemann_and_sample(gamma, state_L, state_R):\n        \"\"\"\n        Solves the Riemann problem and samples the solution at xi=0.\n        Returns (p_star, u_star, rho_at_xi_0).\n        \"\"\"\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n        \n        if abs(rho_L - rho_R) = TOL and abs(u_L - u_R) = TOL and abs(p_L - p_R) = TOL:\n           return (p_L, u_L, rho_L)\n        \n        p_star = solve_for_star_pressure(state_L, state_R, gamma)\n\n        fL = wave_function(p_star, rho_L, p_L, gamma)\n        fR = wave_function(p_star, rho_R, p_R, gamma)\n        u_star = 0.5 * (u_L + u_R) + 0.5 * (fR - fL)\n\n        xi = 0.0\n        rho_at_xi_0 = 0.0\n\n        g1 = (gamma - 1.0) / (gamma + 1.0)\n        g3 = 2.0 / (gamma - 1.0)\n        g4 = 2.0 / (gamma + 1.0)\n\n        if xi = u_star:\n            if p_star > p_L:\n                S_L = u_L - np.sqrt(((gamma + 1.0) * p_star + (gamma - 1.0) * p_L) / (2.0 * rho_L))\n                if xi = S_L:\n                    rho_at_xi_0 = rho_L\n                else:\n                    rho_star_L = rho_L * (p_star / p_L + g1) / (g1 * p_star / p_L + 1.0)\n                    rho_at_xi_0 = rho_star_L\n            else:\n                a_L = np.sqrt(gamma * p_L / rho_L)\n                S_HL = u_L - a_L\n                if xi = S_HL:\n                    rho_at_xi_0 = rho_L\n                else:\n                    rho_star_L = rho_L * (p_star / p_L)**(1.0 / gamma)\n                    a_star_L = np.sqrt(gamma * p_star / rho_star_L)\n                    S_TL = u_star - a_star_L\n                    if xi > S_TL:\n                        rho_at_xi_0 = rho_star_L\n                    else:\n                        rho_fan = rho_L * (g4 + g1 * (u_L - xi) / a_L)**g3\n                        rho_at_xi_0 = rho_fan\n        else:\n            if p_star > p_R:\n                S_R = u_R + np.sqrt(((gamma + 1.0) * p_star + (gamma - 1.0) * p_R) / (2.0 * rho_R))\n                if xi > S_R:\n                    rho_at_xi_0 = rho_R\n                else:\n                    rho_star_R = rho_R * (p_star / p_R + g1) / (g1 * p_star / p_R + 1.0)\n                    rho_at_xi_0 = rho_star_R\n            else:\n                a_R = np.sqrt(gamma * p_R / rho_R)\n                S_HR = u_R + a_R\n                if xi > S_HR:\n                    rho_at_xi_0 = rho_R\n                else:\n                    rho_star_R = rho_R * (p_star / p_R)**(1.0 / gamma)\n                    a_star_R = np.sqrt(gamma * p_star / rho_star_R)\n                    S_TR = u_star + a_star_R\n                    if xi = S_TR:\n                        rho_at_xi_0 = rho_star_R\n                    else:\n                        rho_fan = rho_R * (g4 - g1 * (u_R - xi) / a_R)**g3\n                        rho_at_xi_0 = rho_fan\n\n        return p_star, u_star, rho_at_xi_0\n\n    test_cases = [\n        {'gamma': 1.4, 'state_L': (1.0, 0.0, 1.0), 'state_R': (0.125, 0.0, 0.1)},\n        {'gamma': 1.4, 'state_L': (0.445, 0.698, 3.528), 'state_R': (0.5, 0.0, 0.571)},\n        {'gamma': 1.4, 'state_L': (1.0, 0.0, 1000.0), 'state_R': (1.0, 0.0, 0.01)},\n        {'gamma': 1.4, 'state_L': (1.0, 0.1, 1.0), 'state_R': (1.0, 0.1, 1.0)}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_star, u_star, rho_at_0 = solve_riemann_and_sample(case['gamma'], case['state_L'], case['state_R'])\n        results.extend([p_star, u_star, rho_at_0])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3484431"}, {"introduction": "虽然精确求解器是理论基础，但在实际应用中，为了效率和鲁棒性，我们常常使用近似求解器，例如 HLL 家族的格式。本练习将重点实现 Harten–Lax–van Leer–Einfeldt (HLLE) 求解器，并解决一个关键的实际挑战：如何确保解的物理可采纳性（即密度和压力的正定性），尤其是在强稀疏波等极端情况下。[@problem_id:3484392]", "problem": "要求您在数值宇宙学中常用的理想流体动力学系统内，为 Harten–Lax–van Leer–Einfeldt (HLLE) 近似黎曼求解器实现、分析并测试一个保持正性的原始变量恢复过程。工作将在一个空间维度下使用无量纲单位进行。考虑以守恒形式写出的理想流体动力学欧拉方程，其守恒状态向量为 $\\mathbf{U} = (\\rho, m, E)$，其中 $\\rho$ 是质量密度，$m$ 是动量密度，$E$ 是总能量密度，通量 $\\mathbf{F}(\\mathbf{U})$ 的定义与理想气体定律一致。状态方程由绝热指数为 $\\gamma$ 的理想气体关系给出，其中压力 $p$ 和内能密度 $e$ 满足 $p = (\\gamma - 1) e$，并且 $E = e + \\tfrac{1}{2} \\rho u^{2}$，其中 $u = m/\\rho$。容许集由正性条件 $\\rho > 0$ 和 $p > 0$ 定义。\n\n仅从守恒律、理想气体状态方程以及由波速编码的特征信息出发，推导在给定左右原始状态 $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$ 和 $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$ 以及固定的绝热指数 $\\gamma$ 的情况下，单个界面上的 HLLE 中间状态 $\\mathbf{U}^{\\star}$ 的表达式。使用由流体速度和声速决定的特征速度，其中声速 $c$ 满足 $c = \\sqrt{\\gamma p / \\rho}$。根据推导出的 $\\mathbf{U}^{\\star}$，设计并实现一个原始变量恢复过程，以获得 $(\\rho^{\\star}, u^{\\star}, p^{\\star})$。如果恢复的状态违反了容许性，应用一个最小正性修正，该修正保持速度 $u^{\\star}$ 不变，将密度限制在一个正下限值 $\\rho_{\\mathrm{floor}}$，并通过理想气体定律设置内能以匹配一个正下限压力 $p_{\\mathrm{floor}}$。具体来说，如果 $\\rho^{\\star} \\le \\rho_{\\mathrm{floor}}$ 或 $p^{\\star} \\le p_{\\mathrm{floor}}$，则设置 $\\rho^{\\star}_{\\mathrm{fixed}} = \\max(\\rho^{\\star}, \\rho_{\\mathrm{floor}})$，保持 $u^{\\star}_{\\mathrm{fixed}} = u^{\\star}$，并设置 $E^{\\star}_{\\mathrm{fixed}} = \\tfrac{1}{2} \\rho^{\\star}_{\\mathrm{fixed}} (u^{\\star}_{\\mathrm{fixed}})^{2} + p_{\\mathrm{fixed}}/(\\gamma - 1)$，其中 $p_{\\mathrm{fixed}} = \\max(p^{\\star}, p_{\\mathrm{floor}})$。您的实现应严格遵循此修正方法。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 给定 $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$、$(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$、$\\gamma$、$\\rho_{\\mathrm{floor}}$ 和 $p_{\\mathrm{floor}}$，使用 $E = p/(\\gamma - 1) + \\tfrac{1}{2} \\rho u^{2}$ 构建左右守恒状态，以及与欧拉方程和理想气体定律一致的通量。\n- 使用 $u$ 和 $c = \\sqrt{\\gamma p / \\rho}$ 计算特征速度，然后从左右状态和通量推导 HLLE 中间守恒状态 $\\mathbf{U}^{\\star}$。\n- 使用理想气体定律从 $\\mathbf{U}^{\\star}$ 恢复原始变量 $(\\rho^{\\star}, u^{\\star}, p^{\\star})$。\n- 检查容许性（$\\rho^{\\star} > 0$ 和 $p^{\\star} > 0$）。如果违反，则应用上述正性修正，得到 $p_{\\mathrm{fixed}}$。\n- 对每个测试用例，返回一个包含三个元素的列表：一个布尔值，表示修正前恢复的状态是否是容许的；原始恢复压力 $p^{\\star}$（浮点数）；以及修正后的压力 $p_{\\mathrm{fixed}}$（浮点数）。\n\n所有量都是无量纲的，因此不需要进行物理单位转换。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个按上述顺序排列的三元素列表。例如，生成形如 $[\\,[\\mathrm{bool}, p^{\\star}, p_{\\mathrm{fixed}}],\\ldots\\,]$ 的一行。\n\n使用以下测试套件，旨在探测与数值宇宙学流体动力学相关的各种情况：\n- 测试用例 1（经典激波管）：\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1.0)$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (0.125, 0.0, 0.1)$。\n- 测试用例 2（伴有强平流的近真空）：\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (10^{-3}, 0.0, 10^{-6})$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (10^{-6}, 10.0, 10^{-8})$。\n- 测试用例 3（强爆炸波）：\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 0.0, 1000.0)$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, 0.0, 0.01)$。\n- 测试用例 4（迎头超音速碰撞）：\n  - $\\gamma = 1.4$, $\\rho_{\\mathrm{floor}} = 10^{-12}$, $p_{\\mathrm{floor}} = 10^{-12}$,\n  - $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}}) = (1.0, 20.0, 1.0)$,\n  - $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}}) = (1.0, -20.0, 1.0)$。\n\n您的程序应精确地生成一行格式为 $[[b_{1},p^{\\star}_{1},p_{\\mathrm{fixed},1}],[b_{2},p^{\\star}_{2},p_{\\mathrm{fixed},2}],[b_{3},p^{\\star}_{3},p_{\\mathrm{fixed},3}],[b_{4},p^{\\star}_{4},p_{\\mathrm{fixed},4}]]$ 的输出，其中 $b_{i}$ 是布尔值，$p^{\\star}_{i}$ 和 $p_{\\mathrm{fixed},i}$ 是浮点数。", "solution": "用户在数值流体动力学领域提供了一个定义明确且科学严谨的问题。任务是为一维理想欧拉方程推导并实现一个保持正性的 Harten–Lax–van Leer–Einfeldt (HLLE) 近似黎曼求解器。解决方案将分两部分呈现：首先，对必要方程进行原理性推导；其次，实现最终的算法。\n\n### 1. 控制方程和状态向量\n\n一维理想流体动力学由欧拉方程控制，该方程表达了质量、动量和能量的守恒。其守恒形式写作：\n$$\n\\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}(\\mathbf{U})}{\\partial x} = 0\n$$\n其中 $t$ 是时间，$x$ 是空间坐标，$\\mathbf{U}$ 是守恒状态变量的向量，$\\mathbf{F}(\\mathbf{U})$ 是相应通量的向量。\n\n守恒状态向量 $\\mathbf{U}$ 定义为：\n$$\n\\mathbf{U} = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ E \\end{pmatrix}\n$$\n这里，$\\rho$ 是质量密度，$u$ 是流体速度，$m = \\rho u$ 是动量密度。$E$ 是总能量密度，它是内能密度 $e$ 和动能密度的和：\n$$\nE = e + \\frac{1}{2}\\rho u^2\n$$\n通量向量 $\\mathbf{F}(\\mathbf{U})$ 由下式给出：\n$$\n\\mathbf{F}(\\mathbf{U}) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ (E+p)u \\end{pmatrix}\n$$\n其中 $p$ 是流体压力。\n\n该系统通过一个状态方程 (EoS) 来封闭。对于理想气体，压力与内能密度的关系为：\n$$\np = (\\gamma - 1)e\n$$\n其中 $\\gamma$ 是绝热指数，一个常数。由此，我们可以用原始变量 $(\\rho, u, p)$ 来表示总能量密度 $E$：\n$$\nE = \\frac{p}{\\gamma-1} + \\frac{1}{2}\\rho u^2\n$$\n\n### 2. HLLE 近似黎曼求解器\n\nHLLE 格式为黎曼问题提供了一个近似解。黎曼问题是一个初值问题，具有两个恒定状态——左状态 $\\mathbf{U}_L$ 和右状态 $\\mathbf{U}_R$，在 $x=0$ 处由一个间断分隔。HLLE 近似假设了一个简单的波结构，该结构由原始的左右状态和一个单一的中间状态（记为 $\\mathbf{U}^{\\star}$）分隔。这个结构由两列波界定，它们以速度 $S_L$ 和 $S_R$ 从初始间断处传播开来。\n\n中间状态 $\\mathbf{U}^{\\star}$ 是通过在时间 $t$ 将守恒律的积分形式应用于区域 $[S_L t, S_R t]$ 推导出来的。积分守恒律为：\n$$\n\\frac{d}{dt} \\int_{x_a}^{x_b} \\mathbf{U}(x,t) dx = \\mathbf{F}(\\mathbf{U}(x_a,t)) - \\mathbf{F}(\\mathbf{U}(x_b,t))\n$$\n将其应用于由波速定义的扩展区域，我们设 $x_a = S_L t$ 和 $x_b = S_R t$。左侧变为：\n$$\n\\frac{d}{dt} \\int_{S_L t}^{S_R t} \\mathbf{U}(x,t) dx = \\frac{d}{dt} \\left( t \\int_{S_L}^{S_R} \\mathbf{U}(\\xi,1) d\\xi \\right) = \\int_{S_L}^{S_R} \\mathbf{U}(\\xi,1) d\\xi\n$$\n这里我们使用了自相似变量 $\\xi = x/t$。在 HLLE 近似中，区域 $(S_L, S_R)$ 内的状态是恒定的状态 $\\mathbf{U}^{\\star}$。因此，积分的计算结果为 $(S_R - S_L)\\mathbf{U}^{\\star}$。\n在波扇边界处计算的右侧是 $\\mathbf{F}_L - \\mathbf{F}_R$ (假设 $S_L  0  S_R$)。更一般地，进出该区域的通量与波扇外的状态（即 $\\mathbf{U}_L$ 和 $\\mathbf{U}_R$）有关。通过在边界 $S_L$ 和 $S_R$ 处应用 Rankine-Hugoniot 条件，我们发现通量平衡为 $\\mathbf{F}_L - \\mathbf{F}_R$。将各项相等并为 $\\mathbf{U}^{\\star}$ 重新整理可得：\n$$\n(S_R - S_L) \\mathbf{U}^{\\star} = S_R \\mathbf{U}_R - S_L \\mathbf{U}_L + \\mathbf{F}_L - \\mathbf{F}_R\n$$\n$$\n\\mathbf{U}^{\\star} = \\frac{S_R \\mathbf{U}_R - S_L \\mathbf{U}_L + \\mathbf{F}_L - \\mathbf{F}_R}{S_R - S_L}\n$$\n其中 $\\mathbf{U}_L$、$\\mathbf{U}_R$ 是守恒状态，$\\mathbf{F}_L = \\mathbf{F}(\\mathbf{U}_L)$、$\\mathbf{F}_R = \\mathbf{F}(\\mathbf{U}_R)$ 是相应的通量。\n\n### 3. 波速估计\n\n信号速度 $S_L$ 和 $S_R$ 必须界定真实黎曼解中所有波的传播速度。欧拉方程的特征波速是通量雅可比矩阵 $\\partial \\mathbf{F} / \\partial \\mathbf{U}$ 的特征值，即 $\\lambda_1 = u-c$，$\\lambda_2 = u$ 和 $\\lambda_3 = u+c$。声速 $c$ 由 $c = \\sqrt{\\gamma p / \\rho}$ 给出。\n我们在此采用一种常用且稳健的信号速度选择方法，即取左右状态中这些特征速度的最小值和最大值：\n$$\nS_L = \\min(\\lambda_{1,L}, \\lambda_{1,R}) = \\min(u_L - c_L, u_R - c_R)\n$$\n$$\nS_R = \\max(\\lambda_{3,L}, \\lambda_{3,R}) = \\max(u_L + c_L, u_R + c_R)\n$$\n\n### 4. 原始变量恢复与正性保持\n\n一旦计算出中间守恒状态 $\\mathbf{U}^{\\star} = (\\rho^{\\star}, m^{\\star}, E^{\\star})^T$，我们必须恢复原始变量 $(\\rho^{\\star}, u^{\\star}, p^{\\star})$，以检查其物理容许性并在后续时间步中使用。恢复公式是通过反转守恒变量的定义得出的：\n$$\n\\rho^{\\star} = \\rho^{\\star}\n$$\n$$\nu^{\\star} = \\frac{m^{\\star}}{\\rho^{\\star}}\n$$\n$$\np^{\\star} = (\\gamma - 1) \\left( E^{\\star} - \\frac{1}{2} \\rho^{\\star} (u^{\\star})^2 \\right) = (\\gamma - 1) \\left( E^{\\star} - \\frac{(m^{\\star})^2}{2\\rho^{\\star}} \\right)\n$$\n一个容许的物理状态必须具有正的密度和压力，即 $\\rho > 0$ 和 $p > 0$。HLLE 求解器本质上是一种平均，因此不保证恢复的状态 $(\\rho^{\\star}, p^{\\star})$ 会在容许集内。具体来说，强稀疏波或大的速度差可能导致 $p^{\\star} \\le 0$。\n\n为确保正性，当发现恢复的状态不符合物理实际时，会应用一个修正。问题为这个修正指定了精确的触发条件和步骤。\n- **触发条件**：如果 $\\rho^{\\star} \\le \\rho_{\\mathrm{floor}}$ 或 $p^{\\star} \\le p_{\\mathrm{floor}}$，则应用修正，其中 $\\rho_{\\mathrm{floor}}$ 和 $p_{\\mathrm{floor}}$ 是小的正常数。\n- **步骤**：如果满足触发条件，则计算一个修正后的压力 $p_{\\mathrm{fixed}}$。问题指定保持恢复的速度 $u^{\\star}$ 不变，并将低于下限值的密度和压力限制在其下限值。修正后的压力定义为：\n$$\np_{\\mathrm{fixed}} = \\max(p^{\\star}, p_{\\mathrm{floor}})\n$$\n如果未满足触发条件，则认为该状态对于修正而言是有效的，我们设置 $p_{\\mathrm{fixed}} = p^{\\star}$。布尔值的容许性检查仍然严格基于 $\\rho^{\\star} > 0$ 和 $p^{\\star} > 0$。\n\n### 5. 算法步骤\n\n对于每个给定的左 $(\\rho_{\\mathrm{L}}, u_{\\mathrm{L}}, p_{\\mathrm{L}})$ 和右 $(\\rho_{\\mathrm{R}}, u_{\\mathrm{R}}, p_{\\mathrm{R}})$ 状态，以及参数 $\\gamma$、$\\rho_{\\mathrm{floor}}$ 和 $p_{\\mathrm{floor}}$ 的测试用例，算法按以下步骤进行：\n\n1.  **计算左右状态**：对于左 ($L$) 和右 ($R$) 两种状态，从原始变量计算守恒状态向量 $\\mathbf{U}$ 和通量向量 $\\mathbf{F}$。同时计算声速 $c$。\n2.  **估计波速**：使用第 3 节的公式计算 $S_L$ 和 $S_R$。\n3.  **计算 HLLE 中间状态**：使用第 2 节的 HLLE 公式计算守恒的中间状态 $\\mathbf{U}^{\\star}$。\n4.  **恢复原始变量**：从 $\\mathbf{U}^{\\star} = (\\rho^{\\star}_{\\mathrm{cons}}, m^{\\star}_{\\mathrm{cons}}, E^{\\star}_{\\mathrm{cons}})$ 计算原始变量 $\\rho^{\\star}$、$u^{\\star}$ 和 $p^{\\star}$。\n5.  **检查容许性并应用修正**：\n    - 确定容许性布尔值：`is_admissible = (rho_star > 0.0) and (p_star > 0.0)`。\n    - 检查修正的触发条件：`needs_fix = (rho_star = rho_floor) or (p_star = p_floor)`。\n    - 计算最终压力 $p_{\\mathrm{fixed}}$。如果 `needs_fix` 为真，则 $p_{\\mathrm{fixed}} = \\max(p^{\\star}, p_{\\mathrm{floor}})$；否则，$p_{\\mathrm{fixed}} = p^{\\star}$。\n6.  **返回结果**：对每个测试用例，返回包含容许性布尔值、原始恢复压力 $p^{\\star}$ 和潜在修正后的最终压力 $p_{\\mathrm{fixed}}$ 的列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests a positivity-preserving HLLE approximate Riemann solver \n    for 1D ideal hydrodynamics, as specified in the problem statement.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (classic shock tube)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1.0, \"u\": 0.0, \"p\": 1.0},\n            \"right\": {\"rho\": 0.125, \"u\": 0.0, \"p\": 0.1},\n        },\n        # Test case 2 (near-vacuum with strong advection)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1e-3, \"u\": 0.0, \"p\": 1e-6},\n            \"right\": {\"rho\": 1e-6, \"u\": 10.0, \"p\": 1e-8},\n        },\n        # Test case 3 (strong blast wave)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1.0, \"u\": 0.0, \"p\": 1000.0},\n            \"right\": {\"rho\": 1.0, \"u\": 0.0, \"p\": 0.01},\n        },\n        # Test case 4 (head-on supersonic collision)\n        {\n            \"gamma\": 1.4, \"rho_floor\": 1e-12, \"p_floor\": 1e-12,\n            \"left\": {\"rho\": 1.0, \"u\": 20.0, \"p\": 1.0},\n            \"right\": {\"rho\": 1.0, \"u\": -20.0, \"p\": 1.0},\n        },\n    ]\n\n    def get_state_and_flux(prims, gamma):\n        \"\"\"Computes conserved state, flux, and sound speed from primitives.\"\"\"\n        rho, u, p = prims[\"rho\"], prims[\"u\"], prims[\"p\"]\n        \n        # Prevent division by zero for sound speed calculation if rho is non-positive\n        if rho = 0 or p = 0:\n             c = 0.0\n        else:\n             c = np.sqrt(gamma * p / rho)\n\n        m = rho * u\n        E = p / (gamma - 1.0) + 0.5 * rho * u**2\n        \n        U = np.array([rho, m, E])\n        F = np.array([m, m * u + p, (E + p) * u])\n        \n        return U, F, c\n\n    results = []\n    for case in test_cases:\n        gamma = case[\"gamma\"]\n        rho_floor = case[\"rho_floor\"]\n        p_floor = case[\"p_floor\"]\n\n        # 1. Construct left and right states and fluxes\n        U_l, F_l, c_l = get_state_and_flux(case[\"left\"], gamma)\n        U_r, F_r, c_r = get_state_and_flux(case[\"right\"], gamma)\n        \n        u_l = case[\"left\"][\"u\"]\n        u_r = case[\"right\"][\"u\"]\n\n        # 2. Compute characteristic wave speeds\n        s_l = min(u_l - c_l, u_r - c_r)\n        s_r = max(u_l + c_l, u_r + c_r)\n\n        # 3. Compute HLLE intermediate conserved state U_star\n        if s_r - s_l == 0:\n            # This case implies U_L = U_R, so U_star is just U_L.\n            # Avoids division by zero, though unlikely with these tests.\n            U_star = U_l\n        else:\n            U_star = (s_r * U_r - s_l * U_l + F_l - F_r) / (s_r - s_l)\n        \n        rho_star_cons, m_star_cons, E_star_cons = U_star\n\n        # 4. Recover primitive variables from U_star\n        if rho_star_cons = 0:\n            # Unrecoverable state, density is non-positive\n            rho_star = rho_star_cons\n            u_star = 0.0\n            p_star = -1.0 # Clearly inadmissible\n        else:\n            rho_star = rho_star_cons\n            u_star = m_star_cons / rho_star\n            p_star = (gamma - 1.0) * (E_star_cons - 0.5 * rho_star * u_star**2)\n        \n        # 5. Check admissibility and apply positivity fix to pressure\n        is_admissible = (rho_star > 0.0) and (p_star > 0.0)\n\n        needs_fix = (rho_star = rho_floor) or (p_star = p_floor)\n\n        if needs_fix:\n            p_fixed = max(p_star, p_floor)\n        else:\n            p_fixed = p_star\n            \n        # 6. Store result\n        bool_str = \"true\" if is_admissible else \"false\"\n        result_str = f\"[{bool_str},{p_star},{p_fixed}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3484392"}, {"introduction": "近似黎曼求解器的选择需要在准确性、鲁棒性和计算成本之间进行权衡。本实践将对三种不同的求解器——HLLE、HLLC 和线性化的 PVRS——进行对比分析，测试它们在宇宙学中常见的极端近真空场景下的表现。这个练习将阐明每种方法的优缺点，为针对特定物理问题选择合适的求解器提供指导。[@problem_id:3484438]", "problem": "考虑数值宇宙学中的一维理想流体动力学黎曼问题，具体为一个真空-壁界面，该问题由欧拉方程和理想气体状态方程建模。设界面左右两侧的状态分别为 $(\\rho_L, u_L, p_L)$ 和 $(\\rho_R, u_R, p_R)$，绝热指数 $\\gamma = 5/3$。质量、动量和能量的控制守恒律是欧拉方程，热力学封闭关系是理想气体定律。假设整个问题使用无量纲单位；问题中的任何物理量都不需要物理单位。\n\n您的任务是为 Godunov 型方法实现三种不同的近似黎曼求解器，并分析它们在近真空界面情况下产生的星区状态的压力正定性：\n1. 使用鲁棒波速估计的两波 Harten–Lax–van Leer–Einfeldt (HLLE) 求解器。\n2. 使用鲁棒波速估计和接触波重构的三波 Harten–Lax–van Leer–Contact (HLLC) 求解器。\n3. 一种线性化压力-速度黎曼求解器 (PVRS)，它结合了线性化的压力和速度关系。\n\n从基本守恒律和理想气体封闭关系出发，为每种求解器构建算法表达式，用以计算界面处星区的压力，记为 $p^\\star$。对于 HLLE，使用与守恒跳跃条件一致的两波中间状态。对于 HLLC，包含接触间断并对其速度进行一致性估计，并从波关系中获得 $p^\\star$。对于线性化压力-速度求解器，从跨界面的压力和速度的对称线性化中获得 $p^\\star$。\n\n对于每种求解器和每个测试用例，确定压力正定性的布尔结果，该结果定义为界面星区压力是否满足 $p^\\star > 0$。每个测试用例的最终输出必须是一个包含三个布尔值的列表，按 [HLLE, HLLC, PVRS] 的顺序对应三种求解器。\n\n使用以下绝热指数和一组左右（真空-壁）状态的测试用例，其密度跨越 10 个数量级；所有量均为无量纲：\n- $\\gamma = 5/3$。\n- 测试用例 1（左侧近真空，右侧静态壁）：$(\\rho_L, u_L, p_L) = (10^{-10}, 0, 10^{-12})$，$(\\rho_R, u_R, p_R) = (1, 0, 1)$。\n- 测试用例 2（左侧近真空，右侧快速移动壁）：$(\\rho_L, u_L, p_L) = (10^{-10}, 0, 10^{-12})$，$(\\rho_R, u_R, p_R) = (1, 50, 1)$。\n- 测试用例 3（左侧壁，右侧近真空）：$(\\rho_L, u_L, p_L) = (1, 0, 1)$，$(\\rho_R, u_R, p_R) = (10^{-10}, 0, 10^{-12})$。\n- 测试用例 4（左侧近真空，右侧低压壁）：$(\\rho_L, u_L, p_L) = (10^{-10}, 0, 10^{-15})$，$(\\rho_R, u_R, p_R) = (1, 0, 10^{-5})$。\n\n对于每个测试用例：\n- 使用从局域状态和 Roe 平均状态导出的鲁棒左右波速估计，构建两波中间状态，并计算 HLLE 星区压力 $p^\\star_{\\mathrm{HLLE}}$。\n- 使用从守恒约束导出的接触波速度，重构跨接触间断的压力，并计算 HLLC 星区压力 $p^\\star_{\\mathrm{HLLC}}$。\n- 使用线性化压力-速度关系计算 PVRS 星区压力 $p^\\star_{\\mathrm{PVRS}}$。\n\n对于每个求解器，返回一个布尔值，指示是否 $p^\\star > 0$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应一个测试用例，其本身是一个按 [HLLE, HLLC, PVRS] 顺序排列的包含三个布尔值的列表，例如 $[[b_{11},b_{12},b_{13}],[b_{21},b_{22},b_{23}],\\ldots]$，其中每个 $b_{ij}$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n\n不涉及角度或物理单位；所有量均为无量纲。输出必须严格遵循指定的单行格式。", "solution": "该问题要求实现并分析三种不同的近似黎曼求解器，用于理想气体动力学的一维欧拉方程，特别是针对具有挑战性的真空-壁界面场景。目标是确定在界面处产生的中间区域（或“星区”）中的压力 $p^\\star$ 的正定性。\n\n控制定律是守恒形式的欧拉方程：\n$$\n\\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}(\\mathbf{U})}{\\partial x} = 0\n$$\n其中 $\\mathbf{U}$ 是守恒量向量，$\\mathbf{F}(\\mathbf{U})$ 是通量向量：\n$$\n\\mathbf{U} = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ E \\end{pmatrix}, \\quad \\mathbf{F}(\\mathbf{U}) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E+p) \\end{pmatrix}\n$$\n此处，$\\rho$ 是质量密度，$u$ 是流体速度，$p$ 是压力，$E$ 是总能量密度。该系统通过理想气体状态方程来封闭：\n$$\nE = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2\n$$\n其中 $\\gamma$ 是绝热指数，给定为 $\\gamma = 5/3$。声速为 $c = \\sqrt{\\gamma p / \\rho}$。\n\n黎曼问题在于求解欧拉方程，其初始条件由两个恒定状态组成：左状态 $(\\rho_L, u_L, p_L)$ 和右状态 $(\\rho_R, u_R, p_R)$，两者在 $x=0$ 处被一个间断分开。其解是自相似的，仅取决于相似性变量 $\\xi = x/t$。\n\n该分析需要对从间断处产生的最左 ($S_L$) 和最右 ($S_R$) 的波进行鲁棒的波速估计。我们采用 Einfeldt 提出的估计方法，该方法使用 Roe 平均量来确保鲁棒性。Roe 平均速度 $\\tilde{u}$ 和 Roe 平均焓 $\\tilde{h}$ 为：\n$$\n\\tilde{u} = \\frac{\\sqrt{\\rho_L}u_L + \\sqrt{\\rho_R}u_R}{\\sqrt{\\rho_L} + \\sqrt{\\rho_R}}, \\quad \\tilde{h} = \\frac{\\sqrt{\\rho_L}h_L + \\sqrt{\\rho_R}h_R}{\\sqrt{\\rho_L} + \\sqrt{\\rho_R}}\n$$\n其中对于 $K \\in \\{L, R\\}$，$h_K = (E_K + p_K) / \\rho_K$。Roe 平均声速 $\\tilde{c}$ 则为：\n$$\n\\tilde{c} = \\sqrt{(\\gamma-1)\\left(\\tilde{h} - \\frac{1}{2}\\tilde{u}^2\\right)}\n$$\n那么，波速估计为：\n$$\nS_L = \\min(u_L - c_L, \\tilde{u} - \\tilde{c}), \\quad S_R = \\max(u_R + c_R, \\tilde{u} + \\tilde{c})\n$$\n\n现在，我们为三种指定的求解器分别构建星区压力 $p^\\star$ 的表达式。\n\n**1. Harten–Lax–van Leer–Einfeldt (HLLE) 求解器**\nHLLE 求解器用一个单一的中间状态 $\\mathbf{U}_{\\mathrm{HLLE}}^\\star$ 来近似黎曼扇，该状态与左右状态之间由以速度 $S_L$ 和 $S_R$ 传播的波隔开。状态 $\\mathbf{U}_{\\mathrm{HLLE}}^\\star$ 是通过在控制体 $[-S_L \\Delta t, S_R \\Delta t]$ 上应用守恒律的积分形式得到的，这导出了平均状态的 Rankine-Hugoniot 条件：\n$$\n\\mathbf{U}_{\\mathrm{HLLE}}^\\star = \\frac{S_R \\mathbf{U}_R - S_L \\mathbf{U}_L - (\\mathbf{F}_R - \\mathbf{F}_L)}{S_R - S_L}\n$$\n设计算出的状态分量为 $\\mathbf{U}_{\\mathrm{HLLE}}^\\star = [\\rho^\\star, m^\\star, E^\\star]^T$。然后从总能量的定义中恢复压力 $p^\\star_{\\mathrm{HLLE}}$：\n$$\nE^\\star = \\frac{p^\\star_{\\mathrm{HLLE}}}{\\gamma-1} + \\frac{1}{2}\\rho^\\star (u^\\star)^2 = \\frac{p^\\star_{\\mathrm{HLLE}}}{\\gamma-1} + \\frac{(m^\\star)^2}{2\\rho^\\star}\n$$\n对压力进行整理，得到以下算法表达式：\n$$\np^\\star_{\\mathrm{HLLE}} = (\\gamma-1) \\left( E^\\star - \\frac{(m^\\star)^2}{2\\rho^\\star} \\right)\n$$\n该求解器以其鲁棒性著称，因为所选的波速能确保密度 $\\rho^\\star$ 的正定性，从而得到具有物理意义的压力。\n\n**2. Harten–Lax–van Leer–Contact (HLLC) 求解器**\nHLLC 求解器通过重新引入在 HLLE 中被平均掉的接触间断和剪切波，对 HLLE 模型进行了改进。它假设一个三波结构 $(S_L, S_\\star, S_R)$，其中 $S_\\star$ 是接触波的速度。流体速度和压力在接触间断上是恒定的，即 $u^\\star_L=u^\\star_R=S_\\star$ 和 $p^\\star_L=p^\\star_R=p^\\star$。速度 $S_\\star$ 是通过将守恒律应用于子结构而导出的：\n$$\nS_\\star = \\frac{p_R - p_L + \\rho_L u_L (S_L - u_L) - \\rho_R u_R (S_R - u_R)}{\\rho_L (S_L - u_L) - \\rho_R (S_R - u_R)}\n$$\n一旦确定了 $S_\\star$，就可以通过在左行波或右行波上应用 Rankine-Hugoniot 条件来找到星区压力 $p^\\star$。将其应用于左行波（在状态 L 和星区状态 *L 之间）可得：\n$$\np^\\star_{\\mathrm{HLLC}} = p_L + \\rho_L (u_L - S_L)(u_L - S_\\star)\n$$\n使用右侧状态也存在一个等价的表达式。虽然对于许多问题，HLLC 比 HLLE 更精确，但在涉及强膨胀或近真空状态的情况下，HLLC 可能无法保持压力正定性，本问题将探讨这一点。\n\n**3. 线性化压力-速度黎曼求解器 (PVRS)**\nPVRS，也称为声学求解器，将跨波的压力和速度变化之间的关系线性化。对于右行声波，$\\Delta p = \\rho c \\Delta u$，对于左行声波，$\\Delta p = -\\rho c \\Delta u$。这就得到了一个关于星区状态 $(u^\\star, p^\\star)$ 的二元线性方程组：\n$$\np^\\star-p_L = -(\\rho_L c_L) (u^\\star-u_L)\n$$\n$$\np^\\star-p_R = +(\\rho_R c_R) (u^\\star-u_R)\n$$\n其中 $Z_K = \\rho_K c_K = \\sqrt{\\gamma p_K \\rho_K}$ 是状态 K 的声阻抗。可以求解这个方程组得到 $p^\\star$。消去 $u^\\star$ 可得到星区压力的对称表达式：\n$$\np^\\star_{\\mathrm{PVRS}} = \\frac{p_L Z_R + p_R Z_L + Z_L Z_R(u_L - u_R)}{Z_L + Z_R}\n$$\n该求解器计算成本低，但基于声学近似，该近似仅对弱波精确。对于强激波或稀疏波，特别是那些产生近真空条件的波，它很容易产生非物理的负压。\n\n对所提供的测试用例，将布尔正定性测试 $p^\\star > 0$ 应用于由这三种方法计算出的压力。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the Riemann solver analysis for the given test cases.\n    \"\"\"\n\n    def _get_pressure_positivity(rho_L, u_L, p_L, rho_R, u_R, p_R, gamma):\n        \"\"\"\n        Computes the star-region pressure for HLLE, HLLC, and PVRS solvers\n        and returns a list of booleans indicating pressure positivity (p* > 0).\n        \"\"\"\n        \n        # --- Common Quantities ---\n        # Sound speeds\n        # Add a small epsilon to prevent division by zero or sqrt of zero if p or rho is exactly 0.\n        epsilon = 1e-100\n        c_L = np.sqrt(gamma * p_L / (rho_L + epsilon))\n        c_R = np.sqrt(gamma * p_R / (rho_R + epsilon))\n\n        # --- Solver 1: PVRS (Acoustic Solver) ---\n        p_star_pvrs = -1.0  # Default to negative\n        try:\n            Z_L = np.sqrt(gamma * p_L * rho_L)\n            Z_R = np.sqrt(gamma * p_R * rho_R)\n            denominator = Z_L + Z_R\n            if denominator > epsilon:\n                numerator = p_L * Z_R + p_R * Z_L + Z_L * Z_R * (u_L - u_R)\n                p_star_pvrs = numerator / denominator\n        except (ValueError, ZeroDivisionError):\n            pass # Keep default negative pressure\n\n\n        # --- Wave Speed Estimates (Einfeldt) for HLLE/HLLC ---\n        # Total energy densities\n        E_L = p_L / (gamma - 1) + 0.5 * rho_L * u_L**2\n        E_R = p_R / (gamma - 1) + 0.5 * rho_R * u_R**2\n        \n        # Specific enthalpies\n        h_L = (E_L + p_L) / (rho_L + epsilon)\n        h_R = (E_R + p_R) / (rho_R + epsilon)\n\n        # Roe averages\n        sqrt_rho_L = np.sqrt(rho_L)\n        sqrt_rho_R = np.sqrt(rho_R)\n        sqrt_rho_sum = sqrt_rho_L + sqrt_rho_R\n\n        u_tilde = (sqrt_rho_L * u_L + sqrt_rho_R * u_R) / (sqrt_rho_sum + epsilon)\n        h_tilde = (sqrt_rho_L * h_L + sqrt_rho_R * h_R) / (sqrt_rho_sum + epsilon)\n        \n        c_tilde_sq = (gamma - 1) * (h_tilde - 0.5 * u_tilde**2)\n        c_tilde = np.sqrt(c_tilde_sq) if c_tilde_sq > 0 else 0.0\n\n        # Einfeldt wave speeds\n        S_L = min(u_L - c_L, u_tilde - c_tilde)\n        S_R = max(u_R + c_R, u_tilde + c_tilde)\n        \n        p_star_hlle = -1.0 # Default to negative\n        p_star_hllc = -1.0 # Default to negative\n\n        if S_R > S_L:\n            # --- Solver 2: HLLE ---\n            # State vectors and Flux vectors\n            U_L = np.array([rho_L, rho_L * u_L, E_L])\n            U_R = np.array([rho_R, rho_R * u_R, E_R])\n            F_L = np.array([rho_L * u_L, rho_L * u_L**2 + p_L, u_L * (E_L + p_L)])\n            F_R = np.array([rho_R * u_R, rho_R * u_R**2 + p_R, u_R * (E_R + p_R)])\n            \n            U_star_hlle = (S_R * U_R - S_L * U_L - (F_R - F_L)) / (S_R - S_L)\n\n            rho_star_hlle = U_star_hlle[0]\n            m_star_hlle = U_star_hlle[1]\n            E_star_hlle = U_star_hlle[2]\n\n            if rho_star_hlle > epsilon:\n                 p_star_hlle = (gamma - 1) * (E_star_hlle - 0.5 * m_star_hlle**2 / rho_star_hlle)\n\n            # --- Solver 3: HLLC ---\n            denom_S_star = rho_L * (S_L - u_L) - rho_R * (S_R - u_R)\n            if abs(denom_S_star) > epsilon:\n                num_S_star = p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)\n                S_star = num_S_star / denom_S_star\n                p_star_hllc = p_L + rho_L * (u_L - S_L) * (u_L - S_star)\n\n        return [p_star_hlle > 0, p_star_hllc > 0, p_star_pvrs > 0]\n\n    # Define adiabatic index and test cases from the problem statement.\n    gamma = 5.0 / 3.0\n    test_cases = [\n        # ( (rho_L, u_L, p_L), (rho_R, u_R, p_R) )\n        ( (1e-10, 0.0, 1e-12), (1.0, 0.0, 1.0) ), # Case 1\n        ( (1e-10, 0.0, 1e-12), (1.0, 50.0, 1.0) ),# Case 2\n        ( (1.0, 0.0, 1.0), (1e-10, 0.0, 1e-12) ),# Case 3\n        ( (1e-10, 0.0, 1e-15), (1.0, 0.0, 1e-5) ), # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        state_L, state_R = case\n        rho_L, u_L, p_L = state_L\n        rho_R, u_R, p_R = state_R\n        \n        result = _get_pressure_positivity(rho_L, u_L, p_L, rho_R, u_R, p_R, gamma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The required format is [[b1,b2,b3],[c1,c2,c3],...], not string-based like \"[[True, ...]]\".\n    #\n    # The problem description's example format \"[[b11,b12,b13],[b21,b22,b23],...], where each bij is either True or False\" implies \n    # Python's list of lists representation. We will format the string to look exactly like this.\n    \n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3484438"}]}