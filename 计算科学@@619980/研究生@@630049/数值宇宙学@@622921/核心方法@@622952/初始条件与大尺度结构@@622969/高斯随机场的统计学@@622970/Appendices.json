{"hands_on_practices": [{"introduction": "在数值模拟中，我们通常在离散网格上从给定的功率谱生成高斯随机场。为了确保生成的实空间场是纯实数的（这在物理上是必须的），其傅里叶模式必须满足厄米共轭对称性。这个练习 ([@problem_id:3473758]) 旨在解决一个关键的实现细节：如何正确处理那些满足 $\\mathbf{k}=-\\mathbf{k}$ 的特殊“自共轭”模式（例如奈奎斯特频率模式），以在保持目标功率谱统计的同时严格执行场的实在性。", "problem": "您正在为一个统计上均匀且各向同性的高斯密度涨落场 $\\delta(\\mathbf{x})$ 生成初始条件。该场存在于一个边长为 $L$、体积为 $V=L^3$ 的周期性立方体盒子中，并在一个大小为 $N\\times N\\times N$（$N$为偶数）的偶数尺寸网格上采样。允许的离散波矢为 $\\mathbf{k}=\\frac{2\\pi}{L}(n_x,n_y,n_z)$，其中整数索引 $n_i\\in\\{0,1,\\dots,N-1\\}$，为了便于记录厄米对称性，这些索引可以映射到对称集合 $n_i\\in\\{-\\frac{N}{2}+1,\\dots,\\frac{N}{2}\\}$。离散傅里叶变换定义如下：\n$$\n\\delta(\\mathbf{x})=\\frac{1}{V}\\sum_{\\mathbf{k}}\\delta_{\\mathbf{k}}\\exp(i\\mathbf{k}\\cdot\\mathbf{x}),\\qquad \\delta_{\\mathbf{k}}=\\int_{V}\\delta(\\mathbf{x})\\exp(-i\\mathbf{k}\\cdot\\mathbf{x})\\,d^{3}x.\n$$\n假设以下经过充分检验的统计事实：\n- 场 $\\delta(\\mathbf{x})$ 是实数，因此它遵循厄米约束 $\\delta_{-\\mathbf{k}}=\\delta_{\\mathbf{k}}^{\\ast}$。\n- 两点统计量由功率谱 $P(k)$ 通过以下方式表征：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}'}^{\\ast}\\rangle=V\\,P(k)\\,\\delta_{\\mathbf{k},\\mathbf{k}'},\n$$\n其中 $\\delta_{\\mathbf{k},\\mathbf{k}'}$ 是克罗内克δ函数，且 $k=|\\mathbf{k}|$。\n\n在偶数网格上，存在特殊的自共轭模式，它们满足 $\\mathbf{k}\\equiv -\\mathbf{k}$（模网格），这种情况发生当且仅当每个分量索引为 $0$ 或 $N/2$。这些模式包括零模式 $\\mathbf{k}=\\mathbf{0}$ 和一个或多个分量处于奈奎斯特索引的奈奎斯特模式。在生成与上述定义一致的高斯随机场时，您必须确保 $\\delta(\\mathbf{x})$ 的实数性以及傅里叶模式的正确高斯统计特性。\n\n从上面给出的定义和事实出发（不使用任何其他公式），推导为任何非零自共轭模式（即 $\\mathbf{k}\\neq\\mathbf{0}$ 且每个分量为 $0$ 或奈奎斯特波数）采样 $\\delta_{\\mathbf{k}}$ 所用的单个实高斯变量应分配的正确方差，以使生成的场保持实数性并具有目标功率谱。您的答案应表示为以 $V$ 和 $P(k)$ 表示的闭合形式解析表达式。您还应在推导过程中证明如何处理零模式以保持具有物理意义的密度涨落。您的最终答案必须是一个单一的解析表达式。不需要四舍五入，最终表达式中也不应包含单位，因为根据定义 $\\delta$ 是无量纲的。", "solution": "该问题陈述经过了仔细验证，并被确定为有效。它在科学上植根于数值宇宙学原理，是良定的、客观的且内部一致的。进行严格推导所需的所有信息都已提供。\n\n目标是确定用于对非零自共轭模式 $\\mathbf{k}$ 的傅里叶模式 $\\delta_{\\mathbf{k}}$ 进行采样的实值高斯随机变量的方差。自共轭模式定义为满足 $\\mathbf{k} \\equiv -\\mathbf{k}$（模网格的倒格矢）的模式。在一个大小为 $N\\times N\\times N$ 的偶数尺寸网格上，这些是整数索引向量 $(n_x, n_y, n_z)$ 的每个分量为 $0$ 或 $N/2$ 的模式。问题要求计算当 $\\mathbf{k} \\neq \\mathbf{0}$ 时这些模式的方差。\n\n我们从密度涨落场 $\\delta(\\mathbf{x})$ 及其傅里叶变换 $\\delta_{\\mathbf{k}}$ 的基本性质开始。\n\n首先，场 $\\delta(\\mathbf{x})$ 是一个实值函数。这对它的傅里叶系数施加了一个厄米对称性约束：\n$$\n\\delta_{-\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}\n$$\n其中星号表示复共轭。\n\n其次，高斯随机场的统计性质由功率谱 $P(k)$ 通过傅里叶模式的两点相关函数来定义：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}'}^{\\ast}\\rangle = V\\,P(k)\\,\\delta_{\\mathbf{k},\\mathbf{k}'}\n$$\n其中 $V$ 是盒子的体积，$k=|\\mathbf{k}|$，$\\delta_{\\mathbf{k},\\mathbf{k}'}$ 是克罗内克δ函数。尖括号 $\\langle\\dots\\rangle$ 表示系综平均。\n\n现在让我们考虑一个非零自共轭模式 $\\mathbf{k}$。对于这样的模式，波矢 $\\mathbf{k}$ 是其自身的负值（在相差一个倒格矢的意义下，这对网格上的离散模式是无关紧要的）。因此，厄米对称性约束变为：\n$$\n\\delta_{\\mathbf{k}} = \\delta_{-\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}\n$$\n一个等于其自身共轭的复数必须是纯实数。如果我们将 $\\delta_{\\mathbf{k}}$ 写成其实部和虚部的形式，$\\delta_{\\mathbf{k}} = \\text{Re}(\\delta_{\\mathbf{k}}) + i\\,\\text{Im}(\\delta_{\\mathbf{k}})$，那么条件 $\\delta_{\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}$ 意味着 $\\text{Im}(\\delta_{\\mathbf{k}}) = 0$。因此，对于任何自共轭模式，傅里叶系数 $\\delta_{\\mathbf{k}}$ 都是一个实数。\n\n为了生成该场，我们从一个高斯分布中采样 $\\delta_{\\mathbf{k}}$。由于对于自共轭模式，$\\delta_{\\mathbf{k}}$ 必须是实数，因此它是从一个实高斯分布中抽取的。问题要求计算这个分布的方差。根据定义，一个零均值随机变量 $X$ 的方差是 $\\langle X^2 \\rangle$。一个零均值随机场的傅里叶模式也具有零均值，即 $\\langle \\delta_{\\mathbf{k}} \\rangle = 0$。因此，我们需要计算 $\\langle \\delta_{\\mathbf{k}}^2 \\rangle$。\n\n我们将给定的功率谱定义应用于 $\\mathbf{k}' = \\mathbf{k}$ 的特定情况：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}}^{\\ast}\\rangle = V\\,P(k)\n$$\n由于我们已经确定对于自共轭模式 $\\delta_{\\mathbf{k}}$ 是实数，所以我们有 $\\delta_{\\mathbf{k}}^{\\ast} = \\delta_{\\mathbf{k}}$。将此代入上式可得：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}}\\rangle = \\langle \\delta_{\\mathbf{k}}^2 \\rangle = V\\,P(k)\n$$\n这个结果恰好是用于采样模式 $\\delta_{\\mathbf{k}}$ 的单个实高斯变量的方差。这对任何非零自共轭模式都成立。\n\n作为对比，对于一个一般的非自共轭模式 $\\mathbf{k}$（其中 $\\mathbf{k} \\neq -\\mathbf{k}$），$\\delta_{\\mathbf{k}}$ 是一个复数，$\\delta_{\\mathbf{k}} = A_{\\mathbf{k}} + iB_{\\mathbf{k}}$，其中 $A_{\\mathbf{k}}$ 和 $B_{\\mathbf{k}}$ 是独立的实高斯变量。在这种情况下，$\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}}^{\\ast} \\rangle = \\langle (A_{\\mathbf{k}} + iB_{\\mathbf{k}})(A_{\\mathbf{k}} - iB_{\\mathbf{k}}) \\rangle = \\langle A_{\\mathbf{k}}^2 + B_{\\mathbf{k}}^2 \\rangle$。由于统计各向同性，实部和虚部的方差相等，即 $\\langle A_{\\mathbf{k}}^2 \\rangle = \\langle B_{\\mathbf{k}}^2 \\rangle$。因此，$2\\langle A_{\\mathbf{k}}^2 \\rangle = V P(k)$，这给出 $\\langle A_{\\mathbf{k}}^2 \\rangle = \\langle B_{\\mathbf{k}}^2 \\rangle = \\frac{1}{2}V P(k)$。分配给一般复数模式的实部和虚部的方差是分配给纯实数自共轭模式方差的一半。\n\n最后，问题要求对零模式 $\\mathbf{k}=\\mathbf{0}$ 的处理方式作出合理解释。零模式是最基本的自共轭模式。它的值由傅里叶变换定义给出：\n$$\n\\delta_{\\mathbf{k}=\\mathbf{0}} = \\int_{V} \\delta(\\mathbf{x}) \\exp(-i\\mathbf{0} \\cdot \\mathbf{x})\\,d^3x = \\int_{V} \\delta(\\mathbf{x})\\,d^3x\n$$\n这是密度涨落场在整个体积上的积分。密度涨落定义为 $\\delta(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$，其中 $\\bar{\\rho}$ 是宇宙的平均密度。根据定义，$\\delta(\\mathbf{x})$ 在一个公平的、具有代表性的体积上的空间平均值必须为零。我们的模拟盒子被假定为这样一个体积。因此，我们必须强制执行：\n$$\n\\frac{1}{V}\\int_{V}\\delta(\\mathbf{x})\\,d^3x = 0 \\implies \\int_{V}\\delta(\\mathbf{x})\\,d^3x = 0\n$$\n这意味着 $\\delta_{\\mathbf{k}=\\mathbf{0}}$ 必须根据定义设置为 $0$。它不是一个从分布中抽取的随机变量；它的值是固定的，以保持与密度涨落定义的一致性。这个物理约束正是问题为什么正确地要求计算*非零*自共轭模式的方差的原因。\n\n总之，对于任何非零自共轭模式 $\\mathbf{k}$，其傅里叶系数 $\\delta_{\\mathbf{k}}$ 必须是实数，并且从中抽取它的高斯分布的方差是 $V P(k)$。", "answer": "$$\\boxed{V P(k)}$$", "id": "3473758"}, {"introduction": "在宇宙学中，观测到的场由于红移空间畸变（RSD）等效应而呈现各向异性，通常通过功率谱的勒让德多极矩来进行分析。本练习 ([@problem_id:3490700]) 提供了一个综合性任务，要求您对一个各向异性的高斯场进行建模，并量化巡天窗口函数如何混合这些多极矩，从而扭曲我们对真实宇宙学信号的测量。这项实践模拟了观测宇宙学中一个真实的数据分析流程，从理论推导到数值实现。", "problem": "您的任务是开发一个完整的、可运行的程序，该程序通过方向性功率谱对各向异性高斯随机场中的红移空间畸变进行建模，将该场投影到勒让德多极矩上，在高斯假设下推导并评估这些多极矩的协方差，并量化由方向性选择傅里叶模式的各向异性巡天窗口引入的多极矩之间的模式混合。[@problem_id:159] 所有计算都必须以无量纲量的纯数学术语进行，所有最终的数值输出都应表示为不带物理单位的浮点数。\n\n考虑一个统计均匀的高斯随机场，其傅里叶模式为 $\\delta(\\mathbf{k})$，使得傅里叶空间中的两点函数通过功率谱定义为\n$$\n\\langle \\delta(\\mathbf{k})\\,\\delta^{\\ast}(\\mathbf{k}^{\\prime})\\rangle = (2\\pi)^{3}\\,\\delta_{\\mathrm{D}}^{3}(\\mathbf{k}-\\mathbf{k}^{\\prime})\\,P(k,\\mu),\n$$\n其中 $k=\\lVert \\mathbf{k}\\rVert$ 且 $\\mu=\\cos\\theta$，$\\theta$ 是 $\\mathbf{k}$ 与固定视线轴之间的夹角。假设一个形式如下的各向异性红移空间功率谱\n$$\nP(k,\\mu) = S(k)\\,\\left(1+\\beta\\,\\mu^{2}\\right)^{2},\n$$\n其中 $\\beta$ 是一个常数，$S(k)$ 是一个光滑的非负形状函数。令 $L_{\\ell}(\\mu)$ 表示 $\\ell$ 阶勒让德多项式，并将 $P(k,\\mu)$ 的勒让德多极矩定义为\n$$\nP_{\\ell}(k) = \\frac{2\\ell+1}{2}\\int_{-1}^{1} \\mathrm{d}\\mu\\, P(k,\\mu)\\,L_{\\ell}(\\mu).\n$$\n\n假设在一个有限的周期性巡天体积 $V$ 中，估计量是在以 $k$ 为中心、宽度为 $\\Delta k$ 的球形 $k$-壳层上形成的。将这样一个壳层中的独立傅里叶模式数定义为\n$$\nN_{\\mathrm{m}}(k;\\Delta k,V) \\equiv \\frac{V}{(2\\pi)^{3}}\\int_{k-\\Delta k/2}^{k+\\Delta k/2}\\mathrm{d}k^{\\prime}\\, 4\\pi\\,k^{\\prime 2} \\approx \\frac{V\\,4\\pi\\,k^{2}\\,\\Delta k}{(2\\pi)^{3}} = \\frac{V\\,k^{2}\\,\\Delta k}{2\\pi^{2}}.\n$$\n\nA 部分（推导）：从 $\\delta(\\mathbf{k})$ 的高斯性及以上定义出发，推导通过将壳层平均功率谱投影到 $L_{\\ell}(\\mu)$ 上而形成的勒让德多极矩估计量的高斯协方差，\n$$\n\\widehat{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, \\widehat{P}(k,\\mu)\\,L_{\\ell}(\\mu),\n$$\n其中 $\\widehat{P}(k,\\mu)$ 表示在固定 $(k,\\mu)$ 处的壳层平均功率。您的推导必须将 $\\mathrm{Cov}\\!\\left[\\widehat{P}_{\\ell}(k),\\widehat{P}_{\\ell^{\\prime}}(k)\\right]$ 完全用 $N_{\\mathrm{m}}(k;\\Delta k,V)$ 以及涉及 $L_{\\ell}(\\mu)$、$L_{\\ell^{\\prime}}(\\mu)$ 和 $P(k,\\mu)$ 的关于 $\\mu$ 的积分来表示。您的最终表达式应为 $\\mu$ 的一维积分，并且必须反映功率谱方差的适当高斯因子 $2$。\n\nB 部分（由窗口引起的模式混合）：现在假设巡天窗口通过一个已知的、不依赖于 $k$ 的非负权重函数 $W(\\mu) \\ge 0$ 在方向上各向异性地选择傅里叶模式。未对此方向性选择进行校正而计算出的伪多极矩估计量为\n$$\n\\widetilde{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,P(k,\\mu)\\,L_{\\ell}(\\mu).\n$$\n假设 $P(k,\\mu)$ 允许勒让德级数展开 $P(k,\\mu)=\\sum_{\\ell^{\\prime}}P_{\\ell^{\\prime}}(k)\\,L_{\\ell^{\\prime}}(\\mu)$，推导线性混合关系\n$$\n\\widetilde{P}_{\\ell}(k)=\\sum_{\\ell^{\\prime}} M_{\\ell\\ell^{\\prime}}\\,P_{\\ell^{\\prime}}(k),\n$$\n并获得混合矩阵 $M_{\\ell\\ell^{\\prime}}$ 的一个显式表达式，该表达式用涉及 $W(\\mu)$ 以及 $L_{\\ell}(\\mu)$ 和 $L_{\\ell^{\\prime}}(\\mu)$ 乘积的关于 $\\mu$ 的积分表示。证明当 $W(\\mu)=1$ 时，$M_{\\ell\\ell^{\\prime}}$ 简化为单位矩阵。\n\n实现要求：实现一个程序，使用 $\\mu$ 上的高斯-勒让德求积法数值计算以下量，并为提供的测试套件输出结果。使用 $S(k)=A\\,k^{n}\\,\\exp\\!\\left(-k^{2}/k_{c}^{2}\\right)$，参数按每个测试用例指定。您必须评估 $\\ell\\in\\{0,2,4\\}$ 的勒让德多项式 $L_{\\ell}(\\mu)$，并以足够的求积分辨率执行所有必要的积分，以确保所报告的值收敛到至少 $10^{-8}$ 的绝对精度。\n\n测试套件和要求输出：\n\n- 测试 $1$（单位混合检查）：设置 $W(\\mu)=1$（等效于在窗口参数化 $W(\\mu)=1+\\alpha\\,L_{2}(\\mu)$ 中设置参数 $\\alpha=0$），并为 $\\ell,\\ell^{\\prime}\\in\\{0,2,4\\}$ 计算 $3\\times 3$ 混合矩阵 $M_{\\ell\\ell^{\\prime}}$。报告一个浮点数，等于 $M$ 的最大绝对非对角元素。\n- 测试 $2$（各向异性混合项）：设置 $W(\\mu)=1+\\alpha\\,L_{2}(\\mu)$ 且 $\\alpha=0.5$，并为 $\\ell,\\ell^{\\prime}\\in\\{0,2,4\\}$ 计算 $M_{\\ell\\ell^{\\prime}}$。按此顺序报告三个浮点数 $\\left(M_{0,2},\\,M_{2,2},\\,M_{2,4}\\right)$。\n- 测试 $3$（协方差互相关，各向同性与各向异性红移空间）：使用 $k=0.15$, $\\Delta k=0.02$, $V=(1500)^{3}$, $A=1.0$, $n=1.0$, $k_{c}=0.3$，并在两种情况下评估 $\\ell,\\ell^{\\prime}\\in\\{0,2,4\\}$ 的高斯协方差积分：\n  - 情况 $(a)$：$\\beta=0.0$。\n  - 情况 $(b)$：$\\beta=0.5$。\n  对于每种情况，计算单极矩和四极矩估计量之间的皮尔逊相关系数，定义为\n  $$\n  \\rho_{0,2}(k) = \\frac{\\mathrm{Cov}\\!\\left[\\widehat{P}_{0}(k),\\widehat{P}_{2}(k)\\right]}{\\sqrt{\\mathrm{Cov}\\!\\left[\\widehat{P}_{0}(k),\\widehat{P}_{0}(k)\\right]\\;\\mathrm{Cov}\\!\\left[\\widehat{P}_{2}(k),\\widehat{P}_{2}(k)\\right]}}.\n  $$\n  按此顺序报告两个浮点数 $\\left(\\rho_{0,2}^{(\\beta=0.0)},\\,\\rho_{0,2}^{(\\beta=0.5)}\\right)$。\n- 测试 $4$（模式计数）：对于 $k=0.15$, $\\Delta k=0.02$, $V=(1500)^{3}$，使用上面给出的近似值计算并报告浮点数 $N_{\\mathrm{m}}(k;\\Delta k,V)$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_{1},r_{2},r_{3},r_{4},r_{5},r_{6},r_{7}]$），按顺序汇总来自测试 $1$、测试 $2$（三个数）、测试 $3$（两个数）和测试 $4$ 的输出。\n\n重要规则：\n\n- 所有计算必须是完全确定性的和自包含的，没有用户输入。\n- 所有输出必须是数值浮点数，并严格按照指定的顺序和格式收集。\n- 全程使用无量纲量；不报告任何物理单位。", "solution": "该问题要求推导功率谱多极矩估计量的协方差和由各向异性巡天窗口引起的模式混合矩阵的解析表达式，然后通过数值实现来为一组给定的测试用例评估这些量。\n\n### A 部分：多极矩估计量协方差的推导\n\n起点是傅里叶空间中一个统计上均匀且各向同性的复高斯随机场 $\\delta(\\mathbf{k})$。其两点相关函数由下式给出：\n$$\n\\langle \\delta(\\mathbf{k})\\,\\delta^{\\ast}(\\mathbf{k}^{\\prime})\\rangle = (2\\pi)^{3}\\,\\delta_{\\mathrm{D}}^{3}(\\mathbf{k}-\\mathbf{k}^{\\prime})\\,P(k,\\mu)\n$$\n其中 $P(k,\\mu)$ 是各向异性功率谱，$k = \\lVert\\mathbf{k}\\rVert$，$\\mu = \\hat{\\mathbf{k}}\\cdot\\hat{\\mathbf{z}}$，$\\hat{\\mathbf{z}}$ 是一个固定的视线方向。\n\n功率谱的估计量 $\\widehat{P}(k,\\mu)$ 是通过在傅里叶空间中，在给定半径 $k$ 和极角 $\\cos^{-1}\\mu$ 的薄壳层上对 $|\\delta(\\mathbf{k})|^2$ 进行平均来构建的。对于高斯场，壳层上不同角位置 $(\\mu, \\phi)$ 的功率谱估计量的涨落是统计独立的。对于包含 $N_{\\text{modes}}$ 个独立模式的区域，功率谱估计的方差为 $\\mathrm{Var}[\\widehat{P}] = 2P^2/N_{\\text{modes}}$。因子 $2$ 的出现是因为实空间中的潜在密度场是实数，这意味着 $\\delta(-\\mathbf{k}) = \\delta^*(\\mathbf{k})$。\n\n半径为 $k$、宽度为 $\\Delta k$ 的球壳中的独立模式总数由 $N_{\\mathrm{m}}(k) = \\frac{V k^2 \\Delta k}{2\\pi^2}$ 给出。这些模式均匀分布在 $4\\pi$ 的立体角上。在壳层上位于 $\\mu$ 和 $\\mu+\\mathrm{d}\\mu$ 之间的薄环形区域内的模式数与该环形区域的面积成正比，其面积为 $2\\pi \\sin\\theta \\mathrm{d}\\theta = 2\\pi \\mathrm{d}\\mu$。此环形区域占总立体角的分数为 $(2\\pi \\mathrm{d}\\mu)/(4\\pi) = \\mathrm{d}\\mu/2$。因此，此环形区域内的模式数为 $\\mathrm{d}N_{\\mathrm{m}} = N_{\\mathrm{m}}(k) \\frac{\\mathrm{d}\\mu}{2}$。\n\n壳层平均估计量 $\\widehat{P}(k,\\mu)$ 和 $\\widehat{P}(k,\\mu')$ 的协方差可以建模为在 $\\mu$ 上是局域的，这反映了不同环形区域的统计独立性：\n$$\n\\mathrm{Cov}\\left[\\widehat{P}(k,\\mu), \\widehat{P}(k,\\mu')\\right] = \\frac{2 [P(k,\\mu)]^2}{\\text{单位 } \\mu \\text{ 的模式数}} \\delta_{\\mathrm{D}}(\\mu-\\mu') = \\frac{2 [P(k,\\mu)]^2}{N_{\\mathrm{m}}(k)/2} \\delta_{\\mathrm{D}}(\\mu-\\mu') = \\frac{4 [P(k,\\mu)]^2}{N_{\\mathrm{m}}(k)} \\delta_{\\mathrm{D}}(\\mu-\\mu')\n$$\n勒让德多极矩估计量被定义为 $\\widehat{P}(k,\\mu)$ 的投影：\n$$\n\\widehat{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1} \\mathrm{d}\\mu\\, \\widehat{P}(k,\\mu)\\,L_{\\ell}(\\mu)\n$$\n两个这样的估计量 $\\widehat{P}_{\\ell}(k)$ 和 $\\widehat{P}_{\\ell'}(k)$ 之间的协方差是\n$$\n\\mathrm{Cov}\\!\\left[\\widehat{P}_{\\ell}(k),\\widehat{P}_{\\ell^{\\prime}}(k)\\right] = \\left\\langle (\\widehat{P}_{\\ell}(k)-P_{\\ell}(k)) (\\widehat{P}_{\\ell^{\\prime}}(k)-P_{\\ell^{\\prime}}(k)) \\right\\rangle\n$$\n$$\n= \\frac{(2\\ell+1)(2\\ell^{\\prime}+1)}{4} \\int_{-1}^{1}\\mathrm{d}\\mu \\int_{-1}^{1}\\mathrm{d}\\mu' L_{\\ell}(\\mu)L_{\\ell^{\\prime}}(\\mu') \\mathrm{Cov}\\!\\left[\\widehat{P}(k,\\mu),\\widehat{P}(k,\\mu')\\right]\n$$\n代入微分协方差的表达式：\n$$\n= \\frac{(2\\ell+1)(2\\ell^{\\prime}+1)}{4} \\int_{-1}^{1}\\mathrm{d}\\mu \\int_{-1}^{1}\\mathrm{d}\\mu' L_{\\ell}(\\mu)L_{\\ell^{\\prime}}(\\mu') \\frac{4 [P(k,\\mu)]^2}{N_{\\mathrm{m}}(k)} \\delta_{\\mathrm{D}}(\\mu-\\mu')\n$$\n用狄拉克δ函数 $\\delta_{\\mathrm{D}}(\\mu-\\mu')$ 对 $\\mu'$ 进行积分，得到最终结果：\n$$\n\\mathrm{Cov}\\!\\left[\\widehat{P}_{\\ell}(k),\\widehat{P}_{\\ell^{\\prime}}(k)\\right] = \\frac{(2\\ell+1)(2\\ell^{\\prime}+1)}{N_{\\mathrm{m}}(k)} \\int_{-1}^{1} \\mathrm{d}\\mu\\, [P(k,\\mu)]^2 L_{\\ell}(\\mu) L_{\\ell^{\\prime}}(\\mu)\n$$\n该表达式正确地将协方差与功率谱平方的积分联系起来，该积分由勒让德多项式加权，并与模式数 $N_{\\mathrm{m}}(k)$ 成反比。对于各向同性功率谱 $P(k,\\mu) = P_0(k)$，单极矩估计量 $\\widehat{P}_0(k)$ 的方差变为 $\\mathrm{Var}[\\widehat{P}_0(k)] = \\frac{1}{N_{\\mathrm{m}}(k)}\\int_{-1}^{1} [P_0(k)]^2 \\mathrm{d}\\mu = \\frac{2 [P_0(k)]^2}{N_{\\mathrm{m}}(k)}$，这是反映“高斯因子2”的标准结果。\n\n### B 部分：模式混合矩阵的推导\n\n各向异性巡天窗口引入了一个方向性权重 $W(\\mu)$，从而修改了多极矩估计量。产生的“伪多极矩”估计量为\n$$\n\\widetilde{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,P(k,\\mu)\\,L_{\\ell}(\\mu)\n$$\n真实的潜在功率谱 $P(k,\\mu)$ 可以用勒让德级数展开，其系数 $P_{\\ell'}(k)$ 是真实的多极矩：\n$$\nP(k,\\mu) = \\sum_{\\ell'=0}^{\\infty} P_{\\ell'}(k)\\,L_{\\ell'}(\\mu)\n$$\n将此展开式代入 $\\widetilde{P}_{\\ell}(k)$ 的定义中：\n$$\n\\widetilde{P}_{\\ell}(k) = \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\, \\left(\\sum_{\\ell'=0}^{\\infty} P_{\\ell'}(k)\\,L_{\\ell'}(\\mu)\\right) L_{\\ell}(\\mu)\n$$\n假设级数一致收敛，我们可以交换求和与积分的顺序：\n$$\n\\widetilde{P}_{\\ell}(k) = \\sum_{\\ell'=0}^{\\infty} \\left( \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,L_{\\ell}(\\mu)\\,L_{\\ell'}(\\mu) \\right) P_{\\ell'}(k)\n$$\n这是一个形式为 $\\widetilde{P}_{\\ell}(k)=\\sum_{\\ell'} M_{\\ell\\ell^{\\prime}}\\,P_{\\ell^{\\prime}}(k)$ 的线性关系，其中混合矩阵 $M_{\\ell\\ell^{\\prime}}$ 被确定为：\n$$\nM_{\\ell\\ell^{\\prime}} = \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,L_{\\ell}(\\mu)\\,L_{\\ell^{\\prime}}(\\mu)\n$$\n如果窗口函数是均匀的，$W(\\mu)=1$，矩阵元素变为：\n$$\nM_{\\ell\\ell^{\\prime}} = \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\,L_{\\ell}(\\mu)\\,L_{\\ell^{\\prime}}(\\mu)\n$$\n使用勒让德多项式的正交关系 $\\int_{-1}^{1}L_{\\ell}(\\mu)L_{\\ell'}(\\mu)\\mathrm{d}\\mu = \\frac{2}{2\\ell+1}\\delta_{\\ell\\ell'}$，我们发现：\n$$\nM_{\\ell\\ell^{\\prime}} = \\frac{2\\ell+1}{2} \\left( \\frac{2}{2\\ell+1}\\delta_{\\ell\\ell'} \\right) = \\delta_{\\ell\\ell'}\n$$\n因此，对于均匀窗口，混合矩阵是单位矩阵，多极矩之间没有混合，正如预期的那样。\n\n### 数值实现\n\n推导出的公式通过数值方法实现，以解决这些测试用例。实现的核心是对 $\\mu \\in [-1, 1]$ 上的一维积分进行求值。由于所有被积函数都是 $\\mu$ 的多项式，高精度的高斯-勒让德求积法是一种精确且高效的方法。我们选择求积阶数 $N_{\\text{quad}}=100$，这足以将所产生的多项式积分到机器精度。所需的勒让德多项式 $L_0(\\mu)$、$L_2(\\mu)$ 和 $L_4(\\mu)$ 被实现为显式函数。\n\n- **测试 1**：对于均匀窗口 $W(\\mu)=1$，计算 $\\ell, \\ell' \\in \\{0,2,4\\}$ 的混合矩阵 $M_{\\ell\\ell'}$。每个矩阵元素的积分通过求积法计算。报告最大的绝对非对角元素，其值在数值上应为零。\n- **测试 2**：对于各向异性窗口 $W(\\mu)=1+0.5L_2(\\mu)$，计算 $M_{\\ell\\ell'}$。使用相同的求积方法计算所需的元素 $(M_{0,2}, M_{2,2}, M_{2,4})$。\n- **测试 3**：计算皮尔逊相关系数 $\\rho_{0,2} = \\mathrm{Cov}_{02}/\\sqrt{\\mathrm{Cov}_{00}\\mathrm{Cov}_{22}}$。协方差项与形如 $\\int_{-1}^{1} [P(k,\\mu)]^2 L_{\\ell}(\\mu) L_{\\ell'}(\\mu) \\mathrm{d}\\mu$ 的积分成正比。公共的前置因子 $S(k)^2$ 和 $1/N_{\\mathrm{m}}(k)$ 在比率中被抵消，简化了计算。\n  - 对于情况 (a)，$\\beta=0.0$，功率谱 $P(k,\\mu)$ 是各向同性的。$\\mathrm{Cov}_{02}$ 的积分包含 $L_0(\\mu)L_2(\\mu)$，由于正交性，其积分为零。因此，解析上 $\\rho_{0,2}=0$。\n  - 对于情况 (b)，$\\beta=0.5$，被积函数 $[P(k,\\mu)]^2 = S(k)^2(1+0.5\\mu^2)^4$ 是各向异性的。通过数值计算 $\\mathrm{Cov}_{00}$、$\\mathrm{Cov}_{22}$ 和 $\\mathrm{Cov}_{02}$ 所需的积分来求得 $\\rho_{0,2}$。\n- **测试 4**：使用给定的公式 $N_{\\mathrm{m}} = V k^2 \\Delta k / (2\\pi^2)$ 和给定的参数值直接计算模式数 $N_{\\mathrm{m}}$。\n\n所有测试的结果被汇总到一个列表中，用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes redshift-space distortion quantities based on the problem statement.\n    \"\"\"\n\n    # --- Problem Setup ---\n    # Number of quadrature points for numerical integration.\n    # The integrands are low-degree polynomials, so this is highly accurate.\n    N_QUAD = 100\n    # Required multipole indices\n    ells = [0, 2, 4]\n\n    # Gauss-Legendre quadrature points and weights over [-1, 1]\n    mu, w = np.polynomial.legendre.leggauss(N_QUAD)\n\n    # --- Helper Functions ---\n    def get_legendre_poly(ell):\n        \"\"\"Returns a function for the Legendre polynomial L_ell(mu).\"\"\"\n        if ell == 0:\n            return np.ones_like\n        elif ell == 2:\n            return lambda x: 0.5 * (3 * x**2 - 1)\n        elif ell == 4:\n            return lambda x: 0.125 * (35 * x**4 - 30 * x**2 + 3)\n        else:\n            raise ValueError(f\"Legendre polynomial for l={ell} not required by the problem.\")\n\n    legendre_funcs = {ell: get_legendre_poly(ell) for ell in ells}\n    \n    # This list will store the final results in order.\n    results = []\n\n    # --- Test 1: Identity mixing check ---\n    alpha_1 = 0.0\n    W_1 = 1.0 + alpha_1 * legendre_funcs[2](mu)\n    \n    M_1 = np.zeros((3, 3))\n    \n    for i, ell in enumerate(ells):\n        for j, ell_prime in enumerate(ells):\n            L_ell = legendre_funcs[ell](mu)\n            L_ell_prime = legendre_funcs[ell_prime](mu)\n            integrand = W_1 * L_ell * L_ell_prime\n            integral = np.sum(integrand * w)\n            M_1[i, j] = (2 * ell + 1) / 2.0 * integral\n    \n    off_diag_M_1 = M_1[~np.eye(3, dtype=bool)]\n    max_abs_off_diag = np.max(np.abs(off_diag_M_1))\n    results.append(max_abs_off_diag)\n\n    # --- Test 2: Anisotropic mixing entries ---\n    alpha_2 = 0.5\n    W_2 = 1.0 + alpha_2 * legendre_funcs[2](mu)\n    \n    M_2 = np.zeros((3, 3))\n    for i, ell in enumerate(ells):\n        for j, ell_prime in enumerate(ells):\n            L_ell = legendre_funcs[ell](mu)\n            L_ell_prime = legendre_funcs[ell_prime](mu)\n            integrand = W_2 * L_ell * L_ell_prime\n            integral = np.sum(integrand * w)\n            M_2[i, j] = (2 * ell + 1) / 2.0 * integral\n            \n    m02 = M_2[0, 1]  # ell=0, ell'=2\n    m22 = M_2[1, 1]  # ell=2, ell'=2\n    m24 = M_2[1, 2]  # ell=2, ell'=4\n    results.extend([m02, m22, m24])\n    \n    # --- Test 3: Covariance cross-correlation ---\n    # Case (a): beta = 0.0\n    # For an isotropic field, Cov(P_0, P_2) = 0, so rho_02 = 0.\n    rho_02_a = 0.0\n    results.append(rho_02_a)\n    \n    # Case (b): beta = 0.5\n    beta_b = 0.5\n    # The integrand part depending on mu is ( (1+beta*mu^2)^2 )^2\n    P_mu_part_sq = (1 + beta_b * mu**2)**4\n    \n    def compute_cov_integral(ell, ell_prime):\n        L_ell = legendre_funcs[ell](mu)\n        L_ell_prime = legendre_funcs[ell_prime](mu)\n        integrand = P_mu_part_sq * L_ell * L_ell_prime\n        return np.sum(integrand * w)\n\n    # The correlation coefficient rho_02 simplifies to I_02 / sqrt(I_00 * I_22)\n    # where I_ll' is the integral part of the covariance formula.\n    I_00 = compute_cov_integral(0, 0)\n    I_22 = compute_cov_integral(2, 2)\n    I_02 = compute_cov_integral(0, 2)\n    \n    # The prefactors (2l+1) cancel in the Pearson correlation coefficient.\n    # rho_02 = [(1*5)*I_02] / sqrt([(1*1)*I_00] * [(5*5)*I_22]) = I_02 / sqrt(I_00*I_22)\n    rho_02_b = I_02 / np.sqrt(I_00 * I_22)\n    results.append(rho_02_b)\n    \n    # --- Test 4: Mode count ---\n    V = 1500.0**3\n    k_4 = 0.15\n    delta_k_4 = 0.02\n    \n    N_m = (V * k_4**2 * delta_k_4) / (2 * np.pi**2)\n    results.append(N_m)\n\n    # --- Final Output ---\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3490700"}, {"introduction": "科学研究的最终环节之一是将理论模型与数据进行比较，以推断模型的潜在参数。在这个练习 ([@problem_id:3490786]) 中，您将面对的“数据”是一个高斯随机场的实现，任务是推断生成该场的功率谱参数。您将通过实现并比较两种方法来完成此任务：理论上最优的最大似然估计（MLE）和一种基于模拟的现代技术——无似然推断（LFI），从而深入了解现代数据分析中统计最优性与计算灵活性之间的权衡。", "problem": "考虑一个在傅里叶空间中定义的复值、零均值、统计均匀且各向同性的高斯随机场，该场定义在一个大小为 $N \\times N$ 的周期性二维网格上。设离散角波数为 $k_x$ 和 $k_y$，其大小为 $k = \\sqrt{k_x^2 + k_y^2}$。假设对于所有 $k > 0$ 的 $\\mathbf{k}$，傅里叶空间系数 $\\delta_{\\mathbf{k}}$ 是独立同分布的圆复高斯变量，其方差等于目标功率谱 $P(k \\, ; \\, \\boldsymbol{\\theta})$，其中参数矢量为 $\\boldsymbol{\\theta} = (A, n)$。具体而言，对于每个独立模式，$\\delta_{\\mathbf{k}}$ 的概率密度函数为\n$$\np(\\delta_{\\mathbf{k}} \\mid \\boldsymbol{\\theta}) = \\frac{1}{\\pi P(k \\, ; \\, \\boldsymbol{\\theta})} \\exp\\left(-\\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, \\boldsymbol{\\theta})}\\right),\n$$\n其中 $|\\delta_{\\mathbf{k}}|^2$ 表示复傅里叶系数的模的平方。功率谱的参数形式为\n$$\nP(k \\, ; \\, A, n) = A \\, \\left(k^2 + k_0^2\\right)^{n/2},\n$$\n其中固定枢轴 $k_0 = 1.0$。所有量均为无量纲。\n\n您的任务是设计一个适用于高斯场的无似然推断（Likelihood-Free Inference, LFI）程序，并将其参数恢复效果与基于精确高斯似然的最大似然估计（Maximum Likelihood Estimation, MLE）进行比较。LFI 应依赖于高斯随机场的特征性信息摘要：\n\n- 在各向同性 $k$ 分箱（傅里叶空间中的环带）内 $|\\delta_{\\mathbf{k}}|^2$ 的直方图。\n- 通过相位 $\\phi_{\\mathbf{k}} = \\arg(\\delta_{\\mathbf{k}})$ 的平均合矢量长度测量的相位均匀性，以弧度计算。\n\n从高斯随机场的基本定义和上述 $P(k)$ 的参数形式出发，推导独立傅里叶系数的精确高斯似然，并使用指定的摘要构建一个 LFI。然后，用数值方法实现这两种方法并比较它们的参数估计。\n\n使用以下设计和评估方案：\n\n1. 对于每个测试案例，通过对每个 $k > 0$ 的 $\\delta_{\\mathbf{k}}$ 进行独立抽样，生成一个合成的“观测”复高斯场。抽样基于方差为 $P(k \\, ; \\, A_{\\text{true}}, n_{\\text{true}})$ 的复高斯分布，即从 $\\mathcal{N}(0, P(k \\, ; \\, A_{\\text{true}}, n_{\\text{true}})/2)$ 中独立抽取 $\\Re(\\delta_{\\mathbf{k}})$ 和 $\\Im(\\delta_{\\mathbf{k}})$，使得 $\\mathbb{E}[|\\delta_{\\mathbf{k}}|^2] = P(k \\, ; \\, A_{\\text{true}}, n_{\\text{true}})$。为保证可复现性，使用固定的随机种子。\n\n2. 使用在最小正 $k$ 和最大 $k$ 之间等距的边界，将正 $k$ 模式划分为 $B=6$ 个各向同性分箱。对于每个分箱，使用由该 $k$ 分箱内观测到的 $|\\delta_{\\mathbf{k}}|^2$ 在分位数水平 $q \\in \\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ 处的经验分位数定义的箱边，构建 $|\\delta_{\\mathbf{k}}|^2$ 的 $H=4$ 箱直方图。使用这些固定的箱边来计算观测场和模拟场的归一化直方图计数（总和为 $1$），以使直方图可以直接比较。将全局相位均匀性摘要计算为平均合矢量长度 $R = \\left|\\frac{1}{M} \\sum_{m=1}^M e^{i \\phi_m}\\right|$，其中求和遍历所有 $M$ 个正 $k$ 模式，角度 $\\phi_m$ 以弧度为单位。\n\n3. 无似然推断（LFI）：对于一个候选参数网格 $(A, n)$，其中 $A \\in \\{0.5, 0.8, 1.0, 1.2, 1.5\\}$ 且 $n \\in \\{-1.5, -1.0, -0.5, 0.0, 0.5\\}$，为每个候选参数模拟 $S=16$ 个独立的合成场，并计算这 $S$ 次模拟的平均摘要向量。将摘要向量定义为所有 $B$ 个 $k$ 分箱的归一化直方图计数的拼接，后随全局相位平均合矢量长度 $R$。使用观测摘要与候选参数的平均模拟摘要之间的欧几里得距离的平方，并选择使该距离最小的 $(A, n)$。\n\n4. 精确高斯似然（MLE）：使用独立复高斯系数的精确似然，在相同的参数网格上评估负对数似然（相差一个不依赖于 $\\boldsymbol{\\theta}$ 的加性常数），\n$$\n\\mathcal{L}(A, n) = \\sum_{k > 0} \\left( \\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)} + \\log P(k \\, ; \\, A, n) \\right),\n$$\n并选择使 $\\mathcal{L}(A, n)$ 最小的 $(A, n)$。\n\n5. 对于每个测试案例，报告两种方法恢复参数的绝对误差：$|A_{\\text{LFI}} - A_{\\text{true}}|$、 $|n_{\\text{LFI}} - n_{\\text{true}}|$、 $|A_{\\text{MLE}} - A_{\\text{true}}|$、 $|n_{\\text{MLE}} - n_{\\text{true}}|$。\n\n角度必须以弧度为单位。所有输出均为无量纲。您的程序必须实现上述过程，并为以下三个案例的测试套件生成结果：\n\n- 案例 1：$N = 32$, $A_{\\text{true}} = 1.0$, $n_{\\text{true}} = -1.0$, 种子 $= 12345$。\n- 案例 2：$N = 16$, $A_{\\text{true}} = 0.8$, $n_{\\text{true}} = 0.0$, 种子 $= 67890$。\n- 案例 3：$N = 24$, $A_{\\text{true}} = 1.2$, $n_{\\text{true}} = -1.5$, 种子 $= 24680$。\n\n对所有案例使用 $k_0 = 1.0$。在 LFI 模拟步骤中，对于每个候选参数，使用从案例种子确定性派生的独立种子。由于所有量都是无量纲的，因此不需要物理单位，角度必须以弧度为单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$\n[\\ |A_{\\text{LFI}}^{(1)} - A_{\\text{true}}^{(1)}|,\\ |n_{\\text{LFI}}^{(1)} - n_{\\text{true}}^{(1)}|,\\ |A_{\\text{MLE}}^{(1)} - A_{\\text{true}}^{(1)}|,\\ |n_{\\text{MLE}}^{(1)} - n_{\\text{true}}^{(1)}|,\\ |A_{\\text{LFI}}^{(2)} - A_{\\text{true}}^{(2)}|,\\ |n_{\\text{LFI}}^{(2)} - n_{\\text{true}}^{(2)}|,\\ |A_{\\text{MLE}}^{(2)} - A_{\\text{true}}^{(2)}|,\\ |n_{\\text{MLE}}^{(2)} - n_{\\text{true}}^{(2)}|,\\ |A_{\\text{LFI}}^{(3)} - A_{\\text{true}}^{(3)}|,\\ |n_{\\text{LFI}}^{(3)} - n_{\\text{true}}^{(3)}|,\\ |A_{\\text{MLE}}^{(3)} - A_{\\text{true}}^{(3)}|,\\ |n_{\\text{MLE}}^{(3)} - n_{\\text{true}}^{(3)}|\\ ].\n$$\n不应打印任何其他文本。", "solution": "用户问题已经过验证，被确定为一个定义良好、科学上合理且完备的请求。任务是为一个模拟的二维高斯随机场比较两种参数估计方法——无似然推断（LFI）和最大似然估计（MLE）。\n\n### 基于原理的设计\n\n解决方案将严格按照问题陈述中概述的方案来实施。问题的核心围绕着傅里叶空间中复值、各向同性高斯随机场的统计特性。\n\n#### 1. 傅里叶空间表示与功率谱\n实空间中统计均匀的随机场在傅里叶空间中会变成一个由不相关的随机变量组成的场。对于高斯场，这些傅里叶系数 $\\delta_{\\mathbf{k}}$ 是独立的复高斯随机变量。每个系数的方差由功率谱 $P(k)$ 决定，由于各向同性，功率谱仅依赖于波矢量的大小 $k = |\\mathbf{k}|$。\n\n问题给出了每个独立系数 $\\delta_{\\mathbf{k}}$（其中 $k > 0$）的概率密度：\n$$\np(\\delta_{\\mathbf{k}} \\mid A, n) = \\frac{1}{\\pi P(k \\, ; \\, A, n)} \\exp\\left(-\\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)}\\right)\n$$\n这是一个均值为零、方差为 $P(k)$ 的圆复正态分布的概率密度函数。这样的变量可以通过从一个实值正态分布 $\\mathcal{N}(0, P(k)/2)$ 中独立抽取其实部和虚部来构建。\n\n功率谱模型被给定为一个参数化函数：\n$$\nP(k \\, ; \\, A, n) = A \\, \\left(k^2 + k_0^2\\right)^{n/2}\n$$\n其中 $A$ 是振幅，$n$ 是谱指数，$k_0=1.0$ 是一个固定的枢轴尺度。\n\n定义了一个大小为 $N \\times N$ 的二维网格。相应的离散波数使用 `numpy.fft.fftfreq` 函数计算，该函数提供离散傅里叶变换的频率。对于一个大小为 $L \\times L$ 的物理域，波数将是 $k_i = 2\\pi f_i = 2\\pi \\frac{n_i}{L}$，其中 $n_i$ 是整数。通过将名义上的周期性盒子尺寸设置为 $N$，波数为 $k_i = 2\\pi \\frac{n_i}{N}$。我们使用 `numpy.fft.fftfreq(N, d=1.0)` 来获取频率 $n_i/N$，然后乘以 $2\\pi$ 得到波数。接着计算大小为 $k = \\sqrt{k_x^2 + k_y^2}$ 的网格。\n\n#### 2. 合成数据生成\n对于每个测试案例，通过从指定的分布中抽样傅里叶系数 $\\delta_{\\mathbf{k}}$ 来生成一个“观测”数据集，使用真实参数 $(A_{\\text{true}}, n_{\\text{true}})$ 和一个固定的随机种子以保证可复现性。对于每个 $k>0$ 的模式，我们从 $\\mathcal{N}(0, P(k; A_{\\text{true}}, n_{\\text{true}})/2)$ 中抽样 $\\Re(\\delta_{\\mathbf{k}})$ 和 $\\Im(\\delta_{\\mathbf{k}})$。$k=0$ 处的模式（场均值）被设置为零。\n\n#### 3. 最大似然估计 (MLE)\nMLE 方法利用了数据的精确已知概率分布。由于傅里叶系数是独立的，总对数似然是各个对数似然之和：\n$$\n\\log \\mathcal{L}_{\\text{total}}(A, n) = \\sum_{k>0} \\log p(\\delta_{\\mathbf{k}} \\mid A, n) = \\sum_{k>0} \\left( -\\log(\\pi) - \\log P(k \\, ; \\, A, n) - \\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)} \\right)\n$$\n为了找到最大似然估计，我们最小化负对数似然。忽略常数项 $\\sum \\log(\\pi)$，我们最小化问题陈述中提供的目标函数 $\\mathcal{L}(A, n)$：\n$$\n\\mathcal{L}(A, n) = \\sum_{k > 0} \\left( \\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)} + \\log P(k \\, ; \\, A, n) \\right)\n$$\n该函数在一系列候选参数 $(A, n)$ 的网格上进行评估，产生 $\\mathcal{L}$ 最小值的参数对被选为 MLE 估计。由于此方法使用了数据的全部信息内容，预计其准确性会很高。\n\n#### 4. 无似然推断 (LFI)\n当似然函数难以处理或未知时，使用 LFI，它依赖于比较观测数据的摘要统计量与模拟数据的摘要统计量。设计中指定了两种类型的摘要：\n\n- **功率直方图**：将模的平方 $|\\delta_{\\mathbf{k}}|^2$ 按波数大小 $k$ 分入 $B=6$ 个等距的环形分箱中。在每个环形区域内，计算 $|\\delta_{\\mathbf{k}}|^2$ 值的 $H=4$ 箱直方图。一个关键细节是，给定环形区域的直方图箱边是由*观测*数据在该区域内的 $|\\delta_{\\mathbf{k}}|^2$ 值的经验分位数 $\\{0, 0.25, 0.5, 0.75, 1.0\\}$ 定义的。然后将这些相同的边界用于所有模拟数据集，以确保可比性。直方图计数被归一化以使总和为 $1$。这个摘要统计量是功率谱的分箱和粗化表示，是区分不同高斯模型的主要信息来源。\n- **相位均匀性**：平均合矢量长度 $R = \\left|\\frac{1}{M} \\sum e^{i \\phi_{\\mathbf{k}}}\\right|$ 在所有 $M$ 个 $k>0$ 的模式上计算，其中 $\\phi_{\\mathbf{k}}$ 是 $\\delta_{\\mathbf{k}}$ 的相位。对于纯高斯随机场，相位 $\\phi_{\\mathbf{k}}$ 在 $[0, 2\\pi)$ 上均匀分布。因此，$R$ 的期望值接近于零。这个统计量是探测非高斯性的一个极好的探针，但对于区分不同的高斯模型（即不同的 $A$ 或 $n$）几乎没有区分能力，因为它们都共享相位均匀性这一属性。\n\n完整的摘要向量是所有归一化直方图计数（$B \\times H = 24$ 个值）和单个相位均匀性值的拼接，形成一个 25 维向量。\n\nLFI 过程如下：\n1.  为观测数据计算摘要向量 $S_{\\text{obs}}$。\n2.  对于网格上的每个候选参数对 $(A, n)$：\n    a. 生成 $S=16$ 个独立的模拟场。\n    b. 对于每次模拟，使用从观测数据中派生的固定直方图箱边计算其摘要向量 $S_{\\text{sim}}$。\n    c. 对这 $S$ 个向量进行平均，以获得该参数对的摘要的低方差估计 $\\bar{S}_{\\text{sim}}(A, n)$。\n3.  为每个候选参数计算平方欧几里得距离 $d^2 = ||S_{\\text{obs}} - \\bar{S}_{\\text{sim}}(A, n)||^2$。\n4.  LFI 估计是使该距离最小的 $(A, n)$ 对。\n\n#### 5. 比较\n最后，计算 LFI 和 MLE 方法得到的估计参数与已知的真实参数之间的绝对误差，并按规定报告每个测试案例的结果。这允许对数据压缩的 LFI 方法与理论上最优的 MLE 的性能进行定量比较。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Implements the LFI vs MLE comparison for Gaussian random field parameter estimation.\n    \"\"\"\n\n    def power_spectrum(k, A, n, k0):\n        \"\"\"\n        Calculates the parametric power spectrum P(k; A, n).\n        P(k; A, n) = A * (k^2 + k_0^2)^(n/2)\n        \"\"\"\n        # The term k^2 + k0^2 is always positive since k0=1.0.\n        return A * (k**2 + k0**2)**(n / 2.0)\n\n    def generate_field(N, A, n, k0, seed, k_grid):\n        \"\"\"\n        Generates a 2D complex Gaussian random field in Fourier space.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        P_k = power_spectrum(k_grid, A, n, k0)\n        \n        # Variance of real/imaginary parts is P(k)/2.\n        sigma_k = np.sqrt(P_k / 2.0)\n        \n        real_part = rng.normal(loc=0.0, scale=sigma_k)\n        imag_part = rng.normal(loc=0.0, scale=sigma_k)\n        \n        delta_k = real_part + 1j * imag_part\n        \n        # Set the k=0 mode (DC component) to zero as it's not part of the analysis.\n        delta_k[k_grid == 0] = 0.0\n        \n        return delta_k\n\n    def calculate_summaries(delta_k, k_grid, k_bin_edges, B, H, hist_bin_edges_list=None):\n        \"\"\"\n        Calculates the summary vector (histograms + phase uniformity).\n        If hist_bin_edges_list is None, it computes them from the data (for observed data).\n        Otherwise, it uses the provided edges (for simulated data).\n        \"\"\"\n        pos_k_mask = k_grid > 0\n        k_pos = k_grid[pos_k_mask]\n        delta_k_pos = delta_k[pos_k_mask]\n        \n        # 1. Global phase uniformity (mean resultant length)\n        phases = np.angle(delta_k_pos)\n        R = np.abs(np.mean(np.exp(1j * phases)))\n        \n        # 2. Histograms of |delta_k|^2\n        d2_pos = np.abs(delta_k_pos)**2\n        \n        is_obs_data = hist_bin_edges_list is None\n        if is_obs_data:\n            hist_bin_edges_list = []\n        \n        all_hist_counts = []\n        \n        for i in range(B):\n            k_min, k_max = k_bin_edges[i], k_bin_edges[i+1]\n            bin_mask = (k_pos >= k_min)  (k_pos = k_max) if i == B - 1 else (k_pos >= k_min)  (k_pos  k_max)\n            \n            d2_in_bin = d2_pos[bin_mask]\n            \n            if len(d2_in_bin) == 0:\n                all_hist_counts.append(np.zeros(H))\n                if is_obs_data:\n                    # Append placeholder if bin is empty\n                    hist_bin_edges_list.append(np.linspace(0, 1, H + 1))\n                continue\n\n            current_hist_edges = None\n            if is_obs_data:\n                q_levels = np.linspace(0.0, 1.0, H + 1)\n                current_hist_edges = np.quantile(d2_in_bin, q_levels)\n                # Ensure bin edges are unique for np.histogram\n                if len(np.unique(current_hist_edges))  len(current_hist_edges):\n                    for j in range(1, len(current_hist_edges)):\n                        if current_hist_edges[j] = current_hist_edges[j-1]:\n                            current_hist_edges[j] = current_hist_edges[j-1] + 1e-9 # Add small fuzz\n                hist_bin_edges_list.append(current_hist_edges)\n            else:\n                current_hist_edges = hist_bin_edges_list[i]\n            \n            counts, _ = np.histogram(d2_in_bin, bins=current_hist_edges)\n            total_counts = counts.sum()\n            normalized_counts = counts / total_counts if total_counts > 0 else np.zeros(H)\n            all_hist_counts.append(normalized_counts)\n            \n        summary_vector = np.concatenate(all_hist_counts + [np.array([R])])\n        \n        return (summary_vector, hist_bin_edges_list) if is_obs_data else summary_vector\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {'N': 32, 'A_true': 1.0, 'n_true': -1.0, 'seed': 12345},\n        {'N': 16, 'A_true': 0.8, 'n_true': 0.0, 'seed': 67890},\n        {'N': 24, 'A_true': 1.2, 'n_true': -1.5, 'seed': 24680},\n    ]\n\n    # Global parameters\n    k0 = 1.0\n    B = 6\n    H = 4\n    S = 16\n    A_grid = np.array([0.5, 0.8, 1.0, 1.2, 1.5])\n    n_grid = np.array([-1.5, -1.0, -0.5, 0.0, 0.5])\n    param_grid = list(itertools.product(A_grid, n_grid))\n    \n    results = []\n    \n    for case in test_cases:\n        N, A_true, n_true, seed_main = case['N'], case['A_true'], case['n_true'], case['seed']\n        \n        k_freq = 2 * np.pi * np.fft.fftfreq(N)\n        kx_grid, ky_grid = np.meshgrid(k_freq, k_freq, indexing='ij')\n        k_grid = np.sqrt(kx_grid**2 + ky_grid**2)\n        \n        delta_k_obs = generate_field(N, A_true, n_true, k0, seed_main, k_grid)\n        \n        pos_k_mask = k_grid > 0\n        k_pos = k_grid[pos_k_mask]\n        k_bin_edges = np.linspace(k_pos.min(), k_pos.max(), B + 1)\n        \n        summary_obs, hist_bin_edges_obs = calculate_summaries(delta_k_obs, k_grid, k_bin_edges, B, H)\n        \n        min_dist_sq_lfi = np.inf\n        best_params_lfi = None\n        \n        for i, (A_cand, n_cand) in enumerate(param_grid):\n            sim_summaries = []\n            for s in range(S):\n                sim_seed = seed_main + 1000 * (i + 1) + s\n                delta_k_sim = generate_field(N, A_cand, n_cand, k0, sim_seed, k_grid)\n                summary_sim = calculate_summaries(delta_k_sim, k_grid, k_bin_edges, B, H, hist_bin_edges_list=hist_bin_edges_obs)\n                sim_summaries.append(summary_sim)\n            \n            avg_summary_sim = np.mean(sim_summaries, axis=0)\n            dist_sq = np.sum((summary_obs - avg_summary_sim)**2)\n            \n            if dist_sq  min_dist_sq_lfi:\n                min_dist_sq_lfi = dist_sq\n                best_params_lfi = (A_cand, n_cand)\n                \n        A_lfi, n_lfi = best_params_lfi\n\n        min_neg_log_L_mle = np.inf\n        best_params_mle = None\n        \n        d2_obs_pos = np.abs(delta_k_obs[pos_k_mask])**2\n        \n        for A_cand, n_cand in param_grid:\n            P_k_cand = power_spectrum(k_pos, A_cand, n_cand, k0)\n            if np.any(P_k_cand = 0):\n                neg_log_L = np.inf\n            else:\n                neg_log_L = np.sum(d2_obs_pos / P_k_cand + np.log(P_k_cand))\n            \n            if neg_log_L  min_neg_log_L_mle:\n                min_neg_log_L_mle = neg_log_L\n                best_params_mle = (A_cand, n_cand)\n        \n        A_mle, n_mle = best_params_mle\n        \n        results.extend([\n            abs(A_lfi - A_true),\n            abs(n_lfi - n_true),\n            abs(A_mle - A_true),\n            abs(n_mle - n_true)\n        ])\n\n    print(f\"[{','.join(f'{x:.4f}' for x in results)}]\")\n\nsolve()\n```", "id": "3490786"}]}