{"hands_on_practices": [{"introduction": "重子在原始等离子体中的存在不仅仅是一个细节，它是塑造重子声学振荡（BAO）信号的关键因素。本练习通过一个简化的声学模型，让您亲手推导由重子惯性引起的声波相位延迟。正是这种延迟效应，即重子负载（baryon loading），降低了声速并改变了振荡的节奏，从而在功率谱中留下了独特的印记 ([@problem_id:3465623])。", "problem": "考虑在重子拖曳时期之前，紧密耦合的光子-重子流体中一个共动波数为 $k$ 的傅里叶模式。在紧密耦合极限下，并忽略各向异性应力、光子扩散（丝绸阻尼）以及引力势的任何时间变化，组合的光子-重子流体遵循一个声波方程，其有效声速 $c_{s}$ 取决于重子负载参数 $R$，其中 $R \\equiv 3 \\rho_{b}/(4 \\rho_{\\gamma})$，而 $\\rho_{b}$ 和 $\\rho_{\\gamma}$ 分别表示重子和光子的能量密度。在光速 $c=1$ 的单位制下，声速满足 $c_{s}^{2} = 1/\\big(3(1+R)\\big)$。\n\n假设以下科学上真实的场景：\n- 对于共形时间 $\\eta  \\eta_1$，重子负载可忽略不计，因此 $R \\approx 0$ 且 $c_{s} = 1/\\sqrt{3}$。\n- 对于共形时间 $\\eta \\in [\\eta_{1}, \\eta_{d}]$，重子负载 $R$ 可被视为非零常数 ($R0$)，因此在此区间内 $c_{s} = 1/\\sqrt{3(1+R)}$。\n- 该模式的声学相位可以很好地用 Wentzel–Kramers–Brillouin (WKB) 形式描述，其相位累积由瞬时频率 $k c_{s}$ 对共形时间的积分给出。\n\n将声学相位 $\\varphi(k,\\eta)$ 定义为振荡解的相位，并考虑区间末端 $\\eta=\\eta_{d}$ 处的相位。令 $\\Delta \\varphi(k)$ 表示在有重子负载的模型中累积的声学相位与在同一区间 $[\\eta_{1}, \\eta_{d}]$ 上计算的无重子参考模型累积的声学相位之差：\n$$\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R0}(k,\\eta_{d}) - \\varphi_{R0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big].$$\n\n从紧密耦合声学动力学和上面给出的 $c_{s}$ 定义出发，在所述假设下，推导 $\\Delta \\varphi(k)$ 的一个闭合形式解析表达式。最终答案需以弧度表示，并作为 $k$、$R$ 和共形时间间隔 $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$ 的函数。最终答案必须是单一的解析表达式，而不是不等式或待解方程。", "solution": "问题陈述在所述假设下有科学依据、提法恰当且内部一致。它展示了研究重子声学振荡中的一个标准的、尽管简化的场景。所有必需的定义和条件都已提供，从而可以直接明确地进行推导。因此，该问题是有效的。\n\n核心任务是计算共动波数为 $k$ 的傅里叶模式的相位差 $\\Delta \\varphi(k)$。问题将 $\\Delta \\varphi(k)$ 定义为在共形时间区间 $[\\eta_{1}, \\eta_{d}]$ 上，有重子负载的宇宙和无重子的宇宙中累积的声学相位之差。\n$$\n\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R0}(k,\\eta_{d}) - \\varphi_{R0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big]\n$$\n\n根据指定的 Wentzel–Kramers–Brillouin (WKB) 近似，声学相位 $\\varphi(k, \\eta)$ 是瞬时频率 $k c_{s}(\\eta)$ 对共形时间积分并累积得到的。因此，在区间 $[\\eta_{1}, \\eta_{d}]$ 上累积的相位由以下积分给出：\n$$\n\\varphi(k, \\eta_{d}) - \\varphi(k, \\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k c_{s}(\\eta') \\, d\\eta'\n$$\n\n我们必须为所描述的两种情景计算这个积分：一种是有重子负载 ($R0$)，另一种是无重子的参考情景 ($R=0$)。\n\n首先，考虑有重子负载的情况 ($R0$)。问题陈述，对于 $\\eta \\in [\\eta_{1}, \\eta_{d}]$，重子负载参数 $R$ 是一个非零常数。因此，有效声速 $c_{s}$ 在此区间内也是恒定的，并由下式给出：\n$$\nc_{s, R0} = \\frac{1}{\\sqrt{3(1+R)}}\n$$\n在这种情况下累积的相位，也就是 $\\Delta \\varphi(k)$ 定义中的第一项，是：\n$$\n\\varphi_{R0}(k,\\eta_{d}) - \\varphi_{R0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R0} \\, d\\eta'\n$$\n由于 $k$ 和 $c_{s, R0}$ 相对于积分变量 $\\eta'$ 是常数，我们可以将它们从积分中提取出来：\n$$\n\\varphi_{R0}(k,\\eta_{d}) - \\varphi_{R0}(k,\\eta_{1}) = k \\, c_{s, R0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3(1+R)}} (\\eta_{d} - \\eta_{1})\n$$\n使用定义 $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$，上式变为：\n$$\n\\varphi_{R0}(k,\\eta_{d}) - \\varphi_{R0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}}\n$$\n\n接下来，我们考虑无重子的参考情况 ($R=0$)。这对应于一个纯光子流体。通过在通用公式中设置 $R=0$ 可以找到声速：\n$$\nc_{s, R=0} = \\frac{1}{\\sqrt{3(1+0)}} = \\frac{1}{\\sqrt{3}}\n$$\n这个声速也是恒定的。在这种参考情况下累积的相位，也就是 $\\Delta \\varphi(k)$ 定义中的第二项，是：\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R=0} \\, d\\eta'\n$$\n类似地，我们将常数提取到积分外：\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = k \\, c_{s, R=0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3}} (\\eta_{d} - \\eta_{1})\n$$\n用 $\\Delta \\eta$ 表示，即为：\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3}}\n$$\n\n最后，我们将这两个结果代入 $\\Delta \\varphi(k)$ 的定义表达式中：\n$$\n\\Delta \\varphi(k) = \\left( \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}} \\right) - \\left( \\frac{k \\Delta \\eta}{\\sqrt{3}} \\right)\n$$\n我们可以提取公因子 $k$、$\\Delta \\eta$ 和 $1/\\sqrt{3}$，得到最终的闭合形式表达式：\n$$\n\\Delta \\varphi(k) = \\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)\n$$\n该表达式表示相位移，正如预期的那样，它是负值，因为重子负载降低了声速，从而延迟了声波的相位累积。按要求，它是 $k$、$R$ 和 $\\Delta \\eta$ 的函数。", "answer": "$$\n\\boxed{\\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)}\n$$", "id": "3465623"}, {"introduction": "理解了声速如何依赖于重子，下一步自然就是计算这些声波在光子-重子解耦前所能传播的总距离——即声视界 $r_d$。本练习将引导您从解析理论走向数值实现，这是宇宙学研究的一项核心技能 ([@problem_id:3465692])。您将通过对宇宙历史进行积分来计算这个基本的“标准尺”，并检验您计算结果的数值稳定性。", "problem": "实现一个程序，为几种宇宙学模型计算以百万秒差距（megaparsec）为单位的重子拖拽声视界尺度 $r_d$，并通过比较两种自适应数值方法并与一个标准近似公式进行交叉检验，来对快速变化的有效声速下的数值稳定性进行压力测试。\n\n从以下基础开始。\n\n1. 拖拽时期的重子拖拽声视界定义为，耦合的重子-光子声波直到拖拽尺度因子 $a_d$ 时所传播的共形距离，由下式给出：\n$$\nr_d \\equiv \\int_{0}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a,\n$$\n其中 $c_s(a)$ 是光子-重子流体的有效声速，而 $H(a)$ 是哈勃膨胀率。\n\n2. 有效声速为\n$$\nc_s(a) = \\frac{c}{\\sqrt{3\\left(1 + R(a)\\right)}},\n$$\n其中\n$$\nR(a) \\equiv \\frac{3 \\rho_b(a)}{4 \\rho_\\gamma(a)} = \\frac{3}{4}\\frac{\\Omega_b}{\\Omega_\\gamma} a.\n$$\n这里 $c$ 是真空中的光速，单位为 $\\mathrm{km/s}$，$\\rho_b$ 和 $\\rho_\\gamma$ 分别是重子和光子的能量密度，$\\Omega_b$ 和 $\\Omega_\\gamma$ 是它们当前的密度参数。\n\n3. 在空间平坦的宇宙中，哈勃率作为尺度因子 $a$ 的函数是\n$$\nH(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda},\n$$\n其中 $H_0 = 100\\, h \\, \\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$，且 $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$。当前的辐射密度参数是\n$$\n\\Omega_r = \\Omega_\\gamma \\left( 1 + 0.2271\\, N_{\\mathrm{eff}} \\right),\n$$\n其中 $N_{\\mathrm{eff}}$ 是有效相对论性物质种类数（通常 $N_{\\mathrm{eff}} \\approx 3.046$）。光子密度参数满足\n$$\n\\Omega_\\gamma h^2 = 2.469 \\times 10^{-5} \\left(\\frac{T_{\\mathrm{CMB}}}{2.7255\\,\\mathrm{K}}\\right)^4,\n$$\n其中 $T_{\\mathrm{CMB}}$ 是宇宙微波背景（CMB）的温度。\n\n4. 拖拽红移 $z_d$ 将通过 Eisenstein–Hu 拟合公式计算，\n$$\nz_d = \\frac{1291 (\\Omega_m h^2)^{0.251}}{1 + 0.659 (\\Omega_m h^2)^{0.828}}\\left[ 1 + b_1 (\\Omega_b h^2)^{b_2} \\right],\n$$\n其中\n$$\nb_1 = 0.313 (\\Omega_m h^2)^{-0.419}\\left[1 + 0.607 (\\Omega_m h^2)^{0.674} \\right],\\quad\nb_2 = 0.238 (\\Omega_m h^2)^{0.223}.\n$$\n然后 $a_d = 1/(1+z_d)$。\n\n5. 为了交叉检验，使用 Eisenstein–Hu 对拖拽时期声视界的解析近似，\n$$\nr_d^{\\mathrm{EH}} = \\frac{2}{3 k_{\\mathrm{eq}}} \\sqrt{\\frac{6}{R_{\\mathrm{eq}}}} \\,\n\\ln\\!\\left(\\frac{\\sqrt{1 + R_d} + \\sqrt{R_d + R_{\\mathrm{eq}}}}{1 + \\sqrt{R_{\\mathrm{eq}}}}\\right),\n$$\n其中 $R_d = R(a_d)$，$a_{\\mathrm{eq}} = \\Omega_r / \\Omega_m$，$R_{\\mathrm{eq}} = R(a_{\\mathrm{eq}})$，以及\n$$\nk_{\\mathrm{eq}} \\equiv \\frac{a_{\\mathrm{eq}} H(a_{\\mathrm{eq}})}{c},\n$$\n当 $H$ 的单位为 $\\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$ 且 $c$ 的单位为 $\\mathrm{km\\, s^{-1}}$ 时，结果以 $\\mathrm{Mpc}^{-1}$ 表示。$r_d^{\\mathrm{EH}}$ 的值以 $\\mathrm{Mpc}$ 为单位。\n\n任务要求。\n\nA. 实现两种独立的自适应数值方法来评估 $r_d$：\n- 方法1：对 $a \\in [0, a_d]$ 上的积分进行自适应求积。由于在辐射主导时期，当 $a \\to 0$ 时，被积函数是有限的但趋于一个常数，您必须从一个小的 $a_{\\min}  0$ 开始数值积分，并加上解析的早期贡献\n$$\n\\Delta r(a_{\\min}) = \\frac{c}{\\sqrt{3}\\, H_0 \\sqrt{\\Omega_r}}\\, a_{\\min},\n$$\n因此 $r_d \\approx \\Delta r(a_{\\min}) + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)}\\, \\mathrm{d}a$。\n- 方法2：对常微分方程进行自适应积分\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}a} = \\frac{c_s(a)}{a^2 H(a)}, \\quad r(a_{\\min}) = \\Delta r(a_{\\min}),\n$$\n从 $a_{\\min}$ 到 $a_d$ 并带有步长控制。\n\n两种方法都必须使用严格的绝对和相对容差，以探测由重子负载项 $R(a)$ 引起的快速变化的 $c_s(a)$ 下的数值稳定性。\n\nB. 对于每组宇宙学参数集，计算：\n- 通过方法1（自适应求积）得到的 $r_d$ 值，单位为 $\\mathrm{Mpc}$。\n- 通过方法2（自适应ODE）得到的 $r_d$ 值，单位为 $\\mathrm{Mpc}$。\n- 来自 Eisenstein–Hu 近似的近似值 $r_d^{\\mathrm{EH}}$，单位为 $\\mathrm{Mpc}$。\n\n根据这些值，构建两个无量纲的诊断量：\n- 两种数值方法之间的相对差异，\n$$\n\\delta_{\\mathrm{num}} = \\frac{\\left| r_d^{(1)} - r_d^{(2)} \\right|}{\\tfrac{1}{2}\\left( r_d^{(1)} + r_d^{(2)} \\right)}.\n$$\n- 使用方法1得到的结果与 Eisenstein–Hu 近似的相对偏差，\n$$\n\\delta_{\\mathrm{EH}} = \\frac{\\left| r_d^{(1)} - r_d^{\\mathrm{EH}} \\right|}{r_d^{\\mathrm{EH}}}.\n$$\n\nC. 使用以下五个宇宙学模型的测试套件，每个模型由 $(\\Omega_m, \\Omega_b, h, N_{\\mathrm{eff}}, T_{\\mathrm{CMB}})$ 指定：\n- 情况1（类普朗克基线）：$(0.315, 0.049, 0.674, 3.046, 2.7255\\,\\mathrm{K})$。\n- 情况2（高重子负载）：$(0.35, 0.08, 0.70, 3.046, 2.7255\\,\\mathrm{K})$。\n- 情况3（增强的相对论性物质种类）：$(0.315, 0.049, 0.674, 4.0, 2.7255\\,\\mathrm{K})$。\n- 情况4（低重子分数）：$(0.30, 0.02, 0.67, 3.046, 2.7255\\,\\mathrm{K})$。\n- 情况5（极低重子分数）：$(0.27, 0.005, 0.67, 3.046, 2.7255\\,\\mathrm{K})$。\n\n输出规范。\n\n- $r_d$ 的内部计算必须以 $\\mathrm{Mpc}$ 为单位进行和处理。\n- 对于每种情况，计算如上定义的 $\\delta_{\\mathrm{num}}$ 和 $\\delta_{\\mathrm{EH}}$（无量纲）。\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的10个浮点数列表，并用方括号括起来，顺序如下：\n$$\n[\\delta_{\\mathrm{num}}^{(1)}, \\delta_{\\mathrm{EH}}^{(1)}, \\delta_{\\mathrm{num}}^{(2)}, \\delta_{\\mathrm{EH}}^{(2)}, \\ldots, \\delta_{\\mathrm{num}}^{(5)}, \\delta_{\\mathrm{EH}}^{(5)}].\n$$\n不要四舍五入；打印由标准Python浮点数到字符串转换产生的完整精度。", "solution": "此问题是有效的，因为它定义明确，科学上基于已建立的宇宙学原理，并提供了一套完整、一致的定义和参数。所有给定的方程在宇宙学领域都是标准的，或来自于广泛使用的拟合公式。测试案例是物理上合理的。该任务是一个明确定义的数值问题。\n\n该解决方案计算重子拖拽声视界 $r_d$，这是宇宙学中与重子声学振荡（BAOs）相关的一个基本尺度。这个尺度是原始重子-光子等离子体中的声波从大爆炸开始到重子与光子解耦的时期（拖拽时期，尺度因子为 $a_d$）所能传播的最大距离。计算是针对几个宇宙学模型进行的，每个模型由一组参数 $(\\Omega_m, \\Omega_b, h, N_{\\mathrm{eff}}, T_{\\mathrm{CMB}})$ 定义。\n\n首先，对于每个模型，我们建立宇宙学背景。输入参数是当前的物质密度参数 $\\Omega_m$、重子密度参数 $\\Omega_b$、折合哈勃常数 $h$、有效相对论性物质种类数 $N_{\\mathrm{eff}}$ 和宇宙微波背景温度 $T_{\\mathrm{CMB}}$。根据这些，我们推导出其他基本量。哈勃常数为 $H_0 = 100\\, h \\, \\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$。当前光子密度参数 $\\Omega_\\gamma$ 是通过斯特藩-玻尔兹曼定律从 $T_{\\mathrm{CMB}}$ 计算出来的，使用关系式 $\\Omega_\\gamma h^2 = 2.469 \\times 10^{-5} (T_{\\mathrm{CMB}} / 2.7255\\,\\mathrm{K})^4$。总辐射密度 $\\Omega_r$ 包括光子和相对论性中微子，由 $\\Omega_r = \\Omega_\\gamma ( 1 + 0.2271\\, N_{\\mathrm{eff}} )$ 给出。在空间平坦的宇宙中，暗能量密度为 $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$。有了这些参数，任何尺度因子 $a$ 处的哈勃膨胀率由弗里德曼方程给出：\n$$\nH(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}\n$$\n\n声视界 $r_d$ 由声速 $c_s(a)$ 在共形时上直到拖拽时期 $a_d$ 的积分定义：\n$$\nr_d = \\int_0^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a\n$$\n光子-重子流体的声速取决于重子与光子能量密度的比率，$R(a) = (3\\rho_b/4\\rho_\\gamma) = (3/4)(\\Omega_b/\\Omega_\\gamma)a$：\n$$\nc_s(a) = \\frac{c}{\\sqrt{3\\left(1 + R(a)\\right)}}\n$$\n其中 $c$ 是光速。积分的上限 $a_d$ 是拖拽时期的尺度因子，由拖拽红移 $z_d$ 计算得出，$a_d = 1/(1+z_d)$。我们使用精确的 Eisenstein-Hu 拟合公式计算 $z_d$，该公式取决于物理物质密度和重子密度，即 $\\Omega_m h^2$ 和 $\\Omega_b h^2$。\n\n$r_d$ 的积分从 $a=0$ 开始。分母中的 $a^2$ 项造成了潜在的数值奇点。然而，在早期宇宙（$a \\to 0$）中，宇宙是辐射主导的，因此 $H(a) \\approx H_0 \\sqrt{\\Omega_r} a^{-2}$，且重子负载 $R(a) \\to 0$，所以 $c_s(a) \\to c/\\sqrt{3}$。因此，被积函数趋于一个常数，$\\frac{c}{\\sqrt{3} H_0 \\sqrt{\\Omega_r}}$。为了处理这个积分，我们在一个小的尺度因子 $a_{\\min}  0$ 处将其拆分：\n$$\nr_d = \\int_0^{a_{\\min}} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a\n$$\n第一项可以很好地近似为 $\\Delta r(a_{\\min}) = \\frac{c}{\\sqrt{3} H_0 \\sqrt{\\Omega_r}} a_{\\min}$。第二项则进行数值计算。\n\n我们为这个任务实现了两种高精度的数值方法：\n1.  **方法1（自适应求积）**：我们使用 `scipy.integrate.quad` 这个稳健的自适应求积例程，直接计算从 $a_{\\min}$ 到 $a_d$ 的定积分。最终结果是 $r_d^{(1)} = \\Delta r(a_{\\min}) + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a$。\n2.  **方法2（自适应ODE积分）**：我们将问题重构为一个关于 $r(a)$ 的一阶常微分方程，$\\frac{\\mathrm{d}r}{\\mathrm{d}a} = \\frac{c_s(a)}{a^2 H(a)}$，其初始条件为 $r(a_{\\min}) = \\Delta r(a_{\\min})$。我们使用 `scipy.integrate.solve_ivp` 和一个高阶自适应步长求解器来解决这个从 $a = a_{\\min}$到 $a = a_d$ 的初值问题。解在 $a_d$ 处的值给出 $r_d^{(2)}$。\n\n为了交叉检验，我们还计算了 Eisenstein-Hu 解析近似值 $r_d^{\\mathrm{EH}}$，它提供了一个无需数值积分的快速且相当准确的声视界估计。\n\n最后，对于每个宇宙学模型，我们计算两个无量纲的诊断量。第一个，$\\delta_{\\mathrm{num}} = |r_d^{(1)} - r_d^{(2)}| / (\\frac{1}{2}(r_d^{(1)} + r_d^{(2)}))$，衡量两种独立的高精度方法之间的数值稳定性和一致性。第二个，$\\delta_{\\mathrm{EH}} = |r_d^{(1)} - r_d^{\\mathrm{EH}}| / r_d^{\\mathrm{EH}}$，量化了 Eisenstein-Hu 拟合公式相对于精确数值积分的准确性。这些诊断量是为所有五个测试案例计算的，并以要求的输出格式呈现。数值求解器使用了极严格的容差（$10^{-13}$），以确保 $\\delta_{\\mathrm{num}}$ 是衡量方法一致性的稳健指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad, solve_ivp\n\nC_KM_S = 299792.458  # Speed of light in km/s\n\ndef calculate_diagnostics(params):\n    \"\"\"\n    Computes diagnostic quantities for a given cosmological model.\n    \n    For a given set of cosmological parameters, this function calculates the \n    baryon-drag sound horizon r_d using two numerical methods and one analytic \n    approximation. It then computes the relative differences between these results.\n    \n    Args:\n        params (tuple): A tuple of cosmological parameters \n                        (Omega_m, Omega_b, h, N_eff, T_CMB).\n\n    Returns:\n        tuple: A tuple containing two floats: (delta_num, delta_eh).\n    \"\"\"\n    Omega_m, Omega_b, h, N_eff, T_CMB = params\n\n    # Constants and Derived Parameters\n    H0 = 100.0 * h  # Hubble constant in km/s/Mpc\n    omega_mh2 = Omega_m * h**2\n    omega_bh2 = Omega_b * h**2\n\n    # Photon and radiation densities\n    omega_gamma_h2 = 2.469e-5 * (T_CMB / 2.7255)**4\n    Omega_gamma = omega_gamma_h2 / h**2\n    omega_r_h2 = omega_gamma_h2 * (1.0 + 0.2271 * N_eff)\n    Omega_r = omega_r_h2 / h**2\n\n    # Dark energy density for a flat universe\n    Omega_Lambda = 1.0 - Omega_m - Omega_r\n\n    # Cosmological functions of scale factor 'a'\n    def H(a):\n        return H0 * np.sqrt(Omega_r * a**-4 + Omega_m * a**-3 + Omega_Lambda)\n\n    def R(a):\n        return (3.0 / 4.0) * (Omega_b / Omega_gamma) * a\n    \n    def cs(a):\n        return C_KM_S / np.sqrt(3.0 * (1.0 + R(a)))\n\n    # Drag epoch redshift (z_d) and scale factor (a_d) from Eisenstein-Hu formula\n    b1 = 0.313 * (omega_mh2)**-0.419 * (1.0 + 0.607 * (omega_mh2)**0.674)\n    b2 = 0.238 * (omega_mh2)**0.223\n    z_d = 1291. * (omega_mh2)**0.251 / (1.0 + 0.659 * (omega_mh2)**0.828) * (1.0 + b1 * (omega_bh2)**b2)\n    a_d = 1.0 / (1.0 + z_d)\n\n    # Integrand for sound horizon r_d\n    def integrand(a):\n        if a == 0:\n            # The limit as a - 0 is finite\n            return C_KM_S / (np.sqrt(3.0) * H0 * np.sqrt(Omega_r))\n        return cs(a) / (a**2 * H(a))\n\n    # Handle the integral from a=0 by splitting at a_min\n    a_min = 1e-10\n    integrand_early = C_KM_S / (np.sqrt(3.0) * H0 * np.sqrt(Omega_r))\n    dr_amin = integrand_early * a_min\n\n    # --- Method 1: Adaptive Quadrature ---\n    # Using scipy.integrate.quad with tight tolerances\n    integral_val, _ = quad(integrand, a_min, a_d, epsabs=1e-13, epsrel=1e-13)\n    r_d1 = dr_amin + integral_val\n\n    # --- Method 2: Adaptive ODE Integration ---\n    # dr/da = integrand(a), solved with scipy.integrate.solve_ivp\n    sol = solve_ivp(\n        lambda a, r: integrand(a),\n        (a_min, a_d),\n        [dr_amin],\n        method='DOP853',  # High-order accurate solver\n        rtol=1e-13,\n        atol=1e-13\n    )\n    r_d2 = sol.y[0, -1]\n\n    # --- Eisenstein-Hu Analytic Approximation ---\n    a_eq = Omega_r / Omega_m\n    R_d = R(a_d)\n    R_eq = R(a_eq)\n    k_eq = a_eq * H(a_eq) / C_KM_S  # in 1/Mpc\n\n    log_arg_num = np.sqrt(1.0 + R_d) + np.sqrt(R_d + R_eq)\n    log_arg_den = 1.0 + np.sqrt(R_eq)\n    r_d_eh = (2.0 / (3.0 * k_eq)) * np.sqrt(6.0 / R_eq) * np.log(log_arg_num / log_arg_den)\n\n    # --- Diagnostics ---\n    delta_num = abs(r_d1 - r_d2) / (0.5 * (r_d1 + r_d2))\n    delta_eh = abs(r_d1 - r_d_eh) / r_d_eh\n\n    return delta_num, delta_eh\n\ndef solve():\n    \"\"\"\n    Main function to run the cosmological calculations for all test cases.\n    \"\"\"\n    # Test suite of cosmological models\n    test_cases = [\n        (0.315, 0.049, 0.674, 3.046, 2.7255),  # Case 1 (Planck-like)\n        (0.35, 0.08, 0.70, 3.046, 2.7255),    # Case 2 (high baryon)\n        (0.315, 0.049, 0.674, 4.0, 2.7255),    # Case 3 (high N_eff)\n        (0.30, 0.02, 0.67, 3.046, 2.7255),    # Case 4 (low baryon fraction)\n        (0.27, 0.005, 0.67, 3.046, 2.7255),   # Case 5 (very low baryon)\n    ]\n\n    all_results = []\n    for params in test_cases:\n        delta_num, delta_eh = calculate_diagnostics(params)\n        all_results.extend([delta_num, delta_eh])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3465692"}, {"introduction": "在理论上计算出声视界尺度 $r_d$ 之后，现实中的挑战是如何从包含系统误差的观测功率谱中精确测量出BAO特征。这个高级练习模拟了这一情景，通过向模拟的功率谱中引入校准“倾斜”来实现 ([@problem_id:3465639])。您将实现一个精密的估算器，它能够通过构建正交基来消除这些多项式形式的系统误差，从而稳健地恢复真实的BAO相位，这项技术对于分析真实的宇宙学巡天数据至关重要。", "problem": "要求您设计并实现一个数值估计器，用于估计线性物质功率谱中重子声学振荡特征的相位。该估计器需要通过构造，对低阶乘性定标倾斜保持不变。科学出发点是，在线性理论中，物质功率谱 $P(k)$ 可以分解为一个平滑的宽带成分和一个由重子声学振荡产生的振荡成分。在与重子声学振荡相关的有限波数区间上，振荡成分可以建模为一个宗量为 $k r_s + \\phi_0$ 的正弦波，再乘以一个阻尼包络。其中 $r_s$ 是声视界尺度，$\\phi_0$ 是真实相位。作为 $k$ 的平滑函数的乘性定标误差，可以在领头阶上用 $k$ 的低次多项式来近似。\n\n您的任务是构建一个相位估计器，当观测谱被形式为 $P(k) \\to \\left(1 + \\epsilon \\left(k/k_\\star\\right)^n\\right) P(k)$ (其中整数 $n \\ge 0$，$\\epsilon$ 为小而有限的数值) 的乘性定标误差污染时，该估计器仍能保持稳定。这需要通过确保该估计器对任何直至 $m$ 次的平滑多项式倾斜都不敏感来实现。\n\n使用以下建模选择、常数和计算设计：\n\n- 在波数 $k \\in [k_{\\min}, k_{\\max}]$ 的均匀间隔网格上构建一个包含 $N_k$ 个点的合成线性功率谱，单位为 $h\\,\\mathrm{Mpc}^{-1}$：\n  - 选择 $k_{\\min} = 0.02$, $k_{\\max} = 0.30$ 和 $N_k = 2048$。\n  - 使用形式为\n    $$\n    P_{\\mathrm{sm}}(k) = P_0 \\,\\frac{k^{n_s}}{\\left[1 + \\left(k/k_p\\right)^\\beta\\right]^2},\n    $$\n    的平滑基线，其中 $P_0 = 10^4$，$n_s = 1.0$，$k_p = 0.2$ 和 $\\beta = 3.0$。\n  - 叠加一个建模为\n    $$\n    P(k) = P_{\\mathrm{sm}}(k)\\left[1 + A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)\\right],\n    $$\n    的重子声学振荡特征，其中 $A_w = 0.05$，$k_d = 0.12$，$r_s = 105.0$ 和 $\\phi_0 = 0.35$。在适用情况下，所有数值的单位均为 $h\\,\\mathrm{Mpc}^{-1}$，角度以弧度为单位。\n\n- 应用由 $(\\epsilon, n)$ 参数化、相对于枢轴点 $k_\\star$ 的乘性定标误差：\n  $$\n  P_{\\mathrm{obs}}(k) = \\left(1 + \\epsilon \\left(\\frac{k}{k_\\star}\\right)^n\\right) P(k),\n  $$\n  其中 $k_\\star = 0.20$。\n\n- 为重子声学振荡相位设计一个两阶段估计器：\n  - 阶段 1 (平滑归一化)：通过将 $\\ln P_{\\mathrm{obs}}(k)$ 对 $k$ 的一个 $d_s$ 次多项式进行回归，拟合一个平滑基线 $\\widehat{S}(k)$ 到 $P_{\\mathrm{obs}}(k)$，以捕捉其宽带形状和乘性倾斜。使用 $d_s = 7$，并根据最佳拟合系数 $a_j$ 定义 $\\widehat{S}(k) = \\exp\\left[\\sum_{j=0}^{d_s} a_j k^j\\right]$。然后构建残差比\n    $$\n    R(k) \\equiv \\frac{P_{\\mathrm{obs}}(k)}{\\widehat{S}(k)} - 1.\n    $$\n  - 阶段 2 (多项式倾斜置零和匹配滤波)：构建阻尼振荡模板\n    $$\n    t_s(k) = e^{-\\left(k/k_d\\right)^2} \\sin(k r_s),\\quad t_c(k) = e^{-\\left(k/k_d\\right)^2} \\cos(k r_s).\n    $$\n    构建多项式干扰子空间 $\\mathcal{P}_m = \\mathrm{span}\\{1, k, k^2, \\dots, k^m\\}$，其中 $m = 3$。在 $k$ 网格上的离散内积 $\\langle f, g\\rangle = \\sum_i f(k_i) g(k_i)$ 下，通过将两个模板投影到 $\\mathcal{P}_m$ 的正交补空间中，使它们与 $\\mathcal{P}_m$ 正交。将正交化后的模板表示为 $\\tilde{t}_s$ 和 $\\tilde{t}_c$。\n    通过匹配滤波估计相位：\n    $$\n    a \\equiv \\langle R, \\tilde{t}_s\\rangle,\\quad b \\equiv \\langle R, \\tilde{t}_c\\rangle,\\quad \\widehat{\\phi} \\equiv \\mathrm{atan2}(b, a).\n    $$\n\n- 测试套件。对于以下按指定顺序排列的 $(\\epsilon, n)$ 情况 (其中 $k_\\star$ 如上定义)，评估绝对相位误差 $|\\Delta \\phi| \\equiv \\mathrm{wrap}\\left(\\widehat{\\phi} - \\phi_0\\right)$。该误差值需包裹到 $[-\\pi, \\pi]$ 区间内，并以弧度为单位的非负数形式报告：\n  - 情况 1：$(\\epsilon, n) = (0.00, 0)$。\n  - 情况 2：$(\\epsilon, n) = (0.30, 0)$。\n  - 情况 3：$(\\epsilon, n) = (0.30, 1)$。\n  - 情况 4：$(\\epsilon, n) = (0.50, 2)$。\n  - 情况 5：$(\\epsilon, n) = (0.50, 3)$。\n  - 情况 6：$(\\epsilon, n) = (0.50, 4)$。\n\n- 输出规范。您的程序必须为每个测试用例计算以弧度为单位的 $|\\Delta \\phi|$，并生成单行输出。该输出包含一个用方括号括起来的逗号分隔列表，其顺序与测试套件相同，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是一个浮点数。\n\n所有角度必须以弧度表示。所有波数必须以 $h\\,\\mathrm{Mpc}^{-1}$ 为单位。最终输出必须是严格符合指定格式的单行文本。", "solution": "该问题要求设计并实现一个数值估计器，用于估计线性物质功率谱中重子声学振荡 (BAO) 特征的相位。一项关键要求是，该估计器必须对低阶乘性定标误差具有鲁棒性，这种误差通常被称为“倾斜”，是波数 $k$ 的平滑函数。解决方案包括合成一个模拟功率谱，施加指定的定标误差，然后通过一个两阶段算法处理这个“观测”谱，以恢复BAO相位。\n\n其根本的科学原理是，物质功率谱 $P(k)$可以建模为一个平滑的宽带成分 $P_{\\mathrm{sm}}(k)$ 与一个代表BAO特征的振荡成分的乘积。提供的具体模型是：\n$$\nP(k) = P_{\\mathrm{sm}}(k)\\left[1 + A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)\\right]\n$$\n在此式中，$P_{\\mathrm{sm}}(k)$ 是平滑部分，$A_w = 0.05$ 是BAO振幅，$e^{-\\left(k/k_d\\right)^2}$ (其中 $k_d = 0.12 \\,h\\,\\mathrm{Mpc}^{-1}$) 是一个阻尼包络，$r_s = 105.0 \\,h\\,\\mathrm{Mpc}^{-1}$ 是声视界尺度，而 $\\phi_0 = 0.35$ 弧度是我们旨在估计的真实相位。数据在 $k$ 从 $k_{\\min} = 0.02$ 到 $k_{\\max} = 0.30 \\,h\\,\\mathrm{Mpc}^{-1}$ 的均匀网格上生成，包含 $N_k = 2048$ 个点。\n\n观测谱 $P_{\\mathrm{obs}}(k)$ 被一个乘性系统误差污染：\n$$\nP_{\\mathrm{obs}}(k) = C(k) P(k) = \\left(1 + \\epsilon \\left(\\frac{k}{k_\\star}\\right)^n\\right) P(k)\n$$\n其中 $C(k)$ 是定标倾斜，由其振幅 $\\epsilon$ 和幂律指数 $n$ 参数化，相对于一个枢轴尺度 $k_\\star = 0.20 \\,h\\,\\mathrm{Mpc}^{-1}$。\n\n这个两阶段估计程序旨在隔离BAO相位 $\\phi_0$，同时消除未知倾斜 $C(k)$ 和宽带形状 $P_{\\mathrm{sm}}(k)$ 的影响。\n\n**阶段 1：平滑归一化**\n\n第一阶段旨在移除功率谱的整体平滑形状，包括乘性倾斜。这是通过将一个平滑函数 $\\widehat{S}(k)$ 拟合到 $P_{\\mathrm{obs}}(k)$ 并用其进行归一化来实现的。通过取对数，乘性成分变为加性成分：\n$$\n\\ln P_{\\mathrm{obs}}(k) = \\ln P_{\\mathrm{sm}}(k) + \\ln C(k) + \\ln\\left[1 + A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)\\right]\n$$\n由于BAO项很小 ($A_w \\ll 1$)，最后一项近似为 $A_w e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)$。前两项 $\\ln P_{\\mathrm{sm}}(k)$ 和 $\\ln C(k)$ 是 $k$ 的平滑函数。它们的和可以有效地用一个 $k$ 的多项式来近似。我们对 $\\ln P_{\\mathrm{obs}}(k)$ 进行关于一个 $d_s=7$ 次多项式的最小二乘回归，得到系数 $a_j$。拟合的平滑成分为 $\\widehat{S}(k) = \\exp\\left(\\sum_{j=0}^{d_s} a_j k^j\\right)$。\n\n然后通过计算残差比来分离信号的振荡部分：\n$$\nR(k) = \\frac{P_{\\mathrm{obs}}(k)}{\\widehat{S}(k)} - 1 \\approx A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right) + \\text{残差平滑项}\n$$\n残差平滑项源于多项式拟合的不完美之处。核心挑战在于，这个残差项会使 $\\phi_0$ 的估计产生偏差。\n\n**阶段 2：多项式倾斜置零和匹配滤波**\n\n第二阶段旨在从 $R(k)$ 中估计 $\\phi_0$，其方式对这种残差平滑污染不敏感。$R(k)$ 中的BAO信号可以表示为正弦和余弦模板的线性组合：\n$$\nA_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right) = A_w \\cos(\\phi_0) \\, t_s(k) + A_w \\sin(\\phi_0) \\, t_c(k)\n$$\n其中模板为 $t_s(k) = e^{-\\left(k/k_d\\right)^2} \\sin(k r_s)$ 和 $t_c(k) = e^{-\\left(k/k_d\\right)^2} \\cos(k r_s)$。\n\n$R(k)$ 中的残差平滑污染可以局部地用一个低次多项式来近似。我们将这个干扰成分建模为位于向量空间 $\\mathcal{P}_m = \\mathrm{span}\\{1, k, k^2, \\dots, k^m\\}$ 中，其中 $m=3$。为了使相位估计对 $\\mathcal{P}_m$ 中的任何分量都免疫，我们将我们的模板 $t_s$ 和 $t_c$ 投影到 $\\mathcal{P}_m$ 的正交补空间中。这个过程称为置零，它确保了最终的模板与任何次数不超过 $m$ 的多项式都具有零相关性。\n\n设离散内积定义为 $\\langle f, g\\rangle = \\sum_{i=1}^{N_k} f(k_i)g(k_i)$。设 $\\{q_j(k)\\}_{j=0}^m$ 是 $\\mathcal{P}_m$ 相对于此内积的一个标准正交基。这个基可以从单项式基 $\\{k^j\\}_{j=0}^m$ 通过 Gram-Schmidt 过程构建，或者更稳健地，通过 QR 分解。\n\n一个模板（例如 $t_s$）到干扰空间 $\\mathcal{P}_m$ 的投影由 $\\mathrm{proj}_{\\mathcal{P}_m}(t_s) = \\sum_{j=0}^{m} \\langle t_s, q_j \\rangle q_j$ 给出。与 $\\mathcal{P}_m$ 正交的新模板是：\n$$\n\\tilde{t}_s = t_s - \\mathrm{proj}_{\\mathcal{P}_m}(t_s)\n$$\n类似地，我们构建 $\\tilde{t}_c$。根据构造，对于任何 $p \\in \\mathcal{P}_m$，都有 $\\langle \\tilde{t}_s, p \\rangle = 0$ 和 $\\langle \\tilde{t}_c, p \\rangle = 0$。\n\n最后，我们通过将残差数据 $R(k)$ 投影到这些置零后的模板上，来执行匹配滤波：\n$$\na \\equiv \\langle R, \\tilde{t}_s\\rangle, \\quad b \\equiv \\langle R, \\tilde{t}_c\\rangle\n$$\n由于 $R(k)$ 中的任何多项式分量都与 $\\tilde{t}_s$ 和 $\\tilde{t}_c$ 正交，因此它对 $a$ 和 $b$ 没有贡献。因此，$a$ 和 $b$ 分别隔离了 $\\cos(\\phi_0)$ 和 $\\sin(\\phi_0)$ 分量的振幅。相位估计如下：\n$$\n\\widehat{\\phi} = \\mathrm{atan2}(b, a)\n$$\n然后误差计算为 $|\\Delta \\phi| = |\\mathrm{wrap}(\\widehat{\\phi} - \\phi_0)|$，其中包裹函数将角度映射到 $[-\\pi, \\pi]$。该估计器通过构造对次数最高为 $m=3$ 的多项式污染具有鲁棒性。对于幂律指数 $n \\le m$ 的定标倾斜，残差平滑项可以很好地由 $\\mathcal{P}_m$ 中的一个多项式近似，我们预期相位误差会很小。对于 $n  m$ 的情况，该方法的保护会失效，预计会产生较大的误差。\n\n算法实现过程如下：\n1.  定义所有物理和数值参数。\n2.  创建离散波数网格 $k_i$。\n3.  对每个测试用例 $(\\epsilon, n)$：\n    a.  生成 $P_{\\mathrm{obs}}(k_i)$。\n    b.  用一个 7 次多项式拟合 $\\ln(P_{\\mathrm{obs}})$ 得到 $\\widehat{S}(k_i)$ 并计算残差 $R(k_i)$。\n    c.  构建一个矩阵，其列为 $j \\in \\{0, 1, 2, 3\\}$ 的单项式基向量 $k_i^j$。\n    d.  对此矩阵执行 QR 分解，以获得 $\\mathcal{P}_3$ 的一个标准正交基。\n    e.  生成模板 $t_s(k_i)$ 和 $t_c(k_i)$。\n    f.  从 $t_s$ 和 $t_c$ 中投影去除多项式分量，得到 $\\tilde{t}_s$ 和 $\\tilde{t}_c$。\n    g.  计算内积 $a = \\langle R, \\tilde{t}_s \\rangle$ 和 $b = \\langle R, \\tilde{t}_c \\rangle$。\n    h.  计算相位估计值 $\\widehat{\\phi}$ 及其绝对误差 $|\\Delta \\phi|$。\n4.  收集并按指定格式打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical estimator for the BAO phase\n    in the linear matter power spectrum, robust to calibration tilts.\n    \"\"\"\n\n    # Define constants and model parameters\n    k_min = 0.02\n    k_max = 0.30\n    N_k = 2048\n    \n    P0 = 10000.0\n    n_s = 1.0\n    k_p = 0.2\n    beta = 3.0\n    \n    A_w = 0.05\n    k_d = 0.12\n    r_s = 105.0\n    phi_0 = 0.35\n    \n    k_star = 0.20\n    d_s = 7 # Degree for smooth log-polynomial fit\n    m = 3   # Degree of polynomial nuisance space\n\n    # Create the uniformly spaced wavenumber grid\n    k_grid = np.linspace(k_min, k_max, N_k)\n\n    def generate_power_spectrum(k, eps, n, phi):\n        \"\"\"Generates the observed power spectrum with a given tilt.\"\"\"\n        # Smooth baseline power spectrum\n        P_sm = P0 * (k**n_s) / (1 + (k / k_p)**beta)**2\n        \n        # Power spectrum with BAO feature\n        bao_term = A_w * np.exp(-(k / k_d)**2) * np.sin(k * r_s + phi)\n        P_true = P_sm * (1 + bao_term)\n        \n        # Apply multiplicative calibration error (tilt)\n        tilt_factor = 1 + eps * (k / k_star)**n\n        P_obs = P_true * tilt_factor\n        \n        return P_obs\n\n    def wrap_angle(angle):\n        \"\"\"Wraps an angle to the interval [-pi, pi].\"\"\"\n        return (angle + np.pi) % (2 * np.pi) - np.pi\n\n    # Define the test cases\n    test_cases = [\n        (0.00, 0),\n        (0.30, 0),\n        (0.30, 1),\n        (0.50, 2),\n        (0.50, 3),\n        (0.50, 4),\n    ]\n\n    results = []\n\n    # Main loop over test cases\n    for epsilon, n_tilt in test_cases:\n        # --- Data Generation ---\n        P_obs = generate_power_spectrum(k_grid, epsilon, n_tilt, phi_0)\n\n        # --- Stage 1: Smooth Normalization ---\n        # Regress ln(P_obs) against a polynomial in k\n        log_P_obs = np.log(P_obs)\n        poly_coeffs = np.polyfit(k_grid, log_P_obs, d_s)\n        \n        # Construct the smooth model fit\n        S_hat = np.exp(np.polyval(poly_coeffs, k_grid))\n        \n        # Compute the residual ratio\n        R = P_obs / S_hat - 1\n\n        # --- Stage 2: Polynomial-Tilt Nulling and Matched Filtering ---\n        # Construct the polynomial nuisance basis matrix\n        # Columns are k^0, k^1, ..., k^m\n        poly_basis_matrix = np.vander(k_grid, m + 1, increasing=True)\n        \n        # Orthonormalize the basis using QR decomposition for numerical stability\n        Q, _ = np.linalg.qr(poly_basis_matrix)\n\n        # Generate damped oscillatory templates\n        damping = np.exp(-(k_grid / k_d)**2)\n        t_s = damping * np.sin(k_grid * r_s)\n        t_c = damping * np.cos(k_grid * r_s)\n        \n        # Orthogonalize templates against the nuisance space\n        # Projection operator onto nuisance space is Q @ Q.T\n        # We subtract the projection from the original vector.\n        t_s_tilde = t_s - Q @ (Q.T @ t_s)\n        t_c_tilde = t_c - Q @ (Q.T @ t_c)\n        \n        # Estimate phase by matched filtering with orthogonalized templates\n        # Inner product is the dot product for discrete vectors\n        a = np.dot(R, t_s_tilde)\n        b = np.dot(R, t_c_tilde)\n        \n        phi_hat = np.arctan2(b, a)\n        \n        # Calculate the absolute phase error\n        delta_phi = wrap_angle(phi_hat - phi_0)\n        abs_delta_phi = np.abs(delta_phi)\n        \n        results.append(abs_delta_phi)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3465639"}]}