{"hands_on_practices": [{"introduction": "当压力梯度和密度梯度不重合时产生的斜压涡量，是理解激波-湍流相互作用和界面不稳定性的关键。这项实践练习 [@problem_id:3361565] 旨在通过数值方法直接验证斜压涡量生成项。通过在一个简化的运动学框架中将该项分离出来，您将针对精确解来实施和验证其计算，从而加深对核心物理机制的理解，并锻炼关键的代码验证技能。", "problem": "要求您使用简化的二维周期性域和受控的初始谱，对激波-湍流相互作用中的斜压涡量生成项进行独立的数值验证。起点必须是可压缩的Navier–Stokes方程及其旋度（涡量输运方程）。在二维空间中，涡量沿平面外方向，记涡量为 $\\omega$、速度为 $\\boldsymbol{u}$、密度为 $\\rho$、压力为 $p$、运动粘度为 $\\nu$。物质输运的涡量方程可以写作 $D\\boldsymbol{\\omega}/Dt = (\\boldsymbol{\\omega}\\cdot\\nabla)\\boldsymbol{u} - \\boldsymbol{\\omega}(\\nabla\\cdot \\boldsymbol{u}) + \\nabla \\rho \\times \\nabla p / \\rho^2 + \\nu \\nabla^2 \\boldsymbol{\\omega}$。在运动学验证设置中，始终施加 $\\boldsymbol{u}=\\boldsymbol{0}$，因此 $D\\boldsymbol{\\omega}/Dt=\\partial \\boldsymbol{\\omega}/\\partial t$，演化方程简化为 $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$，其中 $S_b = (\\partial_x \\rho \\, \\partial_y p - \\partial_y \\rho \\, \\partial_x p)/\\rho^2$ 是斜压源项。其目的是，在不求解 $\\boldsymbol{u}$ 的情况下，在受控的 $\\rho$ 谱内容和类激波压力场下，分离并验证斜压源计算的正确性，并在 $S_b$ 不随时间变化时，将直接数值积分与精确谱解进行定量比较。\n\n域和场：使用边长为 $L_x=L_y=2\\pi$ 的双周期正方形域，用 $N_x \\times N_y$ 个均匀间隔的网格点进行离散。密度场 $\\rho(x,y)$ 必须构造成具有受控的谱内容，而压力场 $p(x,y)$ 必须表示一对平滑的、静止的、周期性的激波，其大梯度主要沿 $x$ 方向。设涡量初始条件为 $\\omega(x,y,0)=0$。所有量均为无量纲。\n\n使用的基本原理：可压缩Navier–Stokes方程，涡量定义 $\\boldsymbol{\\omega}=\\nabla\\times\\boldsymbol{u}$，物质输运形式 $D/Dt=\\partial/\\partial t+\\boldsymbol{u}\\cdot\\nabla$，以及提供斜压源项 $\\nabla \\rho \\times \\nabla p / \\rho^2$ 的、经过充分检验的涡量输运方程。必须使用周期域上的傅里叶谱微分恒等式，通过快速傅里叶变换计算空间梯度和拉普拉斯算子，角波数为 $k_x=2\\pi n_x/L_x$ 和 $k_y=2\\pi n_y/L_y$，其中 $n_x$ 和 $n_y$ 是整数模态指数。\n\n您的程序必须在三个精心选择的测试用例上实现以下验证任务，使用稳定的显式格式对 $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ 进行时间积分，并与预期结果进行比较：\n\n1. 梯度对齐（斜压源被抑制）：选择仅依赖于 $x$ 的 $\\rho(x,y)$ 和通过周期性激波对仅依赖于 $x$ 的 $p(x,y)$，使得 $\\partial_y \\rho=0$ 和 $\\partial_y p=0$，意味着 $S_b=0$。在粘度 $\\nu=0$ 的情况下积分至最终时间 $T$，并报告 $\\omega(x,y,T)$ 的 $\\ell_2$ 范数，在精确计算中该值应为 $0$。\n\n2. 梯度最大错位（无扩散的纯斜压生成）：选择仅依赖于 $y$ 的 $\\rho(x,y)$，以及如激波对中仅依赖于 $x$ 的 $p(x,y)$。当 $\\nu=0$ 时，$S_b$ 不随时间变化，精确解为 $\\omega(x,y,T)=T\\,S_b(x,y)$。数值积分至 $T$，并报告数值解 $\\omega$ 与解析解 $T\\,S_b$ 之间的相对 $\\ell_2$ 误差。\n\n3. 具有受控谱的湍流密度和扩散演化：通过谱合成方法构造 $\\rho(x,y)$，其随机相位被约束在目标波数 $k_0$ 周围的各向同性环内，并进行缩放以确保处处 $\\rho(x,y)>0$；$p(x,y)$ 仍为激波对。当粘度 $\\nu>0$ 且 $S_b$ 不随时间变化时，每个非零模的精确谱解为 $\\hat{\\omega}(\\boldsymbol{k},T)=\\hat{S}_b(\\boldsymbol{k})\\,(1-e^{-\\nu |\\boldsymbol{k}|^2 T})/(\\nu |\\boldsymbol{k}|^2)$，其中帽子符号表示傅里叶系数且 $|\\boldsymbol{k}|^2=k_x^2+k_y^2$，零模满足 $\\hat{\\omega}(\\boldsymbol{0},T)=T\\,\\hat{S}_b(\\boldsymbol{0})$。数值积分至 $T$，并报告数值解 $\\omega$ 与精确谱解的逆傅里叶变换之间的相对 $\\ell_2$ 误差。\n\n需强制执行的数值细节：使用快速傅里叶变换进行谱微分，以计算 $\\partial_x$、$\\partial_y$ 和 $\\nabla^2$。使用四阶显式Runge–Kutta方法进行时间积分。通过使用基准值加上小振幅波动，确保 $\\rho(x,y)$ 严格为正。谱合成使用可复现的随机种子。所有计算均为无量纲；无需物理单位。角度以弧度为单位。\n\n测试套件参数值：\n- 案例1：$N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0$, $T=0.20$, 激波厚度 $\\delta=0.05\\,L_x$, 压力跳跃幅度 $\\Delta p=1.0$, 密度幅度 $A_\\rho=0.1$, 沿 $x$ 方向的密度波数 $k_\\rho=4$。\n- 案例2：$N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0$, $T=0.15$, $\\delta=0.05\\,L_x$, $\\Delta p=1.0$, $A_\\rho=0.1$, 沿 $y$ 方向的密度波数 $k_\\rho=5$。\n- 案例3：$N_x=N_y=64$, $L_x=L_y=2\\pi$, $\\nu=0.01$, $T=0.20$, $\\delta=0.05\\,L_x$, $\\Delta p=1.0$, 谱环中心 $k_0=8$, 环半宽 $\\Delta k=1$, 密度脉动幅度 $A_\\rho=0.1$。\n\n程序要求：您的程序必须按规定构造 $\\rho$ 和 $p$，计算 $S_b$，使用为确保数值稳定性和准确性而选择的固定时间步长 $\\Delta t$ 将 $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ 从 $t=0$ 积分到 $t=T$，然后为每个案例计算所要求的定量指标：案例1的一个浮点数，案例2的一个浮点数，以及案例3的一个浮点数。最终输出格式必须是单行，包含由逗号分隔并用方括号括起来的三个结果，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个浮点数。\n\n您的程序必须只产生这一行输出，无其他内容。所有计算必须在没有用户输入的情况下完成。", "solution": "该问题提出了一个针对斜压涡量生成项的数值验证任务，这是可压缩流体动力学中的一个基本机制，尤其与激波-湍流相互作用相关。验证在一个简化的运动学设置中进行，其中速度场 $\\boldsymbol{u}$ 被设为零，这分离了斜压效应和粘性效应对涡量演化的影响。在二维 $(x,y)$ 中，涡量的平面外分量 $\\omega$ 的控制方程如下所示：\n$$\n\\frac{\\partial \\omega}{\\partial t} = S_b + \\nu \\nabla^2 \\omega\n$$\n其中 $\\nu$ 是运动粘度，$S_b$ 是斜压源项，由密度和压力梯度的叉积定义：\n$$\nS_b = \\frac{\\nabla \\rho \\times \\nabla p}{\\rho^2} = \\frac{1}{\\rho^2} \\left( \\frac{\\partial \\rho}{\\partial x} \\frac{\\partial p}{\\partial y} - \\frac{\\partial \\rho}{\\partial y} \\frac{\\partial p}{\\partial x} \\right)\n$$\n该问题要求在一个边长为 $L=2\\pi$、在均匀 $N_x \\times N_y$ 网格上离散的双周期正方形域上，从零涡量初始条件 $\\omega(x,y,0)=0$ 开始积分该方程。对于三个不同的测试用例，必须将解与解析结果或预期的零结果进行比较。\n\n数值实现遵循以下原则：\n\n**1. 空间离散化：傅里叶伪谱法**\n在周期域上，傅里叶谱方法是计算空间导数最精确的方法。一个函数 $f(x,y)$ 由其离散傅里叶级数系数 $\\hat{f}(k_x, k_y)$ 表示。物理空间中的空间导数对应于傅里叶空间中与虚数单位 $i$ 和相应波数的代数乘法。对于一个场 $f$ 及其傅里叶变换 $\\hat{f}$，其导数和拉普拉斯算子通过以下方式计算：\n$$\n\\frac{\\partial f}{\\partial x} = \\mathcal{F}^{-1}\\{i k_x \\hat{f}\\} \\quad , \\quad \\frac{\\partial f}{\\partial y} = \\mathcal{F}^{-1}\\{i k_y \\hat{f}\\}\n$$\n$$\n\\nabla^2 f = \\mathcal{F}^{-1}\\{-(k_x^2 + k_y^2) \\hat{f}\\}\n$$\n其中 $\\mathcal{F}^{-1}$ 表示傅里叶逆变换，$k_x$ 和 $k_y$ 是离散波数。该方法使用快速傅里叶变换（FFT）算法高效实现。\n\n**2. 时间积分：四阶Runge-Kutta（RK4）方法**\n时间演化使用经典的四阶显式Runge-Kutta格式进行，对于给定的时间步长 $\\Delta t$，该格式在精度（四阶）和稳定性之间提供了良好的平衡。对于形式为 $d\\omega/dt = \\mathcal{R}(\\omega)$ 的常微分方程，从 $\\omega_n$ 到 $\\omega_{n+1}$ 的单个时间步长计算如下：\n$$\n\\begin{aligned}\nk_1 = \\Delta t \\cdot \\mathcal{R}(\\omega_n) \\\\\nk_2 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_1/2) \\\\\nk_3 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_2/2) \\\\\nk_4 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_3) \\\\\n\\omega_{n+1} = \\omega_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n其中 $\\mathcal{R}(\\omega) = S_b + \\nu \\nabla^2 \\omega$。选择的时间步长 $\\Delta t$ 足够小，以确保数值稳定性（尤其受高波数下粘性项 $\\nu \\nabla^2 \\omega$ 的限制）和时间精度。\n\n**3. 场的构造**\n静态压力场和密度场的构造如下：\n-   **压力场：** 需要一对平滑的周期性激波，其梯度主要在 $x$ 方向。一个在 $[0, 2\\pi]$ 上周期性且具有这些特征的合适函数是 $p(x,y) = \\frac{\\Delta p}{2} \\tanh(\\frac{\\cos(x)}{\\epsilon})$，其中 $\\epsilon = 2\\delta/L_x$ 是控制激波厚度的参数。这会在 $x=\\pi/2$ 和 $x=3\\pi/2$ 附近产生陡峭的压力梯度。\n-   **密度场：**\n    -   **案例1（梯度对齐）：** 一个简单的正弦场，$\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho x)$，其梯度仅在 $x$ 方向。由于 $\\nabla p$ 也仅在 $x$ 方向，它们的叉积为零，得到 $S_b=0$。\n    -   **案例2（梯度错位）：** 一个类似的正弦场，但沿 $y$ 方向定向，$\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho y)$。在此，$\\nabla\\rho$ 垂直于 $\\nabla p$，从而最大化了斜压源项 $S_b$。\n    -   **案例3（湍流密度）：** 通过谱合成方法构造一个具有受控谱内容的场。在物理空间中生成一个随机实数场，使用FFT转换到傅里叶空间，然后进行滤波，仅保留各向同性波数环 $k_0 - \\Delta k \\le |\\boldsymbol{k}| \\le k_0 + \\Delta k$ 内的能量。将得到的滤波后的谱变换回物理空间，以获得类湍流的密度脉动场。该场按指定的幅度 $A_\\rho$ 进行缩放，并加上平均值1，以确保 $\\rho > 0$。\n\n**4. 验证与指标**\n-   **案例1：** 由于 $S_b=0$ 和 $\\nu=0$，方程变为 $\\partial \\omega/\\partial t=0$。在 $\\omega(0)=0$ 的条件下，精确解为 $\\omega(T)=0$。指标是最终数值涡量的 $\\ell_2$-范数，即 $||\\omega(T)||_2$，其值应接近机器精度。\n-   **案例2：** 当场不随时间变化且 $\\nu=0$ 时，方程为 $\\partial \\omega/\\partial t = S_b(\\text{const.})$。精确解为 $\\omega(T) = T \\cdot S_b$。指标是数值解与精确解之间的相对 $\\ell_2$ 误差，即 $||\\omega_{\\text{num}} - \\omega_{\\text{exact}}||_2 / ||\\omega_{\\text{exact}}||_2$。\n-   **案例3：** 在此案例中，$\\nu>0$，控制方程是带有常数源项的线性偏微分方程。其在傅里叶空间中的精确解已给出。对于每个波数 $\\boldsymbol{k}$：\n    $$\n    \\hat{\\omega}(\\boldsymbol{k}, T) = \\begin{cases} \\hat{S}_b(\\boldsymbol{k}) \\frac{1 - e^{-\\nu |\\boldsymbol{k}|^2 T}}{\\nu |\\boldsymbol{k}|^2}  \\text{if } |\\boldsymbol{k}| \\neq 0 \\\\ T \\cdot \\hat{S}_b(\\boldsymbol{k})  \\text{if } |\\boldsymbol{k}| = 0 \\end{cases}\n    $$\n    物理空间中的精确解 $\\omega_{\\text{exact}}(T)$ 通过对 $\\hat{\\omega}(\\boldsymbol{k}, T)$ 进行傅里叶逆变换得到。指标同样是数值解与精确解之间的相对 $\\ell_2$ 误差。\n\n提供的Python程序实现了这些步骤，处理每个测试用例以计算并报告指定的定量指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the baroclinic vorticity verification problem for three test cases.\n    \"\"\"\n    test_cases_params = [\n        {'case_id': 1, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 4},\n        {'case_id': 2, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.15, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 5},\n        {'case_id': 3, 'N': 64, 'L': 2 * np.pi, 'nu': 0.01, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k0': 8, 'dk': 1},\n    ]\n\n    results = []\n    n_steps = 1000  # Fixed number of time steps for stability and accuracy\n\n    for params in test_cases_params:\n        # 1. Setup Grid and Wavenumbers\n        N = params['N']\n        L = params['L']\n        dx = L / N\n        x_1d = np.arange(N) * dx\n        x, y = np.meshgrid(x_1d, x_1d, indexing='ij')\n\n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_sq = kx**2 + ky**2\n\n        # 2. Define Spectral Derivative Utilities\n        def grad(f_field):\n            f_hat = np.fft.fft2(f_field)\n            dfdx = np.fft.ifft2(1j * kx * f_hat).real\n            dfdy = np.fft.ifft2(1j * ky * f_hat).real\n            return dfdx, dfdy\n\n        def laplacian(f_field):\n            f_hat = np.fft.fft2(f_field)\n            return np.fft.ifft2(-k_sq * f_hat).real\n\n        # 3. Construct Initial Density and Pressure Fields\n        dp = params['dp']\n        delta_param = 2 * params['delta_rel']\n        p = (dp / 2.0) * np.tanh(np.cos(x) / delta_param)\n\n        if params['case_id'] == 1:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * x)\n        elif params['case_id'] == 2:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * y)\n        else:  # Case 3\n            k0, dk, a_rho = params['k0'], params['dk'], params['a_rho']\n            np.random.seed(42)  # For reproducibility\n\n            k_mag = np.sqrt(k_sq)\n            filter_mask = (k_mag >= k0 - dk)  (k_mag = k0 + dk)\n            \n            # Generate a random real field, FFT, filter, then IFFT\n            rand_field = np.random.randn(N, N)\n            rand_hat = np.fft.fft2(rand_field)\n            \n            rho_hat_filtered = rand_hat * filter_mask\n            delta_rho = np.fft.ifft2(rho_hat_filtered).real\n            delta_rho -= np.mean(delta_rho) # Ensure zero mean fluctuation\n            \n            # Scale to specified peak amplitude\n            max_abs_val = np.max(np.abs(delta_rho))\n            if max_abs_val > 1e-9:\n                delta_rho *= a_rho / max_abs_val\n            \n            rho = 1.0 + delta_rho\n\n        # 4. Compute Baroclinic Source Term\n        rho_dx, rho_dy = grad(rho)\n        p_dx, p_dy = grad(p)\n        S_b = (rho_dx * p_dy - rho_dy * p_dx) / rho**2\n\n        # 5. Time Integration (RK4)\n        omega = np.zeros((N, N))\n        T, nu = params['T'], params['nu']\n        dt = T / n_steps\n\n        def rhs(w):\n            return S_b + nu * laplacian(w)\n\n        for _ in range(n_steps):\n            k1 = dt * rhs(omega)\n            k2 = dt * rhs(omega + 0.5 * k1)\n            k3 = dt * rhs(omega + 0.5 * k2)\n            k4 = dt * rhs(omega + k3)\n            omega += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n        # 6. Calculate and Store Result Metric\n        if params['case_id'] == 1:\n            result = np.linalg.norm(omega)\n        elif params['case_id'] == 2:\n            omega_analytic = T * S_b\n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm > 1e-12 else error_norm\n        else: # Case 3\n            S_b_hat = np.fft.fft2(S_b)\n            omega_hat_analytic = np.zeros_like(S_b_hat)\n            \n            # Non-zero k modes\n            non_zero_k_mask = k_sq > 1e-12\n            k_sq_nz = k_sq[non_zero_k_mask]\n            \n            term = nu * k_sq_nz\n            factor = (1.0 - np.exp(-term * T)) / term\n            \n            omega_hat_analytic[non_zero_k_mask] = S_b_hat[non_zero_k_mask] * factor\n            \n            # Zero k mode (k=0)\n            omega_hat_analytic[0, 0] = S_b_hat[0, 0] * T\n            \n            omega_analytic = np.fft.ifft2(omega_hat_analytic).real\n            \n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm > 1e-12 else error_norm\n\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3361565"}, {"introduction": "瑞利-泰勒不稳定性是界面流体动力学中的一个典型问题，但在弱可压（低马赫数）条件下的数值模拟面临着巨大挑战。这项练习 [@problem_id:3361543] 通过一个简化的线性模型，揭示了低马赫数预处理这一高级数值技术的奥秘。通过分析该模型，您将推导和比较不同条件下的不稳定性增长率，从而在概念层面理解预处理是如何有效解决流体运动和声波传播之间的时间尺度差异问题。", "problem": "您的任务是构建一个数学上一致的、低成本的模型问题，该问题能捕捉低马赫数下瑞利-泰勒（Rayleigh–Taylor）界面不稳定性的初始增长，并用它来检验一种可压缩求解器预处理策略的有效性范围。重点是一个线性的、单模的设定，该设定具有普适性，因为它只需要基本定律和明确的假设，并且可以用任何编程语言实现。\n\n考虑在均匀引力场中的两种不相溶、无粘性的流体，引力加速度为 $g$（单位：$\\mathrm{m/s^2}$），重流体位于轻流体之上。设密度分别为 $\\rho_h$ 和 $\\rho_\\ell$，且 $\\rho_h  \\rho_\\ell$，定义阿特伍德数（Atwood number） $A = (\\rho_h - \\rho_\\ell)/(\\rho_h + \\rho_\\ell)$（无量纲）。假设初始平坦界面存在波数为 $k$（单位：$\\mathrm{m^{-1}}$）的小振幅、单傅里叶模式的扰动，并采用水平方向的周期性以及与线性阶段一致的势流运动学。马赫数（Mach number） $M$（无量纲）是根据下文所述的参考速度标度和声速定义的。\n\n起点和建模假设：\n- 从包含重力的可压缩欧拉方程（质量和动量守恒）以及扰动的等熵关系 $p' = c^2 \\rho'$ 开始，其中 $c$ 是声速。采用小振幅、单模线性化方法，其中所有场在水平方向上均以 $\\exp(i k x)$ 的形式变化，并随时间演化。\n- 在不可压缩极限下，当惯性项中的密度变化可忽略时（Boussinesq 近似），界面位移振幅 $\\eta(t)$ 满足一个二阶常微分方程，形式为 $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$，其中算子 $\\mathcal{L}_I$ 由 $A$、$g$ 和 $k$ 决定，并导致以某个增长率 $\\sigma_I$（单位：$\\mathrm{s^{-1}}$）的指数增长。\n- 为了以一种与低马赫数状态和快速声学尺度存在相一致的方式来模拟有限可压缩性，引入一个最小的线性三变量系统，用于描述界面振幅 $\\eta(t)$、界面垂直速度振幅 $w(t)$ 和一个模态压力梯度类振幅 $q(t)$，后者会弛豫到浮力驱动力。在该模型中，可压缩求解器由以下线性系统表示：\n  1) $\\mathrm{d}\\eta/\\mathrm{d}t = w$,\n  2) $\\mathrm{d}w/\\mathrm{d}t = k\\, q$,\n  3) $\\mathrm{d}q/\\mathrm{d}t = -\\left(q - g A \\eta\\right)/\\tau_a$,\n  其中 $\\tau_a$ 是一个弛豫时间尺度，代表声波在波长 $2\\pi/k$ 范围内传播所需的时间。此 $\\tau_a$ 必须根据下文所述的声速和预处理因子，从第一性原理出发进行选择。\n\n参考标度和马赫数的定义：\n- 令不可压缩线性增长率（将由您从上述不可压缩模型中推导得出）为 $\\sigma_I = \\sqrt{A g k}$（单位：$\\mathrm{s^{-1}}$）。定义参考速度标度为 $U_{\\mathrm{ref}} = \\sigma_I / k$（单位：$\\mathrm{m/s}$），这是单位振幅增长下的自然界面垂直速度标度。\n- 给定无量纲马赫数 $M$，定义声速为 $c = U_{\\mathrm{ref}} / M$（单位：$\\mathrm{m/s}$）。这使得 $M$ 成为比率 $U_{\\mathrm{ref}}/c$。\n- 定义一个预处理因子 $\\theta$，它将有效声速缩放为 $c_{\\mathrm{eff}} = \\theta\\, c$。考虑两种情况：\n  - 无预处理的可压缩模型（物理声学）：$\\theta = 1$。\n  - 有预处理的可压缩模型（旨在加速声学传播的低马赫数预处理）：当 $M \\le 1$ 时 $\\theta = 1/M$，当 $M  1$ 时 $\\theta = 1$。当 $M \\ll 1$ 时，这种选择将声学弛豫时间缩短了 $M$ 倍。\n- 根据上述定义的 $c_{\\mathrm{eff}}$，将声学弛豫时间设为 $\\tau_a = 1/(k\\, c_{\\mathrm{eff}})$（单位：$\\mathrm{s}$）。\n\n任务：\n1) 从不可压缩模型中，推导由控制 $\\eta(t)$ 的二阶微分方程产生的增长率 $\\sigma_I$。用 $A$、$g$ 和 $k$ 表示 $\\sigma_I$，单位为 $\\mathrm{s^{-1}}$。\n2) 从可压缩三变量线性系统中，推导形如 $\\eta(t) \\sim \\exp(\\sigma t)$ 的指数解的色散关系，并计算不稳定增长率 $\\sigma_C$（单位：$\\mathrm{s^{-1}}$），将其表示为 $A$、$g$、$k$、$M$ 以及通过 $\\tau_a$ 引入的预处理因子 $\\theta$ 的函数。当存在多个根时，您的求解器必须能稳健地选择具有最大正实部的实根。\n3) 基于以上推导，实现一个程序，对每个测试用例计算并报告以下内容：\n   - 不可压缩增长率 $\\sigma_I$（单位：$\\mathrm{s^{-1}}$），\n   - 使用指定 $\\theta$ 的可压缩预处理增长率 $\\sigma_C$（单位：$\\mathrm{s^{-1}}$），\n   - 使用 $\\theta = 1$ 的可压缩无预处理增长率 $\\sigma_C$（单位：$\\mathrm{s^{-1}}$）。\n   所有报告的值都必须以 $\\mathrm{s^{-1}}$ 为单位，并四舍五入到六位小数。\n\n测试套件：\n使用以下四个测试用例，每个用例都指定为一个元组 $(A, g, k, M)$，单位如上所述。\n- 用例 1（理想路径，低马赫数）：$(0.5,\\; 9.81,\\; 10.0,\\; 0.05)$\n- 用例 2（极低马赫数）：$(0.5,\\; 9.81,\\; 10.0,\\; 0.001)$\n- 用例 3（近稳定小阿特伍德数）：$(1.0\\times 10^{-6},\\; 9.81,\\; 10.0,\\; 0.1)$\n- 用例 4（中等马赫数，长波）：$(0.5,\\; 9.81,\\; 1.0,\\; 0.3)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须包含对应于四个用例的十二个数字，并严格遵循以下顺序：对于每个用例，输出三个数字 $[\\sigma_I,\\; \\sigma_{C,\\mathrm{pre}},\\; \\sigma_{C,\\mathrm{unpre}}]$（单位：$\\mathrm{s^{-1}}$），每个数字四舍五入到六位小数，然后将这四个三元组展开成一个单一列表。例如，一个有效的输出格式为\n\"[sigmaI_case1,sigmaCpre_case1,sigmaCun_case1,sigmaI_case2,sigmaCpre_case2,sigmaCun_case2,sigmaI_case3,sigmaCpre_case3,sigmaCun_case3,sigmaI_case4,sigmaCpre_case4,sigmaCun_case4]\"。", "solution": "该问题旨在构建并分析一个简化的瑞利-泰勒（Rayleigh–Taylor）不稳定性模型，以研究低马赫数预处理方案的效果。分析过程涉及推导不可压缩参考情况以及有预处理和无预处理两种可压缩模型的失稳增长率。\n\n**第 1 部分：不可压缩增长率（$\\sigma_I$）**\n\n问题指出，在不可压缩 Boussinesq 极限下，界面位移振幅 $\\eta(t)$ 由一个二阶常微分方程（ODE）控制，其形式为 $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$，其中 $\\mathcal{L}_I$ 是一个依赖于阿特伍德数 $A$、引力加速度 $g$ 和扰动波数 $k$ 的线性算子。\n\n为了确定算子 $\\mathcal{L}_I$，我们可以研究在声学传播速度无限快的极限情况下，所提供的三变量可压缩模型。模型如下：\n1) $\\mathrm{d}\\eta/\\mathrm{d}t = w$\n2) $\\mathrm{d}w/\\mathrm{d}t = k\\, q$\n3) $\\mathrm{d}q/\\mathrm{d}t = -\\left(q - g A \\eta\\right)/\\tau_a$\n\n不可压缩极限对应于压力场的无限快调整，这在模型中表现为弛豫时间 $\\tau_a \\to 0$。在此极限下，为了使 $\\mathrm{d}q/\\mathrm{d}t$ 保持有限，第三个方程意味着括号中的项必须为零。因此，我们得到平衡条件：\n$$ q(t) = g A \\eta(t) $$\n将此代入第二个方程，得到：\n$$ \\frac{\\mathrm{d}w}{\\mathrm{d}t} = k (g A \\eta) = A g k \\eta $$\n从第一个方程可知 $w = \\mathrm{d}\\eta/\\mathrm{d}t$。将其对时间求导，得到 $\\mathrm{d}w/\\mathrm{d}t = \\mathrm{d}^2\\eta/\\mathrm{d}t^2$。结合这些结果，我们获得了关于 $\\eta(t)$ 的二阶常微分方程：\n$$ \\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} = A g k \\eta $$\n将其与通用形式 $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$ 进行比较，我们确定算子 $\\mathcal{L}_I$ 为乘以常数 $A g k$。为了求得增长率，我们假设解的形式为 $\\eta(t) \\propto \\exp(\\sigma_I t)$。将此代入常微分方程，得到特征方程：\n$$ \\sigma_I^2 = A g k $$\n瑞利-泰勒（Rayleigh–Taylor）不稳定性对应于指数增长的解，因此我们取正根。这得出了经典的不可压缩增长率：\n$$ \\sigma_I = \\sqrt{A g k} $$\n这完成了任务1的推导，并验证了问题陈述中提供的公式。\n\n**第 2 部分：可压缩增长率（$\\sigma_C$）**\n\n对于有限的声学弛豫时间 $\\tau_a$，我们必须求解完整的三变量线性系统。我们假设所有三个变量都具有指数形式的解：\n$$ \\eta(t) = \\eta_0 e^{\\sigma t}, \\quad w(t) = w_0 e^{\\sigma t}, \\quad q(t) = q_0 e^{\\sigma t} $$\n其中 $\\sigma$ 是待确定的复增长率。将这些代入常微分方程组，得到关于振幅 $(\\eta_0, w_0, q_0)$ 的代数系统：\n1) $\\sigma \\eta_0 = w_0$\n2) $\\sigma w_0 = k q_0$\n3) $\\sigma q_0 = -\\left(q_0 - g A \\eta_0\\right)/\\tau_a$\n\n这可以写成一个齐次线性系统。一个更直接的方法是推导一个关于 $\\eta(t)$ 的三阶常微分方程。从 $\\eta(t)$ 出发，我们可以用 $\\eta(t)$ 及其导数来表示 $w(t)$、$q(t)$ 和它们的导数：\n$$ w = \\frac{\\mathrm{d}\\eta}{\\mathrm{d}t} $$\n$$ q = \\frac{1}{k}\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\frac{1}{k}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} $$\n$$ \\frac{\\mathrm{d}q}{\\mathrm{d}t} = \\frac{1}{k}\\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} $$\n将这些表达式代入第三个常微分方程：\n$$ \\frac{1}{k}\\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} = -\\frac{1}{\\tau_a}\\left(\\frac{1}{k}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} - g A \\eta \\right) $$\n两边乘以 $k$ 并重新整理各项，我们得到：\n$$ \\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} + \\frac{1}{\\tau_a}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} - \\frac{A g k}{\\tau_a} \\eta = 0 $$\n假设解的形式为 $\\eta(t) \\propto \\exp(\\sigma t)$，我们得到可压缩增长率 $\\sigma$ 的特征方程（或色散关系）：\n$$ \\sigma^3 + \\frac{1}{\\tau_a}\\sigma^2 - \\frac{A g k}{\\tau_a} = 0 $$\n使用 $\\sigma_I^2 = A g k$，上式可简化为：\n$$ \\sigma^3 + \\frac{1}{\\tau_a}\\sigma^2 - \\frac{\\sigma_I^2}{\\tau_a} = 0 $$\n对这个三次多项式的分析表明，它有且仅有一个正实根，该根对应于物理上的瑞利-泰勒不稳定性增长率 $\\sigma_C$。\n\n弛豫时间 $\\tau_a$ 定义为 $\\tau_a = 1/(k c_{\\mathrm{eff}})$，其中 $c_{\\mathrm{eff}} = \\theta c$，$c = U_{\\mathrm{ref}} / M$，以及 $U_{\\mathrm{ref}} = \\sigma_I/k$。代入这些定义，得到：\n$$ \\frac{1}{\\tau_a} = k c_{\\mathrm{eff}} = k (\\theta c) = k \\theta \\frac{U_{\\mathrm{ref}}}{M} = k \\theta \\frac{\\sigma_I/k}{M} = \\frac{\\theta \\sigma_I}{M} $$\n将此代入特征方程，得到：\n$$ \\sigma^3 + \\left(\\frac{\\theta \\sigma_I}{M}\\right)\\sigma^2 - \\left(\\frac{\\theta \\sigma_I}{M}\\right)\\sigma_I^2 = 0 $$\n为了简化，我们通过定义 $\\hat{\\sigma} = \\sigma / \\sigma_I$ 来对增长率进行无量纲化。我们还定义一个无量纲参数 $\\alpha = \\theta/M$。方程变为：\n$$ (\\hat{\\sigma}\\sigma_I)^3 + \\alpha \\sigma_I (\\hat{\\sigma}\\sigma_I)^2 - \\alpha \\sigma_I \\sigma_I^2 = 0 $$\n两边除以 $\\sigma_I^3$：\n$$ \\hat{\\sigma}^3 + \\alpha \\hat{\\sigma}^2 - \\alpha = 0 $$\n这就是关于缩放增长率 $\\hat{\\sigma}$ 的最终无量纲方程。对于任何给定的测试用例，我们计算参数 $\\alpha$，并求解这个三次方程以得到其唯一的正实根 $\\hat{\\sigma}_C$。那么，物理上的可压缩增长率就是 $\\sigma_C = \\hat{\\sigma}_C \\sigma_I$。\n\n**第 3 部分：实现策略**\n\n程序将对每个测试用例 $(A, g, k, M)$ 实现以下步骤：\n1.  计算不可压缩增长率 $\\sigma_I = \\sqrt{A g k}$。\n2.  对于**有预处理**的情况：\n    a. 确定预处理因子 $\\theta_{pre} = 1/M$（因为所有测试用例的 $M \\le 1$）。\n    b. 计算参数 $\\alpha_{pre} = \\theta_{pre}/M = 1/M^2$。\n    c. 求解三次方程 $\\hat{\\sigma}^3 + \\alpha_{pre} \\hat{\\sigma}^2 - \\alpha_{pre} = 0$，得到正实根 $\\hat{\\sigma}_{C,pre}$。\n    d. 计算增长率 $\\sigma_{C,pre} = \\hat{\\sigma}_{C,pre} \\sigma_I$。\n3.  对于**无预处理**的情况：\n    a. 因子为 $\\theta_{unpre} = 1$。\n    b. 计算参数 $\\alpha_{unpre} = \\theta_{unpre}/M = 1/M$。\n    c. 求解三次方程 $\\hat{\\sigma}^3 + \\alpha_{unpre} \\hat{\\sigma}^2 - \\alpha_{unpre} = 0$，得到正实根 $\\hat{\\sigma}_{C,unpre}$。\n    d. 计算增长率 $\\sigma_{C,unpre} = \\hat{\\sigma}_{C,unpre} \\sigma_I$。\n4.  然后对这三个值 $(\\sigma_I, \\sigma_{C,pre}, \\sigma_{C,unpre})$ 进行格式化和收集。\n\n该三次多项式的根通过数值方法求解。标准的数值库例程可以找到所有三个复根。所需的根通过其性质来识别：是实数（在小的数值容差范围内）且为正数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Rayleigh-Taylor instability growth rate problem for the specified test cases.\n    \"\"\"\n    \n    # Test cases: tuples of (A, g, k, M)\n    test_cases = [\n        (0.5, 9.81, 10.0, 0.05),     # Case 1\n        (0.5, 9.81, 10.0, 0.001),    # Case 2\n        (1.0e-6, 9.81, 10.0, 0.1),    # Case 3\n        (0.5, 9.81, 1.0, 0.3)       # Case 4\n    ]\n\n    results = []\n\n    def get_compressible_rate(alpha, sigma_I):\n        \"\"\"\n        Solves the non-dimensional cubic equation for the growth rate.\n        \n        The equation is: hat_sigma^3 + alpha * hat_sigma^2 - alpha = 0.\n        \n        Args:\n            alpha (float): The dimensionless parameter alpha = theta/M.\n            sigma_I (float): The incompressible growth rate.\n        \n        Returns:\n            float: The compressible growth rate sigma_C.\n        \"\"\"\n        # Coefficients of the polynomial p(x) = x^3 + alpha*x^2 + 0*x - alpha\n        coeffs = [1, alpha, 0, -alpha]\n        roots = np.roots(coeffs)\n        \n        # We need the unique positive real root.\n        # It's guaranteed to exist and be unique.\n        # We filter for it by checking for a positive real part and negligible imaginary part.\n        positive_real_root = None\n        for r in roots:\n            if r.real > 0 and np.abs(r.imag)  1e-9:\n                positive_real_root = r.real\n                break\n        \n        if positive_real_root is None:\n            # This case should not be reached based on the analysis.\n            # Handle as an error if it occurs.\n            raise ValueError(\"Could not find a positive real root.\")\n            \n        hat_sigma_C = positive_real_root\n        sigma_C = hat_sigma_C * sigma_I\n        return sigma_C\n\n    for case in test_cases:\n        A, g, k, M = case\n        \n        # 1. Calculate the incompressible growth rate sigma_I\n        sigma_I = np.sqrt(A * g * k)\n        \n        # --- Preconditioned Case ---\n        # Determine preconditioning factor theta\n        theta_pre = 1.0 / M if M = 1.0 else 1.0\n        # Calculate alpha parameter\n        alpha_pre = theta_pre / M\n        # Calculate compressible growth rate\n        sigma_C_pre = get_compressible_rate(alpha_pre, sigma_I)\n        \n        # --- Unpreconditioned Case ---\n        # Theta is 1\n        theta_unpre = 1.0\n        # Calculate alpha parameter\n        alpha_unpre = theta_unpre / M\n        # Calculate compressible growth rate\n        sigma_C_unpre = get_compressible_rate(alpha_unpre, sigma_I)\n        \n        # Append results for the current case\n        results.append(sigma_I)\n        results.append(sigma_C_pre)\n        results.append(sigma_C_unpre)\n\n    # Format the results to exactly six decimal places for the final output string.\n    results_str = [\"{:.6f}\".format(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```", "id": "3361543"}, {"introduction": "湍流与激波的相互作用是可压缩计算流体动力学的一个基石问题，其应用遍及天体物理学到航空航天工程。这个过程会导致湍动能的放大和雷诺应力的各向异性。这项高级实践 [@problem_id:3361602] 将引导您构建一个用于模拟激波-湍流相互作用的降阶模型，这是大涡模拟（LES）等现代模拟方法的核心任务。您将根据快速畸变理论（RDT）的预测来校准模型，并探索不同激波传感器的影响。该练习综合了流体理论、湍流模型和数值方法等多个领域的概念，为复杂可压缩流的建模提供了一次综合性的实践。", "problem": "您需要实现一个自洽的降阶可压缩大涡模拟（LES）响应模型，用于模拟均匀各向同性湍流以马赫数 $M_s$ 撞击一个平直、静止的正激波。目标是使用三种不同的激波传感器，计算跨激波的湍动能 $k$ 的放大和各向异性张量 $a_{ij}$ 作为马赫数 $M_s$ 的函数。模型常数将通过匹配从线性（快速畸变）极限下跨激波的守恒定律推导出的雷诺应力跳跃条件来进行标定。所有输出必须是无量纲浮点数。\n\n从以下基本基础开始：\n\n- 带有理想气体定律和跨静止平直正激波的Rankine–Hugoniot跳跃条件的可压缩Navier–Stokes方程。对于比热比为 $\\gamma$ 的理想气体，密度比的精确平均跳跃为\n$$\n\\eta \\equiv \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2},\n$$\n静压比的精确平均跳跃为\n$$\n\\Pi \\equiv \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\n假设 $\\gamma = 1.4$。\n\n- 对平均量使用Favre（密度加权）平均，对脉动量使用标准Reynolds分解。设上游湍流是均匀且各向同性的，其上游湍动能为 $k_1$，上游雷诺应力为\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij},\n$$\n其中 $u_i'$ 是速度脉动，$\\delta_{ij}$ 是克罗内克δ函数。为归一化设置 $k_1 = 1$，因此所有输出均为无量纲。\n\n- 通过带有法向和切向乘子的分量式跳跃模型定义下游雷诺应力 $R_{ij,2}$：\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = C_t \\, R_{22,1}, \\quad R_{33,2} = C_t \\, R_{33,1}.\n$$\n定义下游湍动能 $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$，其放大 $A_k \\equiv k_2/k_1$，以及下游各向异性张量\n$$\na_{ij} = \\frac{R_{ij,2}}{2 k_2} - \\frac{1}{3}\\delta_{ij}.\n$$\n\n- 使用带有两个未知常数 $C_1$ 和 $C_2$ 的激波传感器加权的代数响应来对 $C_n$ 和 $C_t$ 进行建模：\n$$\ns \\equiv g_s \\, (\\eta - 1), \\quad C_n = 1 + C_1 s + C_2 s^2, \\quad C_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2,\n$$\n其中 $g_s \\in [0,1]$ 是所选激波传感器（定义如下）的输出。$C_n$ 和 $C_t$ 之间的分解关系编码了围绕激波法线方向的轴对称畸变。\n\n- 通过在快速畸变极限下强制满足从平直正激波的线性化守恒推导出的雷诺应力跳跃条件来标定 $(C_1, C_2)$。使用以下目标分量比作为标定目标：\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}, \\qquad C_t^{\\text{target}}(\\eta) = \\eta,\n$$\n它们分别代表由质量通量连续性引起的法向分量减小，以及由穿过激波积分的平均压缩快速畸变引起的切向分量放大。通过最小化残差平方和来确定 $(C_1, C_2)$\n$$\nJ(C_1,C_2) = \\sum_{M_s \\in \\mathcal{S}_{\\text{cal}}} \\left[ \\left(C_n(M_s) - C_n^{\\text{target}}(\\eta(M_s))\\right)^2 + \\left(C_t(M_s) - C_t^{\\text{target}}(\\eta(M_s))\\right)^2 \\right],\n$$\n在标定集 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 上，并使用固定的标定滤波器与激波厚度之比 $\\Delta/\\delta = 1$。因为 $C_n$ 和 $C_t$ 在减1后是 $C_1$ 和 $C_2$ 的线性函数，所以这是一个关于 $(C_1, C_2)$ 的线性最小二乘问题。\n\n- 实现三种激波传感器来计算 $g_s$：\n  1. 密度梯度传感器 $g_\\rho$：将激波建模为厚度为 $\\delta$ 的 $\\tanh$ 剖面，网格滤波器宽度为 $\\Delta$。令\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  其中 $\\alpha_\\rho = 0.75$。\n  2. 基于压力的传感器 $g_p$：使用压力跳跃，\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  其中 $\\alpha_p = 0.50$。\n  3. Ducros型传感器 $g_D$：使用与 $M_s^2$ 成正比的压缩指示器，\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  其中 $\\alpha_D = 0.35$。\n\n要实现的工作流程：\n\n- 对于给定的 $(M_s, \\delta/\\Delta, \\text{sensor})$，使用 $\\gamma = 1.4$ 从Rankine–Hugoniot公式计算 $\\eta(M_s)$ 和 $\\Pi(M_s)$。计算 $\\Delta/\\delta = 1/(\\delta/\\Delta)$。\n\n- 对于每个传感器，首先使用标定集 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 和 $\\Delta/\\delta = 1$（因此 $\\delta/\\Delta = 1$）求解上述定义的线性最小二乘问题，以标定 $(C_1, C_2)$。在每个标定马赫数 $M_s$ 处，使用特定于传感器的 $g_s$ 来定义 $s$。\n\n- 使用为所选传感器标定的 $(C_1, C_2)$，在请求的 $(M_s, \\delta/\\Delta, \\text{sensor})$ 处计算 $C_n$ 和 $C_t$，然后为 $k_1 = 1$ 和 $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$ 计算 $A_k$ 和 $a_{11}$。\n\n数值和实现细节：\n\n- 使用 $\\gamma = 1.4$ 和 $k_1 = 1$。所有量均为无量纲。\n\n- 测试套件包含以下三种情况，您必须按顺序进行计算：\n  - 情况1：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$，使用密度梯度传感器 $g_\\rho$。\n  - 情况2：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$，使用基于压力的传感器 $g_p$。\n  - 情况3：$(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$，使用Ducros型传感器 $g_D$。\n\n- 对于每种情况，生成两个输出：湍动能放大 $A_k$ 和法向分量各向异性 $a_{11}$，两者均为无量纲浮点数，并四舍五入到小数点后六位。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含按以下顺序排列的结果，形式为用方括号括起来的逗号分隔列表\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}].\n$$\n不应打印任何其他文本。所有输出都必须是四舍五入到六位小数的无量纲浮点数。", "solution": "我们构建一个有理论依据的降阶模型，该模型在小尺度快速畸变的极限下，捕捉了均匀各向同性湍流的激波-湍流相互作用的核心物理。我们从守恒定律和标准分解出发，然后制定一个针对雷诺应力跳跃关系的标定方案，最后定义一个可以实现为简短数值程序的算法。\n\n基本方程和定义：\n\n- 对于比热比为 $\\gamma$ 的理想气体中的静止平直正激波，平均场的Rankine–Hugoniot跳跃条件给出了精确的密度和压力比：\n$$\n\\eta(M_s) = \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2}, \\quad\n\\Pi(M_s) = \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\n\n- 上游流场是均匀且各向同性的，其上游湍动能为 $k_1$，雷诺应力为\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij}.\n$$\n我们设置 $k_1 = 1$，因此 $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$。下游应力使用分量乘子 $C_n$（法向）和 $C_t$（切向）进行建模：\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = R_{33,2} = C_t \\, R_{22,1}.\n$$\n那么下游湍动能为 $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$，放大率为 $A_k \\equiv k_2/k_1$。各向异性张量为 $a_{ij} = \\frac{R_{ij,2}}{2k_2} - \\frac{1}{3}\\delta_{ij}$，我们将从中提取 $a_{11}$。\n\n基于快速畸变的跳跃目标：\n\n- 对于与x轴对齐的平直激波（x为激波法向），我们考虑一个跨越激波的小控制体，并对扰动的质量和动量守恒进行线性化。质量通量连续性表明，法向速度扰动与跨间断的密度增加成反比，即 $u_n' \\to u_n'/\\eta$，这是在假设激波厚度与湍流尺度相比可忽略不计，并且忽略极薄间断内部密度扰动的情况下。对振幅求平方意味着法向分量的方差按 $1/\\eta^2$ 变化。因此，对于法向分量，我们的目标是\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}.\n$$\n\n- 切向分量受压缩性平均快速畸变的影响。在平面压缩的快速畸变理论中，切向分量经历的放大与穿过激波积分的压缩因子成正比。对于围绕法向的轴对称畸变，切向方差的增长与密度增加成正比（反映了物质面的收缩和伴随的切向梯度放大），从而得到\n$$\nC_t^{\\text{target}}(\\eta) = \\eta.\n$$\n这对目标在线性极限下与质量守恒（对法向分量）和压缩性快速畸变（对切向分量）是一致的，并已在激波-湍流相互作用模型中被广泛用作一阶近似。\n\n代数响应模型：\n\n- 我们引入一个带有两个未知常数 $C_1$ 和 $C_2$ 的传感器加权代数模型，用于分量乘子：\n$$\ns \\equiv g_s (\\eta - 1), \\quad\nC_n = 1 + C_1 s + C_2 s^2, \\quad\nC_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2.\n$$\n这里 $g_s \\in [0,1]$ 是一个激波传感器。$C_n$ 和 $C_t$ 的特定形式强制了围绕激波法向的轴对称畸变，并确保当 $s \\to 0$ 时（无激波或激波完全未解析），$C_n, C_t \\to 1$。\n\n激波传感器：\n\n- 我们需要三种传感器 $g_s$，它们随激波强度和解析度（$\\Delta/\\delta$）单调增加，其中 $\\Delta$ 是网格滤波器宽度，$\\delta$ 是激波厚度。注意到 $\\tanh$ 剖面的最大梯度与 $1/\\delta$ 成比例，我们定义：\n  1. 密度梯度传感器：\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_\\rho = 0.75.\n  $$\n  2. 基于压力的传感器：\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_p = 0.50.\n  $$\n  3. Ducros型压缩传感器：\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_D = 0.35.\n  $$\n\n标定程序：\n\n- 我们通过在标定集 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 上使用 $\\Delta/\\delta = 1$ 来最小化模型分量 $(C_n, C_t)$ 和目标 $(\\eta^{-2}, \\eta)$ 之间的残差平方，从而确定 $C_1$ 和 $C_2$。因为在减去1后，对 $(C_1, C_2)$ 的依赖是线性的，所以我们组装一个最小二乘形式的线性系统。对于每个 $M_s \\in \\mathcal{S}_{\\text{cal}}$，令 $s = g_s (\\eta - 1)$，然后我们强制满足\n$$\nC_n - 1 = C_1 s + C_2 s^2 \\approx \\eta^{-2} - 1, \\quad\nC_t - 1 = C_1 \\frac{s}{2} + C_2 \\frac{s^2}{4} \\approx \\eta - 1.\n$$\n将这两个 $M_s$ 值对应的方程堆叠起来，得到关于 $(C_1, C_2)$ 的四个方程，我们在最小二乘意义上求解该方程组。\n\n输出的计算：\n\n- 给定 $(M_s, \\delta/\\Delta, \\text{sensor})$，计算 $\\eta(M_s)$ 和 $\\Pi(M_s)$，计算 $\\Delta/\\delta = 1/(\\delta/\\Delta)$，并根据传感器定义计算 $g_s$。计算 $s = g_s(\\eta-1)$，然后计算 $C_n$ 和 $C_t$。对于 $R_{ij,1} = \\frac{2}{3}\\delta_{ij}$，可得\n$$\nR_{11,2} = \\frac{2}{3} C_n, \\quad R_{22,2} = R_{33,2} = \\frac{2}{3} C_t,\n$$\n所以\n$$\nk_2 = \\frac{1}{2}\\left( \\frac{2}{3} C_n + 2 \\cdot \\frac{2}{3} C_t \\right) = \\frac{1}{3} \\left( C_n + 2 C_t \\right)\n$$\n以及\n$$\nA_k = \\frac{k_2}{k_1} = \\frac{1}{3} \\left( C_n + 2 C_t \\right).\n$$\n最后，\n$$\na_{11} = \\frac{R_{11,2}}{2k_2} - \\frac{1}{3} = \\frac{\\frac{2}{3} C_n}{\\frac{2}{3} (C_n + 2 C_t)} - \\frac{1}{3} = \\frac{C_n}{C_n + 2 C_t} - \\frac{1}{3}.\n$$\n\n测试套件和输出：\n\n- 使用 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 和 $\\Delta/\\delta = 1$ 为每个传感器分别标定 $(C_1, C_2)$。\n\n- 按顺序计算以下情况：\n  - 情况1：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$，使用 $g_\\rho$。\n  - 情况2：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$，使用 $g_p$。\n  - 情况3：$(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$，使用 $g_D$。\n\n- 对于每种情况，计算 $A_k$ 和 $a_{11}$ 并打印\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}]\n$$\n在单行上，形式为逗号分隔的浮点数（四舍五入到六位小数）。所有输出均为无量纲。\n\n算法总结：\n\n- 实现给定 $\\gamma$ 的函数 $\\eta(M_s)$ 和 $\\Pi(M_s)$。\n\n- 实现传感器函数 $g_\\rho$、$g_p$、$g_D$。\n\n- 对于每个传感器，使用标定集求解一个 $4 \\times 2$ 的线性最小二乘问题以确定 $(C_1, C_2)$。\n\n- 对于每个测试用例，使用上述公式计算 $C_n$、$C_t$，然后计算 $A_k$ 和 $a_{11}$。\n\n该方法是基于原理的：它从激波处的守恒定律（Rankine–Hugoniot）出发，使用线性快速畸变论证来定义目标雷诺应力跳跃关系，并构建了一个与激波感知相关联并通过匹配这些目标进行标定的最小代数模型。该算法是确定性的，并由上述方程完全指定，从而确保了可复现性和单行数值输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nGAMMA = 1.4\n\ndef density_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot density ratio across a normal shock\n    num = (gamma + 1.0) * Ms**2\n    den = (gamma - 1.0) * Ms**2 + 2.0\n    return num / den\n\ndef pressure_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot pressure ratio across a normal shock\n    return 1.0 + (2.0 * gamma / (gamma + 1.0)) * (Ms**2 - 1.0)\n\ndef sensor_value(sensor, Ms, delta_over_Delta, gamma=GAMMA):\n    # Compute g_s based on the specified sensor and parameters.\n    # delta_over_Delta = delta/Delta, so inv_ratio = Delta/delta\n    inv_ratio = 1.0 / delta_over_Delta\n    eta = density_ratio(Ms, gamma)\n    Pi = pressure_ratio(Ms, gamma)\n    if sensor == 'density':\n        alpha_rho = 0.75\n        arg = alpha_rho * (eta - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'pressure':\n        alpha_p = 0.50\n        arg = alpha_p * (Pi - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'ducros':\n        alpha_d = 0.35\n        arg = alpha_d * (Ms**2) * inv_ratio\n        return np.tanh(arg)\n    else:\n        raise ValueError(\"Unknown sensor type\")\n\ndef calibrate_constants(sensor, gamma=GAMMA):\n    # Calibrate C1, C2 for the given sensor using Ms in {1.5, 3.0} and Delta/delta = 1 (i.e., delta/Delta=1)\n    Ms_list = [1.5, 3.0]\n    delta_over_Delta_cal = 1.0  # so inv_ratio = 1\n    rows = []\n    rhs = []\n    for Ms in Ms_list:\n        eta = density_ratio(Ms, gamma)\n        # Targets from rapid-distortion-based jump conditions\n        Cn_target = eta**(-2.0)\n        Ct_target = eta\n        # Sensor\n        gs = sensor_value(sensor, Ms, delta_over_Delta_cal, gamma)\n        s = gs * (eta - 1.0)\n        # Equations: Cn - 1 = C1*s + C2*s^2  -> row [s, s^2], rhs (Cn_target - 1)\n        rows.append([s, s**2])\n        rhs.append(Cn_target - 1.0)\n        # Ct - 1 = C1*(s/2) + C2*(s^2/4)\n        rows.append([0.5 * s, 0.25 * s**2])\n        rhs.append(Ct_target - 1.0)\n    A = np.array(rows, dtype=float)\n    b = np.array(rhs, dtype=float)\n    # Least-squares solution\n    theta, *_ = np.linalg.lstsq(A, b, rcond=None)\n    C1, C2 = theta[0], theta[1]\n    return C1, C2\n\ndef compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, gamma=GAMMA):\n    # Compute Ak and a11 for given case and calibrated constants.\n    eta = density_ratio(Ms, gamma)\n    gs = sensor_value(sensor, Ms, delta_over_Delta, gamma)\n    s = gs * (eta - 1.0)\n    Cn = 1.0 + C1 * s + C2 * s**2\n    Ct = 1.0 + 0.5 * C1 * s + 0.25 * C2 * s**2\n    # Upstream R_ii,1 = 2/3\n    R11_2 = (2.0 / 3.0) * Cn\n    R22_2 = (2.0 / 3.0) * Ct\n    R33_2 = (2.0 / 3.0) * Ct\n    k2 = 0.5 * (R11_2 + R22_2 + R33_2)\n    Ak = k2 / 1.0  # since k1 = 1\n    # a11 = R11/(2 k2) - 1/3\n    a11 = (R11_2 / (2.0 * k2)) - (1.0 / 3.0)\n    return Ak, a11\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (Ms, delta_over_Delta, sensor_key)\n    test_cases = [\n        (1.05, 2.0, 'density'),  # Case 1: density-gradient sensor\n        (1.5,  1.0, 'pressure'), # Case 2: pressure-based sensor\n        (3.0,  0.25, 'ducros'),  # Case 3: Ducros-type sensor\n    ]\n\n    # Calibrate constants for each sensor independently.\n    sensors = ['density', 'pressure', 'ducros']\n    calib = {}\n    for s in sensors:\n        C1, C2 = calibrate_constants(s, GAMMA)\n        calib[s] = (C1, C2)\n\n    results = []\n    for Ms, delta_over_Delta, sensor in test_cases:\n        C1, C2 = calib[sensor]\n        Ak, a11 = compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, GAMMA)\n        # Round to six decimals as specified\n        results.append(f\"{Ak:.6f}\")\n        results.append(f\"{a11:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3361602"}]}