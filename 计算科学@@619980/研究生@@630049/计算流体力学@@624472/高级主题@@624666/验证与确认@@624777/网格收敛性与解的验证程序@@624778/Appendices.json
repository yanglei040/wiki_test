{"hands_on_practices": [{"introduction": "任何网格收敛性研究的第一步都是验证数值误差是否以理论预测的速率减小。此练习 [@problem_id:3326375] 演示了如何使用来自三个系统加密网格的数据来计算观测精度阶 $p$，这是验证代码和数值方法正确性的核心步骤。通过将计算结果与理论阶数进行比较，您可以深入了解实际模拟中可能导致阶数偏差的因素。", "problem": "使用制造解方法（MMS）对一个稳态二维标量对流扩散方程进行验证。该代码在均匀笛卡尔网格上采用以单元为中心的有限体积（FV）离散方法。面法向对流通量通过在面中心使用基于单元中心值和最小二乘梯度的分段线性重构来计算，而扩散通量则使用基于单元中心值的Green-Gauss梯度计算，并将材料系数算术平均到面上。对于制造的光滑解，没有激活斜率限制器。空间网格是嵌套的，并以恒定的加密比进行均匀加密，并且在整个域内精确的MMS场都是已知的。对于三种尺寸为 $N \\times N$（其中 $N \\in \\{32, 64, 128\\}$）的网格，标量场的离散误差以离散 $L_{1}$ 范数的形式给出。记 $h$ 为均匀单元宽度，则有 $h_1 = 1/32$，$h_2 = 1/64$，$h_3 = 1/128$，且加密比恒为 $r = h_1/h_2 = h_2/h_3 = 2$。测得的误差为\n\n$$\nE(h_{1}) = E_{1} = 3.200 \\times 10^{-3}, \\quad E(h_{2}) = E_{2} = 8.500 \\times 10^{-4}, \\quad E(h_{3}) = E_{3} = 2.200 \\times 10^{-4}.\n$$\n\n从离散误差的核心定义和相容方法的标准渐进误差模型出发，推导一个关系式，以便从多个网格间距的数据中推断出观测精度阶 $p$。然后，使用上述三个误差测量值，确定该以单元为中心的有限体积格式的观测阶 $p$。将您的答案四舍五入到四位有效数字，并以无量纲数的形式报告。\n\n最后，将观测阶与在均匀笛卡尔网格上采用分段线性重构和单点面通量积分的名义二阶期望值进行比较，并从重构和通量积分误差的角度，从物理和数值上解释为何可能出现与名义阶的偏差。您的解释应基于关于截断误差、多项式重构和数值积分的基本原理，而不应引用任何黑箱公式。", "solution": "将按要求分三部分对问题进行分析：首先，推导观测精度阶的关系式；其次，使用所提供的数据计算该阶数；第三，解释观测阶与名义理论阶之间的偏差。\n\n### 第1部分：观测精度阶关系式的推导\n\n本分析的基础是相容数值方法的渐进误差模型。对于足够小的网格间距 $h$，离散误差 $E$ 预期会遵循以下关系：\n$E(h) = C h^p + O(h^{p+q})$\n其中 $C$ 是一个与 $h$ 无关的常数，$p$ 是该方法的形式精度阶，而 $q \\ge 1$ 的项 $O(h^{p+q})$ 代表误差展开中的高阶项。\n\n在 $h \\to 0$ 的渐进极限下，主导项占主导地位，我们可以写出如下近似式：\n$E(h) \\approx C h^p$\n为了确定观测精度阶 $p$，我们可以使用在至少两个不同网格上模拟得到的误差测量值。让我们考虑两个特征单元尺寸分别为 $h_i$ 和 $h_j$ 的网格，及其对应的误差 $E_i$ 和 $E_j$。应用渐进模型，我们有：\n$$\nE_i \\approx C h_i^p\n$$\n$$\nE_j \\approx C h_j^p\n$$\n假设在此网格间距范围内 $C$ 和 $p$ 是常数，我们可以通过取两个误差方程的比值来消除常数 $C$：\n$$\n\\frac{E_i}{E_j} \\approx \\frac{C h_i^p}{C h_j^p} = \\left(\\frac{h_i}{h_j}\\right)^p\n$$\n为了解出 $p$，我们对两边取自然对数：\n$$\n\\ln\\left(\\frac{E_i}{E_j}\\right) \\approx \\ln\\left(\\left(\\frac{h_i}{h_j}\\right)^p\\right) = p \\ln\\left(\\frac{h_i}{h_j}\\right)\n$$\n这就得到了我们所期望的观测精度阶关系式：\n$$\np \\approx \\frac{\\ln(E_i/E_j)}{\\ln(h_i/h_j)}\n$$\n这个关系式可以用于任意一对网格。当有三个或更多具有恒定加密比 $r = h_k/h_{k+1}$ 的网格时（如本例所示），可以为每对连续的网格计算 $p$。然而，一个利用所有数据点的更稳健的方法是对误差模型的对数形式 $\\ln(E) = p \\ln(h) + \\ln(C)$ 进行线性最小二乘拟合。\n\n对于三个经过均匀加密的网格，当点 $(\\ln(h_1), \\ln(h_2), \\ln(h_3))$ 等距时，最小二乘最佳拟合斜率 $p$ 与使用最外侧两个数据点 $(h_1, E_1)$ 和 $(h_3, E_3)$ 计算出的斜率相同。因此，从这种方法推导出的关系式是：\n$$\np = \\frac{\\ln(E_1/E_3)}{\\ln(h_1/h_3)}\n$$\n这就是我们将用于计算的关系式。\n\n### 第2部分：观测精度阶的计算\n\n问题提供了以下数据：\n- 网格间距：$h_1 = 1/32$，$h_2 = 1/64$，$h_3 = 1/128$。\n- 恒定的网格加密比为 $r = h_1/h_2 = h_2/h_3 = 2$。\n- 测量误差：$E_1 = 3.200 \\times 10^{-3}$，$E_2 = 8.500 \\times 10^{-4}$，以及 $E_3 = 2.200 \\times 10^{-4}$。\n\n我们使用推导出的关系式以及来自最粗网格 ($h_1, E_1$) 和最细网格 ($h_3, E_3$) 的数据，以获得在所研究范围内最具代表性的精度阶。网格间距的比值为：\n$$\n\\frac{h_1}{h_3} = \\frac{1/32}{1/128} = \\frac{128}{32} = 4\n$$\n或者，由于 $h_1=rh_2=r(rh_3)=r^2 h_3$，该比值为 $r^2=2^2=4$。\n\n相应误差的比值为：\n$$\n\\frac{E_1}{E_3} = \\frac{3.200 \\times 10^{-3}}{2.200 \\times 10^{-4}} = \\frac{32}{2.2} \\approx 14.5454...\n$$\n现在，我们将这些值代入 $p$ 的公式中：\n$$\np = \\frac{\\ln(E_1/E_3)}{\\ln(h_1/h_3)} = \\frac{\\ln(14.5454...)}{\\ln(4)}\n$$\n计算数值：\n$$\np = \\frac{2.677234...}{1.386294...} \\approx 1.931240...\n$$\n按要求将结果四舍五入到四位有效数字，我们得到：\n$$\np \\approx 1.931\n$$\n\n### 第3部分：与名义阶偏差的解释\n\n观测到的精度阶 $p \\approx 1.931$ 略低于在均匀笛卡尔网格上对分段线性重构格式所期望的名义二阶精度 ($p=2$)。这种偏差可以通过考虑截断误差的细节和渐进误差模型的实际局限性来解释。\n\n1.  **渐进收敛**：误差模型 $E \\approx C h^p$ 仅在 $h \\to 0$ 的渐进极限下才严格有效。对于有限的网格间距，误差展开式 $E(h) = C_p h^p + C_{p+1} h^{p+1} + \\dots$ 中的高阶项是不可忽略的。这些项的存在“污染”了主导阶的行为，导致*观测*阶与形式阶 $p$ 不同。在网格1和2之间计算出的阶数（$p_{12} \\approx 1.912$）低于在网格2和3之间计算出的阶数（$p_{23} \\approx 1.950$），这一事实表明，随着网格的加密，该方法确实正在接近其 $p=2$ 的渐进阶。报告的值 $p \\approx 1.931$ 是在此范围内的平均值，反映出模拟尚未完全进入渐进区域。\n\n2.  **截断误差抵消与对称性破缺**：在均匀网格上，有限体积格式的名义二阶精度源于控制体相对面上主导阶截断误差的抵消。这种抵消在很大程度上依赖于离散模板的对称性，而对称性是中心差分格式的特点。\n    问题描述了一个用于对流扩散方程的格式。扩散通量的离散化使用了Green-Gauss梯度（在均匀笛卡尔网格上等效于中心差分）和算术平均，因此是对称的并且天然具有二阶精度。\n    然而，对流通量的计算涉及“从单元中心进行分段线性重构”来确定面上的通量。这意味着采用了一种迎风偏置的方法，即使用迎风单元的流体状态来确定面上的值 $\\phi_f$。尽管用于此重构的梯度是二阶精确的（最小二乘法），但迎风格式的单边性质从根本上破坏了模板的对称性。\n    这种不对称性破坏了主要误差项的完美抵消。对流部分产生的截断误差虽然形式上是 $O(h^2)$ 阶，但包含了类似于数值耗散的项（通常与解的三阶导数有关，例如 $\\propto h^2 \\frac{\\partial^3\\phi}{\\partial x^3}$），而这些项在纯对称格式中是不存在的。这个主导误差项的系数可能很大，并且在不够精细的网格上会降低有效或观测到的精度阶，从而导致一个略小于2的值。\n\n总而言之，观测阶为 $1.931$ 而非恰好为 $2$ 的主要原因是，模拟尚未达到足够精细的网格分辨率以真正进入 $O(h^2)$ 误差项完全占主导的渐进区域。迎风偏置对流格式的内在性质加剧了这种效应，其主导误差项虽然形式上是二阶的，但不如完全对称格式的误差项有利，从而导致向理论阶的收敛速度变慢。", "answer": "$$\n\\boxed{1.931}\n$$", "id": "3326375"}, {"introduction": "在掌握了基本验证技术之后，我们来探讨一个更具挑战性的真实场景，因为实际流动问题常常包含解不光滑的特征，如激波或尖锐界面。此练习 [@problem_id:3326338] 使用一个特意构造的非光滑“制造解”来研究解的正则性如何影响收敛性。它揭示了一个重要概念：观测到的收敛阶数可能依赖于所用的误差范数（$L_1$、$L_2$或$L_\\infty$），这对于解释复杂流动中的验证结果至关重要。", "problem": "考虑单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的二维稳态线性平流-反应偏微分方程：\n$$\na_x \\,\\frac{\\partial u}{\\partial x} + a_y \\,\\frac{\\partial u}{\\partial y} + \\sigma \\, u = s(x,y),\n$$\n该方程服从狄利克雷边界条件 $u(x,y) = u_{\\text{MMS}}(x,y)$，其中 $(x,y) \\in \\partial \\Omega$。使用制造解方法 (MMS)，其中精确解规定为\n$$\nu_{\\text{MMS}}(x,y) = \\sin(2\\pi x)\\,\\exp(y) + \\left|y - 0.5\\right|,\n$$\n角度单位默认为弧度。通过将 $u_{\\text{MMS}}$ 代入控制方程，并在经典意义下有定义的地方计算所需导数，来构造源项 $s(x,y)$。您必须通过使用其一阶导数的分段定义，以一种有原则的方式明确处理绝对值项的不可微性，即当 $y \\neq 0.5$ 时为 $\\frac{d}{dy}\\left|y-0.5\\right| = \\operatorname{sign}(y-0.5)$，并为了在恰好位于扭结上的网格节点上进行源项的逐点求值，在 $y=0.5$ 处使用 $\\operatorname{sign}(0)=0$。本问题中不需要 $\\left|y-0.5\\right|$ 的二阶导数。\n\n使用均匀笛卡尔网格离散 $\\Omega$ 的内部，其中 $x$ 方向有 $N_x$ 个点，$y$ 方向有 $N_y$ 个点，间距分别为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。使用二阶中心有限差分格式构造一阶导数的离散算子，并使用逐点求值处理反应项，狄利克雷边界值在 $\\partial \\Omega$ 上由 $u_{\\text{MMS}}$ 设定。不要使用任何迎风格式、限制器、滤波或人工耗散。\n\n对于每个离散解，在内部网格点 $(x_i,y_j)$ 上计算误差 $e_{i,j} = u_{i,j}^{\\text{num}} - u_{\\text{MMS}}(x_i,y_j)$，然后计算以下三种误差范数：\n- 离散 $L_1$ 范数，\n$$\n\\|e\\|_{L_1} = h_x\\,h_y \\sum_{i=1}^{N_x-2} \\sum_{j=1}^{N_y-2} \\left|e_{i,j}\\right|.\n$$\n- 离散 $L_2$ 范数，\n$$\n\\|e\\|_{L_2} = \\sqrt{h_x\\,h_y \\sum_{i=1}^{N_x-2} \\sum_{j=1}^{N_y-2} e_{i,j}^2 }.\n$$\n- 离散 $L_\\infty$ 范数，\n$$\n\\|e\\|_{L_\\infty} = \\max_{1 \\le i \\le N_x-2, \\, 1 \\le j \\le N_y-2} \\left|e_{i,j}\\right|.\n$$\n\n使用三个连续加密的网格，通过 Richardson 外推法，利用两个最密网格的结果，为每种范数估计观测到的精度阶 $p$。特别地，如果中等网格上的误差是 $E(h_2)$，最密网格上的误差是 $E(h_3)$，对应的有效网格间距分别为 $h_2$ 和 $h_3$，则将观测到的阶数 $p$ 计算为满足 $E(h) \\approx C h^p$ 的值；具体来说，在每个网格上使用有效网格间距 $h = \\max(h_x, h_y)$ 进行此估计，并仅根据两个最密层级的结果计算阶数 $p$，不使用任何外部提示。在您的解答中，解释为什么 $y=0.5$ 处的不可微性会导致依赖于范数的精度阶下降。\n\n您的程序必须实现上述过程，并在每个网格上精确求解离散线性系统（达到求解器容差）。最终输出是为以下每个测试案例计算出的 $L_1$、$L_2$ 和 $L_\\infty$ 范数的 $p$ 值（每个案例包括参数值和由三个网格组成的测试套件）：\n\n- 案例 $\\mathrm{A}$（扭结在所有网格上对齐，各向同性加密）：\n  - $a_x = 1$, $a_y = 1$, $\\sigma = 2$。\n  - 网格：$(N_x,N_y) \\in \\{(17,17),(33,33),(65,65)\\}$。\n\n- 案例 $\\mathrm{B}$（扭结在所有网格上错位，各向同性加密）：\n  - $a_x = 1$, $a_y = 0.5$, $\\sigma = 1$。\n  - 网格：$(N_x,N_y) \\in \\{(16,16),(32,32),(64,64)\\}$。\n\n- 案例 $\\mathrm{C}$（弱平流，强反应，各向同性加密）：\n  - $a_x = 0.1$, $a_y = 0.1$, $\\sigma = 10$。\n  - 网格：$(N_x,N_y) \\in \\{(17,17),(33,33),(65,65)\\}$。\n\n- 案例 $\\mathrm{D}$（各向异性加密，$y$ 方向扭结对齐）：\n  - $a_x = 1$, $a_y = 1$, $\\sigma = 2$。\n  - 网格：$(N_x,N_y) \\in \\{(33,17),(65,33),(97,49)\\}$。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个案例贡献一个包含三个浮点数的列表 $[p_{L_1},p_{L_2},p_{L_\\infty}]$，四舍五入到六位小数，总输出必须是这些列表的列表，顺序与案例顺序相同，例如 $[[p_{A,L_1},p_{A,L_2},p_{A,L_\\infty}],[p_{B,L_1},p_{B,L_2},p_{B,L_\\infty}],[p_{C,L_1},p_{C,L_2},p_{C,L_\\infty}],[p_{D,L_1},p_{D,L_2},p_{D,L_\\infty}]]$。不得打印额外文本。\n\n本问题中的所有量均为无量纲量，必须在一致的数学单位下处理。三角函数中的角度以弧度为单位。您的代码必须是自包含的，并且无需任何用户输入即可产生指定的输出。", "solution": "该问题是有效的，因为它提出了一个适定的、具有科学依据的计算流体力学和数值分析任务，并提供了所有必要的数据和定义。我们开始求解。\n\n问题的核心是使用制造解方法 (MMS) 验证求解偏微分方程 (PDE) 的数值方法的精度阶。这包括规定一个精确解，推导相应的源项，在一系列加密的网格上对 PDE 进行数值求解，然后根据计算出的误差计算观测到的收敛阶。\n\n**1. 控制方程和制造解**\n\n控制方程是在域 $\\Omega = [0,1]\\times[0,1]$ 上的二维稳态线性平流-反应方程：\n$$\na_x \\,\\frac{\\partial u}{\\partial x} + a_y \\,\\frac{\\partial u}{\\partial y} + \\sigma \\, u = s(x,y)\n$$\n制造解为：\n$$\nu_{\\text{MMS}}(x,y) = \\sin(2\\pi x)\\,\\exp(y) + \\left|y - 0.5\\right|\n$$\n该解由一个光滑（$C^\\infty$）部分 $u_{\\text{smooth}}(x,y) = \\sin(2\\pi x)\\exp(y)$ 和一个非光滑部分 $u_{\\text{kink}}(y) = |y-0.5|$ 组成，后者在 $y=0.5$ 处连续但不可微。\n\n**2. 源项推导**\n\n为了找到使 $u_{\\text{MMS}}(x,y)$ 成为精确解的源项 $s(x,y)$，我们将其代入 PDE。首先，我们计算 $u_{\\text{MMS}}$ 的偏导数。关于 $x$ 的导数为：\n$$\n\\frac{\\partial u_{\\text{MMS}}}{\\partial x} = 2\\pi\\cos(2\\pi x)\\,\\exp(y)\n$$\n关于 $y$ 的导数需要处理绝对值项。对于 $y \\neq 0.5$，$|y-0.5|$ 的导数是 $\\operatorname{sign}(y-0.5)$，其中如果 $z>0$，$\\operatorname{sign}(z)$ 为 $1$；如果 $z<0$，则为 $-1$。根据规定，为了在 $y=0.5$ 处进行逐点求值，我们使用 $\\operatorname{sign}(0)=0$。因此：\n$$\n\\frac{\\partial u_{\\text{MMS}}}{\\partial y} = \\sin(2\\pi x)\\,\\exp(y) + \\operatorname{sign}(y-0.5)\n$$\n将这些导数代入 PDE，得到制造的源项：\n$$\ns(x,y) = a_x \\left(2\\pi\\cos(2\\pi x)\\exp(y)\\right) + a_y \\left(\\sin(2\\pi x)\\exp(y) + \\operatorname{sign}(y-0.5)\\right) + \\sigma \\left(\\sin(2\\pi x)\\exp(y) + \\left|y - 0.5\\right|\\right)\n$$\n\n**3. 数值离散化和线性系统**\n\n该域使用具有 $N_x$ 和 $N_y$ 个点的均匀笛卡尔网格进行离散化，得到网格间距 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。网格点为 $(x_i, y_j) = (i h_x, j h_y)$。\n\n对于任何内部点 $(x_i, y_j)$（其中 $1 \\le i \\le N_x-2$ 和 $1 \\le j \\le N_y-2$），空间导数使用二阶中心有限差分进行近似：\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i+1,j} - u_{i-1,j}}{2h_x}, \\quad \\frac{\\partial u}{\\partial y}\\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2h_y}\n$$\n将这些近似代入 PDE，得到每个内部节点 $(i,j)$ 的离散方程：\n$$\na_x \\left(\\frac{u_{i+1,j} - u_{i-1,j}}{2h_x}\\right) + a_y \\left(\\frac{u_{i,j+1} - u_{i,j-1}}{2h_y}\\right) + \\sigma u_{i,j} = s(x_i,y_j)\n$$\n重新整理各项，将未知数 $u$ 的系数分组，得到：\n$$\n\\left(-\\frac{a_x}{2h_x}\\right)u_{i-1,j} + \\left(\\frac{a_x}{2h_x}\\right)u_{i+1,j} + \\left(-\\frac{a_y}{2h_y}\\right)u_{i,j-1} + \\left(\\frac{a_y}{2h_y}\\right)u_{i,j+1} + \\sigma u_{i,j} = s(x_i,y_j)\n$$\n这组 $(N_x-2)(N_y-2)$ 个线性代数方程构成一个大型稀疏系统 $A \\mathbf{u} = \\mathbf{b}$。向量 $\\mathbf{u}$ 包含内部网格点上的未知值 $u_{i,j}$。矩阵 $A$ 是稀疏的，每行有五个非零元（一个五点模板）。对于邻近边界的点，已知的狄利克雷值 $u_{\\text{MMS}}(x_i, y_j)$ 被移到右侧向量 $\\mathbf{b}$。例如，在邻近 $x=0$ 边界的内部点 $(1,j)$ 处，涉及 $u_{0,j}$ 的项是已知的，方程变为：\n$$\na_x \\left(\\frac{u_{2,j} - u_{\\text{MMS}}(x_0,y_j)}{2h_x}\\right) + \\dots = s(x_1,y_j) \\implies \\dots = s(x_1,y_j) + a_x\\frac{u_{\\text{MMS}}(x_0,y_j)}{2h_x}\n$$\n得到的系统 $A \\mathbf{u} = \\mathbf{b}$ 使用标准的稀疏线性代数求解器求解。\n\n**4. 误差分析和预期精度阶**\n\n数值格式的形式精度阶由其截断误差决定，截断误差是将精确解代入离散方程后得到的残差。对于足够光滑的解（至少 $C^3$），中心差分格式具有形式上的二阶精度（$O(h^2)$）。\n\n由于 $|y-0.5|$ 项的存在，制造解 $u_{\\text{MMS}}$ 不够光滑。该函数是 $C^0$ 的，其一阶导数在 $y=0.5$ 处有跳跃间断。标准的数值分析理论预测，这种正则性的缺乏会降低格式的收敛率。对于一个应用于其 $k$ 阶导数有跳跃间断的函数的 $p$ 阶方法，其在 $L_q$ 范数下的观测收敛阶预计为 $\\min(p, k + 1/q)$。\n\n在本问题中，格式是二阶的（$p=2$），解的一阶导数有跳跃（$k=1$）。因此，预期的收敛阶为：\n- **$L_\\infty$ 范数 ($q=\\infty$):** 阶数为 $\\min(2, 1 + 1/\\infty) = \\min(2, 1) = 1$。最大误差由最接近奇点的点主导，并预计随网格间距线性减小。\n- **$L_2$ 范数 ($q=2$):** 阶数为 $\\min(2, 1 + 1/2) = \\min(2, 1.5) = 1.5$。\n- **$L_1$ 范数 ($q=1$):** 阶数为 $\\min(2, 1 + 1/1) = \\min(2, 2) = 2$。\n\n当 $y=0.5$ 处的奇点位于网格线之间时，会发生这种理论上的精度下降。然而，如果奇点始终与网格线对齐，则可能出现一种称为“超收敛”的现象。在 $N_y-1$ 是 2 的倍数的网格中，线 $y=0.5$ 将与一条网格线 $y_j = j h_y$（其中 $j=(N_y-1)/2$）重合。在这条线上，$\\partial u/\\partial y$ 的中心差分模板关于扭结是对称的。离散算子有效地计算了左右导数的平均值，即 $\\frac{1}{2}(1 + (-1)) = 0$。在 $y=0.5$ 处的源项也使用 $\\operatorname{sign}(y-0.5)|_{y=0.5}=0$ 进行求值。离散算子和源项求值之间的这种匹配可以导致主误差项的抵消，从而可能恢复形式上的二阶精度。\n\n- **案例 A, C, D:** 网格的选择使得 $N_y-1$ 始终为偶数（A/C 为 16, 32, 64；D 为 16, 32, 48）。因此，扭结始终与网格对齐。我们预计对所有范数都观察到接近二阶的收敛（$p \\approx 2$）。\n- **案例 B:** 网格的选择使得 $N_y-1$ 始终为奇数（15, 31, 63）。位于 $y=0.5$ 的扭结始终错位，落在网格线之间。在这里，我们预计会观察到理论预测的依赖于范数的精度阶下降：$p_{L_1} \\approx 2$, $p_{L_2} \\approx 1.5$, $p_{L_\\infty} \\approx 1$。\n\n**5. 观测阶的计算**\n\n给定在一系列网格上计算出的误差范数 $E$，观测到的精度阶 $p$ 使用两个最密网格的结果进行估计。如果 $E_2$ 和 $E_3$ 分别是有效间距为 $h_2$ 和 $h_3$ 的网格上的误差，那么假设 $E \\approx C h^p$，我们有：\n$$\n\\frac{E_2}{E_3} \\approx \\left(\\frac{h_2}{h_3}\\right)^p \\implies p = \\frac{\\log(E_2 / E_3)}{\\log(h_2 / h_3)}\n$$\n有效网格间距定义为 $h = \\max(h_x, h_y)$。此过程应用于 $L_1$、$L_2$ 和 $L_\\infty$ 每种误差范数，以确定它们各自的收敛阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef u_mms(x, y):\n    \"\"\"Computes the manufactured solution u_MMS(x, y).\"\"\"\n    return np.sin(2 * np.pi * x) * np.exp(y) + np.abs(y - 0.5)\n\ndef source_term(x, y, ax, ay, sigma):\n    \"\"\"Computes the source term s(x, y) for the manufactured solution.\"\"\"\n    dudx = 2 * np.pi * np.cos(2 * np.pi * x) * np.exp(y)\n    dudy = np.sin(2 * np.pi * x) * np.exp(y) + np.sign(y - 0.5)\n    u = u_mms(x, y)\n    return ax * dudx + ay * dudy + sigma * u\n\ndef solve_pde(Nx, Ny, ax, ay, sigma):\n    \"\"\"\n    Solves the 2D advection-reaction PDE on a grid of size (Nx, Ny)\n    and returns the L1, L2, and L_infinity error norms.\n    \"\"\"\n    hx = 1.0 / (Nx - 1)\n    hy = 1.0 / (Ny - 1)\n    \n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    X, Y = np.meshgrid(x, y)\n\n    # Number of interior points\n    Ni = Nx - 2\n    Nj = Ny - 2\n    N_unknowns = Ni * Nj\n\n    if N_unknowns == 0:\n        return 0.0, 0.0, 0.0\n\n    # Assemble the sparse matrix A and vector b\n    A = lil_matrix((N_unknowns, N_unknowns))\n    b = np.zeros(N_unknowns)\n\n    C_W = -ax / (2 * hx)\n    C_E = ax / (2 * hx)\n    C_S = -ay / (2 * hy)\n    C_N = ay / (2 * hy)\n    C_P = sigma\n\n    for j in range(1, Ny - 1):      # Corresponds to rows of interior grid\n        for i in range(1, Nx - 1):  # Corresponds to columns of interior grid\n            k = (j - 1) * Ni + (i - 1)  # Row-major mapping to 1D index\n            \n            # Diagonal entry\n            A[k, k] = C_P\n\n            # Off-diagonal entries for neighbors\n            # West neighbor\n            if i > 1:\n                A[k, k - 1] = C_W\n            # East neighbor\n            if i  Nx - 2:\n                A[k, k + 1] = C_E\n            # South neighbor\n            if j > 1:\n                A[k, k - Ni] = C_S\n            # North neighbor\n            if j  Ny - 2:\n                A[k, k + Ni] = C_N\n\n            # Construct RHS vector b\n            b[k] = source_term(x[i], y[j], ax, ay, sigma)\n            \n            # Incorporate boundary conditions into RHS\n            if i == 1:       # Left boundary\n                b[k] -= C_W * u_mms(x[0], y[j])\n            if i == Nx - 2:  # Right boundary\n                b[k] -= C_E * u_mms(x[Nx - 1], y[j])\n            if j == 1:       # Bottom boundary\n                b[k] -= C_S * u_mms(x[i], y[0])\n            if j == Ny - 2:  # Top boundary\n                b[k] -= C_N * u_mms(x[i], y[Ny - 1])\n                \n    # Solve the linear system\n    A_csc = csc_matrix(A)\n    u_sol_vec = spsolve(A_csc, b)\n    \n    # Reshape solution to 2D grid of interior points\n    u_num = u_sol_vec.reshape((Nj, Ni))\n    \n    # Get exact solution on interior points\n    X_int, Y_int = np.meshgrid(x[1:-1], y[1:-1])\n    u_exact_int = u_mms(X_int, Y_int)\n\n    # Compute error\n    error = u_num - u_exact_int\n    \n    # Compute error norms\n    l1_norm = hx * hy * np.sum(np.abs(error))\n    l2_norm = np.sqrt(hx * hy * np.sum(error**2))\n    linf_norm = np.max(np.abs(error))\n    \n    return l1_norm, l2_norm, linf_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: kink aligned, isotropic refinement\n        {'ax': 1.0, 'ay': 1.0, 'sigma': 2.0, 'grids': [(17, 17), (33, 33), (65, 65)]},\n        # Case B: kink misaligned, isotropic refinement\n        {'ax': 1.0, 'ay': 0.5, 'sigma': 1.0, 'grids': [(16, 16), (32, 32), (64, 64)]},\n        # Case C: weak advection, strong reaction, aligned kink\n        {'ax': 0.1, 'ay': 0.1, 'sigma': 10.0, 'grids': [(17, 17), (33, 33), (65, 65)]},\n        # Case D: anisotropic refinement, aligned kink\n        {'ax': 1.0, 'ay': 1.0, 'sigma': 2.0, 'grids': [(33, 17), (65, 33), (97, 49)]},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        errors = []\n        h_effs = []\n        for Nx, Ny in case['grids']:\n            hx = 1.0 / (Nx - 1)\n            hy = 1.0 / (Ny - 1)\n            h_effs.append(max(hx, hy))\n            \n            l1, l2, linf = solve_pde(Nx, Ny, case['ax'], case['ay'], case['sigma'])\n            errors.append((l1, l2, linf))\n\n        # Errors from middle and fine grids\n        E2 = errors[1]\n        E3 = errors[2]\n        \n        # Effective grid spacings for middle and fine grids\n        h2 = h_effs[1]\n        h3 = h_effs[2]\n\n        # Calculate observed order of accuracy p\n        case_p_values = []\n        log_h_ratio = np.log(h2 / h3)\n        \n        for i in range(3): # For L1, L2, Linf norms\n            if E2[i] > 0 and E3[i] > 0:\n                p = np.log(E2[i] / E3[i]) / log_h_ratio\n            else:\n                p = 0.0 # Error is zero, no convergence to measure\n            case_p_values.append(p)\n        \n        all_results.append(case_p_values)\n\n    # Format the final output string\n    case_strings = []\n    for p_list in all_results:\n        num_strings = [f\"{val:.6f}\" for val in p_list]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3326338"}, {"introduction": "在所有验证研究中，一个关键问题是：“我的网格是否足够精细，以至于已经进入了误差估计有效的渐近范围？”回答这个问题需要一个系统性的方法。这个最终练习 [@problem_id:3326397] 将此过程形式化，指导您实现一个程序，通过检查一系列四个网格上观测精度阶的稳定性来自动检测渐近范围的开始。这为您提供了一个稳健、客观的工具，以增强对验证研究的信心。", "problem": "要求您设计并实现一个计算程序，用于在计算流体动力学解的验证中，检测网格加密研究里的渐近范围起始点。该分析必须基于规范的离散误差模型以及一致性和泰勒级数截断的逻辑推论。考虑一个关注量 $Q(h)$，它在以单一代表性间距 $h$ 为特征的网格上计算，其中 $Q(h)$ 存在如下形式的展开：\n$$\nQ(h) = Q_{\\infty} + C h^{p} + D h^{q} + R(h),\n$$\n其中 $Q_{\\infty}$ 是网格无关（精确）值，$C$ 和 $D$ 是由方法和问题决定的固定实常数，$p$ 是主阶精度方法（渐近条件下的表观阶），$q$ 是满足 $qp$ 的高阶指数，$R(h)$ 是满足 $\\lim_{h \\to 0} R(h)/h^{q} = 0$ 的余项。渐近范围是指高阶项和余项的贡献与主阶项相比变得可以忽略不计的区域，因此由加密引起的差异遵循主阶标度律。\n\n使用此模型，您的程序必须为一组合成测试用例生成四个网格层级，其恒定加密因子 $r1$ 由 $h_{k} = h_{1} r^{-(k-1)}$ 给出，其中 $k \\in \\{1,2,3,4\\}$。在每个层级上，使用所提供的参数评估 $Q_{k} = Q(h_{k})$。根据这些值，推导并计算与连续三元组 $(Q_{1},Q_{2},Q_{3})$ 和 $(Q_{2},Q_{3},Q_{4})$ 分别关联的两个连续表观阶估计值 $p_{12}$ 和 $p_{23}$。推导过程必须源于所述的离散误差模型和关于一致性的基本事实；未经证明，不得假定使用任何简化公式。\n\n通过对连续表观阶之差的绝对容差 $\\tau$ 来定义检测准则：\n$$\n\\text{如果 } |p_{12} - p_{23}| \\le \\tau \\text{，则检测到渐近起始点。}\n$$\n如果 $p_{12}$ 或 $p_{23}$ 在数学上没有良定义（例如，如果由于连续差值中的符号变化导致对数参数为非正值），则必须报告为未检测到渐近起始点。本问题不涉及物理单位。\n\n您的程序必须实现此过程并将其应用于以下测试套件。每个测试用例提供 $(Q_{\\infty}, C, p, D, q, r, h_{1})$，其中 $qp$，加密因子 $r1$，初始间距 $h_{1}0$。对所有用例使用固定的容差 $\\tau = 0.1$。\n\n- 测试用例 A（理想路径，快速渐近）：$(Q_{\\infty}, C, p, D, q, r, h_{1}) = (1.0, 1.0, 2.0, 0.1, 4.0, 2.0, 0.2)$。\n- 测试用例 B（粗网格上强的预渐近常数）：$(Q_{\\infty}, C, p, D, q, r, h_{1}) = (0.0, 1.0, 2.0, 80.0, 4.0, 2.0, 0.4)$。\n- 测试用例 C（接近容差的边界情况）：$(Q_{\\infty}, C, p, D, q, r, h_{1}) = (2.0, 1.0, 2.0, 1.2, 3.0, 2.0, 0.3)$。\n- 测试用例 D（非整数加密因子，高阶方法）：$(Q_{\\infty}, C, p, D, q, r, h_{1}) = (-0.5, 0.5, 3.0, 2.0, 5.0, 1.5, 0.2)$。\n- 测试用例 E（导致非单调差异的符号变化相互作用）：$(Q_{\\infty}, C, p, D, q, r, h_{1}) = (1.0, -1.0, 2.0, 16.0, 3.0, 2.0, 0.25)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[resultA,resultB,resultC,resultD,resultE]”）。对于每个测试用例，输出一个布尔值，指示在所述准则下是否检测到渐近起始点。不应打印任何其他文本。", "solution": "问题陈述经评估有效。它在科学上基于数值分析和计算流体动力学解验证的原理，特别是使用了离散误差估计理论。它是一个良构问题，提供了一套完整且一致的数据以及一个用于达成唯一解的确定性程序。其语言客观且数学上精确。该问题是一个可形式化的计算任务，与网格收敛性研究的主题直接相关。因此，我们可以继续进行求解。\n\n任务的核心是推导并应用一个准则，以检测数值解收敛的渐近范围的起始点。该程序依赖于从一系列在系统加密的网格上得到的解中，计算表观精度阶 $p_{\\text{apparent}}$。\n\n首先，我们推导表观阶的公式。问题提供了关注量 $Q(h)$ 的离散误差展开式：\n$$\nQ(h) = Q_{\\infty} + C h^{p} + D h^{q} + \\dots\n$$\n其中 $h$ 是网格间距，$Q_{\\infty}$ 是精确解，$p$ 是形式精度阶，且 $q  p$。在渐近范围内，网格足够精细，以至于主阶误差项占主导地位，模型可以近似为：\n$$\nQ(h) \\approx Q_{\\infty} + C h^p\n$$\n考虑三个解 $Q_1$、$Q_2$ 和 $Q_3$，它们分别在特征间距为 $h_1$、$h_2$ 和 $h_3$ 的网格上计算得出。这些网格是通过一个恒定的加密因子 $r  1$ 生成的，使得 $h_2 = h_1/r$ 且 $h_3 = h_2/r = h_1/r^2$。将渐近模型应用于这三个解，可得：\n$$\nQ_1 \\approx Q_{\\infty} + C h_1^p \\\\\nQ_2 \\approx Q_{\\infty} + C h_2^p = Q_{\\infty} + C (h_1/r)^p \\\\\nQ_3 \\approx Q_{\\infty} + C h_3^p = Q_{\\infty} + C (h_1/r^2)^p\n$$\n为了消去未知的精确解 $Q_{\\infty}$，我们考虑连续网格上解之间的差值。令 $\\epsilon_{12} = Q_1 - Q_2$ 且 $\\epsilon_{23} = Q_2 - Q_3$：\n$$\n\\epsilon_{12} = (Q_{\\infty} + C h_1^p) - (Q_{\\infty} + C h_2^p) = C(h_1^p - h_2^p) = C h_1^p (1 - r^{-p})\n$$\n$$\n\\epsilon_{23} = (Q_{\\infty} + C h_2^p) - (Q_{\\infty} + C h_3^p) = C(h_2^p - h_3^p) = C (h_1/r)^p (1 - r^{-p})\n$$\n这些差值的比率提供了一种分离出阶数 $p$ 的方法：\n$$\n\\frac{\\epsilon_{12}}{\\epsilon_{23}} = \\frac{C h_1^p (1 - r^{-p})}{C (h_1/r)^p (1 - r^{-p})} = \\frac{h_1^p}{(h_1/r)^p} = r^p\n$$\n求解 $p$，我们将其标记为表观阶 $p_{\\text{apparent}}$，因为它是从计算数据中估计出来的，可得：\n$$\np_{\\text{apparent}} = \\frac{\\ln\\left( \\frac{\\epsilon_{12}}{\\epsilon_{23}} \\right)}{\\ln(r)} = \\frac{\\ln\\left( \\frac{Q_1 - Q_2}{Q_2 - Q_3} \\right)}{\\ln(r)}\n$$\n此推导基于解处于渐近范围内的假设。当解位于较粗的网格上（预渐近范围）时，高阶项（例如 $D h^q$）不可忽略，表观阶 $p_{\\text{apparent}}$ 将会偏离理论阶 $p$。随着网格的加密，$p_{\\text{apparent}}$ 会收敛到 $p$。\n\n问题指定使用四个网格层级，从而得到解 $Q_1, Q_2, Q_3, Q_4$。这允许计算两个连续的表观阶：\n1. $p_{12}$，由三元组 $(Q_1, Q_2, Q_3)$ 计算得出。\n$$\np_{12} = \\frac{\\ln\\left( \\frac{Q_1 - Q_2}{Q_2 - Q_3} \\right)}{\\ln(r)}\n$$\n2. $p_{23}$，由三元组 $(Q_2, Q_3, Q_4)$ 计算得出。\n$$\np_{23} = \\frac{\\ln\\left( \\frac{Q_2 - Q_3}{Q_3 - Q_4} \\right)}{\\ln(r)}\n$$\n检测渐近范围起始点的准则是，这些连续的表观阶估计值应该彼此接近，表明阶数已在其真值附近稳定下来。具体条件是：\n$$\n|p_{12} - p_{23}| \\le \\tau\n$$\n其中容差 $\\tau$ 给定为 $0.1$。\n\n一个关键的考虑因素是表观阶计算的数学有效性。对数的参数 $\\frac{Q_{k-1}-Q_k}{Q_k-Q_{k+1}}$ 必须是一个正实数。这要求连续差值 $Q_{k-1}-Q_k$ 和 $Q_k-Q_{k+1}$ 必须非零且同号。如果在计算 $p_{12}$ 或 $p_{23}$ 时此条件不满足，则表明存在非单调收敛或振荡行为，渐近起始点的测试必须报告失败（未检测到）。\n\n每个测试用例的计算过程如下：\n1. 给定参数集 $(Q_{\\infty}, C, p, D, q, r, h_{1})$，为 $k \\in \\{1,2,3,4\\}$ 生成四个网格间距 $h_k = h_1 r^{-(k-1)}$。\n2. 对于每个网格间距 $h_k$，使用完整的指定模型评估关注量：$Q_k = Q_{\\infty} + C h_k^p + D h_k^q$。对于此合成研究，$R(h)$ 项取为零。\n3. 计算连续差值：$\\epsilon_{12} = Q_1-Q_2$，$\\epsilon_{23} = Q_2-Q_3$，以及 $\\epsilon_{34} = Q_3-Q_4$。\n4. 检查对数参数的有效性。如果 $(\\epsilon_{12} \\cdot \\epsilon_{23} \\le 0)$ 或 $(\\epsilon_{23} \\cdot \\epsilon_{34} \\le 0)$，则未检测到渐近起始点。\n5. 如果差值有效，则使用推导出的公式计算 $p_{12}$ 和 $p_{23}$。\n6. 评估条件 $|p_{12} - p_{23}| \\le \\tau$。结果是一个布尔值，指示此条件是否满足。\n然后将此过程应用于每个提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a procedure to detect the onset of the asymptotic range\n    in grid refinement studies based on the stability of the apparent order.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Q_inf, C, p, D, q, r, h1)\n    test_cases = [\n        (1.0, 1.0, 2.0, 0.1, 4.0, 2.0, 0.2),    # Case A\n        (0.0, 1.0, 2.0, 80.0, 4.0, 2.0, 0.4),   # Case B\n        (2.0, 1.0, 2.0, 1.2, 3.0, 2.0, 0.3),    # Case C\n        (-0.5, 0.5, 3.0, 2.0, 5.0, 1.5, 0.2),   # Case D\n        (1.0, -1.0, 2.0, 16.0, 3.0, 2.0, 0.25), # Case E\n    ]\n\n    # Fixed tolerance for the detection criterion.\n    tau = 0.1\n\n    results = []\n    \n    for case in test_cases:\n        Q_inf, C, p, D, q, r, h1 = case\n        \n        # 1. Generate the four grid levels.\n        # h_k = h1 * r^-(k-1) for k=1,2,3,4.\n        # This corresponds to indices 0, 1, 2, 3 in a 0-indexed array.\n        k = np.arange(4)\n        h = h1 * r**(-k)\n        \n        # 2. Evaluate the quantity of interest on each grid level.\n        # Q_k = Q_inf + C*h_k^p + D*h_k^q\n        Q = Q_inf + C * h**p + D * h**q\n        Q1, Q2, Q3, Q4 = Q[0], Q[1], Q[2], Q[3]\n        \n        # 3. Compute successive differences.\n        diff12 = Q1 - Q2\n        diff23 = Q2 - Q3\n        diff34 = Q3 - Q4\n        \n        # 4. Check for validity of logarithm arguments for p12 and p23.\n        # The products must be strictly positive. If zero or negative, the\n        # logarithm is undefined or indicates non-monotonic convergence.\n        if (diff12 * diff23 = 0) or (diff23 * diff34 = 0):\n            results.append(False)\n            continue\n            \n        # 5. Compute the two successive apparent orders.\n        # p_apparent = ln((Q_k - Q_{k+1}) / (Q_{k+1} - Q_{k+2})) / ln(r)\n        \n        # Apparent order from (Q1, Q2, Q3)\n        p12 = np.log(diff12 / diff23) / np.log(r)\n        \n        # Apparent order from (Q2, Q3, Q4)\n        p23 = np.log(diff23 / diff34) / np.log(r)\n        \n        # 6. Apply the detection criterion.\n        is_asymptotic = np.abs(p12 - p23) = tau\n        results.append(is_asymptotic)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a Python bool is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3326397"}]}