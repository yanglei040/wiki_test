{"hands_on_practices": [{"introduction": "在开发任何基于伴随方法的工具时，严格的验证是其正确性的基石。本练习将介绍泰勒检验（Taylor test），这是一种验证离散伴随梯度与目标泛函真实行为是否一致的基本技术[@problem_id:3289227]。通过这个练习，你不仅将从第一性原理出发实现一个伴随求解器，还将直接观察到在CFD中常见的光滑性被破坏时，例如在包含激波传感器或限制器的泛函中，伴随梯度的收敛阶是如何从二阶下降到一阶的，从而学会诊断和理解非光滑性带来的挑战。", "problem": "您的任务是为一个模拟计算流体动力学中激波传感器行为的不可微后处理泛函，实现并验证一个一阶伴随线性化检验。目标是检验一个逆向模式离散伴随（自动微分）梯度与状态的有限差分方向扰动的一致性，并量化该检验在不可微拐点（例如不连续点）附近是如何失效的。\n\n从以下基本原理开始：\n- 标量泛函 $J(\\mathbf{w})$ 在状态向量 $\\mathbf{w} \\in \\mathbb{R}^N$ 处沿方向 $\\delta \\mathbf{w} \\in \\mathbb{R}^N$ 的方向导数通过一阶泰勒展开定义，\n$$\nJ(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) = J(\\mathbf{w}) + \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w} + r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w}),\n$$\n其中余项 $r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w})$ 满足，当 $J$ 在 $\\mathbf{w}$ 处沿方向 $\\delta \\mathbf{w}$ 可微时，$r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w}) = o(\\epsilon)$（当 $\\epsilon \\to 0$）；而当 $J$ 在 $\\mathbf{w}$ 沿方向 $\\delta \\mathbf{w}$ 的邻域内具有利普希茨连续梯度时，$r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w}) = \\mathcal{O}(\\epsilon^2)$。\n- 链式法则为复合函数中导数的伴随（逆向模式自动微分）累积提供了基础。\n\n您将考虑以下离散泛函，它表示一个激波传感器项和一个平滑项的凸组合：\n$$\nJ(\\mathbf{w}) \\;=\\; \\sum_{i=0}^{N-2} \\phi\\!\\left(d_i\\right), \\quad d_i \\;=\\; w_{i+1}-w_i, \\quad \\phi(x) \\;=\\; |x| \\;+\\; \\tfrac{1}{2}\\kappa x^2,\n$$\n其中给定一个常数 $\\kappa > 0$。绝对值项模拟了不连续性传感器中典型存在的不可微分量；二次项对泛函进行正则化，并确保在绝对值局部线性区域内有一个光滑的曲率贡献。使用以下规则计算绝对值的导数：对于 $x \\neq 0$，$\\frac{d}{dx}|x|=\\operatorname{sign}(x)$，而在 $x=0$ 处，使用特定的次梯度选择 $\\frac{d}{dx}|x|\\big|_{x=0}=0$。\n\n您的程序必须：\n1. 基于应用于计算图 $\\mathbf{w} \\mapsto \\{d_i\\} \\mapsto \\{\\phi(d_i)\\} \\mapsto J$ 的链式法则，实现一个逆向模式伴随（自动微分）方法来评估梯度 $\\nabla J(\\mathbf{w})$。梯度累积必须从第一性原理显式构建，不得使用任何外部自动微分工具。\n2. 使用指定的种子生成随机扰动 $\\delta \\mathbf{w}$，并对递减的 $\\epsilon$ 值序列验证伴随线性化\n$$\nJ(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) \\;\\approx\\; \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\n$$\n对于每种情况，通过对测试 $\\epsilon$ 值的 $\\log_{10}E(\\epsilon)$ 与 $\\log_{10}\\epsilon$ 进行最小二乘拟合，量化从余项大小 $E(\\epsilon) = \\big|J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) - \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\\big|$ 获得的经验收敛阶 $p$。$p \\approx 2$ 的值表示局部二次可微行为和成功的伴随一致性检验，而 $p \\approx 1$ 表示由于拐点或不连续点附近的不可微性导致的失效。\n3. 跟踪经验阶 $p$ 在光滑和非光滑状态场 $\\mathbf{w}$ 之间的变化情况。\n\n不涉及角度。不需要物理单位。\n\n实现下面的测试套件。使用 $N=200$ 个网格点和 $\\kappa = 0.1$。使用以下三个状态场 $\\mathbf{w}$ 和扰动种子，并对所有情况使用相同的扰动量级集合：\n- 情况1（光滑场，“理想路径”）：$w_i = \\sin(2\\pi x_i) + 0.2\\cos(3\\pi x_i) + 0.3$，其中 $x_i = i/(N-1)$，对于 $i=0,\\dots,N-1$。随机方向种子为 $13$。\n- 情况2（近拐点场，可微性边界）：对所有 $i$，$w_i = 0$。随机方向种子为 $17$。\n- 情况3（不连续场，类激波阶跃）：当 $x_i < 0.5$ 时，$w_i = 1$；否则 $w_i = -1$。随机方向种子为 $19$。\n\n对于每种情况，生成一个具有独立标准正态分布条目的随机扰动 $\\delta \\mathbf{w}$，然后将其归一化为单位欧几里得范数。使用以下扰动量级\n$$\n\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}.\n$$\n\n对于每种情况，使用线性最小二乘法对给定的 $\\epsilon$ 值，计算 $\\log_{10}E(\\epsilon)$ 与 $\\log_{10}\\epsilon$ 的最佳拟合线的斜率，从而得到经验收敛阶 $p$。将三个 $p$ 值（每种情况一个）报告为四舍五入到三位小数的浮点数。\n\n您的程序应生成单行输出，其中包含以逗号分隔并用方括号括起来的结果（例如，“[p1,p2,p3]”）。", "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n- **泛函：** $J(\\mathbf{w}) = \\sum_{i=0}^{N-2} \\phi(d_i)$，其中 $d_i = w_{i+1}-w_i$。\n- **分量函数：** $\\phi(x) = |x| + \\frac{1}{2}\\kappa x^2$，其中常数 $\\kappa > 0$。\n- **次梯度规则：** 在 $x=0$ 处，绝对值的导数取为 $\\frac{d}{dx}|x|\\big|_{x=0}=0$。对于 $x \\neq 0$，使用标准导数 $\\frac{d}{dx}|x|=\\operatorname{sign}(x)$。\n- **伴随线性化与余项：** 检验基于 $J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) \\approx \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}$。余项为 $E(\\epsilon) = \\big|J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) - \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\\big|$。\n- **收敛阶：** 经验阶 $p$ 是通过对 $\\log_{10}E(\\epsilon)$ 与 $\\log_{10}\\epsilon$ 进行最小二乘拟合得到的。\n- **常数：** 网格点数 $N=200$，正则化参数 $\\kappa = 0.1$。\n- **扰动量级：** $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$。\n- **测试案例：**\n  1. **光滑场：** $w_i = \\sin(2\\pi x_i) + 0.2\\cos(3\\pi x_i) + 0.3$，其中 $x_i = i/(N-1)$。$\\delta\\mathbf{w}$ 的随机种子为 $13$。\n  2. **近拐点场：** 对所有 $i$，$w_i = 0$。$\\delta\\mathbf{w}$ 的随机种子为 $17$。\n  3. **不连续场：** 当 $x_i < 0.5$ 时，$w_i = 1$；否则 $w_i = -1$。$\\delta\\mathbf{w}$ 的随机种子为 $19$。\n- **扰动向量：** $\\delta\\mathbf{w}$ 由独立的标准正态分布条目生成，并归一化为单位欧几里得范数。\n- **输出格式：** 三个 $p$ 值，每种情况一个，四舍五入到三位小数，格式为 `[p1,p2,p3]`。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准评估问题：\n- **科学依据：** 该问题是一种标准的数值验证技术，称为泰勒检验或伴随一致性检验，这在伴随优化和灵敏度分析代码的开发中是基础性的，尤其是在计算流体动力学（CFD）领域。该泛函是非光滑惩罚项的一个典型例子。所有数学概念（泰勒级数、链式法则、次梯度、最小二乘拟合）都是成熟的。\n- **良态问题：** 该问题是良态的。所有参数、状态向量、函数和数值过程都得到了精确定义。对 $|x|$ 在 $x=0$ 处的次梯度的规定消除了歧义，确保了对于任何状态 $\\mathbf{w}$ 都可以计算出唯一的梯度向量。所描述的过程会导向一组唯一的可计算的三个值。\n- **客观性：** 该问题以精确、客观的数学语言陈述。没有主观或基于意见的元素。\n\n该问题不具有任何指定的无效性缺陷。它在科学上是合理的，完全指定的，计算上是可行的，并且与所述的伴随方法主题直接相关。\n\n### 步骤3：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 基于原理的解决方案设计\n\n#### 1. 泛函及其伴随梯度\n标量泛函 $J$ 是状态向量 $\\mathbf{w} \\in \\mathbb{R}^N$ 的函数，定义如下：\n$$\nJ(\\mathbf{w}) = \\sum_{i=0}^{N-2} \\phi(d_i), \\quad \\text{其中 } d_i = w_{i+1} - w_i \\text{ 且 } \\phi(x) = |x| + \\frac{1}{2}\\kappa x^2.\n$$\n为计算梯度 $\\nabla J(\\mathbf{w})$（其分量为 $\\frac{\\partial J}{\\partial w_j}$），我们应用链式法则：\n$$\n\\frac{\\partial J}{\\partial w_j} = \\sum_{i=0}^{N-2} \\frac{\\partial \\phi(d_i)}{\\partial w_j} = \\sum_{i=0}^{N-2} \\frac{d\\phi}{dx}(d_i) \\frac{\\partial d_i}{\\partial w_j}.\n$$\n$\\phi(x)$ 对其自变量 $x$ 的导数是：\n$$\n\\frac{d\\phi}{dx}(x) = \\frac{d|x|}{dx} + \\kappa x.\n$$\n根据问题指定的绝对值函数的次梯度选择，其中 $\\frac{d|x|}{dx}\\big|_{x=0}=0$，我们有：\n$$\n\\frac{d\\phi}{dx}(x) = \\operatorname{sign}(x) + \\kappa x,\n$$\n这里约定 $\\operatorname{sign}(0) = 0$。\n\n项 $\\frac{\\partial d_i}{\\partial w_j}$ 仅当 $j$ 为 $i$ 或 $i+1$ 时非零。具体来说，$\\frac{\\partial d_i}{\\partial w_{i+1}} = 1$ 和 $\\frac{\\partial d_i}{\\partial w_i} = -1$。这种稀疏依赖结构使我们能够组装梯度。对于任何分量 $w_j$，它只影响 $d_j$（如果 $j < N-1$）和 $d_{j-1}$（如果 $j > 0$）。\n通过累积贡献，梯度分量为：\n- 对于 $j=0$：$\\frac{\\partial J}{\\partial w_0} = \\frac{d\\phi}{dx}(d_0) \\frac{\\partial d_0}{\\partial w_0} = -\\frac{d\\phi}{dx}(d_0)$。\n- 对于 $0 < j < N-1$：$\\frac{\\partial J}{\\partial w_j} = \\frac{d\\phi}{dx}(d_{j-1})\\frac{\\partial d_{j-1}}{\\partial w_j} + \\frac{d\\phi}{dx}(d_j)\\frac{\\partial d_j}{\\partial w_j} = \\frac{d\\phi}{dx}(d_{j-1}) - \\frac{d\\phi}{dx}(d_j)$。\n- 对于 $j=N-1$：$\\frac{\\partial J}{\\partial w_{N-1}} = \\frac{d\\phi}{dx}(d_{N-2})\\frac{\\partial d_{N-2}}{\\partial w_{N-1}} = \\frac{d\\phi}{dx}(d_{N-2})$。\n\n这构成了 $\\nabla J(\\mathbf{w})$ 的逆向模式自动微分（伴随）计算。\n\n#### 2. 伴随线性化检验\n$J(\\mathbf{w})$ 在点 $\\mathbf{w}$ 附近沿任意方向 $\\delta\\mathbf{w}$ 的一阶泰勒展开为：\n$$\nJ(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) = J(\\mathbf{w}) + \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w} + \\mathcal{O}(\\epsilon^2).\n$$\n如果 $J$ 在 $\\mathbf{w}$ 的邻域内二次连续可微，则此式成立。项 $\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}$ 是方向导数，可以使用伴随法推导出的梯度 $\\nabla J(\\mathbf{w})$ 高效计算。伴随线性化检验验证了泛函的变化量 $J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w})$ 是否能被线性项 $\\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}$ 精确近似。\n\n此近似的绝对误差或余项是：\n$$\nE(\\epsilon) = \\big|J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) - \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\\big|.\n$$\n如果 $J$ 局部光滑，$E(\\epsilon)$ 应按 $\\mathcal{O}(\\epsilon^2)$ 比例缩放。然而，如果扰动 $\\epsilon\\,\\delta\\mathbf{w}$ 导致绝对值函数的自变量穿过 $x=0$，则会激活一个导数不连续的“拐点”。在这种情况下，一阶泰勒展开不再能完全描述局部行为，余项 $E(\\epsilon)$ 将由 $\\mathcal{O}(\\epsilon)$ 阶的项主导，反映了不可微性。\n\n#### 3. 经验收敛阶\n为量化此行为，我们将误差建模为 $E(\\epsilon) \\approx C \\epsilon^p$，其中 $C$ 为某个常数，$p$ 为收敛阶。取以10为底的对数，得到一个线性关系：\n$$\n\\log_{10} E(\\epsilon) \\approx \\log_{10} C + p \\log_{10} \\epsilon.\n$$\n通过对一系列递减的 $\\epsilon$ 值计算 $E(\\epsilon)$，我们获得一组数据点 $(\\log_{10}\\epsilon, \\log_{10}E(\\epsilon))$。然后，通过线性最小二乘法计算穿过这些点的最佳拟合线的斜率，确定经验收敛阶 $p$。\n\n#### 4. 实现与案例分析\n实现将遵循这些原则。为提高效率，将使用向量化的 `NumPy` 操作。对于每个测试案例，我们将：\n1. 构建状态向量 $\\mathbf{w}$。\n2. 生成并归一化随机扰动向量 $\\delta\\mathbf{w}$。\n3. 计算基准泛函值 $J(\\mathbf{w})$ 和伴随梯度 $\\nabla J(\\mathbf{w})$。\n4. 对于每个 $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$，计算余项 $E(\\epsilon)$。\n5. 对 $(\\log_{10}\\epsilon, \\log_{10}E(\\epsilon))$ 进行线性回归，以找到斜率 $p$。\n\n- **情况1（光滑场）：** 状态向量 $\\mathbf{w}$ 是一个光滑函数。差分 $d_i = w_{i+1}-w_i$ 会很小但通常非零。泛函的计算远离不可微的拐点。预计行为是光滑的，得到收敛阶 $p \\approx 2$。\n- **情况2（近拐点场）：** 状态向量为 $\\mathbf{w}=\\mathbf{0}$，意味着所有差分均为 $d_i=0$。泛函完全在拐点处进行评估。所选的次梯度为 $\\nabla J(\\mathbf{0}) = \\mathbf{0}$。任何扰动 $\\delta\\mathbf{w}$ 都会使自变量 $d_i$ 偏离 $0$，从而激活不可微性。误差将由线性项主导，因此我们预期 $p \\approx 1$。\n- **情况3（不连续场）：** 状态向量表示一个离散阶跃。大多数差分是 $d_i=0$，在阶跃位置有一个大的非零差分。与情况2类似，扰动将在许多 $d_i=0$ 的位置激活拐点。这种不可微行为预计将占主导地位，导致收敛阶 $p \\approx 1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a first-order adjoint linearization check\n    for a nondifferentiable functional.\n    \"\"\"\n\n    # Define problem constants\n    N = 200\n    KAPPA = 0.1\n    EPSILONS = np.array([1e-1, 1e-2, 1e-3, 1e-4])\n\n    def compute_J(w, kappa):\n        \"\"\"Computes the functional J(w).\"\"\"\n        d = w[1:] - w[:-1]\n        phi_d = np.abs(d) + 0.5 * kappa * d**2\n        return np.sum(phi_d)\n\n    def compute_grad_J(w, kappa):\n        \"\"\"Computes the adjoint gradient of J(w).\"\"\"\n        d = w[1:] - w[:-1]\n        \n        # Derivative of phi(x) = |x| + 0.5*kappa*x^2\n        # d(phi)/dx = sign(x) + kappa*x, with sign(0)=0 as per problem spec.\n        # np.sign(0) is 0, so this works directly.\n        phi_prime_d = np.sign(d) + kappa * d\n        \n        grad_w = np.zeros_like(w)\n        \n        # Reverse-mode accumulation\n        grad_w[1:] += phi_prime_d\n        grad_w[:-1] -= phi_prime_d\n        \n        return grad_w\n\n    def calculate_convergence_order(w, seed, n, kappa, epsilons):\n        \"\"\"\n        Calculates the empirical convergence order p for a given state w.\n        \"\"\"\n        # Generate and normalize the random perturbation\n        rng = np.random.default_rng(seed)\n        dw_raw = rng.standard_normal(n)\n        dw = dw_raw / np.linalg.norm(dw_raw)\n        \n        # Compute baseline values\n        J0 = compute_J(w, kappa)\n        grad_J = compute_grad_J(w, kappa)\n        adj_dot_dw = np.dot(grad_J, dw)\n        \n        errors = []\n        for eps in epsilons:\n            w_eps = w + eps * dw\n            J_eps = compute_J(w_eps, kappa)\n            error = np.abs(J_eps - J0 - eps * adj_dot_dw)\n            errors.append(error)\n            \n        log_eps = np.log10(epsilons)\n        log_E = np.log10(np.array(errors))\n        \n        # Fit a line log(E) = p * log(eps) + c to find the slope p\n        # using numpy's polyfit for linear regression.\n        p = np.polyfit(log_eps, log_E, 1)[0]\n        \n        return p\n\n    # Define test cases\n    x_grid = np.linspace(0, 1, N)\n    \n    # Case 1: Smooth field\n    w1 = np.sin(2 * np.pi * x_grid) + 0.2 * np.cos(3 * np.pi * x_grid) + 0.3\n    seed1 = 13\n    \n    # Case 2: Near-kink field\n    w2 = np.zeros(N)\n    seed2 = 17\n    \n    # Case 3: Discontinuous field\n    w3 = np.ones(N)\n    w3[x_grid >= 0.5] = -1.0\n    seed3 = 19\n    \n    test_cases = [\n        (w1, seed1),\n        (w2, seed2),\n        (w3, seed3),\n    ]\n\n    results = []\n    for w, seed in test_cases:\n        p = calculate_convergence_order(w, seed, N, KAPPA, EPSILONS)\n        results.append(f\"{p:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3289227"}, {"introduction": "伴随方法在计算流体力学中的一个核心应用是气动外形优化，其关键在于高效计算形状导数。本练习通过一个典型的一维偏微分方程模型，将形状灵敏度这一抽象理论具体化[@problem_id:3289239]。你将通过数值方法验证著名的Hadamard公式，将伴随方法计算出的形状梯度与通过微扰边界并重新求解所获得的有限差分结果进行对比，从而弥合形状敏感性理论与其实际编码实现及验证之间的鸿沟。", "problem": "考虑一个一维模型问题，该问题抓住了扩散型偏微分方程（PDE）形状敏感度的本质，这是计算流体力学中一种常见的替代模型。设域为区间 $\\Omega = (0,L)$，在 $x=L$ 处的外单位法向量为 $+1$，在 $x=0$ 处为 $-1$。状态变量 $u(x)$ 求解以下边界值问题\n$$\n-\\,u''(x) = f(x) \\quad \\text{for } x \\in (0,L), \\qquad u(0)=0, \\quad u(L)=0,\n$$\n其中源项为常数 $f(x) \\equiv 1$。定义目标泛函\n$$\nJ(\\Omega) = \\int_0^L u(x)\\,dx.\n$$\n在 $x=L$ 处的一个小的法向边界扰动由 $L \\mapsto L_\\epsilon = L + \\epsilon\\,V_n(L)$ 给出，其中 $\\epsilon$ 是一个小标量，$V_n(L)$ 是在 $x=L$ 处边界速度的法向分量。Hadamard 形式指出，形状导数可以表示为一个边界积分\n$$\n\\mathrm{d}J(\\Omega; \\boldsymbol{V}) \\;=\\; \\int_{\\partial \\Omega} g \\, \\boldsymbol{V} \\cdot \\boldsymbol{n} \\, ds,\n$$\n其中 $g$ 是形状梯度密度，$\\boldsymbol{n}$ 是 $\\partial \\Omega$ 上的外单位法向量。在一维情况下，这简化为端点上的带符号总和。\n\n使用伴随方法，定义伴随变量 $p(x)$ 以强制拉格朗日量的平稳性，并满足伴随偏微分方程\n$$\np''(x) = w(x) \\quad \\text{for } x \\in (0,L), \\qquad p(0)=0, \\quad p(L)=0,\n$$\n其中 $w(x) \\equiv 1$ 对应于 $J(\\Omega)$ 对 $u$ 的线性敏感度。此问题的 Hadamard 形式简化为一个涉及状态和伴随法向导数的边代表达式。特别地，对于所选的拉格朗日量和约束，在 $x=L$ 处的形状梯度为\n$$\ng(L) \\;=\\; -\\,u'(L)\\,p'(L).\n$$\n您的任务是实现一个网格扰动测试，通过比较以下两项来数值验证 Hadamard 形式：\n1. 伴随形状梯度预测 $-\\,u'(L)\\,p'(L)\\,V_n(L)$，以及\n2. 通过在 $(0,L_\\epsilon)$ 上求解扰动问题计算出的有限差分评估 $\\displaystyle \\frac{J(\\Omega_\\epsilon)-J(\\Omega)}{\\epsilon}$。\n\n为每个测试用例实现以下步骤：\n- 在 $(0,L)$ 上的具有 $N$ 个区间的均匀网格上，使用二阶中心差分对内部点离散化正向 PDE（针对 $u(x)$），并施加 Dirichlet 边界条件 $u(0)=u(L)=0$。\n- 在同一网格上使用复合梯形法则计算 $J(\\Omega)$。\n- 使用相同的网格和边界条件，离散化并求解伴随 PDE（针对 $p(x)$）。使用 $w(x)\\equiv 1$。\n- 使用右边界处的二阶单边有限差分公式近似 $u'(L)$ 和 $p'(L)$：\n$$\n\\phi'(L) \\approx \\frac{3\\,\\phi(L) - 4\\,\\phi(L-h) + \\phi(L-2h)}{2h},\n$$\n其中 $\\phi(L)=0$ 且 $h=L/N$。\n- 构建伴随预测值 $G_{\\text{adj}} = -\\,u'(L)\\,p'(L)\\,V_n(L)$，其中 $V_n(L)=1$。\n- 通过在 $(0,L_\\epsilon)$ 上使用相同数量的区间 $N$ 重新求解正向问题，并用梯形法则计算 $J(\\Omega_\\epsilon)$，构建有限差分估计值 $G_{\\text{fd}} = \\dfrac{J(\\Omega_\\epsilon)-J(\\Omega)}{\\epsilon}$。\n- 为每个测试用例报告相对误差 $E = \\dfrac{\\left|G_{\\text{adj}} - G_{\\text{fd}}\\right|}{\\max\\left(10^{-12}, \\left|G_{\\text{fd}}\\right|\\right)}$（作为浮点数）。\n\n本问题无需物理单位，也不涉及角度。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如，“[result1,result2,...]”。\n\n对于所有情况，使用以下参数值测试套件 $(L,N,\\epsilon)$，其中 $V_n(L)=1$：\n- 测试 1 (正常路径): $(1.0, 200, 1.0\\times 10^{-4})$。\n- 测试 2 (小域边界情况): $(0.2, 200, 1.0\\times 10^{-5})$。\n- 测试 3 (较大域): $(3.0, 300, 1.0\\times 10^{-4})$。\n- 测试 4 (较粗网格压力测试): $(1.0, 50, 1.0\\times 10^{-4})$。\n\n您的程序必须实现上述数值方案，并在一行中以指定的精确格式输出四个相对误差 $E$（作为浮点数）。", "solution": "在尝试求解之前，对问题陈述的有效性进行了严格评估。\n\n### 步骤1：提取已知条件\n\n提供的信息如下：\n- **状态方程（正向问题）**：在域 $\\Omega = (0,L)$ 上关于状态变量 $u(x)$ 的一维边界值问题。\n$$-\\,u''(x) = f(x) \\quad \\text{for } x \\in (0,L)$$\n源项为常数 $f(x) \\equiv 1$，并采用 Dirichlet 边界条件 $u(0)=0, u(L)=0$。\n- **目标泛函**：\n$$J(\\Omega) = \\int_0^L u(x)\\,dx$$\n- **边界扰动**：域长度 $L$ 被扰动为 $L_\\epsilon = L + \\epsilon\\,V_n(L)$，其中 $V_n(L)$ 是在 $x=L$ 处的法向速度。\n- **伴随方程**：伴随变量 $p(x)$ 满足以下边界值问题：\n$$p''(x) = w(x) \\quad \\text{for } x \\in (0,L)$$\n源项为常数 $w(x) \\equiv 1$，并采用 Dirichlet 边界条件 $p(0)=0, p(L)=0$。\n- **形状梯度**：在 $x=L$ 处的形状梯度密度由以下公式给出：\n$$g(L) = -\\,u'(L)\\,p'(L)$$\n- **数值方法**：\n    - **PDE 离散化**：在具有 $N$ 个区间（$h=L/N$）的均匀网格上采用二阶中心差分。\n    - **积分近似**：复合梯形法则。\n    - **边导数近似**：二阶单边有限差分公式：$\\phi'(L) \\approx \\frac{3\\,\\phi(L) - 4\\,\\phi(L-h) + \\phi(L-2h)}{2h}$。\n- **任务**：\n    1.  计算基于伴随方法的梯度预测：$G_{\\text{adj}} = g(L)\\,V_n(L) = -\\,u'(L)\\,p'(L)\\,V_n(L)$。\n    2.  计算有限差分梯度估计：$G_{\\text{fd}} = \\dfrac{J(\\Omega_\\epsilon)-J(\\Omega)}{\\epsilon}$。\n    3.  计算相对误差：$E = \\dfrac{\\left|G_{\\text{adj}} - G_{\\text{fd}}\\right|}{\\max\\left(10^{-12}, \\left|G_{\\text{fd}}\\right|\\right)}$。\n- **常数和参数**：所有情况下 $V_n(L)=1$。\n- **测试用例**：四个元组 $(L, N, \\epsilon)$ 的列表：\n    1.  $(1.0, 200, 1.0\\times 10^{-4})$\n    2.  $(0.2, 200, 1.0\\times 10^{-5})$\n    3.  $(3.0, 300, 1.0\\times 10^{-4})$\n    4.  $(1.0, 50, 1.0\\times 10^{-4})$\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估：\n- **科学依据充分**：该问题是将数值分析和优化理论中的标准技术应用于一个典型的微分方程。状态和伴随方程都是一维泊松方程的形式，这是物理和工程中的一个基本模型。形状导数、Hadamard 形式以及使用伴随方法进行计算的概念，是偏微分方程敏感性分析和形状优化中公认的核心原则。所有提供的数值近似公式（中心差分、梯形法则、单边导数）都是标准且正确的。\n- **适定性**：状态变量 $u(x)$ 和伴随变量 $p(x)$ 的边界值问题都是适定的，存在唯一解。整个任务是一个数值验证过程，该过程定义明确，并且对于每个测试用例都会产生唯一的数值结果。\n- **客观性**：问题以精确、形式化的数学语言陈述。它没有歧义、主观性或非科学性的主张。\n- **完整性和一致性**：问题陈述是自洽的。它提供了执行计算所需的所有必要方程、边界条件、数值方案和参数值。内部没有矛盾。例如，伴随方程 $p''=w$（其中 $w=1$）与推导泛函 $J=\\int u\\,dx$ 的敏感度是一致的。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。这是一个基于计算数学既定原则的、适定的、科学上合理的、清晰阐述的数值任务。将提供一个完整的解决方案。\n\n### 解决方案\n\n任务是执行一个网格扰动测试，以数值方式验证一个受微分方程约束的目标泛函形状梯度的伴随公式。我们将比较通过伴随方法计算的梯度 $G_{\\text{adj}}$ 和通过有限差分近似获得的估计值 $G_{\\text{fd}}$。\n\n**1. 解析框架**\n\n为了提供背景和进行验证，我们首先建立解析解。\n状态方程为 $-\\,u''(x) = 1$，边界条件为 $u(0)=u(L)=0$。积分两次并应用边界条件，得到状态变量的精确解：\n$$u(x) = \\frac{1}{2} x(L-x)$$\n伴随方程为 $p''(x) = 1$，边界条件为 $p(0)=p(L)=0$。这可以写成 $-\\,p''(x) = -1$。其解为：\n$$p(x) = -\\frac{1}{2} x(L-x) = -u(x)$$\n目标泛函 $J$ 可以解析计算：\n$$J(\\Omega) = \\int_0^L \\frac{1}{2} x(L-x) \\,dx = \\frac{1}{2} \\left[ \\frac{Lx^2}{2} - \\frac{x^3}{3} \\right]_0^L = \\frac{L^3}{12}$$\n状态变量和伴随变量在 $x=L$ 处的导数为：\n$$u'(x) = \\frac{L}{2} - x \\implies u'(L) = -\\frac{L}{2}$$\n$$p'(x) = x - \\frac{L}{2} \\implies p'(L) = \\frac{L}{2}$$\n在 $x=L$ 处的精确形状梯度密度为：\n$$g(L) = -u'(L)p'(L) = -\\left(-\\frac{L}{2}\\right)\\left(\\frac{L}{2}\\right) = \\frac{L^2}{4}$$\n对于 $V_n(L)=1$，精确的形状导数为 $\\frac{L^2}{4}$。这为我们的数值结果提供了一个基准。\n\n**2. 数值实现策略**\n\n实现的核心是为在 $(0, \\ell)$ 上带有 $y(0)=y(\\ell)=0$ 的通用一维泊松问题 $-y''(x) = f(x)$ 设计一个求解器。\n- **PDE 求解器**：我们将域 $(0, \\ell)$ 离散为 $N$ 个宽度为 $h = \\ell/N$ 的均匀区间。网格点为 $x_i = i h$，其中 $i=0, \\dots, N$。在内部点 $x_i$（$i=1, \\dots, N-1$）处的二阶导数通过二阶中心差分近似：\n$$ -y''(x_i) \\approx \\frac{-y_{i-1} + 2y_i - y_{i+1}}{h^2} = f_i $$\n这导致一个关于内部节点值 $\\mathbf{y}_{int} = [y_1, \\dots, y_{N-1}]^T$ 的 $N-1$ 个线性方程组。该系统形式为 $A \\mathbf{y}_{int} = \\mathbf{b}$，其中 $A$ 是一个对称正定三对角矩阵，主对角线为 $2$，次对角线和超对角线为 $-1$，并由 $1/h^2$ 缩放。右侧向量为 $\\mathbf{b} = [f_1, \\dots, f_{N-1}]^T$。我们将使用 `scipy.linalg.solve_banded` 进行高效求解。然后，完整的解向量为 $\\mathbf{y} = [0, y_1, \\dots, y_{N-1}, 0]^T$。\n\n有了这个求解器，对于每个测试用例 $(L, N, \\epsilon)$ 的过程如下：\n\n- **步骤 A：基线和伴随计算（在域 $\\Omega = (0,L)$ 上）**\n    1.  通过调用泊松求解器，使用 $\\ell=L$、$N$ 和源函数 $f(x)=1$ 求解状态 $u(x)$。设解为 $\\mathbf{u}$。\n    2.  在 $\\mathbf{u}$ 和步长 $h=L/N$ 上使用复合梯形法则计算基线目标泛函 $J(\\Omega)$：$J(\\Omega) \\approx h \\sum_{i=1}^{N-1} u_i$。\n    3.  通过调用泊松求解器求解 $-p''=-1$，使用 $\\ell=L$、$N$ 和等效于 $f(x)=-1$ 的源函数，求解伴随变量 $p(x)$。设解为 $\\mathbf{p}$。\n    4.  分别在数值解 $\\mathbf{u}$ 和 $\\mathbf{p}$ 上，使用给定的二阶单边公式近似导数 $u'(L)$ 和 $p'(L)$。对于一个通用解 $\\phi$ 且 $\\phi_N=0$，公式为 $\\phi'(L) \\approx \\frac{-4\\phi_{N-1} + \\phi_{N-2}}{2h}$。\n    5.  计算伴随梯度预测：$G_{\\text{adj}} = -u'(L)_{num} \\, p'(L)_{num} \\, V_n(L)$，其中 $V_n(L) = 1$。\n\n- **步骤 B：有限差分计算（在扰动域 $\\Omega_\\epsilon = (0,L_\\epsilon)$ 上）**\n    1.  定义扰动域长度 $L_\\epsilon = L + \\epsilon V_n(L)$。\n    2.  通过调用泊松求解器，使用 $\\ell=L_\\epsilon$、$N$ 和源函数 $f(x)=1$ 求解扰动状态 $u_\\epsilon(x)$。设解为 $\\mathbf{u}_\\epsilon$。\n    3.  在 $\\mathbf{u}_\\epsilon$ 和新步长 $h_\\epsilon = L_\\epsilon/N$ 上使用梯形法则计算扰动目标泛函 $J(\\Omega_\\epsilon)$：$J(\\Omega_\\epsilon) \\approx h_\\epsilon \\sum_{i=1}^{N-1} u_{\\epsilon,i}$。\n    4.  计算有限差分梯度估计：$G_{\\text{fd}} = \\frac{J(\\Omega_\\epsilon) - J(\\Omega)}{\\epsilon}$。\n\n- **步骤 C：误差计算**\n    1.  计算两个梯度近似值之间的相对误差 $E$：$E = \\dfrac{\\left|G_{\\text{adj}} - G_{\\text{fd}}\\right|}{\\max\\left(10^{-12}, \\left|G_{\\text{fd}}\\right|\\right)}$。\n\n此过程将对问题陈述中指定的每个测试用例执行。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_poisson_1d(length, n_intervals, source_val):\n    \"\"\"\n    Solves the 1D Poisson equation -y'' = f on (0, length) with y(0)=y(length)=0.\n\n    Args:\n        length (float): The length of the domain.\n        n_intervals (int): The number of intervals for the uniform mesh.\n        source_val (float): The constant value of the source term f.\n\n    Returns:\n        numpy.ndarray: The numerical solution vector y, including boundary points.\n    \"\"\"\n    h = length / n_intervals\n    num_interior_pts = n_intervals - 1\n\n    if num_interior_pts < 1:\n        return np.zeros(n_intervals + 1)\n\n    # Set up the tridiagonal system Ay_int = b for interior points\n    # The equation is (-y_{i-1} + 2y_i - y_{i+1})/h^2 = f_i\n    # This leads to a matrix with main diagonal 2, and sub/super diagonals -1.\n    diagonals = np.zeros((3, num_interior_pts))\n    diagonals[0, 1:] = -1.0  # Super-diagonal\n    diagonals[1, :] = 2.0    # Main diagonal\n    diagonals[2, :-1] = -1.0 # Sub-diagonal\n\n    # Right-hand side vector\n    b = np.full(num_interior_pts, h**2 * source_val)\n\n    # Solve the banded system\n    y_interior = solve_banded((1, 1), diagonals, b)\n\n    # Construct the full solution vector including boundaries\n    y = np.zeros(n_intervals + 1)\n    y[1:-1] = y_interior\n    return y\n\ndef compute_integral_J(y, h):\n    \"\"\"\n    Computes the integral of y using the composite trapezoidal rule.\n    Assumes boundary values y[0] and y[-1] are zero.\n\n    Args:\n        y (numpy.ndarray): The function values on the grid.\n        h (float): The grid spacing.\n\n    Returns:\n        float: The approximate value of the integral.\n    \"\"\"\n    return h * np.sum(y[1:-1])\n\ndef compute_boundary_derivative(phi, h):\n    \"\"\"\n    Computes the derivative at the right boundary phi'(L) using a \n    second-order one-sided finite difference formula.\n    phi'(L) approx (3*phi(L) - 4*phi(L-h) + phi(L-2h))/(2h).\n    Given phi(L) = 0.\n    \n    Args:\n        phi (numpy.ndarray): The function values, where phi[-1] is phi(L).\n        h (float): The grid spacing.\n\n    Returns:\n        float: The approximate derivative at the boundary.\n    \"\"\"\n    # phi[-1] is phi(L), phi[-2] is phi(L-h), phi[-3] is phi(L-2h)\n    # The formula given is (3*phi[-1] - 4*phi[-2] + phi[-3]) / (2*h).\n    # Since boundary condition enforces phi[-1] = 0.\n    return (-4.0 * phi[-2] + phi[-3]) / (2.0 * h)\n\ndef solve():\n    \"\"\"\n    Main function to run the mesh-perturbation test for the given cases.\n    \"\"\"\n    test_cases = [\n        (1.0, 200, 1.0e-4),\n        (0.2, 200, 1.0e-5),\n        (3.0, 300, 1.0e-4),\n        (1.0, 50, 1.0e-4),\n    ]\n\n    results = []\n\n    for L, N, epsilon in test_cases:\n        Vn_L = 1.0\n\n        # --- Base problem and Adjoint Method ---\n        h = L / N\n        \n        # Solve forward problem for u(x) on (0,L)\n        # -u'' = 1\n        u_sol = solve_poisson_1d(L, N, source_val=1.0)\n        \n        # Compute baseline objective functional J(Omega)\n        J_base = compute_integral_J(u_sol, h)\n        \n        # Solve adjoint problem for p(x) on (0,L)\n        # p'' = 1, so -p'' = -1\n        p_sol = solve_poisson_1d(L, N, source_val=-1.0)\n        \n        # Compute derivatives at the right boundary\n        u_prime_L = compute_boundary_derivative(u_sol, h)\n        p_prime_L = compute_boundary_derivative(p_sol, h)\n        \n        # Calculate the adjoint gradient prediction\n        G_adj = -u_prime_L * p_prime_L * Vn_L\n\n        # --- Perturbed problem and Finite Difference Method ---\n        L_eps = L + epsilon * Vn_L\n        h_eps = L_eps / N\n\n        # Solve forward problem for u_eps(x) on (0, L_eps)\n        u_eps_sol = solve_poisson_1d(L_eps, N, source_val=1.0)\n        \n        # Compute objective functional on perturbed domain J(Omega_eps)\n        J_eps = compute_integral_J(u_eps_sol, h_eps)\n\n        # Calculate the finite difference gradient estimate\n        G_fd = (J_eps - J_base) / epsilon\n        \n        # --- Compute Relative Error ---\n        denominator = max(1.0e-12, abs(G_fd))\n        error = abs(G_adj - G_fd) / denominator\n        results.append(error)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3289239"}, {"introduction": "尽管功能强大，但应用于非定常问题的伴随方法自身可能存在数值不稳定性，导致伴随变量在时间反向积分过程中指数级增长，即所谓的“伴随发散”。本练习利用一个能够体现非正规增长（non-normal growth）的简化动力学模型，来探究这个在分析湍流等复杂非定常流场时至关重要的问题[@problem_id:3289215]。你将亲手实现一种时间反向低通滤波器来稳定伴随求解过程，并定量评估其在增强稳定性与维持梯度精度之间的权衡。", "problem": "考虑一个线性时变、半离散的动力学系统，该系统模拟了一个双分量状态 $u \\in \\mathbb{R}^{2}$ 在一个非正规算子作用下的演化。该系统定义在一个均匀时间网格 $t_{n} = n \\Delta t$（其中 $n \\in \\{0,1,\\dots,N\\}$）上，时间步长 $\\Delta t$ 为常数。其正向动力学由应用于线性常微分方程的显式欧拉格式给出\n$$\n\\frac{d u}{d t} = A(t)\\, u + \\theta\\, b(t)\\, s,\n$$\n其中 $A(t) \\in \\mathbb{R}^{2 \\times 2}$ 是一个时变上三角矩阵\n$$\nA(t) = \\begin{bmatrix} -\\alpha  \\beta(t) \\\\ 0  -\\alpha \\end{bmatrix},\n$$\n$\\theta \\in \\mathbb{R}$ 是一个标量参数，$b(t) \\in \\mathbb{R}$ 是一个已知的时间标量函数，$s \\in \\mathbb{R}^{2}$ 是一个固定源向量。离散正向更新公式为\n$$\nu_{n+1} = u_{n} + \\Delta t \\left(A_{n}\\, u_{n} + \\theta\\, b_{n}\\, s\\right),\n$$\n其中 $A_{n} \\equiv A(t_{n})$ 且 $b_{n} \\equiv b(t_{n})$。初始条件为 $u_{0} = 0$。定义性能度量\n$$\nJ(\\theta) = \\frac{1}{2}\\,\\|u_{N}\\|_{2}^{2},\n$$\n其中 $\\|\\cdot\\|_{2}$ 表示欧几里得范数。\n\n您将实现一种离散伴随方法来计算灵敏度 $\\frac{dJ}{d\\theta}$，并研究一种基于对伴随变量进行逆时低通滤波的伴随稳定化技术。针对显式欧拉格式的离散伴随由终端条件定义：\n$$\np_{N} = \\frac{\\partial J}{\\partial u_{N}} = u_{N},\n$$\n以及反向递推关系：\n$$\np_{n} = \\left(I + \\Delta t\\, A_{n}\\right)^{\\top} p_{n+1}, \\quad n = N-1, N-2, \\dots, 0.\n$$\n相应的离散伴随梯度为：\n$$\ng_{\\text{adj}} = \\sum_{n=0}^{N-1} \\Delta t\\, b_{n}\\, s^{\\top} p_{n+1}.\n$$\n为了稳定在时间上反向积分时由非正规放大引起的伴随变量潜在爆破，定义一个应用于伴随序列 $\\{p_{n}\\}$ 的逆时一阶低通滤波器：\n$$\nq_{N} = p_{N}, \\quad q_{n} = r\\, p_{n} + (1-r)\\, q_{n+1}, \\quad r \\in (0,1], \\quad n = N-1, \\dots, 0.\n$$\n滤波后的伴随梯度使用滤波后的序列 $\\{q_{n}\\}$ 代替 $\\{p_{n}\\}$：\n$$\ng_{\\text{filt}}(r) = \\sum_{n=0}^{N-1} \\Delta t\\, b_{n}\\, s^{\\top} q_{n+1}.\n$$\n\n您的任务是编写一个程序，对于一组给定的滤波器强度和非正规性水平的测试套件，评估逆时低通滤波是否在减轻伴随爆破的同时，相对于有限差分基准保持了梯度的正确性。具体来说：\n\n- 使用以下固定的数值规格：\n  - 时间范围 $T = 20.0$，均匀步长 $\\Delta t = 0.005$，步数 $N = 4000$。\n  - 阻尼参数 $\\alpha = 0.01$。\n  - 时变非正规耦合\n    $$\n    \\beta(t) = \\text{scale} \\cdot \\beta_{0}\\, \\left(1 + 0.5 \\sin(\\omega t)\\right),\n    $$\n    基础振幅 $\\beta_{0} = 120.0$，频率 $\\omega = 0.7$。\n  - 源 $s = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$ 和输入调制 $b(t) = \\cos\\!\\left(2\\pi t / T\\right)$。\n  - 参数值 $\\theta = 0.3$。\n  - 用于中心差分基准的有限差分步长 $\\varepsilon = 10^{-6}$\n    $$\n    g_{\\text{fd}} = \\frac{J(\\theta + \\varepsilon) - J(\\theta - \\varepsilon)}{2\\varepsilon}.\n    $$\n  - 爆破阈值 $M = 10^{8}$，根据以下准则对实际用于计算梯度的序列（如果 $r=1$ 则为未滤波序列，如果 $r \\in (0,1)$ 则为滤波序列）进行评估：\n    $$\n    \\max_{0 \\le n \\le N} \\|z_{n}\\|_{2} > M \\quad \\Rightarrow \\quad \\text{blow-up} = 1,\n    $$\n    其中，如果 $r=1$ 则 $z_{n} = p_{n}$，否则 $z_{n} = q_{n}$。\n\n- 对于给定的 $\\theta$ 和 $\\text{scale}$，实现正向模拟以通过显式欧拉格式计算 $J(\\theta)$。然后实现离散伴随和带有系数 $r$ 的逆时滤波器以计算 $g_{\\text{filt}}(r)$。\n\n- 对每个测试用例，计算：\n  - 爆破指示符（整数）：如果根据上述准则检测到爆破，则为 $1$，否则为 $0$。\n  - 相对梯度误差\n    $$\n    E = \\frac{|g_{\\text{filt}}(r) - g_{\\text{fd}}|}{\\max\\{1, |g_{\\text{fd}}|\\}}.\n    $$\n\n测试套件：\n对以下四个参数对 $(r,\\text{scale})$ 评估程序：\n- 用例 1：$(r, \\text{scale}) = (1.0, 1.5)$。\n- 用例 2：$(r, \\text{scale}) = (0.8, 1.0)$。\n- 用例 3：$(r, \\text{scale}) = (0.2, 1.5)$。\n- 用例 4：$(r, \\text{scale}) = (1.0, 0.5)$。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，条目按如下顺序排列：\n$$\n[\\text{blow}_{1}, E_{1}, \\text{blow}_{2}, E_{2}, \\text{blow}_{3}, E_{3}, \\text{blow}_{4}, E_{4}],\n$$\n其中 $\\text{blow}_{k} \\in \\{0,1\\}$，$E_{k}$ 是相应测试用例 $k \\in \\{1,2,3,4\\}$ 的浮点数。不应打印任何额外文本。", "solution": "问题陈述已经过分析，并被确定为有效。它提出了一个在计算科学领域内的适定的、有科学依据的数值任务，特别关注非正规动力学系统灵敏度分析的离散伴随方法。所有参数、方程和评估标准都得到了明确且一致的定义，从而可以得到唯一且可验证的解。\n\n目标是计算线性时变系统中性能度量 $J(\\theta)$ 相对于参数 $\\theta$ 的灵敏度。该灵敏度（或梯度）$\\frac{dJ}{d\\theta}$ 使用离散伴随方法计算。该问题研究了由于系统算子的非正规性质，在伴随方程的时间上反向积分过程中可能出现的数值不稳定性（爆破）。引入了一种逆时低通滤波器作为一种潜在的稳定化技术，并通过将得到的滤波后伴随梯度 $g_{\\text{filt}}(r)$ 与通过有限差分计算的基准梯度 $g_{\\text{fd}}$ 进行比较来评估其有效性。\n\n问题的核心在于为每个指定的测试用例实现一系列数值算法。其方法论分解如下：\n\n1.  **正向模拟与性能评估**\n\n    系统状态 $u \\in \\mathbb{R}^{2}$ 根据从显式欧拉离散化导出的离散正向更新规则进行演化：\n    $$\n    u_{n+1} = u_{n} + \\Delta t \\left(A_{n}\\, u_{n} + \\theta\\, b_{n}\\, s\\right)\n    $$\n    其中 $u_{0} = 0$。时变矩阵为 $A_{n} = A(t_{n}) = \\begin{bmatrix} -\\alpha  \\beta(t_{n}) \\\\ 0  -\\alpha \\end{bmatrix}$。此方程从 $n=0$ 到 $n=N-1$ 在时间上向前推进以求得最终状态 $u_{N}$。然后性能度量计算如下：\n    $$\n    J(\\theta) = \\frac{1}{2}\\,\\|u_{N}\\|_{2}^{2} = \\frac{1}{2} u_{N}^{\\top} u_{N}\n    $$\n    该正向模拟必须对参数 $\\theta$ 的三个值进行：标称值 $\\theta_{\\text{nom}}$、$\\theta_{\\text{nom}} + \\varepsilon$ 和 $\\theta_{\\text{nom}} - \\varepsilon$。\n\n2.  **有限差分基准梯度**\n\n    中心差分近似为梯度提供了一个基准值。使用上一步计算的性能度量，有限差分梯度为：\n    $$\n    g_{\\text{fd}} = \\frac{J(\\theta_{\\text{nom}} + \\varepsilon) - J(\\theta_{\\text{nom}} - \\varepsilon)}{2\\varepsilon}\n    $$\n    其中 $\\varepsilon$ 是一个小扰动。该值作为“真实值”，用于与基于伴随的梯度进行比较。\n\n3.  **离散伴随模拟**\n\n    离散伴随方法提供了一种计算梯度的高效方法。伴随变量 $p \\in \\mathbb{R}^{2}$ 由一个反向递推关系控制。模拟从一个终端条件开始，该条件源自性能度量 $J$ 相对于最终状态 $u_N$ 的梯度：\n    $$\n    p_{N} = \\frac{\\partial J}{\\partial u_{N}} = u_{N}\n    $$\n    其中 $u_N$ 是使用标称参数 $\\theta_{\\text{nom}}$ 进行正向模拟得到的最终状态。然后将伴随变量从 $n=N-1$ 向下到 $n=0$ 在时间上反向积分：\n    $$\n    p_{n} = \\left(I + \\Delta t\\, A_{n}\\right)^{\\top} p_{n+1}\n    $$\n    $A_n$ 中较大的非对角线项可引起非正规放大，导致在反向积分过程中 $\\|p_n\\|$ 的模快速增长，这种现象被称为“伴随爆破”。\n\n4.  **逆时低通滤波**\n\n    为减轻潜在的爆破，在反向积分期间对伴随序列 $\\{p_n\\}$ 应用一个递归的一阶低通滤波器。这会生成一个滤波后的伴随序列 $\\{q_n\\}$。该滤波器由以下递推关系定义：\n    $$\n    q_{N} = p_{N}\n    $$\n    $$\n    q_{n} = r\\, p_{n} + (1-r)\\, q_{n+1}, \\quad \\text{for } n = N-1, \\dots, 0\n    $$\n    滤波器强度由参数 $r \\in (0,1]$ 控制。$r=1$ 的值对应于不进行滤波，此时对所有 $n$ 都有 $q_n = p_n$。较小的 $r$ 值对应于更强的滤波，它将当前伴随状态 $p_n$ 与先前计算的滤波状态 $q_{n+1}$ 进行平均。\n\n5.  **伴随梯度与误差计算**\n\n    梯度是通过对每个时间步的贡献求和来计算的，并由伴随变量加权。滤波后的伴随梯度 $g_{\\text{filt}}(r)$ 由下式给出：\n    $$\n    g_{\\text{filt}}(r) = \\sum_{n=0}^{N-1} \\Delta t\\, b_{n}\\, s^{\\top} q_{n+1}\n    $$\n    该求和与伴随方程和滤波器方程的反向积分同时进行。\n\n6.  **评估指标**\n\n    对于每个由参数对 $(r, \\text{scale})$ 定义的测试用例，计算两个指标：\n    - **爆破指示符：** 评估反向积分的稳定性。令用于梯度的序列表示为 $\\{z_n\\}$，其中如果 $r=1$ 则 $z_n=p_n$，如果 $r \\in (0,1)$ 则 $z_n=q_n$。如果该序列的最大范数超过阈值 $M$，则检测到爆破：\n      $$\n      \\text{blow-up} = \\begin{cases} 1  \\text{if } \\max_{0 \\le n \\le N} \\|z_{n}\\|_{2} > M \\\\ 0  \\text{otherwise} \\end{cases}\n      $$\n    - **相对梯度误差：** 滤波后伴随梯度的准确性通过其相对于有限差分基准的相对误差来衡量：\n      $$\n      E = \\frac{|g_{\\text{filt}}(r) - g_{\\text{fd}}|}{\\max\\{1, |g_{\\text{fd}}|\\}}\n      $$\n    分母 $\\max\\{1, |g_{\\text{fd}}|\\}$ 确保即使基准梯度接近于零，误差也是良定义的。\n\n每个测试用例的计算过程是：首先运行必要的正向模拟以计算 $g_{\\text{fd}}$，然后运行包含指定滤波器强度 $r$ 的反向伴随模拟以计算 $g_{\\text{filt}}(r)$ 并检查是否发生爆破，最后计算相对误差 $E$。对所有四个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the computation for all test cases.\n    \"\"\"\n    \n    # Fixed numerical specifications from the problem statement\n    T = 20.0\n    dt = 0.005\n    N = int(T / dt)  # 4000 steps\n    alpha = 0.01\n    beta0 = 120.0\n    omega = 0.7\n    s = np.array([1.0, 0.0])\n    theta_nom = 0.3\n    eps = 1e-6\n    M = 1e8\n\n    # Test suite: pairs of (r, scale)\n    test_cases = [\n        (1.0, 1.5),  # Case 1\n        (0.8, 1.0),  # Case 2\n        (0.2, 1.5),  # Case 3\n        (1.0, 0.5),  # Case 4\n    ]\n\n    # Pre-compute time-dependent arrays\n    time_pts = np.linspace(0, T, N + 1)\n    b_vals = np.cos(2 * np.pi * time_pts / T)\n\n    def forward_sim(theta_val, scale_val, beta_vals_scaled):\n        \"\"\"\n        Runs the forward simulation to compute the objective J and final state u_N.\n        \"\"\"\n        u = np.zeros(2)\n        for n in range(N):\n            A_n = np.array([[-alpha, beta_vals_scaled[n]], [0, -alpha]])\n            u = u + dt * (A_n @ u + theta_val * b_vals[n] * s)\n        \n        J = 0.5 * (u @ u)\n        return J, u\n\n    def compute_metrics(r, scale):\n        \"\"\"\n        Computes the blow-up indicator and relative error for a given (r, scale) case.\n        \"\"\"\n        # --- Step 1: Compute time-dependent coupling for this scale ---\n        beta_vals_scaled = scale * beta0 * (1 + 0.5 * np.sin(omega * time_pts))\n\n        # --- Step 2: Compute finite-difference gradient benchmark ---\n        J_p, _ = forward_sim(theta_nom + eps, scale, beta_vals_scaled)\n        J_m, _ = forward_sim(theta_nom - eps, scale, beta_vals_scaled)\n        g_fd = (J_p - J_m) / (2 * eps)\n\n        # --- Step 3: Run forward simulation for nominal theta to get u_N ---\n        _, u_N_nom = forward_sim(theta_nom, scale, beta_vals_scaled)\n\n        # --- Step 4: Run backward adjoint simulation with filtering ---\n        p = u_N_nom.copy()\n        q = u_N_nom.copy()\n        \n        # Initialize gradient and max norm for blow-up check\n        g_filt = 0.0\n        \n        z_n = q if r < 1.0 else p\n        max_norm_sq = z_n @ z_n\n        \n        for n in range(N - 1, -1, -1):\n            # p_next and q_next correspond to p_{n+1} and q_{n+1}\n            p_next = p.copy()\n            q_next = q.copy()\n\n            # Add contribution to gradient sum\n            # Note: s is a 1D array, so s @ q_next is s^T q_{n+1}\n            g_filt += dt * b_vals[n] * (s @ q_next)\n\n            # Compute p_n\n            A_n = np.array([[-alpha, beta_vals_scaled[n]], [0, -alpha]])\n            prop_T = (np.eye(2) + dt * A_n).T\n            p = prop_T @ p_next\n            \n            # Compute q_n\n            q = r * p + (1 - r) * q_next\n\n            # Update max norm for blow-up check\n            z_n = q if r < 1.0 else p\n            current_norm_sq = z_n @ z_n\n            if current_norm_sq > max_norm_sq:\n                max_norm_sq = current_norm_sq\n        \n        # --- Step 5: Finalize metrics ---\n        blowup = 1 if np.sqrt(max_norm_sq) > M else 0\n        \n        error = np.abs(g_filt - g_fd) / max(1.0, np.abs(g_fd))\n        \n        return blowup, error\n\n    results = []\n    for r_case, scale_case in test_cases:\n        blowup_val, error_val = compute_metrics(r_case, scale_case)\n        results.append(blowup_val)\n        results.append(error_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3289215"}]}