{"hands_on_practices": [{"introduction": "动态负载均衡是高效并行计算流体动力学（CFD）仿真的基石，尤其是在自适应网格或演化物理现象导致计算负载随时间变化的情况下。一个直观且经典的负载均衡方法是基于扩散原理，即将计算工作量视为一种“浓度”，并使其从高负载区域（高浓度）扩散到低负载区域（低浓度）。这个练习 [@problem_id:3312528] 将指导你从基本守恒原理出发，推导出一个基于图拉普拉斯算子的扩散负载均衡迭代格式，并对其收敛性进行严谨的数学分析。通过这个实践，你将掌握如何将物理类比转化为数值算法，并利用谱分析来优化其性能。", "problem": "考虑一个并行计算流体动力学 (CFD) 求解器，该求解器在一个非结构化网格上对不可压缩流进行离散化并推进求解。该网格被划分为 $P \\times Q$ 个子域，这些子域一对一地映射到一个二维环形进程网格上，因此每个分区通过周期性拓扑与其四个邻居进行通信。设工作权重 $w_i$ 表示分区 $i$ 上的当前负载估计（例如，单元格数量乘以操作计数），并设通信图为 $P \\times Q$ 环形网格，其边连接四邻居对。假设平衡步骤进行同步迭代，其中分区可以沿着邻接图的边交换工作。\n\n从守恒原理和扩散的物理类比（通量与守恒量的差异成正比）出发，完成以下任务：\n\n1. 使用总工作量 $\\sum_{i} w_i$ 的离散守恒和一个沿邻居 $(i,j)$ 之间的边与 $w_j - w_i$ 成正比的线性扩散交换，推导出一个线性迭代，该迭代仅使用邻居交换和标量步长 $\\alpha > 0$ 将负载向量 $\\mathbf{w}^{(t)}$ 更新为 $\\mathbf{w}^{(t+1)}$。使用 $P \\times Q$ 环形网格的图拉普拉斯算子 $\\mathbf{L}$ 将该迭代表示为矩阵形式。\n\n2. 设 $\\bar{w} = \\frac{1}{N}\\sum_{i=1}^{N} w_i$ 其中 $N = P Q$，并定义误差向量 $\\mathbf{e}^{(t)} = \\mathbf{w}^{(t)} - \\bar{w}\\mathbf{1}$，其中 $\\mathbf{1}$ 是全一向量。展示 $\\mathbf{e}^{(t)}$ 在第 1 部分推导的迭代下如何演化，并证明在与 $\\mathbf{1}$ 正交的子空间上，最坏情况下的渐近收敛率由 $\\mathbf{L}$ 的谱决定。推导使最坏情况线性收缩因子最小化的最优步长 $\\alpha^{\\star}$ 的解析表达式，并给出相应的最优收缩因子 $q^{\\star}$，其为关于 $P \\times Q$ 环形网格的最小正拉普拉斯特征值 $\\lambda_{\\min}^{+}$ 和最大拉普拉斯特征值 $\\lambda_{\\max}$ 的闭式表达式。\n\n3. 对于 $P = 64$ 和 $Q = 48$ 的具体情况，使用环形网格的离散傅里叶本征结构来获得 $\\lambda_{\\min}^{+}$ 和 $\\lambda_{\\max}$，并计算最优最坏情况收缩因子 $q^{\\star}$ 的数值。将最终数值答案四舍五入到六位有效数字。不需要单位。", "solution": "这是一个关于数值线性代数和迭代方法分析的有效练习，应用于并行科学计算中常见的负载均衡问题。\n\n第 1 部分：线性迭代的推导\n\n设 $w_i^{(t)}$ 为迭代步长 $t$ 时分区 $i$ 上的工作负载。分区总数为 $N = P \\times Q$。这些分区排列在一个 $P \\times Q$ 的环形网格上，其中每个分区 $i$ 有一组四个邻居，记为 $\\mathcal{N}(i)$。\n\n问题陈述工作通过线性扩散过程在相邻分区之间交换。从分区 $j$ 到分区 $i$ 的工作通量与它们的工作负载之差 $w_j^{(t)} - w_i^{(t)}$ 成正比。给定一个标量步长 $\\alpha > 0$。在一个时间步长内，分区 $i$ 的工作量变化是来自其所有邻居的净通量之和：\n$$ \\Delta w_i^{(t)} = \\sum_{j \\in \\mathcal{N}(i)} \\alpha \\left( w_j^{(t)} - w_i^{(t)} \\right) $$\n那么，下一步的工作负载 $w_i^{(t+1)}$ 由下式给出：\n$$ w_i^{(t+1)} = w_i^{(t)} + \\Delta w_i^{(t)} = w_i^{(t)} + \\alpha \\sum_{j \\in \\mathcal{N}(i)} \\left( w_j^{(t)} - w_i^{(t)} \\right) $$\n此更新规则必须保持总工作量 $\\sum_{i=1}^{N} w_i$ 守恒。我们来验证这一点。\n$$ \\sum_{i=1}^{N} w_i^{(t+1)} = \\sum_{i=1}^{N} w_i^{(t)} + \\alpha \\sum_{i=1}^{N} \\sum_{j \\in \\mathcal{N}(i)} \\left( w_j^{(t)} - w_i^{(t)} \\right) $$\n第二项是通信图所有有向边的总和。对于图中的每条边 $(i, j)$，项 $(w_j^{(t)} - w_i^{(t)})$ 出现在分区 $i$ 的求和中，而项 $(w_i^{(t)} - w_j^{(t)})$ 出现在分区 $j$ 的求和中。这两项相互抵消。因此，所有边的总和为零，总工作量守恒：$\\sum_{i=1}^{N} w_i^{(t+1)} = \\sum_{i=1}^{N} w_i^{(t)}$。\n\n为了将迭代表示为矩阵形式，我们引入图拉普拉斯算子 $\\mathbf{L}$。图拉普拉斯算子定义为 $\\mathbf{L} = \\mathbf{D} - \\mathbf{A}$，其中 $\\mathbf{A}$ 是邻接矩阵，$\\mathbf{D}$ 是对角度矩阵。拉普拉斯算子作用于负载向量 $\\mathbf{w}^{(t)}$ 的第 $i$ 个分量为：\n$$ (\\mathbf{L} \\mathbf{w}^{(t)})_i = (\\mathbf{D} \\mathbf{w}^{(t)})_i - (\\mathbf{A} \\mathbf{w}^{(t)})_i = d_i w_i^{(t)} - \\sum_{j \\in \\mathcal{N}(i)} w_j^{(t)} $$\n其中 $d_i = |\\mathcal{N}(i)|$ 是顶点 $i$ 的度。\n我们来重新整理 $w_i^{(t)}$ 的更新项：\n$$ \\alpha \\sum_{j \\in \\mathcal{N}(i)} \\left( w_j^{(t)} - w_i^{(t)} \\right) = \\alpha \\left( \\sum_{j \\in \\mathcal{N}(i)} w_j^{(t)} - |\\mathcal{N}(i)| w_i^{(t)} \\right) = \\alpha \\left( \\sum_{j \\in \\mathcal{N}(i)} w_j^{(t)} - d_i w_i^{(t)} \\right) = -\\alpha (\\mathbf{L} \\mathbf{w}^{(t)})_i $$\n所以，对每个分量 $i$ 的更新规则是 $w_i^{(t+1)} = w_i^{(t)} - \\alpha (\\mathbf{L} \\mathbf{w}^{(t)})_i$。写成向量形式为：\n$$ \\mathbf{w}^{(t+1)} = \\mathbf{w}^{(t)} - \\alpha \\mathbf{L} \\mathbf{w}^{(t)} = (\\mathbf{I} - \\alpha \\mathbf{L}) \\mathbf{w}^{(t)} $$\n这就是所要求的矩阵形式的线性迭代。\n\n第 2 部分：收敛性分析\n\n完全平衡状态是指所有分区具有相同的工作负载，即平均工作负载 $\\bar{w} = \\frac{1}{N}\\sum_{i=1}^{N} w_i$。误差向量 $\\mathbf{e}^{(t)}$ 衡量了与此平衡状态的偏差：$\\mathbf{e}^{(t)} = \\mathbf{w}^{(t)} - \\bar{w}\\mathbf{1}$，其中 $\\mathbf{1}$ 是全一向量。由于总工作量守恒，$\\bar{w}$ 对所有 $t$ 都是常数。\n\n我们来求 $\\mathbf{e}^{(t)}$ 的演化方程：\n$$ \\mathbf{e}^{(t+1)} = \\mathbf{w}^{(t+1)} - \\bar{w}\\mathbf{1} = (\\mathbf{I} - \\alpha \\mathbf{L}) \\mathbf{w}^{(t)} - \\bar{w}\\mathbf{1} $$\n代入 $\\mathbf{w}^{(t)} = \\mathbf{e}^{(t)} + \\bar{w}\\mathbf{1}$：\n$$ \\mathbf{e}^{(t+1)} = (\\mathbf{I} - \\alpha \\mathbf{L})(\\mathbf{e}^{(t)} + \\bar{w}\\mathbf{1}) - \\bar{w}\\mathbf{1} $$\n$$ \\mathbf{e}^{(t+1)} = (\\mathbf{I} - \\alpha \\mathbf{L})\\mathbf{e}^{(t)} + (\\mathbf{I} - \\alpha \\mathbf{L})\\bar{w}\\mathbf{1} - \\bar{w}\\mathbf{1} $$\n$$ \\mathbf{e}^{(t+1)} = (\\mathbf{I} - \\alpha \\mathbf{L})\\mathbf{e}^{(t)} + \\bar{w}\\mathbf{1} - \\alpha\\bar{w}\\mathbf{L}\\mathbf{1} - \\bar{w}\\mathbf{1} $$\n图拉普拉斯算子的一个基本性质是 $\\mathbf{L}\\mathbf{1} = \\mathbf{0}$。向量 $\\mathbf{1}$ 是对应于特征值 $\\lambda=0$ 的特征向量。利用这一点，方程简化为：\n$$ \\mathbf{e}^{(t+1)} = (\\mathbf{I} - \\alpha \\mathbf{L}) \\mathbf{e}^{(t)} $$\n误差向量 $\\mathbf{e}^{(t)}$ 与 $\\mathbf{1}$ 正交，因为 $\\mathbf{1}^T \\mathbf{e}^{(t)} = \\sum_i (w_i^{(t)} - \\bar{w}) = (\\sum_i w_i^{(t)}) - N\\bar{w} = N\\bar{w} - N\\bar{w} = 0$。这意味着 $\\mathbf{e}^{(t)}$ 位于由 $\\mathbf{L}$ 的正特征值对应的特征向量所张成的子空间中。\n\n误差收敛到 $\\mathbf{0}$ 的速度由迭代矩阵 $\\mathbf{M} = \\mathbf{I} - \\alpha \\mathbf{L}$ 在该子空间上的谱半径决定。设 $\\mathbf{L}$ 的特征值为 $0 = \\lambda_1 \\le \\lambda_2 \\le \\dots \\le \\lambda_N$。设 $\\lambda_{\\min}^{+}$ 为最小正特征值，$\\lambda_{\\max}$ 为最大特征值。$\\mathbf{M}$ 的特征值为 $\\mu_k = 1 - \\alpha \\lambda_k$。收敛率由 $q = \\max_{k>1} |\\mu_k| = \\max_{\\lambda \\in \\{\\lambda_{\\min}^{+}, \\dots, \\lambda_{\\max}\\}} |1 - \\alpha\\lambda|$ 决定。\n由于 $1 - \\alpha\\lambda$ 是关于 $\\lambda$ 的递减函数，其绝对值在区间 $[\\lambda_{\\min}^{+}, \\lambda_{\\max}]$ 上的最大值将出现在端点之一。因此，最坏情况下的收缩因子为：\n$$ q(\\alpha) = \\max(|1 - \\alpha\\lambda_{\\min}^{+}|, |1 - \\alpha\\lambda_{\\max}|) $$\n我们想找到使 $q(\\alpha)$ 最小化的最优步长 $\\alpha^{\\star}$。当 max 函数的两个参数的绝对值相等时，达到这个最小值：\n$$ 1 - \\alpha^{\\star}\\lambda_{\\min}^{+} = -(1 - \\alpha^{\\star}\\lambda_{\\max}) = \\alpha^{\\star}\\lambda_{\\max} - 1 $$\n求解 $\\alpha^{\\star}$：\n$$ 2 = \\alpha^{\\star}(\\lambda_{\\min}^{+} + \\lambda_{\\max}) \\implies \\alpha^{\\star} = \\frac{2}{\\lambda_{\\min}^{+} + \\lambda_{\\max}} $$\n将 $\\alpha^{\\star}$ 代回 $q$ 的表达式，得到相应的最优收缩因子 $q^{\\star}$：\n$$ q^{\\star} = |1 - \\alpha^{\\star}\\lambda_{\\min}^{+}| = \\left| 1 - \\frac{2\\lambda_{\\min}^{+}}{\\lambda_{\\min}^{+} + \\lambda_{\\max}} \\right| = \\left| \\frac{\\lambda_{\\min}^{+} + \\lambda_{\\max} - 2\\lambda_{\\min}^{+}}{\\lambda_{\\min}^{+} + \\lambda_{\\max}} \\right| = \\frac{\\lambda_{\\max} - \\lambda_{\\min}^{+}}{\\lambda_{\\max} + \\lambda_{\\min}^{+}} $$\n这就是最优最坏情况收缩因子的闭式表达式。\n\n第 3 部分：$P = 64, Q = 48$ 的数值计算\n\n$P \\times Q$ 环形网格是两个循环图 $C_P$ 和 $C_Q$ 的笛卡尔积。该乘积图的拉普拉斯算子的特征值是 $C_P$ 和 $C_Q$ 的拉普拉斯算子特征值之和。\n循环图 $C_n$ 的拉普拉斯算子的特征值由 $\\lambda_k^{(n)} = 2(1 - \\cos(\\frac{2\\pi k}{n}))$ 给出，其中 $k=0, 1, \\dots, n-1$。\n因此，$P \\times Q$ 环形网格的拉普拉斯算子的特征值为：\n$$ \\lambda_{j,k} = \\lambda_j^{(P)} + \\lambda_k^{(Q)} = 2\\left(1 - \\cos\\left(\\frac{2\\pi j}{P}\\right)\\right) + 2\\left(1 - \\cos\\left(\\frac{2\\pi k}{Q}\\right)\\right) $$\n其中 $j \\in \\{0, \\dots, P-1\\}$ 且 $k \\in \\{0, \\dots, Q-1\\}$。\n\n为了找到最小正特征值 $\\lambda_{\\min}^{+}$，我们需要找到 $\\lambda_{j,k}$ 的非零最小值。这发生在 $(j,k)$ 中一个为零，另一个对应于最低频率模式时（例如，$j=1$ 或 $k=1$）。\n$$ \\lambda_{\\min}^{+} = \\min(\\lambda_{1,0}, \\lambda_{0,1}) = \\min\\left(2\\left(1 - \\cos\\left(\\frac{2\\pi}{P}\\right)\\right), 2\\left(1 - \\cos\\left(\\frac{2\\pi}{Q}\\right)\\right)\\right) $$\n给定 $P=64$ 和 $Q=48$。由于 $P > Q$，我们有 $\\frac{2\\pi}{P}  \\frac{2\\pi}{Q}$。函数 $f(x) = 1-\\cos(x)$ 在 $x \\in [0, \\pi]$ 上是递增的。因此，较小的角度给出较小的特征值。\n$$ \\lambda_{\\min}^{+} = 2\\left(1 - \\cos\\left(\\frac{2\\pi}{64}\\right)\\right) = 2\\left(1 - \\cos\\left(\\frac{\\pi}{32}\\right)\\right) $$\n为了找到 $\\lambda_{\\max}$，我们需要最大化 $\\lambda_{j,k}$。这发生在两个余弦项都取最小值时。$\\cos(x)$ 的最小值为 $-1$，发生在 $x=\\pi$ 时。要实现这一点，我们需要 $j = P/2$ 和 $k=Q/2$（因为 $P$ 和 $Q$ 是偶数）。\n$$ \\lambda_{\\max} = \\lambda_{P/2, Q/2} = \\lambda_{32,24} = 2\\left(1 - \\cos\\left(\\frac{2\\pi \\cdot 32}{64}\\right)\\right) + 2\\left(1 - \\cos\\left(\\frac{2\\pi \\cdot 24}{48}\\right)\\right) $$\n$$ \\lambda_{\\max} = 2(1 - \\cos(\\pi)) + 2(1 - \\cos(\\pi)) = 2(1 - (-1)) + 2(1 - (-1)) = 4 + 4 = 8 $$\n现在我们可以计算最优收缩因子 $q^{\\star}$：\n$$ q^{\\star} = \\frac{\\lambda_{\\max} - \\lambda_{\\min}^{+}}{\\lambda_{\\max} + \\lambda_{\\min}^{+}} = \\frac{8 - 2\\left(1 - \\cos\\left(\\frac{\\pi}{32}\\right)\\right)}{8 + 2\\left(1 - \\cos\\left(\\frac{\\pi}{32}\\right)\\right)} = \\frac{4 - \\left(1 - \\cos\\left(\\frac{\\pi}{32}\\right)\\right)}{4 + \\left(1 - \\cos\\left(\\frac{\\pi}{32}\\right)\\right)} = \\frac{3 + \\cos\\left(\\frac{\\pi}{32}\\right)}{5 - \\cos\\left(\\frac{\\pi}{32}\\right)} $$\n现在，我们计算其数值。\n$$ \\frac{\\pi}{32} \\approx 0.09817477 \\text{ radians} $$\n$$ \\cos\\left(\\frac{\\pi}{32}\\right) \\approx 0.99518473 $$\n$$ q^{\\star} \\approx \\frac{3 + 0.99518473}{5 - 0.99518473} = \\frac{3.99518473}{4.00481527} \\approx 0.99759529 $$\n四舍五入到六位有效数字，我们得到 $0.997595$。", "answer": "$$\\boxed{0.997595}$$", "id": "3312528"}, {"introduction": "在实践中，重新划分计算域以达到负载均衡并非没有代价。虽然理想的负载均衡可以最小化处理器等待时间，但它可能需要大规模的数据迁移，这本身就会带来显著的开销，并可能破坏依赖于数据局部性的缓存效率或求解器设置。因此，分区决策本质上是一个多目标优化问题。这个练习 [@problem_id:3312469] 构建了一个框架，用于权衡两个相互冲突的目标：最小化负载不平衡与最小化数据迁移。你将通过校准一个组合目标函数中的权重，来寻找一个能在计算时间、通信和迁移成本之间达到最佳平衡的“最优”分区策略，从而深入理解并行计算中无处不在的权衡设计。", "problem": "给定一个简化的、一维的计算流体动力学 (CFD) 区域分解模型，该模型旨在捕捉并行求解器在重新分区过程中的负载均衡与网格质量保持之间的核心权衡。有 $N$ 个计算单元沿一条均匀的直线排列，索引为 $i \\in \\{0,1,\\dots,N-1\\}$。每个单元 $i$ 都有一个已知的计算工作量 $w_i \\in \\mathbb{R}_{0}$，单位为任意工作单位。为进行并行执行，该区域必须被划分为 $P$ 个连续的段。一个分区由一个严格递增的 $P-1$ 个切割索引序列 $K = (k_1,k_2,\\dots,k_{P-1})$ 完全确定，其中 $k_j \\in \\{1,2,\\dots,N-1\\}$，由此产生的段为 $[0,k_1)$, $[k_1,k_2)$, $\\dots$, $[k_{P-1},N)$。初始分区由 $K^{(0)}$ 给出，每个单元 $i$ 的初始分区分配表示为 $s^{(0)}_i \\in \\{0,1,\\dots,P-1\\}$，这是在 $K^{(0)}$ 下包含单元 $i$ 的段的索引。\n\n在切割 $K$ 下，各分区的负载定义为\n$$\nL_j(K) = \\sum_{i \\in \\text{segment } j \\text{ under } K} w_i, \\quad j \\in \\{0,1,\\dots,P-1\\}。\n$$\n负载不均衡度量定义为\n$$\n\\lambda(K) = \\frac{\\max_{j} L_j(K)}{\\frac{1}{P}\\sum_{j} L_j(K)} - 1。\n$$\n网格迁移度量 $M(K)$，通过模拟顶点移动来作为网格质量保持的代理指标，定义为相对于初始分区分配，改变了其所在分区的单元所占的比例：\n$$\nM(K) = \\frac{1}{N}\\sum_{i=0}^{N-1} \\mathbf{1}\\left(s_i(K) \\neq s^{(0)}_i\\right),\n$$\n其中 $s_i(K)$ 是由切割 $K$ 导出的单元 $i$ 的分区索引，$\\mathbf{1}(\\cdot)$ 是一个指示函数。\n\n对于给定的非负权重 $\\alpha \\in \\mathbb{R}_{\\ge 0}$ 和 $\\beta \\in \\mathbb{R}_{\\ge 0}$，考虑多目标标量化\n$$\nJ(\\alpha,\\beta;K) = \\alpha\\,\\lambda(K) + \\beta\\,M(K)。\n$$\n定义一个以秒为单位的并行运行时替代模型（每次迭代的求解时间）\n$$\nT(K) = c_{\\text{comp}}\\cdot \\max_j L_j(K) + c_{\\text{comm}}\\cdot (P-1) + c_{\\text{mig}}\\cdot N\\cdot M(K),\n$$\n其中 $c_{\\text{comp}}$ 是每单位工作量的计算时间（秒/工作单位），$c_{\\text{comm}}$ 是每个接口的通信时间（秒），$c_{\\text{mig}}$ 是每个移动单元的迁移时间（秒/单元）。项 $(P-1)$ 是一维连续分区中的接口数量。\n\n您的任务是实现以下校准和优化过程：\n1. 对于指定离散网格 $\\mathcal{A}\\times\\mathcal{B}$ 中的每对 $(\\alpha,\\beta)$，找到使 $J(\\alpha,\\beta;K)$ 在所有有效的连续分区上最小化的切割 $K^\\star(\\alpha,\\beta)$。如果存在多个切割达到相同的最小 $J$ 值，则选择 $M(K)$ 最小的那个来打破平局；如果仍然存在平局，则选择字典序最小的切割序列 $K$。\n2. 对于每对 $(\\alpha,\\beta)$，计算相应的求解时间 $T\\left(K^\\star(\\alpha,\\beta)\\right)$（以秒为单位）。\n3. 通过选择使 $T\\left(K^\\star(\\alpha,\\beta)\\right)$ 在网格上最小化的那对参数来校准 $(\\alpha^\\star,\\beta^\\star)$。如果存在多对参数的求解时间在 $10^{-12}$ 秒的容差内相等，则选择 $\\alpha$ 最小的那对来打破平局，如果仍然平局，则选择 $\\beta$ 最小的。\n\n实现一个完整的程序，为以下测试套件执行此过程。对于每个案例，返回元组 $[\\alpha^\\star,\\beta^\\star,\\lambda^\\star,M^\\star,T^\\star]$，其中 $\\lambda^\\star = \\lambda\\left(K^\\star(\\alpha^\\star,\\beta^\\star)\\right)$， $M^\\star = M\\left(K^\\star(\\alpha^\\star,\\beta^\\star)\\right)$，以及 $T^\\star = T\\left(K^\\star(\\alpha^\\star,\\beta^\\star)\\right)$。将 $T^\\star$ 以秒表示，并将所有浮点输出四舍五入到 $6$ 位小数。用于校准的集合是 $\\mathcal{A} = \\{0.00, 0.25, 0.50, 0.75, 1.00\\}$ 和 $\\mathcal{B} = \\{0.00, 0.25, 0.50, 0.75, 1.00\\}$。\n\n测试套件：\n- 案例 $1$ (一般异构负载):\n  - $N=12$, $P=3$。\n  - $w = [3,3,4,4,5,6,6,4,3,8,2,1]$。\n  - 初始切割 $K^{(0)} = [4,8]$。\n  - $c_{\\text{comp}} = 0.01$ 秒/工作单位, $c_{\\text{comm}} = 0.05$ 秒/接口, $c_{\\text{mig}} = 0.001$ 秒/移动单元。\n\n- 案例 $2$ (均匀负载边界条件):\n  - $N=12$, $P=3$。\n  - $w = [1,1,1,1,1,1,1,1,1,1,1,1]$。\n  - 初始切割 $K^{(0)} = [4,8]$。\n  - $c_{\\text{comp}} = 0.01$ 秒/工作单位, $c_{\\text{comm}} = 0.05$ 秒/接口, $c_{\\text{mig}} = 0.001$ 秒/移动单元。\n\n- 案例 $3$ (高迁移惩罚的边缘案例):\n  - $N=20$, $P=4$。\n  - $w = [9,7,8,10,12,3,4,5,6,7,20,18,2,2,1,11,13,9,4,3]$。\n  - 初始切割 $K^{(0)} = [5,10,15]$。\n  - $c_{\\text{comp}} = 0.01$ 秒/工作单位, $c_{\\text{comm}} = 0.05$ 秒/接口, $c_{\\text{mig}} = 0.02$ 秒/移动单元。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个列表 $[\\alpha^\\star,\\beta^\\star,\\lambda^\\star,M^\\star,T^\\star]$，所有浮点数都四舍五入到 $6$ 位小数。例如：$[[0.25,0.50,0.123456,0.083333,0.789012],[\\dots],[\\dots]]$。\n\n不涉及角度单位。物理单位仅适用于求解时间，必须按规定以秒为单位报告。不得使用百分比；迁移度量 $M^\\star$ 必须是小数形式。", "solution": "用户提供了一个与计算流体动力学中的区域分解相关的、定义明确的多目标优化问题。该任务涉及校准一个标量化目标函数的超参数，以最小化一个独立的、更具物理基础的运行时替代模型。\n\n### **问题解构与策略**\n\n问题的核心是一个两级优化过程：\n1.  **内部优化**：对于来自离散网格 $\\mathcal{A} \\times \\mathcal{B}$ 的每一对权重参数 $(\\alpha, \\beta)$，我们必须找到一个最优分区 $K^\\star(\\alpha,\\beta)$。一个分区由 $P-1$ 个切割索引的序列 $K = (k_1, k_2, \\dots, k_{P-1})$ 定义。最优分区 $K^\\star(\\alpha, \\beta)$ 是使标量化目标函数 $J(\\alpha, \\beta; K) = \\alpha \\lambda(K) + \\beta M(K)$ 最小化的分区，其中 $\\lambda(K)$ 是负载不均衡度，$M(K)$ 是网格迁移分数。\n2.  **外部优化（校准）**：为每个 $(\\alpha, \\beta)$ 对找到 $K^\\star(\\alpha,\\beta)$ 后，我们为每个分区评估一个运行时替代模型 $T(K^\\star(\\alpha, \\beta))$。目标是找到在所有 $(\\alpha, \\beta)$ 对的网格上使此运行时 $T$ 最小化的那对 $(\\alpha^\\star, \\beta^\\star)$。\n\n问题在两个优化层面上都规定了严格的平局打破规则。\n\n计算区域是一维的，单元数 $N$ 和分区数 $P$ 都很小。搜索空间包括从 $N-1$ 个可能的内部单元边界中选择 $P-1$ 个不同切割位置的所有可能方式。此搜索空间的大小由二项式系数 $\\binom{N-1}{P-1}$ 给出。对于给定的测试案例，这个数字很小（例如，案例 1 为 $\\binom{11}{2}=55$，案例 3 为 $\\binom{19}{3}=969$），这使得对所有可能分区的穷举搜索在计算上是可行的，在算法上是直接的。这确保了能找到内部优化问题的全局最优解。\n\n### **算法步骤**\n\n解决方案通过直接遵循嵌套优化结构来实现。\n\n1.  **预处理**：对于每个测试案例，我们首先计算几个常量值：\n    -   总计算工作量 $W_{\\text{total}} = \\sum_{i=0}^{N-1} w_i$。\n    -   每个分区的理想平均负载 $L_{\\text{avg}} = W_{\\text{total}} / P$。\n    -   工作量分布 $w$ 的前缀和数组。这使得任何连续单元段 $[a, b)$ 的负载都可以在 $O(1)$ 时间内计算出来，从而显著加速主循环。\n    -   初始分区分配向量 $s^{(0)}$，其中 $s^{(0)}_i$ 是在初始切割 $K^{(0)}$ 下包含单元 $i$ 的分区索引。\n\n2.  **外层循环（校准）**：我们遍历所提供集合 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的笛卡尔积中的每个超参数对 $(\\alpha, \\beta)$。\n\n3.  **内层循环（分区优化）**：对于给定的 $(\\alpha, \\beta)$：\n    -   **生成所有分区**：我们使用组合生成所有有效且不同的切割序列 $K$。\n    -   **评估每个分区**：对于每个候选分区 $K$，我们计算：\n        -   使用前缀和数组计算 $P$ 个段中每个段的负载 $L_j(K)$。\n        -   最大负载 $\\max_j L_j(K)$。\n        -   负载不均衡度量 $\\lambda(K) = (\\max_j L_j(K) / L_{\\text{avg}}) - 1$。\n        -   新的分区分配向量 $s(K)$。\n        -   通过将 $s(K)$ 与 $s^{(0)}$ 进行比较，计算网格迁移度量 $M(K)$。\n        -   复合目标函数值 $J(K) = \\alpha \\lambda(K) + \\beta M(K)$。\n    -   **寻找最优分区 $K^\\star(\\alpha, \\beta)$**：为了正确应用指定的平局打破规则（1. 最小 $J$，2. 最小 $M$，3. 字典序最小的 $K$），我们为每个分区 $K$ 存储元组 $(J(K), M(K), K)$。在评估所有分区后，我们对这个元组集合进行排序。排序后列表的第一个元素对应于满足所有标准的唯一最优分区 $K^\\star(\\alpha, \\beta)$。\n\n4.  **运行时替代模型评估**：在确定 $K^\\star(\\alpha, \\beta)$ 后，我们计算其相关度量 $\\lambda^\\star = \\lambda(K^\\star)$、$M^\\star = M(K^\\star)$、$\\max_j L_j(K^\\star)$，并最终使用其定义计算并行运行时替代模型 $T(K^\\star(\\alpha, \\beta))$：\n    $$\n    T(K) = c_{\\text{comp}}\\cdot \\max_j L_j(K) + c_{\\text{comm}}\\cdot (P-1) + c_{\\text{mig}}\\cdot N\\cdot M(K)\n    $$\n\n5.  **最终选择 $(\\alpha^\\star, \\beta^\\star)$**：我们记录迄今为止在所有 $(\\alpha, \\beta)$ 对中找到的最佳结果。如果一对 $(\\alpha, \\beta)$ 的新结果的运行时 $T$ 更低，则它将替换当前的最佳结果。如果运行时在指定的 $10^{-12}$ 容差内相等，则通过选择 $\\alpha$ 较小的对来打破平局，如果 $\\alpha$ 值也相同，则选择 $\\beta$ 较小的那个。\n\n6.  **输出格式化**：在遍历一个测试案例的所有 $(\\alpha, \\beta)$ 对之后，存储最终的校准结果 $[\\alpha^\\star, \\beta^\\star, \\lambda^\\star, M^\\star, T^\\star]$。对所有测试案例重复此过程。然后将收集到的结果格式化为所需的单行字符串，其中浮点值四舍五入到六位小数。\n\n这种系统性的、暴力搜索的方法通过直接实现问题陈述中列出的形式化定义和优化标准来保证正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 12, \"P\": 3, \"w\": [3, 3, 4, 4, 5, 6, 6, 4, 3, 8, 2, 1],\n            \"K0\": [4, 8], \"c_comp\": 0.01, \"c_comm\": 0.05, \"c_mig\": 0.001\n        },\n        {\n            \"N\": 12, \"P\": 3, \"w\": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            \"K0\": [4, 8], \"c_comp\": 0.01, \"c_comm\": 0.05, \"c_mig\": 0.001\n        },\n        {\n            \"N\": 20, \"P\": 4, \"w\": [9, 7, 8, 10, 12, 3, 4, 5, 6, 7, 20, 18, 2, 2, 1, 11, 13, 9, 4, 3],\n            \"K0\": [5, 10, 15], \"c_comp\": 0.01, \"c_comm\": 0.05, \"c_mig\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(\n            case[\"N\"], case[\"P\"], case[\"w\"], case[\"K0\"],\n            case[\"c_comp\"], case[\"c_comm\"], case[\"c_mig\"]\n        )\n        results.append(result)\n\n    # Format the final output string as specified.\n    case_results_str = []\n    for res in results:\n        formatted_vals = [f\"{val:.6f}\" for val in res]\n        case_results_str.append(f\"[{','.join(formatted_vals)}]\")\n    \n    print(f\"[{','.join(case_results_str)}]\")\n\n\ndef solve_case(N, P, w, K0, c_comp, c_comm, c_mig):\n    \"\"\"\n    Solves a single test case by performing the nested optimization procedure.\n    \"\"\"\n    w = np.array(w, dtype=np.float64)\n    total_work = np.sum(w)\n    avg_load = total_work / P\n    prefix_w = np.cumsum(np.concatenate(([0.0], w)))\n\n    # Determine initial partition assignment s_i^(0)\n    s0 = np.zeros(N, dtype=int)\n    cuts0 = [0] + K0 + [N]\n    for j in range(P):\n        s0[cuts0[j]:cuts0[j+1]] = j\n        \n    A_grid = [0.00, 0.25, 0.50, 0.75, 1.00]\n    B_grid = [0.00, 0.25, 0.50, 0.75, 1.00]\n    \n    best_overall_result = None\n\n    # Outer loop: Iterate over the calibration grid for alpha and beta\n    for alpha in A_grid:\n        for beta in B_grid:\n            \n            # --- Inner optimization: Find K*(\\alpha, \\beta) that minimizes J ---\n            \n            partition_candidates = []\n            possible_cuts_range = range(1, N)\n            for K_tuple in itertools.combinations(possible_cuts_range, P - 1):\n                K = list(K_tuple)\n                cuts = [0] + K + [N]\n                \n                # Calculate metrics for the current partition K\n                loads = np.array([prefix_w[cuts[j+1]] - prefix_w[cuts[j]] for j in range(P)])\n                max_load = np.max(loads)\n                \n                lambda_K = (max_load / avg_load) - 1.0 if avg_load > 1e-12 else 0.0\n\n                s_K = np.zeros(N, dtype=int)\n                for j in range(P):\n                    s_K[cuts[j]:cuts[j+1]] = j\n                \n                num_migrated = np.sum(s_K != s0)\n                M_K = num_migrated / N\n                \n                J_K = alpha * lambda_K + beta * M_K\n                \n                partition_candidates.append((J_K, M_K, K_tuple, max_load, num_migrated))\n            \n            # Sort candidates to find the best K according to tie-breaking rules:\n            # 1. min J, 2. min M, 3. lexicographically smallest K\n            partition_candidates.sort(key=lambda x: (x[0], x[1], x[2]))\n            best_J_val, best_M_val, K_star_ab_tuple, max_load_star, num_migrated_star = partition_candidates[0]\n            \n            lambda_star_ab = (max_load_star / avg_load) - 1.0 if avg_load > 1e-12 else 0.0\n            M_star_ab = num_migrated_star / N\n\n            # Calculate runtime surrogate T for the optimal partition K*(\\alpha, \\beta)\n            T_ab = c_comp * max_load_star + c_comm * (P - 1) + c_mig * num_migrated_star\n            \n            new_result = [alpha, beta, lambda_star_ab, M_star_ab, T_ab]\n\n            # --- Update overall best (alpha*, beta*) based on T and tie-breaking rules ---\n            if best_overall_result is None:\n                best_overall_result = new_result\n            else:\n                current_T = best_overall_result[4]\n                new_T = new_result[4]\n                \n                if new_T  current_T - 1e-12:\n                    best_overall_result = new_result\n                elif abs(new_T - current_T) = 1e-12:\n                    current_alpha = best_overall_result[0]\n                    new_alpha = new_result[0]\n                    if new_alpha  current_alpha:\n                        best_overall_result = new_result\n                    elif abs(new_alpha - current_alpha)  1e-12:\n                        current_beta = best_overall_result[1]\n                        new_beta = new_result[1]\n                        if new_beta  current_beta:\n                            best_overall_result = new_result\n                            \n    return best_overall_result\n\nsolve()\n```", "id": "3312469"}, {"introduction": "最高级的并行性能优化需要考虑并行化策略与数值求解器算法之间的深层耦合。对于代数多重网格（AMG）这类先进的求解器，其收敛效率高度依赖于粗化过程中能否有效捕捉代数光滑误差。然而，强制将AMG的聚合（aggregates）限制在分区边界内以减少通信，可能会破坏其捕捉跨边界强耦合的能力，从而降低收敛速度。这个练习 [@problem_id:3312474] 探讨了AMG粗化策略与分区边界之间的相互作用。它挑战你分析如何协同设计聚合策略和分区，以在保证求解器数值鲁棒性的同时，最大限度地减少跨层次的通信开销，这代表了并行求解器设计中的前沿课题。", "problem": "考虑一个在计算流体动力学中不可压缩流求解器中出现的压力泊松子问题，该问题在非结构化网格上离散化，得到一个稀疏线性系统 $\\boldsymbol{A}\\boldsymbol{x}=\\boldsymbol{b}$，其中 $\\boldsymbol{A}$ 是对称正定的。未知量通过区域分解分布在 $P$ 个进程上，该分解为每个细网格自由度 $i\\in V_0$ 分配一个进程标签 $p_0(i)\\in\\{1,\\dots,P\\}$。并行迭代期间的通信主要由跨越进程边界的图边驱动。设细网格邻接图为 $G_0=(V_0,E_0)$，并定义一个简单的逐层通信代理 $C_\\ell$ 为\n$$\nC_\\ell \\equiv \\sum_{(i,j)\\in E_\\ell} \\mathbf{1}\\big[p_\\ell(i)\\neq p_\\ell(j)\\big],\n$$\n其中 $p_\\ell$ 将第 $\\ell$ 层的节点映射到进程标签，$E_\\ell$ 是第 $\\ell$ 层的邻接关系。\n\n一个代数多重网格 (AMG) 层次结构是通过基于聚合的粗化建立的：细层节点被分组为不相交的聚合，定义了从第 $\\ell+1$ 层到第 $\\ell$ 层的延拓 $\\boldsymbol{P}_\\ell$ 和限制 $\\boldsymbol{R}_\\ell$ (通常 $\\boldsymbol{R}_\\ell=\\boldsymbol{P}_\\ell^\\top$)，并且粗算子通过 Galerkin 积 $\\boldsymbol{A}_{\\ell+1}=\\boldsymbol{R}_\\ell\\boldsymbol{A}_\\ell\\boldsymbol{P}_\\ell$ 构建。聚合影响粗层图 $G_{\\ell+1}$、其划分 $p_{\\ell+1}$，并因此影响通信代理 $C_{\\ell+1}$。\n\n从上述定义（图邻接、进程标签映射和 AMG 转移算子）出发，分析聚合选择如何与划分边界和多层通信相互作用。然后，选择下面所有关于 AMG 粗化和聚合对划分边界的影响以及将聚合与进程划分协同定位以减少通信的策略的正确陈述。\n\n- A. 跨越多个进程标签的聚合倾向于创建粗节点，其在 $\\boldsymbol{A}_{\\ell+1}$ 中的非零元会跨进程耦合，从而增加粗层上的界面边；与无约束聚合相比，约束聚合以遵循细层进程标签，并通过多数所有权 $p_{\\ell+1}(a)=\\operatorname{mode}\\{p_\\ell(i): i\\in a\\}$ 分配粗节点，通常会减少 $C_{\\ell+1}$。\n\n- B. 因为粗化减少了自由度的数量，所以无论聚合如何放置，进程间通信在每一层都严格减少，因此将聚合与划分进行显式协同定位是不必要的。\n\n- C. 一个实用的策略是完全根据连接强度来设定聚合种子，而忽略进程标签，然后在每个循环中独立地重新划分粗图，并将新的划分映射散布回细节点；这将减少通信而不影响负载均衡。\n\n- D. 将聚合与进程边界紧密对齐可以减少进程间耦合，但如果聚合变得各向异性，可能会降低切割边界附近的 AMG 收敛性；一种缓解措施是允许边界聚合的一个受控比例 $\\alpha\\in[0,1]$ 包含来自相邻进程的强连接邻居，同时保留多数所有权，通过选择 $\\alpha$ 来最小化一个复合目标 $J(\\alpha)=\\lambda\\,C_{\\ell+1}(\\alpha)+(1-\\lambda)\\,S(\\alpha)$，该目标在通信 $C_{\\ell+1}$ 和连接强度惩罚 $S$ 之间进行权衡，其中 $\\lambda\\in[0,1]$。\n\n- E. 将聚合与划分协同定位可以减少转移操作中的通信，但它对粗算子 $\\boldsymbol{A}_{\\ell+1}$ 没有影响，因为 Galerkin 积 $\\boldsymbol{A}_{\\ell+1}=\\boldsymbol{R}_\\ell\\boldsymbol{A}_\\ell\\boldsymbol{P}_\\ell$ 消除了进程间耦合。\n\n选择所有适用的选项。", "solution": "我们从区域分解和 AMG 粗化的定义开始。区域分解为每个细网格节点 $i\\in V_0$ 分配一个来自 $\\{1,\\dots,P\\}$ 的进程标签 $p_0(i)$。在分布式稀疏操作（如平滑器和残差计算）中，每当一个矩阵非零元耦合了由不同进程拥有的未知量时，就会产生进程间通信。使用第 $\\ell$ 层的邻接图 $G_\\ell=(V_\\ell,E_\\ell)$，每次迭代的通信量的一个实用代理是跨越进程标签的图边计数 $C_\\ell$：\n$$\nC_\\ell = \\sum_{(i,j)\\in E_\\ell} \\mathbf{1}\\big[p_\\ell(i)\\neq p_\\ell(j)\\big].\n$$\n这个代理反映了“光环”交换量：每个跨进程的边都会引发一个需要进程间数据传输的依赖关系。\n\n基于聚合的 AMG 通过将细节点分组为聚合 $a\\subset V_\\ell$ 来构建粗层，定义了一个延拓 $\\boldsymbol{P}_\\ell$，其列表示支持在聚合上的粗基函数。粗算子由 Galerkin 积形成\n$$\n\\boldsymbol{A}_{\\ell+1} \\equiv \\boldsymbol{R}_\\ell\\,\\boldsymbol{A}_\\ell\\,\\boldsymbol{P}_\\ell,\n$$\n而粗图 $G_{\\ell+1}$ 自然地编码了由 $\\boldsymbol{A}_\\ell$ 以及 $\\boldsymbol{P}_\\ell$ 和 $\\boldsymbol{R}_\\ell$ 的稀疏性引起的聚合之间的耦合。\n\n聚合如何影响划分边界和通信：\n\n- 如果一个聚合 $a$ 包含具有多个进程标签的细节点，那么相应的粗自由度将在多个进程上得到支持。在分布式实现中，这通常会导致粗层耦合，需要为平滑和残差计算进行进程间通信。与聚合严格包含在进程子域内的情况相比，计数 $C_{\\ell+1}$ 可能会增加，因为更多的粗边可以跨越进程标签。\n\n- 如果约束聚合以遵循细层进程标签，即在每个进程内形成聚合，并根据诸如多数所有权 $p_{\\ell+1}(a)=\\operatorname{mode}\\{p_\\ell(i): i\\in a\\}$ 的规则（通过打破平局来平衡负载）分配粗节点，那么粗节点倾向于局限在单个进程内，与无约束聚合相比，减少了跨进程耦合，并降低了 $C_{\\ell+1}$。这种对齐最小化了跨越划分的粗边数量，从而减少了粗层上的“光环”交换。\n\n- 然而，严格的对齐可能与收敛性相互作用。在划分切割边界附近，约束聚合可能会产生高度倾斜或各向异性的聚合，在存在各向异性或非均匀系数的情况下，这些聚合不能有效地捕获代数光滑误差。允许受控比例的跨划分成员资格可以改善强连接的表示，同时仍将大部分聚合支持保持在一个进程内。\n\n- 粗化减少了自由度的数量，但除非仔细选择聚合和粗划分，否则它不能保证进程间通信代理 $C_\\ell$ 的单调减少。较粗的算子可以有更密集的模板；如果聚合遍历进程边界或粗边变得更具全局性，界面边的比例可能会增加，通信可能不会严格减少。\n\n- Galerkin 积不会消除进程间耦合；它传播由 $\\boldsymbol{A}_\\ell$、$\\boldsymbol{P}_\\ell$ 和 $\\boldsymbol{R}_\\ell$ 所蕴含的模式。如果 $\\boldsymbol{P}_\\ell$ 具有将跨进程边界的细节点连接到相同粗基函数的非零元，则 $\\boldsymbol{A}_{\\ell+1}$ 将继承跨进程的耦合。协同定位聚合会减少此类跨进程的非零元。\n\n逐项分析：\n\n- A. 这个陈述正确地将跨进程标签的聚合支持与增加的粗层跨进程耦合以及因此更大的 $C_{\\ell+1}$ 联系起来。所提出的策略——约束聚合以遵循细层进程标签，并通过多数所有权 $p_{\\ell+1}(a)=\\operatorname{mode}\\{p_\\ell(i)\\}$ 分配粗节点——是将聚合与划分协同定位的标准有效方法。它减少了跨进程的粗边数量，因为聚合尽可能地被包含在单个进程内。结论：正确。\n\n- B. 声称无论聚合如何放置，通信在每一层都严格减少的说法是错误的。虽然粗化减少了自由度的数量，但 $\\boldsymbol{A}_{\\ell+1}$ 的结构相对于 $\\boldsymbol{A}_\\ell$ 可能更密集，并且跨越进程边界的聚合会增加每个节点的跨进程耦合数量。因此，$C_{\\ell+1}$ 不必严格减少，并且通常需要显式地协同定位聚合来控制通信。结论：不正确。\n\n- C. 完全根据连接强度来设定聚合种子而忽略进程标签可以产生良好的代数性质，但在每个循环中独立地重新划分粗图并将映射散布回细节点会引入大量的开销和复杂性。它确实会影响负载均衡：重新划分会改变自由度和工作的分布，并且每个循环将映射散布回细节点需要额外的通信和同步。断言这可以在不影响负载均衡的情况下减少通信是不现实的；此外，$\\boldsymbol{P}_\\ell$ 支持和划分之间的未对齐倾向于增加转移通信。结论：不正确。\n\n- D. 这个陈述认识到了一个权衡：将聚合与进程边界完美对齐可以减少跨进程耦合，但如果聚合忽略了穿越划分的强连接，则可能损害切割边界附近的收敛性。允许受控比例 $\\alpha$ 的跨划分成员资格，同时保留多数所有权，可以保持代数有效性。通过最小化复合成本 $J(\\alpha)=\\lambda\\,C_{\\ell+1}(\\alpha)+(1-\\lambda)\\,S(\\alpha)$ 来选择 $\\alpha$ 是一个有原则的方法，用以在通信和连接强度考虑之间取得平衡。在高等研究生水平上，这是一个合理的策略。结论：正确。\n\n- E. Galerkin 积 $\\boldsymbol{A}_{\\ell+1}=\\boldsymbol{R}_\\ell\\boldsymbol{A}_\\ell\\boldsymbol{P}_\\ell$ 本身并不消除进程间耦合；它根据 $\\boldsymbol{P}_\\ell$ 和 $\\boldsymbol{R}_\\ell$ 的稀疏性以及细算子 $\\boldsymbol{A}_\\ell$ 来传播这些耦合。协同定位聚合会影响 $\\boldsymbol{P}_\\ell$ 的稀疏模式，从而影响 $\\boldsymbol{A}_{\\ell+1}$ 的稀疏模式，减少跨进程的非零元。因此，声称协同定位对 $\\boldsymbol{A}_{\\ell+1}$ 没有影响的说法是不正确的。结论：不正确。\n\n正确的陈述是 A 和 D。", "answer": "$$\\boxed{AD}$$", "id": "3312474"}]}