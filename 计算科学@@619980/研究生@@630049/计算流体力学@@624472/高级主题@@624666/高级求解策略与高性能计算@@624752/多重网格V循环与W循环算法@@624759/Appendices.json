{"hands_on_practices": [{"introduction": "多重网格方法的核心在于在不同分辨率的网格之间传递信息。本练习将通过一个基本但至关重要的计算，帮助您具体理解这一过程。您将手动应用全权重限制算子（restriction）将一个平滑场从细网格降采样到粗网格，然后通过双线性插值（prolongation）将其重建回细网格，并分析其中产生的误差[@problem_id:3347230]。这个练习揭示了网格间传递算子的基本性质以及它们如何影响解的精度。", "problem": "考虑在计算流体动力学 (CFD) 中，用于光滑标量场（代表偏微分方程 (PDE) 的解）的多重网格 V-循环和 W-循环迭代中的一个典型网格传输步骤。设计算域为 $\\Omega = [0,1] \\times [0,1]$，细网格为均匀的，有 $9 \\times 9$ 个节点（即每个方向有 $8$ 个区间），因此细网格间距为 $h = \\frac{1}{8}$。粗网格通过选取每隔一个细网格节点来定义，从而得到 $5 \\times 5$ 个粗网格节点，其间距为 $2h$。\n\n设连续场为 $u(x,y) = x^{2} + y^{2}$，并假设 $u$ 的细网格采样值是在细网格节点上精确给定的。将从细网格到粗网格的全加权限制算子定义在粗网格节点 $(x_{0},y_{0})$ 上，其形式为九点模板\n$$\n\\mathcal{R}_{\\text{FW}}[u] (x_{0},y_{0}) \\;=\\; \\frac{1}{16}\\Big(u(x_{0}-h,y_{0}-h) + 2\\,u(x_{0},y_{0}-h) + u(x_{0}+h,y_{0}-h) \\\\\n+ 2\\,u(x_{0}-h,y_{0}) + 4\\,u(x_{0},y_{0}) + 2\\,u(x_{0}+h,y_{0}) \\\\\n+ u(x_{0}-h,y_{0}+h) + 2\\,u(x_{0},y_{0}+h) + u(x_{0}+h,y_{0}+h)\\Big).\n$$\n然后通过单元双线性插值定义从粗网格到细网格的延拓：在一个角点为 $(X_{0},Y_{0})$、$(X_{0}+2h,Y_{0})$、$(X_{0},Y_{0}+2h)$、$(X_{0}+2h,Y_{0}+2h)$ 的粗网格单元上，对于该单元内的任意点 $(x,y)$，其局部坐标为 $s,t \\in [0,1]$，使得 $x = X_{0} + 2hs$ 且 $y = Y_{0} + 2ht$，插值结果等于\n$$\n\\mathcal{P}_{\\text{bilinear}}[U_{c}](x,y) \\;=\\; (1-s)(1-t)\\,U_{c}(X_{0},Y_{0}) \\;+\\; s(1-t)\\,U_{c}(X_{0}+2h,Y_{0}) \\\\\n+\\; (1-s)t\\,U_{c}(X_{0},Y_{0}+2h) \\;+\\; s t\\,U_{c}(X_{0}+2h,Y_{0}+2h),\n$$\n其中 $U_{c}$ 表示通过限制算子得到的粗网格值。使用这些定义，对给定的 $u$ 的细网格采样值应用全加权以获得粗网格值，然后应用双线性插值在细网格节点上重建近似的细网格值。计算在所有细网格节点上的逐点插值误差大小的最大值，\n$$\nE_{\\max} \\;=\\; \\max_{\\text{fine nodes }(x,y)} \\left|\\mathcal{P}_{\\text{bilinear}}\\big[\\mathcal{R}_{\\text{FW}}[u]\\big](x,y) \\;-\\; u(x,y)\\right|,\n$$\n并以单个实数的精确形式给出您的答案。答案无需四舍五入，也不包含任何单位。", "solution": "用户希望我解决一个问题。\n\n这是我的计划：\n1.  **验证问题陈述。**\n    *   **提取给定条件**：\n        *   计算域：$\\Omega = [0,1] \\times [0,1]$。\n        *   细网格：$9 \\times 9$ 个节点，间距 $h = \\frac{1}{8}$。\n        *   粗网格：$5 \\times 5$ 个节点，间距 $2h = \\frac{1}{4}$。\n        *   连续场：$u(x,y) = x^2 + y^2$。\n        *   细网格值是 $u(x,y)$ 的精确采样。\n        *   限制算子：$\\mathcal{R}_{\\text{FW}}$ 是全加权 9 点模板。\n        *   延拓算子：$\\mathcal{P}_{\\text{bilinear}}$ 是双线性插值。\n        *   目标：计算 $E_{\\max} = \\max_{\\text{fine nodes }(x,y)} |\\mathcal{P}_{\\text{bilinear}}[\\mathcal{R}_{\\text{FW}}[u]](x,y) - u(x,y)|$。\n    *   **验证**：\n        *   **科学依据**：该问题基于多重网格方法（限制、延拓）的标准、基本概念，这些是求解偏微分方程的数值分析的基石。具体的算子（全加权、双线性插值）和测试函数（$u(x,y)=x^2+y^2$）是分析此类方法性质的典型选择。\n        *   **适定性**：问题陈述清晰，包含了所有必要的定义和值。目标是进行一次具体的计算，得出一个唯一的数值答案。\n        *   **客观性**：问题使用精确的数学语言陈述，没有歧义或主观内容。\n        *   **结论**：问题是有效的。提及连续场 $u(x,y)$ 暗示了函数的定义可以延伸到网格之外，从而解决了在定义域边界应用限制模板时可能出现的歧义，这是截断误差分析中的一种标准做法。\n\n2.  **解决问题。**\n    求解过程包括三个主要步骤：\n    1.  将限制算子 $\\mathcal{R}_{\\text{FW}}$ 应用于 $u(x,y)$ 的细网格表示，以获得粗网格值 $U_c$。\n    2.  将延拓算子 $\\mathcal{P}_{\\text{bilinear}}$ 应用于粗网格值 $U_c$，以获得插值得到的细网格值 $u_I$。\n    3.  计算误差 $E(x,y) = u_I(x,y) - u(x,y)$，并找出其在所有细网格节点上的最大幅值。\n\n    **第 1 步：限制**\n    设 $(x_0, y_0)$ 为一个粗网格节点。全加权限制算子 $\\mathcal{R}_{\\text{FW}}$ 计算粗网格值 $U_c(x_0, y_0)$，其值为以 $(x_0, y_0)$ 为中心的九个细网格值的加权平均。细网格值由连续函数 $u(x,y) = x^2 + y^2$ 给出。\n    该算子定义为：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\sum_{i=-1}^{1} \\sum_{j=-1}^{1} w_{ij} u(x_0+ih, y_0+jh)\n    $$\n    其中权重为 $w_{00}=4$，$w_{\\pm 1, 0}=w_{0, \\pm 1}=2$，$w_{\\pm 1, \\pm 1}=1$。\n\n    我们可以通过将 $u(x_0+ih, y_0+jh)$ 在 $(x_0, y_0)$ 周围进行泰勒级数展开来分析该算子对 $u(x,y)$ 的作用。由于 $u(x,y)$ 是一个二次多项式，其泰勒展开是精确且有限的：\n    $$\n    u(x_0+ih, y_0+jh) = u(x_0, y_0) + (ih) \\frac{\\partial u}{\\partial x} + (jh) \\frac{\\partial u}{\\partial y} + \\frac{1}{2} \\left( (ih)^2 \\frac{\\partial^2 u}{\\partial x^2} + (jh)^2 \\frac{\\partial^2 u}{\\partial y^2} + 2(ih)(jh) \\frac{\\partial^2 u}{\\partial x \\partial y} \\right)\n    $$\n    对于 $u(x,y) = x^2 + y^2$，在 $(x_0, y_0)$ 处的偏导数为：$\\frac{\\partial u}{\\partial x} = 2x_0$，$\\frac{\\partial u}{\\partial y} = 2y_0$，$\\frac{\\partial^2 u}{\\partial x^2} = 2$，$\\frac{\\partial^2 u}{\\partial y^2} = 2$，以及 $\\frac{\\partial^2 u}{\\partial x \\partial y} = 0$。\n    将这些代入展开式，得到：\n    $$\n    u(x_0+ih, y_0+jh) = (x_0^2+y_0^2) + 2x_0 i h + 2y_0 j h + i^2 h^2 + j^2 h^2\n    $$\n    现在，我们计算加权和：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\sum_{i,j} w_{ij} \\left( u(x_0, y_0) + 2x_0 i h + 2y_0 j h + i^2 h^2 + j^2 h^2 \\right)\n    $$\n    根据求和的线性性质：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\left( u(x_0, y_0)\\sum_{i,j} w_{ij} + 2x_0 h \\sum_{i,j} w_{ij}i + 2y_0 h \\sum_{i,j} w_{ij}j + h^2 \\sum_{i,j} w_{ij}i^2 + h^2 \\sum_{i,j} w_{ij}j^2 \\right)\n    $$\n    我们计算加权指数的和：\n    $\\sum_{i,j} w_{ij} = 1+2+1+2+4+2+1+2+1 = 16$。\n    由于权重的对称性（$w_{ij} = w_{-i,j}$ 且 $w_{ij}=w_{i,-j}$）：\n    $\\sum_{i,j} w_{ij} i = 0$ 且 $\\sum_{i,j} w_{ij} j = 0$。\n    $i^2$ 项的和为：\n    $\\sum_{i,j} w_{ij} i^2 = \\sum_{j} (w_{-1,j}(-1)^2 + w_{0,j}(0)^2 + w_{1,j}(1)^2) = \\sum_{j} (w_{-1,j} + w_{1,j})$。\n    对于 $j \\in \\{-1, 1\\}$，$w_{-1,j}+w_{1,j} = 1+1=2$。对于 $j=0$，$w_{-1,0}+w_{1,0} = 2+2=4$。\n    所以，$\\sum_{i,j} w_{ij} i^2 = 2 + 4 + 2 = 8$。根据对称性，$\\sum_{i,j} w_{ij} j^2 = 8$。\n\n    将这些和代回 $U_c$ 的表达式：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\left( 16 u(x_0, y_0) + 0 + 0 + 8h^2 + 8h^2 \\right) = u(x_0, y_0) + \\frac{16h^2}{16} = u(x_0, y_0) + h^2\n    $$\n    因此，在每个粗网格节点 $(x,y)$ 上，粗网格值为 $U_c(x,y) = x^2+y^2+h^2$。\n\n    **第 2 步：延拓**\n    接下来，我们将双线性插值 $\\mathcal{P}_{\\text{bilinear}}$ 应用于粗网格数据 $U_c$，以在细网格上获得值 $u_I$。该算子是线性的，所以我们可以写出：\n    $$\n    u_I(x,y) = \\mathcal{P}_{\\text{bilinear}}[U_c](x,y) = \\mathcal{P}_{\\text{bilinear}}[u+h^2](x,y) = \\mathcal{P}_{\\text{bilinear}}[u](x,y) + \\mathcal{P}_{\\text{bilinear}}[h^2](x,y)\n    $$\n    对一个常数值 ($h^2$) 进行双线性插值，结果处处都是该常数值。因此，$\\mathcal{P}_{\\text{bilinear}}[h^2](x,y) = h^2$。\n    方程简化为：\n    $$\n    u_I(x,y) = \\mathcal{P}_{\\text{bilinear}}[u](x,y) + h^2\n    $$\n\n    **第 3 步：误差计算**\n    在细网格点 $(x,y)$ 处的误差为：\n    $$\n    E(x,y) = u_I(x,y) - u(x,y) = \\left( \\mathcal{P}_{\\text{bilinear}}[u](x,y) - u(x,y) \\right) + h^2\n    $$\n    括号中的项是函数 $u(x,y)=x^2+y^2$ 的双线性插值的标准误差。我们来计算这个误差。\n    考虑一个角点为 $(X_0, Y_0), (X_0+2h, Y_0), (X_0, Y_0+2h), (X_0+2h, Y_0+2h)$ 的粗网格单元。该单元内的点 $(x,y)$ 由 $x = X_0 + s(2h)$ 和 $y = Y_0 + t(2h)$ 参数化，其中 $s,t \\in [0,1]$。\n    双线性插值算子相对于被插值的函数也是线性的，因此 $\\mathcal{P}_{\\text{bilinear}}[x^2+y^2] = \\mathcal{P}_{\\text{bilinear}}[x^2] + \\mathcal{P}_{\\text{bilinear}}[y^2]$。\n    让我们使用一维线性插值在 $[Z_0, Z_0+L]$ 上找出 $f(z)=z^2$ 的插值误差。插值函数为 $f_I(z) = (1-\\sigma)Z_0^2 + \\sigma(Z_0+L)^2$，其中 $z=Z_0+\\sigma L$。误差为 $f_I(z) - z^2 = L^2\\sigma(1-\\sigma)$。\n    对于 $u(x,y)=x^2+y^2$ 的双线性插值，我们有：\n    $\\mathcal{P}_{\\text{bilinear}}[x^2](x,y) = x^2 + (2h)^2s(1-s) = x^2+4h^2s(1-s)$。\n    $\\mathcal{P}_{\\text{bilinear}}[y^2](x,y) = y^2 + (2h)^2t(1-t) = y^2+4h^2t(1-t)$。\n    $u$ 的插值误差为：\n    $$\n    \\mathcal{P}_{\\text{bilinear}}[u](x,y) - u(x,y) = (x^2+4h^2s(1-s) + y^2+4h^2t(1-t)) - (x^2+y^2) = 4h^2s(1-s) + 4h^2t(1-t)\n    $$\n    因此总误差为：\n    $$\n    E(x,y) = \\left( 4h^2s(1-s) + 4h^2t(1-t) \\right) + h^2 = h^2(1 + 4s(1-s) + 4t(1-t))\n    $$\n\n    **第 4 步：最大化**\n    我们需要找到在所有细网格节点上 $|E(x,y)|$ 的最大值。由于 $h0$ 且 $s,t\\in[0,1]$，项 $s(1-s)$ 和 $t(1-t)$ 是非负的，所以 $E(x,y)$ 总是正的。因此， $|E(x,y)|=E(x,y)$。\n    细网格节点位于坐标 $(ih, jh)$ 处，其中 $i,j \\in \\{0, 1, \\dots, 8\\}$。一个细网格节点 $(ih, jh)$ 在一个粗网格单元内的局部坐标 $(s,t)$ 由 $s = (i \\pmod 2)/2$ 和 $t = (j \\pmod 2)/2$ 给出。\n    在细网格节点上，$s$ 和 $t$ 的可能值为 $0$ 和 $1/2$。我们需要在 $(s,t) \\in \\{0, 1/2\\} \\times \\{0, 1/2\\}$ 的情况下最大化 $E(x,y)$。\n    函数 $f(\\sigma) = \\sigma(1-\\sigma)$ 在 $\\sigma=0$ 时为 $0$，在 $\\sigma=1/2$ 时为 $1/4$。当 $s(1-s)$ 和 $t(1-t)$ 最大化时，误差函数 $E$ 也达到最大值，这发生在 $s=1/2$ 和 $t=1/2$ 时。\n    这对应于具有奇数索引 $(i,j)$ 的细网格节点，这些节点是粗网格单元的中心。\n    最大误差为：\n    $$\n    E_{\\max} = h^2\\left(1 + 4\\left(\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right) + 4\\left(\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right)\\right) = h^2\\left(1 + 4\\left(\\frac{1}{4}\\right) + 4\\left(\\frac{1}{4}\\right)\\right)\n    $$\n    $$\n    E_{\\max} = h^2(1 + 1 + 1) = 3h^2\n    $$\n    问题给出 $h = \\frac{1}{8}$。代入这个值：\n    $$\n    E_{\\max} = 3 \\left(\\frac{1}{8}\\right)^2 = 3 \\left(\\frac{1}{64}\\right) = \\frac{3}{64}\n    $$", "answer": "$$\\boxed{\\frac{3}{64}}$$", "id": "3347230"}, {"introduction": "多重网格的效率源于“分而治之”的策略：用平滑器（smoother）高效衰减高频误差，将难以处理的低频误差留给粗网格解决。本练习要求您实现一个红黑高斯-赛德尔（Red-Black Gauss-Seidel）平滑器，并数值化地量化它对特定傅里叶误差模式的阻尼效果[@problem_id:3347195]。通过这个编码实践，您将亲眼验证平滑器是如何选择性地消除振荡误差分量，从而为粗网格校正铺平道路。", "problem": "考虑单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上的泊松方程 $-\\Delta u = f$，其边界条件为在 $\\partial \\Omega$ 上的齐次狄利克雷边界条件 $u=0$。使用一个包含 $N \\times N$ 个内部点的均匀网格，其中 $N=32$，网格间距为 $h = 1/(N+1)$，并对负拉普拉斯算子使用标准的5点有限差分格式进行离散化。由此得到的线性系统为 $A u = f_h$，其中 $A$ 是对应于5点模板的稀疏矩阵，$f_h$ 是在网格点上采样的右端项。在多重网格方法中，前平滑子应用一次红黑高斯-赛德尔（RBGS）扫描。该方法根据整数索引之和的奇偶性将内部网格点划分为两种颜色：如果 $(i+j)$ 为偶数，则为“红色”；如果 $(i+j)$ 为奇数，则为“黑色”。首先更新红色点，然后更新黑色点。每次更新都将 $u_{i,j}$ 替换为其四个最近邻点的平均值加上一个强迫项，这与 $-\\Delta$ 的5点离散格式一致。\n\n您的任务是：\n- 对离散系统 $A u = f_h$ 实现一次RBGS前平滑扫描，使用针对 $-\\Delta$ 的5点模板。在外部虚拟层上使用齐次狄利克雷边界条件，这意味着内部网格之外的值固定为零且不被更新。右端项是在内部网格点 $(x_i,y_j) = (i h, j h)$ 上采样的 $f(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，其中 $i,j \\in \\{1,\\ldots,N\\}$。\n- 量化RBGS前平滑子对一个误差傅里叶模式的平滑（阻尼）效果。为此，考虑由RBGS诱导的线性定常迭代。对于此类迭代，误差 $e^k = u^k - u^\\star$ 的演化遵循 $e^{k+1} = S e^k$，其中误差传播算子 $S$ 不依赖于右端项。因此，可以通过设置 $f_h \\equiv 0$，将内部未知数初始化为一个给定的误差模式 $e^0$，应用一次RBGS扫描，并测量范数之比 $\\|e^1\\|_2 / \\|e^0\\|_2$ 来评估特定误差模式的阻尼情况。定义误差模式为\n$$\ne^0_{i,j} = \\cos(\\theta_x i)\\cos(\\theta_y j), \\quad \\text{for } i,j \\in \\{1,\\ldots,N\\},\n$$\n其中角度单位为弧度。在 $f_h \\equiv 0$ 的情况下，经过一次RBGS扫描后，令 $e^1$ 表示更新后的内部场，并计算阻尼因子\n$$\n\\mu(\\theta_x,\\theta_y) = \\frac{\\|e^1\\|_2}{\\|e^0\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是在 $N \\times N$ 内部网格上的欧几里得范数。\n\n需要使用的假设和定义：\n- 在均匀网格上，$-\\Delta$ 的5点离散格式对每个内部节点 $(i,j)$ 产生：\n$$\n\\frac{4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}.\n$$\n- 在内部节点 $(i,j)$ 处的RBGS更新将 $u_{i,j}$ 替换为：\n$$\nu_{i,j} \\leftarrow \\frac{1}{4}\\left(u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} + h^2 f_{i,j}\\right),\n$$\n该更新首先应用于所有红色节点（使用当前的黑色邻居值），然后应用于所有黑色节点（使用已更新的红色邻居值）。由于齐次狄利克雷边界条件，在访问邻居时，内部网格之外的值被视为零。\n\n测试套件和要求的输出：\n- 对前平滑算子，使用 $N=32$ 和 $h = 1/(N+1)$。构造 $f_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，其中 $(x_i,y_j) = (i h, j h)$。为了量化阻尼，设置 $f_{i,j} \\equiv 0$ 并使用上述误差模式进行初始化。\n- 评估以下三种情况（角度单位为弧度）的阻尼因子 $\\mu(\\theta_x,\\theta_y)$：\n    - 情况1：$(\\theta_x,\\theta_y) = (\\pi/2,\\pi/2)$。\n    - 情况2：$(\\theta_x,\\theta_y) = (\\pi,\\pi)$。\n    - 情况3：$(\\theta_x,\\theta_y) = (\\pi/16,\\pi/16)$。\n- 您的程序必须按上述顺序计算这三个阻尼因子，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$）。列表中的条目必须是浮点数。角度单位是弧度，无需报告物理单位。\n\n约束和期望：\n- 从基本定义开始：泊松方程 $-\\Delta u = f$、标准的5点离散格式以及迭代式RBGS平滑子。不要引用超出这些定义之外的任何专门的多重网格公式。\n- 通过使用指定的网格、边界条件和强迫函数来确保科学真实性。阻尼因子需按规定进行数值计算，而非通过外部公式获得。", "solution": "用户提供的问题被评估为**有效**。该问题在科学上是合理的、适定的和客观的，提出了偏微分方程数值分析领域的一个标准问题。所有必要的参数和定义都已提供，任务是直接对一个明确定义的算法进行数值实现。\n\n该问题要求分析单次红黑高斯-赛德尔（RBGS）扫描的平滑特性，这是多重网格求解器中一个常见的组成部分。分析将通过量化单位正方形上二维泊松方程特定误差模式的阻尼来进行。\n\n设连续问题为带有齐次狄利克雷边界条件的泊松方程：\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega = (0,1) \\times (0,1)\n$$\n$$\nu = 0 \\quad \\text{on } \\partial\\Omega\n$$\n我们在一个包含 $N \\times N$ 个内部点的均匀网格上离散化此问题，其中 $N=32$。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N+1\\}$，网格间距为 $h = 1/(N+1)$。内部点对应于索引 $i,j \\in \\{1, \\dots, N\\}$。边界上的值（其中 $i$ 或 $j$ 为 $0$ 或 $N+1$）固定为 $u_{i,j}=0$。\n\n在内部网格点 $(i,j)$ 处，使用负拉普拉斯算子 $-\\Delta$ 的标准5点有限差分模板，我们得到离散方程：\n$$\n\\frac{4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}\n$$\n其中 $f_{i,j} = f(x_i, y_j)$。这构成了一个大型稀疏线性方程组，$A \\mathbf{u} = \\mathbf{f}_h$。\n\n红黑高斯-赛德尔（RBGS）方法是求解该系统的一种迭代技术。它将网格点重新排序为两个集合：“红色”点，其索引和 $(i+j)$ 为偶数；“黑色”点，其索引和 $(i+j)$ 为奇数。一次RBGS扫描包括两个阶段：\n1.  首先，同时更新所有红色点的 $u_{i,j}$ 值。更新规则通过求解 $u_{i,j}$ 的模板方程得出：\n    $$\n    u_{i,j} \\leftarrow \\frac{1}{4} \\left( u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} + h^2 f_{i,j} \\right)\n    $$\n    关键在于，对于一个红色点，其所有四个邻居 $(i\\pm 1, j)$ 和 $(i, j\\pm 1)$ 都是黑色的。因此，所有红色点都可以使用其黑色邻居的当前值并行更新。\n2.  其次，同时更新所有黑色点的 $u_{i,j}$ 值。此更新使用相同的公式，但现在依赖于第一阶段中计算出的相邻红色点的**新值**。\n\n在多重网格的背景下，平滑子的目的是阻尼误差的高频分量。误差 $\\mathbf{e}^k = \\mathbf{u}^k - \\mathbf{u}^*$（其中 $\\mathbf{u}^*$ 是精确的离散解）根据误差传播算子 $S$ 进行演化，即 $\\mathbf{e}^{k+1} = S \\mathbf{e}^k$。该算子独立于右端项向量 $\\mathbf{f}_h$。因此，我们可以通过设置 $\\mathbf{f}_h = \\mathbf{0}$ 并观察平滑子对初始误差场 $\\mathbf{e}^0$ 的作用来分析其特性。\n\n我们的任务是计算以下形式的特定初始误差模式的阻尼因子：\n$$\ne^0_{i,j} = \\cos(\\theta_x i) \\cos(\\theta_y j), \\quad \\text{for } i,j \\in \\{1, \\dots, N\\}\n$$\n参数 $(\\theta_x, \\theta_y)$ 决定了误差模式的频率。较小的值对应于低频（平滑）误差，而接近 $\\pi$ 的值对应于高频（振荡）误差。\n\n将一次RBGS扫描应用于初始误差场 $\\mathbf{e}^0$（在 $\\mathbf{f}_h = \\mathbf{0}$ 的情况下），我们得到一个新的误差场 $\\mathbf{e}^1$。阻尼因子 $\\mu$ 定义为结果误差场与初始误差场在内部网格上的欧几里得范数之比：\n$$\n\\mu(\\theta_x, \\theta_y) = \\frac{\\|\\mathbf{e}^1\\|_2}{\\|\\mathbf{e}^0\\|_2} = \\frac{\\sqrt{\\sum_{i=1}^N \\sum_{j=1}^N (e^1_{i,j})^2}}{\\sqrt{\\sum_{i=1}^N \\sum_{j=1}^N (e^0_{i,j})^2}}\n$$\n$\\mu  1$ 的值表示该误差分量被阻尼，值越小表示平滑效果越好。$\\mu \\approx 1$ 的值表示对该模式的阻尼效果很差。\n\n为了在数值上实现这一点，我们将使用一个 $(N+2) \\times (N+2)$ 的网格，以自然地包含齐次狄利克雷边界条件。对于每个测试案例 $(\\theta_x, \\theta_y)$，其过程如下：\n1.  初始化一个大小为 $(N+2) \\times (N+2)$ 的误差网格 $\\mathbf{e}^0$，并用零填充。\n2.  使用指定的余弦公式填充内部点 $e^0_{i,j}$，其中 $i,j \\in \\{1,\\dots,N\\}$。\n3.  计算内部网格上初始范数 $\\|\\mathbf{e}^0\\|_2$。\n4.  对 $\\mathbf{e}^0$ 执行一次RBGS扫描以计算 $\\mathbf{e}^1$。这包括一个红色遍（red pass）和一个黑色遍（black pass），并如上所述正确处理数据依赖性。在此误差分析中，$h^2 f_{i,j}$ 项为零。\n5.  计算内部网格上最终范数 $\\|\\mathbf{e}^1\\|_2$。\n6.  计算比率 $\\mu = \\|\\mathbf{e}^1\\|_2 / \\|\\mathbf{e}^0\\|_2$。\n\n对三个指定的 $(\\theta_x, \\theta_y)$ 对重复此过程，并报告所得的阻尼因子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_damping_factor(N, theta_x, theta_y):\n    \"\"\"\n    Calculates the damping factor of a single Red-Black Gauss-Seidel sweep\n    for a given error mode.\n\n    Args:\n        N (int): The number of interior grid points in one dimension.\n        theta_x (float): The frequency parameter for the x-direction of the error mode.\n        theta_y (float): The frequency parameter for the y-direction of the error mode.\n\n    Returns:\n        float: The damping factor mu = ||e^1||_2 / ||e^0||_2.\n    \"\"\"\n    # Grid setup including boundary layers\n    # Grid is (N+2)x(N+2). Interior is [1:N+1, 1:N+1].\n    e0 = np.zeros((N + 2, N + 2))\n\n    # Create grid indices for the interior\n    i_indices, j_indices = np.mgrid[1:N + 1, 1:N + 1]\n\n    # Initialize the interior of the grid with the specified error mode\n    e0[1:N + 1, 1:N + 1] = np.cos(theta_x * i_indices) * np.cos(theta_y * j_indices)\n\n    # Calculate the L2 norm of the initial error field over the interior\n    norm_e0 = np.linalg.norm(e0[1:N + 1, 1:N + 1])\n    \n    # If the initial norm is zero, the concept of a damping ratio is ill-defined.\n    # For the given test cases this will not happen.\n    if norm_e0 == 0:\n        return 1.0\n\n    # The grid that will be updated by the RBGS sweep\n    e1 = e0.copy()\n\n    # Create masks for red and black points in the interior\n    # Red points: (i+j) is even\n    # Black points: (i+j) is odd\n    red_mask = ((i_indices + j_indices) % 2) == 0\n    black_mask = ((i_indices + j_indices) % 2) == 1\n\n    # Get a view of the interior of the grid to be updated\n    e1_interior = e1[1:N + 1, 1:N + 1]\n\n    # --- RBGS Sweep (with f_h = 0) ---\n\n    # 1. Red Pass: Update all red points.\n    # The update for each red point depends only on its black neighbors.\n    # These updates can be computed simultaneously using the state before the sweep.\n    # We use slicing to get neighbor values.\n    # e1[i-1, j] - e1[0:N, 1:N+1]\n    # e1[i+1, j] - e1[2:N+2, 1:N+1]\n    # e1[i, j-1] - e1[1:N+1, 0:N]\n    # e1[i, j+1] - e1[1:N+1, 2:N+2]\n    neighbors_sum = (e1[0:N, 1:N+1] + e1[2:N+2, 1:N+1] +\n                     e1[1:N+1, 0:N] + e1[1:N+1, 2:N+2])\n    \n    # The update uses the average of the neighbors. Since f_h=0, there is no source term.\n    # Masked assignment updates only the red points.\n    e1_interior[red_mask] = 0.25 * neighbors_sum[red_mask]\n\n    # 2. Black Pass: Update all black points.\n    # The update for each black point depends on its red neighbors.\n    # We must use the *updated* values of the red neighbors from the previous pass.\n    # By re-calculating the sum of neighbors now, we are implicitly using the\n    # updated values for red points stored in e1.\n    neighbors_sum = (e1[0:N, 1:N+1] + e1[2:N+2, 1:N+1] +\n                     e1[1:N+1, 0:N] + e1[1:N+1, 2:N+2])\n                     \n    # Masked assignment updates only the black points.\n    e1_interior[black_mask] = 0.25 * neighbors_sum[black_mask]\n\n    # --- End of RBGS Sweep ---\n\n    # Calculate the L2 norm of the final error field over the interior\n    norm_e1 = np.linalg.norm(e1_interior)\n\n    # Return the damping factor\n    return norm_e1 / norm_e0\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the problem parameters and test cases.\n    N = 32\n    test_cases = [\n        # Case 1: High-frequency mode\n        (np.pi / 2, np.pi / 2),\n        # Case 2: Highest frequency (checkerboard) mode\n        (np.pi, np.pi),\n        # Case 3: Low-frequency mode\n        (np.pi / 16, np.pi / 16),\n    ]\n\n    results = []\n    for theta_x, theta_y in test_cases:\n        damping_factor = calculate_damping_factor(N, theta_x, theta_y)\n        results.append(damping_factor)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3347195"}, {"introduction": "在计算流体力学中，求解压力泊松方程等问题时，常会遇到带有诺伊曼（Neumann）边界条件的奇异算子。本练习将引导您处理这一高级主题，即在多重网格循环中正确处理粗网格上的奇异性和零空间（nullspace）[@problem_id:3347220]。您将比较一个“尊重零空间”的粗网格求解器和一个“失效”的求解器对V-循环收敛性的影响，从而深刻理解为何对粗网格校正施加约束对求解这类问题至关重要。", "problem": "考虑带齐次 Neumann 边界条件的一维压力泊松子问题，这是计算流体力学中的一个典型子问题。连续模型是闭区间 $[0,1]$ 上的拉普拉斯方程，其中 $u(x)$ 满足\n$$\n\\frac{d^2 u}{dx^2} = f(x), \\quad \\frac{du}{dx}(0) = 0, \\quad \\frac{du}{dx}(1) = 0,\n$$\n对于一个在 $[0,1]$ 上积分为零的源项 $f(x)$。该积分约束是问题可解的充分必要条件，并表示 Neumann 拉普拉斯算子存在一个常数零空间。\n\n使用 $n$ 个等距网格点 $\\{x_i\\}_{i=0}^{n-1}$（其中 $x_i = i/(n-1)$）和标准的二阶有限差分来离散化区间 $[0,1]$，并通过在端点使用单侧差分来强制施加齐次 Neumann 边界条件。由此得到的离散算子 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 是对称半正定的一维 Neumann 拉普拉斯算子，其分量定义如下\n$$\n\\mathbf{A}_{0,0} = 1, \\quad \\mathbf{A}_{0,1} = -1,\n$$\n$$\n\\mathbf{A}_{i,i-1} = -1, \\quad \\mathbf{A}_{i,i} = 2, \\quad \\mathbf{A}_{i,i+1} = -1 \\quad \\text{for} \\quad i = 1,2,\\dots,n-2,\n$$\n$$\n\\mathbf{A}_{n-1,n-2} = -1, \\quad \\mathbf{A}_{n-1,n-1} = 1,\n$$\n所有其他项均为零。常数向量 $\\mathbf{1} = [1,1,\\dots,1]^\\top$ 满足 $\\mathbf{A}\\mathbf{1} = \\mathbf{0}$ 并张成其零空间。一个相容的右端向量 $\\mathbf{b} \\in \\mathbb{R}^n$ 必须满足 $\\sum_{i=0}^{n-1} b_i = 0$，否则该系统是不相容的。\n\n定义一个标准的几何两层多重网格V循环，从初始猜测 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始近似求解 $\\mathbf{A}\\mathbf{u} = \\mathbf{b}$，使用以下方法：\n- 权重为 $\\omega \\in (0,1)$ 的加权 Jacobi 光滑子，进行 $\\nu_{\\mathrm{pre}}$ 次前光滑扫描和 $\\nu_{\\mathrm{post}}$ 次后光滑扫描：\n$$\n\\mathbf{u} \\leftarrow \\mathbf{u} + \\omega \\mathbf{D}^{-1}(\\mathbf{b}-\\mathbf{A}\\mathbf{u}),\n$$\n其中 $\\mathbf{D} = \\mathrm{diag}(\\mathbf{A})$。\n- 从大小为 $n_c$ 的粗网格到大小为 $n_f$ 的细网格的线性插值延长算子 $\\mathbf{P} \\in \\mathbb{R}^{n_f \\times n_c}$，其中 $n_f = 2 n_c - 1$，定义如下：\n  - 对于粗网格索引 $j=0,1,\\dots,n_c-1$，令其对应的细网格偶数索引为 $i=2j$。然后设置\n  $$\n  P_{i,j} = 1.\n  $$\n  - 对于细网格奇数索引 $i=1,3,\\dots,n_f-2$，定义\n  $$\n  P_{i,\\lfloor i/2 \\rfloor} = \\tfrac{1}{2}, \\quad P_{i,\\lfloor i/2 \\rfloor + 1} = \\tfrac{1}{2}.\n  $$\n- 从细网格到粗网格的全加权限制算子 $\\mathbf{R} \\in \\mathbb{R}^{n_c \\times n_f}$，定义为：对于 $j=0,1,\\dots,n_c-1$ 及其对应的细网格偶数索引 $i=2j$，\n  - 在左边界 $j=0$ 处：\n  $$\n  R_{0,0} = \\tfrac{1}{2}, \\quad R_{0,1} = \\tfrac{1}{2}.\n  $$\n  - 在内部粗网格索引 $j=1,2,\\dots,n_c-2$ 处：\n  $$\n  R_{j,i-1} = \\tfrac{1}{4}, \\quad R_{j,i} = \\tfrac{1}{2}, \\quad R_{j,i+1} = \\tfrac{1}{4}.\n  $$\n  - 在右边界 $j=n_c-1$ 处：\n  $$\n  R_{n_c-1,n_f-2} = \\tfrac{1}{2}, \\quad R_{n_c-1,n_f-1} = \\tfrac{1}{2}.\n  $$\n- Galerkin 粗网格算子：\n$$\n\\mathbf{A}_c = \\mathbf{R}\\mathbf{A}_f\\mathbf{P},\n$$\n其中 $\\mathbf{A}_f$ 是细网格算子。注意 $\\mathbf{A}_c$ 是奇异的，且具有相同的常数零空间。\n\n为残差方程 $\\mathbf{A}_c \\mathbf{e}_c = \\mathbf{r}_c$ 定义两种粗网格求解器：\n- 尊重零空间的粗网格求解器，它通过首先将粗网格残差投影到 $\\mathbf{A}_c$ 的值域中，然后返回一个与零空间正交的粗网格校正量来强制执行零均值约束：\n$$\n\\mathbf{r}_c \\leftarrow \\mathbf{r}_c - \\left(\\frac{1}{n_c}\\sum_{j=0}^{n_c-1} (\\mathbf{r}_c)_j \\right)\\mathbf{1}, \\quad \\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c, \\quad \\mathbf{e}_c \\leftarrow \\mathbf{e}_c - \\left(\\frac{1}{n_c}\\sum_{j=0}^{n_c-1} (\\mathbf{e}_c)_j \\right)\\mathbf{1},\n$$\n其中 $\\mathbf{A}_c^{\\dagger}$ 表示 Moore–Penrose 伪逆。\n- 一个失效的粗网格求解器，它使用 Moore–Penrose 伪逆而不对零空间进行补偿，即：\n$$\n\\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c,\n$$\n不将 $\\mathbf{r}_c$ 或 $\\mathbf{e}_c$ 投影到零均值子空间上。\n\n考虑在大小为 $n_f$ 的细网格上进行单次 V 循环更新，初始迭代量为 $\\mathbf{u}^{(0)}=\\mathbf{0}$，包含前光滑、残差限制和粗网格求解、延长和校正相加，以及后光滑。令 $\\mathbf{u}^{\\star}$ 表示 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 的精确离散零均值解，选择该解以满足 $\\sum_i u_i^{\\star} = 0$。将一次 V 循环后的误差缩减因子定义为\n$$\n\\rho = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}\\|_2}{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(0)}\\|_2} = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}\\|_2}{\\|\\mathbf{u}^{\\star}\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。\n\n实现一个程序，构建上述算子，并对两种粗网格求解器（尊重零空间的和失效的）执行一次 V 循环，计算相应的误差缩减因子 $\\rho_{\\mathrm{respect}}$ 和 $\\rho_{\\mathrm{fail}}$。\n\n使用以下参数值和右端项的测试套件：\n- 测试用例1（理想路径）：$n_f=9$，$\\omega=2/3$，$\\nu_{\\mathrm{pre}}=2$，$\\nu_{\\mathrm{post}}=2$，且 $b_i = \\sin(2\\pi x_i)$，其中 $i=0,1,\\dots,n_f-1$。\n- 测试用例2（边界为主的粗网格）：$n_f=5$，$\\omega=2/3$，$\\nu_{\\mathrm{pre}}=1$，$\\nu_{\\mathrm{post}}=1$，且 $b_i = \\sin(2\\pi x_i)$，其中 $i=0,1,\\dots,n_f-1$。\n- 测试用例3（低频源）：$n_f=7$，$\\omega=0.7$，$\\nu_{\\mathrm{pre}}=3$，$\\nu_{\\mathrm{post}}=3$，且 $b_i = \\cos(\\pi x_i) - \\frac{1}{n_f}\\sum_{k=0}^{n_f-1}\\cos(\\pi x_k)$，其中 $i=0,1,\\dots,n_f-1$。\n\n对每个测试用例，从 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，经过一次 V 循环后，计算浮点数对 $[\\rho_{\\mathrm{respect}}, \\rho_{\\mathrm{fail}}]$。你的程序应生成单行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表，并为三个测试用例使用嵌套列表，格式完全如下\n$$\n[[\\rho_{\\mathrm{respect}}^{(1)},\\rho_{\\mathrm{fail}}^{(1)}],[\\rho_{\\mathrm{respect}}^{(2)},\\rho_{\\mathrm{fail}}^{(2)}],[\\rho_{\\mathrm{respect}}^{(3)},\\rho_{\\mathrm{fail}}^{(3)}]],\n$$\n其中上标表示测试用例索引。不涉及物理单位、角度或百分比；所有输出均为无量纲浮点数。", "solution": "我们从具有齐次 Neumann 边界条件的拉普拉斯算子的基本性质开始，该算子自然地出现在计算流体力学的压力修正步骤中。由于边界通量为零且区域没有 Dirichlet 锚定，连续算子具有一个常数零空间；在物理上，给压力增加一个常数并不会改变速度场。使用二阶有限差分进行离散化，并在端点实施齐次 Neumann 条件，会得到一个对称半正定矩阵 $\\mathbf{A}$，其行和为零，且常数向量 $\\mathbf{1}$ 位于其零空间中。因此，为了使 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 可解，离散源必须满足相容性条件 $\\sum_i b_i = 0$。\n\n多重网格方法处理跨尺度的误差光滑和粗网格校正问题。V循环包括在细网格上的光滑步骤、将剩余误差（残差）限制到粗网格、求解或近似求解粗网格问题、将校正量延长到细网格层次，以及后光滑。对于带对角矩阵 $\\mathbf{D}$ 的加权 Jacobi 方法，一次扫描通过 $\\mathbf{u} \\leftarrow \\mathbf{u} + \\omega \\mathbf{D}^{-1}(\\mathbf{b}-\\mathbf{A}\\mathbf{u})$ 更新迭代量。加权 Jacobi 能有效衰减高频误差分量。\n\n网格间传递算子必须选择得当，以尊重几何形状和边界条件。线性插值延长算子 $\\mathbf{P}$ 通过在偶数索引处进行精确注入，并通过平均来推断奇数索引，将粗网格项映射到细网格。全加权限制算子 $\\mathbf{R}$ 通过与模板一致的局部平均将细网格向量映射到粗网格向量；在边界处，权重会进行调整以考虑缺失的邻点。Galerkin 粗网格算子为 $\\mathbf{A}_c = \\mathbf{R}\\mathbf{A}_f\\mathbf{P}$，它继承了对称性和零空间。具体来说，粗网格上的常数向量位于零空间中，因此 $\\mathbf{A}_c$ 是奇异的。\n\n对于 Neumann 问题，一个微妙但关键的点是在粗网格层次上对零空间的处理。残差方程 $\\mathbf{A}_c \\mathbf{e}_c = \\mathbf{r}_c$ 有解的充要条件是 $\\sum_j (\\mathbf{r}_c)_j = 0$（因为 $\\mathbf{A}_c$ 的值域由零和向量组成）。即使细网格残差 $\\mathbf{r}_f$ 的和为零——对于任何细网格迭代量都是如此，因为根据行和为零的性质有 $\\sum_i (\\mathbf{A}_f \\mathbf{u})_i = \\sum_i \\sum_k A_{ik} u_k = \\sum_k \\left(\\sum_i A_{ik}\\right) u_k = 0$，因此 $\\sum_i r_i = \\sum_i b_i = 0$——限制算子的选择也可能产生一个不保持精确零和的粗网格残差 $\\mathbf{r}_c$。全加权在局部是守恒的，但在全局上，权重之和会变化，除非限制算子经过特殊设计以保持均值，否则 $\\sum_j (\\mathbf{r}_c)_j$ 不必为零。\n\n如果粗网格求解忽略了零空间约束，并试图采用原始的伪逆解，它将计算出一个包含沿零空间的任意分量的最小二乘校正量。在粗网格上，解不是唯一的：将常数向量的任何倍数加到 $\\mathbf{e}_c$ 上都会得到另一个解，因为 $\\mathbf{A}_c \\mathbf{1} = \\mathbf{0}$。延长这样的校正量会在细网格上引入一个伪常数模式。加权 Jacobi 和细网格算子无法移除常数模式误差，因为它位于 $\\mathbf{A}_f$ 的零空间中；因此，V循环将无法缩减此分量，从而增大了误差缩减因子。\n\n为了量化这种效应，我们计算从 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，经过单次V循环后的误差缩减因子 $\\rho = \\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}\\|_2 / \\|\\mathbf{u}^{\\star}\\|_2$。此处 $\\mathbf{u}^{\\star}$ 是通过固定规范 $\\sum_i u_i^{\\star}=0$ 选择的精确离散零均值解，可以通过 Moore–Penrose 伪逆然后减去均值来数值构造：\n$$\n\\mathbf{u}^{\\star} = \\mathbf{A}^{\\dagger}\\mathbf{b} - \\left(\\frac{1}{n}\\sum_{i=0}^{n-1} (\\mathbf{A}^{\\dagger}\\mathbf{b})_i\\right)\\mathbf{1}.\n$$\n这会产生一个在相差常数的解的等价类中的代表解。\n\nV循环算法如下：\n1. 前光滑：对 $\\mathbf{u}$ 应用 $\\nu_{\\mathrm{pre}}$ 次加权 Jacobi 扫描。\n2. 计算细网格残差 $\\mathbf{r}_f = \\mathbf{b} - \\mathbf{A}_f \\mathbf{u}$。\n3. 将残差限制到粗网格 $\\mathbf{r}_c = \\mathbf{R}\\mathbf{r}_f$。\n4. 粗网格求解：二选一\n   - 尊重零空间：通过 $\\mathbf{r}_c \\leftarrow \\mathbf{r}_c - \\left(\\frac{1}{n_c}\\sum_j (\\mathbf{r}_c)_j\\right)\\mathbf{1}$ 强制残差为零均值，求解 $\\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c$，并通过 $\\mathbf{e}_c \\leftarrow \\mathbf{e}_c - \\left(\\frac{1}{n_c}\\sum_j (\\mathbf{e}_c)_j\\right)\\mathbf{1}$ 强制校正量为零均值。\n   - 失效的：计算 $\\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c$，不进行投影。\n5. 延长校正量：$\\mathbf{e}_f = \\mathbf{P}\\mathbf{e}_c$。\n6. 更新细网格解：$\\mathbf{u} \\leftarrow \\mathbf{u} + \\mathbf{e}_f$。\n7. 后光滑：对 $\\mathbf{u}$ 应用 $\\nu_{\\mathrm{post}}$ 次加权 Jacobi 扫描。\n\n在两种情况下，粗网格算子都是奇异的，但尊重零空间的求解器明确地从粗网格残差和校正量中移除了有问题的常数分量，确保校正量位于 $\\mathbf{A}_c$ 可逆的适当子空间中。失效的求解器保留了常数分量，而延长过程引入了一个无法通过后续光滑步骤缩减的误差分量。因此，对于相容的源项和给定的传递算子，我们预期 $\\rho_{\\mathrm{respect}}  \\rho_{\\mathrm{fail}}$。\n\n我们测试三种情景：\n- 测试用例1，其中 $n_f=9$ 且 $b_i=\\sin(2\\pi x_i)$。这是一个典型的光滑零均值源，用于检验内部行为。\n- 测试用例2，其中 $n_f=5$，以强调粗网格非常小时的边界为主的粗网格效应。\n- 测试用例3，其中 $n_f=7$ 且源项为低频的 $b_i = \\cos(\\pi x_i) - \\text{mean}$，这会产生一个在最低频误差分量上有很强投影的源项；在这种情况下，失效的求解器尤其有害。\n\n对每种情况，我们通过伪逆和减去均值计算精确的零均值解，对两种粗网格求解器变体执行一次V循环，并计算\n$$\n\\rho_{\\mathrm{respect}} = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}_{\\mathrm{respect}}\\|_2}{\\|\\mathbf{u}^{\\star}\\|_2}, \\quad \\rho_{\\mathrm{fail}} = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}_{\\mathrm{fail}}\\|_2}{\\|\\mathbf{u}^{\\star}\\|_2}.\n$$\n然后我们将输出聚合为\n$$\n[[\\rho_{\\mathrm{respect}}^{(1)},\\rho_{\\mathrm{fail}}^{(1)}],[\\rho_{\\mathrm{respect}}^{(2)},\\rho_{\\mathrm{fail}}^{(2)}],[\\rho_{\\mathrm{respect}}^{(3)},\\rho_{\\mathrm{fail}}^{(3)}]].\n$$\n这直接展示了在计算流体力学的离散 Neumann 问题中，不当处理粗网格零空间对多重网格V循环收敛性的影响。该程序显式构建所有算子，并仅使用所述操作，以确保可复现性并遵守指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef neumann_laplacian_1d(n: int) - np.ndarray:\n    \"\"\"\n    Construct the 1D Neumann Laplacian (positive semidefinite) with n grid points.\n    A[0,0]=1, A[0,1]=-1; interior i: A[i,i]=2, A[i,i-1]=-1, A[i,i+1]=-1; A[n-1,n-2]=-1, A[n-1,n-1]=1\n    \"\"\"\n    A = np.zeros((n, n), dtype=float)\n    if n == 1:\n        # Degenerate single-point case: purely nullspace; not used in tests.\n        A[0, 0] = 0.0\n        return A\n    # Left boundary\n    A[0, 0] = 1.0\n    A[0, 1] = -1.0\n    # Interior\n    for i in range(1, n - 1):\n        A[i, i] = 2.0\n        A[i, i - 1] = -1.0\n        A[i, i + 1] = -1.0\n    # Right boundary\n    A[n - 1, n - 1] = 1.0\n    A[n - 1, n - 2] = -1.0\n    return A\n\ndef prolongation_linear(n_coarse: int, n_fine: int) - np.ndarray:\n    \"\"\"\n    Linear interpolation prolongation from coarse to fine for 1D grids with n_fine = 2*n_coarse - 1.\n    \"\"\"\n    assert n_fine == 2 * n_coarse - 1, \"Fine size must be 2*n_coarse - 1\"\n    P = np.zeros((n_fine, n_coarse), dtype=float)\n    # Injection at even indices\n    for j in range(n_coarse):\n        i_even = 2 * j\n        P[i_even, j] = 1.0\n    # Averaging for odd indices\n    for i in range(1, n_fine, 2):\n        j_left = (i - 1) // 2\n        j_right = j_left + 1\n        P[i, j_left] = 0.5\n        if j_right  n_coarse:\n            P[i, j_right] = 0.5\n    return P\n\ndef restriction_full_weighting(n_fine: int, n_coarse: int) - np.ndarray:\n    \"\"\"\n    Full-weighting restriction from fine to coarse for 1D grids with n_fine = 2*n_coarse - 1.\n    Boundary rows use 0.5 weights, interior rows use [0.25, 0.5, 0.25] centered on even fine indices.\n    \"\"\"\n    assert n_fine == 2 * n_coarse - 1, \"Fine size must be 2*n_coarse - 1\"\n    R = np.zeros((n_coarse, n_fine), dtype=float)\n    for j in range(n_coarse):\n        i_even = 2 * j\n        if i_even == 0:\n            R[j, 0] = 0.5\n            if n_fine  1:\n                R[j, 1] = 0.5\n        elif i_even == n_fine - 1:\n            R[j, n_fine - 2] = 0.5\n            R[j, n_fine - 1] = 0.5\n        else:\n            R[j, i_even - 1] = 0.25\n            R[j, i_even] = 0.5\n            R[j, i_even + 1] = 0.25\n    return R\n\ndef weighted_jacobi(A: np.ndarray, b: np.ndarray, u: np.ndarray, omega: float, sweeps: int) - np.ndarray:\n    \"\"\"\n    Perform 'sweeps' iterations of weighted Jacobi on Au = b with weight omega.\n    \"\"\"\n    D = np.diag(A)\n    # Avoid division by zero: for Neumann Laplacian, diagonals are positive (1 at boundaries, 2 interior)\n    invD = 1.0 / D\n    for _ in range(sweeps):\n        r = b - A @ u\n        u = u + omega * (invD * r)\n    return u\n\ndef zero_mean(vec: np.ndarray) - np.ndarray:\n    \"\"\"\n    Project a vector onto the zero-mean subspace.\n    \"\"\"\n    return vec - np.mean(vec)\n\ndef exact_zero_mean_solution(A: np.ndarray, b: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute a representative exact solution with zero mean using pseudoinverse and mean subtraction.\n    Assumes b is compatible with A (sum(b) ~ 0).\n    \"\"\"\n    u = np.linalg.pinv(A) @ b\n    u = zero_mean(u)\n    return u\n\ndef v_cycle_one(A_f: np.ndarray, R: np.ndarray, P: np.ndarray,\n                b_f: np.ndarray, omega: float, nu_pre: int, nu_post: int,\n                respect_nullspace: bool) - np.ndarray:\n    \"\"\"\n    Perform a single two-level V-cycle on fine grid.\n    \"\"\"\n    n_f = A_f.shape[0]\n    n_c = R.shape[0]\n    # Pre-smoothing\n    u = np.zeros(n_f, dtype=float)\n    u = weighted_jacobi(A_f, b_f, u, omega, nu_pre)\n    # Fine residual\n    r_f = b_f - A_f @ u\n    # Restrict to coarse\n    r_c = R @ r_f\n    # Build coarse operator\n    A_c = R @ A_f @ P\n    # Coarse solve\n    if respect_nullspace:\n        # Enforce zero-mean on coarse residual\n        r_c = zero_mean(r_c)\n        e_c = np.linalg.pinv(A_c) @ r_c\n        # Remove coarse nullspace component from correction\n        e_c = zero_mean(e_c)\n    else:\n        e_c = np.linalg.pinv(A_c) @ r_c\n        # No nullspace handling: potentially inject constant modes\n    # Prolongate and correct\n    e_f = P @ e_c\n    u = u + e_f\n    # Post-smoothing\n    u = weighted_jacobi(A_f, b_f, u, omega, nu_post)\n    return u\n\ndef build_rhs_sine(n: int) - np.ndarray:\n    \"\"\"\n    Build b_i = sin(2*pi*x_i) with x_i = i/(n-1). This RHS has mean zero.\n    \"\"\"\n    x = np.linspace(0.0, 1.0, n)\n    b = np.sin(2.0 * np.pi * x)\n    # Numerical rounding might cause tiny residual mean; enforce exact zero mean.\n    b = zero_mean(b)\n    return b\n\ndef build_rhs_cos_pi_minus_mean(n: int) - np.ndarray:\n    \"\"\"\n    Build b_i = cos(pi*x_i) - mean(cos(pi*x_i)), enforcing zero mean.\n    \"\"\"\n    x = np.linspace(0.0, 1.0, n)\n    c = np.cos(np.pi * x)\n    b = c - np.mean(c)\n    return b\n\ndef error_reduction_factors(n_f: int, omega: float, nu_pre: int, nu_post: int, b: np.ndarray) - list:\n    \"\"\"\n    Compute [rho_respect, rho_fail] for one V-cycle with the given parameters and RHS.\n    \"\"\"\n    # Fine operator\n    A_f = neumann_laplacian_1d(n_f)\n    # Coarse grid size: n_c = (n_f + 1)//2\n    n_c = (n_f + 1) // 2\n    # Transfers\n    P = prolongation_linear(n_c, n_f)\n    R = restriction_full_weighting(n_f, n_c)\n    # Exact zero-mean solution\n    u_star = exact_zero_mean_solution(A_f, b)\n    norm0 = np.linalg.norm(u_star)\n    # Respecting nullspace\n    u1_respect = v_cycle_one(A_f, R, P, b, omega, nu_pre, nu_post, respect_nullspace=True)\n    rho_respect = np.linalg.norm(u_star - u1_respect) / (norm0 if norm0 != 0.0 else 1.0)\n    # Failing nullspace handling\n    u1_fail = v_cycle_one(A_f, R, P, b, omega, nu_pre, nu_post, respect_nullspace=False)\n    rho_fail = np.linalg.norm(u_star - u1_fail) / (norm0 if norm0 != 0.0 else 1.0)\n    return [rho_respect, rho_fail]\n\ndef format_nested_list(lst):\n    \"\"\"\n    Format nested list of floats without spaces, with reasonable precision.\n    \"\"\"\n    if isinstance(lst, list):\n        return '[' + ','.join(format_nested_list(x) for x in lst) + ']'\n    elif isinstance(lst, float):\n        # Use 12 significant digits to be concise yet precise\n        return f\"{lst:.12g}\"\n    else:\n        return str(lst)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n_f, omega, nu_pre, nu_post, rhs_builder)\n    test_cases = [\n        (9, 2.0/3.0, 2, 2, build_rhs_sine),          # Test case 1 (happy path)\n        (5, 2.0/3.0, 1, 1, build_rhs_sine),          # Test case 2 (small coarse grid)\n        (7, 0.7,      3, 3, build_rhs_cos_pi_minus_mean),  # Test case 3 (low-frequency source)\n    ]\n\n    results = []\n    for n_f, omega, nu_pre, nu_post, rhs_builder in test_cases:\n        b = rhs_builder(n_f)\n        pair = error_reduction_factors(n_f, omega, nu_pre, nu_post, b)\n        results.append(pair)\n\n    # Final print statement in the exact required format.\n    print(format_nested_list(results))\n\nsolve()\n```", "id": "3347220"}]}