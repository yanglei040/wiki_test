{"hands_on_practices": [{"introduction": "任何表面张力模型的一个基本测试是其正确表示静态平衡的能力。对于静态流体中的封闭界面（如球形液滴），其表面上积分的净表面张力必须为零。本动手实践 [@problem_id:3368723] 将指导您验证连续介质表面力 (Continuum Surface Force, CSF) 模型的这一基本原则。通过对体积 CSF 力进行数值积分，并将其与预期的零解析结果进行比较，您将获得实施 CSF 模型核心组件和评估其基本一致性的实践经验。", "problem": "您的任务是通过计算体积积分得到的净表面力，并与解析结果进行比较，来验证球形液滴的连续介质表面力（CSF）模型的一致性。请在三维空间中进行计算，并采用均匀的笛卡尔网格。所有距离的单位必须是米，表面张力的单位是牛顿/米，力的单位是牛顿。\n\n从动量守恒基本定律和经过充分检验的界面建模事实出发，采用以下建模基础：\n- 平滑颜色函数（体积分数）场用 $\\,\\alpha(\\mathbf{x})\\,$ 表示，它是根据有符号距离场 $\\,\\phi(\\mathbf{x})\\,$ 构建的，作为相间的单调过渡。\n- 单位法向量为 $\\,\\mathbf{n} = \\dfrac{\\nabla \\alpha}{\\lVert \\nabla \\alpha \\rVert}\\,$，其中 $\\,\\lVert \\cdot \\rVert\\,$ 是欧几里得范数。\n- 曲率为 $\\,\\kappa = -\\nabla \\cdot \\mathbf{n}\\,$.\n- 连续介质表面力（CSF）的体力密度为 $\\,\\mathbf{f}_\\sigma = \\sigma \\, \\kappa \\, \\nabla \\alpha\\,$，其中 $\\,\\sigma\\,$ 是表面张力系数。\n\n对于一个半径为 $\\,R\\,$、中心位于 $\\,\\mathbf{x}_c\\,$、处于静止流体中的球形液滴，其解析净表面张力是沿封闭界面 $\\,\\Gamma\\,$ 的面积分 $\\,\\displaystyle \\int_{\\Gamma} \\sigma \\, \\kappa \\, \\mathbf{n} \\, \\mathrm{d}S\\,$。对于一个完美的球体，根据对称性和散度定理，此解析净力等于 $\\,\\mathbf{0}\\,$。您的任务是计算扩散CSF模型预测的净力（作为体积分），并验证其与解析结果在考虑了离散化因素的容差范围内是否一致。\n\n数值规格：\n- 考虑一个立方体域 $\\,[-L, L]^3\\,$，用一个 $\\,N \\times N \\times N\\,$ 单元中心的均匀网格进行离散，网格间距为 $\\,\\Delta = \\dfrac{2L}{N}\\,$。\n- 定义有符号距离场 $\\,\\phi(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{x}_c \\rVert - R\\,$ 和平滑颜色函数\n  $$\\alpha(\\mathbf{x}) = \\tfrac{1}{2}\\Big(1 - \\tanh\\Big(\\dfrac{\\phi(\\mathbf{x})}{\\sqrt{2}\\,\\varepsilon}\\Big)\\Big),$$\n  其中 $\\,\\varepsilon\\,$ 是扩散界面厚度参数。\n- 使用二阶中心差分近似空间导数，并用黎曼和近似净力\n  $$\\mathbf{F}_\\mathrm{CSF} \\approx \\sum_{i,j,k} \\sigma \\, \\kappa_{i,j,k} \\, \\nabla \\alpha_{i,j,k}\\, \\Delta^3,$$\n  其中 $\\,\\kappa_{i,j,k}\\,$ 和 $\\,\\nabla \\alpha_{i,j,k}\\,$ 是网格单元 $\\,\\{i,j,k\\}\\,$ 处的离散曲率和梯度。\n\n验证指标和容差：\n- 解析净力的大小为 $\\,\\lVert \\mathbf{F}_\\mathrm{analytic} \\rVert = 0\\,\\mathrm{N}\\,$.\n- 设 $\\,A = 4\\pi R^2\\,$ 为液滴的表面积。定义绝对容差\n  $$\\mathrm{tol} = C \\,\\sigma \\, A \\, \\dfrac{\\Delta}{\\max(\\varepsilon,\\,\\Delta)},$$\n  其中 $\\,C\\,$ 是一个用户指定的无量纲常数，在此验证中设为 $\\,C=1\\,$。\n- 如果 $\\,\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert \\le \\mathrm{tol}\\,$，则声明测试通过。\n\n测试套件：\n为以下情况实现计算。在每种情况下，报告一个布尔值，指示测试是否根据上述标准通过。\n\n- 情况 $\\,1\\,$（顺利路径，居中液滴）：\n  - $\\,N = 48\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.004\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.072\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 2.0\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (0,0,0)\\,\\mathrm{m}\\,$.\n- 情况 $\\,2\\,$（加密网格，偏心液滴）：\n  - $\\,N = 64\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.006\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.03\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 1.5\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (1.1\\times 10^{-4},-7.0\\times 10^{-5},5.0\\times 10^{-5})\\,\\mathrm{m}\\,$.\n- 情况 $\\,3\\,$（更薄界面）：\n  - $\\,N = 56\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.005\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.0728\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 1.0\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (0,0,0)\\,\\mathrm{m}\\,$.\n- 情况 $\\,4\\,$（更小液滴，粗糙网格，偏心）：\n  - $\\,N = 40\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.003\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.05\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 1.0\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (2.0\\times 10^{-4},2.0\\times 10^{-4},-1.0\\times 10^{-4})\\,\\mathrm{m}\\,$.\n\n程序要求：\n- 您的程序必须为每种情况计算 $\\,\\mathbf{F}_\\mathrm{CSF}\\,$，计算 $\\,\\mathrm{tol}\\,$，并为每种情况输出一个布尔值，指示是否 $\\,\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert \\le \\mathrm{tol}\\,$.\n- 最终输出格式：单行包含一个用方括号括起来的逗号分隔的布尔值列表，例如 $\\,\\texttt{[True,False,True,True]}\\,$. 只生成这样一行输出，不包含其他内容。", "solution": "该问题要求验证连续介质表面力（CSF）模型的一致性。CSF模型是多相计算流体动力学的一个基石。验证方法是通过测试一个基本物理原理：在静止流体中，封闭、对称界面上的净力必须为零。数值模型计算出的任何非零力都是离散化伪影，通常被称为伪力或寄生力。任务是计算球形液滴的这种数值力，并验证其大小在考虑了已知离散误差源的指定容差范围内。\n\n解决方案通过执行指定的数值算法来进行。每个测试用例的过程如下：\n\n1.  **域离散化和网格生成**\n    一个 $[-L, L]^3$ 的立方体计算域被离散化为一个 $N \\times N \\times N$ 单元的均匀笛卡尔网格。在所有三个维度上网格间距是恒定的，由 $\\Delta = \\frac{2L}{N}$ 给出。计算点位于网格单元的中心。对于索引为 $i, j, k$（从 $0$ 到 $N-1$）的网格，单元中心的坐标由以下公式给出：\n    $$ x_i = -L + (i + 0.5)\\Delta $$\n    $$ y_j = -L + (j + 0.5)\\Delta $$\n    $$ z_k = -L + (k + 0.5)\\Delta $$\n    这些坐标用于在离散网格上定义所有物理场。\n\n2.  **标量场计算**\n    两种流体之间的界面由一个平滑的标量场表示，即体积分数或颜色函数 $\\alpha(\\mathbf{x})$。该场由有符号距离函数 $\\phi(\\mathbf{x})$ 构建，该函数给出从点 $\\mathbf{x}$ 到界面的最短距离，其符号表示该点在液滴内部还是外部。对于一个半径为 $R$，中心在 $\\mathbf{x}_c = (x_c, y_c, z_c)$ 的球体，有符号距离为：\n    $$ \\phi(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{x}_c \\rVert - R = \\sqrt{(x-x_c)^2 + (y-y_c)^2 + (z-z_c)^2} - R $$\n    然后，颜色函数 $\\alpha(\\mathbf{x})$ 被定义为一个从1（液滴内部，$\\phi \\le 0$）到0（外部，$\\phi > 0$）的平滑过渡：\n    $$ \\alpha(\\mathbf{x}) = \\tfrac{1}{2}\\Big(1 - \\tanh\\Big(\\dfrac{\\phi(\\mathbf{x})}{\\sqrt{2}\\,\\varepsilon}\\Big)\\Big) $$\n    在这里，$\\varepsilon$ 是一个控制扩散界面厚度的参数。这些函数 $\\phi$ 和 $\\alpha$ 在每个网格点 $(x_i, y_j, z_k)$ 上进行评估。\n\n3.  **颜色函数的梯度 ($\\nabla \\alpha$)**\n    CSF模型需要颜色函数的梯度 $\\nabla \\alpha$。这个向量场对内部点使用二阶中心差分进行数值计算。对于边界点，一种常见且稳健的做法是使用二阶单边差分。此过程被封装在标准的数值库函数中，例如 `numpy.gradient`，本任务将使用该函数。每个网格点 $(i,j,k)$ 处的梯度为：\n    $$ \\nabla \\alpha_{i,j,k} \\approx \\left( \\frac{\\alpha_{i+1,j,k} - \\alpha_{i-1,j,k}}{2\\Delta}, \\frac{\\alpha_{i,j+1,k} - \\alpha_{i,j-1,k}}{2\\Delta}, \\frac{\\alpha_{i,j,k+1} - \\alpha_{i,j,k-1}}{2\\Delta} \\right) $$\n    该梯度仅在扩散界面区域内非零，从而正确定位了表面张力效应。\n\n4.  **单位法向量 ($\\mathbf{n}$)**\n    界面的单位法向量从液相指向气相，并由 $\\alpha$ 的梯度定义：\n    $$ \\mathbf{n} = \\frac{\\nabla \\alpha}{\\lVert \\nabla \\alpha \\rVert} $$\n    在数值上，为防止在 $\\nabla \\alpha = \\mathbf{0}$ 的区域（即远离界面的区域）除以零，在分母中加入一个小的正则化参数。然而，由于最终的力密度 $\\mathbf{f}_\\sigma$ 与 $\\nabla \\alpha$ 成正比，这种正则化对最终的力计算没有影响，因为在 $\\nabla \\alpha$ 为零的任何地方，力也为零。\n\n5.  **曲率计算 ($\\kappa$)**\n    界面的曲率 $\\kappa$ 由单位法向量场的负散度给出：\n    $$ \\kappa = -\\nabla \\cdot \\mathbf{n} = -\\left( \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y} + \\frac{\\partial n_z}{\\partial z} \\right) $$\n    与梯度计算类似，散度使用二阶有限差分进行数值计算。对于法向量的每个分量，沿相应轴计算其偏导数，然后将结果相加。\n\n6.  **净力积分 ($\\mathbf{F}_\\mathrm{CSF}$)**\n    CSF模型用一个连续的体力密度 $\\mathbf{f}_\\sigma$ 来近似作用在界面 $\\Gamma$ 上的奇异表面张力，该体力密度作用于扩散界面区域的有限体积内：\n    $$ \\mathbf{f}_\\sigma = \\sigma \\, \\kappa \\, \\nabla \\alpha $$\n    其中 $\\sigma$ 是表面张力系数。液滴上的总净力 $\\mathbf{F}_\\mathrm{CSF}$ 是此力密度在整个域上的体积分。该积分通过对所有网格单元的黎曼和来近似：\n    $$ \\mathbf{F}_\\mathrm{CSF} = \\int_{V} \\mathbf{f}_\\sigma \\, dV \\approx \\sum_{i,j,k} \\mathbf{f}_{\\sigma, i,j,k} \\, \\Delta V = \\sum_{i,j,k} (\\sigma \\, \\kappa_{i,j,k} \\, \\nabla \\alpha_{i,j,k}) \\, \\Delta^3 $$\n    对力向量的每个分量分别进行求和。\n\n7.  **与容差的验证**\n    从解析上看，液滴上的净力为 $\\mathbf{F}_\\mathrm{analytic} = \\mathbf{0}$。由于离散误差，数值计算出的力 $\\mathbf{F}_\\mathrm{CSF}$ 将非零。这个数值力的大小 $\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert$ 与预定义的容差 $\\mathrm{tol}$ 进行比较。如果 $\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert \\le \\mathrm{tol}$，则测试通过。容差定义为：\n    $$ \\mathrm{tol} = C \\,\\sigma \\, A \\, \\frac{\\Delta}{\\max(\\varepsilon, \\Delta)} $$\n    其中 $C=1$ 是一个无量纲常数，$A=4\\pi R^2$ 是液滴的表面积。这种容差结构正确地反映了数值误差会随着界面变尖锐（更小的 $\\varepsilon/\\Delta$）而增加，并随着网格加密（更小的 $\\Delta$）而减小的预期。\n\n通过对每个提供的测试用例执行这些步骤，我们可以系统地验证CSF实现的一致性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, centered droplet)\n        {'N': 48, 'L': 0.01, 'R': 0.004, 'sigma': 0.072, 'eps_factor': 2.0, 'x_c': (0.0, 0.0, 0.0)},\n        # Case 2 (refined grid, off-centered droplet)\n        {'N': 64, 'L': 0.01, 'R': 0.006, 'sigma': 0.03, 'eps_factor': 1.5, 'x_c': (1.1e-4, -7.0e-5, 5.0e-5)},\n        # Case 3 (thinner interface)\n        {'N': 56, 'L': 0.01, 'R': 0.005, 'sigma': 0.0728, 'eps_factor': 1.0, 'x_c': (0.0, 0.0, 0.0)},\n        # Case 4 (smaller droplet, coarser grid, off-centered)\n        {'N': 40, 'L': 0.01, 'R': 0.003, 'sigma': 0.05, 'eps_factor': 1.0, 'x_c': (2.0e-4, 2.0e-4, -1.0e-4)},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        passed = run_case(**case_params)\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_case(N, L, R, sigma, eps_factor, x_c):\n    \"\"\"\n    Computes the net CSF force for a single case and checks against the tolerance.\n\n    Args:\n        N (int): Number of grid cells along one dimension.\n        L (float): Half-length of the cubic domain [-L, L]^3.\n        R (float): Radius of the spherical droplet.\n        sigma (float): Surface tension coefficient.\n        eps_factor (float): Factor to determine interface thickness, eps = eps_factor * Delta.\n        x_c (tuple): Center of the droplet (x_c, y_c, z_c).\n\n    Returns:\n        bool: True if the test passes (||F_CSF|| = tol), False otherwise.\n    \"\"\"\n    # 1. Grid and Field Generation\n    Delta = 2.0 * L / N\n    epsilon = eps_factor * Delta\n    \n    # Create grid coordinates for cell centers\n    grid_coords_1d = np.linspace(-L + Delta / 2.0, L - Delta / 2.0, N)\n    x, y, z = np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # Compute signed distance field (phi)\n    phi = np.sqrt((x - x_c[0])**2 + (y - x_c[1])**2 + (z - x_c[2])**2) - R\n\n    # Compute color function (alpha)\n    alpha = 0.5 * (1.0 - np.tanh(phi / (np.sqrt(2.0) * epsilon)))\n\n    # 2. Gradient of the Color Function (nabla alpha)\n    # np.gradient uses 2nd-order central differences for interior points\n    # and 2nd-order one-sided differences for boundary points.\n    # The 'ij' indexing ensures axis 0 is x, 1 is y, 2 is z.\n    grad_alpha = np.gradient(alpha, Delta)\n    grad_alpha_x, grad_alpha_y, grad_alpha_z = grad_alpha[0], grad_alpha[1], grad_alpha[2]\n\n    # 3. Unit Normal Vector (n)\n    norm_grad_alpha = np.sqrt(grad_alpha_x**2 + grad_alpha_y**2 + grad_alpha_z**2)\n    \n    # Regularization to avoid division by zero\n    reg_term = 1e-20\n    \n    n_x = grad_alpha_x / (norm_grad_alpha + reg_term)\n    n_y = grad_alpha_y / (norm_grad_alpha + reg_term)\n    n_z = grad_alpha_z / (norm_grad_alpha + reg_term)\n\n    # 4. Curvature Calculation (kappa)\n    # kappa = -nabla . n\n    # Use axis argument for efficiency to compute derivatives only along the required axes.\n    div_n = (np.gradient(n_x, Delta, axis=0) +\n             np.gradient(n_y, Delta, axis=1) +\n             np.gradient(n_z, Delta, axis=2))\n    \n    kappa = -div_n\n\n    # 5. Net Force Integration (F_CSF)\n    # f_sigma = sigma * kappa * nabla alpha\n    f_sigma_x = sigma * kappa * grad_alpha_x\n    f_sigma_y = sigma * kappa * grad_alpha_y\n    f_sigma_z = sigma * kappa * grad_alpha_z\n\n    # Integrate over the volume by summing and multiplying by cell volume\n    dV = Delta**3\n    F_csf_x = np.sum(f_sigma_x) * dV\n    F_csf_y = np.sum(f_sigma_y) * dV\n    F_csf_z = np.sum(f_sigma_z) * dV\n    \n    F_csf = np.array([F_csf_x, F_csf_y, F_csf_z])\n    F_csf_magnitude = np.linalg.norm(F_csf)\n\n    # 6. Verification Against Tolerance\n    C = 1.0\n    A = 4.0 * np.pi * R**2\n    tol = C * sigma * A * Delta / max(epsilon, Delta)\n\n    return F_csf_magnitude = tol\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3368723"}, {"introduction": "尽管静态液滴上的净力可能接近于零，但离散化的表面张力在局部的不平衡仍然会引起被称为“伪电流”或“寄生流”的非物理流动。这些不平衡的一个主要原因是离散网格上界面曲率计算的不准确。本实践 [@problem_id:3368626] 专注于量化这种离散化误差，特别是在实际应用中常见的各向异性网格上，并建立了网格引起的曲率误差与寄生速度大小之间的直接联系。", "problem": "要求您量化在二维各向异性笛卡尔网格上圆形界面的曲率离散误差，并估算在静态液滴中由连续表面力（CSF）模型引起的伪速度标度。您的推导和实现必须从以下基础出发：\n\n- 不可压缩动量平衡（纳维-斯托克斯方程的一种形式），其中表面张力被建模为体积力：$$\\rho \\frac{D \\mathbf{u}}{D t} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\rho \\mathbf{g} + \\mathbf{f}_{s},$$ 其中 $\\rho$ 是密度，$\\mathbf{u}$ 是速度，$p$ 是压力，$\\mu$ 是动力粘度，$\\mathbf{g}$ 是重力加速度，$\\mathbf{f}_{s}$ 是通过连续表面力（CSF）方法建模的表面张力密度。\n- 通过光滑的类符号距离函数 $\\phi(\\mathbf{x})$ 对界面进行水平集表示，单位法向量 $\\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$，以及曲率 $$\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert} \\right)。$$\n- 一个静止的液滴在稳态下满足粘性力与表面张力的平衡；由CSF体积力中的曲率离散误差 $\\delta \\kappa$ 引起的任何残余数值不平衡会产生寄生速度（“伪电流”）。\n\n您的任务：\n\n- 从上述基础出发，推导在间距为 $\\Delta x \\neq \\Delta y$ 的矩形网格上，针对 $\\phi$ 的梯度、单位法向量和散度的一致二阶中心差分离散格式，从而在网格节点上得到离散曲率 $\\kappa_{h}$。除了网格本身的对称性外，不要假设任何特定的对称性。您的推导必须在逻辑上与 $\\kappa = \\nabla \\cdot \\mathbf{n}$ 和各向异性网格上的中心差分相一致，但不应依赖于这些原则之外的任何预先给定的离散模板。\n- 设界面为一个半径为 $R$、中心在 $(x_{c}, y_{c})$ 的圆，由解析水平集 $$\\phi(x,y) = \\sqrt{(x - x_{c})^{2} + (y - y_{c})^{2}} - R$$ 表示。界面上的精确曲率是常数，等于 $1/R$。在方形域 $[-L,L] \\times [-L,L]$（其中 $L = 3R$）上使用间距 $\\Delta x$ 和 $\\Delta y$ 构建一个有限网格，在网格节点上计算 $\\phi$ 的值，计算离散曲率场 $\\kappa_{h}$，然后通过将节点 $\\kappa_{h}$ 值双线性插值到角度为 $\\theta \\in \\{0, \\pi/6, \\pi/4, \\pi/3, \\pi/2\\}$（角度以弧度为单位）的精确界面点 $(x(\\theta), y(\\theta)) = (x_{c} + R \\cos \\theta, y_{c} + R \\sin \\theta)$，来计算这些界面点上的曲率。\n- 定义方向曲率误差 $e(\\theta) = \\kappa_{h}^{\\mathrm{interp}}(\\theta) - 1/R$。由此计算以下标量诊断量：\n  - 平均绝对误差 $$E_{\\mathrm{mean}} = \\frac{1}{N_{\\theta}} \\sum_{\\theta} \\left| e(\\theta) \\right|,$$ 其中 $N_{\\theta} = 5$。\n  - 最大绝对误差 $$E_{\\max} = \\max_{\\theta} \\left| e(\\theta) \\right|。$$\n  - 方向各向异性度量 $$E_{\\mathrm{ani}} = \\max_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta) - \\min_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta)。$$\n- 使用受动量方程启发的稳态斯托克斯平衡，按如下方式估算伪电流的标度。在CSF模型中，表面张力密度的标度为 $|\\mathbf{f}_{s}| \\sim \\sigma \\, |\\delta \\kappa| \\, \\delta_{\\varepsilon}$，其中 $\\sigma$ 是表面张力，$\\delta_{\\varepsilon}$ 是集中在厚度为 $\\varepsilon$ 的界面层中的平滑狄拉克δ函数。将平滑δ函数的量级建模为 $C/\\varepsilon$，其中 $C$ 是一个 $\\mathcal{O}(1)$ 的常数，并选择 $\\varepsilon = 1.5 \\max(\\Delta x, \\Delta y)$。将此残余力与尺度为 $L \\sim R$ 的粘性扩散相平衡，以获得伪速度估计 $$U_{\\mathrm{spur}} \\approx \\frac{\\sigma \\, E_{\\max}}{\\varepsilon} \\frac{R^{2}}{\\mu}。$$\n- 实现一个程序，对以下测试套件执行这些计算。除非另有说明，所有测试用例均使用以下固定参数：液滴中心为 $(x_{c}, y_{c}) = (0, 0)$，忽略重力，密度不进入稳态估计。\n- 单位：所有物理量必须采用国际单位制（SI）。以 $\\mathrm{m}^{-1}$ 为单位报告曲率和曲率误差，以 $\\mathrm{m\\,s}^{-1}$ 为单位报告伪速度。\n- 角度单位：弧度。\n\n测试套件（每个元组列出 $(R, \\Delta x, \\Delta y, \\sigma, \\mu)$）：\n\n- 情况 A（理想路径，各向同性）：$(0.5, 0.01, 0.01, 0.072, 0.001)$。\n- 情况 B（中等各向异性）：$(0.5, 0.01, 0.02, 0.072, 0.001)$。\n- 情况 C（强各向异性）：$(0.5, 0.005, 0.02, 0.072, 0.001)$。\n- 情况 D（粗糙，各向异性）：$(0.3, 0.05, 0.08, 0.072, 0.001)$。\n\n您的程序应生成单行输出，其中包含所有情况的结果，形式为列表的列表，每个内部列表对应一种情况，并按 $[E_{\\mathrm{mean}}, E_{\\max}, E_{\\mathrm{ani}}, U_{\\mathrm{spur}}]$ 的顺序排列。所有数字必须以浮点值的科学记数法打印，小数点后恰好有六位数字。例如，最终输出格式必须类似于\n$[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}],[d_{1},d_{2},d_{3},d_{4}]]$\n除了列表格式中的标准空白外，没有额外的文本。\n\n约束和说明：\n\n- 您必须仅使用与内部节点的各向异性间距一致的中心差分以及在边界处使用合理的单边差分来实现曲率计算。\n- 使用离散曲率场的双线性插值来计算精确圆形界面点上的 $\\kappa_{h}$。\n- 使用上述 $\\varepsilon$ 的定义和稳态斯托克斯平衡来计算 $U_{\\mathrm{spur}}$。\n- 所有结果均以SI单位表示，并采用指定的数字格式，四舍五入到小数点后恰好6位。", "solution": "我们从不可压缩动量平衡方程开始，其中表面张力作为体积力处理：$$\\rho \\frac{D \\mathbf{u}}{D t} = -\\nabla p + \\mu \\nabla^{2} \\mathbf{u} + \\rho \\mathbf{g} + \\mathbf{f}_{s}。$$对于一个静止的液滴，我们有 $\\mathbf{u} = \\mathbf{0}$，因此惯性项和瞬态项消失，方程简化为压力梯度、粘性力和表面张力体积力之间的平衡。在理想的连续介质设定中，如果液滴处于平衡状态，粘性应力消失，跨界面的压力跳跃与表面张力平衡。在连续表面力（CSF）方法中，表面张力体积力写为$$\\mathbf{f}_{s} = \\sigma \\kappa \\mathbf{n} \\, \\delta_{\\Gamma},$$ 其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是曲率，$\\mathbf{n}$ 是界面的单位法向量，$\\delta_{\\Gamma}$ 是一个支撑在界面上的分布。在离散计算中，$\\delta_{\\Gamma}$ 由一个具有特征厚度 $\\varepsilon$ 的平滑分布 $\\delta_{\\varepsilon}$ 表示。\n\n我们通过一个水平集函数 $\\phi(\\mathbf{x})$ 来隐式表示界面，其单位法向量为$$\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert},$$曲率定义为$$\\kappa = \\nabla \\cdot \\mathbf{n} = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert} \\right)。$$对于一个半径为 $R$，中心在 $(x_{c}, y_{c})$ 的圆，其解析水平集函数为$$\\phi(x,y) = \\sqrt{(x - x_{c})^{2} + (y - y_{c})^{2}} - R$$，这在界面 $\\phi = 0$ 上精确地给出 $\\kappa = 1/R$。\n\n在间距为 $\\Delta x$ 和 $\\Delta y$ 的矩形网格上，我们使用中心差分来离散化空间导数。设 $\\phi_{i,j}$ 表示网格节点 $(x_{i}, y_{j})$ 处的 $\\phi$。那么，对于内部节点，离散梯度分量近似为$$\\left(\\partial_{x} \\phi \\right)_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2 \\Delta x}, \\quad \\left(\\partial_{y} \\phi \\right)_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2 \\Delta y},$$并在边界处使用单边差分。梯度模为 $\\lVert \\nabla \\phi \\rVert_{i,j} \\approx \\sqrt{ \\left( \\left(\\partial_{x} \\phi \\right)_{i,j} \\right)^{2} + \\left( \\left(\\partial_{y} \\phi \\right)_{i,j} \\right)^{2} }$，离散单位法向量分量为$$n^{x}_{i,j} = \\frac{ \\left(\\partial_{x} \\phi \\right)_{i,j} }{ \\lVert \\nabla \\phi \\rVert_{i,j} + \\eta }, \\quad n^{y}_{i,j} = \\frac{ \\left(\\partial_{y} \\phi \\right)_{i,j} }{ \\lVert \\nabla \\phi \\rVert_{i,j} + \\eta },$$其中 $\\eta$ 是一个小的正正则化常数，以避免在远离界面处除以零。节点上的离散曲率通过对散度进行中心差分得到，$$\\kappa_{i,j} \\approx \\frac{ n^{x}_{i+1,j} - n^{x}_{i-1,j} }{ 2 \\Delta x } + \\frac{ n^{y}_{i,j+1} - n^{y}_{i,j-1} }{ 2 \\Delta y },$$同样在边界处使用适当的单边差分。这种构造与 $\\kappa = \\nabla \\cdot \\mathbf{n}$ 一致，并且当 $\\Delta x$ 和 $\\Delta y$ 可能不同时，对于光滑的 $\\phi$，在内部节点上是二阶精确的。\n\n为量化方向误差，我们考虑由$$\\left( x(\\theta), y(\\theta) \\right) = \\left( x_{c} + R \\cos \\theta, \\, y_{c} + R \\sin \\theta \\right), \\quad \\theta \\in \\{ 0, \\, \\pi/6, \\, \\pi/4, \\, \\pi/3, \\, \\pi/2 \\},$$参数化的精确圆形界面，并通过对节点值进行双线性插值来在这些点上计算离散曲率场 $\\kappa_{h}$。将插值后的值记为 $\\kappa_{h}^{\\mathrm{interp}}(\\theta)$。方向曲率误差为$$e(\\theta) = \\kappa_{h}^{\\mathrm{interp}}(\\theta) - \\frac{1}{R}。$$从这些样本中，我们计算三个标量诊断量：$$E_{\\mathrm{mean}} = \\frac{1}{N_{\\theta}} \\sum_{\\theta} \\left| e(\\theta) \\right|, \\quad E_{\\max} = \\max_{\\theta} \\left| e(\\theta) \\right|, \\quad E_{\\mathrm{ani}} = \\max_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta) - \\min_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta),$$其中 $N_{\\theta} = 5$。\n\n为了估算由CSF项中的曲率误差引起的伪速度标度，我们注意到残余CSF力的量级标度为 $|\\mathbf{f}_{\\mathrm{res}}| \\sim \\sigma \\, |\\delta \\kappa| \\, \\delta_{\\varepsilon}$，其中 $|\\delta \\kappa|$ 是一个特征曲率误差，$\\delta_{\\varepsilon}$ 是正则化的界面delta函数。将平滑delta函数在厚度为 $\\varepsilon$ 的层上的量级建模为 $\\sim 1/\\varepsilon$，我们取 $\\varepsilon = 1.5 \\max(\\Delta x, \\Delta y)$。在长度尺度 $L \\sim R$ 的稳态斯托克斯平衡中，$$\\mu \\frac{U_{\\mathrm{spur}}}{L^{2}} \\sim \\sigma \\frac{ |\\delta \\kappa| }{ \\varepsilon },$$因此$$U_{\\mathrm{spur}} \\approx \\frac{ \\sigma \\, |\\delta \\kappa| }{ \\varepsilon } \\frac{ R^{2} }{ \\mu }。$$我们选择 $|\\delta \\kappa| = E_{\\max}$ 作为残余曲率误差的保守度量。该估计尊重量纲一致性：$[\\sigma] = \\mathrm{N\\,m}^{-1}$，$[\\delta \\kappa] = \\mathrm{m}^{-1}$，$[\\varepsilon] = \\mathrm{m}$，$[R^{2}] = \\mathrm{m}^{2}$，$[\\mu] = \\mathrm{Pa\\,s} = \\mathrm{N\\,s\\,m}^{-2}$，得出 $[U_{\\mathrm{spur}}] = \\mathrm{m\\,s}^{-1}$。\n\n程序实现的算法步骤：\n\n- 对于每个测试用例 $(R, \\Delta x, \\Delta y, \\sigma, \\mu)$，设置方形域的半尺寸 $L = 3R$。构建一维网格 $x_{i} = -L + i \\Delta x$ 和 $y_{j} = -L + j \\Delta y$，对于 $i = 0, \\dots, N_{x}$ 和 $j = 0, \\dots, N_{y}$，使得端点覆盖 $[-L, L]$（如果与步长对齐，则包含最后一个点）。\n- 在网格上计算 $\\phi_{i,j} = \\sqrt{ (x_{i} - x_{c})^{2} + (y_{j} - y_{c})^{2} } - R$，其中 $(x_{c}, y_{c}) = (0, 0)$。\n- 通过内部节点的中心差分和边界的单边差分计算离散梯度 $\\partial_{x} \\phi$ 和 $\\partial_{y} \\phi$。在分母中使用小的正则化 $\\eta$ 形成离散单位法向量 $\\mathbf{n}$，以避免在远离界面处除以零。\n- 使用中心差分（以及在边界处使用单边差分）计算 $\\mathbf{n}$ 的散度，得到离散曲率场 $\\kappa_{h}$。\n- 对于 $\\theta \\in \\{ 0, \\pi/6, \\pi/4, \\pi/3, \\pi/2 \\}$，计算 $(x(\\theta), y(\\theta))$，然后将 $\\kappa_{h}$ 双线性插值到这些坐标上，以获得 $\\kappa_{h}^{\\mathrm{interp}}(\\theta)$。\n- 计算 $e(\\theta)$、$E_{\\mathrm{mean}}$、$E_{\\max}$ 和 $E_{\\mathrm{ani}}$；使用 $\\varepsilon = 1.5 \\max(\\Delta x, \\Delta y)$ 估算 $U_{\\mathrm{spur}}$，即 $$U_{\\mathrm{spur}} = \\frac{ \\sigma E_{\\max} }{ \\varepsilon } \\frac{ R^{2} }{ \\mu }。$$\n- 对于每种情况，输出列表 $[E_{\\mathrm{mean}}, E_{\\max}, E_{\\mathrm{ani}}, U_{\\mathrm{spur}}]$，将所有情况汇总到单行中，每个数字都以科学记数法格式化，小数点后恰好6位，并以正确的SI单位表示：前三个为 $\\mathrm{m}^{-1}$，最后一个为 $\\mathrm{m\\,s}^{-1}$。\n\n这种构造将基本定义 $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\lVert \\nabla \\phi \\rVert \\right)$ 和CSF体积力与各向异性网格上的具体有限差分算法联系起来，并使用稳态斯托克斯标度分析来量化方向曲率误差如何转化为伪速度的量级。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef central_diff_x(f, dx):\n    \"\"\"Central differences in x with first-order one-sided at boundaries.\"\"\"\n    d = np.empty_like(f)\n    d[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2.0 * dx)\n    d[0, :] = (f[1, :] - f[0, :]) / dx\n    d[-1, :] = (f[-1, :] - f[-2, :]) / dx\n    return d\n\ndef central_diff_y(f, dy):\n    \"\"\"Central differences in y with first-order one-sided at boundaries.\"\"\"\n    d = np.empty_like(f)\n    d[:, 1:-1] = (f[:, 2:] - f[:, :-2]) / (2.0 * dy)\n    d[:, 0] = (f[:, 1] - f[:, 0]) / dy\n    d[:, -1] = (f[:, -1] - f[:, -2]) / dy\n    return d\n\ndef curvature_from_levelset(phi, dx, dy, eta=1e-14):\n    \"\"\"\n    Compute discrete curvature kappa = div( grad(phi)/|grad(phi)| )\n    using central differences on an anisotropic grid.\n    \"\"\"\n    # Gradients\n    dphidx = central_diff_x(phi, dx)\n    dphidy = central_diff_y(phi, dy)\n    grad_norm = np.sqrt(dphidx**2 + dphidy**2) + eta\n\n    nx = dphidx / grad_norm\n    ny = dphidy / grad_norm\n\n    dnxdx = central_diff_x(nx, dx)\n    dnydy = central_diff_y(ny, dy)\n\n    kappa = dnxdx + dnydy\n    return kappa\n\ndef bilinear_interpolate(xp, yp, x, y, F):\n    \"\"\"\n    Bilinear interpolation of field F defined on grid (x,y) at point (xp, yp).\n    x: 1D array of x-coordinates, length Nx\n    y: 1D array of y-coordinates, length Ny\n    F: 2D array shape (Nx, Ny)\n    \"\"\"\n    # Ensure xp, yp are within grid bounds\n    if xp = x[0]:\n        i0 = 0\n    elif xp >= x[-1]:\n        i0 = len(x) - 2\n    else:\n        i0 = np.searchsorted(x, xp) - 1\n    i1 = i0 + 1\n\n    if yp = y[0]:\n        j0 = 0\n    elif yp >= y[-1]:\n        j0 = len(y) - 2\n    else:\n        j0 = np.searchsorted(y, yp) - 1\n    j1 = j0 + 1\n\n    x0, x1 = x[i0], x[i1]\n    y0, y1 = y[j0], y[j1]\n\n    # Prevent division by zero if degenerate (shouldn't happen with proper grids)\n    tx = 0.0 if x1 == x0 else (xp - x0) / (x1 - x0)\n    ty = 0.0 if y1 == y0 else (yp - y0) / (y1 - y0)\n\n    f00 = F[i0, j0]\n    f10 = F[i1, j0]\n    f01 = F[i0, j1]\n    f11 = F[i1, j1]\n\n    f0 = (1 - tx) * f00 + tx * f10\n    f1 = (1 - tx) * f01 + tx * f11\n    fp = (1 - ty) * f0 + ty * f1\n    return fp\n\ndef compute_case(R, dx, dy, sigma, mu, center=(0.0, 0.0)):\n    # Domain half-size\n    L = 3.0 * R\n    # Construct grids including endpoints when aligned\n    # Use arange to honor the spacings exactly\n    x = np.arange(-L, L + 0.5 * dx, dx)\n    y = np.arange(-L, L + 0.5 * dy, dy)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    xc, yc = center\n    phi = np.sqrt((X - xc)**2 + (Y - yc)**2) - R\n\n    kappa = curvature_from_levelset(phi, dx, dy, eta=1e-12)\n\n    # Interface angles in radians\n    angles = np.array([0.0, np.pi/6.0, np.pi/4.0, np.pi/3.0, np.pi/2.0])\n    # Interpolate kappa to exact interface points\n    kappa_samples = []\n    for th in angles:\n        xp = xc + R * np.cos(th)\n        yp = yc + R * np.sin(th)\n        kval = bilinear_interpolate(xp, yp, x, y, kappa)\n        kappa_samples.append(kval)\n    kappa_samples = np.array(kappa_samples)\n\n    kappa_exact = 1.0 / R\n    errors = kappa_samples - kappa_exact\n    E_mean = float(np.mean(np.abs(errors)))\n    E_max = float(np.max(np.abs(errors)))\n    E_ani = float(np.max(kappa_samples) - np.min(kappa_samples))\n\n    # Spurious velocity estimate\n    eps = 1.5 * max(dx, dy)\n    U_spur = sigma * E_max / eps * (R**2) / mu\n\n    return E_mean, E_max, E_ani, U_spur\n\ndef format_number(x):\n    # Scientific notation with exactly six digits after decimal\n    return f\"{x:.6e}\"\n\ndef solve():\n    # Define the test cases from the problem statement: (R, dx, dy, sigma, mu)\n    test_cases = [\n        (0.5, 0.01, 0.01, 0.072, 0.001),  # Case A\n        (0.5, 0.01, 0.02, 0.072, 0.001),  # Case B\n        (0.5, 0.005, 0.02, 0.072, 0.001), # Case C\n        (0.3, 0.05, 0.08, 0.072, 0.001),  # Case D\n    ]\n\n    results = []\n    for R, dx, dy, sigma, mu in test_cases:\n        E_mean, E_max, E_ani, U_spur = compute_case(R, dx, dy, sigma, mu, center=(0.0, 0.0))\n        results.append([E_mean, E_max, E_ani, U_spur])\n\n    # Build the exact required format: list of lists with each number formatted\n    formatted_rows = []\n    for row in results:\n        formatted = \"[\" + \",\".join(format_number(v) for v in row) + \"]\"\n        formatted_rows.append(formatted)\n    output = \"[\" + \",\".join(formatted_rows) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3368626"}, {"introduction": "对于涉及移动界面的模拟，数值方案对物体在网格上的相对位置的鲁棒性至关重要。一个理想的方法应表现出几何守恒性，即物理不变量在刚体运动下保持不变。这个高级练习 [@problem_id:3368688] 允许您通过对液滴进行刚性平移并量化由此产生的数值曲率和净力的变化来研究 CSF 模型的此属性。该分析揭示了由于离散界面捕捉方案缺乏伽利略不变性而可能出现的微妙但重要的误差。", "problem": "给定一个二维、不可压缩、静止的流体域，其中一个单一的圆形液滴由水平集符号距离函数表示。您将量化液滴在刚性平移下，连续介质表面力（CSF）模型中的几何守恒误差。目标是确定当液滴平移一个恒定偏移量时，均匀周期性网格上的离散化如何影响表面张力的数值不变量。\n\n从以下基本基础开始：\n- 控制体的牛顿第二定律，其中表面张力在动量方程中表现为体力。\n- 连续介质表面力（CSF）模型将表面张力表示为体力密度 $ \\mathbf{f}_s = \\sigma \\kappa \\delta_s \\mathbf{n} $，其中 $ \\sigma $ 是表面张力系数，$ \\kappa $ 是平均曲率，$ \\delta_s $ 是一个将力集中在界面上的分布函数，$ \\mathbf{n} $ 是指向液滴内部到外部的界面单位法向量。\n- 在水平集方法（LSM）中，界面被表示为符号距离函数 $ \\phi(\\mathbf{x}) $ 的零等值线，并且在界面上，$ \\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert $ 和 $ \\kappa = \\nabla \\cdot \\mathbf{n} $。\n\n假设一个边长为 $ L $ 的方形周期性域，用一个具有 $ N \\times N $ 个节点和网格间距 $ h = L/N $ 的均匀网格进行离散化。对空间导数使用周期性边界条件。液滴是一个半径为 $ R $、中心在 $ (c_x, c_y) $ 的圆。符号距离水平集为 $ \\phi(x,y) = \\sqrt{(x-c_x)^2 + (y-c_y)^2} - R $。圆的解析参考曲率为 $ \\kappa_{\\text{exact}} = 1/R $。\n\n您的任务：\n1. 在周期性边界条件下，使用二阶中心有限差分法离散化梯度和散度，以从 $ \\phi $ 计算离散的单位法向量 $ \\mathbf{n} $ 和曲率 $ \\kappa $。\n2. 使用标准平滑函数，将界面分布 $ \\delta_s $ 近似为一个光滑的狄拉克δ函数 $ \\delta_\\varepsilon(\\phi) $，该函数支撑在半宽为 $ \\varepsilon $ 的窄带内\n   $$ \\delta_\\varepsilon(\\phi) = \\begin{cases}\n   \\dfrac{1}{2\\varepsilon} \\left(1 + \\cos\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right),  |\\phi| \\le \\varepsilon, \\\\\n   0,  \\text{otherwise},\n   \\end{cases} $$\n   其中 $ \\varepsilon = 1.5 h $。\n3. 计算CSF体力密度场 $ \\mathbf{f}_s = \\sigma \\kappa \\delta_\\varepsilon(\\phi) \\mathbf{n} $。\n4. 对于位于域中心 $ (L/2, L/2) $ 的给定液滴中心 $ (c_x, c_y) $，计算两个不变量：\n   - 限制在 $ \\varepsilon $-窄带内的均方根曲率误差，\n     $$ E_\\kappa = \\sqrt{\\dfrac{1}{N_b} \\sum_{i \\in \\mathcal{B}} \\left(\\kappa_i - \\dfrac{1}{R}\\right)^2}, $$\n     其中 $ \\mathcal{B} = \\{ i : |\\phi_i| \\le \\varepsilon \\} $ 且 $ N_b = |\\mathcal{B}| $。\n   - 在整个域上积分的净CSF力向量，\n     $$ \\mathbf{F} = \\sum_{\\text{cells}} \\mathbf{f}_{s} \\, \\Delta A, \\quad \\Delta A = h^2, \\quad F_{\\text{mag}} = \\lVert \\mathbf{F} \\rVert_2. $$\n     在连续介质中，对于周期域中的闭合圆形界面，净力应为 $ \\mathbf{F} = \\mathbf{0} $。\n5. 对液滴施加一个刚性平移 $ (\\Delta x, \\Delta y) $，保持网格固定。平移量被指定为网格间距的倍数：定义 $ \\Delta x = \\alpha_x h $ 和 $ \\Delta y = \\alpha_y h $，中心位置进行周期性环绕处理。平移后重新计算 $ E_\\kappa $ 和 $ F_{\\text{mag}} $。\n6. 将由平移引起的几何守恒误差量化为绝对偏差\n   $$ \\Delta E_\\kappa = \\left| E_\\kappa^{\\text{post}} - E_\\kappa^{\\text{pre}} \\right|, \\qquad \\Delta F = \\left| F_{\\text{mag}}^{\\text{post}} - F_{\\text{mag}}^{\\text{pre}} \\right|. $$\n\n物理和数值单位：\n- 以 $ \\text{m}^{-1} $ 为单位报告 $ E_\\kappa $ 和 $ \\Delta E_\\kappa $。\n- 假设平面外方向的单位厚度，以 $ \\text{N} $ 为单位报告 $ F_{\\text{mag}} $ 和 $ \\Delta F $。\n- 所有长度（$ L $、$ R $、$ h $、$ \\Delta x $、$ \\Delta y $、坐标）单位均为 $ \\text{m} $。\n- 表面张力 $ \\sigma $ 的单位为 $ \\text{N}/\\text{m} $。\n- 角度单位为弧度。\n\n数值方案说明：\n- 对 $ \\nabla \\phi $ 和 $ \\nabla \\cdot \\mathbf{n} $ 使用带周期性边界条件的二阶中心有限差分法。\n- 在单元中心构建网格节点坐标 $ x_i = (i + 0.5) h $，$ y_j = (j + 0.5) h $，其中 $ i,j \\in \\{0,\\dots,N-1\\} $。\n- 通过在分母中添加一个小参数 $ \\eta $ 来正则化归一化过程 $ \\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert $，以避免除以零，其中 $ \\eta = 10^{-12} $ 为无量纲量级。\n\n测试套件：\n为以下参数集提供结果。对于每个测试用例，程序必须计算如上定义的 $ \\Delta E_\\kappa $ 和 $ \\Delta F $，并以指定的输出格式返回它们。\n\n- 测试 $ 1 $（基线，无平移）：\n  - $ N = 128 $，$ L = 1.0 \\, \\text{m} $，$ R = 0.2 \\, \\text{m} $，$ \\sigma = 0.072 \\, \\text{N}/\\text{m} $，$ \\alpha_x = 0.0 $，$ \\alpha_y = 0.0 $。\n- 测试 $ 2 $（$ x $ 方向整数单元平移）：\n  - $ N = 128 $，$ L = 1.0 \\, \\text{m} $，$ R = 0.2 \\, \\text{m} $，$ \\sigma = 0.072 \\, \\text{N}/\\text{m} $，$ \\alpha_x = 1.0 $，$ \\alpha_y = 0.0 $。\n- 测试 $ 3 $（两个方向半单元平移）：\n  - $ N = 128 $，$ L = 1.0 \\, \\text{m} $，$ R = 0.2 \\, \\text{m} $，$ \\sigma = 0.072 \\, \\text{N}/\\text{m} $，$ \\alpha_x = 0.5 $，$ \\alpha_y = 0.5 $。\n- 测试 $ 4 $（较小液滴，$ x $ 方向半单元平移）：\n  - $ N = 128 $，$ L = 1.0 \\, \\text{m} $，$ R = 0.08 \\, \\text{m} $，$ \\sigma = 0.072 \\, \\text{N}/\\text{m} $，$ \\alpha_x = 0.5 $，$ \\alpha_y = 0.0 $。\n- 测试 $ 5 $（较粗网格，$ x $ 方向半单元平移）：\n  - $ N = 64 $，$ L = 1.0 \\, \\text{m} $，$ R = 0.2 \\, \\text{m} $，$ \\sigma = 0.072 \\, \\text{N}/\\text{m} $，$ \\alpha_x = 0.5 $，$ \\alpha_y = 0.0 $。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个测试用例贡献一个双元素列表 $ [\\Delta E_\\kappa, \\Delta F] $。例如，\n  \"[[0.0,0.0],[0.0,0.0]]\"\n- 不应打印任何额外文本。\n\n所有数值答案均以国际单位制（SI）表示，$ \\Delta E_\\kappa $ 的单位为 $ \\text{m}^{-1} $，$ \\Delta F $ 的单位为 $ \\text{N} $。", "solution": "该问题要求量化当一个圆形液滴在固定的周期性网格上进行刚性平移时，表面张力的连续介质表面力（CSF）模型中的几何守恒误差。该误差通过两个数值不变量的变化来衡量：均方根（RMS）曲率误差和域上的净表面张力。分析使用水平集方法进行。\n\n基本原理是流体的牛顿第二定律，其中表面张力被建模为集中在流体-流体界面上的体积力 $\\mathbf{f}_s$。CSF模型将此力定义为 $\\mathbf{f}_s = \\sigma \\kappa \\delta_s \\mathbf{n}$，其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是界面曲率，$\\mathbf{n}$ 是界面单位法向量，$\\delta_s$ 是将力定位到界面的分布函数。\n\n在包含单个闭合界面的连续周期域中，由于力学平衡，净表面张力必须为零，即 $\\oint \\sigma \\kappa \\mathbf{n} \\, dS = \\mathbf{0}$。然而，当在网格上离散化时，$\\kappa$ 和 $\\mathbf{n}$ 的数值计算会引入误差。一个稳健的数值方案的关键特性是，其计算出的不变量应与物体在网格上的位置无关。未能保持这种不变性，即所谓的缺乏几何守恒性，会表现为依赖于界面亚网格位置的伪力和误差。本问题旨在数值化地测量这种效应。\n\n针对每个测试用例，通过以下步骤序列来实施解决方案。\n\n首先，我们建立计算域。一个边长为 $L$ 的方形周期域被离散化为一个 $N \\times N$ 单元的均匀网格。网格间距为 $h=L/N$。网格节点位于单元中心，坐标 $(x_i, y_j)$ 由下式给出：\n$$ x_i = (i + 0.5)h, \\quad y_j = (j + 0.5)h, \\quad \\text{for } i, j \\in \\{0, 1, \\dots, N-1\\} $$\n\n其次，圆形液滴界面由一个符号距离水平集函数 $\\phi(\\mathbf{x})$ 隐式表示。对于一个半径为 $R$、中心在 $(c_x, c_y)$ 的圆，此函数在每个网格节点 $(x_i, y_j)$ 上的定义为：\n$$ \\phi_{i,j} = \\sqrt{(x_i - c_x)^2 + (y_j - c_y)^2} - R $$\n\n第三，我们从离散的 $\\phi$ 场计算界面的几何属性——单位法向量 $\\mathbf{n}$ 和曲率 $\\kappa$。水平集函数的梯度 $\\nabla \\phi = (\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y})$，是使用带有周期性边界条件的二阶中心有限差分法计算的。对于离散场 $u_{i,j}$：\n$$ \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} \\approx \\frac{u_{i+1,j} - u_{i-1,j}}{2h}, \\quad \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2h} $$\n索引按周期性处理，例如，$u_{N,j} = u_{0,j}$ 且 $u_{-1,j} = u_{N-1,j}$。\n\n然后通过对梯度场进行归一化来计算单位法向量 $\\mathbf{n}$。为防止在 $\\nabla\\phi$ 可能接近零的区域（远离界面）出现除以零的情况，通过添加一个小的参数 $\\eta = 10^{-12}$ 来对分母进行正则化：\n$$ \\mathbf{n} = \\frac{\\nabla\\phi}{\\lVert\\nabla\\phi\\rVert_2 + \\eta} $$\n\n曲率 $\\kappa$ 是法向量场的散度，$\\kappa = \\nabla \\cdot \\mathbf{n}$。这也是通过在离散 $\\mathbf{n}$ 场的分量上使用二阶周期性中心差分来计算的：\n$$ \\kappa_{i,j} = \\left(\\frac{\\partial n_x}{\\partial x}\\right)_{i,j} + \\left(\\frac{\\partial n_y}{\\partial y}\\right)_{i,j} $$\n\n第四，将力集中在界面上的狄拉克δ分布 $\\delta_s$，通过一个支撑半宽为 $\\varepsilon = 1.5h$ 的光滑平滑函数 $\\delta_\\varepsilon(\\phi)$ 来近似：\n$$ \\delta_\\varepsilon(\\phi) = \\begin{cases}\n   \\dfrac{1}{2\\varepsilon} \\left(1 + \\cos\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right),  \\text{if } |\\phi| \\le \\varepsilon \\\\\n   0,  \\text{otherwise}\n   \\end{cases} $$\n该函数在每个网格节点上使用相应的 $\\phi_{i,j}$ 值进行评估。\n\n第五，有了所有分量，我们在每个网格节点上计算CSF体力密度场 $\\mathbf{f}_s = \\sigma \\kappa \\delta_\\varepsilon(\\phi) \\mathbf{n}$。\n\n第六，我们计算两个指定的不变量。\n1. 均方根曲率误差 $E_\\kappa$ 是在 $|\\phi| \\le \\varepsilon$ 的窄带 $\\mathcal{B}$ 上计算的。它衡量了数值曲率与精确解析值 $\\kappa_{\\text{exact}} = 1/R$ 的偏差：\n   $$ E_\\kappa = \\sqrt{\\frac{1}{N_b} \\sum_{(i,j) \\in \\mathcal{B}} \\left(\\kappa_{i,j} - \\frac{1}{R}\\right)^2} $$\n   其中 $N_b$ 是窄带 $\\mathcal{B}$ 中的网格节点数。\n2. 净表面张力 $\\mathbf{F}$ 是通过在整个域上对力密度场进行积分来计算的。该积分通过对所有网格单元求和来近似，每个单元的面积为 $\\Delta A = h^2$：\n   $$ \\mathbf{F} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\mathbf{f}_{s,i,j} \\, h^2 $$\n   这个净力的大小即为 $F_{\\text{mag}} = \\lVert \\mathbf{F} \\rVert_2$。理论上，它应该为零。\n\n最后，对几何守恒误差进行量化。对于每个测试用例，上述过程执行两次：\n1.  **平移前**：液滴中心位于 $(c_x^{\\text{pre}}, c_y^{\\text{pre}}) = (L/2, L/2)$。计算不变量 $E_\\kappa^{\\text{pre}}$ 和 $F_{\\text{mag}}^{\\text{pre}}$。\n2.  **平移后**：液滴中心平移 $(\\Delta x, \\Delta y) = (\\alpha_x h, \\alpha_y h)$。新的中心为 $(c_x^{\\text{post}}, c_y^{\\text{post}}) = ((L/2 + \\Delta x) \\pmod L, (L/2 + \\Delta y) \\pmod L)$，其中取模运算确保周期性环绕。重新计算不变量 $E_\\kappa^{\\text{post}}$ 和 $F_{\\text{mag}}^{\\text{post}}$。\n\n几何守恒误差是平移前和平移后值的绝对差：\n$$ \\Delta E_\\kappa = \\left| E_\\kappa^{\\text{post}} - E_\\kappa^{\\text{pre}} \\right| $$\n$$ \\Delta F = \\left| F_{\\text{mag}}^{\\text{post}} - F_{\\text{mag}}^{\\text{pre}} \\right| $$\n这些值 $\\Delta E_\\kappa$ 和 $\\Delta F$ 代表了每个测试用例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_invariants(N, L, R, sigma, cx, cy):\n    \"\"\"\n    Computes numerical invariants for a circular droplet on a 2D periodic grid.\n    \n    Args:\n        N (int): Number of grid points in each dimension.\n        L (float): Domain side length in meters.\n        R (float): Droplet radius in meters.\n        sigma (float): Surface tension coefficient in N/m.\n        cx (float): x-coordinate of the droplet center.\n        cy (float): y-coordinate of the droplet center.\n        \n    Returns:\n        tuple: (E_kappa, F_mag)\n            E_kappa (float): RMS curvature error in the interface band.\n            F_mag (float): Magnitude of the net surface tension force.\n    \"\"\"\n    # Grid and numerical parameters\n    h = L / float(N)\n    eps = 1.5 * h\n    eta = 1e-12\n\n    # Grid coordinates (cell-centered)\n    i_coords = np.arange(N)\n    x = (i_coords + 0.5) * h\n    y = (i_coords + 0.5) * h\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Signed distance function (SDF) phi\n    phi = np.sqrt((xx - cx)**2 + (yy - cy)**2) - R\n\n    # Gradient of phi (2nd-order centered difference with periodic BC)\n    # np.roll provides periodic boundaries\n    phi_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * h)\n    phi_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * h)\n    \n    # Unit normal vector (regularized)\n    mag_grad_phi = np.sqrt(phi_x**2 + phi_y**2)\n    # Adding eta to the denominator as specified\n    denominator = mag_grad_phi + eta\n    nx = phi_x / denominator\n    ny = phi_y / denominator\n\n    # Curvature (divergence of the normal vector)\n    nx_x = (np.roll(nx, -1, axis=0) - np.roll(nx, 1, axis=0)) / (2.0 * h)\n    ny_y = (np.roll(ny, -1, axis=1) - np.roll(ny, 1, axis=1)) / (2.0 * h)\n    kappa = nx_x + ny_y\n\n    # Invariant 1: Root-mean-square curvature error (E_kappa)\n    band_mask = np.abs(phi) = eps\n    Nb = np.sum(band_mask)\n    \n    if Nb == 0:\n        E_kappa = 0.0\n    else:\n        kappa_band = kappa[band_mask]\n        kappa_exact = 1.0 / R\n        E_kappa = np.sqrt(np.mean((kappa_band - kappa_exact)**2))\n\n    # Smoothed Dirac delta function\n    delta = np.zeros_like(phi)\n    phi_band = phi[band_mask]\n    delta[band_mask] = (1.0 / (2.0 * eps)) * (1.0 + np.cos(np.pi * phi_band / eps))\n\n    # Continuum Surface Force (CSF) body force density\n    fsx = sigma * kappa * delta * nx\n    fsy = sigma * kappa * delta * ny\n\n    # Invariant 2: Net force magnitude (F_mag)\n    dA = h**2\n    Fx = np.sum(fsx) * dA\n    Fy = np.sum(fsy) * dA\n    F_mag = np.sqrt(Fx**2 + Fy**2)\n\n    return E_kappa, F_mag\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, R, sigma, alpha_x, alpha_y)\n        (128, 1.0, 0.2, 0.072, 0.0, 0.0),    # Test 1\n        (128, 1.0, 0.2, 0.072, 1.0, 0.0),    # Test 2\n        (128, 1.0, 0.2, 0.072, 0.5, 0.5),    # Test 3\n        (128, 1.0, 0.08, 0.072, 0.5, 0.0),   # Test 4\n        (64, 1.0, 0.2, 0.072, 0.5, 0.0),     # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, R, sigma, alpha_x, alpha_y = case\n        h = L / float(N)\n        \n        # Pre-translation calculation\n        cx_pre = L / 2.0\n        cy_pre = L / 2.0\n        E_kappa_pre, F_mag_pre = calculate_invariants(N, L, R, sigma, cx_pre, cy_pre)\n        \n        # Post-translation calculation\n        delta_x = alpha_x * h\n        delta_y = alpha_y * h\n        \n        # New center with periodic wrapping\n        cx_post = (cx_pre + delta_x) % L\n        cy_post = (cy_pre + delta_y) % L\n        \n        E_kappa_post, F_mag_post = calculate_invariants(N, L, R, sigma, cx_post, cy_post)\n        \n        # Compute absolute deviations\n        delta_E_kappa = np.abs(E_kappa_post - E_kappa_pre)\n        delta_F = np.abs(F_mag_post - F_mag_pre)\n        \n        results.append([delta_E_kappa, delta_F])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res_pair in results:\n        formatted_results.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3368688"}]}