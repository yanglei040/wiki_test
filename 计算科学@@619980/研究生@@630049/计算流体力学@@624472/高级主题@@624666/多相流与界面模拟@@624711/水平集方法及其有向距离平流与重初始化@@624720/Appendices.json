{"hands_on_practices": [{"introduction": "重新初始化方程 $\\partial_{\\tau} \\phi + S(\\phi_0)(|\\nabla \\phi| - 1) = 0$ 是一种哈密顿-雅可比方程。对其进行数值求解时需要特别注意，以确保稳定性和物理一致性。戈杜诺夫 (Godunov) 格式通过根据特征波的传播方向选择正确的“迎风”信息，为离散化关键项 $|\\nabla \\phi|$ 提供了一种稳健的方法。本练习 [@problem_id:3339817] 提供了一个具体的、分步的计算，旨在帮助您直观地理解戈杜诺夫格式在单个网格点上如何工作，而这正是整个重新初始化过程的基本构建模块。", "problem": "考虑一个一维均匀网格，其间距为 $\\Delta x = 0.2$，节点位置为 $x_{i-1}$、$x_i$ 和 $x_{i+1}$，以及一个旨在表示有符号距离函数的水平集函数 $\\phi$。重新初始化步骤由以下哈密顿-雅可比（Hamilton–Jacobi）型偏微分方程 (PDE) 建模：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0,\n$$\n其中 $S(\\phi_0)$ 是初始水平集 $\\phi_0$ 的平滑符号函数，$\\tau$ 是仅用于重新初始化的伪时间变量。在节点 $x_i$ 处的单边有限差分为\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}, \\qquad D_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}.\n$$\n从哈密顿-雅可比方程中数值哈密顿量的单调性要求以及从特征速度导出的迎风原理出发，推导在 $x_i$ 处 $|\\partial_x \\phi|$ 的一个 Godunov 型相容离散格式。该离散格式使用单边差分 $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$，并依赖于 $S(\\phi_0)$ 在 $x_i$ 处的符号。然后，对于给定的具体数据\n$$\n\\phi_{i-1} = 0.3, \\qquad \\phi_i = -0.1, \\qquad \\phi_{i+1} = -0.6, \\qquad \\Delta x = 0.2, \\qquad \\phi_{0,i} = 0.15,\n$$\n计算 $|\\partial_x \\phi|$ 在 $x_i$ 处的 Godunov 离散值，并确定由重新初始化 PDE 所隐含的在 $x_i$ 处的伪时间更新方向。在方向指示符中，使用 $+1$ 表示 $\\phi_i$ 相对于 $\\tau$ 增加，$-1$ 表示减少，0 表示静态更新。\n\n请将您的最终答案以单行矩阵的形式给出，其第一个条目是在 $x_i$ 处计算出的 $|\\partial_x \\phi|$ 的 Godunov 值，第二个条目是更新方向指示符。无需四舍五入。", "solution": "重新初始化 PDE\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0\n$$\n是一个哈密顿-雅可比型方程，其哈密顿量为\n$$\nH(p) = S(\\phi_0)\\left(|p| - 1\\right), \\qquad p = \\partial_x \\phi.\n$$\n对于粘性解，一个相容且单调的数值哈密顿量必须遵循由特征速度决定的迎风方向。特征速度由哈密顿量对 $p$ 的导数给出：\n$$\na(p) = \\frac{\\partial H}{\\partial p} = S(\\phi_0)\\frac{\\partial}{\\partial p}|p| = S(\\phi_0)\\,\\operatorname{sign}(p), \\quad \\text{for } p \\neq 0,\n$$\n其中 $\\operatorname{sign}(p)$ 表示符号函数。由于 $a(p)$ 依赖于（未知的）局部梯度 $p$，Godunov 数值哈密顿量根据单调性原理在容许的单边近似 $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$ 中进行选择：当 $H$ 在 $|p|$ 上非减时，离散格式在其每个自变量上必须是非减的，并且必须根据特征线的方向选择迎风差分。\n\n在一维情况下，可以通过考虑由单边斜率张成的 $p$ 的容许区间来推导 $|\\partial_x \\phi|$ 的 Godunov 选择。数值哈密顿量在此区间内寻找与单调性和迎风原理相符的 $|p|$ 的极值。在 $x_i$ 处，量值 $|\\partial_x \\phi|$ 的最终 Godunov 离散格式为\n$$\n|\\partial_x \\phi|_{\\text{G}} =\n\\begin{cases}\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^- \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^+ \\phi_i,0)\\bigr)^2\\right)},  \\text{if } S(\\phi_{0,i})  0, \\\\[1ex]\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^+ \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^- \\phi_i,0)\\bigr)^2\\right)},  \\text{if } S(\\phi_{0,i})  0, \\\\[1ex]\n0,  \\text{if } S(\\phi_{0,i}) = 0,\n\\end{cases}\n$$\n在一维情况下，这可以简化为根据 $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$ 的符号选择迎风的单边量值。具体来说，对于 $S(\\phi_{0,i})0$，\n- 如果 $D_x^- \\phi_i \\ge 0$ 且 $D_x^+ \\phi_i \\le 0$，则 $|\\partial_x \\phi|_{\\text{G}} = \\max\\!\\left(|D_x^- \\phi_i|, |D_x^+ \\phi_i|\\right)$，\n- 如果 $D_x^- \\phi_i \\ge 0$ 且 $D_x^+ \\phi_i \\ge 0$，则 $|\\partial_x \\phi|_{\\text{G}} = |D_x^- \\phi_i|$，\n- 如果 $D_x^- \\phi_i \\le 0$ 且 $D_x^+ \\phi_i \\le 0$，则 $|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i|$，\n而对于 $S(\\phi_{0,i})0$，$D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$ 的角色互换。\n\n现在，为给定数据计算单边差分：\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} = \\frac{-0.1 - 0.3}{0.2} = \\frac{-0.4}{0.2} = -2.0,\n$$\n$$\nD_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} = \\frac{-0.6 - (-0.1)}{0.2} = \\frac{-0.5}{0.2} = -2.5.\n$$\n平滑符号函数 $S(\\phi_{0,i})$ 为正，因为 $\\phi_{0,i} = 0.15  0$；任何标准的平滑符号近似（例如，对于小的 $\\varepsilon0$，$S(\\phi_{0,i}) = \\phi_{0,i}/\\sqrt{\\phi_{0,i}^2 + \\varepsilon^2}$）都会得到 $S(\\phi_{0,i})  0$。\n\n当 $S(\\phi_{0,i})  0$ 且两个单边差分均为负时，Godunov 选择简化为\n$$\n|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i| = 2.5.\n$$\n接下来，从 PDE 确定伪时间更新方向：\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,S(\\phi_{0,i})\\left(|\\partial_x \\phi|_{\\text{G}} - 1\\right).\n$$\n代入 $S(\\phi_{0,i})0$ 和 $|\\partial_x \\phi|_{\\text{G}} = 2.5$ 得\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,(2.5 - 1) = -1.5,\n$$\n结果为负。因此更新方向指示符为 $-1$（减少）。\n\n因此，所需的输出是 Godunov 量值 $2.5$ 和方向指示符 $-1$。", "answer": "$$\\boxed{\\begin{pmatrix} 2.5  -1 \\end{pmatrix}}$$", "id": "3339817"}, {"introduction": "从单个网格点的计算过渡到完整的模拟，会揭示水平集方法在实际应用中的挑战。一个著名的问题是薄结构（thin structures）的数值侵蚀，即尺寸与网格间距相当的特征可能会在重新初始化过程中被人为地破坏。这个编程练习 [@problem_id:3339798] 将指导您实现一个一维重新初始化算法，首先观察这种薄膜问题，然后实现一种“裁剪”（clipping）策略——这是一种局部禁用重新初始化以保护这些精细特征的实用技术。", "problem": "考虑一种一维水平集方法（LSM），该方法通过标量场 $\\phi(x,t)$ 的零水平集来表示界面。符号距离函数由性质 $| \\nabla \\phi | = 1$（几乎处处成立）定义，其中区域内部 $\\phi  0$，外部 $\\phi  0$。重新初始化是将一个任意的 $\\phi(x,0)$ 演化到一个满足程函方程 $| \\nabla \\phi | = 1$ 的稳态的过程，同时保持原始零水平集的拓扑结构。一种标准的重新初始化方法使用 Hamilton-Jacobi 演化方程\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S_{\\epsilon}(\\phi_0)\\, \\left(| \\nabla \\phi | - 1\\right) = 0,\n$$\n其中 $\\tau$ 是一个虚拟时间，$\\phi_0$ 是初始场，$S_{\\epsilon}$ 是根据 $\\phi_0$ 构造的平滑符号函数（例如 $S_{\\epsilon}(u) = \\frac{u}{\\sqrt{u^2+\\epsilon^2}}$）。在一个空间间距为 $h$ 的一维空间网格上，可以对 $| \\nabla \\phi |$ 使用 Godunov 迎风离散格式，并结合满足 Courant–Friedrichs–Lewy (CFL) 条件的显式时间步进。\n\n当两个界面的间隙 $g$ 与网格间距 $h$ 同量级时，重新初始化可能会错误地合并界面或侵蚀它们之间的薄膜，这是因为 $S_{\\epsilon}(\\phi_0)$ 在一个与 $h$ 相当的宽度上被正则化，导致平滑邻域重叠和数值耗散。有两种缓解方案：在网格点与两个不同界面的距离相当的模糊区域附近，对重新初始化速度进行局部裁剪；或者使用多值符号距离，该方法保留到每个界面的独立距离。\n\n您的任务是编写一个完整的程序，该程序：\n- 构建一个一维域 $x \\in [-L,L]$，该域具有 $N$ 个点的均匀网格，间距为 $h$。\n- 构建一个初始符号距离场 $\\phi_0(x)$，它表示一个由两个对称放置在 $x=-g/2$ 和 $x=+g/2$ 的界面所界定的薄膜，薄膜内部 $\\phi_0(x)  0$，外部 $\\phi_0(x)  0$，且 $\\phi_0$ 等于到最近界面的符号距离。\n- 在虚拟时间 $\\tau$ 中，使用显式欧拉时间步进方法演化 $\\phi$，并采用上述在一维空间中使用 Godunov 迎风格式的重新初始化方程：\n  - 对每个网格索引 $i$，定义单边差分 $D^+ \\phi_i = \\frac{\\phi_{i+1}-\\phi_i}{h}$ 和 $D^- \\phi_i = \\frac{\\phi_i-\\phi_{i-1}}{h}$。对于边界，在需要时通过复制边界值来施加齐次 Neumann 边界条件。\n  - 对每个 $i$，计算 \n    $$\n    G_i = \n    \\begin{cases}\n    \\sqrt{\\max\\left(\\max(D^- \\phi_i, 0)^2, \\min(D^+ \\phi_i, 0)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i}) > 0,\\\\\n    \\sqrt{\\max\\left(\\max(D^+ \\phi_i, 0)^2, \\min(D^- \\phi_i, 0)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i})  0,\\\\\n    0  \\text{if } S_{\\epsilon}(\\phi_{0,i}) = 0,\n    \\end{cases}\n    $$\n    并更新 \n    $$\n    \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right).\n    $$\n- 实现一种局部裁剪策略，该策略在一个网格点与两个界面几乎等距的地方抑制重新初始化：令 $x_L$ 和 $x_R$ 表示从 $\\phi_0$ 初始化的两个界面位置（通过子单元零点穿越检测找到）。对每个网格点 $x_i$，定义距离 $d_L = | x_i - x_L |$ 和 $d_R = | x_i - x_R |$，以及接近度度量 $c_i = | d_L - d_R |$。引入一个由下式定义的权重 $w_i \\in \\{0,1\\}$\n  $$\n  w_i = \\begin{cases}\n  0  \\text{if } c_i  \\beta\\, h,\\\\\n  1  \\text{otherwise},\n  \\end{cases}\n  $$\n  并在更新中用 $w_i\\, S_{\\epsilon}(\\phi_{0,i})$ 替换 $S_{\\epsilon}(\\phi_{0,i})$。这可以在两个界面在网格尺度上过于接近而无法区分的区域局部冻结重新初始化。将 $\\beta$ 视为一个固定常数。\n- 在指定步数的重新初始化之后，测量两个诊断量：\n  - 通过相邻网格点之间的符号变化检测到的零点穿越数量，该数量通过线性插值计算到子单元位置。这量化了两个界面是否持续存在。\n  - 薄膜厚度，定义为包围 $x=0$ 的两个零点穿越位置之间的距离。如果找到的穿越点少于两个，则报告薄膜厚度为 $0$。\n\n对所有测试使用以下固定的数值参数：\n- 域半长 $L = 1$ (无量纲)。\n- 网格点数 $N = 801$ (以使域包含 $x=0$）。\n- 网格间距 $h = \\frac{2L}{N-1}$ (无量纲)。\n- 重新初始化平滑参数 $\\epsilon = \\alpha h$，其中 $\\alpha = 1.5$ (无量纲)。\n- 时间步长 $\\Delta \\tau = 0.3 h$ (无量纲)，以满足 Courant–Friedrichs–Lewy 数。\n- 重新初始化步数 $N_{\\tau} = 300$。\n- 裁剪阈值因子 $\\beta = 1$。\n\n测试套件：\n- 情况 A (理想情况): $g/h = 3.0$。\n- 情况 B (临界情况): $g/h = 1.0$。\n- 情况 C (边缘情况): $g/h = 0.5$。\n\n对于每种情况，从相同的 $\\phi_0$ 开始运行两次重新初始化：一次使用基准方案，另一次启用裁剪策略。对于每次运行，报告：\n- $g/h$ (浮点数),\n- 基准方案的零点穿越计数 (整数),\n- 基准方案的薄膜厚度除以 $h$ (浮点数),\n- 裁剪方案的零点穿越计数 (整数),\n- 裁剪方案的薄膜厚度除以 $h$ (浮点数)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素对应一种情况。每个元素都必须是按上述顺序排列的五个值的列表，例如\n  $$\n  \\left[ [g/h, z_{\\text{base}}, t_{\\text{base}}/h, z_{\\text{clip}}, t_{\\text{clip}}/h], \\ \\ldots \\right].\n  $$\n- 所有量均按定义为无量纲量，因此不需要物理单位。", "solution": "用户提供了一个有效的问题陈述。\n\n### 水平集重新初始化简介\n\n水平集方法（LSM）是一种强大的数值技术，用于追踪演化中的界面和形状，广泛应用于计算流体动力学、计算机图形学和材料科学等领域。其核心思想是将界面 $\\Gamma$ 表示为更高维标量函数 $\\phi(\\mathbf{x}, t)$ 的零水平集，即 $\\Gamma(t) = \\{ \\mathbf{x} \\mid \\phi(\\mathbf{x}, t) = 0 \\}$。按照惯例，界面所包围的区域内部 $\\phi  0$，外部 $\\phi > 0$。\n\n为保证数值稳定性和准确性，非常理想的情况是让 $\\phi$ 成为一个满足程函方程 $|\\nabla \\phi| = 1$ 的符号距离函数（SDF）。然而，在界面演化过程中，$\\phi$ 场可能会变得扭曲，从而失去 SDF 的性质。重新初始化是一个关键步骤，它将 $\\phi$ 重塑为 SDF，同时保持零水平集（$\\phi=0$）不变。这通常通过求解一个 Hamilton-Jacobi 方程直到达到稳态来实现：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0) \\left( |\\nabla \\phi| - 1 \\right) = 0\n$$\n在这里，$\\tau$ 是重新初始化过程的一个虚拟时间变量。$S(\\phi_0)$ 是从重新初始化前的初始扭曲场 $\\phi_0$ 导出的符号函数。它确保演化朝着正确的方向进行（即使 $|\\nabla \\phi|$ 更接近于 1），而不会移动零水平集。为避免奇异点，使用了平滑符号函数，例如 $S_{\\epsilon}(\\phi_0) = \\frac{\\phi_0}{\\sqrt{\\phi_0^2 + \\epsilon^2}}$，其中 $\\epsilon$ 是一个通常与网格间距 $h$ 同量级的小参数。\n\n### 数值离散化\n\n重新初始化方程在离散网格上求解。我们考虑一个一维域 $x \\in [-L, L]$，它有 $N$ 个均匀分布的网格点 $x_i$，间距为 $h = \\frac{2L}{N-1}$。\n\n- **时间离散化**：使用显式前向欧拉法在虚拟时间 $\\tau$ 中推进：\n  $$\n  \\frac{\\phi_i^{n+1} - \\phi_i^n}{\\Delta \\tau} = -S_{\\epsilon}(\\phi_{0,i}) \\left( |\\nabla \\phi|_i - 1 \\right)\n  $$\n  其中 $\\Delta \\tau$ 是时间步长，其选择要足够小以满足 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n- **空间离散化**：非线性项 $|\\nabla \\phi|$ 需要一个适用于 Hamilton-Jacobi 方程的、谨慎选择的迎风离散格式。Godunov 格式是一个标准选择。在一维中，它由下式给出：\n  $$\n  |\\nabla \\phi|_i \\approx G_i =\n  \\begin{cases}\n  \\sqrt{\\max\\left(\\left(\\max(D^- \\phi_i, 0)\\right)^2, \\left(\\min(D^+ \\phi_i, 0)\\right)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i}) > 0 \\\\\n  \\sqrt{\\max\\left(\\left(\\max(D^+ \\phi_i, 0)\\right)^2, \\left(\\min(D^- \\phi_i, 0)\\right)^2\\right)}  \\text{if } S_{\\epsilon}(\\phi_{0,i})  0 \\\\\n  0  \\text{if } S_{\\epsilon}(\\phi_{0,i}) = 0\n  \\end{cases}\n  $$\n  其中 $D^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{h}$ 和 $D^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{h}$ 分别是前向和后向有限差分。在域边界上施加齐次 Neumann 边界条件（$\\frac{\\partial\\phi}{\\partial x}=0$）。\n\n因此，网格点 $\\phi_i$ 从时间步 $n$ 到 $n+1$ 的完整更新公式为：\n$$\n\\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right)\n$$\n\n### 薄膜问题与数值侵蚀\n\nLSM 中的一个已知挑战是表示厚度与网格间距相当的薄结构。在这个问题中，我们模拟一个厚度为 $g$、对称放置在 $x=0$ 周围的薄膜。初始场 $\\phi_0(x)$ 被构造为到位于 $x = -g/2$ 和 $x = +g/2$ 的界面的真实符号距离函数。\n\n当 $g$ 与 $h$ 同量级时，标准的重新初始化会导致数值误差。平滑符号函数 $S_{\\epsilon}(\\phi_0)$ 有一个宽度与 $\\epsilon = \\alpha h$ 成正比的过渡区域。如果薄膜太薄，来自左界面的平滑效应可能与来自右界面的平滑效应重叠。这会在薄膜中心附近的符号项 $S_{\\epsilon}(\\phi_0)$ 中产生模糊性，导致不正确的演化，并使两个界面合并或薄膜被“侵蚀”，从而有效地破坏该特征。\n\n### 裁剪缓解策略\n\n为了对抗这种侵蚀，引入了一种局部裁剪策略。其核心思想是在网格过于粗糙以至于无法明确确定最近界面的区域抑制重新初始化。\n\n1. 通过检测初始场 $\\phi_0$ 的零点穿越，找到初始界面位置 $x_L$ 和 $x_R$。\n2. 对于每个网格点 $x_i$，我们计算它到左界面和右界面的距离，$d_L = |x_i - x_L|$ 和 $d_R = |x_i - x_R|$。\n3. 定义一个“接近度度量” $c_i = |d_L - d_R|$。较小的 $c_i$ 值表示 $x_i$ 与两个界面的距离几乎相等。这就是模糊区域。\n4. 基于阈值 $\\beta h$ 定义一个二元权重 $w_i$：\n   $$\n   w_i = \\begin{cases}\n   0  \\text{if } c_i  \\beta h \\\\\n   1  \\text{otherwise}\n   \\end{cases}\n   $$\n5. 这个权重通过乘以符号项来修改更新规则，在 $w_i=0$ 的地方有效地“裁剪”或冻结重新初始化速度：\n   $$\n   \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, \\left(w_i S_{\\epsilon}(\\phi_{0,i})\\right)\\, \\left(G_i - 1\\right)\n   $$\n这种策略选择性地应用重新初始化，从而在欠解析区域保护薄膜的完整性。\n\n### 仿真与评估\n\n该程序实现了基准和裁剪的重新初始化方案。它为三种不同的薄膜厚度与网格间距之比 $g/h$ 初始化一个薄膜。在固定的重新初始化步数（$N_{\\tau}=300$）之后，计算两个诊断量：\n- 零点穿越的数量，它表明两个界面是已经合并成一个还是已经消失。\n- 薄膜厚度，测量为包围原点的两个零点穿越之间的距离，它量化了薄膜侵蚀的程度。\n\n通过比较基准方案和裁剪方案的结果，评估了该缓解策略在不同薄膜解析度水平下的有效性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D level set reinitialization problem for a thin film,\n    comparing a baseline scheme with a local clipping mitigation strategy.\n    \"\"\"\n\n    # Define the fixed numerical parameters from the problem statement.\n    L = 1.0\n    N = 801\n    h = 2 * L / (N - 1)\n    alpha = 1.5\n    epsilon = alpha * h\n    dt = 0.3 * h\n    N_tau = 300\n    beta = 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        3.0,  # Case A: g/h = 3.0\n        1.0,  # Case B: g/h = 1.0\n        0.5,  # Case C: g/h = 0.5\n    ]\n    \n    # Grid setup\n    x = np.linspace(-L, L, N, dtype=np.float64)\n    \n    results = []\n\n    def find_zero_crossings(x_grid, phi_field):\n        \"\"\"Finds subcell zero-crossing locations using linear interpolation.\"\"\"\n        crossings = []\n        # Find indices where sign changes\n        indices = np.where(phi_field[:-1] * phi_field[1:]  0)[0]\n        for i in indices:\n            phi_i, phi_i1 = phi_field[i], phi_field[i+1]\n            x_i, x_i1 = x_grid[i], x_grid[i+1]\n            # Linear interpolation formula for zero crossing\n            x_cross = x_i - phi_i * (x_i1 - x_i) / (phi_i1 - phi_i)\n            crossings.append(x_cross)\n        return sorted(crossings)\n\n    def calculate_diagnostics(crossings, h_spacing):\n        \"\"\"Calculates number of crossings and film thickness.\"\"\"\n        num_crossings = len(crossings)\n        \n        neg_crossings = [c for c in crossings if c = 0]\n        pos_crossings = [c for c in crossings if c > 0]\n        \n        thickness = 0.0\n        if neg_crossings and pos_crossings:\n            thickness = min(pos_crossings) - max(neg_crossings)\n            \n        return num_crossings, thickness / h_spacing\n\n    for gh_ratio in test_cases:\n        g = gh_ratio * h\n\n        # Build initial signed distance field phi_0\n        dist = np.minimum(np.abs(x + g / 2.0), np.abs(x - g / 2.0))\n        sign_field = np.ones_like(x)\n        sign_field[(x > -g / 2.0)  (x  g / 2.0)] = -1.0\n        phi0 = dist * sign_field\n\n        # Pre-compute the smoothed sign of the initial field\n        s_phi0 = phi0 / np.sqrt(phi0**2 + epsilon**2)\n\n        case_results = [gh_ratio]\n\n        # --- Run simulation for both baseline and clipped schemes ---\n        for use_clipping in [False, True]:\n            phi = phi0.copy()\n            \n            w = np.ones(N) # Default weights (no clipping)\n            if use_clipping:\n                # Calculate clipping weights\n                initial_crossings = find_zero_crossings(x, phi0)\n                if len(initial_crossings) >= 2:\n                    x_L, x_R = initial_crossings[0], initial_crossings[-1]\n                else: # Fallback for unexpected cases\n                    x_L, x_R = -g/2.0, g/2.0\n                \n                d_L = np.abs(x - x_L)\n                d_R = np.abs(x - x_R)\n                c = np.abs(d_L - d_R)\n                w[c  beta * h] = 0.0\n\n            # Evolve in fictitious time\n            for _ in range(N_tau):\n                # Enforce homogeneous Neumann boundary conditions via padding\n                padded_phi = np.pad(phi, 1, 'edge')\n                \n                # Compute one-sided differences\n                diffs = np.diff(padded_phi) / h\n                dm = diffs[:-1]\n                dp = diffs[1:]\n                \n                # Compute Godunov upwind scheme for |nabla phi|\n                grad_phi_sq = np.zeros(N)\n                \n                idx_pos = s_phi0 > 0\n                idx_neg = s_phi0  0\n                \n                grad_phi_sq[idx_pos] = np.maximum(np.maximum(dm[idx_pos], 0)**2, np.minimum(dp[idx_pos], 0)**2)\n                grad_phi_sq[idx_neg] = np.maximum(np.maximum(dp[idx_neg], 0)**2, np.minimum(dm[idx_neg], 0)**2)\n                \n                G = np.sqrt(grad_phi_sq)\n                \n                # Update phi\n                update_term = s_phi0\n                if use_clipping:\n                    update_term *= w\n                \n                phi -= dt * update_term * (G - 1)\n\n            # Calculate and store diagnostics for this run\n            final_crossings = find_zero_crossings(x, phi)\n            z_count, t_h_ratio = calculate_diagnostics(final_crossings, h)\n            case_results.extend([z_count, t_h_ratio])\n            \n        results.append(case_results)\n\n    # Format the final output string to be exactly as specified, without spaces\n    formatted_sublists = []\n    for sublist in results:\n        # Format: g/h (float), z_base (int), t_base/h (float), z_clip (int), t_clip/h (float)\n        # Ensure correct types for formatting\n        formatted_items = [\n            f\"{sublist[0]:.1f}\",\n            str(int(sublist[1])),\n            f\"{sublist[2]:.6f}\",\n            str(int(sublist[3])),\n            f\"{sublist[4]:.6f}\"\n        ]\n        formatted_sublists.append(f\"[{','.join(formatted_items)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3339798"}, {"introduction": "尽管标准的重新初始化能够恢复符号距离属性，但它并不能严格保证零水平集所包围的面积守恒，这会在长时间的模拟中导致累积误差。为了解决这个问题，我们可以将重新初始化表述为一个约束问题，通过添加一个修正项来强制实现面积守恒。这个高级实践 [@problem_id:3339771] 将挑战您在二维情况下推导并实现这样一种改进的、面积守恒的格式，并用数值方法验证其相比于标准方法所具有的更优越的收敛特性。", "problem": "考虑一个移动界面的二维水平集表示，该表示由标量场 $\\phi(x,y,t)$ 定义，其中界面是零水平集 $\\Gamma(t) = \\{(x,y) \\mid \\phi(x,y,t) = 0\\}$。在给定速度场 $\\mathbf{u}(x,y,t)$ 下，$\\phi$ 的平流遵循守恒律 $\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0$。为了保持数值稳定性和几何保真度，通常通过求解一个 Hamilton-Jacobi 型方程，在伪时间 $\\tau$ 内周期性地将 $\\phi$ 重新初始化为一个符号距离函数。一种标准的重新初始化方法根据伪时间动力学演化 $\\phi$：\n$$\n\\partial_\\tau \\phi + S_\\epsilon(\\phi_0)\\left(| \\nabla \\phi| - 1\\right) = 0,\n$$\n其中 $\\phi_0(x,y)$ 是在重新初始化开始时冻结的水平集场的快照，$S_\\epsilon(\\phi_0)$ 是一个平滑符号函数，$\\epsilon0$ 是一个小的正则化参数。\n\n然而，重新初始化可能会伪性地改变演化界面围成的面积 $A(\\tau)$（以及界面长度 $L(\\tau)$）。为减少此类人为影响，构建一种改进的重新初始化方法，该方法强制施加积分约束：\n$$\n\\int_{\\Omega} \\delta_\\epsilon(\\phi)\\,\\partial_\\tau \\phi\\,dx\\,dy = 0,\n$$\n其中 $\\delta_\\epsilon(\\phi)$ 是一个平滑狄拉克δ函数，用于将计算局部化在界面附近，$\\Omega$ 是计算域。假设修正项的形式为\n$$\n\\partial_\\tau \\phi + S_\\epsilon(\\phi_0)\\big(| \\nabla \\phi| - 1\\big) = \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi),\n$$\n并推导标量拉格朗日乘子 $\\lambda(\\tau)$ 的表达式，以确保所述积分约束在所有伪时间 $\\tau$ 内都成立。使用以下正则化形式：\n$$\nS_\\epsilon(\\phi) = \\frac{\\phi}{\\sqrt{\\phi^2+\\epsilon^2}},\\quad \\delta_\\epsilon(\\phi) = \\frac{1}{\\pi}\\frac{\\epsilon}{\\phi^2+\\epsilon^2},\\quad H_\\epsilon(\\phi) = \\frac{1}{2}\\left(1+\\frac{2}{\\pi}\\arctan\\left(\\frac{\\phi}{\\epsilon}\\right)\\right),\n$$\n其中 $H_\\epsilon(\\phi)$ 是平滑亥维赛德函数。围成的面积可计算为 $A(\\tau)=\\int_{\\Omega}\\left(1-H_\\epsilon(\\phi)\\right)\\,dx\\,dy$。\n\n在周期性方形域 $\\Omega=[-1,1)\\times[-1,1)$ 上实现一个显式有限差分求解器，该求解器使用具有 $N\\times N$ 个点的网格中心网格和均匀间距 $h=2/N$。在物理时间平流步中，对空间导数使用一阶迎风格式离散化；在伪时间重新初始化中，对梯度模长使用二阶中心差分。速度场是径向的：\n$$\n\\mathbf{u}(x,y) = \\kappa\\,(x,y),\n$$\n其中 $\\kappa$ 是一个常数。选择一个满足 Courant–Friedrichs–Lewy 型稳定性限制的物理时间步长 $\\Delta t$。使用伪时间步长 $\\Delta \\tau = 0.1\\,h$，并在每次重新初始化调用中执行 $M$ 个重新初始化步骤。使用通过数组滚动实现的周期性边界条件。\n\n你的程序必须：\n\n1. 根据下文规定，为每个测试用例初始化 $\\phi$。\n2. 如果初始 $\\phi$ 不是一个符号距离函数，则在进行物理平流之前，执行初步的标准重新初始化以近似一个符号距离场。\n3. 在 $\\mathbf{u}(x,y)$ 作用下，将 $\\phi$ 平流一个物理时间步。\n4. 平流后立即使用平滑亥维赛德函数计算围成的面积 $A_{\\text{pre}}$。\n5. 从平流后的场开始，应用标准重新初始化（不带修正项）$M$ 步，并计算 $A_{\\text{post,std}}$，然后计算漂移 $E_{\\text{std}}=\\lvert A_{\\text{post,std}}-A_{\\text{pre}}\\rvert$。\n6. 从相同的平流后的场开始，应用改进的重新初始化（带有推导出的 $\\lambda(\\tau)$ 项）$M$ 步，并计算 $A_{\\text{post,mod}}$，然后计算漂移 $E_{\\text{mod}}=\\lvert A_{\\text{post,mod}}-A_{\\text{pre}}\\rvert$。\n7. 对同一测试用例的两种分辨率 $N_{\\text{coarse}}$ 和 $N_{\\text{fine}}$ 重复步骤1-6，并报告漂移的比率 $R_{\\text{mod}}=\\dfrac{E_{\\text{mod}}^{\\text{coarse}}}{E_{\\text{mod}}^{\\text{fine}}}$ 和 $R_{\\text{std}}=\\dfrac{E_{\\text{std}}^{\\text{coarse}}}{E_{\\text{std}}^{\\text{fine}}}$。\n\n设计测试套件以检验收缩和扩张的形状：\n\n- 测试用例1（扩张的圆形）：$N_{\\text{coarse}}=64$，$N_{\\text{fine}}=128$，初始圆形半径 $r_0=0.3$，$\\kappa=0.5$，$\\Delta t=0.01$，$\\epsilon=1.5h$，$M=40$；初始化 $\\phi(x,y)=\\sqrt{x^2+y^2}-r_0$。\n- 测试用例2（收缩的圆形）：$N_{\\text{coarse}}=64$，$N_{\\text{fine}}=128$，初始圆形半径 $r_0=0.4$，$\\kappa=-0.5$，$\\Delta t=0.01$，$\\epsilon=1.5h$，$M=40$；初始化 $\\phi(x,y)=\\sqrt{x^2+y^2}-r_0$。\n- 测试用例3（扩张的椭圆，非符号距离函数初始化）：$N_{\\text{coarse}}=64$，$N_{\\text{fine}}=128$，半轴 $a=0.6, b=0.3$，$\\kappa=0.4$，$\\Delta t=0.01$，$\\epsilon=1.5h$，初步重新初始化 $M_{\\text{pre}}=60$，主重新初始化 $M=40$；初始化 $\\phi(x,y)=\\sqrt{(x/a)^2+(y/b)^2}-1$。\n\n对于每个测试用例，计算如上定义的 $R_{\\text{mod}}$ 和 $R_{\\text{std}}$。改进方法的期望标度行为是，当网格间距 $h$ 减半时，$R_{\\text{mod}}\\approx 4$（反映了 $\\mathcal{O}(h^2)$ 的误差减小），而标准方法可能无法达到这种标度行为。你的程序应生成单行输出，包含三个测试用例的六个比率，形式为方括号内以逗号分隔的列表：\n\"[R_mod_case1,R_std_case1,R_mod_case2,R_std_case2,R_mod_case3,R_std_case3]\"。\n所有报告值必须为无量纲单位，并以 Python 浮点数形式打印。", "solution": "该问题要求在水平集方法中，为一种保持面积的重新初始化方案推导拉格朗日乘子 $\\lambda(\\tau)$，然后通过数值实现来比较这种改进方案与标准方案的性能。\n\n### 第一部分：拉格朗日乘子 $\\lambda(\\tau)$ 的推导\n\n目标是施加面积净变化为零的积分约束，该约束通过平滑狄拉克δ函数 $\\delta_\\epsilon(\\phi)$ 局部化在界面附近。约束由下式给出：\n$$\n\\int_{\\Omega} \\delta_\\epsilon(\\phi)\\,\\partial_\\tau \\phi\\,dx\\,dy = 0\n$$\n所提出的改进重新初始化方程是一个带有与 $\\lambda(\\tau)$ 成比例的修正项的 Hamilton-Jacobi 方程：\n$$\n\\partial_\\tau \\phi + S_\\epsilon(\\phi_0)\\left(| \\nabla \\phi| - 1\\right) = \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi)\n$$\n此处，$\\phi_0$ 是重新初始化过程开始时（$\\tau=0$）的水平集场，$S_\\epsilon(\\phi_0)$ 是一个平滑符号函数，它决定了为恢复符号距离属性而演化的方向（向内或向外）。\n\n为推导 $\\lambda(\\tau)$，我们首先从改进的重新初始化方程中解出 $\\partial_\\tau \\phi$：\n$$\n\\partial_\\tau \\phi = -S_\\epsilon(\\phi_0)\\left(| \\nabla \\phi| - 1\\right) + \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi)\n$$\n接下来，我们将 $\\partial_\\tau \\phi$ 的这个表达式代入积分约束中：\n$$\n\\int_{\\Omega} \\delta_\\epsilon(\\phi) \\left( -S_\\epsilon(\\phi_0)\\left(| \\nabla \\phi| - 1\\right) + \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi) \\right) \\,dx\\,dy = 0\n$$\n由于线性关系，该积分可以分为两项：\n$$\n-\\int_{\\Omega} \\delta_\\epsilon(\\phi) S_\\epsilon(\\phi_0)\\left(| \\nabla \\phi| - 1\\right) \\,dx\\,dy + \\int_{\\Omega} \\lambda(\\tau) \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy = 0\n$$\n拉格朗日乘子 $\\lambda(\\tau)$ 仅是伪时间 $\\tau$ 的函数，并且相对于空间变量 $(x,y)$ 是常数。因此，可以将其从第二个积分中提出：\n$$\n-\\int_{\\Omega} \\delta_\\epsilon(\\phi) S_\\epsilon(\\phi_0)\\left(| \\nabla \\phi| - 1\\right) \\,dx\\,dy + \\lambda(\\tau) \\int_{\\Omega} \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy = 0\n$$\n最后，我们重新整理方程以求解 $\\lambda(\\tau)$：\n$$\n\\lambda(\\tau) \\int_{\\Omega} \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy = \\int_{\\Omega} S_\\epsilon(\\phi_0) \\delta_\\epsilon(\\phi) \\left(| \\nabla \\phi| - 1\\right) \\,dx\\,dy\n$$\n这给出了拉格朗日乘子的显式表达式：\n$$\n\\lambda(\\tau) = \\frac{\\int_{\\Omega} S_\\epsilon(\\phi_0) \\delta_\\epsilon(\\phi) \\left(| \\nabla \\phi| - 1\\right) \\,dx\\,dy}{\\int_{\\Omega} \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy}\n$$\n在离散的数值设置中，积分被替换为对所有网格单元的求和，微分面积元素 $dx\\,dy$ 变为常数网格单元面积 $h^2$，该面积在分子和分母中被约去。\n\n### 第二部分：数值实现策略\n\n数值解是基于周期域上的有限差分法实现的。\n\n**1. 网格与初始化：** 在 $\\Omega=[-1,1)\\times[-1,1)$ 上定义一个二维网格中心网格，包含 $N \\times N$ 个点，网格间距为 $h=2/N$。对于 $i,j \\in \\{0, \\dots, N-1\\}$，坐标 $(x_i, y_j)$ 由 $x_i = -1 + (i+0.5)h$ 和 $y_j = -1 + (j+0.5)h$ 给出。水平集场 $\\phi$ 根据每个测试用例的规范在此网格上初始化。\n\n**2. 平流步：** 平流方程 $\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0$ 使用显式欧拉法求解一个时间步长 $\\Delta t$。空间项 $\\mathbf{u}\\cdot\\nabla \\phi$ 使用一阶迎风格式进行离散化以确保稳定性。对于速度分量 $u_x(i,j)$，如果 $u_x(i,j) > 0$，则用后向差分近似导数 $\\partial_x \\phi$；如果 $u_x(i,j)  0$，则用前向差分。类似逻辑适用于 $y$ 方向。周期性边界条件通过数组滚动（例如 `numpy.roll`）来处理，它正确地实现了空间差分的环绕逻辑。\n\n**3. 重新初始化步：** 标准和改进的重新初始化都以伪时间步长 $\\Delta \\tau = 0.1h$ 执行 $M$ 步。用于 $S_\\epsilon(\\phi_0)$ 项的场 $\\phi_0$ 是平流后的场，在整个重新初始化过程中保持不变。\n- **梯度计算：** 梯度模长 $| \\nabla \\phi |$ 使用二阶中心差分计算 $\\partial_x \\phi$ 和 $\\partial_y \\phi$。对于单元格 $(i,j)$，$\\partial_x \\phi \\approx (\\phi_{i+1,j} - \\phi_{i-1,j})/(2h)$。\n- **标准重新初始化：** 使用显式欧拉步更新场 $\\phi$：\n  $$\n  \\phi^{n+1} = \\phi^n - \\Delta \\tau \\left[ S_\\epsilon(\\phi_0) \\left(| \\nabla \\phi^n | - 1\\right) \\right]\n  $$\n- **改进的重新初始化：** 在每个伪时间步，首先计算 $\\lambda(\\tau)$。离散版本是所有网格单元 $(i,j)$ 上的和：\n  $$\n  \\lambda^n = \\frac{\\sum_{i,j} S_\\epsilon(\\phi_{0,ij}) \\delta_\\epsilon(\\phi_{ij}^n) \\left(| \\nabla \\phi_{ij}^n | - 1\\right)}{\\sum_{i,j} \\left[\\delta_\\epsilon(\\phi_{ij}^n)\\right]^2}\n  $$\n  然后，更新场 $\\phi$：\n  $$\n  \\phi^{n+1} = \\phi^n - \\Delta \\tau \\left[ S_\\epsilon(\\phi_0) \\left(| \\nabla \\phi^n | - 1\\right) - \\lambda^n \\delta_\\epsilon(\\phi^n) \\right]\n  $$\n  对于情况3，在主平流-重新初始化循环开始之前，会执行 $M_{\\text{pre}}$ 步的初步标准重新初始化，以将初始的非符号距离函数转换为近似的符号距离函数。\n\n**4. 面积计算与误差度量：** 围成的面积通过在域上积分平滑特征函数 $\\left(1 - H_\\epsilon(\\phi)\\right)$ 来计算：\n$$\nA = \\sum_{i,j} \\left(1 - H_\\epsilon(\\phi_{ij})\\right) h^2\n$$\n每种方法的面积漂移 $E$ 是重新初始化后的面积（$A_{\\text{post}}$）与平流后、重新初始化前的面积（$A_{\\text{pre}}$）之间的绝对差。最终报告的量是这些漂移在粗网格和细网格之间的比率，$R = E^{\\text{coarse}}/E^{\\text{fine}}$。\n\n这种系统性的方法可以对标准和改进的重新初始化方案的面积守恒特性进行定量比较，检验改进方案性能更优的假设，理想情况下，面积误差的二阶收敛率将反映为比率 $R_{\\text{mod}} \\approx 4$。", "answer": "```python\nimport numpy as np\n\ndef S_epsilon(phi, epsilon):\n    \"\"\"Smoothed sign function.\"\"\"\n    return phi / np.sqrt(phi**2 + epsilon**2)\n\ndef delta_epsilon(phi, epsilon):\n    \"\"\"Smoothed Dirac delta function.\"\"\"\n    return (1.0 / np.pi) * epsilon / (phi**2 + epsilon**2)\n\ndef H_epsilon(phi, epsilon):\n    \"\"\"Smoothed Heaviside function.\"\"\"\n    return 0.5 * (1.0 + (2.0 / np.pi) * np.arctan(phi / epsilon))\n\ndef calculate_area(phi, h, epsilon):\n    \"\"\"Computes the enclosed area using the smoothed Heaviside function.\"\"\"\n    area = np.sum(1.0 - H_epsilon(phi, epsilon)) * h**2\n    return area\n\ndef get_grad_mag(phi, h):\n    \"\"\"Computes gradient magnitude using second-order central differences.\"\"\"\n    # Periodic boundary conditions are handled by np.roll\n    phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * h)\n    phi_y = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * h)\n    grad_mag = np.sqrt(phi_x**2 + phi_y**2)\n    return grad_mag\n\ndef advect_step(phi, dt, h, kappa, xx, yy):\n    \"\"\"Performs one advection step using first-order upwind scheme.\"\"\"\n    u = kappa * xx\n    v = kappa * yy\n\n    # First-order differences (forward and backward)\n    phi_dx_fwd = (np.roll(phi, -1, axis=1) - phi) / h\n    phi_dx_bwd = (phi - np.roll(phi, 1, axis=1)) / h\n    phi_dy_fwd = (np.roll(phi, -1, axis=0) - phi) / h\n    phi_dy_bwd = (phi - np.roll(phi, 1, axis=0)) / h\n\n    # Upwind scheme based on velocity sign\n    u_pos = np.maximum(u, 0)\n    u_neg = np.minimum(u, 0)\n    v_pos = np.maximum(v, 0)\n    v_neg = np.minimum(v, 0)\n\n    grad_phi_upwind = (u_pos * phi_dx_bwd + u_neg * phi_dx_fwd +\n                       v_pos * phi_dy_bwd + v_neg * phi_dy_fwd)\n\n    return phi - dt * grad_phi_upwind\n\ndef reinitialize(phi_start, M, h, epsilon, method):\n    \"\"\"Performs reinitialization for M steps.\"\"\"\n    dtau = 0.1 * h\n    phi = phi_start.copy()\n\n    # The problem freezes phi_0 at the start of reinitialization\n    phi_0_reinit = phi_start.copy()\n    S_phi0 = S_epsilon(phi_0_reinit, epsilon)\n\n    for _ in range(M):\n        grad_mag = get_grad_mag(phi, h)\n        non_corrected_term = S_phi0 * (grad_mag - 1.0)\n        \n        if method == 'standard':\n            phi -= dtau * non_corrected_term\n        elif method == 'modified':\n            delta_phi = delta_epsilon(phi, epsilon)\n            \n            numerator = np.sum(delta_phi * non_corrected_term)\n            denominator = np.sum(delta_phi**2)\n            \n            # Avoid division by zero, though unlikely\n            lambda_val = numerator / denominator if denominator != 0 else 0.0\n            \n            phi -= dtau * (non_corrected_term - lambda_val * delta_phi)\n            \n    return phi\n\ndef run_simulation(N, init_phi_func, kappa, dt, m_steps, m_pre_steps=0):\n    \"\"\"Runs one full simulation for a given resolution and returns area drifts.\"\"\"\n    h = 2.0 / N\n    epsilon = 1.5 * h\n\n    # Create a cell-centered grid\n    grid_coords = np.linspace(-1.0 + 0.5 * h, 1.0 - 0.5 * h, N)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n\n    phi = init_phi_func(xx, yy)\n\n    # Preliminary reinitialization for non-SDF cases (Test Case 3)\n    if m_pre_steps > 0:\n        phi = reinitialize(phi, m_pre_steps, h, epsilon, 'standard')\n\n    # 1. Advect for one physical time step\n    phi_advected = advect_step(phi, dt, h, kappa, xx, yy)\n\n    # 2. Compute pre-reinitialization area\n    area_pre = calculate_area(phi_advected, h, epsilon)\n\n    # 3. Standard reinitialization and compute drift\n    phi_post_std = reinitialize(phi_advected, m_steps, h, epsilon, 'standard')\n    area_post_std = calculate_area(phi_post_std, h, epsilon)\n    E_std = np.abs(area_post_std - area_pre)\n\n    # 4. Modified reinitialization and compute drift\n    phi_post_mod = reinitialize(phi_advected, m_steps, h, epsilon, 'modified')\n    area_post_mod = calculate_area(phi_post_mod, h, epsilon)\n    E_mod = np.abs(area_post_mod - area_pre)\n\n    return E_std, E_mod\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1: Expanding circle\n        {'kappa': 0.5, 'dt': 0.01, 'm_steps': 40, 'm_pre_steps': 0,\n         'init_func': lambda x, y, r0=0.3: np.sqrt(x**2 + y**2) - r0},\n        # Case 2: Shrinking circle\n        {'kappa': -0.5, 'dt': 0.01, 'm_steps': 40, 'm_pre_steps': 0,\n         'init_func': lambda x, y, r0=0.4: np.sqrt(x**2 + y**2) - r0},\n        # Case 3: Expanding ellipse\n        {'kappa': 0.4, 'dt': 0.01, 'm_steps': 40, 'm_pre_steps': 60,\n         'init_func': lambda x, y, a=0.6, b=0.3: np.sqrt((x/a)**2 + (y/b)**2) - 1.0}\n    ]\n\n    N_coarse, N_fine = 64, 128\n    results = []\n\n    for case in test_cases:\n        # Run coarse simulation\n        E_std_coarse, E_mod_coarse = run_simulation(\n            N=N_coarse,\n            init_phi_func=case['init_func'],\n            kappa=case['kappa'],\n            dt=case['dt'],\n            m_steps=case['m_steps'],\n            m_pre_steps=case['m_pre_steps']\n        )\n        \n        # Run fine simulation\n        E_std_fine, E_mod_fine = run_simulation(\n            N=N_fine,\n            init_phi_func=case['init_func'],\n            kappa=case['kappa'],\n            dt=case['dt'],\n            m_steps=case['m_steps'],\n            m_pre_steps=case['m_pre_steps']\n        )\n\n        # Calculate ratios\n        R_mod = E_mod_coarse / E_mod_fine if E_mod_fine != 0 else 0.0\n        R_std = E_std_coarse / E_std_fine if E_std_fine != 0 else 0.0\n        \n        results.extend([R_mod, R_std])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3339771"}]}