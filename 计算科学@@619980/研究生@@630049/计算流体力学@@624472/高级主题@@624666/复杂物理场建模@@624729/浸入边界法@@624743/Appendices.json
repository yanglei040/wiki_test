{"hands_on_practices": [{"introduction": "在处理与笛卡尔网格不重合的浸入边界时，一个核心的挑战是如何在边界附近的流体节点上保持数值计算的精度。标准的有限差分模板在此处不再适用，因为它们需要跨越边界的、位于固体或另一相流体内部的网格点信息。这项练习将引导你通过多项式插值法，为尖锐界面浸入边界法推导修正的、高阶精度的有限差分模板，这是为复杂几何形状开发高精度数值方法的一项基本技能[@problem_id:3332789]。", "problem": "考虑一个二维均匀笛卡尔网格，在$x$和$y$方向上的间距均为$h$。一个尖锐界面浸入边界与位于流体节点$x_0$和外部节点$x_{-1} = x_0 - h$之间的网格段相交。边界位置为$x_b = x_0 - \\alpha h$，其中$0  \\alpha  1$。在浸入边界上给定狄利克雷边界条件，因此$u(x_b) = u_b$是已知的。令$u_0 = u(x_0)$和$u_1 = u(x_1)$表示$x_0$处及其沿$x$轴的邻近点$x_1 = x_0 + h$处的流体值。假设$u$足够光滑。\n\n仅使用导数的定义和泰勒级数展开，推导适用于尖锐界面浸入边界法的修正有限差分格式，具体如下：\n\n- 构建一个在$x$方向上的二次插值多项式，该插值使用$(x_b, u_b)$、$(x_0, u_0)$和$(x_1, u_1)$这三个数据点。使用该插值多项式，在流体节点$x_0$处获得一个关于$x$方向梯度$u_x$的单边二阶精确公式。用$\\alpha$明确表示所得格式的系数。\n- 使用相同的二次插值多项式，在$x_0$处推导一个修正的关于$x$方向二阶导数$u_{xx}$的单边近似。将其与$y$方向的标准中心二阶差分相结合，以构建边界附近的离散拉普拉斯算子。确定$x$方向梯度和拉普拉斯算子的主阶截断误差项。从阶数和主系数方面讨论，与$y$方向的中心离散化相比，$x$方向的单边离散化如何导致截断误差的各向异性。\n\n最后，设$x_0$处$x$方向梯度近似的局部截断误差写为以下形式\n$$\nu_x(x_0)_{\\text{approx}} - u_x(x_0) = C(\\alpha)\\, h^{2}\\, u_{xxx}(x_0) + \\mathcal{O}(h^{3}),\n$$\n其中$C(\\alpha)$是仅依赖于$\\alpha$的无量纲系数。给出$C(\\alpha)$的闭式解析表达式。", "solution": "该问题是适定的，具有科学依据，并包含了完整推导所需的所有信息。这是在发展带浸入边界的偏微分方程数值方法中的一个标准练习。\n\n任务的核心是构建一个通过三个非均匀分布点的多项式插值，然后用其导数来近似底层函数$u(x)$的导数。\n\n设这三个点为$(x_b, u_b)$、$(x_0, u_0)$和$(x_1, u_1)$。我们定义一个局部坐标$\\xi$来简化代数运算：\n$$\nx = x_0 + \\xi h \\implies \\xi = \\frac{x - x_0}{h}\n$$\n在这个新坐标系中，我们的数据点位置为：\n$$\nx_b = x_0 - \\alpha h \\implies \\xi_b = -\\alpha\n$$\n$$\nx_0 \\implies \\xi_0 = 0\n$$\n$$\nx_1 = x_0 + h \\implies \\xi_1 = 1\n$$\n设二次插值多项式为$P(\\xi) = a\\xi^2 + b\\xi + c$。我们强制$P(\\xi)$通过给定的三个数据点：\n1. 在 $\\xi=0$ 处： $P(0) = c = u_0$。\n2. 在 $\\xi=1$ 处： $P(1) = a(1)^2 + b(1) + c = u_1 \\implies a + b + u_0 = u_1 \\implies a + b = u_1 - u_0$。\n3. 在 $\\xi=-\\alpha$ 处： $P(-\\alpha) = a(-\\alpha)^2 + b(-\\alpha) + c = u_b \\implies a\\alpha^2 - b\\alpha + u_0 = u_b \\implies a\\alpha^2 - b\\alpha = u_b - u_0$。\n\n我们得到一个关于系数$a$和$b$的二元线性方程组：\n$$\n\\begin{cases}\na + b = u_1 - u_0 \\\\\na\\alpha^2 - b\\alpha = u_b - u_0\n\\end{cases}\n$$\n由第一个方程，我们有$b = u_1 - u_0 - a$。将其代入第二个方程：\n$$\na\\alpha^2 - (u_1 - u_0 - a)\\alpha = u_b - u_0\n$$\n$$\na\\alpha^2 - \\alpha(u_1 - u_0) + a\\alpha = u_b - u_0\n$$\n$$\na(\\alpha^2 + \\alpha) = u_b - u_0 + \\alpha(u_1 - u_0)\n$$\n$$\na \\alpha(\\alpha+1) = u_b - (1+\\alpha)u_0 + \\alpha u_1\n$$\n求解$a$：\n$$\na = \\frac{u_b - (1+\\alpha)u_0 + \\alpha u_1}{\\alpha(\\alpha+1)}\n$$\n现在，我们用$b = u_1 - u_0 - a$来求解$b$：\n$$\nb = u_1 - u_0 - \\frac{u_b - (1+\\alpha)u_0 + \\alpha u_1}{\\alpha(\\alpha+1)}\n$$\n将所有项通分到公分母$\\alpha(\\alpha+1)$上：\n$$\nb = \\frac{\\alpha(\\alpha+1)(u_1 - u_0) - [u_b - (1+\\alpha)u_0 + \\alpha u_1]}{\\alpha(\\alpha+1)}\n$$\n$$\nb = \\frac{(\\alpha^2+\\alpha)u_1 - (\\alpha^2+\\alpha)u_0 - u_b + (1+\\alpha)u_0 - \\alpha u_1}{\\alpha(\\alpha+1)}\n$$\n按$u_b$、$u_0$和$u_1$对各项进行分组：\n$$\nb = \\frac{-u_b + (-\\alpha^2-\\alpha+1+\\alpha)u_0 + (\\alpha^2+\\alpha-\\alpha)u_1}{\\alpha(\\alpha+1)} = \\frac{-u_b + (1-\\alpha^2)u_0 + \\alpha^2 u_1}{\\alpha(\\alpha+1)}\n$$\n\n**$x_0$处$x$方向梯度$u_x$的近似**\n\n根据链式法则，$u$关于$x$的一阶导数与$P$关于$\\xi$的导数相关：$\\frac{du}{dx} = \\frac{d P}{d\\xi}\\frac{d\\xi}{dx}$。由于$\\frac{d\\xi}{dx} = \\frac{d}{dx}\\left(\\frac{x-x_0}{h}\\right) = \\frac{1}{h}$，我们有$\\frac{du}{dx} = \\frac{1}{h}\\frac{dP}{d\\xi}$。\n插值多项式的导数为$\\frac{dP}{d\\xi} = 2a\\xi + b$。\n我们通过计算插值多项式在$x_0$处（即$\\xi=0$处）的导数值来近似$u_x(x_0)$：\n$$\nu_x(x_0)_{\\text{approx}} = \\frac{1}{h}\\frac{dP}{d\\xi}\\Big|_{\\xi=0} = \\frac{1}{h}(2a(0) + b) = \\frac{b}{h}\n$$\n代入我们关于$b$的表达式：\n$$\nu_x(x_0)_{\\text{approx}} = \\frac{1}{h} \\left( \\frac{-u_b + (1-\\alpha^2)u_0 + \\alpha^2 u_1}{\\alpha(\\alpha+1)} \\right)\n$$\n我们可以将其表示为一个有限差分格式。注意到$1-\\alpha^2=(1-\\alpha)(1+\\alpha)$以及$\\alpha^2 = \\alpha \\cdot \\alpha$：\n$$\nu_x(x_0)_{\\text{approx}} = \\frac{1}{h} \\left( \\frac{-1}{\\alpha(\\alpha+1)} u_b + \\frac{(1-\\alpha)(1+\\alpha)}{\\alpha(\\alpha+1)} u_0 + \\frac{\\alpha^2}{\\alpha(\\alpha+1)} u_1 \\right)\n$$\n$$\nu_x(x_0)_{\\text{approx}} = \\frac{1}{h} \\left( \\frac{-1}{\\alpha(\\alpha+1)} u_b + \\frac{1-\\alpha}{\\alpha} u_0 + \\frac{\\alpha}{\\alpha+1} u_1 \\right)\n$$\n这就是所求的在$x_0$处$x$方向梯度的二阶精确公式。\n\n**$x_0$处$x$方向二阶导数$u_{xx}$及拉普拉斯算子的近似**\n\n类似地，对于二阶导数，我们使用$\\frac{d^2u}{dx^2} = \\frac{d}{dx}\\left(\\frac{1}{h}\\frac{dP}{d\\xi}\\right) = \\frac{1}{h}\\frac{d^2P}{d\\xi^2}\\frac{d\\xi}{dx} = \\frac{1}{h^2}\\frac{d^2P}{d\\xi^2}$。\n插值多项式的二阶导数为$\\frac{d^2P}{d\\xi^2} = 2a$。\n我们通过在$x_0$处（即$\\xi=0$处）计算该值来近似$u_{xx}(x_0)$：\n$$\nu_{xx}(x_0)_{\\text{approx}} = \\frac{2a}{h^2}\n$$\n代入我们关于$a$的表达式：\n$$\nu_{xx}(x_0)_{\\text{approx}} = \\frac{2}{h^2} \\left( \\frac{u_b - (1+\\alpha)u_0 + \\alpha u_1}{\\alpha(\\alpha+1)} \\right)\n$$\n这就是在$x_0$处$u_{xx}$的修正单边近似。在边界附近的一点$(x_0, y_j)$处，将该式与$y$方向的标准中心二阶差分相结合，构成离散拉普拉斯算子：\n$$\n\\nabla^2 u(x_0, y_j)_{\\text{approx}} = u_{xx}(x_0)_{\\text{approx}} + u_{yy}(y_j)_{\\text{approx}}\n$$\n$$\n\\nabla^2 u(x_0, y_j)_{\\text{approx}} = \\frac{2}{h^2\\alpha(\\alpha+1)} \\left( u_b - (1+\\alpha)u_0 + \\alpha u_1 \\right) + \\frac{u(x_0, y_{j+1}) - 2u(x_0, y_j) + u(x_0, y_{j-1})}{h^2}\n$$\n其中$u_0 = u(x_0, y_j)$，$u_1 = u(x_1, y_j)$，以及$u_b = u(x_b, y_j)$。\n\n**截断误差分析**\n\n为了求得截断误差，我们将$u_1$和$u_b$在$x_0$附近的泰勒级数展开式代入我们的格式中。此后所有导数均在$x_0$处取值。\n$u_1 = u(x_0+h) = u_0 + h u_x + \\frac{h^2}{2} u_{xx} + \\frac{h^3}{6} u_{xxx} + \\frac{h^4}{24} u_{xxxx} + \\mathcal{O}(h^5)$\n$u_b = u(x_0-\\alpha h) = u_0 - \\alpha h u_x + \\frac{(\\alpha h)^2}{2} u_{xx} - \\frac{(\\alpha h)^3}{6} u_{xxx} + \\frac{(\\alpha h)^4}{24} u_{xxxx} + \\mathcal{O}(h^5)$\n\n对于$x$方向梯度，$u_x(x_0)_{\\text{approx}} = (b/h)$。使用泰勒级数展开$b$：\n$b \\alpha(\\alpha+1) = -u_b + (1-\\alpha^2)u_0 + \\alpha^2 u_1$\n$= -(u_0 - \\alpha h u_x + \\frac{\\alpha^2 h^2}{2} u_{xx} - \\frac{\\alpha^3 h^3}{6} u_{xxx} + \\dots) + (1-\\alpha^2)u_0 + \\alpha^2(u_0 + h u_x + \\frac{h^2}{2} u_{xx} + \\frac{h^3}{6} u_{xxx} + \\dots)$\n按导数阶数对各项进行分组：\n$u_0$项： $-1+(1-\\alpha^2)+\\alpha^2 = 0$。\n$u_x$项： $\\alpha h + \\alpha^2 h = h(\\alpha + \\alpha^2) = h u_x \\alpha(\\alpha+1)$。\n$u_{xx}$项： $-\\frac{\\alpha^2 h^2}{2} + \\frac{\\alpha^2 h^2}{2} = 0$。\n$u_{xxx}$项： $\\frac{\\alpha^3 h^3}{6} + \\frac{\\alpha^2 h^3}{6} = \\frac{h^3}{6}(\\alpha^3+\\alpha^2) = \\frac{h^3}{6}\\alpha^2(\\alpha+1)$。\n因此，$b \\alpha(\\alpha+1) = h u_x \\alpha(\\alpha+1) + \\frac{h^3}{6}\\alpha^2(\\alpha+1) u_{xxx} + \\mathcal{O}(h^4)$。\n两边同除以$\\alpha(\\alpha+1)$得到$b = h u_x + \\frac{\\alpha^2 h^3}{6} u_{xxx} + \\mathcal{O}(h^4)$。\n于是$u_x(x_0)_{\\text{approx}} = \\frac{b}{h} = u_x + \\frac{\\alpha^2 h^2}{6} u_{xxx} + \\mathcal{O}(h^3)$。\n$x$方向梯度的主阶截断误差为$\\tau_x = \\frac{\\alpha^2}{6} h^2 u_{xxx}$。该近似是二阶精确的。\n\n对于$x$方向二阶导数，$u_{xx}(x_0)_{\\text{approx}} = 2a/h^2$。展开$a$：\n$a \\alpha(\\alpha+1) = u_b - (1+\\alpha)u_0 + \\alpha u_1$\n$= (u_0 - \\alpha h u_x + \\frac{\\alpha^2 h^2}{2} u_{xx} - \\dots) - (1+\\alpha)u_0 + \\alpha(u_0 + h u_x + \\frac{h^2}{2} u_{xx} + \\frac{h^3}{6} u_{xxx} - \\dots)$\n$u_0$项： $1-(1+\\alpha)+\\alpha = 0$。\n$u_x$项： $-\\alpha h + \\alpha h = 0$。\n$u_{xx}$项： $\\frac{\\alpha^2 h^2}{2} + \\frac{\\alpha h^2}{2} = \\frac{h^2}{2}(\\alpha^2+\\alpha) = \\frac{h^2}{2}\\alpha(\\alpha+1)$。\n$u_{xxx}$项： $-\\frac{\\alpha^3 h^3}{6} + \\frac{\\alpha h^3}{6} = \\frac{h^3}{6}(\\alpha-\\alpha^3) = \\frac{h^3}{6}\\alpha(1-\\alpha^2) = \\frac{h^3}{6}\\alpha(1-\\alpha)(1+\\alpha)$。\n因此，$a\\alpha(\\alpha+1) = \\frac{h^2}{2}u_{xx}\\alpha(\\alpha+1) + \\frac{h^3}{6}u_{xxx}\\alpha(1-\\alpha)(1+\\alpha) + \\mathcal{O}(h^4)$。\n两边同除以$\\alpha(\\alpha+1)$得到$a = \\frac{h^2}{2}u_{xx} + \\frac{h^3}{6}(1-\\alpha)u_{xxx} + \\mathcal{O}(h^4)$。\n于是$u_{xx}(x_0)_{\\text{approx}} = \\frac{2a}{h^2} = u_{xx} + \\frac{1-\\alpha}{3}h u_{xxx} + \\mathcal{O}(h^2)$。\n$x$方向二阶导数的主阶截断误差为$\\tau_{xx} = \\frac{1-\\alpha}{3} h u_{xxx}$。该近似是一阶精确的。\n\n$y$方向标准中心差分的截断误差为$\\tau_{yy} = \\frac{h^2}{12}u_{yyyy} + \\mathcal{O}(h^4)$。\n拉普拉斯算子的截断误差为$\\tau_{\\nabla^2} = \\tau_{xx} + \\tau_{yy} = \\frac{1-\\alpha}{3} h u_{xxx} + \\mathcal{O}(h^2)$，因为来自$x$方向离散化的误差是主导项。\n\n单边离散化在截断误差中引入了显著的各向异性。拉普拉斯算子的主误差项$\\frac{1-\\alpha}{3} h u_{xxx}$是关于$h$的一阶项，并且依赖于$x$方向的三阶导数。相比之下，$y$方向的离散化是二阶的，为$\\mathcal{O}(h^2)$，其主误差项依赖于$y$方向的四阶导数。这意味着误差对于坐标方向是不对称的；与切向方向相比，在垂直于边界的方向上，误差更大且性质不同。主误差系数$\\frac{1-\\alpha}{3}$也随着边界的亚网格位置而变化，这与$y$方向的常系数$\\frac{1}{12}$不同。\n\n**系数$C(\\alpha)$的推导**\n\n问题将$x$方向梯度近似的局部截断误差表述为以下形式：\n$$\nu_x(x_0)_{\\text{approx}} - u_x(x_0) = C(\\alpha)\\, h^{2}\\, u_{xxx}(x_0) + \\mathcal{O}(h^{3})\n$$\n根据我们对$x$方向梯度的截断误差分析，我们得到：\n$$\nu_x(x_0)_{\\text{approx}} - u_x(x_0) = \\frac{\\alpha^2}{6} h^2 u_{xxx}(x_0) + \\mathcal{O}(h^3)\n$$\n通过直接比较这两个表达式，我们可以确定系数$C(\\alpha)$。\n$$\nC(\\alpha) = \\frac{\\alpha^2}{6}\n$$", "answer": "$$\n\\boxed{\\frac{\\alpha^2}{6}}\n$$", "id": "3332789"}, {"introduction": "浸入边界法的一个重要应用是模拟多相流，例如带有表面张力的液滴或气泡的动力学。在这些情况下，数值方法中对界面曲率估计的微小误差会破坏力平衡，从而产生非物理性的“寄生流”（parasitic currents）。这项练习将通过求解斯托克斯方程来模拟和量化这些由曲率误差引起的虚假流动，让你亲身体验多相流模拟中的一个关键问题，并理解数值精度对物理真实性的直接影响[@problem_id:3332836]。", "problem": "考虑一个静态、不混溶的两相流，其中光滑界面分隔两种等粘度的牛顿流体，该流动由不可压缩斯托克斯方程控制。其基本依据是不可压缩斯托克斯动量平衡和连续性方程，以及经典的表面张力杨-拉普拉斯压力跳跃。具体来说，设流体速度表示为 $\\mathbf{u}(\\mathbf{x})$，压力表示为 $p(\\mathbf{x})$，动力粘度为 $\\mu$，表面张力系数为 $\\sigma$。假设雷诺数很低，因此惯性项可以忽略不计。流体内部的控制方程为\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{0}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n在界面 $\\Gamma$ 上的尖锐界面条件是压力跳跃等于表面张力乘以平均曲率，以及速度的连续性，\n$$\n[\\![p]\\!] = \\sigma \\kappa, \\quad [\\![\\mathbf{u}]\\!] = \\mathbf{0},\n$$\n其中 $[\\![\\cdot]\\!]$ 表示该量跨界面的差值，$\\kappa$ 是界面的平均曲率。考虑一个三维空间中半径为 $R$ 的球形界面，其精确平均曲率为 $\\kappa_{\\mathrm{true}} = 2/R$。一种以误差 $\\epsilon_\\kappa$ 估计 $\\kappa$ 的数值方法将强制一个跳跃 $[\\![p]\\!]_{\\mathrm{num}} = \\sigma (\\kappa_{\\mathrm{true}} + \\epsilon_\\kappa)$，从而产生一个与 $\\sigma \\epsilon_\\kappa$ 成正比的残余界面力。在分布意义上，不正确的跳跃在动量方程中产生一个等效的奇异体力，可以近似为\n$$\n\\mathbf{f}_{\\mathrm{res}}(\\mathbf{x}) \\approx \\sigma \\epsilon_\\kappa \\, \\mathbf{n}(\\mathbf{x}) \\, \\delta_{\\Gamma}(\\mathbf{x}),\n$$\n其中 $\\mathbf{n}$ 是界面上从内部流体指向外部流体的单位法向量，$\\delta_{\\Gamma}$ 是支集在 $\\Gamma$ 上的表面狄拉克分布。在数值方法中，$\\delta_{\\Gamma}$ 由一个宽度与网格间距 $h$ 成正比的光滑化子近似，$\\mathbf{n}$ 可以从到界面的符号距离函数计算得出。\n\n你的任务是实现一个程序，该程序在一个边长为 $L$、由 $N \\times N$ 个点的均匀网格离散化（网格间距 $h = L/N$）的二维周期性域中，模拟不可压缩斯托克斯方程中残余界面力的影响，并计算寄生流的振幅。你应该将界面视为位于域中心、半径为 $R$ 的圆，并使用平滑的界面δ分布来近似球形界面的残余力。流动是周期性的，你必须在傅里叶空间中通过将残余力投影到无散模上，求解稳态不可压缩斯托克斯方程：\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f}_{\\mathrm{res}}, \\quad \\nabla \\cdot \\mathbf{u} = 0, \\quad \\mathbf{u} \\text{ 在 } [0,L]^2 \\text{ 上是周期性的}。\n$$\n残余力应构建为 $\\mathbf{f}_{\\mathrm{res}}(\\mathbf{x}) = \\sigma \\epsilon_\\kappa \\, \\delta_\\varepsilon(\\phi(\\mathbf{x})) \\, \\mathbf{n}(\\mathbf{x})$，其中 $\\phi(\\mathbf{x})$ 是到圆的符号距离函数，$\\mathbf{n}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) / \\|\\nabla \\phi(\\mathbf{x})\\|$，$\\delta_\\varepsilon$ 是对狄拉克δ函数的光滑近似，其支集宽度 $\\varepsilon$ 与 $h$ 相当。使用余弦光滑化子\n$$\n\\delta_\\varepsilon(\\phi) = \\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1 + \\cos\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right),  |\\phi| \\le \\varepsilon \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n其中 $\\varepsilon = 1.5 h$。在傅里叶空间中，对于每个波数矢量 $\\mathbf{k} = (k_x, k_y) \\neq \\mathbf{0}$，解满足\n$$\n\\widehat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^2} \\left( \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2} \\right) \\widehat{\\mathbf{f}}_{\\mathrm{res}}(\\mathbf{k}),\n$$\n且 $\\widehat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$。\n\n通过傅里叶逆变换计算速度场 $\\mathbf{u}(\\mathbf{x})$，并报告定义为寄生流振幅的\n$$\nU_{\\max} = \\max_{\\mathbf{x}} \\|\\mathbf{u}(\\mathbf{x})\\|.\n$$\n所有物理量必须使用一致的单位处理：$\\sigma$ 的单位是 $\\mathrm{N/m}$，$\\mu$ 的单位是 $\\mathrm{Pa\\cdot s}$，$L$、$R$、$h$ 和 $\\varepsilon$ 的单位是 $\\mathrm{m}$，$\\epsilon_\\kappa$ 的单位是 $\\mathrm{m}^{-1}$，$U_{\\max}$ 的单位是 $\\mathrm{m/s}$。角度（如有）必须以弧度为单位。你的程序必须为以下参数集测试套件生成 $U_{\\max}$ 的数值：\n\n- 测试用例1（正常情况，曲率误差为零）：$\\sigma = 0.072\\,\\mathrm{N/m}$, $\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$, $L = 0.04\\,\\mathrm{m}$, $R = 0.01\\,\\mathrm{m}$, $N = 128$, $\\epsilon_\\kappa = 0.0\\,\\mathrm{m}^{-1}$。\n- 测试用例2（非零曲率误差）：$\\sigma = 0.072\\,\\mathrm{N/m}$, $\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$, $L = 0.04\\,\\mathrm{m}$, $R = 0.01\\,\\mathrm{m}$, $N = 128$, $\\epsilon_\\kappa = 0.5\\,\\mathrm{m}^{-1}$。\n- 测试用例3（网格加密边缘情况）：$\\sigma = 0.072\\,\\mathrm{N/m}$, $\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$, $L = 0.04\\,\\mathrm{m}$, $R = 0.01\\,\\mathrm{m}$, $N = 256$, $\\epsilon_\\kappa = 0.5\\,\\mathrm{m}^{-1}$。\n- 测试用例4（粘度变化边缘情况）：$\\sigma = 0.072\\,\\mathrm{N/m}$, $\\mu = 1.0\\times 10^{-2}\\,\\mathrm{Pa\\cdot s}$, $L = 0.04\\,\\mathrm{m}$, $R = 0.01\\,\\mathrm{m}$, $N = 128$, $\\epsilon_\\kappa = 0.5\\,\\mathrm{m}^{-1}$。\n\n以 $\\mathrm{m/s}$ 为单位表示最终答案，格式为单行，包含四个测试用例的结果，聚合为一个用方括号括起来的逗号分隔列表。输出格式必须严格为\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4}],\n$$\n其中每个 $\\text{result}$ 是一个浮点数，代表相应测试用例的 $U_{\\max}$（单位为 $\\mathrm{m/s}$）。", "solution": "该问题是有效的。它在科学上基于低雷诺数流体动力学（不可压缩斯托克斯流）的原理，是适定的，并为可解的数值任务提供了一整套参数和方程。其目标是计算由于曲率估计误差（这反过来又导致错误的表面张力）而在两相流数值模拟中产生的非物理“寄生”流的大小。\n\n将通过实现一种伪谱方法来求解在二维周期域中带有指定残余力项的控制斯托克斯方程来开发解决方案。该方法的核心依赖于快速傅里叶变换（FFT）在周期域上求解具有常系数的线性偏微分方程的效率。\n\n计算过程如下：\n\n**1. 离散化和力场构建**\n\n首先，我们使用一个 $N \\times N$ 点的均匀网格来离散化二维周期域 $[0, L] \\times [0, L]$。网格间距为 $h = L/N$。网格点 $(x_i, y_j)$ 的坐标由 $x_i = i h$ 和 $y_j = j h$ 给出，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$。\n\n驱动寄生流的残余力被建模为一个连续场：\n$$\n\\mathbf{f}_{\\mathrm{res}}(\\mathbf{x}) = \\sigma \\epsilon_\\kappa \\, \\delta_\\varepsilon(\\phi(\\mathbf{x})) \\, \\mathbf{n}(\\mathbf{x})\n$$\n该力仅在圆形界面周围的一个薄层内非零。我们在离散网格上通过在每个点 $(x_i, y_j)$ 计算其分量来构建这个力场。\n\n该公式的组成部分是：\n-   **符号距离函数, $\\phi(\\mathbf{x})$**: 对于一个以 $(L/2, L/2)$ 为中心、半径为 $R$ 的圆形界面，符号距离函数由 $\\phi(x,y) = \\sqrt{(x-L/2)^2 + (y-L/2)^2} - R$ 给出。$\\phi$ 的负值表示点在圆内，正值表示点在圆外。\n\n-   **法向量场, $\\mathbf{n}(\\mathbf{x})$**: 从界面向外指向的单位法向量是符号距离函数的归一化梯度，即 $\\mathbf{n}(\\mathbf{x}) = \\nabla\\phi / \\|\\nabla\\phi\\|$。对于圆形界面，这可计算为：\n    $$\n    \\mathbf{n}(x,y) = \\frac{(x-L/2, y-L/2)}{\\sqrt{(x-L/2)^2 + (y-L/2)^2}}\n    $$\n    在圆心 $(L/2, L/2)$ 处，法向量在数学上是未定义的。然而，只要界面宽度 $\\varepsilon$ 小于半径 $R$，平滑的δ函数在这一点将为零，因此力也为零。在数值上，我们可以通过确保乘积为零来处理除以零的情况。\n\n-   **平滑的狄拉克δ函数, $\\delta_\\varepsilon(\\phi)$**: 表面狄拉克δ函数使用宽度为 $\\varepsilon = 1.5 h$ 的余弦光滑化子进行正则化：\n    $$\n    \\delta_\\varepsilon(\\phi) = \\begin{cases}\n    \\frac{1}{2\\varepsilon}\\left(1 + \\cos\\left(\\frac{\\pi \\phi}{\\varepsilon}\\right)\\right),  |\\phi| \\le \\varepsilon \\\\\n    0,  \\text{其他情况}\n    \\end{cases}\n    $$\n    此函数将力局域化到围绕圆周 $\\phi=0$ 的一个厚度为 $2\\varepsilon$ 的窄带内。\n\n力场的两个分量 $f_x(\\mathbf{x})$ 和 $f_y(\\mathbf{x})$ 在网格上计算。对于 $\\epsilon_\\kappa = 0$ 的测试用例，力场恒为零，导致速度为零，这符合预期。\n\n**2. 斯托克斯方程的傅里叶空间解**\n\n带有残余力项的控制稳态、不可压缩斯托克斯方程为：\n$$\n-\\mu \\nabla^2 \\mathbf{u} + \\nabla p = \\mathbf{f}_{\\mathrm{res}}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n对这些方程应用傅里叶变换（用帽子符号表示，如 $\\widehat{\\mathbf{u}}$），将空间导数转换为与波数矢量 $\\mathbf{k} = (k_x, k_y)$ 的代数乘法：\n$$\n\\mu \\|\\mathbf{k}\\|^2 \\widehat{\\mathbf{u}}(\\mathbf{k}) + i \\mathbf{k} \\widehat{p}(\\mathbf{k}) = \\widehat{\\mathbf{f}}_{\\mathrm{res}}(\\mathbf{k})\n$$\n$$\ni \\mathbf{k} \\cdot \\widehat{\\mathbf{u}}(\\mathbf{k}) = 0\n$$\n第二个方程是傅里叶空间中的不可压缩性约束。为了求解 $\\widehat{\\mathbf{u}}$，我们将动量方程投影到无散矢量场空间上。这通过使用投影算子 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{\\|\\mathbf{k}\\|^2}$ 来实现，其中 $\\mathbf{I}$ 是单位矩阵。将此算子应用于动量方程可以消除压力项，因为 $\\mathbf{P}(\\mathbf{k}) (i\\mathbf{k}\\widehat{p}) = \\mathbf{0}$。\n\n这给出了对于每个波数矢量 $\\mathbf{k} \\neq \\mathbf{0}$ 在傅里叶空间中的速度场解：\n$$\n\\widehat{\\mathbf{u}}(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^2} \\mathbf{P}(\\mathbf{k}) \\widehat{\\mathbf{f}}_{\\mathrm{res}}(\\mathbf{k})\n$$\n对于零波数矢量 $\\mathbf{k} = \\mathbf{0}$（代表平均流），问题指定 $\\widehat{\\mathbf{u}}(\\mathbf{0}) = \\mathbf{0}$。因此，$\\|\\mathbf{k}\\|^2=0$ 处的奇点得到了处理。\n\n傅里叶空间中速度的分量计算如下：\n$$\n\\widehat{u}_x(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^4} \\left( k_y^2 \\widehat{f}_x(\\mathbf{k}) - k_x k_y \\widehat{f}_y(\\mathbf{k}) \\right)\n$$\n$$\n\\widehat{u}_y(\\mathbf{k}) = \\frac{1}{\\mu \\|\\mathbf{k}\\|^4} \\left( k_x^2 \\widehat{f}_y(\\mathbf{k}) - k_x k_y \\widehat{f}_x(\\mathbf{k}) \\right)\n$$\n这些计算针对与离散网格对应的所有波数矢量执行。波数矢量由 $k_x = 2\\pi f_x$ 和 $k_y = 2\\pi f_y$ 给出，其中 $f_x$ 和 $f_y$ 是从 `numpy.fft.fftfreq` 获得的离散频率。\n\n**3. 实空间速度的恢复与最终结果**\n\n通过对傅里叶空间速度分量 $\\widehat{u}_x(\\mathbf{k})$ 和 $\\widehat{u}_y(\\mathbf{k})$ 应用二维傅里叶逆变换，可以恢复实空间速度场 $\\mathbf{u}(\\mathbf{x}) = (u_x(\\mathbf{x}), u_y(\\mathbf{x}))$。\n\n最后，通过计算所有网格点上速度矢量大小的最大值来确定寄生流的振幅 $U_{\\max}$：\n$$\nU_{\\max} = \\max_{\\mathbf{x}} \\|\\mathbf{u}(\\mathbf{x})\\| = \\max_{i,j} \\sqrt{u_x(x_i, y_j)^2 + u_y(x_i, y_j)^2}\n$$\n对测试套件中提供的每个参数集重复此过程，以获得最终结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1: sigma, mu, L, R, N, eps_kappa\n        (0.072, 1.0e-3, 0.04, 0.01, 128, 0.0),\n        # Test case 2\n        (0.072, 1.0e-3, 0.04, 0.01, 128, 0.5),\n        # Test case 3\n        (0.072, 1.0e-3, 0.04, 0.01, 256, 0.5),\n        # Test case 4\n        (0.072, 1.0e-2, 0.04, 0.01, 128, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        U_max = compute_parasitic_current_amplitude(*case)\n        results.append(U_max)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_parasitic_current_amplitude(sigma, mu, L, R, N, eps_kappa):\n    \"\"\"\n    Computes the amplitude of parasitic currents for a given set of parameters.\n\n    Args:\n        sigma (float): Surface tension coefficient (N/m).\n        mu (float): Dynamic viscosity (Pa·s).\n        L (float): Domain side length (m).\n        R (float): Circle radius (m).\n        N (int): Number of grid points per dimension.\n        eps_kappa (float): Curvature error (m^-1).\n\n    Returns:\n        float: The maximum velocity amplitude U_max (m/s).\n    \"\"\"\n\n    # If there is no curvature error, the residual force is zero, thus velocity is zero.\n    if eps_kappa == 0.0:\n        return 0.0\n\n    # 1. Grid Generation and Parameters\n    h = L / N\n    epsilon = 1.5 * h\n    # Grid coordinates\n    coords = np.arange(N) * h\n    X, Y = np.meshgrid(coords, coords)\n\n    # 2. Construct the Residual Force Field in Real Space\n    center_x, center_y = L / 2, L / 2\n    dist = np.sqrt((X - center_x)**2 + (Y - center_y)**2)\n    \n    # Signed distance function\n    phi = dist - R\n\n    # Smoothed Dirac delta function (cosine mollifier)\n    delta = np.zeros_like(phi)\n    mask = np.abs(phi) = epsilon\n    phi_masked = phi[mask]\n    delta[mask] = (1 / (2 * epsilon)) * (1 + np.cos(np.pi * phi_masked / epsilon))\n\n    # Normal vector field. Handle division by zero at the center.\n    # The normal is undefined at the center, but delta will be zero there if R > epsilon,\n    # so the force will correctly be zero.\n    dist_inv = np.divide(1.0, dist, out=np.zeros_like(dist), where=dist != 0)\n    nx = (X - center_x) * dist_inv\n    ny = (Y - center_y) * dist_inv\n\n    # Assemble the force components\n    f_coeff = sigma * eps_kappa\n    fx = f_coeff * delta * nx\n    fy = f_coeff * delta * ny\n\n    # 3. Fourier Transform the Force Field\n    hat_fx = np.fft.fft2(fx)\n    hat_fy = np.fft.fft2(fy)\n\n    # 4. Solve for Velocity in Fourier Space\n    # Wavevectors\n    freq = np.fft.fftfreq(N, d=h)\n    k = 2 * np.pi * freq\n    Kx, Ky = np.meshgrid(k, k) # Kx varies along cols (axis 1), Ky along rows (axis 0)\n\n    # Squared magnitude of wavevectors\n    K2 = Kx**2 + Ky**2\n\n    # Stokes solver in Fourier space. The projection operator and 1/(mu*K^2) are combined.\n    # The term 1/K^4 must avoid the K=0 singularity.\n    inv_mu_K4 = np.divide(1.0, mu * K2**2, out=np.zeros_like(K2), where=K2 != 0)\n\n    # Calculate velocity components in Fourier space\n    hat_ux = inv_mu_K4 * (Ky**2 * hat_fx - Kx * Ky * hat_fy)\n    hat_uy = inv_mu_K4 * (Kx**2 * hat_fy - Kx * Ky * hat_fx)\n    \n    # The k=0 mode (mean velocity) is correctly set to zero by the `where` clause in np.divide.\n\n    # 5. Inverse Fourier Transform to get Real-Space Velocity\n    ux = np.fft.ifft2(hat_ux).real\n    uy = np.fft.ifft2(hat_uy).real\n\n    # 6. Compute the Amplitude of Parasitic Currents\n    vel_mag = np.sqrt(ux**2 + uy**2)\n    U_max = np.max(vel_mag)\n\n    return U_max\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3332836"}, {"introduction": "除了标准的流动模拟，浸入边界法在形状优化和流动控制等领域也扮演着重要角色，这通常需要基于梯度的优化算法。在弥散界面浸入边界法中，力从拉格朗日点“散布”（spread）到欧拉网格以及速度从欧拉网格“插值”（interpolate）到拉格朗日点是两个核心操作。这项练习将引导你构建这些操作的离散矩阵，并验证它们之间至关重要的伴随关系，因为这种关系是精确计算优化问题中目标函数梯度的基础[@problem_id:3332853]。", "problem": "给定一个单位正方形上的具有周期性边界的均匀二维笛卡尔网格，以及一组代表浸入曲线的拉格朗日标记点。浸入边界法使用一个正则化的狄拉克 delta 函数来定义两个线性算子：一个将拉格朗日力映射到网格上欧拉力的散布算子 $S$，以及一个将欧拉网格场插值到拉格朗日标记点的插值算子 $J$。您的任务是构建这些算子的离散矩阵表示，形成正确加权的伴随对，在特定求积方法下验证对称关系，并量化这种对称性的偏差如何影响一个简单优化任务中的梯度精度。\n\n从以下基本基础和定义开始：\n\n- 欧拉网格为 $N \\times N$，网格间距为 $h = 1/N$，网格坐标为 $x_i = i h, y_j = j h$，其中整数 $i,j \\in \\{0,\\dots,N-1\\}$，并在 $[0,1)^2$ 上具有周期性边界条件。\n\n- 在位置 $(X_\\ell, Y_\\ell)$ 处有 $M$ 个拉格朗日标记点，其均匀求积权重为 $w_\\ell = \\Delta s$，其中 $\\Delta s$ 近似于曲线的弧长间距。\n\n- 一维四点正则化狄拉克 delta 函数（Peskin 核）$\\varphi(r)$ 的支撑集在 $|r| \\le 2$ 上，定义为\n  $$\n  \\varphi(r) = \n  \\begin{cases}\n  \\dfrac{1}{8}\\left(3 - 2|r| + \\sqrt{1 + 4|r| - 4 r^2}\\right),  0 \\le |r| \\le 1, \\\\\n  \\dfrac{1}{8}\\left(5 - 2|r| - \\sqrt{-7 + 12|r| - 4 r^2}\\right),  1 \\le |r| \\le 2, \\\\\n  0,  |r| \\ge 2,\n  \\end{cases}\n  $$\n  且网格间距为 $h$ 时的二维正则化 delta 函数为\n  $$\n  \\delta_h(x,y) = \\dfrac{1}{h^2} \\, \\varphi\\!\\left(\\dfrac{x}{h}\\right)\\, \\varphi\\!\\left(\\dfrac{y}{h}\\right).\n  $$\n  周期性通过对自变量取最小周期差来强制执行。\n\n- 离散散布算子 $S_{\\mathrm{phys}}$ 将一个拉格朗日向量 $F \\in \\mathbb{R}^{M}$ 映射到一个欧拉向量 $f \\in \\mathbb{R}^{N^2}$，通过\n  $$\n  f_{ij} = \\sum_{\\ell=1}^{M} w_\\ell \\, F_\\ell \\, \\delta_h\\!\\left(x_i - X_\\ell, \\, y_j - Y_\\ell\\right),\n  $$\n  即，以矩阵形式表示为 $f = S_{\\mathrm{phys}} \\, F$，其中 $S_{\\mathrm{phys}} \\in \\mathbb{R}^{N^2 \\times M}$。\n\n- 离散插值算子 $J_{\\mathrm{phys}}$ 将一个欧拉向量 $u \\in \\mathbb{R}^{N^2}$ 映射到一个拉格朗日向量 $U \\in \\mathbb{R}^{M}$，通过\n  $$\n  U_\\ell = \\sum_{i=1}^{N} \\sum_{j=1}^{N} u_{ij}\\, h^2 \\, \\delta_h\\!\\left(x_i - X_\\ell, \\, y_j - Y_\\ell\\right),\n  $$\n  即，以矩阵形式表示为 $U = J_{\\mathrm{phys}} \\, u$，其中 $J_{\\mathrm{phys}} \\in \\mathbb{R}^{M \\times N^2}$。\n\n- 欧拉加权内积为 $\\langle u, f \\rangle_E = \\sum_{i,j} u_{ij} f_{ij} \\, h^2$，拉格朗日加权内积为 $\\langle U, F \\rangle_L = \\sum_{\\ell} U_\\ell F_\\ell \\, w_\\ell$。在这些权重下，离散功率恒等式 $\\langle u, S_{\\mathrm{phys}} F \\rangle_E = \\langle J_{\\mathrm{phys}} u, F \\rangle_L$ 成立，等价于\n  $$\n  J_{\\mathrm{phys}} = W_L^{-1} \\, S_{\\mathrm{phys}}^\\top \\, W_E,\n  $$\n  其中 $W_E = h^2 I_{N^2}$ 且 $W_L = \\mathrm{diag}(w_1,\\dots,w_M)$。\n\n- 定义对称加权算子\n  $$\n  \\widetilde{S} = W_E^{1/2}\\, S_{\\mathrm{phys}}\\, W_L^{-1/2}, \\qquad\n  \\widetilde{J} = W_L^{1/2}\\, J_{\\mathrm{phys}}\\, W_E^{-1/2}.\n  $$\n  使用上述基本恒等式，可得到对称关系\n  $$\n  \\widetilde{J} = \\widetilde{S}^\\top.\n  $$\n\n您的程序必须：\n\n- 对于给定的 $(N,M)$、位于半径为 $R$、中心为 $(x_c,y_c)$ 的圆上的标记点位置 $(X_\\ell,Y_\\ell)$，以及求积权重 $w_\\ell = 2\\pi R / M$，构建 $S_{\\mathrm{phys}}$ 和 $J_{\\mathrm{phys}}$。\n\n- 构建对称加权对 $(\\widetilde{S}, \\widetilde{J})$，并计算差值 $\\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$ 的 Frobenius 范数，结果为一个标量浮点数。\n\n- 构建一个偏离的插值算子 $J_{\\mathrm{wrong}}$，该算子省略了欧拉求积因子 $h^2$（即，设 $U_\\ell = \\sum_{i,j} u_{ij}\\, \\delta_h(\\cdot)$），并使用相同的对称加权公式 $\\widetilde{J}_{\\mathrm{wrong}} = W_L^{1/2} J_{\\mathrm{wrong}} W_E^{-1/2}$ 来计算 $\\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$。\n\n- 定义关于拉格朗日力 $F \\in \\mathbb{R}^M$ 的二次目标函数\n  $$\n  \\Phi(F) = \\dfrac{1}{2}\\, \\| A F - b \\|_{W_L}^2, \\quad \\text{其中 } A = J_{\\mathrm{phys}} S_{\\mathrm{phys}},\n  $$\n  且 $\\|v\\|_{W_L}^2 = v^\\top W_L v$。为保证可复现性，使用一个确定性种子的固定随机向量 $b \\in \\mathbb{R}^M$ 和一个固定的随机向量 $F \\in \\mathbb{R}^M$。\n\n- 使用加权内积所隐含的伴随链计算关于 $F$ 的精确梯度，\n  $$\n  \\nabla \\Phi(F) = S_{\\mathrm{phys}}^\\top\\, J_{\\mathrm{phys}}^\\top\\, \\left(W_L (A F - b)\\right).\n  $$\n  同时，计算一个在伴随链中使用了偏离插值算子的不正确梯度，\n  $$\n  \\nabla_{\\mathrm{wrong}} \\Phi(F) = S_{\\mathrm{phys}}^\\top\\, J_{\\mathrm{wrong}}^\\top\\, \\left(W_L (A F - b)\\right).\n  $$\n\n- 通过中心有限差分法估计参考梯度，其中扰动步长 $\\varepsilon$ 按分量施加于 $F$：\n  $$\n  \\left[\\nabla \\Phi(F)\\right]_k \\approx \\dfrac{\\Phi(F + \\varepsilon e_k) - \\Phi(F - \\varepsilon e_k)}{2 \\varepsilon},\n  $$\n  其中 $e_k$ 是第 $k$ 个基向量。\n\n- 报告精确梯度和不正确梯度相对于有限差分法的相对 $\\ell^2$ 误差：\n  $$\n  E_{\\mathrm{true}} = \\dfrac{\\|\\nabla \\Phi(F) - \\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}{\\|\\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}, \\qquad\n  E_{\\mathrm{wrong}} = \\dfrac{\\|\\nabla_{\\mathrm{wrong}} \\Phi(F) - \\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}{\\|\\nabla_{\\mathrm{FD}} \\Phi(F)\\|_2}.\n  $$\n\n测试套件和要求的最终输出：\n\n您的程序必须实现以下三个测试用例，并将其输出汇总到一个列表中：\n\n- 用例 1（对称性验证，匹配求积）：$N = 16$，$M = 20$，圆心 $(x_c,y_c) = (0.15, 0.85)$，半径 $R = 0.22$。计算 $E_{\\mathrm{sym}}^{\\mathrm{matched}} = \\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$ 作为浮点数。\n\n- 用例 2（对称性验证，偏离的插值求积）：参数与用例 1 相同，但使用省略了因子 $h^2$ 的 $J_{\\mathrm{wrong}}$。计算 $E_{\\mathrm{sym}}^{\\mathrm{wrong}} = \\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$ 作为浮点数。\n\n- 用例 3（二次设计任务中的梯度精度）：$N = 24$，$M = 28$，圆心 $(x_c,y_c) = (0.07, 0.11)$，半径 $R = 0.19$，随机种子固定为整数值，有限差分步长 $\\varepsilon = 10^{-6}$。计算 $E_{\\mathrm{true}}$ 和 $E_{\\mathrm{wrong}}$ 作为浮点数。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按顺序为 $[E_{\\mathrm{sym}}^{\\mathrm{matched}}, E_{\\mathrm{sym}}^{\\mathrm{wrong}}, E_{\\mathrm{true}}, E_{\\mathrm{wrong}}]$。", "solution": "用户希望验证一个问题陈述。\n\n### 步骤 1：提取已知条件\n\n- **欧拉网格**：单位正方形 $[0,1)^2$ 上的一个均匀 $N \\times N$ 笛卡尔网格，具有周期性边界。网格间距为 $h = 1/N$。网格点坐标为 $(x_i, y_j)$，其中 $x_i = i h$，$y_j = j h$，$i, j \\in \\{0, \\dots, N-1\\}$。\n- **拉格朗日标记点**：$M$ 个位于位置 $(X_\\ell, Y_\\ell)$ 的标记点。\n- **拉格朗日求积**：均匀求积权重 $w_\\ell = \\Delta s$。对于半径为 $R$ 的圆，$w_\\ell = 2\\pi R / M$。\n- **正则化 Delta 函数**：一维四点 Peskin 核 $\\varphi(r)$ 及其二维张量积扩展 $\\delta_h(x,y) = \\frac{1}{h^2} \\varphi(x/h) \\varphi(y/h)$。周期性通过最小周期差来强制执行。\n- **散布算子 ($S_{\\mathrm{phys}}$)**：一个从拉格朗日力 $F \\in \\mathbb{R}^M$ 到欧拉力 $f \\in \\mathbb{R}^{N^2}$ 的线性算子，定义为 $f_{ij} = \\sum_{\\ell=1}^{M} w_\\ell \\, F_\\ell \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell)$。矩阵形式为 $f = S_{\\mathrm{phys}} F$。\n- **插值算子 ($J_{\\mathrm{phys}}$)**：一个从欧拉场 $u \\in \\mathbb{R}^{N^2}$ 到拉格朗日场 $U \\in \\mathbb{R}^M$ 的线性算子，定义为 $U_\\ell = \\sum_{i,j} u_{ij}\\, h^2 \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell)$。矩阵形式为 $U = J_{\\mathrm{phys}} u$。\n- **加权内积**：欧拉内积 $\\langle u, f \\rangle_E = \\sum_{i,j} u_{ij} f_{ij} \\, h^2$ 和拉格朗日内积 $\\langle U, F \\rangle_L = \\sum_{\\ell} U_\\ell F_\\ell \\, w_\\ell$。\n- **离散伴随关系**：算子被定义为满足功率恒等式 $\\langle u, S_{\\mathrm{phys}} F \\rangle_E = \\langle J_{\\mathrm{phys}} u, F \\rangle_L$，这意味着矩阵关系 $J_{\\mathrm{phys}} = W_L^{-1} S_{\\mathrm{phys}}^\\top W_E$，其中 $W_E = h^2 I_{N^2}$ 且 $W_L = \\mathrm{diag}(w_1, \\dots, w_M)$。\n- **对称加权算子**：$\\widetilde{S} = W_E^{1/2} S_{\\mathrm{phys}} W_L^{-1/2}$ 和 $\\widetilde{J} = W_L^{1/2} J_{\\mathrm{phys}} W_E^{-1/2}$，它们应满足 $\\widetilde{J} = \\widetilde{S}^\\top$。\n- **偏离的插值算子 ($J_{\\mathrm{wrong}}$)**：通过省略 $h^2$ 因子定义：$U_\\ell = \\sum_{i,j} u_{ij} \\delta_h(x_i - X_\\ell, y_j - Y_\\ell)$。\n- **目标函数**：$\\Phi(F) = \\frac{1}{2} \\| A F - b \\|_{W_L}^2$，其中 $A = J_{\\mathrm{phys}} S_{\\mathrm{phys}}$，以及固定的随机向量 $b, F$。\n- **梯度**：一个“精确”梯度 $\\nabla \\Phi(F) = S_{\\mathrm{phys}}^\\top J_{\\mathrm{phys}}^\\top (W_L(AF-b))$，一个“不正确”梯度 $\\nabla_{\\mathrm{wrong}} \\Phi(F) = S_{\\mathrm{phys}}^\\top J_{\\mathrm{wrong}}^\\top (W_L(AF-b))$，以及一个来自有限差分的参考梯度 $\\nabla_{\\mathrm{FD}} \\Phi(F)$。\n- **任务**：\n  1.  构建算子并计算 $E_{\\mathrm{sym}}^{\\mathrm{matched}} = \\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$。\n  2.  构建 $J_{\\mathrm{wrong}}$ 并计算 $E_{\\mathrm{sym}}^{\\mathrm{wrong}} = \\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$。\n  3.  计算解析梯度相对于有限差分近似的相对误差 $E_{\\mathrm{true}}$ 和 $E_{\\mathrm{wrong}}$。\n- **参数**：\n  - 用例 1  2: $N=16, M=20, (x_c,y_c)=(0.15, 0.85), R=0.22$。\n  - 用例 3: $N=24, M=28, (x_c,y_c)=(0.07, 0.11), R=0.19$，固定的整数随机种子，$\\varepsilon = 10^{-6}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估。\n\n- **科学依据**：该问题深深植根于计算流体动力学，特别是 Charles Peskin 开创的浸入边界法。其中的概念，包括正则化 delta 函数、散布/插值算子和加权伴随，都是该领域的标准和基础内容。所有的数学定义和物理解释都是正确的。\n- **适定性**：该问题是适定的。它要求实现明确定义的数学对象，并计算具体的、明确定义的量（矩阵范数、向量范数和相对误差）。为每个任务提供了所有必要的参数和定义。计算的确定性保证了结果的存在性和唯一性。\n- **客观性**：语言精确、量化，没有任何主观或模棱两可的术语。\n- **完整性**：问题是自洽的。为指定的测试用例提供了所有必要的方程、常数和参数。不需要外部信息。\n- **一致性**：定义是相互一致的。例如，矩阵关系 $J_{\\mathrm{phys}} = W_L^{-1} S_{\\mathrm{phys}}^\\top W_E$ 是算子定义和加权内积的直接结果，这构成了练习中的一个关键验证点。\n- **现实性**：对于一个演示规模的问题，这些参数在物理上和数值上都是合理的。验证伴随关系及其对梯度计算的影响，是在工程和物理学中开发和验证数值优化代码时一个关键且现实的步骤。\n\n该问题没有任何无效性缺陷。它是一个典型的、具有教学意义且健全的数值方法练习。\n\n### 步骤 3：结论和行动\n\n该问题是**有效的**。将提供一个解决方案。\n\n---\n\n### 解答\n\n该问题要求仔细实现浸入边界（IB）方法的核心算子，并研究它们的伴随性质。解决方案围绕算子离散化、加权伴随及其在基于梯度的优化中的应用的原则构建。\n\n**1. 连续算子的离散化**\n\nIB 方法将浸入结构的拉格朗日表示与周围的欧拉流体网格耦合起来。这种耦合是通过包含狄拉克 delta 函数的积分算子来介导的。在离散设置中，狄拉克 delta 函数被正则化核 $\\delta_h$ 替代，积分被求和替代。\n\n- **网格和标记点**：欧拉域是一个由 $N^2$ 个点 $(x_i, y_j)$ 组成的网格，浸入边界是一组 $M$ 个拉格朗日标记点 $(X_\\ell, Y_\\ell)$。周期性边界条件通过在环面上计算距离来处理，即，假设域大小为 1，则 $d_{\\text{periodic}}(a,b) = (a-b) - \\lfloor(a-b)+0.5\\rfloor$。\n\n- **散布算子 $S_{\\mathrm{phys}}$**：该算子将拉格朗日量（如力 $F$）散布到欧拉网格上。连续定义为 $f(\\mathbf{x}) = \\int_{\\Gamma} F(s) \\delta(\\mathbf{x} - \\mathbf{X}(s)) ds$。其离散化为：\n$$ f_{ij} = \\sum_{\\ell=1}^M F_\\ell \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) w_\\ell $$\n此处，$w_\\ell$（近似 $ds$）是拉格朗日求积权重。将向量 $F$ 映射到向量 $f$ 的 $S_{\\mathrm{phys}}$ 的矩阵元素（以网格点为行，标记点为列）为：\n$$ (S_{\\mathrm{phys}})_{ij, \\ell} = w_\\ell \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) = \\frac{w_\\ell}{h^2} \\varphi\\left(\\frac{x_i - X_\\ell}{h}\\right) \\varphi\\left(\\frac{y_j - Y_\\ell}{h}\\right) $$\n\n- **插值算子 $J_{\\mathrm{phys}}$**：该算子将欧拉场（如速度 $u$）插值到拉格朗日标记点。连续定义为 $U(s) = \\int_{\\Omega} u(\\mathbf{x}) \\delta(\\mathbf{x} - \\mathbf{X}(s)) d\\mathbf{x}$。其离散化为：\n$$ U_\\ell = \\sum_{i=1}^N \\sum_{j=1}^N u_{ij} \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) h^2 $$\n此处，$h^2$ 是欧拉求积权重（面积元 $d\\mathbf{x}$）。$J_{\\mathrm{phys}}$ 的矩阵元素（以标记点为行，网格点为列）为：\n$$ (J_{\\mathrm{phys}})_{\\ell, ij} = h^2 \\, \\delta_h(x_i - X_\\ell, y_j - Y_\\ell) = \\varphi\\left(\\frac{x_i - X_\\ell}{h}\\right) \\varphi\\left(\\frac{y_j - Y_\\ell}{h}\\right) $$\n\n**2. 伴随关系与对称性**\n\n算子 $S_{\\mathrm{phys}}$ 和 $J_{\\mathrm{phys}}$ 彼此不是矩阵转置关系。相反，它们是关于代表离散积分的特定加权内积的伴随算子：网格上的 $\\langle \\cdot, \\cdot \\rangle_E$ 和标记点上的 $\\langle \\cdot, \\cdot \\rangle_L$。必须满足功率守恒恒等式 $\\langle u, S_{\\mathrm{phys}} F \\rangle_E = \\langle J_{\\mathrm{phys}} u, F \\rangle_L$。这等价于矩阵恒等式 $S_{\\mathrm{phys}}^\\top W_E = W_L J_{\\mathrm{phys}}$，或 $J_{\\mathrm{phys}} = W_L^{-1} S_{\\mathrm{phys}}^\\top W_E$，其中 $W_E=h^2 I$ 且 $W_L=\\mathrm{diag}(w_\\ell)$。我们对 $(S_{\\mathrm{phys}})_{ij, \\ell}$ 和 $(J_{\\mathrm{phys}})_{\\ell, ij}$ 的构造满足此条件。\n\n为了恢复熟悉的矩阵转置关系，我们定义对称加权算子：\n$$ \\widetilde{S} = W_E^{1/2} S_{\\mathrm{phys}} W_L^{-1/2} \\quad \\text{和} \\quad \\widetilde{J} = W_L^{1/2} J_{\\mathrm{phys}} W_E^{-1/2} $$\n将 $J_{\\mathrm{phys}}$ 的伴随关系代入 $\\widetilde{J}$ 的定义并化简，可以证实 $\\widetilde{J} = \\widetilde{S}^\\top$。代码将通过计算 $\\|\\widetilde{J} - \\widetilde{S}^\\top\\|_F$ 来数值验证这一点，其结果应接近机器精度。\n\n偏离的算子 $J_{\\mathrm{wrong}}$ 省略了欧拉求积权重 $h^2$，得到 $(J_{\\mathrm{wrong}})_{\\ell, ij} = \\delta_h(\\dots)$。这破坏了功率恒等式，因此也破坏了加权算子的对称性。$\\|\\widetilde{J}_{\\mathrm{wrong}} - \\widetilde{S}^\\top\\|_F$ 将显著不为零。\n\n**3. 梯度计算与验证**\n\n对于目标函数 $\\Phi(F) = \\frac{1}{2} \\| J_{\\mathrm{phys}} S_{\\mathrm{phys}} F - b \\|_{W_L}^2$，梯度通过链式法则求得。$\\|v\\|_{W_L}^2$ 对 $v$ 的导数是 $2 W_L v$。通过线性算子应用链式法则可得：\n$$ \\nabla \\Phi(F) = (J_{\\mathrm{phys}} S_{\\mathrm{phys}})^\\dagger (J_{\\mathrm{phys}} S_{\\mathrm{phys}} F - b) $$\n其中 $(\\cdot)^\\dagger$ 表示关于输入空间上的标准欧几里得内积和输出空间上的 $W_L$ 加权内积的伴随。这可以简化为：\n$$ \\nabla \\Phi(F) = (J_{\\mathrm{phys}} S_{\\mathrm{phys}})^\\top W_L (J_{\\mathrm{phys}} S_{\\mathrm{phys}} F - b) = S_{\\mathrm{phys}}^\\top J_{\\mathrm{phys}}^\\top W_L (A F - b) $$\n这就是“精确”的解析梯度。该公式关键依赖于前向算子的伴随（转置）。如果在梯度公式中错误地使用了非伴随算子，例如用 $J_{\\mathrm{wrong}}^\\top$ 代替 $J_{\\mathrm{phys}}^\\top$，结果将是不正确的。\n\n我们将解析梯度与中心有限差分近似进行验证，后者是梯度检验的黄金标准。正确解析梯度与有限差分之间的相对误差 $E_{\\mathrm{true}}$ 应该很小，受限于浮点精度和有限差分格式的近似误差。相反，对于不正确计算的梯度，其误差 $E_{\\mathrm{wrong}}$ 将会很大，这表明在灵敏度分析和优化中使用正确推导的伴随算子至关重要。", "answer": "```python\nimport numpy as np\n\ndef phi(r_in):\n    \"\"\"\n    Computes the 4-point Peskin kernel (regularized Dirac delta function).\n    This function is piecewise and continuous, with support over |r| = 2.\n\n    Args:\n        r_in (np.ndarray): Input values.\n\n    Returns:\n        np.ndarray: The kernel values.\n    \"\"\"\n    r = np.abs(r_in)\n    val = np.zeros_like(r, dtype=float)\n    \n    # Case a: 0 = |r| = 1\n    mask1 = r = 1\n    r1 = r[mask1]\n    val[mask1] = (1/8) * (3 - 2*r1 + np.sqrt(1 + 4*r1 - 4*r1**2))\n    \n    # Case b: 1  |r| = 2\n    mask2 = (r > 1)  (r = 2)\n    r2 = r[mask2]\n    val[mask2] = (1/8) * (5 - 2*r2 - np.sqrt(-7 + 12*r2 - 4*r2**2))\n    \n    # Case c: |r| > 2 is implicitly zero\n    return val\n\ndef periodic_diff(coords1, coords2, domain_size=1.0):\n    \"\"\"\n    Calculates the shortest periodic difference vector.\n    Handles broadcasting between coordinate arrays.\n\n    Args:\n        coords1 (np.ndarray): First set of coordinates, shape (P, D).\n        coords2 (np.ndarray): Second set of coordinates, shape (Q, D).\n        domain_size (float): The size of the periodic domain.\n\n    Returns:\n        np.ndarray: The difference vectors, shape (P, Q, D).\n    \"\"\"\n    diff = coords1[:, None, :] - coords2[None, :, :]\n    return diff - domain_size * np.round(diff / domain_size)\n\ndef solve_symmetry_cases(N, M, xc, yc, R):\n    \"\"\"\n    Solves for Cases 1 and 2: Symmetry verification of IB operators.\n\n    Args:\n        N (int): Grid dimension.\n        M (int): Number of markers.\n        xc, yc (float): Circle center coordinates.\n        R (float): Circle radius.\n\n    Returns:\n        tuple[float, float]: The Frobenius norms of the differences for\n                             the matched and wrong interpolation operators.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Eulerian grid setup\n    grid_pts = np.arange(N) * h\n    grid_x, grid_y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n    grid_coords = np.stack((grid_x.ravel(), grid_y.ravel()), axis=-1)\n    \n    # Lagrangian marker setup\n    thetas = 2 * np.pi * np.arange(M) / M\n    marker_coords = np.zeros((M, 2))\n    marker_coords[:, 0] = xc + R * np.cos(thetas)\n    marker_coords[:, 1] = yc + R * np.sin(thetas)\n    \n    # Quadrature weights\n    ds = 2 * np.pi * R / M\n    w_L_vals = np.full(M, ds)\n    \n    # Interaction terms\n    diffs = periodic_diff(grid_coords, marker_coords)\n    phi_x = phi(diffs[..., 0] / h)\n    phi_y = phi(diffs[..., 1] / h)\n    delta_h_prod = phi_x * phi_y\n    \n    # Operator construction\n    # S_phys is N^2 x M\n    S_phys = (w_L_vals[None, :] / (h**2)) * delta_h_prod\n    # J_phys is M x N^2\n    J_phys = (h**2) * delta_h_prod.T\n    # J_wrong is M x N^2, omitting the h^2 factor from the integral\n    J_wrong = delta_h_prod.T\n\n    \n    # Symmetrically weighted operators\n    sqrt_w_L = np.sqrt(w_L_vals)\n    # S_tilde = (h I) S_phys (diag(w_L)^-1/2)\n    S_tilde = h * S_phys / sqrt_w_L[None, :]\n    # J_tilde = (diag(w_L)^1/2) J_phys (h I)^-1/2\n    J_tilde = (1/h) * sqrt_w_L[:, None] * J_phys\n    J_tilde_wrong = (1/h) * sqrt_w_L[:, None] * J_wrong\n    \n    # Compute Frobenius norms\n    E_sym_matched = np.linalg.norm(J_tilde - S_tilde.T, 'fro')\n    E_sym_wrong = np.linalg.norm(J_tilde_wrong - S_tilde.T, 'fro')\n    \n    return E_sym_matched, E_sym_wrong\n\ndef solve_gradient_case(N, M, xc, yc, R, seed, eps):\n    \"\"\"\n    Solves for Case 3: Gradient accuracy of an objective function.\n\n    Args:\n        N, M, xc, yc, R: Problem parameters.\n        seed (int): Seed for random number generator.\n        eps (float): Step size for finite differences.\n\n    Returns:\n        tuple[float, float]: Relative errors of the 'true' and 'wrong' gradients.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Grid and marker setup\n    grid_pts = np.arange(N) * h\n    grid_x, grid_y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n    grid_coords = np.stack((grid_x.ravel(), grid_y.ravel()), axis=-1)\n    \n    thetas = 2 * np.pi * np.arange(M) / M\n    marker_coords = np.zeros((M, 2))\n    marker_coords[:, 0] = xc + R * np.cos(thetas)\n    marker_coords[:, 1] = yc + R * np.sin(thetas)\n    \n    # Weights and interaction terms\n    ds = 2 * np.pi * R / M\n    w_L_vals = np.full(M, ds)\n    W_L = np.diag(w_L_vals)\n    \n    diffs = periodic_diff(grid_coords, marker_coords)\n    delta_h_prod = phi(diffs[..., 0] / h) * phi(diffs[..., 1] / h)\n    \n    # Operator construction\n    S_phys = (w_L_vals[None, :] / (h**2)) * delta_h_prod\n    J_phys = (h**2) * delta_h_prod.T\n    J_wrong = delta_h_prod.T\n\n    # System operator A\n    A = J_phys @ S_phys\n    \n    # Random vectors for reproducibility\n    rng = np.random.default_rng(seed)\n    b = rng.random(M)\n    F_vec = rng.random(M)\n    \n    def objective_Phi(force_vec):\n        residual = A @ force_vec - b\n        return 0.5 * (residual.T @ W_L @ residual)\n\n    # Analytical gradients\n    residual_at_F = A @ F_vec - b\n    grad_Phi_exact = S_phys.T @ J_phys.T @ (W_L @ residual_at_F)\n    grad_Phi_wrong = S_phys.T @ J_wrong.T @ (W_L @ residual_at_F)\n    \n    # Finite difference gradient\n    grad_Phi_fd = np.zeros(M)\n    for k in range(M):\n        F_plus = F_vec.copy()\n        F_plus[k] += eps\n        F_minus = F_vec.copy()\n        F_minus[k] -= eps\n        \n        phi_plus = objective_Phi(F_plus)\n        phi_minus = objective_Phi(F_minus)\n        \n        grad_Phi_fd[k] = (phi_plus - phi_minus) / (2 * eps)\n        \n    # Relative errors\n    norm_fd = np.linalg.norm(grad_Phi_fd)\n    E_true = np.linalg.norm(grad_Phi_exact - grad_Phi_fd) / norm_fd\n    E_wrong = np.linalg.norm(grad_Phi_wrong - grad_Phi_fd) / norm_fd\n\n    return E_true, E_wrong\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    # Test cases defined in the problem statement.\n    test_cases = {\n        \"case1_2\": {\"N\": 16, \"M\": 20, \"xc\": 0.15, \"yc\": 0.85, \"R\": 0.22},\n        \"case3\": {\"N\": 24, \"M\": 28, \"xc\": 0.07, \"yc\": 0.11, \"R\": 0.19, \"seed\": 42, \"eps\": 1e-6}\n    }\n    \n    # Case 1  2\n    params12 = test_cases[\"case1_2\"]\n    E_sym_matched, E_sym_wrong = solve_symmetry_cases(\n        params12[\"N\"], params12[\"M\"], params12[\"xc\"], params12[\"yc\"], params12[\"R\"]\n    )\n    \n    # Case 3\n    params3 = test_cases[\"case3\"]\n    E_true, E_wrong_grad = solve_gradient_case(\n        params3[\"N\"], params3[\"M\"], params3[\"xc\"], params3[\"yc\"], params3[\"R\"], \n        params3[\"seed\"], params3[\"eps\"]\n    )\n    \n    results = [E_sym_matched, E_sym_wrong, E_true, E_wrong_grad]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3332853"}]}