{"hands_on_practices": [{"introduction": "在将数值格式应用于复杂问题之前，深刻理解其基本精度和误差特性至关重要。本练习将指导您通过数值实验，量化线性平流方程中心差分格式的收敛阶。通过一种精巧的技术——分离空间和时间误差源——您将能更深入地洞察该格式的行为，并理解在固定 Courant–Friedrichs–Lewy (CFL) 数下，空间和时间离散化分别对总误差的贡献。[@problem_id:3298150]", "problem": "考虑在周期性域上的常数速度线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\,\\frac{\\partial u}{\\partial x} = 0,\\quad x \\in [0,2\\pi),\\ t \\ge 0,\n$$\n其边界条件为周期性边界条件。设人造精确解为\n$$\nu(x,t) = \\sin(k x - a t),\n$$\n该解在 $x$ 方向上是 $2\\pi$ 周期的，并且所有角度都使用弧度。所有变量均为无量纲。您将研究在均匀网格上用于对流的二阶中心差分格式，并在固定的 Courant–Friedrichs–Lewy (CFL) 数下，量化 $L^2$ 误差与网格间距 $\\Delta x$ 的关系，同时分离空间和时间误差的贡献。\n\n从上述守恒律和在间距为 $\\Delta x$ 的均匀网格上的二阶中心差分算子的定义出发，\n$$\n(D_c u)_j \\equiv \\frac{u_{j+1} - u_{j-1}}{2\\,\\Delta x},\n$$\n得到线方法半离散系统为\n$$\n\\frac{d \\mathbf{u}}{dt} = -a\\, D_c \\mathbf{u},\n$$\n其中 $\\mathbf{u}$ 是周期性网格上节点值的向量。对于时间积分，使用经典的四阶 Runge–Kutta 方法。\n\n您的程序必须对下面指定的每个测试用例，以及给定网格细化集中的每个网格尺寸 $N$，在固定的 Courant–Friedrichs–Lewy (CFL) 数确定的时间步长下，计算在共同的最终时间 $T$ 时的以下量：\n- 仅空间误差，通过在离散傅里叶基中对角化循环中心差分算子，对半离散系统进行精确的时间积分得到。这将得到精确时间积分的半离散解 $\\mathbf{u}_{\\text{space}}(T;\\Delta x)$，其与网格上采样的解析解之差可以分离出空间离散误差。\n- 仅时间误差，通过使用经典的四阶 Runge–Kutta 方法进行时间积分，同时在每个阶段通过周期性网格上的谱微分（即，使用离散傅里叶变换计算网格上所有可表示的傅里叶模式的精确导数 $\\partial u/\\partial x$）来应用精确的空间导数算子。这将得到 $\\mathbf{u}_{\\text{time}}(T;\\Delta x)$，其与网格上采样的解析解之差可以分离出时间离散误差。\n- 总误差，通过使用经典的四阶 Runge–Kutta 方法进行时间积分，同时在每个阶段应用二阶中心差分算子得到。这将得到 $\\mathbf{u}_{\\text{total}}(T;\\Delta x)$，其与网格上采样的解析解之差结合了空间和时间误差。\n\n对于每个数值解 $\\mathbf{u}_{\\text{num}} \\in \\{\\mathbf{u}_{\\text{space}},\\mathbf{u}_{\\text{time}},\\mathbf{u}_{\\text{total}}\\}$，计算相对于网格上采样的精确解的离散 $L^2$ 误差，\n$$\nE_{L^2}(\\Delta x) \\equiv \\left(\\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\text{num}}(x_j,T) - u(x_j,T)\\right]^2\\right)^{1/2},\n$$\n其中 $x_j = j\\,\\Delta x$ 且 $\\Delta x = \\frac{2\\pi}{N}$。\n\n时间步进必须使用由固定的 Courant–Friedrichs–Lewy (CFL) 数确定的时间步长 $\\Delta t$，\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|},\n$$\n如有必要，最后一步将缩短以精确达到时间 $T$。角度必须以弧度为单位。\n\n在一个完整的、可运行的程序中实现上述内容，该程序为每个测试用例的每个网格尺寸 $N$ 返回一个元组，其中包含网格间距和三个 $L^2$ 误差：\n$$\n\\left[\\Delta x,\\ E^{\\text{space}}_{L^2}(\\Delta x),\\ E^{\\text{time}}_{L^2}(\\Delta x),\\ E^{\\text{total}}_{L^2}(\\Delta x)\\right].\n$$\n\n测试套件：\n- 用例 1：$a = 1.0$, $k = 4$, $\\text{CFL} = 0.5$, $T = 1.0$, $N \\in \\{64, 128, 256, 512\\}$。\n- 用例 2：$a = 1.0$, $k = 16$, $\\text{CFL} = 0.5$, $T = 1.0$, $N \\in \\{64, 128, 256, 512\\}$。\n- 用例 3：$a = 0.3$, $k = 3$, $\\text{CFL} = 0.9$, $T = 2.0$, $N \\in \\{64, 128, 256, 512\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个有效的 JSON 数组形式的结果。顶层是按上述顺序排列的测试用例列表。每个测试用例包含一个按升序排列的网格尺寸 $N$ 的列表。每个元素是该 $N$ 对应的列表 $\\left[\\Delta x,E^{\\text{space}}_{L^2},E^{\\text{time}}_{L^2},E^{\\text{total}}_{L^2}\\right]$。例如，一个包含两个网格尺寸的输出将如下所示\n$$\n\\left[\\left[[\\Delta x_1,E^{\\text{space}}_{L^2}(\\Delta x_1),E^{\\text{time}}_{L^2}(\\Delta x_1),E^{\\text{total}}_{L^2}(\\Delta x_1)],\\ [\\Delta x_2,E^{\\text{space}}_{L^2}(\\Delta x_2),E^{\\text{time}}_{L^2}(\\Delta x_2),E^{\\text{total}}_{L^2}(\\Delta x_2)]\\right],\\ \\dots\\right]\n$$\n其中填入了实际的数值。所有数字必须以标准浮点表示法打印为小数。角度以弧度为单位，此问题中没有物理单位。", "solution": "该问题要求对线性平流方程的二阶中心差分格式的误差特性进行数值研究。该分析涉及将总数值误差分离为其空间和时间分量。这是通过设计三个不同的数值实验来实现的：一个在时间上精确以分离空间误差，一个在空间上精确以分离时间误差，以及一个对两者都使用数值近似以捕捉总误差。\n\n控制偏微分方程 (PDE) 是一维常数速度 $a$ 的线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\,\\frac{\\partial u}{\\partial x} = 0\n$$\n区域是周期性的，$x \\in [0,2\\pi)$，我们考虑时间 $t \\ge 0$。提供了一个人造解用于验证和误差分析：\n$$\nu(x,t) = \\sin(k x - a t)\n$$\n其中 $k$ 是波数。该解在 $x$ 方向上是 $2\\pi$ 周期的，并满足该偏微分方程。\n\n数值解在由 $N$ 个点组成的均匀网格上求解，$x_j = j\\,\\Delta x$，$j=0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = 2\\pi/N$。采用线方法 (MOL)，首先对空间导数进行离散化，从而得到一个关于时间的常微分方程组 (ODEs)。空间离散化使用二阶中心差分算子 $D_c$：\n$$\n\\left(D_c u\\right)_j = \\frac{u_{j+1} - u_{j-1}}{2\\,\\Delta x}\n$$\n这导出了半离散系统：\n$$\n\\frac{d \\mathbf{u}}{dt} = -a\\, D_c \\mathbf{u}\n$$\n其中 $\\mathbf{u}(t)$ 是节点值的向量 $[u(x_0, t), u(x_1, t), \\dots, u(x_{N-1}, t)]^T$。对于时间积分，指定了经典的四阶 Runge–Kutta (RK4) 方法。时间步长 $\\Delta t$ 由固定的 Courant–Friedrichs–Lewy (CFL) 数确定：\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|}\n$$\n模拟运行直到最终时间 $T$。误差使用离散 $L^2$ 范数进行量化，定义为：\n$$\nE_{L^2}(\\Delta x) = \\left(\\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\text{num}}(x_j,T) - u(x_j,T)\\right]^2\\right)^{1/2}\n$$\n\n问题的核心是计算在最终时间 $T$ 的三种类型的误差。\n\n1.  **仅空间误差 ($E^{\\text{space}}_{L^2}$)**：\n    为了分离空间离散化带来的误差，我们对半离散系统 $\\frac{d \\mathbf{u}}{dt} = -a D_c \\mathbf{u}$ 进行精确的时间求解。这是一个线性常微分方程组，$\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}$，其中矩阵 $\\mathbf{A}$ 代表算子 $-a D_c$。其精确解为 $\\mathbf{u}(T) = e^{\\mathbf{A}T} \\mathbf{u}(0)$。由于 $D_c$ 在周期性网格上是一个循环矩阵，因此可以通过离散傅里叶变换 (DFT) 对角化 $\\mathbf{A}$ 来高效地计算矩阵指数。\n    算子 $-a D_c$ 的特征值可以通过将其应用于傅里叶模式 $e^{imx}$ 来找到，其中 $m$ 是一个整数波数。\n    $$\n    -a D_c e^{imx} = -a \\frac{e^{im(x+\\Delta x)} - e^{im(x-\\Delta x)}}{2\\Delta x} = -a \\frac{i \\sin(m \\Delta x)}{\\Delta x} e^{imx}\n    $$\n    因此，对应于波数 $m$ 的特征值 $\\lambda_m$ 是 $\\lambda_m = -ia \\frac{\\sin(m \\Delta x)}{\\Delta x}$。这个项通常被称为离散算子的符号。每个傅里叶系数 $\\hat{u}_m(t)$ 的精确演化由 $\\frac{d\\hat{u}_m}{dt} = \\lambda_m \\hat{u}_m$ 给出，从而得到 $\\hat{u}_m(T) = \\hat{u}_m(0) e^{\\lambda_m T}$。\n    算法如下：\n    a. 通过在网格上采样 $u(x,0)=\\sin(kx)$ 来计算初始条件向量 $\\mathbf{u}(0)$。\n    b. 计算其 DFT 以获得初始傅里叶系数 $\\hat{\\mathbf{u}}(0)$。\n    c. 对于网格上可表示的每个波数 $m$，将相应的系数 $\\hat{u}_m(0)$ 乘以演化因子 $e^{\\lambda_m T}$。\n    d. 对得到的系数进行逆 DFT 计算，以获得解向量 $\\mathbf{u}_{\\text{space}}(T)$。\n    e. 根据网格上采样的精确解 $u(x,T)$ 计算 $L^2$ 误差 $E^{\\text{space}}_{L^2}$。\n\n2.  **仅时间误差 ($E^{\\text{time}}_{L^2}$)**：\n    为了分离时间积分带来的误差，对于网格可以表示的所有傅里叶模式，PDE 中的空间导数被精确计算。这被称为谱微分。半离散系统变为 $\\frac{d \\mathbf{u}}{dt} = -a \\frac{\\partial \\mathbf{u}}{\\partial x}_{\\text{exact}}$，然后使用 RK4 方法进行积分。带限函数的精确导数在傅里叶空间中计算。$u(x) = \\sum_m \\hat{u}_m e^{imx}$ 的导数是 $\\frac{\\partial u}{\\partial x} = \\sum_m (im) \\hat{u}_m e^{imx}$。\n    每个 RK4 阶段的算法是：\n    a. 给定状态向量 $\\mathbf{v}$，计算其 DFT $\\hat{\\mathbf{v}}$。\n    b. 将每个系数 $\\hat{v}_m$ 乘以 $im$。\n    c. 计算逆 DFT 以获得精确的导数向量 $\\frac{\\partial \\mathbf{v}}{\\partial x}$。\n    d. ODE 求解器的右侧项则为 $-a \\frac{\\partial \\mathbf{v}}{\\partial x}$。\n    从 $\\mathbf{u}(0)$ 开始，重复此过程所需的步数，以获得 $\\mathbf{u}_{\\text{time}}(T)$。然后计算 $L^2$ 误差 $E^{\\text{time}}_{L^2}$。\n\n3.  **总误差 ($E^{\\text{total}}_{L^2}$)**：\n    这是标准的数值模拟，其中空间和时间都被离散化。半离散系统 $\\frac{d \\mathbf{u}}{dt} = -a D_c \\mathbf{u}$ 使用 RK4 方法进行积分。在每个 RK4 阶段，通过将中心差分算子 $D_c$ 应用于当前状态向量来计算右侧项。这会产生解 $\\mathbf{u}_{\\text{total}}(T)$，由此可以计算出总误差 $E^{\\text{total}}_{L^2}$。\n\n通过在一系列细化的网格（增加 $N$）上计算这三种误差度量，我们可以分析空间、时间和组合格式的收敛率。空间格式是二阶的，因此 $E^{\\text{space}}_{L^2}$ 应与 $(\\Delta x)^2$ 成比例。RK4 积分器是四阶的，因此 $E^{\\text{time}}_{L^2}$ 应与 $(\\Delta t)^4$ 成比例，对于固定的 CFL 数，这与 $(\\Delta x)^4$ 成比例。总误差通常由低阶分量主导，因此预计 $E^{\\text{total}}_{L^2}$ 将与 $(\\Delta x)^2$ 成比例。", "answer": "```python\nimport numpy as np\nimport json\nimport math\n\ndef calculate_spatial_solution(u0, a, T, N, dx):\n    \"\"\"\n    Computes the semi-discrete solution integrated exactly in time.\n    This isolates the spatial discretization error.\n    \"\"\"\n    # DFT of initial condition\n    u0_hat = np.fft.fft(u0)\n    \n    # Integer wavenumbers corresponding to FFT output\n    m = np.fft.fftfreq(N) * N\n    \n    # Symbol of the central difference operator (modified wavenumber)\n    # Handle m=0 case to avoid 0/0, though sin(0)/dx is 0 anyway.\n    # The term is i * sin(m*dx)/dx. The evolution is exp(-a * T * i * sin(m*dx)/dx)\n    m_modified = np.zeros_like(m, dtype=float)\n    non_zero_m = m != 0\n    m_modified[non_zero_m] = np.sin(m[non_zero_m] * dx) / dx\n    \n    # Evolve each Fourier mode exactly in time\n    evolution_operator = np.exp(-1j * a * m_modified * T)\n    uT_hat = u0_hat * evolution_operator\n    \n    # Inverse DFT to get the solution in physical space\n    uT = np.fft.ifft(uT_hat)\n    \n    return uT.real\n\ndef rk4_step(rhs_func, u, dt, *args):\n    \"\"\"A single step of the classical 4th-order Runge-Kutta method.\"\"\"\n    k1 = rhs_func(u, *args)\n    k2 = rhs_func(u + dt / 2.0 * k1, *args)\n    k3 = rhs_func(u + dt / 2.0 * k2, *args)\n    k4 = rhs_func(u + dt * k3, *args)\n    return u + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef spectral_rhs(u, a, N):\n    \"\"\"RHS function using spectral differentiation for -a * du/dx.\"\"\"\n    u_hat = np.fft.fft(u)\n    m = np.fft.fftfreq(N) * N\n    du_dx_hat = 1j * m * u_hat\n    du_dx = np.fft.ifft(du_dx_hat)\n    return -a * du_dx\n\ndef calculate_temporal_solution(u0, a, T, N, dt):\n    \"\"\"\n    Computes the solution using RK4 in time and spectral differentiation in space.\n    This isolates the temporal discretization error.\n    \"\"\"\n    u = u0.copy().astype(np.complex128)\n    t = 0.0\n    num_steps = math.floor(T / dt)\n    \n    for _ in range(num_steps):\n        u = rk4_step(spectral_rhs, u, dt, a, N)\n        t += dt\n        \n    # Final shortened step to hit T exactly\n    if T - t > 1e-12:\n        dt_final = T - t\n        u = rk4_step(spectral_rhs, u, dt_final, a, N)\n        \n    return u.real\n\ndef central_diff_rhs(u, a, dx):\n    \"\"\"RHS function using 2nd-order central differences for -a * du/dx.\"\"\"\n    du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2.0 * dx)\n    return -a * du_dx\n\ndef calculate_total_solution(u0, a, T, dx, dt):\n    \"\"\"\n    Computes the solution using RK4 in time and central differences in space.\n    This captures the total numerical error.\n    \"\"\"\n    u = u0.copy()\n    t = 0.0\n    num_steps = math.floor(T / dt)\n    \n    for _ in range(num_steps):\n        u = rk4_step(central_diff_rhs, u, dt, a, dx)\n        t += dt\n\n    # Final shortened step to hit T exactly\n    if T - t > 1e-12:\n        dt_final = T - t\n        u = rk4_step(central_diff_rhs, u, dt_final, a, dx)\n        \n    return u.real\n\ndef compute_errors_for_case(a, k, CFL, T, N):\n    \"\"\"\n    Main computation for a single grid size N.\n    Sets up the problem and computes the three error types.\n    \"\"\"\n    # Grid and initial conditions\n    dx = 2.0 * np.pi / N\n    x = np.arange(N) * dx\n    u_initial = np.sin(k * x)\n    u_exact_final = np.sin(k * x - a * T)\n    dt = CFL * dx / np.abs(a)\n\n    # 1. Spatial-only error\n    u_space = calculate_spatial_solution(u_initial, a, T, N, dx)\n    error_space = np.sqrt(dx * np.sum((u_space - u_exact_final)**2))\n    \n    # 2. Temporal-only error\n    u_time = calculate_temporal_solution(u_initial, a, T, N, dt)\n    error_time = np.sqrt(dx * np.sum((u_time - u_exact_final)**2))\n\n    # 3. Total error\n    u_total = calculate_total_solution(u_initial, a, T, dx, dt)\n    error_total = np.sqrt(dx * np.sum((u_total - u_exact_final)**2))\n    \n    return [dx, error_space, error_time, error_total]\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'a': 1.0, 'k': 4,  'CFL': 0.5, 'T': 1.0, 'N_list': [64, 128, 256, 512]},\n        {'a': 1.0, 'k': 16, 'CFL': 0.5, 'T': 1.0, 'N_list': [64, 128, 256, 512]},\n        {'a': 0.3, 'k': 3,  'CFL': 0.9, 'T': 2.0, 'N_list': [64, 128, 256, 512]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        for N in case['N_list']:\n            result_tuple = compute_errors_for_case(\n                case['a'], case['k'], case['CFL'], case['T'], N\n            )\n            case_results.append(result_tuple)\n        all_results.append(case_results)\n\n    # Print the final result in the specified JSON format on a single line\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```", "id": "3298150"}, {"introduction": "虽然中心差分格式具有二阶精度，但它在处理对流主导问题时存在一个众所周知的缺陷。本练习将探索一个稳态对流-扩散问题，揭示当对流输运远大于扩散输运时，数值解中如何产生非物理性的振荡。通过这个实践，您将接触到关键的单元佩克莱数（cell Peclet number）概念，并亲眼见证为何纯粹的中心差分格式通常不适用于高速流动模拟。[@problem_id:3298174]", "problem": "考虑一个在一维单位区间 $x \\in [0,1]$ 上输运的标量场 $\\phi(x)$ 的稳态、常系数对流-扩散边界值问题：\n$$\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0,$$\n边界条件为狄利克雷（Dirichlet）边界数据，在区域端点上施加一个单位阶跃，\n$$\\phi(0) = 1,\\quad \\phi(1) = 0.$$\n从控制体上的 $\\phi$ 守恒以及扩散通量和对流通量的定义出发，使用有限体积法（FVM），配合均匀网格和用于计算交界面值的中心差分格式（CDS），为内部节点构建离散代数方程。设单元佩克莱数（Peclet number）定义为\n$$\\mathrm{Pe} \\equiv \\frac{\\rho u\\,\\Delta x}{\\Gamma},$$\n其中 $\\Delta x$ 是均匀的单元宽度。使用此离散化方法，实现一个求解器，对于给定的内部节点数 $n$ 和指定的 $\\mathrm{Pe}$，计算离散解向量 $\\{\\phi_i\\}_{i=0}^{n+1}$，其中 $\\phi_0 = 1$ 和 $\\phi_{n+1} = 0$ 是边界值，$\\{\\phi_i\\}_{i=1}^{n}$ 是内部未知数。从第一性原理出发，论证离散系数如何从通量平衡和中心插值中产生，并解释当 $|\\mathrm{Pe}|$ 足够大时，为什么离散解可能会出现非物理振荡（非单调性和超出区间 $[0,1]$ 的过冲）。\n\n实现一个程序，该程序：\n- 对于给定的 $\\mathrm{Pe}$ 和 $n$，在均匀网格上为 FVM-CDS 离散化建立并求解三对角线性系统。\n- 基于两种诊断方法报告是否存在非物理振荡：\n  1. 单调性：对于边界数据 $\\phi(0)=1$ 和 $\\phi(1)=0$，物理上可接受的解是单调递减的。设离散差分为 $d_i = \\phi_i - \\phi_{i-1}$，其中 $i \\in \\{1,2,\\dots,n+1\\}$。如果存在某个 $i$ 使得 $d_i > \\varepsilon$（其中 $\\varepsilon$ 是一个很小的容差），则声明解为非单调。\n  2. 有界性：如果 $\\max_i \\phi_i > 1 + \\varepsilon$ 或 $\\min_i \\phi_i  0 - \\varepsilon$，则声明存在过冲。将最大过冲幅度量化为\n  $$\\max\\left(\\max_i \\phi_i - 1,\\; 0,\\; 0 - \\min_i \\phi_i\\right),$$\n  解释为一个非负实数。\n- 为每个测试用例聚合一个包含四个项目的结果：\n  1. 一个布尔值，指示是否检测到振荡（如果出现非单调性或过冲，则为 true），\n  2. 一个浮点数，等于最大过冲幅度，\n  3. 一个浮点数，等于超额总变差，定义为 $\\left(\\sum_{i=1}^{n+1} |d_i|\\right) - 1$，\n  4. 完整的离散解向量 $[\\phi_0, \\phi_1, \\dots, \\phi_{n+1}]$。\n\n你的程序应使用 $\\varepsilon = 10^{-12}$ 的容差进行诊断，并且应将所有报告的浮点数（项目2和3，以及离散解向量的所有条目）在最终输出中四舍五入到6位小数。\n\n测试套件：\n为以下五个参数集 $(\\mathrm{Pe}, n)$ 提供结果，所有测试中边界值均为 $\\phi(0)=1$ 和 $\\phi(1)=0$：\n- 情况 A（理想情况，扩散主导）：$(\\mathrm{Pe}, n) = (0, 8)$。\n- 情况 B（阈值）：$(\\mathrm{Pe}, n) = (2, 8)$。\n- 情况 C（对流主导，正向流动）：$(\\mathrm{Pe}, n) = (4, 8)$。\n- 情况 D（对流主导，反向流动）：$(\\mathrm{Pe}, n) = (-4, 8)$。\n- 情况 E（中等对流）：$(\\mathrm{Pe}, n) = (1.5, 8)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，按 A 到 E 的顺序排列。每个结果本身必须是一个列表，形式为 $[\\text{oscillatory},\\ \\text{overshoot},\\ \\text{variation\\_excess},\\ \\text{solution}]$，其中 $\\text{oscillatory}$ 是一个布尔值，$\\text{overshoot}$ 和 $\\text{variation\\_excess}$ 是四舍五入到6位小数的浮点数，$\\text{solution}$ 是一个四舍五入到6位小数的浮点数列表。例如，一个语法上有效的输出结构是\n$$\\big[\\ [\\text{True},\\ 0.123456,\\ 0.234567,\\ [1.000000, \\dots, 0.000000]],\\ \\dots\\ \\big].$$", "solution": "问题陈述被评估为有效。它提出了一个来自计算流体动力学领域的适定、有科学依据的边界值问题，并要求进行标准的数值求解和分析。所有必要的数据和定义都已提供，前提条件一致且符合事实。\n\n### 离散代数方程的推导\n\n我们从标量场 $\\phi(x)$ 的一维、稳态、常系数对流-扩散方程开始：\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0\n$$\n其中 $\\Gamma$ 是扩散系数，$\\rho$ 是密度， $u$ 是速度。通过将总通量 $J(x)$ 定义为扩散通量 $J_D(x) = -\\Gamma \\frac{d\\phi}{dx}$ 和对流通量 $J_C(x) = \\rho u \\phi$ 之和，该方程可以写成守恒形式。控制方程等价于声明总通量的散度为零：\n$$\n\\frac{dJ}{dx} = 0 \\quad \\text{其中} \\quad J(x) = J_C(x) + J_D(x) = \\rho u \\phi(x) - \\Gamma \\frac{d\\phi}{dx}\n$$\n\n有限体积法（FVM）的基础是在覆盖整个区域的一组控制体积（或单元）上，以积分形式强制执行守恒定律。我们考虑在区域 $x \\in [0, 1]$ 上的一个均匀网格。该区域被划分为 $n$ 个内部单元，对应于 $n$ 个内部节点，索引为 $i=1, 2, \\dots, n$。节点位于单元中心。边界节点位于 $x_0=0$ 和 $x_{n+1}=1$。均匀单元宽度为 $\\Delta x = 1/(n+1)$。节点 $i$ 的控制体积从其西侧面 $w$（位于 $x_{i-1/2}$）延伸到其东侧面 $e$（位于 $x_{i+1/2}$）。\n\n将守恒定律 $\\frac{dJ}{dx} = 0$ 在节点 $i$ 的控制体积上积分，得到：\n$$\n\\int_{w}^{e} \\frac{dJ}{dx} dx = 0\n$$\n根据微积分基本定理，这变成了一个简单的单元面通量平衡：\n$$\nJ_e - J_w = 0\n$$\n其中 $J_e = J(x_{i+1/2})$ 和 $J_w = J(x_{i-1/2})$ 分别是东侧面和西侧面的总通量。\n\n下一步是近似这些面通量。中心差分格式（CDS）通过在相邻的单元中心节点之间进行线性插值来近似单元面上的值。\n位于 $x_{i+1/2}$ 的东侧面 $e$ 上的通量为 $J_e = (\\rho u \\phi)_e - (\\Gamma \\frac{d\\phi}{dx})_e$。使用 CDS：\n- 标量值 $\\phi_e$ 通过对节点 $i$ 和 $i+1$ 处的值取平均来近似：$\\phi_e \\approx \\frac{\\phi_i + \\phi_{i+1}}{2}$。\n- 梯度 $(\\frac{d\\phi}{dx})_e$ 使用以面为中心的中心差分来近似：$(\\frac{d\\phi}{dx})_e \\approx \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}$。\n\n将这些代入 $J_e$ 的表达式中：\n$$\nJ_e \\approx \\rho u \\left(\\frac{\\phi_i + \\phi_{i+1}}{2}\\right) - \\Gamma \\left(\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\\right)\n$$\n类似地，位于 $x_{i-1/2}$ 的西侧面 $w$ 上的通量使用节点 $i-1$ 和 $i$ 来近似：\n$$\nJ_w \\approx \\rho u \\left(\\frac{\\phi_{i-1} + \\phi_i}{2}\\right) - \\Gamma \\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right)\n$$\n将这些通量近似值代入平衡方程 $J_e - J_w = 0$：\n$$\n\\left[ \\rho u \\frac{\\phi_i + \\phi_{i+1}}{2} - \\Gamma \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} \\right] - \\left[ \\rho u \\frac{\\phi_{i-1} + \\phi_i}{2} - \\Gamma \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} \\right] = 0\n$$\n我们现在收集乘以 $\\phi_{i-1}$、$\\phi_i$ 和 $\\phi_{i+1}$ 的项：\n$$\n\\left(\\frac{\\Gamma}{\\Delta x} - \\frac{\\rho u}{2}\\right)\\phi_{i+1} + \\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\Gamma}{\\Delta x}\\right)\\phi_i - \\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\rho u}{2}\\right)\\phi_{i-1} = 0\n$$\n重新排列并乘以 $-1$ 以遵循惯例，得到标准的三点差分格式：\n$$\n\\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\rho u}{2}\\right)\\phi_{i-1} - \\left(\\frac{2\\Gamma}{\\Delta x}\\right)\\phi_i + \\left(\\frac{\\Gamma}{\\Delta x} - \\frac{\\rho u}{2}\\right)\\phi_{i+1} = 0\n$$\n为了简化，我们将整个方程除以 $\\Gamma/\\Delta x$，并引入无量纲的单元佩克莱数 $\\mathrm{Pe} \\equiv \\frac{\\rho u \\Delta x}{\\Gamma}$，它代表了单元尺度上对流与扩散输运强度的比率。\n$$\n\\left(1 + \\frac{\\rho u \\Delta x}{2\\Gamma}\\right)\\phi_{i-1} - 2\\phi_i + \\left(1 - \\frac{\\rho u \\Delta x}{2\\Gamma}\\right)\\phi_{i+1} = 0\n$$\n这就得到了内部节点 $i$ 的最终离散代数方程：\n$$\n\\left(1 + \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i-1} - 2\\phi_i + \\left(1 - \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i+1} = 0\n$$\n该方程对每个内部节点 $i=1, \\dots, n$ 均有效。对于 $i=1$，$\\phi_{i-1}$ 是已知的边界值 $\\phi_0 = 1$。对于 $i=n$，$\\phi_{i+1}$ 是已知的边界值 $\\phi_{n+1}=0$。这些代入产生了一个包含 $n$ 个线性方程的三对角系统，用于求解 $n$ 个未知的内部值 $\\{\\phi_i\\}_{i=1}^n$。\n\n### 非物理振荡的起源\n\n离散方程可以重新排列，以将 $\\phi_i$ 表示为其相邻节点的函数：\n$$\n\\phi_i = \\frac{1}{2}\\left(1 + \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i-1} + \\frac{1}{2}\\left(1 - \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i+1}\n$$\n为了使解在物理上是现实的（即有界且单调，与具有给定边界条件的二阶微分方程的物理特性一致），节点 $\\phi_i$ 的值必须是其相邻节点 $\\phi_{i-1}$ 和 $\\phi_{i+1}$ 的加权平均。这要求加权系数为非负。\n1. $\\phi_{i-1}$ 的系数：$\\frac{1}{2}(1 + \\frac{\\mathrm{Pe}}{2}) \\ge 0 \\implies 1 + \\frac{\\mathrm{Pe}}{2} \\ge 0 \\implies \\mathrm{Pe} \\ge -2$。\n2. $\\phi_{i+1}$ 的系数：$\\frac{1}{2}(1 - \\frac{\\mathrm{Pe}}{2}) \\ge 0 \\implies 1 - \\frac{\\mathrm{Pe}}{2} \\ge 0 \\implies \\mathrm{Pe} \\le 2$。\n\n结合这些条件，只有当 $|\\mathrm{Pe}| \\le 2$ 时，所有系数才为非负。当满足此条件时，该格式保证能产生单调解。\n\n当流动是对流主导，以至于 $|\\mathrm{Pe}| > 2$ 时，其中一个系数变为负数。例如，如果 $\\mathrm{Pe} > 2$，$\\phi_{i+1}$ 的系数为负。此时，$\\phi_i$ 的方程就变成了其相邻节点之间的外插，而不是内插。这可能导致计算出的 $\\phi_i$ 值落在其相邻节点定义的范围之外（例如，$\\phi_i > \\max(\\phi_{i-1}, \\phi_{i+1})$ 或 $\\phi_i  \\min(\\phi_{i-1}, \\phi_{i+1})$）。这种数学特性是非物理振荡（摆动）的根源，包括过冲和下冲，这些是中心差分格式在高对流区域中的典型失效表现。解不再保证是单调的或受边界值限制。这种不稳定性使得在对流主导的问题中必须使用其他更复杂的格式，如迎风差分格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the convection-diffusion problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement: (Pe, n)\n    test_cases = [\n        (0.0, 8),   # Case A: Pure diffusion\n        (2.0, 8),   # Case B: Threshold\n        (4.0, 8),   # Case C: Convection-dominated, forward\n        (-4.0, 8),  # Case D: Convection-dominated, reverse\n        (1.5, 8),   # Case E: Moderate convection\n    ]\n\n    # Global parameters\n    phi_0 = 1.0\n    phi_L = 0.0\n    epsilon = 1e-12\n    \n    results = []\n    \n    for Pe, n_interior in test_cases:\n        # 1. Build and solve the linear system\n        \n        # Coefficients of the discrete equation: c_W*phi_{i-1} + c_P*phi_i + c_E*phi_{i+1} = 0\n        c_W = 1.0 + Pe / 2.0\n        c_P = -2.0\n        c_E = 1.0 - Pe / 2.0\n        \n        # Assemble the n x n tridiagonal matrix A in banded format for SciPy\n        # ab[0,:] = super-diagonal (c_E)\n        # ab[1,:] = main diagonal (c_P)\n        # ab[2,:] = sub-diagonal (c_W)\n        ab = np.zeros((3, n_interior))\n        ab[0, 1:] = c_E\n        ab[1, :] = c_P\n        ab[2, :-1] = c_W\n        \n        # Assemble the right-hand side vector b\n        b = np.zeros(n_interior)\n        # For i=1, the term c_W * phi_0 moves to the RHS\n        b[0] = -c_W * phi_0\n        # For i=n, the term c_E * phi_{n+1} is zero since phi_{n+1}=0\n        \n        # Solve the system A * phi_interior = b\n        phi_interior = scipy.linalg.solve_banded((1, 1), ab, b)\n        \n        # Construct the full solution vector including boundaries\n        phi_full = np.concatenate(([phi_0], phi_interior, [phi_L]))\n        \n        # 2. Perform diagnostics\n        \n        # Monotonicity check\n        # d_i = phi_i - phi_{i-1}. For monotonic decrease, all d_i should be = 0.\n        diffs = np.diff(phi_full)\n        is_non_monotone = np.any(diffs > epsilon)\n        \n        # Boundedness check (overshoot/undershoot)\n        max_phi = np.max(phi_full)\n        min_phi = np.min(phi_full)\n        is_overshoot = (max_phi > 1.0 + epsilon) or (min_phi  0.0 - epsilon)\n        \n        # Oscillation detection\n        oscillatory = is_non_monotone or is_overshoot\n        \n        # Maximum overshoot magnitude\n        overshoot_mag = np.max([max_phi - 1.0, 0.0, 0.0 - min_phi])\n        \n        # Excess total variation\n        # Total variation for monotonic solution from 1 to 0 is 1.\n        total_variation = np.sum(np.abs(diffs))\n        variation_excess = total_variation - 1.0\n        \n        # 3. Format and aggregate results\n        \n        # Round floats to 6 decimal places as required\n        rounded_overshoot = round(overshoot_mag, 6)\n        rounded_variation = round(variation_excess, 6)\n        rounded_solution = [round(x, 6) for x in phi_full]\n\n        case_result = [\n            oscillatory,\n            rounded_overshoot,\n            rounded_variation,\n            rounded_solution\n        ]\n        results.append(case_result)\n\n    # 4. Print the final output in the exact required format\n    # Manually construct the string to ensure exact formatting (spacing, decimals)\n    result_strings = []\n    for res in results:\n        osc_str = str(res[0])\n        ov_str = f\"{res[1]:.6f}\"\n        var_str = f\"{res[2]:.6f}\"\n        sol_str = '[' + ', '.join([f\"{x:.6f}\" for x in res[3]]) + ']'\n        result_strings.append(f\"[{osc_str}, {ov_str}, {var_str}, {sol_str}]\")\n        \n    final_output = '[' + ', '.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3298174"}, {"introduction": "为了解决前述的数值不稳定性问题，现代计算流体力学发展了多种先进格式。最后的这个实践将带领您构建并实现一种混合数值通量，它巧妙地融合了中心差分的精度和耗散格式（如 Rusanov 格式）的稳定性。通过亲手实现一个“光滑度传感器”，您将学会如何自适应地在需要的地方施加数值耗散，从而为包含光滑区域和尖锐间断的复杂问题提供一个既鲁棒又精确的解决方案。[@problem_id:3298134]", "problem": "考虑周期域上的一维线性平流方程的守恒形式，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x\\in[0,1],\\ t\\ge 0,\n$$\n其中平流速度 $a0$ 为常数。所有量均为无量纲，所有角度（例如，正弦函数的参数）均以弧度为单位。在有限体积框架内进行计算，该框架具有宽度为 $\\Delta x$ 的均匀单元，以及位于单元中心的单元平均未知数 $u_i(t)$。单元上的积分守恒律意味着\n$$\n\\frac{d}{dt}u_i(t) = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是一个相容的数值通量，用于近似单元界面 $x_{i+\\frac{1}{2}}$ 处的物理通量 $f(u)=a\\,u$。\n\n从这个有限体积基础和数值通量的定义出发：\n\n- 在界面上的中心通量取决于从相邻单元重构的状态 $u_L$ 和 $u_R$，是这些状态下物理通量的对称、相容的平均值。\n- Rusanov（也称为局部 Lax–Friedrichs）通量是双曲守恒律的一种单调通量，它增加了一个与最大局部波速成正比的耗散项。\n\n在每个界面上定义一个光滑度传感器：\n$$\nS_{i+\\frac{1}{2}} = \\frac{\\|\\nabla u\\|_{i+\\frac{1}{2}}}{\\|\\nabla u\\|_{i+\\frac{1}{2}} + \\varepsilon},\n$$\n其中 $\\varepsilon0$，在一维情况下，梯度大小近似为\n$$\n\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x}.\n$$\n\n任务：\n\n1. 从单元平均有限体积公式和上述定义出发，推导每个界面上的混合数值通量，该通量使用光滑度传感器 $S_{i+\\frac{1}{2}}$ 混合中心通量和 Rusanov 通量的贡献，使得在光滑区域通量更接近中心差分，在间断附近更接近迎风（Rusanov）格式。表达出最终的半离散格式，并识别出由混合引入的等效耗散贡献。\n\n2. 从第一性原理（质量守恒和特征输运）解释，为什么对于光滑的傅里叶模式，当传感器 $S_{i+\\frac{1}{2}}$ 很小时，混合通量应相对于纯迎风格式减少耗散；以及为什么在间断附近，传感器 $S_{i+\\frac{1}{2}}$ 应趋近于 $1$，从而恢复单调的、能够捕捉激波的行为。\n\n3. 使用推导出的混合通量实现一个具有周期性边界条件的一维求解器。使用强稳定性保持三阶 Runge–Kutta (SSP-RK3) 方法进行时间步进，并使用保证稳定性的 Courant–Friedrichs–Lewy (CFL) 数 $C = a\\,\\Delta t/\\Delta x$。界面 $x_{i+\\frac{1}{2}}$ 处的面梯度大小必须计算为 $|u_{i+1}-u_i|/\\Delta x$，并且必须使用传感器 $S_{i+\\frac{1}{2}}$ 在您的数值通量中混合每个界面上的中心和 Rusanov 贡献。取 $a=1$ 和域长度 $L=1$。\n\n4. 对以下初始条件进行行为分析：\n   - 一个光滑的正弦波，$u(x,0) = \\sin(2\\pi x)$ 在 $[0,1]$ 上。演化一个完整的平流周期 $T = L/a$，并报告相对于时间 $T$ 时精确解的均方根误差（每个单元的离散 $\\ell^2$ 范数，即所有单元上均方误差的平方根）。将此误差报告为无单位的浮点数。\n   - 一个不连续的方波，$u(x,0) = 1$ 对于 $x\\in[0.25,0.5)$，否则在 $[0,1]$ 上 $u(x,0)=0$（具有周期性）。演化到时间 $T=\\frac{1}{4}L/a$，并报告两个浮点数：过冲幅度 $\\max(0,\\max_i u_i - 1)$ 和下冲幅度 $\\max(0,0 - \\min_i u_i)$。\n\n5. 使用以下参数元组的测试套件 $(\\text{IC 类型}, N, C, \\varepsilon, \\text{cycles})$，其中 $N$ 是单元数，$C$ 是 Courant–Friedrichs–Lewy 数，$\\varepsilon$ 是光滑度正则化参数，$\\text{cycles}$ 是要模拟的域遍历次数（因此最终时间为 $T = \\text{cycles}\\times L/a$）：\n   - $($正弦波$, 128, 0.45, 10^{-2}, 1.0)$\n   - $($正弦波$, 128, 0.45, 10^{-6}, 1.0)$\n   - $($阶跃波$, 512, 0.45, 10^{-2}, 0.25)$\n   - $($阶跃波$, 512, 0.45, 10^{1}, 0.25)$\n\n6. 最终输出格式：您的程序应生成单行输出，包含结果，格式为方括号内的逗号分隔列表，顺序与测试套件相同。对于正弦波情况，输出最终时间的均方根误差（一个浮点数）。对于阶跃波情况，输出一个包含两个浮点数的列表 $[\\,\\text{overshoot},\\,\\text{undershoot}\\,]$。例如，一个语法上有效的输出形式为\n$$\n[\\ e_1,\\ e_2,\\ [o_3,u_3],\\ [o_4,u_4]\\ ],\n$$\n其中 $e_j$ 是浮点数，$o_k,u_k$ 是浮点数。", "solution": "此问题被评估为有效。所有提供的信息在科学上都是合理的、自洽的，并且足以推导和实现一个完整的解决方案。这些任务是计算流体力学领域的标准练习，特别是关于现代激波捕捉有限体积格式的设计和分析。\n\n解决方案按问题陈述的要求分几个部分展开。\n\n_**1. 混合通量和半离散格式的推导**_\n\n推导的基础是一维守恒律的有限体积法。对于线性平流方程 $\\partial_t u + \\partial_x f(u) = 0$，其物理通量为 $f(u) = a u$，宽度为 $\\Delta x$ 的单元 $i$ 的半离散守恒律为：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\n其中 $u_i$ 是单元平均量，$F_{i\\pm\\frac{1}{2}}$ 是单元界面上的数值通量。我们已知平流速度 $a > 0$。\n\n首先，我们定义界面 $x_{i+\\frac{1}{2}}$ 处（位于单元 $i$（左状态 $u_L=u_i$）和单元 $i+1$（右状态 $u_R=u_{i+1}$）之间）的组成通量。\n\n**中心通量**是左右状态物理通量的算术平均值：\n$$\nF_{i+\\frac{1}{2}}^{C} = \\frac{f(u_i) + f(u_{i+1})}{2} = a \\frac{u_i + u_{i+1}}{2}\n$$\n该通量产生二阶精度的空间离散，但对于纯平流问题是不稳定的，因为它缺乏数值耗散。\n\n**Rusanov 通量**（或局部 Lax-Friedrichs 通量）引入耗散以确保稳定性。其定义为：\n$$\nF_{i+\\frac{1}{2}}^{R} = \\frac{f(u_i) + f(u_{i+1})}{2} - \\frac{\\alpha_{i+\\frac{1}{2}}}{2}(u_{i+1} - u_i)\n$$\n其中 $\\alpha_{i+\\frac{1}{2}}$ 是界面处的最大局部波速。对于线性平流方程，唯一的波速（通量雅可比矩阵 $\\partial f / \\partial u$ 的特征值）是 $a$。因此，$\\alpha_{i+\\frac{1}{2}} = |a|$。由于 $a > 0$，我们有 $\\alpha_{i+\\frac{1}{2}} = a$。将此代入 Rusanov 通量定义中，得到：\n$$\nF_{i+\\frac{1}{2}}^{R} = a \\frac{u_i + u_{i+1}}{2} - \\frac{a}{2}(u_{i+1} - u_i) = \\frac{a u_i + a u_{i+1} - a u_{i+1} + a u_i}{2} = a u_i\n$$\n这就是当 $a>0$ 时的一阶迎风通量，它以鲁棒和单调性著称，但同时也具有高耗散性（一阶精度）。\n\n接下来，我们按照规定在界面 $x_{i+\\frac{1}{2}}$ 处定义**光滑度传感器**：\n$$\nS_{i+\\frac{1}{2}} = \\frac{\\|\\nabla u\\|_{i+\\frac{1}{2}}}{\\|\\nabla u\\|_{i+\\frac{1}{2}} + \\varepsilon}\n$$\n使用所提供的一维梯度大小近似，$\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x}$，传感器变为：\n$$\nS_{i+\\frac{1}{2}} = \\frac{\\frac{|u_{i+1} - u_i|}{\\Delta x}}{\\frac{|u_{i+1} - u_i|}{\\Delta x} + \\varepsilon} = \\frac{|u_{i+1} - u_i|}{|u_{i+1} - u_i| + \\varepsilon \\Delta x}\n$$\n参数 $\\varepsilon > 0$ 对传感器进行正则化，并充当阈值。\n\n**混合通量** $F_{i+\\frac{1}{2}}^{H}$ 的构造是为了混合中心通量和 Rusanov 通量。一种常见的表达方式是从中心通量开始，并添加一个由传感器缩放的耗散项。耗散项是中心通量与 Rusanov 通量之差：\n$$\nF_{i+\\frac{1}{2}}^{R} - F_{i+\\frac{1}{2}}^{C} = a u_i - a \\frac{u_i + u_{i+1}}{2} = -\\frac{a}{2}(u_{i+1} - u_i)\n$$\n混合通量则是一个凸组合，$F^H = (1-S)F^C + S F^R$，可以重写为：\n$$\nF_{i+\\frac{1}{2}}^{H} = F_{i+\\frac{1}{2}}^{C} + S_{i+\\frac{1}{2}} \\left( F_{i+\\frac{1}{2}}^{R} - F_{i+\\frac{1}{2}}^{C} \\right) = a \\frac{u_i + u_{i+1}}{2} - S_{i+\\frac{1}{2}} \\frac{a}{2}(u_{i+1} - u_i)\n$$\n这个公式清楚地显示了混合通量是中心通量加上一个受控的数值耗散量。\n\n将此混合通量代入半离散有限体积格式中，得到：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{H} - F_{i-\\frac{1}{2}}^{H} \\right)\n$$\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left[ \\left( a \\frac{u_i + u_{i+1}}{2} - S_{i+\\frac{1}{2}} \\frac{a}{2}(u_{i+1} - u_i) \\right) - \\left( a \\frac{u_{i-1} + u_i}{2} - S_{i-\\frac{1}{2}} \\frac{a}{2}(u_i - u_{i-1}) \\right) \\right]\n$$\n将中心通量项和耗散项分组，得到最终的半离散形式：\n$$\n\\frac{d u_i}{dt} = -a \\frac{u_{i+1} - u_{i-1}}{2\\Delta x} + \\frac{a}{2\\Delta x} \\left[ S_{i+\\frac{1}{2}}(u_{i+1} - u_i) - S_{i-\\frac{1}{2}}(u_i - u_{i-1}) \\right]\n$$\n第一项是平流项 $-a \\partial_x u$ 的标准二阶中心差分近似。第二项是由混合引入的**等效耗散贡献**。该项具有耗散通量散度的形式，类似于一个非线性人工扩散项 $\\partial_x(\\nu(u) \\partial_x u)$，其中界面 $x_{i+\\frac{1}{2}}$ 处的数值粘性系数可以确定为 $\\nu_{i+\\frac{1}{2}} = S_{i+\\frac{1}{2}} \\frac{a \\Delta x}{2}$。\n\n_**2. 基于第一性原理的解释**_\n\n混合格式的行为由光滑度传感器 $S$ 决定。\n\n_在光滑区域（例如，傅里叶模式）的行为：_\n对于光滑解，如正弦波 $u(x,t) = \\sin(k(x-at))$，单元间的差异 $|u_{i+1} - u_i|$ 与网格间距 $\\Delta x$ 成正比。具体来说， $|u_{i+1} - u_i| \\approx |\\partial_x u| \\Delta x = |k \\cos(k(x-at))| \\Delta x$，其量级为 $O(\\Delta x)$。因此，梯度近似为 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x} = O(1)$。传感器变为 $S_{i+\\frac{1}{2}} \\approx \\frac{\\|\\nabla u\\|}{\\|\\nabla u\\| + \\varepsilon}$。\n如果选择的 $\\varepsilon$ 相对于典型的梯度大小 $\\|\\nabla u\\|$ 较大，那么 $S_{i+\\frac{1}{2}}$ 将会很小。例如，如果 $\\varepsilon \\gg \\|\\nabla u\\|$，则 $S \\to 0$。在此极限下，耗散项消失，通量 $F^H$ 接近中心通量 $F^C$，从而得到一个更高阶（耗散更小）的格式。从第一性原理来看，特征输运决定了形状应在传播过程中保持不变。像纯迎风（Rusanov）这样的低阶格式固有的数值耗散会衰减傅里叶模式的振幅，导致精度损失。通过在不需要耗散的地方（即 $S$ 很小的光滑区域）减少耗散，与一阶 Rusanov 格式相比，混合格式能更好地保持光滑波的形状和振幅。由于半离散方程的通量差分形式，质量是守恒的。（注意：对于本问题中为正弦波给定的参数，$\\|\\nabla u\\| \\approx 2\\pi \\gg \\varepsilon$，因此传感器 $S$ 将接近于 1，格式的行为将类似于耗散的 Rusanov 格式。如果 $\\varepsilon$ 选择得当，该原理仍然成立。）\n\n_在间断附近的行为：_\n在间断附近（例如阶跃函数），解在单个单元内表现出大的跳跃。差异 $|u_{i+1} - u_i|$ 的量级为 $O(1)$，与 $\\Delta x$ 无关。因此，梯度近似为 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x} = O(1/\\Delta x)$。随着网格加密（$\\Delta x \\to 0$），该项变得非常大。\n传感器为 $S_{i+\\frac{1}{2}} = \\frac{\\|\\nabla u\\|_{i+\\frac{1}{2}}}{\\|\\nabla u\\|_{i+\\frac{1}{2}} + \\varepsilon}$。当 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\to \\infty$ 时，分母由该项主导，因此 $S_{i+\\frac{1}{2}} \\to 1$。\n当 $S_{i+\\frac{1}{2}} \\to 1$ 时，混合通量 $F^H$ 接近 Rusanov 通量 $F^R$。Rusanov 通量在这里等同于一阶迎风格式，它是一种**单调**通量。单调性是为处理间断而设计的格式的一个关键属性，因为它保证不会产生新的局部极值（过冲或下冲）。这可以防止在间断周围形成非物理振荡（吉布斯现象）。因此，通过在梯度大的地方过渡到 Rusanov 通量，混合格式自动激活必要的耗散来清晰而稳健地捕捉间断，体现了所期望的“激波捕捉”行为，同时保持严格的质量守恒。\n\n_**3. 实现总结**_\n\n数值求解器实现如下：\n- **域和网格：** 长度为 $L=1$ 的一维域被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元。\n- **时间积分：** 使用强稳定性保持三阶 Runge-Kutta (SSP-RK3) 方法对半离散方程进行时间推进。时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 数确定，$\\Delta t = C \\Delta x / a$。\n- **空间离散化：** 在 Runge-Kutta 方法的每个阶段，计算半离散方程的右端项 $\\mathcal{L}(u)$。这包括：\n    1. 应用周期性边界条件，通常通过数组滚动或幽灵单元处理。\n    2. 对于每个界面 $x_{i+\\frac{1}{2}}$，使用状态 $u_i$ 和 $u_{i+1}$ 以及推导出的传感器和通量公式计算混合通量 $F_{i+\\frac{1}{2}}^{H}$。\n    3. 为所有单元 $i$ 计算通量差 $(F_{i+\\frac{1}{2}}^{H} - F_{i-\\frac{1}{2}}^{H})$。\n    4. 除以 $-\\Delta x$ 得到最终的更新向量 $\\mathcal{L}(u)_i$。\n\n_**4. 分析方法**_\n\n- **正弦波情况：** 初始条件为 $u(x,0) = \\sin(2\\pi x)$。模拟运行一个完整周期 $T = L/a = 1$。由于周期性，此时的精确解与初始条件相同，$u_{exact}(x,T) = u(x-aT,0) = u(x-1,0) = u(x,0)$。误差由离散 $\\ell^2$-范数（均方根误差）量化：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} (u_i(T) - u_{i, \\text{exact}}(T))^2}\n$$\n- **方波情况：** 初始条件是阶跃函数。模拟运行时间为 $T=0.25$，这将阶跃平移四分之一的域长度。激波捕捉的质量通过非物理振荡的幅度来衡量：\n$$\n\\text{过冲} = \\max(0, \\max_i u_i(T) - 1.0)\n$$\n$$\n\\text{下冲} = \\max(0, 0.0 - \\min_i u_i(T))\n$$\n这些指标量化了格式违反原始值域 $[0, 1]$ 的程度。\n\n_**5. 测试套件的预期结果**_\n\n- **情况 1  2 (正弦波):** 梯度大小 $\\|\\nabla u\\| \\approx 2\\pi \\approx 6.28$。对于 $\\varepsilon=10^{-2}$ 和 $\\varepsilon=10^{-6}$，梯度大小都远大于 $\\varepsilon$。因此，在这两种情况下，传感器 $S$ 都将非常接近 1。格式的行为将几乎与一阶 Rusanov (迎风) 格式完全相同，后者是高度耗散的。我们预计会有一个相对较大的 RMSE，表明这是一阶精度，其中 $\\varepsilon=10^{-6}$ 的误差与 $\\varepsilon=10^{-2}$ 的误差略有不同（可能稍大）。\n- **情况 3 (阶跃波, $\\varepsilon=10^{-2}$):** 在间断处，$\\|\\nabla u\\| = 1/\\Delta x = 512$。由于 $\\|\\nabla u\\| \\gg \\varepsilon$，传感器 $S \\to 1$。这正确地激活了单调的 Rusanov 通量，应能抑制振荡。我们预计过冲和下冲会非常小或为零。\n- **情况 4 (阶跃波, $\\varepsilon=10^{1}$):** 在这种情况下，$\\varepsilon=10$ 与梯度大小 $\\|\\nabla u\\|=512$ 相比并不小。间断处的传感器值将为 $S = 512 / (512+10) \\approx 0.98$。由于 $S  1$，通量不完全是 Rusanov 通量；它保留了中心通量的成分，而中心通量已知会在间断处产生振荡。因此，我们预计在这种情况下会出现显著的过冲和下冲。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a hybrid flux scheme.\n    \"\"\"\n\n    def spatial_operator(u, a, dx, eps):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete equation du/dt = L(u).\n        L(u) = -1/dx * (F_{i+1/2} - F_{i-1/2})\n        \"\"\"\n        # Periodic boundary conditions by rolling the array\n        u_p = np.roll(u, -1)  # u_{i+1} for all i\n\n        # Left and right states at interfaces i+1/2\n        u_L = u\n        u_R = u_p\n\n        # 1. Compute smoothness sensor S_{i+1/2}\n        # Using the formulation S = |u_R-u_L| / (|u_R-u_L| + eps*dx) is numerically\n        # more stable than the gradient formulation to avoid division by dx then\n        # multiplication by dx later.\n        # grad_norm = np.abs(u_R - u_L) / dx\n        # sensor = grad_norm / (grad_norm + eps)\n        # The line below is equivalent and avoids potential floating point issues with small dx.\n        sensor = np.abs(u_R - u_L) / (np.abs(u_R - u_L) + eps * dx)\n\n        # 2. Compute hybrid flux F^H_{i+1/2}\n        # F^H = a*(u_L+u_R)/2 - S*a/2*(u_R-u_L)\n        F_central = a * (u_L + u_R) / 2.0\n        F_dissipative_term = sensor * a / 2.0 * (u_R - u_L)\n        F_iph = F_central - F_dissipative_term # Flux at i+1/2\n\n        # 3. Compute flux at i-1/2 by rolling\n        F_imh = np.roll(F_iph, 1)\n\n        # 4. Compute RHS\n        rhs = -(F_iph - F_imh) / dx\n        return rhs\n\n    test_cases = [\n        ('sine', 128, 0.45, 1e-2, 1.0),\n        ('sine', 128, 0.45, 1e-6, 1.0),\n        ('step', 512, 0.45, 1e-2, 0.25),\n        ('step', 512, 0.45, 1e1, 0.25),\n    ]\n\n    results = []\n    a = 1.0\n    L = 1.0\n\n    for case in test_cases:\n        ic_type, N, C, eps, cycles = case\n        \n        # Grid and time step\n        dx = L / N\n        dt = C * dx / a\n        x = (np.arange(N) + 0.5) * dx\n        \n        # Initial condition\n        if ic_type == 'sine':\n            u0 = np.sin(2.0 * np.pi * x)\n        elif ic_type == 'step':\n            u0 = np.zeros(N)\n            u0[(x >= 0.25)  (x  0.5)] = 1.0\n        else:\n            raise ValueError(f\"Unknown IC type: {ic_type}\")\n\n        u = u0.copy()\n        \n        # Simulation time\n        T_final = cycles * L / a\n        num_steps = int(np.ceil(T_final / dt))\n        # Adjust dt to hit T_final exactly\n        dt = T_final / num_steps\n        \n        # SSP-RK3 time integration loop\n        for _ in range(num_steps):\n            # Stage 1\n            L_u = spatial_operator(u, a, dx, eps)\n            u1 = u + dt * L_u\n            \n            # Stage 2\n            L_u1 = spatial_operator(u1, a, dx, eps)\n            u2 = 0.75 * u + 0.25 * u1 + 0.25 * dt * L_u1\n            \n            # Stage 3\n            L_u2 = spatial_operator(u2, a, dx, eps)\n            u = (1.0/3.0) * u + (2.0/3.0) * u2 + (2.0/3.0) * dt * L_u2\n\n        # Post-processing and analysis\n        if ic_type == 'sine':\n            # Exact solution after 1 cycle is the initial condition\n            u_exact = u0\n            rmse = np.sqrt(np.mean((u - u_exact)**2))\n            results.append(rmse)\n        elif ic_type == 'step':\n            overshoot = max(0.0, np.max(u) - 1.0)\n            undershoot = max(0.0, 0.0 - np.min(u))\n            results.append([overshoot, undershoot])\n    \n    # Custom string conversion to match the example format [o, u]\n    def format_result(item):\n        if isinstance(item, list):\n            return f\"[{item[0]},{item[1]}]\"\n        return str(item)\n    \n    # Ensure no extra spaces in the final output string around commas\n    # The example [ e_1,\\ e_2,\\ [o_3,u_3],\\ [o_4,u_4]\\ ] appears to use spaces\n    # for readability in the prompt only. Standard list string representations\n    # are more robust.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3298134"}]}