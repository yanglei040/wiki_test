{"hands_on_practices": [{"introduction": "将压力泊松方程从连续形式转换为离散形式是计算流体动力学中的一个核心步骤。本练习旨在通过在非均匀拉伸网格上实现二阶有限体积离散化，让您掌握处理真实世界几何问题的基本功。通过执行局部傅里叶分析并计算修正波数，您将学会量化离散化过程引入的数值色散和耗散误差，这是评估和改进任何数值格式保真度的关键技能。[@problem_id:3307572]", "problem": "您的任务是，在一个拉伸的非均匀网格上，推导并实现压力拉普拉斯算子 $ \\nabla^2 p $ 的二阶单元中心有限体积法（FVM）离散化，然后执行局部傅里叶（冻结系数）分析，以计算修正波数，并量化由离散化引入的色散和耗散。该分析是在计算流体动力学（CFD）中出现的压力泊松方程（PPE）的背景下进行的，但此处的最终计算仅针对离散拉普拉斯算子。角度必须以弧度表示，所有长度均为无量纲。\n\n起点和推导要求：\n- 从不可压缩纳维-斯托克斯方程（INS）和不可压缩性约束 $ \\nabla \\cdot \\boldsymbol{u} = 0 $ 出发，通过对动量方程应用散度算子来推导压力泊松方程（PPE），并明确说明所有必要的光滑性和边界假设。\n- 在一维空间中推导 $ \\nabla^2 p $ 的二阶单元中心有限体积法（FVM）离散格式，然后推广到二维空间。在一个非均匀、拉伸的正交网格上，使用散度定理和在交界面上的线性重构（与二阶精度一致）。您的推导必须是通用的，并且不得假定均匀间距。\n- 根据局部相邻间距和平面波 $ p(\\boldsymbol{x}) = \\exp\\left( \\mathrm{i} (k_x x + k_y y) \\right) $（其中波数 $ k_x $ 和 $ k_y $ 的单位为弧度/单位长度），定义给定单元处离散算子的局部冻结系数傅里叶符号。应用局部傅里叶分析时，需冻结相邻单元距离，并认识到在拉伸网格上，精确的平移不变性被破坏。\n- 根据离散符号，通过将作用于平面波的离散算子与连续关系 $ \\nabla^2 p = - (k_x^2 + k_y^2) p $ 进行匹配，定义复修正波数的平方 $ k_{\\mathrm{mod}}^2 $。通过两个无量纲度量来量化离散化效应：\n  1. 类色散实部误差 $ \\epsilon_{\\mathrm{disp}} = \\dfrac{\\Re\\left(k_{\\mathrm{mod}}^2\\right) - \\left(k_x^2 + k_y^2\\right)}{k_x^2 + k_y^2} $。\n  2. 类耗散虚部比 $ \\epsilon_{\\mathrm{diss}} = \\dfrac{\\Im\\left(k_{\\mathrm{mod}}^2\\right)}{k_x^2 + k_y^2} $。\n- 实现一个程序，对于每个指定的测试用例，计算 $ k_{\\mathrm{mod}}^2 $ 并返回序对 $ \\left[ \\epsilon_{\\mathrm{disp}}, \\epsilon_{\\mathrm{diss}} \\right] $。\n\n使用的网格和离散化细节：\n- 考虑一个二维正交单元中心网格，单元中心坐标为 $ (x_i, y_j) $，相邻单元中心距离为 $ h_{x,-} = x_i - x_{i-1} $、$ h_{x,+} = x_{i+1} - x_i $、$ h_{y,-} = y_j - y_{j-1} $ 和 $ h_{y,+} = y_{j+1} - y_j $。局部单元宽度为 $ \\Delta x_i = \\dfrac{h_{x,-} + h_{x,+}}{2} $ 和 $ \\Delta y_j = \\dfrac{h_{y,-} + h_{y,+}}{2} $。\n- 使用通过相邻单元中心之间的线性重构获得的二阶界面梯度。通过界面的通量必须通过相邻压力的差值除以相应的相邻距离来近似。离散算子由这些界面通量的散度除以局部单元宽度构成，分别在 $ x $ 和 $ y $ 方向上计算，然后求和。\n\n傅里叶分析和输出：\n- 假设一个局部平面波 $ p_{i,j} = \\exp\\left( \\mathrm{i} (k_x x_i + k_y y_j) \\right) $，并使用冻结的相邻距离计算在 $ (i,j) $ 处的局部离散算子符号。确定该复数符号，然后将 $ k_{\\mathrm{mod}}^2 $ 设置为该符号的相反数，以匹配连续算子 $ \\nabla^2 p = - (k_x^2 + k_y^2) p $。\n- 对于每个测试用例，以浮点数形式输出序对 $ \\left[ \\epsilon_{\\mathrm{disp}}, \\epsilon_{\\mathrm{diss}} \\right] $。\n\n测试套件：\n提供以下五个测试用例的结果，每个用例由元组 $ \\left( h_{x,-}, h_{x,+}, h_{y,-}, h_{y,+}, k_x, k_y \\right) $ 指定：\n- 用例 $ 1 $（均匀网格，一维焦点）：$ \\left( 1.0, 1.0, 1.0, 1.0, 1.0, 0.0 \\right) $。\n- 用例 $ 2 $（均匀网格，二维模式）：$ \\left( 0.5, 0.5, 0.5, 0.5, 2.0, 3.0 \\right) $。\n- 用例 $ 3 $（$ x $ 方向轻微拉伸，$ y $ 方向均匀）：$ \\left( 0.8, 1.2, 1.0, 1.0, 2.5, 0.0 \\right) $。\n- 用例 $ 4 $（$ x $ 方向强拉伸，$ y $ 方向均匀）：$ \\left( 0.5, 2.0, 1.0, 1.0, 3.0, 1.0 \\right) $。\n- 用例 $ 5 $（均匀网格，对于 $ h = 0.5 $ 在两个方向上接近奈奎斯特频率）：$ \\left( 0.5, 0.5, 0.5, 0.5, 2\\pi, 2\\pi \\right) $。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个列表 $ \\left[ \\epsilon_{\\mathrm{disp}}, \\epsilon_{\\mathrm{diss}} \\right] $，对应一个测试用例，并保持输入测试用例的顺序。例如，输出应类似于 $ \\left[ [a_1, b_1], [a_2, b_2], \\dots \\right] $。", "solution": "该问题已经过验证，被认为是合理的。它具有科学依据，问题设定良好、客观，并为提供完整解决方案提供了所有必要信息。\n\n**1. 压力泊松方程（PPE）的推导**\n\n推导的基础是不可压缩纳维-斯托克斯（INS）方程，它描述了粘性不可压缩流体的运动。这些方程包括动量方程和不可压缩性约束：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} = -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} \\quad (\\text{动量方程})\n$$\n$$\n\\nabla \\cdot \\boldsymbol{u} = 0 \\quad (\\text{不可压缩性})\n$$\n此处，$\\boldsymbol{u}$ 是流体速度矢量，$p$ 是压力，$\\rho$ 是恒定的流体密度，$\\nu$ 是恒定的运动粘度。\n\n压力泊松方程（PPE）是通过对整个动量方程取散度来推导的：\n$$\n\\nabla \\cdot \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} \\right) = \\nabla \\cdot \\left( -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} \\right)\n$$\n我们在流体属性（$\\rho, \\nu$）恒定且场足够光滑以允许交换空间和时间导数的假设下，分析每一项。\n\n1.  时间导数的散度：\n    $$\n    \\nabla \\cdot \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} \\right) = \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\boldsymbol{u})\n    $$\n    根据不可压缩性约束 $\\nabla \\cdot \\boldsymbol{u} = 0$，该项为零。\n\n2.  压力梯度的散度：\n    $$\n    \\nabla \\cdot \\left( -\\frac{1}{\\rho}\\nabla p \\right) = -\\frac{1}{\\rho} \\nabla \\cdot (\\nabla p) = -\\frac{1}{\\rho} \\nabla^2 p\n    $$\n    这一项产生了压力的拉普拉斯算子，也就是我们感兴趣的算子。\n\n3.  粘性项的散度：\n    $$\n    \\nabla \\cdot (\\nu \\nabla^2 \\boldsymbol{u}) = \\nu \\nabla \\cdot (\\nabla^2 \\boldsymbol{u}) = \\nu \\nabla^2 (\\nabla \\cdot \\boldsymbol{u})\n    $$\n    再次使用不可压缩性约束 $\\nabla \\cdot \\boldsymbol{u} = 0$，该项也为零。\n\n将这些简化结果代回取过散度的动量方程，得到：\n$$\n\\nabla \\cdot \\left( (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} \\right) = -\\frac{1}{\\rho} \\nabla^2 p\n$$\n对压力项进行整理，得到 PPE：\n$$\n\\nabla^2 p = -\\rho \\nabla \\cdot \\left( (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} \\right)\n$$\n该方程建立了一种关系，即压力场 $p$ 必须瞬时调整，以确保在数值模拟的下一个时间步中速度场 $\\boldsymbol{u}$ 保持无散度。方程右侧充当泊松方程的源项。本问题专注于对左侧算子 $\\nabla^2 p$ 的离散化和分析。\n\n**2. 二阶单元中心有限体积离散化**\n\n我们在一个二维、非均匀、正交网格上，为拉普拉斯算子 $\\nabla^2 p = \\nabla \\cdot (\\nabla p)$ 推导一个单元中心的有限体积法（FVM）离散格式。该网格由位于 $(x_i, y_j)$ 的单元中心组成。到相邻单元中心的距离定义为 $h_{x,-} = x_i - x_{i-1}$，$h_{x,+} = x_{i+1} - x_i$，$h_{y,-} = y_j - y_{j-1}$ 和 $h_{y,+} = y_{j+1} - y_j$。\n\nFVM 方法涉及在控制体（CV）上对控制方程进行积分，并应用散度定理。对于一个体积（面积）为 $V_{i,j} = \\Delta x_i \\Delta y_j$ 的二维单元 $(i, j)$，可得：\n$$\n\\frac{1}{V_{i,j}} \\int_{V_{i,j}} \\nabla \\cdot (\\nabla p) \\, dV = \\frac{1}{V_{i,j}} \\oint_{\\partial V_{i,j}} (\\nabla p) \\cdot \\boldsymbol{n} \\, dS\n$$\n其中 $\\boldsymbol{n}$ 是指向控制体边界 $\\partial V_{i,j}$ 外部的法向量。\n\n对于正交网格，拉普拉斯算子可以分解为来自每个坐标方向的独立贡献：$\\nabla^2 p = \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2}$。我们首先为 $\\frac{\\partial^2 p}{\\partial x^2}$ 推导一维离散算子 $(\\delta_{xx}p)_i$。\n\n围绕单元中心 $x_i$ 的一维控制体从界面 $x_{i-1/2}$ 延伸到 $x_{i+1/2}$，宽度为 $\\Delta x_i = \\frac{h_{x,-} + h_{x,+}}{2}$。在一维中应用散度定理得到：\n$$\n(\\delta_{xx}p)_i = \\frac{1}{\\Delta x_i} \\left[ \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1/2} - \\left(\\frac{\\partial p}{\\partial x}\\right)_{i-1/2} \\right]\n$$\n单元界面上的梯度使用相邻单元中心之间的二阶精度中心差分进行近似：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1/2} \\approx \\frac{p_{i+1} - p_i}{x_{i+1} - x_i} = \\frac{p_{i+1} - p_i}{h_{x,+}}\n$$\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i-1/2} \\approx \\frac{p_i - p_{i-1}}{x_i - x_{i-1}} = \\frac{p_i - p_{i-1}}{h_{x,-}}\n$$\n将这些代入 $(\\delta_{xx}p)_i$ 的表达式中：\n$$\n(\\delta_{xx}p)_i = \\frac{1}{\\Delta x_i} \\left[ \\frac{p_{i+1} - p_i}{h_{x,+}} - \\frac{p_i - p_{i-1}}{h_{x,-}} \\right] = \\frac{2}{h_{x,-} + h_{x,+}} \\left[ \\frac{p_{i+1} - p_i}{h_{x,+}} - \\frac{p_i - p_{i-1}}{h_{x,-}} \\right]\n$$\n这可以写成一个三点格式：\n$$\n(\\delta_{xx}p)_i = \\left(\\frac{2}{h_{x,+}(h_{x,-} + h_{x,+})}\\right)p_{i+1} - \\left(\\frac{2}{h_{x,+}h_{x,-}}\\right)p_i + \\left(\\frac{2}{h_{x,-}(h_{x,-} + h_{x,+})}\\right)p_{i-1}\n$$\n推广到正交网格上的二维情况，离散拉普拉斯算子 $L_h(p_{i,j})$ 是一维算子的和：\n$$\nL_h(p_{i,j}) = (\\delta_{xx}p)_{i,j} + (\\delta_{yy}p)_{i,j}\n$$\n$$\nL_h(p_{i,j}) = \\frac{2}{h_{x,-} + h_{x,+}}\\left[\\frac{p_{i+1,j} - p_{i,j}}{h_{x,+}} - \\frac{p_{i,j} - p_{i-1,j}}{h_{x,-}}\\right] + \\frac{2}{h_{y,-} + h_{y,+}}\\left[\\frac{p_{i,j+1} - p_{i,j}}{h_{y,+}} - \\frac{p_{i,j} - p_{i,j-1}}{h_{y,-}}\\right]\n$$\n\n**3. 局部傅里叶分析和修正波数**\n\n为了分析此离散算子的性质，我们执行局部或“冻结系数”傅里叶分析。这涉及将平面波解 $p(\\boldsymbol{x}) = \\exp(\\mathrm{i} \\boldsymbol{k} \\cdot \\boldsymbol{x})$ 代入离散算子 $L_h$。该分析是“局部的”，因为我们将网格间距 $(h_{x,-}, h_{x,+}, h_{y,-}, h_{y,+})$ 冻结在特定单元 $(i,j)$ 处的值，并承认在非均匀网格上不存在真正的平移不变性。\n\n离散压力场为 $p_{i,j} = \\exp(\\mathrm{i}(k_x x_i + k_y y_j))$。相邻节点的值可以用 $p_{i,j}$ 表示：\n$p_{i+1,j} = p_{i,j} \\exp(\\mathrm{i}k_x h_{x,+})$，$p_{i-1,j} = p_{i,j} \\exp(-\\mathrm{i}k_x h_{x,-})$，$p_{i,j+1} = p_{i,j} \\exp(\\mathrm{i}k_y h_{y,+})$，以及 $p_{i,j-1} = p_{i,j} \\exp(-\\mathrm{i}k_y h_{y,-})$。\n\n将这些代入算子 $L_h(p_{i,j})$ 中，得到 $L_h(p_{i,j}) = \\hat{L}_h \\cdot p_{i,j}$，其中 $\\hat{L}_h$ 是算子的复数符号。\n$$\n\\hat{L}_h = \\frac{\\hat{L}_h(p_{i,j})}{p_{i,j}} = \\hat{L}_{h,x} + \\hat{L}_{h,y}\n$$\n$$\n\\hat{L}_{h,x} = \\frac{2}{h_{x,-} + h_{x,+}}\\left[\\frac{\\exp(\\mathrm{i}k_x h_{x,+}) - 1}{h_{x,+}} + \\frac{\\exp(-\\mathrm{i}k_x h_{x,-}) - 1}{h_{x,-}}\\right]\n$$\n$$\n\\hat{L}_{h,y} = \\frac{2}{h_{y,-} + h_{y,+}}\\left[\\frac{\\exp(\\mathrm{i}k_y h_{y,+}) - 1}{h_{y,+}} + \\frac{\\exp(-\\mathrm{i}k_y h_{y,-}) - 1}{h_{y,-}}\\right]\n$$\n连续拉普拉斯算子作用于平面波的结果是 $\\nabla^2 p = -(k_x^2 + k_y^2)p = -k^2 p$。我们通过类比定义复修正波数的平方 $k_{\\mathrm{mod}}^2$，使得 $L_h(p_{i,j}) \\equiv -k_{\\mathrm{mod}}^2 p_{i,j}$。这直接意味着 $k_{\\mathrm{mod}}^2 = -\\hat{L}_h$。\n\n使用欧拉公式 $e^{\\mathrm{i}\\theta} = \\cos\\theta + \\mathrm{i}\\sin\\theta$，我们将 $k_{\\mathrm{mod}}^2$ 分解为实部和虚部：\n$$\n\\Re(k_{\\mathrm{mod}}^2) = -\\frac{2}{h_{x,-} + h_{x,+}} \\left( \\frac{\\cos(k_x h_{x,+}) - 1}{h_{x,+}} + \\frac{\\cos(k_x h_{x,-}) - 1}{h_{x,-}} \\right) - \\frac{2}{h_{y,-} + h_{y,+}} \\left( \\frac{\\cos(k_y h_{y,+}) - 1}{h_{y,+}} + \\frac{\\cos(k_y h_{y,-}) - 1}{h_{y,-}} \\right)\n$$\n$$\n\\Im(k_{\\mathrm{mod}}^2) = -\\frac{2}{h_{x,-} + h_{x,+}} \\left( \\frac{\\sin(k_x h_{x,+})}{h_{x,+}} - \\frac{\\sin(k_x h_{x,-})}{h_{x,-}} \\right) - \\frac{2}{h_{y,-} + h_{y,+}} \\left( \\frac{\\sin(k_y h_{y,+})}{h_{y,+}} - \\frac{\\sin(k_y h_{y,-})}{h_{y,-}} \\right)\n$$\n对于均匀网格，其中 $h_{x,-} = h_{x,+} = h_x$ 且 $h_{y,-} = h_{y,+} = h_y$，虚部消失，即 $\\Im(k_{\\mathrm{mod}}^2) = 0$，表明该格式是非耗散的。实部简化为著名的结果 $k_{\\mathrm{mod}}^2 = \\frac{4}{h_x^2}\\sin^2(\\frac{k_x h_x}{2}) + \\frac{4}{h_y^2}\\sin^2(\\frac{k_y h_y}{2})$。网格拉伸（$h_{+} \\neq h_{-}$）的存在会引入一个非零的虚部，这对应于数值耗散或反耗散。\n\n**4. 离散化效应的量化**\n\n修正波数 $k_{\\mathrm{mod}}^2$ 与精确波数 $k^2 = k_x^2 + k_y^2$ 的偏差量化了由离散化引入的误差。\n\n1.  **类色散误差**，$\\epsilon_{\\mathrm{disp}}$：这衡量了算子符号实部的误差，该误差与数值波的相速度有关。\n    $$\n    \\epsilon_{\\mathrm{disp}} = \\dfrac{\\Re\\left(k_{\\mathrm{mod}}^2\\right) - \\left(k_x^2 + k_y^2\\right)}{k_x^2 + k_y^2}\n    $$\n2.  **类耗散误差**，$\\epsilon_{\\mathrm{diss}}$：这衡量了虚部的相对大小，该部分关系到波幅的非物理衰减（耗散）或增长（不稳定性）。\n    $$\n    \\epsilon_{\\mathrm{diss}} = \\dfrac{\\Im\\left(k_{\\mathrm{mod}}^2\\right)}{k_x^2 + k_y^2}\n    $$\n$\\epsilon_{\\mathrm{diss}}$ 的正值对应于数值耗散（振幅衰减），因为算子 $L_h$ 的符号具有负的实部。\n\n以下程序实现了这些公式，用于计算指定测试用例的误差。", "answer": "```python\nimport numpy as np\n\ndef compute_errors(h_xm: float, h_xp: float, h_ym: float, h_yp: float, kx: float, ky: float) -> list[float]:\n    \"\"\"\n    Computes dispersion and dissipation errors for the 2D FVM Laplacian.\n\n    Args:\n        h_xm: Grid spacing h_{x,-}\n        h_xp: Grid spacing h_{x,+}\n        h_ym: Grid spacing h_{y,-}\n        h_yp: Grid spacing h_{y,+}\n        kx: Wavenumber in x-direction\n        ky: Wavenumber in y-direction\n\n    Returns:\n        A list containing [epsilon_disp, epsilon_diss].\n    \"\"\"\n    # Calculate exact wavenumber squared\n    k_sq = kx**2 + ky**2\n    \n    # Handle the trivial case where the wave is a constant (k=0)\n    if k_sq == 0:\n        return [0.0, 0.0]\n\n    # --- X-direction contribution to k_mod^2 ---\n    # Real part\n    term_x_real_num_p = np.cos(kx * h_xp) - 1.0\n    term_x_real_num_m = np.cos(kx * h_xm) - 1.0\n    k_mod_sq_x_real = -2.0 / (h_xm + h_xp) * (term_x_real_num_p / h_xp + term_x_real_num_m / h_xm)\n\n    # Imaginary part\n    term_x_imag_num_p = np.sin(kx * h_xp)\n    term_x_imag_num_m = np.sin(kx * h_xm)\n    k_mod_sq_x_imag = -2.0 / (h_xm + h_xp) * (term_x_imag_num_p / h_xp - term_x_imag_num_m / h_xm)\n\n    # --- Y-direction contribution to k_mod^2 ---\n    # Real part\n    term_y_real_num_p = np.cos(ky * h_yp) - 1.0\n    term_y_real_num_m = np.cos(ky * h_ym) - 1.0\n    k_mod_sq_y_real = -2.0 / (h_ym + h_yp) * (term_y_real_num_p / h_yp + term_y_real_num_m / h_ym)\n    \n    # Imaginary part\n    term_y_imag_num_p = np.sin(ky * h_yp)\n    term_y_imag_num_m = np.sin(ky * h_ym)\n    k_mod_sq_y_imag = -2.0 / (h_ym + h_yp) * (term_y_imag_num_p / h_yp - term_y_imag_num_m / h_ym)\n\n    # --- Total k_mod^2 and errors ---\n    k_mod_sq_real = k_mod_sq_x_real + k_mod_sq_y_real\n    k_mod_sq_imag = k_mod_sq_x_imag + k_mod_sq_y_imag\n\n    epsilon_disp = (k_mod_sq_real - k_sq) / k_sq\n    epsilon_diss = k_mod_sq_imag / k_sq\n\n    return [epsilon_disp, epsilon_diss]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test cases defined as tuples of (h_xm, h_xp, h_ym, h_yp, kx, ky)\n    test_cases = [\n        (1.0, 1.0, 1.0, 1.0, 1.0, 0.0),      # Case 1: uniform grid, 1D focus\n        (0.5, 0.5, 0.5, 0.5, 2.0, 3.0),      # Case 2: uniform grid, 2D mode\n        (0.8, 1.2, 1.0, 1.0, 2.5, 0.0),      # Case 3: mild stretch in x\n        (0.5, 2.0, 1.0, 1.0, 3.0, 1.0),      # Case 4: strong stretch in x\n        (0.5, 0.5, 0.5, 0.5, 2 * np.pi, 2 * np.pi), # Case 5: uniform grid, near-Nyquist\n    ]\n\n    results = []\n    for case in test_cases:\n        h_xm, h_xp, h_ym, h_yp, kx, ky = case\n        errors = compute_errors(h_xm, h_xp, h_ym, h_yp, kx, ky)\n        results.append(f\"[{errors[0]},{errors[1]}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3307572"}, {"introduction": "压力泊松方程的求解不仅依赖于内部点的离散格式，还深刻地受到边界条件的影响。本练习聚焦于在纯诺伊曼 (Neumann) 边界条件下出现的一个关键数学难题：解的非唯一性。通过设计一个离散测试来验证拉普拉斯算子矩阵的零空间，并实现一个增广系统来固定解，您将深入理解保证压力场唯一解的相容性条件和实用技术。[@problem_id:3307575]", "problem": "考虑一个由质量守恒和动量平衡控制的不可压缩流。对于牛顿流体，在不可压缩的假设下，质量守恒表示为 $ \\nabla \\cdot \\mathbf{u} = 0 $，其中 $ \\mathbf{u} $ 是速度场。动量方程（即单位体积的牛顿第二定律）为 $ \\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u} \\cdot \\nabla \\mathbf{u} \\right) = - \\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $，其中 $ \\rho $ 是密度，$ p $ 是压力，$ \\mu $ 是动力粘度，$ \\mathbf{f} $ 是单位体积的体积力。在用于不可压缩流的投影类算法中，通过强制执行 $ \\nabla \\cdot \\boldsymbol{u}^{n+1} = 0 $ 来获得压力修正，其中 $ \\boldsymbol{u}^{n+1} $ 是更新后的速度。这种强制措施会导出一个形如 $ \\nabla^2 p = g $ 的压力泊松方程，其中 $ g $ 源于对适当离散化的中间速度项和体积力项求散度。在边界上，压力边界条件源于动量的法向分量，在纯诺伊曼边界条件下，这意味着 $ \\frac{\\partial p}{\\partial n} = h $，而在齐次情况下 $ h = 0 $。\n\n您的任务是推导并离散化压力泊松方程，然后设计一个离散测试来验证并消除由纯诺伊曼边界条件引起的零空间。按以下步骤进行：\n\n- 从 $ \\nabla \\cdot \\boldsymbol{u} = 0 $ 和动量方程出发，推导压力泊松方程 $ \\nabla^2 p = g $，并讨论在不可压缩设定下，$ p $ 的纯诺伊曼边界条件的物理来源。具体证明为什么在齐次诺伊曼情况下（即在所有边界上 $ \\frac{\\partial p}{\\partial n} = 0 $），连续算子 $ \\nabla^2 $ 具有由常数构成的零空间，这意味着压力仅在相差一个加性常数的情况下是确定的。\n- 在一个尺寸为 $ N_x $ 和 $ N_y $、间距分别为 $ h_x $ 和 $ h_y $ 的矩形均匀二维网格上，离散化拉普拉斯算子 $ \\nabla^2 $。使用二阶有限差分法。通过引入法向导数为零的虚拟点来强制执行齐次诺伊曼边界条件，这会导致边界上出现单边二阶导数。写出最终的线性系统 $ L \\mathbf{p} = \\mathbf{b} $，其中 $ L $ 是强制执行纯诺伊曼条件的离散拉普拉斯矩阵，$ \\mathbf{p} $ 是离散压力向量，$ \\mathbf{b} $ 是对应于 $ g $ 的离散右端项。解析地证明当 $ \\mathbf{p} $ 是全1向量 $ \\mathbf{1} $ 时，有 $ L \\mathbf{1} = \\mathbf{0} $，从而揭示离散零空间由 $ \\mathbf{1} $ 张成。\n- 解释在纯诺伊曼边界条件下，$ L \\mathbf{p} = \\mathbf{b} $ 存在解的离散相容性条件，即 $ \\sum_i b_i = 0 $。设计一种方法，通过固定平均压力（例如，通过一个拉格朗日乘子，在一个增广鞍点系统中强制执行 $ \\frac{1}{n} \\sum_i p_i = 0 $，其中 $ n = N_x N_y $）来消除零空间并获得唯一解。\n\n实现一个完整的、可运行的程序，该程序：\n- 在齐次诺伊曼边界条件下，使用带有确保 $ \\frac{\\partial p}{\\partial n} = 0 $ 的虚拟点的二阶有限差分，为给定的 $ N_x, N_y, h_x, h_y $ 建立矩阵 $ L $。\n- 对三个网格计算 $ \\| L \\mathbf{1} \\|_\\infty $ 来验证零空间。\n- 构造增广系统\n$$\n\\begin{bmatrix}\nL  \\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\\n0\n\\end{bmatrix}\n$$\n以施加 $ \\sum_i p_i = 0 $（即平均压力为零），并对两个右端项 $ \\mathbf{b} $ 求解：一个均值为零，一个均值非零。报告增广系统的相对残差 $ \\rho_k = \\frac{\\| L \\mathbf{p}^{(k)} + \\lambda^{(k)} \\mathbf{1} - \\mathbf{b}^{(k)} \\|_2}{\\| \\mathbf{b}^{(k)} \\|_2} $ 和所得 $ \\mathbf{p} $ 的均值 $ m_k = \\frac{1}{n} \\sum_i p^{(k)}_i $，以证明零空间的消除和解的唯一性。\n\n使用以下网格和右端项的测试套件：\n- 网格 1：$ N_x = 8 $，$ N_y = 7 $，$ h_x = 0.1 $，$ h_y = 0.2 $。计算 $ r_1 = \\| L \\mathbf{1} \\|_\\infty $。\n- 网格 2：$ N_x = 3 $，$ N_y = 3 $，$ h_x = 0.3 $，$ h_y = 0.5 $。计算 $ r_2 = \\| L \\mathbf{1} \\|_\\infty $。\n- 网格 3：$ N_x = 1 $，$ N_y = 5 $，$ h_x = 1.0 $，$ h_y = 0.25 $。计算 $ r_3 = \\| L \\mathbf{1} \\|_\\infty $。\n- 在网格 1 上进行增广系统测试：令 $ \\mathbf{b}^{(0)} $ 为一个通过减去其平均值构造的均值为零的随机向量，令 $ \\mathbf{b}^{(1)} $ 为一个均值非零的随机向量。对每个 $ \\mathbf{b}^{(k)} $，求解增广系统并计算相对残差 $ \\rho_k = \\frac{\\| L \\mathbf{p}^{(k)} + \\lambda^{(k)} \\mathbf{1} - \\mathbf{b}^{(k)} \\|_2}{\\| \\mathbf{b}^{(k)} \\|_2} $ 和均值 $ m_k = \\frac{1}{n} \\sum_i p^{(k)}_i $。\n\n您的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔列表，顺序为 $ [ r_1, r_2, r_3, \\rho_0, m_0, \\rho_1, m_1 ] $。所有值必须打印为标准浮点数，不带任何附加文本。此问题不需要物理单位。", "solution": "该任务要求推导和离散化压力泊松方程，分析其在纯诺伊曼边界条件下的零空间，并实现一种获得唯一解的方法。\n\n### 第1部分：压力泊松方程及其边界条件的推导\n\n不可压缩牛顿流体的控制方程是质量守恒和动量平衡。\n不可压缩流的连续性方程是：\n$$ \\nabla \\cdot \\boldsymbol{u} = 0 $$\n其中 $\\boldsymbol{u}$ 是速度场。\n\n动量方程是：\n$$ \\rho \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\boldsymbol{u} \\right) = - \\nabla p + \\mu \\nabla^2 \\boldsymbol{u} + \\mathbf{f} $$\n其中 $\\rho$ 是流体密度，$p$ 是压力，$\\mu$ 是动力粘度，$\\mathbf{f}$ 是单位体积的体积力。\n\n为了推导压力泊松方程，我们对动量方程取散度。将散度算子 $\\nabla \\cdot$ 应用于每一项可得：\n$$ \\nabla \\cdot \\left( \\rho \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\boldsymbol{u} \\right) \\right) = \\nabla \\cdot (-\\nabla p) + \\nabla \\cdot (\\mu \\nabla^2 \\boldsymbol{u}) + \\nabla \\cdot \\mathbf{f} $$\n重新整理以分离出压力项，并使用恒等式 $\\nabla \\cdot (\\nabla p) = \\nabla^2 p$，我们得到：\n$$ \\nabla^2 p = \\nabla \\cdot \\left( -\\rho \\frac{\\partial \\boldsymbol{u}}{\\partial t} - \\rho (\\boldsymbol{u} \\cdot \\nabla)\\boldsymbol{u} + \\mu \\nabla^2 \\boldsymbol{u} + \\mathbf{f} \\right) $$\n这就是压力泊松方程，可以简写为 $\\nabla^2 p = g$，其中右端项 $g$ 包括所有不涉及压力的项。压力场的物理作用是瞬时调整自身，以确保速度场 $\\boldsymbol{u}$ 在任何时候都保持无散度，从而满足不可压缩性约束。\n\n压力的边界条件由在边界上求值的动量方程导出。将动量方程投影到边界法向量 $\\mathbf{n}$ 上，可以得到压力法向导数 $\\frac{\\partial p}{\\partial n} = \\mathbf{n} \\cdot \\nabla p$ 的表达式：\n$$ \\frac{\\partial p}{\\partial n} = \\mathbf{n} \\cdot \\left( -\\rho \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\boldsymbol{u} \\right) + \\mu \\nabla^2 \\boldsymbol{u} + \\mathbf{f} \\right) $$\n在许多情况下，特别是在瞬态模拟的投影法中，此条件在所有边界上被简化为齐次诺伊曼边界条件，即 $\\frac{\\partial p}{\\partial n} = 0$。\n\n当在区域 $\\Omega$ 的整个边界 $\\partial\\Omega$ 上应用纯齐次诺伊曼条件时，算子 $\\nabla^2$ 具有一个零空间。该零空间由所有在 $\\Omega$ 中满足 $\\nabla^2 p = 0$ 且在 $\\partial\\Omega$ 上满足 $\\frac{\\partial p}{\\partial n} = 0$ 的函数 $p$ 组成。为了描述这个零空间，我们使用格林第一恒等式：\n$$ \\int_\\Omega (v \\nabla^2 u + \\nabla v \\cdot \\nabla u) dV = \\oint_{\\partial\\Omega} v \\frac{\\partial u}{\\partial n} dS $$\n令 $v=u=p$，我们有：\n$$ \\int_\\Omega (p \\nabla^2 p + |\\nabla p|^2) dV = \\oint_{\\partial\\Omega} p \\frac{\\partial p}{\\partial n} dS $$\n代入条件 $\\nabla^2 p = 0$ 和 $\\frac{\\partial p}{\\partial n} = 0$：\n$$ \\int_\\Omega (p \\cdot 0 + |\\nabla p|^2) dV = \\oint_{\\partial\\Omega} p \\cdot 0 \\, dS $$\n这简化为：\n$$ \\int_\\Omega |\\nabla p|^2 dV = 0 $$\n由于被积函数 $|\\nabla p|^2$ 是非负的，该积分只能在 $|\\nabla p|^2 = 0$ 在 $\\Omega$ 中处处成立时为零。这意味着 $\\nabla p = \\mathbf{0}$，也就是说 $p$ 必须是一个常数函数。因此，具有纯齐次诺伊曼边界条件的连续拉普拉斯算子的零空间是常数函数的空间。这意味着如果 $p(\\mathbf{x})$ 是一个解，那么对于任何常数 $C$，$p(\\mathbf{x}) + C$ 也是一个解。压力仅在相差一个加性常数的情况下是确定的。\n\n### 第2部分：离散化与离散零空间\n\n我们在一个具有 $N_x \\times N_y$ 个点、网格间距为 $h_x, h_y$、网格点为 $(x_i, y_j) = (i h_x, j h_y)$ 的均匀矩形网格上离散化二维拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$。网格点上的压力记为 $p_{i,j}$。我们对内部点 $(i,j)$ 的导数使用二阶中心有限差分近似：\n$$ (\\nabla^2 p)_{i,j} \\approx \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{h_x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{h_y^2} $$\n齐次诺伊曼边界条件，例如在 $x=0$ 处 $\\frac{\\partial p}{\\partial x} = 0$，通过使用虚拟点来强制执行。在 $i=0$ 处的一阶导数的二阶中心差分为 $\\frac{p_{1,j} - p_{-1,j}}{2h_x} = 0$，这意味着虚拟点的值为 $p_{-1,j} = p_{1,j}$。将此代入 $i=0$ 处的拉普拉斯算子模板中：\n$$ (\\nabla^2 p)_{0,j} \\approx \\frac{p_{1,j} - 2p_{0,j} + p_{-1,j}}{h_x^2} + \\dots = \\frac{p_{1,j} - 2p_{0,j} + p_{1,j}}{h_x^2} + \\dots = \\frac{2(p_{1,j} - p_{0,j})}{h_x^2} + \\dots $$\n此过程应用于所有边界（左、右、底、顶），包括角点。\n\n最终得到的线性方程组可以写成矩阵系统 $L\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是按字典序（例如，行主序）排列的压力值 $p_{i,j}$ 的向量，$L$ 是离散拉普拉斯矩阵。为了证明离散算子 $L$ 有一个由全1向量 $\\mathbf{1}$ 张成的零空间，我们必须证明 $L\\mathbf{1} = \\mathbf{0}$。这等价于证明 $L$ 的每一行元素之和为零。让我们检查任意网格点 $(i,j)$ 的模板中系数之和。\n- **内部点 $(i,j)$**：$p_{i-1,j}, p_{i+1,j}, p_{i,j-1}, p_{i,j+1}, p_{i,j}$ 的系数分别为 $\\frac{1}{h_x^2}, \\frac{1}{h_x^2}, \\frac{1}{h_y^2}, \\frac{1}{h_y^2}, -2(\\frac{1}{h_x^2}+\\frac{1}{h_y^2})$。它们的和为 $0$。\n- **边界点（例如，左边界，$i=0$）**：$p_{1,j}, p_{0,j-1}, p_{0,j+1}, p_{0,j}$ 的系数分别为 $\\frac{2}{h_x^2}, \\frac{1}{h_y^2}, \\frac{1}{h_y^2}, -(\\frac{2}{h_x^2}+\\frac{2}{h_y^2})$。它们的和为 $0$。\n- **角点（例如，左下角，$i=0, j=0$）**：$p_{1,0}, p_{0,1}, p_{0,0}$ 的系数分别为 $\\frac{2}{h_x^2}, \\frac{2}{h_y^2}, -(\\frac{2}{h_x^2}+\\frac{2}{h_y^2})$。它们的和也为 $0$。\n\n由于每个网格点的有限差分模板中系数之和都为零，因此矩阵 $L$ 的每一行元素之和也为零。因此，$L\\mathbf{1} = \\mathbf{0}$，这意味着全1向量在 $L$ 的零空间中。\n\n### 第3部分：相容性条件与增广系统\n\n对于奇异线性系统 $L\\mathbf{p} = \\mathbf{b}$ 要有解，右端向量 $\\mathbf{b}$ 必须与转置矩阵 $L^\\top$ 的零空间正交。如此构造的离散拉普拉斯算子 $L$ 是对称的（$L=L^\\top$），所以它的零空间与其转置矩阵的零空间相同，都由 $\\mathbf{1}$ 张成。因此，相容性条件是 $\\mathbf{1}^\\top\\mathbf{b} = 0$，这意味着 $\\mathbf{b}$ 的元素之和必须为零：$\\sum_i b_i = 0$。这是连续条件 $\\int_\\Omega g \\, dV = 0$ 的离散模拟。\n\n如果解存在，它也不是唯一的。为了获得唯一解，必须施加一个额外的约束。一个常见的选择是强制压力均值为零：$\\frac{1}{n} \\sum_i p_i = 0$，其中 $n=N_x N_y$。这等价于约束 $\\mathbf{1}^\\top \\mathbf{p} = 0$。\n\n这个约束系统可以通过使用拉格朗日乘子将约束并入线性系统来求解，从而得到增广鞍点系统：\n$$\n\\begin{bmatrix}\nL  \\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\\n0\n\\end{bmatrix}\n$$\n该增广矩阵是非奇异的，求解此系统会得到一个唯一的解 $(\\mathbf{p}, \\lambda)$，其中 $\\mathbf{p}$ 是均值为零的压力向量。从分块矩阵乘法中，我们得到两个方程：\n$1. \\quad L\\mathbf{p} + \\lambda\\mathbf{1} = \\mathbf{b}$\n$2. \\quad \\mathbf{1}^\\top\\mathbf{p} = 0$\n\n用 $\\mathbf{1}^\\top$ 从左侧乘以第一个方程得到 $\\mathbf{1}^\\top L\\mathbf{p} + \\lambda \\mathbf{1}^\\top\\mathbf{1} = \\mathbf{1}^\\top\\mathbf{b}$。由于 $\\mathbf{1}^\\top L = (L^\\top \\mathbf{1})^\\top = (L\\mathbf{1})^\\top = \\mathbf{0}^\\top$，这简化为 $\\lambda n = \\sum_i b_i$，所以 $\\lambda = \\frac{1}{n} \\sum_i b_i$。拉格朗日乘子 $\\lambda$ 正是原始右端项 $\\mathbf{b}$ 的平均值。正在求解的有效系统是 $L\\mathbf{p} = \\mathbf{b} - \\bar{b}\\mathbf{1}$，其中 $\\bar{b}$ 是 $\\mathbf{b}$ 的平均值。这种修正确保了右端项满足相容性条件，从而使解存在，而约束 $\\mathbf{1}^\\top\\mathbf{p}=0$ 则确保了解的唯一性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_laplacian_neumann(Nx, Ny, hx, hy):\n    \"\"\"\n    Builds the 2D Laplacian matrix with homogeneous Neumann boundary conditions.\n\n    Args:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n\n    Returns:\n        numpy.ndarray: The (Nx*Ny) x (Nx*Ny) discrete Laplacian matrix.\n    \"\"\"\n    n = Nx * Ny\n    L = np.zeros((n, n), dtype=float)\n    \n    hx2i = 1.0 / (hx * hx)\n    hy2i = 1.0 / (hy * hy)\n\n    for i in range(Nx):\n        for j in range(Ny):\n            k = i * Ny + j  # Row-major index\n\n            # Contribution from d^2/dx^2\n            if Nx > 1:\n                # West neighbor contribution\n                if i > 0:\n                    L[k, (i - 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n                else:  # Left boundary i=0\n                    L[k, (i + 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n\n                # East neighbor contribution\n                if i  Nx - 1:\n                    L[k, (i + 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n                else:  # Right boundary i=Nx-1\n                    L[k, (i - 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n\n            # Contribution from d^2/dy^2\n            if Ny  1:\n                # South neighbor contribution\n                if j  0:\n                    L[k, i * Ny + (j - 1)] += hy2i\n                    L[k, k] -= hy2i\n                else:  # Bottom boundary j=0\n                    L[k, i * Ny + (j + 1)] += hy2i\n                    L[k, k] -= hy2i\n                \n                # North neighbor contribution\n                if j  Ny - 1:\n                    L[k, i * Ny + (j + 1)] += hy2i\n                    L[k, k] -= hy2i\n                else:  # Top boundary j=Ny-1\n                    L[k, i * Ny + (j - 1)] += hy2i\n                    L[k, k] -= hy2i\n    return L\n\n\ndef solve():\n    \"\"\"\n    Main function to perform the required computations and print the results.\n    \"\"\"\n    # Use a fixed seed for reproducibility of random vectors\n    np.random.seed(42)\n\n    results = []\n\n    # --- Part 1: Verify the nullspace for three meshes ---\n    meshes = [\n        (8, 7, 0.1, 0.2),  # Mesh 1\n        (3, 3, 0.3, 0.5),  # Mesh 2\n        (1, 5, 1.0, 0.25)  # Mesh 3\n    ]\n\n    for Nx, Ny, hx, hy in meshes:\n        n = Nx * Ny\n        L = build_laplacian_neumann(Nx, Ny, hx, hy)\n        ones_vec = np.ones(n)\n        L_times_ones = L @ ones_vec\n        r = np.linalg.norm(L_times_ones, np.inf)\n        results.append(r)\n\n    # --- Part 2: Solve the augmented system for two RHS on Mesh 1 ---\n    Nx, Ny, hx, hy = meshes[0]\n    n = Nx * Ny\n    L = build_laplacian_neumann(Nx, Ny, hx, hy)\n\n    # Case 0: RHS with zero mean\n    b0 = np.random.rand(n)\n    b0 -= np.mean(b0)\n\n    # Case 1: RHS with non-zero mean\n    b1 = np.random.rand(n)\n    if np.mean(b1) == 0: # Extremely unlikely but handle for robustness\n        b1[0] += 1.0\n\n    rhs_cases = [b0, b1]\n    \n    for b in rhs_cases:\n        # Construct the augmented saddle-point system\n        A = np.zeros((n + 1, n + 1))\n        A[:n, :n] = L\n        A[:n, n] = 1.0  # Lagrange multiplier constraint part\n        A[n, :n] = 1.0\n        \n        # Construct the augmented right-hand side vector\n        B = np.zeros(n + 1)\n        B[:n] = b\n\n        # Solve the augmented system for [p, lambda]\n        x_aug = np.linalg.solve(A, B)\n        p = x_aug[:n]\n        lmbda = x_aug[n]\n\n        # Calculate relative residual\n        residual_vec = L @ p + lmbda * np.ones(n) - b\n        \n        # Handle case where norm of b is zero (only for b0, but still good practice)\n        norm_b = np.linalg.norm(b)\n        if norm_b == 0:\n            relative_residual = np.linalg.norm(residual_vec)\n        else:\n            relative_residual = np.linalg.norm(residual_vec) / norm_b\n\n        # Calculate mean of the pressure solution\n        mean_p = np.mean(p)\n\n        results.append(relative_residual)\n        results.append(mean_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.15e}' for val in results)}]\")\n\nsolve()\n```", "id": "3307575"}, {"introduction": "理论分析和数值离散化最终要服务于解决具有复杂特征的实际流动问题，例如顶盖驱动方腔流中的角点奇性。本练习通过构造一个包含代数奇性的“人造解”问题，引导您探索如何通过网格分级策略来有效应对解的局部低正则性。您将通过计算实验收敛阶 (EOC) 来定量评估不同网格加密方案的优劣，从而掌握一种针对特定物理问题优化计算资源、提升求解精度的先进方法。[@problem_id:3307603]", "problem": "您需要推导、离散化并数值研究在不可压缩流中出现的压力泊松方程（PPE），重点关注类似于二维顶盖驱动方腔中的角点奇性。您的目标是将基本原理与实际的离散化方法联系起来，然后设计一种网格加密策略，该策略能适应压力场的局部正则性，以提高奇异角点附近的精度。\n\n从第一性原理出发：二维不可压缩流的恒定密度Navier–Stokes方程由质量守恒和动量守恒给出，\n- 连续性方程：$\\nabla \\cdot \\mathbf{u} = 0$，\n- 动量方程：$\\rho \\left( \\dfrac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot\\nabla \\mathbf{u} \\right) = -\\nabla p + \\mu \\nabla^2 \\mathbf{u}$，\n其中 $\\rho$ 是密度，$\\mu$ 是动力粘度，$\\mathbf{u}$ 是速度矢量，$p$ 是压力。\n\n您的任务是：\n\n- 推导。通过对动量方程应用散度算子并使用连续性方程，推导压力泊松方程（PPE）。说明您使用的所有假设。您推导出的方程必须是关于 $p$ 的标量椭圆方程，涉及 $\\mathbf{u}$ 的空间导数（不要代入任何特定的速度场）。\n\n- 角点奇性模型。考虑一个单位方腔的顶角，在顶盖驱动方腔问题中，已知由于角点处切向速度的不连续性，这些角点会在压力场中引发奇异行为。在不引用文献中特定问题的精确指数的情况下，假设角点附近的压力局部形式可以用一个指数为 $\\alpha \\in (0,2)$ 的代数奇性来捕捉，即当 $r \\to 0$ 时，压力表现为 $p(\\mathbf{x}) \\sim r^\\alpha \\phi(\\theta)$，其中 $(r,\\theta)$ 是以角点为中心​​的极坐标，$\\phi$ 是一个角函数。为了设计和测试一个对此类奇异结构敏感的离散化方法，在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上采用一个构造的压力场，该场叠加了左上角和右上角两个角点的贡献：\n$$\np_{\\mathrm{ex}}(x,y) = r_L(x,y)^{\\alpha} + r_R(x,y)^{\\alpha},\n$$\n其中 $r_L(x,y) = \\sqrt{(x-0)^2 + (y-1)^2}$ 和 $r_R(x,y) = \\sqrt{(x-1)^2 + (y-1)^2}$。在 $\\partial \\Omega$ 上使用狄利克雷边界条件 $p = p_{\\mathrm{ex}}$，源项 $f$ 通过椭圆方程 $-\\nabla^2 p = f$ 由构造解确定。对于您选择的 $p_{\\mathrm{ex}}$，源项为\n$$\nf(x,y) = -\\Delta p_{\\mathrm{ex}}(x,y) = -\\alpha^2 \\left( r_L(x,y)^{\\alpha-2} + r_R(x,y)^{\\alpha-2} \\right).\n$$\n\n- 离散化。在一个具有节点 $\\{x_i\\}_{i=0}^{N-1}$ 和 $\\{y_j\\}_{j=0}^{N-1}$ 的非均匀笛卡尔网格上，使用在非均匀网格上有效的守恒型有限体积法或等效的二阶有限差分格式来离散化算子 $-\\nabla^2 p$。对于每个间距为 $\\Delta x_w = x_i - x_{i-1}$、$\\Delta x_e = x_{i+1} - x_i$、$\\Delta y_s = y_j - y_{j-1}$ 和 $\\Delta y_n = y_{j+1} - y_j$ 的内部节点 $(i,j)$，定义一维二阶导数系数\n$$\na_W = \\frac{2}{\\Delta x_w(\\Delta x_w + \\Delta x_e)},\\quad a_E = \\frac{2}{\\Delta x_e(\\Delta x_w + \\Delta x_e)},\n$$\n$$\na_S = \\frac{2}{\\Delta y_s(\\Delta y_s + \\Delta y_n)},\\quad a_N = \\frac{2}{\\Delta y_n(\\Delta y_s + \\Delta y_n)},\n$$\n并组装 $-\\nabla^2 p$ 的离散算子为\n$$\n\\left(a_W + a_E + a_S + a_N\\right) p_{i,j} - a_W p_{i-1,j} - a_E p_{i+1,j} - a_S p_{i,j-1} - a_N p_{i,j+1} = f_{i,j},\n$$\n通过在边界节点上设置 $p_{i,j} = p_{\\mathrm{ex}}(x_i,y_j)$，在 $\\partial \\Omega$ 上强施加狄利克雷边界条件。\n\n- 网格加密设计。设非均匀网格由一个带有加密参数 $\\gamma \\geq 1$ 的对称的、向角点聚集的映射生成，定义为\n$$\nx(\\xi;\\gamma) = \\begin{cases} \\dfrac{1}{2} \\left( 2\\xi \\right)^{\\gamma},  \\xi \\in [0,\\tfrac{1}{2}] \\\\ 1 - \\dfrac{1}{2} \\left( 2(1-\\xi) \\right)^{\\gamma},  \\xi \\in (\\tfrac{1}{2},1] \\end{cases} \\quad y(\\eta;\\gamma) = \\begin{cases} \\dfrac{1}{2} \\left( 2\\eta \\right)^{\\gamma},  \\eta \\in [0,\\tfrac{1}{2}] \\\\ 1 - \\dfrac{1}{2} \\left( 2(1-\\eta) \\right)^{\\gamma},  \\eta \\in (\\tfrac{1}{2},1] \\end{cases}\n$$\n其中 $\\xi = i/(N-1)$ 和 $\\eta = j/(N-1)$，对于 $i,j \\in \\{0,\\dots,N-1\\}$。较大的 $\\gamma$ 会更强地将网格点聚集在所有四个边界附近，因此也包括两个顶角。\n\n- 误差度量与实验收敛阶。对于一个具有网格单元宽度 $h_{x,i} = \\tfrac{1}{2}(\\Delta x_w + \\Delta x_e)$ 和 $h_{y,j} = \\tfrac{1}{2}(\\Delta y_s + \\Delta y_n)$ 的网格，定义控制体面积 $A_{i,j} = h_{x,i} h_{y,j}$。通过以下公式定义数值解 $p_h$ 相对于 $p_{\\mathrm{ex}}$ 的离散 $L^2$ 误差：\n$$\n\\|e_h\\|_{L^2(\\Omega)} = \\left( \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( p_h(x_i,y_j) - p_{\\mathrm{ex}}(x_i,y_j) \\right)^2 A_{i,j} \\right)^{1/2}.\n$$\n使用最大近邻间距定义一个特征网格尺寸，\n$$\nh_{\\max} = \\max\\left( \\max_{0 \\le i \\le N-2} (x_{i+1} - x_i),\\ \\max_{0 \\le j \\le N-2} (y_{j+1} - y_j) \\right).\n$$\n给定两个用相同 $\\gamma$ 但不同 $N$ 生成的网格（一个粗网格，分辨率为 $N_{\\mathrm{c}}$，一个细网格，分辨率为 $N_{\\mathrm{f}}$），通过以下公式定义实验观测收敛阶（EOC）：\n$$\n\\mathrm{EOC} = \\frac{\\log\\left( \\|e_{h_{\\mathrm{c}}}\\|_{L^2(\\Omega)} \\big/ \\|e_{h_{\\mathrm{f}}}\\|_{L^2(\\Omega)} \\right)}{\\log\\left( h_{\\max,\\mathrm{c}} \\big/ h_{\\max,\\mathrm{f}} \\right)}.\n$$\n\n- 择优设计策略。对于给定的角点正则性指数 $\\alpha$ 和一组候补加密参数 $\\Gamma = \\{\\gamma_1,\\dots,\\gamma_K\\}$（其中 $\\gamma_1=1$ 代表均匀网格），使用一对分辨率为 $(N_{\\mathrm{c}},N_{\\mathrm{f}}) = (N,2N)$ 的网格为每个 $\\gamma \\in \\Gamma$ 计算 EOC，并选择使 EOC 最大化的 $\\gamma^\\star \\in \\Gamma$。报告均匀网格的EOC（即在 $\\gamma=1$ 时的值）和最佳EOC以及对应的 $\\gamma^\\star$。\n\n您的程序必须实现上述的离散化和网格加密，并且必须应用一个由以下案例组成的测试套件：\n- 案例1：$\\alpha = 0.5$，$N = 24$，$\\Gamma = \\{1.0, 1.5, 2.0, 2.5\\}$。\n- 案例2：$\\alpha = 1.5$，$N = 24$，$\\Gamma = \\{1.0, 1.5, 2.0, 2.5\\}$。\n- 案例3：$\\alpha = 0.25$，$N = 24$，$\\Gamma = \\{1.0, 1.5, 2.0, 2.5\\}$。\n\n您的程序应按指定顺序为每个案例计算一个三元组，包括均匀网格的EOC、候补集中的最佳EOC以及 $\\gamma^\\star$ 的值。最终输出必须是单行文本，包含一个用方括号括起来的、由逗号分隔的所有九个数字的列表，顺序如下：\n$$\n\\left[ \\mathrm{EOC}_{\\mathrm{unif}}^{(1)},\\ \\mathrm{EOC}_{\\mathrm{best}}^{(1)},\\ \\gamma^{\\star}_{(1)},\\ \\mathrm{EOC}_{\\mathrm{unif}}^{(2)},\\ \\mathrm{EOC}_{\\mathrm{best}}^{(2)},\\ \\gamma^{\\star}_{(2)},\\ \\mathrm{EOC}_{\\mathrm{unif}}^{(3)},\\ \\mathrm{EOC}_{\\mathrm{best}}^{(3)},\\ \\gamma^{\\star}_{(3)} \\right].\n$$\n不需要物理单位。如果在您的推理中出现任何角度，都必须以弧度为单位。输出值必须是浮点数。", "solution": "用户的要求是推导压力泊松方程（PPE），然后为一个模拟角点奇性的构造问题进行离散化和求解。任务的核心是设计一个数值实验，以找到一种优化的网格加密策略，从而提高低正则性解的精度。\n\n### 步骤1：压力泊松方程（PPE）的推导\n\n出发点是针对密度为 $\\rho$、动力粘度为 $\\mu$ 的恒定流体的不可压缩Navier-Stokes方程组：\n\n- **连续性方程：**\n$$ \\nabla \\cdot \\boldsymbol{u} = 0 $$\n- **动量方程：**\n$$ \\rho \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u} \\right) = -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} $$\n\n这里，$\\boldsymbol{u}$ 是速度矢量场，$p$ 是压力场。为了推导压力的方程，我们可以通过对动量方程应用散度算子（$\\nabla \\cdot$）来消去时间导数项。\n\n推导过程基于以下假设：\n1.  密度 $\\rho$ 和动力粘度 $\\mu$ 在整个流体域中是常数。\n2.  速度场和压力场足够光滑，允许交换微分顺序（例如，$\\nabla \\cdot (\\partial \\boldsymbol{u} / \\partial t) = \\partial (\\nabla \\cdot \\boldsymbol{u}) / \\partial t$）。\n\n对动量方程的每一项应用散度算子，得到：\n$$ \\nabla \\cdot \\left( \\rho \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u} \\right) \\right) = \\nabla \\cdot \\left( -\\nabla p + \\mu \\nabla^2 \\boldsymbol{u} \\right) $$\n\n由于 $\\rho$ 和 $\\mu$ 是常数，它们可以移到散度算子之外：\n$$ \\rho \\nabla \\cdot \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} \\right) + \\rho \\nabla \\cdot (\\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u}) = -\\nabla \\cdot (\\nabla p) + \\mu \\nabla \\cdot (\\nabla^2 \\boldsymbol{u}) $$\n\n我们分析每一项：\n-   时间导数项变为 $\\rho \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\boldsymbol{u})$。根据连续性方程，$\\nabla \\cdot \\boldsymbol{u} = 0$，所以整个项为零。\n-   压力项变为 $-\\nabla^2 p$，即压力的拉普拉斯算子。\n-   粘性项可以重写为 $\\mu \\nabla^2(\\nabla \\cdot \\boldsymbol{u})$。再次使用连续性方程，此项也为零。\n\n将这些简化代回方程中，我们剩下：\n$$ \\rho \\nabla \\cdot (\\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u}) = -\\nabla^2 p $$\n\n整理后得到压力泊松方程（PPE）：\n$$ \\nabla^2 p = -\\rho \\nabla \\cdot (\\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u}) $$\n这是一个关于压力 $p$ 的标量椭圆偏微分方程。右侧的源项，通常表示为 $f_p = -\\rho \\nabla \\cdot (\\boldsymbol{u}\\cdot\\nabla \\boldsymbol{u})$，仅依赖于速度场 $\\boldsymbol{u}$ 的空间导数。该方程在求解不可压缩Navier-Stokes方程的投影法中至关重要，用于在每个时间步强制执行不可压缩约束。\n\n### 步骤2：构造问题的数值方法\n\n问题要求我们在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上求解一个简化的稳态PPE版本，即 $-\\nabla^2 p = f$。这是一个用于测试数值方案的泊松模型问题。\n\n**构造解与源项**\n为了模拟左上角 $(0,1)$ 和右上角 $(1,1)$ 的代数奇性，给定了一个构造解：\n$$ p_{\\mathrm{ex}}(x,y) = r_L(x,y)^{\\alpha} + r_R(x,y)^{\\alpha} $$\n其中 $r_L(x,y) = \\sqrt{x^2 + (y-1)^2}$ 和 $r_R(x,y) = \\sqrt{(x-1)^2 + (y-1)^2}$ 是到角点的距离，$\\alpha \\in (0,2)$ 是奇性指数。源项 $f(x,y)$ 通过强制 $p_{\\mathrm{ex}}$ 为精确解来确定，即 $f = -\\nabla^2 p_{\\mathrm{ex}}$。单项 $r^\\alpha$ 的拉普拉斯算子为 $\\nabla^2(r^\\alpha) = \\alpha^2 r^{\\alpha-2}$。因此，源项为：\n$$ f(x,y) = -\\alpha^2 \\left( r_L(x,y)^{\\alpha-2} + r_R(x,y)^{\\alpha-2} \\right) $$\n对于 $\\alpha  2$，该源项在角点处是奇异的。边界条件为狄利克雷类型，在 $\\partial \\Omega$ 上指定 $p = p_{\\mathrm{ex}}$。\n\n**在非均匀网格上的离散化**\n区域使用以顶点 $(x_i, y_j)$ 为中心的网格进行离散化。问题提供了一个在内部节点 $(i,j)$ 处针对负拉普拉斯算子 $-\\nabla^2$ 的二阶精度有限差分格式：\n$$ -\\nabla^2 p \\Big|_{(x_i,y_j)} \\approx \\left(a_W + a_E + a_S + a_N\\right) p_{i,j} - a_W p_{i-1,j} - a_E p_{i+1,j} - a_S p_{i,j-1} - a_N p_{i,j+1} $$\n系数是局部网格间距 $\\Delta x_w = x_i - x_{i-1}$、$\\Delta x_e = x_{i+1} - x_i$ 等的函数，由下式给出：\n$$ a_W = \\frac{2}{\\Delta x_w(\\Delta x_w + \\Delta x_e)}, \\quad a_E = \\frac{2}{\\Delta x_e(\\Delta x_w + \\Delta x_e)} $$\n$a_S$ 和 $a_N$ 的形式类似。该格式源于在非均匀网格上基于泰勒级数的标准中心差分近似。在每个内部网格节点 $(x_i, y_j)$（对于 $i,j \\in \\{1, \\dots, N-2\\}$）应用此离散算子，会产生一个包含 $(N-2)^2$ 个线性代数方程的系统。节点 $(i,j)$ 处的方程的一般形式是：\n$$ \\mathcal{L}_h(p)_{i,j} = f(x_i, y_j) $$\n这组方程可以写成矩阵形式 $A \\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是一个包含内部节点处 $(N-2)^2$ 个未知压力值的向量。矩阵 $A$ 是稀疏、带状且非奇异的。狄利克雷边界条件通过将已知的边界值移到右端向量 $\\mathbf{b}$ 来处理。例如，在与左边界相邻的内部节点 $(1,j)$ 处，项 $-a_W p_{0,j}$ 是已知的，因为 $p_{0,j} = p_{\\mathrm{ex}}(x_0, y_j)$，因此被加到右端。然后对得到的稀疏线性系统进行数值求解。\n\n**网格加密与误差分析**\n对于具有奇性的解，均匀网格效率低下。精度受限于最差的局部误差，该误差发生在奇点附近。网格加密通过在奇点附近聚集网格点来提高性能。指定的加密函数使用参数 $\\gamma \\ge 1$ 将计算空间 $(\\xi, \\eta)$ 中的均匀网格映射到物理空间 $(x, y)$ 中的非均匀网格。较大的 $\\gamma$ 会导致在区域边界附近更强的点聚集。\n\n数值解的质量通过其收敛率来评估。我们计算离散 $L^2$ 误差 $\\|e_h\\|_{L^2}$ 和一个特征网格尺寸 $h_{\\max}$。然后使用两种不同分辨率网格上的解来计算实验收敛阶（EOC）：\n$$ \\mathrm{EOC} = \\frac{\\log\\left( \\|e_{h_{\\mathrm{c}}}\\|_{L^2} / \\|e_{h_{\\mathrm{f}}}\\|_{L^2} \\right)}{\\log\\left( h_{\\max,\\mathrm{c}} / h_{\\max,\\mathrm{f}} \\right)} $$\n对于应用于光滑问题的二阶方案，EOC 应接近 $2$。对于在均匀网格（$\\gamma=1$）上的奇异问题，EOC 通常会降低到一个与奇性指数 $\\alpha$ 相关的值。目标是找到一个加密参数 $\\gamma^\\star$，以恢复更高的EOC，理想情况下接近最优阶 $2$。择优设计策略包括为一组候补 $\\gamma$ 值计算 EOC，并选择使 EOC 最大化的那个。此过程凭经验确定给定解正则性的最佳网格分布。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import dok_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # (alpha, N_coarse, Gamma_set)\n        (0.5, 24, [1.0, 1.5, 2.0, 2.5]),\n        (1.5, 24, [1.0, 1.5, 2.0, 2.5]),\n        (0.25, 24, [1.0, 1.5, 2.0, 2.5]),\n    ]\n\n    final_results = []\n    for alpha, N_c, Gamma in test_cases:\n        eocs = []\n        for gamma in Gamma:\n            # Coarse grid calculation\n            N_coarse = N_c\n            err_c, hmax_c = solve_poisson(N_coarse, alpha, gamma)\n\n            # Fine grid calculation\n            N_fine = 2 * N_c\n            err_f, hmax_f = solve_poisson(N_fine, alpha, gamma)\n            \n            # EOC calculation\n            # Add a small epsilon to denominator to avoid division by zero if errors are identical\n            if err_f > 0.0 and err_c > 0.0:\n                eoc = np.log(err_c / err_f) / np.log(hmax_c / hmax_f)\n            else:\n                eoc = 0.0 # Or some other indicator of no convergence\n            eocs.append(eoc)\n\n        eoc_unif = eocs[0]  # First gamma is 1.0 (uniform grid)\n        best_eoc = max(eocs)\n        best_gamma = Gamma[np.argmax(eocs)]\n        \n        final_results.extend([eoc_unif, best_eoc, best_gamma])\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef grid_map(xi, gamma):\n    \"\"\"\n    Applies the symmetric grading transformation.\n    xi: 1D array of uniform coordinates in [0, 1].\n    gamma: Grading parameter.\n    \"\"\"\n    x = np.zeros_like(xi, dtype=np.float64)\n    mask = xi = 0.5\n    x[mask] = 0.5 * (2 * xi[mask])**gamma\n    x[~mask] = 1.0 - 0.5 * (2 * (1.0 - xi[~mask]))**gamma\n    return x\n\ndef p_exact(x, y, alpha):\n    \"\"\"Manufactured solution p_ex.\"\"\"\n    r_L = np.sqrt(x**2 + (y - 1.0)**2)\n    r_R = np.sqrt((x - 1.0)**2 + (y - 1.0)**2)\n    return r_L**alpha + r_R**alpha\n\ndef f_source(x, y, alpha):\n    \"\"\"Source term f = -Laplacian(p_ex).\"\"\"\n    # Use a small epsilon to avoid division by zero at the singular corners\n    eps = 1e-16\n    r_L_sq = x**2 + (y - 1.0)**2 + eps\n    r_R_sq = (x - 1.0)**2 + (y - 1.0)**2 + eps\n    \n    term_L = r_L_sq**((alpha - 2.0) / 2.0)\n    term_R = r_R_sq**((alpha - 2.0) / 2.0)\n    \n    return -alpha**2 * (term_L + term_R)\n\ndef solve_poisson(N, alpha, gamma):\n    \"\"\"\n    Solves -Laplace(p) = f on a nonuniform grid.\n    Returns (L2_error, h_max).\n    \"\"\"\n    # 1. Generate grid\n    xi = np.linspace(0, 1, N)\n    x = grid_map(xi, gamma)\n    y = grid_map(xi, gamma)\n    X, Y = np.meshgrid(x, y)\n\n    # 2. Setup linear system A*p = b for interior nodes\n    n_unknowns = (N - 2)**2\n    A = dok_matrix((n_unknowns, n_unknowns), dtype=np.float64)\n    b = np.zeros(n_unknowns, dtype=np.float64)\n\n    idx_map = lambda i, j: (j - 1) * (N - 2) + (i - 1)\n\n    for j in range(1, N - 1):\n        for i in range(1, N - 1):\n            k = idx_map(i, j)\n            \n            # Grid spacings\n            dx_w = x[i] - x[i - 1]\n            dx_e = x[i + 1] - x[i]\n            dy_s = y[j] - y[j - 1]\n            dy_n = y[j + 1] - y[j]\n            \n            # Coefficients\n            a_W = 2.0 / (dx_w * (dx_w + dx_e))\n            a_E = 2.0 / (dx_e * (dx_w + dx_e))\n            a_S = 2.0 / (dy_s * (dy_s + dy_n))\n            a_N = 2.0 / (dy_n * (dy_s + dy_n))\n            \n            A[k, k] = a_W + a_E + a_S + a_N\n            \n            # RHS source term\n            b[k] = f_source(x[i], y[j], alpha)\n            \n            # Neighbors\n            # West\n            if i > 1:\n                A[k, idx_map(i - 1, j)] = -a_W\n            else:\n                b[k] += a_W * p_exact(x[0], y[j], alpha)\n            # East\n            if i  N - 2:\n                A[k, idx_map(i + 1, j)] = -a_E\n            else:\n                b[k] += a_E * p_exact(x[N - 1], y[j], alpha)\n            # South\n            if j > 1:\n                A[k, idx_map(i, j - 1)] = -a_S\n            else:\n                b[k] += a_S * p_exact(x[i], y[0], alpha)\n            # North\n            if j  N - 2:\n                A[k, idx_map(i, j + 1)] = -a_N\n            else:\n                b[k] += a_N * p_exact(x[i], y[N - 1], alpha)\n\n    # 3. Solve the system\n    A_csr = A.tocsr()\n    p_vec = spsolve(A_csr, b)\n\n    # 4. Reconstruct full solution and compute error\n    p_sol = np.zeros((N, N))\n    p_sol[1:-1, 1:-1] = p_vec.reshape((N - 2, N - 2))\n    \n    p_ex_grid = p_exact(X, Y, alpha)\n    p_sol[0, :] = p_ex_grid[0, :]\n    p_sol[-1, :] = p_ex_grid[-1, :]\n    p_sol[:, 0] = p_ex_grid[:, 0]\n    p_sol[:, -1] = p_ex_grid[:, -1]\n\n    # Error calculation using discrete L2 norm\n    error_grid = p_sol - p_ex_grid\n    error_sq_sum = 0.0\n    for j in range(1, N - 1):\n        for i in range(1, N - 1):\n            h_x = 0.5 * (x[i + 1] - x[i - 1])\n            h_y = 0.5 * (y[j + 1] - y[j - 1])\n            area = h_x * h_y\n            error_sq_sum += error_grid[j, i]**2 * area\n            \n    l2_error = np.sqrt(error_sq_sum)\n\n    # 5. Calculate h_max\n    dx = np.diff(x)\n    dy = np.diff(y)\n    h_max = max(np.max(dx), np.max(dy))\n    \n    return l2_error, h_max\n\nsolve()\n```", "id": "3307603"}]}