{"hands_on_practices": [{"introduction": "这个首个练习将欠松弛的概念建立在严格的稳定性分析之上。通过研究经典的对流-扩散方程，你将推导出最大稳定松弛因子与网格佩克莱特数（一个关键的无量纲数）之间的直接关系。这个练习旨在建立一种基本直觉，即松弛因子 $\\omega$ 的选择并非随意的，而是由底层物理和离散化方法决定的。[@problem_id:3386083]", "problem": "考虑在计算流体动力学（CFD）中用于求解稳态一维对流扩散方程的一种分离式不动点迭代。该方程通过有限体积法（FVM）在单元宽度为 $h$ 的均匀网格上进行离散化。无源标量场 $\\phi(x)$ 的控制连续方程为 $-\\alpha\\,\\frac{d^2 \\phi}{dx^2} + u\\,\\frac{d\\phi}{dx} = s(x)$，其中 $\\alpha > 0$ 是扩散系数，$u$ 是恒定的对流速度。在分离迭代中，扩散算子被隐式处理，而对流算子则根据前一次迭代的结果进行显式处理。定义面扩散系数 $D_f = \\alpha/h$ 和面对流大小 $F_f = |u|$，以及网格佩克莱特数 $Pe_h = \\dfrac{F_f}{2 D_f} = \\dfrac{|u| h}{2 \\alpha}$。\n\n从线性定常迭代和算子分裂的第一性原理出发，完成以下任务：\n\n1) 将分离迭代建模为离散单元中心未知量 $\\phi^k$ 的线性不动点更新，形式为 $\\phi^{k+1} = G(\\omega)\\,\\phi^k + c$，其中 $G(\\omega)$ 是通过欠松弛（UR）因子 $\\omega \\in (0,1]$ 修正的迭代矩阵，$c$ 是由源项和边界条件产生的常数向量。通过将离散算子分裂为隐式扩散部分和显式对流部分来推导 $G(\\omega)$ 的结构。然后，使用对流的中心差分格式，证明预处理的对流-扩散算子 $D^{-1} C$ 的谱是纯虚的，并根据网格佩克莱特数 $Pe_h$ 得出其谱半径的界。仅使用经过充分检验的矩阵分析工具，如诱导范数或 Gershgorin 型界，以及反对称矩阵的基本性质。\n\n2) 根据推导出的界，获得欠松弛因子 $\\omega$ 的充分稳定性判据，以使分离迭代是压缩的，即 $G(\\omega)$ 的谱半径严格小于 $1$。将最大稳定 $\\omega_{\\max}$ 表示为网格佩克莱特数 $Pe_h$ 的函数，并根据迭代矩阵的性质严格证明每一步。你的推导必须从不动点迭代结构开始，不得使用简化公式。\n\n3) 提出一种自适应欠松弛方案，该方案使用局部（单元）网格佩克莱特数 $Pe_i$ 来降低高佩克莱特数区域的 $\\omega$，以避免伪振荡。该方案必须同时满足以下两点：\n   - 遵守你推导出的充分稳定性界，即没有单元的欠松弛因子超过其 $Pe_i$ 所对应的充分稳定性值。\n   - 强制执行一个全局上限 $\\omega \\le 1$。\n   为明确起见，对每个单元的因子使用公式 $\\omega_i = \\min(\\omega_{\\text{base}}, \\min(1, \\omega_{\\max}(Pe_i)))$，其中 $\\omega_{\\text{base}} \\in (0,1]$ 是用户选择的基准值。同时定义一个全局推荐值 $\\omega_{\\text{global}} = \\min_i \\omega_{\\max}(Pe_i)$，当使用单个全局 $\\omega$ 时，该值保证在所有单元中都满足充分稳定性界。\n\n4) 实现一个完整的程序，根据给定的测试输入集，按照推导出的充分稳定性界计算自适应的单元欠松弛因子和全局推荐值。本问题中的所有量都是无量纲的，不需要物理单位。对于数值报告，将浮点数结果四舍五入到 $8$ 位小数。\n\n测试套件：\n- 测试用例 1 (全局推荐，“理想路径”)：$Pe = [0.5, 1.0, 2.0]$，基准值 $\\omega_{\\text{base}} = 0.95$。将 $\\omega_{\\text{global}}$ 报告为单个浮点数。\n- 测试用例 2 (单元自适应，混合佩克莱特数)：$Pe = [0.1, 1.0, 5.0, 10.0]$，基准值 $\\omega_{\\text{base}} = 0.8$。报告列表 $[\\omega_1,\\omega_2,\\omega_3,\\omega_4]$。\n- 测试用例 3 (全局推荐，高佩克莱特数边界情况)：$Pe = [0.0, 100.0, 50.0]$，基准值 $\\omega_{\\text{base}} = 1.0$。将 $\\omega_{\\text{global}}$ 报告为单个浮点数。\n- 测试用例 4 (单元自适应，包括零佩克莱特数)：$Pe = [0.0, 0.5, 2.0, 20.0, 100.0]$，基准值 $\\omega_{\\text{base}} = 0.9$。报告列表 $[\\omega_1,\\omega_2,\\omega_3,\\omega_4,\\omega_5]$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含按上述四个测试用例顺序排列的结果，形式为逗号分隔的列表并用方括号括起来。具体来说，输出格式应为：\n$[\\omega_{\\text{global,TC1}}, [\\omega_i\\ \\text{for TC2}], \\omega_{\\text{global,TC3}}, [\\omega_i\\ \\text{for TC4}]]$\n每个浮点值都四舍五入到 $8$ 位小数。", "solution": "该问题要求对应用于一维稳态对流扩散方程的分离式迭代求解器的欠松弛方案进行分析和实现。分析按规定分为四个部分进行。\n\n### 1) 迭代矩阵和谱界的推导\n\n首先，我们使用有限体积法（FVM）在单元宽度为 $h$ 的均匀网格上离散化控制方程 $-\\alpha\\,\\frac{d^2 \\phi}{dx^2} + u\\,\\frac{d\\phi}{dx} = s(x)$。对围绕单元 $i$ 的控制体进行积分，并对扩散通量和对流通量使用中心差分，得到单元中心未知量 $\\phi_i$ 的离散方程：\n$$\n\\left(-\\frac{\\alpha}{h}(\\phi_{i+1} - \\phi_i)\\right) - \\left(-\\frac{\\alpha}{h}(\\phi_i - \\phi_{i-1})\\right) + \\left(u \\frac{\\phi_i + \\phi_{i+1}}{2}\\right) - \\left(u \\frac{\\phi_{i-1} + \\phi_i}{2}\\right) = S_i\n$$\n其中 $S_i$ 是单元 $i$ 的积分源项。合并各项，我们可以分离出扩散算子和对流算子的贡献。未知量向量 $\\phi$ 的离散系统可以写成 $(D_{mat} + C_{mat})\\phi = b$，其中 $b$ 是源项和边界条件项组成的向量。矩阵 $D_{mat}$ 和 $C_{mat}$ 分别表示离散化的扩散和对流算子。对于一个内部单元 $i$，它们的非零元为：\n- **扩散矩阵 ($D_{mat}$)**: $(D_{mat}\\phi)_i = \\frac{\\alpha}{h}(- \\phi_{i-1} + 2\\phi_i - \\phi_{i+1})$。该矩阵是对称的，并且在适当的边界条件下是正定的。\n- **对流矩阵 ($C_{mat}$)**: $(C_{mat}\\phi)_i = \\frac{u}{2}(- \\phi_{i-1} + \\phi_{i+1})$。该矩阵是实数且反对称的，即 $C_{mat}^T = -C_{mat}$。\n\n分离迭代隐式处理扩散部分，显式处理对流部分。这对应于一种矩阵分裂，其中中间场 $\\phi^*$ 的迭代由下式给出：\n$$\nD_{mat} \\phi^* = -C_{mat} \\phi^k + b\n$$\n使用因子 $\\omega \\in (0,1]$ 的欠松弛步骤利用 $\\phi^*$ 从前一次迭代的解 $\\phi^k$ 更新解：\n$$\n\\phi^{k+1} = (1-\\omega)\\phi^k + \\omega \\phi^* = (1-\\omega)\\phi^k + \\omega D_{mat}^{-1}(-C_{mat} \\phi^k + b)\n$$\n重新整理此式，得到标准的线性不动点形式 $\\phi^{k+1} = G(\\omega)\\phi^k + c$：\n$$\n\\phi^{k+1} = \\left((1-\\omega)I - \\omega D_{mat}^{-1} C_{mat}\\right) \\phi^k + \\omega D_{mat}^{-1} b\n$$\n因此，迭代矩阵为 $G(\\omega) = (1-\\omega)I - \\omega G_{PC}$，其中 $G_{PC} = D_{mat}^{-1} C_{mat}$ 是预处理的对流-扩散算子。常数向量为 $c = \\omega D_{mat}^{-1} b$。\n\n接下来，我们证明 $G_{PC}$ 的谱是纯虚的。设 $\\lambda$ 是 $G_{PC}$ 的一个特征值，对应的特征向量为 $v$：\n$$\nD_{mat}^{-1} C_{mat} v = \\lambda v \\implies C_{mat} v = \\lambda D_{mat} v\n$$\n对该方程取共轭转置，得到 $v^* C_{mat}^* = \\bar{\\lambda} v^* D_{mat}^*$。由于 $D_{mat}$ 是实对称矩阵（$D_{mat}^* = D_{mat}$），而 $C_{mat}$ 是实反对称矩阵（$C_{mat}^* = C_{mat}^T = -C_{mat}$），上式变为 $-v^* C_{mat} = \\bar{\\lambda} v^* D_{mat}$。\n用 $v^*$ 左乘原始特征值方程，得到 $v^* C_{mat} v = \\lambda v^* D_{mat} v$。将此式与共轭转置得到的结果 $-v^* C_{mat} v = \\bar{\\lambda} v^* D_{mat} v$ 相加，可得：\n$$\n0 = (\\lambda + \\bar{\\lambda})(v^* D_{mat} v) = 2 \\text{Re}(\\lambda) (v^* D_{mat} v)\n$$\n由于 $D_{mat}$ 是正定的，对于任何非零特征向量 $v$，$v^* D_{mat} v > 0$。因此，我们必须有 $\\text{Re}(\\lambda) = 0$，这证明了 $G_{PC}$ 的特征值是纯虚的，即形式为 $\\lambda = i\\beta$，其中 $\\beta$ 为实数。\n\n为了获得谱半径 $\\rho(G_{PC}) = \\max |\\lambda|$ 的一个界，我们进行局部分析。设 $v_k$ 是特征向量 $v$ 中模长最大的分量，即对所有 $j$ 都有 $|v_k| \\ge |v_j|$。特征值方程 $C_{mat} v = \\lambda D_{mat} v$ 的第 $k$ 行为：\n$$\n\\frac{u}{2}(v_{k+1} - v_{k-1}) = \\lambda \\frac{\\alpha}{h}(-v_{k-1} + 2v_k - v_{k+1})\n$$\n假设 $v_k \\ne 0$，我们用它除以方程并重新整理以求解 $\\lambda$：\n$$\n\\lambda = \\frac{\\frac{u}{2}(\\frac{v_{k+1}}{v_k} - \\frac{v_{k-1}}{v_k})}{\\frac{\\alpha}{h}(2 - \\frac{v_{k-1}}{v_k} - \\frac{v_{k+1}}{v_k})} = \\frac{|u|h}{2\\alpha} \\frac{\\frac{u}{|u|}(\\frac{v_{k+1}}{v_k} - \\frac{v_{k-1}}{v_k})}{2 - (\\frac{v_{k-1}}{v_k} + \\frac{v_{k+1}}{v_k})}\n$$\n设 $z_1 = \\frac{v_{k+1}}{v_k}$ 和 $z_2 = \\frac{v_{k-1}}{v_k}$。根据 $v_k$ 的定义，有 $|z_1| \\le 1$ 和 $|z_2| \\le 1$。网格佩克莱特数为 $Pe_h = \\frac{|u|h}{2\\alpha}$。取其模长：\n$$\n|\\lambda| = Pe_h \\left| \\frac{z_1 - z_2}{2 - (z_1+z_2)} \\right| \\le Pe_h \\sup_{|z_1|\\le 1, |z_2|\\le 1} \\frac{|z_1 - z_2|}{|2 - (z_1+z_2)|}\n$$\n在定义的约束条件下，使右侧表达式最大化的选择发生在 $z_1 = i$ 和 $z_2 = -i$ 时，其值为 $\\frac{|i - (-i)|}{|2 - (i-i)|} = \\frac{|2i|}{|2|} = 1$。因此，我们得到了谱半径的界：\n$$\n\\rho(G_{PC}) = \\max |\\lambda| \\le Pe_h\n$$\n\n### 2) 稳定性判据的推导\n\n为使迭代是压缩的，迭代矩阵 $G(\\omega)$ 的谱半径必须严格小于1，即 $\\rho(G(\\omega))  1$。$G(\\omega)$ 的特征值 $\\mu$ 与 $G_{PC}$ 的特征值 $\\lambda$ 通过关系式 $\\mu = (1-\\omega) - \\omega \\lambda$ 相关联。\n根据第一部分的发现，我们有 $\\lambda = i\\beta$ 且 $|\\beta| \\le Pe_h$。$\\mu$ 的模长为：\n$$\n|\\mu|^2 = |(1-\\omega) - i\\omega\\beta|^2 = (1-\\omega)^2 + (\\omega\\beta)^2\n$$\n为了确保稳定性，我们需要对所有可能的 $\\beta$ 值都有 $|\\mu|^2  1$。对于 $|\\beta|$ 的最大值，此条件最为严格，因此通过设 $|\\beta| = \\rho(G_{PC})$ 并使用我们的界 $|\\beta| \\le Pe_h$，可以找到一个稳定性的充分条件：\n$$\n(1-\\omega)^2 + \\omega^2 Pe_h^2  1\n$$\n对于 $\\omega \\in (0,1]$，展开并简化该不等式：\n$$\n1 - 2\\omega + \\omega^2 + \\omega^2 Pe_h^2  1\n$$\n$$\n-2\\omega + \\omega^2(1+Pe_h^2)  0\n$$\n由于 $\\omega > 0$，我们可以用它来除：\n$$\n-2 + \\omega(1+Pe_h^2)  0\n$$\n$$\n\\omega (1+Pe_h^2)  2 \\implies \\omega  \\frac{2}{1+Pe_h^2}\n$$\n这就是我们从谱界推导出的充分稳定性判据。由于问题指定欠松弛因子必须在范围 $\\omega \\in (0,1]$ 内，$\\omega$ 的最大允许值必须同时满足这两个约束。因此，最大稳定欠松弛因子 $\\omega_{\\max}$ 由下式给出：\n$$\n\\omega_{\\max}(Pe_h) = \\min\\left(1, \\frac{2}{1+Pe_h^2}\\right)\n$$\n\n### 3) 自适应欠松弛方案\n\n基于推导出的稳定性界，我们可以定义一个自适应欠松弛方案，该方案根据局部网格佩克莱特数 $Pe_i$ 调整因子 $\\omega_i$。\n\n佩克莱特数为 $Pe_i$ 的单元的最大稳定欠松弛因子为 $\\omega_{\\max}(Pe_i) = \\min\\left(1, \\frac{2}{1+Pe_i^2}\\right)$。当 $Pe_i \\le 1$ 时，该函数值为 $1$，并随着 $Pe_i$ 的增加而趋向于 $0$。\n\n自适应的单元欠松弛因子 $\\omega_i$ 的方案由以下公式给出：\n$$\n\\omega_i = \\min(\\omega_{\\text{base}}, \\min(1, \\omega_{\\max}(Pe_i)))\n$$\n正如在第 2 部分中论证的，项 $\\min(1, \\omega_{\\max}(Pe_i))$ 就是 $\\omega_{\\max}(Pe_i)$，因为 $\\omega_{\\max}(Pe_i)$ 本身已经被限制在 $1$ 以下。因此，公式简化为：\n$$\n\\omega_i = \\min(\\omega_{\\text{base}}, \\omega_{\\max}(Pe_i)) = \\min\\left(\\omega_{\\text{base}}, \\frac{2}{1+Pe_i^2}\\right)\n$$\n注意，由于 $\\omega_{\\text{base}} \\le 1$，组合表达式也被限制在 $1$ 以下。\n\n对于保证所有单元稳定性的单个全局欠松弛因子 $\\omega_{\\text{global}}$，我们必须在所有单元的稳定性限制中选择最严格（最小）的值：\n$$\n\\omega_{\\text{global}} = \\min_{i} \\omega_{\\max}(Pe_i)\n$$\n由于 $\\omega_{\\max}(Pe)$ 是 $Pe \\ge 0$ 时 $Pe$ 的单调递减函数，这个最小值对应于具有最大佩克莱特数 $Pe_{\\max} = \\max_i Pe_i$ 的单元：\n$$\n\\omega_{\\text{global}} = \\omega_{\\max}(Pe_{\\max}) = \\min\\left(1, \\frac{2}{1+Pe_{\\max}^2}\\right)\n$$\n\n### 4) 程序实现\n\n下面的 Python 程序实现了推导出的公式，用于为提供的测试套件计算自适应和全局欠松弛因子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating under-relaxation factors for given test cases.\n    \"\"\"\n\n    test_cases = [\n        {'type': 'global', 'Pe': [0.5, 1.0, 2.0], 'w_base': 0.95},\n        {'type': 'per-cell', 'Pe': [0.1, 1.0, 5.0, 10.0], 'w_base': 0.8},\n        {'type': 'global', 'Pe': [0.0, 100.0, 50.0], 'w_base': 1.0},\n        {'type': 'per-cell', 'Pe': [0.0, 0.5, 2.0, 20.0, 100.0], 'w_base': 0.9},\n    ]\n\n    results = []\n    \n    def get_w_max(pe):\n        \"\"\"\n        Calculates the maximum stable under-relaxation factor for a given Peclet number.\n        omega_max(Pe) = min(1, 2 / (1 + Pe^2))\n        \"\"\"\n        if pe  0:\n            # Peclet number is defined based on |u|, so it should be non-negative.\n            raise ValueError(\"Peclet number cannot be negative.\")\n        \n        # The stability bound derived from first principles.\n        bound = 2.0 / (1.0 + pe**2)\n        \n        # The final value is capped at 1.0 as per omega in (0, 1].\n        return min(1.0, bound)\n\n    for case in test_cases:\n        pe_list = case['Pe']\n        \n        if case['type'] == 'global':\n            # For the global recommendation, find the maximum Peclet number in the list.\n            if not pe_list:\n                # Handle empty list case to avoid error with max()\n                max_pe = 0.0\n            else:\n                max_pe = max(pe_list)\n            \n            # The global omega is determined by the most restrictive (highest Pe) case.\n            w_global = get_w_max(max_pe)\n            results.append(w_global)\n            \n        elif case['type'] == 'per-cell':\n            w_base = case['w_base']\n            w_adaptive_list = []\n            \n            # For the per-cell adaptive scheme, calculate omega for each cell.\n            for pe in pe_list:\n                # The local stability limit for the cell's Peclet number.\n                w_limit = get_w_max(pe)\n                \n                # The actual omega used is the minimum of the base value and the local limit.\n                # omega_i = min(omega_base, omega_max(Pe_i))\n                w_i = min(w_base, w_limit)\n                w_adaptive_list.append(w_i)\n            results.append(w_adaptive_list)\n\n    # Helper function to format results exactly as required.\n    def format_result(item):\n        if isinstance(item, list):\n            # Format each float in the list to 8 decimal places and join them.\n            formatted_list = [f\"{x:.8f}\" for x in item]\n            return f\"[{','.join(formatted_list)}]\"\n        elif isinstance(item, float):\n            # Format a single float to 8 decimal places.\n            return f\"{item:.8f}\"\n        else:\n            return str(item)\n\n    # Convert all results to the specified string format.\n    final_output_strings = [format_result(r) for r in results]\n    \n    # Print the final comma-separated list enclosed in square brackets.\n    print(f\"[{','.join(final_output_strings)}]\")\n\nsolve()\n```", "id": "3386083"}, {"introduction": "虽然解析稳定性判据非常强大，但对于像反应流这样的复杂非线性系统，它们往往难以推导。本练习介绍了一种更通用、更鲁棒的方法：一种使用回溯线搜索的单调性保护方案。你将实现该方法，以观察它如何在一个固定松弛因子可能失效的刚性问题中强制收敛，从而突显从解析稳定性到算法鲁棒性的转变。[@problem_id:3386114]", "problem": "您必须设计并实现一种用于迭代耦合的、带单调性保障的欠松弛方案，该方案在每次接受的更新中强制残差下降，并在一个具有代表性的反应性可压缩流简化模型上，量化其计算开销与迭代次数减少之间的关系。目标读者为计算流体动力学（CFD）领域的高阶研究生。程序必须是完整且可运行的。\n\n考虑以下单个控制体积内反应性可压缩混合物的无量纲简化稳态模型。未知状态向量为 $x = [T, Y]^{\\top}$，其中 $T$ 是无量纲温度，$Y$ 是无量纲反应进度变量。控制稳态残差定义为\n$$\nr(x) =\n\\begin{bmatrix}\nr_T(T, Y) \\\\\nr_Y(T, Y)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\alpha \\,(T - T_a) + q\\,S(T, Y) \\\\\n-\\beta\\,Y + S(T, Y)\n\\end{bmatrix},\n$$\n其中反应源项为\n$$\nS(T, Y) = k_0 \\,\\exp\\!\\left(-\\frac{E}{T}\\right) \\,(1 - Y) - k_1 \\, Y,\n$$\n其中参数 $\\alpha$、$\\beta$、$k_0$、$E$、$k_1$、$q$ 和环境温度 $T_a$ 均为严格正值。该模型捕捉了关键的刚性和耦合特性：温度 $T$ 通过阿伦尼乌斯因子 $\\exp\\!\\left(-E/T\\right)$ 进入 $S(T, Y)$，而热释放 $q\\,S(T,Y)$ 通过能量残差 $r_T$ 反向耦合回 $T$；$Y$ 在损耗项 $\\beta Y$ 和消耗项 $k_1 Y$ 的作用下进行松弛，并与生成项 $k_0 \\exp(-E/T)(1-Y)$ 相平衡。\n\n您将使用一个通过顺序子求解定义的迭代耦合映射 $G(x)$：\n- 在当前迭代点 $T^k$ 处冻结温度，通过精确求解 $r_Y(T^k, Y) = 0$ 来计算组分更新，从而得到 $Y$：\n$$\nY^{\\star}(T^k) = \\frac{k_0 \\exp\\!\\left(-\\frac{E}{T^k}\\right)}{\\beta + k_1 + k_0 \\exp\\!\\left(-\\frac{E}{T^k}\\right)}.\n$$\n- 在 $Y^{\\star}(T^k)$ 处冻结组分，通过在一个物理上合理的区间 $T \\in [T_{\\min}, T_{\\max}]$ 内求解 $r_T(T, Y^{\\star}(T^k)) = 0$ 来计算温度更新，其中 $T_{\\min} > 0$ 且 $T_{\\max}$ 足够大以包含预期解。该求解过程必须对由较大的 $E/T$ 引起的刚性具有鲁棒性。\n\n定义候选耦合更新方向 $s^k = G(x^k) - x^k$。带单调性保障的欠松弛通过回溯法选择一个步长 $\\omega_k \\in (0, 1]$，使得接受的更新 $x^{k+1} = x^k + \\omega_k s^k$ 满足残差范数下降条件\n$$\n\\left\\| r\\!\\left(x^{k+1}\\right) \\right\\|_2 \\le \\left\\| r\\!\\left(x^k\\right) \\right\\|_2,\n$$\n其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。如果一个试验步长 $\\omega$ 不满足该条件，则将 $\\omega$ 乘上一个在 $(0,1)$ 区间内的常数因子以减小步长，然后重试，直到成功或达到最小步长 $\\omega_{\\min}$ 为止。若达到最小步长仍不满足条件，则宣告未能找到单调下降的步长。\n\n您必须：\n- 从不动点耦合出发，根据第一性原理推导单调性保障，并展示其与残差范数下降条件的关系。\n- 实现两个求解器：\n  1. 一个基准迭代耦合求解器，使用固定的欠松弛因子 $\\omega_{\\text{const}} \\in (0,1]$，不带单调性保障。\n  2. 一个带单调性保障的回溯线搜索求解器，在 $\\omega_k$ 上执行搜索以强制满足 $\\left\\| r\\!\\left(x^{k+1}\\right) \\right\\|_2 \\le \\left\\| r\\!\\left(x^{k}\\right) \\right\\|_2$。\n- 两个求解器使用相同的耦合映射 $G(x)$。\n- 使用收敛准则 $\\left\\| r\\!\\left(x^{k}\\right) \\right\\|_2 \\le \\varepsilon$（容差 $\\varepsilon = 10^{-6}$）和最大迭代次数 $k_{\\max} = 200$。\n- 对于每个测试案例，通过报告以下内容来量化开销与迭代次数减少之间的关系：\n  - 保障法收敛所需的迭代次数，为整数。\n  - 保障法执行的残差范数计算次数，为整数。仅计算用于收敛检查和回溯接受测试的 $\\left\\| r(x) \\right\\|_2$ 调用，不包括用于 $G(x)$ 的子求解器内部的计算。\n  - 在整个运行过程中 ω 的回溯减少总次数，为整数。\n  - 基准法收敛所需的迭代次数，为整数；如果未在 $k_{\\max}$ 内收敛，则为 -1。\n  - 基准法执行的残差范数计算次数，为整数。\n  - 开销，定义为保障法与基准法之间残差范数计算次数的差值，为整数。\n  - 迭代次数减少量，定义为基准法与保障法之间迭代次数的差值，为整数（正数表示保障法使用的迭代次数更少）。\n\n本问题中的所有变量和数字都是无量纲的；不需要物理单位。不使用角度。不得使用百分比。\n\n测试套件和参数。对于每个案例，使用 $T_a = 1$ 和下面提供的初始猜测值 $x^0 = [T^0, Y^0]^{\\top}$：\n- 案例 A（弱耦合，顺利情况）：\n  - $\\alpha = 1.0$, $\\beta = 0.5$, $k_0 = 10.0$, $E = 5.0$, $k_1 = 1.0$, $q = 1.0$, $T^0 = 0.8$, $Y^0 = 0.1$。\n- 案例 B（刚性反应，强阿伦尼乌斯非线性）：\n  - $\\alpha = 3.0$, $\\beta = 2.0$, $k_0 = 50.0$, $E = 20.0$, $k_1 = 1.0$, $q = 1.5$, $T^0 = 0.5$, $Y^0 = 0.0$。\n- 案例 C（接近平衡的初始条件）：\n  - $\\alpha = 1.5$, $\\beta = 1.0$, $k_0 = 30.0$, $E = 10.0$, $k_1 = 0.5$, $q = 1.5$, $T^0 = 1.0$, $Y^0 = Y^{\\star}(T^0)$，其中\n    $$\n    Y^{\\star}(T^0) = \\frac{k_0 \\exp\\!\\left(-\\frac{E}{T^0}\\right)}{\\beta + k_1 + k_0 \\exp\\!\\left(-\\frac{E}{T^0}\\right)}.\n    $$\n\n您的程序要使用的算法设置：\n- 固定的基准欠松弛因子 $\\omega_{\\text{const}} = 0.5$。\n- 保障法的回溯缩减因子 $\\theta = 0.5$（即每次回溯时 $\\omega \\leftarrow \\theta \\,\\omega$）。\n- 最小步长 $\\omega_{\\min} = 10^{-8}$。\n- 温度子求解的区间界定：从 $T_{\\min} = 10^{-3}$ 和 $T_{\\max} = 3.0$ 开始；如果未找到 $r_T(T, Y^{\\star}(T^k))$ 的符号变化，则通过序列 $10.0$、$50.0$、$100.0$ 几何级数地增加 $T_{\\max}$，直到找到符号变化或宣告无法界定区间。\n\n您的程序必须生成单行输出，其中按顺序包含案例 A、案例 B 和案例 C 的结果，格式为方括号括起来的、由逗号分隔的列表。每个内部列表必须具有以下形式\n$[\\text{iters\\_safe}, \\text{evals\\_safe}, \\text{backtracks\\_safe}, \\text{iters\\_base}, \\text{evals\\_base}, \\text{overhead}, \\text{iteration\\_delta}]$，\n所有条目均为整数。例如，打印的输出必须看起来像\n$[[a_1,b_1,c_1,d_1,e_1,f_1,g_1],[a_2,b_2,c_2,d_2,e_2,f_2,g_2],[a_3,b_3,c_3,d_3,e_3,f_3,g_3]]$。", "solution": "用户指定了一个问题，要求设计、实现并分析一个用于耦合非线性系统的带单调性保障的欠松弛方案，该系统代表了反应性可压缩流。该问题是有效的、有科学依据且适定的。我们将进行推导和求解。\n\n### 理论基础\n\n核心任务是为一个由残差函数 $r(x) = 0$ 定义的非线性方程组找到稳态解 $x$。状态向量为 $x = [T, Y]^{\\top}$，代表无量纲温度和反应进度。该系统描述如下：\n$$\nr(x) =\n\\begin{bmatrix}\nr_T(T, Y) \\\\\nr_Y(T, Y)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\alpha \\,(T - T_a) + q\\,S(T, Y) \\\\\n-\\beta\\,Y + S(T, Y)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\n0\n\\end{bmatrix}\n$$\n其中反应源项 $S(T, Y)$ 由阿伦尼乌斯型表达式给出：\n$$\nS(T, Y) = k_0 \\,\\exp\\!\\left(-\\frac{E}{T}\\right) \\,(1 - Y) - k_1 \\, Y\n$$\n\n处理此类多物理场问题的常用策略是迭代耦合或块高斯-赛德尔方法。问题定义了一个特定的耦合映射 $G(x^k)$，它通过顺序求解分量方程来生成下一个迭代的候选值 $x_{\\text{cand}} = G(x^k)$。此映射的不动点 $x = G(x)$ 是整个系统 $r(x) = 0$ 的一个解。\n\n最简单的迭代方法是直接不动点迭代，$x^{k+1} = G(x^k)$。然而，这种方法可能不稳定，特别是对于刚性系统，其迭代雅可比矩阵的特征值可能有很大的模。为了提高鲁棒性，我们引入一个欠松弛因子 $\\omega \\in (0, 1]$。更新步骤则是在候选解方向上的一个松弛步：\n$$\nx^{k+1} = x^k + \\omega (G(x^k) - x^k)\n$$\n这里，$s^k = G(x^k) - x^k$ 是由耦合映射提供的更新方向。\n\n问题要求比较两种选择 $\\omega$ 的策略：\n1. **基准方法**：在所有迭代中都使用一个恒定的欠松弛因子 $\\omega = \\omega_{\\text{const}}$。这种方法简单，但如果所选因子不适合问题的特定刚度，可能会收敛缓慢或失败。\n2. **带单调性保障的方法**：在每次迭代 $k$ 中自适应地选择步长 $\\omega_k$，以确保朝解的方向取得进展。进展由残差的欧几里得范数 $\\|r(x)\\|_2$ 来衡量。保障机制强制该范数简单单调下降：\n$$\n\\left\\| r(x^{k+1}) \\right\\|_2 \\le \\left\\| r(x^k) \\right\\|_2\n$$\n这个条件通过回溯线搜索来强制执行。我们从一个乐观的完整步长（$\\omega_k = 1$）开始，计算一个试验状态 $x_{\\text{trial}} = x^k + \\omega_k s^k$。如果试验状态满足单调性条件，则接受该步（$x^{k+1} = x_{\\text{trial}}$）。如果不满足，则认为该步过于激进。然后我们通过乘法方式减小步长（$\\omega_k \\leftarrow \\theta \\omega_k$，其中 $\\theta \\in (0, 1)$ 是一个缩减因子）来进行“回溯”，并重复试验，直到找到可接受的步长或步长小于预设的最小值 $\\omega_{\\min}$。\n\n这种保障机制将简单的不动点迭代转变为更鲁棒的非线性求解器。虽然方向 $s^k$ 不一定是函数 $f(x) = \\|r(x)\\|_2$ 的一个严格下降方向，但线搜索确保了我们不接受那些会移动到更高残差区域的步长，从而防止了在刚性、强耦合问题中常见的多种迭代发散形式。主要的权衡是，由于回溯循环中可能需要多次评估残差，每次迭代的计算成本会增加，但这可能会显著减少收敛所需的总迭代次数，尤其是在困难的情况下。\n\n### 实现策略\n\n实现将包括以下几个部分：\n- 用于计算源项 $S(T, Y)$ 和残差向量 $r(x)$ 的函数。\n- 用于计算耦合映射 $G(x)$ 的函数。这包括两个步骤：组分更新 $Y^{\\star}$ 的解析解和温度更新 $T^{\\star}$ 的数值一维求根。`scipy.optimize.brentq` 算法是求根步骤的理想选择，因为它鲁棒且保证能在函数值变号的给定区间内找到根。实现将包括问题指定的、在初始未界定根时扩展 $T^{\\star}$ 搜索区间的逻辑。\n- 两个求解器函数：`solver_baseline` 实现固定 $\\omega_{\\text{const}}$ 的方法，以及 `solver_safeguarded` 实现对 $\\omega_k$ 进行回溯线搜索的方法。\n- 每个求解器将跟踪迭代次数、残差范数评估次数，对于带保障的方法，还将跟踪回溯事件的总数。这些计数器严格按照问题的定义来实现。\n- 一个主驱动循环将为三个测试案例（A、B 和 C）中的每一个执行两个求解器，计算所要求的性能指标（开销和迭代次数减少量），并格式化结果以供打印。案例 C 的初始条件 $Y^0 = Y^{\\star}(T^0)$ 在启动求解器之前计算。在计算迭代减少量时，通过将未收敛情况的迭代次数（由-1表示）视为允许的最大值 $k_{\\max}$ 来处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to design, run, and compare the two under-relaxation schemes.\n    \"\"\"\n\n    # --- Algorithmic and Model Settings ---\n    K_MAX = 200\n    EPSILON = 1e-6\n    OMEGA_CONST = 0.5\n    THETA = 0.5\n    OMEGA_MIN = 1e-8\n    T_A = 1.0\n\n    # --- Helper Functions for the Physics Model ---\n\n    def S_term(T, Y, params):\n        \"\"\"Computes the dimensionless reaction source term S(T, Y).\"\"\"\n        k0, E, k1 = params['k0'], params['E'], params['k1']\n        if T = 0:\n            return -k1 * Y\n        return k0 * np.exp(-E / T) * (1 - Y) - k1 * Y\n\n    def residual(x, params):\n        \"\"\"Computes the residual vector r(x) = [r_T, r_Y]^T.\"\"\"\n        T, Y = x\n        alpha, beta, q = params['alpha'], params['beta'], params['q']\n        s_val = S_term(T, Y, params)\n        r_T = -alpha * (T - T_A) + q * s_val\n        r_Y = -beta * Y + s_val\n        return np.array([r_T, r_Y])\n\n    def coupling_map_G(x, params):\n        \"\"\"Computes the coupling map G(x) via sequential sub-solves.\"\"\"\n        T_k, _ = x\n        alpha, beta, k0, E, k1, q = params['alpha'], params['beta'], params['k0'], params['E'], params['k1'], params['q']\n\n        # 1. Compute species update Y_star by solving r_Y(T_k, Y) = 0\n        if T_k = 0:\n            exp_term = 0.0\n        else:\n            exp_term = k0 * np.exp(-E / T_k)\n        Y_star = exp_term / (beta + k1 + exp_term) if (beta + k1 + exp_term) != 0 else 0.0\n\n        # 2. Compute temperature update T_star by solving r_T(T, Y_star) = 0\n        def r_T_for_solve(T):\n            s_val = S_term(T, Y_star, params)\n            return -alpha * (T - T_A) + q * s_val\n\n        T_max_search_list = [3.0, 10.0, 50.0, 100.0]\n        T_min_br = 1e-3\n        T_star = None\n\n        for T_max_br in T_max_search_list:\n            try:\n                T_star = brentq(r_T_for_solve, T_min_br, T_max_br, xtol=1e-12, rtol=1e-12)\n                break\n            except ValueError:\n                continue\n        \n        if T_star is None:\n            raise RuntimeError(f\"Failed to bracket root for Temperature sub-problem with x_k={x}\")\n            \n        return np.array([T_star, Y_star])\n\n    # --- Iterative Solver Implementations ---\n\n    def solver_baseline(x0, params):\n        \"\"\"Baseline solver with fixed under-relaxation factor.\"\"\"\n        x = np.copy(x0)\n        evals = 0\n        \n        for k in range(K_MAX):\n            norm_r = np.linalg.norm(residual(x, params))\n            evals += 1\n            if norm_r = EPSILON:\n                return k, evals\n\n            x_cand = coupling_map_G(x, params)\n            x = x + OMEGA_CONST * (x_cand - x)\n\n        norm_r = np.linalg.norm(residual(x, params))\n        evals += 1\n        return (K_MAX, evals) if norm_r = EPSILON else (-1, evals)\n\n    def solver_safeguarded(x0, params):\n        \"\"\"Solver with monotonicity-safeguarded backtracking line search.\"\"\"\n        x = np.copy(x0)\n        evals = 0\n        backtracks = 0\n        \n        for k in range(K_MAX):\n            norm_r_k = np.linalg.norm(residual(x, params))\n            evals += 1\n            if norm_r_k = EPSILON:\n                return k, evals, backtracks\n            \n            s_k = coupling_map_G(x, params) - x\n            omega = 1.0\n            \n            while True:\n                x_trial = x + omega * s_k\n                norm_r_trial = np.linalg.norm(residual(x_trial, params))\n                evals += 1\n                \n                if norm_r_trial = norm_r_k:\n                    x = x_trial\n                    break\n                \n                omega *= THETA\n                backtracks += 1\n                \n                if omega  OMEGA_MIN:\n                    return -1, evals, backtracks\n\n        norm_r = np.linalg.norm(residual(x, params))\n        evals += 1\n        return (K_MAX, evals, backtracks) if norm_r = EPSILON else (-1, evals, backtracks)\n\n    # --- Main Execution ---\n\n    # Define the test cases from the problem statement.\n    case_a_params = {'alpha': 1.0, 'beta': 0.5, 'k0': 10.0, 'E': 5.0, 'k1': 1.0, 'q': 1.0}\n    case_b_params = {'alpha': 3.0, 'beta': 2.0, 'k0': 50.0, 'E': 20.0, 'k1': 1.0, 'q': 1.5}\n    case_c_params = {'alpha': 1.5, 'beta': 1.0, 'k0': 30.0, 'E': 10.0, 'k1': 0.5, 'q': 1.5}\n\n    # Calculate special initial condition for Case C\n    T0_c = 1.0\n    exp_term_c = case_c_params['k0'] * np.exp(-case_c_params['E'] / T0_c)\n    Y0_c = exp_term_c / (case_c_params['beta'] + case_c_params['k1'] + exp_term_c)\n    \n    test_cases = [\n        (case_a_params, np.array([0.8, 0.1])),\n        (case_b_params, np.array([0.5, 0.0])),\n        (case_c_params, np.array([T0_c, Y0_c])),\n    ]\n\n    results = []\n    for params, x0 in test_cases:\n        # Run safeguarded solver\n        iters_safe, evals_safe, backtracks_safe = solver_safeguarded(x0, params)\n        \n        # Run baseline solver\n        iters_base, evals_base = solver_baseline(x0, params)\n        \n        # Calculate derived metrics\n        overhead = evals_safe - evals_base\n        \n        # Handle -1 in iteration counts for a consistent delta\n        iters_safe_for_delta = iters_safe if iters_safe != -1 else K_MAX\n        iters_base_for_delta = iters_base if iters_base != -1 else K_MAX\n        iteration_delta = iters_base_for_delta - iters_safe_for_delta\n        \n        results.append([\n            iters_safe, evals_safe, backtracks_safe,\n            iters_base, evals_base,\n            overhead, iteration_delta\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3386114"}, {"introduction": "除了确保稳定收敛，我们通常还希望加速收敛。最后的这个练习将探讨Aitken的Delta-Squared方法，这是一种加速定点迭代收敛的经典技术。你将实现此方法以及至关重要的保护措施，以处理加速过程可能变得不稳定的情况，从而展示迭代求解器在速度和鲁棒性之间的实际权衡。[@problem_id:3386125]", "problem": "在计算流体动力学（CFD）的背景下，考虑两个子系统的迭代分区耦合，其中界面状态由向量 $\\boldsymbol{s}\\in\\mathbb{R}^n$ 表示。该耦合可抽象为一个不动点问题，即寻找 $\\boldsymbol{s}$ 使得 $\\boldsymbol{s}=\\boldsymbol{G}(\\boldsymbol{s})$，其中 $\\boldsymbol{G}:\\mathbb{R}^n\\rightarrow\\mathbb{R}^n$ 是一个光滑映射，代表两个子系统的复合作用。将第 $k$ 次迭代的残差定义为 $\\boldsymbol{r}^k=\\boldsymbol{G}(\\boldsymbol{s}^k)-\\boldsymbol{s}^k$。经典的 Picard 更新对应于 $\\boldsymbol{s}^{k+1}=\\boldsymbol{s}^k+\\alpha\\,\\boldsymbol{r}^k$，其中 $\\alpha$ 为常数松弛参数。在实践中，通过 Aitken's delta-squared 方法动态调整 $\\alpha_k$ 可以改善收敛性，但需要设置安全保护措施以防止由非线性或子系统间的瞬态不匹配引起的病态更新。\n\n您的任务是实现一个独立的程序，为一系列形式为 $\\boldsymbol{G}(\\boldsymbol{s})=\\boldsymbol{K}\\boldsymbol{s}+\\boldsymbol{b}$ 的线性测试问题应用一种带安全保护的基于 Aitken 方法的欠松弛算法，其中 $\\boldsymbol{K}\\in\\mathbb{R}^{n\\times n}$ 和 $\\boldsymbol{b}\\in\\mathbb{R}^n$ 是给定的。所有量均为无量纲。对于每次迭代，计算 $\\boldsymbol{r}^k=\\boldsymbol{G}(\\boldsymbol{s}^k)-\\boldsymbol{s}^k$，使用 Aitken's delta-squared 概念更新 $\\alpha_k$，强制执行安全保护 $\\alpha_k\\in[\\alpha_{\\min},\\alpha_{\\max}]$，并在残差增长满足判据 $\\|\\boldsymbol{r}^k\\|_2\\eta\\,\\|\\boldsymbol{r}^{k-1}\\|_2$ 时重启 Aitken 算法。使用 $\\boldsymbol{s}^0=\\boldsymbol{0}$ 和每个测试用例中提供的 $\\alpha_0$ 进行初始化。当 $\\|\\boldsymbol{r}^k\\|_2\\leq\\varepsilon$ 或迭代次数超过 $N_{\\max}$ 时停止。如果初始残差满足 $\\|\\boldsymbol{r}^0\\|_2\\leq\\varepsilon$，则定义迭代次数为 0。\n\n您必须在不使用问题陈述中简化公式的情况下实现 Aitken 更新；在您的解决方案中推导并使用一个合适的向量泛化形式。必须严格按照规定应用安全保护：对每次迭代强制执行 $\\alpha_k\\in[\\alpha_{\\min},\\alpha_{\\max}]$，并在满足 $\\|\\boldsymbol{r}^k\\|_2\\eta\\,\\|\\boldsymbol{r}^{k-1}\\|_2$ 时通过重置 $\\alpha_k:=\\alpha_0$ 来执行 Aitken 重启。如果方法在 $N_{\\max}$ 次迭代内未能收敛，则该测试用例返回 -1。\n\n为以下测试套件实现程序，使用欧几里得范数 $\\|\\cdot\\|_2$、容差 $\\varepsilon=10^{-8}$ 和最大迭代次数 $N_{\\max}=1000$。矩阵和向量如下所示，所有量均为无量纲：\n\n- 测试用例 1（顺利情况，中度振荡耦合）：\n  - $n=3$,\n  - $\\boldsymbol{K}=\\begin{bmatrix}0  -0.9  0\\\\ 0.8  0  0\\\\ 0  0.2  0.95\\end{bmatrix}$,\n  - $\\boldsymbol{b}=\\begin{bmatrix}1.0\\\\ -1.5\\\\ 0.5\\end{bmatrix}$,\n  - $\\alpha_0=0.5$, $\\alpha_{\\min}=0.05$, $\\alpha_{\\max}=0.95$, $\\eta=1.2$.\n- 测试用例 2（边界条件：固定松弛）：\n  - $n=3$,\n  - $\\boldsymbol{K}$ 和 $\\boldsymbol{b}$ 与测试用例 1 相同，\n  - $\\alpha_0=0.2$, $\\alpha_{\\min}=0.2$, $\\alpha_{\\max}=0.2$, $\\eta=2.0$.\n- 测试用例 3（频繁重启：激进的 $\\eta$）：\n  - $n=3$,\n  - $\\boldsymbol{K}$ 和 $\\boldsymbol{b}$ 与测试用例 1 相同，\n  - $\\alpha_0=0.5$, $\\alpha_{\\min}=0.05$, $\\alpha_{\\max}=0.95$, $\\eta=1.01$.\n- 测试用例 4（强振荡耦合与更紧的上界）：\n  - $n=3$,\n  - $\\boldsymbol{K}=\\begin{bmatrix}-0.99  0  0\\\\ 0  -0.9  0.05\\\\ 0  0.1  -0.95\\end{bmatrix}$,\n  - $\\boldsymbol{b}=\\begin{bmatrix}0.3\\\\ 1.0\\\\ -0.7\\end{bmatrix}$,\n  - $\\alpha_0=0.9$, $\\alpha_{\\min}=0.01$, $\\alpha_{\\max}=0.7$, $\\eta=1.5$.\n- 测试用例 5（零载荷边缘情况：立即收敛）：\n  - $n=3$,\n  - $\\boldsymbol{K}$ 与测试用例 1 相同，\n  - $\\boldsymbol{b}=\\begin{bmatrix}0.0\\\\ 0.0\\\\ 0.0\\end{bmatrix}$,\n  - $\\alpha_0=0.5$, $\\alpha_{\\min}=0.05$, $\\alpha_{\\max}=0.95$, $\\eta=1.2$.\n\n对于每个测试用例，程序必须输出满足 $\\|\\boldsymbol{r}^k\\|_2\\leq\\varepsilon$ 所需的迭代次数，如果在 $N_{\\max}$ 次迭代内未收敛，则输出 -1。您的程序应生成单行输出，包含这五个整数，以逗号分隔并用方括号括起来（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$）。不涉及物理单位，所有常数均为无量纲。", "solution": "该问题要求实现一种带安全保护的动态松弛迭代格式，以求解形式为 $\\boldsymbol{s}=\\boldsymbol{G}(\\boldsymbol{s})$ 的线性不动点问题，其中 $\\boldsymbol{G}(\\boldsymbol{s}) = \\boldsymbol{K}\\boldsymbol{s} + \\boldsymbol{b}$。这等价于求解线性系统 $(\\boldsymbol{I}-\\boldsymbol{K})\\boldsymbol{s}=\\boldsymbol{b}$。\n\n迭代更新规则由一个松弛 Picard 迭代给出：\n$$\n\\boldsymbol{s}^{k+1} = \\boldsymbol{s}^k + \\alpha_k \\boldsymbol{r}^k\n$$\n其中 $\\boldsymbol{s}^k \\in \\mathbb{R}^n$ 是第 $k$ 次迭代的状态向量，$\\boldsymbol{r}^k$ 是残差，$\\alpha_k$ 是一个标量松弛参数。残差被定义为映射后状态与当前状态之间的差值：\n$$\n\\boldsymbol{r}^k = \\boldsymbol{G}(\\boldsymbol{s}^k) - \\boldsymbol{s}^k = \\boldsymbol{K}\\boldsymbol{s}^k + \\boldsymbol{b} - \\boldsymbol{s}^k = (\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{s}^k + \\boldsymbol{b}\n$$\n任务的核心是使用 Aitken's delta-squared 方法的向量泛化形式，在特定安全保护的约束下，动态地确定每次迭代的 $\\alpha_k$。\n\n算法流程如下：\n在迭代 $k=0$ 时初始化：\n初始状态为 $\\boldsymbol{s}^0=\\boldsymbol{0}$。初始残差为 $\\boldsymbol{r}^0 = \\boldsymbol{G}(\\boldsymbol{s}^0) - \\boldsymbol{s}^0 = \\boldsymbol{K}\\boldsymbol{0} + \\boldsymbol{b} - \\boldsymbol{0} = \\boldsymbol{b}$。如果 $\\|\\boldsymbol{r}^0\\|_2 \\leq \\varepsilon$，则解已满足要求，过程以 0 次迭代终止。否则，第一步的初始松弛参数设置为所提供的值 $\\alpha_0$。\n\n对于后续的每次迭代 $k=1, 2, \\dots, N_{\\max}$：\n1.  使用前一状态 $\\boldsymbol{s}^{k-1}$、残差 $\\boldsymbol{r}^{k-1}$ 和松弛因子 $\\alpha_{k-1}$ 更新状态：\n    $$\n    \\boldsymbol{s}^{k} = \\boldsymbol{s}^{k-1} + \\alpha_{k-1} \\boldsymbol{r}^{k-1}\n    $$\n2.  在新状态 $\\boldsymbol{s}^k$ 处计算新残差：\n    $$\n    \\boldsymbol{r}^k = \\boldsymbol{G}(\\boldsymbol{s}^k) - \\boldsymbol{s}^k\n    $$\n3.  检查新残差的范数是否满足收敛容差 $\\varepsilon$。如果 $\\|\\boldsymbol{r}^k\\|_2 \\leq \\varepsilon$，则迭代已收敛，过程终止，返回迭代次数 $k$。\n\n4.  如果未收敛，则为下一步计算新的松弛因子 $\\alpha_k$。这涉及一系列安全保护措施和基于 Aitken 的更新。\n    a. **重启条件**：检查残差范数的增长情况。如果 $\\|\\boldsymbol{r}^k\\|_2  \\eta\\,\\|\\boldsymbol{r}^{k-1}\\|_2$，则认为 Aitken 更新不可靠，并通过将松弛因子重置为其初始值来重启过程：\n       $$\n       \\alpha_k := \\alpha_0\n       $$\n    b. **Aitken 更新**：如果未满足重启条件，则基于 Aitken 方法的向量泛化来计算 $\\alpha_k$。这种泛化可以通过在割线近似下，寻找一个能最小化后续残差 $\\boldsymbol{r}^{k+1}$ 范数的 $\\alpha_k$ 来推导。对于线性问题，连续残差之间的关系是：\n       $$\n       \\begin{aligned}\n       \\boldsymbol{r}^k  = \\boldsymbol{G}(\\boldsymbol{s}^k) - \\boldsymbol{s}^k \\\\\n        = \\boldsymbol{G}(\\boldsymbol{s}^{k-1} + \\alpha_{k-1}\\boldsymbol{r}^{k-1}) - (\\boldsymbol{s}^{k-1} + \\alpha_{k-1}\\boldsymbol{r}^{k-1}) \\\\\n        = \\boldsymbol{K}(\\boldsymbol{s}^{k-1} + \\alpha_{k-1}\\boldsymbol{r}^{k-1}) + \\boldsymbol{b} - \\boldsymbol{s}^{k-1} - \\alpha_{k-1}\\boldsymbol{r}^{k-1} \\\\\n        = (\\boldsymbol{K}\\boldsymbol{s}^{k-1} + \\boldsymbol{b} - \\boldsymbol{s}^{k-1}) + \\alpha_{k-1}(\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^{k-1} \\\\\n        = \\boldsymbol{r}^{k-1} + \\alpha_{k-1}(\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^{k-1}\n       \\end{aligned}\n       $$\n       这为我们提供了一种近似残差映射的雅可比矩阵 $\\boldsymbol{J_r} = \\boldsymbol{K}-\\boldsymbol{I}$ 作用的方式：\n       $$\n       (\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^{k-1} = \\frac{\\boldsymbol{r}^k - \\boldsymbol{r}^{k-1}}{\\alpha_{k-1}}\n       $$\n       下一步的最优松弛参数 $\\alpha_k$ 将最小化 $\\|\\boldsymbol{r}^{k+1}\\|_2^2 \\approx \\|\\boldsymbol{r}^k + \\alpha_k(\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^k\\|_2^2$。使该表达式最小化的 $\\alpha_k$ 值由最小二乘解给出：\n       $$\n       \\alpha_k = - \\frac{(\\boldsymbol{r}^k)^T ((\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^k)}{\\|(\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^k\\|_2^2}\n       $$\n       我们使用割线近似来逼近 $(\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^k$，假设雅可比矩阵的作用在迭代之间没有剧烈变化：$(\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^k \\approx (\\boldsymbol{K}-\\boldsymbol{I})\\boldsymbol{r}^{k-1}$。代入我们之前的结果：\n       $$\n       \\alpha_k \\approx - \\frac{(\\boldsymbol{r}^k)^T \\left( \\frac{\\boldsymbol{r}^k - \\boldsymbol{r}^{k-1}}{\\alpha_{k-1}} \\right)}{\\left\\| \\frac{\\boldsymbol{r}^k - \\boldsymbol{r}^{k-1}}{\\alpha_{k-1}} \\right\\|_2^2} = - \\alpha_{k-1} \\frac{(\\boldsymbol{r}^k)^T (\\boldsymbol{r}^k - \\boldsymbol{r}^{k-1})}{\\|\\boldsymbol{r}^k - \\boldsymbol{r}^{k-1}\\|_2^2}\n       $$\n       这就是用于 Aitken 更新的公式。如果分母 $\\|\\boldsymbol{r}^k - \\boldsymbol{r}^{k-1}\\|_2^2$ 接近于零，表明存在线性相关或停滞，则保留前一个值 $\\alpha_{k-1}$ 以避免数值不稳定性。\n       \n    c. **限幅安全保护**：计算出的 $\\alpha_k$ 被限制在指定的区间 $[\\alpha_{\\min}, \\alpha_{\\max}]$ 内，以确保其在欠松弛的稳定且物理上有意义的范围内：\n       $$\n       \\alpha_k := \\max(\\alpha_{\\min}, \\min(\\alpha_{\\max}, \\alpha_k))\n       $$\n\n5.  循环使用新的状态 $\\boldsymbol{s}^k$ 和松弛因子 $\\alpha_k$ 继续。如果在达到 $N_{\\max}$ 次迭代后仍未收敛，则认为方法失败，并返回值 -1。\n\n这个完整的算法被应用于所提供的五个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(K, b, alpha_0, alpha_min, alpha_max, eta, n_max, epsilon, n):\n    \"\"\"\n    Applies the safeguarded Aitken-based under-relaxation scheme for a single test case.\n    \"\"\"\n    # Initial state and residual (k=0)\n    s = np.zeros(n, dtype=float)\n    r = K @ s + b - s  # r^0 = b\n    \n    norm_r = np.linalg.norm(r)\n    if norm_r = epsilon:\n        return 0\n\n    # Initialize relaxation factor for the first step\n    alpha = alpha_0\n\n    for k in range(1, n_max + 1):\n        # Store previous iteration's values\n        r_prev = r\n        norm_r_prev = np.linalg.norm(r_prev)\n        alpha_prev = alpha\n\n        # Update state (s^k = s^{k-1} + alpha_{k-1} * r^{k-1})\n        s = s + alpha_prev * r_prev\n\n        # Compute new residual (r^k = G(s^k) - s^k)\n        r = K @ s + b - s\n        norm_r = np.linalg.norm(r)\n\n        # Check for convergence\n        if norm_r = epsilon:\n            return k\n\n        # Compute relaxation factor for the next step (alpha_k)\n        \n        # Safeguard 1: Restart on residual growth\n        if norm_r > eta * norm_r_prev:\n            alpha = alpha_0\n        else:\n            # Aitken-based update\n            dr = r - r_prev\n            norm_dr_sq = np.dot(dr, dr)\n\n            # Avoid division by a very small number\n            if norm_dr_sq  1e-24:\n                alpha = alpha_prev\n            else:\n                alpha = -alpha_prev * np.dot(r, dr) / norm_dr_sq\n        \n        # Safeguard 2: Clamp the alpha value\n        alpha = max(alpha_min, min(alpha_max, alpha))\n        \n    return -1 # Not converged\n\ndef solve():\n    \"\"\"\n    Sets up and runs all test cases, then prints the results.\n    \"\"\"\n    # Common parameters\n    N_MAX = 1000\n    EPSILON = 1e-8\n    N_DIMS = 3\n\n    # Test Case 1\n    K1 = np.array([[0.0, -0.9, 0.0], [0.8, 0.0, 0.0], [0.0, 0.2, 0.95]])\n    b1 = np.array([1.0, -1.5, 0.5])\n    tc1 = (K1, b1, 0.5, 0.05, 0.95, 1.2)\n\n    # Test Case 2\n    tc2 = (K1, b1, 0.2, 0.2, 0.2, 2.0)\n    \n    # Test Case 3\n    tc3 = (K1, b1, 0.5, 0.05, 0.95, 1.01)\n\n    # Test Case 4\n    K4 = np.array([[-0.99, 0.0, 0.0], [0.0, -0.9, 0.05], [0.0, 0.1, -0.95]])\n    b4 = np.array([0.3, 1.0, -0.7])\n    tc4 = (K4, b4, 0.9, 0.01, 0.7, 1.5)\n\n    # Test Case 5\n    b5 = np.array([0.0, 0.0, 0.0])\n    tc5 = (K1, b5, 0.5, 0.05, 0.95, 1.2)\n    \n    test_cases = [tc1, tc2, tc3, tc4, tc5]\n    \n    results = []\n    for K, b, alpha_0, alpha_min, alpha_max, eta in test_cases:\n        iters = run_case(K, b, alpha_0, alpha_min, alpha_max, eta, N_MAX, EPSILON, N_DIMS)\n        results.append(iters)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3386125"}]}