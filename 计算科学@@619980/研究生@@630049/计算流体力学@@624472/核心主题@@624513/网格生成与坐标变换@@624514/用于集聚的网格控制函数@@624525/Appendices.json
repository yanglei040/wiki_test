{"hands_on_practices": [{"introduction": "网格自适应的基础是等分布原理。第一个练习 [@problem_id:3325995] 提供了一个直接的、动手的编程体验，将这一数学原理转化为一个有效的一维网格生成器。通过分步实现算法——从监测函数 $m(x)$ 的数值积分到累积分布函数的反演——您将具体理解监测函数如何决定节点的布局，并学会量化网格质量。", "problem": "考虑一个闭区间上的一维网格生成问题，其目标是根据等分布原则在感兴趣的区域放置节点，以实现受控的加密。其基本原理如下。对于一个有界区间 $[a,b]$ 和一个严格为正的监控函数 $m(x)$，等分布原则指定了一个网格映射 $x(s)$，该映射从计算坐标 $s \\in [0,1]$ 映至物理坐标 $x \\in [a,b]$，使得由 $m(x)$ 导出的测度在所有网格单元中均匀分布。在连续形式下，此要求可表述为单元密度由 $m(x)$ 控制，并且每个单元分配到相等份额的总监控测度。在离散形式下，此原则规定每个单元的离散监控函数加权测度在所有单元上应该相等。\n\n您必须实现一个离散等分布算法，该算法为给定的严格为正的监控函数 $m(x)$ 在区间 $[a,b]$ 上构建节点位置 $\\{x_i\\}_{i=0}^N$，使得每个单元的监控函数加权测度的离散近似值在所有单元上近似相等。该算法必须依赖于第一性原理：通过一个由 $m(x)$ 构建的非负递增函数来近似 $[a,b]$ 上的累积监控测度，然后对此累积函数在均匀分布的水平上求逆，以获得节点位置 $\\{x_i\\}_{i=0}^N$。推理过程必须从等分布的核心定义出发，并避免使用捷径。\n\n离散等分布必须按如下方式实现：\n- 在 $[a,b]$ 上构建一个精细的参考网格 $\\{x^{\\mathrm{ref}}_j\\}_{j=0}^{J}$，其中 $x^{\\mathrm{ref}}_0=a$ 且 $x^{\\mathrm{ref}}_{J}=b$，并使用在参考网格上对 $m(x)$ 进行的一致性数值积分来近似累积监控测度 $C(x)$。该近似必须产生一个非递减数组 $\\{C_j\\}_{j=0}^{J}$，其中 $C_0=0$ 且 $C_J \\approx \\int_a^b m(\\xi)\\,d\\xi$。\n- 计算目标水平 $\\{T_i\\}_{i=0}^{N}$，其中 $T_i = \\frac{i}{N} C_J$。\n- 通过对离散累积映射求逆来获得节点位置 $\\{x_i\\}_{i=0}^N$，即通过使用从 $\\{ (C_j, x^{\\mathrm{ref}}_j) \\}$ 进行的稳定单调插值来找到满足 $C(x_i) \\approx T_i$ 的 $x_i$。\n\n构建 $\\{x_i\\}$ 后，使用以下两个量化指标评估等分布和聚类的质量：\n- 网格尺寸比 $R = \\frac{\\max_i \\Delta x_i}{\\min_i \\Delta x_i}$，其中 $\\Delta x_i = x_{i+1}-x_i$，$i=0,\\dots,N-1$。\n- 离散等分布残差，定义为 $E_\\infty = \\max_{i} \\left| \\frac{w_i - W_{\\mathrm{eq}}}{W_{\\mathrm{eq}}} \\right|$，其中 $w_i$ 是单元 $[x_i,x_{i+1}]$ 上监控函数加权测度的梯形近似，即 $w_i \\approx \\frac{1}{2}\\left(m(x_i)+m(x_{i+1})\\right)\\Delta x_i$，而 $W_{\\mathrm{eq}} = \\frac{1}{N} \\int_a^b m(\\xi)\\,d\\xi$。\n\n使用以下监控函数和参数的测试套件构建4个网格，并报告上述指标：\n- 测试用例1（单位区间上的高斯聚类）：$[a,b]=[0,1]$，$N=40$，$m(x) = 1 + A \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)$，其中 $A=9$，$x_0=0.5$，$\\sigma=0.08$。\n- 测试用例2（分段常数凸起）：$[a,b]=[0,1]$，$N=40$，$m(x) = 1 + A$ 若 $x \\in [x_1,x_2]$ 否则 $m(x)=1$，其中 $A=4$，$x_1=0.45$，$x_2=0.55$。\n- 测试用例3（左边界附近的边界层型聚类）：$[a,b]=[0,1]$，$N=60$，$m(x) = 1 + \\frac{A}{(x+\\varepsilon)^p}$，其中 $A=0.2$，$\\varepsilon=10^{-3}$，$p=0.5$。\n- 测试用例4（保证正值的振荡监控函数）：$[a,b]=[0,1]$，$N=50$，$m(x) = \\varepsilon + \\sin^2(2\\pi x)$，其中 $\\varepsilon=0.1$。\n\n本问题中的所有量都是无量纲的，因此不需要物理单位。\n\n您的程序必须为每个测试用例计算上面定义的数对 $[R, E_\\infty]$。最终的程序输出必须是一行，其中包含4个测试用例的结果，这些结果聚合在一个无空格的、逗号分隔的列表之列表中，格式为 $[[R_1,E_{\\infty,1}],[R_2,E_{\\infty,2}],[R_3,E_{\\infty,3}],[R_4,E_{\\infty,4}]]$，其中 $R_k$ 和 $E_{\\infty,k}$ 是测试用例 $k$ 的值。\n\n覆盖性设计：\n- 高斯用例测试平滑聚类。\n- 分段常数凸起用例测试不连续性处理。\n- 边界层用例测试在具有可积奇性的域端点附近的强聚类。\n- 振荡监控函数用例测试在基函数可能接近零的区域内保持正值的能力。\n\n您的解决方案应从等分布原则和上述核心定义推导得出，必须是自包含的，并且必须以确切要求的格式产生输出。", "solution": "根据指定密度对节点进行聚类的一维网格生成问题，是自适应数值方法的基石。等分布原则为此任务提供了严谨的数学基础。本文提出的解决方案遵循指定的离散算法，该算法是此原则的直接数值实现。\n\n等分布原则指出，对于物理域 $[a,b]$ 上的一个给定严格为正的监控函数 $m(x)$，最优的节点分布 $\\{x_i\\}_{i=0}^N$ 是指监控函数在每个网格单元 $[x_i, x_{i+1}]$ 上的积分是常数。在数学上，这表示为：\n$$ \\int_{x_i}^{x_{i+1}} m(\\xi) \\,d\\xi = \\text{constant} \\quad \\text{for } i = 0, 1, \\dots, N-1 $$\n该常数值必须是“监控质量”总量除以单元数量 $N$。总质量是监控函数在整个域上的积分 $\\int_a^b m(\\xi) \\,d\\xi$。因此，对于每个单元，我们有：\n$$ \\int_{x_i}^{x_{i+1}} m(\\xi) \\,d\\xi = \\frac{1}{N} \\int_a^b m(\\xi) \\,d\\xi $$\n为了找到特定节点 $x_i$ 的位置，我们可以对截至该节点的所有单元的贡献求和：\n$$ \\sum_{k=0}^{i-1} \\int_{x_k}^{x_{k+1}} m(\\xi) \\,d\\xi = \\sum_{k=0}^{i-1} \\frac{1}{N} \\int_a^b m(\\xi) \\,d\\xi $$\n$$ \\int_a^{x_i} m(\\xi) \\,d\\xi = \\frac{i}{N} \\int_a^b m(\\xi) \\,d\\xi $$\n这个方程是该方法的核心。我们将累积监控函数 $C(x)$ 定义为 $m(\\xi)$ 从域的起点到点 $x$ 的积分：\n$$ C(x) = \\int_a^x m(\\xi) \\,d\\xi $$\n根据这个定义，节点 $x_i$ 的等分布条件变为：\n$$ C(x_i) = \\frac{i}{N} C(b) $$\n由于 $m(x)$ 是严格为正的，$C(x)$ 是一个严格递增的函数，因此拥有唯一的逆函数 $C^{-1}$。每个节点 $x_i$ 的位置可以通过对累积函数求逆来找到：\n$$ x_i = C^{-1}\\left(\\frac{i}{N} C(b)\\right) $$\n这个方程表明，物理空间 $[a,b]$ 中的节点 $\\{x_i\\}$ 是“监控函数加权”空间或计算空间 $[0, C(b)]$ 中一组均匀间隔点的像。\n\n所指定的算法是此求逆过程的一个离散实现。它包括以下步骤：\n\n1.  **累积监控函数的近似**：连续函数 $C(x)$ 通常没有解析表达式。我们对其进行数值近似。首先，在区间 $[a,b]$ 上创建一个精细、均匀的参考网格 $\\{x^{\\mathrm{ref}}_j\\}_{j=0}^{J}$，其中 $x^{\\mathrm{ref}}_j = a + j(b-a)/J$。在这些点上计算监控函数 $m(x)$ 的值，得到 $\\{m_j = m(x^{\\mathrm{ref}}_j)\\}$。然后使用数值积分法则来近似累积积分 $C(x)$。我们使用梯形法则，它产生一个离散的累积函数数组 $\\{C_j\\}_{j=0}^{J}$，其中 $C_j \\approx C(x^{\\mathrm{ref}}_j)$。其计算方式为 $C_0=0$，且对于 $j  0$：\n    $$ C_j = \\sum_{k=1}^{j} \\frac{1}{2} (m_{k-1} + m_k) (x^{\\mathrm{ref}}_k - x^{\\mathrm{ref}}_{k-1}) $$\n    最终值 $C_J$ 作为总积分 $\\int_a^b m(\\xi)\\,d\\xi$ 的数值近似。由于 $m(x)  0$，这个离散函数 $\\{C_j\\}$ 保证是非递减的。\n\n2.  **目标水平的计算**：根据原理 $C(x_i) = \\frac{i}{N} C(b)$，我们在近似累积函数的值域 $[0, C_J]$ 内定义一组 $N+1$ 个均匀间隔的目标水平 $\\{T_i\\}_{i=0}^N$：\n    $$ T_i = \\frac{i}{N} C_J \\quad \\text{for } i = 0, 1, \\dots, N $$\n\n3.  **通过插值求逆**：最后一步是找到与这些目标水平相对应的物理节点位置 $\\{x_i\\}$。这是对我们所构建的离散映射（由数对 $\\{(C_j, x^{\\mathrm{ref}}_j)\\}$ 定义）的求逆。我们寻找满足 $C(x_i) \\approx T_i$ 的 $x_i$。这可以通过稳定的单调插值来实现。线性插值是一个合适的选择。对于每个目标水平 $T_i$，我们在数组 $\\{C_j\\}$ 中找到它的位置，并对 $\\{x^{\\mathrm{ref}}_j\\}$ 中的相应值进行线性插值，以找到 $x_i$ 的估计值。这个过程有效地近似了逆函数 $C^{-1}$。\n\n生成网格 $\\{x_i\\}_{i=0}^N$ 后，使用两个指标来评估其质量：\n\n-   **网格尺寸比 ($R$)**：该指标量化了网格拉伸或聚类的程度。它定义为最大单元尺寸与最小单元尺寸之比：\n    $$ R = \\frac{\\max_{i} \\Delta x_i}{\\min_{i} \\Delta x_i}, \\quad \\text{where } \\Delta x_i = x_{i+1} - x_i $$\n    $R=1$ 对应于均匀网格，而较大的 $R$ 值表示强烈的聚类。\n\n-   **离散等分布残差 ($E_\\infty$)**：该指标衡量生成的网格满足等分布原则离散版本的程度。它是任意单元中监控函数加权测度与理想均匀测度之间的最大相对偏差：\n    $$ E_\\infty = \\max_{i} \\left| \\frac{w_i - W_{\\mathrm{eq}}}{W_{\\mathrm{eq}}} \\right| $$\n    其中，$w_i$ 是 $m(x)$ 在单元 $[x_i, x_{i+1}]$ 上积分的梯形近似：\n    $$ w_i = \\frac{1}{2} (m(x_i) + m(x_{i+1})) \\Delta x_i $$\n    而 $W_{\\mathrm{eq}}$ 是每个单元的理想常数测度，使用数值计算的总监控积分 $C_J$ 定义：\n    $$ W_{\\mathrm{eq}} = \\frac{C_J}{N} $$\n    $E_\\infty$ 的值很小表明算法成功生成了一个非常接近完美等分布的网格。\n\n提供的Python代码实现了此算法，并为四个指定的测试用例计算了这些指标，每个用例都旨在测试算法对不同类型监控函数（平滑、不连续、奇异和振荡）的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates 1D meshes based on the equidistribution principle for a suite of test cases\n    and evaluates them using specified quality metrics.\n    \"\"\"\n\n    def generate_and_evaluate(a, b, N, m_func, J_ref=20000):\n        \"\"\"\n        Core function to generate a mesh and compute metrics for a single test case.\n\n        Args:\n            a (float): Start of the interval.\n            b (float): End of the interval.\n            N (int): Number of mesh cells.\n            m_func (callable): The monitor function m(x).\n            J_ref (int): Number of intervals in the fine reference grid.\n\n        Returns:\n            tuple: A tuple containing the mesh size ratio (R) and the\n                   equidistribution residual (E_inf).\n        \"\"\"\n        # Step 1: Approximate the cumulative monitor function\n        # Create a fine reference grid\n        x_ref = np.linspace(a, b, J_ref + 1)\n        # Evaluate the monitor function on the reference grid\n        m_ref = m_func(x_ref)\n\n        # Compute the discrete cumulative integral using the trapezoidal rule\n        dx_ref = (b - a) / J_ref\n        integrals = 0.5 * (m_ref[:-1] + m_ref[1:]) * dx_ref\n        C_ref = np.concatenate(([0.0], np.cumsum(integrals)))\n        C_total = C_ref[-1]\n\n        # Step 2: Compute target equidistribution levels\n        T_i = np.linspace(0.0, C_total, N + 1)\n\n        # Step 3: Invert the mapping via linear interpolation to find node positions\n        x_nodes = np.interp(T_i, C_ref, x_ref)\n\n        # Ensure boundary nodes are exact\n        x_nodes[0] = a\n        x_nodes[-1] = b\n\n        # --- Metric Calculation ---\n\n        # Calculate cell sizes\n        delta_x = x_nodes[1:] - x_nodes[:-1]\n\n        # Metric 1: Mesh size ratio R\n        min_delta_x = np.min(delta_x)\n        if min_delta_x == 0:\n            # This should not occur with a strictly positive monitor function\n            R = np.inf\n        else:\n            R = np.max(delta_x) / min_delta_x\n\n        # Metric 2: Discrete equidistribution residual E_inf\n        m_at_nodes = m_func(x_nodes)\n        # Calculate the monitor-weighted measure for each cell\n        w_i = 0.5 * (m_at_nodes[:-1] + m_at_nodes[1:]) * delta_x\n        # Calculate the ideal, constant measure per cell\n        W_eq = C_total / N\n        \n        # Calculate the maximum relative deviation\n        if W_eq == 0:\n            E_inf = np.inf\n        else:\n            E_inf = np.max(np.abs(w_i / W_eq - 1.0))\n\n        return R, E_inf\n\n    # Define the test suite of monitor functions and parameters\n    test_cases = [\n        {\n            \"a\": 0.0, \"b\": 1.0, \"N\": 40,\n            \"m_func\": lambda x: 1.0 + 9.0 * np.exp(-((x - 0.5)**2) / (2 * 0.08**2))\n        },\n        {\n            \"a\": 0.0, \"b\": 1.0, \"N\": 40,\n            \"m_func\": lambda x: 1.0 + 4.0 * np.logical_and(x >= 0.45, x = 0.55)\n        },\n        {\n            \"a\": 0.0, \"b\": 1.0, \"N\": 60,\n            \"m_func\": lambda x: 1.0 + 0.2 / ((x + 1e-3)**0.5)\n        },\n        {\n            \"a\": 0.0, \"b\": 1.0, \"N\": 50,\n            \"m_func\": lambda x: 0.1 + np.sin(2 * np.pi * x)**2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        R, E_inf = generate_and_evaluate(case[\"a\"], case[\"b\"], case[\"N\"], case[\"m_func\"])\n        results.append(f\"[{R},{E_inf}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3325995"}, {"introduction": "掌握了核心算法后，下一个问题是用什么作为监测函数。这个练习 [@problem_id:3325924] 将重点从实现转向设计，解决不可压缩流模拟中的一个实际问题。您将探索如何从原始的物理诊断量——压力泊松方程的残差 $R_p$——构建一个鲁棒的监测函数 $M(\\mathbf{x})$ 以加速求解器收敛，并学习到诸如归一化和平滑等实际步骤的重要性。", "problem": "对于雷诺数$Re=10^4$的二维顶盖驱动方腔流动，一种不可压缩投影法通过求解压力泊松偏微分方程（PDE）来推进速度场。在密度$\\rho$为常数的情况下，设压力泊松残差逐点定义为 $R_p(\\mathbf{x})=\\Delta p(\\mathbf{x}) - \\nabla\\cdot\\left(\\rho\\,\\mathbf{u}(\\mathbf{x})\\cdot\\nabla \\mathbf{u}(\\mathbf{x})\\right)$，该残差使用当前的离散解和离散算子进行评估。考虑计算流体力学（CFD）中的一个网格自适应框架，其中一个正的网格控制（监控）函数$M(\\mathbf{x})$通过椭圆等分布原理驱动节点聚类，使得沿计算坐标，$M$的积分近似均匀。你的任务是根据$R_p$构造$M$，以针对那些对投影法中压力求解的精度和收敛性影响最大的区域，并评估对于雷诺数$Re=10^4$的顶盖驱动方腔流，在控制体数量固定的情况下，向$|R_p|$大的区域进行节点聚类是否会加速收敛到无散度状态的整个过程。\n\n你的推理应基于控制不可压缩Navier-Stokes方程、投影法的结构、压力椭圆求解的性质，以及聚类应遵循局部截断误差或残差强度的替代指标这一等分布原理。如果有理由为了保持鲁棒性和适定的等分布，你可以采用对$R_p$进行平滑和归一化的方法。假设网格生成器强制$M(\\mathbf{x}) \\ge c  0$，并且过度的各向异性会恶化椭圆求解器的条件数。\n\n与具有相同数量控制体的均匀网格相比，以下哪种$M(\\mathbf{x})$的构造及其相关的收敛性论断最符合这些原则，并有望加速雷诺数$Re=10^4$下顶盖驱动方腔流动的投影法的收敛？\n\nA. 定义 $M(\\mathbf{x}) = 1 + \\alpha\\,\\widetilde{R}(\\mathbf{x})$，其中 $\\widetilde{R}(\\mathbf{x}) = S_\\ell\\!\\left(\\dfrac{|R_p(\\mathbf{x})|}{\\langle |R_p|\\rangle_\\Omega + \\varepsilon}\\right)$，$S_\\ell$是一个宽度$\\ell$与局部单元尺寸相当的局部平滑算子，$\\langle\\cdot\\rangle_\\Omega$是域平均，$\\varepsilon0$是一个保证正性的小边界，$\\alpha0$是用户设定的聚类强度。对$M$进行等分布会将节点集中在$|R_p|$较大的区域（剪切层和角点附近），从而减少压力泊松PDE的局部截断误差，进而减少达到无散度容差所需的投影迭代次数；净效应：在自由度固定的情况下，总体收敛速度更快。\n\nB. 定义 $M(\\mathbf{x}) = \\left(1 + \\alpha\\,\\dfrac{|R_p(\\mathbf{x})|}{\\max_\\Omega |R_p| + \\varepsilon}\\right)^{-1}$，以便在$|R_p|$大的地方粗化单元，在$|R_p|$小的地方细化单元。这种做法反转了残差加权，以减轻强特征附近的刚度；净效应：压力求解器收敛更快，因为算子变得更具对角占优性。\n\nC. 定义 $M(\\mathbf{x}) = 1 + \\alpha\\,|\\nabla\\cdot \\mathbf{u}(\\mathbf{x})|$，使节点直接跟随违反不可压缩性的区域；由于投影法在几步之内就能强制$\\nabla\\cdot \\mathbf{u}\\approx 0$，自适应会停止移动，避免了不必要的聚类；净效应：收敛更快，因为网格保持近乎均匀且条件良好。\n\nD. 定义 $M(\\mathbf{x}) = 1 + \\alpha\\,\\dfrac{|\\nabla R_p(\\mathbf{x})|}{\\langle |\\nabla R_p|\\rangle_\\Omega}$，不进行任何平滑，允许在残差前沿进行非常尖锐的聚类；这种激进的自适应使单元与残差梯度对齐，而离散误差正源于此；净效应：收敛更快，因为尖锐的聚类总能提高压力泊松PDE的椭圆求解器速率。\n\n选择最准确地反映了由$R_p$构造$M$的方法及其对收敛性预期影响的选项，并由所述原则证明其合理性。这里$\\alpha0$，$\\ell0$ 和 $\\varepsilon0$ 是用户选择的常数，所有其他符号在不可压缩流数值计算中具有其标准含义。假设偏微分方程（PDE）的离散在光滑区域至少是二阶的，并且投影法采用一个标准的多重网格预条件的Krylov求解器，其收敛性对截断误差分布和算子条件数都很敏感。", "solution": "从速度为$\\mathbf{u}$、压力为$p$、密度$\\rho$恒定、运动粘度为$\\nu$的不可压缩Navier-Stokes方程开始，\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u}\\cdot \\nabla \\mathbf{u} = -\\frac{1}{\\rho}\\nabla p + \\nu \\Delta \\mathbf{u}, \\quad \\nabla \\cdot \\mathbf{u} = 0.\n$$\n在投影法中，首先计算不含压力的中间速度$\\mathbf{u}^\\star$，然后通过求解压力泊松PDE得到压力修正项，使得更新后的速度$\\mathbf{u}^{n+1}$满足$\\nabla\\cdot \\mathbf{u}^{n+1}=0$。对于常数$\\rho$，压力求解的形式为\n$$\n\\Delta p = \\mathcal{F}(\\mathbf{u}),\n$$\n其右端项$\\mathcal{F}(\\mathbf{u})$对于时间精确投影法源自$\\nabla\\cdot \\mathbf{u}^\\star$，或者对于稳态公式，在考虑粘性项后源自$-\\rho\\,\\nabla\\cdot(\\mathbf{u}\\cdot\\nabla \\mathbf{u})$。逐点残差\n$$\nR_p(\\mathbf{x}) = \\Delta p(\\mathbf{x}) - \\nabla\\cdot\\left(\\rho\\,\\mathbf{u}(\\mathbf{x})\\cdot\\nabla \\mathbf{u}(\\mathbf{x})\\right)\n$$\n因此是稳态（或准稳态）压力泊松PDE中不平衡性的自然度量。在实践中，$R_p$是用离散算子计算的，因此其大小反映了局部截断误差以及对雷诺数$Re=10^4$下顶盖驱动方腔流中的剪切层和角点奇点等尖锐特征的分辨率不足。\n\n在椭圆等分布框架中，网格控制（监控）函数$M(\\mathbf{x})$的设计使得其沿计算坐标的累积积分为均匀。等分布的启发式方法是选择$M$与一个和局部误差密度相关的标量场成正比；然后，在$M$大的地方进行聚类可以减少局部离散误差，对于椭圆PDE，这可以改善残差的均匀性，并通常通过缓解局部刚度来加速求解器的收敛。然而，必须管理两个相互制衡的效应：为避免网格缠结，$M$需具有正性和光滑性；为避免由异常值驱动的病态集中，需进行归一化。在与局部网格尺度相当的长度$\\ell$上进行平滑是抑制$M$中高频振荡的标准做法，否则会引起近奇异网格。通过域平均值或最大值进行归一化，可以使聚类强度参数$\\alpha$具有可解释性并保持有界。\n\n我们现在根据这些原则分析每个选项。\n\n选项A构造了\n$$\nM(\\mathbf{x}) = 1 + \\alpha\\,\\widetilde{R}(\\mathbf{x}), \\quad \\widetilde{R}(\\mathbf{x}) = S_\\ell\\!\\left(\\frac{|R_p(\\mathbf{x})|}{\\langle |R_p|\\rangle_\\Omega + \\varepsilon}\\right),\n$$\n其中$S_\\ell$是一个平滑算子（例如，与一个宽度为$\\ell$的紧支核进行卷积，或求解一个屏蔽泊松滤波器），并通过域平均进行归一化。这满足了正性、有界性和光滑性。因为在顶盖下方的薄剪切层和压力曲率必须平衡对流加速度的角点附近，$|R_p|$很大，所以对$M$进行等分布会将节点聚类在压力泊松PDE强迫项最强的区域。对于二阶离散格式，椭圆求解的局部截断误差在光滑区域的尺度为$O(h^2 \\, |D^4 p|)$，而在$p$或右端项变化迅速的区域，较小的$h$会同时减少离散误差和迭代求解期间观察到的代数残差的幅值。在投影法中，压力求解是控制$\\nabla\\cdot \\mathbf{u}$向容差衰减速度的主导椭圆步骤；在泊松残差最强的区域减少局部误差，可以减少达到给定散度容差所需的压力迭代次数，并可以减少达到稳态所需的外时间步或子迭代次数。只要选择的$\\alpha$和$\\ell$能够避免极端各向异性，算子的条件数就不会被过度恶化。因此，在自由度固定的情况下，使用平滑、归一化的监控函数向$|R_p|$大的区域进行聚类，有望加速总体收敛。选项A与原则和预期效果一致；它是正确的。\n\n选项B设置了\n$$\nM(\\mathbf{x}) = \\left(1 + \\alpha\\,\\frac{|R_p(\\mathbf{x})|}{\\max_\\Omega |R_p| + \\varepsilon}\\right)^{-1},\n$$\n这会明确地在$|R_p|$大的地方粗化网格，在$|R_p|$小的地方细化网格。这与等分布原理相矛盾：它降低了椭圆PDE强迫项和压力曲率最大区域的优先级，使得大的截断误差和残差局部化。虽然有人可能会争辩说，在强特征附近进行粗化可以减少离散拉普拉斯算子的刚度（通过避免小单元），但净效应是在恰好控制全局无散度约束的区域增加了离散误差。在投影法中，强剪切层附近的压力场分辨率不足会导致$\\nabla\\cdot \\mathbf{u}$的衰减变慢，以及每次迭代需要更大的压力修正。因此，关于收敛更快的说法是没有根据的。选项B是错误的。\n\n选项C提出了\n$$\nM(\\mathbf{x}) = 1 + \\alpha\\,|\\nabla\\cdot \\mathbf{u}(\\mathbf{x})|.\n$$\n虽然$\\nabla\\cdot \\mathbf{u}$衡量了对不可压缩性的违反程度，但在正确实现的投影法中，这个标量在每个时间步的第一次压力修正后会迅速减小，通常相对于离散算子达到接近机器精度的水平。因此，$|\\nabla\\cdot \\mathbf{u}|$并不是一个好的稳态指标来指示何处需要压力分辨率；它很快在几乎所有地方都变得接近于零，监控函数也回归到近似常数，从而违背了目标聚类的目的。此外，将网格移动集中在$\\nabla\\cdot \\mathbf{u}$上忽略了$R_p$中编码的压力曲率和对流加速度之间的椭圆平衡，即使当$\\nabla\\cdot \\mathbf{u}=0$时，这种平衡依然存在。这种设计通常不会相对于均匀网格加速收敛；它要么不起作用（监控函数近乎均匀），要么追踪瞬态而不是结构性的压力特征。选项C是错误的。\n\n选项D使用了\n$$\nM(\\mathbf{x}) = 1 + \\alpha\\,\\frac{|\\nabla R_p(\\mathbf{x})|}{\\langle |\\nabla R_p|\\rangle_\\Omega},\n$$\n且没有任何平滑。对$|\\nabla R_p|$的敏感性检测的是残差的前沿而不是其大小。原则上，残差梯度可以突显内部层，但没有平滑或限制，这个监控函数是高度振荡的，并可能引起过度、快速变化的聚类。这往往会产生近奇异的网格，损害离散拉普拉斯算子的条件数（特别是在拉伸、扭曲的单元中），并可能因为引入与网格线不对齐的强系数各向异性而降低多重网格的效率。那种认为这种激进的聚类“总是能提高”椭圆求解器速率的一概而论的说法是错误的；在许多椭圆求解器中，过于尖锐的网格分级会增加条件数并减慢Krylov收敛速度，除非经过仔细的预处理和对齐。在没有平滑和归一化保障措施的情况下，这种构造不具鲁棒性，也不能可靠地加速收敛。选项D是错误的。\n\n因此，既能从$R_p$构造出科学合理的监控函数，又能正确预测在$Re=10^4$下顶盖驱动方腔流上投影法收敛加速的选项是A。", "answer": "$$\\boxed{A}$$", "id": "3325924"}, {"introduction": "许多流动特征，如界面和边界层，本质上是各向异性的。最后一个练习 [@problem_id:3325976] 从各向同性聚类转向各向异性度量张量 $M$ 的设计。您将推导并应用一种基于界面曲率 $\\kappa$ 来对齐和拉伸网格单元的控制策略，然后通过计算数值耗散的减少量来量化这种方法的直接好处。", "problem": "考虑一个计算流体动力学 (CFD) 中的二维界面平流问题。一个清晰的材料界面嵌入在速度大小为 $U$、方向角为 $\\phi$ (以弧度为单位) 的均匀流场中。界面上某点的曲率为 $\\kappa$ (单位为 $\\text{m}^{-1}$)，切线方向角为 $\\theta$ (以弧度为单位)。局部网格由一个对称正定度量张量 $M$ 控制，该张量旨在施加一个与主曲率方向（即界面的切线和法线方向）对齐的单元纵横比 $AR$。该度量定义为 $M = \\mathbf{R}^\\top \\,\\text{diag}(m_\\parallel,m_\\perp)\\,\\mathbf{R}$，其中 $\\mathbf{R}$ 是将全局基底映射到切向-法向基底的正交旋转矩阵，$m_\\parallel$ 控制切向尺寸，$m_\\perp$ 控制法向尺寸。比例约束为 $m_\\perp / m_\\parallel = \\chi |\\kappa|$，其中 $\\chi$ 是用户指定的聚类敏感度，单位为 $\\text{m}$。\n\n假设网格控制约定为 $m_\\parallel = 1/h_0^2$，其中 $h_0$ 是目标各向同性间距 (单位为 $\\text{m}$)。$M$ 所蕴含的方向间距为 $h_\\parallel = h_0$ 和 $h_\\perp = h_0 / \\sqrt{m_\\perp / m_\\parallel} = h_0 / \\sqrt{\\chi |\\kappa|}$。通过定义 $AR = h_\\parallel / h_\\perp = \\sqrt{\\chi |\\kappa|}$ 并应用 $AR \\leftarrow \\min(AR_{\\max},\\max(AR,1))$ 来强制施加有界纵横比，以满足对于给定的 $AR_{\\max}$ (无量纲) 有 $AR \\ge 1$ 和 $AR \\le AR_{\\max}$。\n\n被动标量的线性平流输运采用一阶迎风有限体积法进行离散化，时间步长 $\\Delta t$ 是均匀的，其选择使得库朗数 $\\nu = U \\Delta t / h_0$ 在整个网格上为常数。一维空间中一阶迎风格式的修正方程分析得出一个带有有效扩散系数 $D_{\\text{num}} = \\tfrac{1}{2} |a| \\Delta x (1 - \\nu)$ 的人工扩散项，其中 $a$ 是平流速度，$\\Delta x$ 是网格间距。在二维情况下，沿方向 $\\mathbf{\\hat{d}}$ 的扩散为 $D_{\\text{num}}(\\mathbf{\\hat{d}}) = \\tfrac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{d}}| h_{\\mathbf{\\hat{d}}} (1 - \\nu)$，其中 $\\mathbf{u}$ 是速度矢量，$h_{\\mathbf{\\hat{d}}}$ 是沿 $\\mathbf{\\hat{d}}$ 方向的间距。关注于界面的法线方向 $\\mathbf{\\hat{n}}$，各向同性网格使用 $h_\\perp^{\\text{iso}} = h_0$，而各向异性网格使用 $h_\\perp^{\\text{aniso}} = h_0 / AR$。数值扩散削减因子定义为比值 $R = D_{\\text{num}}^{\\text{iso}}(\\mathbf{\\hat{n}}) / D_{\\text{num}}^{\\text{aniso}}(\\mathbf{\\hat{n}})$。如果 $|\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| = 0$ 或 $\\nu = 1$，则定义 $R = 0$，因为没有数值扩散可以削减。\n\n任务：\n- 从一阶迎风平流的修正方程和给定约束 $m_\\perp / m_\\parallel = \\chi |\\kappa|$ 的度量张量 $M$ 的定义出发，推导 $R$ 关于 $AR$、$\\nu$ 和 $\\mathbf{u}$ 的法向分量的表达式。\n- 实现一个程序，该程序：\n  1. 从 $\\theta$ 构建旋转矩阵 $\\mathbf{R}$，其列向量由切向单位向量 $\\mathbf{\\hat{t}} = [\\cos\\theta, \\sin\\theta]^\\top$ 和法向单位向量 $\\mathbf{\\hat{n}} = [-\\sin\\theta, \\cos\\theta]^\\top$ 给出。\n  2. 在施加纵横比边界后，根据 $\\mathbf{R}$、$m_\\parallel = 1/h_0^2$ 和 $m_\\perp = m_\\parallel \\, AR^2$ 构建 $M$。\n  3. 使用法向分量 $u_n = \\mathbf{u}\\cdot\\mathbf{\\hat{n}}$、库朗数 $\\nu$ 和方向间距计算 $R$。\n- 使用以下参数集测试套件，每组参数按 $(U, h_0, \\nu, \\kappa, \\chi, \\theta, \\phi, AR_{\\max})$ 顺序排列，并以指定单位表示：$U$ 单位为 $\\text{m/s}$，$h_0$ 单位为 $\\text{m}$，$\\nu$ 无量纲，$\\kappa$ 单位为 $\\text{m}^{-1}$，$\\chi$ 单位为 $\\text{m}$，$\\theta$ 和 $\\phi$ 单位为弧度，$AR_{\\max}$ 无量纲。\n  1. $(U = 1.0, h_0 = 0.01, \\nu = 0.5, \\kappa = 5.0, \\chi = 0.5, \\theta = 0.5235987756, \\phi = 1.0471975512, AR_{\\max} = 6.0)$\n  2. $(U = 1.0, h_0 = 0.01, \\nu = 0.5, \\kappa = 5.0, \\chi = 0.5, \\theta = 0.5235987756, \\phi = 0.5235987756, AR_{\\max} = 6.0)$\n  3. $(U = 2.0, h_0 = 0.02, \\nu = 0.7, \\kappa = 100.0, \\chi = 0.5, \\theta = 1.2, \\phi = 0.7, AR_{\\max} = 5.0)$\n  4. $(U = 1.5, h_0 = 0.015, \\nu = 0.6, \\kappa = 0.0, \\chi = 0.5, \\theta = 0.7853981634, \\phi = 0.0, AR_{\\max} = 10.0)$\n  5. $(U = 1.0, h_0 = 0.01, \\nu = 1.0, \\kappa = 10.0, \\chi = 0.3, \\theta = 0.2, \\phi = 1.0, AR_{\\max} = 8.0)$\n\n您的程序应生成单行输出，其中包含五个测试用例的数值扩散削减因子 $R$。输出形式为逗号分隔的浮点数十进制列表，小数点后保留六位数字，并用方括号括起来（例如 $[r_1,r_2,r_3,r_4,r_5]$）。角度必须解释为弧度，所有物理量必须按其指定单位处理。输出 $R$ 是无量纲的。", "solution": "该问题要求针对计算流体动力学中的一个界面平流问题，推导并计算数值扩散削减因子 $R$。求解过程分两个阶段：首先，对 $R$ 的表达式进行解析推导；其次，实现一个计算程序，以评估给定测试参数集下的 $R$ 值。\n\n**削减因子 $R$ 的推导**\n\n数值扩散削减因子 $R$ 定义为各向同性参考网格在界面法线方向上的数值扩散系数与度量对齐的各向异性网格的相应系数之比。\n$$\nR = \\frac{D_{\\text{num}}^{\\text{iso}}(\\mathbf{\\hat{n}})}{D_{\\text{num}}^{\\text{aniso}}(\\mathbf{\\hat{n}})}\n$$\n问题指定了沿任意方向 $\\mathbf{\\hat{d}}$ 的数值扩散系数公式为：\n$$\nD_{\\text{num}}(\\mathbf{\\hat{d}}) = \\frac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{d}}| h_{\\mathbf{\\hat{d}}} (1 - \\nu)\n$$\n其中 $\\mathbf{u}$ 是流体速度矢量，$h_{\\mathbf{\\hat{d}}}$ 是在 $\\mathbf{\\hat{d}}$ 方向上的局部网格间距，$\\nu$ 是参考库朗数。\n\n对于各向同性情况，网格间距是均匀的，对所有方向均为 $h_{\\mathbf{\\hat{d}}} = h_0$。因此，垂直于界面的间距为 $h_\\perp^{\\text{iso}} = h_0$。相应的数值扩散系数为：\n$$\nD_{\\text{num}}^{\\text{iso}}(\\mathbf{\\hat{n}}) = \\frac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| h_0 (1 - \\nu)\n$$\n对于各向异性情况，网格在法线方向上被细化。间距由 $h_\\perp^{\\text{aniso}} = h_0 / AR$ 给出，其中 $AR$ 是有界纵横比。此情况下的数值扩散系数为：\n$$\nD_{\\text{num}}^{\\text{aniso}}(\\mathbf{\\hat{n}}) = \\frac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| \\left(\\frac{h_0}{AR}\\right) (1 - \\nu)\n$$\n将这些表达式代入 $R$ 的定义中，可得：\n$$\nR = \\frac{\\frac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| h_0 (1 - \\nu)}{\\frac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| \\frac{h_0}{AR} (1 - \\nu)}\n$$\n项 $\\frac{1}{2} |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| (1 - \\nu)$ 代表数值扩散效应的大小。如果此项非零，则可以从分子和分母中约去，从而显著简化表达式：\n$$\nR = \\frac{h_0}{h_0 / AR} = AR\n$$\n问题通过声明“如果 $|\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| = 0$ 或 $\\nu = 1$，则定义 $R = 0$”明确处理了此公因子为零的情况。这在物理上是合理的，因为这些条件意味着一阶迎风格式的数值扩散为零，因此没有可削减的扩散。\n\n因此，$R$ 的完整表达式为：\n$$\nR =\n\\begin{cases}\nAR  \\text{若 } |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| \\neq 0 \\text{ 且 } \\nu \\neq 1 \\\\\n0  \\text{若 } |\\mathbf{u}\\cdot \\mathbf{\\hat{n}}| = 0 \\text{ 或 } \\nu = 1\n\\end{cases}\n$$\n其中 $AR$ 是有界纵横比。\n\n**计算算法**\n\n计算每个测试用例 $(U, h_0, \\nu, \\kappa, \\chi, \\theta, \\phi, AR_{\\max})$ 的 $R$ 值的算法如下：\n\n1.  根据界面曲率 $\\kappa$ 和聚类敏感度 $\\chi$ 计算原始纵横比 $AR_{\\text{raw}}$：\n    $$AR_{\\text{raw}} = \\sqrt{\\chi |\\kappa|}$$\n2.  应用指定的边界条件 $AR \\ge 1$ 和 $AR \\le AR_{\\max}$ 来找到有效纵横比 $AR$：\n    $$AR = \\min(AR_{\\max}, \\max(AR_{\\text{raw}}, 1.0))$$\n3.  评估特殊情况 $R=0$ 的条件。\n    a. 检查库朗数是否为 $\\nu = 1.0$。\n    b. 计算速度的法向分量 $u_n = \\mathbf{u}\\cdot \\mathbf{\\hat{n}}$。速度矢量为 $\\mathbf{u} = [U \\cos\\phi, U \\sin\\phi]^\\top$，界面法向矢量为 $\\mathbf{\\hat{n}} = [-\\sin\\theta, \\cos\\theta]^\\top$。它们的点积是：\n    $$u_n = U(-\\cos\\phi \\sin\\theta + \\sin\\phi \\cos\\theta) = U \\sin(\\phi - \\theta)$$\n    检查 $|u_n|$ 在数值上是否为零。\n4.  如果 $\\nu = 1.0$ 或 $|u_n| \\approx 0$，则削减因子 $R = 0.0$。\n5.  否则，削减因子等于有界纵横比：$R = AR$。\n\n对提供的五个测试用例中的每一个都实施此程序。尽管问题描述了完整度量张量 $M$ 的构造，但推导出的 $R$ 表达式表明，最终计算仅需要得到的纵横比 $AR$ 和相对于界面法线的流体运动学参数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CFD numerical diffusion reduction factor problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (U, h0, nu, kappa, chi, theta, phi, AR_max)\n    test_cases = [\n        (1.0, 0.01, 0.5, 5.0, 0.5, 0.5235987756, 1.0471975512, 6.0),\n        (1.0, 0.01, 0.5, 5.0, 0.5, 0.5235987756, 0.5235987756, 6.0),\n        (2.0, 0.02, 0.7, 100.0, 0.5, 1.2, 0.7, 5.0),\n        (1.5, 0.015, 0.6, 0.0, 0.5, 0.7853981634, 0.0, 10.0),\n        (1.0, 0.01, 1.0, 10.0, 0.3, 0.2, 1.0, 8.0)\n    ]\n\n    results = []\n    # A small tolerance for floating point comparisons to zero.\n    TOLERANCE = 1e-9\n\n    for case in test_cases:\n        U, h0, nu, kappa, chi, theta, phi, AR_max = case\n\n        # Step 1: Calculate the raw aspect ratio.\n        # AR_raw = sqrt(chi * |kappa|)\n        ar_raw = np.sqrt(chi * np.abs(kappa))\n\n        # Step 2: Apply the bounds to obtain the effective aspect ratio AR.\n        # AR = min(AR_max, max(AR_raw, 1.0))\n        ar_bounded = np.min([AR_max, np.max([ar_raw, 1.0])])\n\n        # Step 3: Evaluate the conditions for setting R=0.\n        \n        # Condition a: Check if Courant number nu is 1.\n        is_nu_one = np.isclose(nu, 1.0, atol=TOLERANCE)\n\n        # Condition b: Check if the normal component of velocity is zero.\n        # u_n = U * sin(phi - theta)\n        u_n = U * np.sin(phi - theta)\n        is_un_zero = np.isclose(u_n, 0.0, atol=TOLERANCE)\n\n        # Step 4  5: Calculate the reduction factor R.\n        # If nu=1 or |u_n|=0, then R=0. Otherwise, R=AR.\n        if is_nu_one or is_un_zero:\n            R = 0.0\n        else:\n            R = ar_bounded\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3325976"}]}