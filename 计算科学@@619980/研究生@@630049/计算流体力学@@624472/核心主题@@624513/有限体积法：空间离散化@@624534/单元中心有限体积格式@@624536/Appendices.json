{"hands_on_practices": [{"introduction": "在将计算流体动力学（CFD）代码用于物理发现之前，必须严格验证其正确性。人造解法（Method of Manufactured Solutions, MMS）是代码验证的基石。此练习将指导您为非定常Navier–Stokes方程实现一个MMS测试，这是开发可靠求解器的一项基本技能。通过从一个已知的解析解推导源项，并测量离散格式的收敛阶，您将能够定量地确认代码实现的正确性。[@problem_id:3297768]", "problem": "要求您设计并实现一个制造解方法（Method of Manufactured Solutions, MMS）验证测试，该测试用于在二维周期性单位正方形上，基于单元中心有限体积框架的非定常不可压缩纳维-斯托克斯方程。您的任务是：选择一个解析的速度-压力对，推导相应的体积力源项和边界条件，然后通过将全离散算子应用于解析场，并测量离散残差随网格加密的缩放情况，来计算观测到的收敛阶。\n\n其基本出发点是非定常不可压缩纳维-斯托克斯方程组，定义在域 $\\Omega = [0,1]\\times[0,1]$上，且两个方向均为周期性边界条件：\n- 动量方程：$\\dfrac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} = \\boldsymbol{f}$，\n- 连续性方程：$\\nabla\\cdot\\boldsymbol{u} = 0$，\n其中 $\\boldsymbol{u}=(u,v)$ 是速度， $p$ 是压力除以密度， $\\nu$ 是运动粘度， $\\boldsymbol{f}=(f_u,f_v)$ 是体积力。三角函数的参数以弧度为单位。\n\n按以下步骤进行。\n\n1) 制造解场和边界条件：\n- 选择一个形式为 $\\psi(x,y,t) = A \\sin(k x)\\sin(k y)\\cos(\\omega t)$ 的流函数 $\\psi(x,y,t)$，其中 $A>0$，$k = 2\\pi$，且 $\\omega = 2\\pi$；通过 $\\boldsymbol{u} = (\\partial\\psi/\\partial y,\\ -\\partial\\psi/\\partial x)$ 定义制造速度，并通过 $p(x,y,t) = P\\cos(k x)\\cos(k y)\\sin(\\omega t)$ 定义制造压力，其中 $P>0$。这种构造恒定地满足 $\\nabla\\cdot\\boldsymbol{u} = 0$。\n- 通过将 $(\\boldsymbol{u},p)$ 代入动量方程并整理以分离出 $\\boldsymbol{f}$，来推导源项 $\\boldsymbol{f}(x,y,t)$。指定与此选择兼容的边界条件；由于场是 1-周期的，因此在 $x$ 和 $y$ 方向上均使用周期性边界。\n\n2) 单元中心有限体积离散化：\n- 使用一个覆盖 $\\Omega$ 的均匀 $N\\times N$ 单元中心网格，其中 $N\\in\\mathbb{N}$，单元宽度 $\\Delta x = \\Delta y = h = 1/N$，单元中心位于 $(x_i,y_j)=((i+\\tfrac{1}{2})h,(j+\\tfrac{1}{2})h)$，对于 $i,j\\in\\{0,\\dots,N-1\\}$。\n- 使用二阶中心差分以守恒有限体积形式离散化空间算子：\n  - $u$-动量方程的对流项的守恒形式 $\\nabla\\cdot(u\\boldsymbol{u})$，通过计算东西向面上的面法向通量 $F_{i+1/2,j} = u_{i+1/2,j}^2$ 和南北向面上的面法向通量 $G_{i,j+1/2} = u_{i,j+1/2}v_{i,j+1/2}$ 来离散化，其中 $u_{i+1/2,j}$ 表示相邻单元中心值的算术平均值；$v$-动量方程使用 $F_{i+1/2,j} = u_{i+1/2,j}v_{i+1/2,j}$ 和 $G_{i,j+1/2} = v_{i,j+1/2}^2$。通过在域边界处的环绕处理来实现周期性。\n  - 压力梯度使用中心差分：$(\\partial p/\\partial x)_{i,j} \\approx \\dfrac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}$ 和 $(\\partial p/\\partial y)_{i,j} \\approx \\dfrac{p_{i,j+1}-p_{i,j-1}}{2\\Delta y}$，使用周期性索引。\n  - 拉普拉斯算子使用标准的 5 点模板：$(\\nabla^2 \\phi)_{i,j} \\approx \\dfrac{\\phi_{i+1,j}+\\phi_{i-1,j}-2\\phi_{i,j}}{\\Delta x^2} + \\dfrac{\\phi_{i,j+1}+\\phi_{i,j-1}-2\\phi_{i,j}}{\\Delta y^2}$，适用于任何标量场 $\\phi$。\n- 使用单参数 $\\theta$-格式对时间进行离散化，其中 $\\theta \\in [\\tfrac{1}{2},1]$：对于作用于 $(\\boldsymbol{u},p)$ 的任何算子 $\\mathcal{L}$，定义 $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}^n + \\theta \\mathcal{L}^{n+1}$，并通过 $(\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n)/\\Delta t$ 离散化非定常项。这样可以在每个单元上得到全离散残差：\n$$\n\\boldsymbol{R}_{i,j} = \\frac{\\boldsymbol{u}_{i,j}^{n+1}-\\boldsymbol{u}_{i,j}^{n}}{\\Delta t} + \\left[\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})\\right]_{i,j}^{n+\\theta} + \\left[\\nabla p\\right]_{i,j}^{n+\\theta} - \\nu \\left[\\nabla^2 \\boldsymbol{u}\\right]_{i,j}^{n+\\theta} - \\boldsymbol{f}_{i,j}^{n+\\theta}.\n$$\n\n3) 观测收敛阶的测量：\n- 对于给定的参数集 $(\\nu,\\theta,A,P,t_0,c)$，其中 $c>0$，定义网格尺寸 $N\\in\\{16,32,64,128\\}$，设置 $\\Delta t = c\\,h$，其中 $h=1/N$，并定义 $t^n = t_0$ 和 $t^{n+1} = t_0 + \\Delta t$。在每个网格尺寸下，评估在这些时刻的精确场 $(\\boldsymbol{u}^n,p^n)$ 和 $(\\boldsymbol{u}^{n+1},p^{n+1})$ 以及精确源项 $\\boldsymbol{f}$，应用全离散残差 $\\boldsymbol{R}$，并计算域上向量残差的离散 $L^2$ 范数，\n$$\nE(h) = \\left( \\sum_{i,j} \\left( R_{u,i,j}^2 + R_{v,i,j}^2 \\right) h^2 \\right)^{1/2}.\n$$\n- 对四个网格尺寸的 $(\\log h, \\log E(h))$ 数据点使用最小二乘法进行线性拟合；观测到的收敛阶是斜率的负值 $p_{\\mathrm{obs}} = -\\dfrac{d\\log E}{d\\log h}$。\n\n您的程序必须为以下参数集测试套件（角度以弧度为单位）实现上述所有步骤，每个测试套件表示为 $(\\nu,\\theta,c,A,P,t_0)$:\n- 情况 1 (理想情况，对流-扩散混合，时间二阶): $(0.1,\\,0.5,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$。\n- 情况 2 (边缘情况，无粘性极限，时间二阶): $(0.0,\\,0.5,\\,0.2,\\,0.8,\\,1.2,\\,0.13)$。\n- 情况 3 (时间主导，后向欧拉，时间一阶): $(0.1,\\,1.0,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含情况 1–3 的三个观测收敛阶，格式为逗号分隔的十进制数列表，保留两位小数，并用方括号括起来，例如，“[2.01,2.00,1.01]”。", "solution": "用户要求对二维周期性域上的非定常不可压缩纳维-斯托克斯方程，进行基于单元中心有限体积离散化的制造解方法（MMS）验证。该过程涉及为给定的制造解推导解析源项，实现离散算子，计算截断误差，并确定观测到的收敛阶。\n\n### 步骤 1：问题验证\n\n**1.1. 提取给定条件**\n\n- **控制方程**:\n  - 动量方程: $\\dfrac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} = \\boldsymbol{f}$\n  - 连续性方程: $\\nabla\\cdot\\boldsymbol{u} = 0$\n- **域**: $\\Omega = [0,1]\\times[0,1]$，带有周期性边界。\n- **制造解**:\n  - 流函数: $\\psi(x,y,t) = A \\sin(k x)\\sin(k y)\\cos(\\omega t)$，其中 $A>0, k = 2\\pi, \\omega = 2\\pi$。\n  - 速度: $\\boldsymbol{u} = (\\partial\\psi/\\partial y,\\ -\\partial\\psi/\\partial x)$。\n  - 压力: $p(x,y,t) = P\\cos(k x)\\cos(k y)\\sin(\\omega t)$，其中 $P>0$。\n- **离散化**:\n  - 网格: 均匀 $N\\times N$ 单元中心网格，$\\Delta x = \\Delta y = h = 1/N$。单元中心 $(x_i,y_j)=((i+\\tfrac{1}{2})h,(j+\\tfrac{1}{2})h)$。\n  - 时间步进: $\\theta$-格式，使用 $\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}$。空间算子评估为 $\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}^n + \\theta \\mathcal{L}^{n+1}$。\n  - 空间算子 (二阶中心):\n    - 对流项 $\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})$: 守恒形式，面对速度采用算术平均。\n    - 压力梯度 $\\nabla p$: x分量为 $\\dfrac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}$。\n    - 拉普拉斯算子 $\\nabla^2 \\boldsymbol{u}$: 标准 5 点模板。\n- **验证程序**:\n  - 计算残差的离散 $L^2$ 范数 $E(h) = \\left( \\sum_{i,j} \\left( R_{u,i,j}^2 + R_{v,i,j}^2 \\right) h^2 \\right)^{1/2}$，对于 $N\\in\\{16,32,64,128\\}$。\n  - 时间步长: $\\Delta t = c\\,h$。\n  - 时间层级: $t^n = t_0$, $t^{n+1} = t_0 + \\Delta t$。\n  - 观测阶为对 $(\\log h, \\log E(h))$ 进行最小二乘拟合的斜率的负值。\n- **测试用例** $(\\nu,\\theta,c,A,P,t_0)$:\n  - 情况 1: $(0.1,\\,0.5,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$\n  - 情况 2: $(0.0,\\,0.5,\\,0.2,\\,0.8,\\,1.2,\\,0.13)$\n  - 情况 3: $(0.1,\\,1.0,\\,0.2,\\,1.0,\\,1.0,\\,0.07)$\n\n**1.2. 使用提取的给定条件进行验证**\n\n- **科学依据**: 该问题基于流体动力学的基石——不可压缩流动的基本纳维-斯托克斯方程。MMS 程序是计算科学中一种标准且严谨的验证技术。所选的制造解是光滑、可微且周期性的，使其适合于本分析。该问题在科学上是合理的。\n- **适定性**: 该问题是适定的。给定了制造解，任务是推导相应的源项，然后测量离散格式的收敛性，这是一个定义明确的计算过程。所有离散化细节和参数都已明确指定。该任务会导出一个唯一的、有意义的数值结果（收敛阶）。\n- **客观性**: 该问题以精确、客观的数学和计算术语表述。它没有歧义、主观性或观点性。\n\n**1.3. 结论与行动**\n\n问题陈述有效。它具有科学依据、适定、客观，并提供了一套完整且一致的指令。将提供一个解决方案。\n\n### 步骤 2：解析推导\n\n首先，我们推导速度分量并验证不可压缩性。\n给定流函数 $\\psi(x,y,t) = A \\sin(kx)\\sin(ky)\\cos(\\omega t)$，其中 $k=2\\pi, \\omega=2\\pi$:\n- $u(x,y,t) = \\dfrac{\\partial\\psi}{\\partial y} = Ak \\sin(kx)\\cos(ky)\\cos(\\omega t)$\n- $v(x,y,t) = -\\dfrac{\\partial\\psi}{\\partial x} = -Ak \\cos(kx)\\sin(ky)\\cos(\\omega t)$\n\n速度场的散度是:\n$$ \\nabla\\cdot\\boldsymbol{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = Ak^2 \\cos(kx)\\cos(ky)\\cos(\\omega t) - Ak^2 \\cos(kx)\\cos(ky)\\cos(\\omega t) = 0 $$\n该制造速度场确实是无散度的，符合要求。\n\n接下来，我们通过将制造解代入动量方程来推导源项 $\\boldsymbol{f}=(f_u, f_v)$:\n$$ \\boldsymbol{f} = \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u} $$\n各项推导如下:\n\n- **时间导数**:\n  - $\\dfrac{\\partial u}{\\partial t} = -A k \\omega \\sin(kx)\\cos(ky)\\sin(\\omega t)$\n  - $\\dfrac{\\partial v}{\\partial t} = Ak \\omega \\cos(kx)\\sin(ky)\\sin(\\omega t)$\n\n- **对流项**: $(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u}$。由于 $\\nabla\\cdot\\boldsymbol{u}=0$，这等价于 $\\nabla\\cdot(\\boldsymbol{u}\\otimes\\boldsymbol{u})$。\n  - 对于 $u$-动量: $(\\boldsymbol{u}\\cdot\\nabla)u = u\\dfrac{\\partial u}{\\partial x} + v\\dfrac{\\partial u}{\\partial y} = \\frac{1}{2}A^2k^3 \\cos^2(\\omega t) \\sin(2kx)$\n  - 对于 $v$-动量: $(\\boldsymbol{u}\\cdot\\nabla)v = u\\dfrac{\\partial v}{\\partial x} + v\\dfrac{\\partial v}{\\partial y} = \\frac{1}{2}A^2k^3 \\cos^2(\\omega t) \\sin(2ky)$\n\n- **压力梯度**: $\\nabla p$，其中 $p=P\\cos(kx)\\cos(ky)\\sin(\\omega t)$。\n  - $\\dfrac{\\partial p}{\\partial x} = -Pk \\sin(kx)\\cos(ky)\\sin(\\omega t)$\n  - $\\dfrac{\\partial p}{\\partial y} = -Pk \\cos(kx)\\sin(ky)\\sin(\\omega t)$\n\n- **粘性项**: $-\\nu \\nabla^2 \\boldsymbol{u}$。\n  - $\\nabla^2 u = \\dfrac{\\partial^2 u}{\\partial x^2} + \\dfrac{\\partial^2 u}{\\partial y^2} = -2Ak^3 \\sin(kx)\\cos(ky)\\cos(\\omega t) = -2k^2 u$\n  - $\\nabla^2 v = \\dfrac{\\partial^2 v}{\\partial x^2} + \\dfrac{\\partial^2 v}{\\partial y^2} = -2(-Ak\\cos(kx)\\sin(ky)\\cos(\\omega t))k^2 = -2k^2 v$\n  - 因此，$-\\nu \\nabla^2 \\boldsymbol{u} = 2\\nu k^2 \\boldsymbol{u}$。\n\n结合这些项可得到源项 $f_u$ 和 $f_v$:\n$$ f_u(x,y,t) = -k\\sin(\\omega t)(A\\omega + P)\\sin(kx)\\cos(ky) + 2A\\nu k^3\\cos(\\omega t)\\sin(kx)\\cos(ky) + \\frac{1}{2}A^2k^3\\cos^2(\\omega t)\\sin(2kx) $$\n$$ f_v(x,y,t) = k\\sin(\\omega t)(A\\omega - P)\\cos(kx)\\sin(ky) - 2A\\nu k^3\\cos(\\omega t)\\cos(kx)\\sin(ky) + \\frac{1}{2}A^2k^3\\cos^2(\\omega t)\\sin(2ky) $$\n\n### 步骤 3：离散化与验证实现\n\n实现遵循问题描述。创建一个 Python 程序来为给定的参数集执行 MMS 测试。\n\n1.  **网格与场**: 对于每个网格尺寸 $N$，生成一个均匀的单元中心网格。在时间层级 $t^n = t_0$ 和 $t^{n+1} = t_0 + \\Delta t$ 处评估单元中心的精确速度、压力和源项场。\n\n2.  **离散算子**: 实现用于离散空间算子（对流、压力梯度、拉普拉斯）的函数，使用周期性网格上的二阶中心差分。使用 `numpy.roll` 来高效处理周期性边界条件。\n\n3.  **残差计算**: 组装完整的离散残差 $\\boldsymbol{R}$。\n    - 首先，将离散空间算子应用于 $t^n$ 和 $t^{n+1}$ 时的精确解场。\n    - 使用 $\\theta$-加权组合这些结果：$\\mathcal{L}^{n+\\theta} = (1-\\theta)\\mathcal{L}(\\phi^n) + \\theta\\mathcal{L}(\\phi^{n+1})$。\n    - 源项 $\\boldsymbol{f}$ 也在 $t^n$ 和 $t^{n+1}$ 时刻进行评估并类似地加权。\n    - 时间导数通过 $\\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}$ 近似。\n    - 最后，将所有项相加形成每个单元上的残差向量 $\\boldsymbol{R} = (R_u, R_v)$。\n\n4.  **误差范数与收敛阶**: 为每个网格分辨率 $N$ 计算残差的离散 $L^2$ 范数 $E(h)$。对误差和网格间距的对数 $(\\log h, \\log E(h))$ 进行线性回归。观测到的收敛阶是最佳拟合线的斜率的负值。\n\n对三个测试用例中的每一个重复此过程。\n\n- **情况 1**: $\\theta=0.5$ (Crank-Nicolson) 在时间上是二阶的。空间离散化是二阶的。当 $\\Delta t \\propto h$ 时，整个格式预期为二阶精度, $p_{\\mathrm{obs}} \\approx 2.0$。\n- **情况 2**: 无粘性情况 ($\\nu=0$)，但离散格式与情况 1 相同。预期阶数也是 $p_{\\mathrm{obs}} \\approx 2.0$。\n- **情况 3**: $\\theta=1.0$ (Backward Euler) 在时间上是一阶的。由于空间误差为 $O(h^2)$ 且时间误差为 $O(\\Delta t) = O(h)$，因此整体精度由时间误差主导。预期阶数为 $p_{\\mathrm{obs}} \\approx 1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions (MMS) verification\n    for the unsteady incompressible Navier-Stokes equations.\n    \"\"\"\n    \n    # --- Mathematical Constants ---\n    K = 2 * np.pi\n    OMEGA = 2 * np.pi\n\n    # --- Analytical Solution Functions ---\n\n    def u_exact(x, y, t, A):\n        \"\"\"Computes the exact u-velocity component.\"\"\"\n        return A * K * np.sin(K * x) * np.cos(K * y) * np.cos(OMEGA * t)\n\n    def v_exact(x, y, t, A):\n        \"\"\"Computes the exact v-velocity component.\"\"\"\n        return -A * K * np.cos(K * x) * np.sin(K * y) * np.cos(OMEGA * t)\n\n    def p_exact(x, y, t, P):\n        \"\"\"Computes the exact pressure component.\"\"\"\n        return P * np.cos(K * x) * np.cos(K * y) * np.sin(OMEGA * t)\n\n    def fu_exact(x, y, t, nu, A, P):\n        \"\"\"Computes the exact source term for the u-momentum equation.\"\"\"\n        term1 = -K * np.sin(OMEGA * t) * (A * OMEGA + P) * np.sin(K * x) * np.cos(K * y)\n        term2 = 2 * A * nu * K**3 * np.cos(OMEGA * t) * np.sin(K * x) * np.cos(K * y)\n        term3 = 0.5 * A**2 * K**3 * np.cos(OMEGA * t)**2 * np.sin(2 * K * x)\n        return term1 + term2 + term3\n\n    def fv_exact(x, y, t, nu, A, P):\n        \"\"\"Computes the exact source term for the v-momentum equation.\"\"\"\n        term1 = K * np.sin(OMEGA * t) * (A * OMEGA - P) * np.cos(K * x) * np.sin(K * y)\n        term2 = -2 * A * nu * K**3 * np.cos(OMEGA * t) * np.cos(K * x) * np.sin(K * y)\n        term3 = 0.5 * A**2 * K**3 * np.cos(OMEGA * t)**2 * np.sin(2 * K * y)\n        return term1 + term2 + term3\n\n    # --- Discrete Operator Functions ---\n\n    def grad_op(p, h):\n        \"\"\"Computes the pressure gradient using second-order central differences.\"\"\"\n        dp_dx = (np.roll(p, -1, axis=1) - np.roll(p, 1, axis=1)) / (2 * h)\n        dp_dy = (np.roll(p, -1, axis=0) - np.roll(p, 1, axis=0)) / (2 * h)\n        return dp_dx, dp_dy\n\n    def lap_op(phi, h):\n        \"\"\"Computes the Laplacian using the standard 5-point stencil.\"\"\"\n        phi_ip1 = np.roll(phi, -1, axis=1)\n        phi_im1 = np.roll(phi, 1, axis=1)\n        phi_jp1 = np.roll(phi, -1, axis=0)\n        phi_jm1 = np.roll(phi, 1, axis=0)\n        \n        lap_phi_x = (phi_ip1 + phi_im1 - 2 * phi) / h**2\n        lap_phi_y = (phi_jp1 + phi_jm1 - 2 * phi) / h**2\n        return lap_phi_x + lap_phi_y\n\n    def conv_op(u, v, h):\n        \"\"\"Computes the conservative form of the convective term.\"\"\"\n        # East-West face values (axis=1 for x-direction)\n        u_face_E = (u + np.roll(u, -1, axis=1)) / 2\n        v_face_E = (v + np.roll(v, -1, axis=1)) / 2\n        \n        # North-South face values (axis=0 for y-direction)\n        u_face_N = (u + np.roll(u, -1, axis=0)) / 2\n        v_face_N = (v + np.roll(v, -1, axis=0)) / 2\n        \n        # Fluxes for u-momentum: F = u*u, G = u*v\n        flux_F_u = u_face_E**2\n        flux_G_u = u_face_N * v_face_N\n        conv_u = (flux_F_u - np.roll(flux_F_u, 1, axis=1)) / h + \\\n                 (flux_G_u - np.roll(flux_G_u, 1, axis=0)) / h\n\n        # Fluxes for v-momentum: F = v*u, G = v*v\n        flux_F_v = v_face_E * u_face_E\n        flux_G_v = v_face_N**2\n        conv_v = (flux_F_v - np.roll(flux_F_v, 1, axis=1)) / h + \\\n                 (flux_G_v - np.roll(flux_G_v, 1, axis=0)) / h\n        \n        return conv_u, conv_v\n\n    # --- Main verification function ---\n\n    def compute_observed_order(case_params):\n        nu, theta, c, A, P, t0 = case_params\n        grid_sizes = [16, 32, 64, 128]\n        log_h_vals = []\n        log_E_vals = []\n\n        for N in grid_sizes:\n            # 1. Grid and time step setup\n            h = 1.0 / N\n            dt = c * h\n            x_coords = (np.arange(N) + 0.5) * h\n            y_coords = (np.arange(N) + 0.5) * h\n            X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n            \n            t_n = t0\n            t_np1 = t0 + dt\n\n            # 2. Evaluate exact solution fields at t_n and t_np1\n            u_n, v_n = u_exact(X, Y, t_n, A), v_exact(X, Y, t_n, A, )\n            p_n = p_exact(X, Y, t_n, P)\n            u_np1, v_np1 = u_exact(X, Y, t_np1, A), v_exact(X, Y, t_np1, A)\n            p_np1 = p_exact(X, Y, t_np1, P)\n\n            # 3. Evaluate and weight source terms\n            f_u_n, f_v_n = fu_exact(X, Y, t_n, nu, A, P), fv_exact(X, Y, t_n, nu, A, P)\n            f_u_np1, f_v_np1 = fu_exact(X, Y, t_np1, nu, A, P), fv_exact(X, Y, t_np1, nu, A, P)\n            f_u_ntheta = (1 - theta) * f_u_n + theta * f_u_np1\n            f_v_ntheta = (1 - theta) * f_v_n + theta * f_v_np1\n            \n            # 4. Compute and weight discrete spatial operators\n            conv_u_n, conv_v_n = conv_op(u_n, v_n, h)\n            grad_px_n, grad_py_n = grad_op(p_n, h)\n            lap_u_n, lap_v_n = lap_op(u_n, h), lap_op(v_n, h)\n            \n            conv_u_np1, conv_v_np1 = conv_op(u_np1, v_np1, h)\n            grad_px_np1, grad_py_np1 = grad_op(p_np1, h)\n            lap_u_np1, lap_v_np1 = lap_op(u_np1, h), lap_op(v_np1, h)\n            \n            conv_u_ntheta = (1-theta)*conv_u_n + theta*conv_u_np1\n            grad_px_ntheta = (1-theta)*grad_px_n + theta*grad_px_np1\n            lap_u_ntheta = (1-theta)*lap_u_n + theta*lap_u_np1\n            \n            conv_v_ntheta = (1-theta)*conv_v_n + theta*conv_v_np1\n            grad_py_ntheta = (1-theta)*grad_py_n + theta*grad_py_np1\n            lap_v_ntheta = (1-theta)*lap_v_n + theta*lap_v_np1\n            \n            # 5. Assemble the residual\n            time_deriv_u = (u_np1 - u_n) / dt\n            R_u = time_deriv_u + conv_u_ntheta + grad_px_ntheta - nu * lap_u_ntheta - f_u_ntheta\n            \n            time_deriv_v = (v_np1 - v_n) / dt\n            R_v = time_deriv_v + conv_v_ntheta + grad_py_ntheta - nu * lap_v_ntheta - f_v_ntheta\n            \n            # 6. Compute discrete L2 norm of the residual\n            E_h = np.sqrt(np.sum(R_u**2 + R_v**2) * h**2)\n            \n            # 7. Store log values for regression\n            log_h_vals.append(np.log(h))\n            log_E_vals.append(np.log(E_h))\n\n        # 8. Perform linear regression and return observed order\n        slope, _, _, _, _ = linregress(log_h_vals, log_E_vals)\n        return -slope\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1: (nu, theta, c, A, P, t0) -> Expected Order: 2\n        (0.1, 0.5, 0.2, 1.0, 1.0, 0.07),\n        # Case 2: -> Expected Order: 2\n        (0.0, 0.5, 0.2, 0.8, 1.2, 0.13),\n        # Case 3: -> Expected Order: 1\n        (0.1, 1.0, 0.2, 1.0, 1.0, 0.07),\n    ]\n\n    results = []\n    for case in test_cases:\n        order = compute_observed_order(case)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{order:.2f}\" for order in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3297768"}, {"introduction": "一个优秀的数值格式除了应具有形式上的精度，还应尊重连续方程的内在物理守恒律。对于无粘性流动，对流项不应人为地产生或耗散动能。本练习探讨离散动能守恒这一关键性质。您将分析和比较不同的对流通量离散格式，以理解其构造如何直接影响模拟的物理保真度，这对于长时间积分和湍流模拟是至关重要的考量。[@problem_id:3297733]", "problem": "考虑在二维周期性域上的不可压缩对流动力学，该域通过均匀笛卡尔网格上的单元中心有限体积法进行离散。设域为 $\\Omega = [0,L_x] \\times [0,L_y]$，在两个方向上均具有周期性边界。令 $N_x$ 和 $N_y$ 分别表示 $x$ 和 $y$ 方向上的控制体数量，其均匀间距为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。未知量是单元中心的速度分量 $u_{i,j}$ 和 $v_{i,j}$，其中 $i \\in \\{0,1,\\ldots,N_x-1\\}$ 和 $j \\in \\{0,1,\\ldots,N_y-1\\}$。\n\n基本基础是守恒形式的不可压缩欧拉方程（无强迫项，单位密度），\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\nabla p = \\boldsymbol{0}, \\quad \\nabla \\cdot \\boldsymbol{u} = 0,\n$$\n以及动能\n$$\nK(t) = \\frac{1}{2} \\int_{\\Omega} \\lVert \\boldsymbol{u}(\\boldsymbol{x},t) \\rVert^2 \\, \\mathrm{d}\\Omega,\n$$\n在周期性边界条件下，连续对流项会使动能随时间保持不变。在单元中心有限体积法中，我们为向量场 $\\boldsymbol{a}$ 和 $\\boldsymbol{b}$ 定义一个离散内积\n$$\n\\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle_h = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( a_{i,j}^{(x)} b_{i,j}^{(x)} + a_{i,j}^{(y)} b_{i,j}^{(y)} \\right) \\Delta x \\Delta y,\n$$\n并将离散动能定义为 $K_h = \\frac{1}{2} \\langle \\boldsymbol{u}, \\boldsymbol{u} \\rangle_h$。\n\n您将使用三种在同位网格上对流算子的有限体积离散化方法，这些方法通过算术平均组装面心值：\n- 守恒中心通量形式 $-\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$，其中每个面通量使用相邻单元值的算术平均来重构面心速度。\n- 斜对称分裂形式 $-\\frac{1}{2} \\left( \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u} \\right)$，其中 $(\\boldsymbol{u} \\cdot \\nabla_h)$ 在单元中心使用中心差分，而 $\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ 使用守恒中心通量散度。\n- 一阶迎风通量形式 $-\\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$，其面心值根据面法向速度的符号从迎风供体单元获取。\n\n所有离散微分算子必须在均匀网格上使用周期性环绕索引。在每个垂直面上，定义面心值 $u_e = \\frac{1}{2}(u_{i,j} + u_{i+1,j})$，$v_e = \\frac{1}{2}(v_{i,j} + v_{i+1,j})$，在每个水平面上，定义 $u_n = \\frac{1}{2}(u_{i,j} + u_{i,j+1})$，$v_n = \\frac{1}{2}(v_{i,j} + v_{i,j+1})$。$x$-动量在垂直面上的守恒中心通量为 $F^{(x)}_{\\text{vert}} = u_e^2$，在水平面上为 $F^{(x)}_{\\text{horiz}} = u_n v_n$。类似地，对于 $y$-动量，$F^{(y)}_{\\text{vert}} = u_e v_e$ 且 $F^{(y)}_{\\text{horiz}} = v_n^2$。控制体中的离散守恒散度是净通量差除以单元尺寸，例如对于垂直面是 $(F_e - F_w)/\\Delta x$，其中 $F_w$ 是单元西侧垂直面上的通量，对于水平面是 $(F_n - F_s)/\\Delta y$。\n\n提出以下由整数 $m$ 和 $n$、振幅 $U_0$ 以及域长度 $L_x$ 和 $L_y$ 参数化的周期性测试速度场：\n- 对于 $m \\ge 1$ 和 $n \\ge 1$，定义波数 $k_x = \\frac{2\\pi m}{L_x}$ 和 $k_y = \\frac{2\\pi n}{L_y}$ 以及解析场\n$$\nu(x,y) = U_0 \\sin(k_x x) \\cos(k_y y), \\qquad v(x,y) = - U_0 \\frac{k_x}{k_y} \\cos(k_x x) \\sin(k_y y),\n$$\n该场在解析上是无散度的。\n- 对于均匀流动的边缘情况 $m = 0$ 和 $n = 0$，定义 $u(x,y) = U_0$ 和 $v(x,y) = 0$，这是一个常数场。\n\n通过在单元中心 $x_i = \\left(i + \\frac{1}{2} \\right) \\Delta x$ 和 $y_j = \\left(j + \\frac{1}{2} \\right) \\Delta y$ 对这些场进行采样来离散化 $u$ 和 $v$。然后，对于选定的对流离散化，定义半离散更新\n$$\n\\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} = \\boldsymbol{R}(\\boldsymbol{u}),\n$$\n和以下诊断指标：\n- 由离散动能归一化的半离散能量生成率，\n$$\nr_h = \\frac{\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h}{K_h}.\n$$\n- 时间步长为 $\\Delta t$ 的单步显式欧拉离散动能变化，\n$$\n\\delta_h = \\frac{K_h^{\\star} - K_h}{K_h}, \\quad \\text{其中} \\quad \\boldsymbol{u}^{\\star} = \\boldsymbol{u} + \\Delta t \\, \\boldsymbol{R}(\\boldsymbol{u}), \\; K_h^{\\star} = \\frac{1}{2} \\langle \\boldsymbol{u}^{\\star}, \\boldsymbol{u}^{\\star} \\rangle_h.\n$$\n- 由速度 $\\ell_2$ 范数归一化的离散散度模，\n$$\nd_h = \\frac{\\left( \\sum_{i,j} \\left( \\nabla_h \\cdot \\boldsymbol{u} \\right)_{i,j}^2 \\, \\Delta x \\Delta y \\right)^{1/2}}{\\left( \\sum_{i,j} \\left( u_{i,j}^2 + v_{i,j}^2 \\right) \\, \\Delta x \\Delta y \\right)^{1/2}},\n$$\n其中 $\\nabla_h \\cdot \\boldsymbol{u}$ 是根据面法向速度 $(u_e, v_n)$ 计算的有限体积散度。\n\n从基本守恒律和周期性假设出发，推导为什么对于中心差分和周期性环绕，斜对称分裂形式具有 $\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h = 0$（在舍入误差范围内），而与 $\\nabla_h \\cdot \\boldsymbol{u}$ 无关；并推导为什么守恒中心通量形式具有 $\\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h = - \\frac{1}{2} \\langle \\lVert \\boldsymbol{u} \\rVert^2, \\nabla_h \\cdot \\boldsymbol{u} \\rangle_h$（因此如果离散散度为零，则该值为零）。解释为什么一阶迎风形式由于数值耗散而产生非正的能量生成。\n\n实现一个程序，构建离散速度场并为以下每个测试案例计算 $(r_h, \\delta_h, d_h)$（所有案例均在 $L_x = 2\\pi$ 和 $L_y = 2\\pi$ 的域中）：\n- 案例 1：$N_x = 32$，$N_y = 32$，$m = 2$，$n = 3$，$U_0 = 1.1$，$\\Delta t = 10^{-3}$，斜对称分裂形式。\n- 案例 2：$N_x = 32$，$N_y = 32$，$m = 2$，$n = 3$，$U_0 = 1.1$，$\\Delta t = 10^{-3}$，守恒中心通量形式。\n- 案例 3：$N_x = 32$，$N_y = 32$，$m = 2$，$n = 3$，$U_0 = 1.1$，$\\Delta t = 10^{-3}$，一阶迎风通量形式。\n- 案例 4：$N_x = 16$，$N_y = 8$，$m = 0$，$n = 0$，$U_0 = 0.77$，$\\Delta t = 10^{-3}$，一阶迎风通量形式（均匀流动边缘情况）。\n- 案例 5：$N_x = 64$，$N_y = 8$，$m = 3$，$n = 1$，$U_0 = 0.8$，$\\Delta t = 2 \\times 10^{-4}$，斜对称分裂形式（各向异性网格）。\n\n您的程序必须为每个测试案例输出诊断三元组 $(r_h, \\delta_h, d_h)$，其格式必须完全如下：单行包含一个类 JSON 的列表之列表，每个内部列表按 $[r_h,\\delta_h,d_h]$ 的顺序排列，使用 Python 的默认浮点数字符串格式。例如，输出应类似于 $[[r_1,\\delta_1,d_1],[r_2,\\delta_2,d_2],\\ldots]$。\n\n所有角度均以弧度为单位。除了给定的无量纲化之外，不需要任何物理单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表之列表形式的结果（例如，$[[r_1,\\delta_1,d_1],[r_2,\\delta_2,d_2],[r_3,\\delta_3,d_3],[r_4,\\delta_4,d_4],[r_5,\\delta_5,d_5]]$）。", "solution": "用户提供了一个有效且定义明确的计算流体力学问题。该任务包括两部分：首先，对不可压缩欧拉方程中对流项的三种不同有限体积离散化方案的动能守恒性质进行理论推导；其次，进行数值实现，以计算这些方案在特定测试案例下的诊断指标。\n\n### 第1部分：能量守恒性质的推导\n\n对于半离散系统 $\\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} = \\boldsymbol{R}(\\boldsymbol{u})$，离散动能 $K_h = \\frac{1}{2} \\langle \\boldsymbol{u}, \\boldsymbol{u} \\rangle_h$ 的变化率由下式给出：\n$$\n\\frac{\\mathrm{d}K_h}{\\mathrm{d}t} = \\left\\langle \\boldsymbol{u}, \\frac{\\mathrm{d}\\boldsymbol{u}}{\\mathrm{d}t} \\right\\rangle_h = \\langle \\boldsymbol{u}, \\boldsymbol{R}(\\boldsymbol{u}) \\rangle_h\n$$\n归一化能量生成率为 $r_h = \\frac{1}{K_h} \\frac{\\mathrm{d}K_h}{\\mathrm{d}t}$。我们对每种方案分析这个量。\n\n**1. 斜对称分裂形式**\n\n对流算子为 $\\boldsymbol{R}_{skew}(\\boldsymbol{u}) = -\\frac{1}{2} \\left( \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u}) + (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u} \\right)$。令 $\\boldsymbol{C}(\\boldsymbol{u}) = \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$ 为守恒部分，$\\boldsymbol{A}(\\boldsymbol{u}) = (\\boldsymbol{u} \\cdot \\nabla_h) \\boldsymbol{u}$ 为平流部分。两者都使用中心差分和算术平均在周期性网格上进行离散化。\n\n通过分部求和（分部积分的离散等价形式）可以证明，此类离散化方法的一个基本性质是，离散算子 $\\boldsymbol{C}$ 和 $\\boldsymbol{A}$ 在离散内积下互为负转置。也就是说，对于任意两个离散向量场 $\\boldsymbol{\\phi}$ 和 $\\boldsymbol{\\psi}$：\n$$\n\\langle \\boldsymbol{\\phi}, \\boldsymbol{C}(\\boldsymbol{\\psi}) \\rangle_h = - \\langle \\boldsymbol{A}(\\boldsymbol{\\psi})\\boldsymbol{\\phi}, \\boldsymbol{1} \\rangle_h\n$$\n我们需要的性质是，整个算子 $\\boldsymbol{R}_{skew}$ 是斜对称的，即对于任意两个场 $\\boldsymbol{\\phi}$ 和 $\\boldsymbol{\\psi}$：\n$$\n\\langle \\boldsymbol{\\phi}, \\boldsymbol{R}_{skew}(\\boldsymbol{\\psi}) \\rangle_h = - \\langle \\boldsymbol{\\psi}, \\boldsymbol{R}_{skew}(\\boldsymbol{\\phi}) \\rangle_h\n$$\n这个性质对于 $\\boldsymbol{R}_{skew}$ 的特定构造是成立的。设 $\\boldsymbol{\\phi} = \\boldsymbol{\\psi} = \\boldsymbol{u}$，我们得到：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h = - \\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h\n$$\n这意味着 $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{skew}(\\boldsymbol{u}) \\rangle_h = 0$。因此，半离散动能是精确守恒的，能量生成率 $r_h = 0$，无论离散速度场是否无散度。这在机器浮点精度误差范围内成立。\n\n**2. 守恒中心通量形式**\n\n算子为 $\\boldsymbol{R}_{cons}(\\boldsymbol{u}) = - \\nabla_h \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})$。能量生成为 $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{cons}(\\boldsymbol{u}) \\rangle_h$。其推导过程与其连续形式的对应物类似。在连续情况下，由对流引起的动能变化率为：\n$$\n\\frac{\\mathrm{d}K}{\\mathrm{d}t} = - \\int_{\\Omega} \\boldsymbol{u} \\cdot (\\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})) \\, \\mathrm{d}\\Omega\n$$\n使用向量恒等式 $\\boldsymbol{u} \\cdot (\\nabla \\cdot (\\boldsymbol{u} \\otimes \\boldsymbol{u})) = (\\boldsymbol{u} \\cdot \\nabla)\\frac{\\lVert\\boldsymbol{u}\\rVert^2}{2} + \\lVert\\boldsymbol{u}\\rVert^2(\\nabla \\cdot \\boldsymbol{u})$，并对第一项应用散度定理（在周期性域上该项为零），可得：\n$$\n\\frac{\\mathrm{d}K}{\\mathrm{d}t} = -\\frac{1}{2} \\int_{\\Omega} \\lVert\\boldsymbol{u}\\rVert^2 (\\nabla \\cdot \\boldsymbol{u}) \\, \\mathrm{d}\\Omega\n$$\n中心差分格式的构造是为了模拟这些连续性质。通过离散分部求和可以证明，离散格式满足一个类似的恒等式：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{R}_{cons}(\\boldsymbol{u}) \\rangle_h = -\\frac{1}{2} \\langle \\lVert \\boldsymbol{u} \\rVert^2, \\nabla_h \\cdot \\boldsymbol{u} \\rangle_h\n$$\n其中 $\\lVert \\boldsymbol{u} \\rVert^2$ 是单元中心速度大小平方的场，即 $(u_{i,j}^2 + v_{i,j}^2)$。此关系表明，守恒中心通量形式仅在离散速度场无散度时（即对所有单元 $(\\nabla_h \\cdot \\boldsymbol{u})_{i,j} = 0$）才守恒能量。所提供的解析速度场在连续意义上是无散度的，但其离散采样不一定在离散意义上无散度，这可能导致能量的产生或耗散。\n\n**3. 一阶迎风通量形式**\n\n一阶迎风格式根据垂直于单元面的速度方向来确定该面上被对流的量的值。对于法向速度为 $u_n$ 的面，迎风通量可以写成中心差分通量和一个耗散项之和：\n$$\nF_{upwind} = F_{central} - \\frac{1}{2} |u_n| \\Delta x(\\text{梯度项})\n$$\n该通量的散度在动量方程中引入了一个类似于物理粘性的项，因此被称为“数值粘性”或“数值扩散”。完整的算子 $\\boldsymbol{R}_{upwind}$ 可以表示为：\n$$\n\\boldsymbol{R}_{upwind}(\\boldsymbol{u}) = \\boldsymbol{R}_{central}(\\boldsymbol{u}) + \\boldsymbol{D}(\\boldsymbol{u})\n$$\n其中 $\\boldsymbol{D}(\\boldsymbol{u})$ 代表数值扩散算子，其形式为 $\\nabla_h \\cdot (\\nu_h \\nabla_h \\boldsymbol{u})$。数值粘性系数 $\\nu_h$ 始终为非负，与局部速度大小和网格间距成正比。\n\n这个耗散项对动能方程的贡献是：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{D}(\\boldsymbol{u}) \\rangle_h = \\langle \\boldsymbol{u}, \\nabla_h \\cdot (\\nu_h \\nabla_h \\boldsymbol{u}) \\rangle_h\n$$\n使用分部求和，这变为：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{D}(\\boldsymbol{u}) \\rangle_h = - \\langle \\nabla_h \\boldsymbol{u}, \\nu_h \\nabla_h \\boldsymbol{u} \\rangle_h = - \\sum_{i,j} \\nu_h \\lVert \\nabla_h \\boldsymbol{u} \\rVert^2_{i,j} \\Delta x \\Delta y \\le 0\n$$\n因为 $\\nu_h \\ge 0$，这一项总是从流动中移除动能。总的能量生成率 $\\langle \\boldsymbol{u}, \\boldsymbol{R}_{upwind}(\\boldsymbol{u}) \\rangle_h$ 是中心项（可正可负）和耗散项（恒为非正）之和。对于大多数流动，耗散效应占主导地位，导致净能量生成为非正，即 $r_h \\le 0$。\n\n### 第2部分：数值实现与结果\n\n以下 Python 代码实现了指定的有限体积格式，并为五个给定的测试案例计算了诊断指标。", "answer": "```python\nimport numpy as np\n\ndef compute_convection(u, v, dx, dy, scheme):\n    \"\"\"\n    Computes the convective term R(u) for different schemes.\n    R(u) is the RHS of d(u)/dt = R(u).\n    \"\"\"\n\n    # --- Central Conservative Operator: Op_C(u) = grad_h . (u tensor u) ---\n    def compute_op_central(u, v, dx, dy):\n        # Face-centered velocities (arithmetic average)\n        u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n        v_e = 0.5 * (v + np.roll(v, -1, axis=1))\n        u_n = 0.5 * (u + np.roll(u, -1, axis=0))\n        v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n\n        # Fluxes\n        F_x_vert = u_e**2\n        F_x_horiz = u_n * v_n\n        F_y_vert = u_e * v_e\n        F_y_horiz = v_n**2\n\n        # Divergence of fluxes\n        Op_C_x = (F_x_vert - np.roll(F_x_vert, 1, axis=1)) / dx + \\\n                 (F_x_horiz - np.roll(F_x_horiz, 1, axis=0)) / dy\n        Op_C_y = (F_y_vert - np.roll(F_y_vert, 1, axis=1)) / dx + \\\n                 (F_y_horiz - np.roll(F_y_horiz, 1, axis=0)) / dy\n        return Op_C_x, Op_C_y\n\n    # --- Central Advective Operator: Op_A(u) = (u . grad_h) u ---\n    def compute_op_advective(u, v, dx, dy):\n        du_dx = (np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2 * dx)\n        du_dy = (np.roll(u, -1, axis=0) - np.roll(u, 1, axis=0)) / (2 * dy)\n        dv_dx = (np.roll(v, -1, axis=1) - np.roll(v, 1, axis=1)) / (2 * dx)\n        dv_dy = (np.roll(v, -1, axis=0) - np.roll(v, 1, axis=0)) / (2 * dy)\n\n        Op_A_x = u * du_dx + v * du_dy\n        Op_A_y = u * dv_dx + v * dv_dy\n        return Op_A_x, Op_A_y\n\n    if scheme == 'conservative central flux':\n        Op_C_x, Op_C_y = compute_op_central(u, v, dx, dy)\n        return -Op_C_x, -Op_C_y\n\n    elif scheme == 'skew-symmetric split':\n        Op_C_x, Op_C_y = compute_op_central(u, v, dx, dy)\n        Op_A_x, Op_A_y = compute_op_advective(u, v, dx, dy)\n        Rx = -0.5 * (Op_C_x + Op_A_x)\n        Ry = -0.5 * (Op_C_y + Op_A_y)\n        return Rx, Ry\n\n    elif scheme == 'first-order upwind':\n        # East/West faces (normal in x-dir)\n        u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n        u_upwind_e = np.where(u_e >= 0, u, np.roll(u, -1, axis=1))\n        v_upwind_e = np.where(u_e >= 0, v, np.roll(v, -1, axis=1))\n        F_x_vert = u_e * u_upwind_e\n        F_y_vert = u_e * v_upwind_e\n\n        # North/South faces (normal in y-dir)\n        v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n        u_upwind_n = np.where(v_n >= 0, u, np.roll(u, -1, axis=0))\n        v_upwind_n = np.where(v_n >= 0, v, np.roll(v, -1, axis=0))\n        F_x_horiz = v_n * u_upwind_n\n        F_y_horiz = v_n * v_upwind_n\n\n        Op_C_x = (F_x_vert - np.roll(F_x_vert, 1, axis=1)) / dx + \\\n                 (F_x_horiz - np.roll(F_x_horiz, 1, axis=0)) / dy\n        Op_C_y = (F_y_vert - np.roll(F_y_vert, 1, axis=1)) / dx + \\\n                 (F_y_horiz - np.roll(F_y_horiz, 1, axis=0)) / dy\n        return -Op_C_x, -Op_C_y\n\n    else:\n        raise ValueError(\"Unknown scheme\")\n\ndef compute_diagnostics(u, v, Rx, Ry, dx, dy, dt):\n    \"\"\"\n    Computes the three diagnostic metrics (r_h, delta_h, d_h).\n    \"\"\"\n    cell_area = dx * dy\n\n    # Discrete kinetic energy K_h\n    kh = 0.5 * np.sum(u**2 + v**2) * cell_area\n\n    # Handle case of zero kinetic energy to avoid division by zero\n    if kh  1e-15:\n        return 0.0, 0.0, 0.0\n\n    # Semi-discrete energy production rate r_h\n    dKh_dt = np.sum(u * Rx + v * Ry) * cell_area\n    rh = dKh_dt / kh\n\n    # One-step Euler discrete energy change delta_h\n    u_star = u + dt * Rx\n    v_star = v + dt * Ry\n    kh_star = 0.5 * np.sum(u_star**2 + v_star**2) * cell_area\n    deltah = (kh_star - kh) / kh\n\n    # Discrete divergence magnitude d_h\n    u_e = 0.5 * (u + np.roll(u, -1, axis=1))\n    v_n = 0.5 * (v + np.roll(v, -1, axis=0))\n    div_u = (u_e - np.roll(u_e, 1, axis=1)) / dx + \\\n            (v_n - np.roll(v_n, 1, axis=0)) / dy\n            \n    norm_div_u_sq = np.sum(div_u**2) * cell_area\n    norm_u_sq = np.sum(u**2 + v**2) * cell_area\n    \n    dh = np.sqrt(norm_div_u_sq / norm_u_sq) if norm_u_sq > 1e-15 else 0.0\n    \n    return rh, deltah, dh\n\ndef solve():\n    \"\"\"\n    Main function to set up and run all test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, m, n, U0, dt, scheme_name)\n        (32, 32, 2, 3, 1.1, 1e-3, 'skew-symmetric split'),\n        (32, 32, 2, 3, 1.1, 1e-3, 'conservative central flux'),\n        (32, 32, 2, 3, 1.1, 1e-3, 'first-order upwind'),\n        (16,  8, 0, 0, 0.77, 1e-3, 'first-order upwind'),\n        (64,  8, 3, 1, 0.8, 2e-4, 'skew-symmetric split'),\n    ]\n\n    results = []\n    Lx, Ly = 2 * np.pi, 2 * np.pi\n\n    for case in test_cases:\n        Nx, Ny, m, n, U0, dt, scheme = case\n        \n        # Grid setup\n        dx, dy = Lx / Nx, Ly / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_centers, y_centers)\n\n        # Velocity field initialization\n        if m >= 1 and n >= 1:\n            kx = 2 * np.pi * m / Lx\n            ky = 2 * np.pi * n / Ly\n            u = U0 * np.sin(kx * xx) * np.cos(ky * yy)\n            v = -U0 * (kx / ky) * np.cos(kx * xx) * np.sin(ky * yy)\n        elif m == 0 and n == 0:\n            u = U0 * np.ones((Ny, Nx))\n            v = np.zeros((Ny, Nx))\n        else:\n            # Other cases not specified in the problem\n            raise ValueError(f\"Velocity field for (m,n)=({m},{n}) not defined.\")\n\n        # Compute convective term\n        Rx, Ry = compute_convection(u, v, dx, dy, scheme)\n        \n        # Compute diagnostics\n        rh, deltah, dh = compute_diagnostics(u, v, Rx, Ry, dx, dy, dt)\n        results.append([rh, deltah, dh])\n\n    # Format output\n    output_str = '[' + ','.join([f\"[{r},{d},{div}]\" for r, d, div in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3297733"}, {"introduction": "实际的CFD模拟通常需要超越单个处理器计算能力的资源，这使得并行计算成为必需。高效地并行化有限体积代码的关键在于理解并最小化处理器之间的通信开销。此问题聚焦于并行求解器的设计，特别是“晕环”（halo）或“鬼影单元”（ghost cell）区域的数据交换。通过推导二阶格式所需的最小数据量，您将深入了解在高性能科学计算中，通信量与本地计算之间的基本权衡。[@problem_id:3297763]", "problem": "考虑一个可压缩守恒律系统，其状态向量为 $\\mathbf{U} \\in \\mathbb{R}^{m}$，定义在 $\\mathbb{R}^{D}$ 的有界域上，并采用以单元为中心的非结构有限体积法进行离散化。对于体积为 $|C_{i}|$ 的控制体 $C_{i}$，其半离散更新通过对守恒律应用散度定理，并使用一个在每个面上取左右极限值的数值通量函数来近似面通量而得到。每个处理器持有一个不相交的单元子集，网格被划分到各个处理器上，任何相邻单元位于不同处理器上的面都称为分区界面。用 $N_{\\Gamma}$ 表示与给定处理器相邻的分区界面的数量。\n\n在质心为 $\\mathbf{x}_{f}$ 的面上的面数值通量需要左右两边的面状态 $\\mathbf{U}_{L,f}$ 和 $\\mathbf{U}_{R,f}$，这些状态是通过对相邻单元平均值进行线性二阶重构得到的，并使用斜率限制器，该限制器对给定单元的评估仅依赖于该单元及其面相邻的一环邻居集。具体来说，对于质心为 $\\mathbf{x}_{i}$、平均值为 $\\overline{\\mathbf{U}}_{i}$ 的单元 $i$，重构形式为 $\\mathbf{U}(\\mathbf{x}) \\approx \\overline{\\mathbf{U}}_{i} + \\nabla \\mathbf{U}_{i} \\cdot (\\mathbf{x} - \\mathbf{x}_{i})$，其中 $\\nabla \\mathbf{U}_{i} \\in \\mathbb{R}^{m \\times D}$ 是一个限制后的梯度，通过对一环邻居集进行最小二乘拟合得到。假设在处理器上的每个面 $f$（包括分区界面）上的数值通量都需要 $\\mathbf{U}_{L,f}$ 和 $\\mathbf{U}_{R,f}$。\n\n晕轮交换（也称鬼影交换）将数据从相邻处理器传送过来，以填充反映处理器外单元的鬼影单元。深度为 $d$ 的鬼影层包含与处理器子域相邻的 $d$ 环处理器外单元。处理器可以选择：\n- 使用接收到的足够深度的鬼影层，在本地计算处理器外（鬼影）单元的重构，或者\n- 从邻居处接收已经限制过的处理器外单元的梯度，以避免更深的鬼影层。\n\n从积分形式的有限体积公式以及二阶重构及其数据依赖性的定义出发，推导所需的最小鬼影层深度 $d_{\\min}$，使得处理器能够在其拥有的面上以二阶精度计算其所有面通量，而无需在单个时间步内执行任何迭代或多阶段通信。在最小化鬼影层深度的策略下，同时推导一个处理器为执行其所有面通量计算而必须在每个时间步接收的标量值总数 $E$ 的闭式表达式，用 $m$、$D$ 和 $N_{\\Gamma}$ 表示。假设每个标量是单个实数，并且每个分区界面都恰好对应于该界面另一侧的一个不同的处理器外相邻单元。\n\n将您的最终答案以行矩阵 $\\begin{pmatrix} E  d_{\\min} \\end{pmatrix}$ 的形式报告，其中 $E$ 是每个时间步接收的标量值总数，$d_{\\min}$ 是最小鬼影层深度（整数）。不需要为 $m$、$D$ 或 $N_{\\Gamma}$ 代入任何数值，也不需要进行舍入。", "solution": "问题陈述经过审视，被认为是有效的。它在科学上基于计算流体动力学和并行计算的原理，问题提法恰当、客观且内部一致。它描述了并行有限体积法的标准场景，并要求推导数据依赖性和通信成本，这是一个形式化且可解的问题。未发现任何缺陷。因此，我们可以进行完整解答。\n\n问题要求两个量：处理器计算其二阶通量所需的最小鬼影层深度 $d_{\\min}$，以及在实现此最小深度的策略下，每个时间步必须接收的标量值总数 $E$。\n\n让我们分析该数值格式的数据依赖性。给定处理器上单元 $C_i$ 的半离散有限体积更新需要在其所有面上计算数值通量。对于处理器子域内部的面，所有需要的数据都在本地可用。关键情况是分区界面，我们称之为 $f$，它将一个本地单元 $C_i$ 与一个处理器外单元 $C_j$ 分开。单元 $C_j$ 对我们的处理器来说是一个“鬼影单元”，属于晕轮的第一层，因为它是本地单元的直接面邻居。\n\n在面 $f$ 上的数值通量，表示为 $\\mathbf{F}(\\mathbf{U}_{L,f}, \\mathbf{U}_{R,f})$，依赖于在面质心 $\\mathbf{x}_f$ 处重构的左右状态。\n左状态 $\\mathbf{U}_{L,f}$ 是从本地单元 $C_i$ 重构的。二阶重构由下式给出：\n$$ \\mathbf{U}_{L,f} = \\mathbf{U}_i(\\mathbf{x}_f) = \\overline{\\mathbf{U}}_{i} + \\nabla \\mathbf{U}_{i} \\cdot (\\mathbf{x}_f - \\mathbf{x}_{i}) $$\n这里，$\\overline{\\mathbf{U}}_{i}$ 是 $C_i$ 中的单元平均状态向量，这是本地已知的。项 $\\nabla \\mathbf{U}_{i}$ 是单元 $C_i$ 中状态向量的限制梯度。问题指明，该梯度是通过对 $C_i$ 的一环面相邻邻居进行最小二乘拟合来计算的，并且随后的限制步骤也仅依赖于此一环邻域。由于 $C_i$ 在面 $f$ 处与分区边界相邻，其邻居之一是鬼影单元 $C_j$。因此，为了计算 $\\nabla \\mathbf{U}_{i}$，处理器必须能够访问鬼影单元 $C_j$ 的单元平均状态向量 $\\overline{\\mathbf{U}}_{j}$。这建立起了对第一环鬼影单元数据的依赖。\n\n右状态 $\\mathbf{U}_{R,f}$ 是从鬼影单元 $C_j$ 重构的：\n$$ \\mathbf{U}_{R,f} = \\mathbf{U}_j(\\mathbf{x}_f) = \\overline{\\mathbf{U}}_{j} + \\nabla \\mathbf{U}_{j} \\cdot (\\mathbf{x}_f - \\mathbf{x}_{j}) $$\n要评估此状态，我们的处理器需要访问鬼影单元的单元平均值 $\\overline{\\mathbf{U}}_{j}$ 和限制梯度 $\\nabla \\mathbf{U}_{j}$。问题提出了两种获取 $\\nabla \\mathbf{U}_{j}$ 的策略：\n\n1.  **在本地计算鬼影梯度：** 本地处理器自行计算 $\\nabla \\mathbf{U}_{j}$。为此，它需要访问 $C_j$ 的所有一环邻居的单元平均值。单元 $C_j$ 是第一层鬼影单元（本地单元 $C_i$ 的邻居）。它的邻居又包括 $C_i$（本地的）和相邻处理器上的其他单元。$C_j$ 的这些其他邻居是我们本地域的邻居的邻居，因此构成了第二层鬼影单元。要计算 $\\nabla \\mathbf{U}_{j}$，我们需要接收这些第二层鬼影单元的单元平均值。因此，该策略需要 $d=2$ 的鬼影层深度。\n\n2.  **接收预先计算的鬼影梯度：** 拥有单元 $C_j$ 的相邻处理器计算自己的限制梯度 $\\nabla \\mathbf{U}_{j}$，并将其与单元平均值 $\\overline{\\mathbf{U}}_{j}$ 一同发送给我们的处理器。在这种情况下，要计算 $\\mathbf{U}_{R,f}$，我们的处理器只需要接收与第一层鬼影单元 $C_j$ 相关的数据。如前所述，要计算 $\\mathbf{U}_{L,f}$，我们也只需要来自第一层鬼影单元的数据（具体来说是 $\\overline{\\mathbf{U}}_{j}$）。因此，所有通量计算都可以通过仅接收与第一环鬼影单元有关的数据来完成。这对应于 $d=1$ 的鬼影层深度。\n\n为了找到最小鬼影层深度 $d_{\\min}$，我们比较这两种策略。策略2需要 $d=1$，而策略1需要 $d=2$。这两者中的最小值是1。\n$$ d_{\\min} = 1 $$\n\n接下来，我们在最小深度策略（策略2）下，推导每个时间步接收的标量值总数 $E$。\n问题陈述中有 $N_{\\Gamma}$ 个分区界面。假设“每个分区界面都恰好对应于一个不同的处理器外相邻单元”，这意味着处理器的子域恰好与 $N_{\\Gamma}$ 个唯一的鬼影单元相邻，这些鬼影单元构成了第一层晕轮。\n\n在最小深度策略下，对于这 $N_{\\Gamma}$ 个鬼影单元中的每一个（我们用索引 $j$ 表示它们），处理器必须接收其所有计算所需的数据。如上所述，这包括：\na) 需要单元平均值 $\\overline{\\mathbf{U}}_{j}$ 来计算与边界相邻的所有本地单元 $i$ 的梯度 $\\nabla \\mathbf{U}_{i}$。\nb) 需要单元平均值 $\\overline{\\mathbf{U}}_{j}$ 和预先计算的限制梯度 $\\nabla \\mathbf{U}_{j}$ 来评估界面上的重构状态 $\\mathbf{U}_{R,f}$。\n\n因此，对于 $N_{\\Gamma}$ 个鬼影单元中的每一个，处理器必须接收数据对 $(\\overline{\\mathbf{U}}_{j}, \\nabla \\mathbf{U}_{j})$。让我们计算一下这代表了多少个标量。\n- 状态向量 $\\mathbf{U}$ 是 $\\mathbb{R}^{m}$ 的一个元素，因此单元平均值 $\\overline{\\mathbf{U}}_{j}$ 由 $m$ 个标量值组成。\n- 梯度 $\\nabla \\mathbf{U}_{j}$ 是 $\\mathbb{R}^{m \\times D}$ 中的一个矩阵（对于 $m$ 个状态变量中的每一个，都有一个在 $\\mathbb{R}^D$ 中的梯度向量）。这由 $m \\times D$ 个标量值组成。\n\n为单个鬼影单元接收的标量总数为 $m + mD = m(1+D)$。\n由于有 $N_{\\Gamma}$ 个这样的唯一鬼影单元，处理器在每个时间步必须接收的标量总数 $E$ 为：\n$$ E = N_{\\Gamma} \\times m(1+D) $$\n这个表达式表示在最小化鬼影层深度的最优策略下，晕轮交换的总通信量。\n\n问题要求以行矩阵 $\\begin{pmatrix} E  d_{\\min} \\end{pmatrix}$ 的形式给出最终答案。代入我们推导出的表达式，我们得到最终结果。", "answer": "$$\\boxed{\\begin{pmatrix} N_{\\Gamma} m (1+D) & 1 \\end{pmatrix}}$$", "id": "3297763"}]}