{"hands_on_practices": [{"introduction": "本次练习将引导你完成格林-高斯公式的一次基础、分步应用。通过处理一个简单的三维四面体单元，我们将直观地看到抽象的散度定理如何转化为具体的数值算法，并验证其对于线性场的精确性。[@problem_id:3325620]", "problem": "在计算流体力学 (CFD) 中，有限体积法 (FVM) 通常使用格林-高斯方法重构梯度。从散度定理和 FVM 的基本概念出发，推导一个依赖于面心标量值、面面积矢量和单元体积的显式、基于单元的梯度估计器。然后，为下面的四面体控制体和标量场计算此估计器的值。\n\n考虑一个三维空间中的四面体控制体，其顶点位于 $\\,\\mathbf{v}_{0}=(0,0,0)\\,$、$\\,\\mathbf{v}_{1}=(1,0,0)\\,$、$\\,\\mathbf{v}_{2}=(0,1,0)\\,$ 和 $\\,\\mathbf{v}_{3}=(0,0,1)\\,$。设标量场为 $\\,\\phi(\\mathbf{x})=2x-3y+4z+1\\,$。为该四面体的每个面计算：\n- 指向外部的面面积矢量 $\\,\\mathbf{S}_{f}\\,$，\n- 面心 $\\,\\mathbf{x}_{f}\\,$，\n\n然后，仅使用面心值 $\\,\\phi(\\mathbf{x}_{f})\\,$ 和向外的面面积矢量 $\\,\\mathbf{S}_{f}\\,$，计算此单元的格林-高斯梯度估计值。\n\n您的最终答案必须是以单个行矩阵 $\\,\\big[\\partial \\phi/\\partial x,\\ \\partial \\phi/\\partial y,\\ \\partial \\phi/\\partial z\\big]\\,$ 表示的梯度矢量，值为精确值。无需四舍五入。不包含单位。", "solution": "本题要求推导基于单元的格林-高斯梯度估计器，并将其应用于具有线性标量场的特定四面体控制体。\n\n首先，我们推导通用公式。推导从标量场 $\\phi$ 梯度的散度定理的一个变体开始：\n$$ \\int_V \\nabla \\phi \\, dV = \\oint_{\\partial V} \\phi \\, d\\mathbf{S} $$\n其中 $V$ 是一个控制体，$\\partial V$ 是其边界面。$d\\mathbf{S}$ 是面积微元矢量，定义为 $\\mathbf{n} dS$，其中 $\\mathbf{n}$ 是向外的单位法向量。\n\n在有限体积法 (FVM) 的背景下，我们将此定理应用于单个多面体单元（控制体），记为 $P$，其体积为 $V_P$。积分方程变为：\n$$ \\int_{V_P} \\nabla \\phi \\, dV = \\oint_{\\partial V_P} \\phi \\, d\\mathbf{S} $$\n为了获得代数近似，我们做出两个关键假设：\n1. 梯度 $\\nabla \\phi$ 假定在整个单元 $P$ 内是恒定的。我们将此单元平均梯度记为 $(\\nabla \\phi)_P$。这使我们可以将左侧写为：\n$$ \\int_{V_P} \\nabla \\phi \\, dV \\approx (\\nabla \\phi)_P \\int_{V_P} dV = (\\nabla \\phi)_P V_P $$\n2. 单元 $\\partial V_P$ 的边界由有限数量的平面组成，以 $f$ 为索引。面积分可以写成在这些面上的积分之和：\n$$ \\oint_{\\partial V_P} \\phi \\, d\\mathbf{S} = \\sum_f \\int_{S_f} \\phi \\, d\\mathbf{S} $$\n对于每个面积分，我们假定标量值 $\\phi$ 在面 $S_f$ 上是恒定的，并等于其在面心的值，即 $\\phi_f = \\phi(\\mathbf{x}_f)$。此近似给出：\n$$ \\int_{S_f} \\phi \\, d\\mathbf{S} \\approx \\phi_f \\int_{S_f} d\\mathbf{S} = \\phi_f \\mathbf{S}_f $$\n其中 $\\mathbf{S}_f = \\int_{S_f} d\\mathbf{S}$ 是面 $f$ 的面积矢量。\n\n结合这些近似，我们有：\n$$ (\\nabla \\phi)_P V_P \\approx \\sum_f \\phi_f \\mathbf{S}_f $$\n求解单元梯度 $(\\nabla \\phi)_P$ 可得到格林-高斯梯度估计器：\n$$ (\\nabla \\phi)_P = \\frac{1}{V_P} \\sum_f \\phi_f \\mathbf{S}_f $$\n该公式提供了单元内梯度的显式估计，该估计基于单元体积 $V_P$、面心标量值 $\\phi_f$ 和面面积矢量 $\\mathbf{S}_f$。\n\n接下来，我们将此公式应用于给定的顶点为 $\\mathbf{v}_{0}=(0,0,0)$、$\\mathbf{v}_{1}=(1,0,0)$、$\\mathbf{v}_{2}=(0,1,0)$ 和 $\\mathbf{v}_{3}=(0,0,1)$ 的四面体。标量场为 $\\phi(\\mathbf{x}) = \\phi(x,y,z) = 2x-3y+4z+1$。\n\n1.  **单元体积 ($V_P$)**：一个顶点在原点，其他顶点在 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ 的四面体的体积由 $V_P = \\frac{1}{6}|(\\mathbf{v}_1 \\times \\mathbf{v}_2) \\cdot \\mathbf{v}_3|$ 给出。\n    $$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = (1,0,0) \\times (0,1,0) = (0,0,1) $$\n    $$ (\\mathbf{v}_1 \\times \\mathbf{v}_2) \\cdot \\mathbf{v}_3 = (0,0,1) \\cdot (0,0,1) = 1 $$\n    因此，体积为 $V_P = \\frac{1}{6}$。\n\n2.  **面属性**：该四面体有四个面。对每个面 $f$，我们计算其面心 $\\mathbf{x}_f$ 和其向外的面积矢量 $\\mathbf{S}_f$。一个顶点为 $A, B, C$ 的三角形面的面积矢量为 $\\mathbf{S}_f = \\frac{1}{2}\\left( (B-A) \\times (C-A) \\right)$，选择顶点的顺序以确保矢量指向外侧。\n\n    - **面 $f_1$ (顶点为 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$)**：\n      - 面心：$\\mathbf{x}_{f_1} = \\frac{1}{3}(\\mathbf{v}_1+\\mathbf{v}_2+\\mathbf{v}_3) = \\frac{1}{3}(1,1,1) = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$。\n      - 面积矢量：$\\mathbf{S}_{f_1} = \\frac{1}{2}((\\mathbf{v}_2-\\mathbf{v}_1) \\times (\\mathbf{v}_3-\\mathbf{v}_1)) = \\frac{1}{2}((-1,1,0) \\times (-1,0,1)) = \\frac{1}{2}(1,1,1)$。此矢量指向远离原点（顶点 $\\mathbf{v}_0$）的方向，因此是向外的。\n      - 标量值：$\\phi_{f_1} = \\phi(\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}) = 2(\\frac{1}{3}) - 3(\\frac{1}{3}) + 4(\\frac{1}{3}) + 1 = \\frac{3}{3} + 1 = 2$。\n\n    - **面 $f_2$ (顶点为 $\\mathbf{v}_0, \\mathbf{v}_3, \\mathbf{v}_2$)**：此面位于 $x=0$ 平面上。\n      - 面心：$\\mathbf{x}_{f_2} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_3+\\mathbf{v}_2) = \\frac{1}{3}(0,1,1) = (0, \\frac{1}{3}, \\frac{1}{3})$。\n      - 面积矢量：$\\mathbf{S}_{f_2} = \\frac{1}{2}((\\mathbf{v}_3-\\mathbf{v}_0) \\times (\\mathbf{v}_2-\\mathbf{v}_0)) = \\frac{1}{2}((0,0,1) \\times (0,1,0)) = \\frac{1}{2}(-1,0,0)$。此矢量指向负 $x$ 方向，远离四面体内部。\n      - 标量值：$\\phi_{f_2} = \\phi(0, \\frac{1}{3}, \\frac{1}{3}) = 2(0) - 3(\\frac{1}{3}) + 4(\\frac{1}{3}) + 1 = \\frac{1}{3} + 1 = \\frac{4}{3}$。\n\n    - **面 $f_3$ (顶点为 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_3$)**：此面位于 $y=0$ 平面上。\n      - 面心：$\\mathbf{x}_{f_3} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_1+\\mathbf{v}_3) = \\frac{1}{3}(1,0,1) = (\\frac{1}{3}, 0, \\frac{1}{3})$。\n      - 面积矢量：$\\mathbf{S}_{f_3} = \\frac{1}{2}((\\mathbf{v}_1-\\mathbf{v}_0) \\times (\\mathbf{v}_3-\\mathbf{v}_0)) = \\frac{1}{2}((1,0,0) \\times (0,0,1)) = \\frac{1}{2}(0,-1,0)$。此矢量指向负 $y$ 方向，远离内部。\n      - 标量值：$\\phi_{f_3} = \\phi(\\frac{1}{3}, 0, \\frac{1}{3}) = 2(\\frac{1}{3}) - 3(0) + 4(\\frac{1}{3}) + 1 = \\frac{6}{3} + 1 = 3$。\n\n    - **面 $f_4$ (顶点为 $\\mathbf{v}_0, \\mathbf{v}_2, \\mathbf{v}_1$)**：此面位于 $z=0$ 平面上。\n      - 面心：$\\mathbf{x}_{f_4} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_2+\\mathbf{v}_1) = \\frac{1}{3}(1,1,0) = (\\frac{1}{3}, \\frac{1}{3}, 0)$。\n      - 面积矢量：$\\mathbf{S}_{f_4} = \\frac{1}{2}((\\mathbf{v}_2-\\mathbf{v}_0) \\times (\\mathbf{v}_1-\\mathbf{v}_0)) = \\frac{1}{2}((0,1,0) \\times (1,0,0)) = \\frac{1}{2}(0,0,-1)$。此矢量指向负 $z$ 方向，远离内部。\n      - 标量值：$\\phi_{f_4} = \\phi(\\frac{1}{3}, \\frac{1}{3}, 0) = 2(\\frac{1}{3}) - 3(\\frac{1}{3}) + 4(0) + 1 = -\\frac{1}{3} + 1 = \\frac{2}{3}$。\n\n3.  **求和**：我们现在计算和 $\\sum_f \\phi_f \\mathbf{S}_f$。\n    $$ \\phi_{f_1}\\mathbf{S}_{f_1} = 2 \\cdot (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}) = (1, 1, 1) $$\n    $$ \\phi_{f_2}\\mathbf{S}_{f_2} = \\frac{4}{3} \\cdot (-\\frac{1}{2}, 0, 0) = (-\\frac{2}{3}, 0, 0) $$\n    $$ \\phi_{f_3}\\mathbf{S}_{f_3} = 3 \\cdot (0, -\\frac{1}{2}, 0) = (0, -\\frac{3}{2}, 0) $$\n    $$ \\phi_{f_4}\\mathbf{S}_{f_4} = \\frac{2}{3} \\cdot (0, 0, -\\frac{1}{2}) = (0, 0, -\\frac{1}{3}) $$\n\n    和为：\n    $$ \\sum_f \\phi_f \\mathbf{S}_f = (1 - \\frac{2}{3}, \\quad 1 - \\frac{3}{2}, \\quad 1 - \\frac{1}{3}) = (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) $$\n\n4.  **梯度计算**：最后，我们计算梯度估计值。\n    $$ (\\nabla \\phi)_P = \\frac{1}{V_P} \\sum_f \\phi_f \\mathbf{S}_f = \\frac{1}{1/6} (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) $$\n    $$ (\\nabla \\phi)_P = 6 \\cdot (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) = (2, -3, 4) $$\n\n估计的梯度是 $(2, -3, 4)$。\n线性标量场 $\\phi(\\mathbf{x}) = 2x-3y+4z+1$ 的解析梯度是 $\\nabla \\phi = (\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y}, \\frac{\\partial \\phi}{\\partial z}) = (2, -3, 4)$。正如预期的那样，格林-高斯方法精确地重现了线性场的梯度，因为构成截断误差的泰勒级数展开中的高阶项为零。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  -3  4\n\\end{pmatrix}\n}\n$$", "id": "3325620"}, {"introduction": "格林-高斯方法依赖于封闭控制体的一个关键几何特性：所有外向面面积矢量之和必须为零。本练习旨在探究当这个“闭合”条件被违反时的后果，这种情况在网格生成错误中很常见。这是一个关键的实践，它揭示了即使在最简单的均匀场情况下，几何不一致性也会如何导致非物理性的计算误差。[@problem_id:3325687]", "problem": "考虑一个用于计算流体力学的有限体积法的六面体控制体，具体来说是一个边长为 $L$ 的立方体，其中心位于原点，各个面位于 $x=\\pm L/2$、$y=\\pm L/2$ 和 $z=\\pm L/2$。令每个面的面积矢量定义为 $\\mathbf{S}_f = \\mathbf{n}_f A_f$，其中 $\\mathbf{n}_f$ 是面单位法向量，$A_f$ 是面面积。在正确定向的网格中，对于任何封闭控制体，外法线满足 $\\sum_f \\mathbf{S}_f = \\mathbf{0}$。\n\n假设由于网格预处理中的一个错误，一个面的法线方向不正确：位于 $x=-L/2$ 的面被赋予了法向量 $\\mathbf{n} = +\\hat{\\mathbf{i}}$，而不是正确的 $\\mathbf{n} = -\\hat{\\mathbf{i}}$。所有其他面的法线都是正确的，且指向外部。所有面的面积均为 $A_f = L^2$，控制体的体积为 $V = L^3$。\n\n一个常数标量场 $\\phi(\\mathbf{x}) \\equiv \\phi_0$ 在此控制体上进行采样。从散度定理和标准的连续介质定义出发，推导控制体上基于面面积矢量和面值的离散格林-高斯梯度重构表达式，然后将其应用于这个具有不正确面法线的特定单元，以获得单元内部的重构梯度。\n\n定义无量纲误差\n$$\ne \\equiv \\frac{\\left\\|\\left.\\nabla \\phi\\right|_{\\text{rec}}\\right\\|\\,L}{|\\phi_0|},\n$$\n其中 $\\left.\\nabla \\phi\\right|_{\\text{rec}}$ 是控制体内部的重构梯度，$\\|\\cdot\\|$ 表示欧几里得范数。计算所述配置下的 $e$ 值。请用一个纯数（无量纲）表示您的最终答案。不要包含任何单位。无需四舍五入。", "solution": "本题要求计算在一个具有一个错误定向面法线的立方体控制体内，对一个常数标量场进行格林-高斯梯度重构时产生的无量纲误差。\n\n首先，我们推导格林-高斯梯度重构的一般公式。其基础是散度定理的一个推论，通常称为梯度定理，该定理指出，对于一个标量场 $\\phi$ 和一个由表面 $S$ 包围的控制体 $V$：\n$$ \\int_V \\nabla \\phi \\, dV = \\oint_S \\phi \\, \\mathbf{n} \\, dS $$\n其中 $\\mathbf{n}$ 是表面 $S$ 上的局部向外单位法向量。\n\n在有限体积法中，我们近似控制体内的平均梯度。平均梯度定义为：\n$$ \\left.\\nabla \\phi\\right|_{\\text{avg}} = \\frac{1}{V} \\int_V \\nabla \\phi \\, dV $$\n代入梯度定理，我们得到：\n$$ \\left.\\nabla \\phi\\right|_{\\text{avg}} = \\frac{1}{V} \\oint_S \\phi \\, \\mathbf{n} \\, dS $$\n为了获得离散的数值格式，连续的面积分被替换为对构成控制体边界的离散面 $f$ 的求和：\n$$ \\oint_S \\phi \\, \\mathbf{n} \\, dS = \\sum_{f} \\int_{S_f} \\phi \\, \\mathbf{n} \\, dS $$\n通过假设标量场 $\\phi$ 在每个面 $S_f$ 上具有一个常数值 $\\phi_f$（通常取面心的值），可以对每个面上的积分进行近似。这使我们可以写出：\n$$ \\int_{S_f} \\phi \\, \\mathbf{n} \\, dS \\approx \\phi_f \\int_{S_f} \\mathbf{n} \\, dS $$\n单位法向量在面区域上的积分即为面面积矢量，$\\mathbf{S}_f = A_f \\mathbf{n}_f$，其中 $A_f$ 是面 $f$ 的面积，$\\mathbf{n}_f$ 是其单位法向量。\n将其代回，控制体中梯度的离散近似，记作 $\\left.\\nabla \\phi\\right|_{\\text{rec}}$，为：\n$$ \\left.\\nabla \\phi\\right|_{\\text{rec}} = \\frac{1}{V} \\sum_{f} \\phi_f \\mathbf{S}_f $$\n这就是格林-高斯梯度重构公式。\n\n现在，我们将此公式应用于具体问题。给定标量场为常数，$\\phi(\\mathbf{x}) \\equiv \\phi_0$。这意味着场在任何点（包括所有面心）的值都就是 $\\phi_0$。因此，对于所有面 $f$，我们有 $\\phi_f = \\phi_0$。该公式简化为：\n$$ \\left.\\nabla \\phi\\right|_{\\text{rec}} = \\frac{1}{V} \\sum_{f} \\phi_0 \\mathbf{S}_f = \\frac{\\phi_0}{V} \\sum_{f} \\mathbf{S}_f $$\n问题简化为计算给定立方体的面面积矢量之和 $\\sum_f \\mathbf{S}_f$。该立方体边长为 $L$，以原点为中心。其体积为 $V = L^3$，每个面的面积为 $A_f = L^2$。\n\n我们来列出立方体六个面的面积矢量，并特别注意题目中提到的错误。我们使用标准的笛卡尔坐标系，其单位向量为 $\\hat{\\mathbf{i}}$、$\\hat{\\mathbf{j}}$ 和 $\\hat{\\mathbf{k}}$。\n\n1.  位于 $x=L/2$ 的面：正确的向外法向量为 $\\mathbf{n} = \\hat{\\mathbf{i}}$。其面积矢量为 $\\mathbf{S}_{x+} = A_f \\hat{\\mathbf{i}} = L^2 \\hat{\\mathbf{i}}$。\n2.  位于 $x=-L/2$ 的面：正确的向外法向量应为 $\\mathbf{n} = -\\hat{\\mathbf{i}}$。然而，由于错误，它被赋予的法向量是 $\\mathbf{n} = \\hat{\\mathbf{i}}$。其面积矢量为 $\\mathbf{S}_{x-} = A_f \\hat{\\mathbf{i}} = L^2 \\hat{\\mathbf{i}}$。\n3.  位于 $y=L/2$ 的面：正确的向外法向量为 $\\mathbf{n} = \\hat{\\mathbf{j}}$。其面积矢量为 $\\mathbf{S}_{y+} = A_f \\hat{\\mathbf{j}} = L^2 \\hat{\\mathbf{j}}$。\n4.  位于 $y=-L/2$ 的面：正确的向外法向量为 $\\mathbf{n} = -\\hat{\\mathbf{j}}$。其面积矢量为 $\\mathbf{S}_{y-} = -A_f \\hat{\\mathbf{j}} = -L^2 \\hat{\\mathbf{j}}$。\n5.  位于 $z=L/2$ 的面：正确的向外法向量为 $\\mathbf{n} = \\hat{\\mathbf{k}}$。其面积矢量为 $\\mathbf{S}_{z+} = A_f \\hat{\\mathbf{k}} = L^2 \\hat{\\mathbf{k}}$。\n6.  位于 $z=-L/2$ 的面：正确的向外法向量为 $\\mathbf{n} = -\\hat{\\mathbf{k}}$。其面积矢量为 $\\mathbf{S}_{z-} = -A_f \\hat{\\mathbf{k}} = -L^2 \\hat{\\mathbf{k}}$。\n\n这些矢量的和为：\n$$ \\sum_{f} \\mathbf{S}_f = \\mathbf{S}_{x+} + \\mathbf{S}_{x-} + \\mathbf{S}_{y+} + \\mathbf{S}_{y-} + \\mathbf{S}_{z+} + \\mathbf{S}_{z-} $$\n$$ \\sum_{f} \\mathbf{S}_f = (L^2 \\hat{\\mathbf{i}} + L^2 \\hat{\\mathbf{i}}) + (L^2 \\hat{\\mathbf{j}} - L^2 \\hat{\\mathbf{j}}) + (L^2 \\hat{\\mathbf{k}} - L^2 \\hat{\\mathbf{k}}) $$\n$$ \\sum_{f} \\mathbf{S}_f = 2L^2 \\hat{\\mathbf{i}} + \\mathbf{0} + \\mathbf{0} = 2L^2 \\hat{\\mathbf{i}} $$\n对于一个正确定向的封闭体积，这个和应为 $\\mathbf{0}$。非零结果完全是由网格错误造成的。\n\n现在，我们可以计算重构梯度：\n$$ \\left.\\nabla \\phi\\right|_{\\text{rec}} = \\frac{\\phi_0}{V} \\sum_{f} \\mathbf{S}_f = \\frac{\\phi_0}{L^3} (2L^2 \\hat{\\mathbf{i}}) = \\frac{2\\phi_0}{L} \\hat{\\mathbf{i}} $$\n从解析上讲，常数场的梯度为零（$\\nabla\\phi_0 = \\mathbf{0}$）。由于几何上的不一致性，数值格式产生了一个非零的梯度。\n\n最后，我们计算无量纲误差 $e$，其定义为：\n$$ e \\equiv \\frac{\\left\\|\\left.\\nabla \\phi\\right|_{\\text{rec}}\\right\\|\\,L}{|\\phi_0|} $$\n重构梯度的欧几里得范数为：\n$$ \\left\\|\\left.\\nabla \\phi\\right|_{\\text{rec}}\\right\\| = \\left\\| \\frac{2\\phi_0}{L} \\hat{\\mathbf{i}} \\right\\| = \\left| \\frac{2\\phi_0}{L} \\right| = \\frac{2|\\phi_0|}{L} $$\n将此范数代入 $e$ 的表达式中：\n$$ e = \\frac{\\left(\\frac{2|\\phi_0|}{L}\\right)L}{|\\phi_0|} = \\frac{2|\\phi_0|}{|\\phi_0|} $$\n假设 $\\phi_0 \\neq 0$，我们得到：\n$$ e = 2 $$\n这个无量纲值量化了由单个不正确的面法线引入的梯度计算误差。", "answer": "$$\n\\boxed{2}\n$$", "id": "3325687"}, {"introduction": "除了基本公式外，实际应用中存在多种近似单元面（或边）上物理量值的方法，从而衍生出不同的格林-高斯格式。这个编程练习旨在比较常见的“基于单元中心”方法与更为稳健的“基于节点”方法的精度。通过亲手实现这两种方法并在不同类型的网格上进行测试，你将获得关于网格质量如何影响计算精度，以及为何在复杂非结构网格中通常首选基于节点方法的实践性见解。[@problem_id:3325671]", "problem": "考虑一种二维多边形控制体离散化方法，其中梯度重构依赖于散度定理（也称为 Gauss–Ostrogradsky 定理）。在此背景下，Green–Gauss (GG) 梯度重构是该定理的一个应用，即对于一个足够光滑的标量场 $\\phi$，$\\nabla \\phi$ 在某个单元上的面积分等于 $\\phi$ 在该单元边界上由外向单位法向量加权的线积分。目标是在三角网格上比较两种 GG 策略：一种是使用顶点值的基于节点的格式，另一种是使用单元中心值的基于单元的格式。此比较将在解析定义的场上进行，其中三角函数中的所有角度都应解释为弧度。\n\n您必须使用通过对指定点集进行 Delaunay 三角剖分获得的三角网格，在二维中实现这两种重构方法。基于单元的策略仅使用三角形自身及其直接相邻单元的中心值 $\\phi_c$ 来重构该三角形上的 $\\nabla \\phi$。基于节点的策略仅使用三角形三个顶点上的顶点值 $\\phi_v$ 来重构该三角形上的 $\\nabla \\phi$。两种重构都必须基于第一性原理：从散度定理所蕴含的积分恒等式出发，通过使用边的外向法向量和边长的边贡献来近似边界积分。您不得使用任何跳过此推导路径的公式，也不得假设任何未经该定理证明的修正项。\n\n为了进行客观的精度比较，设 $\\phi(x,y) = \\sin(2x) + 0.5 \\cos(3y) + x y$，其梯度为 $\\nabla \\phi(x,y) = \\left(2\\cos(2x) + y,\\,-1.5 \\sin(3y) + x\\right)$。在三角形顶点处计算 $\\phi$ 以定义 $\\phi_v$，在三角形质心处计算 $\\phi$ 以定义 $\\phi_c$。对于每个三角形，使用两种策略近似计算 $\\nabla \\phi$，并与三角形质心处的精确梯度进行比较。计算每个三角形的误差向量的欧几里得范数。为避免边界条件的复杂性，误差统计中只包括所有三条边都有相邻单元的三角形。\n\n设计您的程序以生成具有不同连通性和畸变特性的四个网格，以探究基于节点的 GG 在何种情况下能比基于单元的 GG 提高精度。使用以下的点云生成器测试套件，每个生成器都使用确定性种子：\n\n1. 结构化格网：在 $[0,1]\\times[0,1]$ 上的均匀矩形网格，其中 $n_x=25$ 且 $n_y=20$，无扰动。\n2. 倾斜网格：从相同的格网开始，然后在三角剖分前对每个格网点在两个坐标方向上添加幅度为 $\\varepsilon=0.08$ 的独立均匀扰动。\n3. 各向异性拉伸网格：从均匀格网开始，然后通过 $(x,y)\\mapsto(x,\\,0.2\\,y)$ 映射点，并添加幅度为 $\\varepsilon=0.04$ 的小扰动。\n4. 聚集的非结构化点集：将均匀格网与在以 $(0.5,0.5)$ 为中心、半径为 $0.3$ 的圆盘内均匀采样的额外点相结合；使用 $400$ 个额外点。\n\n对于每个网格，运行两种重构方法并计算所有内部三角形的平均误差。对于每个网格，确定基于节点的 GG 平均误差是否严格小于基于单元的 GG 平均误差。每个测试用例要输出的主要量是一个布尔值，指示基于节点的 GG 是否更准确。\n\n需要识别的网格连通性条件是，在这些条件下，基于节点的 Green–Gauss 方法相对于基于单元的 Green–Gauss 方法能提高精度。作为算法推理的一部分，请在内部计算连通性和对齐性的诊断信息（无需打印）：边的外向法向量与单元中心到相邻单元中心方向之间的平均非正交角，以及顶点价的分布。利用这些信息来证明基于节点的重构在何种情况下受益于网格连通性。\n\n您的程序应生成一行输出，其中包含与四个测试用例相对应的四个布尔值，格式为方括号内以逗号分隔的列表（例如，“[true,false,true,false]”）。所有三角函数的角度都必须解释为弧度。不涉及任何物理单位；报告纯数值结果。最终的布尔值是唯一需要的输出。", "solution": "该问题要求在二维三角网格上比较两种不同的 Green-Gauss (GG) 梯度重构策略：一种是基于单元的格式，另一种是基于节点的格式。比较必须是定量的，基于重构已知解析标量场梯度的精度。整个过程基于散度定理的基本原理。\n\n### 理论基础：Green-Gauss 方法\n\n在二维空间中，散度定理指出，对于一个足够光滑的向量场 $\\mathbf{F}$，其在一个面积 $A$ 上的散度积分等于该场在边界 $\\partial A$ 上的法向分量的线积分。\n$$\n\\iint_A (\\nabla \\cdot \\mathbf{F}) \\, dA = \\oint_{\\partial A} \\mathbf{F} \\cdot \\mathbf{n} \\, ds\n$$\n其中 $\\mathbf{n}$ 是指向边界外部的单位法向量。通过将向量场 $\\mathbf{F}$ 设置为标量场 $\\phi$ 的梯度，即 $\\mathbf{F} = \\nabla \\phi$，可以推导出该定理的一种不太常见的形式（格林恒等式之一），通常称为梯度定理。为实现我们的目的，我们将散度定理分别应用于向量场 $\\mathbf{F}_x = (\\phi, 0)$ 和 $\\mathbf{F}_y = (0, \\phi)$。\n$$\n\\iint_A \\frac{\\partial \\phi}{\\partial x} \\, dA = \\oint_{\\partial A} \\phi n_x \\, ds \\quad \\text{和} \\quad \\iint_A \\frac{\\partial \\phi}{\\partial y} \\, dA = \\oint_{\\partial A} \\phi n_y \\, ds\n$$\n将这些结合起来，得到一个关于梯度的向量恒等式，这是 Green-Gauss 方法的基础：\n$$\n\\iint_A \\nabla \\phi \\, dA = \\oint_{\\partial A} \\phi \\mathbf{n} \\, ds\n$$\n为了将此应用于离散的控制体（网格中的单元 $P$），我们假设梯度 $(\\nabla \\phi)_P$ 在整个单元上是恒定的。面积分于是简化为 $(\\nabla \\phi)_P A_P$，其中 $A_P$ 是单元的面积。这为平均梯度提供了一个精确关系式：\n$$\n(\\nabla \\phi)_P = \\frac{1}{A_P} \\oint_{\\partial A_P} \\phi \\mathbf{n} \\, ds\n$$\n线积分通过对单元的每个面（边）$f$ 的贡献求和来近似：\n$$\n\\oint_{\\partial A_P} \\phi \\mathbf{n} \\, ds \\approx \\sum_{f} \\int_f \\phi \\mathbf{n}_f \\, ds\n$$\n其中 $\\mathbf{n}_f$ 是面 $f$ 的外向单位法向量。我们进一步将每个面上的 $\\phi$ 值近似为一个常数 $\\phi_f$。这导出了在单元 $P$ 中梯度的最终离散化公式：\n$$\n(\\nabla \\phi)_P \\approx \\frac{1}{A_P} \\sum_f \\phi_f (\\mathbf{n}_f \\Delta s_f) = \\frac{1}{A_P} \\sum_f \\phi_f \\mathbf{S}_f\n$$\n此处，$\\Delta s_f$ 是面 $f$ 的长度，而 $\\mathbf{S}_f = \\mathbf{n}_f \\Delta s_f$ 是指向外部的面法向量，其大小为面的长度。待比较的两种格式仅在对面值 $\\phi_f$ 的近似上有所不同。\n\n### 基于单元的 Green-Gauss 重构\n\n在基于单元的方法中，标量场的值 $\\phi_c$ 在网格单元的质心处是已知的。对于分隔单元 $P$ 及其相邻单元 $N_f$ 的面 $f$，面值 $\\phi_f$ 通过在两个单元中心值之间进行线性插值来近似。最简单的插值是直接平均：\n$$\n\\phi_f \\approx \\frac{\\phi_P + \\phi_{N_f}}{2}\n$$\n将此代入通用公式，得到基于单元的梯度重构：\n$$\n(\\nabla \\phi)_P^{\\text{cell-based}} = \\frac{1}{A_P} \\sum_f \\left( \\frac{\\phi_P + \\phi_{N_f}}{2} \\right) \\mathbf{S}_f\n$$\n这种近似假设面值可以很好地由相邻单元中心值的平均值表示。当网格是正交的（连接质心 $\\mathbf{c}_P$ 和 $\\mathbf{c}_{N_f}$ 的向量与面法线 $\\mathbf{n}_f$ 平行）且规则时，这个假设的精度最高。随着网格偏斜度和非正交性的增加，精度会显著下降。\n\n### 基于节点的 Green-Gauss 重构\n\n在基于节点的方法中，标量场的值 $\\phi_v$ 在网格的顶点处是已知的。对于连接顶点 $v_1$ 和 $v_2$ 的面 $f$，面值 $\\phi_f$ 通过其端点值的平均值来近似：\n$$\n\\phi_f \\approx \\frac{\\phi_{v_1(f)} + \\phi_{v_2(f)}}{2}\n$$\n这种近似表示 $\\phi$ 在面中点处的值。得到的重构公式为：\n$$\n(\\nabla \\phi)_P^{\\text{node-based}} = \\frac{1}{A_P} \\sum_f \\left( \\frac{\\phi_{v_1(f)} + \\phi_{v_2(f)}}{2} \\right) \\mathbf{S}_f\n$$\n该方法使用的信息在几何上是面自身的局部信息，使其对单元质心相对位置的直接依赖性较低。因此，与基于单元的格式相比，它对网格的非正交性通常更具鲁棒性，并且通常被认为在更广泛的网格类别上具有形式上的二阶精度。\n\n### 算法实现与分析\n\n实现过程首先为四个测试用例中的每一个生成点云，并使用 `scipy.spatial.Delaunay` 进行 Delaunay 三角剖分。这提供了网格的连通性（单纯形和邻居）。一个必要的预处理步骤是确保所有三角形都有一个一致的顶点排序（例如，逆时针），以便无歧义地定义指向外部的法向量 $\\mathbf{S}_f$。这通过检查三角形面积的符号并在必要时重新排序顶点来实现。\n\n对于四个生成的网格中的每一个，都将执行以下步骤：\n1.  解析标量场 $\\phi(x,y) = \\sin(2x) + 0.5 \\cos(3y) + x y$ 在所有网格顶点处被求值以获得顶点值 $\\phi_v$，在所有三角形质心处被求值以获得单元中心值 $\\phi_c$。\n2.  算法遍历所有内部三角形，这些三角形被定义为在所有三条边上都有有效邻居的三角形。此限制避免了处理边界条件时的模糊性。\n3.  对于每个内部三角形，应用基于单元和基于节点的梯度重构公式来计算近似梯度向量。\n4.  在三角形的质心处计算精确梯度 $\\nabla \\phi(x,y) = (2\\cos(2x) + y, -1.5 \\sin(3y) + x)$。\n5.  每种格式的误差计算为近似梯度向量与精确梯度向量之差的欧几里得范数。\n6.  计算两种格式在所有内部三角形上的这些误差的平均值。\n7.  最后，记录一个布尔值，指示基于节点的格式的平均误差是否严格小于基于单元的格式的平均误差。\n\n### 网格特性分析\n\n这四个测试用例旨在探究这些方法在不同网格条件下的性能：\n-   **案例 1 (结构化格网)**：一个高质量、均匀的网格，具有较低的非正交性。预计两种方法都表现良好，基于节点的方法可能因其更高的形式精度阶而略有优势。\n-   **案例 2 (倾斜网格)**：随机扰动引入了显著的网格偏斜度和非正交性。基于单元的方法关于质心到质心插值的核心假设被违反，导致精度大幅下降。预计对这一点不太敏感的基于节点的方法会显著更准确。\n-   **案例 3 (各向异性拉伸网格)**：网格被拉伸，产生高纵横比的三角形。这测试了对几何各向异性的鲁棒性。虽然这对两种方法都具有挑战性，但基于节点的格式依赖于局部顶点数据，应比基于单元的格式依赖于可能距离较远且未对齐的质心更具鲁棒性。\n-   **案例 4 (聚集的非结构化点集)**：增加一个密集的点簇会创建一个高度不均匀的网格，单元尺寸、形状和顶点价都有很大变化。这种复杂的拓扑结构严重考验了基于单元格式的几何假设。在这种情况下，预计基于节点的重构会显著更准确。\n\n实现的结果将证实这些预期，表明基于节点的 Green-Gauss 重构通常更准确，尤其是在偏离规则性和正交性的网格上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Implements and compares cell-based and node-based Green-Gauss gradient\n    reconstructions on four different mesh types.\n    \"\"\"\n\n    # Define the analytical scalar field and its exact gradient.\n    # All trigonometric function arguments are in radians.\n    def phi_func(p):\n        x, y = p[:, 0], p[:, 1]\n        return np.sin(2 * x) + 0.5 * np.cos(3 * y) + x * y\n\n    def grad_phi_func(p):\n        x, y = p[:, 0], p[:, 1]\n        grad_x = 2 * np.cos(2 * x) + y\n        grad_y = -1.5 * np.sin(3 * y) + x\n        return np.stack([grad_x, grad_y], axis=1)\n\n    def generate_points(case_id, seed):\n        \"\"\"Generates point clouds for the four test cases.\"\"\"\n        rng = np.random.default_rng(seed)\n        nx, ny = 25, 20\n        x = np.linspace(0, 1, nx)\n        y = np.linspace(0, 1, ny)\n        xx, yy = np.meshgrid(x, y)\n        base_points = np.vstack([xx.ravel(), yy.ravel()]).T\n\n        if case_id == 1: # Structured lattice\n            return base_points\n        elif case_id == 2: # Skewed grid\n            eps = 0.08\n            perturbations = rng.uniform(-eps, eps, size=base_points.shape)\n            return base_points + perturbations\n        elif case_id == 3: # Anisotropic stretched grid\n            eps = 0.04\n            stretched_points = base_points.copy()\n            stretched_points[:, 1] *= 0.2\n            perturbations = rng.uniform(-eps, eps, size=stretched_points.shape)\n            return stretched_points + perturbations\n        elif case_id == 4: # Clustered irregular set\n            n_extra = 400\n            radius = 0.3\n            center = np.array([0.5, 0.5])\n            \n            # Sample points uniformly in a disk\n            r = radius * np.sqrt(rng.uniform(0, 1, size=n_extra))\n            theta = 2 * np.pi * rng.uniform(0, 1, size=n_extra)\n            extra_points = np.zeros((n_extra, 2))\n            extra_points[:, 0] = center[0] + r * np.cos(theta)\n            extra_points[:, 1] = center[1] + r * np.sin(theta)\n            \n            return np.vstack([base_points, extra_points])\n        else:\n            raise ValueError(\"Invalid case_id\")\n\n    def compute_gg_errors(points):\n        \"\"\"\n        Computes mean errors for cell-based and node-based GG reconstructions.\n        \"\"\"\n        tri = Delaunay(points)\n        simplices = tri.simplices\n        neighbors = tri.neighbors\n\n        # Identify interior triangles (no boundary edges)\n        interior_tri_indices = np.where(np.all(neighbors != -1, axis=1))[0]\n\n        # Pre-compute geometric properties\n        num_tris = len(simplices)\n        areas = np.zeros(num_tris)\n        centroids = np.zeros((num_tris, 2))\n        # normals will store [S_f0, S_f1, S_f2] for each triangle, where S_fi is opposite vertex i\n        normals = np.zeros((num_tris, 3, 2)) \n\n        for i in range(num_tris):\n            v_indices = simplices[i]\n            verts = points[v_indices]\n            \n            # Ensure CCW ordering for consistent outward normals\n            # Signed area calculation\n            signed_area = 0.5 * ((verts[1, 0] - verts[0, 0]) * (verts[2, 1] - verts[0, 1]) - \n                                 (verts[2, 0] - verts[0, 0]) * (verts[1, 1] - verts[0, 1]))\n\n            if signed_area  0:\n                v_indices = np.array([v_indices[0], v_indices[2], v_indices[1]])\n                simplices[i] = v_indices # Update simplices array\n                verts = points[v_indices]\n                areas[i] = -signed_area\n            else:\n                areas[i] = signed_area\n\n            centroids[i] = np.mean(verts, axis=0)\n\n            # Face normal vectors S_f = n_f * |edge_length|.\n            # The edge opposite vertex 0 is between vertices 1 and 2.\n            # Rule for outward normal of edge p1->p2: (y2-y1, -(x2-x1))\n            normals[i, 0, :] = [verts[2, 1] - verts[1, 1], -(verts[2, 0] - verts[1, 0])] # Opp. v0\n            normals[i, 1, :] = [verts[0, 1] - verts[2, 1], -(verts[0, 0] - verts[2, 0])] # Opp. v1\n            normals[i, 2, :] = [verts[1, 1] - verts[0, 1], -(verts[1, 0] - verts[0, 0])] # Opp. v2\n\n        # Evaluate scalar field at cell centroids and vertices\n        phi_c = phi_func(centroids)\n        phi_v = phi_func(points)\n\n        cell_errors = []\n        node_errors = []\n\n        exact_grads_at_centroids = grad_phi_func(centroids)\n\n        for i in interior_tri_indices:\n            p_area = areas[i]\n            p_v_indices = simplices[i]\n            p_neighbors = neighbors[i]\n\n            # --- Cell-based reconstruction ---\n            grad_cell = np.zeros(2)\n            phi_p = phi_c[i]\n            \n            # Edge opp v0 (between v1,v2), neighbor is n0\n            phi_n0 = phi_c[p_neighbors[0]]\n            phi_f0 = 0.5 * (phi_p + phi_n0)\n            grad_cell += phi_f0 * normals[i, 0, :]\n\n            # Edge opp v1 (between v2,v0), neighbor is n1\n            phi_n1 = phi_c[p_neighbors[1]]\n            phi_f1 = 0.5 * (phi_p + phi_n1)\n            grad_cell += phi_f1 * normals[i, 1, :]\n\n            # Edge opp v2 (between v0,v1), neighbor is n2\n            phi_n2 = phi_c[p_neighbors[2]]\n            phi_f2 = 0.5 * (phi_p + phi_n2)\n            grad_cell += phi_f2 * normals[i, 2, :]\n            \n            grad_cell /= p_area\n            \n            # --- Node-based reconstruction ---\n            grad_node = np.zeros(2)\n            phi_v0, phi_v1, phi_v2 = phi_v[p_v_indices]\n\n            # Contribution from edge between v1 and v2\n            phi_f_12 = 0.5 * (phi_v1 + phi_v2) \n            grad_node += phi_f_12 * normals[i, 0, :]\n            \n            # Contribution from edge between v2 and v0\n            phi_f_20 = 0.5 * (phi_v2 + phi_v0)\n            grad_node += phi_f_20 * normals[i, 1, :]\n            \n            # Contribution from edge between v0 and v1\n            phi_f_01 = 0.5 * (phi_v0 + phi_v1)\n            grad_node += phi_f_01 * normals[i, 2, :]\n\n            grad_node /= p_area\n\n            # --- Error calculation ---\n            exact_grad = exact_grads_at_centroids[i]\n            cell_errors.append(np.linalg.norm(grad_cell - exact_grad))\n            node_errors.append(np.linalg.norm(grad_node - exact_grad))\n            \n        return np.mean(cell_errors), np.mean(node_errors)\n\n    # Main execution loop\n    test_cases = [1, 2, 3, 4]\n    results = []\n    for case_id in test_cases:\n        points = generate_points(case_id, seed=42)\n        mean_cell_err, mean_node_err = compute_gg_errors(points)\n        is_node_better = mean_node_err  mean_cell_err\n        results.append(str(is_node_better).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3325671"}]}