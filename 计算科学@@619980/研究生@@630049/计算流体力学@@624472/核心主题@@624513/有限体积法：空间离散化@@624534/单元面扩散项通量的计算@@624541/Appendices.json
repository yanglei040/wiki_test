{"hands_on_practices": [{"introduction": "我们从最基本的情景开始：一维扩散穿过一个分隔两种不同扩散系数材料的界面。这个练习将通过解析方式证明，为什么对扩散系数进行简单的算术平均是错误的，以及如何通过强制通量连续性自然地得出调和平均值。这一原理是精确处理多材料问题的基石，也是理解更复杂离散化方案的基础。 [@problem_id:3316585]", "problem": "考虑一个被动标量 $\\phi$ 在复合介质中的一维稳态扩散，其中无源项且无对流。扩散系数 $\\Gamma$ 在一个与有限体积边界面重合的界面上存在不连续性。两个相邻的控制体共享一个位于位置 $x_f$ 的公共面。西侧单元中心的坐标为 $x_W$，东侧单元中心的坐标为 $x_E$。单元中心到边界面之间的距离分别为 $\\delta_W = x_f - x_W$ 和 $\\delta_E = x_E - x_f$，其中 $\\delta_W \\neq \\delta_E$ 表示一个渐变网格。横截面积 $A$ 假定为常数，扩散系数在 $x < x_f$ 时为 $\\Gamma_W$，在 $x > x_f$ 时为 $\\Gamma_E$。一种常见的数值实践是使用扩散系数的算术平均值来近似通量：$F_{\\text{arith}} = A\\,\\Gamma_f^{\\text{arith}}\\,\\frac{\\phi_E - \\phi_W}{\\delta_W + \\delta_E}$，其中 $\\Gamma_f^{\\text{arith}} = \\frac{1}{2}(\\Gamma_W + \\Gamma_E)$。请推导相对误差 $\\mathcal{E} = \\frac{F_{\\text{arith}} - F_{\\text{exact}}}{F_{\\text{exact}}}$ 的表达式，其中 $F_{\\text{exact}}$ 是穿过界面的精确通量。请用 $\\Gamma_W, \\Gamma_E, \\delta_W,$ 和 $\\delta_E$ 来表示您的答案。", "solution": "该问题要求推导在复合介质中，数值近似的扩散通量与穿过界面的精确扩散通量之间的相对误差。出发点是没有源项或对流的一维稳态扩散方程，该方程由菲克定律推导而来。\n\n对于一维系统，菲克定律指出单位面积的扩散通量 $q$ 由下式给出：\n$$q = -\\Gamma \\frac{d\\phi}{dx}$$\n其中 $\\phi$ 是标量浓度，$\\Gamma$ 是扩散系数。穿过面积为 $A$ 的表面的总通量为 $F = A q$。\n\n在无源的稳态条件下，守恒原理要求通量在整个区域内必须是恒定的。也就是说，$\\frac{dF}{dx} = 0$，这意味着 $F$ 是一个常数。我们将此恒定的精确通量表示为 $F_{\\text{exact}}$。\n\n该区域由两个具有不同扩散系数的区域组成：当 $x  x_f$ 时为 $\\Gamma_W$，当 $x > x_f$ 时为 $\\Gamma_E$。我们可以分别在每个区域上对菲克定律进行积分。\n\n首先，考虑西侧区域，从单元中心 $x_W$ 到边界面 $x_f$。扩散系数为 $\\Gamma_W$。\n$$F_{\\text{exact}} = -A \\Gamma_W \\frac{d\\phi}{dx} \\quad \\text{for} \\quad x \\in [x_W, x_f]$$\n分离变量并从 $x_W$ 积分到 $x_f$，其中标量值分别为 $\\phi_W$ 和 $\\phi_f$：\n$$\\int_{x_W}^{x_f} F_{\\text{exact}} dx = -A \\Gamma_W \\int_{\\phi_W}^{\\phi_f} d\\phi$$\n$$F_{\\text{exact}} (x_f - x_W) = -A \\Gamma_W (\\phi_f - \\phi_W)$$\n使用定义 $\\delta_W = x_f - x_W$，我们得到：\n$$F_{\\text{exact}} \\delta_W = A \\Gamma_W (\\phi_W - \\phi_f)$$\n这可以重新整理以表示标量值的下降：\n$$\\phi_W - \\phi_f = \\frac{F_{\\text{exact}} \\delta_W}{A \\Gamma_W}$$\n\n接下来，考虑东侧区域，从边界面 $x_f$ 到单元中心 $x_E$。扩散系数为 $\\Gamma_E$。\n$$F_{\\text{exact}} = -A \\Gamma_E \\frac{d\\phi}{dx} \\quad \\text{for} \\quad x \\in [x_f, x_E]$$\n从 $x_f$ 积分到 $x_E$，其中标量值为 $\\phi_f$ 和 $\\phi_E$：\n$$\\int_{x_f}^{x_E} F_{\\text{exact}} dx = -A \\Gamma_E \\int_{\\phi_f}^{\\phi_E} d\\phi$$\n$$F_{\\text{exact}} (x_E - x_f) = -A \\Gamma_E (\\phi_E - \\phi_f)$$\n使用定义 $\\delta_E = x_E - x_f$，我们有：\n$$F_{\\text{exact}} \\delta_E = A \\Gamma_E (\\phi_f - \\phi_E)$$\n这给出了第二个标量下降：\n$$\\phi_f - \\phi_E = \\frac{F_{\\text{exact}} \\delta_E}{A \\Gamma_E}$$\n\n为了消除未知的界面标量值 $\\phi_f$，我们将两个标量下降的表达式相加：\n$$(\\phi_W - \\phi_f) + (\\phi_f - \\phi_E) = \\frac{F_{\\text{exact}} \\delta_W}{A \\Gamma_W} + \\frac{F_{\\text{exact}} \\delta_E}{A \\Gamma_E}$$\n$$\\phi_W - \\phi_E = \\frac{F_{\\text{exact}}}{A} \\left( \\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E} \\right)$$\n现在我们可以用已知的单元中心值 $\\phi_W$ 和 $\\phi_E$ 来求解精确通量 $F_{\\text{exact}}$：\n$$F_{\\text{exact}} = A \\frac{\\phi_W - \\phi_E}{\\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E}}$$\n为了与 $F_{\\text{arith}}$ 定义中使用的符号约定（与 $\\phi_E - \\phi_W$ 成正比）保持一致，我们可以写成：\n$$F_{\\text{exact}} = -A \\frac{\\phi_E - \\phi_W}{\\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E}}$$\n这可以通过为界面定义一个有效扩散系数 $\\Gamma_f^{\\text{exact}}$ 来重写：\n$$F_{\\text{exact}} = -A \\, \\Gamma_f^{\\text{exact}} \\frac{\\phi_E - \\phi_W}{\\delta_W + \\delta_E}$$\n比较形式，我们可以确定 $\\Gamma_f^{\\text{exact}}$：\n$$-A \\, \\Gamma_f^{\\text{exact}} \\frac{\\phi_E - \\phi_W}{\\delta_W + \\delta_E} = -A \\frac{\\phi_E - \\phi_W}{\\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E}} \\quad \\implies \\quad \\Gamma_f^{\\text{exact}} = \\frac{\\delta_W + \\delta_E}{\\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E}}$$\n这是扩散系数的加权调和平均值。项 $\\frac{\\delta_W}{A\\Gamma_W}$ 和 $\\frac{\\delta_E}{A\\Gamma_E}$ 分别代表西段和东段的扩散阻力，这表明对于精确解，这些串联的阻力是相加的。\n\n问题将使用扩散系数的算术平均值计算的通量定义为：\n$$F_{\\text{arith}} = A\\,\\Gamma_f^{\\text{arith}}\\,\\frac{\\phi_E - \\phi_W}{\\delta_W + \\delta_E}$$\n其中 $\\Gamma_f^{\\text{arith}} = \\frac{1}{2}(\\Gamma_W + \\Gamma_E)$。\n\n我们被要求找出相对误差 $\\mathcal{E}$：\n$$\\mathcal{E} = \\frac{F_{\\text{arith}} - F_{\\text{exact}}}{F_{\\text{exact}}} = \\frac{F_{\\text{arith}}}{F_{\\text{exact}}} - 1$$\n通量之比简化为有效扩散系数之比：\n$$\\frac{F_{\\text{arith}}}{F_{\\text{exact}}} = \\frac{A\\,\\Gamma_f^{\\text{arith}}\\,\\frac{\\phi_E - \\phi_W}{\\delta_W + \\delta_E}}{-A\\,\\Gamma_f^{\\text{exact}}\\,\\frac{\\phi_E - \\phi_W}{\\delta_W + \\delta_E}} = \\frac{\\Gamma_f^{\\text{arith}}}{\\Gamma_f^{\\text{exact}}}$$\n代入 $\\Gamma_f^{\\text{arith}}$ 和 $\\Gamma_f^{\\text{exact}}$ 的表达式：\n$$\\frac{F_{\\text{arith}}}{F_{\\text{exact}}} = \\frac{\\frac{1}{2}(\\Gamma_W + \\Gamma_E)}{\\frac{\\delta_W + \\delta_E}{\\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E}}} = \\frac{\\Gamma_W + \\Gamma_E}{2} \\cdot \\frac{\\frac{\\delta_W}{\\Gamma_W} + \\frac{\\delta_E}{\\Gamma_E}}{\\delta_W + \\delta_E}$$\n让我们简化这个表达式：\n$$\\frac{F_{\\text{arith}}}{F_{\\text{exact}}} = \\frac{\\Gamma_W + \\Gamma_E}{2(\\delta_W + \\delta_E)} \\cdot \\frac{\\delta_W \\Gamma_E + \\delta_E \\Gamma_W}{\\Gamma_W \\Gamma_E} = \\frac{(\\Gamma_W + \\Gamma_E)(\\delta_W \\Gamma_E + \\delta_E \\Gamma_W)}{2 \\Gamma_W \\Gamma_E (\\delta_W + \\delta_E)}$$\n现在，我们计算相对误差 $\\mathcal{E}$：\n$$\\mathcal{E} = \\frac{(\\Gamma_W + \\Gamma_E)(\\delta_W \\Gamma_E + \\delta_E \\Gamma_W)}{2 \\Gamma_W \\Gamma_E (\\delta_W + \\delta_E)} - 1$$\n$$\\mathcal{E} = \\frac{(\\Gamma_W + \\Gamma_E)(\\delta_W \\Gamma_E + \\delta_E \\Gamma_W) - 2 \\Gamma_W \\Gamma_E (\\delta_W + \\delta_E)}{2 \\Gamma_W \\Gamma_E (\\delta_W + \\delta_E)}$$\n展开分子：\n分子 $= (\\Gamma_W \\delta_W \\Gamma_E + \\Gamma_W \\delta_E \\Gamma_W + \\Gamma_E \\delta_W \\Gamma_E + \\Gamma_E \\delta_E \\Gamma_W) - (2\\delta_W \\Gamma_W \\Gamma_E + 2\\delta_E \\Gamma_W \\Gamma_E)$\n分子 $= \\delta_W \\Gamma_W \\Gamma_E + \\delta_E \\Gamma_W^2 + \\delta_W \\Gamma_E^2 + \\delta_E \\Gamma_W \\Gamma_E - 2\\delta_W \\Gamma_W \\Gamma_E - 2\\delta_E \\Gamma_W \\Gamma_E$\n合并同类项：\n分子 $= \\delta_E \\Gamma_W^2 + \\delta_W \\Gamma_E^2 - \\delta_W \\Gamma_W \\Gamma_E - \\delta_E \\Gamma_W \\Gamma_E$\n按 $\\delta_W$ 和 $\\delta_E$ 因式分解：\n分子 $= \\delta_W(\\Gamma_E^2 - \\Gamma_W \\Gamma_E) + \\delta_E(\\Gamma_W^2 - \\Gamma_W \\Gamma_E)$\n分子 $= \\delta_W \\Gamma_E(\\Gamma_E - \\Gamma_W) - \\delta_E \\Gamma_W(\\Gamma_E - \\Gamma_W)$\n提取公因式 $(\\Gamma_E - \\Gamma_W)$：\n分子 $= (\\Gamma_E - \\Gamma_W)(\\delta_W \\Gamma_E - \\delta_E \\Gamma_W)$\n\n因此，相对误差的最终表达式为：\n$$\\mathcal{E} = \\frac{(\\Gamma_E - \\Gamma_W)(\\delta_W \\Gamma_E - \\delta_E \\Gamma_W)}{2 \\Gamma_W \\Gamma_E (\\delta_W + \\delta_E)}$$\n该表达式是无量纲的，符合要求。分子的单位是 $[\\Gamma]^2[\\delta]$，分母的单位也是 $[\\Gamma]^2[\\delta]$。\n\n这个结果可以通过扩散阻力的概念来解释。精确的总阻力是 $R_{\\text{exact}} = (\\delta_W/(A\\Gamma_W)) + (\\delta_E/(A\\Gamma_E))$。算术平均近似所隐含的阻力是 $R_{\\text{arith}} = (\\delta_W+\\delta_E)/(A\\Gamma_f^{\\text{arith}})$。通量的相对误差由 $\\mathcal{E} = R_{\\text{exact}}/R_{\\text{arith}} - 1$ 给出。推导出的表达式表明，在两种情况下，此误差为零：\n1. $\\Gamma_E = \\Gamma_W$：介质是均匀的，因此没有不连续性。\n2. $\\delta_W \\Gamma_E = \\delta_E \\Gamma_W$，或 $\\delta_W/\\delta_E = \\Gamma_W/\\Gamma_E$：界面两侧的网格间距以一个与扩散系数相关的特定比例进行渐变。在这种特殊情况下，算术平均值碰巧得出了物理上所要求的正确的调和平均值。\n对于均匀网格（$\\delta_W = \\delta_E = \\delta$），误差简化为 $\\mathcal{E} = \\frac{(\\Gamma_E - \\Gamma_W)^2}{4\\Gamma_W\\Gamma_E}$。由于该值总是非负的，当网格均匀且 $\\Gamma_W \\neq \\Gamma_E$ 时，与精确解相比，算术平均格式总是高估通量的大小。", "answer": "$$\\boxed{\\frac{(\\Gamma_E - \\Gamma_W)(\\delta_W \\Gamma_E - \\delta_E \\Gamma_W)}{2 \\Gamma_W \\Gamma_E (\\delta_W + \\delta_E)}}$$", "id": "3316585"}, {"introduction": "现实世界中的材料通常是各向异性的，这意味着它们的性质取决于方向。本实践探讨了张量电导率 $\\mathbf{K}$ 如何耦合通量，产生简单的两点通量近似 (TPFA) 无法捕捉的“交叉扩散”项。通过在一个简单的线性场中比较 TPFA 与更高级的多点通量近似 (MPFA)，您将精确地理解为什么以及何时必须使用高级格式来保证物理保真度。 [@problem_id:3316594]", "problem": "考虑一个由傅里叶热传导定律（等效于菲克质量扩散定律）控制的二维扩散过程，该定律指出扩散通量矢量为 $\\mathbf{q}=-\\mathbf{K}\\nabla u$，其中 $\\mathbf{K}\\in\\mathbb{R}^{2\\times 2}$ 是一个对称正定传导率张量，而 $u:\\mathbb{R}^2\\to\\mathbb{R}$ 是一个标量势，其梯度为 $\\nabla u$。在有限体积法的背景下，穿过具有单位法向量 $\\mathbf{n}_f$ 的面的法向通量定义为 $q_f=-\\mathbf{n}_f^\\top\\mathbf{K}\\nabla u$。传导率张量被假定为各向异性的，其主值为 $k_10$ 和 $k_20$，主方向相对于一个固定的全局坐标系旋转了角度 $\\theta$。令 $\\mathbf{R}(\\theta)$ 表示旋转角度为 $\\theta$ 的平面旋转矩阵，并将传导率张量定义为 $\\mathbf{K}=\\mathbf{R}(\\theta)^\\top\\mathrm{diag}(k_1,k_2)\\,\\mathbf{R}(\\theta)$。在同一个全局坐标系中，面法线的方向角为 $\\varphi$，即 $\\mathbf{n}_f=[\\cos\\varphi,\\sin\\varphi]^\\top$，其切线为 $\\mathbf{t}_f=[-\\sin\\varphi,\\cos\\varphi]^\\top$。\n\n需要评估两种数值通量近似方法：\n- 两点通量近似 (TPFA)：$q_f^{\\mathrm{TPFA}}$ 仅使用沿连接两个相邻单元中心的线上的单元中心值的差，以及 $\\mathbf{K}$ 在法线方向上的投影。\n- 多点通量近似 (MPFA)：$q_f^{\\mathrm{MPFA}}$ 使用多个点的值来重建局部梯度，以捕捉法向和切向的方向导数，从而考虑由各向异性和未对准引入的交叉耦合效应。\n\n假设一个形式为 $u(x,y)=a\\,x+b\\,y$ 的线性标量场，其中 $a$ 和 $b$ 是常数，因此梯度 $\\nabla u=\\mathbf{g}=[a,b]^\\top$ 是恒定的。考虑一个以原点为中心、单位法向量为 $\\mathbf{n}_f$、切向量为 $\\mathbf{t}_f$ 的面。设两个相邻单元的中心位于位置 $\\mathbf{r}_A=-\\frac{d}{2}\\mathbf{n}_f$ 和 $\\mathbf{r}_B=+\\frac{d}{2}\\mathbf{n}_f$ 处，其中 $d0$ 是沿法线方向的单元中心之间的距离。此外，定义每一侧的切向邻居位置：$\\mathbf{r}_{A,\\pm}=\\mathbf{r}_A\\pm s\\,\\mathbf{t}_f$ 和 $\\mathbf{r}_{B,\\pm}=\\mathbf{r}_B\\pm s\\,\\mathbf{t}_f$，其中 $s\\ge 0$ 是切向偏移量。\n\n将精确法向通量定义为 $q_f^{\\mathrm{exact}}=-\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{g}$。将两点通量近似定义为 $q_f^{\\mathrm{TPFA}}=-\\left(\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f\\right)\\,\\frac{u(\\mathbf{r}_B)-u(\\mathbf{r}_A)}{d}$。通过首先构造方向导数来定义多点通量近似\n$$\nD_n=\\frac{u(\\mathbf{r}_B)-u(\\mathbf{r}_A)}{d},\\quad D_t^{(A)}=\\frac{u(\\mathbf{r}_{A,+})-u(\\mathbf{r}_{A,-})}{2s},\\quad D_t^{(B)}=\\frac{u(\\mathbf{r}_{B,+})-u(\\mathbf{r}_{B,-})}{2s},\n$$\n约定如果 $s=0$ 则 $D_t^{(A)}=D_t^{(B)}=0$，并设置 $D_t=\\frac{D_t^{(A)}+D_t^{(B)}}{2}$。形成重建梯度 $\\widehat{\\nabla u}=D_n\\,\\mathbf{n}_f+D_t\\,\\mathbf{t}_f$，并计算\n$$\nq_f^{\\mathrm{MPFA}}=-\\mathbf{n}_f^\\top\\mathbf{K}\\,\\widehat{\\nabla u}.\n$$\n根据设计，对于线性 $u$ 和 $s0$，$\\widehat{\\nabla u}$ 可以精确地恢复 $\\nabla u$。\n\n您的任务是实现一个程序，对于一组给定的参数 $(k_1,k_2,\\theta,\\varphi,d,s,a,b)$，计算绝对误差对 $\\left|q_f^{\\mathrm{TPFA}}-q_f^{\\mathrm{exact}}\\right|$ 和 $\\left|q_f^{\\mathrm{MPFA}}-q_f^{\\mathrm{exact}}\\right|$。角度使用弧度制。将所有量视为无量纲。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n\n测试套件：\n- 情况 $\\mathbf{1}$ (各向异性但对齐): $(k_1,k_2,\\theta,\\varphi,d,s,a,b)=\\left(2.0,0.5,0.0,0.0,1.0,0.5,1.0,0.5\\right)$。\n- 情况 $\\mathbf{2}$ (各向异性, $\\mathbf{K}$ 旋转): $(k_1,k_2,\\theta,\\varphi,d,s,a,b)=\\left(2.0,0.5,\\frac{\\pi}{4},0.0,1.0,0.5,1.0,0.5\\right)$。\n- 情况 $\\mathbf{3}$ (各向同性): $(k_1,k_2,\\theta,\\varphi,d,s,a,b)=\\left(1.0,1.0,\\frac{\\pi}{3},\\frac{\\pi}{4},1.0,0.5,1.0,0.5\\right)$。\n- 情况 $\\mathbf{4}$ (一般未对准): $(k_1,k_2,\\theta,\\varphi,d,s,a,b)=\\left(3.0,0.7,\\frac{\\pi}{6},\\frac{\\pi}{3},1.2,0.4,1.0,0.5\\right)$。\n- 情况 $\\mathbf{5}$ (边界, 无切向邻居): $(k_1,k_2,\\theta,\\varphi,d,s,a,b)=\\left(2.0,0.5,\\frac{\\pi}{4},\\frac{\\pi}{6},1.0,0.0,1.0,0.5\\right)$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由数个对组成的逗号分隔列表，每个对本身是用方括号括起来的、包含两个浮点绝对误差的逗号分隔列表。例如，包含三个测试用例的输出应如下所示：$\\left[[e_{1}^{\\mathrm{TPFA}},e_{1}^{\\mathrm{MPFA}}],[e_{2}^{\\mathrm{TPFA}},e_{2}^{\\mathrm{MPFA}}],[e_{3}^{\\mathrm{TPFA}},e_{3}^{\\mathrm{MPFA}}]\\right]$。", "solution": "该问题要求计算二维扩散问题的两种数值通量近似方法——两点通量近似 (TPFA) 和多点通量近似 (MPFA)——相对于精确解析通量的绝对误差。该问题是适定的、科学上合理的，并为获得唯一解提供了所有必要信息。\n\n分析首先将问题陈述中提供的数学构造形式化。所有量均被视为无量纲。\n\n首先，我们定义主要的向量和矩阵。标量场是线性的，$u(x,y)=a\\,x+b\\,y$，这意味着梯度向量 $\\mathbf{g}=\\nabla u = [a,b]^\\top$ 是恒定的。\n面单位法向量 $\\mathbf{n}_f$ 和单位切向量 $\\mathbf{t}_f$ 由面朝向角 $\\varphi$ 定义：\n$$\n\\mathbf{n}_f = \\begin{pmatrix} \\cos\\varphi \\\\ \\sin\\varphi \\end{pmatrix}, \\quad \\mathbf{t}_f = \\begin{pmatrix} -\\sin\\varphi \\\\ \\cos\\varphi \\end{pmatrix}\n$$\n这两个向量构成了 $\\mathbb{R}^2$ 的一个标准正交基。\n\n传导率张量 $\\mathbf{K}$ 由其主传导率 $k_1$ 和 $k_2$ 及其主轴的旋转角 $\\theta$ 定义。旋转矩阵 $\\mathbf{R}(\\theta)$ 及其转置 $\\mathbf{R}(\\theta)^\\top$ 为：\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}, \\quad \\mathbf{R}(\\theta)^\\top = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\n张量 $\\mathbf{K}$ 由 $\\mathbf{K}=\\mathbf{R}(\\theta)^\\top\\mathrm{diag}(k_1,k_2)\\,\\mathbf{R}(\\theta)$ 给出。执行矩阵乘法可得出 $\\mathbf{K}$ 的分量：\n$$\n\\mathbf{K} = \\begin{pmatrix} k_1\\cos^2\\theta + k_2\\sin^2\\theta  (k_1-k_2)\\sin\\theta\\cos\\theta \\\\ (k_1-k_2)\\sin\\theta\\cos\\theta  k_1\\sin^2\\theta + k_2\\cos^2\\theta \\end{pmatrix}\n$$\n这是一个对称矩阵，并且由于 $k_1  0$ 和 $k_2  0$，因此它是所要求的正定矩阵。\n\n有了这些定义，我们就可以推导出三种通量的表达式。\n\n**1. 精确法向通量, $q_f^{\\mathrm{exact}}$**\n\n精确法向通量定义为 $q_f^{\\mathrm{exact}}=-\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{g}$。这是一个涉及矩阵-向量乘法的直接计算。\n$$\nq_f^{\\mathrm{exact}} = - \\begin{pmatrix} \\cos\\varphi  \\sin\\varphi \\end{pmatrix} \\begin{pmatrix} K_{11}  K_{12} \\\\ K_{21}  K_{22} \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix}\n$$\n\n**2. 两点通量近似, $q_f^{\\mathrm{TPFA}}$**\n\nTPFA 通量定义为 $q_f^{\\mathrm{TPFA}}=-\\left(\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f\\right)\\,\\frac{u(\\mathbf{r}_B)-u(\\mathbf{r}_A)}{d}$。项 $\\frac{u(\\mathbf{r}_B)-u(\\mathbf{r}_A)}{d}$ 代表法向导数的有限差分近似。对于线性标量场 $u(\\mathbf{r}) = \\mathbf{g}^\\top\\mathbf{r} + c$，该项可以精确计算。给定 $\\mathbf{r}_A = -\\frac{d}{2}\\mathbf{n}_f$ 和 $\\mathbf{r}_B = \\frac{d}{2}\\mathbf{n}_f$：\n$$\nu(\\mathbf{r}_B) - u(\\mathbf{r}_A) = (\\mathbf{g}^\\top\\mathbf{r}_B + c) - (\\mathbf{g}^\\top\\mathbf{r}_A + c) = \\mathbf{g}^\\top(\\mathbf{r}_B - \\mathbf{r}_A) = \\mathbf{g}^\\top(d\\,\\mathbf{n}_f) = d\\,(\\mathbf{g}^\\top\\mathbf{n}_f)\n$$\n因此，有限差分是精确的：\n$$\n\\frac{u(\\mathbf{r}_B)-u(\\mathbf{r}_A)}{d} = \\mathbf{g}^\\top\\mathbf{n}_f = \\mathbf{n}_f^\\top\\mathbf{g}\n$$\n将此代入 TPFA 的定义，我们得到：\n$$\nq_f^{\\mathrm{TPFA}} = -\\left(\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f\\right) \\left(\\mathbf{n}_f^\\top\\mathbf{g}\\right)\n$$\nTPFA 通量是有效法向传导率 $T_{\\mathrm{eff}} = \\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f$ 和梯度在面法线上的投影 $g_n = \\mathbf{n}_f^\\top\\mathbf{g}$ 的乘积。\n\n**3. 多点通量近似, $q_f^{\\mathrm{MPFA}}$**\n\nMPFA 通量为 $q_f^{\\mathrm{MPFA}}=-\\mathbf{n}_f^\\top\\mathbf{K}\\,\\widehat{\\nabla u}$，其中 $\\widehat{\\nabla u}$ 是一个重建梯度。\n重建梯度为 $\\widehat{\\nabla u}=D_n\\,\\mathbf{n}_f+D_t\\,\\mathbf{t}_f$。\n法向导数分量 $D_n$ 与 TPFA 中使用的相同：\n$$\nD_n = \\frac{u(\\mathbf{r}_B)-u(\\mathbf{r}_A)}{d} = \\mathbf{n}_f^\\top\\mathbf{g}\n$$\n切向导数分量 $D_t = \\frac{1}{2}(D_t^{(A)} + D_t^{(B)})$ 是根据切向邻居位置的值计算的。我们来分析 $s  0$ 的情况：\n$$\nD_t^{(A)} = \\frac{u(\\mathbf{r}_{A,+}) - u(\\mathbf{r}_{A,-})}{2s} = \\frac{\\mathbf{g}^\\top(\\mathbf{r}_{A,+}-\\mathbf{r}_{A,-})}{2s} = \\frac{\\mathbf{g}^\\top((\\mathbf{r}_A+s\\mathbf{t}_f)-(\\mathbf{r}_A-s\\mathbf{t}_f))}{2s} = \\frac{\\mathbf{g}^\\top(2s\\mathbf{t}_f)}{2s} = \\mathbf{g}^\\top\\mathbf{t}_f\n$$\n同样地，$D_t^{(B)} = \\mathbf{g}^\\top\\mathbf{t}_f$，所以 $D_t = \\mathbf{g}^\\top\\mathbf{t}_f = \\mathbf{t}_f^\\top\\mathbf{g}$。\n对于 $s0$，重建梯度为：\n$$\n\\widehat{\\nabla u} = (\\mathbf{n}_f^\\top\\mathbf{g})\\,\\mathbf{n}_f + (\\mathbf{t}_f^\\top\\mathbf{g})\\,\\mathbf{t}_f\n$$\n由于 $\\{\\mathbf{n}_f, \\mathbf{t}_f\\}$ 是一个标准正交基，此表达式是向量 $\\mathbf{g}$ 在该基上的分解。因此，$\\widehat{\\nabla u} = \\mathbf{g}$。当 $s0$ 时，MPFA 方案可以精确地重建线性场的梯度。\n因此，对于 $s  0$：\n$$\nq_f^{\\mathrm{MPFA}} = -\\mathbf{n}_f^\\top\\mathbf{K}\\,\\widehat{\\nabla u} = -\\mathbf{n}_f^\\top\\mathbf{K}\\,\\mathbf{g} = q_f^{\\mathrm{exact}}\n$$\n这意味着在所有 $s  0$ 的测试用例中，MPFA 的绝对误差为零。\n\n现在，考虑 $s=0$ 的情况。问题陈述中说明，如果 $s=0$，则 $D_t^{(A)} = D_t^{(B)} = 0$，这导致 $D_t = 0$。\n重建梯度变为：\n$$\n\\widehat{\\nabla u} = D_n\\,\\mathbf{n}_f = (\\mathbf{n}_f^\\top\\mathbf{g})\\,\\mathbf{n}_f\n$$\n于是 MPFA 通量为：\n$$\nq_f^{\\mathrm{MPFA}} = -\\mathbf{n}_f^\\top\\mathbf{K}\\left( (\\mathbf{n}_f^\\top\\mathbf{g})\\,\\mathbf{n}_f \\right) = -(\\mathbf{n}_f^\\top\\mathbf{g}) (\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f)\n$$\n这与 $q_f^{\\mathrm{TPFA}}$ 的表达式相同。因此，当 $s=0$ 时，$q_f^{\\mathrm{MPFA}} = q_f^{\\mathrm{TPFA}}$，它们的误差将是相同的。\n\n**4. 误差计算**\n\n绝对误差计算如下：\n$$\nE_{\\mathrm{TPFA}} = \\left|q_f^{\\mathrm{TPFA}} - q_f^{\\mathrm{exact}}\\right| = \\left| -\\left(\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f\\right) \\left(\\mathbf{n}_f^\\top\\mathbf{g}\\right) - (-\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{g}) \\right| = \\left| \\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{g} - (\\mathbf{n}_f^\\top\\mathbf{K}\\mathbf{n}_f) (\\mathbf{n}_f^\\top\\mathbf{g}) \\right|\n$$\n如果在 $\\{\\mathbf{n}_f, \\mathbf{t}_f\\}$ 基中表示时 $\\mathbf{K}$ 具有非对角项，则 TPFA 误差非零，这种情况发生在 $\\mathbf{K}$ 的主轴与面的法线/切线不对齐时。\n\nMPFA 误差为：\n$$\nE_{\\mathrm{MPFA}} = \\left|q_f^{\\mathrm{MPFA}} - q_f^{\\mathrm{exact}}\\right| = \\begin{cases} 0  \\text{if } s  0 \\\\ E_{\\mathrm{TPFA}}  \\text{if } s = 0 \\end{cases}\n$$\n\n实现将遵循这些推导出的公式。对于每个测试用例，我们构造 $\\mathbf{K}$ 矩阵以及向量 $\\mathbf{g}$ 和 $\\mathbf{n}_f$，然后计算通量及其差异。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes absolute errors for TPFA and MPFA flux approximations for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (k1, k2, theta, phi, d, s, a, b)\n        (2.0, 0.5, 0.0, 0.0, 1.0, 0.5, 1.0, 0.5),\n        (2.0, 0.5, np.pi/4, 0.0, 1.0, 0.5, 1.0, 0.5),\n        (1.0, 1.0, np.pi/3, np.pi/4, 1.0, 0.5, 1.0, 0.5),\n        (3.0, 0.7, np.pi/6, np.pi/3, 1.2, 0.4, 1.0, 0.5),\n        (2.0, 0.5, np.pi/4, np.pi/6, 1.0, 0.0, 1.0, 0.5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        k1, k2, theta, phi, d, s, a, b = case\n\n        # --- Define vectors and matrices ---\n\n        # Gradient vector g\n        g = np.array([a, b])\n\n        # Face normal vector n_f\n        n_f = np.array([np.cos(phi), np.sin(phi)])\n\n        # Conductivity tensor K\n        c_theta, s_theta = np.cos(theta), np.sin(theta)\n        K = np.array([\n            [k1 * c_theta**2 + k2 * s_theta**2, (k1 - k2) * s_theta * c_theta],\n            [(k1 - k2) * s_theta * c_theta, k1 * s_theta**2 + k2 * c_theta**2]\n        ])\n\n        # --- Calculate fluxes ---\n\n        # 1. Exact flux\n        # q_f_exact = -n_f^T * K * g\n        q_f_exact = -n_f @ (K @ g)\n\n        # 2. Two-Point Flux Approximation (TPFA)\n        # q_f_tpfa = -(n_f^T * K * n_f) * (n_f^T * g)\n        transmissibility = n_f @ (K @ n_f)\n        grad_normal_proj = n_f @ g\n        q_f_tpfa = -transmissibility * grad_normal_proj\n\n        # --- Calculate errors ---\n\n        # TPFA error\n        error_tpfa = np.abs(q_f_tpfa - q_f_exact)\n\n        # MPFA error\n        # For a linear scalar field u, the MPFA scheme is exact if s > 0.\n        # If s = 0, the MPFA scheme degenerates to the TPFA scheme.\n        if s > 0:\n            error_mpfa = 0.0\n        else: # s == 0\n            error_mpfa = error_tpfa\n        \n        results.append([error_tpfa, error_mpfa])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[err1_tpfa,err1_mpfa],[err2_tpfa,err2_mpfa]]\n    inner_parts = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_string = f\"[{','.join(inner_parts)}]\"\n    print(final_string)\n\nsolve()\n```", "id": "3316594"}, {"introduction": "这最后一个实践是一个综合性的计算练习，结合了各向异性和网格非正交性的挑战。您将使用工业标准的精确解方法 (MMS) 来实现并验证一个包含非正交修正的通量格式，以确保其在复杂几何上的准确性。这项练习将巩固您构建和测试数值方法的技能，这些方法对于现实的工程模拟必须是准确和可靠的。 [@problem_id:3316543]", "problem": "您需要通过精确解方法（Method of Manufactured Solutions, MMS），验证二维各向异性扩散算子在非正交单元面上扩散通量的数值计算。目标是确定一个面通量计算格式的观测精度阶，并在具有受控非正交性的一系列网格上量化误差范数。基本依据是菲克扩散定律和散度定理。从以下陈述开始：在各向异性、对称正定的传导率张量 $\\mathbf{K}$ 作用下，标量场 $\\phi(x,y)$ 的扩散通量密度由 $\\mathbf{q} = -\\mathbf{K}\\nabla \\phi$ 给出；通过面积矢量为 $\\mathbf{S} = \\mathbf{n}\\,A$ 的面的定向通量为 $F = \\mathbf{q}\\cdot \\mathbf{S}$, 其中 $\\mathbf{n}$ 是向外的单位法向量，$A$ 是面的面积，因此 $F = -\\mathbf{n}^{\\mathsf{T}}\\mathbf{K}\\nabla\\phi\\;A$。任务是设计并实现一种面梯度近似方法，该方法通过基于第一原理的原则性分解，在非正交网格上保持准确性，然后将得到的离散面通量与精确构造的通量进行比较。\n\n定义物理域为单位正方形 $\\Omega = [0,1]\\times[0,1]$。通过从计算坐标 $( \\xi,\\eta )$到物理坐标 $(x,y)$ 的剪切映射，构造一系列结构化的平行四边形网格，映射关系如下\n$$\nx = \\xi + s\\,\\eta,\\qquad y = \\eta,\n$$\n其中 $s$ 是一个非正交性（剪切）参数。一个具有 $N_x = N_y = N$ 的结构化网格，其节点位于计算坐标 $\\xi_i = i/N$ 和 $\\eta_j = j/N$ 处，其中 $i \\in \\{0,1,\\dots,N\\}$ 且 $j \\in \\{0,1,\\dots,N\\}$。每个单元是由连续节点构成的四边形，其中心是其四个顶点的平均值。面是这些四边形的边，内部面是两个相邻单元共享的面。\n\n使用一个各向异性、常数、对称正定的传导率张量\n$$\n\\mathbf{K} = \\begin{bmatrix} 2.0  0.5 \\\\ 0.5  1.5 \\end{bmatrix}.\n$$\n构造一个光滑标量场\n$$\n\\phi(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y) + x^2 - y,\n$$\n其精确梯度为\n$$\n\\nabla\\phi(x,y) = \\begin{bmatrix} \\pi \\cos(\\pi x)\\,\\cos(\\pi y) + 2x \\\\ -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) - 1 \\end{bmatrix}.\n$$\n\n对于由一对相邻单元 $P$ 和 $N$ 共享的每个内部面，其单元中心位置分别为 $\\mathbf{c}_P$ 和 $\\mathbf{c}_N$，边端点为 $\\mathbf{e}_0$ 和 $\\mathbf{e}_1$，定义面中心 $\\mathbf{f} = (\\mathbf{e}_0 + \\mathbf{e}_1)/2$，边切线 $\\mathbf{t} = \\mathbf{e}_1 - \\mathbf{e}_0$，单元 $P$ 的向外面积矢量为边法线 $\\mathbf{S}_f = \\mathbf{n}_f\\,A_f = [t_y,\\,-t_x]$（其大小等于边长 $A_f = \\|\\mathbf{t}\\|$），方向从 $P$ 向外，以及中心-中心矢量 $\\mathbf{d} = \\mathbf{c}_N - \\mathbf{c}_P$ 及其单位矢量 $\\widehat{\\mathbf{d}} = \\mathbf{d}/\\|\\mathbf{d}\\|$。从定义 $F = -\\mathbf{n}^{\\mathsf{T}}\\mathbf{K}\\nabla\\phi\\;A$ 出发，通过将 $\\nabla\\phi$ 分解为沿 $\\widehat{\\mathbf{d}}$ 及其正交补方向的分量，并仅使用单元中心处可用的量，推导出一个在非正交网格上一致的面梯度近似 $\\nabla\\phi\\big|_f$，然后构建相应的近似面通量 $F_{\\text{approx}} = -\\mathbf{S}_f^{\\mathsf{T}}\\,\\mathbf{K}\\,\\nabla\\phi\\big|_f$。使用在单元中心处的精确构造解 $\\phi$ 及其精确梯度，以分离出由面梯度近似（而非单元梯度重构）引起的误差。\n\n通过在所有内部面上比较 $F_{\\text{approx}}$ 与精确面通量 $F_{\\text{exact}} = -\\mathbf{S}_f^{\\mathsf{T}}\\,\\mathbf{K}\\,\\nabla\\phi(\\mathbf{f})$ 来量化误差。计算相对 $L_2$ 误差\n$$\nE_{L_2} = \\sqrt{\\frac{\\sum_{f} \\left(F_{\\text{approx}} - F_{\\text{exact}}\\right)^2}{\\sum_{f} \\left(F_{\\text{exact}}\\right)^2}},\n$$\n并确定在连续网格加密 $N \\to 2N$ 之间的观测精度阶，计算公式为\n$$\np = \\frac{\\log\\left(E_{L_2}(N) / E_{L_2}(2N)\\right)}{\\log(2)}.\n$$\n\n实现一个程序，该程序：\n- 为指定的 $N$ 和 $s$ 构建剪切映射网格。\n- 根据精确解，精确计算所有单元中心处的 $\\phi$ 和 $\\nabla\\phi$。\n- 构建内部面、定向面积矢量，并根据第一原理推导的原则性非正交修正计算 $F_{\\text{approx}}$，同时根据面中心的精确构造梯度计算 $F_{\\text{exact}}$。\n- 汇总所有内部面的误差，为每种情况计算 $E_{L_2}$，并计算不同加密网格之间的观测阶 $p$。\n\n您的测试套件必须使用：\n- $s \\in \\{0.0,\\,0.3\\}$。\n- $N \\in \\{8,\\,16,\\,32\\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下浮点数顺序排列结果：\n- 对于 $s=0.0$：$E_{L_2}(8),\\,E_{L_2}(16),\\,E_{L_2}(32),\\,p(8\\to 16),\\,p(16\\to 32)$，\n- 对于 $s=0.3$：$E_{L_2}(8),\\,E_{L_2}(16),\\,E_{L_2}(32),\\,p(8\\to 16),\\,p(16\\to 32)$。\n\n所有量均为无量纲；将所有数字表示为浮点值。最终打印的行必须在一个方括号列表中仅包含这十个值，不得有任何附加文本。", "solution": "### 第 1 步：提取已知条件\n问题提供了以下信息：\n- **物理定律**：菲克扩散定律，扩散通量密度为 $\\mathbf{q} = -\\mathbf{K}\\nabla \\phi$。\n- **通过一个面的通量**：$F = \\mathbf{q}\\cdot \\mathbf{S} = -\\mathbf{S}^{\\mathsf{T}}\\mathbf{K}\\nabla\\phi$，其中 $\\mathbf{S} = \\mathbf{n}\\,A$。\n- **区域**：单位正方形 $\\Omega = [0,1]\\times[0,1]$。\n- **网格生成**：通过从 $(\\xi, \\eta)$ 中的均匀计算网格到剪切映射 $x = \\xi + s\\,\\eta$, $y = \\eta$ 生成结构化平行四边形网格，其中 $s$ 是剪切参数。网格在每个方向上有 $N_x = N_y = N$ 个单元。\n- **节点位置**：节点位于计算坐标 $\\xi_i = i/N$ 和 $\\eta_j = j/N$ 处，其中 $i,j \\in \\{0, \\dots, N\\}$。\n- **传导率张量**：各向异性、常数、对称正定的张量 $\\mathbf{K} = \\begin{bmatrix} 2.0  0.5 \\\\ 0.5  1.5 \\end{bmatrix}$。\n- **精确构造解（标量场）**：$\\phi(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y) + x^2 - y$。\n- **精确构造解（梯度）**：$\\nabla\\phi(x,y) = \\begin{bmatrix} \\pi \\cos(\\pi x)\\,\\cos(\\pi y) + 2x \\\\ -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) - 1 \\end{bmatrix}$。\n- **几何定义**：对于单元 $P$ 和 $N$ 之间的面：\n    - 面中心：$\\mathbf{f} = (\\mathbf{e}_0 + \\mathbf{e}_1)/2$，其中 $\\mathbf{e}_0, \\mathbf{e}_1$ 是端点。\n    - 切向矢量：$\\mathbf{t} = \\mathbf{e}_1 - \\mathbf{e}_0$。\n    - 面积矢量：$\\mathbf{S}_f = [t_y, -t_x]$（从单元 $P$ 向外）。\n    - 中心-中心矢量：$\\mathbf{d} = \\mathbf{c}_N - \\mathbf{c}_P$。\n- **通量计算**：\n    - 近似通量：$F_{\\text{approx}} = -\\mathbf{S}_f^{\\mathsf{T}}\\,\\mathbf{K}\\,\\nabla\\phi\\big|_f$，其中 $\\nabla\\phi\\big|_f$ 是一个近似值。\n    - 精确通量：$F_{\\text{exact}} = -\\mathbf{S}_f^{\\mathsf{T}}\\,\\mathbf{K}\\,\\nabla\\phi(\\mathbf{f})$，使用面中心的精确梯度。\n- **误差度量**：\n    - 相对 $L_2$ 误差：$E_{L_2} = \\sqrt{\\frac{\\sum_{f} \\left(F_{\\text{approx}} - F_{\\text{exact}}\\right)^2}{\\sum_{f} \\left(F_{\\text{exact}}\\right)^2}}$。\n    - 观测精度阶：$p = \\frac{\\log\\left(E_{L_2}(N) / E_{L_2}(2N)\\right)}{\\log(2)}$。\n- **测试用例**：\n    - 剪切参数：$s \\in \\{0.0, 0.3\\}$。\n    - 网格尺寸：$N \\in \\{8, 16, 32\\}$。\n- **任务**：为非正交网格推导一个面梯度近似，实现它，并计算指定的误差和精度阶。使用来自精确解的精确单元中心值 $\\phi$ 和 $\\nabla\\phi$，将误差隔离到面插值/重构格式上。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于扩散方程，这是物理学和工程学中的一个基本输运方程。精确解方法是计算科学中一种标准、成熟的验证技术。所选的精确构造解是光滑的，传导率张量是对称正定的，这是扩散过程的物理要求。该问题是合理的。\n2.  **适定性**：任务是数值评估一个明确定义的过程。输入已指定，输出已定义，所需的推导遵循有限体积法中的标准方法。预期会得到一个唯一、稳定且有意义的结果（误差范数和精度阶）。该问题是适定的。\n3.  **客观性**：该问题使用精确的数学和计算语言。所有量都得到了明确的定义。没有主观或基于观点的陈述。\n4.  **完整性和一致性**：所有必要的参数（$\\mathbf{K}$, $\\phi(x,y)$, $s$, $N$）、定义（几何、误差）和程序均已提供。信息是自洽且一致的。\n\n### 第 3 步：结论与行动\n该问题是有效的。这是计算流体力学数值方法中一个明确定义的练习。将提供一个解决方案。\n\n### 求解推导与实现\n目标是验证一个用于计算穿过单元面 $f$ 的扩散通量 $F = -\\mathbf{S}_f^{\\mathsf{T}}\\mathbf{K}\\nabla\\phi$ 的数值格式。在非正交网格上的主要挑战是，利用相邻单元中心 $P$ 和 $N$ 的值，找到面中心梯度 $\\nabla\\phi\\big|_f$ 的一个精确近似。问题指定，$\\phi$ 和 $\\nabla\\phi$ 在单元中心处的精确值是已知的。\n\n**面梯度近似的推导**\n我们的任务是通过分解梯度矢量，推导出一个一致的面梯度近似 $\\nabla\\phi\\big|_f$。一种原则性的方法是将 $\\nabla\\phi\\big|_f$ 分解为平行于和垂直于连接两个单元中心的矢量 $\\mathbf{d} = \\mathbf{c}_N - \\mathbf{c}_P$ 的分量。设 $\\widehat{\\mathbf{d}} = \\mathbf{d} / \\|\\mathbf{d}\\|$ 为该方向的单位矢量。\n\n任何矢量都可以唯一地分解为其在给定方向上及正交于该方向上的投影。因此，我们可以写出：\n$$\n\\nabla\\phi\\big|_f = (\\nabla\\phi\\big|_f \\cdot \\widehat{\\mathbf{d}})\\,\\widehat{\\mathbf{d}} + \\left( \\nabla\\phi\\big|_f - (\\nabla\\phi\\big|_f \\cdot \\widehat{\\mathbf{d}})\\,\\widehat{\\mathbf{d}} \\right)\n$$\n现在我们对这两个正交分量分别进行近似。\n\n1.  **平行于 $\\mathbf{d}$ 的分量**：在面上沿 $\\widehat{\\mathbf{d}}$ 方向的 $\\phi$ 的方向导数 $\\nabla\\phi\\big|_f \\cdot \\widehat{\\mathbf{d}}$，可以使用单元中心 $\\mathbf{c}_P$ 和 $\\mathbf{c}_N$ 处的标量值，通过二阶精度的中心有限差分进行近似：\n    $$\n    \\nabla\\phi\\big|_f \\cdot \\widehat{\\mathbf{d}} \\approx \\frac{\\phi_N - \\phi_P}{\\|\\mathbf{d}\\|}\n    $$\n    其中 $\\phi_P = \\phi(\\mathbf{c}_P)$ 且 $\\phi_N = \\phi(\\mathbf{c}_N)$。此近似直接来自于 $\\phi$ 在线段 $\\overline{\\mathbf{c}_P \\mathbf{c}_N}$ 上某点附近的泰勒级数展开。\n\n2.  **正交于 $\\mathbf{d}$ 的分量**：对于正交于 $\\widehat{\\mathbf{d}}$ 的梯度分量，可以通过使用已知的单元中心梯度 $\\nabla\\phi_P$ 和 $\\nabla\\phi_N$ 获得一个合理的近似。我们首先构成一个平均梯度 $\\overline{\\nabla\\phi} = \\frac{1}{2}(\\nabla\\phi_P + \\nabla\\phi_N)$，这是 $\\nabla\\phi$ 在线段 $\\overline{\\mathbf{c}_P \\mathbf{c}_N}$ 中点处的二阶近似。这个平均梯度中正交于 $\\widehat{\\mathbf{d}}$ 的分量可以通过减去其在 $\\widehat{\\mathbf{d}}$ 上的投影得到：\n    $$\n    \\left( \\nabla\\phi\\big|_f - (\\nabla\\phi\\big|_f \\cdot \\widehat{\\mathbf{d}})\\,\\widehat{\\mathbf{d}} \\right) \\approx \\overline{\\nabla\\phi} - (\\overline{\\nabla\\phi} \\cdot \\widehat{\\mathbf{d}})\\,\\widehat{\\mathbf{d}}\n    $$\n\n结合这两个近似，得到面梯度的完整表达式：\n$$\n\\nabla\\phi\\big|_f \\approx \\left(\\frac{\\phi_N - \\phi_P}{\\|\\mathbf{d}\\|}\\right)\\,\\widehat{\\mathbf{d}} + \\left( \\overline{\\nabla\\phi} - (\\overline{\\nabla\\phi} \\cdot \\widehat{\\mathbf{d}})\\,\\widehat{\\mathbf{d}} \\right)\n$$\n这可以重排成更常见的“修正”形式：\n$$\n\\nabla\\phi\\big|_f \\approx \\overline{\\nabla\\phi} + \\left( \\frac{\\phi_N - \\phi_P}{\\|\\mathbf{d}\\|} - \\overline{\\nabla\\phi} \\cdot \\widehat{\\mathbf{d}} \\right)\\,\\widehat{\\mathbf{d}}\n$$\n此表达式将面梯度表示为单元中心梯度的简单平均值外加一个修正项。当沿 $\\mathbf{d}$ 方向的插值梯度分量（即 $\\overline{\\nabla\\phi}\\cdot\\widehat{\\mathbf{d}}$）与中心差分近似 $(\\phi_N-\\phi_P)/\\|\\mathbf{d}\\|$ 不匹配时，该修正项非零。在非正交网格上，当单元中心连接线 $\\mathbf{d}$ 不平行于面法线时，这种差异尤为显著。该格式旨在在此类网格上保持二阶精度。\n\n**数值实现**\n程序将执行以下步骤：\n1.  **设置**：定义常数矩阵 $\\mathbf{K}$ 并实现精确解 $\\phi(x,y)$ 及其梯度 $\\nabla\\phi(x,y)$ 的函数。\n2.  **网格生成**：对于给定的网格尺寸 $N$ 和剪切参数 $s$，使用映射 $x_{i,j} = i/N + s \\cdot (j/N)$ 和 $y_j = j/N$ 计算所有节点 $(x_{i,j}, y_{j})$ 的坐标。随后，通过平均每个单元 $(i,j)$ 的四个顶点坐标来计算其中心 $\\mathbf{c}_{i,j}$。\n3.  **单元中心求值**：在每个单元中心 $\\mathbf{c}_{i,j}$ 处计算精确的标量场 $\\phi$ 和梯度 $\\nabla\\phi$。存储这些值以供后续使用。\n4.  **面循环与通量计算**：遍历网格的所有内部面。内部面可分为两组：“垂直”面（分隔单元 $(i,j)$ 和 $(i+1,j)$）和“水平”面（分隔单元 $(i,j)$ 和 $(i,j+1)$）。对于每个内部面：\n    a.  识别相邻单元 $P$ 和 $N$，并检索它们预先计算的中心位置和场值（$\\mathbf{c}_P, \\mathbf{c}_N, \\phi_P, \\phi_N, \\nabla\\phi_P, \\nabla\\phi_N$）。\n    b.  确定面端点 $\\mathbf{e}_0, \\mathbf{e}_1$ 并计算面中心 $\\mathbf{f}$、切线 $\\mathbf{t}$ 和面积矢量 $\\mathbf{S}_f$。必须保持 $\\mathbf{S}_f$ 的一致方向（例如，从 $P$ 指向 $N$）。\n    c.  通过在面中心 $\\mathbf{f}$ 处计算 $\\nabla\\phi$ 并计算 $F_{\\text{exact}} = -\\mathbf{S}_f^{\\mathsf{T}}\\mathbf{K}\\nabla\\phi(\\mathbf{f})$ 来计算精确通量 $F_{\\text{exact}}$。\n    d.  首先使用推导的非正交修正格式计算近似面梯度 $\\nabla\\phi\\big|_f$，然后计算近似通量 $F_{\\text{approx}} = -\\mathbf{S}_f^{\\mathsf{T}}\\mathbf{K}\\nabla\\phi\\big|_f$。\n    e.  累加误差平方 $(F_{\\text{approx}} - F_{\\text{exact}})^2$ 和精确通量平方 $(F_{\\text{exact}})^2$。\n5.  **误差分析**：遍历所有内部面后，使用累加的和计算相对 $L_2$ 误差 $E_{L_2}$。对每个指定的 $N$ 值（$8, 16, 32$）重复此过程。\n6.  **精度阶**：利用连续网格加密的误差 $E_{L_2}(N)$ 和 $E_{L_2}(2N)$，计算观测精度阶 $p$。\n7.  **输出**：收集 $s=0.0$ 和 $s=0.3$ 的最终结果，并按指定格式打印。该格式预期将表现出二阶精度（$p \\approx 2$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# This problem requires no external libraries beyond numpy.\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the numerical experiment as per the problem statement.\n    \"\"\"\n\n    # Global constants defined in the problem\n    K_TENSOR = np.array([[2.0, 0.5], [0.5, 1.5]])\n    PI = np.pi\n\n    def phi_func(x, y):\n        \"\"\"Manufactured scalar field phi(x,y).\"\"\"\n        return np.sin(PI * x) * np.cos(PI * y) + x**2 - y\n\n    def grad_phi_func(x, y):\n        \"\"\"Exact gradient of the manufactured scalar field.\"\"\"\n        grad_x = PI * np.cos(PI * x) * np.cos(PI * y) + 2 * x\n        grad_y = -PI * np.sin(PI * x) * np.sin(PI * y) - 1\n        return np.array([grad_x, grad_y])\n\n    def compute_errors_for_case(N, s):\n        \"\"\"\n        Computes the L2 error for a given grid size N and shear parameter s.\n        \"\"\"\n        # 1. Grid Generation\n        nodes = np.zeros((N + 1, N + 1, 2))\n        xi = np.linspace(0, 1, N + 1)\n        eta = np.linspace(0, 1, N + 1)\n        for j in range(N + 1):\n            for i in range(N + 1):\n                nodes[i, j, 0] = xi[i] + s * eta[j]\n                nodes[i, j, 1] = eta[j]\n\n        cell_centers = np.zeros((N, N, 2))\n        for j in range(N):\n            for i in range(N):\n                cell_centers[i, j] = 0.25 * (\n                    nodes[i, j] + nodes[i + 1, j] +\n                    nodes[i + 1, j + 1] + nodes[i, j + 1]\n                )\n\n        # 2. Evaluate exact values at cell centers\n        phi_at_centers = np.zeros((N, N))\n        grad_phi_at_centers = np.zeros((N, N, 2))\n        for j in range(N):\n            for i in range(N):\n                x_c, y_c = cell_centers[i, j]\n                phi_at_centers[i, j] = phi_func(x_c, y_c)\n                grad_phi_at_centers[i, j] = grad_phi_func(x_c, y_c)\n\n        # 3. Loop over interior faces and calculate fluxes\n        sum_sq_err = 0.0\n        sum_sq_exact = 0.0\n\n        all_faces_info = []\n\n        # Vertical interior faces\n        for j in range(N):\n            for i in range(N - 1):\n                # P = cell (i, j), N_cell = cell (i+1, j)\n                e0, e1 = nodes[i + 1, j], nodes[i + 1, j + 1]\n                all_faces_info.append(((i, j), (i + 1, j), e0, e1))\n\n        # Horizontal interior faces\n        for j in range(N - 1):\n            for i in range(N):\n                # P = cell (i, j), N_cell = cell (i, j+1)\n                # Tangent from right to left for upward normal\n                e0, e1 = nodes[i + 1, j + 1], nodes[i, j + 1]\n                all_faces_info.append(((i, j), (i, j + 1), e0, e1))\n\n        for P_idx, N_idx, e0, e1 in all_faces_info:\n            c_P = cell_centers[P_idx]\n            c_N = cell_centers[N_idx]\n\n            phi_P = phi_at_centers[P_idx]\n            phi_N = phi_at_centers[N_idx]\n            grad_phi_P = grad_phi_at_centers[P_idx]\n            grad_phi_N = grad_phi_at_centers[N_idx]\n\n            f_center = 0.5 * (e0 + e1)\n            t = e1 - e0\n            Sf = np.array([t[1], -t[0]])\n\n            d = c_N - c_P\n            # Ensure Sf points from P to N_cell\n            if np.dot(Sf, d)  0:\n                Sf = -Sf\n\n            # Exact flux calculation\n            grad_phi_f_exact = grad_phi_func(f_center[0], f_center[1])\n            F_exact = -Sf.T @ K_TENSOR @ grad_phi_f_exact\n\n            # Approximate flux calculation with non-orthogonal correction\n            d_norm = np.linalg.norm(d)\n            if d_norm == 0: continue\n            d_hat = d / d_norm\n            grad_phi_avg = 0.5 * (grad_phi_P + grad_phi_N)\n\n            correction_term = (\n                (phi_N - phi_P) / d_norm - np.dot(grad_phi_avg, d_hat)\n            ) * d_hat\n            grad_phi_f_approx = grad_phi_avg + correction_term\n            \n            F_approx = -Sf.T @ K_TENSOR @ grad_phi_f_approx\n            \n            sum_sq_err += (F_approx - F_exact)**2\n            sum_sq_exact += F_exact**2\n\n        # 4. Final L2 error calculation\n        if sum_sq_exact == 0:\n            return 0.0 # Avoid division by zero in trivial cases\n        \n        e_l2 = np.sqrt(sum_sq_err / sum_sq_exact)\n        return e_l2\n\n    def calculate_order(e1, e2, n_ratio=2.0):\n        \"\"\"Calculates the observed order of accuracy.\"\"\"\n        if e1 = 0 or e2 = 0:\n            return 0.0\n        return np.log(e1 / e2) / np.log(n_ratio)\n    \n    # Test cases parameters\n    test_cases = [\n        {'s': 0.0, 'N_values': [8, 16, 32]},\n        {'s': 0.3, 'N_values': [8, 16, 32]},\n    ]\n    \n    final_results = []\n    \n    for case in test_cases:\n        s = case['s']\n        N_values = case['N_values']\n        \n        errors = [compute_errors_for_case(N, s) for N in N_values]\n        \n        final_results.extend(errors)\n        \n        order1 = calculate_order(errors[0], errors[1])\n        order2 = calculate_order(errors[1], errors[2])\n        final_results.append(order1)\n        final_results.append(order2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.8f}' for val in final_results)}]\")\n\nsolve()\n```", "id": "3316543"}]}