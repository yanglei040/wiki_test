{"hands_on_practices": [{"introduction": "在计算流体力学中，验证我们数值解的正确性与精度是至关重要的一步。本练习将介绍“制造解方法”（Method of Manufactured Solutions, MMS），这是一种通过构建一个精确的解析解来严格评估数值方案收敛阶的强大技术。通过实现和比较中心差分、一阶迎风以及更先进的 Scharfetter–Gummel 格式，你将亲手验证这些基本离散格式的理论精度，并深入理解它们在不同物理情境下的表现[@problem_id:3311647]。", "problem": "考虑定义在有限区间上的具有常系数的稳态一维线性对流-扩散方程，通过引入总通量以守恒形式写出。设未知场为 $u(x)$，定义域为 $x \\in [0,1]$（单位：米），具有恒定的平流速度 $c$（单位：米/秒）和恒定的扩散系数 $D$（单位：平方米/秒）。其控制方程为\n$$\\frac{d}{dx}\\left(-D \\frac{du}{dx} + c\\,u\\right) = s(x), \\quad x \\in (0,1),$$\n这等价于非守恒形式\n$$c\\,\\frac{du}{dx} - D\\,\\frac{d^2 u}{dx^2} = s(x)。$$\n使用人造解法（Method of Manufactured Solutions）来验证三种空间算子通量离散化的空间精度阶，具体如下：\n- 对流通量采用二阶中心插值，扩散通量采用中心差分。\n- 对流通量采用一阶迎风插值，扩散通量采用中心差分。\n- 总通量采用 Scharfetter–Gummel (SG) 指数拟合格式，其中 Scharfetter–Gummel (SG) 指的是通过求解跨一个面、源项为零的局部稳态对流-扩散方程推导出的经典两点通量近似。\n\n您必须：\n- 选择人造解\n$$u(x) = e^{x}\\,\\sin(2\\pi x) + x(1-x),$$\n推导由控制方程所对应的源项 $s(x)$，并推断在 $x=0$ 和 $x=1$ 处的相容边界条件。\n- 使用空间算子 $c\\,u'(x) - D\\,u''(x)$ 的定义，通过对 $u(x)$ 进行必要的微分，从第一性原理推导 $s(x)$。边界条件必须直接取自 $u(x)$，以使精确解通过构造满足边界条件。\n- 设计一个基于节点的均匀网格，该网格包含 $N$ 个大小为 $h=1/N$ 的相等子区间，节点为 $x_i = i h$，其中 $i \\in \\{0,1,\\dots,N\\}$。对每个内部节点 $x_i$（$i \\in \\{1,2,\\dots,N-1\\}$）周围的控制体应用有限体积平衡。对每个控制体上的源项使用中点积分。施加由人造解在 $x=0$ 和 $x=1$ 处确定的狄利克雷边界条件。\n\n您的程序必须为每种格式构建并求解所得到的线性系统，并计算网格节点上与精确解 $u(x)$ 的误差。使用离散类 $L^2$ 范数\n$$E(h) = \\sqrt{h \\sum_{i=0}^{N} \\left(u_i^{\\text{num}} - u(x_i)\\right)^2}。$$\n通过在网格序列上的对数-对数关系 $\\log E(h) \\approx \\alpha + p \\log h$ 中的最佳拟合斜率来估计观测精度阶 $p$。\n\n科学和数值规范：\n- 物理单位：长度单位为米，时间单位为秒，速度单位为米/秒，扩散系数单位为平方米/秒。最终输出报告为无量纲实数。\n- 角度单位：弧度。\n- 对所有测试使用以下网格尺寸：$N \\in \\{40, 80, 160, 320\\}$。\n- 使用以下参数测试套件（每一项为一个测试用例）：\n  1. 正常情况，中等对流-扩散：$(c, D) = (1.0, 0.1)$。\n  2. 边值问题边缘情况，纯扩散：$(c, D) = (0.0, 0.1)$。\n  3. 在所选网格上接近对流占优但仍稳定：$(c, D) = (1.0, 0.025)$。\n- 对于每个测试用例，计算三种格式（中心差分、迎风和 Scharfetter–Gummel）中每一种的观测阶 $p$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的9个结果列表，结果按测试用例然后按格式排序，即\n$$[p_{\\text{central},1},p_{\\text{upwind},1},p_{\\text{SG},1},p_{\\text{central},2},p_{\\text{upwind},2},p_{\\text{SG},2},p_{\\text{central},3},p_{\\text{upwind},3},p_{\\text{SG},3}],$$\n其中下标表示 $(\\text{scheme}, \\text{test case index})$，测试用例索引按上述顺序排列。将每个 $p$ 表示为小数点后保留三位的小数。", "solution": "该问题被评估为**有效**。它具有科学依据、良定、客观且完整，为获得唯一解提供了所有必要信息。\n\n### 1. 人造解与源项\n我们采用人造解法（Method of Manufactured Solutions, MMS）来验证实现。我们选择一个光滑函数，即人造解 $u(x)$，并将其代入控制微分方程，以找到相应的源项 $s(x)$。这个过程保证我们有一个精确解，可以用来衡量我们数值格式的误差。\n\n指定的人造解是：\n$$ u(x) = e^{x}\\,\\sin(2\\pi x) + x(1-x) $$\n问题定义在域 $x \\in [0, 1]$ 上。狄利克雷边界条件通过在边界处计算 $u(x)$ 得到：\n$$ u(0) = e^{0}\\,\\sin(0) + 0(1-0) = 0 $$\n$$ u(1) = e^{1}\\,\\sin(2\\pi) + 1(1-1) = 0 $$\n因此，我们在离散问题中施加 $u_0 = 0$ 和 $u_N = 0$。\n\n源项 $s(x)$ 从控制方程的非守恒形式 $s(x) = c\\,u'(x) - D\\,u''(x)$ 推导得出。我们首先计算 $u(x)$ 的一阶和二阶导数：\n$$ u'(x) = \\frac{d}{dx} \\left( e^{x}\\,\\sin(2\\pi x) + x - x^2 \\right) = e^x \\sin(2\\pi x) + 2\\pi e^x \\cos(2\\pi x) + 1 - 2x $$\n$$ u''(x) = \\frac{d}{dx} u'(x) = \\left( e^x \\sin(2\\pi x) + 2\\pi e^x \\cos(2\\pi x) \\right) + \\left( 2\\pi e^x \\cos(2\\pi x) - 4\\pi^2 e^x \\sin(2\\pi x) \\right) - 2 $$\n$$ u''(x) = (1 - 4\\pi^2) e^x \\sin(2\\pi x) + 4\\pi e^x \\cos(2\\pi x) - 2 $$\n将这些结合起来，源项为：\n$$ s(x) = c \\left( e^x \\sin(2\\pi x) + 2\\pi e^x \\cos(2\\pi x) + 1 - 2x \\right) - D \\left( (1 - 4\\pi^2) e^x \\sin(2\\pi x) + 4\\pi e^x \\cos(2\\pi x) - 2 \\right) $$\n\n### 2. 有限体积离散化\n我们将域 $[0, 1]$ 离散为 $N$ 个宽度为 $h=1/N$ 的均匀子区间。节点位于 $x_i = i h$，其中 $i=0, 1, \\dots, N$。有限体积法通过将方程的守恒形式 $\\frac{dF}{dx} = s(x)$（其中 $F(x) = -D \\frac{du}{dx} + c\\,u$ 是总通量）在以每个内部节点 $x_i$ 为中心的控制体（CV）上积分来应用。节点 $i$ 的控制体是 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i \\pm 1/2} = x_i \\pm h/2$。\n\n在第 $i$ 个长度为 $h$ 的控制体上的积分方程是：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{dF}{dx} \\,dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} s(x) \\,dx $$\n对左侧应用微积分基本定理，对右侧积分应用中点法则，得到每个内部节点 $i \\in \\{1, \\dots, N-1\\}$ 的半离散方程：\n$$ F_{i+1/2} - F_{i-1/2} \\approx h \\cdot s(x_i) $$\n这里，$F_{i \\pm 1/2}$ 表示在控制体边界面 $x_{i \\pm 1/2}$ 处计算的总通量。\n\n### 3. 通量离散化格式\n该问题要求比较三种不同的格式来近似节点 $j$ 和 $j+1$ 之间的边界面通量 $F_{j+1/2}$。通量的扩散部分 $-D \\frac{du}{dx}$ 始终使用二阶中心差分近似：$-D \\frac{u_{j+1} - u_j}{h}$。这些格式在对流通量项 $c u$ 的近似上有所不同。\n\n设通量以一般形式写为 $F_{j+1/2} = \\mathcal{A}_{j+1/2} u_j + \\mathcal{B}_{j+1/2} u_{j+1}$。\n\n**a) 中心差分格式 (CD):**\n对流项使用二阶中心插值，$u_{j+1/2} \\approx (u_j + u_{j+1})/2$。\n$$ F_{j+1/2}^{\\text{CD}} = -D \\frac{u_{j+1} - u_j}{h} + c \\frac{u_j + u_{j+1}}{2} = \\left(\\frac{D}{h} + \\frac{c}{2}\\right) u_j + \\left(-\\frac{D}{h} + \\frac{c}{2}\\right) u_{j+1} $$\n该格式名义上是二阶精度 ($p=2$)，但当单元佩克莱特数 (Péclet number) $Pe_h = |c|h/D > 2$ 时，已知会变得不稳定并产生非物理振荡。\n\n**b) 迎风格式 (UDS):**\n对流项使用一阶迎风插值，其中 $u$ 的边界面值取自上游节点。\n$$ u_{j+1/2} \\approx \\begin{cases} u_j  \\text{if } c \\ge 0 \\\\ u_{j+1}  \\text{if } c  0 \\end{cases} $$\n这可以紧凑地写为 $u_{j+1/2} \\approx \\frac{1+\\text{sgn}(c)}{2} u_j + \\frac{1-\\text{sgn}(c)}{2} u_{j+1}$。总通量为：\n$$ F_{j+1/2}^{\\text{UDS}} = -D \\frac{u_{j+1} - u_j}{h} + \\max(c, 0) u_j + \\min(c, 0) u_{j+1} = \\left(\\frac{D}{h} + \\max(c, 0)\\right) u_j + \\left(-\\frac{D}{h} + \\min(c, 0)\\right) u_{j+1} $$\n该格式是一阶精度 ($p=1$)，但无论佩克莱特数如何，它都具有鲁棒的稳定性。在 $c=0$ 的特殊情况下，它正确地简化为纯扩散的二阶中心差分格式。\n\n**c) Scharfetter–Gummel 格式 (SG):**\n该格式是通过求解两个节点之间的局部齐次方程（无源）$-D u'' + c u' = 0$ 的精确解，然后计算得到的常数通量而推导出来的。通量使用伯努利函数 $B(z) = z/(e^z - 1)$ 表示：\n$$ F_{j+1/2}^{\\text{SG}} = \\frac{D}{h} \\left( B(-Pe_h) u_j - B(Pe_h) u_{j+1} \\right) $$\n其中 $Pe_h = ch/D$ 是单元佩克莱特数。SG 格式在 $Pe_h \\to 0$ 时（此时 $B(z) \\to 1 - z/2$）平滑过渡到中心差分格式，在 $|Pe_h| \\to \\infty$ 时过渡到迎风格式。由于它对于方程的齐次部分是精确的，其精度由源项近似决定，而源项通过中点法则是二阶的。因此，SG 格式预期为二阶精度 ($p=2$)。\n\n### 4. 线性系统构建与求解\n对于均匀网格，通量系数 $\\mathcal{A}$ 和 $\\mathcal{B}$ 对所有面都是常数。我们将其表示为 $\\mathcal{A}_f$ 和 $\\mathcal{B}_f$。将通量表达式代入有限体积平衡方程得到：\n$$ (\\mathcal{A}_f u_i + \\mathcal{B}_f u_{i+1}) - (\\mathcal{A}_f u_{i-1} + \\mathcal{B}_f u_i) = h s(x_i) $$\n对未知数 $u_{i-1}, u_i, u_{i+1}$ 进行整理：\n$$ (-\\mathcal{A}_f) u_{i-1} + (\\mathcal{A}_f - \\mathcal{B}_f) u_i + (\\mathcal{B}_f) u_{i+1} = h s(x_i) $$\n此方程对每个内部节点 $i=1, \\dots, N-1$ 成立。在边界处，对于 $i=1$，项 $(-\\mathcal{A}_f)u_0$ 移到右侧。对于 $i=N-1$，项 $(\\mathcal{B}_f)u_N$ 移到右侧。由于 $u_0=u_N=0$，这些项为零。这就形成了一个关于未知内部节点值向量 $\\mathbf{U} = [u_1, \\dots, u_{N-1}]^T$ 的三对角线性系统 $\\mathbf{A} \\mathbf{U} = \\mathbf{b}$。求解该系统即可得到数值解。\n\n### 5. 误差分析与精度阶\n数值解的误差是相对于精确的人造解，使用离散类 $L^2$ 范数来衡量：\n$$ E(h) = \\sqrt{h \\sum_{i=0}^{N} \\left(u_i^{\\text{num}} - u(x_i)\\right)^2} $$\n求和包括边界节点，根据构造，边界节点的误差为零。为了估计精度阶 $p$，我们对一系列减小的网格尺寸 $h$（对应于 $N \\in \\{40, 80, 160, 320\\}$）计算误差 $E(h)$。假设误差行为如 $E(h) \\approx C h^p$（其中 $C$ 为某个常数），我们可以取对数：\n$$ \\log E(h) \\approx \\log C + p \\log h $$\n精度阶 $p$ 是误差对网格尺寸的对数-对数图中的直线斜率。我们使用线性最小二乘法拟合计算出的 $(\\log h, \\log E)$ 数据点来确定此斜率。对三种格式和三个测试用例中的每一个重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the verification study for the 1D convection-diffusion equation.\n    It computes the order of accuracy for three different spatial discretization schemes\n    across three different physical parameter sets.\n    \"\"\"\n    \n    # Define problem parameters from the statement.\n    test_cases = [\n        (1.0, 0.1),    # Case 1: Moderate advection-diffusion\n        (0.0, 0.1),    # Case 2: Pure diffusion\n        (1.0, 0.025),  # Case 3: Near convection-dominated\n    ]\n    schemes = ['central', 'upwind', 'sg']\n    N_values = [40, 80, 160, 320]\n    \n    # --- Helper Functions ---\n\n    def u_exact(x):\n        \"\"\" The manufactured solution u(x). \"\"\"\n        return np.exp(x) * np.sin(2 * np.pi * x) + x * (1 - x)\n\n    def s_source(x, c, D):\n        \"\"\" The source term s(x) derived from the manufactured solution. \"\"\"\n        u_prime = (np.exp(x) * (np.sin(2 * np.pi * x) + 2 * np.pi * np.cos(2 * np.pi * x)) \n                   + 1 - 2 * x)\n        u_double_prime = (np.exp(x) * ((1 - 4 * np.pi**2) * np.sin(2 * np.pi * x) \n                                     + 4 * np.pi * np.cos(2 * np.pi * x)) \n                          - 2)\n        return c * u_prime - D * u_double_prime\n\n    def bernoulli(z):\n        \"\"\" \n        Robust implementation of the Bernoulli function B(z) = z / (exp(z) - 1).\n        Handles limits for small and large |z| to avoid numerical issues.\n        \"\"\"\n        if abs(z)  1e-9:\n            # Taylor expansion for small z to avoid 0/0\n            return 1.0 - 0.5 * z + (z**2) / 12.0\n        elif z > 700:\n            # Asymptotic value for large positive z to avoid overflow\n            return 0.0\n        elif z  -700:\n            # Asymptotic value for large negative z\n            return -z\n        else:\n            return z / np.expm1(z)\n            \n    def get_flux_coeffs(scheme, c, D, h):\n        \"\"\" \n        Computes the coefficients for the flux F_{j+1/2} = A_f*u_j + B_f*u_{j+1}.\n        \"\"\"\n        if scheme == 'central':\n            A_f = D / h + c / 2.0\n            B_f = -D / h + c / 2.0\n        elif scheme == 'upwind':\n            A_f = D / h + max(c, 0.0)\n            B_f = -D / h + min(c, 0.0)\n        elif scheme == 'sg':\n            if c == 0.0:\n                 # Pure diffusion limit\n                A_f = D / h\n                B_f = -D / h\n            else:\n                Pe_h = c * h / D\n                B_Pe_h = bernoulli(Pe_h)\n                B_minus_Pe_h = bernoulli(-Pe_h)\n                A_f = (D / h) * B_minus_Pe_h\n                B_f = -(D / h) * B_Pe_h\n        return A_f, B_f\n        \n    def run_single_sim(N, c, D, scheme):\n        \"\"\" \n        Assembles and solves the linear system for a given mesh size and scheme.\n        Returns the discrete L2-like error.\n        \"\"\"\n        h = 1.0 / N\n        x = np.linspace(0.0, 1.0, N + 1)\n        \n        # Dirichlet boundary conditions from manufactured solution\n        u_bc0 = u_exact(x[0])\n        u_bc1 = u_exact(x[-1])\n\n        # Get flux coefficients which are constant on a uniform grid\n        A_f, B_f = get_flux_coeffs(scheme, c, D, h)\n        \n        # Assemble the tridiagonal system Ax=b for interior nodes\n        num_unknowns = N - 1\n        \n        # The banded matrix 'ab' for scipy.linalg.solve_banded\n        # Shape is (l+u+1, M) -> (3, N-1)\n        ab = np.zeros((3, num_unknowns))\n        ab[0, 1:] = B_f          # Upper diagonal\n        ab[1, :] = A_f - B_f     # Main diagonal\n        ab[2, :-1] = -A_f        # Lower diagonal\n        \n        # Assemble the right-hand side vector\n        b = h * s_source(x[1:-1], c, D)\n        \n        # Apply boundary conditions\n        b[0] -= (-A_f) * u_bc0\n        b[-1] -= B_f * u_bc1\n\n        # Solve the linear system\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Combine with boundary values to get full solution\n        u_num = np.concatenate(([u_bc0], u_interior, [u_bc1]))\n        \n        # Compute error norm\n        u_ex = u_exact(x)\n        error = np.sqrt(h * np.sum((u_num - u_ex)**2))\n        \n        return error\n\n    def calculate_order(c, D, scheme):\n        \"\"\"\n        Computes the order of accuracy p for a given scheme and parameters\n        by running simulations on a sequence of refined meshes.\n        \"\"\"\n        errors = []\n        h_values = []\n        \n        for N in N_values:\n            h = 1.0 / N\n            h_values.append(h)\n            error = run_single_sim(N, c, D, scheme)\n            errors.append(error)\n\n        # Use polyfit on log-log data to find the slope (order of accuracy)\n        log_h = np.log(h_values)\n        log_e = np.log(errors)\n        p, _ = np.polyfit(log_h, log_e, 1)\n        \n        return abs(p)\n\n    # --- Main Execution Logic ---\n    \n    all_results = []\n    for c_val, D_val in test_cases:\n        for scheme_name in schemes:\n            p_val = calculate_order(c_val, D_val, scheme_name)\n            all_results.append(p_val)\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(f'{p:.3f}' for p in all_results)}]\")\n\nsolve()\n```", "id": "3311647"}, {"introduction": "超越了形式上的收敛阶，我们如何更精细地评估数值解的质量？本练习将带你深入探讨模拟波传播时两种主要的数值误差：数值耗散（导致振幅衰减）和数值色散（导致相位偏移）。你将学习运用傅里叶分析这一强大工具，来量化一个可调参数的混合格式所产生的幅值和相位误差，并通过系统地寻优来最小化它们的综合影响，从而获得更高保真度的数值结果[@problem_id:3311680]。", "problem": "考虑一个长度为 $L$ 的周期性定义域上的一维线性对流-扩散方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in [0,L), \\ t \\ge 0,\n$$\n其中对流速度 $a0$ 为严格正的常数，运动扩散系数 $\\nu \\ge 0$ 为常数。初始条件为高斯函数，\n$$\nu(x,0) = \\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right),\n$$\n其中 $x_0 \\in [0,L)$ 是中心位置，$\\sigma0$ 表征初始宽度。使用具有 $N$ 个点的均匀网格，网格间距为 $\\Delta x = L/N$，并采用周期性边界条件。\n\n空间导数按如下方式离散化：\n- 对于一阶导数，使用一个混合了中心差分和迎风差分的单参数族，\n$$\n\\left(D^{(1)}_\\beta u\\right)_i = \\frac{1-\\beta}{2\\Delta x}\\left(u_{i+1}-u_{i-1}\\right) + \\frac{\\beta}{\\Delta x}\\left(u_i - u_{i-1}\\right),\n$$\n其中索引 $i$ 对 $N$ 取模，$\\beta \\in [0,1]$ 是迎风偏置参数。此定义假设 $a0$。\n- 对于二阶导数，使用标准的中心差分，\n$$\n\\left(D^{(2)} u\\right)_i = \\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2}.\n$$\n\n令 $T = L/a$ 表示一个对流回转时间。在一个回转时间内，连续问题的精确解会将高斯函数在定义域内平流一圈并使其扩散。$T$ 时刻的精确解是一个以 $x_0$ 为中心、振幅为\n$$\nA_{\\text{exact}} = \\frac{\\sigma}{\\sqrt{\\sigma^2 + \\nu T}},\n$$\n且位置仍为 $x_0$ (对 $L$ 取模) 的高斯函数。\n\n对半离散系统进行时间离散化\n$$\n\\frac{d \\boldsymbol{u}}{dt} = -a D^{(1)}_\\beta \\boldsymbol{u} + \\nu D^{(2)} \\boldsymbol{u}\n$$\n使用三阶强保稳龙格－库塔方法 (SSP-RK3)。选择时间步长 $\\Delta t$ 以同时满足对流和扩散的显式稳定性限制，\n$$\n\\Delta t \\le \\text{CFL}\\,\\frac{\\Delta x}{a}, \\qquad \\Delta t \\le C_\\nu\\,\\frac{\\Delta x^2}{\\nu} \\ \\ (\\text{if } \\nu0),\n$$\n其中系数 $\\text{CFL} \\in (0,1)$ 和 $C_\\nu \\in (0,1)$ 是预设的，并取整数个时间步数 $n$ 使得 $n\\Delta t = T$。\n\n在 $T$ 时刻定义两个定量诊断量：\n- 数值振幅 $A_{\\text{num}} = \\max_i u_i(T)$。\n- 通过循环质心计算数值相位位置，\n$$\nx_{\\text{num}} = \\frac{L}{2\\pi} \\operatorname{Arg}\\left(\\sum_{i=0}^{N-1} u_i(T)\\, e^{\\mathrm{i}\\, 2\\pi x_i/L}\\right) \\bmod L,\n$$\n以及最小周期相位误差\n$$\n\\Delta x = \\operatorname{mod}\\left(x_{\\text{num}} - x_0 + \\frac{L}{2},\\, L\\right) - \\frac{L}{2}.\n$$\n\n使用精确解来诊断一个回转时间后的两个误差：\n- 振幅衰减误差 $E_A = \\left|A_{\\text{num}} - A_{\\text{exact}}\\right|/A_{\\text{exact}}$。\n- 相位误差 $E_\\phi = \\left|\\Delta x\\right|/\\sigma$。\n\n通过最小化组合目标函数来校准迎风偏置参数 $\\beta$\n$$\nJ(\\beta) = \\frac{1}{2} \\left(E_A + E_\\phi\\right),\n$$\n在一个候选值 $\\beta \\in [0, \\beta_{\\max}]$ 的均匀网格上进行，其中 $\\beta_{\\max}0$ 且步长 $\\Delta\\beta0$ 固定。时间积分器为 SSP-RK3，空间算子如上定义。为保证可复现性，使用离散傅里叶表示，通过在半离散算子的傅里叶符号上评估 SSP-RK3 稳定性多项式 $P(z) = 1 + z + \\tfrac{1}{2}z^2 + \\tfrac{1}{6}z^3$，在 $n$ 个大小为 $\\Delta t = T/n$ 的相等时间步长上应用线性更新。算法必须是自包含的，且不得依赖外部数据。\n\n所有量均为无量纲；不需要物理单位。\n\n测试套件。对于下面的每个测试用例，在搜索集合 $\\{\\beta_k = k\\,\\Delta\\beta \\mid k=0,1,\\dots, K\\}$ 上最小化 $J(\\beta)$，其中 $\\beta_{\\max} = K\\,\\Delta\\beta$：\n- 测试 1：$L=10$, $N=256$, $a=1$, $\\nu=10^{-2}$, $\\sigma=0.5$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n- 测试 2：$L=10$, $N=256$, $a=1$, $\\nu=0$, $\\sigma=0.5$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n- 测试 3：$L=10$, $N=64$, $a=1$, $\\nu=5\\times 10^{-3}$, $\\sigma=0.7$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n- 测试 4：$L=10$, $N=256$, $a=2$, $\\nu=5\\times 10^{-3}$, $\\sigma=0.5$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含四个最小化 $\\beta$ 值，每个值四舍五入到三位小数，以逗号分隔列表的形式包含在方括号内（例如，$[\\beta_1,\\beta_2,\\beta_3,\\beta_4]$）。不应打印任何其他文本。", "solution": "用户提供了一个计算流体力学中的适定问题。任务是为求解一维线性对流-扩散方程的有限差分格式找到一个最优的迎风偏置参数 $\\beta$。该优化基于最小化一个对流回转时间后的振幅和相位组合误差度量。\n\n控制方程是长度为 $L$ 的周期性定义域上的线性对流-扩散方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其初始条件由一个高斯函数给出：\n$$\nu(x,0) = \\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\n$$\n所有参数 $L, a, \\nu, \\sigma, x_0$ 均为给定常数。该定义域使用 $N$ 个均匀间隔的网格点 $x_i = i \\Delta x$ (其中 $i=0, \\dots, N-1$) 进行离散化，网格间距为 $\\Delta x = L/N$。\n\n空间导数使用有限差分进行离散化。由此产生的半离散系统可以写成关于网格点值向量 $\\boldsymbol{u}(t)$ 的常微分方程组 (ODEs)：\n$$\n\\frac{d \\boldsymbol{u}}{dt} = \\boldsymbol{L}_\\beta \\boldsymbol{u}\n$$\n其中 $\\boldsymbol{L}_\\beta$ 是表示空间离散化的线性算子：\n$$\n\\boldsymbol{L}_\\beta = -a D^{(1)}_\\beta + \\nu D^{(2)}\n$$\n离散算子 $D^{(1)}_\\beta$ 和 $D^{(2)}$ 定义如下：\n$$\n\\left(D^{(1)}_\\beta u\\right)_i = \\frac{1-\\beta}{2\\Delta x}\\left(u_{i+1}-u_{i-1}\\right) + \\frac{\\beta}{\\Delta x}\\left(u_i - u_{i-1}\\right)\n$$\n$$\n\\left(D^{(2)} u\\right)_i = \\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2}\n$$\n\n在周期性定义域上求解这种具有常系数的线性系统的一种高效方法是使用离散傅里叶变换 (DFT)。DFT 可以对角化任何循环矩阵，而我们在周期性网格上的离散算子正是由这类矩阵表示的。令 $\\hat{\\boldsymbol{u}}(t)$ 为 $\\boldsymbol{u}(t)$ 的 DFT。该常微分方程组转换为一组解耦的标量常微分方程，每个傅里叶模式 $k$ 对应一个方程：\n$$\n\\frac{d\\hat{u}_k}{dt} = \\hat{L}_\\beta(k)\\hat{u}_k\n$$\n这里，$\\hat{L}_\\beta(k)$ 是算子 $\\boldsymbol{L}_\\beta$ 的傅里叶符号（特征值），对应于离散波数 $k_p = 2\\pi p / L$ (其中 $p = 0, \\dots, N-1$）。各个差分算子的符号是通过将它们应用于傅里叶模式 $e^{\\mathrm{i}k x_j} = e^{\\mathrm{i} (k \\Delta x)j}$ 推导出来的。令 $\\theta_k = k \\Delta x$。\n一阶导数算子的符号是：\n$$\n\\hat{d}^{(1)}_\\beta(k) = \\frac{\\mathrm{i}\\sin(\\theta_k)}{\\Delta x} + \\frac{\\beta(1-\\cos(\\theta_k))}{\\Delta x}\n$$\n二阶导数算子的符号是：\n$$\n\\hat{d}^{(2)}(k) = \\frac{2(\\cos(\\theta_k)-1)}{\\Delta x^2}\n$$\n将这些组合起来，得到完整算子 $\\boldsymbol{L}_\\beta$ 的符号：\n$$\n\\hat{L}_\\beta(k) = -a \\hat{d}^{(1)}_\\beta(k) + \\nu \\hat{d}^{(2)}(k)\n$$\n\n问题指定使用 SSP-RK3 方法在总时间 $T = L/a$ 上进行时间积分。时间区间被划分为 $n$ 个步长为 $\\Delta t = T/n$ 的时间步。步数 $n$ 选择为满足对流和扩散的显式稳定性条件的最小整数。$n$ 步之后，傅里叶空间中的解由下式给出：\n$$\n\\hat{u}_k(T) = \\left[ P\\left(\\hat{L}_\\beta(k) \\Delta t\\right) \\right]^n \\hat{u}_k(0)\n$$\n其中 $P(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$ 是 SSP-RK3 方法的稳定性多项式，而 $\\hat{u}_k(0)$ 是初始条件的 DFT。通过对 $\\hat{\\boldsymbol{u}}(T)$ 应用逆 DFT，可以恢复最终的数值解 $\\boldsymbol{u}(T)$。\n\n为了找到最优的 $\\beta$，我们评估两个误差度量：\n1.  **振幅衰减误差 ($E_A$)**：$T$ 时刻的精确解是一个振幅为 $A_{\\text{exact}} = \\sigma / \\sqrt{\\sigma^2 + \\nu T}$ 的高斯函数。数值振幅为 $A_{\\text{num}} = \\max_i u_i(T)$。误差为 $E_A = |A_{\\text{num}} - A_{\\text{exact}}|/A_{\\text{exact}}$。\n2.  **相位误差 ($E_\\phi$)**：数值相位位置 $x_{\\text{num}}$ 使用质心公式计算，该公式对应于第一傅里叶模式的相位：\n    $$\n    x_{\\text{num}} = \\frac{L}{2\\pi} \\operatorname{Arg}\\left(\\sum_{i=0}^{N-1} u_i(T)\\, e^{\\mathrm{i}\\, 2\\pi x_i/L}\\right) \\bmod L\n    $$\n    该求和等价于 $\\boldsymbol{u}(T)$ 的 DFT 的 $k=-1$ 分量，该分量可以从 $\\hat{\\boldsymbol{u}}(T)$ 中直接获得。最小周期相位误差为 $\\Delta x = \\operatorname{mod}(x_{\\text{num}} - x_0 + L/2, L) - L/2$。无量纲相位误差为 $E_\\phi = |\\Delta x|/\\sigma$。\n\n需要最小化的目标函数是 $J(\\beta) = \\frac{1}{2} (E_A + E_\\phi)$。最小化是通过在指定的 $\\beta$ 候选值的离散集合上进行网格搜索来执行的。对于每个测试用例，选择产生最小 $J(\\beta)$ 的 $\\beta$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_optimal_beta(L, N, a, nu, sigma, x0, CFL, C_nu, delta_beta, beta_max):\n    \"\"\"\n    Solves the 1D linear convection-diffusion equation and finds the optimal\n    upwind-bias parameter beta by minimizing a combined error metric.\n    \"\"\"\n    # Grid and initial condition\n    dx = L / N\n    x = np.arange(N) * dx\n    # The initial condition is a non-periodic Gaussian. This is a common simplification\n    # when sigma  L, as the periodic wrap-around effects are negligible.\n    u0 = np.exp(-(x - x0)**2 / (4 * sigma**2))\n    u0_hat = np.fft.fft(u0)\n\n    # Time step calculation\n    T = L / a\n    # Number of steps n must be large enough to satisfy CFL conditions.\n    # n >= (T * a) / (CFL * dx) = (L/a * a) / (CFL * L/N) = N/CFL\n    n_conv = N / CFL\n    # n >= (T * nu) / (C_nu * dx^2) = (L/a * nu) / (C_nu * (L/N)^2) = nu*N^2 / (a*C_nu*L)\n    n_diff = (nu * N**2) / (a * C_nu * L) if nu > 0 else 0\n    n_steps = int(np.ceil(max(n_conv, n_diff)))\n    dt = T / n_steps\n\n    # Wavenumbers for Fourier analysis\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    theta = k * dx\n\n    # Exact amplitude at time T\n    A_exact = sigma / np.sqrt(sigma**2 + nu * T)\n\n    # Grid search for optimal beta\n    beta_candidates = np.arange(0.0, beta_max + delta_beta / 2, delta_beta)\n    min_J = float('inf')\n    optimal_beta = -1.0\n\n    for beta in beta_candidates:\n        # Fourier symbol of the semi-discrete operator L_beta\n        # Symbol for first derivative operator D^(1)_beta\n        d1_hat = (1j * np.sin(theta) / dx) + (beta * (1 - np.cos(theta)) / dx)\n        # Symbol for second derivative operator D^(2)\n        d2_hat = (2 * (np.cos(theta) - 1)) / dx**2\n        \n        L_hat = -a * d1_hat + nu * d2_hat\n        \n        # Evolve in Fourier space using SSP-RK3 stability polynomial\n        z = L_hat * dt\n        P_z = 1 + z + 0.5 * z**2 + (1/6.0) * z**3\n        uT_hat = u0_hat * (P_z**n_steps)\n\n        # Transform back to physical space\n        uT = np.fft.ifft(uT_hat).real\n\n        # Calculate amplitude error\n        A_num = np.max(uT)\n        E_A = np.abs(A_num - A_exact) / A_exact\n\n        # Calculate phase error\n        # The sum is the k=-1 component of the DFT of uT, which is uT_hat[-1]\n        # In numpy's fft, this corresponds to the last element of the array.\n        Z = uT_hat[-1]\n        x_num = (L / (2 * np.pi) * np.angle(Z)) % L\n        \n        # Minimal periodic phase error\n        dx_error = (x_num - x0 + L / 2) % L - L / 2\n        E_phi = np.abs(dx_error) / sigma\n\n        # Objective function\n        J = 0.5 * (E_A + E_phi)\n\n        if J  min_J:\n            min_J = J\n            optimal_beta = beta\n\n    return optimal_beta\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: L=10, N=256, a=1, nu=10^-2, sigma=0.5, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 256, 1.0, 1e-2, 0.5, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n        # Test 2: L=10, N=256, a=1, nu=0, sigma=0.5, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 256, 1.0, 0.0, 0.5, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n        # Test 3: L=10, N=64, a=1, nu=5x10^-3, sigma=0.7, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 64, 1.0, 5e-3, 0.7, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n        # Test 4: L=10, N=256, a=2, nu=5x10^-3, sigma=0.5, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 256, 2.0, 5e-3, 0.5, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n    ]\n\n    results = []\n    for params in test_cases:\n        optimal_beta = find_optimal_beta(*params)\n        results.append(optimal_beta)\n\n    # Format the results as specified\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3311680"}]}