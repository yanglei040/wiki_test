{"hands_on_practices": [{"introduction": "在计算流体动力学（CFD）中，准确核算能量通量至关重要，尤其是在处理移动边界问题时。此练习 [@problem_id:3358314] 要求我们从第一性原理出发，推导移动无滑移壁面附近的机械能平衡方程，并精确识别壁面做功项。通过一个经典的解析解案例，它揭示了在数值实现中一个常见的错误来源，从而加深对雷诺输运定理物理内涵的理解。", "problem": "考虑一个邻近运动的、不可渗透的无滑移壁面的粘性不可压缩流体，其瞬时壁面速度表示为 $\\boldsymbol{U}_w(t)$。选取一个控制体 $\\mathsf{CV}$，使其紧贴壁面并沿壁面与壁面一起运动，从而使与壁面重合的控制面部分具有等于 $\\boldsymbol{U}_w(t)$ 的边界速度。您的任务是从第一性原理出发，使用 Reynolds 输运定理为 $\\mathsf{CV}$ 内的流体建立机械能平衡方程，并明确识别出运动无滑移壁面的精确壁面功项。\n\n使用的基本原理和定义：\n- Newton 第二定律和 Cauchy 应力张量 $\\boldsymbol{\\sigma} = -p \\boldsymbol{I} + 2 \\mu \\boldsymbol{S}$，其中 $\\mu$ 是动力粘度，$p$ 是压力，$\\boldsymbol{S} = \\tfrac{1}{2} \\left( \\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\mathsf{T}} \\right)$ 是应变率张量。\n- 单位体积的总机械能密度为 $e_m = \\tfrac{1}{2} \\rho \\lvert \\boldsymbol{u} \\rvert^2 + \\rho \\Phi$，其中 $\\rho$ 是质量密度，$\\Phi$ 是单位质量势能（在验证案例中取 $\\Phi = 0$）。\n- 对于通用标量 $\\phi(\\boldsymbol{x},t)$ 的 Reynolds 输运定理：$\\dfrac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} \\rho \\, \\phi \\, \\mathrm{d}V = \\int_{\\mathsf{CV}} \\dfrac{\\partial}{\\partial t}(\\rho \\phi) \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} \\rho \\, \\phi \\, (\\boldsymbol{u} - \\boldsymbol{u}_{\\mathsf{CS}}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A$，其中 $\\boldsymbol{u}_{\\mathsf{CS}}$ 是局部控制面速度，$\\boldsymbol{n}$ 是从 $\\mathsf{CV}$ 指出的外向单位法向量。\n\n要求 A：基于这些原理，推导紧贴无滑移壁面的运动控制体的机械能平衡方程，并识别出精确的壁面功项。清楚地说明为什么在控制面的壁面部分 $A_w$ 上，正确的壁面功项是 $\\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A$，其中 $\\boldsymbol{t}_w = \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}$ 是壁面对流体施加的面力（$\\boldsymbol{n}$ 是从流体指向壁面的外法线）。\n\n要求 B（验证案例）：考虑半无限空间 $y \\ge 0$ 中的 Stokes 第一问题，其中位于 $y=0$ 的平板在 $t>0$ 时以恒定的切向速度 $U$ 沿 $x$ 方向开始运动。流体初始静止 $\\boldsymbol{u}(\\boldsymbol{x},0) = \\boldsymbol{0}$，且忽略重力，因此 $\\Phi = 0$。使用 Stokes 第一问题的精确速度场，计算单位壁面面积上的以下三个量：\n- 单位面积的壁面输入功率 $P_{\\text{wall}}(t) = \\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A$，用 $\\mu$、$U$、运动粘度 $\\nu = \\mu/\\rho$ 和时间 $t$ 表示。\n- 单位面积的粘性耗散率 $D(t) = \\mu \\int_0^\\infty \\left( \\dfrac{\\partial u}{\\partial y} \\right)^2 \\mathrm{d}y$。\n- 单位面积的流体内机械能的精确变化率 $E'(t) = \\dfrac{\\mathrm{d}}{\\mathrm{d}t} \\int_0^\\infty \\tfrac{1}{2} \\rho u(y,t)^2 \\, \\mathrm{d}y$。\n验证平衡关系 $E'(t) = P_{\\text{wall}}(t) - D(t)$。\n\n要求 C（误差量化）：假设一个不正确的实现使用了壁面处的相对速度，将壁面功 $\\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A$ 替换为 $\\int_{A_w} \\boldsymbol{t}_w \\cdot (\\boldsymbol{u} - \\boldsymbol{U}_w) \\, \\mathrm{d}A$。对于无滑移壁面，在 $A_w$ 上有 $\\boldsymbol{u} = \\boldsymbol{U}_w$，这将错误地导致壁面功率为零。通过将不正确的壁面功率代入机械能平衡方程，定义不正确的变化率 $E'_{\\text{wrong}}(t)$。计算无量纲相对误差\n$$\\varepsilon(t) = \\frac{E'_{\\text{wrong}}(t) - E'(t)}{E'(t)},$$\n以及无量纲归一化预算残差\n$$R(t) = \\frac{E'(t) - \\big( P_{\\text{wall}}(t) - D(t) \\big)}{E'(t)}.$$\n\n您的程序必须实现该验证案例，并为以下参数值 $(\\rho,\\mu,U,t)$ 的测试套件计算 $\\varepsilon(t)$ 和 $R(t)$：\n- 案例 1：$(1000, 0.001, 0.5, 0.1)$，\n- 案例 2：$(1000, 1.0, 0.3, 0.5)$，\n- 案例 3：$(1.225, 1.8 \\times 10^{-5}, 2.0, 10^{-4})$，\n- 案例 4：$(1.225, 1.8 \\times 10^{-5}, 2.0, 0.05)$，\n- 案例 5：$(860, 0.05, 1.2, 10)$。\n\n所有输出都必须是无量纲数。您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，每个元素对应一个测试案例，并且本身是一个双元素列表 $[\\varepsilon(t), R(t)]$。例如，输出必须具有以下精确格式\n$$\\big[ [\\varepsilon_1, R_1], [\\varepsilon_2, R_2], \\ldots \\big].$$", "solution": "该问题经评估是有效的，因为它在科学上基于连续介质力学原理，是适定的、客观的且内部一致的。\n\n解决方案分为三部分呈现，分别对应问题的各项要求。\n\n### 要求 A：机械能平衡方程的推导\n\n我们的目标是推导邻近无滑移壁面的运动控制体 $\\mathsf{CV}$ 的机械能平衡方程。我们从 Cauchy 动量方程开始，这是流体连续体 Newton 第二定律的微分形式。对于密度为 $\\rho$、速度为 $\\boldsymbol{u}$ 的不可压缩流体，在受到体积力 $\\rho \\boldsymbol{g}$ 和由 Cauchy 应力张量 $\\boldsymbol{\\sigma}$ 描述的面力作用下，其方程为：\n$$\n\\rho \\frac{D\\boldsymbol{u}}{D t} = \\nabla \\cdot \\boldsymbol{\\sigma} + \\rho \\boldsymbol{g}\n$$\n其中 $\\frac{D}{Dt} = \\frac{\\partial}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla$ 是物质导数。\n\n为了获得能量方程，我们将动量方程与流体速度 $\\boldsymbol{u}$ 做点积：\n$$\n\\rho \\boldsymbol{u} \\cdot \\frac{D\\boldsymbol{u}}{D t} = \\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma}) + \\rho \\boldsymbol{u} \\cdot \\boldsymbol{g}\n$$\n左侧的项可以重写为单位质量动能 $\\frac{1}{2} |\\boldsymbol{u}|^2$ 的物质导数：\n$$\n\\rho \\frac{D}{Dt} \\left( \\frac{1}{2} |\\boldsymbol{u}|^2 \\right) = \\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma}) + \\rho \\boldsymbol{u} \\cdot \\boldsymbol{g}\n$$\n我们假设体积力是守恒的，即 $\\boldsymbol{g} = -\\nabla\\Phi$，其中 $\\Phi$ 是单位质量势能。如果 $\\Phi$ 与时间无关，则 $\\rho \\boldsymbol{u} \\cdot \\boldsymbol{g} = -\\rho \\boldsymbol{u} \\cdot \\nabla\\Phi = -\\rho \\frac{D\\Phi}{Dt}$。将此项移到左侧，我们得到总机械能密度 $e_m = \\frac{1}{2}\\rho|\\boldsymbol{u}|^2 + \\rho\\Phi$ 的变化率：\n$$\n\\rho \\frac{D}{Dt} \\left( \\frac{1}{2} |\\boldsymbol{u}|^2 + \\Phi \\right) = \\frac{D e_m}{Dt} = \\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma})\n$$\n右侧的项表示单位体积内应力所做的功的速率。利用矢量恒等式 $\\nabla \\cdot (\\boldsymbol{A} \\cdot \\boldsymbol{v}) = (\\nabla \\cdot \\boldsymbol{A}^{\\mathsf{T}}) \\cdot \\boldsymbol{v} + \\boldsymbol{A}^{\\mathsf{T}} : (\\nabla \\boldsymbol{v})$ 以及应力张量的对称性（$\\boldsymbol{\\sigma}^{\\mathsf{T}} = \\boldsymbol{\\sigma}$），我们可以写出：\n$$\n\\boldsymbol{u} \\cdot (\\nabla \\cdot \\boldsymbol{\\sigma}) = \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) - \\boldsymbol{\\sigma} : \\nabla\\boldsymbol{u}\n$$\n机械能密度方程变为：\n$$\n\\frac{D e_m}{Dt} = \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) - \\boldsymbol{\\sigma} : \\nabla\\boldsymbol{u}\n$$\n项 $\\boldsymbol{\\sigma} : \\nabla\\boldsymbol{u}$ 是变形功的速率。对于牛顿流体，$\\boldsymbol{\\sigma} = -p\\boldsymbol{I} + 2\\mu\\boldsymbol{S}$。对于不可压缩流体，$\\nabla \\cdot \\boldsymbol{u} = 0$，因此功的压力部分为 $-p\\boldsymbol{I}:\\nabla\\boldsymbol{u} = -p(\\nabla \\cdot \\boldsymbol{u}) = 0$。粘性部分为 $2\\mu\\boldsymbol{S}:\\nabla\\boldsymbol{u}$。由于 $\\nabla\\boldsymbol{u} = \\boldsymbol{S} + \\boldsymbol{\\Omega}$，其中 $\\boldsymbol{S}$ 是对称的应变率张量，$\\boldsymbol{\\Omega}$ 是反对称的自旋张量，且对称张量与反对称张量的双点积为零（$\\boldsymbol{S}:\\boldsymbol{\\Omega}=0$），我们有 $2\\mu\\boldsymbol{S}:\\nabla\\boldsymbol{u} = 2\\mu\\boldsymbol{S}:\\boldsymbol{S}$。该项通常表示为 $\\Psi_v$，代表单位体积机械能因粘性耗散不可逆地转化为热的速率。它总是非负的。\n\n展开物质导数，机械能平衡的微分形式为：\n$$\n\\frac{\\partial e_m}{\\partial t} + \\nabla \\cdot (e_m \\boldsymbol{u}) = \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) - \\Psi_v\n$$\n现在，我们对该方程在运动控制体 $\\mathsf{CV}(t)$ 上积分：\n$$\n\\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V + \\int_{\\mathsf{CV}} \\nabla \\cdot (e_m \\boldsymbol{u}) \\, \\mathrm{d}V = \\int_{\\mathsf{CV}} \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\, \\mathrm{d}V - \\int_{\\mathsf{CV}} \\Psi_v \\, \\mathrm{d}V\n$$\n对通量项应用散度定理：\n$$\n\\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u} \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A = \\int_{\\mathsf{CS}} (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A - \\int_{\\mathsf{CV}} \\Psi_v \\, \\mathrm{d}V\n$$\n对于标量（这里是 $e_m$）的 Reynolds 输运定理是：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} e_m \\, \\mathrm{d}V = \\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u}_{\\mathsf{CS}} \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A\n$$\n整理可得：$\\int_{\\mathsf{CV}} \\frac{\\partial e_m}{\\partial t} \\, \\mathrm{d}V = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} e_m \\, \\mathrm{d}V - \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u}_{\\mathsf{CS}} \\cdot \\boldsymbol{n}) \\, \\mathrm{d}A$。将此式代入我们的积分能量方程，得到：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{\\mathsf{CV}} e_m \\, \\mathrm{d}V + \\int_{\\mathsf{CS}} e_m (\\boldsymbol{u} - \\boldsymbol{u}_{\\mathsf{CS}}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A = \\int_{\\mathsf{CS}} (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A - \\int_{\\mathsf{CV}} \\Psi_v \\, \\mathrm{d}V\n$$\n这是最终的积分形式机械能平衡方程。项 $\\int_{\\mathsf{CS}} (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{u}) \\cdot \\boldsymbol{n} \\, \\mathrm{d}A$ 是控制体内流体受到的面力所做的总功的速率。面力矢量定义为 $\\boldsymbol{t} = \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}$。所以该项为 $\\int_{\\mathsf{CS}} \\boldsymbol{t} \\cdot \\boldsymbol{u} \\, \\mathrm{d}A$。\n\n我们现在关注与壁面重合的控制面部分 $A_w$。壁面功项是该积分在 $A_w$ 上的部分：\n$$\nP_w = \\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{u} \\, \\mathrm{d}A\n$$\n其中 $\\boldsymbol{t}_w$ 是壁面对流体施加的面力。由于无滑移条件，壁面处的流体速度等于壁面速度：在 $A_w$ 上有 $\\boldsymbol{u} = \\boldsymbol{U}_w$。将此代入积分，我们得到精确的壁面功项：\n$$\nP_w = \\int_{A_w} \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w \\, \\mathrm{d}A\n$$\n该项表示运动壁面对流体做功的速率。另一种公式 $\\int_{A_w} \\boldsymbol{t}_w \\cdot (\\boldsymbol{u} - \\boldsymbol{U}_w) \\mathrm{d}A$ 在计算输入功方面是根本错误的。功是力与作用点速度的点积，对于壁面边界，该速度为 $\\boldsymbol{U}_w$。相对速度项 $(\\boldsymbol{u} - \\boldsymbol{U}_w)$ 在无滑移壁面上恒等于零，这将错误地意味着零功输入。\n\n### 要求 B：Stokes 第一问题的验证案例\n\n我们考虑在 $y=0$ 处的平板以速度 $U$ 沿 $x$ 方向开始运动所产生的流动。速度场为 $\\boldsymbol{u}(y,t) = u(y,t)\\boldsymbol{i}$，其中\n$$\nu(y,t) = U \\operatorname{erfc}\\left(\\frac{y}{2\\sqrt{\\nu t}}\\right)\n$$\n我们计算单位壁面面积上的所需量。控制体包含每单位面积的整个流体域，因此积分范围是从 $y=0$ 到 $\\infty$。\n\n1.  **壁面输入功率 $P_{\\text{wall}}(t)$：**\n    $P_{\\text{wall}}(t) = \\boldsymbol{t}_w \\cdot \\boldsymbol{U}_w$。壁面速度为 $\\boldsymbol{U}_w = U\\boldsymbol{i}$。在壁面处，从流体指出的外法线为 $\\boldsymbol{n} = -\\boldsymbol{j}$。对流体的面力为 $\\boldsymbol{t}_w = \\boldsymbol{\\sigma}|_{y=0} \\cdot \\boldsymbol{n}$。唯一非零的应力剪切分量是 $\\sigma_{yx} = \\mu \\frac{\\partial u}{\\partial y}$。面力矢量为 $\\boldsymbol{t}_w = -\\sigma_{yx}|_{y=0} \\boldsymbol{i} = -\\mu \\left(\\frac{\\partial u}{\\partial y}\\right)_{y=0} \\boldsymbol{i}$。\n    我们计算速度梯度：\n    $$\n    \\frac{\\partial u}{\\partial y} = U \\frac{\\mathrm{d}}{\\mathrm{d}y}\\left(\\frac{2}{\\sqrt{\\pi}}\\int_{y/(2\\sqrt{\\nu t})}^\\infty e^{-\\xi^2} d\\xi \\right) = U \\left(-\\frac{2}{\\sqrt{\\pi}} e^{-y^2/(4\\nu t)}\\right) \\frac{1}{2\\sqrt{\\nu t}} = -\\frac{U}{\\sqrt{\\pi \\nu t}} e^{-y^2/(4\\nu t)}\n    $$\n    在壁面处（$y=0$）：$\\left(\\frac{\\partial u}{\\partial y}\\right)_{y=0} = -\\frac{U}{\\sqrt{\\pi \\nu t}}$。\n    单位面积的功率输入为：\n    $$\n    P_{\\text{wall}}(t) = \\left(-\\mu \\left(-\\frac{U}{\\sqrt{\\pi \\nu t}}\\right) \\boldsymbol{i}\\right) \\cdot (U\\boldsymbol{i}) = \\frac{\\mu U^2}{\\sqrt{\\pi \\nu t}}\n    $$\n\n2.  **粘性耗散率 $D(t)$：**\n    $D(t) = \\mu \\int_0^\\infty \\left( \\frac{\\partial u}{\\partial y} \\right)^2 \\mathrm{d}y$。\n    $$\n    D(t) = \\mu \\int_0^\\infty \\left(-\\frac{U}{\\sqrt{\\pi \\nu t}} e^{-y^2/(4\\nu t)}\\right)^2 \\mathrm{d}y = \\frac{\\mu U^2}{\\pi \\nu t} \\int_0^\\infty e^{-y^2/(2\\nu t)} \\mathrm{d}y\n    $$\n    这是一个标准的高斯积分，$\\int_0^\\infty e^{-ay^2} \\mathrm{d}y = \\frac{1}{2}\\sqrt{\\frac{\\pi}{a}}$。当 $a = 1/(2\\nu t)$ 时，积分为 $\\frac{1}{2}\\sqrt{2\\pi\\nu t}$。\n    $$\n    D(t) = \\frac{\\mu U^2}{\\pi \\nu t} \\left(\\frac{\\sqrt{2\\pi\\nu t}}{2}\\right) = \\frac{\\mu U^2}{\\sqrt{2\\pi \\nu t}}\n    $$\n\n3.  **机械能变化率 $E'(t)$：**\n    $E'(t) = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_0^\\infty \\frac{1}{2} \\rho u(y,t)^2 \\mathrm{d}y$。首先，我们计算总动能 $E(t)$：\n    $$\n    E(t) = \\frac{1}{2}\\rho U^2 \\int_0^\\infty \\left[\\operatorname{erfc}\\left(\\frac{y}{2\\sqrt{\\nu t}}\\right)\\right]^2 \\mathrm{d}y\n    $$\n    令 $z = y/(2\\sqrt{\\nu t})$，则 $\\mathrm{d}y = 2\\sqrt{\\nu t} \\, \\mathrm{d}z$。\n    $$\n    E(t) = \\frac{1}{2}\\rho U^2 (2\\sqrt{\\nu t}) \\int_0^\\infty [\\operatorname{erfc}(z)]^2 \\mathrm{d}z = \\rho U^2 \\sqrt{\\nu t} \\int_0^\\infty [\\operatorname{erfc}(z)]^2 \\mathrm{d}z\n    $$\n    该定积分为一个已知常数：$\\int_0^\\infty [\\operatorname{erfc}(z)]^2 \\mathrm{d}z = \\frac{2-\\sqrt{2}}{\\sqrt{\\pi}}$。\n    $$\n    E(t) = \\rho U^2 \\sqrt{\\nu t} \\left(\\frac{2-\\sqrt{2}}{\\sqrt{\\pi}}\\right)\n    $$\n    现在，对时间 $t$ 求导：\n    $$\n    E'(t) = \\frac{\\mathrm{d}E}{\\mathrm{d}t} = \\rho U^2 \\left(\\frac{2-\\sqrt{2}}{\\sqrt{\\pi}}\\right) \\sqrt{\\nu} \\cdot \\frac{1}{2\\sqrt{t}} = \\frac{\\rho U^2(2-\\sqrt{2})}{2\\sqrt{\\pi}}\\sqrt{\\frac{\\nu}{t}}\n    $$\n    验证：我们检验是否 $E'(t) = P_{\\text{wall}}(t) - D(t)$。使用 $\\mu = \\rho\\nu$：\n    $$\n    P_{\\text{wall}}(t) - D(t) = \\frac{\\rho\\nu U^2}{\\sqrt{\\pi\\nu t}} - \\frac{\\rho\\nu U^2}{\\sqrt{2\\pi\\nu t}} = \\rho U^2 \\sqrt{\\frac{\\nu}{\\pi t}} \\left(1-\\frac{1}{\\sqrt{2}}\\right) = \\rho U^2 \\sqrt{\\frac{\\nu}{t}} \\frac{\\sqrt{2}-1}{\\sqrt{2\\pi}}\n    $$\n    分子和分母同乘以 $\\sqrt{2}$：\n    $$\n    P_{\\text{wall}}(t) - D(t) = \\rho U^2 \\sqrt{\\frac{\\nu}{t}} \\frac{2-\\sqrt{2}}{2\\sqrt{\\pi}}\n    $$\n    该表达式与我们得到的 $E'(t)$ 结果完全相同。能量平衡得到验证。\n\n### 要求 C：误差量化\n\n不正确的实现使用了壁面功率 $P'_{\\text{wall}} = \\int_{A_w} \\boldsymbol{t}_w \\cdot (\\boldsymbol{u} - \\boldsymbol{U}_w) \\, \\mathrm{d}A$。对于无滑移壁面，在 $A_w$ 上有 $\\boldsymbol{u} = \\boldsymbol{U}_w$，因此 $P'_{\\text{wall}}=0$。不正确的能量变化率为 $E'_{\\text{wrong}}(t) = P'_{\\text{wall}}(t) - D(t) = -D(t)$。\n\n1.  **无量纲相对误差 $\\varepsilon(t)$：**\n    $$\n    \\varepsilon(t) = \\frac{E'_{\\text{wrong}}(t) - E'(t)}{E'(t)} = \\frac{-D(t) - (P_{\\text{wall}}(t) - D(t))}{P_{\\text{wall}}(t) - D(t)} = \\frac{-P_{\\text{wall}}(t)}{P_{\\text{wall}}(t) - D(t)}\n    $$\n    我们代入 $P_{\\text{wall}}(t)$ 和 $D(t)$ 的表达式：\n    $$\n    \\varepsilon(t) = \\frac{-\\frac{\\mu U^2}{\\sqrt{\\pi \\nu t}}}{\\frac{\\mu U^2}{\\sqrt{\\pi \\nu t}} - \\frac{\\mu U^2}{\\sqrt{2\\pi \\nu t}}} = \\frac{-1}{1 - 1/\\sqrt{2}} = \\frac{-\\sqrt{2}}{\\sqrt{2}-1}\n    $$\n    分母有理化得到：\n    $$\n    \\varepsilon(t) = \\frac{-\\sqrt{2}(\\sqrt{2}+1)}{(\\sqrt{2}-1)(\\sqrt{2}+1)} = -(2+\\sqrt{2})\n    $$\n    这是一个常数，与所有问题参数 $(\\rho, \\mu, U, t)$ 无关。\n\n2.  **无量纲归一化预算残差 $R(t)$：**\n    $$\n    R(t) = \\frac{E'(t) - \\big( P_{\\text{wall}}(t) - D(t) \\big)}{E'(t)}\n    $$\n    如在 B 部分所验证的，对于精确解，分子恒等于零，因为 $E'(t) = P_{\\text{wall}}(t) - D(t)$。只要 $E'(t) \\neq 0$（这对任何有限的 $t>0$ 都成立），残差就是：\n    $$\n    R(t) = 0\n    $$\n    这也是一个常数，与所有问题参数无关。\n\n下面的程序将为每个测试案例计算这些常数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes error metrics for an energy balance calculation in a fluid mechanics problem.\n\n    The problem analyzes the mechanical energy balance for Stokes' first problem.\n    It's shown analytically that the dimensionless relative error (epsilon) and\n    the normalized budget residual (R) are constants, independent of the physical\n    parameters of the specific test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1000, 0.001, 0.5, 0.1),\n        (1000, 1.0, 0.3, 0.5),\n        (1.225, 1.8e-5, 2.0, 1e-4),\n        (1.225, 1.8e-5, 2.0, 0.05),\n        (860, 0.05, 1.2, 10),\n    ]\n\n    # As derived in the solution, the dimensionless relative error epsilon\n    # is a constant value. The derivation is as follows:\n    # epsilon = -P_wall / (P_wall - D)\n    # The ratio of dissipation to wall power is D/P_wall = 1/sqrt(2).\n    # So, epsilon = -1 / (1 - 1/sqrt(2))\n    # Simplifying this expression gives epsilon = -(2 + sqrt(2)).\n    epsilon = -(2.0 + np.sqrt(2.0))\n\n    # The normalized budget residual R(t) is defined as:\n    # R(t) = (E'(t) - (P_wall(t) - D(t))) / E'(t)\n    # The analytical solution demonstrated that the energy balance\n    # E'(t) = P_wall(t) - D(t) holds exactly.\n    # Therefore, the numerator is zero, and R(t) = 0 for all t > 0.\n    residual = 0.0\n\n    results = []\n    # The loop is maintained to match the specified output format,\n    # even though the results are identical for all test cases.\n    for _ in test_cases:\n        results.append([epsilon, residual])\n\n    # Format the final output string as a comma-separated list of two-element lists,\n    # matching the format [[e1, R1], [e2, R2], ...].\n    result_str = \",\".join([f\"[{e},{r}]\" for e, r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3358314"}, {"introduction": "在海洋学和气象学等领域，我们常常通过稀疏的漂流浮标（拉格朗日数据点）来观测流场，而非拥有完整的速度场信息。此练习 [@problem_id:3358328] 演示了如何将雷诺输运定理应用于这些浮标构成的物质区域，从而估计出流场的关键宏观属性，如散度和示踪剂源汇项。这项实践将理论与实际的数据分析技术紧密联系起来。", "problem": "给定一组漂流点观测数据，这些数据在每个时间点构成一个水平二维流体域中的简单多边形移动控制体。这些点是理想的中性浮力拉格朗日漂流浮标，因此每个点都随着当地的水平速度移动。每个漂流浮标在其瞬时位置对一个标量示踪剂场进行采样。您的任务是：从第一性原理出发，使用移动控制体的雷诺输运定理，推导如何从稀疏的拉格朗日数据中推断出面积平均的表面散度和示踪剂的面积平均源率；然后，实现一个数值算法，从两个连续的快照中估算这些量。\n\n您可以使用的基本出发点：\n- 随速度场 $\\boldsymbol{u}(\\boldsymbol{x},t)$ 移动的物质区域的几何面积守恒，以及散度 $\\nabla \\cdot \\boldsymbol{u}$ 的定义。\n- 单位面积示踪剂密度 $c(\\boldsymbol{x},t)$ 在速度场 $\\boldsymbol{u}$ 输运下且存在源项 $\\sigma(\\boldsymbol{x},t)$ 时的标量守恒，不提供任何捷径公式。\n- 在二维空间中有效的基础向量微积分定理。\n\n您必须：\n- 仅基于上述基本原理，推导将控制体面积的时间变化率与控制区域上 $\\nabla \\cdot \\boldsymbol{u}$ 的空间平均值联系起来的表达式，以及将面积积分示踪剂的时间变化率与面积平均源率联系起来的表达式。\n- 设计一个离散算法，仅使用两个时间点 $t_0$ 和 $t_1=t_0+\\Delta t$ 的漂流浮标位置及其示踪剂测量值来估算：\n  - 中点时间 $t_{1/2}=t_0+\\Delta t/2$ 的面积平均散度 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$，单位为 $\\mathrm{s}^{-1}$，\n  - 中点时间 $t_{1/2}$ 的面积平均源率 $\\overline{\\sigma}$，单位为示踪剂单位/秒。\n- 您的算法必须使用鞋带公式近似多边形面积，通过多边形三角剖分（扇形三角剖分）近似面积平均示踪剂，并使用 $\\Delta t$ 上的有限差分近似时间导数。所有漂流浮标数据都是稀疏的，且仅在顶点处给出；没有内部信息可用。\n\n数值测试套件：\n对于每个测试，漂流浮标在 $t_0$ 时刻被初始化，形成一个简单的凸多边形，其顶点坐标以米为单位，按逆时针顺序列出。速度场和示踪剂演变在科学上是合理的且自洽的。对于每个测试，从指定的场生成 $t_1$ 时刻的漂流浮标位置及其在 $t_0$ 和 $t_1$ 时刻的示踪剂值，然后应用您的算法估算 $t_{1/2}$ 时刻的面积平均散度和面积平均源。角度（如果使用）以弧度为单位。\n\n- 测试A（均匀面积扩张，无源物质示踪剂）：\n  - 参数：$\\lambda = 2\\times 10^{-5}\\ \\mathrm{s}^{-1}$，$\\Delta t = 10000\\ \\mathrm{s}$。\n  - 速度：$\\boldsymbol{u}(x,y,t) = \\left(\\frac{\\lambda}{2} x,\\ \\frac{\\lambda}{2} y\\right)$。\n  - 漂流浮标运动：$\\Delta t$ 后的精确位置为 $(x_1,y_1) = \\left(x_0 e^{\\lambda \\Delta t/2},\\ y_0 e^{\\lambda \\Delta t/2}\\right)$。\n  - 示踪剂动力学：无源物质，因此沿轨迹 $c$ 满足 $\\mathrm{d}c/\\mathrm{d}t + c\\,\\nabla \\cdot \\boldsymbol{u} = 0$。对于均匀初始值 $c_0=5$（任意单位），在 $t_1$ 时刻每个漂流浮标处的精确示踪剂值为 $c_1 = c_0 e^{-\\lambda \\Delta t}$。\n  - $t_0$ 时刻的初始多边形顶点（米）：$(0,0)$, $(1000,0)$, $(1000,500)$, $(0,500)$。\n\n- 测试B（不可压缩剪切，均匀示踪剂源）：\n  - 参数：$S = 10^{-4}\\ \\mathrm{s}^{-1}$，$\\Delta t = 5000\\ \\mathrm{s}$，均匀源 $\\sigma_0=10^{-2}$（任意示踪剂单位/秒）。\n  - 速度：$\\boldsymbol{u}(x,y,t) = (S y,\\ 0)$。\n  - 漂流浮标运动：$\\Delta t$ 后的精确位置为 $(x_1,y_1) = (x_0 + S y_0 \\Delta t,\\ y_0)$。\n  - 示踪剂动力学：$\\partial_t c + \\nabla \\cdot (c \\boldsymbol{u}) = \\sigma_0$，初始 $c_0=1$ 为均匀值。每个漂流浮标处的精确示踪剂值为 $c_1 = c_0 + \\sigma_0 \\Delta t$。\n  - $t_0$ 时刻的初始多边形顶点（米）：$(0,0)$, $(1000,0)$, $(1500,500)$, $(500,500)$。\n\n- 测试C（刚体旋转，轴对称示踪剂，无源）：\n  - 参数：$\\Omega = 10^{-4}\\ \\mathrm{s}^{-1}$，$\\Delta t = 2000\\ \\mathrm{s}$。\n  - 速度：$\\boldsymbol{u}(x,y,t) = (-\\Omega y,\\ \\Omega x)$。\n  - 漂流浮标运动：$\\Delta t$ 后的精确位置为 $(x_1,y_1) = (x_0 \\cos(\\Omega \\Delta t) - y_0 \\sin(\\Omega \\Delta t),\\ x_0 \\sin(\\Omega \\Delta t) + y_0 \\cos(\\Omega \\Delta t))$。\n  - 示踪剂：$c(x,y,t) = c_0 + \\alpha (x^2+y^2)$，其中 $c_0=2$，$\\alpha=10^{-5}$（任意单位/$\\mathrm{m}^2$）。在刚体旋转和无源的情况下，该示踪剂场是稳定的且物质守恒，因此每个漂流浮标的示踪剂值保持不变：$c_1=c_0(x_0,y_0)$。\n  - $t_0$ 时刻的初始多边形顶点（米）：$(1000,0)$, $(1500,500)$, $(1000,1000)$, $(500,500)$。\n\n实现要求：\n- 使用鞋带公式计算 $t_0$ 和 $t_1$ 时刻的多边形面积。使用面积的绝对值，单位为 $\\mathrm{m}^2$。\n- 通过从第一个顶点进行扇形剖分，将多边形三角化为不重叠的三角形，来计算 $t_0$ 和 $t_1$ 时刻的面积平均示踪剂 $\\bar{c}$。假设 $c$ 在每个三角形上线性变化，其三角形平均值等于其顶点值的平均值。\n- 通过将有限差分面积变化率除以中点面积来估算 $t_{1/2}$ 时刻的面积平均散度（单位为 $\\mathrm{s}^{-1}$）。通过将面积平均示踪剂的有限差分变化率与中点面积平均示踪剂和估算的面积平均散度的乘积相结合，来估算 $t_{1/2}$ 时刻的面积平均源（单位为示踪剂单位/秒）。\n- 单位：位置以米为单位，时间以秒为单位，散度以 $\\mathrm{s}^{-1}$ 为单位，源以示踪剂单位/秒为单位。将最终的数值输出表示为浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格的列表的列表：按 A、B、C 的顺序为每个测试提供一个内部列表，每个内部列表包含两个数字，顺序为 [$\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$, $\\overline{\\sigma}$]。例如，一个语法上有效的输出看起来像 \"[[0.0,0.0],[0.0,0.0],[0.0,0.0]]\"，但使用的是您计算出的数字。", "solution": "任务是推导并实现一种方法，用于从定义移动多边形控制体的拉格朗日漂流浮标数据中估算面积平均散度 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$ 和面积平均示踪剂源率 $\\overline{\\sigma}$。推导从连续介质力学和向量微积分的基本原理开始。\n\n### 1. 理论推导\n\n分析的基础是应用于二维移动控制区域的雷诺输运定理 (RTT)。该控制体由一组拉格朗日漂流浮标定义，这意味着其边界随当地流体速度移动。这样的体积被称为物质体积。\n\n#### 1.1 物质区域的雷诺输运定理\n设 $A_c(t)$ 是一个随流体速度场 $\\boldsymbol{u}(\\boldsymbol{x}, t)$ 移动的物质控制区域，并设 $S_c(t)$ 是其边界。对于任何内含性质 $f(\\boldsymbol{x}, t)$，$A_c(t)$ 内 $f$ 总量的时间变化率由 RTT 的积分形式给出。对于一个物质体积，其边界随流体速度 $\\boldsymbol{u}$ 移动，RTT 简化为：\n$$\n\\frac{d}{dt} \\int_{A_c(t)} f \\, dA = \\int_{A_c(t)} \\left( \\frac{\\partial f}{\\partial t} + \\nabla \\cdot (f \\boldsymbol{u}) \\right) \\, dA\n$$\n\n#### 1.2 面积平均散度\n为了将控制体面积的变化率与流体散度联系起来，我们将 RTT 应用于内含性质设为1的情况，即 $f=1$。在面积 $A_c(t)$ 上对 $f=1$ 的积分就是面积本身 $A_c$。\n$$\n\\frac{d A_c}{dt} = \\frac{d}{dt} \\int_{A_c(t)} 1 \\, dA\n$$\n将 $f=1$ 代入物质区域的 RTT：\n$$\n\\frac{d A_c}{dt} = \\int_{A_c(t)} \\left( \\frac{\\partial 1}{\\partial t} + \\nabla \\cdot (1 \\cdot \\boldsymbol{u}) \\right) \\, dA = \\int_{A_c(t)} (\\nabla \\cdot \\boldsymbol{u}) \\, dA\n$$\n控制区域上散度的空间平均值，记为 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$，定义为：\n$$\n\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\int_{A_c(t)} (\\nabla \\cdot \\boldsymbol{u}) \\, dA\n$$\n通过结合前两个方程，我们得到了所需的关系：\n$$\n\\frac{d A_c}{dt} = A_c \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle\n$$\n或者，表示为面积平均散度：\n$$\n\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\frac{d A_c}{dt} = \\frac{d (\\ln A_c)}{dt}\n$$\n这个结果表明，物质区域的面积分数变化率等于速度场的面积平均散度。\n\n#### 1.3 面积平均示踪剂源率\n单位面积标量示踪剂浓度 $c(\\boldsymbol{x}, t)$，在速度 $\\boldsymbol{u}$ 输运和源项 $\\sigma(\\boldsymbol{x}, t)$ 作用下的守恒定律为：\n$$\n\\frac{\\partial c}{\\partial t} + \\nabla \\cdot (c \\boldsymbol{u}) = \\sigma\n$$\n我们将这个守恒方程在物质控制区域 $A_c(t)$ 上积分：\n$$\n\\int_{A_c(t)} \\left( \\frac{\\partial c}{\\partial t} + \\nabla \\cdot (c \\boldsymbol{u}) \\right) \\, dA = \\int_{A_c(t)} \\sigma \\, dA\n$$\n根据物质区域的 RTT（其中 $f=c$），左侧恰好是积分量的全时间导数：\n$$\n\\frac{d}{dt} \\int_{A_c(t)} c \\, dA = \\int_{A_c(t)} \\left( \\frac{\\partial c}{\\partial t} + \\nabla \\cdot (c \\boldsymbol{u}) \\right) \\, dA\n$$\n因此，我们得到了一个简单而有力的结果：物质体积中示踪剂总量的变化率等于该体积内的总源量：\n$$\n\\frac{d}{dt} \\int_{A_c(t)} c \\, dA = \\int_{A_c(t)} \\sigma \\, dA\n$$\n我们定义面积平均示踪剂浓度 $\\bar{c} = \\frac{1}{A_c} \\int_{A_c(t)} c \\, dA$ 和面积平均源率 $\\overline{\\sigma} = \\frac{1}{A_c} \\int_{A_c(t)} \\sigma \\, dA$。上述方程可以重写为：\n$$\n\\frac{d (A_c \\bar{c})}{dt} = A_c \\overline{\\sigma}\n$$\n对左侧应用乘积法则求导，得到：\n$$\n\\bar{c} \\frac{d A_c}{dt} + A_c \\frac{d \\bar{c}}{dt} = A_c \\overline{\\sigma}\n$$\n除以面积 $A_c$（假设 $A_c > 0$）：\n$$\n\\bar{c} \\left( \\frac{1}{A_c} \\frac{d A_c}{dt} \\right) + \\frac{d \\bar{c}}{dt} = \\overline{\\sigma}\n$$\n最后，代入面积平均散度的表达式 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\frac{d A_c}{dt}$：\n$$\n\\overline{\\sigma} = \\frac{d \\bar{c}}{dt} + \\bar{c} \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle\n$$\n这就是所需的关系式，它将面积平均源率与面积平均示踪剂的变化率以及面积平均散度的稀释/浓缩效应联系起来。\n\n### 2. 数值算法设计\n\n必须将连续关系离散化，才能应用于两个离散时间点 $t_0$ 和 $t_1=t_0+\\Delta t$ 的观测数据。我们使用在中间时间点 $t_{1/2} = t_0 + \\Delta t/2$ 求值的二阶精确中心有限差分格式。\n\n#### 2.1 散度估算器\n公式 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle = \\frac{1}{A_c} \\frac{dA_c}{dt}$ 按如下方式离散化：\n在 $t_{1/2}$ 处的时间导数 $\\frac{dA_c}{dt}$ 通过中心差分近似：\n$$ \\left. \\frac{d A_c}{dt} \\right|_{t_{1/2}} \\approx \\frac{A_c(t_1) - A_c(t_0)}{\\Delta t} $$\n在 $t_{1/2}$ 处的面积 $A_c$ 通过平均值近似：\n$$ A_c(t_{1/2}) \\approx \\frac{A_c(t_0) + A_c(t_1)}{2} $$\n结合这些，在 $t_{1/2}$ 处的面积平均散度的估算值为：\n$$\n\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle_{1/2} \\approx \\frac{(A_1 - A_0) / \\Delta t}{(A_0 + A_1) / 2} = \\frac{2}{\\Delta t} \\frac{A_1 - A_0}{A_1 + A_0}\n$$\n其中 $A_0 = A_c(t_0)$ 且 $A_1 = A_c(t_1)$。\n\n#### 2.2 源率估算器\n公式 $\\overline{\\sigma} = \\frac{d\\bar{c}}{dt} + \\bar{c} \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle$ 同样在 $t_{1/2}$ 处进行离散化：\n平均示踪剂的时间导数近似为：\n$$ \\left. \\frac{d \\bar{c}}{dt} \\right|_{t_{1/2}} \\approx \\frac{\\bar{c}_1 - \\bar{c}_0}{\\Delta t} $$\n中点处的平均示踪剂通过平均值近似：\n$$ \\bar{c}(t_{1/2}) \\approx \\frac{\\bar{c}_0 + \\bar{c}_1}{2} $$\n面积平均散度取自上一步的估算值 $\\langle \\nabla \\cdot \\boldsymbol{u} \\rangle_{1/2}$。结合这些，可得出面积平均源率的估算器：\n$$\n\\overline{\\sigma}_{1/2} \\approx \\frac{\\bar{c}_1 - \\bar{c}_0}{\\Delta t} + \\left( \\frac{\\bar{c}_0 + \\bar{c}_1}{2} \\right) \\langle \\nabla \\cdot \\boldsymbol{u} \\rangle_{1/2}\n$$\n其中 $\\bar{c}_0 = \\bar{c}(t_0)$ 且 $\\bar{c}_1 = \\bar{c}(t_1)$。\n\n#### 2.3 几何与示踪剂计算\n离散估算器需要面积 ($A_0, A_1$) 和平均示踪剂浓度 ($\\bar{c}_0, \\bar{c}_1$) 的值。\n- **多边形面积：** 由 $N$ 个顶点 $(x_1, y_1), \\dots, (x_N, y_N)$ 定义的多边形面积使用鞋带公式计算：\n$$ A = \\frac{1}{2} \\left| \\sum_{i=1}^{N} (x_i y_{i+1} - x_{i+1} y_i) \\right| $$\n其中 $(x_{N+1}, y_{N+1}) = (x_1, y_1)$。此公式应用于 $t_0$ 和 $t_1$ 时刻的顶点坐标。\n\n- **面积平均示踪剂：** 面积平均示踪剂 $\\bar{c}$ 通过对多边形进行三角剖分和平均来计算。从第一个顶点 $P_1$ 开始的扇形三角剖分将 $N$ 个顶点的多边形划分为 $N-2$ 个三角形 $T_j = (P_1, P_{j+1}, P_{j+2})$，其中 $j=1, \\dots, N-2$。\n每个三角形 $T_j$ 上的平均示踪剂值（顶点示踪剂值为 $c_a, c_b, c_d$）近似为其顶点值的平均值：$\\bar{c}_{T_j} = (c_a+c_b+c_d)/3$。每个三角形的面积 $A_{T_j}$ 被计算出来。\n多边形内的示踪剂总量是每个三角形中量的总和，即 $C = \\sum_{j=1}^{N-2} \\bar{c}_{T_j} A_{T_j}$。\n面积平均示踪剂则是总量除以总面积：\n$$ \\bar{c} = \\frac{C}{A} = \\frac{\\sum_{j=1}^{N-2} \\bar{c}_{T_j} A_{T_j}}{\\sum_{j=1}^{N-2} A_{T_j}} $$\n此过程应用于 $t_0$ 和 $t_1$ 时刻的数据，以获得 $\\bar{c}_0$ 和 $\\bar{c}_1$。\n对于测试中指定的凸多边形，$\\sum_{j} A_{T_j}$ 等于通过鞋带公式计算的总面积 $A$。\n\n这些步骤构成了一个完整的算法，用于处理稀疏的拉格朗日数据并估算所需的物理量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef shoelace_area(vertices: np.ndarray) -> float:\n    \"\"\"\n    Calculates the area of a polygon using the shoelace formula.\n    The input vertices are assumed to be in counterclockwise or clockwise order.\n\n    Args:\n        vertices: A NumPy array of shape (N, 2) where N is the number of vertices.\n\n    Returns:\n        The area of the polygon.\n    \"\"\"\n    x = vertices[:, 0]\n    y = vertices[:, 1]\n    # The formula is 0.5 * |(x1y2 + x2y3 + ... + xNy1) - (y1x2 + y2x3 + ... + yNx1)|\n    # which can be vectorized using np.roll.\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    return area\n\ndef area_mean_tracer(vertices: np.ndarray, tracer_values: np.ndarray) -> float:\n    \"\"\"\n    Calculates the area-mean tracer concentration for a polygon.\n    The calculation is based on a fan triangulation from the first vertex.\n    The mean tracer in each triangle is the average of its vertex values.\n\n    Args:\n        vertices: A NumPy array of shape (N, 2) for polygon vertices.\n        tracer_values: A NumPy array of shape (N,) with tracer values at each vertex.\n\n    Returns:\n        The area-weighted mean tracer concentration.\n    \"\"\"\n    num_vertices = len(vertices)\n    if num_vertices < 3:\n        # Not a valid polygon for triangulation\n        return np.mean(tracer_values) if len(tracer_values) > 0 else 0.0\n\n    total_tracer_amount = 0.0\n    total_area = 0.0\n\n    # The fan triangulation originates from the first vertex (p1).\n    p1 = vertices[0]\n    c1 = tracer_values[0]\n\n    # Iterate through the vertices to form triangles (p1, p_i, p_{i+1})\n    for i in range(1, num_vertices - 1):\n        p2 = vertices[i]\n        c2 = tracer_values[i]\n        p3 = vertices[i+1]\n        c3 = tracer_values[i+1]\n\n        # Area of triangle (p1, p2, p3) using the determinant formula\n        # 0.5 * |(x1(y2-y3) + x2(y3-y1) + x3(y1-y2))|\n        area_tri = 0.5 * abs(p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1]))\n\n        # Mean tracer in the triangle is the average of vertex values\n        mean_c_tri = (c1 + c2 + c3) / 3.0\n\n        total_tracer_amount += mean_c_tri * area_tri\n        total_area += area_tri\n    \n    if total_area == 0:\n        # Fallback for degenerate polygons, though not expected in tests.\n        return np.mean(tracer_values)\n\n    return total_tracer_amount / total_area\n\ndef estimate_divergence_and_source(v0, c0, v1, c1, dt):\n    \"\"\"\n    Estimates area-mean divergence and source rate from two snapshots.\n\n    Args:\n        v0: Vertices at time t0.\n        c0: Tracer values at time t0.\n        v1: Vertices at time t1.\n        c1: Tracer values at time t1.\n        dt: Time step (t1 - t0).\n\n    Returns:\n        A tuple containing the estimated mean divergence and mean source rate.\n    \"\"\"\n    # Step 1: Compute areas at t0 and t1\n    A0 = shoelace_area(v0)\n    A1 = shoelace_area(v1)\n\n    # Step 2: Estimate area-mean divergence at t_{1/2}\n    # Using the centered finite difference approximation of d(ln A)/dt\n    if (A0 + A1) == 0:\n        mean_div = 0.0\n    else:\n        mean_div = (2.0 / dt) * (A1 - A0) / (A0 + A1)\n\n    # Step 3: Compute area-mean tracer at t0 and t1\n    c_bar_0 = area_mean_tracer(v0, c0)\n    c_bar_1 = area_mean_tracer(v1, c1)\n\n    # Step 4: Estimate area-mean source rate at t_{1/2}\n    dc_bar_dt = (c_bar_1 - c_bar_0) / dt\n    c_bar_mid = (c_bar_0 + c_bar_1) / 2.0\n    mean_sigma = dc_bar_dt + c_bar_mid * mean_div\n    \n    return mean_div, mean_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'name': 'A',\n            'params': {'lambda': 2e-5, 'dt': 10000.0, 'c0_val': 5.0},\n            'v0': np.array([[0.0, 0.0], [1000.0, 0.0], [1000.0, 500.0], [0.0, 500.0]]),\n        },\n        {\n            'name': 'B',\n            'params': {'S': 1e-4, 'dt': 5000.0, 'sigma0': 1e-2, 'c0_val': 1.0},\n            'v0': np.array([[0.0, 0.0], [1000.0, 0.0], [1500.0, 500.0], [500.0, 500.0]]),\n        },\n        {\n            'name': 'C',\n            'params': {'Omega': 1e-4, 'dt': 2000.0, 'c0_base': 2.0, 'alpha': 1e-5},\n            'v0': np.array([[1000.0, 0.0], [1500.0, 500.0], [1000.0, 1000.0], [500.0, 500.0]]),\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        v0 = case['v0']\n        params = case['params']\n        dt = params['dt']\n\n        if case['name'] == 'A':\n            lam = params['lambda']\n            c0 = np.full(len(v0), params['c0_val'])\n            \n            # Evolve drifters and tracer to t1\n            v1 = v0 * np.exp(lam * dt / 2.0)\n            c1 = c0 * np.exp(-lam * dt)\n\n        elif case['name'] == 'B':\n            S = params['S']\n            c0 = np.full(len(v0), params['c0_val'])\n            \n            # Evolve drifters and tracer to t1\n            v1 = v0.copy()\n            v1[:, 0] = v0[:, 0] + S * v0[:, 1] * dt\n            c1 = np.full(len(v1), params['c0_val'] + params['sigma0'] * dt)\n\n        elif case['name'] == 'C':\n            Omega = params['Omega']\n            c0 = params['c0_base'] + params['alpha'] * (v0[:, 0]**2 + v0[:, 1]**2)\n\n            # Evolve drifters and tracer to t1\n            x0, y0 = v0[:, 0], v0[:, 1]\n            cos_dt = np.cos(Omega * dt)\n            sin_dt = np.sin(Omega * dt)\n            v1 = np.array([x0 * cos_dt - y0 * sin_dt, x0 * sin_dt + y0 * cos_dt]).T\n            # Tracer is materially conserved, so each drifter keeps its initial value\n            c1 = c0.copy()\n\n        # Apply the estimation algorithm\n        mean_div, mean_sigma = estimate_divergence_and_source(v0, c0, v1, c1, dt)\n        results.append([mean_div, mean_sigma])\n    \n    # Print the formatted output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3358328"}, {"introduction": "在移动网格上进行数值模拟时，保证计算的准确性是一个核心挑战，因为对控制体积变化的简单处理可能导致人为的质量或动量产生。此练习 [@problem_id:3358333] 深入探讨了数值保真度的核心问题，要求我们推导时间积分器满足几何守恒律（Geometric Conservation Law, GCL）所需的阶数条件。理解并实现几何守恒律是精确进行任意拉格朗日-欧拉（Arbitrary Lagrangian-Eulerian, ALE）模拟的基石。", "problem": "考虑一个一维移动控制体，其左右边界分别位于 $x_L(t)$ 和 $x_R(t)$。令 $w_L(t) = \\frac{dx_L}{dt}$ 和 $w_R(t) = \\frac{dx_R}{dt}$ 表示边界速度，单位为 $\\mathrm{m/s}$。定义控制体长度为 $L(t) = x_R(t) - x_L(t)$。假设属性场是均匀且不随时间变化的，因此移动控制体上积分的变化仅由几何因素引起。\n\n从雷诺输运定理 (RTT) 出发，推导一个单步多点求值时间积分器的离散阶条件。该积分器通过近似几何贡献，在一个大小为 $\\Delta t$ 的时间步长内更新 $L(t)$。具体来说，考虑一种基于求积的更新形式：\n$$\nL^{n+1} = L^n + \\Delta t \\sum_{i=1}^{s} b_i \\, g\\!\\left(t^n + c_i \\Delta t\\right),\n$$\n其中 $g(t) = w_R(t) - w_L(t)$，$s$ 是求值点的数量，$\\{b_i\\}_{i=1}^s$ 是标量权重，$\\{c_i\\}_{i=1}^s$ 是区间 $[0,1]$ 内的标量横坐标。使用 RTT 几何残差关于 $\\Delta t$ 幂次的泰勒展开，推导对 $\\{b_i\\}$ 和 $\\{c_i\\}$ 的约束条件，以保证 $L^{n+1}$ 中的局部截断误差为 $O(\\Delta t^4)$ 阶，并且 $O(\\Delta t^2)$ 阶的几何误差项被精确抵消。\n\n通过选择满足所推导阶条件的特定 $\\{b_i\\}$ 和 $\\{c_i\\}$，构建一个具体的三阶格式。该格式必须在步长内恰好三个时间点上计算 $g(t)$，并根据上述公式更新 $L$。\n\n然后，在程序中实现此格式，并针对以下独立测试集（所有情况下 $t^n = 0$）在单个时间步长内评估其几何更新误差：\n\n- 测试用例 1 (多项式，一般情况): $g(t) = 3 + 2 t + t^2$，$\\Delta t = 0.1\\,\\mathrm{s}$。\n- 测试用例 2 (多项式，三次): $g(t) = t^3$，$\\Delta t = 0.1\\,\\mathrm{s}$。\n- 测试用例 3 (振荡): $g(t) = \\sin(7 t)$，$\\Delta t = 0.1\\,\\mathrm{s}$。\n- 测试用例 4 (振荡，步长减半): $g(t) = \\sin(7 t)$，$\\Delta t = 0.05\\,\\mathrm{s}$。\n- 测试用例 5 (匀速运动): $g(t) = 5$，$\\Delta t = 0.1\\,\\mathrm{s}$。\n- 测试用例 6 (无运动): $g(t) = 0$，$\\Delta t = 0.1\\,\\mathrm{s}$。\n\n对每个测试用例，计算精确的几何长度变化量\n$$\n\\Delta L_{\\mathrm{exact}} = \\int_{0}^{\\Delta t} g(t)\\, dt,\n$$\n以及由你构建的三阶格式给出的数值几何长度变化量\n$$\n\\Delta L_{\\mathrm{num}} = \\Delta t \\sum_{i=1}^{3} b_i \\, g\\!\\left(c_i \\Delta t\\right),\n$$\n并报告绝对误差 $E = \\lvert \\Delta L_{\\mathrm{num}} - \\Delta L_{\\mathrm{exact}} \\rvert$。\n\n将每个误差值以米为单位表示，并四舍五入到八位小数。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$\\left[0.00000000,0.12345678,\\ldots\\right]$）。", "solution": "问题陈述已经过严格验证，被认为是**有效的**。它在科学上基于流体动力学原理（雷诺输运定理）和数值分析（求积方法），是适定的、客观的，并包含推导出唯一且可验证解所需的所有信息。\n\n该问题要求推导数值积分器的阶条件，构建一个特定的三阶格式，并实现该格式以针对几个案例进行测试。\n\n### 第1部分：阶条件的推导\n\n出发点是针对均匀且不随时间变化属性的一维雷诺输运定理，它可简化为关于控制体长度 $L(t)$ 的常微分方程 (ODE)：\n$$\n\\frac{dL}{dt} = w_R(t) - w_L(t) = g(t)\n$$\n从 $t^n$到 $t^{n+1} = t^n + \\Delta t$ 的一个时间步长内，长度的精确变化由 $g(t)$ 的积分给出：\n$$\n\\Delta L_{\\mathrm{exact}} = L(t^{n+1}) - L(t^n) = \\int_{t^n}^{t^{n+1}} g(t) \\, dt\n$$\n为了找到阶条件，我们将 $\\Delta L_{\\mathrm{exact}}$ 在 $t^n$ 附近进行泰勒级数展开。令 $\\tau = t - t^n$。\n$$\n\\Delta L_{\\mathrm{exact}} = \\int_{0}^{\\Delta t} g(t^n+\\tau) \\, d\\tau\n$$\n将 $g(t^n+\\tau)$ 在 $\\tau=0$ 附近展开：\n$$\ng(t^n+\\tau) = g(t^n) + g'(t^n)\\tau + \\frac{g''(t^n)}{2!}\\tau^2 + \\frac{g'''(t^n)}{3!}\\tau^3 + \\dots\n$$\n从 $\\tau=0$ 到 $\\Delta t$ 逐项积分：\n$$\n\\Delta L_{\\mathrm{exact}} = g(t^n)\\Delta t + \\frac{g'(t^n)}{2}\\Delta t^2 + \\frac{g''(t^n)}{6}\\Delta t^3 + \\frac{g'''(t^n)}{24}\\Delta t^4 + O(\\Delta t^5)\n$$\n数值格式使用求积法则来近似该积分：\n$$\n\\Delta L_{\\mathrm{num}} = \\Delta t \\sum_{i=1}^{s} b_i \\, g(t^n + c_i \\Delta t)\n$$\n我们将 $g(t^n + c_i \\Delta t)$ 在 $t^n$ 附近进行泰勒级数展开：\n$$\ng(t^n + c_i \\Delta t) = g(t^n) + g'(t^n)(c_i \\Delta t) + \\frac{g''(t^n)}{2}(c_i \\Delta t)^2 + \\frac{g'''(t^n)}{6}(c_i \\Delta t)^3 + \\dots\n$$\n将此代入数值格式的公式中：\n$$\n\\Delta L_{\\mathrm{num}} = \\Delta t \\sum_{i=1}^{s} b_i \\left( g(t^n) + g'(t^n)c_i \\Delta t + \\frac{g''(t^n)}{2}c_i^2 \\Delta t^2 + \\frac{g'''(t^n)}{6}c_i^3 \\Delta t^3 + \\dots \\right)\n$$\n$$\n\\Delta L_{\\mathrm{num}} = \\left(\\sum_{i=1}^{s} b_i\\right) g(t^n)\\Delta t + \\left(\\sum_{i=1}^{s} b_i c_i\\right) g'(t^n)\\Delta t^2 + \\left(\\sum_{i=1}^{s} b_i c_i^2\\right) \\frac{g''(t^n)}{2}\\Delta t^3 + \\left(\\sum_{i=1}^{s} b_i c_i^3\\right) \\frac{g'''(t^n)}{6}\\Delta t^4 + O(\\Delta t^5)\n$$\n$L^{n+1}$ 中的局部截断误差 (LTE) 是一步之后精确解与数值解之差，即 $\\Delta L_{\\mathrm{exact}} - \\Delta L_{\\mathrm{num}}$。为了使 LTE 达到 $O(\\Delta t^4)$ 阶，该方法必须具有三阶精度。这要求 $\\Delta L_{\\mathrm{exact}}$ 和 $\\Delta L_{\\mathrm{num}}$ 展开式中 $\\Delta t$、$\\Delta t^2$ 和 $\\Delta t^3$ 的系数相匹配。\n\n比较 $g(t^n)$ 的各阶导数的系数：\n1.  $g(t^n)\\Delta t$ 项：$1 = \\sum_{i=1}^{s} b_i$\n2.  $g'(t^n)\\Delta t^2$ 项：$\\frac{1}{2} = \\sum_{i=1}^{s} b_i c_i$\n3.  $g''(t^n)\\Delta t^3$ 项：$\\frac{1}{6} = \\frac{1}{2} \\sum_{i=1}^{s} b_i c_i^2 \\implies \\frac{1}{3} = \\sum_{i=1}^{s} b_i c_i^2$\n\n为了使格式的局部截断误差至少为 $O(\\Delta t^4)$ 阶，参数 $\\{b_i, c_i\\}$ 必须满足这三个条件。问题中“$O(\\Delta t^2)$ 阶的几何误差项被精确抵消”的要求对应于与 $g'(t^n)\\Delta t^2$ 成正比的误差项，这导致了第二个条件 $\\sum b_i c_i = 1/2$。任何2阶或更高阶的方法都隐式地满足此条件。\n\n### 第2部分：具体三阶格式的构建\n\n问题要求一个具有 $s=3$ 个求值点的格式。这给出了一个包含6个未知数（$b_1, b_2, b_3, c_1, c_2, c_3$）的3个方程组。该方程组是欠定的，因此我们可以选择一些参数。横坐标 $\\{c_i\\}$ 的一个标准选择是 $c_1=0$，$c_2=1/2$，$c_3=1$。\n\n将这些值代入阶条件：\n1.  $b_1 + b_2 + b_3 = 1$\n2.  $b_1(0) + b_2(1/2) + b_3(1) = 1/2 \\implies \\frac{1}{2} b_2 + b_3 = \\frac{1}{2}$\n3.  $b_1(0)^2 + b_2(1/2)^2 + b_3(1)^2 = 1/3 \\implies \\frac{1}{4} b_2 + b_3 = \\frac{1}{3}$\n\n从(2)式，我们得到 $b_2 + 2b_3 = 1$。从(3)式，我们得到 $b_2 + 4b_3 = 4/3$。两式相减得到 $2b_3 = 4/3 - 1 = 1/3$，所以 $b_3 = 1/6$。\n将 $b_3 = 1/6$ 代入 $b_2 + 2b_3 = 1$ 得到 $b_2 + 2(1/6) = 1 \\implies b_2 = 1 - 1/3 = 2/3$。\n最后，将 $b_2$ 和 $b_3$ 代入(1)式：$b_1 + 2/3 + 1/6 = 1 \\implies b_1 + 5/6 = 1 \\implies b_1 = 1/6$。\n\n所构建的格式定义如下：\n-   横坐标：$c_1 = 0$, $c_2 = 1/2$, $c_3 = 1$\n-   权重：$b_1 = 1/6$, $b_2 = 4/6 = 2/3$, $b_3 = 1/6$\n\n这对应于众所周知的用于数值积分的辛普森1/3法则。已知该法则对次数不高于3的多项式是精确的。其求积精度阶为4阶（LTE为 $O(\\Delta t^5)$），满足了问题对三阶方法的要求。\n\n### 第3部分：测试用例的评估\n\n使用构建的格式，数值长度变化为：\n$$\n\\Delta L_{\\mathrm{num}} = \\Delta t \\left( \\frac{1}{6} g(0) + \\frac{4}{6} g\\left(\\frac{\\Delta t}{2}\\right) + \\frac{1}{6} g(\\Delta t) \\right)\n$$\n对于每个测试用例，我们计算 $\\Delta L_{\\mathrm{exact}} = \\int_0^{\\Delta t} g(t) dt$ 和绝对误差 $E = \\lvert \\Delta L_{\\mathrm{num}} - \\Delta L_{\\mathrm{exact}} \\rvert$。\n\n-   **测试用例 1**: $g(t) = 3 + 2t + t^2$。由于 $g(t)$ 是一个2次多项式，次数小于4，辛普森法则是精确的。$E = 0$。\n-   **测试用例 2**: $g(t) = t^3$。由于 $g(t)$ 是一个3次多项式，辛普森法则是精确的。$E = 0$。\n-   **测试用例 3**: $g(t) = \\sin(7t)$，$\\Delta t = 0.1$。\n    $\\Delta L_{\\mathrm{exact}} = (1 - \\cos(0.7))/7 \\approx 0.03359397$。\n    $\\Delta L_{\\mathrm{num}} \\approx 0.03359681$。\n    $E \\approx 0.00000284$。\n-   **测试用例 4**: $g(t) = \\sin(7t)$，$\\Delta t = 0.05$。\n    $\\Delta L_{\\mathrm{exact}} = (1 - \\cos(0.35))/7 \\approx 0.00866103$。\n    $\\Delta L_{\\mathrm{num}} \\approx 0.00866121$。\n    $E \\approx 0.00000018$。\n-   **测试用例 5**: $g(t) = 5$。一个0次多项式。该格式是精确的。$E = 0$。\n-   **测试用例 6**: $g(t) = 0$。该格式是精确的。$E = 0$。\n\n计算出的误差，四舍五入到八位小数后，汇总在最终答案中。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a third-order geometric integrator to a set of test cases.\n    The integrator is based on the problem description, which reduces to a numerical\n    quadrature task. A 3-stage scheme is constructed, which is identical to\n    Simpson's 1/3 rule. This scheme is applied to calculate the change in length\n    of a control volume over a single time step for several definitions of\n    boundary velocity differences g(t).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (function g(t), function for exact integral, dt)\n    test_cases = [\n        (lambda t: 3 + 2 * t + t**2, lambda dt: 3 * dt + dt**2 + dt**3 / 3, 0.1),\n        (lambda t: t**3, lambda dt: dt**4 / 4, 0.1),\n        (lambda t: np.sin(7 * t), lambda dt: (1 - np.cos(7 * dt)) / 7, 0.1),\n        (lambda t: np.sin(7 * t), lambda dt: (1 - np.cos(7 * dt)) / 7, 0.05),\n        (lambda t: 5.0, lambda dt: 5.0 * dt, 0.1),\n        (lambda t: 0.0, lambda dt: 0.0, 0.1)\n    ]\n\n    # Scheme parameters for a 3-stage, 3rd-order (actually 4th-order) method.\n    # This is Simpson's 1/3 rule.\n    # c_i: abscissas, b_i: weights\n    c = np.array([0.0, 0.5, 1.0])\n    b = np.array([1/6, 4/6, 1/6])\n\n    results = []\n    for g, integral_exact_func, dt in test_cases:\n        # Calculate the exact change in length\n        delta_L_exact = integral_exact_func(dt)\n\n        # Calculate the numerical change in length using the constructed scheme\n        # Evaluation points in time: t_i = t_n + c_i * dt. Here t_n = 0.\n        t_eval = c * dt\n        # Evaluate g at these time points\n        g_eval = g(t_eval)\n        # Compute the quadrature sum\n        delta_L_num = dt * np.sum(b * g_eval)\n\n        # Compute the absolute error\n        error = np.abs(delta_L_num - delta_L_exact)\n        results.append(error)\n\n    # Format results to 8 decimal places as required.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3358333"}]}