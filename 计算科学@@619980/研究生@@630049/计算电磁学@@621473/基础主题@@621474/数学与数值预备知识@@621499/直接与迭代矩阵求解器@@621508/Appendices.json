{"hands_on_practices": [{"introduction": "迭代法是求解大型线性系统的关键，而理解其收敛行为至关重要。本练习将引导你使用局部傅里叶分析（Local Fourier Analysis, LFA）这一强大工具，来研究逐次超松弛（Successive Over-Relaxation, SOR）法作为平滑算子在一个模型问题上的性能。通过推导其放大因子并确定最优参数，你将深入了解多重网格方法中基本构件的设计原理。[@problem_id:3299116]", "problem": "在计算电磁学中，考虑一个均匀、无源、具有均匀磁导率和介电常数的一维周期性介质中的静态旋度-旋度方程。在网格间距为 $h$ 的均匀 Yee 交错网格上，单个切向电场分量可简化为一个标量方程，其中离散旋度-旋度算子等于标准二阶差分算子\n$$\n(A u)_{j} \\;=\\; \\frac{1}{h^{2}}\\left(2 u_{j} - u_{j-1} - u_{j+1}\\right),\n$$\n并周期性地延拓到无限网格。我们希望使用逐次超松弛（SOR）方法，以字典序求解 $A u = b$。该方法基于分裂 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是其严格下三角部分，$U$ 是其严格上三角部分，松弛参数为 $\\omega>0$。\n\n使用无限网格上的局部傅里叶分析，按以下步骤进行：\n\n1) 对于傅里叶模式 $e^{\\mathrm{i} j \\theta}$，推导 SOR 误差传播算子的傅里叶符号，其中 $\\theta \\in [0,\\pi]$ 是无量纲角频率（角度以弧度为单位）。将相应的放大因子记为 $g_{\\omega}(\\theta)$。\n\n2) 定义高频集为 $\\mathcal{H} = \\{\\theta \\in [\\pi/2, \\pi]\\}$。证明对于 $0<\\omega<2$，最坏情况下的高频放大在 $\\theta = \\pi/2$ 处达到，并将高频平滑因子写为\n$$\n\\sigma(\\omega) \\;=\\; \\max_{\\theta \\in \\mathcal{H}} \\, |g_{\\omega}(\\theta)| \\;=\\; |g_{\\omega}(\\tfrac{\\pi}{2})|.\n$$\n\n3) 确定在 $\\omega>0$ 上最小化 $\\sigma(\\omega)$ 的最优松弛参数 $\\omega_{\\star}$，并给出 $\\sigma(\\omega_{\\star})$ 的闭式解。\n\n4) 考虑一个双网格方法，该方法包含一个前平滑和一个后平滑 SOR 步骤，以及一个理想化的粗网格校正，该校正能完全消除所有低频误差分量 $\\theta \\in [0,\\pi/2)$，同时保持高频集 $\\mathcal{H}$ 不变。在这种理想化的情况下，预测双网格误差缩减因子为\n$$\n\\rho_{\\mathrm{TG}}(\\omega) \\;=\\; \\left(\\sigma(\\omega)\\right)^{2},\n$$\n并计算其在 $\\omega_{\\star}$ 处的值。\n\n以精确解析形式提供您的最终答案，答案为一个数对，包含最优松弛参数 $\\omega_{\\star}$ 和相应的双网格误差缩减因子 $\\rho_{\\mathrm{TG}}(\\omega_{\\star})$。最终答案中不要包含单位。如果选择数值近似，请四舍五入到四位有效数字。", "solution": "该问题陈述经核实具有科学依据、适定且客观。它描述了迭代多重网格方法的局部傅里叶分析（或 von Neumann 分析）中的一个标准问题。所有术语均为标准术语，设置一致。\n\n解题过程遵循问题中概述的四个步骤。\n\n1) 推导 SOR 误差传播算子的傅里叶符号。\n\n离散算子由\n$$ (A u)_{j} = \\frac{1}{h^{2}}\\left(2 u_{j} - u_{j-1} - u_{j+1}\\right) $$\n给出。我们考虑缩放后的算子$A' = h^2 A$，使得 $(A' u)_{j} = 2 u_{j} - u_{j-1} - u_{j+1}$。待解的系统是$A'u = h^2 b$。\n算子 $A'$ 可分裂为$A' = D' - L' - U'$，其中 $D'$ 是对角部分，$L'$ 是严格下三角部分，$U'$ 是严格上三角部分。在一维字典序（从较小的 $j$ 到较大的 $j$）的背景下：\n- $(D'u)_j = 2u_j$\n- $(L'u)_j = u_{j-1}$\n- $(U'u)_j = u_{j+1}$\n\n用于求解 $A'u=b'$ 的逐次超松弛（SOR）迭代由分裂 $A' = D' - L' - U'$ 和松弛参数 $\\omega > 0$ 定义。在第 $k$ 次迭代时的误差$e^{(k)} = u^{(k)}-u$根据以下方程传播：\n$$ (D' - \\omega L') e^{(k+1)} = ((1-\\omega)D' + \\omega U') e^{(k)} $$\n将此方程写出分量 $j$ 的形式，得到：\n$$ 2 e_j^{(k+1)} - \\omega e_{j-1}^{(k+1)} = 2(1-\\omega) e_j^{(k)} + \\omega e_{j+1}^{(k)} $$\n我们分析误差的单个傅里叶模式的行为，$e_j^{(k)} = (g_{\\omega}(\\theta))^k e^{\\mathrm{i} j \\theta}$，其中$g_{\\omega}(\\theta)$是无量纲角频率 $\\theta$ 的放大因子。将此代入误差传播方程，我们得到：\n$$ g_{\\omega}(\\theta) \\left( 2 e^{\\mathrm{i} j \\theta} - \\omega e^{\\mathrm{i} (j-1) \\theta} \\right) = 2(1-\\omega) e^{\\mathrm{i} j \\theta} + \\omega e^{\\mathrm{i} (j+1) \\theta} $$\n除以 $e^{\\mathrm{i} j \\theta}$（非零）：\n$$ g_{\\omega}(\\theta) \\left( 2 - \\omega e^{-\\mathrm{i} \\theta} \\right) = 2(1-\\omega) + \\omega e^{\\mathrm{i} \\theta} $$\n求解放大因子$g_{\\omega}(\\theta)$，得到其傅里叶符号：\n$$ g_{\\omega}(\\theta) = \\frac{2(1-\\omega) + \\omega e^{\\mathrm{i}\\theta}}{2 - \\omega e^{-\\mathrm{i}\\theta}} $$\n\n2) 高频平滑因子 $\\sigma(\\omega)$。\n\n高频集定义为 $\\mathcal{H} = \\{\\theta \\in [\\pi/2, \\pi]\\}$。平滑因子是此集合上的最坏情况（最大）放大因子：$\\sigma(\\omega) = \\max_{\\theta \\in \\mathcal{H}} |g_{\\omega}(\\theta)|$。\n我们来计算$g_{\\omega}(\\theta)$的幅值平方：\n$$ |g_{\\omega}(\\theta)|^2 = g_{\\omega}(\\theta) \\overline{g_{\\omega}(\\theta)} = \\frac{2(1-\\omega) + \\omega e^{\\mathrm{i}\\theta}}{2 - \\omega e^{-\\mathrm{i}\\theta}} \\cdot \\frac{2(1-\\omega) + \\omega e^{-\\mathrm{i}\\theta}}{2 - \\omega e^{\\mathrm{i}\\theta}} $$\n分子为：\n$$ N = \\left(2(1-\\omega) + \\omega \\cos\\theta \\right)^2 + (\\omega \\sin\\theta)^2 = 4(1-\\omega)^2 + 4\\omega(1-\\omega)\\cos\\theta + \\omega^2\\cos^2\\theta + \\omega^2\\sin^2\\theta = 4(1-2\\omega+\\omega^2) + 4\\omega(1-\\omega)\\cos\\theta + \\omega^2 = 5\\omega^2 - 8\\omega + 4 + (4\\omega - 4\\omega^2)\\cos\\theta $$\n分母为：\n$$ D = (2 - \\omega\\cos\\theta)^2 + (\\omega \\sin\\theta)^2 = 4 - 4\\omega\\cos\\theta + \\omega^2\\cos^2\\theta + \\omega^2\\sin^2\\theta = \\omega^2 + 4 - 4\\omega\\cos\\theta $$\n令$f(c) = |g_{\\omega}(\\theta)|^2$，其中$c = \\cos\\theta$。对于 $\\theta \\in [\\pi/2, \\pi]$，$c$位于区间$[-1, 0]$内。\n$$ f(c) = \\frac{5\\omega^2-8\\omega+4 + (4\\omega-4\\omega^2)c}{\\omega^2+4 - 4\\omega c} $$\n为了找到最大值，我们计算关于 $c$ 的导数：\n$$ f'(c) = \\frac{(4\\omega-4\\omega^2)(\\omega^2+4-4\\omega c) - (5\\omega^2-8\\omega+4 + (4\\omega-4\\omega^2)c)(-4\\omega)}{(\\omega^2+4 - 4\\omega c)^2} $$\n$f'(c)$ 的符号由其分子决定。经过展开和简化，含 $c$ 的项相互抵消，分子变为：\n$$ \\text{Num}' = 4\\omega(8 - 12\\omega + 6\\omega^2 - \\omega^3) = 4\\omega(2-\\omega)^3 $$\n对于 $0 < \\omega < 2$，我们有 $4\\omega > 0$ 且 $(2-\\omega)^3 > 0$。因此，$f'(c) > 0$。这意味着$f(c)$是关于 $c$ 的单调递增函数。\n对于 $c \\in [-1, 0]$，$f(c)$的最大值在 $c=0$ 处取得，这对应于 $\\theta = \\pi/2$。\n因此，高频平滑因子为 $\\sigma(\\omega) = |g_{\\omega}(\\pi/2)|$。\n我们计算$g_{\\omega}(\\theta)$在 $\\theta = \\pi/2$ 处的值：\n$$ g_{\\omega}(\\pi/2) = \\frac{2(1-\\omega) + \\omega e^{\\mathrm{i}\\pi/2}}{2 - \\omega e^{-\\mathrm{i}\\pi/2}} = \\frac{2-2\\omega + \\mathrm{i}\\omega}{2 + \\mathrm{i}\\omega} $$\n其幅值的平方为：\n$$ \\sigma(\\omega)^2 = |g_{\\omega}(\\pi/2)|^2 = \\frac{(2-2\\omega)^2 + \\omega^2}{2^2 + \\omega^2} = \\frac{4 - 8\\omega + 4\\omega^2 + \\omega^2}{4+\\omega^2} = \\frac{5\\omega^2 - 8\\omega + 4}{\\omega^2 + 4} $$\n\n3) 最优松弛参数 $\\omega_{\\star}$。\n\n为了找到最小化 $\\sigma(\\omega)$ 的最优松弛参数$\\omega_{\\star}$，我们可以最小化 $\\sigma(\\omega)^2$。令$S(\\omega) = \\sigma(\\omega)^2$。我们计算 $S(\\omega)$ 的导数并令其为零：\n$$ S'(\\omega) = \\frac{(10\\omega - 8)(\\omega^2+4) - (5\\omega^2-8\\omega+4)(2\\omega)}{(\\omega^2 + 4)^2} = 0 $$\n令分子为零得到：\n$$ 10\\omega^3 - 8\\omega^2 + 40\\omega - 32 - (10\\omega^3 - 16\\omega^2 + 8\\omega) = 0 $$\n$$ 8\\omega^2 + 32\\omega - 32 = 0 \\implies \\omega^2 + 4\\omega - 4 = 0 $$\n求解关于 $\\omega$ 的二次方程：\n$$ \\omega = \\frac{-4 \\pm \\sqrt{16-4(1)(-4)}}{2} = \\frac{-4 \\pm \\sqrt{32}}{2} = \\frac{-4 \\pm 4\\sqrt{2}}{2} = -2 \\pm 2\\sqrt{2} $$\n因为 $\\omega > 0$，我们必须选择正根：\n$$ \\omega_{\\star} = 2\\sqrt{2} - 2 = 2(\\sqrt{2}-1) $$\n接下来，我们求最小平滑因子 $\\sigma(\\omega_{\\star})$。我们使用二次方程中的关系式$\\omega_{\\star}^2 = 4 - 4\\omega_{\\star}$来简化$S(\\omega_{\\star})$的表达式：\n$$ S(\\omega_{\\star}) = \\frac{5\\omega_{\\star}^2 - 8\\omega_{\\star} + 4}{\\omega_{\\star}^2 + 4} = \\frac{5(4-4\\omega_{\\star}) - 8\\omega_{\\star} + 4}{(4-4\\omega_{\\star}) + 4} = \\frac{20 - 20\\omega_{\\star} - 8\\omega_{\\star} + 4}{8 - 4\\omega_{\\star}} = \\frac{24-28\\omega_{\\star}}{8-4\\omega_{\\star}} = \\frac{6-7\\omega_{\\star}}{2-\\omega_{\\star}} $$\n代入 $\\omega_{\\star} = 2\\sqrt{2}-2$：\n$$ S(\\omega_{\\star}) = \\frac{6 - 7(2\\sqrt{2}-2)}{2 - (2\\sqrt{2}-2)} = \\frac{6 - 14\\sqrt{2} + 14}{4 - 2\\sqrt{2}} = \\frac{20 - 14\\sqrt{2}}{4 - 2\\sqrt{2}} = \\frac{10 - 7\\sqrt{2}}{2 - \\sqrt{2}} $$\n对分母进行有理化：\n$$ S(\\omega_{\\star}) = \\frac{10 - 7\\sqrt{2}}{2 - \\sqrt{2}} \\cdot \\frac{2 + \\sqrt{2}}{2 + \\sqrt{2}} = \\frac{20 + 10\\sqrt{2} - 14\\sqrt{2} - 14}{4-2} = \\frac{6 - 4\\sqrt{2}}{2} = 3 - 2\\sqrt{2} $$\n所以，$\\sigma(\\omega_{\\star})^2 = 3-2\\sqrt{2}$。我们可以将其识别为 $(\\sqrt{2}-1)^2$。\n因此，最优平滑因子$\\sigma(\\omega_{\\star}) = \\sqrt{3-2\\sqrt{2}} = \\sqrt{(\\sqrt{2}-1)^2} = \\sqrt{2}-1$。\n\n4) 双网格误差缩减因子 $\\rho_{\\mathrm{TG}}(\\omega_{\\star})$。\n\n所述的双网格循环包括一个前平滑步骤、一个理想化的粗网格校正和一个后平滑步骤。前平滑器作用于误差，将每个傅里叶分量乘以$g_{\\omega}(\\theta)$。理想化的粗网格校正完全消除了所有低频误差分量（对于 $\\theta \\in [0, \\pi/2)$），同时保持高频分量（对于 $\\theta \\in \\mathcal{H} = [\\pi/2, \\pi]$）不变。然后，后平滑器作用于剩余的高频误差，再次将每个分量乘以$g_{\\omega}(\\theta)$。\n因此，低频模式的放大因子为 $0$，高频模式的放大因子为 $(g_{\\omega}(\\theta))^2$。总体的双网格误差缩减因子是所有模式中的最大放大因子：\n$$ \\rho_{\\mathrm{TG}}(\\omega) = \\max_{\\theta \\in [0, \\pi]} |\\text{amplification}(\\theta)| = \\max \\left( \\max_{\\theta \\in [0, \\pi/2)} |0|, \\max_{\\theta \\in [\\pi/2, \\pi]} |(g_{\\omega}(\\theta))^2| \\right) $$\n$$ \\rho_{\\mathrm{TG}}(\\omega) = \\left( \\max_{\\theta \\in [\\pi/2, \\pi]} |g_{\\omega}(\\theta)| \\right)^2 = (\\sigma(\\omega))^2 $$\n这证实了问题陈述中提供的公式。\n我们在最优参数$\\omega_{\\star}$处计算这个因子：\n$$ \\rho_{\\mathrm{TG}}(\\omega_{\\star}) = (\\sigma(\\omega_{\\star}))^2 $$\n从上一步我们得到$\\sigma(\\omega_{\\star})^2 = 3-2\\sqrt{2}$。\n因此，在最优松弛参数下的双网格误差缩减因子为\n$$ \\rho_{\\mathrm{TG}}(\\omega_{\\star}) = 3-2\\sqrt{2} $$\n最终答案是数对$(\\omega_{\\star}, \\rho_{\\mathrm{TG}}(\\omega_{\\star}))$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2(\\sqrt{2}-1)  3-2\\sqrt{2}\n\\end{pmatrix}\n}\n$$", "id": "3299116"}, {"introduction": "与迭代法不同，直接法通过矩阵分解一次性求得精确解，其效率在处理稀疏矩阵时高度依赖于“填充”（fill-in）的控制。本练习将通过一个具体的小型有限元网格，让你亲手构建消去树（elimination tree），这是理解稀疏矩阵分解过程和并行调度的核心数据结构。你将看到一个精心选择的节点排序如何决定计算的结构和潜在的并行性。[@problem_id:3299155]", "problem": "在一个单连通的均匀三维电介质中的静态电势场，由标量拉普拉斯方程建模，并使用小网格上的线性四面体单元通过有限元法 (FEM) 进行离散化。组装后的刚度矩阵是对称正定的 (SPD)。该四面体网格由共享一个三角形面的两个四面体组成：\n- 四面体 $\\mathrm{T}_1$ 的顶点集为 $\\{1,2,3,4\\}$。\n- 四面体 $\\mathrm{T}_2$ 的顶点集为 $\\{1,2,3,5\\}$。\n\n假设使用标准节点基函数和组装过程，使得全局刚度矩阵的对称稀疏模式连接了任何在至少一个四面体中共同出现的节点对。\n\n考虑一个减少填充的置换 $P$，它将未知数排序为 $\\{4,5,1,2,3\\}$（即，新的行/列索引 $1$ 对应旧节点 $4$，新索引 $2$ 对应旧节点 $5$，新索引 $3$ 对应旧节点 $1$，新索引 $4$ 对应旧节点 $2$，新索引 $5$ 对应旧节点 $3$）。采用基于 Cholesky 分解的直接求解器。\n\n任务：\n- 仅使用稀疏 Cholesky 分解及其消去图的基本定义，为在排序 $P$ 下的置换刚度矩阵构建消去树。\n- 现在考虑一个多波前直接求解器，它将每一列视为一个独立的波前任务（无超节点合并）。第 $j$ 列的波前矩阵大小定义为 $f_j = 1 + d_j$，其中 $d_j$ 是在消去第 $j$ 列时，填充图中第 $j$ 列的具有更大索引的邻居数量。假设对于一个阶为 $f$ 的波前矩阵，其稠密 Cholesky 分解的成本模型为 $\\frac{1}{3} f^3$ 浮点运算的计算量，并假设每次浮点运算的单位时间为 1。假设有实际上无限的处理器和可忽略的调度/通信开销，因此最小并行完成时间由消去树关键路径上节点权重 $\\frac{1}{3} f_j^3$ 的总和给出。\n\n对于此网格和排序，该模型所隐含的最小并行完成时间（以浮点运算单位计）的精确值是多少？请以精确有理数形式给出答案，不带单位。不要进行四舍五入。", "solution": "问题要求在给定特定节点排序和简化并行性能模型的情况下，计算一个特定稀疏矩阵进行 Cholesky 分解的最小并行完成时间。解决方案需要对稀疏分解过程进行逐步分析。\n\n**步骤 1：构建刚度矩阵的图**\n\n问题陈述，对称刚度矩阵 $A$ 的稀疏模式连接了任何在至少一个四面体中共同出现的节点对。节点总集为 $V = \\{1, 2, 3, 4, 5\\}$。\n- 四面体 $T_1 = \\{1, 2, 3, 4\\}$ 在其顶点上形成一个 $K_4$ 团。其边为 $(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)$。\n- 四面体 $T_2 = \\{1, 2, 3, 5\\}$ 在其顶点上形成一个 $K_4$ 团。其边为 $(1,2), (1,3), (1,5), (2,3), (2,5), (3,5)$。\n\n矩阵的图$G(A)$的顶点为 $V$，其边由两个团的边的并集构成。每个节点 $i$ 的邻居集合（邻接表）记作 $\\mathrm{Adj}_G(i)$，如下所示：\n- $\\mathrm{Adj}_G(1) = \\{2, 3, 4, 5\\}$\n- $\\mathrm{Adj}_G(2) = \\{1, 3, 4, 5\\}$\n- $\\mathrm{Adj}_G(3) = \\{1, 2, 4, 5\\}$\n- $\\mathrm{Adj}_G(4) = \\{1, 2, 3\\}$\n- $\\mathrm{Adj}_G(5) = \\{1, 2, 3\\}$\n\n**步骤 2：确定给定排序下的填充图**\n\n置换 $P$ 指定了节点的消去顺序：$\\{4, 5, 1, 2, 3\\}$。为清晰起见，我们用撇号表示新的索引：$1' \\to 4$, $2' \\to 5$, $3' \\to 1$, $4' \\to 2$, $5' \\to 3$。我们需要找到对置换矩阵$A_P = PAP^T$进行符号分解所得到的填充图$G^+$。\n\n填充图$G^+$包含 $G(A_P)$ 的原始边和“填充”边。如果在消去节点 $k$ 之前的图中 $(k, i)$ 和 $(k, j)$ 是边，而 $(i, j)$ 不是边，则在消去节点 $k$ 的过程中会添加一条填充边 $(i, j)$。这等价于说，一个被消去节点的所有索引值更大的邻居会形成一个团。\n\n让我们按照新的排序模拟消去过程：\n1.  **消去节点 $1'$（原始节点 $4$）：** 节点 $4$ 的邻居是 $\\{1, 2, 3\\}$，对应于新索引 $\\{3', 4', 5'\\}$。在原始图 $G$ 中，这三个节点已经形成一个团（它们都同时在 $T_1$ 和 $T_2$ 中）。因此，没有添加新边。\n2.  **消去节点 $2'$（原始节点 $5$）：** 节点 $5$ 的邻居是 $\\{1, 2, 3\\}$，对应于新索引 $\\{3', 4', 5'\\}$。和之前一样，这些节点已经形成一个团。没有发生填充。\n3.  **消去节点 $3'$（原始节点 $1$）：** 在此阶段，剩余的图由节点 $\\{1, 2, 3\\}$（新索引 $\\{3', 4', 5'\\}$）上的团构成。$3'$ 的索引值更大的邻居是 $\\{4', 5'\\}$。它们已经相连。没有发生填充。\n4.  **消去节点 $4'$（原始节点 $2$）：** 唯一剩下的索引值更大的邻居是 $5'$，因此无法形成新边。\n\n由于在任何步骤中都没有添加边，填充图$G^+$与原始图 $G(A)$ 相同（只是节点根据置换进行了重新标记）。$G^+ = G(A)$。\n\n**步骤 3：构建消去树**\n\n消去树$T$是在新排序 $\\{1', 2', 3', 4', 5'\\}$ 的节点上定义的。节点 $j$ 的父节点是在填充图$G^+$中 $j$ 的所有索引值大于 $j$ 的邻居中，索引值最小的那个。\n$$ \\mathrm{parent}(j) = \\min \\{ k \\mid k > j \\text{ and } (j, k) \\text{ is an edge in } G^+ \\} $$\n\n使用新索引和$G^+$中的邻接关系：\n-   **节点 $1'$ (旧 4):** 邻居是 $\\{3', 4', 5'\\}$。它们的索引都大于 $1'$。\n    $\\mathrm{parent}(1') = \\min\\{3', 4', 5'\\} = 3'$。\n-   **节点 $2'$ (旧 5):** 邻居是 $\\{3', 4', 5'\\}$。它们的索引都大于 $2'$。\n    $\\mathrm{parent}(2') = \\min\\{3', 4', 5'\\} = 3'$。\n-   **节点 $3'$ (旧 1):** 索引值更大的邻居是 $\\{4', 5'\\}$。\n    $\\mathrm{parent}(3') = \\min\\{4', 5'\\} = 4'$。\n-   **节点 $4'$ (旧 2):** 唯一索引值更大的邻居是 $\\{5'\\}$。\n    $\\mathrm{parent}(4') = 5'$。\n-   **节点 $5'$ (旧 3):** 这是索引值最大的节点，因此它是树的根，没有父节点。\n\n消去树的结构如下：节点 $1'$ 和 $2'$ 是 $3'$ 的子节点；$3'$ 是 $4'$ 的子节点；$4'$ 是 $5'$ 的子节点。\n\n**步骤 4：计算每个节点的计算量**\n\n消去第 $j$ 列的计算量（成本）由$W_j = \\frac{1}{3} f_j^3$给出，其中$f_j = 1 + d_j$。量$d_j$是$G^+$中节点 $j$ 的索引值大于 $j$ 的邻居数量。\n\n-   **节点 $j=1'$:** 在$G^+$中的索引值更大的邻居是 $\\{3', 4', 5'\\}$。\n    $d_{1'} = 3$，所以 $f_{1'} = 1+3=4$。\n    $W_{1'} = \\frac{1}{3} (4^3) = \\frac{64}{3}$。\n-   **节点 $j=2'$:** 在$G^+$中的索引值更大的邻居是 $\\{3', 4', 5'\\}$。\n    $d_{2'} = 3$，所以 $f_{2'} = 1+3=4$。\n    $W_{2'} = \\frac{1}{3} (4^3) = \\frac{64}{3}$。\n-   **节点 $j=3'$:** 在$G^+$中的索引值更大的邻居是 $\\{4', 5'\\}$。\n    $d_{3'} = 2$，所以 $f_{3'} = 1+2=3$。\n    $W_{3'} = \\frac{1}{3} (3^3) = \\frac{27}{3} = 9$。\n-   **节点 $j=4'$:** 在$G^+$中的索引值更大的邻居是 $\\{5'\\}$。\n    $d_{4'} = 1$，所以 $f_{4'} = 1+1=2$。\n    $W_{4'} = \\frac{1}{3} (2^3) = \\frac{8}{3}$。\n-   **节点 $j=5'$:** 没有索引值更大的邻居。\n    $d_{5'} = 0$，所以 $f_{5'} = 1+0=1$。\n    $W_{5'} = \\frac{1}{3} (1^3) = \\frac{1}{3}$。\n\n**步骤 5：确定关键路径和最小并行时间**\n\n在有无限处理器的情况下，仅当一个节点在消去树中的所有子节点的工作都完成后，该节点的工作才能开始。最小并行完成时间是关键路径上工作成本$W_j$的总和，其中关键路径是树中从任意叶节点到根节点的、以成本$W_j$加权的最长路径。\n\n消去树有两个叶节点，$1'$ 和 $2'$。这产生了通往根节点 $5'$ 的两条路径：\n1.  路径 A：$1' \\to 3' \\to 4' \\to 5'$\n2.  路径 B：$2' \\to 3' \\to 4' \\to 5'$\n\n让我们计算每条路径的总加权长度：\n-   路径 A 的长度 = $W_{1'} + W_{3'} + W_{4'} + W_{5'}$\n    $= \\frac{64}{3} + 9 + \\frac{8}{3} + \\frac{1}{3}$\n    $= \\frac{64}{3} + \\frac{27}{3} + \\frac{8}{3} + \\frac{1}{3}$\n    $= \\frac{64 + 27 + 8 + 1}{3} = \\frac{100}{3}$。\n-   路径 B 的长度 = $W_{2'} + W_{3'} + W_{4'} + W_{5'}$\n    $= \\frac{64}{3} + 9 + \\frac{8}{3} + \\frac{1}{3}$\n    $= \\frac{100}{3}$。\n\n两条路径的长度相同。关键路径的长度，即最小并行完成时间，是 $\\frac{100}{3}$。", "answer": "$$\\boxed{\\frac{100}{3}}$$", "id": "3299155"}, {"introduction": "现代计算电磁学常常结合直接法和迭代法的优点来应对挑战。本编程练习将指导你实现一种先进的混合精度迭代精化（mixed-precision iterative refinement）技术，它使用一个快速但精度较低的直接分解（如单精度LU分解）作为预条件子，来迭代求解一个高精度（双精度）的系统。通过解决一个源于边界元法的稠密矩阵问题，你将掌握一项在节约计算资源的同时确保高精度的实用策略。[@problem_id:3299108]", "problem": "考虑一个横磁场在二维空间中被一个半径为 $a$ 的光滑、理想导电圆形圆柱体所产生的经典频域散射问题。在时谐依赖关系 $e^{\\mathrm{i} \\omega t}$ 下，Maxwell 方程组可化简为关于平面外电场的标量 Helmholtz 方程，其在圆柱体边界上的边界积分表示会导出一个稠密线性系统。使用在圆上具有 $N$ 个均匀分布节点和权重 $w = 2 \\pi a / N$ 的周期梯形 Nyström 离散化方法，一个带有稳定项的简单单层离散化会产生以下复线性系统：\n$$\nA x = b,\n$$\n其中 $A \\in \\mathbb{C}^{N \\times N}$ 的元素为\n$$\nA_{ij} = \n\\begin{cases}\nw \\, G\\!\\left(\\left\\| r_i - r_j \\right\\|\\right),  i \\neq j, \\\\\nw \\, G\\!\\left(s_{\\mathrm{avg}}\\right) + \\beta,  i = j,\n\\end{cases}\n$$\n其中 $r_j = \\left(a \\cos \\theta_j, a \\sin \\theta_j\\right)$，$\\theta_j = 2 \\pi j / N$，$s_{\\mathrm{avg}} = 2 \\pi a / N$，以及二维自由空间格林函数为\n$$\nG(\\rho) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c \\rho\\right), \\quad k_c = k \\left(1 + \\mathrm{i} \\alpha\\right),\n$$\n其中 $H_0^{(1)}$ 是第一类零阶 Hankel 函数，$k$ 是单位为 $\\mathrm{m}^{-1}$ 的实波数，$\\alpha \\ge 0$ 是一个小的吸收参数（无量纲），用于避免离散对角线上出现非物理的奇异行为。右端项表示在边界上求值的入射平面波，\n$$\nb_i = \\exp\\!\\left(\\mathrm{i} \\, k_c \\, d_x \\, x_i\\right),\n$$\n其中 $x_i$ 是 $r_i$ 的 x 坐标，$d_x = 1$ 是单位传播方向的 x 分量。稳定参数 $\\beta > 0$ 是一个添加到对角线上的小的实数（无量纲），用于模拟组合场效应并抑制近零空间分量。\n\n你需要实现混合精度迭代细化方法，以单精度复数 LU 分解作为右预条件子，在双精度下求解 $A x = b$。具体来说，令 $\\epsilon_{32}$ 表示单精度的机器精度，$\\epsilon_{64}$ 表示双精度的机器精度。该算法必须：\n- 在双精度（$64$ 位复数）下构建 $A$ 和 $b$。\n- 计算 $A$ 的单精度（$32$ 位复数）部分主元 LU 分解，并将其用作预条件子。\n- 在双精度下将 $x^{(0)}$ 初始化为零向量。\n- 对于迭代 $m = 0, 1, 2, \\dots$，计算双精度残差\n$$\nr^{(m)} = b - A x^{(m)}.\n$$\n- 将 $r^{(m)}$ 转换为单精度，使用单精度 LU 因子求解单精度校正量 $\\Delta x^{(m)}$，\n$$\nA \\, \\Delta x^{(m)} \\approx r^{(m)},\n$$\n然后将 $\\Delta x^{(m)}$ 转换回双精度。\n- 在双精度下更新 $x^{(m+1)} = x^{(m)} + \\Delta x^{(m)}$。\n- 当双精度相对残差\n$$\n\\eta^{(m)} = \\frac{\\left\\| r^{(m)} \\right\\|_2}{\\left\\| b \\right\\|_2}\n$$\n低于目标容差 $\\tau$ 或达到最大迭代次数 $M$ 时终止。目标容差为 $\\tau = 10^{-11}$，最大迭代次数为 $M = 50$。\n\n从频域 Maxwell 方程组、标量 Helmholtz 方程和格林函数 $G(\\rho)$ 定义的基本原理出发，推导上述离散系统结构和混合精度迭代细化过程。然后，实现一个完整、可运行的程序，该程序根据指定参数构建 $A$ 和 $b$，执行迭代细化，并为每个测试用例返回最终达到的相对残差范数 $\\eta^{(m_\\star)}$，其中 $m_\\star$ 是该用例的最终迭代索引。\n\n所有物理参数必须使用指定的单位：圆柱体半径 $a$ 的单位是 $\\mathrm{m}$，波数 $k$ 的单位是 $\\mathrm{m}^{-1}$。最终的相对残差范数是无量纲的。角度以弧度为单位。你的算法必须使用向量 $2$-范数。\n\n设计一个包含以下参数集 $(N, k, \\alpha, \\beta, a)$ 的测试套件：\n- 用例 1（理想路径）：$(64, 20.0, 0.010, 0.10, 1.0)$。\n- 用例 2（低频边界情况）：$(16, 0.50, 0.020, 0.20, 1.0)$。\n- 用例 3（更高频率，更大的 $N$）：$(128, 40.0, 0.005, 0.05, 1.0)$。\n- 用例 4（轻度稳定化压力）：$(64, 10.0, 0.005, 0.02, 1.0)$。\n\n对于每个用例，计算混合精度迭代细化所达到的最终相对残差范数 $\\eta^{(m_\\star)}$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个浮点数都以科学记数法格式化，精确到 8 位有效数字，并按上述用例的顺序列出，例如 $\\left[\\text{res}_1,\\text{res}_2,\\text{res}_3,\\text{res}_4\\right]$。", "solution": "基本原理始于角频率为 $\\omega$ 的时谐场的 Maxwell 方程组，在二维空间中的横磁极化条件下，该方程组可简化为标量 Helmholtz 方程\n$$\n\\left(\\nabla^2 + k^2\\right) u(\\mathbf{r}) = 0,\n$$\n该方程在散射体外部成立，其中 $k = \\omega / c$ 是单位为 $\\mathrm{m}^{-1}$ 的自由空间波数，$u$ 是平面外电场分量。对于理想导电散射体，$u$ 在散射体边界 $\\Gamma$ 上满足适当的边界条件，并且散射场可以通过使用二维 Helmholtz 算子的自由空间格林函数 $G(\\rho)$ 的边界积分公式来表示。散射场的单层势为\n$$\nu^{\\mathrm{scat}}(\\mathbf{r}) = \\int_{\\Gamma} G\\!\\left(\\left\\| \\mathbf{r} - \\mathbf{r}' \\right\\|\\right) \\sigma(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}'),\n$$\n其中 $\\sigma$ 是未知的表面密度。自由空间格林函数为\n$$\nG(\\rho) = \\frac{\\mathrm{i}}{4} H_0^{(1)}(k \\rho),\n$$\n其中 $H_0^{(1)}$ 是第一类零阶 Hankel 函数。为避免非物理奇异性并模拟材料损耗，可以通过将 $k$ 替换为复波数 $k_c = k \\left(1 + \\mathrm{i} \\alpha\\right)$ 来引入一个小的吸收项，其中 $\\alpha \\ge 0$ 是无量纲的。在边界上，将积分表示与一个稳定的对角项（模拟组合场效应）进行配置，即可得到离散稠密系统\n$$\nA x = b,\n$$\n其中未知向量 $x$ 近似为边界节点上 $\\sigma$ 的采样值，$b$ 则编码了入射场的边界条件。对于半径为 $a$ 的圆形边界，其参数化形式为 $r(\\theta) = \\left(a \\cos \\theta, a \\sin \\theta\\right)$，$\\theta \\in [0, 2\\pi)$，采用具有 $N$ 个均匀节点 $\\theta_j = 2 \\pi j / N$、权重 $w = 2 \\pi a / N$ 和稳定化参数 $\\beta > 0$ 的周期梯形 Nyström 离散化，可得\n$$\nA_{ij} = \n\\begin{cases}\nw \\, \\dfrac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c \\left\\| r_i - r_j \\right\\|\\right),  i \\neq j, \\\\\nw \\, \\dfrac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c s_{\\mathrm{avg}}\\right) + \\beta,  i = j,\n\\end{cases}\n$$\n其中 $s_{\\mathrm{avg}} = 2 \\pi a / N$。这种对角线建模方法用一个单元长度上的局部平均值替换了弱奇异的自相互作用，并添加了 $\\beta$ 以改善条件数。对于沿 x 轴方向的平面波入射，右端项为 $b_i = \\exp\\!\\left(\\mathrm{i} \\, k_c \\, x_i\\right)$，其中 $x_i = a \\cos \\theta_i$。\n\n我们现在推导混合精度迭代细化算法。目标是在仅进行单精度分解的情况下，获得满足严格容差 $\\tau$ 的双精度解。设 $A \\in \\mathbb{C}^{N \\times N}$ 和 $b \\in \\mathbb{C}^N$ 在双精度下构建。计算带部分主元的单精度 LU 分解：\n$$\nP A = L U,\n$$\n其中排列矩阵 $P$、下三角矩阵 $L$ 和上三角矩阵 $U$ 均由标准例程在单精度算术中隐式存储。初始化双精度迭代值 $x^{(0)} = 0$。细化迭代过程如下\n$$\nr^{(m)} = b - A x^{(m)}, \\quad \\Delta x^{(m)} \\approx A^{-1} r^{(m)},\n$$\n其中 $A^{-1} r^{(m)}$ 的近似值是通过使用单精度 LU 因子求解三角系统 $U y = L^{-1} P r^{(m)}$ 来实现的。具体而言，将 $r^{(m)}$ 从双精度转换为单精度，在单精度下应用前向和后向替换，然后将得到的 $\\Delta x^{(m)}$ 转换回双精度。更新\n$$\nx^{(m+1)} = x^{(m)} + \\Delta x^{(m)}.\n$$\n每次更新后，计算双精度相对残差范数\n$$\n\\eta^{(m)} = \\frac{\\left\\| r^{(m)} \\right\\|_2}{\\left\\| b \\right\\|_2}.\n$$\n当 $\\eta^{(m)} \\le \\tau$ 或 $m$ 达到最大值 $M$ 时停止。\n\n迭代细化的基本原理是后向误差校正：当在双精度下测量时，残差 $r^{(m)}$ 编码了 $x^{(m)}$ 中的累积误差。使用较低精度的预条件子求解 $\\Delta x^{(m)}$ 会减小前向误差，前提是条件数 $\\kappa_2(A)$ 和单精度机器精度 $\\epsilon_{32}$ 满足 $\\kappa_2(A) \\epsilon_{32} \\ll 1$；这确保了单精度三角求解能产生足够精确的校正，从而使双精度残差按几何级数减小，直到达到双精度的舍入极限。吸收参数 $\\alpha$ 和稳定参数 $\\beta$ 减小了 $\\kappa_2(A)$，从而提高了迭代细化收敛到严格容差的可能性。\n\n算法设计细节：\n- 构建 $r_j = \\left(a \\cos \\theta_j, a \\sin \\theta_j\\right)$，其中 $\\theta_j = 2 \\pi j / N$。圆上两点间的距离 $\\left\\| r_i - r_j \\right\\|$ 为 $\\sqrt{a^2 + a^2 - 2 a^2 \\cos(\\theta_i - \\theta_j)} = a \\sqrt{2 - 2 \\cos(\\theta_i - \\theta_j)} = 2 a \\left| \\sin\\!\\left(\\frac{\\theta_i - \\theta_j}{2}\\right) \\right|$，我们为了稳健性会进行数值计算。\n- 使用 $G(\\rho) = \\dfrac{\\mathrm{i}}{4} H_0^{(1)}\\!\\left(k_c \\rho\\right)$ 和 $k_c = k \\left(1 + \\mathrm{i} \\alpha\\right)$ 在双精度下构建 $A$，并用 $w \\, G(s_{\\mathrm{avg}}) + \\beta$ 设置对角线元素。\n- 使用 $b_i = \\exp\\!\\left(\\mathrm{i} \\, k_c \\, x_i\\right)$ 和 $x_i = a \\cos \\theta_i$ 构建 $b$。\n- 通过标准例程计算单精度 LU 因子 $(L, U, P)$，并在所有细化步骤中重用它们。\n- 迭代直到 $\\eta^{(m)} \\le \\tau$ 或 $m = M$，并记录最终的 $\\eta^{(m_\\star)}$。\n\n该测试套件探究了不同的情景：\n- 用例 1 使用中等的 $N$ 和 $k$ 以及小的吸收和稳定化参数，代表了一个良态条件情景。\n- 用例 2 探测小 $N$ 的低频情况，可能测试由 $\\alpha$ 和 $\\beta$ 缓解的近奇异行为。\n- 用例 3 使用更高的频率和更大的 $N$，对条件数和稠密矩阵组装的计算成本都构成了压力。\n- 用例 4 减小了稳定化参数，挑战了细化过程的稳健性。\n\n程序将组装这些用例，执行迭代细化，并以单行形式输出最终的相对残差范数。输出结果是一个用方括号括起来的逗号分隔列表，其中每个浮点数都采用科学记数法，精确到 8 位有效数字，并按用例顺序排列。结果是无量纲的，所有角度都以弧度为单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef assemble_system(N, k, alpha, beta, a):\n    \"\"\"\n    Assemble the dense boundary integral system matrix A and RHS b\n    for a circular cylinder of radius a in 2D using a stabilized\n    single-layer discretization with periodic trapezoidal rule.\n\n    Parameters:\n        N (int): number of boundary nodes\n        k (float): real wavenumber (1/m)\n        alpha (float): absorption parameter (dimensionless)\n        beta (float): diagonal stabilization parameter (dimensionless)\n        a (float): cylinder radius (m)\n\n    Returns:\n        A64 (np.ndarray): complex128 system matrix (N x N)\n        b64 (np.ndarray): complex128 right-hand side (N,)\n    \"\"\"\n    # Discretization points on the circle\n    j = np.arange(N, dtype=np.float64)\n    theta = 2.0 * np.pi * j / float(N)\n    # Boundary points r_j = (a cos theta_j, a sin theta_j)\n    x = a * np.cos(theta)\n    y = a * np.sin(theta)\n\n    # Complex wavenumber with small absorption\n    kc = complex(k, k * alpha)  # k * (1 + i*alpha) == k + i*k*alpha\n\n    # Pairwise distances on a circle: robust computation\n    # Using broadcasting to compute all pairwise differences\n    theta_i = theta.reshape(-1, 1)\n    theta_j = theta.reshape(1, -1)\n    dtheta = theta_i - theta_j\n    # rho_ij = 2 a |sin((theta_i - theta_j)/2)|\n    rho = 2.0 * a * np.abs(np.sin(0.5 * dtheta))\n\n    # Weight for trapezoidal rule\n    w = 2.0 * np.pi * a / float(N)\n    # Average panel length for diagonal replacement\n    s_avg = w\n\n    # Assemble A in complex128\n    A64 = np.empty((N, N), dtype=np.complex128)\n    # Off-diagonal: w * G(rho_ij)\n    # Green's function G(rho) = i/4 * H0^(1)(kc * rho)\n    # Compute hankel1 for all entries; we will fix diagonal separately\n    # Note: hankel1 expects real argument, but kc*rho may be complex.\n    # We compute H0^(1) over complex arguments via series: not available.\n    # Instead, use that for small absorption alpha, kc is complex, so hankel1\n    # with complex argument is handled by SciPy for complex input.\n    # Prepare complex argument\n    z = kc * rho\n    # Compute Hankel of order 0, first kind\n    H0 = hankel1(0, z)\n    G = 1j * 0.25 * H0\n    A64[:] = w * G\n\n    # Diagonal: replace with w * G(s_avg) + beta\n    H0_diag = hankel1(0, kc * s_avg)\n    G_diag = 1j * 0.25 * H0_diag\n    np.fill_diagonal(A64, w * G_diag + beta)\n\n    # Right-hand side: incident plane wave along +x: b_i = exp(i * kc * x_i)\n    b64 = np.exp(1j * kc * x)\n\n    return A64, b64\n\ndef mixed_precision_iterative_refinement(A64, b64, max_iters=50, tol=1e-11):\n    \"\"\"\n    Perform mixed-precision iterative refinement using single-precision\n    LU factorization as a preconditioner to solve A x = b in double precision.\n\n    Parameters:\n        A64 (np.ndarray): complex128 system matrix\n        b64 (np.ndarray): complex128 right-hand side\n        max_iters (int): maximum number of refinement iterations\n        tol (float): target relative residual tolerance\n\n    Returns:\n        rel_res (float): final achieved relative residual norm\n    \"\"\"\n    # Single-precision copy and LU factorization\n    A32 = A64.astype(np.complex64)\n    try:\n        lu32, piv = lu_factor(A32)\n    except Exception:\n        # In case factorization fails due to precision issues, upcast to float64 (but this violates mixed precision).\n        # To adhere to the problem, we keep single-precision and propagate failure via large residual.\n        return float(\"inf\")\n\n    # Initialize x in double precision\n    x64 = np.zeros_like(b64, dtype=np.complex128)\n\n    # Precompute norm of b\n    norm_b = np.linalg.norm(b64)\n\n    # Iterate\n    rel_res = np.inf\n    for _ in range(max_iters):\n        # Residual in double precision\n        r64 = b64 - A64 @ x64\n        norm_r = np.linalg.norm(r64)\n        rel_res = (norm_r / norm_b) if norm_b != 0.0 else 0.0\n\n        if rel_res = tol:\n            break\n\n        # Solve for correction in single precision using LU\n        r32 = r64.astype(np.complex64)\n        dx32 = lu_solve((lu32, piv), r32)\n        dx64 = dx32.astype(np.complex128)\n\n        # Update\n        x64 += dx64\n\n    # Return final double-precision relative residual\n    # Recompute final residual to be consistent\n    r64 = b64 - A64 @ x64\n    rel_res = (np.linalg.norm(r64) / norm_b) if norm_b != 0.0 else 0.0\n    return float(rel_res.real)  # residual norm is real\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, k, alpha, beta, a)\n    test_cases = [\n        (64, 20.0, 0.010, 0.10, 1.0),  # Case 1\n        (16, 0.50, 0.020, 0.20, 1.0),  # Case 2\n        (128, 40.0, 0.005, 0.05, 1.0), # Case 3\n        (64, 10.0, 0.005, 0.02, 1.0),  # Case 4\n    ]\n\n    results = []\n    for (N, k, alpha, beta, a) in test_cases:\n        A64, b64 = assemble_system(N, k, alpha, beta, a)\n        rel_res = mixed_precision_iterative_refinement(A64, b64, max_iters=50, tol=1e-11)\n        results.append(rel_res)\n\n    # Format floats in scientific notation with exactly 8 significant digits.\n    formatted = [f\"{val:.8e}\" for val in results]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3299108"}]}