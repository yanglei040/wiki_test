{"hands_on_practices": [{"introduction": "Lax-Richtmyer等价定理是数值分析的基石，它指出对于一个适定的线性问题，稳定性和相容性共同构成了收敛的充分必要条件。本练习通过分析一个特意设计为稳定但非相容的格式，为该定理提供了一个关键的证明。通过观察其无法收敛到正确解的现象，您将亲身体会到为何相容性是任何可靠数值方法不可或缺的要求 [@problem_id:3394996]。", "problem": "考虑周期性线性平流初值问题 $u_{t} + a\\,u_{x} = 0$，其中 $x \\in [0,2\\pi]$ 且 $t \\ge 0$，具有周期性边界条件和零初始数据 $u(x,0) = 0$。这个问题的适定性在于，对于一个合适的赋范空间中的任何容许的初始数据，都存在一个唯一解，并且该解连续地依赖于初始数据。在谱方法和间断伽辽金（DG）方法的背景下，如果一个线性格式的齐次部分在所选范数下产生有界演化，则称该格式是稳定的；如果离散算子作用于足够光滑的精确解所产生的残差在网格加密时趋于零，则称该格式是相容的。\n\n构建如下具有 $N$ 个模态（由整数 $k$ 标记，其中 $|k| \\le K$ 且 $N = 2K+1$）的傅里叶谱半离散格式：将 $u_{N}(x,t)$ 展开为 $u_{N}(x,t) = \\sum_{|k| \\le K} \\hat{u}_{k}(t)\\,\\exp(i k x)$，并根据以下方程演化模态系数：\n$$\n\\frac{d}{dt}\\,\\hat{u}_{k}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}(t) \\;+\\; \\gamma\\,\\delta_{k,0},\n$$\n其中参数 $a = 1$，强迫振幅 $\\gamma = 1$，$\\delta_{k,0}$ 为克罗内克δ函数。假设对此半离散系统进行精确时间积分。该格式是线性的，其齐次部分对应于斜伴随平流算子的标准傅里叶谱离散化，该离散化在 $L^{2}$ 范数下是保范数的。然而，增加的零模态强迫项使得该格式与原始齐次问题不相容。\n\n从上述定义和半离散系统的精确演化出发，利用第一性原理推导，证明该格式是稳定的（在齐次演化保持 $L^{2}$ 范数的意义上）但不相容，并解释为什么它不收敛于精确解 $u \\equiv 0$。然后，计算当模态数 $N \\to \\infty$ 时，在时间 $t = 1$ 处的 $L^{2}$ 误差的极限：\n$$\n\\lim_{N \\to \\infty} \\,\\left\\| u_{N}(\\cdot,1) - 0 \\right\\|_{L^{2}(0,2\\pi)}.\n$$\n请以单一的闭式解析表达式形式给出最终答案。无需四舍五入。若有角度，必须以弧度表示。", "solution": "首先验证问题，以确保其具有科学依据、适定且客观。\n\n已知条件如下：\n1.  偏微分方程（PDE）是线性平流方程：$u_{t} + a\\,u_{x} = 0$。\n2.  空间域为 $x \\in [0,2\\pi]$，具有周期性边界条件。\n3.  时间域为 $t \\ge 0$。\n4.  初始条件为 $u(x,0) = 0$。\n5.  提出了一个傅里叶谱半离散格式，用于数值解 $u_{N}(x,t) = \\sum_{|k| \\le K} \\hat{u}_{k}(t)\\,\\exp(i k x)$，其中 $N = 2K+1$。\n6.  模态系数 $\\hat{u}_{k}(t)$ 的演化由常微分方程（ODE）系统给出：$\\frac{d}{dt}\\,\\hat{u}_{k}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}(t) \\;+\\; \\gamma\\,\\delta_{k,0}$。\n7.  该格式的初始条件与 $u(x,0)=0$ 一致，这意味着对所有 $k$ 都有 $\\hat{u}_{k}(0)=0$。\n8.  参数指定为 $a = 1$ 和 $\\gamma = 1$。\n9.  初值问题的精确解是对所有 $x$ 和 $t$ 都有 $u(x,t) = 0$。\n10. 任务是证明该格式是稳定的但不相容，解释由此导致的不收敛性，并计算当 $N \\to \\infty$ 时在 $t=1$ 处的 $L^{2}$ 误差的极限。\n\n该问题在数学上是定义明确的、内部一致的，并直接关系到偏微分方程数值方法的分析，特别是拉克斯等价定理所描述的稳定性、相容性和收敛性之间的相互作用。所构建的格式是一个用于说明相容性重要性的教科书式例子。因此，该问题是有效的。\n\n我们开始求解，求解过程包括三个部分：稳定性和相容性分析、不收敛性解释以及误差计算。\n\n首先，我们分析格式的稳定性。根据问题陈述，稳定性由格式的齐次部分的行为决定。给定的半离散格式为：\n$$\n\\frac{d}{dt}\\,\\hat{u}_{k}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}(t) \\;+\\; \\gamma\\,\\delta_{k,0}\n$$\n齐次部分是通过移除强迫项 $\\gamma\\,\\delta_{k,0}$ 得到的：\n$$\n\\frac{d}{dt}\\,\\hat{u}_{k}^{h}(t) \\;=\\; -\\,i\\,a\\,k\\,\\hat{u}_{k}^{h}(t)\n$$\n其中 $\\hat{u}_{k}^{h}(t)$ 表示齐次演化的系数。这个线性常微分方程的解是 $\\hat{u}_{k}^{h}(t) = \\hat{u}_{k}^{h}(0) \\exp(-iakt)$。数值解 $u_{N}(x,t)$ 的 $L^{2}$ 范数通过帕塞瓦尔定理与其傅里叶系数相关联：\n$$\n\\left\\| u_{N}(\\cdot, t) \\right\\|_{L^{2}(0,2\\pi)}^{2} = \\int_{0}^{2\\pi} |u_{N}(x,t)|^{2} dx = 2\\pi \\sum_{|k| \\le K} |\\hat{u}_{k}(t)|^{2}\n$$\n对于齐次演化，我们考察系数模的平方：\n$$\n|\\hat{u}_{k}^{h}(t)|^{2} = \\left| \\hat{u}_{k}^{h}(0) \\exp(-iakt) \\right|^{2} = |\\hat{u}_{k}^{h}(0)|^{2} |\\exp(-iakt)|^{2} = |\\hat{u}_{k}^{h}(0)|^{2}\n$$\n因为对于任何实数 $\\theta$，都有 $|\\exp(i\\theta)|=1$。对所有模态求和，我们得到：\n$$\n\\sum_{|k| \\le K} |\\hat{u}_{k}^{h}(t)|^{2} = \\sum_{|k| \\le K} |\\hat{u}_{k}^{h}(0)|^{2}\n$$\n这意味着 $\\left\\| u_{N}^{h}(\\cdot, t) \\right\\|_{L^{2}}^{2} = \\left\\| u_{N}^{h}(\\cdot, 0) \\right\\|_{L^{2}}^{2}$。齐次格式的解的 $L^{2}$ 范数在所有时间内都是守恒的。一个保范数的演化是有界的（其算子范数为1）。因此，根据所提供的定义，该格式是稳定的。\n\n其次，我们分析相容性。如果将偏微分方程的精确解代入数值格式所得到的截断误差——即残差——在离散化加密（$N \\to \\infty$）时趋于零，则称该格式与该偏微分方程是相容的。对于 $u_{t} + a u_{x} = 0$ 且 $u(x,0)=0$ 的问题，其精确解为对所有 $t \\ge 0$ 都有 $u(x,t) = 0$。该精确解的傅里叶系数为对所有 $k$ 和 $t$ 都有 $\\hat{u}_{k,exact}(t) = 0$。\n我们将这些精确解的系数代入完整的数值格式，以求出每个模态的残差 $\\tau_k(t)$：\n$$\n\\tau_k(t) = \\frac{d}{dt}\\hat{u}_{k,exact}(t) - \\left( -iak\\,\\hat{u}_{k,exact}(t) + \\gamma\\,\\delta_{k,0} \\right)\n$$\n代入 $\\hat{u}_{k,exact}(t) = 0$ 及其时间导数 $\\frac{d}{dt}(0)=0$：\n$$\n\\tau_k(t) = 0 - \\left( -iak \\cdot 0 + \\gamma\\,\\delta_{k,0} \\right) = -\\gamma\\,\\delta_{k,0}\n$$\n当 $\\gamma=1$ 时，残差为 $\\tau_k(t) = -\\delta_{k,0}$。对于 $k=0$ 模态，残差为 $\\tau_0 = -1$，而对于所有其他模态 $k \\neq 0$，残差为 $\\tau_k = 0$。零阶模态的残差是一个非零常数值。它不依赖于模态数 $N$，因此当 $N \\to \\infty$ 时不趋于零。所以，该格式与齐次偏微分方程 $u_t + a u_x = 0$ 是不相容的。\n\n不收敛是这种不相容性的直接后果，这可由拉克斯-里奇迈尔等价定理来解释。该定理指出，对于一个适定的线性初值问题，一个相容的线性有限差分格式是收敛的当且仅当它是稳定的。在这里，该格式是稳定的但不是相容的。该定理关于收敛的条件没有被满足。该格式实际上是另一个不同偏微分方程 $u_t + a u_x = F(x)$ 的相容离散化，其中 $F(x)$ 是一个傅里叶系数为 $\\gamma\\,\\delta_{k,0}$ 的函数。这对应于一个空间上恒定的强迫项 $F(x) = \\gamma=1$。该数值格式正在解决一个错误的问题，因此其解不会收敛到目标问题的解。源项 $\\gamma\\,\\delta_{k,0}$ 持续地向零阶模态注入一个非物理信号，导致数值解偏离真实解 $u=0$。\n\n最后，我们计算在 $t=1$ 时 $L^{2}$ 误差的极限。我们必须求解具有指定参数 $a=1$, $\\gamma=1$ 和初始条件 $\\hat{u}_k(0)=0$ 的半离散系统的精确解。该常微分方程系统为：\n$$\n\\frac{d}{dt}\\hat{u}_{k}(t) = -ik\\hat{u}_{k}(t) + \\delta_{k,0}\n$$\n我们分两种情况求解。\n情况 1：$k \\neq 0$。方程为 $\\frac{d}{dt}\\hat{u}_{k}(t) = -ik\\hat{u}_{k}(t)$。在初始条件 $\\hat{u}_k(0)=0$ 下，唯一解是对所有 $t$ 都有 $\\hat{u}_{k}(t)=0$。\n情况 2：$k=0$。方程为 $\\frac{d}{dt}\\hat{u}_{0}(t) = -i(0)\\hat{u}_{0}(t) + 1$，简化为 $\\frac{d}{dt}\\hat{u}_{0}(t) = 1$。从 $0$ 到 $t$ 积分得到 $\\hat{u}_{0}(t) - \\hat{u}_{0}(0) = \\int_0^t 1 ds = t$。因为 $\\hat{u}_{0}(0)=0$，我们有 $\\hat{u}_{0}(t)=t$。\n\n因此，数值解的系数为 $\\hat{u}_{k}(t) = t\\,\\delta_{k,0}$。在物理空间中的数值解为：\n$$\nu_{N}(x,t) = \\sum_{|k| \\le K} \\hat{u}_{k}(t)\\,\\exp(ikx) = \\hat{u}_{0}(t)\\exp(i \\cdot 0 \\cdot x) = t\n$$\n解 $u_{N}(x,t)=t$ 是一个空间上恒定且随时间线性增长的函数。该解对任何 $N \\ge 1$（即 $K \\ge 0$）都有效。\n\n误差为 $e_{N}(x,t) = u_{N}(x,t) - u(x,t) = t - 0 = t$。\n我们被要求计算在时间 $t=1$ 时误差的 $L^{2}$ 范数。此时的误差是 $e_N(x,1) = 1$。\n误差的 $L^{2}$ 范数的平方是：\n$$\n\\left\\| e_{N}(\\cdot,1) \\right\\|_{L^{2}(0,2\\pi)}^{2} = \\int_{0}^{2\\pi} |e_{N}(x,1)|^{2} dx = \\int_{0}^{2\\pi} |1|^{2} dx = \\int_{0}^{2\\pi} 1 dx = 2\\pi\n$$\n因此，在 $t=1$ 时误差的 $L^{2}$ 范数为 $\\left\\| e_{N}(\\cdot,1) \\right\\|_{L^{2}(0,2\\pi)} = \\sqrt{2\\pi}$。\n\n这个结果与 $N$ 无关。因此，当 $N \\to \\infty$ 时的极限是相同的值：\n$$\n\\lim_{N \\to \\infty} \\,\\left\\| u_{N}(\\cdot,1) - 0 \\right\\|_{L^{2}(0,2\\pi)} = \\sqrt{2\\pi}\n$$\n这个非零极限证实了该格式不收敛于精确解。", "answer": "$$\n\\boxed{\\sqrt{2\\pi}}\n$$", "id": "3394996"}, {"introduction": "虽然相容性是必要的，但它并非收敛的充分条件；一个格式还必须是稳定的。本实践练习将探讨一个常见的情景：一个热方程的相容有限差分格式在应用于非均匀网格时，可能会变得剧烈不稳定并无法收敛。通过编程实现该格式，并观察当时间步长未根据最小网格间距选择时出现的爆炸性误差增长，您将具体领会到稳定性是一种局部属性，并理解其在Lax等价定理中的关键作用 [@problem_id:3217060]。", "problem": "考虑空间区间 $x \\in (0,1)$上的一维热方程 $u_t = u_{xx}$，其具有齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$，以及光滑初始条件 $u(x,0) = \\sin(\\pi x)$。本题的目标是研究在非均匀网格上，显式时间步进格式的一致性、稳定性和收敛性之间的相互作用，并在实践中检验Lax等价定理。\n\n从核心定义开始：\n- 一致性：当空间步长 $h_i$ 和时间步长 $\\Delta t$ 趋于零时，局部截断误差趋于零。\n- 稳定性：离散解算子对于输入数据或舍入误差的扰动是有界的，通常通过放大因子的界来表征。\n- 收敛性：在选定的范数（此处为平方可积范数）下，数值解逼近原始连续模型的精确解。\n\n使用非均匀二阶导数有限差分在内部节点 $x_i$ 上构建显式前向欧拉线法格式为\n$$u^{n+1}_i = u^n_i + \\Delta t \\, D^{(2)}u^n_i,$$\n其中 $D^{(2)}$ 是在间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_{i} = x_{i+1} - x_i$ 的非均匀网格上，通过泰勒展开推导出的三点二阶导数近似\n$$D^{(2)}u_i \\approx 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)。$$\n通过设置 $u^n_0 = 0$ 和 $u^n_{N+1} = 0$ 来施加边界条件。\n\n将离散空间算子 $L$ 定义为作用于内部节点值向量 $\\mathbf{u}^n = (u^n_1,\\dots,u^n_N)^\\top$ 的 $D^{(2)}$ 的矩阵表示，从而该方法可以写成 $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$。对于给定的初始条件，其精确解为 $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$。\n\n您必须：\n1. 在严格递增网格 $\\{x_i\\}_{i=0}^{N+1}$（其中 $x_0 = 0$ 且 $x_{N+1} = 1$）上实现非均匀网格二阶导数算子 $L$。\n2. 对于每个测试用例，计算：\n   - 最大单步放大因子 $a_{\\max} = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$，其中 $\\mathrm{spec}(L)$ 表示 $L$ 的谱（特征值集合）。\n   - 与 $u(x,\\Delta t)$ 相比的单步误差的离散平方可积范数（$L^2$ 范数），对内部节点使用求积权重 $w_i = \\tfrac{h_{i-1} + h_i}{2}$，并定义范数 $\\|\\mathbf{v}\\|_{L^2} = \\left(\\sum_{i=1}^N w_i v_i^2\\right)^{1/2}$。\n   - 加密误差比 $r = E_{2N} / E_{N}$，其中 $E_{N}$ 是在具有 $N$ 个内部节点的网格上的单步离散 $L^2$ 误差，$E_{2N}$ 是在具有 $2N$ 个内部节点的网格上的类似误差，两者均使用下述相同的步长选择策略。\n   - 由 $a_{\\max} \\le 1$ 定义的稳定性布尔值。\n3. 通过计算出的值，解释如果时间步长不与最小网格尺寸成比例，格式如何在 $L^2$ 范数下是逐点一致的（即当 $N \\to \\infty$ 和 $\\Delta t \\to 0$ 时局部截断误差趋于零），但却不稳定并因此不收敛。具体而言，展示当网格是强非均匀时，将 $\\Delta t$ 与平均步长的平方成比例会导致 $a_{\\max} > 1$，这会破坏稳定性，并根据Lax等价定理阻止收敛。\n\n使用以下测试套件。对于每个用例，根据指定的策略构建网格并选择时间步长：\n- 用例A（理想情况，均匀且稳定）：$N = 64$，均匀网格 $x_i = i/(N+1)$，选择 $\\Delta t = 0.45\\, h_{\\min}^2$，其中 $h_{\\min} = \\min_i (x_{i+1} - x_i)$。\n- 用例B（边缘情况，非均匀且因平均缩放而不稳定）：$N = 64$，分级网格 $x_i = \\left(\\frac{i}{N+1}\\right)^p$，其中 $p = 2$，选择 $\\Delta t = 0.45\\, \\bar{h}^2$，其中 $\\bar{h} = \\frac{1}{N+1}\\sum_{i=0}^N (x_{i+1} - x_i)$。\n- 用例C（非均匀但因最小缩放而稳定）：$N = 64$，分级网格 $x_i = \\left(\\frac{i}{N+1}\\right)^p$，其中 $p = 2$，选择 $\\Delta t = 0.45\\, h_{\\min}^2$。\n\n对于每个用例，在相同策略下通过比较 $E_N$ 和 $E_{2N}$ 来计算 $a_{\\max}$、稳定性布尔值和加密误差比 $r$。所有量均为无量纲。\n\n您的程序应生成单行输出，其中包含结果，格式为一个用方括号括起来、不含空格的逗号分隔列表，其中每个用例贡献一个形如 $[$stable\\_boolean$,a_{\\max},r]$ 的子列表。例如，包含三个用例的输出应类似于 $[[\\mathrm{True},0.9,0.5],[\\mathrm{False},3.1,1.8],[\\mathrm{True},0.8,0.6]]$，并且该行中任何地方都没有空格。", "solution": "所述问题是数值分析中一个适定且科学上合理的问题，旨在研究求解一维热方程的数值格式的一致性、稳定性和收敛性之间的相互依赖关系。所有提供的方程、条件和定义都是标准且正确的。该问题是有效的。\n\n此问题的核心在于Lax等价定理，该定理指出，对于一个一致的线性有限差分格式，稳定性是其收敛的充分必要条件。我们将通过在非均匀网格上对热方程 $u_t = u_{xx}$ 应用显式的时间前向、空间中心 (FTCS) 格式来展示这一原理。\n\n该数值方法由更新规则 $\\mathbf{u}^{n+1} = \\left(I + \\Delta t\\, L\\right)\\mathbf{u}^n$ 定义，其中 $\\mathbf{u}^n$ 是在时间步 $n$ 处内部网格点上的数值解向量，$I$ 是单位矩阵，$\\Delta t$ 是时间步长，$L$ 是由下式给出的二阶导数算子 $D^{(2)}$ 的矩阵表示\n$$D^{(2)}u_i = 2\\left(\\frac{u_{i-1}}{h_{i-1}(h_{i-1}+h_i)} - \\frac{u_i}{h_{i-1}h_i} + \\frac{u_{i+1}}{h_i(h_{i-1}+h_i)}\\right)$$\n对于一个间距为 $h_{i-1} = x_i - x_{i-1}$ 和 $h_i = x_{i+1} - x_i$ 的网格。该算子与连续二阶导数 $u_{xx}$ 是一致的；其局部截断误差在网格间距趋于零时趋于零。\n\n这种显式格式的稳定性由放大矩阵 $G = I + \\Delta t\\, L$ 的谱半径决定。稳定性要求单步放大因子 $a_{\\max} = \\rho(G) = \\max_{\\lambda \\in \\mathrm{spec}(L)} |1 + \\Delta t\\, \\lambda|$ 不得超过1。离散拉普拉斯算子 $L$ 的特征值 $\\lambda$ 是实数且非正的。设 $\\lambda_{\\min}$ 是 $L$ 的最小（最负）特征值。稳定性条件简化为 $1 + \\Delta t\\, \\lambda_{\\min} \\ge -1$，从而得出约束条件：\n$$\\Delta t \\le \\frac{-2}{\\lambda_{\\min}}$$\n对于非均匀网格，$\\lambda_{\\min}$ 的大小由最小网格间距 $h_{\\min}$ 决定。可以证明 $|\\lambda_{\\min}|$ 与 $1/h_{\\min}^2$ 成比例。这导致了显式格式众所周知的稳定性要求：\n$$\\Delta t \\le C \\cdot h_{\\min}^2$$\n对于某个常数 $C$（在均匀网格情况下，$C=1/2$）。一个关键的见解是，稳定性取决于*最小*间距 $h_{\\min}$，而不是平均间距 $\\bar{h}$。问题的测试用例就是为了说明这一点而设计的。\n\n对于每个用例，我们将计算最大放大因子 $a_{\\max}$，通过条件 $a_{\\max} \\le 1$ 来确定稳定性，并通过单步误差加密比 $r = E_{2N} / E_N$ 来评估收敛行为。比率 $r < 1$ 表明收敛，而 $r \\ge 1$ 则暗示发散。\n\n**用例 A：均匀网格，稳定时间步长**\n网格是均匀的，意味着对所有 $i$ 都有 $h_i = h = \\bar{h} = h_{\\min}$。时间步长选择为 $\\Delta t = 0.45\\, h_{\\min}^2 = 0.45\\, h^2$。这满足稳定性条件 $\\Delta t \\le 0.5\\, h^2$。因此，我们预期该格式是稳定的，即 $a_{\\max} \\le 1$。由于格式既一致又稳定，Lax等价定理保证了其收敛性。这应该会通过加密比 $r < 1$ 反映出来。\n\n**用例 B：非均匀网格，不稳定时间步长**\n采用分级网格 $x_i = (i/(N+1))^2$，这使得点集中在 $x=0$ 附近，导致与平均间距 $\\bar{h}$ 相比，$h_{\\min}$ 非常小。时间步长设置为 $\\Delta t = 0.45\\, \\bar{h}^2$。由于 $\\bar{h} \\gg h_{\\min}$，这个 $\\Delta t$ 的选择将远大于基于 $h_{\\min}^2$ 的稳定性条件所允许的值。\n$$\\Delta t = 0.45\\, \\bar{h}^2 = 0.45 \\left(\\frac{\\bar{h}}{h_{\\min}}\\right)^2 h_{\\min}^2 \\gg h_{\\min}^2$$\n因此我们预测该格式将是不稳定的，即 $a_{\\max} > 1$。尽管这是一个一致的格式，但这种不稳定性将导致不收敛，这应该由误差比 $r \\ge 1$ 来证明。\n\n**用例 C：非均匀网格，稳定时间步长**\n此用例使用与用例B相同的分级网格，但修正了时间步长策略中的缺陷。时间步长选择为 $\\Delta t = 0.45\\, h_{\\min}^2$。这个选择遵守了由最小网格单元施加的约束，旨在满足稳定性条件。我们预期会发现 $a_{\\max} \\le 1$。随着一致性和稳定性都重新建立，该格式应该再次收敛，从而产生一个加密比 $r < 1$。\n\n该实现将构建矩阵 $L$，计算其特征值以找到 $a_{\\max}$，并计算相对于精确解 $u(x,t) = e^{-\\pi^2 t}\\sin(\\pi x)$ 的单步 $L^2$ 误差，以确定加密比 $r$。这些结果将提供Lax等价定理的实践演示，并说明根据最严格的局部网格间距选择时间步长的至关重要性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case_metrics(N, p, dt_policy):\n    \"\"\"\n    Computes stability and error metrics for a given grid and time step policy.\n\n    Args:\n        N (int): Number of interior grid points.\n        p (float): Power for graded grid generation. p=1 gives a uniform grid.\n        dt_policy (str): Time step policy, either 'min' or 'avg'.\n\n    Returns:\n        tuple: A tuple containing:\n            - l2_error (float): The discrete L2 norm of the one-step error.\n            - a_max (float): The maximum one-step amplification factor.\n            - is_stable (bool): True if the scheme is stable, False otherwise.\n    \"\"\"\n    # 1. Grid Generation\n    i_vals = np.arange(N + 2, dtype=float)\n    x = (i_vals / (N + 1))**p\n    h = np.diff(x)  # h has length N+1, h_i = x_{i+1} - x_i\n\n    # 2. Time Step Calculation\n    h_min = np.min(h)\n    # The problem defines h_bar as the sum over N+1 spacings divided by N+1\n    h_bar = np.mean(h)\n    \n    if dt_policy == 'min':\n        dt = 0.45 * h_min**2\n    elif dt_policy == 'avg':\n        dt = 0.45 * h_bar**2\n    else:\n        raise ValueError(\"Invalid dt_policy specified.\")\n\n    # 3. Construct the discrete operator matrix L\n    L = np.zeros((N, N))\n    # Loop over interior nodes i = 1, ..., N\n    # Matrix row j = i - 1 corresponds to node i\n    for j in range(N):\n        h_im1 = h[j]      # This is h_{i-1}\n        h_i   = h[j + 1]  # This is h_i\n        \n        # Diagonal term (coefficient of u_i)\n        L[j, j] = 2.0 * (-1.0 / (h_im1 * h_i))\n        \n        # Sub-diagonal term (coefficient of u_{i-1})\n        if j > 0:\n            L[j, j - 1] = 2.0 / (h_im1 * (h_im1 + h_i))\n        \n        # Super-diagonal term (coefficient of u_{i+1})\n        if j < N - 1:\n            L[j, j + 1] = 2.0 / (h_i * (h_im1 + h_i))\n\n    # 4. Compute stability metrics\n    eigenvalues = np.linalg.eigvals(L)\n    a_max = np.max(np.abs(1.0 + dt * eigenvalues))\n    is_stable = a_max <= 1.0\n\n    # 5. Compute one-step L2 error\n    x_interior = x[1:N + 1]\n    \n    # Initial condition at interior nodes\n    u0 = np.sin(np.pi * x_interior)\n    \n    # Numerical solution at t = dt\n    u1_num = u0 + dt * (L @ u0)\n    \n    # Exact solution at t = dt\n    u1_exact = np.exp(-np.pi**2 * dt) * np.sin(np.pi * x_interior)\n    \n    # Error vector\n    error_vec = u1_num - u1_exact\n    \n    # Quadrature weights for L2 norm\n    # w_i = (h_{i-1} + h_i)/2. For interior nodes i=1..N, these are h_0..h_{N-1} + h_1..h_N\n    weights = 0.5 * (h[0:N] + h[1:N + 1])\n    \n    l2_error = np.sqrt(np.sum(weights * error_vec**2))\n    \n    return l2_error, a_max, is_stable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # (N_base, p, dt_policy) for each case\n    # p=1 represents a uniform grid as (i/(N+1))^1.\n    test_cases_params = [\n        (64, 1.0, 'min'),  # Case A: Uniform grid, stable by h_min\n        (64, 2.0, 'avg'),  # Case B: Graded grid, unstable by h_bar\n        (64, 2.0, 'min'),  # Case C: Graded grid, stable by h_min\n    ]\n\n    final_results = []\n    for N_base, p, policy in test_cases_params:\n        # Calculate metrics for the base grid N\n        E_N, a_max, is_stable = compute_case_metrics(N_base, p, policy)\n        \n        # Calculate error for the refined grid 2N to find the ratio\n        E_2N, _, _ = compute_case_metrics(2 * N_base, p, policy)\n        \n        # Refinement error ratio\n        r = E_2N / E_N\n        \n        final_results.append([is_stable, a_max, r])\n    \n    # Format the output string exactly as specified: [[val,val,val],[val,val,val],...]\n    case_strings = []\n    for s_bool, a_val, r_val in final_results:\n        # Python's bool __str__ is 'True' or 'False'\n        case_strings.append(f\"[{str(s_bool)},{a_val},{r_val}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3217060"}, {"introduction": "先进的数值方法致力于将稳定性和守恒律直接构建在离散化过程之中。本练习将向您介绍一种基于离散外微分的强大结构保持方法，使用关联矩阵来表示麦克斯韦方程组。您将首先验证一个基本的拓扑性质——边界的边界为空（$\\mathbf{C}\\mathbf{G}=\\mathbf{0}$），然后实现一个蛙跳格式以监测离散能量泛函来检验其稳定性，从而将CFL条件与能量守恒直接联系起来 [@problem_id:3335818]。", "problem": "给定积分形式的无源麦克斯韦方程组和二维矩形主网格上的离散拓扑恒等式，使用关联矩阵构建一个基于图的半离散格式。考虑一个包含 $N_x \\times N_y$ 个主网格面、$ (N_x+1)\\times(N_y+1)$ 个主网格节点、$N_x(N_y+1)$ 条沿 $+x$ 方向的水平主网格边以及 $(N_x+1)N_y$ 条沿 $+y$ 方向的垂直主网格边的均匀矩形网格。对于每条有向边，在其尾节点处赋值 $-1$、头节点处赋值 $+1$ 来定义节点-边关联矩阵 $\\mathbf{G}$；对于每个面，当边的方向与面的逆时针边界方向一致时，符号为 $+1$，否则为 $-1$，通过组合每个面的边界来定义边-面关联（离散旋度）矩阵 $\\mathbf{C}$。\n\n使用此设置：\n- 离散梯度由 $\\mathbf{G}$ 表示，离散旋度由 $\\mathbf{C}$ 表示。\n- 离散幂零条件要求 $\\mathbf{C}\\mathbf{G}=\\mathbf{0}$，这对应于“边界的边界”恒等式。\n- 在z方向横磁（TM$_z$）极化中，将电场分量 $E_x$ 和 $E_y$ 放置在主网格边上，磁通量密度 $B_z$ 放置在主网格面上。对于均匀的介电常数 $\\varepsilon$ 和磁导率 $\\mu$，定义半离散、无损、无源的麦克斯韦系统如下：\n$$\n\\frac{d}{dt}\\mathbf{B} = - \\mathbf{C}\\,\\mathbf{E}, \\qquad\n\\frac{d}{dt}\\mathbf{E} = \\frac{1}{\\varepsilon\\mu}\\mathbf{C}^\\top \\mathbf{B},\n$$\n其能量泛函为\n$$\n\\mathcal{H}(t) = \\frac{1}{2}\\,\\varepsilon\\,\\mathbf{E}(t)^\\top \\mathbf{E}(t) + \\frac{1}{2}\\,\\frac{1}{\\mu}\\,\\mathbf{B}(t)^\\top \\mathbf{B}(t).\n$$\n\n你的程序必须：\n1. 为指定的 $(N_x,N_y)$ 构建 $\\mathbf{G}$ 和 $\\mathbf{C}$。\n2. 通过计算 $\\mathbf{C}\\mathbf{G}$ 的弗罗贝尼乌斯范数来验证离散幂零性，并报告一个布尔值，指示是否满足 $\\lVert \\mathbf{C}\\mathbf{G}\\rVert_F \\leq \\tau$（容差 $\\tau=10^{-12}$）。\n3. 为上述半离散系统实现一个显式蛙跳时间离散化，其中磁通量密度 $\\mathbf{B}$ 存储在半时间步长 $t = (n+\\tfrac{1}{2})\\Delta t$ 上，电场 $\\mathbf{E}$ 存储在整数时间步长 $t=n\\Delta t$ 上：\n   - 使用确定性的（有种子的）伪随机值初始化 $\\mathbf{E}^0$，并设 $\\mathbf{B}^{-1/2}=\\mathbf{0}$。\n   - 更新 $\\mathbf{B}^{n+1/2} = \\mathbf{B}^{n-1/2} - \\Delta t\\,\\mathbf{C}\\,\\mathbf{E}^n$，然后更新 $\\mathbf{E}^{n+1} = \\mathbf{E}^n + \\Delta t\\,\\frac{1}{\\varepsilon\\mu}\\,\\mathbf{C}^\\top \\mathbf{B}^{n+1/2}$。\n   - 在每个整数时间 $n$，计算离散能量\n     $$\n     \\mathcal{H}^n = \\frac{1}{2}\\,\\varepsilon\\,\\left(\\mathbf{E}^n\\right)^\\top \\mathbf{E}^n + \\frac{1}{2}\\,\\frac{1}{\\mu}\\,\\left(\\mathbf{B}^{n+1/2}\\right)^\\top \\mathbf{B}^{n+1/2}.\n     $$\n4. 通过 $\\mathbf{C}$ 的谱范数确定半离散系统的最大离散角频率 $\\omega_{\\max}$，使用\n   $$\n   \\omega_{\\max} = \\sqrt{\\frac{1}{\\varepsilon\\mu}}\\,\\sigma_{\\max}(\\mathbf{C}),\n   $$\n   其中 $\\sigma_{\\max}(\\mathbf{C})$ 是 $\\mathbf{C}$ 的最大奇异值。\n5. 对于定义如下的三个不同时间步长 $\\Delta t$\n   $$\n   \\Delta t_{\\text{small}} = \\frac{1.9}{\\omega_{\\max}}, \\quad \\Delta t_{\\text{critical}} = \\frac{2.0}{\\omega_{\\max}}, \\quad \\Delta t_{\\text{large}} = \\frac{2.1}{\\omega_{\\max}},\n   $$\n   运行蛙跳格式 $N_{\\text{steps}}$ 次迭代，并计算能量比 $r = \\max_n \\mathcal{H}^n / \\mathcal{H}^0$。根据以下标准报告指示能量增长是否有界的布尔值：\n   - 对于 $\\Delta t_{\\text{small}}$：如果 $r \\leq 1.05$，则为有界。\n   - 对于 $\\Delta t_{\\text{critical}}$：如果 $r \\leq 1.20$，则为有界。\n   - 对于 $\\Delta t_{\\text{large}}$：如果 $r \\leq 1.50$，则为有界。\n\n使用 $\\varepsilon=1$ 和 $\\mu=1$，并且在本练习中将所有量视为无量纲。\n\n测试套件：\n- 在 $(N_x,N_y)=(2,2)$ 上进行幂零性测试，容差 $\\tau=10^{-12}$。\n- 在 $(N_x,N_y)=(3,4)$ 上进行幂零性测试，容差 $\\tau=10^{-12}$。\n- 在 $(N_x,N_y)=(10,8)$ 上进行能量有界性测试，其中 $\\varepsilon=1$，$\\mu=1$，使用种子初始化，并对上述三个时间步长 $\\Delta t_{\\text{small}}, \\Delta t_{\\text{critical}}, \\Delta t_{\\text{large}}$ 分别进行 $N_{\\text{steps}}=1000$ 次迭代。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的五个布尔值列表，顺序为\n$$\n[\\text{nilpotency}_{2\\times 2},\\ \\text{nilpotency}_{3\\times 4},\\ \\text{bounded}_{\\Delta t_{\\text{small}}},\\ \\text{bounded}_{\\Delta t_{\\text{critical}}},\\ \\text{bounded}_{\\Delta t_{\\text{large}}}],\n$$\n例如，$[\\text{True},\\text{True},\\text{True},\\text{True},\\text{False}]$。", "solution": "该问题是有效的。它提出了一个在计算电磁学领域中定义明确且具有科学依据的任务，具体涉及基于离散外微分（也称为有限积分法，FIT）的数值格式的构建和分析。该问题是自包含的，提供了所有必要的定义、方程和参数，以获得唯一且可验证的解。\n\n问题的核心在于将无源麦克斯韦方程组从其连续的微分形式转换为适合计算的离散代数形式。这是通过对空间域进行离散化，并以一种能保持基本拓扑和物理定律的方式来表示物理场和微分算子来实现的。\n\n首先，我们建立一个二维矩形网格。该网格具有分层结构的几何元素：节点（0-胞腔）、边（1-胞腔）和面（2-胞腔）。对于一个 $N_x \\times N_y$ 个面的网格，这些元素的数量为：\n- 节点数：$N_n = (N_x+1)(N_y+1)$\n- 水平边数：$N_{ex} = N_x(N_y+1)$\n- 垂直边数：$N_{ey} = (N_x+1)N_y$\n- 总边数：$N_e = N_{ex} + N_{ey}$\n- 面数：$N_f = N_x N_y$\n\n这些网格元素之间的关系由关联矩阵捕获。这些矩阵是微分算子的离散模拟。\n- 节点-边关联矩阵 $\\mathbf{G}$ 代表离散梯度算子。其维度为 $N_e \\times N_n$。每一行对应一条边，并有两个非零项：在尾节点对应的列处为-1，在头节点对应的列处为+1。这表示标量势（节点上的场）在一条边上的差值。\n- 边-面关联矩阵 $\\mathbf{C}$ 代表离散旋度算子。其维度为 $N_f \\times N_e$。每一行对应一个面，并有四个非零项，代表形成其边界的四条边。符号（+1或-1）取决于边的内在方向是否与面的逆时针遍历方向一致。这表示矢量场（边上的场）围绕一个面的环量。\n\n这些离散算子的一个基本性质是离散幂零性：$\\mathbf{C}\\mathbf{G} = \\mathbf{0}$，这反映了连续向量微积分恒等式 $\\nabla \\times (\\nabla \\phi) = \\mathbf{0}$。这意味着边界的边界为空。我们将通过计算乘积 $\\mathbf{C}\\mathbf{G}$ 的弗罗贝尼乌斯范数来验证此性质，其值应在机器精度范围内为零。\n\n对于z方向横磁（TM$_z$）极化，电场分量（$E_x, E_y$）自然地与主网格边相关联，而磁通量密度（$B_z$）与主网格面相关联。连续的麦克斯韦方程组，即法拉第定律（$\\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t}$）和安培定律（$\\nabla \\times \\mathbf{H} = \\frac{\\partial \\mathbf{D}}{\\partial t}$），在空间离散化后，变成一个关于时间的常微分方程组：\n$$\n\\frac{d}{dt}\\mathbf{B} = - \\mathbf{C}\\,\\mathbf{E}\n$$\n$$\n\\frac{d}{dt}\\mathbf{E} = \\frac{1}{\\varepsilon\\mu}\\mathbf{C}^\\top \\mathbf{B}\n$$\n在这里，$\\mathbf{E}$ 是一个包含所有 $N_e$ 条边上电场值的向量，$\\mathbf{B}$ 是一个包含所有 $N_f$ 个面上磁通量密度值的向量。矩阵 $\\mathbf{C}^\\top$ 是离散旋度的转置，它在对偶网格上充当旋度算子，并正确地将面上的磁通量关联回边上的电场。\n\n为了数值求解该系统，我们采用显式蛙跳时间步进格式。该方法是二阶精确的，并且在稳定的时间步长下是能量守恒的。该格式将电场和磁场在时间上交错排列：$\\mathbf{E}$ 在整数时间步 $n\\Delta t$ 上求值，而 $\\mathbf{B}$ 在半整数时间步 $(n+\\frac{1}{2})\\Delta t$ 上求值。更新规则是：\n1.  更新磁通量密度：$\\mathbf{B}^{n+1/2} = \\mathbf{B}^{n-1/2} - \\Delta t\\,\\mathbf{C}\\,\\mathbf{E}^n$\n2.  更新电场：$\\mathbf{E}^{n+1} = \\mathbf{E}^n + \\Delta t\\,\\frac{1}{\\varepsilon\\mu}\\,\\mathbf{C}^\\top \\mathbf{B}^{n+1/2}$\n\n该格式的稳定性由 Courant-Friedrichs-Lewy (CFL) 条件决定。对于此系统，稳定性极限由离散系统模式的最大角频率 $\\omega_{\\max}$ 决定。该频率与离散旋度矩阵的最大奇异值 $\\sigma_{\\max}(\\mathbf{C})$ 相关：\n$$\n\\omega_{\\max} = \\frac{1}{\\sqrt{\\varepsilon\\mu}}\\,\\sigma_{\\max}(\\mathbf{C})\n$$\n蛙跳格式是稳定的当且仅当 $\\omega_{\\max} \\Delta t \\le 2$。问题要求测试三个时间步长：一个稳定的（$\\Delta t_{\\text{small}}$，其中 $\\omega_{\\max}\\Delta t = 1.9$），一个在稳定性极限上的（$\\Delta t_{\\text{critical}}$，其中 $\\omega_{\\max}\\Delta t = 2.0$），以及一个不稳定的（$\\Delta t_{\\text{large}}$，其中 $\\omega_{\\max}\\Delta t = 2.1$）。\n\n我们将通过追踪在每个时间步 $n$ 定义的离散能量泛函 $\\mathcal{H}^n$ 来监控系统的稳定性：\n$$\n\\mathcal{H}^n = \\frac{1}{2}\\,\\varepsilon\\,\\left(\\mathbf{E}^n\\right)^\\top \\mathbf{E}^n + \\frac{1}{2}\\,\\frac{1}{\\mu}\\,\\left(\\mathbf{B}^{n+1/2}\\right)^\\top \\mathbf{B}^{n+1/2}\n$$\n在稳定的模拟中，该能量应保持有界且接近其初始值 $\\mathcal{H}^0$。在不稳定的模拟中，能量将呈指数级增长。我们将计算在 $N_{\\text{steps}}=1000$ 次迭代中的比率 $r = \\max_n \\mathcal{H}^n / \\mathcal{H}^0$，并使用指定的阈值将能量增长分类为有界或无界。\n\n实现将基于对节点、边和面的一致索引来构建稀疏矩阵 $\\mathbf{G}$ 和 $\\mathbf{C}$。将使用SciPy稀疏线性代数模块中的`svds`函数找到 $\\mathbf{C}$ 的最大奇异值。最后，将对三个指定的时间步长运行蛙跳模拟，并将幂零性和能量有界性测试的结果编译成所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import svds\n\ndef construct_matrices(Nx, Ny):\n    \"\"\"\n    Constructs the discrete gradient (G) and curl (C) matrices.\n    \n    Args:\n        Nx (int): Number of primal faces in the x-direction.\n        Ny (int): Number of primal faces in the y-direction.\n        \n    Returns:\n        tuple: A tuple containing the sparse matrices (G, C).\n               G: Node-to-edge incidence matrix (discrete gradient).\n               C: Edge-to-face incidence matrix (discrete curl).\n    \"\"\"\n    Nnx = Nx + 1\n    Nny = Ny + 1\n    \n    Nn = Nnx * Nny\n    Nex = Nx * Nny\n    Ney = Nnx * Ny\n    Ne = Nex + Ney\n    Nf = Nx * Ny\n\n    # Use LIL format for efficient construction\n    G = lil_matrix((Ne, Nn), dtype=np.float64)\n    C = lil_matrix((Nf, Ne), dtype=np.float64)\n\n    # Construct G (Node-to-edge incidence)\n    # Horizontal edges\n    for i in range(Nx):\n        for j in range(Nny):\n            edge_idx = i * Nny + j\n            node1_idx = i * Nny + j\n            node2_idx = (i + 1) * Nny + j\n            G[edge_idx, node1_idx] = -1.0\n            G[edge_idx, node2_idx] = 1.0\n\n    # Vertical edges\n    for i in range(Nnx):\n        for j in range(Ny):\n            edge_idx = Nex + i * Ny + j\n            node1_idx = i * Nny + j\n            node2_idx = i * Nny + (j + 1)\n            G[edge_idx, node1_idx] = -1.0\n            G[edge_idx, node2_idx] = 1.0\n\n    # Construct C (Edge-to-face incidence, discrete curl)\n    for i in range(Nx):\n        for j in range(Ny):\n            face_idx = i * Ny + j\n            \n            # Bottom edge (orientation +x, traversal +x -> +1)\n            bottom_edge_idx = i * Nny + j\n            C[face_idx, bottom_edge_idx] = 1.0\n\n            # Right edge (orientation +y, traversal +y -> +1)\n            right_edge_idx = Nex + (i + 1) * Ny + j\n            C[face_idx, right_edge_idx] = 1.0\n\n            # Top edge (orientation +x, traversal -x -> -1)\n            top_edge_idx = i * Nny + (j + 1)\n            C[face_idx, top_edge_idx] = -1.0\n\n            # Left edge (orientation +y, traversal -y -> -1)\n            left_edge_idx = Nex + i * Ny + j\n            C[face_idx, left_edge_idx] = -1.0\n            \n    # Convert to CSR for efficient matrix operations\n    return G.tocsr(), C.tocsr()\n\ndef run_simulation(C_matrix, eps, mu, N_steps, dt, rng_seed):\n    \"\"\"\n    Runs the leapfrog simulation and computes the energy ratio.\n    \"\"\"\n    Ne = C_matrix.shape[1]\n    Nf = C_matrix.shape[0]\n    \n    # Seeded random number generator for reproducible initial conditions\n    rng = np.random.default_rng(rng_seed)\n    \n    # Initialize fields\n    E_n = rng.random(Ne)\n    B_half = np.zeros(Nf)\n    Ct = C_matrix.transpose().tocsr()\n\n    # Energy calculation\n    H0 = 0.5 * eps * np.dot(E_n, E_n) + 0.5 / mu * np.dot(B_half, B_half)\n    if H0 == 0: return 1.0 # Avoid division by zero if initial energy is zero\n    \n    max_H = H0\n    \n    # Leapfrog loop\n    for _ in range(N_steps):\n        # Update B at n+1/2 from E at n\n        B_half = B_half - dt * (C_matrix @ E_n)\n        \n        # Calculate energy H^n using E^n and B^{n+1/2}\n        H_n = 0.5 * eps * np.dot(E_n, E_n) + 0.5 / mu * np.dot(B_half, B_half)\n        if H_n > max_H:\n            max_H = H_n\n\n        # Update E at n+1 from B at n+1/2\n        E_n = E_n + (dt / (eps * mu)) * (Ct @ B_half)\n\n    return max_H / H0\n\ndef solve():\n    test_cases = [\n        {'type': 'nilpotency', 'Nx': 2, 'Ny': 2, 'tol': 1e-12},\n        {'type': 'nilpotency', 'Nx': 3, 'Ny': 4, 'tol': 1e-12},\n        {'type': 'energy', 'Nx': 10, 'Ny': 8, 'eps': 1.0, 'mu': 1.0, 'N_steps': 1000}\n    ]\n\n    results = []\n    \n    # Nilpotency tests\n    for case in filter(lambda c: c['type'] == 'nilpotency', test_cases):\n        G, C = construct_matrices(case['Nx'], case['Ny'])\n        CG = C @ G\n        frob_norm = np.linalg.norm(CG.toarray(), 'fro')\n        results.append(frob_norm <= case['tol'])\n\n    # Energy boundedness tests\n    energy_case = next(filter(lambda c: c['type'] == 'energy', test_cases))\n    Nx = energy_case['Nx']\n    Ny = energy_case['Ny']\n    eps = energy_case['eps']\n    mu = energy_case['mu']\n    N_steps = energy_case['N_steps']\n\n    _, C = construct_matrices(Nx, Ny)\n    \n    # Calculate max singular value of C to find w_max\n    # k=1 and which='LM' finds the largest magnitude singular value\n    sigma_max = svds(C, k=1, which='LM', return_singular_vectors=False)[0]\n    w_max = (1.0 / np.sqrt(eps * mu)) * sigma_max\n\n    # Define the three time steps\n    dt_small = 1.9 / w_max\n    dt_critical = 2.0 / w_max\n    dt_large = 2.1 / w_max\n    \n    # Use a fixed seed for reproducibility across the three runs\n    rng_seed = 42\n\n    # Run for dt_small\n    r_small = run_simulation(C, eps, mu, N_steps, dt_small, rng_seed)\n    results.append(r_small <= 1.05)\n    \n    # Run for dt_critical\n    r_critical = run_simulation(C, eps, mu, N_steps, dt_critical, rng_seed)\n    results.append(r_critical <= 1.20)\n    \n    # Run for dt_large\n    r_large = run_simulation(C, eps, mu, N_steps, dt_large, rng_seed)\n    results.append(r_large <= 1.50)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3335818"}]}