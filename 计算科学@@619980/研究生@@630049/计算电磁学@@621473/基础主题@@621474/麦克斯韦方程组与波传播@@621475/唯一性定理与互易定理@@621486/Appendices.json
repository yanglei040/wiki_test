{"hands_on_practices": [{"introduction": "我们的实践之旅始于一个看似简单却极其深刻的问题：在什么条件下，电磁问题的解是唯一的？我们将从最基础的静电场问题入手，其场分布由拉普拉斯方程 $\\nabla^2 \\phi = 0$ 决定。通过这个练习，你将亲自验证唯一性定理的一个重要推论：对于一个封闭区域，当边界上全部给定诺伊曼（Neumann）条件（即电势的法向导数）时，其解并不是完全唯一的，而是相差一个任意常数。你将通过编写一个有限差分程序来数值地观察到这一现象，并学习如何通过施加一个简单的额外约束来恢复解的唯一性 [@problem_id:3354244]。这个实践将帮助你深刻理解唯一性定理在数值计算中的具体体现和实际意义。", "problem": "考虑在无源、均匀、各向同性介质中麦克斯韦方程组的准静态极限，该介质的介电常数为 $\\varepsilon$，其中电场 $\\mathbf{E}$ 是无旋的，可以表示为 $\\mathbf{E} = - \\nabla \\phi$。在此极限下，本构关系 $\\mathbf{D} = \\varepsilon \\mathbf{E}$ 和高斯定律 $\\nabla \\cdot \\mathbf{D} = 0$ 意味着标量势 $\\phi$ 满足拉普拉斯方程 $\\nabla^2 \\phi = 0$。边值问题的唯一性定理指出，对于纯诺伊曼边界条件，在一个封闭有界域上，$\\nabla^2 \\phi = 0$ 的解仅在相差一个加法常数的情况下是确定的。一种恢复唯一性的自然方法是增加一个约束来固定这个常数（例如，零均值约束）。\n\n您将对单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的方程 $\\nabla^2 \\phi = 0$ 进行有限差分模拟，其四条边均为纯诺伊曼边界条件。使用一个 $N_x \\times N_y$ 个点的均匀网格，间距为 $h_x = \\frac{1}{N_x - 1}$ 和 $h_y = \\frac{1}{N_y - 1}$。网格点索引为 $(i,j)$，其中 $i \\in \\{0,1,\\dots,N_y-1\\}$ 表示 $y$ 轴索引，$j \\in \\{0,1,\\dots,N_x-1\\}$ 表示 $x$ 轴索引。未知数记为 $\\phi_{i,j}$，通过字典序映射 $k = i N_x + j$ 排列成一个长度为 $N = N_x N_y$ 的向量。使用标准的五点差分格式对内部点的拉普拉斯算子进行离散化：\n$$\n\\frac{\\phi_{i+1,j} - 2 \\phi_{i,j} + \\phi_{i-1,j}}{h_y^2} + \\frac{\\phi_{i,j+1} - 2 \\phi_{i,j} + \\phi_{i,j-1}}{h_x^2} = 0,\n$$\n并使用由法向导数的中心差分近似推导出的虚拟节点来施加非齐次诺伊曼边界条件。设上、下、左、右边界上的 $\\partial \\phi / \\partial n$ 分别由常数 $g_t$、$g_b$、$g_l$ 和 $g_r$ 指定。使用向外的单位法向量 $\\mathbf{n}$，边界条件为\n$$\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\text{top}} = g_t,\\quad\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\text{bottom}} = g_b,\\quad\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\text{left}} = g_l,\\quad\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\text{right}} = g_r.\n$$\n令沿坐标轴方向在边界上的导数满足\n$$\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{\\text{top}} = + g_t,\\quad\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{\\text{bottom}} = - g_b,\\quad\n\\left.\\frac{\\partial \\phi}{\\partial x}\\right|_{\\text{left}} = - g_l,\\quad\n\\left.\\frac{\\partial \\phi}{\\partial x}\\right|_{\\text{right}} = + g_r,\n$$\n这反映了向外的法线方向。使用中心差分来强制实施这些条件以消除虚拟节点：\n- 在下边界（$i = 0$），使用 $\\frac{\\phi_{1,j} - \\phi_{-1,j}}{2 h_y} = - g_b$，因此 $\\phi_{-1,j} = \\phi_{1,j} + 2 h_y g_b$，得到 $y$ 项\n$$\n\\frac{\\phi_{1,j} - 2 \\phi_{0,j} + \\phi_{-1,j}}{h_y^2} = \\frac{2 \\phi_{1,j} - 2 \\phi_{0,j}}{h_y^2} + \\frac{2 g_b}{h_y}.\n$$\n- 在上边界（$i = N_y - 1$），使用 $\\frac{\\phi_{N_y,j} - \\phi_{N_y-2,j}}{2 h_y} = + g_t$，因此 $\\phi_{N_y,j} = \\phi_{N_y-2,j} + 2 h_y g_t$，得到\n$$\n\\frac{\\phi_{N_y,j} - 2 \\phi_{N_y-1,j} + \\phi_{N_y-2,j}}{h_y^2} = \\frac{2 \\phi_{N_y-2,j} - 2 \\phi_{N_y-1,j}}{h_y^2} + \\frac{2 g_t}{h_y}.\n$$\n- 在左边界（$j = 0$），使用 $\\frac{\\phi_{i,1} - \\phi_{i,-1}}{2 h_x} = - g_l$，因此 $\\phi_{i,-1} = \\phi_{i,1} + 2 h_x g_l$，得到\n$$\n\\frac{\\phi_{i,1} - 2 \\phi_{i,0} + \\phi_{i,-1}}{h_x^2} = \\frac{2 \\phi_{i,1} - 2 \\phi_{i,0}}{h_x^2} + \\frac{2 g_l}{h_x}.\n$$\n- 在右边界（$j = N_x - 1$），使用 $\\frac{\\phi_{i,N_x} - \\phi_{i,N_x-2}}{2 h_x} = + g_r$，因此 $\\phi_{i,N_x} = \\phi_{i,N_x-2} + 2 h_x g_r$，得到\n$$\n\\frac{\\phi_{i,N_x} - 2 \\phi_{i,N_x-1} + \\phi_{i,N_x-2}}{h_x^2} = \\frac{2 \\phi_{i,N_x-2} - 2 \\phi_{i,N_x-1}}{h_x^2} + \\frac{2 g_r}{h_x}.\n$$\n将所有项收集成一个线性系统 $A \\phi = b$，其中 $A$ 是一个 $N \\times N$ 矩阵，$b$ 是一个长度为 $N$ 的向量。将诺伊曼边界产生的常数项移到右侧，即从左侧的贡献中减去它们，使它们在右侧以负号出现；具体来说，每个适用的边界贡献会向 $b$ 中相应的条目添加 $-\\frac{2 g_b}{h_y}$、$-\\frac{2 g_t}{h_y}$、$-\\frac{2 g_l}{h_x}$ 或 $-\\frac{2 g_r}{h_x}$。对于内部节点，使用标准系数 $\\frac{1}{h_y^2}$、$-\\frac{2}{h_y^2}$ 和 $\\frac{1}{h_x^2}$、$-\\frac{2}{h_x^2}$；对于边界节点，使用虚拟节点替换来替代缺失的邻居，这将为最近的内部邻居产生修改后的系数 $\\frac{2}{h_y^2}$ 或 $\\frac{2}{h_x^2}$，为中心点产生 $-\\frac{2}{h_y^2}$ 或 $-\\frac{2}{h_x^2}$，常数偏移量如上所述移至 $b$。这种构造方法得到的矩阵 $A$ 的行和为零，因此常数向量在其零空间中，并且当且仅当右侧项 $b$ 的总和为零时，该系统有解，这在 $g_t = - g_b$ 和 $g_r = - g_l$ 时得到保证。\n\n任务：\n- 对于下面的每个测试用例，按照上述规则组装 $A$ 和 $b$，并使用 Moore–Penrose 伪逆计算一个特解 $\\phi_0$。伪逆可以通过奇异值分解 (SVD) 计算。\n- 通过验证对于多个常数 $c$，$A(\\phi_0 + c \\mathbf{1}) = b$ 在数值上成立，来演示常数偏移的非唯一性，其中 $\\mathbf{1}$ 是长度为 $N$ 的全一向量。通过计算一组常数 $c$ 上的最大残差范数来量化这一点：\n$$\nr_{\\max} = \\max_{c \\in \\mathcal{C}} \\left\\| A(\\phi_0 + c \\mathbf{1}) - b \\right\\|_2,\n$$\n其中 $\\mathcal{C} = \\{-0.3, 0.0, 0.9\\}$。\n- 通过将任何解投影到零均值子空间上来施加零均值约束以恢复唯一性：\n$$\n\\phi_{\\text{zm}} = \\phi - \\frac{1}{N} \\sum_{k=0}^{N-1} \\phi_k.\n$$\n对于每个 $c \\in \\mathcal{C}$，计算 $\\phi_c = \\phi_0 + c \\mathbf{1}$ 和 $\\phi_{c,\\text{zm}} = \\phi_c - \\frac{1}{N} \\sum_{k} (\\phi_c)_k$。通过计算以下值来量化唯一性的恢复情况：\n$$\nd_{\\max} = \\max_{c \\in \\mathcal{C}} \\left\\| \\phi_{c,\\text{zm}} - \\phi_{0,\\text{zm}} \\right\\|_2,\\quad m_{\\text{abs}} = \\left| \\frac{1}{N} \\sum_{k=0}^{N-1} (\\phi_{0,\\text{zm}})_k \\right|.\n$$\n\n测试套件：\n- 案例 1：$N_x = 5$，$N_y = 4$，$g_t = 1.0$，$g_b = -1.0$，$g_l = 0.0$，$g_r = 0.0$。\n- 案例 2：$N_x = 6$，$N_y = 6$，$g_t = 0.0$，$g_b = 0.0$，$g_l = 0.5$，$g_r = -0.5$。\n- 案例 3：$N_x = 3$，$N_y = 3$，$g_t = 0.0$，$g_b = 0.0$，$g_l = 0.0$，$g_r = 0.0$。\n\n在这个数学表述中，所有量都是无量纲的。不涉及角度。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按顺序将 3 个案例的三元组 $(r_{\\max}, d_{\\max}, m_{\\text{abs}})$ 展平。例如，输出格式必须是\n$$\n[\\text{case1\\_}r_{\\max},\\text{case1\\_}d_{\\max},\\text{case1\\_}m_{\\text{abs}},\\text{case2\\_}r_{\\max},\\text{case2\\_}d_{\\max},\\text{case2\\_}m_{\\text{abs}},\\text{case3\\_}r_{\\max},\\text{case3\\_}d_{\\max},\\text{case3\\_}m_{\\text{abs}}].\n$$\n每个条目必须是浮点数。", "solution": "用户提供的问题陈述是有效的。它在科学上是合理的、适定的和客观的。它提出了一个计算电磁学中的标准数值练习，特别是使用纯诺伊曼边界条件的拉普拉斯方程的有限差分解法。该问题正确地指出了由此产生的不适定性（系统矩阵的奇异性，解在相差一个加法常数下的非唯一性），并详细说明了处理它的标准程序，既通过使用 Moore-Penrose 伪逆找到一个特解，也通过强制执行唯一性约束（零均值）。提供的测试用例与问题的理论设置一致。我现在将着手解决。\n\n这个问题的核心是构建一个线性方程组 $A \\phi = b$，它表示在具有指定诺伊曼边界条件的单位正方形网格上离散化的拉普拉斯方程 $\\nabla^2 \\phi = 0$。向量 $\\phi$ 包含了每个网格点上的未知电势值 $\\phi_{i,j}$，按字典序排列。矩阵 $A$ 表示离散化的拉普拉斯算子，向量 $b$ 包含了非齐次边界条件的值。\n\n首先，我们定义网格和离散化参数。对于 $[0,1] \\times [0,1]$ 域上的 $N_x \\times N_y$ 网格，未知数的总数为 $N = N_x N_y$。网格间距为 $h_x = 1/(N_x - 1)$ 和 $h_y = 1/(N_y - 1)$。为方便起见，我们定义系数 $c_x = 1/h_x^2$ 和 $c_y = 1/h_y^2$。从二维网格索引 $(i, j)$ 到一维向量索引 $k$ 的映射是 $k = i N_x + j$。\n\n矩阵 $A$ 和向量 $b$ 是通过遍历每个网格点 $(i, j)$ 并构建相应的方程（系统的第 $k$ 行）来组装的。方程的形式取决于点的位置：\n\n1.  **内部点** ($0 < i < N_y-1$ 且 $0 < j < N_x-1$)：使用标准的拉普拉斯五点差分格式：\n    $$\n    c_y(\\phi_{i-1,j} + \\phi_{i+1,j}) + c_x(\\phi_{i,j-1} + \\phi_{i,j+1}) - 2(c_x + c_y)\\phi_{i,j} = 0\n    $$\n    这设置了 $A$ 的第 $k$ 行中，中心节点 $\\phi_{i,j}$ 及其四个邻居的系数。相应的条目 $b_k$ 为 $0$。\n\n2.  **边界点**：对于边界上的点，我们使用给定的有限差分近似，该近似通过虚拟节点来包含诺伊曼条件。\n    -   **下边界** ($i=0$)：y-导数项变为 $\\frac{2\\phi_{1,j} - 2\\phi_{0,j}}{h_y^2} + \\frac{2g_b}{h_y}$。这为 $\\phi_{1,j}$ 的系数贡献了 $2c_y$，为 $\\phi_{0,j}$（对角线）的系数贡献了 $-2c_y$，并向右侧的 $b_k$ 添加了一项 $-\\frac{2g_b}{h_y}$。\n    -   **上边界** ($i=N_y-1$)：类似地，对 $\\phi_{N_y-2,j}$ 的贡献是 $2c_y$，对 $\\phi_{N_y-1,j}$ 的贡献是 $-2c_y$，对 $b_k$ 的贡献是 $-\\frac{2g_t}{h_y}$。\n    -   **左边界** ($j=0$)：x-导数项对 $\\phi_{i,1}$ 的贡献是 $2c_x$，对 $\\phi_{i,0}$ 的贡献是 $-2c_x$，对 $b_k$ 的贡献是 $-\\frac{2g_l}{h_x}$。\n    -   **右边界** ($j=N_x-1$)：对 $\\phi_{i,N_x-2}$ 的贡献是 $2c_x$，对 $\\phi_{i,N_x-1}$ 的贡献是 $-2c_x$，对 $b_k$ 的贡献是 $-\\frac{2g_r}{h_x}$。\n\n3.  **角点**：这些点受到两个边界条件的影响。例如，左下角 $(i=0, j=0)$ 同时受到下边界和左边界模板修改的影响。它的方程结合了对系数和右侧项 $b_k$ 的两种效应。\n\n组装后，矩阵 $A$ 是奇异的；其行和全为零，这意味着常数向量 $\\mathbf{1}$（所有元素都为1的向量）在其零空间中 ($A\\mathbf{1} = \\mathbf{0}$)。仅当 $b$ 位于 $A$ 的列空间（即与 $A^T$ 的零空间正交）时，$A\\phi=b$ 的解才存在。对于这个离散拉普拉斯算子，这个相容性条件转化为 $\\sum_k b_k = 0$，这由问题的约束 $g_t+g_b=0$ 和 $g_l+g_r=0$ 来保证。\n\n然后按如下方式执行任务：\n-   通过求解 $A\\phi=b$ 找到一个特解 $\\phi_0$。由于 $A$ 是奇异的，我们使用一种提供最小范数最小二乘解的方法，这等同于使用 Moore-Penrose 伪逆：$\\phi_0 = A^\\dagger b$。这可以使用 `numpy.linalg.lstsq` 高效计算。\n-   为证明非唯一性，我们为几个常数 $c$ 计算残差 $\\|A(\\phi_0 + c\\mathbf{1}) - b\\|_2$。由于 $A\\mathbf{1} = \\mathbf{0}$，这个残差简化为 $\\|A\\phi_0 - b\\|_2$。对于一个相容的系统，由于浮点精度限制，无论 $c$ 是多少，这个值都应接近于零。我们找到给定常数集合 $\\mathcal{C}$ 上的最大残差 $r_{\\max}$。\n-   为了恢复唯一性，我们将解投影到具有零均值的函数子空间上。对于任何解 $\\phi$，零均值解是 $\\phi_{\\text{zm}} = \\phi - \\text{mean}(\\phi)$。我们验证对于任何常数偏移 $c$，投影是不变的：$\\phi_{c, \\text{zm}} = (\\phi_0+c\\mathbf{1}) - \\text{mean}(\\phi_0+c\\mathbf{1}) = (\\phi_0+c) - (\\text{mean}(\\phi_0)+c) = \\phi_0 - \\text{mean}(\\phi_0) = \\phi_{0,\\text{zm}}$。我们通过计算 $d_{\\max} = \\max_{c \\in \\mathcal{C}} \\|\\phi_{c,\\text{zm}} - \\phi_{0,\\text{zm}}\\|_2$ 来量化这一点，这个值应该接近于零。\n-   最后，我们计算投影基解的均值的绝对值，$m_{\\text{abs}} = |\\text{mean}(\\phi_{0,\\text{zm}})|$，根据构造，这个值也必须接近于零。\n\n下面的 Python 代码实现了这整个过程。它遍历测试用例，为每个用例执行矩阵组装和计算，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(Nx, Ny, gt, gb, gl, gr):\n    \"\"\"\n    Assembles and solves the finite difference system for the Laplace equation\n    with pure Neumann boundary conditions, then computes the required metrics.\n    \n    Args:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        gt, gb, gl, gr (float): Neumann boundary condition values for top, bottom,\n                                 left, and right sides, respectively.\n                                 \n    Returns:\n        tuple: A tuple containing (r_max, d_max, m_abs).\n    \"\"\"\n    N = Nx * Ny\n    \n    # Grid spacings. Handles 1D cases not present in the test suite.\n    hx = 1.0 / (Nx - 1) if Nx > 1 else float('inf')\n    hy = 1.0 / (Ny - 1) if Ny > 1 else float('inf')\n    \n    # Pre-calculate stencil coefficients.\n    cx = 1.0 / hx**2 if hx != float('inf') else 0.0\n    cy = 1.0 / hy**2 if hy != float('inf') else 0.0\n    \n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Assemble the matrix A and vector b\n    for i in range(Ny):\n        for j in range(Nx):\n            k = i * Nx + j  # Row index for the current node (i, j)\n            \n            # Y-derivative part (d^2/dy^2)\n            if Ny > 1:\n                if i == 0:  # Bottom boundary (i=0)\n                    A[k, k] -= 2 * cy\n                    A[k, k + Nx] += 2 * cy\n                    b[k] -= 2 * gb / hy\n                elif i == Ny - 1:  # Top boundary (i=Ny-1)\n                    A[k, k] -= 2 * cy\n                    A[k, k - Nx] += 2 * cy\n                    b[k] -= 2 * gt / hy\n                else:  # Interior y\n                    A[k, k] -= 2 * cy\n                    A[k, k - Nx] += cy\n                    A[k, k + Nx] += cy\n            \n            # X-derivative part (d^2/dx^2)\n            if Nx > 1:\n                if j == 0:  # Left boundary (j=0)\n                    A[k, k] -= 2 * cx\n                    A[k, k + 1] += 2 * cx\n                    b[k] -= 2 * gl / hx\n                elif j == Nx - 1:  # Right boundary (j=Nx-1)\n                    A[k, k] -= 2 * cx\n                    A[k, k - 1] += 2 * cx\n                    b[k] -= 2 * gr / hx\n                else:  # Interior x\n                    A[k, k] -= 2 * cx\n                    A[k, k - 1] += cx\n                    A[k, k + 1] += cx\n\n    # Task 1: Compute a particular solution phi_0 using Moore-Penrose pseudoinverse.\n    # np.linalg.lstsq finds the minimum-norm least-squares solution.\n    phi_0 = np.linalg.lstsq(A, b, rcond=None)[0]\n    \n    # Task 2: Demonstrate non-uniqueness and compute r_max\n    C = [-0.3, 0.0, 0.9]\n    ones_vec = np.ones(N)\n    residual_norms = []\n    \n    for c in C:\n        phi_c = phi_0 + c * ones_vec\n        residual_vector = A @ phi_c - b\n        residual_norms.append(np.linalg.norm(residual_vector))\n        \n    r_max = np.max(residual_norms)\n    \n    # Task 3: Impose zero-mean constraint and quantify uniqueness restoration\n    # Base zero-mean solution\n    phi_0_zm = phi_0 - np.mean(phi_0)\n    \n    diff_norms = []\n    for c in C:\n        phi_c = phi_0 + c * ones_vec\n        # Project phi_c to have zero mean\n        phi_c_zm = phi_c - np.mean(phi_c)\n        # Compute the norm of the difference to the base zero-mean solution\n        diff_norms.append(np.linalg.norm(phi_c_zm - phi_0_zm))\n        \n    d_max = np.max(diff_norms)\n    \n    # Absolute mean of the base zero-mean solution (should be ~0)\n    m_abs = np.abs(np.mean(phi_0_zm))\n    \n    return r_max, d_max, m_abs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, gt, gb, gl, gr)\n        (5, 4, 1.0, -1.0, 0.0, 0.0),\n        (6, 6, 0.0, 0.0, 0.5, -0.5),\n        (3, 3, 0.0, 0.0, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, gt, gb, gl, gr = case\n        r_max, d_max, m_abs = run_simulation(Nx, Ny, gt, gb, gl, gr)\n        results.extend([r_max, d_max, m_abs])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10e}' for x in results)}]\")\n\nsolve()\n```", "id": "3354244"}, {"introduction": "在理解了唯一性之后，我们将探索电磁学中另一个充满对称之美的基本原理——互易定理。洛伦兹（Lorentz）互易定理巧妙地联系了两组独立的源及其产生的场，但它是否仅适用于理想的无损介质？这个实践将挑战这一局限认知。你将通过数值模拟来证明，即使在包含有耗、各向异性甚至频率相关的色散材料的复杂环境中，只要材料的本构张量是对称的，互易性依然严格成立 [@problem_id:3354270]。通过亲手构建一个有限体积法程序，你不仅能验证这一深刻的物理原理，还能体会到在数值计算中保持离散算子对称性的重要性，这对保证计算结果的物理真实性至关重要。", "problem": "考虑在均匀笛卡尔网格上离散化的二维矩形域中，时谐因子为 $e^{j\\omega t}$ 的频域计算电磁学问题。您将为一个包含有损各向异性色散平板的电准静态模型验证洛伦兹互易性。使用麦克斯韦方程组和电准静态极限作为基本基础，并且除了从麦克斯韦方程组导出的一般性陈述外，不假定任何专门的互易性公式。目标是构建一个对称的离散算子，该算子表示 $\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}}(\\omega)\\nabla \\phi\\right) = -\\rho$，其中介电常数张量为复对称；并针对多种情景，在数值上确认离散洛伦兹互易性恒等式\n$$\n\\int_{\\Omega} \\rho_1(\\mathbf{r}) \\,\\phi_2(\\mathbf{r})\\,dV \\;=\\; \\int_{\\Omega} \\rho_2(\\mathbf{r}) \\,\\phi_1(\\mathbf{r})\\,dV\n$$\n对于 $\\underline{\\underline{\\epsilon}}(\\omega)$ 是复对称的无源色散介质，在数值容差范围内成立。计算必须完全在有限体积离散化的电准静态框架下进行，并采用狄利克雷边界条件，在计算域的外边界上强制 $\\phi=0$。离散解的存在性和唯一性由这些边界条件以及材料的无源性、严格耗散性或无损性所保证。\n\n基本基础和建模假设：\n- 从时谐因子为 $e^{j\\omega t}$ 的频域麦克斯韦方程组开始：\n  - $\\nabla \\times \\mathbf{E} = -j\\omega \\mu_0 \\mathbf{H}$,\n  - $\\nabla \\times \\mathbf{H} = \\mathbf{J} + j\\omega \\underline{\\underline{\\epsilon}}(\\omega)\\mathbf{E}$,\n  - $\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}}(\\omega)\\mathbf{E}\\right) = \\rho$,\n  - $\\nabla \\cdot \\mathbf{B} = 0$,\n  以及本构关系 $\\mathbf{D} = \\underline{\\underline{\\epsilon}}(\\omega)\\mathbf{E}$，$\\mathbf{B} = \\mu_0 \\mathbf{H}$。在电准静态极限下，模型为 $\\mathbf{E} = -\\nabla \\phi$，并求解 $\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}}(\\omega)\\nabla \\phi\\right) = -\\rho$。\n- 使用一个 $N_x\\times N_y$ 个节点的矩形域，两个方向上的均匀间距均为 $h$，并在域边界上强制执行狄利克雷边界条件 $\\phi=0$。使用调和平均计算跨面的通量来组合有限体积算子，以保持对称性。\n- 将平板建模为一个水平带状区域，其介电常数张量为各向异性的对角张量 $\\underline{\\underline{\\epsilon}}(\\omega) = \\mathrm{diag}\\left(\\epsilon_x(\\omega), \\epsilon_y(\\omega)\\right)$；在平板外部，使用真空，介电常数为 $\\epsilon_0$。在平板内部，使用增加了电导的德拜型色散模型：\n  $$\n  \\epsilon_k(\\omega) = \\epsilon_{\\infty,k} + \\frac{\\epsilon_{s,k} - \\epsilon_{\\infty,k}}{1 + j\\omega \\tau_k} + \\frac{\\sigma_k}{j\\omega}, \\quad k\\in\\{x,y\\}.\n  $$\n  无源性要求耗散功率为非负；在使用 $e^{j\\omega t}$ 约定的情况下，这由 $\\sigma_k/(j\\omega)$ 项和满足 $\\tau_k>0$ 及 $\\epsilon_{s,k}\\ge \\epsilon_{\\infty,k}$ 的德拜项来体现。\n- 使用两个紧支集的外加电荷偶极子 $\\rho_1$ 和 $\\rho_2$ 来激励系统，每个偶极子实现为一对大小相等、方向相反的点电荷，电荷量为 $q$，沿指定的坐标轴相隔一个网格间距，位于指定的网格节点上。每个单元的离散总电荷 $Q\\,[\\mathrm{C}]$作为单元积分方程右侧的源项；需要验证的离散互易性恒等式是\n  $$\n  I_1 \\equiv \\sum_{\\text{cells}} Q_1 \\,\\phi_2 \\;\\stackrel{?}{=}\\; \\sum_{\\text{cells}} Q_2 \\,\\phi_1 \\equiv I_2.\n  $$\n- 利用带有狄利克雷边界条件的边值问题的唯一性定理来证明对每个源唯一地求解 $\\phi$ 是合理的。\n\n离散化要求：\n- 在间距为 $h$ 的均匀网格上使用有限体积离散化，使得每个内部单元 $C$ 的离散平衡方程为\n  $$\n  \\epsilon_{x,e}(\\phi_E - \\phi_C) - \\epsilon_{x,w}(\\phi_C - \\phi_W) + \\epsilon_{y,n}(\\phi_N - \\phi_C) - \\epsilon_{y,s}(\\phi_C - \\phi_S) = -Q_C,\n  $$\n  其中 $\\epsilon_{x,e}$ 是东面的有效介电常数（使用来自两个相邻单元的 $\\epsilon_x$ 的调和平均值），其他面也类似。对于狄利克雷边界的邻居，视为 $\\phi=0$，并仅将相应的面系数包含在内部单元的对角线元素中。对于对称的 $\\underline{\\underline{\\epsilon}}(\\omega)$，这种构造方法会产生一个复对称的系统矩阵。\n- 将偶极子表示为分配给相邻内部单元的离散电荷 $+q$ 和 $-q$，每个偶极子的净电荷为零。\n\n物理和数值单位：\n- 使用国际单位制 (SI)。真空介电常数为 $\\epsilon_0 = 8.8541878128\\times 10^{-12}\\,\\mathrm{F/m}$。网格间距为 $h=10^{-3}\\,\\mathrm{m}$。\n\n测试套件和参数规格：\n- 全局域设置：$N_x=40$，$N_y=40$，$h=10^{-3}\\,\\mathrm{m}$。平板占据第 $j_1=14$ 行到第 $j_2=26$ 行（含边界，从底行的 $0$ 计数到顶行的 $N_y-1$）。所有偶极子的电荷量 $q=10^{-9}\\,\\mathrm{C}$。确保偶极子中心距离边界至少一个单元格，以使两个电荷都位于内部单元中。\n- 材料模型：\n  - 各向异性色散平板A：$\\epsilon_{\\infty,x} = 2\\,\\epsilon_0$，$\\epsilon_{s,x} = 8\\,\\epsilon_0$，$\\tau_x = 1\\times 10^{-10}\\,\\mathrm{s}$，$\\sigma_x = 0.5\\,\\mathrm{S/m}$；$\\epsilon_{\\infty,y} = 3\\,\\epsilon_0$，$\\epsilon_{s,y} = 6\\,\\epsilon_0$，$\\tau_y = 5\\times 10^{-11}\\,\\mathrm{s}$，$\\sigma_y = 0.2\\,\\mathrm{S/m}$。\n  - 各向同性无损平板B：$\\epsilon_{\\infty,x} = \\epsilon_{\\infty,y} = 4\\,\\epsilon_0$，$\\epsilon_{s,x} = \\epsilon_{s,y} = 4\\,\\epsilon_0$，$\\sigma_x = \\sigma_y = 0$，$\\tau$ 为任意值（因为 $\\epsilon_s=\\epsilon_{\\infty}$ 而无关紧要）。\n- 频率：\n  - $\\omega_1 = 2\\pi \\cdot 5\\times 10^{9}\\,\\mathrm{rad/s}$，\n  - $\\omega_2 = 2\\pi \\cdot 5\\times 10^{7}\\,\\mathrm{rad/s}$，\n  - $\\omega_3 = 2\\pi \\cdot 3\\times 10^{10}\\,\\mathrm{rad/s}$。\n- 偶极子位置和方向：\n  - 情况1（一般各向异性色散，中等频率）：材料A，频率 $\\omega_1$；偶极子 $\\rho_1$ 中心位于 $(i,j)=(8,10)$，沿 $x$ 方向；偶极子 $\\rho_2$ 中心位于 $(i,j)=(30,29)$，沿 $y$ 方向。\n  - 情况2（低频，强色散/导电损耗）：材料A，频率 $\\omega_2$；偶极子位置与情况1相同。\n  - 情况3（各向同性，无损校验）：材料B，频率 $\\omega_1$；偶极子 $\\rho_1$ 中心位于 $(i,j)=(12,20)$，沿 $x$ 方向；偶极子 $\\rho_2$ 中心位于 $(i,j)=(28,20)$，沿 $y$ 方向。\n  - 情况4（近界面边缘情况）：材料A，频率 $\\omega_3$；平板界面靠近 $j=14$；偶极子 $\\rho_1$ 中心位于 $(i,j)=(20,13)$，沿 $x$ 方向；偶极子 $\\rho_2$ 中心位于 $(i,j)=(22,27)$，沿 $y$ 方向。\n- 对于每种情况，计算 $\\rho_1$ 对应的 $\\phi_1$ 和 $\\rho_2$ 对应的 $\\phi_2$，然后评估离散互易性积分 $I_1 = \\sum Q_1 \\phi_2$ 和 $I_2 = \\sum Q_2 \\phi_1$。报告每种情况的无量纲互易性误差，定义为\n  $$\n  \\mathrm{err} \\;=\\; \\frac{\\left| I_1 - I_2 \\right|}{\\max\\left(\\left|I_1\\right|, \\left|I_2\\right|, \\varepsilon\\right)} \\quad \\text{with} \\quad \\varepsilon=10^{-30}.\n  $$\n\n程序要求：\n- 您的程序必须使用面系数的调和平均来组合算子 $\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}}(\\omega)\\nabla \\phi\\right)$ 的复对称有限体积矩阵，使用稀疏直接法求解每种情况下的两个线性系统以得到 $\\phi_1$ 和 $\\phi_2$，并计算上述测试套件的四个互易性误差。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[r1,r2,r3,r4]\"），其中每个 $r_k$ 是情况 $k$ 的互易性误差，表示为全机器精度的浮点数。不应打印任何额外文本。", "solution": "该问题要求在二维电准静态 (EQS) 框架内对洛伦兹互易性定理进行数值验证。该系统涉及一个有损、各向异性且色散的介质平板。验证将通过模拟两个不同的偶极子源及其相应的电势场，然后评估互易性恒等式来完成。整个公式必须以麦克斯韦方程组为基础，并使用能够保持底层物理算子对称性的有限体积法进行离散化。\n\n**1. 互易性的理论基础**\n\n洛伦兹互易性定理是从麦克斯韦方程组导出的一个基本原理。对于线性介质中频率为 $\\omega$ 的两组时谐源 $(\\mathbf{J}_1, \\rho_1)$ 和 $(\\mathbf{J}_2, \\rho_2)$，该定理的一般形式为：\n$$\n\\int_V \\left( \\mathbf{E}_1 \\cdot \\mathbf{J}_2 - \\mathbf{H}_1 \\cdot \\mathbf{M}_2 \\right) dV = \\int_V \\left( \\mathbf{E}_2 \\cdot \\mathbf{J}_1 - \\mathbf{H}_2 \\cdot \\mathbf{M}_1 \\right) dV\n$$\n前提是材料的本构关系 $\\mathbf{D} = \\underline{\\underline{\\epsilon}}\\mathbf{E}$ 和 $\\mathbf{B} = \\underline{\\underline{\\mu}}\\mathbf{H}$ 使用对称张量，即 $\\underline{\\underline{\\epsilon}}^T = \\underline{\\underline{\\epsilon}}$ 和 $\\underline{\\underline{\\mu}}^T = \\underline{\\underline{\\mu}}$。所考虑的问题是非磁性的 ($\\mathbf{M}_1 = \\mathbf{M}_2 = 0$)，并且在电准静态极限下工作，其中传导电流 $\\mathbf{J}$ 通过介电常数的虚部建模，电场是无旋的，$\\mathbf{E} = -\\nabla\\phi$。\n\n电势 $\\phi$ 的控制方程由高斯定律 $\\nabla \\cdot \\mathbf{D} = \\rho$ 导出：\n$$\n\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}}(\\omega)\\mathbf{E}\\right) = \\rho \\quad \\implies \\quad \\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}}(\\omega)\\nabla\\phi\\right) = -\\rho\n$$\n让我们考虑分别对应于电荷分布 $\\rho_1$ 和 $\\rho_2$ 的两个独立情景，它们分别产生电势 $\\phi_1$ 和 $\\phi_2$：\n$$\n\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}} \\nabla \\phi_1\\right) = -\\rho_1\n$$\n$$\n\\nabla \\cdot \\left(\\underline{\\underline{\\epsilon}} \\nabla \\phi_2\\right) = -\\rho_2\n$$\n我们将第一个方程乘以 $\\phi_2$，并在域体积 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\phi_2 \\left[ \\nabla \\cdot (\\underline{\\underline{\\epsilon}} \\nabla \\phi_1) \\right] dV = -\\int_{\\Omega} \\rho_1 \\phi_2 dV\n$$\n使用矢量恒等式 $\\nabla \\cdot (f\\mathbf{A}) = f(\\nabla \\cdot \\mathbf{A}) + \\mathbf{A} \\cdot \\nabla f$，令 $f=\\phi_2$ 和 $\\mathbf{A} = \\underline{\\underline{\\epsilon}}\\nabla\\phi_1$，左侧变为：\n$$\n\\int_{\\Omega} \\left[ \\nabla \\cdot (\\phi_2 \\underline{\\underline{\\epsilon}} \\nabla \\phi_1) - (\\underline{\\underline{\\epsilon}} \\nabla \\phi_1) \\cdot \\nabla \\phi_2 \\right] dV\n$$\n对第一项应用散度定理，得到一个关于边界 $\\partial\\Omega$ 的面积分。由于问题指定了齐次狄利克雷边界条件（在 $\\partial\\Omega$ 上 $\\phi=0$），这个面积分为零。我们剩下：\n$$\n-\\int_{\\Omega} (\\underline{\\underline{\\epsilon}} \\nabla \\phi_1) \\cdot \\nabla \\phi_2 dV = -\\int_{\\Omega} \\rho_1 \\phi_2 dV\n$$\n左侧可以写成标量积 $(\\nabla\\phi_2)^T \\underline{\\underline{\\epsilon}} (\\nabla\\phi_1)$。通过交换索引 $1$ 和 $2$，我们得到对称关系：\n$$\n\\int_{\\Omega} (\\underline{\\underline{\\epsilon}} \\nabla \\phi_2) \\cdot \\nabla \\phi_1 dV = \\int_{\\Omega} \\rho_2 \\phi_1 dV\n$$\n此式的左侧是 $(\\nabla\\phi_1)^T \\underline{\\underline{\\epsilon}} (\\nabla\\phi_2)$。如果涉及源的两个积分相等，则互易性定理成立。这要求双线性形式相等：\n$$\n\\int_{\\Omega} (\\nabla\\phi_2)^T \\underline{\\underline{\\epsilon}} (\\nabla\\phi_1) dV = \\int_{\\Omega} (\\nabla\\phi_1)^T \\underline{\\underline{\\epsilon}} (\\nabla\\phi_2) dV\n$$\n由于这是一个标量等式，右侧等于其转置：$[(\\nabla\\phi_1)^T \\underline{\\underline{\\epsilon}} (\\nabla\\phi_2)]^T = (\\nabla\\phi_2)^T \\underline{\\underline{\\epsilon}}^T (\\nabla\\phi_1)$。将此与左侧进行比较，如果介电常数张量是对称的，即 $\\underline{\\underline{\\epsilon}} = \\underline{\\underline{\\epsilon}}^T$，则等式得到保证。问题指定了一个对角（因此是对称）的介电常数张量 $\\underline{\\underline{\\epsilon}}(\\omega)$。因此，连续互易性恒等式成立：\n$$\n\\int_{\\Omega} \\rho_1 \\phi_2 dV = \\int_{\\Omega} \\rho_2 \\phi_1 dV\n$$\n\n**2. 有限体积离散化**\n\n我们在大小为 $N_x \\times N_y$、间距为 $h$ 的均匀笛卡尔网格上离散化控制方程。电势 $\\phi$ 定义在每个单元的中心。将方程 $\\nabla \\cdot (\\underline{\\underline{\\epsilon}}\\nabla\\phi) = -\\rho$ 在一个单元 $C_{i,j}$ 上积分，并应用散度定理，得到：\n$$\n\\oint_{\\partial C_{i,j}} (\\underline{\\underline{\\epsilon}}\\nabla\\phi) \\cdot \\hat{\\mathbf{n}} dS = -\\int_{C_{i,j}} \\rho dV = -Q_{i,j}\n$$\n其中 $Q_{i,j}$ 是单元 $C_{i,j}$ 中的总电荷。面积分通过对单元四个面（北、南、东、西）的通量求和来近似。对于单位深度的二维问题，面面积为 $h$。通过东面的通量是：\n$$\nF_e = \\left. (\\epsilon_x \\frac{\\partial\\phi}{\\partial x})\\right|_{i+1/2,j} h \\approx \\epsilon_{x,e} \\frac{\\phi_{i+1,j}-\\phi_{i,j}}{h} h = \\epsilon_{x,e}(\\phi_{E}-\\phi_C)\n$$\n其中 $\\phi_C = \\phi_{i,j}$ 且 $\\phi_E = \\phi_{i+1,j}$。面介电常数 $\\epsilon_{x,e}$ 使用调和平均计算，以在材料界面处保持对称性和物理一致性：\n$$\n\\epsilon_{x,e} = \\frac{2\\epsilon_{x, C}\\epsilon_{x, E}}{\\epsilon_{x, C} + \\epsilon_{x, E}}\n$$\n对所有四个面的通量求和，得到内部单元 $C$ 的离散方程：\n$$\n\\epsilon_{x,e}(\\phi_E - \\phi_C) + \\epsilon_{x,w}(\\phi_W - \\phi_C) + \\epsilon_{y,n}(\\phi_N - \\phi_C) + \\epsilon_{y,s}(\\phi_S - \\phi_C) = -Q_C\n$$\n这可以重排成一个五点模板形式：\n$$\n-(\\epsilon_{x,e}+\\epsilon_{x,w}+\\epsilon_{y,n}+\\epsilon_{y,s})\\phi_C + \\epsilon_{x,e}\\phi_E + \\epsilon_{x,w}\\phi_W + \\epsilon_{y,n}\\phi_N + \\epsilon_{y,s}\\phi_S = -Q_C\n$$\n对于所有内部节点 $(i,j)$，其中 $i \\in \\{1,\\dots,N_x-2\\}$ 且 $j \\in \\{1,\\dots,N_y-2\\}$，这组线性方程可以写成矩阵形式 $A\\boldsymbol{\\phi} = \\mathbf{b}$。这里，$\\boldsymbol{\\phi}$ 是内部节点处未知电势的向量，$\\mathbf{b}$ 是源向量，其元素为 $b_k = -Q_k$，而 $A$ 是系统矩阵。\n\n这种离散化的关键特性是得到的矩阵 $A$ 是对称的。一对相邻节点，例如 $C=(i,j)$ 和 $E=(i+1,j)$ 之间的耦合项，来自于单元 C 的方程（$\\phi_E$ 的系数是 $\\epsilon_{x,e}$）和单元 E 的方程（$\\phi_C$ 的系数是单元 E 的 $\\epsilon_{x,w}$）。调和平均的定义确保了从两侧看面介电常数是相同的：$\\epsilon_{x,e}(i,j) = \\epsilon_{x,w}(i+1,j)$。因此，矩阵元素 $A_{CE}$ 等于 $A_{EC}$，矩阵 $A$ 是对称的 ($A=A^T$)。\n\n**3. 互易性的数值验证**\n\n对于一个对称的系统矩阵 $A$，离散版本的互易性在数学上是有保证的。设两个源向量 $\\mathbf{Q}_1$ 和 $\\mathbf{Q}_2$ 分别生成电势向量 $\\boldsymbol{\\phi}_1$ 和 $\\boldsymbol{\\phi}_2$。\n$$\nA\\boldsymbol{\\phi}_1 = -\\mathbf{Q}_1 \\implies \\boldsymbol{\\phi}_1 = -A^{-1}\\mathbf{Q}_1\n$$\n$$\nA\\boldsymbol{\\phi}_2 = -\\mathbf{Q}_2 \\implies \\boldsymbol{\\phi}_2 = -A^{-1}\\mathbf{Q}_2\n$$\n离散互易性积分为 $I_1 = \\sum_k Q_{1,k}\\phi_{2,k} = \\mathbf{Q}_1^T \\boldsymbol{\\phi}_2$ 和 $I_2 = \\sum_k Q_{2,k}\\phi_{1,k} = \\mathbf{Q}_2^T \\boldsymbol{\\phi}_1$。代入电势的表达式：\n$$\nI_1 = \\mathbf{Q}_1^T (-A^{-1}\\mathbf{Q}_2) = -\\mathbf{Q}_1^T A^{-1}\\mathbf{Q}_2\n$$\n$$\nI_2 = \\mathbf{Q}_2^T (-A^{-1}\\mathbf{Q}_1) = -\\mathbf{Q}_2^T A^{-1}\\mathbf{Q}_1\n$$\n由于 $I_2$ 是一个标量，它等于其转置：$I_2 = -(\\mathbf{Q}_2^T A^{-1}\\mathbf{Q}_1)^T = -\\mathbf{Q}_1^T (A^{-1})^T \\mathbf{Q}_2$。要使互易性 ($I_1 = I_2$) 成立，我们需要 $A^{-1} = (A^{-1})^T$，这当且仅当 $A = A^T$ 时成立。\n因此，数值实验验证了有限体积法实现的正确性，特别是系统矩阵 $A$ 的对称组合。预期的结果是互易性误差接近机器精度，这完全由浮点运算和线性求解器的数值容差引起。\n\n**4. 实现策略**\n\n每个测试用例的数值流程如下：\n1.  定义网格参数（$N_x, N_y, h$）、材料属性和激励频率 $\\omega$。\n2.  根据给定 $\\omega$ 的材料模型，为所有单元 $(i,j)$ 构建复介电常数网格 $\\epsilon_x(i,j)$ 和 $\\epsilon_y(i,j)$。\n3.  通过遍历所有内部单元并使用调和平均计算面介电常数的五点模板系数，来组合 $(N_x-2)(N_y-2) \\times (N_x-2)(N_y-2)$ 的复对称稀疏矩阵 $A$。\n4.  为两个偶极子定义电荷分布 $Q_1$ 和 $Q_2$，并构建相应的源向量 $\\mathbf{b}_1 = -\\mathbf{Q}_1$ 和 $\\mathbf{b}_2 = -\\mathbf{Q}_2$。\n5.  使用稀疏直接求解器求解两个线性系统 $A\\boldsymbol{\\phi}_1 = \\mathbf{b}_1$ 和 $A\\boldsymbol{\\phi}_2 = \\mathbf{b}_2$ 以获得电势向量 $\\boldsymbol{\\phi}_1$ 和 $\\boldsymbol{\\phi}_2$。\n6.  计算互易性积分 $I_1 = \\mathbf{Q}_1^T\\boldsymbol{\\phi}_2$ 和 $I_2 = \\mathbf{Q}_2^T\\boldsymbol{\\phi}_1$。由于源向量是稀疏的（每个偶极子仅在两个位置非零），这些只是简单的求和。\n7.  使用提供的公式计算相对误差：$\\mathrm{err} = |I_1 - I_2| / \\max(|I_1|, |I_2|, \\varepsilon)$。\n\n对四个指定的测试用例中的每一个重复此过程，并报告最终的误差列表。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Verifies Lorentz reciprocity for a 2D electroquasistatic system\n    with an anisotropic, dispersive, and lossy slab.\n    \"\"\"\n    \n    # Physical and numerical constants\n    e0 = 8.8541878128e-12  # Vacuum permittivity in F/m\n    \n    # Global domain settings\n    Nx, Ny = 40, 40\n    h = 1e-3  # Grid spacing in m\n    slab_j1, slab_j2 = 14, 26\n    q_mag = 1e-9  # Charge magnitude for dipoles in C\n    err_eps = 1e-30 # Small number for error denominator\n    \n    # Test case definitions\n    # (material_params, omega, dipole1_info, dipole2_info)\n    \n    # Material A model\n    mat_A = {\n        'eps_inf_x': 2 * e0, 'eps_s_x': 8 * e0, 'tau_x': 1e-10, 'sigma_x': 0.5,\n        'eps_inf_y': 3 * e0, 'eps_s_y': 6 * e0, 'tau_y': 5e-11, 'sigma_y': 0.2\n    }\n    \n    # Material B model (isotropic, lossless)\n    mat_B = {\n        'eps_inf_x': 4 * e0, 'eps_s_x': 4 * e0, 'tau_x': 1e-10, 'sigma_x': 0.0,\n        'eps_inf_y': 4 * e0, 'eps_s_y': 4 * e0, 'tau_y': 1e-10, 'sigma_y': 0.0\n    }\n    \n    # Frequencies\n    w1 = 2 * np.pi * 5e9\n    w2 = 2 * np.pi * 5e7\n    w3 = 2 * np.pi * 3e10\n    \n    test_cases = [\n        (mat_A, w1, {'center': (8, 10), 'orient': 'x'}, {'center': (30, 29), 'orient': 'y'}),\n        (mat_A, w2, {'center': (8, 10), 'orient': 'x'}, {'center': (30, 29), 'orient': 'y'}),\n        (mat_B, w1, {'center': (12, 20), 'orient': 'x'}, {'center': (28, 20), 'orient': 'y'}),\n        (mat_A, w3, {'center': (20, 13), 'orient': 'x'}, {'center': (22, 27), 'orient': 'y'})\n    ]\n\n    results = []\n\n    def get_permittivity(mat_params, w):\n        \"\"\"Calculates complex permittivity for a given material and frequency.\"\"\"\n        eps = {}\n        for k in ['x', 'y']:\n            eps_inf = mat_params[f'eps_inf_{k}']\n            eps_s = mat_params[f'eps_s_{k}']\n            tau = mat_params[f'tau_{k}']\n            sigma = mat_params[f'sigma_{k}']\n            \n            # Debye + conductivity model\n            eps[k] = eps_inf + (eps_s - eps_inf) / (1 + 1j * w * tau) + sigma / (1j * w)\n        return eps['x'], eps['y']\n\n    for case_num, (mat_params, w, d1_info, d2_info) in enumerate(test_cases):\n        \n        # 1. Construct permittivity grid\n        eps_x = np.full((Nx, Ny), e0, dtype=complex)\n        eps_y = np.full((Nx, Ny), e0, dtype=complex)\n        \n        slab_eps_x, slab_eps_y = get_permittivity(mat_params, w)\n        \n        eps_x[:, slab_j1:slab_j2 + 1] = slab_eps_x\n        eps_y[:, slab_j1:slab_j2 + 1] = slab_eps_y\n        \n        # 2. Assemble system matrix A\n        num_unknowns = (Nx - 2) * (Ny - 2)\n        A = lil_matrix((num_unknowns, num_unknowns), dtype=complex)\n        \n        # Map 2D interior grid (i, j) to 1D vector index k\n        def to_k(i, j):\n            return (j - 1) * (Nx - 2) + (i - 1)\n\n        for j in range(1, Ny - 1):      # Iterate over interior rows\n            for i in range(1, Nx - 1):  # Iterate over interior columns\n                \n                k = to_k(i, j)\n                \n                # West face\n                eps_x_w_val = (2 * eps_x[i-1, j] * eps_x[i, j]) / (eps_x[i-1, j] + eps_x[i, j])\n                \n                # East face\n                eps_x_e_val = (2 * eps_x[i, j] * eps_x[i+1, j]) / (eps_x[i, j] + eps_x[i+1, j])\n                \n                # South face\n                eps_y_s_val = (2 * eps_y[i, j-1] * eps_y[i, j]) / (eps_y[i, j-1] + eps_y[i, j])\n                \n                # North face\n                eps_y_n_val = (2 * eps_y[i, j] * eps_y[i, j+1]) / (eps_y[i, j] + eps_y[i, j+1])\n\n                # Diagonal term\n                A[k, k] = -(eps_x_w_val + eps_x_e_val + eps_y_s_val + eps_y_n_val)\n                \n                # Off-diagonal terms\n                if i > 1:      A[k, to_k(i-1, j)] = eps_x_w_val  # West neighbor\n                if i  Nx - 2: A[k, to_k(i+1, j)] = eps_x_e_val  # East neighbor\n                if j > 1:      A[k, to_k(i, j-1)] = eps_y_s_val  # South neighbor\n                if j  Ny - 2: A[k, to_k(i, j+1)] = eps_y_n_val  # North neighbor\n\n        A = A.tocsc()\n        \n        # 3. Create source vectors\n        def create_source_vector(dipole_info):\n            Q = np.zeros((Nx, Ny), dtype=complex)\n            i, j = dipole_info['center']\n            \n            if dipole_info['orient'] == 'x':\n                i1, j1 = i, j\n                i2, j2 = i + 1, j\n            else: # 'y'\n                i1, j1 = i, j\n                i2, j2 = i, j + 1\n            \n            Q[i1, j1] = -q_mag\n            Q[i2, j2] = +q_mag\n            \n            # Map Q grid to 1D source vector b = -Q\n            b = np.zeros(num_unknowns, dtype=complex)\n            for j_s in range(1, Ny - 1):\n                for i_s in range(1, Nx - 1):\n                    if Q[i_s, j_s] != 0:\n                        b[to_k(i_s, j_s)] = -Q[i_s, j_s]\n            \n            return Q, b\n            \n        Q1_grid, b1 = create_source_vector(d1_info)\n        Q2_grid, b2 = create_source_vector(d2_info)\n        \n        # 4. Solve linear systems\n        phi1_vec = spsolve(A, b1)\n        phi2_vec = spsolve(A, b2)\n\n        # 5. Calculate reciprocity integrals and error\n        I1 = 0.0\n        I2 = 0.0\n        \n        # Find non-zero charge locations\n        Q1_locs = np.argwhere(Q1_grid != 0)\n        Q2_locs = np.argwhere(Q2_grid != 0)\n        \n        # I1 = sum(Q1 * phi2)\n        for i, j in Q1_locs:\n            k = to_k(i, j)\n            I1 += Q1_grid[i, j] * phi2_vec[k]\n        \n        # I2 = sum(Q2 * phi1)\n        for i, j in Q2_locs:\n            k = to_k(i, j)\n            I2 += Q2_grid[i, j] * phi1_vec[k]\n\n        error = abs(I1 - I2) / max(abs(I1), abs(I2), err_eps)\n        results.append(error)\n        \n    # Final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3354270"}, {"introduction": "我们的最后一个实践将唯一性的概念从封闭区域推广到开放区域问题，例如天线向自由空间辐射，这类问题由亥姆霍兹（Helmholtz）方程描述。在这些无界区域中，仅在有限的边界面上设定条件不足以保证解的唯一性，我们还必须规定场在无穷远处的行为，即“辐射条件”，以确保能量是向外传播的。本练习将引导你通过一种基于边界积分的数值方法，探索索末菲（Sommerfeld）和西尔弗-穆勒（Silver-Müller）辐射条件的关键作用 [@problem_id:3354259]。你将亲眼见证，违背辐射条件将导致非物理的、不唯一的解，而不同的辐射条件形式如何殊途同归，最终指向同一个唯一的物理现实，并在此过程中发现互易定理在远场中的巧妙体现。", "problem": "您将实现、分析并比较两种用于均匀介质中二维外部时谐亥姆霍兹问题的边界元法 (BEM) 公式，重点关注辐射条件在确保唯一性中的作用以及洛伦兹互易定理的计算体现。您将使用圆形边界上的圆谐函数，在圆上构建一个谱精度的边界元法，并评估远场行为，以证明对于横电 (TE) 极化，索末菲辐射条件与 Silver–Müller 辐射条件的等价性，以及当辐射条件被违反时唯一性的丧失。\n\n问题设置。令 $u(r,\\theta)$ 表示二维空间中横电 (TE) 极化下电场 $z$ 分量的标量场，时间约定为 $\\exp(-i \\omega t)$。该场在外部域 $\\{(r,\\theta) \\mid r \\ge a\\}$ 中满足齐次亥姆霍兹方程\n$$\n\\nabla^2 u + k^2 u = 0\n$$\n其中 $k$ 是波数，$a$ 是圆形边界 $\\Gamma = \\{ r = a \\}$ 的半径。边界条件规定了总场在 $\\Gamma$ 上的狄利克雷迹。未知解通过外部域中的截断圆谐级数表示\n$$\nu(r,\\theta) \\approx \\sum_{n=-N}^{N} \\alpha_n H_n^{(1)}(k r) e^{i n \\theta},\n$$\n其中 $H_n^{(1)}$ 是第一类汉克尔函数，它编码了索末菲辐射条件。在极坐标中，径向导数为 $\\partial_r u(r,\\theta) = k \\sum_{n=-N}^{N} \\alpha_n H_n^{(1)\\prime}(k r) e^{i n \\theta}$，其中撇号表示对自变量的微分。二维索末菲辐射条件为\n$$\n\\lim_{r\\to\\infty} \\sqrt{r}\\,\\left(\\partial_r u - i k u\\right) = 0.\n$$\n对于麦克斯韦方程组的 TE 极化，通过与波阻抗 $\\eta$ 的本构关系以及关系式 $k = \\omega \\sqrt{\\mu \\epsilon}$，Silver–Müller 辐射条件可简化为与 $u$ 相同的标量条件：\n$$\n\\mathbf{\\hat r} \\times \\mathbf{H} - \\frac{1}{\\eta}\\mathbf{E} \\to \\mathbf{0}\n\\quad \\Longleftrightarrow \\quad\n\\partial_r u - i k u \\to 0,\n$$\n当 $r \\to \\infty$ 时。\n\n您将使用此圆谐函数展开在圆上实现两种 BEM 风格的求解器：\n- 一个 Sommerfeld-BEM，它使用出射汉克尔级数在 $r=a$ 上强制施加边界条件。\n- 一个 Silver–Müller-BEM，它在 $r=a$ 上强制施加边界条件，并额外在一个大的截断半径 $r=R_{\\mathrm{far}}$ 处以最小二乘方式强制施加 Silver–Müller 条件，通过添加惩罚在 $r=R_{\\mathrm{far}}$ 处残差 $\\partial_r u - i k u$ 的行来实现。\n\n您还将通过违反辐射条件并允许入射波来构造一个非辐射解：\n$$\nu_{\\mathrm{in}}(r,\\theta) \\approx \\sum_{n=-N}^{N} \\beta_n H_n^{(2)}(k r) e^{i n \\theta},\n$$\n其中 $H_n^{(2)}$ 是第二类汉克尔函数（入射）。通过适当选择系数 $\\beta_n$，可以使此表示在 $r=a$ 处与相同的狄利克雷边界数据一致，从而证明在不强制执行辐射条件的情况下，外部问题的非唯一性。\n\n最后，您将计算在半径为 $r=R$ 的圆上的洛伦兹互易边界积分的离散版本，\n$$\n\\mathcal{J}_R(u_1,u_2) = \\int_{0}^{2\\pi} \\left(u_1 \\,\\partial_r u_2 - u_2 \\,\\partial_r u_1\\right) \\, R \\, d\\theta,\n$$\n针对亥姆霍兹方程在外部域的两个独立解 $u_1$ 和 $u_2$。使用出射解，远场渐近行为意味着当 $R \\to \\infty$ 时 $\\mathcal{J}_R(u_1,u_2) \\to 0$，这是洛伦兹互易定理的远场体现。如果其中一个解是入射的，$\\mathcal{J}_R(u_{\\mathrm{out}},u_{\\mathrm{in}})$ 不会随 $R$ 衰减。\n\n基本依据。仅使用以下基础：\n- 极坐标下的亥姆霍兹方程 $\\nabla^2 u + k^2 u = 0$。\n- 极坐标下的分离变量法，导出傅里叶模式 $e^{i n \\theta}$ 和径向贝塞尔/汉克尔函数。\n- $H_n^{(1)}$（出射）和 $H_n^{(2)}$（入射）的定义。\n- 索末菲辐射条件及其 TE 极化下的 Silver-Müller 等价性。\n- 边界积分互易泛函 $\\mathcal{J}_R(u_1,u_2)$。\n\n需要实现和计算的任务：\n1) 在圆 $\\Gamma$ 上实现一个 Sommerfeld-BEM，通过以最小二乘方式求解系数 $\\{\\alpha_n\\}_{n=-N}^{N}$，使其在 $r=a$ 处匹配狄利克雷边界数据。使用一个均匀的 $\\theta$ 网格，角度单位为弧度。令目标边界数据为索引为 $m$ 的单个出射模式的数据，即：\n$$\ng(\\theta) = H_m^{(1)}(k a)\\, e^{i m \\theta}.\n$$\n2) 实现一个 Silver–Müller-BEM，通过一个最小二乘问题求解系数 $\\{\\tilde{\\alpha}_n\\}_{n=-N}^{N}$。该问题堆叠了两组方程：在 $r=a$ 处的边界匹配，以及在 $r=R_{\\mathrm{far}}$ 处施加的带惩罚权重 $\\lambda$ 的 Silver–Müller 残差 $\\partial_r u - i k u = 0$，所有采样均在均匀的 $\\theta$（弧度）上进行。\n3) 通过违反辐射条件来构造一个非辐射解：仅采用入射谐波，其系数 $\\{\\beta_n\\}_{n=-N}^{N}$ 的选择要确保在 $r=a$ 处匹配相同的边界数据 $g(\\theta)$。一个简单的非唯一性证明是设置除 $\\beta_m = H_m^{(1)}(k a)/H_m^{(2)}(k a)$ 外的所有 $\\beta_n=0$，这确保了 $u_{\\mathrm{in}}(a,\\theta) = g(\\theta)$，但对于 $r  a$ 产生了不同的场。\n4) 在圆 $r=R_{\\mathrm{far}}$ 上评估三个场 $u_{\\mathrm{Sommerfeld}}$、$u_{\\mathrm{Silver\\text{--}M\\ddot{u}ller}}$ 和 $u_{\\mathrm{incoming}}$ 的远场解，并计算：\n   - 相对 $\\ell^2$ 差异\n   $$\n   \\mathrm{err}_{\\mathrm{eq}} = \\frac{\\|u_{\\mathrm{Sommerfeld}} - u_{\\mathrm{Silver\\text{--}M\\ddot{u}ller}}\\|_2}{\\|u_{\\mathrm{Sommerfeld}}\\|_2}\n   $$\n   以证明当 $k R_{\\mathrm{far}} \\to \\infty$ 时，两种辐射条件实现的等价性。\n   - 相对 $\\ell^2$ 差异\n   $$\n   \\mathrm{err}_{\\mathrm{nonuniq}} = \\frac{\\|u_{\\mathrm{Sommerfeld}} - u_{\\mathrm{incoming}}\\|_2}{\\|u_{\\mathrm{Sommerfeld}}\\|_2}\n   $$\n   以证明当允许匹配相同边界数据的入射波时存在的非唯一性。\n5) 在大半径 $r=R_{\\mathrm{rec}}$ 处计算互易边界积分：\n   $$\n   \\mathcal{J}_{R_{\\mathrm{rec}}}(u_1,u_2) = \\int_0^{2\\pi} \\left(u_1 \\,\\partial_r u_2 - u_2 \\,\\partial_r u_1\\right) R_{\\mathrm{rec}} \\, d\\theta,\n   $$\n   使用梯形法则。评估：\n   - 对于两个出射模式 $m_1$ 和 $m_2$ 的 $\\left|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{out},m_2})\\right|$，对于大的 $R_{\\mathrm{rec}}$，该值应很小。\n   - 对于一个出射模式和一个入射模式的 $\\left|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{in},m_2})\\right|$，该值应显著更大，并随着 $R_{\\mathrm{rec}}$ 的增加趋向于一个非零极限。\n\n物理和数值单位：\n- $k$ 的单位为 $\\mathrm{m}^{-1}$。\n- $a$、$R_{\\mathrm{far}}$ 和 $R_{\\mathrm{rec}}$ 的单位为 $\\mathrm{m}$。\n- 所有角度 $\\theta$ 的单位均为弧度。\n- 输出为无量纲浮点数。\n\n测试套件。您的程序必须运行以下测试并汇总其结果：\n- 测试 A（等价性与非唯一性）：\n  - $k = 8.0\\,\\mathrm{m}^{-1}$，$a = 1.0\\,\\mathrm{m}$，$m = 3$，$N = 7$，$N_\\theta = 256$，$R_{\\mathrm{far}} = 40.0\\,\\mathrm{m}$，以及惩罚权重 $\\lambda = 1000$。\n  - 输出两个浮点数：$\\mathrm{err}_{\\mathrm{eq}}$ 和 $\\mathrm{err}_{\\mathrm{nonuniq}}$。\n- 测试 B（无穷远处的互易性）：\n  - $k_{\\mathrm{rec}} = 6.0\\,\\mathrm{m}^{-1}$，$R_{\\mathrm{rec}} = 100.0\\,\\mathrm{m}$，$m_1 = 1$，$m_2 = -1$，$N_\\theta = 2048$。\n  - 输出两个浮点数：$\\left|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{out},m_2})\\right|$ 和 $\\left|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{in},m_2})\\right|$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n\\left[\\mathrm{err}_{\\mathrm{eq}},\\, \\mathrm{err}_{\\mathrm{nonuniq}},\\, \\left|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{out},m_2})\\right|,\\, \\left|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{in},m_2})\\right|\\right].\n$$", "solution": "该问题被评估为有效。它在科学上基于成熟的波传播理论和计算电磁学，特别是关于亥姆霍兹方程、辐射条件和洛伦兹互易定理。该问题是适定的，提供了构建唯一且有意义的解所需的所有物理参数、数学定义和数值规范。所述任务是客观、可形式化的，并构成了通过数值模拟验证基本电磁原理的标准学术练习。\n\n### 1. 理论框架与场表示\n\n该问题探讨的是时谐、二维、外部亥姆霍兹方程，其标量场 $u(r,\\theta)$ 对应于横电 (TE) 极化下电场的 $z$ 分量 ($E_z$)：\n$$\n\\nabla^2 u + k^2 u = 0 \\quad \\text{for } r \\ge a\n$$\n其中 $k$ 是波数，域是半径为 $a$ 的圆的外部。在极坐标中，该方程的解可以用分离变量法表示。对于外部问题，解还必须满足无穷远处的辐射条件，以确保其对应于物理上有意义的出射波并保证唯一性。合适的径向函数是汉克尔函数，从而得到一个截断的圆谐级数的一般表示：\n$$\nu(r,\\theta) \\approx \\sum_{n=-N}^{N} c_n \\mathcal{H}_n(k r) e^{i n \\theta}\n$$\n其中 $\\mathcal{H}_n$ 可以是用于出射波的第一类汉克尔函数 $H_n^{(1)}$，或用于入射波的第二类汉克尔函数 $H_n^{(2)}$。系数 $\\{c_n\\}$ 由边界条件确定。\n\n### 2. 边界元法 (BEM) 的实现\n\n我们实现两种方法来求解出射波解的系数，该解在边界圆 $\\Gamma$（$r=a$ 处）上匹配给定的狄利克雷数据 $g(\\theta) = u(a,\\theta)$。在此问题中，目标数据是单个出射模式的数据，$g(\\theta) = H_m^{(1)}(k a) e^{i m \\theta}$。未知系数通过在 $N_\\theta$ 个点的均匀网格 $\\theta_j = 2\\pi j / N_\\theta$ 上以最小二乘方式求解一个线性系统来找到。\n\n**任务 1：Sommerfeld-BEM 求解器**\n\n该方法通过仅使用出射汉克尔函数 $H_n^{(1)}$ 来表示解，从而直接包含了索末菲辐射条件：\n$$\nu_{\\mathrm{Sommerfeld}}(r,\\theta) = \\sum_{n=-N}^{N} \\alpha_n H_n^{(1)}(k r) e^{i n \\theta}\n$$\n系数 $\\{\\alpha_n\\}_{n=-N}^N$ 通过在 $r=a$ 处施加边界条件来确定：\n$$\n\\sum_{n=-N}^{N} \\alpha_n H_n^{(1)}(k a) e^{i n \\theta_j} = g(\\theta_j) = H_m^{(1)}(k a) e^{i m \\theta_j}, \\quad \\text{for } j=0, \\dots, N_\\theta-1\n$$\n这构成了一个超定的线性方程组 $\\mathbf{A} \\mathbf{\\alpha} = \\mathbf{b}$，其中：\n- $\\mathbf{\\alpha}$ 是包含 $2N+1$ 个未知系数的向量 $[\\alpha_{-N}, \\dots, \\alpha_N]^T$。\n- $\\mathbf{A}$ 是 $N_\\theta \\times (2N+1)$ 的系统矩阵，其元素为 $A_{j,n'} = H_{n'-N-1}^{(1)}(k a) e^{i (n'-N-1) \\theta_j}$（列使用基于 1 的索引）。我们使用模式索引 $n \\in \\{-N, ..., N\\}$：$A_{j,n} = H_n^{(1)}(ka) e^{in\\theta_j}$。\n- $\\mathbf{b}$ 是边界数据向量，其元素为 $b_j = g(\\theta_j)$。\n该系统使用线性最小二乘法（`numpy.linalg.lstsq`）求解 $\\mathbf{\\alpha}$。\n\n**任务 2：Silver–Müller-BEM 求解器**\n\n该方法在 $r=a$ 处施加边界条件，并额外在一个大但有限的半径 $R_{\\mathrm{far}}$ 处施加 Silver–Müller 辐射条件。对于 TE 极化，此条件等价于当 $r \\to \\infty$ 时 $\\partial_r u - i k u \\to 0$。我们在 $r=R_{\\mathrm{far}}$ 处以最小二乘的方式并使用惩罚权重 $\\lambda$ 来施加此条件：\n$$\n\\partial_r u(R_{\\mathrm{far}}, \\theta_j) - i k u(R_{\\mathrm{far}}, \\theta_j) \\approx 0\n$$\n代入 $u(r,\\theta)$ 的展开式及其径向导数 $\\partial_r u = \\sum_n \\tilde{\\alpha}_n k H_n^{(1)\\prime}(k r) e^{i n \\theta}$，得到一组关于系数 $\\{\\tilde{\\alpha}_n\\}$ 的线性方程：\n$$\n\\sum_{n=-N}^{N} \\tilde{\\alpha}_n \\left[ k H_n^{(1)\\prime}(k R_{\\mathrm{far}}) - i k H_n^{(1)}(k R_{\\mathrm{far}}) \\right] e^{i n \\theta_j} = 0\n$$\n这构成了第二个矩阵系统 $\\mathbf{A}_{\\mathrm{SM}} \\tilde{\\mathbf{\\alpha}} = \\mathbf{0}$。最终的系统是一个堆叠的最小二乘问题，结合了边界条件和带惩罚的辐射条件：\n$$\n\\begin{pmatrix} \\mathbf{A} \\\\ \\lambda \\mathbf{A}_{\\mathrm{SM}} \\end{pmatrix} \\tilde{\\mathbf{\\alpha}} = \\begin{pmatrix} \\mathbf{b} \\\\ \\mathbf{0} \\end{pmatrix}\n$$\n这个更大的系统也使用最小二乘法求解，以找到系数 $\\tilde{\\mathbf{\\alpha}}$。\n\n### 3. 非唯一性与非辐射解\n\n**任务 3：非辐射解**\n\n为了证明辐射条件对唯一性至关重要，我们构造一个仅使用入射汉克尔函数 $H_n^{(2)}$ 的解 $u_{\\mathrm{in}}(r,\\theta)$，该解违反了索末菲条件：\n$$\nu_{\\mathrm{in}}(r,\\theta) = \\sum_{n=-N}^{N} \\beta_n H_n^{(2)}(k r) e^{i n \\theta}\n$$\n选择系数 $\\{\\beta_n\\}$ 以便在 $r=a$ 处匹配相同的边界数据 $g(\\theta)$：\n$$\n\\sum_{n=-N}^{N} \\beta_n H_n^{(2)}(k a) e^{i n \\theta_j} = H_m^{(1)}(k a) e^{i m \\theta_j}\n$$\n由于复指数函数 $e^{in\\theta}$ 在圆上的正交性，可以轻易地发现解为当 $n \\neq m$ 时 $\\beta_n = 0$，而 $\\beta_m = H_m^{(1)}(k a) / H_m^{(2)}(k a)$。这提供了一个与 $u_{\\mathrm{Sommerfeld}}$ 不同但共享相同狄利克雷边界数据的解，从而证明了在没有辐射条件的情况下外部问题的非唯一性。\n\n### 4. 数值分析与验证\n\n**任务 4：等价性与非唯一性演示**\n\n通过在远场 $r=R_{\\mathrm{far}}$ 处比较 Sommerfeld-BEM 和 Silver–Müller-BEM 的各自解 $u_{\\mathrm{Sommerfeld}}$ 和 $u_{\\mathrm{Silver\\text{--}M\\ddot{u}ller}}$，来评估它们的等价性。我们计算相对 $\\ell^2$ 差异：\n$$\n\\mathrm{err}_{\\mathrm{eq}} = \\frac{\\|u_{\\mathrm{Sommerfeld}} - u_{\\mathrm{Silver\\text{--}M\\ddot{u}ller}}\\|_2}{\\|u_{\\mathrm{Sommerfeld}}\\|_2}\n$$\n$\\mathrm{err}_{\\mathrm{eq}}$ 的一个较小值表明，在大的有限半径处施加 Silver–Müller 条件是无穷远处索末菲条件的有效数值代理。\n\n非唯一性通过比较辐射的索末菲解与非辐射的入射解来量化，两者都在 $r=R_{\\mathrm{far}}$ 处进行评估：\n$$\n\\mathrm{err}_{\\mathrm{nonuniq}} = \\frac{\\|u_{\\mathrm{Sommerfeld}} - u_{\\mathrm{incoming}}\\|_2}{\\|u_{\\mathrm{Sommerfeld}}\\|_2}\n$$\n由于 $u_{\\mathrm{Sommerfeld}}$ 按 $r^{-1/2}$ 衰减，而 $u_{\\mathrm{incoming}}$ 按 $r^{-1/2}$ 增长，这个差异将是显著的，证实它们是不同的解。\n\n**任务 5：洛伦兹互易定理**\n\n在此背景下，洛伦兹互易定理意味着，对于满足索末菲辐射条件的齐次亥姆霍兹方程的任意两个解 $u_1, u_2$，当边界取至无穷远时，以下边界积分消失：\n$$\n\\lim_{R\\to\\infty} \\mathcal{J}_R(u_1,u_2) = \\lim_{R\\to\\infty} \\int_{0}^{2\\pi} \\left(u_1 \\,\\partial_r u_2 - u_2 \\,\\partial_r u_1\\right) \\, R \\, d\\theta = 0\n$$\n我们通过在大的半径 $R=R_{\\mathrm{rec}}$ 处，使用梯形法则在一个包含 $N_\\theta$ 个点的细网格（$\\Delta\\theta = 2\\pi/N_\\theta$）上计算积分，对两种测试情况进行数值验证。\n被积函数项 $(u_1 \\partial_r u_2 - u_2 \\partial_r u_1)$ 与径向解的朗斯基行列式有关。\n1.  **两个出射解**：$u_1 = u_{\\mathrm{out},m_1}$ 和 $u_2 = u_{\\mathrm{out},m_2}$。\n    径向函数都是第一类汉克尔函数。它们的朗斯基行列式为零，因此积分 $|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{out},m_2})|$ 在解析上应为零，而在数值上由于浮点和求积误差应非常小。\n2.  **一个出射解，一个入射解**：$u_1 = u_{\\mathrm{out},m_1}$ 和 $u_2 = u_{\\mathrm{in},m_2}$。\n    径向函数是 $H_{m_1}^{(1)}(kr)$ 和 $H_{m_2}^{(2)}(kr)$。对于 $m_1 = -m_2$，积分非零。$H_n^{(1)}(z)$ 和 $H_n^{(2)}(z)$ 的朗斯基行列式是 $W[H_n^{(1)}, H_n^{(2)}](z) = -4i/(\\pi z)$。这导致 $|\\mathcal{J}_{R_{\\mathrm{rec}}}(u_{\\mathrm{out},m_1}, u_{\\mathrm{in},m_2})|$ 的一个非零值，该值与 $R_{\\mathrm{rec}}$ 无关，对于给定的参数，具体为 $|8i|=8$。这表明互易性要求两个场都是出射的。\n\n该实现将依次执行测试 A（等价性与非唯一性）和测试 B（互易性）的计算，并汇总四个指定的浮点数值作为最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Implements and compares BEM formulations for the 2D exterior Helmholtz problem,\n    demonstrating the role of radiation conditions and the Lorentz reciprocity theorem.\n    \"\"\"\n    \n    # === TEST A: Equivalence of Radiation Conditions and Non-Uniqueness ===\n    k = 8.0          # Wavenumber in m^-1\n    a = 1.0          # Boundary radius in m\n    m = 3            # Mode index for boundary data\n    N = 7            # Truncation order for circular harmonics\n    N_theta = 256    # Number of points on the circle grid\n    R_far = 40.0     # Far-field radius for SM condition and evaluation\n    penalty_lambda = 1000.0  # Penalty weight for SM condition\n\n    modes = np.arange(-N, N + 1)\n    n_modes = len(modes)\n    theta = np.linspace(0, 2 * np.pi, N_theta, endpoint=False)\n    \n    # 1. Sommerfeld-BEM Solver\n    A_som = np.zeros((N_theta, n_modes), dtype=np.complex128)\n    for i, n_mode in enumerate(modes):\n        A_som[:, i] = special.hankel1(n_mode, k * a) * np.exp(1j * n_mode * theta)\n    \n    b_som = special.hankel1(m, k * a) * np.exp(1j * m * theta)\n    alpha_som, _, _, _ = np.linalg.lstsq(A_som, b_som, rcond=None)\n    \n    # 2. Silver-Müller-BEM Solver\n    A_bc = A_som\n    b_bc = b_som\n    \n    A_sm = np.zeros((N_theta, n_modes), dtype=np.complex128)\n    for i, n_mode in enumerate(modes):\n        # The penalty expression is k * [H_n'(kR) - i*H_n(kR)]\n        sm_term = k * (special.h1vp(n_mode, k * R_far) - 1j * special.hankel1(n_mode, k * R_far))\n        A_sm[:, i] = sm_term * np.exp(1j * n_mode * theta)\n        \n    A_stacked = np.vstack([A_bc, penalty_lambda * A_sm])\n    b_stacked = np.hstack([b_bc, np.zeros(N_theta, dtype=np.complex128)])\n    alpha_sm, _, _, _ = np.linalg.lstsq(A_stacked, b_stacked, rcond=None)\n\n    # 3. Non-radiating (incoming) solution\n    beta = np.zeros(n_modes, dtype=np.complex128)\n    m_idx = np.where(modes == m)[0][0]\n    beta[m_idx] = special.hankel1(m, k * a) / special.hankel2(m, k * a)\n    \n    # 4. Evaluate fields at R_far and compute errors\n    u_som_far = np.zeros_like(theta, dtype=np.complex128)\n    u_sm_far = np.zeros_like(theta, dtype=np.complex128)\n    u_in_far = np.zeros_like(theta, dtype=np.complex128)\n\n    for i, n_mode in enumerate(modes):\n        exp_term = np.exp(1j * n_mode * theta)\n        hankel1_val = special.hankel1(n_mode, k * R_far)\n        \n        u_som_far += alpha_som[i] * hankel1_val * exp_term\n        u_sm_far += alpha_sm[i] * hankel1_val * exp_term\n        u_in_far += beta[i] * special.hankel2(n_mode, k * R_far) * exp_term\n        \n    norm_u_som = np.linalg.norm(u_som_far)\n    err_eq = np.linalg.norm(u_som_far - u_sm_far) / norm_u_som\n    err_nonuniq = np.linalg.norm(u_som_far - u_in_far) / norm_u_som\n\n    # === TEST B: Reciprocity Integral ===\n    k_rec = 6.0\n    R_rec = 100.0\n    m1 = 1\n    m2 = -1\n    N_theta_rec = 2048\n    \n    theta_rec = np.linspace(0, 2 * np.pi, N_theta_rec, endpoint=False)\n    d_theta = 2 * np.pi / N_theta_rec\n    kr_rec = k_rec * R_rec\n\n    # Case 1: Two outgoing solutions (u_out_m1, u_out_m2)\n    u1_out = special.hankel1(m1, kr_rec) * np.exp(1j * m1 * theta_rec)\n    dr_u1_out = k_rec * special.h1vp(m1, kr_rec) * np.exp(1j * m1 * theta_rec)\n    \n    u2_out = special.hankel1(m2, kr_rec) * np.exp(1j * m2 * theta_rec)\n    dr_u2_out = k_rec * special.h1vp(m2, kr_rec) * np.exp(1j * m2 * theta_rec)\n    \n    integrand_out_out = (u1_out * dr_u2_out - u2_out * dr_u1_out) * R_rec\n    J_out_out = np.sum(integrand_out_out) * d_theta\n    \n    # Case 2: One outgoing, one incoming solution (u_out_m1, u_in_m2)\n    u2_in = special.hankel2(m2, kr_rec) * np.exp(1j * m2 * theta_rec)\n    dr_u2_in = k_rec * special.h2vp(m2, kr_rec) * np.exp(1j * m2 * theta_rec)\n    \n    integrand_out_in = (u1_out * dr_u2_in - u2_in * dr_u1_out) * R_rec\n    J_out_in = np.sum(integrand_out_in) * d_theta\n    \n    # Aggregate results from both tests\n    results = [err_eq, err_nonuniq, np.abs(J_out_out), np.abs(J_out_in)]\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354259"}]}