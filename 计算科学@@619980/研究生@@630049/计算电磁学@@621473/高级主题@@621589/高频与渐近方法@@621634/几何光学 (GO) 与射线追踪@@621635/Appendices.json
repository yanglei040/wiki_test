{"hands_on_practices": [{"introduction": "在深入研究复杂的数值积分之前，掌握近轴光学的矩阵表示法至关重要。这种方法被称为射线传输矩阵（或ABCD矩阵）方法，它将光线通过一系列标准光学元件的追踪过程，简化为优雅的矩阵乘法运算。本练习将从斯涅尔定律等第一性原理出发，指导你构建并串联一个复合光学系统的传递矩阵，从而为系统化的光学设计与分析打下坚实的基础。[@problem_id:3311406]", "problem": "一个旋转对称的成像系统由一个空气中的厚双凸单透镜、一个气隙和一块平行平板窗口组成，所有元件共轴。设光轴为指向右侧的 $z$ 轴，光线高度 $y$ 为横向于光轴的度量，近轴角 $u \\equiv dy/dz$（以弧度为单位）。采用符号约定，即如果球面曲率中心位于其表面顶点右侧，则其半径 $R$ 为正。\n\n透镜的折射率为 $n_{\\ell} = 1.5168$，中心厚度为 $t = 8\\,\\mathrm{mm}$。其第一个表面（空气到玻璃）的半径为 $R_1 = +50\\,\\mathrm{mm}$，其第二个表面（玻璃到空气）的半径为 $R_2 = -50\\,\\mathrm{mm}$。紧随透镜之后是一个长度为 $g = 20\\,\\mathrm{mm}$ 的气隙。气隙之后是一块厚度为 $w = 2\\,\\mathrm{mm}$、折射率为 $n_{w} = 1.5$ 的平行平板窗口，其两侧均为空气。所有未另外说明的介质均为折射率为 $n_0 = 1$ 的空气。\n\n从第一性原理出发，使用近轴近似，从斯涅尔定律和球面的小角度几何形状开始，构建球面和平坦界面上平移和折射的适当 $2\\times 2$ 光线传输矩阵。按照传播顺序级联这些矩阵，以获得从第一个透镜表面前的参考输入平面到窗口出射面后的输出平面的总体一阶系统矩阵。\n\n假设一束准直输入光束（物在无穷远处）入射到系统上，确定从窗口出射面测量的后焦距 $L$（即从窗口出射面到近轴焦点的空气中轴向距离）。将最终数值结果四舍五入至四位有效数字。以 $\\mathrm{mm}$ 为单位表示你的答案。", "solution": "对用户提供的问题进行有效性评估。\n\n**步骤1：提取已知条件**\n- **系统配置**：一个旋转对称的成像系统，由一个厚双凸单透镜、一个气隙和一块平行平板窗口组成，所有元件共轴。\n- **坐标系**：光轴为 $z$ 轴，指向右侧。光线高度为 $y$。近轴角为 $u \\equiv dy/dz$。\n- **符号约定**：如果球面曲率中心位于其顶点右侧，则其半径 $R$ 为正。\n- **透镜参数**：\n  - 折射率：$n_{\\ell} = 1.5168$\n  - 中心厚度：$t = 8\\,\\mathrm{mm}$\n  - 第一个表面半径（空气到玻璃）：$R_1 = +50\\,\\mathrm{mm}$\n  - 第二个表面半径（玻璃到空气）：$R_2 = -50\\,\\mathrm{mm}$\n- **气隙**：长度 $g = 20\\,\\mathrm{mm}$\n- **窗口参数**：\n  - 厚度：$w = 2\\,\\mathrm{mm}$\n  - 折射率：$n_{w} = 1.5$\n  - 几何形状：平行平板\n- **环境介质**：空气，折射率为 $n_0 = 1$。\n- **任务**：\n  1. 从第一性原理推导平移和折射的 $2\\times 2$ 光线传输矩阵。\n  2. 形成从第一个透镜表面前的平面到窗口出射面后的平面的总体系统矩阵。\n  3. 对于准直输入光束，确定从窗口出射面测量的后焦距 $L$。\n  4. 提供最终数值答案，以 $\\mathrm{mm}$ 为单位，并四舍五入至四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是使用光线传输矩阵法的近轴几何光学中的一个标准练习。其基本原理（小角度近似下的斯涅尔定律）是基础且公认的。所提供的物理参数（折射率、尺寸）对于常见的光学元件是现实的。\n- **良态问题**：该问题是良态的。所有必要的参数都已指定，目标明确，且该系统允许一个唯一的、稳定的解。\n- **目标**：问题陈述是定量的，没有主观或含糊的语言。\n\n**步骤3：结论与行动**\n该问题是**有效的**。它是一个完整、一致且科学上合理的计算电磁学问题，特别是在几何光学和光线追迹领域。可以开始求解过程。\n\n**求解推导**\n\n该问题将使用标准的光线传输矩阵法来解决，该方法将光线在两个不同平面上的位置 $y$ 和光学方向余弦 $\\nu = n u$ 联系起来。近轴光线的状态由向量 $\\begin{pmatrix} y \\\\ \\nu \\end{pmatrix}$ 描述。当这个向量通过一个光学系统传播时，其变换由一个 $2\\times 2$ 矩阵描述，通常称为ABCD矩阵。\n\n首先，我们按要求从第一性原理推导折射和平移矩阵。\n\n**1. 折射矩阵**\n考虑一个曲率半径为 $R$ 的球面，它分隔了两种折射率分别为 $n_1$ 和 $n_2$ 的介质。一束高度为 $y_1$、角度为 $u_1$ 的光线从左侧入射。折射后，其高度为 $y_2$，角度为 $u_2$。\n在入射点，高度不变：$y_2 = y_1$。\n斯涅尔定律的近轴形式是 $n_1 i_1 = n_2 i_2$，其中 $i_1$ 和 $i_2$ 是相对于表面法线的入射角和折射角。设 $\\phi$ 为表面法线与光轴的夹角。对于在半径为 $R$ 的球面上高度为 $y$ 的光线，$\\phi \\approx y/R$。从角度的几何关系，我们有 $i_1 = u_1 + \\phi$ 和 $i_2 = u_2 + \\phi$。\n将这些代入斯涅尔定律：\n$n_1(u_1 + \\phi) = n_2(u_2 + \\phi)$\n$n_1 u_1 + n_1 (y_1/R) = n_2 u_2 + n_2 (y_1/R)$\n整理得到 $n_2 u_2$：\n$n_2 u_2 = n_1 u_1 + \\frac{n_1 - n_2}{R} y_1$\n这是我们变换的第二个方程。我们定义光学方向余弦 $\\nu_1 = n_1 u_1$ 和 $\\nu_2 = n_2 u_2$。这两个方程是：\n$y_2 = y_1$\n$\\nu_2 = \\nu_1 + \\frac{n_1 - n_2}{R} y_1$\n这可以写成矩阵形式：\n$$ \\begin{pmatrix} y_2 \\\\ \\nu_2 \\end{pmatrix} = \\begin{pmatrix} 1  & 0 \\\\ \\frac{n_1 - n_2}{R} & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\nu_1 \\end{pmatrix} $$\n量 $P = \\frac{n_2 - n_1}{R}$ 是表面的光焦度。折射矩阵是 $\\mathcal{R} = \\begin{pmatrix} 1 & 0 \\\\ -P & 1 \\end{pmatrix}$。\n\n**2. 平移矩阵**\n考虑一束光线在折射率为 $n$ 的均匀介质中沿光轴平移距离 $d$。初始状态为 $(y_1, u_1)$，最终状态为 $(y_2, u_2)$。\n光线的角度不变，所以 $u_2 = u_1$。因此，$\\nu_2 = n u_2 = n u_1 = \\nu_1$。\n高度根据 $y_2 = y_1 + d \\tan(u_1)$ 变化。在近轴近似中，$\\tan(u_1) \\approx u_1$。\n所以，$y_2 = y_1 + d u_1$。由于 $u_1 = \\nu_1/n$，我们有 $y_2 = y_1 + \\frac{d}{n} \\nu_1$。\n这两个方程是：\n$y_2 = y_1 + \\frac{d}{n} \\nu_1$\n$\\nu_2 = \\nu_1$\n矩阵形式为：\n$$ \\begin{pmatrix} y_2 \\\\ \\nu_2 \\end{pmatrix} = \\begin{pmatrix} 1 & d/n \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\nu_1 \\end{pmatrix} $$\n平移矩阵是 $\\mathcal{T}(d, n) = \\begin{pmatrix} 1 & d/n \\\\ 0 & 1 \\end{pmatrix}$。\n\n**3. 系统矩阵构建**\n总系统矩阵 $M_{sys}$ 是每个光学元件的单个矩阵的乘积，按传播顺序的逆序相乘。该系统由透镜、气隙和窗口组成。\n$M_{sys} = M_{window} \\cdot M_{gap} \\cdot M_{lens}$\n$M_{sys} = (\\mathcal{R}_{w2}\\mathcal{T}_w\\mathcal{R}_{w1}) \\cdot \\mathcal{T}_g \\cdot (\\mathcal{R}_2\\mathcal{T}_{\\ell}\\mathcal{R}_1)$\n\n参数为：$n_0=1$，$n_{\\ell}=1.5168$，$n_w=1.5$，$R_1=50\\,\\mathrm{mm}$，$R_2=-50\\,\\mathrm{mm}$，$t=8\\,\\mathrm{mm}$，$g=20\\,\\mathrm{mm}$，$w=2\\,\\mathrm{mm}$。\n\n**透镜矩阵 ($M_{lens}$):**\n- 折射 $\\mathcal{R}_1$（空气到透镜）：$n_1=n_0=1$，$n_2=n_{\\ell}$，$R=R_1$。光焦度 $P_1 = \\frac{n_{\\ell} - n_0}{R_1} = \\frac{1.5168 - 1}{50} = 0.010336\\,\\mathrm{mm}^{-1}$。\n  $\\mathcal{R}_1 = \\begin{pmatrix} 1 & 0 \\\\ -P_1 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -0.010336 & 1 \\end{pmatrix}$。\n- 平移 $\\mathcal{T}_{\\ell}$（通过透镜）：$d=t=8\\,\\mathrm{mm}$，$n=n_{\\ell}$。\n  $\\mathcal{T}_{\\ell} = \\begin{pmatrix} 1 & t/n_{\\ell} \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 8/1.5168 \\\\ 0 & 1 \\end{pmatrix}$。\n- 折射 $\\mathcal{R}_2$（透镜到空气）：$n_1=n_{\\ell}$，$n_2=n_0=1$，$R=R_2$。光焦度 $P_2 = \\frac{n_0 - n_{\\ell}}{R_2} = \\frac{1 - 1.5168}{-50} = 0.010336\\,\\mathrm{mm}^{-1}$。\n  $\\mathcal{R}_2 = \\begin{pmatrix} 1 & 0 \\\\ -P_2 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -0.010336 & 1 \\end{pmatrix}$。\n\n$M_{lens} = \\mathcal{R}_2 \\mathcal{T}_{\\ell} \\mathcal{R}_1 = \\begin{pmatrix} 1 & 0 \\\\ -P_2 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & t/n_{\\ell} \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ -P_1 & 1 \\end{pmatrix}$\n$M_{lens} = \\begin{pmatrix} 1 - P_1(t/n_{\\ell}) & t/n_{\\ell} \\\\ -(P_1+P_2) + P_1 P_2 (t/n_{\\ell}) & 1 - P_2(t/n_{\\ell}) \\end{pmatrix}$\n设 $P_1=P_2=P=0.010336\\,\\mathrm{mm}^{-1}$ 且 $t/n_{\\ell} \\approx 5.27426\\,\\mathrm{mm}$。\n$A_L = D_L = 1 - (0.010336)(5.27426) = 1 - 0.054512 = 0.945488$\n$B_L = 5.27426\\,\\mathrm{mm}$\n$C_L = -2P + P^2(t/n_{\\ell}) = -2(0.010336) + (0.010336)^2(5.27426) = -0.020672 + 0.000563 = -0.020109\\,\\mathrm{mm}^{-1}$\n$M_{lens} = \\begin{pmatrix} 0.945488 & 5.27426 \\\\ -0.020109 & 0.945488 \\end{pmatrix}$\n\n**气隙矩阵 ($M_{gap}$):**\n- 通过空气的平移 $\\mathcal{T}_g$：$d=g=20\\,\\mathrm{mm}$，$n=n_0=1$。\n$M_{gap} = \\mathcal{T}_g = \\begin{pmatrix} 1 & 20 \\\\ 0 & 1 \\end{pmatrix}$。\n\n**窗口矩阵 ($M_{window}$):**\n- 对于空气中厚度为 $w$、折射率为 $n_w$ 的平行平板（$R_1, R_2 \\to \\infty$），其表面的光焦度为零。矩阵为：\n$M_{window} = \\mathcal{R}_{w2}\\mathcal{T}_w\\mathcal{R}_{w1} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & w/n_w \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & w/n_w \\\\ 0 & 1 \\end{pmatrix}$\n$w/n_w = 2/1.5 = 4/3\\,\\mathrm{mm}$。\n$M_{window} = \\begin{pmatrix} 1 & 4/3 \\\\ 0 & 1 \\end{pmatrix}$。\n\n**总系统矩阵 ($M_{sys}$):**\n$M_{sys} = M_{window} \\cdot M_{gap} \\cdot M_{lens}$\n首先，我们计算 $M' = M_{gap} \\cdot M_{lens}$：\n$M' = \\begin{pmatrix} 1 & 20 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0.945488 & 5.27426 \\\\ -0.020109 & 0.945488 \\end{pmatrix} = \\begin{pmatrix} A_L+g C_L & B_L+g D_L \\\\ C_L & D_L \\end{pmatrix}$\n$A' = 0.945488 + 20(-0.020109) = 0.945488 - 0.40218 = 0.543308$\n$B' = 5.27426 + 20(0.945488) = 5.27426 + 18.90976 = 24.18402$\n$C' = -0.020109$\n$D' = 0.945488$\n$M' = \\begin{pmatrix} 0.543308 & 24.18402 \\\\ -0.020109 & 0.945488 \\end{pmatrix}$\n\n现在，我们计算 $M_{sys} = M_{window} \\cdot M'$：\n$M_{sys} = \\begin{pmatrix} 1 & 4/3 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0.543308 & 24.18402 \\\\ -0.020109 & 0.945488 \\end{pmatrix} = \\begin{pmatrix} A' + (4/3)C' & B' + (4/3)D' \\\\ C' & D' \\end{pmatrix}$\n$A_{sys} = 0.543308 + (4/3)(-0.020109) = 0.543308 - 0.026812 = 0.516496$\n$B_{sys} = 24.18402 + (4/3)(0.945488) = 24.18402 + 1.260651 = 25.444671$\n$C_{sys} = -0.020109$\n$D_{sys} = 0.945488$\n\n最终的系统矩阵是 $M_{sys} = \\begin{pmatrix} 0.516496 & 25.444671 \\\\ -0.020109 & 0.945488 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix}$。\n\n**4. 后焦距计算**\n准直输入光束由平行于光轴的光线组成，因此 $u_{in} = 0$，这意味着 $\\nu_{in} = n_0 u_{in} = 0$。在透镜前端的输入光线向量为 $\\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix}$。\n在窗口后端的输出光线向量由下式给出：\n$$ \\begin{pmatrix} y_{out} \\\\ \\nu_{out} \\end{pmatrix} = M_{sys} \\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix} \\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} A y_{in} \\\\ C y_{in} \\end{pmatrix} $$\n所以，在窗口的出射平面，光线的高度为 $y_{out} = A y_{in}$，光学方向余弦为 $\\nu_{out} = C y_{in}$。\n窗口后的介质是空气（$n_{out}=1$），所以光线角度为 $u_{out} = \\nu_{out}/n_{out} = \\nu_{out} = C y_{in}$。\n后焦点是这条光线与光轴（$y=0$）相交的点。设 $L$ 是从窗口出射面到该点的距离。窗口后光线路径的方程为 $y(z) = y_{out} + z u_{out}$。焦点在 $z=L$ 处，此时 $y(L)=0$。\n$0 = y_{out} + L u_{out}$\n$L = - \\frac{y_{out}}{u_{out}} = - \\frac{A y_{in}}{C y_{in}} = - \\frac{A}{C}$\n使用系统矩阵计算出的 $A$ 和 $C$ 值：\n$L = - \\frac{0.516496}{-0.020109} \\approx 25.6865\\,\\mathrm{mm}$\n\n题目要求将结果四舍五入至四位有效数字。\n$L \\approx 25.69\\,\\mathrm{mm}$。", "answer": "$$\n\\boxed{25.69}\n$$", "id": "3311406"}, {"introduction": "虽然矩阵方法功能强大，但其应用局限于近轴光线和分立元件系统。对于折射率连续变化的非均匀介质（如梯度折射率透镜），我们必须直接求解光线方程。本练习将深入探讨现代光线追踪的核心，通过比较一种标准的数值积分方法（四阶龙格-库塔法）与一种保持几何结构的辛积分方法，揭示哈密顿系统在长期积分稳定性和守恒律方面的重要特性。[@problem_id:3311401]", "problem": "您需要实现并比较两种数值积分器，用于在具有快速变化的折射率的非均匀、各向同性介质中进行几何光学光线传播的模拟。比较的重点是能量守恒和传播时间精度。该比较将在具有强梯度的渐变折射率（GRIN）透镜模型上进行。此任务基于从费马原理和程函近似推导出的哈密顿光线动力学，以纯数学术语进行描述，最终答案必须是按规定编写的完整、可运行的程序。\n\n从以下基本原理开始：\n\n- 在折射率为 $n(\\mathbf{x})$ 的非均匀、各向同性、静态介质中，光线遵循费马原理和程函近似，这允许使用哈密顿形式进行描述，其中包含正则位置 $\\mathbf{x} \\in \\mathbb{R}^2$、正则动量 $\\mathbf{p} \\in \\mathbb{R}^2$ 和哈密顿量\n$$\nH(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2}\\left(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x})\\right).\n$$\n- 相应的正则方程为\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\tfrac{1}{2}\\nabla n^2(\\mathbf{x}),\n$$\n其中 $\\tau$ 是一个路径参数，单位为米，使得光学传播时间 $T$ 满足\n$$\nT = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) \\, d\\tau,\n$$\n其中 $c_0$ 是真空中的光速。\n\n考虑一个具有以下剖面的二维 GRIN 透镜\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2,\n$$\n其中 $n_0 > 0$ 是常数，$\\alpha > 0$ 的单位是 $m^{-2}$。当 $\\alpha$ 很大时，该介质是强非均匀的，导致光线动力学方程是刚性的。正则方程变为\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\, \\mathbf{x}.\n$$\n\n任务：\n\n1. 为上述哈密顿系统实现两种时间步进方案：\n   - 应用于 $(\\mathbf{x}, \\mathbf{p})$ 一阶系统的经典显式 4 阶 Runge–Kutta 方法。\n   - 应用于可分离哈密顿量 $H(\\mathbf{x},\\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$ 的二阶辛分裂 (Störmer–Verlet) 方法，其中 $T(\\mathbf{p}) = \\tfrac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ 且 $V(\\mathbf{x}) = -\\tfrac{1}{2} n^2(\\mathbf{x})$。\n\n2. 对于下面的每个积分器和每个测试用例，将光线在 $\\tau$ 中传播整整一个完整的振荡周期（即，总参数长度为 $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$），使用固定的标称步长 $h$，但缩短最后一步以精确到达 $\\tau_{\\text{end}}$。\n\n3. 使用构造的初始条件以满足在 $\\tau = 0$ 时的几何光学约束 $H=0$：\n   - 设 $r_c = \\tfrac{n_0}{\\sqrt{\\alpha}}$。\n   - 设 $A = \\rho \\, r_c$，其中 $\\rho = 0.6$，并选择 $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$。\n   - 选择 $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$，这确保了 $H(\\mathbf{x}(0),\\mathbf{p}(0)) = 0$。\n\n4. 对于每个积分器和测试用例，评估：\n   - 在整个轨迹上的最大哈密顿量绝对漂移，\n     $$\n     \\Delta H_{\\max} = \\max_{k}\\left|H(\\mathbf{x}_k,\\mathbf{p}_k) - H(\\mathbf{x}_0,\\mathbf{p}_0)\\right|.\n     $$\n     将此结果报告为无量纲浮点数。\n   - 绝对传播时间误差，\n     $$\n     \\left|T_{\\text{num}} - T_{\\text{exact}}\\right|,\n     $$\n     其中 $T_{\\text{num}}$ 是通过对 $\\tfrac{1}{c_0}\\int_0^{\\tau_{\\text{end}}} n^2(\\mathbf{x}(\\tau)) \\, d\\tau$ 应用梯形法则计算得出的，而 $T_{\\text{exact}}$ 是从上述基本原理推导出的该 GRIN 介质中一个完整周期的解析值。将此误差以秒为单位表示为浮点数。\n\n5. 使用常数 $n_0 = 1.6$ (无量纲) 和 $c_0 = 299792458$ (单位为米/秒)。所有位置单位为 $m$，$\\alpha$ 单位为 $m^{-2}$，$\\tau$ 单位为 $m$。\n\n6. 测试套件。对于下面的每一对 $(\\alpha, h)$，运行两种积分器并计算所描述的两个度量。周期为 $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$ $m$。\n   - 用例 1：$\\alpha = 400$, $h = 0.05$。\n   - 用例 2：$\\alpha = 2500$, $h = 0.039$。\n   - 用例 3：$\\alpha = 25$, $h = 0.3$。\n   - 用例 4：$\\alpha = 10000$, $h = 0.015$。\n\n7. 输出格式。您的程序应生成单行输出，其中包含测试套件的结果，格式为方括号括起来的逗号分隔列表。每个测试用例应按以下顺序提供一个包含四个浮点数的列表\n   $$\n   \\left[\\Delta H_{\\max}^{\\mathrm{RK4}}, \\, \\left|T_{\\text{num}}^{\\mathrm{RK4}} - T_{\\text{exact}}\\right|, \\, \\Delta H_{\\max}^{\\mathrm{SV}}, \\, \\left|T_{\\text{num}}^{\\mathrm{SV}} - T_{\\text{exact}}\\right|\\right],\n   $$\n   其中上标表示所使用的积分器。传播时间误差必须以秒为单位，哈密顿量漂移是无量纲的。最终输出应如下所示\n   $$\n   \\left[\\,[a_1, b_1, c_1, d_1],[a_2, b_2, c_2, d_2],[a_3, b_3, c_3, d_3],[a_4, b_4, c_4, d_4]\\,\\right],\n   $$\n   其中每个 $a_i$, $b_i$, $c_i$, $d_i$ 都是 Python 格式的浮点数。\n\n如果在您的推导中出现任何角度，都必须以弧度为单位。所有传播时间值和误差都必须以秒表示。不允许使用百分号；任何小数部分都请使用十进制数表示。", "solution": "该问题是有效的，因为它在科学上基于哈密顿力学和几何光学，作为一个标准初值问题是适定的，并且是自洽的，包含了所有必需的常数、初始条件和完整指定的步骤。\n\n该问题要求实现并比较两种数值积分器，用于模拟二维渐变折射率（GRIN）介质中的光线传播。比较的重点是系统不变量（哈密顿量）的守恒性以及路径积分量（光学传播时间）的精度。\n\n控制物理过程由哈密顿光线动力学描述。对于折射率为 $n(\\mathbf{x})$ 的介质，光线位置 $\\mathbf{x}(\\tau) \\in \\mathbb{R}^2$ 和动量 $\\mathbf{p}(\\tau) \\in \\mathbb{R}^2$ 的正则方程源自哈密顿量 $H(\\mathbf{x},\\mathbf{p}) = \\frac{1}{2}(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x}))$。运动方程为：\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}\n$$\n$$\n\\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\frac{1}{2}\\nabla n^2(\\mathbf{x})\n$$\n这里，$\\tau$ 是一个路径参数。对于物理光线，哈密顿量是一个运动常数，其值被约束为零，即对于所有 $\\tau$ 都有 $H(\\mathbf{x}(\\tau), \\mathbf{p}(\\tau)) = 0$。这意味着沿着光线路径，光线动量矢量的大小等于当地的折射率：$\\lVert\\mathbf{p}(\\tau)\\rVert = n(\\mathbf{x}(\\tau))$。\n\n特定的介质是具有抛物线剖面的 GRIN 透镜：\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2\n$$\n其中 $n_0$ 和 $\\alpha$ 是正常数。对于此剖面，梯度项为 $\\frac{1}{2}\\nabla n^2(\\mathbf{x}) = \\frac{1}{2}\\nabla(n_0^2 - \\alpha(x^2+y^2)) = -\\alpha\\mathbf{x}$。常微分方程（ODE）组变为：\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\mathbf{x}\n$$\n这等价于二阶系统 $\\frac{d^2\\mathbf{x}}{d\\tau^2} + \\alpha\\mathbf{x} = 0$，它描述了一个角频率为 $\\omega = \\sqrt{\\alpha}$ 的简谐振子。\n\n在实现数值求解器之前，我们先推导精确的解析解和精确的传播时间 $T_{\\text{exact}}$，它将作为精度的基准。初始条件指定为 $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$ 和 $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$，其中 $A = \\rho r_c = \\rho n_0 / \\sqrt{\\alpha}$ 且 $\\rho = 0.6$。代入这些值可将初始动量简化为 $\\mathbf{p}(0)=[0, 0.8 n_0]^{\\mathsf{T}}$。谐振子方程的通解为 $\\mathbf{x}(\\tau) = \\mathbf{C}_1 \\cos(\\sqrt{\\alpha}\\tau) + \\mathbf{C}_2 \\sin(\\sqrt{\\alpha}\\tau)$。应用初始条件可得出精确轨迹：\n$$\n\\mathbf{x}(\\tau) = \\begin{bmatrix} A \\cos(\\sqrt{\\alpha}\\tau) \\\\ \\frac{\\sqrt{n_0^2 - \\alpha A^2}}{\\sqrt{\\alpha}} \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix} = \\begin{bmatrix} (0.6 n_0 / \\sqrt{\\alpha}) \\cos(\\sqrt{\\alpha}\\tau) \\\\ (0.8 n_0 / \\sqrt{\\alpha}) \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix}\n$$\n参数 $\\tau$ 的振荡周期为 $\\tau_p = 2\\pi/\\sqrt{\\alpha}$。问题要求正好对此周期进行积分，因此 $\\tau_{\\text{end}} = 2\\pi/\\sqrt{\\alpha}$。\n\n光学传播时间 $T$ 由 $T = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) d\\tau$ 给出。由于沿真实路径 $H=0$，我们有 $n^2(\\mathbf{x}(\\tau)) = \\lVert\\mathbf{p}(\\tau)\\rVert^2$。我们可以计算 $\\mathbf{p}(\\tau) = \\frac{d\\mathbf{x}}{d\\tau}$ 并对其范数的平方进行积分，但一个更简洁的推导方法来获得一个完整周期的精确传播时间 $T_{\\text{exact}}$ 如下：\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\int_{0}^{\\tau_{\\text{end}}} \\left( n_0^2 - \\alpha \\lVert \\mathbf{x}(\\tau) \\rVert^2 \\right) d\\tau\n$$\n我们需要计算 $\\lVert \\mathbf{x}(\\tau) \\rVert^2$ 的积分：\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\int_{0}^{2\\pi/\\sqrt{\\alpha}} \\left( A^2 \\cos^2(\\sqrt{\\alpha}\\tau) + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\sin^2(\\sqrt{\\alpha}\\tau) \\right) d\\tau\n$$\n使用定积分 $\\int_0^{2\\pi} \\cos^2\\theta d\\theta = \\pi$ 和 $\\int_0^{2\\pi} \\sin^2\\theta d\\theta = \\pi$，并进行代换 $\\theta = \\sqrt{\\alpha}\\tau$，我们得到：\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\frac{1}{\\sqrt{\\alpha}} \\left( A^2 \\pi + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\pi \\right) = \\frac{\\pi}{\\alpha\\sqrt{\\alpha}} \\left( \\alpha A^2 + n_0^2 - \\alpha A^2 \\right) = \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}}\n$$\n将此结果代回 $T_{\\text{exact}}$ 的表达式中：\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\left( n_0^2 \\tau_{\\text{end}} - \\alpha \\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau \\right) = \\frac{1}{c_0} \\left( n_0^2 \\frac{2\\pi}{\\sqrt{\\alpha}} - \\alpha \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}} \\right) = \\frac{n_0^2 \\pi}{c_0 \\sqrt{\\alpha}}\n$$\n这个简单的公式为比较提供了精确的传播时间。\n\n接下来，我们指定数值积分器。系统的状态是 4 维向量 $\\mathbf{y} = [\\mathbf{x}^{\\mathsf{T}}, \\mathbf{p}^{\\mathsf{T}}]^{\\mathsf{T}} = [x, y, p_x, p_y]^{\\mathsf{T}}$。ODE 系统为 $\\frac{d\\mathbf{y}}{d\\tau} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{f}(\\mathbf{y}) = [p_x, p_y, -\\alpha x, -\\alpha y]^{\\mathsf{T}}$。\n\n第一个积分器是经典的四阶 Runge-Kutta 方法 (RK4)。对于步长 $h$，从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的一步是：\n$$\n\\mathbf{k}_1 = h \\, \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_1/2)\n$$\n$$\n\\mathbf{k}_3 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_2/2)\n$$\n$$\n\\mathbf{k}_4 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_3)\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nRK4 是一种通用积分器，它并非设计用来保持哈密顿系统的几何结构，如辛性。\n\n第二个积分器是二阶 Störmer-Verlet (SV) 方法，这是一种辛积分器，非常适合形式为 $H(\\mathbf{x}, \\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$ 的可分离哈密顿量。在我们的例子中，$T(\\mathbf{p}) = \\frac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ 且 $V(\\mathbf{x}) = -\\frac{1}{2}n^2(\\mathbf{x}) = -\\frac{1}{2}(n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2)$。力为 $\\mathbf{F}(\\mathbf{x}) = -\\nabla V(\\mathbf{x}) = -\\alpha\\mathbf{x}$。对于大小为 $h$ 的一步，位置-Verlet 更新方案为：\n$$\n\\mathbf{p}_{n+1/2} = \\mathbf{p}_n + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_n) = \\mathbf{p}_n - \\frac{h}{2} \\alpha \\mathbf{x}_n\n$$\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + h \\mathbf{p}_{n+1/2}\n$$\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+1/2} + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_{n+1}) = \\mathbf{p}_{n+1/2} - \\frac{h}{2} \\alpha \\mathbf{x}_{n+1}\n$$\n该方法是时间可逆的，并保持辛二形式，这使得它对哈密顿系统具有出色的长期稳定性和有界的能量误差。\n\n对于每个积分器和测试用例，我们执行从 $\\tau=0$到 $\\tau_{\\text{end}}$ 的模拟。大小为 $h$ 的完整步数为 $N = \\lfloor\\tau_{\\text{end}}/h\\rfloor$。最后一步具有较小的步长 $h_{\\text{last}} = \\tau_{\\text{end}} - N h$，以便精确到达目标时间。轨迹 $(\\mathbf{x}_k, \\mathbf{p}_k)$ 在每个时间点 $\\tau_k$ 被存储。\n\n评估度量从存储的轨迹中计算得出。最大哈密顿量漂移计算如下：\n$$\n\\Delta H_{\\max} = \\max_{k} \\left| H(\\mathbf{x}_k, \\mathbf{p}_k) - H(\\mathbf{x}_0, \\mathbf{p}_0) \\right|\n$$\n由于初始条件的构造使得 $H(\\mathbf{x}_0, \\mathbf{p}_0) = 0$，这简化为 $\\Delta H_{\\max} = \\max_{k} | \\frac{1}{2}(\\lVert\\mathbf{p}_k\\rVert^2 - (n_0^2 - \\alpha\\lVert\\mathbf{x}_k\\rVert^2)) |$。\n\n数值传播时间 $T_{\\text{num}}$ 使用梯形法则对存储在时间 $\\tau_k$ 的 $n^2(\\mathbf{x}_k)$ 值进行计算：\n$$\nT_{\\text{num}} = \\frac{1}{c_0} \\sum_{k=0}^{M-1} \\frac{n^2(\\mathbf{x}_k) + n^2(\\mathbf{x}_{k+1})}{2} (\\tau_{k+1}-\\tau_k)\n$$\n其中 $M$ 是总步数。绝对误差则为 $|T_{\\text{num}} - T_{\\text{exact}}|$。\n\n实现将包括每个积分器步骤的函数、一个应用所选积分器并收集轨迹数据的主模拟循环，以及一个用于遍历测试用例并按规定格式化结果的顶层脚本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Global constants\n    n0 = 1.6  # Dimensionless\n    c0 = 299792458.0  # m/s\n    rho = 0.6  # Dimensionless\n\n    # Test suite: (alpha [m^-2], h [m])\n    test_cases = [\n        (400.0, 0.05),\n        (2500.0, 0.039),\n        (25.0, 0.3),\n        (10000.0, 0.015),\n    ]\n\n    results = []\n    for alpha, h in test_cases:\n        # Calculate case-specific parameters\n        sqrt_alpha = np.sqrt(alpha)\n        tau_end = 2.0 * np.pi / sqrt_alpha\n\n        # Initial conditions\n        A = rho * n0 / sqrt_alpha\n        x0 = np.array([A, 0.0])\n        p0 = np.array([0.0, 0.8 * n0])\n\n        # Exact travel time\n        t_exact = (n0**2 * np.pi) / (c0 * sqrt_alpha)\n\n        # Run RK4 simulation\n        h_drift_rk4, t_err_rk4 = run_simulation(\n            \"rk4\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        # Run Störmer-Verlet simulation\n        h_drift_sv, t_err_sv = run_simulation(\n            \"sv\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        results.append([h_drift_rk4, t_err_rk4, h_drift_sv, t_err_sv])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(integrator_name, alpha, h, tau_end, x0, p0, n0, c0, t_exact):\n    \"\"\"\n    Runs a single simulation for a given integrator and returns the metrics.\n    \"\"\"\n    # Initialize trajectory storage\n    tau = 0.0\n    x, p = x0.copy(), p0.copy()\n    \n    tau_vals = [tau]\n    x_traj = [x]\n    p_traj = [p]\n\n    # Integration loop\n    while tau  tau_end:\n        step_h = min(h, tau_end - tau)\n        if step_h  1e-12: # Avoid tiny final steps\n            break\n\n        if integrator_name == \"rk4\":\n            y = np.concatenate((x, p))\n            k1 = step_h * f_ode(y, alpha)\n            k2 = step_h * f_ode(y + 0.5 * k1, alpha)\n            k3 = step_h * f_ode(y + 0.5 * k2, alpha)\n            k4 = step_h * f_ode(y + k3, alpha)\n            y_next = y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            x, p = y_next[:2], y_next[2:]\n        elif integrator_name == \"sv\":\n            p_half = p - (step_h / 2.0) * alpha * x\n            x_next = x + step_h * p_half\n            p = p_half - (step_h / 2.0) * alpha * x_next\n            x = x_next\n        \n        tau += step_h\n        \n        tau_vals.append(tau)\n        x_traj.append(x)\n        p_traj.append(p)\n    \n    # Calculate metrics\n    x_traj_arr = np.array(x_traj)\n    p_traj_arr = np.array(p_traj)\n    tau_vals_arr = np.array(tau_vals)\n\n    # Hamiltonian drift\n    n_sq_vals = n0**2 - alpha * np.sum(x_traj_arr**2, axis=1)\n    p_sq_vals = np.sum(p_traj_arr**2, axis=1)\n    hamiltonian_vals = 0.5 * (p_sq_vals - n_sq_vals)\n    h_drift_max = np.max(np.abs(hamiltonian_vals)) # H(0)=0\n\n    # Travel time error\n    t_num = np.trapz(n_sq_vals, tau_vals_arr) / c0\n    t_error = np.abs(t_num - t_exact)\n\n    return h_drift_max, t_error\n\ndef f_ode(y, alpha):\n    \"\"\"\n    Derivative function for the 4D state vector y = [x, y, px, py].\n    \"\"\"\n    x, y_coord, px, py = y\n    return np.array([px, py, -alpha * x, -alpha * y_coord])\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3311401"}, {"introduction": "光线追踪不仅用于分析现有系统，更是一种强大的设计工具。这项高级实践将挑战一个典型的光学逆问题：设计一个透镜的表面形状，以在目标平面上形成预期的光强分布。本练习将介绍强大的伴随方法来高效地计算形状梯度，这是计算优化领域的基石技术，并通过与直观但计算成本高昂的有限差分法的对比来验证其准确性。[@problem_id:3311421]", "problem": "考虑一个由标量高度函数 $s(x;p)$ 描述的二维折射界面，其中 $x$ 是横向坐标，$p$ 是形状参数向量。一束准直光束从折射率为 $n_1$ 的均匀介质中进入，并沿 $y$ 轴负方向传播，在 $y=s(x;p)$ 处入射到折射界面，然后折射进入折射率为 $n_2$ 的第二个均匀介质中。折射后的光线随后传播到位于 $y=Y_t$ 的平面目标上，在目标上产生一个辐照度分布。任务是使用伴随光线追迹计算能量匹配目标函数的形状梯度，并通过有限差分验证梯度精度。\n\n基本原理：\n- 使用从 Fermat 原理导出的斯涅尔折射定律：对于单位入射方向 $\\mathbf{I}$ 和界面处的单位法线 $\\mathbf{N}$，单位折射方向 $\\mathbf{T}$ 遵循矢量形式 $\\mathbf{T}=\\eta\\,\\mathbf{I}+(\\eta\\,\\cos\\theta_i-\\cos\\theta_t)\\,\\mathbf{N}$，其中 $\\eta=n_1/n_2$，$\\cos\\theta_i=-\\mathbf{N}\\cdot\\mathbf{I}$，并且在无全内反射的情况下 $\\cos\\theta_t=\\sqrt{1-\\eta^2(1-\\cos^2\\theta_i)}$。\n- 使用几何光学中的局部能量守恒：目标上的辐照度可以通过一个平滑核函数近似狄拉克δ分布，将输入光线的能量传输到目标上来表示。\n\n模型和离散化：\n- 界面是一条旋转对称曲线，参数化为 $s(x;p)=p_0+p_2 x^2$，其中 $p_0$ 是单位为 $\\mathrm{m}$ 的轴向偏移，$p_2$ 是单位为 $\\mathrm{m}^{-1}$ 的二次曲率系数。\n- 入射光线在孔径 $x\\in[-W,W]$ 上均匀分布，光线位置为 $\\{x_i\\}_{i=1}^{N}$，输入辐照度密度为恒定的 $I_0$（单位 $\\mathrm{W/m}$）。每条光线携带的能量为 $w_i=I_0\\,\\Delta x$，其中 $\\Delta x=\\frac{2W}{N-1}$ 是单位为 $\\mathrm{m}$ 的光线采样间隔。\n- 在界面上的点 $x_i$ 处，单位法线由表面斜率 $s'(x_i;p)$ 构造为 $\\mathbf{N}=\\frac{1}{\\sqrt{1+(s')^2}}(-s',1)$，单位入射方向为 $\\mathbf{I}=(0,-1)$。折射方向 $\\mathbf{T}=(T_x,T_y)$ 由斯涅尔定律获得。\n- 从 $(x_i,s(x_i;p))$ 开始的折射光线与目标平面 $y=Y_t$ 相交于横向位置 $x_t(x_i;p)$，由 $x_t(x_i;p)=x_i+T_x\\,t_i$ 给出，其中 $t_i=\\frac{Y_t-s(x_i;p)}{T_y}$ 是传播参数。\n- 目标辐照度在指定范围内的均匀网格 $\\{x_k\\}_{k=1}^{M}$ 上计算，使用归一化高斯核 $\\varphi_\\sigma(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$（单位 $\\mathrm{m}^{-1}$）来近似将每条光线的能量传输到目标的狄拉克δ函数。数值辐照度为 $I_{\\text{num}}(x_k;p)=\\sum_{i=1}^{N}w_i\\,\\varphi_\\sigma(x_k-x_t(x_i;p))$（单位 $\\mathrm{W/m}$）。\n- 目标分布是一个归一化高斯函数 $I_{\\text{tgt}}(x_k)=\\frac{P}{\\sqrt{2\\pi}\\sigma_t}\\exp\\!\\left(-\\frac{x_k^2}{2\\sigma_t^2}\\right)$（单位 $\\mathrm{W/m}$），其中 $P=I_0\\cdot 2W$ 是总输入功率（单位 $\\mathrm{W}$），$\\sigma_t$ 是目标宽度（单位 $\\mathrm{m}$）。\n\n目标函数：\n- 定义最小二乘失配 $J(p)=\\frac{1}{2}\\sum_{k=1}^{M}\\left(I_{\\text{num}}(x_k;p)-I_{\\text{tgt}}(x_k)\\right)^2\\,\\Delta x_{\\text{tgt}}$，其中 $\\Delta x_{\\text{tgt}}$ 是目标网格间距（单位 $\\mathrm{m}$）。\n\n伴随光线追迹梯度：\n- 通过从目标平面到界面的反向累积，推导基于伴随法的形状梯度 $\\nabla_p J$。使用链式法则，结合核函数导数 $\\varphi'_\\sigma(x)=-\\frac{x}{\\sigma^2}\\varphi_\\sigma(x)$ 和 $x_t$ 相对于 $(p_0,p_2)$（通过 $s,s'$）的几何导数。\n- 每条光线所需的几何导数是 $\\frac{\\partial x_t}{\\partial s}$ 和 $\\frac{\\partial x_t}{\\partial s'}$，这些导数从折射运动学和与目标平面的相交关系中获得，然后通过 $\\frac{\\partial x_t}{\\partial p_0}=\\frac{\\partial x_t}{\\partial s}$ 和 $\\frac{\\partial x_t}{\\partial p_2}=x_i^2\\frac{\\partial x_t}{\\partial s}+2x_i\\frac{\\partial x_t}{\\partial s'}$ 组合它们。\n\n通过有限差分进行验证：\n- 通过将伴随梯度与中心有限差分近似进行比较来验证它，其中中心有限差分使用在 $\\mathrm{m}$ 中的小扰动 $\\delta_{p_0}$ 和在 $\\mathrm{m}^{-1}$ 中的小扰动 $\\delta_{p_2}$。\n\n单位和输出：\n- 所有距离必须以 $\\mathrm{m}$ 为单位处理，折射率为无量纲，辐照度单位为 $\\mathrm{W/m}$。角度不直接使用；方向由单位矢量表示。\n- 您的程序必须为每个指定的测试用例计算伴随梯度和有限差分梯度之间关于两个参数 $p_0$ 和 $p_2$ 的相对误差，定义为 $\\frac{\\left|\\text{grad}_{\\text{adj}}-\\text{grad}_{\\text{fd}}\\right|}{\\max\\left(\\left|\\text{grad}_{\\text{fd}}\\right|,10^{-12}\\right)}$，每个测试用例产生两个浮点数。\n- 最终输出必须是单行，包含一个 Python 列表的列表，其中每个内部列表对应一个测试用例，并按顺序 $[e_{p_0},e_{p_2}]$ 包含两个相对梯度误差的浮点数。\n\n测试套件：\n- 使用以下三个案例，它们共同考察了典型行为、近边界平坦表面条件以及具有更高折射率对比度的更强曲率。对于每个案例，指定 $(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})$：\n    - 案例1（通用聚焦）：$(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.5,0.02,201,-0.20,0.002,0.010,1.0,0.0,50.0,0.04,801,10^{-6},10^{-6})$。\n    - 案例2（平坦界面边缘情况）：$(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.2,0.02,201,-0.20,0.002,0.010,1.0,0.0,0.0,0.04,801,10^{-6},10^{-6})$。\n    - 案例3（强曲率，高对比度）：$(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.7,0.015,301,-0.15,0.001,0.008,1.0,0.0,300.0,0.03,601,10^{-6},10^{-6})$。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的 Python 列表的列表形式的结果，例如 $[\\,[e_{p_0}^{(1)},e_{p_2}^{(1)}],\\,[e_{p_0}^{(2)},e_{p_2}^{(2)}],\\,[e_{p_0}^{(3)},e_{p_2}^{(3)}]\\,]$，其中上标表示测试用例索引。\n\n要求：\n- 从第一性原理出发，使用斯涅尔定律实现正向光线追迹。\n- 实现从目标失配到表面参数的伴随梯度累积。\n- 实现中心有限差分以进行验证。\n- 通过避免全内反射并使用指定的有限差分小扰动来确保数值稳定性。", "solution": "用户提供了一个计算光学领域中有效且适定的问题。任务是使用伴随法计算最小二乘目标函数的形状梯度，并对照有限差分近似来验证其准确性。该光学系统包含一个由二次曲线轮廓定义的单一折射界面，该界面分隔了两种均匀介质。\n\n解决方案将分三个主要部分呈现：\n1.  **正向模型**：本节描述了将光线从光源追迹到目标平面并计算所得辐照度分布和目标函数的过程。\n2.  **伴随模型**：本节详细介绍了使用伴随状态法推导目标函数相对于形状参数的梯度。这涉及将灵敏度从目标平面反向传播到折射界面。\n3.  **验证**：本节概述了用于获得梯度数值近似的中心有限差分法，该近似值作为验证解析伴随梯度的基准。\n\n### 1. 正向模型：光线追迹和目标函数\n\n正向模型模拟了光传播和相互作用的物理过程。\n\n**1.1. 光线生成和界面相互作用**\n在输入孔径 $x \\in [-W, W]$ 上的均匀网格 $\\{x_i\\}$ 上初始化一组 $N$ 条光线。每条光线沿 $y$ 轴负方向传播，初始方向矢量为 $\\mathbf{I} = (0, -1)$，携带能量 $w = I_0 \\Delta x$，其中 $\\Delta x = \\frac{2W}{N-1}$。\n\n对于每条入射在横向位置 $x_i$ 的光线 $i$，它在点 $(x_i, s_i = s(x_i; p))$ 处与折射界面 $s(x; p) = p_0 + p_2 x^2$ 相交。在此点，表面斜率为 $s'_i = \\frac{\\partial s}{\\partial x}(x_i; p) = 2p_2 x_i$。指向第一介质（向上）的界面单位法向量由下式给出：\n$$\n\\mathbf{N}_i = \\frac{1}{\\sqrt{1 + (s'_i)^2}}(-s'_i, 1)\n$$\n入射方向为 $\\mathbf{I}=(0,-1)$。入射角 $\\theta_i$ 的余弦计算为 $\\cos\\theta_i = -\\mathbf{N}_i \\cdot \\mathbf{I} = N_{iy} = (1+(s'_i)^2)^{-1/2}$。\n\n**1.2. 通过斯涅尔定律折射**\n折射光线方向 $\\mathbf{T}_i = (T_{ix}, T_{iy})$ 由斯涅尔定律的矢量形式确定：\n$$\n\\mathbf{T}_i = \\eta \\mathbf{I} + (\\eta \\cos\\theta_i - \\cos\\theta_t) \\mathbf{N}_i\n$$\n其中 $\\eta = n_1/n_2$ 是相对折射率，$\\cos\\theta_t = \\sqrt{1 - \\eta^2(1 - \\cos^2\\theta_i)}$。由于所有测试用例都满足 $n_1  n_2$（光从光疏介质进入光密介质），因此不会发生全内反射。\n通过展开矢量方程，我们可以推导出折射方向 $x$ 分量 $T_{ix}$ 作为斜率 $s'_i$ 的显式表达式：\n$$\nT_{ix} = \\frac{-s'_i}{1+(s'_i)^2} \\left(\\eta - \\sqrt{1+(s'_i)^2(1-\\eta^2)}\\right)\n$$\n由于 $\\mathbf{T}_i$ 是单位矢量，所以 $T_{ix}^2 + T_{iy}^2 = 1$。物理情况要求光线朝目标平面传播，所以必须有 $T_{iy}  0$。因此，$T_{iy} = -\\sqrt{1 - T_{ix}^2}$。\n\n**1.3. 传播到目标和辐照度计算**\n从 $(x_i, s_i)$ 发出的折射光线传播到位于 $y=Y_t$ 的目标平面。传播参数 $t_i$ 可从光线路径的 $y$ 分量中找到：$Y_t = s_i + T_{iy} t_i$，这给出 $t_i = (Y_t - s_i) / T_{iy}$。光线在目标上的横向位置则为：\n$$\nx_{t,i} = x_i + T_{ix} t_i\n$$\n目标上的辐照度是在一个由 $M$ 个点组成的均匀网格 $\\{x_k\\}$ 上计算的。每条光线的能量使用一个归一化高斯核函数 $\\varphi_\\sigma(z)$ 分布到这个网格上，以近似狄拉克δ函数。每个网格点 $x_k$ 处的数值辐照度是所有 $N$ 条光线贡献的总和：\n$$\nI_{\\text{num}}(x_k; p) = \\sum_{i=1}^{N} w \\, \\varphi_\\sigma(x_k - x_{t,i}(p))\n$$\n\n**1.4. 目标函数**\n目标是使计算出的辐照度 $I_{\\text{num}}$ 与预设的目标辐照度 $I_{\\text{tgt}}$ 相匹配。失配程度由一个最小二乘目标函数 $J(p)$ 来量化：\n$$\nJ(p) = \\frac{1}{2} \\sum_{k=1}^{M} (I_{\\text{num}}(x_k; p) - I_{\\text{tgt}}(x_k))^2 \\Delta x_{\\text{tgt}}\n$$\n其中 $\\Delta x_{\\text{tgt}}$ 是目标网格点的间距。\n\n### 2. 伴随模型：梯度计算\n\n伴随法通过避免重复的正向模拟，提供了一种计算梯度 $\\nabla_p J$ 的高效方法。它依赖于链式法则将灵敏度从目标函数反向传播到设计参数。\n\n**2.1. 目标函数的梯度**\n$J$ 相对于参数 $p_j$（其中 $j \\in \\{0, 2\\}$）的梯度为：\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{k=1}^{M} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} \\Delta x_{\\text{tgt}}\n$$\n数值辐照度的导数为：\n$$\n\\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} = \\sum_{i=1}^{N} w \\, \\varphi'_\\sigma(x_k - x_{t,i}) \\left( -\\frac{\\partial x_{t,i}}{\\partial p_j} \\right)\n$$\n其中 $\\varphi'_\\sigma$ 是高斯核的导数。代入并重排求和项，我们得到：\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\left( -w \\sum_{k=1}^{M} \\Delta x_{\\text{tgt}} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\varphi'_\\sigma(x_k-x_{t,i}) \\right) \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\n括号中的项是伴随变量或灵敏度 $\\bar{x}_{t,i}$，它表示光线目标位置 $x_{t,i}$ 的微小变化对目标函数 $J$ 总变化的贡献。\n$$\n\\bar{x}_{t,i} = \\frac{\\partial J}{\\partial x_{t,i}}\n$$\n所以，总梯度是所有光线贡献的累加：\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\bar{x}_{t,i} \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\n\n**2.2. 几何灵敏度**\n最后一步是找到几何灵敏度 $\\frac{\\partial x_{t,i}}{\\partial p_j}$。我们使用局部表面高度 $s_i$ 和斜率 $s'_i$ 作为中间变量。根据链式法则：\n$$\n\\frac{\\partial x_{t,i}}{\\partial p_j} = \\frac{\\partial x_{t,i}}{\\partial s_i}\\frac{\\partial s_i}{\\partial p_j} + \\frac{\\partial x_{t,i}}{\\partial s'_i}\\frac{\\partial s'_i}{\\partial p_j}\n$$\n从 $s_i = p_0 + p_2 x_i^2$ 和 $s'_i = 2p_2 x_i$ 可得：\n*   $\\frac{\\partial s_i}{\\partial p_0} = 1$, $\\frac{\\partial s'_i}{\\partial p_0} = 0 \\implies \\frac{\\partial x_{t,i}}{\\partial p_0} = \\frac{\\partial x_{t,i}}{\\partial s_i}$\n*   $\\frac{\\partial s_i}{\\partial p_2} = x_i^2$, $\\frac{\\partial s'_i}{\\partial p_2} = 2x_i \\implies \\frac{\\partial x_{t,i}}{\\partial p_2} = x_i^2 \\frac{\\partial x_{t,i}}{\\partial s_i} + 2x_i \\frac{\\partial x_{t,i}}{\\partial s'_i}$\n\n目标位置 $x_t$ 相对于 $s$ 和 $s'$ 的导数可以从 $x_t = x + T_x(s') \\frac{Y_t - s}{T_y(s')}$ 推导得出：\n$$\n\\frac{\\partial x_t}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = -\\frac{T_x}{T_y}\n$$\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{\\partial}{\\partial s'}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = (Y_t-s)\\frac{\\partial}{\\partial s'}\\left(\\frac{T_x}{T_y}\\right) = t \\left( \\frac{\\partial T_x}{\\partial s'} - \\frac{T_x}{T_y}\\frac{\\partial T_y}{\\partial s'}\\right)\n$$\n利用属性 $T_x^2+T_y^2=1$，它意味着 $T_x \\frac{\\partial T_x}{\\partial s'} + T_y \\frac{\\partial T_y}{\\partial s'} = 0$，表达式简化为：\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{t}{T_y^2} \\frac{\\partial T_x}{\\partial s'}\n$$\n导数 $\\frac{\\partial T_x}{\\partial s'}$ 可通过对 $T_x(s')$ 的显式表达式进行微分来找到。\n\n有了这些分量，就可以组装和计算完整的伴随梯度。\n\n### 3. 通过有限差分进行验证\n\n为了验证所推导的伴随梯度的正确性，我们将其与使用中心有限差分公式获得的数值近似进行比较。对于每个参数 $p_j$，梯度近似为：\n$$\n\\frac{\\partial J}{\\partial p_j} \\approx \\frac{J(p + \\delta_j \\mathbf{e}_j) - J(p - \\delta_j \\mathbf{e}_j)}{2\\delta_j}\n$$\n其中 $\\mathbf{e}_j$ 是一个标准基向量，$\\delta_j$ 是一个小的扰动（例如，$10^{-6}$）。这需要对每个参数额外进行两次目标函数 $J$ 的求值。然后计算伴随梯度 $(\\text{grad}_{\\text{adj}})$ 和有限差分梯度 $(\\text{grad}_{\\text{fd}})$ 之间的相对误差：\n$$\n\\text{Error} = \\frac{|\\text{grad}_{\\text{adj}} - \\text{grad}_{\\text{fd}}|}{\\max(|\\text{grad}_{\\text{fd}}|, 10^{-12})}\n$$\n一个小的相对误差（通常接近机器精度或有限差分近似的精度）证实了复杂的伴随法实现的正确性。", "answer": "```python\nimport numpy as np\n\nclass SimulationParameters:\n    \"\"\"A helper class to hold all simulation parameters for a given case.\"\"\"\n    def __init__(self, n1, n2, W, N, Yt, sigma, sigma_t, I0, p0, p2, Xmax, M, delta_p0, delta_p2):\n        self.n1 = n1\n        self.n2 = n2\n        self.eta = n1 / n2\n        self.W = W\n        self.N = N\n        self.Yt = Yt\n        self.sigma = sigma\n        self.sigma_t = sigma_t\n        self.I0 = I0\n        self.p_vec = np.array([p0, p2], dtype=float)\n        self.Xmax = Xmax\n        self.M = M\n        self.delta_p = np.array([delta_p0, delta_p2], dtype=float)\n\n        # Derived parameters\n        self.x_in = np.linspace(-self.W, self.W, self.N)\n        self.dx_in = (2.0 * self.W) / (self.N - 1) if self.N > 1 else 0\n        self.ray_energy = self.I0 * self.dx_in\n        self.P_total = self.I0 * 2.0 * self.W\n        \n        self.x_target_grid = np.linspace(-self.Xmax, self.Xmax, self.M)\n        self.dx_target = (2.0 * self.Xmax) / (self.M - 1) if self.M > 1 else 0\n\ndef gaussian_kernel(x, sigma):\n    \"\"\"Computes the value of a Gaussian kernel.\"\"\"\n    return (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-x**2 / (2.0 * sigma**2))\n\ndef gaussian_kernel_deriv(x, sigma):\n    \"\"\"Computes the derivative of a Gaussian kernel.\"\"\"\n    return -x / sigma**2 * gaussian_kernel(x, sigma)\n\ndef compute_objective_and_intermediates(p_vec, params):\n    \"\"\"Performs forward ray tracing and computes the objective function J and intermediate values.\"\"\"\n    p0, p2 = p_vec\n    \n    x_i = params.x_in\n    s_i = p0 + p2 * x_i**2\n    s_prime_i = 2.0 * p2 * x_i\n\n    s_prime_sq = s_prime_i**2\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - params.eta**2)\n    \n    if np.any(term_in_sqrt  0):\n        raise ValueError(\"Total Internal Reflection encountered, problem is ill-defined for these parameters.\")\n    \n    sqrt_term = np.sqrt(term_in_sqrt)\n    Tx = (-s_prime_i * (params.eta - sqrt_term)) / (1.0 + s_prime_sq)\n    \n    Ty_sq = 1.0 - Tx**2\n    Ty_sq[Ty_sq  0] = 0.0\n    Ty = -np.sqrt(Ty_sq)\n\n    t_i = (params.Yt - s_i) / Ty\n    x_t = x_i + Tx * t_i\n\n    delta_x = params.x_target_grid[:, np.newaxis] - x_t[np.newaxis, :]\n    I_num = params.ray_energy * np.sum(gaussian_kernel(delta_x, params.sigma), axis=1)\n\n    I_tgt = (params.P_total / (np.sqrt(2.0 * np.pi) * params.sigma_t)) * \\\n            np.exp(-params.x_target_grid**2 / (2.0 * params.sigma_t**2))\n\n    J = 0.5 * np.sum((I_num - I_tgt)**2) * params.dx_target\n    \n    intermediates = {\n        'x_i': x_i, 's_prime_i': s_prime_i, 'Tx': Tx, 'Ty': Ty, 't_i': t_i,\n        'I_num': I_num, 'I_tgt': I_tgt, 'delta_x': delta_x\n    }\n    \n    return J, intermediates\n\ndef compute_adjoint_gradient(p_vec, params):\n    \"\"\"Computes the gradient of the objective function using the adjoint method.\"\"\"\n    _, intermediates = compute_objective_and_intermediates(p_vec, params)\n    \n    x_i = intermediates['x_i']\n    s_prime_i = intermediates['s_prime_i']\n    Tx, Ty, t_i = intermediates['Tx'], intermediates['Ty'], intermediates['t_i']\n    I_num, I_tgt, delta_x = intermediates['I_num'], intermediates['I_tgt'], intermediates['delta_x']\n    \n    mismatch = (I_num - I_tgt)[:, np.newaxis]\n    kernel_deriv = gaussian_kernel_deriv(delta_x, params.sigma)\n    x_t_bar = -params.ray_energy * params.dx_target * np.sum(mismatch * kernel_deriv, axis=0)\n    \n    dxt_ds = -Tx / Ty\n    \n    s_prime_sq = s_prime_i**2\n    eta_sq = params.eta**2\n    \n    f = -s_prime_i / (1.0 + s_prime_sq)\n    f_prime = (s_prime_sq - 1.0) / (1.0 + s_prime_sq)**2\n\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - eta_sq)\n    sqrt_term = np.sqrt(term_in_sqrt)\n    g = params.eta - sqrt_term\n    \n    g_prime = np.zeros_like(s_prime_i)\n    # Avoid division by zero when s_prime_i is 0\n    nonzero_s_prime = s_prime_i != 0\n    g_prime[nonzero_s_prime] = -s_prime_i[nonzero_s_prime] * (1.0 - eta_sq) / sqrt_term[nonzero_s_prime]\n\n    dTx_ds_prime = f_prime * g + f * g_prime\n    dxt_ds_prime = (t_i / Ty**2) * dTx_ds_prime\n    \n    grad_p0 = np.sum(x_t_bar * dxt_ds)\n    grad_p2 = np.sum(x_t_bar * (dxt_ds * x_i**2 + dxt_ds_prime * 2.0 * x_i))\n    \n    return np.array([grad_p0, grad_p2])\n\ndef compute_fd_gradient(p_vec, params):\n    \"\"\"Computes the gradient using central finite differences for verification.\"\"\"\n    grad_fd = np.zeros_like(p_vec, dtype=float)\n    for i in range(len(p_vec)):\n        p_plus = p_vec.copy()\n        p_minus = p_vec.copy()\n        p_plus[i] += params.delta_p[i]\n        p_minus[i] -= params.delta_p[i]\n        \n        J_plus, _ = compute_objective_and_intermediates(p_plus, params)\n        J_minus, _ = compute_objective_and_intermediates(p_minus, params)\n        \n        grad_fd[i] = (J_plus - J_minus) / (2.0 * params.delta_p[i])\n        \n    return grad_fd\n    \ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        (1.0, 1.5, 0.02, 201, -0.20, 0.002, 0.010, 1.0, 0.0, 50.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.2, 0.02, 201, -0.20, 0.002, 0.010, 1.0, 0.0, 0.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.7, 0.015, 301, -0.15, 0.001, 0.008, 1.0, 0.0, 300.0, 0.03, 601, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        params = SimulationParameters(*case)\n        \n        grad_adj = compute_adjoint_gradient(params.p_vec, params)\n        grad_fd = compute_fd_gradient(params.p_vec, params)\n        \n        denominator = np.maximum(np.abs(grad_fd), 1e-12)\n        rel_errors = np.abs(grad_adj - grad_fd) / denominator\n        \n        results.append(rel_errors.tolist())\n\n    print(str(results))\n\nsolve()\n```", "id": "3311421"}]}