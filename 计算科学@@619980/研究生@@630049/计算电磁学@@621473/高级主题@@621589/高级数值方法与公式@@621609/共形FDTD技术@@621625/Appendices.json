{"hands_on_practices": [{"introduction": "在将弯曲的材料边界整合到笛卡尔网格中之前，我们必须首先掌握如何用离散的几何量来描述这些边界。本练习将指导您从第一性原理出发，实现一个核心算法，用于计算由三角面元定义的任意表面与标准网格单元相交时的关键几何参数。掌握这项处理几何相交问题的技能，是实现任何高级共形FDTD方法的基础。[@problem_id:3294796]", "problem": "设计并实现一个完整的、可运行的程序，该程序为一个嵌入在单位笛卡尔单元中的三角化曲面计算共形时域有限差分（FDTD）技术所需的鲁棒几何量。您的程序必须从第一性原理实现一个算法，该算法在给定三维空间中的一组三角形的情况下，计算位于由 $[0,1] \\times [0,1] \\times [0,1]$ 定义的单位立方体内部的那部分曲面的以下量值：\n\n- 立方体内部的总切割表面积 $A_{\\mathrm{cut}}$。\n- 立方体内部切割表面的面积加权单位法向量 $\\mathbf{n}_{\\mathrm{cut}}$，其定义为对矢量面积分 $\\int_{S_{\\mathrm{cut}}} \\mathbf{\\hat{n}} \\, \\mathrm{d}S$ 进行归一化，其中 $S_{\\mathrm{cut}}$ 是单位立方体内部的三角化曲面部分，$\\mathbf{\\hat{n}}$ 是与三角形方向一致的曲面单位法向量。\n- 对于单位立方体的 $12$ 条边中的每一条，计算边长分数 $f_e \\in [0,1]$，其值等于该立方体边与切割表面区域交集的一维总测度除以总边长。此处，立方体边（一条线段）与二维切割表面之间的“交集长度”为零，除非该边位于某个三角形的平面内且与该三角形的内部重叠；在这种共面的情况下，该交集可以是一个长度在 $0$ 和 $1$ 之间的非平凡线段。\n\n您的推导和实现必须从时域有限差分法底层的麦克斯韦方程组的积分形式出发，其中离散更新依赖于面通量和边环量。因此，切割表面积和面积加权法向量源于离散斯托克斯定理和散度定理中的几何量，而边长分数源于当曲面与网格边重合时网格边上的度量项。除了平面、凸多面体裁剪、通过矢量面积计算多边形面积以及线段对半平面裁剪的标准定义外，您不能假定任何快捷公式。\n\n算法要求：\n\n1. 曲面裁剪。每个三角形都必须通过与 $6$ 个轴对齐平面 $x \\ge 0$、$x \\le 1$、$y \\ge 0$、$y \\le 1$、$z \\ge 0$、$z \\le 1$ 进行顺序半空间裁剪，从而鲁棒地裁剪到单位立方体内。使用一个带有容差 $\\varepsilon$ 的数值鲁棒的内外测试，并通过在平面谓词值中进行线性插值来计算交点，以避免灾难性抵消。\n\n2. 面积和法向量累加。对于每个裁剪后的多边形（一个三角形或其凸多边形子集），计算其矢量面积 $\\mathbf{A} = \\frac{1}{2} \\sum_{i} \\mathbf{r}_i \\times \\mathbf{r}_{i+1}$，其中 $\\mathbf{r}_i$ 是按循环顺序列出的多边形顶点。累加所有三角形的 $\\mathbf{A}$ 以获得 $\\mathbf{A}_{\\mathrm{tot}}$，然后计算 $A_{\\mathrm{cut}} = \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$ 和 $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{A}_{\\mathrm{tot}} / \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$（如果 $\\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert > \\varepsilon$），否则设置 $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{0}$。\n\n3. 边长分数。设 $12$ 条立方体边为以下线段：\n   - $e_0 : (0,0,0) \\rightarrow (1,0,0)$,\n   - $e_1 : (0,0,0) \\rightarrow (0,1,0)$,\n   - $e_2 : (0,0,0) \\rightarrow (0,0,1)$,\n   - $e_3 : (1,0,0) \\rightarrow (1,1,0)$,\n   - $e_4 : (1,0,0) \\rightarrow (1,0,1)$,\n   - $e_5 : (0,1,0) \\rightarrow (1,1,0)$,\n   - $e_6 : (0,1,0) \\rightarrow (0,1,1)$,\n   - $e_7 : (0,0,1) \\rightarrow (1,0,1)$,\n   - $e_8 : (0,0,1) \\rightarrow (0,1,1)$,\n   - $e_9 : (1,1,0) \\rightarrow (1,1,1)$,\n   - $e_{10} : (1,0,1) \\rightarrow (1,1,1)$,\n   - $e_{11} : (0,1,1) \\rightarrow (1,1,1)$。\n   对于每个裁剪后在立方体内形成非空多边形的三角形，计算其平面单位法向量 $\\mathbf{\\hat{n}}_{\\triangle}$，并使用距离容差 $\\varepsilon$ 测试每条边 $e$ 是否与该平面共面。如果一条边是共面的，则将裁剪后的多边形和该边都投影到一个张成该三角形平面的二维基底 $\\{\\mathbf{u}, \\mathbf{v}\\}$ 上，并通过将线段裁剪到多边形的半平面来计算位于投影多边形内部的边线段长度。通过总边长（对于单位立方体为 $1$）进行归一化，以获得该三角形对 $f_e$ 的贡献。如果多个三角形对同一条边有贡献，则在求和长度之前，取沿该边覆盖的参数区间的并集，以避免重复计算。\n\n4. 针对退化的数值鲁棒性。您的实现必须明确防范：\n   - 面积接近零的退化三角形。\n   - 三角形与裁剪平面之间近乎平行或近乎共面的相交情况。\n   - 立方体边与三角形平面近乎共面导致分类模糊的情况。在内外测试和区间合并中使用一致的容差，并确保半平面法向量与多边形顶点顺序保持一致。\n\n所有量均为无量纲。您的程序必须将所有报告的浮点值四舍五入到恰好 $10$ 位小数。\n\n测试套件和要求输出：\n\n实现上述算法，并在以下四个测试用例上进行评估。每个测试用例是一个三角形列表，每个三角形由三个顶点 $(x,y,z)$ 给出：\n\n- 测试用例 1（一般斜向相交）：\n  - 单个三角形，顶点为 $(-0.2, 0.2, 0.2)$、$(1.2, 0.8, 0.2)$、$(0.5, 0.5, 1.2)$。\n\n- 测试用例 2（与一个面共面，产生非零边长分数）：\n  - 单个三角形，顶点为 $(0.0, 0.0, 0.0)$、$(1.0, 0.0, 0.0)$、$(0.0, 1.0, 0.0)$。\n\n- 测试用例 3（近切相交，对小偏移的鲁棒性）：\n  - 单个三角形，顶点为 $(-0.1, 0.5, 10^{-12})$、$(1.1, 0.5, -10^{-12})$、$(0.5, -0.1, 10^{-12})$。\n\n- 测试用例 4（面积为零的退化三角形）：\n  - 单个三角形，顶点为 $(0.2, 0.2, 0.2)$、$(0.6, 0.6, 0.6)$、$(1.0, 1.0, 1.0)$。\n\n对于每个测试用例，您的程序必须输出一个列表，其中包含：\n- 总切割表面积 $A_{\\mathrm{cut}}$，\n- 面积加权单位法向量的各分量 $\\mathbf{n}_{\\mathrm{cut}} = (n_x,n_y,n_z)$，\n- $12$ 个边长分数 $[f_0, f_1, \\dots, f_{11}]$，按上述边顺序排列。\n\n最终输出格式：\n\n您的程序应生成单行输出，包含所有测试用例的结果，形式为逗号分隔的列表的列表，其中每个内部列表按 $[A_{\\mathrm{cut}}, n_x, n_y, n_z, f_0, f_1, \\dots, f_{11}]$ 的顺序排列。所有数字必须四舍五入到恰好 $10$ 位小数。例如，一个有效的外层结构类似于“[[...],[...],[...],[...]]”，其中每个“...”由该测试用例的 $16$ 个数字替换。", "solution": "该问题要求设计并实现一个算法，用于计算三角化曲面与单位立方体相交时的特定几何量。这些量——切割表面积 $A_{\\mathrm{cut}}$、面积加权单位法向量 $\\mathbf{n}_{\\mathrm{cut}}$ 和立方体边长分数 $f_e$——是高等计算电磁学中的基本量，尤其是在共形时域有限差分（FDTD）方法中。在FDTD中，麦克斯韦方程组在网格上被离散化。共形技术在被材料边界（如三角化曲面）穿过的网格单元处调整标准算法。用于分别更新磁场和电场的斯托克斯定理和散度定理的离散形式，需要关于曲面如何穿过网格单元的几何信息。切割表面积 $A_{\\mathrm{cut}}$ 及其面积加权法向量 $\\mathbf{n}_{\\mathrm{cut}}$ 用于计算表面平均场或通量，而边长分数 $f_e$ 为沿部分被曲面覆盖的网格边的线积分提供修正的度量项。\n\n该算法从第一性原理出发，单独处理每个三角形并累加结果。对于由多个三角形组成的曲面，核心步骤如下：\n1.  遍历每个输入的三角形。\n2.  对于每个三角形，将其鲁棒地裁剪到单位立方体 $[0,1]^3$ 的六个面。这将产生一个凸多边形（如果三角形完全在立方体外部，则为空）。\n3.  计算生成的裁剪后多边形的矢量面积。在所有三角形上累加这些矢量面积。\n4.  对于每个三角形及其生成的裁剪后多边形，确定该三角形的平面是否与 $12$ 个单位立方体边中的任何一个共面。如果是，则计算立方体边与裁剪后多边形之间的交集长度。\n5.  处理完所有三角形后，最终确定全局量：从累加的矢量面积计算总切割面积和法向量，并对每个立方体边，合并任何重叠的相交区间并求和其长度，以找到总边长分数。\n\n一个数值容差，记为 $\\varepsilon$，用于所有浮点比较，以确保对几何退化和浮点不精确性的鲁棒性。\n\n**步骤 1：曲面裁剪**\n每个三角形被视为一个凸多边形，并相对于单位立方体进行裁剪。立方体是一个由六个半空间交集定义的凸体：$x \\ge 0$、$x \\le 1$、$y \\ge 0$、$y \\le 1$、$z \\ge 0$ 和 $z \\le 1$。我们采用Sutherland-Hodgman算法，该算法将一个凸多边形按顺序裁剪到一系列凸半空间，每次裁剪操作都产生一个新的凸多边形，作为下一次裁剪的输入。\n\n对于由点 $\\mathbf{p}_0$ 和向内的法向量 $\\mathbf{n}$ 定义的单个半空间，我们处理输入多边形的每条边，从顶点 $\\mathbf{S}$ 到 $\\mathbf{E}$：\n- 如果一个点 $\\mathbf{v}$ 的符号距离 $d(\\mathbf{v}) = (\\mathbf{v} - \\mathbf{p}_0) \\cdot \\mathbf{n} \\ge -\\varepsilon$，则该点在半空间“内部”。\n- 如果 $\\mathbf{S}$ 和 $\\mathbf{E}$ 都在内部，则将顶点 $\\mathbf{E}$ 添加到输出多边形。\n- 如果 $\\mathbf{S}$ 在内部而 $\\mathbf{E}$ 在外部，则计算交点 $\\mathbf{I}$ 并将其添加到输出。\n- 如果 $\\mathbf{S}$ 和 $\\mathbf{E}$ 都在外部，则不添加任何内容。\n- 如果 $\\mathbf{S}$ 在外部而 $\\mathbf{E}$ 在内部，则将交点 $\\mathbf{I}$ 和顶点 $\\mathbf{E}$ 添加到输出。\n\n线段 $\\mathbf{SE}$ 的交点 $\\mathbf{I}$ 是通过基于端点符号距离的线性插值找到的。交点沿边 $\\mathbf{L}(t) = \\mathbf{S} + t(\\mathbf{E}-\\mathbf{S})$ 的参数位置 $t \\in [0,1]$ 由 $t = d(\\mathbf{S}) / (d(\\mathbf{S}) - d(\\mathbf{E}))$ 给出。交点即为 $\\mathbf{I} = \\mathbf{S} + t(\\mathbf{E}-\\mathbf{S})$。这种方法在数值上是稳定的，特别是当边几乎平行于裁剪平面时（即 $|d(\\mathbf{S}) - d(\\mathbf{E})|$ 很小）。一个接近零的分母 $(\\mathbf{E}-\\mathbf{S}) \\cdot \\mathbf{n}$ 表示平行，这种情况通过检查任一端点是否在内部来处理。\n\n**步骤 2：面积和法向量累加**\n对于上述过程产生的每个裁剪后的多边形，我们计算其矢量面积 $\\mathbf{A}_{\\mathrm{poly}}$。对于具有顺序顶点 $\\mathbf{r}_0, \\mathbf{r}_1, \\dots, \\mathbf{r}_{N-1}$ 的多边形，矢量面积由以下公式给出：\n$$ \\mathbf{A}_{\\mathrm{poly}} = \\frac{1}{2} \\sum_{i=0}^{N-1} \\mathbf{r}_i \\times \\mathbf{r}_{i+1} $$\n其中 $\\mathbf{r}_N = \\mathbf{r}_0$。该公式提供了一个矢量，其方向垂直于多边形，其大小为其面积。方向与顶点顺序一致（右手定则）。\n\n切割表面的总矢量面积 $\\mathbf{A}_{\\mathrm{tot}}$ 是所有裁剪后多边形矢量面积的总和：\n$$ \\mathbf{A}_{\\mathrm{tot}} = \\sum_{\\text{三角形}} \\mathbf{A}_{\\mathrm{poly}} $$\n从 $\\mathbf{A}_{\\mathrm{tot}}$ 计算所需的全局量：\n- 总切割表面积：$A_{\\mathrm{cut}} = \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$。\n- 面积加权单位法向量：$\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{A}_{\\mathrm{tot}} / \\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert$，如果 $\\lVert \\mathbf{A}_{\\mathrm{tot}} \\rVert > \\varepsilon$。否则，如果总面积可忽略不计，则 $\\mathbf{n}_{\\mathrm{cut}} = \\mathbf{0}$。\n\n**步骤 3：边长分数**\n边长分数 $f_e$ 量化了立方体边 $e$ 中位于曲面内部的部分。这仅在立方体边与某个与立方体有非空交集的三角形共面时才为非零。\n\n对于每个产生非空裁剪多边形的原始三角形：\n1.  **共面性测试**：三角形的平面由其一个顶点（例如 $\\mathbf{v}_0$）及其单位法向量 $\\hat{\\mathbf{n}}_{\\triangle}$ 定义。一条从 $\\mathbf{P}_{\\text{start}}$ 到 $\\mathbf{P}_{\\text{end}}$ 的立方体边 $e$ 被认为是共面的，如果其两个端点在容差 $\\varepsilon$ 内都位于三角形平面上。即， $|(\\mathbf{P}_{\\text{start}} - \\mathbf{v}_0) \\cdot \\hat{\\mathbf{n}}_{\\triangle}|  \\varepsilon$ 并且 $|(\\mathbf{P}_{\\text{end}} - \\mathbf{v}_0) \\cdot \\hat{\\mathbf{n}}_{\\triangle}|  \\varepsilon$。\n\n2.  **交集计算**：如果一条边 $e$ 是共面的，我们必须找到该边段与相应的 `clipped_poly` 之间的交集长度。这是一个针对凸多边形的3D线段裁剪问题，Cyrus-Beck算法对此很适用。设边被参数化为 $\\mathbf{L}(t) = \\mathbf{P}_{\\text{start}} + t(\\mathbf{P}_{\\text{end}} - \\mathbf{P}_{\\text{start}})$，其中 $t \\in [0, 1]$。我们维护一个区间 $[t_{\\text{in}}, t_{\\text{out}}]$，初始化为 $[0, 1]$。对于 `clipped_poly` 的每条边，我们计算其在平面内的向外法向量，并找到与直线 $\\mathbf{L}(t)$ 的交点参数 $t$。根据直线是进入还是离开多边形的半空间，我们更新 $t_{\\text{in}}$ 或 $t_{\\text{out}}$。如果在任何时候 $t_{\\text{in}} > t_{\\text{out}}$，则交集为空。最终的区间 $[t_{\\text{in}}, t_{\\text{out}}]$ 代表了在多边形内部的立方体边部分（以参数坐标表示）。\n\n3.  **区间累加与合并**：单个立方体边可能与多个三角形共面。为避免重复计算，我们为 $12$ 个立方体边中的每一个存储计算出的交集区间 $[t_{\\text{in}}, t_{\\text{out}}]$。在处理完所有三角形后，对于每条边，我们将收集到的可能重叠的区间列表合并为一组不相交的区间。这通过按区间的起始点对其进行排序并迭代地组合任何重叠的区间来完成。这些合并后的不相交区间的总长度给出了总交集长度。由于立方体边的长度为单位长度，这个总长度就是边长分数 $f_e$。\n\n**步骤 4：数值鲁棒性**\n退化情况被明确处理。具有接近零面积的三角形（共线顶点）通过检查其边向量叉乘的模是否低于 $\\varepsilon^2$ 来识别。这样的三角形被忽略，因为它们对面积或体积没有贡献。所有的几何测试——内外检查、共面性以及线段裁剪中的平行性——都使用容差 $\\varepsilon$ 进行，以防止由于浮点表示错误而导致的失败。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    # Define a consistent tolerance for floating-point comparisons.\n    EPS = 1e-12\n\n    def sutherland_hodgman_clip(polygon, clip_planes):\n        \"\"\"\n        Clips a convex polygon against a list of convex half-spaces (planes).\n        \"\"\"\n        clipped_polygon = list(polygon)\n        for plane_point, plane_normal in clip_planes:\n            input_list = list(clipped_polygon)\n            clipped_polygon.clear()\n            if not input_list:\n                return []\n\n            s = input_list[-1]\n            for e in input_list:\n                s_dist = np.dot(s - plane_point, plane_normal)\n                e_dist = np.dot(e - plane_point, plane_normal)\n                \n                s_inside = s_dist >= -EPS\n                e_inside = e_dist >= -EPS\n\n                if s_inside and e_inside:\n                    clipped_polygon.append(e)\n                elif s_inside and not e_inside:\n                    # S is in, E is out: intersection\n                    den = s_dist - e_dist\n                    if abs(den) > EPS:\n                        t = s_dist / den\n                        intersection = s + t * (e - s)\n                        clipped_polygon.append(intersection)\n                elif not s_inside and e_inside:\n                    # S is out, E is in: intersection then E\n                    den = s_dist - e_dist\n                    if abs(den) > EPS:\n                        t = s_dist / den\n                        intersection = s + t * (e - s)\n                        clipped_polygon.append(intersection)\n                    clipped_polygon.append(e)\n                # Both S and E are out: do nothing\n                s = e\n        return clipped_polygon\n\n    def get_vector_area(polygon):\n        \"\"\"\n        Computes the vector area of a 3D polygon.\n        \"\"\"\n        if len(polygon)  3:\n            return np.array([0.0, 0.0, 0.0])\n        \n        total_area = np.array([0.0, 0.0, 0.0])\n        for i in range(len(polygon)):\n            v1 = polygon[i]\n            v2 = polygon[(i + 1) % len(polygon)]\n            total_area += np.cross(v1, v2)\n        \n        return total_area / 2.0\n\n    def merge_intervals(intervals):\n        \"\"\"\n        Merges a list of overlapping intervals.\n        \"\"\"\n        if not intervals:\n            return []\n        \n        intervals.sort(key=lambda x: x[0])\n        \n        merged = [intervals[0]]\n        for current_start, current_end in intervals[1:]:\n            last_start, last_end = merged[-1]\n            \n            # Use tolerance for merging\n            if current_start = last_end + EPS:\n                merged[-1] = (last_start, max(last_end, current_end))\n            else:\n                merged.append((current_start, current_end))\n                \n        return merged\n\n    def compute_edge_fractions(triangle, clipped_poly, edge_definitions, edge_intervals):\n        \"\"\"\n        Computes intersection of a triangle's plane with cube edges and updates intervals.\n        \"\"\"\n        v0, v1, v2 = triangle\n        \n        tri_normal_vec = np.cross(v1 - v0, v2 - v0)\n        norm_mag = np.linalg.norm(tri_normal_vec)\n        if norm_mag  EPS:\n            return # Degenerate triangle\n\n        tri_normal = tri_normal_vec / norm_mag\n\n        for i, (p_start, p_end) in enumerate(edge_definitions):\n            # 1. Coplanarity Test\n            dist_start = abs(np.dot(p_start - v0, tri_normal))\n            dist_end = abs(np.dot(p_end - v0, tri_normal))\n\n            if dist_start  EPS and dist_end  EPS:\n                # 2. Intersection Calculation (Cyrus-Beck)\n                edge_dir = p_end - p_start\n                t_in, t_out = 0.0, 1.0\n\n                for j in range(len(clipped_poly)):\n                    poly_v1 = clipped_poly[j]\n                    poly_v2 = clipped_poly[(j + 1) % len(clipped_poly)]\n                    poly_edge_dir = poly_v2 - poly_v1\n                    \n                    # Outward normal in the triangle plane\n                    outward_normal = np.cross(poly_edge_dir, tri_normal)\n                    \n                    numerator = np.dot(poly_v1 - p_start, outward_normal)\n                    denominator = np.dot(edge_dir, outward_normal)\n\n                    if abs(denominator)  EPS: # Line is parallel to polygon edge\n                        if numerator > 0: # Line is outside this half-plane\n                            t_in = 1.0; t_out = 0.0 # Empty intersection\n                            break\n                        # Otherwise, inside, continue\n                    else:\n                        t = numerator / denominator\n                        if denominator > 0: # Exiting\n                            t_out = min(t_out, t)\n                        else: # Entering\n                            t_in = max(t_in, t)\n                \n                if t_in  t_out:\n                    edge_intervals[i].append((t_in, t_out))\n\n    # Cube definition\n    cube_clip_planes = [\n        (np.array([0, 0, 0]), np.array([1, 0, 0])),  # x >= 0\n        (np.array([1, 0, 0]), np.array([-1, 0, 0])), # x = 1\n        (np.array([0, 0, 0]), np.array([0, 1, 0])),  # y >= 0\n        (np.array([0, 1, 0]), np.array([0, -1, 0])), # y = 1\n        (np.array([0, 0, 0]), np.array([0, 0, 1])),  # z >= 0\n        (np.array([0, 0, 1]), np.array([0, 0, -1])), # z = 1\n    ]\n\n    edge_defs = [\n        (np.array([0,0,0]), np.array([1,0,0])), # e0\n        (np.array([0,0,0]), np.array([0,1,0])), # e1\n        (np.array([0,0,0]), np.array([0,0,1])), # e2\n        (np.array([1,0,0]), np.array([1,1,0])), # e3\n        (np.array([1,0,0]), np.array([1,0,1])), # e4\n        (np.array([0,1,0]), np.array([1,1,0])), # e5\n        (np.array([0,1,0]), np.array([0,1,1])), # e6\n        (np.array([0,0,1]), np.array([1,0,1])), # e7\n        (np.array([0,0,1]), np.array([0,1,1])), # e8\n        (np.array([1,1,0]), np.array([1,1,1])), # e9\n        (np.array([1,0,1]), np.array([1,1,1])), # e10\n        (np.array([0,1,1]), np.array([1,1,1])), # e11\n    ]\n\n    # Test cases\n    test_cases = [\n        # Test case 1\n        [[np.array([-0.2, 0.2, 0.2]), np.array([1.2, 0.8, 0.2]), np.array([0.5, 0.5, 1.2])]],\n        # Test case 2\n        [[np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])]],\n        # Test case 3\n        [[np.array([-0.1, 0.5, 1e-12]), np.array([1.1, 0.5, -1e-12]), np.array([0.5, -0.1, 1e-12])]],\n        # Test case 4\n        [[np.array([0.2, 0.2, 0.2]), np.array([0.6, 0.6, 0.6]), np.array([1.0, 1.0, 1.0])]],\n    ]\n    \n    final_results = []\n    \n    for triangles in test_cases:\n        total_vector_area = np.array([0.0, 0.0, 0.0])\n        edge_intervals = [[] for _ in range(12)]\n\n        for triangle in triangles:\n            # Check for degenerate triangle before clipping\n            v0, v1, v2 = triangle\n            if np.linalg.norm(np.cross(v1 - v0, v2 - v0))  EPS**2:\n                continue\n\n            clipped_polygon = sutherland_hodgman_clip(triangle, cube_clip_planes)\n            \n            if len(clipped_polygon) >= 3:\n                poly_area = get_vector_area(clipped_polygon)\n                total_vector_area += poly_area\n                compute_edge_fractions(triangle, clipped_polygon, edge_defs, edge_intervals)\n        \n        # Finalize area and normal\n        A_cut = np.linalg.norm(total_vector_area)\n        n_cut = np.array([0.0, 0.0, 0.0])\n        if A_cut > EPS:\n            n_cut = total_vector_area / A_cut\n            \n        # Finalize edge fractions\n        f_edges = []\n        for i in range(12):\n            merged = merge_intervals(edge_intervals[i])\n            total_length = sum(end - start for start, end in merged)\n            f_edges.append(total_length)\n            \n        # Format results\n        case_result = [A_cut, n_cut[0], n_cut[1], n_cut[2]] + f_edges\n        rounded_result = [f\"{x:.10f}\" for x in case_result]\n        final_results.append(rounded_result)\n\n    # Format output string\n    output_str = \"[\"\n    for i, res in enumerate(final_results):\n        output_str += f\"[{','.join(res)}]\"\n        if i  len(final_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3294796"}, {"introduction": "获得了描述边界的几何信息后，下一步就是将其应用于FDTD更新方程中。本练习将引导您为一个封闭的完美电导体（PEC）谐振腔实现一个二维共形FDTD模拟，通过直接使用几何面积和边长比例来修正磁场更新。通过监测系统的离散能量随时间是否守恒，您将能亲手验证共形格式是否引入了非物理损耗，这是评估数值方案稳定性和准确性的关键一步。[@problem_id:3294784]", "problem": "考虑一个由光滑理想电导体 (PEC) 边界包围的单连通真空区域中，麦克斯韦方程组的二维平面外方向横电波 (TE$_z$) 配置。设PEC边界为以原点为中心、半径为 $R$ 的圆。真空区域为开圆盘 $\\{(x,y): x^2 + y^2  R^2\\}$。场为 $\\mathbf{E} = (E_x, E_y, 0)$ 和 $\\mathbf{H} = (0, 0, H_z)$，其中 $\\varepsilon_0$ 为真空介电常数，$\\mu_0$ 为真空磁导率。光速为 $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$。此极化下的麦克斯韦方程组连续形式为\n$$\n\\frac{\\partial}{\\partial t}\\left(\\mu_0 H_z \\right) = -\\left(\\nabla \\times \\mathbf{E}\\right)_z,\\quad\n\\frac{\\partial}{\\partial t}\\left(\\varepsilon_0 E_x\\right) = \\left(\\nabla \\times \\mathbf{H}\\right)_x,\\quad\n\\frac{\\partial}{\\partial t}\\left(\\varepsilon_0 E_y\\right) = \\left(\\nabla \\times \\mathbf{H}\\right)_y,\n$$\n以及切向电场在圆形边界上为零的PEC边界条件。\n\n您的任务是实现一种共形时域有限差分 (FDTD) 格式，该格式通过使用几何分数修正磁场更新来贴合圆形PEC的几何形状，同时保持电场更新为标准的Yee形式，但对完全位于真空区域外的边强制场为零。具体来说，使用一个均匀的笛卡尔Yee网格，覆盖一个方形区域 $[-L_x/2,L_x/2]\\times[-L_y/2,L_y/2]$，其中 $x$ 方向有 $N_x$ 个单元， $y$ 方向有 $N_y$ 个单元，间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$，时间步长 $\\Delta t$ 通过Courant–Friedrichs–Lewy (CFL) 条件选取 \n$$\n\\Delta t = \\alpha \\left( c \\sqrt{\\Delta x^{-2} + \\Delta y^{-2}} \\right)^{-1},\n$$\n其中 $\\alpha \\in (0,1)$ 是一个指定因子。将半径为 $R$ 的PEC圆形边界置于中心 $(0,0)$。\n\n$H_z$的共形更新：对于每个主元胞，设 $A_{\\text{eff}}$ 为该元胞与圆盘 $x^2+y^2  R^2$ 的交集面积。设 $\\ell_{\\text{bot}}, \\ell_{\\text{top}}, \\ell_{\\text{left}}, \\ell_{\\text{right}}$ 分别为该元胞的下、上、左、右四条边中位于圆盘内部的长度。磁场更新方程为\n$$ H_z^{n+1/2}|_{i,j} = H_z^{n-1/2}|_{i,j} - \\frac{\\Delta t}{\\mu_0 A_{\\text{eff}}} \\left( E_x^n|_{i,j+1} \\ell_{\\text{top}} - E_x^n|_{i,j} \\ell_{\\text{bot}} + E_y^n|_{i+1,j} \\ell_{\\text{right}} - E_y^n|_{i,j} \\ell_{\\text{left}} \\right). $$\n$E_x,E_y$的更新：使用标准的Yee更新方程，但对所有完全位于圆盘外部的场分量强制为零。对于 $E_x$ 位于 $(i,j+1/2)$ 处的更新，\n$$ E_x^{n+1}|_{i,j+1} = E_x^n|_{i,j+1} + \\frac{\\Delta t}{\\varepsilon_0 \\Delta y} (H_z^{n+1/2}|_{i,j+1} - H_z^{n+1/2}|_{i,j}) \\text{ if } \\ell_{x\\text{-edge}} > 0, $$\n否则 $E_x^{n+1}|_{i,j+1} = 0$，其中 $\\ell_{x\\text{-edge}}$ 是对应 $E_x$ 边的长度。类似地对 $E_y$ 进行更新。\n\n几何量的计算：\n-   $A_{\\text{eff}}$ 可以通过在一个 $p \\times p$ 的子网格上对每个单元进行蒙特卡洛积分来近似。\n-   边长 $\\ell$ 必须使用精确的弦长公式来计算：对于一个垂直于轴线，与轴线距离为 $d$ 的线段，它与半径为 $R$ 的圆的弦长为 $2\\sqrt{R^2 - d^2}$，若 $d  R$。您的代码必须处理线段端点对弦的裁剪。\n\n能量守恒：对于每个时间步 $n$，计算系统的离散能量\n$$ W^n = \\frac{1}{2} \\sum_{i,j} \\left( \\varepsilon_0 E_x^n|^2_{i,j} (\\Delta x \\ell_x^*) + \\varepsilon_0 E_y^n|^2_{i,j} (\\Delta y \\ell_y^*) + \\mu_0 H_z^{n-1/2,n+1/2}|^2_{i,j} A_{\\text{eff}} \\right), $$\n其中 $H_z^{n-1/2,n+1/2}$ 是两个连续半步磁场的平均值。有效对偶边长 $\\ell_x^*$ 和 $\\ell_y^*$ 是垂直于对应电场分量的对偶网格边的长度，它们也位于圆盘内部。\n\n实现一个程序，对每个给定的测试用例，计算并报告归一化能量偏差 $\\delta_{\\min} = (W^0 - \\min_{n \\in [0,N_t-1]} W^n) / W^0$。\n\n初始条件：$E_x(t=0)=0$，$E_y(t=0)=0$，$H_z(t=0) = H_0 \\exp[-(x^2+y^2)/(2\\sigma^2)]$，其中 $\\sigma = 0.2R$。在数值上，$H_z$在 $t=-\\Delta t/2$ 时刻初始化。\n\n测试用例（格式为(Lx, Ly, Nx, Ny, R, alpha, Nt)）：\n- A: (1.0, 1.0, 80, 80, 0.4, 0.90, 1000)\n- B: (1.0, 1.0, 64, 64, 0.2, 0.90, 800)\n- C: (1.0, 1.0, 96, 96, 0.45, 0.98, 1200)\n\n使用 $p=8$ 进行面积子采样。您的程序应生成一个包含三个值的单行输出，格式为 `[result_A,result_B,result_C]`。", "solution": "用户提供的问题经评估是有效的。它在科学上基于计算电磁学原理，特别是时域有限差分 (FDTD) 方法。该问题定义明确，提供了一整套偏微分方程、边界条件、初始条件和数值参数。其语言是客观的，要求可以形式化为一个具体的数值算法。任务是为一个圆形理想电导体 (PEC) 内部的二维 TE$_z$ 问题实现一个特定的共形 FDTD 格式，并验证其能量守恒特性。\n\n解决方案将通过以下步骤开发：\n1.  使用标准Yee网格对计算域进行离散化。\n2.  预先计算所有必要的几何因子，将圆形边界编码到笛卡尔网格中。\n3.  使用蛙跳算法和指定的共形更新实现时间步进循环。\n4.  在每个时间步计算离散电磁能。\n5.  对指定的测试用例评估能量守恒指标。\n\n### 1. 离散化与网格设置\n使用均匀的笛卡尔网格对连续的二维域进行离散化。该问题使用横电 (TE$_z$) 极化，其中电场 $\\mathbf{E} = (E_x, E_y, 0)$ 位于 $xy$ 平面，而磁场 $\\mathbf{H} = (0, 0, H_z)$ 与之垂直。在标准的Yee FDTD格式中，场分量在空间和时间上是交错的。\n- 标量磁场分量 $H_z$ 在每个网格单元 $(i, j)$ 的中心和半整数时间步 $n+1/2$ 处采样。一个单元 $(i,j)$ 覆盖区域 $[x_i, x_{i+1}] \\times [y_j, y_{j+1}]$。\n- 电场分量 $E_x$ 在每个单元的水平边中心和整数时间步 $n$ 处采样。\n- 电场分量 $E_y$ 在每个单元的垂直边中心和整数时间步 $n$ 处采样。\n\n模拟域是一个方形区域 $[-L_x/2, L_x/2] \\times [-L_y/2, L_y/2]$，包含 $N_x \\times N_y$ 个单元。空间和时间步长由以下公式给出：\n$$ \\Delta x = \\frac{L_x}{N_x}, \\quad \\Delta y = \\frac{L_y}{N_y} $$\n$$ \\Delta t = \\alpha \\left( c \\sqrt{\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}} \\right)^{-1} $$\n其中 $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$ 是真空中的光速，$\\alpha$ 是 Courant 因子。\n\n### 2. 几何预计算\n为了将半径为 $R$ 的圆形PEC边界整合到笛卡尔网格中，必须在时间步进模拟开始前为每个单元和边计算几个几何因子。\n\n- **有效面积 ($A_{\\text{eff}}$)**：对于每个 $H_z$ 单元，$A_{\\text{eff}}$ 是该单元位于圆 $x^2 + y^2  R^2$ 内部的面积。按照规定，这通过在每个单元内创建一个均匀的 $p \\times p$ 子点网格，并计算落在圆内的点的比例，再乘以单元面积 $\\Delta x \\Delta y$ 来近似。\n\n- **用于H更新的有效边长 ($\\ell_{\\text{edge}}$)**：对于每个单元，计算其四条边（上、下、左、右）中位于圆内的长度。这些长度表示为 $\\ell_{\\text{top}}$、$\\ell_{\\text{bot}}$、$\\ell_{\\text{left}}$ 和 $\\ell_{\\text{right}}$。计算使用提供的线段与圆的弦相交长度的精确公式。对于高度为 $y_0$、跨度为 $[x_0, x_1]$ 的水平边，若 $|y_0|  R$，则与圆周的交点为 $x = \\pm\\sqrt{R^2 - y_0^2}$。有效长度是线段 $[x_0, x_1]$ 和 $[-\\sqrt{R^2 - y_0^2}, \\sqrt{R^2 - y_0^2}]$ 的交集长度。对垂直边应用类似逻辑。\n\n- **用于E更新和能量计算的边长**：\n  - $\\ell_{x\\text{-edge}}$ 和 $\\ell_{y\\text{-edge}}$：对于每个 $E_x$ 和 $E_y$ 场分量，其对应的主网格边的长度位于圆内。这些与用于 $H$ 更新的 $\\ell_{\\text{edge}}$ 相同，但根据其在网格中的位置进行索引。\n  - $\\ell_x^*$ 和 $\\ell_y^*$：这些是对偶网格边的长度。位于 $(x_i, y_{j+1/2})$ 的 $E_x$ 场的对偶边是一条从 $(x_i, y_j)$ 到 $(x_i, y_{j+1})$ 的垂直线段。$\\ell_x^*$ 是该线段中位于圆内的长度。类似地，位于 $(x_{i+1/2}, y_j)$ 的 $E_y$ 场的对偶边是一条从 $(x_i, y_j)$ 到 $(x_{i+1}, y_j)$ 的水平线段，$\\ell_y^*$ 是其位于圆内的部分。这些长度也使用精确的弦长公式计算。\n\n### 3. 时间步进\nFDTD算法是一个“蛙跳”格式，其中 $E$ 和 $H$ 场交替更新。\n1.  在 $t = -\\Delta t/2$ 时初始化 $H_z$。\n2.  进入主时间步进循环，从 $n=0$ 到 $N_t-1$。\n3.  **更新 $H_z$**：使用在 $t=n$ 时的 $E_x, E_y$ 场和预先计算的几何因子 ($A_{\\text{eff}}, \\ell_{\\text{edge}}$)，将 $H_z$ 从 $t=n-1/2$ 更新到 $t=n+1/2$。\n4.  **计算能量**：在 $H$ 场更新后，通过对 $H_z^{n-1/2}$ 和 $H_z^{n+1/2}$ 进行时间平均，得到 $t=n$ 时刻的 $H_z$ 场。然后使用在 $t=n$ 时的 $E_x, E_y$ 场、时间平均后的 $H_z$ 场以及几何因子 ($A_{\\text{eff}}, \\ell_x^*, \\ell_y^*$) 计算总离散能量 $W^n$。\n5.  **更新 $E_x, E_y$**：使用在 $t=n+1/2$ 时的 $H_z$ 场，将 $E_x$ 和 $E_y$ 场从 $t=n$ 更新到 $t=n+1$。\n6.  **施加边界条件**：对于所有 $\\ell_{x\\text{-edge}} = 0$ 或 $\\ell_{y\\text{-edge}} = 0$ 的边，将相应的 $E$ 场分量强制设为零。这有效地施加了圆形PEC边界条件。\n7.  循环继续。\n\n### 4. 评估\n在模拟完成后，我们得到一个时间序列的能量值 $\\{W^0, W^1, \\dots, W^{N_t-1}\\}$。然后计算指定的度量：\n$$ \\delta_{\\min} = \\frac{W^0 - \\min(W^n)}{W^0} $$\n该度量量化了在模拟期间相对于初始能量的最大能量损失。对于一个理想的无损耗方案，$\\delta_{\\min}$ 应该非常接近于零（仅受浮点舍入误差影响）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FDTD simulations for all test cases and print the results.\n    \"\"\"\n\n    class ConformalFDTDSim:\n        \"\"\"\n        Encapsulates the logic for a 2D TEz conformal FDTD simulation.\n        \"\"\"\n        def __init__(self, Lx, Ly, Nx, Ny, R, alpha, Nt, p):\n            # Physical constants\n            self.EPS0 = 8.854187817e-12\n            self.MU0 = 4 * np.pi * 1e-7\n            self.C = 1 / np.sqrt(self.EPS0 * self.MU0)\n\n            # Simulation parameters\n            self.Lx, self.Ly = Lx, Ly\n            self.Nx, self.Ny = Nx, Ny\n            self.R = R\n            self.alpha = alpha\n            self.Nt = Nt\n            self.p = p\n\n            # Discretization\n            self.dx = self.Lx / self.Nx\n            self.dy = self.Ly / self.Ny\n            self.dt = self.alpha / (self.C * np.sqrt(1/self.dx**2 + 1/self.dy**2))\n\n            # Precompute geometric factors\n            self._precompute_geometry()\n\n        def _compute_len(self, p0, p1, R, orth_coord):\n            \"\"\"Computes intersection length of a segment with a circle's chord.\"\"\"\n            if np.abs(orth_coord) >= R:\n                return 0.0\n            chord_half_len = np.sqrt(R**2 - orth_coord**2)\n            overlap_min = max(p0, -chord_half_len)\n            overlap_max = min(p1, chord_half_len)\n            return max(0.0, overlap_max - overlap_min)\n\n        def _precompute_geometry(self):\n            \"\"\"Precomputes all geometric factors for the conformal FDTD scheme.\"\"\"\n            # Grid coordinates\n            x_h = -self.Lx/2 + (np.arange(self.Nx) + 0.5) * self.dx\n            y_h = -self.Ly/2 + (np.arange(self.Ny) + 0.5) * self.dy\n            x_ey = -self.Lx/2 + np.arange(self.Nx + 1) * self.dx\n            y_ex = -self.Ly/2 + np.arange(self.Ny + 1) * self.dy\n            \n            # --- Geometry for H_z update ---\n            self.A_eff = np.zeros((self.Nx, self.Ny))\n            self.l_top = np.zeros((self.Nx, self.Ny))\n            self.l_bot = np.zeros((self.Nx, self.Ny))\n            self.l_left = np.zeros((self.Nx, self.Ny))\n            self.l_right = np.zeros((self.Nx, self.Ny))\n\n            for i in range(self.Nx):\n                for j in range(self.Ny):\n                    x_min, x_max = x_ey[i], x_ey[i+1]\n                    y_min, y_max = y_ex[j], y_ex[j+1]\n\n                    # A_eff via subsampling\n                    sub_dx = self.dx / self.p\n                    sub_dy = self.dy / self.p\n                    sub_x = x_min + (np.arange(self.p) + 0.5) * sub_dx\n                    sub_y = y_min + (np.arange(self.p) + 0.5) * sub_dy\n                    sub_X, sub_Y = np.meshgrid(sub_x, sub_y)\n                    inside_mask = sub_X**2 + sub_Y**2  self.R**2\n                    self.A_eff[i, j] = np.sum(inside_mask) / self.p**2 * self.dx * self.dy\n                    \n                    # Effective edge lengths\n                    self.l_bot[i, j] = self._compute_len(x_min, x_max, self.R, y_min)\n                    self.l_top[i, j] = self._compute_len(x_min, x_max, self.R, y_max)\n                    self.l_left[i, j] = self._compute_len(y_min, y_max, self.R, x_min)\n                    self.l_right[i, j] = self._compute_len(y_min, y_max, self.R, x_max)\n            \n            self.inv_mu0_A_eff = np.zeros((self.Nx, self.Ny))\n            mask = self.A_eff > 0\n            self.inv_mu0_A_eff[mask] = 1.0 / (self.MU0 * self.A_eff[mask])\n\n            # --- Geometry for E-field zeroing and Energy ---\n            ex_loc_x = -self.Lx/2 + (np.arange(self.Nx) + 0.5) * self.dx\n            ex_loc_y = -self.Ly/2 + np.arange(self.Ny + 1) * self.dy\n            ey_loc_x = -self.Lx/2 + np.arange(self.Nx + 1) * self.dx\n            ey_loc_y = -self.Ly/2 + (np.arange(self.Ny) + 0.5) * self.dy\n\n            self.l_x_edges = np.zeros((self.Nx, self.Ny + 1))\n            self.l_star_x = np.zeros((self.Nx, self.Ny + 1))\n            for i in range(self.Nx):\n                for j in range(self.Ny + 1):\n                    x, y = ex_loc_x[i], ex_loc_y[j]\n                    self.l_x_edges[i, j] = self._compute_len(x - self.dx/2, x + self.dx/2, self.R, y)\n                    self.l_star_x[i, j] = self._compute_len(y - self.dy/2, y + self.dy/2, self.R, x)\n\n            self.l_y_edges = np.zeros((self.Nx + 1, self.Ny))\n            self.l_star_y = np.zeros((self.Nx + 1, self.Ny))\n            for i in range(self.Nx + 1):\n                for j in range(self.Ny):\n                    x, y = ey_loc_x[i], ey_loc_y[j]\n                    self.l_y_edges[i, j] = self._compute_len(y - self.dy/2, y + self.dy/2, self.R, x)\n                    self.l_star_y[i, j] = self._compute_len(x - self.dx/2, x + self.dx/2, self.R, y)\n\n        def run(self):\n            \"\"\"Executes the FDTD time-stepping loop and returns the metric.\"\"\"\n            # Field arrays\n            ex = np.zeros((self.Nx, self.Ny + 1))\n            ey = np.zeros((self.Nx + 1, self.Ny))\n            hz = np.zeros((self.Nx, self.Ny))\n\n            # Initial condition for H_z at t=0 (used as t=-dt/2)\n            H0 = 1.0\n            sigma = 0.2 * self.R\n            x_h = -self.Lx/2 + (np.arange(self.Nx) + 0.5) * self.dx\n            y_h = -self.Ly/2 + (np.arange(self.Ny) + 0.5) * self.dy\n            X_h, Y_h = np.meshgrid(x_h, y_h, indexing='ij')\n            hz = H0 * np.exp(-(X_h**2 + Y_h**2) / (2 * sigma**2))\n            hz[self.A_eff == 0] = 0.0 # Enforce H=0 outside the physical domain\n\n            C_ex = self.dt / (self.EPS0 * self.dy)\n            C_ey = -self.dt / (self.EPS0 * self.dx)\n\n            W_history = []\n\n            for n in range(self.Nt):\n                hz_old = hz.copy() # H at n-1/2\n\n                # Update H_z to n+1/2\n                curl_E_x_term = ex[:, 1:] * self.l_top - ex[:, :-1] * self.l_bot\n                curl_E_y_term = ey[1:, :] * self.l_right - ey[:-1, :] * self.l_left\n                hz -= self.dt * self.inv_mu0_A_eff * (curl_E_y_term + curl_E_x_term)\n\n                # Time average H_z to get H at time n\n                hz_avg = 0.5 * (hz_old + hz)\n                \n                # Calculate energy at time n\n                W_H = 0.5 * self.MU0 * np.sum(hz_avg**2 * self.A_eff)\n                W_Ex = 0.5 * self.EPS0 * np.sum(ex**2 * self.dx * self.l_star_x)\n                W_Ey = 0.5 * self.EPS0 * np.sum(ey**2 * self.dy * self.l_star_y)\n                W_total = W_H + W_Ex + W_Ey\n                W_history.append(W_total)\n\n                # Update E_x to n+1\n                ex[:, 1:-1] += C_ex * (hz[:, 1:] - hz[:, :-1])\n                \n                # Update E_y to n+1\n                ey[1:-1, :] += C_ey * (hz[1:, :] - hz[:-1, :])\n\n                # Enforce PEC by zeroing E fields on edges outside the circle\n                ex[self.l_x_edges == 0] = 0.0\n                ey[self.l_y_edges == 0] = 0.0\n\n            W0 = W_history[0]\n            if W0 == 0:\n                return 0.0 \n            min_W = min(W_history)\n            delta_min = (W0 - min_W) / W0\n            return delta_min\n\n    # Test suite parameters\n    test_cases = [\n        # (Lx, Ly, Nx, Ny, R, alpha, Nt)\n        (1.0, 1.0, 80, 80, 0.4, 0.90, 1000),  # Case A\n        (1.0, 1.0, 64, 64, 0.2, 0.90, 800),   # Case B\n        (1.0, 1.0, 96, 96, 0.45, 0.98, 1200), # Case C\n    ]\n    p_subsampling = 8\n\n    results = []\n    for params in test_cases:\n        sim = ConformalFDTDSim(*params, p=p_subsampling)\n        result = sim.run()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3294784"}, {"introduction": "共形FDTD并非单一方法，而是一类技术。最后的这个练习将探索一种概念上截然不同且功能强大的方法：局部坐标变换。我们不再直接用几何因子修改更新方程，而是在边界附近的倾斜单元内部应用仿射变换，将其映射回正交空间，这在原始笛卡尔网格上等效于引入了各向异性材料。您将通过推导这些等效材料张量和相应的稳定性条件，深入了解变换光学这一强大概念在改进网格剖分技术中的应用。[@problem_id:3294846]", "problem": "考虑一个由时域有限差分法（FDTD）离散化的二维电磁区域。假设在一个被弯曲材料边界穿过的网格单元（一个“切割单元”）内，为了实现几何共形，应用了一个局部的非正交仿射坐标变换。该变换由 $x' = x + \\alpha y$ 和 $y' = y$ 给出，其中 $\\alpha$ 是一个无量纲剪切参数，$(x,y)$ 表示原始笛卡尔坐标，而 $(x',y')$ 表示切割单元内部的局部共形坐标。网格在 $(x,y)$ 坐标系中保持正交，但切割单元内的材料被替换为等效的各向异性介质，从而使得 $(x,y)$ 坐标系中的麦克斯韦方程组能够再现 $(x',y')$ 坐标系中的物理现象。假设该变换通过 $z' = z$ 在 $z$ 方向上进行平凡扩展。\n\n从麦克斯韦方程组的微分形式出发，即 $\\nabla \\times \\mathbf{E} = -\\partial \\mathbf{B}/\\partial t$、$\\nabla \\times \\mathbf{H} = \\partial \\mathbf{D}/\\partial t$，以及本构关系 $\\mathbf{D} = \\boldsymbol{\\varepsilon}\\,\\mathbf{E}$、$\\mathbf{B} = \\boldsymbol{\\mu}\\,\\mathbf{H}$，并结合麦克斯韦方程组在可微映射下的坐标不变性，推导在原始 $(x,y,z)$ 坐标系下的等效各向异性材料张量，该张量能够在给定的切割单元内仿射剪切变换下，再现 $(x',y',z')$ 坐标系中各向同性介质的物理特性。设各向同性介质具有标量介电常数 $\\varepsilon = \\varepsilon_0 \\varepsilon_r$ 和标量磁导率 $\\mu = \\mu_0 \\mu_r$，其中 $\\varepsilon_0$ 是真空介电常数，$\\mu_0$ 是真空磁导率；请用 $\\alpha$、$\\varepsilon_0$、$\\mu_0$、$\\varepsilon_r$ 和 $\\mu_r$ 显式地表示出 $(x,y,z)$ 坐标系中的各向异性张量 $\\boldsymbol{\\varepsilon}$ 和 $\\boldsymbol{\\mu}$。\n\n然后，针对FDTD中使用的两种典型的二维极化方式——z向横电波（TEz，非零场为 $E_z$、$H_x$ 和 $H_y$）和z向横磁波（TMz，非零场为 $H_z$、$E_x$ 和 $E_y$）——推导当在切割单元内使用等效各向异性张量时，标准蛙跳FDTD更新算法对时间步长 $\\Delta t$ 的一个充分的显式稳定性边界。您的边界条件必须用网格间距 $\\Delta x$ 和 $\\Delta y$、真空光速 $c = 1/\\sqrt{\\varepsilon_0 \\mu_0}$ 以及剪切参数 $\\alpha$ 来表示，并且当 $\\alpha = 0$ 时，它必须退化为通常的二维笛卡尔坐标下的边界条件。请提供一个适用于切割单元内剪切映射下TEz和TMz两种模式的 $\\Delta t_{\\text{max}}$ 的单一显式公式。\n\n实现一个程序，对每个给定的测试用例，计算：\n- 等效各向异性介电常数张量 $\\boldsymbol{\\varepsilon}$ 的平面内分量：$(\\varepsilon_{xx}, \\varepsilon_{xy}, \\varepsilon_{yx}, \\varepsilon_{yy})$，单位为法拉每米 (F/m)。\n- 等效各向异性磁导率张量 $\\boldsymbol{\\mu}$ 的平面内分量：$(\\mu_{xx}, \\mu_{xy}, \\mu_{yx}, \\mu_{yy})$，单位为亨利每米 (H/m)。\n- TEz和TMz模式下的最大稳定时间步长 $\\Delta t_{\\text{max}}$，单位为秒 (s)，报告为 $(\\Delta t_{\\text{TEz}}, \\Delta t_{\\text{TMz}})$。\n\n单位必须严格遵守：\n- $\\boldsymbol{\\varepsilon}$ 单位为 F/m，\n- $\\boldsymbol{\\mu}$ 单位为 H/m，\n- $\\Delta t$ 单位为 s。\n\n角度不出现；不需要角度单位。所有最终答案必须是实数。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，输出一个包含 $[\\varepsilon_{xx}, \\varepsilon_{xy}, \\varepsilon_{yx}, \\varepsilon_{yy}, \\mu_{xx}, \\mu_{xy}, \\mu_{yx}, \\mu_{yy}, \\Delta t_{\\text{TEz}}, \\Delta t_{\\text{TMz}}]$ 的嵌套列表。\n\n使用以下测试套件，每个套件指定为 $(\\alpha, \\Delta x, \\Delta y, \\varepsilon_r, \\mu_r)$，其中 $\\Delta x$ 和 $\\Delta y$ 的单位为米：\n- 测试 1：$(\\alpha = 0.0, \\Delta x = 10^{-3}, \\Delta y = 10^{-3}, \\varepsilon_r = 1.0, \\mu_r = 1.0)$。\n- 测试 2：$(\\alpha = 0.5, \\Delta x = 10^{-3}, \\Delta y = 2\\times 10^{-3}, \\varepsilon_r = 2.5, \\mu_r = 1.0)$。\n- 测试 3：$(\\alpha = -0.9, \\Delta x = 5\\times 10^{-4}, \\Delta y = 10^{-3}, \\varepsilon_r = 1.0, \\mu_r = 1.0)$。\n- 测试 4：$(\\alpha = 3.0, \\Delta x = 10^{-3}, \\Delta y = 10^{-3}, \\varepsilon_r = 1.0, \\mu_r = 1.0)$。\n- 测试 5：$(\\alpha = 1.0, \\Delta x = 10^{-3}, \\Delta y = 5\\times 10^{-4}, \\varepsilon_r = 1.0, \\mu_r = 2.0)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resultk$ 是测试 $k$ 的嵌套列表，格式如上所述。不应打印任何额外文本。", "solution": "该问题是有效的，因为它在科学上基于计算电磁学和变换光学的原理，问题是适定的，并为获得唯一解提供了所有必要信息。\n\n求解过程需要两个主要推导：首先，在笛卡尔坐标系 $(x,y,z)$ 中模拟剪切坐标系 $(x',y',z')$ 中各向同性介质的等效各向异性材料张量（$\\boldsymbol{\\varepsilon}$ 和 $\\boldsymbol{\\mu}$）；其次，针对该等效各向异性介质的FDTD稳定性条件。\n\n### 第1部分：等效各向异性张量的推导\n\n从计算用的笛卡尔坐标 $(x,y,z)$ 到局部共形（剪切）坐标 $(x',y',z')$ 的变换由以下仿射映射给出：\n$$ x' = x + \\alpha y $$\n$$ y' = y $$\n$$ z' = z $$\n其中 $\\alpha$ 是一个无量纲剪切参数。该变换应用于FDTD网格的单个“切割单元”内。\n\n麦克斯韦方程组的坐标不变性原理指出，可以使用坐标变换的雅可比矩阵来找到原始坐标中等效介质的本构关系。变换 $\\mathbf{x}'(\\mathbf{x})$ 的雅可比矩阵 $\\mathbf{J}$ 为：\n$$ \\mathbf{J} = \\frac{\\partial(x', y', z')}{\\partial(x, y, z)} = \\begin{pmatrix} \\frac{\\partial x'}{\\partial x}  \\frac{\\partial x'}{\\partial y}  \\frac{\\partial x'}{\\partial z} \\\\ \\frac{\\partial y'}{\\partial x}  \\frac{\\partial y'}{\\partial y}  \\frac{\\partial y'}{\\partial z} \\\\ \\frac{\\partial z'}{\\partial x}  \\frac{\\partial z'}{\\partial y}  \\frac{\\partial z'}{\\partial z} \\end{pmatrix} = \\begin{pmatrix} 1  \\alpha  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\n雅可比矩阵的行列式为 $\\det(\\mathbf{J}) = 1$。\n\n在加撇的坐标系 $(x',y',z')$ 中，介质是各向同性且均匀的，其标量介电常数为 $\\varepsilon' = \\varepsilon_0 \\varepsilon_r$，磁导率为 $\\mu' = \\mu_0 \\mu_r$。用张量形式表示为 $\\boldsymbol{\\varepsilon}' = \\varepsilon' \\mathbf{I}$ 和 $\\boldsymbol{\\mu}' = \\mu' \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。\n\n从加撇坐标系到不加撇坐标系的介电常数和磁导率张量的变换法则是：\n$$ \\boldsymbol{\\varepsilon} = \\frac{\\mathbf{J} \\boldsymbol{\\varepsilon}' \\mathbf{J}^T}{|\\det(\\mathbf{J})|} \\quad \\text{和} \\quad \\boldsymbol{\\mu} = \\frac{\\mathbf{J} \\boldsymbol{\\mu}' \\mathbf{J}^T}{|\\det(\\mathbf{J})|} $$\n由于 $\\det(\\mathbf{J})=1$ 且加撇的张量是单位矩阵的标量倍，因此简化为：\n$$ \\boldsymbol{\\varepsilon} = \\varepsilon' (\\mathbf{J} \\mathbf{J}^T) \\quad \\text{和} \\quad \\boldsymbol{\\mu} = \\mu' (\\mathbf{J} \\mathbf{J}^T) $$\n我们计算矩阵乘积 $\\mathbf{J} \\mathbf{J}^T$：\n$$ \\mathbf{J} \\mathbf{J}^T = \\begin{pmatrix} 1  \\alpha  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\alpha  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 1 + \\alpha^2  \\alpha  0 \\\\ \\alpha  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\n因此，在 $(x,y,z)$ 坐标系中的等效各向异性材料张量为：\n$$ \\boldsymbol{\\varepsilon} = (\\varepsilon_0 \\varepsilon_r) \\begin{pmatrix} 1 + \\alpha^2  \\alpha  0 \\\\ \\alpha  1  0 \\\\ 0  0  1 \\end{pmatrix} \\quad \\text{和} \\quad \\boldsymbol{\\mu} = (\\mu_0 \\mu_r) \\begin{pmatrix} 1 + \\alpha^2  \\alpha  0 \\\\ \\alpha  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\n计算所需的平面内分量为：\n$\\varepsilon_{xx} = \\varepsilon_0 \\varepsilon_r (1 + \\alpha^2)$，$\\varepsilon_{xy} = \\varepsilon_{yx} = \\varepsilon_0 \\varepsilon_r \\alpha$，$\\varepsilon_{yy} = \\varepsilon_0 \\varepsilon_r$。\n$\\mu_{xx} = \\mu_0 \\mu_r (1 + \\alpha^2)$，$\\mu_{xy} = \\mu_{yx} = \\mu_0 \\mu_r \\alpha$，$\\mu_{yy} = \\mu_0 \\mu_r$。\n\n### 第2部分：FDTD稳定性条件的推导\n\nFDTD算法的稳定性由Courant-Friedrichs-Lewy (CFL)条件决定，该条件取决于网格中的最大波传播速度。对于给定的各向异性介质，横电波（TEz）和横磁波（TMz）极化的波传播特性是相同的，因为它们都受相同的标量波动方程控制。这是因为各向异性仅限于 $xy$ 平面，并且张量 $\\boldsymbol{\\varepsilon}$ 和 $\\boldsymbol{\\mu}$ 具有相同的张量结构。\n\n在使用等效各向异性介质的正交网格 $(\\Delta x, \\Delta y)$ 上进行FDTD模拟的稳定性极限，与在扭斜网格上模拟各向同性介质的稳定性极限相同。扭斜网格是通过对加撇空间中的正交网格应用逆坐标变换得到的。然而，问题陈述了网格在 $(x,y)$ 坐标系中是正交的，而我们要求的是该模拟的稳定性极限。这等效于在一个空间中模拟各向同性介质，其中 $(x,y)$ 空间的正交网格矢量 $\\mathbf{v}_1 = (\\Delta x, 0)$ 和 $\\mathbf{v}_2 = (0, \\Delta y)$ 被映射到 $(x',y')$ 空间中的扭斜矢量。\n\n该变换将这些基矢量映射为：\n$\\mathbf{v}'_1 = \\mathbf{J} \\mathbf{v}_1 = (\\Delta x, 0)$\n$\\mathbf{v}'_2 = \\mathbf{J} \\mathbf{v}_2 = (\\alpha \\Delta y, \\Delta y)$\n\n$(x',y')$ 空间中的FDTD模拟在由这两个扭斜矢量定义的网格上进行。这种格式的稳定性是已知的。设 $\\phi$ 为 $\\mathbf{v}'_1$ 和 $\\mathbf{v}'_2$ 之间的夹角。\n$|\\mathbf{v}'_1| = \\Delta x$\n$|\\mathbf{v}'_2| = \\sqrt{(\\alpha \\Delta y)^2 + (\\Delta y)^2} = \\Delta y \\sqrt{1+\\alpha^2}$\n$\\cos(\\phi) = \\frac{\\mathbf{v}'_1 \\cdot \\mathbf{v}'_2}{|\\mathbf{v}'_1| |\\mathbf{v}'_2|} = \\frac{\\alpha \\Delta x \\Delta y}{\\Delta x (\\Delta y \\sqrt{1+\\alpha^2})} = \\frac{\\alpha}{\\sqrt{1+\\alpha^2}}$\n$\\sin^2(\\phi) = 1 - \\cos^2(\\phi) = 1 - \\frac{\\alpha^2}{1+\\alpha^2} = \\frac{1}{1+\\alpha^2}$\n\n对于间距为 $|\\mathbf{v}'_1|$、 $|\\mathbf{v}'_2|$ 且夹角为 $\\phi$ 的非正交网格，二维FDTD蛙跳格式的稳定性条件是：\n$$ (\\Delta t)^2 \\le \\frac{\\sin^2(\\phi)}{v^2 \\left( \\frac{1}{|\\mathbf{v}'_1|^2} + \\frac{1}{|\\mathbf{v}'_2|^2} - \\frac{2 \\cos(\\phi)}{|\\mathbf{v}'_1| |\\mathbf{v}'_2|} \\right)} $$\n其中 $v = c/\\sqrt{\\varepsilon_r \\mu_r}$ 是各向同性介质中的光速。代入我们推导出的几何量：\n$$ (\\Delta t)^2 \\le \\frac{1/(1+\\alpha^2)}{v^2 \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2(1+\\alpha^2)} - \\frac{2 \\alpha/\\sqrt{1+\\alpha^2}}{\\Delta x \\Delta y \\sqrt{1+\\alpha^2}} \\right)} $$\n$$ (\\Delta t)^2 \\le \\frac{1/(1+\\alpha^2)}{v^2 \\left( \\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2(1+\\alpha^2)} - \\frac{2\\alpha}{\\Delta x \\Delta y (1+\\alpha^2)} \\right)} $$\n将分子和分母同乘以 $(1+\\alpha^2)$：\n$$ (\\Delta t)^2 \\le \\frac{1}{v^2 \\left( \\frac{1+\\alpha^2}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2} - \\frac{2\\alpha}{\\Delta x \\Delta y} \\right)} $$\n这导出了最大稳定时间步长：\n$$ \\Delta t_{\\text{max}} = \\frac{1}{v\\sqrt{\\frac{1+\\alpha^2}{(\\Delta x)^2} - \\frac{2\\alpha}{\\Delta x \\Delta y} + \\frac{1}{(\\Delta y)^2}}} $$\n代入 $v = c/\\sqrt{\\varepsilon_r \\mu_r}$：\n$$ \\Delta t_{\\text{max}} = \\frac{\\sqrt{\\varepsilon_r \\mu_r}}{c\\sqrt{\\frac{1+\\alpha^2}{(\\Delta x)^2} - \\frac{2\\alpha}{\\Delta x \\Delta y} + \\frac{1}{(\\Delta y)^2}}} $$\n这个单一公式对TEz和TMz极化都有效。对于 $\\alpha = 0$ 的情况，该公式正确地退化为标准的二维笛卡尔CFL条件：\n$$ \\Delta t_{\\text{max}} (\\alpha=0) = \\frac{\\sqrt{\\varepsilon_r \\mu_r}}{c\\sqrt{\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}}} $$\n平方根内的项 $\\left(\\frac{\\alpha}{\\Delta x} - \\frac{1}{\\Delta y}\\right)^2 + \\left(\\frac{1}{\\Delta x}\\right)^2$ 恒为正，确保时间步长为实值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants\n\ndef solve():\n    \"\"\"\n    Solves the conformal FDTD problem for a series of test cases.\n    It calculates the equivalent anisotropic material tensors and the FDTD\n    stability limit for a given affine shear transformation.\n    \"\"\"\n    # Define physical constants from scipy\n    eps0 = constants.epsilon_0  # Vacuum permittivity in F/m\n    mu0 = constants.mu_0        # Vacuum permeability in H/m\n    c = constants.c             # Speed of light in vacuum in m/s\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, delta_x, delta_y, eps_r, mu_r)\n    test_cases = [\n        (0.0, 1e-3, 1e-3, 1.0, 1.0),\n        (0.5, 1e-3, 2e-3, 2.5, 1.0),\n        (-0.9, 5e-4, 1e-3, 1.0, 1.0),\n        (3.0, 1e-3, 1e-3, 1.0, 1.0),\n        (1.0, 1e-3, 5e-4, 1.0, 2.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, dx, dy, eps_r, mu_r = case\n\n        # Part 1: Calculate equivalent anisotropic tensor components\n        # Permittivity in the isotropic (primed) coordinate system\n        eps_prime = eps0 * eps_r\n        # Permeability in the isotropic (primed) coordinate system\n        mu_prime = mu0 * mu_r\n\n        # Anisotropic permittivity tensor components in the (x,y) system\n        eps_xx = eps_prime * (1 + alpha**2)\n        eps_xy = eps_prime * alpha\n        eps_yx = eps_prime * alpha\n        eps_yy = eps_prime\n\n        # Anisotropic permeability tensor components in the (x,y) system\n        mu_xx = mu_prime * (1 + alpha**2)\n        mu_xy = mu_prime * alpha\n        mu_yx = mu_prime * alpha\n        mu_yy = mu_prime\n\n        # Part 2: Calculate the maximum stable time step\n        # The stability condition is derived from the CFL condition for a \n        # non-orthogonal grid, resulting in the following expression.\n        # This single formula applies to both TEz and TMz polarizations.\n        \n        # Calculate the term inside the square root of the stability condition's denominator\n        dt_denom_sq_term = (1 + alpha**2) / dx**2 - 2 * alpha / (dx * dy) + 1 / dy**2\n        \n        # Calculate the maximum stable time step\n        # dt_max = (sqrt(eps_r * mu_r) / c) / sqrt(dt_denom_sq_term)\n        dt_max = np.sqrt(eps_r * mu_r) / (c * np.sqrt(dt_denom_sq_term))\n        \n        # The stability bound is the same for TEz and TMz modes\n        dt_tez = dt_max\n        dt_tmz = dt_max\n\n        # Collect results for the current test case in the specified order\n        case_results = [\n            eps_xx, eps_xy, eps_yx, eps_yy,\n            mu_xx, mu_xy, mu_yx, mu_yy,\n            dt_tez, dt_tmz\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts each inner list to its string representation.\n    # The ','.join(...) creates a comma-separated string of these list strings.\n    # The f-string adds the outer brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3294846"}]}