{"hands_on_practices": [{"introduction": "分层矩阵方法的核心在于用低秩分解来近似表示远场相互作用块。本实践将指导您亲手实现这一过程的基础算法：首先使用可纳性准则 (admissibility criterion) 来识别这些远场块，然后应用奇异值分解 (Singular Value Decomposition, SVD) 来找到达到预设精度所需的最小秩。这是构建任何分层矩阵代码的基石。[@problem_id:3313470]", "problem": "考虑一个时谐电磁散射问题的边界积分离散化，其中两个良好分离的点簇之间的相互作用通过标量亥姆霍兹格林核进行建模。标量亥姆霍兹核定义为 $G(\\mathbf{r}) = \\dfrac{e^{\\mathrm{i} k \\lVert \\mathbf{r} \\rVert}}{4\\pi \\lVert \\mathbf{r} \\rVert}$，其中 $k$ 是以 $\\mathrm{m}^{-1}$ 为单位的波数，$\\mathbf{r} \\in \\mathbb{R}^3$ 是以 $\\mathrm{m}$ 为单位的位移向量，$\\lVert \\cdot \\rVert$ 表示欧几里得范数。在计算电磁学中，分层矩阵表示利用了这样一个事实：对于良好分离的簇，由于核在受限域上的光滑性，由 $G$ 的样本构成的子矩阵在数值上是低秩的。\n\n设 $X = \\{\\mathbf{x}_i\\}_{i=1}^m$ 和 $Y = \\{\\mathbf{y}_j\\}_{j=1}^n$ 是 $\\mathbb{R}^3$ 中的两个离散点簇，每个簇都位于长度为 $a$（单位为 $\\mathrm{m}$）的直线上。$X$ 的线段以原点为中心，并与 $x$ 轴对齐；具体来说，$X$ 包含 $m$ 个均匀分布在从 $(-a/2,0,0)$ 到 $(a/2,0,0)$ 的线段上的点。$Y$ 的线段以 $(\\delta_x, 0, D)$ 为中心，与 $x$ 轴对齐，包含 $n$ 个均匀分布在从 $(\\delta_x - a/2,0,D)$ 到 $(\\delta_x + a/2,0,D)$ 的线段上的点，其中 $D$ 是沿 $z$ 轴的中心间距，$\\delta_x$ 是以 $\\mathrm{m}$ 为单位的微小横向偏移。相互作用块矩阵 $A \\in \\mathbb{C}^{m \\times n}$ 的元素定义为 $A_{ij} = G(\\mathbf{x}_i - \\mathbf{y}_j)$。\n\n为了判断一个块是否适用于低秩近似，使用几何可接纳性准则 $D/a \\ge \\eta$，其中 $\\eta > 0$ 是一个固定的可接纳性参数。对于可接纳的块，根据用户指定的容差自适应地选择一个低秩近似。设 $A$ 的奇异值分解 (SVD) 为 $A = U \\Sigma V^*$，其中奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_q \\ge 0$，$q = \\min(m,n)$。最佳的秩-$r$ 截断 SVD 近似 $A_r$ 产生的 Frobenius 范数相对误差为\n$$\nE_r = \\sqrt{\\frac{\\sum_{j=r+1}^{q} \\sigma_j^2}{\\sum_{j=1}^{q} \\sigma_j^2}}.\n$$\n给定一个块容差 $\\tau > 0$，选择满足 $E_r \\le \\tau$ 的最小 $r \\in \\{1,2,\\dots,q\\}$。如果块是不可接纳的（即 $D/a  \\eta$），则设 $r = q$ 并定义 $E_r = 0$，因为满秩近似可以精确地恢复 $A$。\n\n从亥姆霍兹核的良好分离相互作用因其光滑性和可分离性而产生数值低秩块这一基本出发点，推导出一个算法，该算法能够：\n- 根据上述几何结构构建点簇 $X$ 和 $Y$。\n- 使用具有物理一致单位的 $G(\\mathbf{r})$ 形成块矩阵 $A$。\n- 应用可接纳性准则。\n- 对于可接纳的块，计算 $A$ 的 SVD，对递增的 $r$ 求值 $E_r$，并选择满足 $E_r \\le \\tau$ 的最小 $r$。\n- 对于不可接纳的块，设 $r = q$ 且 $E_r = 0$。\n\n使用以下测试套件，其中长度参数以米表示，波数以 $\\mathrm{m}^{-1}$ 表示。所有容差均为无量纲：\n1. 情况 1（理想路径远场）：$m = 40$, $n = 40$, $a = 0.2$ $\\mathrm{m}$, $D = 1.0$ $\\mathrm{m}$, $\\delta_x = 0.03$ $\\mathrm{m}$, $k = 3.0$ $\\mathrm{m}^{-1}$, $\\eta = 2.5$, $\\tau = 10^{-3}$。\n2. 情况 2（边界小块）：$m = 4$, $n = 4$, $a = 0.1$ $\\mathrm{m}$, $D = 0.6$ $\\mathrm{m}$, $\\delta_x = 0.02$ $\\mathrm{m}$, $k = 3.0$ $\\mathrm{m}^{-1}$, $\\eta = 2.5$, $\\tau = 10^{-3}$。\n3. 情况 3（近场不可接纳）：$m = 50$, $n = 50$, $a = 0.2$ $\\mathrm{m}$, $D = 0.05$ $\\mathrm{m}$, $\\delta_x = 0.03$ $\\mathrm{m}$, $k = 3.0$ $\\mathrm{m}^{-1}$, $\\eta = 2.5$, $\\tau = 10^{-3}$。\n4. 情况 4（高频远场）：$m = 60$, $n = 60$, $a = 0.2$ $\\mathrm{m}$, $D = 1.0$ $\\mathrm{m}$, $\\delta_x = 0.05$ $\\mathrm{m}$, $k = 20.0$ $\\mathrm{m}^{-1}$, $\\eta = 2.5$, $\\tau = 10^{-3}$。\n5. 情况 5（严格容差远场）：$m = 40$, $n = 40$, $a = 0.2$ $\\mathrm{m}$, $D = 1.2$ $\\mathrm{m}$, $\\delta_x = 0.03$ $\\mathrm{m}$, $k = 3.0$ $\\mathrm{m}^{-1}$, $\\eta = 2.5$, $\\tau = 10^{-6}$。\n\n你的程序应该为每个测试用例计算出数对 $[r, E_r]$，其中 $r$ 是选定的秩，$E_r$ 是达到的 Frobenius 范数相对误差（无量纲）。最终输出格式必须是单行，包含一个由方括号括起来的逗号分隔的数对列表，例如 $[[r_1,E_1],[r_2,E_2],\\dots]$。此问题中不出现角度；如果引入任何角度，则必须以弧度为单位，但此处不需要。距离必须以米为单位，波数以米分之一为单位，如指定；然而，输出值 $r$ 和 $E_r$ 是无量纲的。", "solution": "经评估，用户提供的问题是有效的。它在科学上植根于计算电磁学，问题陈述清晰，给定的条件完整，并且以客观、正式的语言呈现。它要求实现一个标准程序，用于确定边界积分方程公式中产生的矩阵块的数值秩。\n\n解决方案是通过一个分步过程推导出来的，该过程首先建立几何结构，然后构建相互作用矩阵，最后基于其奇异值分解进行分析，以确定满足指定近似容差所需的秩。\n\n**1. 几何配置与点簇生成**\n\n问题定义了三维欧几里得空间 $\\mathbb{R}^3$ 中的两个点簇，$X = \\{\\mathbf{x}_i\\}_{i=1}^m$ 和 $Y = \\{\\mathbf{y}_j\\}_{j=1}^n$。\n\n第一个簇 $X$ 包含 $m$ 个点，位于以原点 $(0,0,0)$ 为中心、与 $x$ 轴对齐的长度为 $a$ 的线段上。这些点 $\\mathbf{x}_i \\in \\mathbb{R}^3$ 的坐标由 $\\mathbf{x}_i = (x_i, 0, 0)$ 给出。标量值 $x_i$ 表示区间 $[-a/2, a/2]$ 的均匀离散化。对于 $m > 1$，这些点是通过包含端点的均匀线性间距生成的，即 $x_i = -a/2 + (i-1) \\frac{a}{m-1}$，其中 $i = 1, \\dots, m$。对于退化情况 $m=1$，单点位于中心，$\\mathbf{x}_1 = (0,0,0)$。\n\n第二个簇 $Y$ 包含 $n$ 个点，位于一条平行的、长度同为 $a$ 的线段上。该线段以 $(\\delta_x, 0, D)$ 为中心，其中 $D$ 表示沿 $z$ 轴的间距，$\\delta_x$ 表示沿 $x$ 轴的横向偏移。坐标 $\\mathbf{y}_j \\in \\mathbb{R}^3$ 由 $\\mathbf{y}_j = (y_j' + \\delta_x, 0, D)$ 给出。标量值 $y_j'$ 是与 $x_i$ 值类似的、对同一区间 $[-a/2, a/2]$ 的均匀离散化。对于 $n > 1$，$y_j' = -a/2 + (j-1) \\frac{a}{n-1}$，其中 $j=1, \\dots, n$。对于 $n=1$，点位于偏移前的线段中心，最终为 $\\mathbf{y}_1 = (\\delta_x, 0, D)$。\n\n**2. 块矩阵构建**\n\n两个簇之间的相互作用由一个 $m \\times n$ 矩阵 $A \\in \\mathbb{C}^{m \\times n}$ 捕获。该矩阵的每个元素 $A_{ij}$ 表示点 $\\mathbf{x}_i$ 和点 $\\mathbf{y}_j$ 之间的相互作用，由标量亥姆霍兹格林函数介导：\n$$\nA_{ij} = G(\\mathbf{x}_i - \\mathbf{y}_j) = \\frac{e^{\\mathrm{i} k \\lVert \\mathbf{x}_i - \\mathbf{y}_j \\rVert}}{4\\pi \\lVert \\mathbf{x}_i - \\mathbf{y}_j \\rVert}\n$$\n这里，$k$ 是波数，$\\mathrm{i}$ 是虚数单位，$\\lVert \\cdot \\rVert$ 是欧几里得范数。位移向量为 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{y}_j$。其范数的平方是：\n$$\n\\lVert \\mathbf{r}_{ij} \\rVert^2 = \\lVert (x_i - (y_j' + \\delta_x), 0, -D) \\rVert^2 = (x_i - y_j' - \\delta_x)^2 + D^2\n$$\n由于问题中声明 $D$ 的单位是米，并且在所有测试用例中 $D > 0$，因此分母 $\\lVert \\mathbf{x}_i - \\mathbf{y}_j \\rVert$ 永远不为零，从而避免了核函数求值中的任何奇点。\n\n**3. 可接纳性准则与秩选择**\n\n分层矩阵方法的核心是区分可以压缩的相互作用（远场）和不能压缩的相互作用（近场）。这是通过一个可接纳性准则来完成的。\n\n首先，评估几何条件 $D/a \\ge \\eta$，其中 $\\eta$ 是一个无量纲的可接纳性参数。\n- 如果 $D/a  \\eta$，相互作用被视为“不可接纳”或近场。在这种情况下，不执行近似。问题规定秩 $r$ 设置为可能的最大秩，即 $r = q = \\min(m, n)$，相应的误差 $E_r$ 定义为 $E_r = 0$。这意味着使用精确的块矩阵 $A$。\n- 如果 $D/a \\ge \\eta$，相互作用是“可接纳的”或远场。矩阵 $A$ 预期是数值低秩的。任务是找到在指定容差 $\\tau$ 内近似 $A$ 的最小秩 $r$。\n\n**4. 通过 SVD 进行自适应秩确定**\n\n对于一个可接纳的块，Frobenius 范数意义下的最佳秩-$r$ 近似由截断奇异值分解 (SVD) 给出。设 $A$ 的 SVD 为 $A = U \\Sigma V^*$，其中奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_q \\ge 0$。\n\n秩-$r$ 近似 $A_r$ 的相对 Frobenius 范数误差为：\n$$\nE_r = \\sqrt{\\frac{\\sum_{j=r+1}^{q} \\sigma_j^2}{\\sum_{j=1}^{q} \\sigma_j^2}}\n$$\n我们寻求满足 $E_r \\le \\tau$ 的最小整数 $r \\in \\{1, 2, \\dots, q\\}$。这等价于找到满足以下条件的最小 $r$：\n$$\n\\sum_{j=r+1}^{q} \\sigma_j^2 \\le \\tau^2 \\sum_{j=1}^{q} \\sigma_j^2\n$$\n设 $F^2 = \\sum_{j=1}^{q} \\sigma_j^2$ 为 $A$ 的 Frobenius 范数的平方。通过重新排列项，该条件可以重写为：\n$$\nF^2 - \\sum_{j=1}^{r} \\sigma_j^2 \\le \\tau^2 F^2 \\implies \\sum_{j=1}^{r} \\sigma_j^2 \\ge (1-\\tau^2) F^2\n$$\n这提供了一个高效的算法：\n1. 计算 $A$ 的奇异值 $\\sigma_j$。\n2. 计算它们的平方 $\\sigma_j^2$。\n3. 计算平方奇异值的累积和，$C_k = \\sum_{j=1}^{k} \\sigma_j^2$。总和为 $C_q = F^2$。\n4. 找到使 $C_r \\ge (1-\\tau^2)C_q$ 成立的最小索引 $r$。这就是所期望的秩。\n5. 一旦找到这个最小秩 $r$，就使用其定义计算相应的误差 $E_r$：$E_r = \\sqrt{(C_q - C_r)/C_q}$。\n\n将此完整过程应用于每个测试用例，以确定数对 $[r, E_r]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the adaptive low-rank approximation for matrix blocks\n    arising in a computational electromagnetics context for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (m, n, a, D, delta_x, k, eta, tau)\n    test_cases = [\n        (40, 40, 0.2, 1.0, 0.03, 3.0, 2.5, 1e-3),   # Case 1\n        (4, 4, 0.1, 0.6, 0.02, 3.0, 2.5, 1e-3),     # Case 2\n        (50, 50, 0.2, 0.05, 0.03, 3.0, 2.5, 1e-3),  # Case 3\n        (60, 60, 0.2, 1.0, 0.05, 20.0, 2.5, 1e-3),  # Case 4\n        (40, 40, 0.2, 1.2, 0.03, 3.0, 2.5, 1e-6),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n, a, D, delta_x, k, eta, tau = case\n        q = min(m, n)\n\n        # Step 1: Apply admissibility criterion\n        if D / a  eta:\n            # Inadmissible block: use full rank, error is zero by definition\n            rank = q\n            error = 0.0\n            results.append([rank, error])\n            continue\n\n        # Admissible block: proceed with matrix construction and SVD\n        \n        # Step 2: Construct point clusters X and Y\n        if m > 1:\n            x_coords = np.linspace(-a / 2, a / 2, m)\n        else:\n            x_coords = np.array([0.0])\n        \n        if n > 1:\n            y_coords_base = np.linspace(-a / 2, a / 2, n)\n        else:\n            y_coords_base = np.array([0.0])\n\n        # Create 3D point arrays\n        X = np.zeros((m, 3))\n        X[:, 0] = x_coords\n\n        Y = np.zeros((n, 3))\n        Y[:, 0] = y_coords_base + delta_x\n        Y[:, 2] = D\n        \n        # Step 3: Form the block matrix A\n        # Use broadcasting for efficient computation of pairwise distances\n        # diff will have shape (m, n, 3)\n        diff = X[:, np.newaxis, :] - Y[np.newaxis, :, :]\n        # r_norm will have shape (m, n)\n        r_norm = np.linalg.norm(diff, axis=2)\n\n        # Evaluate the Helmholtz Green's function, G(r) = exp(i*k*r) / (4*pi*r)\n        # The condition D > 0 ensures r_norm is never zero.\n        A = np.exp(1j * k * r_norm) / (4 * np.pi * r_norm)\n\n        # Step 4: Compute SVD and determine adaptive rank\n        # We only need the singular values\n        s = np.linalg.svd(A, compute_uv=False)\n        \n        s_sq = s**2\n        f_norm_sq = np.sum(s_sq)\n\n        if f_norm_sq == 0:\n            # The matrix is a zero matrix. Rank is 0. Problem asks for r in {1..q}.\n            # A rank-1 approximation (the zero matrix) is exact.\n            rank = 1\n            error = 0.0\n        else:\n            # Use the cumulative sum of squared singular values to find the rank\n            # efficiently. We seek the smallest r such that the energy captured \n            # by the first r singular values, sum(s_sq[:r]), is at least\n            # (1 - tau^2) of the total energy.\n            cum_s_sq = np.cumsum(s_sq)\n            threshold = (1 - tau**2) * f_norm_sq\n            \n            # Find the first index i where cum_s_sq[i] >= threshold.\n            # The rank r is i + 1. np.searchsorted gives this index directly.\n            # 'side=\"left\"' is the default but included for clarity.\n            rank_idx = np.searchsorted(cum_s_sq, threshold, side='left')\n            rank = rank_idx + 1\n\n            # Step 5: Calculate the final error for the determined rank\n            # The sum is over singular values from index 'rank' to the end.\n            err_norm_sq = np.sum(s_sq[rank:])\n            error = np.sqrt(err_norm_sq / f_norm_sq)\n\n        results.append([rank, error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3313470"}, {"introduction": "虽然标准的分层矩阵通常将几何上的“近场”块视为不可压缩的稠密块，但这其实是一种简化。本练习将揭示一个更深刻的原理：可压缩性源于底层积分核的光滑性。通过在光滑的曲线几何上使用高阶多项式基函数，您将发现即使是紧邻的相互作用块也能变得高度可压缩，从而挑战传统的近场/远场二分法。[@problem_id:3313460]", "problem": "考虑在自由空间中，对一个理想电导体物体使用矩量法 (MoM) 对电场积分方程 (EFIE) 进行离散化时所用的两个光滑曲面片。从自由空间中的麦克斯韦方程组\n$$\\nabla \\times \\mathbf{E} = -\\mu_0 \\frac{\\partial \\mathbf{H}}{\\partial t}, \\quad \\nabla \\times \\mathbf{H} = \\epsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t}, \\quad \\nabla \\cdot \\mathbf{E} = 0, \\quad \\nabla \\cdot \\mathbf{H} = 0,$$\n出发，并考虑到三维亥姆霍兹方程存在时谐自由空间格林函数，\n$$G_k(\\mathbf{x},\\mathbf{y}) = \\frac{e^{\\mathrm{i} k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4\\pi \\|\\mathbf{x}-\\mathbf{y}\\|},$$\n其中波数 $k = 2\\pi/\\lambda$，EFIE 导出了一个边界积分算子，其阻抗矩阵元将一个曲面片上的基函数与另一个曲面片上的测试函数耦合起来。在分层矩阵中，当底层核函数限制在相关的几何簇上足够光滑时，矩阵被分割成块，并用低秩形式进行近似。经典的可容许性准则对簇 $X$ 和 $Y$ 施加了分离条件，例如\n$$\\max\\{\\operatorname{diam}(X), \\operatorname{diam}(Y)\\} \\leq \\eta \\operatorname{dist}(X,Y),$$\n但通常假设不满足此条件的所谓近场块是内在满秩的。本问题要求您通过分析光滑性如何降低 MoM 阻抗矩阵中的局部数值秩，来证明当几何和基函数是高阶曲线时，即使是近场块在多项式 ($p$) 加密下也会变得可压缩。\n\n您将使用一个标量单层算子代理，它能捕捉到本质的光滑性机制。设两个边长为 $L$ 米的相邻方形曲面片由曲线映射\n$$\\mathbf{x}_1(\\xi,\\eta) = \\begin{bmatrix} \\frac{L}{2}\\,\\xi + c\\,\\frac{L}{2}\\,\\frac{\\xi^3 - \\xi}{3} \\\\ \\frac{L}{2}\\,\\eta + c\\,\\frac{L}{2}\\,\\frac{\\eta^3 - \\eta}{3} \\\\ 0 \\end{bmatrix}, \\quad \\mathbf{x}_2(\\xi',\\eta') = \\begin{bmatrix} \\frac{L}{2}\\,\\xi' + c\\,\\frac{L}{2}\\,\\frac{{\\xi'}^3 - \\xi'}{3} \\\\ \\frac{L}{2}\\,\\eta' + c\\,\\frac{L}{2}\\,\\frac{{\\eta'}^3 - \\eta'}{3} \\\\ d \\end{bmatrix},$$\n参数化，其中曲率参数 $c \\ge 0$，曲面片之间的间隙为 $d > 0$ 米。将相关的曲面雅可比行列式的大小记为\n$$J(\\xi,\\eta) = \\left\\|\\frac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{x}}{\\partial \\eta}\\right\\|.$$\n对于多项式阶数 $p$，在每个参数方向上使用具有 $n = p+1$ 个点的 Legendre–Gauss 求积。构建配置矩阵 $K \\in \\mathbb{C}^{n^2 \\times n^2}$，其元素为\n$$K_{rs} = \\sqrt{w_r J_1(\\xi_r,\\eta_r)} \\, G_k\\!\\big(\\mathbf{x}_1(\\xi_r,\\eta_r), \\mathbf{x}_2(\\xi'_s,\\eta'_s)\\big) \\, \\sqrt{w_s J_2(\\xi'_s,\\eta'_s)},$$\n其中 $(\\xi_r,\\eta_r)$ 和 $(\\xi'_s,\\eta'_s)$ 遍历第一个和第二个曲面片上的张量积求积节点，而 $w_r, w_s$ 是相应的乘积权重。这个 $K$ 矩阵模拟了两个不相交但间距很近的面板之间的近场阻抗子块。对于固定容差 $\\tau = 10^{-6}$，将 $K$ 的数值秩 $r_\\tau$ 定义为满足 $\\sigma_i \\ge \\tau \\,\\|K\\|_2$ 的奇异值 $\\sigma_i$ 的数量，其中 $\\|K\\|_2$ 是谱范数。\n\n任务：\n- 根据 $G_k(\\mathbf{x},\\mathbf{y})$ 在分离域上的光滑性以及曲线参数化，推导当 $d>0$ 时，受限核函数在参数 $(\\xi,\\eta,\\xi',\\eta')$ 中为何是解析的，并解释此解析性如何意味着离散化块 $K$ 的奇异值会快速衰减，且衰减情况与 $p$ 无关。\n- 对给定的映射，显式地计算雅可比因子 $J(\\xi,\\eta)$，并描述曲率参数 $c$ 如何影响度量和光滑性。\n- 实现每个方向 $n$ 点 ($n=p+1$) 的 Legendre–Gauss 求积，组装矩阵 $K$，并计算 $r_\\tau$ 和归一化秩分数 $f = r_\\tau / \\min\\{n^2, n^2\\}$。\n\n使用以下物理和数值参数：\n- 边长 $L = 0.5$ 米。\n- 波长 $\\lambda = 1.0$ 米，因此波数 $k = 2\\pi$ 弧度/米。\n- 用无量纲的秩分数 $f$（无单位数字）作答。\n\n测试组：\n- 情况 A：$p = 1$，$c = 0.00$，$d = 0.10$ 米（低阶，平坦几何）。\n- 情况 B：$p = 3$，$c = 0.20$，$d = 0.10$ 米（中等 $p$，曲线几何）。\n- 情况 C：$p = 6$，$c = 0.30$，$d = 0.10$ 米（高 $p$，强曲线几何）。\n- 情况 D：$p = 6$，$c = 0.30$，$d = 0.02$ 米（高 $p$，小间隙边界情况）。\n\n您的程序应产生单行输出，其中包含情况 A-D 的四个归一化秩分数 $f$，形式为用方括号括起来的逗号分隔列表（例如, $[f_A,f_B,f_C,f_D]$）。本问题不涉及角度；不需要角度单位。所有长度必须以米为单位处理。输出必须是无量纲浮点数。", "solution": "问题陈述经评估是有效的。它在科学上基于计算电磁学的原理，特别是矩量法和快速多极子/分层矩阵方法。该问题是适定的，提供了所有必要的数学定义、物理参数和一个清晰、明确的计算任务。该设置虽然是一个简化模型，但在该领域中是研究积分算子可压缩性的一个标准且信息丰富的代理。\n\n求解过程首先提供所要求的理论分析，然后推导必要的几何量，最后概述得出最终答案的数值实现。\n\n### 1. 理论分析：核函数解析性与低秩可压缩性\n\n问题的核心在于理解两个曲面片之间相互作用核函数的光滑性。这种相互作用由亥姆霍兹方程的自由空间格林函数控制，其表达式为\n$$\nG_k(\\mathbf{x},\\mathbf{y}) = \\frac{e^{\\mathrm{i} k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4\\pi \\|\\mathbf{x}-\\mathbf{y}\\|}.\n$$\n该函数是复值的，并且对于所有 $(\\mathbf{x}, \\mathbf{y}) \\in \\mathbb{R}^3 \\times \\mathbb{R}^3$ 都是解析的，除了在 $\\mathbf{x} = \\mathbf{y}$ 的对角集上，这将意味着 $\\|\\mathbf{x}-\\mathbf{y}\\| = 0$。原点处的奇点类型为 $1/r$。\n\n这两个曲面片由 $\\mathbf{x}_1(\\xi, \\eta)$ 和 $\\mathbf{x}_2(\\xi', \\eta')$ 参数化，其中参数 $(\\xi, \\eta, \\xi', \\eta')$ 属于紧致域 $[-1,1]^4$。参数化由以下公式给出：\n$$\n\\mathbf{x}_1(\\xi,\\eta) = \\begin{bmatrix} \\frac{L}{2}\\left(\\xi + c\\frac{\\xi^3 - \\xi}{3}\\right) \\\\ \\frac{L}{2}\\left(\\eta + c\\frac{\\eta^3 - \\eta}{3}\\right) \\\\ 0 \\end{bmatrix}, \\quad\n\\mathbf{x}_2(\\xi',\\eta') = \\begin{bmatrix} \\frac{L}{2}\\left(\\xi' + c\\frac{{\\xi'}^3 - \\xi'}{3}\\right) \\\\ \\frac{L}{2}\\left(\\eta' + c\\frac{{\\eta'}^3 - \\eta'}{3}\\right) \\\\ d \\end{bmatrix}.\n$$\n这些是多项式（因此是解析的）映射。关键步骤是分析第一个曲面片上的点 $\\mathbf{p}_1 = \\mathbf{x}_1(\\xi, \\eta)$ 和第二个曲面片上的点 $\\mathbf{p}_2 = \\mathbf{x}_2(\\xi', \\eta')$ 之间距离的平方：\n$$\n\\|\\mathbf{p}_1 - \\mathbf{p}_2\\|^2 = \\left(x_1-x_2\\right)^2 + \\left(y_1-y_2\\right)^2 + \\left(z_1-z_2\\right)^2.\n$$\n代入分量表达式，我们得到\n$$\n\\|\\mathbf{p}_1 - \\mathbf{p}_2\\|^2 = \\left[\\frac{L}{2}\\left(\\xi - \\xi' + c\\frac{(\\xi^3-\\xi)-(\\xi'^3-\\xi')}{3}\\right)\\right]^2 + \\left[\\frac{L}{2}\\left(\\eta - \\eta' + c\\frac{(\\eta^3-\\eta)-(\\eta'^3-\\eta')}{3}\\right)\\right]^2 + (0-d)^2.\n$$\n由于前两项是实数的平方，它们是非负的。第三项是 $d^2$。问题陈述 $d > 0$，这意味着对于任何参数 $(\\xi, \\eta, \\xi', \\eta')$ 的选择，距离的平方都是严格为正的：\n$$\n\\|\\mathbf{p}_1 - \\mathbf{p}_2\\|^2 \\geq d^2 > 0.\n$$\n这证实了两个曲面片在几何上是分离的。因此，格林函数的自变量 $\\|\\mathbf{x}_1(\\xi, \\eta) - \\mathbf{x}_2(\\xi', \\eta')\\|$ 永远不会达到零。\n\n受限核函数，当视为参数坐标的函数 $K_{cont.}(\\xi, \\eta, \\xi', \\eta') = G_k(\\mathbf{x}_1(\\xi, \\eta), \\mathbf{x}_2(\\xi', \\eta'))$ 时，是解析函数的复合：多项式参数化和在其奇点之外求值的格林函数 $G_k$。解析函数的复合是解析的。因此，核函数 $K_{cont.}$ 在紧致的四维域 $[-1, 1]^4$ 上是一个解析函数。\n\n逼近理论指出，紧致区间上的解析函数可以被多项式以指数衰减的误差逼近。这一点可以推广到多维情况。具有解析核的算子可以用具有指数精度的低秩可分展开来逼近。这类算子的奇异值呈指数衰减。离散化矩阵 $K$ 是一个积分算子的 Nyström 离散化，其核函数为 $k_{full} = \\sqrt{J_1 J_2} G_k$。我们将证明，雅可比行列式 $J_1$ 和 $J_2$ 也是多项式且非零，从而保持了整体的解析性。底层连续算子的快速奇异值衰减特性被其高阶求积离散化 $K$ 所继承。对于一个固定的容差 $\\tau$，捕获算子作用所需的数值秩 $r_\\tau$ 会在一个由核函数光滑性决定的值上饱和，而不是由矩阵大小 $n^2$ 决定。这意味着，当我们增加多项式阶数 $p$（从而 $n=p+1$），矩阵大小 $n^2 \\times n^2$ 会增长，但数值秩 $r_\\tau$ 保持大致恒定。因此，归一化秩分数 $f = r_\\tau / n^2$ 会迅速减小，表明随着 p-加密，矩阵块的可压缩性增强。\n\n### 2. 雅可比行列式推导与曲率效应\n\n为计算曲面雅可比行列式 $J(\\xi,\\eta) = \\|\\frac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{x}}{\\partial \\eta}\\|$，我们首先求出参数化 $\\mathbf{x}(\\xi, \\eta)$ 的切向量。为简单起见，我们省略下标 '1'，并将 z 坐标设为一个通用常数，因为雅可比行列式与此偏移量无关。\n$$\n\\mathbf{x}(\\xi,\\eta) = \\begin{bmatrix} \\frac{L}{2}\\left(\\xi + c\\frac{\\xi^3 - \\xi}{3}\\right) \\\\ \\frac{L}{2}\\left(\\eta + c\\frac{\\eta^3 - \\eta}{3}\\right) \\\\ z_0 \\end{bmatrix}\n$$\n偏导数为：\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial \\xi} = \\begin{bmatrix} \\frac{d}{d\\xi}\\left(\\frac{L}{2}\\left(\\xi + c\\frac{\\xi^3 - \\xi}{3}\\right)\\right) \\\\ 0 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{L}{2}\\left(1 + c\\left(\\xi^2 - \\frac{1}{3}\\right)\\right) \\\\ 0 \\\\ 0 \\end{bmatrix}\n$$\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial \\eta} = \\begin{bmatrix} 0 \\\\ \\frac{d}{d\\eta}\\left(\\frac{L}{2}\\left(\\eta + c\\frac{\\eta^3 - \\eta}{3}\\right)\\right) \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\frac{L}{2}\\left(1 + c\\left(\\eta^2 - \\frac{1}{3}\\right)\\right) \\\\ 0 \\end{bmatrix}\n$$\n切向量的叉积为：\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{x}}{\\partial \\eta} = \\begin{vmatrix} \\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\ \\frac{L}{2}(1 + c(\\xi^2 - 1/3))  0  0 \\\\ 0  \\frac{L}{2}(1 + c(\\eta^2 - 1/3))  0 \\end{vmatrix} = \\left(\\frac{L}{2}\\right)^2 \\left(1 + c\\left(\\xi^2 - \\frac{1}{3}\\right)\\right) \\left(1 + c\\left(\\eta^2 - \\frac{1}{3}\\right)\\right) \\mathbf{k}.\n$$\n该向量的模即为雅可比行列式 $J(\\xi, \\eta)$。所提供的 $c$ 值足够小 ($c  3$)，使得对于 $(\\xi, \\eta) \\in [-1,1]^2$，括号内的项保持为正，因此不需要取绝对值。\n$$\nJ(\\xi, \\eta) = \\frac{L^2}{4} \\left(1 + c\\left(\\xi^2 - \\frac{1}{3}\\right)\\right) \\left(1 + c\\left(\\eta^2 - \\frac{1}{3}\\right)\\right).\n$$\n曲率参数 $c$ 直接影响几何形状和度量。\n- 如果 $c=0$，$J(\\xi, \\eta) = L^2/4$，为一个常数。这对应于边长为 $L$ 的平坦方形曲面片的雅可比行列式。\n- 如果 $c > 0$，雅可比行列式不再是常数，而是随 $\\xi$ 和 $\\eta$ 呈多项式变化。这表明从参数域到物理曲面片的映射涉及面积元的局部拉伸和压缩。较大的 $c$ 值对应于与平坦正方形相比更显著的几何变形，即更高的曲率。这种更快的几何变化使得整个核函数的光滑性稍差，对于给定的容差，这会在数量上增加数值秩。然而，由于映射仍然是多项式（解析的），它不会破坏保证可压缩性的基本解析性。\n\n### 3. 数值实现\n\n对于每个测试用例，归一化秩分数 $f$ 的计算过程如下：\n\n1.  **设置参数**：对于给定的测试用例，设置多项式阶数 $p$、曲率 $c$ 和间隙 $d$。求积阶数为 $n = p+1$。\n2.  **求积法则**：使用标准数值库函数计算 $[-1,1]$ 上的 $n$ 点 Legendre-Gauss 节点和权重。\n3.  **张量积网格**：在每个曲面片上构建 $N=n^2$ 个求积点。曲面片1上的点 $\\{\\mathbf{p}_{1,r}\\}_{r=1}^N$ 是 $\\mathbf{x}_1(\\xi_i, \\eta_j)$，曲面片2上的点 $\\{\\mathbf{p}_{2,s}\\}_{s=1}^N$ 是 $\\mathbf{x}_2(\\xi_k, \\eta_l)$，其中 $(\\xi_i, \\eta_j, \\xi_k, \\eta_l)$ 是1D求积节点的组合。乘积权重 $\\{w_r\\}_{r=1}^N$ 是 $w_i w_j$。\n4.  **组装矩阵 K**：组装 $N \\times N$ 矩阵 $K$。其元素 $K_{rs}$ 将曲面片1上的点 $r$ 与曲面片2上的点 $s$ 耦合起来。\n    -   首先，为所有 $r, s \\in \\{1,...,N\\}$ 计算物理坐标 $\\mathbf{p}_{1,r}$ 和 $\\mathbf{p}_{2,s}$。\n    -   在曲面片1的所有点上计算雅可比行列式 $J_1$，并在曲面片2的所有点上计算 $J_2$。注意 $J_1(\\xi, \\eta) = J_2(\\xi', \\eta')$。\n    -   构建逐对距离矩阵 $D_{rs} = \\|\\mathbf{p}_{1,r} - \\mathbf{p}_{2,s}\\|$。\n    -   计算格林函数矩阵 $G_{rs} = G_k(\\mathbf{p}_{1,r}, \\mathbf{p}_{2,s})$。\n    -   计算缩放向量 $S_{1,r} = \\sqrt{w_r J_1(\\mathbf{p}_{1,r})}$ 和 $S_{2,s} = \\sqrt{w_s J_2(\\mathbf{p}_{2,s})}$。\n    -   组合这些元素：$K_{rs} = S_{1,r} \\cdot G_{rs} \\cdot S_{2,s}$。这可以高效地实现为 $K = \\text{diag}(S_1) \\cdot G \\cdot \\text{diag}(S_2)$。\n5.  **计算数值秩**：\n    -   计算 $K$ 的奇异值分解 (SVD) 以获得其奇异值 $\\sigma_i$。\n    -   谱范数 $\\|K\\|_2$ 是最大的奇异值 $\\sigma_1$。\n    -   对于容差 $\\tau=10^{-6}$，数值秩 $r_\\tau$ 是满足 $\\sigma_i \\ge \\tau \\sigma_1$ 的奇异值的数量。\n6.  **计算秩分数**：归一化秩分数为 $f = r_\\tau / N = r_\\tau / n^2$。为每个测试用例计算并报告此值。\n\n下面的 Python 程序实现了这个过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized numerical rank of a near-field collocation matrix\n    for a scalar integral operator between two curvilinear patches, demonstrating\n    compressibility under p-refinement.\n    \"\"\"\n\n    # --- Physical and Numerical Parameters ---\n    L = 0.5  # Side length in meters\n    lam = 1.0  # Wavelength in meters\n    k = 2 * np.pi / lam  # Wavenumber in rad/m\n    tau = 1e-6  # Tolerance for numerical rank\n\n    # --- Test Suite ---\n    test_cases = [\n        # (p, c, d)\n        (1, 0.00, 0.10),  # Case A: Low-order, flat\n        (3, 0.20, 0.10),  # Case B: Moderate p, curvilinear\n        (6, 0.30, 0.10),  # Case C: High p, strongly curvilinear\n        (6, 0.30, 0.02),  # Case D: High p, small gap\n    ]\n\n    def x_map(xi, eta, c, d_offset):\n        \"\"\"\n        Calculates the physical coordinates (x, y, z) for given parametric\n        coordinates (xi, eta), curvature c, and z-offset d_offset.\n        This function is vectorized to handle arrays of xi and eta.\n        \"\"\"\n        # Polynomial mapping function for a single coordinate\n        f_map = lambda u: L / 2.0 * (u + c * (u**3 - u) / 3.0)\n        \n        # Apply the mapping to xi and eta arrays\n        x_coords = f_map(xi)\n        y_coords = f_map(eta)\n        z_coords = np.full_like(x_coords, d_offset)\n        \n        # Stack into an (N, 3) array of coordinates\n        return np.stack((x_coords, y_coords, z_coords), axis=-1)\n\n    def jacobian(xi, eta, c):\n        \"\"\"\n        Calculates the surface Jacobian J(xi, eta) for the given parameterization.\n        This function is vectorized.\n        \"\"\"\n        # Derivative of the polynomial mapping function f_map\n        fp_map = lambda u: L / 2.0 * (1.0 + c * (u**2 - 1.0/3.0))\n        \n        # Jacobian is the product of the derivatives\n        return fp_map(xi) * fp_map(eta)\n\n    def compute_rank_fraction(p, c, d):\n        \"\"\"\n        Assembles the collocation matrix K and computes its normalized numerical rank.\n        \"\"\"\n        n = p + 1\n        N = n * n\n\n        # 1. Get Legendre-Gauss quadrature nodes and weights\n        nodes_1d, weights_1d = np.polynomial.legendre.leggauss(n)\n\n        # 2. Create tensor-product grids for the patches\n        xi = np.tile(nodes_1d, n)\n        eta = np.repeat(nodes_1d, n)\n        \n        # Product weights\n        w_prod = np.outer(weights_1d, weights_1d).flatten()\n\n        # 3. Generate physical coordinates for both patches\n        # Patch 1 (source) at z=0\n        points1 = x_map(xi, eta, c, 0.0)\n        # Patch 2 (target) at z=d\n        points2 = x_map(xi, eta, c, d)\n\n        # 4. Calculate Jacobians and scaling factors\n        # Jacobian is the same for both patches as the map is identical\n        J_vals = jacobian(xi, eta, c)\n        \n        # Scaling factors for matrix entries\n        S1 = np.sqrt(w_prod * J_vals)\n        S2 = np.sqrt(w_prod * J_vals)\n\n        # 5. Assemble the collocation matrix K\n        # Pairwise distance matrix (N x N)\n        # Broadcasting: points1 (N,1,3) - points2 (1,N,3) -> diff (N,N,3)\n        dist_matrix = np.linalg.norm(points1[:, np.newaxis, :] - points2[np.newaxis, :, :], axis=2)\n        \n        # Green's function matrix\n        G = np.exp(1j * k * dist_matrix) / (4 * np.pi * dist_matrix)\n        \n        # Apply scaling to form the final matrix K\n        K = S1[:, np.newaxis] * G * S2[np.newaxis, :]\n\n        # 6. Compute singular values and numerical rank\n        # We only need the singular values, not the vectors\n        sv = np.linalg.svd(K, compute_uv=False)\n        \n        # Spectral norm is the largest singular value\n        spectral_norm = sv[0]\n        \n        # Numerical rank is the count of singular values above the threshold\n        r_tau = np.sum(sv >= tau * spectral_norm)\n        \n        # 7. Calculate normalized rank fraction\n        f = r_tau / N\n        return f\n\n    results = []\n    for p_val, c_val, d_val in test_cases:\n        f_val = compute_rank_fraction(p_val, c_val, d_val)\n        results.append(f_val)\n    \n    # Print the final result in the required format\n    print(f\"[{','.join(f'{res:.4f}' for res in results)}]\")\n\nsolve()\n```", "id": "3313460"}, {"introduction": "在高频情况下，亥姆霍兹核的振荡特性会破坏远场块的低秩属性，这对标准的分层矩阵方法构成了重大挑战。本实践将介绍一种强大的解决方案：平面波富集，它通过分解并消除主要的振荡相位来恢复可压缩性。您将实现该技术并探索一种与之对应的方向性可纳性准则，从而深入了解现代高频快速算法。[@problem_id:3313454]", "problem": "您将为计算电磁学中的二维时谐边界积分算子实现并分析一个简化的方向性分层矩阵模型。该模型专注于理解平面波富集边界基如何影响非对角交互块的分层可压缩性，并在高波数下改变可纳性准则。您的研究必须从基于物理的定义出发，数值化地量化由富集引起的秩降低，同时评估基于相位提取的方向性准则所引起的可纳性变化。\n\n使用以下基本基础：考虑波数为 $k$（单位：$\\mathrm{m}^{-1}$）的二维亥姆霍兹方程。二维亥姆霍茲算子的自由空间格林函数是第一类汉克尔函数 $H_0^{(1)}$，边界点 $\\mathbf{x}$ 和 $\\mathbf{y}$ 之间的单层边界积分核由下式给出\n$$\nG_k(\\mathbf{x},\\mathbf{y}) \\;=\\; \\frac{\\mathrm{i}}{4}\\, H_0^{(1)}\\!\\big( k\\,\\|\\mathbf{x}-\\mathbf{y}\\| \\big),\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数，$\\mathrm{i}$ 是虚数单位，且 $H_0^{(1)}$ 是对非负实数参数求值。对于对应两个良好分离的边界簇的非对角分层块，其数值秩取决于振荡相位 $k\\,\\|\\mathbf{x}-\\mathbf{y}\\|$ 和交互作用的角展。平面波富集通过将边界自由度与复指数相乘来修改边界基，这些复指数近似抵消了主导相位，留下一个更平滑的残余振幅。\n\n您的程序必须：\n- 通过在 $\\mathbb{R}^2$ 中采样 $N$ 个等距边界点来离散化一个半径为 $R$ 米的圆。角度使用弧度。\n- 将两个边界簇 $\\mathcal{A}$ 和 $\\mathcal{B}$ 定义为由采样点的索引范围指定的连续弧段。计算非对角交互块 $\\mathbf{M}\\in\\mathbb{C}^{n_{\\mathcal{A}}\\times n_{\\mathcal{B}}}$，其元素为 $M_{ij} = G_k(\\mathbf{x}_i,\\mathbf{y}_j)$，其中 $\\mathbf{x}_i\\in\\mathcal{A}$ 且 $\\mathbf{y}_j\\in\\mathcal{B}$。\n- 通过奇异值分解 (Singular Value Decomposition (SVD)) 计算 $\\mathbf{M}$ 的数值秩，使用相对容差 $\\varepsilon$：统计满足 $s_j/s_0 > \\varepsilon$ 的奇异值 $s_j$，其中 $s_0$ 是最大的奇异值。\n- 通过选择一个从 $\\mathcal{A}$ 的形心指向 $\\mathcal{B}$ 的形心的单位方向 $\\mathbf{u}$ 来构造一个平面波富集边界基，并定义对角调制矩阵\n$$\n\\mathbf{P}_{\\mathcal{A}} = \\operatorname{diag}\\!\\left( e^{-\\mathrm{i}\\,k\\,\\mathbf{u}\\cdot \\mathbf{x}_i} \\right),\\quad\n\\mathbf{P}_{\\mathcal{B}} = \\operatorname{diag}\\!\\left( e^{+\\mathrm{i}\\,k\\,\\mathbf{u}\\cdot \\mathbf{y}_j} \\right).\n$$\n形成富集块 $\\mathbf{M}' = \\mathbf{P}_{\\mathcal{A}}\\,\\mathbf{M}\\,\\mathbf{P}_{\\mathcal{B}}$ 并使用相同的容差计算其数值秩。\n- 确定对 $(\\mathcal{A},\\mathcal{B})$ 的两个可纳性布尔值：\n  1. 分层矩阵 (Hierarchical matrix (H-matrix)) 的几何可纳性：令 $\\operatorname{diam}(\\mathcal{C})$ 为簇 $\\mathcal{C}$ 中点之间的最大两两间距离，令 $\\operatorname{dist}(\\mathcal{A},\\mathcal{B})$ 为形心之间的距离。对于一个固定的参数 $\\eta>0$，如果满足以下条件，则声明为几何可纳：\n  $$\n  \\max\\!\\big(\\operatorname{diam}(\\mathcal{A}),\\operatorname{diam}(\\mathcal{B})\\big) \\;\\le\\; \\eta\\,\\operatorname{dist}(\\mathcal{A},\\mathcal{B}).\n  $$\n  2. 由平面波富集驱动的方向性高频可纳性：对于一个固定的常数 $c_{\\mathrm{dir}}>0$，如果满足以下条件，则声明为方向性可纳：\n  $$\n  k\\,\\frac{\\max\\!\\big(\\operatorname{diam}(\\mathcal{A}),\\operatorname{diam}(\\mathcal{B})\\big)^2}{\\operatorname{dist}(\\mathcal{A},\\mathcal{B})} \\;\\le\\; c_{\\mathrm{dir}}.\n  $$\n  该准则确保了在方向性线性化下的二阶相位误差保持较小，从而在高频状态下稳定了富集后的低秩行为。\n\n单位和角度：\n- 距离 $\\|\\mathbf{x}-\\mathbf{y}\\|$、半径 $R$、直径和形心距离必须以米为单位。\n- 波数 $k$ 必须以 $\\mathrm{m}^{-1}$ 为单位。\n- 所有角度必须以弧度为单位。\n\n为以下测试套件实现计算，该套件基于一个半径为 $R$、有 $N$ 个边界点的圆，使用相对SVD容差 $\\varepsilon$、几何参数 $\\eta$ 和方向性参数 $c_{\\mathrm{dir}}$：\n\n- 测试用例1（理想情况，中度振荡，良好分离）：\n  - $R=1.0$, $N=160$, $\\mathcal{A}$ 索引 $[0,1,\\dots,39]$, $\\mathcal{B}$ 索引 $[80,81,\\dots,119]$,\n  - $k=5.0$, $\\varepsilon=10^{-3}$, $\\eta=2.0$, $c_{\\mathrm{dir}}=2.0$.\n- 测试用例2（大 k 值，良好分离，预期方向性富集会降低秩）：\n  - $R=1.0$, $N=160$, $\\mathcal{A}$ 索引 $[0,\\dots,39]$, $\\mathcal{B}$ 索引 $[80,\\dots,119]$,\n  - $k=50.0$, $\\varepsilon=10^{-3}$, $\\eta=2.0$, $c_{\\mathrm{dir}}=2.0$.\n- 测试用例3（小 k 值接近静态极限，两个秩都很小）：\n  - $R=1.0$, $N=160$, $\\mathcal{A}$ 索引 $[0,\\dots,39]$, $\\mathcal{B}$ 索引 $[80,\\dots,119]$,\n  - $k=0.5$, $\\varepsilon=10^{-3}$, $\\eta=2.0$, $c_{\\mathrm{dir}}=2.0$.\n- 测试用例4（大 k 值但簇分离不佳；富集不充分；方向性可纳性不满足）：\n  - $R=1.0$, $N=160$, $\\mathcal{A}$ 索引 $[0,\\dots,39]$, $\\mathcal{B}$ 索引 $[40,\\dots,79]$,\n  - $k=50.0$, $\\varepsilon=10^{-3}$, $\\eta=2.0$, $c_{\\mathrm{dir}}=2.0$.\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每个测试用例的结果必须是一个包含四个条目的列表，顺序为 $[\\text{rank\\_base},\\text{rank\\_enriched},\\text{geom\\_adm},\\text{dir\\_adm}]$，其中 $\\text{rank\\_base}$ 和 $\\text{rank\\_enriched}$ 是整数，而 $\\text{geom\\_adm}$ 和 $\\text{dir\\_adm}$ 是布尔值。例如，总输出格式必须为\n$$\n[[\\![r_1^{\\mathrm{base}}, r_1^{\\mathrm{enr}}, \\text{True}, \\text{False}]\\!],\\,[\\![r_2^{\\mathrm{base}}, r_2^{\\mathrm{enr}}, \\text{True}, \\text{True}]\\!],\\,\\dots]\n$$\n不带任何额外文本。", "solution": "我们从二维空间中时谐场的亥姆霍兹方程出发，它导出了单层边界积分算子的自由空间格林函数 $G_k(\\mathbf{x},\\mathbf{y}) = \\frac{\\mathrm{i}}{4} H_0^{(1)}(k\\|\\mathbf{x}-\\mathbf{y}\\|)$。函数 $H_0^{(1)}$ 编码了振荡行为，其相位近似为 $k\\|\\mathbf{x}-\\mathbf{y}\\|$，对于大的参数，其振幅以 $\\big(k\\|\\mathbf{x}-\\mathbf{y}\\|\\big)^{-1/2}$ 的形式衰减。分层矩阵 (Hierarchical matrix (H-matrix)) 通过将自由度细分为簇，并用低秩块来近似良好分离的交互作用，从而表示积分算子。对于中低波数 $k$，两个簇 $\\mathcal{A}$ 和 $\\mathcal{B}$ 之间的块是可压缩的，因为核函数在块域上是光滑的。对于高波数 $k$，除非考虑方向性相位，否则振荡会增加数值秩。\n\n为了理解方向性富集，考虑两个簇 $\\mathcal{A}$ 和 $\\mathcal{B}$，其形心分别为 $\\mathbf{c}_{\\mathcal{A}}$ 和 $\\mathbf{c}_{\\mathcal{B}}$，定义 $\\mathbf{d} = \\mathbf{c}_{\\mathcal{B}} - \\mathbf{c}_{\\mathcal{A}}$ 和单位向量 $\\mathbf{u} = \\mathbf{d}/\\|\\mathbf{d}\\|$。对于 $\\mathbf{x}\\in\\mathcal{A}$ 和 $\\mathbf{y}\\in\\mathcal{B}$，记作 $\\mathbf{x} = \\mathbf{c}_{\\mathcal{A}} + \\boldsymbol{\\xi}$ 和 $\\mathbf{y} = \\mathbf{c}_{\\mathcal{B}} + \\boldsymbol{\\eta}$，其中 $\\|\\boldsymbol{\\xi}\\| \\le \\operatorname{diam}(\\mathcal{A})/2$ 且 $\\|\\boldsymbol{\\eta}\\| \\le \\operatorname{diam}(\\mathcal{B})/2$。距离的一阶展开式给出\n$$\n\\|\\mathbf{x}-\\mathbf{y}\\| \\;=\\; \\|\\mathbf{d} + (\\boldsymbol{\\xi} - \\boldsymbol{\\eta})\\| \\;\\approx\\; \\|\\mathbf{d}\\| + \\mathbf{u}\\cdot(\\boldsymbol{\\xi} - \\boldsymbol{\\eta}) + \\mathcal{O}\\!\\left( \\frac{\\|\\boldsymbol{\\xi} - \\boldsymbol{\\eta}\\|^2}{\\|\\mathbf{d}\\|}\\right).\n$$\n主导振荡相位 $k\\,\\|\\mathbf{x}-\\mathbf{y}\\|$ 近似为\n$$\nk\\,\\|\\mathbf{x}-\\mathbf{y}\\| \\;\\approx\\; k\\,\\|\\mathbf{d}\\| + k\\,\\mathbf{u}\\cdot\\boldsymbol{\\xi} - k\\,\\mathbf{u}\\cdot\\boldsymbol{\\eta} + \\mathcal{O}\\!\\left(k\\,\\frac{\\|\\boldsymbol{\\xi} - \\boldsymbol{\\eta}\\|^2}{\\|\\mathbf{d}\\|}\\right).\n$$\n因此，如果我们分别用平面波 $e^{-\\mathrm{i}k\\,\\mathbf{u}\\cdot\\mathbf{x}}$ 和 $e^{+\\mathrm{i}k\\,\\mathbf{u}\\cdot\\mathbf{y}}$ 对 $\\mathcal{A}$ 和 $\\mathcal{B}$ 中的边界自由度进行预调制，那么变换后的核函数会获得一个由常数 $k\\,\\|\\mathbf{d}\\|$ 主导的残余相位，而对 $\\boldsymbol{\\xi}$ 和 $\\boldsymbol{\\eta}$ 的依赖性变得弱得多，其二阶误差量级为 $k\\,\\|\\boldsymbol{\\xi}-\\boldsymbol{\\eta}\\|^2/\\|\\mathbf{d}\\|$。这个残余核函数在块上变化缓慢，从而降低了数值秩。这种降低的有效性取决于二阶项的大小，这提示了一个方向性可纳性准则\n$$\nk\\,\\frac{\\max\\!\\big(\\operatorname{diam}(\\mathcal{A}),\\operatorname{diam}(\\mathcal{B})\\big)^{2}}{\\|\\mathbf{d}\\|} \\;\\le\\; c_{\\mathrm{dir}},\n$$\n对于某个固定常数 $c_{\\mathrm{dir}}$，保证了方向性线性化误差保持较小。经典几何可纳性准则\n$$\n\\max\\!\\big(\\operatorname{diam}(\\mathcal{A}),\\operatorname{diam}(\\mathcal{B})\\big) \\;\\le\\; \\eta\\,\\|\\mathbf{d}\\|\n$$\n确保了非振荡的光滑性，但它与 $k$ 无关，也未解决高波数 $k$ 时的相位振荡问题。\n\n算法设计：\n- 使用 $N$ 个等距角度 $\\theta_j = 2\\pi j / N$（其中 $j=0,\\dots,N-1$）在半径为 $R$ 米的圆上采样，得到点 $\\mathbf{p}_j = (R\\cos\\theta_j, R\\sin\\theta_j)$。\n- 通过索引范围选择簇 $\\mathcal{A}$ 和 $\\mathcal{B}$，得到点集 $\\{\\mathbf{x}_i\\}$ 和 $\\{\\mathbf{y}_j\\}$，其元素数量分别为 $n_{\\mathcal{A}}$ 和 $n_{\\mathcal{B}}$。通过最大化每个簇内的两两间欧几里得距离来计算直径，通过 $\\|\\mathbf{c}_{\\mathcal{B}} - \\mathbf{c}_{\\mathcal{A}}\\|$ 计算形心距离。\n- 使用 $G_k(\\mathbf{x}_i,\\mathbf{y}_j) = \\frac{\\mathrm{i}}{4}\\, H_0^{(1)}(k\\,\\|\\mathbf{x}_i-\\mathbf{y}_j\\|)$ 形成复矩阵块 $\\mathbf{M}$。为确保数值稳定性，请注意对于小参数，$H_0^{(1)}$ 近似为 $\\sim \\frac{2\\mathrm{i}}{\\pi}\\ln(k\\,\\|\\mathbf{x}-\\mathbf{y}\\|)$ 加上有界项，但我们的测试套件通过使用非对角块来避免奇异或近奇异的配置。\n- 通过奇异值分解 (SVD) 计算数值秩，统计相对于最大奇异值大于相对阈值 $\\varepsilon$ 的奇异值数量。\n- 通过 $\\mathbf{M}' = \\mathbf{P}_{\\mathcal{A}}\\,\\mathbf{M}\\,\\mathbf{P}_{\\mathcal{B}}$ 计算富集块，其中 $\\mathbf{P}_{\\mathcal{A}} = \\operatorname{diag}\\!\\left(e^{-\\mathrm{i}k\\,\\mathbf{u}\\cdot\\mathbf{x}_i}\\right)$ 且 $\\mathbf{P}_{\\mathcal{B}} = \\operatorname{diag}\\!\\left(e^{+\\mathrm{i}k\\,\\mathbf{u}\\cdot\\mathbf{y}_j}\\right)$，$\\mathbf{u}$ 是从 $\\mathbf{c}_{\\mathcal{A}}$ 到 $\\mathbf{c}_{\\mathcal{B}}$ 的单位向量。\n- 评估可纳性布尔值：\n  - 几何可纳性：$\\max(\\operatorname{diam}(\\mathcal{A}),\\operatorname{diam}(\\mathcal{B})) \\le \\eta\\,\\operatorname{dist}(\\mathcal{A},\\mathcal{B})$。\n  - 方向性可纳性：$k\\,\\max(\\operatorname{diam}(\\mathcal{A}),\\operatorname{diam}(\\mathcal{B}))^{2}/\\operatorname{dist}(\\mathcal{A},\\mathcal{B}) \\le c_{\\mathrm{dir}}$。\n\n测试套件理据：\n- 测试用例1使用 $k=5.0$ 和相对的弧段，产生中度振荡和强的几何分离；两个准则很可能都满足；富集可能会略微降低秩。\n- 测试用例2使用 $k=50.0$ 和相对的弧段；几何可纳性成立，但振荡会提高秩；方向性富集应能显著降低秩，并且如果二阶误差有界，方向性可纳性应成立。\n- 测试用例3使用 $k=0.5$，接近静态状态；预期两个秩都很小，并且满足可纳性准则。\n- 测试用例4使用 $k=50.0$ 但相邻的弧段减小了形心距离并增大了直径；根据 $\\eta$ 的值，几何可纳性可能会不满足或处于临界状态，而对于给定的 $c_{\\mathrm{dir}}$，方向性可纳性应不满足；即使在富集之后，秩仍然很高。\n\n最终输出必须将四个测试用例的结果聚合为单个 Python 列表，该列表包含四个子列表，每个子列表的形式为 $[\\text{rank\\_base},\\text{rank\\_enriched},\\text{geom\\_adm},\\text{dir\\_adm}]$，打印时不带任何额外文本，并与指定格式匹配。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\ndef points_on_circle(N: int, R: float) -> np.ndarray:\n    \"\"\"Generate N points uniformly on a circle of radius R in 2D.\"\"\"\n    angles = np.linspace(0.0, 2.0 * np.pi, N, endpoint=False)\n    x = R * np.cos(angles)\n    y = R * np.sin(angles)\n    pts = np.stack([x, y], axis=1)\n    return pts\n\ndef helmholtz_2d_block(k: float, A_pts: np.ndarray, B_pts: np.ndarray) -> np.ndarray:\n    \"\"\"Construct the 2D Helmholtz single-layer off-diagonal block using H_0^{(1)}.\"\"\"\n    # Compute pairwise distances between points in A and B\n    # A_pts: (m,2), B_pts: (n,2)\n    diff = A_pts[:, None, :] - B_pts[None, :, :]  # shape (m, n, 2)\n    r = np.linalg.norm(diff, axis=2)  # shape (m, n)\n    # Avoid numerical issues at r=0 (shouldn't occur for off-diagonal blocks). If occurs, set small epsilon.\n    r = np.where(r == 0.0, 1e-15, r)\n    # 2D Helmholtz single-layer kernel: i/4 * H_0^{(1)}(k r)\n    M = 1j / 4.0 * hankel1(0, k * r)\n    return M\n\ndef numerical_rank(M: np.ndarray, rel_tol: float) -> int:\n    \"\"\"Compute numerical rank by SVD with relative tolerance.\"\"\"\n    # Use full SVD; we only need singular values\n    s = np.linalg.svd(M, compute_uv=False)\n    if s.size == 0:\n        return 0\n    s0 = s[0] if s[0] != 0 else (np.max(s) if np.max(s) != 0 else 1.0)\n    threshold = rel_tol * s0\n    rank = int(np.sum(s > threshold))\n    return rank\n\ndef cluster_diameter(pts: np.ndarray) -> float:\n    \"\"\"Compute maximum pairwise distance within a set of points.\"\"\"\n    # Efficient via broadcasting for moderate sizes\n    diff = pts[:, None, :] - pts[None, :, :]\n    dists = np.linalg.norm(diff, axis=2)\n    return float(np.max(dists))\n\ndef centroid(pts: np.ndarray) -> np.ndarray:\n    \"\"\"Compute centroid (mean) of points.\"\"\"\n    return np.mean(pts, axis=0)\n\ndef directional_enrichment_block(k: float, A_pts: np.ndarray, B_pts: np.ndarray, M: np.ndarray) -> np.ndarray:\n    \"\"\"Apply plane-wave modulation to form enriched block.\"\"\"\n    cA = centroid(A_pts)\n    cB = centroid(B_pts)\n    d = cB - cA\n    norm_d = np.linalg.norm(d)\n    if norm_d == 0.0:\n        # Degenerate: no direction; return original\n        return M\n    u = d / norm_d\n    phase_A = np.exp(-1j * k * (A_pts @ u))\n    phase_B = np.exp(+1j * k * (B_pts @ u))\n    P_A = np.diag(phase_A)\n    P_B = np.diag(phase_B)\n    M_enr = P_A @ M @ P_B\n    return M_enr\n\ndef geometric_admissibility(diamA: float, diamB: float, distAB: float, eta: float) -> bool:\n    \"\"\"Standard geometric admissibility: max(diam) = eta * dist.\"\"\"\n    return max(diamA, diamB) = eta * distAB\n\ndef directional_admissibility(k: float, diamA: float, diamB: float, distAB: float, c_dir: float) -> bool:\n    \"\"\"Directional high-frequency admissibility: k * max(diam)^2 / dist = c_dir.\"\"\"\n    # Avoid division by zero\n    if distAB == 0.0:\n        return False\n    return (k * (max(diamA, diamB) ** 2) / distAB) = c_dir\n\ndef run_case(R: float, N: int, idxA_start: int, lenA: int, idxB_start: int, lenB: int,\n             k: float, svd_tol: float, eta: float, c_dir: float):\n    pts = points_on_circle(N, R)\n    # Wrap indices in case of overflow\n    idxA = np.arange(idxA_start, idxA_start + lenA) % N\n    idxB = np.arange(idxB_start, idxB_start + lenB) % N\n    A_pts = pts[idxA]\n    B_pts = pts[idxB]\n    # Build block\n    M = helmholtz_2d_block(k, A_pts, B_pts)\n    # Base rank\n    r_base = numerical_rank(M, svd_tol)\n    # Enriched block and rank\n    M_enr = directional_enrichment_block(k, A_pts, B_pts, M)\n    r_enr = numerical_rank(M_enr, svd_tol)\n    # Admissibility checks\n    diamA = cluster_diameter(A_pts)\n    diamB = cluster_diameter(B_pts)\n    distAB = float(np.linalg.norm(centroid(B_pts) - centroid(A_pts)))\n    adm_geom = geometric_admissibility(diamA, diamB, distAB, eta)\n    adm_dir = directional_admissibility(k, diamA, diamB, distAB, c_dir)\n    return [int(r_base), int(r_enr), bool(adm_geom), bool(adm_dir)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R, N, idxA_start, lenA, idxB_start, lenB, k, svd_tol, eta, c_dir)\n        (1.0, 160, 0, 40, 80, 40, 5.0, 1e-3, 2.0, 2.0),    # Test case 1\n        (1.0, 160, 0, 40, 80, 40, 50.0, 1e-3, 2.0, 2.0),   # Test case 2\n        (1.0, 160, 0, 40, 80, 40, 0.5, 1e-3, 2.0, 2.0),    # Test case 3\n        (1.0, 160, 0, 40, 40, 40, 50.0, 1e-3, 2.0, 2.0),   # Test case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3313454"}]}