{"hands_on_practices": [{"introduction": "深入理解区域分解方法性能的关键在于分析其在人工边界上的行为。本练习将通过一个简化的理想一维波动问题，引导你推导最优的传输条件。这个过程将揭示通过最小化界面反射来优化算法收敛速度的核心物理原理，为你后续的数值实现和理论分析打下坚实的基础。[@problem_id:3302402]", "problem": "考虑一个分层各向同性介质中的时谐麦克斯韦方程组，其中场仅在垂直于平面界面的法线方向上变化。设时间依赖关系为 $\\exp(-i \\omega t)$，其中角频率 $\\omega > 0$。一个计算域被位于 $x=0$ 处的平面界面 $\\Gamma$ 分割成两个不重叠的子域，其中左子域的向外单位法向量指向 $+x$ 方向。子域问题使用有限元法（FEM）求解，并通过一种优化 Schwarz 方法（OSM）类型的区域分解法（DDM）进行耦合，该方法在 $\\Gamma$ 上采用 Robin 传输条件。\n\n假设在法向入射下为横电极化，因此非零分量为切向电场 $E_{t}(x)$ 和切向磁场 $H_{t}(x)$。左子域在 $\\Gamma$ 的邻域内是局部均匀的，其介电常数为 $\\epsilon_{-}>0$，磁导率为 $\\mu_{-}>0$。右子域是 $x>0$ 处的一个半无限非均匀平面层堆，具有分段常数的 $\\epsilon(x)$ 和 $\\mu(x)$，并终止于一个半无限均匀半空间；记 $Y_{\\mathrm{in}}$ 为此半无限层堆的精确输入导纳，即出射波在 $x=0^{+}$ 处“看到”的导纳，也就是说，$\\Gamma$ 上的 Dirichlet-to-Neumann (DtN) 映射具有形式 $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$。\n\n在左子问题上，OSM Robin 传输条件为\n$n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$\n在 $\\Gamma$ 上，其中 $Z>0$ 是一个实数调节参数（“Robin 阻抗”）。对于法向入射的平面波，通过波在阻抗终端的反射来建模界面误差动力学，并将精确 DtN 导纳 $Y_{\\mathrm{in}}$ 与 Robin 导纳 $1/Z$ 之间的失配视为 DDM 迭代中界面反射的唯一来源。\n\n仅从频域麦克斯韦方程组及其在均匀介质中蕴含的平面波关系出发，完成以下任务：\n\n- 推导右侧为半无限均匀半空间时的输入导纳 $Y_{\\mathrm{in}}$，用局部材料参数表示。然后将非均匀半无限层堆的 $Y_{\\mathrm{in}}$ 定义为 $\\Gamma$ 处出射波迹的比值 $H_{t}(0^{+})/E_{t}(0^{+})$。\n\n- 使用参考右侧层堆精确输入阻抗的波变量，推导用 $n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$ 替代精确 DtN 条件 $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$ 所引起的界面反射系数 $\\mathcal{R}(Z)$，并将其表示为 $Z$ 和等效输入阻抗 $\\eta_{\\mathrm{in}} = 1/Y_{\\mathrm{in}}$ 的闭式函数。\n\n- 对实数 $Z>0$ 最小化 $|\\mathcal{R}(Z)|$，并求得对应的最优 Robin 参数 $Z_{\\mathrm{opt}}$。\n\n最后，将问题特殊化到一种科学上现实且具有实际重要性的情况，即界面 $\\Gamma$ 严格位于非均匀层堆的单个均匀层内部，该层的局部材料参数为 $\\mu$ 和 $\\epsilon$（这样，右子域内部的多次反射已被考虑）。在此假设下，仅用 $\\mu$ 和 $\\epsilon$ 表示你得到的 $Z_{\\mathrm{opt}}$ 的最终结果。请以单个闭式解析表达式的形式给出你的最终答案。最终答案中不包含单位。", "solution": "该问题要求为应用于一维时谐麦克斯韦方程组的区域分解法推导一个最优的 Robin 传输条件参数。这个过程涉及分析波在子域间界面上的反射。\n\n首先，我们建立控制方程。对于 $\\exp(-i \\omega t)$ 的时间依赖关系，在无源、各向同性的均匀介质中，麦克斯韦方程组为：\n$$\n\\nabla \\times \\vec{E} = i \\omega \\mu \\vec{H} \\\\\n\\nabla \\times \\vec{H} = -i \\omega \\epsilon \\vec{E}\n$$\n问题指定了横电（TE）极化，场仅在 $x$ 方向上变化，即 $E_t(x)$ 和 $H_t(x)$。为满足 $\\nabla \\cdot \\vec{E}=0$ 和 $\\nabla \\cdot \\vec{H}=0$ 对于一维场变化的要求，场必须纯粹与 $x$ 方向横向。我们考虑特定的极化方式，其中 $\\vec{E} = E_y(x) \\hat{y}$ 和 $\\vec{H} = H_z(x) \\hat{z}$。因此，切向场为 $E_t(x) = E_y(x)$ 和 $H_t(x) = H_z(x)$。一维麦克斯韦方程组变为：\n$$\n\\frac{d E_t}{dx} = i \\omega \\mu H_t \\\\\n\\frac{d H_t}{dx} = i \\omega \\epsilon E_t\n$$\n联立这些方程得到关于 $E_t$ 的亥姆霍兹方程：\n$$\n\\frac{d^2 E_t}{dx^2} + k^2 E_t = 0, \\quad \\text{其中 } k = \\omega \\sqrt{\\mu\\epsilon} \\text{ 是波数。}\n$$\n其通解是一个前向（向右传播）波和一个后向（向左传播）波的叠加：\n$$\nE_t(x) = E^+ \\exp(ikx) + E^- \\exp(-ikx)\n$$\n相应的磁场为：\n$$\nH_t(x) = \\frac{1}{i\\omega\\mu} \\frac{dE_t}{dx} = \\frac{k}{\\omega\\mu} \\left( E^+ \\exp(ikx) - E^- \\exp(-ikx) \\right)\n$$\n我们定义介质的内禀阻抗为 $\\eta = \\frac{\\omega\\mu}{k} = \\frac{\\omega\\mu}{\\omega\\sqrt{\\mu\\epsilon}} = \\sqrt{\\frac{\\mu}{\\epsilon}}$。磁场可以写成：\n$$\nH_t(x) = \\frac{1}{\\eta} \\left( E^+ \\exp(ikx) - E^- \\exp(-ikx) \\right)\n$$\n\n现在，我们解决具体任务。\n\n**1. 均匀半空间的输入导纳**\n\n考虑一个 $x>0$ 的半无限均匀半空间，其参数为 $\\mu_r, \\epsilon_r$。一束出射波从 $x=0$ 的界面传播到这个区域。物理上要求无穷远处没有波源，这施加了一个辐射条件，意味着不能有后向传播的波分量。因此，$E^- = 0$。$x>0$ 处的场是纯粹前向传播的：\n$$\nE_t(x) = E^+ \\exp(ik_r x) \\\\\nH_t(x) = \\frac{1}{\\eta_r} E^+ \\exp(ik_r x)\n$$\n其中 $k_r = \\omega\\sqrt{\\mu_r \\epsilon_r}$ 且 $\\eta_r = \\sqrt{\\mu_r / \\epsilon_r}$。问题将输入导纳 $Y_{\\mathrm{in}}$ 定义为这类出射波的 $H_t(0^+)/E_t(0^+)$ 之比。\n$$\nY_{\\mathrm{in}} = \\frac{H_t(0^+)}{E_t(0^+)} = \\frac{(1/\\eta_r) E^+ \\exp(0)}{E^+ \\exp(0)} = \\frac{1}{\\eta_r} = \\sqrt{\\frac{\\epsilon_r}{\\mu_r}}\n$$\n\n**2. 非均匀层堆的输入导纳**\n\n对于 $x>0$ 的半无限非均匀层堆，问题将输入导纳 $Y_{\\mathrm{in}}$ 定义为出射波在界面处总切向场的比值：$Y_{\\mathrm{in}} = H_t(0^+) / E_t(0^+)$。相应的输入阻抗为 $\\eta_{\\mathrm{in}} = 1/Y_{\\mathrm{in}} = E_t(0^+) / H_t(0^+)$。由于层堆内部的多次反射，即使对于无损耗的层，$\\eta_{\\mathrm{in}}$ 通常也是一个复数。\n\n**3. 界面反射系数 $\\mathcal{R}(Z)$**\n\n问题的核心是找到控制优化 Schwarz 方法收敛性的反射系数。该系数源于精确 Dirichlet-to-Neumann (DtN) 条件与近似 Robin 传输条件在界面 $\\Gamma$ 上的失配。我们将界面处的总场 $E_t, H_t$ 分解为相对于特性阻抗 $\\eta_{\\mathrm{in}}$ 的入射（$a$）和反射（$b$）分量：\n$$\nE_t = a + b \\\\\nH_t = \\frac{1}{\\eta_{\\mathrm{in}}}(a - b)\n$$\n反射系数定义为 $\\mathcal{R} = b/a$。这些总场必须满足所施加的 Robin 条件，该条件规定了终端的阻抗为 $Z$，即 $E_t = Z H_t$。将波变量表达式代入此条件：\n$$\na+b = Z \\left(\\frac{1}{\\eta_{\\mathrm{in}}}(a - b)\\right)\n$$\n$$\n\\eta_{\\mathrm{in}}(a+b) = Z(a-b)\n$$\n$$\na\\eta_{\\mathrm{in}} + b\\eta_{\\mathrm{in}} = aZ - bZ\n$$\n$$\na(\\eta_{\\mathrm{in}} - Z) = -b(Z + \\eta_{\\mathrm{in}})\n$$\n$$\n\\mathcal{R}(Z) = \\frac{b}{a} = -\\frac{\\eta_{\\mathrm{in}} - Z}{Z + \\eta_{\\mathrm{in}}} = \\frac{Z - \\eta_{\\mathrm{in}}}{Z + \\eta_{\\mathrm{in}}}\n$$\n此即为负载阻抗为 $Z$ 的传输线上的标准反射系数公式。\n\n**4. $|\\mathcal{R}(Z)|$ 的最小化**\n\n为优化收敛性，我们需对实数正参数 $Z$ 最小化反射系数的模 $|\\mathcal{R}(Z)|$。设输入阻抗为复数 $\\eta_{\\mathrm{in}} = R + iI$。\n$$\n|\\mathcal{R}(Z)|^2 = \\left| \\frac{Z - (R+iI)}{Z + (R+iI)} \\right|^2 = \\frac{|(Z-R) - iI|^2}{|(Z+R) + iI|^2} = \\frac{(Z-R)^2 + I^2}{(Z+R)^2 + I^2}\n$$\n为了求最小值，我们对 $Z$ 求导并令其为零。设 $f(Z) = |\\mathcal{R}(Z)|^2$。\n$$\n\\frac{df}{dZ} = \\frac{2(Z-R)((Z+R)^2 + I^2) - ((Z-R)^2 + I^2)2(Z+R)}{((Z+R)^2 + I^2)^2} = 0\n$$\n分子必须为零。对于无源介质，$\\Re(\\eta_{\\mathrm{in}}) = R \\ge 0$。假设 $R \\ne 0$：\n$$\n(Z-R)((Z+R)^2 + I^2) = (Z+R)((Z-R)^2 + I^2)\n$$\n展开并简化，可得：\n$$\n(Z^2-R^2)(2R) = I^2(2R)\n$$\n因为 $R \\neq 0$，我们可以除以 $2R$：\n$$\nZ^2 - R^2 = I^2 \\implies Z^2 = R^2 + I^2 = (\\Re(\\eta_{\\mathrm{in}}))^2 + (\\Im(\\eta_{\\mathrm{in}}))^2 = |\\eta_{\\mathrm{in}}|^2\n$$\n由于 $Z$ 必须为正，最优值为 $Z_{\\mathrm{opt}} = |\\eta_{\\mathrm{in}}|$。\n\n**5. 特殊化与最终答案**\n\n最后一步是将此结果应用于人工界面 $\\Gamma$ 位于参数为 $\\mu$ 和 $\\epsilon$ 的均匀层内部的情况。这等效于假设右子域是一个具有这些局部材料属性的均匀半空间。\n因此，在这种假设下，我们将整个非均匀层堆的复杂输入阻抗 $\\eta_{\\mathrm{in}}$ 替换为界面处介质的局部内禀阻抗：\n$$\n\\eta_{\\mathrm{in}} \\approx \\eta_{\\mathrm{local}} = \\sqrt{\\frac{\\mu}{\\epsilon}}\n$$\n该阻抗是一个实数正值。将此代入我们最优参数 $Z_{\\mathrm{opt}}$ 的表达式中：\n$$\nZ_{\\mathrm{opt}} = |\\eta_{\\mathrm{in}}| \\approx \\left| \\sqrt{\\frac{\\mu}{\\epsilon}} \\right| = \\sqrt{\\frac{\\mu}{\\epsilon}}\n$$\n这给出了仅用界面处局部材料参数 $\\mu$ 和 $\\epsilon$ 表示的最优 Robin 阻抗参数。", "answer": "$$\\boxed{\\sqrt{\\frac{\\mu}{\\epsilon}}}$$", "id": "3302402"}, {"introduction": "将理论转化为可执行的代码是计算科学中的关键一步。本练习要求你亲手实现一个优化Schwarz方法，以数值方式求解亥姆霍兹方程。你将构建一个完整的有限元区域分解程序，从而加深对算法迭代过程的理解，并直观地观察到传输参数的选择如何直接影响计算的收敛性能。[@problem_id:3302374]", "problem": "考虑在均匀、各向同性、有源介质中的时谐麦克斯韦方程组，其介电常数为 $\\epsilon$，磁导率为 $\\mu$。在频域中，方程组写作\n$$\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + i \\omega \\epsilon \\mathbf{E}, \\quad \\nabla \\times \\mathbf{E} = - i \\omega \\mu \\mathbf{H},\n$$\n其中 $\\mathbf{E}$ 和 $\\mathbf{H}$ 分别是电场和磁场，$\\mathbf{J}$ 是给定的电流密度，$\\omega$ 是角频率。在一维均匀介质中，通过横电 (TE) 或横磁 (TM) 降维，相关标量分量的控制方程简化为亥姆霍兹方程\n$$\n- \\frac{d^2 u}{dx^2} - k^2 u = f(x),\n$$\n该方程定义在有限区间 $x \\in [0, L]$ 上，其中 $u(x)$ 表示一个标量场分量，$k = \\omega \\sqrt{\\mu \\epsilon}$ 是波数，$f(x)$ 是从 $\\mathbf{J}$ 导出的标量源项。在物理边界上，施加与 Silver-Müller 辐射条件一致的一维一阶吸收边界条件：\n$$\n\\frac{du}{dx}(0) + i k\\, u(0) = 0, \\quad -\\frac{du}{dx}(L) + i k\\, u(L) = 0.\n$$\n我们旨在采用基于优化 Schwarz 方法的双子区域分解法来求解此边值问题。将区间 $[0, L]$ 划分为两个重叠的子区域 $\\Omega_1 = [0, a]$ 和 $\\Omega_2 = [b, L]$，重叠长度为 $\\delta = a - b \\ge 0$。用 $p \\in \\mathbb{C}$ 表示 Robin 传输参数。优化 Schwarz 迭代在人工界面上施加 Robin 型传输条件：\n$$\n\\frac{du_1}{dx}(a) + p\\, u_1(a) = -\\frac{du_2}{dx}(a) + p\\, u_2(a), \\quad -\\frac{du_2}{dx}(b) + p\\, u_2(b) = \\frac{du_1}{dx}(b) + p\\, u_1(b),\n$$\n其中 $u_1$ 和 $u_2$ 分别是子区域 $\\Omega_1$ 和 $\\Omega_2$ 上的解。在物理边界 $x=0$ 和 $x=L$ 处，保留吸收边界条件。该算法使用最新的数据来更新 Robin 传输条件，并在 $\\Omega_1$ 和 $\\Omega_2$ 上交替求解。\n\n从带 Robin 边界条件的一维亥姆霍兹方程的弱形式出发，推导在均匀网格上使用连续分段线性函数的有限元法。展示 Robin 边界项如何进入物理边界和人工界面上的双线性形式和线性形式。接着，实现一个程序，该程序：\n- 使用含 $N$ 个单元的 $[0, L]$ 的均匀剖分，为亥姆霍兹算子组装一维有限元矩阵。\n- 使用系数 $p$ 求解带 Robin 传输的双子区域优化 Schwarz 迭代，其中人工边界上的非齐次 Robin 数据如上所述在子区域间相等。\n- 使用源项 $f(x) = e^{i k x}$，并将子区域迭代解初始化为零。\n- 在每次迭代中，使用与各子区域外法线一致的单边导数构建界面数据，并通过计算两个传输失配量的最大范数来检查收敛性：\n$$\nr_1 = \\left(\\frac{du_1}{dx}(a) + p\\, u_1(a)\\right) - \\left(-\\frac{du_2}{dx}(a) + p\\, u_2(a)\\right), \\quad\nr_2 = \\left(-\\frac{du_2}{dx}(b) + p\\, u_2(b)\\right) - \\left(\\frac{du_1}{dx}(b) + p\\, u_1(b)\\right).\n$$\n当 $\\max(|r_1|, |r_2|)$ 小于给定的容差时，判定为收敛。\n\n最终输出必须是每个指定测试用例达到收敛所需的迭代次数（如果在最大迭代次数内未收敛，则为 $-1$）。输出中不需要物理单位，因为结果是无量纲的迭代次数。\n\n为以下测试套件实现您的解法：\n1. $L = 1.0$，$k = 20.0$，$p = i k$，重叠长度 $\\delta = 0.2$，$N = 400$，容差 $10^{-8}$，最大迭代次数 $200$。\n2. $L = 1.0$，$k = 20.0$，$p = 1.0$，重叠长度 $\\delta = 0.2$，$N = 400$，容差 $10^{-8}$，最大迭代次数 $200$。\n3. $L = 1.0$，$k = 40.0$，$p = i k$，重叠长度 $\\delta = 0.0$ (无重叠)，$N = 800$，容差 $10^{-8}$，最大迭代次数 $200$。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。", "solution": "### 弱形式推导\n我们从亥姆霍兹方程 $-u'' - k^2 u = f$ 出发，推导其在通用子区间 $[x_L, x_R]$ 上的弱形式。将方程乘以一个测试函数 $v$，并在区间上积分，然后使用分部积分法：\n$$\n\\int_{x_L}^{x_R} u'(x)v'(x) \\,dx - [u'(x)v(x)]_{x_L}^{x_R} - k^2 \\int_{x_L}^{x_R} u(x)v(x) \\,dx = \\int_{x_L}^{x_R} f(x)v(x) \\,dx\n$$\n边界项为 $-u'(x_R)v(x_R) + u'(x_L)v(x_L)$。我们将为每个子区域问题代入特定的边界条件。\n\n**子问题 1: $\\Omega_1 = [0, a]$**\n边界条件为：\n1.  物理边界 ($x=0$): $u_1'(0) = -i k u_1(0)$。\n2.  传输边界 ($x=a$): $u_1'(a) + p u_1(a) = g_1^{(n)}$，其中 $g_1^{(n)} = -u_2'^{(n)}(a) + p u_2^{(n)}(a)$。因此 $u_1'(a) = g_1^{(n)} - p u_1(a)$。\n\n将这些代入 $\\Omega_1$ 的边界项中：\n$$\n-u_1'(a)v(a) + u_1'(0)v(0) = -(g_1^{(n)} - p u_1(a))v(a) + (-i k u_1(0))v(0)\n$$\n整理后，$\\Omega_1$ 的弱形式为：求 $u_1 \\in H^1(\\Omega_1)$，使得对于所有 $v \\in H^1(\\Omega_1)$：\n$$\n\\int_{0}^{a} (u_1'v' - k^2 u_1v) \\,dx + p u_1(a)v(a) - i k u_1(0)v(0) = \\int_{0}^{a} fv \\,dx + g_1^{(n)} v(a)\n$$\n\n**子问题 2: $\\Omega_2 = [b, L]$**\n边界条件为：\n1.  传输边界 ($x=b$): $-u_2'(b) + p u_2(b) = g_2^{(n)}$，其中 $g_2^{(n)} = u_1'^{(n)}(b) + p u_1^{(n)}(b)$。因此 $u_2'(b) = p u_2(b) - g_2^{(n)}$。\n2.  物理边界 ($x=L$): $-u_2'(L) + i k u_2(L) = 0$，因此 $u_2'(L) = i k u_2(L)$。\n\n将这些代入 $\\Omega_2$ 的边界项中：\n$$\n-u_2'(L)v(L) + u_2'(b)v(b) = -(i k u_2(L))v(L) + (p u_2(b) - g_2^{(n)})v(b)\n$$\n整理后，$\\Omega_2$ 的弱形式为：求 $u_2 \\in H^1(\\Omega_2)$，使得对于所有 $v \\in H^1(\\Omega_2)$：\n$$\n\\int_{b}^{L} (u_2'v' - k^2 u_2v) \\,dx - i k u_2(L)v(L) + p u_2(b)v(b) = \\int_{b}^{L} fv \\,dx + g_2^{(n)} v(b)\n$$\n\n### 有限元离散化\n我们使用分段线性基函数 $\\phi_j(x)$ 对弱形式进行离散化，近似解为 $u_h(x) = \\sum_j U_j \\phi_j(x)$。这会将问题转化为每个子区域的线性代数方程组 $A \\mathbf{U} = \\mathbf{b}$。\n\n- **双线性形式**: 积分项 $\\int (u'v' - k^2 uv)$ 构成了标准的一维亥姆霍兹有限元矩阵，由单元刚度矩阵 $K^e$ 和质量矩阵 $M^e$ 组装而成。\n- **边界项**: Robin 边界条件项对系统矩阵和右端向量（RHS）有额外贡献。\n  - 对于 $\\Omega_1$：项 $- i k u_1(0)v(0)$ 为矩阵 $A_1$ 的第一个对角元素增加 $-ik$。项 $p u_1(a)v(a)$ 为 $A_1$ 的最后一个对角元素增加 $p$。\n  - 对于 $\\Omega_2$：项 $p u_2(b)v(b)$ 为矩阵 $A_2$ 的第一个对角元素增加 $p$。项 $- i k u_2(L)v(L)$ 为 $A_2$ 的最后一个对角元素增加 $-ik$。\n- **线性形式**: 源项 $\\int fv$ 构成了源向量。传输数据 $g_1^{(n)}$ 和 $g_2^{(n)}$ 分别加到 $b_1$ 的最后一个元素和 $b_2$ 的第一个元素上。\n\n### 算法实现\n该算法遵循并行（Jacobi 类型）Schwarz 迭代。\n1.  **初始化**: 定义网格和子区域。将子区域解向量 $U_1, U_2$ 初始化为零。预先组装每个子区域的有限元矩阵 $A_1, A_2$（包含边界条件的贡献）和源向量 $b_1, b_2$（不含传输数据）。\n2.  **迭代循环**:\n    a.  **计算传输数据**: 使用上一步的解 $U_1, U_2$ 和单边有限差分近似来计算传输数据 $g_1, g_2$。\n    b.  **求解子问题**: 将 $g_1, g_2$ 添加到对应的右端向量中，然后求解线性系统 $A_1 U_1^{\\text{new}} = b_1$ 和 $A_2 U_2^{\\text{new}} = b_2$。\n    c.  **检查收敛性**: 使用新解计算残差 $r_1, r_2$。若 $\\max(|r_1|, |r_2|)$ 小于容差，则算法收敛。\n    d.  **更新**: $U_1 \\leftarrow U_1^{\\text{new}}$, $U_2 \\leftarrow U_2^{\\text{new}}$。\n3.  **终止**: 若收敛则返回迭代次数，否则在达到最大迭代次数后返回-1。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_1d_helmholtz(nodes, k, h, f_func):\n    \"\"\"\n    Assembles the 1D FEM system matrix A and source vector b for -u'' - k^2 u = f.\n    Boundary condition terms are added separately.\n    \"\"\"\n    num_nodes = len(nodes)\n    \n    # Elemental matrices\n    Ke = (1 / h) * np.array([[1, -1], [-1, 1]])\n    Me = (h / 6) * np.array([[2, 1], [1, 2]])\n    Ae = Ke - k**2 * Me\n\n    # Assembly\n    A = np.zeros((num_nodes, num_nodes), dtype=np.complex128)\n    for i in range(num_nodes - 1):\n        A[i:i+2, i:i+2] += Ae\n\n    # Assemble RHS vector b using 2-point Gaussian Quadrature\n    b = np.zeros(num_nodes, dtype=np.complex128)\n    gq_pts = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gq_wts = np.array([1, 1])\n    \n    for i in range(num_nodes - 1):\n        x_i, x_ip1 = nodes[i], nodes[i+1]\n        phys_pts = 0.5 * (x_ip1 - x_i) * gq_pts + 0.5 * (x_ip1 + x_i)\n        \n        f_vals = f_func(phys_pts)\n        phi_i_vals = 0.5 * (1 - gq_pts)\n        phi_ip1_vals = 0.5 * (1 + gq_pts)\n        \n        integral_factor = 0.5 * h\n        b[i] += integral_factor * np.sum(gq_wts * f_vals * phi_i_vals)\n        b[i+1] += integral_factor * np.sum(gq_wts * f_vals * phi_ip1_vals)\n\n    return A, b\n\ndef run_schwarz_iteration(L, k, p, delta, N, tol, max_iter):\n    h = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    f_func = lambda x_val: np.exp(1j * k * x_val)\n\n    # Subdomain definitions\n    if delta >= 0:\n        b = (L - delta) / 2\n        a = b + delta\n        N2 = int(round(b / h))\n        N1 = int(round(a / h))\n    \n    nodes1 = x[0:N1+1]\n    nodes2 = x[N2:N+1]\n    \n    u1 = np.zeros(len(nodes1), dtype=np.complex128)\n    u2 = np.zeros(len(nodes2), dtype=np.complex128)\n    \n    # Pre-assemble matrices and source vectors\n    A1_base, b1_base = assemble_1d_helmholtz(nodes1, k, h, f_func)\n    A2_base, b2_base = assemble_1d_helmholtz(nodes2, k, h, f_func)\n    \n    # Add matrix contributions from boundary conditions\n    # Physical BC on Omega1 at x=0: u' + iku = 0 => add -ik to A[0,0]\n    A1_base[0, 0] += -1j * k\n    # Transmission BC on Omega1 at x=a: u' + pu = g1 => add p to A[-1,-1]\n    A1_base[-1, -1] += p\n    \n    # Transmission BC on Omega2 at x=b: -u' + pu = g2 => add p to A[0,0]\n    A2_base[0, 0] += p\n    # Physical BC on Omega2 at x=L: -u' + iku = 0 => add -ik to A[-1,-1]\n    A2_base[-1, -1] += -1j * k\n    \n    A1_sparse = sparse.csr_matrix(A1_base)\n    A2_sparse = sparse.csr_matrix(A2_base)\n\n    for n_iter in range(max_iter):\n        # 1. Compute transmission data g1, g2 from previous step\n        idx_a_in_2 = N1 - N2\n        u2_at_a = u2[idx_a_in_2]\n        du2dx_at_a = (u2[idx_a_in_2] - u2[idx_a_in_2 - 1]) / h if idx_a_in_2 > 0 else 0\n        g1 = -du2dx_at_a + p * u2_at_a\n        \n        idx_b_in_1 = N2\n        u1_at_b = u1[idx_b_in_1]\n        du1dx_at_b = (u1[idx_b_in_1 + 1] - u1[idx_b_in_1]) / h if idx_b_in_1  len(u1) -1 else 0\n        g2 = du1dx_at_b + p * u1_at_b\n        \n        # 2. Solve on subdomains\n        b1 = b1_base.copy()\n        b1[-1] += g1\n        \n        b2 = b2_base.copy()\n        b2[0] += g2\n        \n        u1_new = spsolve(A1_sparse, b1)\n        u2_new = spsolve(A2_sparse, b2)\n        \n        # 3. Check for convergence using new solutions\n        # Residual at x=a\n        du1new_dx_at_a = (u1_new[-1] - u1_new[-2]) / h\n        term1_r1 = du1new_dx_at_a + p * u1_new[-1]\n        \n        du2new_dx_at_a = (u2_new[idx_a_in_2] - u2_new[idx_a_in_2 - 1]) / h if idx_a_in_2 > 0 else 0\n        term2_r1 = -du2new_dx_at_a + p * u2_new[idx_a_in_2]\n        r1 = term1_r1 - term2_r1\n        \n        # Residual at x=b\n        du2new_dx_at_b = (u2_new[1] - u2_new[0]) / h if len(u2_new) > 1 else 0\n        term1_r2 = -du2new_dx_at_b + p * u2_new[0]\n        \n        du1new_dx_at_b = (u1_new[idx_b_in_1 + 1] - u1_new[idx_b_in_1]) / h if idx_b_in_1  len(u1_new) - 1 else 0\n        term2_r2 = du1new_dx_at_b + p * u1_new[idx_b_in_1]\n        r2 = term1_r2 - term2_r2\n        \n        residual = max(abs(r1), abs(r2))\n        \n        if residual  tol:\n            return n_iter + 1\n        \n        # 4. Update solutions\n        u1, u2 = u1_new, u2_new\n        \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, k, p, delta, N, tol, max_iter)\n        (1.0, 20.0, 1j * 20.0, 0.2, 400, 1e-8, 200),\n        (1.0, 20.0, 1.0, 0.2, 400, 1e-8, 200),\n        (1.0, 40.0, 1j * 40.0, 0.0, 800, 1e-8, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, k, p, delta, N, tol, max_iter = case\n        n_iters = run_schwarz_iteration(L, k, p, delta, N, tol, max_iter)\n        results.append(n_iters)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3302374"}, {"introduction": "实际的科学与工程计算往往需要更高级的技术，例如在不同子区域使用不同的多项式阶次（即 $p$-自适应）以提升效率。本练习聚焦于求解麦克斯韦方程组时的一个高级挑战：处理非协调网格上的矢量场耦合问题。你将设计并实现一个投影算子，以确保在不同阶次的有限元空间之间正确传递切向场分量，这是开发先进、高效的电磁仿真软件所需的一项核心技能。[@problem_id:3302373]", "problem": "考虑二维空间中的时谐麦克斯韦边界值问题，其中电场由一个矢量场表示，在没有表面电流的情况下，其切向分量必须跨越内部界面保持连续。在使用区域分解法 (DDM) 的有限元法 (FEM) 子结构技术中，计算域被划分为共享一个界面的多个子域。对于基于边的 Nédélec 型 $H(\\mathrm{curl})$（具有平方可积旋度的平方可积向量场的索伯列夫空间）有限元，电场沿内部边的切向迹必须在子域之间保持连续。在一个 $p$-自适应设置中，不同的子域可以使用不同的多项式阶数，这迫使我们设计投影算子，在不匹配的多项式空间之间传递切向迹，同时保持斯托克斯定理和麦克斯韦界面条件所要求的旋度协调性。\n\n假设两个子域共享一个直线界面 $\\Gamma$，该界面被参数化为区间 $[0,1]$，坐标为 $y \\in [0,1]$。对于多项式阶数 $p \\in \\mathbb{N}_0$，$\\Gamma$ 上的切向迹空间是关于 $y$ 的次数至多为 $p$ 的多项式空间。使用在 $[0,1]$ 上的标准正交基 $\\{\\phi_i(y)\\}_{i=0}^{p}$，定义如下：对于每个整数 $i \\ge 0$，令 $P_i(x)$ 为在 $[-1,1]$ 上的 $i$ 次勒让德多项式，其归一化条件为 $P_i(1)=1$。定义\n$$\n\\phi_i(y) \\equiv \\sqrt{2 i + 1}\\, P_i(2y - 1),\n$$\n该定义满足\n$$\n\\int_{0}^{1} \\phi_i(y) \\, \\phi_j(y) \\, dy = \\delta_{ij}\n$$\n对于所有整数 $i,j \\ge 0$。\n\n设左子域使用多项式阶数 $p_{\\mathrm{L}} \\in \\mathbb{N}_0$，右子域使用多项式阶数 $p_{\\mathrm{R}} \\in \\mathbb{N}_0$。来自左子域在 $\\Gamma$ 上的一个切向迹由其相对于基 $\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{L}}}$ 的系数向量 $\\mathbf{c}_{\\mathrm{L}} \\in \\mathbb{R}^{p_{\\mathrm{L}}+1}$ 表示；类似地，右迹使用相对于基 $\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{R}}}$ 的系数向量 $\\mathbf{c}_{\\mathrm{R}} \\in \\mathbb{R}^{p_{\\mathrm{R}}+1}$。$\\Gamma$ 上单位切向量的朝向在两个子域之间可能相反；用朝向参数 $\\sigma \\in \\{+1,-1\\}$ 表示，其中 $\\sigma=-1$ 表示右子域的局部切向量与左子域的相反，而 $\\sigma=+1$ 表示朝向相同。\n\n您的任务是：\n\n- 从麦克斯韦方程组的弱形式和斯托克斯定理出发，为一个线性投影算子（将 $\\mathbf{c}_{\\mathrm{L}} \\mapsto \\mathbf{c}_{\\mathrm{R}}$）建立一个有原则的、与基无关的条件，该算子必须满足以下要求：\n  1. 当 $\\sigma = -1$ 时，在全局组装中，界面对旋度矩的贡献相互抵消，即对于右迹空间中的每个测试多项式 $q$，左迹和右迹的带符号矩之和为零。\n  2. 当 $\\sigma = +1$ 时，对于来自公共迹空间的所有测试多项式，两边的切向矩相匹配。\n  您的公式必须仅依赖于与 $H(\\mathrm{curl})$ 协调性一致的切向矩守恒，并且不得假设任何先验的多项式阶数匹配。\n\n- 将您的公式具体化到多项式基 $\\{\\phi_i\\}$ 上，并推导出一个可实现的算法，该算法给定 $(p_{\\mathrm{L}}, p_{\\mathrm{R}}, \\sigma, \\mathbf{c}_{\\mathrm{L}})$，通过使用高斯-勒让德求积计算的 $[0,1]$ 上的数值组装内积来强制执行矩条件，从而计算 $\\mathbf{c}_{\\mathrm{R}}$。您的算法对于所有非负整数 $p_{\\mathrm{L}}$ 和 $p_{\\mathrm{R}}$ 以及两种朝向 $\\sigma \\in \\{+1,-1\\}$ 都必须是鲁棒的。\n\n- 将该算法实现为一个完整的可运行程序，在指定环境中执行以下操作：\n  1. 使用勒让德多项式在 $[0,1]$ 上构建标准正交基 $\\{\\phi_i\\}$。\n  2. 通过高斯-勒让德求积组装所需的内积矩阵，使用的求积阶数足以精确积分所有由次数最高为 $\\max(2 p_{\\mathrm{L}}, 2 p_{\\mathrm{R}})$ 的基函数乘积产生的多项式。\n  3. 对于下面的每个测试用例，从 $\\mathbf{c}_{\\mathrm{L}}$ 计算投影 $\\mathbf{c}_{\\mathrm{R}}$。\n  4. 通过检查矩抵消或匹配来验证界面处的旋度协调性，具体如下：\n     - 对于 $\\sigma=-1$，检查对于每个索引 $j \\in \\{0,1,\\dots,p_{\\mathrm{R}}\\}$，\n       $$\n       \\left| \\int_0^1 \\left(\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\, \\phi_i(y)\\right) \\, \\phi_j(y) \\, dy \\;+\\; \\int_0^1 \\left(\\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\, \\phi_k(y)\\right) \\, \\phi_j(y) \\, dy \\right| \\le \\varepsilon,\n       $$\n       容差为 $\\varepsilon = 10^{-10}$。\n     - 对于 $\\sigma=+1$，检查对于每个索引 $j \\in \\{0,1,\\dots,\\min(p_{\\mathrm{L}},p_{\\mathrm{R}})\\}$,\n       $$\n       \\left| \\int_0^1 \\left(\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\, \\phi_i(y)\\right) \\, \\phi_j(y) \\, dy \\;-\\; \\int_0^1 \\left(\\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\, \\phi_k(y)\\right) \\, \\phi_j(y) \\, dy \\right| \\le \\varepsilon,\n       $$\n       容差同样为 $\\varepsilon = 10^{-10}$。\n\n测试套件：\n\n- 情况 1（正常情况，从高阶到低阶，朝向相反）：$p_{\\mathrm{L}}=4$, $p_{\\mathrm{R}}=2$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.5,\\,-0.3,\\,0.2,\\,-0.4,\\,0.1\\,]^{\\top}$。\n- 情况 2（边界情况，均为最低阶，朝向相反）：$p_{\\mathrm{L}}=0$, $p_{\\mathrm{R}}=0$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.123456789\\,]^{\\top}$。\n- 情况 3（阶数相等，朝向相反）：$p_{\\mathrm{L}}=3$, $p_{\\mathrm{R}}=3$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.1,\\,0.2,\\,-0.1,\\,0.05\\,]^{\\top}$。\n- 情况 4（从低阶到高阶，朝向相同）：$p_{\\mathrm{L}}=2$, $p_{\\mathrm{R}}=5$, $\\sigma=+1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.7,\\,-0.25,\\,0.33\\,]^{\\top}$。\n- 情况 5（压力情况，强不协调，朝向相反）：$p_{\\mathrm{L}}=5$, $p_{\\mathrm{R}}=1$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.0,\\,1.0,\\,0.0,\\,-0.2,\\,0.3,\\,-0.1\\,]^{\\top}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[True,False,True]`），其中每个条目都是一个布尔值，指示相应情况是否在给定容差内满足各自的旋度协调性矩条件。不需要物理单位。不涉及角度。不涉及百分比。", "solution": "该问题要求为不匹配的多项式空间之间的向量场切向迹制定并实现一个投影算子，这是 $p$-自适应区域分解法在麦克斯韦方程组有限元分析中的一项常见任务。\n\n### 步骤 1：投影算子的构建\n\n计算域 $\\Omega$ 被划分为多个子域，包括一个左子域 $\\Omega_{\\mathrm{L}}$ 和一个右子域 $\\Omega_{\\mathrm{R}}$，它们共享一个公共界面 $\\Gamma$。对于 $H(\\mathrm{curl})$-协调有限元，必须在 $\\Gamma$ 上强制电场切向分量 $\\mathbf{E}_{\\tau}$ 的连续性。\n\n设 $\\mathbf{t}_{\\mathrm{L}}$ 和 $\\mathbf{t}_{\\mathrm{R}}$ 分别为在 $\\Gamma$ 上为左子域和右子域定义局部参数化的单位切向量。朝向参数 $\\sigma \\in \\{+1, -1\\}$ 通过 $\\mathbf{t}_{\\mathrm{R}} = \\sigma \\mathbf{t}_{\\mathrm{L}}$ 将它们关联起来。切向电场是向量量，由 $\\mathbf{E}_{\\tau, \\mathrm{L}} = u_{\\mathrm{L}} \\mathbf{t}_{\\mathrm{L}}$ 和 $\\mathbf{E}_{\\tau, \\mathrm{R}} = u_{\\mathrm{R}} \\mathbf{t}_{\\mathrm{R}}$ 给出，其中 $u_{\\mathrm{L}}$ 和 $u_{\\mathrm{R}}$ 是标量切向迹函数。\n\n切向连续性的物理条件是 $\\mathbf{E}_{\\tau, \\mathrm{L}} = \\mathbf{E}_{\\tau, \\mathrm{R}}$。代入局部表示可得：\n$$\nu_{\\mathrm{L}}(y) \\mathbf{t}_{\\mathrm{L}} = u_{\\mathrm{R}}(y) \\mathbf{t}_{\\mathrm{R}} = u_{\\mathrm{R}}(y) (\\sigma \\mathbf{t}_{\\mathrm{L}})\n$$\n这对标量迹施加了强逐点条件：$u_{\\mathrm{L}}(y) = \\sigma u_{\\mathrm{R}}(y)$。\n\n在弱形式中，通过要求该条件在与合适的函数空间进行测试时在积分意义上成立来强制执行。定义从左迹空间 $V_{\\mathrm{L}} = \\mathrm{span}\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{L}}}$ 到右迹空间 $V_{\\mathrm{R}} = \\mathrm{span}\\{\\phi_k\\}_{k=0}^{p_{\\mathrm{R}}}$ 的投影的一个原则性选择是，对目标空间 $V_{\\mathrm{R}}$ 的所有基函数强制执行该条件。这是一种 $L^2$ 投影的形式。\n\n与基无关的条件是找到 $u_{\\mathrm{R}} \\in V_{\\mathrm{R}}$，使得对于给定的 $u_{\\mathrm{L}} \\in V_{\\mathrm{L}}$：\n$$\n\\int_{\\Gamma} \\left( u_{\\mathrm{L}}(y) - \\sigma u_{\\mathrm{R}}(y) \\right) q(y) \\, dy = 0, \\quad \\forall q(y) \\in V_{\\mathrm{R}}\n$$\n这等价于 $\\int_{\\Gamma} u_{\\mathrm{L}}(y) q(y) \\, dy = \\sigma \\int_{\\Gamma} u_{\\mathrm{R}}(y) q(y) \\, dy$。这个公式与问题对 $\\sigma=-1$（矩抵消）和 $\\sigma=+1$（矩匹配）的要求一致。\n\n### 步骤 2：算法的推导\n\n我们将该公式具体化到给定的标准正交基 $\\{\\phi_i(y)\\}$。设 $u_{\\mathrm{L}}(y) = \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\phi_i(y)$ 和 $u_{\\mathrm{R}}(y) = \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\phi_k(y)$。测试函数为 $q(y) = \\phi_j(y)$，其中 $j \\in \\{0, 1, \\dots, p_{\\mathrm{R}}\\}$。\n\n代入弱条件中：\n$$\n\\int_{0}^{1} \\left( \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\phi_i(y) \\right) \\phi_j(y) \\, dy = \\sigma \\int_{0}^{1} \\left( \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\phi_k(y) \\right) \\phi_j(y) \\, dy\n$$\n由于基 $\\{\\phi_k(y)\\}_{k=0}^{p_{\\mathrm{R}}}$ 的标准正交性，右侧得以简化。因为 $j \\le p_{\\mathrm{R}}$，我们有 $\\int_{0}^{1} \\phi_k(y) \\phi_j(y) \\, dy = \\delta_{kj}$：\n$$\n\\sigma \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\delta_{kj} = \\sigma \\mathbf{c}_{\\mathrm{R}}[j]\n$$\n左侧是 $u_{\\mathrm{L}}$ 在基函数 $\\phi_j$ 上的投影：\n$$\n\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy\n$$\n结合这些，我们得到 $\\mathbf{c}_{\\mathrm{R}}$ 每个系数的显式公式：\n$$\n\\mathbf{c}_{\\mathrm{R}}[j] = \\frac{1}{\\sigma} \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy\n$$\n因为 $\\sigma^2=1$，所以我们有 $1/\\sigma = \\sigma$。我们定义 $(p_{\\mathrm{R}}+1) \\times (p_{\\mathrm{L}}+1)$ 的质量矩阵 $M$，其元素为 $M_{ji} = \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy$。整个投影可以写成矩阵-向量乘积：\n$$\n\\mathbf{c}_{\\mathrm{R}} = \\sigma M \\mathbf{c}_{\\mathrm{L}}\n$$\n### 步骤 3：实现细节\n\n对于每个测试用例 $(p_{\\mathrm{L}}, p_{\\mathrm{R}}, \\sigma, \\mathbf{c}_{\\mathrm{L}})$，算法包括以下步骤：\n1.  **基函数**：实现函数 $\\phi_i(y) = \\sqrt{2 i + 1}\\, P_i(2y - 1)$，其中 $P_i$ 是 `scipy.special` 中可用的标准勒让德多项式。\n2.  **求积**：在 $[0,1]$ 上建立一个足够高阶的高斯-勒让德求积法则，以精确计算矩阵元素。被积函数 $\\phi_i(y)\\phi_j(y)$ 是一个 $i+j$ 次多项式。问题指定了一个求积阶数 $N_q$，足以处理高达 $\\max(2p_{\\mathrm{L}}, 2p_{\\mathrm{R}})$ 次的多项式。这意味着选择 $N_q \\ge \\max(p_{\\mathrm{L}}, p_{\\mathrm{R}}) + 1$。\n3.  **矩阵组装**：通过数值计算每个积分 $M_{ji}$ 来计算矩阵 $M$：$M_{ji} \\approx \\sum_{k=1}^{N_q} w'_k \\phi_i(y_k) \\phi_j(y_k)$，其中 $(y_k, w'_k)$ 是在 $[0,1]$ 上的求积点和权重。\n4.  **投影**：使用矩阵-向量乘积 $\\mathbf{c}_{\\mathrm{R}} = \\sigma M \\mathbf{c}_{\\mathrm{L}}$ 计算投影后的系数向量 $\\mathbf{c}_{\\mathrm{R}}$。\n5.  **验证**：对于每个测试用例，使用相同的数值求积方案验证相应的矩条件。\n    -   对于 $\\sigma = -1$，检查是否对所有 $j \\in \\{0, \\dots, p_{\\mathrm{R}}\\}$ 都有 $|\\int_0^1 (u_{\\mathrm{L}} + u_{\\mathrm{R}}) \\phi_j(y) \\, dy| \\le \\varepsilon$。\n    -   对于 $\\sigma = +1$，检查是否对所有 $j \\in \\{0, \\dots, \\min(p_{\\mathrm{L}}, p_{\\mathrm{R}})\\}$ 都有 $|\\int_0^1 (u_{\\mathrm{L}} - u_{\\mathrm{R}}) \\phi_j(y) \\, dy| \\le \\varepsilon$。\n    积分通过求积点上的和进行数值计算。此检查的布尔结果是该用例的输出。根据构造，这些检查应该在浮点运算的精度范围内通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef run_case(p_L, p_R, sigma, c_L):\n    \"\"\"\n    Computes the projection and verifies the moment conditions for a single test case.\n\n    Args:\n        p_L (int): Polynomial order for the left subdomain.\n        p_R (int): Polynomial order for the right subdomain.\n        sigma (int): Orientation parameter, either +1 or -1.\n        c_L (np.ndarray): Coefficient vector for the left trace.\n\n    Returns:\n        bool: True if the moment conditions are satisfied within tolerance, False otherwise.\n    \"\"\"\n    epsilon = 1e-10\n\n    # 1. Define basis functions using Legendre polynomials\n    # The basis is phi_i(y) = sqrt(2i+1) * P_i(2y-1) for y in [0,1].\n    # scipy.special.legendre P_i are normalized with P_i(1)=1.\n    p_max_basis = max(p_L, p_R)\n    legendre_polys = {i: legendre(i) for i in range(p_max_basis + 1)}\n    \n    def phi(i, y):\n        # y can be a scalar or a numpy array\n        return np.sqrt(2 * i + 1) * legendre_polys[i](2 * y - 1)\n\n    # 2. Set up Gauss-Legendre quadrature on [0, 1]\n    # Quadrature order sufficient to integrate polynomials of degree up to max(2*p_L, 2*p_R)\n    # requires 2*N_q - 1 >= 2*p_max, so N_q = p_max + 1.\n    p_max_quad = max(p_L, p_R)\n    N_q = p_max_quad + 1\n    \n    # Get nodes and weights for [-1, 1] and scale to [0, 1]\n    x_q, w_q = np.polynomial.legendre.leggauss(N_q)\n    y_q = (x_q + 1) / 2.0\n    w_q_scaled = w_q / 2.0\n\n    # 3. Assemble the (p_R+1) x (p_L+1) mass matrix M_ji = integral(phi_i * phi_j dy)\n    phi_vals_L = np.array([phi(i, y_q) for i in range(p_L + 1)]) # Shape (p_L+1, N_q)\n    phi_vals_R = np.array([phi(j, y_q) for j in range(p_R + 1)]) # Shape (p_R+1, N_q)\n    \n    M = phi_vals_R @ (phi_vals_L.T * w_q_scaled[:, np.newaxis])\n    \n    # 4. Compute projected coefficients c_R = sigma * M @ c_L\n    c_R = sigma * (M @ c_L)\n    \n    # 5. Verify curl-conformity moment conditions using numerical quadrature\n    u_L_at_yq = c_L @ phi_vals_L\n    u_R_at_yq = c_R @ phi_vals_R\n    \n    all_checks_passed = True\n    if sigma == -1:\n        # Check condition for j in {0, ..., p_R}\n        for j in range(p_R + 1):\n            phi_j_at_yq = phi_vals_R[j, :]\n            \n            moment_L = np.sum(w_q_scaled * u_L_at_yq * phi_j_at_yq)\n            moment_R = np.sum(w_q_scaled * u_R_at_yq * phi_j_at_yq)\n            \n            error = np.abs(moment_L + moment_R)\n            if error > epsilon:\n                all_checks_passed = False\n                break\n    elif sigma == 1:\n        # Check condition for j in {0, ..., min(p_L, p_R)}\n        p_min = min(p_L, p_R)\n        for j in range(p_min + 1):\n            # Test functions phi_j are from the right space's basis\n            phi_j_at_yq = phi_vals_R[j, :]\n            \n            moment_L = np.sum(w_q_scaled * u_L_at_yq * phi_j_at_yq)\n            moment_R = np.sum(w_q_scaled * u_R_at_yq * phi_j_at_yq)\n            \n            error = np.abs(moment_L - moment_R)\n            if error > epsilon:\n                all_checks_passed = False\n                break\n                \n    return all_checks_passed\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 2, -1, [0.5, -0.3, 0.2, -0.4, 0.1]),\n        (0, 0, -1, [0.123456789]),\n        (3, 3, -1, [0.1, 0.2, -0.1, 0.05]),\n        (2, 5, 1,  [0.7, -0.25, 0.33]),\n        (5, 1, -1, [0.0, 1.0, 0.0, -0.2, 0.3, -0.1]),\n    ]\n\n    results = []\n    for p_L, p_R, sigma, c_L in test_cases:\n        is_valid = run_case(p_L, p_R, sigma, np.array(c_L))\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3302373"}]}