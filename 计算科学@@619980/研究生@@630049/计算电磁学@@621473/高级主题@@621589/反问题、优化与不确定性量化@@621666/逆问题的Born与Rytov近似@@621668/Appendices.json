{"hands_on_practices": [{"introduction": "本实践展示了玻恩近似和程函近似之间的一个关键区别。我们将设计一个场景，其中玻恩近似会导致非物理的结果——负吸收，而程函近似在结合了通过克拉默-克勒尼希关系实现的物理被动性原理后，能提供物理上一致的重建。这个练习突出了结合物理约束如何能够纠正由测量偏差和线性化引入的误差 [@problem_id:3290082]。", "problem": "考虑在一维平板几何结构中，单色平面波的标量电磁散射，该过程由总场的标量亥姆霍兹方程描述。设时谐约定为 $e^{-i\\omega t}$，标量场为 $u(x,\\omega)$，满足\n$$\n\\frac{d^2 u}{dx^2} + k_0^2 n^2(\\omega)\\,u = 0,\n$$\n其中 $k_0 = \\omega/c$，$c$ 是真空中的光速，单位为 $\\mathrm{m/s}$，$n(\\omega)$ 是复折射率。定义背景折射率 $n_0 = \\sqrt{\\varepsilon_\\infty}$，其中 $\\varepsilon_\\infty  0$ 为实数；以及一个厚度为 $L$ 的平板，其相对介电常数 $\\varepsilon_r(\\omega)$ 具有因果性和无源性，因此对于感兴趣频带内的所有角频率 $\\omega$，$\\operatorname{Im}\\{\\varepsilon_r(\\omega)\\} \\ge 0$（无源性）。复折射率 $n(\\omega) = \\sqrt{\\varepsilon_r(\\omega)}$ 选取主支，使得 $\\operatorname{Im}\\{n(\\omega)\\} \\ge 0$。入射场是一个沿 $+x$ 方向传播的平面波。\n\n定义在 $x=L$ 处的透射场，并用穿过相同厚度背景平板的透射场进行归一化，得到\n$$\nd(\\omega) = \\exp\\big( i k_0 L\\,(n(\\omega) - n_0)\\big),\n$$\n当内部反射可以忽略时，这是精确的透射比。在实践中，仪器设备通常会引入一个未知的、频率相关的校准增益 $g(\\omega)  0$ 来影响测量数据，因此测量的透射比为\n$$\nd_{\\mathrm{meas}}(\\omega) = g(\\omega)\\,d(\\omega).\n$$\n\n我们希望通过线性化模型从测量数据中恢复复衬度 $\\Delta m(\\omega) = n(\\omega) - n_0 = \\Delta n(\\omega) + i\\,\\kappa(\\omega)$。两种常见的线性化方法是：\n\n1. 玻恩近似（场的线性化）：\n$$\n\\Delta m_{\\mathrm{Born}}(\\omega) \\approx \\frac{d_{\\mathrm{meas}}(\\omega) - 1}{i\\,k_0\\,L}.\n$$\n\n2. 程函近似（场的复对数的线性化）：\n$$\n\\psi(\\omega) = \\ln d_{\\mathrm{meas}}(\\omega), \\quad \\Delta m_{\\mathrm{Rytov}}(\\omega) \\approx \\frac{\\psi(\\omega)}{i\\,k_0\\,L}.\n$$\n\n定义吸收系数 $\\alpha(\\omega)$，单位为 $\\mathrm{m^{-1}}$，为\n$$\n\\alpha(\\omega) = 2\\,k_0\\,\\kappa(\\omega).\n$$\n无源性要求对于所有 $\\omega$，$\\alpha(\\omega) \\ge 0$。\n\n克拉默-克勒尼希关系（KK关系；以 Hendrik Anthony Kramers 和 Ralph Kronig 的名字命名）用于最小相位传输，它通过希尔伯特变换将相位 $\\phi(\\omega) = \\arg d(\\omega)$ 和幅度 $A(\\omega) = |d(\\omega)|$ 联系起来。在因果性和最小相位的假设下，以下关系成立（由于未知的绝对校准增益，可能存在一个加性常数）：\n$$\n\\phi(\\omega) = -\\mathcal{H}\\left[\\ln A(\\omega)\\right](\\omega) + \\phi_0,\n$$\n其中 $\\mathcal{H}[\\cdot]$ 表示频率轴上的希尔伯特变换，$\\phi_0$ 是一个实常数。等价地，\n$$\n\\ln A(\\omega) = \\mathcal{H}\\left[\\phi(\\omega)\\right](\\omega) + \\ln A_0,\n$$\n其中常数 $\\ln A_0$ 反映了未知的绝对增益。\n\n你需要设计一个基准模型（即一个频率相关的 $\\varepsilon_r(\\omega)$ 和一个带校准增益 $g(\\omega)$ 的测量模型），使得玻恩近似在某些频率下预测出非物理的负吸收 $\\alpha_{\\mathrm{Born}}(\\omega)  0$，而与克拉默-克勒尼希关系一致的程函重构则不会。请使用物理上合理的德拜色散模型来表示 $\\varepsilon_r(\\omega)$：\n$$\n\\varepsilon_r(\\omega) = \\varepsilon_\\infty + \\frac{\\Delta\\varepsilon}{1 - i\\,\\omega\\,\\tau} + i\\,\\frac{\\sigma}{\\varepsilon_0\\,\\omega},\n$$\n其中 $\\varepsilon_0$ 是真空介电常数，单位为 $\\mathrm{F/m}$，$\\Delta\\varepsilon > 0$，$\\tau > 0$，且 $\\sigma \\ge 0$。选择参数以确保在频带内对所有 $\\omega$ 都有 $\\operatorname{Im}\\{\\varepsilon_r(\\omega)\\} \\ge 0$。\n\n为了给线性化方法带来挑战，定义一个平滑的实数校准增益剖面\n$$\ng(\\omega) = 1 + b\\,\\exp\\Big(-\\frac{(\\omega - \\omega_c)^2}{2\\,\\sigma_\\omega^2}\\Big),\n$$\n其中 $b \\ge 0$，$\\omega_c$ 在频带内，且 $\\sigma_\\omega > 0$。此校准增益不属于物理过程，但在玻恩线性化下可能导致对无源性的表观违背。程函方法应与克拉默-克勒尼希一致性结合使用，以诊断并校正这种校准偏差：在采样频率轴上使用离散希尔伯特变换从测量的相位 $\\phi_{\\mathrm{meas}}(\\omega) = \\arg d_{\\mathrm{meas}}(\\omega)$ 重构 $\\ln A(\\omega)$，然后选择加性常数以强制满足无源性，并构造 $\\psi(\\omega) = \\ln A_{\\mathrm{KK}}(\\omega) + i\\,\\phi_{\\mathrm{meas}}(\\omega)$ 来获得 $\\Delta m_{\\mathrm{Rytov}}(\\omega)$，进而得到 $\\alpha_{\\mathrm{Rytov}}(\\omega)$。\n\n实现约束：\n\n- 使用角频率 $\\omega$，单位为 $\\mathrm{rad/s}$；平板厚度 $L$，单位为 $\\mathrm{m}$；吸收系数以 $\\mathrm{m^{-1}}$ 报告。\n- 使用弧度作为角度单位。\n- 构建一个在有限频带 $[\\omega_{\\min},\\omega_{\\max}]$ 内均匀采样的频率网格。在进行离散希尔伯特变换之前，对数据应用合适的窗函数以减少边缘效应，并通过强制施加无源性 $\\ln A(\\omega) \\le 0$ 来处理克拉默-克勒尼希振幅重构中未知的加性常数。\n- 使用 $n(\\omega) = \\sqrt{\\varepsilon_r(\\omega)}$，并采用复数平方根的主支。\n\n测试套件：\n\n设 $c = 3.0\\times 10^8\\,\\mathrm{m/s}$，$\\varepsilon_\\infty = 2.25$，$\\Delta\\varepsilon = 0.75$，$\\tau = 1.0\\times 10^{-12}\\,\\mathrm{s}$，$\\sigma = 0$，$L = 0.01\\,\\mathrm{m}$，$\\omega_{\\min} = 1.0\\times 10^{13}\\,\\mathrm{rad/s}$，$\\omega_{\\max} = 3.0\\times 10^{14}\\,\\mathrm{rad/s}$，$\\omega_c = 1.5\\times 10^{14}\\,\\mathrm{rad/s}$，以及 $\\sigma_\\omega = 2.0\\times 10^{13}\\,\\mathrm{rad/s}$。考虑以下三种校准增益：\n- 情况1（理想情况）：$b = 0.0$。\n- 情况2（中等偏差）：$b = 0.03$。\n- 情况3（强偏差）：$b = 0.08$。\n\n对于每种情况，计算\n$$\n\\alpha_{\\mathrm{Born}}(\\omega) = 2\\,k_0\\,\\operatorname{Im}\\{\\Delta m_{\\mathrm{Born}}(\\omega)\\},\n\\quad\n\\alpha_{\\mathrm{Rytov}}(\\omega) = 2\\,k_0\\,\\operatorname{Im}\\{\\Delta m_{\\mathrm{Rytov}}(\\omega)\\}.\n$$\n对于每种情况，返回一个布尔值，指示在频带内是否存在任何 $\\omega$ 使得 $\\alpha_{\\mathrm{Born}}(\\omega)  0$，以及在经过克拉默-克勒尼希振幅重构和无源性强制施加后，是否存在任何 $\\omega$ 使得 $\\alpha_{\\mathrm{Rytov}}(\\omega)  0$。您的程序应生成单行输出，包含三种情况下的六个布尔值，按顺序排列并聚合为方括号内的逗号分隔列表（例如，“[b1,b2,b3,r1,r2,r3]”）。", "solution": "用户提供了一个计算电磁学中有效的、适定的问题。任务是构建一个数值模型，以展示玻恩近似和程函近似在逆散射问题中的一个关键区别，特别是在存在测量校准误差的情况下。我将给出一个完整的、有理有据的解决方案。\n\n该问题要求比较两种线性化模型——玻恩近似和程函近似——在从平板的透射响应重构其材料属性方面的表现。我们被要求设计一个场景，其中较简单的玻恩近似会产生非物理结果（负吸收），而一个结合了程函近似与克拉默-克勒尼希（KK）一致性强制的更复杂方法则能产生物理上有效的结果。\n\n对于每个测试用例，解决方案主要分为四个步骤：\n1.  **真实情况模拟**：我们首先计算“真实”的物理量。频率相关的相对介电常数 $\\varepsilon_r(\\omega)$ 由德拜模型定义。\n    $$\n    \\varepsilon_r(\\omega) = \\varepsilon_\\infty + \\frac{\\Delta\\varepsilon}{1 - i\\,\\omega\\,\\tau}\n    $$\n    由于指定了 $\\sigma=0$，涉及电导率 $\\sigma$ 的项被省略。然后使用平方根的主支计算复折射率 $n(\\omega)$，$n(\\omega) = \\sqrt{\\varepsilon_r(\\omega)}$，确保虚部非负，即 $\\operatorname{Im}\\{n(\\omega)\\} \\ge 0$，这对应于无源介质。通过厚度为 $L$ 的平板的真实单程透射比 $d(\\omega)$ 由下式给出：\n    $$\n    d(\\omega) = \\exp\\big( i k_0 L\\,(n(\\omega) - n_0)\\big)\n    $$\n    其中 $k_0 = \\omega/c$ 是真空波数，$n_0 = \\sqrt{\\varepsilon_\\infty}$ 是背景折射率。\n\n2.  **测量模型**：模拟的“测量”数据 $d_{\\mathrm{meas}}(\\omega)$ 包含一个频率相关的实值校准增益 $g(\\omega)  0$。\n    $$\n    g(\\omega) = 1 + b\\,\\exp\\Big(-\\frac{(\\omega - \\omega_c)^2}{2\\,\\sigma_\\omega^2}\\Big)\n    $$\n    $$\n    d_{\\mathrm{meas}}(\\omega) = g(\\omega)\\,d(\\omega)\n    $$\n    该增益会破坏测量的幅度，即 $|d_{\\mathrm{meas}}| = g(\\omega)|d(\\omega)|$，但不会改变相位，即 $\\arg(d_{\\mathrm{meas}}) = \\arg(d(\\omega))$，因为 $g(\\omega)$ 是实数且为正。\n\n3.  **玻恩近似重构**：玻恩近似对散射场进行线性化。重构的材料衬度 $\\Delta m_{\\mathrm{Born}}(\\omega)$ 和相应的吸收系数 $\\alpha_{\\mathrm{Born}}(\\omega)$ 从测量数据中计算得出。\n    $$\n    \\Delta m_{\\mathrm{Born}}(\\omega) \\approx \\frac{d_{\\mathrm{meas}}(\\omega) - 1}{i\\,k_0\\,L}\n    $$\n    吸收系数为 $\\alpha(\\omega) = 2\\,k_0\\,\\operatorname{Im}\\{\\Delta m(\\omega)\\}$。经过仔细推导可得：\n    $$\n    \\alpha_{\\mathrm{Born}}(\\omega) = 2\\,k_0\\,\\operatorname{Im}\\left\\{\\frac{d_{\\mathrm{meas}}(\\omega) - 1}{i\\,k_0\\,L}\\right\\} = \\frac{2}{L}\\left(1 - \\operatorname{Re}\\{d_{\\mathrm{meas}}(\\omega)\\}\\right) = \\frac{2}{L}\\left(1 - g(\\omega)\\operatorname{Re}\\{d(\\omega)\\}\\right)\n    $$\n    项 $\\operatorname{Re}\\{d(\\omega)\\}$ 是振荡的，$g(\\omega)  1$ 的放大作用很容易导致 $g(\\omega)\\operatorname{Re}\\{d(\\omega)\\} > 1$，从而得出非物理的预测，即有源介质 $\\alpha_{\\mathrm{Born}}(\\omega)  0$。此问题中，由于平板电厚度很大（$k_0 L$ 很大），系统远超出了玻恩近似的适用范围，导致这种失效更加严重。\n\n4.  **与克拉默-克勒尼希关系一致的程函重构**：程函近似对场的复相位（对数）进行线性化。\n    $$\n    \\Delta m_{\\mathrm{Rytov}}(\\omega) \\approx \\frac{\\ln d_{\\mathrm{meas}}(\\omega)}{i\\,k_0\\,L}\n    $$\n    关键的洞见是不要直接使用 $\\ln d_{\\mathrm{meas}}(\\omega)$，因为它的实部 $\\ln|d_{\\mathrm{meas}}| = \\ln g(\\omega) + \\ln|d(\\omega)|$ 被增益所破坏。相反，我们利用克拉默-克勒尼希关系，它连接了因果、最小相位函数对数的实部和虚部。透射函数 $d(\\omega)$ 就是这样一个函数。它的相位 $\\phi(\\omega) = \\arg d(\\omega)$ 不受增益影响，即 $\\phi_{\\mathrm{meas}}(\\omega) = \\phi(\\omega)$。因此，我们可以利用希尔伯特变换从测量的相位 $\\phi_{\\mathrm{meas}}(\\omega)$ 重构出物理上一致的对数振幅 $\\ln A_{\\mathrm{KK}}(\\omega)$：\n    $$\n    \\ln A_{\\mathrm{KK}}(\\omega) = \\mathcal{H}[\\phi_{\\mathrm{meas}}](\\omega) + C\n    $$\n    其中 $\\mathcal{H}[\\cdot]$ 表示希尔伯特变换，$C$ 是一个常数。问题指定在有限频率网格上数值实现希尔伯特变换，为此我们对 $\\phi_{\\mathrm{meas}}$ 应用Tukey窗以减轻边缘效应伪影。常数 $C$ 通过强制施加物理无源性约束 $\\alpha(\\omega) \\ge 0$ 来确定。程函重构的吸收系数为：\n    $$\n    \\alpha_{\\mathrm{Rytov}}(\\omega) = 2\\,k_0\\,\\operatorname{Im}\\left\\{\\frac{\\ln A_{\\mathrm{KK}}(\\omega) + i\\,\\phi_{\\mathrm{meas}}(\\omega)}{i\\,k_0\\,L}\\right\\} = -\\frac{2}{L}\\ln A_{\\mathrm{KK}}(\\omega)\n    $$\n    无源性 $\\alpha_{\\mathrm{Rytov}} \\ge 0$ 意味着 $\\ln A_{\\mathrm{KK}}(\\omega) \\le 0$。我们通过设置未知常数 $C$ 来强制满足这一点，使得重构的对数振幅的最大值为零：$C = -\\max(\\mathcal{H}[\\phi_{\\mathrm{meas}}](\\omega))$。通过这种构造，对于所有 $\\omega$，都有 $\\ln A_{\\mathrm{KK}}(\\omega) \\le 0$，这保证了重构的吸收系数 $\\alpha_{\\mathrm{Rytov}}(\\omega)$ 将是非负的。此过程诊断并校正了未知的频率相关增益 $g(\\omega)$，从而产生物理上有效的重构。\n\n实现将为每个测试用例计算 $\\alpha_{\\mathrm{Born}}(\\omega)$ 和 $\\alpha_{\\mathrm{Rytov}}(\\omega)$，并检查是否存在任何负值。我们预期玻恩近似在所有情况下都会失败（预测 $\\alpha  0$），而经过KK校正的程函方法在所有情况下都会成功（保持 $\\alpha \\ge 0$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import hilbert\nfrom scipy.signal.windows import tukey\n\ndef solve():\n    \"\"\"\n    Solves the electromagnetics problem by comparing Born and Rytov approximations.\n\n    This function sets up a physical model of a dielectric slab, simulates a\n    \"measured\" transmission signal with a calibration gain, and then applies\n    two different reconstruction algorithms (Born and Rytov/Kramers-Kronig)\n    to recover the slab's absorption profile. It then checks each reconstruction\n    for a non-physical artifact (negative absorption).\n    \"\"\"\n\n    # Define physical constants and problem parameters from the statement.\n    c = 3.0e8  # Speed of light in vacuum, m/s\n    eps_inf = 2.25\n    delta_eps = 0.75\n    tau = 1.0e-12  # Debye relaxation time, s\n    sigma = 0.0  # Electrical conductivity, S/m\n    L = 0.01  # Slab thickness, m\n    w_min = 1.0e13  # Minimum angular frequency, rad/s\n    w_max = 3.0e14  # Maximum angular frequency, rad/s\n    w_c = 1.5e14  # Center frequency of gain profile, rad/s\n    sigma_w = 2.0e13  # Width of gain profile, rad/s\n\n    # Define the test cases for the calibration gain amplitude 'b'.\n    test_cases_b = [\n        0.0,   # Case 1: No calibration bias\n        0.03,  # Case 2: Moderate bias\n        0.08,  # Case 3: Strong bias\n    ]\n\n    # Set up the computational grid.\n    n0 = np.sqrt(eps_inf)\n    N = 4096  # Number of frequency points for high resolution.\n    omega = np.linspace(w_min, w_max, N)\n    k0 = omega / c\n\n    born_results = []\n    rytof_results = []\n\n    for b in test_cases_b:\n        # Step 1: Simulate the ground truth physics.\n        # Debye model for relative permittivity.\n        # The term with sigma is zero as per the problem statement.\n        eps_r = eps_inf + delta_eps / (1.0 - 1j * omega * tau)\n\n        # Complex refractive index (principal branch is default for np.sqrt).\n        n = np.sqrt(eps_r)\n\n        # Step 2: Simulate the measurement process.\n        # Ideal transmission ratio d(omega) neglecting internal reflections.\n        d = np.exp(1j * k0 * L * (n - n0))\n\n        # Frequency-dependent calibration gain g(omega).\n        g = 1.0 + b * np.exp(-((omega - w_c)**2) / (2.0 * sigma_w**2))\n\n        # \"Measured\" transmission ratio including the gain.\n        d_meas = g * d\n\n        # Step 3: Reconstruction using the Born approximation.\n        # The absorption coefficient from the Born model is alpha = (2/L)*(1 - Re{d_meas}).\n        alpha_born = (2.0 / L) * (1.0 - np.real(d_meas))\n        born_neg_alpha = np.any(alpha_born  0)\n        born_results.append(born_neg_alpha)\n\n        # Step 4: Reconstruction using the Kramers-Kronig-consistent Rytov approximation.\n        # The measured phase is immune to the real-valued gain g > 0.\n        phi_meas = np.angle(d_meas)\n        \n        # Apply a Tukey window to the phase data to reduce spectral leakage artifacts\n        # in the discrete Hilbert transform (FFT-based).\n        win = tukey(N, alpha=0.25)\n        phi_windowed = phi_meas * win\n        \n        # Reconstruct log-amplitude via the discrete Hilbert transform of the phase.\n        # ln(A) = H[phi]. The imaginary part of scipy's hilbert() is the transform.\n        ln_A_KK_raw = np.imag(hilbert(phi_windowed))\n\n        # Enforce passivity (alpha >= 0, which implies ln(A) = 0) by shifting\n        # the reconstructed log-amplitude so its maximum is 0.\n        ln_A_KK = ln_A_KK_raw - np.max(ln_A_KK_raw)\n        \n        # Calculate the Rytov absorption coefficient from the KK-reconstructed amplitude.\n        # alpha = -(2/L)*ln(A_KK).\n        alpha_rytof = (-2.0 / L) * ln_A_KK\n\n        # Check for non-physical negative absorption. By construction, we expect\n        # alpha_rytof >= 0, so this should be False barring numerical noise.\n        rytof_neg_alpha = np.any(alpha_rytof  0)\n        rytof_results.append(rytof_neg_alpha)\n\n    # Aggregate results in the specified order: [b1, b2, b3, r1, r2, r3].\n    final_results = born_results + rytof_results\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3290082"}, {"introduction": "虽然Rytov近似能有效处理振幅变化，但其对相位的依赖带来了一个实际挑战：相位缠绕。本练习旨在解决相位模糊性问题，即测量相位被限制在一个 $2\\pi$ 区间内。你将实现一个多波数相位解缠绕策略，利用相位随频率线性变化的物理模型来解决模糊性，从而正确地重建物体属性 [@problem_id:3290093]。", "problem": "考虑一个标量时谐电磁场，它由均匀背景中标量亥姆霍兹方程控制，波数为 $k$（单位：弧度/米）。设一入射平面波 $E_{\\mathrm{inc}}(\\mathbf{r};k)$ 照射一个弱散射、薄、纯相位物体，该物体具有小的折射率微扰 $\\delta n(\\mathbf{r})$ 和沿传播方向的厚度 $T$（单位：米）。在 Rytov 近似下，定义 Rytov 变量 $\\psi(\\mathbf{r};k) = \\ln\\left(E(\\mathbf{r};k)/E_{\\mathrm{inc}}(\\mathbf{r};k)\\right)$，其中 $E(\\mathbf{r};k)$ 是总场。对于傍轴区中的薄纯相位物体，$\\psi$ 的虚部是相对于入射场的相位延迟，并且近似地与 $k$ 呈线性关系，即 $\\phi(\\mathbf{r};k) = \\mathrm{Im}\\,\\psi(\\mathbf{r};k) \\approx \\eta(\\mathbf{r})\\,k$，其中 $\\eta(\\mathbf{r}) = \\int \\delta n(\\mathbf{r})\\,\\mathrm{d}\\ell$ 是在观测点 $\\mathbf{r}$ 处沿视线的有效光程长度微扰（单位为米）。实部 $\\mathrm{Re}\\,\\psi$ 是对数振幅，我们假设其保持在有限的动态范围内。\n\n在测量中，由于复数对数或相位提取的主辐角限制，复相位只能以模 $2\\pi$ 的形式被获取，因此测得的包裹相位为 $\\tilde{\\phi}(\\mathbf{r};k) = \\mathrm{wrap}\\left(\\phi(\\mathbf{r};k)\\right)$，其被限制在区间 $(-\\pi,\\pi]$（单位：弧度）内。当 $\\lvert \\phi(\\mathbf{r};k) \\rvert$ 超过 $\\pi$ 时，这就构成了一个相位包裹问题。可以利用多波数数据，通过强制执行源自 Rytov/Born 线性化的跨 $k$ 一致性来解包裹相位：两个邻近波数 $k_1$ 和 $k_2$ 之间的 Rytov 变量之差满足 $\\Delta \\psi(\\mathbf{r}) \\approx (k_2-k_1)\\,\\partial_k \\psi(\\mathbf{r};k)$，因此其虚部遵循 $\\Delta \\phi(\\mathbf{r}) \\approx (k_2-k_1)\\,\\partial_k \\phi(\\mathbf{r};k)$。对于相位满足 $\\phi(\\mathbf{r};k) \\approx \\eta(\\mathbf{r})\\,k$ 的薄相位物体，有 $\\partial_k \\phi(\\mathbf{r};k) \\approx \\eta(\\mathbf{r})$。\n\n您必须构建一个计算场景，该场景能够：\n1.  对于给定的波数对 $k_1$ 和 $k_2$，模拟在固定观测点（省略显式 $\\mathbf{r}$ 符号，并将 $\\eta$ 视为常数）的标量单点接收器处的真实解包裹相位 $\\phi(\\mathbf{r};k_i) = \\eta\\,k_i$。\n2.  生成包裹测量值 $\\tilde{\\phi}(k_i) = \\mathrm{wrap}(\\phi(k_i)) \\in (-\\pi,\\pi]$，并可选地添加小的确定性微扰，以模拟有限的动态范围和量化效应。\n3.  使用以下公式实现一种多 $k$ 解包裹策略，该策略强制执行 Rytov 跨波数一致性：\n$$\n\\Delta \\phi_{\\mathrm{unwrapped}} = \\mathrm{wrap}\\big(\\tilde{\\phi}(k_2) - \\tilde{\\phi}(k_1)\\big) + 2\\pi\\,m,\n$$\n其中，$m \\in \\mathbb{Z}$ 的选择旨在最小化 $\\left\\lvert \\Delta \\phi_{\\mathrm{unwrapped}} - (k_2-k_1)\\,\\eta \\right\\rvert$。这是在相位分量上强制执行 $\\Delta \\psi \\approx (k_2 - k_1)\\,\\partial_k \\psi$，其中 $\\partial_k \\phi \\approx \\eta$。\n\n您的任务是实现一个程序，为下面的每个测试用例计算：\n- 真实相位差 $\\Delta \\phi_{\\mathrm{true}} = \\phi(k_2) - \\phi(k_1) = \\eta\\,(k_2-k_1)$。\n- 包裹相位差 $\\Delta \\tilde{\\phi} = \\mathrm{wrap}\\left(\\tilde{\\phi}(k_2) - \\tilde{\\phi}(k_1)\\right)$。\n- 通过选择使与 $\\Delta \\phi_{\\mathrm{true}}$ 的失配最小化的整数 $m$ 来计算的解包裹相位差 $\\Delta \\phi_{\\mathrm{unwrapped}}$。\n- 绝对误差 $e = \\left\\lvert \\Delta \\phi_{\\mathrm{unwrapped}} - \\Delta \\phi_{\\mathrm{true}} \\right\\rvert$。\n\n所有角度必须以弧度表示。每个测试用例的输出必须是绝对误差 $e$（一个浮点数）。您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表（例如，\"[e1,e2,e3,e4]\"）。\n\n使用以下测试套件（所有 $k$ 的单位为弧度/米，$\\eta$ 的单位为米，角度的单位为弧度）：\n- 测试 1（理想路径，存在包裹但无微扰）：$k_1 = 20.0$, $k_2 = 22.0$, $\\eta = 0.8$, 无微扰。\n- 测试 2（显著包裹，无微扰）：$k_1 = 12.5$, $k_2 = 15.0$, $\\eta = 1.7$, 无微扰。\n- 测试 3（包裹相位接近边界，带有小的确定性微扰）：$k_1 = 30.0$, $k_2 = 32.8$, $\\eta = 3.05$, 在求差前，为 $\\tilde{\\phi}(k_1)$ 添加 $-0.05$，为 $\\tilde{\\phi}(k_2)$ 添加 $+0.05$。\n- 测试 4（k 间距小，包裹最小）：$k_1 = 100.0$, $k_2 = 100.5$, $\\eta = 2.7$, 无微扰。\n\n最终的数值输出必须是每个测试用例的绝对误差 $e$，以弧度为单位，并按上述测试顺序排列。\n\n您的程序必须是一个完整、可运行的实现，它：\n- 计算 $\\phi(k_i)$，将其包裹成 $\\tilde{\\phi}(k_i)$，如果指定了微扰则应用微扰，计算 $\\Delta \\tilde{\\phi}$，使用满足 $\\partial_k \\phi \\approx \\eta$ 的跨 $k$ 一致性执行解包裹，并返回每个测试用例的绝对误差 $e$。\n- 使用角度包裹约定 $\\mathrm{wrap}(\\alpha) \\in (-\\pi,\\pi]$。\n- 以精确的格式 \"[e1,e2,e3,e4]\" 打印单行输出。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：标量时谐电磁场的标量亥姆霍兹方程。\n- **背景介质**：均匀，波数为 $k$ (rad/m)。\n- **物体**：弱散射、薄、纯相位物体，具有小的折射率微扰 $\\delta n(\\mathbf{r})$ 和厚度 $T$ (m)。\n- **入射场**：平面波 $E_{\\mathrm{inc}}(\\mathbf{r};k)$。\n- **总场**：$E(\\mathbf{r};k)$。\n- **Rytov 变量**：$\\psi(\\mathbf{r};k) = \\ln\\left(E(\\mathbf{r};k)/E_{\\mathrm{inc}}(\\mathbf{r};k)\\right)$。\n- **相位模型**：对于傍轴区中的薄纯相位物体，相位延迟 $\\phi(\\mathbf{r};k) = \\mathrm{Im}\\,\\psi(\\mathbf{r};k)$ 近似与 $k$ 呈线性关系：$\\phi(\\mathbf{r};k) \\approx \\eta(\\mathbf{r})\\,k$。\n- **光程长度微扰**：$\\eta(\\mathbf{r}) = \\int \\delta n(\\mathbf{r})\\,\\mathrm{d}\\ell$ (m)。对于给定的问题，这在单个观测点被视为标量常数 $\\eta$。\n- **包裹相位测量**：$\\tilde{\\phi}(\\mathbf{r};k) = \\mathrm{wrap}\\left(\\phi(\\mathbf{r};k)\\right)$，其中 `wrap` 函数将其参数映射到区间 $(-\\pi,\\pi]$。\n- **跨波数一致性**：两个波数 $k_1$ 和 $k_2$ 之间的相位差近似为 $\\Delta \\phi(\\mathbf{r}) \\approx (k_2-k_1)\\,\\partial_k \\phi(\\mathbf{r};k)$。使用给定的相位模型，这变为 $\\Delta \\phi(\\mathbf{r}) \\approx (k_2-k_1)\\,\\eta(\\mathbf{r})$。\n- **解包裹公式**：$\\Delta \\phi_{\\mathrm{unwrapped}} = \\mathrm{wrap}\\big(\\tilde{\\phi}(k_2) - \\tilde{\\phi}(k_1)\\big) + 2\\pi\\,m$，其中 $m \\in \\mathbb{Z}$。\n- **解包裹准则**：选择整数 $m$ 以最小化 $\\left\\lvert \\Delta \\phi_{\\mathrm{unwrapped}} - (k_2-k_1)\\,\\eta \\right\\rvert$。\n- **任务**：对于每个测试用例，计算绝对误差 $e = \\left\\lvert \\Delta \\phi_{\\mathrm{unwrapped}} - \\Delta \\phi_{\\mathrm{true}} \\right\\rvert$，其中 $\\Delta \\phi_{\\mathrm{true}} = \\eta\\,(k_2-k_1)$。\n- **测试用例**：\n  1. $k_1 = 20.0$, $k_2 = 22.0$, $\\eta = 0.8$, 无微扰。\n  2. $k_1 = 12.5$, $k_2 = 15.0$, $\\eta = 1.7$, 无微扰。\n  3. $k_1 = 30.0$, $k_2 = 32.8$, $\\eta = 3.05$, 对 $\\tilde{\\phi}(k_1)$ 的微扰为 $-0.05$，对 $\\tilde{\\phi}(k_2)$ 的微扰为 $+0.05$。\n  4. $k_1 = 100.0$, $k_2 = 100.5$, $\\eta = 2.7$, 无微扰。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据充分**：该问题基于 Rytov 近似，这是解决电磁逆散射问题中广泛使用且有效的线性化方法。相位包裹、多波数测量以及通过一致性检查进行相位解包裹等概念是相干成像和信号处理中的标准方法。相位模型 $\\phi(k) \\approx \\eta k$ 是薄物体和 Born/Rytov 近似的直接且有效的结果。该问题在科学上是合理的。\n2.  **适定性**：该问题为每个测试用例指定了清晰的计算任务，并提供了所有必要的输入（$k_1$、$k_2$、$\\eta$ 以及任何微扰）。用于寻找解包裹整数 $m$ 的目标函数定义明确，能够导出一个唯一解。所需输出的定义也很明确。\n3.  **客观性**：该问题以精确、定量和客观的科学语言陈述。没有主观或基于意见的条款。\n4.  **不完整或矛盾的设置**：该问题是自洽的。所有变量、函数和约束都已定义。所提供的数据是充分且一致的。\n5.  **不切实际或不可行**：物理参数和提议的测量，尽管为计算练习而简化，但在模拟的背景下是物理上合理的。\n6.  **病态或结构不良**：该问题结构良好，引导用户从物理模型到具体算法及其测试用例。用于 $m$ 的最小化过程是明确的，并确保唯一解的存在。\n7.  **伪深刻、琐碎或同义反复**：该问题是一项非凡的实现任务，它通过使用来自物理模型的旁路信息，正确地模拟了相位解包裹中模糊性解析（寻找 $m$）的核心挑战。\n8.  **超出科学可验证范围**：该问题是一个计算任务，完全可以通过实现所述算法来验证。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它科学依据充分、适定、客观且完整。将提供一个解决方案。\n\n---\n\n### 解决方案\n该问题要求实现一个多波数相位解包裹算法。该算法利用了薄弱散射物体中相位累积的物理模型，该模型由 Rytov 近似控制。我们将首先形式化算法的步骤，然后将其应用于指定的测试用例。\n\n**1. 物理模型和测量过程**\n\n对于给定的波数 $k$，在特定观测点的真实、解包裹的相位由以下线性关系建模：\n$$\n\\phi(k) = \\eta k\n$$\n其中 $\\eta$ 是有效光程长度微扰。这是基准真相相位。\n\n在测量中，相位通常作为复值信号的辐角被提取，这将其值限制在一个主值范围内。问题将此范围指定为 $(-\\pi, \\pi]$。这个过程称为相位包裹。测得的包裹相位 $\\tilde{\\phi}(k)$ 由下式给出：\n$$\n\\tilde{\\phi}(k) = \\mathrm{wrap}(\\phi(k))\n$$\n包裹函数 $\\mathrm{wrap}(\\alpha)$ 通过加减 $2\\pi$ 的整数倍，将任意实值角度 $\\alpha$ 映射到区间 $(-\\pi, \\pi]$。在数学上，这可以表示为：\n$$\n\\mathrm{wrap}(\\alpha) = \\alpha - 2\\pi N \\quad \\text{其中} \\quad N = \\left\\lfloor \\frac{\\alpha + \\pi}{2\\pi} \\right\\rfloor \\in \\mathbb{Z}\n$$\n或者等效地，使用底函数，或在计算上更常见的是 `(alpha + pi) % (2*pi) - pi`。\n\n在某些情况下，测量过程可能会引入微扰。对于给定的测试用例，我们考虑添加到包裹相位 $\\tilde{\\phi}(k_1)$ 和 $\\tilde{\\phi}(k_2)$ 上的确定性微扰 $p_1$ 和 $p_2$。\n\n**2. 相位解包裹算法**\n\n问题的核心是仅使用包裹测量值来确定两个波数 $k_1$ 和 $k_2$ 之间的真实相位差 $\\Delta\\phi_{\\mathrm{true}}$。真实相位差为：\n$$\n\\Delta\\phi_{\\mathrm{true}} = \\phi(k_2) - \\phi(k_1) = \\eta(k_2 - k_1)\n$$\n测量提供了两个包裹相位 $\\tilde{\\phi}(k_1)$ 和 $\\tilde{\\phi}(k_2)$（包括任何指定的微扰）。这些包裹相位的朴素差值 $\\tilde{\\phi}(k_2) - \\tilde{\\phi}(k_1)$ 本身也存在包裹模糊性。我们首先计算包裹相位差：\n$$\n\\Delta\\tilde{\\phi} = \\mathrm{wrap}(\\tilde{\\phi}(k_2) - \\tilde{\\phi}(k_1))\n$$\n真实相位差 $\\Delta\\phi_{\\mathrm{true}}$ 与包裹相位差 $\\Delta\\tilde{\\phi}$ 通过一个未知的 $2\\pi$ 整数倍相关联：\n$$\n\\Delta\\phi_{\\mathrm{true}} = \\Delta\\tilde{\\phi} + 2\\pi m^*\n$$\n其中某个整数 $m^* \\in \\mathbb{Z}$。我们的目标是找到 $\\Delta\\phi_{\\mathrm{true}}$ 的一个估计值，我们称之为 $\\Delta\\phi_{\\mathrm{unwrapped}}$。这是通过找到正确的整数（我们记为 $m$）来实现的。\n$$\n\\Delta\\phi_{\\mathrm{unwrapped}} = \\Delta\\tilde{\\phi} + 2\\pi m\n$$\n问题规定，应选择 $m$ 以强制与已知物理模型保持一致。具体来说，选择 $m$ 以最小化估计的解包裹相位差与理论预测的真实相位差之间的差的绝对值：\n$$\n\\min_{m \\in \\mathbb{Z}} \\left| \\Delta\\phi_{\\mathrm{unwrapped}} - \\Delta\\phi_{\\mathrm{true}} \\right| = \\min_{m \\in \\mathbb{Z}} \\left| (\\Delta\\tilde{\\phi} + 2\\pi m) - \\eta(k_2 - k_1) \\right|\n$$\n为了找到最小化此表达式的整数 $m$，我们希望绝对值内的项尽可能接近于零：\n$$\n\\Delta\\tilde{\\phi} + 2\\pi m \\approx \\eta(k_2 - k_1)\n$$\n$$\n2\\pi m \\approx \\eta(k_2 - k_1) - \\Delta\\tilde{\\phi}\n$$\n$$\nm \\approx \\frac{\\eta(k_2 - k_1) - \\Delta\\tilde{\\phi}}{2\\pi}\n$$\n最接近此实数值的整数 $m$ 通过四舍五入到最近的整数得到：\n$$\nm = \\mathrm{round}\\left( \\frac{\\Delta\\phi_{\\mathrm{true}} - \\Delta\\tilde{\\phi}}{2\\pi} \\right)\n$$\n\n**3. 计算步骤和误差度量**\n\n对于每个具有参数 $(k_1, k_2, \\eta, p_1, p_2)$ 的测试用例，流程如下：\n1.  计算真实相位：$\\phi(k_1) = \\eta k_1$ 和 $\\phi(k_2) = \\eta k_2$。\n2.  计算真实相位差：$\\Delta\\phi_{\\mathrm{true}} = \\phi(k_2) - \\phi(k_1)$。\n3.  计算原始包裹相位：$\\tilde{\\phi}_0(k_1) = \\mathrm{wrap}(\\phi(k_1))$ 和 $\\tilde{\\phi}_0(k_2) = \\mathrm{wrap}(\\phi(k_2))$。\n4.  应用微扰得到最终的测量相位：$\\tilde{\\phi}(k_1) = \\tilde{\\phi}_0(k_1) + p_1$ 和 $\\tilde{\\phi}(k_2) = \\tilde{\\phi}_0(k_2) + p_2$。对于没有微扰的用例，$p_1=0$ 且 $p_2=0$。\n5.  根据测量值计算包裹相位差：$\\Delta\\tilde{\\phi} = \\mathrm{wrap}(\\tilde{\\phi}(k_2) - \\tilde{\\phi}(k_1))$。\n6.  使用上面导出的四舍五入公式确定最佳解包裹整数 $m$。\n7.  计算解包裹相位差的估计值：$\\Delta\\phi_{\\mathrm{unwrapped}} = \\Delta\\tilde{\\phi} + 2\\pi m$。\n8.  最后，计算绝对误差 $e$，这是每个测试用例所需的输出：\n    $$\n    e = \\left| \\Delta\\phi_{\\mathrm{unwrapped}} - \\Delta\\phi_{\\mathrm{true}} \\right|\n    $$\n此流程将为四个给定的测试用例实现。测试用例 3 中的微扰引入了一个误差，该误差无法通过物理模型一致性检查来纠正，由此产生的非零误差 $e$ 量化了这种测量噪声对解包裹结果的影响。对于其他没有微扰的用例，误差 $e$ 预计为零或接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a multi-wavenumber phase unwrapping algorithm for a series of test cases.\n\n    The algorithm is based on the Rytov approximation for a thin phase object, where\n    the unwrapped phase is linear with the wavenumber k: phi(k) = eta * k.\n    The goal is to recover the true phase difference between two wavenumbers,\n    delta_phi_true = eta * (k2 - k1), from wrapped measurements.\n\n    The core of the method is to find an integer `m` that unwraps the phase difference\n    by minimizing the mismatch with the physically predicted phase difference.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (k1, k2, eta, perturbation1, perturbation2)\n    test_cases = [\n        (20.0, 22.0, 0.8, 0.0, 0.0),      # Test 1\n        (12.5, 15.0, 1.7, 0.0, 0.0),      # Test 2\n        (30.0, 32.8, 3.05, -0.05, 0.05),  # Test 3\n        (100.0, 100.5, 2.7, 0.0, 0.0)     # Test 4\n    ]\n\n    results = []\n\n    def wrap_to_pi(angle):\n        \"\"\"\n        Wraps an angle in radians to the interval (-pi, pi].\n        \"\"\"\n        return (angle + np.pi) % (2 * np.pi) - np.pi\n\n    for case in test_cases:\n        k1, k2, eta, p1, p2 = case\n\n        # Step 1  2: Calculate true phases and their difference.\n        # phi(k) = eta * k\n        phi_k1 = eta * k1\n        phi_k2 = eta * k2\n        delta_phi_true = phi_k2 - phi_k1\n\n        # Step 3  4: Calculate wrapped phases and apply perturbations.\n        tilde_phi_k1_raw = wrap_to_pi(phi_k1)\n        tilde_phi_k2_raw = wrap_to_pi(phi_k2)\n        \n        tilde_phi_k1 = tilde_phi_k1_raw + p1\n        tilde_phi_k2 = tilde_phi_k2_raw + p2\n        \n        # Step 5: Calculate the wrapped phase difference from measurements.\n        delta_tilde_phi = wrap_to_pi(tilde_phi_k2 - tilde_phi_k1)\n\n        # Step 6: Determine the optimal unwrapping integer 'm'.\n        # m is chosen to minimize | (delta_tilde_phi + 2*pi*m) - delta_phi_true |\n        # This is equivalent to rounding (delta_phi_true - delta_tilde_phi) / (2*pi).\n        m_float = (delta_phi_true - delta_tilde_phi) / (2 * np.pi)\n        m = np.round(m_float)\n\n        # Step 7: Compute the unwrapped phase difference.\n        delta_phi_unwrapped = delta_tilde_phi + 2 * np.pi * m\n\n        # Step 8: Compute the absolute error.\n        error = np.abs(delta_phi_unwrapped - delta_phi_true)\n        results.append(error)\n\n    # Format and print the final results\n    # Use '.16g' to ensure sufficient precision without trailing zeros.\n    print(f\"[{','.join(f'{r:.16g}' for r in results)}]\")\n\nsolve()\n```", "id": "3290093"}, {"introduction": "一阶玻恩近似的失效根本上源于多重散射。本实践通过分析两个点散射体的玻恩级数中的二阶项，让您能够直接审视这一现象。您将计算由单次散射（一阶）产生的干涉图样，并将其与包含散射体之间相干相互作用（二阶）的图样进行比较，从而量化玻恩近似失效的临界点 [@problem_id:3290130]。", "problem": "您的任务是研究标量时谐 Helmholtz 背景下两个相同点散射体之间的多重散射和相干相互作用，并通过探测器线上的干涉图样来量化 Born 近似失效的起始点。从二维空间中标量 Helmholtz 方程开始，该方程描述了总场 $E(\\mathbf{r})$，\n$$\n\\nabla^2 E(\\mathbf{r}) + k_0^2 \\bigl(1 + \\chi(\\mathbf{r})\\bigr) E(\\mathbf{r}) = 0,\n$$\n其中 $k_0 = 2\\pi/\\lambda$ 是波长为 $\\lambda$ 的自由空间波数，$\\chi(\\mathbf{r})$ 是无量纲的散射衬度。相关的 Lippmann–Schwinger 积分方程为\n$$\nE(\\mathbf{r}) = E_{\\mathrm{inc}}(\\mathbf{r}) + k_0^2 \\int_{\\mathbb{R}^2} G(\\mathbf{r},\\mathbf{r}') \\chi(\\mathbf{r}') E(\\mathbf{r}') \\,\\mathrm{d}\\mathbf{r}',\n$$\n其中 $E_{\\mathrm{inc}}(\\mathbf{r})$ 是入射场，$G(\\mathbf{r},\\mathbf{r}')$ 是二维自由空间格林函数，定义为\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{i}{4} H_0^{(1)}\\!\\big(k_0 \\lVert \\mathbf{r}-\\mathbf{r}' \\rVert\\big),\n$$\n其中 $H_0^{(1)}$ 是第一类零阶 Hankel 函数。考虑两个衬度为 $\\chi_0$ 的相同点散射体，分别位于 $\\mathbf{r}_1 = (-d/2,0)$ 和 $\\mathbf{r}_2 = (d/2,0)$，因此衬度分布为\n$$\n\\chi(\\mathbf{r}) = \\chi_0 \\delta(\\mathbf{r}-\\mathbf{r}_1) + \\chi_0 \\delta(\\mathbf{r}-\\mathbf{r}_2).\n$$\n假设入射场为沿 $x$ 轴传播的平面波，$E_{\\mathrm{inc}}(\\mathbf{r}) = e^{i k_0 x}$。一阶 Born 近似在 Lippmann–Schwinger 积分中用 $E_{\\mathrm{inc}}(\\mathbf{r}')$ 替换 $E(\\mathbf{r}')$。当被积函数中的 $E(\\mathbf{r}')$ 被其一阶 Born 场替换时，便产生二阶 Born 项，形成一个二重积分项。利用 $\\chi(\\mathbf{r})$ 的分布表示，该二重积分可简化为一个离散和。在此设定下，您必须通过仅保留交叉散射项（即与 $G(\\mathbf{r}_1,\\mathbf{r}_2)$ 或 $G(\\mathbf{r}_2,\\mathbf{r}_1)$ 成比例的项）来模拟两个散射体之间的相干相互作用，并忽略自相互作用项 $G(\\mathbf{r}_j,\\mathbf{r}_j)$，以避免点散射体模型中出现奇异的自能项。这对应于通常在多重散射近似中排除自能的主值解释。\n\n您的任务是：\n- 使用上面定义的二维格林函数，推导在探测器线 $y=L$ 上的一阶 Born 散射场 $E^{(1)}(\\mathbf{r})$ 和二阶 Born 交叉散射场 $E^{(2)}_{\\mathrm{cross}}(\\mathbf{r})$ 的表达式，它们是观测坐标 $x$ 和间距 $d$ 的函数。\n- 展示二阶 Born 交叉项如何通过随 $d$ 变化的 $G(\\mathbf{r}_1,\\mathbf{r}_2)$ 来编码相干相互作用。\n- 设计一个基于干涉的定量指标，用于检测 Born 近似失效的起始点：定义一阶 Born 模型下的探测器强度，\n$$\nI_1(x) = \\big\\lvert E^{(1)}(x,L)\\big\\rvert^2,\n$$\n以及包含一阶和二阶交叉项时的强度，\n$$\nI_{12}(x) = \\big\\lvert E^{(1)}(x,L) + E^{(2)}_{\\mathrm{cross}}(x,L)\\big\\rvert^2.\n$$\n定义最大分数偏差\n$$\nR = \\frac{\\max_{x\\in[-X_{\\max},X_{\\max}]} \\big\\lvert I_{12}(x) - I_1(x)\\big\\rvert}{\\max_{x\\in[-X_{\\max},X_{\\max}]} I_1(x)},\n$$\n这是一个无单位的小数。该指标反映了相干多重散射相对于一阶 Born 预测的强度。您将为几组参数计算 $R$，从而设计一个实验来检测随着 $d$ 的变化和 $\\chi_0$ 的增加，Born 近似失效的起始点。使用的判据是：较大的 $R$ 值表示与一阶 Born 干涉图样的偏离更强。\n\n物理单位与数值约定：\n- 所有长度（$\\lambda$、$d$、$L$、$X_{\\max}$）均以米（m）为单位。\n- 入射角以弧度为单位；此处为沿 $x$ 轴的 $0$ 弧度。\n- 输出 $R$ 是无单位的，并且必须表示为小数。\n\n实现一个完整、可运行的程序，该程序：\n- 使用如上给出的二维格林函数 $G(\\mathbf{r},\\mathbf{r}')$。\n- 为一个在 $\\left[-X_{\\max},X_{\\max}\\right]$ 区间内均匀分布的、包含 $N_x$ 个点的探测点数组 $x$，计算 $E^{(1)}(x,L)$ 和 $E^{(2)}_{\\mathrm{cross}}(x,L)$。\n- 为下面列出的每个测试用例计算上面定义的指标 $R$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $\\left[0.12345,0.06789\\right]$。\n\n测试套件：\n- 用例 1：$\\lambda = 0.5$ 米，$\\chi_0 = 0.05$，$d = 0.05$ 米，$L = 2.0$ 米，$X_{\\max} = 1.0$ 米，$N_x = 1001$。\n- 用例 2：$\\lambda = 0.5$ 米，$\\chi_0 = 0.20$，$d = 0.05$ 米，$L = 2.0$ 米，$X_{\\max} = 1.0$ 米，$N_x = 1001$。\n- 用例 3：$\\lambda = 0.5$ 米，$\\chi_0 = 0.05$，$d = 0.5$ 米，$L = 2.0$ 米，$X_{\\max} = 1.0$ 米，$N_x = 1001$。\n- 用例 4：$\\lambda = 0.5$ 米，$\\chi_0 = 0.05$，$d = 5.0$ 米，$L = 2.0$ 米，$X_{\\max} = 1.0$ 米，$N_x = 1001$。\n\n您的程序应生成单行输出，其中包含按照上述用例顺序列出的结果，结果为逗号分隔的列表，并用方括号括起来，例如 $\\left[r_1,r_2,r_3,r_4\\right]$，其中每个 $r_j$ 是为用例 $j$ 计算出的 $R$ 的小数值。", "solution": "该问题要求使用 Lippmann-Schwinger 积分方程的 Born 级数展开，分析二维空间中两个点散射体之间的多重散射。目标是推导一阶和二阶（仅交叉项）散射场，然后用它们构建一个定量指标 $R$，该指标用于衡量与一阶 Born 近似的偏差。将为几组参数计算该指标。\n\n分析始于介质中总场 $E(\\mathbf{r})$ 的时谐标量 Helmholtz 方程，其散射衬度为 $\\chi(\\mathbf{r})$：\n$$\n\\nabla^2 E(\\mathbf{r}) + k_0^2 \\bigl(1 + \\chi(\\mathbf{r})\\bigr) E(\\mathbf{r}) = 0,\n$$\n其中 $k_0 = 2\\pi/\\lambda$ 是自由空间波数。该微分方程可以重构为 Lippmann-Schwinger 积分方程：\n$$\nE(\\mathbf{r}) = E_{\\mathrm{inc}}(\\mathbf{r}) + k_0^2 \\int_{\\mathbb{R}^2} G(\\mathbf{r},\\mathbf{r}') \\chi(\\mathbf{r}') E(\\mathbf{r}') \\,\\mathrm{d}\\mathbf{r}',\n$$\n其中 $E_{\\mathrm{inc}}(\\mathbf{r})$ 是入射场，$G(\\mathbf{r},\\mathbf{r}')$ 是自由空间格林函数。在二维空间中，$G(\\mathbf{r},\\mathbf{r}') = \\frac{i}{4} H_0^{(1)}\\!\\big(k_0 \\lVert \\mathbf{r}-\\mathbf{r}' \\rVert\\big)$，其中 $H_0^{(1)}$ 是第一类零阶 Hankel 函数。\n\n该问题考虑两个强度为 $\\chi_0$ 的相同点散射体，分别位于 $\\mathbf{r}_1 = (-d/2, 0)$ 和 $\\mathbf{r}_2 = (d/2, 0)$。因此，散射衬度通过 Dirac delta 函数的和来建模：\n$$\n\\chi(\\mathbf{r}) = \\chi_0 \\delta(\\mathbf{r}-\\mathbf{r}_1) + \\chi_0 \\delta(\\mathbf{r}-\\mathbf{r}_2).\n$$\n入射场是沿 $x$ 轴传播的平面波，$E_{\\mathrm{inc}}(\\mathbf{r}) = e^{i k_0 x}$。\n\n**一阶 Born 散射场 $E^{(1)}(\\mathbf{r})$ 的推导**\n\n一阶 Born 近似 $E^{(1)}(\\mathbf{r})$ 是通过在积分内用入射场 $E_{\\mathrm{inc}}(\\mathbf{r}')$ 替换总场 $E(\\mathbf{r}')$ 得到的。这代表单次散射事件。\n$$\nE^{(1)}(\\mathbf{r}) = k_0^2 \\int_{\\mathbb{R}^2} G(\\mathbf{r},\\mathbf{r}') \\chi(\\mathbf{r}') E_{\\mathrm{inc}}(\\mathbf{r}') \\,\\mathrm{d}\\mathbf{r}'.\n$$\n代入 $\\chi(\\mathbf{r}')$ 的表达式，并利用 delta 函数的筛选性质，我们得到：\n$$\nE^{(1)}(\\mathbf{r}) = k_0^2 \\int_{\\mathbb{R}^2} G(\\mathbf{r},\\mathbf{r}') \\left[ \\chi_0 \\delta(\\mathbf{r}'-\\mathbf{r}_1) + \\chi_0 \\delta(\\mathbf{r}'-\\mathbf{r}_2) \\right] E_{\\mathrm{inc}}(\\mathbf{r}') \\,\\mathrm{d}\\mathbf{r}' \\\\\n= k_0^2 \\chi_0 \\left[ G(\\mathbf{r},\\mathbf{r}_1) E_{\\mathrm{inc}}(\\mathbf{r}_1) + G(\\mathbf{r},\\mathbf{r}_2) E_{\\mathrm{inc}}(\\mathbf{r}_2) \\right].\n$$\n散射体位置处的入射场值为 $E_{\\mathrm{inc}}(\\mathbf{r}_1) = e^{i k_0 (-d/2)} = e^{-i k_0 d/2}$ 和 $E_{\\mathrm{inc}}(\\mathbf{r}_2) = e^{i k_0 (d/2)} = e^{i k_0 d/2}$。因此，一阶散射场为：\n$$\nE^{(1)}(\\mathbf{r}) = k_0^2 \\chi_0 \\left[ G(\\mathbf{r},\\mathbf{r}_1) e^{-i k_0 d/2} + G(\\mathbf{r},\\mathbf{r}_2) e^{i k_0 d/2} \\right].\n$$\n\n**二阶 Born 交叉散射场 $E^{(2)}_{\\mathrm{cross}}(\\mathbf{r})$ 的推导**\n\n二阶 Born 项 $E^{(2)}(\\mathbf{r})$ 是通过在 Lippmann-Schwinger 积分中使用一阶散射场 $E^{(1)}(\\mathbf{r}')$ 得到的。这解释了二次散射事件。\n$$\nE^{(2)}(\\mathbf{r}) = k_0^2 \\int_{\\mathbb{R}^2} G(\\mathbf{r},\\mathbf{r}') \\chi(\\mathbf{r}') E^{(1)}(\\mathbf{r}') \\,\\mathrm{d}\\mathbf{r}'.\n$$\n代入 $E^{(1)}(\\mathbf{r}')$ 的积分形式，得到一个二重积分：\n$$\nE^{(2)}(\\mathbf{r}) = (k_0^2)^2 \\iint G(\\mathbf{r}, \\mathbf{r}') \\chi(\\mathbf{r}') G(\\mathbf{r}',\\mathbf{r}'') \\chi(\\mathbf{r}'') E_{\\mathrm{inc}}(\\mathbf{r}'') \\,\\mathrm{d}\\mathbf{r}'' \\mathrm{d}\\mathbf{r}'.\n$$\n使用 $\\chi$ 的 delta 函数模型，将积分分解为关于散射体索引 $j,k \\in \\{1,2\\}$ 的离散和：\n$$\nE^{(2)}(\\mathbf{r}) = (k_0^2 \\chi_0)^2 \\sum_{j=1}^{2} \\sum_{k=1}^{2} G(\\mathbf{r},\\mathbf{r}_j) G(\\mathbf{r}_j,\\mathbf{r}_k) E_{\\mathrm{inc}}(\\mathbf{r}_k).\n$$\n问题指定只保留交叉散射项，即 $j \\neq k$。这是一个标准程序，用以避免与点散射体自相互作用（$G(\\mathbf{r}_j,\\mathbf{r}_j)$ 项）相关的非物理奇点。这对应于波从散射体 $k$ 传播到散射体 $j$，然后再传播到观测者。因此，交叉散射场为：\n$$\nE^{(2)}_{\\mathrm{cross}}(\\mathbf{r}) = (k_0^2 \\chi_0)^2 \\left[ G(\\mathbf{r},\\mathbf{r}_1) G(\\mathbf{r}_1,\\mathbf{r}_2) E_{\\mathrm{inc}}(\\mathbf{r}_2) + G(\\mathbf{r},\\mathbf{r}_2) G(\\mathbf{r}_2,\\mathbf{r}_1) E_{\\mathrm{inc}}(\\mathbf{r}_1) \\right].\n$$\n利用格林函数的互易性，$G(\\mathbf{r}_1,\\mathbf{r}_2) = G(\\mathbf{r}_2,\\mathbf{r}_1) = \\frac{i}{4} H_0^{(1)}(k_0 d)$，以及入射场的值，我们得到：\n$$\nE^{(2)}_{\\mathrm{cross}}(\\mathbf{r}) = (k_0^2 \\chi_0)^2 G(\\mathbf{r}_1,\\mathbf{r}_2) \\left[ G(\\mathbf{r},\\mathbf{r}_1) e^{i k_0 d/2} + G(\\mathbf{r},\\mathbf{r}_2) e^{-i k_0 d/2} \\right].\n$$\n该项明确包含因子 $G(\\mathbf{r}_1,\\mathbf{r}_2)$，它介导了两个散射体之间的相干相互作用。其大小取决于间距 $d$。\n\n**最终表达式和定量指标**\n\n为了进行数值计算，我们在探测器线上的观测点 $\\mathbf{r} = (x, L)$ 处计算场。令 $G_j(x,L) = G((x,L), \\mathbf{r}_j)$。所需的场为：\n$$\nE^{(1)}(x,L) = k_0^2 \\chi_0 \\left[ G_1(x,L) e^{-i k_0 d/2} + G_2(x,L) e^{i k_0 d/2} \\right]\n$$\n$$\nE^{(2)}_{\\mathrm{cross}}(x,L) = (k_0^2 \\chi_0)^2 G(\\mathbf{r}_1,\\mathbf{r}_2) \\left[ G_1(x,L) e^{i k_0 d/2} + G_2(x,L) e^{-i k_0 d/2} \\right]\n$$\n其中\n$G_1(x,L) = \\frac{i}{4} H_0^{(1)}\\!\\left(k_0 \\sqrt{(x+d/2)^2 + L^2}\\right)$,\n$G_2(x,L) = \\frac{i}{4} H_0^{(1)}\\!\\left(k_0 \\sqrt{(x-d/2)^2 + L^2}\\right)$,\n以及 $G(\\mathbf{r}_1,\\mathbf{r}_2) = \\frac{i}{4} H_0^{(1)}(k_0 d)$。\n\n强度计算如下：$I_1(x) = \\big\\lvert E^{(1)}(x,L)\\big\\rvert^2$ 和 $I_{12}(x) = \\big\\lvert E^{(1)}(x,L) + E^{(2)}_{\\mathrm{cross}}(x,L)\\big\\rvert^2$。指标 $R$ 衡量了因包含二阶多重散射项而导致的强度图样的最大分数变化：\n$$\nR = \\frac{\\max_{x\\in[-X_{\\max},X_{\\max}]} \\big\\lvert I_{12}(x) - I_1(x)\\big\\rvert}{\\max_{x\\in[-X_{\\max},X_{\\max}]} I_1(x)}.\n$$\n\n**数值策略**\n\n计算过程首先为 $[-X_{\\max}, X_{\\max}]$ 内的 $x$ 定义一个包含 $N_x$ 个点的网格。然后，对于每组参数 $(\\lambda, \\chi_0, d, L, X_{\\max})$：\n1. 计算波数 $k_0 = 2\\pi/\\lambda$。\n2. 将 $G_1$、$G_2$ 和 $G(\\mathbf{r}_1,\\mathbf{r}_2)$ 的 Hankel 函数的参数计算为 NumPy 数组。\n3. 使用 `scipy.special.hankel1` 计算格林函数。\n4. 在 $x$ 网格上以向量形式组装复数值场 $E^{(1)}(x,L)$ 和 $E^{(2)}_{\\mathrm{cross}}(x,L)$。\n5. 计算强度 $I_1(x)$ 和 $I_{12}(x)$。\n6. 找到 $R$ 的分子和分母所需的最大值，并计算它们的比率。\n对每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Computes the Born breakdown indicator R for a series of test cases\n    in a 2D scalar multiple scattering problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (lambda (m), chi_0, d (m), L (m), X_max (m), N_x)\n    test_cases = [\n        (0.5, 0.05, 0.05, 2.0, 1.0, 1001),\n        (0.5, 0.20, 0.05, 2.0, 1.0, 1001),\n        (0.5, 0.05, 0.5, 2.0, 1.0, 1001),\n        (0.5, 0.05, 5.0, 2.0, 1.0, 1001),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current case\n        lambda_val, chi_0, d, L, X_max, N_x = case\n\n        # --- Initial Setup ---\n        # Free-space wavenumber\n        k_0 = 2.0 * np.pi / lambda_val\n        \n        # Detector coordinates\n        x_coords = np.linspace(-X_max, X_max, N_x)\n\n        # --- Green's Function Components ---\n        # Distances from each scatterer to the detector points\n        dist_1 = np.sqrt((x_coords + d / 2.0)**2 + L**2)\n        dist_2 = np.sqrt((x_coords - d / 2.0)**2 + L**2)\n\n        # Green's functions from scatterers to detector points\n        # G_j(x, L) = (i/4) * H_0^(1) (k_0 * ||r - r_j||)\n        G_1 = (1j / 4.0) * special.hankel1(0, k_0 * dist_1)\n        G_2 = (1j / 4.0) * special.hankel1(0, k_0 * dist_2)\n\n        # --- Field Calculations ---\n        # Incident field phase factors at the scatterer locations\n        # E_inc(r_1) = exp(-i*k_0*d/2) and E_inc(r_2) = exp(i*k_0*d/2)\n        phase_inc_at_r1 = np.exp(-1j * k_0 * d / 2.0)\n        phase_inc_at_r2 = np.exp(1j * k_0 * d / 2.0)\n\n        # --- First-Order Born Scattered Field E^(1) ---\n        # E^(1) = k_0^2 * chi_0 * [G_1 * E_inc(r_1) + G_2 * E_inc(r_2)]\n        E1_field = (k_0**2 * chi_0) * (G_1 * phase_inc_at_r1 + G_2 * phase_inc_at_r2)\n\n        # --- Second-Order Cross-Scattering Field E^(2)_cross ---\n        # Green's function between scatterers G(r_1, r_2)\n        # The argument is k_0 * ||r_1 - r_2|| = k_0 * d\n        G_12 = (1j / 4.0) * special.hankel1(0, k_0 * d)\n        \n        # E^(2)_cross = (k_0^2 * chi_0)^2 * G_12 * [G_1 * E_inc(r_2) + G_2 * E_inc(r_1)]\n        # Note the swapped phase factors corresponding to the interaction path\n        E2_cross_field = ((k_0**2 * chi_0)**2) * G_12 * (G_1 * phase_inc_at_r2 + G_2 * phase_inc_at_r1)\n\n        # --- Intensity Calculations ---\n        # I_1 = |E^(1)|^2\n        I_1 = np.abs(E1_field)**2\n        # I_12 = |E^(1) + E^(2)_cross|^2\n        I_12 = np.abs(E1_field + E2_cross_field)**2\n\n        # --- Quantitative Indicator R ---\n        # R = max|I_12 - I_1| / max|I_1|\n        numerator = np.max(np.abs(I_12 - I_1))\n        denominator = np.max(I_1)\n        \n        if denominator == 0:\n            # This case is physically unexpected for this problem setup.\n            # If max I_1 is 0, the first-order field is null everywhere.\n            # Assign inf if numerator is non-zero, otherwise 0.\n            R = np.inf if numerator > 0 else 0.0\n        else:\n            R = numerator / denominator\n        \n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3290130"}]}