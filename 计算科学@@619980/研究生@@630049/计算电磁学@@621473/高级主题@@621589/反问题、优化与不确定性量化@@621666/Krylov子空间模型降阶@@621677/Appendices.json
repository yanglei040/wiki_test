{"hands_on_practices": [{"introduction": "任何模型降阶方法的有效性都取决于其量化和控制近似误差的能力。这个练习将引导您推导一个后验误差估计器，这是评估降阶模型质量的理论基石。通过从第一性原理出发，您将揭示可计算的“残差”与真实的模型误差之间的根本联系，这为所有严谨的模型验证和自适应算法提供了理论依据 [@problem_id:3322125]。", "problem": "考虑一个通过保旋有限元法或有限积分技术等方法获得的麦克斯韦方程组的半离散化公式，它产生一个形如 $E \\dot{x}(t) = A x(t) + B u(t)$ 的线性时不变 (LTI) 描述系统，其输出为 $y(t) = C x(t)$。其中，$E \\in \\mathbb{C}^{n \\times n}$ 通常是厄米半正定矩阵，$A \\in \\mathbb{C}^{n \\times n}$ 来自材料算子和拓扑算子，$B \\in \\mathbb{C}^{n \\times m}$ 和 $C \\in \\mathbb{C}^{p \\times n}$ 是与所选端口或探针一致的输入和输出矩阵。频域传递函数为 $H(s) = C (s E - A)^{-1} B$，其中 $s \\in \\mathbb{C}$ 位于右半开平面以确保适定性。通过使用试探基 $V \\in \\mathbb{C}^{n \\times r}$ 和测试基 $W \\in \\mathbb{C}^{n \\times r}$ 进行投影来构建 Petrov–Galerkin 降阶模型，使得 $W^{*} E V$ 是非奇异的，从而得到降阶传递函数 $\\hat{H}(s) = C V \\left(s W^{*} E V - W^{*} A V\\right)^{-1} W^{*} B$。\n\n固定一个频率 $s \\in \\mathbb{C}$，使得 $(s E - A)$ 可逆。对于给定的输入 $u \\in \\mathbb{C}^{m}$，通过 $(s E - A) x(s) = B u$ 定义 $x(s) \\in \\mathbb{C}^{n}$，以及降阶状态 $\\hat{x}(s) = V \\hat{z}(s)$，其中 $\\hat{z}(s) \\in \\mathbb{C}^{r}$ 满足 Petrov–Galerkin 条件 $W^{*} \\left((s E - A) V \\hat{z}(s) - B u\\right) = 0$。将在频率 $s$ 处与 $u$ 相关的 Petrov–Galerkin 残差定义为 $r_{u}(s) = B u - (s E - A) \\hat{x}(s)$。全文假设使用欧几里得向量范数和诱导谱算子 2-范数。\n\n仅从上述定义和标准范数不等式出发，为传递函数误差 $\\|H(s) - \\hat{H}(s)\\|_{2}$ 的诱导 2-范数在固定频率 $s$ 处推导一个后验误差估计量，该估计量显式地依赖于 Petrov–Galerkin 残差和 $(s E - A)^{-1}$ 的算子范数。您的推导必须从残差所蕴含的状态和输出误差开始，并得出一个形如“类预解式因子的范数乘以一个可计算的残差大小”的界。然后，讨论如何在不显式构造 $(s E - A)^{-1}$ 的情况下，通过在频率 $s$ 处的局部求解来获得预解式因子的可计算界，以及如何仅使用投影量来界定输入上的最坏情况残差。最后，将您的最终估计量表述为关于 Petrov–Galerkin 残差和预解式因子的单个闭式表达式。无需进行数值计算；请以符号形式提供最终的估计量表达式作为您的答案。", "solution": "该问题是有效的，因为它在科学上基于线性时不变系统的模型降阶理论，是适定、客观且自洽的。我们继续进行推导。\n\n我们的目标是为传递函数误差的诱导 2-范数 $\\|H(s) - \\hat{H}(s)\\|_{2}$ 在固定频率 $s \\in \\mathbb{C}$ 处推导一个后验误差估计量。推导将从状态变量的误差开始。\n\n设 $x(s) \\in \\mathbb{C}^{n}$ 为全系统的状态，$\\hat{x}(s) = V \\hat{z}(s) \\in \\mathbb{C}^{n}$ 为在频率 $s$ 处给定输入 $u \\in \\mathbb{C}^{m}$ 时降阶模型的近似状态。状态误差定义为 $e_x(s) = x(s) - \\hat{x}(s)$。\n\n根据问题陈述，全系统状态满足频域方程：\n$$ (s E - A) x(s) = B u $$\nPetrov-Galerkin 残差 $r_{u}(s)$ 定义为：\n$$ r_{u}(s) = B u - (s E - A) \\hat{x}(s) $$\n这可以重新排列以表示系统矩阵对近似状态的作用：\n$$ (s E - A) \\hat{x}(s) = B u - r_{u}(s) $$\n从全系统方程中减去该方程，我们得到状态误差的表达式：\n$$ (s E - A) x(s) - (s E - A) \\hat{x}(s) = B u - (B u - r_{u}(s)) $$\n$$ (s E - A) (x(s) - \\hat{x}(s)) = r_{u}(s) $$\n$$ (s E - A) e_x(s) = r_{u}(s) $$\n由于问题指出对于所选的 $s$，$ (s E - A)$ 是可逆的，我们可以正式地用残差来表示状态误差：\n$$ e_x(s) = (s E - A)^{-1} r_{u}(s) $$\n该方程提供了状态估计误差和可计算残差之间的直接联系。\n\n接下来，我们将状态误差与输出误差联系起来。全系统的输出是 $y(s) = C x(s)$，对应于近似状态的输出是 $\\hat{y}(s) = C \\hat{x}(s)$。输出误差为 $e_y(s) = y(s) - \\hat{y}(s)$。\n$$ e_y(s) = C x(s) - C \\hat{x}(s) = C(x(s) - \\hat{x}(s)) = C e_x(s) $$\n代入 $e_x(s)$ 的表达式，我们得到：\n$$ e_y(s) = C (s E - A)^{-1} r_{u}(s) $$\n输出误差也可以用传递函数误差来表示。根据定义，$y(s) = H(s) u$ 且 $\\hat{y}(s) = \\hat{H}(s) u$。因此：\n$$ e_y(s) = (H(s) - \\hat{H}(s)) u $$\n结合这两个输出误差的表达式，得到精确误差表示：\n$$ (H(s) - \\hat{H}(s)) u = C (s E - A)^{-1} r_{u}(s) $$\n为了找到传递函数误差范数 $\\|H(s) - \\hat{H}(s)\\|_{2}$ 的界，我们取两边的欧几里得向量范数（2-范数）。\n$$ \\|(H(s) - \\hat{H}(s)) u\\|_{2} = \\|C (s E - A)^{-1} r_{u}(s)\\|_{2} $$\n使用诱导算子范数的性质 $\\|M v\\|_{2} \\le \\|M\\|_{2} \\|v\\|_{2}$，我们可以建立一个不等式：\n$$ \\|(H(s) - \\hat{H}(s)) u\\|_{2} \\le \\|C (s E - A)^{-1}\\|_{2} \\|r_{u}(s)\\|_{2} $$\n进一步应用范数的次可乘性 $\\|MN\\|_{2} \\le \\|M\\|_{2} \\|N\\|_{2}$，可得：\n$$ \\|(H(s) - \\hat{H}(s)) u\\|_{2} \\le \\|C\\|_{2} \\|(s E - A)^{-1}\\|_{2} \\|r_{u}(s)\\|_{2} $$\n传递函数误差矩阵的诱导 2-范数定义为在所有单位范数输入上输出误差范数的最大放大率：\n$$ \\|H(s) - \\hat{H}(s)\\|_{2} = \\sup_{\\|u\\|_{2}=1} \\|(H(s) - \\hat{H}(s)) u\\|_{2} $$\n将此定义应用于我们的不等式，我们得到误差界：\n$$ \\|H(s) - \\hat{H}(s)\\|_{2} \\le \\sup_{\\|u\\|_{2}=1} \\left( \\|C\\|_{2} \\|(s E - A)^{-1}\\|_{2} \\|r_{u}(s)\\|_{2} \\right) $$\n由于 $\\|C\\|_{2}$ 和 $\\|(s E - A)^{-1}\\|_{2}$ 与输入 $u$ 无关，我们可以写成：\n$$ \\|H(s) - \\hat{H}(s)\\|_{2} \\le \\|C\\|_{2} \\|(s E - A)^{-1}\\|_{2} \\sup_{\\|u\\|_{2}=1} \\|r_{u}(s)\\|_{2} $$\n这个不等式提供了一个所需形式的后验误差界：一个“类预解式因子”，即 $\\|C\\|_{2} \\|(s E - A)^{-1}\\|_{2}$，乘以一个“可计算的残差大小”，即 $\\sup_{\\|u\\|_{2}=1} \\|r_{u}(s)\\|_{2}$。\n\n然后，问题要求讨论如何计算这个界中的因子。\n$1$. 预解式因子 $\\|(s E - A)^{-1}\\|_{2}$ 代表算子 $(s E - A)^{-1}$ 的最大放大因子。对于大规模系统，显式地构造逆矩阵在计算上是不可行的。相反，可以估计其范数。该范数等于 $(s E - A)$ 的最小奇异值的倒数，即 $\\|(s E - A)^{-1}\\|_{2} = 1/\\sigma_{\\min}(s E - A)$。这个奇异值可以使用迭代方法来估计，例如反幂法或应用于 $(s E - A)^{*}(s E - A)$ 或 $(s E - A)(s E - A)^{*}$ 的 Lanczos/Arnoldi 算法。这些方法的每次迭代都需要求解形如 $(s E - A)x=b$ 或 $(s E - A)^{*}x=b$ 的线性系统，这正是问题中提到的“在频率 $s$ 处的局部求解”。这些求解是通过诸如 GMRES 或 BiCGSTAB 等迭代方法完成的，这些方法仅需要与大型稀疏矩阵 $E$ 和 $A$ 进行矩阵向量积运算。\n\n$2$. 最坏情况残差大小 $\\sup_{\\|u\\|_{2}=1} \\|r_{u}(s)\\|_{2}$ 是残差算子的诱导 2-范数。为了说明这一点，我们将残差 $r_u(s)$ 表示为作用于 $u$ 的线性算子。根据定义，$\\hat{x}(s) = V \\hat{z}(s)$ 且 $\\hat{z}(s) = (s W^{*} E V - W^{*} A V)^{-1} W^{*} B u$。将此代入残差的定义中：\n$$ r_{u}(s) = B u - (s E - A) V \\left(s W^{*} E V - W^{*} A V\\right)^{-1} W^{*} B u $$\n$$ r_{u}(s) = \\left(I - (s E - A) V \\left(s W^{*} E V - W^{*} A V\\right)^{-1} W^{*} B\\right) u $$\n最坏情况残差是 $n \\times m$ 矩阵算子的范数：\n$$ \\sup_{\\|u\\|_{2}=1} \\|r_{u}(s)\\|_{2} = \\left\\| I - (s E - A) V \\left(s W^{*} E V - W^{*} A V\\right)^{-1} W^{*} B \\right\\|_{2} $$\n计算这个范数需要构造这个矩阵。这涉及到与大型矩阵 $A$ 和 $E$ 的运算（具体来说，是构造 $(sE-A)V = s(EV)-(AV)$），但也利用了“投影量” $W^*AV$、$W^*EV$ 和 $W^*B$ 来构造和求逆小的 $r \\times r$ 矩阵 $(s W^{*} E V - W^{*} A V)$。一旦构造了 $n \\times m$ 的残差算子矩阵，就可以计算其 2-范数（例如，通过 SVD），这在计算上成本很高，但提供了一个严格的界。对于某些投影基 $V$ 和 $W$ 的选择（例如，来自克雷洛夫方法），这个表达式可以显著简化。\n\n最后，问题要求将估计量表示为单个闭式表达式。推导出的上界即为后验误差估计量。将所有单位范数输入上的最坏情况残差范数表示为 $\\mathcal{R}(s) = \\sup_{\\|u\\|_{2}=1} \\|r_u(s)\\|_2$，则估计量 $\\Delta(s)$ 为：\n$$ \\Delta(s) = \\|C\\|_{2} \\|(s E - A)^{-1}\\|_{2} \\mathcal{R}(s) $$\n该表达式清晰地将估计量分为与全系统属性相关的因子（预解式）和与近似质量相关的因子（残差）。", "answer": "$$ \\boxed{\\|C\\|_{2} \\|(s E - A)^{-1}\\|_{2} \\sup_{\\|u\\|_{2}=1} \\|r_u(s)\\|_{2}} $$", "id": "3322125"}, {"introduction": "在实际的电磁应用中，器件通常在很宽的频率范围内工作，因此评估模型在整个频带上的性能至关重要。这个练习将前一个练习中的单频点误差分析扩展到宽带评估，要求您设计并实现一个宽带误差指标，通过在多个频率点上对残差进行加权求和来近似一个积分形式的误差范数，例如 $\\mathcal{H}_2$ 范数。掌握此方法使您能够有效地评估和比较不同降阶模型在整个工作频带内的保真度 [@problem_id:3322065]。", "problem": "考虑一个通过有限元方法离散化的麦克斯韦方程组的频域公式，它产生一个广义线性时不变系统，包含矩阵 $E \\in \\mathbb{R}^{n \\times n}$ 和 $A \\in \\mathbb{R}^{n \\times n}$、输入矩阵 $B \\in \\mathbb{R}^{n \\times m}$ 以及输出矩阵 $C \\in \\mathbb{R}^{p \\times n}$。对于一个复频率偏移 $s \\in \\mathbb{C}$，全阶状态 $X(s) \\in \\mathbb{C}^{n \\times m}$ 满足线性系统 $(sE - A) X(s) = B,$ 且相关的传递函数为 $H(s) = C X(s) = C (sE - A)^{-1} B.$ 在使用克雷洛夫子空间的基于投影的模型降阶中，一个列正交投影矩阵 $V \\in \\mathbb{R}^{n \\times r}$ 定义了降阶算子 $E_r = V^\\top E V, \\quad A_r = V^\\top A V, \\quad B_r = V^\\top B, \\quad C_r = C V.$ 状态的降阶近似为 $\\widetilde{X}(s) = V (s E_r - A_r)^{-1} B_r,$ 相应的降阶传递函数为 $H_r(s) = C_r (s E_r - A_r)^{-1} B_r.$\n\n可以通过聚合在多个频率偏移 $\\{ s_i \\}_{i=1}^q$ 处的信息来评估一个频率区间内的宽带精度。这些频率偏移点配有非负求积权重 $\\{ w_i \\}_{i=1}^q$，其选择旨在近似频带上的一个积分，这与虚轴上的哈代空间 $\\mathcal{H}_2$ 范数的思想一致。你的任务是设计一个误差指标，该指标结合在这些偏移点处由降阶近似产生的残差，其聚合过程由求积权重控制，从而使其作为一个在频带上具有物理意义且计算上易于处理的类 $\\mathcal{H}_2$ 范数的替代品。在某个偏移点处的残差应根据原始全阶算子和降阶近似状态来定义。\n\n基于第一性原理，推导出这样一个指标，并实现一个程序来为以下测试套件计算它。每个测试用例提供了 $E$、$A$、$B$、$V$、一个虚轴偏移列表 $s_i = \\jmath \\omega_i$（其中 $\\omega_i \\in \\mathbb{R}_{\\ge 0}$）以及求积权重 $w_i \\in \\mathbb{R}_{\\ge 0}$。在不同偏移点间进行组合的残差范数必须以一种对多个右端项（$B$ 的多列）一致的方式计算，并且跨偏移点的聚合必须包含给定的权重。\n\n你必须生成单行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表。将每个结果表示为浮点数。输出中不需要物理单位。\n\n使用以下测试套件：\n\n- 测试用例 1 (正常路径，多输入):\n  - $n=4$, $m=2$, $r=2$.\n  - $$E = \\mathrm{diag}(2.0,\\,1.5,\\,1.0,\\,0.8).$$\n  - $$A = \\begin{bmatrix}\n  6.0  -1.0  0.0  0.0 \\\\\n  -1.0  5.0  -1.0  0.0 \\\\\n  0.0  -1.0  4.5  -0.8 \\\\\n  0.0  0.0  -0.8  3.5\n  \\end{bmatrix}.$$\n  - $$B = \\begin{bmatrix}\n  1.0  0.5 \\\\\n  0.2  -0.3 \\\\\n  0.0  0.1 \\\\\n  -0.1  0.2\n  \\end{bmatrix}.$$\n  - $$V = \\begin{bmatrix}\n  1.0  0.0 \\\\\n  0.0  1.0 \\\\\n  0.0  0.0 \\\\\n  0.0  0.0\n  \\end{bmatrix}.$$\n  - 虚轴上的偏移: $\\omega_1 = 1.0\\times 10^8$, $\\omega_2 = 2.0\\times 10^8$, $\\omega_3 = 3.0\\times 10^8$.\n  - 在频带 $[1.0\\times 10^8,\\,3.0\\times 10^8]$ 上的辛普森法则权重: $w_1 = \\dfrac{2.0\\times 10^8}{6}$, $w_2 = \\dfrac{4\\cdot 2.0\\times 10^8}{6}$, $w_3 = \\dfrac{2.0\\times 10^8}{6}$.\n\n- 测试用例 2 (单位质量矩阵，零权重边界):\n  - $n=4$, $m=1$, $r=1$.\n  - $$E = I_4.$$\n  - $$A = \\begin{bmatrix}\n  4.0  -1.0  0.0  0.0 \\\\\n  -1.0  4.0  -1.0  0.0 \\\\\n  0.0  -1.0  3.5  -1.0 \\\\\n  0.0  0.0  -1.0  3.0\n  \\end{bmatrix}.$$\n  - $$B = \\begin{bmatrix}\n  1.0 \\\\\n  0.0 \\\\\n  0.5 \\\\\n  -0.2\n  \\end{bmatrix}.$$\n  - $$V = \\frac{1}{2} \\begin{bmatrix}\n  1.0 \\\\\n  1.0 \\\\\n  1.0 \\\\\n  1.0\n  \\end{bmatrix}.$$\n  - 偏移: $\\omega_1 = 5.0\\times 10^7$, $\\omega_2 = 1.5\\times 10^8$.\n  - 权重: $w_1 = 1.0$, $w_2 = 0.0$.\n\n- 测试用例 3 (近共振频带，单输入):\n  - $n=3$, $m=1$, $r=1$.\n  - $$E = \\mathrm{diag}(1.0,\\,0.8,\\,0.6).$$\n  - $$A = \\begin{bmatrix}\n  2.0  -0.9  0.0 \\\\\n  -0.9  2.2  -0.8 \\\\\n  0.0  -0.8  1.8\n  \\end{bmatrix}.$$\n  - $$B = \\begin{bmatrix}\n  0.3 \\\\\n  0.1 \\\\\n  0.2\n  \\end{bmatrix}.$$\n  - $$V = \\begin{bmatrix}\n  1.0 \\\\\n  0.0 \\\\\n  0.0\n  \\end{bmatrix}.$$\n  - 偏移: $\\omega_1 = 1.0\\times 10^7$, $\\omega_2 = 7.0\\times 10^7$, $\\omega_3 = 1.3\\times 10^8$, $\\omega_4 = 1.9\\times 10^8$.\n  - 对于均匀间距 $h = 6.0\\times 10^7$ 的梯形权重: $w_1 = \\dfrac{h}{2}$, $w_2 = h$, $w_3 = h$, $w_4 = \\dfrac{h}{2}$.\n\n- 测试用例 4 (一致性检查，全阶子空间应产生零残差):\n  - 使用与测试用例 3 中相同的 $E$、$A$、$B$、偏移和权重。\n  - 选择 $V = I_3$。\n\n你的程序应生成单行输出，其中包含方括号内以逗号分隔的结果列表（例如，$[result1,result2,result3,result4]$）。每个 $resultk$ 必须是一个浮点数，通过使用你推导出的指标，并利用给定的权重聚合在给定偏移点处的残差来计算得出。", "solution": "该问题要求针对由离散化麦克斯韦方程组产生的线性时不变系统，推导并实现一个用于基于投影的模型降阶的宽带误差指标。该指标必须将在多个频率点处的残差按求积系数加权聚合，以作为频带上类 $\\mathcal{H}_2$ 范数的替代。\n\n### 步骤 1：问题验证\n\n第一步是对问题陈述进行关键性验证。\n\n#### 步骤 1.1：提取的已知条件\n- **全阶系统**：\n  - 方程：$(sE - A) X(s) = B$\n  - 矩阵：$E \\in \\mathbb{R}^{n \\times n}$、$A \\in \\mathbb{R}^{n \\times n}$、$B \\in \\mathbb{R}^{n \\times m}$、$C \\in \\mathbb{R}^{p \\times n}$\n  - 状态：$X(s) \\in \\mathbb{C}^{n \\times m}$\n  - 传递函数：$H(s) = C (sE - A)^{-1} B$\n- **降阶系统**：\n  - 投影矩阵：$V \\in \\mathbb{R}^{n \\times r}$，列正交（$V^\\top V = I_r$）\n  - 降阶算子：$E_r = V^\\top E V$、$A_r = V^\\top A V$、$B_r = V^\\top B$、$C_r = C V$\n  - 近似状态：$\\widetilde{X}(s) = V (s E_r - A_r)^{-1} B_r$\n  - 近似传递函数：$H_r(s) = C_r (s E_r - A_r)^{-1} B_r$\n- **误差指标要求**：\n  - 采样点：一组复频率偏移 $\\{ s_i \\}_{i=1}^q$，其中 $s_i = \\jmath \\omega_i$ 且 $\\omega_i \\in \\mathbb{R}_{\\ge 0}$。\n  - 求积权重：一组非负权重 $\\{ w_i \\}_{i=1}^q$。\n  - 指标必须结合根据全阶算子（$E, A$）和降阶近似状态（$\\widetilde{X}(s)$）定义的残差。\n  - 聚合必须使用权重 $w_i$。\n  - 用于残差的范数必须对多个右端项（即 $B$ 的多列）保持一致。\n- **测试套件**：提供了四个测试用例，每个都指定了 $E$、$A$、$B$、$V$、偏移 $\\{\\omega_i\\}$ 和权重 $\\{w_i\\}$ 的数值。计算出的指标值的输出格式也已指定。注意，矩阵 $C$ 在前言中被引入，但在测试用例中并未提供，并且对于基于状态的残差计算不是必需的。\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n- **科学上合理**：该问题在基于投影的线性时不变系统模型降阶的既定理论中有坚实的基础，这是计算电磁学和控制理论中的一种标准技术。所有方程和定义都是标准的。\n- **适定的**：该问题是适定的。它要求基于清晰的约束推导一个特定量（误差指标），并提供了在测试套件中进行计算所需的所有数据。矩阵 $C$ 的缺失不是一个缺陷，因为任务明确要求根据状态近似 $\\widetilde{X}(s)$ 来定义残差，而不是输出近似 $H_r(s)$。\n- **客观的**：问题陈述使用了精确和客观的数学语言。\n- **缺陷分析**：\n  1.  **科学上不健全**：无。该框架是标准的。\n  2.  **不可形式化/不相关**：无。该问题高度具体且可形式化。\n  3.  **不完整/矛盾的设置**：无。计算基于状态的残差所需的所有数据都已提供。\n  4.  **不切实际/不可行**：无。所提供的矩阵是小型的、良态的，并且适合于计算测试。\n  5.  **不适定/结构不良**：无。推导过程会得出一个唯一且有意义的数值结果。\n  6.  **伪深刻/微不足道**：无。该任务需要正确的推导和实现，这并非微不足道。测试用例 4（其中投影空间是全空间）提供了一个非平凡的一致性检查。\n  7.  **超出科学可验证范围**：无。结果是可以通过数值进行验证的。\n\n#### 步骤 1.3：结论和行动\n问题是有效的。将推导并实现一个解决方案。\n\n### 步骤 2：误差指标的推导\n\n目标是构建一个标量误差指标 $\\mathcal{E}$，用于量化降阶模型在某个频带上的精度。推导按要求从第一性原理开始。\n\n1.  **状态残差**：误差的基本度量是残差，它量化了近似解满足原始控制方程的程度。全阶系统由 $(sE - A) X(s) = B$ 定义。我们将降阶模型的近似状态 $\\widetilde{X}(s)$ 代入此方程。由此产生的不平衡量就是状态残差矩阵 $R(s) \\in \\mathbb{C}^{n \\times m}$：\n    $$ R(s) = (sE - A) \\widetilde{X}(s) - B $$\n    较小的残差意味着对系统内部动力学的更好近似。\n\n2.  **残差的范数**：残差 $R(s)$ 是一个矩阵。为了在单个频率 $s_i$ 处量化其大小，我们需要一个矩阵范数。对于具有多个输入（即 $m > 1$）的问题，需要一个能公平对待残差矩阵所有列的范数。弗罗贝尼乌斯范数是自然的选择，因为它是欧几里得向量范数的矩阵扩展，并定义为其所有元素模的平方和的平方根。平方弗罗贝尼乌斯范数由下式给出：\n    $$ \\| R(s_i) \\|_F^2 = \\sum_{j=1}^n \\sum_{k=1}^m |(R(s_i))_{jk}|^2 = \\mathrm{Tr}(R(s_i)^H R(s_i)) $$\n    其中 $H$ 表示共轭转置。这种范数计算方便，并能恰当地聚合所有状态和所有输入的误差。\n\n3.  **跨频率聚合**：问题要求一个宽带误差指标，用于近似一个类 $\\mathcal{H}_2$ 范数，该范数由频率轴上的积分定义。我们给定了求积点 $s_i = \\jmath \\omega_i$ 和相应的权重 $w_i$。这种设置直接对应于近似积分的数值求积方案。残差的平方弗罗贝尼乌斯范数在频带上的积分可以通过加权和来近似：\n    $$ \\int_{\\text{band}} \\|R(\\jmath \\omega)\\|_F^2 \\, d\\omega \\approx \\sum_{i=1}^q w_i \\|R(s_i)\\|_F^2 $$\n    这个加权和，我们称之为 $\\mathcal{E}^2$，表示由给定求积法则近似的频带上的总平方误差。\n\n4.  **最终误差指标**：最终误差指标 $\\mathcal{E}$ 应具有与残差范数本身相同的单位，而不是其平方。因此，我们将该指标定义为聚合和的平方根：\n    $$ \\mathcal{E} = \\sqrt{\\sum_{i=1}^q w_i \\|R(s_i)\\|_F^2} $$\n    这就是我们为积分残差范数提出的具有物理意义且计算上易于处理的替代品。\n\n### 步骤 3：计算算法\n\n基于推导出的指标，其计算算法如下：\n\n1.  给定系统矩阵 $E, A, B$，投影矩阵 $V$，频率采样点 $\\{\\omega_i\\}_{i=1}^q$，以及求积权重 $\\{w_i\\}_{i=1}^q$。\n2.  预计算与频率无关的降阶矩阵：\n    $$ E_r = V^\\top E V \\quad \\in \\mathbb{R}^{r \\times r} $$\n    $$ A_r = V^\\top A V \\quad \\in \\mathbb{R}^{r \\times r} $$\n    $$ B_r = V^\\top B \\quad \\in \\mathbb{R}^{r \\times m} $$\n3.  初始化总加权平方误差变量，$\\mathcal{E}^2_{\\text{total}} = 0$。\n4.  对每个样本索引 $i = 1, \\dots, q$：\n    a.  设置复频率 $s_i = \\jmath \\omega_i$。\n    b.  构造此频率下的降阶系统矩阵：$M_{r,i} = s_i E_r - A_r$。\n    c.  求解 $r \\times r$ 复线性系统以获得降阶状态系数矩阵 $Y(s_i) \\in \\mathbb{C}^{r \\times m}$：\n        $$ M_{r,i} Y(s_i) = B_r \\implies Y(s_i) = M_{r,i}^{-1} B_r $$\n    d.  将解投影回全 $n$ 维空间，以获得近似状态 $\\widetilde{X}(s_i) \\in \\mathbb{C}^{n \\times m}$：\n        $$ \\widetilde{X}(s_i) = V Y(s_i) $$\n    e.  计算全阶残差矩阵 $R(s_i) \\in \\mathbb{C}^{n \\times m}$：\n        $$ R(s_i) = (s_i E - A) \\widetilde{X}(s_i) - B $$\n    f.  计算残差的平方弗罗贝尼乌斯范数，$\\epsilon_i^2 = \\|R(s_i)\\|_F^2$。\n    g.  将加权贡献加到总和中：$\\mathcal{E}^2_{\\text{total}} = \\mathcal{E}^2_{\\text{total}} + w_i \\epsilon_i^2$。\n5.  最终的误差指标是 $\\mathcal{E} = \\sqrt{\\mathcal{E}^2_{\\text{total}}}$。\n\n该算法将被实现以解决所提供的测试用例。对于测试用例 4，其中 $V = I_n$，我们有 $r=n$。降阶系统与全阶系统相同，导致 $\\widetilde{X}(s) = X(s)$。因此，对于所有 $s$，残差 $R(s)$ 必须为零，最终指标 $\\mathcal{E}$ 也必须为零。这可以作为实现正确性的一个关键检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a wideband error indicator for Krylov subspace model reduction.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, multiple inputs)\n        {\n            \"E\": np.diag([2.0, 1.5, 1.0, 0.8]),\n            \"A\": np.array([\n                [6.0, -1.0, 0.0, 0.0],\n                [-1.0, 5.0, -1.0, 0.0],\n                [0.0, -1.0, 4.5, -0.8],\n                [0.0, 0.0, -0.8, 3.5]\n            ]),\n            \"B\": np.array([\n                [1.0, 0.5],\n                [0.2, -0.3],\n                [0.0, 0.1],\n                [-0.1, 0.2]\n            ]),\n            \"V\": np.array([\n                [1.0, 0.0],\n                [0.0, 1.0],\n                [0.0, 0.0],\n                [0.0, 0.0]\n            ]),\n            \"omegas\": np.array([1.0e8, 2.0e8, 3.0e8]),\n            \"weights\": np.array([2.0e8 / 6, 4 * 2.0e8 / 6, 2.0e8 / 6])\n        },\n        # Test case 2 (identity mass, zero weight edge)\n        {\n            \"E\": np.identity(4),\n            \"A\": np.array([\n                [4.0, -1.0, 0.0, 0.0],\n                [-1.0, 4.0, -1.0, 0.0],\n                [0.0, -1.0, 3.5, -1.0],\n                [0.0, 0.0, -1.0, 3.0]\n            ]),\n            \"B\": np.array([\n                [1.0],\n                [0.0],\n                [0.5],\n                [-0.2]\n            ]),\n            \"V\": 0.5 * np.array([\n                [1.0],\n                [1.0],\n                [1.0],\n                [1.0]\n            ]),\n            \"omegas\": np.array([5.0e7, 1.5e8]),\n            \"weights\": np.array([1.0, 0.0])\n        },\n        # Test case 3 (near-resonant band, single input)\n        {\n            \"E\": np.diag([1.0, 0.8, 0.6]),\n            \"A\": np.array([\n                [2.0, -0.9, 0.0],\n                [-0.9, 2.2, -0.8],\n                [0.0, -0.8, 1.8]\n            ]),\n            \"B\": np.array([\n                [0.3],\n                [0.1],\n                [0.2]\n            ]),\n            \"V\": np.array([\n                [1.0],\n                [0.0],\n                [0.0]\n            ]),\n            \"omegas\": np.array([1.0e7, 7.0e7, 1.3e8, 1.9e8]),\n            \"weights\": np.array([6e7/2, 6e7, 6e7, 6e7/2])\n        },\n        # Test case 4 (consistency check, full-order subspace should give zero residual)\n        {\n            \"E\": np.diag([1.0, 0.8, 0.6]),\n            \"A\": np.array([\n                [2.0, -0.9, 0.0],\n                [-0.9, 2.2, -0.8],\n                [0.0, -0.8, 1.8]\n            ]),\n            \"B\": np.array([\n                [0.3],\n                [0.1],\n                [0.2]\n            ]),\n            \"V\": np.identity(3),\n            \"omegas\": np.array([1.0e7, 7.0e7, 1.3e8, 1.9e8]),\n            \"weights\": np.array([6e7/2, 6e7, 6e7, 6e7/2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E, A, B, V = case[\"E\"], case[\"A\"], case[\"B\"], case[\"V\"]\n        omegas, weights = case[\"omegas\"], case[\"weights\"]\n        \n        # 1. Compute reduced system matrices\n        E_r = V.T @ E @ V\n        A_r = V.T @ A @ V\n        B_r = V.T @ B\n\n        total_weighted_sq_err = 0.0\n\n        for omega, w in zip(omegas, weights):\n            if w == 0.0:\n                continue\n\n            # 2. Set complex frequency\n            s = 1j * omega\n\n            # 3. Solve the reduced system\n            # M_r * Y = B_r\n            M_r = s * E_r - A_r\n            try:\n                Y = np.linalg.solve(M_r, B_r)\n            except np.linalg.LinAlgError:\n                # Handle potential singularity, though not expected in these test cases\n                # If singular, the residual norm would be infinite.\n                Y = np.linalg.pinv(M_r) @ B_r\n            \n            # 4. Reconstruct approximate full-order state\n            X_tilde = V @ Y\n\n            # 5. Compute the residual\n            R = (s * E - A) @ X_tilde - B\n\n            # 6. Compute squared Frobenius norm of the residual\n            sq_frob_norm = np.linalg.norm(R, 'fro')**2\n\n            # 7. Add weighted contribution to total error\n            total_weighted_sq_err += w * sq_frob_norm\n\n        # 8. Compute the final indicator\n        indicator = np.sqrt(total_weighted_sq_err)\n        results.append(indicator)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3322065"}, {"introduction": "这个最终练习将理论与实践融合成一个强大的自适应工作流，代表了模型降阶领域的前沿技术。您将不再仅仅是在模型构建后被动地评估误差，而是主动地利用误差指标来指导模型的构建过程。通过实现一个自适应的克雷洛夫子空间增强策略，您的算法将能够自动识别当前模型的“弱点”（即误差最大的频率点），并迭代地优化模型，直到满足预设的精度要求为止。这个闭环反馈过程是构建高效且可靠的降阶模型的关键 [@problem_id:3322115]。", "problem": "实现一个完整的程序，该程序为矩形波导的一维替代模型构建、降阶和评估一个二阶线性时不变描述符模型，并计算一个宽带误差指标，该指标近似于模型降阶误差的哈代空间 $H_\\infty$ 范数。模型降阶必须使用一种自适应克雷洛夫子空间增广策略，该策略由采样频域误差指标的峰值驱动。\n\n从以下在计算电磁学中标准的基本和建模假设出发。在一个理想电导体矩形波导中，处于无损耗、均匀介质中，且磁导率和介电常数均为单位值（因此在归一化单位下波速 $c=1$），麦克斯韦方程组允许变量分离，分解为与横截面相关的截止常数和沿轴向坐标的传播方程。在一个沿轴向坐标 $z \\in (0,L)$ 的单模替代模型中，其截止波数为 $k_c = \\pi/a$（对应于宽度为 $a$ 的矩形波导中的主模），横向场分量可以通过频域中的标量二阶系统来建模\n$$\n(K - \\omega^2 M)\\, q(\\omega) = b, \\quad y(\\omega) = c^\\top q(\\omega),\n$$\n其中 $M$ 是一个对称正定的“质量”算子，$K$ 是一个对称正定的“刚度”算子，它既包括轴向二阶导数也包括截止项 $k_c^2$，$b$ 是一个位于 $z=0$ 附近的输入激励，$c$ 用于提取 $z=L$ 附近的响应。频率变量是角频率 $\\omega$，单位为弧度/秒。相应的单输入单输出传递函数为\n$$\nG(\\mathrm{j}\\omega) = c^\\top (K - \\omega^2 M)^{-1} b.\n$$\n\n通过 $N_z$ 个内部网格点对区间 $(0,L)$ 进行离散化，网格间距为 $h = L/(N_z+1)$，并在 $z=0$ 和 $z=L$ 处施加狄利克雷边界条件（理想电导体终端）。使用一维拉普拉斯算子的标准二阶中心有限差分近似来构建刚度矩阵\n$$\nK = T + k_c^2 I, \\quad T = \\frac{1}{h^2}\\,\\text{tridiag}(-1,2,-1)\\in\\mathbb{R}^{N_z\\times N_z}, \\quad k_c = \\frac{\\pi}{a},\n$$\n并将质量矩阵设置为\n$$\nM = I \\in \\mathbb{R}^{N_z\\times N_z}.\n$$\n在最左侧的内部节点使用单位点输入，并在最右侧的内部节点提取响应，即\n$$\nb = e_1 \\in \\mathbb{R}^{N_z}, \\quad c = e_{N_z} \\in \\mathbb{R}^{N_z}.\n$$\n\n定义一个通过对频率轴进行均匀采样来近似 $\\lVert G - G_r\\rVert_{H_\\infty}$ 的宽带误差指标，\n$$\n\\mathcal{E} = \\max_{\\omega\\in\\Omega_{\\mathrm{s}}} \\left| G(\\mathrm{j}\\omega) - G_r(\\mathrm{j}\\omega)\\right|,\n$$\n其中 $\\Omega_{\\mathrm{s}} = \\{\\omega_1,\\dots,\\omega_{N_\\Omega}\\}$ 是用户指定的一组角频率（单位为弧度/秒），$G(\\mathrm{j}\\omega)$ 是全阶传递函数，$G_r(\\mathrm{j}\\omega)$ 是降阶传递函数。\n\n通过投影到二阶形式的有理克雷洛夫子空间上来构建降阶模型，该子空间由在自适应选择的频率下的频移解构建而成。具体来说，对于每个选定的角频率 $\\omega_k$，构建向量\n$v_k = (K - \\omega_k^2 M)^{-1} b,$\n在标准的欧几里得内积下，将其与当前的基 $\\{v_1,\\dots,v_{k-1}\\}$ 进行正交归一化，并增广基矩阵 $V = [v_1,\\dots,v_r]$。然后定义降阶算子以及降阶输入和输出为\n$K_r = V^H K V,\\quad M_r = V^H M V,\\quad b_r = V^H b,\\quad c_r^\\top = c^\\top V,$\n降阶传递函数为\n$G_r(\\mathrm{j}\\omega) = c_r^\\top (K_r - \\omega^2 M_r)^{-1} b_r.$\n使用以下自适应增广策略：\n- 使用在采样频带中点频率处计算的一个向量来初始化基。\n- 在每次迭代中，在整个采样集 $\\Omega_{\\mathrm{s}}$ 上评估采样指标 $\\left| G(\\mathrm{j}\\omega) - G_r(\\mathrm{j}\\omega)\\right|$，找到使该指标最大化的峰值频率 $\\omega_\\star$，并用新向量 $(K - \\omega_\\star^2 M)^{-1} b$（经正交归一化后）来增广基。\n- 当当前最大采样指标低于给定容差或达到允许的最大基大小时停止。\n\n为了避免在谐振点出现精确的奇异性，通过将 $K - \\omega^2 M$ 替换为 $K - (1 - \\mathrm{j}\\eta)\\omega^2 M$ 来在采样和增广求解中增加一个无穷小的正损耗，其中 $\\eta$ 是一个固定的微小正常数。\n\n角度单位必须是弧度/秒。所有其他量在归一化单位系统中都是无量纲的。每个测试所需的最终答案是纯数字（浮点数和整数），输出中不带单位标签。\n\n您的程序必须实现上述内容并运行以下测试套件。对于每个测试用例，构建模型，运行自适应增广，并报告一个三元组，包括：\n- 最终最大采样指标 $\\mathcal{E}$（浮点数），\n- 最后一次迭代的指标达到其最大值时的角频率 $\\omega_\\star$（浮点数），\n- 最终的降阶基大小 $r$（整数）。\n\n每个测试用例由元组 $(N_z, L, a, \\omega_{\\min}, \\omega_{\\max}, N_\\Omega, \\text{tol}, r_{\\max})$ 指定：\n1. $(60, 1.0, 1.0, 2.0, 3.5, 40, 1\\times 10^{-5}, 6)$\n2. $(60, 1.0, 1.0, 4.0, 6.0, 60, 1\\times 10^{-4}, 12)$\n3. $(60, 1.0, 1.0, 6.5, 8.5, 60, 1\\times 10^{-4}, 14)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应测试用例的 $[\\mathcal{E}, \\omega_\\star, r]$ 顺序的列表。例如，对于三个测试，一个语法上有效的输出应如下所示\n“[ [0.0123,4.567,5],[0.001,5.432,7],[0.1,7.0,8] ]”\n但使用您的实现所计算的实际值。角频率必须以弧度/秒为单位。不应打印任何附加文本。", "solution": "所提出的问题是有效的，因为它在科学上是合理的、适定的、客观和完整的，仅缺少一个可以假设的标准数值参数。它要求为一个二阶系统实现一个自适应模型降阶方案，这在计算科学与工程领域是一个成熟的流程。\n\n目标是为一个一维有限差分法离散化的替代波导模型构建一个降阶模型（ROM）。此降阶将使用自适应有理克雷洛夫子空间方法执行，其中子空间通过迭代选择新的展开频率来增广，这些频率对应于全阶模型（FOM）与降阶模型（ROM）之间频域误差的峰值。\n\n### 1. 全阶模型（FOM）构建\n\n问题从频域中的一个二阶线性时不变系统开始，该系统代表了单模波导中的横向场分量：\n$$\n(K - \\omega^2 M)\\, q(\\omega) = b, \\quad y(\\omega) = c^\\top q(\\omega)\n$$\n系统的频率响应由传递函数 $G(\\mathrm{j}\\omega) = c^\\top (K - \\omega^2 M)^{-1} b$ 表征。\n\n空间域是区间 $z \\in (0, L)$，使用 $N_z$ 个内部网格点进行离散化。网格间距为 $h = L / (N_z + 1)$。模型在 $z=0$ 和 $z=L$ 处采用狄利克雷边界条件。\n\n系统矩阵定义如下：\n-   **质量矩阵** $M$ 是单位矩阵，$M = I \\in \\mathbb{R}^{N_z \\times N_z}$。\n-   **刚度矩阵** $K \\in \\mathbb{R}^{N_z \\times N_z}$ 由 $K = T + k_c^2 I$ 给出，其中 $k_c = \\pi/a$ 是截止波数。矩阵 $T$ 是负二阶导数算子的标准二阶中心有限差分近似，并按 $1/h^2$ 缩放：\n    $$\n    T = \\frac{1}{h^2}\n    \\begin{pmatrix}\n    2  -1   \\\\\n    -1  2  -1  \\\\\n     \\ddots  \\ddots  \\ddots \\\\\n      -1  2  -1 \\\\\n       -1  2\n    \\end{pmatrix}\n    $$\n    $K$ 和 $M$ 都是对称正定的。\n-   **输入向量** $b$ 代表在第一个内部节点的点源激励，$b = e_1 = [1, 0, \\dots, 0]^\\top \\in \\mathbb{R}^{N_z}$。\n-   **输出向量** $c$ 代表在最后一个内部节点的探针，$c = e_{N_z} = [0, \\dots, 0, 1]^\\top \\in \\mathbb{R}^{N_z}$。\n\n### 2. 通过投影进行模型降阶\n\n模型降阶旨在找到全阶模型的一个低维近似。我们使用一种基于投影的方法，其中状态向量 $q(\\omega) \\in \\mathbb{C}^{N_z}$ 在一个低维子空间内被近似。该子空间由一个正交矩阵 $V \\in \\mathbb{C}^{N_z \\times r}$ 的列向量张成，其中 $r \\ll N_z$ 是降阶模型的阶数。近似为 $q(\\omega) \\approx V z(\\omega)$，其中 $z(\\omega) \\in \\mathbb{C}^r$ 是降阶状态向量。\n\n将此假设代入全阶模型方程并应用伽辽金投影（强制残差与由 $V$ 张成的子空间正交），得到降阶模型：\n$$\nV^H (K - \\omega^2 M) V z(\\omega) = V^H b\n$$\n$$\n(V^H K V - \\omega^2 V^H M V) z(\\omega) = V^H b\n$$\n这定义了降阶系统矩阵：\n-   降阶刚度矩阵：$K_r = V^H K V \\in \\mathbb{C}^{r \\times r}$\n-   降阶质量矩阵：$M_r = V^H M V \\in \\mathbb{C}^{r \\times r}$\n-   降阶输入向量：$b_r = V^H b \\in \\mathbb{C}^r$\n\n降阶输出为 $y_r(\\omega) = c^\\top (V z(\\omega)) = (c^\\top V) z(\\omega) = c_r^\\top z(\\omega)$，降阶输出向量定义为 $c_r = V^H c \\in \\mathbb{C}^r$。注意这里使用了共轭转置来形成 $c_r$，当 $V$ 是复数时，这是为了保持一致性所必需的。\n\n降阶传递函数则为：\n$$\nG_r(\\mathrm{j}\\omega) = c_r^\\top (K_r - \\omega^2 M_r)^{-1} b_r\n$$\n\n### 3. 自适应有理克雷洛夫方法\n\n降阶模型的质量关键取决于投影基 $V$ 的选择。问题指定了一种自adaptive有理克雷洛夫方法。基向量由全阶模型在特定、自适应选择的角频率（展开点）$\\omega_k$ 下的解生成：\n$$\nv'_k = (K - \\omega_k^2 M)^{-1} b\n$$\n然后将这些向量正交归一化以形成基 $V = [v_1, v_2, \\dots, v_r]$。我们使用数值稳定的修正格拉姆-施密特（MGS）算法进行正交归一化。对于一个新向量 $v'$，MGS 通过依次移除其在每个现有基向量上的投影来进行。\n\n自适应过程如下：\n1.  **初始化**：感兴趣的频带为 $[\\omega_{\\min}, \\omega_{\\max}]$，在该频带上采样 $N_\\Omega$ 个点以形成集合 $\\Omega_s$。初始基由单个向量组成（$r=1$），该向量在中点频率 $\\omega_1 = (\\omega_{\\min} + \\omega_{\\max}) / 2$ 处生成。\n2.  **迭代**：算法通过迭代进行，以增广基。在每次迭代中，对于大小为 $r$ 的基：\n    a. 构建降阶模型 $\\{K_r, M_r, b_r, c_r\\}$。\n    b. 通过在采样频率上找到全阶和降阶传递函数之间绝对差的最大值来计算误差指标 $\\mathcal{E}$：\n       $$\n       \\mathcal{E} = \\max_{\\omega \\in \\Omega_s} |G(\\mathrm{j}\\omega) - G_r(\\mathrm{j}\\omega)|\n       $$\n    c. 确定出现此最大误差的频率 $\\omega_\\star \\in \\Omega_s$。\n    d. **停止准则检查**：如果 $\\mathcal{E}$ 低于指定的容差 `tol`，或者如果基的大小 $r$ 已达到允许的最大大小 `r_max`，则算法终止。\n    e. **增广**：如果未满足停止准则，则用一个新向量增广基。这个新向量是使用 $\\omega_\\star$ 作为下一个展开点生成的。计算原始向量 $(K - \\omega_\\star^2 M)^{-1} b$，并使用 MGS 对其与现有基向量进行正交归一化，以产生 $v_{r+1}$。更新基，$V \\leftarrow [V, v_{r+1}]$，其大小变为 $r+1$。\n\n### 4. 数值实现\n\n为了避免当展开频率 $\\omega_k$ 与无阻尼系统的固有频率（谐振点）重合时出现奇异性，引入了一个小的人为阻尼项。系统矩阵被修改为 $K - (1 - \\mathrm{j}\\eta)\\omega^2 M$，其中 $\\eta$ 是一个微小的正常数。对于此问题，选择标准值 $\\eta = 10^{-8}$。这一修改使系统矩阵变为复数，因此基 $V$ 和降阶矩阵也将是复数。\n\n求解算法如下：\n1.  对于每个测试用例，构建全阶模型矩阵 $K, M, b, c$。$K$ 被构建为稀疏矩阵。\n2.  对所有 $\\omega \\in \\Omega_s$，预先计算全阶模型传递函数 $G(\\mathrm{j}\\omega)$。这是通过为每个频率求解复线性系统 $(K - (1 - \\mathrm{j}\\eta)\\omega^2 M)q(\\omega)=b$ 来完成的。\n3.  用在频带中点频率处生成的一个向量初始化基 $V$。设置 $r=1$。\n4.  进入自适应循环：\n    - 构建当前的 $r \\times r$ 降阶模型。\n    - 在 $\\Omega_s$ 上评估降阶模型传递函数 $G_r(\\mathrm{j}\\omega)$。这涉及为每个频率求解一个小的 $r \\times r$ 线性系统。\n    - 计算误差指标 $\\mathcal{E}$ 及其峰值频率 $\\omega_\\star$。\n    - 如果 $\\mathcal{E}  \\text{tol}$ 或 $r \\ge r_{\\max}$，退出循环并报告 $(\\mathcal{E}, \\omega_\\star, r)$。\n    - 否则，使用 $\\omega_\\star$ 作为展开点并通过 MGS 过程将基的大小增广到 $r+1$。递增 $r$ 并继续循环。\n\n此过程为每个测试用例产生最终误差、该误差的峰值频率以及降阶模型的最终大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg as sla\n\ndef build_fom(Nz, L, a):\n    \"\"\"Builds the full-order model matrices and vectors.\"\"\"\n    h = L / (Nz + 1)\n    kc = np.pi / a\n\n    # Stiffness matrix T for the 1D Laplacian\n    diagonals = [-np.ones(Nz-1), 2*np.ones(Nz), -np.ones(Nz-1)]\n    T = sparse.diags(diagonals, [-1, 0, 1], shape=(Nz, Nz), format='csc') / (h**2)\n    \n    # K and M matrices\n    I_Nz = sparse.identity(Nz, format='csc')\n    K = T + (kc**2) * I_Nz\n    M = I_Nz.copy()\n\n    # Input and output vectors\n    b = np.zeros(Nz)\n    b[0] = 1.0\n    c = np.zeros(Nz)\n    c[Nz-1] = 1.0\n\n    return K, M, b, c\n\ndef evaluate_transfer_function(sys_mat, b, c, omega_samples, eta, is_fom=True):\n    \"\"\"Evaluates the transfer function G(jw) for a set of frequencies.\"\"\"\n    K, M = sys_mat\n    Nz = K.shape[0]\n    G_values = np.zeros(len(omega_samples), dtype=np.complex128)\n\n    if is_fom:\n        # For FOM, K and M are sparse\n        for i, w in enumerate(omega_samples):\n            if w == 0:\n                # Handle DC case, though not expected in test cases\n                A = K\n            else:\n                A = K - (1 - 1j * eta) * (w**2) * M\n            # Use sparse solver for the large system\n            q = sla.spsolve(A, b)\n            G_values[i] = c.T @ q\n    else:\n        # For ROM, Kr and Mr are small dense matrices\n        Kr, Mr = sys_mat\n        br, cr_T = b, c\n        for i, w in enumerate(omega_samples):\n            if w == 0:\n                Ar = Kr\n            else:\n                Ar = Kr - (w**2) * Mr\n            # Use dense solver for the small system\n            zr = np.linalg.solve(Ar, br)\n            G_values[i] = cr_T @ zr\n            \n    return G_values\n\ndef run_adaptive_reduction(Nz, L, a, w_min, w_max, Nw, tol, r_max):\n    \"\"\"Performs the adaptive Krylov subspace model reduction.\"\"\"\n    eta = 1e-8\n    \n    # 1. Setup FOM and frequency samples\n    K, M, b, c = build_fom(Nz, L, a)\n    omega_samples = np.linspace(w_min, w_max, Nw)\n\n    # 2. Pre-compute FOM response\n    G_full = evaluate_transfer_function((K, M), b, c, omega_samples, eta, is_fom=True)\n\n    # 3. Initialization (r=1)\n    w_expand = (w_min + w_max) / 2.0\n    A_expand = K - (1 - 1j * eta) * (w_expand**2) * M\n    v_raw = sla.spsolve(A_expand, b)\n    v_new = v_raw / np.linalg.norm(v_raw)\n    V = v_new.reshape(-1, 1)\n    r = 1\n\n    # 4. Adaptive loop\n    while True:\n        # Project FOM to create ROM\n        br = V.T.conj() @ b\n        cr_T = c.T @ V # c is real, so c.T is fine\n        Kr = V.T.conj() @ K @ V\n        Mr = V.T.conj() @ M @ V\n\n        # Evaluate ROM response\n        G_reduced = evaluate_transfer_function((Kr, Mr), br, cr_T, omega_samples, eta, is_fom=False)\n\n        # Compute error\n        error_indicator = np.abs(G_full - G_reduced)\n        max_error = np.max(error_indicator)\n        w_star_idx = np.argmax(error_indicator)\n        w_star = omega_samples[w_star_idx]\n\n        # Check stopping criteria\n        if max_error  tol or r >= r_max:\n            return max_error, w_star, r\n\n        # Enrich basis at peak error frequency\n        w_expand = w_star\n        A_expand = K - (1 - 1j * eta) * (w_expand**2) * M\n        v_raw = sla.spsolve(A_expand, b)\n        \n        # Modified Gram-Schmidt orthonormalization\n        w = v_raw.copy()\n        for i in range(r):\n            v_i = V[:, i]\n            proj_coeff = np.vdot(v_i, w)\n            w -= proj_coeff * v_i\n        \n        norm_w = np.linalg.norm(w)\n        if norm_w  1e-10: \n            # Vector is linearly dependent, stop enrichment\n            return max_error, w_star, r\n            \n        v_new = w / norm_w\n        V = np.hstack((V, v_new.reshape(-1, 1)))\n        r += 1\n\n\ndef solve():\n    test_cases = [\n        # (Nz, L, a, w_min, w_max, Nw, tol, r_max)\n        (60, 1.0, 1.0, 2.0, 3.5, 40, 1e-5, 6),\n        (60, 1.0, 1.0, 4.0, 6.0, 60, 1e-4, 12),\n        (60, 1.0, 1.0, 6.5, 8.5, 60, 1e-4, 14),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, w_star, r = run_adaptive_reduction(*case)\n        results.append([E, w_star, r])\n\n    # Format output string manually to match the required format\n    # \"[ [E1,w1,r1],[E2,w2,r2],... ]\"\n    results_str_list = []\n    for res in results:\n        # res[0] is E (float), res[1] is w_star (float), res[2] is r (int)\n        results_str_list.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3322115"}]}