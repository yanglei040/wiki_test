{"hands_on_practices": [{"introduction": "Buffa-Christiansen (BC) 基函数属于一类“散度整合” ($H(\\mathrm{div}_{\\Gamma})$ conforming) 基函数，在计算电磁学中至关重要。本练习将引导你通过第一性原理，验证这些函数的一个关键局部性质。通过在一个由两个三角形组成的简单片面上应用高斯散度定理，你将亲自证明，跨共享边的法向连续性条件如何确保了内部基函数的总散度积分为零 [@problem_id:3290791]。", "problem": "考虑一个位于平面 $z=0$ 内的平坦曲面片，它由构成单位正方形的两个三角形组成。设顶点为 $v_{1}=(0,0,0)$、$v_{2}=(1,0,0)$、$v_{3}=(0,1,0)$ 和 $v_{4}=(1,1,0)$。定义两个有向三角形 $T^{+}=[v_{1},v_{2},v_{3}]$ 和 $T^{-}=[v_{2},v_{4},v_{3}]$，它们共享内边 $e=[v_{2},v_{3}]$。令 $\\Gamma=T^{+}\\cup T^{-}$ 表示该曲面片，并令 $\\partial\\Gamma$ 为其外边界，由四条外边 $[v_{1},v_{2}]$、$[v_{1},v_{3}]$、$[v_{2},v_{4}]$ 和 $[v_{4},v_{3}]$ 组成。\n\n在每个三角形 $T\\in\\{T^{+},T^{-}\\}$上，考虑最低阶的 Raviart–Thomas 空间 (RT0)，当限制在平面 $z=0$ 时，该空间由形式为 $u(\\boldsymbol{x})=\\boldsymbol{a}+b\\,\\boldsymbol{x}$ 的向量场组成，其中 $\\boldsymbol{a}\\in\\mathbb{R}^{2}$ 且 $b\\in\\mathbb{R}$。与内边 $e$ 相关联的 Buffa–Christiansen 基函数 $b_{e}\\in H(\\mathrm{div}_{\\Gamma},\\Gamma)$ 是通过取 $b_{e}|_{T^{+}}\\in \\mathrm{RT0}(T^{+})$ 和 $b_{e}|_{T^{-}}\\in \\mathrm{RT0}(T^{-})$ 组合而成，使得：\n- 在 $\\partial\\Gamma$ 的每条外边界边上，$b_{e}\\cdot \\boldsymbol{\\nu}=0$，其中 $\\boldsymbol{\\nu}$ 表示平面内 $\\partial T^{\\pm}$ 的单位向外余法向量，\n- 跨共享边 $e$ 的法向分量是连续的，且\n- 归一化选择为，在 $T^{+}$ 上跨过 $e$ 的边通量等于 $\\int_{e} b_{e}\\cdot \\boldsymbol{\\nu}_{e}^{+}\\,\\mathrm{d}\\ell=1$，其中 $\\boldsymbol{\\nu}_{e}^{+}$ 是 $T^{+}$ 沿 $e$ 的单位向外余法向量。\n\n仅从上述定义和曲面散度定理出发，显式计算积分的值\n$$\nI \\;=\\; \\int_{\\Gamma} \\mathrm{div}_{\\Gamma}\\, b_{e}\\,\\mathrm{d}S.\n$$\n你的计算必须是自洽的，并且只能使用指定的曲面片几何数据和为 $b_{e}$ 列出的性质。将你的最终答案表示为一个实数。不需要单位。", "solution": "该问题被评估为有效。在计算电磁学的数值分析领域，这是一个适定的、有科学依据的问题。所有提供的信息都是一致的，并且足以推导出唯一的解。\n\n目标是计算积分 $I = \\int_{\\Gamma} \\mathrm{div}_{\\Gamma}\\, b_{e}\\,\\mathrm{d}S$。积分区域 $\\Gamma$ 是一个由两个三角形组成的曲面片，$\\Gamma = T^{+} \\cup T^{-}$。向量场 $b_e$ 是分段定义的，其在每个三角形上的限制 $b_e|_{T^+}$ 和 $b_e|_{T^-}$ 都是一个光滑函数（具体来说，是来自RT0空间的多项式向量场）。因此，我们可以将 $\\Gamma$ 上的积分分解为两个三角形上的积分之和：\n$$\nI = \\int_{T^{+}} \\mathrm{div}_{\\Gamma}\\, (b_e|_{T^{+}})\\,\\mathrm{d}S + \\int_{T^{-}} \\mathrm{div}_{\\Gamma}\\, (b_e|_{T^{-}})\\,\\mathrm{d}S\n$$\n由于曲面片 $\\Gamma$ 是平坦的，且位于平面 $z=0$ 中，曲面散度算子 $\\mathrm{div}_{\\Gamma}$ 与标准的二维散度相同，我们将其表示为 $\\mathrm{div}$。我们把 $b_e$ 在三角形上的限制表示为 $b_e^{+} = b_e|_{T^{+}}$ 和 $b_e^{-} = b_e|_{T^{-}}$。$I$ 的表达式变为：\n$$\nI = \\int_{T^{+}} \\mathrm{div}\\, b_{e}^{+}\\,\\mathrm{d}S + \\int_{T^{-}} \\mathrm{div}\\, b_{e}^{-}\\,\\mathrm{d}S\n$$\n问题指出，计算应基于曲面散度定理。我们分别对每个积分项应用此定理。\n\n对于 $T^{+}$ 上的积分：\n散度定理应用于三角形 $T^{+}$，表明向量场散度在该三角形面积上的积分等于向量场通过其边界 $\\partial T^{+}$ 的通量：\n$$\n\\int_{T^{+}} \\mathrm{div}\\, b_{e}^{+}\\,\\mathrm{d}S = \\oint_{\\partial T^{+}} b_{e}^{+} \\cdot \\boldsymbol{\\nu}^{+} \\,\\mathrm{d}\\ell\n$$\n其中 $\\boldsymbol{\\nu}^{+}$ 是边界 $\\partial T^{+}$ 上的向外单位余法向量。$T^{+} = [v_1, v_2, v_3]$ 的边界由三条边组成：$[v_1, v_2]$、$[v_3, v_1]$ 和共享的内边 $e = [v_2, v_3]$。边 $[v_1, v_2]$ 和 $[v_1, v_3]$（$[v_3, v_1]$ 所在的位置）是外边界 $\\partial\\Gamma$ 的一部分。\n\n根据 $b_e$ 的性质2，向量场的法向分量在曲面片 $\\Gamma$ 的外边界上为零：在 $\\partial\\Gamma$ 上，$b_{e}\\cdot \\boldsymbol{\\nu}=0$。这意味着在 $\\partial T^{+}$ 位于 $\\partial\\Gamma$ 上的部分的通量积分为零。因此，边界积分简化为仅在内边 $e$ 上的积分：\n$$\n\\oint_{\\partial T^{+}} b_{e}^{+} \\cdot \\boldsymbol{\\nu}^{+} \\,\\mathrm{d}\\ell = \\int_{e} b_{e}^{+} \\cdot \\boldsymbol{\\nu}_{e}^{+} \\,\\mathrm{d}\\ell\n$$\n其中 $\\boldsymbol{\\nu}_{e}^{+}$ 是 $T^{+}$ 沿边 $e$ 的向外单位余法向量，与问题的符号一致。\n\n$b_e$ 的性质4提供了归一化条件，这正是该积分的值：\n$$\n\\int_{e} b_{e}\\cdot \\boldsymbol{\\nu}_{e}^{+}\\,\\mathrm{d}\\ell = 1\n$$\n因此，我们 $I$ 表达式中的第一项是：\n$$\n\\int_{T^{+}} \\mathrm{div}\\, b_{e}^{+}\\,\\mathrm{d}S = 1\n$$\n\n对于 $T^{-}$ 上的积分：\n类似地，我们将散度定理应用于三角形 $T^{-}$：\n$$\n\\int_{T^{-}} \\mathrm{div}\\, b_{e}^{-}\\,\\mathrm{d}S = \\oint_{\\partial T^{-}} b_{e}^{-} \\cdot \\boldsymbol{\\nu}^{-} \\,\\mathrm{d}\\ell\n$$\n其中 $\\boldsymbol{\\nu}^{-}$ 是边界 $\\partial T^{-}$ 上的向外单位余法向量。$T^{-} = [v_2, v_4, v_3]$ 的边界由外边 $[v_2, v_4]$ 和 $[v_4, v_3]$ 以及内边 $[v_3, v_2]$（对应于 $-e$）组成。同样，性质2确保了通过外边的通量为零。边界积分简化为在共享边 $e$ 上的积分：\n$$\n\\oint_{\\partial T^{-}} b_{e}^{-} \\cdot \\boldsymbol{\\nu}^{-} \\,\\mathrm{d}\\ell = \\int_{e} b_{e}^{-} \\cdot \\boldsymbol{\\nu}_{e}^{-} \\,\\mathrm{d}\\ell\n$$\n其中 $\\boldsymbol{\\nu}_{e}^{-}$ 是 $T^{-}$ 沿边 $e$ 的向外单位余法向量。\n\n现在，我们必须使用性质3，它指出 $b_e$ 跨共享边 $e$ 的法向分量是连续的。对于空间 $H(\\mathrm{div}_{\\Gamma},\\Gamma)$ 中的向量场，跨两个单元 $T^{+}$ 和 $T^{-}$ 之间内界面 $e$ 的法向分量的连续性表示为：\n$$\n(b_e|_{T^{+}}) \\cdot \\boldsymbol{\\nu}_{e}^{+} + (b_e|_{T^{-}}) \\cdot \\boldsymbol{\\nu}_{e}^{-} = 0 \\quad \\text{for all points on } e\n$$\n这个条件确保了离开 $T^{+}$ 穿过 $e$ 的通量等于进入 $T^{-}$ 穿过 $e$ 的通量。由此关系，我们得到：\n$$\nb_{e}^{-} \\cdot \\boldsymbol{\\nu}_{e}^{-} = -b_{e}^{+} \\cdot \\boldsymbol{\\nu}_{e}^{+} \\quad \\text{on } e\n$$\n将此代入第二项的积分中，我们发现：\n$$\n\\int_{e} b_{e}^{-} \\cdot \\boldsymbol{\\nu}_{e}^{-} \\,\\mathrm{d}\\ell = \\int_{e} (-b_{e}^{+} \\cdot \\boldsymbol{\\nu}_{e}^{+}) \\,\\mathrm{d}\\ell = - \\int_{e} b_{e}^{+} \\cdot \\boldsymbol{\\nu}_{e}^{+} \\,\\mathrm{d}\\ell\n$$\n再次使用性质4，$\\int_{e} b_{e}^{+} \\cdot \\boldsymbol{\\nu}_{e}^{+} \\,\\mathrm{d}\\ell = 1$，我们得到：\n$$\n\\int_{T^{-}} \\mathrm{div}\\, b_{e}^{-}\\,\\mathrm{d}S = -1\n$$\n\n最后，我们将两个三角形的结果相加，求得总积分 $I$：\n$$\nI = \\left(\\int_{T^{+}} \\mathrm{div}\\, b_{e}^{+}\\,\\mathrm{d}S\\right) + \\left(\\int_{T^{-}} \\mathrm{div}\\, b_{e}^{-}\\,\\mathrm{d}S\\right) = 1 + (-1) = 0\n$$\n积分为 $0$。这个结果反映了像 Buffa-Christiansen 函数这样的散度协调基函数的一个基本性质：在一个内部基函数的支集上的总散度为零。", "answer": "$$\\boxed{0}$$", "id": "3290791"}, {"introduction": "从局部性质转向全局应用，我们来探讨 BC 基函数最著名的贡献之一：解决电场积分方程 (EFIE) 的“低频崩溃”问题。这个编码练习将通过一个简化的代数模型，直观地展示为什么选择 BC 函数作为测试函数的 Petrov-Galerkin 方法能够稳定系统矩阵，有效避免传统 Galerkin 方法在频率 $k$ 趋近于零时出现的严重病态问题 [@problem_id:3290751]。", "problem": "考虑频域中理想电导体散射体的电场积分方程 (EFIE)。设时谐波数为 $k$ (单位为 $\\mathrm{m}^{-1}$)。EFIE 通过由矢量位和标量位构建的边界积分算子，将 Lipschitz 曲面 $\\Gamma$ 上的表面电流密度 $\\mathbf{J}$ 映射到总电场的切向分量 $\\mathbf{E}_t$。众所周知，Helmholtz 分解将 $\\mathbf{J}$ 分为一个表面无散部分（在 $\\Gamma$ 上散度为零）和一个表面有散部分（表面散度非零）。当 $k \\to 0$ 时，在相容范数下衡量，作用于无散部分的矢量位贡献与 $k$ 成正比，而作用于有散部分的标量位贡献与 $1/k$ 成正比。当使用 Rao–Wilton–Glisson (RWG) 试函数和 Buffa–Christiansen (BC) 测试函数进行离散化时，离散算子在一个适应于 Helmholtz 分裂的基中可以表示为一个块结构。在该结构中，当 $k \\to 0$ 时，非对角耦合项消失，而对角块在范数上是平衡的。相比之下，与 RWG 测试函数进行的 Galerkin 配对会引发范数失配，从而产生持续存在的非对角耦合项，这些耦合项在 $k \\to 0$ 时不会消失。\n\n基于上述基本事实和 Helmholtz 分解，为离散 EFIE 的低频行为构建一个自洽的块算子模型。该模型应能捕捉无散和有散子空间的 $k$-缩放特性以及测试空间选择的影响。您的模型应是纯代数的，并按如下方式定义：\n\n- 令 $n_s \\in \\mathbb{N}$ 和 $n_n \\in \\mathbb{N}$ 分别表示离散无散子空间和有散子空间的维度。令 $A \\in \\mathbb{R}^{n_s \\times n_s}$ 和 $D \\in \\mathbb{R}^{n_n \\times n_n}$ 为对称正定矩阵，它们分别在与 $k$ 无关的参考尺度上模拟 EFIE 在无散和有散子空间上的离散限制。令 $B_0 \\in \\mathbb{R}^{n_s \\times n_n}$ 和 $B_1 \\in \\mathbb{R}^{n_s \\times n_n}$ 为实耦合矩阵。\n- 定义两个与 $k$ 相关的离散算子来模拟两种测试方法：\n  - RWG–RWG Galerkin 模型：\n    $$Z_{\\mathrm{RR}}(k) \\;=\\; \\begin{bmatrix} k A & B_0 \\\\ B_0^{\\mathsf{T}} & \\dfrac{1}{k} D \\end{bmatrix}.$$\n  - RWG–BC Petrov–Galerkin 模型：\n    $$Z_{\\mathrm{RB}}(k) \\;=\\; \\begin{bmatrix} A & k B_1 \\\\ k B_1^{\\mathsf{T}} & D \\end{bmatrix}.$$\n- 对每个算子，定义谱条件数\n  $$\\kappa\\!\\left(Z(k)\\right) \\;=\\; \\dfrac{\\sigma_{\\max}\\!\\left(Z(k)\\right)}{\\sigma_{\\min}\\!\\left(Z(k)\\right)},$$\n  其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别表示最大和最小奇异值。\n\n您的任务是通过计算在对数-对数关系\n$$\\log \\kappa\\!\\left(Z(k)\\right) \\;\\approx\\; \\alpha \\, \\log k \\;+\\; \\beta,$$\n中的斜率 $\\alpha$ 来量化当 $k \\to 0$ 时 $\\kappa\\!\\left(Z_{\\mathrm{RR}}(k)\\right)$ 和 $\\kappa\\!\\left(Z_{\\mathrm{RB}}(k)\\right)$ 的渐近缩放特性。该斜率通过对一组指定的波数进行最小二乘回归来估计。斜率 $\\alpha$ 是无量纲的，必须以实数形式报告。\n\n实现要求：\n\n- 通过对实高斯矩阵 $M$ 进行 $M^{\\mathsf{T}} M$ 运算并添加一个正对角移位来构造对称正定矩阵 $A$ 和 $D$。确保 $B_0$ 的谱范数严格小于 $\\sqrt{\\lambda_{\\min}(A)\\,\\lambda_{\\min}(D)}$，以使 $Z_{\\mathrm{RR}}(k)$ 对于测试套件中的 $k$ 保持正定。使用独立设置种子的伪随机数生成器，使所有构造过程都是确定性的。\n- 对于每个测试用例，对波数集合 $k \\in \\{10^{-1},5 \\cdot 10^{-2},2 \\cdot 10^{-2},10^{-2},5 \\cdot 10^{-3},2 \\cdot 10^{-3},10^{-3}\\}$（单位为 $\\mathrm{m}^{-1}$）评估 $\\kappa\\!\\left(Z_{\\mathrm{RR}}(k)\\right)$ 和 $\\kappa\\!\\left(Z_{\\mathrm{RB}}(k)\\right)$。然后使用 $(x_i,y_i)=(\\log k_i,\\log \\kappa(Z(k_i)))$ 为每个算子计算最小二乘斜率 $\\alpha$。\n- 每个测试用例的最终输出是两个斜率 $\\alpha_{\\mathrm{RB}}$ 和 $\\alpha_{\\mathrm{RR}}$，它们是实数。这些输出不需要物理单位。\n\n测试套件规范：\n\n- 测试用例 1（平衡维度，一般情况）：\n  - 维度：$n_s = 3$，$n_n = 3$。\n  - 随机种子和移位：使用种子 $12345$ 和移位 $2$ 构建 $A$，使用种子 $23456$ 和移位 $2$ 构建 $D$。\n  - 耦合：\n    - $B_0$ 来自种子 $34567$，将其谱范数缩放至 $0.3 \\cdot \\sqrt{\\lambda_{\\min}(A)\\,\\lambda_{\\min}(D)}$。\n    - $B_1$ 来自种子 $45678$，将其谱范数缩放至 $1$。\n- 测试用例 2（边界标量情况，近临界耦合）：\n  - 维度：$n_s = 1$，$n_n = 1$。\n  - 标量：$A = [2]$，$D = [3]$，$B_0 = [0.6 \\sqrt{2 \\cdot 3}]$。\n  - $B_1$ 来自种子 $98765$，将其谱范数缩放至 $1$。\n- 测试用例 3（维度不平衡）：\n  - 维度：$n_s = 4$，$n_n = 2$。\n  - 随机种子和移位：使用种子 $111$ 和移位 $1$ 构建 $A$，使用种子 $222$ 和移位 $1.5$ 构建 $D$。\n  - 耦合：\n    - $B_0$ 来自种子 $333$，将其谱范数缩放至 $0.25 \\cdot \\sqrt{\\lambda_{\\min}(A)\\,\\lambda_{\\min}(D)}$。\n    - $B_1$ 来自种子 $444$，将其谱范数缩放至 $1$。\n\n不涉及角度单位。所有输出均为无单位的实数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$[\\alpha_{\\mathrm{RB}}^{(1)}, \\alpha_{\\mathrm{RR}}^{(1)}, \\alpha_{\\mathrm{RB}}^{(2)}, \\alpha_{\\mathrm{RR}}^{(2)}, \\alpha_{\\mathrm{RB}}^{(3)}, \\alpha_{\\mathrm{RR}}^{(3)}].$", "solution": "该问题要求分析电场积分方程 (EFIE) 两种不同数值离散化的低频行为。该分析通过简化的代数块算子模型进行，这些模型捕捉了底层物理和数值方法的关键频率相关缩放特性。\n\nEFIE 控制着理想电导体上的表面电流密度 $\\mathbf{J}$。Helmholtz 分解提供了一个关键的理论工具，它将电流 $\\mathbf{J}$ 分为一个表面无散（散度为零）分量和一个表面有散（旋度为零）分量。在波数 $k \\to 0$ 的低频极限下，EFIE 的积分算子在作用于这些分量时表现出显著不同的缩放行为。作用于无散子空间的矢量位算子与 $k$ 成正比缩放。作用于有散子空间的标量位算子与 $1/k$ 成正比缩放。这种缩放上的差异是低频下数值不稳定性的根源，这一现象被称为“低频崩溃”。\n\n在矩量法离散化中，测试函数的选择会显著影响所得线性系统的稳定性。该问题提出了两种模型，对应两种常见的选择：\n\n1.  **RWG–RWG (Galerkin) 模型**：试函数和测试函数均为 Rao–Wilton–Glisson (RWG) 基函数。所得的离散算子模型如下：\n    $$Z_{\\mathrm{RR}}(k) = \\begin{bmatrix} k A & B_0 \\\\ B_0^{\\mathsf{T}} & \\dfrac{1}{k} D \\end{bmatrix}$$\n    此处，$A \\in \\mathbb{R}^{n_s \\times n_s}$ 和 $D \\in \\mathbb{R}^{n_n \\times n_n}$ 是对称正定 (SPD) 矩阵，分别表示在一个参考尺度下，无散子空间和有散子空间上的离散化算子。$B_0 \\in \\mathbb{R}^{n_s \\times n_n}$ 表示子空间之间与频率无关的耦合。缩放失配是显式的：当 $k \\to 0$ 时，(1,1) 块消失，而 (2,2) 块发散。\n\n2.  **RWG–BC (Petrov-Galerkin) 模型**：试函数是 RWG，但测试函数是 Buffa–Christiansen (BC) 基函数。BC 基是专门为修正低频崩溃而设计的，它在其有散基函数的定义中引入了频率缩放。这种预缩放有效消除了标量位算子的 $1/k$ 奇异性。所得的离散算子模型如下：\n    $$Z_{\\mathrm{RB}}(k) = \\begin{bmatrix} A & k B_1 \\\\ k B_1^{\\mathsf{T}} & D \\end{bmatrix}$$\n    在这个模型中，对角块 $A$ 和 $D$ 具有良好的缩放性并且与 $k$ 无关。由 $k B_1$ 表示的非对角耦合在 $k \\to 0$ 时消失，在极限情况下系统变为块对角系统。\n\n目标是通过分析当 $k \\to 0$ 时其谱条件数 $\\kappa(Z(k)) = \\sigma_{\\max}(Z(k)) / \\sigma_{\\min}(Z(k))$ 的渐近缩放特性，来量化这两个模型的稳定性。这是通过计算数据 $(\\log k, \\log \\kappa(Z(k)))$ 线性拟合的斜率 $\\alpha$ 来实现的。\n\n**条件数的渐近分析**\n\n让我们在 $k \\to 0$ 的极限下分析每个模型的 $\\kappa(Z(k))$ 的行为。\n\n对于 **RWG–BC 模型**，矩阵为 $Z_{\\mathrm{RB}}(k) = \\begin{bmatrix} A & k B_1 \\\\ k B_1^{\\mathsf{T}} & D \\end{bmatrix}$。当 $k \\to 0$ 时，该矩阵收敛到一个块对角矩阵：\n$$ \\lim_{k\\to 0} Z_{\\mathrm{RB}}(k) = Z_{\\mathrm{RB}}(0) = \\begin{bmatrix} A & 0 \\\\ 0 & D \\end{bmatrix} $$\n由于 $A$ 和 $D$ 是对称正定矩阵，因此 $Z_{\\mathrm{RB}}(0)$ 的奇异值是 $A$ 和 $D$ 特征值的并集。因此条件数为：\n$$ \\kappa(Z_{\\mathrm{RB}}(0)) = \\frac{\\max(\\lambda_{\\max}(A), \\lambda_{\\max}(D))}{\\min(\\lambda_{\\min}(A), \\lambda_{\\min}(D))} $$\n这是一个与 $k$ 无关的有限正常量。对于较小的 $k$，$\\kappa(Z_{\\mathrm{RB}}(k))$ 将接近此常量。因此，$\\log \\kappa(Z_{\\mathrm{RB}}(k))$ 相对于 $\\log k$ 的图像预计将近乎水平。斜率 $\\alpha_{\\mathrm{RB}}$ 应接近 $0$。这表明 RWG–BC 格式在低频下是良态的。\n\n对于 **RWG–RWG 模型**，矩阵为 $Z_{\\mathrm{RR}}(k) = \\begin{bmatrix} k A & B_0 \\\\ B_0^{\\mathsf{T}} & \\frac{1}{k} D \\end{bmatrix}$。问题规定 $A$ 和 $D$ 是对称正定矩阵，且 $\\|B_0\\|_2  \\sqrt{\\lambda_{\\min}(A)\\lambda_{\\min}(D)}$，这确保了当 $k  0$ 时 $Z_{\\mathrm{RR}}(k)$ 是正定的。特征值（对于对称正定矩阵即为其奇异值）的缩放可以被估计。对角块的特征值缩放为 $O(k)$ 和 $O(1/k)$。\n最大奇异值将由发散块主导：\n$$ \\sigma_{\\max}(Z_{\\mathrm{RR}}(k)) \\approx \\sigma_{\\max}\\left(\\frac{1}{k} D\\right) = \\frac{1}{k} \\lambda_{\\max}(D) \\propto k^{-1} $$\n最小奇异值可以使用 Schur 补的性质来估计。对于一个对称正定块矩阵，最小特征值受其对角块的最小特征值所界定。启发式地，它与 $kA$ 块的最小特征值相关，其缩放如下：\n$$ \\sigma_{\\min}(Z_{\\mathrm{RR}}(k)) \\approx k \\lambda_{\\min}(A, B_0, D) \\propto k^{1} $$\n其中 $\\lambda_{\\min}(A, B_0, D)$ 这一项是依赖于这些矩阵的一个常数。\n结合这些缩放关系，条件数的行为表现为：\n$$ \\kappa(Z_{\\mathrm{RR}}(k)) = \\frac{\\sigma_{\\max}(Z_{\\mathrm{RR}}(k))}{\\sigma_{\\min}(Z_{\\mathrm{RR}}(k))} \\propto \\frac{k^{-1}}{k^1} = k^{-2} $$\n取对数得到 $\\log \\kappa(Z_{\\mathrm{RR}}(k)) \\approx C - 2 \\log k$，其中 $C$ 为某个常数。因此，对数-对数图的斜率 $\\alpha_{\\mathrm{RR}}$ 预计为 $-2$。这证实了 Galerkin 格式在低频下的严重病态问题。\n\n**数值步骤**\n\n对于每个测试用例，实现将遵循以下步骤：\n1.  使用提供的随机种子和参数值构造矩阵 $A$、$D$、$B_0$ 和 $B_1$。对于 $A$ 和 $D$，使用带种子的伪随机数生成器从高斯分布中生成一个矩阵 $M$，最终的对称正定矩阵形成为 $M^{\\mathsf{T}}M + \\delta I$，其中 $\\delta$ 是给定的对角移位。耦合矩阵 $B_0$ 和 $B_1$ 也由带种子的生成器生成，然后进行缩放以具有特定的谱范数。\n2.  定义波数集合 $k_i = \\{10^{-1}, 5 \\cdot 10^{-2}, \\dots, 10^{-3}\\}$。\n3.  对于集合中的每个 $k_i$：\n    a. 组装矩阵 $Z_{\\mathrm{RB}}(k_i)$ 和 $Z_{\\mathrm{RR}}(k_i)$。\n    b. 使用标准数值库例程计算它们的奇异值。提取最大和最小奇异值 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$。\n    c. 计算条件数 $\\kappa(Z(k_i)) = \\sigma_{\\max}/\\sigma_{\\min}$。\n4.  计算完所有 $k_i$ 的条件数后，创建两组数据点：$(\\log k_i, \\log \\kappa(Z_{\\mathrm{RB}}(k_i)))$ 和 $(\\log k_i, \\log \\kappa(Z_{\\mathrm{RR}}(k_i)))$。\n5.  对每组数据集执行线性最小二乘回归以找到斜率 $\\alpha$。对于一组点 $(x_i, y_i)$，斜率计算如下：\n    $$ \\alpha = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2} $$\n    其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是 $x_i$ 和 $y_i$ 值的均值。\n6.  为每个测试用例报告所得的斜率 $\\alpha_{\\mathrm{RB}}$ 和 $\\alpha_{\\mathrm{RR}}$。\n\n此过程将数值上验证 $\\alpha_{\\mathrm{RB}} \\approx 0$ 和 $\\alpha_{\\mathrm{RR}} \\approx -2$ 的理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_spd_matrix(dim, seed, shift):\n    \"\"\"\n    Constructs a symmetric positive definite matrix.\n    Generated as M.T @ M + shift * I, where M is from a Gaussian distribution.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    M = rng.standard_normal((dim, dim))\n    A = M.T @ M + shift * np.identity(dim)\n    return A\n\ndef get_spectral_norm(matrix):\n    \"\"\"Computes the spectral norm (largest singular value) of a matrix.\"\"\"\n    # For scalar matrices, svd returns a scalar, need to handle this\n    if matrix.size == 1:\n        return np.abs(matrix.item())\n    return np.linalg.svd(matrix, compute_uv=False)[0]\n\ndef scale_matrix_norm(matrix, target_norm):\n    \"\"\"Scales a matrix to have a specific spectral norm.\"\"\"\n    current_norm = get_spectral_norm(matrix)\n    if np.isclose(current_norm, 0):\n        return matrix # Cannot scale a zero matrix\n    return matrix * (target_norm / current_norm)\n\ndef compute_slope(k_values, kappa_values):\n    \"\"\"\n    Computes the slope of the log-log plot using least-squares regression.\n    \"\"\"\n    x = np.log(k_values)\n    y = np.log(kappa_values)\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n    \n    numerator = np.sum((x - x_mean) * (y - y_mean))\n    denominator = np.sum((x - x_mean)**2)\n    \n    if np.isclose(denominator, 0):\n        return 0.0\n        \n    return numerator / denominator\n\ndef analyze_case(params):\n    \"\"\"\n    Analyzes a single test case for both Z_RR and Z_RB models.\n    \"\"\"\n    # Unpack parameters\n    ns, nn = params[\"dims\"]\n    A_params, D_params = params[\"spd_params\"]\n    B0_params, B1_params = params[\"coupling_params\"]\n\n    # --- Matrix Construction ---\n    if A_params[\"type\"] == \"scalar\":\n        A = np.array([[A_params[\"value\"]]])\n    else:\n        A = build_spd_matrix(ns, A_params[\"seed\"], A_params[\"shift\"])\n\n    if D_params[\"type\"] == \"scalar\":\n        D = np.array([[D_params[\"value\"]]])\n    else:\n        D = build_spd_matrix(nn, D_params[\"seed\"], D_params[\"shift\"])\n\n    # --- Coupling Matrix B0 ---\n    rng_b0 = np.random.default_rng(B0_params[\"seed\"])\n    if B0_params[\"type\"] == \"scalar\":\n        B0 = np.array([[B0_params[\"value\"]]])\n    else:\n        B0_raw = rng_b0.standard_normal((ns, nn))\n        lambda_min_A = np.min(np.linalg.eigvalsh(A))\n        lambda_min_D = np.min(np.linalg.eigvalsh(D))\n        target_norm_B0 = B0_params[\"scale_factor\"] * np.sqrt(lambda_min_A * lambda_min_D)\n        B0 = scale_matrix_norm(B0_raw, target_norm_B0)\n\n    # --- Coupling Matrix B1 ---\n    rng_b1 = np.random.default_rng(B1_params[\"seed\"])\n    B1_raw = rng_b1.standard_normal((ns, nn))\n    B1 = scale_matrix_norm(B1_raw, B1_params[\"norm\"])\n    \n    # --- Wavenumbers ---\n    k_values = np.array([1e-1, 5e-2, 2e-2, 1e-2, 5e-3, 2e-3, 1e-3])\n\n    kappa_rr_values = []\n    kappa_rb_values = []\n\n    for k in k_values:\n        # Assemble Z_RR(k)\n        Z_rr = np.block([\n            [k * A, B0],\n            [B0.T, (1/k) * D]\n        ])\n        \n        # Assemble Z_RB(k)\n        Z_rb = np.block([\n            [A, k * B1],\n            [k * B1.T, D]\n        ])\n        \n        # Compute condition numbers\n        s_rr = np.linalg.svd(Z_rr, compute_uv=False)\n        kappa_rr = s_rr[0] / s_rr[-1]\n        kappa_rr_values.append(kappa_rr)\n        \n        s_rb = np.linalg.svd(Z_rb, compute_uv=False)\n        kappa_rb = s_rb[0] / s_rb[-1]\n        kappa_rb_values.append(kappa_rb)\n\n    # Compute slopes\n    alpha_rr = compute_slope(k_values, np.array(kappa_rr_values))\n    alpha_rb = compute_slope(k_values, np.array(kappa_rb_values))\n    \n    return alpha_rb, alpha_rr\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analysis, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"dims\": (3, 3),\n            \"spd_params\": (\n                {\"type\": \"generated\", \"seed\": 12345, \"shift\": 2},\n                {\"type\": \"generated\", \"seed\": 23456, \"shift\": 2}\n            ),\n            \"coupling_params\": (\n                {\"type\": \"generated\", \"seed\": 34567, \"scale_factor\": 0.3},\n                {\"seed\": 45678, \"norm\": 1.0}\n            )\n        },\n        # Test case 2\n        {\n            \"dims\": (1, 1),\n            \"spd_params\": (\n                {\"type\": \"scalar\", \"value\": 2.0},\n                {\"type\": \"scalar\", \"value\": 3.0}\n            ),\n            \"coupling_params\": (\n                {\"type\": \"scalar\", \"seed\": 0, \"value\": 0.6 * np.sqrt(2.0 * 3.0)}, # seed unused for scalar\n                {\"seed\": 98765, \"norm\": 1.0}\n            )\n        },\n        # Test case 3\n        {\n            \"dims\": (4, 2),\n            \"spd_params\": (\n                {\"type\": \"generated\", \"seed\": 111, \"shift\": 1.0},\n                {\"type\": \"generated\", \"seed\": 222, \"shift\": 1.5}\n            ),\n            \"coupling_params\": (\n                {\"type\": \"generated\", \"seed\": 333, \"scale_factor\": 0.25},\n                {\"seed\": 444, \"norm\": 1.0}\n            )\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_rb, alpha_rr = analyze_case(case)\n        results.extend([alpha_rb, alpha_rr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3290751"}, {"introduction": "最后，我们将 BC 函数与离散外微分和代数拓扑这一深刻而优美的理论框架联系起来。本练习揭示了由 Rao-Wilton-Glisson (RWG) 和 BC 函数对（或其组合模拟）构建的离散算子，实际上蕴含了计算域本身的根本拓扑信息。通过为不同亏格 (genus) 的曲面（如球面和环面）构建关联矩阵，你将验证离散调和空间的维度能够准确地恢复曲面的“环柄”数量，即第一贝蒂数 $b_1$ [@problem_id:3290798]。", "problem": "考虑一个闭合、可定向的三角化曲面，它表示为一个单纯复形，具有一组顶点、边和三角面。设顶点、边和面的数量分别为 $n_V$、$n_E$ 和 $n_F$。定义单纯链复形的边界算子为矩阵 $\\partial_1 \\in \\mathbb{R}^{n_V \\times n_E}$ 和 $\\partial_2 \\in \\mathbb{R}^{n_E \\times n_F}$，这些矩阵由有向关联关系构建，并满足 $\\partial_1 \\partial_2 = 0$。在用于计算电磁学的离散 de Rham 框架中，使用 Rao–Wilton–Glisson (RWG) 边基函数和 Buffa–Christiansen (BC) 对偶基函数，离散梯度和旋度算子在转置和适当的质量配对下，对应于上边缘算子 $\\delta_0 = \\partial_1^\\top$ 和 $\\delta_1 = \\partial_2^\\top$。$1$-形式的调和子空间是 $\\ker(\\delta_0) \\cap \\ker(\\delta_1)$ 的交集，对于闭合可定向曲面，其维数等于第一个 Betti 数 $b_1$。\n\n从单纯同调、Hodge 分解和离散 de Rham 序列等基本概念出发，设计一个拓扑测试，以从通过 RWG–BC 组装的算子的秩和零空间中恢复 Betti 数 $b_0$、$b_1$ 和 $b_2$，并在不同亏格的曲面上验证恢复结果。具体而言：\n\n1. 从三角剖分中构造有向关联矩阵 $\\partial_1$ 和 $\\partial_2$。\n2. 使用秩公式计算 Betti 数\n   $$\n   b_0 = n_V - \\operatorname{rank}(\\partial_1),\\quad\n   b_1 = n_E - \\operatorname{rank}(\\partial_1) - \\operatorname{rank}(\\partial_2),\\quad\n   b_2 = n_F - \\operatorname{rank}(\\partial_2).\n   $$\n3. 组装组合 $1$-Hodge 拉普拉斯算子\n   $$\n   L_1 = \\partial_1^\\top \\partial_1 + \\partial_2 \\partial_2^\\top,\n   $$\n   在对称正定内积选择下，该算子等价于一个 RWG–BC 加权的拉普拉斯算子，并提取调和维数为\n   $$\n   h_{\\mathrm{lap}} = \\dim \\ker(L_1).\n   $$\n4. 独立地通过 RWG 零散度子空间和 BC 零旋度子空间的交集来计算调和维数：\n   $$\n   h_{\\mathrm{int}} = \\dim\\left(\\ker(\\partial_1) \\cap \\ker(\\partial_2^\\top)\\right) = n_E - \\operatorname{rank}\\left(\\begin{bmatrix}\\partial_1 \\\\ \\partial_2^\\top\\end{bmatrix}\\right).\n   $$\n5. 对每个测试用例，验证 $h_{\\mathrm{lap}} = b_1$ 和 $h_{\\mathrm{int}} = b_1$。\n\n你的程序必须在以下三角化曲面上实现上述步骤：\n\n- 测试用例 A（正常路径）：球体（亏格为 $0$）的八面体三角剖分，由有向面构成，其中 $n_V = 6$，$n_E = 12$，$n_F = 8$。\n- 测试用例 B（不同亏格）：一个环面（亏格为 $1$），由一个 $N=3$ 的 $N \\times N$ 周期性网格生成，通过将每个周期性单元格分裂成两个有向三角形来进行三角剖分。\n- 测试用例 C（边界情况）：一个由测试用例 A 和测试用例 B 的不交并构成的非连通曲面。\n\n对于每个测试用例，你的程序必须输出一个列表，其中包含五个项目 $[b_0, b_1, b_2, h_{\\mathrm{int}}, h_{\\mathrm{lap}}]$，后跟两个布尔值验证 $[\\text{passed}_{\\mathrm{int}}, \\text{passed}_{\\mathrm{lap}}]$，其中如果 $h_{\\mathrm{int}} = b_1$ 则 $\\text{passed}_{\\mathrm{int}}$ 为真，如果 $h_{\\mathrm{lap}} = b_1$ 则 $\\text{passed}_{\\mathrm{lap}}$ 为真。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[[b_0,b_1,b_2,h_{\\mathrm{int}},h_{\\mathrm{lap}},\\text{passed}_{\\mathrm{int}},\\text{passed}_{\\mathrm{lap}}], [\\dots], [\\dots]]$）。此问题不涉及任何物理单位或角度。所有计算必须在 $\\mathbb{R}$ 上执行，使用奇异值分解以数值稳定的容差来确定秩和零度。", "solution": "我们从一个三角化的闭合可定向曲面的单纯链复形开始，\n$$\nC_2 \\xrightarrow{\\partial_2} C_1 \\xrightarrow{\\partial_1} C_0,\n$$\n其中 $C_k$ 是 $k$-链，$\\partial_k$ 是满足 $\\partial_1 \\partial_2 = 0$ 的边界算子。相应的上链复形具有上边缘算子 $\\delta_k = \\partial_{k+1}^\\top$。在计算电磁学中使用的离散 de Rham 序列中，Rao–Wilton–Glisson (RWG) 边基函数表示原始网格上的离散 $1$-形式，而 Buffa–Christiansen (BC) 对偶边基函数表示对偶网格上的离散 $1$-形式。作用于原始 $1$-形式的离散梯度和旋度，在内积的意义下，分别由 $\\delta_0 = \\partial_1^\\top$ 和 $\\delta_1 = \\partial_2^\\top$ 表示。\n\nBetti 数 $b_k$ 定义为同调群 $H_k = \\ker(\\partial_k)/\\operatorname{im}(\\partial_{k+1})$ 的维数。在 $\\mathbb{R}$ 上，这些维数可以通过秩来计算：\n$$\nb_0 = n_V - \\operatorname{rank}(\\partial_1),\\quad\nb_1 = n_E - \\operatorname{rank}(\\partial_1) - \\operatorname{rank}(\\partial_2),\\quad\nb_2 = n_F - \\operatorname{rank}(\\partial_2).\n$$\n这些恒等式源于链复形维数的正合性以及秩-零度定理：\n$\\dim \\ker(\\partial_k) = n_{C_k} - \\operatorname{rank}(\\partial_k)$ 和 $\\dim \\operatorname{im}(\\partial_{k+1}) = \\operatorname{rank}(\\partial_{k+1})$。\n\n为了与 Buffa–Christiansen 稳定化方法联系起来，我们考虑原始 $1$-上链上的 $1$-Hodge 拉普拉斯算子，\n$$\nL_1 = \\delta_0 \\delta_0^\\top + \\delta_1^\\top \\delta_1 = \\partial_1^\\top \\partial_1 + \\partial_2 \\partial_2^\\top.\n$$\n在连续理论中，$L_1$ 的核是调和 $1$-形式的空间，其维数等于 $b_1$。在离散设置中，通过对称正定 (SPD) 质量矩阵（如同在 RWG–BC 配对中出现的那样）进行加权，将 $L_1$ 修改为 $L_1^{\\mathrm{SPD}} = \\partial_1^\\top W_0 \\partial_1 + \\partial_2 W_2 \\partial_2^\\top$，其中 $W_0$ 和 $W_2$ 是 SPD 矩阵。核条件 $L_1^{\\mathrm{SPD}} x = 0$ 意味着 $\\partial_1 x = 0$ 和 $\\partial_2^\\top x = 0$，因此核是交集 $\\ker(\\partial_1) \\cap \\ker(\\partial_2^\\top)$，其维数是一个等于 $b_1$ 的拓扑不变量。因此，任何 SPD 选择（包括组合选择 $W_0 = I$ 和 $W_2 = I$）都会得到相同的核维数。\n\n算法步骤：\n\n1. 构建有向关联矩阵：\n   - 对于 $\\partial_2 \\in \\mathbb{R}^{n_E \\times n_F}$，每个面贡献三个带 $\\pm 1$ 符号的有向边。$\\partial_2$ 的每一列编码了该三角面的有向边界。\n   - 对于 $\\partial_1 \\in \\mathbb{R}^{n_V \\times n_E}$，每个有向边 $(u \\to v)$ 在对应列的第 $u$ 行贡献 $-1$，在第 $v$ 行贡献 $+1$。\n\n2. 使用奇异值分解 (SVD) 计算秩。给定一个具有奇异值 $\\sigma_i$ 的矩阵 $A$，定义一个容差 $\\tau = \\max(n_{\\text{rows}}, n_{\\text{cols}}) \\cdot \\sigma_{\\max} \\cdot \\epsilon$，其中 $\\epsilon$ 是机器精度，并通过计算大于 $\\tau$ 的奇异值的数量来获得 $\\operatorname{rank}(A)$。\n\n3. 恢复 Betti 数：\n   $$\n   b_0 = n_V - \\operatorname{rank}(\\partial_1),\\quad\n   b_1 = n_E - \\operatorname{rank}(\\partial_1) - \\operatorname{rank}(\\partial_2),\\quad\n   b_2 = n_F - \\operatorname{rank}(\\partial_2).\n   $$\n\n4. 通过两种途径计算调和维数：\n   - 交集途径（RWG–BC 零空间）：将算子垂直堆叠，$S = \\begin{bmatrix}\\partial_1 \\\\ \\partial_2^\\top\\end{bmatrix}$，则\n     $$\n     h_{\\mathrm{int}} = n_E - \\operatorname{rank}(S).\n     $$\n     这是因为 $\\ker(S) = \\ker(\\partial_1) \\cap \\ker(\\partial_2^\\top)$。\n   - 拉普拉斯算子途径：形成 $L_1 = \\partial_1^\\top \\partial_1 + \\partial_2 \\partial_2^\\top$ 并计算\n     $$\n     h_{\\mathrm{lap}} = \\dim \\ker(L_1),\n     $$\n     通过 SVD 计算小于容差的奇异值的数量。\n\n5. 对每个测试用例，验证 $h_{\\mathrm{int}} = b_1$ 和 $h_{\\mathrm{lap}} = b_1$。\n\n测试三角剖分的构造：\n\n- 测试用例 A（球体，亏格为 $0$）：使用一个具有 $n_V = 6$ 个顶点、$n_E = 12$ 条边、$n_F = 8$ 个面的八面体三角剖分。将顶面 $(v_5, v_i, v_{i+1})$（对于 $i \\in \\{0,1,2,3\\}$）和底面 $(v_4, v_{i+1}, v_i)$ 定向，以确保一致的全局定向。\n\n- 测试用例 B（环面，亏格为 $1$）：使用一个 $N=3$ 的 $N \\times N$ 周期性网格，每个周期性单元格包含两个有向三角形：\n  $$\n  (i,j),\\ (i+1,j),\\ (i+1,j+1)\n  \\quad\\text{和}\\quad\n  (i,j),\\ (i+1,j+1),\\ (i,j+1),\n  $$\n  其中索引对 $N$ 取模以强制周期性。这将生成一个闭合、可定向的三角化环面。\n\n- 测试用例 C（不交并）：通过偏移一个复形的顶点索引并连接面列表，形成测试用例 A 和测试用例 B 的不交并。边界算子将变为块对角矩阵，Betti 数相加：$b_k^{\\text{union}} = b_k^{(A)} + b_k^{(B)}$。\n\n预期的拓扑不变量：\n- 球体：$b_0 = 1$, $b_1 = 0$, $b_2 = 1$。\n- 环面：$b_0 = 1$, $b_1 = 2$, $b_2 = 1$。\n- 不交并（球体 $\\sqcup$ 环面）：$b_0 = 2$, $b_1 = 2$, $b_2 = 2$。\n\n程序实现了上述构造，计算 $\\partial_1$、$\\partial_2$、秩、Betti 数、$h_{\\mathrm{int}}$ 和 $h_{\\mathrm{lap}}$，并为每个测试用例在单行中输出列表 $[b_0, b_1, b_2, h_{\\mathrm{int}}, h_{\\mathrm{lap}}, \\text{passed}_{\\mathrm{int}}, \\text{passed}_{\\mathrm{lap}}]$，汇总到一个外部列表中。由于 RWG–BC 稳定化引入的对称正定内积不会改变核条件 $\\partial_1 x = 0$ 和 $\\partial_2^\\top x = 0$，因此两种调和维数的计算都是一致且纯拓扑的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef matrix_rank_svd(A, eps=None):\n    \"\"\"Numerically stable matrix rank using SVD with tolerance.\"\"\"\n    # Convert to float64\n    A = np.asarray(A, dtype=float)\n    # Handle empty matrices\n    if A.size == 0:\n        return 0\n    # Compute SVD\n    U, s, Vt = np.linalg.svd(A, full_matrices=False)\n    # Machine epsilon\n    if eps is None:\n        eps = np.finfo(float).eps\n    # Tolerance as in numpy.linalg.matrix_rank\n    tol = s.max() * max(A.shape) * eps\n    return int(np.sum(s > tol))\n\ndef nullity_svd(A, eps=None):\n    \"\"\"Compute nullity of A over reals using SVD.\"\"\"\n    rank = matrix_rank_svd(A, eps=eps)\n    return A.shape[1] - rank\n\ndef build_incidence_from_faces(nV, faces):\n    \"\"\"\n    Build oriented incidence matrices ∂1 (V x E) and ∂2 (E x F)\n    from a list of oriented triangular faces with vertex indices.\n    Edge orientation is canonical: (min(u,v) -> max(u,v)).\n    For each face (a,b,c), edges are (a,b), (b,c), (c,a) with ±1 signs.\n    \"\"\"\n    # Collect edges as unordered pairs, map to index\n    edge_dict = {}  # key: (min, max) -> edge_index\n    edges = []      # list of (u, v) with u  v (canonical orientation)\n    # Temporary: per-face edge entries (edge_index, sign)\n    face_edges = []\n\n    def add_edge(u, v):\n        u0, v0 = (u, v)\n        if u0 == v0:\n            raise ValueError(\"Degenerate edge with identical vertices.\")\n        a, b = (u0, v0) if u0  v0 else (v0, u0)\n        sign = +1 if (u0  v0) else -1\n        key = (a, b)\n        if key not in edge_dict:\n            edge_dict[key] = len(edges)\n            edges.append(key)\n        return edge_dict[key], sign\n\n    for (a, b, c) in faces:\n        e1_idx, s1 = add_edge(a, b)\n        e2_idx, s2 = add_edge(b, c)\n        e3_idx, s3 = add_edge(c, a)\n        face_edges.append([(e1_idx, s1), (e2_idx, s2), (e3_idx, s3)])\n\n    nE = len(edges)\n    nF = len(faces)\n    # Build ∂2 (E x F)\n    d2 = np.zeros((nE, nF), dtype=float)\n    for f_idx, edges_in_face in enumerate(face_edges):\n        for e_idx, s in edges_in_face:\n            d2[e_idx, f_idx] += s\n    # Build ∂1 (V x E) based on canonical orientation (u -> v) with u  v\n    d1 = np.zeros((nV, nE), dtype=float)\n    for e_idx, (u, v) in enumerate(edges):\n        # canonical orientation from u -> v\n        d1[u, e_idx] = -1.0\n        d1[v, e_idx] = +1.0\n\n    return d1, d2, edges\n\ndef build_octahedron_sphere():\n    \"\"\"\n    Build an octahedron triangulation of the sphere:\n    vertices 0..5, where 4 is bottom apex, 5 is top apex,\n    and 0..3 are equatorial vertices in cyclic order.\n    Faces are oriented consistently.\n    \"\"\"\n    nV = 6\n    # Top faces: (5,i,i+1)\n    top_faces = [(5, 0, 1), (5, 1, 2), (5, 2, 3), (5, 3, 0)]\n    # Bottom faces: (4,i+1,i) to ensure consistent global orientation\n    bottom_faces = [(4, 1, 0), (4, 2, 1), (4, 3, 2), (4, 0, 3)]\n    faces = top_faces + bottom_faces\n    return nV, faces\n\ndef build_torus_grid(N):\n    \"\"\"\n    Build a torus triangulation from an N x N periodic grid.\n    Vertices are indexed by (i,j) with modulo N periodicity.\n    Two oriented triangles per grid cell:\n    (i,j),(i+1,j),(i+1,j+1) and (i,j),(i+1,j+1),(i,j+1).\n    \"\"\"\n    def vid(i, j):\n        return (i % N) * N + (j % N)\n\n    nV = N * N\n    faces = []\n    for i in range(N):\n        for j in range(N):\n            # Triangle 1\n            a = vid(i, j)\n            b = vid(i + 1, j)\n            c = vid(i + 1, j + 1)\n            faces.append((a, b, c))\n            # Triangle 2\n            a2 = vid(i, j)\n            b2 = vid(i + 1, j + 1)\n            c2 = vid(i, j + 1)\n            faces.append((a2, b2, c2))\n    return nV, faces\n\ndef disjoint_union(meshA, meshB):\n    \"\"\"\n    Disjoint union of two complexes. Each mesh is (nV, faces).\n    Returns (nV_total, faces_total) after offsetting indices of meshB.\n    \"\"\"\n    nV_A, faces_A = meshA\n    nV_B, faces_B = meshB\n    offset = nV_A\n    faces_B_off = [(a + offset, b + offset, c + offset) for (a, b, c) in faces_B]\n    nV_total = nV_A + nV_B\n    faces_total = faces_A + faces_B_off\n    return nV_total, faces_total\n\ndef hodge_laplacian_1(d1, d2):\n    \"\"\"\n    Build the combinatorial 1-Hodge Laplacian L1 = d1^T d1 + d2 d2^T.\n    \"\"\"\n    return d1.T @ d1 + d2 @ d2.T\n\ndef harmonic_dim_laplacian(L1, eps=None):\n    \"\"\"Compute dimension of kernel of L1 via SVD.\"\"\"\n    # SVD of symmetric matrix\n    U, s, Vt = np.linalg.svd(L1, full_matrices=False)\n    if eps is None:\n        eps = np.finfo(float).eps\n    tol = s.max() * max(L1.shape) * eps if s.size > 0 else 0.0\n    return int(np.sum(s = tol))\n\ndef compute_betti_and_harmonic(nV, faces):\n    \"\"\"\n    Compute Betti numbers and harmonic dimensions for a triangulated surface.\n    Returns b0, b1, b2, h_int, h_lap.\n    \"\"\"\n    d1, d2, edges = build_incidence_from_faces(nV, faces)\n    nE = len(edges)\n    nF = len(faces)\n\n    # Ranks\n    r1 = matrix_rank_svd(d1)\n    r2 = matrix_rank_svd(d2)\n\n    # Betti numbers\n    b0 = nV - r1\n    b1 = nE - r1 - r2\n    b2 = nF - r2\n\n    # Intersection harmonic dimension: nullity of [d1; d2^T]\n    S = np.vstack([d1, d2.T])\n    h_int = nE - matrix_rank_svd(S)\n\n    # Laplacian harmonic dimension\n    L1 = hodge_laplacian_1(d1, d2)\n    h_lap = harmonic_dim_laplacian(L1)\n\n    return b0, b1, b2, h_int, h_lap\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Test case A: Octahedron sphere (genus 0)\n    mesh_sphere = build_octahedron_sphere()\n    # Test case B: Torus (genus 1) with N=3\n    mesh_torus = build_torus_grid(N=3)\n    # Test case C: Disjoint union of sphere and torus\n    mesh_union = disjoint_union(mesh_sphere, mesh_torus)\n\n    test_cases = [\n        (\"sphere_octa\", mesh_sphere),\n        (\"torus_N3\", mesh_torus),\n        (\"union_sphere_torus\", mesh_union),\n    ]\n\n    results = []\n    for name, mesh in test_cases:\n        nV, faces = mesh\n        b0, b1, b2, h_int, h_lap = compute_betti_and_harmonic(nV, faces)\n        passed_int = (h_int == b1)\n        passed_lap = (h_lap == b1)\n        results.append([b0, b1, b2, h_int, h_lap, passed_int, passed_lap])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3290798"}]}