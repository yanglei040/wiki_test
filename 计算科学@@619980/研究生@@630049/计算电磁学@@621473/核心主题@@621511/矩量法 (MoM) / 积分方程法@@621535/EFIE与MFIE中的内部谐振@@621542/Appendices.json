{"hands_on_practices": [{"introduction": "要解决内部谐振问题，我们首先必须学会预测它们何时发生。该练习 [@problem_id:3319829] 提供了一个基本的诊断工具，它将谐振的抽象概念与寻找球谐贝塞尔函数根点的具体任务联系起来，这些根点定义了理想电导体球体的内部腔模。通过计算这些谐振频率，您将为电场积分方程(EFIE)和磁场积分方程(MFIE)创建一个潜在不稳定点的“地图”。", "problem": "要求您编写一个完整且可运行的程序，该程序通过使用从变量分离法推导出的解析内部特征值信息，来诊断完美电导球体（perfectly electrically conducting spheres）的电场积分方程（Electric Field Integral Equation, EFIE）和磁场积分方程（Magnetic Field Integral Equation, MFIE）的内部谐振。对于半径为 $a$、波数为 $k$（单位为 $\\mathrm{m}^{-1}$）的球体，导致 EFIE 病态的内部谐振发生在标量亥姆霍兹方程（scalar Helmholtz equation）的内部狄利克雷特征值（interior Dirichlet eigenvalues）处，而导致 MFIE 病态的内部谐振则发生在内部诺伊曼特征值（interior Neumann eigenvalues）处。对于球形几何，变量分离法会导出 $\\ell$ 阶球贝塞尔函数（spherical Bessel functions）$j_{\\ell}(x)$，其特征值由无量纲量 $x = ka$ 通过以下方式表征：\n- 狄利克雷（内部）特征值：$j_{\\ell}(ka) = 0$，\n- 诺伊曼（内部）特征值：$j_{\\ell}'(ka) = 0$，\n其中撇号表示对自变量求导。\n\n从频域中的矢量麦克斯韦方程组出发，当在矢量球谐函数（vector spherical harmonics）中展开时，完美电导球体的散射场边界积分方程可简化为独立的标量径向条件，其根与横磁（TM）类型（污染 EFIE）的 $j_{\\ell}(x)$ 的零点以及横电（TE）类型（污染 MFIE）的 $j_{\\ell}'(x)$ 的零点相吻合。因此，当 $ka$ 接近这些零点之一时，相应的积分算子会产生一个近零空间（near-null space），其条件数会变得非常大。在本问题中，您将：\n- 计算阶数 $\\ell \\in \\{0,1,\\dots,L\\}$ 的 $j_{\\ell}(x)$ 的前 $N$ 个零点集合 $\\{x_{\\ell,n}^{(D)}\\}_{n=1}^{N}$（狄利克雷集），以及相同 $\\ell$ 范围内的 $j_{\\ell}'(x)$ 的前 $N$ 个零点集合 $\\{x_{\\ell,n}^{(N)}\\}_{n=1}^{N}$（诺伊曼集），\n- 对于测试波数 $k$ 和半径 $a$，评估在 $x$ 域中的最小距离 $\\delta_E = \\min_{\\ell \\le L, n \\le N} \\lvert ka - x_{\\ell,n}^{(D)} \\rvert$ 和 $\\delta_M = \\min_{\\ell \\le L, n \\le N} \\lvert ka - x_{\\ell,n}^{(N)} \\rvert$，\n- 将 EFIE 和 MFIE 的代理条件度量定义为 $C_E = 1/\\max(\\delta_E,\\varepsilon)$ 和 $C_M = 1/\\max(\\delta_M,\\varepsilon)$，其中有一个小的下限值 $\\varepsilon$ 以避免除以零。这些无量纲的代理指标随着 $k a$ 接近谐振而增加，反映了积分方程的病态性。\n\n您的程序必须仅使用基本的数学和物理原理来实现以下内容：\n- 使用时谐麦克斯韦方程组（time-harmonic Maxwell equations）和完美电导球体上的边界条件来证明 EFIE 内部谐振与内部狄利克雷特征值重合，MFIE 内部谐振与内部诺伊曼特征值重合，并且这些都可以通过上述球贝塞尔函数零点条件来捕捉。\n- 通过在 $x \\in (0,\\infty)$ 上使用稳健的一维求根区间法（root bracketing）和类似二分法（bisection-like methods）的方法，仅依赖于目标函数明确的符号变化，来数值计算每个 $\\ell \\in \\{0,\\dots,L\\}$ 的 $j_{\\ell}(x)$ 和 $j_{\\ell}'(x)$ 的前 $N$ 个正零点。您可以假设 $j_{\\ell}(x)$ 在 $x \\ge 0$ 上是连续的，在有限的起始点后是严格振荡的，并且其零点是单根且与其导数的零点交错。\n- 聚合指定范围 $\\ell$ 和索引 $n$ 的所有零点，并为每个测试用例计算最小间隔 $\\delta_E$ 和 $\\delta_M$。\n\n物理单位和输出规范：\n- 球体半径必须以米（$\\mathrm{m}$）为单位指定。\n- 波数必须以米分之一（$\\mathrm{m}^{-1}$）为单位指定。\n- 无量纲参数为 $x = ka$。\n- 您的代理条件度量 $C_E$ 和 $C_M$ 是无量纲的，并且必须以浮点数形式生成。\n\n测试套件和答案规范：\n- 使用以下测试套件，其中每个测试用例是一个元组 $(a, L, N, k)$：\n    1. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;6.2\\;\\mathrm{m}^{-1})$，\n    2. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;8.99\\;\\mathrm{m}^{-1})$，\n    3. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;2.0\\;\\mathrm{m}^{-1})$，\n    4. $(a=\\;1.0\\;\\mathrm{m},\\;L=\\;8,\\;N=\\;3,\\;k=\\;4.50\\;\\mathrm{m}^{-1})$，\n    5. $(a=\\;0.2\\;\\mathrm{m},\\;L=\\;4,\\;N=\\;5,\\;k=\\;20.0\\;\\mathrm{m}^{-1})$。\n- 在 $C_E$ 和 $C_M$ 的定义中使用距离下限值 $\\varepsilon = 10^{-6}$。\n- 对于每个测试用例，计算并返回一对 $[C_E, C_M]$，作为一个包含两个浮点数的列表，在打印输出中至少四舍五入到 $6$ 位有效数字。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是一个表示 $[C_E, C_M]$ 的双元素列表。例如，最终打印的行必须具有以下形式：\n- $[\\,[C_{E,1},C_{M,1}],\\,[C_{E,2},C_{M,2}],\\,\\dots\\,]$。", "solution": "本问题的主题是诊断完美电导（PEC）球体电磁散射的频域边界积分方程中的内部谐振。电场积分方程（EFIE）和磁场积分方程（MFIE）是解决此类问题的标准公式。然而，它们存在一个关键缺陷：在对应于散射体内部形成的空腔的谐振模式的频率下，它们的离散表示会变得病态。此分析证实了所提供的问题陈述，并为数值求解奠定了基础。\n\n首先，我们建立积分方程和内部特征值之间的理论联系。分析从时谐麦克斯韦方程组开始，假设时间依赖关系为 $e^{i\\omega t}$，其中 $\\omega=kc$ 是角频率，$k$ 是波数，$c$ 是介质中的光速。\n$$\n\\nabla \\times \\vec{E} = -i \\omega \\mu \\vec{H} \\\\\n\\nabla \\times \\vec{H} = i \\omega \\epsilon \\vec{E} + \\vec{J}\n$$\n对于一个涉及占据体积 $V$、由表面 $S$ 界定的 PEC 物体的散射问题，我们必须找到由入射场 $(\\vec{E}^{inc}, \\vec{H}^{inc})$ 感应出的表面电流 $\\vec{J}_s$。总场是入射场和散射场的和，例如 $\\vec{E} = \\vec{E}^{inc} + \\vec{E}^{scat}$。\n\nEFIE 是从 PEC 边界条件推导出来的，即总电场的切向分量在表面 $S$ 上必须为零：\n$$\n\\hat{n} \\times \\vec{E}|_S = \\hat{n} \\times (\\vec{E}^{inc} + \\vec{E}^{scat})|_S = 0\n$$\n散射电场 $\\vec{E}^{scat}$ 由表面电流 $\\vec{J}_s$ 产生，可以通过作用于 $\\vec{J}_s$ 的积分算子 $\\mathcal{E}$ 来表示，即 $\\vec{E}^{scat} = \\mathcal{E}(\\vec{J}_s)$。这导出了算子方程 $\\mathcal{L}_{EFIE}(\\vec{J}_s) \\equiv (\\hat{n} \\times \\mathcal{E}(\\vec{J}_s))|_S = -(\\hat{n} \\times \\vec{E}^{inc})|_S$。如果存在一个非平凡电流 $\\vec{J}_s$ 使得 $\\mathcal{L}_{EFIE}(\\vec{J}_s)=0$，则算子 $\\mathcal{L}_{EFIE}$ 是不可逆的。这种情况恰好发生在某些波数 $k$ 上，对于这些波数，齐次内部问题（homogeneous interior problem），即在 $V$ 内部寻找一个满足 $\\nabla \\times \\nabla \\times \\vec{E}_{int} - k^2\\vec{E}_{int} = 0$ 且边界条件为 $\\hat{n} \\times \\vec{E}_{int}|_S = 0$ 的非平凡场 $\\vec{E}_{int}$，存在解。这些波数是 PEC 空腔的谐振频率，对应于矢量亥姆霍兹算子（vector Helmholtz operator）的内部狄利克雷特征值。\n\nMFIE 是从跨越表面 $S$ 的磁场切向分量的连续性条件推导出来的。紧邻 $S$ 外部的总磁场切向分量通过 $\\hat{n} \\times \\vec{H}|_S = \\vec{J}_s$ 与表面电流相关联。这导出了算子方程 $\\mathcal{L}_{MFIE}(\\vec{J}_s) \\equiv \\vec{J}_s - \\hat{n} \\times \\mathcal{H}(\\vec{J}_s)|_S = \\hat{n} \\times \\vec{H}^{inc}|_S$，其中 $\\mathcal{H}$ 是产生散射磁场的算子。算子 $\\mathcal{L}_{MFIE}$ 在对应于对偶内部问题（dual interior problem）谐振的波数 $k$ 处失效，该问题与场上的齐次诺伊曼边界条件相关联。这些就是内部诺伊曼特征值。\n\n对于半径为 $a$ 的球体，这些矢量边值问题可以通过使用变量分离法和矢量球谐函数展开来简化。球体内部的解在原点处必须是正则的（regular）。这些解的径向依赖性由第一类球贝塞尔函数 $j_{\\ell}(kr)$ 给出。\n对矢量球谐函数的分析表明，场解可分为两种类型：相对于径向方向 $\\hat{r}$ 的横磁（TM）和横电（TE）。\n\\begin{itemize}\n    \\item 污染 EFIE 的内部狄利克雷问题，其解的特征值 $k$ 满足 $j_{\\ell}(ka) = 0$（对于某个整数阶 $\\ell \\ge 0$）。这些被指定为狄利克雷特征值。\n    \\item 污染 MFIE 的内部诺伊曼问题，其解的特征值 $k$ 满足 $j_{\\ell}'(ka) = 0$（对于某个整数阶 $\\ell \\ge 0$），其中撇号表示对自变量求导。这些是诺伊曼特征值。\n\\end{itemize}\n因此，该问题正确地指出，球体 EFIE 和 MFIE 的病态性分别与无量纲参数 $x = ka$ 接近 $j_{\\ell}(x)$ 和 $j_{\\ell}'(x)$ 的零点有关。\n\n数值任务是找到这些零点，然后计算条件代理指标 $C_E$ 和 $C_M$。算法流程如下：\n1.  定义用于求根的目标函数：$f_D(x;\\ell) = j_{\\ell}(x)$ 用于狄利克雷根（EFIE），$f_N(x;\\ell) = j_{\\ell}'(x)$ 用于诺伊曼根（MFIE）。这些函数是使用 `scipy.special` 库中的函数实现的。\n2.  实现一个稳健的求根程序，以定位每个函数在阶数 $\\ell=0, 1, \\dots, L$ 下的前 $N$ 个正零点。这通过首先确定根的区间，然后对其进行精化来实现。确定区间的操作是通过沿正 $x$ 轴步进并检测函数值的符号变化来完成的。然后将发生符号变化的区间传递给一个基于二分法的求解器 `scipy.optimize.brentq`，该求解器能高效地找到高精度的根。\n3.  对于每个测试用例 $(a, L, N, k)$，首先预计算所需的零点集 $\\{x_{\\ell,n}^{(D)}\\}$ 和 $\\{x_{\\ell,n}^{(N)}\\}$，其中 $\\ell \\in \\{0, \\dots, L\\}$ 且 $n \\in \\{1, \\dots, N\\}$。\n4.  计算测试参数 $x_{test} = ka$。\n5.  计算 $x_{test}$ 到所有已计算的狄利克雷零点的最小距离：$\\delta_E = \\min_{\\ell,n} |x_{test} - x_{\\ell,n}^{(D)}|$。\n6.  计算 $x_{test}$ 到所有已计算的诺伊曼零点的最小距离：$\\delta_M = \\min_{\\ell,n} |x_{test} - x_{\\ell,n}^{(N)}|$。\n7.  使用指定的下限值 $\\varepsilon = 10^{-6}$ 计算代理条件度量 $C_E = 1/\\max(\\delta_E, \\varepsilon)$ 和 $C_M = 1/\\max(\\delta_M, \\varepsilon)$。\n8.  收集所有测试用例的最终结果，并按规定格式化为单个字符串。这个系统化的过程提供了一个定量度量，衡量每个测试配置与内部谐振的接近程度，从而诊断 EFIE 和 MFIE 求解器中潜在的数值不稳定性。", "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.optimize import brentq\nimport json\n\ndef solve():\n    \"\"\"\n    Computes EFIE and MFIE conditioning proxies for PEC spheres by analyzing distances\n    to interior resonance wavenumbers.\n    \"\"\"\n    test_cases = [\n        # (a, L, N, k)\n        (0.5, 6, 4, 6.2),\n        (0.5, 6, 4, 8.99),\n        (0.5, 6, 4, 2.0),\n        (1.0, 8, 3, 4.50),\n        (0.2, 4, 5, 20.0),\n    ]\n\n    epsilon = 1e-6\n\n    def find_zeros(l, N, derivative):\n        \"\"\"\n        Finds the first N positive zeros of j_l(x) or j_l'(x) for a given order l.\n        Uses scanning to find brackets, then brentq to find roots.\n        \"\"\"\n        zeros = []\n        f = lambda x: spherical_jn(l, x, derivative=derivative)\n        \n        # Start scanning for roots from a small positive number to avoid x=0.\n        x_current = 0.1\n        scan_step = 0.1\n\n        # For l > 0, j_l(0)=0 and j'_l(0)=0 (for l > 1).\n        # We seek positive roots, so starting at x_current > 0 is correct.\n        \n        y_current = f(x_current)\n        \n        while len(zeros)  N:\n            # Move along the x-axis to find a sign change.\n            x_next = x_current + scan_step\n            y_next = f(x_next)\n            \n            # If a sign change is detected, there is a root in [x_current, x_next].\n            if np.sign(y_current) != np.sign(y_next):\n                try:\n                    root = brentq(f, x_current, x_next)\n                    # Add if it's a new root (to guard against re-finding)\n                    if not any(np.isclose(root, z) for z in zeros):\n                        zeros.append(root)\n                    # Advance the ancher to continue searching past the found root.\n                    x_current = root + scan_step\n                    y_current = f(x_current)\n\n                except ValueError: # Should not happen with a sign change\n                    x_current = x_next\n                    y_current = y_next\n            else:\n                x_current = x_next\n                y_current = y_next\n        \n        return zeros\n\n    # Determine maximum L and N from test cases to pre-compute all needed zeros.\n    L_max = max(tc[1] for tc in test_cases)\n    N_max = max(tc[2] for tc in test_cases)\n\n    # Pre-compute zeros to avoid redundant calculations.\n    # precomputed_dirichlet_zeros[l] will be a list of the first N_max zeros of j_l(x)\n    precomputed_dirichlet_zeros = [find_zeros(l, N_max, derivative=False) for l in range(L_max + 1)]\n    # precomputed_neumann_zeros[l] will be a list of the first N_max zeros of j_l'(x)\n    precomputed_neumann_zeros = [find_zeros(l, N_max, derivative=True) for l in range(L_max + 1)]\n\n    final_results = []\n    \n    for a, L, N, k in test_cases:\n        # Assemble the sets of active roots for the current test case.\n        active_dirichlet_roots = []\n        for l in range(L + 1):\n            active_dirichlet_roots.extend(precomputed_dirichlet_zeros[l][:N])\n\n        active_neumann_roots = []\n        for l in range(L + 1):\n            active_neumann_roots.extend(precomputed_neumann_zeros[l][:N])\n            \n        x_test = k * a\n\n        # Compute minimum distances to the resonance sets.\n        delta_E = np.min(np.abs(np.array(active_dirichlet_roots) - x_test))\n        delta_M = np.min(np.abs(np.array(active_neumann_roots) - x_test))\n\n        # Compute conditioning proxies.\n        C_E = 1.0 / max(delta_E, epsilon)\n        C_M = 1.0 / max(delta_M, epsilon)\n\n        final_results.append([C_E, C_M])\n\n    # Format the output string exactly as required.\n    # Using json.dumps provides a compact, space-free representation of a list of lists.\n    # The default float precision is sufficient.\n    class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, np.floating):\n                return float(obj)\n            return json.JSONEncoder.default(self, obj)\n\n    print(json.dumps(final_results, separators=(',', ':'), cls=CustomEncoder))\n\nsolve()\n```", "id": "3319829"}, {"introduction": "既然我们能够预测谐振发生的位置，下一步就是理解它们的数值影响。该实践 [@problem_id:3319757] 从预测转向量化，要求您计算二维圆形物体离散化后 EFIE 算子的条件数。您将直接观察到当工作频率接近谐振频率时，这个关键指标如何急剧增大，从而清晰地展示由此产生的数值不稳定性。", "problem": "考虑二维横电（TE）极化下的时谐电磁散射问题，其中电场唯一非零分量为平面外标量场 $E_z(\\mathbf{r})$，它在一个具有光滑边界 $\\Gamma$ 的完美导电（PEC）障碍物外部满足标量亥姆霍兹方程 $\\nabla^2 E_z + k^2 E_z = 0$。针对狄利克雷边界条件 $E_z|_{\\Gamma} = 0$ 的电场积分方程（EFIE）可以用单层积分算子表示为\n$$\n(S_k \\varphi)(\\mathbf{r}) = \\int_{\\Gamma} G_k(\\mathbf{r}, \\mathbf{r}') \\, \\varphi(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}'),\n$$\n其中 $G_k(\\mathbf{r}, \\mathbf{r}') = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$ 是亥姆霍兹方程的二维自由空间格林函数，$H_0^{(1)}$ 是零阶第一类汉克尔函数，$k$ 是波数（在此数学公式中为无量纲量）。当算子 $S_k$ 因内部狄利克雷问题存在非平凡解而变得不可逆时，EFIE 会出现内部谐振，这对应于某些 $k$ 值，在这些 $k$ 值下，内部区域存在满足 $\\nabla^2 u + k^2 u = 0$ 且 $u|_{\\Gamma} = 0$ 的非零解。\n\n在一个半径为 $a$、由 $\\mathbf{r}(\\theta) = a(\\cos\\theta, \\sin\\theta)$（其中 $0 \\le \\theta  2\\pi$）参数化的圆上，算子 $S_k$ 在角变量上表现为卷积，并在傅里叶基 $\\{e^{i m \\theta}\\}_{m \\in \\mathbb{Z}}$ 下对角化。使用关于贝塞尔函数和汉克尔函数的 Graf 加法定理，$S_k$ 作用于傅里叶模态 $e^{i m \\theta}$ 的结果是乘以一个标量\n$$\ns_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(k a) J_m(k a),\n$$\n其中 $J_m$ 是 $m$ 阶第一类贝塞尔函数，$H_m^{(1)}$ 是 $m$ 阶第一类汉克尔函数。对于圆，内部狄利克雷特征值（谐振）发生在满足 $J_m(k a) = 0$（对于某个整数 $m$）的 $k$ 值处，这导致 $s_m(k)$ 为零，EFIE 变为奇异的。\n\n通过将傅里叶基截断为模态 $m = -M, \\ldots, M$，将半径为 $a$ 的圆上的 EFIE 离散化，得到一个对角线元素为 $\\{s_m(k)\\}_{m=-M}^{M}$ 的 $(2M+1) \\times (2M+1)$ 方形对角矩阵。对于给定的 $k$，将此离散化 EFIE 矩阵的条件数定义为\n$$\n\\kappa(k; a, M) = \\frac{\\max_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}{\\min_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}.\n$$\n在与模态 $m$ 相关的内部谐振附近，由于 $J_m(k a) \\to 0$，$\\lvert s_m(k) \\rvert$ 的值会变小，条件数也相应增大。\n\n任务：编写一个完整、可运行的程序，该程序：\n- 使用上述在圆上的傅里叶-伽辽金离散化方法，为指定的 $k$ 值计算条件数 $\\kappa(k; a, M)$。\n- 使用 $a = 1$ 和 $M = 20$。\n- 将模态 $m = 0$ 的第一个内部狄利克雷谐振 $k_0$ 确定为 $J_0(k a)$（其中 $a=1$）的最小正根。\n- 对以下波数测试套件评估条件数：\n  1. $k = 1.0$（远离谐振），\n  2. $k = k_0 - 0.2$（适度低于谐振），\n  3. $k = k_0 - 0.05$（接近低于谐振），\n  4. $k = k_0 - 0.005$（非常接近低于谐振），\n  5. $k = k_0 + 0.05$（接近高于谐振），\n  6. $k = 3.0$（高于第一谐振，低于下一谐振）。\n- 生成最终输出为单行，包含上述测试套件的六个条件数，格式化为方括号括起来的逗号分隔的 Python 列表，例如 $[c_1,c_2,c_3,c_4,c_5,c_6]$，其中每个 $c_j$ 是一个浮点数。\n\n注意：\n- 此问题中的所有量都是无量纲的；不需要物理单位。\n- 您的实现必须使用所述的傅里叶符号 $s_m(k)$，并且条件数必须计算为最大奇异值与最小奇异值的比值，对于对角矩阵，奇异值是其对角线元素的绝对值。\n- 使用可靠的特殊函数（$J_m$ 和 $H_m^{(1)}$）求值以确保数值稳定性。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。", "solution": "该问题被评估为有效。它在科学上基于计算电磁学的原理，特别是散射问题的积分方程方法。该问题的表述是适定的，提供了计算出唯一、有意义的数值结果所需的所有必要参数、方程和定义。语言客观且数学上精确。\n\n该问题要求计算圆形散射体上离散化电场积分方程（EFIE）算子的条件数。这用于展示内部谐振现象，即算子变得病态或奇异的情况。\n\n其物理背景是二维时谐电磁波从完美导电（PEC）圆柱体上的散射。对于横电（TE）极化，问题简化为求解电场平面外分量 $E_z(\\mathbf{r})$ 的标量亥姆霍兹方程：\n$$\n(\\nabla^2 + k^2) E_z(\\mathbf{r}) = 0\n$$\n在散射体外部的区域中。这里，$k$ 是波数。对于 PEC 散射体，总的切向电场在边界 $\\Gamma$ 上必须为零，对于标量场 $E_z$ 这意味着狄利克雷边界条件 $E_z|_{\\Gamma} = 0$。\n\nEFIE 源于将散射场表示为单层势。这导出了一个关于未知表面电流密度 $\\varphi(\\mathbf{r}')$ 的积分方程。所涉及的算子是单层算子 $S_k$：\n$$\n(S_k \\varphi)(\\mathbf{r}) = \\int_{\\Gamma} G_k(\\mathbf{r}, \\mathbf{r}') \\, \\varphi(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}')\n$$\n其中 $G_k(\\mathbf{r}, \\mathbf{r}') = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$ 是二维自由空间格林函数，$H_0^{(1)}$ 是零阶第一类汉克尔函数。\n\nEFIE 的一个关键问题是内部谐振的存在。这些谐振发生在特定的波数 $k$ 处，对于这些波数，相应的内部狄利克雷问题（即散射体内部带有零边界条件的亥姆霍兹方程）存在非平凡解。在这些谐振波数下，外部 EFIE 算子 $S_k$ 变得不可逆，数值解也变得不稳定。\n\n对于半径为 $a$ 的圆形散射体，由于对称性，问题大大简化。算子 $S_k$ 在角变量上表现为卷积，并通过傅里叶基函数 $\\{e^{i m \\theta}\\}_{m \\in \\mathbb{Z}}$ 对角化。$S_k$ 作用于 $e^{i m \\theta}$ 的结果是乘以一个标量，即符号 $s_m(k)$：\n$$\ns_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(k a) J_m(k a)\n$$\n这里，$J_m$ 和 $H_m^{(1)}$ 分别是 $m$ 阶的贝塞尔函数和汉克尔函数。\n圆的内部谐振对应于使 $k a$ 成为贝塞尔函数 $J_m$ 的一个零点的波数 $k$。在这样的 $k$ 值下，符号 $s_m(k)$ 变为零，表明 $S_k$ 不可逆。\n\n该问题要求我们通过将傅里叶级数截断到有限数量的模态 $m \\in \\{-M, \\ldots, M\\}$ 来离散化算子。在这个基底下，算子由一个 $(2M+1) \\times (2M+1)$ 的对角矩阵 $S_{k,M}$ 表示，其对角线上的元素为符号 $\\{s_m(k)\\}_{m=-M}^{M}$。\n\n该矩阵的条件数 $\\kappa(S_{k,M})$ 衡量其对扰动的敏感度及其接近奇异的程度。对于对角矩阵，奇异值是对角线元素的绝对值。因此，条件数由最大奇异值与最小奇异值的比值给出：\n$$\n\\kappa(k; a, M) = \\frac{\\max_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}{\\min_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}\n$$\n在谐振附近（例如，对于模态 $m_0$），当 $k a$ 接近 $J_{m_0}$ 的一个零点时，$\\lvert s_{m_0}(k) \\rvert$ 的值会变得非常小。这个小值出现在条件数的分母中，导致 $\\kappa$ 变得非常大，预示着数值问题的病态性。\n\n计算步骤如下：\n1.  设置固定参数：半径 $a=1$ 和傅里叶截断极限 $M=20$。考虑的模态将是 $m \\in \\{-20, -19, \\ldots, 19, 20\\}$。\n2.  确定模态 $m=0$ 的第一个内部狄利克雷谐振 $k_0$。这是使 $J_0(k a) = J_0(k) = 0$ 的最小正 $k$。这个值是一个著名的数学常数，即 $J_0(x)$ 的第一个零点，约为 $2.4048$。我们为了高精度会数值计算这个值。\n3.  根据计算出的 $k_0$ 值构建测试波数集 $k$。\n4.  对于测试集中的每个测试波数 $k$：\n    a. 生成从 $-M$ 到 $M$ 的模态数 $m$ 的数组。\n    b. 使用公式 $s_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(ka) J_m(ka)$ 计算符号集 $\\{s_m(k)\\}_{m=-M}^{M}$。注意，由于 $J_{-m}(z) = (-1)^m J_m(z)$ 和 $H_{-m}^{(1)}(z) = (-1)^m H_m^{(1)}(z)$，因此 $s_{-m}(k) = s_m(k)$。我们的计算将直接处理从 $-M$到$M$ 的所有 $m$。\n    c. 计算所有符号的绝对值 $\\{\\lvert s_m(k) \\rvert\\}_{m=-M}^{M}$。\n    d. 找出这些绝对值的最大值和最小值。\n    e. 将条件数 $\\kappa$ 计算为最大值与最小值的比值。\n5.  收集六个计算出的条件数，并以指定格式呈现。所需的特殊函数（$J_m, H_m^{(1)}$）以及用于 $J_0$ 的求根程序可在 `scipy.special` 库中找到。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1, jn_zeros\n\ndef solve():\n    \"\"\"\n    Computes the condition number of a discretized EFIE operator on a circle\n    to demonstrate the effect of internal resonances.\n    \"\"\"\n    \n    # Define the problem parameters as specified.\n    a = 1.0\n    M = 20\n\n    # Step 1: Find the first interior Dirichlet resonance k_0 for m=0.\n    # This is the smallest positive root of J_0(k*a) = 0, which is the first\n    # zero of the Bessel function J_0(x) divided by a.\n    # jn_zeros(0, 1) returns an array containing the first positive zero of J_0.\n    # Since a=1, k_0 is simply the first zero.\n    k0 = jn_zeros(0, 1)[0]\n\n    # Step 2: Define the test suite of wavenumbers.\n    test_k_values = [\n        1.0,           # k = 1.0 (far from resonance)\n        k0 - 0.2,      # k moderately below resonance\n        k0 - 0.05,     # k near below resonance\n        k0 - 0.005,    # k very close below resonance\n        k0 + 0.05,     # k near above resonance\n        3.0,           # k above the first resonance, below the next\n    ]\n\n    results = []\n    \n    # Step 3: Loop through each test wavenumber and compute the condition number.\n    for k in test_k_values:\n        # Define the range of Fourier modes m = -M, ..., M.\n        modes = np.arange(-M, M + 1)\n        \n        # Argument for the Bessel and Hankel functions.\n        x = k * a\n        \n        # Calculate the symbols s_m(k) for all modes.\n        # The formula is s_m(k) = a * (i*pi/2) * H_m^(1)(k*a) * J_m(k*a)\n        # SciPy's jv and hankel1 functions are vectorized, so we can compute\n        # for all modes at once.\n        Jm_values = jv(modes, x)\n        H1m_values = hankel1(modes, x)\n        \n        sm_values = a * (1j * np.pi / 2.0) * H1m_values * Jm_values\n        \n        # The singular values of the diagonal matrix are the absolute values\n        # of its diagonal entries.\n        singular_values = np.abs(sm_values)\n        \n        # The condition number is the ratio of the largest to smallest singular value.\n        max_sv = np.max(singular_values)\n        min_sv = np.min(singular_values)\n        \n        # A check for singularity. For the chosen k, min_sv should not be zero.\n        if min_sv == 0:\n            condition_number = np.inf\n        else:\n            condition_number = max_sv / min_sv\n            \n        results.append(condition_number)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3319757"}, {"introduction": "在诊断并量化了内部谐振问题之后，我们转向其解决方案：组合场积分方程 (CFIE)。该练习 [@problem_id:3319825] 利用一个巧妙的光谱替代模型，来探索如何将“病态”的 EFIE 与“健康”的 MFIE 相结合，以产生一个即使在谐振频率下也稳健且良态的系统。您的任务是开发并测试一种自适应策略来选择最佳混合参数 $\\alpha$，从而揭示 CFIE 在消除其母方程不稳定性方面的威力。", "problem": "你需要构建、分析并算法优化一个组合场积分方程 (Combined Field Integral Equation, CFIE)，用以缓解在求解闭合理想电导体 (Perfect Electric Conductor, PEC) 上的时谐麦克斯韦边界积分方程时，电场积分方程 (Electric Field Integral Equation, EFIE) 和磁场积分方程 (Magnetic Field Integral Equation, MFIE) 中出现的内共振问题。你的任务是实现一个独立的数值实验，该实验通过一个综合但物理上合理的谱代理模型来模拟一个亏格为2的PEC体，并提出和验证一个自适应CFIE混合参数，以减少在共振波数附近的谱恶化。\n\n从以下原则和建模假设开始。\n\n1. 基本基础。从时谐麦克斯韦方程和闭合PEC上著名的边界积分公式开始，即电场积分方程 (EFIE) 和磁场积分方程 (MFIE)。CFIE是这两个算子的凸组合，用于避免可能导致病态和迭代停滞的内共振。将EFIE算子表示为 $\\mathcal{E}(k)$，MFIE算子表示为 $\\mathcal{M}(k)$，其中 $k$ 是实数波数（单位为 $1/\\mathrm{m}$）。CFIE算子为\n$$\n\\mathcal{C}_{\\alpha}(k) \\,=\\, \\alpha\\, \\mathcal{E}(k) \\,+\\, \\left(1-\\alpha\\right)\\, \\mathcal{M}(k),\n$$\n其中 $\\alpha \\in [0,1]$。我们将分析 $\\mathcal{C}_{\\alpha}(k)$ 的一个离散代理的谱，以量化其鲁棒性。\n\n2. 离散谱代理。通过两个独立的表面电流模式族来模拟亏格为2的PEC体，总共得到 $N = 12$ 个离散模式。对于每个模式索引 $i \\in \\{1,2,\\dots,12\\}$ 和给定的波数 $k$，通过在严格为正的基线周围添加平滑的洛伦兹微扰来定义EFIE和MFIE的特征值 $\\lambda_{E,i}(k)$ 和 $\\lambda_{M,i}(k)$。EFIE表现出显著的波谷（模拟内部狄利克雷共振），而MFIE保持有界且远离零，只有轻微变化（模拟MFIE在闭合PEC几何结构上的相对鲁棒性）。具体来说：\n- EFIE特征值：\n$$\n\\lambda_{E,i}(k) \\,=\\, b_i \\;-\\; \\sum_{j=1}^{4} a_{E,i,j}\\,\\frac{\\gamma_{E,j}^{2}}{(k - k_{E,j})^{2} + \\gamma_{E,j}^{2}},\n$$\n共振中心和宽度为\n$$\nk_{E,1} = 5.0,\\;\\; \\gamma_{E,1} = 0.08;\\quad\nk_{E,2} = 8.0,\\;\\; \\gamma_{E,2} = 0.06;\\quad\nk_{E,3} = 3.2,\\;\\; \\gamma_{E,3} = 0.05;\\quad\nk_{E,4} = 9.2,\\;\\; \\gamma_{E,4} = 0.07,\n$$\n以及依赖于模式的振幅\n$$\nb_i \\in [0.95, 1.25],\\quad\na_{E,i,1} = 0.35\\,w_i,\\;\\;\na_{E,i,2} = 0.30\\,w_i,\\;\\;\na_{E,i,3} = 0.12\\,w_i,\\;\\;\na_{E,i,4} = 0.10\\,w_i,\n$$\n其中 $w_i \\in [0.85,1.15]$ 通过一个确定性缩放向量编码了亏格为2的多重性模式（两个各含6个模式的族）。这些选择确保了 $\\lambda_{E,i}(k) > 0$，但允许在 $k \\approx 5.0$ 和 $k \\approx 8.0$ 附近出现接近于零的波谷。\n\n- MFIE特征值：\n$$\n\\lambda_{M,i}(k) \\,=\\, m_i \\;+\\; \\sum_{j=1}^{2} q_{M,i,j}\\,\\frac{\\gamma_{M,j}^{2}}{(k - k_{M,j})^{2} + \\gamma_{M,j}^{2}},\n$$\n其中\n$$\nk_{M,1} = 6.3,\\;\\; \\gamma_{M,1} = 0.08;\\quad\nk_{M,2} = 9.5,\\;\\; \\gamma_{M,2} = 0.07,\n$$\n和依赖于模式的基线和振幅\n$$\nm_i \\in [0.50, 0.72],\\qquad\nq_{M,i,1} = 0.08\\,v_i,\\;\\;\nq_{M,i,2} = 0.07\\,v_i,\n$$\n其中 $v_i \\in [0.90,1.10]$。这些确保了在所有感兴趣的 $k$ 值下 $\\lambda_{M,i}(k) > 0.30$。\n\n3. CFIE谱。第 $i$ 个CFIE特征值是凸组合\n$$\n\\lambda_{C,i}(k,\\alpha) \\,=\\, \\alpha\\, \\lambda_{E,i}(k) \\,+\\, \\left(1-\\alpha\\right)\\, \\lambda_{M,i}(k),\\qquad \\alpha \\in [0,1].\n$$\n\n4. 性能度量。考虑应用于线性缩放的CFIE矩阵的定常Richardson迭代。对于具有正实数特征值的矩阵，Richardson迭代的最优标量步长能最小化迭代矩阵的谱半径，并产生一个仅依赖于条件数的最小化谱半径。令\n$$\n\\kappa(\\alpha,k) \\,=\\, \\frac{\\max_{i}\\lambda_{C,i}(k,\\alpha)}{\\min_{i}\\lambda_{C,i}(k,\\alpha)}.\n$$\n最优缩放的Richardson迭代的谱半径满足\n$$\n\\rho^{\\star}(\\alpha,k) \\,=\\, \\frac{\\kappa(\\alpha,k) - 1}{\\kappa(\\alpha,k) + 1}.\n$$\n因此，当所有特征值都是正实数时，最小化 $\\rho^{\\star}(\\alpha,k)$（在 $\\alpha \\in [0,1]$ 范围内）等价于最小化 $\\kappa(\\alpha,k)$。\n\n5. 自适应CFIE参数。设计一个仅基于EFIE和MFIE的粗略谱指标的自适应策略 $\\alpha(k)$：\n$$\n\\kappa_{E}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{E,i}(k)}{\\min_{i}\\lambda_{E,i}(k)},\\quad\n\\kappa_{M}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{M,i}(k)}{\\min_{i}\\lambda_{M,i}(k)}.\n$$\n定义稳定性得分\n$$\ns_{E}(k) \\,=\\, \\kappa_{E}(k)^{-1},\\qquad\ns_{M}(k) \\,=\\, \\kappa_{M}(k)^{-1},\n$$\n和一个带有锐度参数 $p \\ge 1$ 的自适应混合法则：\n$$\n\\alpha_{\\mathrm{ad}}(k) \\,=\\, \\frac{\\left[s_{E}(k)\\right]^{p}}{\\left[s_{E}(k)\\right]^{p} + \\left[s_{M}(k)\\right]^{p}}.\n$$\n使用 $p = 2$。\n\n6. 任务。\n- 完全按照上述说明实现谱代理模型，使用确定性数组表示 $b_i, m_i, w_i, v_i$（在指定范围内取值），并设置 $N=12$ 个模式。\n- 对于每个给定的测试波数 $k$（单位为 $1/\\mathrm{m}$），计算：\n  1. 自适应参数 $\\alpha_{\\mathrm{ad}}(k)$。\n  2. 通过自适应选择实现的最小化谱半径 $\\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k)$。\n  3. 全局最小化谱半径 $\\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)$。\n  4. 一个布尔值，指示自适应选择是否在最优谱半径的 $5\\%$ 相对容差范围内，即是否满足\n  $$\n  \\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k) \\,\\le\\, 1.05 \\times \\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k).\n  $$\n- 使用稳健的一维有界搜索在 $\\alpha \\in [0,1]$ 范围内进行数值最小化。\n\n7. 测试套件。使用以下波数（单位为 $1/\\mathrm{m}$），这些波数被选择用来探测理想路径、近共振和边缘场景：\n$$\nk \\in \\left\\{\\, 4.0,\\; 5.0,\\; 6.3,\\; 8.0,\\; 9.2,\\; 9.5,\\; 3.2,\\; 10.0 \\,\\right\\}.\n$$\n\n8. 输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。对于按上述顺序排列的每个测试用例，输出一个包含四个条目的列表：\n$$\n\\left[\\, \\alpha_{\\mathrm{ad}}(k),\\; \\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k),\\; \\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k),\\; \\text{boolean} \\,\\right].\n$$\n所有浮点数必须四舍五入到 $6$ 位小数，布尔值必须是 $\\mathrm{True}$ 或 $\\mathrm{False}$。因此，整个输出是一个包含八个此类测试用例列表的单一列表，例如：\n$$\n\\left[\\,[0.123456,0.234567,0.210000,\\mathrm{True}],\\; \\dots \\,\\right].\n$$\n不应打印任何其他文本。除波数输入 $k$ 的单位为 $1/\\mathrm{m}$ 外，所有量都是无量纲的；你无需在输出中报告单位。", "solution": "该问题是有效的。它提出了一个计算电磁学领域中适定且有科学依据的数值实验。任务是分析组合场积分方程(CFIE)的谱代理模型，以评估一种选择混合参数 $\\alpha$ 的自适应策略。该模型模拟了电场积分方程(EFIE)和磁场积分方程(MFIE)在内共振附近的行为。后续的解决方案是严格遵循所提供的定义和参数来开发的。\n\n该方法按以下顺序实现：\n\n1.  **模型参数的离散化：** 分析是在一个具有 $N=12$ 个离散模式的系统上进行的。依赖于模式的参数 $b_i, m_i, w_i, v_i$（对于 $i \\in \\{1, 2, \\dots, 12\\}$）需要是跨越其指定范围的确定性数组。\n    -   基线参数 $b_i$ 和 $m_i$ 是通过在其各自区间内使用线性间隔值生成的：$b_i$ 是一个跨越 $[0.95, 1.25]$ 的向量，$m_i$ 跨越 $[0.50, 0.72]$。\n    -   缩放向量 $w_i$ 和 $v_i$ 被指定为编码一个“亏格为2的多重性模式（两个各含6个模式的族）”。这被解释为一个重复的模式。我们通过在 $[0.85, 1.15]$ 中生成6个线性间隔点并将此序列平铺两次来构建 $w_i$。对 $v_i$ 在区间 $[0.90, 1.10]$ 上应用类似的过程。\n\n2.  **谱代理函数：** 我们定义函数来计算作为波数 $k$ 函数的EFIE和MFIE算子的特征值。\n    -   EFIE特征值 $\\lambda_{E,i}(k)$ 由下式给出：\n    $$\n    \\lambda_{E,i}(k) \\,=\\, b_i \\;-\\; \\sum_{j=1}^{4} a_{E,i,j}\\,\\frac{\\gamma_{E,j}^{2}}{(k - k_{E,j})^{2} + \\gamma_{E,j}^{2}}\n    $$\n    其中振幅 $a_{E,i,j}$ 是给定常数（$0.35, 0.30, 0.12, 0.10$）与依赖于模式的缩放因子 $w_i$ 的乘积。该求和项模拟了EFIE特有的共振波谷。\n    -   MFIE特征值 $\\lambda_{M,i}(k)$ 由下式给出：\n    $$\n    \\lambda_{M,i}(k) \\,=\\, m_i \\;+\\; \\sum_{j=1}^{2} q_{M,i,j}\\,\\frac{\\gamma_{M,j}^{2}}{(k - k_{M,j})^{2} + \\gamma_{M,j}^{2}}\n    $$\n    其中振幅 $q_{M,i,j}$ 是常数（$0.08, 0.07$）与缩放因子 $v_i$ 的乘积。这模拟了MFIE通常更稳定的谱。\n\n3.  **CFIE谱与性能度量：** 分析的核心涉及CFIE，它结合了EFIE和MFIE算子。\n    -   CFIE特征值是一个凸组合：\n    $$\n    \\lambda_{C,i}(k,\\alpha) \\,=\\, \\alpha\\, \\lambda_{E,i}(k) \\,+\\, \\left(1-\\alpha\\right)\\, \\lambda_{M,i}(k)\n    $$\n    对于混合参数 $\\alpha \\in [0,1]$。\n    -   迭代求解器的性能与系统矩阵的条件数有关。问题将条件数定义为：\n    $$\n    \\kappa(\\alpha,k) \\,=\\, \\frac{\\max_{i}\\lambda_{C,i}(k,\\alpha)}{\\min_{i}\\lambda_{C,i}(k,\\alpha)}\n    $$\n    -   对于最优缩放的Richardson迭代，决定渐进收敛率的迭代矩阵的谱半径为：\n    $$\n    \\rho^{\\star}(\\alpha,k) \\,=\\, \\frac{\\kappa(\\alpha,k) - 1}{\\kappa(\\alpha,k) + 1}\n    $$\n    最小化此谱半径 $\\rho^{\\star}$ 等价于最小化条件数 $\\kappa$，因为 $\\rho^{\\star}$ 是 $\\kappa \\ge 1$ 的单调递增函数。\n\n4.  **自适应混合策略及其评估：** 问题提出了一种启发式方法，用于根据构成算子的条件数自适应地选择 $\\alpha$。\n    -   我们首先计算EFIE和MFIE特征值集的条件数：\n    $$\n    \\kappa_{E}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{E,i}(k)}{\\min_{i}\\lambda_{E,i}(k)},\\quad\n    \\kappa_{M}(k) \\,=\\, \\frac{\\max_{i}\\lambda_{M,i}(k)}{\\min_{i}\\lambda_{M,i}(k)}\n    $$\n    -   自适应参数 $\\alpha_{\\mathrm{ad}}(k)$ 的构建旨在为条件数较低（稳定性得分 $s = 1/\\kappa$ 较高）的算子赋予更大权重。锐度 $p=2$ 时：\n    $$\n    \\alpha_{\\mathrm{ad}}(k) \\,=\\, \\frac{\\left[s_{E}(k)\\right]^{p}}{\\left[s_{E}(k)\\right]^{p} + \\left[s_{M}(k)\\right]^{p}} = \\frac{\\kappa_{M}(k)^p}{\\kappa_{M}(k)^p + \\kappa_{E}(k)^p}\n    $$\n    -   然后将此自适应选择的性能 $\\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k)$ 与全局最优值 $\\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)$ 进行比较。\n\n5.  **数值优化：** 为了找到全局最优谱半径，需要对每个测试波数 $k$ 进行数值最小化。目标函数是 $f(\\alpha) = \\rho^{\\star}(\\alpha,k)$。由于 $\\alpha$ 被约束在区间 $[0,1]$ 内，因此采用有界一维优化算法。`scipy.optimize.minimize_scalar` 函数的 'bounded' 方法适用于此目的。\n\n6.  **计算流程：** 对于提供的测试套件中的每个波数 $k$，执行以下步骤：\n    a. 计算EFIE的 $N=12$ 个特征值 $\\lambda_{E,i}(k)$ 和MFIE的 $N=12$ 个特征值 $\\lambda_{M,i}(k)$。\n    b. 计算自适应混合参数 $\\alpha_{\\mathrm{ad}}(k)$。\n    c. 使用自适应参数计算谱半径 $\\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k),k)$。\n    d. 通过在 $\\alpha$ 上进行优化，数值求解最小谱半径 $\\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)$。\n    e. 通过检查自适应谱半径是否在最优谱半径的 $5\\%$ 相对容差范围内来确定一个布尔标志：\n    $$\n    \\rho^{\\star}(\\alpha_{\\mathrm{ad}}(k), k) \\,\\le\\, 1.05 \\times \\min_{\\alpha \\in [0,1]}\\rho^{\\star}(\\alpha,k)\n    $$\n    最后，将收集到的结果格式化为指定的单一列表的列表，其中浮点数四舍五入到6位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and algorithmically optimizes a Combined Field Integral Equation (CFIE)\n    to mitigate internal resonances using a spectral surrogate model.\n    \"\"\"\n    # 1. Define Constants and Parameters\n    N = 12\n    P_SHARPNESS = 2.0\n\n    # EFIE resonance parameters\n    KE_RESONANCES = np.array([5.0, 8.0, 3.2, 9.2])\n    GAMMA_E = np.array([0.08, 0.06, 0.05, 0.07])\n\n    # MFIE resonance parameters\n    KM_RESONANCES = np.array([6.3, 9.5])\n    GAMMA_M = np.array([0.08, 0.07])\n\n    # 2. Generate Deterministic Mode-Dependent Arrays\n    b_i = np.linspace(0.95, 1.25, N)\n    m_i = np.linspace(0.50, 0.72, N)\n    \n    # Per problem statement: \"genus-2 multiplicity pattern (two families of 6 modes each)\"\n    w_i = np.tile(np.linspace(0.85, 1.15, 6), 2)\n    v_i = np.tile(np.linspace(0.90, 1.10, 6), 2)\n\n    # Pre-calculate mode-dependent amplitudes\n    a_E_factors = np.array([0.35, 0.30, 0.12, 0.10])\n    a_E_ij = np.outer(w_i, a_E_factors)  # Shape (12, 4)\n\n    q_M_factors = np.array([0.08, 0.07])\n    q_M_ij = np.outer(v_i, q_M_factors)  # Shape (12, 2)\n\n    def lorentzian(k, k_res_vec, gamma_vec):\n        \"\"\"Calculates an array of Lorentzian terms.\"\"\"\n        return (gamma_vec**2) / ((k - k_res_vec)**2 + gamma_vec**2)\n\n    # 3. Implement Eigenvalue Functions\n    def get_lambda_E(k):\n        \"\"\"Computes the 12 EFIE eigenvalues for a given wavenumber k.\"\"\"\n        lorentzian_terms = lorentzian(k, KE_RESONANCES, GAMMA_E)\n        sum_term = np.dot(a_E_ij, lorentzian_terms)\n        return b_i - sum_term\n\n    def get_lambda_M(k):\n        \"\"\"Computes the 12 MFIE eigenvalues for a given wavenumber k.\"\"\"\n        lorentzian_terms = lorentzian(k, KM_RESONANCES, GAMMA_M)\n        sum_term = np.dot(q_M_ij, lorentzian_terms)\n        return m_i + sum_term\n\n    def get_lambda_C(lambda_E, lambda_M, alpha):\n        \"\"\"Computes the CFIE eigenvalues.\"\"\"\n        return alpha * lambda_E + (1.0 - alpha) * lambda_M\n\n    # 4. Implement Performance Metric and Adaptive Parameter Functions\n    def get_rho_star_from_lambdas(lambdas_C):\n        \"\"\"Calculates the optimal Richardson spectral radius from eigenvalues.\"\"\"\n        min_lambda = np.min(lambdas_C)\n        if min_lambda = 0:\n            return np.inf  # Problem guarantees positivity, but good practice\n        kappa = np.max(lambdas_C) / min_lambda\n        return (kappa - 1.0) / (kappa + 1.0)\n\n    def get_alpha_ad(lambda_E, lambda_M):\n        \"\"\"Calculates the adaptive mixing parameter.\"\"\"\n        kappa_E = np.max(lambda_E) / np.min(lambda_E)\n        kappa_M = np.max(lambda_M) / np.min(lambda_M)\n        \n        # Using the formulation alpha = kappa_M^p / (kappa_M^p + kappa_E^p)\n        # which is equivalent to the one based on stability scores s=1/kappa\n        # and is numerically more stable if a kappa is very large.\n        term_M_p = kappa_M ** P_SHARPNESS\n        term_E_p = kappa_E ** P_SHARPNESS\n        \n        if term_M_p + term_E_p == 0:\n            return 0.5 # Fallback for a potential 0/0 case, though unlikely\n        \n        return term_M_p / (term_M_p + term_E_p)\n\n    # 5. Define Test Suite and Main Loop\n    test_k_values = [4.0, 5.0, 6.3, 8.0, 9.2, 9.5, 3.2, 10.0]\n    all_results = []\n\n    for k in test_k_values:\n        lambda_E = get_lambda_E(k)\n        lambda_M = get_lambda_M(k)\n\n        # Task 1: Compute adaptive parameter\n        alpha_ad = get_alpha_ad(lambda_E, lambda_M)\n\n        # Task 2: Compute spectral radius for the adaptive choice\n        lambda_C_ad = get_lambda_C(lambda_E, lambda_M, alpha_ad)\n        rho_star_ad = get_rho_star_from_lambdas(lambda_C_ad)\n\n        # Task 3: Numerically find the globally minimized spectral radius\n        def objective_func(alpha):\n            lambdas_C = get_lambda_C(lambda_E, lambda_M, alpha)\n            return get_rho_star_from_lambdas(lambdas_C)\n        \n        opt_result = minimize_scalar(objective_func, bounds=(0, 1), method='bounded')\n        rho_star_opt = opt_result.fun\n\n        # Task 4: Compare adaptive vs optimal\n        is_near_optimal = rho_star_ad = 1.05 * rho_star_opt\n\n        all_results.append([\n            alpha_ad,\n            rho_star_ad,\n            rho_star_opt,\n            is_near_optimal\n        ])\n\n    # 6. Format and Print Output\n    formatted_results = []\n    for res in all_results:\n        # Format: [float, float, float, bool]\n        # Floats are rounded to 6 decimal places implicitly by formatter\n        # Python's str(bool) results in 'True'/'False' as required\n        formatted_r = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{res[3]}]\"\n        formatted_results.append(formatted_r)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3319825"}]}