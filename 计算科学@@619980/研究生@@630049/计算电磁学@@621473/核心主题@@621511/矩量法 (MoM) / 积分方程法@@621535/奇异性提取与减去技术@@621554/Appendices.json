{"hands_on_practices": [{"introduction": "在处理奇异性之前，我们必须首先理解其数学形式。本练习将深入探讨二维亥姆霍兹方程格林函数的核心，这是波散射问题中的基石 [@problem_id:3348056]。通过使用贝塞尔函数的级数展开，你将分析性地分离出对数奇异项，从而揭示数值方法必须处理的内在结构。", "problem": "考虑在二维空间中带有自由空间边界条件的时谐标量亥姆霍兹方程，\n$$(\\nabla^{2} + k^{2})\\,G(\\mathbf{r}) = -\\delta(\\mathbf{r}),$$\n其中 $k>0$ 是波数，$\\delta(\\cdot)$ 是狄拉克δ分布。自由空间格林函数由下式给出\n$$G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r),$$\n其中 $r = \\|\\mathbf{r}\\|$，$H_{0}^{(1)}$ 是第一类零阶汉克尔函数。在计算电磁学中，特别是在边界积分公式和边界元法（BEM）中，标准做法是通过减去静态二维格林函数核 $-\\frac{1}{2\\pi}\\ln r$ 来进行奇异性提取，以便在重合点分离出有限的余项。\n\n从基本定义和构成 $H_{0}^{(1)} = J_{0} + i Y_{0}$ 的贝塞尔函数 $J_{0}$ 和 $Y_{0}$ 的成熟级数表示出发，推导当 $r \\to 0^{+}$ 时 $G(\\mathbf{r})$ 的小宗量渐近行为，识别其主导的对数奇异性，并确定减去 $-\\frac{1}{2\\pi}\\ln r$ 后剩下的有限常数项。你的推导必须清楚地说明对数奇异性是如何产生的，以及常数项如何依赖于 $k$。\n\n作为最终答案，请提供 $G(\\mathbf{r})$ 的包含常数项在内的显式渐近表达式，即形式为\n$$-\\frac{1}{2\\pi}\\ln r + \\text{关于 r 的常数}$$\n的表达式，其中依赖于 $k$ 的常数需要被完全确定。不需要进行数值计算或四舍五入。最终答案必须是单一的闭式解析表达式。", "solution": "首先对问题进行验证。\n\n### 第一步：提取已知条件\n- 控制方程是二维时谐标量亥姆霍兹方程：$(\\nabla^{2} + k^{2})\\,G(\\mathbf{r}) = -\\delta(\\mathbf{r})$。\n- 波数 $k$ 是一个正实数，$k>0$。\n- 源项是狄拉克δ分布，$\\delta(\\mathbf{r})$。\n- 自由空间格林函数由 $G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r)$ 给出，其中 $r = \\|\\mathbf{r}\\|$。\n- $H_{0}^{(1)}$ 是第一类零阶汉克尔函数。\n- 奇异性提取技术涉及减去静态格林函数，即 $-\\frac{1}{2\\pi}\\ln r$。\n- 汉克尔函数通过 $H_{0}^{(1)} = J_{0} + i Y_{0}$ 与第一类贝塞尔函数（$J_0$）和第二类贝塞尔函数（$Y_0$）相关联。\n- 任务是使用 $J_0$ 和 $Y_0$ 的级数表示，推导当 $r \\to 0^{+}$ 时 $G(\\mathbf{r})$ 的小宗量渐近行为，并将其表示为 $-\\frac{1}{2\\pi}\\ln r + \\text{常数}$ 的形式。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学上成立：** 问题陈述完全基于成熟的数学物理和计算科学。亥姆霍兹方程、格林函数、贝塞尔函数和汉克尔函数，以及奇异性提取方法都是标准且有据可查的概念。\n- **适定的：** 该问题是适定的。它要求推导一个已定义函数的特定、已知的渐近极限。所需的步骤已经列出，并且存在唯一的解析解。\n- **客观的：** 问题以精确、客观、形式化的数学语言陈述，没有任何歧义或主观因素。\n- **结论：** 该问题科学上合理，内部一致，完整且适定。它没有违反任何指定的无效标准。\n\n### 第三步：裁定与行动\n该问题是**有效的**。将提供完整解答。\n\n### 渐近表达式的推导\n\n目标是确定亥姆霍兹方程的二维自由空间格林函数在径向距离 $r = \\|\\mathbf{r}\\|$ 趋近于零时的渐近行为。格林函数由下式给出：\n$$G(\\mathbf{r}) = \\frac{i}{4} H_{0}^{(1)}(k r)$$\n其中 $k > 0$ 是波数，$H_{0}^{(1)}$ 是第一类零阶汉克尔函数。\n\n首先，我们用第一类贝塞尔函数 $J_0$ 和第二类贝塞尔函数（或诺依曼函数）$Y_0$ 来表示汉克尔函数：\n$$H_{0}^{(1)}(z) = J_{0}(z) + i Y_{0}(z)$$\n将此定义代入 $G(\\mathbf{r})$ 的表达式中，并设宗量为 $z = kr$：\n$$G(\\mathbf{r}) = \\frac{i}{4} \\left( J_{0}(k r) + i Y_{0}(k r) \\right) = \\frac{i}{4} J_{0}(k r) - \\frac{1}{4} Y_{0}(k r)$$\n为了找到当 $r \\to 0^{+}$ 时的行为，我们需要 $J_0(z)$ 和 $Y_0(z)$ 在 $z \\to 0^{+}$ 时的小宗量渐近展开式。\n\n$J_0(z)$ 贝塞尔函数的级数表示为：\n$$J_{0}(z) = \\sum_{m=0}^{\\infty} \\frac{(-1)^{m}}{(m!)^{2}} \\left(\\frac{z}{2}\\right)^{2m} = 1 - \\frac{z^2}{4} + \\frac{z^4}{64} - \\dots$$\n当 $z \\to 0$ 时，主导项是 $1$。因此，对于小的 $r$：\n$$J_{0}(k r) = 1 + O((kr)^2)$$\n\n$Y_0(z)$ 贝塞尔函数的小宗量展开式更为复杂，也是对数奇异性的来源。其标准展开式为：\n$$Y_{0}(z) = \\frac{2}{\\pi} \\left[ \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) J_0(z) - \\sum_{m=1}^{\\infty} \\frac{(-1)^m}{(m!)^2} \\left( \\sum_{j=1}^{m} \\frac{1}{j} \\right) \\left(\\frac{z}{2}\\right)^{2m} \\right]$$\n其中 $\\gamma \\approx 0.5772$ 是欧拉-马歇罗尼常数。\n对于 $z \\to 0$，我们知道 $J_0(z) \\to 1$。求和项的行为是 $O(z^2)$。因此，$Y_0(z)$ 的主导阶行为由第一项决定：\n$$Y_{0}(z) \\approx \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) \\cdot 1 = \\frac{2}{\\pi} \\left( \\ln(z) - \\ln(2) + \\gamma \\right)$$\n代入 $z=kr$，我们得到 $Y_0(kr)$ 的小宗量行为：\n$$Y_{0}(k r) = \\frac{2}{\\pi} \\left( \\ln(kr) - \\ln(2) + \\gamma \\right) + O((kr)^2 \\ln(kr)) = \\frac{2}{\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right) + O((kr)^2 \\ln(kr))$$\n\n现在我们将 $J_0(kr)$ 和 $Y_0(kr)$ 的渐近形式代回到 $G(\\mathbf{r})$ 的表达式中：\n$$G(\\mathbf{r}) \\approx \\frac{i}{4}(1) - \\frac{1}{4} \\left[ \\frac{2}{\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right) \\right]$$\n简化此表达式：\n$$G(\\mathbf{r}) \\approx \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) + \\ln(r) - \\ln(2) + \\gamma \\right)$$\n为了匹配所要求的形式，我们分离出包含 $\\ln(r)$ 的项：\n$$G(\\mathbf{r}) \\approx -\\frac{1}{2\\pi}\\ln(r) + \\left[ \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) - \\ln(2) + \\gamma \\right) \\right]$$\n项 $-\\frac{1}{2\\pi}\\ln(r)$ 是预期的对数奇异性，它与二维拉普拉斯算子的格林函数（通常称为静态核）相同。剩下的部分是关于 $r$ 的常数：\n$$\\text{常数} = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(k) - \\ln(2) + \\gamma \\right) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{k}{2}\\right) + \\gamma \\right)$$\n这个常数代表了亥姆霍兹格林函数在减去对数奇异性后在原点的有限部分。它对波数 $k$ 的依赖性直接源于 $Y_0$ 展开式中对数的宗量。\n\n因此，当 $r \\to 0^{+}$ 时，$G(\\mathbf{r})$ 的包含常数项在内的完整渐近表达式为：\n$$G(\\mathbf{r}) \\approx -\\frac{1}{2\\pi}\\ln(r) + \\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)$$\n这个结果对于像边界元法这样的数值方法至关重要，在这些方法中，减去这种奇异性的解析形式可以对余下的良态函数进行精确的数值积分。", "answer": "$$\n\\boxed{-\\frac{1}{2\\pi}\\ln(r) + \\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)}\n$$", "id": "3348056"}, {"introduction": "既然我们能够识别奇异性，现在让我们看看移除它的实际好处。这个编程练习将挑战你计算一个近奇异积分，首先采用直接的数值方法，然后使用奇异性减除技术 [@problem_id:3348122]。通过比较两种方法的误差，你将直接衡量该技术带来的显著精度提升，这也是边界元法中采用此项技术的关键原因。", "problem": "考虑拉普拉斯方程的静态自由空间格林核，定义为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{1}{4\\pi \\|\\mathbf{r} - \\mathbf{r}'\\|}$，其中 $\\mathbf{r}$ 是观测点，$\\mathbf{r}'$ 是位于一个平面上的源点。设参考三角形是位于平面 $z=0$ 上的一个直角三角形，其顶点为 $(0,0,0)$、$(1,0,0)$ 和 $(0,1,0)$。其形心位于 $\\mathbf{r}_{c} = \\left(\\dfrac{1}{3}, \\dfrac{1}{3}, 0\\right)$。对于一个位于形心上方距离为 $\\delta$ 的观测点 $\\mathbf{r}_{\\text{obs}}(\\delta) = \\left(\\dfrac{1}{3}, \\dfrac{1}{3}, \\delta\\right)$（其中 $\\delta > 0$），将在该三角形上的核函数定义为\n$$\nG(x,y;\\delta) = \\frac{1}{4\\pi\\sqrt{(x - \\tfrac{1}{3})^2 + (y - \\tfrac{1}{3})^2 + \\delta^2}},\n$$\n其中 $(x,y)$ 位于三角形 $\\{(x,y)\\,|\\, x \\ge 0,\\ y \\ge 0,\\ x + y \\le 1\\}$ 内部。\n\n设源权重为与顶点 $(1,0,0)$ 相关联的重心坐标的线性基函数，即 $\\phi(x,y) = x$。我们关注的量是曲面积分\n$$\nI(\\delta) = \\int_{T} \\phi(x,y)\\,G(x,y;\\delta)\\, \\mathrm{d}S = \\int_{0}^{1} \\int_{0}^{1-x} x\\, G(x,y;\\delta)\\,\\mathrm{d}y\\,\\mathrm{d}x,\n$$\n其中 $T$ 表示参考三角形，$\\mathrm{d}S$ 是以 $\\mathrm{m}^2$ 为单位的面元。尽管对于任何 $\\delta > 0$，$I(\\delta)$ 都是有限的，但由于 $G(x,y;\\delta)$ 在 $(x,y) = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}\\right)$ 附近表现出近奇异行为，当 $\\delta$ 很小时，数值计算变得具有挑战性。\n\n一种经典的奇异性提取与相减技术将积分重写为\n$$\nI(\\delta) = \\underbrace{\\int_{T} \\big(\\phi(x,y) - \\phi(\\mathbf{r}_{c})\\big)\\, G(x,y;\\delta)\\, \\mathrm{d}S}_{I_{\\text{rem}}(\\delta)}\\;+\\; \\underbrace{\\phi(\\mathbf{r}_{c}) \\int_{T} G(x,y;\\delta)\\,\\mathrm{d}S}_{I_{\\text{sing}}(\\delta)},\n$$\n其中 $\\phi(\\mathbf{r}_{c}) = \\tfrac{1}{3}$，且 $I_{\\text{rem}}(\\delta)$ 具有更平缓的局部行为，因为 $\\phi(x,y) - \\phi(\\mathbf{r}_{c})$ 在形心处为零，从而降低了被积函数在奇异点附近的峰值剧烈程度。\n\n从格林函数的基本定义和三角形的几何参数化出发，实现并比较两种计算 $I(\\delta)$ 的数值策略：\n- 在 $(x,y)$ 域上使用固定中等阶数 $n$ 的朴素张量积高斯-勒让德求积，直接逼近二重积分 $\\int_{0}^{1} \\int_{0}^{1-x} x\\, G(x,y;\\delta)\\, \\mathrm{d}y\\,\\mathrm{d}x$。\n- 一种基于相减的策略，使用相同的中等求积阶数 $n$ 计算 $I_{\\text{rem}}(\\delta)$，并使用一个极高阶的求积 $n_{\\text{ref}}$ 计算 $I_{\\text{sing}}(\\delta)$，以在实践中模拟解析已知的奇异贡献。\n\n使用一维高斯-勒让德求积来逼近在 $x \\in [0,1]$ 上的积分，以及对于每个 $x$，在 $y \\in [0,1-x]$ 上的积分，并进行正确的仿射映射和权重缩放。你的程序必须：\n- 通过将高阶求积 $n_{\\text{ref}}$ 直接应用于 $I(\\delta)$（不使用相减法），计算一个高精度的参考值 $I_{\\text{ref}}(\\delta)$。\n- 计算朴素方法的绝对误差 $E_{\\text{naive}}(\\delta) = \\big| I_{\\text{naive}}(\\delta) - I_{\\text{ref}}(\\delta) \\big|$。\n- 计算相减方法的绝对误差 $E_{\\text{sub}}(\\delta) = \\big| I_{\\text{sub}}(\\delta) - I_{\\text{ref}}(\\delta) \\big|$。\n- 报告定义为\n$$\n\\Gamma(\\delta) = \\frac{E_{\\text{naive}}(\\delta)}{E_{\\text{sub}}(\\delta)}.\n$$\n的精度增益。\n\n物理单位：将 $\\delta$ 视为米，面积视为平方米，但将最终的精度增益 $\\Gamma(\\delta)$ 报告为无量纲浮点数。\n\n本问题不涉及角度单位。\n\n测试套件：\n- 使用三个 $\\delta$ 值来测试不同的情况：$\\delta_1 = 10^{-1}\\,\\mathrm{m}$，$\\delta_2 = 10^{-3}\\,\\mathrm{m}$ 和 $\\delta_3 = 10^{-5}\\,\\mathrm{m}$。\n- 对朴素积分和余项积分使用中等求积阶数 $n = 24$，对参考值和相减法中的奇异部分使用高阶求积阶数 $n_{\\text{ref}} = 400$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试套件的顺序排列结果，例如 $[\\Gamma(\\delta_1),\\Gamma(\\delta_2),\\Gamma(\\delta_3)]$。输出必须是标准的 Python 浮点数格式。\n\n通过基于上述格林函数定义和正确的求积法则来确保科学真实性。不要使用任何外部数据或捷径；严格按照规定实现求积和相减方法。", "solution": "该问题要求比较两种数值积分策略，用于处理在拉普拉斯方程的边界元法背景下出现的近奇异积分。我们关注的量是在参考三角形 $T$ 上的积分 $I(\\delta) = \\int_{T} \\phi(x,y) G(x,y;\\delta) \\mathrm{d}S$，其中 $G$ 是静态自由空间格林核，$\\phi$ 是线性源权重。当位于三角形形心上方距离 $\\delta$ 处的观测点接近曲面时（即 $\\delta \\to 0$），便产生了近奇异性。我们将比较一种直接、朴素的数值求积方法和一种更复杂的奇异性相减技术。\n\n奇异性相减的核心原理是对被积函数进行正则化。积分 $I(\\delta)$ 被重写为：\n$$\nI(\\delta) = \\int_{T} \\big(\\phi(x,y) - \\phi(\\mathbf{r}_{c})\\big)\\, G(x,y;\\delta)\\, \\mathrm{d}S \\;+\\; \\phi(\\mathbf{r}_{c}) \\int_{T} G(x,y;\\delta)\\,\\mathrm{d}S\n$$\n这将原始积分分解为一个“余项” $I_{\\text{rem}}(\\delta)$ 和一个“奇异项” $I_{\\text{sing}}(\\delta)$。关键的洞见在于源权重函数 $\\phi(x,y)=x$ 是光滑的。通过减去其在形心处的值 $\\phi(\\mathbf{r}_c) = \\phi(1/3, 1/3) = 1/3$，余项被积函数中的新因子 $\\phi(x,y) - \\phi(\\mathbf{r}_c) = x - 1/3$ 在近奇异点位置的 $x$ 坐标处变为零。这种对消显著降低了被积函数的峰值，使得 $I_{\\text{rem}}(\\delta)$ 变得更加光滑，从而更易于用低阶数值求积进行精确近似。奇异行为被分离到 $I_{\\text{sing}}(\\delta)$ 中，该项可以用高精度方法（此处为高阶求积）或在实践中用解析公式来处理。\n\n为了在参考三角形 $T = \\{(x,y)\\,|\\, x \\ge 0,\\, y \\ge 0,\\, x + y \\le 1\\}$ 上执行数值积分，我们将曲面积分表示为累次积分：\n$$\n\\int_{T} f(x,y) \\mathrm{d}S = \\int_{0}^{1} \\left( \\int_{0}^{1-x} f(x,y) \\mathrm{d}y \\right) \\mathrm{d}x\n$$\n我们应用一维高斯-勒让德求积法则的张量积。这需要将标准求积区间 $[-1, 1]$ 映射到外层积分的积分限 $[0, 1]$ 和内层积分的积分限 $[0, 1-x]$。\n\n对于关于 $x$ 的外层积分，从 $\\xi \\in [-1, 1]$ 到 $x \\in [0, 1]$ 的仿射映射是 $x(\\xi) = \\frac{1}{2}(\\xi+1)$，其雅可比为 $\\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{1}{2}$。\n对于关于 $y$ 的内层积分，在 $x$ 固定的情况下，从 $\\eta \\in [-1, 1]$ 到 $y \\in [0, 1-x]$ 的映射是 $y(\\eta) = \\frac{1-x}{2}(\\eta+1)$，其雅可比为 $\\frac{\\mathrm{d}y}{\\mathrm{d}\\eta} = \\frac{1-x}{2}$。\n\n将这些结合起来，每个维度使用 $N$ 点求积的近似公式变为：\n$$\nI \\approx \\sum_{i=1}^{N} \\sum_{j=1}^{N} f(x_i, y_{ij}) \\, w_i w_j \\, \\left(\\frac{1-x_i}{4}\\right)\n$$\n其中 $(\\xi_k, w_k)$（$k=1, \\dots, N$）是 $N$ 点高斯-勒让德节点和权重，求值点为 $x_i = \\frac{1}{2}(\\xi_i+1)$ 和 $y_{ij} = \\frac{1-x_i}{2}(\\eta_j+1)$（使用 $\\eta_j = \\xi_j$）。\n\n计算过程如下：\n1. 通过使用 $n_{\\text{ref}} = 400$ 的高阶求积对原始被积函数 $\\phi(x,y)G(x,y;\\delta)$ 进行积分，计算一个高精度的参考值 $I_{\\text{ref}}(\\delta)$。\n2. 通过使用 $n = 24$ 的中等求积阶数对相同函数进行积分，计算朴素近似值 $I_{\\text{naive}}(\\delta)$。\n3. 基于相减法的近似值 $I_{\\text{sub}}(\\delta)$ 分两部分计算：\n    -   正则部分 $I_{\\text{rem}}(\\delta)$ 通过使用中等阶数 $n=24$ 对正则化后的被积函数 $(\\phi(x,y) - \\phi(\\mathbf{r}_c))G(x,y;\\delta)$ 进行积分来计算。\n    -   奇异部分 $I_{\\text{sing}}(\\delta)$ 通过计算 $\\phi(\\mathbf{r}_c) \\int_T G(x,y;\\delta)\\,\\mathrm{d}S$ 来求得，其中格林函数 $G$ 的积分使用高阶 $n_{\\text{ref}} = 400$ 进行计算。\n    -   最终值为 $I_{\\text{sub}}(\\delta) = I_{\\text{rem}}(\\delta) + I_{\\text{sing}}(\\delta)$。\n4. 对于每个 $\\delta$，计算绝对误差 $E_{\\text{naive}}(\\delta) = |I_{\\text{naive}}(\\delta) - I_{\\text{ref}}(\\delta)|$ 和 $E_{\\text{sub}}(\\delta) = |I_{\\text{sub}}(\\delta) - I_{\\text{ref}}(\\delta)|$。精度增益 $\\Gamma(\\delta) = E_{\\text{naive}}(\\delta) / E_{\\text{sub}}(\\delta)$ 量化了相减方法的有效性。对于相同的计算成本（正则部分的成本），$\\Gamma(\\delta)$ 的值越大，表示精度提升越大。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the accuracy gain of a singularity subtraction technique for a near-singular\n    integral over a triangular domain.\n    \"\"\"\n\n    # Define the test cases and parameters from the problem statement.\n    test_deltas = [1e-1, 1e-3, 1e-5]\n    n_modest = 24\n    n_ref = 400\n    phi_centroid = 1.0 / 3.0\n    xc, yc = 1.0 / 3.0, 1.0 / 3.0\n\n    # Pre-compute Gauss-Legendre nodes and weights to avoid redundant calculations.\n    nodes_modest, weights_modest = roots_legendre(n_modest)\n    nodes_ref, weights_ref = roots_legendre(n_ref)\n\n    def G(x, y, delta):\n        \"\"\"\n        The static free-space Green's kernel for the Laplace equation.\n        G(r, r') = 1 / (4 * pi * ||r - r'||)\n        \"\"\"\n        inv_4pi = 1.0 / (4.0 * np.pi)\n        distance_sq = (x - xc)**2 + (y - yc)**2 + delta**2\n        return inv_4pi / np.sqrt(distance_sq)\n\n    def naive_integrand(x, y, delta):\n        \"\"\"\n        The original integrand: phi(x,y) * G(x,y;delta).\n        phi(x,y) = x\n        \"\"\"\n        return x * G(x, y, delta)\n\n    def rem_integrand(x, y, delta):\n        \"\"\"\n        The remainder integrand after subtraction: (phi(x,y) - phi_c) * G.\n        \"\"\"\n        return (x - phi_centroid) * G(x, y, delta)\n\n    def quad_2d_triangle(func, delta, nodes, weights):\n        \"\"\"\n        Performs 2D Gauss-Legendre quadrature over the reference triangle.\n        The integration is done on a [-1,1] x [-1,1] square and mapped to the triangle.\n        \"\"\"\n        # Create a 2D grid of nodes and weights using broadcasting\n        xi = nodes[:, np.newaxis]\n        eta = nodes[np.newaxis, :]\n        wi = weights[:, np.newaxis]\n        wj = weights[np.newaxis, :]\n\n        # Affine mapping from standard square to triangle\n        x = 0.5 * (xi + 1.0)\n        y = 0.5 * (1.0 - x) * (eta + 1.0)\n\n        # Jacobian of the transformation\n        jacobian = 0.5 * (1.0 - x) * 0.5\n\n        # Evaluate the integrand at all quadrature points\n        integrand_values = func(x, y, delta)\n\n        # Compute the integral by summing weighted values\n        integral = np.sum(wi * wj * integrand_values * jacobian)\n        \n        return integral\n\n\n    results = []\n    for delta in test_deltas:\n        # 1. Compute the high-accuracy reference value using n_ref points.\n        I_ref = quad_2d_triangle(naive_integrand, delta, nodes_ref, weights_ref)\n\n        # 2. Compute the naive approximation using n_modest points.\n        I_naive = quad_2d_triangle(naive_integrand, delta, nodes_modest, weights_modest)\n\n        # 3. Compute the subtraction-based approximation.\n        #    - The remainder term is integrated with the modest order.\n        I_rem = quad_2d_triangle(rem_integrand, delta, nodes_modest, weights_modest)\n        #    - The singular term's integral part is computed with high order.\n        I_G_ref = quad_2d_triangle(G, delta, nodes_ref, weights_ref)\n        I_sing = phi_centroid * I_G_ref\n        \n        I_sub = I_rem + I_sing\n\n        # 4. Compute absolute errors and the accuracy gain.\n        E_naive = np.abs(I_naive - I_ref)\n        E_sub = np.abs(I_sub - I_ref)\n        \n        # Handle the case where the subtraction method is extremely accurate,\n        # to avoid division by a number close to machine epsilon.\n        if E_sub == 0.0:\n            # If the subtraction method error is zero, the gain is effectively infinite.\n            # This can happen due to floating point limitations. We can report a large number\n            # or handle it as a special case. Here, if E_naive is also zero, gain is 1.\n            # Otherwise, gain is large. Since E_naive is not expected to be zero, it's safe to say gain is huge.\n            gamma = np.inf if E_naive > 0.0 else 1.0\n        else:\n            gamma = E_naive / E_sub\n            \n        results.append(gamma)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3348122"}, {"introduction": "在高等计算科学中，我们如何验证复杂算法的正确性？本练习将介绍一种强大的方法：制造解方法 (Method of Manufactured Solutions) [@problem_id:3348130]。你将首先为一个特定的源分布推导出精确的势函数解析解，然后实现一个可变阶数的减除方案并评估其精度，从而验证更高阶的减除如何改善结果，并对照已知真值来校准你的代码。", "problem": "考虑一个由平面圆盘上的光滑、紧支集面源产生的自由空间标量单层势。设该表面为 $z=0$ 平面中一个半径为 $a$、以原点为中心的圆盘。设拉普拉斯方程的自由空间格林函数为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{1}{4\\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}$。设构造的面密度是径向对称且解析的，由 $\\sigma(\\rho) = \\sum_{p=0}^{P} c_p \\,\\rho^{2p}$ 给出，其中 $\\rho = \\sqrt{x'^2+y'^2}$ 是圆盘上的径向坐标，$c_p$ 是实系数，$P$ 是一个非负整数。\n\n目标量是观测点 $\\mathbf{r} = (0,0,0)$ 处的标量势：\n$$\n\\phi = \\int_{S} \\sigma(\\rho) \\, G(\\mathbf{r},\\mathbf{r}') \\, \\mathrm{d}S' \\, ,\n$$\n其中 $S$ 是半径为 $a$ 的圆盘，$\\mathbf{r}' = (x',y',0)$，且 $\\mathrm{d}S' = \\mathrm{d}x'\\mathrm{d}y'$。\n\n在观测点附近，核函数是弱奇异的，因为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{1}{4\\pi \\sqrt{x'^2+y'^2}} = \\dfrac{1}{4\\pi \\rho}$。一个标准的 $L$ 阶奇异性提取与减去技术的步骤是：加上并减去源密度关于奇异点的截断级数展开，对减去的项进行解析积分，而对余项进行数值积分：\n$$\n\\sigma(\\rho) = \\underbrace{\\sum_{p=0}^{L} c_p \\,\\rho^{2p}}_{\\text{subtracted terms}} \\;+\\; \\underbrace{\\left(\\sum_{p=L+1}^{P} c_p \\,\\rho^{2p}\\right)}_{\\text{remainder}} \\, ,\n$$\n从而得到\n$$\n\\phi = \\int_{S} \\frac{\\sigma(\\rho) - \\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S' \\;+\\; \\int_{S} \\frac{\\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S' \\, .\n$$\n随着 $L$ 的增加，第一项通过构造被正则化，从而改善了数值求积的性能；第二项则需使用基本原理以闭式形式进行求值。\n\n仅从自由空间格林函数、极坐标变量替换以及解析函数的基本性质出发，为给定构造源推导原点处势的闭式表达式。然后设计一个数值算法，该算法能够：\n- 实现 $L$ 阶减法策略，并通过张量积高斯-勒让德求积计算余项积分，其中圆盘被表示为 $y$ 的外层积分，而 $x$ 的内层积分限依赖于 $y$。\n- 将解析积分的减去项加回，以构成数值近似解 $\\phi_L$。\n- 对于每个指定的减法阶数 $L$，将绝对误差 $\\varepsilon_L = |\\phi_L - \\phi_{\\text{exact}}|$ 与推导出的闭式解 $\\phi_{\\text{exact}}$ 进行比较评估。\n\n使用以下构造参数，这些参数都是无量纲的：\n- 圆盘半径 $a = 1$。\n- 多项式次数 $P = 3$，系数为 $c_0 = 1.0$, $c_1 = -0.7$, $c_2 = 0.5$, $c_3 = -0.2$。\n\n使用高斯-勒让德求积法对余项进行数值积分，其中外层积分使用 $N_y$ 个节点，内层积分使用 $N_x$ 个节点。为确保科学真实性，请确保节点和权重从 $[-1,1]$ 正确缩放到相应的物理区间。\n\n测试套件和要求的输出：\n- 四个测试用例，分别对应减法阶数 $L \\in \\{0,1,2,3\\}$，并使用相同的求积规模 $N_y = 64$ 和 $N_x = 64$。\n- 对于每个用例，计算绝对误差 $\\varepsilon_L$（作为浮点数）。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。\n\n所有量均无单位。在内部需要时，角度必须以弧度处理。最终的数值答案必须是浮点数。不要打印任何解释性文本；仅按指定格式打印列表。", "solution": "该问题陈述具有科学依据、是适定且客观的。它提供了一套完整且一致的定义、参数和约束，用于推导解析解并实现一个特定的数值验证方案。该问题是计算科学中的一个标准练习，特别是在势论的积分方程方法背景下，涉及使用构造解来测试奇异性减去技术。因此，该问题是有效的。\n\n### 精确势的解析推导\n\n由表面 $S$ 上的面源密度 $\\sigma(\\mathbf{r}')$ 在原点 $\\mathbf{r}=(0,0,0)$ 处产生的标量势 $\\phi$ 由单层势积分给出：\n$$\n\\phi = \\int_{S} \\sigma(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') \\, \\mathrm{d}S'\n$$\n表面 $S$ 是 $z=0$ 平面中一个以原点为中心的半径为 $a$ 的圆盘。观测点为 $\\mathbf{r}=(0,0,0)$，源点为 $\\mathbf{r}'=(x',y',0)$。拉普拉斯方程的自由空间格林函数为 $G(\\mathbf{r},\\mathbf{r}') = \\frac{1}{4\\pi \\|\\mathbf{r}-\\mathbf{r}'\\|}$。在原点处，这简化为 $G((0,0,0), \\mathbf{r}') = \\frac{1}{4\\pi \\|\\mathbf{r}'\\|}$。\n\n在圆盘上，我们使用径向坐标 $\\rho = \\|\\mathbf{r}'\\| = \\sqrt{x'^2+y'^2}$。因此奇异核为 $G = \\frac{1}{4\\pi \\rho}$。源密度由一个径向对称的解析函数 $\\sigma(\\rho) = \\sum_{p=0}^{P} c_p \\,\\rho^{2p}$ 给出。\n\n精确势 $\\phi_{\\text{exact}}$ 的积分为：\n$$\n\\phi_{\\text{exact}} = \\int_{S} \\frac{\\sigma(\\rho)}{4\\pi \\rho} \\, \\mathrm{d}S'\n$$\n由于被积函数和积分域的径向对称性，最自然的方法是使用极坐标计算此积分，其中 $\\mathrm{d}S' = \\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\theta'$。积分限为 $\\rho \\in [0, a]$ 和 $\\theta' \\in [0, 2\\pi]$。\n$$\n\\phi_{\\text{exact}} = \\int_{0}^{2\\pi} \\int_{0}^{a} \\frac{\\sigma(\\rho)}{4\\pi \\rho} (\\rho \\, \\mathrm{d}\\rho \\, \\mathrm{d}\\theta')\n$$\n分母中的 $\\rho$ 与面积元中的 $\\rho$ 相消：\n$$\n\\phi_{\\text{exact}} = \\frac{1}{4\\pi} \\int_{0}^{2\\pi} \\mathrm{d}\\theta' \\int_{0}^{a} \\sigma(\\rho) \\, \\mathrm{d}\\rho\n$$\n对 $\\theta'$ 的积分得到 $2\\pi$。\n$$\n\\phi_{\\text{exact}} = \\frac{2\\pi}{4\\pi} \\int_{0}^{a} \\sigma(\\rho) \\, \\mathrm{d}\\rho = \\frac{1}{2} \\int_{0}^{a} \\sigma(\\rho) \\, \\mathrm{d}\\rho\n$$\n代入 $\\sigma(\\rho)$ 的多项式形式：\n$$\n\\phi_{\\text{exact}} = \\frac{1}{2} \\int_{0}^{a} \\left( \\sum_{p=0}^{P} c_p \\rho^{2p} \\right) \\mathrm{d}\\rho\n$$\n交换有限和与积分：\n$$\n\\phi_{\\text{exact}} = \\frac{1}{2} \\sum_{p=0}^{P} c_p \\int_{0}^{a} \\rho^{2p} \\, \\mathrm{d}\\rho\n$$\n这个基本积分为 $\\int_{0}^{a} \\rho^{2p} \\, \\mathrm{d}\\rho = \\left[ \\frac{\\rho^{2p+1}}{2p+1} \\right]_{0}^{a} = \\frac{a^{2p+1}}{2p+1}$。\n这就得出了原点处精确势的闭式表达式：\n$$\n\\phi_{\\text{exact}} = \\frac{1}{2} \\sum_{p=0}^{P} c_p \\frac{a^{2p+1}}{2p+1}\n$$\n\n### 奇异性减去方案\n\n问题提出了一种 $L$ 阶奇异性减去技术。势被分成两部分：一个包含奇异性且可解析积分的部分，以及一个需要数值积分的正则化余项。\n$$\n\\phi = \\underbrace{\\int_{S} \\frac{\\sigma(\\rho) - \\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S'}_{I_{\\text{rem}}(L)} \\;+\\; \\underbrace{\\int_{S} \\frac{\\sum_{p=0}^{L} c_p \\,\\rho^{2p}}{4\\pi \\rho} \\,\\mathrm{d}S'}_{I_{\\text{sub}}(L)}\n$$\n数值近似为 $\\phi_L = I_{\\text{rem, numerical}}(L) + I_{\\text{sub}}(L)$。\n\n解析项 $I_{\\text{sub}}(L)$ 的形式与精确势积分相同，但求和在 $p=L$ 处被截断。遵循相同的推导过程：\n$$\nI_{\\text{sub}}(L) = \\frac{1}{2} \\sum_{p=0}^{L} c_p \\frac{a^{2p+1}}{2p+1}\n$$\n\n余项积分 $I_{\\text{rem}}(L)$ 的被积函数在原点是正则的。分子为 $\\sigma(\\rho) - \\sum_{p=0}^{L} c_p \\,\\rho^{2p} = \\sum_{p=L+1}^{P} c_p \\,\\rho^{2p}$。因此被积函数为：\n$$\nf_L(\\rho) = \\frac{\\sum_{p=L+1}^{P} c_p \\rho^{2p}}{4\\pi \\rho} = \\frac{1}{4\\pi} \\sum_{p=L+1}^{P} c_p \\rho^{2p-1}\n$$\n此展开式中的首项表现为 $\\rho^{2(L+1)-1} = \\rho^{2L+1}$。对于 $L \\ge 0$，指数 $2L+1$ 为正，确保了当 $\\rho \\to 0$ 时被积函数 $f_L(\\rho)$ 趋于零，因此在整个积分域上是正则的。\n\n### 余项的数值积分\n\n问题指定余项积分 $I_{\\text{rem}}(L) = \\int_S f_L(\\rho) \\, \\mathrm{d}S'$ 必须使用张量积高斯-勒让德求积在笛卡尔坐标下表示的圆盘上进行计算：\n$$\nI_{\\text{rem}}(L) = \\int_{-a}^{a} \\left( \\int_{-\\sqrt{a^2-y'^2}}^{\\sqrt{a^2-y'^2}} f_L(\\sqrt{x'^2+y'^2}) \\, \\mathrm{d}x' \\right) \\mathrm{d}y'\n$$\n我们应用变量替换，将标准的高斯-勒让德区间 $[-1, 1]$ 映射到积分限。\n\n1. **外层积分（关于 $y'$）：** 积分为 $y' \\in [-a, a]$。我们使用线性映射 $\\eta \\in [-1, 1] \\to y'$：\n    $$ y'(\\eta) = a \\eta, \\quad \\mathrm{d}y' = a \\, \\mathrm{d}\\eta $$\n\n2. **内层积分（关于 $x'$）：** 对于一个固定的外层节点 $\\eta_j$（对应于 $y'_j = a \\eta_j$），内层积分限为 $x' \\in [-X_j, X_j]$，其中 $X_j = \\sqrt{a^2 - (y'_j)^2} = a\\sqrt{1-\\eta_j^2}$。我们使用映射 $\\xi \\in [-1, 1] \\to x'$：\n    $$ x'(\\xi) = X_j \\xi, \\quad \\mathrm{d}x' = X_j \\, \\mathrm{d}\\xi $$\n\n该二重积分由一个嵌套求和来近似：\n$$\nI_{\\text{rem}}(L) \\approx \\sum_{j=1}^{N_y} w_j^{(\\eta)} \\left[ a \\left( \\sum_{i=1}^{N_x} w_i^{(\\xi)} f_L(\\rho_{ij}) X_j \\right) \\right]\n$$\n其中 $(\\eta_j, w_j^{(\\eta)})$ 是外层积分的 $N_y$ 个高斯-勒让德节点和权重，$(\\xi_i, w_i^{(\\xi)})$ 是内层积分的 $N_x$ 个节点和权重，而 $\\rho_{ij}$ 是对应于节点对 $(\\xi_i, \\eta_j)$ 的径向位置：\n$$\n\\rho_{ij} = \\sqrt{(x'( \\xi_i))^2 + (y'(\\eta_j))^2} = \\sqrt{(X_j \\xi_i)^2 + (a\\eta_j)^2}\n$$\n完整变换的雅可比行列式是 $a \\cdot X_j = a^2\\sqrt{1-\\eta_j^2}$，它被内层（$X_j$）和外层（$a$）变换各自的雅可比行列式正确地计入了。\n\n### 误差计算\n\n对于每个减法阶数 $L \\in \\{0, 1, 2, 3\\}$，势的数值近似计算为 $\\phi_L = I_{\\text{sub}}(L) + I_{\\text{rem, numerical}}(L)$。然后通过将此近似值与精确解析值进行比较来计算绝对误差：\n$$\n\\varepsilon_L = |\\phi_L - \\phi_{\\text{exact}}|\n$$\n对于 $L=P=3$ 的情况，余项求和 $\\sum_{p=4}^{3}$ 为空，因此 $f_3(\\rho)=0$ 且 $I_{\\text{rem}}(3)=0$。减去项 $I_{\\text{sub}}(3)$ 变得与 $\\phi_{\\text{exact}}$ 完全相同。因此，$\\phi_3 = \\phi_{\\text{exact}}$，误差 $\\varepsilon_3$ 预计在机器精度范围内为零。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Solves the singularity subtraction problem as specified.\n    \n    This function computes the absolute error between an exact analytical potential\n    and a numerical approximation using a singularity subtraction technique. The\n    problem involves a scalar potential on a disk with a manufactured source.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    a = 1.0  # Disk radius\n    P = 3    # Polynomial degree of the source\n    # Source coefficients c_p for p=0, 1, 2, 3\n    c_coeffs = np.array([1.0, -0.7, 0.5, -0.2])\n\n    # --- Numerical Parameters ---\n    Ny = 64  # Number of quadrature nodes for the outer (y) integral\n    Nx = 64  # Number of quadrature nodes for the inner (x) integral\n\n    # --- Test Cases ---\n    L_values = [0, 1, 2, 3]  # Subtraction orders\n\n    def get_exact_potential(radius, p_max, coeffs):\n        \"\"\"\n        Computes the exact potential at the origin in closed form.\n        phi_exact = 0.5 * sum_{p=0 to P} c_p * a^(2p+1) / (2p+1)\n        \"\"\"\n        p_vals = np.arange(p_max + 1)\n        denominators = 2 * p_vals + 1\n        terms = coeffs * (radius**denominators) / denominators\n        return 0.5 * np.sum(terms)\n\n    def get_analytical_subtracted_term(radius, l_order, p_max, coeffs):\n        \"\"\"\n        Computes the analytically integrated subtracted term.\n        I_sub = 0.5 * sum_{p=0 to L} c_p * a^(2p+1) / (2p+1)\n        \"\"\"\n        if l_order < 0:\n            return 0.0\n        # Ensure we don't try to access coeffs beyond its defined length\n        capped_l_order = min(l_order, p_max)\n        p_vals = np.arange(capped_l_order + 1)\n        denominators = 2 * p_vals + 1\n        terms = coeffs[:capped_l_order+1] * (radius**denominators) / denominators\n        return 0.5 * np.sum(terms)\n\n    def remainder_integrand(rho, l_order, p_max, coeffs):\n        \"\"\"\n        Computes the regularized integrand of the remainder term.\n        f_L(rho) = (1 / 4pi) * sum_{p=L+1 to P} c_p * rho^(2p-1)\n        \"\"\"\n        if l_order >= p_max:\n            return np.zeros_like(rho) if hasattr(rho, 'shape') else 0.0\n\n        p_range = np.arange(l_order + 1, p_max + 1)\n        \n        # Use np.atleast_1d to handle both scalar and array inputs for rho\n        rho_arr = np.atleast_1d(rho)\n        \n        # Broadcasting computes rho^(power) for each rho and each power in p_range\n        # rho_arr[:, np.newaxis] has shape (len(rho_arr), 1)\n        # 2 * p_range - 1 has shape (len(p_range),)\n        # powers matrix has shape (len(rho_arr), len(p_range))\n        powers = rho_arr[:, np.newaxis] ** (2 * p_range - 1)\n        \n        # Sum over the p-index (axis=1)\n        integrand_sum = np.sum(coeffs[p_range] * powers, axis=1)\n        \n        result = integrand_sum / (4.0 * np.pi)\n        \n        # Return a scalar if the input was a scalar\n        return result.item() if isinstance(rho, (int, float)) else result\n\n    def get_numerical_remainder_integral(radius, l_order, p_max, coeffs, nx_nodes, ny_nodes):\n        \"\"\"\n        Computes the remainder integral using tensor-product Gauss-Legendre quadrature.\n        \"\"\"\n        xi_nodes, xi_weights = roots_legendre(nx_nodes)\n        eta_nodes, eta_weights = roots_legendre(ny_nodes)\n\n        integral_val = 0.0\n        \n        outer_jacobian = radius\n        \n        # Outer integral over y'\n        for j in range(ny_nodes):\n            eta_j = eta_nodes[j]\n            w_eta_j = eta_weights[j]\n            y_j = radius * eta_j\n            \n            x_max_j = radius * np.sqrt(1.0 - eta_j**2)\n            \n            if x_max_j == 0.0:  # This occurs at the poles (eta = +/- 1)\n                continue\n\n            inner_jacobian = x_max_j\n            \n            # Map inner nodes from [-1, 1] to [-x_max_j, x_max_j]\n            x_nodes = x_max_j * xi_nodes\n            \n            # Calculate radial distance rho at each inner quadrature point\n            rho_vals = np.sqrt(x_nodes**2 + y_j**2)\n            \n            # Evaluate the integrand at all inner points for the current outer point\n            integrand_vals = remainder_integrand(rho_vals, l_order, p_max, coeffs)\n            \n            # Calculate the inner integral via quadrature sum\n            inner_integral = np.sum(xi_weights * integrand_vals) * inner_jacobian\n            \n            # Accumulate the outer integral value\n            integral_val += w_eta_j * inner_integral\n\n        return integral_val * outer_jacobian\n\n    # --- Main Calculation Loop ---\n    \n    phi_exact = get_exact_potential(a, P, c_coeffs)\n    errors = []\n\n    for L in L_values:\n        # Calculate the analytical part of the potential\n        I_sub_analytical = get_analytical_subtracted_term(a, L, P, c_coeffs)\n        \n        # Calculate the remainder integral numerically\n        I_rem_numerical = get_numerical_remainder_integral(a, L, P, c_coeffs, Nx, Ny)\n        \n        # The total numerical approximation for the potential\n        phi_L = I_sub_analytical + I_rem_numerical\n        \n        # Calculate the absolute error\n        error = np.abs(phi_L - phi_exact)\n        errors.append(error)\n        \n    # --- Format and Print Output ---\n    print(f\"[{','.join(map(str, errors))}]\")\n\nsolve()\n```", "id": "3348130"}]}