{"hands_on_practices": [{"introduction": "在许多物理问题中，边界上的条件并非直接给定场的值，而是其法向导数，即所谓的诺伊曼（Neumann）边界条件。本练习将介绍一种通用且直观的处理方法——“虚拟单元法”（ghost cell method）。通过从泰勒级数展开的基础出发，您将推导并实现用于一维标量亥姆霍兹（Helmholtz）和扩散（diffusion）方程的诺伊曼边界条件，为理解更复杂的数值格式奠定坚实的数学和编程基础 ([@problem_id:3305488])。", "problem": "考虑在区间 $\\left[0,L\\right]$ 上的一维标量边值问题，使用包含 $N$ 个区间的均匀网格，网格间距为 $h = L/N$，网格节点为 $x_i = i h$，其中 $i = 0,1,\\dots,N$。主要目标是使用虚拟单元在左边界 $x=0$ 处实现诺伊曼边界条件的施加，并推导出一个等效的二阶精确单侧边界格式，该格式在边界 $\\partial \\Omega$ 处施加法向导数条件 $\\partial_n u = g$。三角函数中的所有角度都必须以弧度为单位进行解释。\n\n您将从以下基本事实出发：\n- 一维标量亥姆霍兹方程为 $u''(x) + k^2 u(x) = s(x)$，其中 $k$ 是给定的波数，$s(x)$ 是已知的源项。\n- 一维标量稳态扩散（泊松）方程（单位传导率）为 $-u''(x) = f(x)$，其中 $f(x)$ 是已知的源项。\n- 对于内部点，二阶导数的二阶精确中心差分近似为 $u''(x_i) \\approx \\left(u_{i-1} - 2 u_i + u_{i+1}\\right)/h^2$。\n- 左边界上的诺伊曼边界条件为 $u'(0) = g$，即对于一维区间，在 $x=0$ 处沿 $-x$ 方向的外法线有 $\\partial_n u = g$，在此情况下等效于 $u'(0) = g$。\n\n任务：\n- 从关于 $x=0$ 的泰勒展开出发，推导一个二阶精确的虚拟单元关系式。当该关系式与亥姆霍兹或扩散算子的标准三点二阶内部格式结合时，可施加 $u'(0) = g$。引入位于 $x=-h$ 的虚拟节点 $u_{-1}$，并推导出 $u_{-1}$ 关于 $u_1$、$g$ 和 $h$ 的关系式，该关系式适用于二阶精确地施加 $u'(0)=g$。\n- 独立地从泰勒展开出发，推导一个用 $u_0$、$u_1$、$u_2$ 和 $h$ 表示的 $u'(0)$ 的二阶精确单侧边界格式，该格式在 $x=0$ 处施加 $u'(0)=g$。\n- 展示虚拟单元关系式如何修改每个算子的最左侧离散方程：\n  - 对于亥姆霍兹算子，在 $i=0$ 处的离散方程中使用 $u_{-1}$ 会得到一个形式为 $a_{00} u_0 + a_{01} u_1 = b_0$ 的修正方程，其中 $a_{00}$、$a_{01}$ 和 $b_0$ 必须用 $h$、$k$、$s(0)$ 和 $g$ 表示。\n  - 对于扩散算子，在 $i=0$ 处的离散方程中使用 $u_{-1}$ 会得到一个形式为 $a_{00} u_0 + a_{01} u_1 = b_0$ 的修正方程，其中 $a_{00}$、$a_{01}$ 和 $b_0$ 必须用 $h$、$f(0)$ 和 $g$ 表示。\n- 实现一个求解器，用于组装和求解具有以下条件的线性系统：\n  - 对于 $i=1,2,\\dots,N-1$，亥姆霍兹或扩散内部算子使用二阶中心差分进行离散。\n  - 在 $i=0$ 处的诺伊曼边界通过上述推导的虚拟单元关系式施加，并将其代入 $i=0$ 处的离散方程。\n  - 在 $x=L$ 处的狄利克雷边界条件通过设置 $u_N = u(L)$ 来施加，使用已知的精确解 $u(x)$ 来定义此边界值。这避免了扩散问题的奇异性，并确保了唯一的离散解。\n\n使用以下参数集测试套件。对于每个测试用例，您必须计算解向量 $\\{u_i\\}_{i=0}^N$ 并报告指定的标量值。\n\n- 测试用例1（亥姆霍兹，理想路径）：$L=1$，$N=64$，$k=3$，精确解 $u(x) = \\cos(2 x) + 0.1 x$，源项由 $s(x) = u''(x) + k^2 u(x)$ 定义，诺伊曼数据 $g = u'(0)$，狄利克雷数据 $u(L)$ 来自精确解。以浮点数形式报告离散 $L^2$ 误差范数 $\\left(\\,h\\sum_{i=0}^N \\left(u_i - u(x_i)\\right)^2\\,\\right)^{1/2}$。\n- 测试用例2（亥姆霍兹，使用粗网格探究离散化）：$L=1$，$N=8$，$k=3$，精确解和源项与测试用例1相同，边界数据相同。报告离散 $L^2$ 误差范数。\n- 测试用例3（扩散，混合边界条件）：$L=1$，$N=64$，精确解 $u(x) = \\sin(\\pi x) + x$，源项由 $f(x) = -u''(x)$ 定义，诺伊曼数据 $g = u'(0)$，狄利克雷数据 $u(L)$ 来自精确解。报告离散 $L^2$ 误差范数。\n- 测试用例4（亥姆霍兹，齐次源项和在 $x=0$ 处的齐次诺伊曼条件）：$L=1$，$N=32$，$k=2$，精确解 $u(x) = \\cos(2 x)$，因此 $s(x) \\equiv 0$，$g = u'(0) = 0$，狄利克雷数据 $u(L)$ 来自精确解。使用推导的二阶单侧格式，根据数值解计算并报告边界导数施加绝对误差 $\\left|\\,(-3 u_0 + 4 u_1 - u_2)/(2 h) - g\\,\\right|$。\n\n实现细节和要求：\n- 使用单一均匀网格，节点为 $x_i = i h$，其中 $i=0,1,\\dots,N$。\n- 对于内部点 $i=1,2,\\dots,N-1$：\n  - 亥姆霍兹方程：将 $u''(x_i) + k^2 u(x_i) = s(x_i)$ 离散为 $\\left(u_{i-1} - 2 u_i + u_{i+1}\\right)/h^2 + k^2 u_i = s(x_i)$。\n  - 扩散方程：将 $-u''(x_i) = f(x_i)$ 离散为 $\\left(-u_{i-1} + 2 u_i - u_{i+1}\\right)/h^2 = f(x_i)$。\n- 在左边界 $i=0$ 处，通过您推导的虚拟单元关系式消除虚拟节点 $u_{-1}$ 并代入 $i=0$ 处的离散算子方程来施加 $u'(0)=g$。\n- 在右边界 $i=N$ 处，精确施加狄利克雷条件 $u_N = u(L)$。\n- 精确计算并报告每个测试指定的标量输出。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"）。\n\n所有输出均为无量纲数。三角函数中的角度必须以弧度为单位进行解释。最终输出必须是浮点数。程序不得要求任何输入，并且必须按原样运行以产生所需的单行输出。", "solution": "用户提供了一个定义明确的计算问题，该问题科学上合理、自洽且客观。该问题是有效的，并且可以按所述方式解决。\n\n该问题要求推导数值格式并实现一个用于一维标量边值问题的有限差分求解器。核心任务是使用虚拟单元法处理诺伊曼边界条件，并根据已知的精确解验证实现。\n\n### 第1部分：虚拟单元关系式的推导\n\n我们的任务是为位于 $x = -h$ 的虚拟节点 $u_{-1}$ 推导一个二阶精确的关系式，以施加诺伊曼条件 $u'(0) = g$。我们使用 $u(x)$ 在 $x=0$ 附近的泰勒级数展开。\n\n$u(x)$ 在 $x=h$（节点 $x_1$）处的展开式为：\n$$u(h) = u(0) + h u'(0) + \\frac{h^2}{2} u''(0) + \\frac{h^3}{6} u'''(0) + \\mathcal{O}(h^4)$$\n离散形式为 $u_1 = u_0 + h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$。\n\n$u(x)$ 在 $x=-h$（虚拟节点 $x_{-1}$）处的展开式为：\n$$u(-h) = u(0) - h u'(0) + \\frac{h^2}{2} u''(0) - \\frac{h^3}{6} u'''(0) + \\mathcal{O}(h^4)$$\n离散形式为 $u_{-1} = u_0 - h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$。\n\n为了获得 $u'(0)$ 的二阶精确近似，我们可以构造一个中心差分。将第二个展开式从第一个中减去，得到：\n$$u(h) - u(-h) = 2h u'(0) + \\frac{h^3}{3} u'''(0) + \\mathcal{O}(h^5)$$\n对 $u'(0)$ 进行整理：\n$$\\frac{u(h) - u(-h)}{2h} = u'(0) + \\frac{h^2}{6} u'''(0) + \\mathcal{O}(h^4)$$\n截断高阶项，得到在 $x=0$ 处一阶导数的二阶精确中心差分近似：\n$$u'(0) \\approx \\frac{u_1 - u_{-1}}{2h}$$\n为了施加诺伊曼条件 $u'(0) = g$，我们设定：\n$$\\frac{u_1 - u_{-1}}{2h} = g$$\n求解虚拟节点值 $u_{-1}$，得到所需的关系式：\n$$u_{-1} = u_1 - 2hg$$\n这个关系式用内部点值 $u_1$ 和指定的导数 $g$ 来表示虚拟节点值 $u_{-1}$，并且具有二阶精度。\n\n### 第2部分：单侧边界格式的推导\n\n作为一项独立检验和用于验证，我们使用网格值 $u_0$、$u_1$ 和 $u_2$ 推导一个 $u'(0)$ 的二阶精确单侧格式。我们寻求系数 $a, b, c$ 使得：\n$$u'(0) \\approx a u_0 + b u_1 + c u_2$$\n我们使用 $u_1 = u(h)$ 和 $u_2 = u(2h)$ 在 $x=0$ 附近的泰勒展开：\n$$u_1 = u(h) = u_0 + h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$$\n$$u_2 = u(2h) = u_0 + 2h u'(0) + \\frac{(2h)^2}{2} u''(0) + \\mathcal{O}(h^3) = u_0 + 2h u'(0) + 2h^2 u''(0) + \\mathcal{O}(h^3)$$\n将这些代入格式形式：\n$$a u_0 + b \\left(u_0 + h u'(0) + \\frac{h^2}{2} u''(0)\\right) + c \\left(u_0 + 2h u'(0) + 2h^2 u''(0)\\right) + \\mathcal{O}(h^3)$$\n$$= (a+b+c)u_0 + (bh + 2ch)u'(0) + \\left(b\\frac{h^2}{2} + c(2h^2)\\right)u''(0) + \\mathcal{O}(h^3)$$\n为了使该表达式成为 $u'(0)$ 的二阶精确近似，系数必须满足：\n1.  $u_0$ 的系数：$a+b+c = 0$\n2.  $u'(0)$ 的系数：$h(b+2c) = 1$\n3.  $u''(0)$ 的系数：$b\\frac{h^2}{2} + 2ch^2 = 0 \\implies b+4c=0$\n\n从 (3) 得，$b = -4c$。代入 (2) 得：$h(-4c+2c)=1 \\implies -2ch=1 \\implies c = -\\frac{1}{2h}$。\n于是，$b = -4c = -4(-\\frac{1}{2h}) = \\frac{2}{h}$。\n从 (1) 得，$a = -b-c = -\\frac{2}{h} - (-\\frac{1}{2h}) = -\\frac{4}{2h} + \\frac{1}{2h} = -\\frac{3}{2h}$。\n得到的格式为：\n$$u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}$$\n这是一阶导数的二阶精确前向差分公式。\n\n### 第3部分：最左侧离散方程的修正\n\n现在我们将虚拟单元关系式 $u_{-1} = u_1 - 2hg$ 代入第一个节点 $i=0$ 处的标准中心差分方程。\n\n**对于亥姆霍兹算子：**\n在 $x_0=0$ 处的离散方程为：\n$$\\frac{u_{-1} - 2u_0 + u_1}{h^2} + k^2 u_0 = s_0$$\n代入 $u_{-1}$：\n$$\\frac{(u_1 - 2hg) - 2u_0 + u_1}{h^2} + k^2 u_0 = s_0$$\n合并同类项：\n$$\\frac{-2u_0 + 2u_1 - 2hg}{h^2} + k^2 u_0 = s_0$$\n整理以匹配形式 $a_{00} u_0 + a_{01} u_1 = b_0$：\n$$\\left(k^2 - \\frac{2}{h^2}\\right) u_0 + \\frac{2}{h^2} u_1 = s_0 + \\frac{2g}{h}$$\n系数为：\n$a_{00} = k^2 - \\frac{2}{h^2}$\n$a_{01} = \\frac{2}{h^2}$\n$b_0 = s(0) + \\frac{2g}{h}$\n\n**对于扩散算子：**\n标准离散形式为 $(-u_{i-1} + 2u_i - u_{i+1})/h^2 = f_i$。在 $x_0=0$ 处：\n$$\\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f_0$$\n代入 $u_{-1}$：\n$$\\frac{-(u_1 - 2hg) + 2u_0 - u_1}{h^2} = f_0$$\n合并同类项：\n$$\\frac{2u_0 - 2u_1 + 2hg}{h^2} = f_0$$\n整理以匹配形式 $a_{00} u_0 + a_{01} u_1 = b_0$：\n$$\\frac{2}{h^2} u_0 - \\frac{2}{h^2} u_1 = f_0 - \\frac{2g}{h}$$\n系数为：\n$a_{00} = \\frac{2}{h^2}$\n$a_{01} = -\\frac{2}{h^2}$\n$b_0 = f(0) - \\frac{2g}{h}$\n\n### 第4部分：系统组装与求解\n\n问题在 $N+1$ 个节点 $x_0, \\dots, x_N$ 上进行离散。未知量为 $u_0, \\dots, u_{N-1}$，形成一个大小为 $N$ 的向量。$u_N$ 由狄利克雷条件给出。这构成一个 $N \\times N$ 的线性系统 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。\n\n矩阵 $A$ 和向量 $\\mathbf{b}$ 的构造如下：\n\n**$i=0$ 的方程（诺伊曼边界条件）：** 如上文推导。\n\n**$i=1, \\dots, N-2$ 的方程（内部）：**\n-   亥姆霍兹方程：$\\frac{1}{h^2} u_{i-1} + \\left(k^2 - \\frac{2}{h^2}\\right) u_i + \\frac{1}{h^2} u_{i+1} = s_i$。\n-   扩散方程：$-\\frac{1}{h^2} u_{i-1} + \\frac{2}{h^2} u_i - \\frac{1}{h^2} u_{i+1} = f_i$。\n这些构成了矩阵 $A$ 的三对角部分。\n\n**$i=N-1$ 的方程（邻近狄利克雷边界条件）：**\n该格式涉及 $u_{N-2}, u_{N-1}, u_N$。由于 $u_N$ 是已知的，其项被移到方程右侧。\n-   亥姆霍兹方程：$\\frac{1}{h^2} u_{N-2} + \\left(k^2 - \\frac{2}{h^2}\\right) u_{N-1} = s_{N-1} - \\frac{u_N}{h^2}$。\n-   扩散方程：$-\\frac{1}{h^2} u_{N-2} + \\frac{2}{h^2} u_{N-1} = f_{N-1} + \\frac{u_N}{h^2}$。\n\n然后求解得到的 $N \\times N$ 系统以获得 $\\mathbf{u}$。完整的数值解是向量 $[u_0, \\dots, u_{N-1}, u_N]$。下面的 Python 实现为指定的测试用例组装并求解此系统。", "answer": "```python\nimport numpy as np\n\ndef build_and_solve_system(params):\n    \"\"\"\n    Builds and solves the finite difference system for 1D BVP.\n    \"\"\"\n    problem_type = params[\"type\"]\n    L = params[\"L\"]\n    N = params[\"N\"]\n    k = params.get(\"k\", 0)\n    u_ex = params[\"u_ex\"]\n    u_prime = params[\"u_prime\"]\n    u_dprime = params[\"u_dprime\"]\n\n    # 1. Grid and parameters\n    h = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    # 2. Source term and boundary conditions from exact solution\n    if problem_type == \"helmholtz\":\n        s = u_dprime(x) + k**2 * u_ex(x)\n    elif problem_type == \"diffusion\":\n        f = -u_dprime(x)\n    else:\n        raise ValueError(\"Unknown problem type\")\n\n    g = u_prime(x[0])\n    u_N_val = u_ex(x[N])\n\n    # 3. Assemble the N x N linear system A*u = b\n    # The unknowns are u_0, u_1, ..., u_{N-1}\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Pre-calculate common coefficients\n    h2_inv = 1 / h**2\n    \n    # Equation for i=0 (Neumann BC at x=0)\n    if problem_type == \"helmholtz\":\n        A[0, 0] = k**2 - 2 * h2_inv\n        A[0, 1] = 2 * h2_inv\n        b[0] = s[0] + 2 * g / h\n    elif problem_type == \"diffusion\":\n        A[0, 0] = 2 * h2_inv\n        A[0, 1] = -2 * h2_inv\n        b[0] = f[0] - 2 * g / h\n\n    # Equations for i = 1 to N-2 (Interior points)\n    for i in range(1, N - 1):\n        if problem_type == \"helmholtz\":\n            A[i, i - 1] = h2_inv\n            A[i, i]     = k**2 - 2 * h2_inv\n            A[i, i + 1] = h2_inv\n            b[i] = s[i]\n        elif problem_type == \"diffusion\":\n            A[i, i - 1] = -h2_inv\n            A[i, i]     = 2 * h2_inv\n            A[i, i + 1] = -h2_inv\n            b[i] = f[i]\n\n    # Equation for i = N-1 (adjacent to Dirichlet BC)\n    if N > 1:\n        i = N - 1\n        if problem_type == \"helmholtz\":\n            A[i, i - 1] = h2_inv\n            A[i, i]     = k**2 - 2 * h2_inv\n            b[i] = s[i] - u_N_val * h2_inv\n        elif problem_type == \"diffusion\":\n            A[i, i - 1] = -h2_inv\n            A[i, i]     = 2 * h2_inv\n            b[i] = f[i] + u_N_val * h2_inv\n\n    # 4. Solve the system and construct the full solution vector\n    u_sol_part = np.linalg.solve(A, b)\n    u_sol = np.zeros(N + 1)\n    u_sol[0:N] = u_sol_part\n    u_sol[N] = u_N_val\n\n    # 5. Compute the required metric\n    report_metric = params[\"report\"]\n    if report_metric == \"l2_error\":\n        u_exact_nodes = u_ex(x)\n        error = u_sol - u_exact_nodes\n        l2_norm = np.sqrt(h * np.sum(error**2))\n        return l2_norm\n    elif report_metric == \"bdy_deriv_error\":\n        u0, u1, u2 = u_sol[0], u_sol[1], u_sol[2]\n        g_numerical = (-3 * u0 + 4 * u1 - u2) / (2 * h)\n        # The specified g is the exact derivative at 0\n        g_exact = g\n        return np.abs(g_numerical - g_exact)\n    else:\n        raise ValueError(\"Unknown report metric\")\n\ndef solve():\n    # Define test case parameters\n    test_cases = [\n        {\n            \"case\": 1, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 64, \"k\": 3.0,\n            \"u_ex\": lambda x: np.cos(2 * x) + 0.1 * x,\n            \"u_prime\": lambda x: -2 * np.sin(2 * x) + 0.1,\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 2, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 8, \"k\": 3.0,\n            \"u_ex\": lambda x: np.cos(2 * x) + 0.1 * x,\n            \"u_prime\": lambda x: -2 * np.sin(2 * x) + 0.1,\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 3, \"type\": \"diffusion\", \"L\": 1.0, \"N\": 64,\n            \"u_ex\": lambda x: np.sin(np.pi * x) + x,\n            \"u_prime\": lambda x: np.pi * np.cos(np.pi * x) + 1,\n            \"u_dprime\": lambda x: -np.pi**2 * np.sin(np.pi * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 4, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 32, \"k\": 2.0,\n            \"u_ex\": lambda x: np.cos(2 * x),\n            \"u_prime\": lambda x: -2 * np.sin(2 * x),\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"bdy_deriv_error\"\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = build_and_solve_system(params)\n        results.append(f\"{result:.16g}\") # Format to avoid scientific notation if small\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3305488"}, {"introduction": "真实的电磁学问题常常涉及混合边界条件，例如在一些导体电极上施加狄利克雷（Dirichlet）条件，而在其他绝缘边界上施加诺伊曼（Neumann）条件。本练习采用守恒的有限体积法（Finite Volume Method），在一个二维静电学模型中精确施加这类混合边界条件。通过计算并验证整个区域边界上的总通量是否为零，您将亲手验证高斯定律的离散形式，深刻理解数值格式的守恒性对于保证物理解的正确性是何等重要 ([@problem_id:3305444])。", "problem": "考虑在无自由电荷情况下的二维静电学，其由散度形式的麦克斯韦方程组所支配：在矩形区域 $\\Omega = [0,L_x]\\times[0,L_y]$ 上的标量电势场 $u(x,y)$ 满足偏微分方程 $\\nabla\\cdot(\\epsilon(x,y)\\nabla u) = 0$ in $\\Omega$，其中 $\\epsilon(x,y)$ 是空间变化的介电常数。狄利克雷边界条件施加在不相交的电极片 $\\Gamma_D \\subset \\partial\\Omega$ 上（指定电势值），而诺伊曼边界条件则施加在其他边界 $\\Gamma_N = \\partial\\Omega \\setminus \\Gamma_D$ 上（指定的法向通量值表示为 $\\epsilon\\,\\partial_n u$）。我们的目标是在离散化和求解器容差范围内，对电中性恒等式进行数值验证，即当使用保守离散化在网格上计算 $u$ 时，边界通量之和为零，也就是说，积分恒等式\n$$\n\\sum_{\\text{Neumann sides}} \\int_{\\Gamma_N} \\epsilon\\,\\partial_n u\\,ds \\;=\\; -\\sum_{\\text{Dirichlet sides}} \\int_{\\Gamma_D} \\epsilon\\,\\partial_n u\\,ds\n$$\n成立。此问题中的所有物理量必须使用国际单位制（SI单位）表示。电势 $u$ 的单位是伏特，介电常数 $\\epsilon$ 的单位是法拉每米，长度单位是米，边界积分 $\\int \\epsilon\\,\\partial_n u\\,ds$ 的单位是库仑每米。\n\n你的任务是编写一个完整的程序，为下面定义的每个测试用例，在矩形网格上构建一个均匀的单元中心有限体积离散化，施加混合边界条件（在给定的电极段上施加狄利克雷条件，在其他地方施加诺伊曼条件），求解得到的线性系统以获得 $u$，然后计算在 $\\Gamma_D$ 和 $\\Gamma_N$ 上的边界积分，以计算残差\n$$\nR \\;=\\; \\left|\\;\\sum_{\\Gamma_N}\\int_{\\Gamma_N}\\epsilon\\,\\partial_n u\\,ds \\;+\\; \\sum_{\\Gamma_D}\\int_{\\Gamma_D}\\epsilon\\,\\partial_n u\\,ds\\;\\right|\n$$\n单位为库仑每米。你的程序必须为每个测试报告单个浮点数 $R$。\n\n基本依据和数值实现要求：\n- 以 $\\nabla\\cdot\\mathbf{D} = 0$（其中 $\\mathbf{D} = -\\epsilon\\nabla u$）和域内无自由电荷作为物理出发点。在此设定下，电势 $u$ 满足 $\\nabla\\cdot(\\epsilon\\nabla u)=0$。\n- 通过在每个控制体积上积分并近似面法向导数，以保守形式离散化算子。在具有 $N_x\\times N_y$ 个尺寸为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$ 的矩形单元的均匀网格上，使用单元中心有限体积法。\n- 在内部面上，使用一致的面介电常数，以保持跨材料跳跃处的法向通量连续性。一个标准选择是每个面上相邻单元介电常数的调和平均值。在与一个单元相邻的边界面上，使用该相邻内部单元的介电常数。\n- 通过消除虚拟值并将面法向电势导数表示为内部单元中心电势和指定边界值的形式，在边界面上施加狄利克雷边界条件。通过将 $\\epsilon\\,\\partial_n u=g(s)$ 指定为有限体积残差中的边界通量项，来施加诺伊曼边界条件，其中 $s$ 是沿该边的弧长坐标。假设平面外方向的厚度为单位厚度。\n- 在求解出 $u$ 后，按如下方式计算边界积分：\n  - 对于每个狄利克雷边界面，将 $\\int_{\\text{face}} \\epsilon\\,\\partial_n u\\,ds$ 近似为 $\\epsilon \\, (u_B - u_C)/d \\times \\ell$，其中 $u_B$ 是该面段上指定的边界电势，$u_C$ 是相邻的内部单元中心电势，$d$ 是从该单元中心到边界沿外法线方向的距离，$\\ell$ 是该面段的长度。\n  - 对于具有指定数据 $g(s)=\\epsilon\\,\\partial_n u$ 的每个诺伊曼边界面，将 $\\int_{\\text{face}} \\epsilon\\,\\partial_n u\\,ds$ 近似为 $g(s_f)\\times \\ell$，其中 $s_f$ 是面中心的弧长坐标，$\\ell$ 是面长。在诺伊曼条件为齐次的地方使用 $g(s)=0$。\n你的实现必须确保离散算子和积分计算之间的数值一致性，以使任何残差 $R$ 仅反映数值误差。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，你必须使用指定的几何形状、材料、网格和边界数据。所有角度都应以弧度处理。\n\n- 测试1（正常情况，均匀介质，除电极外各边绝缘）：\n  - 域：$L_x = 0.01\\,\\text{m}$，$L_y = 0.01\\,\\text{m}$。\n  - 网格：$N_x = 64$，$N_y = 64$。\n  - 介电常数：$\\epsilon(x,y) = \\epsilon_r \\epsilon_0$，其中 $\\epsilon_r = 3.2$，$\\epsilon_0 = 8.854187817\\times 10^{-12}\\,\\text{F/m}$。\n  - 狄利克雷电极：\n    - 顶边，对于 $x\\in[0.3L_x,\\,0.7L_x]$：$u=1.0\\,\\text{V}$。\n    - 底边，对于 $x\\in[0.1L_x,\\,0.2L_x]$：$u=0.0\\,\\text{V}$。\n  - 其他地方为诺伊曼条件：齐次的，即在所有其他边界段上 $g(s)=0$。\n\n- 测试2（非均匀介质，一侧有非零诺伊曼条件）：\n  - 域：$L_x = 0.02\\,\\text{m}$，$L_y = 0.02\\,\\text{m}$。\n  - 网格：$N_x = 60$，$N_y = 60$。\n  - 介电常数：分段的，如果 $x  L_x/2$，则 $\\epsilon(x,y) = \\epsilon_0$；如果 $x \\ge L_x/2$，则 $\\epsilon(x,y) = 4\\epsilon_0$。\n  - 狄利克雷电极：\n    - 左边，对于 $y\\in[0.4L_y,\\,0.7L_y]$：$u=0.0\\,\\text{V}$。\n    - 顶边，对于 $x\\in[0.5L_x,\\,0.9L_x]$：$u=5.0\\,\\text{V}$。\n  - 右边的诺伊曼边界条件：$g(y) = 1.0\\times 10^{-7}\\,\\big(0.5 + 0.5\\sin(2\\pi y/L_y)\\big)\\,\\text{C/m}^2$。\n  - 其他地方为诺伊曼条件：齐次的，即 $g(s)=0$。\n\n- 测试3（角点附近的小电极，顶边为常数诺伊曼条件）：\n  - 域：$L_x = 0.03\\,\\text{m}$，$L_y = 0.015\\,\\text{m}$。\n  - 网格：$N_x = 80$，$N_y = 40$。\n  - 介电常数：$\\epsilon(x,y)=2\\epsilon_0$。\n  - 狄利克雷电极：\n    - 底边，对于 $x\\in[0.0,\\,0.005]$：$u=0.0\\,\\text{V}$。\n    - 右边，对于 $y\\in[0.0,\\,0.004]$：$u=1.0\\,\\text{V}$。\n  - 顶边的诺伊曼边界条件：$g(x) = -5.0\\times 10^{-8}\\,\\text{C/m}^2$（常数）。\n  - 其他地方为诺伊曼条件：齐次的，即 $g(s)=0$。\n\n输出规范：\n- 对于每个测试用例，按上述定义计算残差 $R$，单位为库仑每米。\n- 你的程序应产生一行输出，包含三个残差，以逗号分隔的列表形式并用方括号括起来，顺序为测试1、测试2、测试3。例如：\"[r1,r2,r3]\"。\n- 每个 $r_i$ 必须是浮点数。不应打印其他任何文本。\n\n所有数值步骤和实现选择必须在您提交的程序中实现。不需要用户输入。正确性的标准是，如果边界条件被正确施加且离散化是保守的，则每个残差 $r_i$ 都应该很小（接近于零），其偏差仅由数值近似和求解器容差引起。所有计算出的残差都以库仑每米为单位表示。", "solution": "该问题要求对由 $\\nabla \\cdot (\\epsilon \\nabla u) = 0$ 控制的二维静电系统，进行电中性 $\\oint_{\\partial\\Omega} \\epsilon \\partial_n u \\, ds = 0$ 的数值验证。这是通过使用单元中心有限体积法实现的。该方法的核心在于对每个网格单元（控制体积）上的控制方程进行积分，并应用散度定理。\n\n对于中心为 $(x_i, y_j)$ 的单元 $V_{i,j}$，这会得到：\n$$\n\\int_{V_{i,j}} \\nabla \\cdot (\\epsilon \\nabla u) \\, dV = \\oint_{\\partial V_{i,j}} (\\epsilon \\nabla u) \\cdot \\mathbf{n}_{\\text{cell}} \\, dS = 0\n$$\n其中 $\\mathbf{n}_{\\text{cell}}$ 是从单元边界 $\\partial V_{i,j}$ 指出的外法线。边界积分是单元四个面（东、西、北、南）上通量的总和：\n$$\nF_E + F_W + F_N + F_S = 0\n$$\n每个通量项 $F$ 代表 $\\epsilon \\nabla u$ 的法向分量在一个单元面上的积分。例如，流出东面的通量是 $F_E = \\int_{\\text{east face}} \\epsilon \\frac{\\partial u}{\\partial x} \\, dy$。\n\n**通量的离散化**\n\n通量使用单元中心电势之间的有限差分进行近似。\n对于单元 $(i,j)$ 与其东侧邻居 $(i+1,j)$ 之间的**内部面**，通量近似为：\n$$\nF_E \\approx \\left(\\epsilon_{i+1/2,j} \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x}\\right) \\Delta y\n$$\n这里，$u_{i,j}$ 是单元 $(i,j)$ 中心的电势，而 $\\epsilon_{i+1/2,j}$ 是界面上的介电常数。按照规定，我们使用调和平均值：$\\epsilon_{i+1/2,j} = \\frac{2\\epsilon_{i,j}\\epsilon_{i+1,j}}{\\epsilon_{i,j}+\\epsilon_{i+1,j}}$。这确保了电位移场 $\\mathbf{D}$ 的法向分量在跨材料界面时的连续性。\n\n对于**边界面**，通量近似取决于边界条件。\n1.  **诺伊曼边界条件**：法向通量的值 $g(s) = \\epsilon \\partial_n u$ 是给定的。在长度为 $\\ell$ 的边界面上，流出单元的通量就是 $F_{\\text{bnd}} \\approx g(s_f)\\ell$，其中 $s_f$ 是面中心的坐标。这个值是一个已知的常数，并被移到线性系统的右侧。\n\n2.  **狄利克雷边界条件**：边界上给定了电势 $u_B$。通量使用相邻内部单元的电势 $u_C$ 和边界电势 $u_B$ 进行近似。对于距离单元中心为 $d$ 的一个面，法向导数为 $\\partial_n u \\approx (u_B - u_C)/d$（注意法线的符号）。问题给出了流出区域的通量积分公式：$\\int \\epsilon\\,\\partial_n u\\,ds \\approx \\epsilon_C (u_B-u_C)/d \\times \\ell$。流出单元的通量与此表达式一致。例如，对于单元 $(0,j)$ 的西面，从单元指出的外法线是 $-\\hat{\\mathbf{x}}$，这也是从区域指出的外法线。流出单元的通量是 $F_W = \\int -\\epsilon \\frac{\\partial u}{\\partial x} dy$。使用 $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{0,j}-u_B}{\\Delta x/2}$，通量变为 $F_W \\approx -\\epsilon_{0,j} \\frac{u_{0,j}-u_B}{\\Delta x/2} \\Delta y = \\epsilon_{0,j}\\frac{u_B-u_{0,j}}{\\Delta x/2}\\Delta y$。此项取决于未知的 $u_{0,j}$，并且也为右侧贡献了一个涉及 $u_B$ 的常数项。\n\n**线性系统与守恒性**\n\n为 $N_x \\times N_y$ 网格中的每个单元 $(i,j)$ 建立通量平衡方程，会得到一个包含 $N_x N_y$ 个线性方程的系统，可以写成矩阵形式 $A\\mathbf{u} = \\mathbf{b}$。这里 $\\mathbf{u}$ 是未知单元中心电势的向量，$A$ 是一个稀疏系数矩阵，$\\mathbf{b}$ 是包含边界条件贡献的右端向量。\n\n这种保守有限体积格式的一个关键性质是，如果我们将区域中所有单元的离散通量平衡方程相加，内部面上的通量会完全抵消。这是因为离开一个单元的通量与进入相邻单元的通量大小相同但符号相反。总和简化为：\n$$\n\\sum_{\\text{all boundary faces}} F_{\\text{bnd, out of cell}} = 0\n$$\n其中 $F_{\\text{bnd, out of cell}}$ 是用于构建矩阵系统的离散通量表达式。问题要求计算残差 $R$，它是流出区域边界的总通量的绝对值，该总通量是使用与推导矩阵 $A$ 和向量 $\\mathbf{b}$ 时一致的近似方法计算的。由于守恒性质，对于离散系统的精确解，此和必须为零。任何非零结果仅归因于求解器的数值容差和浮点运算误差。\n\n**实现细节**\n\n对于每个测试用例，解决方案包括以下步骤：\n1.  **网格与材料设置**：定义域的大小、网格分辨率以及每个单元的介电常数 $\\epsilon(x,y)$。\n2.  **矩阵组装**：创建一个稀疏矩阵 $A$ 和一个向量 $\\mathbf{b}$。遍历每个单元 $(i,j)$，并对其四个面中的每一个，根据该面是内部面还是边界面，计算相应的系数并更新 $A$ 和/或 $\\mathbf{b}$。对于诺伊曼边界，通量 $g(s)\\ell$ 从 $\\mathbf{b}$ 的相应条目中减去。对于狄利克雷边界，项被分配到 $A$ 和 $\\mathbf{b}$ 中。\n3.  **求解**：使用 `scipy.sparse.linalg.spsolve` 求解线性系统 $A\\mathbf{u}=\\mathbf{b}$ 以获得电势向量 $\\mathbf{u}$。\n4.  **残差计算**：将总通量累加器初始化为零。遍历所有边界面（左、右、底、顶）。对于每个面，使用规定的数值近似和新计算的电势 $u_{i,j}$ 来计算离开区域的通量。将此通量加到累加器中。最终残差 $R$ 是此和的绝对值。\n对所有三个测试用例重复此过程，以生成所需的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Physical constant\n    EPS0 = 8.854187817e-12  # Permittivity of free space in F/m\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"name\": \"Test 1\",\n            \"Lx\": 0.01, \"Ly\": 0.01, \"Nx\": 64, \"Ny\": 64,\n            \"eps_func\": lambda x, y: 3.2 * EPS0,\n            \"bcs\": [\n                {'side': 'N', 'type': 'D', 'value': 1.0, 'range': (0.3, 0.7)},\n                {'side': 'S', 'type': 'D', 'value': 0.0, 'range': (0.1, 0.2)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        },\n        {\n            \"name\": \"Test 2\",\n            \"Lx\": 0.02, \"Ly\": 0.02, \"Nx\": 60, \"Ny\": 60,\n            \"eps_func\": lambda x, y: EPS0 if x  0.01 else 4 * EPS0,\n            \"bcs\": [\n                {'side': 'W', 'type': 'D', 'value': 0.0, 'range': (0.4, 0.7)},\n                {'side': 'N', 'type': 'D', 'value': 5.0, 'range': (0.5, 0.9)},\n                {'side': 'E', 'type': 'N', 'value': lambda y, Ly: 1.0e-7 * (0.5 + 0.5 * np.sin(2 * np.pi * y / Ly)), 'range': (0.0, 1.0)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        },\n        {\n            \"name\": \"Test 3\",\n            \"Lx\": 0.03, \"Ly\": 0.015, \"Nx\": 80, \"Ny\": 40,\n            \"eps_func\": lambda x, y: 2.0 * EPS0,\n            \"bcs\": [\n                {'side': 'S', 'type': 'D', 'value': 0.0, 'range': (0, 0.005)},\n                {'side': 'E', 'type': 'D', 'value': 1.0, 'range': (0, 0.004)},\n                {'side': 'N', 'type': 'N', 'value': -5.0e-8, 'range': (0.0, 1.0)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = solve_one_case(case)\n        results.append(res)\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef solve_one_case(case_params):\n    \"\"\"\n    Solves a single electrostatic problem using a finite volume method.\n    \"\"\"\n    Lx, Ly = case_params[\"Lx\"], case_params[\"Ly\"]\n    Nx, Ny = case_params[\"Nx\"], case_params[\"Ny\"]\n    eps_func = case_params[\"eps_func\"]\n    \n    dx, dy = Lx / Nx, Ly / Ny\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n    \n    eps_grid = np.zeros((Ny, Nx))\n    for j in range(Ny):\n        for i in range(Nx):\n            eps_grid[j, i] = eps_func(x_centers[i], y_centers[j])\n\n    def get_bc_for_face(side, index):\n        coord = 0.0\n        domain_len = 0.0\n        if side in ['N', 'S']:\n            coord = x_centers[index]\n            domain_len = Lx\n        else:  # 'W', 'E'\n            coord = y_centers[index]\n            domain_len = Ly\n\n        for bc in case_params['bcs']:\n            if bc['side'] == side:\n                is_relative_range = all(0.0 = val = 1.0 for val in bc['range'])\n                start, end = bc['range']\n                \n                if is_relative_range:\n                    start *= domain_len\n                    end   *= domain_len\n\n                if start = coord  end:\n                    return bc['type'], bc['value']\n\n        return case_params['default_bc']['type'], case_params['default_bc']['value']\n\n    N_total = Nx * Ny\n    A = lil_matrix((N_total, N_total))\n    b = np.zeros(N_total)\n\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx\n            \n            # West Face\n            if i > 0:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j, i-1] / (eps_grid[j, i] + eps_grid[j, i-1])\n                c = eps_face * dy / dx\n                A[k, k] -= c\n                A[k, k-1] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('W', j)\n                if bc_type == 'D':\n                    c = eps_grid[j, 0] * dy / (dx / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n                    b[k] -= g * dy\n\n            # East Face\n            if i  Nx - 1:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j, i+1] / (eps_grid[j, i] + eps_grid[j, i+1])\n                c = eps_face * dy / dx\n                A[k, k] -= c\n                A[k, k+1] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('E', j)\n                if bc_type == 'D':\n                    c = eps_grid[j, -1] * dy / (dx / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n                    b[k] -= g * dy\n            \n            # South Face\n            if j > 0:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j-1, i] / (eps_grid[j, i] + eps_grid[j-1, i])\n                c = eps_face * dx / dy\n                A[k, k] -= c\n                A[k, k - Nx] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('S', i)\n                if bc_type == 'D':\n                    c = eps_grid[0, i] * dx / (dy / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n                    b[k] -= g * dx\n            \n            # North Face\n            if j  Ny - 1:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j+1, i] / (eps_grid[j, i] + eps_grid[j+1, i])\n                c = eps_face * dx / dy\n                A[k, k] -= c\n                A[k, k + Nx] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('N', i)\n                if bc_type == 'D':\n                    c = eps_grid[-1, i] * dx / (dy / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n                    b[k] -= g * dx\n    \n    u_vec = spsolve(A.tocsr(), b)\n    u_grid = u_vec.reshape((Ny, Nx))\n\n    total_flux = 0.0\n\n    # West (i=0): n_out = -x_hat, d_n u = -du/dx\n    for j in range(Ny):\n        bc_type, bc_val = get_bc_for_face('W', j)\n        if bc_type == 'D':\n            flux = eps_grid[j, 0] * (bc_val - u_grid[j, 0]) / (dx / 2) * dy\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n            flux = g * dy\n        total_flux += flux\n\n    # East (i=Nx-1): n_out = +x_hat, d_n u = +du/dx\n    for j in range(Ny):\n        bc_type, bc_val = get_bc_for_face('E', j)\n        if bc_type == 'D':\n            flux = eps_grid[j, -1] * (bc_val - u_grid[j, -1]) / (dx / 2) * dy\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n            flux = g * dy\n        total_flux += flux\n\n    # South (j=0): n_out = -y_hat, d_n u = -du/dy\n    for i in range(Nx):\n        bc_type, bc_val = get_bc_for_face('S', i)\n        if bc_type == 'D':\n            flux = eps_grid[0, i] * (bc_val - u_grid[0, i]) / (dy / 2) * dx\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n            flux = g * dx\n        total_flux += flux\n\n    # North (j=Ny-1): n_out = +y_hat, d_n u = +du/dy\n    for i in range(Nx):\n        bc_type, bc_val = get_bc_for_face('N', i)\n        if bc_type == 'D':\n            flux = eps_grid[-1, i] * (bc_val - u_grid[-1, i]) / (dy / 2) * dx\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n            flux = g * dx\n        total_flux += flux\n        \n    return abs(total_flux)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3305444"}, {"introduction": "当计算区域的边界是平滑曲线且不与离散网格对齐时，边界条件的施加就变得极具挑战性。本练习将引导您解决这一高级问题，通过在Yee氏网格上设计并实现一种针对任意曲面边界的二次外插虚拟单元法。您不仅将把诺伊曼条件 $\\partial_n u = g$ 应用于亚单元精度的电介质界面上，还将通过计算离散算子产生的“虚假电荷”（$\\rho_{\\mathrm{sp}} = -\\nabla\\cdot(\\epsilon \\nabla u)$）来量化该方法的精度，这对于评估和改进复杂几何构型的仿真算法至关重要 ([@problem_id:3305487])。", "problem": "您需要设计并实现一种在二维Yee网格上处理静电学问题的鬼点法，该方法通过沿局部界面法线进行二次外插，在亚单元分辨的弯曲界面上施加诺伊曼边界条件，并通过电通量密度的离散散度来量化由此产生的伪电荷。推导必须从静电学第一性原理开始。\n\n静电学的出发点如下。令 $u(x,y)$ 表示标量电势，$\\epsilon(x,y)$ 表示介电常数，$\\mathbf{E} = -\\nabla u$ 表示电场，$\\mathbf{D} = \\epsilon \\mathbf{E}$ 表示电通量密度。静电学中的高斯定律表述为 $\\nabla \\cdot \\mathbf{D} = \\rho$，因此，在无电荷区域，$\\nabla \\cdot (\\epsilon \\nabla u) = 0$。诺伊曼边界条件指定了边界上电势的法向导数：$\\partial_n u = g$，其中 $\\partial_n u = \\nabla u \\cdot \\mathbf{n}$，$\\mathbf{n}$ 是边界的向外单位法向量。\n\n您必须在一个覆盖单位正方形 $[0,1] \\times [0,1]$ 的均匀矩形网格上进行工作，该网格在 $x$ 方向有 $N_x$ 个单元，在 $y$ 方向有 $N_y$ 个单元，单元尺寸为 $\\Delta x = 1/N_x$、$\\Delta y = 1/N_y$，单元中心位于 $(x_i, y_j) = \\big((i+1/2)\\Delta x,(j+1/2)\\Delta y\\big)$，其中整数 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$。您将对离散场算子采用Yee型交错排布：将标量电势 $u_{i,j}$ 存储在单元中心，通过 $u$ 的中心差分计算 $x$ 方向面 $(i+1/2,j)$ 上的 $E_x$，并类似地计算 $y$ 方向面 $(i,j+1/2)$ 上的 $E_y$。然后，通过单元中心的通量差分计算 $\\mathbf{D} = \\epsilon \\mathbf{E}$ 的离散散度。\n\n弯曲界面是一个符号距离类函数 $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$ 的零水平集，该函数表示一个以 $(x_c,y_c)$ 为中心、半径为 $R$ 的圆。将计算区域定义为 $\\Omega = \\{(x,y)\\,:\\,\\phi(x,y) \\ge 0\\}$，即圆的外部。假设在 $\\Omega$ 区域内，介电常数是一个给定的正常数 $\\epsilon$。在界面 $\\Gamma = \\{(x,y)\\,:\\,\\phi(x,y) = 0\\}$ 上，施加诺伊曼条件 $\\partial_n u = g$，其中 $g$ 是从一个光滑的构造解（下文指定）中获取的已知法向导数。进入 $\\Omega$ 的向外单位法向量为 $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$ on $\\Gamma$。\n\n您的任务是实现一个鬼点构造，以提供位于界面另一侧的假想相邻单元中心处的 $u$ 值，从而能够使用 $u$ 的中心差分来计算与界面切割单元相邻的Yee网格面上的电场。对于 $\\Omega$ 中某个单元的任意一个面，如果其相邻单元位于 $\\{ \\phi  0 \\}$ 内，则需要通过沿局部界面法线拟合一个二次函数分布来计算相邻单元中心的鬼点值 $u_g$。用法线方向上的直线进行参数化，设参数为 $s$，在界面处 $s=0$，指向 $\\Omega$ 内部的方向为 $s>0$。用 $s_0$ 表示从界面点沿法线到内部单元中心的有向距离，并定义两个额外的内部采样点，位置在 $s_1 = s_0 + h_n$ 和 $s_2 = s_0 + 2 h_n$ 处，其中 $h_n = \\min(\\Delta x,\\Delta y)$。拟合一个二次函数 $p(s) = a s^2 + b s + c$ 满足：\n- $p'(0) = b = g$（界面上的诺伊曼条件），\n- $p(s_1) = u(s_1)$，\n- $p(s_2) = u(s_2)$，\n然后通过二次外插到界面另一侧的镜像位置来定义鬼点值，$u_g = p(-s_0)$。$u(s_1)$ 和 $u(s_2)$ 的值应取自下面指定的光滑构造解，在物理坐标 $(x,y) = (x_I,y_I) + s\\,\\mathbf{n}$ 处求值，其中 $(x_I,y_I)$ 是连接内部单元中心及其跨界面邻居的线段上的界面点，而 $\\mathbf{n}$ 是在 $(x_I,y_I)$ 处的界面法向量。\n\n为了使问题完全确定且无需解全局线性系统即可测试，请使用构造的谐波势\n$$u_{\\mathrm{ex}}(x,y) = x^2 - y^2,$$\n对于此解，精确电场为 $\\mathbf{E}_{\\mathrm{ex}} = -\\nabla u_{\\mathrm{ex}} = (-2x, 2y)$，精确法向导数为 $g = \\partial_n u_{\\mathrm{ex}} = \\nabla u_{\\mathrm{ex}} \\cdot \\mathbf{n} = (2x,-2y)\\cdot \\mathbf{n}$ on the interface，并且连续介质的无电荷条件 $\\nabla\\cdot(\\epsilon \\nabla u_{\\mathrm{ex}}) = \\epsilon \\nabla^2 u_{\\mathrm{ex}} = 0$ 成立。将内部单元的值设为 $u_{i,j} = u_{\\mathrm{ex}}(x_i,y_j)$，适用于 $\\Omega$ 中所有单元中心（即满足 $\\phi(x_i,y_j) \\ge 0$ 的单元）。然后，对于计算界面附近带状区域内离散散度所需的每个内部单元面，通过上述二次法向过程在跨界面的相邻单元中心构造鬼点值，使用真实相邻值（如果两个单元中心都在 $\\Omega$ 内）或鬼点值（如果相邻单元跨越界面）通过中心差分计算Yee网格面上的电场，在面上形成 $\\mathbf{D}$ 为 $\\epsilon \\mathbf{E}$，并按以下公式计算单元中心 $(i,j)$ 的离散散度：\n$$\n(\\nabla\\cdot \\mathbf{D})_{i,j}\n=\n\\frac{D_x|_{i+1/2,j} - D_x|_{i-1/2,j}}{\\Delta x}\n+\n\\frac{D_y|_{i,j+1/2} - D_y|_{i,j-1/2}}{\\Delta y}.\n$$\n将伪电荷密度定义为\n$$\n\\rho_{\\mathrm{sp}} = -\\nabla\\cdot(\\epsilon \\nabla u),\n$$\n按上述方式进行离散计算。由于 $u_{\\mathrm{ex}}$ 是谐波函数且 $\\epsilon$ 是常数，精确的连续介质电荷密度为零，因此非零值完全由离散化和边界强制引起。在一个邻近界面且厚度为一个单元的带状区域内量化伪电荷，该区域由满足 $0 \\le \\phi(x_i,y_j) \\le 3\\min(\\Delta x,\\Delta y)$ 的单元中心集合给出。对于此带状区域，报告：\n- 均方根值 $\\sqrt{\\frac{1}{N_b}\\sum \\rho_{\\mathrm{sp}}^2}$，计算范围为带状区域内的所有单元，其中 $N_b$ 是带状区域内的单元数。\n- 最大绝对值 $\\max |\\rho_{\\mathrm{sp}}|$，计算范围为带状区域内的所有单元。\n\n单位：此问题已无量纲化；所有量均无单位。\n\n您的程序必须实现上述方案，并为以下四个测试用例（每个用例定义了网格、圆心和半径以及介电常数）生成所要求的指标：\n\n- 用例 A（一般情况）：$N_x=64$，$N_y=64$，$(x_c,y_c) = (0.5,0.5)$，$R=0.30$，$\\epsilon=2.0$。\n- 用例 B（小半径界面）：$N_x=64$，$N_y=64$，$(x_c,y_c) = (0.5,0.5)$，$R=0.12$，$\\epsilon=5.0$。\n- 用例 C（较粗网格）：$N_x=32$，$N_y=40$，$(x_c,y_c) = (0.5,0.5)$，$R=0.30$，$\\epsilon=3.0$。\n- 用例 D（偏移界面）：$N_x=80$，$N_y=60$，$(x_c,y_c) = (0.42,0.47)$，$R=0.35$，$\\epsilon=1.0$。\n\n您的程序应生成单行输出，包含八个结果，形式为用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\mathrm{RMS}_A,\\mathrm{MAX}_A,\\mathrm{RMS}_B,\\mathrm{MAX}_B,\\mathrm{RMS}_C,\\mathrm{MAX}_C,\\mathrm{RMS}_D,\\mathrm{MAX}_D],\n$$\n每个浮点数以定点表示法打印，并四舍五入到 $8$ 位小数。不应打印任何额外文本。", "solution": "用户要求设计并实现一种数值方法，用于量化在弯曲界面上施加诺伊曼边界条件所产生的伪电荷。该方法基于二维Yee网格上的鬼点法，并结合了二次外插，用于解决静电学问题。该问题定义明确，科学上合理，并提供了所有必要的信息，包括用于测试的构造解、特定的边界处理算法以及清晰的评估指标。因此，该问题被认为是有效的。\n\n以下是已实现解决方案的逐步推导和解释。\n\n### 1. 问题建模与离散化\n\n控制方程是无电荷区域中的静电学高斯定律，即 $\\nabla \\cdot \\mathbf{D} = 0$，其中 $\\mathbf{D} = \\epsilon \\mathbf{E}$ 是电通量密度，$\\mathbf{E} = -\\nabla u$ 是由标量电势 $u$ 导出的电场。这得到了偏微分方程 $\\nabla \\cdot (\\epsilon \\nabla u) = 0$。\n\n计算域为单位正方形 $[0,1] \\times [0,1]$，通过一个 $N_x \\times N_y$ 的均匀网格进行离散化，单元尺寸为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。采用了Yee网格上的标准类有限体积离散化方法：\n- 标量电势 $u_{i,j}$ 位于单元中心 $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$。\n- 电场分量位于单元的面上。位于单元 $(i,j)$ 和 $(i+1,j)$ 之间面上的 $x$ 分量 $E_x$ 计算如下：\n  $$ E_x|_{i+1/2,j} = - \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x} $$\n- 类似地，位于单元 $(i,j)$ 和 $(i,j+1)$ 之间面上的 $y$ 分量 $E_y$ 为：\n  $$ E_y|_{i,j+1/2} = - \\frac{u_{i,j+1} - u_{i,j}}{\\Delta y} $$\n电通量密度分量为 $D_x = \\epsilon E_x$ 和 $D_y = \\epsilon E_y$。散度在单元中心 $(i,j)$ 处使用通量的中心差分计算：\n$$ (\\nabla \\cdot \\mathbf{D})_{i,j} = \\frac{D_x|_{i+1/2,j} - D_x|_{i-1/2,j}}{\\Delta x} + \\frac{D_y|_{i,j+1/2} - D_y|_{i,j-1/2}}{\\Delta y} $$\n伪电荷密度定义为 $\\rho_{\\mathrm{sp}} = -\\nabla \\cdot (\\epsilon \\nabla u)$。由于 $\\mathbf{D} = \\epsilon \\mathbf{E} = -\\epsilon\\nabla u$，我们有 $\\nabla \\cdot \\mathbf{D} = -\\nabla \\cdot (\\epsilon\\nabla u)$。因此，单元中心的离散伪电荷密度等于 $\\mathbf{D}$ 的离散散度：\n$$ \\rho_{\\mathrm{sp}}|_{i,j} = (\\nabla \\cdot \\mathbf{D})_{i,j} $$\n\n### 2. 界面与边界条件\n\n圆形界面由函数 $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$ 的零水平集定义。计算域 $\\Omega$ 是圆的外部，其中 $\\phi(x,y) \\ge 0$。在界面上，施加诺伊曼条件 $\\partial_n u = g$，其中 $\\mathbf{n}$ 是从圆向外的法向量。该问题使用构造解 $u_{\\mathrm{ex}}(x,y) = x^2 - y^2$ 进行测试。任何内部单元中心 $(x_i,y_j)$ 的电势都简单地设为 $u_{\\mathrm{ex}}(x_i,y_j)$。函数 $g$ 从这个精确解导出，为 $g = \\nabla u_{\\mathrm{ex}} \\cdot \\mathbf{n}$。\n\n### 3. 采用二次外插的鬼点法\n\n当计算跨越一个内部单元（在 $\\Omega$ 内）和一个外部或“鬼”单元（在 $\\Omega$ 外）之间的面的通量时，需要鬼单元中心的电势。这个值 $u_g$ 是通过鬼点法构造的。对于一个分隔内部单元（位于 $\\mathbf{x}_{\\text{int}}$）和鬼单元（位于 $\\mathbf{x}_{\\text{ghost}}$）的面，其过程如下：\n\n1.  **寻找界面点**：确定线段 $[\\mathbf{x}_{\\text{int}}, \\mathbf{x}_{\\text{ghost}}]$ 与界面 $\\phi=0$ 相交的点 $\\mathbf{x}_I$。这需要解一个关于交点参数的二次方程。\n2.  **确定局部几何**：在 $\\mathbf{x}_I$ 处，计算界面法向量 $\\mathbf{n} = (\\mathbf{x}_I - \\mathbf{x}_c)/R$。沿此法线从 $\\mathbf{x}_I$ 到 $\\mathbf{x}_{\\text{int}}$ 的距离计算为 $s_0 = (\\mathbf{x}_{\\text{int}} - \\mathbf{x}_I) \\cdot \\mathbf{n}$。\n3.  **构造二次剖面**：沿法线构造一个一维二次多项式 $p(s) = as^2+bs+c$，其中 $s$ 是距界面的距离。系数由三个条件确定：\n    a. 界面处的导数与诺伊曼条件匹配：$p'(0) = b = g = \\nabla u_{\\mathrm{ex}}(\\mathbf{x}_I) \\cdot \\mathbf{n}$。\n    b. 剖面在两个内部采样点处与已知解匹配。这些点沿法线方向距界面分别为 $s_1 = s_0 + h_n$ 和 $s_2 = s_0 + 2h_n$，其中 $h_n = \\min(\\Delta x, \\Delta y)$。条件是 $p(s_1) = u_{\\mathrm{ex}}(\\mathbf{x}_I+s_1\\mathbf{n})$ 和 $p(s_2) = u_{\\mathrm{ex}}(\\mathbf{x}_I+s_2\\mathbf{n})$。\n    这三个条件构成一个关于系数 $(a, b, c)$ 的唯一可解的线性系统。\n4.  **外插鬼点值**：通过在镜像距离 $s = -s_0$ 处计算二次剖面的值来获得鬼点电势 $u_g$：\n    $$ u_g = p(-s_0) = a(-s_0)^2 + b(-s_0) + c = as_0^2 - bs_0 + c $$\n    然后，这个值 $u_g$ 被用于面电场的有限差分公式中。\n\n### 4. 伪电荷计算\n\n该算法首先识别界面附近的一个单元带，特别是那些中心 $(x_i,y_j)$ 满足 $0 \\le \\phi(x_i,y_j) \\le 3\\min(\\Delta x, \\Delta y)$ 的单元。对于该带中的每个单元，计算四个通量（在 $x_{i\\pm1/2}$ 处的 $D_x$ 和在 $y_{j\\pm1/2}$ 处的 $D_y$）。如果一个面位于两个内部单元之间，则使用标准的有限差分。如果它是一个切割界面的面，则通过鬼点法程序提供必要的电势值。最后，在单元中心计算 $\\mathbf{D}$ 的离散散度，得到伪电荷密度 $\\rho_{\\mathrm{sp}}$。然后，计算该带内所有单元的 $\\rho_{\\mathrm{sp}}$ 的均方根值和最大绝对值。对四个测试用例中的每一个重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ElectrostaticsSolver:\n    \"\"\"\n    Implements a ghost-cell method on a 2D Yee grid for electrostatics\n    to enforce a Neumann boundary condition on a subcell-resolved curved interface.\n    \"\"\"\n\n    def __init__(self, Nx, Ny, xc, yc, R, eps):\n        # Store parameters\n        self.Nx, self.Ny = Nx, Ny\n        self.xc, self.yc, self.R, self.eps = float(xc), float(yc), float(R), float(eps)\n\n        # Grid setup\n        self.dx, self.dy = 1.0 / Nx, 1.0 / Ny\n        self.hn = min(self.dx, self.dy)\n        \n        # Cell center coordinates\n        i_coords = np.arange(Nx)\n        j_coords = np.arange(Ny)\n        self.x_centers = (i_coords + 0.5) * self.dx\n        self.y_centers = (j_coords + 0.5) * self.dy\n        \n        # Grid of cell-centered coordinates\n        self.xx, self.yy = np.meshgrid(self.x_centers, self.y_centers, indexing='ij')\n\n        # Identify interior/exterior cells based on phi at cell centers\n        self.phi_vals = self._phi(self.xx, self.yy)\n        self.is_interior = self.phi_vals >= 0\n\n    def _u_ex(self, x, y):\n        \"\"\"Manufactured potential solution.\"\"\"\n        return x**2 - y**2\n\n    def _grad_u_ex(self, x, y):\n        \"\"\"Gradient of the manufactured potential.\"\"\"\n        return np.array([2 * x, -2 * y])\n\n    def _phi(self, x, y):\n        \"\"\"Signed distance function for the circular interface.\"\"\"\n        return np.sqrt((x - self.xc)**2 + (y - self.yc)**2) - self.R\n\n    def _compute_ghost_value(self, p_int, p_ghost):\n        \"\"\"\n        Computes the ghost potential value using quadratic extrapolation along the normal.\n        p_int: Coordinates of the interior cell center.\n        p_ghost: Coordinates of the ghost cell center.\n        \"\"\"\n        v = p_ghost - p_int\n        p1c = p_int - np.array([self.xc, self.yc])\n        \n        A = np.dot(v, v)\n        B = 2 * np.dot(p1c, v)\n        C = np.dot(p1c, p1c) - self.R**2\n        \n        discriminant = B**2 - 4 * A * C\n        if discriminant  0:\n            discriminant = 0\n            \n        t = (-B - np.sqrt(discriminant)) / (2 * A)\n        \n        p_I = p_int + t * v\n        \n        n_vec = p_I - np.array([self.xc, self.yc])\n        norm_n = np.linalg.norm(n_vec)\n        n = n_vec / norm_n if norm_n > 0 else np.array([1.0, 0.0])\n\n        s0 = np.dot(p_int - p_I, n)\n        if s0  0:\n            s0 = 0\n            \n        g = np.dot(self._grad_u_ex(p_I[0], p_I[1]), n)\n        \n        s1 = s0 + self.hn\n        s2 = s0 + 2 * self.hn\n        \n        p1_sample = p_I + s1 * n\n        p2_sample = p_I + s2 * n\n        \n        u1_sample = self._u_ex(p1_sample[0], p1_sample[1])\n        u2_sample = self._u_ex(p2_sample[0], p2_sample[1])\n        \n        b = g\n        denom = self.hn * (2 * s0 + 3 * self.hn)\n        a = (u2_sample - u1_sample - b * self.hn) / denom\n        c = u1_sample - a * s1**2 - b * s1\n        \n        u_g = a * (-s0)**2 + b * (-s0) + c\n        return u_g\n\n    def _get_Dx(self, i, j):\n        \"\"\"Computes D_x at the face between cells (i,j) and (i+1,j).\"\"\"\n        if not (0 = i  self.Nx - 1 and 0 = j  self.Ny):\n            return 0.0\n\n        is_p1_int = self.is_interior[i, j]\n        is_p2_int = self.is_interior[i + 1, j]\n        \n        Ex = 0.0\n        if is_p1_int and is_p2_int:\n            u1 = self._u_ex(self.x_centers[i], self.y_centers[j])\n            u2 = self._u_ex(self.x_centers[i+1], self.y_centers[j])\n            Ex = -(u2 - u1) / self.dx\n        elif is_p1_int and not is_p2_int:\n            p_int = np.array([self.x_centers[i], self.y_centers[j]])\n            p_ghost = np.array([self.x_centers[i+1], self.y_centers[j]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u1 = self._u_ex(p_int[0], p_int[1])\n            Ex = -(u_g - u1) / self.dx\n        elif not is_p1_int and is_p2_int:\n            p_int = np.array([self.x_centers[i+1], self.y_centers[j]])\n            p_ghost = np.array([self.x_centers[i], self.y_centers[j]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u2 = self._u_ex(p_int[0], p_int[1])\n            Ex = -(u2 - u_g) / self.dx\n        \n        return self.eps * Ex\n\n    def _get_Dy(self, i, j):\n        \"\"\"Computes D_y at the face between cells (i,j) and (i,j+1).\"\"\"\n        if not (0 = i  self.Nx and 0 = j  self.Ny - 1):\n            return 0.0\n\n        is_p1_int = self.is_interior[i, j]\n        is_p2_int = self.is_interior[i, j + 1]\n\n        Ey = 0.0\n        if is_p1_int and is_p2_int:\n            u1 = self._u_ex(self.x_centers[i], self.y_centers[j])\n            u2 = self._u_ex(self.x_centers[i], self.y_centers[j+1])\n            Ey = -(u2 - u1) / self.dy\n        elif is_p1_int and not is_p2_int:\n            p_int = np.array([self.x_centers[i], self.y_centers[j]])\n            p_ghost = np.array([self.x_centers[i], self.y_centers[j+1]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u1 = self._u_ex(p_int[0], p_int[1])\n            Ey = -(u_g - u1) / self.dy\n        elif not is_p1_int and is_p2_int:\n            p_int = np.array([self.x_centers[i], self.y_centers[j+1]])\n            p_ghost = np.array([self.x_centers[i], self.y_centers[j]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u2 = self._u_ex(p_int[0], p_int[1])\n            Ey = -(u2 - u_g) / self.dy\n\n        return self.eps * Ey\n\n    def compute_metrics(self):\n        \"\"\"\n        Computes the spurious charge density and its RMS and MAX metrics\n        in the specified band near the interface.\n        \"\"\"\n        band_mask = (self.phi_vals >= 0)  (self.phi_vals = 3 * self.hn)\n        band_indices = np.where(band_mask)\n        \n        if band_indices[0].size == 0:\n            return 0.0, 0.0\n            \n        spurious_charges = []\n        for i, j in zip(*band_indices):\n            Dx_plus = self._get_Dx(i, j)\n            Dx_minus = self._get_Dx(i - 1, j)\n            Dy_plus = self._get_Dy(i, j)\n            Dy_minus = self._get_Dy(i, j - 1)\n            \n            # rho_sp = -div(eps grad u) = div(-eps grad u) = div(eps E) = div(D)\n            div_D = (Dx_plus - Dx_minus) / self.dx + (Dy_plus - Dy_minus) / self.dy\n            spurious_charges.append(div_D)\n        \n        charges_arr = np.array(spurious_charges)\n        \n        rms = np.sqrt(np.mean(charges_arr**2))\n        max_abs = np.max(np.abs(charges_arr))\n        \n        return rms, max_abs\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, xc, yc, R, eps)\n        (64, 64, 0.5, 0.5, 0.30, 2.0),  # Case A\n        (64, 64, 0.5, 0.5, 0.12, 5.0),  # Case B\n        (32, 40, 0.5, 0.5, 0.30, 3.0),  # Case C\n        (80, 60, 0.42, 0.47, 0.35, 1.0), # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        solver = ElectrostaticsSolver(*params)\n        rms, max_abs = solver.compute_metrics()\n        results.append(f\"{rms:.8f}\")\n        results.append(f\"{max_abs:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3305487"}]}