{"hands_on_practices": [{"introduction": "本节的第一个练习是一个基础热身。它将引导你直接应用等参映射公式，来寻找参考单元中的一个点在物理空间中的对应坐标。通过这个实践[@problem_id:3320941]，你将巩固对形函数和节点坐标在定义高阶单元几何形状中所扮演角色的理解。", "problem": "考虑一个用于计算电磁学中求解光滑导电边界附近 Maxwell 方程组的弯曲二次等参四面体单元。从具有局部坐标 $(\\xi,\\eta,\\zeta)$ 的参考四面体到物理空间的等参映射由使用节点形函数的 Lagrange 插值定义。设重心坐标为 $L_1 = \\xi$，$L_2 = \\eta$，$L_3 = \\zeta$，以及 $L_4 = 1 - \\xi - \\eta - \\zeta$，并设二次四面体形函数为标准的 $10$ 节点 Lagrange 多项式：\n$$\nN_1 = L_1(2L_1 - 1),\\quad\nN_2 = L_2(2L_2 - 1),\\quad\nN_3 = L_3(2L_3 - 1),\\quad\nN_4 = L_4(2L_4 - 1),\n$$\n$$\nN_5 = 4L_1L_2,\\quad\nN_6 = 4L_2L_3,\\quad\nN_7 = 4L_3L_1,\\quad\nN_8 = 4L_1L_4,\\quad\nN_9 = 4L_2L_4,\\quad\nN_{10} = 4L_3L_4.\n$$\n物理坐标映射为\n$$\n\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i,\n$$\n其中 $\\{\\mathbf{x}_i\\}_{i=1}^{10}$ 是弯曲单元的物理节点坐标。顶点坐标为\n$$\n\\mathbf{x}_1 = (0,0,0)\\,\\text{米},\\quad\n\\mathbf{x}_2 = (1,0,0)\\,\\text{米},\\quad\n\\mathbf{x}_3 = (0,1,0)\\,\\text{米},\\quad\n\\mathbf{x}_4 = (0,0,1)\\,\\text{米},\n$$\n边中点节点坐标为\n$$\n\\mathbf{x}_5 = \\left(\\frac{1}{2},0,\\frac{1}{8}\\right)\\,\\text{米},\\quad\n\\mathbf{x}_6 = \\left(\\frac{1}{2},\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{米},\\quad\n\\mathbf{x}_7 = \\left(0,\\frac{1}{2},\\frac{1}{8}\\right)\\,\\text{米},\n$$\n$$\n\\mathbf{x}_8 = \\left(0,0,\\frac{1}{2}\\right)\\,\\text{米},\\quad\n\\mathbf{x}_9 = \\left(\\frac{1}{2},0,\\frac{1}{2}\\right)\\,\\text{米},\\quad\n\\mathbf{x}_{10} = \\left(0,\\frac{1}{2},\\frac{1}{2}\\right)\\,\\text{米}.\n$$\n在面 $1$-$2$-$3$ 上的这些边中点节点位置代表了一个光滑的向外凸起（弯曲边界），而连接到节点 $4$ 的边则保持为直线。\n\n计算在参数点 $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$ 处的物理坐标向量 $\\mathbf{x}$。将 $\\mathbf{x}$ 的三个分量以米为单位表示。使用精确值；无需四舍五入。然后，从边界曲率保真度的角度解释结果，并与在相同参数点使用线性（$4$ 节点）四面体映射所得到的结果进行定性比较。", "solution": "该问题要求在一个二次等参四面体单元内，计算特定局部参数点 $(\\xi,\\eta,\\zeta)$ 处的物理坐标 $\\mathbf{x} = (x,y,z)$，并随后进行定性分析，将结果与线性单元近似进行比较。\n\n### 步骤1：问题验证\n问题陈述为等参映射计算提供了一套完整且一致的已知条件。\n- **已知条件**：\n    - 局部坐标： $(\\xi, \\eta, \\zeta)$。\n    - 重心坐标： $L_1 = \\xi$，$L_2 = \\eta$，$L_3 = \\zeta$，$L_4 = 1 - \\xi - \\eta - \\zeta$。\n    - 二次形函数 $N_i$，其中 $i=1, \\dots, 10$。\n    - 等参映射公式： $\\mathbf{x}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{10} N_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i$。\n    - 节点坐标 $\\{\\mathbf{x}_i\\}_{i=1}^{10}$。\n    - 用于评估的参数点： $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$。\n- **验证**：\n    - 该问题在有限元法 (FEM) 中有**科学依据**，这是计算科学与工程中一种标准且成熟的数值技术。\n    - 所提供的形函数是二次四面体的标准 10 节点 Lagrange 多项式。\n    - 节点坐标定义明确，创建了一个特定的弯曲几何形状。对于面 $1-2-3$（位于平面 $z=0$ 上），其边中点节点在 $z = 1/8 > 0$ 处，将其描述为“向外凸起”略有误述；它实际上描述了一个向四面体体积*内部*的凸起（假设内部是 $L_4 > 0$ 的区域）。然而，这种轻微的描述不准确性不影响该设置的数学有效性，因为节点坐标明确地定义了几何形状。\n    - 该问题是**适定的**：所有必要信息都已提供，并且任务导向一个唯一且有意义的解。\n    - 语言**客观**且精确。\n\n- **结论**：该问题有效。\n\n### 步骤2：物理坐标的计算\n\n第一步是计算在给定参数点 $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$ 处的重心坐标 $L_i$。\n$$\nL_1 = \\xi = \\frac{1}{4}\n$$\n$$\nL_2 = \\eta = \\frac{1}{4}\n$$\n$$\nL_3 = \\zeta = \\frac{1}{4}\n$$\n$$\nL_4 = 1 - \\xi - \\eta - \\zeta = 1 - \\frac{1}{4} - \\frac{1}{4} - \\frac{1}{4} = \\frac{1}{4}\n$$\n该评估点是参考四面体的重心。\n\n接下来，我们计算这 10 个二次形函数 $N_i$ 在此点的值。\n对于顶点节点 ($i=1,2,3,4$)：\n$$\nN_i = L_i(2L_i - 1) = \\frac{1}{4}\\left(2\\left(\\frac{1}{4}\\right) - 1\\right) = \\frac{1}{4}\\left(\\frac{1}{2} - 1\\right) = \\frac{1}{4}\\left(-\\frac{1}{2}\\right) = -\\frac{1}{8}\n$$\n所以，$N_1 = N_2 = N_3 = N_4 = -\\frac{1}{8}$。\n\n对于边中点节点 ($i=5, \\dots, 10$)：\n通用形式为 $N_{ij} = 4L_iL_j$。\n$$\nN_5 = 4L_1L_2 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_6 = 4L_2L_3 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_7 = 4L_3L_1 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_8 = 4L_1L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_9 = 4L_2L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n$$\nN_{10} = 4L_3L_4 = 4\\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = \\frac{1}{4}\n$$\n作为一致性检查，形函数之和必须为1：$\\sum_{i=1}^{10} N_i = 4\\left(-\\frac{1}{8}\\right) + 6\\left(\\frac{1}{4}\\right) = -\\frac{1}{2} + \\frac{3}{2} = 1$。这些值是正确的。\n\n最后，我们计算物理坐标向量 $\\mathbf{x} = \\sum_{i=1}^{10} N_i \\mathbf{x}_i$。设 $\\mathbf{x} = (x,y,z)$。我们分别计算每个分量。\n节点坐标为：\n$\\mathbf{x}_1 = (0,0,0)$，$\\mathbf{x}_2 = (1,0,0)$，$\\mathbf{x}_3 = (0,1,0)$，$\\mathbf{x}_4 = (0,0,1)$。\n$\\mathbf{x}_5 = (\\frac{1}{2},0,\\frac{1}{8})$，$\\mathbf{x}_6 = (\\frac{1}{2},\\frac{1}{2},\\frac{1}{8})$，$\\mathbf{x}_7 = (0,\\frac{1}{2},\\frac{1}{8})$。\n$\\mathbf{x}_8 = (0,0,\\frac{1}{2})$，$\\mathbf{x}_9 = (\\frac{1}{2},0,\\frac{1}{2})$，$\\mathbf{x}_{10} = (0,\\frac{1}{2},\\frac{1}{2})$。\n\n对于 $x$ 分量：\n$$\nx = \\sum_{i=1}^{10} N_i x_i = N_2 x_2 + N_5 x_5 + N_6 x_6 + N_9 x_9\n$$\n$$\nx = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nx = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\n对于 $y$ 分量：\n$$\ny = \\sum_{i=1}^{10} N_i y_i = N_3 y_3 + N_6 y_6 + N_7 y_7 + N_{10} y_{10}\n$$\n$$\ny = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\ny = -\\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} + \\frac{1}{8} = \\frac{2}{8} = \\frac{1}{4}\n$$\n\n对于 $z$ 分量：\n$$\nz = \\sum_{i=1}^{10} N_i z_i = N_4 z_4 + N_5 z_5 + N_6 z_6 + N_7 z_7 + N_8 z_8 + N_9 z_9 + N_{10} z_{10}\n$$\n$$\nz = \\left(-\\frac{1}{8}\\right)(1) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{8}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right)\n$$\n$$\nz = -\\frac{1}{8} + 3\\left(\\frac{1}{32}\\right) + 3\\left(\\frac{1}{8}\\right) = -\\frac{1}{8} + \\frac{3}{32} + \\frac{3}{8}\n$$\n$$\nz = \\frac{-4 + 3 + 12}{32} = \\frac{11}{32}\n$$\n物理坐标向量为 $\\mathbf{x} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$ 米。\n\n### 步骤3：定性解释\n\n为解释此结果，我们将其与从线性（$4$ 节点）四面体映射获得的坐标进行比较。对于线性单元，映射仅由顶点定义：\n$$\n\\mathbf{x}_{\\text{lin}}(\\xi,\\eta,\\zeta) = \\sum_{i=1}^{4} L_i(\\xi,\\eta,\\zeta)\\,\\mathbf{x}_i\n$$\n在相同的参数点 $(\\xi,\\eta,\\zeta) = \\left(\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}\\right)$，其中 $L_1 = L_2 = L_3 = L_4 = \\frac{1}{4}$：\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\mathbf{x}_1 + \\frac{1}{4}\\mathbf{x}_2 + \\frac{1}{4}\\mathbf{x}_3 + \\frac{1}{4}\\mathbf{x}_4\n$$\n$$\n\\mathbf{x}_{\\text{lin}} = \\frac{1}{4}\\left[(0,0,0) + (1,0,0) + (0,1,0) + (0,0,1)\\right] = \\frac{1}{4}(1,1,1) = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{1}{4}\\right)\n$$\n线性映射简单地得出了四个顶点的物理质心。\n\n**比较与保真度**：\n-   **线性单元**：线性单元生成具有直边和平坦面的物理单元。它将参考四面体的重心映射到顶点的物理质心，即 $\\mathbf{x}_{\\text{lin}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{8}{32}\\right)$。这构成了对几何形状的一阶（或分段线性）近似。如果实际边界是弯曲的，线性单元只能将其表示为一组平坦的小平面，导致引入几何误差的“阶梯式”近似。\n\n-   **二次单元**：二次单元使用边中点节点来定义更高阶的弯曲几何形状。得到的坐标为 $\\mathbf{x}_{\\text{quad}} = \\left(\\frac{1}{4}, \\frac{1}{4}, \\frac{11}{32}\\right)$。其 $x$ 和 $y$ 分量与线性情况相同，但 $z$ 分量不同：$z_{\\text{quad}} = \\frac{11}{32}$ 对比 $z_{\\text{lin}} = \\frac{8}{32}$。位移 $\\Delta z = \\frac{3}{32}$ 是边中点节点从其直边位置偏移的直接结果。具体来说，位于 $z=0$ 平面上的边中点节点 $\\mathbf{x}_5, \\mathbf{x}_6, \\mathbf{x}_7$ 被赋予了 $\\frac{1}{8}$ 的正 $z$ 分量，从而创建了一个凸入单元体积的曲面。\n\n-   **结论**：二次等参单元提供了更高的边界曲率保真度。它允许有限元网格平滑且精确地贴合弯曲边界，这对于计算电磁学问题至关重要，因为在这些问题中，导电表面上的边界条件必须被精确施加。线性单元的几何不准确性可能导致计算得到的场、表面电流和散射参数出现显著误差，而二次单元模拟曲率的能力则极大地提高了求解的精度。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4} & \\frac{1}{4} & \\frac{11}{32}\n\\end{pmatrix}\n}\n$$", "id": "3320941"}, {"introduction": "学会了如何映射点之后，一个关键问题随之而来：映射后的单元在多大程度上能够精确表示真实的曲面几何？本练习[@problem_id:3320945]通过使用一个二次单元来近似一段圆弧，并计算产生的几何偏差，从而直面这一问题。这个实践将让你对等参近似的权衡与精度有一个切实的理解。", "problem": "在计算电磁学 (CEM) 中，采用高阶曲线元来表示理想导电边界，以减少几何误差。考虑一个二维理想导电圆弧，半径为 $R = 1.000$ 米，以原点为中心，角度范围从 $-\\alpha$ 到 $+\\alpha$，其中 $\\alpha = \\pi/6$ 弧度。使用一个等参二次边来近似该圆弧。该边由参考坐标 $\\xi \\in [-1,1]$ 参数化，并使用位于 $\\xi = -1, 0, 1$ 的三个边界点，分别映射到精确圆弧上角度为 $-\\alpha$、$0$、和 $+\\alpha$ 的位置。\n\n使用该边的标准二阶拉格朗日等参映射，构建从参考坐标到物理坐标的近似几何映射 $(x(\\xi), y(\\xi))$。然后，通过径向误差函数\n$$\n\\delta(\\xi) = \\sqrt{x(\\xi)^{2} + y(\\xi)^{2}} - R,\n$$\n来量化与精确圆的几何偏差，并确定在 $\\xi \\in [-1,1]$ 上的最大绝对径向偏差。\n\n将最终答案表示为一个实数，单位为米，四舍五入到四位有效数字。角度必须以弧度处理。", "solution": "该问题要求通过一个二次等参单元来近似一段圆弧，并量化其几何偏差。\n\n### 步骤1：建立几何映射\n\n首先，我们定义参考坐标 $\\xi \\in [-1, 1]$ 上的一维二次拉格朗日形函数 $N_i(\\xi)$，其节点位于 $\\xi = -1, 0, 1$：\n$$N_1(\\xi) = \\frac{1}{2}\\xi(\\xi - 1)$$\n$$N_2(\\xi) = 1 - \\xi^2$$\n$$N_3(\\xi) = \\frac{1}{2}\\xi(\\xi + 1)$$\n接着，确定三个节点在物理空间中的坐标。这些节点位于半径 $R=1$、圆心在原点的圆弧上，对应角度为 $-\\alpha, 0, +\\alpha$，其中 $\\alpha = \\pi/6$。\n- 节点1 ($\\xi=-1$): $\\mathbf{x}_1 = (R\\cos(-\\alpha), R\\sin(-\\alpha)) = (\\frac{\\sqrt{3}}{2}, -\\frac{1}{2})$\n- 节点2 ($\\xi=0$): $\\mathbf{x}_2 = (R\\cos(0), R\\sin(0)) = (1, 0)$\n- 节点3 ($\\xi=1$): $\\mathbf{x}_3 = (R\\cos(\\alpha), R\\sin(\\alpha)) = (\\frac{\\sqrt{3}}{2}, \\frac{1}{2})$\n\n等参映射 $\\mathbf{x}(\\xi) = (x(\\xi), y(\\xi))$ 由下式给出：\n$$\\mathbf{x}(\\xi) = \\sum_{i=1}^3 N_i(\\xi) \\mathbf{x}_i$$\n代入形函数和节点坐标，我们得到：\n$$x(\\xi) = N_1(\\xi)x_1 + N_2(\\xi)x_2 + N_3(\\xi)x_3 = 1 - \\left(1 - \\frac{\\sqrt{3}}{2}\\right)\\xi^2$$\n$$y(\\xi) = N_1(\\xi)y_1 + N_2(\\xi)y_2 + N_3(\\xi)y_3 = \\frac{1}{2}\\xi$$\n\n### 步骤2：计算径向误差\n\n任意点 $\\xi$ 处到原点的径向距离的平方为 $r^2(\\xi) = x(\\xi)^2 + y(\\xi)^2$。代入表达式并化简可得：\n$$r^2(\\xi) = 1 + C^2(\\xi^4 - \\xi^2), \\quad \\text{其中 } C = 1 - \\cos(\\alpha) = 1 - \\frac{\\sqrt{3}}{2}$$\n径向误差函数定义为 $\\delta(\\xi) = \\sqrt{r^2(\\xi)} - R$。由于 $R=1$，我们有：\n$$\\delta(\\xi) = \\sqrt{1 + C^2(\\xi^4 - \\xi^2)} - 1$$\n\n### 步骤3：寻找最大误差\n\n为了找到最大绝对径向偏差，我们需要找到 $|\\delta(\\xi)|$ 的最大值。注意到在区间 $\\xi \\in [-1, 1]$ 中，$\\xi^4 - \\xi^2 \\le 0$，因此 $\\delta(\\xi) \\le 0$。我们需要最小化 $\\delta(\\xi)$，这等价于最小化 $g(\\xi) = \\xi^4 - \\xi^2$。\n对 $g(\\xi)$ 求导并令其为零：$g'(\\xi) = 4\\xi^3 - 2\\xi = 2\\xi(2\\xi^2 - 1) = 0$。\n临界点为 $\\xi = 0, \\pm\\frac{1}{\\sqrt{2}}$。\n在节点 $\\xi=0, \\pm 1$ 处，$g(\\xi)=0$，误差为零。在 $\\xi = \\pm\\frac{1}{\\sqrt{2}}$ 处，$g(\\xi)$ 达到最小值 $-\\frac{1}{4}$。\n\n### 步骤4：计算数值结果\n\n将 $g(\\xi)$ 的最小值代入误差函数，得到最大绝对误差：\n$$|\\delta|_{\\text{max}} = |\\sqrt{1 + C^2(-\\frac{1}{4})} - 1| = 1 - \\sqrt{1 - \\frac{C^2}{4}}$$\n代入 $C = 1 - \\frac{\\sqrt{3}}{2}$，我们有 $C^2 = (1 - \\frac{\\sqrt{3}}{2})^2 = \\frac{7}{4} - \\sqrt{3}$。\n$$|\\delta|_{\\text{max}} = 1 - \\sqrt{1 - \\frac{1}{4}\\left(\\frac{7}{4} - \\sqrt{3}\\right)} = 1 - \\frac{\\sqrt{9 + 4\\sqrt{3}}}{4}$$\n计算数值结果：\n$$|\\delta|_{\\text{max}} \\approx 1 - \\frac{\\sqrt{9 + 4(1.73205)}}{4} \\approx 1 - \\frac{\\sqrt{15.9282}}{4} \\approx 1 - \\frac{3.991015}{4} \\approx 1 - 0.997754 = 0.002246$$\n将结果四舍五入到四位有效数字，得到 $0.002246$ 米。", "answer": "$$\n\\boxed{0.002246}\n$$", "id": "3320945"}, {"introduction": "最后的这项实践将所有概念融合成一个实际的计算任务。你将编写一个程序来计算关键的单元畸变度量——例如偏斜度、纵横比和雅可比行列式——并研究它们与场插值及数值积分精度的关系。这个练习[@problem_id:3320978]展示了为什么在计算科学中，保持高质量的网格对于获得可靠结果至关重要。", "problem": "考虑一个二维等参二次四边形单元，该单元有九个节点，定义在坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 的参考方块上。从参考方块到物理单元的等参映射是使用在三节点集 $\\{\\xi=-1,0,1\\}\\times\\{\\eta=-1,0,1\\}$ 上的张量积二次 Lagrange 基构建的，并且每个测试用例都给出了物理节点坐标 $\\{\\mathbf{x}_i\\}_{i=1}^{9}$。映射的雅可比矩阵 $\\mathbf{J}(\\xi,\\eta)$ 由物理坐标相对于 $(\\xi,\\eta)$ 的偏导数定义，其行列式为 $\\det \\mathbf{J}(\\xi,\\eta)$。设解析标量场为 $f(x,y)=\\sin(\\pi x)\\cos(\\pi y)$，视为无量纲。\n\n从等参映射、度量张量和高斯求积法则的基本定义出发，实现一个程序，为每个测试用例计算以下畸变度量和精度度量：\n\n1. 平均偏斜度 $\\overline{s}$：对于每个采样点 $(\\xi,\\eta)$，令 $\\mathbf{a}=\\partial\\mathbf{x}/\\partial\\xi$ 和 $\\mathbf{b}=\\partial\\mathbf{x}/\\partial\\eta$ 为 $\\mathbf{J}$ 的列向量。将局部偏斜度定义为 $s=\\left|\\frac{\\mathbf{a}\\cdot\\mathbf{b}}{\\|\\mathbf{a}\\|\\|\\mathbf{b}\\|}\\right|$。计算 $\\overline{s}$，即 $s$ 在一个 $n_s\\times n_s$ 的内部采样网格上的算术平均值，其中 $n_s$ 设为 $7$。角度通过余弦函数隐式地以弧度度量。\n\n2. 平均纵横比 $\\overline{r}$：在每个采样点，计算 $\\mathbf{J}$ 的奇异值 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$，并定义 $r=\\sigma_{\\max}/\\sigma_{\\min}$。计算 $\\overline{r}$，即 $r$ 在相同采样网格上的算术平均值。\n\n3. 雅可比行列式的最小值 $\\min_{\\text{samples}} \\det \\mathbf{J}$：在采样网格上评估 $\\det \\mathbf{J}$，并报告其在采样点上的最小值（不取绝对值）。\n\n4. 场插值 $L^2$-误差：使用与几何映射相同的二次 Lagrange 基，形成等参插值 $f_h(\\xi,\\eta)=\\sum_{i=1}^{9}N_i(\\xi,\\eta) f(\\mathbf{x}_i)$，其中 $N_i$ 是形函数，$\\mathbf{x}_i$ 是物理节点坐标。计算物理单元上插值误差的 $L^2$-范数，\n$$\n\\Vert f-f_h\\Vert_{L^2(\\Omega_e)}=\\left(\\int_{\\Omega_e} (f-f_h)^2 \\, d\\Omega\\right)^{1/2},\n$$\n通过变换到参考域，并使用阶数为 $q_h=7$ 的张量积高斯求积来近似该积分，其中映射下的测度因子为绝对值 $\\left|\\det \\mathbf{J}\\right|$。\n\n5. 积分精度：使用阶数为 $q_\\ell=3$ 的张量积高斯求积计算积分 $I=\\int_{\\Omega_e} f \\, d\\Omega$，并使用阶数为 $q_h=7$ 的高斯求积计算参考值 $I_{\\text{ref}}$，两者均使用绝对值 $\\left|\\det \\mathbf{J}\\right|$。报告绝对积分误差 $|I-I_{\\text{ref}}|$。\n\n通过在每个轴上于 $(-1,1)$ 内均匀放置 $n_s$ 个点，其位置为 $\\xi_i=-1+\\frac{2i}{n_s+1}$ 和 $\\eta_j=-1+\\frac{2j}{n_s+1}$（对于 $i,j\\in\\{1,\\dots,n_s\\}$），来使用排除边界的采样点。\n\n通过计算所有量并为每个测试用例返回数值，将畸变度量与精度度量关联起来。较大的偏斜度和纵横比通常表示较高的畸变，并预期与较大的插值和积分误差相关。\n\n测试套件（每个测试用例按行主序提供九个物理节点，对应于 $(\\xi,\\eta)\\in\\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$）：\n\n- 测试用例 1（轻度弯曲，接近矩形）：\n$\\left[\n(0.0,0.0),\\,\n(1.0,-0.03),\\,\n(2.0,0.05),\\,\n(-0.02,0.5),\\,\n(1.02,0.52),\\,\n(2.03,0.5),\\,\n(0.0,1.0),\\,\n(1.0,1.03),\\,\n(2.0,1.05)\n\\right]$。\n\n- 测试用例 2（偏斜且中度弯曲）：\n$\\left[\n(0.0,0.0),\\,\n(1.0,0.10),\\,\n(2.0,0.3),\\,\n(0.03,0.42),\\,\n(1.07,0.57),\\,\n(2.08,0.68),\\,\n(0.1,0.8),\\,\n(1.12,0.97),\\,\n(2.1,1.1)\n\\right]$。\n\n- 测试用例 3（细长且显著弯曲）：\n$\\left[\n(0.0,0.0),\\,\n(1.5,0.06),\\,\n(3.0,0.2),\\,\n(0.2,0.22),\\,\n(1.62,0.27),\\,\n(3.15,0.33),\\,\n(0.5,0.4),\\,\n(1.9,0.47),\\,\n(3.2,0.5)\n\\right]$。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个包含五个浮点数的列表，顺序为 $\\left[\\overline{s},\\overline{r},\\min \\det \\mathbf{J},\\|f-f_h\\|_{L^2(\\Omega_e)},|I-I_{\\text{ref}}|\\right]$。例如，输出格式为 $\\left[ [a_1,a_2,a_3,a_4,a_5], [b_1,b_2,b_3,b_4,b_5], [c_1,c_2,c_3,c_4,c_5] \\right]$，所有条目均以十进制数表示。", "solution": "该问题要求为一个二维九节点等参二次四边形单元计算若干畸变度量和精度度量。该分析涉及有限元方法的概念，包括等参映射、使用高斯求积的数值积分以及误差估计。详细过程如下，从基本定义开始。\n\n### 1. 等参公式\n\n该方法的核心是等参映射，它使用同一组基函数（形函数）来定义单元的几何形状并对单元上的场进行插值。\n\n#### 1.1. 参考单元和形函数\n参考单元是计算域中的一个正方形，由 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 定义。对于一个九节点二次单元，节点位于每个轴上点集 $\\{-1, 0, 1\\}$ 的张量积处。\n\n首先，我们为变量 $\\zeta \\in [-1, 1]$ 定义一维二次 Lagrange 基函数 $L_k(\\zeta)$，节点位于 $\\zeta \\in \\{-1, 0, 1\\}$。\n设节点位置为 $\\zeta_1 = -1$, $\\zeta_2 = 0$, 和 $\\zeta_3 = 1$。基函数为：\n- $L_1(\\zeta) = \\frac{(\\zeta - \\zeta_2)(\\zeta - \\zeta_3)}{(\\zeta_1 - \\zeta_2)(\\zeta_1 - \\zeta_3)} = \\frac{\\zeta(\\zeta - 1)}{(-1)(-2)} = \\frac{1}{2}\\zeta(\\zeta - 1)$\n- $L_2(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_3)}{(\\zeta_2 - \\zeta_1)(\\zeta_2 - \\zeta_3)} = \\frac{(\\zeta + 1)(\\zeta - 1)}{(1)(-1)} = 1 - \\zeta^2$\n- $L_3(\\zeta) = \\frac{(\\zeta - \\zeta_1)(\\zeta - \\zeta_2)}{(\\zeta_3 - \\zeta_1)(\\zeta_3 - \\zeta_2)} = \\frac{(\\zeta + 1)\\zeta}{(2)(1)} = \\frac{1}{2}\\zeta(\\zeta + 1)$\n\n九个节点的二维形函数 $N_i(\\xi, \\eta)$ 由这些一维函数的张量积形成。给定指定的行主序节点排序，如果我们有 $\\xi$ 和 $\\eta$ 方向的节点索引 $j,k \\in \\{1,2,3\\}$，则全局节点索引 $i$（从 1 到 9）和相应的形函数由 $N_i(\\xi, \\eta) = L_j(\\xi) L_k(\\eta)$ 给出。例如，对于位于 $(\\xi, \\eta)=(0,0)$ 的节点 $i=5$，其形函数为 $N_5(\\xi, \\eta) = L_2(\\xi)L_2(\\eta) = (1-\\xi^2)(1-\\eta^2)$。\n\n#### 1.2. 几何映射和场插值\n从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $\\mathbf{x} = (x, y)$ 的等参映射由下式给出：\n$$ \\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) \\mathbf{x}_i $$\n其中 $\\mathbf{x}_i = (x_i, y_i)$ 是第 $i$ 个物理节点的坐标。\n\n类似地，标量场 $f(x, y)$ 使用相同的形函数在单元上进行插值：\n$$ f_h(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) f(\\mathbf{x}_i) $$\n其中 $f_h$ 是 $f$ 的近似，而 $f(\\mathbf{x}_i)$ 是真正在物理节点 $i$ 处的值。\n\n### 2. 雅可比矩阵和畸变度量\n\n映射的局部畸变由雅可比矩阵 $\\mathbf{J}$ 来表征，它关联了参考坐标中的无穷小变化与物理坐标中的无穷小变化。\n\n#### 2.1. 雅可比矩阵\n雅可比矩阵定义为：\n$$ \\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} $$\n偏导数通过对映射方程求导得到：\n$$ \\frac{\\partial \\mathbf{x}}{\\partial \\xi} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\xi} \\mathbf{x}_i \\quad \\text{和} \\quad \\frac{\\partial \\mathbf{x}}{\\partial \\eta} = \\sum_{i=1}^{9} \\frac{\\partial N_i}{\\partial \\eta} \\mathbf{x}_i $$\n这里需要形函数的导数，例如 $\\frac{\\partial N_i}{\\partial \\xi} = \\frac{d L_j(\\xi)}{d \\xi} L_k(\\eta)$。\n\n#### 2.2. 畸变度量\n问题要求在一个 $n_s \\times n_s$ 的内部采样网格上评估三个度量，其中 $n_s=7$。\n1.  **平均偏斜度 $\\overline{s}$**：$\\mathbf{J}$ 的列向量 $\\mathbf{a} = \\frac{\\partial \\mathbf{x}}{\\partial \\xi}$ 和 $\\mathbf{b} = \\frac{\\partial \\mathbf{x}}{\\partial \\eta}$ 代表映射后的基向量。偏斜度度量了与正交性的偏离。局部偏斜度 $s$ 是它们之间夹角余弦的绝对值：\n    $$ s(\\xi, \\eta) = \\left| \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\| \\|\\mathbf{b}\\|} \\right| $$\n    平均偏斜度 $\\overline{s}$ 是 $s$ 在采样网格上的算术平均值。理想值为 0（正交），而接近 1 的值表示严重畸变。\n\n2.  **平均纵横比 $\\overline{r}$**：此度量衡量单元的拉伸程度。它定义为雅可比矩阵的最大奇异值与最小奇异值之比，$\\sigma_{\\max}$ 和 $\\sigma_{\\min}$：\n    $$ r(\\xi, \\eta) = \\frac{\\sigma_{\\max}(\\mathbf{J})}{\\sigma_{\\min}(\\mathbf{J})} $$\n    平均纵横比 $\\overline{r}$ 是 $r$ 在采样网格上的算术平均值。理想单元的纵横比为 1。\n\n3.  **雅可比行列式的最小值 $\\min \\det \\mathbf{J}$**：雅可比行列式 $\\det \\mathbf{J}$ 是物理域中面积与参考域中面积的局部比率。非正的行列式表示一个局部无效（折叠）的映射。我们在采样网格上找到 $\\det \\mathbf{J}$ 的最小值。\n\n### 3. 精度度量\n\n畸变会影响场插值和数值积分的精度。\n\n#### 3.1. 场插值的 $L^2$-误差\n用 $f_h$ 近似场 $f$ 的误差由它们在物理单元 $\\Omega_e$ 上差值的 $L^2$-范数来度量：\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{\\Omega_e} (f(\\mathbf{x}) - f_h(\\mathbf{x}))^2 \\, d\\Omega \\right)^{1/2} $$\n为了计算这个值，我们将积分变换到参考单元上：\n$$ \\int_{\\Omega_e} g(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} g(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\n将此应用于 $g = (f-f_h)^2$，误差范数变为：\n$$ \\|f - f_h\\|_{L^2(\\Omega_e)} = \\left( \\int_{-1}^{1} \\int_{-1}^{1} (f(\\mathbf{x}(\\xi, \\eta)) - f_h(\\xi, \\eta))^2 |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta \\right)^{1/2} $$\n该积分使用一个 $q_h \\times q_h$ 的张量积高斯求积法则来近似，其中 $q_h=7$。二维高斯求积的公式为：\n$$ \\int_{-1}^{1}\\int_{-1}^{1} G(\\xi, \\eta) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{q} \\sum_{k=1}^{q} w_j w_k G(\\xi_j, \\eta_k) $$\n其中 $(\\xi_j, \\eta_k)$ 是求积点，$(w_j, w_k)$ 是相应的权重。\n\n#### 3.2. 积分精度\n我们通过比较用两种不同求积阶数计算的场 $f$ 的积分来评估单元畸变对数值积分精度的影响。积分为：\n$$ I = \\int_{\\Omega_e} f(\\mathbf{x}) \\, d\\Omega = \\int_{-1}^{1} \\int_{-1}^{1} f(\\mathbf{x}(\\xi, \\eta)) |\\det \\mathbf{J}(\\xi, \\eta)| \\, d\\xi \\, d\\eta $$\n- 使用低阶求积法则（$q_\\ell=3$）计算一个低精度积分 $I$。\n- 使用高阶法则（$q_h=7$）计算一个高精度参考积分 $I_{\\text{ref}}$。\n绝对积分误差即为 $|I - I_{\\text{ref}}|$。\n\n### 4. 计算算法\n对于每个测试用例（一组9个物理节点坐标 $\\mathbf{x}_i$）：\n1.  定义 $n_s \\times n_s = 7 \\times 7$ 的内部采样网格。\n2.  为平均偏斜度、平均纵横比初始化累加器，并为一个变量初始化以存储最小雅可比行列式。\n3.  遍历采样网格中的每个点 $(\\xi, \\eta)$：\n    a. 计算雅可比矩阵 $\\mathbf{J}(\\xi, \\eta)$。\n    b. 计算局部偏斜度 $s$、纵横比 $r$ 和 $\\det \\mathbf{J}$。\n    c. 更新累加器和最小行列式。\n4.  计算最终的平均值 $\\overline{s}$ 和 $\\overline{r}$。\n5.  建立 $q_h=7$ 点的高斯求积法则。\n6.  在9个物理节点上分别评估解析场 $f(\\mathbf{x}_i)$。\n7.  通过对每个求积点的贡献求和来计算 $L^2$ 插值误差积分。取结果的平方根。\n8.  使用 $q_h=7$ 的求积法则计算参考积分 $I_{\\text{ref}}$。\n9.  建立 $q_\\ell=3$ 点的高斯求积法则。\n10. 使用 $q_\\ell=3$ 的法则计算低阶积分 $I$。\n11. 计算绝对积分误差 $|I - I_{\\text{ref}}|$。\n12. 收集五个计算值：$\\overline{s}$、$\\overline{r}$、$\\min \\det \\mathbf{J}$、$\\|f-f_h\\|_{L^2(\\Omega_e)}$ 和 $|I-I_{\\text{ref}}|$。\n\n对每个测试用例重复此过程，得出所要求的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_d_basis(z: float) -> np.ndarray:\n    \"\"\"Computes the 1D quadratic Lagrange basis functions at a point z.\"\"\"\n    l1 = 0.5 * z * (z - 1.0)\n    l2 = 1.0 - z**2\n    l3 = 0.5 * z * (z + 1.0)\n    return np.array([l1, l2, l3])\n\ndef one_d_basis_deriv(z: float) -> np.ndarray:\n    \"\"\"Computes the derivatives of the 1D quadratic Lagrange basis functions.\"\"\"\n    dl1 = z - 0.5\n    dl2 = -2.0 * z\n    dl3 = z + 0.5\n    return np.array([dl1, dl2, dl3])\n\ndef shape_functions(xi: float, eta: float) -> np.ndarray:\n    \"\"\"Computes the 9-node quadratic shape functions at (xi, eta).\"\"\"\n    l_xi = one_d_basis(xi)\n    l_eta = one_d_basis(eta)\n    n_vec = np.zeros(9)\n    for i in range(3):  # eta node index\n        for j in range(3):  # xi node index\n            n_vec[i * 3 + j] = l_xi[j] * l_eta[i]\n    return n_vec\n\ndef shape_derivatives(xi: float, eta: float) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"Computes derivatives of shape functions w.r.t. xi and eta.\"\"\"\n    l_xi = one_d_basis(xi)\n    dl_xi = one_d_basis_deriv(xi)\n    l_eta = one_d_basis(eta)\n    dl_eta = one_d_basis_deriv(eta)\n    \n    dn_dxi = np.zeros(9)\n    dn_deta = np.zeros(9)\n    \n    for i in range(3):\n        for j in range(3):\n            k = i * 3 + j\n            dn_dxi[k] = dl_xi[j] * l_eta[i]\n            dn_deta[k] = l_xi[j] * dl_eta[i]\n            \n    return dn_dxi, dn_deta\n\ndef jacobian(xi: float, eta: float, physical_nodes: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the Jacobian matrix of the mapping at (xi, eta).\"\"\"\n    dn_dxi, dn_deta = shape_derivatives(xi, eta)\n    \n    # J is a 2x2 matrix\n    # J[0,0] = dN_dxi . x_coords, J[1,0] = dN_dxi . y_coords\n    # J[0,1] = dN_deta . x_coords, J[1,1] = dN_deta . y_coords\n    \n    j_matrix = np.zeros((2, 2))\n    j_matrix[:, 0] = np.dot(dn_dxi, physical_nodes)   # d(x,y)/dxi\n    j_matrix[:, 1] = np.dot(dn_deta, physical_nodes) # d(x,y)/deta\n    \n    return j_matrix\n\ndef f_analytic(x: float, y: float) -> float:\n    \"\"\"The analytic scalar field.\"\"\"\n    return np.sin(np.pi * x) * np.cos(np.pi * y)\n\ndef calculate_all_metrics(physical_nodes: np.ndarray) -> list[float]:\n    \"\"\"\n    Computes all requiredd distortion and accuracy metrics for a given element.\n    \"\"\"\n    n_s = 7\n    q_h = 7\n    q_l = 3\n\n    # 1. Compute distortion metrics\n    s_vals, r_vals, det_j_vals = [], [], []\n    sample_points_1d = -1.0 + 2.0 * (np.arange(n_s) + 1.0) / (n_s + 1.0)\n\n    for eta_s in sample_points_1d:\n        for xi_s in sample_points_1d:\n            j_mat = jacobian(xi_s, eta_s, physical_nodes)\n            a, b = j_mat[:, 0], j_mat[:, 1]\n\n            # Skewness\n            norm_a = np.linalg.norm(a)\n            norm_b = np.linalg.norm(b)\n            if norm_a > 1e-12 and norm_b > 1e-12:\n                cos_theta = np.dot(a, b) / (norm_a * norm_b)\n                s_vals.append(np.abs(cos_theta))\n            else: # Should not happen for valid elements\n                s_vals.append(0.0)\n\n            # Aspect ratio from singular values\n            _, s_svd, _ = np.linalg.svd(j_mat)\n            if s_svd.min() > 1e-12:\n                r_vals.append(s_svd.max() / s_svd.min())\n            else: # Folded element\n                r_vals.append(np.inf)\n\n            # Jacobian determinant\n            det_j_vals.append(np.linalg.det(j_mat))\n\n    s_mean = np.mean(s_vals)\n    r_mean = np.mean(r_vals)\n    min_det_j = np.min(det_j_vals)\n    \n    # 2. Compute L^2 interpolation error\n    xi_h, w_h = np.polynomial.legendre.leggauss(q_h)\n    f_at_nodes = f_analytic(physical_nodes[:, 0], physical_nodes[:, 1])\n\n    error_integral_sum = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            f_h = np.dot(n_vec, f_at_nodes)\n            \n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            \n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            \n            error_integral_sum += (f_true - f_h)**2 * np.abs(det_j) * w_xi * w_eta\n    \n    l2_error = np.sqrt(error_integral_sum)\n    \n    # 3. Compute integration accuracy\n    # I_ref (high order, q_h=7)\n    i_ref = 0.0\n    for w_eta, eta_q in zip(w_h, xi_h):\n        for w_xi, xi_q in zip(w_h, xi_h):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_ref += f_true * np.abs(det_j) * w_xi * w_eta\n\n    # I (low order, q_l=3)\n    xi_l, w_l = np.polynomial.legendre.leggauss(q_l)\n    i_low = 0.0\n    for w_eta, eta_q in zip(w_l, xi_l):\n        for w_xi, xi_q in zip(w_l, xi_l):\n            n_vec = shape_functions(xi_q, eta_q)\n            x_mapped, y_mapped = np.dot(n_vec, physical_nodes)\n            f_true = f_analytic(x_mapped, y_mapped)\n            det_j = np.linalg.det(jacobian(xi_q, eta_q, physical_nodes))\n            i_low += f_true * np.abs(det_j) * w_xi * w_eta\n            \n    int_error = np.abs(i_low - i_ref)\n    \n    return [s_mean, r_mean, min_det_j, l2_error, int_error]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        [(0.0, 0.0), (1.0, -0.03), (2.0, 0.05),\n         (-0.02, 0.5), (1.02, 0.52), (2.03, 0.5),\n         (0.0, 1.0), (1.0, 1.03), (2.0, 1.05)],\n        # Test Case 2\n        [(0.0, 0.0), (1.0, 0.10), (2.0, 0.3),\n         (0.03, 0.42), (1.07, 0.57), (2.08, 0.68),\n         (0.1, 0.8), (1.12, 0.97), (2.1, 1.1)],\n        # Test Case 3\n        [(0.0, 0.0), (1.5, 0.06), (3.0, 0.2),\n         (0.2, 0.22), (1.62, 0.27), (3.15, 0.33),\n         (0.5, 0.4), (1.9, 0.47), (3.2, 0.5)]\n    ]\n\n    all_results = []\n    for case_nodes in test_cases:\n        physical_nodes_arr = np.array(case_nodes)\n        metrics = calculate_all_metrics(physical_nodes_arr)\n        all_results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{', '.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3320978"}]}