{"hands_on_practices": [{"introduction": "本次练习旨在连接理论与实践，核心是探索互易性原理。您将首先从亥姆霍兹方程的弱形式出发，推导波动物理学中的这一基本对称性，然后基于此原理构建一个数值测试，为验证有限元代码的正确性提供一个强有力的工具。这项练习对于培养开发稳健可靠的仿真程序的能力至关重要。[@problem_id:3360923]", "problem": "考虑一个标量Helmholtz边界值问题，该问题是无损耗、非均匀、一维介质中时谐电磁波传播的模型简化。设$\\Omega = (0,1)$，并设$a(x)$和$b(x)$为代表有效材料参数的实值、有界、严格为正的系数函数。对于给定的实波数$k \\in \\mathbb{R}$和给定的源函数$f \\in L^2(\\Omega)$，其强形式为：求$u:\\Omega \\to \\mathbb{R}$，使得\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1), \\quad u(0)=0, \\quad u(1)=0,\n$$\n其中所有量纲均为无量纲。\n\n1) 从散度定理和Sobolev空间$H_0^1(\\Omega)$的定义出发，推导弱形式：求$u \\in H_0^1(\\Omega)$，使得对于所有$v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx.\n$$\n明确指出$a(x)$、$b(x)$的哪些性质以及边界条件确保了双线性形式\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n是对称的。从第一性原理出发，解释为什么这种对称性意味着对应于源$f_1,f_2 \\in L^2(\\Omega)$的任意两个弱解$u_1,u_2 \\in H_0^1(\\Omega)$之间存在互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx.\n$$\n\n2) 考虑使用全局连续的分段线性基函数，在具有$N$个单元的均匀网格上应用协调Galerkin有限元法 (FEM)。设$\\{\\phi_i(x)\\}_{i=0}^N$表示在区间$[0,1]$剖分上的标准节点基，其节点为 $0=x_0  x_1  \\cdots  x_N = 1$。使用中点求积进行逐单元组装，定义单元矩阵和向量来组装全局矩阵\n$$\nA \\equiv K - k^2 M,\n$$\n其中刚度矩阵项为$K_{ij} \\approx \\int_0^1 a(x)\\, \\phi_i'(x)\\, \\phi_j'(x)\\, dx$，质量矩阵项为$M_{ij} \\approx \\int_0^1 b(x)\\, \\phi_i(x)\\, \\phi_j(x)\\, dx$，载荷向量项为$b_i \\approx \\int_0^1 f(x)\\, \\phi_i(x)\\, dx$。在端点处强施加齐次Dirichlet边界条件。从组装系统的代数角度证明，当$A$是对称的，且两个离散解$U^{(1)}$和$U^{(2)}$都满足$A U^{(m)} = b^{(m)}$（使用相同的$A$）时，以下离散互易恒等式在有限精度算术中精确成立（误差仅为线性求解器的舍入误差）：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}.\n$$\n\n3) 构建一个数值测试，通过计算差异\n$$\nr \\equiv \\left| \\left(U^{(2)}\\right)^\\top b^{(1)} - \\left(U^{(1)}\\right)^\\top b^{(2)} \\right|\n$$\n来检测离散情况下违反互易性的实现错误。实现一个独立的程序，该程序：\n- 使用中点求积组装一维分段线性有限元系统。\n- 求解具有源$f_1$和$f_2$的两个离散问题。\n- 报告互易性差异$r$。\n\n您的程序必须评估以下测试套件，并以浮点数形式输出四个差异值。所有量纲均为无量纲。\n\n- 测试1（理想情况，光滑系数和源）：\n  - $N = 64$, $k = 7.3$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = \\sin(3\\pi x)$, $f_2(x) = \\cos(5\\pi x)$,\n  - 两次求解均使用相同的组装矩阵$A$。\n\n- 测试2（非均匀系数，光滑局部化源）：\n  - $N = 64$, $k = 4.2$,\n  - 当$x  0.5$时$a(x) = 1$，当$x \\ge 0.5$时$a(x) = 3$，$b(x) = 1$，\n  - $f_1(x) = \\exp\\!\\left(-100\\,(x-0.3)^2\\right)$, $f_2(x) = \\exp\\!\\left(-120\\,(x-0.7)^2\\right)$,\n  - 两次求解均使用相同的组装矩阵$A$。\n\n- 测试3（极粗网格，粗糙离散边界情况）：\n  - $N = 2$, $k = 2.0$, $a(x) = 1$, $b(x) = 1$,\n  - $f_1(x) = x\\,(1-x)$, $f_2(x) = 1 - 2x$,\n  - 两次求解均使用相同的组装矩阵$A$。\n\n- 测试4（通过模拟组装错误的斜扰动故意违反互易性）：\n  - 从与测试1相同的配置开始。\n  - 组装对称矩阵$A$后，通过向单个内部非对角元添加一个斜扰动$\\varepsilon = 10^{-2}$来创建一个扰动矩阵$\\tilde{A}$：$\\tilde{A}_{p,p+1} \\leftarrow \\tilde{A}_{p,p+1} + \\varepsilon$ (其中$p = \\lfloor N/2 \\rfloor$)，而不对$\\tilde{A}_{p+1,p}$进行相应更改。\n  - 求解$A U^{(1)} = b^{(1)}$和$\\tilde{A} U^{(2)} = b^{(2)}$。\n  - 用$U^{(1)},U^{(2)},b^{(1)},b^{(2)}$计算$r$。此配置应产生比测试1-3大几个数量级的差异。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个互易性差异，形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”）。每个$r_m$必须是浮点数。不应打印额外文本。该问题完全无量纲；不需要物理单位，也不涉及角度。", "solution": "该问题要求对一维标量Helmholtz方程的互易原理进行理论推导和数值验证。我们将首先验证问题陈述，然后进行详细求解。\n\n### 第1部分：弱形式和互易恒等式的推导\n\n边界值问题的强形式是在域$\\Omega = (0,1)$上找到一个函数$u:\\Omega \\to \\mathbb{R}$，满足：\n$$\n-\\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) - k^2 b(x) u(x) = f(x) \\quad \\text{for } x \\in (0,1)\n$$\n并服从齐次Dirichlet边界条件$u(0)=0$和$u(1)=0$。系数$a(x)$和$b(x)$是实值、有界且严格为正的，$k \\in \\mathbb{R}$是波数，$f \\in L^2(\\Omega)$是源项。\n\n为了推导弱形式，我们采用标准步骤，即将微分方程乘以一个测试函数$v$，然后在域$\\Omega$上积分。解$u$和测试函数$v$的合适空间都是Sobolev空间$H_0^1(\\Omega)$。该空间由$L^2(\\Omega)$中的函数组成，这些函数的弱导数也在$L^2(\\Omega)$中，并且它们满足齐次边界条件，即$u(0)=v(0)=0$和$u(1)=v(1)=0$。\n\n将强形式乘以$v \\in H_0^1(\\Omega)$并积分，得到：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n我们关注第一项并应用分部积分法，这是一维版本的散度定理：$\\int_\\Omega (\\nabla \\cdot \\mathbf{F}) \\phi \\, dV = -\\int_\\Omega \\mathbf{F} \\cdot (\\nabla \\phi) \\, dV + \\int_{\\partial\\Omega} (\\mathbf{F} \\cdot \\mathbf{n}) \\phi \\, dS$。在一维中，这变为$\\int_0^1 \\frac{dF}{dx} v \\, dx = [Fv]_0^1 - \\int_0^1 F\\frac{dv}{dx} \\, dx$。\n令$F(x) = -a(x)\\frac{du}{dx}$，我们有：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) v(x)\\, dx = - \\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 + \\int_0^1 a(x) \\frac{du}{dx} \\frac{dv}{dx} \\, dx\n$$\n边界项$\\left[ a(x)\\frac{du}{dx}v(x) \\right]_0^1 = a(1)\\frac{du}{dx}(1)v(1) - a(0)\\frac{du}{dx}(0)v(0)$为零，因为测试函数$v$属于$H_0^1(\\Omega)$，这意味着$v(0)=0$和$v(1)=0$。\n\n将此代入积分后的方程，我们得到弱形式：求$u \\in H_0^1(\\Omega)$，使得对于所有$v \\in H_0^1(\\Omega)$，\n$$\n\\int_0^1 a(x)\\, \\frac{du}{dx}(x)\\, \\frac{dv}{dx}(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx = \\int_0^1 f(x)\\, v(x)\\, dx\n$$\n这可以写成抽象形式$B(u,v) = L(v)$，其中$B(u,v)$是双线性形式，$L(v)$是右侧的线性泛函。\n\n双线性形式$B(u,v)$定义为：\n$$\nB(u,v) \\equiv \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx - k^2 \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n为了使$B(u,v)$对称，我们需要对于所有$u,v \\in H_0^1(\\Omega)$，$B(u,v) = B(v,u)$。让我们检验$B(v,u)$:\n$$\nB(v,u) = \\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx - k^2 \\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx\n$$\n由于$u(x)$、$v(x)$及其导数都是标量实值函数，系数$a(x)$和$b(x)$也是实值函数，因此这些函数的乘法是可交换的。即$u'(x)v'(x) = v'(x)u'(x)$和$u(x)v(x) = v(x)u(x)$。因此：\n$$\n\\int_0^1 a(x)\\, v'(x)\\, u'(x)\\, dx = \\int_0^1 a(x)\\, u'(x)\\, v'(x)\\, dx\n$$\n$$\n\\int_0^1 b(x)\\, v(x)\\, u(x)\\, dx = \\int_0^1 b(x)\\, u(x)\\, v(x)\\, dx\n$$\n这表明$B(u,v) = B(v,u)$。由于问题处理的是实值函数和系数，双线性形式的对称性得到了保证。\n\n现在，我们推导互易恒等式。设$u_1, u_2 \\in H_0^1(\\Omega)$是分别对应于两个不同源函数$f_1, f_2 \\in L^2(\\Omega)$的两个弱解。根据弱解的定义，它们满足：\n1. 对于所有$v \\in H_0^1(\\Omega)$，$B(u_1, v) = \\int_0^1 f_1(x) v(x) dx$。\n2. 对于所有$v \\in H_0^1(\\Omega)$，$B(u_2, v) = \\int_0^1 f_2(x) v(x) dx$。\n\n由于$u_1, u_2 \\in H_0^1(\\Omega)$，它们本身就是有效的测试函数。我们可以在第一个方程中选择$v=u_2$，在第二个方程中选择$v=u_1$：\n1. $B(u_1, u_2) = \\int_0^1 f_1(x) u_2(x) dx$\n2. $B(u_2, u_1) = \\int_0^1 f_2(x) u_1(x) dx$\n\n正如我们刚才所证，双线性形式$B(\\cdot, \\cdot)$是对称的，这导致$B(u_1, u_2) = B(u_2, u_1)$。令上述两个表达式的右侧相等，便得到互易恒等式：\n$$\n\\int_0^1 f_1(x)\\, u_2(x)\\, dx = \\int_0^1 f_2(x)\\, u_1(x)\\, dx\n$$\n这个恒等式表明，第一个源对第二个解所做的功等于第二个源对第一个解所做的功。\n\n### 第2部分：离散公式和互易性\n\n我们使用协调Galerkin有限元法 (FEM) 对问题进行离散化，基函数为定义在$[0,1]$上具有$N$个单元和步长$h=1/N$的均匀网格上的分段线性函数$\\phi_i(x)$。节点为$x_i = i h$，其中$i=0, \\dots, N$。帽函数$\\phi_i(x)$在节点$x_i$处为1，在所有其他节点处为0。\n\nFEM解$u_h(x)$在由内部基函数$\\{\\phi_i\\}_{i=1}^{N-1}$张成的有限维子空间$V_h \\subset H_0^1(\\Omega)$中寻找。解表示为这些基函数的线性组合：\n$$\nu_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)\n$$\n其中$U_j$是未知系数，代表解在内部节点$x_j$处的值。注意，$U_0=0$和$U_N=0$是强施加的。\n\nGalerkin方法要求弱形式对所有测试函数$v_h \\in V_h$成立。我们选择基函数本身作为测试函数，即$v = \\phi_i(x)$，其中$i=1, \\dots, N-1$：\n$$\nB\\left(\\sum_{j=1}^{N-1} U_j \\phi_j, \\phi_i\\right) = L(\\phi_i) \\quad \\text{for } i=1, \\dots, N-1\n$$\n根据双线性形式的线性性质，这变成一个线性方程组：\n$$\n\\sum_{j=1}^{N-1} U_j B(\\phi_j, \\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n这是一个代数系统$A U = b$，其中$U = [U_1, \\dots, U_{N-1}]^\\top$是未知节点值的向量，矩阵$A$（大小为$(N-1) \\times (N-1)$）和向量$b$（大小为$(N-1) \\times 1$）的项分别为：\n$$\nA_{ij} = B(\\phi_j, \\phi_i) = \\int_0^1 a(x) \\phi_j'(x) \\phi_i'(x) dx - k^2 \\int_0^1 b(x) \\phi_j(x) \\phi_i(x) dx\n$$\n$$\nb_i = \\int_0^1 f(x) \\phi_i(x) dx\n$$\n问题指定使用中点求积来组装系统。对于一个单元$e_m = [x_{m-1}, x_m]$，其中点为$x_{m-1/2} = (x_{m-1}+x_m)/2$：\n- 单元刚度矩阵$K^{(m)}$的局部项为$K_{ij}^{(m)} \\approx h \\cdot a(x_{m-1/2}) \\phi_j'(x_{m-1/2}) \\phi_i'(x_{m-1/2})$。局部分段线性基函数的导数是常数，为$\\pm 1/h$。这导致对称的单元矩阵：$K^{(m)} \\approx \\frac{a(x_{m-1/2})}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n- 单元质量矩阵$M^{(m)}$的局部项为$M_{ij}^{(m)} \\approx h \\cdot b(x_{m-1/2}) \\phi_j(x_{m-1/2}) \\phi_i(x_{m-1/2})$。在单元中点，局部基函数的值均为$1/2$。这导致对称的单元矩阵：$M^{(m)} \\approx \\frac{h \\cdot b(x_{m-1/2})}{4} \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}$。\n- 单元载荷向量$b^{(m)}$的项为$b_i^{(m)} \\approx h \\cdot f(x_{m-1/2}) \\phi_i(x_{m-1/2})$。这得到$b^{(m)} \\approx \\frac{h \\cdot f(x_{m-1/2})}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n全局矩阵$K$和$M$是通过对这些对称的单元贡献求和而形成的。对称矩阵之和是对称的，所以$K$和$M$是对称的。因此，系统矩阵$A = K - k^2 M$也是对称的，即$A = A^\\top$。\n\n现在，我们来推导离散互易恒等式。考虑两个具有相同矩阵$A$但不同源$b^{(1)}$和$b^{(2)}$的离散问题：\n1. $A U^{(1)} = b^{(1)}$\n2. $A U^{(2)} = b^{(2)}$\n我们想证明$(U^{(2)})^\\top b^{(1)} = (U^{(1)})^\\top b^{(2)}$。\n从左侧开始，代入第一个方程中的$b^{(1)}$：\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(2)}\\right)^\\top \\left(A U^{(1)}\\right)\n$$\n使用转置性质$(XY)^\\top = Y^\\top X^\\top$，我们可以将其写为：\n$$\n\\left(U^{(2)}\\right)^\\top A U^{(1)} = \\left(U^{(2)}\\right)^\\top A^\\top U^{(1)} = \\left(A U^{(2)}\\right)^\\top U^{(1)}\n$$\n这一步依赖于$A$的对称性，即$A = A^\\top$。现在，从第二个方程代入$A U^{(2)} = b^{(2)}$：\n$$\n\\left(A U^{(2)}\\right)^\\top U^{(1)} = \\left(b^{(2)}\\right)^\\top U^{(1)}\n$$\n最后，由于行向量和列向量的乘积是一个标量，它等于其自身的转置。$(b^{(2)})^\\top U^{(1)}$的转置是$(U^{(1)})^\\top b^{(2)}$。因此，\n$$\n\\left(U^{(2)}\\right)^\\top b^{(1)} = \\left(U^{(1)}\\right)^\\top b^{(2)}\n$$\n这个恒等式在代数层面上是精确成立的。任何数值偏差都必然源于诸如非对称矩阵组装（程序错误）、两次求解使用不同矩阵或线性求解器中的浮点舍入误差等。所提出的数值测试旨在测量这种偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not strictly needed, numpy is sufficient\n\ndef run_reciprocity_test(N, k, a_func, b_func, f1_func, f2_func, A_perturbation=None):\n    \"\"\"\n    Assembles and solves two 1D Helmholtz problems using FEM and calculates the reciprocity discrepancy.\n    \n    Args:\n        N (int): Number of elements.\n        k (float): Wavenumber.\n        a_func (callable): Coefficient function a(x).\n        b_func (callable): Coefficient function b(x).\n        f1_func (callable): Source function f1(x).\n        f2_func (callable): Source function f2(x).\n        A_perturbation (tuple, optional): A tuple (row, col, value) to perturb the matrix A for the \n                                          second solve. Defaults to None.\n    \n    Returns:\n        float: The reciprocity discrepancy |(U2)^T b1 - (U1)^T b2|.\n    \"\"\"\n    \n    # Mesh properties\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    \n    # Initialize global stiffness and mass matrices, and load vectors\n    # Full size (N+1)x(N+1) to simplify assembly indexing\n    K = np.zeros((N + 1, N + 1))\n    M = np.zeros((N + 1, N + 1))\n    b1 = np.zeros(N + 1)\n    b2 = np.zeros(N + 1)\n    \n    # Element properties (constant for all elements with linear basis functions)\n    # Element stiffness matrix for a(x)=1, h=1\n    k_elem_base = np.array([[1, -1], [-1, 1]])\n    # Element mass matrix for b(x)=1, h=1\n    m_elem_base = np.array([[1/4, 1/4], [1/4, 1/4]])\n    \n    # Loop over elements to assemble the system\n    for i in range(N):\n        # Global indices for the current element's nodes\n        idx0, idx1 = i, i + 1\n        \n        # Midpoint of the element\n        midpoint = nodes[idx0] + h / 2.0\n        \n        # Evaluate coefficients and sources at the midpoint\n        a_mid = a_func(midpoint)\n        b_mid = b_func(midpoint)\n        f1_mid = f1_func(midpoint)\n        f2_mid = f2_func(midpoint)\n        \n        # Scale element matrices by coefficients and mesh size\n        k_elem = (a_mid / h) * k_elem_base\n        m_elem = (b_mid * h) * m_elem_base\n        \n        # Assemble element matrices into global matrices\n        K[idx0:idx1+1, idx0:idx1+1] += k_elem\n        M[idx0:idx1+1, idx0:idx1+1] += m_elem\n        \n        # Assemble element load vectors\n        b1[idx0] += h * f1_mid * 0.5\n        b1[idx1] += h * f1_mid * 0.5\n        b2[idx0] += h * f2_mid * 0.5\n        b2[idx1] += h * f2_mid * 0.5\n\n    # Form the system matrix A\n    A = K - k**2 * M\n    \n    # Enforce homogeneous Dirichlet boundary conditions by using only interior nodes\n    # The interior system involves nodes 1 to N-1\n    A_int = A[1:N, 1:N]\n    b1_int = b1[1:N]\n    b2_int = b2[1:N]\n    \n    # --- Solve for U1 ---\n    # The matrix for the first solve is always the unperturbed one\n    U1 = np.linalg.solve(A_int, b1_int)\n    \n    # --- Solve for U2 ---\n    # The matrix for the second solve might be perturbed\n    A2_int = A_int.copy()\n    if A_perturbation:\n        row, col, value = A_perturbation\n        A2_int[row, col] += value\n    \n    U2 = np.linalg.solve(A2_int, b2_int)\n    \n    # --- Calculate reciprocity discrepancy ---\n    # r = | (U2)^T @ b1 - (U1)^T @ b2 |\n    discrepancy = np.abs(U2.T @ b1_int - U1.T @ b2_int)\n    \n    return discrepancy\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the reciprocity check.\n    \"\"\"\n    \n    # Test 1: Happy path, smooth coefficients and sources\n    N1 = 64\n    k1 = 7.3\n    a1 = lambda x: 1.0\n    b1 = lambda x: 1.0\n    f1_1 = lambda x: np.sin(3 * np.pi * x)\n    f2_1 = lambda x: np.cos(5 * np.pi * x)\n    \n    # Test 2: Heterogeneous coefficient, smooth localized sources\n    N2 = 64\n    k2 = 4.2\n    a2 = lambda x: 3.0 if x >= 0.5 else 1.0\n    b2 = lambda x: 1.0\n    f1_2 = lambda x: np.exp(-100 * (x - 0.3)**2)\n    f2_2 = lambda x: np.exp(-120 * (x - 0.7)**2)\n    \n    # Test 3: Boundary-size mesh, coarse discretization edge case\n    N3 = 2\n    k3 = 2.0\n    a3 = lambda x: 1.0\n    b3 = lambda x: 1.0\n    f1_3 = lambda x: x * (1 - x)\n    f2_3 = lambda x: 1 - 2 * x\n\n    # Test 4: Intentional reciprocity violation via a skew perturbation\n    N4 = 64 # Same as Test 1\n    k4 = 7.3\n    a4 = lambda x: 1.0\n    b4 = lambda x: 1.0\n    f1_4 = lambda x: np.sin(3 * np.pi * x)\n    f2_4 = lambda x: np.cos(5 * np.pi * x)\n    # The interior matrix indices are 0...N-2.\n    # Node p = floor(N/2) = 32 has matrix index 32-1=31.\n    # Node p+1 = 33 has matrix index 33-1=32.\n    perturbation = (31, 32, 1e-2)\n\n    test_cases = [\n        (N1, k1, a1, b1, f1_1, f2_1, None),\n        (N2, k2, a2, b2, f1_2, f2_2, None),\n        (N3, k3, a3, b3, f1_3, f2_3, None),\n        (N4, k4, a4, b4, f1_4, f2_4, perturbation),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_reciprocity_test(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3360923"}, {"introduction": "使用有限元法高效求解高频波问题，关键在于自适应网格加密（AMR）技术。这项概念性练习将挑战您批判性地设计一种标记策略，以有效应对亥姆霍兹方程模拟中臭名昭著的“污染误差”问题。通过对不同策略的分析与权衡，您将能够磨练自己的专业直觉，学会在由相位误差主导的区域精确地指导网格细化。[@problem_id:2539330]", "problem": "考虑非齐次亥姆霍兹问题：求 $u:\\Omega \\to \\mathbb{R}$，其中 $\\Omega \\subset \\mathbb{R}^d$ 是一个有界Lipschitz域，且 $d \\in \\{1,2,3\\}$，使得\n$$\n-\\Delta u - k(\\boldsymbol{x})^2 u = f \\quad \\text{in } \\Omega, \n\\qquad \nu = 0 \\quad \\text{on } \\partial \\Omega,\n$$\n其中波数 $k:\\Omega \\to \\mathbb{R}_+$ 是分片光滑且严格为正的，并且 $f \\in L^2(\\Omega)$。其弱形式为：求 $u \\in H_0^1(\\Omega)$，使得\n$$\na(u,v) = \\ell(v) \\quad \\forall v \\in H_0^1(\\Omega),\n$$\n其中\n$$\na(u,v) := \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\boldsymbol{x} - \\int_{\\Omega} k(\\boldsymbol{x})^2 \\, u \\, v \\, \\mathrm{d}\\boldsymbol{x},\n\\qquad\n\\ell(v) := \\int_{\\Omega} f \\, v \\, \\mathrm{d}\\boldsymbol{x}.\n$$\n令 $V_h \\subset H_0^1(\\Omega)$ 为一个在形状正则的三角剖分 $\\mathcal{T}_h$ 上、多项式次数为 $p \\in \\mathbb{N}$ 的协调有限元法(FEM)空间，并令 $u_h \\in V_h$ 求解\n$$\na(u_h,v_h) = \\ell(v_h) \\quad \\forall v_h \\in V_h.\n$$\n定义单元残差和内部边跳跃残差为\n$$\nR_T := f + \\Delta u_h + k(\\boldsymbol{x})^2 u_h \\quad \\text{in } T \\in \\mathcal{T}_h,\n\\qquad\nJ_e := \\llbracket \\nabla u_h \\cdot \\boldsymbol{n}_e \\rrbracket \\quad \\text{on interior edge/face } e,\n$$\n以及标准的基于残差的局部指示子\n$$\n\\eta_T^2 := h_T^2 \\, \\| R_T \\|_{0,T}^2 + \\sum_{e \\subset \\partial T \\cap \\mathcal{E}_h^{\\mathrm{int}}} h_e \\, \\| J_e \\|_{0,e}^2,\n$$\n其中使用了单元直径 $h_T$、边/面直径 $h_e$ 和破碎 $L^2$-范数的通常记号。在不定的亥姆霍兹问题中，即使 $\\eta_T$ 不大，前渐近污染(相位)误差也可能主导总误差。考虑局部解析度参数\n$$\n\\kappa_T := \\frac{k_T \\, h_T}{p+1},\n\\qquad \nk_T := \\left(\\frac{1}{|T|} \\int_T k(\\boldsymbol{x})^2 \\, \\mathrm{d}\\boldsymbol{x} \\right)^{1/2},\n$$\n并注意 $k(\\boldsymbol{x})$ 的快速空间变化可能会引起额外的局部位相失配。标准的体(Dörfler)标记方法选择一个最小集 $\\mathcal{M} \\subset \\mathcal{T}_h$，使得对于给定的比例 $\\theta \\in (0,1)$，\n$$\n\\sum_{T \\in \\mathcal{M}} \\eta_T^2 \\ge \\theta \\sum_{T \\in \\mathcal{T}_h} \\eta_T^2。\n$$\n\n下列哪种策略在标记步骤中最恰当地考虑了局部波数变化，以便在相位误差占主导的区域优先进行加密，同时保持在 $h$-加密框架内？\n\nA. 使用标准的体标记，采用如上定义的、独立于 $k(\\boldsymbol{x})$ 的 $\\eta_T$，因为跳跃项 $J_e$ 已经捕捉了相位误差。\n\nB. 增强指示子以放大不良的局部解析度和系数变化，例如，\n$$\n\\widetilde{\\eta}_T^2 := \\bigl(1 + \\alpha \\, \\kappa_T^q \\bigr) \\, \\eta_T^2 \\;+\\; \\beta \\, h_T^2 \\, \\|\\nabla k\\|_{0,T}^2 \\, \\|u_h\\|_{0,T}^2,\n$$\n其中 $\\alpha0$，$q \\ge 1$ 和 $\\beta0$ 是用户选择的常数，然后使用 $\\widetilde{\\eta}_T$ 应用体标记。这针对的是 $k_T$ 较大或 $\\|\\nabla k\\|_{0,T}$ 较大的区域，在这些区域相位误差预计会很显著。\n\nC. 优先粗化 $\\kappa_T$ 大的单元以减少污染累积，因为较少的自由度限制了相位滞后。\n\nD. 标记数据振荡项最小的单元，因为最小化数据振荡可以独立于 $k(\\boldsymbol{x})$ 地抑制色散。\n\nE. 忽略残差，仅根据面跳跃进行标记，即选择与 $\\|J_e\\|_{0,e}$ 最大的边相邻的单元，因为色散误差是一种单元间现象。\n\n选择最佳答案。从变分形式和残差结构出发，证明你的选择，解释局部波数变化如何进入后验指示子和标记决策，以及所提出的策略如何与在相位误差主导区域进行加密保持一致。常数 $\\alpha$、$q$ 和 $\\beta$ 允许是独立于 $h_T$ 和 $k_T$ 的通用正常数。", "solution": "我们从弱形式和后验残差指示子的定义开始。有限元误差 $e := u - u_h$ 满足Galerkin正交性\n$$\na(e,v_h) = 0 \\quad \\forall v_h \\in V_h,\n$$\n以及分布形式的残差表示\n$$\na(e,v) = \\sum_{T \\in \\mathcal{T}_h} \\int_T R_T \\, v \\, \\mathrm{d}\\boldsymbol{x} - \\sum_{e \\in \\mathcal{E}_h^{\\mathrm{int}}} \\int_e J_e \\, v \\, \\mathrm{d}s \\quad \\forall v \\in H_0^1(\\Omega).\n$$\n对于二阶椭圆问题，经典的基于残差的后验理论将能量误差与单元量 $h_T \\|R_T\\|_{0,T}$ 和 $h_e^{1/2} \\|J_e\\|_{0,e}$ 联系起来，对于某些与网格无关的常数 $C_{\\mathrm{rel}}, C_{\\mathrm{eff}}  0$，通常得到\n$$\n\\| e \\|_{1,\\Omega} \\le C_{\\mathrm{rel}} \\left( \\sum_{T \\in \\mathcal{T}_h} \\eta_T^2 \\right)^{1/2},\n\\qquad\n\\left( \\sum_{T \\in \\mathcal{T}_h} \\eta_T^2 \\right)^{1/2} \\le C_{\\mathrm{eff}} \\left( \\| e \\|_{1,\\Omega} + \\operatorname{osc}(f,k; \\mathcal{T}_h) \\right),\n$$\n其中 $\\| \\cdot \\|_{1,\\Omega}$ 表示 $H^1$-半范数，$\\operatorname{osc}$ 表示数据振荡。然而，对于具有大波数 $k(\\boldsymbol{x})$ 的不定亥姆霍兹算子，前渐近污染(色散或相位)误差可能主导能量误差。这种污染不纯粹是局部残差现象；更确切地说，它反映了连续和离散色散关系之间的失配，并且取决于局部解析度参数\n$$\n\\kappa_T := \\frac{k_T \\, h_T}{p+1},\n\\qquad \nk_T := \\left(\\frac{1}{|T|} \\int_T k(\\boldsymbol{x})^2 \\, \\mathrm{d}\\boldsymbol{x} \\right)^{1/2}.\n$$\n启发式地讲，当 $\\kappa_T$ 很大时，即使 $\\eta_T$ 不大，离散解 $u_h$ 对局部波长的解析也不足，并会累积相位误差。此外，当 $k(\\boldsymbol{x})$ 快速变化时，局部平面波方向和相位会跨单元发生变化，引入额外的相位失配，而这可能无法仅靠残差大小来充分捕捉。梯度 $\\nabla k$ 提供了一种衡量介质变化的自然局部度量。\n\n因此，将两种效应纳入标记准则是符合原理的：\n\n1.  由于相对于 $p$ 而言，$k_T$ 和 $h_T$ 较大导致的局部解析度差，由 $\\kappa_T$ 量化。\n\n2.  $k(\\boldsymbol{x})$ 的快速空间变化，由 $T$ 上的 $\\nabla k$ 的范数量化。\n\n在保持 $h$-加密策略的同时，编码这两种效应的一个简单方法是，用一个随 $\\kappa_T$ 递增的因子和一个与 $\\|\\nabla k\\|_{0,T}$ 成比例的项来增强残差指示子。例如，定义\n$$\n\\widetilde{\\eta}_T^2 := \\bigl(1 + \\alpha \\, \\kappa_T^q \\bigr) \\, \\eta_T^2 \\;+\\; \\beta \\, h_T^2 \\, \\|\\nabla k\\|_{0,T}^2 \\, \\|u_h\\|_{0,T}^2,\n$$\n其中 $\\alpha0$，$q \\ge 1$ 和 $\\beta0$ 是用户选择的常数。选择乘法因子 $(1 + \\alpha \\kappa_T^q)$ 提高了具有较大 $\\kappa_T$ 的单元的优先级，这些单元易受相位误差影响。加性项 $\\beta \\, h_T^2 \\, \\|\\nabla k\\|_{0,T}^2 \\, \\|u_h\\|_{0,T}^2$ 针对的是系数在 $T$ 上变化显著的区域，这是局部变化的相速度（可能加剧色散）的一个代理指标。与 $h_T$ 和 $L^2$-范数的缩放关系与残差估计子中的量纲考虑是一致的：$h_T$ 乘以一个体积量，会产生一个与能量范数界相当的贡献。\n\n然后，用 $\\widetilde{\\eta}_T$ 应用体(Dörfler)标记会选择一个最小集 $\\mathcal{M}$，使得\n$$\n\\sum_{T \\in \\mathcal{M}} \\widetilde{\\eta}_T^2 \\ge \\theta \\sum_{T \\in \\mathcal{T}_h} \\widetilde{\\eta}_T^2,\n$$\n这会优先加密传统残差较大或局部解析度和系数变化表明存在相位主导误差的区域。这与相位误差的物理和数值根源相一致，并保持在 $h$-加密范式内。\n\n我们现在分析每个选项。\n\n选项 A. 使用仅基于标准残差的 $\\eta_T$ 忽略了对 $k(\\boldsymbol{x})$ 的显式依赖，除了它出现在 $R_T = f + \\Delta u_h + k^2 u_h$ 中。虽然 $R_T$ 确实包含 $k^2 u_h$，但它无法区分一个中等大小的残差是出现在一个解析良好的低 $k$ 区域，还是出现在一个解析不足的高 $k$ 区域；此外，即使 $\\eta_T$ 不大，由于局部残差大小未能捕捉到的色散失配，污染误差仍可能很显著。跳跃项 $J_e$ 主要衡量单元间的通量平衡，但它们本身并不能诊断出相对于局部波长的解析不足。因此，该策略没有专门针对相位误差。结论：不正确。\n\n选项 B. 所提出的 $\\widetilde{\\eta}_T$ 通过 $\\|\\nabla k\\|_{0,T}$ 结合了局部解析度参数 $\\kappa_T$ 和系数变化，从而精确地放大了预期相位误差占主导地位区域的指示子：即 $k_T$ 相对于 $h_T$ 和 $p$ 较大，或 $k(\\boldsymbol{x})$ 快速变化的区域。乘法因子 $(1+\\alpha \\kappa_T^q)$ 在 $\\kappa_T$ 上是单调的，而由 $h_T \\|\\nabla k\\|_{0,T}$ 缩放的加性项与系数变化通过数据振荡进入基于残差的界的方式是一致的。对 $\\widetilde{\\eta}_T$ 应用体标记产生了一种 $h$-加密策略，该策略尊重变分结构和相位误差的来源。结论：正确。\n\n选项 C. 在 $\\kappa_T$ 大的地方进行粗化会增加 $h_T$，从而增加 $\\kappa_T$，这会加剧解析不足和相位误差。这与维持每个波长足够点数的要求相矛盾。在亥姆霍兹问题中，粗化不能减少色散误差。结论：不正确。\n\n选项 D. 最小化或优先考虑数据振荡小的单元并不能解决相位(色散)误差的根本原因，这些误差与相对于波长的解析不足和系数变化有关，而不仅仅是与振荡项的大小有关。在振荡最小的地方进行标记会误导加密方向。结论：不正确。\n\n选项 E. 面跳跃 $J_e$ 量化了单元间的通量不平衡，是一致性残差估计子的一部分。然而，色散误差并不仅限于界面；它是一种体相位失配，取决于局部波长解析度($\\kappa_T$)和介质变化。忽略体积残差 $R_T$ 和对 $k(\\boldsymbol{x})$ 的依赖性，无法可靠地针对相位主导的区域。结论：不正确。\n\n因此，在给定的选项中，选项 B 中的策略最好地捕捉了局部波数变化对标记的影响，并在相位误差主导的区域优先进行加密，所有这些都在 $h$-加密框架内完成。", "answer": "$$\\boxed{B}$$", "id": "2539330"}]}