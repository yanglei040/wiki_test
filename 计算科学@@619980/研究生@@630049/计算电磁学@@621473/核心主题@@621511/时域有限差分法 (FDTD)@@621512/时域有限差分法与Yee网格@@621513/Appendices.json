{"hands_on_practices": [{"introduction": "我们通过解决 FDTD 模拟中的一个基本问题来开始我们的实践练习：如何在不引入虚假反射的情况下截断计算域。本练习将引导您直接从波动方程推导出一阶 Mur 吸收边界条件（ABC）。通过将此条件离散化并分析其反射系数作为入射角的函数，您将对局部 ABC 的工作原理及其固有的局限性（特别是对于非垂直入射的波）有基本的了解。该分析是理解为何需要更先进吸收层的关键第一步。[@problem_id:3353919]", "problem": "在 Yee 网格上使用三维时域有限差分 (FDTD) 方法来模拟电磁波在自由空间中以光速 $c$ 的传播。计算域的一个平面由一个旨在最小化反射的吸收边界所界定。考虑一个平面边界上的单个切向电场分量 $E_{t}(x,y,z,t)$，该边界的外法线方向沿 $+x$ 方向。空间步长为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$，时间步长为 $\\Delta t$，其选择满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件。\n\n(a) 从该边界附近自由空间中 $E_{t}(x,t)$ 的一维无损波动方程出发，将其分解为单向波动方程，并仅保留对应于穿过边界离开计算域的出射波的分量，推导出一阶局部吸收边界条件 (ABC)，表示为边界上 $E_{t}$ 的时间导数和法向空间导数之间的一阶关系。然后，使用与法线方向上的 Yee 交错网格和前向时间步进一致的一阶精度单边有限差分，推导出显式边界更新，该更新关联了邻近边界平面的前两个网格点上的采样值。用 Courant 数 $S_{x} = c \\Delta t / \\Delta x$ 表示你的结果。\n\n(b) 将 (a) 部分的结果推广到完整的三维边界面，方法是对边界平面上的每对切向指数 $(j,k)$ 逐点应用相同的一维更新，在法线方向上使用单边差分，并保留切向电场分量的 Yee 交错结构。\n\n(c) 现在考虑一个角频率为 $\\omega$ 的时谐平面波，在自由空间中从计算域内部以相对于边界面法线（$x$ 轴）的极角 $\\theta$ 入射到边界平面上，方位角任意。在场局部具有形式 $\\exp\\!\\big(i(k_{x} x + k_{y} y + k_{z} z - \\omega t)\\big)$ 且 $k = \\omega/c$ 的连续平面近似下，将 (a) 部分推导的一阶 ABC 应用于边界上入射波和反射波的叠加。求解复反射系数作为 $\\theta$ 的函数。\n\n请以反射系数的幅值作为入射极角 $\\theta$（单位为弧度）的函数的单个闭合形式解析表达式提供你的最终答案，其中不包含其他变量或参数。不要进行任何数值取整。", "solution": "该问题经评估有效，因为它在计算电磁学方面具有科学依据，问题提法得当且客观。它提出了一个关于时域有限差分法吸收边界条件推导和分析的标准、多部分练习。该问题是自包含的，并为得出唯一解提供了清晰的路径。\n\n(a) 一阶吸收边界条件的推导及其离散化\n\n我们从自由空间中传播的切向电场分量 $E_t(x,t)$ 的一维无损波动方程开始：\n$$ \\frac{\\partial^2 E_t}{\\partial x^2} - \\frac{1}{c^2} \\frac{\\partial^2 E_t}{\\partial t^2} = 0 $$\n其中 $c$ 是光速。该微分算子可以分解为：\n$$ \\left( \\frac{\\partial}{\\partial x} - \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) \\left( \\frac{\\partial}{\\partial x} + \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) E_t = 0 $$\n该分解将波动方程分离为两个一阶单向波动方程。项 $\\left( \\frac{\\partial}{\\partial x} + \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) E_t = 0$ 对应于形式为 $f(x-ct)$ 的波，其在 $+x$ 方向传播。项 $\\left( \\frac{\\partial}{\\partial x} - \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) E_t = 0$ 对应于形式为 $g(x+ct)$ 的波，其在 $-x$ 方向传播。\n\n计算域由一个外法线在 $+x$ 方向的边界平面终止。为了吸收离开计算域的波，我们必须防止反射。一个理想的吸收边界条件 (ABC) 应该对出射波是透明的。出射波是在 $+x$ 方向传播的波。因此，我们强制要求边界处的场必须满足纯出射波的单向波动方程：\n$$ \\frac{\\partial E_t}{\\partial x} + \\frac{1}{c} \\frac{\\partial E_t}{\\partial t} = 0 $$\n这是一阶局部吸收边界条件。\n\n为了推导显式更新规则，我们在 FDTD 网格上对此方程进行离散化。设 $x$ 方向的网格点由 $i$ 索引，使得 $x = i \\Delta x$。设离散时间步长由 $n$ 索引，使得 $t = n \\Delta t$。切向场分量表示为 $E_t(i\\Delta x, n\\Delta t) \\equiv E_t^n[i]$。\n设边界位于网格索引 $i=I_{max}$ 处。我们需要找到该边界点在下一个时间步的值 $E_t^{n+1}[I_{max}]$。\n\n按照规定，我们使用一阶精度的有限差分来近似导数。我们对时间导数使用前向差分，对空间导数使用单边后向差分，两者都在边界位置 $(x=I_{max}\\Delta x, t=n\\Delta t)$ 进行评估：\n$$ \\frac{\\partial E_t}{\\partial t} \\approx \\frac{E_t^{n+1}[I_{max}] - E_t^n[I_{max}]}{\\Delta t} $$\n$$ \\frac{\\partial E_t}{\\partial x} \\approx \\frac{E_t^n[I_{max}] - E_t^n[I_{max}-1]}{\\Delta x} $$\n将这些近似值代入 ABC 中得到：\n$$ \\frac{E_t^n[I_{max}] - E_t^n[I_{max}-1]}{\\Delta x} + \\frac{1}{c} \\left( \\frac{E_t^{n+1}[I_{max}] - E_t^n[I_{max}]}{\\Delta t} \\right) = 0 $$\n该方案是显式的，因为空间导数在时间步 $n$ 进行评估，此时所有场值都是已知的。求解 $E_t^{n+1}[I_{max}]$：\n$$ \\frac{E_t^{n+1}[I_{max}] - E_t^n[I_{max}]}{\\Delta t} = -c \\frac{E_t^n[I_{max}] - E_t^n[I_{max}-1]}{\\Delta x} $$\n$$ E_t^{n+1}[I_{max}] = E_t^n[I_{max}] - \\frac{c \\Delta t}{\\Delta x} \\left( E_t^n[I_{max}] - E_t^n[I_{max}-1] \\right) $$\n使用 $x$ 方向的 Courant 数定义 $S_x = c \\Delta t / \\Delta x$，更新方程变为：\n$$ E_t^{n+1}[I_{max}] = E_t^n[I_{max}] - S_x \\left( E_t^n[I_{max}] - E_t^n[I_{max}-1] \\right) $$\n这可以重写为：\n$$ E_t^{n+1}[I_{max}] = (1 - S_x) E_t^n[I_{max}] + S_x E_t^n[I_{max}-1] $$\n这个显式更新规则使用当前时间步 $n$ 在边界点 $I_{max}$ 和相邻内部点 $I_{max}-1$ 的场值，来计算未来时间步 $n+1$ 在边界网格点 $I_{max}$ 的场值。\n\n(b) 推广到三维\n\n将此一维 ABC 推广到三维边界面，是通过在边界平面上的每个点独立应用相同的更新规则来实现的。切向电场分量，如 $E_y$ 和 $E_z$，位于由 $x = I_{max}\\Delta x$ 定义的 $y$-$z$ 平面上的离散点 $(j,k)$ 处。该更新规则逐点应用于每个切向位置。\n设离散切向场表示为 $E_t^n[i, j, k]$。对于 $i=I_{max}$ 处的边界，更新规则为：\n$$ E_t^{n+1}[I_{max}, j, k] = (1 - S_x) E_t^n[I_{max}, j, k] + S_x E_t^n[I_{max}-1, j, k] $$\n此方程应用于边界平面上所有相关的索引 $j$ 和 $k$，以及该平面上定义的每个切向场分量（$E_y$ 和 $E_z$），并遵循 Yee 网格的空间交错特性。\n\n(c) 反射系数分析\n\n为分析该边界条件的性能，我们将 (a) 部分的连续形式 ABC 应用于一个时谐平面波。为便于分析，设边界位于平面 $x=0$ 处，计算域位于区域 $x0$ 内。该 ABC 为：\n$$ \\left. \\left( \\frac{\\partial E_t}{\\partial x} + \\frac{1}{c} \\frac{\\partial E_t}{\\partial t} \\right) \\right|_{x=0} = 0 $$\n一个角频率为 $\\omega$ 的平面波从计算域内 ($x0$) 入射到边界上。波矢量 $\\mathbf{k}$ 的大小为 $k = \\omega/c$。入射极角 $\\theta$ 是 $\\mathbf{k}$ 与边界法线（$x$ 轴）之间的夹角。波矢量的分量为 $k_x = k \\cos\\theta$、$k_y = k \\sin\\theta \\cos\\phi$ 和 $k_z = k \\sin\\theta \\sin\\phi$，其中 $\\phi$ 是方位角。分析与 $\\phi$ 无关。朝正 $x$ 方向传播的入射波为：\n$$ E_{inc} = E_0 \\exp\\big(i(k_x x + k_y y + k_z z - \\omega t)\\big) $$\n该波在边界处被部分反射。反射波传播回计算域内（负 $x$ 方向）。根据边界处的相位匹配条件，反射波具有相同的频率 $\\omega$ 和切向波矢量分量 $k_y, k_z$。其法向波矢量分量必须是 $k'_x = -k_x = -k\\cos\\theta$。设 $R$ 为复反射系数。反射波为：\n$$ E_{refl} = R E_0 \\exp\\big(i(-k_x x + k_y y + k_z z - \\omega t)\\big) $$\n总场 $E_t$ 是入射场和反射场的叠加：\n$$ E_t(x,y,z,t) = E_0 \\left( \\exp(ik_x x) + R \\exp(-ik_x x) \\right) \\exp\\big(i(k_y y + k_z z - \\omega t)\\big) $$\n我们现在计算 ABC 所需的导数。\n$$ \\frac{\\partial E_t}{\\partial x} = E_0 \\left( ik_x \\exp(ik_x x) - ik_x R \\exp(-ik_x x) \\right) \\exp\\big(i(k_y y + k_z z - \\omega t)\\big) $$\n$$ \\frac{\\partial E_t}{\\partial t} = E_0 \\left( \\exp(ik_x x) + R \\exp(-ik_x x) \\right) (-i\\omega) \\exp\\big(i(k_y y + k_z z - \\omega t)\\big) $$\n在边界 $x=0$ 处评估这些导数，并代入 ABC 中：\n$$ ik_x E_0 (1-R) + \\frac{1}{c} \\left( -i\\omega E_0 (1+R) \\right) = 0 $$\n假设 $E_0 \\neq 0$ 且 $\\omega \\neq 0$，我们可以消去公因子 $iE_0$：\n$$ k_x (1-R) - \\frac{\\omega}{c} (1+R) = 0 $$\n代入 $k_x = k \\cos\\theta$ 和 $k = \\omega/c$：\n$$ k \\cos\\theta (1-R) - k (1+R) = 0 $$\n$$ \\cos\\theta (1-R) - (1+R) = 0 $$\n现在，我们求解反射系数 $R$：\n$$ \\cos\\theta - R \\cos\\theta - 1 - R = 0 $$\n$$ \\cos\\theta - 1 = R(1 + \\cos\\theta) $$\n$$ R(\\theta) = \\frac{\\cos\\theta - 1}{\\cos\\theta + 1} $$\n问题要求反射系数的幅值 $|R|$。由于入射角 $\\theta$ 的范围是 $[0, \\pi/2)$，$\\cos\\theta$ 是一个实数，满足 $0  \\cos\\theta \\le 1$。因此，$R$ 是实数。分子 $\\cos\\theta - 1$ 是非正的，分母 $\\cos\\theta + 1$ 是正的。因此，幅值为：\n$$ |R(\\theta)| = \\left| \\frac{\\cos\\theta - 1}{\\cos\\theta + 1} \\right| = \\frac{-(\\cos\\theta - 1)}{\\cos\\theta + 1} = \\frac{1 - \\cos\\theta}{1 + \\cos\\theta} $$\n使用三角半角恒等式 $1 - \\cos\\theta = 2 \\sin^2(\\theta/2)$ 和 $1 + \\cos\\theta = 2 \\cos^2(\\theta/2)$，这可以简化为：\n$$ |R(\\theta)| = \\frac{2\\sin^2(\\theta/2)}{2\\cos^2(\\theta/2)} = \\tan^2\\left(\\frac{\\theta}{2}\\right) $$\n该表达式给出了反射系数的幅值，纯粹是入射角 $\\theta$ 的函数。", "answer": "$$\\boxed{\\frac{1 - \\cos\\theta}{1 + \\cos\\theta}}$$", "id": "3353919"}, {"introduction": "一个现代的 FDTD 求解器必须兼具物理准确性和计算效率。最后的这项实践通过研究 Yee 核中的误差来源和依赖于硬件的性能瓶颈，将电磁理论与高性能计算（HPC）联系起来。您将推导并分析 FDTD 方案固有的数值色散，构建一个包含浮点舍入效应的相误差预算，并为 GPU 上的不同数据布局建立内存合并效率模型。这项练习提供了一个整体视角，揭示了数值精度和数据结构的选择如何直接影响大规模模拟的准确性和速度。[@problem_id:3353975]", "problem": "你需要设计、分析并实现一个计算实验，该实验将 Yee 有限差分时域 (FDTD) 内核中的图形处理单元 (GPU) 合并内存访问与数值色散和浮点精度联系起来。你的任务是从基本的电磁定律出发，在简化但科学一致的模型下，对相位误差和内存效率做出具体、可测试的预测。\n\n从一维空间中的无源宏观麦克斯韦方程组开始，该方程组适用于相对介电常数和相对磁导率均为1的线性、各向同性、均匀介质，并使用无量纲单位，使得光速 $c = 1$：\n- $\\nabla \\times \\mathbf{E} = -\\dfrac{\\partial \\mathbf{H}}{\\partial t}$,\n- $\\nabla \\times \\mathbf{H} = \\dfrac{\\partial \\mathbf{E}}{\\partial t}$,\n- $\\nabla \\cdot \\mathbf{E} = 0$,\n- $\\nabla \\cdot \\mathbf{H} = 0$.\n\n在一维空间中使用 Yee 有限差分时域 (FDTD) 方案（Yee 方案），采用交错网格，网格间距为 $\\Delta x$，时间步长为 $\\Delta t$，库朗数 $S = c \\,\\Delta t / \\Delta x$。在无量纲化中，固定 $c = 1$ 和 $\\Delta x = 1$，因此 $S = \\Delta t$。推导 Yee 方案的离散色散关系，并按如下方式定义相位误差度量。对于波数为 $k$（无量纲化的 $k$）的平面波，定义连续角频率 $\\omega_{\\mathrm{exact}}(k) = k$。从 Yee 更新中推导数值角频率 $\\omega_{\\mathrm{num}}(k, S)$。在传播时间 $T_{\\mathrm{prop}} = N_{\\mathrm{steps}} \\,\\Delta t$ 内，将色散引起的相位误差定义为 $\\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}}) = \\left|\\left(\\omega_{\\mathrm{num}}(k, S) - \\omega_{\\mathrm{exact}}(k)\\right) T_{\\mathrm{prop}}\\right|$。对于波数带 $k \\in [k_{\\min}, k_{\\max}]$，将最坏情况色散误差定义为 $\\max_{k \\in [k_{\\min}, k_{\\max}]} \\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}})$。\n\n接下来，为 Yee 更新建立一个浮点舍入误差预算。假设使用二进制浮点数，其单位舍入误差对于 32 位单精度为 $u_{32} = 2^{-24}$，对于 64 位双精度为 $u_{64} = 2^{-53}$。考虑两种计算模式：\n- 单精度：所有算术和存储均使用 32 位单精度。假设一个规范的一维 Yee 更新在每个时间步的每个空间位置引入 $r_{\\mathrm{single}} = 6$ 个单位舍入误差贡献，这些贡献在最坏情况下会相干地累加到相位误差中。\n- 混合精度：算术运算以 64 位双精度执行，而存储则以 32 位单精度进行，因此只有存储操作会舍入到单精度。假设这在每个时间步的每个空间位置引入 $r_{\\mathrm{mixed}} = 2$ 个单位舍入误差贡献，这些贡献在最坏情况下会相干地累加到相位误差中。\n\n在最坏情况相干累积模型下，经过 $N_{\\mathrm{steps}}$ 次 Yee 更新后，由舍入引起的相位误差的界限为 $\\phi_{\\mathrm{round}} \\le N_{\\mathrm{steps}} \\, r \\, u$，其中 $r$ 和 $u$ 根据计算模式选择。将一个波数带上的总最坏情况相位误差定义为色散和舍入界限之和：$\\phi_{\\mathrm{total,wc}}([k_{\\min}, k_{\\max}]; S, N_{\\mathrm{steps}}, r, u) = \\max_{k \\in [k_{\\min}, k_{\\max}]} \\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}}) + N_{\\mathrm{steps}} \\, r \\, u$。所有相位和相位误差必须以弧度表示。\n\n最后，分析 Yee 内核的 GPU 内存合并，该内核一次读取一个场分量。考虑一个由 $W = 32$ 个并发线程组成的线程束 (warp)，每个线程从全局内存中加载一个元素。假设硬件内存事务段大小为 128 字节。按如下方式对合并效率进行建模。一个线程束发出 $m$ 个内存事务，$m$ 等于 $W$ 次加载所触及的不同 128 字节段的数量。将合并效率定义为 $\\eta = 1/m$。假设基地址是 128 字节对齐的。考虑两种内存布局：\n- 数组结构 (SoA)：为 $E_x, E_y, E_z, H_x, H_y, H_z$ 分别设置六个独立的数组。在固定的 $y, z$ 处沿 $x$ 方向读取 $E_x$ 时，连续的线程读取连续的 $E_x$ 元素。\n- 结构数组 (AoS)：每个单元一个结构数组，其中分量按 $(E_x, E_y, E_z, H_x, H_y, H_z)$ 的顺序交错存储。\n\n假设元素为 32 位（4 字节）或 64 位（8 字节）。一个线程束中的线程编号为 $t = 0, 1, \\dots, 31$，读取的地址为 $a_t = a_0 + t \\cdot s \\cdot b$，其中 $b$ 是元素大小（以字节为单位），$s$ 是步幅（以元素为单位）。对于 SoA，当沿 $x$ 方向读取单个场分量时，取 $s = 1$。对于 AoS，当读取单个场分量时，由于数据是交错的，取 $s = 6$。\n\n你的程序必须：\n- 推导并实现 Yee 方案的色散关系，并通过在 $k \\in [k_{\\min}, k_{\\max}]$ 上进行足够密集的均匀采样进行数值评估，计算一个波数带上的 $\\phi_{\\mathrm{disp}}$。\n- 实现舍入误差界限，并计算单精度和混合精度下的 $\\phi_{\\mathrm{total,wc}}$。\n- 实现合并效率模型，根据给定的 $(b, s)$ 以及固定的线程束和段参数计算 $\\eta$。\n\n角度单位必须是弧度。除上述无量纲定义外，不使用其他物理单位。\n\n测试套件和要求输出：\n实现以下十个测试用例，并将输出聚合为单行、逗号分隔的 Python 列表字面量。\n\n内存合并测试（输出为浮点数 $\\eta$）：\n- T1：AoS 布局，单精度元素大小 $b = 4$ 字节，步幅 $s = 6$。\n- T2：SoA 布局，单精度元素大小 $b = 4$ 字节，步幅 $s = 1$。\n- T3：SoA 布局，双精度元素大小 $b = 8$ 字节，步幅 $s = 1$。\n- T4：假设的未对齐步幅读取，单精度元素大小 $b = 4$ 字节，步幅 $s = 17$。\n\n相位误差预算测试（输出为布尔值，指示最坏情况总相位误差是否小于或等于阈值）：\n- T5：单精度，波数带 $k \\in [0.1\\pi, 0.5\\pi]$，库朗数 $S = 0.9$，步数 $N_{\\mathrm{steps}} = 50$，阈值 $\\phi_{\\mathrm{thr}} = 1.5$ 弧度。\n- T6：混合精度，波数带和参数与 T5 相同。\n- T7：单精度，波数带 $k \\in [0.1\\pi, 0.3\\pi]$，库朗数 $S = 1.0$，步数 $N_{\\mathrm{steps}} = 2000$，阈值 $\\phi_{\\mathrm{thr}} = 3 \\times 10^{-4}$ 弧度。\n- T8：混合精度，波数带和参数与 T7 相同。\n- T9：单精度，波数带 $k \\in [0.8\\pi, 0.95\\pi]$，库朗数 $S = 0.9$，步数 $N_{\\mathrm{steps}} = 50$，阈值 $\\phi_{\\mathrm{thr}} = 5.0$ 弧度。\n- T10：混合精度，波数带和参数与 T9 相同。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,...]”）。", "solution": "该问题要求在一维时域有限差分 (FDTD) 方法的背景下，分析连接数值色散、浮点误差和 GPU 内存访问模式。我将首先推导必要的理论模型，然后将它们应用于指定的测试用例。\n\n首先，我们推导 FDTD 更新方程和数值色散关系。问题从线性、各向同性、均匀介质中的无源麦克斯韦方程组开始，采用无量纲单位，其中光速 $c=1$，介电常数 $\\epsilon=1$，磁导率 $\\mu=1$。对于场 $E_y(x,t)$ 和 $H_z(x,t)$ 沿 x 轴传播的一维问题，旋度方程简化为：\n$$\n\\frac{\\partial E_y}{\\partial x} = -\\frac{\\partial H_z}{\\partial t}\n$$\n$$\n\\frac{\\partial H_z}{\\partial x} = -\\frac{\\partial E_y}{\\partial t}\n$$\nYee 方案在交错网格上离散化这些方程。设 $E_y$ 在空间位置 $i \\Delta x$ 和时间步长 $n \\Delta t$ 处求值，记为 $E_y^n[i]$。设 $H_z$ 在空间位置 $(i+1/2) \\Delta x$ 和时间步长 $(n+1/2) \\Delta t$ 处求值，记为 $H_z^{n+1/2}[i+1/2]$。使用中心差分，更新方程为：\n$$\n\\frac{E_y^n[i+1] - E_y^n[i]}{\\Delta x} = -\\frac{H_z^{n+1/2}[i+1/2] - H_z^{n-1/2}[i+1/2]}{\\Delta t}\n$$\n$$\n\\frac{H_z^{n+1/2}[i+1/2] - H_z^{n+1/2}[i-1/2]}{\\Delta x} = -\\frac{E_y^{n+1}[i] - E_y^n[i]}{\\Delta t}\n$$\n我们假设平面波解的形式为 $E_y^n[i] = E_0 e^{j(k i \\Delta x - \\omega_{\\mathrm{num}} n \\Delta t)}$ 和 $H_z^{n+1/2}[i+1/2] = H_0 e^{j(k (i+1/2) \\Delta x - \\omega_{\\mathrm{num}} (n+1/2) \\Delta t)}$，其中 $k$ 是波数，$\\omega_{\\mathrm{num}}$ 是数值角频率。将这些代入两个更新方程，得到一个由两个代数方程组成的系统。将它们联立消去振幅 $E_0$ 和 $H_0$，得到数值色散关系：\n$$\n\\sin\\left(\\frac{\\omega_{\\mathrm{num}} \\Delta t}{2}\\right) = \\frac{c \\Delta t}{\\Delta x} \\sin\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n使用问题的无量纲化（$c=1$, $\\Delta x=1$）和库朗数 $S = c \\Delta t / \\Delta x = \\Delta t$ 的定义，该关系简化为：\n$$\n\\sin\\left(\\frac{\\omega_{\\mathrm{num}} S}{2}\\right) = S \\sin\\left(\\frac{k}{2}\\right)\n$$\n求解 $\\omega_{\\mathrm{num}}$ 得：\n$$\n\\omega_{\\mathrm{num}}(k, S) = \\frac{2}{S} \\arcsin\\left( S \\sin\\left(\\frac{k}{2}\\right) \\right)\n$$\n此关系在 Courant-Friedrichs-Lewy (CFL) 稳定性条件 $S \\le 1$ 下有效，该条件确保反正弦函数的参数的绝对值不超过 1。精确的连续谱色散关系为 $\\omega_{\\mathrm{exact}}(k) = ck = k$。在传播时间 $T_{\\mathrm{prop}} = N_{\\mathrm{steps}} \\Delta t = N_{\\mathrm{steps}} S$ 内，由色散引起的相位误差为：\n$$\n\\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}}) = |\\left(\\omega_{\\mathrm{num}}(k, S) - k\\right) T_{\\mathrm{prop}}| = \\left|\\left(\\frac{2}{S} \\arcsin\\left( S \\sin\\left(\\frac{k}{2}\\right) \\right) - k\\right) N_{\\mathrm{steps}} S\\right|\n$$\n为了找到波数带 $[k_{\\min}, k_{\\max}]$ 上的最坏情况误差，我们必须最大化这个函数。对于 $S  1$，误差函数 $E(k) = k - \\omega_{\\mathrm{num}}(k, S)$ 随 $k$ 单调递增。其导数为 $E'(k) = 1 - (\\cos(k/2)) / \\sqrt{1 - S^2 \\sin^2(k/2)}$，对于 $S1$ 和 $k \\in (0, \\pi]$，该导数为正。因此，最大误差出现在 $k = k_{\\max}$ 处。对于 $S=1$ 的特殊情况，当 $|k| \\le \\pi$ 时，$\\omega_{\\mathrm{num}}(k, 1) = 2 \\arcsin(\\sin(k/2)) = k$，这意味着色散误差为零。\n\n接下来，我们构建总相位误差预算。由舍入引起的相位误差界限为 $\\phi_{\\mathrm{round}} = N_{\\mathrm{steps}} \\, r \\, u$。根据问题描述，对于单精度，我们使用 $r = r_{\\mathrm{single}} = 6$；对于混合精度，我们使用 $r = r_{\\mathrm{mixed}} = 2$。在这两种情况下，误差源都与 32 位表示有关（无论是通过算术运算还是存储），因此相关的单位舍入误差是单精度的 $u = u_{32} = 2^{-24}$。\n总最坏情况相位误差是最大色散误差和舍入误差界限之和：\n$$\n\\phi_{\\mathrm{total,wc}} = \\phi_{\\mathrm{disp}}(k_{\\max}; S, N_{\\mathrm{steps}}) + N_{\\mathrm{steps}} \\, r \\, u\n$$\n\n最后，我们对 GPU 内存合并效率进行建模。一个由 $W=32$ 个线程组成的线程束 (warp) 执行同步内存访问。硬件使用 128 字节的内存事务来服务这些请求。效率 $\\eta$ 是事务数量 $m$ 的倒数。线程 $t \\in [0, 31]$ 访问地址 $a_t = a_0 + t \\cdot s \\cdot b$，其中 $a_0$ 是基地址（假定为 128 字节对齐），$s$ 是元素步幅，$b$ 是元素大小（以字节为单位）。事务数量 $m$ 是该线程束触及的不同 128 字节内存段的数量。线程 $t$ 的段索引为 $\\lfloor a_t / 128 \\rfloor$。由于 $a_0$ 是 128 的倍数，这可以简化为 $q + \\lfloor (t \\cdot s \\cdot b) / 128 \\rfloor$，其中 $q$ 是某个整数。我们需要找出对于 $t \\in [0, 31]$，由 $\\lfloor (t \\cdot s \\cdot b) / 128 \\rfloor$ 生成的唯一整数值的数量。\n$$\nm = \\left| \\left\\{ \\left\\lfloor \\frac{t \\cdot s \\cdot b}{128} \\right\\rfloor \\mid t = 0, 1, \\dots, 31 \\right\\} \\right|\n$$\n效率则为 $\\eta = 1/m$。\n\n这些模型被实现用于解决十个测试用例。对于测试 T1-T4，我们计算 $\\eta$。对于测试 T5-T10，我们计算 $\\phi_{\\mathrm{total,wc}}$ 并将其与给定的阈值 $\\phi_{\\mathrm{thr}}$ 进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a multi-part problem involving GPU memory coalescing, FDTD numerical dispersion,\n    and floating-point error analysis.\n    \"\"\"\n\n    # Constants from the problem statement.\n    W = 32  # Warp size\n    SEGMENT_SIZE = 128  # Bytes\n    U_32 = 2**-24  # Unit roundoff for 32-bit single precision\n    R_SINGLE = 6\n    R_MIXED = 2\n\n    def compute_coalescing_efficiency(b, s):\n        \"\"\"\n        Computes the memory coalescing efficiency.\n\n        Args:\n            b (int): Element size in bytes.\n            s (int): Stride in elements.\n\n        Returns:\n            float: The coalescing efficiency eta.\n        \"\"\"\n        stride_in_bytes = s * b\n        segment_indices = set()\n        for t in range(W):\n            offset = t * stride_in_bytes\n            segment_index = offset // SEGMENT_SIZE\n            segment_indices.add(segment_index)\n        \n        m = len(segment_indices)\n        return 1.0 / m\n\n    def compute_total_phase_error(k_min, k_max, S, N_steps, r, u):\n        \"\"\"\n        Computes the total worst-case phase error.\n\n        Args:\n            k_min (float): Minimum wavenumber of the band.\n            k_max (float): Maximum wavenumber of the band.\n            S (float): Courant number.\n            N_steps (int): Number of time steps.\n            r (int): Number of unit roundoff contributions per step.\n            u (float): Unit roundoff value.\n\n        Returns:\n            float: The total worst-case phase error.\n        \"\"\"\n        # Dispersion error is monotonic with k, so the max is at k_max.\n        # Handle the special case S=1 (magic time step) where dispersion is zero\n        # for k in the principal Brillouin zone.\n        if S == 1.0 and k_max = np.pi:\n            max_phi_disp = 0.0\n        else:\n            # Argument for arcsin\n            arg = S * np.sin(k_max / 2.0)\n            if abs(arg) > 1.0:\n                # This would violate the CFL condition.\n                # The problem statement's cases are stable.\n                # Return infinity for unstable cases.\n                return float('inf')\n\n            omega_num = (2.0 / S) * np.arcsin(arg)\n            T_prop = N_steps * S\n            max_phi_disp = np.abs(omega_num - k_max) * T_prop\n\n        phi_round = N_steps * r * u\n        phi_total_wc = max_phi_disp + phi_round\n        \n        return phi_total_wc\n\n    test_cases = [\n        # T1: AoS, single precision\n        {'type': 'coalescing', 'b': 4, 's': 6},\n        # T2: SoA, single precision\n        {'type': 'coalescing', 'b': 4, 's': 1},\n        # T3: SoA, double precision\n        {'type': 'coalescing', 'b': 8, 's': 1},\n        # T4: Hypothetical misaligned stride\n        {'type': 'coalescing', 'b': 4, 's': 17},\n        # T5: Single precision, S=0.9\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.5 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_SINGLE, 'u': U_32, 'thr': 1.5},\n        # T6: Mixed precision, S=0.9\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.5 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_MIXED, 'u': U_32, 'thr': 1.5},\n        # T7: Single precision, S=1.0\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.3 * np.pi,\n         'S': 1.0, 'N_steps': 2000, 'r': R_SINGLE, 'u': U_32, 'thr': 3e-4},\n        # T8: Mixed precision, S=1.0\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.3 * np.pi,\n         'S': 1.0, 'N_steps': 2000, 'r': R_MIXED, 'u': U_32, 'thr': 3e-4},\n        # T9: Single precision, high-k\n        {'type': 'phase_error', 'k_min': 0.8 * np.pi, 'k_max': 0.95 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_SINGLE, 'u': U_32, 'thr': 5.0},\n        # T10: Mixed precision, high-k\n        {'type': 'phase_error', 'k_min': 0.8 * np.pi, 'k_max': 0.95 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_MIXED, 'u': U_32, 'thr': 5.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'coalescing':\n            result = compute_coalescing_efficiency(case['b'], case['s'])\n        elif case['type'] == 'phase_error':\n            total_error = compute_total_phase_error(\n                case['k_min'], case['k_max'], case['S'],\n                case['N_steps'], case['r'], case['u']\n            )\n            result = total_error = case['thr']\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3353975"}]}