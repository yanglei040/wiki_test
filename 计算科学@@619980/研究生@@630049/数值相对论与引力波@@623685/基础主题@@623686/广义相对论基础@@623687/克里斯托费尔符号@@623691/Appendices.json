{"hands_on_practices": [{"introduction": "动手实践的第一步是掌握如何根据给定的度规直接计算克里斯托费尔符号。这项练习 [@problem_id:3467763] 提供了一个共形平直度规的解析上可解的案例，旨在训练您应用克里斯托费尔符号的基本公式。通过计算矢量场的协变散度，您将体验到这些符号如何将偏导数推广到弯曲空间中的协变导数。", "problem": "在数值相对论中使用的 $3$ 维柯西超曲面 $\\Sigma$ 上，考虑全局笛卡尔坐标 $(x,y,z)$ 和一个共形平坦空间度规 $\\gamma_{ij} = \\psi(x)^{4}\\,\\delta_{ij}$，其共形因子为 $\\psi(x) = 1 + \\lambda x^{2}$，其中 $\\lambda$ 是一个实常数，$\\delta_{ij}$ 是克罗内克δ函数。设一个逆变矢量场 $V^{i}$ 在这些坐标下的分量由 $V^{x} = x^{2}y$, $V^{y} = xy^{2}$ 和 $V^{z} = z^{3}$ 给出。仅使用黎曼流形上Levi-Civita联络的定义性质（无挠和度规适配）以及由 $\\gamma_{ij}$ 导出的空间协变导数的定义，计算空间联络的克里斯托费尔符号 $\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}$，然后用它们来计算该矢量场的空间协变散度 $D_{i}V^{i}$。将你的最终答案表示为关于 $x$、$y$、$z$ 和 $\\lambda$ 的单个精确解析表达式。不需要单位。", "solution": "任务是计算 $3$-度规 $\\gamma_{ij}$ 的Levi-Civita联络系数（克里斯托费尔符号），然后用它们来计算协变散度 $D_{i}V^{i}$。Levi-Civita联络的独特性质是其无挠性和度规适配性。在坐标中，这导出标准公式：\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk} = \\frac{1}{2}\\,\\gamma^{i\\ell}\\left(\\partial_{j}\\gamma_{k\\ell} + \\partial_{k}\\gamma_{j\\ell} - \\partial_{\\ell}\\gamma_{jk}\\right),\n$$\n其中 $\\gamma^{i\\ell}$ 是 $\\gamma_{i\\ell}$ 的逆。\n\n步骤 $1$：计算逆度规及其导数。给定的度规是 $\\gamma_{ij} = \\psi^{4}\\delta_{ij}$，其中 $\\psi = 1 + \\lambda x^{2}$。因此其逆为\n$$\n\\gamma^{ij} = \\psi^{-4}\\delta^{ij}.\n$$\n我们还有\n$$\n\\partial_{j}\\gamma_{k\\ell} = \\partial_{j}\\left(\\psi^{4}\\delta_{k\\ell}\\right) = 4\\psi^{3}(\\partial_{j}\\psi)\\,\\delta_{k\\ell}.\n$$\n因为 $\\psi$ 只依赖于 $x$，所以 $\\psi$ 唯一的非零导数是\n$$\n\\partial_{x}\\psi = 2\\lambda x,\\quad \\partial_{y}\\psi = 0,\\quad \\partial_{z}\\psi = 0.\n$$\n\n步骤 $2$：化简共形平坦形式下的克里斯托费尔符号。代入定义式：\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}\n= \\frac{1}{2}\\,\\psi^{-4}\\delta^{i\\ell}\\left[4\\psi^{3}(\\partial_{j}\\psi)\\delta_{k\\ell} + 4\\psi^{3}(\\partial_{k}\\psi)\\delta_{j\\ell} - 4\\psi^{3}(\\partial_{\\ell}\\psi)\\delta_{jk}\\right].\n$$\n提取公因式 $2\\psi^{-1}$ 并使用 $\\delta^{i\\ell}\\delta_{k\\ell} = \\delta^{i}{}_{k}$ 和 $\\delta^{i\\ell}\\partial_{\\ell}\\psi = \\partial^{i}\\psi$（其中 $\\partial^{i}\\psi \\equiv \\delta^{i\\ell}\\partial_{\\ell}\\psi$）：\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}\n= 2\\psi^{-1}\\left[(\\partial_{j}\\psi)\\delta^{i}{}_{k} + (\\partial_{k}\\psi)\\delta^{i}{}_{j} - \\delta_{jk}\\,\\partial^{i}\\psi\\right].\n$$\n等价地，用 $\\ln\\psi$ 表示，\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{jk}\n= 2\\left[(\\partial_{j}\\ln\\psi)\\delta^{i}{}_{k} + (\\partial_{k}\\ln\\psi)\\delta^{i}{}_{j} - \\delta_{jk}\\,\\partial^{i}\\ln\\psi\\right].\n$$\n由于 $\\partial_{x}\\ln\\psi = \\frac{\\partial_{x}\\psi}{\\psi} = \\frac{2\\lambda x}{1+\\lambda x^{2}}$ 且 $\\partial_{y}\\ln\\psi = \\partial_{z}\\ln\\psi = 0$，令\n$$\nL(x) \\equiv \\partial_{x}\\ln\\psi = \\frac{2\\lambda x}{1+\\lambda x^{2}}.\n$$\n那么，唯一的非零克里斯托费尔符号是通过代入沿 $x$ 方向的导数得到的。明确列出非零分量如下：\n- 对于 $i=x$：\n$$\n\\prescript{(3)}{}{\\Gamma}^{x}{}_{xx} = 2L,\\quad \\prescript{(3)}{}{\\Gamma}^{x}{}_{yy} = -2L,\\quad \\prescript{(3)}{}{\\Gamma}^{x}{}_{zz} = -2L.\n$$\n- 对于 $i=y$：\n$$\n\\prescript{(3)}{}{\\Gamma}^{y}{}_{xy} = \\prescript{(3)}{}{\\Gamma}^{y}{}_{yx} = 2L.\n$$\n- 对于 $i=z$：\n$$\n\\prescript{(3)}{}{\\Gamma}^{z}{}_{xz} = \\prescript{(3)}{}{\\Gamma}^{z}{}_{zx} = 2L.\n$$\n所有其他分量均为零。\n\n步骤 $3$：计算散度 $D_{i}V^{i}$。根据定义，\n$$\nD_{i}V^{i} = \\partial_{i}V^{i} + \\prescript{(3)}{}{\\Gamma}^{i}{}_{ik} V^{k}.\n$$\n首先计算 $V^{i}$ 各分量的偏导数：\n$$\n\\partial_{x}V^{x} = \\partial_{x}(x^{2}y) = 2xy,\\quad\n\\partial_{y}V^{y} = \\partial_{y}(xy^{2}) = 2xy,\\quad\n\\partial_{z}V^{z} = \\partial_{z}(z^{3}) = 3z^{2}.\n$$\n因此\n$$\n\\partial_{i}V^{i} = 2xy + 2xy + 3z^{2} = 4xy + 3z^{2}.\n$$\n接着计算缩并 $\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik}$。根据上面的表达式，\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik}\n= 2\\left[(\\partial_{i}\\ln\\psi)\\delta^{i}{}_{k} + (\\partial_{k}\\ln\\psi)\\delta^{i}{}_{i} - \\delta_{ik}\\,\\partial^{i}\\ln\\psi\\right].\n$$\n对 $i$ 求和，并使用 $\\delta^{i}{}_{i} = 3$、$\\delta_{ik}\\partial^{i}\\ln\\psi = \\partial_{k}\\ln\\psi$ 和 $\\sum_{i}(\\partial_{i}\\ln\\psi)\\delta^{i}{}_{k} = \\partial_{k}\\ln\\psi$，我们得到\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik} = 6\\,\\partial_{k}\\ln\\psi.\n$$\n由于只有 $\\partial_{x}\\ln\\psi = L$ 非零，我们有\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ix} = 6L,\\quad \\prescript{(3)}{}{\\Gamma}^{i}{}_{iy} = 0,\\quad \\prescript{(3)}{}{\\Gamma}^{i}{}_{iz} = 0.\n$$\n因此\n$$\n\\prescript{(3)}{}{\\Gamma}^{i}{}_{ik}V^{k} = (6L)\\,V^{x} = 6L\\,x^{2}y = 6\\left(\\frac{2\\lambda x}{1+\\lambda x^{2}}\\right)x^{2}y = \\frac{12\\lambda x^{3}y}{1+\\lambda x^{2}}.\n$$\n合并两部分的贡献：\n$$\nD_{i}V^{i} = \\left(4xy + 3z^{2}\\right) + \\frac{12\\lambda x^{3}y}{1+\\lambda x^{2}}.\n$$\n这就是所要求的用 $x$、$y$、$z$ 和 $\\lambda$ 表示的精确解析表达式。", "answer": "$$\\boxed{4xy+3z^{2}+\\frac{12\\lambda x^{3}y}{1+\\lambda x^{2}}}$$", "id": "3467763"}, {"introduction": "从解析计算过渡到数值实现是数值相对论的关键一步。在实际模拟中，所有量都在离散网格上计算，因此验证基本物理和几何恒等式是确保代码正确性的核心环节。这项练习 [@problem_id:3467809] 要求您编写一个程序，以数值方式验证度规相容性（即 $\\nabla_{a} g_{bc} = 0$），这是列维-奇维塔联络的定义性特征之一。通过在不同的时空度规下进行测试，此实践强化了理论与计算之间的联系。", "problem": "给定你的任务是，从第一性原理出发，证明对于与给定度规相容的唯一无挠联络，度规张量的协变导数为零；然后设计并实现一个数值一致性检验，该检验使用有限差分和数值计算的克里斯托费尔符号来验证此恒等式。你的工作必须以纯数学术语表达，并实现为一个程序，该程序为与数值相对论和引力波相关的一小组度规测试套件计算明确的数值残差。\n\n从微分几何和广义相对论中的基本定义出发，推导对于一个4维流形上的光滑度规张量 $g_{ab}$ 所关联的 Levi-Civita 联络，度规的协变导数消失，即 $ \\nabla_{a} g_{bc} = 0$。你的推导必须仅基于核心定义，例如对称、无挠联络的概念，作用于张量场（包括乘法法则）的协变微分法则，以及由度规引起的指标升降。不要将所求的恒等式 $ \\nabla_{a} g_{bc} = 0$ 作为前提；相反，应证明它是由从 $g_{ab}$ 构建的 Levi-Civita 联络的定义属性推导出来的。\n\n然后，设计一个数值程序，通过计算以下各项，在几个坐标系和度规中的单个点上验证恒等式 $ \\nabla_{a} g_{bc} = 0$：\n- 偏导数 $ \\partial_{a} g_{bc}$，通过步长为 $h$ 的中心有限差分计算，\n- 克里斯托费尔符号 $ \\Gamma^{a}{}_{bc}$，由 $g_{ab}$ 及其偏导数构建，\n- 以及数值计算的协变导数 $ \\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\Gamma^{d}{}_{ab}\\, g_{dc} - \\Gamma^{d}{}_{ac}\\, g_{bd}$。\n\n你的程序必须：\n- 将坐标表示为一个向量 $x^{a}$，其指标顺序为 $a \\in \\{0,1,2,3\\}$。\n- 根据每个测试用例选择的坐标图，使用指标约定 $0 \\mapsto t$，$1 \\mapsto x$ (或 $r$)，$2 \\mapsto y$ (或 $\\theta$)，$3 \\mapsto z$ (或 $\\phi$)；程序必须在声明的坐标图中明确实现度规。\n- 使用中心有限差分模板 $ \\partial_{a} g_{bc}(x) \\approx \\left[g_{bc}(x + h\\, e_{a}) - g_{bc}(x - h\\, e_{a})\\right]/(2h)$ 计算偏导数 $ \\partial_{a} g_{bc}$，其中 $e_{a}$ 是第 $a$ 个坐标方向上的单位向量，$h$ 是一个小的正实数。\n- 使用标准的 Levi-Civita 联络公式，根据 $g_{ab}$ 及其偏导数构建 $ \\Gamma^{a}{}_{bc}$。\n- 将残差计算为 $ \\nabla_{a} g_{bc}$ 在所有指标 $a,b,c \\in \\{0,1,2,3\\}$ 上的最大绝对分量。\n- 对每个测试用例，输出一个等于该残差的浮点数。这些浮点数是无量纲的。当出现角度坐标时，它们必须以弧度为单位。\n\n测试套件：\n实现以下四个测试用例，每个用例由一个度规、一个坐标图、一个求值点和一个有限差分步长 $h$ 指定。对于每种情况，在指定的点计算残差。\n\n- 情况1 (理想情况，笛卡尔坐标系下的常数度规)：\n  - 坐标：$(t,x,y,z)$。\n  - 度规：闵可夫斯基度规，符号为 $(-,+,+,+)$，$g_{ab} = \\mathrm{diag}(-1, 1, 1, 1)$。\n  - 求值点：$(t, x, y, z) = (0.0, 0.0, 0.0, 0.0)$。\n  - 步长：$h = 10^{-5}$。\n\n- 情况2 (具有平坦几何的非平凡坐标系，球坐标)：\n  - 坐标：$(t,r,\\theta,\\phi)$，其中 $\\theta$ 和 $\\phi$ 以弧度为单位。\n  - 度规：球坐标空间下的闵可夫斯基度规，$g_{ab} = \\mathrm{diag}(-1, 1, r^{2}, r^{2}\\sin^{2}\\theta)$。\n  - 求值点：$(t, r, \\theta, \\phi) = (0.0, 2.0, 0.7, 1.2)$。\n  - 步长：$h = 10^{-6}$。\n\n- 情况3 (横向无迹规范下的弱平面引力波)：\n  - 坐标：$(t,x,y,z)$。\n  - 度规：$ds^{2} = -dt^{2} + \\left[1 + h_{+}(u)\\right]dx^{2} + \\left[1 - h_{+}(u)\\right]dy^{2} + 2 h_{\\times}(u)\\,dx\\,dy + dz^{2}$，其中 $u = t - z$，$h_{+}(u) = A \\cos(k u)$，$h_{\\times}(u) = A \\sin(k u)$，参数 $A = 10^{-3}$ 和 $k = 2.0$。\n  - 求值点：$(t, x, y, z) = (0.4, 0.1, -0.1, 0.2)$。\n  - 步长：$h = 10^{-6}$。\n\n- 情况4 (类笛卡尔坐标系下的弯曲静态时空，各向同性史瓦西度规)：\n  - 坐标：$(t,x,y,z)$。\n  - 度规：$ds^{2} = -\\alpha^{2}(r)\\,dt^{2} + \\psi^{4}(r)\\left(dx^{2} + dy^{2} + dz^{2}\\right)$，其中 $r = \\sqrt{x^{2} + y^{2} + z^{2}}$，$\\psi(r) = 1 + \\dfrac{M}{2r}$，以及 $\\alpha(r) = \\dfrac{1 - \\dfrac{M}{2r}}{1 + \\dfrac{M}{2r}}$；取 $M = 1.0$。\n  - 求值点：$(t, x, y, z) = (0.0, 2.0, 1.0, 1.5)$。\n  - 步长：$h = 10^{-6}$。\n\n要求的最终输出格式：\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表的结果（例如，$[r_{1},r_{2},r_{3},r_{4}]$），其中 $r_{i}$ 是测试用例 $i$ 的浮点残差。不应打印任何其他文本。问题中出现的角度以弧度为单位。不需要物理单位，因为在上述构造中所有量都是无量纲的。", "solution": "用户提供的问题被评估为有效。这是一个在计算广义相对论领域内定义良好、有科学依据且客观的问题。它要求进行标准的理论推导，然后通过数值实现来验证黎曼几何的一个基本恒等式。所有定义、数据和约束都是自洽和一致的。\n\n### 理论推导：Levi-Civita 联络的度规相容性\n\n目标是证明对于 Levi-Civita 联络，度规张量的协变导数 $\\nabla_{a} g_{bc}$ 恒等于零。根据定义，Levi-Civita 联络是(伪)黎曼流形上唯一的既对称（无挠）又与度规相容的联络。另一种构造性方法是通过从度规导出的联络系数（克里斯托费尔符号）来定义联络，然后证明这两个性质成立。我们将遵循后一种路径，正如问题所指示的：我们将假定克里斯托费尔符号的标准公式，并证明度规相容性 $\\nabla_{a} g_{bc} = 0$ 是其直接推论。\n\n设 $g_{ab}$ 是一个4维流形上的光滑、对称、非退化的度规张量。Levi-Civita 联络的第二类克里斯托费尔符号 $\\Gamma^{a}{}_{bc}$ 根据度规及其偏导数 $\\partial_a g_{bc} \\equiv \\frac{\\partial g_{bc}}{\\partial x^a}$ 定义为：\n$$\n\\Gamma^{a}{}_{bc} = \\frac{1}{2} g^{ad} \\left( \\partial_b g_{dc} + \\partial_c g_{bd} - \\partial_d g_{bc} \\right)\n$$\n这里，$g^{ad}$ 是逆度规张量，满足 $g^{ad}g_{db} = \\delta^{a}_{b}$，其中 $\\delta^{a}_{b}$ 是克罗内克δ。\n\n像 $g_{bc}$ 这样的秩为(0,2)的张量场的协变导数由以下公式给出：\n$$\n\\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\Gamma^{d}{}_{ab} g_{dc} - \\Gamma^{d}{}_{ac} g_{bd}\n$$\n我们的目标是将 $\\Gamma^{a}{}_{bc}$ 的定义代入此表达式，并证明其恒为零。\n\n让我们分析涉及克里斯托费尔符号的两项：\n第一项是 $\\Gamma^{d}{}_{ab} g_{dc}$。代入 $\\Gamma^{d}{}_{ab}$ 的公式：\n$$\n\\Gamma^{d}{}_{ab} g_{dc} = \\left[ \\frac{1}{2} g^{de} \\left( \\partial_a g_{eb} + \\partial_b g_{ae} - \\partial_e g_{ab} \\right) \\right] g_{dc}\n$$\n利用性质 $g^{de}g_{dc} = \\delta^{e}_{c}$，我们对指标 $d$ 和 $e$ 进行缩并：\n$$\n\\Gamma^{d}{}_{ab} g_{dc} = \\frac{1}{2} \\delta^{e}_{c} \\left( \\partial_a g_{eb} + \\partial_b g_{ae} - \\partial_e g_{ab} \\right) = \\frac{1}{2} \\left( \\partial_a g_{cb} + \\partial_b g_{ac} - \\partial_c g_{ab} \\right)\n$$\n\n第二项是 $\\Gamma^{d}{}_{ac} g_{bd}$。代入 $\\Gamma^{d}{}_{ac}$ 的公式：\n$$\n\\Gamma^{d}{}_{ac} g_{bd} = \\left[ \\frac{1}{2} g^{de} \\left( \\partial_a g_{ec} + \\partial_c g_{ae} - \\partial_e g_{ac} \\right) \\right] g_{bd}\n$$\n利用性质 $g^{de}g_{bd} = \\delta^{e}_{b}$，我们对指标 $d$ 和 $e$ 进行缩并：\n$$\n\\Gamma^{d}{}_{ac} g_{bd} = \\frac{1}{2} \\delta^{e}_{b} \\left( \\partial_a g_{ec} + \\partial_c g_{ae} - \\partial_e g_{ac} \\right) = \\frac{1}{2} \\left( \\partial_a g_{bc} + \\partial_c g_{ab} - \\partial_b g_{ac} \\right)\n$$\n\n现在，我们将这两个结果代回 $\\nabla_{a} g_{bc}$ 的表达式中：\n$$\n\\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\frac{1}{2} \\left( \\partial_a g_{cb} + \\partial_b g_{ac} - \\partial_c g_{ab} \\right) - \\frac{1}{2} \\left( \\partial_a g_{bc} + \\partial_c g_{ab} - \\partial_b g_{ac} \\right)\n$$\n由于度规张量是对称的，$g_{bc} = g_{cb}$。我们可以分配因子 $-1/2$ 并合并同类项：\n$$\n\\nabla_{a} g_{bc} = \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{b} g_{ac} + \\frac{1}{2} \\partial_{c} g_{ab} - \\frac{1}{2} \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{c} g_{ab} + \\frac{1}{2} \\partial_{b} g_{ac}\n$$\n将同类项组合在一起：\n$$\n\\nabla_{a} g_{bc} = \\left( \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{a} g_{bc} - \\frac{1}{2} \\partial_{a} g_{bc} \\right) + \\left( -\\frac{1}{2} \\partial_{b} g_{ac} + \\frac{1}{2} \\partial_{b} g_{ac} \\right) + \\left( \\frac{1}{2} \\partial_{c} g_{ab} - \\frac{1}{2} \\partial_{c} g_{ab} \\right)\n$$\n所有三个括号内的项都总和为零：\n$$\n\\nabla_{a} g_{bc} = 0 + 0 + 0 = 0\n$$\n这样就完成了推导，证明了由克里斯托费尔符号公式定义的联络确实是度规相容的。这个恒等式是广义相对论的基础，意味着向量的长度和它们之间的角度在平行输运下是保持不变的。\n\n### 数值程序设计\n\n对恒等式 $\\nabla_{a} g_{bc} = 0$ 的数值验证，通过使用数值方法计算协变导数表达式中的每一项，然后计算一个残差来进行。理想情况下，这个残差应为零，但由于有限精度算术和有限差分格式带来的近似误差，它将是一个小的非零数。\n\n对于每个由度规 $g_{ab}(x)$、求值点 $x_p$ 和步长 $h$ 指定的测试用例：\n\n1.  **定义度规函数**：为每种情况实现一个 Python 函数 `metric_func(coords)`。它接受一个4元坐标向量 $x^a = (x^0, x^1, x^2, x^3)$，并返回一个 $4 \\times 4$ 的度规张量 $g_{ab}$ 作为 NumPy 数组。\n\n2.  **计算偏导数**：在点 $x_p$ 处的偏导数 $\\partial_a g_{bc}$ 使用二阶中心有限差分公式进行近似。对于每个坐标方向 $a \\in \\{0,1,2,3\\}$：\n    $$\n    \\partial_{a} g_{bc}(x_p) \\approx \\frac{g_{bc}(x_p + h \\cdot e_{a}) - g_{bc}(x_p - h \\cdot e_{a})}{2h}\n    $$\n    其中 $e_a$ 是第 $a$ 个方向的单位向量。对所有的 $a, b, c$ 计算这个值，得到一个 $4 \\times 4 \\times 4$ 的导数张量，我们记为 `dG`。\n\n3.  **计算克里斯托费尔符号**：在点 $x_p$，我们首先计算度规 $g_{ab}$ 及其逆 $g^{ab}$。然后，我们使用它们根据度规和数值计算的偏导数的定义来计算克里斯托费尔符号 $\\Gamma^{a}{}_{bc}$：\n    $$\n    \\Gamma^{a}{}_{bc} = \\frac{1}{2} g^{ad} \\left( \\partial_b g_{dc} + \\partial_c g_{bd} - \\partial_d g_{bc} \\right)\n    $$\n    对所有的 $a,b,c$ 进行计算，得到一个 $4 \\times 4 \\times 4$ 的张量 `Gamma`。\n\n4.  **计算协变导数**：通过将前几步的结果代入其定义公式，数值计算张量 $\\nabla_a g_{bc}$ 的分量：\n    $$\n    \\nabla_{a} g_{bc} = (\\partial_{a} g_{bc})_{\\text{numerical}} - \\sum_{d=0}^{3} (\\Gamma^{d}{}_{ab})_{\\text{numerical}} (g_{dc})_{\\text{numerical}} - \\sum_{d=0}^{3} (\\Gamma^{d}{}_{ac})_{\\text{numerical}} (g_{bd})_{\\text{numerical}}\n    $$\n    此计算产生一个 $4 \\times 4 \\times 4$ 的张量 `nablaG`，其分量表示恒等式 $\\nabla_a g_{bc} = 0$ 的数值误差。\n\n5.  **计算残差**：测试用例的最终残差定义为计算出的张量 $\\nabla_a g_{bc}$ 的所有 $4^3 = 64$ 个分量中的最大绝对值：\n    $$\n    \\text{残差} = \\max_{a,b,c} \\left| (\\nabla_{a} g_{bc})_{\\text{numerical}} \\right|\n    $$\n    这个标量值量化了总体的数值不一致性。对于一个正确的实现，这个残差预计会很小，通常在 $O(h^2)$ 的量级（来自有限差分误差），再加上任何机器精度限制。\n\n此过程应用于四个指定的测试用例中的每一个，并收集所得到的残差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# In this problem, scipy is not required.\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical consistency check for the identity\n    nabla_a g_bc = 0 for four test cases in general relativity.\n    \"\"\"\n\n    # ==========================================================================\n    # Metric Tensor Functions\n    # Each function takes a 4-element coordinate vector and returns the\n    # 4x4 metric tensor g_ab as a NumPy array.\n    # ==========================================================================\n\n    def metric_minkowski_cartesian(coords):\n        \"\"\"\n        Minkowski metric in Cartesian coordinates (t, x, y, z).\n        Signature (-, +, +, +).\n        \"\"\"\n        return np.diag([-1.0, 1.0, 1.0, 1.0])\n\n    def metric_minkowski_spherical(coords):\n        \"\"\"\n        Minkowski metric in spherical polar coordinates (t, r, theta, phi).\n        \"\"\"\n        t, r, theta, phi = coords\n        # Add a small epsilon to r to handle r=0 case gracefully if it ever occurs,\n        # though the test point avoids it.\n        r_safe = r + 1e-30\n        return np.diag([-1.0, 1.0, r_safe**2, (r_safe * np.sin(theta))**2])\n\n    def metric_gw(coords):\n        \"\"\"\n        Weak plane gravitational wave in transverse-traceless gauge.\n        Coordinates are (t, x, y, z).\n        \"\"\"\n        A = 1e-3\n        k = 2.0\n        t, x, y, z = coords\n        u = t - z\n        h_plus = A * np.cos(k * u)\n        h_cross = A * np.sin(k * u)\n        \n        g = np.diag([-1.0, 1.0, 1.0, 1.0])\n        g[1, 1] = 1.0 + h_plus\n        g[2, 2] = 1.0 - h_plus\n        g[1, 2] = h_cross\n        g[2, 1] = h_cross\n        return g\n\n    def metric_schwarzschild_iso(coords):\n        \"\"\"\n        Schwarzschild metric in isotropic coordinates (t, x, y, z).\n        \"\"\"\n        M = 1.0\n        t, x, y, z = coords\n        r = np.sqrt(x**2 + y**2 + z**2)\n        \n        if r  1e-12: # Avoid division by zero\n            # This case is not hit by the provided test points.\n            # Return a singular-like metric. This is physically ill-defined at r=0.\n            return np.diag([0.0, np.inf, np.inf, np.inf])\n\n        psi = 1.0 + M / (2.0 * r)\n        alpha = (1.0 - M / (2.0 * r)) / psi\n        \n        g = np.zeros((4, 4))\n        g[0, 0] = -alpha**2\n        g[1, 1] = psi**4\n        g[2, 2] = psi**4\n        g[3, 3] = psi**4\n        return g\n\n    # ==========================================================================\n    # Numerical Computation Core\n    # ==========================================================================\n\n    def compute_residual(metric_func, point, h):\n        \"\"\"\n        Computes the residual for the identity nabla_a g_bc = 0.\n\n        Args:\n            metric_func: A function that returns the metric tensor at a point.\n            point: The 4D coordinate vector at which to evaluate.\n            h: The step size for finite differences.\n\n        Returns:\n            The maximum absolute value of the components of nabla_a g_bc.\n        \"\"\"\n        p = np.array(point, dtype=float)\n        dim = 4\n\n        # 1. Compute partial derivatives dG[a, b, c] = \\partial_a g_bc\n        # Uses a centered finite-difference scheme.\n        dG = np.zeros((dim, dim, dim))\n        for a in range(dim):\n            p_plus = p.copy()\n            p_plus[a] += h\n            p_minus = p.copy()\n            p_minus[a] -= h\n            \n            g_plus = metric_func(p_plus)\n            g_minus = metric_func(p_minus)\n            \n            dG[a, :, :] = (g_plus - g_minus) / (2.0 * h)\n            \n        # 2. Compute G and its inverse invG at the central point p\n        G = metric_func(p)\n        invG = np.linalg.inv(G)\n        \n        # 3. Compute Christoffel symbols Gamma^a_bc\n        # Gamma^a_{bc} = 1/2 g^{ad} (d_b g_{dc} + d_c g_{bd} - d_d g_{bc})\n        # Note: dG[k, i, j] represents \\partial_k g_ij\n        Gamma = np.zeros((dim, dim, dim))\n        for a in range(dim):\n            for b in range(dim):\n                for c in range(dim):\n                    s = 0.0\n                    for d in range(dim):\n                        term1 = dG[b, d, c]  # \\partial_b g_{dc}\n                        term2 = dG[c, b, d]  # \\partial_c g_{bd}\n                        term3 = dG[d, b, c]  # \\partial_d g_{bc}\n                        s += 0.5 * invG[a, d] * (term1 + term2 - term3)\n                    Gamma[a, b, c] = s\n        \n        # 4. Compute covariant derivative nabla_a g_bc\n        # nabla_a g_bc = d_a g_bc - Gamma^d_{ab} g_{dc} - Gamma^d_{ac} g_{bd}\n        # Using np.einsum for efficient and readable tensor contraction.\n        term2 = np.einsum('dab,dc->abc', Gamma, G)\n        term3 = np.einsum('dac,db->abc', Gamma, G) # relies on symmetry of G (g_bd = g_db)\n        \n        nablaG = dG - term2 - term3\n\n        # 5. The residual is the maximum absolute component of nablaG\n        residual = np.max(np.abs(nablaG))\n        return residual\n\n    # ==========================================================================\n    # Test Suite Execution\n    # ==========================================================================\n    \n    test_cases = [\n        {'name': 'Minkowski (Cartesian)', 'metric_func': metric_minkowski_cartesian, 'point': (0.0, 0.0, 0.0, 0.0), 'h': 1e-5},\n        {'name': 'Minkowski (Spherical)', 'metric_func': metric_minkowski_spherical, 'point': (0.0, 2.0, 0.7, 1.2), 'h': 1e-6},\n        {'name': 'Gravitational Wave', 'metric_func': metric_gw, 'point': (0.4, 0.1, -0.1, 0.2), 'h': 1e-6},\n        {'name': 'Schwarzschild (Isotropic)', 'metric_func': metric_schwarzschild_iso, 'point': (0.0, 2.0, 1.0, 1.5), 'h': 1e-6}\n    ]\n    \n    results = []\n    for case in test_cases:\n        res = compute_residual(case['metric_func'], case['point'], case['h'])\n        results.append(res)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```", "id": "3467809"}, {"introduction": "精确计算克里斯托费尔符号为何至关重要？此高级练习 [@problem_id:3467751] 揭示了其在维持数值模拟稳定性方面的直接影响。计算中的数值误差会传播到里奇张量，导致哈密顿约束等爱因斯坦方程的关键约束条件出现非零残差。本练习将指导您量化这种约束违背，并执行收敛性测试——这是验证数值代码准确性和可靠性的黄金标准方法。", "problem": "在用于数值相对论的 $3+1$ 分解的背景下，给定一个等时切片的三维空间度规。该空间度规是共形平直的，在三维环面 $[0,1]^3$ 上由 $ \\gamma_{ij} = \\psi^4 \\delta_{ij} $ 给出，且在每个坐标方向上具有周期性边界条件。共形因子为\n$$\n\\psi(x,y,z) = 1 + \\varepsilon \\sin(2\\pi x) \\sin(2\\pi y) \\sin(2\\pi z).\n$$\n真空广义相对论的哈密顿约束为\n$$\n\\mathcal{H} \\equiv R + K^2 - K_{ij} K^{ij} = 0,\n$$\n其中 $R$ 是空间度规 $\\gamma_{ij}$ 的里奇标量，$K_{ij}$ 是外在曲率，$K = \\gamma^{ij} K_{ij}$ 是其迹。对于本问题，取 $K_{ij} = 0$，因此哈密顿约束简化为 $ \\mathcal{H} = R $。\n\n你的任务是，当 $R$ 从离散数据中数值计算时，展示计算空间克里斯托费尔符号时的数值误差如何导致哈密顿约束中出现非零残差，并通过网格加密来量化这些残差的收敛性。\n\n需要使用的基本依据和定义：\n- 克里斯托费尔符号（列维-奇维塔联络）定义为\n$$\n\\Gamma^{k}{}_{ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_i \\gamma_{j\\ell} + \\partial_j \\gamma_{i\\ell} - \\partial_\\ell \\gamma_{ij} \\right).\n$$\n- 里奇张量定义为\n$$\nR_{ij} = \\partial_k \\Gamma^{k}{}_{ij} - \\partial_j \\Gamma^{k}{}_{ik} + \\Gamma^{k}{}_{ij}\\Gamma^{\\ell}{}_{k\\ell} - \\Gamma^{k}{}_{i\\ell}\\Gamma^{\\ell}{}_{jk},\n$$\n里奇标量为 $ R = \\gamma^{ij} R_{ij} $。\n- 你必须使用均匀网格和二阶精度的中心有限差分格式，在所有三个方向上采用周期性边界条件，来数值计算这些定义中出现的所有空间导数。设每个维度的网格点数为 $N$，网格间距为 $h = 1/N$。\n\n为了量化由空间克里斯托费尔符号及其导数的数值计算所专门产生的误差，请按以下步骤进行。\n1. 通过以下方式计算里奇标量的数值近似 $R_{\\mathrm{num}}$：\n   - 从 $ \\psi $ 构建 $ \\gamma_{ij} $。\n   - 使用二阶中心差分计算所有空间导数，通过上述定义计算克里斯托费尔符号 $ \\Gamma^{k}{}_{ij} $。\n   - 再次使用二阶中心差分，根据上述定义，从 $ \\Gamma^{k}{}_{ij} $ 及其导数计算 $ R_{ij} $。\n   - 进行缩并以获得 $ R_{\\mathrm{num}} = \\gamma^{ij} R_{ij} $。\n2. 通过对 $ \\psi $ 进行解析微分，并使用 $ \\psi $ 的精确导数，为给定的共形平直度规 $ \\gamma_{ij} = \\psi^4 \\delta_{ij} $ 计算里奇标量的封闭形式表达式，从而得到精确的里奇标量 $R_{\\mathrm{exact}}$。\n3. 将逐点哈密顿约束残差定义为 $ \\mathcal{H}_{\\mathrm{res}} = R_{\\mathrm{num}} - R_{\\mathrm{exact}} $。通过其在网格上的离散均方根范数来量化：\n$$\n\\|\\mathcal{H}_{\\mathrm{res}}\\|_2 = \\left( \\frac{1}{N^3} \\sum_{i,j,k} \\left[ \\mathcal{H}_{\\mathrm{res}}(x_i,y_j,z_k) \\right]^2 \\right)^{1/2}.\n$$\n\n通过在多种分辨率下评估 $ \\|\\mathcal{H}_{\\mathrm{res}}\\|_2 $ 并报告从连续加密中计算出的经验收敛阶，来进行收敛性研究。使用以下具有周期性边界条件的测试套件：\n- 测试集 A（非平凡曲率下的收敛性）：$ \\varepsilon = 0.1 $ 且 $ N \\in \\{16, 32, 64\\} $。\n- 测试集 B（平直空间边界情况）：$ \\varepsilon = 0.0 $ 且 $ N = 32 $。\n\n对于测试集 A，计算残差范数 $E_{16}$、$E_{32}$ 和 $E_{64}$，以及经验收敛阶\n$$\np_{16\\rightarrow 32} = \\log_2\\!\\left(\\frac{E_{16}}{E_{32}}\\right), \\quad p_{32\\rightarrow 64} = \\log_2\\!\\left(\\frac{E_{32}}{E_{64}}\\right).\n$$\n对于测试集 B，计算残差范数 $E_{\\mathrm{flat}}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序和类型如下：\n- $E_{16}$、$E_{32}$、$E_{64}$、$p_{16\\rightarrow 32}$、$p_{32\\rightarrow 64}$、$E_{\\mathrm{flat}}$，全部为浮点数。\n\n不涉及物理单位。所有角度均以弧度为单位。数值导数必须在周期性边界条件下使用二阶中心差分实现。最终的数值输出必须严格遵守指定的单行格式，例如：“[0.0123,0.0031,0.0008,2.00,1.95,0.0]”。", "solution": "用户提供的问题陈述已经过验证，并被认为是**有效的**。它在科学上基于广义相对论的 $3+1$ 形式，问题设定良好、客观，并包含进行唯一、可验证求解所需的所有必要信息。\n\n该问题要求对哈密顿约束残差进行数值研究，该残差源于空间里奇标量 $R$ 计算中的离散化误差。空间度规在三维环面上被给定为共形平直的 $\\gamma_{ij} = \\psi^4 \\delta_{ij}$，并具有特定形式的共形因子 $\\psi$。初始数据是时间对称的（$K_{ij}=0$），这将哈密顿约束简化为 $\\mathcal{H} = R = 0$。然而，为了量化数值误差，我们将残差计算为数值计算的里奇标量 $R_{\\mathrm{num}}$ 与其精确解析对应物 $R_{\\mathrm{exact}}$ 之间的差值。\n\n### 基于原理的求解设计\n\n求解过程分为两个主要部分：精确里奇标量 $R_{\\mathrm{exact}}$ 的解析推导，以及计算 $R_{\\mathrm{num}}$ 和所得残差的数值算法。\n\n#### 1. 解析里奇标量 ($R_{\\mathrm{exact}}$)\n\n对于一个 $n=3$ 维的共形平直度规，由 $\\gamma_{ij} = \\phi^2 \\delta_{ij}$ 给出，其中 $\\phi$ 是共形因子，其里奇标量 $R$ 通过标准公式与平直背景度规的里奇标量（$R_{\\text{flat}}=0$）相关联：$R = \\phi^{-2} [R_{\\text{flat}} - 2(n-1) \\Delta \\ln \\phi - (n-2)(n-1) (\\nabla \\ln \\phi)^k (\\nabla \\ln \\phi)_k]$，其中 $\\Delta$ 和 $\\nabla$ 分别是平直度规的拉普拉斯算子和梯度算子。在我们的情况下，度规为 $\\gamma_{ij} = \\psi^4 \\delta_{ij}$，因此共形因子为 $\\phi = \\psi^2$。代入 $n=3$ 和 $R_{\\text{flat}}=0$，该公式简化为针对此特定度规形式的一个著名表达式：\n$$\nR = -8 \\psi^{-5} \\Delta \\psi = -8 \\psi^{-5} (\\partial_x^2 + \\partial_y^2 + \\partial_z^2) \\psi\n$$\n给定的共形因子为 $\\psi(x,y,z) = 1 + \\varepsilon \\sin(2\\pi x) \\sin(2\\pi y) \\sin(2\\pi z)$。令 $S(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z)$，则 $\\psi = 1 + \\varepsilon S$。我们计算它的二阶导数：\n$$\n\\partial_x^2 \\psi = \\partial_x^2 (1 + \\varepsilon S) = \\varepsilon \\partial_x^2 S = \\varepsilon [-(2\\pi)^2 \\sin(2\\pi x)] \\sin(2\\pi y)\\sin(2\\pi z) = -(2\\pi)^2 \\varepsilon S\n$$\n同理，$\\partial_y^2 \\psi = -(2\\pi)^2 \\varepsilon S$ 且 $\\partial_z^2 \\psi = -(2\\pi)^2 \\varepsilon S$。\n因此，$\\psi$ 的平直空间拉普拉斯算子为：\n$$\n\\Delta\\psi = \\partial_x^2\\psi + \\partial_y^2\\psi + \\partial_z^2\\psi = -3(2\\pi)^2 \\varepsilon S = -3(2\\pi)^2 (\\psi - 1)\n$$\n将此结果代入 $R$ 的公式中，我们得到精确的解析表达式：\n$$\nR_{\\mathrm{exact}} = -8 \\psi^{-5} [-3(2\\pi)^2 (\\psi - 1)] = 24(2\\pi)^2 \\psi^{-5} (\\psi - 1)\n$$\n该表达式将在数值网格上进行评估，以提供参考解。对于 $\\varepsilon=0$ 的特殊情况，我们有 $\\psi=1$，因此 $R_{\\mathrm{exact}}=0$，对应于平直空间。\n\n#### 2. 数值里奇标量 ($R_{\\mathrm{num}}$)\n\n$R$ 的数值计算遵循所提供的定义链，对所有导数使用有限差分。区域 $[0,1]^3$ 被离散化为一个 $N \\times N \\times N$ 个点的均匀网格，网格间距为 $h=1/N$。周期性边界条件通过 `numpy.roll` 处理，该函数自然地实现了环绕行为。所有导数都使用二阶精度的中心有限差分格式进行近似。对于网格上的函数 $f$，其沿 $k$ 轴的导数为：\n$$\n(\\partial_k f)_i \\approx \\frac{f_{i+1} - f_{i-1}}{2h}\n$$\n数值算法按以下步骤进行：\n\n**步骤 2a：计算克里斯托费尔符号 $\\Gamma^k{}_{ij}$**\n克里斯托费尔符号由 $\\Gamma^{k}{}_{ij} = \\frac{1}{2} \\gamma^{k\\ell} \\left( \\partial_i \\gamma_{j\\ell} + \\partial_j \\gamma_{i\\ell} - \\partial_\\ell \\gamma_{ij} \\right)$ 给出。由于度规 $\\gamma_{ij} = \\psi^4 \\delta_{ij}$ 是对角的，这个公式可以显著简化。逆度规为 $\\gamma^{ij} = \\psi^{-4} \\delta^{ij}$。简化后的表达式为：\n$$\n\\Gamma^k{}_{ij} = 2 \\psi^{-1} (\\delta_{jk} \\partial_i \\psi + \\delta_{ik} \\partial_j \\psi - \\delta_{ij} \\partial_k \\psi)\n$$\n为了进行数值计算，我们首先在网格上评估 $\\psi$。然后，我们使用中心有限差分算子计算一阶导数 $\\partial_x \\psi$、$\\partial_y \\psi$ 和 $\\partial_z \\psi$。最后，我们使用这些数值导数在网格上构建克里斯托费尔符号的所有 $3^3=27$ 个分量。\n\n**步骤 2b：计算里奇张量 $R_{ij}$**\n里奇张量定义为 $R_{ij} = \\partial_k \\Gamma^{k}{}_{ij} - \\partial_j \\Gamma^{k}{}_{ik} + \\Gamma^{k}{}_{ij}\\Gamma^{\\ell}{}_{k\\ell} - \\Gamma^{k}{}_{i\\ell}\\Gamma^{\\ell}{}_{jk}$。此计算涉及：\n1.  先前计算出的数值克里斯托费尔符号 $\\Gamma^k{}_{ij}$ 的导数。这第二层微分也使用中心差分格式进行。\n2.  克里斯托费尔符号的二次乘积。\n这一步计算量很大，需要仔细管理张量指标。定义中的每一项都针对里奇张量的每个分量 $(i,j)$ 单独计算。对哑指标 $k$ 和 $\\ell$ 的求和是显式执行的。\n\n**步骤 2c：计算里奇标量 $R_{\\mathrm{num}}$**\n数值里奇标量是缩并 $R_{\\mathrm{num}} = \\gamma^{ij} R_{ij}$。由于 $\\gamma^{ij}$ 和 $R_{ij}$ 都是对称的，且 $\\gamma^{ij}$ 是对角的，这可以简化为：\n$$\nR_{\\mathrm{num}} = \\gamma^{xx}R_{xx} + \\gamma^{yy}R_{yy} + \\gamma^{zz}R_{zz} = \\psi^{-4}(R_{xx} + R_{yy} + R_{zz})\n$$\n其中 $R_{xx}$、$R_{yy}$ 和 $R_{zz}$ 是数值计算出的里奇张量的对角分量。\n\n#### 3. 残差与收敛性分析\n\n哈密顿约束残差被定义为逐点差值 $\\mathcal{H}_{\\mathrm{res}} = R_{\\mathrm{num}} - R_{\\mathrm{exact}}$。总误差通过其在 $N^3$ 个网格点上的离散均方根范数来量化。\n由于所有数值导数都是用二阶精度格式（$O(h^2)$）计算的，并且 $R$ 的计算涉及两次连续应用微分算子（从 $\\gamma$ 到 $\\Gamma$，再从 $\\Gamma$ 到 $R$），因此 $R_{\\mathrm{num}}$ 中的主阶截断误差预计与 $h^2$ 成正比。因此，误差范数 $\\|\\mathcal{H}_{\\mathrm{res}}\\|_2$ 也应按 $h^2 = (1/N)^2$ 的比例缩放。当分辨率加倍时（即 $N \\to 2N$），误差预计会减少 4 倍。因此，经验收敛阶 $p = \\log_2(E_N / E_{2N})$ 应接近 2。这就是将为测试集 A 计算的内容。\n\n对于测试集 B（$\\varepsilon=0$），空间是平直的，因此 $R_{\\mathrm{exact}}=0$。度规是常数，$\\gamma_{ij}=\\delta_{ij}$。常数的数值导数为零。因此，所有的克里斯托费尔符号和里奇张量在数值上都将为零（在机器浮点精度范围内）。残差范数预计将接近于零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical relativity problem by computing Hamiltonian residuals\n    for a conformally flat metric and performing a convergence study.\n    \"\"\"\n\n    def central_diff(f, h, axis):\n        \"\"\"\n        Computes the second-order centered finite difference of a 3D array `f`\n        with grid spacing `h` along a given `axis` with periodic boundary conditions.\n        \"\"\"\n        return (np.roll(f, -1, axis=axis) - np.roll(f, 1, axis=axis)) / (2.0 * h)\n\n    def compute_hamiltonian_residual(N, epsilon):\n        \"\"\"\n        Computes the RMS norm of the Hamiltonian residual for a given grid size N\n        and perturbation parameter epsilon.\n        \"\"\"\n        # 1. Grid setup\n        h = 1.0 / N\n        grid_pts = np.linspace(0.0, 1.0, N, endpoint=False)\n        # Use 'ij' indexing to match axis order with derivative directions\n        # axis 0 -> x, axis 1 -> y, axis 2 -> z\n        X, Y, Z = np.meshgrid(grid_pts, grid_pts, grid_pts, indexing='ij')\n\n        # 2. Compute analytical psi and R_exact\n        S = np.sin(2.0 * np.pi * X) * np.sin(2.0 * np.pi * Y) * np.sin(2.0 * np.pi * Z)\n        psi = 1.0 + epsilon * S\n\n        if abs(epsilon)  1e-15: # Case for epsilon = 0.0\n            R_exact = np.zeros((N, N, N))\n        else:\n            # R_exact = 24 * (2*pi)^2 * psi^-5 * (psi-1)\n            psi_minus_1 = epsilon * S\n            R_exact = 24.0 * (2.0 * np.pi)**2 * np.power(psi, -5.0) * psi_minus_1\n\n        # 3. Compute metric components\n        psi_inv = 1.0 / psi\n        gamma_inv_diag = np.power(psi, -4.0)\n        \n        # 4. Compute numerical derivatives of psi\n        dpsi_d = [\n            central_diff(psi, h, 0),  # dpsi/dx\n            central_diff(psi, h, 1),  # dpsi/dy\n            central_diff(psi, h, 2)   # dpsi/dz\n        ]\n\n        # 5. Compute Christoffel symbols Gamma^k_{ij}\n        # Gamma[k, i, j] stores the 3D grid data for Gamma^k_ij\n        GAMMA = np.zeros((3, 3, 3, N, N, N))\n        for k in range(3):\n            for i in range(3):\n                for j in range(3):\n                    # Simplified formula for diagonal conformally flat metric\n                    # Gamma^k_ij = 2/psi * (delta_jk * d_i psi + delta_ik * d_j psi - delta_ij * d_k psi)\n                    term1 = (1.0 if j == k else 0.0) * dpsi_d[i]\n                    term2 = (1.0 if i == k else 0.0) * dpsi_d[j]\n                    term3 = (1.0 if i == j else 0.0) * dpsi_d[k]\n                    GAMMA[k, i, j] = 2.0 * psi_inv * (term1 + term2 - term3)\n\n        # 6. Compute Ricci tensor R_ij\n        # R_ij = d_k Gamma^k_ij - d_j Gamma^k_ik + Gamma^k_ij Gamma^l_kl - Gamma^k_il Gamma^l_jk\n        R_ij = np.zeros((3, 3, N, N, N))\n        \n        # Precompute trace Gamma^l_kl for each k\n        trace_G_k = np.zeros((3, N, N, N))\n        for k_idx in range(3):\n            for l_idx in range(3):\n                trace_G_k[k_idx] += GAMMA[l_idx, k_idx, l_idx]\n                \n        for i in range(3):\n            for j in range(3):\n                # Term 1: partial_k Gamma^k_ij (sum over k)\n                term1 = np.zeros((N, N, N))\n                for k in range(3):\n                    term1 += central_diff(GAMMA[k, i, j], h, k)\n\n                # Term 2: partial_j Gamma^k_ik (sum over k)\n                trace_G_i = np.zeros((N, N, N))\n                for k in range(3):\n                    trace_G_i += GAMMA[k, i, k]\n                term2 = central_diff(trace_G_i, h, j)\n\n                # Term 3: Gamma^k_ij * Gamma^l_kl (sum over k)\n                term3 = np.zeros((N, N, N))\n                for k in range(3):\n                    term3 += GAMMA[k, i, j] * trace_G_k[k]\n                    \n                # Term 4: Gamma^k_il * Gamma^l_jk (sum over k, l)\n                term4 = np.zeros((N, N, N))\n                for k in range(3):\n                    for l in range(3):\n                        term4 += GAMMA[k, i, l] * GAMMA[l, j, k]\n                \n                R_ij[i, j] = term1 - term2 + term3 - term4\n\n        # 7. Compute R_num = gamma^ij R_ij\n        R_num = gamma_inv_diag * (R_ij[0, 0] + R_ij[1, 1] + R_ij[2, 2])\n\n        # 8. Compute residual and its RMS norm\n        H_res = R_num - R_exact\n        norm = np.sqrt(np.mean(H_res**2))\n        return norm\n\n    # --- Main execution ---\n    # Test Set A: Convergence study\n    eps_A = 0.1\n    Ns_A = [16, 32, 64]\n    \n    E16 = compute_hamiltonian_residual(Ns_A[0], eps_A)\n    E32 = compute_hamiltonian_residual(Ns_A[1], eps_A)\n    E64 = compute_hamiltonian_residual(Ns_A[2], eps_A)\n    \n    # Compute convergence orders\n    p16_32 = np.log2(E16 / E32) if E32 > 0 else 0.0\n    p32_64 = np.log2(E32 / E64) if E64 > 0 else 0.0\n    \n    # Test Set B: Flat space case\n    eps_B = 0.0\n    N_B = 32\n    E_flat = compute_hamiltonian_residual(N_B, eps_B)\n    \n    # Format and print the final output\n    results = [E16, E32, E64, p16_32, p32_64, E_flat]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3467751"}]}