{"hands_on_practices": [{"introduction": "在数值相对论中，求解像泊松方程这样的椭圆型方程是一项基本任务，尤其在构造初始数据时至关重要。本练习将指导你使用傅里叶伪谱法在周期性区域上求解此类方程。你将通过此实践掌握的核心技能是在傅里叶空间中高效计算空间导数，并学习如何妥善处理点粒子等奇异源项，这是在实际研究中经常遇到的挑战 [@problem_id:3484238]。", "problem": "考虑一个一维周期性域，其坐标 $x \\in [0,2\\pi)$ 以弧度为单位。在爱因斯坦场方程的 $3{+}1$分解中，哈密顿约束简化为一个关于共形因子的椭圆方程，在简化的代理设置中，可以将其建模为源项来自致密天体的泊松型方程。为专注于使用伪谱法处理局部化源项和点粒子，研究以下代理周期性泊松问题\n$$\n- \\partial_x^2 \\phi(x) = \\rho(x),\n$$\n在圆上，其中 $\\rho(x)$ 是由 Dirac delta 分布建模的点粒子的叠加。在周期性域上，为了使方程在周期性边界条件下可解，右侧项的平均值必须为零。在实践中，伪谱法通过对分布进行精确谱投影和柔化来处理奇异源。你的任务是从第一性原理出发，推导一个谱算法，使用傅里叶伪谱法在均匀配置网格上计算 $\\phi(x)$，通过谱投影柔化器处理点源，并强制执行零模约束。\n\n从以下基础开始：\n- Dirac delta 的分布理论：在圆上，以 $x_0$ 为中心的周期性 Dirac delta 对所有整数 $k$ 都有傅里叶级数系数 $\\widehat{\\delta}_{k}(x_0) = \\frac{1}{2\\pi} e^{-i k x_0}$，其在 $[0,2\\pi)$ 上的平均值为 $\\frac{1}{2\\pi}$。\n- $[0,2\\pi)$ 上的傅里叶级数：任何足够正则的周期函数 $f(x)$ 都有傅里叶系数 $\\widehat{f}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} f(x) e^{-i k x} \\, dx$ 和表示 $f(x) = \\sum_{k \\in \\mathbb{Z}} \\widehat{f}_k e^{i k x}$，其中 $k \\in \\mathbb{Z}$。\n- 在傅里叶空间中，拉普拉斯算子是对角作用的：对于 $k \\neq 0$，$-\\partial_x^2$ 将 $\\widehat{\\phi}_k$ 映射到 $k^2 \\widehat{\\phi}_k$。\n\n你必须：\n1. 推导谱反演公式。该公式通过将解的零傅里叶模式（$k=0$）$\\widehat{\\phi}_0$ 设置为 $0$ 来强制执行可解性条件，并对所有 $k \\neq 0$ 计算 $\\widehat{\\phi}_k = \\widehat{\\rho}_k / k^2$。\n2. 展示对于每个质量为 $m_i$、位置在 $x_i$ 的点粒子，谱投影高斯柔化器如何将源系数改变为 $\\widehat{\\rho}_k = \\sum_i m_i \\widehat{G}_k e^{-i k x_i}$，其中 $\\widehat{G}_k$ 是宽度为 $\\sigma$ 且在 $[0,2\\pi)$ 上积分为 $1$ 的归一化周期性高斯的傅里叶系数。以闭合形式指定 $\\widehat{G}_k$，并证明 $k=0$ 模式通过移除平均值来处理，以满足周期性泊松方程的可解性。\n3. 提供算子 $-\\partial_x^2$ 在单个点源和零平均值强制条件下的精确周期性格林函数，并以实空间形式表示。也就是说，对于位于 $x_0$ 的单个源，$\\phi(x)$ 必须满足 $- \\partial_x^2 \\phi(x) = \\delta(x-x_0) - \\frac{1}{2\\pi}$，其中 $\\phi$ 是周期性的且平均值为零。推导一个闭合形式的实空间表达式 $G(y)$，其中 $y = (x - x_0) \\bmod 2\\pi \\in [0,2\\pi)$，使得对于质量 $m$，有 $\\phi(x) = m\\, G(y)$，并线性扩展到多个源的情况。\n\n你的程序必须实现以下算法：\n- 使用一个包含 $N$ 个配置点 $x_j = \\frac{2\\pi j}{N}$（$j = 0,1,\\dots,N-1$）的均匀网格。\n- 以快速傅里叶变换的顺序构建整数模式 $k \\in \\{-\\frac{N}{2}, \\dots, \\frac{N}{2}-1\\}$ 的离散频率数组。\n- 通过对以每个 $x_i$ 为中心、宽度为 $\\sigma$、质量为 $m_i$ 的周期性高斯柔化器进行谱投影，来组装离散源系数 $\\widehat{\\rho}_k$。确保你的离散系数被归一化，以便在通过离散傅里叶逆变换重构时与连续傅里叶级数相匹配。然后将 $\\widehat{\\rho}_0$ 设置为原始离散值，并在反演步骤中通过使用 $\\widehat{\\phi}_0 = 0$ 来强制执行可解性。\n- 对于 $k \\neq 0$，通过除以 $k^2$ 来计算 $\\widehat{\\phi}_k$。\n- 可选地，对 $\\widehat{\\phi}_k$ 应用一个阶数为 $p$、强度参数为 $\\alpha$ 的指数谱滤波器，以减少不连续点附近的吉布斯振荡。该滤波器应为 $F_k = \\exp\\left(-\\alpha \\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right)$，其中 $k_{\\max} = \\frac{N}{2}$，并乘法应用于 $\\widehat{\\phi}_k$。\n- 通过离散傅里叶逆变换重构 $\\phi(x_j)$。\n- 计算精确解 $\\phi_{\\text{exact}}(x_j)$，其值为所有源的 $m_i$ 乘以在 $y_i = (x_j - x_i) \\bmod 2\\pi$ 处求值的周期性格林函数的总和。\n- 报告最大绝对误差 $E = \\max_j |\\phi(x_j) - \\phi_{\\text{exact}}(x_j)|$。\n\n角度必须以弧度处理。此问题中没有其他物理单位。你的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n\n测试套件：\n- 案例 1：$N=512$，两个源，质量为 $[1.0, -0.5]$，位置在 $[1.0, 4.0]$，柔化器宽度 $\\sigma=0.05$，指数滤波器阶数 $p=18$，强度 $\\alpha=36$。\n- 案例 2：$N=128$，一个源，质量为 $[1.0]$，位置在 $[2.7]$，柔化器宽度 $\\sigma=0.001$，无滤波器 $p=0$ 且 $\\alpha=0$。\n- 案例 3：$N=256$，两个位于相同位置 $[1.0, 1.0]$ 的重合源，质量为 $[1.0, -1.0]$，柔化器宽度 $\\sigma=0.02$，滤波器阶数 $p=24$，强度 $\\alpha=36$。\n- 案例 4：$N=1024$，一个源，质量为 $[2.0]$，位置在 $[6.0]$，柔化器宽度 $\\sigma=0.01$，滤波器阶数 $p=36$，强度 $\\alpha=36$。\n- 案例 5：$N=64$，两个邻近源，质量为 $[1.0, 1.0]$，位置在 $[3.14, 3.15]$，柔化器宽度 $\\sigma=0.05$，滤波器阶数 $p=12$，强度 $\\alpha=36$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的浮点数逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中每个条目是相应测试案例的最大绝对误差 $E$。", "solution": "该问题是有效的，因为它具有科学依据、良定、客观且内部一致。它提出了一个标准但并非不重要的练习，即应用傅里叶伪谱法求解带有奇异源的周期性泊松方程，这是计算物理和数值相对论中的常见任务。我们将进行完整的推导和求解。\n\n问题的核心是求解一维周期性泊松方程：\n$$\n- \\partial_x^2 \\phi(x) = \\rho(x), \\quad x \\in [0, 2\\pi)\n$$\n其中 $\\phi(x)$ 是周期性的，$\\rho(x)$ 代表点粒子的集合。我们将使用傅里叶伪谱法。\n\n### 1. 谱反演公式的推导\n\n我们用傅里叶级数表示解 $\\phi(x)$ 和源 $\\rho(x)$：\n$$\n\\phi(x) = \\sum_{k \\in \\mathbb{Z}} \\widehat{\\phi}_k e^{i k x}, \\quad \\rho(x) = \\sum_{k \\in \\mathbb{Z}} \\widehat{\\rho}_k e^{i k x}\n$$\n其中 $\\widehat{f}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} f(x) e^{-i k x} dx$ 是傅里叶系数。算子 $-\\partial_x^2$ 对傅里叶基函数 $e^{ikx}$ 的作用是对角的：\n$$\n- \\partial_x^2 (e^{ikx}) = - (ik)^2 e^{ikx} = k^2 e^{ikx}\n$$\n将傅里叶级数代入泊松方程得到：\n$$\n- \\partial_x^2 \\left( \\sum_{k \\in \\mathbb{Z}} \\widehat{\\phi}_k e^{i k x} \\right) = \\sum_{k \\in \\mathbb{Z}} k^2 \\widehat{\\phi}_k e^{i k x} = \\sum_{k \\in \\mathbb{Z}} \\widehat{\\rho}_k e^{i k x}\n$$\n根据傅里叶级数的唯一性，我们可以对每个模式 $k$ 的系数进行等价：\n$$\nk^2 \\widehat{\\phi}_k = \\widehat{\\rho}_k\n$$\n对于 $k \\neq 0$，解是直接的：$\\widehat{\\phi}_k = \\widehat{\\rho}_k / k^2$。\n\n对于 $k=0$ 模式（空间平均值），方程变为 $0 \\cdot \\widehat{\\phi}_0 = \\widehat{\\rho}_0$，这意味着 $\\widehat{\\rho}_0 = 0$。这是周期性泊松问题的可解性条件：源的平均值必须为零。如果满足此条件，$\\widehat{\\phi}_0$ 是不受约束的，这反映了可以向解 $\\phi(x)$ 添加任意常数的自由度。为了获得唯一解，我们强制执行解的平均值为零的条件，这对应于设置 $\\widehat{\\phi}_0 = 0$。\n\n在实践中，源项 $\\rho(x)$ 的平均值可能不为零（$\\widehat{\\rho}_0 \\neq 0$）。我们在此采用的标准程序是求解修正后的问题 $-\\partial_x^2 \\phi(x) = \\rho(x) - \\langle\\rho\\rangle$，其中 $\\langle\\rho\\rangle = \\frac{1}{2\\pi}\\int_0^{2\\pi} \\rho(x) dx = \\widehat{\\rho}_0$。修正后的源 $\\rho'(x) = \\rho(x) - \\widehat{\\rho}_0$ 的系数对于 $k \\neq 0$ 为 $\\widehat{\\rho'}_k = \\widehat{\\rho}_k$，对于 $k=0$ 为 $\\widehat{\\rho'}_0 = 0$，因此满足可解性条件。于是，谱反演公式为：\n$$\n\\widehat{\\phi}_k = \\begin{cases} \\widehat{\\rho}_k / k^2  \\text{if } k \\neq 0 \\\\ 0  \\text{if } k = 0 \\end{cases}\n$$\n此过程产生修正后问题的唯一零平均解。\n\n### 2. 谱投影高斯柔化器\n\n源 $\\rho(x)$ 是点粒子的总和，在数学上是 Dirac delta 分布。为了进行数值处理，这些奇异分布使用柔化器进行正则化。我们使用一个由其傅里叶系数定义的周期性高斯柔化器 $G(x; \\sigma)$。为了近似 delta 函数，柔化器在域上的积分必须为 $1$，即 $\\int_0^{2\\pi} G(x; \\sigma) dx = 1$。在傅里叶空间中，这意味着 $2\\pi \\widehat{G}_0 = 1$，或 $\\widehat{G}_0 = 1/(2\\pi)$。一个谱局域化的合适选择是：\n$$\n\\widehat{G}_k(\\sigma) = \\frac{1}{2\\pi} e^{-k^2 \\sigma^2 / 2}\n$$\n对于一组质量为 $m_i$、位置在 $x_i$ 的粒子，柔化后的源为 $\\rho(x) = \\sum_i m_i G(x-x_i; \\sigma)$。傅里叶系数 $\\widehat{\\rho}_k$ 通过线性和位移定理求得：\n$$\n\\widehat{\\rho}_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} \\left( \\sum_i m_i G(x-x_i; \\sigma) \\right) e^{-ikx} dx = \\sum_i m_i \\left( e^{-ikx_i} \\widehat{G}_k(\\sigma) \\right)\n$$\n代入 $\\widehat{G}_k(\\sigma)$ 的表达式，我们得到：\n$$\n\\widehat{\\rho}_k = \\left( \\frac{1}{2\\pi} e^{-k^2 \\sigma^2 / 2} \\right) \\sum_i m_i e^{-ikx_i}\n$$\n对于 $k=0$，源的平均值为 $\\widehat{\\rho}_0 = \\frac{1}{2\\pi} \\sum_i m_i$。如第 1 部分所述，谱求解算法通过从源中减去非零平均值来隐式处理它，这等效于使用完整的 $\\widehat{\\rho}_k$ 求解 $\\phi$ 并设置 $\\widehat{\\phi}_0=0$。\n\n### 3. 周期性格林函数\n\n单个点源的精确解由周期性格林函数给出，该函数求解：\n$$\n-\\partial_x^2 \\phi(x) = \\delta(x-x_0) - \\frac{1}{2\\pi}\n$$\n源项 $\\delta(x-x_0) - 1/(2\\pi)$ 的平均值为零，满足可解性条件。我们要求解 $\\phi(x)$ 是周期性的并且平均值为零。让我们找到源在 $x_0=0$ 处的格林函数 $G(y)$，其中 $y=x$。在傅里叶空间中求解 $-\\partial_y^2 G(y) = \\delta(y) - 1/(2\\pi)$ 得到 $k^2 \\widehat{G}_k = \\widehat{(\\delta - 1/2\\pi)}_k$。源的傅里叶系数对于 $k \\neq 0$ 是 $\\frac{1}{2\\pi}$，对于 $k=0$ 是 $0$。因此，对于 $k \\neq 0$，有 $\\widehat{G}_k = \\frac{1}{2\\pi k^2}$。$G(y)$ 的零平均值条件要求 $\\widehat{G}_0=0$。\n实空间格林函数通过对傅里叶级数求和得到：\n$$\nG(y) = \\sum_{k \\in \\mathbb{Z} \\setminus \\{0\\}} \\frac{e^{iky}}{2\\pi k^2} = \\frac{1}{2\\pi} \\left( \\sum_{k=1}^{\\infty} \\frac{e^{iky}}{k^2} + \\sum_{k=1}^{\\infty} \\frac{e^{-iky}}{k^2} \\right) = \\frac{1}{\\pi} \\sum_{k=1}^{\\infty} \\frac{\\cos(ky)}{k^2}\n$$\n这是一个著名的傅里叶级数，其在 $y \\in [0, 2\\pi)$ 上的和由 $\\frac{y^2}{4} - \\frac{\\pi y}{2} + \\frac{\\pi^2}{6}$ 给出。\n因此，周期性格林函数是：\n$$\nG(y) = \\frac{1}{\\pi} \\left(\\frac{y^2}{4} - \\frac{\\pi y}{2} + \\frac{\\pi^2}{6}\\right) = \\frac{y^2}{4\\pi} - \\frac{y}{2} + \\frac{\\pi}{6}, \\quad \\text{for } y \\in [0, 2\\pi)\n$$\n多个源的精确解通过线性叠加获得：\n$$\n\\phi_{\\text{exact}}(x) = \\sum_i m_i G\\big((x - x_i) \\pmod{2\\pi}\\big)\n$$\n这为我们衡量数值解的误差提供了基准。\n\n### 算法实现\n\n数值算法如下：\n1.  定义一个均匀网格 $x_j = 2\\pi j/N$ 以及对应的 FFT 友好顺序的整数波数 $k$。\n2.  使用第 2 部分的公式计算柔化源分布的连续傅里叶系数 $\\widehat{\\rho}_k$。\n3.  使用第 1 部分的反演公式计算解系数 $\\widehat{\\phi}_k$，即对于 $k \\neq 0$ 除以 $k^2$，并将 $k=0$ 模式设置为零。\n4.  可选地，对 $\\widehat{\\phi}_k$ 应用指数谱滤波器以抑制高频振荡（吉布斯现象）。\n5.  通过快速傅里叶逆变换（IFFT）重构实空间解 $\\phi(x_j)$。连续系数与离散变换之间的关系需要一个缩放因子 $N$：$\\phi(x_j) \\approx N \\cdot \\text{ifft}(\\{\\widehat{\\phi}_k\\})$。\n6.  使用第 3 部分的格林函数计算网格上的精确解。\n7.  计算数值解和精确解之间的最大绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the periodic Poisson problem using a Fourier pseudospectral method\n    for a series of test cases and computes the maximum absolute error.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=512, two sources with masses [1.0, -0.5] at positions [1.0, 4.0],\n        # mollifier width sigma=0.05, exponential filter order p=18 and strength alpha=36.\n        (512, [1.0, -0.5], [1.0, 4.0], 0.05, 18, 36),\n        # Case 2: N=128, one source with mass [1.0] at position [2.7],\n        # mollifier width sigma=0.001, no filter p=0 and alpha=0.\n        (128, [1.0], [2.7], 0.001, 0, 0),\n        # Case 3: N=256, two coincident sources at the same position [1.0, 1.0] with\n        # masses [1.0, -1.0], mollifier width sigma=0.02, filter order p=24 and strength alpha=36.\n        (256, [1.0, -1.0], [1.0, 1.0], 0.02, 24, 36),\n        # Case 4: N=1024, one source with mass [2.0] at position [6.0],\n        # mollifier width sigma=0.01, filter order p=36 and strength alpha=36.\n        (1024, [2.0], [6.0], 0.01, 36, 36),\n        # Case 5: N=64, two nearby sources with masses [1.0, 1.0] at positions [3.14, 3.15],\n        # mollifier width sigma=0.05, filter order p=12 and strength alpha=36.\n        (64, [1.0, 1.0], [3.14, 3.15], 0.05, 12, 36),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, masses, positions, sigma, p, alpha = case\n        error = solve_poisson_pseudospectral(N, masses, positions, sigma, p, alpha)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef periodic_greens_function(y):\n    \"\"\"\n    Computes the one-dimensional periodic Green's function for -d^2/dx^2.\n    The argument y is assumed to be in the interval [0, 2*pi).\n    G(y) = y^2/(4*pi) - y/2 + pi/6\n    \"\"\"\n    return y**2 / (4 * np.pi) - y / 2.0 + np.pi / 6.0\n\ndef solve_poisson_pseudospectral(N, masses, positions, sigma, p, alpha):\n    \"\"\"\n    Implements the pseudospectral algorithm for a single test case.\n    \"\"\"\n    # 1. Define grid and wavenumbers\n    # Real-space grid points x_j in [0, 2*pi)\n    x = 2 * np.pi * np.arange(N) / N\n    # Integer wavenumbers k in FFT order: [0, 1, ..., N/2-1, -N/2, ..., -1]\n    k = np.fft.fftfreq(N) * N\n\n    # 2. Assemble source term in Fourier space\n    # The term sum_i m_i * exp(-i*k*x_i)\n    source_fourier_sum = np.zeros(N, dtype=np.complex128)\n    for m, x_pos in zip(masses, positions):\n        source_fourier_sum += m * np.exp(-1j * k * x_pos)\n    \n    # Fourier coefficients of the Gaussian mollifier: hat(G)_k = (1/(2pi)) * exp(-k^2*sigma^2/2)\n    mollifier_hat_k = (1.0 / (2.0 * np.pi)) * np.exp(-0.5 * k**2 * sigma**2)\n    \n    # Fourier coefficients of the full mollified source: hat(rho)_k\n    rho_hat = mollifier_hat_k * source_fourier_sum\n\n    # 3. Solve for phi_hat in Fourier space\n    # The equation is k^2 * hat(phi)_k = hat(rho)_k.\n    # We solve for k!=0 and set hat(phi)_0 = 0 for a unique, zero-mean solution.\n    phi_hat = np.zeros(N, dtype=np.complex128)\n    \n    # Create a mask for non-zero wavenumbers\n    nonzero_k_mask = (k != 0)\n    \n    # Invert for non-zero k\n    phi_hat[nonzero_k_mask] = rho_hat[nonzero_k_mask] / (k[nonzero_k_mask]**2)\n    # phi_hat[0] remains 0 by construction.\n\n    # 4. Apply exponential spectral filter\n    # F_k = exp(-alpha * (|k|/k_max)^p)\n    if alpha > 0 and p > 0:\n        k_max = N / 2.0\n        filter_vals = np.exp(-alpha * (np.abs(k) / k_max)**p)\n        phi_hat *= filter_vals\n\n    # 5. Reconstruct the solution phi in real space via inverse FFT\n    # The reconstruction from continuous Fourier coefficients requires multiplication by N.\n    phi_numerical = N * np.fft.ifft(phi_hat)\n    # The solution should be real; the small imaginary part is numerical noise.\n    phi_numerical = phi_numerical.real\n\n    # 6. Compute the exact solution using the Green's function\n    phi_exact = np.zeros(N)\n    for m, x_pos in zip(masses, positions):\n        # Ensure y is in [0, 2*pi)\n        y = (x - x_pos) % (2 * np.pi)\n        phi_exact += m * periodic_greens_function(y)\n\n    # 7. Calculate and return the maximum absolute error\n    error = np.max(np.abs(phi_numerical - phi_exact))\n    return error\n\nsolve()\n```", "id": "3484238"}, {"introduction": "相对论中的许多问题，例如模拟黑洞外部的时空，都定义在无界区域上。本练习介绍了一种处理此类半无限区域的强大技术：有理切比雪夫函数。你将学习如何将无限区域映射到有限区间，并使用切比雪夫多项式来精确表示具有特定渐近行为的函数，例如引力波的幂律尾部 [@problem_id:3484209]。", "problem": "考虑一个在质量为 $M$ 的固定史瓦西背景上的 (1+1) 维无质量标量场，经过球谐分解并约化为龟坐标下的 Regge–Wheeler 方程。一个经过充分验证的事实是，曲率势的背散射会在固定半径处产生晚期时间幂律尾巴，其中场的行为符合 $\\psi(t,r)\\sim t^{-p}$，指数 $p$ 取决于角模式。为了关注在一个较大但固定的晚期时间 $t$ 的空间分辨率方面，考虑在半无限外部区域 $r\\geq 2M$ 上的以下玩具模型径向剖面：对于 $s\\equiv r-2M\\geq 0$，定义\n$$\nf_{t,p,\\alpha}(s) \\equiv t^{-p}\\,(1+s)^{-\\alpha}.\n$$\n该剖面概括了当 $\\alpha=1$ 时的类出射 $r^{-1}$ 标度行为，以及当 $\\alpha>1$ 时更陡峭的代数衰减，这与晚期时间史瓦西外部区域的渐近衰减行为一致。你的任务是在半无限区间 $s\\in[0,\\infty)$ 上对 $f_{t,p,\\alpha}(s)$ 进行谱方法近似，并定量比较两种在数值相对论中广泛用于半无限区域的伪谱构造：\n\n1. 使用代数映射的有理切比雪夫紧致化\n$$\nx=\\frac{s-L}{s+L},\\quad s\\in[0,\\infty)\\mapsto x\\in[-1,1),\n$$\n其中 $L>0$ 是一个尺度参数。在此坐标系中，可以使用标准切比雪夫基 $\\{T_n(x)\\}_{n\\geq 0}$ 来表示关于 $s$ 的函数。\n\n2. 一种边界条件化的有理切比雪夫基，其通过构造强制场在空间无穷远处为零。具体来说，定义基底\n$$\n\\Psi_n(x)\\equiv T_n(x)-T_{n+1}(x),\\quad n\\geq 0,\n$$\n该基底对所有 $n$ 都满足 $\\Psi_n(1)=0$，因此在紧致化边界 $x=1$ 处编码了 $f_{t,p,\\alpha}(s\\to\\infty)=0$ 的条件。\n\n仅从标量尾模型 $f_{t,p,\\alpha}(s)$ 和区间 $[-1,1]$ 上的切比雪夫多项式 $T_n(x)$ 的基本定义出发，完成以下任务：\n\n- 推导一个实用的伪谱算法，使用 $N+1$ 个切比雪夫–高斯–洛巴托配置点 $x_j=\\cos(\\pi j/N)$（其中 $j=0,1,\\dots,N$）来计算与映射 $x=(s-L)/(s+L)$ 复合的 $f_{t,p,\\alpha}(s)$ 的截断切比雪夫级数。对于标准切比雪夫表示，利用这些节点上的离散正交性来计算 $\\sum_{n=0}^N a_n T_n(x)$ 的系数。\n\n- 使用基底 $\\{\\Psi_n\\}_{n=0}^{N-1}$ 构造一个边界条件化的近似，采用除点 $x_0=1$（对应于 $s=\\infty$ 和 $f_{t,p,\\alpha}=0$）之外的相同配置网格。建立并求解所得的线性系统，使得近似在 $N$ 个有限配置点 $x_j$（其中 $j=1,\\dots,N$）上与数据匹配，并自动满足在 $x=1$ 处的渐近边界条件。\n\n- 为了量化在视界侧 $s=0$ 和远区 $s\\to\\infty$ 附近的近似质量，在一个排除了 $x=1$ 的密集类切比雪夫评估网格 $x\\in(-1,1)$ 上评估最大绝对误差（$L^\\infty$ 范数），该网格通过相同的有理映射被映射回 $s$。精确描述如何选择评估网格，以及它如何探测远场行为 $s\\gg 1$。\n\n- 对这两种近似，提取谱系数衰减的一个标量度量：对于标准切比雪夫展开，记录最后一个系数的大小 $|a_N|$；对于边界条件化的基底，记录展开式 $\\sum_{n=0}^{N-1} b_n \\Psi_n(x)$ 中最后一个系数的大小 $|b_{N-1}|$。\n\n你的程序必须为以下测试套件实现上述内容，其中 $M=1$ 且 $r-2M=s$：\n\n- 测试用例 1（一般晚期时间，平衡映射）：$(\\alpha,p,t,L,N)=(1.0,3.0,50.0,10.0,64)$。\n- 测试用例 2（相同的尾部但更紧密的近视界聚类）：$(\\alpha,p,t,L,N)=(1.0,3.0,50.0,1.0,64)$。\n- 测试用例 3（更陡峭的空间衰减和更晚的时间）：$(\\alpha,p,t,L,N)=(2.0,5.0,80.0,10.0,64)$。\n\n对于每个测试用例，你的程序必须按以下顺序输出四个浮点数：\n- 标准切比雪夫近似在评估网格上的最大绝对误差。\n- 边界条件化的有理切比雪夫近似在同一网格上的最大绝对误差。\n- 最后一个标准切比雪夫系数的大小 $|a_N|$。\n- 最后一个边界条件化系数的大小 $|b_{N-1}|$。\n\n最终输出格式：你的程序应生成单行输出，其中包含所有测试用例的串联结果，形式为逗号分隔的列表，并用方括号括起来，顺序为测试用例 1、2、3。即，该行必须是\n“[E_T1,E_R1,C_T1,C_R1,E_T2,E_R2,C_T2,C_R2,E_T3,E_R3,C_T3,C_R3]”\n所有量均为十进制数。不需要单位，也未使用角度，因此无需指定角度单位。", "solution": "该问题要求对定义在半无限域上的一个函数，进行两种伪谱近似方法的定量比较，其动机源于广义相对论中的晚期时间尾巴。该函数为 $f_{t,p,\\alpha}(s) = t^{-p}\\,(1+s)^{-\\alpha}$，定义在 $s \\in [0, \\infty)$ 上。该域通过有理映射 $s(x) = L\\frac{1+x}{1-x}$ 紧致化为 $x \\in [-1, 1)$。在紧致化坐标 $x$ 中的函数记作 $g(x) \\equiv f(s(x))$。\n\n任务是使用标准有理切比雪夫基和边界条件化的有理切比雪夫基来计算近似，然后评估它们各自的精度和谱系数衰减率。\n\n基本定义如下：\n- 待近似的函数是 $f_{t,p,\\alpha}(s) = t^{-p}(1+s)^{-\\alpha}$，定义在 $s\\in[0,\\infty)$ 上。\n- 坐标映射为 $x = \\frac{s-L}{s+L}$，其逆映射为 $s(x) = L\\frac{1+x}{1-x}$。\n- 紧致化坐标中的函数为 $g(x) = f(s(x)) = t^{-p}\\left(1+L\\frac{1+x}{1-x}\\right)^{-\\alpha} = t^{-p}\\left(\\frac{(L+1)-(L-1)x}{1-x}\\right)^{-\\alpha}$。\n- 第一类切比雪夫多项式由递推关系 $T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)$ 定义，其中 $T_0(x)=1$ 和 $T_1(x)=x$。\n- 配置点是 $N+1$ 个切比雪夫–高斯–洛巴托 (CGL) 节点，$x_j = \\cos(\\frac{\\pi j}{N})$，其中 $j=0,1,\\dots,N$。注意 $x_0=1$ 对应于 $s\\to\\infty$，$x_N=-1$ 对应于 $s=0$。函数在空间无穷远处的值为 $f(s\\to\\infty)=0$，因此我们有 $g(x_0)=g(1)=0$。\n\n分析过程通过推导两种近似方法的算法来进行。\n\n**方法 1：标准有理切比雪夫近似**\n\n此方法通过一个 N 次切比雪夫多项式 $p_N(x)$ 来近似 $g(x)$，该多项式在 $N+1$ 个 CGL 节点上对 $g(x)$ 进行插值。\n$$\np_N(x) = \\sum_{n=0}^N a_n T_n(x)\n$$\n配置条件为 $p_N(x_j) = g(x_j)$，其中 $j=0,1,\\dots,N$。这个插值多项式的系数 $a_n$ 可以利用切比雪夫多项式在 CGL 网格上的离散正交性来计算。系数的显式公式为：\n$$\na_n = \\frac{2}{N \\bar{c}_n} \\sum_{j=0}^N \\frac{g(x_j)}{\\bar{c}_j} T_n(x_j)\n$$\n其中 $\\bar{c}_k$ 是归一化常数，定义为 $\\bar{c}_0 = \\bar{c}_N = 2$，而对于 $k=1, \\dots, N-1$，$\\bar{c}_k = 1$。由于 $T_n(x_j) = \\cos(\\frac{\\pi nj}{N})$，该公式可以写成：\n$$\na_n = \\frac{2}{N \\bar{c}_n} \\sum_{j=0}^N \\frac{g(\\cos(\\frac{\\pi j}{N}))}{\\bar{c}_j} \\cos\\left(\\frac{\\pi nj}{N}\\right)\n$$\n这本质上是I型离散余弦变换 (DCT-I)。这个求和可以直接实现。此方法所需的谱衰减度量是最后一个系数的大小 $|a_N|$。\n\n**方法 2：边界条件化的有理切比雪夫近似**\n\n此方法使用一个为强制执行边界条件 $g(1)=0$ 而特别构造的基。基函数为 $\\Psi_n(x) = T_n(x) - T_{n+1}(x)$，其中 $n \\ge 0$。由于对所有 $n$ 都有 $T_n(1)=1$，因此可得 $\\Psi_n(1) = 1-1=0$。近似被写成一个截断和：\n$$\nq_{N-1}(x) = \\sum_{n=0}^{N-1} b_n \\Psi_n(x)\n$$\n通过构造，$q_{N-1}(1)=0$ 自动匹配了函数在 $s=\\infty$ 处的值。未知系数 $b_n$ 通过在余下的 $N$ 个 CGL 节点 $x_j$（$j=1, \\dots, N$）上强制配置来确定：\n$$\nq_{N-1}(x_j) = g(x_j), \\quad j=1, \\dots, N\n$$\n这为系数 $\\mathbf{b} = (b_0, \\dots, b_{N-1})^T$ 产生了一个 $N\\times N$ 线性方程组：\n$$\n\\sum_{n=0}^{N-1} b_n \\Psi_n(x_j) = g(x_j), \\quad j=1, \\dots, N\n$$\n设此系统写为 $A\\mathbf{b} = \\mathbf{g}$，其中矩阵元素为 $A_{j'n} = \\Psi_n(x_{j'+1})$，右侧向量元素为 $g_{j'} = g(x_{j'+1})$，这里采用 Python 风格的索引 $j', n \\in \\{0, \\dots, N-1\\}$。利用 $x_j = \\cos(\\pi j/N)$ 和 $T_n(x_j) = \\cos(\\pi n j/N)$，矩阵元素为：\n$$\nA_{j'n} = \\cos\\left(\\frac{\\pi n (j'+1)}{N}\\right) - \\cos\\left(\\frac{\\pi (n+1) (j'+1)}{N}\\right)\n$$\n这个线性系统可以使用标准的线性代数求解器求解，以得到系数向量 $\\mathbf{b}$。此方法的谱衰减度量是最后一个系数的大小 $|b_{N-1}|$。\n\n**误差评估**\n\n为了评估近似的质量，我们在一个密集的评估网格上计算最大绝对误差（$L^\\infty$ 范数）。一个合适的网格是更精细的 CGL 类型网格，它在边界 $x=\\pm 1$（$s=0$ 和 $s\\to\\infty$）附近聚集点，谱方法在这些地方通常会表现出更大的误差。我们选择一个有 $N_{eval} = 4N$ 个点的评估网格 $x'_k$：\n$$\nx'_k = \\cos\\left(\\frac{\\pi k}{N_{eval}}\\right), \\quad k=1, \\dots, N_{eval}-1\n$$\n此网格位于开区间 $(-1,1)$ 内，按要求排除了端点。标准近似的误差为 $E_T = \\max_k |p_N(x'_k) - g(x'_k)|$，而边界条件化近似的误差为 $E_R = \\max_k |q_{N-1}(x'_k) - g(x'_k)|$。\n\n为了高效且准确地评估多项式和 $p_N(x)$ 与 $q_{N-1}(x)$，我们可以使用 Clenshaw 算法。对于标准和 $p_N(x) = \\sum_{n=0}^N a_n T_n(x)$，该算法被直接应用。对于边界条件化的和 $q_{N-1}(x) = \\sum_{n=0}^{N-1} b_n \\Psi_n(x)$，我们首先将其表示为标准的切比雪夫级数：\n$$\nq_{N-1}(x) = \\sum_{n=0}^{N-1} b_n (T_n(x) - T_{n+1}(x)) = b_0 T_0(x) + \\sum_{n=1}^{N-1} (b_n - b_{n-1})T_n(x) - b_{N-1}T_N(x)\n$$\n这是一个标准的切比雪夫级数 $\\sum_{n=0}^N c_n T_n(x)$，其系数为 $c_0=b_0$，$c_n=b_n-b_{n-1}$（对于 $1\\le n \\le N-1$），以及 $c_N=-b_{N-1}$。然后可以对这个等价级数应用 Clenshaw 算法。\n\n实现将通过为每个提供的测试用例计算这些量来继续进行。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef clenshaw_chebyshev(x, c):\n    \"\"\"\n    Evaluates a Chebyshev series sum_n c_n T_n(x) using Clenshaw's algorithm.\n    \"\"\"\n    x = np.atleast_1d(x)\n    c = np.atleast_1d(c)\n    if len(c) == 0:\n        return np.zeros_like(x)\n    if len(c) == 1:\n        return np.full_like(x, c[0])\n    \n    y0 = np.zeros_like(x)\n    y1 = np.zeros_like(x)\n    \n    # Use recurrence y_{k-1} = 2*x*y_k - y_{k+1} + c_{k-1}\n    for i in range(len(c) - 1, 0, -1):\n        y_tmp = y0\n        y0 = c[i] + 2 * x * y0 - y1\n        y1 = y_tmp\n        \n    return c[0] + x * y0 - y1\n\ndef compute_metrics(alpha, p, t, L, N):\n    \"\"\"\n    Computes the four specified metrics for a given test case.\n    \"\"\"\n    # 1. Define function and coordinate map\n    def s_map(x):\n        return L * (1.0 + x) / (1.0 - x)\n\n    def g_func(x):\n        # Handle x=1 case where s -> infinity\n        if isinstance(x, (float, np.floating)) and np.isclose(x, 1.0):\n            return 0.0\n        \n        # Vectorized version\n        res = np.zeros_like(x, dtype=float)\n        # Avoid division by zero\n        non_one_mask = ~np.isclose(x, 1.0)\n        x_safe = x[non_one_mask]\n        \n        s_vals = s_map(x_safe)\n        f_vals = np.power(t, -p) * np.power(1.0 + s_vals, -alpha)\n        res[non_one_mask] = f_vals\n        return res\n\n    # 2. Standard Rational Chebyshev Method\n    # CGL grid\n    j_grid = np.arange(N + 1)\n    x_cgl = np.cos(np.pi * j_grid / N)\n    \n    # Function values on CGL grid\n    v = g_func(x_cgl)\n    \n    # Compute coefficients a_n using direct summation\n    c_bar = np.ones(N + 1)\n    c_bar[0], c_bar[N] = 2.0, 2.0\n    \n    a_n = np.zeros(N + 1)\n    for n in range(N + 1):\n        T_n_xj = np.cos(np.pi * n * j_grid / N)\n        sum_val = np.sum(v * T_n_xj / c_bar)\n        a_n[n] = (2.0 / (N * c_bar[n])) * sum_val\n        \n    last_coeff_std = np.abs(a_n[N])\n\n    # 3. Boundary-Conditioned Method\n    # Collocation on x_j for j=1,...,N\n    j_bc_grid = np.arange(1, N + 1)\n    x_bc = np.cos(np.pi * j_bc_grid / N)\n    g_bc = g_func(x_bc)\n\n    # Build matrix A_jn = Psi_n(x_j)\n    A = np.zeros((N, N))\n    n_basis = np.arange(N)\n    for j_idx, j in enumerate(j_bc_grid):\n        arg = np.pi * j / N\n        A[j_idx, :] = np.cos(n_basis * arg) - np.cos((n_basis + 1) * arg)\n    \n    # Solve system A*b = g\n    try:\n        b_n = linalg.solve(A, g_bc)\n    except linalg.LinAlgError:\n        # Fallback to pseudo-inverse if singular, though unlikely for this setup\n        b_n = linalg.pinv(A) @ g_bc\n\n    last_coeff_bc = np.abs(b_n[N-1])\n    \n    # 4. Error Evaluation\n    N_eval = 4 * N\n    k_eval = np.arange(1, N_eval)\n    x_eval = np.cos(np.pi * k_eval / N_eval)\n    g_exact_eval = g_func(x_eval)\n    \n    # Error for standard method\n    p_N_eval = clenshaw_chebyshev(x_eval, a_n)\n    error_std = np.max(np.abs(p_N_eval - g_exact_eval))\n    \n    # Error for boundary-conditioned method\n    # Convert b_n (Psi_n basis) to c_n (T_n basis)\n    c_n_bc = np.zeros(N + 1)\n    c_n_bc[0] = b_n[0]\n    for n in range(1, N):\n        c_n_bc[n] = b_n[n] - b_n[n-1]\n    c_n_bc[N] = -b_n[N-1]\n    \n    q_N_eval = clenshaw_chebyshev(x_eval, c_n_bc)\n    error_bc = np.max(np.abs(q_N_eval - g_exact_eval))\n    \n    return [error_std, error_bc, last_coeff_std, last_coeff_bc]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and format output.\n    \"\"\"\n    test_cases = [\n        # (alpha, p, t, L, N)\n        (1.0, 3.0, 50.0, 10.0, 64),\n        (1.0, 3.0, 50.0, 1.0, 64),\n        (2.0, 5.0, 80.0, 10.0, 64),\n    ]\n\n    results = []\n    for case in test_cases:\n        metrics = compute_metrics(*case)\n        results.extend(metrics)\n\n    # Format output as specified\n    # Example: [E_T1,E_R1,C_T1,C_R1,E_T2,E_R2,C_T2,C_R2,E_T3,E_R3,C_T3,C_R3]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3484209"}, {"introduction": "本练习作为一个综合性实践，将谱方法空间微分的概念与时间演化相结合。你将解决一个简化版的Teukolsky方程，这是研究黑洞微扰理论的核心方程。通过这项练习，你将使用“人造解方法”(Method of Manufactured Solutions)进行验证，构建一个完整的时域求解器，从而在开发和测试数值相对论代码方面获得全面的经验 [@problem_id:3484278]。", "problem": "你的任务是为 Kerr 时空中 Teukolsky 方程的一个简化的方位角模态约化形式实现一个完全自洽的时域伪谱求解器，并将其观测到的谱收敛性与一个用于相同数据的频域伪谱求解器进行比较。其科学背景是 Kerr 黑洞上的微扰，其中 Teukolsky 方程可分离为径向和角向部分，角函数由自spin加权扁球谐函数给出。在慢速旋转和零自旋极限下，自旋加权扁球谐函数简化为普通扁球谐函数，其本征值存在经过充分检验的小参数展开。目标是使用一个构造解来量化方位角坐标下的伪谱收敛性，并比较时域和频域方法。\n\n基本原理：\n- Kerr 黑洞视界的角速度由下式给出：$$\\Omega_{\\mathrm{H}} = \\frac{a}{2 M r_{+}}, \\quad r_{+} = M + \\sqrt{M^{2} - a^{2}},$$ 其中 $a$ 是 Kerr 自旋参数，$M$ 是质量。这是从 Kerr 解的几何结构得出的一个经过充分检验的事实。\n- 对于零自旋（标量情况），自旋加权扁球谐函数本征值在扁率参数 $c = a \\, \\omega$（其中 $\\omega$ 是傅里叶频率）下存在一个小参数展开。对于给定的方位角量子数 $m$ 和角量子数 $l$，一个广泛使用的扁球谐本征值二阶近似为 $$\\lambda_{l m}(c) \\approx l(l+1) + \\frac{2 m^{2} - 2 l(l+1)}{(2l - 1)(2l + 3)} c^{2},$$ 该近似对小的 $|c|$ 有效，并作为黑洞微扰理论中的一个基本近似。\n\n模型与构造数据：\n- 考虑一个周期性的单一方位角坐标 $\\phi \\in [0, 2\\pi)$，并定义以下简化的、线性的、时间一阶的模型偏微分方程（PDE），以模拟 Kerr 黑洞上标量微扰的 Teukolsky 方程的方位角部分动力学：\n$$\\partial_{t} u(\\phi, t) = c_{2} \\, \\partial_{\\phi\\phi} u(\\phi, t) + c_{1} \\, \\partial_{\\phi} u(\\phi, t) + c_{0} \\, u(\\phi, t) + S(\\phi, t; a/M),$$\n其中 $c_{2} = 1$ 是一个常数，$c_{1} = 2 \\, \\Omega_{\\mathrm{H}}$ 捕捉参考系拖拽引起的平流效应，$c_{0} = -\\lambda_{l m}(a \\, \\omega) / \\Lambda$ 具有固定的缩放因子 $\\Lambda > 0$ 以控制刚度。你必须以弧度处理 $\\phi$。\n- 使用以下平滑的构造解：\n$$u_{\\mathrm{exact}}(\\phi, t) = e^{-\\gamma t} \\, g(\\phi) \\, \\cos(\\omega t), \\quad g(\\phi) = \\exp\\!\\big(\\alpha \\cos \\phi\\big),$$\n其中参数 $\\alpha > 0$ 和 $\\gamma > 0$ 是固定的。该函数是实值的、$2\\pi$-周期的，并且在圆上是解析的。\n- 通过将 $u_{\\mathrm{exact}}$ 代入 PDE 并求解 $S$ 来定义源项 $S(\\phi, t; a/M)$，即：\n$$S(\\phi, t; a/M) = \\partial_{t} u_{\\mathrm{exact}} - c_{2} \\, \\partial_{\\phi\\phi} u_{\\mathrm{exact}} - c_{1} \\, \\partial_{\\phi} u_{\\mathrm{exact}} - c_{0} \\, u_{\\mathrm{exact}}.$$\n你必须使用 $g(\\phi)$ 的精确导数来计算 $\\partial_{\\phi} u_{\\mathrm{exact}}$ 和 $\\partial_{\\phi\\phi} u_{\\mathrm{exact}}$：\n$$g'(\\phi) = -\\alpha \\sin\\phi \\, e^{\\alpha \\cos\\phi}, \\quad g''(\\phi) = \\big(-\\alpha \\cos\\phi - \\alpha^{2} \\sin^{2}\\phi\\big) \\, e^{\\alpha \\cos\\phi}.$$\n- 对于频域求解器，假设 $u(\\phi, t) = \\Re\\{U(\\phi) e^{-i \\omega t}\\}$ 并定义时谐源振幅 $S_{h}(\\phi)$，使得 $U_{\\mathrm{exact}}(\\phi) = g(\\phi)$ 精确满足谐波方程：\n$$-i \\omega \\, U(\\phi) = c_{2} \\, \\partial_{\\phi\\phi} U(\\phi) + c_{1} \\, \\partial_{\\phi} U(\\phi) + c_{0} \\, U(\\phi) + S_{h}(\\phi).$$\n因此，设置\n$$S_{h}(\\phi) = -i \\omega \\, g(\\phi) - c_{2} \\, g''(\\phi) - c_{1} \\, g'(\\phi) - c_{0} \\, g(\\phi).$$\n\n需实现的数值方法：\n- 时域伪谱求解器：对周期性域上的空间导数使用基于快速傅里叶变换（FFT）的傅里叶伪谱方法，并使用显式四阶龙格－库塔（RK4）方法进行时间积分。在每一步中，使用 FFT 波数在谱空间计算 $\\partial_{\\phi} u$ 和 $\\partial_{\\phi\\phi} u$，并根据上述公式解析地计算 $S(\\phi, t; a/M)$。\n- 频域伪谱求解器：在傅里叶空间中逐个模态地求解线性代数方程，\n$$\\big(-i \\omega + c_{2}(-k^{2}) + c_{1}(i k) + c_{0}\\big) \\, \\widehat{U}(k) = \\widehat{S}_{h}(k),$$\n其中 $\\widehat{U}(k)$ 和 $\\widehat{S}_{h}(k)$ 是傅里叶系数，$k$ 是整数波数。通过逆 FFT 构建 $U(\\phi)$ 并与 $g(\\phi)$ 进行比较。\n\n误差测量与谱收敛性：\n- 对于时域求解器，使用最终时间 $T$ 的离散 $L^{2}$ 误差；对于频域求解器，使用 $U(\\phi)$ 相对于 $g(\\phi)$ 的离散 $L^{2}$ 误差。其中离散 $L^{2}$ 范数是网格上点态差的均方根。\n- 对每种方法，计算谱分辨率为 $N=16$、$N=32$ 和 $N=64$ 时的误差。通过误差衰减因子 $$\\rho = \\frac{E_{32}}{E_{64}},$$ 来量化从 $N=32$ 到 $N=64$ 的观测谱收敛性。如果实现正确，对于解析数据，该因子应反映指数收敛。更大的 $\\rho$ 表示 $N$ 每加倍一次，衰减更快。\n\n参数、单位和测试套件：\n- 固定 $M = 1$（无量纲），角度以弧度为单位。\n- 使用 $l = 2$、$m = 2$、$\\alpha = 0.5$、$\\gamma = 0.1$、$\\omega = 1.3$、$c_{2} = 1$、$\\Lambda = 10$，最终时间 $T = 1.0$。\n- 设置时间步长 $\\Delta t$ 与 $1/N$ 成正比：对于 $N=16$，$\\Delta t = 2\\times 10^{-3}$；对于 $N=32$，$\\Delta t = 1\\times 10^{-3}$；对于 $N=64$，$\\Delta t = 5\\times 10^{-4}$。选择这些值是为了确保对包含二阶导数项的方程进行稳定的显式积分。\n- Kerr 自旋比 $a/M$ 的测试套件值：$a/M = 0.0$（Schwarzschild 极限）、$a/M = 0.5$（中等旋转）、$a/M = 0.9$（近极端旋转）。\n- 对于每个 $a/M$，计算并报告两个浮点数：从 $N=32$ 到 $N=64$ 的时域误差衰减因子，以及从 $N=32$ 到 $N=64$ 的频域误差衰减因子。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，包含三个条目（每个 $a/M$ 一个），每个条目是一个包含两个浮点数的列表，顺序为 [时域衰减因子, 频域衰减因子]。输出必须采用\n$$[\\,[r_{t}(0.0), r_{f}(0.0)],\\,[r_{t}(0.5), r_{f}(0.5)],\\,[r_{t}(0.9), r_{f}(0.9)]\\,],$$\n的形式，并精确地作为单个字符串打印，例如：[[1.23,4.56],[1.78,3.21],[2.34,5.67]]。", "solution": "问题陈述已经过验证，被认为是可靠、适定且有科学依据的。它在数值相对论和计算物理领域提出了一个明确的任务：为一个模型问题实现并比较时域和频域伪谱求解器。所有必需的常数、方程和数值参数都已提供，且设置是内部一致的。我们现在开始进行解答。\n\n问题的核心是使用两种不同的伪谱方法求解一个模型偏微分方程（PDE），并量化它们的数值收敛性。该 PDE 由以下公式给出：\n$$\n\\partial_{t} u(\\phi, t) = c_{2} \\, \\partial_{\\phi\\phi} u(\\phi, t) + c_{1} \\, \\partial_{\\phi} u(\\phi, t) + c_{0} \\, u(\\phi, t) + S(\\phi, t; a/M)\n$$\n在周期性域 $\\phi \\in [0, 2\\pi)$ 上。系数 $c_1$ 和 $c_0$ 取决于 Kerr 黑洞的物理参数，即其质量 $M$ 和自旋参数 $a$。我们给定 $M=1$ 和 $a/M$ 的测试用例。\n\n首先，我们定义函数来计算这些系数。视界角速度 $\\Omega_{\\mathrm{H}}$ 和中间参数 $r_+$ 为：\n$$\nr_{+} = M + \\sqrt{M^{2} - a^{2}}, \\quad \\Omega_{\\mathrm{H}} = \\frac{a}{2 M r_{+}}\n$$\n由此，平流系数为 $c_1 = 2 \\Omega_{\\mathrm{H}}$。反应系数 $c_0$ 从自旋 $s=0$ 的扁球谐本征值 $\\lambda_{lm}$ 的一个近似推导得出：\n$$\nc = a\\omega, \\quad \\lambda_{l m}(c) \\approx l(l+1) + \\frac{2 m^{2} - 2 l(l+1)}{(2l - 1)(2l + 3)} c^{2}\n$$\n当 $l=2$，$m=2$ 且缩放因子 $\\Lambda=10$ 时，这给出：\n$$\nc_0 = -\\frac{\\lambda_{22}(a\\omega)}{\\Lambda} = -\\frac{1}{10}\\left(6 - \\frac{4}{21}(a\\omega)^2\\right)\n$$\n扩散系数固定为 $c_2 = 1$。必须对 $a/M \\in \\{0.0, 0.5, 0.9\\}$ 进行分析。\n\n该问题采用了构造解法，即假设一个精确解并推导出相应的源项。构造解为：\n$$\nu_{\\mathrm{exact}}(\\phi, t) = e^{-\\gamma t} \\, g(\\phi) \\, \\cos(\\omega t), \\quad \\text{where} \\quad g(\\phi) = \\exp(\\alpha \\cos \\phi)\n$$\n时域求解器的源项 $S(\\phi, t)$ 的定义使得 $u_{\\mathrm{exact}}$ 恒等地满足该 PDE：\n$$\nS(\\phi, t) = \\partial_{t} u_{\\mathrm{exact}} - \\big(c_{2} \\partial_{\\phi\\phi} u_{\\mathrm{exact}} + c_{1} \\partial_{\\phi} u_{\\mathrm{exact}} + c_{0} u_{\\mathrm{exact}}\\big)\n$$\n我们解析地计算 $u_{\\mathrm{exact}}$ 的必要导数，以精确定义 $S(\\phi, t)$。\n\n**时域伪谱求解器：**\n该方法从 $u(\\phi, 0) = u_{\\mathrm{exact}}(\\phi, 0) = g(\\phi)$ 开始求解初值问题。\n1.  **空间离散化：** 将域 $\\phi \\in [0, 2\\pi)$ 离散化为 $N$ 个等距点 $\\phi_j = 2\\pi j/N$（$j=0, \\dots, N-1$）。空间导数 $\\partial_\\phi$ 和 $\\partial_{\\phi\\phi}$ 在傅里叶空间中计算。网格上的函数 $f(\\phi)$ 使用快速傅里叶变换（FFT）进行变换。如果 $\\widehat{f}(k)$ 是整数波数 $k$ 的傅里葉系数，则导数的系数分别为 $(ik)\\widehat{f}(k)$ 和 $(-k^2)\\widehat{f}(k)$。然后，逆 FFT 返回网格上的导数值。\n2.  **时间积分：** 我们使用经典的四阶龙格－库塔（RK4）方法使系统从 $t=0$ 演化到 $t=T=1.0$。为每个分辨率 $N$ 指定了时间步长 $\\Delta t$。在 RK4 积分器的每个阶段，我们计算 PDE 的右侧，这涉及计算谱导数和在相应时间点计算解析源项 $S(\\phi, t)$。\n3.  **误差计算：** 在最终时间 $T$，使用离散 $L^2$ 误差范数将数值解 $u(\\phi_j, T)$ 与精确解 $u_{\\mathrm{exact}}(\\phi_j, T)$ 进行比较。\n\n**频域伪谱求解器：**\n该方法在频域中求解问题，假设一个时谐解 $u(\\phi, t) = \\Re\\{U(\\phi) e^{-i\\omega t}\\}$。该 PDE 简化为关于复振幅 $U(\\phi)$ 的一个常微分方程（ODE）：\n$$\n-i \\omega \\, U(\\phi) = c_{2} \\, \\partial_{\\phi\\phi} U(\\phi) + c_{1} \\, \\partial_{\\phi} U(\\phi) + c_{0} \\, U(\\phi) + S_{h}(\\phi)\n$$\n振幅的精确解为 $U_{\\mathrm{exact}}(\\phi) = g(\\phi)$。定义时谐源 $S_h(\\phi)$ 以确保这一点：\n$$\nS_{h}(\\phi) = -i \\omega g(\\phi) - \\big(c_2 g''(\\phi) + c_1 g'(\\phi) + c_0 g(\\phi)\\big)\n$$\n1.  **傅里叶空间解：** 我们将此 ODE 变换到傅里叶空间。应用 FFT 将微分转换为乘以 $(ik)$ 和 $(-k^2)$。这为每个傅里叶模态 $\\widehat{U}(k)$ 产生一个简单的代数方程：\n$$\n\\big(-i \\omega + c_{2}(-k^{2}) + c_{1}(i k) + c_{0}\\big) \\, \\widehat{U}(k) = \\widehat{S}_{h}(k)\n$$\n我们首先在网格上解析地计算 $S_h(\\phi)$，然后通过 FFT 找到其傅里叶系数 $\\widehat{S}_h(k)$。然后我们通过除法求解每个 $\\widehat{U}(k)$。\n2.  **逆变换与误差计算：** 通过对 $\\widehat{U}(k)$ 系数应用逆 FFT 来恢复数值解 $U(\\phi)$。通过使用离散 $L^2$ 范数比较得到的 $U(\\phi_j)$ 与精确振幅 $g(\\phi_j)$ 来计算误差。\n\n**收敛性分析：**\n对于两种求解器，我们都计算网格分辨率为 $N=16, 32, 64$ 时的误差 $E_{16}$、$E_{32}$ 和 $E_{64}$。谱收敛性由衰减因子 $\\rho = E_{32}/E_{64}$ 来量化。由于构造解是解析的，我们期望指数收敛，这意味着误差应随 $N$ 的增加而非常迅速地减小，从而导致 $\\rho$ 值很大。对每个指定的 $a/M$ 值重复整个过程。\n\n实现将结构化为单个 Python 脚本。将定义用于计算系数、源项和执行每个求解器的辅助函数，最终为所有测试用例计算衰减因子，并以指定格式打印它们。`numpy.fft.fftfreq` 和 `numpy.fft.fft`/`ifft` 的使用是伪谱导数计算的核心。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Implements and compares time-domain and frequency-domain pseudospectral solvers\n    for a model PDE related to black hole perturbations, and computes their\n    spectral convergence factors.\n    \"\"\"\n    \n    # Define the problem parameters from the statement.\n    config = {\n        \"M\": 1.0,\n        \"l\": 2,\n        \"m_azi\": 2,\n        \"alpha\": 0.5,\n        \"gamma\": 0.1,\n        \"omega\": 1.3,\n        \"c2\": 1.0,\n        \"Lambda\": 10.0,\n        \"T_final\": 1.0,\n        \"N_vals\": [16, 32, 64],\n        \"dt_vals\": [2e-3, 1e-3, 5e-4],\n        \"a_over_M_vals\": [0.0, 0.5, 0.9]\n    }\n\n    def l2_error(numerical, exact):\n        \"\"\"Computes the discrete L2 error.\"\"\"\n        return np.sqrt(np.mean(np.abs(numerical - exact)**2))\n\n    def get_coefficients(a_over_M, params):\n        \"\"\"Calculates PDE coefficients based on a/M.\"\"\"\n        a = a_over_M * params[\"M\"]\n        M = params[\"M\"]\n        \n        if a == M:\n            r_plus = M\n        else:\n            r_plus = M + np.sqrt(M**2 - a**2)\n        \n        omega_H = a / (2 * M * r_plus)\n        c1 = 2 * omega_H\n        \n        c_param = a * params[\"omega\"]\n        l, m = params[\"l\"], params[\"m_azi\"]\n        lambda_lm = l * (l + 1) + (2 * m**2 - 2 * l * (l + 1)) / ((2 * l - 1) * (2 * l + 3)) * c_param**2\n        c0 = -lambda_lm / params[\"Lambda\"]\n        \n        return c1, c0\n\n    def get_g_functions(phi, params):\n        \"\"\"Computes g(phi) and its derivatives.\"\"\"\n        g = np.exp(params[\"alpha\"] * np.cos(phi))\n        g_prime = -params[\"alpha\"] * np.sin(phi) * g\n        g_prime_prime = (-params[\"alpha\"] * np.cos(phi) - params[\"alpha\"]**2 * np.sin(phi)**2) * g\n        return g, g_prime, g_prime_prime\n\n    def get_exact_solution(phi, t, params):\n        \"\"\"Computes the exact manufactured solution u(phi, t).\"\"\"\n        g, _, _ = get_g_functions(phi, params)\n        u_exact = np.exp(-params[\"gamma\"] * t) * g * np.cos(params[\"omega\"] * t)\n        return u_exact\n\n    def get_time_domain_source(phi, t, c1, c0, params):\n        \"\"\"Computes the manufactured source term S(phi, t).\"\"\"\n        g, g_prime, g_prime_prime = get_g_functions(phi, params)\n        \n        cos_wt = np.cos(params[\"omega\"] * t)\n        sin_wt = np.sin(params[\"omega\"] * t)\n        exp_gt = np.exp(-params[\"gamma\"] * t)\n\n        u_exact = exp_gt * g * cos_wt\n        u_t_exact = exp_gt * g * (-params[\"gamma\"] * cos_wt - params[\"omega\"] * sin_wt)\n        u_phi_exact = exp_gt * g_prime * cos_wt\n        u_phiphi_exact = exp_gt * g_prime_prime * cos_wt\n\n        source = u_t_exact - (params[\"c2\"] * u_phiphi_exact + c1 * u_phi_exact + c0 * u_exact)\n        return source\n\n    def solve_time_domain(N, dt, a_over_M, params):\n        \"\"\"Solves the PDE using a time-domain pseudospectral method.\"\"\"\n        phi = np.linspace(0, 2 * np.pi, N, endpoint=False)\n        k = fftfreq(N) * N\n        \n        c1, c0 = get_coefficients(a_over_M, params)\n        \n        u = get_exact_solution(phi, 0.0, params)\n        t = 0.0\n        num_steps = int(round(params[\"T_final\"] / dt))\n\n        def rhs(t_current, u_current):\n            u_hat = fft(u_current)\n            du_dphi_hat = 1j * k * u_hat\n            d2u_dphi2_hat = -(k**2) * u_hat\n            \n            du_dphi = ifft(du_dphi_hat).real\n            d2u_dphi2 = ifft(d2u_dphi2_hat).real\n            \n            source = get_time_domain_source(phi, t_current, c1, c0, params)\n            \n            dudt = params[\"c2\"] * d2u_dphi2 + c1 * du_dphi + c0 * u_current + source\n            return dudt\n\n        for _ in range(num_steps):\n            k1 = dt * rhs(t, u)\n            k2 = dt * rhs(t + 0.5 * dt, u + 0.5 * k1)\n            k3 = dt * rhs(t + 0.5 * dt, u + 0.5 * k2)\n            k4 = dt * rhs(t + dt, u + k3)\n            u += (k1 + 2*k2 + 2*k3 + k4) / 6.0\n            t += dt\n\n        u_final_exact = get_exact_solution(phi, t, params)\n        error = l2_error(u, u_final_exact)\n        return error\n\n    def get_freq_domain_source(phi, c1, c0, params):\n        \"\"\"Computes the time-harmonic source Sh(phi).\"\"\"\n        g, g_prime, g_prime_prime = get_g_functions(phi, params)\n        source_h = -1j * params[\"omega\"] * g - (params[\"c2\"] * g_prime_prime + c1 * g_prime + c0 * g)\n        return source_h\n\n    def solve_freq_domain(N, a_over_M, params):\n        \"\"\"Solves the PDE using a frequency-domain pseudospectral method.\"\"\"\n        phi = np.linspace(0, 2 * np.pi, N, endpoint=False)\n        k = fftfreq(N) * N\n        \n        c1, c0 = get_coefficients(a_over_M, params)\n        \n        Sh = get_freq_domain_source(phi, c1, c0, params)\n        Sh_hat = fft(Sh)\n        \n        op = -1j * params[\"omega\"] + params[\"c2\"] * (-k**2) + c1 * (1j * k) + c0\n        \n        U_hat = Sh_hat / op\n        U_numerical = ifft(U_hat).real\n        U_exact, _, _ = get_g_functions(phi, params)\n        \n        error = l2_error(U_numerical, U_exact)\n        return error\n\n    all_results = []\n    \n    for a_over_M in config[\"a_over_M_vals\"]:\n        td_errors = []\n        fd_errors = []\n        \n        for N, dt in zip(config[\"N_vals\"], config[\"dt_vals\"]):\n            td_error = solve_time_domain(N, dt, a_over_M, config)\n            td_errors.append(td_error)\n            \n            fd_error = solve_freq_domain(N, a_over_M, config)\n            fd_errors.append(fd_error)\n            \n        td_decay = td_errors[1] / td_errors[2] if td_errors[2] != 0 else float('inf')\n        fd_decay = fd_errors[1] / fd_errors[2] if fd_errors[2] != 0 else float('inf')\n        \n        all_results.append([td_decay, fd_decay])\n        \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3484278"}]}