{"hands_on_practices": [{"introduction": "掌握线方法（Method of Lines）的第一步，是亲手将时间积分器与空间离散格式结合起来。这个练习提供了一个具体的实践机会，要求你为平流方程这一数值相对论中的基本模型，推导在使用经典的四阶龙格-库塔（RK4）方法时的完整更新格式。通过这个推导，你将深刻理解从半离散常微分方程组到最终单步更新公式的全过程 [@problem_id:3493026]。", "problem": "在数值相对论中使用的许多爱因斯坦场方程的双曲形式中，某些特征场沿着由规范设定的优选方向近似地作为平流输运量传播。作为一个在一维均匀空间网格上与线性化引力波相关的出射特征的简化模型，考虑一个标量场 $h(t,x)$ 满足常系数平流方程 $\\partial_{t} h + v \\,\\partial_{x} h = 0$，其中 $v$ 是一个正常数速度。使用线方法（MOL），在均匀网格 $x_{i} = i\\,\\Delta x$ 上对空间进行离散化，并在时间层 $t^{n} = t^{0} + n\\,\\Delta t$ 上定义网格函数 $u_{i}^{n} \\approx h(t^{n}, x_{i})$。用中心差分算子 $D_{0}$ 来近似空间导数，其定义为 $D_{0} u_{i} = \\big(u_{i+1} - u_{i-1}\\big)/(2\\,\\Delta x)$，因此半离散系统在一个足够扩展或周期性的域上（使得所有需要的模板点都有良好定义）可写为 $\\frac{d}{dt}\\,\\mathbf{u}(t) = -\\,v\\,D_{0}\\,\\mathbf{u}(t)$。\n\n应用经典的四阶 Runge–Kutta (RK) 方法将时间从 $t^{n}$ 推进一个时间步长到 $t^{n+1} = t^{n} + \\Delta t$。从基本的平流定律和中心差分半离散化出发，根据第一性原理推导网格函数 $\\mathbf{u}^{n}$ 的四个阶段更新，并简化结果，以获得每个分量 $u_{i}^{n+1}$ 的单步更新表达式，该表达式完全用 $\\{u_{i+k}^{n}\\}_{k=-4}^{4}$ 和无量纲的库朗数 $\\lambda = v\\,\\Delta t/\\Delta x$ 表示。\n\n将您的最终结果以一个关于 $\\lambda$ 和 RK4 模板上 $u^{n}$ 的邻近值的封闭形式解析表达式给出。不需要进行数值计算或舍入，最终表达式中也不应包含任何物理单位。", "solution": "控制偏微分方程（PDE）是标量场 $h(t,x)$ 的常系数平流方程：\n$$\n\\partial_{t} h + v \\,\\partial_{x} h = 0\n$$\n其中 $v$ 是一个正常数速度。\n\n问题指定了在均匀网格 $x_{i} = i\\,\\Delta x$ 上使用线方法的半离散化。空间导数 $\\partial_x h$ 由二阶中心差分算子 $D_0$ 近似：\n$$\nD_{0} u_{i} = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}\n$$\n其中 $u_i(t) \\approx h(t, x_i)$。这为网格函数 $u_i(t)$ 产生了一个常微分方程（ODE）系统：\n$$\n\\frac{d u_i}{dt} = -v D_0 u_i = -v \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}\n$$\n该系统是线性的，可以写成向量形式 $\\frac{d}{dt}\\mathbf{u}(t) = L\\mathbf{u}(t)$，其中 $L$ 是表示右侧项的线性算子，$L = -v D_0$。\n\n经典的四阶 Runge-Kutta (RK4) 方法用于将解从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$。对于一个线性的、不依赖于时间的常微分方程系统 $\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}$，RK4 更新公式等价于矩阵指数算子 $\\exp(\\Delta t L)$ 的截断泰勒级数展开：\n$$\n\\mathbf{u}^{n+1} = \\left( I + \\Delta t L + \\frac{(\\Delta t L)^2}{2!} + \\frac{(\\Delta t L)^3}{3!} + \\frac{(\\Delta t L)^4}{4!} \\right) \\mathbf{u}^{n}\n$$\n其中 $I$ 是单位算子。我们定义无量纲的库朗数 $\\lambda = v\\,\\Delta t/\\Delta x$。我们可以用 $\\lambda$ 和一个纯粹的几何差分算子来表示算子 $\\Delta t L$。设 $D_c$ 为中心差分算子，使得 $D_c u_i = u_{i+1} - u_{i-1}$。那么，\n$$\n\\Delta t L = -v \\Delta t D_0 = -v \\Delta t \\frac{D_c}{2 \\Delta x} = -\\frac{v \\Delta t}{2 \\Delta x} D_c = -\\frac{\\lambda}{2} D_c\n$$\n我们记算子 $A = \\Delta t L = -\\frac{\\lambda}{2} D_c$。单个网格点 $u_i$ 的更新规则是：\n$$\nu_i^{n+1} = \\left( I + A + \\frac{A^2}{2} + \\frac{A^3}{6} + \\frac{A^4}{24} \\right) u_i^n\n$$\n为了找到显式公式，我们需要计算算子 $A$ 的幂对 $u_i^n$ 的作用。这需要计算差分算子 $D_c$ 的幂：\n\\begin{itemize}\n    \\item $A u_i^n = -\\frac{\\lambda}{2} D_c u_i^n = -\\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n)$\n    \\item $A^2 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^2 D_c^2 u_i^n = \\frac{\\lambda^2}{4} D_c(u_{i+1}^n - u_{i-1}^n) = \\frac{\\lambda^2}{4} \\left( (u_{i+2}^n - u_i^n) - (u_i^n - u_{i-2}^n) \\right) = \\frac{\\lambda^2}{4} (u_{i+2}^n - 2u_i^n + u_{i-2}^n)$\n    \\item $A^3 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^3 D_c^3 u_i^n = -\\frac{\\lambda^3}{8} D_c(u_{i+2}^n - 2u_i^n + u_{i-2}^n) = -\\frac{\\lambda^3}{8} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n)$\n    \\item $A^4 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^4 D_c^4 u_i^n = \\frac{\\lambda^4}{16} D_c(u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) = \\frac{\\lambda^4}{16} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)$\n\\end{itemize}\n现在我们将这些表达式代回到 RK4 更新公式中：\n$$\nu_i^{n+1} = u_i^n + A u_i^n + \\frac{1}{2}A^2 u_i^n + \\frac{1}{6}A^3 u_i^n + \\frac{1}{24}A^4 u_i^n\n$$\n$$\n\\begin{aligned}\nu_i^{n+1} = u_i^n  - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n) \\\\\n + \\frac{1}{2}\\frac{\\lambda^2}{4} (u_{i+2}^n - 2u_i^n + u_{i-2}^n) \\\\\n - \\frac{1}{6}\\frac{\\lambda^3}{8} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) \\\\\n + \\frac{1}{24}\\frac{\\lambda^4}{16} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)\n\\end{aligned}\n$$\n简化每一项的系数：\n$$\n\\begin{aligned}\nu_i^{n+1} = u_i^n  - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n) \\\\\n + \\frac{\\lambda^2}{8} (u_{i+2}^n - 2u_i^n + u_{i-2}^n) \\\\\n - \\frac{\\lambda^3}{48} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) \\\\\n + \\frac{\\lambda^4}{384} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)\n\\end{aligned}\n$$\n最后一步是收集每个网格点值 $u_{i+k}^n$ (其中 $k \\in \\{-4, -3, \\dots, 3, 4\\}$) 的系数。\n\\begin{itemize}\n    \\item $u_{i+4}^n$ 的系数：来自 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^4}{384}$。\n    \\item $u_{i+3}^n$ 的系数：来自 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda^3}{48}$。\n    \\item $u_{i+2}^n$ 的系数：来自 $\\lambda^2$ 和 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^2}{8} + \\frac{\\lambda^4}{384}(-4) = \\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}$。\n    \\item $u_{i+1}^n$ 的系数：来自 $\\lambda$ 和 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda}{2} - \\frac{\\lambda^3}{48}(-3) = -\\frac{\\lambda}{2} + \\frac{\\lambda^3}{16}$。\n    \\item $u_i^n$ 的系数：来自初始项、$\\lambda^2$ 和 $\\lambda^4$ 项，我们得到 $1 + \\frac{\\lambda^2}{8}(-2) + \\frac{\\lambda^4}{384}(6) = 1 - \\frac{\\lambda^2}{4} + \\frac{\\lambda^4}{64}$。\n    \\item $u_{i-1}^n$ 的系数：来自 $\\lambda$ 和 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda}{2}(-1) - \\frac{\\lambda^3}{48}(3) = \\frac{\\lambda}{2} - \\frac{\\lambda^3}{16}$。\n    \\item $u_{i-2}^n$ 的系数：来自 $\\lambda^2$ 和 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^2}{8}(1) + \\frac{\\lambda^4}{384}(-4) = \\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}$。\n    \\item $u_{i-3}^n$ 的系数：来自 $\\lambda^3$ 项，我们得到 $-\\frac{\\lambda^3}{48}(-1) = \\frac{\\lambda^3}{48}$。\n    \\item $u_{i-4}^n$ 的系数：来自 $\\lambda^4$ 项，我们得到 $\\frac{\\lambda^4}{384}$。\n\\end{itemize}\n将这些系数合并，得到 $u_i^{n+1}$ 的最终单步更新公式。", "answer": "$$\n\\boxed{u_i^{n+1} = \\left(1 - \\frac{\\lambda^2}{4} + \\frac{\\lambda^4}{64}\\right)u_i^n + \\left(-\\frac{\\lambda}{2} + \\frac{\\lambda^3}{16}\\right)u_{i+1}^n + \\left(\\frac{\\lambda}{2} - \\frac{\\lambda^3}{16}\\right)u_{i-1}^n + \\left(\\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}\\right)(u_{i+2}^n + u_{i-2}^n) + \\left(-\\frac{\\lambda^3}{48}\\right)u_{i+3}^n + \\left(\\frac{\\lambda^3}{48}\\right)u_{i-3}^n + \\left(\\frac{\\lambda^4}{384}\\right)(u_{i+4}^n + u_{i-4}^n)}\n$$", "id": "3493026"}, {"introduction": "虽然高阶空间离散格式能提供高精度，但它们往往会引入非物理的振荡，破坏解的稳定性。本练习将探讨如何通过添加人工耗散来恢复一个中心差分格式的单调性（monotonicity），这是一个保证数值解行为良好的重要性质。更重要的是，它揭示了半离散算子的性质与一类特殊的强稳定性保持（Strong Stability Preserving, SSP）龙格-库塔方法的时间步长限制之间的关键联系 [@problem_id:3493000]。", "problem": "考虑线性平流方程 $\\partial_{t} u + a \\,\\partial_{x} u = 0$，其中平流速度 $a>0$ 为常数。该方程建立在间距为 $\\Delta x$ 的均匀空间网格上，并采用周期性边界条件。使用直线法，通过中心差分算子对平流项进行空间半离散化，并添加一个在离散 $\\ell^{2}$ 内积意义下为半正定的人工耗散项。具体来说，取\n$$\n\\frac{d u_{i}}{dt} \\;=\\; -\\,a \\,D^{0} u_{i} \\;+\\; \\varepsilon \\, D^{+}D^{-} u_{i},\n$$\n其中 $D^{0} u_{i} = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}$ 且 $D^{+}D^{-} u_{i} = \\frac{u_{i+1} - 2 u_{i} + u_{i-1}}{\\Delta x^{2}}$。假设人工耗散系数 $\\varepsilon$ 的选择与特征速度和网格间距成正比，即 $\\varepsilon = \\theta \\,\\frac{a\\,\\Delta x}{2}$，其中参数 $\\theta \\ge 0$。时间积分采用经典的三阶段三阶强保稳定性 (SSP) Runge–Kutta 方法 (SSPRK($3,3$)) 进行，单调性应在离散 $\\ell^{\\infty}$-范数下进行解释。\n\n从直线法、中心差分和离散极值原理（凸组合刻画）的基本定义出发，完成以下任务：\n- 证明与上述半离散算子相关联的前向欧拉更新是相邻网格点值的凸组合，当且仅当 $\\theta \\ge 1$ 且 Courant–Friedrichs–Lewy 数 $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$ 满足 $\\nu \\le \\frac{1}{\\theta}$。推断出在此条件下，添加的耗散项是半正定的，并且恢复了中心差分的 $\\ell^{\\infty}$-单调性。\n- 仅利用强保稳定性 Runge–Kutta 方法作为前向欧拉步的凸组合这一定义性质，确定 SSPRK($3,3$) 在保持相同单调性属性下的最大允许时间步长。\n\n以 $a$、$\\Delta x$ 和 $\\theta$ 表示最大允许时间步长 $\\Delta t_{\\max}$，并提供一个单一的闭式表达式作为最终答案。答案以秒为单位表示。无需四舍五- 仅利用强保稳定性 Runge–Kutta 方法作为前向欧拉步的凸组合这一定义性质，确定 SSPRK($3,3$) 在保持相同单调性属性下的最大允许时间步长。\n\n以 $a$、$\\Delta x$ 和 $\\theta$ 表示最大允许时间步长 $\\Delta t_{\\max}$，并提供一个单一的闭式表达式作为最终答案。答案以秒为单位表示。无需四舍五入。", "solution": "该问题要求分析一个用于线性平流方程的数值格式，该格式结合了直线法、带有人工耗散的特定空间离散化方法，以及一个强保稳定性 (SSP) 时间积分器。我们必须首先验证前向欧拉法是单调的条件，然后利用这个结果来求出 SSPRK($3,3$) 方法的最大允许时间步长。\n\n首先，我们分析半离散方程。空间算子（我们记为 $L$）由下式给出：\n$$\n\\frac{d u_{i}}{dt} = L(u_i) = -\\,a \\,D^{0} u_{i} \\;+\\; \\varepsilon \\, D^{+}D^{-} u_{i}\n$$\n代入算子 $D^{0} u_{i} = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}$ 和 $D^{+}D^{-} u_{i} = \\frac{u_{i+1} - 2 u_{i} + u_{i-1}}{\\Delta x^{2}}$ 的定义，我们得到：\n$$\n\\frac{d u_{i}}{dt} = -a \\left( \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x} \\right) + \\varepsilon \\left( \\frac{u_{i+1} - 2 u_{i} + u_{i-1}}{\\Delta x^{2}} \\right)\n$$\n问题陈述人工耗散系数为 $\\varepsilon = \\theta \\,\\frac{a\\,\\Delta x}{2}$，其中参数 $\\theta \\ge 0$。将 $\\varepsilon$ 的表达式代入：\n$$\n\\frac{d u_{i}}{dt} = -a \\left( \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x} \\right) + \\theta \\frac{a\\,\\Delta x}{2} \\left( \\frac{u_{i+1} - 2 u_{i} + u_{i-1}}{\\Delta x^{2}} \\right)\n$$\n\n第一个任务是分析前向欧拉时间积分格式：\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\, L(u_i^n)\n$$\n代入 $L(u_i^n)$ 的表达式：\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ -a \\left( \\frac{u_{i+1}^n - u_{i-1}^n}{2\\,\\Delta x} \\right) + \\theta \\frac{a\\,\\Delta x}{2} \\left( \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^{2}} \\right) \\right]\n$$\n我们引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$。我们可以将 $\\Delta t$ 重写为 $\\Delta t = \\nu \\frac{\\Delta x}{a}$。将其代入更新方程：\n$$\nu_i^{n+1} = u_i^n + \\nu \\frac{\\Delta x}{a} \\left[ -a \\left( \\frac{u_{i+1}^n - u_{i-1}^n}{2\\,\\Delta x} \\right) + \\theta \\frac{a\\,\\Delta x}{2} \\left( \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^{2}} \\right) \\right]\n$$\n通过消项来化简表达式：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\nu}{2} (u_{i+1}^n - u_{i-1}^n) + \\frac{\\nu\\theta}{2} (u_{i+1}^n - 2 u_i^n + u_{i-1}^n)\n$$\n现在，我们收集 $u_{i-1}^n$、$u_i^n$ 和 $u_{i+1}^n$ 的系数，将更新写成 $u_i^{n+1} = C_{i-1} u_{i-1}^n + C_i u_i^n + C_{i+1} u_{i+1}^n$ 的形式：\n$u_{i-1}^n$ 的系数是 $C_{i-1} = \\frac{\\nu}{2} + \\frac{\\nu\\theta}{2} = \\frac{\\nu}{2}(1 + \\theta)$。\n$u_{i+1}^n$ 的系数是 $C_{i+1} = -\\frac{\\nu}{2} + \\frac{\\nu\\theta}{2} = \\frac{\\nu}{2}(\\theta - 1)$。\n$u_i^n$ 的系数是 $C_i = 1 - 2\\frac{\\nu\\theta}{2} = 1 - \\nu\\theta$。\n\n为了使更新成为相邻网格点值的凸组合，必须满足两个条件：\n1. 系数之和必须为1：$\\sum C_j = 1$。\n2. 每个系数都必须是非负的：$C_j \\ge 0$。\n\n我们来检查和：\n$$\nC_{i-1} + C_i + C_{i+1} = \\frac{\\nu}{2}(1+\\theta) + (1-\\nu\\theta) + \\frac{\\nu}{2}(\\theta-1) = \\frac{\\nu}{2} + \\frac{\\nu\\theta}{2} + 1 - \\nu\\theta + \\frac{\\nu\\theta}{2} - \\frac{\\nu}{2} = 1\n$$\n系数之和恒为 $1$。\n\n现在，我们来检查非负性条件。给定 $a>0$、$\\Delta t > 0$ 和 $\\Delta x > 0$，这意味着 $\\nu > 0$。同时给定 $\\theta \\ge 0$。\n- $C_{i-1} = \\frac{\\nu}{2}(1+\\theta) \\ge 0$。由于 $\\nu > 0$ 且 $\\theta \\ge 0$，这个条件总是满足的。\n- $C_{i+1} = \\frac{\\nu}{2}(\\theta-1) \\ge 0$。由于 $\\nu > 0$，这要求 $\\theta-1 \\ge 0$，即 $\\theta \\ge 1$。\n- $C_i = 1 - \\nu\\theta \\ge 0$。这要求 $\\nu\\theta \\le 1$。既然我们已经确定 $\\theta \\ge 1$，我们可以两边同除以 $\\theta$ 得到 $\\nu \\le \\frac{1}{\\theta}$。\n\n综合这些条件，前向欧拉更新是凸组合当且仅当 $\\theta \\ge 1$ 且 $\\nu \\le \\frac{1}{\\theta}$。这证明了问题的第一部分。\n\n一个作为凸组合的格式满足离散极值原理，即 $\\min_{j}(u_j^n) \\le u_i^{n+1} \\le \\max_{j}(u_j^n)$。这个性质保证了不会产生新的极值，并且是 $\\ell^{\\infty}$-单调性的一个充分条件。纯中心差分格式（$\\theta = 0$）会导致 $C_{i+1} = -\\nu/2 < 0$，违反了非负性条件，因此不具有单调性。添加耗散项可以恢复单调性，只要耗散足够强，即 $\\theta \\ge 1$。\n\n关于耗散项是“半正定”的说法：可以证明，在离散 $\\ell^2$ 内积中，算子 $D^+D^-$ 是半负定的，因为 $\\langle u, D^+D^- u \\rangle = -\\langle D^-u, D^-u \\rangle = -\\|D^-u\\|_2^2 \\le 0$。因此，对于 $\\varepsilon > 0$，项 $\\varepsilon D^+ D^-$ 是一个半负定算子。对于形如 $du/dt=L(u)$ 的演化方程，这是一个项具有耗散性的正确属性，因为它会衰减解。我们按照添加一个物理耗散项来解释问题的意图并继续。\n\n第二个任务是确定 SSPRK($3,3$) 方法的最大允许时间步长。一个显式 SSP Runge-Kutta 方法的设计旨在，当它应用于一个半离散化方程 $du/dt = L(u)$ 时，如果前向欧拉法 $u \\to u + \\lambda L(u)$ 对于 $0 \\le \\lambda \\le (\\Delta t_{FE})_{\\max}$ 是单调的，那么 SSP-RK 方法对于时间步长 $\\Delta t \\le C \\cdot (\\Delta t_{FE})_{\\max}$ 也是单调的，其中 $C$ 是 SSP 系数。问题陈述 SSP-RK 方法是前向欧拉步的凸组合。\n\n经典的 SSPRK($3,3$) 方法由以下三个阶段给出：\n$$\nu^{(1)} = u^n + \\Delta t L(u^n)\n$$\n$$\nu^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} u^{(1)} + \\frac{1}{4} \\Delta t L(u^{(1)})\n$$\n$$\nu^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} u^{(2)} + \\frac{2}{3} \\Delta t L(u^{(2)})\n$$\n我们可以使用前向欧拉算子 $FE_{\\lambda}(v) = v + \\lambda L(v)$ 来重写每个阶段：\n$$\nu^{(1)} = FE_{\\Delta t}(u^n)\n$$\n$$\nu^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} FE_{\\Delta t}(u^{(1)})\n$$\n$$\nu^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} FE_{\\Delta t}(u^{(2)})\n$$\n根据我们对前向欧拉法的分析，如果与步长 $\\lambda$ 相关的 CFL 数（即 $a\\lambda/\\Delta x$）小于或等于 $1/\\theta$，则算子 $FE_\\lambda$ 是单调的。这定义了最大的单调前向欧拉步长：\n$$\n\\frac{a (\\Delta t_{FE})_{\\max}}{\\Delta x} \\le \\frac{1}{\\theta} \\implies (\\Delta t_{FE})_{\\max} = \\frac{\\Delta x}{a\\theta}\n$$\n如果每个阶段都是由单调操作的凸组合构成的，那么 SSP-RK 方法就是单调的。对于第一阶段 $u^{(1)} = FE_{\\Delta t}(u^n)$，我们要求 $\\Delta t \\le (\\Delta t_{FE})_{\\max}$。对于第二阶段，$u^{(2)}$ 是 $u^n$ 和 $FE_{\\Delta t}(u^{(1)})$ 的凸组合。如果 $\\Delta t \\le (\\Delta t_{FE})_{\\max}$，那么 $u^{(1)}$ 是一个相对于 $u^n$ 遵守极值原理的中间解。那么操作 $FE_{\\Delta t}(u^{(1)})$ 也是单调的，并且由于 $u^{(2)}$ 是两个单调结果的凸组合，它也是单调的。这个逻辑可以推广到最后阶段 $u^{n+1}$。每个阶段所要求的条件是，所使用的前向欧拉步本身是单调的，这意味着 $\\Delta t \\le (\\Delta t_{FE})_{\\max}$。\n\n因此，SSPRK($3,3$) 方法在与前向欧拉法相同的时间步长限制下保持单调性。这意味着对于这个特定方法，其 SSP 系数为 $C=1$。\nSSPRK($3,3$) 方法的最大允许时间步长是：\n$$\n\\Delta t_{\\max} = C \\cdot (\\Delta t_{FE})_{\\max} = 1 \\cdot \\frac{\\Delta x}{a\\theta}\n$$\n这个结果在 $\\theta \\ge 1$ 的条件下有效。如果 $\\theta < 1$，则对于任何 $\\Delta t > 0$，前向欧拉步都不是单调的，因此 $\\Delta t_{\\max}=0$。所提出的问题隐含地假设我们处于可能存在非零时间步长的区域。因此，最终答案应针对 $\\theta \\ge 1$ 的情况给出。\n以 $a$、$\\Delta x$ 和 $\\theta$ 表示的最大时间步长的最终表达式是 $\\frac{\\Delta x}{a\\theta}$。如果 $\\Delta x$ 的单位是米，$a$ 的单位是米/秒，那么其单位是秒，因为 $\\theta$ 是无量纲的。", "answer": "$$\\boxed{\\frac{\\Delta x}{a\\theta}}$$", "id": "3493000"}, {"introduction": "对于引力波天文学中的轨道演化等长期模拟，数值稳定性仅仅是最低要求，长期精度，特别是相位精度，才是成功的关键。本练习使用一个简化的轨道动力学模型，让你对比标准龙格-库塔方法与保持系统内在几何结构的辛积分器（symplectic integrator）的表现。你将通过编程实践，直观地认识到长期积分中“长期误差”（secular error）的累积效应，并理解它为何对引力波信号的相位保真度至关重要 [@problem_id:3493030]。", "problem": "设计并实现一个完整且可运行的程序，用于量化一个哈密顿测地线玩具模型中由龙格-库塔 (RK) 时间积分引起的累积轨道相位误差，并将其与一个时间对称辛积分器进行比较，旨在评估与数值相对论中引力波 (GW) 建模相关的长期相位保真度。这些积分器必须从线方法 (MoL) 的角度应用，其中时间上连续的演化由 RK 格式执行。该比较必须基于第一性原理，并且必须在指定的测试套件上产生数值可验证的输出。\n\n从以下基本基础开始。考虑一个有界赤道轨道的牛顿检验质量测地线玩具模型（作为固定背景下圆形测地线的代理），其哈密顿量为\n$$\nH(r,p_r;\\phi,L) \\;=\\; \\frac{p_r^2}{2} \\;+\\; \\frac{L^2}{2\\,r^2} \\;-\\; \\frac{\\mu}{r},\n$$\n其中 $r$ 是径向坐标，$p_r$ 是径向正则动量，$\\phi$ 是轨道相位，$L$ 是守恒角动量，$\\mu$ 是引力参数。正则哈密顿方程为\n$$\n\\frac{dr}{dt} \\;=\\; \\frac{\\partial H}{\\partial p_r} \\;=\\; p_r,\\qquad\n\\frac{dp_r}{dt} \\;=\\; -\\,\\frac{\\partial H}{\\partial r} \\;=\\; \\frac{L^2}{r^3} \\;-\\; \\frac{\\mu}{r^2},\\qquad\n\\frac{d\\phi}{dt} \\;=\\; \\frac{\\partial H}{\\partial L} \\;=\\; \\frac{L}{r^2},\\qquad\n\\frac{dL}{dt} \\;=\\; 0.\n$$\n对于半径为 $r_0$ 的圆形轨道，精确的圆频率为\n$$\n\\omega \\;=\\; \\sqrt{\\frac{\\mu}{r_0^3}},\n$$\n在时间 $T$ 后的精确相位为\n$$\n\\phi_{\\mathrm{exact}}(T) \\;=\\; \\omega\\,T,\n$$\n因此，在整数个周期 $N$ 之后，精确相位为 $\\phi_{\\mathrm{exact}}(T)=2\\pi N$，其中 $T = \\frac{2\\pi N}{\\omega}$。\n\n任务要求：\n\n- 为上述常微分方程 (ODE) 系统实现两种时间积分器：\n  1. 一种带误差控制的嵌入式龙格-库塔方法，具有局部误差控制（使用一个经典的二阶嵌入对，有时称为 Heun–Euler，其中 1 阶欧拉法嵌入在 2 阶梯形 RK 方法中）。这通过使用 RK 积分器对半离散系统进行时间积分，实现了线方法 (MoL) 的视角。该积分器必须基于一个标量误差范数，使用相对容差 $rtol$ 来自适应调整其步长。为确保评估覆盖长期累积，对步长设置一个硬上限 $h_{\\max}$，以使接受的步数至少达到一个预设的目标值。必须实现局部误差的接受/拒绝逻辑。\n  2. 在简化的 $(r,p_r)$ 子系统上使用一个二阶时间对称辛格式，其有效势为 $V_{\\mathrm{eff}}(r)=\\frac{L^2}{2r^2}-\\frac{\\mu}{r}$，即 Störmer–Verlet (也称为 Velocity–Verlet) 方法：\n     - 半步踢：$p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$，\n     - 漂移：$r \\leftarrow r + p_r\\,h$，\n     - 半步踢：$p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$。\n    相位 $\\phi$ 必须在漂移过程中使用步长为 $h$ 的二阶精度求积法进行一致地推进，例如，采用辛普森型更新\n    $$\n    \\Delta\\phi \\;\\approx\\; \\frac{h\\,L}{6}\\left(\\frac{1}{r_{\\mathrm{before}}^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{\\mathrm{after}}^2}\\right),\n    $$\n    其中 $r_{\\mathrm{before}}$ 和 $r_{\\mathrm{after}}$ 分别是漂移前后的半径，$r_{\\mathrm{mid}}$ 是漂移的中点半径。\n\n- 使用无量纲单位，除非另有说明，$\\mu=1$。所有角度必须以弧度为单位。以弧度报告相位误差。不使用其他物理单位。\n\n- 初始数据必须设置为 $t=0$ 时的精确圆形轨道条件：$r(0)=r_0$，$p_r(0)=0$，$L=\\sqrt{\\mu r_0}$，以及 $\\phi(0)=0$。\n\n- 对于每个测试，积分到 $T=\\frac{2\\pi N}{\\omega}$，其中 $\\omega=\\sqrt{\\mu/r_0^3}$，并计算绝对相位误差\n  $$\n  \\Delta\\phi \\;=\\; \\min_{k\\in\\mathbb{Z}} \\left| \\phi_{\\mathrm{num}}(T) \\;-\\; \\phi_{\\mathrm{exact}}(T) \\;-\\; 2\\pi k \\right| \\;\\in\\; [0,\\pi],\n  $$\n  即，模 $2\\pi$ 的最小绝对差。将误差与一个受引力波启发的累积相位预算目标 $\\Delta\\phi_{\\max}$ 进行比较，其中必须使用 $\\Delta\\phi_{\\max}=0.1$。\n\n- 带误差控制的 RK 方法必须使用相对容差 $rtol$ 和时间步长的硬上限 $h_{\\max}$。辛方法必须使用固定步数 $n_{\\mathrm{symp}}$，步长为 $h=T/n_{\\mathrm{symp}}$。\n\n测试套件：\n\n为以下参数集提供结果，作为三个测试用例，每个用例以元组 $\\left(r_0,\\mu,N,rtol,\\mathrm{target\\_steps}_{\\mathrm{RK}},n_{\\mathrm{symp}}\\right)$ 形式给出：\n\n- 用例 A (理想路径): $(10.0,\\,1.0,\\,200,\\,10^{-8},\\,300000,\\,262144)$,\n- 用例 B (更紧凑的轨道，不同的容差): $(1.0,\\,1.0,\\,500,\\,10^{-6},\\,200000,\\,131072)$,\n- 用例 C (长期累积，超过 $10^6$ 步): $(7.0,\\,1.0,\\,4000,\\,10^{-7},\\,1024000,\\,1048576)$。\n\n对于每个用例中的带误差控制的 RK 方法，将硬上限设置为 $h_{\\max}=T/\\mathrm{target\\_steps}_{\\mathrm{RK}}$。对于辛方法，设置 $h=T/n_{\\mathrm{symp}}$。在所有用例中，计算两种积分器在 $t=T$ 时的绝对相位误差 $\\Delta\\phi$，并确定每个误差是否满足引力波相位预算 $\\Delta\\phi \\le \\Delta\\phi_{\\max}$。\n\n最终输出规范：\n\n- 您的程序必须生成单行输出，其中包含一个列表，按以下顺序汇总所有三个测试用例的结果：\n  $[\\Delta\\phi_{\\mathrm{RK}}^{(A)},\\Delta\\phi_{\\mathrm{SV}}^{(A)},\\mathrm{ok}_{\\mathrm{RK}}^{(A)},\\mathrm{ok}_{\\mathrm{SV}}^{(A)},\\Delta\\phi_{\\mathrm{RK}}^{(B)},\\Delta\\phi_{\\mathrm{SV}}^{(B)},\\mathrm{ok}_{\\mathrm{RK}}^{(B)},\\mathrm{ok}_{\\mathrm{SV}}^{(B)},\\Delta\\phi_{\\mathrm{RK}}^{(C)},\\Delta\\phi_{\\mathrm{SV}}^{(C)},\\mathrm{ok}_{\\mathrm{RK}}^{(C)},\\mathrm{ok}_{\\mathrm{SV}}^{(C)}]$。\n- 每个 $\\Delta\\phi$ 必须是浮点数（单位为弧度），每个 $\\mathrm{ok}$ 必须是布尔值，指示相应方法是否满足相位预算 $\\Delta\\phi_{\\max}=0.1$。\n- 不得打印任何其他文本。\n\n您的实现必须完全自包含，不使用外部输入，并且在科学上是合理的，在数值上与所述方程一致。该程序必须能在任何现代 Python 环境中运行，只要它遵守指定的约束。", "solution": "问题的核心是实现并比较两种用于描述检验质量轨道的哈密顿系统的数值积分器。待解的常微分方程 (ODE) 系统由状态向量 $\\mathbf{y} = [r, p_r, \\phi]^T$ 给出：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y}) =\n\\begin{pmatrix}\np_r \\\\\nL^2/r^3 - \\mu/r^2 \\\\\nL/r^2\n\\end{pmatrix}\n$$\n参数 $L$ 和 $\\mu$ 在整个积分过程中保持不变。对于每个测试用例，我们首先计算导出的常数：角动量 $L = \\sqrt{\\mu r_0}$，轨道频率 $\\omega = \\sqrt{\\mu/r_0^3}$，以及总积分时间 $T = 2\\pi N / \\omega$。\n\n**积分器 1：自适应嵌入式龙格-库塔 RK2(1)**\n该方法使用两个对新时刻解的估计（一个 $p=2$ 阶，另一个 $p-1=1$ 阶）将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$。我们使用 Heun-Euler 对。\n令 $\\mathbf{y}_n$ 为时间 $t_n$ 时的状态。步骤如下：\n1. 计算一阶 (欧拉) 阶段：\n$$ \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n2. 计算第二阶段：\n$$ \\mathbf{k}_2 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_1) $$\n3. 高阶 (2 阶, Heun 方法) 解是：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2) $$\n4. 低阶 (1 阶, 欧拉方法) 解是：\n$$ \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_1 $$\n5. 局部误差估计是这两者之差：\n$$ \\mathbf{E} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1} = \\frac{h}{2}(\\mathbf{k}_2 - \\mathbf{k}_1) $$\n6. 步长控制：如果误差的标量范数在指定容差范围内，则接受该步。我们对动力学变量 $(r,p_r)$ 使用相对误差准则，因为它们的精度决定了轨道的路径。令 $\\mathbf{E}_{dyn} = (E_r, E_{p_r})$。通过要求 $\\Vert\\mathbf{E}_{dyn}\\Vert_2 \\le rtol \\cdot \\Vert(r_n, p_{r,n})\\Vert_2$ 来控制误差。\n如果接受该步，新的步长 $h_{\\text{new}}$ 计算如下：\n$$ h_{\\text{new}} = S \\cdot h_{\\text{old}} \\left( \\frac{rtol \\cdot \\Vert(r_n, p_{r,n})\\Vert_2}{\\Vert\\mathbf{E}_{dyn}\\Vert_2} \\right)^{1/2} $$\n其中 $S=0.9$ 是一个安全系数。如果拒绝，则用这个较小的 $h_{\\text{new}}$ 重新进行该步。步长始终被限制在 $h_{\\max}$ 以内。\n\n**积分器 2：辛 Störmer-Verlet 方法**\n该方法应用于可分离哈密顿量 $H = T(p_r) + V_{\\mathrm{eff}}(r)$。它使用固定步长 $h = T / n_{\\mathrm{symp}}$。力为 $F(r) = - \\frac{dV_{\\mathrm{eff}}}{dr} = \\frac{L^2}{r^3} - \\frac{\\mu}{r^2}$。从状态 $(r_n, p_{r,n})$ 到 $(r_{n+1}, p_{r,n+1})$ 的更新是一个“踢-漂移-踢”序列：\n1. 第一次动量半步踢：\n$$ p_{r, n+1/2} = p_{r,n} + F(r_n) \\frac{h}{2} $$\n2. 使用半步动量进行位置全步漂移：\n$$ r_{n+1} = r_n + p_{r, n+1/2} h $$\n3. 第二次动量半步踢：\n$$ p_{r, n+1} = p_{r, n+1/2} + F(r_{n+1}) \\frac{h}{2} $$\n相位 $\\phi$ 使用对 $\\int_{t_n}^{t_{n+1}} \\frac{L}{r(t)^2} dt$ 的二阶精度辛普森法则求积法同时积分。这需要步长开始、中间和结束时的半径。我们有 $r_{\\mathrm{before}} = r_n$ 和 $r_{\\mathrm{after}} = r_{n+1}$。通过半步漂移可以获得中点半径的一致二阶估计：\n$$ r_{\\mathrm{mid}} = r_n + p_{r, n+1/2} \\frac{h}{2} $$\n相位更新则为：\n$$ \\phi_{n+1} = \\phi_n + \\frac{hL}{6} \\left( \\frac{1}{r_n^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{n+1}^2} \\right) $$\n该格式保留了 $(r, p_r)$ 子系统的辛结构，已知对于适当选择的步长，它能提供出色的长期能量守恒。\n\n**最终相位误差计算**\n对于两种方法，在积分到时间 $T$ 后，我们得到一个数值相位 $\\phi_{\\mathrm{num}}(T)$。精确相位是 $\\phi_{\\mathrm{exact}}(T) = \\omega T = 2\\pi N$。相位误差是圆上的最小差异，计算为 $\\Delta\\phi = |\\text{mod}(\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{exact}} + \\pi, 2\\pi) - \\pi|$。这将原始差值映射到 $[-\\pi, \\pi]$ 区间，然后取绝对值，确保结果在 $[0, \\pi]$ 内，符合要求。然后将此值与 $\\Delta\\phi_{\\max}=0.1$ 进行比较，以确定是否满足相位保真度预算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the test suite and prints the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (r0, mu, N, rtol, target_steps_RK, n_symp)\n    test_cases = [\n        (10.0, 1.0, 200, 1e-8, 300000, 262144),      # Case A\n        (1.0, 1.0, 500, 1e-6, 200000, 131072),       # Case B\n        (7.0, 1.0, 4000, 1e-7, 1024000, 1048576),    # Case C\n    ]\n\n    # Maximum allowed phase error for Gravitational Wave budget\n    delta_phi_max = 0.1\n    \n    results = []\n\n    for case in test_cases:\n        r0, mu, N, rtol, target_steps_rk, n_symp = case\n\n        # --- Calculate orbit constants ---\n        L = math.sqrt(mu * r0)\n        omega = math.sqrt(mu / r0**3)\n        T_final = (2.0 * math.pi * N) / omega\n        \n        # --- Initial Conditions ---\n        y0 = np.array([r0, 0.0, 0.0])  # [r, p_r, phi]\n\n        # --- Run RK Integrator ---\n        h_max_rk = T_final / target_steps_rk\n        phi_rk = integrate_rk_adaptive(y0, T_final, L, mu, rtol, h_max_rk)\n        \n        # --- Run Symplectic Integrator ---\n        phi_sv = integrate_symplectic(y0, T_final, n_symp, L, mu)\n\n        # --- Calculate Phase Errors ---\n        phi_exact = omega * T_final\n        \n        # Calculate phase error for RK, wrapped to [0, pi]\n        err_rk_raw = phi_rk - phi_exact\n        delta_phi_rk = abs( (err_rk_raw + math.pi) % (2.0 * math.pi) - math.pi )\n        \n        # Calculate phase error for Symplectic, wrapped to [0, pi]\n        err_sv_raw = phi_sv - phi_exact\n        delta_phi_sv = abs( (err_sv_raw + math.pi) % (2.0 * math.pi) - math.pi )\n\n        # --- Check against budget ---\n        ok_rk = delta_phi_rk = delta_phi_max\n        ok_sv = delta_phi_sv = delta_phi_max\n        \n        results.extend([delta_phi_rk, delta_phi_sv, ok_rk, ok_sv])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef get_rhs(y, L, mu):\n    \"\"\"Computes the right-hand side of the ODE system.\"\"\"\n    r, p_r, _ = y\n    dr_dt = p_r\n    dp_r_dt = (L**2 / r**3) - (mu / r**2)\n    dphi_dt = L / r**2\n    return np.array([dr_dt, dp_r_dt, dphi_dt])\n\n\ndef integrate_rk_adaptive(y0, T_final, L, mu, rtol, h_max):\n    \"\"\"\n    Integrates the ODE system using an adaptive RK2(1) embedded method (Heun-Euler).\n    \"\"\"\n    y = np.copy(y0)\n    t = 0.0\n    h = h_max  # Initial step size guess\n    safety_factor = 0.9\n    \n    while t  T_final:\n        if t + h > T_final:\n            h = T_final - t\n\n        while True:\n            # Embedded RK2(1) / Heun-Euler method\n            k1 = get_rhs(y, L, mu)\n            \n            # Use k1 to step forward to get y at t+h for k2\n            y_temp = y + h * k1\n            # Prevent r from becoming non-positive in a bad step\n            if y_temp[0] = 0:\n                h *= 0.5\n                continue\n\n            k2 = get_rhs(y_temp, L, mu)\n            \n            # Higher-order (2nd) estimate\n            y_next = y + 0.5 * h * (k1 + k2)\n            \n            # Lower-order (1st) estimate is simply the Euler step\n            # Note: y_temp is the Euler step proposal\n            \n            # Estimate local error as the difference between the two\n            # We only control error on the dynamical variables r and p_r\n            error_est_vec = y_next - y_temp\n            error_norm = np.linalg.norm(error_est_vec[:2])\n\n            # Desired error based on relative tolerance\n            # Add a small absolute tolerance to prevent division by zero for p_r=0\n            scale = rtol * np.linalg.norm(y[:2]) + 1e-12 \n            \n            if error_norm  scale:\n                # Step is accepted\n                t += h\n                y = y_next\n                # Update next step size\n                if error_norm > 0:\n                    h_new = h * safety_factor * (scale / error_norm)**0.5\n                else: # Error is zero, can afford to increase step size\n                    h_new = h * 2.0\n                h = min(h_new, h_max)\n                break\n            else:\n                # Step is rejected, reduce step size and retry\n                h_new = h * safety_factor * (scale / error_norm)**0.5\n                h = max(h_new, 1e-9) # Prevent h from becoming too small\n                if t + h > T_final:\n                    h = T_final-t\n                    if h = 0: # If we are too close to end, finish\n                        return y[2]\n\n\n    return y[2]\n\n\ndef get_force(r, L, mu):\n    \"\"\"Computes the radial force F(r) = -dV_eff/dr.\"\"\"\n    return (L**2 / r**3) - (mu / r**2)\n    \n\ndef integrate_symplectic(y0, T_final, n_steps, L, mu):\n    \"\"\"\n    Integrates the ODE system using a 2nd order Störmer-Verlet method\n    with a Simpson-rule quadrature for the phase.\n    \"\"\"\n    r, p_r, phi = y0\n    h = T_final / n_steps\n\n    for _ in range(n_steps):\n        r_before = r\n        \n        # First half-kick for momentum\n        p_mid = p_r + 0.5 * h * get_force(r, L, mu)\n        \n        # Calculate midpoint radius for phase integration\n        r_mid = r + 0.5 * h * p_mid\n\n        # Full drift for position\n        r_after = r + h * p_mid\n        \n        # Second half-kick for momentum\n        p_r = p_mid + 0.5 * h * get_force(r_after, L, mu)\n        r = r_after\n        \n        # Update phase using Simpson's rule\n        delta_phi = (h * L / 6.0) * (1.0 / r_before**2 + 4.0 / r_mid**2 + 1.0 / r_after**2)\n        phi += delta_phi\n\n    return phi\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3493030"}]}