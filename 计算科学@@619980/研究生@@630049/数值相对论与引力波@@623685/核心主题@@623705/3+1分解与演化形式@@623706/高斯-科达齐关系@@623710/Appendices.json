{"hands_on_practices": [{"introduction": "本练习提供了应用 $3+1$ 分解基本定义的必要实践。通过一个非平凡的例子——平直闵可夫斯基空间的双曲面切片——你将显式计算所有关键的几何量，并验证动量约束得到满足 [@problem_id:3491166]。这将加深你对切片本身如何能引起非零外曲率的理解，这项基础技能对于解释更复杂动态时空的几何至关重要。", "problem": "考虑球坐标 $(t,r,\\theta,\\phi)$ 下的四维闵可夫斯基时空，其线元为 $ds^{2} = - dt^{2} + dr^{2} + r^{2} d\\theta^{2} + r^{2} \\sin^{2}\\theta \\, d\\phi^{2}$。通过时间函数 $\\tau = t - \\sqrt{r^{2} + \\ell^{2}}$ 定义一个双曲面切片，其中 $\\ell > 0$ 是一个具有长度量纲的常数。在适用于由 $\\tau = \\text{constant}$ 切片构成的叶状结构的 3+1 分解下进行计算。\n\n从基本定义出发，按以下步骤进行：\n- 计算 $\\tau = \\text{constant}$ 切片的单位法向量 $n_{\\mu}$，并确定在坐标基 $(r,\\theta,\\phi)$ 下的垂直函数 $\\alpha$、移位向量 $\\beta^{i}$ 以及切片上的诱导空间度规 $h_{ij}$。\n- 使用定义 $K_{ij} = - h_{i}{}^{\\mu} h_{j}{}^{\\nu} \\nabla_{\\mu} n_{\\nu}$，计算切片上的外在曲率 $K_{ij}$ 及其迹 $K = h^{ij} K_{ij}$。\n- 设 $D_{j}$ 表示与 $h_{ij}$ 相容的空间协变导数，在坐标基 $(r,\\theta,\\phi)$ 下显式地计算动量约束 $D_{j} \\!\\left( K^{ij} - h^{ij} K \\right)$。\n\n将你的最终答案表示为 $D_{j} \\!\\left( K^{ij} - h^{ij} K \\right)$ 的三个分量，按 $(r,\\theta,\\phi)$ 的顺序，并使用 $\\pmatrix$ 环境格式化为单个行矩阵。最终表达式中不需四舍五入，也不应出现单位。", "solution": "该问题要求我们验证闵可夫斯基时空特定双曲面切片的动量约束。这是广义相对论 3+1 (ADM) 形式体系中的一个标准练习。该时空是爱因斯坦场方程的一个真空解，因此动量约束必须恒等满足。任务是通过显式计算来证明这一点。\n\n球坐标 $(t,r,\\theta,\\phi)$ 下的四维时空度规由下式给出\n$$ds^2 = g_{\\mu\\nu} dx^\\mu dx^\\nu = -dt^2 + dr^2 + r^2 d\\theta^2 + r^2 \\sin^2\\theta d\\phi^2$$\n度规张量为 $g_{\\mu\\nu} = \\text{diag}(-1, 1, r^2, r^2\\sin^2\\theta)$。其逆为 $g^{\\mu\\nu} = \\text{diag}(-1, 1, r^{-2}, (r\\sin\\theta)^{-2})$。\n\n叶状结构由时间函数 $\\tau = t - \\sqrt{r^2 + \\ell^2}$ 的等值面定义。为简洁起见，令 $S(r) = \\sqrt{r^2+\\ell^2}$。因此 $\\tau = t - S(r)$。\n\n**第一部分：计算 $n_{\\mu}$、$\\alpha$、$\\beta^{i}$ 和 $h_{ij}$**\n\n与 $\\tau = \\text{constant}$ 切片垂直的法余向量与梯度 $\\partial_\\mu \\tau$ 成正比。\n$$\\partial_\\mu \\tau = (\\partial_t \\tau, \\partial_r \\tau, \\partial_\\theta \\tau, \\partial_\\phi \\tau) = (1, -\\frac{r}{S(r)}, 0, 0)$$\n该法余向量的范数平方为 $g^{\\mu\\nu}(\\partial_\\mu \\tau)(\\partial_\\nu \\tau) = (-1)(1)^2 + (1)(-\\frac{r}{S})^2 = -1 + \\frac{r^2}{r^2+\\ell^2} = -\\frac{\\ell^2}{r^2+\\ell^2}$。\n单位法余向量 $n_\\mu$ 必须满足 $n_\\mu n^\\mu = -1$。我们选择未来指向的法向量。标准约定得出：\n$$n_\\mu = -\\frac{\\partial_\\mu \\tau}{\\sqrt{-g^{\\alpha\\beta}\\partial_\\alpha\\tau \\partial_\\beta\\tau}} = -\\frac{(1, -r/S, 0, 0)}{\\ell/S} = \\left(-\\frac{S}{\\ell}, \\frac{r}{\\ell}, 0, 0\\right)$$\n相应的逆变单位法向量为 $n^\\mu = g^{\\mu\\nu}n_\\nu$：\n$$n^\\mu = \\left(\\frac{S}{\\ell}, \\frac{r}{\\ell}, 0, 0\\right)$$\n\n垂直函数 $\\alpha$ 和移位向量 $\\beta^\\mu$ 由时间演化矢量场 $t^\\mu = (\\partial/\\partial t)^\\mu = (1, 0, 0, 0)^\\mu$ 分解为 $t^\\mu = \\alpha n^\\mu + \\beta^\\mu$ 来定义，其中 $\\beta^\\mu$ 与切片相切（$n_\\mu \\beta^\\mu=0$）。\n垂直函数为 $\\alpha = -n_\\mu t^\\mu = -n_t = S/\\ell = \\frac{\\sqrt{r^2+\\ell^2}}{\\ell}$。\n移位向量（四维分量）为 $\\beta^\\mu = t^\\mu - \\alpha n^\\mu$：\n$$\\beta^\\mu = (1, 0, 0, 0)^\\mu - \\frac{S}{\\ell} \\left(\\frac{S}{\\ell}, \\frac{r}{\\ell}, 0, 0\\right)^\\mu = \\left(1-\\frac{S^2}{\\ell^2}, -\\frac{rS}{\\ell^2}, 0, 0\\right)^\\mu = \\left(-\\frac{r^2}{\\ell^2}, -\\frac{r\\sqrt{r^2+\\ell^2}}{\\ell^2}, 0, 0\\right)^\\mu$$\n空间坐标基 $(r,\\theta,\\phi)$ 中的移位向量分量 $\\beta^i$ 必须从 $\\beta^\\mu$ 投影得到。切片的切向量为 $X^\\mu_{,i} = \\partial X^\\mu/\\partial x^i$。该切片是一个曲面 $t(r) = \\tau_0 + S(r)$，因此 $X^\\mu = (S(r), r, \\theta, \\phi)$。\n$X^\\mu_{,r} = (S'(r), 1, 0, 0) = (r/S, 1, 0, 0)$，$X^\\mu_{,\\theta}=(0,0,1,0)$，$X^\\mu_{,\\phi}=(0,0,0,1)$。\n空间向量 $\\beta^i$ 由 $\\beta^\\mu = \\beta^i X^\\mu_{,i}$ 定义。\n从 $\\beta^\\mu$ 的 $\\theta$ 和 $\\phi$ 分量，我们看到 $\\beta^\\theta = 0$ 和 $\\beta^\\phi=0$。\n从 $r$ 分量：$\\beta^r = -\\frac{r\\sqrt{r^2+\\ell^2}}{\\ell^2}$。我们用 $t$ 分量验证这一点：$\\beta^t = \\beta^r (r/S) = (-\\frac{rS}{\\ell^2})(\\frac{r}{S}) = -\\frac{r^2}{\\ell^2}$。这与之前结果一致。所以，$\\beta^i = (-\\frac{r\\sqrt{r^2+\\ell^2}}{\\ell^2}, 0, 0)$。\n\n切片上的诱导空间度规 $h_{ij}$ 由 $h_{ij} = g_{\\mu\\nu} X^{\\mu}_{,i} X^{\\nu}_{,j}$ 给出。\n$$h_{rr} = g_{\\mu\\nu} X^\\mu_{,r} X^\\nu_{,r} = g_{tt}(r/S)^2 + g_{rr}(1)^2 = -1 \\cdot \\frac{r^2}{S^2} + 1 = \\frac{\\ell^2}{S^2} = \\frac{\\ell^2}{r^2+\\ell^2}$$\n$$h_{\\theta\\theta} = g_{\\mu\\nu} X^\\mu_{,\\theta} X^\\nu_{,\\theta} = g_{\\theta\\theta}(1)^2 = r^2$$\n$$h_{\\phi\\phi} = g_{\\mu\\nu} X^\\mu_{,\\phi} X^\\nu_{,\\phi} = g_{\\phi\\phi}(1)^2 = r^2\\sin^2\\theta$$\n所有非对角分量均为零。因此，$h_{ij} = \\text{diag}(\\frac{\\ell^2}{r^2+\\ell^2}, r^2, r^2\\sin^2\\theta)$。\n\n**第二部分：计算 $K_{ij}$ 和 $K$**\n\n外在曲率为 $K_{ij} = -h_i{}^\\mu h_j{}^\\nu \\nabla_\\mu n_\\nu = -X^\\mu_{,i} X^\\nu_{,j} \\nabla_\\mu n_\\nu$。我们需要闵可夫斯基时空中的协变导数 $\\nabla_\\mu n_\\nu = \\partial_\\mu n_\\nu - \\Gamma^\\lambda_{\\mu\\nu} n_\\lambda$。球坐标系中非零的克里斯托费尔符号为 $\\Gamma^r_{\\theta\\theta}=-r$，$\\Gamma^r_{\\phi\\phi}=-r\\sin^2\\theta$，$\\Gamma^\\theta_{r\\theta}=1/r$，$\\Gamma^\\theta_{\\phi\\phi}=-\\sin\\theta\\cos\\theta$，$\\Gamma^\\phi_{r\\phi}=1/r$，$\\Gamma^\\phi_{\\theta\\phi}=\\cot\\theta$。\n余向量 $n_\\mu$ 仅有 $t$ 和 $r$ 分量，$n_t = -S/\\ell$ 和 $n_r=r/\\ell$。\n$$K_{rr} = -X^\\mu_{,r} X^\\nu_{,r} \\nabla_\\mu n_\\nu = - (X^t_{,r}X^r_{,r}\\nabla_t n_r + X^r_{,r}X^t_{,r}\\nabla_r n_t + X^r_{,r}X^r_{,r}\\nabla_r n_r + \\dots)$$\n由于 $n_\\mu$ 与 $t$ 无关，$\\partial_t n_\\nu=0$ 且 $\\Gamma^\\lambda_{t\\nu}=0$，所以 $\\nabla_t n_\\nu = 0$。\n$\\nabla_r n_t = \\partial_r n_t - \\Gamma^\\lambda_{rt}n_\\lambda = \\partial_r(-S/\\ell) = -r/(\\ell S)$。\n$\\nabla_r n_r = \\partial_r n_r - \\Gamma^\\lambda_{rr}n_\\lambda = \\partial_r(r/\\ell) = 1/\\ell$。\n$$K_{rr} = - \\left( (1)\\left(\\frac{r}{S}\\right)\\left(-\\frac{r}{\\ell S}\\right) + (1)(1)\\left(\\frac{1}{\\ell}\\right) \\right) = - \\left(-\\frac{r^2}{\\ell S^2} + \\frac{1}{\\ell}\\right) = - \\frac{-r^2+S^2}{\\ell S^2} = -\\frac{\\ell^2}{\\ell S^2} = -\\frac{\\ell}{r^2+\\ell^2}$$\n对于 $K_{\\theta\\theta}$：$\\nabla_\\theta n_\\theta = \\partial_\\theta n_\\theta - \\Gamma^\\lambda_{\\theta\\theta}n_\\lambda = 0 - \\Gamma^r_{\\theta\\theta}n_r = -(-r)(r/\\ell) = r^2/\\ell$。\n$$K_{\\theta\\theta} = -X^\\theta_{,\\theta}X^\\theta_{,\\theta}\\nabla_\\theta n_\\theta = - (1)(1)(r^2/\\ell) = -r^2/\\ell$$\n对于 $K_{\\phi\\phi}$：$\\nabla_\\phi n_\\phi = \\partial_\\phi n_\\phi - \\Gamma^\\lambda_{\\phi\\phi}n_\\lambda = 0 - \\Gamma^r_{\\phi\\phi}n_r = -(-r\\sin^2\\theta)(r/\\ell) = r^2\\sin^2\\theta/\\ell$。\n$$K_{\\phi\\phi} = -X^\\phi_{,\\phi}X^\\phi_{,\\phi}\\nabla_\\phi n_\\phi = -(1)(1)(r^2\\sin^2\\theta/\\ell) = -r^2\\sin^2\\theta/\\ell$$\n非对角项为零。外在曲率张量为 $K_{ij} = \\text{diag}(-\\frac{\\ell}{r^2+\\ell^2}, -\\frac{r^2}{\\ell}, -\\frac{r^2\\sin^2\\theta}{\\ell})$。\n\n迹为 $K=h^{ij}K_{ij}$。逆空间度规为 $h^{ij} = \\text{diag}(\\frac{r^2+\\ell^2}{\\ell^2}, \\frac{1}{r^2}, \\frac{1}{r^2\\sin^2\\theta})$。\n$$K = \\left(\\frac{r^2+\\ell^2}{\\ell^2}\\right)\\left(-\\frac{\\ell}{r^2+\\ell^2}\\right) + \\left(\\frac{1}{r^2}\\right)\\left(-\\frac{r^2}{\\ell}\\right) + \\left(\\frac{1}{r^2\\sin^2\\theta}\\right)\\left(-\\frac{r^2\\sin^2\\theta}{\\ell}\\right) = -\\frac{1}{\\ell} - \\frac{1}{\\ell} - \\frac{1}{\\ell} = -\\frac{3}{\\ell}$$\n\n**第三部分：计算动量约束 $D_j(K^{ij} - h^{ij}K)$**\n\n令 $S^{ij} = K^{ij} - h^{ij}K$。我们首先计算其分量。\n$K^{ij}=h^{ik}h^{jl}K_{kl}$，对于对角度规，即为 $K^{ii}=(h^{ii})^2 K_{ii}$。\n$$K^{rr} = \\left(\\frac{r^2+\\ell^2}{\\ell^2}\\right)^2 \\left(-\\frac{\\ell}{r^2+\\ell^2}\\right) = -\\frac{(r^2+\\ell^2)}{\\ell^3}$$\n$$K^{\\theta\\theta} = \\left(\\frac{1}{r^2}\\right)^2 \\left(-\\frac{r^2}{\\ell}\\right) = -\\frac{1}{r^2\\ell}$$\n$$K^{\\phi\\phi} = \\left(\\frac{1}{r^2\\sin^2\\theta}\\right)^2 \\left(-\\frac{r^2\\sin^2\\theta}{\\ell}\\right) = -\\frac{1}{r^2\\ell\\sin^2\\theta}$$\n现在我们计算 $S^{ij}$。\n$$S^{rr} = K^{rr} - h^{rr}K = -\\frac{r^2+\\ell^2}{\\ell^3} - \\frac{r^2+\\ell^2}{\\ell^2}\\left(-\\frac{3}{\\ell}\\right) = \\frac{2(r^2+\\ell^2)}{\\ell^3}$$\n$$S^{\\theta\\theta} = K^{\\theta\\theta} - h^{\\theta\\theta}K = -\\frac{1}{r^2\\ell} - \\frac{1}{r^2}\\left(-\\frac{3}{\\ell}\\right) = \\frac{2}{r^2\\ell}$$\n$$S^{\\phi\\phi} = K^{\\phi\\phi} - h^{\\phi\\phi}K = -\\frac{1}{r^2\\ell\\sin^2\\theta} - \\frac{1}{r^2\\sin^2\\theta}\\left(-\\frac{3}{\\ell}\\right) = \\frac{2}{r^2\\ell\\sin^2\\theta}$$\n真空中的动量约束为 $D_j S^{ij} = 0$。我们来验证这一点。协变散度为 $(D_j S^{ij})^i = \\frac{1}{\\sqrt{h}}\\partial_j(\\sqrt{h}S^{ij}) + \\Gamma^i_{jk}S^{jk}$，其中 $h = \\det(h_{ij}) = \\frac{\\ell^2 r^4\\sin^2\\theta}{r^2+\\ell^2}$，所以 $\\sqrt{h} = \\frac{\\ell r^2\\sin\\theta}{\\sqrt{r^2+\\ell^2}}$。\n\n$r$-分量：$(D_j S^{ij})^r = \\frac{1}{\\sqrt{h}}\\partial_r(\\sqrt{h}S^{rr}) + \\Gamma^r_{rr}S^{rr} + \\Gamma^r_{\\theta\\theta}S^{\\theta\\theta} + \\Gamma^r_{\\phi\\phi}S^{\\phi\\phi}$。\n必须计算空间度规 $h_{ij}$ 的克里斯托费尔符号。\n$\\Gamma^r_{rr} = \\frac{1}{2}h^{rr}\\partial_r h_{rr} = -\\frac{r}{r^2+\\ell^2}$。\n$\\Gamma^r_{\\theta\\theta} = -\\frac{1}{2}h^{rr}\\partial_r h_{\\theta\\theta} = -\\frac{r(r^2+\\ell^2)}{\\ell^2}$。\n$\\Gamma^r_{\\phi\\phi} = -\\frac{1}{2}h^{rr}\\partial_r h_{\\phi\\phi} = -\\frac{r(r^2+\\ell^2)\\sin^2\\theta}{\\ell^2}$。\n$\\sqrt{h}S^{rr} = \\frac{\\ell r^2\\sin\\theta}{\\sqrt{r^2+\\ell^2}}\\frac{2(r^2+\\ell^2)}{\\ell^3} = \\frac{2r^2\\sin\\theta\\sqrt{r^2+\\ell^2}}{\\ell^2}$。\n$\\partial_r(\\sqrt{h}S^{rr}) = \\frac{2\\sin\\theta}{\\ell^2}\\frac{d}{dr}(r^2\\sqrt{r^2+\\ell^2}) = \\frac{2\\sin\\theta(3r^3+2r\\ell^2)}{\\ell^2\\sqrt{r^2+\\ell^2}}$。\n$\\frac{1}{\\sqrt{h}}\\partial_r(\\sqrt{h}S^{rr}) = \\frac{\\sqrt{r^2+\\ell^2}}{\\ell r^2\\sin\\theta} \\frac{2\\sin\\theta(3r^3+2r\\ell^2)}{\\ell^2\\sqrt{r^2+\\ell^2}} = \\frac{2(3r^2+2\\ell^2)}{r\\ell^3}$。\n将 $(D_j S^{ij})^r$ 的各项相加：\n$$\\frac{2(3r^2+2\\ell^2)}{r\\ell^3} + \\left(-\\frac{r}{r^2+\\ell^2}\\right)\\frac{2(r^2+\\ell^2)}{\\ell^3} + \\left(-\\frac{r(r^2+\\ell^2)}{\\ell^2}\\right)\\frac{2}{r^2\\ell} + \\left(-\\frac{r(r^2+\\ell^2)\\sin^2\\theta}{\\ell^2}\\right)\\frac{2}{r^2\\ell\\sin^2\\theta}$$\n$$= \\frac{6r^2+4\\ell^2}{r\\ell^3} - \\frac{2r^2}{r\\ell^3} - \\frac{2(r^2+\\ell^2)}{r\\ell^3} - \\frac{2(r^2+\\ell^2)}{r\\ell^3} = \\frac{1}{r\\ell^3}(6r^2+4\\ell^2 - 2r^2 - 2r^2-2\\ell^2 - 2r^2-2\\ell^2) = 0$$\n\n$\\theta$-分量：$(D_j S^{ij})^\\theta$。由于球对称性，我们预期该分量与关于 $\\theta$ 的导数有关。对称张量散度的一个更简洁的表达式很有用：$(D_j S^{ij})^\\theta = \\partial_j S^{\\theta j} + \\Gamma^\\theta_{jk}S^{jk} + \\Gamma^j_{j k} S^{\\theta k}$。\n由于 $S^{ij}$ 是对角的，这简化为 $\\partial_\\theta S^{\\theta\\theta} + \\Gamma^\\theta_{\\phi\\phi}S^{\\phi\\phi} + \\Gamma^j_{j\\theta}S^{\\theta\\theta}$。\n$S^{\\theta\\theta}$ 与 $\\theta$ 无关，因此 $\\partial_\\theta S^{\\theta\\theta}=0$。\n$\\Gamma^\\theta_{\\phi\\phi} = -\\frac{1}{2}h^{\\theta\\theta}\\partial_\\theta h_{\\phi\\phi} = -\\sin\\theta\\cos\\theta$。\n$\\Gamma^j_{j\\theta} = \\partial_\\theta(\\ln\\sqrt{h}) = \\cot\\theta$。\n所以，$(D_j S^{ij})^\\theta = 0 + (-\\sin\\theta\\cos\\theta)\\frac{2}{r^2\\ell\\sin^2\\theta} + (\\cot\\theta)\\frac{2}{r^2\\ell} = -\\frac{2\\cot\\theta}{r^2\\ell} + \\frac{2\\cot\\theta}{r^2\\ell} = 0$。\n\n$\\phi$-分量：$(D_j S^{ij})^\\phi$。由于轴对称性，所有量都与 $\\phi$ 无关。因此所有对 $\\phi$ 的偏导数都为零。详细计算表明，散度表达式中的所有项要么相互抵消，要么各自为零，导致 $(D_j S^{ij})^\\phi=0$。\n\n动量约束 $D_{j} \\!\\left( K^{ij} - h^{ij} K \\right)$ 的计算结果为一个零向量。在 $(r,\\theta,\\phi)$ 基下的三个分量是 $(0, 0, 0)$。", "answer": "$$\\boxed{\\begin{pmatrix} 0  0  0 \\end{pmatrix}}$$", "id": "3491166"}, {"introduction": "从解析计算到计算验证是现代物理学中的关键一步。这个实践将引导你对史瓦西时空中的一个静态切片，数值地检验高斯方程 [@problem_id:3491214]。通过实现数值微分来计算三维和四维黎曼张量，你将对抽象的几何关系如何在计算环境中被实现和验证获得实践性的洞察。", "problem": "要求您在一个已知的解析时空中，对一个 $t$ 为常数的超曲面，在 $3+1$ 分解下实现 Gauss 方程的数值一致性检验。请使用标准 Schwarzschild 坐标 $\\left(t,r,\\theta,\\phi\\right)$ 下的 Schwarzschild 时空，并采用几何单位制，其中引力常数和光速均设为 $G=c=1$。考虑 $t=\\mathrm{const}$ 的超曲面，其漂移矢量为零，并采用自然的法向 1-形式。在这种静态切片下，外在曲率恒为零，因此 Gauss 方程简化为超曲面上的内蕴三维 Riemann 张量与时空 Riemann 张量的完全空间投影相等。\n\n请仅从以下基本基础和核心定义出发：\n- 在标准坐标下，质量参数为 $M$ 的 Schwarzschild 线元，其度规张量 $g_{\\mu\\nu}$ 是对角的，分量为 $g_{tt}=-\\left(1-\\dfrac{2M}{r}\\right)$, $g_{rr}=\\left(1-\\dfrac{2M}{r}\\right)^{-1}$, $g_{\\theta\\theta}=r^{2}$, $g_{\\phi\\phi}=r^{2}\\sin^{2}\\theta$。\n- 在 $t=\\mathrm{const}$ 切片上的诱导三维内蕴度规 $\\gamma_{ij}$ 由 $g_{\\mu\\nu}$ 的空间部分给出，即 $\\gamma_{rr}=\\left(1-\\dfrac{2M}{r}\\right)^{-1}$, $\\gamma_{\\theta\\theta}=r^{2}$, $\\gamma_{\\phi\\phi}=r^{2}\\sin^{2}\\theta$。\n- 对于度规 $g_{\\mu\\nu}$，Levi-Civita 联络的 Christoffel 符号定义为 $\\Gamma^{\\alpha}_{\\ \\beta\\gamma}=\\dfrac{1}{2}g^{\\alpha\\delta}\\left(\\partial_{\\beta}g_{\\gamma\\delta}+\\partial_{\\gamma}g_{\\beta\\delta}-\\partial_{\\delta}g_{\\beta\\gamma}\\right)$，对于三维内蕴度规 $\\gamma_{ij}$ 也类似。\n- Riemann 曲率张量定义为 $R^{\\alpha}_{\\ \\beta\\gamma\\delta}=\\partial_{\\gamma}\\Gamma^{\\alpha}_{\\ \\beta\\delta}-\\partial_{\\delta}\\Gamma^{\\alpha}_{\\ \\beta\\gamma}+\\Gamma^{\\alpha}_{\\ \\gamma\\mu}\\Gamma^{\\mu}_{\\ \\beta\\delta}-\\Gamma^{\\alpha}_{\\ \\delta\\mu}\\Gamma^{\\mu}_{\\ \\beta\\gamma}$，在三维情况下使用拉丁字母索引，定义类似。\n\n实现以下纯粹的数学和算法任务：\n1. 对度规分量关于坐标的偏导数，实现数值中心差分估计器，沿每个坐标 $x^{a}$ 使用大小为 $h_{a}$ 的对称步长。将四维内蕴度规 $g_{\\mu\\nu}(t,r,\\theta,\\phi)$ 和三维内蕴度规 $\\gamma_{ij}(r,\\theta,\\phi)$ 视为其坐标的函数，并根据数值估计的度规导数计算它们的 Christoffel 符号。\n2. 对 Christoffel 符号使用中心差分，数值估计 Riemann 张量定义中出现的导数，并在某一点上构建完整的四维张量 $R_{\\mu\\nu\\rho\\sigma}$ 和三维张量 ${}^{(3)}\\!R_{ijkl}$。您必须使用评估点处的度规来降低索引。\n3. 通过选择所有索引都在空间集合 $\\{r,\\theta,\\phi\\}$ (即 $\\mu,\\nu,\\rho,\\sigma \\in \\{r,\\theta,\\phi\\}$) 中的分量，构建四维 Riemann 张量在 $t=\\mathrm{const}$ 超曲面切空间上的完全空间投影，形成一个索引顺序与 $(r,\\theta,\\phi)$ 对齐的数组 $R^{\\mathrm{proj}}_{ijkl}$。\n4. 因为切片是静态且时间对称的，使用 $K_{ij}=0$，因此检验 ${}^{(3)}\\!R_{ijkl}$ 和 $R^{\\mathrm{proj}}_{ijkl}$ 之间的相等性。通过无量纲的验证度量来量化其一致性程度\n$$\n\\varepsilon = \\frac{\\left\\|\\,{}^{(3)}\\!R_{ijkl}-R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}}{\\left\\|\\,{}^{(3)}\\!R_{ijkl}\\right\\|_{F}+\\left\\|R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}+\\delta},\n$$\n其中 $\\left\\|\\cdot\\right\\|_{F}$ 表示 Frobenius 范数，$\\delta$ 是一个小的正常数以避免除以零。使用 $\\delta=10^{-30}$。\n\n数值细节和约束：\n- 对四维量使用步长为 $h_{t}$、$h_{r}$、$h_{\\theta}$、$h_{\\phi}$ 的中心差分，对三维量使用步长为 $h_{r}$、$h_{\\theta}$、$h_{\\phi}$ 的中心差分。所有角度必须以弧度处理。\n- 选择远离坐标奇点的评估点。具体来说，在测试套件中避免 $r \\le 2M$ 和 $\\theta \\in \\{0, \\pi\\}$。您的程序应使用解析的 Schwarzschild 公式精确实现度规，但必须如上所述数值地估计导数。\n- 最终输出是无量纲的浮点数，因此答案不需要指定物理单位。\n\n测试套件和要求的最终输出格式：\n- 实现您的程序，为以下五个测试用例评估验证度量 $\\varepsilon$。每个测试用例是一个元组 $\\left(M,r,\\theta,\\phi,h_{t},h_{r},h_{\\theta},h_{\\phi}\\right)$，其中角度以弧度为单位：\n  1. $\\left(1.0,\\,10.0,\\,\\frac{\\pi}{3},\\,0.7,\\,10^{-6},\\,10^{-5}\\cdot 10.0,\\,10^{-6},\\,10^{-6}\\right)$\n  2. $\\left(1.0,\\,2.1,\\,1.2,\\,2.0,\\,10^{-6},\\,10^{-5}\\cdot 2.1,\\,10^{-6},\\,10^{-6}\\right)$\n  3. $\\left(1.0,\\,6.0,\\,\\frac{\\pi}{2},\\,0.1,\\,10^{-6},\\,10^{-5}\\cdot 6.0,\\,10^{-6},\\,10^{-6}\\right)$\n  4. $\\left(1.0,\\,100.0,\\,2.0,\\,3.0,\\,10^{-6},\\,10^{-5}\\cdot 100.0,\\,10^{-6},\\,10^{-6}\\right)$\n  5. $\\left(1.0,\\,8.0,\\,0.05,\\,1.0,\\,10^{-6},\\,10^{-5}\\cdot 8.0,\\,10^{-6},\\,10^{-6}\\right)$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $\\left[\\varepsilon_{1},\\varepsilon_{2},\\varepsilon_{3},\\varepsilon_{4},\\varepsilon_{5}\\right]$，其中每个 $\\varepsilon_{k}$ 是测试用例 $k$ 的验证度量。\n\n您的实现必须是自包含的，并且不能需要任何外部输入。所有角度都必须以弧度解释，并且所有计算都应使用双精度浮点运算。确保在任何中心差分模板中，数值步长不会跨越事件视界 $r=2M$。如有必要，请在内部减小步长以在所有评估点保持 $r-h_{r} > 2M$。", "solution": "该问题要求在广义相对论的 $3+1$ 分解框架内，针对一个特定场景对 Gauss-Codazzi 方程进行数值验证。我们需要考虑 Schwarzschild 时空中的一个静态、等时（$t=\\mathrm{const}$）超曲面。解决方案涉及数值计算该超曲面的内蕴和外在曲率张量，并验证它们是否满足约束方程。\n\n**1. 理论框架：Gauss-Codazzi 方程**\n\n$3+1$ 形式主义将四维时空分解为一堆三维空间超曲面。然后，时空的几何结构通过这些切片的内蕴几何以及它们如何嵌入到更大的时空中来描述。将四维曲率与三维几何联系起来的基本方程是 Gauss-Codazzi 方程。\n\nGauss 方程将空间切片的内蕴三维 Riemann 张量（表示为 ${}^{(3)}\\!R_{ijkl}$）与四维时空 Riemann 张量 $R_{\\mu\\nu\\rho\\sigma}$ 的投影以及切片的外在曲率 $K_{ij}$ 联系起来：\n$$\n{}^{(3)}R_{ikjl} = R^{\\perp}_{ikjl} + K_{ik}K_{jl} - K_{il}K_{jk}\n$$\n此处，$R^{\\perp}_{ikjl} = \\gamma^i_\\alpha \\gamma^j_\\beta \\gamma^k_\\gamma \\gamma^l_\\delta R_{ijkl}$ 表示四维 Riemann 张量在空间超曲面上的投影，其中 $\\gamma^i_\\alpha$ 是投影算子。\n\n**2. 对 Schwarzschild 静态切片的简化**\n\n问题指定了标准坐标 $(t,r,\\theta,\\phi)$ 下的 Schwarzschild 时空，并研究 $t=\\mathrm{const}$ 的超曲面。度规是对角的且与时间无关。这种切片是静态的，意味着空间切片的几何形状不随时间改变。这种切片的一个关键特性是其外在曲率为零，即 $K_{ij}=0$。外在曲率衡量了超曲面的法向量在沿曲面移动时如何变化，对于静态切片，它们不发生变化。\n\n当 $K_{ij}=0$ 时，Gauss 方程极大地简化为：\n$$\n{}^{(3)}R_{ikjl} = R^{\\perp}_{ikjl}\n$$\n此外，在所选的坐标系中，空间坐标 $(r,\\theta,\\phi)$ 与时间坐标 $t$ 正交。四维 Riemann 张量的投影仅仅相当于选择所有索引都是空间索引的分量。如果我们让拉丁索引 $i,j,k,l$ 遍历空间坐标 $\\{r,\\theta,\\phi\\}$，那么需要验证的方程就变成了由切片的内蕴度规计算出的三维 Riemann 张量与四维 Riemann 张量的纯空间分量之间的直接相等关系：\n$$\n{}^{(3)}R_{ijkl} = R_{ijkl}\n$$\n这提供了一个清晰、可验证的恒等式，可用于数值测试。\n\n**3. 计算策略**\n\n问题的核心是数值计算简化 Gauss 方程的两边并进行比较。问题提供了几何对象的基本定义，所有导数都必须使用中心有限差分进行数值计算。\n\n步骤如下：\na. **定义度规**：实现函数，用于在任意给定坐标点提供四维时空度规 $g_{\\mu\\nu}(t,r,\\theta,\\phi)$ 和三维诱导空间度规 $\\gamma_{ij}(r,\\theta,\\phi)$ 的分量。这些分量已在问题描述中给出。\n\nb. **计算 Christoffel 符号**：Christoffel 符号描述了平行输运效应，由度规的一阶导数计算得出。四维符号的定义为：\n$$\n\\Gamma^{\\alpha}_{\\ \\beta\\gamma} = \\frac{1}{2}g^{\\alpha\\delta}\\left(\\partial_{\\beta}g_{\\gamma\\delta} + \\partial_{\\gamma}g_{\\beta\\delta} - \\partial_{\\delta}g_{\\beta\\gamma}\\right)\n$$\n使用空间度规 $\\gamma_{ij}$，对于三维符号 ${}^{(3)}\\!\\Gamma^{i}_{\\ jk}$ 也存在一个类似的公式。所有偏导数 $\\partial_{\\alpha}g_{\\mu\\nu}$ 都使用中心差分公式 $f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}$ 进行数值计算。\n\nc. **计算 Riemann 曲率张量**：Riemann 张量捕捉了流形的曲率，由 Christoffel 符号及其一阶导数定义。四维张量的定义为：\n$$\nR^{\\alpha}_{\\ \\beta\\gamma\\delta} = \\partial_{\\gamma}\\Gamma^{\\alpha}_{\\ \\beta\\delta} - \\partial_{\\delta}\\Gamma^{\\alpha}_{\\ \\beta\\gamma} + \\Gamma^{\\alpha}_{\\ \\gamma\\mu}\\Gamma^{\\mu}_{\\ \\beta\\delta} - \\Gamma^{\\alpha}_{\\ \\delta\\mu}\\Gamma^{\\mu}_{\\ \\beta\\gamma}\n$$\n同样，对于 ${}^{(3)}\\!R^{i}_{\\ jkl}$ 也存在一个类似的公式。Christoffel 符号的导数，例如 $\\partial_{\\gamma}\\Gamma^{\\alpha}_{\\ \\beta\\delta}$，也使用中心差分计算。这涉及到在微小位移的点上评估 Christoffel 符号，这是一个计算密集但直接的定义实现。在计算出一个上指标的张量后，我们使用度规来降低其指标：$R_{\\alpha\\beta\\gamma\\delta} = g_{\\alpha\\mu}R^{\\mu}_{\\ \\beta\\gamma\\delta}$。\n\nd. **投影和比较**：一旦在指定的评估点计算出两个张量 ${}^{(3)}\\!R_{ijkl}$ 和 $R_{\\mu\\nu\\rho\\sigma}$，我们提取 $R_{\\mu\\nu\\rho\\sigma}$ 的纯空间分量以形成投影张量 $R^{\\mathrm{proj}}_{ijkl}$。在这种情况下，这仅仅意味着取所有四个索引都对应于 $(r,\\theta,\\phi)$ 的子张量。\n\ne. **验证度量**：两个计算出的张量之间的一致性程度使用所提供的无量纲度量 $\\varepsilon$ 进行量化：\n$$\n\\varepsilon = \\frac{\\left\\|\\,{}^{(3)}\\!R_{ijkl}-R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}}{\\left\\|\\,{}^{(3)}\\!R_{ijkl}\\right\\|_{F}+\\left\\|R^{\\mathrm{proj}}_{ijkl}\\right\\|_{F}+\\delta}\n$$\n其中 $\\left\\|\\cdot\\right\\|_{F}$ 是 Frobenius 范数，$\\delta=10^{-30}$ 是一个正则化常数。该度量衡量了两个张量之间的相对误差。一个小的 $\\varepsilon$ 值表示良好的一致性，并作为我们的数值实现与已知物理学之间成功的一致性检验。$\\varepsilon$ 的非零值源于有限差分近似中固有的截断误差。\n\n实现将这些步骤封装到一组函数中。一个顶层函数遍历测试用例，为每组参数调用一个核心计算例程。该例程负责协调两个 Riemann 张量和最终误差度量 $\\varepsilon$ 的计算。在实现中，特别注意在循环内部为数值微分创建函数时正确处理函数闭包。\n```python\nimport numpy as np\n\ndef schwarzschild_metric_4d(coords, M):\n    \"\"\"\n    Computes the 4D Schwarzschild metric tensor g_mu_nu.\n    Indices: 0=t, 1=r, 2=theta, 3=phi.\n    \"\"\"\n    t, r, theta, phi = coords\n    if r = 2 * M or theta == 0 or theta == np.pi:\n        return np.full((4, 4), np.nan) # Handle singularity\n    \n    f = 1 - 2 * M / r\n    g = np.zeros((4, 4))\n    g[0, 0] = -f\n    g[1, 1] = 1 / f\n    g[2, 2] = r**2\n    g[3, 3] = r**2 * np.sin(theta)**2\n    return g\n\ndef spatial_metric_3d(coords, M):\n    \"\"\"\n    Computes the 3D spatial metric tensor gamma_ij on a t=const slice.\n    Indices: 0=r, 1=theta, 2=phi.\n    \"\"\"\n    r, theta, phi = coords\n    if r = 2 * M or theta == 0 or theta == np.pi:\n        return np.full((3, 3), np.nan) # Handle singularity\n\n    f = 1 - 2 * M / r\n    gamma = np.zeros((3, 3))\n    gamma[0, 0] = 1 / f\n    gamma[1, 1] = r**2\n    gamma[2, 2] = r**2 * np.sin(theta)**2\n    return gamma\n\ndef numerical_derivative(func, point, var_idx, h):\n    \"\"\"\n    Computes the central finite difference derivative of a function.\n    'func' takes one argument: a coordinate tuple/array.\n    \"\"\"\n    p_plus = np.array(point, dtype=float)\n    p_minus = np.array(point, dtype=float)\n    p_plus[var_idx] += h\n    p_minus[var_idx] -= h\n    return (func(p_plus) - func(p_minus)) / (2 * h)\n\ndef make_metric_component_func(metric_func, M, i, j):\n    \"\"\"Factory to create a function that returns a single metric component.\"\"\"\n    def metric_component_at_p(p):\n        return metric_func(p, M)[i, j]\n    return metric_component_at_p\n\ndef compute_christoffel(metric_func, dim, point, M, h_vec):\n    \"\"\"Computes Christoffel symbols Gamma^i_{jk} numerically.\"\"\"\n    g = metric_func(point, M)\n    g_inv = np.linalg.inv(g)\n\n    # dg[k, i, j] = partial_k g_ij\n    dg = np.zeros((dim, dim, dim))\n    for k in range(dim):\n        for i in range(dim):\n            for j in range(dim):\n                # Create a function of position for the specific metric component\n                f_ij = make_metric_component_func(metric_func, M, i, j)\n                dg[k, i, j] = numerical_derivative(f_ij, point, k, h_vec[k])\n\n    # Gamma^alpha_{beta,gamma}\n    gamma_tensor = np.zeros((dim, dim, dim))\n    for alpha in range(dim):\n        for beta in range(dim):\n            for iota in range(dim): # iota = gamma in formula\n                sum_val = 0\n                for delta in range(dim):\n                    term1 = dg[beta, iota, delta]   # partial_beta g_{gamma,delta}\n                    term2 = dg[iota, beta, delta]   # partial_gamma g_{beta,delta}\n                    term3 = -dg[delta, beta, iota]  # -partial_delta g_{beta,gamma}\n                    sum_val += g_inv[alpha, delta] * (term1 + term2 + term3)\n                gamma_tensor[alpha, beta, iota] = 0.5 * sum_val\n    return gamma_tensor\n\ndef make_gamma_func(metric_func, dim, M, h_vec, i, j, k):\n    \"\"\"Factory for a function returning a single Christoffel symbol component.\"\"\"\n    def gamma_component_at_p(p):\n        temp_gamma = compute_christoffel(metric_func, dim, p, M, h_vec)\n        return temp_gamma[i, j, k]\n    return gamma_component_at_p\n\ndef compute_riemann(metric_func, dim, point, M, h_vec):\n    \"\"\"Computes the Riemann tensor R_{ijkl} numerically.\"\"\"\n    christoffel_at_point = compute_christoffel(metric_func, dim, point, M, h_vec)\n\n    # dGamma[k, i, j, l] = partial_k Gamma^i_{jl}\n    dGamma = np.zeros((dim, dim, dim, dim))\n    for k in range(dim):\n        for i in range(dim):\n            for j in range(dim):\n                for l in range(dim):\n                    gamma_ijl_func = make_gamma_func(metric_func, dim, M, h_vec, i, j, l)\n                    dGamma[k, i, j, l] = numerical_derivative(gamma_ijl_func, point, k, h_vec[k])\n    \n    # R^i_{jkl}\n    R_upper = np.zeros((dim, dim, dim, dim))\n    for i in range(dim):\n        for j in range(dim):\n            for k in range(dim):\n                for l in range(dim):\n                    term1 = dGamma[k, i, j, l]      # partial_k Gamma^i_{jl}\n                    term2 = -dGamma[l, i, j, k]     # -partial_l Gamma^i_{jk}\n                    term3 = np.einsum('m,m->', christoffel_at_point[i, k, :], christoffel_at_point[:, j, l])\n                    term4 = -np.einsum('m,m->', christoffel_at_point[i, l, :], christoffel_at_point[:, j, k])\n                    R_upper[i, j, k, l] = term1 + term2 + term3 + term4\n\n    # Lower the first index: R_{ijkl} = g_{im} R^m_{jkl}\n    g_at_point = metric_func(point, M)\n    R_lower = np.einsum('im,mjkl->ijkl', g_at_point, R_upper)\n    return R_lower\n\ndef calculate_epsilon(M, r, theta, phi, ht, hr, htheta, hphi):\n    \"\"\"Main function to calculate the validation metric epsilon for a given case.\"\"\"\n    \n    current_hr = hr\n    if r - current_hr = 2 * M:\n        # Reduce step size to stay outside the horizon. (Not needed for test cases)\n        current_hr = (r - (2 * M)) / 2.0 \n    \n    t = 0.0 # Metric is static, t is arbitrary.\n    point_4d = np.array([t, r, theta, phi])\n    h_4d = np.array([ht, current_hr, htheta, hphi])\n    \n    point_3d = np.array([r, theta, phi])\n    h_3d = np.array([current_hr, htheta, hphi])\n\n    # 1. Compute 3D Riemann tensor\n    R_3d = compute_riemann(spatial_metric_3d, 3, point_3d, M, h_3d)\n\n    # 2. Compute 4D Riemann tensor\n    R_4d = compute_riemann(schwarzschild_metric_4d, 4, point_4d, M, h_4d)\n    \n    # 3. Project 4D Riemann tensor to the spatial slice\n    R_proj = R_4d[1:, 1:, 1:, 1:]\n\n    # 4. Calculate the validation metric\n    delta = 1e-30\n    diff_R = R_3d - R_proj\n    \n    norm_diff = np.linalg.norm(diff_R)\n    norm_3d = np.linalg.norm(R_3d)\n    norm_proj = np.linalg.norm(R_proj)\n    \n    epsilon = norm_diff / (norm_3d + norm_proj + delta)\n    return epsilon\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints results.\n    \"\"\"\n    test_cases = [\n        (1.0, 10.0, np.pi/3, 0.7, 1e-6, 1e-5 * 10.0, 1e-6, 1e-6),\n        (1.0, 2.1, 1.2, 2.0, 1e-6, 1e-5 * 2.1, 1e-6, 1e-6),\n        (1.0, 6.0, np.pi/2, 0.1, 1e-6, 1e-5 * 6.0, 1e-6, 1e-6),\n        (1.0, 100.0, 2.0, 3.0, 1e-6, 1e-5 * 100.0, 1e-6, 1e-6),\n        (1.0, 8.0, 0.05, 1.0, 1e-6, 1e-5 * 8.0, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    for params in test_cases:\n        M, r, theta, phi, ht, hr, htheta, hphi = params\n        epsilon = calculate_epsilon(M, r, theta, phi, ht, hr, htheta, hphi)\n        results.append(epsilon)\n    \n    # This part would normally be executed to generate the answer.\n    # For this exercise, the code itself is the primary content of the answer.\n    # print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    # Running this block would generate the numerical answer.\n    # The provided test cases are computationally intensive.\n    pass\n```", "answer": "```python\nimport numpy as np\n\ndef schwarzschild_metric_4d(coords, M):\n    \"\"\"\n    Computes the 4D Schwarzschild metric tensor g_mu_nu.\n    Indices: 0=t, 1=r, 2=theta, 3=phi.\n    \"\"\"\n    t, r, theta, phi = coords\n    if r = 2 * M or theta == 0 or theta == np.pi:\n        return np.full((4, 4), np.nan) # Handle singularity\n    \n    f = 1 - 2 * M / r\n    g = np.zeros((4, 4))\n    g[0, 0] = -f\n    g[1, 1] = 1 / f\n    g[2, 2] = r**2\n    g[3, 3] = r**2 * np.sin(theta)**2\n    return g\n\ndef spatial_metric_3d(coords, M):\n    \"\"\"\n    Computes the 3D spatial metric tensor gamma_ij on a t=const slice.\n    Indices: 0=r, 1=theta, 2=phi.\n    \"\"\"\n    r, theta, phi = coords\n    if r = 2 * M or theta == 0 or theta == np.pi:\n        return np.full((3, 3), np.nan) # Handle singularity\n\n    f = 1 - 2 * M / r\n    gamma = np.zeros((3, 3))\n    gamma[0, 0] = 1 / f\n    gamma[1, 1] = r**2\n    gamma[2, 2] = r**2 * np.sin(theta)**2\n    return gamma\n\ndef numerical_derivative(func, point, var_idx, h):\n    \"\"\"\n    Computes the central finite difference derivative of a function.\n    'func' takes one argument: a coordinate tuple/array.\n    \"\"\"\n    p_plus = np.array(point, dtype=float)\n    p_minus = np.array(point, dtype=float)\n    p_plus[var_idx] += h\n    p_minus[var_idx] -= h\n    return (func(p_plus) - func(p_minus)) / (2 * h)\n\ndef make_metric_component_func(metric_func, M, i, j):\n    \"\"\"Factory to create a function that returns a single metric component.\"\"\"\n    def metric_component_at_p(p):\n        return metric_func(p, M)[i, j]\n    return metric_component_at_p\n\ndef compute_christoffel(metric_func, dim, point, M, h_vec):\n    \"\"\"Computes Christoffel symbols Gamma^i_{jk} numerically.\"\"\"\n    g = metric_func(point, M)\n    g_inv = np.linalg.inv(g)\n\n    # dg[k, i, j] = partial_k g_ij\n    dg = np.zeros((dim, dim, dim))\n    for k in range(dim):\n        for i in range(dim):\n            for j in range(dim):\n                # Create a function of position for the specific metric component\n                f_ij = make_metric_component_func(metric_func, M, i, j)\n                dg[k, i, j] = numerical_derivative(f_ij, point, k, h_vec[k])\n\n    # Gamma^alpha_{beta,gamma}\n    gamma_tensor = np.zeros((dim, dim, dim))\n    for alpha in range(dim):\n        for beta in range(dim):\n            for iota in range(dim): # iota = gamma in formula\n                sum_val = 0\n                for delta in range(dim):\n                    term1 = dg[beta, iota, delta]   # partial_beta g_{gamma,delta}\n                    term2 = dg[iota, beta, delta]   # partial_gamma g_{beta,delta}\n                    term3 = -dg[delta, beta, iota]  # -partial_delta g_{beta,gamma}\n                    sum_val += g_inv[alpha, delta] * (term1 + term2 + term3)\n                gamma_tensor[alpha, beta, iota] = 0.5 * sum_val\n    return gamma_tensor\n\ndef make_gamma_func(metric_func, dim, M, h_vec, i, j, k):\n    \"\"\"Factory for a function returning a single Christoffel symbol component.\"\"\"\n    def gamma_component_at_p(p):\n        temp_gamma = compute_christoffel(metric_func, dim, p, M, h_vec)\n        return temp_gamma[i, j, k]\n    return gamma_component_at_p\n\ndef compute_riemann(metric_func, dim, point, M, h_vec):\n    \"\"\"Computes the Riemann tensor R_{ijkl} numerically.\"\"\"\n    christoffel_at_point = compute_christoffel(metric_func, dim, point, M, h_vec)\n\n    # dGamma[k, i, j, l] = partial_k Gamma^i_{jl}\n    dGamma = np.zeros((dim, dim, dim, dim))\n    for k in range(dim):\n        for i in range(dim):\n            for j in range(dim):\n                for l in range(dim):\n                    gamma_ijl_func = make_gamma_func(metric_func, dim, M, h_vec, i, j, l)\n                    dGamma[k, i, j, l] = numerical_derivative(gamma_ijl_func, point, k, h_vec[k])\n    \n    # R^i_{jkl}\n    R_upper = np.zeros((dim, dim, dim, dim))\n    for i in range(dim):\n        for j in range(dim):\n            for k in range(dim):\n                for l in range(dim):\n                    term1 = dGamma[k, i, j, l]      # partial_k Gamma^i_{jl}\n                    term2 = -dGamma[l, i, j, k]     # -partial_l Gamma^i_{jk}\n                    term3 = np.einsum('m,m->', christoffel_at_point[i, k, :], christoffel_at_point[:, j, l])\n                    term4 = -np.einsum('m,m->', christoffel_at_point[i, l, :], christoffel_at_point[:, j, k])\n                    R_upper[i, j, k, l] = term1 + term2 + term3 + term4\n\n    # Lower the first index: R_{ijkl} = g_{im} R^m_{jkl}\n    g_at_point = metric_func(point, M)\n    R_lower = np.einsum('im,mjkl->ijkl', g_at_point, R_upper)\n    return R_lower\n\ndef calculate_epsilon(M, r, theta, phi, ht, hr, htheta, hphi):\n    \"\"\"Main function to calculate the validation metric epsilon for a given case.\"\"\"\n    \n    current_hr = hr\n    if r - current_hr = 2 * M:\n        current_hr = (r - (2 * M)) / 2.0 \n    \n    t = 0.0\n    point_4d = np.array([t, r, theta, phi])\n    h_4d = np.array([ht, current_hr, htheta, hphi])\n    \n    point_3d = np.array([r, theta, phi])\n    h_3d = np.array([current_hr, htheta, hphi])\n\n    R_3d = compute_riemann(spatial_metric_3d, 3, point_3d, M, h_3d)\n    R_4d = compute_riemann(schwarzschild_metric_4d, 4, point_4d, M, h_4d)\n    R_proj = R_4d[1:, 1:, 1:, 1:]\n\n    delta = 1e-30\n    diff_R = R_3d - R_proj\n    \n    norm_diff = np.linalg.norm(diff_R)\n    norm_3d = np.linalg.norm(R_3d)\n    norm_proj = np.linalg.norm(R_proj)\n    \n    epsilon = norm_diff / (norm_3d + norm_proj + delta)\n    return epsilon\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints results.\n    \"\"\"\n    test_cases = [\n        (1.0, 10.0, np.pi/3, 0.7, 1e-6, 1e-5 * 10.0, 1e-6, 1e-6),\n        (1.0, 2.1, 1.2, 2.0, 1e-6, 1e-5 * 2.1, 1e-6, 1e-6),\n        (1.0, 6.0, np.pi/2, 0.1, 1e-6, 1e-5 * 6.0, 1e-6, 1e-6),\n        (1.0, 100.0, 2.0, 3.0, 1e-6, 1e-5 * 100.0, 1e-6, 1e-6),\n        (1.0, 8.0, 0.05, 1.0, 1e-6, 1e-5 * 8.0, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    for params in test_cases:\n        M, r, theta, phi, ht, hr, htheta, hphi = params\n        epsilon = calculate_epsilon(M, r, theta, phi, ht, hr, htheta, hphi)\n        results.append(epsilon)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3491214"}, {"introduction": "约束方程不仅仅是静态条件；它们还与守恒律有着深刻的联系，这对于稳定的数值模拟至关重要。本练习探讨了科达齐方程在动量约束中的作用，展示了如何将其写成通量守恒形式 [@problem_id:3491204]。通过有限体积法实现并测试这种形式，你将直接体验现代数值相对论程序中用于处理约束的技术。", "problem": "要求您在广义相对论的三加一($3+1$)分解中使用高斯-科达齐关系，推导、实现并验证在平直空间度规下动量约束的一种通量形式。该任务纯粹是数学和算法性质的：从几何基本原理出发，得到一个适用于有限体积法的散度形式，将其实现，并数值验证一个积分恒等式。\n\n给定一个具有度规 $\\gamma_{ij}$ 和外曲率 $K_{ij}$ 的空间超曲面，科达齐方程将 $K_{ij}$ 的空间协变导数与四维曲率联系起来。仅从以下几点出发：\n- 科达齐方程（投影到超曲面上）和爱因斯坦场方程，\n- 列维-奇维塔联络的度规相容性 $D_k \\gamma_{ij} = 0$，\n- 迹的定义 $K = \\gamma^{ij} K_{ij}$\n推导在 $\\gamma_{ij} = \\delta_{ij}$ 且克里斯托费尔符号为零的平直度规极限下，动量约束的一种通量形式。具体而言，在该极限下，获得一个 $(1,1)$ 阶通量，其散度等于左侧的 $D_j K^{ij} - D^i K$。\n\n然后，将此通量形式嵌入到一个二维空间矩形域上的守恒型有限体积法中。使用带单元中心的均匀笛卡尔网格，并通过在内部面上进行算术平均以及在边界上进行单边复制，从单元中心值定义数值面通量。在此平直度规设置下，由于内部面贡献的对消，有限体积法产生一个精确的离散散度定理。\n\n验证目标：对于下面列出的每个测试用例，计算\n- 使用推导出的通量的有限体积散度计算区域积分量 $\\int_{\\Omega} \\left(D_j K^{ij} - D^i K\\right)\\, dA$，以及\n- 同一通量的边界积分 $\\int_{\\partial \\Omega} n_j \\,\\mathcal{F}^{ij}\\, ds$（其中 $n_j$ 为外向单位法向量），\n并验证这两个向量（对于 $i \\in \\{x,y\\}$）在舍入误差范围内是一致的。对于每个测试用例，报告一个等于这两个向量之间分量最大绝对差的单个标量。三角函数中的角度应解释为弧度。无需物理单位。\n\n使用的实现细节：\n- 在具有坐标 $x$ 和 $y$ 的两个空间维度中工作。使用平直空间度规 $\\gamma_{ij} = \\delta_{ij}$，因此 $D_j$ 简化为 $\\partial_j$。\n- 令 $\\Omega = [0,L_x]\\times[0,L_y]$ 为矩形域，对于整数 $N_x$ 和 $N_y$，均匀网格间距为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。\n- 使用单元中心的有限体积布局。通过对内部面上相邻单元中心通量进行平均来定义数值面通量。在边界上，使用相邻边界单元的通量作为面通量值。\n- 为进行评估，将 $K_{ij}$ 视为对称的，并提供三个独立分量 $K_{xx}(x,y)$、$K_{xy}(x,y)=K_{yx}(x,y)$ 和 $K_{yy}(x,y)$。二维中的迹为 $K = K_{xx} + K_{yy}$。\n\n测试套件：\n- 用例 $1$ (理想情况，常数场)：$L_x = 1$, $L_y = 1$, $N_x = 16$, $N_y = 16$, 且\n  $K_{xx}(x,y) = 0.3$,\n  $K_{xy}(x,y) = -0.2$,\n  $K_{yy}(x,y) = 0.5$。\n- 用例 $2$ (线性场，测试边界通量聚合)：$L_x = 1$, $L_y = 1$, $N_x = 25$, $N_y = 25$, 且\n  $K_{xx}(x,y) = 0.1x + 0.2y + 0.05$,\n  $K_{xy}(x,y) = -0.3x + 0.1y - 0.07$,\n  $K_{yy}(x,y) = 0.2x - 0.4y + 0.09$。\n- 用例 $3$ (平滑振荡场，角度以弧度为单位)：$L_x = 2\\pi$, $L_y = 2\\pi$, $N_x = 64$, $N_y = 64$, 且\n  $K_{xx}(x,y) = \\sin(x) + \\cos(y)$,\n  $K_{xy}(x,y) = \\sin(x+y)$,\n  $K_{yy}(x,y) = \\cos(x) - \\sin(y)$。\n- 用例 $4$ (二次多项式，边缘情况梯度)：$L_x = 1$, $L_y = 1$, $N_x = 17$, $N_y = 17$, 且\n  $K_{xx}(x,y) = x^2 + y$,\n  $K_{xy}(x,y) = xy$,\n  $K_{yy}(x,y) = y^2 - x$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述用例顺序排列的结果，形式为方括号括起来的逗号分隔列表，不含空格。例如，一个有效的输出看起来像 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是一个浮点数，表示用例 $k$ 所请求的最大绝对差。", "solution": "用户提供了一个问题，要求在简化的设定下，从广义相对论中推导和数值验证动量约束方程的一种通量形式。验证和解答如下。\n\n### 步骤1：提取给定条件\n- **控制关系**：推导从科达齐方程（投影到超曲面上）和爱因斯坦场方程出发。\n- **基本原理**：假定列维-奇维塔联络满足度规相容性 $D_k \\gamma_{ij} = 0$。\n- **定义**：外曲率的迹为 $K = \\gamma^{ij} K_{ij}$。\n- **问题背景**：设定是广义相对论的三加一($3+1$)分解。\n- **简化**：问题将在平直度规极限下解决，其中空间度规 $\\gamma_{ij} = \\delta_{ij}$ 且其相关的克里斯托费尔符号为零。\n- **推导目标**：推导一个 $(1,1)$ 阶张量通量 $\\mathcal{F}^{ij}$，其散度在指定的平直度规极限下等于动量约束源项 $D_j K^{ij} - D^i K$。\n- **数值域**：一个二维矩形域 $\\Omega = [0,L_x]\\times[0,L_y]$，带有 $N_x \\times N_y$ 个单元的均匀笛卡尔网格。\n- **数值方法**：单元中心的有限体积法。\n- **数值通量规则**：在内部面上，通量是两个相邻单元中值的算术平均。在边界面上，通量是相邻边界单元值的直接复制。\n- **验证任务**：对于每个测试用例，计算两个向量：\n    1. 使用每个单元中有限体积散度的总和来评估的区域积分 $\\int_{\\Omega} \\left(D_j K^{ij} - D^i K\\right)\\, dA$。\n    2. 通过对边界面上的数值通量求和来评估的边界积分 $\\int_{\\partial \\Omega} n_j \\,\\mathcal{F}^{ij}\\, ds$。\n- **报告指标**：两个计算出的向量之间的最大分量绝对差。\n- **测试用例**：提供了四个具体用例，定义了域大小（$L_x, L_y$）、网格分辨率（$N_x, N_y$）以及对称外曲率张量独立分量 $K_{xx}(x,y)$, $K_{xy}(x,y)$ 和 $K_{yy}(x,y)$ 的函数形式。\n\n### 步骤2：使用提取的给定条件进行验证\n问题经过了严格的验证过程。\n\n- **科学依据**：问题在科学上是合理的。它基于广义相对论的ADM ($3+1$) 形式体系，这是理论物理和数值相对论中一个标准且成熟的框架。动量约束是基本的爱因斯坦约束方程之一，将其处理成通量守恒形式是设计数值格式的标准技术。\n- **适定性**：问题是适定的。推导任务是张量微积分在简化（平直空间）极限下的直接应用，会得到一个唯一的通量表达式。数值验证任务也是适定的：数值方法（具有指定通量的有限体积法）被无歧义地定义，测试函数是明确的，比较指标是精确的。这保证了每个测试用例都能得到唯一、稳定且有意义的数值结果（受浮点精度限制）。\n- **客观性**：问题以精确、客观的数学语言陈述，没有歧义或主观解释。\n- **缺陷检查清单**：问题没有违反任何无效标准。它是科学上合理、可形式化、完整且可行的。所有术语在微分几何和数值分析的背景下都有明确的定义。该任务是这些原理的一次非平凡的应用，既需要解析推导，也需要仔细的数值实现。\n\n### 步骤3：结论和行动\n问题是**有效的**。下面提供了完整的解答。\n\n### 通量形式的推导\n\n我们感兴趣的量是 $M^i = D_j K^{ij} - D^i K$，它表示真空中的动量约束。我们在平直空间几何中工作，其度规为克罗内克δ，即 $\\gamma_{ij} = \\delta_{ij}$。这一简化有两个关键结果：\n$1$. 空间度规的克里斯托费尔符号为零，所以协变导数 $D_j$ 简化为偏导数 $\\partial_j$。\n$2$. 升降指标变得平凡（例如，$K^{ij} = K_{ij}$, $D^i = \\delta^{ij}D_j = \\partial_i$）。\n\n因此，$M^i$ 的表达式简化为：\n$$M^i = \\partial_j K_{ij} - \\partial_i K$$\n其中 $K$ 是迹，$K = \\delta^{ij}K_{ij} = K_{kk}$（对 $k$ 求和）。目标是将 $M^i$ 写成一个通量张量 $\\mathcal{F}^{ij}$ 的散度，即 $M^i = \\partial_j \\mathcal{F}^{ij}$。\n\n我们假设一个通量张量的形式为 $\\mathcal{F}^{ij} = A K_{ij} + B \\delta_{ij} K$，其中 $A$ 和 $B$ 是常数。取其散度：\n$$\\partial_j \\mathcal{F}^{ij} = \\partial_j (A K_{ij} + B \\delta_{ij} K) = A \\partial_j K_{ij} + B \\partial_j(\\delta_{ij} K) = A \\partial_j K_{ij} + B \\delta_{ij} \\partial_j K$$\n使用 $\\delta_{ij} \\partial_j = \\partial_i$，我们得到：\n$$\\partial_j \\mathcal{F}^{ij} = A \\partial_j K_{ij} + B \\partial_i K$$\n将其与目标表达式 $M^i = \\partial_j K_{ij} - \\partial_i K$ 比较，我们可以匹配系数，得到 $A=1$ 和 $B=-1$。\n因此，所求的通量张量为：\n$$\\mathcal{F}^{ij} = K_{ij} - \\delta_{ij} K$$\n在具有坐标 $(x, y)$ 的二维空间中，迹为 $K = K_{xx} + K_{yy}$。通量张量 $\\mathcal{F}$ 的分量为：\n$$\n\\mathcal{F}^{xx} = K_{xx} - K = K_{xx} - (K_{xx} + K_{yy}) = -K_{yy} \\\\\n\\mathcal{F}^{xy} = K_{xy} - \\delta_{xy} K = K_{xy} \\\\\n\\mathcal{F}^{yx} = K_{yx} - \\delta_{yx} K = K_{yx} = K_{xy} \\\\\n\\mathcal{F}^{yy} = K_{yy} - K = K_{yy} - (K_{xx} + K_{yy}) = -K_{xx}\n$$\n所以，通量张量由矩阵 $\\mathcal{F} = \\begin{pmatrix} -K_{yy}  K_{xy} \\\\ K_{xy}  -K_{xx} \\end{pmatrix}$ 给出。\n\n### 通过离散散度定理进行数值验证\n\n问题要求对散度定理进行数值验证，该定理表述为 $\\int_\\Omega \\nabla \\cdot \\mathbf{F} \\, dA = \\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, ds$。在我们的背景下，对于每个动量分量 $i \\in \\{x, y\\}$，这变为：\n$$\\int_\\Omega (\\partial_j \\mathcal{F}^{ij}) \\, dA = \\oint_{\\partial\\Omega} \\mathcal{F}^{ij} n_j \\, ds$$\n我们使用指定的有限体积格式计算左侧（体积分 $V^i$）和右侧（边面积分 $S^i$），并验证它们相等。\n\n**1. 体积分 ($V^i$):**\n区域被离散为 $N_x \\times N_y$ 个单元。体积分是每个单元上积分的总和。对于一个单元 $(k, l)$，散度的积分通过其边界上的净通量乘以单元面积 $\\Delta x \\Delta y$ 来近似。对所有单元求和：\n$$V^i = \\sum_{k=0}^{N_x-1} \\sum_{l=0}^{N_y-1} (\\text{div}_h \\mathcal{F}^i)_{k,l} \\, \\Delta x \\Delta y$$\n其中 $(\\text{div}_h \\mathcal{F}^i)_{k,l}$ 是单元 $(k,l)$ 的离散散度，使用其四个面上的指定数值通量计算得出。由于内部面上的和具有对消性质，这个和在代数上简化为穿过整个区域边界的总通量。\n\n**2. 边面积分 ($S^i$):**\n这是通过对区域边界上的数值通量求和来计算的。对于一个边界面，数值通量被规定为相邻单元的单元中心值。例如，右边界（$x=L_x$）上的通量由单元 $(k=N_x-1, l)$ 中的值决定。总边界积分为：\n$$S^i = \\sum_{l=0}^{N_y-1} (\\mathcal{F}^{ix}_{N_x-1,l} - \\mathcal{F}^{ix}_{0,l})\\Delta y + \\sum_{k=0}^{N_x-1} (\\mathcal{F}^{iy}_{k,N_y-1} - \\mathcal{F}^{iy}_{k,0})\\Delta x$$\n其中 $\\mathcal{F}^{ix}$ 和 $\\mathcal{F}^{iy}$ 分别是第 $i$ 个动量分量的通量向量的 $x$ 和 $y$ 分量。\n\n任务的核心是分别实现 $V^i$ 和 $S^i$ 的计算并进行比较。任何差异纯粹由浮点运算的顺序引起。\n\n### 算法实现\n\n对于每个测试用例，算法流程如下：\n1. 定义 $N_x \\times N_y$ 个单元中心 $(x_k, y_l)$ 的网格。\n2. 在此网格上评估给定的函数 $K_{xx}, K_{xy}, K_{yy}$。\n3. 由此计算通量张量分量 $\\mathcal{F}^{xx}, \\mathcal{F}^{xy}, \\mathcal{F}^{yx}, \\mathcal{F}^{yy}$ 的单元中心值。\n4. 计算 $V^i = [V^x, V^y]$：\n    a. 对每个单元，使用指定的面通量规则（内部平均，边界复制）计算局部离散散度。\n    b. 将这些局部散度在所有单元上求和，并乘以单元面积 $\\Delta x \\Delta y$。由于离散散度定理，这等效于对边界通量求和。\n5. 计算 $S^i = [S^x, S^y]$：\n    a. 根据推导出的 $S^i$ 公式，对边界通量贡献求和。这涉及对区域四个边界上的通量分量求和。\n6. 计算测试用例的最终结果为 $\\max(|V^x - S^x|, |V^y - S^y|)$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    It derives and verifies a flux form of the momentum constraint.\n    \"\"\"\n    \n    test_cases = [\n        {\n            'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16,\n            'Kxx_f': lambda x, y: 0.3 + 0*x,\n            'Kxy_f': lambda x, y: -0.2 + 0*x,\n            'Kyy_f': lambda x, y: 0.5 + 0*x\n        },\n        {\n            'Lx': 1.0, 'Ly': 1.0, 'Nx': 25, 'Ny': 25,\n            'Kxx_f': lambda x, y: 0.1*x + 0.2*y + 0.05,\n            'Kxy_f': lambda x, y: -0.3*x + 0.1*y - 0.07,\n            'Kyy_f': lambda x, y: 0.2*x - 0.4*y + 0.09\n        },\n        {\n            'Lx': 2 * np.pi, 'Ly': 2 * np.pi, 'Nx': 64, 'Ny': 64,\n            'Kxx_f': lambda x, y: np.sin(x) + np.cos(y),\n            'Kxy_f': lambda x, y: np.sin(x + y),\n            'Kyy_f': lambda x, y: np.cos(x) - np.sin(y)\n        },\n        {\n            'Lx': 1.0, 'Ly': 1.0, 'Nx': 17, 'Ny': 17,\n            'Kxx_f': lambda x, y: x**2 + y,\n            'Kxy_f': lambda x, y: x * y,\n            'Kyy_f': lambda x, y: y**2 - x\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_diff = solve_case(case)\n        results.append(max_diff)\n\n    # Use a format that avoids scientific notation for small numbers near zero.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef solve_case(case):\n    \"\"\"\n    Computes the maximum absolute difference between the volume and surface\n    integrals for a single test case, using a proper FVM implementation.\n    \"\"\"\n    Lx, Ly, Nx, Ny = case['Lx'], case['Ly'], case['Nx'], case['Ny']\n    Kxx_f, Kxy_f, Kyy_f = case['Kxx_f'], case['Kxy_f'], case['Kyy_f']\n    \n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n    K_xx = Kxx_f(X, Y)\n    K_xy = Kxy_f(X, Y)\n    K_yy = Kyy_f(X, Y)\n\n    F_xx = -K_yy\n    F_xy = K_xy\n    F_yx = K_xy\n    F_yy = -K_xx\n\n    # --- 1. Compute Volume Integral V via FVM telescoping sum ---\n    # This sum is algebraically equivalent to the boundary integral S.\n    \n    # Numerical fluxes at x-faces (i+1/2)\n    Fx_x_face = np.zeros((Ny, Nx + 1))\n    Fx_x_face[:, 1:-1] = 0.5 * (F_xx[:, :-1] + F_xx[:, 1:])\n    Fx_x_face[:, 0] = F_xx[:, 0]\n    Fx_x_face[:, -1] = F_xx[:, -1]\n\n    Fy_x_face = np.zeros((Ny, Nx + 1))\n    Fy_x_face[:, 1:-1] = 0.5 * (F_yx[:, :-1] + F_yx[:, 1:])\n    Fy_x_face[:, 0] = F_yx[:, 0]\n    Fy_x_face[:, -1] = F_yx[:, -1]\n\n    # Numerical fluxes at y-faces (j+1/2)\n    Fx_y_face = np.zeros((Ny + 1, Nx))\n    Fx_y_face[1:-1, :] = 0.5 * (F_xy[:-1, :] + F_xy[1:, :])\n    Fx_y_face[0, :] = F_xy[0, :]\n    Fx_y_face[-1, :] = F_xy[-1, :]\n\n    Fy_y_face = np.zeros((Ny + 1, Nx))\n    Fy_y_face[1:-1, :] = 0.5 * (F_yy[:-1, :] + F_yy[1:, :])\n    Fy_y_face[0, :] = F_yy[0, :]\n    Fy_y_face[-1, :] = F_yy[-1, :]\n\n    # Sum of cell divergences (times cell area)\n    # This is the volume integral.\n    div_x = (Fx_x_face[:, 1:] - Fx_x_face[:, :-1]) * dy + \\\n            (Fx_y_face[1:, :] - Fx_y_face[:-1, :]) * dx\n    div_y = (Fy_x_face[:, 1:] - Fy_x_face[:, :-1]) * dy + \\\n            (Fy_y_face[1:, :] - Fy_y_face[:-1, :]) * dx\n    \n    Vx = np.sum(div_x)\n    Vy = np.sum(div_y)\n    V_vec = np.array([Vx, Vy])\n\n    # --- 2. Compute Surface Integral S directly ---\n    sx_x_boundary = (np.sum(F_xx[:, -1]) - np.sum(F_xx[:, 0])) * dy\n    sx_y_boundary = (np.sum(F_xy[-1, :]) - np.sum(F_xy[0, :])) * dx\n    Sx = sx_x_boundary + sx_y_boundary\n\n    sy_x_boundary = (np.sum(F_yx[:, -1]) - np.sum(F_yx[:, 0])) * dy\n    sy_y_boundary = (np.sum(F_yy[-1, :]) - np.sum(F_yy[0, :])) * dx\n    Sy = sy_x_boundary + sy_y_boundary\n    \n    S_vec = np.array([Sx, Sy])\n\n    # --- 3. Compare and return the maximum absolute componentwise difference ---\n    max_diff = np.max(np.abs(V_vec - S_vec))\n    return max_diff\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3491204"}]}