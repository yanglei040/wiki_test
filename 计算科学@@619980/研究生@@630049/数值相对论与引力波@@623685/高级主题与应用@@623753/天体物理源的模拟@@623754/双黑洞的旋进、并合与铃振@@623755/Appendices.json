{"hands_on_practices": [{"introduction": "在数值相对论中，时空是逐个空间切片演化的，一个核心挑战是如何在这些切片上定位黑洞。本练习通过从第一性原理推导视界方程，将这一过程理论化，视界是数值模拟中识别黑洞边界的关键工具。通过这个实践 [@problem_id:3464688]，你将把作为“外部陷获面”的几何定义（即向外的光线膨胀为零）与 $3+1$ 分解中的具体量（如外在曲率 $K_{ij}$）联系起来，这是理解如何在模拟中测量黑洞质量和自旋等性质的基础。", "problem": "考虑一个在广义相对论 (GR) 框架下，通过 $3+1$ 形式分解进行数值演化的双黑洞时空。令 $\\Sigma_{t}$ 为坐标时间 $t$ 处的一个空间超曲面，其单位类时法向量为 $n^{a}$，诱导空间度规为 $\\gamma_{ab} = g_{ab} + n_{a} n_{b}$，外曲率为 $K_{ab} = - \\gamma_{a}^{\\ c} \\gamma_{b}^{\\ d} \\nabla_{c} n_{d}$。在 $\\Sigma_{t}$ 内部，考虑一个光滑的闭合二维面 $\\mathcal{S}$，其向外的单位空间法向量为 $s^{a}$，满足 $s^{a} s_{a} = 1$ 和 $n^{a} s_{a} = 0$。$\\mathcal{S}$ 上的诱导二维度规为 $q_{ab} = \\gamma_{ab} - s_{a} s_{b}$。定义出射零法向量为 $l^{a} = n^{a} + s^{a}$。\n\n出射零汇的膨胀定义为 $\\theta_{(l)} = q^{ab} \\nabla_{a} l_{b}$，其中 $\\nabla_{a}$ 是时空协变导数。仅使用前面的定义以及与 $\\gamma_{ab}$ 相关联的空间列维-奇维塔联络 $D_{a}$，推导 $\\theta_{(l)}$ 的一个显式表达式，该表达式完全用 $\\Sigma_{t}$ 上的 $3+1$ 变量表示，即 $D_{i}$、$K_{ij}$、其迹 $K = \\gamma^{ij} K_{ij}$ 和 $s^{i}$，其中指标 $i,j$ 是 $\\Sigma_{t}$ 上的空间指标。\n\n您的最终答案必须是 $\\theta_{(l)}$ 的一个单一闭合形式解析表达式，用 $D_{i}$、$K_{ij}$、$K$ 和 $s^{i}$ 表示。最终答案中请勿提供中间步骤。不需要进行数值计算或四舍五入，也无需报告单位。该表达式隐含地定义了 $\\Sigma_{t}$ 上边际外陷获面 (MOTS) 的视界条件 $\\theta_{(l)} = 0$。", "solution": "用户希望在广义相对论的 $3+1$ 分解中，对嵌入空间超曲面 $\\Sigma_t$ 内的闭合二维面 $\\mathcal{S}$，推导出射零汇的膨胀 $\\theta_{(l)}$。最终表达式必须用空间协变导数 $D_i$、外曲率 $K_{ij}$ 及其迹 $K$、以及曲面的空间法向量 $s^i$ 来表示。\n\n问题陈述已经过验证，并被认为是有效的。这是数值相对论和微分几何应用于广义相对论中的一个标准推导。所有定义和上下文在科学上都是合理且适定的。\n\n我们从给定的膨胀定义开始推导：\n$$\n\\theta_{(l)} = q^{ab} \\nabla_{a} l_{b}\n$$\n已知条件如下：\n1.  出射零法向量：$l^{a} = n^{a} + s^{a}$，这意味着 $l_{b} = n_{b} + s_{b}$。\n2.  到二维面 $\\mathcal{S}$ 的投影算符：$q_{ab} = \\gamma_{ab} - s_{a} s_{b}$。它在曲面切空间上的逆可以写为 $q^{ab} = \\gamma^{ab} - s^{a} s^{b}$，其中 $\\gamma^{ab}$ 是空间度规 $\\gamma_{ab}$ 的逆。请注意，像 $s^a$ 和 $\\gamma_{ab}$ 这类空间张量的指标可以通过 $\\gamma_{ab}$ 和 $\\gamma^{ab}$ 来升降。\n\n将 $l_b$ 的定义代入膨胀公式，我们得到：\n$$\n\\theta_{(l)} = q^{ab} \\nabla_{a} (n_{b} + s_{b}) = q^{ab} \\nabla_{a} n_{b} + q^{ab} \\nabla_{a} s_{b}\n$$\n我们将分别分析右侧的两项。\n\n**第一项：$q^{ab} \\nabla_{a} n_{b}$**\n\n这一项涉及空间超曲面 $\\Sigma_t$ 的类时单位法向量 $n_b$ 的时空协变导数。在 $3+1$ 形式中，$\\nabla_a n_b$ 的分解由魏恩加滕方程给出：\n$$\n\\nabla_a n_b = -K_{ab} + n_a a_b\n$$\n其中 $K_{ab} = - \\gamma_{a}^{\\ c} \\gamma_{b}^{\\ d} \\nabla_{c} n_{d}$ 是外曲率（一个空间张量），而 $a_b = n^c \\nabla_c n_b$ 是参考观测者的加速度，这些观测者的世界线与 $\\Sigma_t$ 正交。\n\n将此代入第一项：\n$$\nq^{ab} \\nabla_{a} n_{b} = q^{ab} (-K_{ab} + n_a a_b) = - q^{ab} K_{ab} + q^{ab} n_a a_b\n$$\n张量 $q^{ab}$ 是到二维面 $\\mathcal{S}$ 的投影算符，该二维面位于空间超曲面 $\\Sigma_t$ 内。根据构造，$\\mathcal{S}$ 切空间中的任何向量都与 $n^a$ 正交。因此，投影算符 $q^{ab}$ 是一个空间张量，意味着它没有沿 $n^a$ 方向的分量。这可以表示为 $q^{ab} n_a = 0$ 和 $q^{ab} n_b = 0$。\n性质 $q^{ab} n_a = 0$ 直接意味着表达式的第二部分为零：$q^{ab} n_a a_b = 0$。\n\n第一部分变为：\n$$\n-q^{ab} K_{ab} = -(\\gamma^{ab} - s^a s^b) K_{ab} = -(\\gamma^{ab} K_{ab} - s^a s^b K_{ab})\n$$\n根据定义，$\\gamma^{ab} K_{ab}$ 是外曲率的迹，记为 $K$。项 $s^a s^b K_{ab}$ 是外曲率在法向 $s^a$ 上的两次投影。由于此表达式中的所有张量（$K_{ab}$、$\\gamma^{ab}$、$s^a$）都是空间的，我们可以使用空间指标 $i, j, \\ldots$：\n$$\nq^{ab} \\nabla_{a} n_{b} = -K + K_{ij} s^i s^j\n$$\n\n**第二项：$q^{ab} \\nabla_{a} s_{b}$**\n\n这一项涉及二维面 $\\mathcal{S}$ 的空间单位法向量 $s_b$ 的时空协变导数。我们需要将其与和空间度规 $\\gamma_{ab}$ 相关联的空间协变导数 $D_a$ 联系起来。\n算符 $D_a$ 通过其对空间张量的作用来定义，该作用是将四维协变导数投影到空间超曲面上得到的结果。对于像 $s_b$ 这样的空间余向量，其关系为：\n$$\nD_a s_b = \\gamma_a^c \\gamma_b^d \\nabla_c s_d\n$$\n其中 $\\gamma_a^c = g_a^c + n_a n^c$ 是到空间切片 $\\Sigma_t$ 的投影算符。我们想计算 $q^{ab} \\nabla_a s_b$。由于 $q^{ab}$ 是一个空间张量，它满足 $q^{ab} = \\gamma_c^a \\gamma_d^b q^{cd}$。因此我们可以写出：\n$$\nq^{ab} \\nabla_a s_b = (\\gamma_c^a \\gamma_d^b q^{cd}) \\nabla_a s_b\n$$\n$\\nabla_a s_b$ 和 $D_a s_b$ 之间的关系可以通过将 $\\nabla_a s_b$ 分解为与 $\\Sigma_t$ 相切和正交的部分来找到。任何张量 $T_{ab}$ 都可以分解为 $T_{ab} = \\gamma_a^c \\gamma_b^d T_{cd} + \\dots$，其中其余项至少包含一个 $n_a$ 或 $n_b$。当我们与 $q^{ab}$ 进行缩并时，这些附加项会因为 $q^{ab}n_a=0$ 和 $q^{ab}n_b=0$ 而消失。因此：\n$$\nq^{ab} \\nabla_a s_b = q^{ab} (\\gamma_a^c \\gamma_b^d \\nabla_c s_d) = q^{ab} D_a s_b\n$$\n这表明，就我们的目的而言，我们可以用空间导数替换时空导数。该表达式现在是纯空间的，所以我们切换到空间指标：\n$$\nq^{ij} D_i s_j = (\\gamma^{ij} - s^i s^j) D_i s_j = \\gamma^{ij} D_i s_j - s^i s^j D_i s_j\n$$\n第一部分是 $s^j$ 的空间散度：$\\gamma^{ij} D_i s_j = D_i (\\gamma^{ij} s_j) - s_j (D_i \\gamma^{ij})$。由于 $D_i$ 是度规相容的（$D_i \\gamma^{ij} = 0$），这简化为 $D_i s^i$。这一项 $D_i s^i$ 表示作为嵌入三维空间 $\\Sigma_t$ 中的二维面 $\\mathcal{S}$ 的外曲率，通常记为 $\\mathcal{K}$。\n\n对于第二部分 $-s^i s^j D_i s_j$，我们利用 $s^i$ 是空间切片中的单位向量这一事实：$s_j s^j = \\gamma_{jk} s^j s^k = 1$。让我们取沿 $s^i$ 方向的协变导数：\n$$\ns^i D_i (s_j s^j) = s^i D_i (1) = 0\n$$\n使用乘积法则和 $D_i$ 的度规相容性：\n$$\ns^i ( (D_i s_j)s^j + s_j(D_i s^j) ) = 0\n$$\n重新整理各项可得：\n$$\ns^j (s^i D_i s_j) + s_j (s^i D_i s^j) = 0 \\implies 2 s^j (s^i D_i s_j) = 0\n$$\n项 $s^i D_i s_j$ 是垂直于 $\\mathcal{S}$ 的曲线汇的加速度。结果 $s^j (s^i D_i s_j) = 0$ 意味着该加速度与 $s^j$ 正交。我们需要计算的量是 $-s^j(s^i D_i s_j)$，而我们刚刚证明了它为零。因此，第二项为零：$-s^i s^j D_i s_j = 0$。\n\n所以，我们有：\n$$\nq^{ab} \\nabla_{a} s_{b} = D_i s^i\n$$\n\n**合并结果**\n\n我们现在可以将推导出的两个部分相加，得到膨胀 $\\theta_{(l)}$ 的最终表达式：\n$$\n\\theta_{(l)} = (q^{ab} \\nabla_{a} n_{b}) + (q^{ab} \\nabla_{a} s_{b}) = (-K + K_{ij} s^i s^j) + (D_i s^i)\n$$\n为了清晰起见，重新整理各项，我们得到：\n$$\n\\theta_{(l)} = D_i s^i + K_{ij} s^i s^j - K\n$$\n这个方程用空间切片的内蕴几何（$D_i$）、其外曲率（$K_{ij}$ 和 $K$）以及切片内二维面的几何（$s^i$）给出了出射零汇的膨胀。视界（边际外陷获面）的条件是 $\\theta_{(l)} = 0$。", "answer": "$$\n\\boxed{D_{i} s^{i} + K_{ij} s^{i} s^{j} - K}\n$$", "id": "3464688"}, {"introduction": "数值相对论模拟在离散的网格上近似求解爱因斯坦方程，因此，验证其结果的可靠性至关重要。一个核心的验证方法是收敛性测试：随着网格分辨率的提高，一个准确的数值解应该趋向于连续的真实解。这个编码练习 [@problem_id:3464789] 让你亲手实践这一基本验证过程，通过分析模拟数据来确定经验收敛阶，这是确保计算结果物理意义的必要步骤。", "problem": "考虑在几何单位制（$G = c = 1$，总质量 $M = 1$）下，使用 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 形式体系和协变共形 Z4 (CCZ4) 形式体系，对双黑洞的旋进、并合和铃振过程进行数值演化。在此类演化中，需要监测约束违例（例如，哈密顿约束和 Z4 约束）以及视界属性（例如，质量和无量纲自旋）作为网格分辨率 $h$ 的函数，其中 $h$ 是以总质量 $M$ 为单位表示的均匀空间网格间距。\n\n数值分析的基本原理是，一个 $p$ 阶的一致且稳定的数值离散化方案所产生的截断误差，在渐近状态下会随着网格间距呈幂律关系缩放，因此一个可观测误差 $\\varepsilon$ 在渐近区域内遵循 $ \\varepsilon \\sim \\kappa \\, h^{p} $，其中 $\\kappa$ 是一个与 $h$ 无关的常数。因此，可以通过识别误差代理与 $h$ 之间的幂律关系，从测量数据中推断出经验收敛阶 $p$。\n\n你需要实现一个程序，在给定几组分辨率 $h$ 和相应测量值的数据集后，通过估计经验收敛阶 $p$ 来执行收敛性测试。对于约束测量，你将直接把给定的约束范数 $ \\lVert \\mathcal{C} \\rVert $ 作为误差代理。对于视界测量，你将把测量属性与连续极限目标值之间的绝对偏差作为误差代理。你的程序必须使用一种鲁棒的方法，通过对给定数据集中的所有分辨率拟合幂律关系 $\\varepsilon \\propto h^{p}$ 来估计 $p$，并返回指数 $p$。\n\n你的程序必须为以下每个测试用例计算经验阶 $p$：\n\n- 测试用例 A（BSSN 约束范数，理想情况）：分辨率 $h = [1/48,\\, 1/64,\\, 1/80,\\, 1/96]$，测得的约束范数 $ \\lVert \\mathcal{C} \\rVert = [1.884\\times 10^{-4},\\, 5.960\\times 10^{-5},\\, 2.442\\times 10^{-5},\\, 1.178\\times 10^{-5}] $。\n- 测试用例 B（CCZ4 约束范数，不同阶数）：分辨率 $h = [1/40,\\, 1/56,\\, 1/72,\\, 1/88]$，测得的约束范数 $ \\lVert \\mathcal{C} \\rVert = [9.766\\times 10^{-3},\\, 1.815\\times 10^{-3},\\, 5.168\\times 10^{-4},\\, 1.894\\times 10^{-4}] $。\n- 测试用例 C（视界质量，二阶行为）：连续极限目标质量 $M_{\\infty} = 0.951$，分辨率 $h = [1/48,\\, 1/64,\\, 1/80,\\, 1/96]$，测得的视界质量 $ M(h) = [0.9510173611,\\, 0.951009765625,\\, 0.95100625,\\, 0.9510043402778] $。使用绝对偏差 $ \\lvert M(h) - M_{\\infty} \\rvert $ 作为误差代理。\n- 测试用例 D（视界无量纲自旋，高阶行为）：连续极限目标自旋 $ \\chi_{\\infty} = 0.686 $，分辨率 $h = [1/44,\\, 1/60,\\, 1/88,\\, 1/100]$，测得的视界自旋 $ \\chi(h) = [0.6861334,\\, 0.68603858,\\, 0.68600834,\\, 0.686005] $。使用绝对偏差 $ \\lvert \\chi(h) - \\chi_{\\infty} \\rvert $ 作为误差代理。\n- 测试用例 E（约束范数接近底限，边界情况）：分辨率 $h = [1/96,\\, 1/100,\\, 1/120,\\, 1/160]$，测得的约束范数 $ \\lVert \\mathcal{C} \\rVert = [1.05\\times 10^{-6},\\, 1.02\\times 10^{-6},\\, 1.01\\times 10^{-6},\\, 1.00\\times 10^{-6}] $。\n\n要求：\n- 对于每个测试用例，通过对该用例提供的所有分辨率下的误差代理和 $h$ 之间的幂律关系进行拟合，来估计经验阶 $p$。该估计必须使用一种数学上可靠的算法完成，该算法在误差代理的缩放下应保持不变，并且不应仅依赖于任何单一的成对比例。\n- 不涉及角度；无需角度单位。\n- 如果任何计算出的误差代理值为非正数，程序必须通过不尝试对非正数取对数来优雅地处理它。\n- 最终输出是无量纲的，不需要物理单位。但是，你必须在几何单位制下解释测量的质量和自旋，并根据与指定的连续极限目标值的绝对偏差来构建误差代理。\n- 你的程序应生成单行输出，其中包含估计的阶数，格式为用方括号括起来的逗号分隔列表，四舍五入到三位小数，顺序为 $[p_{A},\\, p_{B},\\, p_{C},\\, p_{D},\\, p_{E}]$。\n- 你的程序必须是自包含的，无需输入，并且只使用 Python 标准库以及指定的数值库。", "solution": "该问题已经过审查并被认为是有效的。它在科学上基于应用于计算相对论的数值分析原理，问题提法清晰，目标明确，数据充分，并以精确、客观的语言表述。该问题是收敛性测试中的一个标准练习，这是验证科学计算中数值代码的一项基本实践。\n\n目标是为几个数值数据集确定经验收敛阶，记为 $p$。其基本原理是，一个 $p$ 阶数值近似方案的截断误差 $\\varepsilon$ 会随着网格分辨率 $h$ 按照以下幂律关系进行缩放：\n$$ \\varepsilon(h) \\approx \\kappa h^p $$\n其中 $\\kappa$ 是一个比例常数，它取决于具体问题和数值方法，但与分辨率 $h$ 无关，至少在 $h$ 足够小的渐近极限下是如此。\n\n为了从一组在相应分辨率 $h_i$ 下的误差代理 $\\varepsilon_i$ 的测量值中确定指数 $p$，我们可以通过对两边取自然对数，将幂律关系转换为线性关系：\n$$ \\ln(\\varepsilon) \\approx \\ln(\\kappa) + p \\ln(h) $$\n这个方程的形式是 $y = c + mx$，其中变量为 $y = \\ln(\\varepsilon)$ 和 $x = \\ln(h)$，y 轴截距为 $c = \\ln(\\kappa)$，最重要的是，斜率就是收敛阶 $m = p$。\n\n问题要求对每个案例使用所有可用的数据点来对 $p$ 进行鲁棒估计。线性最小二乘回归方法非常适合此任务。给定一组 $N$ 个数据点 $(x_i, y_i)$，该方法会找到一条直线，使得所有数据点到该直线的垂直距离的平方和最小。这条直线的斜率提供了对 $p$ 的鲁棒估计。给定 $N$ 个数据点 $(x_i, y_i) = (\\ln(h_i), \\ln(\\varepsilon_i))$，斜率 $p$ 的显式公式为：\n$$ p = \\frac{N \\sum_{i=1}^{N}(x_i y_i) - (\\sum_{i=1}^{N} x_i)(\\sum_{i=1}^{N} y_i)}{N \\sum_{i=1}^{N}(x_i^2) - (\\sum_{i=1}^{N} x_i)^2} $$\n这种方法满足了问题的要求：它使用了所有可用数据，并且在误差代理 $\\varepsilon$ 的缩放下保持不变，因为将 $\\varepsilon$ 乘以一个常数只会改变截距 $\\ln(\\kappa)$，而不会影响斜率 $p$。\n\n要实现的算法如下：\n$1$. 对于每个测试用例，整理分辨率列表 $\\{h_i\\}$ 和相应的测量值。\n$2$. 构建误差代理值 $\\{\\varepsilon_i\\}$。\n    - 对于约束范数，$\\varepsilon_i$ 是给定的范数值 $\\lVert \\mathcal{C} \\rVert_i$。\n    - 对于视界属性，$\\varepsilon_i$ 是与连续极限目标值的绝对偏差，例如 $\\varepsilon_i = \\lvert M(h_i) - M_{\\infty} \\rvert$。\n$3$. 筛选数据，只保留误差代理 $\\varepsilon_i$ 为严格正值的点，因为对数对于非正值没有定义。这确保了按要求进行优雅处理。所提供的测试数据不包含非正误差，但这一步对于鲁棒的实现至关重要。\n$4$. 通过对每个分辨率 $h_i$ 和每个误差代理 $\\varepsilon_i$ 取自然对数来转换筛选后的数据，以获得点集 $(\\ln(h_i), \\ln(\\varepsilon_i))$。\n$5$. 对这些经过对数转换的点应用线性最小二乘回归来计算斜率，该斜率即为收敛阶 $p$ 的估计值。\n$6$. 收集所有测试用例计算出的阶数，并按指定格式进行格式化。\n\n对于测试用例 E，测得的约束范数几乎是恒定的，并接近一个底限值，这可能是由于有限的浮点精度或其他不随分辨率降低的系统效应所致。在这种情况下，误差 $\\varepsilon$ 近似为常数，因此 $\\varepsilon \\propto h^0$。因此，拟合过程预计会得出一个接近于 $0$ 的收敛阶 $p$。\n\n此过程将应用于所提供的五个测试用例中的每一个。\n- 案例 A：BSSN 约束范数。预期 $p \\approx 4$。\n- 案例 B：CCZ4 约束范数。预期 $p \\approx 6$。\n- 案例 C：视界质量。预期 $p \\approx 2$。\n- 案例 D：视界自旋。预期 $p \\approx 4$。\n- 案例 E：约束范数在底限处。预期 $p \\approx 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats # Scipy is allowed but numpy.polyfit is sufficient and used here.\n\ndef solve():\n    \"\"\"\n    Computes the empirical order of convergence for several numerical relativity test cases\n    by fitting a power law to the error proxy vs. grid resolution data.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: BSSN constraint norm\n        {\n            \"name\": \"A\",\n            \"resolutions\": np.array([1/48, 1/64, 1/80, 1/96]),\n            \"measurements\": np.array([1.884e-4, 5.960e-5, 2.442e-5, 1.178e-5]),\n            \"target\": None\n        },\n        # Case B: CCZ4 constraint norm\n        {\n            \"name\": \"B\",\n            \"resolutions\": np.array([1/40, 1/56, 1/72, 1/88]),\n            \"measurements\": np.array([9.766e-3, 1.815e-3, 5.168e-4, 1.894e-4]),\n            \"target\": None\n        },\n        # Case C: Apparent horizon mass\n        {\n            \"name\": \"C\",\n            \"resolutions\": np.array([1/48, 1/64, 1/80, 1/96]),\n            \"measurements\": np.array([0.9510173611, 0.951009765625, 0.95100625, 0.9510043402778]),\n            \"target\": 0.951\n        },\n        # Case D: Apparent horizon dimensionless spin\n        {\n            \"name\": \"D\",\n            \"resolutions\": np.array([1/44, 1/60, 1/88, 1/100]),\n            \"measurements\": np.array([0.6861334, 0.68603858, 0.68600834, 0.686005]),\n            \"target\": 0.686\n        },\n        # Case E: Constraint norm near floor\n        {\n            \"name\": \"E\",\n            \"resolutions\": np.array([1/96, 1/100, 1/120, 1/160]),\n            \"measurements\": np.array([1.05e-6, 1.02e-6, 1.01e-6, 1.00e-6]),\n            \"target\": None\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        h = case[\"resolutions\"]\n        measurements = case[\"measurements\"]\n        target = case[\"target\"]\n\n        # Calculate the error proxy\n        if target is not None:\n            # For apparent horizon properties, error is the absolute deviation from the continuum target\n            error_proxy = np.abs(measurements - target)\n        else:\n            # For constraint norms, the norm itself is the error proxy\n            error_proxy = measurements\n\n        # Gracefully handle non-positive error proxies by filtering them out.\n        # This is a robustness measure; the given data has only positive errors.\n        valid_indices = np.where(error_proxy > 0)\n        \n        h_filtered = h[valid_indices]\n        error_proxy_filtered = error_proxy[valid_indices]\n\n        # A linear fit requires at least 2 points.\n        if len(h_filtered)  2:\n            # Convergence order is undefined with fewer than 2 points.\n            # Storing as NaN (Not a Number) for this edge case.\n            p = np.nan\n        else:\n            # Transform to log-log space for linear fitting\n            log_h = np.log(h_filtered)\n            log_error = np.log(error_proxy_filtered)\n\n            # Perform a linear least-squares fit (degree 1 polynomial)\n            # np.polyfit returns the coefficients [slope, intercept]\n            # The slope is the desired convergence order 'p'.\n            p, _ = np.polyfit(log_h, log_error, 1)\n\n        results.append(p)\n\n    # Format the final output as a comma-separated list of orders,\n    # rounded to three decimal places, enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3464789"}, {"introduction": "引力波探测器实际上位于距源无限远的地方，而数值模拟则在有限的计算区域内进行，这就要求我们必须将在有限半径 $R$ 处提取的引力波信号外推至零无穷远（$R \\to \\infty$）。本练习 [@problem_id:3464669] 将指导你完成这一关键的数据分析步骤，通过对多个半径处的合成数据进行拟合，来重建无限远处的波形。这个实践将模拟从原始数值结果到可供物理分析的最终引力波信号的完整过程。", "problem": "给定一个用于从双黑洞 (BBH) 模拟中提取引力波应变的简化但科学上一致的模型，该模型源自数值相对论 (NR)。在大的提取半径处，于半径为 $R$ 的坐标球面上测得的应变具有一个与领头阶辐射衰减一致的渐近展开，其形式可简写为\n$$\nh(t,R) = h_\\infty(t) + \\frac{c(t)}{R} + \\frac{d(t)}{R^2} + \\mathcal{O}\\!\\left(\\frac{1}{R^3}\\right),\n$$\n其中 $h_\\infty(t)$ 是在零无穷远处的应变，$c(t)$ 包含了按 $1/R$ 标度的次领头阶辐射和规范贡献，$d(t)$ 则捕捉了按 $1/R^2$ 标度的更高阶有限半径效应。目标是实现一个仅使用领头阶模型 $h(t,R) \\approx h_\\infty(t) + c(t)/R$ 的时间局域外推方案，并根据已知的真实值 $h_\\infty(t)$ 来量化外推残差。使用纯粹的数学和算法操作来构建应变数据并评估方法性能。\n\n按如下方式构建合成的、确定性的应变数据。定义一个在零无穷远处的无量纲应变\n$$\nh_\\infty(t) = A(t)\\cos\\big(\\phi(t)\\big),\n$$\n其振幅 $A(t)$ 模拟了旋近增长和铃振衰减，\n$$\nA(t) = \\begin{cases}\nA_0 \\big(1 + \\eta t\\big),  0 \\le t \\le t_m, \\\\\nA_0 \\big(1 + \\eta t_m\\big) \\exp\\big(-\\lambda (t - t_m)\\big),  t  t_m,\n\\end{cases}\n$$\n其相位 $\\phi(t)$ 模拟了啁啾，\n$$\n\\phi(t) = \\phi_0 + \\omega_0 t + \\gamma t^2.\n$$\n令 $c(t)$ 和 $d(t)$ 为相干的次领头项，\n$$\nc(t) = \\alpha_c A(t)\\cos\\big(\\phi(t) + \\delta_c\\big), \\quad d(t) = \\alpha_d A(t)\\cos\\big(\\phi(t) + \\delta_d\\big).\n$$\n对于每个提取半径 $R_i$，通过以下方式构建有限半径应变时间序列 $h_i(t)$：\n$$\nh_i(t) = h_\\infty(t) + \\frac{c(t)}{R_i} + \\frac{d(t)}{R_i^2} + \\epsilon \\sin\\big(2\\pi f_i t\\big),\n$$\n其中 $f_i$ 是每个半径对应的不同确定性频率，$\\epsilon$ 是一个确定性的小振幅。所有量均为无量纲。\n\n在每个时间样本 $t_k$ 处，通过对所有半径 $\\{R_i\\}$ 上的值 $\\{h_i(t_k)\\}$ 进行模型 $h(t,R) \\approx h_\\infty(t) + c(t)/R$ 的线性最小二乘拟合，来估计 $\\hat{h}_\\infty(t_k)$ 和 $\\hat{c}(t_k)$，拟合时忽略 $1/R^2$ 及更高阶的项。此外，通过选取在最大半径处测得的应变，构建一个朴素近似 $h_{\\max R}(t)$。\n\n定义以下度量指标，以在公共的均匀时间网格 $\\{t_k\\}_{k=1}^N$ 上量化相对于真实值 $h_\\infty(t)$ 的外推残差：\n- 相对均方根误差，\n$$\n\\mathrm{relL2}(x,y) = \\frac{\\sqrt{\\sum_{k=1}^N \\big(x_k - y_k\\big)^2}}{\\sqrt{\\sum_{k=1}^N x_k^2}}.\n$$\n- 失配，\n$$\n\\mathrm{mismatch}(x,y) = 1 - \\frac{\\sum_{k=1}^N x_k y_k}{\\sqrt{\\sum_{k=1}^N x_k^2}\\sqrt{\\sum_{k=1}^N y_k^2}}.\n$$\n- 在所有半径和时间上拟合后的归一化残差均方根，\n$$\n\\mathrm{residRMS} = \\frac{\\sqrt{\\sum_{i,k} \\big[h_i(t_k) - \\big(\\hat{h}_\\infty(t_k) + \\hat{c}(t_k)/R_i\\big)\\big]^2}}{\\sqrt{\\sum_k h_\\infty(t_k)^2}}.\n$$\n\n使用以下在所有测试用例中共享的固定的、确定性的选择来实现上述过程：\n- 使用一个均匀时间网格 $t_k$，在区间 $[0,1)$ 秒上取 $N = 2048$ 个样本，即 $t_k = k/N$ for $k = 0,1,\\dots,N-1$。\n- 使用 $A_0 = 1$、$\\eta = 1.5$、$t_m = 0.7$、$\\lambda = 8$、$\\phi_0 = 0$、$\\omega_0 = 50$、$\\gamma = 80$、$\\delta_c = 0.3$ 和 $\\delta_d = -0.6$。\n- 对于每个半径索引 $i$（第一个半径的索引 $i=0$），设置 $f_i = 3 + i$。\n\n你的程序必须为每个测试用例计算四个浮点数：\n- $\\mathrm{relL2}\\big(h_\\infty, \\hat{h}_\\infty\\big)$，\n- $\\mathrm{relL2}\\big(h_\\infty, h_{\\max R}\\big)$，\n- $\\mathrm{mismatch}\\big(h_\\infty, \\hat{h}_\\infty\\big)$，\n- $\\mathrm{residRMS}$。\n\n设计一个包含三个用例的测试套件：\n- 用例1（常规顺利路径）：$\\{R_i\\} = [100, 150, 200, 300, 400]$，$\\alpha_c = 0.25$，$\\alpha_d = 0.05$，$\\epsilon = 10^{-4}$。\n- 用例2（边界条件，使用最少数量的半径且无高阶项或噪声）：$\\{R_i\\} = [100, 300]$，$\\alpha_c = 0.30$，$\\alpha_d = 0$，$\\epsilon = 0$。\n- 用例3（边缘用例，使用更小的半径、更强的高阶项污染和更大的确定性噪声）：$\\{R_i\\} = [50, 75, 100]$，$\\alpha_c = 0.20$，$\\alpha_d = 0.20$，$\\epsilon = 5\\times 10^{-4}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果作为一个嵌套列表贡献其四个计算出的浮点数，顺序与上文规定相同。例如，输出格式必须为 $[\\,[r_{11},r_{12},r_{13},r_{14}],\\,[r_{21},r_{22},r_{23},r_{24}],\\,[r_{31},r_{32},r_{33},r_{34}]\\,]$ 的形式。\n\n所有量均为无量纲，不需要物理单位。角度以弧度为单位。将所有计算出的数字表示为十进制浮点数。程序必须能独立运行，且不得读取输入或写入文件。", "solution": "所提出的问题是一个定义明确的数值数据分析计算练习，专门针对数值相对论中的一个常见任务：将在有限半径处计算出的引力波信号外推至零无穷远。所有提供的方程、参数和程序都与该领域使用的简化模型在科学上保持一致，在数学上是合理的，并且在计算上是可行的。该问题是自洽且无歧义的。因此，该问题被认为是有效的，并将构建一个解决方案。\n\n核心任务是在几个有限的提取半径上生成合成的引力波数据，然后使用一个线性外推模型来估计在零无穷远处的波形。之后，将该外推的准确性与已知的真实值进行量化比较。\n\n首先，我们基于所提供的解析模型构建必要的时域波形。定义一个在区间 $[0, 1)$ 上的均匀时间网格 $\\{t_k\\}_{k=0}^{N-1}$，其中包含 $N = 2048$ 个点，使得 $t_k = k/N$。\n\n在零无穷远处的真实值波形 $h_\\infty(t)$ 由振幅 $A(t)$ 和相位 $\\phi(t)$ 定义。振幅 $A(t)$ 模拟了双黑洞并合的旋近和铃振：\n$$\nA(t) = \\begin{cases}\nA_0 \\big(1 + \\eta t\\big),  0 \\le t \\le t_m \\\\\nA_0 \\big(1 + \\eta t_m\\big) \\exp\\big(-\\lambda (t - t_m)\\big),  t  t_m\n\\end{cases}\n$$\n相位 $\\phi(t)$ 模拟了信号的“啁啾”，即频率随时间增加：\n$$\n\\phi(t) = \\phi_0 + \\omega_0 t + \\gamma t^2\n$$\n使用给定的参数 $A_0 = 1$、$\\eta = 1.5$、$t_m = 0.7$、$\\lambda = 8$、$\\phi_0 = 0$、$\\omega_0 = 50$ 和 $\\gamma = 80$，我们计算 $A(t_k)$、$_phi(t_k)$ 的时间序列，并随后计算真实值波形 $h_\\infty(t_k) = A(t_k)\\cos(\\phi(t_k))$。\n\n接下来，我们生成次领头贡献 $c(t)$ 和 $d(t)$，它们代表了在有限半径处污染信号的物理效应和规范效应。它们被建模为与主信号相干，但具有相位偏移 $\\delta_c$ 和 $\\delta_d$：\n$$\nc(t) = \\alpha_c A(t)\\cos\\big(\\phi(t) + \\delta_c\\big)\n$$\n$$\nd(t) = \\alpha_d A(t)\\cos\\big(\\phi(t) + \\delta_d\\big)\n$$\n这里，$\\delta_c = 0.3$ 和 $\\delta_d = -0.6$，而 $\\alpha_c$ 和 $\\alpha_d$ 对每个测试用例是特定的。\n\n对于给定集合 $\\{R_i\\}$ 中的每个提取半径 $R_i$，我们组装合成的应变数据 $h_i(t)$。它包括真实值、按 $1/R_i$ 的幂缩放的次领头项，以及一个对每个半径都唯一的确定性高频噪声项：\n$$\nh_i(t_k) = h_\\infty(t_k) + \\frac{c(t_k)}{R_i} + \\frac{d(t_k)}{R_i^2} + \\epsilon \\sin\\big(2\\pi f_i t_k\\big)\n$$\n噪声频率为 $f_i = 3 + i$，其中 $i$ 是半径的从零开始的索引。参数 $\\epsilon$、$\\{R_i\\}$、$\\alpha_c$ 和 $\\alpha_d$ 均针对三个测试用例中的每一个提供。\n\n下一步是外推过程。在每个时间样本 $t_k$，我们有一组在不同半径 $\\{R_i\\}$ 上的测量值 $\\{h_i(t_k)\\}$。我们将一个形式为 $y = a + bx$ 的线性模型拟合到这些数据上，其中 $y_i = h_i(t_k)$，自变量是 $x_i = 1/R_i$，待定系数是 $a = \\hat{h}_\\infty(t_k)$ 和 $b = \\hat{c}(t_k)$。这是一个线性最小二乘问题。对于一组 $M$ 个半径，在每个时间 $t_k$ 的问题是找到 $(\\hat{h}_\\infty, \\hat{c})$ 以最小化 $\\sum_{i=1}^M [h_i(t_k) - (\\hat{h}_\\infty + \\hat{c}/R_i)]^2$。对所有 $k=0, \\dots, N-1$ 执行此操作，以获得外推波形 $\\hat{h}_\\infty(t)$ 和次领头项 $\\hat{c}(t)$ 的完整时间序列。此外，一个朴素的波形近似 $h_{\\max R}(t)$ 被取为从最大可用半径获得的数据，即 $h_{\\max R}(t_k) = h_i(t_k)$，其中 $R_i = \\max(\\{R_j\\})$。\n\n最后，我们计算四个度量指标来评估外推的性能。\n1.  外推波形的相对L2误差：$\\mathrm{relL2}\\big(h_\\infty, \\hat{h}_\\infty\\big) = \\frac{\\sqrt{\\sum_{k} (h_\\infty(t_k) - \\hat{h}_\\infty(t_k))^2}}{\\sqrt{\\sum_{k} h_\\infty(t_k)^2}}$。该指标衡量整体的振幅差异。\n2.  朴素近似波形的相对L2误差：$\\mathrm{relL2}\\big(h_\\infty, h_{\\max R}\\big) = \\frac{\\sqrt{\\sum_{k} (h_\\infty(t_k) - h_{\\max R}(t_k))^2}}{\\sqrt{\\sum_{k} h_\\infty(t_k)^2}}$。该指标作为一个比较基准。\n3.  外推波形的失配：$\\mathrm{mismatch}\\big(h_\\infty, \\hat{h}_\\infty\\big) = 1 - \\frac{\\sum_{k} h_\\infty(t_k) \\hat{h}_\\infty(t_k)}{\\sqrt{\\sum_k h_\\infty(t_k)^2}\\sqrt{\\sum_k \\hat{h}_\\infty(t_k)^2}}$。该指标对信号之间的相位误差很敏感。\n4.  拟合的归一化残差均方根：$\\mathrm{residRMS} = \\frac{\\sqrt{\\sum_{i,k} [h_i(t_k) - (\\hat{h}_\\infty(t_k) + \\hat{c}(t_k)/R_i)]^2}}{\\sqrt{\\sum_k h_\\infty(t_k)^2}}$。该量度衡量了线性模型 $h_\\infty+c/R$ 对包含 $1/R^2$ 项和噪声的完整数据集的描述程度。值越大表明模型设定存在严重不当。\n\n对三个指定的测试用例中的每一个都执行这些计算，并收集每个用例得到的四个标量度量指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave extrapolation problem for three test cases.\n    \"\"\"\n\n    # Global fixed parameters\n    N = 2048\n    A0 = 1.0\n    eta = 1.5\n    t_m = 0.7\n    lmbda = 8.0  # 'lambda' is a reserved keyword\n    phi0 = 0.0\n    omega0 = 50.0\n    gamma = 80.0\n    delta_c = 0.3\n    delta_d = -0.6\n\n    # Time grid\n    t = np.arange(N) / N\n\n    # Construct ground truth waveform h_infty(t)\n    # Amplitude A(t)\n    A_t_inspiral = A0 * (1 + eta * t)\n    A_t_ringdown = A0 * (1 + eta * t_m) * np.exp(-lmbda * (t - t_m))\n    A_t = np.where(t = t_m, A_t_inspiral, A_t_ringdown)\n    \n    # Phase phi(t)\n    phi_t = phi0 + omega0 * t + gamma * t**2\n    \n    # Ground truth strain h_infty(t)\n    h_inf_t = A_t * np.cos(phi_t)\n    norm_h_inf = np.linalg.norm(h_inf_t)\n\n    # Test cases\n    test_cases = [\n        {\n            \"R_vals\": np.array([100, 150, 200, 300, 400]),\n            \"alpha_c\": 0.25,\n            \"alpha_d\": 0.05,\n            \"epsilon\": 1e-4,\n        },\n        {\n            \"R_vals\": np.array([100, 300]),\n            \"alpha_c\": 0.30,\n            \"alpha_d\": 0.0,\n            \"epsilon\": 0.0,\n        },\n        {\n            \"R_vals\": np.array([50, 75, 100]),\n            \"alpha_c\": 0.20,\n            \"alpha_d\": 0.20,\n            \"epsilon\": 5e-4,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        R_vals = case[\"R_vals\"]\n        alpha_c = case[\"alpha_c\"]\n        alpha_d = case[\"alpha_d\"]\n        epsilon = case[\"epsilon\"]\n\n        # 1. Generate synthetic strain data for all radii\n        c_t = alpha_c * A_t * np.cos(phi_t + delta_c)\n        d_t = alpha_d * A_t * np.cos(phi_t + delta_d)\n        \n        num_radii = len(R_vals)\n        H_data = np.zeros((num_radii, N))\n\n        for i, R_i in enumerate(R_vals):\n            f_i = 3.0 + i\n            noise_term = epsilon * np.sin(2 * np.pi * f_i * t)\n            H_data[i, :] = h_inf_t + c_t / R_i + d_t / R_i**2 + noise_term\n\n        # 2. Perform extrapolation using linear least squares\n        # The independent variable for the fit is 1/R\n        x_fit = 1 / R_vals\n        \n        # np.polyfit fits for each column of y if y is 2D.\n        # H_data is (num_radii, N), x_fit is (num_radii,).\n        # This will perform N fits, one for each time step.\n        # The result 'coeffs' will have shape (2, N).\n        # coeffs[0, :] will be the slopes (c_hat_t)\n        # coeffs[1, :] will be the intercepts (h_inf_hat_t)\n        coeffs = np.polyfit(x_fit, H_data, 1)\n        c_hat_t = coeffs[0, :]\n        h_inf_hat_t = coeffs[1, :]\n\n        # 3. Get the naive approximation from the largest radius\n        idx_max_R = np.argmax(R_vals)\n        h_maxR_t = H_data[idx_max_R, :]\n\n        # 4. Calculate the performance metrics\n        # Metric 1: relL2(h_infty, h_inf_hat)\n        relL2_h_inf_hat = np.linalg.norm(h_inf_t - h_inf_hat_t) / norm_h_inf\n\n        # Metric 2: relL2(h_infty, h_maxR)\n        relL2_h_maxR = np.linalg.norm(h_inf_t - h_maxR_t) / norm_h_inf\n\n        # Metric 3: mismatch(h_infty, h_inf_hat)\n        norm_h_inf_hat = np.linalg.norm(h_inf_hat_t)\n        inner_product = np.dot(h_inf_t, h_inf_hat_t)\n        mismatch_h_inf_hat = 1.0 - inner_product / (norm_h_inf * norm_h_inf_hat)\n\n        # Metric 4: residRMS\n        # Reconstruct the fitted model values at all radii and times\n        # H_fit[i, k] = h_inf_hat_t[k] + c_hat_t[k] / R_vals[i]\n        H_fit = h_inf_hat_t[np.newaxis, :] + c_hat_t[np.newaxis, :] / R_vals[:, np.newaxis]\n        \n        # Sum of squared residuals over all radii and times\n        total_residual_sq_sum = np.sum((H_data - H_fit)**2)\n        residRMS_val = np.sqrt(total_residual_sq_sum) / norm_h_inf\n        \n        case_results = [\n            relL2_h_inf_hat,\n            relL2_h_maxR,\n            mismatch_h_inf_hat,\n            residRMS_val,\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format requires nested lists, so we format each sublist.\n    formatted_results = [f\"[{','.join(f'{x:.17g}' for x in res)}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3464669"}]}