{"hands_on_practices": [{"introduction": "这个练习介绍引力波数据分析中的一项核心技能：计算两个波形模型之间的“失配”（mismatch）。失配度量了在探测器噪声存在的情况下，两个信号的可区分程度，这个概念是参数估计和物理理论检验的基础。通过亲手实现这一计算[@problem_id:3488789]，你将获得处理噪声加权内积的实践经验，并理解波形模型的细微差异是如何被测量的。", "problem": "考虑两个频域旋进–并合–铃振（IMR）引力波模型，记为 $h_1(f)$ 和 $h_2(f)$，它们描述了一个准圆形、非进动的双星系统。该系统的组分质量分别为 $m_1$ 和 $m_2$（以太阳质量为单位），无量纲的对齐自旋分别为 $\\chi_1$ 和 $\\chi_2$。设两个信号 $a$ 和 $b$ 之间的内积定义为\n$$\n(a|b) = 4\\,\\Re \\int_0^\\infty \\frac{\\tilde a(f)\\,\\tilde b^*(f)}{S_n(f)}\\,df,\n$$\n其中 $S_n(f)$ 是探测器的单边噪声功率谱密度，波浪号表示傅里叶变换。$h_1$ 和 $h_2$ 之间的归一化重叠在恒定相移 $\\phi$ 和时间平移 $t$ 上进行最大化，其表达式为\n$$\n\\mathcal{O} = \\max_{\\phi,t} \\frac{\\langle h_1|h_2\\rangle}{\\sqrt{\\langle h_1|h_1\\rangle\\,\\langle h_2|h_2\\rangle}},\n$$\n失配则为 $\\mathcal{M} = 1 - \\mathcal{O}$。\n\n您将使用以下具有物理动机的自洽设置，为四个测试用例计算 $\\mathcal{M}$：\n\n1. 频率网格和采样：\n   - 使用采样率 $f_{\\mathrm{samp}} = 4096$ Hz 和离散傅里叶变换长度 $N = 16384$。\n   - 频率分辨率为 $\\Delta f = f_{\\mathrm{samp}}/N$，奈奎斯特频率为 $f_{\\mathrm{Nyq}} = f_{\\mathrm{samp}}/2$。\n   - 定义一个低频截断 $f_{\\mathrm{low}} = 20$ Hz；对于 $f  f_{\\mathrm{low}}$，波形振幅必须设置为零。\n\n2. 噪声功率谱密度：\n   - 使用以下对 Advanced Laser Interferometer Gravitational-Wave Observatory (Advanced LIGO) 设计灵敏度曲线的解析、正定近似：\n     $$\n     S_n(f) = S_0\\left[\\left(\\frac{f_0}{f}\\right)^4 + 1 + \\left(\\frac{f}{f_0}\\right)^2\\right],\n     $$\n     其中 $S_0 = 10^{-46}$ 且 $f_0 = 100$ Hz。此形式捕捉了低频处的上升、$f_0$ 附近的最小值以及高频处的性能退化。\n\n3. IMR 模型：\n   - 通用定义：\n     - 使用 $M_\\odot = 4.925491\\times 10^{-6}$ s 将太阳质量转换为几何时间单位，因此以秒为单位的总质量为 $M = (m_1+m_2)\\,M_\\odot$。\n     - 对称质量比为 $\\eta = \\frac{m_1 m_2}{(m_1+m_2)^2}$。\n     - 有效对齐自旋为 $\\chi_{\\mathrm{eff}} = \\frac{m_1 \\chi_1 + m_2 \\chi_2}{m_1+m_2}$。\n     - 顺行 Kerr 最内稳定圆轨道 (ISCO) 半径（以 $M$ 为单位）为\n       $$\n       r_{\\mathrm{ISCO}} = 3 + Z_2 - \\mathrm{sign}(a)\\,\\sqrt{(3 - Z_1)\\left(3 + Z_1 + 2 Z_2\\right)},\n       $$\n       其中 $a = \\chi_{\\mathrm{eff}}$，\n       $$\n       Z_1 = 1 + (1-a^2)^{1/3}\\left[(1+a)^{1/3} + (1-a)^{1/3}\\right],\\quad\n       Z_2 = \\sqrt{3a^2 + Z_1^2}.\n       $$\n       对应的轨道角频率为\n       $$\n       \\Omega_{\\mathrm{ISCO}} = \\frac{1}{M\\left(r_{\\mathrm{ISCO}}^{3/2} + a\\right)},\n       $$\n       引力波 ISCO 频率为 $f_{\\mathrm{ISCO}} = \\Omega_{\\mathrm{ISCO}}/(2\\pi)$。对于非自旋情况，使用 $a=0$。\n   - 振幅模型（适用于两种模型，但截断选择不同）：\n     $$\n     A(f) = f^{-7/6}\\,\\exp\\left[-\\left(\\frac{f}{f_{\\mathrm{cut}}}\\right)^p\\right],\n     $$\n     其中 $p0$。为模型1选择 $p=4$，为模型2选择 $p=3$。这种指数锥削使旋进振幅正则化，并模拟并合–铃振阶段的抑制。\n   - 相位模型：\n     - 使用领头阶后牛顿旋进相标度，\n       $$\n       \\psi_{\\mathrm{LO}}(f) = \\frac{3}{128\\,\\eta}\\left(\\pi M f\\right)^{-5/3},\n       $$\n       它捕捉了主要的啁啾行为。\n     - 模型1的相位：$\\psi_1(f) = \\psi_{\\mathrm{LO}}(f)$。\n     - 模型2的相位：$\\psi_2(f) = \\psi_{\\mathrm{LO}}(f) + \\delta\\left(\\frac{f}{f_{\\mathrm{ISCO}}^{\\mathrm{(NS)}}}\\right)^2$，其中 $f_{\\mathrm{ISCO}}^{\\mathrm{(NS)}}$ 是在 $a=0$ 的条件下计算的，$\\delta = 0.1$ 弧度，这引入了一个具有物理动机的小的高频修正，以表示并合附近的模型差异。\n   - 截断频率：\n     - 模型1使用依赖于自旋的截断 $f_{\\mathrm{cut}} = 1.3\\,f_{\\mathrm{ISCO}}(a=\\chi_{\\mathrm{eff}})$。\n     - 模型2使用不依赖于自旋的截断 $f_{\\mathrm{cut}} = 1.3\\,f_{\\mathrm{ISCO}}(a=0)$。\n\n   于是，频域波形为\n   $$\n   h_1(f) = A_1(f)\\,e^{i\\psi_1(f)},\\qquad h_2(f) = A_2(f)\\,e^{i\\psi_2(f)}.\n   $$\n\n4. 对相位和时间的最大化：\n   - 恒定相移 $\\phi$ 将 $h_2(f)$ 乘以 $e^{i\\phi}$；时间平移 $t$ 将其乘以 $e^{i2\\pi f t}$。\n   - 证明对 $\\phi$ 的最大化会得到复数相关的模，而对 $t$ 的最大化则对应于寻找单边、噪声加权的互谱的离散傅里叶反变换的最大模。在数值上，使用均匀频率网格 $f_k = k\\,\\Delta f$，用离散和来近似积分。对于时间最大化，在与 $f_{\\mathrm{samp}}$ 和 $N$ 相关的紧凑时间网格上计算离散傅里叶反变换，并取其最大模。\n\n5. 计算细节：\n   - 内积应通过在 $f\\in[0,f_{\\mathrm{Nyq}}]$ 上的黎曼和来近似，对于 $f", "solution": "用户提供了一个引力波数据分析领域的问题，该问题要求计算两种唯象的旋进-并合-铃振 (IMR) 波形模型之间的失配。在尝试求解之前，需要根据严格的科学和逻辑标准对该问题进行验证。\n\n### 步骤1：问题验证\n\n问题陈述提供了一套全面且自洽的定义、方程和参数。\n- **已知条件**：\n    - **模型**：两个频域模型 $h_1(f)$ 和 $h_2(f)$，用于描述具有参数 $(m_1, m_2, \\chi_1, \\chi_2)$ 的非进动双星。\n    - **内积**：$(a|b) = 4\\,\\Re \\int_0^\\infty \\frac{\\tilde a(f)\\,\\tilde b^*(f)}{S_n(f)}\\,df$。\n    - **重叠和失配**：$\\mathcal{O} = \\max_{\\phi,t} \\frac{\\langle h_1|h_2\\rangle}{\\sqrt{\\langle h_1|h_1\\rangle\\,\\langle h_2|h_2\\rangle}}$，以及 $\\mathcal{M} = 1 - \\mathcal{O}$。\n    - **数值设置**：$f_{\\mathrm{samp}} = 4096$ Hz, $N = 16384$, $\\Delta f = f_{\\mathrm{samp}}/N$, $f_{\\mathrm{Nyq}} = f_{\\mathrm{samp}}/2$, $f_{\\mathrm{low}} = 20$ Hz。\n    - **噪声功率谱密度 (PSD)**：$S_n(f) = S_0[ (f_0/f)^4 + 1 + (f/f_0)^2 ]$，其中 $S_0 = 10^{-46}$ 且 $f_0 = 100$ Hz。\n    - **物理常数和定义**：$M_\\odot = 4.925491\\times 10^{-6}$ s。提供了总质量 $M$、对称质量比 $\\eta$ 和有效自旋 $\\chi_{\\mathrm{eff}}$ 的定义。\n    - **ISCO 频率**：给出了一套基于 Kerr 度规 ISCO 半径计算 $f_{\\mathrm{ISCO}}$ 的完整方程。\n    - **波形模型**：为两个模型定义了特定的振幅 $A(f)$ 和相位 $\\psi(f)$ 的函数形式，包括参数选择（模型1为 $p=4$，模型2为 $p=3$）以及相位修正（$\\delta = 0.1$）和截断频率定义的差异。\n    - **最大化过程**：提供了关于如何对相位和时间平移最大化重叠的清晰物理和数值描述，正确地将该过程识别为对噪声加权的互谱进行离散傅里叶反变换 (IDFT)。\n    - **测试用例**：指定了四个不同的、具有物理意义的测试用例。\n\n- **验证结论**：\n    1.  **科学依据充分**：该问题牢固地植根于广义相对论和引力波数据分析的原理。内积、噪声功率谱密度、波形匹配以及后牛顿/唯象模型等概念都是该领域的标准。所提供的公式，如 Kerr ISCO 和 LIGO 噪声曲线的公式，都是已建立且具有物理动机的。\n    2.  **适定性**：该问题在数学和计算上都是明确定义的。所有必要的常数、函数和参数都已提供，从而为每个测试用例导出一个唯一的数值结果。\n    3.  **客观性**：问题陈述使用精确、客观的语言，没有歧义或主观陈述。\n    4.  **缺陷**：该问题没有任何不合格的缺陷。它在科学上是合理的，完全可形式化、完整、可行、结构良好、非平凡且可验证。\n\n- **结论**：该问题是有效的。将着手开发解决方案。\n\n### 步骤2：解法开发\n\n问题的核心是计算失配 $\\mathcal{M} = 1 - \\mathcal{O}$。这需要计算最大化重叠 $\\mathcal{O}$。重叠定义为：\n$$\n\\mathcal{O} = \\frac{\\max_{\\phi, t} (h_1 | h_2')}{\\sqrt{(h_1|h_1)(h_2|h_2)}}\n$$\n其中 $h_2'(f) = h_2(f) e^{i(2\\pi f t + \\phi)}$。\n\n**归一化因子（分母）：**\n分母包含两个波形的范数。对于一个波形 $h$，其范数的平方由下式给出：\n$$\n(h|h) = 4\\Re \\int_0^\\infty \\frac{h(f) h^*(f)}{S_n(f)} df = 4 \\int_0^\\infty \\frac{|h(f)|^2}{S_n(f)} df\n$$\n这些积分将通过频率网格上的离散黎曼和来近似：\n$$\n(h|h) \\approx 4 \\sum_{k=k_{\\text{low}}}^{k_{\\text{Nyq}}} \\frac{|h(f_k)|^2}{S_n(f_k)} \\Delta f\n$$\n其中 $f_k = k \\Delta f$，$k_{\\text{low}}$ 是对应于 $f_{\\text{low}}$ 的索引。\n\n**最大化内积（分子）：**\n分子需要对内积 $(h_1 | h_2')$ 在时间平移 $t$ 和相位平移 $\\phi$ 上进行最大化。\n$$\n(h_1 | h_2') = 4\\Re \\int_0^\\infty \\frac{h_1(f) (h_2(f)e^{i(2\\pi f t + \\phi)})^*}{S_n(f)} df = 4\\Re \\left[ e^{-i\\phi} \\int_0^\\infty \\frac{h_1(f)h_2^*(f)}{S_n(f)} e^{-i2\\pi f t} df \\right]\n$$\n令复数量 $C(t) = \\int_0^\\infty \\frac{h_1(f)h_2^*(f)}{S_n(f)} e^{-i2\\pi f t} df$。需要最大化的表达式是 $4\\Re[e^{-i\\phi} C(t)]$。对于任意给定的 $t$，通过选择与 $C(t)$ 具有相同相位的 $e^{-i\\phi}$，可以对 $\\phi$ 进行最大化，得到最大值为 $4|C(t)|$。然后我们必须对 $t$ 最大化该值。最终最大化的内积为 $4 \\max_t |C(t)|$。\n\n函数 $C(t)$ 是单边、噪声加权的互谱 $Q(f) = \\frac{h_1(f)h_2^*(f)}{S_n(f)}$ 的傅里叶反变换。在计算上，我们可以通过计算离散谱 $Q_k = Q(f_k)$ 的离散傅里叶反变换 (IDFT) 并找到所得时间序列的最大模来求得 $\\max_t |C(t)|$。\n单边谱 $Q_k$（对于 $k=0, \\dots, N/2$）的 IDFT 可以通过创建一个长度为 $N$ 的数组，将 $Q_k$ 放入前 $N/2+1$ 个元素，其余补零，然后应用 IDFT 来实现。IDFT 与连续积分之间的关系需要一个缩放因子。\n$$\n\\max_t |C(t)| \\approx \\max_n \\left| \\Delta f \\sum_{k=0}^{N/2} Q_k e^{-i2\\pi kn/N} \\right|\n$$\n`numpy` 等库中的标准 `ifft` 计算 $(1/N) \\sum X_k e^{i2\\pi kn/N}$。为了匹配我们想要的计算，我们必须将 `ifft(X)` 的输出乘以 $N \\cdot \\Delta f = f_{\\mathrm{samp}}$。注意指数中符号的差异；这对应于时间反转，它不影响绝对值的最大值。\n\n**实现步骤：**\n1.  定义一个频率网格 $f_k$，从 $0$ 到 $f_{\\mathrm{Nyq}}$，间距为 $\\Delta f$。\n2.  对于每个测试用例 $(m_1, m_2, \\chi_1, \\chi_2)$：\n    a. 实现一个基于所提供的 Kerr 公式计算 $f_{\\mathrm{ISCO}}$ 的函数。\n    b. 实现一个根据各自不同的振幅和相位规定生成波形 $h_1(f)$ 和 $h_2(f)$ 的函数，确保对于 $f  f_{\\mathrm{low}}$，波形为零。\n    c. 在频率网格上计算噪声功率谱密度 $S_n(f)$。\n    d. 使用黎曼求和计算范数 $(h_1|h_1)$ 和 $(h_2|h_2)$。\n    e. 计算噪声加权的互谱 $Q(f_k)$。\n    f. 对一个单边 $Q(f_k)$ 数组（填充至长度 $N$）使用 `numpy.fft.ifft`，并乘以 $f_{\\mathrm{samp}}$ 得到一个时间序列。\n    g. 找到此时间序列的最大绝对值 `max_corr`。\n    h. 计算重叠 $\\mathcal{O} = \\frac{4 \\cdot \\text{max\\_corr}}{\\sqrt{(h_1|h_1)(h_2|h_2)}}$。因子 $4$ 会抵消，因此 $\\mathcal{O} = \\frac{\\text{max\\_corr}}{\\sqrt{(\\text{norm}_1/4)(\\text{norm}_2/4)}}$。\n    i. 计算并存储失配 $\\mathcal{M} = 1 - \\mathcal{O}$。\n3.  按规定格式化失配值列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mismatch between two IMR gravitational-wave models\n    for a set of test cases.\n    \"\"\"\n\n    # --- Physical and Numerical Constants ---\n    M_SUN_S = 4.925491e-6  # Solar mass in seconds (G=c=1 units)\n    F_SAMP = 4096.0         # Sampling rate in Hz\n    N = 16384               # Number of points in the DFT\n    F_LOW = 20.0            # Lower frequency cutoff in Hz\n    S0 = 1e-46              # Noise PSD amplitude\n    F0 = 100.0              # Noise PSD characteristic frequency in Hz\n    DELTA_PHASE = 0.1       # Phase correction parameter in radians\n\n    # --- Helper Functions ---\n\n    def get_isco_freq(m1, m2, spin_a):\n        \"\"\"Calculates the gravitational-wave ISCO frequency.\"\"\"\n        if not -1.0 = spin_a = 1.0:\n            raise ValueError(\"Spin parameter 'a' must be between -1 and 1.\")\n\n        total_mass_sec = (m1 + m2) * M_SUN_S\n\n        if np.isclose(spin_a, 0):\n            r_isco = 6.0\n        else:\n            a_sq = spin_a**2\n            z1 = 1.0 + (1.0 - a_sq)**(1/3) * ((1.0 + spin_a)**(1/3) + (1.0 - spin_a)**(1/3))\n            z2 = np.sqrt(3.0 * a_sq + z1**2)\n            \n            # Ensure argument of sqrt is non-negative to avoid domain errors\n            sqrt_arg = (3.0 - z1) * (3.0 + z1 + 2.0 * z2)\n            r_isco = 3.0 + z2 - np.sign(spin_a) * np.sqrt(max(0, sqrt_arg))\n\n        omega_isco = 1.0 / (total_mass_sec * (r_isco**1.5 + spin_a))\n        f_isco = omega_isco / (2.0 * np.pi)\n        return f_isco\n\n    def get_ligo_psd(freqs):\n        \"\"\"Calculates the analytic Advanced LIGO noise power spectral density.\"\"\"\n        psd = np.full_like(freqs, np.inf)\n        valid_f_mask = freqs > 0\n        f_valid = freqs[valid_f_mask]\n        f_ratio = F0 / f_valid\n        psd[valid_f_mask] = S0 * (f_ratio**4 + 1.0 + (f_valid / F0)**2)\n        return psd\n\n    def generate_waveform(freqs, m1, m2, chi1, chi2, model_type):\n        \"\"\"Generates a frequency-domain waveform model.\"\"\"\n        total_mass_sec = (m1 + m2) * M_SUN_S\n        eta = (m1 * m2) / (m1 + m2)**2\n        chi_eff = (m1 * chi1 + m2 * chi2) / (m1 + m2)\n\n        f_isco_spin = get_isco_freq(m1, m2, chi_eff)\n        f_isco_ns = get_isco_freq(m1, m2, 0.0)\n        \n        if model_type == 1:\n            p, f_cut = 4.0, 1.3 * f_isco_spin\n        elif model_type == 2:\n            p, f_cut = 3.0, 1.3 * f_isco_ns\n        else:\n            raise ValueError(\"model_type must be 1 or 2\")\n\n        h = np.zeros_like(freqs, dtype=np.complex128)\n        \n        # Only compute for f > 0 to avoid singularities\n        mask = freqs > 0\n        f_valid = freqs[mask]\n        \n        # Amplitude\n        amp = f_valid**(-7.0/6.0) * np.exp(-(f_valid / f_cut)**p)\n        \n        # Phase\n        psi_lo = (3.0 / (128.0 * eta)) * (np.pi * total_mass_sec * f_valid)**(-5.0/3.0)\n        psi = psi_lo\n        if model_type == 2:\n            psi_corr = DELTA_PHASE * (f_valid / f_isco_ns)**2\n            psi += psi_corr\n            \n        h[mask] = amp * np.exp(1j * psi)\n        \n        # Apply low-frequency cutoff\n        h[freqs  F_LOW] = 0.0\n        \n        return h\n\n    def calculate_mismatch(params):\n        \"\"\"Computes the mismatch for a single binary system.\"\"\"\n        m1, m2, chi1, chi2 = params\n        \n        delta_f = F_SAMP / N\n        freqs = np.arange(N / 2 + 1) * delta_f\n\n        h1 = generate_waveform(freqs, m1, m2, chi1, chi2, model_type=1)\n        h2 = generate_waveform(freqs, m1, m2, chi1, chi2, model_type=2)\n        Sn = get_ligo_psd(freqs)\n\n        # Denominator of overlap: norm of each waveform\n        integrand1 = np.divide(np.abs(h1)**2, Sn, where=Sn!=0, out=np.zeros_like(Sn))\n        integrand2 = np.divide(np.abs(h2)**2, Sn, where=Sn!=0, out=np.zeros_like(Sn))\n        \n        norm1_sq = np.sum(integrand1) * delta_f\n        norm2_sq = np.sum(integrand2) * delta_f\n\n        # Numerator of overlap: maximized over time and phase\n        cross_spectrum = np.divide(h1 * np.conj(h2), Sn, where=Sn!=0, out=np.zeros_like(Sn, dtype=np.complex128))\n    \n        X = np.zeros(N, dtype=np.complex128)\n        X[:len(cross_spectrum)] = cross_spectrum\n        \n        # IFFT scaling: multiply by N * df = f_samp to match integral def.\n        # This finds max_t | integral(Q(f) exp(i 2pi f t) df) |\n        time_series = np.fft.ifft(X) * F_SAMP\n        max_corr = np.max(np.abs(time_series))\n        \n        # Final overlap and mismatch calculation\n        # Factors of 4 from inner product definition cancel out\n        denominator = np.sqrt(norm1_sq * norm2_sq)\n        if denominator == 0:\n            return 1.0 # Mismatch is 1 if signals have no power in band\n        \n        overlap = max_corr / denominator\n        mismatch = 1.0 - overlap\n        return mismatch\n    \n    # --- Main Execution Logic ---\n    \n    test_cases = [\n        (30.0, 30.0, 0.2, 0.2),       # Case 1\n        (15.0, 10.0, 0.5, -0.3),      # Case 2\n        (1.4, 1.3, 0.02, -0.01),     # Case 3\n        (35.0, 20.0, 0.95, 0.8),       # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        mismatch_val = calculate_mismatch(case)\n        results.append(f\"{mismatch_val:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3488789"}, {"introduction": "检验广义相对论最有力的方法之一，是检查来自双黑洞并合的引力波信号的内部自洽性。本练习将指导你实现一个简化的旋进-并合-铃振（IMR）自洽性检验[@problem_id:3488813]，该检验旨在比较从信号的早期旋进阶段和晚期铃振阶段分别推断出的最终黑洞属性。你将运用贝叶斯推断来计算贝叶斯因子，为信号的自洽性提供定量证据，从而直接检验广义相对论的一项关键预测。", "problem": "实现一个完整且可运行的程序，该程序使用合成数据集执行简化的广义相对论（GR）的旋进-并合-铃振（IMR）一致性检验。检验过程通过传播旋进和铃振推断中的测量不确定性，并计算旋进预测的与铃振推断的最终黑洞自旋之间的一致性假设与不一致性假设的贝叶斯因子。请完全在几何单位制（其中引力常数和光速满足 $G = c = 1$）下工作，并将所有物理量以无量纲形式表示。最终输出必须是单行，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表。列表中的值必须是贝叶斯因子（浮点数）。\n\n您必须在以下物理和统计基础上构建此检验，仅使用此处给出的定义和经过充分检验的公式，不引入任何超出指定范围的额外经验拟合。检验的目标是残余黑洞的无量纲最终自旋参数 $a \\in (0,1)$。旋进阶段测量的参数是对称质量比 $\\eta \\in (0,0.25]$，铃振阶段测量的量是无量纲主导准简正模（QNM）频率 $\\hat{\\omega}$ 和无量纲阻尼时间 $\\hat{\\tau}$。程序必须计算一个贝叶斯因子，该因子量化了支持“旋进和铃振与单个共同最终自旋 $a$ 一致”（假设 $\\mathcal{H}_{\\mathrm{c}}$）与“旋进和铃振倾向于不同的最终自旋”（假设 $\\mathcal{H}_{\\mathrm{i}}$）的证据。\n\n使用的基本和建模假设：\n- 旋进的总结参数是对称质量比 $\\eta \\equiv \\frac{m_1 m_2}{(m_1 + m_2)^2}$，残余黑洞的非旋转最终自旋由以下经过充分检验的拟合公式近似：\n$$\na(\\eta) \\equiv a_{\\mathrm{f}}(\\eta) = \\sqrt{12}\\,\\eta - 3.871\\,\\eta^2.\n$$\n- 主导克尔黑洞准简正模（$\\ell = m = 2, n = 0$）的无量纲频率和品质因数作为最终自旋 $a$ 的函数，由标准的 Berti–Cardoso–Will 拟合公式给出：\n$$\n\\hat{\\omega}(a) = 1.5251 - 1.1568\\,\\bigl(1 - a\\bigr)^{0.1292}, \\quad\nQ(a) = 0.7000 + 1.4187\\,\\bigl(1 - a\\bigr)^{-0.4990}.\n$$\n- 无量纲阻尼时间为：\n$$\n\\hat{\\tau}(a) = \\frac{2\\,Q(a)}{\\hat{\\omega}(a)}.\n$$\n- 旋进测量模型：对 $\\eta$ 进行单次高斯测量，均值为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$。使用线性不确定性传播将此不确定性传播到 $a$，其中使用在 $\\bar{\\eta}$ 处计算的导数 $\\frac{da}{d\\eta}$，得到一个高斯分布 $a_{\\mathrm{I}} \\sim \\mathcal{N}(\\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2)$，其中 $\\mu_{\\mathrm{I}} = a(\\bar{\\eta})$ 且 $\\sigma_{\\mathrm{I}} = \\left|\\frac{da}{d\\eta}(\\bar{\\eta})\\right| \\sigma_{\\eta}$。\n- 铃振测量模型：对 $\\mathbf{y} \\equiv \\bigl(\\hat{\\omega}, \\hat{\\tau}\\bigr)$ 进行二维高斯测量，均值为 $\\bar{\\mathbf{y}}$，对角协方差为 $\\Sigma_{\\mathrm{R}} = \\mathrm{diag}(\\sigma_{\\hat{\\omega}}^2, \\sigma_{\\hat{\\tau}}^2)$。通过最小化加权最小二乘失配来推断 $a$：\n$$\n\\chi^2(a) = \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr)^{\\top} \\Sigma_{\\mathrm{R}}^{-1} \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr),\n$$\n其中 $\\mathbf{g}(a) = \\bigl(\\hat{\\omega}(a), \\hat{\\tau}(a)\\bigr)$。将 $a$ 的铃振后验分布近似为高斯分布 $a_{\\mathrm{R}} \\sim \\mathcal{N}(\\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2)$，其中 $\\mu_{\\mathrm{R}}$ 是 $\\chi^2(a)$ 在 $a \\in (0,1)$ 上的最小化器，且\n$$\n\\sigma_{\\mathrm{R}}^2 \\approx \\Bigl(J^{\\top} \\Sigma_{\\mathrm{R}}^{-1} J\\Bigr)^{-1}\\Bigr|_{a = \\mu_{\\mathrm{R}}},\n$$\n其中灵敏度向量 $J = \\frac{d\\mathbf{g}}{da} = \\left(\\frac{d\\hat{\\omega}}{da}, \\frac{d\\hat{\\tau}}{da}\\right)$ 在 $a = \\mu_{\\mathrm{R}}$ 处计算。可以使用数值有限差分来计算 $J$。\n- 使用高斯先验对 $a$ 进行贝叶斯模型比较：采用先验分布 $a \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，均值为 $\\mu_0$，标准差为 $\\sigma_0$。该分布名义上截断到 $(0,1)$，但为了分析上的易处理性，使用其非截断的高斯形式。\n- 在一致性假设 $\\mathcal{H}_{\\mathrm{c}}$ 下，两次测量共享同一个 $a$，证据是以下一维积分：\n$$\nZ_{\\mathrm{c}} = \\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_0, \\sigma_0^2\\bigr)\\, da.\n$$\n- 在不一致性假设 $\\mathcal{H}_{\\mathrm{i}}$ 下，旋进和铃振由从相同先验中抽取的独立自旋 $a_{\\mathrm{I}}$ 和 $a_{\\mathrm{R}}$ 控制，因此证据可分解为：\n$$\nZ_{\\mathrm{i}} = \\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{I}}\\right]\\,\n\\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{R}}\\right].\n$$\n- 贝叶斯因子是 $K \\equiv \\frac{Z_{\\mathrm{c}}}{Z_{\\mathrm{i}}}$。\n\n测试套件的合成数据构建：\n- 对每个测试，定义一个真实的对称质量比 $\\eta_{\\mathrm{true}}$，构建真实的最终自旋 $a_{\\mathrm{true}} = a(\\eta_{\\mathrm{true}})$，并定义一个铃振偏差 $\\delta a$ 来设置铃振的平均自旋 $a_{\\mathrm{RD}} = a_{\\mathrm{true}} + \\delta a$。\n- 将铃振的平均测量值设置为在 $a_{\\mathrm{RD}}$ 处的无噪声模型值：\n$$\n\\bar{\\hat{\\omega}} = \\hat{\\omega}(a_{\\mathrm{RD}}), \\quad \\bar{\\hat{\\tau}} = \\hat{\\tau}(a_{\\mathrm{RD}}).\n$$\n- $\\eta$ 的旋进平均测量值为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$；按照上述规定传播到 $(\\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}})$。\n- 使用均值为 $\\mu_0$ 且标准差为 $\\sigma_0$ 的高斯先验。\n\n数值要求：\n- 实现对 $\\chi^2(a)$ 在 $a \\in (0,1)$ 上的稳健一维最小化，以找到 $\\mu_{\\mathrm{R}}$。\n- 使用小步长的数值中心有限差分来计算 $J$。\n- 以闭合形式计算一维高斯证据积分。\n- 所有量都是无量纲的；不需要物理单位转换。\n- 您的程序必须产生单行输出，其中包含所有测试用例的贝叶斯因子，形式为逗号分隔的列表并用方括号括起，例如 $[\\text{value}_1,\\text{value}_2,\\text{value}_3]$。\n\n先验设定（所有测试通用）：\n- $\\mu_0 = 0.7$,\n- $\\sigma_0 = 0.3$.\n\n测试套件：\n- 测试 $1$（理想路径，一致，类似等质量）：\n  - $\\eta_{\\mathrm{true}} = 0.25$, $\\delta a = 0.0$,\n  - $\\bar{\\eta} = 0.248$, $\\sigma_{\\eta} = 0.004$,\n  - $\\sigma_{\\hat{\\omega}} = 0.003$, $\\sigma_{\\hat{\\tau}} = 0.2$.\n- 测试 $2$（不一致的铃振偏差，中等质量比）：\n  - $\\eta_{\\mathrm{true}} = 0.20$, $\\delta a = 0.10$,\n  - $\\bar{\\eta} = 0.202$, $\\sigma_{\\eta} = 0.004$,\n  - $\\sigma_{\\hat{\\omega}} = 0.003$, $\\sigma_{\\hat{\\tau}} = 0.2$.\n- 测试 $3$（弱旋进强铃振的边缘情况）：\n  - $\\eta_{\\mathrm{true}} = 0.24$, $\\delta a = 0.0$,\n  - $\\bar{\\eta} = 0.235$, $\\sigma_{\\eta} = 0.020$,\n  - $\\sigma_{\\hat{\\omega}} = 0.001$, $\\sigma_{\\hat{\\tau}} = 0.05$.\n\n最终输出格式：\n- 您的程序必须向标准输出精确打印一行：一个形如 $[K_1,K_2,K_3]$ 的列表，其中 $K_i$ 是为测试 $i$ 按上述规定计算的贝叶斯因子。不允许有额外的空格或文本。", "solution": "我们首先将从测量到贝叶斯因子的各个量和流程进行形式化。所有数学符号和数字都以 LaTeX 格式呈现。\n\n定义和测量模型：\n- 对称质量比是 $\\eta = \\frac{m_1 m_2}{(m_1 + m_2)^2}$ 且满足 $\\eta \\in (0, 0.25]$。对于非旋转的前身天体，最终的克尔自旋 $a$ 由以下经过充分检验的关系式近似：\n$$\na(\\eta) = \\sqrt{12}\\,\\eta - 3.871\\,\\eta^2,\n$$\n在 $\\eta = 0.25$ 时，该式恢复为 $a \\approx 0.686$。\n\n- 主导克尔准简正模（QNM）的无量纲频率和品质因数作为最终自旋 $a$ 的函数，由以下公式给出：\n$$\n\\hat{\\omega}(a) = 1.5251 - 1.1568 \\bigl(1-a\\bigr)^{0.1292}, \\quad\nQ(a) = 0.7000 + 1.4187 \\bigl(1-a\\bigr)^{-0.4990},\n$$\n无量纲阻尼时间为：\n$$\n\\hat{\\tau}(a) = \\frac{2 Q(a)}{\\hat{\\omega}(a)}.\n$$\n\n- 旋进测量：对 $\\eta$ 的高斯测量，其均值为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$，通过线性化传播到对 $a$ 的高斯估计。我们计算均值\n$$\n\\mu_{\\mathrm{I}} = a(\\bar{\\eta}),\n$$\n和标准差\n$$\n\\sigma_{\\mathrm{I}} = \\left|\\frac{da}{d\\eta}(\\bar{\\eta})\\right| \\sigma_{\\eta}, \\quad \\frac{da}{d\\eta} = \\sqrt{12} - 2 \\cdot 3.871 \\, \\eta.\n$$\n这使用了适用于足够小的 $\\sigma_{\\eta}$ 的一阶不确定性传播。\n\n- 铃振测量：二维高斯观测 $\\bar{\\mathbf{y}} = \\bigl(\\bar{\\hat{\\omega}}, \\bar{\\hat{\\tau}}\\bigr)$，其对角协方差为 $\\Sigma_{\\mathrm{R}} = \\mathrm{diag}(\\sigma_{\\hat{\\omega}}^2, \\sigma_{\\hat{\\tau}}^2)$，通过映射 $\\mathbf{g}(a) = \\bigl(\\hat{\\omega}(a), \\hat{\\tau}(a)\\bigr)$ 来提供参数 $a$ 的信息。我们定义失配\n$$\n\\chi^2(a) = \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr)^{\\top} \\Sigma_{\\mathrm{R}}^{-1} \\bigl(\\bar{\\mathbf{y}} - \\mathbf{g}(a)\\bigr),\n$$\n并选择\n$$\n\\mu_{\\mathrm{R}} = \\operatorname*{arg\\,min}_{a \\in (0,1)} \\chi^2(a).\n$$\n来自局部高斯近似的后验方差由费雪信息的逆给出：\n$$\n\\sigma_{\\mathrm{R}}^2 \\approx \\Bigl(J^{\\top} \\Sigma_{\\mathrm{R}}^{-1} J\\Bigr)^{-1} \\Big|_{a = \\mu_{\\mathrm{R}}}, \\quad J = \\frac{d\\mathbf{g}}{da} = \\left(\\frac{d\\hat{\\omega}}{da}, \\frac{d\\hat{\\tau}}{da}\\right).\n$$\n我们使用小步长 $h$ 通过中心有限差分法数值计算 $J$：\n$$\n\\frac{d\\hat{\\omega}}{da}(a) \\approx \\frac{\\hat{\\omega}(a + h) - \\hat{\\omega}(a - h)}{2 h}, \\quad \\frac{d\\hat{\\tau}}{da}(a) \\approx \\frac{\\hat{\\tau}(a + h) - \\hat{\\tau}(a - h)}{2 h}.\n$$\n\n- 贝叶斯模型比较：采用先验 $a \\sim \\mathcal{N}(\\mu_0, \\sigma_0^2)$，其中 $\\mu_0 = 0.7$ 和 $\\sigma_0 = 0.3$。在一致性假设 $\\mathcal{H}_{\\mathrm{c}}$ 下，证据为：\n$$\nZ_{\\mathrm{c}} = \\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a; \\mu_0, \\sigma_0^2\\bigr)\\, da.\n$$\n在不一致性假设 $\\mathcal{H}_{\\mathrm{i}}$ 下，其中 $a_{\\mathrm{I}}$ 和 $a_{\\mathrm{R}}$ 独立，证据可分解为：\n$$\nZ_{\\mathrm{i}} = \\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{I}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{I}}\\right]\\,\n\\left[\\int_{-\\infty}^{+\\infty} \\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}}^2\\bigr)\\,\\mathcal{N}\\bigl(a_{\\mathrm{R}}; \\mu_0, \\sigma_0^2\\bigr)\\, da_{\\mathrm{R}}\\right].\n$$\n\n高斯乘积的闭合形式证据：\n- $a$ 的高斯函数乘积仍然是 $a$ 的高斯函数。让我们定义精度 $\\lambda_{\\mathrm{I}} = \\sigma_{\\mathrm{I}}^{-2}$、$\\lambda_{\\mathrm{R}} = \\sigma_{\\mathrm{R}}^{-2}$ 和 $\\lambda_0 = \\sigma_0^{-2}$。$Z_{\\mathrm{c}}$ 的积分可以通过配方法写出。指数的二次型是：\n$$\n\\frac{(a - \\mu_{\\mathrm{I}})^2}{\\sigma_{\\mathrm{I}}^2} + \\frac{(a - \\mu_{\\mathrm{R}})^2}{\\sigma_{\\mathrm{R}}^2} + \\frac{(a - \\mu_0)^2}{\\sigma_0^2} = \\Lambda\\, a^2 - 2 b\\, a + c,\n$$\n其中\n$$\n\\Lambda = \\lambda_{\\mathrm{I}} + \\lambda_{\\mathrm{R}} + \\lambda_0, \\quad b = \\lambda_{\\mathrm{I}} \\mu_{\\mathrm{I}} + \\lambda_{\\mathrm{R}} \\mu_{\\mathrm{R}} + \\lambda_0 \\mu_0, \\quad c = \\lambda_{\\mathrm{I}} \\mu_{\\mathrm{I}}^2 + \\lambda_{\\mathrm{R}} \\mu_{\\mathrm{R}}^2 + \\lambda_0 \\mu_0^2.\n$$\n使用后验均值 $m = b/\\Lambda$ 进行配方，积分得出：\n$$\nZ_{\\mathrm{c}} = \\frac{1}{(2\\pi)\\,\\sigma_{\\mathrm{I}}\\,\\sigma_{\\mathrm{R}}\\,\\sigma_0} \\cdot \\frac{1}{\\sqrt{\\Lambda}} \\cdot \\exp\\left( -\\frac{1}{2}\\left[c - \\frac{b^2}{\\Lambda}\\right] \\right).\n$$\n\n- $Z_{\\mathrm{i}}$ 中的每个因子是两个高斯函数的卷积积分，得出：\n$$\n\\int \\mathcal{N}(a; \\mu, \\sigma^2) \\mathcal{N}(a; \\mu_0, \\sigma_0^2)\\, da = \\mathcal{N}(\\mu; \\mu_0, \\sigma^2 + \\sigma_0^2) = \\frac{1}{\\sqrt{2\\pi(\\sigma^2 + \\sigma_0^2)}} \\exp\\left( -\\frac{1}{2} \\frac{(\\mu - \\mu_0)^2}{\\sigma^2 + \\sigma_0^2} \\right).\n$$\n因此，\n$$\nZ_{\\mathrm{i}} = \\frac{1}{2\\pi \\sqrt{(\\sigma_{\\mathrm{I}}^2 + \\sigma_0^2)(\\sigma_{\\mathrm{R}}^2 + \\sigma_0^2)}} \\exp\\left( -\\frac{1}{2} \\left[ \\frac{(\\mu_{\\mathrm{I}} - \\mu_0)^2}{\\sigma_{\\mathrm{I}}^2 + \\sigma_0^2} + \\frac{(\\mu_{\\mathrm{R}} - \\mu_0)^2}{\\sigma_{\\mathrm{R}}^2 + \\sigma_0^2} \\right] \\right).\n$$\n\n贝叶斯因子：\n- 贝叶斯因子为\n$$\nK = \\frac{Z_{\\mathrm{c}}}{Z_{\\mathrm{i}}}.\n$$\n将上面推导出的表达式代入，得到一个可以直接从 $(\\mu_{\\mathrm{I}}, \\sigma_{\\mathrm{I}})$、$(\\mu_{\\mathrm{R}}, \\sigma_{\\mathrm{R}})$ 和 $(\\mu_0, \\sigma_0)$ 计算的闭合形式。\n\n每个测试的合成数据生成：\n- 对于每个测试，我们设置 $\\eta_{\\mathrm{true}}$ 并计算 $a_{\\mathrm{true}} = a(\\eta_{\\mathrm{true}})$。应用铃振偏差 $\\delta a$ 来构建铃振平均自旋 $a_{\\mathrm{RD}} = a_{\\mathrm{true}} + \\delta a$。然后我们将铃振均值设置为模型预测值：\n$$\n\\bar{\\hat{\\omega}} = \\hat{\\omega}(a_{\\mathrm{RD}}), \\quad \\bar{\\hat{\\tau}} = \\hat{\\tau}(a_{\\mathrm{RD}}).\n$$\n$\\eta$ 的旋进均值给定为 $\\bar{\\eta}$，标准差为 $\\sigma_{\\eta}$，我们通过线性化从中计算出 $\\mu_{\\mathrm{I}}$ 和 $\\sigma_{\\mathrm{I}}$。\n\n算法步骤：\n- 对于每个测试用例，\n  - 计算 $a_{\\mathrm{true}} = a(\\eta_{\\mathrm{true}})$ 和 $a_{\\mathrm{RD}} = a_{\\mathrm{true}} + \\delta a$。\n  - 使用提供的 QNM 拟合计算铃振均值 $\\bar{\\hat{\\omega}}$ 和 $\\bar{\\hat{\\tau}}$。\n  - 计算 $\\mu_{\\mathrm{I}} = a(\\bar{\\eta})$ 和 $\\sigma_{\\mathrm{I}} = \\left|\\sqrt{12} - 2\\cdot 3.871 \\, \\bar{\\eta}\\right| \\sigma_{\\eta}$。\n  - 通过在 $a \\in (0,1)$ 上最小化 $\\chi^2(a)$ 来推断 $\\mu_{\\mathrm{R}}$；在 $a = \\mu_{\\mathrm{R}}$ 处使用数值导数计算 $J$ 来计算 $\\sigma_{\\mathrm{R}}^2 \\approx \\bigl(J^{\\top} \\Sigma_{\\mathrm{R}}^{-1} J\\bigr)^{-1}$。\n  - 使用上述闭合形式表达式及 $\\mu_0 = 0.7$ 和 $\\sigma_0 = 0.3$ 计算 $Z_{\\mathrm{c}}$ 和 $Z_{\\mathrm{i}}$。\n  - 返回 $K = Z_{\\mathrm{c}}/Z_{\\mathrm{i}}$。\n\n测试套件详情：\n- 测试 $1$：$\\eta_{\\mathrm{true}} = 0.25$, $\\delta a = 0.0$, $\\bar{\\eta} = 0.248$, $\\sigma_{\\eta} = 0.004$, $\\sigma_{\\hat{\\omega}} = 0.003$, $\\sigma_{\\hat{\\tau}} = 0.2$。\n- 测试 $2$：$\\eta_{\\mathrm{true}} = 0.20$, $\\delta a = 0.10$, $\\bar{\\eta} = 0.202$, $\\sigma_{\\eta} = 0.004$, $\\sigma_{\\hat{\\omega}} = 0.003$, $\\sigma_{\\hat{\\tau}} = 0.2$。\n- 测试 $3$：$\\eta_{\\mathrm{true}} = 0.24$, $\\delta a = 0.0$, $\\bar{\\eta} = 0.235$, $\\sigma_{\\eta} = 0.020$, $\\sigma_{\\hat{\\omega}} = 0.001$, $\\sigma_{\\hat{\\tau}} = 0.05$。\n\n程序必须将三个测试的贝叶斯因子组合成一个列表，并以 $[K_1,K_2,K_3]$ 的确切格式单行打印，不得包含额外文本。\n\n此过程检验广义相对论（GR）的假设，即单个最终自旋参数 $a$ 能够解释旋进和铃振的测量结果。大的贝叶斯因子 $K$ 支持一致性，而小的 $K$ 支持不一致性。该设计涵盖了一个理想路径（测试1）、一个故意不一致的场景（测试2）以及一个弱旋进但强铃振信息的边缘情况（测试3）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef final_spin_from_eta(eta: float) - float:\n    # a(eta) = sqrt(12)*eta - 3.871*eta^2\n    return np.sqrt(12.0) * eta - 3.871 * eta**2\n\ndef da_deta(eta: float) - float:\n    # derivative of final spin wrt eta: sqrt(12) - 2*3.871*eta\n    return np.sqrt(12.0) - 2.0 * 3.871 * eta\n\ndef omega_hat(a: float) - float:\n    # Dimensionless QNM frequency fit\n    return 1.5251 - 1.1568 * (1.0 - a)**0.1292\n\ndef Q_factor(a: float) - float:\n    # Quality factor fit\n    return 0.7000 + 1.4187 * (1.0 - a)**(-0.4990)\n\ndef tau_hat(a: float) - float:\n    # Dimensionless damping time\n    w = omega_hat(a)\n    Q = Q_factor(a)\n    return 2.0 * Q / w\n\ndef g_vec(a: float) - np.ndarray:\n    return np.array([omega_hat(a), tau_hat(a)])\n\ndef chi2(a: float, ybar: np.ndarray, inv_cov: np.ndarray) - float:\n    # Enforce bounds inside minimization; if outside (0,1), penalize\n    if not (0.0  a  1.0):\n        return 1e9 + (a - 0.5)**2\n    r = ybar - g_vec(a)\n    return float(r.T @ inv_cov @ r)\n\ndef numerical_J(a: float, h: float = 1e-6) - np.ndarray:\n    # Central finite differences for derivatives of omega_hat and tau_hat wrt a\n    ap = min(a + h, 1.0 - 1e-9)\n    am = max(a - h, 1e-9)\n    gp = g_vec(ap)\n    gm = g_vec(am)\n    return (gp - gm) / (ap - am)\n\ndef infer_ringdown_posterior(ybar: np.ndarray, sigmas: np.ndarray) - tuple[float, float]:\n    # ybar = [omega_hat_mean, tau_hat_mean]; sigmas = [sigma_omega, sigma_tau]\n    cov = np.diag(sigmas**2)\n    inv_cov = np.diag(1.0 / (sigmas**2))\n    # Minimize chi^2 over a in (0,1)\n    res = minimize_scalar(lambda a: chi2(a, ybar, inv_cov), bounds=(0.0, 1.0), method='bounded')\n    a_hat = float(res.x)\n    # Fisher information for variance\n    J = numerical_J(a_hat)\n    F = float(J.T @ inv_cov @ J)\n    # Guard against numerical issues\n    if F = 0.0 or not np.isfinite(F):\n        # Fall back to a small variance to avoid division by zero; but keep finite\n        var = 1e6\n    else:\n        var = 1.0 / F\n    return a_hat, var\n\ndef gaussian_evidence_consistent(muI: float, sigI: float, muR: float, sigR: float, mu0: float, sig0: float) - float:\n    # Z_c = (1/((2π) σI σR σ0)) * (1/sqrt(Λ)) * exp(-0.5*(c - b^2/Λ))\n    lamI = 1.0 / (sigI**2)\n    lamR = 1.0 / (sigR**2)\n    lam0 = 1.0 / (sig0**2)\n    Lam = lamI + lamR + lam0\n    b = lamI * muI + lamR * muR + lam0 * mu0\n    c = lamI * muI**2 + lamR * muR**2 + lam0 * mu0**2\n    pref = 1.0 / ((2.0 * np.pi) * sigI * sigR * sig0)\n    val = pref * (1.0 / np.sqrt(Lam)) * np.exp(-0.5 * (c - (b**2) / Lam))\n    return float(val)\n\ndef gaussian_evidence_inconsistent(muI: float, sigI: float, muR: float, sigR: float, mu0: float, sig0: float) - float:\n    # Z_i = [N(muI; mu0, sigI^2+sig0^2)] * [N(muR; mu0, sigR^2+sig0^2)]\n    sI2 = sigI**2 + sig0**2\n    sR2 = sigR**2 + sig0**2\n    prefI = 1.0 / np.sqrt(2.0 * np.pi * sI2)\n    prefR = 1.0 / np.sqrt(2.0 * np.pi * sR2)\n    expI = np.exp(-0.5 * ((muI - mu0)**2) / sI2)\n    expR = np.exp(-0.5 * ((muR - mu0)**2) / sR2)\n    return float(prefI * expI * prefR * expR)\n\ndef bayes_factor(muI: float, sigI: float, muR: float, sigR: float, mu0: float, sig0: float) - float:\n    Zc = gaussian_evidence_consistent(muI, sigI, muR, sigR, mu0, sig0)\n    Zi = gaussian_evidence_inconsistent(muI, sigI, muR, sigR, mu0, sig0)\n    # Avoid division by zero\n    if Zi == 0.0 or not np.isfinite(Zi):\n        return float('inf')\n    return Zc / Zi\n\ndef solve():\n    # Prior parameters\n    mu0 = 0.7\n    sig0 = 0.3\n\n    # Define the test cases from the problem statement.\n    # Each test case: (eta_true, delta_a, eta_bar, sigma_eta, sigma_omega_hat, sigma_tau_hat)\n    test_cases = [\n        (0.25, 0.0, 0.248, 0.004, 0.003, 0.2),   # Test 1\n        (0.20, 0.10, 0.202, 0.004, 0.003, 0.2),  # Test 2\n        (0.24, 0.0, 0.235, 0.020, 0.001, 0.05),  # Test 3\n    ]\n\n    results = []\n    for (eta_true, delta_a, eta_bar, sigma_eta, sigma_omega, sigma_tau) in test_cases:\n        # True and ringdown-bias spins\n        a_true = final_spin_from_eta(eta_true)\n        a_rd = a_true + delta_a\n        # Ringdown mean observables\n        ybar = np.array([omega_hat(a_rd), tau_hat(a_rd)])\n        sigmas = np.array([sigma_omega, sigma_tau])\n\n        # Inspiral mean and sigma\n        mu_I = final_spin_from_eta(eta_bar)\n        dade = da_deta(eta_bar)\n        sig_I = abs(dade) * sigma_eta\n        # Guard: ensure positive non-zero sigma\n        sig_I = max(sig_I, 1e-9)\n\n        # Ringdown posterior approximation\n        mu_R, var_R = infer_ringdown_posterior(ybar, sigmas)\n        sig_R = np.sqrt(max(var_R, 1e-18))\n\n        # Bayes factor\n        K = bayes_factor(mu_I, sig_I, mu_R, sig_R, mu0, sig0)\n        results.append(K)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3488813"}, {"introduction": "除了验证广义相对论的自洽性，我们还可以通过检验对广义相对论的特定参数化偏离，来主动寻找新物理的迹象。本练习将通过量化一个“后爱因斯坦”（pPE）修正对引力波相位的影响，来探索这种方法[@problem_id:3488821]。你将计算该修正对标准广义相对论参数测量所引起的系统偏差，并将其与统计不确定性进行比较，这对于判断这种偏离是会被掩盖还是能被清晰地探测到至关重要。", "problem": "考虑一个双黑洞并合的频域主模引力波应变，其模型为 $h(f; \\theta) = A(f; \\theta)\\exp\\left[i\\,\\phi_{\\mathrm{GR}}(f; \\theta)\\right]$，其中 $f$ 是频率（单位为 $\\mathrm{Hz}$），$\\theta$ 表示内禀参数，相位 $\\phi_{\\mathrm{GR}}(f; \\theta)$ 是广义相对论基线。假设为非进动、准圆形轨道双星，并考虑一个参数化的后爱因斯坦（pPE）相位注入，它将真实信号修正为 $h_{\\mathrm{true}}(f; \\theta) = A(f; \\theta)\\exp\\left[i(\\phi_{\\mathrm{GR}}(f; \\theta) + \\delta\\phi(f))\\right]$，其中包含一个小的相位修正 $\\delta\\phi(f)$（单位为弧度）。在稳相近似和单探测器高斯噪声模型下进行计算。\n\n基本依据和定义：\n- 应变噪声的功率谱密度（PSD）$S_n(f)$ 出现在最优内积的定义中：$(a|b) = 4\\,\\mathrm{Re}\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}}\\frac{a(f)^{*}b(f)}{S_n(f)}\\,\\mathrm{d}f$，其中 $^{*}$ 表示复共轭。频率单位为 $\\mathrm{Hz}$，相位单位为弧度。\n- 对于小的建模误差 $\\Delta h(f) = h_{\\mathrm{true}}(f) - h_{\\mathrm{model}}(f)$ 和一个忽略了 $\\delta\\phi(f)$ 的模板参数 $\\theta$，一阶参数偏差为 $\\delta\\theta \\approx \\Gamma^{-1}\\,(\\partial_{\\theta}h|\\Delta h)$，其中 $\\Gamma = (\\partial_{\\theta}h|\\partial_{\\theta}h)$ 是 $\\theta$ 的费雪信息（Fisher information），$\\partial_{\\theta}h$ 表示模板相对于 $\\theta$ 的导数。\n- 在纯相位近似中，忽略振幅的导数，因此 $\\partial_{\\theta}h \\approx i\\,(\\partial_{\\theta}\\phi_{\\mathrm{GR}})\\,h$；对于小的 $\\delta\\phi(f)$，$\\Delta h(f) \\approx i\\,\\delta\\phi(f)\\,h(f)$。于是，$\\theta$ 的偏差简化为 $\\delta\\theta \\approx \\frac{\\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})\\,\\delta\\phi\\,W(f)\\,\\mathrm{d}f}{\\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})^2\\,W(f)\\,\\mathrm{d}f}$，其中 $W(f) = \\frac{4\\,|h(f)|^2}{S_n(f)}$，而 $1\\sigma$ 不确定度为 $\\sigma_{\\theta} \\approx \\Gamma^{-1/2}$，其中 $\\Gamma = \\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})^2\\,W(f)\\,\\mathrm{d}f$。\n- 信噪比（SNR）为 $\\rho = \\sqrt{(h|h)}$。\n\n本任务中使用的波形和注入模型：\n- 采用牛顿阶振幅标度 $A(f; \\theta) \\propto f^{-7/6}$，并在高频处通过一个平滑窗进行锥削，以模拟经数值相对论（NR）校准的并合行为。使用窗函数 $W_{\\mathrm{amp}}(f; f_{\\mathrm{ISCO}}, \\Delta) = \\left(1 + \\exp\\left[\\frac{f - f_{\\mathrm{ISCO}}}{\\Delta}\\right]\\right)^{-1}$，其中 $\\Delta = 0.1\\,f_{\\mathrm{ISCO}}$。这里的 $f_{\\mathrm{ISCO}} = \\frac{c^3}{6^{3/2}\\pi G M}$ 是对应于总质量 $M$ 的最内稳定圆轨道频率（在使用 $G$ 和 $c$ 时，将 $M$ 以 $\\mathrm{kg}$ 表示），其中 $G$ 是引力常数，$c$ 是光速。\n- 使用牛顿阶广义相对论相位 $\\phi_{\\mathrm{GR}}(f; M, \\eta) = \\phi_0 + \\frac{3}{128}\\left(\\pi f \\mathcal{M}\\right)^{-5/3}$，其中常数偏移相位 $\\phi_0 = 0$。啁啾质量 $\\mathcal{M} = \\eta^{3/5} M$ 通过 $M_{\\mathrm{sec}} = \\frac{G M}{c^3}$ 和 $\\mathcal{M}_{\\mathrm{sec}} = \\eta^{3/5} M_{\\mathrm{sec}}$ 以秒的几何单位表示。对称质量比为 $\\eta = \\frac{m_1 m_2}{(m_1 + m_2)^2} \\in (0, 0.25]$。\n- 将pPE相位注入实现为 $\\delta\\phi(f) = \\beta \\left(\\pi f M_{\\mathrm{sec}}\\right)^{b}$，并乘以相同的高频锥削函数 $W_{\\mathrm{amp}}(f; f_{\\mathrm{ISCO}}, \\Delta)$，其中 $\\beta$ 是一个小的无量纲振幅，$b$ 是一个实指数。角度单位为弧度。\n\n待测试偏差的参数：\n- 设感兴趣的参数为总质量 $M$。在纯相位近似下进行计算，即 $\\partial_M h \\approx i\\,(\\partial_M \\phi_{\\mathrm{GR}})\\,h$，使用 $\\partial_M \\phi_{\\mathrm{GR}}(f) = \\frac{\\partial}{\\partial M}\\left(\\frac{3}{128}(\\pi f \\mathcal{M}_{\\mathrm{sec}})^{-5/3}\\right)$，其中 $\\mathcal{M}_{\\mathrm{sec}} = \\eta^{3/5} M_{\\mathrm{sec}}$ 且 $M_{\\mathrm{sec}} = \\frac{G M}{c^3}$。输出的偏差 $\\delta M$ 和不确定度 $\\sigma_M$ 必须以太阳质量（$M_{\\odot}$）为单位报告。\n\n噪声模型：\n- 使用一个代表地面探测器的平滑解析PSD：$S_n(f) = S_0\\left[\\left(\\frac{f_0}{f}\\right)^{4} + 1 + \\left(\\frac{f}{f_0}\\right)^{2}\\right]$，其中 $S_0 = 10^{-46}\\,\\mathrm{Hz}^{-1}$ 且 $f_0 = 100\\,\\mathrm{Hz}$。\n\n归一化：\n- 通过选择有效光度距离来确定总振幅标度，使得广义相对论模板达到一个指定的目标信噪比（SNR）$\\rho$；即，通过一个常数因子 $s$ 来重标度 $A(f)$，使得 $(s\\,A\\,e^{i\\phi_{\\mathrm{GR}}}|s\\,A\\,e^{i\\phi_{\\mathrm{GR}}}) = \\rho^{2}$。\n\n计算要求和单位：\n- 频率 $f$ 必须以 $\\mathrm{Hz}$ 为单位，输入和输出的质量以 $M_{\\odot}$ 为单位，相位以弧度为单位。积分上下限为 $f_{\\mathrm{low}}$ 到 $f_{\\mathrm{high}} = f_{\\mathrm{ISCO}}$，数值积分应在此区间上使用一个分辨率良好的均匀网格。\n- 最终的偏差 $\\delta M$ 和不确定度 $\\sigma_M$ 以 $M_{\\odot}$ 为单位表示，并对每个测试案例评估可恢复性准则 $|\\delta M| \\leq \\sigma_M$（布尔值）。\n\n测试套件：\n- 使用以下五个参数集，每个参数集指定为一个元组 $(M, \\eta, \\beta, b, f_{\\mathrm{low}}, \\rho)$，其中 $M$ 的单位是 $M_{\\odot}$，$f_{\\mathrm{low}}$ 的单位是 $\\mathrm{Hz}$，$\\rho$ 是无量纲的：\n  1. $(40, 0.25, 1\\times 10^{-3}, -1, 20, 25)$ 作为一般的理想情况。\n  2. $(40, 0.25, 0, -1, 20, 25)$ 作为零注入的边缘情况。\n  3. $(80, 0.25, 1\\times 10^{-3}, -1, 20, 25)$ 作为大质量情况。\n  4. $(30, 0.25, 1\\times 10^{-5}, 2, 20, 25)$ 作为正指数 pPE 情况。\n  5. $(40, 0.25, 1\\times 10^{-3}, -1, 20, 8)$ 作为低信噪比边界情况。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是对相应测试案例评估 $|\\delta M| \\leq \\sigma_M$ 的布尔值。", "solution": "问题陈述已经过严格审查，并被确定为**有效**。这是一个在引力波数据分析领域内提法明确、有科学依据的问题。它指定了一个标准的（尽管是简化的）计算流程，用于计算当使用理论模型（广义相对论）从包含微小未建模物理效应（pPE 相位修正）的数据中测量参数时所产生的系统参数偏差和统计不确定性。所提供的公式、常数和测试案例是完整且一致的，可以得出一个唯一且有意义的解。\n\n求解过程首先建立理论框架，推导必要的解析表达式，然后概述用于评估给定测试案例下这些表达式的计算算法。\n\n**1. 理论框架：参数偏差和不确定性**\n\n该分析基于低信噪比展开背景下的费雪信息矩阵（Fisher information matrix）形式。其核心思想是量化真实信号 $h_{\\mathrm{true}}(f)$ 与模板波形 $h_{\\mathrm{model}}(f)$ 之间的微小差异 $\\Delta h(f)$ 如何转化为推断参数 $\\theta$ 的系统偏差 $\\delta\\theta$。\n\n基本量是根据频域中引力波信号的噪声加权内积来定义的：\n$$\n(a|b) = 4\\,\\mathrm{Re}\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}}\\frac{a(f)^{*}b(f)}{S_n(f)}\\,\\mathrm{d}f\n$$\n其中 $S_n(f)$ 是探测器噪声的功率谱密度（PSD）。\n\n问题提供了一阶近似的参数偏差 $\\delta\\theta$ 和统计不确定性 $\\sigma_{\\theta}$：\n$$\n\\delta\\theta \\approx \\frac{(\\partial_{\\theta}h|\\Delta h)}{(\\partial_{\\theta}h|\\partial_{\\theta}h)} \\quad , \\quad \\sigma_{\\theta} \\approx \\Gamma^{-1/2} = (\\partial_{\\theta}h|\\partial_{\\theta}h)^{-1/2}\n$$\n其中 $\\Gamma = (\\partial_{\\theta}h|\\partial_{\\theta}h)$ 是参数 $\\theta$ 的费雪信息。\n\n问题要求在“纯相位”近似下工作，其中振幅的导数被忽略。对于模板 $h(f) = A(f) e^{i\\phi_{\\mathrm{GR}}(f)}$，其相对于一个仅出现在相位中的参数 $\\theta$ 的导数为 $\\partial_{\\theta}h \\approx i (\\partial_{\\theta}\\phi_{\\mathrm{GR}}) h$。信号的修正也纯粹在相位中，$h_{\\mathrm{true}}(f) = h(f) e^{i\\delta\\phi(f)}$。对于一个小的相位修正 $\\delta\\phi(f)$，建模误差为 $\\Delta h(f) = h_{\\mathrm{true}} - h \\approx i \\delta\\phi(f) h(f)$。\n\n将这些近似代入内积可得：\n- 偏差的分子：$(\\partial_{\\theta}h|\\Delta h) = (i(\\partial_{\\theta}\\phi_{\\mathrm{GR}})h | i\\delta\\phi(f)h) = 4\\,\\mathrm{Re}\\int \\frac{(-i\\partial_{\\theta}\\phi_{\\mathrm{GR}}h^{*})(i\\delta\\phi h)}{S_n} \\mathrm{d}f = \\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})\\delta\\phi \\frac{4|h|^2}{S_n} \\mathrm{d}f$。\n- 偏差的分母（费雪矩阵）：$(\\partial_{\\theta}h|\\partial_{\\theta}h) = (i(\\partial_{\\theta}\\phi_{\\mathrm{GR}})h | i(\\partial_{\\theta}\\phi_{\\mathrm{GR}})h) = \\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})^2 \\frac{4|h|^2}{S_n} \\mathrm{d}f$。\n\n这导出了所提供的表达式，其中被积函数由 $W(f) = \\frac{4|h(f)|^2}{S_n(f)}$ 加权：\n$$\n\\delta\\theta \\approx \\frac{\\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})\\,\\delta\\phi\\,W(f)\\,\\mathrm{d}f}{\\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})^2\\,W(f)\\,\\mathrm{d}f}\n\\quad, \\quad\n\\sigma_{\\theta} \\approx \\left( \\int (\\partial_{\\theta}\\phi_{\\mathrm{GR}})^2\\,W(f)\\,\\mathrm{d}f \\right)^{-1/2}\n$$\n\n**2. 波形、噪声和注入模型**\n\n各分量函数定义如下：\n- **噪声PSD：** $S_n(f) = S_0\\left[\\left(\\frac{f_0}{f}\\right)^{4} + 1 + \\left(\\frac{f}{f_0}\\right)^{2}\\right]$，其中 $S_0 = 10^{-46}\\,\\mathrm{Hz}^{-1}$ 且 $f_0 = 100\\,\\mathrm{Hz}$。\n- **未归一化振幅：** 一个未归一化的振幅 $A_{\\mathrm{unnorm}}(f)$ 由牛顿标度和并合锥削定义：$A_{\\mathrm{unnorm}}(f) = f^{-7/6} W_{\\mathrm{amp}}(f)$，其中锥削函数为 $W_{\\mathrm{amp}}(f) = \\left(1 + \\exp\\left[\\frac{f - f_{\\mathrm{ISCO}}}{\\Delta}\\right]\\right)^{-1}$。截止频率为 $f_{\\mathrm{ISCO}} = \\frac{c^3}{6^{3/2}\\pi G M}$ 而宽度为 $\\Delta = 0.1\\,f_{\\mathrm{ISCO}}$。\n- **广义相对论相位：** $\\phi_{\\mathrm{GR}}(f) = \\frac{3}{128}\\left(\\pi f \\mathcal{M}_{\\mathrm{sec}}\\right)^{-5/3}$，其中啁啾质量（秒）为 $\\mathcal{M}_{\\mathrm{sec}} = \\eta^{3/5} M_{\\mathrm{sec}} = \\eta^{3/5} \\frac{G M}{c^3}$。\n- **pPE注入：** $\\delta\\phi(f) = \\beta \\left(\\pi f M_{\\mathrm{sec}}\\right)^{b} W_{\\mathrm{amp}}(f)$。\n\n**3. SNR 归一化与推导**\n\n总振幅 $A(f)$ 被归一化，以使信噪比 $\\rho = \\sqrt{(h|h)}$ 与目标值匹配。设 $A(f) = K \\cdot A_{\\mathrm{unnorm}}(f)$，其中 $K$ 是归一化常数。\n$$\n\\rho^2 = (h|h) = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{|A(f)|^2}{S_n(f)} \\mathrm{d}f = K^2 \\left( 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{|A_{\\mathrm{unnorm}}(f)|^2}{S_n(f)} \\mathrm{d}f \\right)\n$$\n常数 $K^2$ 可以从目标 $\\rho$ 和未归一化波形的积分中求出。因此，权重函数为 $W(f) = \\frac{4|A(f)|^2}{S_n(f)} = K^2 \\frac{4|A_{\\mathrm{unnorm}}(f)|^2}{S_n(f)}$。\n\n关键在于，当将此形式的 $W(f)$ 代入偏差 $\\delta\\theta$ 的表达式时，常数 $K^2$（以及因此对 $\\rho$ 的依赖）在分子和分母之间被消去。因此，偏差 $\\delta M$ 与 SNR 无关。然而，不确定度 $\\sigma_{\\theta}$ 与 $K^{-1}$ 成正比，这意味着 $\\sigma_{\\theta} \\propto 1/\\rho$。正如预期的那样，更高的 SNR 会导致更小的统计不确定性。\n\n感兴趣的参数是总质量 $M$，在所有物理计算中均以千克为单位。需要计算广义相对论相位对 $M$ 的导数：\n$$\n\\partial_M \\phi_{\\mathrm{GR}} = \\frac{\\partial}{\\partial M} \\left[ \\frac{3}{128} \\left(\\pi f \\eta^{3/5} \\frac{G M}{c^3}\\right)^{-5/3} \\right]\n$$\n使用链式法则，可以方便地表示为：\n$$\n\\partial_M \\phi_{\\mathrm{GR}} = \\left( -\\frac{5}{3M} \\right) \\phi_{\\mathrm{GR}}(f)\n$$\n这种简化在计算上是高效的。$\\partial_M \\phi_{\\mathrm{GR}}$ 的单位是 $\\mathrm{rad}\\cdot\\mathrm{kg}^{-1}$。\n\n**4. 计算策略**\n\n对于每个给定的测试案例 $(M_{\\odot}, \\eta, \\beta, b, f_{\\mathrm{low}}, \\rho)$：\n1.  **常数和输入：** 定义物理常数（$G, c, M_{\\odot}$）并将输入的总质量从太阳质量（$M_{\\odot}$）转换为千克（$M_{\\mathrm{kg}}$）。\n2.  **频率网格：** 为频率 $f$ 建立一个从 $f_{\\mathrm{low}}$ 到 $f_{\\mathrm{high}} = f_{\\mathrm{ISCO}}(M_{\\mathrm{kg}})$ 的密集数值网格。\n3.  **模型函数：** 在频率网格上评估所有必需的函数（$S_n(f)$, $W_{\\mathrm{amp}}(f)$, $A_{\\mathrm{unnorm}}(f)$, $\\phi_{\\mathrm{GR}}(f)$, $\\partial_M \\phi_{\\mathrm{GR}}(f)$, $\\delta\\phi(f)$）。\n4.  **被积函数：** 构建偏差的分子和分母的被积函数。设 $w_{\\mathrm{un}}(f) = 4|A_{\\mathrm{unnorm}}(f)|^2/S_n(f)$。\n    - 分子被积函数：$I_{\\mathrm{num}}(f) = (\\partial_M \\phi_{\\mathrm{GR}}) \\delta\\phi \\cdot w_{\\mathrm{un}}(f)$。\n    - 分母被积函数：$I_{\\mathrm{den}}(f) = (\\partial_M \\phi_{\\mathrm{GR}})^2 \\cdot w_{\\mathrm{un}}(f)$。\n5.  **偏差计算：** 在频率网格上对 $I_{\\mathrm{num}}$ 和 $I_{\\mathrm{den}}$ 进行数值积分。以千克为单位的偏差是 $\\delta M_{\\mathrm{kg}} = (\\int I_{\\mathrm{num}} \\mathrm{d}f) / (\\int I_{\\mathrm{den}} \\mathrm{d}f)$。\n6.  **不确定性计算：**\n    a. 计算未归一化波形的信噪比平方：$\\rho_0^2 = \\int w_{\\mathrm{un}}(f) \\mathrm{d}f$。\n    b. 费雪矩阵元为 $\\Gamma_{MM} = \\frac{\\rho^2}{\\rho_0^2} \\int I_{\\mathrm{den}}(f) \\mathrm{d}f$。\n    c. 不确定性是 $\\sigma_{M, \\mathrm{kg}} = \\Gamma_{MM}^{-1/2}$。\n7.  **最终评估：** 将 $\\delta M_{\\mathrm{kg}}$ 和 $\\sigma_{M, \\mathrm{kg}}$ 转换为太阳质量（$M_{\\odot}$）。将可恢复性准则 $|\\delta M| \\leq \\sigma_M$ 评估为布尔值。\n\n该过程被系统地应用于每个测试案例，以生成最终的布尔结果列表。对于 $\\beta=0$ 的测试案例的计算作为一个零检验，其正确地得出 $\\delta M=0$，因此可恢复性为 `true`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all specified test cases.\n    \"\"\"\n    # Physical constants\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    C = 299792458.0   # Speed of light in m/s\n    M_SOLAR = 1.98847e30  # Solar mass in kg\n\n    # Power Spectral Density (PSD) parameters\n    S0 = 1e-46  # Hz^-1\n    f0 = 100.0  # Hz\n\n    # Test suite from the problem statement\n    # Each tuple is (M_solar, eta, beta, b, f_low, rho_target)\n    test_cases = [\n        (40.0, 0.25, 1e-3, -1.0, 20.0, 25.0),\n        (40.0, 0.25, 0.0, -1.0, 20.0, 25.0),\n        (80.0, 0.25, 1e-3, -1.0, 20.0, 25.0),\n        (30.0, 0.25, 1e-5, 2.0, 20.0, 25.0),\n        (40.0, 0.25, 1e-3, -1.0, 20.0, 8.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        is_recoverable = calculate_bias_and_uncertainty(\n            params, G, C, M_SOLAR, S0, f0\n        )\n        results.append(str(is_recoverable).lower())\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_bias_and_uncertainty(params, G, C, M_SOLAR, S0, f0):\n    \"\"\"\n    Calculates the mass bias and uncertainty for a single set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (M_solar, eta, beta, b, f_low, rho_target).\n        G (float): Gravitational constant.\n        C (float): Speed of light.\n        M_SOLAR (float): Solar mass in kg.\n        S0 (float): PSD normalization constant.\n        f0 (float): PSD characteristic frequency.\n\n    Returns:\n        bool: True if |delta_M| = sigma_M, False otherwise.\n    \"\"\"\n    M_sol, eta, beta, b, f_low, rho_target = params\n    M_kg = M_sol * M_SOLAR\n\n    # Calculate derived astrophysical quantities\n    M_sec = G * M_kg / (C**3)\n    Mc_sec = eta**(3/5) * M_sec\n    f_isco = C**3 / (6**(3/2) * np.pi * G * M_kg)\n    f_high = f_isco\n\n    # Set up a high-resolution frequency grid for numerical integration\n    num_points = 32768\n    freqs = np.linspace(f_low, f_high, num_points)\n\n    # Calculate model components over the frequency grid\n    \n    # 1. Noise Power Spectral Density (PSD)\n    Sn = S0 * ((f0 / freqs)**4 + 1 + (freqs / f0)**2)\n    \n    # 2. Amplitude taper window\n    delta_taper = 0.1 * f_isco\n    W_amp = 1.0 / (1.0 + np.exp((freqs - f_isco) / delta_taper))\n\n    # 3. Un-normalized amplitude squared (A_unnorm^2)\n    # A_unnorm = f^{-7/6} * W_amp\n    A_unnorm_sq = (freqs**(-7/6) * W_amp)**2\n\n    # 4. General Relativity phase and its derivative with respect to total mass M\n    term_in_phi = np.pi * freqs * Mc_sec\n    # Avoid division by zero if term_in_phi is zero (at f=0, which is excluded)\n    # The phase is only calculated where term_in_phi > 0.\n    phi_GR = (3.0 / 128.0) * term_in_phi**(-5.0/3.0)\n    dphi_dM = -(5.0 / (3.0 * M_kg)) * phi_GR\n\n    # 5. pPE phase injection\n    delta_phi = beta * (np.pi * freqs * M_sec)**b * W_amp\n\n    # Construct integrands for bias and uncertainty calculations\n    # This is the common weighting factor, proportional to |A_unnorm|^2/Sn\n    integrand_common_weight = A_unnorm_sq / Sn\n    \n    # Numerator for bias calculation: (dphi_dM * delta_phi * weight)\n    integrand_bias_num = dphi_dM * delta_phi * integrand_common_weight\n    \n    # Denominator for bias calculation: (dphi_dM^2 * weight)\n    integrand_bias_den = dphi_dM**2 * integrand_common_weight\n\n    # Perform numerical integrations using the trapezoidal rule\n    bias_num_integral = np.trapz(integrand_bias_num, freqs)\n    bias_den_integral = np.trapz(integrand_bias_den, freqs)\n\n    # Calculate the mass bias in kg\n    # The full formulas have a '4' from the inner product, which cancels.\n    if bias_den_integral == 0:\n        delta_M_kg = 0.0\n    else:\n        delta_M_kg = bias_num_integral / bias_den_integral\n\n    # Calculate the statistical uncertainty in mass\n    # First, find the squared SNR of the un-normalized waveform\n    # rho_0^2 = 4 * integral(A_unnorm^2 / Sn df)\n    snr_sq_unnorm = 4.0 * np.trapz(integrand_common_weight, freqs)\n    \n    # Fisher matrix element Gamma_MM\n    # Gamma = rho_target^2 / rho_0^2 * (4 * integral(dphi_dM^2 * |A_unnorm|^2 / Sn df))\n    if snr_sq_unnorm > 0:\n        Gamma_MM = (rho_target**2 / snr_sq_unnorm) * (4.0 * bias_den_integral)\n    else:\n        Gamma_MM = 0.0\n\n    # 1-sigma uncertainty in kg\n    if Gamma_MM > 0:\n        sigma_M_kg = Gamma_MM**(-0.5)\n    else:\n        # Effectively infinite uncertainty if Gamma is zero\n        sigma_M_kg = float('inf')\n\n    # Convert results from kg to solar masses\n    delta_M_solar = delta_M_kg / M_SOLAR\n    sigma_M_solar = sigma_M_kg / M_SOLAR\n\n    # Evaluate the recoverability criterion\n    return abs(delta_M_solar) = sigma_M_solar\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3488821"}]}