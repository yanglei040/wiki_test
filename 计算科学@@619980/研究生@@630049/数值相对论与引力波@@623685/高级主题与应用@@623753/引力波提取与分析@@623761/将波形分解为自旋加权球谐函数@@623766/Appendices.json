{"hands_on_practices": [{"introduction": "要将引力波信号分解为不同的模式，我们需要计算信号与自旋权球谐函数基函数的内积，这在数学上对应于球面上的积分。虽然简单的均匀网格可以近似这个积分，但一种更高效且精确的方法是设计一个对于基函数本身（直到某个阶数）能够实现精确积分的求积法则。本练习将指导您推导并实现这样一个理想的求积方案——即在极角方向使用高斯-勒让德求积，在方位角方向使用梯形法则——这是构建高精度谱方法的基础。[@problem_id:3471575]", "problem": "您的任务是构建并验证一个在单位$2$-球面$S^2$上的数值求积方法，该方法能精确积分直到某个最大谐波阶数的自旋权重球谐函数的内积。您的程序必须实现一个以下形式的张量积求积：在极角上使用Gauss–Legendre求积，在方位角上使用等距梯形法则。目标是通过第一性原理推导，确定保证精确计算带限达到指定值的自旋权重球谐函数所有内积所需的最少采样点数，并通过一个小规模测试套件在数值上验证其精确性。所有角度都必须以弧度为单位。\n\n使用的定义和基本事实：\n- 自旋权重球谐函数 ${}_sY_{\\ell m}(\\theta,\\phi)$ 是 $S^2$ 上的本征函数，它将标量球谐函数推广到自旋权重 $s \\in \\mathbb{Z}$ 的情况。对于任意固定的自旋权重 $s$，它们满足正交归一关系\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^\\pi {}_sY_{\\ell m}(\\theta,\\phi)\\,{}_sY_{\\ell' m'}^*(\\theta,\\phi)\\,\\sin\\theta\\,d\\theta\\,d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- 该内积积分可以分解为一个涉及复指数 $e^{i m \\phi}$ 的方位角（$\\phi$）部分和一个涉及相关角度依赖性的极角（$\\theta$）部分。当使用足够多的点时，$\\phi$ 上的均匀梯形法则可以精确积分直到给定最高频率的所有复指数 $e^{i n \\phi}$。在 $x=\\cos\\theta$ 上的Gauss–Legendre求积可以精确积分次数由节点数决定的 $x$ 的多项式。\n- 对于受限于 $\\ell\\le\\ell_{\\max}$ 的自旋权重球谐函数的乘积，其方位角依赖性的带限频率为 $|m|\\le\\ell_{\\max}$，而其极角依赖性（在变量替换 $x=\\cos\\theta$ 后）可以表示为 $x$ 的一个最高次数为 $2\\ell_{\\max}$ 的多项式。\n\n任务：\n1. 根据上述基本事实，推导使得张量积求积能够精确积分所有满足 $|s|\\le \\ell\\le\\ell_{\\max}$ 和 $-\\ell\\le m\\le \\ell$ 的 ${}_sY_{\\ell m}$ 和 ${}_sY_{\\ell' m'}^*$ 的内积所需的最少方位角采样点数 $N_\\phi$ 和极角采样点数 $N_\\theta$。推导过程应是纯数学的，并且不应依赖于所述基本事实之外的捷径公式。所有角度的单位均为弧度。\n2. 实现一个程序，该程序能够：\n   - 构建对应于 $\\theta=\\arccos x$ 的在 $x\\in[-1,1]$ 上的 $N_\\theta$ 阶Gauss–Legendre求积。\n   - 在 $[0,2\\pi)$ 上构建一个包含 $N_\\phi$ 个点的等距方位角网格，并使用均匀权重（梯形法则）。\n   - 使用Wigner small-$d$ 矩阵表示来计算 ${}_sY_{\\ell m}(\\theta,\\phi)$，并通过计算离散求积和来验证内积的数值精确性：\n   $$\n   \\sum_{k=0}^{N_\\phi-1} w_\\phi \\sum_{i=1}^{N_\\theta} w_{\\theta,i}\\;{}_sY_{\\ell m}(\\theta_i,\\phi_k)\\;{}_sY_{\\ell' m'}^*(\\theta_i,\\phi_k),\n   $$\n   并将其与 $\\delta_{\\ell\\ell'}\\,\\delta_{mm'}$ 进行比较。您的程序必须限制在 $\\ell\\ge |s|$ 的情况下，因为在其他情况下 ${}_sY_{\\ell m}$ 为零。\n3. 对于测试套件中的每个测试，您的程序必须报告：\n   - 从第1项推导中得出的最少采样点数 $N_{\\text{points}}=N_\\theta N_\\phi$。\n   - 在所有测试内积中的最大绝对误差，计算方式为离散求积值与精确的克罗内克δ值之间的最大绝对差。\n\n测试套件参数：\n- 使用以下 $(\\ell_{\\max},s)$ 对来测试不同的区域：\n  - $(\\ell_{\\max},s)=(0,0)$。\n  - $(\\ell_{\\max},s)=(2,-2)$。\n  - $(\\ell_{\\max},s)=(3,1)$。\n  - $(\\ell_{\\max},s)=(4,0)$。\n所有角度都必须以弧度为单位。使用适合双精度的数值容差，并确保验证过程比较的是浮点值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，结果聚合为一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[N_{\\text{points}},\\varepsilon]$ 形式的二元列表，其中 $N_{\\text{points}}$ 是一个整数，$\\varepsilon$ 是一个等于上述指定最大绝对误差的浮点数。例如：$[[N_1,\\varepsilon_1],[N_2,\\varepsilon_2],[N_3,\\varepsilon_3],[N_4,\\varepsilon_4]]$。", "solution": "任务是确定精确积分带限为 $\\ell_{\\max}$ 的自旋权重球谐函数 ${}_sY_{\\ell m}$ 内积所需的最少求积点数，并对这一发现进行数值验证。指定的求积方法是极角 $\\theta$ 上的Gauss-Legendre法则和方位角 $\\phi$ 上的等距梯形法则的张量积。\n\n正交归一性积分由下式给出：\n$$\nI = \\int_0^{2\\pi} d\\phi \\int_0^\\pi d\\theta \\, \\sin\\theta \\, {}_sY_{\\ell m}(\\theta,\\phi) \\, {}_sY_{\\ell' m'}^*(\\theta,\\phi) = \\delta_{\\ell\\ell'} \\delta_{mm'}\n$$\n我们将首先根据问题陈述中提供的基本事实，推导所需的最少点数 $N_\\phi$ 和 $N_\\theta$。\n\n**最少求积点数的推导**\n\n推导过程通过分别分析积分的方位角和极角部分来进行。\n\n**1. 方位角求积 ($N_\\phi$)**\n\n自旋权重球谐函数的形式为 ${}_sY_{\\ell m}(\\theta,\\phi) \\propto d^\\ell_{m,s}(\\theta) e^{im\\phi}$，其中 $d^\\ell_{m,s}(\\theta)$ 是Wigner small-d矩阵。因此，被积函数 ${}_sY_{\\ell m}(\\theta,\\phi)\\,{}_sY_{\\ell' m'}^*(\\theta,\\phi)$ 的方位角依赖性形式为 $e^{im\\phi} (e^{im'\\phi})^* = e^{i(m-m')\\phi}$。\n\n问题要求使用一个单一的求积网格，该网格对所有满足 $\\ell, \\ell' \\le \\ell_{\\max}$ 的内积都是精确的。谐波指数 $m$ 和 $m'$ 受限于 $|m| \\le \\ell \\le \\ell_{\\max}$ 和 $|m'| \\le \\ell' \\le \\ell_{\\max}$。方位角被积函数的频率为 $k = m-m'$。因此，可能的频率范围是：\n$$\n-\\ell_{\\max} - \\ell_{\\max} \\le m - m' \\le \\ell_{\\max} - (-\\ell_{\\max}) \\implies -2\\ell_{\\max} \\le k \\le 2\\ell_{\\max}\n$$\n我们必须选择梯形法则的点数 $N_\\phi$，以精确积分在 $[-2\\ell_{\\max}, 2\\ell_{\\max}]$ 范围内的所有整数频率 $k$ 的任何形式为 $e^{ik\\phi}$ 的函数。\n\n积分 $\\int_0^{2\\pi} f(\\phi) d\\phi$ 的 $N_\\phi$ 点梯形法则近似为 $\\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} f(\\phi_j)$，其中 $\\phi_j = 2\\pi j / N_\\phi$。对于函数 $f(\\phi) = e^{ik\\phi}$，其精确积分为 $\\int_0^{2\\pi} e^{ik\\phi} d\\phi = 2\\pi \\delta_{k0}$。数值求积得出：\n$$\n\\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} e^{ik(2\\pi j/N_\\phi)} = \\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} \\left(e^{i2\\pi k/N_\\phi}\\right)^j\n$$\n如果 $k$ 是 $N_\\phi$ 的整数倍，这个几何级数的和为 $N_\\phi$，否则为 $0$。因此，如果 $k=p N_\\phi$（其中 $p$ 为某个整数），则数值积分的计算结果为 $2\\pi$，否则为 $0$。\n\n为了使求积对所有频率 $|k| \\le 2\\ell_{\\max}$ 都精确，其结果必须与真实的积分值匹配（当 $k=0$ 时为 $2\\pi$，否则为 $0$）。这要求我们范围内的任何非零频率都不是 $N_\\phi$ 的倍数。如果对于范围内的所有非零 $k$ 都有 $|k|  N_\\phi$，则该条件得到满足。最大频率幅值为 $2\\ell_{\\max}$。因此，我们必须有 $N_\\phi > 2\\ell_{\\max}$。最少的整数点数是：\n$$\nN_\\phi = 2\\ell_{\\max} + 1\n$$\n\n**2. 极角求积 ($N_\\theta$)**\n\n极角积分的形式为 $\\int_0^\\pi F(\\theta) \\sin\\theta d\\theta$。经过变量替换 $x = \\cos\\theta$, $dx = -\\sin\\theta d\\theta$ 后，积分变为 $\\int_{-1}^1 F(\\arccos x) dx$。\n\n问题陈述指出，被积函数的极角部分与乘积 $d^\\ell_{m,s}(\\theta) d^{\\ell'}_{m',s}(\\theta)$ 成正比，由于 $\\ell, \\ell' \\le \\ell_{\\max}$，它可以表示为 $x = \\cos\\theta$ 的一个最高次数为 $2\\ell_{\\max}$ 的多项式。\n\n一个具有 $N_\\theta$ 个点（节点）的Gauss-Legendre求积被设计用来精确积分最高次数为 $2N_\\theta - 1$ 的任意多项式。为了保证对我们的被积函数的精确性，该法则能处理的多项式次数必须至少等于我们被积函数多项式的最大次数。这给出了条件：\n$$\n2N_\\theta - 1 \\ge 2\\ell_{\\max}\n$$\n解出 $N_\\theta$ 可得 $2N_\\theta \\ge 2\\ell_{\\max} + 1$，即 $N_\\theta \\ge \\ell_{\\max} + 1/2$。由于 $N_\\theta$ 必须是整数，最少的极角求积点数为：\n$$\nN_\\theta = \\ell_{\\max} + 1\n$$\n\n总而言之，为精确积分所有满足 $\\ell, \\ell' \\le \\ell_{\\max}$ 的内积所需的最少求积点数为 $N_\\theta = \\ell_{\\max} + 1$ 和 $N_\\phi = 2\\ell_{\\max} + 1$。球面上的总点数为 $N_{\\text{points}} = N_\\theta N_\\phi = (\\ell_{\\max}+1)(2\\ell_{\\max}+1)$。\n\n**数值实现与验证**\n\n验证算法的结构如下：\n1. 对于给定的测试用例 $(\\ell_{\\max}, s)$，计算所需的最小网格尺寸 $N_\\theta = \\ell_{\\max} + 1$ 和 $N_\\phi = 2\\ell_{\\max} + 1$。\n2. 构建求积网格。$N_\\theta$ 个极角 $\\theta_i$ 和权重 $w_{\\theta, i}$ 是从 $x \\in [-1,1]$ 上的 $N_\\theta$ 点Gauss-Legendre求积的节点和权重导出的。节点 $x_i$ 给出 $\\theta_i = \\arccos(x_i)$，权重 $w_{\\theta,i}$ 被直接使用。$N_\\phi$ 个方位角为 $\\phi_k = 2\\pi k / N_\\phi$，其中 $k=0, \\dots, N_\\phi-1$，具有均匀权重 $w_\\phi = 2\\pi/N_\\phi$。\n3. 实现一个计算 ${}_sY_{\\ell m}(\\theta,\\phi)$ 的函数。这基于Wigner small-d矩阵表示：\n    $$\n    {}_sY_{\\ell m}(\\theta,\\phi) = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi}\n    $$\n    Wigner函数 $d^\\ell_{m,s}(\\theta)$ 使用其显式求和公式计算。为了在使用阶乘项时保持数值稳定性，计算使用对数伽马函数（`gammaln`）进行。\n4. 遍历所有有效的模式组合：$\\ell, \\ell' \\in [|s|, \\ell_{\\max}]$ 和 $m \\in [-\\ell, \\ell], m' \\in [-\\ell', \\ell']$。\n5. 对于每个组合 $(\\ell, m, \\ell', m')$，通过在求积网格上求和来计算数值内积：\n    $$\n    I_{\\text{numeric}} = w_\\phi \\sum_{k=0}^{N_\\phi-1} \\sum_{i=1}^{N_\\theta} w_{\\theta,i}\\;{}_sY_{\\ell m}(\\theta_i,\\phi_k)\\;{}_sY_{\\ell' m'}^*(\\theta_i,\\phi_k)\n    $$\n6. 将 $I_{\\text{numeric}}$ 与精确解析值 $I_{\\text{exact}} = \\delta_{\\ell\\ell'}\\,\\delta_{mm'}$ 进行比较。记录绝对误差 $|I_{\\text{numeric}} - I_{\\text{exact}}|$。\n7. 对于该测试用例，报告在所有模式组合中发现的最大绝对误差，以及网格总点数 $N_{\\text{points}} = N_\\theta N_\\phi$。预期误差应在浮点机器精度量级，从而证实求积的精确性。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, gammaln\nimport math\n\ndef wigner_d(l, m, s, theta):\n    \"\"\"\n    Computes the Wigner small-d matrix d^l_{m,s}(theta) using the summation formula.\n    Numerically stable implementation using log-gamma for factorials.\n    The angles theta are expected in radians.\n    \"\"\"\n    if np.abs(m) > l or np.abs(s) > l:\n        return np.zeros_like(theta)\n\n    # Use log-gamma to handle large numbers from factorials.\n    # gammaln(n+1) = log(n!)\n    log_prefactor = 0.5 * (gammaln(l + m + 1) + gammaln(l - m + 1) + gammaln(l + s + 1) + gammaln(l - s + 1))\n\n    # Summation range for k\n    k_min = int(max(0, s - m))\n    k_max = int(min(l + s, l - m))\n\n    d_values = np.zeros_like(theta, dtype=float)\n    \n    # Pre-compute trigonometric terms\n    cos_theta_half = np.cos(theta / 2.0)\n    sin_theta_half = np.sin(theta / 2.0)\n    \n    for k in range(k_min, k_max + 1):\n        log_term = (\n            log_prefactor\n            - gammaln(k + 1)\n            - gammaln(l + s - k + 1)\n            - gammaln(l - m - k + 1)\n            - gammaln(m - s + k + 1)\n        )\n        \n        # Power terms. Special handling for base=0 to avoid log(0).\n        # Since theta is from arccos of Legendre roots in (-1,1), theta is in (0,pi).\n        # cos_theta_half and sin_theta_half will be in (0,1).\n        pow1 = 2 * l + s - m - 2 * k\n        pow2 = m - s + 2 * k\n        \n        log_term += pow1 * np.log(cos_theta_half)\n        log_term += pow2 * np.log(sin_theta_half)\n\n        term = (-1)**k * np.exp(log_term)\n        d_values += term\n        \n    return d_values\n\ndef sYlm(s, l, m, theta, phi):\n    \"\"\"\n    Computes spin-weighted spherical harmonic sYlm on a grid of (theta, phi).\n    theta is a 1D array of size N_theta.\n    phi is a 1D array of size N_phi.\n    Returns a 2D array of shape (N_theta, N_phi).\n    \"\"\"\n    norm = math.sqrt((2 * l + 1) / (4 * np.pi))\n    d_vals = wigner_d(l, m, s, theta)\n    exp_vals = np.exp(1j * m * phi)\n    \n    # Use broadcasting to form the 2D grid of Y_lm values\n    return norm * d_vals[:, np.newaxis] * exp_vals[np.newaxis, :]\n\ndef run_verification(l_max, s):\n    \"\"\"\n    Performs the full verification for a given (l_max, s) pair.\n    \"\"\"\n    # 1. Determine minimal grid sizes from derivation\n    if l_max  abs(s): # No valid modes exist\n        return [1, 0.0]\n        \n    n_theta = l_max + 1\n    n_phi = 2 * l_max + 1\n    \n    if l_max == 0:\n        n_phi = 1 # special case, 2*0+1 = 1\n        \n    n_points = n_theta * n_phi\n\n    # 2. Construct quadrature grid and weights\n    # Polar grid (Gauss-Legendre)\n    x_nodes, w_theta = roots_legendre(n_theta)\n    theta_nodes = np.arccos(x_nodes)  # in radians\n\n    # Azimuthal grid (Trapezoidal)\n    phi_nodes = np.linspace(0, 2 * np.pi, n_phi, endpoint=False)\n    w_phi = 2 * np.pi / n_phi\n\n    # 3. Iterate over all mode pairs and check orthonormality\n    max_abs_error = 0.0\n    l_values = range(abs(s), l_max + 1)\n\n    Y_lm_cache = {}\n    \n    for l1 in l_values:\n        for m1 in range(-l1, l1 + 1):\n            if (l1, m1) not in Y_lm_cache:\n                Y_lm_cache[(l1, m1)] = sYlm(s, l1, m1, theta_nodes, phi_nodes)\n            Y1 = Y_lm_cache[(l1, m1)]\n            \n            for l2 in l_values:\n                for m2 in range(-l2, l2 + 1):\n                    if (l2, m2) not in Y_lm_cache:\n                         Y_lm_cache[(l2, m2)] = sYlm(s, l2, m2, theta_nodes, phi_nodes)\n                    Y2 = Y_lm_cache[(l2, m2)]\n\n                    # Compute integrand\n                    integrand = Y1 * np.conj(Y2)\n\n                    # Perform quadrature\n                    # Sum over theta (axis=0) using Gauss-Legendre weights\n                    integral_over_theta = np.sum(integrand * w_theta[:, np.newaxis], axis=0)\n                    \n                    # Sum over phi (remaining axis) using trapezoidal weight\n                    numerical_inner_product = np.sum(integral_over_theta) * w_phi\n\n                    exact_value = 1.0 if (l1 == l2 and m1 == m2) else 0.0\n                    \n                    error = np.abs(numerical_inner_product - exact_value)\n                    if error > max_abs_error:\n                        max_abs_error = error\n    \n    return [n_points, max_abs_error]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0, 0),\n        (2, -2),\n        (3, 1),\n        (4, 0),\n    ]\n\n    results_for_print = []\n    for l_max, s in test_cases:\n        n_points, max_err = run_verification(l_max, s)\n        results_for_print.append(f\"[{n_points},{max_err}]\")\n\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n\n```", "id": "3471575"}, {"introduction": "在掌握了精确的数值投影方法之后，我们来探讨一个在实际应用中至关重要的问题：谱泄漏（spectral leakage）。当一个连续信号在有限的离散网格上被采样时，一个模式的能量会“泄漏”到其他模式的系数中，从而产生虚假的信号成分。本练习旨在量化这一效应，并引入窗函数（windowing functions）这一标准技术，以有效抑制谱泄漏，从而提高球谐函数分解的保真度。[@problem_id:3471549]", "problem": "您的任务是量化将一个纯自旋加权球谐函数信号投影到有限网格上时的球谐函数泄漏。在数值相对论的引力波提取中，球面上的复应变被分解为自旋权重为 $s=-2$ 的自旋加权球谐函数。自旋加权球谐函数 $\\ {}_sY_{\\ell m}(\\theta,\\phi)$ 在由球面测度导出的内积下，构成二维球面上的一个标准正交基，在连续统中，\n$$\n\\int_0^{2\\pi}\\int_0^\\pi\\ {}_sY_{\\ell m}(\\theta,\\phi)\\ {}_sY_{\\ell' m'}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi = \\delta_{\\ell \\ell'}\\delta_{m m'}.\n$$\n信号的有限分辨率采样和加窗会改变有效内积，并可能导致功率泄漏到相邻的 $(\\ell,m)$ 模态中。\n\n从一个复场 $f(\\theta,\\phi)$ 展开式中模态 $(\\ell,m)$ 的系数由内积得到这一基本定义出发：\n$$\nc_{\\ell m} = \\int_0^{2\\pi}\\int_0^\\pi f(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ \\sin\\theta\\ d\\theta\\ d\\phi,\n$$\n您必须使用矩形求积法，在一个余纬和方位角均为均匀的网格上，并对余纬进行中点采样，来近似此积分。具体来说，设 $N_\\theta$ 和 $N_\\phi$ 分别表示余纬和方位角的采样点数。定义 $\\Delta\\theta = \\pi/N_\\theta$ 和 $\\Delta\\phi = 2\\pi/N_\\phi$，余纬中点采样点为 $\\theta_i = (i+1/2)\\Delta\\theta$（其中 $i=0,\\dots,N_\\theta-1$），方位角采样点为 $\\phi_j = j\\Delta\\phi$（其中 $j=0,\\dots,N_\\phi-1$）。于是，$c_{\\ell m}$ 的离散近似为\n$$\nc_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f(\\theta_i,\\phi_j)\\ {}_sY_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.\n$$\n\n考虑纯输入信号\n$$\nf(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi),\n$$\n并在投影前将窗函数 $w(\\theta)$ 乘到信号上，得到 $f_w(\\theta,\\phi) = w(\\theta)\\ f(\\theta,\\phi)$。该窗函数仅在余纬方向上起作用。需要考虑的窗函数有：\n- 矩形窗：$w(\\theta) = 1$。\n- 余纬方向的汉宁窗：令 $x = \\theta/\\pi$，则 $w(\\theta) = \\tfrac{1}{2}\\big(1 - \\cos(2\\pi x)\\big)$。\n- 余纬方向的图基窗，参数为 $\\alpha\\in(0,1]$：令 $x=\\theta/\\pi$，\n$$\nw(\\theta) = \\begin{cases}\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2x}{\\alpha} - 1\\right)\\right)\\right],  0 \\le x  \\tfrac{\\alpha}{2},\\\\\n1,  \\tfrac{\\alpha}{2} \\le x \\le 1 - \\tfrac{\\alpha}{2},\\\\\n\\tfrac{1}{2}\\left[1 + \\cos\\left(\\pi\\left(\\tfrac{2(1-x)}{\\alpha} - 1\\right)\\right)\\right],  1 - \\tfrac{\\alpha}{2}  x \\le 1.\n\\end{cases}\n$$\n\n对于每个指定的采样网格和窗函数，使用以弧度为单位的角度，计算边带模态 $(\\ell,m)\\in\\{(2,1),(3,2),(4,4)\\}$ 的离散投影系数 $c_{\\ell m}$。将每个模态的边带功率分数定义为\n$$\nP_{\\ell m} = \\frac{|c_{\\ell m}|^2}{|c_{2,2}|^2},\n$$\n其中分子和分母都在相同的采样和加窗配置下计算。分母使用 $(\\ell,m)=(2,2)$ 模态。\n\n您必须使用标准的维格纳小d函数构造和方位相位来实现自旋加权球谐函数 $\\ {}_sY_{\\ell m}(\\theta,\\phi)$，并按上文规定执行离散求和。所有角度均以弧度为单位。\n\n测试套件：\n使用以下参数值集合 $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$：\n1. $(64, 128, \\text{rect}, 0.0)$\n2. $(8, 16, \\text{rect}, 0.0)$\n3. $(64, 128, \\text{hann\\_theta}, 0.0)$\n4. $(128, 256, \\text{tukey\\_theta}, 0.25)$\n\n对于每个测试用例，按顺序计算并返回三个边带功率分数 $P_{2,1}$、$P_{3,2}$ 和 $P_{4,4}$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表应按顺序将所有测试用例的结果展平，三个测试用例共产生九个条目，四个测试用例共产生十二个条目。例如，最终输出格式必须为\n$$\n[ P_{2,1}^{(1)}, P_{3,2}^{(1)}, P_{4,4}^{(1)}, P_{2,1}^{(2)}, P_{3,2}^{(2)}, P_{4,4}^{(2)}, \\dots ].\n$$\n所有计算值都必须是浮点数。所有角度都必须以弧度处理。此计算不涉及任何物理单位。通过使用维格纳小d函数构造正确实现自旋加权球谐函数，并使用指定的求积方案，以确保数值稳定性和科学真实性。", "solution": "用户的问题要求计算在不同加窗方案下，将一个纯自旋加权球谐函数信号数值投影到有限网格上时产生的边带功率分数。这是数值相对论引力波信号分析中的一个标准问题，其中由于有限分辨率和加窗引起的频谱泄漏会破坏提取出的模态内容。该问题具有科学依据、是适定的，并且其所有组成部分都有形式化定义。因此，这是一个有效的问题。\n\n该解决方案通过以下主要步骤实现：\n1.  **问题分解**：核心任务是计算内积积分 $$c_{\\ell m} = \\int_{S^2} f_w(\\theta,\\phi)\\ {}_sY_{\\ell m}^*(\\theta,\\phi)\\ d\\Omega,$$ 的离散近似，其中 $d\\Omega = \\sin\\theta\\ d\\theta\\ d\\phi$。引力波应变的自旋权重为 $s=-2$。输入信号是一个纯模态 $f(\\theta,\\phi) = {}_{-2}Y_{2,2}(\\theta,\\phi)$，然后将其乘以一个依赖于余纬的窗函数 $w(\\theta)$，得到 $f_w(\\theta,\\phi) = w(\\theta)f(\\theta,\\phi)$。\n2.  **数值求积**：$c_{\\ell m}$ 的积分使用均匀网格上的矩形求积法则进行近似。网格在余纬 $\\theta$ 方向上有 $N_\\theta$ 个点，在方位角 $\\phi$ 方向上有 $N_\\phi$ 个点。网格点为 $\\theta_i = (i+1/2)\\Delta\\theta$（其中 $i \\in \\{0, \\dots, N_\\theta-1\\}$）和 $\\phi_j = j\\Delta\\phi$（其中 $j \\in \\{0, \\dots, N_\\phi-1\\}$），其中 $\\Delta\\theta = \\pi/N_\\theta$ 且 $\\Delta\\phi = 2\\pi/N_\\phi$。离散化后的系数为\n    $$c_{\\ell m} \\approx \\sum_{i=0}^{N_\\theta-1}\\sum_{j=0}^{N_\\phi-1} f_w(\\theta_i,\\phi_j)\\ {}_{-2}Y_{\\ell m}^*(\\theta_i,\\phi_j)\\ \\sin\\theta_i\\ \\Delta\\theta\\ \\Delta\\phi.$$\n    对 $\\theta$ 使用中点采样避免了在极点（$\\theta=0,\\pi$）处的奇点。\n3.  **自旋加权球谐函数的实现**：一个关键部分是自旋加权球谐函数 ${}_sY_{\\ell m}(\\theta,\\phi)$ 的数值计算。它们定义为\n    $${}_sY_{\\ell m}(\\theta,\\phi) = (-1)^s \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,s}(\\theta) e^{im\\phi},$$\n    其中 $d^\\ell_{m,s}(\\theta)$ 是维格纳小d函数。为确保对于所需的适中 $\\ell$ 值的计算具有正确性和数值稳定性，我们选择了一种基于维格纳-克莱布施-戈登级数（维格纳公式）的实现方法。我们使用了来自 Varshalovich, Moskalev,  Khersonskii 的公式来计算 $d^\\ell_{m',m}(\\beta)$ 函数，并在我们的用例中将其映射为 $(m', m) \\to (m, s)$：\n    $$d^\\ell_{m,s}(\\theta) = \\left[ (\\ell+m)!(\\ell-m)!(\\ell+s)!(\\ell-s)! \\right]^{1/2} \\sum_z \\frac{(-1)^z}{z!(m-s+z)!(\\ell-m-z)!(\\ell+s-z)!} (\\cos(\\theta/2))^{2\\ell+s-m-2z}(\\sin(\\theta/2))^{m-s+2z}.$$\n    对 $z$ 的求和包括所有使阶乘参数为非负的整数值。这可以表示为从 $z_{min} = \\max(0, s-m)$到 $z_{max} = \\min(\\ell-m, \\ell+s)$ 的求和。为处理阶乘中潜在的大数，我们使用 `scipy.special.gammaln` 计算它们的对数，其中 $\\ln(n!) = \\text{gammaln}(n+1)$。\n4.  **投影核**：投影需要复共轭 ${}_{-2}Y_{\\ell m}^*(\\theta,\\phi)$。鉴于维格纳d函数是实数，我们有\n    $${}_{-2}Y_{\\ell m}^*(\\theta, \\phi) = (-1)^{-2} \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi} = \\sqrt{\\frac{2\\ell+1}{4\\pi}} d^\\ell_{m,-2}(\\theta) e^{-im\\phi}.$$\n    这通过计算 ${}_{-2}Y_{\\ell m}$ 然后取其复共轭来实现。\n5.  **窗函数**：指定的窗函数（矩形窗、汉宁窗和图基窗）被实现为余纬 $\\theta$ 的函数。图基窗由 $\\alpha$ 参数化。\n6.  **功率分数计算**：对于由 $(N_\\theta, N_\\phi, \\text{window}, \\alpha)$ 指定的每个测试用例，过程如下：\n    a. 生成一个 $(\\theta, \\phi)$ 值的二维网格。\n    b. 在此网格上计算输入信号 $f(\\theta,\\phi)$ 和模态 $(\\ell,m) \\in \\{(2,1),(3,2),(4,4),(2,2)\\}$ 的投影核 ${}_{-2}Y_{\\ell m}^*$。\n    c. 将适当的窗函数 $w(\\theta)$ 应用于输入信号。\n    d. 计算系数 $c_{\\ell m}$ 的离散和。\n    e. 计算边带功率分数 $P_{\\ell m} = |c_{\\ell m}|^2 / |c_{2,2}|^2$，其中 $(\\ell,m) \\in \\{(2,1),(3,2),(4,4)\\}$。\n7.  **执行**：一个主函数遍历所提供的测试套件，为每个用例调用一个子程序执行计算，并将结果汇总到一个列表中，以便按指定格式进行最终输出。\n\n因此，该算法设计是问题陈述中数学规定的直接而稳健的实现，使用了适合该学科的、数值稳定的标准技术。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef wigner_d(l, m1, m2, theta):\n    \"\"\"\n    Computes the Wigner small-d function d^l_{m1,m2}(theta) using the\n    summation formula from Varshalovich, Moskalev,  Khersonskii.\n    This implementation uses logarithms of factorials for numerical stability.\n    \"\"\"\n    # Wigner d-functions are defined for |m1| = l and |m2| = l.\n    if abs(m1) > l or abs(m2) > l:\n        return np.zeros_like(np.asarray(theta), dtype=float)\n\n    # Convert theta to a numpy array to handle scalar and array inputs uniformly.\n    theta = np.asarray(theta)\n    \n    # Summation limits for z\n    z_min = max(0, m2 - m1)\n    z_max = min(l - m1, l + m2)\n    \n    # Pre-compute the logarithm of the constant square-root factor.\n    log_sqrt_factor = 0.5 * (gammaln(l + m1 + 1) + gammaln(l - m1 + 1) +\n                             gammaln(l + m2 + 1) + gammaln(l - m2 + 1))\n    \n    # Initialize the result array.\n    d_val = np.zeros_like(theta, dtype=float)\n    \n    cos_half_theta = np.cos(theta / 2.0)\n    sin_half_theta = np.sin(theta / 2.0)\n    \n    for z in range(z_min, z_max + 1):\n        # Logarithm of the denominator in the summation term\n        log_denom_z = (gammaln(z + 1) +\n                       gammaln(m1 - m2 + z + 1) +\n                       gammaln(l - m1 - z + 1) +\n                       gammaln(l + m2 - z + 1))\n        \n        # Logarithm of the z-th term's coefficient\n        log_C_z = log_sqrt_factor - log_denom_z\n        C_z = np.exp(log_C_z)\n        \n        # Power exponents for cos and sin terms\n        pow_cos = 2 * l + m2 - m1 - 2 * z\n        pow_sin = m1 - m2 + 2 * z\n        \n        # The grid for theta avoids 0 and pi, so cos_half_theta and sin_half_theta are non-zero.\n        # This prevents issues with 0**negative_power.\n        term_z = C_z * (cos_half_theta**pow_cos) * (sin_half_theta**pow_sin)\n        \n        d_val += (-1)**z * term_z\n            \n    return d_val\n\ndef spin_weighted_Y(s, l, m, theta, phi):\n    \"\"\"\n    Computes the spin-weighted spherical harmonic sYlm(theta, phi).\n    \"\"\"\n    if abs(m) > l or abs(s) > l:\n        if isinstance(theta, np.ndarray):\n            return np.zeros_like(theta, dtype=complex)\n        else:\n            return 0.0 + 0.0j\n\n    # In sYlm, the d-function is d^l_{m,s}. So m1=m, m2=s.\n    d_func = wigner_d(l, m, s, theta)\n    norm = np.sqrt((2 * l + 1) / (4 * np.pi))\n    phase = np.exp(1j * m * phi)\n    \n    return (-1)**s * norm * d_func * phase\n\ndef get_window_function(name, alpha, N_theta):\n    \"\"\"\n    Generates the specified window function array.\n    \"\"\"\n    theta = (np.arange(N_theta) + 0.5) * np.pi / N_theta\n    if name == 'rect':\n        return np.ones(N_theta)\n    \n    x = theta / np.pi\n    if name == 'hann_theta':\n        return 0.5 * (1 - np.cos(2 * np.pi * x))\n    elif name == 'tukey_theta':\n        w = np.ones_like(x)\n        # First section of the Tukey window\n        mask1 = x  alpha / 2.0\n        w[mask1] = 0.5 * (1 + np.cos(np.pi * (2 * x[mask1] / alpha - 1)))\n        # Last section of the Tukey window\n        mask3 = x > 1 - alpha / 2.0\n        w[mask3] = 0.5 * (1 + np.cos(np.pi * (2 * (1 - x[mask3]) / alpha - 1)))\n        return w\n    else:\n        raise ValueError(f\"Unknown window: {name}\")\n\ndef calculate_power_fractions(N_theta, N_phi, window_name, alpha):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    s = -2 # Spin weight\n    \n    # 1. Set up the grid\n    delta_theta = np.pi / N_theta\n    delta_phi = 2 * np.pi / N_phi\n    \n    theta_pts = (np.arange(N_theta) + 0.5) * delta_theta\n    phi_pts = np.arange(N_phi) * delta_phi\n    \n    theta_mesh, phi_mesh = np.meshgrid(theta_pts, phi_pts, indexing='ij')\n\n    # 2. Define the input signal on the grid\n    # f(theta, phi) = -2_Y_2,2(theta, phi)\n    input_signal_grid = spin_weighted_Y(s, 2, 2, theta_mesh, phi_mesh)\n    \n    # 3. Apply the window function\n    window = get_window_function(window_name, alpha, N_theta)\n    # Window is 1D (theta-dependent), broadcast it to the 2D grid\n    windowed_signal_grid = window[:, np.newaxis] * input_signal_grid\n    \n    # 4. Compute projection coefficients\n    modes_to_calculate = [(2, 2), (2, 1), (3, 2), (4, 4)]\n    coeffs = {}\n    \n    d_omega = np.sin(theta_mesh) * delta_theta * delta_phi\n\n    for l_val, m_val in modes_to_calculate:\n        # Kernel is the complex conjugate of sYlm\n        kernel_grid = np.conj(spin_weighted_Y(s, l_val, m_val, theta_mesh, phi_mesh))\n        \n        integrand = windowed_signal_grid * kernel_grid\n        \n        c_lm = np.sum(integrand * d_omega)\n        coeffs[(l_val, m_val)] = c_lm\n\n    # 5. Calculate power fractions\n    c_22_sq = np.abs(coeffs[(2, 2)])**2\n    \n    if c_22_sq == 0:\n        # Avoid division by zero, though it's physically unlikely here.\n        P_21 = P_32 = P_44 = np.inf\n    else:\n        P_21 = np.abs(coeffs[(2, 1)])**2 / c_22_sq\n        P_32 = np.abs(coeffs[(3, 2)])**2 / c_22_sq\n        P_44 = np.abs(coeffs[(4, 4)])**2 / c_22_sq\n        \n    return [P_21, P_32, P_44]\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the result.\n    \"\"\"\n    test_cases = [\n        (64, 128, 'rect', 0.0),\n        (8, 16, 'rect', 0.0),\n        (64, 128, 'hann_theta', 0.0),\n        (128, 256, 'tukey_theta', 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_theta, N_phi, window_name, alpha = case\n        case_results = calculate_power_fractions(N_theta, N_phi, window_name, alpha)\n        results.extend(case_results)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3471549"}, {"introduction": "最后的这个实践练习将深入探讨一个在数值相对论等非线性物理领域中更为精妙和深刻的问题。在任何数值模拟中，球谐函数级数都必须在某个最大阶数 $\\ell_{\\max}$ 处被截断。本练习旨在研究这种截断如何通过非线性模式耦合，影响我们提取的关键引力波模式（如 $(\\ell,m)=(2,2)$ 模式）的相位精度。通过这个练习，您将理解数值截断不仅是简单的信息丢失，它还会与物理方程的非线性特性相互作用，对模拟结果的物理真实性产生深远影响。[@problem_id:3471582]", "problem": "你的任务是设计并实现一个数值实验，以量化自旋权球谐函数分解中的截断如何与非线性模式耦合相互作用，从而对恢复出的主导引力波模式的相位产生偏差。实验背景是将引力波场分解为自旋权球谐函数（SWSH），这适用于数值相对论（NR）波形。\n\n从以下基本概念开始：\n- 单位球面上的一个复自旋权场 $\\,{}_s h(\\theta,\\phi)\\,$，通过球面上的内积分解为自旋权球谐函数（SWSH）$\\,{}_s Y_{\\ell m}(\\theta,\\phi)\\,$，\n$$\n{}_s h(\\theta,\\phi) \\;=\\; \\sum_{\\ell=|s|}^{\\infty}\\sum_{m=-\\ell}^{\\ell} h_{\\ell m} \\; {}_s Y_{\\ell m}(\\theta,\\phi), \n\\qquad\nh_{\\ell m} \\;=\\; \\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\,{}_s h(\\theta,\\phi)\\, {}_s Y_{\\ell m}^{*}(\\theta,\\phi)\\, \\sin\\theta \\, d\\theta \\, d\\phi.\n$$\n- 自旋权球谐函数（SWSH）在球面上是正交归一的，\n$$\n\\int {}_s Y_{\\ell m}(\\theta,\\phi) \\; {}_s Y_{\\ell' m'}^{*}(\\theta,\\phi) \\, d\\Omega \\;=\\; \\delta_{\\ell \\ell'} \\delta_{m m'},\n\\qquad d\\Omega = \\sin\\theta \\, d\\theta \\, d\\phi.\n$$\n- 对于自旋权重 $\\,s\\,$，SWSH通过维格纳小d函数 $\\,d^{\\ell}_{m m'}(\\theta)\\,$ 关联如下：\n$$\n{}_s Y_{\\ell m}(\\theta,\\phi) \\;=\\; (-1)^s \\sqrt{\\frac{2\\ell+1}{4\\pi}} \\; d^{\\ell}_{m,-s}(\\theta)\\; e^{i m \\phi}.\n$$\n所有角度必须以弧度为单位。\n\n你将模拟一个高$\\ell$信号，该信号包含一个主导的 $\\,(\\ell,m)=(2,2)\\,$ 分量以及额外的高阶多极，以引发非线性泄漏。设自旋权重为 $\\,s=-2\\,$。构造“真实”场\n$$\n{}_s h_{\\text{true}}(\\theta,\\phi) \\;=\\; \\sum_{(\\ell,m)\\in \\mathcal{C}_{\\text{true}}} A_{\\ell m} \\; {}_{-2} Y_{\\ell m}(\\theta,\\phi),\n$$\n其系数集为\n$$\n\\mathcal{C}_{\\text{true}} \\;=\\; \\left\\{ (\\ell,m,A_{\\ell m}) \\right\\} \\;=\\; \\left\\{\n(2,2,\\, 1.0\\,e^{i\\,0}),\\;\n(8,8,\\, 0.2\\, e^{i\\,\\pi/3}),\\;\n(9,7,\\, 0.15\\, e^{-i\\,\\pi/4}),\\;\n(12,10,\\, 0.1\\, e^{i\\,0.7})\n\\right\\}.\n$$\n定义一个模拟模式耦合的非线性映射，\n$$\n\\mathcal{N}_{\\alpha}[{}_s h](\\theta,\\phi) \\;=\\; {}_s h(\\theta,\\phi) \\;+\\; \\alpha \\,\\big|{}_s h(\\theta,\\phi)\\big|^2 \\; {}_s h(\\theta,\\phi),\n$$\n其中 $\\,\\alpha0\\,$ 是一个实标量。这种非线性保留了自旋权重，并在不同 $\\,\\ell\\,$ 之间耦合频谱内容，同时保留方位角结构，其方式允许来自被截断自由度的泄漏影响到恢复出的 $(2,2)$ 模式的振幅和相位。\n\n为揭示由截断引起的非线性泄漏，请比较两种处理流程：\n- 真实流程：计算 $\\,{}_s h_{\\text{true,nl}} = \\mathcal{N}_{\\alpha}[{}_s h_{\\text{true}}]\\,$，然后通过投影提取 $(2,2)$ 系数，\n$$\nh^{\\text{true}}_{22} \\;=\\; \\int {}_s h_{\\text{true,nl}}(\\theta,\\phi)\\; {}_{-2} Y_{22}^{*}(\\theta,\\phi)\\, d\\Omega.\n$$\n- 非线性作用前截断流程：在 $\\,\\ell_{\\max}\\,$ 处截断原始场\n$$\n{}_s h_{\\text{trunc}}(\\theta,\\phi) \\;=\\; \\sum_{(\\ell,m)\\in \\mathcal{C}_{\\text{true}}, \\, \\ell \\le \\ell_{\\max} } A_{\\ell m} \\; {}_{-2} Y_{\\ell m}(\\theta,\\phi),\n$$\n然后计算 $\\,{}_s h_{\\text{trunc,nl}} = \\mathcal{N}_{\\alpha}[{}_s h_{\\text{trunc}}]\\,$ 并提取\n$$\nh^{\\text{trunc}}_{22} \\;=\\; \\int {}_s h_{\\text{trunc,nl}}(\\theta,\\phi)\\; {}_{-2} Y_{22}^{*}(\\theta,\\phi)\\, d\\Omega.\n$$\n\n定义模式相位 $\\,\\varphi\\,$ 为 $\\,h_{22} = |h_{22}|\\, e^{i \\varphi}\\,$。模式相位误差为\n$$\n\\Delta \\varphi \\;=\\; \\mathrm{wrap}_{[-\\pi,\\pi]} \\big( \\varphi^{\\text{trunc}} - \\varphi^{\\text{true}} \\big) \\quad \\text{并以浮点数形式报告 } |\\Delta \\varphi| \\text{（单位为弧度）。}\n$$\n环绕操作必须返回在 $\\,[-\\pi,\\pi]\\,$ 区间内的唯一代表值。\n\n使用变量代换 $\\,\\mu=\\cos\\theta\\,$（使得 $\\,\\sin\\theta\\,d\\theta = d\\mu\\,$）来数值近似球面积分，即\n$$\nh_{\\ell m} \\;=\\; \\int_{0}^{2\\pi}\\!\\!\\int_{-1}^{1} {}_s h(\\theta(\\mu),\\phi)\\; {}_s Y_{\\ell m}^{*}(\\theta(\\mu),\\phi)\\; d\\mu\\, d\\phi.\n$$\n在 $\\,\\mu\\,$ 上使用具有 $\\,N_{\\theta}\\,$ 个点的高斯-勒让德求积法，在 $\\,\\phi\\,$ 上使用具有 $\\,N_{\\phi}\\,$ 个点的均匀梯形求积法。所有计算都必须使用弧度。\n\n实现以下测试套件。每个测试用例是一个元组 $\\,(\\ell_{\\text{high}}, \\ell_{\\max}, N_{\\theta}, N_{\\phi}, \\alpha)\\,$，其中 $\\,\\ell_{\\text{high}}\\,$ 设置了 $\\,\\mathcal{C}_{\\text{true}}\\,$ 中存在的最高 $\\,\\ell\\,$（对于给定的系数，此处 $\\,\\ell_{\\text{high}}=12\\,$），$\\,\\ell_{\\max}\\,$ 是截断流程中的截断阈值，$\\,N_{\\theta}\\,$ 和 $\\,N_{\\phi}\\,$ 是求积分辨率，$\\,\\alpha\\,$ 是非线性强度：\n- 测试 1（“理想路径”）：$\\,(\\,12,\\,8,\\,64,\\,128,\\,0.5\\,)\\,$。\n- 测试 2（“完全捕获边界”）：$\\,(\\,12,\\,12,\\,64,\\,128,\\,0.5\\,)\\,$。\n- 测试 3（“严重截断”）：$\\,(\\,12,\\,2,\\,80,\\,160,\\,0.8\\,)\\,$。\n- 测试 4（“因粗糙采样导致的混叠”）：$\\,(\\,12,\\,8,\\,16,\\,16,\\,0.5\\,)\\,$。\n\n你的程序必须：\n- 根据 $\\,\\mathcal{C}_{\\text{true}}\\,$ 和 $\\,s=-2\\,$ 构造 $\\,{}_s h_{\\text{true}}\\,$。\n- 对于每个测试用例，使用指定的 $\\,N_{\\theta}\\,$ 和 $\\,N_{\\phi}\\,$ 计算 $\\,h^{\\text{true}}_{22}\\,$ 和 $\\,h^{\\text{trunc}}_{22}\\,$，然后将该用例的 $\\,|\\Delta \\varphi|\\,$ 作为 Python 浮点数输出。\n- 角度必须以弧度为单位。\n- 最终输出必须是单行，包含一个由四个结果组成的逗号分隔的 Python 列表，例如 $\\,\\big[ r_1, r_2, r_3, r_4 \\big]\\,$，其中每个 $\\,r_i\\,$ 是测试 $\\,i\\,$ 的绝对模式相位误差（以弧度为单位）。\n\n科学真实性约束：\n- 通过 $\\,\\mu=\\cos\\theta\\,$ 替换，使用精确的正交归一性度量 $\\,d\\Omega = \\sin\\theta \\, d\\theta \\, d\\phi\\,$。\n- 使用上面给出的维格纳小d函数定义来定义SWSH。\n- 确保数值求积的权重被正确应用。\n- 无外部文件或输入；所有常量和参数必须在程序内部定义。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\,\\big[ r_1, r_2, r_3, r_4 \\big]\\,$）。", "solution": "我们从球面上自旋权场的正交归一分解开始。自旋权球谐函数（SWSH）$\\,{}_s Y_{\\ell m}(\\theta,\\phi)\\,$ 构成了一个关于由 $\\,d\\Omega=\\sin\\theta\\, d\\theta \\, d\\phi\\,$ 导出的内积的正交归一基。因此，场 $\\,{}_s h(\\theta,\\phi)\\,$ 的频谱系数 $\\,h_{\\ell m}\\,$ 通过内积得到：\n$$\nh_{\\ell m} \\;=\\; \\int_{0}^{2\\pi}\\int_{0}^{\\pi} {}_s h(\\theta,\\phi)\\; {}_s Y_{\\ell m}^{*}(\\theta,\\phi)\\; \\sin\\theta \\; d\\theta \\; d\\phi.\n$$\n为了进行数值评估并最小化类多项式角结构的求积误差，我们进行变量代换 $\\,\\mu=\\cos\\theta\\,$，从而 $\\,\\sin\\theta\\, d\\theta = d\\mu\\,$，得到：\n$$\nh_{\\ell m} \\;=\\; \\int_{0}^{2\\pi}\\int_{-1}^{1} {}_s h(\\theta(\\mu),\\phi)\\; {}_s Y_{\\ell m}^{*}(\\theta(\\mu),\\phi)\\; d\\mu \\; d\\phi.\n$$\n我们使用具有 $\\,N_{\\theta}\\,$ 个节点和权重的高斯-勒让德求积法来近似 $\\,\\mu\\,$ 积分，该方法对于最高为 $\\,2 N_{\\theta}-1\\,$ 次的多项式是精确的，并且经验上对于维格纳小d函数也是精确的，因为后者是 $\\,\\sin(\\theta/2)\\,$ 和 $\\,\\cos(\\theta/2)\\,$ 幂的有限和。$\\,\\phi\\,$ 积分是周期性的，因此可以用具有 $\\,N_{\\phi}\\,$ 个点的均匀梯形求积法很好地近似。\n\n基本定义：\n- 自旋权球谐函数定义为\n$$\n{}_s Y_{\\ell m}(\\theta,\\phi) \\;=\\; (-1)^s \\sqrt{\\frac{2\\ell+1}{4\\pi}} \\; d^{\\ell}_{m,-s}(\\theta)\\; e^{i m \\phi},\n$$\n其中 $\\,d^{\\ell}_{m m'}(\\theta)\\,$ 是维格纳小d函数。后者具有闭式级数形式\n$$\nd^{\\ell}_{m m'}(\\theta) \\;=\\; \\sum_{k=k_{\\min}}^{k_{\\max}}\n(-1)^{\\,k - m' + m} \\;\n\\frac{\n\\sqrt{(\\ell+m)!\\,(\\ell-m)!\\,(\\ell+m')!\\,(\\ell-m')!}\n}{\n(\\ell+m-k)! \\; k! \\; (m' - m + k)! \\; (\\ell - m' - k)!\n}\n\\;\n\\big(\\cos\\tfrac{\\theta}{2}\\big)^{2\\ell + m - m' - 2k}\n\\;\n\\big(\\sin\\tfrac{\\theta}{2}\\big)^{m' - m + 2k},\n$$\n其中 $\\,k_{\\min}=\\max(0, m - m')\\,$ 且 $\\,k_{\\max}=\\min(\\ell + m,\\, \\ell - m')\\,$，确保所有阶乘的参数都是非负的。这个定义是一个标准的、经过充分测试的表示形式，能确保中等 $\\,\\ell\\,$ 值的数值稳定性。\n\n实验设计：\n- 使用提供的系数集 $\\,\\mathcal{C}_{\\text{true}}\\,$ 和自旋权重 $\\,s=-2\\,$，构造“真实”场，\n$$\n{}_s h_{\\text{true}}(\\theta,\\phi) \\;=\\; \\sum_{(\\ell,m)\\in \\mathcal{C}_{\\text{true}}} A_{\\ell m} \\; {}_{-2} Y_{\\ell m}(\\theta,\\phi).\n$$\n- 定义引发模式耦合的非线性\n$$\n\\mathcal{N}_{\\alpha}[{}_s h] \\;=\\; {}_s h \\;+\\; \\alpha \\, |{}_s h|^2 \\, {}_s h.\n$$\n这种选择保留了自旋权重，并且重要的是，它在不同 $\\,\\ell\\,$ 之间创建了耦合，同时通常保留了方位角特性，其方式允许来自被截断的高$\\ell$模式的内容在非线性作用后影响恢复出的 $\\,(\\ell,m)=(2,2)\\,$ 系数。其机制是 $\\,|{}_s h|^2\\,$ 引入了一个由 $\\,m''=m-m'\\,$ 组合主导的标量调制，而乘积 $\\,|{}_s h|^2 {}_s h\\,$ 在保持相同自旋权重的同时，重新分配了各阶 $\\,\\ell\\,$ 之间的振幅。如果在应用 $\\,\\mathcal{N}_{\\alpha}\\,$ 之前发生截断，被省略的高$\\ell$结构就无法影响非线性调制，这将导致对恢复的 $\\,h_{22}\\,$ 相位的估计出现偏差。\n\n处理流程与相位误差：\n- 在“真实”流程中，我们计算 $\\,{}_s h_{\\text{true,nl}} = \\mathcal{N}_{\\alpha}[{}_s h_{\\text{true}}]\\,$ 并得到\n$$\nh^{\\text{true}}_{22} \\;=\\; \\int {}_s h_{\\text{true,nl}}(\\theta,\\phi)\\; {}_{-2} Y_{22}^{*}(\\theta,\\phi)\\, d\\mu \\, d\\phi.\n$$\n- 在“非线性作用前截断”流程中，我们首先在 $\\,\\ell_{\\max}\\,$ 处进行截断，\n$$\n{}_s h_{\\text{trunc}}(\\theta,\\phi) \\;=\\; \\sum_{(\\ell,m)\\in \\mathcal{C}_{\\text{true}}, \\, \\ell \\le \\ell_{\\max} } A_{\\ell m} \\; {}_{-2} Y_{\\ell m}(\\theta,\\phi),\n$$\n然后计算 $\\,{}_s h_{\\text{trunc,nl}} = \\mathcal{N}_{\\alpha}[{}_s h_{\\text{trunc}}]\\,$ 并得到\n$$\nh^{\\text{trunc}}_{22} \\;=\\; \\int {}_s h_{\\text{trunc,nl}}(\\theta,\\phi)\\; {}_{-2} Y_{22}^{*}(\\theta,\\phi)\\, d\\mu \\, d\\phi.\n$$\n定义相位 $\\,\\varphi^{\\text{true}}=\\arg(h^{\\text{true}}_{22})\\,$ 和 $\\,\\varphi^{\\text{trunc}}=\\arg(h^{\\text{trunc}}_{22})\\,$。环绕后的相位差为\n$$\n\\Delta \\varphi \\;=\\; \\mathrm{wrap}_{[-\\pi,\\pi]}(\\varphi^{\\text{trunc}}-\\varphi^{\\text{true}}),\n$$\n我们报告 $\\,|\\Delta \\varphi|\\,$。\n\n算法实现细节：\n- 使用具有 $\\,N_{\\theta}\\,$ 个点的高斯-勒让德节点和权重将 $\\,\\mu\\in[-1,1]\\,$ 离散化：$\\{ \\mu_i, w_i \\}_{i=1}^{N_{\\theta}}$，并设置 $\\,\\theta_i=\\arccos(\\mu_i)\\,$。\n- 使用 $\\,N_{\\phi}\\,$ 个点将 $\\,\\phi\\in[0,2\\pi)\\,$ 均匀离散化：$\\,\\phi_j=\\frac{2\\pi j}{N_{\\phi}}\\,$ 和 $\\,w_{\\phi}=\\frac{2\\pi}{N_{\\phi}}\\,$。\n- 通过将SWSH值乘以 $\\,A_{\\ell m}\\,$ 并求和来评估 $\\,{}_s h_{\\text{true}}(\\theta_i,\\phi_j)\\,$，其中使用维格纳小d级数计算 $\\,{}_s Y_{\\ell m}(\\theta_i,\\phi_j)\\,$（$s=-2$）。\n- 计算 $\\,{}_s h_{\\text{true,nl}}(\\theta_i,\\phi_j)= {}_s h_{\\text{true}}(\\theta_i,\\phi_j) + \\alpha \\, |{}_s h_{\\text{true}}(\\theta_i,\\phi_j)|^2 \\, {}_s h_{\\text{true}}(\\theta_i,\\phi_j)\\,$。\n- 类似地，在初始求和中仅使用 $\\,\\ell\\le \\ell_{\\max}\\,$ 的分量来构成 $\\,{}_s h_{\\text{trunc,nl}}(\\theta_i,\\phi_j)\\,$。\n- 通过以下方式投影到 $\\,(\\ell,m)=(2,2)\\,$ 上：\n$$\nh_{22} \\;\\approx\\; \\sum_{i=1}^{N_{\\theta}} \\sum_{j=1}^{N_{\\phi}} \\left[ {}_s h_{\\text{nl}}(\\theta_i,\\phi_j)\\, {}_{-2} Y_{22}^{*}(\\theta_i,\\phi_j) \\right] \\; w_i \\; w_{\\phi}.\n$$\n- 提取相位 $\\,\\varphi^{\\text{true}}\\,$ 和 $\\,\\varphi^{\\text{trunc}}\\,$，将其差值环绕到 $\\,[-\\pi,\\pi]\\,$ 区间，并返回其绝对值。\n\n测试套件覆盖范围：\n- 测试 1 评估了典型的截断 $\\,\\ell_{\\max}=8\\,$ 和足够的分辨率，显示出中等程度的泄漏。\n- 测试 2 使用 $\\,\\ell_{\\max}=\\ell_{\\text{high}}=12\\,$ 作为边界情况；截断没有移除任何东西，相位误差应接近机器精度。\n- 测试 3 严重截断至 $\\,\\ell_{\\max}=2\\,$，但使用高分辨率和更强的非线性 $\\,\\alpha=0.8\\,$，突显了在省略高$\\ell$项时，大量非线性泄漏进入 $(2,2)$ 相位的情况。\n- 测试 4 重复了测试 1 的设置，但使用粗糙的 $\\,N_{\\theta}\\,$ 和 $\\,N_{\\phi}\\,$ 来引发求积混叠，从而增加了相位误差。\n\n最终输出为单行，包含一个由四个浮点数组成的 Python 列表 $\\,\\big[ r_1, r_2, r_3, r_4 \\big]\\,$，其中每个条目是相应测试用例的绝对环绕相位差（以弧度为单位）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom numpy.polynomial.legendre import leggauss\n\n# Spin weight\nS = -2\n\ndef wigner_d(l, m, mp, theta):\n    \"\"\"\n    Compute the Wigner small-d function d^l_{m, mp}(theta) using the standard sum.\n    Parameters:\n        l (int): degree\n        m (int): order m\n        mp (int): order m'\n        theta (float): polar angle in radians\n    Returns:\n        float: d^l_{m, mp}(theta)\n    \"\"\"\n    # Pre-factor with factorials\n    # Use math.factorial for integer arguments (small l)\n    pref = math.sqrt(\n        math.factorial(l + m) *\n        math.factorial(l - m) *\n        math.factorial(l + mp) *\n        math.factorial(l - mp)\n    )\n    # k range ensuring nonnegative factorial arguments\n    k_min = max(0, m - mp)\n    k_max = min(l + m, l - mp)\n    cos_half = math.cos(theta / 2.0)\n    sin_half = math.sin(theta / 2.0)\n    total = 0.0\n    for k in range(k_min, k_max + 1):\n        denom = (\n            math.factorial(l + m - k) *\n            math.factorial(k) *\n            math.factorial(mp - m + k) *\n            math.factorial(l - mp - k)\n        )\n        # (-1)^(k - mp + m)\n        sign = -1 if ((k - mp + m) % 2) else 1\n        power_cos = 2 * l + m - mp - 2 * k\n        power_sin = mp - m + 2 * k\n        term = sign * pref * (cos_half ** power_cos) * (sin_half ** power_sin) / denom\n        total += term\n    return total\n\ndef sY(s, l, m, theta, phi):\n    \"\"\"\n    Compute the spin-weighted spherical harmonic {}_s Y_{l m}(theta, phi) via Wigner-d.\n    Parameters:\n        s (int): spin weight\n        l (int): degree\n        m (int): order\n        theta (float): colatitude in radians\n        phi (float): longitude in radians\n    Returns:\n        complex: {}_s Y_{l m}(theta, phi)\n    \"\"\"\n    # (-1)^s; for integer s this is 1 if s even, -1 if s odd\n    sign = -1 if (s % 2) else 1\n    dval = wigner_d(l, m, -s, theta)\n    norm = math.sqrt((2 * l + 1) / (4.0 * math.pi))\n    return sign * norm * dval * np.exp(1j * m * phi)\n\ndef build_field(theta_grid, phi_grid, components, s=S):\n    \"\"\"\n    Build a spin-weighted field from SWSH components.\n    components: list of tuples (l, m, amplitude complex)\n    Returns 2D complex array h[theta_index, phi_index]\n    \"\"\"\n    nt = len(theta_grid)\n    np_ = len(phi_grid)\n    h = np.zeros((nt, np_), dtype=complex)\n    # Accumulate contributions\n    for (l, m, amp) in components:\n        # Precompute d-function over theta for this (l,m)\n        dvals = np.array([wigner_d(l, m, -s, th) for th in theta_grid], dtype=float)\n        norm = math.sqrt((2 * l + 1) / (4.0 * math.pi))\n        # For each phi, multiply by exp(i m phi)\n        exp_imphi = np.exp(1j * m * phi_grid)\n        # Outer product to form Y_{lm}(theta_i, phi_j)\n        Ylm = (norm * dvals[:, None]) * exp_imphi[None, :]\n        # (-1)^s factor\n        sign = -1 if (s % 2) else 1\n        Ylm *= sign\n        h += amp * Ylm\n    return h\n\ndef nonlinear_map(h, alpha):\n    \"\"\"\n    Nonlinear map N_alpha[h] = h + alpha * |h|^2 * h\n    \"\"\"\n    return h + alpha * (np.abs(h) ** 2) * h\n\ndef project_c22(theta_grid, phi_grid, weights_mu, w_phi, h, s=S):\n    \"\"\"\n    Project the field h onto {}_s Y_{2 2} using the inner product over the sphere.\n    Returns complex coefficient h_22.\n    \"\"\"\n    # Precompute {}_s Y_{22}(theta, phi) over grid\n    # Compute d^2_{2,-s}(theta) once\n    dvals = np.array([wigner_d(2, 2, -s, th) for th in theta_grid], dtype=float)\n    norm = math.sqrt((2 * 2 + 1) / (4.0 * math.pi))\n    sign = -1 if (s % 2) else 1\n    exp_imphi = np.exp(1j * 2 * phi_grid)\n    Y22 = sign * norm * dvals[:, None] * exp_imphi[None, :]\n    # Inner product with Y22*\n    integrand = h * np.conjugate(Y22)\n    # Integrate: sum_i w_mu[i] * sum_j w_phi * integrand[i,j]\n    # Perform phi integral first\n    sum_phi = w_phi * np.sum(integrand, axis=1)\n    # Then mu integral\n    h22 = np.sum(weights_mu * sum_phi)\n    return h22\n\ndef phase_error(h22_true, h22_trunc):\n    \"\"\"\n    Compute the absolute wrapped phase difference |Delta phi| in radians.\n    \"\"\"\n    phi_true = np.angle(h22_true)\n    phi_trunc = np.angle(h22_trunc)\n    # Wrap to [-pi, pi]\n    delta = phi_trunc - phi_true\n    delta_wrapped = (delta + np.pi) % (2 * np.pi) - np.pi\n    return abs(delta_wrapped)\n\ndef run_case(l_high, l_max, N_theta, N_phi, alpha):\n    \"\"\"\n    Execute one test case and return absolute phase error in radians.\n    l_high is informational (highest l present in true components).\n    \"\"\"\n    # Define true components up to l_high\n    # Fixed set as specified in the problem statement\n    components_true = [\n        (2, 2, 1.0 * np.exp(1j * 0.0)),\n        (8, 8, 0.2 * np.exp(1j * (math.pi / 3.0))),\n        (9, 7, 0.15 * np.exp(-1j * (math.pi / 4.0))),\n        (12, 10, 0.1 * np.exp(1j * 0.7)),\n    ]\n    # Truncated components: keep only those with l = l_max\n    components_trunc = [(l, m, amp) for (l, m, amp) in components_true if l = l_max]\n\n    # Quadrature grids\n    mu_nodes, mu_weights = leggauss(N_theta)  # mu in [-1,1]\n    theta_grid = np.arccos(mu_nodes)  # radians\n    phi_grid = np.linspace(0.0, 2.0 * math.pi, num=N_phi, endpoint=False)\n    w_phi = (2.0 * math.pi) / N_phi\n\n    # Build fields\n    h_true = build_field(theta_grid, phi_grid, components_true, s=S)\n    h_trunc = build_field(theta_grid, phi_grid, components_trunc, s=S)\n\n    # Apply nonlinearity\n    h_true_nl = nonlinear_map(h_true, alpha=alpha)\n    h_trunc_nl = nonlinear_map(h_trunc, alpha=alpha)\n\n    # Project onto (2,2)\n    h22_true = project_c22(theta_grid, phi_grid, mu_weights, w_phi, h_true_nl, s=S)\n    h22_trunc = project_c22(theta_grid, phi_grid, mu_weights, w_phi, h_trunc_nl, s=S)\n\n    # Phase error\n    err = phase_error(h22_true, h22_trunc)\n    return err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (l_high, l_max, N_theta, N_phi, alpha)\n    test_cases = [\n        (12, 8, 64, 128, 0.5),   # Test 1: happy path\n        (12, 12, 64, 128, 0.5),  # Test 2: full capture boundary\n        (12, 2, 80, 160, 0.8),   # Test 3: severe truncation\n        (12, 8, 16, 16, 0.5),    # Test 4: aliasing due to coarse sampling\n    ]\n\n    results = []\n    for case in test_cases:\n        l_high, l_max, N_theta, N_phi, alpha = case\n        result = run_case(l_high, l_max, N_theta, N_phi, alpha)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3471582"}]}