{"hands_on_practices": [{"introduction": "在数值模拟中，描述黑洞最直接的方法是检查其视界的几何属性。本次实践将理论与应用相结合，首先要求您从克尔黑洞的基本性质出发，推导联系其质量、自旋和面积的关键方程——克里斯托杜卢（Christodoulou）质量公式。随后，您将设计一个算法，利用从模拟中测量的视界面积和自旋，精确计算黑洞的总质量和角动量。这项练习旨在巩固您对黑洞热力学基本关系的理解，并培养将理论公式转化为实用计算工具的能力。[@problem_id:3479534]", "problem": "我们为您提供一个框架，用于根据数值相对论（NR）模拟中测量的视界量来推断克尔黑洞的质量和自旋。您的任务有两方面：首先，从克尔几何的基本且经过充分检验的性质出发，推导克尔黑洞的质量-自旋-面积关系；其次，实现一个算法，该算法能根据视界面积和角动量测量值，或根据视界面积和无量纲自旋测量值，来计算总质量和角动量。\n\n推导任务：\n- 从几何单位制（其中 $G=c=1$）下克尔黑洞几何的以下基本事实出发：\n  - 克尔黑洞的外视界半径为 $r_{+} = M + \\sqrt{M^{2} - a^{2}}$，其中 $M$ 是总质量，$a = J/M$ 是自旋参数，$J$ 是角动量。\n  - 视界面积为 $A = 4\\pi (r_{+}^{2} + a^{2}) = 8\\pi M r_{+}$。\n  - 不可约质量定义为 $M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$。\n  - 无量纲自旋为 $\\chi = J/M^{2}$，对于亚极端克尔黑洞，有 $0 \\le \\chi \\le 1$。\n- 在不引入任何新假设的情况下，从上述基本定义和关系式中推导出关联 $M$、$M_{\\mathrm{irr}}$ 和 $J$ 的 Christodoulou 质量公式。你的推导必须从所列的基本事实逐步进行，并最终得到一个关于 $M^{2}$、$M_{\\mathrm{irr}}^{2}$ 和 $J^{2}$ 之间的关系式。\n\n算法设计任务：\n- 设计一个算法，在给定测量的视界面积 $A$ 以及以下两者之一的情况下：\n  - 测量的角动量大小 $J$，或\n  - 测量的无量纲自旋 $\\chi$，\n  自洽地计算出克尔黑洞的总质量 $M$ 和角动量 $J$。\n- 使用几何单位制（$G=c=1$）。将 $M$ 以长度单位表示，$J$ 以长度的平方单位表示。\n- 你的算法必须：\n  1. 通过 $M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$ 从 $A$ 计算出 $M_{\\mathrm{irr}}$。\n  2. 如果提供了 $J$，则直接从推导出的质量-自旋-面积关系式计算 $M$。\n  3. 如果提供了 $\\chi$，则使用一个对所有 $0 \\le \\chi \\le 1$（包括边界情况 $\\chi=0$）都有效的数值稳定表达式计算 $M$；然后根据 $\\chi$ 和 $M$ 计算 $J$。\n  4. 与克尔几何一致地处理边界情况 $J=0$ 和 $\\chi=0$。\n  5. 返回 $M$ 和 $J$ 的浮点数输出，并四舍五入到10位小数。\n\n输入和测试套件：\n- 将你的解决方案实现为一个独立的程序，该程序使用以下测试套件，其中每个测试用例包含一个视界面积和一个自旋测量类型：\n  1. 情况1（理想情况，直接角动量）：$A = 5026.548245743669$，测量类型 $J$，值 $J = 20.0$。\n  2. 情况2（中等无量纲自旋）：$A = 7238.229473870883$，测量类型 $\\chi$，值 $\\chi = 0.7$。\n  3. 情况3（边界情况 $\\chi=0$）：$A = 1256.6370614359173$，测量类型 $\\chi$，值 $\\chi = 0.0$。\n  4. 情况4（近极端无量纲自旋）：$A = 452.3893421169302$，测量类型 $\\chi$，值 $\\chi = 0.999$。\n- 所有面积均采用几何单位制，并分别对应于 $M_{\\mathrm{irr}}$ 等于 $10$、$12$、$5$ 和 $3$ 时的 $A = 16\\pi M_{\\mathrm{irr}}^{2}$，以确保测试用例的科学一致性。\n\n输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 该列表必须按 $[M_{1},J_{1},M_{2},J_{2},M_{3},J_{3},M_{4},J_{4}]$ 的顺序展开，其中 $M_{k}$ 和 $J_{k}$ 是测试用例 $k$ 的计算值，每个值都四舍五入到10位小数。", "solution": "该问题是有效的，因为它在科学上基于广义相对论的原理，特别是克尔度规，并且问题陈述清晰，为推导和算法任务提供了完整且一致的信息集。\n\n按照要求，解决方案分两部分进行。第一部分，从提供的基本关系式逐步推导 Christodoulou 质量公式。第二部分，设计并实现一个算法，用于根据克尔黑洞的视界面积 $A$ 和一项自旋测量值来计算其质量 $M$ 和角动量 $J$。所有计算均在几何单位制（$G=c=1$）下进行。\n\n**第一部分：Christodoulou 质量公式的推导**\n\n目标是推导出一个关联克尔黑洞总质量 $M$、不可约质量 $M_{\\mathrm{irr}}$ 和角动量 $J$ 的公式。推导从以下已建立的关系式开始：\n1. 不可约质量的定义：$M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$，这意味着视界面积为 $A = 16\\pi M_{\\mathrm{irr}}^{2}$。\n2. 视界面积的另一种表达式：$A = 8\\pi M r_{+}$，其中 $r_{+}$ 是外视界半径。\n3. 外视界半径：$r_{+} = M + \\sqrt{M^{2} - a^{2}}$。\n4. 自旋参数：$a = J/M$。\n\n推导过程如下：\n\n首先，我们将关系式(1)和(2)中给出的两个视界面积 $A$ 的表达式相等：\n$$16\\pi M_{\\mathrm{irr}}^{2} = 8\\pi M r_{+}$$\n两边同时除以 $8\\pi$ 得到不可约质量、总质量和视界半径之间的直接关系：\n$$2 M_{\\mathrm{irr}}^{2} = M r_{+}$$\n\n接下来，我们将关系式(3)中的 $r_{+}$ 表达式代入上式：\n$$2 M_{\\mathrm{irr}}^{2} = M (M + \\sqrt{M^{2} - a^{2}})$$\n展开右侧得到：\n$$2 M_{\\mathrm{irr}}^{2} = M^{2} + M \\sqrt{M^{2} - a^{2}}$$\n\n为了消去平方根，我们首先分离出含有平方根的项：\n$$M \\sqrt{M^{2} - a^{2}} = 2 M_{\\mathrm{irr}}^{2} - M^{2}$$\n现在，我们将方程两边平方：\n$$(M \\sqrt{M^{2} - a^{2}})^{2} = (2 M_{\\mathrm{irr}}^{2} - M^{2})^{2}$$\n这导致：\n$$M^{2} (M^{2} - a^{2}) = (2 M_{\\mathrm{irr}}^{2})^{2} - 2(2 M_{\\mathrm{irr}}^{2})(M^{2}) + (M^{2})^{2}$$\n$$M^{4} - M^{2} a^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2} + M^{4}$$\n\n两边的 $M^{4}$ 项相互抵消，方程简化为：\n$$-M^{2} a^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n\n现在我们代入关系式(4)中自旋参数的定义 $a = J/M$：\n$$-M^{2} \\left(\\frac{J}{M}\\right)^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n$$-M^{2} \\left(\\frac{J^{2}}{M^{2}}\\right) = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n$$-J^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n\n最后，我们重排此方程，以 $M_{\\mathrm{irr}}^{2}$ 和 $J^{2}$ 表示 $M^{2}$。这就是 Christodoulou 质量公式：\n$$4 M_{\\mathrm{irr}}^{2} M^{2} = 4 M_{\\mathrm{irr}}^{4} + J^{2}$$\n$$M^{2} = M_{\\mathrm{irr}}^{2} + \\frac{J^{2}}{4 M_{\\mathrm{irr}}^{2}}$$\n这个公式优雅地将一个旋转黑洞的总质能的平方分解为来自其不可约质量（与其表面积相关）的贡献和来自其旋转能量（与其角动量相关）的贡献。\n\n**第二部分：算法设计**\n\n该算法根据给定的视界面积 $A$ 以及 $J$ 的直接测量值或无量纲自旋 $\\chi = J/M^{2}$ 的测量值来计算总质量 $M$ 和角动量 $J$。\n\n所有情况下的第一步，都是从视界面积 $A$ 计算不可约质量 $M_{\\mathrm{irr}}$：\n$$M_{\\mathrm{irr}} = \\sqrt{\\frac{A}{16\\pi}}$$\n\n接下来的步骤取决于所提供的自旋测量类型。\n\n**情况1：给定视界面积 $A$ 和角动量 $J$。**\n在从 $A$ 计算出 $M_{\\mathrm{irr}}$ 并且直接给定 $J$ 的情况下，我们可以使用推导出的 Christodoulou 质量公式来求解 $M$：\n$$M = \\sqrt{M_{\\mathrm{irr}}^{2} + \\frac{J^{2}}{4 M_{\\mathrm{irr}}^{2}}}$$\n这个表达式对所有非负的 $J$ 都有效。如果 $J=0$（史瓦西情况），该公式正确地简化为 $M = \\sqrt{M_{\\mathrm{irr}}^{2}} = M_{\\mathrm{irr}}$。计算出的质量 $M$ 和给定的角动量 $J$ 即为输出。\n\n**情况2：给定视界面积 $A$ 和无量纲自旋 $\\chi$。**\n在这种情况下，我们有从 $A$ 得到的 $M_{\\mathrm{irr}}$ 和无量纲自旋 $\\chi$。角动量通过 $J = \\chi M^{2}$ 与 $M$ 和 $\\chi$ 相关联。我们将此代入 Christodoulou 公式：\n$$M^{2} = M_{\\mathrm{irr}}^{2} + \\frac{(\\chi M^{2})^{2}}{4 M_{\\mathrm{irr}}^{2}} = M_{\\mathrm{irr}}^{2} + \\frac{\\chi^{2} M^{4}}{4 M_{\\mathrm{irr}}^{2}}$$\n重排后得到一个关于 $M^{2}$ 的二次方程：\n$$\\left(\\frac{\\chi^{2}}{4 M_{\\mathrm{irr}}^{2}}\\right)M^{4} - M^{2} + M_{\\mathrm{irr}}^{2} = 0$$\n解这个关于 $M^{2}$ 的二次方程会得到两个可能的解。物理上正确的解是在 $\\chi \\to 0$ 时能恢复到史瓦西极限（$M \\to M_{\\mathrm{irr}}$）的那个解：\n$$M^{2} = 2 M_{\\mathrm{irr}}^{2} \\frac{1 - \\sqrt{1 - \\chi^{2}}}{\\chi^{2}}$$\n然而，当 $\\chi$ 很小时，这个表达式会因灾难性抵消而导致数值不稳定。为了创建一个数值上稳健的算法，我们对分子进行有理化：\n$$\\frac{1 - \\sqrt{1 - \\chi^{2}}}{\\chi^{2}} \\times \\frac{1 + \\sqrt{1 - \\chi^{2}}}{1 + \\sqrt{1 - \\chi^{2}}} = \\frac{1 - (1 - \\chi^{2})}{\\chi^{2}(1 + \\sqrt{1 - \\chi^{2}})} = \\frac{1}{1 + \\sqrt{1 - \\chi^{2}}}$$\n这导出了一个数值稳定的 $M^{2}$ 表达式：\n$$M^{2} = \\frac{2 M_{\\mathrm{irr}}^{2}}{1 + \\sqrt{1 - \\chi^{2}}}$$\n由此我们计算总质量 $M$：\n$$M = M_{\\mathrm{irr}} \\sqrt{\\frac{2}{1 + \\sqrt{1 - \\chi^{2}}}}$$\n这个公式在整个有效范围 $0 \\le \\chi \\le 1$ 内都表现良好，包括边界情况 $\\chi=0$（史瓦西）和 $\\chi=1$（极端克尔）。\n\n一旦计算出 $M$，就可以使用角动量 $J$ 关于 $\\chi$ 的定义来找到它：\n$$J = \\chi M^{2}$$\n计算出的 $M$ 和 $J$ 的值即为输出。最终的实现将按要求将这些结果四舍五入到10位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mass and spin of a Kerr black hole from horizon quantities.\n    \n    This function processes a series of test cases, each providing a horizon area\n    and a spin measurement (either angular momentum J or dimensionless spin chi).\n    It calculates the total mass M and angular momentum J for each case based on\n    the Christodoulou mass formula and prints the aggregated results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary specifying the area 'A', the measurement type 'type',\n    # and the measured 'value'.\n    test_cases = [\n        {'A': 5026.548245743669, 'type': 'J', 'value': 20.0},\n        {'A': 7238.229473870883, 'type': 'chi', 'value': 0.7},\n        {'A': 1256.6370614359173, 'type': 'chi', 'value': 0.0},\n        {'A': 452.3893421169302, 'type': 'chi', 'value': 0.999},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A = case['A']\n        measurement_type = case['type']\n        value = case['value']\n\n        # Step 1: Compute the irreducible mass from the area A.\n        # The irreducible mass is defined by A = 16 * pi * M_irr^2.\n        M_irr = np.sqrt(A / (16.0 * np.pi))\n\n        M = 0.0\n        J = 0.0\n\n        if measurement_type == 'J':\n            # Case where angular momentum J is given directly.\n            J_val = value\n            \n            # Use the Christodoulou mass formula to find M:\n            # M^2 = M_irr^2 + J^2 / (4 * M_irr^2)\n            # This handles the J=0 case correctly, where M = M_irr.\n            if M_irr == 0:\n                # This case represents a singular state, but for completeness,\n                # if J is also 0, M would be 0. If J  0, it is unphysical.\n                # Problem constraints ensure M_irr  0.\n                M = 0.0 if J_val == 0.0 else float('inf')\n            else:\n                M = np.sqrt(M_irr**2 + J_val**2 / (4.0 * M_irr**2))\n            \n            J = J_val\n\n        elif measurement_type == 'chi':\n            # Case where dimensionless spin chi is given.\n            chi_val = value\n\n            # A numerically stable expression for M is used, derived from\n            # M^2 = 2 * M_irr^2 / (1 + sqrt(1 - chi^2)).\n            # This avoids catastrophic cancellation for small chi.\n            # It is well-defined for all 0 = chi = 1.\n            radicand = 1.0 - chi_val**2\n            # Handle potential floating point inaccuracies for chi=1\n            if radicand  0: radicand = 0\n            \n            M = M_irr * np.sqrt(2.0 / (1.0 + np.sqrt(radicand)))\n            \n            # Compute J from the definition chi = J / M^2.\n            J = chi_val * M**2\n\n        # Round results to 10 decimal places as specified.\n        M_rounded = round(M, 10)\n        J_rounded = round(J, 10)\n        \n        results.extend([M_rounded, J_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3479534"}, {"introduction": "虽然基于视界的物理量（如面积和从中导出的质量）在理论上是稳健的，但在数值模拟中我们可能还会遇到其他“准局域”的质量定义。这些定义在高度动态或非球对称的情况下可能并不可靠。本次实践将要求您利用前一练习中稳固的克尔（Kerr）黑洞关系，构建一个诊断工具。这个工具将用于检验准局域质量测量值与视界几何的一致性，从而评估其可靠性。掌握这种构建内部一致性检验的方法，对于批判性地分析和验证复杂的数值模拟结果至关重要。[@problem_id:3479624]", "problem": "您正在为广义相对论的完全三维数值模拟（不假设任何对称性）中的准局域黑洞质量测量构建一个程序化的可靠性诊断工具。在高度动态和非球形的阶段，准局域质量可能表现出规范和切片依赖性，这使其与从黑洞视界几何推断出的量解耦。您的任务是设计并实现一个独立的诊断工具，该工具仅使用视界面积和自旋测量值来测试给定的准局域质量是否与克尔家族兼容的黑洞一致，并在动态演化过程中标记出可能不可靠的质量估计。\n\n从黑洞力学和静态黑洞理论中经过充分检验的关系出发，您必须：\n\n- 根据给定的视界面积和自旋大小，推断出一个与克尔黑洞一致的质量，此处表示为“与克尔黑洞一致的质量”。除了黑洞力学定律中编码的对称性外，不要假设任何其他对称性。\n- 构建所提供的准局域质量与克尔一致质量之间的无量纲相对差异。\n- 使用所提供的准局域质量和视界几何，为质量-自旋-面积关系构建一个无量纲残差。\n- 构建一个极端性比率，用于测试自旋和面积是否服从与次极端黑洞相关的不等式。\n- 将这些组合成一个布尔可靠性标志，仅当所有一致性检查都在指定容差范围内时才返回真。\n\n您必须在几何单位制下工作，其中引力常数和光速设为1，即 $G=c=1$，因此质量、长度和角动量在这些单位下是无量纲的。您程序的所有输出都必须是无量纲的。您的算法不得依赖输入数据编码之外的任何对称性假设，并且必须普遍适用于任何光滑且非简并的视界数据。\n\n从第一性原理定义以下诊断量：\n\n- 一个仅依赖于视界面积 $A$ 和自旋大小 $J$ 的克尔一致质量 $M_{\\mathrm{Kerr}}$。\n- 一个相对质量差异 $\\delta_{M}$，定义为所提供的准局域质量 $M_{\\mathrm{H}}$ 与 $M_{\\mathrm{Kerr}}$ 之间的差，并用 $M_{\\mathrm{Kerr}}$ 进行归一化。\n- 一个质量-自旋-面积关系的无量纲残差 $r_{\\mathrm{norm}}$，通过适当的克尔一致质量标度进行归一化，以使 $r_{\\mathrm{norm}}$ 无单位。\n- 一个仅依赖于 $A$ 和 $J$ 的极端性比率 $\\varepsilon$，对于次极端黑洞，该值不得超过1。\n\n使用以下具有固定容差的可靠性决策规则：准局域质量是可靠的，当且仅当\n- 绝对相对质量差异满足 $|\\delta_{M}| \\le \\tau_{M}$，\n- 绝对归一化残差满足 $|r_{\\mathrm{norm}}| \\le \\tau_{r}$，\n- 且极端性比率满足 $\\varepsilon \\le 1 + \\tau_{e}$，\n容差为 $\\tau_{M}=0.02$, $\\tau_{r}=0.02$, 和 $\\tau_{e}=0.001$。\n\n您的程序必须在不使用任何外部数据的情况下，从黑洞力学的基础知识实现这些诊断。将您的实现应用于以下视界测量测试套件，每个测试套件以三元组 $(A,J,M_{\\mathrm{H}})$ 的形式给出：\n\n- 案例1（类静态，中等自旋）：$A=43.08110859803532$, $J=0.7$, $M_{\\mathrm{H}}=1.0$。\n- 案例2（近极端，质量有小的建模误差）：$A=28.67824906701301$, $J=0.99$, $M_{\\mathrm{H}}=1.005$。\n- 案例3（不一致的质量）：$A=46.89833316054006$, $J=0.5$, $M_{\\mathrm{H}}=1.3$。\n- 案例4（数据中违反极端性不等式）：$A=21.488493750554183$, $J=0.9$, $M_{\\mathrm{H}}=1.0$。\n- 案例5（类史瓦西，质量略有低估）：$A=50.26548245743669$, $J=0.0$, $M_{\\mathrm{H}}=0.99$。\n\n对于每种情况，您的程序必须按以下顺序输出一个包含四个条目的列表：$[\\delta_{M}, r_{\\mathrm{norm}}, \\varepsilon, \\text{reliable}]$，其中 $\\text{reliable}$ 是一个布尔值。最终输出必须是包含这些按案例排列的列表的单行内容，不含附加文本。例如，总输出应具有以下形式\n$[[\\delta_{M}^{(1)}, r_{\\mathrm{norm}}^{(1)}, \\varepsilon^{(1)}, \\text{reliable}^{(1)}],\\ldots,[\\delta_{M}^{(5)}, r_{\\mathrm{norm}}^{(5)}, \\varepsilon^{(5)}, \\text{reliable}^{(5)}]]$。\n\n此问题中不出现角度，因此不需要角度单位。所有数值答案在几何单位制 $G=c=1$ 下均为无量纲。", "solution": "该问题陈述被评估为科学上合理、适定且客观。唯一解所需的所有必要数据和定义均已提供，其物理基础是关于克尔黑洞的广义相对论标准且成熟的原理。该问题是有效的。\n\n目标是创建一个诊断工具，用于在给定黑洞的事件视界面积 $A$ 和其自旋角动量大小 $J$ 的情况下，评估黑洞的准局域质量测量值 $M_{\\mathrm{H}}$ 的可靠性。该诊断基于这些测量值与广义相对论中克尔黑洞解家族性质的一致性。我们在几何单位制中操作，其中引力常数 $G$ 和光速 $c$ 均设为1，即 $G=c=1$。\n\n对于克尔黑洞，连接其质量 $M$、自旋大小 $J$ 和视界面积 $A$ 的基本关系源于其几何结构。其面积由 $A = 4\\pi (r_+^2 + a^2)$ 给出，其中 $r_+ = M + \\sqrt{M^2 - a^2}$ 是外事件视界的半径，而 $a=J/M$ 是自旋参数。这个关系的一个更直接的形式，通常称为 Christodoulou-Ruffini 质量公式，用不可约质量 $M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$ 和自旋 $J$ 来表示质量的平方：\n$$\nM^2 = M_{\\mathrm{irr}}^2 + \\frac{J^2}{4M_{\\mathrm{irr}}^2}\n$$\n代入 $M_{\\mathrm{irr}}$ 的表达式，得到质量-自旋-面积关系：\n$$\nM^2 = \\frac{A}{16\\pi} + \\frac{4\\pi J^2}{A}\n$$\n该方程构成了我们诊断工具的理论基础。\n\n我们现在定义所需的四个诊断量。\n\n1.  **与克尔黑洞一致的质量，$M_{\\mathrm{Kerr}}$**：这是一个黑洞如果是一个具有给定视界面积 $A$ 和自旋 $J$ 的克尔黑洞时*将会*拥有的质量。我们可以通过求解质量-自旋-面积关系式中的 $M$ 来得到这个质量。我们将其表示为 $M_{\\mathrm{Kerr}}$：\n    $$\n    M_{\\mathrm{Kerr}}(A, J) = \\sqrt{\\frac{A}{16\\pi} + \\frac{4\\pi J^2}{A}}\n    $$\n    只要 $A > 0$，这个量就是良定义的。\n\n2.  **相对质量差异，$\\delta_{M}$**：这个无量纲量测量所提供的准局域质量 $M_{\\mathrm{H}}$ 与克尔一致质量 $M_{\\mathrm{Kerr}}$ 之间的相对差异。其定义为：\n    $$\n    \\delta_{M} = \\frac{M_{\\mathrm{H}} - M_{\\mathrm{Kerr}}}{M_{\\mathrm{Kerr}}} = \\frac{M_{\\mathrm{H}}}{M_{\\mathrm{Kerr}}} - 1\n    $$\n    接近于0的 $\\delta_{M}$ 值表明，在克尔假设下，测量的质量与从视界几何推断的质量吻合良好。\n\n3.  **无量纲残差，$r_{\\mathrm{norm}}$**：此诊断量化了测量到的三元组 $(A, J, M_{\\mathrm{H}})$ 满足克尔质量-自旋-面积关系的程度。该关系的残差 $r$ 为：\n    $$\n    r = M_{\\mathrm{H}}^2 - \\left(\\frac{A}{16\\pi} + \\frac{4\\pi J^2}{A}\\right)\n    $$\n    使用 $M_{\\mathrm{Kerr}}$ 的定义，这变为 $r = M_{\\mathrm{H}}^2 - M_{\\mathrm{Kerr}}^2$。为使其无量纲，我们用一个特征质量标度的平方来归一化它。自然的选择是 $M_{\\mathrm{Kerr}}^2$：\n    $$\n    r_{\\mathrm{norm}} = \\frac{M_{\\mathrm{H}}^2 - M_{\\mathrm{Kerr}}^2}{M_{\\mathrm{Kerr}}^2} = \\left(\\frac{M_{\\mathrm{H}}}{M_{\\mathrm{Kerr}}}\\right)^2 - 1\n    $$\n    对于小差异 $\\delta_M \\ll 1$，我们注意到 $r_{\\mathrm{norm}} = (1+\\delta_M)^2 - 1 \\approx 2\\delta_M$。\n\n4.  **极端性比率，$\\varepsilon$**：一个物理上的黑洞不能是裸奇点，这个条件被宇宙监督假设所概括。对于克尔黑洞，这意味着自旋参数 $a$ 不能超过质量 $M$，即 $|a| \\le M$，这可转化为 $M^2 \\ge |J|$。为了仅使用可测量的量 $A$ 和 $|J|$ 来表达这个条件，我们可以找到给定面积下允许的最大自旋。这个最大值出现在极端情况下 ($M^2=|J|$)，此时视界面积为 $A = 8\\pi M^2 = 8\\pi |J|$。这导出了适用于任何次极端黑洞的不等式：\n    $$\n    A \\ge 8\\pi |J|\n    $$\n    我们可以基于这个不等式定义一个无量纲的极端性比率 $\\varepsilon$：\n    $$\n    \\varepsilon = \\frac{8\\pi |J|}{A}\n    $$\n    对于一个物理的（次极端的或极端的）克尔黑洞，这个比率必须满足 $\\varepsilon \\le 1$。大于1的值表示违反了极端性界限，表明输入数据 $(A, J)$ 与任何黑洞解都不一致。\n\n最后，我们根据指定的容差构建可靠性标志。准局域质量 $M_{\\mathrm{H}}$ 的测量被认为是可靠的，当且仅当以下所有三个条件都得到满足：\n- 绝对相对质量差异在其容差范围内：$|\\delta_{M}| \\le \\tau_{M}$，其中 $\\tau_{M} = 0.02$。\n- 绝对归一化残差在其容差范围内：$|r_{\\mathrm{norm}}| \\le \\tau_{r}$，其中 $\\tau_{r} = 0.02$。\n- 极端性比率被遵守，并带有一个小的数值误差容差：$\\varepsilon \\le 1 + \\tau_{e}$，其中 $\\tau_{e} = 0.001$。\n\n该算法包括为每个输入集 $(A, J, M_{\\mathrm{H}})$ 计算这四个量（$M_{\\mathrm{Kerr}}$, $\\delta_{M}$, $r_{\\mathrm{norm}}$, $\\varepsilon$），然后基于这些条件评估布尔可靠性标志。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes black hole diagnostic quantities and reliability flags for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (A, J, M_H).\n    test_cases = [\n        (43.08110859803532, 0.7, 1.0),       # Case 1\n        (28.67824906701301, 0.99, 1.005),    # Case 2\n        (46.89833316054006, 0.5, 1.3),       # Case 3\n        (21.488493750554183, 0.9, 1.0),      # Case 4\n        (50.26548245743669, 0.0, 0.99),      # Case 5\n    ]\n\n    # Define the tolerances for the reliability checks.\n    tau_M = 0.02\n    tau_r = 0.02\n    tau_e = 0.001\n\n    results = []\n    \n    for case in test_cases:\n        A, J, M_H = case\n\n        # 1. Calculate the Kerr-consistent mass, M_Kerr.\n        # The mass-spin-area relation is M^2 = A/(16*pi) + (4*pi*J^2)/A.\n        # We need to handle the case A=0, though it is not present in the tests.\n        if A = 0:\n            # Physically unrealistic, results would be undefined.\n            # For robustness, we could flag this as an error. Here we assume A > 0.\n            # Using nan for undefined results to signal invalid input.\n            M_Kerr = np.nan\n        else:\n            M_Kerr_sq = A / (16 * np.pi) + (4 * np.pi * J**2) / A\n            M_Kerr = np.sqrt(M_Kerr_sq)\n\n        # 2. Calculate the relative mass discrepancy, delta_M.\n        if M_Kerr == 0:\n            delta_M = np.inf if M_H > 0 else 0.0\n        else:\n            delta_M = (M_H / M_Kerr) - 1\n\n        # 3. Calculate the dimensionless residual, r_norm.\n        if M_Kerr == 0:\n            r_norm = np.inf if M_H > 0 else 0.0\n        else:\n            r_norm = (M_H / M_Kerr)**2 - 1\n            \n        # 4. Calculate the extremality ratio, epsilon.\n        # The condition for a sub-extremal black hole is A >= 8*pi*|J|.\n        if A = 0:\n            epsilon = np.inf\n        else:\n            epsilon = (8 * np.pi * abs(J)) / A\n\n        # 5. Combine diagnostics into a final reliability flag.\n        is_reliable = (abs(delta_M) = tau_M) and \\\n                      (abs(r_norm) = tau_r) and \\\n                      (epsilon = 1 + tau_e)\n        \n        # Append the list of results for this case.\n        results.append([delta_M, r_norm, epsilon, is_reliable])\n\n    # Format the final output string to match the required format:\n    # A list of lists, with no spaces.\n    # e.g., [[val1,val2,val3,True],[val4,val5,val6,False]]\n    inner_list_strings = []\n    for res in results:\n        # res is a list: [float, float, float, bool]\n        # str(bool) gives 'True' or 'False'\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3])}]\"\n        inner_list_strings.append(inner_str)\n    \n    final_output_string = f\"[{','.join(inner_list_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3479624"}, {"introduction": "将我们的讨论从黑洞本身的几何属性转向其产生的可观测信号——引力波。天文学家通过分析探测器记录的含噪数据来测量黑洞的参数，这与直接从无噪声的模拟视界中读取数据有本质区别。本次实践将引导您使用费希尔（Fisher）信息矩阵这一强大的统计工具，对简化的黑洞并合旋进（inspiral）引力波信号进行参数估计。通过这个练习，您将学会如何从理论波形模型和噪声模型出发，估算黑洞参数（如质量和自旋）的测量不确定性及其相关性，从而连接起理论物理、数值模拟与引力波天文学的实践。[@problem_id:3479528]", "problem": "设计并实现一个完整的程序，该程序通过费雪信息矩阵，在线性高斯（拉普拉斯）近似下，对来自准圆形、非进动、自旋对齐的双黑洞并合旋进的简化频域引力波信号进行贝叶斯参数估计。目标是从具有平稳高斯噪声的单个探测器中估计啁啾质量 $M_{\\mathrm{c}}$、对称质量比 $\\eta$ 以及一个有效对齐无量纲自旋 $\\chi$。\n\n您的实现必须基于以下基础，这对于推导所需算法是充分且必要的：\n\n1) 稳相近似下的频域旋进波形模型（限制振幅）：\n- 应变模型为 $h(f) = \\mathcal{A}(f; M_{\\mathrm{c}}, \\eta, \\chi) \\exp\\left(i \\Psi(f; M_{\\mathrm{c}}, \\eta, \\chi)\\right)$，适用于 $f \\in [f_{\\mathrm{low}}, f_{\\mathrm{high}}]$，其中领头阶振幅的标度关系如下\n$$\n|\\mathcal{A}(f; M_{\\mathrm{c}}, \\eta, \\chi)| = \\mathcal{C} \\frac{M_{\\mathrm{c}}^{5/6}}{D_L} f^{-7/6}, \\quad \\mathcal{C} = \\sqrt{\\frac{5}{24}} \\pi^{-2/3}.\n$$\n此处 $D_L$ 是光度距离，$\\mathcal{C}$ 是一个方向平均常数。\n- 相位取到包含领头阶自旋-轨道耦合的 $1.5$ 阶后牛顿阶，写作\n$$\n\\Psi(f) = \\frac{3}{128 \\, \\eta} v^{-5} \\left[ 1 + \\alpha_2 v^2 + \\alpha_3 v^3 \\right],\n$$\n其中 $v = (\\pi M f)^{1/3}$，$M = M_{\\mathrm{c}} \\eta^{-3/5}$ 是总质量，$\\alpha_2 = \\frac{3715}{756} + \\frac{55}{9} \\eta$，以及\n$$\n\\alpha_3 = 4 \\beta - 16 \\pi, \\quad \\beta(\\eta, \\chi) = \\left(\\frac{113}{12} - \\frac{19}{3}\\eta\\right)\\chi.\n$$\n并合时间和相位被视为已知或已被边缘化，并从参数集中省略。\n\n2) 探测器噪声与内积：\n- 假设单边功率谱密度为 $S_n(f)$，并为任意频域信号 $a(f)$ 和 $b(f)$ 定义噪声加权内积为\n$$\n(a|b) = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{a(f) b^*(f)}{S_n(f)} \\, df,\n$$\n- 以及对于真实参数，最优信噪比由 $\\rho^2 = (h|h)$ 定义。\n- 使用以下简化但科学上合理的解析模型来表示噪声功率谱密度：\n$$\nS_n(f) = S_0 \\left[ \\left( \\frac{f_0}{f} \\right)^4 + 1 + \\left( \\frac{f}{f_1} \\right)^2 \\right],\n$$\n其中 $S_0 = 10^{-47}\\,\\mathrm{Hz}^{-1}$，$f_0 = 50\\,\\mathrm{Hz}$，$f_1 = 200\\,\\mathrm{Hz}$。\n\n3) 信息几何与贝叶斯线性高斯后验：\n- 对于参数 $\\theta = (M_{\\mathrm{c}}, \\eta, \\chi)$，在某一注入参数点上的费雪信息矩阵为\n$$\n\\Gamma_{ij} = \\left( \\partial_i h \\mid \\partial_j h \\right),\n$$\n其中 $\\partial_i = \\partial / \\partial \\theta_i$。\n- 在限制振幅近似下，对于 $h(f) = A(f) e^{i\\Psi(f)}$，可以使用\n$$\n\\partial_i h(f) = h(f)\\left[ \\partial_i \\ln A(f) + i \\,\\partial_i \\Psi(f) \\right],\n$$\n这意味着\n$$\n\\Gamma_{ij} = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{|h(f)|^2}{S_n(f)} \\left[ \\partial_i \\ln A(f) \\,\\partial_j \\ln A(f) + \\partial_i \\Psi(f) \\,\\partial_j \\Psi(f) \\right] df.\n$$\n- 对参数采用标准差为 $\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}}$、$\\sigma_{\\eta,\\mathrm{prior}}$ 和 $\\sigma_{\\chi,\\mathrm{prior}}$ 的独立高斯先验，这会贡献一个先验精度矩阵 $\\Pi = \\mathrm{diag}(\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}}^{-2}, \\sigma_{\\eta,\\mathrm{prior}}^{-2}, \\sigma_{\\chi,\\mathrm{prior}}^{-2})$。那么，线性高斯后验协方差为\n$$\n\\Sigma = \\left( \\Gamma + \\Pi \\right)^{-1}.\n$$\n\n您的任务：\n- 从上述基础出发，推导计算 $\\partial_i \\ln A(f)$ 和 $\\partial_i \\Psi(f)$（其中 $\\theta_i \\in \\{M_{\\mathrm{c}}, \\eta, \\chi\\}$）所需的表达式，实现费雪信息矩阵，整合高斯先验，并从 $\\Sigma$ 计算后验标准差 $\\sigma_{M_{\\mathrm{c}}}$、$\\sigma_{\\eta}$、$\\sigma_{\\chi}$ 以及所有参数对之间的相关系数。同时计算最优信噪比 $\\rho$。\n- 内部使用几何单位制，其中 $G=c=1$，因此质量和距离的单位是秒，频率的单位是 $\\mathrm{Hz}$。对于单位转换，使用以下物理上一致的常数：\n  - 时间单位表示的太阳质量：$t_\\odot = G M_\\odot / c^3 = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}$。\n  - 时间单位表示的百万秒差距：$1\\,\\mathrm{Mpc} = 3.085677581491367 \\times 10^{22}\\,\\mathrm{m}$ 且 $c = 299{,}792{,}458\\,\\mathrm{m/s}$，因此 $1\\,\\mathrm{Mpc}/c = 1.029271250 \\times 10^{14}\\,\\mathrm{s}$。\n- 将频率上限截止值设置为用户提供的上限 $f_{\\mathrm{cap}}$ 和 Schwarzschild 黑洞的最内稳定圆轨道频率中的较小者，\n$$\nf_{\\mathrm{ISCO}}(M) = \\frac{1}{6^{3/2} \\pi M}.\n$$\n- 先验：使用高斯先验，标准差分别为 $\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}} = 50\\,M_\\odot$（内部转换为秒）、$\\sigma_{\\eta,\\mathrm{prior}} = 0.10$ 和 $\\sigma_{\\chi,\\mathrm{prior}} = 0.50$。\n\n要求的输出和单位：\n- 对每个测试案例，按以下顺序报告一个包含七个浮点数的列表：\n  1) 啁啾质量的后验标准差 $\\sigma_{M_{\\mathrm{c}}}$，单位为 $M_\\odot$，\n  2) 后验标准差 $\\sigma_{\\eta}$（无量纲），\n  3) 后验标准差 $\\sigma_{\\chi}$（无量纲），\n  4) 相关系数 $\\mathrm{corr}(M_{\\mathrm{c}},\\eta)$，\n  5) 相关系数 $\\mathrm{corr}(M_{\\mathrm{c}},\\chi)$，\n  6) 相关系数 $\\mathrm{corr}(\\eta,\\chi)$，\n  7) 最优信噪比 $\\rho$（无量纲）。\n- 确保所有与质量相关的输出都按规定以太阳质量表示，所有其他输出均为无量纲。\n\n数值实现细节：\n- 在 $f_{\\mathrm{low}}$ 和 $f_{\\mathrm{high}}$ 之间足够精细的线性网格上，使用黎曼和或梯形法则进行频率积分的数值计算。\n- 每个测试案例至少使用 $N=4000$ 个频率样本。\n- 在对费雪矩阵求逆之前，通过加上先验精度矩阵来确保数值稳定性。\n\n测试套件：\n实现程序以计算以下三个测试案例的输出。下面给出的所有质量单位为 $M_\\odot$，距离单位为 $\\mathrm{Mpc}$；代码必须按照单位说明将它们内部转换为秒，然后以指定单位报告所需的输出。\n- 案例 1 (平衡、中等质量、零自旋)：\n  - $M_{\\mathrm{c}} = 26.0$, $\\eta = 0.25$, $\\chi = 0.0$, $D_L = 500.0$, $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $f_{\\mathrm{cap}} = 512\\,\\mathrm{Hz}$。\n- 案例 2 (较低质量、正自旋、较高带宽)：\n  - $M_{\\mathrm{c}} = 8.7$, $\\eta = 0.25$, $\\chi = 0.6$, $D_L = 400.0$, $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $f_{\\mathrm{cap}} = 1024\\,\\mathrm{Hz}$。\n- 案例 3 (不对称质量比、负自旋、低信噪比)：\n  - $M_{\\mathrm{c}} = 15.0$, $\\eta = 0.16$, $\\chi = -0.4$, $D_L = 2000.0$, $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $f_{\\mathrm{cap}} = 512\\,\\mathrm{Hz}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的 Python 风格列表，该列表包含三个子列表，每个子列表对应一个测试案例，且每个子列表按指定顺序包含七个浮点数。例如，必须打印一个结构上类似于\n$$\n\\texttt{[[x\\_11,x\\_12,\\dots,x\\_17],[x\\_21,x\\_22,\\dots,x\\_27],[x\\_31,x\\_32,\\dots,x\\_37]]}\n$$\n的输出，其中每个 $x\\_{ij}$ 是如上定义的浮点数。不应打印任何其他文本。\n\n按要求以 $M_\\odot$ 表示啁啾质量的不确定性，所有其他量均为无量纲数。此问题不使用角度。将所有数值报告为原始十进制浮点数（无百分号）。", "solution": "用户希望设计并实现一个程序，用于对来自双黑洞旋进的简化引力波信号进行贝叶斯参数估计。该估计将在依赖于费雪信息矩阵的线性高斯（拉普拉斯）近似下进行。待估计的参数是啁啾质量 $M_{\\mathrm{c}}$、对称质量比 $\\eta$ 和有效对齐自旋 $\\chi$。\n\n解决方案将分三个主要阶段进行开发：\n1.  费雪信息矩阵所需分量的解析推导，特别是波形的对数振幅和相位对模型参数的偏导数。\n2.  构建数值算法，用于计算费雪矩阵、整合先验信息并推导后验协方差，从中提取不确定度和相关性。\n3.  指定完整和正确实现所需的常数和单位转换。\n\n令参数向量为 $\\theta = (\\theta_1, \\theta_2, \\theta_3) = (M_{\\mathrm{c}}, \\eta, \\chi)$。\n\n### 1. 费雪矩阵的解析推导\n\n费雪信息矩阵 $\\Gamma_{ij}$ 由波形 $h(f)$ 对参数 $\\theta_i$ 和 $\\theta_j$ 的偏导数的噪声加权内积定义。对于形式为 $h(f) = A(f) e^{i\\Psi(f)}$ 的波形，其中 $A(f)$ 是实值振幅，给出的费雪矩阵公式为：\n$$\n\\Gamma_{ij} = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{A(f)^2}{S_n(f)} \\left[ (\\partial_i \\ln A(f)) (\\partial_j \\ln A(f)) + (\\partial_i \\Psi(f)) (\\partial_j \\Psi(f)) \\right] df\n$$\n此处，$\\partial_i$ 表示偏导数 $\\partial/\\partial\\theta_i$。我们的任务简化为计算对数振幅 $\\ln A(f)$ 和相位 $\\Psi(f)$ 分别对 $M_{\\mathrm{c}}$、$\\eta$ 和 $\\chi$ 的导数。所有计算都将在几何单位制（$G=c=1$）下进行。\n\n**1.1. 对数振幅导数**\n\n振幅由 $A(f) \\equiv |\\mathcal{A}(f)| = \\mathcal{C} \\frac{M_{\\mathrm{c}}^{5/6}}{D_L} f^{-7/6}$ 给出。其自然对数为：\n$$\n\\ln A(f) = \\ln\\left(\\frac{\\mathcal{C}}{D_L}\\right) + \\frac{5}{6}\\ln M_{\\mathrm{c}} - \\frac{7}{6}\\ln f\n$$\n在此背景下，光度距离 $D_L$ 被视为一个固定的无关参数。关于我们的参数 $\\theta = (M_{\\mathrm{c}}, \\eta, \\chi)$ 的偏导数为：\n\\begin{align*}\n\\partial_{M_{\\mathrm{c}}} \\ln A(f) = \\frac{5}{6 M_{\\mathrm{c}}} \\\\\n\\partial_{\\eta} \\ln A(f) = 0 \\\\\n\\partial_{\\chi} \\ln A(f) = 0\n\\end{align*}\n振幅仅依赖于啁啾质量，这极大地简化了费雪矩阵中与振幅相关的项。\n\n**1.2. 相位导数**\n\n相位导数的计算需要仔细应用链式法则。相位 $\\Psi(f)$ 是后牛顿速度参数 $v$ 的函数，而 $v$ 又依赖于总质量 $M$，因此依赖于 $M_{\\mathrm{c}}$ 和 $\\eta$。相位还显式地依赖于 $\\eta$，并通过系数 $\\alpha_2$ 和 $\\alpha_3$ 隐式地依赖于 $\\eta$ 和 $\\chi$。\n\n关键的依赖关系是：\n$M = M_{\\mathrm{c}} \\eta^{-3/5}$，$v = (\\pi M f)^{1/3}$，$\\alpha_2(\\eta) = \\frac{3715}{756} + \\frac{55}{9}\\eta$，以及 $\\alpha_3(\\eta, \\chi) = 4\\beta - 16\\pi$ 其中 $\\beta(\\eta, \\chi) = (\\frac{113}{12} - \\frac{19}{3}\\eta)\\chi$。\n\n完整的相位表达式为：\n$$\n\\Psi(f) = \\frac{3}{128 \\, \\eta} \\left( v^{-5} + \\alpha_2 v^{-3} + \\alpha_3 v^{-2} \\right)\n$$\n使用链式法则，我们推导出以下偏导数：\n\n- **关于啁啾质量（$M_{\\mathrm{c}}$）的导数：**\n依赖关系为 $\\Psi \\rightarrow v \\rightarrow M \\rightarrow M_{\\mathrm{c}}$。\n$$\n\\partial_{M_{\\mathrm{c}}} \\Psi(f) = \\frac{\\partial \\Psi}{\\partial v} \\frac{\\partial v}{\\partial M} \\frac{\\partial M}{\\partial M_{\\mathrm{c}}}\n$$\n中间导数为 $\\frac{\\partial M}{\\partial M_{\\mathrm{c}}} = \\eta^{-3/5}$，$\\frac{\\partial v}{\\partial M} = \\frac{v}{3M}$，以及 $\\frac{\\partial \\Psi}{\\partial v} = \\frac{3}{128\\eta}(-5v^{-6} - 3\\alpha_2v^{-4} - 2\\alpha_3v^{-3})$。将它们组合起来得到：\n$$\n\\partial_{M_{\\mathrm{c}}} \\Psi(f) = \\frac{1}{128 \\eta M_{\\mathrm{c}}} \\left( -5 v^{-5} - 3 \\alpha_2 v^{-3} - 2 \\alpha_3 v^{-2} \\right)\n$$\n\n- **关于对称质量比（$\\eta$）的导数：**\n参数 $\\eta$ 通过 $v$、$\\alpha_2$ 和 $\\alpha_3$ 显式和隐式地出现。完整的求导计算得出：\n$$\n\\partial_{\\eta} \\Psi(f) = \\frac{3}{128\\eta^2} \\left[ \\left(\\frac{55}{9}\\eta - \\frac{2}{5}\\alpha_2\\right)v^{-3} + \\left(-\\frac{76}{3}\\chi\\eta - \\frac{3}{5}\\alpha_3\\right)v^{-2} \\right]\n$$\n\n- **关于有效自旋（$\\chi$）的导数：**\n自旋 $\\chi$ 仅通过系数 $\\alpha_3$ 进入相位。依赖关系为 $\\Psi \\rightarrow \\alpha_3 \\rightarrow \\beta \\rightarrow \\chi$。\n$$\n\\partial_{\\chi} \\Psi(f) = \\frac{\\partial \\Psi}{\\partial \\alpha_3} \\frac{\\partial \\alpha_3}{\\partial \\chi}\n$$\n根据 $\\frac{\\partial \\Psi}{\\partial \\alpha_3} = \\frac{3}{128\\eta}v^{-2}$ 和 $\\frac{\\partial \\alpha_3}{\\partial \\chi} = 4(\\frac{113}{12} - \\frac{19}{3}\\eta)$，我们得到：\n$$\n\\partial_{\\chi} \\Psi(f) = \\frac{1}{128 \\eta} (113 - 76\\eta) v^{-2}\n$$\n\n### 2. 数值算法\n\n将推导出的表达式在一个数值算法中实现，以计算每个测试案例所需的后验量。\n\n1.  **初始化：** 定义用于单位转换的物理常数：太阳质量到秒（$t_\\odot$）和百万秒差距到秒（$1\\,\\mathrm{Mpc}/c$）。将每个案例的程序输入（$M_{\\mathrm{c}}$ 单位 $M_\\odot$，$\\eta$，$\\chi$，$D_L$ 单位 Mpc，$f_{\\mathrm{low}}$，$f_{\\mathrm{cap}}$）转换为几何单位（秒）。\n2.  **频率网格：** 从 $f_{\\mathrm{low}}$ 到 $f_{\\mathrm{high}} = \\min(f_{\\mathrm{cap}}, f_{\\mathrm{ISCO}}(M))$ 构建一个离散频率网格 $f_k$，其中 $f_{\\mathrm{ISCO}}(M) = (6^{3/2} \\pi M)^{-1}$ 是最内稳定圆轨道频率。使用一个包含 $N=4000$ 个点的网格进行数值积分。\n3.  **被积函数计算：** 对于网格上的每个频率 $f_k$，我们计算以下量：\n    - 噪声功率谱密度 $S_n(f_k)$。\n    - 波形振幅的平方 $A(f_k)^2$。\n    - 相位导数 $\\partial_i \\Psi(f_k)$ 和常数对数振幅导数 $\\partial_i \\ln A(f_k)$ 的数值。\n    - 权重函数 $W(f_k) = 4 A(f_k)^2 / S_n(f_k)$。\n    - 在 $f_k$ 处的 $3 \\times 3$ 费雪矩阵被积函数：$I_{\\Gamma,ij}(f_k) = W(f_k) \\left[ (\\partial_i \\ln A) (\\partial_j \\ln A) + (\\partial_i \\Psi(f_k)) (\\partial_j \\Psi(f_k)) \\right]$。\n4.  **数值积分：** 通过在频率网格上使用梯形法则（例如，通过 `numpy.trapz`）对各自的被积函数进行数值积分，来计算费雪矩阵 $\\Gamma$ 和信噪比的平方 $\\rho^2$。\n    - $\\Gamma_{ij} = \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} I_{\\Gamma,ij}(f) df$\n    - $\\rho^2 = \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} W(f) df$\n5.  **后验协方差：** 通过将先验精度矩阵 $\\Pi$ 加到费雪矩阵上来整合高斯先验。$\\Pi$ 是对角矩阵，其元素为 $\\Pi_{ii} = 1/\\sigma_{i, \\mathrm{prior}}^2$。先验的参数空间标准差给定为 $\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}} = 50\\,M_\\odot$、$\\sigma_{\\eta,\\mathrm{prior}} = 0.10$ 和 $\\sigma_{\\chi,\\mathrm{prior}} = 0.50$。啁啾质量的先验必须转换为秒。后验协方差矩阵 $\\Sigma$ 是该和的逆：\n    $$\n    \\Sigma = (\\Gamma + \\Pi)^{-1}\n    $$\n6.  **提取结果：** 从后验协方差矩阵 $\\Sigma$ 中提取最终的量：\n    - 后验标准差：$\\sigma_i = \\sqrt{\\Sigma_{ii}}$。\n    - 相关系数：$\\mathrm{corr}(\\theta_i, \\theta_j) = \\frac{\\Sigma_{ij}}{\\sqrt{\\Sigma_{ii}\\Sigma_{jj}}}$。\n    - 最优信噪比为 $\\rho = \\sqrt{\\rho^2}$。\n7.  **最终处理：** 将以秒为单位计算出的啁啾质量后验标准差 $\\sigma_{M_{\\mathrm{c}}}$ 转换回太阳质量单位（$M_\\odot$）以用于最终输出。将每个测试案例的结果按规定编译成一个包含七个浮点数的列表。\n\n这个过程构成了一个完整的、基于原理的解决该问题的算法。解析导数提供了与底层物理模型的连接，而数值步骤则实现了费雪矩阵近似的统计框架。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the gravitational wave parameter estimation problem\n    for the given test cases.\n    \"\"\"\n\n    # Physical and model constants in SI units, and conversion factors.\n    # Solar mass to seconds: G*M_sun/c^3\n    T_SUN = 4.92549095e-6\n    # Megaparsec to seconds: 1 Mpc / c\n    MPC_TO_S = 1.029271250e14\n    # Constant C in waveform amplitude\n    C_CONST = np.sqrt(5.0 / 24.0) * np.pi**(-2.0 / 3.0)\n\n    # Noise curve parameters for S_n(f)\n    S0 = 1e-47  # Hz^-1\n    F0 = 50.0   # Hz\n    F1 = 200.0  # Hz\n\n    # Prior standard deviations\n    SIGMA_MC_PRIOR_MSUN = 50.0\n    SIGMA_ETA_PRIOR = 0.10\n    SIGMA_CHI_PRIOR = 0.50\n\n    # Numerical integration settings\n    N_FREQ_SAMPLES = 4000\n\n    def perform_calculation(case_params):\n        \"\"\"\n        Performs the Fisher matrix calculation for a single test case.\n        \n        Args:\n            case_params (tuple): A tuple containing (Mc_msun, eta, chi, DL_mpc, f_low, f_cap).\n        \n        Returns:\n            list: A list of 7 floats representing the results.\n        \"\"\"\n        Mc_msun, eta, chi, DL_mpc, f_low, f_cap = case_params\n\n        # 1. Unit Conversions (to geometric units where G=c=1, time/mass/length in seconds)\n        Mc = Mc_msun * T_SUN\n        DL = DL_mpc * MPC_TO_S\n        sigma_mc_prior_s = SIGMA_MC_PRIOR_MSUN * T_SUN\n\n        # 2. Setup frequency grid\n        M = Mc * eta**(-3.0 / 5.0)  # Total mass in seconds\n        f_isco = 1.0 / (6.0**(1.5) * np.pi * M)\n        f_high = min(f_cap, f_isco)\n        f = np.linspace(f_low, f_high, N_FREQ_SAMPLES)\n\n        # 3. Calculate frequency-dependent quantities (vectorized)\n        # Power Spectral Density\n        Sn = S0 * ((F0 / f)**4 + 1 + (f / F1)**2)\n        # Squared amplitude\n        A_sq = (C_CONST * Mc**(5.0/6.0) / DL * f**(-7.0/6.0))**2\n        \n        # PN parameters and coefficients\n        v = (np.pi * M * f)**(1.0/3.0)\n        alpha2 = 3715.0/756.0 + 55.0/9.0 * eta\n        beta = (113.0/12.0 - 19.0/3.0 * eta) * chi\n        alpha3 = 4.0 * beta - 16.0 * np.pi\n\n        # 4. Calculate derivatives\n        # Log-amplitude derivatives (constants in frequency)\n        d_logA_dMc = 5.0 / (6.0 * Mc)\n        d_logA_deta = 0.0\n        d_logA_dchi = 0.0\n        d_logA_dtheta = np.array([d_logA_dMc, d_logA_deta, d_logA_dchi])\n\n        # Phase derivatives (functions of frequency)\n        v_m2 = v**-2\n        v_m3 = v**-3\n        v_m5 = v**-5\n        \n        d_psi_dMc = (1.0 / (128.0 * eta * Mc)) * (-5.0 * v_m5 - 3.0 * alpha2 * v_m3 - 2.0 * alpha3 * v_m2)\n        \n        term_eta_1 = (55.0/9.0 * eta - 2.0/5.0 * alpha2) * v_m3\n        term_eta_2 = (-76.0/3.0 * chi * eta - 3.0/5.0 * alpha3) * v_m2\n        d_psi_deta = (3.0 / (128.0 * eta**2)) * (term_eta_1 + term_eta_2)\n        \n        d_psi_dchi = (1.0 / (128.0 * eta)) * (113.0 - 76.0 * eta) * v_m2\n        \n        d_psi_dtheta = np.stack([d_psi_dMc, d_psi_deta, d_psi_dchi], axis=-1)\n\n        # 5. Compute Fisher matrix integrand\n        weight = 4.0 * A_sq / Sn\n        \n        # Term for logA derivatives: shape (3,3)\n        term_logA = np.outer(d_logA_dtheta, d_logA_dtheta)\n        \n        # Term for Psi derivatives: shape (N, 3, 3)\n        term_psi = d_psi_dtheta[:, :, np.newaxis] * d_psi_dtheta[:, np.newaxis, :]\n        \n        # Full integrand for Gamma: shape (N, 3, 3)\n        integrand_gamma = weight[:, np.newaxis, np.newaxis] * (term_logA[np.newaxis, :, :] + term_psi)\n\n        # 6. Numerical Integration\n        Gamma = np.trapz(integrand_gamma, x=f, axis=0)\n        rho_sq = np.trapz(weight, x=f)\n        rho = np.sqrt(rho_sq)\n\n        # 7. Incorporate Priors and Compute Covariance\n        Pi = np.diag([\n            1.0 / sigma_mc_prior_s**2,\n            1.0 / SIGMA_ETA_PRIOR**2,\n            1.0 / SIGMA_CHI_PRIOR**2\n        ])\n        \n        # Posterior covariance matrix\n        Sigma = np.linalg.inv(Gamma + Pi)\n\n        # 8. Extract Results\n        sigma_mc_s = np.sqrt(Sigma[0, 0])\n        sigma_eta = np.sqrt(Sigma[1, 1])\n        sigma_chi = np.sqrt(Sigma[2, 2])\n\n        # Correlation coefficients\n        corr_mc_eta = Sigma[0, 1] / (sigma_mc_s * sigma_eta)\n        corr_mc_chi = Sigma[0, 2] / (sigma_mc_s * sigma_chi)\n        corr_eta_chi = Sigma[1, 2] / (sigma_eta * sigma_chi)\n\n        # 9. Unit conversion for output\n        sigma_mc_msun = sigma_mc_s / T_SUN\n\n        return [sigma_mc_msun, sigma_eta, sigma_chi, corr_mc_eta, corr_mc_chi, corr_eta_chi, rho]\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: (Mc[Msun], eta, chi, DL[Mpc], flow[Hz], fcap[Hz])\n        (26.0, 0.25, 0.0, 500.0, 20.0, 512.0),\n        # Case 2:\n        (8.7, 0.25, 0.6, 400.0, 20.0, 1024.0),\n        # Case 3:\n        (15.0, 0.16, -0.4, 2000.0, 20.0, 512.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result_list = perform_calculation(case)\n        all_results.append(result_list)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3479528"}]}