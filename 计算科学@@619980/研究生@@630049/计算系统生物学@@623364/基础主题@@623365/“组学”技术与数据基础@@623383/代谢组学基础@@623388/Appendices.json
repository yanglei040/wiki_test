{"hands_on_practices": [{"introduction": "在质谱分析中，一个代谢物常常会因为形成多种加合物或带有不同电荷而产生多个信号。要从这些混合信号（$y$）中准确反推出原始代谢物的浓度（$x$），我们需要将此过程建模为一个线性系统（$y = Ax$）。这项实践的核心挑战是“可识别性”问题：我们能否唯一地确定 $x$？本练习将指导你运用矩阵的秩和条件数等线性代数工具，来评估定量结果的可靠性与数值稳定性，这是从原始数据中获得有意义的生物学洞见的基石。[@problem_id:3311156]", "problem": "考虑一个代谢组学中的质谱分析测量模型，其中多种加合物和电荷态导致了代谢物贡献的线性混合。该测量模型是加性的，由 $y = A x + \\epsilon$ 给出，其中 $y \\in \\mathbb{R}^{m}$ 是在 $m$ 个提取离子特征上观测到的信号向量，$x \\in \\mathbb{R}^{n}$ 是 $n$ 种代谢物的非负浓度向量，$A \\in \\mathbb{R}^{m \\times n}$ 编码了从代谢物浓度到期望特征强度的线性化加合物和电荷态映射，而 $\\epsilon \\in \\mathbb{R}^{m}$ 是加性测量噪声。在这种情况下，可辨识性测试应确定在给定的 $A$ 和 $\\epsilon$ 下，从 $y$到 $x$ 的映射对于 $x$ 是否是唯一可逆的，并且评估该反演过程在数值上是否稳定。从线性系统和最小二乘法的基础出发，如下定义和实现可辨识性：当线性映射具有平凡核时，$x$ 存在理论唯一性，而最小二乘唯一性等价地由法算子的正定性来表征。对于数值稳定性，通过由奇异值定义的 $A$ 的条件数来量化其灵敏度。您的程序必须为每种情况实现以下输出：一个表示理论可辨识性的布尔值，一个在指定条件数阈值下表示实践数值可辨识性的布尔值，$A$ 的条件数，以及最小化 $\\lVert y - A x \\rVert_2^2$ 的最小二乘解的估计误差的欧几里得范数。\n\n使用以下由显式指定的矩阵和向量组成的参数值测试套件。在所有情况下，通过 $y = A x_{\\text{true}} + \\epsilon$ 构建 $y$。目标是确定在给定的 $A$ 和 $\\epsilon$ 下，$x$ 是否可以从 $y$ 唯一确定，并量化其稳定性和估计误差。\n\n情况 $\\mathbf{1}$（理想情况，列满秩，中等条件数）：设 $m = 5, n = 3$，\n$$\nA^{(1)} = \\begin{bmatrix}\n1.0  0.8  0.6 \\\\\n0.5  0.4  0.3 \\\\\n0.1  0.05  0.0 \\\\\n0.3  0.2  0.1 \\\\\n0.0  0.1  0.4\n\\end{bmatrix},\\quad\nx_{\\text{true}}^{(1)} = \\begin{bmatrix} 10.0 \\\\ 5.0 \\\\ 2.0 \\end{bmatrix},\\quad\n\\epsilon^{(1)} = \\begin{bmatrix} 0.01 \\\\ -0.02 \\\\ 0.0 \\\\ 0.005 \\\\ -0.01 \\end{bmatrix}.\n$$\n\n情况 $\\mathbf{2}$（因加合物模糊性导致的秩亏）：设 $m = 5, n = 4$，其中两列相同，表示无法区分的加合物贡献，\n$$\nA^{(2)} = \\begin{bmatrix}\n1.0  0.7  0.3  0.7 \\\\\n0.2  0.1  0.05  0.1 \\\\\n0.0  0.2  0.1  0.2 \\\\\n0.3  0.1  0.2  0.1 \\\\\n0.4  0.6  0.5  0.6\n\\end{bmatrix},\\quad\nx_{\\text{true}}^{(2)} = \\begin{bmatrix} 3.0 \\\\ 1.5 \\\\ 2.0 \\\\ 0.5 \\end{bmatrix},\\quad\n\\epsilon^{(2)} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.01 \\\\ -0.01 \\end{bmatrix}.\n$$\n\n情况 $\\mathbf{3}$（病态，近似共线的加合物映射）：设 $m = 6, n = 3$，定义 $A^{(3)}$ 的列为\n$$\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.5 \\\\ 0.2 \\\\ 0.1 \\\\ 0.05 \\\\ 0.02 \\end{bmatrix},\\quad\nc_2 = \\begin{bmatrix} 1.0 \\cdot (1 + 10^{-10}) \\\\ 0.5 \\cdot (1 + 10^{-10}) \\\\ 0.2 \\cdot (1 + 10^{-10}) \\\\ 0.1 \\cdot (1 + 10^{-10}) \\\\ 0.05 \\cdot (1 + 10^{-10}) \\\\ 0.02 \\cdot (1 + 10^{-10}) + 10^{-12} \\end{bmatrix},\\quad\nc_3 = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.002 \\\\ 0.001 \\\\ 0.0005 \\\\ 0.0002 \\end{bmatrix},\n$$\n且 $A^{(3)} = [\\,c_1\\; c_2\\; c_3\\,]$,\n$$\nx_{\\text{true}}^{(3)} = \\begin{bmatrix} 10.0 \\\\ 10.0 \\\\ 0.5 \\end{bmatrix},\\quad\n\\epsilon^{(3)} = \\begin{bmatrix} 10^{-6} \\\\ -10^{-6} \\\\ 2\\cdot 10^{-6} \\\\ -2\\cdot 10^{-6} \\\\ 10^{-6} \\\\ -10^{-6} \\end{bmatrix}.\n$$\n\n情况 $\\mathbf{4}$（欠定系统：代谢物多于特征）：设 $m = 3, n = 5$，\n$$\nA^{(4)} = \\begin{bmatrix}\n1.0  0.2  0.0  0.5  0.1 \\\\\n0.0  0.1  1.0  0.0  0.2 \\\\\n0.5  0.3  0.2  0.1  0.0\n\\end{bmatrix},\\quad\nx_{\\text{true}}^{(4)} = \\begin{bmatrix} 1.0 \\\\ 2.0 \\\\ 0.5 \\\\ 0.8 \\\\ 0.3 \\end{bmatrix},\\quad\n\\epsilon^{(4)} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}.\n$$\n\n情况 $\\mathbf{5}$（方阵系统，异方差噪声）：设 $m = 4, n = 4$，\n$$\nA^{(5)} = \\begin{bmatrix}\n1.0  0.0  0.5  0.2 \\\\\n0.1  1.0  0.3  0.0 \\\\\n0.0  0.2  1.0  0.1 \\\\\n0.3  0.0  0.0  1.0\n\\end{bmatrix},\\quad\nx_{\\text{true}}^{(5)} = \\begin{bmatrix} 2.0 \\\\ 1.0 \\\\ 0.5 \\\\ 3.0 \\end{bmatrix},\\quad\n\\epsilon^{(5)} = \\begin{bmatrix} 0.05 \\\\ -0.02 \\\\ 0.1 \\\\ -0.15 \\end{bmatrix}.\n$$\n\n您的程序必须基于以下第一性原理准则：$x$ 的理论可辨识性取决于线性映射 $A$ 是否为列满秩，这意味着 $A$ 的核为 $\\{0\\}$ 且法算子 $A^{\\top}A$ 是正定的；最小二乘唯一性等价于此列满秩条件。实践中的数值可辨识性通过限制条件数来确定，定义为 $\\kappa(A) = s_{\\max}/s_{\\min}$，其中 $s_{\\max}$ 和 $s_{\\min}$ 是 $A$ 的最大和最小奇异值。使用奇异值阈值 $\\tau = 10^{-12} s_{\\max}$ 计算秩，并且仅当理论可辨识性成立且 $\\kappa(A)  10^{8}$ 时，才声明实践数值可辨识性成立。对于每种情况，计算一个最小二乘估计 $\\hat{x}$ 作为 $\\lVert y - A x \\rVert_2^2$ 的最小化子，并报告估计误差范数 $\\lVert \\hat{x} - x_{\\text{true}} \\rVert_2$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个列表的列表，每个内部列表对应一种情况，形式为 $[b_{\\text{theory}}, b_{\\text{numeric}}, \\kappa, e]$，其中 $b_{\\text{theory}}$ 和 $b_{\\text{numeric}}$ 分别是表示理论和实践可辨识性的布尔值，$\\kappa$ 是 $A$ 的条件数，$e$ 是估计误差的欧几里得范数。将浮点数 $\\kappa$ 和 $e$ 四舍五入到 $6$ 位小数。程序必须以该确切格式输出此单行内容，例如 $[[\\text{True},\\text{True},1.234567,0.000001],[\\dots]]$，不带任何附加文本。不涉及物理单位。不使用角度。不使用百分比。该列表必须完全由指定的输入确定，无任何随机性。", "solution": "该问题要求对线性模型 $y = A x + \\epsilon$ 进行可辨识性分析，这是代谢组学中质谱数据的常见表示。在这里，$y \\in \\mathbb{R}^{m}$ 代表 $m$ 个离子特征的测量强度，$x \\in \\mathbb{R}^{n}$ 是 $n$ 种代谢物的浓度向量，$A \\in \\mathbb{R}^{m \\times n}$ 是一个线性映射矩阵，它将代谢物浓度映射到它们对离子特征的期望贡献，其中考虑了加合物和电荷态。项 $\\epsilon \\in \\mathbb{R}^{m}$ 代表加性测量噪声。任务是评估在给定映射 $A$ 的情况下，从测量值 $y$ 中辨识代谢物浓度 $x$ 的理论和实践可辨识性。\n\n**1. 理论可辨识性**\n\n理论可辨识性关注在理想化的无噪声情况（即 $\\epsilon=0$）下，对于系统 $y = Ax$，$x$ 解的唯一性。对于任何给定的 $y$（在 $A$ 的值域内），$x$ 的唯一解存在的充要条件是，由 $A$ 表示的线性映射是一对一（单射）的。这等价于矩阵 $A$ 的零空间（或核）是平凡的，即只包含零向量：$\\ker(A) = \\{0\\}$。\n\n对于一个矩阵 $A \\in \\mathbb{R}^{m \\times n}$，其核为平凡的充要条件是它的列是线性无关的。这意味着矩阵的秩必须等于其列数 $n$。形式上，理论可辨识性的条件是：\n$$\n\\text{rank}(A) = n\n$$\n这个条件也被称为 $A$ 具有列满秩。如果该条件成立，则格拉姆矩阵 $A^{\\top}A \\in \\mathbb{R}^{n \\times n}$ 是对称正定的，这保证了唯一的最小二乘解存在。\n\n列满秩的一个必要条件是行数（测量数）必须大于或等于列数（未知数），即 $m \\geq n$。如果 $m  n$，则系统是欠定的，$\\text{rank}(A) \\leq m  n$，不可能有唯一的 $x$ 解；此时存在一个无限解族。\n\n**2. 实践与数值可辨识性**\n\n即使一个系统在理论上是可辨识的（即 $A$ 列满秩），由于数值不稳定性，它在实践中也可能变得不可辨识。如果 $A$ 的列近似线性相关，系统就被称为是病态的。在这种情况下，由噪声 $\\epsilon$ 引起的测量向量 $y$ 的微小扰动可能导致估计解 $\\hat{x}$ 发生非常大的变化。\n\n这种敏感性由矩阵 $A$ 的条件数来量化，记为 $\\kappa(A)$。使用 $A$ 的奇异值，其中 $s_{\\max}$ 是最大的非零奇异值，$s_{\\min}$ 是最小的非零奇异值，条件数定义为：\n$$\n\\kappa(A) = \\frac{s_{\\max}}{s_{\\min}}\n$$\n一个良态矩阵的条件数很小（接近 1），而一个病态矩阵的条件数非常大。问题指定了一个阈值 $10^8$：仅当系统理论上可辨识且 $\\kappa(A)  10^8$ 时，才认为其在实践上是可辨识的。\n\n**3. 计算算法**\n\n对于由一组参数 $(A, x_{\\text{true}}, \\epsilon)$ 指定的每个测试用例，执行以下步骤：\n1.  构造测量向量 $y$ 为 $y = A x_{\\text{true}} + \\epsilon$。\n2.  计算 $A$ 的奇异值分解（SVD）。SVD 产生奇异值 $\\{s_i\\}$，用于所有后续分析。\n3.  **确定理论可辨识性 ($b_{\\text{theory}}$)**。通过计算满足 $s_i > \\tau$ 的奇异值 $s_i$ 的数量来确定 $A$ 的秩，其中阈值 $\\tau$ 定义为 $\\tau = 10^{-12} s_{\\max}$。如果计算出的秩等于 $n$，则 $b_{\\text{theory}}$ 设置为 `True`；否则为 `False`。\n4.  **确定实践可辨识性 ($b_{\\text{numeric}}$)**。根据奇异值计算条件数 $\\kappa(A)$。如果 $b_{\\text{theory}}$ 为 `True` 且 $\\kappa(A)  10^8$，则 $b_{\\text{numeric}}$ 设置为 `True`；否则为 `False`。\n5.  **计算最小二乘估计 ($\\hat{x}$)**。这是使残差的平方欧几里得范数 $\\|y - A x\\|_2^2$ 最小化的向量 $\\hat{x}$。这可以通过标准的数值线性代数程序（如 `numpy.linalg.lstsq`）稳健地计算，这些程序能正确处理满秩、秩亏和欠定系统。对于秩亏和欠定情况，此函数返回唯一的最小范数解。\n6.  **计算估计误差 ($e$)**。计算为估计浓度向量与真实浓度向量之差的欧几里得范数：$e = \\|\\hat{x} - x_{\\text{true}}\\|_2$。\n\n此过程系统地评估了每个案例，依据可辨识性和数值稳定性的严格标准，为底层逆问题的可解性提供了定量评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and format the results for all test cases.\n    \"\"\"\n\n    # Case 1: Happy path, full column rank, moderate conditioning\n    A1 = np.array([\n        [1.0, 0.8, 0.6],\n        [0.5, 0.4, 0.3],\n        [0.1, 0.05, 0.0],\n        [0.3, 0.2, 0.1],\n        [0.0, 0.1, 0.4]\n    ])\n    x_true1 = np.array([10.0, 5.0, 2.0])\n    epsilon1 = np.array([0.01, -0.02, 0.0, 0.005, -0.01])\n    case1 = (A1, x_true1, epsilon1)\n\n    # Case 2: Rank-deficient due to adduct ambiguity\n    A2 = np.array([\n        [1.0, 0.7, 0.3, 0.7],\n        [0.2, 0.1, 0.05, 0.1],\n        [0.0, 0.2, 0.1, 0.2],\n        [0.3, 0.1, 0.2, 0.1],\n        [0.4, 0.6, 0.5, 0.6]\n    ])\n    x_true2 = np.array([3.0, 1.5, 2.0, 0.5])\n    epsilon2 = np.array([0.0, 0.0, 0.0, 0.01, -0.01])\n    case2 = (A2, x_true2, epsilon2)\n\n    # Case 3: Ill-conditioned, nearly collinear adduct mappings\n    c1 = np.array([1.0, 0.5, 0.2, 0.1, 0.05, 0.02])\n    c2 = np.array([\n        1.0 * (1.0 + 1e-10), \n        0.5 * (1.0 + 1e-10), \n        0.2 * (1.0 + 1e-10), \n        0.1 * (1.0 + 1e-10), \n        0.05 * (1.0 + 1e-10), \n        0.02 * (1.0 + 1e-10) + 1e-12\n    ])\n    c3 = np.array([0.01, 0.005, 0.002, 0.001, 0.0005, 0.0002])\n    A3 = np.vstack([c1, c2, c3]).T\n    x_true3 = np.array([10.0, 10.0, 0.5])\n    epsilon3 = np.array([1e-6, -1e-6, 2e-6, -2e-6, 1e-6, -1e-6])\n    case3 = (A3, x_true3, epsilon3)\n\n    # Case 4: Underdetermined system\n    A4 = np.array([\n        [1.0, 0.2, 0.0, 0.5, 0.1],\n        [0.0, 0.1, 1.0, 0.0, 0.2],\n        [0.5, 0.3, 0.2, 0.1, 0.0]\n    ])\n    x_true4 = np.array([1.0, 2.0, 0.5, 0.8, 0.3])\n    epsilon4 = np.array([0.0, 0.0, 0.0])\n    case4 = (A4, x_true4, epsilon4)\n\n    # Case 5: Square system\n    A5 = np.array([\n        [1.0, 0.0, 0.5, 0.2],\n        [0.1, 1.0, 0.3, 0.0],\n        [0.0, 0.2, 1.0, 0.1],\n        [0.3, 0.0, 0.0, 1.0]\n    ])\n    x_true5 = np.array([2.0, 1.0, 0.5, 3.0])\n    epsilon5 = np.array([0.05, -0.02, 0.1, -0.15])\n    case5 = (A5, x_true5, epsilon5)\n\n    test_cases = [case1, case2, case3, case4, case5]\n    results = []\n\n    for case in test_cases:\n        A, x_true, epsilon = case\n        \n        # Unpack dimensions\n        m, n = A.shape\n        \n        # Construct observed signal vector y\n        y = A @ x_true + epsilon\n        \n        # --- Identifiability Analysis ---\n        \n        # Compute singular values for rank and condition number\n        s = np.linalg.svd(A, compute_uv=False)\n        \n        # Theoretical identifiability based on rank\n        b_theory = False\n        if s.size > 0: # Handle empty matrix case\n            s_max = s[0]\n            # Rank is computed using the problem-specified threshold\n            rank_threshold = 1e-12 * s_max\n            rank = np.sum(s > rank_threshold)\n            if rank == n:\n                b_theory = True\n        \n        # Compute condition number\n        # np.linalg.cond returns a large number for singular/ill-conditioned matrices\n        kappa = np.linalg.cond(A)\n        \n        # Practical numerical identifiability\n        b_numeric = b_theory and (kappa  1e8)\n        \n        # --- Least Squares Estimation ---\n        \n        # Compute the least-squares estimate for x\n        x_hat = np.linalg.lstsq(A, y, rcond=None)[0]\n        \n        # Compute the Euclidean norm of the estimation error\n        e = np.linalg.norm(x_hat - x_true)\n        \n        # Append the list of results for this case\n        results.append([b_theory, b_numeric, round(float(kappa), 6), round(float(e), 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3311156"}, {"introduction": "在稳定同位素示踪实验中，即便我们已经完成了初步的代谢物定量，一个更高级的校正步骤仍然至关重要。自然界中天然存在的重同位素（如 $^{13}C$）会干扰我们特意引入的示踪剂信号，导致分析结果出现偏差。此实践将自然丰度的影响建模为一个卷积过程，并将校正问题转化为一个线性系统的逆问题。通过从第一性原理构建校正矩阵，你将深入理解如何提纯同位素标记数据，并学会评估结果对自然丰度不确定性的敏感度。[@problem_id:3311163]", "problem": "考虑一个通过高分辨率质谱法测量的代謝物，其质量同位素体分布 (MID) 由一个概率向量 $x_{\\text{true}} \\in \\mathbb{R}^{K+1}$ 表示，其中 $x_{\\text{true}}[j]$ 表示对于 $j \\in \\{0,1,\\dots,K\\}$，分子中恰好有 $j$ 个示踪剂衍生的重同位素取代的概率。分子中的每个非示踪剂原子都独立地发生自然丰度同位素取代，这会产生一个非负整数的质量漂移。将每个原子的质量漂移建模为从 $\\{0,1,\\dots,m\\}$ 上的一个离散分布 $\\pi$ 中的一次独立抽取，其概率为 $\\pi[0],\\pi[1],\\dots,\\pi[m]$，满足 $\\sum_{r=0}^{m} \\pi[r] = 1$，并假设有 $N$ 个这样的原子。定义总自然丰度质量漂移 $S$ 为这 $N$ 次独立抽取之和。观测到的 MID $y_{\\text{obs}} \\in \\mathbb{R}^{K+1}$ 通过以下线性系统与 $x_{\\text{true}}$ 相关\n$$\ny_{\\text{obs}} = P(\\pi)\\, x_{\\text{true}},\n$$\n其中 $P(\\pi) \\in \\mathbb{R}^{(K+1)\\times(K+1)}$ 是一个下三角矩阵，它通过跨原子的离散卷积编码了 $S$ 的分布。你的任务是：从基本原理出发构造 $P(\\pi)$，不使用任何闭式快捷公式；在 $\\pi$ 不确定时校正 $y_{\\text{obs}}$ 以估计 $x_{\\text{true}}$；并量化对 $\\pi$ 中不确定性的敏感度。\n\n基本出发点：仅使用原子的独立性、概率公理以及一个事实，即独立整值随机变量之和的分布由其各自概率质量函数的重复离散卷积给出。将 $x_{\\text{true}}$ 和 $y_{\\text{obs}}$ 视为元素之和为 1 的概率向量。\n\n定义以下计算任务：\n\n1. 给定 $N$、$\\pi$ 和 $K$，构造向量 $h \\in \\mathbb{R}^{K+1}$，其中 $h[r]$ 是对于 $r \\in \\{0,1,\\dots,K\\}$，$S=r$ 的概率。使用原子质量漂移分布 $\\pi$ 的 $N$ 重卷积进行计算（如有必要，截断至 $\\{0,1,\\dots,K\\}$）。然后通过设置以下公式来构造 $P(\\pi)$\n$$\nP(\\pi)[k,j] = \n\\begin{cases}\nh[k-j],  \\text{if } k \\ge j, \\\\\n0,  \\text{if } k  j,\n\\end{cases}\n$$\n其中 $k,j \\in \\{0,1,\\dots,K\\}$。\n\n2. 给定 $y_{\\text{obs}}$ 和估计的 $\\pi_{\\text{est}}$，通过求解一个非负最小二乘问题来计算估计值 $x_{\\text{hat}}$\n$$\n\\min_{x \\in \\mathbb{R}^{K+1}} \\|P(\\pi_{\\text{est}})\\,x - y_{\\text{obs}}\\|_2 \\quad \\text{subject to } x \\ge 0,\n$$\n然后对 $x$进行重新归一化，使其满足 $\\sum_{j=0}^{K} x[j] = 1$。\n\n3. 对 $\\pi$ 的敏感性：设 $\\pi_{\\text{true}}$ 是用于生成 $y_{\\text{obs}}$ 的真实原子分布，$\\pi_{\\text{est}}$ 是用于校正的模型。定义估计误差 $e = \\|x_{\\text{hat}} - x_{\\text{true}}\\|_2$。按如下方式估计 $x_{\\text{hat}}$ 相对于 $\\pi$ 中不确定性的扰动的局部上界。通过沿着一组扰动基的中心差分来数值近似雅可比矩阵 $J = \\partial x_{\\text{hat}} / \\partial \\pi$。这些扰动通过在一个选定分量和一个补偿分量之间转移一个微小量 $\\delta$ 来保持概率单纯形约束 $\\sum_{r=0}^{m} \\pi[r] = 1$。使用诱导算子范数界\n$$\n\\| \\Delta x_{\\text{hat}} \\|_2 \\le \\|\\Delta \\pi\\|_{1} \\cdot \\max_{i} \\| J_{:,i} \\|_2,\n$$\n来计算实际差异的上界，其中 $\\|\\Delta \\pi\\|_{1} = \\|\\pi_{\\text{est}} - \\pi_{\\text{true}}\\|_{1}$。将此界限与 $e$ 一同报告。\n\n4. 同时报告谱条件数 $\\kappa_2(P(\\pi_{\\text{est}}))$ 以评估数值条件。\n\n本问题不涉及物理单位。\n\n使用以下参数值测试套件，其中包括一个一般情况、一个近简并边界情况和一个多重漂移边缘情况。对于每种情况，首先确定性地（无噪声）合成 $y_{\\text{obs}} = P(\\pi_{\\text{true}})\\,x_{\\text{true}}$，然后使用 $\\pi_{\\text{est}}$ 计算 $x_{\\text{hat}}$，最后计算 $e$、敏感性界限和 $\\kappa_2(P(\\pi_{\\text{est}}))$。\n\n- 测试用例 1 (单漂移原子分布，中等 $N$):\n  - $N = 12$\n  - $m = 1$, $\\pi_{\\text{true}} = [0.989,\\,0.011]$ 且 $\\pi_{\\text{est}} = [0.988,\\,0.012]$\n  - $K = 6$\n  - $x_{\\text{true}} = [0.25,\\,0.20,\\,0.18,\\,0.15,\\,0.12,\\,0.07,\\,0.03]$\n\n- 测试用例 2 (近简并重概率，较大 $N$):\n  - $N = 30$\n  - $m = 1$, $\\pi_{\\text{true}} = [0.9995,\\,0.0005]$ 且 $\\pi_{\\text{est}} = [0.9985,\\,0.0015]$\n  - $K = 10$\n  - $x_{\\text{true}} = [0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.0]$\n\n- 测试用例 3 (每原子多重漂移，包含 $+2$ 質量漂移):\n  - $N = 6$\n  - $m = 2$, $\\pi_{\\text{true}} = [0.95,\\,0.03,\\,0.02]$ 且 $\\pi_{\\text{est}} = [0.952,\\,0.031,\\,0.017]$\n  - $K = 8$\n  - $x_{\\text{true}} = [0.15,\\,0.14,\\,0.13,\\,0.12,\\,0.11,\\,0.10,\\,0.09,\\,0.08,\\,0.08]$\n\n程序要求：\n\n- 通过 $\\pi$ 的显式 $N$ 重离散卷积构造 $P(\\pi)$ (不使用闭式二项式或多项式快捷公式)。\n- 使用非负最小二乘法计算 $x_{\\text{hat}}$，然后重新归一化使其和为 1。\n- 使用中心差分雅可比矩阵计算敏感性界限，该雅可比矩阵扰动 $\\pi$ 的一个分量并用第零个分量进行补偿（对于第零个分量，则用第一个分量补偿）以保持单纯形约束；使用一个足够小且能保持非负性的 $\\delta$。\n- 对于每个测试用例，按以下顺序输出一个包含三个实数的列表：误差 $e$、界限和 $\\kappa_2(P(\\pi_{\\text{est}}))$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个项目本身是用于一个测试用例的、由括号括起并用逗号分隔的三元组，不含空格。例如，输出应类似于\n  - \"[[e1,b1,k1],[e2,b2,k2],[e3,b3,k3]]\"\n其中每个符号都由该测试用例计算出的浮点值替换。", "solution": "该问题要求为基于质谱的代谢组学中的自然丰度校正构建并应用一个数值工作流程，其中包括对校正过程中潜在原子同位素分布不确定性的敏感性分析。解决方案将按照规定从基本原理出发进行开发。\n\n问题的核心在于代谢物的真实质量同位素体分布 (MID) $x_{\\text{true}}$ 与观测到的 MID $y_{\\text{obs}}$ 之间的关系。该关系被建模为一个线性系统 $y_{\\text{obs}} = P(\\pi) x_{\\text{true}}$。矩阵 $P(\\pi)$ 解释了分子非示踪剂部分中自然丰度同位素的混淆效应。\n\n由自然丰度产生的总质量漂移 $S$ 是 $N$ 个独立同分布的随机变量之和，每个变量代表单个原子的质量漂移。每个原子漂移的概率质量函数 (PMF) 由 $\\pi = [\\pi[0], \\pi[1], \\dots, \\pi[m]]$ 给出。根据概率公理，独立随机变量之和的 PMF 是它们各自 PMF 的离散卷积。\n\n设 $h^{(n)}$ 为 $n$ 个原子的总质量漂移的 PMF。我们有 $h^{(1)} = \\pi$。$n$ 个原子的 PMF 可通过将 $n-1$ 个原子的 PMF 与 $\\pi$ 进行卷积得到：\n$$\nh^{(n)}[k] = (h^{(n-1)} * \\pi)[k] = \\sum_{j=0}^{k} h^{(n-1)}[j] \\pi[k-j]\n$$\n为了找到 $N$ 个原子的总漂移 $S$ 的 PMF（表示为 $h$），我们将此卷积迭代执行 $N-1$ 次。然后必须将得到的向量 $h$ 截断至相关长度 $K+1$。\n\n**步骤 1：校正矩阵 $P(\\pi)$ 的构建**\n\n给定 $N$、$\\pi$ 和 $K$，我们首先计算代表总自然丰度质量漂移 $S$ 的 PMF 的向量 $h$，并将其截断至大小 $K+1$。\n1.  用原子 PMF $\\pi$ 初始化一个向量 `h_current`。\n2.  重复 $N-1$ 次：通过将 `h_current` 与 $\\pi$ 卷积来更新它。这将得到 $N$ 个原子漂移之和的 PMF。\n3.  通过取上一步结果的前 $K+1$ 个元素来获得最终向量 $h$。\n4.  然后构造大小为 $(K+1) \\times (K+1)$ 的矩阵 $P(\\pi)$。其元素由 $P(\\pi)[k,j] = h[k-j]$ (当 $k \\ge j$ 时) 和 0 (其他情况) 给出。这种结构反映了一个真实的质量同位素体 $j$ 只能对观测到的质量同位素体 $k \\ge j$ 有贡献，其质量差 $k-j$ 来自自然丰度。这会形成一个下三角托普利茨 (Toeplitz) 矩阵。\n\n**步骤 2：真实 MID $x_{\\text{true}}$ 的估计**\n\n给定一个观测到的 MID $y_{\\text{obs}}$ 和一个估计的原子 PMF $\\pi_{\\text{est}}$，我们旨在为真实 MID $x_{\\text{true}}$ 找到一个估计值 $x_{\\text{hat}}$。该问题被表述为求解线性系统的逆问题，但带有 $x$ 的元素必须为非负的约束。这导致了非负最小二乘 (NNLS) 问题：\n$$\n\\min_{x \\in \\mathbb{R}^{K+1}} \\|P(\\pi_{\\text{est}})\\,x - y_{\\text{obs}}\\|_2 \\quad \\text{subject to } x_j \\ge 0 \\text{ for all } j.\n$$\n这是一个标准的凸优化问题，可以使用已有的算法来解决。在解出非负向量（例如 $x_{\\text{nnls}}$）后，必须对其进行重新归一化，以确保它代表一个有效的概率分布，即其元素之和为 1。\n$$\nx_{\\text{hat}}[j] = \\frac{x_{\\text{nnls}}[j]}{\\sum_{i=0}^{K} x_{\\text{nnls}}[i]}\n$$\n为了数值稳定性，应该在分母上加上一个小的 epsilon ($\\epsilon > 0$)，尽管在此问题背景下，总和预计不会为零。\n\n**步骤 3：敏感性分析**\n\n这一步量化了估计的 MID $x_{\\text{hat}}$ 对估计的原子 PMF $\\pi_{\\text{est}}$ 中不确定性的敏感程度。我们被要求计算误差放大的一个上界。该界定义为 $\\|\\Delta \\pi\\|_{1} \\cdot \\max_{i} \\| J_{:,i} \\|_2$，其中 $J = \\partial x_{\\text{hat}} / \\partial \\pi$ 是雅可比矩阵，$\\Delta \\pi = \\pi_{\\text{est}} - \\pi_{\\text{true}}$。\n\n雅可比矩阵 $J$ 使用中心差分进行数值近似。一个关键细节是，对 $\\pi$ 的任何扰动都必须保持其元素总和为 1 的约束。规定的方案是扰动一个分量 $\\pi[i]$ 并对另一个分量施加补偿性扰动。\n对于每个 $i \\in \\{0, 1, \\dots, m\\}$：\n1.  定义一个大小为 $\\delta \\ll 1$ 的扰动。\n2.  创建两个扰动向量 $\\pi^{+}$ 和 $\\pi^{-}$：\n    -   如果 $i > 0$：$\\pi^{+}[i] = \\pi_{\\text{est}}[i] + \\delta$，$\\pi^{+}[0] = \\pi_{\\text{est}}[0] - \\delta$。以及 $\\pi^{-}[i] = \\pi_{\\text{est}}[i] - \\delta$，$\\pi^{-}[0] = \\pi_{\\text{est}}[0] + \\delta$。\n    -   如果 $i = 0$：$\\pi^{+}[0] = \\pi_{\\text{est}}[0] + \\delta$，$\\pi^{+}[1] = \\pi_{\\text{est}}[1] - \\delta$。以及 $\\pi^{-}[0] = \\pi_{\\text{est}}[0] - \\delta$，$\\pi^{-}[1] = \\pi_{\\text{est}}[1] + \\delta$。\n3.  对于每个扰动向量，重新计算整个校正流程：构建 $P(\\pi^{\\pm})$，求解 NNLS 问题得到 $x_{\\text{nnls}}(\\pi^{\\pm})$，然后重新归一化得到 $x_{\\text{hat}}(\\pi^{\\pm})$。\n4.  雅可比矩阵的第 $i$ 列随后近似为：\n    $$\n    J_{:,i} \\approx \\frac{x_{\\text{hat}}(\\pi^{+}) - x_{\\text{hat}}(\\pi^{-})}{2\\delta}\n    $$\n计算完 $J$ 的所有 $m+1$ 列后，我们找到它们欧几里得范数的最大值：$\\max_{i} \\| J_{:,i} \\|_2$。然后将此最大范数乘以 $\\pi$ 中误差的 $L_1$ 范数 $\\|\\pi_{\\text{est}} - \\pi_{\\text{true}}\\|_1$ 来计算敏感性界限。\n\n最后，计算实际估计误差 $e = \\|x_{\\text{hat}} - x_{\\text{true}}\\|_2$，以便与界限进行比较。\n\n**步骤 4：数值条件评估**\n\n求解线性系统的数值稳定性与矩阵 $P(\\pi_{\\text{est}})$ 的条件数有关。谱条件数 $\\kappa_2(P(\\pi_{\\text{est}}))$ 是矩阵最大奇异值与最小奇异值的比率。大的条件数表明矩阵接近奇异，并且 $y_{\\text{obs}}$ 或 $P(\\pi_{\\text{est}})$ 中的小误差可能会在解 $x_{\\text{hat}}$ 中被大大放大。这可以使用标准线性代数程序计算。\n\n这四个步骤提供了一个完整的框架，用于执行自然丰度校正、评估其数值条件并量化其对模型参数的敏感性。实现将针对每个提供的测试用例遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"N\": 12, \"m\": 1, \"K\": 6,\n            \"pi_true\": np.array([0.989, 0.011]),\n            \"pi_est\": np.array([0.988, 0.012]),\n            \"x_true\": np.array([0.25, 0.20, 0.18, 0.15, 0.12, 0.07, 0.03])\n        },\n        {\n            \"N\": 30, \"m\": 1, \"K\": 10,\n            \"pi_true\": np.array([0.9995, 0.0005]),\n            \"pi_est\": np.array([0.9985, 0.0015]),\n            \"x_true\": np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.0])\n        },\n        {\n            \"N\": 6, \"m\": 2, \"K\": 8,\n            \"pi_true\": np.array([0.95, 0.03, 0.02]),\n            \"pi_est\": np.array([0.952, 0.031, 0.017]),\n            \"x_true\": np.array([0.15, 0.14, 0.13, 0.12, 0.11, 0.10, 0.09, 0.08, 0.08])\n        }\n    ]\n\n    all_results = []\n\n    def construct_P(N, pi, K):\n        \"\"\"Constructs the correction matrix P from N, pi, and K.\"\"\"\n        # 1. N-fold convolution of pi\n        h_conv = pi.copy()\n        for _ in range(N - 1):\n            h_conv = np.convolve(h_conv, pi)\n        \n        # 2. Truncate to get h vector\n        h = np.zeros(K + 1)\n        len_h = min(len(h_conv), K + 1)\n        h[:len_h] = h_conv[:len_h]\n\n        # 3. Construct P matrix\n        P = np.zeros((K + 1, K + 1))\n        for j in range(K + 1):\n            for k in range(j, K + 1):\n                P[k, j] = h[k - j]\n        return P\n\n    def full_correction_pipeline(pi, y_obs, N, K):\n        \"\"\"Runs the full correction process for a given pi and y_obs.\"\"\"\n        P_est = construct_P(N, pi, K)\n        x_nnls, _ = nnls(P_est, y_obs)\n        # Renormalize\n        sum_x = np.sum(x_nnls)\n        if sum_x > 1e-9:\n             x_hat = x_nnls / sum_x\n        else: # Handle zero-sum case\n             x_hat = np.full(K + 1, 1.0 / (K + 1))\n        return x_hat\n\n    for case in test_cases:\n        N, m, K = case[\"N\"], case[\"m\"], case[\"K\"]\n        pi_true, pi_est, x_true_raw = case[\"pi_true\"], case[\"pi_est\"], case[\"x_true\"]\n        \n        # Ensure x_true is a probability vector\n        x_true = x_true_raw / np.sum(x_true_raw)\n\n        # Synthesize observed data\n        P_true = construct_P(N, pi_true, K)\n        y_obs = P_true @ x_true\n        \n        # Task 2: Compute x_hat\n        x_hat = full_correction_pipeline(pi_est, y_obs, N, K)\n        \n        # Task 3 (part 1): Estimation error\n        error_e = np.linalg.norm(x_hat - x_true, 2)\n        \n        # Task 4: Condition number\n        P_est_for_cond = construct_P(N, pi_est, K)\n        cond_num = np.linalg.cond(P_est_for_cond, 2)\n\n        # Task 3 (part 2): Sensitivity analysis\n        delta = 1e-7\n        jacobian_cols_norms = []\n        for i in range(m + 1):\n            pi_plus = pi_est.copy()\n            pi_minus = pi_est.copy()\n            \n            # Perturb pi while preserving the sum-to-1 simplex constraint\n            if i > 0:\n                comp_idx = 0\n            else: # i == 0\n                comp_idx = 1\n\n            pi_plus[i] += delta\n            pi_plus[comp_idx] -= delta\n            pi_minus[i] -= delta\n            pi_minus[comp_idx] += delta\n            \n            # Check for non-negativity after perturbation\n            if np.any(pi_plus  0) or np.any(pi_minus  0):\n                # This should not happen with a small delta on non-zero probabilities\n                # If it does, a smaller delta or different handling might be needed.\n                # For this problem, we assume delta is small enough.\n                pass\n\n            x_hat_plus = full_correction_pipeline(pi_plus, y_obs, N, K)\n            x_hat_minus = full_correction_pipeline(pi_minus, y_obs, N, K)\n            \n            jac_col = (x_hat_plus - x_hat_minus) / (2 * delta)\n            jacobian_cols_norms.append(np.linalg.norm(jac_col, 2))\n\n        max_jac_norm = np.max(jacobian_cols_norms) if jacobian_cols_norms else 0\n        delta_pi_norm_1 = np.linalg.norm(pi_est - pi_true, 1)\n        sensitivity_bound = delta_pi_norm_1 * max_jac_norm\n        \n        all_results.append(f\"[{error_e},{sensitivity_bound},{cond_num}]\")\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join(all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3311163"}, {"introduction": "代谢组学的一个核心目标是利用浓度数据来理解代谢网络的行为。要实现这一点，一个强有力的方法是确保我们的网络模型遵循基本的物理定律。本练习将展示如何将热力学第二定律——即反应的净通量方向必须与吉布斯自由能的负向变化（$\\Delta G \\lt 0$）相耦合——整合到通量平衡分析（FBA）的框架中。你将运用混合整数线性规划（MILP）这一强大工具，将这些关键的热力学约束施加于代谢模型之上，从而构建出更真实、更具预测能力的系统生物学模型。[@problem_id:3311190]", "problem": "考虑一个包含 $m$ 种代谢物和 $n$ 个反应的稳态代谢网络。设化学计量矩阵为 $S \\in \\mathbb{R}^{m \\times n}$，通量向量为 $v \\in \\mathbb{R}^{n}$，化学势向量为 $\\mu \\in \\mathbb{R}^{m}$。流平衡分析 (FBA) 施加了稳态质量平衡约束 $S_{\\text{int}} v = 0$，其中 $S_{\\text{int}}$ 是 $S$ 的一个子矩阵，仅包含对应于内部代谢物的行。反应 $i$ 的吉布斯自由能变化定义为 $\\Delta G_i = \\sum_{j=1}^{m} S_{j i} \\mu_j$。热力学一致性要求正向通量由负的吉布斯自由能变化驱动。我们使用混合整数约束和 Big-$M$ 松弛来强制执行逻辑蕴涵 $v_i > 0 \\Rightarrow \\Delta G_i  0$。具体来说，对于每个反应 $i$，我们引入一个二元指示变量 $y_i \\in \\{0,1\\}$，当 $y_i = 1$ 时，它允许非零正向通量，并强制执行 $\\Delta G_i \\leq -\\varepsilon$，其中 $\\varepsilon > 0$ 是一个小的严格性余量。约束条件如下：\n- $S_{\\text{int}} v = 0$，\n- 对于每个 $i$，$0 \\leq v_i \\leq y_i \\, v_{i}^{\\max}$，\n- 对于每个 $i$，$ \\sum_{j \\in \\mathcal{V}} S_{j i} \\mu_j \\leq -\\varepsilon + M_i (1 - y_i) - \\sum_{k \\in \\mathcal{F}} S_{k i} \\mu_k^{\\text{fixed}} $，\n- 对于 $j \\in \\mathcal{V}$，$\\mu_j^{\\min} \\leq \\mu_j \\leq \\mu_j^{\\max}$，\n- $\\sum_{i=1}^{n} v_i \\geq \\delta$，\n其中 $\\mathcal{V}$ 是具有可变势的代谢物的索引集，$\\mathcal{F}$ 是具有固定势的代谢物的索引集，$v_{i}^{\\max}$ 是通量上界，$\\mu_j^{\\min}$ 和 $\\mu_j^{\\max}$ 是化学势界限，$M_i$ 是根据界限确定的足够大的常数，$\\delta > 0$ 强制要求非平凡通量。热力学蕴涵得到满足，因为当 $y_i = 1$ 时，Big-$M$ 项消失，且 $\\Delta G_i \\leq -\\varepsilon$；当 $y_i = 0$ 时，正向通量被 $v_i \\leq 0$ 禁止，$\\Delta G_i$ 约束变为松弛。\n\n您的任务是编写一个程序，对于给定的网络规范和选定的二元模式 $y$，判断上述约束是否允许至少一个具有非平凡通量的可行解 $(v, \\mu)$。通过最小化一个零目标函数来将此决策问题表述为线性可行性问题，该目标函数受线性等式和不等式约束，并使用 Big-$M$ 松弛来处理逻辑蕴涵。使用基于所提供界限的确定性方法构建 $M_i$。除了所述定义外，不要假定任何热力学简化公式。\n\n测试套件和参数化：\n- 以下定义中的所有数字都是精确的，必须按字面意思处理。\n\n案例1（热力学不可行的循环）：\n- 代谢物：$A$、$B$、$C$（均为内部代谢物，均为可变势）。\n- 反应：$R_1: A \\rightarrow B$, $R_2: B \\rightarrow C$, $R_3: C \\rightarrow A$。\n- $$S = \\begin{bmatrix}\n-1  0  +1 \\\\\n+1  -1  0 \\\\\n0  +1  -1\n\\end{bmatrix} \\in \\mathbb{R}^{3 \\times 3}.$$\n- 内部代谢物索引：$\\{0, 1, 2\\}$。\n- 可变势索引：$\\{0, 1, 2\\}$。\n- 固定势：无（因此 $\\mathcal{F} = \\emptyset$）。\n- 通量上界：$v^{\\max} = [\\,10,\\,10,\\,10\\,]$。\n- 二元模式：$y = [\\,1,\\,1,\\,1\\,]$。\n- 化学势界限：对于每个内部代谢物，$\\mu^{\\min} = -100$，$\\mu^{\\max} = +100$。\n- 余量：$\\varepsilon = 10^{-4}$。\n- 非平凡通量阈值：$\\delta = 10^{-3}$。\n\n案例2（跨区室具有势降的可行链）：\n- 代谢物：内部代谢物 $A$、$B$（可变势），外部代谢物 $E_{\\text{in}}$、$E_{\\text{out}}$（固定势）。\n- 反应：$R_0: E_{\\text{in}} \\rightarrow A$, $R_1: A \\rightarrow B$, $R_2: B \\rightarrow E_{\\text{out}}$。\n- 代谢物排序为 $[A, B, E_{\\text{in}}, E_{\\text{out}}]$。\n- $$S = \\begin{bmatrix}\n+1  -1  0 \\\\\n0  +1  -1 \\\\\n-1  0  0 \\\\\n0  0  +1\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 3}.$$\n- 内部代谢物索引：$\\{0, 1\\}$。\n- 可变势索引：$\\{0, 1\\}$。\n- 固定势：$\\mu_{E_{\\text{in}}}^{\\text{fixed}} = 0$，$\\mu_{E_{\\text{out}}}^{\\text{fixed}} = -10$（索引 $\\{2,3\\}$）。\n- 通量上界：$v^{\\max} = [\\,5,\\,5,\\,5\\,]$。\n- 二元模式：$y = [\\,1,\\,1,\\,1\\,]$。\n- 化学势界限：对于每个内部代谢物，$\\mu^{\\min} = -100$，$\\mu^{\\max} = +100$。\n- 余量：$\\varepsilon = 10^{-4}$。\n- 非平凡通量阈值：$\\delta = 10^{-3}$。\n\n案例3（由于零上界导致的通量阻塞）：\n- 网络和代谢物索引与案例2相同。\n- 通量上界：$v^{\\max} = [\\,0,\\,0,\\,0\\,]$。\n- 二元模式：$y = [\\,1,\\,1,\\,1\\,]$。\n- 化学势界限：对于每个内部代谢物，$\\mu^{\\min} = -100$，$\\mu^{\\max} = +100$。\n- 固定势：$\\mu_{E_{\\text{in}}}^{\\text{fixed}} = 0$，$\\mu_{E_{\\text{out}}}^{\\text{fixed}} = -10$（索引 $\\{2,3\\}$）。\n- 余量：$\\varepsilon = 10^{-4}$。\n- 非平凡通量阈值：$\\delta = 10^{-3}$。\n\nBig-$M$ 构建：\n- 对于每个反应 $i$，设 $\\mathcal{V}$ 为可变代谢物索引集，并定义 $U_{\\mu} = \\max\\{\\,|\\mu^{\\min}|, |\\mu^{\\max}|\\,\\}$。计算\n$$M_i = \\left(\\sum_{j \\in \\mathcal{V}} |S_{j i}|\\right) U_{\\mu} + \\left| \\sum_{k \\in \\mathcal{F}} S_{k i} \\mu_k^{\\text{fixed}} \\right| + 1.$$\n这确保了当 $y_i = 0$ 时，关于 $\\Delta G_i$ 的不等式是非约束性的。\n\n您的程序必须为每个案例返回一个布尔值，指示在上述约束下的可行性（如果存在可行的 $(v,\\mu)$ 则为 true，否则为 false）。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\,\\text{True},\\text{False},\\text{True}\\,]$）。由于输出是布尔值，因此不需要进行物理单位转换；但是，内部常数和界限（例如 $\\varepsilon$, $\\delta$）必须完全按照规定使用。不涉及角度。不涉及百分比。", "solution": "该问题是有效的。它要求针对三个特定的测试案例，确定从代谢网络的热力学模型派生出的一组线性约束系统的可行性。该问题在科学上基于流平衡分析 (FBA) 和代谢热力学的原理，使用了诸如化学计量矩阵、吉布斯自由能和化学势等既定概念。这是一个适定问题，因为对于一个固定的二元向量 $y$，它可以归约为一个标准的线性规划 (LP) 可行性问题，该问题有明确的是/否答案。所有必要的参数、常数和数据集都已提供，术语精确且客观。没有矛盾、歧义或伪科学的实例。\n\n为了确定对于给定的二元模式 $y$ 是否存在可行解 $(v, \\mu)$，我们将问题表述为一个线性规划可行性任务。这是通过最小化一个零目标函数 $f(x) = 0$ 来实现的，该函数受所提供的一组线性约束的限制。当且仅当由约束定义的可行域非空时，才存在可行解。我们将使用标准的 LP 求解器来检查可行性。\n\n我们 LP 的决策变量是通量向量 $v \\in \\mathbb{R}^n$ 和可变化学势向量 $\\mu_{\\text{var}} \\in \\mathbb{R}^{m_{\\text{var}}}$，其中 $n$ 是反应数量，$m_{\\text{var}}$ 是具有可变势的代谢物数量。我们将这些连接成一个单一的变量向量 $x = [v_0, \\dots, v_{n-1}, \\mu_{\\text{var},0}, \\dots, \\mu_{\\text{var},m_{\\text{var}}-1}]^T$。\n\n这些约束被转换为标准的 LP 形式，即等式 $A_{\\text{eq}}x = b_{\\text{eq}}$、不等式 $A_{\\text{ub}}x \\leq b_{\\text{ub}}$ 和变量界限 $l \\leq x \\leq u$。\n\n1.  **稳态质量平衡**：约束 $S_{\\text{int}} v = 0$ 是一组线性等式。设 $S_{\\text{int}} \\in \\mathbb{R}^{m_{\\text{int}} \\times n}$。我们构建矩阵 $A_{\\text{eq}} = [S_{\\text{int}} | \\mathbf{0}]$，其中 $\\mathbf{0}$ 是一个大小为 $m_{\\text{int}} \\times m_{\\text{var}}$ 的零矩阵。等式右侧是 $b_{\\text{eq}} = \\mathbf{0}$。\n\n2.  **通量和势的界限**：约束 $0 \\leq v_i \\leq y_i \\, v_{i}^{\\max}$ 和 $\\mu_j^{\\min} \\leq \\mu_j \\leq \\mu_j^{\\max}$ 作为决策变量向量 $x$ 相应元素的下界和上界来处理。对于每个通量 $v_i$，界限是 $[0, y_i v_i^{\\max}]$。对于每个可变势 $\\mu_j$，界限是 $[\\mu_j^{\\min}, \\mu_j^{\\max}]$。\n\n3.  **热力学一致性**：每个反应 $i$ 的核心热力学约束是 $\\sum_{j=1}^{m} S_{j i} \\mu_j \\leq -\\varepsilon + M_i (1 - y_i)$。我们将代谢物的总和分为具有可变势（$\\mathcal{V}$）和固定势（$\\mathcal{F}$）的两部分：\n    $$ \\sum_{j \\in \\mathcal{V}} S_{j i} \\mu_j + \\sum_{k \\in \\mathcal{F}} S_{k i} \\mu_k^{\\text{fixed}} \\leq -\\varepsilon + M_i (1 - y_i) $$\n    重新整理得到关于可变势 $\\mu_{\\text{var}}$ 的线性不等式：\n    $$ \\sum_{j \\in \\mathcal{V}} S_{j i} \\mu_j \\leq -\\varepsilon + M_i (1 - y_i) - \\sum_{k \\in \\mathcal{F}} S_{k i} \\mu_k^{\\text{fixed}} $$\n    对于每个反应 $i=1, \\dots, n$，这构成了不等式矩阵 $A_{\\text{ub}}$ 和向量 $b_{\\text{ub}}$ 的一行。$v$ 变量的系数全为零。$\\mu_{\\text{var}}$ 变量的系数由化学计量 $S_{ji}$（其中 $j \\in \\mathcal{V}$）给出。Big-$M_i$ 常数按规定构建：\n    $$ M_i = \\left(\\sum_{j \\in \\mathcal{V}} |S_{j i}|\\right) U_{\\mu} + \\left| \\sum_{k \\in \\mathcal{F}} S_{k i} \\mu_k^{\\text{fixed}} \\right| + 1 $$\n    其中 $U_{\\mu} = \\max\\{|\\mu^{\\min}|, |\\mu^{\\max}|\\}$。这种构建方式确保了如果 $y_i=0$，该约束会变得松弛且无约束力，因为 $M_i$ 足够大，可以超过左侧的任何可能值。如果 $y_i=1$，则 $M_i$ 项消失，强制执行 $\\Delta G_i \\leq -\\varepsilon$。\n\n4.  **非平凡通量**：约束 $\\sum_{i=1}^{n} v_i \\geq \\delta$ 是一个线性不等式。我们将其重写为标准的“小于等于”形式，即 $-\\sum_{i=1}^{n} v_i \\leq -\\delta$。这为 $A_{\\text{ub}}$ 和 $b_{\\text{ub}}$ 增加了一行。$v$ 变量的系数全部为 $-1$，而 $\\mu$ 变量的系数全部为 $0$。\n\n然后由 LP 求解器确定该系统的可行性。如果求解器找到一个满足所有约束的点 $x$，则问题是可行的（True）。如果可行域为空，则是不可行的（False）。\n\n**测试案例分析：**\n- **案例1：** 这描述了一个循环路径 $A \\rightarrow B \\rightarrow C \\rightarrow A$。由于 $y=[1, 1, 1]$，约束条件为 $\\Delta G_1  0$、$\\Delta G_2  0$ 和 $\\Delta G_3  0$。该循环的总吉布斯自由能变化为 $\\Delta G_1 + \\Delta G_2 + \\Delta G_3 = (\\mu_B - \\mu_A) + (\\mu_C - \\mu_B) + (\\mu_A - \\mu_C) = 0$。然而，约束要求这个总和是严格为负的（$\\leq -3\\varepsilon$），这是一个矛盾。因此，该系统必须是不可行的。\n- **案例2：** 一个线性路径 $E_{\\text{in}} \\rightarrow A \\rightarrow B \\rightarrow E_{\\text{out}}$。质量平衡要求所有通量相等，$v_0=v_1=v_2$。非平凡通量约束 $\\sum v_i \\geq \\delta$ 可以通过正通量来满足。总反应是 $E_{\\text{in}} \\rightarrow E_{\\text{out}}$，其吉布斯能量变化为 $\\mu_{E_{\\text{out}}} - \\mu_{E_{\\text{in}}} = -10 - 0 = -10$。这个负势降可以驱动反应，并且可以找到满足所有局部热力学约束的中间势 $\\mu_A, \\mu_B$。该系统应该是可行的。\n- **案例3：** 这个案例与案例2相同，但 $v^{\\max}=[0, 0, 0]$。通量界限变为 $0 \\leq v_i \\leq 0$，迫使所有通量都为零。这与非平凡通量要求 $\\sum v_i \\geq \\delta > 0$ 直接矛盾。由于这个冲突，该系统是不可行的。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of metabolic network feasibility problems.\n    \"\"\"\n\n    # Case 1: Thermodynamically infeasible loop\n    S1 = np.array([\n        [-1., 0., 1.],\n        [1., -1., 0.],\n        [0., 1., -1.]\n    ])\n    case1 = {\n        'S': S1,\n        'internal_idx': [0, 1, 2],\n        'variable_idx': [0, 1, 2],\n        'fixed_idx': [],\n        'mu_fixed': {},\n        'v_max': np.array([10., 10., 10.]),\n        'y': np.array([1, 1, 1]),\n        'mu_min': -100.,\n        'mu_max': 100.,\n        'epsilon': 1e-4,\n        'delta': 1e-3\n    }\n\n    # Case 2: Feasible chain across compartments with a potential drop\n    S2 = np.array([\n        [1., -1., 0.],   # A\n        [0., 1., -1.],   # B\n        [-1., 0., 0.],   # E_in\n        [0., 0., 1.]     # E_out\n    ])\n    case2 = {\n        'S': S2,\n        'internal_idx': [0, 1],\n        'variable_idx': [0, 1],\n        'fixed_idx': [2, 3],\n        'mu_fixed': {2: 0., 3: -10.},\n        'v_max': np.array([5., 5., 5.]),\n        'y': np.array([1, 1, 1]),\n        'mu_min': -100.,\n        'mu_max': 100.,\n        'epsilon': 1e-4,\n        'delta': 1e-3\n    }\n\n    # Case 3: Blocked flux due to zero upper bounds\n    case3 = {\n        'S': S2,\n        'internal_idx': [0, 1],\n        'variable_idx': [0, 1],\n        'fixed_idx': [2, 3],\n        'mu_fixed': {2: 0., 3: -10.},\n        'v_max': np.array([0., 0., 0.]),\n        'y': np.array([1, 1, 1]),\n        'mu_min': -100.,\n        'mu_max': 100.,\n        'epsilon': 1e-4,\n        'delta': 1e-3\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case_params in test_cases:\n        S = case_params['S']\n        internal_idx = case_params['internal_idx']\n        variable_idx = case_params['variable_idx']\n        fixed_idx = case_params['fixed_idx']\n        mu_fixed = case_params['mu_fixed']\n        v_max = case_params['v_max']\n        y = case_params['y']\n        mu_min = case_params['mu_min']\n        mu_max = case_params['mu_max']\n        epsilon = case_params['epsilon']\n        delta = case_params['delta']\n\n        m, n = S.shape\n        m_int = len(internal_idx)\n        m_var = len(variable_idx)\n        num_vars = n + m_var\n\n        # Objective function (minimize 0 for a feasibility problem)\n        c = np.zeros(num_vars)\n\n        # Equality constraints: S_int * v = 0\n        if m_int > 0:\n            S_int = S[internal_idx, :]\n            A_eq = np.zeros((m_int, num_vars))\n            A_eq[:, :n] = S_int\n            b_eq = np.zeros(m_int)\n        else:\n            A_eq = None\n            b_eq = None\n\n        # Inequality constraints: A_ub * x = b_ub\n        # n for thermodynamics, 1 for nontrivial flux\n        num_ineq = n + 1\n        A_ub = np.zeros((num_ineq, num_vars))\n        b_ub = np.zeros(num_ineq)\n\n        # Big-M construction\n        U_mu = max(abs(mu_min), abs(mu_max))\n        M = np.zeros(n)\n        for i in range(n):\n            sum_s_var_abs = np.sum(np.abs(S[variable_idx, i])) if m_var > 0 else 0.\n            \n            sum_s_fix_mu = 0.\n            if len(fixed_idx) > 0:\n                for k, mu_val in mu_fixed.items():\n                    if k  S.shape[0]:\n                        sum_s_fix_mu += S[k, i] * mu_val\n            \n            M[i] = sum_s_var_abs * U_mu + abs(sum_s_fix_mu) + 1.0\n\n        # Thermodynamic constraints: Sum(S_ji * mu_j) = -eps + M_i*(1-y_i)\n        # -> Sum_{j in V} S_ji*mu_j = -eps + M_i*(1-y_i) - Sum_{k in F} S_ki*mu_k_fixed\n        if m_var > 0:\n            S_var = S[variable_idx, :]\n            A_ub[:n, n:] = S_var.T\n        \n        for i in range(n):\n            rhs_fixed_term = 0.\n            for k, mu_val in mu_fixed.items():\n                if k  S.shape[0]:\n                    rhs_fixed_term += S[k, i] * mu_val\n            \n            b_ub[i] = -epsilon + M[i] * (1 - y[i]) - rhs_fixed_term\n\n        # Nontrivial flux constraint: sum(v_i) >= delta => -sum(v_i) = -delta\n        A_ub[n, :n] = -1.0\n        b_ub[n] = -delta\n\n        # Bounds for variables v (fluxes) and mu (potentials)\n        bounds = []\n        # Flux bounds: 0 = v_i = y_i * v_max_i\n        for i in range(n):\n            bounds.append((0, y[i] * v_max[i]))\n        # Potential bounds: mu_min = mu_j = mu_max\n        for _ in range(m_var):\n            bounds.append((mu_min, mu_max))\n        \n        # Solve the LP feasibility problem\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        results.append(res.success)\n    \n    # Print the final result in the exact required format\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n```", "id": "3311190"}]}