{"hands_on_practices": [{"introduction": "中心法则的核心在于信息从mRNA到蛋白质的精确传递，但这个过程的可靠性如何？本练习使用基本的概率论来模拟翻译过程中错误的累积。通过推导合成一个完美蛋白质的概率，学生将对在长肽链上保持高保真度的巨大挑战获得定量的理解。[@problem_id:3355092]", "problem": "一个长度为 $L$ 个密码子的信使核糖核酸（mRNA）由核糖体翻译成多肽。假设一个简化的保真度模型，在该模型中，每个密码子发生翻译错误的概率为 $p$，且这些错误是相互独立的。一旦发生错误，任何错误事件都会导致最终生成的蛋白质失去功能。在这些假设下，分子生物学的中心法则启发了在密码子水平上对翻译过程的伯努利试验描述，这与信息从核酸序列流向蛋白质序列的过程相联系。\n\n从独立伯努利试验的第一性原理出发，并且不使用任何预先推导的封闭形式表达式，完成以下任务：\n\n- 推导整个蛋白质翻译过程无差错（即没有密码子发生错误）的概率 $P_0$ 的表达式。\n\n- 使用自然对数 $\\ln(\\cdot)$ 的定义和在 $|p|<1$ 的小 $p$ 值下有效的级数展开，推导 $\\ln P_0$ 关于 $L$ 和 $p$ 的三阶截断（保留到 $p^3$ 阶项）。\n\n说明您使用的任何收敛条件。您的最终答案必须包含两个表达式：精确的 $P_0$ 和 $\\ln P_0$ 的三阶截断。不需要进行数值计算，也不需要单位。最终表达式中不要包含任何余项符号；只包含保留到 $p^3$ 阶（包括 $p^3$ 阶）的项。", "solution": "在尝试求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取已知条件\n- 一个信使核糖核酸（mRNA）的长度为 $L$ 个密码子。\n- 翻译过程被建模为一系列独立的伯努利试验，每个密码子对应一次试验。\n- 任何单个密码子发生翻译错误的概率为 $p$。\n- 任何一个错误都会导致生成的蛋白质失去功能。\n- 第一个任务是推导 $P_0$ 的表达式，即整个 mRNA 无差错翻译的概率。\n- 第二个任务是使用在 $|p|<1$ 的小 $p$ 值下的级数展开，推导 $\\ln P_0$ 关于 $L$ 和 $p$ 的三阶截断。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于分子生物学的中心法则，并使用了一个标准（尽管简化）的概率模型来描述翻译保真度。使用伯努利试验来模拟独立的错误事件是计算系统生物学中一种常用且有效的方法。\n- **问题定义明确：** 这是一个定义明确的问题。它提供了推导所需量所需的所有必要参数（$L$，$p$）和假设（独立性）。目标清晰，并能导出唯一的数学表达式。\n- **客观性：** 语言正式、精确，没有主观或含糊的术语。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**，因为它具有科学依据、定义明确且客观。它不包含任何逻辑不一致、事实错误或含糊之处。将根据指定的任务推导解答。\n\n### 解答推导\n\n该问题要求基于蛋白质翻译的概率模型进行两次推导。\n\n**第一部分：无差错翻译概率 $P_0$ 的推导**\n\n长度为 $L$ 个密码子的 mRNA 翻译过程被建模为 $L$ 次独立的伯努利试验。对于每次试验（即每个密码子），有两种可能的结果：\n1.  **成功：** 密码子被正确翻译。\n2.  **失败：** 密码子翻译过程中发生错误。\n\n任何给定密码子发生错误（失败）的概率为 $p$。因此，任何给定密码子被正确翻译（成功）的概率是其补集，即 $1-p$。\n\n设 $S_i$ 为第 $i$ 个密码子被正确翻译的事件，其中 $i \\in \\{1, 2, \\dots, L\\}$。该事件的概率为：\n$$P(S_i) = 1-p$$\n\n整个蛋白质无差错翻译的事件对应于所有 $L$ 个密码子都被正确翻译。这是事件 $S_1, S_2, \\dots, S_L$ 的交集。这个复合事件的概率记为 $P_0$。\n$$P_0 = P(S_1 \\cap S_2 \\cap \\dots \\cap S_L)$$\n\n问题陈述指出，每个密码子上的错误事件是独立的。因此，成功事件 $S_i$ 也是独立的。对于一组独立事件，它们交集的概率是它们各自概率的乘积。\n$$P_0 = P(S_1) \\times P(S_2) \\times \\dots \\times P(S_L)$$\n\n将每个 $L$ 项的概率 $P(S_i) = 1-p$ 代入乘积中，我们得到：\n$$P_0 = \\underbrace{(1-p) \\times (1-p) \\times \\dots \\times (1-p)}_{L \\text{ times}}$$\n\n这可以简化为：\n$$P_0 = (1-p)^L$$\n该表达式表示在每个密码子错误概率为 $p$ 的情况下，一个长度为 $L$ 个密码子的蛋白质在合成过程中没有任何错误的概率。\n\n**第二部分：$\\ln P_0$ 的三阶截断推导**\n\n我们从上面推导出的 $P_0$ 表达式开始，并取其自然对数：\n$$\\ln P_0 = \\ln((1-p)^L)$$\n\n使用对数性质 $\\ln(a^b) = b \\ln(a)$，我们可以将指数 $L$ 提到前面：\n$$\\ln P_0 = L \\ln(1-p)$$\n\n问题要求对小 $p$（具体为 $|p|<1$）进行级数展开。自然对数函数 $\\ln(1+x)$ 的麦克劳林级数为：\n$$\\ln(1+x) = \\sum_{n=1}^{\\infty} (-1)^{n-1} \\frac{x^n}{n} = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\frac{x^4}{4} + \\dots$$\n该级数在 $-1 < x \\le 1$ 时收敛。\n\n为了找到 $\\ln(1-p)$ 的级数，我们将 $x = -p$ 代入展开式中。关于 $p$ 的条件 $|p|<1$ 确保了 $x=-p$ 在收敛区间 $(-1, 1)$ 内。\n$$\\ln(1-p) = (-p) - \\frac{(-p)^2}{2} + \\frac{(-p)^3}{3} - \\frac{(-p)^4}{4} + \\dots$$\n简化各项可得：\n$$\\ln(1-p) = -p - \\frac{p^2}{2} - \\frac{p^3}{3} - \\frac{p^4}{4} - \\dots$$\n或者，用求和符号表示：\n$$\\ln(1-p) = -\\sum_{n=1}^{\\infty} \\frac{p^n}{n}$$\n\n问题要求进行三阶截断，这意味着我们保留所有项，直到并包括含有 $p^3$ 的项。\n$$\\ln(1-p) \\approx -p - \\frac{p^2}{2} - \\frac{p^3}{3}$$\n\n最后，我们将这个截断后的级数代回到我们关于 $\\ln P_0$ 的表达式中：\n$$\\ln P_0 = L \\ln(1-p) \\approx L \\left( -p - \\frac{p^2}{2} - \\frac{p^3}{3} \\right)$$\n将因子 $L$ 分配进去，得到 $\\ln P_0$ 的三阶近似的最终表达式：\n$$\\ln P_0 \\approx -Lp - \\frac{Lp^2}{2} - \\frac{Lp^3}{3}$$\n该近似对于错误概率 $p$ 的小值是有效的。\n\n两个所要求的表达式已按要求从第一性原理推导得出。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-p)^L  -Lp - \\frac{Lp^2}{2} - \\frac{Lp^3}{3}\n\\end{pmatrix}\n}\n$$", "id": "3355092"}, {"introduction": "除了精确性，蛋白质的合成速度对细胞功能也至关重要。本练习探讨了翻译速度如何受到资源（特别是tRNA分子）可用性的影响。通过将延伸过程建模为一个随机过程，学生将计算翻译mRNA序列的期望时间，并亲身体验同义密码子替换——合成生物学中的一项关键技术——如何被用来优化蛋白质的生产速率。[@problem_id:3355123]", "problem": "考虑一个分子生物学中心法则框架内核糖体驱动翻译延伸的最小随机模型，其中核糖体利用同源转运核糖核酸 (tRNA) 一次解码一个信使核糖核酸 (mRNA) 上的密码子。假设每个密码子特异性的延伸步骤都是无记忆的（等待时间呈指数分布），其速率依赖于密码子。设密码子 $c$ 的瞬时延伸速率表示为 $k_{e}(c)$，满足 $k_{e}(c) = k_{0}\\, a_{c}$，其中 $a_{c}$ 是密码子 $c$ 的同源 tRNA 的相对丰度，而 $k_{0}$ 是一个与核糖体和条件相关的比例常数。可以假设连续的延伸步骤是相互独立的，并且在翻译的时间尺度上 $a_{c}$ 是平稳的。\n\n从这些建模假设以及关于指数等待时间过程和期望线性性的基本事实出发，推导出一个密码子序列为 $\\{c_{j}\\}_{j=1}^{n}$ 的 mRNA 的期望总延伸时间的解析表达式。然后，针对以下场景对此表达式进行数值计算。\n\n设 $n = 12$，原始密码子序列为\n$\\{\\text{AAA}, \\text{GCT}, \\text{CTT}, \\text{GAA}, \\text{TTT}, \\text{ATA}, \\text{CGT}, \\text{TCT}, \\text{GGT}, \\text{CAA}, \\text{TTA}, \\text{GCA}\\}$。\n一组同义替换产生了优化后的序列\n$\\{\\text{AAG}, \\text{GCC}, \\text{CTG}, \\text{GAG}, \\text{TTC}, \\text{ATT}, \\text{CGC}, \\text{TCC}, \\text{GGC}, \\text{CAG}, \\text{CTG}, \\text{GCC}\\}$。\n使用 $k_{0} = 20$，单位为 $\\text{s}^{-1}$。\n\n密码子特异性的 tRNA 相对丰度 $a_{c}$（无量纲）如下所示：\n- $\\text{AAA}: 0.65$, $\\text{AAG}: 0.95$\n- $\\text{GCT}: 0.50$, $\\text{GCC}: 0.90$, $\\text{GCA}: 0.70$\n- $\\text{CTT}: 0.40$, $\\text{CTG}: 1.10$\n- $\\text{GAA}: 0.60$, $\\text{GAG}: 0.85$\n- $\\text{TTT}: 0.45$, $\\text{TTC}: 0.80$\n- $\\text{ATA}: 0.30$, $\\text{ATT}: 0.75$\n- $\\text{CGT}: 0.35$, $\\text{CGC}: 0.88$\n- $\\text{TCT}: 0.55$, $\\text{TCC}: 0.92$\n- $\\text{GGT}: 0.50$, $\\text{GGC}: 1.00$\n- $\\text{CAA}: 0.48$, $\\text{CAG}: 0.89$\n- $\\text{TTA}: 0.42$\n\n计算替换前的期望总延伸时间 $T_{\\text{before}}$ 和替换后的期望总延伸时间 $T_{\\text{after}}$，并以 $\\text{s}$ 为单位报告其变化量 $\\Delta T = T_{\\text{after}} - T_{\\text{before}}$。将最终报告的 $\\Delta T$ 值四舍五入到四位有效数字。以 $\\text{s}$ 为单位表示答案。", "solution": "我们从中心法则的工作流程开始，其中核糖体通过使用同源 tRNA 解码密码子，将 mRNA 翻译成多肽。在所述假设下，每个密码子特异性的延伸步骤都有一个无记忆的等待时间，该等待时间被建模为一个指数随机变量。对于密码子 $c$，等待时间 $X_{c}$ 的速率为 $k_{e}(c)$，因此 $X_{c} \\sim \\text{Exp}(k_{e}(c))$。一个经过充分检验的事实是，对于速率为 $k$ 的指数随机变量，其期望值为 $\\mathbb{E}[X] = \\frac{1}{k}$。另一个基本性质是期望的线性性，它不要求独立性：对于随机变量 $X_{1},\\dots,X_{n}$，$\\mathbb{E}\\left[\\sum_{j=1}^{n} X_{j}\\right] = \\sum_{j=1}^{n} \\mathbb{E}[X_{j}]$。此处的独立性支持了建模假设，但对于期望求和并非必需。\n\n设 mRNA 密码子序列为 $\\{c_{j}\\}_{j=1}^{n}$。总延伸时间 $T$ 是各密码子特异性解码时间之和，即 $T = \\sum_{j=1}^{n} X_{c_{j}}$。使用 $\\mathbb{E}[X_{c_{j}}] = \\frac{1}{k_{e}(c_{j})}$，我们得到\n$$\n\\mathbb{E}[T] \\;=\\; \\sum_{j=1}^{n} \\frac{1}{k_{e}(c_{j})}.\n$$\n根据模型，$k_{e}(c) = k_{0}\\, a_{c}$，其中 $a_{c}$ 是密码子同源 tRNA 的相对丰度，$k_{0}$ 则反映了与核糖体和条件相关的比例关系。代入后得到解析表达式\n$$\n\\mathbb{E}[T] \\;=\\; \\sum_{j=1}^{n} \\frac{1}{k_{0}\\, a_{c_{j}}}\n\\;=\\; \\frac{1}{k_{0}} \\sum_{j=1}^{n} \\frac{1}{a_{c_{j}}}.\n$$\n\n现在我们对指定的序列进行计算，其中 $n = 12$ 且 $k_{0} = 20$，单位为 $\\text{s}^{-1}$。\n\n对于原始序列 $\\{\\text{AAA}, \\text{GCT}, \\text{CTT}, \\text{GAA}, \\text{TTT}, \\text{ATA}, \\text{CGT}, \\text{TCT}, \\text{GGT}, \\text{CAA}, \\text{TTA}, \\text{GCA}\\}$，我们计算\n$$\nT_{\\text{before}} \\;=\\; \\frac{1}{20} \\left(\n\\frac{1}{0.65} + \\frac{1}{0.50} + \\frac{1}{0.40} + \\frac{1}{0.60} + \\frac{1}{0.45} + \\frac{1}{0.30} + \\frac{1}{0.35} + \\frac{1}{0.55} + \\frac{1}{0.50} + \\frac{1}{0.48} + \\frac{1}{0.42} + \\frac{1}{0.70}\n\\right).\n$$\n计算倒数：\n- $\\frac{1}{0.65} = 1.53846153846$,\n- $\\frac{1}{0.50} = 2$,\n- $\\frac{1}{0.40} = 2.5$,\n- $\\frac{1}{0.60} = 1.66666666667$,\n- $\\frac{1}{0.45} = 2.22222222222$,\n- $\\frac{1}{0.30} = 3.33333333333$,\n- $\\frac{1}{0.35} = 2.85714285714$,\n- $\\frac{1}{0.55} = 1.81818181818$,\n- $\\frac{1}{0.50} = 2$,\n- $\\frac{1}{0.48} = 2.08333333333$,\n- $\\frac{1}{0.42} = 2.38095238095$,\n- $\\frac{1}{0.70} = 1.42857142857$.\n将这些值相加得到\n$$\n\\sum_{j=1}^{12} \\frac{1}{a_{c_{j}}} \\;=\\; 25.82886557885,\n$$\n所以\n$$\nT_{\\text{before}} \\;=\\; \\frac{25.82886557885}{20} \\;=\\; 1.2914432789425.\n$$\n\n对于优化后的序列 $\\{\\text{AAG}, \\text{GCC}, \\text{CTG}, \\text{GAG}, \\text{TTC}, \\text{ATT}, \\text{CGC}, \\text{TCC}, \\text{GGC}, \\text{CAG}, \\text{CTG}, \\text{GCC}\\}$，我们计算\n$$\nT_{\\text{after}} \\;=\\; \\frac{1}{20} \\left(\n\\frac{1}{0.95} + \\frac{1}{0.90} + \\frac{1}{1.10} + \\frac{1}{0.85} + \\frac{1}{0.80} + \\frac{1}{0.75} + \\frac{1}{0.88} + \\frac{1}{0.92} + \\frac{1}{1.00} + \\frac{1}{0.89} + \\frac{1}{1.10} + \\frac{1}{0.90}\n\\right).\n$$\n计算倒数：\n- $\\frac{1}{0.95} = 1.05263157895$,\n- $\\frac{1}{0.90} = 1.11111111111$,\n- $\\frac{1}{1.10} = 0.909090909091$,\n- $\\frac{1}{0.85} = 1.17647058824$,\n- $\\frac{1}{0.80} = 1.25$,\n- $\\frac{1}{0.75} = 1.33333333333$,\n- $\\frac{1}{0.88} = 1.13636363636$,\n- $\\frac{1}{0.92} = 1.08695652174$,\n- $\\frac{1}{1.00} = 1$,\n- $\\frac{1}{0.89} = 1.12359550562$,\n- $\\frac{1}{1.10} = 0.909090909091$,\n- $\\frac{1}{0.90} = 1.11111111111$.\n将这些值相加得到\n$$\n\\sum_{j=1}^{12} \\frac{1}{a_{c_{j}}} \\;=\\; 13.19975520464,\n$$\n所以\n$$\nT_{\\text{after}} \\;=\\; \\frac{13.19975520464}{20} \\;=\\; 0.6599877602320.\n$$\n\n期望总延伸时间的变化量为\n$$\n\\Delta T \\;=\\; T_{\\text{after}} - T_{\\text{before}} \\;=\\; 0.6599877602320 \\,-\\, 1.2914432789425 \\;=\\; -0.6314555187105.\n$$\n四舍五入到四位有效数字，$\\Delta T = -0.6315$ $\\text{s}$。", "answer": "$$\\boxed{-0.6315}$$", "id": "3355123"}, {"introduction": "中心法则并非一系列孤立的事件，而是一个紧密整合的系统。最后的这个练习运用排队论，将从启动子激活到转录和翻译的整个基因表达途径，建模为一个串联的生产线。学生将通过一个计算模型来计算每个阶段的“利用率”，识别限制整体蛋白质产出的瓶颈，并评估整个系统的稳定性，从而获得一个整体的、系统层面的视角。[@problem_id:3355173]", "problem": "考虑一个分子生物学中心法则的三阶段抽象模型，该模型在计算系统生物学中被构建为一个串联队列。这些阶段是：(i) 控制转录起始的DNA启动子切换，(ii) 核糖核酸聚合酶合成信使核糖核酸（mRNA），以及 (iii) 由核糖体进行的蛋白质合成，该过程通过完全不对称简单排除过程（TASEP）进行建模。目标是通过计算队列利用率来识别瓶颈，并在稳态条件下评估串联系统的稳定性。您的程序必须为每个提供的测试用例计算三个阶段的利用率，确定瓶颈站点和稳定性标志，然后按规定汇总结果。\n\n使用以下具有科学依据的基本假设和定义：\n\n- 中心法则指出，脱氧核糖核酸（DNA）被转录为信使核糖核酸（mRNA），后者再被翻译成蛋白质。\n- 启动子以速率 $k_\\mathrm{on}$ 和 $k_\\mathrm{off}$（单位 $\\mathrm{s}^{-1}$）在 $ON$ 和 $OFF$ 状态之间切换。对于一个两状态连续时间马尔可夫过程，在稳态下，处于 $ON$ 状态的时间比例为 $P_\\mathrm{ON} = \\dfrac{k_\\mathrm{on}}{k_\\mathrm{on} + k_\\mathrm{off}}$。\n- 当启动子处于 $ON$ 状态时，转录起始事件以最大速率 $r_\\mathrm{tx}$（单位 $\\mathrm{s}^{-1}$）作为泊松过程发生，从而产生平均转录起始速率 $\\lambda_m = P_\\mathrm{ON}\\, r_\\mathrm{tx}$（单位 $\\mathrm{s}^{-1}$）。\n- 转录延伸和终止被建模为一个单服务台队列，其服务速率为每个转录本完成 $\\mu_m$（单位 $\\mathrm{s}^{-1}$）。阶段2的利用率为 $\\rho_2 = \\lambda_m / \\mu_m$。\n- 核糖体翻译在低起始密度下通过完全不对称简单排除过程（TASEP）进行近似。其中，每个密码子的平均跳跃速率为 $p$（单位 $\\mathrm{codons}\\,\\mathrm{s}^{-1}$），多肽链长度为 $L$（单位 $\\mathrm{codons}$）。在低密度机制下，在一个mRNA上完成一个蛋白质的有效服务速率近似为 $\\mu_p = p / L$（单位 $\\mathrm{s}^{-1}$），从而得出阶段3的利用率 $\\rho_3 = \\lambda_m / \\mu_p$。\n- 为保证诊断的完整性，将启动子门视为阶段1的资源，其利用率代理为 $\\rho_1 = P_\\mathrm{ON}$。\n- 将瓶颈定义为利用率 $\\rho_i$ 最大的站点索引 $i \\in \\{1,2,3\\}$；如果出现平局，则选择最小的索引。\n- 当且仅当 $\\rho_2  1$ 且 $\\rho_3  1$ 时，定义串联系统为稳定。注意，根据定义 $\\rho_1 \\le 1$，它不会导致不稳定性。\n\n您的任务是实现一个程序，为每个测试用例计算列表 $[\\rho_1, \\rho_2, \\rho_3, i_\\mathrm{bottleneck}, \\mathrm{stable}]$，其中 $\\rho_1$、$\\rho_2$ 和 $\\rho_3$ 是浮点数，$i_\\mathrm{bottleneck}$ 是 $\\{1,2,3\\}$ 中的一个整数，$\\mathrm{stable}$ 是一个布尔值。不涉及物理角度。速率单位必须一致处理：$k_\\mathrm{on}$、$k_\\mathrm{off}$、$r_\\mathrm{tx}$ 和 $\\mu_m$ 的单位为 $\\mathrm{s}^{-1}$，$p$ 的单位为 $\\mathrm{codons}\\,\\mathrm{s}^{-1}$，$L$ 的单位为 $\\mathrm{codons}$。\n\n使用以下参数集测试套件，以确保覆盖典型和边缘情况下的行为：\n\n- 测试用例1（均衡利用率）：$k_\\mathrm{on} = 0.05\\,\\mathrm{s}^{-1}$，$k_\\mathrm{off} = 0.10\\,\\mathrm{s}^{-1}$，$r_\\mathrm{tx} = 0.10\\,\\mathrm{s}^{-1}$，$\\mu_m = 0.05\\,\\mathrm{s}^{-1}$，$p = 15\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$，$L = 300\\,\\mathrm{codons}$。\n- 测试用例2（翻译受限）：$k_\\mathrm{on} = 0.05\\,\\mathrm{s}^{-1}$，$k_\\mathrm{off} = 0.10\\,\\mathrm{s}^{-1}$，$r_\\mathrm{tx} = 0.10\\,\\mathrm{s}^{-1}$，$\\mu_m = 0.05\\,\\mathrm{s}^{-1}$，$p = 5\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$，$L = 300\\,\\mathrm{codons}$。\n- 测试用例3（转录受限）：$k_\\mathrm{on} = 0.05\\,\\mathrm{s}^{-1}$，$k_\\mathrm{off} = 0.10\\,\\mathrm{s}^{-1}$，$r_\\mathrm{tx} = 0.10\\,\\mathrm{s}^{-1}$，$\\mu_m = 0.02\\,\\mathrm{s}^{-1}$，$p = 15\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$，$L = 300\\,\\mathrm{codons}$。\n- 测试用例4（几乎总是$ON$，高吞吐量需求）：$k_\\mathrm{on} = 10\\,\\mathrm{s}^{-1}$，$k_\\mathrm{off} = 0.01\\,\\mathrm{s}^{-1}$，$r_\\mathrm{tx} = 1\\,\\mathrm{s}^{-1}$，$\\mu_m = 0.10\\,\\mathrm{s}^{-1}$，$p = 50\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$，$L = 100\\,\\mathrm{codons}$。\n- 测试用例5（$\\rho_3 = 1$ 时的边界条件）：$k_\\mathrm{on} = 0.20\\,\\mathrm{s}^{-1}$，$k_\\mathrm{off} = 0.20\\,\\mathrm{s}^{-1}$，$r_\\mathrm{tx} = 0.05\\,\\mathrm{s}^{-1}$，$\\mu_m = 0.10\\,\\mathrm{s}^{-1}$，$p = 10\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$，$L = 400\\,\\mathrm{codons}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，输出列表 $[\\rho_1, \\rho_2, \\rho_3, i_\\mathrm{bottleneck}, \\mathrm{stable}]$，并将所有五个测试用例的结果汇总到一个列表中，例如 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$，以单行形式，使用逗号分隔符和方括号。", "solution": "用户提供的问题已经过验证，被认为是具有科学依据、定义明确且自洽的。该模型是计算系统生物学中一个公认的简化模型，它利用马尔可夫过程和排队论的原理来抽象中心法则。所有参数、定义和约束都已明确指定，构成了一个可解的计算问题。\n\n解决方案基于所提供的定义，为每个测试用例系统地计算所需的指标。该过程涉及对代表基因表达的三阶段串联队列进行逐步评估。\n\n**第1步：阶段1利用率（启动子门控）**\n\n第一阶段模拟基因启动子在 $ON$ 和 $OFF$ 状态之间的随机切换。这被描述为一个两状态连续时间马尔可夫过程，其转移速率分别为 $k_\\mathrm{on}$（用于 $OFF \\rightarrow ON$）和 $k_\\mathrm{off}$（用于 $ON \\rightarrow OFF$），单位均为 $\\mathrm{s}^{-1}$。\n\n在稳态下，启动子处于 $ON$ 状态的时间比例 $P_\\mathrm{ON}$ 由以下公式给出：\n$$P_\\mathrm{ON} = \\frac{k_\\mathrm{on}}{k_\\mathrm{on} + k_\\mathrm{off}}$$\n这个量是无量纲的。根据问题定义，该概率作为启动子资源的利用率代理，记为 $\\rho_1$。\n$$\\rho_1 = P_\\mathrm{ON}$$\n\n**第2步：阶段2利用率（mRNA合成）**\n\n第二阶段模拟DNA转录为信使RNA（mRNA）的过程。转录起始是一个泊松过程，只有当启动子处于 $ON$ 状态时才能发生。最大起始速率为 $r_\\mathrm{tx}$（单位为 $\\mathrm{s}^{-1}$）。因此，平均转录起始速率 $\\lambda_m$ 是最大速率乘以启动子处于活动状态的概率：\n$$\\lambda_m = P_\\mathrm{ON} \\cdot r_\\mathrm{tx}$$\n$\\lambda_m$ 的单位是 $\\mathrm{s}^{-1}$。\n\n随后的mRNA延伸和终止过程被建模为一个单服务台队列，服务速率为 $\\mu_m$（单位为 $\\mathrm{s}^{-1}$），表示完成一个mRNA转录本的速率。转录机制的利用率 $\\rho_2$ 是起始事件的到达速率（$\\lambda_m$）与转录本完成的服务速率（$\\mu_m$）之比，这是排队论中的一个标准结果。\n$$\\rho_2 = \\frac{\\lambda_m}{\\mu_m}$$\n该利用率是一个无量纲的量。\n\n**第3步：阶段3利用率（蛋白质合成）**\n\n第三阶段模拟核糖体将mRNA翻译成蛋白质的过程。此过程通过完全不对称简单排除过程（TASEP）进行近似。在指定的低密度机制下，可以计算出完成一条多肽链的有效服务速率 $\\mu_p$。它取决于核糖体沿mRNA的平均跳跃速率 $p$（单位为 $\\mathrm{codons}\\,\\mathrm{s}^{-1}$）和待合成多肽的长度 $L$（单位为 $\\mathrm{codons}$）。遍历mRNA的时间约为 $L/p$，因此完成速率是其倒数：\n$$\\mu_p = \\frac{p}{L}$$\n$\\mu_p$ 的单位是 $\\mathrm{s}^{-1}$。\n\n到达此阶段的任务（即新的翻译）的到达速率被假定为转录阶段的稳态输出速率，该速率等于转录起始速率 $\\lambda_m$。因此，翻译机制的利用率 $\\rho_3$ 是到达速率 $\\lambda_m$ 与蛋白质合成服务速率 $\\mu_p$ 之比：\n$$\\rho_3 = \\frac{\\lambda_m}{\\mu_p}$$\n该利用率也是无量纲的。\n\n**第4步：瓶颈识别**\n\n三阶段系统的瓶颈被定义为利用率最高的站点。利用率集合为 $\\{\\rho_1, \\rho_2, \\rho_3\\}$。瓶颈站点索引 $i_\\mathrm{bottleneck}$ 是使 $\\rho_i$ 最大化的索引 $i \\in \\{1, 2, 3\\}$。\n$$i_\\mathrm{bottleneck} = \\underset{i \\in \\{1, 2, 3\\}}{\\mathrm{argmax}} \\{\\rho_i\\}$$\n如果利用率值出现平局，问题规定应选择最小的站点索引。例如，如果 $\\rho_2 = \\rho_3$ 且该值是最大值，则瓶颈为站点2。\n\n**第5步：系统稳定性分析**\n\n串联排队系统的稳定性由处理阶段（阶段2和3）的利用率决定。根据排队论，如果一个队列的利用率严格小于1，则该队列是稳定的。如果利用率大于或等于1，队列长度将无限增长，导致不稳定。问题定义，当且仅当阶段2和阶段3的利用率都低于此阈值时，系统是稳定的。\n$$\\mathrm{stable} = (\\rho_2  1) \\land (\\rho_3  1)$$\n阶段1的利用率 $\\rho_1 = P_\\mathrm{ON}$ 是一个概率，因此其值界于0和1之间（$0 \\le \\rho_1 \\le 1$）。它不代表一个可以无限增长的队列，因此被正确地排除在稳定性条件之外。\n\n**计算实现**\n\n实现了一个程序来为五个提供的测试用例中的每一个执行这些计算。对于每个用例，它计算五元列表 $[\\rho_1, \\rho_2, \\rho_3, i_\\mathrm{bottleneck}, \\mathrm{stable}]$，并将这些列表汇总成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes utilizations, bottleneck, and stability for a three-stage model of gene expression.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (k_on, k_off, r_tx, mu_m, p, L)\n    test_cases = [\n        # Test case 1 (balanced utilization)\n        (0.05, 0.10, 0.10, 0.05, 15, 300),\n        # Test case 2 (translation-limited)\n        (0.05, 0.10, 0.10, 0.05, 5, 300),\n        # Test case 3 (transcription-limited)\n        (0.05, 0.10, 0.10, 0.02, 15, 300),\n        # Test case 4 (nearly always ON, high throughput demand)\n        (10.0, 0.01, 1.0, 0.10, 50, 100),\n        # Test case 5 (boundary condition at rho_3 = 1)\n        (0.20, 0.20, 0.05, 0.10, 10, 400),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        k_on, k_off, r_tx, mu_m, p, L = case\n\n        # Step 1: Stage-1 Utilization (Promoter Gating)\n        # P_ON is the fraction of time the promoter is in the ON state.\n        # This is also the proxy for stage-1 utilization, rho_1.\n        p_on = k_on / (k_on + k_off)\n        rho_1 = p_on\n\n        # Step 2: Stage-2 Utilization (mRNA Synthesis)\n        # lambda_m is the average transcription initiation rate.\n        lambda_m = p_on * r_tx\n        # rho_2 is the utilization of the transcription machinery.\n        rho_2 = lambda_m / mu_m\n\n        # Step 3: Stage-3 Utilization (Protein Synthesis)\n        # mu_p is the effective service rate for protein completion.\n        mu_p = p / L\n        # rho_3 is the utilization of the translation machinery.\n        rho_3 = lambda_m / mu_p\n\n        utilizations = np.array([rho_1, rho_2, rho_3])\n\n        # Step 4: Bottleneck Identification\n        # Find the index of the maximum utilization.\n        # np.argmax returns the first occurrence in case of a tie, which matches the rule.\n        # Add 1 to convert from 0-based index to 1-based station index.\n        i_bottleneck = int(np.argmax(utilizations) + 1)\n\n        # Step 5: System Stability Analysis\n        # System is stable if and only if rho_2  1.0 and rho_3  1.0.\n        is_stable = (rho_2  1.0) and (rho_3  1.0)\n\n        # Assemble the results for the current test case.\n        case_result = [rho_1, rho_2, rho_3, i_bottleneck, is_stable]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # The example f\"[{','.join(map(str, results))}]\" works perfectly for this.\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "3355173"}]}