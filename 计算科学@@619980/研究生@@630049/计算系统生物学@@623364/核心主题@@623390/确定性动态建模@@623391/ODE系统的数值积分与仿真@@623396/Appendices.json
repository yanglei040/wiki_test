{"hands_on_practices": [{"introduction": "在深入研究生物系统的复杂动态之前，我们必须首先掌握将这些动态从数学模型转化为模拟结果的核心工具——数值积分器。本练习将揭开这些求解器的神秘面纱，指导您从第一性原理出发，构建一个三阶龙格-库塔（Runge-Kutta）方法。通过将数值格式的泰勒级数展开与解的精确展开相匹配，您将深入理解数值方法如何实现其精度，并为评估和选择更高级的算法奠定基础。[@problem_id:3334726]", "problem": "您正在为一个由质量作用动力学产生的非刚性基因调控网络设计一个数值求解器。该网络由形式为 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$ 的自治常微分方程（ODE）系统控制，其中 $\\mathbf{y} \\in \\mathbb{R}^{n}$ 表示浓度，$\\mathbf{f}$ 集合了反应速率。为了在大小为 $h$ 的时间步长上推进模拟，您决定构建一个三阶三级显式龙格-库塔（RK）方法。该方法经过专门设计，用于在步长内的中点和端点评估反应速率，以减少离散化误差，同时保持非刚性稳定性。\n\n设该方法由布彻（Butcher）系数 $(A, \\mathbf{b}, \\mathbf{c})$ 指定，其中 $A \\in \\mathbb{R}^{3 \\times 3}$ 是严格下三角矩阵，$\\mathbf{b} \\in \\mathbb{R}^{3}$ 是权重，$\\mathbf{c} \\in \\mathbb{R}^{3}$ 是级横坐标。施加约束条件 $c_{1} = 0$、$c_{2} = \\frac{1}{2}$ 和 $c_{3} = 1$，这与在步长的起点、中点和终点评估各级相一致。使用显式龙格-库塔方法的核心定义，特别是 $\\sum_{j=1}^{i-1} a_{ij} = c_i$ 对 $i>1$，并通过将精确解的泰勒级数展开与数值方法的泰勒级数展开相匹配，来推导达到三阶精度所需的阶条件。然后求解这些阶条件，以确定 $A$ 的所有非零元素和 $\\mathbf{b}$ 的所有元素，并给出最终的布彻表。\n\n最终答案请提供系数 $a_{31}$ 的精确数值。不要四舍五入。最终答案不需要物理单位。在您的推导和表述中，每个数学符号、变量、函数、运算符和数字都必须用 LaTeX 书写。您的解法中必须包含布彻表，并且您的推理必须从基本定义和经过检验的公式出发，而不是使用任何捷径公式。", "solution": "问题要求推导一个特定的三级三阶显式龙格-库塔（RK）方法的系数，该方法用于求解自治常微分方程（ODE）系统 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$。\n\n一个通用的 $s$ 级显式 RK 方法，用于将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$，由以下公式给出：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i \\mathbf{k}_i\n$$\n其中，级向量 $\\mathbf{k}_i$ 的计算方式如下：\n$$\n\\mathbf{k}_i = \\mathbf{f}\\left(\\mathbf{y}_n + h \\sum_{j=1}^{i-1} a_{ij} \\mathbf{k}_j\\right) \\quad \\text{for } i = 1, \\dots, s\n$$\n该方法由其布彻表来表征：\n$$\n\\begin{array}{c|c}\n\\mathbf{c} & A \\\\\n\\hline\n & \\mathbf{b}^T\n\\end{array}\n=\n\\begin{array}{c|cccc}\nc_1 & a_{11} & a_{12} & \\cdots & a_{1s} \\\\\nc_2 & a_{21} & a_{22} & \\cdots & a_{2s} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\nc_s & a_{s1} & a_{s2} & \\cdots & a_{ss} \\\\\n\\hline\n & b_1 & b_2 & \\cdots & b_s\n\\end{array}\n$$\n对于一个显式方法，矩阵 $A$ 是严格下三角的，即对于 $j \\geq i$，$a_{ij} = 0$。问题指定了一个 3 级方法（$s=3$），因此布彻表的形式为：\n$$\n\\begin{array}{c|ccc}\nc_1 & 0 & 0 & 0 \\\\\nc_2 & a_{21} & 0 & 0 \\\\\nc_3 & a_{31} & a_{32} & 0 \\\\\n\\hline\n & b_1 & b_2 & b_3\n\\end{array}\n$$\n问题施加了以下约束条件：\n1.  级横坐标为 $\\mathbf{c} = (c_1, c_2, c_3)^T = (0, 1/2, 1)^T$。\n2.  关系式 $\\sum_{j=1}^{i-1} a_{ij} = c_i$ 对所有 $i>1$ 成立。\n对于 $i=1$，$c_1 = 0$ 意味着没有 $\\sum a_{1j}$ 的约束，但这与显式方法的 $a_{1j}=0$ 一致。\n对于 $i=2$，$c_2 = a_{21} = 1/2$。\n对于 $i=3$，$c_3 = a_{31} + a_{32} = 1$。\n\n为了推导剩余的系数（$b_1, b_2, b_3, a_{31}, a_{32}$），我们将数值解 $\\mathbf{y}_{n+1}$ 的泰勒级数展开与精确解 $\\mathbf{y}(t_n+h)$ 的泰勒级数展开进行匹配，直到 $h^3$ 阶。\n\n精确解 $\\mathbf{y}(t)$ 在 $t_n$ 附近的泰勒级数展开为：\n$$\n\\mathbf{y}(t_n+h) = \\mathbf{y}(t_n) + h \\mathbf{y}'(t_n) + \\frac{h^2}{2} \\mathbf{y}''(t_n) + \\frac{h^3}{6} \\mathbf{y}'''(t_n) + O(h^4)\n$$\n对于自治系统，$\\mathbf{y}$ 的导数可以用 $\\mathbf{f}$ 及其雅可比矩阵 $\\mathbf{f}' = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}$ 及更高阶导数来表示：\n$\\mathbf{y}' = \\mathbf{f}$\n$\\mathbf{y}'' = \\mathbf{f}' \\mathbf{y}' = \\mathbf{f}' \\mathbf{f}$\n$\\mathbf{y}''' = \\frac{d}{dt}(\\mathbf{f}' \\mathbf{f}) = (\\mathbf{f}''(\\mathbf{f}))\\mathbf{f} + \\mathbf{f}'(\\mathbf{f}' \\mathbf{f})$\n将这些代入展开式，得到：\n$$\n\\mathbf{y}(t_n+h) = \\mathbf{y}_n + h\\mathbf{f} + \\frac{h^2}{2}\\mathbf{f}'\\mathbf{f} + \\frac{h^3}{6}\\left( \\mathbf{f}''(\\mathbf{f},\\mathbf{f}) + \\mathbf{f}'(\\mathbf{f}'\\mathbf{f}) \\right) + O(h^4)\n$$\n（此处，$\\mathbf{y}_n$ 代表 $\\mathbf{y}(t_n)$，$\\mathbf{f}$ 及其导数均在 $\\mathbf{y}_n$ 处求值）。\n\n接下来，我们展开数值解。各级为：\n$\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = \\mathbf{f}$\n$\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + h a_{21} \\mathbf{k}_1) = \\mathbf{f}(\\mathbf{y}_n + h a_{21} \\mathbf{f})$\n将 $\\mathbf{k}_2$ 在 $\\mathbf{y}_n$ 附近进行泰勒级数展开：\n$\\mathbf{k}_2 = \\mathbf{f} + h a_{21} (\\mathbf{f}'\\mathbf{f}) + \\frac{h^2}{2} a_{21}^2 \\mathbf{f}''(\\mathbf{f},\\mathbf{f}) + O(h^3)$\n$\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + h(a_{31}\\mathbf{k}_1 + a_{32}\\mathbf{k}_2))$\n$\\mathbf{f}$ 的自变量为 $\\mathbf{y}_n + h(a_{31}\\mathbf{f} + a_{32}(\\mathbf{f} + h a_{21}(\\mathbf{f}'\\mathbf{f}) + \\dots)) = \\mathbf{y}_n + h(a_{31}+a_{32})\\mathbf{f} + h^2 a_{32}a_{21}(\\mathbf{f}'\\mathbf{f}) + O(h^3)$。\n由于 $a_{31}+a_{32}=c_3$，自变量为 $\\mathbf{y}_n + h c_3 \\mathbf{f} + h^2 a_{32}a_{21}(\\mathbf{f}'\\mathbf{f}) + O(h^3)$。\n将 $\\mathbf{k}_3$ 在 $\\mathbf{y}_n$ 附近展开：\n$\\mathbf{k}_3 = \\mathbf{f} + \\mathbf{f}'(h c_3 \\mathbf{f} + h^2 a_{32}a_{21}(\\mathbf{f}'\\mathbf{f})) + \\frac{1}{2}\\mathbf{f}''(h c_3 \\mathbf{f}, h c_3 \\mathbf{f}) + O(h^3)$\n$\\mathbf{k}_3 = \\mathbf{f} + h c_3 (\\mathbf{f}'\\mathbf{f}) + h^2 \\left( a_{32}a_{21} \\mathbf{f}'(\\mathbf{f}'\\mathbf{f}) + \\frac{c_3^2}{2} \\mathbf{f}''(\\mathbf{f},\\mathbf{f}) \\right) + O(h^3)$\n\n数值解为 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + h(b_1\\mathbf{k}_1 + b_2\\mathbf{k}_2 + b_3\\mathbf{k}_3)$。代入 $\\mathbf{k}_i$ 的展开式：\n$$\n\\mathbf{y}_{n+1} - \\mathbf{y}_n = h\\mathbf{f}(b_1+b_2+b_3) + h^2(\\mathbf{f}'\\mathbf{f})(b_2 a_{21} + b_3 c_3) + h^3 \\left( \\mathbf{f}'(\\mathbf{f}'\\mathbf{f}) (b_3 a_{32} a_{21}) + \\mathbf{f}''(\\mathbf{f},\\mathbf{f}) \\left(\\frac{1}{2}b_2 a_{21}^2 + \\frac{1}{2}b_3 c_3^2\\right) \\right) + O(h^4)\n$$\n使用 $a_{21}=c_2$：\n$$\n\\mathbf{y}_{n+1} - \\mathbf{y}_n = h\\mathbf{f}\\sum_{i=1}^3 b_i + h^2(\\mathbf{f}'\\mathbf{f})\\sum_{i=1}^3 b_i c_i + h^3 \\left( \\mathbf{f}'(\\mathbf{f}'\\mathbf{f}) (b_3 a_{32} c_2) + \\mathbf{f}''(\\mathbf{f},\\mathbf{f}) \\sum_{i=1}^3 \\frac{1}{2}b_i c_i^2 \\right) + O(h^4)\n$$\n将系数与精确展开式逐项比较，得到阶条件：\n1. $O(h^1)$ 阶：$\\sum b_i = b_1+b_2+b_3 = 1$\n2. $O(h^2)$ 阶：$\\sum b_i c_i = b_1 c_1 + b_2 c_2 + b_3 c_3 = 1/2$\n3. $O(h^3)$ 阶，$\\mathbf{f}''(\\mathbf{f},\\mathbf{f})$ 项：$\\sum b_i c_i^2 = b_1 c_1^2 + b_2 c_2^2 + b_3 c_3^2 = 1/3$\n4. $O(h^3)$ 阶，$\\mathbf{f}'(\\mathbf{f}'\\mathbf{f})$ 项：$b_3 a_{32} c_2 = 1/6$\n\n我们使用给定的值 $c_1=0$，$c_2=1/2$，$c_3=1$ 来解这个方程组。\n从条件 2：\n$b_1(0) + b_2(1/2) + b_3(1) = 1/2 \\implies \\frac{1}{2}b_2 + b_3 = \\frac{1}{2}$\n从条件 3：\n$b_1(0)^2 + b_2(1/2)^2 + b_3(1)^2 = 1/3 \\implies \\frac{1}{4}b_2 + b_3 = \\frac{1}{3}$\n\n我们现在得到了一个关于 $b_2$ 和 $b_3$ 的二元线性方程组：\n(i) $\\frac{1}{2}b_2 + b_3 = \\frac{1}{2}$\n(ii) $\\frac{1}{4}b_2 + b_3 = \\frac{1}{3}$\n(i)式减去(ii)式：\n$(\\frac{1}{2} - \\frac{1}{4})b_2 = \\frac{1}{2} - \\frac{1}{3} \\implies \\frac{1}{4}b_2 = \\frac{1}{6} \\implies b_2 = \\frac{4}{6} = \\frac{2}{3}$。\n将 $b_2 = 2/3$ 代入 (ii)：\n$\\frac{1}{4}(\\frac{2}{3}) + b_3 = \\frac{1}{3} \\implies \\frac{1}{6} + b_3 = \\frac{1}{3} \\implies b_3 = \\frac{1}{3} - \\frac{1}{6} = \\frac{1}{6}$。\n从条件 1，求出 $b_1$：\n$b_1 + b_2 + b_3 = 1 \\implies b_1 + \\frac{2}{3} + \\frac{1}{6} = 1 \\implies b_1 + \\frac{5}{6} = 1 \\implies b_1 = \\frac{1}{6}$。\n所以权重向量为 $\\mathbf{b} = (1/6, 2/3, 1/6)^T$。\n\n现在我们求 $A$ 的剩余系数。我们已经有 $a_{21}=c_2=1/2$ 和关系式 $a_{31}+a_{32}=c_3=1$。\n我们使用第四个阶条件：$b_3 a_{32} c_2 = 1/6$。\n代入已知值 $b_3 = 1/6$ 和 $c_2 = 1/2$：\n$(\\frac{1}{6}) a_{32} (\\frac{1}{2}) = \\frac{1}{6} \\implies \\frac{a_{32}}{12} = \\frac{1}{6} \\implies a_{32} = \\frac{12}{6} = 2$。\n最后，我们从 $a_{31}+a_{32}=1$ 求出 $a_{31}$：\n$a_{31} + 2 = 1 \\implies a_{31} = -1$。\n\n现在所有系数都已确定。最终的布彻表为：\n$$\n\\begin{array}{c|ccc}\n0 & 0 & 0 & 0 \\\\\n1/2 & 1/2 & 0 & 0 \\\\\n1 & -1 & 2 & 0 \\\\\n\\hline\n & 1/6 & 2/3 & 1/6\n\\end{array}\n$$\n这对应于 Kutta 的三阶方法。问题要求系数 $a_{31}$ 的具体值。根据我们的推导，$a_{31} = -1$。", "answer": "$$\n\\boxed{-1}\n$$", "id": "3334726"}, {"introduction": "虽然我们刚刚构建的显式方法非常强大，但它们在面对生物系统中一个普遍存在的挑战——“刚性”（stiffness）问题时，会遇到效率瓶颈甚至失效。本练习将介绍刚性这一关键概念，并展示一个强大的、计算成本低廉的诊断工具——格施戈林圆盘定理（Gershgorin circle theorem）。通过应用该定理，您将学会如何估计一个系统的刚性程度，并理解它如何决定显式方法为保持稳定所必须采用的极小时间步长。[@problem_id:3334723]", "problem": "考虑一个三态磷酸化级联反应，其中蛋白质在一个未磷酸化状态 $M_{0}$、一个单磷酸化状态 $M_{1}$ 和一个双磷酸化状态 $M_{2}$ 之间循环。该网络由 $M_{0}$ 的组成性合成驱动，并通过激酶进行磷酸化，通过磷酸酶进行去磷酸化。假设激酶和磷酸酶的浓度恒定，因此动力学相对于蛋白质状态是一阶的。令 $x_{0}$、$x_{1}$ 和 $x_{2}$ 分别表示 $M_{0}$、$M_{1}$ 和 $M_{2}$ 的浓度。其常微分方程 (ODE) 模型为\n$$\n\\frac{d x_{0}}{d t} = c_{\\text{syn}} - a_{1} x_{0} - \\delta_{0} x_{0} + d_{1} x_{1}, \\quad\n\\frac{d x_{1}}{d t} = a_{1} x_{0} - a_{2} x_{1} - d_{1} x_{1} - \\delta_{1} x_{1} + d_{2} x_{2}, \\quad\n\\frac{d x_{2}}{d t} = a_{2} x_{1} - d_{2} x_{2} - \\delta_{2} x_{2}.\n$$\n此处，$c_{\\text{syn}}$ 是 $M_{0}$ 的恒定合成速率，$a_{1}$ 和 $a_{2}$ 是有效一级磷酸化速率常数，$d_{1}$ 和 $d_{2}$ 是有效一级去磷酸化速率常数，$\\delta_{0}$、$\\delta_{1}$、$\\delta_{2}$ 是一级降解常数。参数为\n$$\nc_{\\text{syn}} = 1.0 \\times 10^{-3}, \\quad a_{1} = 0.10, \\quad a_{2} = 0.08, \\quad d_{1} = 12.0, \\quad d_{2} = 15.0, \\quad \\delta_{0} = 0.02, \\quad \\delta_{1} = 0.03, \\quad \\delta_{2} = 0.04,\n$$\n所有速率常数的单位为 $\\text{s}^{-1}$，$c_{\\text{syn}}$ 的单位为浓度/秒。\n\n从质量作用定律和向量场的雅可比矩阵的定义出发，使用盖尔雄圆盘定理构建一个基于雅可比矩阵最大特征值模上界的保守且计算成本低的刚性诊断方法。然后，从此上界出发，为显式前向欧拉法推导最大稳定时间步长 $h_{\\max}^{G}$ 的一个保守估计值，定义为\n$$\nh_{\\max}^{G} = \\frac{2}{H},\n$$\n其中 $H$ 是您基于盖尔雄定理得到的最大特征值模的上界。使用指定的参数计算给定级联反应的 $h_{\\max}^{G}$。\n\n你的最终答案应以秒为单位，并将最终数值四舍五入至四位有效数字。只提供 $h_{\\max}^{G}$ 的最终数值作为答案。", "solution": "首先验证问题陈述，以确保其具有科学依据、是良定的和客观的。\n\n**第 1 步：提取已知信息**\n- **状态变量**：$x_{0}$、$x_{1}$、$x_{2}$，代表蛋白质状态 $M_{0}$、$M_{1}$、$M_{2}$ 的浓度。\n- **ODE 系统**：\n$$\n\\frac{d x_{0}}{d t} = c_{\\text{syn}} - a_{1} x_{0} - \\delta_{0} x_{0} + d_{1} x_{1}\n$$\n$$\n\\frac{d x_{1}}{d t} = a_{1} x_{0} - a_{2} x_{1} - d_{1} x_{1} - \\delta_{1} x_{1} + d_{2} x_{2}\n$$\n$$\n\\frac{d x_{2}}{d t} = a_{2} x_{1} - d_{2} x_{2} - \\delta_{2} x_{2}\n$$\n- **参数**：\n  - 合成速率：$c_{\\text{syn}} = 1.0 \\times 10^{-3}$\n  - 磷酸化速率：$a_{1} = 0.10$, $a_{2} = 0.08$\n  - 去磷酸化速率：$d_{1} = 12.0$, $d_{2} = 15.0$\n  - 降解速率：$\\delta_{0} = 0.02$, $\\delta_{1} = 0.03$, $\\delta_{2} = 0.04$\n- **任务**：\n  1. 求系统的雅可比矩阵。\n  2. 使用盖尔雄圆盘定理求雅可比矩阵最大特征值模的上界 $H$。\n  3. 计算最大稳定时间步长 $h_{\\max}^{G} = \\frac{2}{H}$。\n  4. 提供 $h_{\\max}^{G}$ 的数值，并四舍五入至四位有效数字。\n\n**第 2 步：使用提取的已知信息进行验证**\n该问题描述了一个线性常微分方程组，这是系统生物学中磷酸化级联反应的一个标准模型。该模型基于一级动力学，这是一种常见且有效的简化方法。所给参数的单位是一致的。该任务是矩阵理论（盖尔雄圆盘定理）在数值分析（前向欧拉法的稳定性）中的一个良定应用。该问题在科学上是合理的、自洽的、客观的。未发现任何缺陷。\n\n**第 3 步：结论与操作**\n问题是有效的。将提供解答。\n\n**解答推导**\n\n该 ODE 系统可以写成向量形式 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x})$，其中 $\\mathbf{x} = [x_{0}, x_{1}, x_{2}]^T$，向量场 $\\mathbf{f}(\\mathbf{x})$ 由下式给出：\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{pmatrix} c_{\\text{syn}} - (a_{1} + \\delta_{0}) x_{0} + d_{1} x_{1} \\\\ a_{1} x_{0} - (a_{2} + d_{1} + \\delta_{1}) x_{1} + d_{2} x_{2} \\\\ a_{2} x_{1} - (d_{2} + \\delta_{2}) x_{2} \\end{pmatrix}\n$$\n像显式前向欧拉法这类数值方法的稳定性取决于系统的雅可比矩阵的特征值，雅可比矩阵定义为 $J_{ij} = \\frac{\\partial f_i}{\\partial x_j}$。对于该系统，向量场 $\\mathbf{f}$ 的分量为 $f_0, f_1, f_2$。雅可比矩阵 $J$ 是：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f_0}{\\partial x_0} & \\frac{\\partial f_0}{\\partial x_1} & \\frac{\\partial f_0}{\\partial x_2} \\\\ \\frac{\\partial f_1}{\\partial x_0} & \\frac{\\partial f_1}{\\partial x_1} & \\frac{\\partial f_1}{\\partial x_2} \\\\ \\frac{\\partial f_2}{\\partial x_0} & \\frac{\\partial f_2}{\\partial x_1} & \\frac{\\partial f_2}{\\partial x_2} \\end{pmatrix}\n$$\n计算偏导数可得：\n$$\nJ = \\begin{pmatrix} -(a_{1} + \\delta_{0}) & d_{1} & 0 \\\\ a_{1} & -(a_{2} + d_{1} + \\delta_{1}) & d_{2} \\\\ 0 & a_{2} & -(d_{2} + \\delta_{2}) \\end{pmatrix}\n$$\n由于系统是线性的，雅可比矩阵是常数矩阵。\n\n盖尔雄圆盘定理指出，对于一个复 $n \\times n$ 矩阵 $A$，其所有特征值都位于盖尔雄圆盘 $D(A_{ii}, R_i)$ 的并集内，其中 $A_{ii}$ 是对角线元素，$R_i = \\sum_{j\\neq i} |A_{ij}|$ 是第 $i$ 行非对角线元素的绝对值之和。因此，谱半径 $\\rho(A) = \\max_i |\\lambda_i|$ 的上界为：\n$$\n\\rho(A) \\le \\max_i \\left( |A_{ii}| + R_i \\right)\n$$\n我们将此定理应用于雅可比矩阵 $J$ 以求得上界 $H$：\n$$\nH = \\max_i \\left( |J_{ii}| + \\sum_{j\\neq i} |J_{ij}| \\right)\n$$\n由于所有速率常数均为正，绝对值的计算很简单。我们计算每一行的总和：\n- **第 0 行**：$|J_{00}| + |J_{01}| + |J_{02}| = |-(a_{1} + \\delta_{0})| + |d_{1}| + |0| = a_{1} + \\delta_{0} + d_{1}$\n- **第 1 行**：$|J_{11}| + |J_{10}| + |J_{12}| = |-(a_{2} + d_{1} + \\delta_{1})| + |a_{1}| + |d_{2}| = a_{2} + d_{1} + \\delta_{1} + a_{1} + d_{2}$\n- **第 2 行**：$|J_{22}| + |J_{20}| + |J_{21}| = |-(d_{2} + \\delta_{2})| + |0| + |a_{2}| = d_{2} + \\delta_{2} + a_{2}$\n\n所以，上界 $H$ 是：\n$$\nH = \\max( a_{1} + \\delta_{0} + d_{1}, \\quad a_{1} + a_{2} + d_{1} + d_{2} + \\delta_{1}, \\quad a_{2} + d_{2} + \\delta_{2} )\n$$\n现在我们代入给定的参数值：\n$a_{1} = 0.10$, $a_{2} = 0.08$, $d_{1} = 12.0$, $d_{2} = 15.0$, $\\delta_{0} = 0.02$, $\\delta_{1} = 0.03$, $\\delta_{2} = 0.04$。\n\n令 $H_0, H_1, H_2$ 为每一行的上界：\n- $H_0 = 0.10 + 0.02 + 12.0 = 12.12$\n- $H_1 = 0.10 + 0.08 + 12.0 + 15.0 + 0.03 = 27.21$\n- $H_2 = 0.08 + 15.0 + 0.04 = 15.12$\n\n这些值的最大值给出了总上界 $H$：\n$$\nH = \\max(12.12, 27.21, 15.12) = 27.21 \\, \\text{s}^{-1}\n$$\n这个值 $H$ 作为雅可比矩阵最大特征值模 $|\\lambda|_{\\max}$ 的一个保守上界。较大的 $H$ 值表示系统中存在快速动力学，这是数值刚性的一个来源。\n\n对于系统 $\\frac{d\\mathbf{x}}{dt} = J\\mathbf{x}$，显式前向欧拉法的稳定性要求对于 $J$ 的每一个特征值 $\\lambda$，时间步长 $h$ 都必须满足 $|1+h\\lambda| \\le 1$。如果特征值为实数且为负，该条件意味着 $h \\le \\frac{2}{|\\lambda|_{\\max}}$。基于盖尔雄上界的最大稳定时间步长的给定公式为 $h_{\\max}^{G} = \\frac{2}{H}$。这是一个保守估计，因为 $H \\ge |\\lambda|_{\\max}$。\n\n使用计算出的 $H$ 值：\n$$\nh_{\\max}^{G} = \\frac{2}{H} = \\frac{2}{27.21} \\, \\text{s}\n$$\n$$\nh_{\\max}^{G} \\approx 0.0735023888... \\, \\text{s}\n$$\n按要求将结果四舍五入到四位有效数字：\n$$\nh_{\\max}^{G} \\approx 0.07350 \\, \\text{s}\n$$\n这就是将前向欧拉法应用于给定系统时，最大稳定时间步长的保守估计值。", "answer": "$$\n\\boxed{0.07350}\n$$", "id": "3334723"}, {"introduction": "既然我们能够诊断刚性问题，下一个合乎逻辑的步骤是学习如何有效地求解这类系统。本练习将引导您进入隐式-显式（IMEX）方法的世界，这是一种通过策略性地对系统不同部分采用不同处理方式来应对刚性的先进技术。通过这个编程实践，您将实现并分析一种“保渐近”分裂方案，亲身体验它如何在刚性极限下依然保持精度和效率，这是现代科学计算中的一个重要基石。[@problem_id:3334748]", "problem": "考虑一个可逆结合反应，其中两种分子间的合成与降解被建模为一个常微分方程（ODE）系统。该系统中，正向结合反应速度快，而合成与降解速度慢。设分子种类为 $A$、$B$ 和 $AB$，反应网络为 $A + B \\rightleftharpoons AB$，并补充有 $A$ 和 $B$ 的零阶合成，以及 $A$、$B$ 和 $AB$ 的一阶降解。浓度为无量纲。该 ODE 系统如下：\n$$\n\\frac{dA}{dt} \\;=\\; s_A \\;-\\; d_A\\,A \\;-\\; k_f\\,A\\,B \\;+\\; k_r\\,AB,\n$$\n$$\n\\frac{dB}{dt} \\;=\\; s_B \\;-\\; d_B\\,B \\;-\\; k_f\\,A\\,B \\;+\\; k_r\\,AB,\n$$\n$$\n\\frac{d(AB)}{dt} \\;=\\; -\\,d_{AB}\\,AB \\;+\\; k_f\\,A\\,B \\;-\\; k_r\\,AB.\n$$\n假设采用奇异摄动标度 $k_f = k_0/\\epsilon$，其中 $\\epsilon \\in (0,1)$，$k_0 = \\mathcal{O}(1)$ 且 $k_r = \\mathcal{O}(1)$，合成与降解参数均为 $\\mathcal{O}(1)$。\n\n你需要为此系统构建一个隐式–显式（IMEX）分裂，并分析其在 $\\epsilon \\to 0$ 时的行为。除非另有说明，请使用以下固定参数值：$s_A = 1.0$，$s_B = 0.5$，$d_A = 0.1$，$d_B = 0.2$，$d_{AB} = 0.05$，$k_0 = 1.0$，$k_r = 1.0$。初始条件为 $A(0) = 3.0$，$B(0) = 2.0$，$AB(0) = 0.0$。最终时间为 $T = 0.2$。所有量均为无量纲。\n\n任务：\n- 构建一个一阶隐式–显式欧拉法。对于固定的时间步长 $h$，将更新形式写为\n$$\ny^{n+1} \\;=\\; y^n \\;+\\; h\\,F(y^n) \\;+\\; h\\,G(y^{n+1}),\n$$\n其中 $y = (A,B,AB)^\\top$，$F$ 包含显式处理的非刚性项，$G$ 包含隐式处理的刚性项。考虑以下三种分裂：\n    - 渐近保持分裂（AP）：将完整的可逆反应对包含在刚性部分，即 $G$ 包含 $A+B \\rightleftharpoons AB$ 项，$F$ 仅包含合成与降解。\n    - 非渐近保持分裂（nonAP）：仅将正向结合项包含在 $G$ 中，并将逆向解离项与合成和降解一起在 $F$ 中处理。\n    - 自适应分裂（ADAPT）：在每一步计算一个刚性指标\n    $$\n    \\sigma \\;=\\; h\\left(k_f \\max\\{A^n,B^n\\} + k_r\\right),\n    $$\n    并使用滞后阈值 $\\theta_{\\text{on}} = 1.0$ 和 $\\theta_{\\text{off}} = 0.2$。如果 $\\sigma > \\theta_{\\text{on}}$，则将完整的可逆反应对包含在 $G$ 中；如果 $\\sigma < \\theta_{\\text{off}}$，则显式处理可逆反应对（即将其包含在 $F$ 中）；否则，仅将正向结合包含在 $G$ 中，解离包含在 $F$ 中。\n- 基于第一性原理，不使用任何预封装的结果，推导 IMEX-欧拉法对于 AP 和 nonAP 分裂的全局误差如何随时间步长 $h$ 和刚性参数 $\\epsilon$ 变化（当 $\\epsilon \\to 0$ 时）。假设 $h$ 的选择独立于 $\\epsilon$，但足够小以使一阶时间截断误差占主导。\n- 提出并实现一个稳健的牛顿法，用于每一步的隐式求解。使用 $G$ 的精确雅可比矩阵构建线性系统 $(I - h\\,J_G)\\,\\delta = -R$，其中 $R$ 是残差，并在必要时应用简单的回溯线搜索以确保收敛。\n- 使用由刚性求解器计算的高精度参考解来估计最终时间的全局误差。\n\n测试套件与输出规范：\n- 使用两个 $\\epsilon$ 值：$\\epsilon_1 = 10^{-3}$ 和 $\\epsilon_2 = 10^{-5}$。\n- 为计算观测阶，使用两个均匀步长 $h_1 = T/1000$ 和 $h_2 = T/2000$。\n- 对于所有参考解，使用具有严格容差 $\\text{rtol} = 10^{-12}$ 和 $\\text{atol} = 10^{-14}$ 的刚性 ODE 积分器来近似 $t = T$ 时的精确解。\n- 计算以下五个标量结果：\n    1. $p_{\\text{AP}}(\\epsilon_1)$：AP 分裂在 $\\epsilon_1$ 时的观测精度阶，计算公式为\n    $$\n    p \\;=\\; \\log_2\\!\\left(\\frac{E(h_1)}{E(h_2)}\\right),\n    $$\n    其中 $E(h)$ 是使用步长 $h$ 在 $t=T$ 时相对于参考解的全局误差的欧几里得范数。\n    2. $p_{\\text{AP}}(\\epsilon_2)$：使用相同公式计算的 AP 分裂在 $\\epsilon_2$ 时的观测阶。\n    3. $\\rho_{\\text{nonAP}}$：在固定步长 $h_2$ 下，nonAP 分裂的最终时刻误差之比，\n    $$\n    \\rho_{\\text{nonAP}} \\;=\\; \\frac{E_{\\text{nonAP}}(\\epsilon_2, h_2)}{E_{\\text{nonAP}}(\\epsilon_1, h_2)}.\n    $$\n    4. $p_{\\text{ADAPT}}(\\epsilon_1)$：ADAPT 分裂在 $\\epsilon_1$ 时的观测阶，计算方法同第 1 项。\n    5. $\\phi_{\\text{ADAPT}}$：当使用 $\\epsilon_1$ 和步长 $h_1$ 运行时，自适应逻辑选择将完整可逆反应对作隐式处理（即 $G$ 包括正向和逆向项）的时间步所占的比例。\n- 最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[ \\, p_{\\text{AP}}(\\epsilon_1), \\; p_{\\text{AP}}(\\epsilon_2), \\; \\rho_{\\text{nonAP}}, \\; p_{\\text{ADAPT}}(\\epsilon_1), \\; \\phi_{\\text{ADAPT}} \\, \\right].\n$$\n所有输出必须是十进制浮点数。\n\n注意：\n- 所有计算都是无单位的。不涉及角度。不要打印中间文本或诊断信息。\n- IMEX 方法、牛顿求解器和自适应切换逻辑必须由你明确实现；不要为 IMEX 步骤调用黑盒时间步进求解器。只有参考解可以使用库求解器。", "solution": "该问题要求实现和分析用于模拟可逆化学反应的刚性常微分方程（ODE）系统的隐式-显式（IMEX）欧拉法。设状态向量为 $y = (A, B, AB)^\\top$。控制该系统的 ODE 为 $\\frac{dy}{dt} = f(y)$。\n\n该系统可以写成一个代表合成和降解的非刚性部分与一个代表可逆结合反应的刚性部分之和：\n$$\n\\frac{dy}{dt} = \\begin{pmatrix} s_A - d_A A \\\\ s_B - d_B B \\\\ -d_{AB} AB \\end{pmatrix} + \\begin{pmatrix} -k_f A B + k_r AB \\\\ -k_f A B + k_r AB \\\\ k_f A B - k_r AB \\end{pmatrix}\n$$\n刚性来源于正向反应速率常数 $k_f = k_0/\\epsilon$（对于小的 $\\epsilon > 0$）。\n\n一阶 IMEX 欧拉法将 ODE $\\frac{dy}{dt} = F(y) + G(y)$ 离散化为：\n$$\n\\frac{y^{n+1} - y^n}{h} = F(y^n) + G(y^{n+1})\n$$\n其中 $h$ 是时间步长，$y^n \\approx y(t_n)$，函数 $F$ 被显式处理，而 $G$ 被隐式处理。这可以重排为更新公式：\n$$\ny^{n+1} = y^n + h F(y^n) + h G(y^{n+1})\n$$\n\n分裂的选择，即哪些项进入 $F$（非刚性，显式）和 $G$（刚性，隐式），对于方法的精度和稳定性至关重要，尤其是在刚性极限 $\\epsilon \\to 0$ 时。\n\n**1. IMEX 分裂**\n\n设 $S(y) = (s_A - d_A A, s_B - d_B B, -d_{AB} AB)^\\top$ 为合成/降解项。\n设 $R_f(y) = (-k_f A B, -k_f A B, k_f A B)^\\top$ 为正向反应项。\n设 $R_r(y) = (k_r AB, k_r AB, -k_r AB)^\\top$ 为逆向反应项。\n完整的 ODE 是 $\\frac{dy}{dt} = S(y) + R_f(y) + R_r(y)$。\n\n- **渐近保持（AP）分裂**：整个刚性反应项被隐式处理。\n  - $F_{AP}(y) = S(y)$\n  - $G_{AP}(y) = R_f(y) + R_r(y) = (-k_f A B + k_r AB, -k_f A B + k_r AB, k_f A B - k_r AB)^\\top$\n\n- **非渐近保持（nonAP）分裂**：只有最快的项被隐式处理。\n  - $F_{nonAP}(y) = S(y) + R_r(y) = (s_A - d_A A + k_r AB, s_B - d_B B + k_r AB, -d_{AB} AB - k_r AB)^\\top$\n  - $G_{nonAP}(y) = R_f(y) = (-k_f A B, -k_f A B, k_f A B)^\\top$\n\n- **自适应（ADAPT）分裂**：在每一步 $n$ 根据刚性指标 $\\sigma^n = h(k_f \\max\\{A^n, B^n\\} + k_r)$ 选择分裂方式。\n  - 如果 $\\sigma^n > \\theta_{\\text{on}} = 1.0$：使用 AP 分裂。$F=F_{AP}$，$G=G_{AP}$。\n  - 如果 $\\sigma^n < \\theta_{\\text{off}} = 0.2$：使用完全显式格式。$F=S+R_f+R_r$，$G=0$。\n  - 否则（$0.2 \\le \\sigma^n \\le 1.0$）：使用 nonAP 分裂。$F=F_{nonAP}$，$G=G_{nonAP}$。\n\n**2. $\\epsilon \\to 0$ 时的误差分析**\n\nIMEX-欧拉法的局部截断误差（LTE）为 $d^{n+1} = y(t_{n+1}) - y^{n+1}$，其中 $y^{n+1}$ 是从精确解 $y(t_n)$ 出发经过一步计算得到的数值解。标准分析表明 LTE 为 $d^{n+1} = h^2 \\left( \\frac{1}{2}\\ddot{y}(t_n) - J_G(y(t_n))\\dot{y}(t_n) \\right) + \\mathcal{O}(h^3)$，其中 $J_G$ 是 $G$ 的雅可比矩阵。只要 LTE 中的常数保持有界，全局误差会低一阶，为 $\\mathcal{O}(h)$。关键在于这个常数如何依赖于 $\\epsilon$。\n\n该 ODE 系统是一个形式为 $\\dot{y} = \\text{慢项} + \\frac{1}{\\epsilon}\\text{快项}$ 的奇异摄动问题。当 $\\epsilon \\to 0$ 时，解会迅速趋近一个准稳态（QSS）流形，在该流形上快速动力学达到平衡，即 $k_f A B \\approx k_r AB$。在此流形上，解在慢时间尺度上演化。\n\n- **AP 分裂**：这种分裂被设计成“渐近保持”的。隐式部分 $G_{AP}$ 包含完整的可逆反应。隐式部分的数值格式为 $y^{n+1} = y_{exp} + h G_{AP}(y^{n+1})$，其中 $y_{exp} = y^n + h F_{AP}(y^n)$。在极限 $\\epsilon \\to 0$ 时，$k_f \\to \\infty$。为使更新保持有界，$G_{AP}(y^{n+1})$ 必须是有限的，这要求刚性项相互抵消，即 $k_f A^{n+1} B^{n+1} - k_r AB^{n+1} \\approx 0$。这意味着数值解 $y^{n+1}$ 被正确地强制到一个 QSS 流形的离散近似上。此性质确保 LTE 中的误差常数在 $\\epsilon \\to 0$ 时保持为 $\\mathcal{O}(1)$。因此，全局误差的阶为 $\\mathcal{O}(h)$，且关于 $\\epsilon$ 一致。我们预期对于小和非常小的 $\\epsilon$，观测到的精度阶 $p_{AP}$ 都接近 1。\n\n- **nonAP 分裂**：这种分裂不是渐近保持的。它隐式处理正向反应，但显式处理逆向反应：\n$$\n\\frac{AB^{n+1} - AB^n}{h} \\approx (-d_{AB}AB^n - k_r AB^n) + k_f A^{n+1}B^{n+1}\n$$\n该格式混合了在不同时间层上计算的项（$AB^n$ 和 $A^{n+1}B^{n+1}$），而这些项在刚性极限下本应相互平衡。这种“分裂误差”引入了与极限动力学的不一致性。对 $k_r AB$ 项的显式处理导致了一个与快速动力学量级成比例的误差项。形式化分析表明，LTE 中的误差常数以 $\\mathcal{O}(1/\\epsilon)$ 的速度增长，导致全局误差的形式为 $E(h, \\epsilon) \\approx C_1 h + C_2 h/\\epsilon$。对于固定的步长 $h$，当 $\\epsilon \\to 0$ 时误差会爆炸。对于两个不同的 $\\epsilon$ 值（$\\epsilon_1$ 和 $\\epsilon_2$），误差之比预计为 $\\rho_{\\text{nonAP}} \\approx \\frac{E(\\epsilon_2)}{E(\\epsilon_1)} \\approx \\frac{h/\\epsilon_2}{h/\\epsilon_1} = \\frac{\\epsilon_1}{\\epsilon_2}$。\n\n**3. 用于隐式求解的牛顿法**\n\n在每个时间步，我们必须求解一个关于 $y^{n+1}$ 的非线性系统。令 $x = y^{n+1}$ 和 $y^* = y^n + h F(y^n)$。需要求解的方程是：\n$$\nR(x) = x - h G(x) - y^* = 0\n$$\n我们使用牛顿法，它生成一个近似序列 $x_k$。从一个初始猜测 $x_0$（例如 $x_0 = y^n$）开始，迭代过程如下：\n1. 求解线性系统以获得更新步 $\\delta_k$：$J_R(x_k) \\delta_k = -R(x_k)$，其中 $J_R(x_k) = I - h J_G(x_k)$ 是残差函数 $R(x)$ 的雅可比矩阵。\n2. 更新解：$x_{k+1} = x_k + \\alpha_k \\delta_k$。\n\n这里，$\\alpha_k$ 是通过回溯线搜索选择的步长，以确保残差范数 $\\|R(x_{k+1})\\|_2$ 有充分的下降。我们从 $\\alpha_k=1$ 开始，如果新的残差不小于旧的，则减小它（例如，除以 2）。\n\n需要刚性部分 $G$ 的雅可比矩阵。设 $y=(A,B,C)^\\top$，其中 $C=AB$。\n- 对于 AP 分裂：$G(y) = (-k_f A B + k_r C, -k_f A B + k_r C, k_f A B - k_r C)^\\top$。雅可比矩阵为：\n$$\nJ_{G,AP}(y) = \\begin{pmatrix}\n-k_f B & -k_f A & k_r \\\\\n-k_f B & -k_f A & k_r \\\\\nk_f B & k_f A & -k_r\n\\end{pmatrix}\n$$\n- 对于 nonAP 分裂：$G(y) = (-k_f A B, -k_f A B, k_f A B)^\\top$。雅可比矩阵为：\n$$\nJ_{G,nonAP}(y) = \\begin{pmatrix}\n-k_f B & -k_f A & 0 \\\\\n-k_f B & -k_f A & 0 \\\\\nk_f B & k_f A & 0\n\\end{pmatrix}\n$$\n- 对于 ADAPT 格式的完全显式部分，$G=0$，因此 $J_G=0$，隐式求解是平凡的：$y^{n+1} = y^*$。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to perform the analysis and produce the final output.\n    \"\"\"\n    params = {\n        'sA': 1.0, 'sB': 0.5, 'dA': 0.1, 'dB': 0.2, 'dAB': 0.05,\n        'k0': 1.0, 'k_r': 1.0,\n    }\n    y0 = np.array([3.0, 2.0, 0.0])\n    T = 0.2\n\n    # Test suite parameters\n    epsilon_1 = 1e-3\n    epsilon_2 = 1e-5\n    h1 = T / 1000.0\n    h2 = T / 2000.0\n\n    # --- Calculation for p_AP(epsilon_1) ---\n    y_ref_e1 = get_reference(y0, T, epsilon_1, params)\n    y_final_ap_e1_h1, _ = imex_euler(y0, T, h1, epsilon_1, params, 'ap')\n    y_final_ap_e1_h2, _ = imex_euler(y0, T, h2, epsilon_1, params, 'ap')\n    err_ap_e1_h1 = np.linalg.norm(y_final_ap_e1_h1 - y_ref_e1)\n    err_ap_e1_h2 = np.linalg.norm(y_final_ap_e1_h2 - y_ref_e1)\n    p_ap_e1 = np.log2(err_ap_e1_h1 / err_ap_e1_h2)\n\n    # --- Calculation for p_AP(epsilon_2) ---\n    y_ref_e2 = get_reference(y0, T, epsilon_2, params)\n    y_final_ap_e2_h1, _ = imex_euler(y0, T, h1, epsilon_2, params, 'ap')\n    y_final_ap_e2_h2, _ = imex_euler(y0, T, h2, epsilon_2, params, 'ap')\n    err_ap_e2_h1 = np.linalg.norm(y_final_ap_e2_h1 - y_ref_e2)\n    err_ap_e2_h2 = np.linalg.norm(y_final_ap_e2_h2 - y_ref_e2)\n    p_ap_e2 = np.log2(err_ap_e2_h1 / err_ap_e2_h2)\n\n    # --- Calculation for rho_nonAP ---\n    y_final_nonap_e1_h2, _ = imex_euler(y0, T, h2, epsilon_1, params, 'nonap')\n    err_nonap_e1_h2 = np.linalg.norm(y_final_nonap_e1_h2 - y_ref_e1)\n    y_final_nonap_e2_h2, _ = imex_euler(y0, T, h2, epsilon_2, params, 'nonap')\n    err_nonap_e2_h2 = np.linalg.norm(y_final_nonap_e2_h2 - y_ref_e2)\n    rho_nonap = err_nonap_e2_h2 / err_nonap_e1_h2\n\n    # --- Calculation for p_ADAPT(epsilon_1) ---\n    y_final_adapt_e1_h1, _ = imex_euler(y0, T, h1, epsilon_1, params, 'adapt')\n    y_final_adapt_e1_h2, _ = imex_euler(y0, T, h2, epsilon_1, params, 'adapt')\n    err_adapt_e1_h1 = np.linalg.norm(y_final_adapt_e1_h1 - y_ref_e1)\n    err_adapt_e1_h2 = np.linalg.norm(y_final_adapt_e1_h2 - y_ref_e1)\n    p_adapt_e1 = np.log2(err_adapt_e1_h1 / err_adapt_e1_h2)\n    \n    # --- Calculation for phi_ADAPT ---\n    _, ap_count = imex_euler(y0, T, h1, epsilon_1, params, 'adapt')\n    phi_adapt = ap_count / (T / h1)\n    \n    results = [p_ap_e1, p_ap_e2, rho_nonap, p_adapt_e1, phi_adapt]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_reference(y0, T, epsilon, params):\n    \"\"\"Computes a high-accuracy reference solution using a stiff solver.\"\"\"\n    def ode_system(t, y):\n        A, B, AB = y\n        sA, sB, dA, dB, dAB = params['sA'], params['sB'], params['dA'], params['dB'], params['dAB']\n        k_f = params['k0'] / epsilon\n        k_r = params['k_r']\n        \n        reaction_rate = k_f * A * B - k_r * AB\n        \n        dAdt = sA - dA * A - reaction_rate\n        dBdt = sB - dB * B - reaction_rate\n        dABdt = -dAB * AB + reaction_rate\n        \n        return np.array([dAdt, dBdt, dABdt])\n\n    sol = solve_ivp(ode_system, (0, T), y0, method='Radau', rtol=1e-12, atol=1e-14)\n    return sol.y[:, -1]\n\ndef newton_solver(y_star, y_guess, h, k_f, k_r, g_type):\n    \"\"\"Solves the nonlinear system x - h*G(x) - y_star = 0 for x.\"\"\"\n    x = y_guess.copy()\n    max_iter = 10\n    tol = 1e-12\n\n    for _ in range(max_iter):\n        if g_type == 'ap':\n            G_x = np.array([-k_f*x[0]*x[1] + k_r*x[2],\n                            -k_f*x[0]*x[1] + k_r*x[2],\n                             k_f*x[0]*x[1] - k_r*x[2]])\n            J_G = np.array([[-k_f*x[1], -k_f*x[0], k_r],\n                            [-k_f*x[1], -k_f*x[0], k_r],\n                            [ k_f*x[1],  k_f*x[0], -k_r]])\n        elif g_type == 'nonap':\n            G_x = np.array([-k_f*x[0]*x[1],\n                            -k_f*x[0]*x[1],\n                             k_f*x[0]*x[1]])\n            J_G = np.array([[-k_f*x[1], -k_f*x[0], 0],\n                            [-k_f*x[1], -k_f*x[0], 0],\n                            [ k_f*x[1],  k_f*x[0], 0]])\n        else: # 'explicit'\n            return y_star\n\n        residual = x - h * G_x - y_star\n        if np.linalg.norm(residual)  tol:\n            return x\n\n        J_R = np.identity(3) - h * J_G\n        delta = np.linalg.solve(J_R, -residual)\n        \n        # Backtracking line search\n        alpha = 1.0\n        norm_res = np.linalg.norm(residual)\n        for _ in range(5):  # Max 5 backtracking steps\n            x_new = x + alpha * delta\n            # Ensure positivity\n            if np.any(x_new  0):\n                alpha /= 2\n                continue\n            \n            if g_type == 'ap':\n                G_new = np.array([-k_f*x_new[0]*x_new[1] + k_r*x_new[2],\n                                  -k_f*x_new[0]*x_new[1] + k_r*x_new[2],\n                                   k_f*x_new[0]*x_new[1] - k_r*x_new[2]])\n            else: # nonap\n                G_new = np.array([-k_f*x_new[0]*x_new[1],\n                                  -k_f*x_new[0]*x_new[1],\n                                   k_f*x_new[0]*x_new[1]])\n            \n            new_res_norm = np.linalg.norm(x_new - h * G_new - y_star)\n            if new_res_norm  norm_res:\n                break\n            alpha /= 2\n        \n        x += alpha * delta\n\n    return x\n\ndef imex_euler(y0, T, h, epsilon, params, splitting_mode):\n    \"\"\"\n    Solves the ODE system using an IMEX Euler method.\n    Returns the final state vector and, for adaptive mode, the AP mode count.\n    \"\"\"\n    y = y0.copy()\n    num_steps = int(np.round(T / h))\n    k_f = params['k0'] / epsilon\n    k_r = params['k_r']\n    sA, sB, dA, dB, dAB = params['sA'], params['sB'], params['dA'], params['dB'], params['dAB']\n    \n    ap_mode_count = 0\n    theta_on, theta_off = 1.0, 0.2\n\n    for _ in range(num_steps):\n        A, B, AB = y\n\n        current_g_type = ''\n        if splitting_mode == 'ap':\n            F_y = np.array([sA - dA*A, sB - dB*B, -dAB*AB])\n            current_g_type = 'ap'\n        elif splitting_mode == 'nonap':\n            F_y = np.array([sA - dA*A + k_r*AB, sB - dB*B + k_r*AB, -dAB*AB - k_r*AB])\n            current_g_type = 'nonap'\n        elif splitting_mode == 'adapt':\n            sigma = h * (k_f * max(A, B) + k_r)\n            if sigma > theta_on:\n                F_y = np.array([sA - dA*A, sB - dB*B, -dAB*AB])\n                current_g_type = 'ap'\n                ap_mode_count += 1\n            elif sigma  theta_off:\n                reaction_rate = k_f * A * B - k_r * AB\n                F_y = np.array([sA - dA*A - reaction_rate,\n                                sB - dB*B - reaction_rate,\n                                -dAB*AB + reaction_rate])\n                current_g_type = 'explicit'\n            else:\n                F_y = np.array([sA - dA*A + k_r*AB, sB - dB*B + k_r*AB, -dAB*AB - k_r*AB])\n                current_g_type = 'nonap'\n\n        y_star = y + h * F_y\n        \n        # Use previous step y as initial guess for Newton solver\n        y = newton_solver(y_star, y, h, k_f, k_r, current_g_type)\n\n    return y, ap_mode_count\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3334748"}]}