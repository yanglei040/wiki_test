{"hands_on_practices": [{"introduction": "细胞信号通路的基本功能之一是响应环境变化，但通常需要区分持续的信号和短暂的信号。前馈环（Feedforward Loops, FFLs）是实现这一功能的关键网络基序。本实践将引导你通过分析两种典型的前馈环（C1-FFL 和 I1-FFL）来探索它们如何产生适应性（adaptation）和脉冲式响应，这是理解细胞如何过滤信号和产生动态输出的基础。通过从头推导系统的解析解并编写代码来验证其行为，你将把线性系统理论与计算实践相结合，加深对网络结构与功能之间关系的理解 [@problem_id:3336287]。", "problem": "考虑细胞中常见的两种典型三节点信号传导架构：1型相干前馈环（C1-FFL）和1型非相干前馈环（I1-FFL）。设上游输入为阶跃函数 $u(t)$，在时间 $t=0$ 时从 $0$ 切换到一个正常数 $U$。假设在一个工作点附近存在一个线性化的小信号区域，其中产物的生成与调节因子的浓度呈线性关系，且所有物质均以一级动力学方式降解。具体而言，设 $x(t)$ 和 $z(t)$ 是由 $u(t)$ 直接驱动的中间调节因子，而 $y(t)$ 是输出。其动力学由一阶常微分方程（ODE）控制，其生物学和数学基础如下：\n\n- 一阶分子周转：$x(t)$、$y(t)$ 和 $z(t)$ 的降解速率与其各自浓度成正比，速率常数 $a_x$、$a_y$ 和 $a_z$ 均为正常数。\n- 工作点附近的线性化生成：对于小偏差，生成项与上游调节因子的浓度呈线性关系，$b_x$、$b_z$ 分别是 $u(t)$ 对 $x(t)$ 和 $z(t)$ 影响的增益，$k_x$、$k_z$ 分别是 $x(t)$ 和 $z(t)$ 对 $y(t)$ 影响的增益。\n- C1-FFL的两条路径都激活 $y(t)$，而I1-FFL中一条路径激活 $y(t)$，另一条则抑制它。令 $s \\in \\{+1,-1\\}$ 编码相干性：对于C1-FFL，$s=+1$；对于I1-FFL，$s=-1$。\n\n在这些假设下，常微分方程组为\n$$\n\\frac{dx}{dt} = -a_x x + b_x u(t), \\quad \\frac{dz}{dt} = -a_z z + b_z u(t), \\quad \\frac{dy}{dt} = -a_y y + k_x x + s\\,k_z z,\n$$\n初始条件为 $x(0)=0$、$z(0)=0$、$y(0)=0$，输入为阶跃函数，当 $t\\ge 0$ 时 $u(t)=U$，当 $t  0$ 时 $u(t)=0$。所有参数 $a_x$、$a_y$、$a_z$、$b_x$、$b_z$、$k_x$、$k_z$、$U$ 均为严格为正的实数。\n\n您的任务：\n\n1. 从上述常微分方程出发，仅使用线性系统原理（叠加原理、积分因子和一阶系统的阶跃响应），推导 $t\\ge 0$ 时 $y(t)$ 的闭式表达式，该表达式应使用参数 $a_x$、$a_y$、$a_z$、$b_x$、$b_z$、$k_x$、$k_z$、$U$ 和 $s$ 来表示。您的推导必须从一阶系统的阶跃响应定义和一阶线性常微分方程的积分因子法开始。\n2. 使用您得到的 $y(t)$ 表达式，为阶跃输入后的适应性和脉冲状行为定义一个定量测试：\n   - 定义稳态值 $y_\\infty = \\lim_{t\\to\\infty} y(t)$，并定义一个绝对容差 $\\varepsilon$ 来判断适应性。如果 $|y_\\infty - y(0)| \\le \\varepsilon$，则称系统表现出适应性，注意 $y(0)=0$。使用 $\\varepsilon = 10^{-8}$。\n   - 定义峰值 $y_{\\max} = \\max_{t\\ge 0} y(t)$。脉冲状响应定义如下。如果系统具有适应性，当 $y_{\\max} \\ge A_{\\min}$ (其中 $A_{\\min} = 10^{-4}$) 时，判定为脉冲状。如果系统不具有适应性，当 $y_{\\max} / \\max\\{ |y_\\infty|, \\delta \\} \\ge R$ (其中 $R = 1.2$，$\\delta = 10^{-12}$ 用于避免除以零) 时，判定为脉冲状。这个定义涵盖了返回基线的瞬态过程（带脉冲的适应性）或相对于非零稳态的显著超调。\n3. 实现一个程序，对于下面的每个参数集，在时间范围 $t \\in [0,T]$（其中 $T=50$）内计算 $y(t)$，并根据上述定义确定两个布尔值：响应是否具有适应性，以及是否是脉冲状的。使用足够精细的时间离散化来精确捕捉瞬态过程。\n4. 您的程序必须处理以下参数集测试套件。对于每种情况，所有量都是无量纲的。对于每个参数元组，按顺序报告两个布尔值：首先是适应性布尔值，然后是脉冲状布尔值。\n   - 案例1 (I1-FFL，完全适应): $s=-1$, $a_x=1.0$, $a_y=0.5$, $a_z=0.2$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.2$, $U=1.0$.\n   - 案例2 (C1-FFL，无适应性): $s=+1$, $a_x=1.0$, $a_y=0.5$, $a_z=0.2$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.2$, $U=1.0$.\n   - 案例3 (I1-FFL，部分适应和超调): $s=-1$, $a_x=1.0$, $a_y=0.5$, $a_z=0.2$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.1$, $U=1.0$.\n   - 案例4 (C1-FFL，不同时间尺度): $s=+1$, $a_x=0.1$, $a_y=0.5$, $a_z=2.0$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=1.0$, $U=1.0$.\n   - 案例5 (I1-FFL，时间尺度接近，增益轻微失配): $s=-1$, $a_x=0.5$, $a_y=0.3$, $a_z=0.51$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.95$, $U=1.0$.\n5. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须是按顺序将每个案例的两个布尔值串联起来的结果，形成一个长度为10的扁平列表。例如，输出形式为 $[b_1,b_2,\\dots,b_{10}]$，其中每个 $b_i$ 是 $True$ 或 $False$。\n\n您的程序必须是自包含的，不得读取任何输入，并且只能使用标准库和（如果需要）指定的数值库。输出必须严格为指定格式的一行。不涉及任何物理单位；所有量均为无量纲。不出现角度。任何地方都不得使用百分比；如果需要，只能考虑十进制形式的实值分数。", "solution": "该问题已经过验证，并被确定为有效。它在科学上基于应用于生化网络基序的线性系统理论原理，在数学上是适定的，提供了所有必要信息，并且陈述客观。我们开始进行求解。\n\n任务是推导两种类型的前馈环（FFL）对阶跃输入的瞬态响应 $y(t)$，然后根据适应性和脉冲状行为的标准对响应进行分类。\n\n**1. $y(t)$ 闭式解的推导**\n\n该系统由一组常系数线性常微分方程（ODE）描述。对于 $t \\ge 0$，输入为常数 $u(t)=U$。\n\n**步骤1.1：求解中间调节因子 $x(t)$ 和 $z(t)$**\n\n$x(t)$ 和 $z(t)$ 的动力学与系统的其余部分以及彼此之间是解耦的。它们遵循相同的一阶线性常微分方程通用形式：\n$$\n\\frac{dw}{dt} = -a w + b U, \\quad w(0) = 0\n$$\n其中 $(w, a, b)$ 对应于 $(x, a_x, b_x)$ 或 $(z, a_z, b_z)$。我们使用积分因子法求解该方程。积分因子为 $e^{\\int a dt} = e^{at}$。将整理后的常微分方程 $\\frac{dw}{dt} + aw = bU$ 乘以积分因子，得到：\n$$\ne^{at} \\frac{dw}{dt} + a e^{at} w = b U e^{at}\n$$\n左边是乘积的导数：\n$$\n\\frac{d}{dt}(w(t) e^{at}) = b U e^{at}\n$$\n对两边从 $\\tau=0$ 到 $\\tau=t$ 进行积分，并应用初始条件 $w(0)=0$：\n$$\n\\int_0^t \\frac{d}{d\\tau}(w(\\tau) e^{a\\tau}) d\\tau = \\int_0^t b U e^{a\\tau} d\\tau\n$$\n$$\n[w(\\tau) e^{a\\tau}]_0^t = b U \\left[ \\frac{1}{a} e^{a\\tau} \\right]_0^t\n$$\n$$\nw(t)e^{at} - w(0)e^0 = \\frac{bU}{a} (e^{at} - e^0)\n$$\n$$\nw(t)e^{at} = \\frac{bU}{a} (e^{at} - 1)\n$$\n求解 $w(t)$ 可得一阶系统的阶跃响应：\n$$\nw(t) = \\frac{bU}{a}(1 - e^{-at})\n$$\n将此通解应用于 $x(t)$ 和 $z(t)$：\n$$\nx(t) = \\frac{b_x U}{a_x}(1 - e^{-a_x t})\n$$\n$$\nz(t) = \\frac{b_z U}{a_z}(1 - e^{-a_z t})\n$$\n\n**步骤1.2：求解输出 $y(t)$**\n\n$y(t)$ 的常微分方程为：\n$$\n\\frac{dy}{dt} = -a_y y + k_x x(t) + s k_z z(t), \\quad y(0)=0\n$$\n代入 $x(t)$ 和 $z(t)$ 的表达式：\n$$\n\\frac{dy}{dt} + a_y y = k_x \\left[\\frac{b_x U}{a_x}(1 - e^{-a_x t})\\right] + s k_z \\left[\\frac{b_z U}{a_z}(1 - e^{-a_z t})\\right]\n$$\n令强迫函数为 $f(t)$。我们可以将各项分组：\n$$\nf(t) = \\underbrace{U \\left(\\frac{k_x b_x}{a_x} + s\\frac{k_z b_z}{a_z}\\right)}_{K_0} \\underbrace{- U\\frac{k_x b_x}{a_x}}_{K_x} e^{-a_x t} \\underbrace{- s U\\frac{k_z b_z}{a_z}}_{K_z} e^{-a_z t}\n$$\n方程为 $\\frac{dy}{dt} + a_y y = K_0 + K_x e^{-a_x t} + K_z e^{-a_z t}$。通解是齐次解 $y_h(t) = A e^{-a_y t}$ 和一个特解 $y_p(t)$ 的和。根据叠加原理，我们可以为 $f(t)$ 中的每一项找到特解。假设衰减率 $a_x$、$a_y$、$a_z$ 是互不相同的（在所有给定的测试案例中都是如此），我们使用待定系数法：\n- 对于常数项 $K_0$，特解为 $y_{p,0} = K_0/a_y$。\n- 对于项 $K_x e^{-a_x t}$，特解为 $y_{p,x} = \\frac{K_x}{a_y - a_x} e^{-a_x t}$。\n- 对于项 $K_z e^{-a_z t}$，特解为 $y_{p,z} = \\frac{K_z}{a_y - a_z} e^{-a_z t}$。\n\n完整的特解是 $y_p(t) = \\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} e^{-a_x t} + \\frac{K_z}{a_y - a_z} e^{-a_z t}$。\n通解为：\n$$\ny(t) = A e^{-a_y t} + \\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} e^{-a_x t} + \\frac{K_z}{a_y - a_z} e^{-a_z t}\n$$\n使用初始条件 $y(0)=0$：\n$$\n0 = A + \\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} + \\frac{K_z}{a_y - a_z} \\implies A = -\\left(\\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} + \\frac{K_z}{a_y - a_z}\\right)\n$$\n将 $A$ 代回并整理各项：\n$$\ny(t) = \\frac{K_0}{a_y}(1 - e^{-a_y t}) + \\frac{K_x}{a_y - a_x}(e^{-a_x t} - e^{-a_y t}) + \\frac{K_z}{a_y - a_z}(e^{-a_z t} - e^{-a_y t})\n$$\n最后，代回 $K_0$、$K_x$ 和 $K_z$ 的表达式：\n$$\ny(t) = \\frac{U}{a_y}\\left(\\frac{k_x b_x}{a_x} + s\\frac{k_z b_z}{a_z}\\right)(1-e^{-a_y t}) - \\frac{U k_x b_x}{a_x(a_y-a_x)}(e^{-a_x t} - e^{-a_y t}) - \\frac{s U k_z b_z}{a_z(a_y-a_z)}(e^{-a_z t} - e^{-a_y t})\n$$\n这就是在衰减率互不相同的假设下，$y(t)$ 的闭式表达式。\n\n**2. 系统行为的定量测试**\n\n**步骤2.1：稳态和适应性**\n稳态值 $y_\\infty$ 是通过取 $y(t)$ 在 $t \\to \\infty$ 时的极限得到的。由于所有速率常数 $a_i$ 均为正数，所有指数项 $e^{-a_i t}$ 都趋近于 $0$。\n$$\ny_\\infty = \\lim_{t\\to\\infty} y(t) = \\frac{U}{a_y}\\left(\\frac{k_x b_x}{a_x} + s\\frac{k_z b_z}{a_z}\\right) = U\\left(\\frac{k_x b_x}{a_x a_y} + s\\frac{k_z b_z}{a_z a_y}\\right)\n$$\n如果 $|y_\\infty - y(0)| \\le \\varepsilon$，系统表现出适应性。由于 $y(0)=0$，这简化为 $|y_\\infty| \\le \\varepsilon$，其中 $\\varepsilon = 10^{-8}$。对于 I1-FFL ($s=-1$)，如果 $\\frac{k_x b_x}{a_x} = \\frac{k_z b_z}{a_z}$，则会发生完全适应（$y_\\infty=0$）。\n\n**步骤2.2：峰值和脉冲状响应**\n峰值为 $y_{\\max} = \\max_{t\\ge 0} y(t)$。要找到峰值时间 $t_{\\text{peak}}$，需要求解 $\\frac{dy}{dt}=0$，这会得到一个通常无法解析求解的超越方程。因此，$y_{\\max}$ 必须通过在足够密集的时间网格上评估 $y(t)$ 来进行数值确定。\n\n响应根据以下条件被定义为脉冲状：\n- 如果系统具有适应性（$|y_\\infty| \\le \\varepsilon$），当 $y_{\\max} \\ge A_{\\min}$ (其中 $A_{\\min} = 10^{-4}$) 时，它是脉冲状的。\n- 如果系统不具有适应性，当它表现出显著的超调，定义为 $y_{\\max} / \\max\\{|y_\\infty|, \\delta\\} \\ge R$ (其中 $R=1.2$，$\\delta=10^{-12}$ 用于防止除以零) 时，它是脉冲状的。\n\n**3. 实现策略**\n\n程序将实现推导出的 $y(t)$ 的解析解。对于每个参数集：\n1.  使用其解析公式计算 $y_\\infty$ 以测试适应性。\n2.  生成一个从 $t=0$ 到 $t=T=50$ 的离散时间向量，使用小步长以精确捕捉瞬态。\n3.  使用推导的闭式解计算向量 $y(t)$。\n4.  通过取计算出的 $y(t)$ 向量的最大值来找到 $y_{\\max}$。\n5.  应用由两部分组成的逻辑测试来确定响应是否为脉冲状。\n6.  为每个案例存储两个结果布尔值（适应性，脉冲状），并按规定格式化最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the response of FFL circuits and classifies their behavior.\n    \"\"\"\n    # Define constants from the problem statement\n    EPSILON = 1e-8\n    A_MIN = 1e-4\n    R = 1.2\n    DELTA = 1e-12\n    T_FINAL = 50.0\n    N_POINTS = 10001  # Use a fine grid to accurately find the peak\n\n    # Define the test cases as a list of tuples.\n    # Each tuple: (s, ax, ay, az, bx, bz, kx, kz, U)\n    test_cases = [\n        # Case 1 (I1-FFL with perfect adaptation)\n        (-1, 1.0, 0.5, 0.2, 1.0, 1.0, 1.0, 0.2, 1.0),\n        # Case 2 (C1-FFL, no adaptation)\n        (1, 1.0, 0.5, 0.2, 1.0, 1.0, 1.0, 0.2, 1.0),\n        # Case 3 (I1-FFL with partial adaptation and overshoot)\n        (-1, 1.0, 0.5, 0.2, 1.0, 1.0, 1.0, 0.1, 1.0),\n        # Case 4 (C1-FFL with disparate timescales)\n        (1, 0.1, 0.5, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0),\n        # Case 5 (I1-FFL near-timescale match, slight mismatch in gains)\n        (-1, 0.5, 0.3, 0.51, 1.0, 1.0, 1.0, 0.95, 1.0),\n    ]\n\n    results = []\n\n    # Time vector for evaluating the transient response\n    t = np.linspace(0, T_FINAL, N_POINTS)\n\n    for case in test_cases:\n        s, ax, ay, az, bx, bz, kx, kz, U = case\n        \n        # --- Task 2: Quantitative Tests ---\n        \n        # Calculate steady-state value y_inf\n        x_inf = bx*U/ax\n        z_inf = bz*U/az\n        y_inf = (kx * x_inf + s * kz * z_inf) / ay\n\n        # Perform adaptation test\n        adapts = abs(y_inf) = EPSILON\n\n        # --- Task 1: Closed-form solution for y(t) ---\n        # The analytical solution for y(t) assuming distinct decay rates.\n        # This holds for all given test cases.\n\n        # Term related to the constant part of the forcing function\n        term1_const = (U / ay) * ((kx * bx / ax) + s * (kz * bz / az))\n        term1 = term1_const * (1 - np.exp(-ay * t))\n        \n        # Term related to the exponential from x(t)'s dynamics\n        term2_const = U * kx * bx / (ax * (ay - ax))\n        term2 = term2_const * (np.exp(-ax * t) - np.exp(-ay * t))\n        \n        # Term related to the exponential from z(t)'s dynamics\n        term3_const = s * U * kz * bz / (az * (ay - az))\n        term3 = term3_const * (np.exp(-az * t) - np.exp(-ay * t))\n        \n        y_t = term1 - term2 - term3\n        \n        # Find the peak value y_max\n        # Per problem, y_max is the algebraic maximum of y(t) for t>=0.\n        y_max = np.max(y_t)\n        \n        # Perform pulse-like test\n        is_pulse_like = False\n        if adapts:\n            if y_max >= A_MIN:\n                is_pulse_like = True\n        else:  # Does not adapt\n            denominator = max(abs(y_inf), DELTA)\n            if y_max / denominator >= R:\n                is_pulse_like = True\n                \n        results.append(adapts)\n        results.append(is_pulse_like)\n\n    # Final print statement in the exact required format\n    # The map(str,...) converts Python's True/False to \"True\"/\"False\" string literals.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3336287"}, {"introduction": "正反馈是生物系统中产生开关行为和细胞记忆的基石，它能将渐变的模拟信号转化为明确的全或无数字响应。本练习将指导你构建一个经典的自激活激酶模型，该模型结合了正反馈和饱和降解过程，这是实现双稳态（bistability）的核心机制。你将运用分岔分析这一强大的数学工具，通过求解系统的稳态和临界条件，精确地定位参数空间中导致系统在单稳态和双稳态之间切换的鞍结分岔点（saddle-node bifurcation points）。这项实践将使你从简单的动态模拟提升到对系统行为相变的深刻理解 [@problem_id:3336283]。", "problem": "您的任务是为一个具有饱和去磷酸化作用的自激活激酶建立一个最小化的、有原则的模型，然后执行分岔分析以定位参数空间中的鞍节点。该情景必须纯粹以建立在已确立的生物物理动力学基础上的数学术语来构建。从基本的生物化学动力学原理出发，您将推导出一个关于活性激酶浓度的一维常微分方程（ODE），并利用它通过求解定义的数学条件来检测鞍节点分岔。最终交付物是一个完整的、可运行的程序。\n\n使用的基本原理：\n- 质量作用动力学：当一个活性激酶物种催化一个非活性激酶向其活性形式转化时，其速率与反应物浓度的乘积成正比。如果总激酶池是守恒的，则可以使用可用的非活性部分来模拟激活过程。\n- 酶催化去磷酸化的米氏动力学：一个依赖于活性激酶浓度的饱和去磷酸化速率。\n\n建模设置：\n- 令 $x$ 表示活性激酶物种的浓度，令 $T$ 表示守恒的总激酶浓度，因此非活性池为 $T - x$。\n- 激活由一个基础组分和一个自激活组分组成。基础激活速率与非活性池成正比，常数为 $k_b$；自激活速率与活性和非活性池的乘积成正比，常数为 $k_a$。\n- 去磷酸化由磷酸酶催化，遵循米氏动力学，最大速率为 $V_{\\max}$，米氏常数为 $K_M$。\n\n任务：\n1. 从第一性原理出发，推导出形如 $\\dfrac{dx}{dt} = f(x; k_b, k_a, V_{\\max}, K_M, T)$ 的ODE，该方程需捕捉在上述假设下的基础激活、自激活和饱和去磷酸化过程。\n2. 对于一维系统 $\\dfrac{dx}{dt} = f(x;\\theta)$，其中标量控制参数嵌入在 $\\theta$（参数向量）中，将其数学鞍节点分岔条件表述为稳态和相切条件的联立解：\n   - 稳态：$f(x;\\theta) = 0$。\n   - 相切（折叠）条件：$\\dfrac{\\partial f}{\\partial x}(x;\\theta) = 0$。\n   - 非简并条件：$\\dfrac{\\partial^2 f}{\\partial x^2}(x;\\theta) \\neq 0$。\n   您将把基础激活常数 $k_b$ 作为控制参数，并为每个测试用例固定其余参数。\n3. 实现一个数值程序，对于每个参数集，通过联立求解 $f(x; k_b, k_a, V_{\\max}, K_M, T) = 0$ 和 $\\dfrac{\\partial f}{\\partial x}(x; k_b, k_a, V_{\\max}, K_M, T) = 0$ 来定位所有鞍节点，求解 $x$ 和 $k_b$，并满足约束条件 $0  x  T$ 和 $k_b > 0$，同时验证非简并条件 $\\dfrac{\\partial^2 f}{\\partial x^2} \\neq 0$。报告发生鞍节点分岔时对应的 $k_b$ 值。\n4. 您的程序必须稳健地实现该数值算法，无需任何用户输入，并完全按照规定格式生成最终输出。对于每个参数集，将检测到的 $k_b$ 值按升序排序。\n\n物理和数值细节：\n- 在此问题中，所有量都是无量纲的；您必须将 $x$、$T$、$k_b$、$k_a$、$V_{\\max}$ 和 $K_M$ 视为无量纲数。\n- 不涉及角度；您不得引入任何角度单位。\n- 将每个鞍节点 $k_b$ 值的列表报告为浮点数。\n\n测试套件：\n使用以下参数集来测试不同的机制。每个测试用例是一个元组 $(k_a, V_{\\max}, K_M, T)$；将 $k_b$ 视为由鞍节点条件决定的控制参数。\n- 测试 $1$：$(k_a = 5.0, V_{\\max} = 1.0, K_M = 0.1, T = 1.0)$。\n- 测试 $2$：$(k_a = 1.0, V_{\\max} = 1.0, K_M = 0.1, T = 1.0)$。\n- 测试 $3$：$(k_a = 5.0, V_{\\max} = 5.0, K_M = 0.1, T = 1.0)$。\n- 测试 $4$：$(k_a = 5.0, V_{\\max} = 1.0, K_M = 1.0, T = 1.0)$。\n- 测试 $5$：$(k_a = 3.0, V_{\\max} = 1.0, K_M = 0.2, T = 2.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，本身也是一个用方括号括起来的逗号分隔列表，其中包含发生鞍节点分岔的浮点 $k_b$ 值，按升序排列。例如，如果前两个测试分别产生两个和零个鞍节点，其余每个测试产生一个点，那么一个有效的输出将类似于 $[[k_{b,1},k_{b,2}],[],[k_{b,3}],[k_{b,4}],[k_{b,5}]]$，其中没有任何空格。", "solution": "用户要求对一个自激活激酶模型进行分岔分析。这需要推导其控制常微分方程（ODE），然后构建并求解鞍节点分岔的条件。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   **模型：** 具有饱和去磷酸化作用的自激活激酶。\n-   **变量：**\n    -   $x$: 活性激酶的浓度。\n    -   $T$: 守恒的总激酶浓度。\n-   **动力学和速率：**\n    -   基础激活：速率为 $k_b (T - x)$，其中 $k_b$ 是速率常数。\n    -   自激活：速率为 $k_a x (T - x)$，其中 $k_a$ 是速率常数。\n    -   去磷酸化：遵循米氏动力学，速率为 $V_{\\max} \\frac{x}{K_M + x}$，其中 $V_{\\max}$ 是最大速率，$K_M$ 是米氏常数。\n-   **ODE 形式：** $\\dfrac{dx}{dt} = f(x; k_b, k_a, V_{\\max}, K_M, T)$。\n-   **分岔条件（鞍节点）：**\n    1.  稳态：$f(x; \\theta) = 0$。\n    2.  相切：$\\dfrac{\\partial f}{\\partial x}(x; \\theta) = 0$。\n    3.  非简并性：$\\dfrac{\\partial^2 f}{\\partial x^2}(x; \\theta) \\neq 0$。\n-   **控制参数：** $k_b$。\n-   **约束条件：** $0  x  T$ 且 $k_b > 0$。\n-   **测试套件：** 提供了五组关于 $(k_a, V_{\\max}, K_M, T)$ 的参数集。\n-   **输出：** 一个列表的列表，其中每个内部列表包含对应测试用例发生分岔时的 $k_b$ 值，这些值已排序且为浮点数。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地建立在已确立的生物化学动力学之上。用于激活的质量作用动力学和用于酶促去磷酸化的米氏动力学是系统生物学中的标准模型。正反馈（自激活）与饱和去除过程的结合是已知的可产生双稳态和滞后现象的经典基序，而鞍节点分岔是其边界。该模型在科学上是合理的。\n-   **适定性：** 该问题是适定的。它要求解一个具体且明确定义的代数方程组，该方程组由两个变量（$x$ 和 $k_b$）和两个方程组成，源自标准的动力系统理论（分岔分析）。约束条件具有物理意义，有助于定义一组唯一的解。\n-   **客观性：** 问题陈述精确、定量，没有任何主观或模棱两可的语言。\n\n**步骤3：结论与行动**\n该问题有效。它在科学上合理，数学上适定，且陈述客观。我将继续推导并实现解决方案。\n\n### 分步求解\n\n**1. 控制ODE的推导**\n\n活性激酶浓度的变化率 $\\dfrac{dx}{dt}$ 是激活和去磷酸化过程的净结果。\n\n-   **激活速率：** 总激活速率是基础激活速率和自激活速率之和：\n    $$ \\text{Rate}_{\\text{activation}} = k_b (T - x) + k_a x (T - x) = (k_b + k_a x)(T - x) $$\n-   **去磷酸化速率：** 失活速率遵循米氏动力学：\n    $$ \\text{Rate}_{\\text{dephos}} = V_{\\max} \\dfrac{x}{K_M + x} $$\n-   **完整ODE：** 结合这些项得到函数 $f(x)$：\n    $$ \\dfrac{dx}{dt} = f(x; k_b, k_a, V_{\\max}, K_M, T) = (k_b + k_a x)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} $$\n\n**2. 鞍节点分岔条件**\n\n当一对不动点（一个稳定，一个不稳定）随着参数的变化而出现或消失时，就会发生鞍节点分岔。这对应于函数 $f(x)$ 与x轴相切。数学条件如下：\n\n-   **稳态：** $f(x) = 0$\n    $$ (k_b + k_a x)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} = 0 \\quad (1) $$\n-   **相切条件：** $\\dfrac{\\partial f}{\\partial x} = 0$。首先，我们计算导数：\n    $$ \\dfrac{\\partial f}{\\partial x} = \\dfrac{\\partial}{\\partial x} \\left[ (k_b + k_a x)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} \\right] $$\n    $$ \\dfrac{\\partial f}{\\partial x} = [k_a(T-x) + (k_b+k_a x)(-1)] - V_{\\max} \\dfrac{(1)(K_M + x) - x(1)}{(K_M + x)^2} $$\n    $$ \\dfrac{\\partial f}{\\partial x} = k_a T - k_a x - k_b - k_a x - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} $$\n    $$ \\dfrac{\\partial f}{\\partial x} = k_a(T - 2x) - k_b - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} $$\n    将其设为零得到第二个条件：\n    $$ k_a(T - 2x) - k_b - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} = 0 \\quad (2) $$\n-   **非简并条件：** $\\dfrac{\\partial^2 f}{\\partial x^2} \\neq 0$。我们计算二阶导数：\n    $$ \\dfrac{\\partial^2 f}{\\partial x^2} = \\dfrac{\\partial}{\\partial x} \\left[ k_a(T - 2x) - k_b - V_{\\max} K_M (K_M + x)^{-2} \\right] $$\n    $$ \\dfrac{\\partial^2 f}{\\partial x^2} = -2k_a - V_{\\max} K_M (-2)(K_M + x)^{-3} = -2k_a + \\dfrac{2 V_{\\max} K_M}{(K_M + x)^3} $$\n    在解点 $(x, k_b)$ 处，此表达式必须非零。\n\n**3. 解析简化与数值策略**\n\n我们有一个包含两个未知数 $x$ 和 $k_b$ 的方程组，即方程 $(1)$ 和 $(2)$。为了求解，我们可以首先从方程 $(2)$ 中用 $x$ 表示 $k_b$：\n$$ k_b = k_a(T - 2x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} \\quad (*) $$\n接下来，我们将这个 $k_b$ 的表达式代入方程 $(1)$。项 $(k_b + k_a x)$ 变为：\n$$ k_b + k_a x = \\left( k_a(T - 2x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} \\right) + k_a x = k_a(T - x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} $$\n将此代回方程 $(1)$：\n$$ \\left( k_a(T - x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} \\right)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} = 0 $$\n为消去分母，我们将整个方程乘以 $(K_M+x)^2$：\n$$ (k_a(T - x)(K_M+x)^2 - V_{\\max}K_M)(T-x) - V_{\\max} x(K_M+x) = 0 $$\n展开并整理各项，我们得到一个关于 $x$ 的单多项式方程，记为 $h(x) = 0$：\n$$ h(x) = k_a(T - x)^2 (K_M + x)^2 - V_{\\max} K_M (T - x) - V_{\\max} x (K_M + x) = 0 $$\n简化乘以 $V_{\\max}$ 的项：\n$$ -V_{\\max} [K_M (T - x) + x (K_M + x)] = -V_{\\max} [K_M T - K_M x + K_M x + x^2] = -V_{\\max}(x^2 + K_M T) $$\n因此，需要求解的关于 $x$ 的方程是：\n$$ h(x) = k_a(T - x)^2 (K_M + x)^2 - V_{\\max}(x^2 + K_M T) = 0 $$\n这是一个关于 $x$ 的四次多项式。数值求解其根是一种稳健的方法。一个可靠的方法是，首先通过找到 $h(x)$ 的临界点（即 $h'(x)=0$ 的根）来定位包含根的区间，然后在这些区间内使用一个像 Brent 方法这样的区间法求根器。\n\n**4. 数值算法**\n\n对于每个参数集 $(k_a, V_{\\max}, K_M, T)$：\n1.  定义四次多项式函数 $h(x)$。\n2.  定义其导数 $h'(x)$，这是一个三次多项式。\n3.  找到 $h'(x)=0$ 在有效范围 $(0, T)$ 内的实根。这些是 $h(x)$ 的临界点。\n4.  使用这些临界点以及 $0$ 和 $T$ 来定义一组搜索区间。对于每个区间 $(a, b)$，检查 $h(a)$ 和 $h(b)$ 是否异号。如果是，则存在一个根。\n5.  对于每个保证包含根的区间，使用数值求解器（例如，带有 `brentq` 方法的 `scipy.optimize.root_scalar`）来找到根 $x^*$。\n6.  对于找到的每个根 $x^*$：\n    a. 使用方程 $(*)$ 计算相应的 $k_b^*$。\n    b. 验证 $k_b^*  0$。\n    c. 验证非简并条件：$\\dfrac{\\partial^2 f}{\\partial x^2}(x^*) \\neq 0$。\n    d. 如果所有条件都满足，则值 $k_b^*$ 对应一个鞍节点分岔。\n7.  收集该参数集的所有有效 $k_b^*$ 值，去除重复项，并按升序排序。\n8.  对所有测试用例重复此过程，并按规定格式化最终输出。\n\n该过程将在提供的 Python 环境中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Analyzes a model of a self-activating kinase to find saddle-node bifurcations.\n\n    The model is described by the ODE:\n    dx/dt = (k_b + k_a*x)*(T - x) - V_max*x / (K_M + x)\n\n    Saddle-node bifurcations occur where f(x) = 0 and df/dx = 0 simultaneously.\n    This leads to a quartic polynomial equation h(x) = 0 for the state variable x at the bifurcation point.\n    h(x) = k_a*(T - x)^2*(K_M + x)^2 - V_max*(x^2 + K_M*T)\n\n    The algorithm finds roots of h(x) in (0, T), then calculates the corresponding\n    bifurcation parameter k_b and validates the solution.\n    \"\"\"\n    test_cases = [\n        # (k_a, V_max, K_M, T)\n        (5.0, 1.0, 0.1, 1.0),\n        (1.0, 1.0, 0.1, 1.0),\n        (5.0, 5.0, 0.1, 1.0),\n        (5.0, 1.0, 1.0, 1.0),\n        (3.0, 1.0, 0.2, 2.0),\n    ]\n\n    final_results = []\n    tol = 1e-9  # Tolerance for floating point comparisons\n\n    for params in test_cases:\n        ka, vmax, km, T = params\n\n        # Define the quartic polynomial h(x) whose roots give the x-coordinate of the saddle-node.\n        def h(x, ka_p, vmax_p, km_p, T_p):\n            term1 = ka_p * ((T_p - x)**2) * ((km_p + x)**2)\n            term2 = vmax_p * (x**2 + km_p * T_p)\n            return term1 - term2\n\n        # To robustly find roots of h(x), we first find its critical points by solving h'(x)=0.\n        # h(x) = A*x^4 + B*x^3 + C*x^2 + D*x + E\n        # Coefficients of the polynomial h(x):\n        A = ka\n        B = 2 * ka * (km - T)\n        C = ka * (T**2 - 4 * T * km + km**2) - vmax\n        D = 2 * ka * T * km * (T - km)\n        \n        # h'(x) is a cubic: 4*A*x^3 + 3*B*x^2 + 2*C*x + D = 0\n        h_prime_coeffs = [4 * A, 3 * B, 2 * C, D]\n        critical_points_all = np.roots(h_prime_coeffs)\n\n        # Filter for real critical points within the physical interval (0, T)\n        real_crit_pts = [cp.real for cp in critical_points_all if np.isclose(cp.imag, 0)]\n        crit_pts_in_interval = sorted([p for p in real_crit_pts if tol  p  T - tol])\n\n        # Define search intervals for roots of h(x) based on its critical points.\n        boundaries = [0] + crit_pts_in_interval + [T]\n        \n        potential_x_saddles = []\n        for i in range(len(boundaries) - 1):\n            a, b = boundaries[i], boundaries[i + 1]\n            # Use a slightly smaller bracket to avoid issues at the boundaries.\n            a_eff, b_eff = a + tol, b - tol\n            if a_eff >= b_eff:\n                continue\n\n            try:\n                # Check for a sign change, which indicates a root is present.\n                if np.sign(h(a_eff, ka, vmax, km, T)) != np.sign(h(b_eff, ka, vmax, km, T)):\n                    sol = root_scalar(h, args=(ka, vmax, km, T), bracket=[a_eff, b_eff], method='brentq')\n                    potential_x_saddles.append(sol.root)\n            except ValueError:\n                # This can occur if signs are the same; just ignore.\n                pass\n        \n        saddle_node_kbs = set()\n        for x_star in potential_x_saddles:\n            # For each potential x, calculate the corresponding k_b.\n            # k_b = k_a*(T - 2x) - V_max*K_M / (K_M + x)^2\n            kb_star = ka * (T - 2 * x_star) - (vmax * km) / ((km + x_star)**2)\n\n            # Validate the solution: k_b must be positive.\n            if kb_star = tol:\n                continue\n            \n            # Validate the non-degeneracy condition: d2f/dx2 != 0.\n            # d2f/dx2 = -2*k_a + 2*V_max*K_M / (K_M + x)^3\n            d2f_dx2 = -2 * ka + (2 * vmax * km) / ((km + x_star)**3)\n            if abs(d2f_dx2) = tol:\n                continue\n                \n            saddle_node_kbs.add(kb_star)\n\n        final_results.append(sorted(list(saddle_node_kbs)))\n\n    # Format the final output string precisely as specified.\n    formatted_sublists = []\n    for sublist in final_results:\n        s = ','.join(map(str, sublist))\n        formatted_sublists.append(f'[{s}]')\n    \n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```", "id": "3336283"}, {"introduction": "在系统生物学研究中，我们常常面对“逆向问题”：即根据实验观测数据推断其背后的分子网络结构。这个实践模拟了这一核心挑战，要求你扮演一名计算生物学家的角色，运用贝叶斯模型选择（Bayesian model selection）来判断一组扰动实验数据更支持前馈环还是反馈环结构。你将学习如何计算每个模型的边际似然（marginal likelihood），并结合先验知识来量化我们对每个假设架构的信心。这项练习不仅能让你掌握一种强大的统计推断方法，还能让你体验从“结构决定功能”到“功能反推结构”的思维转变 [@problem_id:3336284]。", "problem": "给定一个计算系统生物学中的简化反问题，您需要使用贝叶斯模型选择，从部分扰动数据中推断出主导的信号传导结构基序。考虑一个包含节点 $A$、$B$ 和 $C$ 的三节点信号传导模块的小信号、稳态线性化模型。假设存在两种备选的结构基序：一种是前馈环 (FFL)，其中 $A$ 调控 $C$ 但没有从 $C$ 到 $A$ 的反馈；另一种是反馈环 (FBK)，其中 $C$ 反馈至 $A$ 但没有直接的 $A \\to C$ 连边。您进行了三次独立的、小振幅的扰动实验，并测量了以下响应子集：\n- 实验 $u_1$：激活 $A$；观察 $C$ 的变化。\n- 实验 $u_2$：抑制 $B$；观察 $C$ 的变化。\n- 实验 $u_3$：激活 $C$；观察 $A$ 的变化。\n\n假设在稳态下有一个局部线性响应模型。对于每种结构 $M \\in \\{\\mathrm{FFL}, \\mathrm{FBK}\\}$，数据向量 $y \\in \\mathbb{R}^3$（堆叠为 $[\\Delta C|u_1,\\ \\Delta C|u_2,\\ \\Delta A|u_3]^\\top$）被建模为 $y = X_M w_M + \\varepsilon$，其中 $w_M$ 是一个未知的线性灵敏度参数向量，$\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_3)$ 是方差为 $\\sigma^2$ 的加性高斯噪声，$I_3$ 是单位矩阵。设计矩阵编码了每种结构下哪些灵敏度是允许的：\n- 对于前馈环 (FFL)，由于缺少从 $C$ 到 $A$ 的反馈，意味着不存在从 $u_3$ 到 $\\Delta A$ 的线性路径，因此得到一个 $3 \\times 2$ 的设计矩阵\n$$\nX_{\\mathrm{FFL}} \\;=\\; \\begin{bmatrix}\n1  0\\\\\n0  1\\\\\n0  0\n\\end{bmatrix}.\n$$\n- 对于反馈环 (FBK)，直接的 $C \\to A$ 反馈允许 $u_3$ 影响 $\\Delta A$，因此得到一个 $3 \\times 3$ 的设计矩阵\n$$\nX_{\\mathrm{FBK}} \\;=\\; I_3 \\;=\\; \\begin{bmatrix}\n1  0  0\\\\\n0  1  0\\\\\n0  0  1\n\\end{bmatrix}.\n$$\n\n假设每种结构的线性灵敏度服从共轭高斯先验分布 $w_M \\sim \\mathcal{N}(0, \\tau^2 I_{d_M})$，其中 $d_{\\mathrm{FFL}} = 2$，$d_{\\mathrm{FBK}} = 3$。结构本身服从伯努利先验分布，$\\mathbb{P}(M=\\mathrm{FFL}) = \\pi$ 且 $\\mathbb{P}(M=\\mathrm{FBK}) = 1 - \\pi$。所有量均为无量纲的。\n\n您的任务是，通过应用贝叶斯模型选择，并使用对 $w_M$ 进行积分（边际化）得到的边缘似然，为每个测试用例计算后验概率 $\\mathbb{P}(\\mathrm{FFL} \\mid y)$。请从以下基础原理出发：用于模型选择的贝叶斯法则、多元高斯恒等式以及线性高斯共轭性。除这些基础原理外，不要假设任何预先推导的简化公式。\n\n测试套件。对于下方的每个测试用例，请使用给定的观测向量 $y$、噪声标准差 $\\sigma$、灵敏度先验标准差 $\\tau$ 和结构先验 $\\pi$。所有数值均为无量纲的。\n- 测试 1：$y = [\\,1.2,\\ -0.9,\\ 0.02\\,]$，$\\sigma = 0.1$，$\\tau = 1.0$，$\\pi = 0.5$。\n- 测试 2：$y = [\\,0.8,\\ 0.7,\\ 0.9\\,]$，$\\sigma = 0.1$，$\\tau = 1.0$，$\\pi = 0.5$。\n- 测试 3：$y = [\\,0.5,\\ -0.4,\\ 0.3\\,]$，$\\sigma = 1.0$，$\\tau = 1.0$，$\\pi = 0.5$。\n- 测试 4：$y = [\\,0.5,\\ -0.4,\\ 0.3\\,]$，$\\sigma = 0.2$，$\\tau = 1.0$，$\\pi = 0.8$。\n\n程序要求。\n- 输入：不读取任何输入；测试套件已嵌入程序中。\n- 计算：对于每个测试用例，使用上述线性高斯模型，通过贝叶斯模型选择计算后验概率 $\\mathbb{P}(\\mathrm{FFL} \\mid y)$，其中 $w_M$ 在高斯先验下被积分掉。\n- 输出：您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的浮点数列表，四舍五入到六位小数，并用方括号括起来，顺序与上述测试用例一致（例如，$[x_1,x_2,x_3,x_4]$）。", "solution": "用户提供的问题是有效的。这是一个计算系统生物学中适定的、有科学依据的问题，需要将贝叶斯模型选择应用于一个线性高斯系统。所有必要的数据和模型定义都已提供，不存在内部矛盾、歧义或事实错误。\n\n解决方案首先从基本原理出发，为两个提出的模型（FFL 和 FBK）推导边缘似然，然后利用这些似然在贝叶斯法则框架内计算 FFL 模型在每个给定测试用例下的后验概率。\n\n目标是计算在给定观测向量 $y$ 的条件下，前馈环 (FFL) 模型的后验概率，记为 $\\mathbb{P}(\\mathrm{FFL} \\mid y)$。根据用于模型选择的贝叶斯法则，其表达式为：\n$$\n\\mathbb{P}(\\mathrm{FFL} \\mid y) = \\frac{\\mathbb{P}(y \\mid \\mathrm{FFL}) \\mathbb{P}(\\mathrm{FFL})}{\\mathbb{P}(y)}\n$$\n其中 $\\mathbb{P}(y \\mid \\mathrm{FFL})$ 是 FFL 模型的边缘似然（或证据），$\\mathbb{P}(\\mathrm{FFL})$ 是 FFL 模型的先验概率，$\\mathbb{P}(y)$ 是数据的总证据，用作归一化常数。总证据是所有考虑的模型的证据按其先验加权之和：\n$$\n\\mathbb{P}(y) = \\mathbb{P}(y \\mid \\mathrm{FFL}) \\mathbb{P}(\\mathrm{FFL}) + \\mathbb{P}(y \\mid \\mathrm{FBK}) \\mathbb{P}(\\mathrm{FBK})\n$$\n问题陈述了 $\\mathbb{P}(\\mathrm{FFL}) = \\pi$ 且 $\\mathbb{P}(\\mathrm{FBK}) = 1 - \\pi$。将这些代入后验概率的表达式，得到：\n$$\n\\mathbb{P}(\\mathrm{FFL} \\mid y) = \\frac{\\mathbb{P}(y \\mid \\mathrm{FFL}) \\pi}{\\mathbb{P}(y \\mid \\mathrm{FFL}) \\pi + \\mathbb{P}(y \\mid \\mathrm{FBK}) (1 - \\pi)}\n$$\n核心任务是为每个模型 $M \\in \\{\\mathrm{FFL}, \\mathrm{FBK}\\}$ 计算边缘似然 $\\mathbb{P}(y \\mid M)$。边缘似然是通过对未知参数向量 $w_M$ 在其先验分布上进行积分得到的：\n$$\n\\mathbb{P}(y \\mid M) = \\int \\mathbb{P}(y \\mid w_M, M) \\mathbb{P}(w_M \\mid M) \\, dw_M\n$$\n我们给定的是一个线性高斯框架：\n- 似然为 $\\mathbb{P}(y \\mid w_M, M) = \\mathcal{N}(y; X_M w_M, \\sigma^2 I_3)$，这是一个关于 $y$ 的多元高斯分布，其均值为 $X_M w_M$，协方差为 $\\sigma^2 I_3$。\n- 先验为 $\\mathbb{P}(w_M \\mid M) = \\mathcal{N}(w_M; 0, \\tau^2 I_{d_M})$，这是一个关于 $w_M$ 的多元高斯分布，其均值为 $0$，协方差为 $\\tau^2 I_{d_M}$。\n\n对于这样一个共轭线性高斯系统，$y$ 的边缘分布也是高斯分布。我们可以推导其参数而无需显式地执行积分。将 $y$ 视为一个生成过程的结果：首先，从其先验分布中抽取 $w_M$，然后生成 $y = X_M w_M + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_3)$。$y$ 的均值为：\n$$\n\\mathbb{E}[y \\mid M] = \\mathbb{E}[X_M w_M + \\varepsilon] = X_M \\mathbb{E}[w_M] + \\mathbb{E}[\\varepsilon] = X_M \\cdot 0 + 0 = 0\n$$\n$y$ 的协方差（我们记为 $\\Sigma_M$）可使用全协方差定律求得。由于 $w_M$ 和 $\\varepsilon$ 是独立的：\n$$\n\\Sigma_M = \\mathrm{Cov}(y \\mid M) = \\mathrm{Cov}(X_M w_M + \\varepsilon) = \\mathrm{Cov}(X_M w_M) + \\mathrm{Cov}(\\varepsilon)\n$$\n变换后的变量 $X_M w_M$ 的协方差为 $X_M \\mathrm{Cov}(w_M) X_M^\\top = X_M (\\tau^2 I_{d_M}) X_M^\\top = \\tau^2 X_M X_M^\\top$。噪声的协方差为 $\\sigma^2 I_3$。因此，\n$$\n\\Sigma_M = \\tau^2 X_M X_M^\\top + \\sigma^2 I_3\n$$\n因此，边缘似然是在观测数据 $y$ 处求值的多元高斯分布 $\\mathcal{N}(0, \\Sigma_M)$ 的概率密度：\n$$\n\\mathbb{P}(y \\mid M) = \\frac{1}{\\sqrt{(2\\pi)^3 \\det(\\Sigma_M)}} \\exp\\left(-\\frac{1}{2} y^\\top \\Sigma_M^{-1} y\\right)\n$$\n现在，我们将此结果具体到每个模型。\n\n**1. 前馈环 (FFL) 模型**\n设计矩阵为 $X_{\\mathrm{FFL}} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\end{bmatrix}$。协方差矩阵 $\\Sigma_{\\mathrm{FFL}}$ 为：\n$$\nX_{\\mathrm{FFL}} X_{\\mathrm{FFL}}^\\top = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\end{bmatrix} \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\end{bmatrix} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{bmatrix}\n$$\n$$\n\\Sigma_{\\mathrm{FFL}} = \\tau^2 \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{bmatrix} + \\sigma^2 \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix} = \\begin{bmatrix} \\tau^2 + \\sigma^2  0  0 \\\\ 0  \\tau^2 + \\sigma^2  0 \\\\ 0  0  \\sigma^2 \\end{bmatrix}\n$$\n其行列式为 $\\det(\\Sigma_{\\mathrm{FFL}}) = (\\tau^2 + \\sigma^2)^2 \\sigma^2$。指数中的二次型为 $y^\\top \\Sigma_{\\mathrm{FFL}}^{-1} y = \\frac{y_1^2 + y_2^2}{\\tau^2 + \\sigma^2} + \\frac{y_3^2}{\\sigma^2}$。\n\n**2. 反馈环 (FBK) 模型**\n设计矩阵为 $X_{\\mathrm{FBK}} = I_3$。协方差矩阵 $\\Sigma_{\\mathrm{FBK}}$ 为：\n$$\nX_{\\mathrm{FBK}} X_{\\mathrm{FBK}}^\\top = I_3 I_3^\\top = I_3\n$$\n$$\n\\Sigma_{\\mathrm{FBK}} = \\tau^2 I_3 + \\sigma^2 I_3 = (\\tau^2 + \\sigma^2) I_3\n$$\n其行列式为 $\\det(\\Sigma_{\\mathrm{FBK}}) = (\\tau^2 + \\sigma^2)^3$。二次型为 $y^\\top \\Sigma_{\\mathrm{FBK}}^{-1} y = \\frac{y^\\top y}{\\tau^2 + \\sigma^2} = \\frac{y_1^2 + y_2^2 + y_3^2}{\\tau^2 + \\sigma^2}$。\n\n为避免数值下溢并简化计算，使用贝叶斯因子 $K = \\frac{\\mathbb{P}(y \\mid \\mathrm{FFL})}{\\mathbb{P}(y \\mid \\mathrm{FBK})}$ 会很方便。\n$$\nK = \\frac{\\frac{1}{\\sqrt{(2\\pi)^3 \\det(\\Sigma_{\\mathrm{FFL}})}} \\exp\\left(-\\frac{1}{2} y^\\top \\Sigma_{\\mathrm{FFL}}^{-1} y\\right)}{\\frac{1}{\\sqrt{(2\\pi)^3 \\det(\\Sigma_{\\mathrm{FBK}})}} \\exp\\left(-\\frac{1}{2} y^\\top \\Sigma_{\\mathrm{FBK}}^{-1} y\\right)} = \\sqrt{\\frac{\\det(\\Sigma_{\\mathrm{FBK}})}{\\det(\\Sigma_{\\mathrm{FFL}})}} \\exp\\left( -\\frac{1}{2} \\left( y^\\top \\Sigma_{\\mathrm{FFL}}^{-1} y - y^\\top \\Sigma_{\\mathrm{FBK}}^{-1} y \\right) \\right)\n$$\n代入行列式和二次型：\n$$\n\\sqrt{\\frac{(\\tau^2 + \\sigma^2)^3}{(\\tau^2 + \\sigma^2)^2 \\sigma^2}} = \\sqrt{\\frac{\\tau^2 + \\sigma^2}{\\sigma^2}} = \\sqrt{1 + \\frac{\\tau^2}{\\sigma^2}}\n$$\n$$\ny^\\top \\Sigma_{\\mathrm{FFL}}^{-1} y - y^\\top \\Sigma_{\\mathrm{FBK}}^{-1} y = \\left(\\frac{y_1^2 + y_2^2}{\\tau^2 + \\sigma^2} + \\frac{y_3^2}{\\sigma^2}\\right) - \\left(\\frac{y_1^2 + y_2^2 + y_3^2}{\\tau^2 + \\sigma^2}\\right) = \\frac{y_3^2}{\\sigma^2} - \\frac{y_3^2}{\\tau^2 + \\sigma^2} = y_3^2 \\frac{(\\tau^2 + \\sigma^2) - \\sigma^2}{\\sigma^2(\\tau^2 + \\sigma^2)} = \\frac{y_3^2 \\tau^2}{\\sigma^2(\\tau^2 + \\sigma^2)}\n$$\n合并这些项，得到贝叶斯因子：\n$$\nK = \\sqrt{1 + \\frac{\\tau^2}{\\sigma^2}} \\exp\\left( -\\frac{y_3^2 \\tau^2}{2\\sigma^2(\\tau^2 + \\sigma^2)} \\right)\n$$\n后验概率可以用贝叶斯因子和先验优势比 $\\frac{\\pi}{1-\\pi}$ 来表示：\n$$\n\\mathbb{P}(\\mathrm{FFL} \\mid y) = \\frac{K \\pi}{K \\pi + (1-\\pi)} = \\frac{K \\frac{\\pi}{1-\\pi}}{K \\frac{\\pi}{1-\\pi} + 1}\n$$\n这个最终表达式用于计算每个测试用例的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the posterior probability of a feedforward loop (FFL) model\n    for a series of test cases using Bayesian model selection.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    # Each tuple contains: (y_vector, sigma, tau, pi)\n    test_cases = [\n        (np.array([1.2, -0.9, 0.02]), 0.1, 1.0, 0.5),\n        (np.array([0.8, 0.7, 0.9]), 0.1, 1.0, 0.5),\n        (np.array([0.5, -0.4, 0.3]), 1.0, 1.0, 0.5),\n        (np.array([0.5, -0.4, 0.3]), 0.2, 1.0, 0.8),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        y, sigma, tau, pi = case\n        \n        # Extract the third component of the observation vector y.\n        # This component, the response of A to a perturbation on C, is\n        # the only one that differs in its treatment between the two models.\n        y3 = y[2]\n        \n        # Calculate squares of standard deviations for convenience.\n        sigma_sq = sigma**2\n        tau_sq = tau**2\n        \n        # Calculate the Bayes factor K = P(y|FFL) / P(y|FBK).\n        # This formula is derived in the solution description and avoids\n        # explicit calculation of the full likelihoods, which can have\n        # numerical stability issues.\n        \n        # The determinant ratio component of the Bayes factor\n        det_ratio_sqrt = np.sqrt(1.0 + tau_sq / sigma_sq)\n        \n        # The exponential component of the Bayes factor\n        exponent_term = - (y3**2 * tau_sq) / (2.0 * sigma_sq * (tau_sq + sigma_sq))\n        \n        bayes_factor = det_ratio_sqrt * np.exp(exponent_term)\n        \n        # Check for edge cases with prior probabilities.\n        if pi == 1.0:\n            posterior_prob_ffl = 1.0\n        elif pi == 0.0:\n            posterior_prob_ffl = 0.0\n        else:\n            # Calculate the prior odds for the FFL model.\n            prior_odds = pi / (1.0 - pi)\n            \n            # Calculate the posterior odds using the Bayes factor.\n            posterior_odds = bayes_factor * prior_odds\n            \n            # Convert posterior odds to posterior probability.\n            posterior_prob_ffl = posterior_odds / (1.0 + posterior_odds)\n            \n        results.append(posterior_prob_ffl)\n\n    # Format the final output as specified: a comma-separated list of\n    # floating-point numbers rounded to six decimal places, enclosed\n    # in square brackets.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3336284"}]}