{"hands_on_practices": [{"introduction": "本练习将我们的理解建立在基础物理化学之上。我们将应用德拜-休克尔理论，推导离子环境（生物系统中的一个关键因素）如何通过计算动力学参数的变化来调节受体-配体相互作用。该练习将活度等抽象的热力学概念与具体的、可测量的结合常数联系起来。[@problem_id:3344616]", "problem": "一个温度为 $298\\ \\mathrm{K}$ 的水溶液中的受体-配体体系，由可逆结合反应 $R + L \\rightleftharpoons RL$ 描述。在无限稀释条件下（用活度定义）的热力学标准结合常数为 $K_{a}^{0} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}$ (在 $298\\ \\mathrm{K}$ 时)。溶液中含有一种支持性的1:1型电解质，其离子强度为 $I = 0.010\\ \\mathrm{M}$，该强度足够低，可以适用 Debye–Hückel 极限法则。在所关注的 pH 范围内，受体、配体和复合物的净电荷分别为 $z_{R} = -3$，$z_{L} = +2$ 和 $z_{RL} = -1$。假设长程静电屏蔽是离子强度对非理想性的唯一影响，并且短程特定离子效应可以忽略不计。\n\n使用以下基本事实：\n- 溶质物种 $i$ 的化学势为 $\\mu_{i} = \\mu_{i}^{\\circ} + RT \\ln a_{i}$，其中 $a_{i} = \\gamma_{i} c_{i}$ 是活度，$\\gamma_{i}$ 是活度系数，$c_{i}$ 是摩尔浓度。\n- 在平衡时，各活度满足无限稀释条件下热力学结合常数 $K_{a}^{0}$ 的定义。\n- 对于低离子强度的 $z{:}z$ 型电解质，Debye–Hückel 极限法则给出 $\\log_{10} \\gamma_{i} = -A z_{i}^{2} \\sqrt{I}$，其中对于 $298\\ \\mathrm{K}$ 的水，$A = 0.509$，$I$ 是离子强度。\n\n结合速率（结合速率常数）是扩散限制的，并假定其不依赖于离子强度，其值为 $k_{\\mathrm{on}} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$。\n\n从化学势的定义和基于活度的平衡条件出发，推导离子强度如何以活度系数的形式修正基于浓度的结合常数（当 $I \\neq 0$ 时），然后计算在 $I = 0.010\\ \\mathrm{M}$ 时的解离速率常数 $k_{\\mathrm{off}}$。请用 $\\mathrm{s}^{-1}$ 作为单位表示最终答案，并四舍五入到三位有效数字。", "solution": "该问题是有效的，因为它科学地基于物理化学原理（溶液热力学和动力学），提法得当，提供了所有必要信息，并且其表述是客观的。\n\n可逆结合反应由 $R + L \\rightleftharpoons RL$ 给出。\n在化学平衡时，反应的吉布斯自由能变化为零。这转化为产物的化学势等于反应物化学势之和的条件：\n$$ \\mu_{RL} = \\mu_{R} + \\mu_{L} $$\n物种 $i$ 的化学势由 $\\mu_{i} = \\mu_{i}^{\\circ} + RT \\ln a_{i}$ 给出，其中 $\\mu_{i}^{\\circ}$ 是标准化学势，$R$ 是气体常数，$T$ 是绝对温度，$a_{i}$ 是该物种的活度。将此代入平衡条件：\n$$ \\mu_{RL}^{\\circ} + RT \\ln a_{RL} = (\\mu_{R}^{\\circ} + RT \\ln a_{R}) + (\\mu_{L}^{\\circ} + RT \\ln a_{L}) $$\n重新整理各项可得：\n$$ \\mu_{RL}^{\\circ} - \\mu_{R}^{\\circ} - \\mu_{L}^{\\circ} = RT (\\ln a_{R} + \\ln a_{L} - \\ln a_{RL}) $$\n左侧是标准结合吉布斯自由能变 $\\Delta G_{a}^{\\circ}$。该方程可以重写为：\n$$ \\Delta G_{a}^{\\circ} = -RT \\ln \\left( \\frac{a_{RL}}{a_{R} a_{L}} \\right) $$\n热力学标准结合常数 $K_{a}^{0}$ 由关系式 $\\Delta G_{a}^{\\circ} = -RT \\ln K_{a}^{0}$ 定义。因此，在平衡时，活度由以下关系式关联：\n$$ K_{a}^{0} = \\frac{a_{RL}}{a_{R} a_{L}} $$\n活度 $a_i$ 通过活度系数 $\\gamma_i$ 与摩尔浓度 $c_i$ 相关，即 $a_i = \\gamma_i c_i$。将此代入 $K_{a}^{0}$ 的表达式中：\n$$ K_{a}^{0} = \\frac{\\gamma_{RL} c_{RL}}{(\\gamma_{R} c_{R}) (\\gamma_{L} c_{L})} = \\left( \\frac{\\gamma_{RL}}{\\gamma_{R} \\gamma_{L}} \\right) \\left( \\frac{c_{RL}}{c_{R} c_{L}} \\right) $$\n在给定离子强度 $I$ 下，基于浓度的结合常数，记作 $K_{a}(I)$，定义为：\n$$ K_{a}(I) = \\frac{c_{RL}}{c_{R} c_{L}} $$\n因此，我们得到了热力学常数 $K_{a}^{0}$（在无限稀释条件下，此时所有 $\\gamma_i=1$）和在离子强度 $I$ 下基于浓度的常数 $K_{a}(I)$ 之间的关系：\n$$ K_{a}^{0} = K_{a}(I) \\left( \\frac{\\gamma_{RL}}{\\gamma_{R} \\gamma_{L}} \\right) $$\n这个表达式可以重新整理以显示离子强度如何修正基于浓度的结合常数，这是任务的第一部分：\n$$ K_{a}(I) = K_{a}^{0} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) $$\n活度系数 $\\gamma_i$ 使用 Debye–Hückel 极限法则计算，适用于 $T=298\\ \\mathrm{K}$ 的水溶液：\n$$ \\log_{10} \\gamma_{i} = -A z_{i}^{2} \\sqrt{I} $$\n其中 $A = 0.509$，$z_i$ 是物种 $i$ 的电荷，$I$ 是离子强度。\n为了找到 $K_{a}(I)$ 的校正因子，我们可以处理活度系数比值的对数：\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = \\log_{10} \\gamma_{R} + \\log_{10} \\gamma_{L} - \\log_{10} \\gamma_{RL} $$\n代入 Debye–Hückel 法则：\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = (-A z_{R}^{2} \\sqrt{I}) + (-A z_{L}^{2} \\sqrt{I}) - (-A z_{RL}^{2} \\sqrt{I}) $$\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = -A \\sqrt{I} (z_{R}^{2} + z_{L}^{2} - z_{RL}^{2}) $$\n问题给出的数值为：$z_{R} = -3$，$z_{L} = +2$，$z_{RL} = -1$，$I = 0.010\\ \\mathrm{M}$，以及 $A = 0.509$。\n首先，我们计算涉及电荷的项：\n$$ z_{R}^{2} + z_{L}^{2} - z_{RL}^{2} = (-3)^{2} + (+2)^{2} - (-1)^{2} = 9 + 4 - 1 = 12 $$\n现在我们计算该比值的对数：\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = -0.509 \\times \\sqrt{0.010} \\times 12 = -0.509 \\times 0.1 \\times 12 = -0.6108 $$\n所以，校正因子是 $10^{-0.6108}$。\n基于浓度的结合常数也是结合速率常数 $k_{\\mathrm{on}}$ 和解离速率常数 $k_{\\mathrm{off}}$ 的比值：\n$$ K_{a}(I) = \\frac{k_{\\mathrm{on}}(I)}{k_{\\mathrm{off}}(I)} $$\n问题陈述 $k_{\\mathrm{on}}$ 不依赖于离子强度，所以 $k_{\\mathrm{on}}(I) = k_{\\mathrm{on}} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$。\n我们需要求解在 $I=0.010\\ \\mathrm{M}$ 时的 $k_{\\mathrm{off}}$，我们将其记为 $k_{\\mathrm{off}}(I)$。\n$$ k_{\\mathrm{off}}(I) = \\frac{k_{\\mathrm{on}}}{K_{a}(I)} $$\n代入 $K_{a}(I)$ 的表达式：\n$$ k_{\\mathrm{off}}(I) = \\frac{k_{\\mathrm{on}}}{K_{a}^{0} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right)} $$\n给定 $K_{a}^{0} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}$。\n$$ k_{\\mathrm{off}}(I) = \\frac{1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}}{(1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}) \\times 10^{-0.6108}} $$\n$$ k_{\\mathrm{off}}(I) = \\frac{1}{10^{-0.6108}} \\ \\mathrm{s}^{-1} = 10^{0.6108}\\ \\mathrm{s}^{-1} $$\n现在，我们计算数值：\n$$ k_{\\mathrm{off}}(I) \\approx 4.08133 \\ \\mathrm{s}^{-1} $$\n四舍五入到三位有效数字，在 $I = 0.010\\ \\mathrm{M}$ 时的解离速率常数为 $4.08\\ \\mathrm{s}^{-1}$。\n电解质的存在屏蔽了带相反电荷的受体（$z_R = -3$）和配体（$z_L = +2$）之间的有利静电吸引。这种屏蔽作用使复合物不稳定，与无限稀释的情况相比，导致了更弱的结合（更低的 $K_a(I)$）和更快的解离（更高的 $k_{\\mathrm{off}}(I)$）。我们的结果与这个物理图像是一致的。", "answer": "$$\\boxed{4.08}$$", "id": "3344616"}, {"introduction": "超越简单的结合模型，本练习将使用经典的Monod-Wyman-Changeux (MWC)模型来解决变构与协同性这一至关重要的生物学现象。您将从统计力学原理出发，推导该模型的核心方程，并实施数值分析来计算希尔系数等关键可观测量。本练习旨在搭建理论模型与其计算实现之间的桥梁，以用于分析复杂系统。[@problem_id:3344587]", "problem": "一个受体-配体系统使用 Monod–Wyman–Changeux (MWC) 变构框架进行建模。该受体是一个寡聚体，具有 $N$ 个相同的配体结合位点，并可以存在于两种全局构象状态中：紧张态 $R_T$ 和松弛态 $R_R$。这两种状态可以相互转换，$R_T \\rightleftharpoons R_R$。变构常数 $L$ 定义为在配体浓度 $C = 0$ 时，未结合配体的状态浓度之比，$L = [R_T]/[R_R]$。在每种构象内部，$N$ 个结合位点是独立且等价的，其对于 $R_T$ 和 $R_R$ 构象的微观解离常数分别为 $K_{d,T}$ 和 $K_{d,R}$。令 $\\theta(C)$ 表示在配体浓度为 $C$ 时的分数占据率（即被占据位点的期望分数）。\n\n从质量作用定律和针对每种构象中独立结合的基本统计力学计数方法出发，推导出 MWC 假设所蕴含的函数依赖关系 $\\theta(C)$，过程中不使用任何预先推导的快捷公式。使用推导出的 $\\theta(C)$ 计算以下量：\n\n1. 由方程 $\\theta(C_{0.5}) = 0.5$ 定义的半饱和浓度 $C_{0.5}$。将 $C_{0.5}$ 以摩尔 (M) 为单位表示。\n\n2. 在半饱和时的 Hill 系数 $n_H$，其操作性定义为 Hill 图在 $\\theta = 0.5$ 处的斜率，\n$$\nn_H = \\left.\\frac{d \\log\\left(\\frac{\\theta}{1 - \\theta}\\right)}{d \\log C}\\right|_{C = C_{0.5}},\n$$\n其中 $\\log$ 表示自然对数。$n_H$ 是无量纲的。\n\n3. 结合曲线在配体趋于零时的初始斜率 $S_0$，\n$$\nS_0 = \\lim_{C \\to 0^+} \\frac{d \\theta}{d C},\n$$\n以 $\\mathrm{M}^{-1}$ 为单位表示。\n\n你的程序必须实现一个算法，该算法对每组测试参数，仅使用上述基本原理（质量作用定律和 MWC 模型下的组合/统计计数），计算 $C_{0.5}$、在 $C_{0.5}$ 处求值的 $n_H$ 以及 $S_0$。对于 $C_{0.5}$，你必须使用一种不需要外部输入的稳健的区间法来数值求解 $\\theta(C) = 0.5$。对于 $n_H$，你必须使用你推导的解析表达式来计算导数，而不是使用有限差分。对于 $S_0$，你必须从你推导的 $\\theta(C)$ 解析地求解该极限。\n\n使用以下参数值的测试套件，每个指定为 $(N, K_{d,T}, K_{d,R}, L)$，其中 $K_{d,T}$ 和 $K_{d,R}$ 的单位为摩尔 (M)，$L$ 为无量纲：\n\n- 测试用例 1（协同机制，初始时紧张态占优）：$(4, 2\\times 10^{-4}, 1\\times 10^{-6}, 1000)$。\n- 测试用例 2（具有相同微观解离常数的非协同基线）：$(4, 1\\times 10^{-5}, 1\\times 10^{-5}, 100)$。\n- 测试用例 3（单价受体边界情况）：$(1, 5\\times 10^{-6}, 5\\times 10^{-7}, 50)$。\n- 测试用例 4（初始时松弛态占优，弱变构效应）：$(4, 5\\times 10^{-6}, 1\\times 10^{-6}, 1\\times 10^{-3})$。\n- 测试用例 5（极端变构效应和微观亲和力差异）：$(4, 1\\times 10^{-3}, 1\\times 10^{-9}, 1\\times 10^{6})$。\n\n要求的最终输出格式：你的程序应生成单行输出，包含所有五个测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个测试用例贡献一个包含三个浮点数 $[n_H, C_{0.5}, S_0]$ 的子列表（按此顺序）。所有数字必须四舍五入到六位有效数字。例如，总输出必须具有以下形式\n$$\n[[n_{H,1}, C_{0.5,1}, S_{0,1}],[n_{H,2}, C_{0.5,2}, S_{0,2}],[n_{H,3}, C_{0.5,3}, S_{0,3}],[n_{H,4}, C_{0.5,4}, S_{0,4}],[n_{H,5}, C_{0.5,5}, S_{0,5}]]\n$$\n打印行中没有空格。每个 $C_{0.5}$ 的单位必须是 $\\mathrm{M}$，每个 $S_0$ 的单位必须是 $\\mathrm{M}^{-1}$。", "solution": "用户要求一个基于 Monod-Wyman-Changeux (MWC) 变构模型的受体-配体结合问题的解决方案。该任务要求从第一性原理推导分数饱和度 $\\theta(C)$ 的函数形式，然后用它来计算半饱和浓度 $C_{0.5}$、半饱和时的 Hill 系数 $n_H$ 以及结合曲线的初始斜率 $S_0$。\n\n**1. 分数占据函数 $\\theta(C)$ 的推导**\n\nMWC 模型假设，一个具有 $N$ 个相同且独立结合位点的受体存在于两种构象状态：紧张态 ($R_T$) 和松弛态 ($R_R$)。这些状态处于平衡状态，$R_T \\rightleftharpoons R_R$，在没有配体 ($C=0$) 的情况下，该平衡由变构常数 $L = [R_T]/[R_R]$ 控制。配体以不同的微观解离常数（T-态为 $K_{d,T}$，R-态为 $K_{d,R}$）结合到每个状态。\n\n让我们考虑每种状态下受体物种的浓度。对于处于状态 $S \\in \\{T, R\\}$ 的受体，它有 $N$ 个独立位点和微观解离常数 $K_{d,S}$，根据质量作用定律，结合了 $k$ 个配体的受体浓度 $[R_{S,k}]$ 与未结合配体的受体浓度 $[R_{S,0}]$ 相关。将 $k$ 个配体结合到 $N$ 个位点的方式数量由二项式系数 $\\binom{N}{k}$ 给出。\n$$[R_{S,k}] = \\binom{N}{k} \\left(\\frac{C}{K_{d,S}}\\right)^k [R_{S,0}]$$\n状态 $S$ 中受体的总浓度 $[R_S^{\\text{total}}]$ 是对所有配体结合状态（$k=0, \\dots, N$）求和：\n$$[R_S^{\\text{total}}] = \\sum_{k=0}^{N} [R_{S,k}] = [R_{S,0}] \\sum_{k=0}^{N} \\binom{N}{k} \\left(\\frac{C}{K_{d,S}}\\right)^k = [R_{S,0}] \\left(1 + \\frac{C}{K_{d,S}}\\right)^N$$\n变构常数 $L = [R_{T,0}]/[R_{R,0}]$ 关联了未结合配体状态的浓度。我们可以用 $[R_{R,0}]$ 来表示 T-态和 R-态受体的总浓度：\n$$[R_T^{\\text{total}}] = L [R_{R,0}] \\left(1 + \\frac{C}{K_{d,T}}\\right)^N$$\n$$[R_R^{\\text{total}}] = [R_{R,0}] \\left(1 + \\frac{C}{K_{d,R}}\\right)^N$$\n分数饱和度 $\\theta(C)$ 是结合的配体位点总数除以可用位点总数。\n$$\\theta(C) = \\frac{\\sum_{k=0}^{N} k [R_{T,k}] + \\sum_{k=0}^{N} k [R_{R,k}]}{N \\left( [R_T^{\\text{total}}] + [R_R^{\\text{total}}] \\right)}$$\n总和 $\\sum_{k=0}^{N} k [R_{S,k}]$ 代表了状态 $S$ 结合的配体位点的总浓度。使用恒等式 $\\sum_{k=0}^{N} k \\binom{N}{k} x^k = Nx(1+x)^{N-1}$，我们得到：\n$$\\sum_{k=0}^{N} k [R_{S,k}] = [R_{S,0}] N \\frac{C}{K_{d,S}} \\left(1 + \\frac{C}{K_{d,S}}\\right)^{N-1}$$\n将这些表达式代入 $\\theta(C)$ 的公式，并使用 $[R_{T,0}] = L [R_{R,0}]$，项 $[R_{R,0}]N$ 从分子和分母中消去：\n$$ \\theta(C) = \\frac{L \\frac{C}{K_{d,T}} \\left(1+\\frac{C}{K_{d,T}}\\right)^{N-1} + \\frac{C}{K_{d,R}} \\left(1+\\frac{C}{K_{d,R}}\\right)^{N-1}}{L \\left(1+\\frac{C}{K_{d,T}}\\right)^N + \\left(1+\\frac{C}{K_{d,R}}\\right)^N} $$\n这就是所要求的分数占据率的函数形式。\n\n**2. $C_{0.5}$、$n_H$ 和 $S_0$ 的计算**\n\n**a. 半饱和浓度 ($C_{0.5}$)**\n$C_{0.5}$ 是使得 $\\theta(C_{0.5}) = 0.5$ 的配体浓度。这导出一个方程：\n$$ 2 \\left( L \\frac{C_{0.5}}{K_{d,T}} \\left(1+\\frac{C_{0.5}}{K_{d,T}}\\right)^{N-1} + \\frac{C_{0.5}}{K_{d,R}} \\left(1+\\frac{C_{0.5}}{K_{d,R}}\\right)^{N-1} \\right) = L \\left(1+\\frac{C_{0.5}}{K_{d,T}}\\right)^N + \\left(1+\\frac{C_{0.5}}{K_{d,R}}\\right)^N $$\n这个方程是关于 $C_{0.5}$ 的高次多项式，通常没有闭式解析解。它必须通过数值方法求解。我们定义函数 $f(C) = \\theta(C) - 0.5$，并使用像 Brent 法这样的稳健区间法来找到它的根。必须找到一个合适的搜索区间 $[a, b]$ 使得 $f(a)f(b)  0$。由于 $\\theta(0)=0$，我们可以将 $a$ 设置为一个很小的正数。可以通过从一个小值开始并增加它直到 $\\theta(b) > 0.5$ 来找到上界 $b$。\n\n**b. Hill 系数 ($n_H$)**\n半饱和时的 Hill 系数定义为：\n$$ n_H = \\left.\\frac{d \\log\\left(\\frac{\\theta}{1 - \\theta}\\right)}{d \\log C}\\right|_{C = C_{0.5}} = \\frac{C}{\\theta(1-\\theta)} \\frac{d\\theta}{dC} \\bigg|_{C = C_{0.5}} $$\n在 $C=C_{0.5}$ 时，$\\theta=0.5$，所以 $\\theta(1-\\theta) = 0.25$。该表达式简化为：\n$$ n_H = 4 C_{0.5} \\left.\\frac{d\\theta}{dC}\\right|_{C = C_{0.5}} $$\n为了计算 $n_H$，我们需要 $\\theta(C)$ 的解析导数。令 $\\theta(C) = \\frac{Num(C)}{Den(C)}$。使用商法则，$\\frac{d\\theta}{dC} = \\frac{Num'(C)Den(C) - Num(C)Den'(C)}{Den(C)^2}$。\n在 $C=C_{0.5}$ 时，$Num(C_{0.5}) = 0.5 Den(C_{0.5})$，这将导数简化为：\n$$ \\left.\\frac{d\\theta}{dC}\\right|_{C=C_{0.5}} = \\frac{Num'(C_{0.5}) - 0.5 Den'(C_{0.5})}{Den(C_{0.5})} $$\n令 $A_S(C) = 1 + C/K_{d,S}$，其中 $S \\in \\{T,R\\}$。分子和分母组成函数的导数是：\n$$ Den'(C) = \\frac{d}{dC} \\left[ L A_T^N + A_R^N \\right] = \\frac{LN}{K_{d,T}} A_T^{N-1} + \\frac{N}{K_{d,R}} A_R^{N-1} $$\n$$ Num'(C) = \\frac{d}{dC} \\left[ L \\frac{C}{K_{d,T}} A_T^{N-1} + \\frac{C}{K_{d,R}} A_R^{N-1} \\right] = \\frac{L}{K_{d,T}} A_T^{N-2} \\left(1 + \\frac{NC}{K_{d,T}}\\right) + \\frac{1}{K_{d,R}} A_R^{N-2} \\left(1 + \\frac{NC}{K_{d,R}}\\right) $$\n这些表达式可以在 $C=C_{0.5}$ 处求值以找到 $n_H$。这些通用形式对 $N \\ge 1$ 均有效。\n\n**c. 初始斜率 ($S_0$)**\n初始斜率 $S_0$ 是导数在 $C \\to 0^+$ 时的极限：\n$$ S_0 = \\lim_{C \\to 0^+} \\frac{d\\theta}{dC} $$\n我们在 $C=0$ 处计算 $\\frac{d\\theta}{dC}$。当 $C \\to 0$ 时，我们有 $A_T \\to 1$，$A_R \\to 1$，$Num(C) \\to 0$ 和 $Den(C) \\to L+1$。导数的值为：\n$$ \\lim_{C\\to 0} Num'(C) = \\frac{L}{K_{d,T}} + \\frac{1}{K_{d,R}} $$\n$$ \\lim_{C\\to 0} Den'(C) = \\frac{LN}{K_{d,T}} + \\frac{N}{K_{d,R}} $$\n代入 $\\frac{d\\theta}{dC}$ 的商法则公式中：\n$$ S_0 = \\frac{(\\frac{L}{K_{d,T}} + \\frac{1}{K_{d,R}})(L+1) - (0) \\cdot Den'(0)}{(L+1)^2} = \\frac{\\frac{L}{K_{d,T}} + \\frac{1}{K_{d,R}}}{L+1} $$\n该表达式可以直接从输入参数计算得出。\n\n**算法实现**\n程序将实现函数来计算 $\\theta(C)$，使用数值求根器找到 $C_{0.5}$，并计算 $n_H$ 和 $S_0$ 的解析表达式。对每个指定的测试用例将重复此过程。最终的数值结果将格式化为六位有效数字。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the MWC model problem for a suite of test cases.\n    It computes C_0.5, n_H, and S_0 for each case based on first-principle derivations.\n    \"\"\"\n    \n    test_cases = [\n        # (N, K_d,T, K_d,R, L)\n        (4, 2e-4, 1e-6, 1000),\n        (4, 1e-5, 1e-5, 100),\n        (1, 5e-6, 5e-7, 50),\n        (4, 5e-6, 1e-6, 1e-3),\n        (4, 1e-3, 1e-9, 1e6)\n    ]\n\n    def _calculate_quantities(N, K_d_T, K_d_R, L):\n        \"\"\"\n        Computes the three requested quantities for a single parameter set.\n        \"\"\"\n        \n        # 1. Define the fractional occupancy function theta(C)\n        def theta(C):\n            if C == 0: return 0.0\n            \n            alpha_T = C / K_d_T\n            alpha_R = C / K_d_R\n            \n            # Using np.power for robust exponentiation\n            # Numerator terms\n            term_T_num = L * alpha_T * np.power(1.0 + alpha_T, N - 1)\n            term_R_num = alpha_R * np.power(1.0 + alpha_R, N - 1)\n            \n            # Denominator terms\n            term_T_den = L * np.power(1.0 + alpha_T, N)\n            term_R_den = np.power(1.0 + alpha_R, N)\n            \n            numerator = term_T_num + term_R_num\n            denominator = term_T_den + term_R_den\n            \n            # Avoid division by zero, though unlikely for C > 0\n            if denominator == 0:\n                return 0.0\n            return numerator / denominator\n\n        # 2. Find C_0.5 by solving theta(C) - 0.5 = 0\n        def f_for_root(C):\n            return theta(C) - 0.5\n\n        # Establish a robust search bracket [a, b] for the root finder\n        a, b = 1e-20, 1e-18\n        # Check if the root is smaller than the initial guess for b\n        if f_for_root(b)  0:\n            while f_for_root(b)  0:\n                b *= 10.0\n                if b > 1e12: # Safety break to prevent infinite loops\n                    raise ValueError(\"Failed to find an upper bracket for C_0.5\")\n        \n        # Use Brent's method to find the root C_0.5\n        C_0_5 = brentq(f_for_root, a, b, xtol=1e-24, rtol=1e-15)\n\n        # 3. Calculate the Hill coefficient n_H at C_0.5\n        def calculate_n_H(C):\n            # n_H = 4 * C * (d(theta)/dC) at C_0.5\n            # d(theta)/dC = (Num' - 0.5 * Den') / Den at C_0.5\n            \n            A_T = 1.0 + C / K_d_T\n            A_R = 1.0 + C / K_d_R\n            \n            Den = L * np.power(A_T, N) + np.power(A_R, N)\n            \n            # Derivative of Numerator (Num')\n            Num_prime_T = (L / K_d_T) * np.power(A_T, N - 2) * (1.0 + N * C / K_d_T)\n            Num_prime_R = (1.0 / K_d_R) * np.power(A_R, N - 2) * (1.0 + N * C / K_d_R)\n            Num_prime = Num_prime_T + Num_prime_R\n            \n            # Derivative of Denominator (Den')\n            Den_prime_T = N * L / K_d_T * np.power(A_T, N - 1)\n            Den_prime_R = N / K_d_R * np.power(A_R, N - 1)\n            Den_prime = Den_prime_T + Den_prime_R\n            \n            dtheta_dc_at_C05 = (Num_prime - 0.5 * Den_prime) / Den\n            \n            n_H = 4.0 * C * dtheta_dc_at_C05\n            return n_H\n\n        n_H = calculate_n_H(C_0_5)\n\n        # 4. Calculate the initial slope S_0\n        S_0 = (L / K_d_T + 1.0 / K_d_R) / (L + 1.0)\n        \n        return n_H, C_0_5, S_0\n\n    all_results = []\n    for case in test_cases:\n        N, K_d_T, K_d_R, L = case\n        result_tuple = _calculate_quantities(N, K_d_T, K_d_R, L)\n        all_results.append(result_tuple)\n\n    # Format the final output string according to the spec\n    # Use {:.6g} for floating-point formatting to 6 significant figures.\n    formatted_sublists = [\n        f\"[{res[0]:.6g},{res[1]:.6g},{res[2]:.6g}]\" \n        for res in all_results\n    ]\n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3344587"}, {"introduction": "生物过程，特别是涉及少量分子的过程，本质上是随机的。本练习引入化学主方程（CME）将受体-配体结合模拟为一个随机的生灭过程。您将超越确定性的常微分方程，不仅计算平均行为，还将计算涨落、稳态分布和首次穿越时间，从而为分子相互作用提供一幅更完整的图景。[@problem_id:3344581]", "problem": "考虑一个具有有限数量受体和配体的受体-配体系统，它们之间发生可逆结合。令 $n$ 表示已结合的受体-配体复合物的数量。状态空间为 $n \\in \\{0,1,2,\\dots,\\min(N_R,N_L)\\}$，其中 $N_R$ 是受体总数，$N_L$ 是配体总数。假设在充分混合条件下，遵循质量作用配对原则，从状态 $n$ 到 $n+1$ 的瞬时结合倾向率为 $a_+(n) = k_+ \\,(N_R - n)\\,(N_L - n)$，从状态 $n$ 到 $n-1$ 的解离倾向率为 $a_-(n) = k_- \\, n$。其中，$k_+$ 是单位为 $\\mathrm{s}^{-1}$ 的每对结合速率常数，$k_-$ 是单位为 $\\mathrm{s}^{-1}$ 的每复合物解离速率常数。令 $p_n(t)$ 表示在时间 $t$ 处于状态 $n$ 的概率。化学主方程 (Chemical Master Equation, CME) 定义了连续时间马尔可夫链生成元 $\\mathbf{Q}$，使得正向方程为 $\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\,\\mathbf{Q}$。其中 $\\mathbf{p}(t)$ 是一个行向量，其元素为 $p_n(t)$，$\\mathbf{Q}$ 具有与生灭转换一致的三对角结构。\n\n仅从上述定义以及随机过程的平衡和动力学基本原理出发：\n- 基于生灭链的可逆性和细致平衡，推导关于 $n$ 的稳态分布 $\\boldsymbol{\\pi}$，并确保在离散状态空间上归一化。使用此分布计算已结合复合物的稳态平均数 $\\mu = \\sum_n n\\,\\pi_n$ 和稳态方差 $\\sigma^2 = \\sum_n (n - \\mu)^2 \\,\\pi_n$。将 $\\mu$ 和 $\\sigma^2$ 以实数形式报告。\n- 对于给定的阈值 $n^\\*$（满足 $1 \\le n^\\* \\le \\min(N_R,N_L)$），推导并计算从初始状态 $n_0$（满足 $0 \\le n_0  n^\\*$）到达状态 $n^\\*$ 的平均首达时间 $\\tau$（单位为秒）。通过将 $n^\\*$ 设为吸收态，并求解生成元在瞬态上的相应线性系统来对此首达事件建模。\n- 对于给定的评估时间 $t$（单位为秒），计算在时间 $0$ 从 $n_0$ 初始化后，系统在时间 $t$ 处于状态 $n=0$（所有受体均未结合）的瞬态概率 $p_0(t)$。使用 $\\mathbf{Q}$ 的矩阵指数来演化概率分布随时间的变化。\n\n物理单位：\n- 所有速率常数 $k_+$ 和 $k_-$ 的单位必须是 $\\mathrm{s}^{-1}$。\n- 所有时间（$t$ 和 $\\tau$）必须以秒为单位表示，并为实数。\n\n您的程序必须精确实现这些计算，并为以下测试集生成数值结果。每个测试用例指定 $(N_R,N_L,k_+,k_-,n^\\*,n_0,t)$：\n\n- 测试用例 A (一般场景): $N_R=20$, $N_L=15$, $k_+=10^{-3}\\ \\mathrm{s}^{-1}$, $k_-=10^{-2}\\ \\mathrm{s}^{-1}$, $n^\\*=10$, $n_0=0$, $t=500\\ \\mathrm{s}$。\n- 测试用例 B (小数目边界): $N_R=1$, $N_L=1$, $k_+=5\\times 10^{-1}\\ \\mathrm{s}^{-1}$, $k_-=10^{-1}\\ \\mathrm{s}^{-1}$, $n^\\*=1$, $n_0=0$, $t=5\\ \\mathrm{s}$。\n- 测试用例 C (高亲和力体系): $N_R=30$, $N_L=30$, $k_+=5\\times 10^{-2}\\ \\mathrm{s}^{-1}$, $k_-=10^{-3}\\ \\mathrm{s}^{-1}$, $n^\\*=25$, $n_0=0$, $t=20\\ \\mathrm{s}$。\n- 测试用例 D (配体限制边界): $N_R=50$, $N_L=5$, $k_+=2\\times 10^{-3}\\ \\mathrm{s}^{-1}$, $k_-=5\\times 10^{-3}\\ \\mathrm{s}^{-1}$, $n^\\*=5$, $n_0=0$, $t=50\\ \\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表为每个测试用例（按 A、B、C、D 的顺序）包含一个子列表。每个子列表必须按 $[\\mu,\\sigma^2,\\tau,p_0(t)]$ 的顺序包含四个实数，其中 $\\mu$ 是稳态平均占据数，$\\sigma^2$ 是稳态方差，$\\tau$ 是到达 $n^\\*$ 的平均首达时间（单位为秒），$p_0(t)$ 是在时间 $t$ 处于未结合状态的概率。要求的确切格式是\n\"[[\\mu_A,\\sigma^2_A,\\tau_A,p_{0,A}(t)],[\\mu_B,\\sigma^2_B,\\tau_B,p_{0,B}(t)],[\\mu_C,\\sigma^2_C,\\tau_C,p_{0,C}(t)],[\\mu_D,\\sigma^2_D,\\tau_D,p_{0,D}(t)]]\"\n方括号内不含任何空白字符。", "solution": "用户提供了一个计算系统生物学问题，涉及受体-配体结合的随机动力学。我将首先验证问题陈述，然后提供完整的推导和计算解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **系统**：$N_R$ 个受体与 $N_L$ 个配体之间的可逆结合。\n- **状态空间**：已结合复合物的数量 $n$，范围从 $0$ 到 $N_{max} = \\min(N_R, N_L)$。\n- **结合倾向率**：从状态 $n$ 到 $n+1$ 的转变速率为 $a_+(n) = k_+ (N_R - n)(N_L - n)$。\n- **解离倾向率**：从状态 $n$ 到 $n-1$ 的转变速率为 $a_-(n) = k_- n$。\n- **速率常数**：$k_+$ (单位 $\\mathrm{s}^{-1}$) 和 $k_-$ (单位 $\\mathrm{s}^{-1}$)。\n- **演化方程**：$\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\mathbf{Q}$，其中 $\\mathbf{p}(t)$ 是状态概率的行向量。\n- **任务 1**：计算 $n$ 的稳态平均值 $\\mu$ 和方差 $\\sigma^2$。\n- **任务 2**：计算从 $n_0$ 开始到达状态 $n^\\*$ 的平均首达时间 (MFPT) $\\tau$，其中 $1 \\le n^\\* \\le N_{max}$ 且 $0 \\le n_0  n^\\*$。\n- **任务 3**：计算在 $t=0$ 时从状态 $n_0$ 开始，在时间 $t$ 处于状态 $n=0$ 的瞬态概率 $p_0(t)$。\n- **测试用例**：\n    - A: $(N_R=20, N_L=15, k_+=10^{-3}, k_-=10^{-2}, n^\\*=10, n_0=0, t=500)$\n    - B: $(N_R=1, N_L=1, k_+=0.5, k_-=0.1, n^\\*=1, n_0=0, t=5)$\n    - C: $(N_R=30, N_L=30, k_+=0.05, k_-=0.001, n^\\*=25, n_0=0, t=20)$\n    - D: $(N_R=50, N_L=5, k_+=0.002, k_-=0.005, n^\\*=5, n_0=0, t=50)$\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了一个经典的生灭过程模型，用于随机化学动力学，这是系统生物学的基石。对于具有有限数量分子的充分混合系统，质量作用倾向率是标准的且物理上合理的。\n- **适定性**：每个任务都是有限状态空间的连续时间马尔可夫链理论中的一个标准、明确定义的问题。存在唯一的稳态分布。到达吸收态的平均首达时间是唯一确定的。概率分布的瞬态演化由一个明确定义的线性常微分方程控制。\n- **客观性**：该问题使用精确的数学和科学语言陈述，不含任何主观性。\n- **一致性和完整性**：为每个测试用例提供了所有必要的参数。参数的约束条件（例如，$0 \\le n_0  n^\\*$）是一致的。状态空间的边界由倾向率的定义正确处理（例如，$a_+(N_{max}) = 0$，$a_-(0) = 0$）。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。它是一个适定的、有科学依据且计算上可行的问题。我将继续进行详细的解答。\n\n### 推导与方法论\n\n该系统是在状态空间 $S = \\{0, 1, \\dots, N_{max}\\}$ 上的一个一维生灭过程，其中 $N_{max} = \\min(N_R, N_L)$。出生率（从 $n \\to n+1$）为 $\\lambda_n = a_+(n) = k_+(N_R - n)(N_L - n)$（对于 $n \\in \\{0, \\dots, N_{max}-1\\}$），死亡率（从 $n \\to n-1$）为 $\\mu_n = a_-(n) = k_- n$（对于 $n \\in \\{1, \\dots, N_{max}\\}$）。\n\n**1. 稳态分布、平均值和方差**\n在平衡状态下，系统满足细致平衡条件：\n$$ \\pi_n \\lambda_n = \\pi_{n+1} \\mu_{n+1} $$\n其中 $\\pi_n$ 是处于状态 $n$ 的稳态概率。这为概率提供了一个递推关系：\n$$ \\pi_{n+1} = \\pi_n \\frac{\\lambda_n}{\\mu_{n+1}} = \\pi_n \\frac{k_+(N_R - n)(N_L - n)}{k_-(n+1)} $$\n我们可以用 $\\pi_0$ 来表示每个 $\\pi_n$：\n$$ \\pi_n = \\pi_0 \\prod_{i=0}^{n-1} \\frac{\\lambda_i}{\\mu_{i+1}} $$\n为了在数值计算中避免上溢或下溢，我们首先计算未归一化的对数概率：$\\log \\tilde{\\pi}_0 = 0$ 和 $\\log \\tilde{\\pi}_{n+1} = \\log \\tilde{\\pi}_n + \\log(\\lambda_n) - \\log(\\mu_{n+1})$。然后，我们使用 log-sum-exp 技巧以保证稳定性，将其转换回线性尺度，最后通过总和 $\\sum_n \\pi_n = 1$ 进行归一化，以找到正确缩放的 $\\pi_n$ 值。\n然后根据其定义计算稳态平均值 $\\mu$ 和方差 $\\sigma^2$：\n$$ \\mu = \\sum_{n=0}^{N_{max}} n \\pi_n \\quad , \\quad \\sigma^2 = \\sum_{n=0}^{N_{max}} (n-\\mu)^2 \\pi_n = \\left(\\sum_{n=0}^{N_{max}} n^2 \\pi_n\\right) - \\mu^2 $$\n\n**2. 平均首达时间 (MFPT)**\n为了计算从 $n_0  n^\\*$ 开始到达吸收态 $n^\\*$ 的 MFPT $\\tau$，我们考虑瞬态集 $S_T = \\{0, 1, \\dots, n^\\*-1\\}$。令 $\\tau_i$ 为从状态 $i \\in S_T$ 到达 $n^\\*$ 的 MFPT。$\\tau_i$ 的值满足一个线性方程组。通过考虑离开状态 $i$ 的第一步，我们将 $\\tau_i$ 与相邻状态的 MFPT 联系起来：\n$$ \\tau_i = \\frac{1}{\\lambda_i + \\mu_i} + \\frac{\\lambda_i}{\\lambda_i + \\mu_i}\\tau_{i+1} + \\frac{\\mu_i}{\\lambda_i + \\mu_i}\\tau_{i-1} $$\n整理后得到：\n$$ \\mu_i \\tau_{i-1} - (\\lambda_i + \\mu_i) \\tau_i + \\lambda_i \\tau_{i+1} = -1 $$\n此式对 $i \\in S_T$ 成立，边界条件为 $\\tau_{n^\\*} = 0$（从目标到达目标的时间为零）和 $\\mu_0 = 0$。这个包含 $n^\\*$ 个线性方程的系统可以写成矩阵形式 $\\mathbf{A}\\boldsymbol{\\tau} = \\mathbf{b}$，其中 $\\boldsymbol{\\tau} = [\\tau_0, \\dots, \\tau_{n^\\*-1}]^T$，$\\mathbf{b} = [-1, \\dots, -1]^T$，$\\mathbf{A}$ 是针对瞬态的 $n^\\* \\times n^\\*$ 生成元子矩阵。我们求解该系统得到 $\\boldsymbol{\\tau}$，并提取 $\\tau_{n_0}$。\n\n**3. 瞬态概率**\n概率向量 $\\mathbf{p}(t)$ 的演化由 $\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\mathbf{Q}$ 给出，其中 $\\mathbf{p}(t)$ 是一个行向量。其解为 $\\mathbf{p}(t) = \\mathbf{p}(0) e^{\\mathbf{Q}t}$，其中 $\\mathbf{p}(0)$ 是初始概率分布，$e^{\\mathbf{Q}t}$ 是 $\\mathbf{Q}t$ 的矩阵指数。对于全状态空间 $S = \\{0, \\dots, N_{max}\\}$，生成元矩阵 $\\mathbf{Q}$ 是一个 $(N_{max}+1) \\times (N_{max}+1)$ 的三对角矩阵，其元素由转移速率定义：\n$$ Q_{i,j} = \\begin{cases} \\lambda_i  \\text{if } j = i+1 \\\\ \\mu_i  \\text{if } j = i-1 \\\\ -(\\lambda_i + \\mu_i)  \\text{if } j = i \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $\\lambda_{N_{max}} = 0$ 且 $\\mu_0 = 0$。\n初始状态为 $n_0$，所以 $\\mathbf{p}(0)$ 是一个在索引 $n_0$ 处为 1，其他位置为 0 的向量。在时间 $t$ 处于状态 $j$ 的概率是 $p_j(t) = (\\mathbf{p}(0)e^{\\mathbf{Q}t})_j = (e^{\\mathbf{Q}t})_{n_0, j}$。我们需要计算 $p_0(t)$，它对应于元素 $(e^{\\mathbf{Q}t})_{n_0, 0}$。对于给定的测试用例，$n_0=0$，因此我们需要计算 $\\mathbf{Q}t$ 的矩阵指数的 $(0,0)$ 元素。这可以使用 `scipy.linalg.expm` 进行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve\n\ndef solve_problem():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    # Each tuple: (NR, NL, k+, k-, n*, n0, t)\n    test_cases = [\n        (20, 15, 1e-3, 1e-2, 10, 0, 500),  # Test Case A\n        (1, 1, 0.5, 0.1, 1, 0, 5),          # Test Case B\n        (30, 30, 5e-2, 1e-3, 25, 0, 20),    # Test Case C\n        (50, 5, 2e-3, 5e-3, 5, 0, 50),      # Test Case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = compute_metrics(*case)\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    result_strings = []\n    for res in all_results:\n        result_strings.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\ndef compute_metrics(NR, NL, k_plus, k_minus, n_star, n0, t):\n    \"\"\"\n    Computes the four required metrics (stationary mean, stationary variance,\n    mean first-passage time, and a transient probability) for a single test case.\n    \"\"\"\n    N_max = min(NR, NL)\n\n    # --- Part 1: Stationary Mean and Variance ---\n    # We use logarithms to prevent numerical over/underflow when calculating\n    # the unnormalized stationary probabilities.\n    log_unnormalized_pi = np.zeros(N_max + 1, dtype=np.float64)\n    for n in range(N_max):\n        lambda_n = k_plus * (NR - n) * (NL - n)\n        mu_n_plus_1 = k_minus * (n + 1)\n        if lambda_n == 0:\n            log_unnormalized_pi[n+1:] = -np.inf\n            break\n        log_unnormalized_pi[n+1] = log_unnormalized_pi[n] + np.log(lambda_n) - np.log(mu_n_plus_1)\n\n    # Normalize using the log-sum-exp trick for stability\n    log_max = np.max(log_unnormalized_pi)\n    unnormalized_pi = np.exp(log_unnormalized_pi - log_max)\n    pi = unnormalized_pi / np.sum(unnormalized_pi)\n\n    n_values = np.arange(N_max + 1, dtype=np.float64)\n    mu_stationary = np.sum(n_values * pi)\n    sigma2_stationary = np.sum((n_values - mu_stationary)**2 * pi)\n\n    # --- Part 2: Mean First-Passage Time (MFPT) ---\n    # Solve the system A * tau = -1, where A is the generator submatrix\n    # for the transient states {0, 1, ..., n_star-1}.\n    size_mfpt = n_star\n    \n    lambda_vals = k_plus * (NR - np.arange(size_mfpt, dtype=np.float64)) * (NL - np.arange(size_mfpt, dtype=np.float64))\n    mu_vals = k_minus * np.arange(size_mfpt, dtype=np.float64)\n\n    diag0 = -(lambda_vals + mu_vals)\n    diagp1 = lambda_vals[:-1] if size_mfpt > 1 else np.array([])\n    diagm1 = mu_vals[1:] if size_mfpt > 1 else np.array([])\n\n    A_mfpt = np.diag(diag0) + np.diag(diagp1, k=1) + np.diag(diagm1, k=-1)\n    \n    b_mfpt = -np.ones(size_mfpt, dtype=np.float64)\n    tau_vec = solve(A_mfpt, b_mfpt)\n    tau_mfpt = tau_vec[n0]\n\n    # --- Part 3: Transient Probability ---\n    # Compute p(t) = p(0) * expm(Q*t), where Q is the full generator matrix.\n    size_q = N_max + 1\n    \n    lambda_vals_q = k_plus * (NR - np.arange(size_q, dtype=np.float64)) * (NL - np.arange(size_q, dtype=np.float64))\n    lambda_vals_q[N_max] = 0.0 # Explicitly set rate out of max state to 0\n    mu_vals_q = k_minus * np.arange(size_q, dtype=np.float64)\n\n    diag0_q = -(lambda_vals_q + mu_vals_q)\n    diagp1_q = lambda_vals_q[:-1] if size_q > 1 else np.array([])\n    diagm1_q = mu_vals_q[1:] if size_q > 1 else np.array([])\n\n    Q = np.diag(diag0_q) + np.diag(diagp1_q, k=1) + np.diag(diagm1_q, k=-1)\n    \n    # Propagator matrix P(t) = expm(Q*t)\n    P_t = expm(Q * t)\n    \n    # We need p_0(t) given initial state n0, which is P_t[n0, 0].\n    p0_t = P_t[n0, 0]\n\n    return [mu_stationary, sigma2_stationary, tau_mfpt, p0_t]\n\nif __name__ == '__main__':\n    solve_problem()\n```", "id": "3344581"}]}