{"hands_on_practices": [{"introduction": "在网络基序的显著性分析中，第一步是建立一个合适的零模型。本练习将探讨最基础的零模型——有向埃尔德什-雷尼（Erdős–Rényi）随机图，并要求您从第一性原理出发，推导前馈环（Feed-Forward Loop, FFL）这一重要三节点基序的期望数量和方差。通过这个理论实践[@problem_id:3332172]，您将掌握在随机图中分析基序统计特性的核心数学工具，为理解更复杂的显著性检验奠定坚实的基础。", "problem": "考虑一个由 $n$ 个分子种类构成的有向网络，该网络由有向 Erdős–Rényi (ER) 随机图模型生成。在此模型中，对于任意有序的不同节点对 $(u,v)$，有向边 $u \\to v$ 以概率 $p \\in (0,1)$ 独立存在，并以概率 $1-p$ 不存在。在计算系统生物学中，前馈环 (FFL) 是一个 3 节点有向三元组模体，由三个不同节点 $(i,j,k)$ 组成，它们之间恰好存在三条有向边 $i \\to j$、 $j \\to k$ 和 $i \\to k$，且这三个节点之间的所有其他有向边都不存在。在全文中，将模体计数解释为与 FFL 同构的、由3个不同节点构成的诱导子图的数量。FFL 对于模体显著性分析至关重要，而 ER 模型和配置模型 (CM) 等零模型基准需要其期望丰度和变异性的解析表达式。\n\n从适用于零模型分析的第一性原理出发——即 ER 模型中的边独立性、子图出现的指示随机变量、期望的线性性以及全方差公式——推导出以下各项的闭式解析表达式：\n- 作为 $n$ 和 $p$ 的函数的 FFL 期望数量，以及\n- 作为 $n$ 和 $p$ 的函数的 FFL 数量的方差，\n\n明确考虑边的方向性和诱导子图约束。将共享少于 2 个节点的两个 3 节点集在模体出现方面视为独立的，并仔细枚举当两个不同的 3 节点集恰好共享 2 个节点时的依赖结构。假设 $n \\geq 3$。将最终结果表示为关于 $n$ 和 $p$ 的闭式表达式。不需要数值近似。将最终答案以包含两个表达式的单行矩阵形式提供。不需要单位。", "solution": "设 $V$ 是网络中 $n$ 个节点的集合。前馈环 (FFL) 的总数，记为 $N_{FFL}$，是遍及 $V$ 的所有不同 3 节点子集的指示随机变量之和。设 $S$ 是 $V$ 的一个子集，且 $|S|=3$。设 $I_S$ 是一个指示变量，如果 $S$ 上的诱导子图是一个 FFL，则 $I_S = 1$，否则 $I_S = 0$。那么，总计数为 $N_{FFL} = \\sum_{S \\subset V, |S|=3} I_S$。\n\nFFL 期望数量 $E[N_{FFL}]$ 的推导\n根据期望的线性性，FFL 的期望数量为：\n$$E[N_{FFL}] = E\\left[\\sum_{S \\subset V, |S|=3} I_S\\right] = \\sum_{S \\subset V, |S|=3} E[I_S]$$\n不同 3 节点集的数量为 $\\binom{n}{3}$。根据对称性，对于所有集合 $S$，期望 $E[I_S]$ 都是相同的。对于任意给定集合 $S = \\{i,j,k\\}$，令 $P_1 = E[I_S] = P(I_S=1)$。\n如果节点可以被分配为源（例如，$i$）、中间（例如，$j$）和汇（例如，$k$）的角色，使得边 $i \\to j$、$j \\to k$ 和 $i \\to k$ 存在，并且这些节点之间的所有其他 3 条可能的有向边（$j \\to i$、$k \\to j$、$k \\to i$）都不存在，则 $\\{i,j,k\\}$ 上的诱导子图是一个 FFL。\n在 Erdős–Rényi 模型中，由于边的独立性，这 6 条边的特定构型的概率是 $p^3(1-p)^3$。\n对于一个给定的 3 节点集，有 $3! = 6$ 种方式来分配源、中间和汇的角色。这 6 种分配对应于集合 $\\{i,j,k\\}$ 上的互斥边构型。每种构型具有相同的概率 $p^3(1-p)^3$。\n因此，一个集合 $S$ 形成 FFL 的总概率为：\n$$P_1 = P(I_S=1) = 3! \\times p^3(1-p)^3 = 6p^3(1-p)^3$$\nFFL 的期望数量是 3 节点集的数量与概率 $P_1$ 的乘积：\n$$E[N_{FFL}] = \\binom{n}{3} P_1 = \\frac{n(n-1)(n-2)}{6} \\times 6p^3(1-p)^3 = n(n-1)(n-2)p^3(1-p)^3$$\n\nFFL 数量方差 $Var(N_{FFL})$ 的推导\n随机变量之和的方差由下式给出：\n$$Var(N_{FFL}) = Var\\left(\\sum_S I_S\\right) = \\sum_S Var(I_S) + \\sum_{S \\neq T} Cov(I_S, I_T)$$\n第一项是各指示变量的方差之和。因为 $I_S$ 是一个指示变量，所以 $I_S^2 = I_S$，其方差为 $Var(I_S) = E[I_S^2] - (E[I_S])^2 = P_1 - P_1^2 = P_1(1-P_1)$。\n$$\\sum_S Var(I_S) = \\binom{n}{3} P_1(1-P_1) = \\binom{n}{3} \\left[6p^3(1-p)^3\\right] \\left[1 - 6p^3(1-p)^3\\right]$$\n第二项是协方差之和，$Cov(I_S, I_T) = E[I_S I_T] - E[I_S]E[I_T] = P(I_S=1, I_T=1) - P_1^2$。只有当事件 $I_S=1$ 和 $I_T=1$ 相关时，协方差才非零，这发生在它们的底层边集重叠时。如果节点集 $S$ 和 $T$ 共享边，即 $|S \\cap T| \\ge 2$，就会发生这种情况。\n根据问题陈述，我们只需要考虑两个不同集合 $S$ 和 $T$ 恰好共享 2 个节点的情况。\n设 $|S \\cap T|=2$。设 $S=\\{a,b,c\\}$ 和 $T=\\{a,b,d\\}$，其中 $a,b,c,d$ 是不同的节点。\n我们需要计算 $P_2 = E[I_S I_T] = P(I_S=1, I_T=1)$。要使 $S$ 和 $T$ 上的诱导子图都是 FFL，共享节点 $a$ 和 $b$ 之间必须存在特定的连接模式。任何 3 个节点上的 FFL 都要求 FFL 内的任意一对节点之间恰好有一条有向边。因此，$a$ 和 $b$ 之间的边的状态不能是无边或双向边。它必须是（$a \\to b$ 且 $b \\not\\to a$）或（$b \\to a$ 且 $a \\not\\to b$）之一。\n让我们分析（$a \\to b$ 且 $b \\not\\to a$）的情况。此状态的概率是 $p(1-p)$。给定节点对 $(a,b)$ 的这种状态，集合 $S$ 形成 FFL 的事件现在仅依赖于涉及节点 $c$ 的边，而集合 $T$ 形成 FFL 的事件仅依赖于涉及节点 $d$ 的边。这两个事件是条件独立的。\n给定 $a \\to b$ 和 $b \\not\\to a$，要使 $S=\\{a,b,c\\}$ 成为一个诱导FFL，有三种互斥的可能性，每种都要求其余4条边的特定状态（2条存在，2条不存在），因此每种情况的概率为$p^2(1-p)^2$。这三种可能性是：1) $a \\to b, b \\to c, a \\to c$；2) $c \\to a, a \\to b, c \\to b$；3) $a \\to c, c \\to b, a \\to b$。\n给定 $a \\to b$ 且 $b \\not\\to a$，集合 $S$ 形成 FFL 的总概率是这些概率之和：$3p^2(1-p)^2$。\n根据对称性，给定 $a \\to b$ 且 $b \\not\\to a$，集合 $T$ 形成 FFL 的概率也是 $3p^2(1-p)^2$。\n因此，$P(I_S=1, I_T=1 | a \\to b, b \\not\\to a) = (3p^2(1-p)^2) \\times (3p^2(1-p)^2) = 9p^4(1-p)^4$。\n使用关于 $a$ 和 $b$ 之间边的状态的全概率公式：\n$$P_2 = P(I_S=1, I_T=1 | a \\to b, b \\not\\to a)P(a \\to b, b \\not\\to a) + P(I_S=1, I_T=1 | b \\to a, a \\not\\to b)P(b \\to a, a \\not\\to b)$$\n根据对称性，这两项是相同的。\n$$P_2 = 2 \\times [9p^4(1-p)^4] \\times [p(1-p)] = 18p^5(1-p)^5$$\n现在，我们计算 $|S \\cap T|=2$ 的有序集合对 $(S,T)$ 的数量。我们可以用 $\\binom{n}{2}$ 种方式选择 2 个共享节点，并从剩余的 $n-2$ 个节点中用 $\\binom{n-2}{2}$ 种方式选择 2 个唯一节点。这定义了一个四元节点组和共享对。给定四元组和共享对，只有一种方法可以形成两个集合 $S$ 和 $T$。这给出了 $\\binom{n}{2}\\binom{n-2}{2}$ 个具有指定共享对的唯一四元组。每个这样的构型对应于 2 个有序对 $(S,T)$ 和 $(T,S)$。\n有序对的数量为 $2 \\times \\binom{n}{2}\\binom{n-2}{2} = 2 \\times \\frac{n(n-1)}{2} \\times \\frac{(n-2)(n-3)}{2} = \\frac{n(n-1)(n-2)(n-3)}{2}$。\n来自协方差项的总贡献是：\n$$\\sum_{S \\neq T, |S \\cap T|=2} Cov(I_S, I_T) = \\frac{n(n-1)(n-2)(n-3)}{2} (P_2 - P_1^2)$$\n$$= \\frac{n(n-1)(n-2)(n-3)}{2} [18p^5(1-p)^5 - (6p^3(1-p)^3)^2]$$\n$$= n(n-1)(n-2)(n-3) [9p^5(1-p)^5 - 18p^6(1-p)^6]$$\n$$= 9n(n-1)(n-2)(n-3)p^5(1-p)^5(1 - 2p(1-p))$$\n$$= 9n(n-1)(n-2)(n-3)p^5(1-p)^5(1 - 2p + 2p^2)$$\n结合方差的两个部分：\n$$Var(N_{FFL}) = \\binom{n}{3}P_1(1-P_1) + \\frac{n(n-1)(n-2)(n-3)}{2}(P_2 - P_1^2)$$\n$$Var(N_{FFL}) = \\frac{n(n-1)(n-2)}{6} [6p^3(1-p)^3(1-6p^3(1-p)^3)] + 9n(n-1)(n-2)(n-3)p^5(1-p)^5(1 - 2p + 2p^2)$$\n$$Var(N_{FFL}) = n(n-1)(n-2)p^3(1-p)^3(1-6p^3(1-p)^3) + 9n(n-1)(n-2)(n-3)p^5(1-p)^5(1 - 2p + 2p^2)$$\n这是方差的最终闭式表达式。", "answer": "$$ \\boxed{ \\begin{pmatrix} n(n-1)(n-2)p^{3}(1-p)^{3}  n(n-1)(n-2)p^{3}(1-p)^{3}(1-6p^{3}(1-p)^{3}) + 9n(n-1)(n-2)(n-3)p^{5}(1-p)^{5}(1 - 2p + 2p^{2}) \\end{pmatrix} } $$", "id": "3332172"}, {"introduction": "在现实应用中，生物网络（如共表达网络）通常是加权的，而基序分析则常在无权图上进行。因此，一个关键的预处理步骤是通过阈值化将加权网络转换为无权网络，但阈值的选择对网络结构和基序分布有巨大影响。这项编程实践[@problem_id:3332155]将指导您实现一种数据驱动的方法，通过寻找一个使基序显著性（$z$-score）剖面最稳定的区域来确定最优阈值$ \\tau^\\ast $。完成此练习有助于您掌握从原始加权数据到鲁棒网络表示的完整工作流程，这是计算系统生物学中的一项关键技能。", "problem": "考虑一个加权的、对称的、对角线为零的共表达矩阵 $W \\in [0,1]^{n \\times n}$，它代表一个无向简单网络（无自环、无多重边）。在截断值 $ \\tau \\in [0,1] $ 处进行阈值化，可生成一个无权邻接矩阵 $A(\\tau)$，其定义为：如果 $i \\neq j$ 且 $W_{ij} \\ge \\tau$，则 $A_{ij}(\\tau) = 1$；否则 $A_{ij}(\\tau) = 0$。对于一个固定的 $ \\tau $，令 $G(\\tau)$ 为对应的、在 $n$ 个顶点上的简单无向图，其边集由 $A(\\tau)$ 诱导。\n\n网络模体是小的、连通或不连通的子图模式。对于无向简单图中的三节点诱导子图，存在四种由三个节点间的边数决定的同构类：$m=0$（无边）、$m=1$（恰好一条边）、$m=2$（恰好两条边，一个开放三元组）和 $m=3$（三条边，一个三角形）。令 $C_m(\\tau)$ 表示在 $G(\\tau)$ 中模体类别为 $m$ 的三节点诱导子图的数量，该数量通过遍历所有无序的不同顶点三元组计算得出。\n\n为评估模体的显著性，定义一个零模型系综，该系综包含所有在 $n$ 个顶点上且恰好有 $E(\\tau)$ 条边的简单无向图，其中 $E(\\tau)$ 是 $G(\\tau)$ 中的边数。假设从该零模型系综中进行均匀随机采样。对于每个 $ \\tau $，计算模体 $m$ 的显著性 $z$-分数：\n$$\nz_m(\\tau) = \\frac{C_m(\\tau) - \\mu_m(\\tau)}{\\sigma_m(\\tau)},\n$$\n其中 $\\mu_m(\\tau)$ 和 $\\sigma_m(\\tau)$ 分别是从边数为 $E(\\tau)$ 的零模型系综的独立样本中计算出的 $C_m$ 的均值和标准差。如果 $\\sigma_m(\\tau) = 0$，则定义 $z_m(\\tau) = 0$。\n\n定义一个阈值网格 $ \\{\\tau_k\\}_{k=0}^{K-1} $，其值在 $[0,1]$ 区间内严格递增，并通过有限差分近似导数 $ \\frac{d}{d\\tau} z_m(\\tau) $。在左边界使用向前差分，在右边界使用向后差分，在内部点使用中心差分：\n- 左边界 ($k=0$): $$ \\left.\\frac{d}{d\\tau} z_m(\\tau)\\right|_{\\tau=\\tau_0} \\approx \\frac{z_m(\\tau_1) - z_m(\\tau_0)}{\\tau_1 - \\tau_0}. $$\n- 右边界 ($k=K-1$): $$ \\left.\\frac{d}{d\\tau} z_m(\\tau)\\right|_{\\tau=\\tau_{K-1}} \\approx \\frac{z_m(\\tau_{K-1}) - z_m(\\tau_{K-2})}{\\tau_{K-1} - \\tau_{K-2}}. $$\n- 内部点 ($0  k  K-1$): $$ \\left.\\frac{d}{d\\tau} z_m(\\tau)\\right|_{\\tau=\\tau_k} \\approx \\frac{z_m(\\tau_{k+1}) - z_m(\\tau_{k-1})}{\\tau_{k+1} - \\tau_{k-1}}. $$\n\n对于每个网格点 $\\tau_k$，定义聚合灵敏度\n$$\nS(\\tau_k) = \\sum_{m \\in \\{0,1,2,3\\}} \\left| \\left.\\frac{d}{d\\tau} z_m(\\tau) \\right|_{\\tau=\\tau_k} \\right|.\n$$\n给定一个窗口半径 $r \\in \\mathbb{Z}_{\\ge 0}$，定义局部稳定性泛函\n$$\n\\mathcal{M}(\\tau_k) = \\max_{j \\in \\{ \\max(0,k-r),\\ldots,\\min(K-1,k+r) \\}} S(\\tau_j).\n$$\n令最优阈值 $ \\tau^\\ast $ 为使 $\\mathcal{M}(\\tau_k)$ 最小化的网格值；如果存在多个最小值，则选择其中最大的 $\\tau_k$ 作为最优值。\n\n您的任务是实现一个程序，该程序能够：\n1. 对每个提供的测试用例，在指定的截断值网格上对给定的共表达矩阵进行阈值化。\n2. 使用三节点诱导子图，为所有的 $m \\in \\{0,1,2,3\\}$ 和所有的 $k$ 计算 $C_m(\\tau_k)$。\n3. 使用指定数量的样本，通过均匀采样具有相同边数 $E(\\tau_k)$ 的简单无向图来构建零模型系综，并计算 $z_m(\\tau_k)$。\n4. 近似导数，计算 $S(\\tau_k)$ 和 $\\mathcal{M}(\\tau_k)$，并根据平局打破规则为每个测试用例返回 $ \\tau^\\ast $。\n5. 输出一行，其中包含所有测试用例的 $ \\tau^\\ast $ 值列表，格式为一个用方括号括起来、以逗号分隔的十进制数列表，每个数值四舍五入到三位小数（例如，$[0.350,0.650,0.725]$）。\n\n使用以下测试套件。每个测试用例提供 $(W, \\{\\tau_k\\}_{k=0}^{K-1}, r, R)$，其中 $r$ 是窗口半径，$R$是每个网格点的零模型样本数。\n\n测试用例 1 ($n=6$):\n- 矩阵 $W^{(1)}$（对称，零对角线）。对于 $i  j$：$W^{(1)}_{01} = 0.92, W^{(1)}_{02} = 0.88, W^{(1)}_{03} = 0.35, W^{(1)}_{04} = 0.28, W^{(1)}_{05} = 0.40, W^{(1)}_{12} = 0.90, W^{(1)}_{13} = 0.38, W^{(1)}_{14} = 0.30, W^{(1)}_{15} = 0.42, W^{(1)}_{23} = 0.33, W^{(1)}_{24} = 0.25, W^{(1)}_{25} = 0.37, W^{(1)}_{34} = 0.91, W^{(1)}_{35} = 0.87, W^{(1)}_{45} = 0.89$。\n- $\\tau^{(1)} \\in \\{0.20, 0.35, 0.50, 0.65, 0.80, 0.90\\}$。\n- $r^{(1)} = 1$，$R^{(1)} = 60$。\n\n测试用例 2 ($n=7$):\n- 矩阵 $W^{(2)}$（对称，零对角线）。对于 $i  j$：$W^{(2)}_{01} = 0.85, W^{(2)}_{02} = 0.90, W^{(2)}_{03} = 0.50, W^{(2)}_{04} = 0.48, W^{(2)}_{05} = 0.52, W^{(2)}_{06} = 0.77, W^{(2)}_{12} = 0.83, W^{(2)}_{13} = 0.47, W^{(2)}_{14} = 0.51, W^{(2)}_{15} = 0.49, W^{(2)}_{16} = 0.74, W^{(2)}_{23} = 0.53, W^{(2)}_{24} = 0.46, W^{(2)}_{25} = 0.50, W^{(2)}_{26} = 0.79, W^{(2)}_{34} = 0.62, W^{(2)}_{35} = 0.58, W^{(2)}_{36} = 0.44, W^{(2)}_{45} = 0.60, W^{(2)}_{46} = 0.43, W^{(2)}_{56} = 0.42$。\n- $\\tau^{(2)} \\in \\{0.10, 0.25, 0.40, 0.55, 0.70, 0.85, 0.95\\}$。\n- $r^{(2)} = 1$，$R^{(2)} = 50$。\n\n测试用例 3 ($n=8$):\n- 矩阵 $W^{(3)}$（对称，零对角线）。对于 $i  j$：$W^{(3)}_{01} = 0.82, W^{(3)}_{02} = 0.76, W^{(3)}_{03} = 0.80, W^{(3)}_{04} = 0.48, W^{(3)}_{05} = 0.42, W^{(3)}_{06} = 0.44, W^{(3)}_{07} = 0.37, W^{(3)}_{12} = 0.78, W^{(3)}_{13} = 0.74, W^{(3)}_{14} = 0.46, W^{(3)}_{15} = 0.43, W^{(3)}_{16} = 0.45, W^{(3)}_{17} = 0.39, W^{(3)}_{23} = 0.81, W^{(3)}_{24} = 0.49, W^{(3)}_{25} = 0.41, W^{(3)}_{26} = 0.47, W^{(3)}_{27} = 0.36, W^{(3)}_{34} = 0.50, W^{(3)}_{35} = 0.40, W^{(3)}_{36} = 0.46, W^{(3)}_{37} = 0.35, W^{(3)}_{45} = 0.65, W^{(3)}_{46} = 0.66, W^{(3)}_{47} = 0.64, W^{(3)}_{56} = 0.67, W^{(3)}_{57} = 0.62, W^{(3)}_{67} = 0.68$。\n- $\\tau^{(3)} \\in \\{0.30, 0.45, 0.60, 0.75\\}$。\n- $r^{(3)} = 1$，$R^{(3)} = 80$。", "solution": "该问题要求实现一种算法，为给定的加权共表达矩阵 $W$ 确定一个最优阈值 $\\tau^\\ast$。优化准则基于最小化模体显著性剖面灵敏度的局部最大值。该方法通过以下几个计算阶段进行，具体细节如下。\n\n### I. 问题验证\n\n问题陈述已经过评估，被认为是有效的。\n\n1.  **已知条件**：问题提供了加权的、对称的、对角线为零的共表达矩阵 $W$、一个阈值网格 $\\{\\tau_k\\}$、一个窗口半径 $r$ 和一个零模型样本数 $R$。它定义了对 $W$ 进行阈值化以获得邻接矩阵 $A(\\tau)$ 的过程，定义了四类三节点模体，指定了模体计数 $C_m(\\tau)$ 的计算方法，定义了具有固定边数的随机图零模型系综，定义了用于模体显著性的z-分数 $z_m(\\tau)$，提供了用于近似z-分数导数的有限差分公式，并定义了聚合灵敏度 $S(\\tau_k)$ 和局部稳定性泛函 $\\mathcal{M}(\\tau_k)$。最优阈值 $\\tau^\\ast$ 被定义为 $\\mathcal{M}(\\tau_k)$ 的最小化者，并有特定的平局打破规则。\n2.  **科学依据**：所使用的概念——共表达网络、阈值化、网络模体、使用z-分数与零模型进行显著性分析以及稳定性分析——在计算系统生物学和网络科学中是标准且成熟的。该方法论在科学上是连贯的。\n3.  **良定性**：该问题在算法上是良定义的，所有术语和步骤都已明确指定。平局打破规则的提供确保了对于给定输入存在唯一的解 $\\tau^\\ast$。\n4.  **客观性**：问题以精确、定量和客观的语言陈述，没有歧义或主观性陈述。\n\n因此，该问题是一个形式化且可解的计算任务。我们可以着手进行求解。\n\n### II. 算法求解\n\n通过对每个提供的测试用例遵循规定的步骤序列来实施解决方案。\n\n**步骤 1：在每个阈值下构建网络**\n\n对于给定网格 $\\{\\tau_k\\}_{k=0}^{K-1}$ 中的每个阈值 $\\tau_k$，将加权矩阵 $W$ 转换为一个无权的、简单的、无向的图 $G(\\tau_k)$。构建相应的邻接矩阵 $A(\\tau_k)$，使其元素 $A_{ij}(\\tau_k)$ 在权重 $W_{ij} \\ge \\tau_k$ 且 $i \\neq j$ 时为 $1$，否则为 $0$。顶点数 $n$ 是 $W$ 的维度，边数 $E(\\tau_k)$ 计算为 $E(\\tau_k) = \\frac{1}{2}\\sum_{i,j} A_{ij}(\\tau_k)$。\n\n**步骤 2：在观测网络中进行模体计数**\n\n对于每个图 $G(\\tau_k)$，我们必须计算四种三节点诱导子图同构类的出现次数。这些类别由连接三个顶点的边数 $m \\in \\{0, 1, 2, 3\\}$ 定义。令 $C_m(\\tau_k)$ 为模体类别 $m$ 的计数。一种直接且稳健的计数方法是遍历所有唯一的无序顶点三元组 $\\{i, j, k\\}$，并对每个三元组，计算其诱导子图中的边数：$e = A_{ij}(\\tau_k) + A_{ik}(\\tau_k) + A_{jk}(\\tau_k)$。这个和 $e$ 直接对应于模体类别 $m$。此类三元组的总数为 $\\binom{n}{3}$。\n\n**步骤 3：零模型模拟与显著性评分**\n\n为了评估观测到的模体计数的统计显著性，我们将它们与零模型系综中的期望计数进行比较。指定的零模型系综包含所有具有 $n$ 个顶点和 $E(\\tau_k)$ 条边的简单无向图，并进行均匀随机采样。\n\n对于每个 $\\tau_k$，我们执行以下过程：\n1.  生成 $R$ 个随机图，其中 $R$ 是指定的零模型样本数。每个随机图通过从所有 $\\binom{n}{2}$ 个可能的边中不放回地均匀随机选择 $E(\\tau_k)$ 条边来构建。\n2.  对于 $R$ 个随机图中的每一个，计算模体计数 $C_m^{(rand)}$，其中 $m \\in \\{0, 1, 2, 3\\}$。\n3.  从每个模体类别 $m$ 的 $R$ 个计数样本中，计算样本均值 $\\mu_m(\\tau_k)$ 和样本标准差 $\\sigma_m(\\tau_k)$。由于我们是从有限样本中估计总体参数，因此使用样本标准差（带有贝塞尔校正，即除以 $R-1$）是合适的。\n4.  每个模体的显著性由其z-分数来量化：\n    $$\n    z_m(\\tau_k) = \\frac{C_m(\\tau_k) - \\mu_m(\\tau_k)}{\\sigma_m(\\tau_k)}\n    $$\n    如果标准差 $\\sigma_m(\\tau_k)$ 为零（例如，对于空图或完全图，所有随机样本都产生相同的计数），则z-分数定义为 $z_m(\\tau_k) = 0$。\n\n这个过程为每个模体类别 $m$ 产生一个z-分数向量 $[z_m(\\tau_0), \\dots, z_m(\\tau_{K-1})]$。\n\n**步骤 4：灵敏度与稳定性分析**\n\n算法的下一阶段是分析模体显著性剖面在阈值网格上的稳定性。\n1.  **导数近似**：在每个网格点 $\\tau_k$ 处，使用指定的有限差分公式近似每个z-分数剖面相对于阈值的变化率 $\\frac{d}{d\\tau} z_m(\\tau)$：在起点使用向前差分，在终点使用向后差分，在内部点使用中心差分。\n2.  **聚合灵敏度**：在每个 $\\tau_k$ 处，通过对所有四个模体类别的近似导数的绝对值求和，计算一个聚合灵敏度度量 $S(\\tau_k)$：\n    $$\n    S(\\tau_k) = \\sum_{m=0}^{3} \\left| \\left.\\frac{d}{d\\tau} z_m(\\tau) \\right|_{\\tau=\\tau_k} \\right|\n    $$\n3.  **局部稳定性泛函**：为了平滑局部波动并识别整体稳定区域，计算局部稳定性泛函 $\\mathcal{M}(\\tau_k)$。对于每个 $\\tau_k$，这是以 $k$ 为中心、半径为 $r$ 的窗口内 $S$ 的最大值：\n    $$\n    \\mathcal{M}(\\tau_k) = \\max_{j \\in \\{ \\max(0, k-r), \\dots, \\min(K-1, k+r) \\}} S(\\tau_j)\n    $$\n\n**步骤 5：确定最优阈值**\n\n最优阈值 $\\tau^\\ast$ 定义为使局部稳定性泛函 $\\mathcal{M}(\\tau_k)$ 最小化的网格点 $\\tau_k$。这种选择偏好位于网络模体结构显著性剖面最稳定区域的阈值。如果多个阈值产生相同的最小值 $\\mathcal{M}$，则通过选择其中最大的阈值来打破平局。这对应于索引 $k^\\ast = \\max \\{k \\mid \\mathcal{M}(\\tau_k) = \\min_j \\mathcal{M}(\\tau_j)\\}$，因此 $\\tau^\\ast = \\tau_{k^\\ast}$。\n\n对每个测试用例执行此过程，并将得到的 $\\tau^\\ast$ 值收集起来用于最终输出。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the optimal threshold problem for the given test cases.\n    \"\"\"\n    \n    # Using a fixed random seed for reproducibility of the null model simulation.\n    np.random.seed(42)\n\n    # Test Case 1\n    W1_upper = {\n        (0,1): 0.92, (0,2): 0.88, (0,3): 0.35, (0,4): 0.28, (0,5): 0.40,\n        (1,2): 0.90, (1,3): 0.38, (1,4): 0.30, (1,5): 0.42,\n        (2,3): 0.33, (2,4): 0.25, (2,5): 0.37,\n        (3,4): 0.91, (3,5): 0.87,\n        (4,5): 0.89\n    }\n    W1 = np.zeros((6, 6))\n    for (i, j), val in W1_upper.items():\n        W1[i, j] = W1[j, i] = val\n    \n    taus1 = np.array([0.20, 0.35, 0.50, 0.65, 0.80, 0.90])\n    r1 = 1\n    R1 = 60\n\n    # Test Case 2\n    W2_upper = {\n        (0,1): 0.85, (0,2): 0.90, (0,3): 0.50, (0,4): 0.48, (0,5): 0.52, (0,6): 0.77,\n        (1,2): 0.83, (1,3): 0.47, (1,4): 0.51, (1,5): 0.49, (1,6): 0.74,\n        (2,3): 0.53, (2,4): 0.46, (2,5): 0.50, (2,6): 0.79,\n        (3,4): 0.62, (3,5): 0.58, (3,6): 0.44,\n        (4,5): 0.60, (4,6): 0.43,\n        (5,6): 0.42\n    }\n    W2 = np.zeros((7, 7))\n    for (i, j), val in W2_upper.items():\n        W2[i, j] = W2[j, i] = val\n\n    taus2 = np.array([0.10, 0.25, 0.40, 0.55, 0.70, 0.85, 0.95])\n    r2 = 1\n    R2 = 50\n\n    # Test Case 3\n    W3_upper = {\n        (0,1): 0.82, (0,2): 0.76, (0,3): 0.80, (0,4): 0.48, (0,5): 0.42, (0,6): 0.44, (0,7): 0.37,\n        (1,2): 0.78, (1,3): 0.74, (1,4): 0.46, (1,5): 0.43, (1,6): 0.45, (1,7): 0.39,\n        (2,3): 0.81, (2,4): 0.49, (2,5): 0.41, (2,6): 0.47, (2,7): 0.36,\n        (3,4): 0.50, (3,5): 0.40, (3,6): 0.46, (3,7): 0.35,\n        (4,5): 0.65, (4,6): 0.66, (4,7): 0.64,\n        (5,6): 0.67, (5,7): 0.62,\n        (6,7): 0.68\n    }\n    W3 = np.zeros((8, 8))\n    for (i, j), val in W3_upper.items():\n        W3[i, j] = W3[j, i] = val\n\n    taus3 = np.array([0.30, 0.45, 0.60, 0.75])\n    r3 = 1\n    R3 = 80\n\n    test_cases = [\n        (W1, taus1, r1, R1),\n        (W2, taus2, r2, R2),\n        (W3, taus3, r3, R3),\n    ]\n\n    results = []\n    \n    for W, taus, r, R in test_cases:\n        tau_star = find_optimal_threshold(W, taus, r, R)\n        results.append(tau_star)\n\n    print(f\"[{','.join(f'{x:.3f}' for x in results)}]\")\n\ndef count_three_node_motifs(A, n):\n    \"\"\"Counts 3-node induced subgraphs based on edge count (0, 1, 2, 3).\"\"\"\n    counts = np.zeros(4, dtype=int)\n    node_triplets = combinations(range(n), 3)\n    for i, j, k in node_triplets:\n        num_edges = A[i, j] + A[i, k] + A[j, k]\n        counts[int(num_edges)] += 1\n    return counts\n\ndef find_optimal_threshold(W, taus, r, R):\n    \"\"\"\n    Main function to find the optimal threshold for a single test case.\n    \"\"\"\n    n = W.shape[0]\n    K = len(taus)\n    z_scores = np.zeros((4, K))\n    \n    possible_edges = list(combinations(range(n), 2))\n    max_edges = len(possible_edges)\n\n    for k, tau in enumerate(taus):\n        A = (W = tau).astype(int)\n        np.fill_diagonal(A, 0)\n        \n        E = int(np.sum(A) / 2)\n        \n        C_real = count_three_node_motifs(A, n)\n\n        if E == 0 or E == max_edges:\n            z_scores[:, k] = 0.0\n            continue\n\n        C_null_samples = np.zeros((R, 4))\n        for i in range(R):\n            rand_indices = np.random.choice(max_edges, size=E, replace=False)\n            rand_A = np.zeros((n, n), dtype=int)\n            for edge_idx in rand_indices:\n                u, v = possible_edges[edge_idx]\n                rand_A[u, v] = rand_A[v, u] = 1\n            C_null_samples[i, :] = count_three_node_motifs(rand_A, n)\n            \n        mu = np.mean(C_null_samples, axis=0)\n        sigma = np.std(C_null_samples, axis=0, ddof=1) # Sample standard deviation\n        \n        for m in range(4):\n            if sigma[m]  1e-9:\n                z_scores[m, k] = 0.0\n            else:\n                z_scores[m, k] = (C_real[m] - mu[m]) / sigma[m]\n    \n    # Approximate derivatives\n    dzdt = np.zeros_like(z_scores)\n    if K  1:\n        # Left boundary\n        dzdt[:, 0] = (z_scores[:, 1] - z_scores[:, 0]) / (taus[1] - taus[0])\n        # Right boundary\n        dzdt[:, K-1] = (z_scores[:, K-1] - z_scores[:, K-2]) / (taus[K-1] - taus[K-2])\n        # Internal points\n        for k in range(1, K - 1):\n             dzdt[:, k] = (z_scores[:, k+1] - z_scores[:, k-1]) / (taus[k+1] - taus[k-1])\n    \n    # Aggregate sensitivity S(tau_k)\n    S = np.sum(np.abs(dzdt), axis=0)\n    \n    # Local stability functional M(tau_k)\n    M = np.zeros(K)\n    for k in range(K):\n        j_start = max(0, k - r)\n        j_end = min(K - 1, k + r)\n        M[k] = np.max(S[j_start : j_end + 1])\n        \n    # Find optimal tau*\n    # `np.isclose` is used to handle potential floating point inaccuracies.\n    min_M = np.min(M)\n    min_indices = np.where(np.isclose(M, min_M))[0]\n    \n    # Tie-breaking: select the largest tau_k among the minimizers\n    best_k = np.max(min_indices)\n    tau_star = taus[best_k]\n    \n    return tau_star\n    \nsolve()\n```", "id": "3332155"}, {"introduction": "简单的零模型（如固定边数的随机图）可能无法完全捕捉网络的复杂结构，导致观测到的基序富集可能仅仅是其他结构特征（如社区结构或度异质性）的副产品。这项高级编程练习[@problem_id:3332201]将引导您使用一个更复杂的零模型——度矫正随机块模型（Degree-Corrected Stochastic Block Model, DCSBM），它能够同时控制社区结构和节点的度序列。通过计算在校正这些高阶结构后的“残差”$z$-score，您将学会如何更精确地剖析基序显著性的来源，从而进行更严谨的网络科学假设检验。", "problem": "给定一组有向、简单、无自环图，每个图由一个邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 和一个块分配向量 $b \\in \\{0,1,\\dots,B-1\\}^n$ 表示。对于每个图，考虑其泊松形式的度校正随机块模型 (Degree-Corrected Stochastic Block Model, DCSBM)，其中，在给定参数的条件下，有向边是独立的泊松随机变量。DCSBM 将节点 $i$ 和 $j$ 之间的期望边率指定为 $\\lambda_{ij} = \\theta_i^{\\text{out}} \\theta_j^{\\text{in}} \\omega_{r s}$，其中 $r = b_i$ 和 $s = b_j$，并带有块特定的归一化，使得最大似然估计可识别。通过最大似然法从观测到的邻接矩阵中拟合DCSBM参数，并使用拟合的模型形成一个伯努利独立近似，其中边概率为 $p_{ij} = \\mathbb{E}[A_{ij}]$ (当 $i \\neq j$) 且 $p_{ii} = 0$。\n\n定义两种在不同节点的有序三元组 $(i,j,k)$ 上的有向 3-节点子图模体：\n- 前馈环 (FFL) 模体 $m_{\\text{FFL}}$，它在 $(i,j,k)$ 上出现当且仅当 $A_{ij} = 1$、$A_{ik} = 1$ 且 $A_{jk} = 1$。\n- 有向 3-环模体 $m_{\\circlearrowleft}$，它在 $(i,j,k)$ 上出现当且仅当 $A_{ij} = 1$、$A_{jk} = 1$ 且 $A_{ki} = 1$。\n\n对于每个图，计算：\n1. 观测计数 $C_{\\text{FFL}}$ 和 $C_{\\circlearrowleft}$，即满足上述模体边条件的有序三元组 $(i,j,k)$ 的总数。如果允许重复索引，则有序三元组的总数为 $n \\cdot (n-1) \\cdot (n-1)$，但由于 $A_{ii} = 0$ 且当索引重复时下面的乘积会包含 $A_{ii}$，因此只要您明确设置 $A_{ii} = 0$，就可以对所有有序三元组 $(i,j,k)$ 求和，而无需显式强制节点不同。\n2. 在拟合的DCSBM和伯努利独立近似下的期望计数，通过将每个 $A_{uv}$ 替换为 $p_{uv}$ 并对所有有序三元组求和得到，即\n   - $\\mathbb{E}[C_{\\text{FFL}}] = \\sum_{i,j,k} p_{ij} \\, p_{ik} \\, p_{jk}$，\n   - $\\mathbb{E}[C_{\\circlearrowleft}] = \\sum_{i,j,k} p_{ij} \\, p_{jk} \\, p_{ki}$，\n   在这两种情况下，求和遍及所有 $i,j,k \\in \\{0,1,\\dots,n-1\\}$，且 $p_{ii} = 0$。\n3. 方差的近似值，该近似在稀疏情况下忽略了由重叠三元组引起的依赖性，方法是将每个三元组的模体指示符视为独立的伯努利随机变量，其均值等于相应概率的乘积：\n   - $\\operatorname{Var}(C_{\\text{FFL}}) \\approx \\sum_{i,j,k} q_{ijk}^{\\text{FFL}} \\, (1 - q_{ijk}^{\\text{FFL}})$，其中 $q_{ijk}^{\\text{FFL}} = p_{ij} \\, p_{ik} \\, p_{jk}$，\n   - $\\operatorname{Var}(C_{\\circlearrowleft}) \\approx \\sum_{i,j,k} q_{ijk}^{\\circlearrowleft} \\, (1 - q_{ijk}^{\\circlearrowleft})$，其中 $q_{ijk}^{\\circlearrowleft} = p_{ij} \\, p_{jk} \\, p_{ki}$。\n4. 残差 $z$-分数 $z_m = \\dfrac{C_m - \\mathbb{E}[C_m]}{\\sqrt{\\operatorname{Var}(C_m)}}$，对于 $m \\in \\{\\text{FFL}, \\circlearrowleft\\}$。如果 $\\operatorname{Var}(C_m) = 0$，则定义 $z_m = 0$。\n\n您的目标是通过计算考虑了块之后的残差 $z_m$，来研究模体富集是否可以完全由社区同配性解释，其中使用通过最大似然拟合的度校正随机块模型作为零模型。\n\n使用以下图形和块标签的测试套件。在每种情况下，邻接矩阵 $A^{(t)}$ 都明确给出，行和列的索引从 $0$ 到 $n-1$，所有对角线条目都等于 $0$。\n\n测试用例 1 ($n = 6$, $B = 2$):\n- 块标签 $b^{(1)} = [\\,0,\\,0,\\,0,\\,1,\\,1,\\,1\\,]$。\n- 邻接矩阵 $A^{(1)}$：\n  $$\n  \\begin{bmatrix}\n  0  1  1  1  0  0 \\\\\n  0  0  1  0  0  0 \\\\\n  0  0  0  1  0  0 \\\\\n  1  0  0  0  1  1 \\\\\n  0  0  0  0  0  1 \\\\\n  1  0  0  0  0  0\n  \\end{bmatrix}\n  $$\n\n测试用例 2 ($n = 6$, $B = 2$):\n- 块标签 $b^{(2)} = [\\,0,\\,0,\\,0,\\,1,\\,1,\\,1\\,]$。\n- 邻接矩阵 $A^{(2)}$：\n  $$\n  \\begin{bmatrix}\n  0  1  0  1  0  0 \\\\\n  0  0  1  1  0  0 \\\\\n  0  0  0  0  1  0 \\\\\n  0  1  0  0  1  0 \\\\\n  0  0  1  0  0  1 \\\\\n  0  0  0  0  0  0\n  \\end{bmatrix}\n  $$\n\n测试用例 3 ($n = 4$, $B = 2$):\n- 块标签 $b^{(3)} = [\\,0,\\,0,\\,1,\\,1\\,]$。\n- 邻接矩阵 $A^{(3)}$：\n  $$\n  \\begin{bmatrix}\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  0  0  0  0\n  \\end{bmatrix}\n  $$\n\n所有测试用例中统一使用的实现细节和假设：\n- 通过最大似然法拟合泊松DCSBM，然后在拟合的模型下使用 $p_{ij} = \\mathbb{E}[A_{ij}]$ (当 $i \\neq j$) 且 $p_{ii} = 0$。使用数值稳定的裁剪规则 $p_{ij} \\leftarrow \\min\\{p_{ij}, 1 - \\varepsilon\\}$，其中 $\\varepsilon  0$ 是一个小数，以避免退化的概率。如果分母中的任何拟合分量为零（例如，某个块没有出边），则将相应的 $p_{ij}$ 设为 $0$。\n- 如上所述，在有序三元组上计算观测到的模体计数 $C_{\\text{FFL}}$ 和 $C_{\\circlearrowleft}$。\n- 通过对所有有序三元组的 $q(1-q)$ 求和来近似方差，其中 $q$ 等于该三元组的相关边概率的乘积，并且每当方差计算为 $0$ 时，将残差 $z$-分数设为 $0$。\n\n您的程序应该产生单行输出，其中包含按 $[\\,z_{\\text{FFL}}^{(1)}, z_{\\circlearrowleft}^{(1)}, z_{\\text{FFL}}^{(2)}, z_{\\circlearrowleft}^{(2)}, z_{\\text{FFL}}^{(3)}, z_{\\circlearrowleft}^{(3)}\\,]$ 顺序排列的六个残差 $z$-分数，作为一个用方括号括起来的逗号分隔列表，每个值四舍五入到恰好 $6$ 位小数，没有多余的空格。此任务不涉及物理单位，所有量都是纯数。不涉及角度。不使用百分比；所有输出均为十进制数。", "solution": "用户希望在多个有向图中计算两种网络模体——前馈环（FFL）和3-环——的残差z分数。此显著性分析的零模型是度校正随机块模型（DCSBM）。\n\n每个图的总体流程如下：\n1.  使用最大似然估计（MLE）从给定的邻接矩阵 $A$ 和块分配 $b$ 中拟合泊松DCSBM的参数。这提供了期望边概率 $p_{ij}$。\n2.  直接从邻接矩阵 $A$ 计算FFL和3-环模体的观测计数 $C_{\\text{FFL}}$ 和 $C_{\\circlearrowleft}$。\n3.  在拟合的DCSBM下，使用边概率矩阵 $P = [p_{ij}]$ 计算期望计数 $\\mathbb{E}[C_{\\text{FFL}}]$ 和 $\\mathbb{E}[C_{\\circlearrowleft}]$。\n4.  在独立性假设下，近似方差 $\\operatorname{Var}(C_{\\text{FFL}})$ 和 $\\operatorname{Var}(C_{\\circlearrowleft})$。\n5.  组合这些量来计算最终的残差z分数 $z_{\\text{FFL}}$ 和 $z_{\\circlearrowleft}$。\n\n我现在将详细说明这些步骤。\n\n### 步骤 1：DCSBM 的最大似然估计\n\n在其泊松形式中，度校正随机块模型（DCSBM）假设节点 $i$ 和 $j$ 之间的边数 $A_{ij}$ 是一个均值为 $\\lambda_{ij}$ 的泊松随机变量。这个期望率参数化为：\n$$ \\lambda_{ij} = \\theta_i^{\\text{out}} \\theta_j^{\\text{in}} \\omega_{b_i b_j} $$\n其中 $\\theta_i^{\\text{out}}$ 和 $\\theta_j^{\\text{in}}$ 是节点 $i$ 和 $j$ 的度校正参数，$\\omega_{rs}$ 是块 $r$ 和块 $s$ 之间边的亲和力参数。向量 $b$ 将每个节点分配到 B 个块中的一个。\n\n观测到图 $A$ 的对数似然为：\n$$ \\mathcal{L} = \\sum_{i,j} (A_{ij} \\log \\lambda_{ij} - \\lambda_{ij}) + \\text{const} $$\n最大化此似然因参数可识别性问题而变得复杂。然而，期望边数 $\\mathbb{E}[A_{ij}] = \\lambda_{ij}$ 的最大似然估计是唯一的，并且可以直接用可观测的图属性表示。根据 Karrer 和 Newman (2011) 的推导，$\\mathbb{E}[A_{ij}] = \\lambda_{ij}$ 的 MLE 由下式给出：\n$$ \\hat{\\lambda}_{ij} = \\frac{k_i^{\\text{out}} k_j^{\\text{in}} M_{b_i b_j}}{\\kappa_{b_i}^{\\text{out}} \\kappa_{b_j}^{\\text{in}}} $$\n其中：\n- $k_i^{\\text{out}} = \\sum_j A_{ij}$ 是节点 $i$ 的出度。\n- $k_j^{\\text{in}} = \\sum_i A_{ij}$ 是节点 $j$ 的入度。\n- $M_{rs} = \\sum_{i: b_i=r, j: b_j=s} A_{ij}$ 是从块 $r$ 到块 $s$ 的总边数。\n- $\\kappa_r^{\\text{out}} = \\sum_{i: b_i=r} k_i^{\\text{out}}$ 是块 $r$ 的总出度。\n- $\\kappa_s^{\\text{in}} = \\sum_{j: b_j=s} k_j^{\\text{in}}$ 是块 $s$ 的总入度。\n\n如果任何分母项（$\\kappa_{b_i}^{\\text{out}}$ 或 $\\kappa_{b_j}^{\\text{in}}$）为零，则模型没有关于涉及该块度类型的边的信息，根据题目的指示，我们将相应的 $\\hat{\\lambda}_{ij}$ 设为 $0$。\n\n问题指定使用一个伯努利独立模型，其概率为 $p_{ij} = \\mathbb{E}[A_{ij}] = \\hat{\\lambda}_{ij}$。这是对稀疏图的常见近似。由于 $\\hat{\\lambda}_{ij}$ 可能大于 $1$，我们必须裁剪概率：$p_{ij} \\leftarrow \\min\\{\\hat{\\lambda}_{ij}, 1 - \\varepsilon\\}$，其中 $\\varepsilon  0$ 是一个小数。因为没有自环，我们也强制 $p_{ii} = 0$。\n\n### 步骤 2：观测的模体计数\n\n观测计数被定义为对所有节点有序三元组 $(i, j, k)$ 的求和。这些和可以使用矩阵运算高效计算。\n\n**前馈环 (FFL):** 在 $(i,j,k)$ 上的一个FFL对应于边 $i \\to j$、$i \\to k$ 和 $j \\to k$。总计数为：\n$$ C_{\\text{FFL}} = \\sum_{i,j,k} A_{ij} A_{ik} A_{jk} $$\n这可以通过对项进行分组来重写：\n$$ C_{\\text{FFL}} = \\sum_{j,k} A_{jk} \\left( \\sum_i A_{ij} A_{ik} \\right) $$\n内部和 $\\sum_i A_{ij} A_{ik} = \\sum_i (A^T)_{ji} A_{ik}$ 是矩阵乘积 $A^T A$ 的第 $(j,k)$ 个元素。因此，总计数是 $A$ 与 $A^T A$ 的元素级乘积之和：\n$$ C_{\\text{FFL}} = \\sum_{j,k} A_{jk} (A^T A)_{jk} $$\n\n**有向 3-环:** 在 $(i,j,k)$ 上的一个 3-环对应于边 $i \\to j$、$j \\to k$ 和 $k \\to i$。总计数为：\n$$ C_{\\circlearrowleft} = \\sum_{i,j,k} A_{ij} A_{jk} A_{ki} $$\n这个和正是矩阵乘積 $A^3$ 的迹的定义：\n$$ C_{\\circlearrowleft} = \\operatorname{Tr}(A^3) $$\n每个涉及三个不同节点的唯一环路在这个和中被计算了三次，每个节点作为起始点 $i$ 时计算一次。\n\n### 步骤 3：期望模体计数\n\n在拟合模型下的期望计数通过将二元邻接矩阵 $A$ 替换为概率矩阵 $P = [p_{ij}]$ 来计算。\n$$ \\mathbb{E}[C_{\\text{FFL}}] = \\sum_{i,j,k} p_{ij} p_{ik} p_{jk} = \\sum_{j,k} p_{jk} (P^T P)_{jk} $$\n$$ \\mathbb{E}[C_{\\circlearrowleft}] = \\sum_{i,j,k} p_{ij} p_{jk} p_{ki} = \\operatorname{Tr}(P^3) $$\n\n### 步骤 4：近似方差\n\n方差通过假设不同三元组上的模体出现是独立的伯努利试验来近似。独立伯努利变量之和的方差是它们各自方差 $p(1-p)$ 的和。\n\n**FFL 方差:** 在特定三元组 $(i,j,k)$ 上出现 FFL 的概率是 $q_{ijk}^{\\text{FFL}} = p_{ij} p_{ik} p_{jk}$。\n$$ \\operatorname{Var}(C_{\\text{FFL}}) \\approx \\sum_{i,j,k} q_{ijk}^{\\text{FFL}} (1 - q_{ijk}^{\\text{FFL}}) = \\sum_{i,j,k} q_{ijk}^{\\text{FFL}} - \\sum_{i,j,k} (q_{ijk}^{\\text{FFL}})^2 $$\n第一项是 $\\mathbb{E}[C_{\\text{FFL}}]$。设 $P_2$ 是概率平方矩阵，$(P_2)_{ij} = p_{ij}^2$。第二项是：\n$$ \\sum_{i,j,k} (p_{ij} p_{ik} p_{jk})^2 = \\sum_{i,j,k} p_{ij}^2 p_{ik}^2 p_{jk}^2 = \\sum_{j,k} p_{jk}^2 \\left( \\sum_i p_{ij}^2 p_{ik}^2 \\right) = \\sum_{j,k} (P_2)_{jk} (P_2^T P_2)_{jk} $$\n\n**3-环方差:** 类似地，在 $(i,j,k)$ 上出现 3-环的概率是 $q_{ijk}^{\\circlearrowleft} = p_{ij} p_{jk} p_{ki}$。\n$$ \\operatorname{Var}(C_{\\circlearrowleft}) \\approx \\sum_{i,j,k} q_{ijk}^{\\circlearrowleft} (1 - q_{ijk}^{\\circlearrowleft}) = \\mathbb{E}[C_{\\circlearrowleft}] - \\sum_{i,j,k} (p_{ij} p_{jk} p_{ki})^2 $$\n第二项可以使用矩阵 $P_2$ 表示：\n$$ \\sum_{i,j,k} p_{ij}^2 p_{jk}^2 p_{ki}^2 = \\operatorname{Tr}(P_2^3) $$\n\n### 步骤 5：残差 Z 分数\n\n每种模体类型 $m$ 的残差 z-分数计算为观测计数和期望计数之间的标准化差异：\n$$ z_m = \\frac{C_m - \\mathbb{E}[C_m]}{\\sqrt{\\operatorname{Var}(C_m)}} $$\n根据问题的规则，如果 $\\operatorname{Var}(C_m) = 0$，则相应的 $z_m$ 设为 $0$。\n\n实现将对提供的每个测试用例应用这五个步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the residual z-scores for FFL and 3-cycle motifs\n    using a DCSBM null model.\n    \"\"\"\n\n    # Epsilon for numerical stability in clipping probabilities\n    EPSILON = 1e-10\n\n    test_cases = [\n        # Test case 1\n        (\n            np.array([\n                [0, 1, 1, 1, 0, 0],\n                [0, 0, 1, 0, 0, 0],\n                [0, 0, 0, 1, 0, 0],\n                [1, 0, 0, 0, 1, 1],\n                [0, 0, 0, 0, 0, 1],\n                [1, 0, 0, 0, 0, 0]\n            ]),\n            np.array([0, 0, 0, 1, 1, 1])\n        ),\n        # Test case 2\n        (\n            np.array([\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 1, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 1, 0, 0, 1, 0],\n                [0, 0, 1, 0, 0, 1],\n                [0, 0, 0, 0, 0, 0]\n            ]),\n            np.array([0, 0, 0, 1, 1, 1])\n        ),\n        # Test case 3\n        (\n            np.array([\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ]),\n            np.array([0, 0, 1, 1])\n        )\n    ]\n\n    all_z_scores = []\n    for A, b in test_cases:\n        z_ffl, z_cyc = compute_z_scores(A, b, EPSILON)\n        all_z_scores.extend([z_ffl, z_cyc])\n\n    print(f\"[{','.join([f'{z:.6f}' for z in all_z_scores])}]\")\n\ndef compute_z_scores(A, b, epsilon):\n    \"\"\"\n    Computes the residual z-scores for FFL and 3-cycle motifs for a single graph.\n    \n    Args:\n        A (np.ndarray): The adjacency matrix of the graph.\n        b (np.ndarray): The block assignment vector for the nodes.\n        epsilon (float): A small value for probability clipping.\n\n    Returns:\n        tuple: A tuple containing the z-scores (z_ffl, z_cyc).\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return 0.0, 0.0\n        \n    num_blocks = np.max(b) + 1 if b.size  0 else 0\n\n    # Step 1: Fit DCSBM and get probability matrix P\n    k_out = A.sum(axis=1)\n    k_in = A.sum(axis=0)\n\n    M = np.zeros((num_blocks, num_blocks))\n    for r in range(num_blocks):\n        for s in range(num_blocks):\n            nodes_r = np.where(b == r)[0]\n            nodes_s = np.where(b == s)[0]\n            if nodes_r.size  0 and nodes_s.size  0:\n                M[r, s] = A[np.ix_(nodes_r, nodes_s)].sum()\n\n    kappa_out = np.zeros(num_blocks)\n    kappa_in = np.zeros(num_blocks)\n    for r in range(num_blocks):\n        nodes_r = np.where(b == r)[0]\n        if nodes_r.size  0:\n            kappa_out[r] = k_out[nodes_r].sum()\n            kappa_in[r] = k_in[nodes_r].sum()\n\n    P = np.zeros((n, n), dtype=float)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            r, s = b[i], b[j]\n            denom = kappa_out[r] * kappa_in[s]\n            if denom  0:\n                lambda_ij = k_out[i] * k_in[j] * M[r, s] / denom\n                P[i, j] = min(lambda_ij, 1.0 - epsilon)\n\n    # Step 2: Observed Motif Counts\n    C_ffl = np.sum(A * (A.T @ A))\n    C_cyc = np.trace(A @ A @ A)\n\n    # Step 3: Expected Motif Counts\n    E_ffl = np.sum(P * (P.T @ P))\n    E_cyc = np.trace(P @ P @ P)\n\n    # Step 4: Approximate Variances\n    P2 = P**2\n    \n    # FFL Variance\n    sum_q_sq_ffl = np.sum(P2 * (P2.T @ P2))\n    var_ffl = E_ffl - sum_q_sq_ffl\n    \n    # 3-Cycle Variance\n    if n  0:\n        P2_cubed = P2 @ P2 @ P2\n        sum_q_sq_cyc = np.trace(P2_cubed)\n    else:\n        sum_q_sq_cyc = 0\n    var_cyc = E_cyc - sum_q_sq_cyc\n    \n    # Prevent negative variance due to numerical precision issues\n    var_ffl = max(0, var_ffl)\n    var_cyc = max(0, var_cyc)\n\n    # Step 5: Residual Z-Scores\n    z_ffl = 0.0\n    if var_ffl  0:\n        z_ffl = (C_ffl - E_ffl) / np.sqrt(var_ffl)\n        \n    z_cyc = 0.0\n    if var_cyc  0:\n        z_cyc = (C_cyc - E_cyc) / np.sqrt(var_cyc)\n\n    return z_ffl, z_cyc\n\nsolve()\n```", "id": "3332201"}]}