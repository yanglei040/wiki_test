{"hands_on_practices": [{"introduction": "在我们探讨如何校正多重检验之前，我们必须首先理解单个p值是如何产生的。这个练习 ([@problem_id:3351012]) 通过让学生们亲手实现一个精确的置换检验来揭开p值的神秘面纱。这是一种稳健的非参数方法，其核心在于零假设下的“可交换性”这一基本原则，这在分布假设可能存在问题的基因组学领域是统计推断的基石。", "problem": "给定一个在 $n = n_1 + n_2$ 个生物样本中测得的分子表型，其中 $n_1$ 个样本被指定为“病例”（case），$n_2$ 个样本被指定为“对照”（control）。在无关联的原假设下，标签是可交换的，精确置换检验会枚举所有 $\\binom{n}{n_1}$ 种不同的标签分配方式。这些分配方式是通过将 $n$ 个观测测量值重新分配到两个组中，同时保持组的大小不变而获得的。使用具有等方差合并估计的双样本 $t$ 统计量作为检验统计量。对于任何固定的标签分配，如果 $\\bar{x}_1$ 和 $\\bar{x}_2$ 表示两组的样本均值，$s_1^2$ 和 $s_2^2$ 表示无偏样本方差，$s_p$ 表示合并标准差，则对于 $n_1 \\ge 2$ 和 $n_2 \\ge 2$ 的情况，该统计量定义为\n$$\nt \\;=\\; \\frac{\\bar{x}_1 - \\bar{x}_2}{s_p \\,\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}}\\,,\n\\quad \\text{with} \\quad\ns_p \\;=\\; \\sqrt{\\frac{(n_1-1)s_1^2 + (n_2-1)s_2^2}{n_1 + n_2 - 2}}\\,.\n$$\n如果 $s_p = 0$ 且 $\\bar{x}_1 \\neq \\bar{x}_2$，则定义 $|t| = +\\infty$。如果 $s_p = 0$ 且 $\\bar{x}_1 = \\bar{x}_2$，则定义 $t = 0$。精确的双边置换 $p$ 值是所有置换中满足 $|t| \\ge |t_{\\mathrm{obs}}|$ 的置换所占的比例，其中 $t_{\\mathrm{obs}}$ 是在原始标签分配下观测到的统计量。\n\n您的任务是编写一个完整的、可运行的程序，该程序针对几个指定的测试用例，通过枚举所有 $\\binom{n}{n_1}$ 种标签分配并计算满足 $|t| \\ge |t_{\\mathrm{obs}}|$ 的比例来计算这个精确的双边置换 $p$ 值。这是原假设下可交换性的直接结果，不需要任何参数近似。\n\n所有答案都必须以无量纲的十进制数形式产生。比较实数时必须使用一个微小的绝对容差 $\\varepsilon = 10^{-12}$，以避免在判断 $|t| \\ge |t_{\\mathrm{obs}}|$ 时出现浮点误差。\n\n使用以下测试套件。在所有情况下，$n_1 = 4$ 且 $n_2 = 5$，因此 $\\binom{n}{n_1} = \\binom{9}{4} = 126$。\n\n- 测试用例 1（理想路径，科学上现实，经过精确构造以使观测统计量等于所述阈值）：使用 $n = 9$ 个观测测量值\n  $$\n  \\bigl[\n  0.3809919006126299,\\;\n  1.1555885698541132,\\;\n  1.9301852390955966,\\;\n  2.7047819083370800,\\;\n  -1.2649110640673518,\\;\n  -0.6324555320336759,\\;\n  0.0000000000000000,\\;\n  0.6324555320336759,\\;\n  1.2649110640673518\n  \\bigr]\n  $$\n  其中最初观测到的“病例”是前 4 个条目，“对照”是后 5 个条目。此标签分配的观测统计量为 $t_{\\mathrm{obs}} = 2.3$。计算精确的双边置换 $p$ 值，即在 $\\binom{9}{4}$ 种标签分配中满足 $|t| \\ge 2.3$ 的比例。\n\n- 测试用例 2（退化边界，合并方差恒为零）：使用 $n = 9$ 个测量值\n  $$\n  \\bigl[ 0.0,\\; 0.0,\\; 0.0,\\; 0.0,\\; 0.0,\\; 0.0,\\; 0.0,\\; 0.0,\\; 0.0 \\bigr],\n  $$\n  其中 $t_{\\mathrm{obs}} = 0.0$。根据定义，如果 $s_p = 0$ 且组均值相等，则为该标签分配设置 $t = 0$。计算精确的双边置换 $p$ 值，即在 $\\binom{9}{4}$ 种标签分配中满足 $|t| \\ge 0.0$ 的比例。\n\n- 测试用例 3（严格阈值边缘情况）：重用测试用例 1 的测量值，并设置 $t_{\\mathrm{obs}} = 10.0$。计算在 $\\binom{9}{4}$ 种标签分配中满足 $|t| \\ge 10.0$ 的比例。\n\n您的程序必须：\n- 为每种标签分配实现如上定义的双样本合并 $t$ 统计量。\n- 枚举所有 $\\binom{n}{n_1}$ 种病例标签分配，并使用 $\\varepsilon = 10^{-12}$ 计数满足 $|t| \\ge |t_{\\mathrm{obs}}| - \\varepsilon$ 的数量。\n- 对于每个测试用例，返回精确的双边置换 $p$ 值，该值等于计数除以 $\\binom{n}{n_1}$ 的十进制数。\n\n最终输出格式：\n- 您的程序应生成一行，其中包含所有测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，例如 $\\bigl[\\text{result}_1,\\text{result}_2,\\text{result}_3\\bigr]$。\n- 每个结果必须格式化为小数点后恰好有 $6$ 位数字的十进制数。\n\n不需要外部输入。所有常量和数据均已在上方提供。程序必须是自包含的，并且可以在任何支持指定库和版本的现代环境中运行。不涉及角度。所有输出都是无单位的。输出必须可重现至指定精度。", "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上基于非参数统计推断的原理，定义和数据清晰完整，问题阐述得当，并以客观、正式的语言表达。因此，我们可以进行完整的解答。\n\n该问题要求计算双样本 $t$ 统计量的精确双边置换 $p$ 值。在计算生物学和其他领域，这种方法是统计假设检验的基础，特别是当参数检验的假设（例如，数据正态性）不满足或不希望作出此类假设时。\n\n置换检验的核心原理是原假设（$H_0$）下的可交换性。原假设假定分子表型与病例/对照状态之间没有关联。如果 $H_0$ 为真，那么将“病例”或“对照”标签分配给观测到的测量值是任意的。这些标签的任何置换都是等可能的。置换检验通过为选定的检验统计量生成一个零分布来实施这一原理。这是通过计算数据所有可能的重新标记（同时保留原始组大小 $n_1$ 和 $n_2$）的统计量来实现的。\n\n将 $n_1$ 个“病例”标签分配给一组 $n = n_1 + n_2$ 个测量值的不同方式总数由二项式系数 $\\binom{n}{n_1}$ 给出。对于每一种标签分配，我们都计算检验统计量 $t$。这些 $t$ 值的集合构成了精确的零分布。\n\n规定的检验统计量是假设方差相等的双样本 $t$ 统计量：\n$$\nt \\;=\\; \\frac{\\bar{x}_1 - \\bar{x}_2}{s_p \\,\\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}}\n$$\n其中 $\\bar{x}_1$ 和 $\\bar{x}_2$ 是给定置换中两组的样本均值，$s_p$ 是合并标准差：\n$$\ns_p \\;=\\; \\sqrt{\\frac{(n_1-1)s_1^2 + (n_2-1)s_2^2}{n_1 + n_2 - 2}}\n$$\n这里，$s_1^2$ 和 $s_2^2$ 是无偏样本方差。条件 $n_1 \\ge 2$ 和 $n_2 \\ge 2$ 确保了样本方差和 $s_p$ 公式中的分母是良定义的。\n\n问题正确地指定了当合并标准差 $s_p = 0$ 时的退化情况处理。这种情况当且仅当每个组内的方差为零时发生（即，第 1 组内的所有测量值都相同，且第 2 组内的所有测量值都相同）。\n- 如果 $s_p = 0$ 且组均值不同（$\\bar{x}_1 \\neq \\bar{x}_2$），则效应大小相对于零变异是最大的，因此 $|t|$ 定义为 $+\\infty$。\n- 如果 $s_p = 0$ 且组均值相同（$\\bar{x}_1 = \\bar{x}_2$），则两组之间没有差异，因此 $t$ 定义为 $0$。\n\n双边置换 $p$ 值是在零分布中，检验统计量的绝对值 $|t|$ 大于或等于使用原始数据标签观测到的统计量的绝对值 $|t_{\\mathrm{obs}}|$ 的置换所占的比例。\n$$\np\\text{-value} \\;=\\; \\frac{\\text{满足 } |t| \\ge |t_{\\mathrm{obs}}|\\text{ 的置换数}}{\\text{总置换数}}\n$$\n为了处理浮点运算误差，比较被实现为 $|t| \\ge |t_{\\mathrm{obs}}| - \\varepsilon$，其中 $\\varepsilon = 10^{-12}$ 是一个很小的容差。\n\n计算策略如下：\n1.  对每个测试用例，取 $n$ 个测量值的向量以及组大小 $n_1$ 和 $n_2$。\n2.  从所有索引集合 $\\{0, 1, \\dots, n-1\\}$ 中生成所有大小为 $n_1$ 的唯一索引组合。每个组合代表将测量值分配给“病例”组的一种可能方式。剩下的 $n_2$ 个索引将构成“对照”组。对于给定的参数 $n_1=4$ 和 $n=9$，共有 $\\binom{9}{4}=126$ 种这样的组合。\n3.  对于这 126 个置换中的每一个：\n    a. 将数据划分为一个病例组 ($x_1$) 和一个对照组 ($x_2$)\n    b. 计算均值 $\\bar{x}_1, \\bar{x}_2$ 和无偏样本方差 $s_1^2, s_2^2$。\n    c. 计算合并标准差 $s_p$，并使用数值容差处理 $s_p=0$ 的情况。\n    d. 计算 $t$ 统计量 $t_{perm}$，并在 $s_p = 0$ 时应用特殊定义。\n    e. 使用指定的容差比较 $|t_{perm}|$ 和 $|t_{\\mathrm{obs}}|$。如果 $|t_{perm}| \\ge |t_{\\mathrm{obs}}| - \\varepsilon$，则将计数器加一。\n4.  最终的 $p$ 值是步骤 3e 的总计数除以总置换数（126）。\n\n此过程将应用于指定的三个测试用例中的每一个。\n- **测试用例 1：** 一个标准的、科学上现实的场景，其中观测统计量 $t_{\\mathrm{obs}} = 2.3$ 是非平凡的。\n- **测试用例 2：** 一个所有测量值都为零的退化情况。这测试了实现对零方差的处理。对于任何置换，所有组的值都将为 $0$。因此，$\\bar{x}_1=\\bar{x}_2=0$ 且 $s_p=0$，导致所有置换的 $t=0$。由于 $t_{\\mathrm{obs}}=0$，条件 $|t| \\ge |t_{\\mathrm{obs}}|$ 总是满足，因此 $p$ 值预期为 $1.0$。\n- **测试用例 3：** 一个边缘情况，重用测试用例 1 的数据，但使用一个非常严格的阈值 $t_{\\mathrm{obs}}=10.0$。我们预计很少（甚至没有）置换会产生如此极端的统计量。$p$ 值预计会非常小，可能为 $0$。\n\n该实现将使用 `numpy` 进行高效的数组操作，并使用标准库中的 `itertools.combinations` 来枚举标签分配。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef calculate_t_statistic(x1: np.ndarray, x2: np.ndarray) - float:\n    \"\"\"\n    Computes the two-sample pooled t-statistic.\n    \n    Handles the special case where the pooled standard deviation is zero.\n    \"\"\"\n    n1, n2 = len(x1), len(x2)\n    \n    # Per problem statement, n1 = 2 and n2 = 2, so sample variance is well-defined.\n    mean1 = np.mean(x1)\n    mean2 = np.mean(x2)\n    \n    var1 = np.var(x1, ddof=1)\n    var2 = np.var(x2, ddof=1)\n\n    # Check for the condition leading to sp = 0\n    # s_p = 0 iff var1 = 0 and var2 = 0\n    # Using a small tolerance for floating point comparison\n    is_var1_zero = np.isclose(var1, 0.0)\n    is_var2_zero = np.isclose(var2, 0.0)\n\n    if is_var1_zero and is_var2_zero:\n        if np.isclose(mean1, mean2):\n            return 0.0\n        else:\n            return np.inf\n\n    # Calculate pooled standard deviation\n    sp_sq_numerator = (n1 - 1) * var1 + (n2 - 1) * var2\n    sp_sq_denominator = n1 + n2 - 2\n    \n    # Denominator is guaranteed to be  0 since n1, n2 = 2.\n    sp_sq = sp_sq_numerator / sp_sq_denominator\n    \n    # sp can become numerically zero even if variances aren't exactly zero\n    if np.isclose(sp_sq, 0.0):\n        if np.isclose(mean1, mean2):\n            return 0.0\n        else:\n            return np.inf\n            \n    sp = np.sqrt(sp_sq)\n    \n    # Calculate t-statistic\n    t_numerator = mean1 - mean2\n    t_denominator = sp * np.sqrt(1/n1 + 1/n2)\n    \n    if np.isclose(t_denominator, 0.0): # Should not happen due to sp check, but for safety\n        return np.inf if not np.isclose(t_numerator, 0.0) else 0.0\n        \n    return t_numerator / t_denominator\n\ndef compute_permutation_p_value(data: np.ndarray, n1: int, n2: int, t_obs: float, epsilon: float) - float:\n    \"\"\"\n    Computes the exact two-sided permutation p-value for a t-statistic.\n    \n    Enumerates all possible labelings and counts the fraction where\n    the absolute permuted t-statistic is = the absolute observed t-statistic.\n    \"\"\"\n    n = n1 + n2\n    indices = np.arange(n)\n    \n    count_exceeding = 0\n    total_permutations = 0\n    \n    abs_t_obs = abs(t_obs)\n    \n    for case_indices in itertools.combinations(indices, n1):\n        total_permutations += 1\n        \n        # Create a boolean mask for efficient indexing\n        mask = np.zeros(n, dtype=bool)\n        mask[list(case_indices)] = True\n        \n        x1 = data[mask]\n        x2 = data[~mask]\n        \n        t_perm = calculate_t_statistic(x1, x2)\n        \n        if abs(t_perm) = abs_t_obs - epsilon:\n            count_exceeding += 1\n            \n    if total_permutations == 0:\n        return 0.0\n        \n    return count_exceeding / total_permutations\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Define common parameters and the comparison tolerance\n    n1, n2 = 4, 5\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"data\": np.array([\n                0.3809919006126299, 1.1555885698541132, 1.9301852390955966,\n                2.7047819083370800, -1.2649110640673518, -0.6324555320336759,\n                0.0000000000000000, 0.6324555320336759, 1.2649110640673518\n            ]),\n            \"t_obs\": 2.3\n        },\n        {\n            \"data\": np.array([0.0] * 9),\n            \"t_obs\": 0.0\n        },\n        {\n            \"data\": np.array([ # Reusing data from test case 1\n                0.3809919006126299, 1.1555885698541132, 1.9301852390955966,\n                2.7047819083370800, -1.2649110640673518, -0.6324555320336759,\n                0.0000000000000000, 0.6324555320336759, 1.2649110640673518\n            ]),\n            \"t_obs\": 10.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_value = compute_permutation_p_value(\n            data=case[\"data\"],\n            n1=n1,\n            n2=n2,\n            t_obs=case[\"t_obs\"],\n            epsilon=epsilon\n        )\n        results.append(p_value)\n\n    # Format the final output string as specified\n    formatted_results = ','.join([f\"{r:.6f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "3351012"}, {"introduction": "一旦我们进行了大量检验，就会面临多重比较问题。这个练习 ([@problem_id:3351050]) 将探讨最严格的错误控制形式：族系错误率（Family-Wise Error Rate, FWER）。通过手动应用Bonferroni、Holm和Hochberg程序，学生将直观地感受到在简单性、错误控制和统计功效之间的权衡。", "problem": "在一项计算系统生物学研究中，一位研究人员评估了两种条件下五个不相交通路的差异活性。这五个通路是经过筛选的，每个通路都由一个源自独立基因集的综合得分来表示。对于每个通路，都进行了一次假设检验，使用一个能产生有效 $p$-值的良好校准检验方法，来比较两种条件下的活性得分。假设通路水平的检验满足逐步族错误率（FWER）控制程序有效的条件，例如检验统计量的独立性或正相关性。\n\n研究人员旨在使用三种经典程序将族错误率（FWER）控制在 $\\alpha=0.05$ 的水平：Bonferroni校正、Holm降步程序和Hochberg升步程序。五个通路排序后的 $p$-值为 $p_{(1)}=0.002$，$p_{(2)}=0.01$，$p_{(3)}=0.03$，$p_{(4)}=0.07$ 和 $p_{(5)}=0.2$，总共有 $m=5$ 个假设。\n\n从FWER和有效多重检验程序的核心定义出发，确定每种方法拒绝了多少个原假设。将你的最终答案以（Bonferroni, Holm, Hochberg）的顺序报告为一行三个数字。无需四舍五入。", "solution": "首先验证问题陈述，以确保其具有科学依据、是良定的、客观且完整的。\n\n### 步骤1：提取已知条件\n- 假设（通路）总数，$m = 5$。\n- 期望的族错误率（FWER）控制水平，$\\alpha = 0.05$。\n- 五个假设检验针对的是不相交的通路，并且假设它们的检验统计量是独立的或表现出正相关性，这使得Holm和Hochberg程序的使用是有效的。\n- 假设检验得到的排序后的 $p$-值为：\n  - $p_{(1)} = 0.002$\n  - $p_{(2)} = 0.01$\n  - $p_{(3)} = 0.03$\n  - $p_{(4)} = 0.07$\n  - $p_{(5)} = 0.2$\n- 需要评估的三种多重检验程序是：Bonferroni校正、Holm降步程序和Hochberg升步程序。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于统计推断，特别是多重假设检验，这是计算系统生物学和许多其他科学领域的一个关键课题。Bonferroni、Holm和Hochberg程序是控制FWER的标准、成熟的方法。所提供的假设（独立性或正相关性）是证明这些程序有效的标准条件。\n- **良定性：** 该问题定义清晰，包含了所有必要的数值（$m$、$\\alpha$和$p$-值集合）以及一个具体的目标（确定每种方法的拒绝次数）。通过应用这三种程序的定义，可以得出一个唯一且有意义的解。\n- **客观性：** 问题以精确、定量且无偏见的语言陈述。没有主观因素或观点。\n\n### 步骤3：结论与行动\n该问题是有效的。它是多重假设检验基本原理的一个直接且形式良好的应用。将继续进行求解。\n\n目标是确定由三种旨在将族错误率（FWER）控制在$\\alpha = 0.05$水平的多重检验程序所拒绝的原假设的数量。FWER是在一系列假设检验中犯下至少一个I类错误（错误地拒绝一个真实的原假设）的概率。我们已知有 $m=5$ 个假设，其排序后的$p$-值为 $p_{(1)} \\le p_{(2)} \\le p_{(3)} \\le p_{(4)} \\le p_{(5)}$。\n\n**1. Bonferroni校正**\n\nBonferroni校正是一种单步法，如果任何原假设 $H_i$ 对应的 $p$-值 $p_i$ 满足不等式：\n$$p_i \\le \\frac{\\alpha}{m}$$\n则拒绝该假设。在这种情况下，调整后的显著性阈值为 $\\frac{0.05}{5} = 0.01$。我们将每个 $p$-值与此阈值进行比较。\n- $p_{(1)} = 0.002 \\le 0.01$。拒绝原假设 $H_{(1)}$。\n- $p_{(2)} = 0.01 \\le 0.01$。拒绝原假设 $H_{(2)}$。\n- $p_{(3)} = 0.03 > 0.01$。不拒绝原假设 $H_{(3)}$。\n- $p_{(4)} = 0.07 > 0.01$。不拒绝原假设 $H_{(4)}$。\n- $p_{(5)} = 0.2 > 0.01$。不拒绝原假设 $H_{(5)}$。\n\nBonferroni程序拒绝了两个假设。\n\n**2. Holm降步程序**\n\nHolm程序是一种序列降步法，它比Bonferroni校正一致更优。该程序将排序后的 $p$-值与依次减小保守性的阈值进行检验。对于 $j = 1, 2, \\dots, m$，我们比较 $p_{(j)}$ 和 $\\frac{\\alpha}{m - j + 1}$。程序从最小的 $p$-值开始，在第一个不满足不等式的地方停止。\n\n- **步骤 1 ($j=1$):** 比较 $p_{(1)}$ 与 $\\frac{\\alpha}{m - 1 + 1} = \\frac{0.05}{5} = 0.01$。\n  $p_{(1)} = 0.002 \\le 0.01$。条件满足。我们拒绝 $H_{(1)}$ 并进行下一步。\n\n- **步骤 2 ($j=2$):** 比较 $p_{(2)}$ 与 $\\frac{\\alpha}{m - 2 + 1} = \\frac{0.05}{4} = 0.0125$。\n  $p_{(2)} = 0.01 \\le 0.0125$。条件满足。我们拒绝 $H_{(2)}$ 并进行下一步。\n\n- **步骤 3 ($j=3$):** 比较 $p_{(3)}$ 与 $\\frac{\\alpha}{m - 3 + 1} = \\frac{0.05}{3} \\approx 0.0167$。\n  $p_{(3)} = 0.03 > 0.0167$。条件不满足。程序停止。\n\n根据Holm程序，我们拒绝假设 $H_{(1)}$ 和 $H_{(2)}$，并且未能拒绝 $H_{(3)}$、$H_{(4)}$ 和 $H_{(5)}$。因此，Holm程序拒绝了两个假设。\n\n**3. Hochberg升步程序**\n\nHochberg程序是一种序列升步法，（在给定的独立性或正相关性假设下）它比Holm程序一致更优。它从最大的 $p$-值开始，向最小的进行检验。目标是找到满足以下条件的最大索引 $k \\in \\{1, 2, \\dots, m\\}$：\n$$p_{(k)} \\le \\frac{\\alpha}{m - k + 1}$$\n如果找到了这样的 $k$，那么所有假设 $H_{(1)}, \\dots, H_{(k)}$ 都将被拒绝。\n\n- **步骤 1 (检验 $k=5$):** 比较 $p_{(5)}$ 与 $\\frac{\\alpha}{m - 5 + 1} = \\frac{0.05}{1} = 0.05$。\n  $p_{(5)} = 0.2 > 0.05$。条件不满足。\n\n- **步骤 2 (检验 $k=4$):** 比较 $p_{(4)}$ 与 $\\frac{\\alpha}{m - 4 + 1} = \\frac{0.05}{2} = 0.025$。\n  $p_{(4)} = 0.07 > 0.025$。条件不满足。\n\n- **步骤 3 (检验 $k=3$):** 比较 $p_{(3)}$ 与 $\\frac{\\alpha}{m - 3 + 1} = \\frac{0.05}{3} \\approx 0.0167$。\n  $p_{(3)} = 0.03 > 0.0167$。条件不满足。\n\n- **步骤 4 (检验 $k=2$):** 比较 $p_{(2)}$ 与 $\\frac{\\alpha}{m - 2 + 1} = \\frac{0.05}{4} = 0.0125$。\n  $p_{(2)} = 0.01 \\le 0.0125$。条件满足。\n\n满足不等式的最大索引 $k$ 是 $k=2$。因此，Hochberg程序拒绝从 $H_{(1)}$到 $H_{(k=2)}$ 的所有假设，即包括 $H_{(1)}$ 和 $H_{(2)}$。Hochberg程序拒绝了两个假设。\n\n总结：\n- Bonferroni拒绝数量：$2$\n- Holm拒绝数量：$2$\n- Hochberg拒绝数量：$2$\n最终答案是这三个计数的行向量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  2  2\n\\end{pmatrix}\n}\n$$", "id": "3351050"}, {"introduction": "在许多大规模研究中，控制FWER可能过于保守，导致我们错失真正的发现。这个练习 ([@problem_id:3351031]) 介绍了错误发现率（False Discovery Rate, FDR）以及q值这一强大概念。学生将学习如何估计真实零假设的比例（$\\pi_0$），并利用它来计算自适应的显著性阈值，这是现代计算生物学分析中的一项核心技术。", "problem": "在一项计算系统生物学实验中，对六个候选调控基因进行差异表达筛选，假设六个检验的独立零假设 $p$-值为 $(0.001, 0.01, 0.04, 0.2, 0.5, 0.7)$。令检验总数为 $m=6$。真实零假设的比例记为 $\\pi_{0}$，且未知。在标准假设下，即零假设 $p$-值独立同分布于 $[0,1]$ 上的均匀分布，且非零假设 $p$-值在随机意义上小于均匀分布，考虑用于多重检验的错误发现率 (FDR) 框架。\n\n使用 Storey 的方法，并取调节参数 $\\lambda=0.5$，完成以下任务：\n- 从均匀零假设属性和高于某个阈值的 $p$-值的期望计数的定义出发，推导出一个估计量 $\\hat{\\pi}_{0}$，并对给定的数据计算其值。\n- 将每个检验的 $q$-值定义为其 $p$-值阈值或更高阈值下的最小估计 FDR，并基于 $\\hat{\\pi}_{0}$ 和排序后的 $p$-值推导一个可计算的表达式。然后计算这六个检验的 $q$-值，并按照原始 $p$-值 $(0.001, 0.01, 0.04, 0.2, 0.5, 0.7)$ 的顺序报告。\n- 确定在 $q \\le 0.1$ 水平下哪些检验是显著的。\n\n以精确形式（不要四舍五入）表示所有计算量。将最终答案表示为一个单行矩阵，其条目依次为：首先是 $\\hat{\\pi}_{0}$，然后是按原始 $p$-值顺序排列的六个 $q$-值，最后是在 $q \\le 0.1$ 水平下显著的检验的索引（按升序排列）。", "solution": "该问题是良定且科学上有效的，要求应用Storey的方法来估计 $\\pi_0$ 并计算q值。我们将按步骤进行。\n\n### 第1步：估计真实零假设的比例 $\\hat{\\pi}_{0}$\n\nStorey的方法基于以下原理：在零假设下，$p$-值服从 $[0,1]$ 上的均匀分布。因此，对于一个给定的阈值 $\\lambda$，来自真实零假设的 $p$-值大于 $\\lambda$ 的概率是 $1-\\lambda$。对于全部 $m$ 个检验，其中有 $m_0 = \\pi_0 m$ 个是真实零假设，我们期望有 $\\pi_0 m (1-\\lambda)$ 个来自真实零假设的 $p$-值会大于 $\\lambda$。来自备择假设的 $p$-值倾向于更小，因此我们可以假设大于 $\\lambda$ 的 $p$-值主要来自真实零假设。\n\n这引出了对 $\\pi_0$ 的估计量：\n$$ \\hat{\\pi}_{0}(\\lambda) = \\frac{\\#\\{p_i > \\lambda\\}}{m(1-\\lambda)} $$\n给定数据：\n- $p$-值集合: $(0.001, 0.01, 0.04, 0.2, 0.5, 0.7)$\n- 检验总数 $m=6$\n- 调节参数 $\\lambda=0.5$\n\n我们首先计算大于 $\\lambda=0.5$ 的 $p$-值的数量：\n$\\#\\{p_i > 0.5\\} = \\#\\{0.7\\} = 1$。\n（注意：$p$-值为 $0.5$ 的检验不包含在内，因为是不等式是严格大于）。\n\n现在代入公式：\n$$ \\hat{\\pi}_{0}(0.5) = \\frac{1}{6 \\times (1-0.5)} = \\frac{1}{6 \\times 0.5} = \\frac{1}{3} $$\n因此，$\\hat{\\pi}_{0} = \\frac{1}{3}$。\n\n### 第2步：计算q值\n\nq值是p值在FDR框架下的对应物。对于一个特定的 $p$-值 $p_i$，其q值是在所有 $p_j \\ge p_i$ 的检验集合中可以达到的最小估计FDR。Storey-Tibshirani程序的计算步骤如下：\n\n1.  将 $p$-值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n    $p_{(1)}=0.001, p_{(2)}=0.01, p_{(3)}=0.04, p_{(4)}=0.2, p_{(5)}=0.5, p_{(6)}=0.7$。\n\n2.  从最大的 $p$-值 $p_{(m)}$ 开始，逆序计算每个 $p_{(i)}$ 的q值。$p_{(i)}$ 的q值 $q_{(i)}$ 定义为：\n    $$ q_{(i)} = \\min_{j=i, \\dots, m} \\left( \\frac{\\hat{\\pi}_{0} \\cdot m \\cdot p_{(j)}}{j} \\right) $$\n    这确保了q值是单调递增的。为了简化计算，我们先计算每个 $i$ 的中间量 $q'_{(i)} = \\frac{\\hat{\\pi}_{0} \\cdot m \\cdot p_{(i)}}{i}$，然后再强制单调性。\n    我们已知 $\\hat{\\pi}_{0} \\cdot m = \\frac{1}{3} \\cdot 6 = 2$。\n\n    - $i=1: q'_{(1)} = \\frac{2 \\times 0.001}{1} = 0.002 = \\frac{1}{500}$\n    - $i=2: q'_{(2)} = \\frac{2 \\times 0.01}{2} = 0.01 = \\frac{1}{100}$\n    - $i=3: q'_{(3)} = \\frac{2 \\times 0.04}{3} = \\frac{0.08}{3} = \\frac{8}{300} = \\frac{2}{75}$\n    - $i=4: q'_{(4)} = \\frac{2 \\times 0.2}{4} = \\frac{0.4}{4} = 0.1 = \\frac{1}{10}$\n    - $i=5: q'_{(5)} = \\frac{2 \\times 0.5}{5} = \\frac{1}{5} = 0.2 = \\frac{1}{5}$\n    - $i=6: q'_{(6)} = \\frac{2 \\times 0.7}{6} = \\frac{1.4}{6} = \\frac{14}{60} = \\frac{7}{30}$\n\n3.  强制单调性：$q_{(i)} = \\min(q_{(i+1)}, q'_{(i)})$。\n    - $q_{(6)} = q'_{(6)} = \\frac{7}{30}$\n    - $q_{(5)} = \\min(q_{(6)}, q'_{(5)}) = \\min(\\frac{7}{30}, \\frac{1}{5}) = \\min(\\frac{7}{30}, \\frac{6}{30}) = \\frac{6}{30} = \\frac{1}{5}$\n    - $q_{(4)} = \\min(q_{(5)}, q'_{(4)}) = \\min(\\frac{1}{5}, \\frac{1}{10}) = \\frac{1}{10}$\n    - $q_{(3)} = \\min(q_{(4)}, q'_{(3)}) = \\min(\\frac{1}{10}, \\frac{2}{75}) = \\min(\\frac{7.5}{75}, \\frac{2}{75}) = \\frac{2}{75}$\n    - $q_{(2)} = \\min(q_{(3)}, q'_{(2)}) = \\min(\\frac{2}{75}, \\frac{1}{100}) = \\min(\\frac{8}{300}, \\frac{3}{300}) = \\frac{3}{300} = \\frac{1}{100}$\n    - $q_{(1)} = \\min(q_{(2)}, q'_{(1)}) = \\min(\\frac{1}{100}, \\frac{1}{500}) = \\frac{1}{500}$\n\n    排序后的q值为：$(\\frac{1}{500}, \\frac{1}{100}, \\frac{2}{75}, \\frac{1}{10}, \\frac{1}{5}, \\frac{7}{30})$。\n    由于原始的 $p$-值列表已经是排序好的，因此最终的q值列表（按原始顺序）就是这个结果。\n\n### 第3步：确定在 $q \\le 0.1$ 水平下显著的检验\n\n我们将每个q值与阈值 $0.1$ 进行比较：\n- $q_1 = \\frac{1}{500} = 0.002 \\le 0.1$ (显著)\n- $q_2 = \\frac{1}{100} = 0.01 \\le 0.1$ (显著)\n- $q_3 = \\frac{2}{75} \\approx 0.0267 \\le 0.1$ (显著)\n- $q_4 = \\frac{1}{10} = 0.1 \\le 0.1$ (显著)\n- $q_5 = \\frac{1}{5} = 0.2 > 0.1$ (不显著)\n- $q_6 = \\frac{7}{30} \\approx 0.2333 > 0.1$ (不显著)\n\n显著检验的索引（从1开始）是 $1, 2, 3, 4$。\n\n### 总结\n\n将所有结果整合到要求的单行矩阵中：\n- $\\hat{\\pi}_{0} = \\frac{1}{3}$\n- 六个q值：$(\\frac{1}{500}, \\frac{1}{100}, \\frac{2}{75}, \\frac{1}{10}, \\frac{1}{5}, \\frac{7}{30})$\n- 显著检验的索引：$1, 2, 3, 4$\n最终的矩阵为：\n$(\\frac{1}{3} \\quad \\frac{1}{500} \\quad \\frac{1}{100} \\quad \\frac{2}{75} \\quad \\frac{1}{10} \\quad \\frac{1}{5} \\quad \\frac{7}{30} \\quad 1 \\quad 2 \\quad 3 \\quad 4)$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{3}  \\frac{1}{500}  \\frac{1}{100}  \\frac{2}{75}  \\frac{1}{10}  \\frac{1}{5}  \\frac{7}{30}  1  2  3  4 \\end{pmatrix}}$$", "id": "3351031"}]}