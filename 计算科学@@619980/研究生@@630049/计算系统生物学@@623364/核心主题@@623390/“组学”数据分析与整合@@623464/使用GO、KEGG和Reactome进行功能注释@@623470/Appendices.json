{"hands_on_practices": [{"introduction": "功能富集分析通常会同时检测数千个功能类别（例如GO术语或KEGG通路），这大大增加了偶然发现假阳性的机会。因此，理解并应用多重假设检验校正是计算生物学家一项不可或缺的基本技能。本练习将引导你对一组典型的富集分析原始$p$值，手动计算两种最核心的校正方法（Bonferroni和Benjamini-Hochberg）的结果，从而让你深入理解它们在控制不同类型统计错误（家族谬误率与错误发现率）和统计功效之间的权衡。通过这个练习，你将为解读真实的生物信息学分析结果打下坚实的统计基础 [@problem_id:3312231]。", "problem": "一位研究人员使用三种标准化的注释资源，对一个差异表达基因列表进行基因集富集分析：基因本体论生物学过程 (Gene Ontology Biological Process, GO BP)、京都基因与基因组百科全书 (Kyoto Encyclopedia of Genes and Genomes, KEGG) 和 Reactome 通路知识库 (Reactome Pathway Knowledgebase, Reactome)。对于这些资源中总共 $m=12$ 个候选类别组成的组合面板，在标准假设下，每个类别都通过单侧超几何富集检验进行测试，得到的原始 $p$ 值（已经针对每个检验的组合样本空间进行了校正，但未针对跨类别的多重假设进行校正）如下：\n$0.0008$, $0.0015$, $0.0042$, $0.0070$, $0.0110$, $0.0190$, $0.0280$, $0.0370$, $0.0490$, $0.1200$, $0.3300$, $0.6200$。\n\n假设在所测试的 $m=12$ 个类别水平的假设中，恰好有 $m_0=9$ 个是真零假设，并且零假设的 $p$ 值是独立同分布于 $\\mathrm{Uniform}(0,1)$。\n\n仅使用族系误差率控制和错误发现率控制的第一性原理定义：\n- 计算所有 $m=12$ 个检验的 Bonferroni 校正 $p$ 值，并在族系显著性阈值 $\\alpha_{\\text{FWER}}=0.05$ 下确定被拒绝的假设数量。\n- 计算所有 $m=12$ 个检验的 Benjamini–Hochberg (BH) 校正 $p$ 值，并在目标错误发现率 $q=0.10$ 下确定被拒绝的假设数量。\n\n然后，在指定的独立性和均匀性假设下：\n- 在 $\\alpha_{\\text{FWER}}=0.05$ 下，推导 Bonferroni 程序的预期错误拒绝数。\n- 在 $q=0.10$ 下，推导 Benjamini–Hochberg 程序所达到的预期错误发现比例（错误发现率）的界限。\n\n最后，定义无量纲比较指标\n$$\\rho \\equiv \\frac{E[V_{\\text{Bonf}}]/m}{\\left(\\frac{m_0}{m}\\right) q},$$\n其中 $E[V_{\\text{Bonf}}]$ 是 Bonferroni 方法下预期错误拒绝的数量。精确计算 $\\rho$，并将 $\\rho$ 的单一值报告为精确的解析分数。不要包含任何单位，也不要四舍五入。", "solution": "题目陈述经评估具有科学依据、问题明确、客观且内容完整。为得出唯一且有意义的解所需的所有数据、定义和假设均已提供。因此，该问题被判定为 **有效**。\n\n该问题要求对一组 $p$ 值应用多重假设检验校正（Bonferroni 和 Benjamini-Hochberg），然后推导并计算相关的统计量。设检验总数为 $m=12$，提供的原始 $p$ 值已按非递减顺序排序，记为 $p_{(i)}$，其中 $i=1, 2, \\dots, 12$。族系显著性阈值为 $\\alpha_{\\text{FWER}}=0.05$，目标错误发现率为 $q=0.10$。给定的真零假设数量为 $m_0=9$。\n\n**1. Bonferroni 校正**\n\nBonferroni 校正通过调整每个原始 $p$ 值 $p_i$ 来控制族系误差率 (FWER)。Bonferroni 校正后的 $p$ 值 $p_{i, \\text{adj}}^{\\text{Bonf}}$ 定义为：\n$$p_{i, \\text{adj}}^{\\text{Bonf}} = \\min(m \\cdot p_i, 1)$$\n如果一个假设的校正后 $p$ 值小于或等于 FWER 阈值 $\\alpha_{\\text{FWER}}$，则该假设被拒绝。这等价于拒绝任何其原始 $p$ 值 $p_i \\le \\alpha_{\\text{FWER}} / m$ 的假设。\n\n给定 $m=12$ 和 $\\alpha_{\\text{FWER}}=0.05$，原始 $p$ 值的拒绝阈值为 $0.05/12 \\approx 0.004167$。\n提供的原始 $p$ 值为：\n$p_{(1)} = 0.0008$, $p_{(2)} = 0.0015$, $p_{(3)} = 0.0042$, $p_{(4)} = 0.0070$, $p_{(5)} = 0.0110$, $p_{(6)} = 0.0190$, $p_{(7)} = 0.0280$, $p_{(8)} = 0.0370$, $p_{(9)} = 0.0490$, $p_{(10)} = 0.1200$, $p_{(11)} = 0.3300$, $p_{(12)} = 0.6200$。\n\nBonferroni 校正后的 $p$ 值计算如下：$p_{(i), \\text{adj}}^{\\text{Bonf}} = \\min(12 \\cdot p_{(i)}, 1)$:\n$p_{(1), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0008 = 0.0096$\n$p_{(2), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0015 = 0.0180$\n$p_{(3), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0042 = 0.0504$\n$p_{(4), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0070 = 0.0840$\n$p_{(5), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0110 = 0.1320$\n$p_{(6), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0190 = 0.2280$\n$p_{(7), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0280 = 0.3360$\n$p_{(8), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0370 = 0.4440$\n$p_{(9), \\text{adj}}^{\\text{Bonf}} = 12 \\times 0.0490 = 0.5880$\n$p_{(10), \\text{adj}}^{\\text{Bonf}} = \\min(12 \\times 0.1200, 1) = \\min(1.44, 1) = 1.0$\n$p_{(11), \\text{adj}}^{\\text{Bonf}} = \\min(12 \\times 0.3300, 1) = \\min(3.96, 1) = 1.0$\n$p_{(12), \\text{adj}}^{\\text{Bonf}} = \\min(12 \\times 0.6200, 1) = \\min(7.44, 1) = 1.0$\n\n为求得被拒绝的假设数量，我们将每个校正后的 $p$ 值与 $\\alpha_{\\text{FWER}} = 0.05$ 进行比较：\n$p_{(1), \\text{adj}}^{\\text{Bonf}} = 0.0096 \\le 0.05$ (拒绝)\n$p_{(2), \\text{adj}}^{\\text{Bonf}} = 0.0180 \\le 0.05$ (拒绝)\n$p_{(3), \\text{adj}}^{\\text{Bonf}} = 0.0504 > 0.05$ (不拒绝)\n所有后续的校正 $p$ 值也都大于 $0.05$。\n因此，Bonferroni 程序拒绝了 2 个假设。\n\n**2. Benjamini-Hochberg (BH) 校正**\n\nBenjamini-Hochberg 程序控制错误发现率 (FDR)。对于第 $i$ 个排序后的原始 $p$ 值 $p_{(i)}$，其 BH 校正后的 $p$ 值 $p_{(i), \\text{adj}}^{\\text{BH}}$ 是通过一个强制单调性的降步法 (step-down procedure) 计算的。最大原始 $p$ 值的校正值就是其本身：$p_{(m), \\text{adj}}^{\\text{BH}}=p_{(m)}$。对于所有其他 $p$ 值，校正递归进行：\n$$p_{(i), \\text{adj}}^{\\text{BH}} = \\min\\left(p_{(i+1), \\text{adj}}^{\\text{BH}}, \\frac{m \\cdot p_{(i)}}{i}\\right) \\quad \\text{for } i=m-1, \\dots, 1$$\n这等价于 $p_{(i), \\text{adj}}^{\\text{BH}} = \\min_{j \\ge i}\\left(\\frac{m \\cdot p_{(j)}}{j}\\right)$。\n\n让我们计算 BH 校正后的 $p$ 值：\n$p_{(12), \\text{adj}}^{\\text{BH}} = p_{(12)} = 0.6200$\n$p_{(11), \\text{adj}}^{\\text{BH}} = \\min(p_{(12), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.3300}{11}) = \\min(0.6200, 0.3600) = 0.3600$\n$p_{(10), \\text{adj}}^{\\text{BH}} = \\min(p_{(11), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.1200}{10}) = \\min(0.3600, 0.1440) = 0.1440$\n$p_{(9), \\text{adj}}^{\\text{BH}} = \\min(p_{(10), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0490}{9}) = \\min(0.1440, 0.0653\\overline{3}) = 0.0653\\overline{3}$\n$p_{(8), \\text{adj}}^{\\text{BH}} = \\min(p_{(9), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0370}{8}) = \\min(0.0653\\overline{3}, 0.0555) = 0.0555$\n$p_{(7), \\text{adj}}^{\\text{BH}} = \\min(p_{(8), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0280}{7}) = \\min(0.0555, 0.0480) = 0.0480$\n$p_{(6), \\text{adj}}^{\\text{BH}} = \\min(p_{(7), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0190}{6}) = \\min(0.0480, 0.0380) = 0.0380$\n$p_{(5), \\text{adj}}^{\\text{BH}} = \\min(p_{(6), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0110}{5}) = \\min(0.0380, 0.0264) = 0.0264$\n$p_{(4), \\text{adj}}^{\\text{BH}} = \\min(p_{(5), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0070}{4}) = \\min(0.0264, 0.0210) = 0.0210$\n$p_{(3), \\text{adj}}^{\\text{BH}} = \\min(p_{(4), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0042}{3}) = \\min(0.0210, 0.0168) = 0.0168$\n$p_{(2), \\text{adj}}^{\\text{BH}} = \\min(p_{(3), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0015}{2}) = \\min(0.0168, 0.0090) = 0.0090$\n$p_{(1), \\text{adj}}^{\\text{BH}} = \\min(p_{(2), \\text{adj}}^{\\text{BH}}, \\frac{12 \\cdot 0.0008}{1}) = \\min(0.0090, 0.0096) = 0.0090$\n\n如果一个假设的 BH 校正 $p$ 值小于或等于目标 FDR $q=0.10$，则该假设被拒绝。\n从 $p_{(1), \\text{adj}}^{\\text{BH}}$ 到 $p_{(9), \\text{adj}}^{\\text{BH}}$ 都小于或等于 $0.10$。$p_{(10), \\text{adj}}^{\\text{BH}} = 0.1440 > 0.10$。\n因此，Benjamini-Hochberg 程序拒绝了 9 个假设。\n\n**3. 预期错误拒绝数 (Bonferroni)**\n\n设 $V_{\\text{Bonf}}$ 为 Bonferroni 程序下的错误拒绝数（第一类错误）。这些是被错误拒绝的真零假设。设 $H_0$ 为 $m_0$ 个真零假设的集合。\n$$V_{\\text{Bonf}} = \\sum_{i \\in H_0} \\mathbb{I}\\left(p_i \\le \\frac{\\alpha_{\\text{FWER}}}{m}\\right)$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。根据期望的线性性质，预期的错误拒绝数为：\n$$E[V_{\\text{Bonf}}] = E\\left[\\sum_{i \\in H_0} \\mathbb{I}\\left(p_i \\le \\frac{\\alpha_{\\text{FWER}}}{m}\\right)\\right] = \\sum_{i \\in H_0} E\\left[\\mathbb{I}\\left(p_i \\le \\frac{\\alpha_{\\text{FWER}}}{m}\\right)\\right] = \\sum_{i \\in H_0} P\\left(p_i \\le \\frac{\\alpha_{\\text{FWER}}}{m}\\right)$$\n在真零假设的 $p$ 值独立同分布于 $\\mathrm{Uniform}(0,1)$ 的假设下，拒绝单个真零假设的概率为 $P(p_i \\le \\frac{\\alpha_{\\text{FWER}}}{m}) = \\frac{\\alpha_{\\text{FWER}}}{m}$。\n因为有 $m_0$ 个这样的假设，所以预期的错误拒绝数为：\n$$E[V_{\\text{Bonf}}] = m_0 \\cdot \\frac{\\alpha_{\\text{FWER}}}{m}$$\n代入给定值：$m_0=9$, $m=12$, 以及 $\\alpha_{\\text{FWER}}=0.05$：\n$$E[V_{\\text{Bonf}}] = 9 \\times \\frac{0.05}{12} = \\frac{9 \\times 0.05}{12} = \\frac{0.45}{12} = 0.0375 = \\frac{3}{80}$$\n\n**4. 错误发现率的界限 (Benjamini-Hochberg)**\n\n错误发现率 (FDR) 定义为所有发现中错误发现的预期比例，即 $E[V/R]$，其中 $V$ 是错误拒绝数，$R$ 是总拒绝数（如果 $R=0$，则定义 $V/R$ 为 $0$）。Benjamini-Hochberg 程序在水平 $q$ 下应用时，保证了对于独立的检验（如此处所假设），FDR 受到控制：\n$$\\text{FDR} = E\\left[\\frac{V}{R}\\right] \\le \\frac{m_0}{m}q$$\n问题要求的是该程序所达到的界限。这个界限就是不等式的右侧。\n代入给定值：$m_0=9$, $m=12$, 以及 $q=0.10$：\n$$\\text{Bound} = \\frac{9}{12} \\times 0.10 = \\frac{3}{4} \\times 0.10 = 0.75 \\times 0.10 = 0.075 = \\frac{3}{40}$$\n\n**5. 比较指标 $\\rho$ 的计算**\n\n无量纲比较指标 $\\rho$ 定义为：\n$$\\rho \\equiv \\frac{E[V_{\\text{Bonf}}]/m}{\\left(\\frac{m_0}{m}\\right) q}$$\n我们代入第 3 部分推导出的 $E[V_{\\text{Bonf}}]$ 的表达式：\n$$E[V_{\\text{Bonf}}] = m_0 \\frac{\\alpha_{\\text{FWER}}}{m}$$\n$\\rho$ 的表达式变为：\n$$\\rho = \\frac{\\left(m_0 \\frac{\\alpha_{\\text{FWER}}}{m}\\right) / m}{\\left(\\frac{m_0}{m}\\right) q} = \\frac{\\frac{m_0 \\alpha_{\\text{FWER}}}{m^2}}{\\frac{m_0 q}{m}}$$\n通过消去项来简化表达式：\n$$\\rho = \\frac{m_0 \\alpha_{\\text{FWER}}}{m^2} \\cdot \\frac{m}{m_0 q} = \\frac{\\alpha_{\\text{FWER}}}{m \\cdot q}$$\n现在，我们使用给定的常数 $\\alpha_{\\text{FWER}}=0.05$，$m=12$ 和 $q=0.10$ 来计算 $\\rho$ 的精确值：\n$$\\rho = \\frac{0.05}{12 \\times 0.10} = \\frac{0.05}{1.2} = \\frac{5/100}{12/10} = \\frac{5}{100} \\times \\frac{10}{12} = \\frac{50}{1200} = \\frac{1}{24}$$", "answer": "$$\\boxed{\\frac{1}{24}}$$", "id": "3312231"}, {"introduction": "掌握了基本的统计校正方法后，我们面临的下一个挑战源于功能注释数据库（尤其是基因本体论，Gene Ontology）自身的内在结构。GO术语被组织在一个有向无环图（DAG）中，其中具体的“子”术语嵌套在更宽泛的“父”术语之下，这种层级结构会造成注释依赖性，可能误导朴素的统计检验。本练习通过一个简化的“玩具”DAG模型，生动地展示了一个父术语如何仅仅因为继承了其真正富集的子术语的信号而显得“显著” [@problem_id:3312252]。通过亲手计算在考虑和不考虑父项注释上下文两种情况下的富集$p$值，你将深刻体会到注释传播问题的本质，并认识到采用更复杂分析方法的必要性。", "problem": "一个实验室正在将一个小基因集注释到一个基因本体论（Gene Ontology, GO）的玩具版有向无环图（Directed Acyclic Graph, DAG）上。目标是在此DAG上比较朴素的过表达分析（Over-Representation Analysis, ORA）与一种亲子条件方法，并量化这两种方法所识别出的显著性术语数量上的差异。\n\n使用以下科学上合理的设置：\n- 已注释的基因全集包含 $12$ 个基因，$G = \\{g1, g2, \\dots, g12\\}$。\n- GO DAG由术语 $\\{T1, T2, T3, T4, T5, T6, T7\\}$ 组成，其亲子关系如下：\n  - $T1$（根节点）。\n  - $T2$ 是 $T1$ 的子节点。\n  - $T3$ 是 $T1$ 的子节点。\n  - $T4$ 是 $T2$ 的子节点。\n  - $T5$ 是 $T2$ 的子节点。\n  - $T6$ 是 $T2$ 和 $T3$ 的子节点（多父节点术语）。\n  - $T7$ 是 $T1$ 的子节点。\n- 基因被直接注释到以下叶节点术语（注释会向上传播至DAG中的所有祖先节点）：\n  - $T4$: $\\{g1, g2, g3\\}$。\n  - $T5$: $\\{g4, g5\\}$。\n  - $T6$: $\\{g6, g7, g8, g9\\}$。\n  - $T7$: $\\{g10, g11, g12\\}$。\n  因此，通过传播：\n  - $T2$ 包含 $\\{g1, g2, g3, g4, g5, g6, g7, g8, g9\\}$。\n  - $T3$ 包含 $\\{g6, g7, g8, g9\\}$。\n  - $T1$ 包含所有 $12$ 个基因。\n- 研究列表（查询集）为 $L = \\{g1, g6, g7, g8, g9\\}$。\n\n需要执行的任务：\n1. 朴素的过表达分析（ORA）：\n   - 对于每个术语 $T \\in \\{T3, T4, T5, T6\\}$，使用标准的超几何模型计算单侧富集$p$值。其中，总体定义为已注释的基因全集（$N = |T1|$），术语大小为 $K = |T|$（使用传播后的注释），列表大小为 $n = |L|$，观察到的重叠为 $k = |L \\cap T|$。使用上尾约定，“至少这么多或更多”的匹配。\n2. 亲子方法（并集变体）：\n   - 对于每个术语 $T \\in \\{T3, T4, T5, T6\\}$ 及其父节点 $\\mathrm{Pa}(T)$，将条件集 $S_{\\mathrm{parent}}(T)$ 定义为注释到 $T$ 的所有父节点的基因的并集。使用超几何模型计算单侧富集$p$值，但总体限制为 $N' = |S_{\\mathrm{parent}}(T)|$，其中 $K' = |T|$，$n' = |L \\cap S_{\\mathrm{parent}}(T)|$，$k' = |L \\cap T|$。\n3. 多重检验：\n   - 对 $m = 4$ 个被检验的术语 $\\{T3, T4, T5, T6\\}$ 应用Bonferroni校正，使用家族错误率 $\\alpha = 0.05$。如果一个术语的未校正$p$值至多为 $\\alpha/m$，则该术语被称为显著。\n4. 报告在朴素ORA和亲子方法下显著术语的数量。然后计算定义为“朴素ORA计数减去亲子方法计数”的差值。\n\n将最终答案表示为单个整数。无需四舍五入。无需单位。", "solution": "问题陈述已经过验证，被认为是有效的。它在计算系统生物学领域具有科学依据，问题设定良好，包含了所有必要的数据和定义，并且内部一致。任务是执行并比较两种标准的基因本体论（GO）富集分析。\n\n分析过程首先执行朴素的过表达分析（ORA），然后进行亲子条件分析。GO术语的显著性通过单侧（上尾）超几何检验来确定。从一个包含 $K$ 个成功项、大小为 $N$ 的总体中，进行 $n$ 次不放回抽样，观察到至少 $k$ 次成功的概率由以下公式给出：\n$$p = P(X \\ge k) = \\sum_{i=k}^{\\min(n,K)} \\frac{\\binom{K}{i}\\binom{N-K}{n-i}}{\\binom{N}{n}}$$\n我们需要检验 $m=4$ 个术语：$\\{T_3, T_4, T_5, T_6\\}$。在家族错误率为 $\\alpha=0.05$ 的情况下，对每个未校正的$p$值进行Bonferroni校正后的显著性阈值为 $\\frac{\\alpha}{m} = \\frac{0.05}{4} = 0.0125$。如果一个术语的$p$值小于或等于此阈值，则该术语被称为显著。\n\n提供的基因集如下：\n- 基因全集 $G = \\{g_1, g_2, \\dots, g_{12}\\}$。\n- 研究列表 $L = \\{g_1, g_6, g_7, g_8, g_9\\}$。\n- GO术语注释（传播后）：\n  - $T_1 = \\{g_1, \\dots, g_{12}\\}$，所以 $|T_1| = 12$。\n  - $T_2 = \\{g_1, \\dots, g_9\\}$，所以 $|T_2| = 9$。\n  - $T_3 = \\{g_6, g_7, g_8, g_9\\}$，所以 $|T_3| = 4$。\n  - $T_4 = \\{g_1, g_2, g_3\\}$，所以 $|T_4| = 3$。\n  - $T_5 = \\{g_4, g_5\\}$，所以 $|T_5| = 2$。\n  - $T_6 = \\{g_6, g_7, g_8, g_9\\}$，所以 $|T_6| = 4$。\n\n### 1. 朴素的过表达分析（ORA）\n\n对于朴素ORA，总体是整个基因全集 $T_1$。\n- 总体大小：$N = |T_1| = 12$。\n- 列表大小（抽样次数）：$n = |L| = 5$。\n\n我们分析每个术语：\n\n**术语 $T_3$：**\n- 术语大小（总体中的成功项）：$K = |T_3| = 4$。\n- 观察到的重叠：$k = |L \\cap T_3| = |\\{g_6, g_7, g_8, g_9\\}| = 4$。\n- 参数为 $N=12, K=4, n=5, k=4$。\n- $p$值为 $P(X \\ge 4) = P(X=4) = \\frac{\\binom{4}{4}\\binom{12-4}{5-4}}{\\binom{12}{5}} = \\frac{\\binom{4}{4}\\binom{8}{1}}{\\binom{12}{5}}$。\n- $\\binom{12}{5} = \\frac{12 \\cdot 11 \\cdot 10 \\cdot 9 \\cdot 8}{5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 792$。\n- $p_{T_3} = \\frac{1 \\cdot 8}{792} = \\frac{1}{99} \\approx 0.0101$。\n- 由于 $0.0101 \\le 0.0125$，术语 $T_3$ 是**显著的**。\n\n**术语 $T_4$：**\n- 术语大小：$K = |T_4| = 3$。\n- 观察到的重叠：$k = |L \\cap T_4| = |\\{g_1\\}| = 1$。\n- 参数为 $N=12, K=3, n=5, k=1$。\n- $p$值为 $P(X \\ge 1) = 1 - P(X=0) = 1 - \\frac{\\binom{3}{0}\\binom{12-3}{5-0}}{\\binom{12}{5}} = 1 - \\frac{\\binom{3}{0}\\binom{9}{5}}{792}$。\n- $\\binom{9}{5} = \\binom{9}{4} = \\frac{9 \\cdot 8 \\cdot 7 \\cdot 6}{4 \\cdot 3 \\cdot 2 \\cdot 1} = 126$。\n- $p_{T_4} = 1 - \\frac{1 \\cdot 126}{792} = \\frac{792 - 126}{792} = \\frac{666}{792} = \\frac{37}{44} \\approx 0.8409$。\n- 由于 $0.8409 > 0.0125$，术语 $T_4$ 是**不显著的**。\n\n**术语 $T_5$：**\n- 术语大小：$K = |T_5| = 2$。\n- 观察到的重叠：$k = |L \\cap T_5| = |\\emptyset| = 0$。\n- 参数为 $N=12, K=2, n=5, k=0$。\n- 我们正在检验过表达（上尾）。$k=0$ 的观察值不可能是过表达。$p$值为 $P(X \\ge 0) = 1$。\n- 由于 $1 > 0.0125$，术语 $T_5$ 是**不显著的**。\n\n**术语 $T_6$：**\n- 术语大小：$K = |T_6| = 4$。\n- 观察到的重叠：$k = |L \\cap T_6| = |\\{g_6, g_7, g_8, g_9\\}| = 4$。\n- 参数为 $N=12, K=4, n=5, k=4$。这与 $T_3$ 的计算相同。\n- $p_{T_6} = \\frac{1}{99} \\approx 0.0101$。\n- 由于 $0.0101 \\le 0.0125$，术语 $T_6$ 是**显著的**。\n\n在朴素ORA下，显著术语的数量为 $2$ （术语 $T_3$ 和 $T_6$）。\n\n### 2. 亲子条件分析\n\n在这里，术语 $T$ 的总体被限制在其父节点并集中的基因，$S_{\\mathrm{parent}}(T) = \\bigcup_{P \\in \\mathrm{Pa}(T)} P$。\n\n**术语 $T_3$：**\n- 父节点：$\\mathrm{Pa}(T_3)=\\{T_1\\}$。\n- 条件集：$S_{\\mathrm{parent}}(T_3) = T_1$。\n- 这简化为朴素ORA的情况。$N'=12, K'=4, n'=5, k'=4$。\n- $p'_{T_3} = \\frac{1}{99} \\approx 0.0101$。\n- 由于 $0.0101 \\le 0.0125$，术语 $T_3$ 是**显著的**。\n\n**术语 $T_4$：**\n- 父节点：$\\mathrm{Pa}(T_4)=\\{T_2\\}$。\n- 条件集：$S_{\\mathrm{parent}}(T_4) = T_2$。\n- 新的总体大小：$N' = |T_2| = 9$。\n- 新的列表：$L \\cap T_2 = \\{g_1, g_6, g_7, g_8, g_9\\} \\cap \\{g_1, \\dots, g_9\\} = L$。\n- 新的列表大小：$n' = |L| = 5$。\n- 术语大小：$K' = |T_4| = 3$。\n- 观察到的重叠：$k' = |L \\cap T_4| = 1$。\n- 参数为 $N'=9, K'=3, n'=5, k'=1$。\n- $p'_{T_4} = P(X \\ge 1) = 1 - P(X=0) = 1 - \\frac{\\binom{3}{0}\\binom{9-3}{5-0}}{\\binom{9}{5}} = 1 - \\frac{\\binom{3}{0}\\binom{6}{5}}{\\binom{9}{5}}$。\n- $\\binom{9}{5} = 126$。$\\binom{6}{5} = 6$。\n- $p'_{T_4} = 1 - \\frac{1 \\cdot 6}{126} = 1 - \\frac{1}{21} = \\frac{20}{21} \\approx 0.9524$。\n- 由于 $0.9524 > 0.0125$，术语 $T_4$ 是**不显著的**。\n\n**术语 $T_5$：**\n- 父节点：$\\mathrm{Pa}(T_5)=\\{T_2\\}$。\n- 条件集是 $T_2$，所以参数为 $N'=9, n'=5$。\n- 术语大小：$K' = |T_5| = 2$。\n- 观察到的重叠：$k' = |L \\cap T_5| = 0$。\n- $p'_{T_5} = P(X \\ge 0) = 1$。\n- 由于 $1 > 0.0125$，术语 $T_5$ 是**不显著的**。\n\n**术语 $T_6$：**\n- 父节点：$\\mathrm{Pa}(T_6)=\\{T_2, T_3\\}$。\n- 条件集：$S_{\\mathrm{parent}}(T_6) = T_2 \\cup T_3$。由于 $T_3$ 不是 $T_2$ 的子集，它们的并集是 $T_2$。更正：根据问题定义，$T6$的注释 $\\{g6, g7, g8, g9\\}$ 是 $T2$ 和 $T3$ 的子集。这意味着 $T3$ 包含 $\\{g6, g7, g8, g9\\}$，$T2$ 包含 $\\{g1, \\dots, g9\\}$。因此 $T_2 \\cup T_3 = T_2$。\n- 新的总体大小：$N' = |T_2| = 9$。\n- 新的列表大小：$n' = |L \\cap T_2| = 5$。\n- 术语大小：$K' = |T_6| = 4$。\n- 观察到的重叠：$k' = |L \\cap T_6| = 4$。\n- 参数为 $N'=9, K'=4, n'=5, k'=4$。\n- $p'_{T_6} = P(X \\ge 4) = P(X=4) = \\frac{\\binom{4}{4}\\binom{9-4}{5-4}}{\\binom{9}{5}} = \\frac{\\binom{4}{4}\\binom{5}{1}}{\\binom{9}{5}}$。\n- $p'_{T_6} = \\frac{1 \\cdot 5}{126} = \\frac{5}{126} \\approx 0.0397$。\n- 由于 $0.0397 > 0.0125$，术语 $T_6$ 是**不显著的**。\n\n在亲子方法下，显著术语的数量为 $1$（仅术语 $T_3$）。\n\n### 3. 比较与最终答案\n\n- 显著术语数量（朴素ORA）：$2$。\n- 显著术语数量（亲子方法）：$1$。\n- 差值定义为“朴素ORA计数减去亲子方法计数”。\n- 差值 = $2 - 1 = 1$。", "answer": "$$\\boxed{1}$$", "id": "3312252"}, {"introduction": "前面的练习揭示了在GO这样的层级本体中进行富集分析时，注释继承可能导致的问题。在此基础上，本练习将介绍两种经典的算法策略——“消除法”（elim）和“权重法”（weight），它们被设计用来系统性地解决这一问题，并在许多主流生物信息学工具中得以应用。这些方法通过修剪GO图或调整$p$值来消除已被更具体的显著子术语解释的证据，从而生成更可靠、更易于解释的富集结果 [@problem_id:3312287]。通过实现这两种算法，你将从概念理解走向实际应用，深入探索高级GO分析工具背后的核心逻辑。", "problem": "您的任务是形式化并实现一种结构化遍历策略，该策略作用于代表基因本体论（Gene Ontology, GO）术语的有向无环图（DAG），以解决统计富集检验中遗传注释的依赖性问题。此问题的基础是用于富集检验的超几何模型定义、GO注释的DAG遗传特性，以及在基因本体论、京都基因与基因组百科全书（KEGG）和Reactome中观察到的沿层次结构的证据衰减逻辑。目标是构建两种遍历策略的程序化版本，通常称为“elim”和“weight”，以减轻宽泛的祖先GO术语对其子术语显著性的影响。您必须通过在一个明确定义的测试套件上进行实现和计算来证明这些策略的合理性。\n\n基础和定义：\n- 令基因的背景全集为一个有限集合 $U$，其基数为 $|U| = M$。\n- 令 $I \\subseteq U$ 为一个固定的“感兴趣”基因集（例如，差异表达的基因），其基数为 $|I| = n$。\n- 对于每个GO术语 $t$，令 $A_t \\subseteq U$ 表示直接注释到术语 $t$ 的基因集合。\n- GO结构是一个有向无环图（DAG），其中的边从父术语指向子术语，子术语代表比其父术语更具体的生物学功能。\n- 对于在超几何模型下一个术语 $t$ 的富集，定义重叠 $k_t = |I \\cap A_t|$，以及 $K_t = |A_t|$。观察到 $k_t$ 或更多感兴趣的基因注释到术语 $t$ 的单边过表示 $p$-值由超几何尾部给出：\n$$\np_t = \\Pr\\{X \\ge k_t\\} \\quad \\text{其中 } X \\sim \\text{Hypergeometric}(M, K_t, n).\n$$\n\n需要实现的衰减策略：\n- 消除策略（“elim”）：遍历从叶节点到根节点自下而上进行。当一个子术语 $c$ 在阈值 $\\alpha$ 下被认为是显著的（即 $p_c \\le \\alpha$）时，注释到 $c$ 的基因将从其所有祖先的注释集中排除，然后才对这些祖先进行检验。形式上，对于一个父术语 $t$，定义消除后的有效注释集为 $A_t^{\\text{elim}} = A_t \\setminus \\bigcup_{c \\in \\mathcal{D}_t^{\\text{sig}}} A_c$，其中 $\\mathcal{D}_t^{\\text{sig}}$ 是 $t$ 的后代中，在自下而上的遍历中已发现在水平 $\\alpha$ 下显著的术语。然后使用 $k_t^{\\text{elim}} = |I \\cap A_t^{\\text{elim}}|$ 和 $K_t^{\\text{elim}} = |A_t^{\\text{elim}}|$ 在相同的超几何尾部检验该父术语。\n- 加权策略（“weight”）：遍历首先计算所有术语的原始 $p$-值，然后对于每个父术语 $t$，其原始 $p_t$ 会根据已集中在显著子术语中的感兴趣证据的比例进行增加。为 $t$ 的每个子术语 $c$ 定义重叠分数\n$$\nf_{t,c} = \\frac{|I \\cap A_t \\cap A_c|}{\\max(1, |I \\cap A_t|)}.\n$$\n然后定义累积子代影响\n$$\nS_t = \\sum_{c \\in \\text{child}(t)} f_{t,c} \\cdot \\mathbf{1}[p_c \\le \\alpha],\n$$\n并定义加权后的父术语值为\n$$\np_t^{\\text{weight}} = \\min\\{1, \\, p_t \\cdot (1 + \\lambda S_t)\\},\n$$\n缩放参数为 $\\lambda = 1$。此策略确保祖先的显著性衰减程度与已被显著子术语解释的感兴趣基因的集中程度成比例。选择乘法调整是一种有原则的单调惩罚，当子术语捕获重叠证据时，它会提高 $p$-值，从而阻止在DAG中进行双重计数。\n\n测试套件规范：\n所有测试用例使用相同的GO DAG和注释图，但改变感兴趣的集合 $I$。DAG、背景全集和注释规定如下：\n- 全集 $U = \\{g_1, g_2, g_3, g_4, g_5, g_6, g_7, g_8, g_9, g_{10}, g_{11}, g_{12}\\}$，其中 $|U| = M = 12$。\n- 术语：$R$（根）、$A$、$B$、$C$，边为 $R \\to A$、$R \\to B$、$A \\to C$。\n- 注释：\n    - $A_R = \\{g_1, g_2, g_3, g_4, g_5, g_6, g_7, g_8, g_9, g_{10}\\}$，其中 $|A_R| = 10$。\n    - $A_A = \\{g_1, g_2, g_3, g_4, g_5, g_6\\}$，其中 $|A_A| = 6$。\n    - $A_B = \\{g_7, g_8, g_9, g_{10}\\}$，其中 $|A_B| = 4$。\n    - $A_C = \\{g_1, g_2, g_3\\}$，其中 $|A_C| = 3$。\n所有测试用例使用 $\\alpha = 0.05$ 和 $\\lambda = 1$，并关注父术语 $A$ 以评估策略相对于其子术语 $C$ 的效果。\n\n测试用例：\n- 用例 1（理想路径，子术语集中）：$I = \\{g_1, g_2, g_3, g_{11}\\}$，其中 $|I| = n = 4$。期望：$C$ 显著，消除策略通过从 $A$ 中移除 $C$ 的基因来降低 $A$ 的表观显著性，而加权策略则按比例提高父术语的 $p$ 值。\n- 用例 2（边界情况，子术语不显著）：$I = \\{g_4, g_5, g_7, g_8\\}$，其中 $|I| = n = 4$。期望：$C$ 不显著，elim和weight策略都退化为原始父术语的值，不显示衰减。\n- 用例 3（边缘情况，与父术语无重叠）：$I = \\{g_{11}, g_{12}\\}$，其中 $|I| = n = 2$。期望：父术语无富集；两种策略都保持父术语不显著。\n\n所需程序行为：\n- 实现用于过表示的超几何单边尾部 $p$-值、所定义的消除策略和所定义的加权策略。以精确整数形式处理所有集合基数和操作，并精确处理DAG关系。程序必须为每个测试用例计算三元组 $[p_A, p_A^{\\text{elim}}, p_A^{\\text{weight}}]$ 作为浮点值。\n- 最终输出格式：您的程序应生成单行输出，包含三个测试用例的结果，形式为一个包含三个浮点数列表的逗号分隔列表，并用方括号括起，顺序为用例1、用例2、用例3。例如，输出格式为 $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$，其中每个 $x_i, y_i, z_i$ 是一个浮点数。不应打印其他任何文本。\n- 不涉及物理单位。不使用角度。百分比（如 $\\alpha$ 的 $0.05$）在出现时必须表示为 $[0,1]$ 范围内的小数。\n\n科学真实性：\nGO DAG的遗传性会引发依赖关系，因为如果一个特定的子术语 $c$ 富集，其祖先 $t$ 可能会因为继承了 $A_c \\subseteq A_t$ 而显得富集。所构建的策略旨在衰减那些否则会被重复计算的证据，这是合理的。这些原则在概念上可以扩展到京都基因与基因组百科全书（KEGG）和Reactome中的通路层次结构和图，尽管确切的拓扑和统计结构有所不同（例如，Reactome的事件层次结构和KEGG的通路图与GO DAG并非严格同构）。", "solution": "该问题陈述经过严格验证，被认为是有效的。它具有科学依据、问题明确、客观且内部一致。它提出了一个计算系统生物学中关于校正有向无环图（DAG）上功能富集分析中统计依赖性的形式化且可解的问题。\n\n目标是实现并评估两种策略，“elim”和“weight”，旨在减轻因基因本体论（GO）等本体的层次结构而产生的统计偏差。这些偏差通常表现为，宽泛且信息量较少的父术语仅仅因为其一个或多个具体的、信息量更丰富的子术语的强信号而显得显著。我们将使用一个已定义的GO类DAG、基因注释和特定的“感兴趣基因”集的玩具模型来计算这些策略的效果。\n\n富集分析的统计基础是单边超几何检验。给定一个包含 $M$ 个基因的全集，一个包含 $n$ 个基因的感兴趣集，以及一个注释有 $K_t$ 个基因的GO术语 $t$，观察到 $k_t$ 或更多来自感兴趣集的基因被注释到术语 $t$ 的概率（$p$-值）由超几何分布的生存函数给出：\n$$\np_t = \\Pr\\{X \\ge k_t\\} = \\sum_{i=k_t}^{\\min(n, K_t)} \\frac{\\binom{K_t}{i} \\binom{M - K_t}{n - i}}{\\binom{M}{n}}, \\quad \\text{其中 } X \\sim \\text{Hypergeometric}(M, K_t, n)\n$$\n这里，$k_t$ 是感兴趣集与该术语注释集交集中的基因数量。\n\n提供的测试套件使用一致的背景和结构：\n- 基因全集大小：$M = |U| = 12$。\n- GO术语和DAG结构：边 $R \\to A$，$R \\to B$，$A \\to C$。术语 $C$ 是 $A$ 的子术语。\n- 基因注释：\n    - $A_A = \\{g_1, g_2, g_3, g_4, g_5, g_6\\}$，因此 $K_A = |A_A| = 6$。\n    - $A_C = \\{g_1, g_2, g_3\\}$，因此 $K_C = |A_C| = 3$。我们注意到 $A_C \\subset A_A$，这与GO中的真实路径规则一致。\n- 用于识别显著子术语的显著性水平：$\\alpha = 0.05$。\n- 加权参数：$\\lambda = 1$。\n\n我们现在将分析三个测试用例中的每一个，首先计算术语 $A$ 和 $C$ 的原始 $p$-值，然后应用 `elim` 和 `weight` 算法来推导父术语 $A$ 的调整后 $p$-值。\n\n**用例 1：子术语集中**\n- 感兴趣集：$I = \\{g_1, g_2, g_3, g_{11}\\}$，大小 $n = |I| = 4$。\n\n1.  **检验子术语 C**：\n    - 与 $A_C$ 的交集：$I \\cap A_C = \\{g_1, g_2, g_3\\}$。基数 $k_C = 3$。\n    - $p_C = \\Pr\\{X \\ge 3\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_C=3, n=4)$。\n    - $p_C = \\frac{\\binom{3}{3}\\binom{12-3}{4-3}}{\\binom{12}{4}} = \\frac{1 \\cdot 9}{495} \\approx 0.01818$。\n    - 因为 $p_C \\approx 0.01818 \\le \\alpha=0.05$，术语 $C$ 是显著的。\n\n2.  **检验父术语 A（原始）**：\n    - 与 $A_A$ 的交集：$I \\cap A_A = \\{g_1, g_2, g_3\\}$。基数 $k_A = 3$。\n    - $p_A = \\Pr\\{X \\ge 3\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_A=6, n=4)$。\n    - $p_A = \\frac{\\binom{6}{3}\\binom{12-6}{4-3}}{\\binom{12}{4}} + \\frac{\\binom{6}{4}\\binom{12-6}{4-4}}{\\binom{12}{4}} = \\frac{20 \\cdot 6}{495} + \\frac{15 \\cdot 1}{495} = \\frac{120+15}{495} = \\frac{135}{495} \\approx 0.27273$。\n\n3.  **对 A 应用 `elim` 策略**：\n    - 由于子术语 $C$ 显著，其基因从父术语 $A$ 中移除。\n    - 有效注释集：$A_A^{\\text{elim}} = A_A \\setminus A_C = \\{g_4, g_5, g_6\\}$。\n    - 有效集大小：$K_A^{\\text{elim}} = |A_A^{\\text{elim}}| = 3$。\n    - 有效交集：$I \\cap A_A^{\\text{elim}} = \\emptyset$。基数 $k_A^{\\text{elim}} = 0$。\n    - $p_A^{\\text{elim}} = \\Pr\\{X \\ge 0\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_A^{\\text{elim}}=3, n=4)$。此概率为 $1$。\n\n4.  **对 A 应用 `weight` 策略**：\n    - 由于子术语 $C$ 显著，我们计算惩罚。\n    - 子代影响分数：$f_{A,C} = \\frac{|I \\cap A_C|}{\\max(1, |I \\cap A_A|)} = \\frac{k_C}{\\max(1, k_A)} = \\frac{3}{\\max(1, 3)} = 1$。\n    - 累积影响：$S_A = f_{A,C} \\cdot \\mathbf{1}[p_C \\le \\alpha] = 1 \\cdot 1 = 1$。\n    - 加权 $p$-值：$p_A^{\\text{weight}} = \\min\\{1, p_A \\cdot (1 + \\lambda S_A)\\} = \\min\\{1, 0.27273 \\cdot (1 + 1 \\cdot 1)\\} = \\min\\{1, 0.54545\\} = 0.54545$。\n\n- **用例 1 的结果**：$[p_A, p_A^{\\text{elim}}, p_A^{\\text{weight}}] \\approx [0.27273, 1.0, 0.54545]$。\n\n**用例 2：子术语不显著**\n- 感兴趣集：$I = \\{g_4, g_5, g_7, g_8\\}$，大小 $n = |I| = 4$。\n\n1.  **检验子术语 C**：\n    - 与 $A_C$ 的交集：$I \\cap A_C = \\emptyset$。基数 $k_C = 0$。\n    - $p_C = \\Pr\\{X \\ge 0\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_C=3, n=4)$。此概率为 $1$。\n    - 因为 $p_C = 1 > \\alpha=0.05$，术语 $C$ 不显著。\n\n2.  **检验父术语 A（原始）**：\n    - 与 $A_A$ 的交集：$I \\cap A_A = \\{g_4, g_5\\}$。基数 $k_A = 2$。\n    - $p_A = \\Pr\\{X \\ge 2\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_A=6, n=4)$。\n    - $p_A = \\frac{\\binom{6}{2}\\binom{6}{2}}{\\binom{12}{4}} + \\frac{\\binom{6}{3}\\binom{6}{1}}{\\binom{12}{4}} + \\frac{\\binom{6}{4}\\binom{6}{0}}{\\binom{12}{4}} = \\frac{15 \\cdot 15}{495} + \\frac{20 \\cdot 6}{495} + \\frac{15 \\cdot 1}{495} = \\frac{225+120+15}{495} = \\frac{360}{495} \\approx 0.72727$。\n\n3.  **对 A 应用 `elim` 和 `weight` 策略**：\n    - 由于子术语 $C$ 不显著，两种策略均不进行调整。\n    - $A_A^{\\text{elim}} = A_A$，所以 $p_A^{\\text{elim}} = p_A \\approx 0.72727$。\n    - 指示函数 $\\mathbf{1}[p_C \\le \\alpha]$ 为 $0$，所以 $S_A = 0$，并且 $p_A^{\\text{weight}} = p_A \\approx 0.72727$。\n\n- **用例 2 的结果**：$[p_A, p_A^{\\text{elim}}, p_A^{\\text{weight}}] \\approx [0.72727, 0.72727, 0.72727]$。\n\n**用例 3：与父术语无重叠**\n- 感兴趣集：$I = \\{g_{11}, g_{12}\\}$，大小 $n = |I| = 2$。\n\n1.  **检验子术语 C**：\n    - 与 $A_C$ 的交集：$I \\cap A_C = \\emptyset$。基数 $k_C = 0$。\n    - $p_C = \\Pr\\{X \\ge 0\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_C=3, n=2)$。此概率为 $1$。\n    - 术语 $C$ 不显著。\n\n2.  **检验父术语 A（原始）**：\n    - 与 $A_A$ 的交集：$I \\cap A_A = \\emptyset$。基数 $k_A = 0$。\n    - $p_A = \\Pr\\{X \\ge 0\\}$，对于 $X \\sim \\text{Hypergeometric}(M=12, K_A=6, n=2)$。此概率为 $1$。\n\n3.  **对 A 应用 `elim` 和 `weight` 策略**：\n    - 子术语 $C$ 不显著，因此不进行调整。\n    - $p_A^{\\text{elim}} = p_A = 1$。\n    - $p_A^{\\text{weight}} = p_A = 1$。\n\n- **用例 3 的结果**：$[p_A, p_A^{\\text{elim}}, p_A^{\\text{weight}}] = [1.0, 1.0, 1.0]$。\n\n这些计算证实了算法的预期行为。在用例1中，子术语捕获了所有证据，两种策略都正确地衰减了父术语的表观显著性。在用例2和3中，子术语不显著，父术语的 $p$-值被正确地保持不变。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef solve():\n    \"\"\"\n    Implements and evaluates 'elim' and 'weight' strategies for GO enrichment.\n    \"\"\"\n\n    # --- Static data from the problem statement ---\n    # Universe of genes\n    U = {f'g_{i}' for i in range(1, 13)}\n    M = len(U)\n\n    # GO term annotations (full sets including inheritance)\n    annotations = {\n        'R': {f'g_{i}' for i in range(1, 11)},\n        'A': {f'g_{i}' for i in range(1, 7)},\n        'B': {f'g_{i}' for i in range(7, 11)},\n        'C': {f'g_{i}' for i in range(1, 4)},\n    }\n    \n    # DAG structure: map parent to a list of its children\n    dag_children = {\n        'R': ['A', 'B'],\n        'A': ['C'],\n        'B': [],\n        'C': []\n    }\n    # For bottom-up traversal (elim strategy), we need parent information\n    dag_parents = {\n        'A': ['R'],\n        'B': ['R'],\n        'C': ['A'],\n        'R': []\n    }\n\n    # Parameters\n    alpha = 0.05\n    lambda_param = 1.0\n\n    # --- Test cases ---\n    test_cases = [\n        # Case 1: Happy path, child term concentration\n        {'I': {'g_1', 'g_2', 'g_3', 'g_11'}},\n        # Case 2: Boundary, child not significant\n        {'I': {'g_4', 'g_5', 'g_7', 'g_8'}},\n        # Case 3: Edge, no overlap with parent\n        {'I': {'g_11', 'g_12'}},\n    ]\n    \n    # Helper function for hypergeometric p-value\n    def hypergeometric_p_value(M_total, K_annotated, n_interest, k_overlap):\n        \"\"\"\n        Calculates the one-sided overrepresentation p-value.\n        Uses scipy.stats.hypergeom.sf (survival function), which is 1 - cdf.\n        sf(k-1, M, n, N) is Pr(X >= k).\n        - M (total) is M in problem\n        - n (type I) is K in problem\n        - N (draws) is n in problem\n        \"\"\"\n        if k_overlap == 0:\n            # For an over-representation test, an overlap of 0 can never be significant.\n            # The probability of getting 0 or more is 1.\n            return 1.0\n        # sf(k-1, ...) computes P(X >= k)\n        return hypergeom.sf(k_overlap - 1, M_total, K_annotated, n_interest)\n\n    final_results = []\n    \n    # --- Main processing loop ---\n    for case in test_cases:\n        I = case['I']\n        n = len(I)\n\n        # We focus on the parent term A and its child C.\n        \n        # 1. Calculate raw p-values for C and A\n        K_C = len(annotations['C'])\n        k_C = len(I.intersection(annotations['C']))\n        p_C = hypergeometric_p_value(M, K_C, n, k_C)\n\n        K_A = len(annotations['A'])\n        k_A = len(I.intersection(annotations['A']))\n        p_A = hypergeometric_p_value(M, K_A, n, k_A)\n\n        # Determine if child C is significant\n        is_C_significant = (p_C = alpha)\n\n        # 2. Calculate p_A_elim\n        p_A_elim = p_A\n        if is_C_significant:\n            # The only descendant of A is C.\n            # Perform elimination: remove genes of significant children\n            A_elim_set = annotations['A'].difference(annotations['C'])\n            K_A_elim = len(A_elim_set)\n            k_A_elim = len(I.intersection(A_elim_set))\n            p_A_elim = hypergeometric_p_value(M, K_A_elim, n, k_A_elim)\n\n        # 3. Calculate p_A_weight\n        p_A_weight = p_A\n        if is_C_significant:\n            # The only child of A is C\n            # Calculate overlap fraction f_AC\n            f_AC_num = len(I.intersection(annotations['C']))\n            f_AC_den = max(1, k_A)\n            f_AC = f_AC_num / f_AC_den\n            \n            # Calculate cumulative child influence S_A\n            S_A = f_AC # Since C is the only child of A\n\n            # Calculate weighted p-value\n            p_A_weight = min(1.0, p_A * (1.0 + lambda_param * S_A))\n\n        final_results.append([p_A, p_A_elim, p_A_weight])\n\n    # Final print statement in the exact required format.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in final_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3312287"}]}