{"hands_on_practices": [{"introduction": "在序列蒙特卡洛方法中，重要性权重是通过将先前的权重与新观测的似然函数相乘来更新的。当处理许多时间步或似然值本身极小的情况时，直接乘法会导致数值下溢。这个练习将引导你通过在对数空间中进行计算来解决此问题，并演示了如何使用log-sum-exp技巧来稳定地归一化对数权重，这是实现稳健粒子滤波器的关键技术 ([@problem_id:3347782])。", "problem": "考虑一个细胞群体中单个基因转录活性的隐状态模型，其中离散时间 $t$ 的潜启动子活性 $x_t$ 根据马尔可夫过程演化，观测读出值 $y_t$ 是由标准观测模型（例如，泊松或负二项模型）生成的计数，其似然 $p(y_t \\mid x_t)$ 在不同潜状态下可能相差多个数量级。在一个以先验作为提议分布的序列蒙特卡洛（SMC）粒子滤波器中，$N$ 个粒子 $\\{x_t^{(i)}\\}_{i=1}^{N}$ 向前传播，未归一化的权重通过观测似然进行乘法更新。为了在存在极端似然比的情况下保持数值稳定性，我们传播对数权重 $\\ell_t^{(i)}$ 并使用指数和的对数（log-sum-exp）执行稳定归一化。\n\n从粒子滤波的原理出发，定义对数权重，并展示如何仅使用加法、减法和差分的指数运算来稳定地执行归一化。然后，将此方法应用于以下模拟计算系统生物学中SMC更新的玩具示例，其中有 $N=4$ 个粒子。假设先前的归一化权重是均匀的，即对于 $i \\in \\{1,2,3,4\\}$，$w_{t-1}^{(i)} = 1/4$。并假设在时间 $t$ 由新观测值 $y_t$ 引起的增量对数似然贡献为：\n$$\\delta_1 = -300,\\quad \\delta_2 = -0.1,\\quad \\delta_3 = 0,\\quad \\delta_4 = -200.$$\n使用对数权重传播和数值稳定的 log-sum-exp 归一化方法，计算 $i \\in \\{1,2,3,4\\}$ 的归一化权重 $w_t^{(i)}$，并将权重向量以指数函数 $\\exp(\\cdot)$ 的单个闭式解析表达式形式报告。无需四舍五入；请将最终答案精确表示为 $\\exp(\\cdot)$ 的函数。", "solution": "该问题要求推导序列蒙特卡洛（SMC）方法中使用的数值稳定的对数权重更新和归一化过程，并将其应用于一个具体的数值示例。问题陈述已经过验证，并被认为是有效的。\n\n首先，我们详细介绍粒子滤波器中权重更新的原理。设一组 $N$ 个粒子 $\\{x_{t-1}^{(i)}, w_{t-1}^{(i)}\\}_{i=1}^{N}$ 表示在时间 $t-1$ 时潜状态的后验分布，其中 $w_{t-1}^{(i)}$ 是归一化权重，满足 $\\sum_{i=1}^{N} w_{t-1}^{(i)} = 1$。在一个使用先验作为提议分布的标准SMC算法中，每个粒子的状态根据系统动力学进行传播：$x_t^{(i)} \\sim p(x_t | x_{t-1}^{(i)})$。\n\n在收到新观测值 $y_t$ 后，每个粒子的重要性权重被更新。在时间 $t$ 的未归一化权重，记为 $\\tilde{w}_t^{(i)}$，是前一时刻权重与给定粒子新状态下观测值似然的乘积：\n$$ \\tilde{w}_t^{(i)} = w_{t-1}^{(i)} \\cdot p(y_t | x_t^{(i)}) $$\n然后，权重被归一化以使其和为1：\n$$ w_t^{(i)} = \\frac{\\tilde{w}_t^{(i)}}{\\sum_{j=1}^{N} \\tilde{w}_t^{(j)}} $$\n在许多应用中，包括所描述的应用，似然值 $p(y_t | x_t^{(i)})$ 可能极小，如果直接计算权重，会导致数值下溢。为规避此问题，计算在对数域中进行。\n\n令 $\\ell_t^{(i)} = \\ln(w_t^{(i)})$ 为对数权重。未归一化对数权重 $\\tilde{\\ell}_t^{(i)} = \\ln(\\tilde{w}_t^{(i)})$ 的更新变为加法运算：\n$$ \\tilde{\\ell}_t^{(i)} = \\ln(w_{t-1}^{(i)}) + \\ln(p(y_t | x_t^{(i)})) $$\n这可以写作 $\\tilde{\\ell}_t^{(i)} = \\ell_{t-1}^{(i)} + \\delta_t^{(i)}$，其中 $\\ell_{t-1}^{(i)}$ 是上一步的归一化对数权重，$\\delta_t^{(i)} = \\ln(p(y_t | x_t^{(i)}))$ 是增量对数似然贡献。\n\n为了获得归一化权重 $w_t^{(i)}$，我们必须计算：\n$$ w_t^{(i)} = \\frac{\\exp(\\tilde{\\ell}_t^{(i)})}{\\sum_{j=1}^{N} \\exp(\\tilde{\\ell}_t^{(j)})} $$\n分母中的和 $\\sum_{j=1}^{N} \\exp(\\tilde{\\ell}_t^{(j)})$ 是数值不稳定的一个潜在来源。如果 $\\tilde{\\ell}_t^{(j)}$ 的值很大，$\\exp(\\tilde{\\ell}_t^{(j)})$ 可能会上溢。如果它们是大的负数，则可能会下溢到零，导致除以零的错误。\n\n对此归一化的标准且数值稳定的方法，称为 log-sum-exp 技巧，即通过减去对数权重的最大值来平移它们。令 $L_{\\max} = \\max_{j} \\{ \\tilde{\\ell}_t^{(j)} \\}$。这个和可以重写为：\n$$ \\sum_{j=1}^{N} \\exp(\\tilde{\\ell}_t^{(j)}) = \\sum_{j=1}^{N} \\exp(L_{\\max} + \\tilde{\\ell}_t^{(j)} - L_{\\max}) = \\exp(L_{\\max}) \\sum_{j=1}^{N} \\exp(\\tilde{\\ell}_t^{(j)} - L_{\\max}) $$\n将此代回归一化权重的表达式中：\n$$ w_t^{(i)} = \\frac{\\exp(\\tilde{\\ell}_t^{(i)})}{\\exp(L_{\\max}) \\sum_{j=1}^{N} \\exp(\\tilde{\\ell}_t^{(j)} - L_{\\max})} = \\frac{\\exp(\\tilde{\\ell}_t^{(i)} - L_{\\max})}{\\sum_{j=1}^{N} \\exp(\\tilde{\\ell}_t^{(j)} - L_{\\max})} $$\n这个公式是数值稳定的。项 $\\tilde{\\ell}_t^{(j)} - L_{\\max}$ 总是非正的，且至少有一项恰好为零。因此，其指数 $\\exp(\\tilde{\\ell}_t^{(j)} - L_{\\max})$ 总是在 $0$ 和 $1$ 之间，从而防止了上溢。分母是这些性质良好的项之和，并且由于其中一项等于 $1$，所以总和保证至少为 $1$，从而防止了下溢和除以零。此计算如要求一样，仅依赖于对数权重的减法、这些差值的指数运算、求和与除法。\n\n现在，我们将此过程应用于所给的玩具示例。\n已知条件是：\n- 粒子数：$N=4$。\n- 先前的归一化权重：对于 $i \\in \\{1,2,3,4\\}$，$w_{t-1}^{(i)} = 1/4$。\n- 增量对数似然：$\\delta_1 = -300$, $\\delta_2 = -0.1$, $\\delta_3 = 0$, $\\delta_4 = -200$。\n\n1.  计算在时间 $t$ 的未归一化对数权重。\n先前的归一化对数权重为 $\\ell_{t-1}^{(i)} = \\ln(w_{t-1}^{(i)}) = \\ln(1/4) = -\\ln(4)$，对所有 $i$ 均如此。\n未归一化对数权重为 $\\tilde{\\ell}_t^{(i)} = \\ell_{t-1}^{(i)} + \\delta_i = -\\ln(4) + \\delta_i$。\n$$ \\tilde{\\ell}_t^{(1)} = -\\ln(4) - 300 $$\n$$ \\tilde{\\ell}_t^{(2)} = -\\ln(4) - 0.1 $$\n$$ \\tilde{\\ell}_t^{(3)} = -\\ln(4) + 0 = -\\ln(4) $$\n$$ \\tilde{\\ell}_t^{(4)} = -\\ln(4) - 200 $$\n\n2.  找到最大的未归一化对数权重 $L_{\\max}$。\n$$ L_{\\max} = \\max_{i} \\{ \\tilde{\\ell}_t^{(i)} \\} = \\max \\{ -\\ln(4) - 300, -\\ln(4) - 0.1, -\\ln(4), -\\ln(4) - 200 \\} $$\n最大值显然是 $\\tilde{\\ell}_t^{(3)} = -\\ln(4)$。\n$$ L_{\\max} = -\\ln(4) $$\n\n3.  使用稳定公式计算归一化权重 $w_t^{(i)}$。\n$$ w_t^{(i)} = \\frac{\\exp(\\tilde{\\ell}_t^{(i)} - L_{\\max})}{\\sum_{j=1}^{4} \\exp(\\tilde{\\ell}_t^{(j)} - L_{\\max})} $$\n首先，计算指数的差值：$\\tilde{\\ell}_t^{(i)} - L_{\\max} = (-\\ln(4) + \\delta_i) - (-\\ln(4)) = \\delta_i$。\n分母（我们记为 $S$）是这些差值的指数之和：\n$$ S = \\sum_{j=1}^{4} \\exp(\\delta_j) = \\exp(\\delta_1) + \\exp(\\delta_2) + \\exp(\\delta_3) + \\exp(\\delta_4) $$\n$$ S = \\exp(-300) + \\exp(-0.1) + \\exp(0) + \\exp(-200) $$\n为清晰起见重新排序：\n$$ S = 1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300) $$\n归一化权重 $w_t^{(i)}$ 由 $w_t^{(i)} = \\frac{\\exp(\\delta_i)}{S}$ 给出：\n$$ w_t^{(1)} = \\frac{\\exp(-300)}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} $$\n$$ w_t^{(2)} = \\frac{\\exp(-0.1)}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} $$\n$$ w_t^{(3)} = \\frac{\\exp(0)}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} = \\frac{1}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} $$\n$$ w_t^{(4)} = \\frac{\\exp(-200)}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} $$\n最终的权重向量 $\\mathbf{w}_t = (w_t^{(1)}, w_t^{(2)}, w_t^{(3)}, w_t^{(4)})$ 可以写成一个标量乘以一个向量的形式：\n$$ \\mathbf{w}_t = \\frac{1}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} \\begin{pmatrix} \\exp(-300)  \\exp(-0.1)  1  \\exp(-200) \\end{pmatrix} $$\n此表达式表示四个粒子的精确、未四舍五入的归一化权重。", "answer": "$$\n\\boxed{\\frac{1}{1 + \\exp(-0.1) + \\exp(-200) + \\exp(-300)} \\begin{pmatrix} \\exp(-300)  \\exp(-0.1)  1  \\exp(-200) \\end{pmatrix}}\n$$", "id": "3347782"}, {"introduction": "权重更新步骤不可避免地会导致“权重退化”现象，即少数粒子占据了几乎所有的权重，使得粒子集对后验分布的表示效率低下。重采样是解决此问题的标准方法，它通过复制高权重粒子并剔除低权重粒子来重新生成粒子集。本练习将让你亲手实现系统重采样算法，这是一种广泛使用的高效重采样方案，通过一个具体的例子来加深理解 ([@problem_id:3347857])。", "problem": "在计算系统生物学的背景下，一个单细胞转录爆发模型通过序贯蒙特卡罗（SMC）粒子滤波器进行随时间追踪。在时间步长 $t$ 同化一次荧光测量后，您有 $N=8$ 个粒子代表潜在的启动子活性状态，其归一化重要性权重 $w_{1:8}$ 是通过高斯观测模型进行贝叶斯更新得到的。重采样的目标是根据这些归一化权重抽取祖先索引，以减轻权重退化，同时保持经验测度的无偏性。\n\n给定归一化权重向量\n$$\nw_{1:8} = \\big(0.04,\\; 0.08,\\; 0.12,\\; 0.06,\\; 0.20,\\; 0.10,\\; 0.30,\\; 0.10\\big),\n$$\n其满足 $\\sum_{i=1}^{8} w_i = 1$。请在此时间步长使用基于1的索引约定实现系统重采样，其中单个随机偏移量从 $U \\sim \\mathrm{Uniform}(0, 1/N)$ 中抽取，并实现为 $U = 0.03$。计算权重的累积和向量以及从 $U$ 开始、间隔为 $1/N$ 的 $N$ 个等距阈值，然后对每个阈值，确定其累积和超过或等于该阈值的最小祖先索引。\n\n使用基于1的索引报告长度为8的所选祖先索引向量，形式为八个整数。将您的最终答案表示为单个行向量，不要包含任何单位。无需四舍五入。", "solution": "问题陈述经评估有效。它在科学上基于序贯蒙特卡罗方法（特别是粒子滤波）的既定原理。该问题是适定的，提供了计算唯一确定性答案所需的所有必要数据——粒子数 $N$、归一化权重向量 $w_{1:8}$ 以及实现的随机偏移量 $U$。该问题是客观、完整且无矛盾的。所要求的任务是该领域的标准计算程序。\n\n该问题要求对一组具有给定归一化重要性权重的 $N=8$ 个粒子实施系统重采样。该过程包括三个主要步骤：\n1.  计算归一化权重的累积和。\n2.  从给定的随机偏移量 $U$ 开始，生成一组 $N$ 个有序的、均匀间隔的随机数（阈值）。\n3.  对于每个阈值，通过找到其累积权重超过或等于该阈值的第一个粒子来确定相应的祖先粒子。\n\n给定的参数是：\n-   粒子数：$N=8$。\n-   归一化权重向量：$w_{1:8} = \\left(0.04,\\; 0.08,\\; 0.12,\\; 0.06,\\; 0.20,\\; 0.10,\\; 0.30,\\; 0.10\\right)$。\n-   从 $U \\sim \\mathrm{Uniform}(0, 1/N)$ 中抽取的随机偏移量，实现为 $U=0.03$。\n-   索引是基于1的。\n\n首先，我们计算累积和向量 $c$，其中 $c_k = \\sum_{i=1}^{k} w_i$。\n$$\n\\begin{aligned}\nc_1 = w_1 = 0.04 \\\\\nc_2 = w_1 + w_2 = 0.04 + 0.08 = 0.12 \\\\\nc_3 = c_2 + w_3 = 0.12 + 0.12 = 0.24 \\\\\nc_4 = c_3 + w_4 = 0.24 + 0.06 = 0.30 \\\\\nc_5 = c_4 + w_5 = 0.30 + 0.20 = 0.50 \\\\\nc_6 = c_5 + w_6 = 0.50 + 0.10 = 0.60 \\\\\nc_7 = c_6 + w_7 = 0.60 + 0.30 = 0.90 \\\\\nc_8 = c_7 + w_8 = 0.90 + 0.10 = 1.00\n\\end{aligned}\n$$\n累积和向量为 $c_{1:8} = \\left(0.04,\\; 0.12,\\; 0.24,\\; 0.30,\\; 0.50,\\; 0.60,\\; 0.90,\\; 1.00\\right)$。\n\n其次，我们计算 $N=8$ 个等距阈值，我们用向量 $u_{1:8}$ 表示。阈值根据公式 $u_j = U + \\frac{j-1}{N}$ 生成，其中 $j = 1, 2, \\ldots, N$。间距为 $\\frac{1}{N} = \\frac{1}{8} = 0.125$。\n$$\n\\begin{aligned}\nu_1 = U = 0.03 \\\\\nu_2 = 0.03 + 1 \\times 0.125 = 0.155 \\\\\nu_3 = 0.03 + 2 \\times 0.125 = 0.03 + 0.25 = 0.280 \\\\\nu_4 = 0.03 + 3 \\times 0.125 = 0.03 + 0.375 = 0.405 \\\\\nu_5 = 0.03 + 4 \\times 0.125 = 0.03 + 0.5 = 0.530 \\\\\nu_6 = 0.03 + 5 \\times 0.125 = 0.03 + 0.625 = 0.655 \\\\\nu_7 = 0.03 + 6 \\times 0.125 = 0.03 + 0.75 = 0.780 \\\\\nu_8 = 0.03 + 7 \\times 0.125 = 0.03 + 0.875 = 0.905\n\\end{aligned}\n$$\n阈值向量为 $u_{1:8} = \\left(0.03,\\; 0.155,\\; 0.280,\\; 0.405,\\; 0.530,\\; 0.655,\\; 0.780,\\; 0.905\\right)$。\n\n第三，我们确定所选的祖先索引。对于每个阈值 $u_j$，我们找到满足 $u_j \\le c_k$ 的最小整数索引 $k \\in \\{1, 2, ..., 8\\}$。设此索引为 $a_j$。\n\n-   对于 $u_1 = 0.03$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.03$。由于 $c_1 = 0.04 \\ge 0.03$，所选索引为 $a_1=1$。\n-   对于 $u_2 = 0.155$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.155$。我们有 $c_2 = 0.12  0.155$ 且 $c_3 = 0.24 \\ge 0.155$。所选索引为 $a_2=3$。\n-   对于 $u_3 = 0.280$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.280$。我们有 $c_3 = 0.24  0.280$ 且 $c_4 = 0.30 \\ge 0.280$。所选索引为 $a_3=4$。\n-   对于 $u_4 = 0.405$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.405$。我们有 $c_4 = 0.30  0.405$ 且 $c_5 = 0.50 \\ge 0.405$。所选索引为 $a_4=5$。\n-   对于 $u_5 = 0.530$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.530$。我们有 $c_5 = 0.50  0.530$ 且 $c_6 = 0.60 \\ge 0.530$。所选索引为 $a_5=6$。\n-   对于 $u_6 = 0.655$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.655$。我们有 $c_6 = 0.60  0.655$ 且 $c_7 = 0.90 \\ge 0.655$。所选索引为 $a_6=7$。\n-   对于 $u_7 = 0.780$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.780$。我们有 $c_7 = 0.90 \\ge 0.780$。所选索引为 $a_7=7$。\n-   对于 $u_8 = 0.905$：我们寻找最小的 $k$ 使得 $c_k \\ge 0.905$。我们有 $c_7 = 0.90  0.905$ 且 $c_8 = 1.00 \\ge 0.905$。所选索引为 $a_8=8$。\n\n综合这些结果，所选祖先索引的向量为 $(1, 3, 4, 5, 6, 7, 7, 8)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  3  4  5  6  7  7  8\n\\end{pmatrix}\n}\n$$", "id": "3347857"}, {"introduction": "掌握了稳定的权重更新和重采样技术后，我们就可以将这些模块组合起来，构建一个完整的粒子滤波器。这个综合性练习将指导你为一个在计算系统生物学中常见的非线性生灭过程实现一个自举粒子滤波器，用于追踪细胞内分子的数量。通过完成这个练习，你将把所有关键概念——初始化、传播、权重更新和重采样——整合到一个实际的应用中 ([@problem_id:3340174])。", "problem": "您需要设计并实现一个序贯蒙特卡洛（粒子滤波）算法，该算法针对一个隐式计数、非线性生灭模型，这种模型常用于计算系统生物学中描述分子拷贝数。您的程序必须基于贝叶斯定理实现重要性权重的更新，并基于有效样本量准则做出重采样决策。整个任务必须以纯粹的数学和逻辑术语表述，并且最终程序必须使用下面提供的固定种子以确定性方式运行。\n\n模型与假设。潜状态是一个非负整数值过程 $\\{N_t\\}_{t=0,1,\\dots,T}$，代表分子计数。其动态特性在离散时间中通过步长 $\\Delta t$ 指定，使用连续时间非线性密度依赖生灭过程的泊松 tau-leap 近似。对于时间 $t-1$ 处状态为 $N_{t-1}$ 的粒子，在一个步长内，出生数 $B_t$ 和死亡数 $D_t$ 条件独立，其中 $B_t \\sim \\mathrm{Poisson}(\\lambda_b)$，$D_t \\sim \\mathrm{Poisson}(\\lambda_d)$，并且\n$$\n\\lambda_b \\equiv \\frac{\\alpha N_{t-1}}{1 + \\beta N_{t-1}}\\,\\Delta t,\\quad\n\\lambda_d \\equiv \\left(\\delta N_{t-1} + \\gamma N_{t-1}^2\\right)\\,\\Delta t.\n$$\n传播后的状态为 $N_t \\leftarrow \\max\\{0, N_{t-1} + B_t - D_t\\}$。初始状态 $N_0$ 对每个粒子从均值为 $m_0$ 的泊松先验分布中独立采样。\n\n在给定潜状态的情况下，观测模型在时间上条件独立。在每个时间点 $t \\in \\{1,\\dots,T\\}$，根据均值为 $\\kappa N_t + \\eta$ 的泊松分布抽取一个观测值 $Y_t \\in \\mathbb{N}_0$，其中 $\\kappa \\ge 0$ 是一个缩放因子，$\\eta \\ge 0$ 是一个背景项：\n$$\nY_t \\mid N_t \\sim \\mathrm{Poisson}\\!\\left(\\kappa N_t + \\eta\\right).\n$$\n\n滤波任务。考虑由潜过程和观测过程定义的隐马尔可夫模型。实现一个自举粒子滤波器，这是序贯重要性采样 (SIS) 的一个特例，其中提议分布等于转移先验。从 $M$ 个粒子和均匀权重开始。在每个时间点 $t = 1,\\dots,T$：\n- 根据 tau-leap 动态传播每个粒子以获得新状态 $N_t^{(i)}$。\n- 使用时间 $t$ 的观测模型似然，通过应用贝叶斯定理来更新其重要性权重。\n- 对所有粒子的权重进行归一化。\n- 根据归一化的权重计算有效样本量，并使用阈值规则进行重采样决策。如果触发重采样，则执行系统重采样并将权重重置为均匀。\n\n您必须从贝叶斯定理和自举提议分布的选择中推导出重要性权重的更新规则，并在您的解决方案中定义有效样本量和基于阈值的重采样准则。为了在评估观测似然时保证数值稳健性，将泊松均值视为 $\\max\\{\\kappa N_t^{(i)} + \\eta, \\epsilon\\}$，其中 $\\epsilon  0$ 是一个固定的很小的值。\n\n需要计算的输出。对于下方的每个测试用例，您的程序必须返回以下三个量：\n- 最终时间的滤波后验均值，$\\sum_{i=1}^M w_T^{(i)} N_T^{(i)}$，在并入 $Y_T$ 并归一化权重之后，但在时间 $T$ 进行任何重采样之前计算。\n- 在 $t \\in \\{1,\\dots,T\\}$ 期间执行的重采样事件总数。\n- 在时间 $T$ 的最终有效样本量分数，定义为有效样本量除以 $M$，在并入 $Y_T$ 并归一化权重之后，但在时间 $T$ 进行任何重采样之前计算。\n\n所有浮点数输出四舍五入到 $6$ 位小数。整数必须打印为不带小数点的形式。\n\n重采样规则。使用一个阈值参数 $\\tau \\in (0,1)$，并在有效样本量分数严格小于 $\\tau$ 时执行重采样。使用系统重采样，并在重采样后将权重重置为均匀分布。\n\n随机性与确定性。对每个测试用例使用提供的随机种子，以确保输出的确定性。\n\n测试套件。对于每个测试用例，您将获得粒子数 $M$、时间范围 $T$、时间步长 $\\Delta t$、模型参数 $(\\alpha,\\beta,\\delta,\\gamma,\\kappa,\\eta)$、泊松先验均值 $m_0$、重采样阈值 $\\tau$、观测序列 $\\{y_t\\}_{t=1}^T$ 和一个种子 $s$。\n\n- 用例 A (理想情况，中等速率和计数):\n  - $M = 1000$, $T = 5$, $\\Delta t = 0.5$, $(\\alpha,\\beta,\\delta,\\gamma) = (1.2, 0.01, 0.8, 0.001)$, $(\\kappa,\\eta) = (2.0, 1.0)$, $m_0 = 20$, $\\tau = 0.5$, $s = 12345$, 观测值 $[45, 52, 55, 48, 50]$。\n\n- 用例 B (接近灭绝的边界行为，小计数，低先验均值):\n  - $M = 500$, $T = 5$, $\\Delta t = 0.5$, $(\\alpha,\\beta,\\delta,\\gamma) = (0.5, 0.02, 0.9, 0.002)$, $(\\kappa,\\eta) = (1.0, 0.0), $m_0 = 3$, $\\tau = 0.5$, $s = 12346$, 观测值 $[0, 1, 2, 1, 0]$。\n\n- 用例 C (强非线性和背景，中等粒子数):\n  - $M = 800$, $T = 5$, $\\Delta t = 0.2$, $(\\alpha,\\beta,\\delta,\\gamma) = (3.0, 0.05, 1.5, 0.01)$, $(\\kappa,\\eta) = (1.5, 2.0)$, $m_0 = 10$, $\\tau = 0.5$, $s = 12347$, 观测值 $[20, 18, 25, 22, 24]$。\n\n- 用例 D (少量粒子，对退化和重采样频率进行压力测试):\n  - $M = 100$, $T = 5$, $\\Delta t = 0.5$, $(\\alpha,\\beta,\\delta,\\gamma) = (1.0, 0.02, 0.7, 0.002)$, $(\\kappa,\\eta) = (1.2, 0.5)$, $m_0 = 15$, $\\tau = 0.5$, $s = 12348$, 观测值 $[18, 21, 17, 20, 19]$。\n\n数值细节。在评估观测似然时使用 $\\epsilon = 10^{-12}$ 以避免对零取对数。小步长 tau-leap 近似是可以接受的，但请确保对于所有粒子状态，出生和死亡的泊松强度保持非负。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须为每个测试用例包含一个条目，顺序与上面相同。每个条目必须是形如 $[\\text{mean\\_final}, \\text{resample\\_count}, \\text{ess\\_final}]$ 的三元素列表，其中第一个和第三个元素是四舍五入到 $6$ 位小数的浮点数，第二个元素是整数。例如，您的输出必须看起来像\n$[[m_A,r_A,e_A],[m_B,r_B,e_B],[m_C,r_C,e_C],[m_D,r_D,e_D]]$。", "solution": "该问题要求设计并实现一个自举粒子滤波器（序贯蒙特卡洛的一种形式），用于估计计算系统生物学中一个非线性、非高斯状态空间模型的潜状态。该模型描述了分子拷贝数的离散时间演化。我将首先验证问题陈述，然后推导算法的必要组成部分——即重要性权重更新、有效样本量和重采样程序——最后再详细阐述完整算法。\n\n### 问题验证\n\n**第1步：提取给定信息**\n\n- **潜过程 ($N_t$):** 一个非负整数值过程 $\\{N_t\\}_{t=0,1,\\dots,T}$，代表分子拷贝数。\n- **状态转移模型 (Tau-Leap):**\n    - 对于时间 $t-1$ 处状态为 $N_{t-1}$ 的粒子，出生数 $B_t$ 和死亡数 $D_t$ 从条件独立的泊松分布中采样：\n        - $B_t \\sim \\mathrm{Poisson}(\\lambda_b)$\n        - $D_t \\sim \\mathrm{Poisson}(\\lambda_d)$\n    - 泊松率是：\n        - $\\lambda_b = \\frac{\\alpha N_{t-1}}{1 + \\beta N_{t-1}}\\,\\Delta t$\n        - $\\lambda_d = (\\delta N_{t-1} + \\gamma N_{t-1}^2)\\,\\Delta t$\n    - 状态按如下方式传播：$N_t \\leftarrow \\max\\{0, N_{t-1} + B_t - D_t\\}$。\n- **初始状态分布：** 对于每个粒子 $i$，$N_0^{(i)}$ 从均值为 $m_0$ 的泊松分布中独立抽取：$N_0 \\sim \\mathrm{Poisson}(m_0)$。\n- **观测模型：** 在每个时间点 $t \\in \\{1,\\dots,T\\}$，观测值 $Y_t$ 在潜状态 $N_t$ 的条件下从泊松分布中抽取：\n    - $Y_t \\mid N_t \\sim \\mathrm{Poisson}(\\kappa N_t + \\eta)$\n- **滤波算法：** 自举粒子滤波器。\n    - 从 $M$ 个粒子和均匀权重开始。\n    - 在每个时间步 $t=1,\\dots,T$：传播、更新权重、归一化，并在满足准则时重采样。\n- **重采样规则：**\n    - 准则：如果有效样本量分数严格小于阈值 $\\tau$，则进行重采样。\n    - 方法：系统重采样。\n    - 重采样后：权重被重置为均匀。\n- **数值细节：**\n    - 似然稳健性：观测泊松分布的均值为 $\\max\\{\\kappa N_t + \\eta, \\epsilon\\}$，其中 $\\epsilon = 10^{-12}$。\n    - 确定性：为每个测试用例使用指定的随机种子。\n- **每个测试用例的输出：**\n    1.  最终后验均值 $\\mathbb{E}[N_T | Y_{1:T}] \\approx \\sum_{i=1}^M w_T^{(i)} N_T^{(i)}$，在时间 $T$ 重采样之前计算。\n    2.  在 $t=1,\\dots,T$ 期间重采样事件的总数。\n    3.  最终有效样本量分数 $ESS_T/M$，在时间 $T$ 重采样之前计算。\n- **测试用例：**\n    - A: $M = 1000, T = 5, \\Delta t = 0.5, (\\alpha,\\beta,\\delta,\\gamma) = (1.2, 0.01, 0.8, 0.001), (\\kappa,\\eta) = (2.0, 1.0), m_0 = 20, \\tau = 0.5, s = 12345$, 观测值: $[45, 52, 55, 48, 50]$。\n    - B: $M = 500, T = 5, \\Delta t = 0.5, (\\alpha,\\beta,\\delta,\\gamma) = (0.5, 0.02, 0.9, 0.002), (\\kappa,\\eta) = (1.0, 0.0), m_0 = 3, \\tau = 0.5, s = 12346$, 观测值: $[0, 1, 2, 1, 0]$。\n    - C: $M = 800, T = 5, \\Delta t = 0.2, (\\alpha,\\beta,\\delta,\\gamma) = (3.0, 0.05, 1.5, 0.01), (\\kappa,\\eta) = (1.5, 2.0), m_0 = 10, \\tau = 0.5, s = 12347$, 观测值: $[20, 18, 25, 22, 24]$。\n    - D: $M = 100, T = 5, \\Delta t = 0.5, (\\alpha,\\beta,\\delta,\\gamma) = (1.0, 0.02, 0.7, 0.002), (\\kappa,\\eta) = (1.2, 0.5), m_0 = 15, \\tau = 0.5, s = 12348$, 观测值: $[18, 21, 17, 20, 19]$。\n\n**第2步：使用提取的给定信息进行验证**\n\n- **科学依据：** 该模型是连续时间生灭过程的标准离散时间近似（tau-leap），是随机化学动力学和群体动力学的基石。观测模型是一个简单而常见的泊松噪声模型。粒子滤波方法是对此类非线性、非高斯状态空间模型进行推断的最新方法。该问题在科学上是合理的。\n- **问题明确性：** 该问题在数学和算法上定义明确。所有参数、初始条件、数据和算法选择（自举提议、系统重采样）都已指定。使用固定的随机种子确保了存在唯一、确定性的解。\n- **客观性：** 问题使用精确的数学符号和客观语言陈述，没有歧义或主观性陈述。\n\n该问题没有显示出验证标准中列出的任何缺陷。这是一个应用于系统生物学的计算统计学中完整、一致且可解的问题。\n\n**第3步：结论与行动**\n\n此问题是**有效的**。将提供完整的解决方案。\n\n### 算法推导与设计\n\n目标是近似滤波分布序列 $p(N_t | Y_{1:t})$，其中 $t = 1, \\dots, T$。我们使用一组 $M$ 个带权重的粒子 $\\{N_t^{(i)}, w_t^{(i)}\\}_{i=1}^M$ 来表示这个分布。\n\n**1. 初始化 ($t=0$):**\n我们从初始状态的先验分布 $p(N_0)$ 中采样 $M$ 个粒子开始。权重被初始化为均匀分布。\n- 对于 $i = 1, \\dots, M$：采样 $N_0^{(i)} \\sim \\mathrm{Poisson}(m_0)$。\n- 设置初始权重：$w_0^{(i)} = 1/M$。\n\n**2. 序贯重要性采样步骤 (对于 $t=1, \\dots, T$):**\n对于每个时间步，我们执行三个主要操作：传播、权重更新和重采样。\n\n**2.1. 传播 (采样):**\n每个粒子 $N_{t-1}^{(i)}$ 根据状态转移模型 $p(N_t | N_{t-1})$ 向前传播。这定义了自举滤波器的提议分布。对于每个粒子 $i$：\n1. 根据其状态 $N_{t-1}^{(i)}$ 计算出生和死亡强度：\n   $$ \\lambda_b^{(i)} = \\frac{\\alpha N_{t-1}^{(i)}}{1 + \\beta N_{t-1}^{(i)}}\\Delta t $$\n   $$ \\lambda_d^{(i)} = \\left(\\delta N_{t-1}^{(i)} + \\gamma (N_{t-1}^{(i)})^2\\right)\\Delta t $$\n2. 采样出生和死亡事件的数量：\n   $B_t^{(i)} \\sim \\mathrm{Poisson}(\\lambda_b^{(i)})$\n   $D_t^{(i)} \\sim \\mathrm{Poisson}(\\lambda_d^{(i)})$\n3. 获得新状态，确保非负性：\n   $N_t^{(i)} = \\max\\{0, N_{t-1}^{(i)} + B_t^{(i)} - D_t^{(i)}\\}$\n\n**2.2. 权重更新：**\n必须更新重要性权重以考虑新的观测值 $Y_t$。根据序贯重要性采样的原理，权重更新规则是：\n$$ w_t^{(i)} \\propto w_{t-1}^{(i)} \\frac{p(Y_t | N_t^{(i)}) p(N_t^{(i)} | N_{t-1}^{(i)})}{q(N_t^{(i)} | N_{t-1}^{(i)}, Y_t)} $$\n在自举滤波器中，提议分布 $q(\\cdot)$ 被选择为先验动态 $p(N_t | N_{t-1})$。这极大地简化了更新规则：\n$$ w_t^{(i)} \\propto w_{t-1}^{(i)} p(Y_t | N_t^{(i)}) $$\n这里，$p(Y_t | N_t^{(i)})$ 是在给定传播后状态 $N_t^{(i)}$ 的条件下观测到 $Y_t$ 的似然。根据观测模型，这是泊松分布的概率质量函数：\n$$ p(Y_t | N_t^{(i)}) = \\mathrm{Poisson}(Y_t; \\lambda_y^{(i)}) = \\frac{(\\lambda_y^{(i)})^{Y_t} e^{-\\lambda_y^{(i)}}}{Y_t!} $$\n其中 $\\lambda_y^{(i)} = \\max\\{\\kappa N_t^{(i)} + \\eta, \\epsilon\\}$。\n未归一化的权重为 $\\tilde{w}_t^{(i)} = w_{t-1}^{(i)} p(Y_t | N_t^{(i)})$。为避免数值下溢，标准做法是使用对数权重。增量对数权重更新为：\n$$ \\log(\\Delta w_t^{(i)}) = \\log(p(Y_t | N_t^{(i)})) = Y_t \\log(\\lambda_y^{(i)}) - \\lambda_y^{(i)} - \\log(Y_t!) $$\n由于项 $\\log(Y_t!)$ 在时间 $t$ 对所有粒子都是常数，因此可以从计算中省略，因为它将被吸收到归一化常数中。粒子 $i$ 在时间 $t$ 的未归一化对数权重是：\n$$ \\log(\\tilde{w}_t^{(i)}) = \\log(w_{t-1}^{(i)}) + Y_t \\log(\\lambda_y^{(i)}) - \\lambda_y^{(i)} $$\n在为所有粒子计算这些值后，对权重进行归一化：\n$$ w_t^{(i)} = \\frac{\\exp(\\log(\\tilde{w}_t^{(i)}))}{\\sum_{j=1}^M \\exp(\\log(\\tilde{w}_t^{(j)}))} $$\n为防止上溢/下溢，此归一化通过使用 log-sum-exp 技巧来稳健地执行。\n\n**2.3. 重采样：**\n粒子退化，即少数粒子获得所有权重，由有效样本量 (ESS) 监控。ESS 的一个常用估计是：\n$$ \\mathrm{ESS}_t = \\frac{1}{\\sum_{i=1}^M (w_t^{(i)})^2} $$\n其中 $w_t^{(i)}$ 是归一化权重。ESS 的范围从 $1$（完全退化）到 $M$（均匀权重）。\n重采样决策基于 ESS 分数：如果 $\\mathrm{ESS}_t / M  \\tau$，则执行重采样步骤。\n- **系统重采样：** 采用这种低方差方法。\n    1. 从 $U[0, 1/M]$ 中抽取一个随机数 $u_0$。\n    2. 创建一个包含 $M$ 个有序指针的序列：$u_j = u_0 + (j-1)/M$，对于 $j=1, \\dots, M$。\n    3. 计算权重的累积和，$C_k = \\sum_{i=1}^k w_t^{(i)}$。\n    4. 对于每个指针 $u_j$，我们选择粒子索引 $k$ 使得 $C_{k-1}  u_j \\le C_k$。这将通过根据旧粒子集的权重进行有放回的采样，创建一个新的 $M$ 个粒子的集合。\n- **重采样后**，粒子集被新集合替换，所有权重被重置为均匀分布：$w_t^{(i)} = 1/M$。\n\n**3. 最终输出：**\n对于每个测试用例，算法从 $t=1$ 执行到 $T$。\n- 在每个步骤 $t \\in \\{1, \\dots, T\\}$，在权重归一化后，计算 ESS 并检查重采样条件。如果触发，则重采样事件计数器加一。\n- 在最后一步 $t=T$，在传播和权重归一化后，**在**时间 $T$ 的任何潜在重采样之前计算以下量：\n    - 后验均值：$\\hat{N}_T = \\sum_{i=1}^M w_T^{(i)} N_T^{(i)}$。\n    - 最终 ESS 分数：$\\mathrm{ESS}_T / M$。\n- 累积的重采样计数也会被报告。\n\n这完成了粒子滤波器的形式化设计。实现将为每个测试用例精确遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef run_particle_filter(\n    M, T, dt, params, obs_params, m0, tau, seed, observations, epsilon=1e-12\n):\n    \"\"\"\n    Implements a bootstrap particle filter for a nonlinear birth-death model.\n    \"\"\"\n    alpha, beta, delta, gamma = params\n    kappa, eta = obs_params\n    \n    rng = np.random.default_rng(seed)\n    \n    # --- Step 0: Initialization (t=0) ---\n    # Sample initial particles from the Poisson prior\n    particles = rng.poisson(m0, size=M).astype(np.float64)\n    # Initialize uniform weights\n    log_weights = np.full(M, -np.log(M))\n    \n    resample_count = 0\n\n    for t in range(1, T + 1):\n        y_t = observations[t-1]\n        \n        # --- Step 1: Propagation ---\n        # Calculate birth and death rates for all particles\n        # Rates must be non-negative. Since N = 0, they will be.\n        birth_rate = (alpha * particles) / (1.0 + beta * particles) * dt\n        death_rate = (delta * particles + gamma * particles**2) * dt\n        \n        # Sample births and deaths\n        births = rng.poisson(birth_rate)\n        deaths = rng.poisson(death_rate)\n        \n        # Propagate state, ensuring non-negativity\n        particles = np.maximum(0.0, particles + births - deaths)\n        \n        # --- Step 2: Weight Update ---\n        # Calculate observation mean for each particle\n        obs_mean = np.maximum(kappa * particles + eta, epsilon)\n        \n        # Calculate incremental log-weights (log-likelihood contribution)\n        # We can ignore the log(y_t!) term as it's constant for all particles.\n        # log L(y_t|N_t) = y_t * log(lambda_y) - lambda_y\n        delta_log_w = y_t * np.log(obs_mean) - obs_mean\n        log_weights += delta_log_w\n        \n        # --- Step 3: Weight Normalization (Log-Sum-Exp) ---\n        max_log_w = np.max(log_weights)\n        if np.isneginf(max_log_w): # All particles have zero weight\n            # This can happen if all particles have a state that makes the observation impossible.\n            # Reset to uniform weights to prevent total failure.\n            log_weights = np.full(M, -np.log(M))\n        else:\n            log_weights -= max_log_w\n            weights = np.exp(log_weights)\n            sum_weights = np.sum(weights)\n            weights /= sum_weights\n            log_weights = np.log(weights)\n\n        # Before resampling, calculate quantities if it's the final step\n        if t == T:\n            # Final posterior mean\n            final_mean = np.sum(weights * particles)\n            # Final ESS fraction\n            final_ess_frac = (1.0 / np.sum(weights**2)) / M\n            # Check for resampling at T and update count\n            # Problem description is a bit ambiguous. It says \"total count of resampling events performed across t in {1,...,T}\"\n            # This implies checking the condition at t=T and counting it, even if the resampling itself is not part of the final state calculation\n            # My current interpretation: final outputs are calculated before the final resampling operation, but the decision to resample at T is still counted.\n            if final_ess_frac  tau:\n                resample_count += 1\n            \n            return final_mean, resample_count, final_ess_frac\n\n        # --- Step 4: Resampling Decision ---\n        # Calculate normalized weights to compute ESS\n        weights = np.exp(log_weights)\n        ess_frac = (1.0 / np.sum(weights**2)) / M\n\n        if ess_frac  tau:\n            resample_count += 1\n            \n            # Perform systematic resampling\n            positions = (rng.random() + np.arange(M)) / M\n            cdf = np.cumsum(weights)\n            indices = np.searchsorted(cdf, positions, side='left')\n            # Ensure indices are valid\n            indices = np.minimum(indices, M - 1)\n            \n            particles = particles[indices]\n            \n            # Reset weights to uniform\n            log_weights = np.full(M, -np.log(M))\n\n    # This part should not be reached due to the return inside the t==T block\n    return None, None, None\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            # Case A (happy path, moderate rates and counts)\n            \"M\": 1000, \"T\": 5, \"dt\": 0.5, \"params\": (1.2, 0.01, 0.8, 0.001), \n            \"obs_params\": (2.0, 1.0), \"m0\": 20, \"tau\": 0.5, \"seed\": 12345, \n            \"observations\": [45, 52, 55, 48, 50]\n        },\n        {\n            # Case B (boundary behavior near extinction, small counts, low prior mean)\n            \"M\": 500, \"T\": 5, \"dt\": 0.5, \"params\": (0.5, 0.02, 0.9, 0.002), \n            \"obs_params\": (1.0, 0.0), \"m0\": 3, \"tau\": 0.5, \"seed\": 12346, \n            \"observations\": [0, 1, 2, 1, 0]\n        },\n        {\n            # Case C (strong nonlinearity and background, moderate particles)\n            \"M\": 800, \"T\": 5, \"dt\": 0.2, \"params\": (3.0, 0.05, 1.5, 0.01), \n            \"obs_params\": (1.5, 2.0), \"m0\": 10, \"tau\": 0.5, \"seed\": 12347, \n            \"observations\": [20, 18, 25, 22, 24]\n        },\n        {\n            # Case D (few particles, stress-test for degeneracy and resampling frequency)\n            \"M\": 100, \"T\": 5, \"dt\": 0.5, \"params\": (1.0, 0.02, 0.7, 0.002), \n            \"obs_params\": (1.2, 0.5), \"m0\": 15, \"tau\": 0.5, \"seed\": 12348, \n            \"observations\": [18, 21, 17, 20, 19]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        mean_final, resample_count, ess_final = run_particle_filter(**case)\n        all_results.append(\n            f\"[{mean_final:.6f},{resample_count},{ess_final:.6f}]\"\n        )\n    \n    print(f\"[[{','.join(all_results)}]]\")\n\nsolve()\n```", "id": "3340174"}]}