{"hands_on_practices": [{"introduction": "在构建复杂的多尺度模型之前，通过量纲分析来把握问题的核心物理过程至关重要。这种方法可以简化控制方程，并将众多参数合并为少数几个关键的无量纲数，从而揭示不同物理过程之间的相对重要性。本练习 ([@problem_id:3330669]) 将指导你对一个反应-扩散方程进行无量纲化，识别出如 Damköhler 数这样的关键参数，并理解它们如何帮助我们选择合适的建模策略——例如，何时可以使用简化的连续介质模型，何时又必须采用更精细的离散细胞模型。", "problem": "考虑一个扩散信号分子的混合多尺度模型，其浓度场为 $c(\\mathbf{x},t)$，存在于一个特征长度尺度为 $L$ 的三维组织域中。在组织尺度上，浓度根据质量守恒和菲克扩散进行演化，并伴随由生物化学降解和细胞摄取引起的线性清除。宏观动力学由以下偏微分方程 (PDE) 表示：\n$$\n\\partial_t c(\\mathbf{x},t) = D \\nabla^2 c(\\mathbf{x},t) - k\\,c(\\mathbf{x},t) - \\lambda\\,c(\\mathbf{x},t),\n$$\n其中 $D$ 是扩散系数，$k$ 是内在的一阶生物化学清除率，$\\lambda$ 是一个有效的一阶摄取速率系数，它在均质化假设下，将离散的细胞级摄取事件聚合成一个连续的汇项。\n\n从质量守恒和菲克扩散定律出发，使用尺度变换关系 $c = c_0 \\tilde{c}$、$\\mathbf{x} = L \\tilde{\\mathbf{x}}$ 和 $t = \\tau \\tilde{t}$ 对该方程进行无量纲化，其中 $\\tau$ 选择为扩散时间尺度。识别出两个控制过程平衡的、独立的、可解释的无量纲群：一个用于捕捉域尺度上反应与扩散的比率，另一个用于衡量细胞摄取相对于内在生物化学清除的强度。然后，解释这些群的量级如何为多尺度混合建模的机制选择提供信息，特别是判断对摄取的连续介质近似是否合适，或者在细胞尺度上基于离散事件的建模是否必要。\n\n对于一个参数为 $L = 500~\\mu\\mathrm{m}$、$D = 2 \\times 10^{-10}~\\mathrm{m}^2\\,\\mathrm{s}^{-1}$、$k = 1 \\times 10^{-3}~\\mathrm{s}^{-1}$ 和 $\\lambda = 5 \\times 10^{-4}~\\mathrm{s}^{-1}$ 的组织板，计算你所识别的两个无量纲群。将最终值表示为无量纲数，并将答案四舍五入到四位有效数字。以单行矩阵 $(\\mathrm{Da}, \\Lambda)$ 的顺序报告这两个无量纲群的最终数值。", "solution": "首先对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程：** 信号分子的浓度 $c(\\mathbf{x},t)$ 根据以下偏微分方程 (PDE) 演化：\n$$\n\\partial_t c(\\mathbf{x},t) = D \\nabla^2 c(\\mathbf{x},t) - k\\,c(\\mathbf{x},t) - \\lambda\\,c(\\mathbf{x},t)\n$$\n- **变量定义：**\n  - $c(\\mathbf{x},t)$：三维组织域中的浓度场。\n  - $\\mathbf{x}$：位置向量。\n  - $t$：时间。\n- **参数定义：**\n  - $D$：扩散系数。\n  - $k$：内在的一阶生物化学清除率。\n  - $\\lambda$：有效的一阶摄取速率系数。\n  - $L$：组织域的特征长度尺度。\n- **无量纲化尺度变换：**\n  - $c = c_0 \\tilde{c}$，其中 $c_0$ 是特征浓度。\n  - $\\mathbf{x} = L \\tilde{\\mathbf{x}}$。\n  - $t = \\tau \\tilde{t}$，其中 $\\tau$ 选择为扩散时间尺度。\n- **用于计算的数值：**\n  - $L = 500~\\mu\\mathrm{m}$\n  - $D = 2 \\times 10^{-10}~\\mathrm{m}^2\\,\\mathrm{s}^{-1}$\n  - $k = 1 \\times 10^{-3}~\\mathrm{s}^{-1}$\n  - $\\lambda = 5 \\times 10^{-4}~\\mathrm{s}^{-1}$\n- **任务：**\n  1. 对控制方程进行无量纲化。\n  2. 识别两个独立的、可解释的无量纲群。\n  3. 解释这些群对于多尺度建模机制选择的意义。\n  4. 计算这两个群的数值，记为 $(\\mathrm{Da}, \\Lambda)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 控制方程是标准的线性反应扩散方程，是物理学、化学和生物学中输运现象建模的基石。菲克扩散、一阶反应/清除和均质化的概念是公认的科学原理。该问题牢固地植根于计算系统生物学领域。\n- **适定性：** 该问题是一个定义明确的数学任务。它提供了一个偏微分方程和一套清晰的分析指令（无量纲化、参数识别、解释和计算）。它为数值计算部分提供了所有必要的数据。\n- **客观性：** 语言精确且定量。术语是该领域的标准术语，并提供了定义。任务是客观的，不涉及主观判断。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它具有科学合理性、适定性和客观性。没有矛盾、缺失信息或不成立的前提。接下来将进行完整求解。\n\n### 求解推导\n\n分析始于对控制 PDE 的无量纲化。我们引入由以下尺度变换关系定义的无量纲变量 $\\tilde{c}$、$\\tilde{\\mathbf{x}}$ 和 $\\tilde{t}$：\n$c = c_0 \\tilde{c}$\n$\\mathbf{x} = L \\tilde{\\mathbf{x}}$\n$t = \\tau \\tilde{t}$\n\n根据这些尺度变换关系，我们可以变换微分算子。空间导数使用链式法则进行变换。关于 $\\mathbf{x}$ 的梯度算子 $\\nabla$ 与关于 $\\tilde{\\mathbf{x}}$ 的梯度算子 $\\tilde{\\nabla}$ 的关系如下：\n$$ \\nabla = \\frac{\\partial}{\\partial \\mathbf{x}} = \\frac{\\partial \\tilde{\\mathbf{x}}}{\\partial \\mathbf{x}} \\frac{\\partial}{\\partial \\tilde{\\mathbf{x}}} = \\frac{1}{L} \\tilde{\\nabla} $$\n这意味着拉普拉斯算子变换为：\n$$ \\nabla^2 = \\nabla \\cdot \\nabla = \\left(\\frac{1}{L} \\tilde{\\nabla}\\right) \\cdot \\left(\\frac{1}{L} \\tilde{\\nabla}\\right) = \\frac{1}{L^2} \\tilde{\\nabla}^2 $$\n时间导数变换为：\n$$ \\frac{\\partial}{\\partial t} = \\frac{d \\tilde{t}}{d t} \\frac{\\partial}{\\partial \\tilde{t}} = \\frac{1}{\\tau} \\frac{\\partial}{\\partial \\tilde{t}} $$\n将这些变换后的算子和尺度化的浓度 $c = c_0 \\tilde{c}$ 代入原始 PDE：\n$$ \\frac{1}{\\tau} \\frac{\\partial (c_0 \\tilde{c})}{\\partial \\tilde{t}} = D \\left(\\frac{1}{L^2} \\tilde{\\nabla}^2 (c_0 \\tilde{c})\\right) - k(c_0 \\tilde{c}) - \\lambda(c_0 \\tilde{c}) $$\n假设特征浓度 $c_0$ 是一个非零常数，可以将其从所有项中因子分解并消去：\n$$ \\frac{c_0}{\\tau} \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\frac{D c_0}{L^2} \\tilde{\\nabla}^2 \\tilde{c} - (k + \\lambda) c_0 \\tilde{c} $$\n$$ \\frac{1}{\\tau} \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\frac{D}{L^2} \\tilde{\\nabla}^2 \\tilde{c} - (k + \\lambda) \\tilde{c} $$\n问题陈述指出，特征时间尺度 $\\tau$ 是长度 $L$ 上的扩散时间尺度。该时间尺度由 $\\tau = L^2/D$ 给出。将此代入方程：\n$$ \\frac{1}{(L^2/D)} \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\frac{D}{L^2} \\tilde{\\nabla}^2 \\tilde{c} - (k + \\lambda) \\tilde{c} $$\n$$ \\frac{D}{L^2} \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\frac{D}{L^2} \\tilde{\\nabla}^2 \\tilde{c} - (k + \\lambda) \\tilde{c} $$\n为了得到扩散项和时间导数项系数为 $1$ 的规范无量纲形式，我们将整个方程乘以因子 $L^2/D$：\n$$ \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\tilde{\\nabla}^2 \\tilde{c} - \\frac{(k + \\lambda)L^2}{D} \\tilde{c} $$\n这就是控制方程的无量纲形式。无量纲群 $\\frac{(k + \\lambda)L^2}{D}$ 控制着总清除相对于扩散的强度。\n\n我们需要识别两个独立的、可解释的无量纲群。我们可以将组合群分解如下：\n$$ \\frac{(k + \\lambda)L^2}{D} = \\frac{kL^2}{D} + \\frac{\\lambda L^2}{D} $$\n第一个群，按要求应捕捉“反应与扩散的比率”。这就是达姆科勒数 (Damköhler number)，它比较了扩散的特征时间尺度 ($\\tau_{diff} = L^2/D$) 与反应的特征时间尺度 ($\\tau_{reac} = 1/k$)。将“反应”与内在生物化学清除率 $k$ 相关联，我们定义第一个群为：\n$$ \\mathrm{Da} \\equiv \\frac{\\tau_{diff}}{\\tau_{reac}} = \\frac{kL^2}{D} $$\n第二个群应衡量“细胞摄取相对于内在生物化学清除的相对强度”。这是它们各自速率系数 $\\lambda$ 和 $k$ 的比值。我们定义这个第二个群 $\\Lambda$ 为：\n$$ \\Lambda \\equiv \\frac{\\lambda}{k} $$\n这两个群 $\\mathrm{Da}$ 和 $\\Lambda$ 是独立的，并具有清晰的物理解释。我们可以用它们来重写无量纲方程：\n$$ \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\tilde{\\nabla}^2 \\tilde{c} - \\left(\\frac{kL^2}{D} + \\frac{\\lambda}{k} \\frac{kL^2}{D}\\right) \\tilde{c} $$\n$$ \\frac{\\partial \\tilde{c}}{\\partial \\tilde{t}} = \\tilde{\\nabla}^2 \\tilde{c} - (\\mathrm{Da} + \\Lambda \\mathrm{Da})\\tilde{c} = \\tilde{\\nabla}^2 \\tilde{c} - \\mathrm{Da}(1+\\Lambda)\\tilde{c} $$\n复合群 $\\mathrm{Da}(1+\\Lambda)$ 是组合清除过程的总达姆科勒数。\n\n接下来，我们解释这些群的量级对于多尺度建模的意义。原始方程中的项 $\\lambda c$ 是对单个细胞离散摄取事件的连续介质近似（均质化）。该近似的有效性取决于信号分子是否扩散得足够远，以“平均掉”细胞汇的离散性。由于反应和摄取导致浓度梯度衰减的特征长度尺度是反应-扩散长度，$L_{rd} = \\sqrt{D/k_{tot}} = \\sqrt{D/(k+\\lambda)}$。\n当这个长度尺度远大于细胞间的特征距离 $l_{cell}$ 时，即 $L_{rd} \\gg l_{cell}$ 时，连续介质近似是有效的。\n用我们的无量纲群表示：\n$$ L_{rd} = \\sqrt{\\frac{D}{k(1+\\lambda/k)}} = \\sqrt{\\frac{D}{k(1+\\Lambda)}} = \\sqrt{\\frac{L^2 D}{kL^2(1+\\Lambda)}} = L \\sqrt{\\frac{1}{\\mathrm{Da}(1+\\Lambda)}} = \\frac{L}{\\sqrt{\\mathrm{Da}(1+\\Lambda)}} $$\n连续介质模型有效的条件 $L_{rd} \\gg l_{cell}$ 变为 $\\frac{L}{\\sqrt{\\mathrm{Da}(1+\\Lambda)}} \\gg l_{cell}$，或者整理后为 $\\mathrm{Da}(1+\\Lambda) \\ll \\left(\\frac{L}{l_{cell}}\\right)^2$。\n- 如果 $\\mathrm{Da}(1+\\Lambda)$ 很小，则扩散主导清除。$L_{rd}$ 很大，意味着一个分子在被清除前会扩散经过许多细胞。浓度场是平滑的，均质化的连续介质模型是合适的。\n- 如果 $\\mathrm{Da}(1+\\Lambda)$ 很大，则清除主导扩散。$L_{rd}$ 很小。如果 $L_{rd}$ 变得与细胞间距 $l_{cell}$ 相当或更小，浓度场将在每个细胞周围表现出陡峭的梯度。汇的离散性质变得至关重要，连续介质近似失效。在这种机制下，需要一个离散（例如，基于代理的）或混合模型，其中细胞被明确表示。\n群 $\\Lambda = \\lambda/k$ 指示了主导的清除机制。如果 $\\Lambda \\gg 1$，细胞摄取占主导，正确地对其建模（连续介质 vs. 离散）至关重要。如果 $\\Lambda \\ll 1$，则内在降解占主导，摄取模型的细节可能就不那么重要了。\n\n最后，我们计算这两个已识别群的数值。\n给定参数：\n$L = 500~\\mu\\mathrm{m} = 5 \\times 10^{-4}~\\mathrm{m}$\n$D = 2 \\times 10^{-10}~\\mathrm{m}^2\\,\\mathrm{s}^{-1}$\n$k = 1 \\times 10^{-3}~\\mathrm{s}^{-1}$\n$\\lambda = 5 \\times 10^{-4}~\\mathrm{s}^{-1}$\n\n达姆科勒数 $\\mathrm{Da}$ 的计算：\n$$ \\mathrm{Da} = \\frac{kL^2}{D} = \\frac{(1 \\times 10^{-3}~\\mathrm{s}^{-1})(5 \\times 10^{-4}~\\mathrm{m})^2}{2 \\times 10^{-10}~\\mathrm{m}^2\\,\\mathrm{s}^{-1}} $$\n$$ \\mathrm{Da} = \\frac{(1 \\times 10^{-3})(25 \\times 10^{-8})}{2 \\times 10^{-10}} = \\frac{25 \\times 10^{-11}}{2 \\times 10^{-10}} = \\frac{2.5 \\times 10^{-10}}{2 \\times 10^{-10}} = 1.25 $$\n摄取-清除比 $\\Lambda$ 的计算：\n$$ \\Lambda = \\frac{\\lambda}{k} = \\frac{5 \\times 10^{-4}~\\mathrm{s}^{-1}}{1 \\times 10^{-3}~\\mathrm{s}^{-1}} = 0.5 $$\n问题要求将答案四舍五入到四位有效数字。\n$\\mathrm{Da} = 1.250$\n$\\Lambda = 0.5000$\n\n这两个无量纲群的最终值为 $(\\mathrm{Da}, \\Lambda) = (1.250, 0.5000)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.250 & 0.5000\n\\end{pmatrix}\n}\n$$", "id": "3330669"}, {"introduction": "理解了何时选择不同尺度的模型后，下一步的关键是学习如何将它们有效地耦合在一起。混合建模的核心挑战之一在于确保在离散的、随机的细胞域与连续的、确定性的组织域之间交换物质（或信息）时，系统总质量是守恒的。在本练习 ([@problem_id:3330619]) 中，你将亲手实现一个基于通量的耦合方案，这是许多混合模拟平台中的基石技术，从而深刻理解如何处理跨尺度接口上的质量平衡问题。", "problem": "考虑一个一维组织段，它由一个使用 Gillespie 随机模拟算法 (SSA) 的中央隔室和由扩散-衰变偏微分方程建模的外部区域组成。长度为 $L_s$ 的中央随机隔室包含离散数量的分子 $N_s$，其两侧各有一个等宽为 $h$ 的外部有限体积单元，浓度分别为 $c_L$（左单元）和 $c_R$（右单元）。分子交换仅通过中央隔室与直接相邻的外部单元之间的扩散发生；外部区域通过扩散和线性衰变演化，而中央隔室则通过 SSA 反应演化。\n\n外部动力学由扩散-衰变方程控制\n$$\n\\partial_t c = D \\,\\partial_{xx} c - k\\, c,\n$$\n其中 $D$ 是扩散系数，$k$ 是一阶衰变率。SSA 隔室通过 $c_s = N_s/L_s$ 将其离散分子数 $N_s$ 映射为浓度。设 $A$ 表示横截面积，为简便起见，本问题中取 $A = 1$。每个界面上的交换遵循菲克定律。使用单元中心之间的中心差分来近似跨面的梯度，穿过左界面（左单元和中央隔室之间）的向右通量 $F$ 为\n$$\nF_{\\text{left}} = - D \\,\\frac{c_s - c_L}{d},\n$$\n穿过右界面（中央隔室和右单元之间）的通量为\n$$\nF_{\\text{right}} = - D \\,\\frac{c_R - c_s}{d},\n$$\n其中 $d = \\tfrac{1}{2}(h + L_s)$ 是各自单元中心之间的距离。按照惯例，正值 $F$ 表示向右的通量。在单个时间步长 $\\Delta t$ 内，对于外部边界为零通量的情况，外部单元的有限体积更新公式为\n$$\nc_L^{n+1} = c_L^n - \\frac{\\Delta t}{h}\\,F_{\\text{left}} - k\\,c_L^n\\,\\Delta t,\n\\quad\nc_R^{n+1} = c_R^n + \\frac{\\Delta t}{h}\\,F_{\\text{right}} - k\\,c_R^n\\,\\Delta t.\n$$\n设 $\\Delta N_{\\text{rxn}}$ 为在时间步长 $\\Delta t$ 内，中央隔室中由 SSA 反应产生（正值）或消耗（负值）的分子净数量。必须计算在 $\\Delta t$ 内进入 SSA 隔室的总扩散交换量，以保持详细的质量平衡。您必须使用上述基本定律和定义，为 SSA 隔室 $N_s$ 推导并实现质量守恒的交换更新，使得在 $\\Delta t$ 内所有三个隔室的质量变化总和等于 SSA 反应产生量与外部衰变损失量之和。\n\n所有量均具有以下单位，并且必须一致地处理：$D$ 的单位是 $\\mu\\text{m}^2/\\text{s}$，$k$ 的单位是 $\\text{s}^{-1}$，$h$ 和 $L_s$ 的单位是 $\\mu\\text{m}$，$c$ 的单位是 分子数$/\\mu\\text{m}$，$N_s$ 的单位是 分子数，$\\Delta t$ 的单位是 $\\text{s}$。将所有分子数表示为实值浮点数（不四舍五入），所有浓度单位为 分子数$/\\mu\\text{m}$。\n\n您的程序必须针对以下每个测试用例，在单个时间步长 $\\Delta t$ 内计算：\n- 进入 SSA 隔室的净扩散交换量 $\\Delta N_{\\text{ex}}$（单位：分子数），\n- 更新后的 SSA 分子数 $N_s^{n+1}$（单位：分子数），\n- 更新后的外部浓度 $c_L^{n+1}$ 和 $c_R^{n+1}$（单位：分子数$/\\mu\\text{m}$），\n- 质量平衡残差，定义为\n$$\n\\text{residual} = \\Big( N_s^{n+1} + h\\,c_L^{n+1} + h\\,c_R^{n+1} \\Big) - \\Big( N_s^n + h\\,c_L^n + h\\,c_R^n \\Big) - \\Big( \\Delta N_{\\text{rxn}} - k\\,\\Delta t\\,h\\,(c_L^n + c_R^n) \\Big),\n$$\n如果交换实现正确，该值在数值上应接近 $0$。\n\n使用以下测试套件，它探索了理想路径、对称性、无扩散和非对称几何条件：\n- 测试 1：$D = 10$, $k = 0.05$, $h = 5$, $L_s = 5$, $\\Delta t = 0.1$, $N_s = 500$, $c_L = 140$, $c_R = 80$, $\\Delta N_{\\text{rxn}} = 0$。\n- 测试 2：$D = 10$, $k = 0.1$, $h = 5$, $L_s = 5$, $\\Delta t = 0.1$, $N_s = 500$, $c_L = 100$, $c_R = 100$, $\\Delta N_{\\text{rxn}} = 10$。\n- 测试 3：$D = 0$, $k = 0$, $h = 5$, $L_s = 5$, $\\Delta t = 0.1$, $N_s = 500$, $c_L = 120$, $c_R = 80$, $\\Delta N_{\\text{rxn}} = -5$。\n- 测试 4：$D = 20$, $k = 0$, $h = 10$, $L_s = 2$, $\\Delta t = 0.05$, $N_s = 200$, $c_L = 50$, $c_R = 200$, $\\Delta N_{\\text{rxn}} = 0$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按顺序为每个测试用例连接五个浮点数 $[\\Delta N_{\\text{ex}}, N_s^{n+1}, c_L^{n+1}, c_R^{n+1}, \\text{residual}]$。对于所有数值输出，请使用原始浮点数（无百分号），并确保单位如上所述。", "solution": "核心要求是设计一个随机隔室与周围确定性扩散-衰变外部区域之间的数学上一致的耦合，以保证在时间步长 $\\Delta t$ 内的详细质量平衡。我们将推导建立在以下原则之上：\n- 菲克扩散定律：通量 $J$ 为 $J = -D\\,\\partial_x c$。\n- 有限体积守恒：单元中平均浓度的变化等于通过其边界的净通量除以其体积（此处在一维情况下，横截面积设为 $1$，体积简化为长度 $h$），再减去任何反应项。\n- SSA 隔室中离散分子与浓度之间的映射：$c_s = N_s/L_s$。\n\n我们通过与中央 SSA 隔室相邻的两个有限体积单元来离散化外部区域：一个平均浓度为 $c_L$ 的左单元和一个平均浓度为 $c_R$ 的右单元。假设每个界面区域具有均匀的属性和线性浓度分布，左单元中心与 SSA 中心之间、以及 SSA 中心与右单元中心之间的距离由 $d = \\tfrac{1}{2}(h + L_s)$ 建模。\n\n使用中心差分计算左界面（左单元中心到 SSA 中心）上的梯度，向右的通量为\n$$\nF_{\\text{left}} = -D\\,\\frac{c_s - c_L}{d}。\n$$\n正的 $F_{\\text{left}}$ 表示从左单元流入 SSA 隔室的净流量（穿过左界面向右）。在右界面（SSA 中心到右单元中心）上，向右的通量为\n$$\nF_{\\text{right}} = -D\\,\\frac{c_R - c_s}{d}。\n$$\n正的 $F_{\\text{right}}$ 表示从 SSA 隔室流入右外部单元的净流量（穿过右界面向右）。\n\n对于每个外部单元，在单个时间步长 $\\Delta t$ 内，具有零通量外部边界的一维有限体积守恒给出，\n$$\nc_L^{n+1} = c_L^n - \\frac{\\Delta t}{h}\\,F_{\\text{left}} - k\\,c_L^n\\,\\Delta t,\n$$\n$$\nc_R^{n+1} = c_R^n + \\frac{\\Delta t}{h}\\,F_{\\text{right}} - k\\,c_R^n\\,\\Delta t.\n$$\n符号遵循标准更新公式 $c_i^{n+1} = c_i^n - (\\Delta t/h)\\,(F_{i+1/2} - F_{i-1/2}) - k\\,c_i^n\\,\\Delta t$，其中 $F_{L-1/2} = 0$ 且 $F_{R+1/2} = 0$。\n\nSSA 隔室必须接收等于来自左界面和右界面的流入量之和的净扩散交换量（取适当的符号以表示流入 SSA）。从左界面流入 SSA 的量等于 $+\\Delta t\\,F_{\\text{left}}$（穿过左界面向右的正通量将分子从左单元移入 SSA）。从右界面流入 SSA 的量等于 $-\\Delta t\\,F_{\\text{right}}$（穿过右界面向右的正通量将分子从 SSA 移入右单元，这是从 SSA 流出的；因此流入量是其负值）。因此，进入 SSA 的净扩散交换量为\n$$\n\\Delta N_{\\text{ex}} = \\Delta t\\,\\Big(F_{\\text{left}} - F_{\\text{right}}\\Big).\n$$\n设 $\\Delta N_{\\text{rxn}}$ 表示在时间步长 $\\Delta t$ 内由 SSA 反应产生（正）或消耗（负）的净分子数。则 SSA 隔室的更新公式为\n$$\nN_s^{n+1} = N_s^n + \\Delta N_{\\text{rxn}} + \\Delta N_{\\text{ex}}.\n$$\n根据构造，跨界面的详细质量平衡得以保持，因为由界面通量引起的外部区域净质量变化等于 $-\\Delta N_{\\text{ex}}$：\n$$\n\\Delta M_{\\text{ext, interface}} = h\\,(c_L^{n+1} - c_L^n)_{\\text{interface}} + h\\,(c_R^{n+1} - c_R^n)_{\\text{interface}} = -\\Delta t\\,F_{\\text{left}} + \\Delta t\\,F_{\\text{right}} = -\\Delta N_{\\text{ex}}.\n$$\n因此，对所有隔室求和，唯一的净质量产生或损失源于中央隔室内的 SSA 反应和外部单元中的外部衰变：\n$$\n\\Big(N_s^{n+1} + h\\,c_L^{n+1} + h\\,c_R^{n+1}\\Big) - \\Big(N_s^n + h\\,c_L^n + h\\,c_R^n\\Big) = \\Delta N_{\\text{rxn}} - k\\,\\Delta t\\,h\\,(c_L^n + c_R^n).\n$$\n为了在数值上验证质量守恒，我们计算残差\n$$\n\\text{residual} = \\Big( N_s^{n+1} + h\\,c_L^{n+1} + h\\,c_R^{n+1} \\Big) - \\Big( N_s^n + h\\,c_L^n + h\\,c_R^n \\Big) - \\Big( \\Delta N_{\\text{rxn}} - k\\,\\Delta t\\,h\\,(c_L^n + c_R^n) \\Big),\n$$\n在浮点舍入误差范围内，其计算结果应为 $0$。\n\n每个测试用例的算法步骤：\n- 计算 $c_s = N_s/L_s$ 和 $d = \\tfrac{1}{2}(h + L_s)$。\n- 使用上述公式计算 $F_{\\text{left}}$ 和 $F_{\\text{right}}$。\n- 计算 $\\Delta N_{\\text{ex}} = \\Delta t\\,(F_{\\text{left}} - F_{\\text{right}})$。\n- 使用 $N_s^{n+1} = N_s^n + \\Delta N_{\\text{rxn}} + \\Delta N_{\\text{ex}}$ 更新 $N_s^{n+1}$。\n- 更新外部浓度：\n  $c_L^{n+1} = c_L^n - (\\Delta t/h)\\,F_{\\text{left}} - k\\,c_L^n\\,\\Delta t$ 以及\n  $c_R^{n+1} = c_R^n + (\\Delta t/h)\\,F_{\\text{right}} - k\\,c_R^n\\,\\Delta t$。\n- 计算残差以验证质量平衡。\n\n对于所提供的时间步长和参数（例如，选择的 $D$ 和 $h$ 使得 $\\Delta t/h^2$ 保持较小），该显式格式在科学上是现实且稳定的，并且仅使用基本定律，没有使用快捷公式。程序按要求为每个测试用例输出五个浮点数，顺序为 $[\\Delta N_{\\text{ex}}, N_s^{n+1}, c_L^{n+1}, c_R^{n+1}, \\text{residual}]$，并将所有测试用例的结果连接成单行上的一个方括号列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hybrid_step(D, k, h, Ls, dt, Ns, cL, cR, dN_rxn):\n    \"\"\"\n    Perform one hybrid step coupling a central SSA compartment and two exterior PDE cells.\n    Units:\n      D: um^2/s\n      k: 1/s\n      h, Ls: um\n      dt: s\n      Ns: molecules\n      cL, cR: molecules/um\n      dN_rxn: molecules\n    Returns:\n      (dN_ex, Ns_new, cL_new, cR_new, residual)\n    \"\"\"\n    # Map SSA molecules to concentration in the compartment\n    cs = Ns / Ls\n    # Distance between centers across each interface\n    d = 0.5 * (h + Ls)\n\n    # Face-to-the-right fluxes by Fick's law (central differences)\n    F_left = -D * (cs - cL) / d      # left interface: left cell (cL) to SSA (cs)\n    F_right = -D * (cR - cs) / d     # right interface: SSA (cs) to right cell (cR)\n\n    # Net diffusive exchange into SSA (in molecules) over dt\n    dN_ex = dt * (F_left - F_right)\n\n    # Update SSA molecule count with reactions and exchange\n    Ns_new = Ns + dN_rxn + dN_ex\n\n    # Exterior updates via finite volume with zero outer fluxes\n    cL_new = cL - (dt / h) * F_left - k * cL * dt\n    cR_new = cR + (dt / h) * F_right - k * cR * dt\n\n    # Mass-balance residual check (should be ~0)\n    M_before = Ns + h * (cL + cR)\n    M_after = Ns_new + h * (cL_new + cR_new)\n    predicted_change = dN_rxn - k * dt * h * (cL + cR)\n    residual = M_after - M_before - predicted_change\n\n    return dN_ex, Ns_new, cL_new, cR_new, residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (D, k, h, Ls, dt, Ns, cL, cR, dN_rxn)\n    test_cases = [\n        (10.0, 0.05, 5.0, 5.0, 0.1, 500.0, 140.0, 80.0, 0.0),    # Test 1\n        (10.0, 0.1, 5.0, 5.0, 0.1, 500.0, 100.0, 100.0, 10.0),   # Test 2\n        (0.0, 0.0, 5.0, 5.0, 0.1, 500.0, 120.0, 80.0, -5.0),     # Test 3\n        (20.0, 0.0, 10.0, 2.0, 0.05, 200.0, 50.0, 200.0, 0.0),   # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        D, k, h, Ls, dt, Ns, cL, cR, dN_rxn = case\n        dN_ex, Ns_new, cL_new, cR_new, residual = hybrid_step(D, k, h, Ls, dt, Ns, cL, cR, dN_rxn)\n        # Append results in required flat order for each test case\n        results.extend([dN_ex, Ns_new, cL_new, cR_new, residual])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3330619"}, {"introduction": "在掌握了核心的耦合技术之后，我们的下一个目标是提升模拟的计算效率。本练习 ([@problem_id:3330692]) 将介绍自适应网格加密（AMR）技术，这是一种将计算资源集中在最需要区域的强大方法。你将学习如何利用离散智能体（细胞）的状态来动态地加密连续介质偏微分方程的求解网格，这对于高效处理具有局域活动和尖锐梯度的多尺度问题至关重要。", "problem": "考虑一个占据域 $[0,1]$ 的一维无量纲组织段。一个扩散和降解的分子场 $u(x)$ 由位于 $\\{x_j\\}$ 位置的离散主体产生，这些主体充当局部源。从质量守恒和菲克定律出发，具有一阶降解和源的扩散过程的稳态满足\n$$-D \\frac{d^2 u}{dx^2} + \\lambda u = s(x), \\quad x \\in (0,1),$$\n其中齐次狄利克雷边界条件为\n$$u(0)=0, \\quad u(1)=0,$$\n其中 $D>0$ 是扩散系数，$\\lambda>0$ 是降解率，$s(x)$ 是由主体引起的源密度。将位于位置 $x_j$ 的每个主体建模为产生一个由高斯核近似的光滑、局部化的源。设每个主体的生产强度为 $q>0$，核宽度为 $\\sigma>0$，定义\n$$s(x) = \\sum_{j} q \\cdot \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right)。$$\n定义一个主体活动指示器为\n$$\\eta(x) = \\sum_{j} \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right),$$\n该指示器与 $s(x)$ 成正比，并度量独立于生产强度 $q$ 的局部主体活动。\n\n你需要实现由主体活动指示器 $\\eta(x)$ 引导的自适应网格加密（AMR），并用它来求解稳态偏微分方程（PDE）。在一个非均匀节点集 $\\{x_i\\}_{i=0}^{N-1}$ 上对 PDE 进行保守离散化，该节点集包括边界 $x_0=0$ 和 $x_{N-1}=1$，以及由 $i=1,\\dots,N-2$ 索引的内部节点。利用每个内部节点周围控制体积上的有限体积平衡和菲克定律，将节点 $i$ 处的二阶导数近似为\n$$\\left.\\frac{d^2 u}{dx^2}\\right|_{x_i} \\approx \\frac{\\displaystyle \\frac{u_{i+1}-u_i}{x_{i+1}-x_i} - \\frac{u_i - u_{i-1}}{x_i - x_{i-1}}}{\\displaystyle \\frac{(x_{i+1}-x_i) + (x_i - x_{i-1})}{2}},$$\n由此得到内部节点的线性系统\n$$\\left(\\frac{D}{\\delta_i}\\left(\\frac{1}{x_{i+1}-x_i} + \\frac{1}{x_i - x_{i-1}}\\right) + \\lambda\\right) u_i - \\frac{D}{\\delta_i}\\frac{u_{i-1}}{x_i - x_{i-1}} - \\frac{D}{\\delta_i}\\frac{u_{i+1}}{x_{i+1}-x_i} = s(x_i),$$\n其中 $\\delta_i = \\tfrac{1}{2}\\big((x_{i+1}-x_i)+(x_i-x_{i-1})\\big)$，并且由边界条件强制 $u_0=u_{N-1}=0$。\n\n通过从将 $[0,1]$ 剖分为 $M_0$ 个等大小单元的粗糙剖分开始，实现 AMR。迭代地二分任何其中点活动指示器超过阈值 $\\tau>0$ 的单元，即，如果一个中点为 $c=\\tfrac{a+b}{2}$ 的单元 $[a,b]$ 满足 $\\eta(c)>\\tau$，则将其标记。持续此过程，直到没有单元被标记或达到最大加密级别 $L_{\\max}$。将节点集 $\\{x_i\\}$ 构建为加密后所有单元端点的排序唯一集合。\n\n将协同仿真误差定义为 AMR 解与在 $[0,1]$ 上由 $N_{\\text{ref}}$ 个节点组成的精细均匀参考网格上计算的参考解之差的 $L^2$-范数。将 AMR 解线性插值到参考网格上，并计算\n$$\\|u_{\\text{AMR}} - u_{\\text{ref}}\\|_{L^2(0,1)} = \\left(\\int_0^1 \\left(u_{\\text{AMR}}(x) - u_{\\text{ref}}(x)\\right)^2 dx\\right)^{1/2},$$\n在参考网格上使用梯形法则进行数值近似。所有量均为无量纲。你的程序必须在 AMR 和参考计算中使用相同的 $D$、$\\lambda$、$q$ 和 $\\sigma$ 值。\n\n对所有测试使用以下固定参数值：\n- $D = 1.0$，\n- $\\lambda = 1.0$，\n- $q = 0.02$，\n- $\\sigma = 0.02$，\n- $M_0 = 32$，\n- $L_{\\max} = 6$，\n- $\\tau = 0.35$，\n- $N_{\\text{ref}} = 2049$。\n\n测试套件。对于以下每个主体位置集，计算如上定义的协同仿真误差：\n- 测试 $1$（主体分离）：$\\{x_j\\} = [0.2, 0.5, 0.8]$。\n- 测试 $2$（主体在内部聚集）：$\\{x_j\\} = [0.48, 0.5, 0.52]$。\n- 测试 $3$（主体在边界附近聚集）：$\\{x_j\\} = [0.02, 0.04, 0.06]$。\n\n最终输出格式。你的程序应生成单行输出，其中包含按上述测试顺序列出的三个协同仿真误差，格式为方括号内以逗号分隔的列表，每个数字格式化为四舍五入到六位小数的浮点值，例如 $[0.123456,0.234567,0.345678]$。", "solution": "我们从具有源的扩散和降解分子场的质量守恒开始。令 $u(x)$ 表示稳态浓度。在一个空间维度中，结合菲克扩散定律和一阶降解的质量平衡得出稳态偏微分方程（PDE）\n$$-D \\frac{d^2 u}{dx^2} + \\lambda u = s(x), \\quad x \\in (0,1),$$\n服从齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。这里 $D>0$ 是扩散系数，$\\lambda>0$ 是降解率。源项 $s(x)$ 源于产生场的主体。为了数值目的对狄拉克分布进行正则化，位置 $x_j$ 处的每个主体由宽度为 $\\sigma>0$、强度为 $q>0$ 的高斯函数表示，因此总源为\n$$s(x) = \\sum_{j} q \\cdot \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right)。$$\n为了引导自适应网格加密（AMR），主体活动指示器被定义为高斯函数的归一化和，\n$$\\eta(x) = \\sum_{j} \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right),$$\n它与 $s(x)$ 成正比且与 $q$ 无关。\n\n在非均匀网格上的离散化是根据第一性原理，通过在每个内部节点 $x_i$（其中 $i=1,\\dots,N-2$）周围的控制体积上应用有限体积平衡来构建的。设节点集为 $0=x_0 < x_1 < \\dots < x_{N-2} < x_{N-1}=1$，并定义间距 $\\Delta x_{i-1/2} = x_i - x_{i-1}$、$\\Delta x_{i+1/2} = x_{i+1} - x_i$ 以及平均半宽 $\\delta_i = \\tfrac{1}{2}(\\Delta x_{i-1/2} + \\Delta x_{i+1/2})$。菲克定律给出通量 $J = -D \\tfrac{du}{dx}$。将扩散项在控制体积上积分，并通过单边差分近似面梯度，得到保守离散拉普拉斯算子\n$$\\left.\\frac{d^2 u}{dx^2}\\right|_{x_i} \\approx \\frac{\\displaystyle \\frac{u_{i+1}-u_i}{\\Delta x_{i+1/2}} - \\frac{u_i - u_{i-1}}{\\Delta x_{i-1/2}}}{\\displaystyle \\delta_i}。$$\n将此代入 PDE，对每个内部节点可得，\n$$-D \\cdot \\frac{\\displaystyle \\frac{u_{i+1}-u_i}{\\Delta x_{i+1/2}} - \\frac{u_i - u_{i-1}}{\\Delta x_{i-1/2}}}{\\displaystyle \\delta_i} + \\lambda u_i = s(x_i)。$$\n整理后得到一个对称三对角线性系统\n$$a_{i-1} u_{i-1} + a_i u_i + a_{i+1} u_{i+1} = s(x_i),$$\n其系数为\n$$a_{i-1} = -\\frac{D}{\\delta_i} \\cdot \\frac{1}{\\Delta x_{i-1/2}}, \\quad a_{i+1} = -\\frac{D}{\\delta_i} \\cdot \\frac{1}{\\Delta x_{i+1/2}}, \\quad a_i = \\frac{D}{\\delta_i}\\left(\\frac{1}{\\Delta x_{i-1/2}} + \\frac{1}{\\Delta x_{i+1/2}}\\right) + \\lambda。$$\n边界条件 $u_0=0$ 和 $u_{N-1}=0$ 被直接强制执行，并消除了 $i=0$ 和 $i=N-1$ 处的未知数，因此求解该三对角系统以得到内部未知数 $u_1,\\dots,u_{N-2}$。\n\n自适应网格加密由活动指示器 $\\eta(x)$ 驱动。从加密级别为 0 的 $[0,1]$ 上的一个均匀剖分开始，该剖分包含 $M_0$ 个单元。对于级别为 $\\ell$、中点为 $c=\\tfrac{a+b}{2}$ 的单元 $[a,b]$，如果 $\\eta(c)>\\tau$ 且 $\\ell < L_{\\max}$，则将其标记为待加密。每个被标记的单元被二分为两个级别为 $\\ell+1$ 的子单元。迭代执行标记和二分过程，直到没有单元被标记或达到最大加密级别 $L_{\\max}$。用于离散化 PDE 的节点集 $\\{x_i\\}$ 是加密后所有单元端点的排序集合。这将加密区域与主体高活动区域对齐，在这些区域中 $s(x)$ 出现尖峰，而 $u(x)$ 倾向于表现出陡峭的梯度。\n\n协同仿真误差通过将 AMR 解与在 $[0,1]$ 上具有 $N_{\\text{ref}}$ 个节点的精细均匀网格上的参考解进行比较来计算。通过在均匀网格上应用相同的离散算子来计算参考解。将 AMR 解线性插值到参考网格上，得到在均匀节点 $x_k$ 处的 $u_{\\text{AMR}}(x_k)$。使用梯形法则近似 $L^2$ 误差范数，\n$$\\|u_{\\text{AMR}} - u_{\\text{ref}}\\|_{L^2(0,1)} \\approx \\left( \\int_0^1 \\left(u_{\\text{AMR}}(x) - u_{\\text{ref}}(x)\\right)^2 dx \\right)^{1/2} \\approx \\left( \\sum_{k=0}^{N_{\\text{ref}}-1} w_k \\left(u_{\\text{AMR}}(x_k) - u_{\\text{ref}}(x_k)\\right)^2 \\right)^{1/2},$$\n其中 $w_k$ 是梯形求积权重，满足 $w_0 = w_{N_{\\text{ref}}-1} = \\tfrac{\\Delta x}{2}$ 和 $w_k = \\Delta x$（对于 $1 \\le k \\le N_{\\text{ref}}-2$），并且 $\\Delta x = \\tfrac{1}{N_{\\text{ref}}-1}$。\n\n算法步骤：\n- 定义参数 $D$、$\\lambda$、$q$、$\\sigma$、$M_0$、$L_{\\max}$、$\\tau$ 和 $N_{\\text{ref}}$。\n- 对于每个测试用例的主体集 $\\{x_j\\}$：\n  - 通过使用阈值 $\\tau$ 进行迭代中点指示器标记来构建 AMR 网格，直到没有标记或达到最大级别 $L_{\\max}$。\n  - 从加密后的单元端点形成非均匀节点向量。\n  - 使用上述系数和在节点处求值的右侧项 $s(x_i)$，为 AMR 网格组装并求解三对角系统。\n  - 在具有 $N_{\\text{ref}}$ 个节点的均匀网格上，使用相同的 $D$、$\\lambda$、$q$ 和 $\\sigma$ 组装并求解参考系统。\n  - 将 AMR 解插值到均匀参考网格上，并通过梯形法则计算 $L^2$ 误差。\n- 以指定的列表格式输出三个误差。\n\n正确性论证：\n- 控制方程源自质量守恒和菲克定律，具有线性降解和光滑源，确保了对于 $D>0$ 和 $\\lambda>0$ 存在唯一解的适定、线性、自伴随椭圆边界值问题。\n- 由于 $D>0$、$\\lambda>0$ 和严格递增的节点，非均匀网格上的有限体积离散化是保守的，并产生一个对称正定三对角系统，从而确保了数值稳定性和离散解的唯一性。\n- AMR 策略针对 $\\eta(x)$ 较大的区域，这些区域与局部源和 $u(x)$ 中的陡峭梯度相吻合，从而将分辨率集中在最有利的地方。\n- 在精细均匀参考网格上计算的 $L^2$ 误差为 AMR 解和参考解之间的协同仿真差异提供了一致的、定量的度量。\n\n所有量均为无量纲，并且要求的三个测试是：\n- 测试 $1$：$\\{x_j\\} = [0.2, 0.5, 0.8]$，\n- 测试 $2$：$\\{x_j\\} = [0.48, 0.5, 0.52]$，\n- 测试 $3$：$\\{x_j\\} = [0.02, 0.04, 0.06]$。\n\n程序必须打印一行包含三个误差值的数据，格式为 $[e_1,e_2,e_3]$，每个值四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian_mixture(x, agents, q, sigma):\n    # Compute sum_j q * Gaussian(x - x_j; sigma)\n    # Gaussian normalization 1/(sigma*sqrt(2*pi))\n    x = np.asarray(x)\n    val = np.zeros_like(x, dtype=float)\n    norm = 1.0 / (sigma * np.sqrt(2.0 * np.pi))\n    for aj in agents:\n        val += q * norm * np.exp(-0.5 * ((x - aj) / sigma) ** 2)\n    return val\n\ndef activity_indicator(x, agents, sigma):\n    # Same as gaussian mixture but with q=1\n    x = np.asarray(x)\n    val = np.zeros_like(x, dtype=float)\n    norm = 1.0 / (sigma * np.sqrt(2.0 * np.pi))\n    for aj in agents:\n        val += norm * np.exp(-0.5 * ((x - aj) / sigma) ** 2)\n    return val\n\ndef build_amr_nodes(agents, sigma, tau, M0, Lmax, max_cells=8192):\n    # Cells represented as tuples (a, b, level)\n    cells = []\n    # initial uniform partition\n    edges = np.linspace(0.0, 1.0, M0 + 1)\n    for i in range(M0):\n        cells.append([edges[i], edges[i+1], 0])\n    # Refinement loop\n    changed = True\n    while changed:\n        changed = False\n        new_cells = []\n        for a, b, lev in cells:\n            c = 0.5 * (a + b)\n            eta_c = activity_indicator(np.array([c]), agents, sigma)[0]\n            if (eta_c > tau) and (lev < Lmax):\n                # bisect\n                mid = 0.5 * (a + b)\n                new_cells.append([a, mid, lev + 1])\n                new_cells.append([mid, b, lev + 1])\n                changed = True\n            else:\n                new_cells.append([a, b, lev])\n        cells = new_cells\n        if len(cells) > max_cells:\n            break\n        if not changed:\n            break\n    # Build nodes from cell endpoints\n    nodes = np.unique(np.array([c[0] for c in cells] + [cells[-1][1]]))\n    return nodes\n\ndef assemble_tridiagonal_nonuniform(nodes, D, lam, source_fn):\n    # nodes: array of length N, with boundaries at nodes[0]=0, nodes[-1]=1\n    N = len(nodes)\n    # interior indices: 1..N-2\n    n_int = N - 2\n    if n_int <= 0:\n        # trivial case, no interior unknowns\n        return np.zeros((0,)), np.zeros((0,)), np.zeros((0,)), np.zeros((0,))\n    xi = nodes\n    # compute spacings\n    dxm = xi[1:-1] - xi[0:-2]     # length n_int\n    dxp = xi[2:] - xi[1:-1]       # length n_int\n    denom = 0.5 * (dxm + dxp)     # length n_int\n\n    # Coefficients for interior points\n    aW = -D / denom / dxm\n    aE = -D / denom / dxp\n    aP = (D / denom) * (1.0/dxm + 1.0/dxp) + lam\n\n    # RHS s(x_i)\n    x_interior = xi[1:-1]\n    b = source_fn(x_interior).copy()\n\n    # Tridiagonal arrays\n    lower = aW[1:]          # sub-diagonal of length n_int-1\n    diag = aP.copy()        # main diagonal of length n_int\n    upper = aE[:-1]         # super-diagonal of length n_int-1\n\n    # Dirichlet boundaries are zero, so no modifications to b needed\n    return lower, diag, upper, b\n\ndef thomas_solve(lower, diag, upper, rhs):\n    # Solve tridiagonal system with Thomas algorithm\n    n = len(diag)\n    if n == 0:\n        return np.zeros((0,))\n    c = np.zeros(n-1, dtype=float)\n    d = np.zeros(n, dtype=float)\n    # forward elimination\n    c[0:1] = upper[0:1] / diag[0]\n    d[0] = rhs[0] / diag[0]\n    for i in range(1, n):\n        denom = diag[i] - lower[i-1] * c[i-1]\n        if i < n-1:\n            c[i] = upper[i] / denom\n        d[i] = (rhs[i] - lower[i-1] * d[i-1]) / denom\n    # back substitution\n    x = np.zeros(n, dtype=float)\n    x[-1] = d[-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d[i] - c[i] * x[i+1]\n    return x\n\ndef solve_nonuniform(nodes, D, lam, agents, q, sigma):\n    # Build source function\n    def sfun(x):\n        return gaussian_mixture(x, agents, q, sigma)\n    lower, diag, upper, b = assemble_tridiagonal_nonuniform(nodes, D, lam, sfun)\n    u_int = thomas_solve(lower, diag, upper, b)\n    # assemble full solution with Dirichlet boundaries zero\n    u_full = np.zeros_like(nodes)\n    if len(u_int) > 0:\n        u_full[1:-1] = u_int\n    return u_full\n\ndef l2_error_on_uniform_ref(u_ref, x_ref, x_amr, u_amr):\n    # Interpolate AMR solution to reference grid and compute L2 norm via trapezoidal rule\n    u_amr_interp = np.interp(x_ref, x_amr, u_amr)\n    diff2 = (u_amr_interp - u_ref) ** 2\n    err_sq = np.trapz(diff2, x_ref)\n    return np.sqrt(err_sq)\n\ndef solve_case(agents, params):\n    D = params[\"D\"]\n    lam = params[\"lam\"]\n    q = params[\"q\"]\n    sigma = params[\"sigma\"]\n    M0 = params[\"M0\"]\n    Lmax = params[\"Lmax\"]\n    tau = params[\"tau\"]\n    Nref = params[\"Nref\"]\n\n    # Reference grid and solution\n    x_ref = np.linspace(0.0, 1.0, Nref)\n    u_ref = solve_nonuniform(x_ref, D, lam, agents, q, sigma)\n\n    # AMR grid and solution\n    x_amr = build_amr_nodes(agents, sigma, tau, M0, Lmax, max_cells=8192)\n    u_amr = solve_nonuniform(x_amr, D, lam, agents, q, sigma)\n\n    # L2 error\n    err = l2_error_on_uniform_ref(u_ref, x_ref, x_amr, u_amr)\n    return err\n\ndef solve():\n    # Define parameters\n    params = {\n        \"D\": 1.0,\n        \"lam\": 1.0,\n        \"q\": 0.02,\n        \"sigma\": 0.02,\n        \"M0\": 32,\n        \"Lmax\": 6,\n        \"tau\": 0.35,\n        \"Nref\": 2049,\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [0.2, 0.5, 0.8],        # Test 1: separated agents\n        [0.48, 0.5, 0.52],      # Test 2: clustered interior\n        [0.02, 0.04, 0.06],     # Test 3: clustered near boundary\n    ]\n\n    results = []\n    for agents in test_cases:\n        err = solve_case(agents, params)\n        # Round to six decimal places for output formatting\n        results.append(f\"{err:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3330692"}]}