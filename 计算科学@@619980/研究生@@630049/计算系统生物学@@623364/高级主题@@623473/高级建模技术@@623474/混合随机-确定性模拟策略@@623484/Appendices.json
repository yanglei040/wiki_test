{"hands_on_practices": [{"introduction": "在我们深入研究复杂的混合模拟策略之前，通过一个基础练习来巩固基本原理至关重要。这个练习分析了一个简单的线性生灭过程，要求我们从化学主方程（CME）出发，精确推导其均值和方差的演化。通过将随机模型的均值与相应的确定性常微分方程（ODE）解进行比较 [@problem_id:3319363]，我们可以揭示两者之间的根本联系，并理解何时以及为何可以用确定性方法来近似随机系统的一部分。", "problem": "考虑一个固定体积内混合均匀的单物种系统，其中物种 $X$ 的分子由一个零级源产生，并通过一级衰变被移除。在作为连续时间马尔可夫跳跃过程的随机描述中，两个反应为 $X \\xrightarrow{k_b} X+1$（倾向为 $a_b(x) = k_b$）和 $X \\xrightarrow{k_d} \\emptyset$（倾向为 $a_d(x) = k_d x$），其中 $k_b > 0$ 和 $k_d > 0$ 是常数，$x$ 表示当前的分子数。假设初始条件 $X(0) = x_0$ 是一个已知的非负整数。\n\n从化学主方程框架和马尔可夫跳跃过程矩的生成元恒等式出发，推导前两个矩 $\\mathbb{E}[X(t)]$ 和 $\\mathbb{E}[X(t)^2]$ 的时间演化方程。求解这些方程，以获得在随机模拟算法（SSA）下 $\\mathbb{E}[X(t)]$ 和 $\\mathrm{Var}[X(t)]$ 的显式闭合形式表达式。然后，将 $\\mathbb{E}[X(t)]$ 与确定性常微分方程 $\\dot{c}(t) = k_b - k_d c(t)$（满足 $c(0) = x_0$）的解 $c(t)$进行比较。\n\n将您的最终答案表示为有序对 $\\left(\\mathbb{E}[X(t)], \\mathrm{Var}[X(t)]\\right)$，形式为单行矩阵。不需要四舍五入，最终表达式中不应包含单位。", "solution": "首先验证问题，以确保其科学上合理、适定且完整。\n\n**步骤1：提取已知条件**\n- 系统：固定体积内混合均匀的单物种系统。\n- 物种：$X$。\n- 状态变量：$x$，即 $X$ 的分子数。\n- 反应1（产生）：$X \\xrightarrow{k_b} X+1$，倾向为 $a_b(x) = k_b$。\n- 反应2（衰变）：$X \\xrightarrow{k_d} \\emptyset$，倾向为 $a_d(x) = k_d x$。\n- 常数：$k_b > 0$，$k_d > 0$。\n- 初始条件：$X(0) = x_0$，一个已知的非负整数。\n- 框架：化学主方程（CME）。\n- 任务：\n  1. 推导 $\\mathbb{E}[X(t)]$ 和 $\\mathbb{E}[X(t)^2]$ 的时间演化方程。\n  2. 求解 $\\mathbb{E}[X(t)]$ 和 $\\mathrm{Var}[X(t)]$ 的闭合形式表达式。\n  3. 将 $\\mathbb{E}[X(t)]$ 与确定性常微分方程 $\\dot{c}(t) = k_b - k_d c(t)$（$c(0)=x_0$）的解 $c(t)$ 进行比较。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题描述了一个线性生灭过程，这是随机化学动力学中一个基本且被充分理解的模型。这些反应和倾向是零级产生和一级衰变的标准化表示。符号 $X \\xrightarrow{k_b} X+1$ 及其倾向 $a_b(x) = k_b$ 明确定义了一个零级产生过程。所有参数和初始条件均已提供，使得问题自洽且适定。任务涉及在此框架内的标准数学推导。该问题具有科学依据，是客观的，并且没有违反任何无效性标准。\n\n**步骤3：结论与行动**\n问题被判定为有效。将提供完整解答。\n\n**矩方程的推导**\n\n对于连续时间马尔可夫跳跃过程，其状态的任意函数 $f(X(t))$ 的期望值的时间演化由生成元恒等式给出：\n$$\n\\frac{d}{dt}\\mathbb{E}[f(X(t))] = \\mathbb{E}[\\mathcal{L}f(X(t))]\n$$\n其中 $\\mathcal{L}$ 是该过程的生成元。对于化学反应网络，生成元作用于函数 $f(x)$ 的方式如下：\n$$\n\\mathcal{L}f(x) = \\sum_{j} a_j(x) [f(x+v_j) - f(x)]\n$$\n这里，$j$ 是反应的索引，$a_j(x)$ 是反应 $j$ 的倾向，$v_j$ 是由于反应 $j$ 引起的状态变量 $x$ 的变化。\n\n对于给定系统，我们有两个反应：\n1.  产生：$a_1(x) = k_b$，$v_1 = +1$。\n2.  消亡：$a_2(x) = k_d x$，$v_2 = -1$。\n\n因此，生成元为：\n$$\n\\mathcal{L}f(x) = k_b [f(x+1) - f(x)] + k_d x [f(x-1) - f(x)]\n$$\n\n**均值 $\\mathbb{E}[X(t)]$ 的时间演化**\n\n为了求一阶矩的方程，我们设 $f(x) = x$。\n$$\n\\mathcal{L}x = k_b [(x+1) - x] + k_d x [(x-1) - x] = k_b(1) + k_d x(-1) = k_b - k_d x\n$$\n应用生成元恒等式和期望算子的线性性：\n$$\n\\frac{d}{dt}\\mathbb{E}[X(t)] = \\mathbb{E}[\\mathcal{L}X(t)] = \\mathbb{E}[k_b - k_d X(t)] = k_b - k_d \\mathbb{E}[X(t)]\n$$\n令 $\\mu(t) = \\mathbb{E}[X(t)]$。我们得到一阶线性常微分方程（ODE）：\n$$\n\\frac{d\\mu(t)}{dt} = k_b - k_d \\mu(t)\n$$\n其初始条件为 $\\mu(0) = \\mathbb{E}[X(0)] = x_0$。\n\n**与确定性模型的比较**\n\n确定性速率方程为 $\\dot{c}(t) = k_b - k_d c(t)$，且 $c(0) = x_0$。这个 ODE 在数学上与随机过程均值 $\\mu(t)$ 的 ODE 完全相同。因此，它们的解也将是相同的：$\\mu(t) = c(t)$。该性质成立，因为所有反应倾向都是状态变量 $x$ 的线性函数。\n\n**求解均值 $\\mathbb{E}[X(t)]$**\n\n我们求解 ODE $\\frac{d\\mu}{dt} + k_d \\mu = k_b$。积分因子是 $I(t) = \\exp(\\int k_d dt) = \\exp(k_d t)$。\n$$\n\\frac{d}{dt} (\\mu(t) \\exp(k_d t)) = k_b \\exp(k_d t)\n$$\n对两边关于 $t$ 积分：\n$$\n\\mu(t) \\exp(k_d t) = \\int k_b \\exp(k_d t) dt = \\frac{k_b}{k_d} \\exp(k_d t) + C\n$$\n其中 $C$ 是积分常数。\n$$\n\\mu(t) = \\frac{k_b}{k_d} + C \\exp(-k_d t)\n$$\n使用初始条件 $\\mu(0) = x_0$：\n$$\nx_0 = \\frac{k_b}{k_d} + C \\implies C = x_0 - \\frac{k_b}{k_d}\n$$\n将 $C$ 代回解中，得到均值的显式表达式：\n$$\n\\mathbb{E}[X(t)] = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)\n$$\n\n**方差 $\\mathrm{Var}[X(t)]$ 的时间演化**\n\n方差定义为 $\\mathrm{Var}[X(t)] = \\mathbb{E}[X(t)^2] - (\\mathbb{E}[X(t)])^2$。一个比先求 $\\mathbb{E}[X(t)^2]$ 更直接的方法是直接推导方差本身的 ODE。令 $V(t) = \\mathrm{Var}[X(t)]$。\n$$\n\\frac{dV(t)}{dt} = \\frac{d}{dt}\\mathbb{E}[X(t)^2] - 2\\mathbb{E}[X(t)]\\frac{d}{dt}\\mathbb{E}[X(t)]\n$$\n首先，我们通过设 $f(x)=x^2$ 来求二阶矩 $m_2(t) = \\mathbb{E}[X(t)^2]$ 的 ODE。\n$$\n\\mathcal{L}x^2 = k_b [(x+1)^2 - x^2] + k_d x [(x-1)^2 - x^2]\n$$\n$$\n\\mathcal{L}x^2 = k_b (2x+1) + k_d x (-2x+1) = 2k_b x + k_b - 2k_d x^2 + k_d x = -2k_d x^2 + (2k_b + k_d)x + k_b\n$$\n取期望：\n$$\n\\frac{dm_2(t)}{dt} = \\mathbb{E}[\\mathcal{L}X(t)^2] = -2k_d \\mathbb{E}[X(t)^2] + (2k_b + k_d)\\mathbb{E}[X(t)] + k_b\n$$\n$$\n\\frac{dm_2(t)}{dt} = -2k_d m_2(t) + (2k_b + k_d)\\mu(t) + k_b\n$$\n现在将此结果和 $\\mu(t)$ 的 ODE 代入方差的导数中：\n$$\n\\frac{dV(t)}{dt} = [-2k_d m_2(t) + (2k_b + k_d)\\mu(t) + k_b] - 2\\mu(t)[k_b - k_d \\mu(t)]\n$$\n$$\n\\frac{dV(t)}{dt} = -2k_d m_2(t) + 2k_b\\mu(t) + k_d\\mu(t) + k_b - 2k_b\\mu(t) + 2k_d\\mu(t)^2\n$$\n$$\n\\frac{dV(t)}{dt} = -2k_d m_2(t) + 2k_d\\mu(t)^2 + k_d\\mu(t) + k_b\n$$\n$$\n\\frac{dV(t)}{dt} = -2k_d [m_2(t) - \\mu(t)^2] + k_d\\mu(t) + k_b\n$$\n这简化为方差的 ODE：\n$$\n\\frac{dV(t)}{dt} = -2k_d V(t) + k_d\\mu(t) + k_b\n$$\n初始条件是 $V(0) = \\mathrm{Var}[X(0)] = \\mathrm{Var}[x_0] = 0$，因为 $x_0$ 是一个确定值。\n\n**求解方差 $\\mathrm{Var}[X(t)]$**\n\n我们通过代入 $\\mu(t)$ 的表达式来求解 ODE $\\frac{dV}{dt} + 2k_d V = k_d\\mu(t) + k_b$：\n$$\n\\frac{dV}{dt} + 2k_d V = k_d\\left[\\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)\\right] + k_b\n$$\n$$\n\\frac{dV}{dt} + 2k_d V = k_b + (k_d x_0 - k_b)\\exp(-k_d t) + k_b = 2k_b + (k_d x_0 - k_b)\\exp(-k_d t)\n$$\n积分因子是 $I(t) = \\exp(\\int 2k_d dt) = \\exp(2k_d t)$。\n$$\n\\frac{d}{dt}(V(t)\\exp(2k_d t)) = 2k_b \\exp(2k_d t) + (k_d x_0 - k_b)\\exp(k_d t)\n$$\n关于 $t$ 积分：\n$$\nV(t)\\exp(2k_d t) = \\int [2k_b \\exp(2k_d t) + (k_d x_0 - k_b)\\exp(k_d t)] dt\n$$\n$$\nV(t)\\exp(2k_d t) = 2k_b \\frac{\\exp(2k_d t)}{2k_d} + (k_d x_0 - k_b) \\frac{\\exp(k_d t)}{k_d} + C'\n$$\n$$\nV(t)\\exp(2k_d t) = \\frac{k_b}{k_d}\\exp(2k_d t) + \\left(x_0 - \\frac{k_b}{k_d}\\right)\\exp(k_d t) + C'\n$$\n两边除以 $\\exp(2k_d t)$：\n$$\nV(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right)\\exp(-k_d t) + C'\\exp(-2k_d t)\n$$\n使用初始条件 $V(0)=0$：\n$$\n0 = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) + C' = x_0 + C' \\implies C' = -x_0\n$$\n代入 $C'$ 得到方差的最终表达式：\n$$\n\\mathrm{Var}[X(t)] = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right)\\exp(-k_d t) - x_0\\exp(-2k_d t)\n$$\n这个表达式可以被重排，以突出过程的内在随机性以及从初始状态弛豫的贡献：\n$$\n\\mathrm{Var}[X(t)] = \\frac{k_b}{k_d}(1-\\exp(-k_d t)) + x_0 \\exp(-k_d t)(1 - \\exp(-k_d t))\n$$\n提取公因式 $(1 - \\exp(-k_d t))$ 可以得到一个紧凑的形式：\n$$\n\\mathrm{Var}[X(t)] = \\left(\\frac{k_b}{k_d} + x_0 \\exp(-k_d t)\\right)\\left(1 - \\exp(-k_d t)\\right)\n$$\n\n**最终表达式**\n该过程的均值为：\n$$\n\\mathbb{E}[X(t)] = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)\n$$\n该过程的方差为：\n$$\n\\mathrm{Var}[X(t)] = \\left(\\frac{k_b}{k_d} + x_0 \\exp(-k_d t)\\right)\\left(1 - \\exp(-k_d t)\\right)\n$$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t) & \\left(\\frac{k_b}{k_d} + x_0 \\exp(-k_d t)\\right)\\left(1 - \\exp(-k_d t)\\right)\n\\end{pmatrix}\n}\n$$", "id": "3319363"}, {"introduction": "理论联系实际，下一个练习将指导我们为一个经典的生物系统——遗传拨动开关（genetic toggle switch）——设计并实现一个混合模拟器。这个系统的关键特性，即双稳态，源于启动子结合与解离事件的随机性，而信使RNA和蛋白质的数量则相对较大。这个实践练习 [@problem_id:3319361] 让我们亲身体验如何根据分子数量和过程速率对系统进行划分，将慢速、低分子数的事件进行随机处理，而将快速、高分子数的事件进行确定性处理，从而在保证模型关键行为的同时提高计算效率。", "problem": "您的任务是为计算系统生物学中的一个基准遗传触发开关网络设计并实现一种混合仿真算法，该算法结合使用随机和确定性方法，以在提高计算性能的同时保持双稳态。该网络由两个基因（表示为 $A$ 和 $B$）组成，它们通过与启动子位点结合来相互抑制对方的转录。\n\n物种如下：\n- 基因 $A$ 的启动子状态：$P_A^{\\mathrm{free}}$ 和 $P_A^{\\mathrm{bound}}$。\n- 基因 $B$ 的启动子状态：$P_B^{\\mathrm{free}}$ 和 $P_B^{\\mathrm{bound}}$。\n- 信使 RNA (mRNA)：$m_A$ 和 $m_B$（分子）。\n- 蛋白质：$A$ 和 $B$（分子）。\n\n反应（遵循质量作用定律）如下：\n- 启动子结合与解离（随机）：\n  - $B + P_A^{\\mathrm{free}} \\xrightarrow{k_{\\mathrm{on},A}} P_A^{\\mathrm{bound}}$，\n  - $P_A^{\\mathrm{bound}} \\xrightarrow{k_{\\mathrm{off},A}} B + P_A^{\\mathrm{free}}$，\n  - $A + P_B^{\\mathrm{free}} \\xrightarrow{k_{\\mathrm{on},B}} P_B^{\\mathrm{bound}}$，\n  - $P_B^{\\mathrm{bound}} \\xrightarrow{k_{\\mathrm{off},B}} A + P_B^{\\mathrm{free}}$。\n- 转录（确定性），取决于启动子占用情况：\n  - 若为 $P_A^{\\mathrm{free}}$，转录速率 $r_A = \\alpha_A$；若为 $P_A^{\\mathrm{bound}}$，转录速率 $r_A = \\ell_A$（泄漏）。\n  - 若为 $P_B^{\\mathrm{free}}$，转录速率 $r_B = \\alpha_B$；若为 $P_B^{\\mathrm{bound}}$，转录速率 $r_B = \\ell_B$（泄漏）。\n- 翻译与降解（确定性）：\n  - $m_A \\xrightarrow{\\beta_A} A$，\n  - $m_B \\xrightarrow{\\beta_B} B$，\n  - 降解 $m_A \\xrightarrow{\\delta_{m,A}} \\varnothing$，$m_B \\xrightarrow{\\delta_{m,B}} \\varnothing$，$A \\xrightarrow{\\delta_{p,A}} \\varnothing$，$B \\xrightarrow{\\delta_{p,B}} \\varnothing$。\n\n您必须对反应进行划分，使得启动子的结合与解离通过随机方法进行模拟，而转录、翻译和降解则通过确定性方法进行模拟。确定性部分应使用固定步长的显式方法进行积分，随机部分则应基于瞬时倾向性，使用非齐次泊松过程的离散时间近似进行模拟。具体来说，在每个大小为 $\\Delta t$ 的时间步长内：\n- 对于 $P_A$：\n  - 若为 $P_A^{\\mathrm{free}}$，结合倾向为 $a_{\\mathrm{bind},A}(t) = k_{\\mathrm{on},A} \\, B(t)$，在 $\\Delta t$ 内的结合概率为 $p_{\\mathrm{bind},A} = 1 - e^{-a_{\\mathrm{bind},A}(t)\\,\\Delta t}$。\n  - 若为 $P_A^{\\mathrm{bound}}$，解离倾向为 $a_{\\mathrm{unbind},A} = k_{\\mathrm{off},A}$，在 $\\Delta t$ 内的解离概率为 $p_{\\mathrm{unbind},A} = 1 - e^{-a_{\\mathrm{unbind},A}\\,\\Delta t}$。\n- 对于 $P_B$：\n  - 若为 $P_B^{\\mathrm{free}}$，结合倾向为 $a_{\\mathrm{bind},B}(t) = k_{\\mathrm{on},B} \\, A(t)$，概率为 $p_{\\mathrm{bind},B} = 1 - e^{-a_{\\mathrm{bind},B}(t)\\,\\Delta t}$。\n  - 若为 $P_B^{\\mathrm{bound}}$，解离倾向为 $a_{\\mathrm{unbind},B} = k_{\\mathrm{off},B}$，概率为 $p_{\\mathrm{unbind},B} = 1 - e^{-a_{\\mathrm{unbind},B}\\,\\Delta t}$。\n\n对于 $m_A$、$m_B$、$A$ 和 $B$ 的确定性更新必须使用显式欧拉积分：\n$$\nm_A(t+\\Delta t) = m_A(t) + \\Delta t \\left(r_A(t) - \\delta_{m,A} \\, m_A(t)\\right), \\quad\nA(t+\\Delta t) = A(t) + \\Delta t \\left(\\beta_A \\, m_A(t) - \\delta_{p,A} \\, A(t)\\right),\n$$\n$$\nm_B(t+\\Delta t) = m_B(t) + \\Delta t \\left(r_B(t) - \\delta_{m,B} \\, m_B(t)\\right), \\quad\nB(t+\\Delta t) = B(t) + \\Delta t \\left(\\beta_B \\, m_B(t) - \\delta_{p,B} \\, B(t)\\right).\n$$\n每次更新后，将 $m_A$、$m_B$、$A$ 和 $B$ 的值限制为非负。\n\n设计的科学依据与约束：\n- 该混合方案是一个分段确定性马尔可夫过程 (Piecewise Deterministic Markov Process, PDMP)，通过将化学主方程 (Chemical Master Equation, CME) 划分为用于离散启动子状态的随机子系统和在反应速率近似下用于大拷贝数物种的确定性子系统而导出。\n- 为保持双稳态，必须在启动子结合动力学中保留随机性，该动力学介导了由噪声驱动的吸引子状态之间的切换。\n- 对 $m_A$、$m_B$、$A$ 和 $B$ 进行确定性积分可以提高性能，并且当它们的拷贝数处于中到大水平时，这种做法是合理的。\n\n所有模拟的初始条件：\n- 在时间 $t=0$ 时，设置 $m_A(0) = 0$、$m_B(0) = 0$、$A(0) = 0$、$B(0) = 0$（均为分子数），以及 $P_A^{\\mathrm{free}}$、$P_B^{\\mathrm{free}}$。\n- 时间步长为 $\\Delta t = 1\\,\\mathrm{s}$。\n- 总模拟时长为 $T = 2000\\,\\mathrm{s}$。\n- 对每组参数，运行 $N = 100$ 次独立重复模拟，以形成最终蛋白质差异 $D = A(T) - B(T)$（以分子数记录）的经验分布。\n\n您的程序必须通过以下方式估计 $D$ 的经验分布中的模态数量：\n- 使用弗里德曼-迪亚科尼斯法则 (Freedman–Diaconis rule) 确定区间宽度来计算直方图，使用一个短的对称核平滑计数，并统计高于全局最大值一小部分的局部最大值的数量。\n\n设计以下参数集测试套件（所有速率单位为 $\\mathrm{s^{-1}}$，$k_{\\mathrm{on}}$ 值的单位为每分子每秒，因此 $k_{\\mathrm{on}} \\times$ 浓度 的单位为 $\\mathrm{s^{-1}}$）：\n1. 对称、双稳态基准（理想情况）：\n   - $\\alpha_A = \\alpha_B = 5$, $\\ell_A = \\ell_B = 0.02$, $\\beta_A = \\beta_B = 0.5$,\n   - $\\delta_{m,A} = \\delta_{m,B} = 0.1$, $\\delta_{p,A} = \\delta_{p,B} = 0.005$,\n   - $k_{\\mathrm{on},A} = k_{\\mathrm{on},B} = 2\\times 10^{-4}$, $k_{\\mathrm{off},A} = k_{\\mathrm{off},B} = 5\\times 10^{-4}$.\n   预期行为：由于启动子的互斥占用，在 $D$ 中出现两个分离良好的模态。\n2. 减弱的抑制（趋向单峰的边界条件）：\n   - $\\alpha_A = \\alpha_B = 5$, $\\ell_A = \\ell_B = 0.02$, $\\beta_A = \\beta_B = 0.5$,\n   - $\\delta_{m,A} = \\delta_{m,B} = 0.1$, $\\delta_{p,A} = \\delta_{p,B} = 0.005$,\n   - $k_{\\mathrm{on},A} = k_{\\mathrm{on},B} = 1\\times 10^{-4}$, $k_{\\mathrm{off},A} = k_{\\mathrm{off},B} = 2\\times 10^{-2}$.\n   预期行为：频繁的解离导致频繁的切换，并在 $D \\approx 0$ 附近形成一个单一的宽模态。\n3. 强抑制与持久性（具有高度稳定模态的边缘情况）：\n   - $\\alpha_A = \\alpha_B = 5$, $\\ell_A = \\ell_B = 0.02$, $\\beta_A = \\beta_B = 0.5$,\n   - $\\delta_{m,A} = \\delta_{m,B} = 0.1$, $\\delta_{p,A} = \\delta_{p,B} = 0.005$,\n   - $k_{\\mathrm{on},A} = k_{\\mathrm{on},B} = 4\\times 10^{-4}$, $k_{\\mathrm{off},A} = k_{\\mathrm{off},B} = 2\\times 10^{-4}$.\n   预期行为：两个模态具有更大的分离度和更长的驻留时间。\n\n单位：\n- 时间单位必须是 $\\mathrm{s}$。\n- 分子计数以分子为单位（无量纲计数）。\n\n最终输出规范：\n- 对于每组参数，计算在 $D$ 的经验分布中检测到的模态的整数数量。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。例如，如果三种情况分别有 $2$、$1$ 和 $2$ 个模态，则输出必须严格格式化为 $[2,1,2]$。", "solution": "该问题要求为遗传触发开关网络设计并实现一种混合随机-确定性仿真算法。该问题在科学上是合理的、适定的，并为构建唯一且有意义的解决方案提供了足够的细节。该模型是遗传触发开关的标准表示，而所提出的混合仿真策略，一种分段确定性马尔可夫过程 (Piecewise Deterministic Markov Process, PDMP)，是计算系统生物学中的一种既定方法。参数和初始条件已完全指定。模态计数过程中存在的轻微模糊性将通过做出下文详述的标准、明确的假设来解决。\n\n问题的核心是模拟一个系统，其中一些事件（启动子结合/解离）是稀有且根本上是随机的，驱动系统级状态切换（双稳态），而其他过程（转录、翻译、降解）涉及大量的分子，为了计算效率可以进行确定性近似。\n\n在任何时间 $t$，系统状态由元组 $(m_A(t), m_B(t), A(t), B(t), P_A(t), P_B(t))$ 描述，其中 $m_A, m_B, A, B$ 是 mRNA 和蛋白质的分子数，而 $P_A, P_B$ 表示启动子的离散状态（游离或结合）。我们将游离状态表示为 $0$，结合状态表示为 $1$。\n\n模拟以大小为 $\\Delta t = 1\\,\\mathrm{s}$ 的离散时间步长进行，总时长为 $T = 2000\\,\\mathrm{s}$。在从时间 $t$ 到 $t+\\Delta t$ 的每一步中，我们根据划分的动力学更新系统状态。\n\n首先，我们处理启动子状态 $P_A$ 和 $P_B$ 的随机更新。游离态和结合态之间的转换被建模为一个非齐次泊松过程，在离散时间间隔 $\\Delta t$ 上进行近似。状态改变的概率取决于系统的当前状态。\n\n- 对于启动子 $A$：\n  - 如果在时间 $t$ 是游离的 ($P_A(t)=0$)，它可以被一个蛋白质 $B$ 分子结合。该反应的倾向为 $a_{\\mathrm{bind},A}(t) = k_{\\mathrm{on},A} B(t)$。此事件在区间 $[t, t+\\Delta t]$ 内发生的概率为 $p_{\\mathrm{bind},A} = 1 - \\exp(-a_{\\mathrm{bind},A}(t)\\Delta t)$。\n  - 如果在时间 $t$ 是结合的 ($P_A(t)=1$)，它可以解离。该反应的倾向是恒定的：$a_{\\mathrm{unbind},A} = k_{\\mathrm{off},A}$。解离的概率为 $p_{\\mathrm{unbind},A} = 1 - \\exp(-a_{\\mathrm{unbind},A}\\Delta t)$。\n- 一套对称的规则适用于启动子 $B$，其状态转换取决于蛋白质 $A$ 的浓度。\n\n其次，我们使用显式欧拉方法对连续值物种（mRNA 和蛋白质分子数）进行确定性更新。问题指定，用于欧拉步骤的速率 $r_A(t)$ 和 $r_B(t)$ 由区间开始时（即时间 $t$）的启动子状态决定。\n\n- 转录速率为：\n  - 如果 $P_A(t)=0$（游离），$r_A(t) = \\alpha_A$；如果 $P_A(t)=1$（结合），$r_A(t) = \\ell_A$。\n  - 如果 $P_B(t)=0$（游离），$r_B(t) = \\alpha_B$；如果 $P_B(t)=1$（结合），$r_B(t) = \\ell_B$。\n- 经欧拉离散化的常微分方程为：\n$$\nm_A(t+\\Delta t) = m_A(t) + \\Delta t \\left(r_A(t) - \\delta_{m,A} \\, m_A(t)\\right)\n$$\n$$\nA(t+\\Delta t) = A(t) + \\Delta t \\left(\\beta_A \\, m_A(t) - \\delta_{p,A} \\, A(t)\\right)\n$$\n$m_B$ 和 $B$ 也类似。每次更新后，分子数被限制为非负，以确保物理真实性。\n\n单次模拟轨迹的总体算法如下：\n1. 在 $t=0$ 时初始化状态：$m_A(0)=0$, $m_B(0)=0$, $A(0)=0$, $B(0)=0$，以及启动子 $P_A(0)=0, P_B(0)=0$（游离）。\n2. 对于从 $0$ 到 $(T/\\Delta t) - 1$ 的每个时间步 $i$，其中 $t_i = i \\Delta t$：\n    a. 根据 $P_A(t_i)$ 和 $P_B(t_i)$ 确定转录速率 $r_A(t_i)$ 和 $r_B(t_i)$。\n    b. 使用显式欧拉公式和 $t_i$ 时的值计算新的分子数 $m_A(t_{i+1}), A(t_{i+1}), m_B(t_{i+1}), B(t_{i+1})$。强制非负性。\n    c. 根据 $t_i$ 时的状态计算启动子的跃迁概率。\n    d. 为每个启动子生成一个随机数，以决定其状态是否翻转，从而确定 $P_A(t_{i+1})$ 和 $P_B(t_{i+1})$。\n3. 循环完成后，记录最终的蛋白质差异 $D = A(T) - B(T)$。\n\n对于三组参数集中的每一组，此过程重复 $N=100$ 次，从而为每种情况生成 $D$ 的经验分布。\n\n最后，我们分析这个分布以计算其模态数量。问题概述了一个程序，我们将其完整地规定如下：\n1.  **分箱 (Binning)**：计算 $N=100$ 个 $D$ 值的直方图。箱宽 $h$ 由弗里德曼-迪亚科尼斯法则 (Freedman-Diaconis rule) 确定：$h = 2 \\frac{\\mathrm{IQR}(D)}{N^{1/3}}$，其中 $\\mathrm{IQR}$ 是数据的四分位距。\n2.  **平滑 (Smoothing)**：为减少噪声，对直方图计数进行平滑处理。我们将使用一个 3 点对称三角核 $[0.25, 0.5, 0.25]$ 通过卷积来应用。\n3.  **峰值检测 (Peak Detection)**：识别平滑后直方图中的局部最大值。如果一个点的值严格大于其两个直接邻居，则该点是局部最大值。\n4.  **阈值处理 (Thresholding)**：为滤除微小波动，只计算高度大于平滑后直方图中全局最大高度 $10\\%$ 的局部最大值。这个阈值是区分重要模态与噪声的合理选择。\n\n最终输出是为三组参数集中的每一组检测到的模态数量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the hybrid simulation for the three test cases\n    and print the detected number of modes for each.\n    \"\"\"\n\n    # Define the three test cases as dictionaries of parameters.\n    # Base parameters common to all cases\n    base_params = {\n        'alpha_A': 5.0, 'alpha_B': 5.0, 'ell_A': 0.02, 'ell_B': 0.02,\n        'beta_A': 0.5, 'beta_B': 0.5, 'delta_m_A': 0.1, 'delta_m_B': 0.1,\n        'delta_p_A': 0.005, 'delta_p_B': 0.005,\n    }\n\n    test_cases = [\n        # Case 1: Symmetric, bistable benchmark\n        {**base_params, 'k_on_A': 2e-4, 'k_on_B': 2e-4, 'k_off_A': 5e-4, 'k_off_B': 5e-4},\n        # Case 2: Weakened repression (unimodal)\n        {**base_params, 'k_on_A': 1e-4, 'k_on_B': 1e-4, 'k_off_A': 2e-2, 'k_off_B': 2e-2},\n        # Case 3: Strong repression (highly stable modes)\n        {**base_params, 'k_on_A': 4e-4, 'k_on_B': 4e-4, 'k_off_A': 2e-4, 'k_off_B': 2e-4},\n    ]\n\n    # Simulation constants\n    T = 2000.0\n    DT = 1.0\n    N_REPLICATES = 100\n    \n    # Mode counting parameters\n    MODE_THRESHOLD_FRACTION = 0.1\n    SMOOTHING_KERNEL = np.array([0.25, 0.5, 0.25])\n\n    rng = np.random.default_rng(seed=42) # for reproducible results\n\n    results = []\n    for params in test_cases:\n        final_diffs = []\n        for _ in range(N_REPLICATES):\n            d = run_simulation(params, T, DT, rng)\n            final_diffs.append(d)\n        \n        n_modes = count_modes(\n            np.array(final_diffs), \n            SMOOTHING_KERNEL, \n            MODE_THRESHOLD_FRACTION\n        )\n        results.append(n_modes)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(params, T, dt, rng):\n    \"\"\"\n    Runs a single trajectory of the hybrid simulation.\n    \n    Args:\n        params (dict): Dictionary of model parameters.\n        T (float): Total simulation time.\n        dt (float): Time step.\n        rng (np.random.Generator): Random number generator instance.\n\n    Returns:\n        float: The final difference D = A(T) - B(T).\n    \"\"\"\n    # Initial conditions\n    m_a, m_b = 0.0, 0.0\n    prot_a, prot_b = 0.0, 0.0\n    p_a_free, p_b_free = 1, 1 # 1 for free, 0 for bound\n\n    num_steps = int(T / dt)\n\n    for _ in range(num_steps):\n        # Store current state for calculations within this time step\n        m_a_t, m_b_t = m_a, m_b\n        prot_a_t, prot_b_t = prot_a, prot_b\n        p_a_free_t, p_b_free_t = p_a_free, p_b_free\n\n        # --- Stochastic update of promoter states ---\n        # Based on state at time t\n        \n        # Promoter A\n        if p_a_free_t == 1: # free -> bound?\n            propensity = params['k_on_A'] * prot_b_t\n            prob_bind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_bind:\n                p_a_free = 0\n        else: # bound -> free?\n            propensity = params['k_off_A']\n            prob_unbind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_unbind:\n                p_a_free = 1\n        \n        # Promoter B\n        if p_b_free_t == 1: # free -> bound?\n            propensity = params['k_on_B'] * prot_a_t\n            prob_bind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_bind:\n                p_b_free = 0\n        else: # bound -> free? \n            propensity = params['k_off_B']\n            prob_unbind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_unbind:\n                p_b_free = 1\n\n        # --- Deterministic update of mRNA and proteins ---\n        # Based on state at time t\n        r_a = params['alpha_A'] if p_a_free_t == 1 else params['ell_A']\n        r_b = params['alpha_B'] if p_b_free_t == 1 else params['ell_B']\n\n        # Update mRNA\n        m_a = m_a_t + dt * (r_a - params['delta_m_A'] * m_a_t)\n        m_b = m_b_t + dt * (r_b - params['delta_m_B'] * m_b_t)\n        \n        # Update proteins\n        prot_a = prot_a_t + dt * (params['beta_A'] * m_a_t - params['delta_p_A'] * prot_a_t)\n        prot_b = prot_b_t + dt * (params['beta_B'] * m_b_t - params['delta_p_B'] * prot_b_t)\n\n        # Clamp to non-negative\n        m_a = max(0.0, m_a)\n        m_b = max(0.0, m_b)\n        prot_a = max(0.0, prot_a)\n        prot_b = max(0.0, prot_b)\n        \n    return prot_a - prot_b\n\n\ndef count_modes(data, kernel, threshold_frac):\n    \"\"\"\n    Counts the number of modes in a 1D data array using a histogram-based method.\n    \n    Args:\n        data (np.ndarray): Array of data points.\n        kernel (np.ndarray): Smoothing kernel.\n        threshold_frac (float): Fraction of the global max for peak thresholding.\n\n    Returns:\n        int: The number of detected modes.\n    \"\"\"\n    if len(data)  3:\n        return 1\n        \n    # 1. Binning using Freedman-Diaconis rule\n    try:\n        counts, bin_edges = np.histogram(data, bins='fd')\n    except ValueError:\n        # Fallback if 'fd' fails (e.g., zero variance)\n        counts, bin_edges = np.histogram(data, bins=10)\n\n    if len(counts)  3:\n      # Not enough bins to find local maxima with a 3-point kernel\n      return 1 if len(counts) > 0 else 0\n\n    # 2. Smoothing\n    smoothed_counts = np.convolve(counts, kernel, mode='same')\n    \n    # 3. Peak Finding  4. Thresholding\n    global_max = np.max(smoothed_counts)\n    if global_max == 0:\n        return 0\n        \n    threshold = threshold_frac * global_max\n    \n    modes = 0\n    # Iterate from the second to the second-to-last bin to check for local maxima\n    for i in range(1, len(smoothed_counts) - 1):\n        is_local_max = smoothed_counts[i] > smoothed_counts[i-1] and \\\n                       smoothed_counts[i] > smoothed_counts[i+1]\n        \n        if is_local_max and smoothed_counts[i] > threshold:\n            modes += 1\n            \n    # Handle edge case where a single peak might exist at the edge\n    # or the data is monotonic, producing no peaks in the center.\n    if modes == 0 and np.any(smoothed_counts > 0):\n        return 1\n        \n    return modes\n\nsolve()\n```", "id": "3319361"}, {"introduction": "任何近似方法都不可避免地会引入误差，因此，对混合模拟器的准确性进行验证是至关重要的一步。本练习旨在建立一个严格的框架来量化混合模拟器与精确解析解之间的差异。我们将为一个其稳态解已知的线性系统实施一个基于阈值的混合算法，然后使用总变差距离（total variation distance）来比较经验分布和理论分布 [@problem_id:3319370]。通过构建置信区间并应用接受准则，我们学会了如何有原则地判断一个混合模型的有效性，这在模型开发和验证中是一项核心技能。", "problem": "设计并实现一个程序，用于量化一个混合随机-确定性模拟器与一个线性生灭网络的解析化学主方程（CME）稳态解之间的差异，然后根据一个有原则的标准来判断该混合模拟器是否可接受。所研究的网络是单物种迁移-死亡过程，其反应为 $\\varnothing \\to X$（速率为 $k_{0}$）和 $X \\to \\varnothing$（速率为 $k_{1} \\, X$）。混合模拟策略定义如下：当副本数 $x$ 满足 $x \\le H$ 时，使用随机模拟算法（SSA）进行模拟；当 $x  H$ 时，通过常微分方程 $\\mathrm{d}x/\\mathrm{d}t = k_{0} - k_{1} x$ 进行确定性模拟，并在跨越阈值时切换模式。在确定性模式下，使用精确的解析流来将 $x(t)$ 随时间向前推进，并在流向下穿过 $H$ 时允许切换回随机模式。假设体积混合均匀，分子计数无单位；时间单位为秒。\n\n从该线性网络的 CME 和稳态的基本定义出发，推导适用于比较的解析平稳分布。定义并实现一个估计量，用于计算解析稳态分布 $p$ 与通过运行混合模拟器多次独立重复实验获得的经验分布 $\\hat{q}$ 之间的全变差距离。每次重复实验都从 $x(0) = 0$ 开始，运行至时间 $T_{\\mathrm{final}}$。为使估计量在数值上易于处理，将状态空间截断为 $\\{0,1,\\dots,K\\}$，并将所有超出 $K$ 的概率质量聚合到一个尾部区间中。对于一个选定的非负整数 $K$，全变差估计量为\n$$\n\\widehat{\\mathrm{TV}} \\;=\\; \\tfrac{1}{2} \\left( \\sum_{k=0}^{K} \\left| p(k) - \\hat{q}(k) \\right| \\;+\\; \\left| 1 - \\sum_{k=0}^{K} p(k) \\;-\\; \\sum_{k=0}^{K} \\hat{q}(k) \\right| \\right).\n$$\n自适应地选择 $K$，即 $K = \\lceil \\lambda + L \\sqrt{\\lambda} \\rceil$，其中 $\\lambda$ 是解析稳态均值，$L$ 是一个正常数，并包含一个聚合的尾部区间，因此总区间数为 $B = K + 2$。利用多项式频率的测度集中和对 $B$ 个区间的联合界，推导出有限样本边际 $\\Delta$，使得在置信度至少为 $1 - \\alpha$ 的情况下，未知的真实全变差距离 $\\mathrm{TV}(p,\\hat{q})$ 最多为 $\\widehat{\\mathrm{TV}} + \\Delta$，其中\n$$\n\\Delta \\;=\\; \\tfrac{1}{2} \\, B \\, \\varepsilon, \n\\qquad\n\\varepsilon \\;=\\; \\sqrt{ \\dfrac{\\ln \\left( \\dfrac{2B}{\\alpha} \\right)}{2 n} },\n$$\n且 $n$ 是独立重复实验的次数。制定一个接受决策规则：如果 $\\widehat{\\mathrm{TV}} + \\Delta \\le \\tau$，则接受该混合模拟器，其中 $\\tau$ 是用户指定的容差。\n\n您的任务是实现一个完整的程序，该程序：\n- 对下面的测试套件中的每个参数集，使用指定的 $n$ 次独立重复实验、时间范围 $T_{\\mathrm{final}}$、阈值 $H$ 和支持乘数 $L$ 来模拟混合过程。\n- 从第一性原理出发，计算该线性网络的解析 CME 稳态分布及其均值 $\\lambda$。\n- 在 $\\{0,\\dots,K\\}$ 加上一个尾部区间上，构建如上定义的截断全变差估计量 $\\widehat{\\mathrm{TV}}$。\n- 使用上述有限样本界、置信水平 $\\alpha$ 和总区间数 $B = K + 2$ 计算边际 $\\Delta$。\n- 根据规则 $\\widehat{\\mathrm{TV}} + \\Delta \\le \\tau$，将每个测试用例的接受决策作为布尔值返回。\n\n混合模拟器必须精确实现以下模式切换：\n- 如果 $x \\le H$，使用随机模拟算法，总风险率 $a_{0}(x) = k_{0} + k_{1} x$，指数等待时间的均值为 $1/a_{0}(x)$，并以概率 $k_{0}/a_{0}(x)$ 进行跳跃 $x \\mapsto x + 1$，或以概率 $k_{1} x / a_{0}(x)$ 进行跳跃 $x \\mapsto \\max\\{0,x-1\\}$。\n- 如果 $x  H$，使用精确流 $x(t+\\Delta t) = \\lambda + \\left( x(t) - \\lambda \\right) e^{-k_{1} \\Delta t}$ 进行确定性传播。当 $\\lambda  H$ 时，计算从上方到达 $H$ 的精确时间，即第一个使得 $x(t+\\Delta t) = H$ 的 $\\Delta t$，然后在该时间切换到 SSA；如果 $\\lambda \\ge H$，则在确定性模式下保持运行直到 $T_{\\mathrm{final}}$。\n- 在 $T_{\\mathrm{final}}$ 时，将连续的 $x$ 四舍五入到最近的非负整数，以生成用于经验分布的样本。\n\n测试套件和要求输出：\n- 使用以下四个测试用例，每个用例由 $(k_{0}, k_{1}, H, T_{\\mathrm{final}}, n, L, \\tau, \\alpha)$ 指定：\n    - 用例 1: $(5.0, 1.0, 100, 50.0, 600, 8.0, 0.05, 0.01)$。\n    - 用例 2: $(40.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01)$。\n    - 用例 3: $(1.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01)$。\n    - 用例 4: $(5.0, 0.2, 10, 50.0, 600, 8.0, 0.05, 0.01)$。\n- 对于每个用例，计算并存储一个布尔值，指示在置信水平 $1 - \\alpha$ 下是否满足接受准则。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表，顺序与上述用例一致（例如，“[True,False,True,False]”）。不应打印任何其他文本。\n\n假设和约束：\n- 所有随机抽样在各重复实验之间必须是独立的。\n- 为保证可复现性，使用固定的随机种子。\n- 不涉及角度；不需要角度单位。\n- 除了已声明的时间单位秒之外，不需要进行物理单位转换。", "solution": "该问题要求设计并实现一个计算流程，用于对照一个基本生化反应网络的精确解析解，来验证一个混合随机-确定性模拟器。验证过程通过量化模拟器输出与解析已知的稳态分布之间的统计差异，并应用一个有原则的接受决策规则来执行。该流程包括三个主要部分：推导解析解、实现指定的混合模拟算法，以及执行严谨的统计比较。\n\n### 1. 解析稳态解\n\n该系统是一个单物种迁移-死亡过程，由以下反应描述：\n$$\n\\varnothing \\xrightarrow{k_0} X \\\\\nX \\xrightarrow{k_1} \\varnothing\n$$\n系统的状态是物种 $X$ 的分子数，用非负整数 $x$ 表示。第一个反应是迁移（或生成）过程，以恒定速率 $k_0$ 发生。第二个是降解（或死亡）过程，以速率 $k_1 x$ 发生，该速率与当前分子数成正比。\n\n状态概率分布 $p(k, t) = \\mathrm{Prob}(X(t)=k)$ 的演化由化学主方程（CME）控制。在稳态下，流入任何状态 $k$ 的净概率流为零，即 $\\mathrm{d}p(k, t)/\\mathrm{d}t = 0$。这导出了平衡方程，该方程将流入状态 $k$ 的概率速率与流出状态 $k$ 的速率等同起来：\n$$\n\\text{流入速率} = \\text{流出速率}\n$$\n对于一个一般状态 $k  0$，系统可以从状态 $k-1$（通过生成）或状态 $k+1$（通过死亡）进入。它可以通过生成（到状态 $k+1$）或死亡（到状态 $k-1$）离开。状态 $k$ 的稳态平衡方程是：\n$$\nk_0 \\, p(k-1) + k_1 (k+1) \\, p(k+1) = (k_0 + k_1 k) \\, p(k)\n$$\n对于边界状态 $k=0$，方程为：\n$$\nk_1 (1) \\, p(1) = k_0 \\, p(0)\n$$\n这给出 $p(1) = (k_0/k_1) p(0)$。让我们定义参数 $\\lambda = k_0/k_1$。那么 $p(1) = \\lambda p(0)$。我们可以递归地求解一般平衡方程。对于 $k=1$：\n$$\nk_0 p(0) + k_1 (2) p(2) = (k_0 + k_1) p(1)\n$$\n代入 $p(1) = (k_0/k_1) p(0)$：\n$$\nk_0 p(0) + 2k_1 p(2) = (k_0 + k_1) (k_0/k_1) p(0) = (k_0^2/k_1 + k_0) p(0)\n$$\n$$\n2k_1 p(2) = (k_0^2/k_1) p(0) \\implies p(2) = \\frac{k_0^2}{2 k_1^2} p(0) = \\frac{\\lambda^2}{2} p(0)\n$$\n通过归纳法，可以证明通解为：\n$$\np(k) = \\frac{\\lambda^k}{k!} p(0)\n$$\n为了找到 $p(0)$，我们使用归一化条件 $\\sum_{k=0}^{\\infty} p(k) = 1$：\n$$\n\\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} p(0) = p(0) \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} = p(0) e^{\\lambda} = 1\n$$\n这意味着 $p(0) = e^{-\\lambda}$。因此，解析稳态分布是一个均值为 $\\lambda$ 的泊松分布：\n$$\np(k) = \\frac{e^{-\\lambda} \\lambda^k}{k!} \\quad \\text{其中} \\quad \\lambda = \\frac{k_0}{k_1}\n$$\n\n### 2. 混合模拟算法\n\n该模拟器结合了精确的随机模拟算法（SSA）和基于系统速率方程的确定性近似。模式之间的切换由一个阈值副本数 $H$ 控制。\n\n-   **随机模式 ($x \\le H$)：** 当副本数 $x$ 小于或等于阈值 $H$ 时，模拟使用 Gillespie 直接法（一种 SSA 形式）进行。\n    1.  所有可能反应的总倾向（风险率）为 $a_0(x) = k_0 + k_1 x$。\n    2.  从均值为 $1/a_0(x)$ 的指数分布中抽取下一次反应的等待时间 $\\Delta t$。\n    3.  时间推进 $\\Delta t$。如果新时间超过最终时间 $T_{\\mathrm{final}}$，则该次重复实验的模拟终止。\n    4.  根据其相对倾向选择一个反应。抽取一个均匀随机数 $u \\in [0,1)$。如果 $u  k_0/a_0(x)$，发生一次生成 ($x \\to x+1$)；否则，发生一次死亡 ($x \\to x-1$)。\n    5.  更新整数副本数 $x$，并重复此逻辑。\n\n-   **确定性模式 ($x  H$)：** 当一个反应导致副本数 $x$ 超过 $H$ 时，模拟切换到确定性模型。平均副本数的演化由常微分方程（ODE）$\\mathrm{d}x/\\mathrm{d}t = k_0 - k_1 x$ 描述。\n    1.  该线性 ODE 的解析解，从切换时间 $t_s$ 的 $x(t_s)$ 开始，是 $x(t) = \\lambda + (x(t_s) - \\lambda)e^{-k_1(t-t_s)}$，其中 $\\lambda = k_0/k_1$ 是确定性不动点。\n    2.  轨迹的行为取决于不动点 $\\lambda$ 和阈值 $H$ 之间的关系：\n        -   如果 $\\lambda \\ge H$，任何从 $x  H$ 开始的轨迹将从下方或上方接近 $\\lambda$，但永远不会再次穿越到 $H$ 以下。模拟可以直接快进到 $T_{\\mathrm{final}}$。最终状态是 $x(T_{\\mathrm{final}}) = \\lambda + (x(t_s) - \\lambda)e^{-k_1(T_{\\mathrm{final}}-t_s)}$。\n        -   如果 $\\lambda  H$，从 $x  H$ 开始的轨迹将向 $\\lambda$ 衰减，并将穿越 $H$。我们计算到达 $H$ 的精确时间 $\\Delta t_H$：\n            $$\n            H = \\lambda + (x(t_s) - \\lambda)e^{-k_1 \\Delta t_H} \\implies \\Delta t_H = \\frac{1}{k_1} \\ln \\left( \\frac{x(t_s) - \\lambda}{H - \\lambda} \\right)\n            $$\n            如果 $t_s + \\Delta t_H \\ge T_{\\mathrm{final}}$，模拟在到达 $H$ 之前或之时结束。最终状态在 $T_{\\mathrm{final}}$ 时刻使用 ODE 解计算。否则，时间推进到 $t_s + \\Delta t_H$，状态设置为整数 $x=H$，模拟切换回随机模式。\n\n-   **最终样本生成：** $n$ 次独立重复实验中的每一次都从 $x(0)=0$ 开始，运行到 $t=T_{\\mathrm{final}}$。如果一次重复实验在确定性模式下结束，其最终连续状态 $x(T_{\\mathrm{final}})$ 将被四舍五入到最近的非负整数。这 $n$ 个整数值构成了经验分布的样本。\n\n### 3. 统计差异框架\n\n为了比较来自模拟器的经验分布 $\\hat{q}$ 和解析泊松分布 $p$，我们使用截断状态空间上的全变差（TV）距离。\n\n-   **状态空间截断：** 为便于实际计算，无限状态空间 $\\{0, 1, 2, \\dots \\}$ 被截断为 $B$ 个有限区间的集合。这些区间是 $\\{0\\}, \\{1\\}, \\dots, \\{K\\}$，外加一个用于所有大于 $K$ 的状态的聚合尾部区间。截断点 $K$ 是自适应选择的，以覆盖解析分布的大部分质量：$K = \\lceil \\lambda + L \\sqrt{\\lambda} \\rceil$，其中 $L$ 是给定的乘数。总区间数为 $B = K + 2$。\n\n-   **全变差估计量 ($\\widehat{\\mathrm{TV}}$)：** 经验分布 $\\hat{q}$ 是通过计算落入 $B$ 个区间中每个区间的 $n$ 个样本的比例形成的。TV 距离的估计量是分箱后概率向量之间 $L_1$ 距离的一半：\n    $$\n    \\widehat{\\mathrm{TV}} = \\frac{1}{2} \\sum_{i=1}^{B} |\\hat{q}_i - p_i|\n    $$\n    其中 $p_i$ 和 $\\hat{q}_i$ 分别是解析分布和经验分布下第 $i$ 个区间的概率。这与问题陈述中提供的公式完全对应。\n\n-   **有限样本置信界：** 估计量 $\\widehat{\\mathrm{TV}}$ 是从有限数量的样本 $n$ 计算出来的，它本身是一个随机变量。为了做出稳健的决策，我们必须考虑这种抽样误差。我们为解析分布 $p$ 和混合模拟器的真实潜在分布（我们称之为 $q_{true}$）之间的真实（未知）TV 距离构建一个单边置信区间。在置信度至少为 $1-\\alpha$ 的情况下，该距离受 $\\mathrm{TV}(p, q_{true}) \\le \\widehat{\\mathrm{TV}} + \\Delta$ 的限制。误差边际 $\\Delta$ 考虑了 $\\hat{q}$ 中的统计不确定性。它是利用针对多项式频率的 Hoeffding 不等式与对 $B$ 个区间的联合界相结合推导出来的。这得出：\n    $$\n    \\Delta = \\frac{1}{2} B \\varepsilon, \\quad \\text{其中} \\quad \\varepsilon = \\sqrt{ \\frac{\\ln (2B/\\alpha)}{2n} }\n    $$\n\n### 4. 接受准则\n\n如果混合模拟器与解析解的最坏情况差异在可容忍的小范围内，则认为它是真实随机过程的一个可接受的近似。决策规则是：\n$$\n\\text{如果 } \\widehat{\\mathrm{TV}} + \\Delta \\le \\tau \\text{ 则接受}\n$$\n这意味着我们仅当真实 TV 距离的 $(1-\\alpha)$-置信区间的上界不超过用户指定的容差 $\\tau$ 时，才接受该模拟器。这为验证数值方法提供了统计上合理的依据。最终的实现将对每个测试用例执行这整个过程，并返回一个布尔决策。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # A fixed random seed is used for reproducibility as per the problem statement.\n    # The problem asks for independent replicates, but a global seed ensures the\n    # entire test suite is reproducible. The RNG is passed down.\n    rng = np.random.default_rng(seed=42)\n\n    # Test suite: (k0, k1, H, T_final, n, L, tau, alpha)\n    test_cases = [\n        (5.0, 1.0, 100, 50.0, 600, 8.0, 0.05, 0.01),\n        (40.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01),\n        (1.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01),\n        (5.0, 0.2, 10, 50.0, 600, 8.0, 0.05, 0.01),\n    ]\n\n    results = [_run_validation_case(rng, *case) for case in test_cases]\n\n    # Format the output as specified: a single line \"[bool,bool,...]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _run_validation_case(rng, k0, k1, H, T_final, n, L, tau, alpha):\n    \"\"\"\n    Runs the full validation procedure for a single parameter set.\n    \"\"\"\n    # 1. Generate n samples from the hybrid simulator.\n    samples = [_simulate_replicate(rng, k0, k1, H, T_final) for _ in range(n)]\n    \n    # 2. Perform statistical analysis and make an acceptance decision.\n    return _analyze_discrepancy(samples, k0, k1, n, L, tau, alpha)\n\ndef _simulate_replicate(rng, k0, k1, H, T_final):\n    \"\"\"\n    Simulates a single trajectory of the hybrid process from t=0 to t=T_final.\n    \"\"\"\n    t = 0.0\n    x = 0  # State is an integer copy number.\n\n    while t  T_final:\n        if x = H:\n            # Stochastic Simulation Algorithm (SSA) regime\n            propensity = k0 + k1 * x\n            if propensity = 1e-9:  # System is stuck (e.g., x=0, k0=0)\n                t = T_final\n                continue\n            \n            # Time to next event\n            dt = rng.exponential(1.0 / propensity)\n            \n            if t + dt >= T_final:\n                # Event occurs after T_final, so state does not change\n                t = T_final\n                break\n                \n            t += dt\n            \n            # Choose event\n            if rng.uniform(0, 1)  k0 / propensity:\n                x += 1  # Birth\n            else:\n                x = max(0, x - 1)  # Death\n            # State x remains an integer for the next loop iteration check\n        else:\n            # Deterministic regime (x > H)\n            lambda_val = k0 / k1\n            t_det_start = t\n            x_det_start = float(x)\n\n            if lambda_val >= H:\n                # Trajectory will not cross back below H. Fast-forward to T_final.\n                x_final_det = lambda_val + (x_det_start - lambda_val) * np.exp(-k1 * (T_final - t_det_start))\n                return int(np.round(x_final_det))\n            else:\n                # Trajectory will decay towards lambda  H and will cross H.\n                # Compute time to hit H. Since x_det_start > H > lambda_val, the log argument is > 1.\n                dt_H = (1.0 / k1) * np.log((x_det_start - lambda_val) / (H - lambda_val))\n                \n                if t_det_start + dt_H >= T_final:\n                    # Does not reach H before simulation ends.\n                    x_final_det = lambda_val + (x_det_start - lambda_val) * np.exp(-k1 * (T_final - t_det_start))\n                    return int(np.round(x_final_det))\n                else:\n                    # Reaches H. Update state and switch back to stochastic.\n                    t = t_det_start + dt_H\n                    x = int(H) # State is now exactly H.\n                    # The loop will continue in the stochastic regime.\n\n    # If the loop completes, the final state is the integer x.\n    return x\n\ndef _analyze_discrepancy(samples, k0, k1, n, L, tau, alpha):\n    \"\"\"\n    Computes discrepancy metrics and returns the acceptance decision.\n    \"\"\"\n    # 1. Define analytic and empirical distributions on a truncated space.\n    lambda_val = k0 / k1\n    \n    # Define truncation K and number of bins B\n    if lambda_val > 0:\n        K = int(np.ceil(lambda_val + L * np.sqrt(lambda_val)))\n    else:\n        K = 0\n    B = K + 2\n\n    # Analytic distribution (p)\n    k_vals = np.arange(0, K + 1)\n    p_analytic_pmf = poisson.pmf(k_vals, lambda_val)\n    p_analytic_tail = 1.0 - np.sum(p_analytic_pmf)\n    p_vec = np.append(p_analytic_pmf, p_analytic_tail)\n\n    # Empirical distribution (q_hat)\n    counts = np.zeros(K + 2, dtype=np.int64)\n    for s in samples:\n        if s = K:\n            counts[s] += 1\n        else:\n            counts[K + 1] += 1  # Tail bin\n    q_hat_vec = counts / n\n\n    # 2. Compute the total variation distance estimator.\n    tv_hat = 0.5 * np.sum(np.abs(p_vec - q_hat_vec))\n    \n    # 3. Compute the finite-sample margin.\n    epsilon = np.sqrt(np.log(2 * B / alpha) / (2 * n))\n    delta = 0.5 * B * epsilon\n    \n    # 4. Apply the acceptance decision rule.\n    return (tv_hat + delta) = tau\n\n# Using a default_rng and passing it ensures better practice than global state,\n# but for this problem, the effect is the same.\nsolve()\n```", "id": "3319370"}]}