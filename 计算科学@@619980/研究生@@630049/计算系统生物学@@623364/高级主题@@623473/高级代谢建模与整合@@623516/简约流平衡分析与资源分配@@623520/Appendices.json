{"hands_on_practices": [{"introduction": "这个练习将为你提供一个关于简约通量平衡分析 (pFBA) 核心机制的基础实践。我们将从一个简单的线性代谢途径入手，其中通量之间的关系可以很容易地通过解析推导得出。通过实现 pFBA 的两阶段优化过程 [@problem_id:3336992]，你将观察到系统如何首先最大化其主要生物学目标（例如生物质生产），然后通过次级目标（最小化总通量）从可能的最优解空间中挑选出一个唯一的、高效的通量分布。这个练习将帮助你对 pFBA 的工作原理以及不同约束如何影响最终通量分布建立起一个具体的认识。", "problem": "给定一个稳态代谢网络，由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和反应通量向量 $v \\in \\mathbb{R}^{n}$ 描述。在稳态下，质量平衡要求 $S v = 0$。通量平衡分析 (Flux Balance Analysis, FBA) 为每个反应 $i$ 定义了线性通量边界 $l_i \\le v_i \\le u_i$，并选择一个主要目标进行优化，该目标通常代表生长或产物生成。简约通量平衡分析 (Parsimonious Flux Balance Analysis, pFBA) 是一种分层优化：首先将主要目标最大化至其最优值，然后在所有达到该最优值的通量向量中，最小化总通量 $\\sum_{i=1}^{n} v_i$，以此作为最小化酶使用和资源分配的代理。\n\n基本假设：\n- 稳态质量守恒：$S v = 0$。\n- 线性可行性约束：对每个 $i$，$l_i \\le v_i \\le u_i$。\n- 分层目标：首先最大化单个通量 $v_k$；其次，在给定最优值 $v_k^\\star$ 的情况下，在满足 $S v = 0$、$l_i \\le v_i \\le u_i$ 和 $v_k = v_k^\\star$ 的约束条件下，最小化 $\\sum_i v_i$。\n\n考虑一个示例网络，其 $S = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix}$ 和三个通量 $v_1$、$v_2$、$v_3$。主要目标是最大化 $v_3$。所有量均为无量纲，并应以不带物理单位的实数形式输出。\n\n您的任务是为以下测试套件实现分层 pFBA 优化。对于每个测试用例，计算 pFBA 解向量 $v = [v_1, v_2, v_3]$：\n1. 基线情况：边界 $0 \\le v_1 \\le 10$，$0 \\le v_2 \\le 100$，$0 \\le v_3 \\le 100$。\n2. 目标受限情况：边界 $0 \\le v_1 \\le 10$，$0 \\le v_2 \\le 100$，$0 \\le v_3 \\le 5$。\n3. 内部瓶颈情况：边界 $0 \\le v_1 \\le 10$，$0 \\le v_2 \\le 4$，$0 \\le v_3 \\le 100$。\n4. 零情况：边界 $0 \\le v_1 \\le 0$，$0 \\le v_2 \\le 0$，$0 \\le v_3 \\le 0$。\n5. 非零下界情况：边界 $2 \\le v_1 \\le 10$，$0 \\le v_2 \\le 100$，$0 \\le v_3 \\le 100$。\n\n对于每个情况，执行：\n- 阶段 1：在满足 $S v = 0$ 和边界约束的条件下，最大化 $v_3$。\n- 阶段 2：在满足 $S v = 0$、边界约束以及 $v_3 = v_3^\\star$（其中 $v_3^\\star$ 是阶段 1 的最优值）的条件下，最小化 $v_1 + v_2 + v_3$。\n\n您的程序应生成单行输出，包含所有测试用例的 pFBA 通量向量，形式为以逗号分隔的列表并用方括号括起来。每个通量分量必须是四舍五入到三位小数的实数。例如，输出格式应类似于 $[[a_{11},a_{12},a_{13}],[a_{21},a_{22},a_{23}],\\dots]$，其中 $a_{ij}$ 表示第 $i$ 个测试用例的第 $j$ 个通量，四舍五入到三位小数。", "solution": "该问题要求计算一个简单代谢网络在五种不同通量边界条件下的简约通量平衡分析 (pFBA) 解。pFBA 方法是一个两阶段优化过程。首先，最大化一个主要的生物学目标。其次，在所有能够达到该最大目标值的可能通量分布中，优化一个次要目标，通常是最小化总通量。\n\n该网络由化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 3}$ 和通量向量 $v \\in \\mathbb{R}^{3}$ 描述：\n$$ S = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix}, \\quad v = \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\end{bmatrix} $$\n系统的基本约束是稳态质量平衡条件 $S v = 0$ 和反应通量边界 $l_i \\le v_i \\le u_i$（对于每个反应 $i \\in \\{1, 2, 3\\}$）。\n\n**步骤 1：稳态约束分析**\n稳态条件 $S v = 0$ 是一个定义了可行通量空间的线性方程组。对于给定的矩阵 $S$，展开为：\n$$ \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix} \\begin{bmatrix} v_1 \\\\ v_2 \\\\ v_3 \\end{bmatrix} = \\begin{bmatrix} -v_1 + v_2 \\\\ -v_2 + v_3 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} $$\n该系统产生两个方程：\n1. $-v_1 + v_2 = 0 \\implies v_1 = v_2$\n2. $-v_2 + v_3 = 0 \\implies v_2 = v_3$\n\n从这些方程中，我们推断任何稳态通量向量都必须满足 $v_1 = v_2 = v_3$。这意味着 $S$ 的零空间是一维的，任何可行通量向量 $v$ 都必须是 $v = [k, k, k]^T$ 的形式，其中 $k$ 为某个标量值。这极大地简化了优化问题，因为我们只需要确定 $k$ 的可行范围。\n\n**步骤 2：定义系统的可行空间**\n标量通量值 $k$ 必须同时满足所有三个反应的边界：\n$$ l_1 \\le v_1 \\le u_1 \\implies l_1 \\le k \\le u_1 $$\n$$ l_2 \\le v_2 \\le u_2 \\implies l_2 \\le k \\le u_2 $$\n$$ l_3 \\le v_3 \\le u_3 \\implies l_3 \\le k \\le u_3 $$\n要使 $k$ 成为一个有效的通量，它必须位于这三个区间的交集内。这导致 $k$ 的一个复合区间：\n$$ \\max(l_1, l_2, l_3) \\le k \\le \\min(u_1, u_2, u_3) $$\n我们定义 $L_{max} = \\max(l_1, l_2, l_3)$ 和 $U_{min} = \\min(u_1, u_2, u_3)$。$k$ 的可行集是区间 $[L_{max}, U_{min}]$。当且仅当 $L_{max} \\le U_{min}$ 时，存在可行解，这对于所有给定的测试用例都成立。\n\n**步骤 3：阶段 1 优化（最大化主要目标）**\n主要目标是最大化通量 $v_3$。由于 $v_3 = k$，这等价于在其可行范围 $[L_{max}, U_{min}]$ 内找到 $k$ 的最大值。\n$$ \\max_{k} k \\quad \\text{subject to} \\quad k \\in [L_{max}, U_{min}] $$\n这个最大化问题的解显然是区间的上界。$v_3$ 的最优值是：\n$$ v_3^{\\star} = U_{min} = \\min(u_1, u_2, u_3) $$\n\n**步骤 4：阶段 2 优化（最小化总通量）**\npFBA 的第二阶段是找到最小化总通量 $\\sum_{i=1}^{3} v_i$ 的通量分布，其约束条件为原始约束以及主要目标必须等于阶段 1 中找到的最优值，即 $v_3 = v_3^{\\star}$。\n目标函数是 $\\sum v_i = v_1 + v_2 + v_3 = k + k + k = 3k$。所以我们必须最小化 $3k$。\n此阶段的约束是：\n1. $k \\in [L_{max}, U_{min}]$ (来自原始边界和稳态)\n2. $v_3 = v_3^{\\star}$，这意味着 $k = U_{min}$ (来自阶段 1)\n\n阶段 2 中 $k$ 的可行集被缩减为单点 $\\{U_{min}\\}$。优化问题变为：\n$$ \\min_{k} 3k \\quad \\text{subject to} \\quad k = U_{min} $$\n唯一解是 $k_{pFBA} = U_{min}$。因为最大化主要目标的通量分布集合只包含一个向量 $[U_{min}, U_{min}, U_{min}]^T$，所以第二步优化必须选择这同一个向量。\n\n**步骤 5：应用于测试用例**\n推导出的解析解 $v_{pFBA} = [k, k, k]^T$（其中 $k = \\min(u_1, u_2, u_3)$）可以应用于每个测试用例。\n\n1.  **基线情况：** 边界为 $l=[0, 0, 0]$ 和 $u=[10, 100, 100]$。\n    $k = \\min(10, 100, 100) = 10$。\n    解向量：$[10.0, 10.0, 10.0]$。\n\n2.  **目标受限情况：** 边界为 $l=[0, 0, 0]$ 和 $u=[10, 100, 5]$。\n    $k = \\min(10, 100, 5) = 5$。\n    解向量：$[5.0, 5.0, 5.0]$。\n\n3.  **内部瓶颈情况：** 边界为 $l=[0, 0, 0]$ 和 $u=[10, 4, 100]$。\n    $k = \\min(10, 4, 100) = 4$。\n    解向量：$[4.0, 4.0, 4.0]$。\n\n4.  **零情况：** 边界为 $l=[0, 0, 0]$ 和 $u=[0, 0, 0]$。\n    $k = \\min(0, 0, 0) = 0$。\n    解向量：$[0.0, 0.0, 0.0]$。\n\n5.  **非零下界情况：** 边界为 $l=[2, 0, 0]$ 和 $u=[10, 100, 100]$。\n    $L_{max} = \\max(2, 0, 0) = 2$。\n    $U_{min} = \\min(10, 100, 100) = 10$。\n    $k$ 的可行范围是 $[2, 10]$。由于 $L_{max} \\le U_{min}$，该问题是可行的。$k$ 的 pFBA 解仍然由 $U_{min}$ 决定。\n    $k = 10$。\n    解向量：$[10.0, 10.0, 10.0]$。\n\n实现将计算这些值并按要求进行格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the parsimonious Flux Balance Analysis (pFBA) solution for a toy\n    metabolic network under several different bounding conditions.\n    \"\"\"\n    \n    # Test cases are defined as tuples of (lower_bounds, upper_bounds)\n    test_cases = [\n        # Case 1: Baseline\n        ([0, 0, 0], [10, 100, 100]),\n        # Case 2: Objective-limited\n        ([0, 0, 0], [10, 100, 5]),\n        # Case 3: Internal bottleneck\n        ([0, 0, 0], [10, 4, 100]),\n        # Case 4: Null case\n        ([0, 0, 0], [0, 0, 0]),\n        # Case 5: Nonzero lower bound\n        ([2, 0, 0], [10, 100, 100]),\n    ]\n\n    results_vectors = []\n    \n    # The stoichiometric matrix S = [[-1, 1, 0], [0, -1, 1]] imposes the\n    # steady-state constraint Sv = 0, which simplifies to v1 = v2 = v3.\n    # Let's call this common flux value 'k'.\n    # The pFBA procedure for this simple network was solved analytically.\n    # Stage 1 (maximize v3 = k) yields k_opt = min(u1, u2, u3).\n    # Stage 2 (minimize v1+v2+v3=3k subject to k=k_opt) confirms the solution k = k_opt.\n    # Thus, the pFBA solution vector is [k_opt, k_opt, k_opt].\n    # We must also ensure feasibility, i.e., max(l_bounds) <= min(u_bounds).\n    # All provided test cases are feasible.\n\n    for l_bounds, u_bounds in test_cases:\n        # Calculate the common flux value 'k' for the pFBA solution\n        k = np.min(u_bounds)\n        \n        # The pFBA flux vector is [k, k, k]\n        pfba_vector = [k, k, k]\n        results_vectors.append(pfba_vector)\n\n    # Format results according to the problem specification:\n    # [[a11,a12,a13],[a21,a22,a23],...] with numbers rounded to three decimal places.\n    formatted_results = []\n    for vec in results_vectors:\n        # Format each component of the vector to three decimal places\n        formatted_vec = [f\"{x:.3f}\" for x in vec]\n        # Join components with a comma and enclose in brackets\n        formatted_results.append(f\"[{','.join(formatted_vec)}]\")\n    \n    # Join all formatted vectors with a comma and enclose in brackets\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3336992"}, {"introduction": "标准 pFBA 通过最小化总通量 $\\sum_i |v_i|$ 来有效促进稀疏解，但这种未加权的求和方式隐含了一个假设：即每单位通量都具有相同的“成本”。本练习将通过一个精心设计的反例来探讨这一假设的关键局限性。你将证明，未加权的 pFBA 可能仅因某个途径包含的反应步骤较少，而错误地偏好一个酶催化效率极低的途径。为了解决这个问题，我们将引入加权 pFBA [@problem_id:3337066]，其权重来源于酶的催化常数 ($w_i = 1/k_{\\text{cat},i}$)，从而提供一个更符合生物学现实的资源成本度量。通过对比加权与未加权 pFBA 的结果，你将理解整合资源分配原则如何能够从根本上改变模型预测的代谢策略。", "problem": "考虑一个由四个内源代谢物和六个不可逆反应组成的最小代谢网络。这些代谢物分别是底物 $S$、中间产物 $A$ 和 $B$ 以及生物质前体 $X$。这些反应是：\n1. 摄取反应 $R_0$：$S_{\\text{ext}} \\rightarrow S$，通量为 $v_0 \\ge 0$，其上限设置得足够大以确保不会成为限制因素。\n2. 直接转化反应 $R_1$：$S \\rightarrow X$，通量为 $v_1 \\ge 0$。\n3. 步骤 $R_2$：$S \\rightarrow A$，通量为 $v_2 \\ge 0$。\n4. 步骤 $R_3$：$A \\rightarrow B$，通量为 $v_3 \\ge 0$。\n5. 步骤 $R_4$：$B \\rightarrow X$，通量为 $v_4 \\ge 0$。\n6. 生物质排出反应 $R_X$：$X \\rightarrow \\emptyset$，通量为 $v_X \\ge 0$。\n\n假设系统处于稳态，并应用基于内源代谢物质量守恒推导出的通量平衡约束。使用编码平衡关系的化学计量矩阵 $S$\n$$\n\\begin{aligned}\nS\\text{-行:}\\quad +v_0 - v_1 - v_2 = 0,\\\\\nA\\text{-行:}\\quad +v_2 - v_3 = 0,\\\\\nB\\text{-行:}\\quad +v_3 - v_4 = 0,\\\\\nX\\text{-行:}\\quad +v_1 + v_4 - v_X = 0,\n\\end{aligned}\n$$\n将生物质排出通量固定为 $v_X = 1$（单位：量/秒），并要求所有反应 $i \\in \\{0,1,2,3,4,X\\}$ 的通量 $v_i \\ge 0$。所有反应都是正向不可逆的。$v_0$ 的摄取上限应设置为一个严格大于 $1$ 的值，以确保在这些约束条件下，摄取不是速率限制步骤。\n\n该网络有两条替代途径来满足 $v_X=1$：一条是经由 $R_1$ 的单反应途径，另一条是经由 $R_2$、$R_3$、$R_4$ 的三反应途径。在简约通量平衡分析（Parsimonious Flux Balance Analysis, pFBA）中，通过最小化总通量大小来获得稀疏的通量分布。在无加权形式下，目标是最小化 $\\min \\sum_i |v_i|$。在一个考虑了资源分配的变体中，会为每个反应分配权重 $w_i$ 并最小化 $\\min \\sum_i w_i |v_i|$，其中权重 $w_i$ 是根据酶催化反应的催化常数 $k_{\\text{cat},i}$ 的倒数 $w_i = 1/k_{\\text{cat},i}$ 得出的。摄取反应 $R_0$ 和生物质排出反应 $R_X$ 被视为非酶促步骤，其权重被赋值为 $w_0 = 0$ 和 $w_X = 0$。\n\n您的任务是：\n- 根据上述约束，构建并求解该网络的无加权 pFBA 问题。\n- 构建并求解加权 pFBA 问题，其中权重 $w_i = 1/k_{\\text{cat},i}$ (当 $i \\in \\{1,2,3,4\\}$ 时)，且 $w_0 = w_X = 0$。\n- 给出一个反例，证明无加权 pFBA 倾向于选择经由 $R_1$ 的低催化常数途径（因为它涉及的反应较少），而权重为 $w_i = 1/k_{\\text{cat},i}$ 的加权 pFBA 则因较高的催化效率而倾向于选择经由 $R_2$、$R_3$、$R_4$ 的多步途径。通过比较 $v_1$ 和 $v_4$ 的大小来决定每种优化方法所偏好的途径，选择通向 $X$ 且通量较大的那条途径。\n\n将每个优化问题表述为线性规划：\n$$\n\\min_{v \\ge 0} \\sum_i w_i v_i \\quad \\text{subject to} \\quad S v = 0,\\quad v_X = 1,\n$$\n其中 $S$ 编码了上述化学计量等式。对于无加权情况，设置所有 $i$ 的 $w_i = 1$。对于加权情况，设置 $w_0 = 0$、$w_X = 0$ 以及当 $i \\in \\{1,2,3,4\\}$ 时 $w_i = 1/k_{\\text{cat},i}$。\n\n使用以下催化常数 $k_{\\text{cat},i}$ 测试组，单位为 $\\text{s}^{-1}$：\n- 测试 1（反例目标）：$k_{\\text{cat},1} = 1$, $k_{\\text{cat},2} = 100$, $k_{\\text{cat},3} = 100$, $k_{\\text{cat},4} = 100$。在这种情况下，加权 pFBA 应该会表现出途径切换。\n- 测试 2（无切换，直接途径仍然更优）：$k_{\\text{cat},1} = 40$, $k_{\\text{cat},2} = 100$, $k_{\\text{cat},3} = 100$, $k_{\\text{cat},4} = 100$。\n- 测试 3（所有催化效率相同）：$k_{\\text{cat},1} = 100$, $k_{\\text{cat},2} = 100$, $k_{\\text{cat},3} = 100$, $k_{\\text{cat},4} = 100$。\n\n对于所有测试，设置摄取上限为 $v_0 \\le 10$ 并保持 $v_X = 1$ 固定不变。按如下方式确定每种优化所偏好的途径：如果 $v_1 \\ge v_4$，选择直接途径；否则，选择多步途径。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是一个布尔值，表示在相应的测试用例中，加权 pFBA 是否相对于无加权 pFBA 改变了偏好的途径，并在此过程中偏好于 $k_{\\text{cat}}$ 值更高的多步途径。输出是无单位的布尔值。例如，需要形如 $[b_1,b_2,b_3]$ 的输出，其中每个 $b_j$ 为 True 或 False。", "solution": "该问题要求我们使用简约通量平衡分析（pFBA）的两种变体来分析一个小型代谢网络：一种是最小化所有反应通量之和的无加权版本，另一种是最小化与酶成本相关的目标函数的加权版本。我们必须针对三个测试用例，判断加权 pFBA 是否会比无加权 pFBA 更偏好一条不同的、催化效率更高的途径。\n\n首先，我们将问题形式化为一个线性规划（LP）问题。变量是六个反应的通量，由向量 $v = [v_0, v_1, v_2, v_3, v_4, v_X]^T$ 表示。所有通量都是不可逆的，因此我们有非负约束 $v_i \\ge 0$ (对所有 $i$) 。\n\n稳态质量平衡方程构成一组线性等式约束 $S v = 0$，其中 $S$ 是化学计量矩阵。根据给定的方程，$S$ 是一个 $4 \\times 6$ 的矩阵：\n$$\nS = \\begin{pmatrix}\n1  -1  -1  0  0  0 \\\\\n0  0  1  -1  0  0 \\\\\n0  0  0  1  -1  0 \\\\\n0  1  0  0  1  -1\n\\end{pmatrix}\n$$\n该系统的右侧是一个零向量，$b_{eq} = [0, 0, 0, 0]^T$。\n\n其他约束以单个通量边界的形式给出：\n1.  生物质排出是固定的：$v_X = 1$。\n2.  底物摄取是非限制性的：$0 \\le v_0 \\le 10$。\n3.  所有其他通量都是非负的：$v_i \\ge 0$ (当 $i \\in \\{1, 2, 3, 4\\}$ 时)。\n\n从化学计量约束中，我们可以推导出通量之间的关键关系。\n$S v = 0$ 的第二行和第三行意味着 $v_2 - v_3 = 0$ 和 $v_3 - v_4 = 0$，可以简化为 $v_2 = v_3 = v_4$。这意味着通过多步途径（$R_2, R_3, R_4$）的通量是均一的。\n第四行结合约束 $v_X = 1$，得到 $v_1 + v_4 = v_X = 1$。这个方程是核心，因为它表明生物质前体 $X$ 的生产被分配到直接途径（通量 $v_1$）和多步途径（通量 $v_4$）之间。\n第一行给出 $v_0 = v_1 + v_2$。代入 $v_2 = v_4$ 和 $v_1 + v_4 = 1$，我们得到 $v_0 = v_1 + v_4 = 1$。总底物摄取量固定为 $1$，这符合上限 $v_0 \\le 10$。\n\n该系统只有一个自由度，可以用通过直接途径 $R_1$ 的通量分数来表示。让我们定义 $\\alpha = v_1$，其中由于通量的非负性和约束 $v_1+v_4=1$，有 $\\alpha \\in [0, 1]$。然后，整个通量向量 $v$ 可以用 $\\alpha$ 表示：\n$v_1 = \\alpha$\n$v_4 = 1 - \\alpha$\n$v_2 = v_3 = v_4 = 1 - \\alpha$\n$v_X = 1$\n$v_0 = 1$\n因此，通量向量为 $v(\\alpha) = [1, \\alpha, 1-\\alpha, 1-\\alpha, 1-\\alpha, 1]^T$。优化问题简化为找到使相应目标函数最小化的 $\\alpha \\in [0, 1]$。\n\n目标是最小化通量的线性组合，即 $\\min \\sum_i w_i v_i$。\n\n对于无加权 pFBA，所有 $i$ 的权重均为 $w_i = 1$。目标函数 $F_{unw}$ 是所有通量之和：\n$$F_{unw}(\\alpha) = \\sum_{i} v_i(\\alpha) = v_0 + v_1 + v_2 + v_3 + v_4 + v_X$$\n$$F_{unw}(\\alpha) = 1 + \\alpha + (1-\\alpha) + (1-\\alpha) + (1-\\alpha) + 1 = 1 + \\alpha + 3(1-\\alpha) + 1 = 5 - 2\\alpha$$\n为了最小化 $F_{unw}(\\alpha)$，我们必须最大化 $\\alpha$。其最大值为 $\\alpha = 1$。这对应于一个通量分布，其中 $v_1 = 1$ 且 $v_4 = 0$。根据决策准则（$v_1 \\ge v_4$），无加权 pFBA 总是选择直接途径。这是符合预期的，因为与任何其他通量分配相比，这条途径涉及的反应更少，因此总通量更低（$1+1+0+0+0+1 = 3$）。\n\n对于加权 pFBA，权重为 $w_0 = 0$、$w_X = 0$ 以及对于酶促反应 $i \\in \\{1, 2, 3, 4\\}$，$w_i = 1/k_{\\text{cat},i}$。目标函数 $F_w$ 是：\n$$F_w(\\alpha) = \\sum_{i} w_i v_i(\\alpha) = w_0 v_0 + w_1 v_1 + w_2 v_2 + w_3 v_3 + w_4 v_4 + w_X v_X$$\n$$F_w(\\alpha) = 0 \\cdot 1 + w_1 \\alpha + w_2 (1-\\alpha) + w_3 (1-\\alpha) + w_4 (1-\\alpha) + 0 \\cdot 1$$\n$$F_w(\\alpha) = w_1 \\alpha + (w_2 + w_3 + w_4)(1-\\alpha)$$\n重新整理这个关于 $\\alpha$ 的线性函数：\n$$F_w(\\alpha) = (w_1 - (w_2 + w_3 + w_4))\\alpha + (w_2 + w_3 + w_4)$$\n此函数在 $\\alpha \\in [0, 1]$ 上的最小值取决于 $\\alpha$ 的系数的符号。\n- 如果 $w_1 - (w_2 + w_3 + w_4) > 0$，最小值在 $\\alpha = 0$ 时取得。这意味着 $v_1 = 0, v_4 = 1$，并且偏好选择多步途径。\n- 如果 $w_1 - (w_2 + w_3 + w_4)  0$，最小值在 $\\alpha = 1$ 时取得。这意味着 $v_1 = 1, v_4 = 0$，并且偏好选择直接途径。\n- 如果 $w_1 - (w_2 + w_3 + w_4) = 0$，任何 $\\alpha \\in [0, 1]$ 都是最优解。\n\n从直接途径（无加权情况）切换到多步途径（加权情况）的条件是当且仅当 $w_1 > w_2 + w_3 + w_4$。回想一下 $w_i = 1/k_{\\text{cat},i}$，此条件等价于：\n$$ \\frac{1}{k_{\\text{cat},1}} > \\frac{1}{k_{\\text{cat},2}} + \\frac{1}{k_{\\text{cat},3}} + \\frac{1}{k_{\\text{cat},4}} $$\n这个不等式意味着直接途径的酶“成本”大于多步途径的酶成本之和，因此从资源分配的角度来看，后者效率更高。\n\n现在我们将这个条件应用于给定的测试用例。\n\n测试 1: $k_{\\text{cat}} = (1, 100, 100, 100)$。\n- $w_1 = 1/1 = 1$。\n- $w_2 = 1/100 = 0.01$, $w_3 = 1/100 = 0.01$, $w_4 = 1/100 = 0.01$。\n- 条件：$1 > 0.01 + 0.01 + 0.01$ 是否成立？是的，$1 > 0.03$。\n- 发生切换。在加权情况下，偏好选择多步途径。该途径的酶（$k_{\\text{cat}}=100$）比直接途径的酶（$k_{\\text{cat}}=1$）效率更高。结果是 `True`。\n\n测试 2: $k_{\\text{cat}} = (40, 100, 100, 100)$。\n- $w_1 = 1/40 = 0.025$。\n- $w_2 = w_3 = w_4 = 0.01$。\n- 条件：$0.025 > 0.01 + 0.01 + 0.01$ 是否成立？否，$0.025 \\ngtr 0.03$。\n- 未发生切换。直接途径仍然是首选。结果是 `False`。\n\n测试 3: $k_{\\text{cat}} = (100, 100, 100, 100)$。\n- $w_1 = 1/100 = 0.01$。\n- $w_2 = w_3 = w_4 = 0.01$。\n- 条件：$0.01 > 0.01 + 0.01 + 0.01$ 是否成立？否，$0.01 \\ngtr 0.03$。\n- 未发生切换。直接途径仍然是首选。结果是 `False`。\n\n最终结果是一个布尔值列表：`[True, False, False]`。所提供的代码将使用标准的 LP 求解器实现此逻辑，以验证分析推导。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the pFBA problem for the given metabolic network and test cases.\n    \"\"\"\n\n    # Define the test suite of catalytic constants\n    test_cases = [\n        # (k_cat1, k_cat2, k_cat3, k_cat4)\n        (1.0, 100.0, 100.0, 100.0),  # Test 1: Should switch\n        (40.0, 100.0, 100.0, 100.0), # Test 2: Should not switch\n        (100.0, 100.0, 100.0, 100.0) # Test 3: Should not switch\n    ]\n\n    # Flux vector v = [v0, v1, v2, v3, v4, vX]^T\n    # Stoichiometric matrix S for Sv = 0\n    # Rows correspond to metabolites S, A, B, X\n    A_eq = np.array([\n        [1, -1, -1,  0,  0,  0],  # S balance: v0 - v1 - v2 = 0\n        [0,  0,  1, -1,  0,  0],  # A balance: v2 - v3 = 0\n        [0,  0,  0,  1, -1,  0],  # B balance: v3 - v4 = 0\n        [0,  1,  0,  0,  1, -1]   # X balance: v1 + v4 - vX = 0\n    ])\n\n    # Right-hand side for the equality constraints\n    b_eq = np.zeros(4)\n\n    # Bounds for the fluxes [v0, v1, v2, v3, v4, vX]\n    # v0 = 10, vX = 1, all others = 0\n    bounds = [\n        (0, 10.0),  # v0\n        (0, None),  # v1\n        (0, None),  # v2\n        (0, None),  # v3\n        (0, None),  # v4\n        (1.0, 1.0)  # vX\n    ]\n\n    # Objective function for unweighted pFBA: min sum(v_i)\n    c_unweighted = np.ones(6)\n\n    def get_preferred_route(flux_vector):\n        \"\"\"\n        Determines the preferred route based on v1 and v4 fluxes.\n        A small tolerance is used for floating point comparison.\n        \"\"\"\n        v1 = flux_vector[1]\n        v4 = flux_vector[4]\n        # Direct route is chosen if v1 = v4\n        return 'direct' if v1 = v4 - 1e-9 else 'multi-step'\n\n    results = []\n    for k_cats in test_cases:\n        k1, k2, k3, k4 = k_cats\n\n        # 1. Unweighted pFBA\n        res_unw = linprog(c=c_unweighted, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        if not res_unw.success:\n            raise RuntimeError(f\"Unweighted LP solver failed for case {k_cats}\")\n        route_unw = get_preferred_route(res_unw.x)\n\n        # 2. Weighted pFBA\n        # Weights w_i = 1/k_cat_i for i=1,2,3,4 and w_0=w_X=0\n        weights = [0.0, 1.0/k1, 1.0/k2, 1.0/k3, 1.0/k4, 0.0]\n        c_weighted = np.array(weights)\n        \n        res_w = linprog(c=c_weighted, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        if not res_w.success:\n            raise RuntimeError(f\"Weighted LP solver failed for case {k_cats}\")\n        route_w = get_preferred_route(res_w.x)\n\n        # 3. Compare routes\n        # Unweighted should always be 'direct' as analyzed.\n        # A switch means unweighted is 'direct' and weighted is 'multi-step'.\n        # The problem statement also implies checking that the multi-step route is 'higher-kcat'.\n        # In Test 1, k_cat for multi-step (100)  k_cat for direct (1), so this holds.\n        # The condition of switching to the multi-step implies it must be more efficient overall.\n        is_switch = (route_unw == 'direct' and route_w == 'multi-step')\n        results.append(is_switch)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3337066"}, {"introduction": "通量平衡分析 (FBA) 的一个核心挑战是“替代最优解”的存在，即多种不同的通量分布可以达到相同的最大目标值。这种解的简并性使得途径分析和预测变得复杂。本练习将提供一个严谨的计算框架，来探讨此问题以及 pFBA 作为解决方案所扮演的角色 [@problem_id:3336975]。你将学习如何通过分析活动约束的零空间来量化 FBA 解空间的简并度，并验证 pFBA 所选出的唯一解是可行多胞体的一个极点。通过比较 FBA 和 pFBA 解的稀疏性，尤其是在包含冗余途径或无效循环的网络中，你将深刻体会到 pFBA 如何增强代谢模型的可解释性和预测能力。", "problem": "给定一个基于质量守恒和线性规划的稳态代谢建模框架。其基本基础是化学计量稳态假设和反应边界：稳态要求每个细胞内代谢物的净生产速率为零，这由线性约束 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ 强制执行，其中 $\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$ 是包含 $m$ 种代谢物和 $n$ 个反应的化学计量矩阵，$\\mathbf{v} \\in \\mathbb{R}^{n}$ 是通量向量。反应边界满足 $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$，其中 $\\mathbf{l}$ 是下界，$\\mathbf{u}$ 是上界。通量平衡分析 (FBA) 在这些约束条件下最大化一个线性目标 $z = \\mathbf{c}^{\\top}\\mathbf{v}$。简约通量平衡分析 (pFBA) 通过最小化酶资源使用的代理（建模为 $\\ell_{1}$-范数 $\\sum_{i=1}^{n} |v_i|$）来解决 FBA 最优通量向量中的简并性，其约束条件是达到相同的最优目标值。\n\n你的任务是编写一个完整的程序，对每个测试用例执行以下操作：\n\n1.  通过最大化 $z = \\mathbf{c}^{\\top}\\mathbf{v}$ 来求解 FBA 问题，约束条件为 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ 和 $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$。\n2.  通过活性约束的零空间分析来识别 FBA 最优解的简并性。按如下方式构建活性约束矩阵 $\\mathbf{A}_{\\text{act}}$：\n    -   包含 $\\mathbf{S}$ 的所有行（这些是等式约束，始终处于活性状态）。\n    -   对于每个反应 $i$，当 $v_i = l_i$ 或 $v_i = u_i$ 在最优解处是活性的（在数值公差范围内）时，包含相应的标准基行 $\\mathbf{e}_i^{\\top}$。\n    -   包含目标超平面行 $\\mathbf{c}^{\\top}$，以限制在最优解集 $z = z^{\\star}$ 内，其中 $z^{\\star}$ 是步骤 1 中找到的最大值。\n    计算 FBA 最优解的简并维度为 $d_{\\text{FBA}} = n - \\operatorname{rank}(\\mathbf{A}_{\\text{act}})$。\n3.  通过最小化 $\\sum_{i=1}^{n} |v_i|$ 来求解 pFBA 问题，约束条件为 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$、$\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$ 和 $\\mathbf{c}^{\\top}\\mathbf{v} = z^{\\star}$，使用带有辅助变量的标准线性化方法来处理绝对值。设 pFBA 解为 $\\mathbf{v}^{\\text{pFBA}}$。\n4.  在 pFBA 解处，仅使用原始定义多胞体的约束（排除目标超平面）来构建活性约束矩阵，即包含 $\\mathbf{S}$ 的所有行和处于边界的反应的边界等式行 $\\mathbf{e}_i^{\\top}$。计算 $d_{\\text{pFBA}} = n - \\operatorname{rank}(\\mathbf{A}_{\\text{act,poly}})$。通过检查 $d_{\\text{pFBA}} = 0$ 是否成立，报告 pFBA 是否选择了原始可行多胞体的一个极点。\n5.  通过比较稀疏性来量化通路的可识别性：计算 FBA 解中的非零通量数量（高于公差），记为 $\\text{nnz}_{\\text{FBA}}$，以及 pFBA 解中的非零通量数量，记为 $\\text{nnz}_{\\text{pFBA}}$。\n\n用于判断活性和非零性的数值公差必须设置为 $10^{-9}$。\n\n测试套件：\n为以下三个科学上一致的网络提供结果。在每个案例中，所有边界都以任意通量单位给出，应视为无量纲数。\n\n-   测试用例 1（从 $G$ 到生物质的两条替代通路）：\n    -   代谢物：$G, B, C$（因此 $m = 3$）。\n    -   反应（$n = 6$）：$v_1$ 摄取 $: \\varnothing \\to G$，$v_2$ 直接转化 $: G \\to B$，$v_3$ 分支 $: G \\to C$，$v_4$ 转化 $: C \\to B$，$v_5$ 生物质流出 $: B \\to \\varnothing$，$v_6$ 输出 $: C \\to \\varnothing$。\n    -   化学计量矩阵行：\n        -   $G$: $(+1, -1, -1, 0, 0, 0)$,\n        -   $B$: $(0, +1, 0, +1, -1, 0)$,\n        -   $C$: $(0, 0, +1, -1, 0, -1)$。\n    -   边界：$v_1 \\in [0, 10]$，$v_2 \\in [0, 1000]$，$v_3 \\in [0, 1000]$，$v_4 \\in [0, 1000]$，$v_5 \\in [0, 1000]$，$v_6 \\in [0, 1000]$。\n    -   目标：$\\mathbf{c} = (0, 0, 0, 0, 1, 0)$。\n\n-   测试用例 2（唯一通路，无分支）：\n    -   代谢物：$G, B$（因此 $m = 2$）。\n    -   反应（$n = 3$）：$v_1$ 摄取 $: \\varnothing \\to G$，$v_2$ 转化 $: G \\to B$，$v_3$ 生物质流出 $: B \\to \\varnothing$。\n    -   化学计量矩阵行：\n        -   $G$: $(+1, -1, 0)$,\n        -   $B$: $(0, +1, -1)$。\n    -   边界：$v_1 \\in [0, 10]$，$v_2 \\in [0, 1000]$，$v_3 \\in [0, 1000]$。\n    -   目标：$\\mathbf{c} = (0, 0, 1)$。\n\n-   测试用例 3（两条替代通路外加一个无效循环 $B \\leftrightarrow D$）：\n    -   代谢物：$G, B, C, D$（因此 $m = 4$）。\n    -   反应（$n = 8$）：与测试用例 1 相同（$v_1$ 到 $v_6$）外加 $v_7$ 正向循环 $: B \\to D$，$v_8$ 反向循环 $: D \\to B$。\n    -   化学计量矩阵行：\n        -   $G$: $(+1, -1, -1, 0, 0, 0, 0, 0)$,\n        -   $B$: $(0, +1, 0, +1, -1, 0, -1, +1)$,\n        -   $C$: $(0, 0, +1, -1, 0, -1, 0, 0)$,\n        -   $D$: $(0, 0, 0, 0, 0, 0, +1, -1)$。\n    -   边界：$v_1 \\in [0, 10]$，$v_2 \\in [0, 1000]$，$v_3 \\in [0, 1000]$，$v_4 \\in [0, 1000]$，$v_5 \\in [0, 1000]$，$v_6 \\in [0, 1000]$，$v_7 \\in [0, 1000]$，$v_8 \\in [0, 1000]$。\n    -   目标：$\\mathbf{c} = (0, 0, 0, 0, 1, 0, 0, 0)$。\n\n答案规格：\n对于每个测试用例，按顺序生成一个包含五个值的列表 $[d_{\\text{FBA}}, d_{\\text{pFBA}}, \\text{nnz}_{\\text{FBA}}, \\text{nnz}_{\\text{pFBA}}, \\text{extreme}_{\\text{pFBA}}]$，其中 $d_{\\text{FBA}}$ 和 $d_{\\text{pFBA}}$ 是整数，$\\text{nnz}_{\\text{FBA}}$ 和 $\\text{nnz}_{\\text{pFBA}}$ 是整数，$\\text{extreme}_{\\text{pFBA}}$ 是一个布尔值，指示 $d_{\\text{pFBA}} = 0$ 是否成立。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是对应测试用例的五个值的列表。例如：$[\\,[d_1, d'_1, k_1, k'_1, b_1],\\,[d_2, d'_2, k_2, k'_2, b_2],\\,[d_3, d'_3, k_3, k'_3, b_3]\\,]$。", "solution": "该问题要求对三种不同的代谢网络模型实施和分析通量平衡分析 (FBA) 和简约通量平衡分析 (pFBA)。分析内容包括求解线性规划问题，通过零空间分析确定解空间的简并性，以及比较所得通量分布的稀疏性。\n\n其方法论基础是基于约束的代谢建模。核心假设是细胞内代谢物处于稳态，从而得出质量平衡约束 $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$，其中 $\\mathbf{S}$ 是化学计量矩阵，$\\mathbf{v}$ 是反应通量向量。通量进一步受到热力学和容量限制的约束，表示为箱式约束 $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$。\n\n对每个测试用例，分析按规定的五个步骤进行：\n\n**步骤 1：通量平衡分析 (FBA)**\n第一步是求解标准的 FBA 问题。这是一个线性规划 (LP) 问题，其公式旨在最大化一个生物学目标函数 $z = \\mathbf{c}^{\\top}\\mathbf{v}$，同时满足稳态和通量边界约束。\n$$\n\\begin{align*}\n\\text{maximize} \\quad  z = \\mathbf{c}^{\\top}\\mathbf{v} \\\\\n\\text{subject to} \\quad  \\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}\n\\end{align*}\n$$\n这个 LP 将使用 `scipy.optimize` 库中的 `linprog` 函数来求解。由于 `linprog` 是一个最小化器，我们求解等效的最小化问题 $z' = -\\mathbf{c}^{\\top}\\mathbf{v}$。FBA 的最优目标值表示为 $z^{\\star}$。\n\n**步骤 2：FBA 简并性 ($d_{\\text{FBA}}$)**\nFBA 问题可能产生唯一的最佳通量向量，也可能产生一个备选最优解的凸集。问题定义了一个计算与此简并性相关的量 $d_{\\text{FBA}}$ 的过程。为求解器返回的特定 FBA 解向量 $\\mathbf{v}^{\\text{FBA}}$ 构建一个活性约束矩阵 $\\mathbf{A}_{\\text{act}}$。该矩阵包括：\n1.  化学计量矩阵 $\\mathbf{S}$ 的所有行。\n2.  目标函数行 $\\mathbf{c}^{\\top}$，代表约束 $\\mathbf{c}^{\\top}\\mathbf{v} = z^{\\star}$。\n3.  对于每个通量 $v_i^{\\text{FBA}}$ 处于其下界或上界的反应 $i$，包含相应的标准基向量 $\\mathbf{e}_i^{\\top}$。\n然后简并性计算为 $d_{\\text{FBA}} = n - \\operatorname{rank}(\\mathbf{A}_{\\text{act}})$，其中 $n$ 是反应的数量。必须注意，这个特定公式衡量的是 LP 求解器返回的单个顶点处活性约束集的零度。如果求解器返回最优面的一个非简并顶点，则无论是否存在备选最优解，该值都将为 $0$。这个量不同于整个最优解空间的维度，后者是备选最优解简并性更常见的定义。我们将严格遵守问题的定义。使用 $10^{-9}$ 的数值公差来确定一个约束是否是活性的。\n\n**步骤 3：简约通量平衡分析 (pFBA)**\npFBA 是一个优化 FBA 解的两步优化过程。在找到最大目标值 $z^{\\star}$ 后，pFBA 在 FBA 最优空间内寻找能够最小化总通量的解，总通量被用作最小化酶成本的代理。目标是最小化通量向量的 $\\ell_{1}$-范数，即 $\\sum_{i=1}^{n} |v_i|$。在给定的测试用例中，所有通量下界均为 $l_i = 0$，这意味着所有通量都是非负的 ($v_i \\ge 0$)。这简化了 pFBA 的目标，因为 $|v_i| = v_i$。因此，pFBA 问题是另一个 LP：\n$$\n\\begin{align*}\n\\text{minimize} \\quad  \\sum_{i=1}^{n} v_i \\\\\n\\text{subject to} \\quad  \\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n \\mathbf{c}^{\\top}\\mathbf{v} = z^{\\star} \\\\\n \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}\n\\end{align*}\n该公式找到一个通量分布，该分布以最小的总酶投入实现最大的生物产量。\n\n**步骤 4：pFBA 解的表征 ($d_{\\text{pFBA}}$)**\npFBA 解 $\\mathbf{v}^{\\text{pFBA}}$ 通常是原始可行多胞体的一个唯一顶点。为了验证这一点，我们计算第二个简并性度量 $d_{\\text{pFBA}}$。我们仅使用定义可行多胞体的约束（即，排除目标超平面 $\\mathbf{c}^{\\top}\\mathbf{v} = z^{\\star}$）来构建活性约束矩阵 $\\mathbf{A}_{\\text{act,poly}}$。该矩阵包含 $\\mathbf{S}$ 的所有行以及在 $\\mathbf{v}^{\\text{pFBA}}$ 处的活性边界约束。简并性为 $d_{\\text{pFBA}} = n - \\operatorname{rank}(\\mathbf{A}_{\\text{act,poly}})$。如果 $d_{\\text{pFBA}} = 0$，则 pFBA 解是可行区域的一个唯一顶点，我们报告 pFBA 选择了一个极点。\n\n**步骤 5：稀疏性分析**\npFBA 的一个关键优势是它倾向于产生更稀疏的通量向量，这意味着更少的反应带有通量。这增强了通路的可识别性。我们通过计算 FBA 解 ($\\text{nnz}_{\\text{FBA}}$) 和 pFBA 解 ($\\text{nnz}_{\\text{pFBA}}$) 中的非零通量数量（定义为 $|v_i| > 10^{-9}$）来量化这一点。这种比较突显了 pFBA 消除生理上不必要的通量的能力，例如 FBA 可能任意包含的无效循环或冗余通路中的通量。虽然标准的 LP 求解器可能碰巧返回一个稀疏的 FBA 解（作为最优面的一个顶点），但 pFBA 保证了这一点。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the specified results.\n    \"\"\"\n    tol = 1e-9\n\n    # Test case 1 definition\n    S1 = np.array([\n        [1, -1, -1, 0, 0, 0],\n        [0, 1, 0, 1, -1, 0],\n        [0, 0, 1, -1, 0, -1]\n    ], dtype=float)\n    l1 = np.zeros(6)\n    u1 = np.array([10, 1000, 1000, 1000, 1000, 1000], dtype=float)\n    c1 = np.array([0, 0, 0, 0, 1, 0], dtype=float)\n\n    # Test case 2 definition\n    S2 = np.array([\n        [1, -1, 0],\n        [0, 1, -1]\n    ], dtype=float)\n    l2 = np.zeros(3)\n    u2 = np.array([10, 1000, 1000], dtype=float)\n    c2 = np.array([0, 0, 1], dtype=float)\n\n    # Test case 3 definition\n    S3 = np.array([\n        [1, -1, -1, 0, 0, 0, 0, 0],\n        [0, 1, 0, 1, -1, 0, -1, 1],\n        [0, 0, 1, -1, 0, -1, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, -1]\n    ], dtype=float)\n    l3 = np.zeros(8)\n    u3 = np.array([10, 1000, 1000, 1000, 1000, 1000, 1000, 1000], dtype=float)\n    c3 = np.array([0, 0, 0, 0, 1, 0, 0, 0], dtype=float)\n\n    test_cases = [\n        (S1, l1, u1, c1),\n        (S2, l2, u2, c2),\n        (S3, l3, u3, c3)\n    ]\n\n    results = []\n    for S, l, u, c in test_cases:\n        results.append(_process_case(S, l, u, c, tol))\n    \n    # Format the final output string\n    # E.g., [[0, 0, 3, 3, True], [0, 0, 3, 3, True], [0, 0, 3, 3, True]]\n    result_str = '[' + ','.join([f\"[{','.join(map(str, r))}]\" for r in results]) + ']'\n    print(result_str)\n\ndef _process_case(S, l, u, c, tol):\n    \"\"\"\n    Performs the full FBA and pFBA analysis for a single test case.\n    \"\"\"\n    m, n = S.shape\n\n    # --- Step 1: Solve FBA ---\n    # Maximize c'v by a minimizing -c'v\n    res_fba = linprog(c=-c, A_eq=S, b_eq=np.zeros(m), bounds=list(zip(l, u)), method='highs')\n    \n    if not res_fba.success:\n        # This should not happen for the given valid problems.\n        raise RuntimeError(\"FBA optimization failed.\")\n        \n    v_fba = res_fba.x\n    z_star = c @ v_fba\n\n    # --- Step 2: Compute FBA Degeneracy (d_FBA) ---\n    # Construct A_act based on the FBA solution\n    A_act_fba_rows = [S, c.reshape(1, -1)]\n    for i in range(n):\n        if abs(v_fba[i] - l[i])  tol or abs(v_fba[i] - u[i])  tol:\n            row = np.zeros(n)\n            row[i] = 1.0\n            A_act_fba_rows.append(row.reshape(1, -1))\n    \n    A_act_fba = np.vstack(A_act_fba_rows)\n    rank_fba = np.linalg.matrix_rank(A_act_fba, tol=tol)\n    d_fba = n - rank_fba\n\n    # --- Step 3: Solve pFBA ---\n    # Objective is to minimize sum(v_i) since all v_i = 0\n    c_pfba = np.ones(n)\n    \n    # Constraints for pFBA: S.v=0 and c.v=z_star\n    A_eq_pfba = np.vstack([S, c.reshape(1, -1)])\n    b_eq_pfba = np.append(np.zeros(m), z_star)\n\n    res_pfba = linprog(c=c_pfba, A_eq=A_eq_pfba, b_eq=b_eq_pfba, bounds=list(zip(l, u)), method='highs')\n\n    if not res_pfba.success:\n        # This should not happen for the given valid problems.\n        raise RuntimeError(\"pFBA optimization failed.\")\n    \n    v_pfba = res_pfba.x\n\n    # --- Step 4: Compute pFBA Degeneracy  Extreme Point Check (d_pFBA) ---\n    # Construct A_act_poly based on the pFBA solution (excluding objective)\n    A_act_poly_rows = [S]\n    for i in range(n):\n        if abs(v_pfba[i] - l[i])  tol or abs(v_pfba[i] - u[i])  tol:\n            row = np.zeros(n)\n            row[i] = 1.0\n            A_act_poly_rows.append(row.reshape(1, -1))\n\n    A_act_poly = np.vstack(A_act_poly_rows)\n    rank_pfba_poly = np.linalg.matrix_rank(A_act_poly, tol=tol)\n    d_pfba = n - rank_pfba_poly\n    extreme_pfba = (d_pfba == 0)\n\n    # --- Step 5: Quantify Sparsity (nnz) ---\n    nnz_fba = np.sum(np.abs(v_fba)  tol)\n    nnz_pfba = np.sum(np.abs(v_pfba)  tol)\n    \n    return [int(d_fba), int(d_pfba), int(nnz_fba), int(nnz_pfba), extreme_pfba]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3336975"}]}