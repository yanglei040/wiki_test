{"hands_on_practices": [{"introduction": "本章的第一个实践将引导你完成一个典型的菌株设计双层优化问题的完整实现 [@problem_id:3290717]。你将为一个简化的代谢网络构建一个模型，其中上层问题是选择基因敲除策略，而下层问题则模拟细胞在最大化生长目标下的行为。这个练习旨在巩固通过枚举上层设计并求解下层线性规划问题来寻找最优工程策略的核心逻辑。", "problem": "您将接触一个在通量平衡分析 (FBA) 框架下的、用于菌株设计的双层优化玩具案例研究。该生物体由一个具有稳态质量平衡和不可逆反应边界的最小代谢网络表示。该双层设计问题模拟了上层工程师选择反应敲除，以在下层生物体实现最佳生长时最大化最坏情况下的产物生成。您必须实现一个完整的、可运行的程序，该程序评估所有允许的敲除集下最坏情况的产物生成，并返回最佳选择。\n\n基本原理和假设：\n- 通量平衡分析 (FBA) 对胞内代谢物使用稳态近似，这会产生形如 $$S\\,\\mathbf{v}=\\mathbf{0}$$ 的线性等式，其中 $$S$$ 是化学计量矩阵，$$\\mathbf{v}$$ 是反应通量向量。\n- 每个反应 $$i$$ 的通量都受到不可逆约束 $$\\ell_i \\le v_i \\le u_i$$ 的限制。\n- 生物体的生长由生物质反应通量 $$v_2$$ 建模，生物体在稳态下会最大化该通量。\n- 我们假设下层生物体可能会在多个生长最优的通量分布中进行选择；在这里，我们评估悲观情况，即在所有实现最大生长的通量向量中，生物体选择使产物分泌通量 $$v_3$$ 最小化的那一个。这对应于一个字典序双层问题：首先最大化 $$v_2$$，然后在相同约束条件下，并附加一个强制 $$v_2=v_2^\\star$$ 的等式，最小化 $$v_3$$，其中 $$v_2^\\star$$ 是第一步得到的最优生长速率。\n\n网络定义：\n- 反应索引为 $$R_0, R_1, R_2, R_3, R_4$$，其通量分别为 $$v_0, v_1, v_2, v_3, v_4$$：\n  - $$R_0$$: 葡萄糖摄取 $$G_{\\mathrm{ext}} \\rightarrow G$$。\n  - $$R_1$$: 氧气摄取 $$O_{\\mathrm{ext}} \\rightarrow O$$。\n  - $$R_2$$: 生物质生长 $$G + 2\\,O \\rightarrow \\mathrm{Biomass}$$。\n  - $$R_3$$: 产物生成 $$G \\rightarrow P_{\\mathrm{ext}}$$.\n  - $$R_4$$: 废物生成 $$G \\rightarrow W_{\\mathrm{ext}}$$.\n- 胞内葡萄糖 $$G$$ 和氧气 $$O$$ 的内部稳态质量平衡等式：\n  - $$v_0 - v_2 - v_3 - v_4 = 0$$,\n  - $$v_1 - 2\\,v_2 = 0$$.\n- 边界：\n  - 固定的葡萄糖摄取：$$v_0 \\in [G_{\\mathrm{fixed}},\\,G_{\\mathrm{fixed}}]$$，其中 $$G_{\\mathrm{fixed}}$$ 是一个指定的非负数。\n  - 氧气摄取：$$v_1 \\in [0,\\,O_{\\max}]$$，其中 $$O_{\\max}$$ 是一个指定的非负数。\n  - 生物质生长最小存活性：$$v_2 \\in [\\gamma,\\,U_2]$$，其中 $$\\gamma \\ge 0$$ 且 $$U_2$$ 是一个较大的上界（您可以选择 $$U_2=100$$）。\n  - 产物和废物通量：$$v_3 \\in [0,\\,U_3]$$，$v_4 \\in [0,\\,U_4]$$，具有较大的上界（您可以选择 $$U_3=U_4=100$$）。\n- 候选敲除仅限于集合 $$\\{R_3, R_4\\}$$。对反应 $$R_i$$ 的敲除通过设置边界为 $$[0,0]$$ 来实现 $$v_i=0$$。\n\n双层优化定义：\n- 上层选择一个敲除集 $$\\mathcal{K} \\subseteq \\{3,4\\}$$ 且 $$|\\mathcal{K}| \\le K$$，以最大化下层最优生长时的最坏情况产物通量：\n  1. 下层步骤 1：在应用了 $$\\mathcal{K}$$ 中敲除的质量平衡和边界约束下，最大化 $$v_2$$。\n  2. 下层步骤 2：在实现最优生长 $$v_2^\\star$$ 的解中，使用相同的约束条件并附加等式 $$v_2=v_2^\\star$$ 来最小化 $$v_3$$。\n- 上层的目标是由步骤 2 返回的最小产物通量 $$v_3^{\\min}(\\mathcal{K})$$；工程师选择能最大化此值的 $$\\mathcal{K}$$。\n\n敲除集的位掩码编码：\n- 反应索引为 $$0,1,2,3,4$$，对应于 $$R_0,R_1,R_2,R_3,R_4$$。\n- 一个敲除集 $$\\mathcal{K}$$ 被编码为一个整数位掩码 $$M$$，其中如果反应 $$R_i$$ 被敲除，则位 $$i$$ 为 $$1$$，否则为 $$0$$。例如，仅敲除 $$R_4$$ 对应于 $$M=2^4=16$$，仅敲除 $$R_3$$ 对应于 $$M=2^3=8$$，没有敲除则对应于 $$M=0$$。\n\n您的任务：\n- 在指定环境中实现一个程序，该程序：\n  - 枚举所有满足 $$|\\mathcal{K}| \\le K$$ 的敲除集 $$\\mathcal{K} \\subseteq \\{3,4\\}$$。\n  - 对于每个 $$\\mathcal{K}$$，求解下层步骤 1（最大化 $$v_2$$）。如果不可行，则舍弃 $$\\mathcal{K}$$。\n  - 对于可行的 $$\\mathcal{K}$$，求解下层步骤 2（在 $$v_2=v_2^\\star$$ 的条件下最小化 $$v_3$$）。如果不可行，则舍弃 $$\\mathcal{K}$$。\n  - 选择能最大化最坏情况产物通量 $$v_3^{\\min}(\\mathcal{K})$$ 的 $$\\mathcal{K}$$。如果出现平局，选择最小的位掩码 $$M$$。\n- 对于任何在步骤 1 中没有敲除集能产生可行解的测试用例，返回哨兵对 $$[-1,-1.0]$$。\n\n测试套件：\n- 您必须将以下测试用例实现为一个列表，每个用例由 $$[G_{\\mathrm{fixed}},\\,O_{\\max},\\,\\gamma,\\,K]$$ 定义：\n  1. $$[10,\\,6,\\,2.5,\\,1]$$: 氧气限制生长且允许一次敲除的正常路径。\n  2. $$[10,\\,6,\\,2.5,\\,0]$$: 不允许敲除的边界情况。\n  3. $$[5,\\,6,\\,2.0,\\,1]$$: 减少葡萄糖，迫使剩余碳量减少。\n  4. $$[10,\\,6,\\,2.5,\\,2]$$: 最多允许两次敲除；同时敲除产物和废物的集合可能变得不可行。\n  5. $$[10,\\,4,\\,2.5,\\,1]$$: 氧气过低无法满足最低生长需求，导致所有集合都不可行。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含测试套件的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素是一个双元素列表 $$[M, v_3]$$，代表所选的敲除位掩码 $$M$$ 和相应的最坏情况产物通量 $$v_3$$，并按测试用例的顺序排列。例如，$$[[M_1,v_{3,1}], [M_2,v_{3,2}], \\dots]$$。\n- 将每个 $$v_3$$ 表示为浮点数。这个玩具模型不需要物理单位。", "solution": "该问题提出了一个用于代谢菌株设计的有效、适定的双层优化任务。其目标是确定一个最佳的反应敲除集，以最大化目标产物的最坏情况生成量。该问题在通量平衡分析 (FBA) 的框架内提出，FBA 是计算系统生物学中一种标准的基于约束的建模方法。解决方案需要迭代求解一系列线性规划 (LP) 问题。\n\n问题的核心在于一个双层优化结构：\n1.  **上层**，代表工程师，从一组允许的修改中选择一个敲除策略 $$\\mathcal{K}$$。\n2.  **下层**，代表细胞的新陈代谢，在给定上层施加的基因改造的条件下，优化其自身的目标（生长）。\n\n我们为下层假设一个悲观或最坏情况的场景：在所有能实现最大生长的可能代谢状态（通量分布）中，细胞将选择使期望化合物产量最小化的那一种。\n\n总体算法通过枚举所有允许的敲除策略，评估每种策略的结果，并根据工程师的目标选择最佳策略来进行。\n\n**数学表述**\n\n代谢网络由一个线性方程和不等式组描述。设反应通量向量为 $$\\mathbf{v} = [v_0, v_1, v_2, v_3, v_4]^T$$。\n\n稳态质量平衡约束由 $$S\\mathbf{v}=\\mathbf{0}$$ 给出。对于这个特定网络，具体方程如下：\n$$v_0 - v_2 - v_3 - v_4 = 0$$\n$$v_1 - 2v_2 = 0$$\n\n这两个方程可以写成矩阵形式 $$A_{eq}\\mathbf{v}=\\mathbf{b}_{eq}$$，其中：\n$$\nA_{eq} = \\begin{pmatrix}\n1  0  -1  -1  -1 \\\\\n0  1  -2  0  0\n\\end{pmatrix}\n, \\quad \\mathbf{b}_{eq} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n\n每个反应 $$i$$ 的通量也受下界和上界 $$\\ell_i \\le v_i \\le u_i$$ 的约束。对于一个给定的测试用例，其参数为 $$G_{\\mathrm{fixed}}$$、$O_{\\max}$$ 和 $$\\gamma$$，基本边界为：\n- $$v_0 \\in [G_{\\mathrm{fixed}}, G_{\\mathrm{fixed}}]$$\n- $$v_1 \\in [0, O_{\\max}]$$\n- $$v_2 \\in [\\gamma, 100]$$\n- $$v_3 \\in [0, 100]$$\n- $$v_4 \\in [0, 100]$$\n\n对反应 $$R_i$$ 的敲除通过将其边界设置为 $$[0, 0]$$ 来实现。候选的敲除反应是 $$R_3$$ 和 $$R_4$$。\n\n**双层优化算法**\n\n对于每个测试用例，我们必须考虑所有有效的敲除集 $$\\mathcal{K} \\subseteq \\{3, 4\\}$$，其中敲除数量 $$|\\mathcal{K}|$$ 不超过给定的限制 $$K$$。每个集合 $$\\mathcal{K}$$ 由一个整数位掩码 $$M$$ 编码。我们评估每个有效的掩码 $$M$$。\n\n对于给定的掩码 $$M$$：\n1.  **下层步骤 1：最大化生长**\n    我们首先求解最大可能的生物质通量 $$v_2$$。这是一个线性规划 (LP) 问题：\n    $$\n    \\begin{align*}\n    v_2^\\star = \\max_{\\mathbf{v}} \\quad  v_2 \\\\\n    \\text{subject to} \\quad  A_{eq}\\mathbf{v} = \\mathbf{b}_{eq} \\\\\n     \\ell_i(M) \\le v_i \\le u_i(M) \\quad \\text{for } i=0, \\dots, 4\n    \\end{align*}\n    $$\n    边界 $$\\ell_i(M)$$ 和 $$u_i(M)$$ 是根据 $$M$$ 中的敲除修改后的基本边界。如果此 LP 不可行（即没有通量向量可以满足所有约束，例如最小生长需求 $$\\gamma$$），则丢弃该敲除策略 $$M$$。\n\n2.  **下层步骤 2：最小化产物通量（最坏情况）**\n    如果步骤 1 可行，我们通过最小化 $$v_3$$ 来找到最坏情况下的产物通量，同时将生长速率约束为其最大可达值 $$v_2^\\star$$。这是第二个 LP 问题：\n    $$\n    \\begin{align*}\n    v_3^{\\min}(M) = \\min_{\\mathbf{v}} \\quad  v_3 \\\\\n    \\text{subject to} \\quad  A_{eq}\\mathbf{v} = \\mathbf{b}_{eq} \\\\\n     \\ell_i(M) \\le v_i \\le u_i(M) \\quad \\text{for } i=0, \\dots, 4 \\\\\n     v_2 = v_2^\\star\n    \\end{align*}\n    $$\n    值 $$v_3^{\\min}(M)$$ 是敲除策略 $$M$$ 的保证最低产物产量。\n\n**上层决策**\n\n在为所有可行和允许的掩码 $$M$$ 评估了 $$v_3^{\\min}(M)$$ 之后，上层问题是选择使该值最大化的掩码 $$M^\\star$$：\n$$ M^\\star = \\arg\\max_{M} \\{v_3^{\\min}(M)\\} $$\n如果 $$v_3^{\\min}$$ 值出现平局，则选择整数值最小的掩码 $$M$$。如果没有敲除策略能产生可行的模型，则为该测试用例返回哨兵值 $$[-1, -1.0]$$。\n\n**实现细节**\n\n所描述的算法使用 Python 和 `scipy.optimize.linprog` 函数实现，该函数用于求解标准形式的 LP 问题。\n- 最大化 $$v_2$$ 是通过最小化 $$-v_2$$ 来实现的，即使用目标向量 $$c = [0, 0, -1, 0, 0]^T$$。\n- 第二个 LP 中的约束 $$v_2 = v_2^\\star$$ 是通过将变量 $$v_2$$ 的边界设置为 `[v_2_star, v_2_star]` 来实现的。\n- 程序遍历所提供的测试用例，对每个用例应用双层算法，并报告最优掩码及相应的最坏情况产物通量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_case(G_fixed, O_max, gamma, K):\n    \"\"\"\n    Solves the bilevel optimization problem for a single test case.\n    \n    Args:\n        G_fixed (float): The fixed glucose uptake rate.\n        O_max (float): The maximum oxygen uptake rate.\n        gamma (float): The minimum required biomass flux for viability.\n        K (int): The maximum number of allowed knockouts.\n\n    Returns:\n        list: A list containing the best knockout mask and the corresponding\n              worst-case product flux, e.g., [mask, v3_min].\n              Returns [-1, -1.0] if no feasible strategy is found.\n    \"\"\"\n    # Stoichiometric matrix for equality constraints v0-v2-v3-v4=0, v1-2v2=0\n    A_eq = np.array([\n        [1, 0, -1, -1, -1],  # Glucose balance\n        [0, 1, -2, 0, 0]     # Oxygen balance\n    ])\n    b_eq = np.array([0, 0])\n    \n    # Large upper bound for unconstrained fluxes\n    U_large = 100.0\n    \n    # Base bounds for the fluxes [v0, v1, v2, v3, v4]\n    base_bounds = [\n        (G_fixed, G_fixed),   # v0: Glucose uptake\n        (0, O_max),           # v1: Oxygen uptake\n        (gamma, U_large),     # v2: Biomass growth\n        (0, U_large),         # v3: Product formation\n        (0, U_large)          # v4: Waste formation\n    ]\n\n    # Define all possible knockout strategies (mask, number of knockouts)\n    # R3 knockout corresponds to bit 3 (2^3=8)\n    # R4 knockout corresponds to bit 4 (2^4=16)\n    knockout_options = [\n        (0, 0),    # No knockouts\n        (8, 1),    # Knockout R3\n        (16, 1),   # Knockout R4\n        (24, 2)    # Knockout R3 and R4\n    ]\n    \n    # Filter for strategies that are permissible under the K limit\n    masks_to_test = [m for m, k_count in knockout_options if k_count = K]\n    \n    best_mask = -1\n    best_v3_min = -1.0\n\n    for M in masks_to_test:\n        bounds = base_bounds.copy()\n        \n        # Apply knockouts by setting the bounds of the flux to [0, 0]\n        if M  8:  # Test bit 3 for R3 knockout\n            bounds[3] = (0, 0)\n        if M  16: # Test bit 4 for R4 knockout\n            bounds[4] = (0, 0)\n        \n        # --- Lower-Level Step 1: Maximize v2 ---\n        # Objective: max(v2) is equivalent to min(-v2)\n        c1 = np.array([0, 0, -1, 0, 0])\n        res1 = linprog(c=c1, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res1.success:\n            continue  # This knockout strategy is infeasible.\n        \n        v2_star = -res1.fun\n\n        # --- Lower-Level Step 2: Minimize v3 at optimal growth ---\n        bounds_step2 = bounds.copy()\n        # Enforce v2 = v2_star by setting the bounds for v2\n        bounds_step2[2] = (v2_star, v2_star)\n        \n        # Objective: min(v3)\n        c2 = np.array([0, 0, 0, 1, 0])\n        res2 = linprog(c=c2, A_eq=A_eq, b_eq=b_eq, bounds=bounds_step2, method='highs')\n        \n        if not res2.success:\n            # This would be an unexpected failure, but we handle it defensively.\n            continue\n            \n        v3_min = res2.fun\n\n        # --- Upper-Level: Update best result ---\n        if best_mask == -1:\n            best_mask = M\n            best_v3_min = v3_min\n        else:\n            # Update if current v3_min is better, or if it's a tie and the mask is smaller\n            # Using a tolerance for robust float comparison\n            if v3_min > best_v3_min + 1e-9:\n                best_v3_min = v3_min\n                best_mask = M\n            elif abs(v3_min - best_v3_min)  1e-9 and M  best_mask:\n                best_mask = M\n    \n    return [best_mask, float(best_v3_min)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # [G_fixed, O_max, gamma, K]\n        [10, 6, 2.5, 1],\n        [10, 6, 2.5, 0],\n        [5, 6, 2.0, 1],\n        [10, 6, 2.5, 2],\n        [10, 4, 2.5, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes a space, e.g., '[16, 7.0]',\n    # which is consistent with the problem's example format of `[M, v_3]`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3290717"}, {"introduction": "真实的代谢网络包含许多可逆反应，这为建模带来了挑战。本练习 [@problem_id:3290687] 介绍了一种关键技术——“拆分变量法”，用于在线性规划中表示可逆通量。你将应用此方法解决一个双层优化问题，其工程目标是通过编辑反应方向性来强制生成目标产物，从而加深对更复杂代谢模型构建的理解。", "problem": "考虑一个使用分裂变量表示可逆反应的最小通量平衡分析（FBA）模型。对于每个反应 $j$，引入非负分裂变量 $v_j^+ \\ge 0$ 和 $v_j^- \\ge 0$，其净通量为 $v_j = v_j^+ - v_j^-$。稳态质量平衡由化学计量矩阵 $S \\in \\mathbb{R}^{n \\times m}$ 强制执行，即 $S v = 0$，其中 $v = (v_1, \\dots, v_m)^\\top$。对每个分裂变量施加边界条件 $0 \\le v_j^+ \\le U_j^+$ 和 $0 \\le v_j^- \\le U_j^-$。方向性编辑通过二元门控变量进行建模，该变量可以通过将其容量设置为零来禁用某个方向：对 $(j, +)$ 的编辑将设置 $U_j^+ = 0$，对 $(j, -)$ 的编辑将设置 $U_j^- = 0$。\n\n低层（内部）问题代表最大化生物质生产的细胞代谢。高层（外部）问题代表一种菌株设计，通过禁用最多 $K$ 个方向（编辑）来限制可逆性，以影响产物途径的方向性。产物方向性被量化为产物反应的净交换通量，$D = v_{\\mathrm{prod}} = v_{\\mathrm{prod}}^+ - v_{\\mathrm{prod}}^-$。外部目标是选择编辑，以最大化在生物质生产的内部最优解处评估的 $D$，其中内部目标是\n$$\n\\max_{v^+, v^- \\ge 0} \\; v_{\\mathrm{biomass}}^+ \\;+\\; \\varepsilon \\cdot \\left(v_{\\mathrm{prod}}^+ - v_{\\mathrm{prod}}^- \\right)\n$$\n其中有一个固定的微小破同位权重 $\\varepsilon = 10^{-6}$，以便在生物质量相同时优先选择正向产物通量。\n\n使用以下小型、科学上一致的网络，该网络捕捉了限制可逆性如何强制实现产物途径的期望方向性。代谢物排序为 $(\\mathrm{S}, \\mathrm{A}, \\mathrm{P})$，反应 $(j=1,\\dots,5)$ 如下：\n- $R_1$：底物摄取 $\\mathrm{extS} \\to \\mathrm{S}$ (不可逆正向)。\n- $R_2$：转化 $\\mathrm{S} \\to \\mathrm{A}$ (不可逆正向)。\n- $R_3$：相互转化 $\\mathrm{A} \\leftrightarrow \\mathrm{P}$ (可逆)。\n- $R_4$：产物交换 $\\mathrm{P} \\leftrightarrow \\mathrm{extP}$ (可逆)。\n- $R_5$：生物质形成 $\\mathrm{A} \\to \\mathrm{Biomass}$ (不可逆正向)。\n\n化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 5}$ 由反应的正向方向按列指定：\n$$\nS = \\begin{bmatrix}\n+1  -1  0  0  0 \\\\\n0  +1  -1  0  -1 \\\\\n0  0  +1  -1  0\n\\end{bmatrix}.\n$$\n对于每个反应 $j$，分裂变量 $v_j^+$ 和 $v_j^-$ 满足 $v_j = v_j^+ - v_j^-$，$v_j^+, v_j^- \\ge 0$。对于不可逆反应（$R_1$, $R_2$, $R_5$），$v_j^- \\equiv 0$。对于可逆反应（$R_3$, $R_4$），除非被编辑禁用，否则 $v_j^+$ 和 $v_j^-$ 都是允许的。内部问题受 $S(v^+ - v^-) = 0$ 和 $v_j^\\pm$ 上的边界约束。生物质变量是 $v_{\\mathrm{biomass}}^+ = v_5^+$，产物交换变量是 $v_{\\mathrm{prod}} = v_4^+ - v_4^-$。\n\n外部问题可以从可编辑集合中选择禁用最多 $K$ 个方向\n$$\n\\mathcal{E} = \\{ (3,-), (4,-) \\},\n$$\n即，$R_3$ 和 $R_4$ 的反向方向可以被单独禁用，每次禁用算作一次编辑。禁用 $(3,-)$ 会强制内部 $\\mathrm{A} \\not\\leftarrow \\mathrm{P}$，禁用 $(4,-)$ 会强制 $\\mathrm{P}$ 不从环境中输入，这两者都会影响产物途径的方向性。\n\n您的任务是编写一个完整的程序，对于每个给定的测试用例，枚举所有大小最多为 $K$ 的编辑集，为每个编辑集求解内部线性规划，评估在内部最优解下得到的产物方向性 $D = v_4^+ - v_4^-$，并返回所有可行编辑集中的最大 $D$。\n\n在每个测试用例中，为非零上界使用以下边界。对于所有情况，取 $U_2^+ = 100$, $U_3^+ = 100$, $U_3^- = 100$, $U_5^+ = 100$，对于不可逆方向，$U_j^- = 0$。让 $U_1^+$ 和 $U_4^\\pm$ 按指定情况变化。所有物理量都是无量纲的；答案中不需要物理单位。\n\n测试套件：\n- 情况 1（顺利路径，不允许编辑）：$U_1^+ = 10$, $U_4^+ = 10$, $U_4^- = 10$, $K = 0$。\n- 情况 2（允许单个编辑以强制方向性）：$U_1^+ = 10$, $U_4^+ = 10$, $U_4^- = 10$, $K = 1$。\n- 情况 3（底物摄取紧张的边界情况）：$U_1^+ = 2$, $U_4^+ = 8$, $U_4^- = 8$, $K = 1$。\n\n对于每种情况，计算最大产物方向性 $D \\in \\mathbb{R}$，定义为在所选编辑下生物质目标的内部最优解处的净交换通量 $v_4^+ - v_4^-$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[D_{\\text{case 1}}, D_{\\text{case 2}}, D_{\\text{case 3}}]$。将每个 $D$ 表示为浮点数。\n\n约束和实现要求：\n- 您必须将内部优化实现为一个线性规划，其决策变量为 $(v^+, v^-)$，约束为 $S(v^+ - v^-) = 0$ 和 $0 \\le v_j^\\pm \\le U_j^\\pm$，其中特定方向的 $U_j^\\pm$ 在被编辑禁用时设置为零。目标是最大化 $v_5^+ + \\varepsilon (v_4^+ - v_4^-)$，其中 $\\varepsilon = 10^{-6}$。\n- 您必须通过枚举 $\\mathcal{E}$ 的所有大小最多为 $K$ 的子集来实现外部优化，并选择在可行内部解中具有最大 $D$ 的设计。\n- 如果对于某组特定的编辑，内部线性规划不可行，则在对编辑进行最大化时，应丢弃该组编辑。\n- 不涉及角度、百分比或物理单位，因此不需要单位转换。[@problem_id:481]", "solution": "在尝试解决方案之前，用户提供的问题陈述会经过严格的验证过程。\n\n### 第1步：提取已知信息\n\n问题提供了以下数据和定义：\n\n*   **模型**：带有分裂变量 $v_j^+ \\ge 0$ 和 $v_j^- \\ge 0$ 的通量平衡分析（FBA），用于每个反应 $j$，其中净通量为 $v_j = v_j^+ - v_j^-$。\n*   **化学计量**：稳态质量平衡为 $S v = 0$，其中 $v = v^+ - v^-$。针对代谢物 $(\\mathrm{S}, \\mathrm{A}, \\mathrm{P})$ 和反应 $(R_1, \\dots, R_5)$ 的化学计量矩阵是：\n    $$\n    S = \\begin{bmatrix}\n    +1  -1  0  0  0 \\\\\n    0  +1  -1  0  -1 \\\\\n    0  0  +1  -1  0\n    \\end{bmatrix}\n    $$\n*   **反应**：\n    - $R_1$：$\\mathrm{extS} \\to \\mathrm{S}$ (不可逆正向, $v_1^- = 0$)\n    - $R_2$：$\\mathrm{S} \\to \\mathrm{A}$ (不可逆正向, $v_2^- = 0$)\n    - $R_3$：$\\mathrm{A} \\leftrightarrow \\mathrm{P}$ (可逆)\n    - $R_4$：$\\mathrm{P} \\leftrightarrow \\mathrm{extP}$ (可逆)\n    - $R_5$：$\\mathrm{A} \\to \\mathrm{Biomass}$ (不可逆正向, $v_5^- = 0$)\n*   **双层优化结构**：\n    - **内部问题（细胞目标）**：最大化生物质生产，并使用一个破同位项来处理产物通量：\n      $$\n      \\max_{v^+, v^- \\ge 0} \\; v_{\\mathrm{biomass}}^+ \\;+\\; \\varepsilon \\cdot \\left(v_{\\mathrm{prod}}^+ - v_{\\mathrm{prod}}^- \\right)\n      $$\n      其中 $v_{\\mathrm{biomass}}^+ = v_5^+$，$v_{\\mathrm{prod}} = v_4^+ - v_4^-$，且 $\\varepsilon = 10^{-6}$。\n    - **外部问题（工程目标）**：选择一个编辑集以最大化产物方向性 $D = v_4^+ - v_4^-$，该值在内部最优解处进行评估。\n*   **编辑**：可以从可编辑集 $\\mathcal{E} = \\{ (3,-), (4,-) \\}$ 中禁用最多 $K$ 个方向。禁用 $(j,-)$ 意味着将上界 $U_j^-$ 设置为 $0$。\n*   **边界**：\n    - 恒定边界：$U_2^+ = 100$, $U_3^+ = 100$, $U_3^- = 100$, $U_5^+ = 100$。\n    - 不可逆反应边界：$U_1^- = 0$, $U_2^- = 0$, $U_5^- = 0$。\n*   **测试用例**：\n    - **情况 1**：$U_1^+ = 10$, $U_4^+ = 10$, $U_4^- = 10$, $K = 0$。\n    - **情况 2**：$U_1^+ = 10$, $U_4^+ = 10$, $U_4^- = 10$, $K = 1$。\n    - **情况 3**：$U_1^+ = 2$, $U_4^+ = 8$, $U_4^- = 8$, $K = 1$。\n*   **任务**：枚举所有大小最多为 $K$ 的编辑集，为每个编辑集求解内部线性规划（LP），并找到由此产生的最大产物方向性 $D$。\n\n### 第2步：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n\n*   **科学依据**：该问题是使用FBA进行代谢菌株设计的双层优化的一个标准（尽管简化了）的公式化表述。这种方法是计算系统生物学的基石。网络拓扑结构是对分支代谢途径的合理表示。\n*   **适定性**：该问题是适定的。外部优化是在一个小的、有限的离散选择集（$\\mathcal{E}$的子集）上进行搜索。对于每个选择，内部问题都是一个线性规划（LP）。LP的可行域由指定的上界 $U_j^\\pm$ 限定，保证了最优解的存在。目标函数中的 $\\varepsilon$ 项确保了在主目标（$v_5^+$）出现退化情况时，存在唯一的最优通量分布，从而得到唯一确定的 $D$ 值。\n*   **客观性**：问题使用精确的数学语言陈述，所有术语和变量都得到了清晰的定义。它不含主观或模棱两可的陈述。\n*   **完整性和一致性**：问题是自洽的。它提供了化学计量矩阵、反应定义、两个优化层次的目标、所有必要的边界、可能编辑的集合以及每个测试用例的具体参数。没有内部矛盾。\n\n### 第3步：结论与行动\n\n问题是有效的。它在科学上是合理的，适定的，并且是完全指定的。将制定一个解决方案。\n\n### 解法推导\n\n该问题是一个双层优化任务。外部层决策是选择一组反应方向的删除，而内部层是一个代谢FBA问题。\n\n**外部问题：编辑的枚举**\n\n可编辑的反应方向集合是 $\\mathcal{E} = \\{ (3,-), (4,-) \\}$。外部问题要求我们考虑所有大小最多为 $K$ 的 $\\mathcal{E}$ 的子集。\n*   对于 $K=0$，唯一可能的编辑集是空集 $\\emptyset$。\n*   对于 $K=1$，可能的编辑集是 $\\emptyset$、$\\{(3,-)\\}$ 和 $\\{(4,-)\\}$。\n对于这些编辑集中的每一个，我们求解内部问题并记录得到的产物通量 $D$。给定测试用例的最终答案是在所有有效编辑集中找到的最大 $D$。\n\n**内部问题：线性规划公式**\n\n对于一组给定的编辑（这决定了通量边界），内部问题是找到通量分布 $(v^+, v^-)$ 来解决：\n$$\n\\max_{v^+, v^-} \\quad v_5^+ + \\varepsilon(v_4^+ - v_4^-)\n$$\n受以下条件约束：\n1.  **稳态**：$S(v^+ - v^-) = 0$\n2.  **边界**：对于所有 $j=1, \\dots, 5$，$0 \\le v_j^+ \\le U_j^+$ 和 $0 \\le v_j^- \\le U_j^-$。$U_j^\\pm$ 的值由测试用例和激活的编辑确定。\n\n让我们将决策变量向量定义为 $x = [v_1^+, v_2^+, v_3^+, v_4^+, v_5^+, v_1^-, v_2^-, v_3^-, v_4^-, v_5^-]^\\top \\in \\mathbb{R}^{10}$。\n\nLP可以写成数值求解器（例如`scipy.optimize.linprog`）所需的标准形式，它通常是最小化 $c^\\top x$。因此，我们最小化目标函数的负值：\n$$\n\\min_{x} \\quad -v_5^+ - \\varepsilon(v_4^+ - v_4^-)\n$$\n这定义了目标向量 $c \\in \\mathbb{R}^{10}$ 为：\n$$\nc = [0, 0, 0, -\\varepsilon, -1, 0, 0, 0, \\varepsilon, 0]^\\top\n$$\n其中非零元素对应于 $v_4^+$（索引3）、$v_5^+$（索引4）和 $v_4^-$（索引8）。\n\n等式约束 $S(v^+ - v^-) = 0$ 可以写成 $A_{eq} x = b_{eq}$，其中：\n$$\nA_{eq} = [S | -S] = \\begin{bmatrix}\n1  -1  0  0  0  -1  1  0  0  0 \\\\\n0  1  -1  0  -1  0  -1  1  0  1 \\\\\n0  0  1  -1  0  0  0  -1  1  0\n\\end{bmatrix}\n$$\n并且 $b_{eq} = [0, 0, 0]^\\top$。\n\n边界是 $0 \\le x_i \\le U_i$ 对于 $x$ 的每个元素。上界向量 $U$ 是根据测试用例和选定的编辑为每次运行配置的。例如，如果选择了编辑 $(3,-)$，则 $v_3^-$（$x$ 中的第8个变量）的上界设置为 $0$。\n\n**代谢网络分析**\n\n稳态方程是：\n1.  $v_1 - v_2 = 0 \\implies v_1 = v_2$\n2.  $v_2 - v_3 - v_5 = 0 \\implies v_5 = v_2 - v_3$\n3.  $v_3 - v_4 = 0 \\implies v_3 = v_4$\n\n代入这些，得到生物质通量的简化表达式：\n$$\nv_5 = v_2 - v_4\n$$\n由于 $R_1$ 和 $R_2$ 是不可逆的，$v_1=v_1^+ \\ge 0$ 和 $v_2=v_2^+ \\ge 0$。底物摄取限制是 $v_1^+ \\le U_1^+$，这意味着 $v_2^+ \\le U_1^+$。现在可以通过代入 $v_5 = v_5^+$（因为 $R_5$ 是不可逆的）和 $v_4 = v_4^+ - v_4^-$ 来重写内部目标：\n$$\n\\max \\quad (v_2^+ - v_4) + \\varepsilon v_4 = v_2^+ + (\\varepsilon - 1)v_4\n$$\n由于 $\\varepsilon = 10^{-6}$，项 $(\\varepsilon - 1)$ 是负的。为了最大化此目标，细胞将尝试最大化 $v_2^+$（直到其限制 $U_1^+$）并同时使 $v_4$ 尽可能小（即，尽可能负），这要受 $v_4$ 的活动约束。\n\n**测试用例演练**\n\n*   **情况 1**：$U_1^+ = 10$, $U_4^{\\pm} = 10$, $K = 0$。\n    *   **编辑**：只有空集 $\\emptyset$。\n    *   **分析**：净通量 $v_4$ 受其边界约束：$-U_4^- \\le v_4 \\le U_4^+$，因此 $v_4 \\in [-10, 10]$。为了最大化 $v_2^+ + (\\varepsilon - 1)v_4$，我们选择最大的 $v_2^+ = 10$ 和最小的 $v_4 = -10$。\n    *   **结果**：$D = v_4 = -10.0$。生物质通量为 $v_5^+ = v_2^+ - v_4 = 10 - (-10) = 20$。\n\n*   **情况 2**：$U_1^+ = 10$, $U_4^{\\pm} = 10$, $K = 1$。\n    *   **编辑**：$\\emptyset$、$\\{(3,-)\\}$、$\\{(4,-)\\}$。\n    *   **集合 $\\emptyset$**：如情况1， $D = -10.0$。\n    *   **集合 $\\{(3,-)\\}$**：编辑 $v_3^- = 0$ 使 $R_3$ 不可逆（$A \\to P$），因此 $v_3 = v_3^+ \\ge 0$。由于 $v_3=v_4$，这强制 $v_4 \\ge 0$。$v_4$ 的允许范围变为 $[0, 10]$。为了最大化 $v_2^+ + (\\varepsilon - 1)v_4$，我们选择 $v_2^+ = 10$ 和最小可能的 $v_4$，现在是 $0$。\n    *   **此编辑的结果**：$D = v_4 = 0.0$。\n    *   **集合 $\\{(4,-)\\}$**：编辑 $v_4^-=0$ 使 $R_4$ 不可逆（$P \\to extP$），因此 $v_4 = v_4^+ \\ge 0$。这导致与前一个编辑相同的结果。\n    *   **此编辑的结果**：$D = v_4 = 0.0$。\n    *   **总计**：所有编辑集中的最大 $D$ 是 $\\max(-10.0, 0.0, 0.0) = 0.0$。\n\n*   **情况 3**：$U_1^+ = 2$, $U_4^{\\pm} = 8$, $K = 1$。\n    *   **编辑**：$\\emptyset$、$\\{(3,-)\\}$、$\\{(4,-)\\}$。\n    *   **集合 $\\emptyset$**：$v_2^+ \\le U_1^+ = 2$。$v_4$ 的范围是 $[-8, 8]$。为了最大化 $v_2^+ + (\\varepsilon - 1)v_4$，我们选择 $v_2^+ = 2$ 和 $v_4 = -8$。\n    *   **结果**：$D = v_4 = -8.0$。生物质为 $v_5^+ = 2 - (-8) = 10$。\n    *   **集合 $\\{(3,-)\\}$**：强制 $v_4 \\ge 0$。$v_4$ 的范围变为 $[0, 8]$。我们选择 $v_2^+ = 2$ 和最小的 $v_4 = 0$。\n    *   **此编辑的结果**：$D = v_4 = 0.0$。\n    *   **集合 $\\{(4,-)\\}$**：强制 $v_4 \\ge 0$，导致相同的结果。\n    *   **此编辑的结果**：$D = v_4 = 0.0$。\n    *   **总计**：所有编辑集中的最大 $D$ 是 $\\max(-8.0, 0.0, 0.0) = 0.0$。\n\n实现将遵循此逻辑，为每个场景构建并求解相应的LP。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the bilevel optimization problem for strain design.\n    The outer loop enumerates edit strategies, and the inner loop solves\n    a flux balance analysis problem formulated as a linear program.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: K=0, no edits allowed\n        {'U1+': 10, 'U4+': 10, 'U4-': 10, 'K': 0},\n        # Case 2: K=1, one edit allowed to enforce product directionality\n        {'U1+': 10, 'U4+': 10, 'U4-': 10, 'K': 1},\n        # Case 3: K=1, tight substrate uptake\n        {'U1+': 2, 'U4+': 8, 'U4-': 8, 'K': 1},\n    ]\n\n    # Stoichiometric matrix S (3 metabolites x 5 reactions)\n    # Metabolites: S, A, P\n    # Reactions: R1(uptake), R2(S-A), R3(A-P), R4(P-extP), R5(biomass)\n    S = np.array([\n        [1, -1, 0, 0, 0],\n        [0, 1, -1, 0, -1],\n        [0, 0, 1, -1, 0]\n    ])\n\n    # Linear programming formulation using split variables\n    # x = [v1+, v2+, v3+, v4+, v5+, v1-, v2-, v3-, v4-, v5-]\n    num_reactions = 5\n    num_vars = 2 * num_reactions\n\n    # Equality constraints: S(v+ - v-) = 0  =  [S, -S]x = 0\n    A_eq = np.hstack([S, -S])\n    b_eq = np.zeros(S.shape[0])\n\n    # Inner objective: max v5+ + eps*(v4+ - v4-)\n    # linprog minimizes, so we use c for: min -v5+ - eps*v4+ + eps*v4-\n    epsilon = 1e-6\n    c = np.zeros(num_vars)\n    c[4] = -1.0        # Coefficient for -v5+\n    c[3] = -epsilon    # Coefficient for -eps*v4+\n    c[8] = epsilon     # Coefficient for +eps*v4- (index 5 + 3)\n\n    # Editable reactions are R3- and R4-\n    # In the U_minus vector, these correspond to indices 2 and 3.\n    editable_set = [\n        (),          # No edits (size 0)\n        ((2, '-'),), # Edit R3- (v3-)\n        ((3, '-'),), # Edit R4- (v4-)\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        K = case['K']\n        \n        # Determine which edit sets to evaluate based on K\n        # For K=0, only size 0 sets. For K=1, size 0 and 1 sets.\n        sets_to_evaluate = [s for s in editable_set if len(s) = K]\n\n        # Base upper bounds for v+ and v-\n        U_plus_base = np.array([\n            case['U1+'],  # U1+\n            100.0,        # U2+\n            100.0,        # U3+\n            case['U4+'],  # U4+\n            100.0,        # U5+\n        ])\n        \n        U_minus_base = np.array([\n            0.0,          # U1- (irreversible)\n            0.0,          # U2- (irreversible)\n            100.0,        # U3- (reversible, editable)\n            case['U4-'],  # U4- (reversible, editable)\n            0.0,          # U5- (irreversible)\n        ])\n\n        max_D_for_case = -np.inf\n\n        for edit_set in sets_to_evaluate:\n            # Apply edits to the bounds\n            U_plus = U_plus_base.copy()\n            U_minus = U_minus_base.copy()\n\n            for reaction_index, direction in edit_set:\n                if direction == '+':\n                    U_plus[reaction_index] = 0.0\n                elif direction == '-':\n                    U_minus[reaction_index] = 0.0\n\n            # Combine bounds for the full variable vector x\n            bounds = []\n            for i in range(num_reactions):\n                bounds.append((0, U_plus[i]))\n            for i in range(num_reactions):\n                bounds.append((0, U_minus[i]))\n\n            # Solve the inner linear program\n            sol = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n            if sol.success:\n                # Calculate product directionality D = v4+ - v4-\n                v_plus = sol.x[:num_reactions]\n                v_minus = sol.x[num_reactions:]\n                D = v_plus[3] - v_minus[3] # v4 is the 4th reaction (index 3)\n                \n                # The bilevel objective is to maximize D\n                if D > max_D_for_case:\n                    max_D_for_case = D\n        \n        results.append(max_D_for_case)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{r:.1f}' for r in results)}]\")\n\nsolve()\n```", "id": "3290687"}, {"introduction": "一个成功的工程菌株通常需要在多种环境条件下都能稳定表现。本实践 [@problem_id:3290694] 将菌株设计问题扩展到多场景优化的框架中，其目标是找到一个在所有预设环境中都能最大化最差情况下产物产量的单一设计。这个练习让你从针对单一条件的优化转向为稳健性而设计，这在实际应用中至关重要。", "problem": "考虑一个基于稳态通量平衡分析（FBA）的多场景双层菌株设计问题。细胞内稳态条件由每个场景索引 $k$ 的线性约束 $S v^{(k)} = 0$ 表示，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v^{(k)} \\in \\mathbb{R}^n$ 是场景 $k$ 的反应通量向量，并逐分量施加边界 $l^{(k)} \\le v^{(k)} \\le u^{(k)}$。在每个场景 $k$ 中，内层问题选择一个通量向量 $v^{(k)}$，以最大化生长目标 $c_{\\mu}^\\top v^{(k)}$，其中 $c_{\\mu} \\in \\mathbb{R}^n$。为了在最优生长条件下唯一定义产物通量，使用了一个字典序标准：首先求解生长最大化问题以获得最优生长值 $\\mu^{*(k)}$，然后在所有能达到至少 $\\mu^{*(k)}$ 生长水平的通量向量中，选择一个能最大化产物目标 $c_{p}^\\top v^{(k)}$ 的向量。外层问题从一个有限目录 $\\mathcal{X}$ 中选择一个单一设计 $x$，该设计以依赖于设计的方式修改边界 $(l^{(k)}, u^{(k)})$，目标是最大化所有场景中的最差情况产物通量，同时确保场景级别的最优生长值满足生存阈值。形式上，对于给定的 $x \\in \\mathcal{X}$ 和场景 $k$，将经设计修改的边界定义为 $l^{(k)}(x), u^{(k)}(x)$，并将内层生长最优值定义为\n$$\n\\mu^{*(k)}(x) \\;=\\; \\max_{v \\in \\mathbb{R}^n} \\;\\; c_{\\mu}^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l^{(k)}(x) \\le v \\le u^{(k)}(x).\n$$\n对每个场景 $k$ 施加生存能力要求 $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$，其中给定了 $\\underline{\\mu}^{(k)} \\in \\mathbb{R}_{\\ge 0}$。然后将每个 $k$ 的产物生成字典序步骤定义为\n$$\nv_{p}^{(k)}(x) \\;=\\; \\max_{v \\in \\mathbb{R}^n} \\;\\; c_{p}^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l^{(k)}(x) \\le v \\le u^{(k)}(x),\\;\\; c_{\\mu}^\\top v \\ge \\mu^{*(k)}(x) - \\tau,\n$$\n其中 $\\tau \\in \\mathbb{R}_{0}$ 是一个小的容差，以避免数值问题。外层问题选择 $x \\in \\mathcal{X}$ 来最大化最差情况下的产物，\n$$\n\\max_{x \\in \\mathcal{X}} \\;\\; \\min_{k} \\; v_{p}^{(k)}(x) \\qquad \\text{subject to} \\qquad \\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)} \\;\\; \\text{for all}\\; k.\n$$\n您必须实现一个程序，针对以下包含三个案例的测试套件，计算每个案例的最优外层目标值（作为一个实数），并将结果作为单行输出。\n\n所有三个案例都使用相同的化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 5}$，其中有 $n = 5$ 个反应和 $m = 2$ 种细胞内代谢物。反应顺序如下：$v_1$ 是葡萄糖摄取，$v_2$ 是生物质形成（生长），$v_3$ 是前体形成，$v_4$ 是产物形成，$v_5$ 是一条竞争性的废物途径。代谢物顺序为细胞内葡萄糖和细胞内前体。化学计量矩阵 $S$ 为\n$$\nS \\;=\\; \\begin{bmatrix}\n1  -1  -1  0  -1\\\\\n0  0  1  -1  0\n\\end{bmatrix}.\n$$\n生长目标向量为 $c_{\\mu} = \\begin{bmatrix}0  1  0  0  0\\end{bmatrix}^\\top$，产物目标向量为 $c_{p} = \\begin{bmatrix}0  0  0  1  0\\end{bmatrix}^\\top$。除非设计另有修改，否则所有下界均为 $0$。每个场景 $k$ 都有其自身的上界 $u^{(k)}$，具体如下所述，在设计修改前，它们有共同的下界 $l^{(k)} = \\begin{bmatrix}0  0  0  0  0\\end{bmatrix}^\\top$。\n\n必须从离散集合 $\\mathcal{X} = \\{x^{(0)}, x^{(1)}, x^{(2)}, x^{(3)}\\}$ 中选择一个单一设计 $x$。依赖于设计的边界修改定义如下。对于任何场景 $k$，令 $u^{(k)}_{\\text{base}}$ 表示设计前的基础上限；那么：\n1. 基线设计 $x^{(0)}$ 不施加任何改变，即 $u^{(k)}(x^{(0)}) = u^{(k)}_{\\text{base}}$ 且 $l^{(k)}(x^{(0)}) = l^{(k)}$。\n2. 废物敲除设计 $x^{(1)}$ 通过在每个场景中将 $v_5$ 的上界设置为 $0$ 来消除竞争途径，即 $u^{(k)}(x^{(1)})_5 = 0$，而所有其他分量等于 $u^{(k)}_{\\text{base}}$。\n3. 生长上限设计 $x^{(2)}$ 对 $v_2$ 施加一个为 $4$ 的上界限制，即在每个场景中 $u^{(k)}(x^{(2)})_2 = \\min\\{u^{(k)}_{\\text{base},2}, 4\\}$，而所有其他分量等于 $u^{(k)}_{\\text{base}}$。\n4. 产物过表达设计 $x^{(3)}$ 将产物容量增加 $3$ 倍，即在每个场景中 $u^{(k)}(x^{(3)})_4 = 3 \\, u^{(k)}_{\\text{base},4}$，而所有其他分量等于 $u^{(k)}_{\\text{base}}$。\n\n在所有情况下，使用字典序容差 $\\tau = 10^{-9}$。每个案例包含三个场景，其指定的基础上限 $u^{(k)}_{\\text{base}}$ 和生存阈值 $\\underline{\\mu}^{(k)}$ 如下。\n\n案例 A：\n三个场景的基础上限为\n$$\nu^{(1)}_{\\text{base}} = \\begin{bmatrix}10  100  100  3  8\\end{bmatrix}^\\top,\\quad\nu^{(2)}_{\\text{base}} = \\begin{bmatrix}5  100  100  1.5  4\\end{bmatrix}^\\top,\\quad\nu^{(3)}_{\\text{base}} = \\begin{bmatrix}8  100  100  2  7\\end{bmatrix}^\\top.\n$$\n生存阈值为\n$$\n\\underline{\\mu}^{(1)} = 0.5,\\quad \\underline{\\mu}^{(2)} = 0.2,\\quad \\underline{\\mu}^{(3)} = 0.2.\n$$\n\n案例 B：\n基础上限与案例 A 相同。生存阈值更为严格，\n$$\n\\underline{\\mu}^{(1)} = 6,\\quad \\underline{\\mu}^{(2)} = 4.5,\\quad \\underline{\\mu}^{(3)} = 4.\n$$\n\n案例 C：\n基础上限与案例 A 相同，但第三个场景的产物容量更紧，\n$$\nu^{(3)}_{\\text{base}} = \\begin{bmatrix}8  100  100  0.5  7\\end{bmatrix}^\\top.\n$$\n生存阈值与案例 A 相同，\n$$\n\\underline{\\mu}^{(1)} = 0.5,\\quad \\underline{\\mu}^{(2)} = 0.2,\\quad \\underline{\\mu}^{(3)} = 0.2.\n$$\n\n对于每个案例，任务是计算最优外层目标值，即在所有场景 $k$ 满足生存能力约束 $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$ 的条件下，字典序产物通量 $v_{p}^{(k)}(x)$ 在 $k$ 上的最小值在 $x \\in \\mathcal{X}$ 上的最大值。您的程序必须如上所述解决内层问题，并枚举有限的设计集以确定每个案例的最佳 $x$。\n\n不使用角度单位。数值输出中没有物理单位。要求的最终输出格式是包含一个 Python 风格列表的单行，其中有三个浮点数，按 A、B、C 的顺序对应每个案例。每个数字必须精确到六位小数。例如，格式必须像 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 是小数点后有六位数字的浮点数，逗号后没有空格，例如 $[1.234000,0.000100,5.600000]$。", "solution": "问题陈述描述了一个用于代谢菌株设计的多场景双层优化问题。任务是从一个有限的目录中确定一个最优设计策略，该策略在多个环境场景中最大化最差情况下的产物产量，同时受限于细胞生长的生存能力约束。该问题是适定的，科学上基于通量平衡分析（FBA）的原理，并为获得唯一解提供了所有必要的数据。因此，我们可以进行完整求解。\n\n整个问题可以表述为：\n$$\n\\max_{x \\in \\mathcal{X}} \\left( \\min_{k} v_{p}^{(k)}(x) \\right)\n$$\n受限于生存能力约束，即对于每个场景 $k$，最大生长速率 $\\mu^{*(k)}(x)$ 必须满足 $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$。任何场景 $k$ 中不满足此条件的设计 $x$ 都被认为不可行，并从外层最大化问题的候选解集中排除。\n\n问题的核心在于为每个设计 $x \\in \\mathcal{X}$ 和场景 $k$ 求解内层字典序优化问题。这涉及两个序贯的线性规划（LP）。\n\n**步骤 1：代谢模型的解析简化**\n\n首先，我们分析稳态质量平衡约束 $S v = 0$，其中 $v = [v_1, v_2, v_3, v_4, v_5]^\\top$。化学计量矩阵如下所示：\n$$\nS = \\begin{bmatrix}\n1  -1  -1  0  -1 \\\\\n0  0  1  -1  0\n\\end{bmatrix}\n$$\n该矩阵方程对应于两个线性方程：\n1. $v_1 - v_2 - v_3 - v_5 = 0$\n2. $v_3 - v_4 = 0$\n\n从第二个方程，我们直接得到 $v_3 = v_4$。将此代入第一个方程，得到 $v_1 = v_2 + v_4 + v_5$。\n这两个关系表明，5 维通量向量 $v$ 由三个独立通量决定。我们可以选择生长通量 $v_2$、产物通量 $v_4$ 和废物通量 $v_5$ 作为我们的自变量。剩余的通量，即前体形成通量 $v_3$ 和葡萄糖摄取通量 $v_1$，是因变量。\n\nLP 的完整约束集可以根据这些独立通量重新表述。对于任意给定的设计 $x$ 和场景 $k$，设边界为 $l^{(k)}(x) \\le v \\le u^{(k)}(x)$。鉴于所有基础下界均为 $l_i = 0$，我们对所有反应 $i \\in \\{1, \\dots, 5\\}$ 都有 $v_i \\ge 0$。因变量通量的上界 $u_i$ 对自变量施加了约束：\n- $v_1 \\le u_1 \\implies v_2 + v_4 + v_5 \\le u_1$\n- $v_3 \\le u_3 \\implies v_4 \\le u_3$\n\n将这些与自变量的直接边界结合起来，$(v_2, v_4, v_5)$ 的可行空间由以下条件定义：\n- $v_2 + v_4 + v_5 \\le u_1$\n- $0 \\le v_2 \\le u_2$\n- $0 \\le v_4 \\le \\min(u_3, u_4)$\n- $0 \\le v_5 \\le u_5$\n\n**步骤 2：求解内层优化问题**\n\n利用简化的约束，我们可以为两个内层 LP 找到解析解。对于给定的设计 $x$ 和场景 $k$，边界 $(u_1, u_2, u_3, u_4, u_5)$ 是固定的。\n\n**LP 1：生长最大化**\n第一个目标是最大化生长通量，$c_\\mu^\\top v = v_2$。\n$$\n\\mu^{*(k)}(x) = \\max_{v_2, v_4, v_5} v_2\n$$\n在简化约束条件下。为了最大化 $v_2$，我们必须在约束 $v_2 + v_4 + v_5 \\le u_1$ 中为 $v_4$ 和 $v_5$ 选择尽可能小的非负值。最小值为 $v_4=0$ 和 $v_5=0$。这将对 $v_2$ 的约束简化为 $v_2 \\le u_1$ 和 $v_2 \\le u_2$。因此，最优生长速率为：\n$$\n\\mu^{*(k)}(x) = \\min(u_1, u_2)\n$$\n\n**LP 2：产物最大化（字典序步骤）**\n第二个目标是最大化产物通量 $c_p^\\top v = v_4$，条件是达到至少 $\\mu^{*(k)}(x) - \\tau$ 的生长速率。\n$$\nv_p^{(k)}(x) \\text{ value} = \\max_{v_2, v_4, v_5} v_4\n$$\n受简化约束和附加的字典序约束条件限制：\n$$\nv_2 \\ge \\mu^{*(k)}(x) - \\tau\n$$\n为了最大化 $v_4$，我们必须在约束 $v_2 + v_4 + v_5 \\le u_1$ 中为 $v_2$ 和 $v_5$ 选择尽可能小的值。$v_2$ 的最小允许值为 $\\mu^{*(k)}(x) - \\tau$。$v_5$ 的最小值为 $0$。将这些代入不等式得到：\n$$\n(\\mu^{*(k)}(x) - \\tau) + v_4 + 0 \\le u_1 \\implies v_4 \\le u_1 - \\mu^{*(k)}(x) + \\tau\n$$\n最终的最大产物通量也受其自身容量的限制，$v_4 \\le \\min(u_3, u_4)$。因此，解为：\n$$\nv_p^{(k)}(x) \\text{ value} = \\min(\\min(u_3, u_4), u_1 - \\mu^{*(k)}(x) + \\tau)\n$$\n代入 $\\mu^{*(k)}(x) = \\min(u_1, u_2)$ 的表达式：\n$$\nv_p^{(k)}(x) \\text{ value} = \\min(\\min(u_3, u_4), u_1 - \\min(u_1, u_2) + \\tau)\n$$\n\n**步骤 3：设计的算法评估**\n\n利用这些解析解，我们可以通过遍历每个案例的有限设计集来实现完整的程序。对于每个案例（A、B、C）：\n1. 将最大最差情况产物 $P_{\\text{opt}}$ 初始化为一个非常小的数（例如 $-\\infty$）。\n2. 对于每个设计 $x \\in \\{x^{(0)}, x^{(1)}, x^{(2)}, x^{(3)}\\}$：\n   a. 初始化一个标志 `is_viable` 为 `true` 和一个列表 `product_fluxes` 来存储各场景的结果。\n   b. 对于每个场景 $k \\in \\{1, 2, 3\\}$：\n      i. 通过将设计 $x$ 的修改规则应用于基础上限 $u^{(k)}_{\\text{base}}$ 来确定上限 $u^{(k)}(x)$。\n      ii. 计算最大生长速率 $\\mu^{*(k)}(x) = \\min(u_1, u_2)$。\n      iii. 检查生存能力：如果 $\\mu^{*(k)}(x)  \\underline{\\mu}^{(k)}$，则将 `is_viable` 设置为 `false` 并跳出场景循环，因为该设计无效。\n      iv. 如果可行，使用推导出的公式计算最大产物通量 $v_p^{(k)}(x)$。将此值附加到 `product_fluxes`。\n   c. 如果在检查完所有场景后 `is_viable` 仍为 `true`：\n      i. 找到此设计的最差情况（最小）产物通量：$P_{\\text{worst}}(x) = \\min(\\text{product\\_fluxes})$。\n      ii. 更新全局最优值：$P_{\\text{opt}} = \\max(P_{\\text{opt}}, P_{\\text{worst}}(x))$。\n3. 最终值 $P_{\\text{opt}}$ 即为该案例的答案。如果没有可行的设计，则最大值是在一个空集上取，按惯例为 $-\\infty$。在此问题中，每个案例至少有一个设计被证明是可行的。\n\n通过将此算法应用于为案例 A、B 和 C 提供的数据，我们可以计算所需的最优目标值。例如，在案例 A 中使用设计 $x^{(2)}$，生长上限被限制在 $u_2=4$。对于场景 1，新的边界为 $[10, 4, 100, 3, 8]^\\top$。生长速率为 $\\mu^* = \\min(10, 4) = 4$，超过了阈值 $\\underline{\\mu}^{(1)}=0.5$。产物通量为 $\\min(\\min(100, 3), 10 - 4 + \\tau) = \\min(3, 6+\\tau) = 3$。对所有设计和场景重复此过程以找到最终的最优值。对于案例 B，更严格的生存阈值 $\\underline{\\mu}^{(k)}$ 使得设计 $x^{(2)}$ 不可行，因为其受限的生长速率 $4$ 小于 $\\underline{\\mu}^{(1)}=6$ 和 $\\underline{\\mu}^{(2)}=4.5$。最终的最优值是从每个案例中表现最好的可行设计中得出的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-scenario bilevel strain design problem for three given cases.\n    \"\"\"\n    \n    # Global parameters from the problem statement\n    tau = 1e-9\n    designs = ['baseline', 'waste_ko', 'growth_cap', 'product_over']\n\n    def solve_case(base_upper_bounds, viability_thresholds):\n        \"\"\"\n        Calculates the optimal outer objective value for a single case.\n\n        This involves iterating through all possible designs, checking their viability\n        across all scenarios, and finding the design that maximizes the worst-case\n        product flux.\n        \"\"\"\n        max_worst_case_product = -np.inf\n\n        for design in designs:\n            scenario_product_fluxes = []\n            design_is_viable = True\n\n            for k in range(3):  # Iterate through the three scenarios\n                u_base = base_upper_bounds[k]\n                u_mod = u_base.copy()\n\n                # Apply design modifications to the base upper bounds\n                if design == 'waste_ko':\n                    # Design x^(1): Waste knockout\n                    u_mod[4] = 0.0\n                elif design == 'growth_cap':\n                    # Design x^(2): Growth cap\n                    u_mod[1] = min(u_base[1], 4.0)\n                elif design == 'product_over':\n                    # Design x^(3): Product overexpression\n                    u_mod[3] = 3.0 * u_base[3]\n\n                u1, u2, u3, u4, u5 = u_mod\n\n                # Analytically solve the inner optimization problems\n                \n                # LP1: Maximize growth (v_2)\n                # mu_star = min(u_1, u_2)\n                mu_star = min(u1, u2)\n\n                # Check viability constraint for the current scenario\n                if mu_star  viability_thresholds[k]:\n                    design_is_viable = False\n                    break  # This design is not viable, no need to check other scenarios\n\n                # LP2: Maximize product (v_4) subject to near-optimal growth\n                # vp = min(min(u_3, u_4), u_1 - min(u_1, u_2) + tau)\n                u4_prime = min(u3, u4)\n                if u1 = u2:\n                    # In this case, u_1 - min(u_1, u_2) = u_1 - u_1 = 0\n                    vp = min(u4_prime, tau)\n                else: # u1 > u2\n                    # In this case, u_1 - min(u_1, u_2) = u_1 - u_2\n                    vp = min(u4_prime, u1 - u2 + tau)\n                \n                scenario_product_fluxes.append(vp)\n            \n            # If the design was viable across all scenarios, evaluate its performance\n            if design_is_viable:\n                worst_case_product = min(scenario_product_fluxes)\n                if worst_case_product > max_worst_case_product:\n                    max_worst_case_product = worst_case_product\n\n        # If no design was viable, the result is -inf.\n        # The problem setup ensures at least one design is viable.\n        if max_worst_case_product == -np.inf:\n            return 0.0\n        \n        return max_worst_case_product\n\n    # Define the test cases from the problem statement.\n    case_A_ubs = [\n        np.array([10., 100., 100., 3., 8.]),\n        np.array([5., 100., 100., 1.5, 4.]),\n        np.array([8., 100., 100., 2., 7.])\n    ]\n    case_A_mus = [0.5, 0.2, 0.2]\n\n    # Case B uses the same bounds as Case A but with stricter viability thresholds.\n    case_B_ubs = case_A_ubs\n    case_B_mus = [6.0, 4.5, 4.0]\n\n    # Case C modifies the bounds of the third scenario from Case A.\n    case_C_ubs = [\n        np.array([10., 100., 100., 3., 8.]),\n        np.array([5., 100., 100., 1.5, 4.]),\n        np.array([8., 100., 100., 0.5, 7.])\n    ]\n    case_C_mus = case_A_mus\n\n    test_cases = [\n        (case_A_ubs, case_A_mus),\n        (case_B_ubs, case_B_mus),\n        (case_C_ubs, case_C_mus),\n    ]\n\n    results = []\n    for ubs, mus in test_cases:\n        result = solve_case(ubs, mus)\n        results.append(result)\n\n    # Format the final output string as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3290694"}]}