{"hands_on_practices": [{"introduction": "在整合不同数据类型之前，确保每种单一模态的数据质量至关重要。本实践聚焦于单细胞ATAC-seq，其中的关键指标，如转录起始位点（TSS）富集度和峰内读数比例（FRiP），对于滤除低质量细胞至关重要。通过在一个微型数据集上从零开始实现这些计算，您将对任何多模态分析流程中首要且最关键的步骤获得基本理解 ([@problem_id:3330229])。", "problem": "您的任务是形式化并计算两个标准的单细胞转座酶可及性染色质测序 (ATAC-seq) 质量控制指标，然后针对多种阈值方案判定质量控制是否通过。这些指标是转录起始位点 (TSS) 富集度和峰内读数分数 (FRiP)，用于在与通过测序的转录组和表位细胞索引 (CITE-seq) 以及 ATAC-seq 进行多模态整合之前。该问题特意定义在一个具有离散整数坐标的玩具基因组上，以强调基本原理。\n\n以下所有区间均为整数线上的闭区间。一个闭区间 $[a,b]$ 是集合 $\\{x \\in \\mathbb{Z} \\mid a \\le x \\le b\\}$。两个闭区间 $[a,b]$ 和 $[c,d]$ 重叠，当且仅当 $\\max(a,c) \\le \\min(b,d)$。\n\n待实现的定义：\n\n- 碱基覆盖度。给定一个带有片段多重集 $\\mathcal{F} = \\{[s_i,e_i]\\}$ 的细胞和一个位置 $p \\in \\mathbb{Z}$，定义单位碱基覆盖函数\n$$\n\\operatorname{cov}(p;\\mathcal{F}) = \\sum_{[s_i,e_i]\\in \\mathcal{F}} \\mathbf{1}\\{s_i \\le p \\le e_i\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是条件的指示函数。\n\n- 聚合TSS图谱和TSS富集度。设单个染色体上的TSS位置集合为 $G = \\{g_1,\\dots,g_{|G|}\\}$。固定一个对称窗口半径 $W \\in \\mathbb{N}$。对于每个偏移量 $o \\in \\{-W, -W+1, \\dots, -1, 0, 1, \\dots, W\\}$，定义聚合偏移覆盖度\n$$\nC(o) = \\sum_{g \\in G} \\operatorname{cov}(g+o;\\mathcal{F}).\n$$\n定义中心集 $S_{\\text{center}} = \\{-1,0,1\\}$ 和背景集 $S_{\\text{bg}} = \\{-W,\\dots,-2,2,\\dots,W\\}$。定义平均覆盖度\n$$\n\\overline{C}(S) = \\frac{1}{|S|} \\sum_{o\\in S} C(o).\n$$\n定义TSS富集度\n$$\nE = \\begin{cases}\n\\frac{\\overline{C}(S_{\\text{center}})}{\\overline{C}(S_{\\text{bg}})}  \\text{if } \\overline{C}(S_{\\text{bg}}) > 0, \\\\\n+\\infty  \\text{if } \\overline{C}(S_{\\text{bg}}) = 0 \\text{ and } \\overline{C}(S_{\\text{center}}) > 0, \\\\\n0  \\text{if } \\overline{C}(S_{\\text{bg}}) = 0 \\text{ and } \\overline{C}(S_{\\text{center}}) = 0.\n\\end{cases}\n$$\n\n- 峰内读数分数 (FRiP)。设峰区间集合为 $\\mathcal{P} = \\{[u_j,v_j]\\}$。设 $N_{\\text{frag}} = |\\mathcal{F}|$ 为细胞中的片段数。设 $N_{\\text{in\\_peaks}}$ 为 $\\mathcal{F}$ 中与 $\\mathcal{P}$ 中至少一个峰重叠的片段数。定义\n$$\nF = \\begin{cases}\n\\frac{N_{\\text{in\\_peaks}}}{N_{\\text{frag}}}  \\text{if } N_{\\text{frag}} > 0, \\\\\n0  \\text{if } N_{\\text{frag}} = 0.\n\\end{cases}\n$$\n将 $F$ 表示为小数。\n\n- 质量控制通过规则。对于阈值 $\\tau_F \\in \\mathbb{R}_{\\ge 0}$、$\\tau_E \\in \\mathbb{R}_{\\ge 0}$ 和 $\\tau_n \\in \\mathbb{N}_0$，一个细胞通过当且仅当以下三个条件都成立：\n$$\nN_{\\text{frag}} \\ge \\tau_n,\\quad F \\ge \\tau_F,\\quad E \\ge \\tau_E.\n$$\n\n对所有测试用例使用以下固定的玩具数据集：\n\n- TSS 集合 $G = \\{1000, 2000\\}$。\n\n- 窗口半径 $W = 5$。\n\n- 峰集合 $\\mathcal{P} = \\{[990,1010], [1990,2005], [3000,3010]\\}$。\n\n- 三个细胞及其片段集：\n\n    - 细胞1：$\\mathcal{F}_1 = \\{[995,1005], [999,1002], [1998,2002], [2999,3001], [4000,4003]\\}$。\n\n    - 细胞2：$\\mathcal{F}_2 = \\{[985,988], [1008,1012], [1993,1994], [2006,2008], [3005,3005]\\}$。\n\n    - 细胞3：$\\mathcal{F}_3 = \\{\\}$ (无片段)。\n\n阈值三元组 $(\\tau_F,\\tau_E,\\tau_n)$ 的测试套件：\n\n- 测试 1：$(0.5, 2.0, 1)$。\n\n- 测试 2：$(0.8, \\frac{24}{11}, 5)$。\n\n- 测试 3：$(0.0, 0.0, 0)$。\n\n- 测试 4：$(0.9, 3.0, 6)$。\n\n您的程序必须按照上述顺序，对每个测试用例计算在给定阈值下通过质量控制的细胞数量。您的程序应生成单行输出，其中包含这四个整数，以逗号分隔并用方括号括起，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是测试 $i$ 的通过细胞计数。", "solution": "该问题是有效的，因为它在科学上基于单细胞基因组学质量控制的原理，在数学上是适定的，并提供了一套完整、自洽的定义和数据。使用玩具整数基因组是一种标准的教学简化方法，旨在专注于质量控制指标的基本原理实现。\n\n任务是为三个不同的单细胞 ATAC-seq 图谱计算三个质量控制 (QC) 指标，然后针对四组不同的阈值，确定有多少细胞通过 QC。这些指标是唯一片段数 ($N_{\\text{frag}}$)、峰内读数分数 ($F$，或 FRiP) 和转录起始位点 (TSS) 富集分数 ($E$) 。\n\n整体流程是首先为三个细胞中的每一个计算 QC 指标三元组 $(N_{\\text{frag}}, F, E)$。随后，对于四个测试用例中的每一个，我们将每个细胞的指标与给定的阈值 $(\\tau_n, \\tau_F, \\tau_E)$ 进行比较，以确定通过的细胞数量。\n\n所有计算的固定参数为：\n- TSS 集合 $G = \\{1000, 2000\\}$。\n- 窗口半径 $W = 5$。\n- 峰集合 $\\mathcal{P} = \\{[990,1010], [1990,2005], [3000,3010]\\}$。\n\n**第1步：为每个细胞计算 QC 指标**\n\n我们将为细胞1、细胞2和细胞3计算 $(N_{\\text{frag}}, F, E)$。\n\n**细胞1：$\\mathcal{F}_1 = \\{[995,1005], [999,1002], [1998,2002], [2999,3001], [4000,4003]\\}$**\n\n1.  **片段数 ($N_{\\text{frag},1}$):**\n    片段数是多重集 $\\mathcal{F}_1$ 的大小。\n    $$N_{\\text{frag},1} = |\\mathcal{F}_1| = 5$$\n\n2.  **峰内读数分数 ($F_1$):**\n    我们计算 $\\mathcal{F}_1$ 中与 $\\mathcal{P}$ 中至少一个峰重叠的片段数量。\n    - $[995,1005]$ 与 $[990,1010]$ 重叠。\n    - $[999,1002]$ 与 $[990,1010]$ 重叠。\n    - $[1998,2002]$ 与 $[1990,2005]$ 重叠。\n    - $[2999,3001]$ 与 $[3000,3010]$ 重叠。\n    - $[4000,4003]$ 不与 $\\mathcal{P}$ 中任何峰重叠。\n    峰内片段数为 $N_{\\text{in\\_peaks},1} = 4$。\n    $$F_1 = \\frac{N_{\\text{in\\_peaks},1}}{N_{\\text{frag},1}} = \\frac{4}{5} = 0.8$$\n\n3.  **TSS 富集度 ($E_1$):**\n    我们需要为偏移量 $o \\in \\{-5, \\dots, 5\\}$ 计算聚合偏移覆盖度 $C(o) = \\sum_{g \\in G} \\operatorname{cov}(g+o;\\mathcal{F}_1)$。\n    TSS 位于位置 $g_1 = 1000$ 和 $g_2 = 2000$。\n    对于给定的偏移量 $o$, $C(o) = \\operatorname{cov}(1000+o;\\mathcal{F}_1) + \\operatorname{cov}(2000+o;\\mathcal{F}_1)$。\n\n    TSS 附近位置的覆盖度为：\n    - 对于 $o = -5$：$C(-5) = \\operatorname{cov}(995) + \\operatorname{cov}(1995) = 1 + 0 = 1$。\n    - 对于 $o = -4$：$C(-4) = \\operatorname{cov}(996) + \\operatorname{cov}(1996) = 1 + 0 = 1$。\n    - 对于 $o = -3$：$C(-3) = \\operatorname{cov}(997) + \\operatorname{cov}(1997) = 1 + 0 = 1$。\n    - 对于 $o = -2$：$C(-2) = \\operatorname{cov}(998) + \\operatorname{cov}(1998) = 1 + 1 = 2$。\n    - 对于 $o = -1$：$C(-1) = \\operatorname{cov}(999) + \\operatorname{cov}(1999) = 2 + 1 = 3$。\n    - 对于 $o = 0$：$C(0) = \\operatorname{cov}(1000) + \\operatorname{cov}(2000) = 2 + 1 = 3$。\n    - 对于 $o = 1$：$C(1) = \\operatorname{cov}(1001) + \\operatorname{cov}(2001) = 2 + 1 = 3$。\n    - 对于 $o = 2$：$C(2) = \\operatorname{cov}(1002) + \\operatorname{cov}(2002) = 2 + 1 = 3$。\n    - 对于 $o = 3$：$C(3) = \\operatorname{cov}(1003) + \\operatorname{cov}(2003) = 1 + 0 = 1$。\n    - 对于 $o = 4$：$C(4) = \\operatorname{cov}(1004) + \\operatorname{cov}(2004) = 1 + 0 = 1$。\n    - 对于 $o = 5$：$C(5) = \\operatorname{cov}(1005) + \\operatorname{cov}(2005) = 1 + 0 = 1$。\n\n    中心集 $S_{\\text{center}}=\\{-1,0,1\\}$ 上的平均覆盖度为：\n    $$\\overline{C}(S_{\\text{center}}) = \\frac{C(-1) + C(0) + C(1)}{3} = \\frac{3+3+3}{3} = 3$$\n    背景集 $S_{\\text{bg}}=\\{-5,-4,-3,-2,2,3,4,5\\}$ 上的平均覆盖度为：\n    $$\\overline{C}(S_{\\text{bg}}) = \\frac{C(-5)+C(-4)+C(-3)+C(-2)+C(2)+C(3)+C(4)+C(5)}{8} = \\frac{1+1+1+2+3+1+1+1}{8} = \\frac{11}{8}$$\n    由于 $\\overline{C}(S_{\\text{bg}}) > 0$，富集度为：\n    $$E_1 = \\frac{\\overline{C}(S_{\\text{center}})}{\\overline{C}(S_{\\text{bg}})} = \\frac{3}{11/8} = \\frac{24}{11}$$\n    细胞1的指标为 $(N_{\\text{frag},1}, F_1, E_1) = (5, 0.8, \\frac{24}{11})$。\n\n**细胞2：$\\mathcal{F}_2 = \\{[985,988], [1008,1012], [1993,1994], [2006,2008], [3005,3005]\\}$**\n\n1.  **片段数 ($N_{\\text{frag},2}$):**\n    $$N_{\\text{frag},2} = |\\mathcal{F}_2| = 5$$\n\n2.  **峰内读数分数 ($F_2$):**\n    - $[985,988]$：不重叠。\n    - $[1008,1012]$ 与 $[990,1010]$ 重叠。\n    - $[1993,1994]$ 与 $[1990,2005]$ 重叠。\n    - $[2006,2008]$：不重叠。\n    - $[3005,3005]$ 与 $[3000,3010]$ 重叠。\n    峰内片段数为 $N_{\\text{in\\_peaks},2} = 3$。\n    $$F_2 = \\frac{N_{\\text{in\\_peaks},2}}{N_{\\text{frag},2}} = \\frac{3}{5} = 0.6$$\n\n3.  **TSS 富集度 ($E_2$):**\n    对于细胞2，$\\mathcal{F}_2$ 中的片段均不覆盖范围 $[995, 1005]$ 或 $[1995, 2005]$ 内的任何位置 $p$。这些位置是对于 $g \\in G$ 和 $o \\in \\{-5, \\dots, 5\\}$ 的 $g+o$。因此，对于所有相关的 $g$ 和 $o$，$\\operatorname{cov}(g+o;\\mathcal{F}_2) = 0$。\n    这导致对于所有 $o \\in \\{-5, \\dots, 5\\}$，$C(o) = 0$。\n    因此，$\\overline{C}(S_{\\text{center}}) = 0$ 且 $\\overline{C}(S_{\\text{bg}}) = 0$。\n    根据此情况的定义：\n    $$E_2 = 0$$\n    细胞2的指标为 $(N_{\\text{frag},2}, F_2, E_2) = (5, 0.6, 0)$。\n\n**细胞3：$\\mathcal{F}_3 = \\{\\}$**\n\n1.  **片段数 ($N_{\\text{frag},3}$):**\n    $$N_{\\text{frag},3} = |\\mathcal{F}_3| = 0$$\n\n2.  **峰内读数分数 ($F_3$):**\n    根据定义，如果 $N_{\\text{frag}}=0$，则 $F=0$。\n    $$F_3 = 0$$\n\n3.  **TSS 富集度 ($E_3$):**\n    没有片段时，各处的覆盖度都为0。因此，与细胞2一样，$\\overline{C}(S_{\\text{center}}) = 0$ 且 $\\overline{C}(S_{\\text{bg}}) = 0$。\n    $$E_3 = 0$$\n    细胞3的指标为 $(N_{\\text{frag},3}, F_3, E_3) = (0, 0, 0)$。\n\n**第2步：评估测试用例**\n\n我们使用 QC 规则：一个细胞通过，当且仅当 $N_{\\text{frag}} \\ge \\tau_n$，$F \\ge \\tau_F$，且 $E \\ge \\tau_E$。\n\n**细胞指标摘要：**\n- 细胞1：$(5, 0.8, \\frac{24}{11} \\approx 2.18)$\n- 细胞2：$(5, 0.6, 0)$\n- 细胞3：$(0, 0, 0)$\n\n**测试 1: $(\\tau_F, \\tau_E, \\tau_n) = (0.5, 2.0, 1)$**\n- 细胞1：$5 \\ge 1$ (通过), $0.8 \\ge 0.5$ (通过), $24/11 \\ge 2.0$ (通过)。$\\implies$ **通过**\n- 细胞2：$5 \\ge 1$ (通过), $0.6 \\ge 0.5$ (通过), $0 \\ge 2.0$ (失败)。$\\implies$ **失败**\n- 细胞3：$0 \\ge 1$ (失败)。$\\implies$ **失败**\n通过的细胞数 = $1$。\n\n**测试 2: $(\\tau_F, \\tau_E, \\tau_n) = (0.8, \\frac{24}{11}, 5)$**\n- 细胞1：$5 \\ge 5$ (通过), $0.8 \\ge 0.8$ (通过), $24/11 \\ge 24/11$ (通过)。$\\implies$ **通过**\n- 细胞2：$5 \\ge 5$ (通过), $0.6 \\ge 0.8$ (失败)。$\\implies$ **失败**\n- 细胞3：$0 \\ge 5$ (失败)。$\\implies$ **失败**\n通过的细胞数 = $1$。\n\n**测试 3: $(\\tau_F, \\tau_E, \\tau_n) = (0.0, 0.0, 0)$**\n- 细胞1：$5 \\ge 0$ (通过), $0.8 \\ge 0.0$ (通过), $24/11 \\ge 0.0$ (通过)。$\\implies$ **通过**\n- 细胞2：$5 \\ge 0$ (通过), $0.6 \\ge 0.0$ (通过), $0 \\ge 0.0$ (通过)。$\\implies$ **通过**\n- 细胞3：$0 \\ge 0$ (通过), $0.0 \\ge 0.0$ (通过), $0.0 \\ge 0.0$ (通过)。$\\implies$ **通过**\n通过的细胞数 = $3$。\n\n**测试 4: $(\\tau_F, \\tau_E, \\tau_n) = (0.9, 3.0, 6)$**\n- 细胞1：$5 \\ge 6$ (失败)。$\\implies$ **失败**\n- 细胞2：$5 \\ge 6$ (失败)。$\\implies$ **失败**\n- 细胞3：$0 \\ge 6$ (失败)。$\\implies$ **失败**\n通过的细胞数 = $0$。\n\n最终结果是四个测试中各自通过的细胞数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ATAC-seq QC metrics for a toy dataset and determines the number of passing cells\n    for several QC thresholds.\n    \"\"\"\n\n    # --- Fixed Dataset ---\n    G = [1000, 2000]  # TSS set\n    W = 5             # Window radius\n    P = [[990, 1010], [1990, 2005], [3000, 3010]]  # Peak set\n\n    cells_fragments = [\n        # Cell 1\n        [[995, 1005], [999, 1002], [1998, 2002], [2999, 3001], [4000, 4003]],\n        # Cell 2\n        [[985, 988], [1008, 1012], [1993, 1994], [2006, 2008], [3005, 3005]],\n        # Cell 3\n        []\n    ]\n\n    test_cases = [\n        (0.5, 2.0, 1),\n        (0.8, 24/11, 5),\n        (0.0, 0.0, 0),\n        (0.9, 3.0, 6),\n    ]\n    \n    def compute_metrics(fragments, tss_set, peak_set, window_radius):\n        \"\"\"\n        Computes N_frag, FRiP (F), and TSS Enrichment (E) for a single cell.\n        \"\"\"\n        N_frag = len(fragments)\n\n        # Handle the case of an empty cell\n        if N_frag == 0:\n            return (0, 0.0, 0.0)\n\n        # --- Compute Fraction of Reads in Peaks (FRiP) ---\n        N_in_peaks = 0\n        for s_frag, e_frag in fragments:\n            in_any_peak = False\n            for s_peak, e_peak in peak_set:\n                if max(s_frag, s_peak) = min(e_frag, e_peak):\n                    in_any_peak = True\n                    break\n            if in_any_peak:\n                N_in_peaks += 1\n        F = N_in_peaks / N_frag\n\n        # --- Compute TSS Enrichment (E) ---\n        C = {o: 0 for o in range(-window_radius, window_radius + 1)}\n        \n        # Calculate aggregated offset coverage C(o)\n        for g in tss_set:\n            for s_frag, e_frag in fragments:\n                # The offsets o relative to g covered by the fragment are in [s_frag - g, e_frag - g]\n                o_start = s_frag - g\n                o_end = e_frag - g\n                \n                # Iterate through offsets in the intersection of the covered range and the window [-W, W]\n                # to increment the aggregated coverage counts.\n                start_offset = max(-window_radius, o_start)\n                end_offset = min(window_radius, o_end)\n                for o in range(start_offset, end_offset + 1):\n                    C[o] += 1\n        \n        # Calculate mean coverages for center and background\n        s_center_offsets = [-1, 0, 1]\n        s_bg_offsets = list(range(-window_radius, -1)) + list(range(2, window_radius + 1))\n        \n        C_center_values = [C[o] for o in s_center_offsets]\n        C_bg_values = [C[o] for o in s_bg_offsets]\n        \n        mean_C_center = np.mean(C_center_values) if C_center_values else 0.0\n        mean_C_bg = np.mean(C_bg_values) if C_bg_values else 0.0\n        \n        # Apply definition of TSS enrichment E\n        if mean_C_bg > 0:\n            E = mean_C_center / mean_C_bg\n        elif mean_C_center > 0:\n            E = np.inf\n        else:  # mean_C_bg == 0 and mean_C_center == 0\n            E = 0.0\n            \n        return (N_frag, F, E)\n\n    # Calculate metrics for all cells once\n    cell_metrics = []\n    for frags in cells_fragments:\n        metrics = compute_metrics(frags, G, P, W)\n        cell_metrics.append(metrics)\n\n    # Evaluate each test case\n    final_results = []\n    for tau_F, tau_E, tau_n in test_cases:\n        passed_count = 0\n        for n_frag, f, e in cell_metrics:\n            if n_frag >= tau_n and f >= tau_F and e >= tau_E:\n                passed_count += 1\n        final_results.append(passed_count)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3330229"}, {"introduction": "整合CITE-seq和ATAC-seq的核心挑战之一在于它们测量的是不同实体：基因表达与染色质可及性。本练习通过让您从ATAC-seq数据计算“基因活性得分”来解决此问题，这是一种将可及性信息投射到以基因为中心的共享空间的关键技术。接着，您将评估这些得分与实际RNA表达的一致性，从而亲身体验共享特征空间是如何构建和验证的 ([@problem_id:3330201])。", "problem": "考虑一项任务：整合转座酶可及性染色质测序技术 (ATAC-seq) 的染色质可及性与细胞转录组和表位测序索引技术 (CITE-seq) 的信使核糖核酸 (mRNA) 表达，以在单细胞水平上评估其一致性。您将获得一个小的 peak-细胞可及性矩阵、peak 的基因组坐标、两个基因的转录起始位点 (TSS) 位置，以及一个以碱基对为单位的基因组窗口大小。假设以下基础：基因 TSS 附近的染色质可及性有助于其转录活性，且调控影响随与 TSS 的基因组距离的增加而根据指数核函数衰减。您必须通过聚合 TSS 周围对称窗口内 peak 的可及性信号来计算每个细胞的基因活性得分，使用指数核对其进行加权，然后计算每个基因的这些活性得分与跨细胞的 mRNA 表达之间的皮尔逊相关系数，以评估一致性。\n\n数据和参数：\n1. Peak 位于单个染色体上，并由以碱基对 (bp) 为单位的闭合区间表示。Peak 区间为：\n$$\nP_1 = [1000,1100],\\quad\nP_2 = [1500,1600],\\quad\nP_3 = [2000,2100],\\quad\nP_4 = [2600,2700],\\quad\nP_5 = [3000,3100].\n$$\n将 peak 中心 $c_p$ 定义为其区间的中点。\n\n2. peak-细胞可及性矩阵 $X \\in \\mathbb{R}^{5 \\times 4}$（行为 peak $P_1, \\dots, P_5$；列为细胞 $C_1,\\dots,C_4$）为：\n$$\nX = \\begin{bmatrix}\n2  0  1  0 \\\\\n3  1  0  0 \\\\\n0  2  2  0 \\\\\n0  1  0  3 \\\\\n1  0  3  2\n\\end{bmatrix}.\n$$\n\n3. 两个基因位于同一染色体上，其 TSS 位置（以 bp 为单位）为：\n$$\ng_A: t_A = 1550,\\quad g_B: t_B = 3050.\n$$\n\n4. 这两个基因在相同 $4$ 个细胞中的信使核糖核酸 (mRNA) 表达提供如下：\n$$\ny_A = [5,2,3,0], \\quad y_B = [0,1,0,2].\n$$\n\n5. 指数衰减核参数（长度尺度）指定为：\n$$\n\\tau = 500\\ \\text{bp}.\n$$\n\n基因活性计算：\n- 对于一个 TSS 为 $t_g$ 的基因 $g$，和一个对称窗口大小 $w$（以碱基对为单位），选择中心满足 $|c_p - t_g| \\le w$ 的 peak。如果没有选中任何 peak，则基因 $g$ 的活性得分向量为零向量。\n- 将距离为 $d_p = |c_p - t_g|$ 的选定 peak $p$ 的权重定义为：\n$$\nK(d_p) = \\exp\\left(-\\frac{d_p}{\\tau}\\right).\n$$\n- 基因 $g$ 在细胞 $i$ 中的基因活性得分为：\n$$\nA_{g,i}(w) = \\sum_{p:\\ |c_p - t_g| \\le w} X_{p,i}\\, K(|c_p - t_g|).\n$$\n\n一致性计算：\n- 设 $A_g(w) \\in \\mathbb{R}^4$ 为跨 $4$ 个细胞的活性得分， $y_g \\in \\mathbb{R}^4$ 为跨相同 $4$ 个细胞的 mRNA 表达。皮尔逊相关系数定义为：\n$$\nr_g(w) = \n\\begin{cases}\n0,  \\text{if}\\ \\sum_{i=1}^{4} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2 = 0\\ \\text{or}\\ \\sum_{i=1}^{4} \\left(y_{g,i} - \\bar{y}_g\\right)^2 = 0, \\\\\n\\displaystyle \\frac{\\sum_{i=1}^{4} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)\\left(y_{g,i} - \\bar{y}_g\\right)}{\\sqrt{\\sum_{i=1}^{4} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2}\\ \\sqrt{\\sum_{i=1}^{4} \\left(y_{g,i} - \\bar{y}_g\\right)^2}},  \\text{otherwise},\n\\end{cases}\n$$\n其中 $\\bar{A}_g(w)$ 和 $\\bar{y}_g$ 分别表示 $A_g(w)$ 和 $y_g$ 的均值。\n\n测试套件：\n- 使用以下窗口大小（以碱基对为单位）：\n$$\nw_1 = 600,\\quad w_2 = 0,\\quad w_3 = 400.\n$$\n对于每个 $w_j$，计算 $r_{g_A}(w_j)$ 和 $r_{g_B}(w_j)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，包含测试套件的 $6$ 个相关性结果，顺序如下：\n$$\n\\left[r_{g_A}(w_1), r_{g_B}(w_1), r_{g_A}(w_2), r_{g_B}(w_2), r_{g_A}(w_3), r_{g_B}(w_3)\\right],\n$$\n以逗号分隔的列表形式打印，并用方括号括起来，值为无单位（无量纲）的浮点数。", "solution": "我们从以下原理出发：在真核基因调控中，基因转录起始位点 (TSS) 附近的开放染色质区域（通过转座酶可及性染色质测序技术 (ATAC-seq) 测量的可及性 DNA）促进转录起始，并且其调控影响随与 TSS 的基因组距离的增加而减弱。为了对这种距离依赖性影响进行建模，我们采用了一个广泛使用的指数核，它反映了远端调控元件的贡献随距离衰减的特性。对于单细胞一致性评估，我们将源自染色质的基因活性得分与通过细胞转录组和表位测序索引技术 (CITE-seq) 测量的信使核糖核酸 (mRNA) 表达进行比较。\n\n定义与推导：\n1. Peak 表示与中心：每个染色质可及性 peak $p$ 是染色体上一个以碱基对 (bp) 为单位的区间 $[s_p, e_p]$。其中心为：\n$$\nc_p = \\frac{s_p + e_p}{2}.\n$$\n该中心为相对于基因 TSS 的距离计算提供了一致的标量表示。\n\n2. 基于窗口的选择：对于一个 TSS 位置为 $t_g$ 的基因 $g$ 和一个对称窗口大小 $w$（以 bp 为单位），我们选择中心满足以下条件的 peak：\n$$\n|c_p - t_g| \\le w.\n$$\n该条件在 TSS 周围施加了一个具有物理意义的局部性约束。包含关系被定义为包含边界，以确保在 $|c_p - t_g| = w$ 时的行为是明确定义的。\n\n3. 指数衰减核：调控影响随距离 $d_p = |c_p - t_g|$ 按以下公式衰减：\n$$\nK(d_p) = \\exp\\left(-\\frac{d_p}{\\tau}\\right),\n$$\n其中 $\\tau  0$ 是一个长度尺度参数（以 bp 为单位）。该核函数符合生物物理学的直觉，即可及区域的相互作用概率和功能效应大致随基因组距离呈指数下降。\n\n4. 基因活性聚合：给定 peak-细胞矩阵 $X \\in \\mathbb{R}^{m \\times n}$（此处 $m = 5, n = 4$），基因 $g$ 在细胞 $i$ 中对于窗口大小 $w$ 的基因活性得分为：\n$$\nA_{g,i}(w) = \\sum_{p:\\ |c_p - t_g| \\le w} X_{p,i}\\, \\exp\\left(-\\frac{|c_p - t_g|}{\\tau}\\right).\n$$\n如果选择集为空，我们定义 $A_g(w)$ 为 $\\mathbb{R}^n$ 中的零向量，反映了窗口内没有可及的调控证据。\n\n5. 通过皮尔逊相关性评估一致性：为了量化源自染色质的活性 $A_g(w)$ 与 mRNA 表达 $y_g$ 之间的线性一致性，皮尔逊相关系数为：\n$$\nr_g(w) = \n\\begin{cases}\n0,  \\text{if}\\ \\sum_{i=1}^{n} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2 = 0\\ \\text{or}\\ \\sum_{i=1}^{n} \\left(y_{g,i} - \\bar{y}_g\\right)^2 = 0, \\\\\n\\displaystyle \\frac{\\sum_{i=1}^{n} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)\\left(y_{g,i} - \\bar{y}_g\\right)}{\\sqrt{\\sum_{i=1}^{n} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2}\\ \\sqrt{\\sum_{i=1}^{n} \\left(y_{g,i} - \\bar{y}_g\\right)^2}},  \\text{otherwise},\n\\end{cases}\n$$\n在此设置中 $n=4$，其中 $\\bar{A}_g(w)$ 和 $\\bar{y}_g$ 表示跨细胞的均值。零值情况的保护措施处理了任一向量为常数的退化情景。\n\n与上述原理一致的算法步骤：\n- 根据给定的区间 $[s_p,e_p]$，使用 $c_p = (s_p + e_p)/2$ 计算 peak 中心 $c_p$。\n- 对每个基因 $g \\in \\{g_A,g_B\\}$ 和每个窗口大小 $w \\in \\{w_1, w_2, w_3\\}$，为中心满足 $|c_p - t_g| \\le w$ 的 peak 构建选择掩码。\n- 对选定的 peak，计算权重 $K(d_p) = \\exp(-d_p/\\tau)$，其中 $d_p = |c_p - t_g|$ 且 $\\tau = 500$。\n- 使用跨选定 peak 的加权和来聚合每个细胞的活性：\n$$\nA_{g,i}(w) = \\sum_{p} \\left(\\mathbf{1}\\{|c_p - t_g| \\le w\\}\\, X_{p,i}\\, K(|c_p - t_g|)\\right).\n$$\n- 根据上述皮尔逊相关公式计算 $r_g(w)$，包括处理标准差为零时的零值情况。\n- 按以下顺序生成最终结果的单个列表：\n$$\n\\left[r_{g_A}(w_1), r_{g_B}(w_1), r_{g_A}(w_2), r_{g_B}(w_2), r_{g_A}(w_3), r_{g_B}(w_3)\\right].\n$$\n\n此过程通过推导一个可解释的基因活性得分，该得分反映了受距离调控的局部染色质环境，从而将 ATAC-seq 可及性与 CITE-seq mRNA 表达的整合操作化，然后通过标准相关性度量来量化一致性。该测试套件涵盖了一个一般情况 ($w_1$)、一个捕获与 TSS 精确匹配的 peak 的边界情况 ($w_2$)，以及一个测试包含性窗口边界的边缘情况 ($w_3$)。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_peak_centers(starts, ends):\n    return (np.array(starts, dtype=float) + np.array(ends, dtype=float)) / 2.0\n\ndef exponential_kernel(distances, tau):\n    return np.exp(-np.abs(distances) / float(tau))\n\ndef compute_activity(X, centers, tss, window, tau):\n    distances = np.abs(centers - float(tss))\n    mask = distances = float(window)\n    if not np.any(mask):\n        # No peaks in window: return zero activity vector\n        return np.zeros(X.shape[1], dtype=float)\n    weights = exponential_kernel(distances[mask], tau)  # shape (k,)\n    X_sel = X[mask, :]  # shape (k, n_cells)\n    # Weighted sum across peaks -> activity per cell\n    activity = (weights[:, None] * X_sel).sum(axis=0)\n    return activity\n\ndef pearson_correlation(x, y):\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    # Center\n    x_dev = x - x.mean()\n    y_dev = y - y.mean()\n    ssx = np.dot(x_dev, x_dev)\n    ssy = np.dot(y_dev, y_dev)\n    if ssx == 0.0 or ssy == 0.0:\n        return 0.0\n    num = np.dot(x_dev, y_dev)\n    den = np.sqrt(ssx * ssy)\n    return float(num / den)\n\ndef solve():\n    # Define data from the problem statement.\n    # Peak intervals (bp)\n    starts = [1000, 1500, 2000, 2600, 3000]\n    ends   = [1100, 1600, 2100, 2700, 3100]\n    centers = compute_peak_centers(starts, ends)  # shape (5,)\n\n    # Peak-by-cell ATAC accessibility matrix X (5 peaks x 4 cells)\n    X = np.array([\n        [2, 0, 1, 0],\n        [3, 1, 0, 0],\n        [0, 2, 2, 0],\n        [0, 1, 0, 3],\n        [1, 0, 3, 2]\n    ], dtype=float)\n\n    # Gene TSS positions (bp)\n    tss_A = 1550\n    tss_B = 3050\n\n    # CITE-seq mRNA expression across 4 cells\n    y_A = np.array([5, 2, 3, 0], dtype=float)\n    y_B = np.array([0, 1, 0, 2], dtype=float)\n\n    # Exponential kernel length scale (bp)\n    tau = 500\n\n    # Test suite: window sizes (bp)\n    test_windows = [600, 0, 400]\n\n    results = []\n    for w in test_windows:\n        # Gene A\n        A_A = compute_activity(X, centers, tss_A, w, tau)\n        r_A = pearson_correlation(A_A, y_A)\n        results.append(r_A)\n        # Gene B\n        A_B = compute_activity(X, centers, tss_B, w, tau)\n        r_B = pearson_correlation(A_B, y_B)\n        results.append(r_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3330201"}, {"introduction": "当来自不同模态的数据被处理并表示在低维空间中后，最后一步是将它们整合成一个统一的细胞间相似性度量。本实践将引导您完成影响深远的加权最近邻（WNN）算法的核心逻辑。您将实现基于跨模态可预测性学习模态权重，并构建最终的加权邻域图的关键步骤，从而深入了解一种前沿的整合方法 ([@problem_id:3330226])。", "problem": "给定一组通过三种模态测量的单细胞共享的三个合成低维嵌入：信使核糖核酸（RNA）、来自CITE-seq（通过测序进行转录组和表位的细胞索引）的抗体衍生标签（ADT），以及来自ATAC-seq（使用测序的转座酶可及性染色质分析）的染色质可及性。设模态集合为 $\\mathcal{M} = \\{\\mathrm{RNA}, \\mathrm{ADT}, \\mathrm{ATAC}\\}$，细胞数量为 $N$，在所有模态中共享。对于每种模态 $m \\in \\mathcal{M}$，给定一个嵌入矩阵 $X^{(m)} \\in \\mathbb{R}^{N \\times d_m}$，其中第 $i$ 行存储细胞 $i$ 的嵌入。\n\n从基本定义出发，您将为焦点细胞 $c$ 和邻域大小 $k$ 实现以下流程：\n- 在每种模态中，使用嵌入空间中的欧几里得距离计算特定于模态的 $k$-最近邻，不包括焦点细胞。\n- 对于每种模态，通过从该源模态中选择的 $k$-最近邻的均值来预测焦点细胞在所有模态中的嵌入，从而计算焦点细胞的跨模态预测误差。\n- 通过逆误差归一化将预测误差转换为归一化权重，以获得总和为一的模态权重。\n- 使用模态权重组合特定于模态的相似性核，形成加权最近邻分数，该分数仅限于来自所有特定模态邻居集合的候选者并集。返回最终的加权最近邻索引列表。\n\n使用以下核心定义作为基础：\n- 向量 $u, v \\in \\mathbb{R}^{d}$ 之间的欧几里得距离是 $d(u,v) = \\lVert u - v \\rVert_2 = \\sqrt{\\sum_{j=1}^{d} (u_j - v_j)^2}$。\n- 对于一个焦点细胞 $c$ 和模态 $m \\in \\mathcal{M}$，令 $d_{c,i}^{(m)} = \\lVert X_c^{(m)} - X_i^{(m)} \\rVert_2$ 表示细胞 $c$ 和另一个细胞 $i$ 在模态 $m$ 中的距离。\n- $k$-最近邻集合 $N_c^{(m)}$ 由 $k$ 个具有最小 $d_{c,i}^{(m)}$ 值的索引 $i \\neq c$ 组成。距离的平局必须通过首先选择较低的细胞索引来解决。集合 $N_c^{(m)}$ 按距离升序排列（平局由索引升序解决）。\n- 对于每个源模态 $m \\in \\mathcal{M}$ 和每个目标模态 $t \\in \\mathcal{M}$，将焦点细胞在模态 $t$ 中的嵌入的邻居-均值预测器定义为\n$$\n\\widehat{X}_{c}^{(t \\mid m)} \\;=\\; \\frac{1}{k} \\sum_{i \\in N_c^{(m)}} X_i^{(t)}.\n$$\n- 将特定于模态的预测误差定义为所有模态中平方欧几里得误差的总和：\n$$\nE_c^{(m)} \\;=\\; \\sum_{t \\in \\mathcal{M}} \\left\\lVert X_c^{(t)} \\;-\\; \\widehat{X}_{c}^{(t \\mid m)} \\right\\rVert_2^2.\n$$\n- 通过带有小数数值稳定性常数 $\\varepsilon$ 的逆误差归一化将预测误差转换为正权重：\n$$\nw_c^{(m)} \\;=\\; \\frac{1}{E_c^{(m)} + \\varepsilon}, \\quad\n\\alpha_c^{(m)} \\;=\\; \\frac{w_c^{(m)}}{\\sum_{r \\in \\mathcal{M}} w_c^{(r)}}.\n$$\n- 对于每种模态 $m$，将焦点细胞 $c$ 和任何候选邻居 $i$ 之间的相似性核定义为\n$$\ns_{c,i}^{(m)} \\;=\\; \\exp\\!\\left( - \\frac{d_{c,i}^{(m)}}{\\sigma_c^{(m)}} \\right),\n$$\n其中 $\\sigma_c^{(m)}$ 是焦点细胞 $c$ 在模态 $m$ 中到第 $k$ 个最近邻的距离（即，$N_c^{(m)}$ 中 $k$ 个邻居中的最大距离）。如果 $\\sigma_c^{(m)} \\le \\varepsilon$，则使用 $\\sigma_c^{(m)} = \\varepsilon$ 以避免除以零。\n- 设候选集为特定于模态的邻居的并集：\n$$\nU_c \\;=\\; N_c^{(\\mathrm{RNA})} \\;\\cup\\; N_c^{(\\mathrm{ADT})} \\;\\cup\\; N_c^{(\\mathrm{ATAC})}.\n$$\n- 将候选 $i \\in U_c$ 的聚合加权相似性分数定义为\n$$\nS_{c,i} \\;=\\; \\sum_{m \\in \\mathcal{M}} \\alpha_c^{(m)} \\, s_{c,i}^{(m)}.\n$$\n- 最终的加权最近邻列表是来自 $U_c$ 的按 $S_{c,i}$ 降序排序的前 $k$ 个索引的列表；$S_{c,i}$ 的平局通过首先选择较低的索引来解决。\n\n您必须使用 $\\varepsilon = 10^{-8}$。所有浮点输出必须四舍五入到六位小数并以十进制表示。\n\n数据集。在所有模态中，共有 $N = 6$ 个共享细胞，其嵌入如下：\n- RNA嵌入 $X^{(\\mathrm{RNA})} \\in \\mathbb{R}^{6 \\times 3}$：\n  - 细胞 $0$: $(0.0, 0.0, 0.0)$\n  - 细胞 $1$: $(0.1, 0.0, 0.0)$\n  - 细胞 $2$: $(5.0, 0.0, 0.0)$\n  - 细胞 $3$: $(5.1, 0.1, 0.0)$\n  - 细胞 $4$: $(10.0, 0.0, 0.0)$\n  - 细胞 $5$: $(10.1, 0.1, 0.0)$\n- ADT嵌入 $X^{(\\mathrm{ADT})} \\in \\mathbb{R}^{6 \\times 2}$：\n  - 细胞 $0$: $(1.0, 1.0)$\n  - 细胞 $1$: $(1.1, 0.9)$\n  - 细胞 $2$: $(2.0, 2.0)$\n  - 细胞 $3$: $(2.1, 2.1)$\n  - 细胞 $4$: $(1.0, 1.0)$\n  - 细胞 $5$: $(5.0, 5.0)$\n- ATAC嵌入 $X^{(\\mathrm{ATAC})} \\in \\mathbb{R}^{6 \\times 4}$：\n  - 细胞 $0$: $(0.0, 0.0, 1.0, 0.0)$\n  - 细胞 $1$: $(0.0, 0.0, 0.9, 0.1)$\n  - 细胞 $2$: $(0.0, 1.0, 0.0, 0.0)$\n  - 细胞 $3$: $(0.0, 1.1, 0.0, 0.0)$\n  - 细胞 $4$: $(1.0, 0.0, 0.0, 0.0)$\n  - 细胞 $5$: $(1.1, 0.0, 0.0, 0.0)$\n\n测试套件。对于以下集合中的每个参数对 $(c,k)$，计算：\n- 特定于模态的邻居列表 $N_c^{(\\mathrm{RNA})}$, $N_c^{(\\mathrm{ADT})}$, $N_c^{(\\mathrm{ATAC})}$；\n- 预测误差 $E_c^{(\\mathrm{RNA})}$, $E_c^{(\\mathrm{ADT})}$, $E_c^{(\\mathrm{ATAC})}$；\n- 归一化权重 $\\alpha_c^{(\\mathrm{RNA})}$, $\\alpha_c^{(\\mathrm{ADT})}$, $\\alpha_c^{(\\mathrm{ATAC})}$；以及\n- 最终的加权最近邻列表（来自 $U_c$ 的按 $S_{c,i}$ 降序排序的前 $k$ 个索引，平局由索引升序解决）。\n\n使用测试用例：\n- $(c,k) = (2,2)$\n- $(c,k) = (2,3)$\n- $(c,k) = (3,3)$\n\n计算规则和约束：\n- 所有距离必须使用所定义的欧几里得距离。\n- 从所有邻居列表中排除焦点细胞 $c$。\n- 在 $k$-最近邻选择中，距离的平局必须通过细胞索引升序来解决。\n- 对于聚合加权相似性评分，$S_{c,i}$ 的平局必须通过细胞索引升序来解决。\n- 在指定处使用 $\\varepsilon = 10^{-8}$。\n- 将所有浮点输出四舍五入到六位小数，并以十进制表示（无百分比）。\n\n最终输出格式：\n- 对于每个测试用例 $(c,k)$，生成一个形式如下的列表\n$$\n[\\;N_c^{(\\mathrm{RNA})},\\; N_c^{(\\mathrm{ADT})},\\; N_c^{(\\mathrm{ATAC})},\\; [E_c^{(\\mathrm{RNA})}, E_c^{(\\mathrm{ADT})}, E_c^{(\\mathrm{ATAC})}],\\; [\\alpha_c^{(\\mathrm{RNA})}, \\alpha_c^{(\\mathrm{ADT})}, \\alpha_c^{(\\mathrm{ATAC})}],\\; \\mathrm{WNN}_c\\;],\n$$\n其中每个 $N_c^{(\\cdot)}$ 和 $\\mathrm{WNN}_c$ 是细胞索引的列表，误差和权重向量是四舍五入的十进制数列表。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}]$）。", "solution": "该问题提出了一个详细且自包含的使用加权最近邻（WNN）方法进行多模态单细胞数据整合的流程。提供的输入是一组 $N=6$ 个细胞的三个合成低维嵌入，对应于RNA、ADT（蛋白质）和ATAC（染色质可及性）模态。任务是为指定的焦点细胞和邻域大小计算特定模态的邻居、跨模态预测误差、归一化的模态权重，以及最终的整合最近邻列表。\n\n该问题的陈述经验证如下：\n- **科学基础**：该方法是WNN算法的一个简化但概念上正确的表示，WNN是计算系统生物学中用于整合多模态单细胞数据集的一种广为接受的技术。欧几里得距离、k-最近邻、跨模态预测和加权核求和的使用都是标准组成部分。\n- **良构性**：该问题在计算上是良构的。所有步骤都用数学精度进行了定义。关键的是，为k-最近邻选择（优先选择较小的细胞索引）和最终加权相似性得分排序（优先选择较小的细胞索引）都提供了明确的平局打破规则，确保了唯一解。引入数值稳定性常数 $\\varepsilon$ 避免了除以零。\n- **客观性和完整性**：问题以客观、正式的语言陈述。所有必要的数据，包括嵌入矩阵 $X^{(m)}$、参数（$c, k, \\varepsilon$）以及一套完整的程序定义，都已提供。问题是自包含且无歧义的。\n\n该问题被认为是有效的，因为它在科学上是合理的，在数学上是严谨的，并且是完全指定的。解决方案通过对三个测试用例中的每一个逐步实现所定义的流程来进行。\n\n让我们将模态集合表示为 $\\mathcal{M} = \\{\\mathrm{RNA}, \\mathrm{ADT}, \\mathrm{ATAC}\\}$。我们得到了嵌入矩阵 $X^{(\\mathrm{RNA})}$、 $X^{(\\mathrm{ADT})}$ 和 $X^{(\\mathrm{ATAC})}$。对于每个测试用例 $(c, k)$，执行以下步骤：\n\n**1. 模态特定的k-最近邻 ($N_c^{(m)}$)**\n对于每个模态 $m \\in \\mathcal{M}$，我们计算从焦点细胞 $c$ 到每个其他细胞 $i \\neq c$ 的欧几里得距离 $d_{c,i}^{(m)} = \\lVert X_c^{(m)} - X_i^{(m)} \\rVert_2$。然后，细胞按此距离升序排列。平局通过选择索引较小的细胞来打破。集合 $N_c^{(m)}$ 包含此排序列表中前 $k$ 个细胞的索引。我们还记录 $\\sigma_c^{(m)}$，即此列表中第 $k$ 个邻居的距离，它将被用作带宽参数。\n\n**2. 跨模态预测误差 ($E_c^{(m)}$)**\n对于每个源模态 $m$，我们使用其最近邻集合 $N_c^{(m)}$ 来预测焦点细胞在每个目标模态 $t \\in \\mathcal{M}$ 中的嵌入。预测值 $\\widehat{X}_{c}^{(t \\mid m)}$ 是目标模态 $t$ 中 $N_c^{(m)}$ 集合内细胞嵌入的算术平均值：\n$$\n\\widehat{X}_{c}^{(t \\mid m)} \\;=\\; \\frac{1}{k} \\sum_{i \\in N_c^{(m)}} X_i^{(t)}\n$$\n源模态 $m$ 的总预测误差，表示为 $E_c^{(m)}$，是真实嵌入 $X_c^{(t)}$ 与预测嵌入 $\\widehat{X}_{c}^{(t \\mid m)}$ 之间在所有目标模态上的平方欧几里得误差之和：\n$$\nE_c^{(m)} \\;=\\; \\sum_{t \\in \\mathcal{M}} \\left\\lVert X_c^{(t)} \\;-\\; \\widehat{X}_{c}^{(t \\mid m)} \\right\\rVert_2^2\n$$\n\n**3. 模态权重计算 ($\\alpha_c^{(m)}$)**\n预测误差 $\\{E_c^{(m)}\\}_{m \\in \\mathcal{M}}$ 被转换为与误差成反比的权重。给定源模态的误差越小，意味着其局部邻域结构对于预测该细胞在所有测量类型中的状态信息量越大。首先使用一个小的常数 $\\varepsilon = 10^{-8}$ 计算一个中间权重 $w_c^{(m)}$ 以保证数值稳定性：\n$$\nw_c^{(m)} \\;=\\; \\frac{1}{E_c^{(m)} + \\varepsilon}\n$$\n然后将这些权重归一化，使其总和为一，得到最终的模态权重 $\\alpha_c^{(m)}$：\n$$\n\\alpha_c^{(m)} \\;=\\; \\frac{w_c^{(m)}}{\\sum_{r \\in \\mathcal{M}} w_c^{(r)}}\n$$\n\n**4. 加权最近邻 (WNN) 整合**\n首先，通过取所有模态特定邻居集的并集来形成候选邻居集 $U_c$：$U_c = \\bigcup_{m \\in \\mathcal{M}} N_c^{(m)}$。\n\n对于每个模态 $m$，使用高斯核计算焦点细胞 $c$ 与每个候选邻居 $i \\in U_c$ 之间的相似性核 $s_{c,i}^{(m)}$。距离由 $\\sigma_c^{(m)}$ 缩放，$\\sigma_c^{(m)}$ 是该模态中到第 $k$ 个最近邻的距离，作为局部带宽：\n$$\ns_{c,i}^{(m)} \\;=\\; \\exp\\!\\left( - \\frac{d_{c,i}^{(m)}}{\\sigma_c^{(m)}} \\right)\n$$\n如果 $\\sigma_c^{(m)}$ 小于 $\\varepsilon$，则将其设置为 $\\varepsilon$。\n\n每个候选邻居 $i$ 的最终整合相似性分数 $S_{c,i}$是这些模态特定相似性核的加权和，使用权重 $\\alpha_c^{(m)}$：\n$$\nS_{c,i} \\;=\\; \\sum_{m \\in \\mathcal{M}} \\alpha_c^{(m)} \\, s_{c,i}^{(m)}\n$$\n$U_c$ 中的候选者根据其分数 $S_{c,i}$ 按降序排序。平局通过选择索引较小的细胞来解决。最终的WNN列表包含此排序列表中的前 $k$ 个索引。\n\n这些步骤针对每个提供的测试用例实施，所有浮点结果均按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the WNN pipeline for multimodal single-cell data integration based on the problem description.\n    \"\"\"\n    # Define the datasets as per the problem statement\n    X_rna = np.array([\n        [0.0, 0.0, 0.0],\n        [0.1, 0.0, 0.0],\n        [5.0, 0.0, 0.0],\n        [5.1, 0.1, 0.0],\n        [10.0, 0.0, 0.0],\n        [10.1, 0.1, 0.0],\n    ])\n\n    X_adt = np.array([\n        [1.0, 1.0],\n        [1.1, 0.9],\n        [2.0, 2.0],\n        [2.1, 2.1],\n        [1.0, 1.0],\n        [5.0, 5.0],\n    ])\n\n    X_atac = np.array([\n        [0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.9, 0.1],\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 1.1, 0.0, 0.0],\n        [1.0, 0.0, 0.0, 0.0],\n        [1.1, 0.0, 0.0, 0.0],\n    ])\n\n    modalities = {\n        'RNA': X_rna,\n        'ADT': X_adt,\n        'ATAC': X_atac,\n    }\n    \n    num_cells = X_rna.shape[0]\n    modality_keys = ['RNA', 'ADT', 'ATAC']\n    epsilon = 1e-8\n\n    test_cases = [\n        (2, 2),\n        (2, 3),\n        (3, 3),\n    ]\n\n    all_results = []\n\n    for c, k in test_cases:\n        focal_cell_idx = c\n        \n        # Step 1: Compute modality-specific k-nearest neighbors\n        nn_sets = {}\n        sigmas = {}\n        all_distances = {}\n\n        for m_key in modality_keys:\n            X_m = modalities[m_key]\n            focal_vec = X_m[focal_cell_idx]\n            \n            distances = []\n            for i in range(num_cells):\n                if i == focal_cell_idx:\n                    continue\n                dist = np.linalg.norm(focal_vec - X_m[i])\n                distances.append((dist, i))\n            \n            # Sort by distance, then by index for tie-breaking\n            distances.sort()\n            \n            nn_sets[m_key] = [i for dist, i in distances[:k]]\n            sigmas[m_key] = distances[k-1][0] if k > 0 else epsilon\n            \n            # Store all distances for later use\n            all_distances[m_key] = {i: dist for dist, i in distances}\n\n        # Step 2: Compute cross-modal prediction errors\n        errors = {}\n        for m_source_key in modality_keys:\n            total_error = 0.0\n            neighbor_indices = nn_sets[m_source_key]\n\n            for m_target_key in modality_keys:\n                X_target = modalities[m_target_key]\n                \n                # Calculate the mean embedding of neighbors\n                if k > 0:\n                    neighbor_embeddings = X_target[neighbor_indices]\n                    predicted_embedding = np.mean(neighbor_embeddings, axis=0)\n                else: \n                    predicted_embedding = np.zeros(X_target.shape[1])\n                \n                # Get the true embedding of the focal cell\n                true_embedding = X_target[focal_cell_idx]\n                \n                # Calculate squared Euclidean error\n                squared_error = np.sum((true_embedding - predicted_embedding)**2)\n                total_error += squared_error\n            \n            errors[m_source_key] = total_error\n\n        # Step 3: Convert prediction errors to normalized weights\n        raw_weights = {m_key: 1.0 / (errors[m_key] + epsilon) for m_key in modality_keys}\n        sum_raw_weights = sum(raw_weights.values())\n        \n        if sum_raw_weights > 0:\n            norm_weights = {m_key: w / sum_raw_weights for m_key, w in raw_weights.items()}\n        else: # Handle case of all zero weights (unlikely)\n            norm_weights = {m_key: 1.0/len(modality_keys) for m_key in modality_keys}\n\n        # Step 4: Form a weighted nearest neighbor score\n        candidate_set = set()\n        for m_key in modality_keys:\n            candidate_set.update(nn_sets[m_key])\n        \n        candidate_list = sorted(list(candidate_set))\n\n        weighted_scores = []\n        if k > 0:\n            for i in candidate_list:\n                total_score = 0.0\n                for m_key in modality_keys:\n                    # Retrieve the distance to candidate i\n                    dist_ci_m = np.linalg.norm(modalities[m_key][c] - modalities[m_key][i])\n                    \n                    sigma_m = max(sigmas[m_key], epsilon)\n                    \n                    # Similarity kernel\n                    s_cim = np.exp(-dist_ci_m / sigma_m)\n                    \n                    total_score += norm_weights[m_key] * s_cim\n                \n                # Store with negative score for descending sort\n                weighted_scores.append((-total_score, i))\n        \n        # Sort by score (desc), then index (asc)\n        weighted_scores.sort()\n        \n        wnn_list = [i for score, i in weighted_scores[:k]]\n\n        # Format results for output\n        result_Nc = [nn_sets[key] for key in modality_keys]\n        result_E = [round(errors[key], 6) for key in modality_keys]\n        result_alpha = [round(norm_weights[key], 6) for key in modality_keys]\n\n        # Use repr to get the exact list format like [1, 2]\n        formatted_result = (\n            f\"[{repr(result_Nc[0])}, {repr(result_Nc[1])}, {repr(result_Nc[2])}, \"\n            f\"[{result_E[0]:.6f}, {result_E[1]:.6f}, {result_E[2]:.6f}], \"\n            f\"[{result_alpha[0]:.6f}, {result_alpha[1]:.6f}, {result_alpha[2]:.6f}], \"\n            f\"{repr(wnn_list)}]\"\n        )\n        all_results.append(formatted_result)\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3330226"}]}