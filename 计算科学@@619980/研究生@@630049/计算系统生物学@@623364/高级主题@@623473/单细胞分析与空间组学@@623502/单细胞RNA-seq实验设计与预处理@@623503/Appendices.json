{"hands_on_practices": [{"introduction": "单细胞 RNA 测序数据的分析之旅始于原始测序读段。一个核心的初始步骤是将这些读段的比对位置转化为有意义的定量测量，即基因表达计数。本练习将引导您完成这一基本过程，特别是区分“剪接”和“未剪接”的 RNA 分子，这是 RNA 速度等前沿分析的基础。通过根据基因组注释（外显子和内含子）对读段进行分类，您将亲手构建计数矩阵，并执行初步的归一化，为理解基因表达的动态变化奠定基础 ([@problem_id:3348545])。", "problem": "您将获得一个简化的单细胞核糖核酸测序 (scRNA-seq) 预处理流程片段的形式化描述，用于在稳态模型下估计核糖核酸 (RNA) 速度。其基本依据是分子生物学的中心法则以及 scRNA-seq 预处理中广泛使用的计算计数约定：信使核糖核酸 (mRNA) 分子源于转录和加工；映射到已注释外显子内的读段被视为已剪接；映射到已注释内含子内（且不与外显子重叠）的读段被视为未剪接；而与这两类重叠的读段则被视为模糊不清并被排除。您将实现一个程序，对于每个测试用例，该程序会构建每个基因、每个细胞的剪接和未剪接计数矩阵，执行文库大小归一化，计算每个基因的基本稳态斜率，推导速度残差，并输出一个标量一致性得分，该得分定义为每个基因在所有细胞中的归一化剪接计数和未剪接计数之间的平均皮尔逊相关性。\n\n定义与任务：\n- 假设有一个由 $c \\in \\{1,\\dots,n_c\\}$ 索引的有限细胞集合，以及一个由 $g \\in \\{1,\\dots,n_g\\}$ 索引的有限基因集合。每个基因 $g$ 在一维基因组坐标轴上有一组外显子区间 $E_g = \\{[a_{g,k}, b_{g,k}]\\}_{k}$ 和一组内含子区间 $I_g = \\{[u_{g,m}, v_{g,m}]\\}_{m}$，坐标单位为碱基对（unit: base pairs）。每个细胞 $c$ 为每个基因提供一个读段比对的多重集，记为 $R_{c,g} = \\{[\\ell_{c,g,i}, r_{c,g,i}]\\}_i$。\n- 对于读段区间 $[\\ell, r]$ 和基因 $g$ 的分类规则：\n  - 如果存在一个外显子区间 $[a,b] \\in E_g$ 使得 $\\ell \\ge a$ 且 $r \\le b$，并且不存在任何内含子区间 $[u,v] \\in I_g$ 与 $[\\ell,r]$ 有非空交集，则它贡献一个剪接计数。\n  - 如果存在一个内含子区间 $[u,v] \\in I_g$ 使得 $\\ell \\ge u$ 且 $r \\le v$，并且不存在任何外显子区间 $[a,b] \\in E_g$ 与 $[\\ell,r]$ 有非空交集，则它贡献一个未剪接计数。\n  - 否则（包括任何跨类别的重叠），它就是模糊的，贡献为零。\n- 构建整数计数矩阵 $S \\in \\mathbb{N}_0^{n_g \\times n_c}$ 和 $U \\in \\mathbb{N}_0^{n_g \\times n_c}$，其中 $S_{g,c}$ 和 $U_{g,c}$ 分别是基因 $g$ 在细胞 $c$ 中的剪接和未剪接计数。\n- 执行文库大小归一化，目标值为 $T = 1$（无单位）：对于每个细胞 $c$，计算总数 $T_c = \\sum_{g=1}^{n_g} \\left(S_{g,c} + U_{g,c}\\right)$。定义大小因子 $s_c$ 为 $s_c = T_c$（如果 $T_c > 0$）和 $s_c = 1$（如果 $T_c = 0$）。定义归一化计数为 $S'_{g,c} = S_{g,c} / s_c$ 和 $U'_{g,c} = U_{g,c} / s_c$。\n- 对于每个基因 $g$，使用约束通过原点的最小二乘法估计稳态斜率参数 $\\omega_g$，即\n$$\n\\omega_g = \n\\begin{cases}\n\\displaystyle \\frac{\\sum_{c=1}^{n_c} U'_{g,c} \\, S'_{g,c}}{\\sum_{c=1}^{n_c} \\left(U'_{g,c}\\right)^2}, & \\text{if } \\sum_{c=1}^{n_c} \\left(U'_{g,c}\\right)^2 > 0,\\\\[1.2ex]\n1, & \\text{otherwise}.\n\\end{cases}\n$$\n- 定义速度残差 $V_{g,c}$ 为 $V_{g,c} = S'_{g,c} - \\omega_g \\, U'_{g,c}$。\n- 将一个测试用例的基本一致性得分定义为，对于每个基因 $g$，$S'_{g,\\cdot}$ 和 $U'_{g,\\cdot}$ 在所有细胞间的皮尔逊相关性的平均值，并约定如果任一向量的经验方差为零（即所有条目相等），则其对每个基因的贡献为 $0$。形式上，对于每个基因 $g$，计算\n$$\nr_g = \n\\begin{cases}\n\\text{Pearson}\\left(\\left(S'_{g,1},\\dots,S'_{g,n_c}\\right), \\left(U'_{g,1},\\dots,U'_{g,n_c}\\right)\\right), & \\text{if } \\operatorname{Var}\\left(S'_{g,\\cdot}\\right) > 0 \\text{ and } \\operatorname{Var}\\left(U'_{g,\\cdot}\\right) > 0,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n一致性得分为 $\\displaystyle \\frac{1}{n_g} \\sum_{g=1}^{n_g} r_g$。该得分无单位，必须报告为实数。\n- 角度单位不适用。输出无需物理单位。\n\n测试套件：\n对于所有测试，有两个基因 $n_g = 2$，记为 $g=1$ 和 $g=2$，其注释如下：\n- 基因 $g=1$：外显子区间 $E_1 = \\{[100,120],[180,200]\\}$ 和内含子区间 $I_1 = \\{[121,179]\\}$。\n- 基因 $g=2$：外显子区间 $E_2 = \\{[300,320]\\}$ 和内含子区间 $I_2 = \\{[321,360]\\}$。\n\n每个测试用例指定了 $n_c$ 个细胞，以及每个细胞 $c$ 和基因 $g$ 的读段区间列表 $R_{c,g}$：\n\n- 测试用例 1 (正常路径, $n_c = 3$):\n  - 细胞 1:\n    - $R_{1,1} = \\{[100,105],[182,185],[125,128],[119,122]\\}$,\n    - $R_{1,2} = \\{[305,310],[325,330],[319,322]\\}$.\n  - 细胞 2:\n    - $R_{2,1} = \\{[183,187],[186,190],[126,128]\\}$,\n    - $R_{2,2} = \\{[306,309],[308,312],[330,335],[331,333]\\}$.\n  - 细胞 3:\n    - $R_{3,1} = \\{[110,115],[190,195],[192,196],[127,129]\\}$,\n    - $R_{3,2} = \\{[307,308]\\}$.\n\n- 测试用例 2 (边界情况，含一个空细胞, $n_c = 2$):\n  - 细胞 1:\n    - $R_{1,1} = \\{[119,122]\\}$,\n    - $R_{1,2} = \\{[305,310],[306,311],[331,334]\\}$.\n  - 细胞 2:\n    - $R_{2,1} = \\{\\}$,\n    - $R_{2,2} = \\{\\}$.\n\n- 测试用例 3 (所有读段均为模糊, $n_c = 2$):\n  - 细胞 1:\n    - $R_{1,1} = \\{[119,122]\\}$,\n    - $R_{1,2} = \\{[319,322]\\}$.\n  - 细胞 2:\n    - $R_{2,1} = \\{[119,122]\\}$,\n    - $R_{2,2} = \\{[319,322]\\}$.\n\n- 测试用例 4 (每个基因在细胞间完全成比例, $n_c = 2$):\n  - 细胞 1:\n    - $R_{1,1} = \\{[100,102],[110,112],[125,127]\\}$,\n    - $R_{1,2} = \\{[305,307],[308,310],[311,312],[330,332]\\}$.\n  - 细胞 2:\n    - $R_{2,1} = \\{[180,182],[183,184],[110,111],[115,116],[125,126],[170,171]\\}$,\n    - $R_{2,2} = \\{[300,301],[302,303],[304,305],[306,307],[308,309],[310,311],[321,322],[323,324]\\}$.\n\n您的程序必须：\n- 完全按照规定实现计数、归一化、斜率估计、残差计算和一致性得分计算。\n- 生成单行输出，其中包含四个测试用例的一致性得分，格式为方括号内的逗号分隔列表，并四舍五入到六位小数，按测试用例 1 到 4 的顺序排列。例如，格式必须为 `[x_1,x_2,x_3,x_4]`，其中每个 $x_i$ 是小数点后有六位数字的实数。", "solution": "用户提供了一个问题，要求实现一个简化的单细胞RNA测序(scRNA-seq)预处理和RNA速度估计流程。首先必须确定问题的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **索引：** 细胞 $c \\in \\{1,\\dots,n_c\\}$；基因 $g \\in \\{1,\\dots,n_g\\}$。\n- **基因注释：** 对于每个基因 $g$，有外显子区间 $E_g = \\{[a_{g,k}, b_{g,k}]\\}_{k}$ 和内含子区间 $I_g = \\{[u_{g,m}, v_{g,m}]\\}_{m}$。\n- **读段数据：** 对于每个细胞-基因对 $(c,g)$，有一个读段比对区间的多重集 $R_{c,g} = \\{[\\ell_{c,g,i}, r_{c,g,i}]\\}_i$。\n- **读段分类规则：** 对于读段 $[\\ell, r]$ 和基因 $g$：\n    - **剪接计数：** $1$ 如果 $(\\exists [a,b] \\in E_g: \\ell \\ge a \\land r \\le b) \\land (\\neg\\exists [u,v] \\in I_g: [\\ell,r] \\cap [u,v] \\ne \\emptyset)$。\n    - **未剪接计数：** $1$ 如果 $(\\exists [u,v] \\in I_g: \\ell \\ge u \\land r \\le v) \\land (\\neg\\exists [a,b] \\in E_g: [\\ell,r] \\cap [a,b] \\ne \\emptyset)$。\n    - **模糊：** $0$ 否则。\n- **计数矩阵：** $S \\in \\mathbb{N}_0^{n_g \\times n_c}$ (剪接的) 和 $U \\in \\mathbb{N}_0^{n_g \\times n_c}$ (未剪接的)。\n- **归一化：** 目标大小 $T=1$。细胞总数 $T_c = \\sum_{g} (S_{g,c} + U_{g,c})$。大小因子 $s_c = T_c$ 如果 $T_c > 0$，$s_c = 1$ 如果 $T_c = 0$。归一化计数为 $S'_{g,c} = S_{g,c} / s_c$ 和 $U'_{g,c} = U_{g,c} / s_c$。\n- **斜率估计：** 对于每个基因 $g$，$\\omega_g = (\\sum_{c} U'_{g,c} S'_{g,c}) / (\\sum_{c} (U'_{g,c})^2)$ 如果 $\\sum_{c} (U'_{g,c})^2 > 0$，否则 $\\omega_g = 1$。\n- **速度残差：** $V_{g,c} = S'_{g,c} - \\omega_g U'_{g,c}$。\n- **一致性得分：** 对于每个基因 $g$，计算皮尔逊相关性 $r_g = \\text{Pearson}(S'_{g,\\cdot}, U'_{g,\\cdot})$。如果 $\\operatorname{Var}(S'_{g,\\cdot}) = 0$ 或 $\\operatorname{Var}(U'_{g,\\cdot}) = 0$，则 $r_g=0$。最终得分是这些值的平均值：$\\frac{1}{n_g} \\sum_{g=1}^{n_g} r_g$。\n- **测试套件的基因注释：**\n    - 基因 $g=1$：$E_1 = \\{[100,120],[180,200]\\}$，$I_1 = \\{[121,179]\\}$。\n    - 基因 $g=2$：$E_2 = \\{[300,320]\\}$，$I_2 = \\{[321,360]\\}$。\n- **四个测试用例：** 为 $n_c \\in \\{2,3\\}$ 和 $n_g=2$ 提供了特定的读段数据 $R_{c,g}$。\n- **输出格式：** 四个得分的逗号分隔列表，`[x_1,x_2,x_3,x_4]`，每个得分四舍五入到六位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学依据：** 该问题是系统生物学中分析scRNA-seq数据（特别是RNA速度）的一个常见计算工作流程的简化但正确的表示。剪接/未剪接读段、文库大小归一化和稳态动力学建模等概念都是该领域的标准。该问题牢固地建立在公认的科学和计算原理之上。\n- **问题定义良好：** 所有术语都经过了精确的数学定义。读段分类规则明确。边缘情况，例如总读段为零的细胞（$T_c=0$）、斜率计算中分母为零以及相关性计算中方差为零的向量，都通过特定约定明确处理。该问题被构建为一个确定性算法，保证了唯一解。\n- **客观性：** 问题完全用客观、形式化的语言表述。没有主观或基于意见的成分。\n\n问题陈述没有违反任何无效性标准。它在科学上是合理的，形式上是明确的，自成体系的，并且是可计算解决的。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。将提供解决方案。\n\n### 解决方案\n\n该问题要求实现一个计算流程，处理简化的单细胞RNA测序数据以得出一个一致性得分。该流程包括四个主要阶段：读段计数、数据归一化、参数估计和相关性分析。我们将按定义系统地实现每个阶段。\n\n所建模的基本关系是新转录的、未剪接的 pre-mRNA 转化为成熟的、剪接的 mRNA 的过程。在稳态模型中，剪接的 mRNA（$S'$）的丰度被假定与未剪接的 mRNA（$U'$）的丰度成正比，比例常数代表降解速率与剪接速率之比。该流程旨在评估这种关系。\n\n**1. 读段分类和计数**\n\n对于与基因 $g$ 相关的每个读段区间 $[\\ell, r]$，我们必须将其分类为剪接的、未剪接的或模糊的。区间交集测试是必要的：两个区间 $[\\ell_1, r_1]$ 和 $[\\ell_2, r_2]$ 有非空交集的充要条件是 $\\max(\\ell_1, \\ell_2) \\le \\min(r_1, r_2)$。\n\n- 如果一个读段完全包含在基因的某个外显子区间内，并且不与其任何内含子区间相交，则该读段是**剪接的**。\n- 如果一个读段完全包含在基因的某个内含子区间内，并且不与其任何外显子区间相交，则该读段是**未剪接的**。\n- 否则，该读段是**模糊的**并被丢弃。\n\n通过将此逻辑应用于每个细胞 $c$ 和基因 $g$ 的所有读段，我们构建了维度为 $n_g \\times n_c$ 的整数计数矩阵 $S$ 和 $U$。\n\n**2. 文库大小归一化**\n\n单细胞实验通常在不同细胞间显示出显著的测序深度（文库大小）差异。为了使计数具有可比性，我们执行文库大小归一化。对于每个细胞 $c$，计算读段总数 $T_c = \\sum_{g=1}^{n_g} (S_{g,c} + U_{g,c})$。大小因子定义为：当 $T_c > 0$ 时 $s_c = T_c$；对于空细胞（$T_c = 0$）则为 $s_c = 1$，以防止除以零。然后将原始计数除以此大小因子，以生成归一化矩阵 $S'_{g,c} = S_{g,c} / s_c$ 和 $U'_{g,c} = U_{g,c} / s_c$。\n\n**3. 稳态斜率和残差估计**\n\n对于每个基因 $g$，稳态模型假设在所有细胞 $c$ 中存在线性关系 $S'_{g,c} \\approx \\omega_g U'_{g,c}$。斜率参数 $\\omega_g$ 是通过对经过原点的回归进行普通最小二乘法来估计的。所提供的公式是标准解：\n$$\n\\omega_g = \\frac{\\sum_{c=1}^{n_c} U'_{g,c} \\, S'_{g,c}}{\\sum_{c=1}^{n_c} \\left(U'_{g,c}\\right)^2}\n$$\n分母为零（即所有 $U'_{g,c}$ 均为零）的情况通过设置 $\\omega_g=1$ 来处理。随后，计算 RNA 速度残差为 $V_{g,c} = S'_{g,c} - \\omega_g U'_{g,c}$。这些残差代表了与稳态期望的偏差。尽管进行了计算，但它们不用于最终得分。\n\n**4. 一致性得分计算**\n\n最终输出是一个单一的一致性得分，它衡量了数据在所有基因上与稳态假设的拟合程度。对于每个基因 $g$，我们计算归一化剪接计数向量 $(S'_{g,1}, \\dots, S'_{g,n_c})$ 和未剪接计数向量 $(U'_{g,1}, \\dots, U'_{g,n_c})$ 之间的皮尔逊相关系数 $r_g$。皮尔逊相关性 $r(X, Y)$ 由下式给出：\n$$\nr(X, Y) = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^n (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^n (y_i - \\bar{y})^2}}\n$$\n根据问题规范，如果任一向量的经验方差为零（即向量的所有元素都相同），则相关性 $r_g$ 取为 $0$。总体一致性得分是每个基因相关性的算术平均值：$\\text{得分} = \\frac{1}{n_g} \\sum_{g=1}^{n_g} r_g$。\n\n**示例演练：测试用例 1**\n\n让我们将此过程应用于测试用例 1，该用例有 $n_c=3$ 个细胞和 $n_g=2$ 个基因。\n- **基因注释**：$E_1 = \\{[100,120],[180,200]\\}$，$I_1 = \\{[121,179]\\}$。$E_2 = \\{[300,320]\\}$，$I_2 = \\{[321,360]\\}$。\n- **计数**：根据分类规则处理所有读段，得到以下原始计数矩阵：\n$$\nS = \\begin{pmatrix} 2 & 2 & 3 \\\\ 1 & 2 & 1 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 2 & 0 \\end{pmatrix}\n$$\n- **归一化**：\n  - 细胞 1：$T_1 = 2+1+1+1=5 \\implies s_1=5$。\n  - 细胞 2：$T_2 = 2+1+2+2=7 \\implies s_2=7$。\n  - 细胞 3：$T_3 = 3+1+1+0=5 \\implies s_3=5$。\n  归一化矩阵为：\n$$\nS' = \\begin{pmatrix} 2/5 & 2/7 & 3/5 \\\\ 1/5 & 2/7 & 1/5 \\end{pmatrix} \\approx \\begin{pmatrix} 0.4000 & 0.2857 & 0.6000 \\\\ 0.2000 & 0.2857 & 0.2000 \\end{pmatrix}\n$$\n$$\nU' = \\begin{pmatrix} 1/5 & 1/7 & 1/5 \\\\ 1/5 & 2/7 & 0/5 \\end{pmatrix} \\approx \\begin{pmatrix} 0.2000 & 0.1429 & 0.2000 \\\\ 0.2000 & 0.2857 & 0.0000 \\end{pmatrix}\n$$\n- **一致性得分**：\n  - **基因 1**：用于相关性计算的向量是 $S'_{1,\\cdot} = (2/5, 2/7, 3/5)$ 和 $U'_{1,\\cdot} = (1/5, 1/7, 1/5)$。两者都具有非零方差。皮尔逊相关性为 $r_1 \\approx 0.710443$。\n  - **基因 2**：向量是 $S'_{2,\\cdot} = (1/5, 2/7, 1/5)$ 和 $U'_{2,\\cdot} = (1/5, 2/7, 0)$。两者都具有非零方差。皮尔逊相关性为 $r_2 \\approx 0.464758$。\n  - **最终得分**：得分为平均值：$(r_1 + r_2) / 2 \\approx (0.710443 + 0.464758) / 2 \\approx 0.587601$。\n\n对所有测试用例重复此过程以生成最终输出。实现将使用数值库来稳健地计算方差和相关性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a simplified scRNA-seq preprocessing pipeline to estimate a consistency score.\n    \"\"\"\n    \n    # Static gene annotations for all test cases\n    gene_annotations = {\n        # Gene 1 (index 0)\n        0: {'exons': [[100, 120], [180, 200]], 'introns': [[121, 179]]},\n        # Gene 2 (index 1)\n        1: {'exons': [[300, 320]], 'introns': [[321, 360]]},\n    }\n    n_g = 2\n\n    test_cases = [\n        # Test case 1 (happy path, n_c = 3)\n        {\n            'n_c': 3,\n            'reads': [\n                # Cell 1\n                [\n                    [[100,105],[182,185],[125,128],[119,122]], # Gene 1\n                    [[305,310],[325,330],[319,322]],          # Gene 2\n                ],\n                # Cell 2\n                [\n                    [[183,187],[186,190],[126,128]],          # Gene 1\n                    [[306,309],[308,312],[330,335],[331,333]], # Gene 2\n                ],\n                # Cell 3\n                [\n                    [[110,115],[190,195],[192,196],[127,129]], # Gene 1\n                    [[307,308]],                              # Gene 2\n                ],\n            ]\n        },\n        # Test case 2 (boundary with an empty cell, n_c = 2)\n        {\n            'n_c': 2,\n            'reads': [\n                # Cell 1\n                [\n                    [[119,122]],                             # Gene 1\n                    [[305,310],[306,311],[331,334]],         # Gene 2\n                ],\n                # Cell 2\n                [\n                    [],                                      # Gene 1\n                    [],                                      # Gene 2\n                ],\n            ]\n        },\n        # Test case 3 (all ambiguous reads, n_c = 2)\n        {\n            'n_c': 2,\n            'reads': [\n                # Cell 1\n                [\n                    [[119,122]],                             # Gene 1\n                    [[319,322]],                             # Gene 2\n                ],\n                # Cell 2\n                [\n                    [[119,122]],                             # Gene 1\n                    [[319,322]],                             # Gene 2\n                ],\n            ]\n        },\n        # Test case 4 (perfect proportionality, n_c = 2)\n        {\n            'n_c': 2,\n            'reads': [\n                # Cell 1\n                [\n                    [[100,102],[110,112],[125,127]],          # Gene 1\n                    [[305,307],[308,310],[311,312],[330,332]], # Gene 2\n                ],\n                # Cell 2\n                [\n                    [[180,182],[183,184],[110,111],[115,116],[125,126],[170,171]], # Gene 1\n                    [[300,301],[302,303],[304,305],[306,307],[308,309],[310,311],[321,322],[323,324]], # Gene 2\n                ],\n            ]\n        },\n    ]\n\n    def classify_read(read, exons, introns):\n        \"\"\"Classifies a read as 'spliced', 'unspliced', or 'ambiguous'.\"\"\"\n        \n        def intersects(read_interval, other_interval):\n            return max(read_interval[0], other_interval[0]) = min(read_interval[1], other_interval[1])\n\n        def is_contained(read_interval, other_interval):\n            return read_interval[0] >= other_interval[0] and read_interval[1] = other_interval[1]\n\n        is_in_exon = any(is_contained(read, exon) for exon in exons)\n        is_in_intron = any(is_contained(read, intron) for intron in introns)\n        \n        intersects_exon = any(intersects(read, exon) for exon in exons)\n        intersects_intron = any(intersects(read, intron) for intron in introns)\n\n        if is_in_exon and not intersects_intron:\n            return 'spliced'\n        if is_in_intron and not intersects_exon:\n            return 'unspliced'\n        return 'ambiguous'\n\n    results = []\n    \n    for case in test_cases:\n        n_c = case['n_c']\n        reads_data = case['reads']\n        \n        S = np.zeros((n_g, n_c), dtype=np.int64)\n        U = np.zeros((n_g, n_c), dtype=np.int64)\n\n        # 1. Read Classification and Counting\n        for c in range(n_c):\n            for g in range(n_g):\n                spliced_count = 0\n                unspliced_count = 0\n                ann = gene_annotations[g]\n                for read in reads_data[c][g]:\n                    classification = classify_read(read, ann['exons'], ann['introns'])\n                    if classification == 'spliced':\n                        spliced_count += 1\n                    elif classification == 'unspliced':\n                        unspliced_count += 1\n                S[g, c] = spliced_count\n                U[g, c] = unspliced_count\n\n        # 2. Library-Size Normalization\n        T_c = np.sum(S, axis=0) + np.sum(U, axis=0)\n        s_c = np.where(T_c > 0, T_c, 1.0)\n        \n        S_prime = S / s_c\n        U_prime = U / s_c\n\n        # 3. Slope and Residual Estimation\n        omega = np.ones(n_g)\n        V = np.zeros((n_g, n_c))\n        for g in range(n_g):\n            u_prime_g = U_prime[g, :]\n            s_prime_g = S_prime[g, :]\n            \n            sum_u_sq = np.sum(u_prime_g**2)\n            if sum_u_sq > 0:\n                omega[g] = np.sum(u_prime_g * s_prime_g) / sum_u_sq\n            # else omega[g] remains 1\n            \n            V[g, :] = s_prime_g - omega[g] * u_prime_g\n\n        # 4. Consistency Score Calculation\n        gene_correlations = []\n        for g in range(n_g):\n            s_vec = S_prime[g, :]\n            u_vec = U_prime[g, :]\n            \n            # Use population variance (ddof=0) as it is the empirical variance.\n            var_s = np.var(s_vec, ddof=0)\n            var_u = np.var(u_vec, ddof=0)\n            \n            if var_s > 1e-12 and var_u > 1e-12: # Check variance is non-zero with a tolerance\n                # np.corrcoef returns a matrix, we need the off-diagonal element\n                corr = np.corrcoef(s_vec, u_vec)[0, 1]\n                gene_correlations.append(corr)\n            else:\n                gene_correlations.append(0.0)\n\n        consistency_score = np.mean(gene_correlations)\n        results.append(consistency_score)\n\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3348545"}, {"introduction": "获得原始计数矩阵后，下一步的关键是识别并校正技术噪声。本练习聚焦于一种在基于液滴的单细胞测序中常见的技术伪影：环境 RNA 污染，即悬浮液中的无细胞转录本被错误捕获，从而掩盖了真实的细胞表达谱。您将实现一个去污染模型，学习如何根据每个细胞的污染比例和环境 RNA 的基因组成来估算并移除这部分噪声，并通过评估校正后标记基因特异性的提升来验证去污效果，从而将计算校正与更清晰的生物学信号直接联系起来 ([@problem_id:3348555])。", "problem": "在单细胞 RNA 测序 (scRNA-seq) 的场景中，每个细胞中每个基因的观测唯一分子标识符 (UMI) 计数会受到环境 RNA 污染的影响。一个普遍接受的生成模型观点是，观测计数来自于对细胞内源表达谱和环境表达谱混合体的采样。假设有 $n$ 个细胞和 $G$ 个基因。对于每个细胞 $i \\in \\{1,\\dots,n\\}$ 和基因 $g \\in \\{1,\\dots,G\\}$，将观测计数定义为 $N_{ig} \\in \\mathbb{N}_0$。设 $\\mathbf{a} \\in \\mathbb{R}_{\\ge 0}^{G}$ 为一个非负的环境表达谱，代表了环境分子的分布；并设 $c_i \\in [0,1]$ 表示细胞 $i$ 的污染分数，代表了归因于环境污染的计数的期望比例。环境表达谱必须满足 $\\sum_{g=1}^{G} a_g = 1$；如果不满足，则应进行归一化。\n\n基本原理。在采用唯一分子标识符 (UMI) 计数的 scRNA-seq 中，一个经过充分检验的模型将计数视为采样产生，其中细胞 $i$ 的期望观测计数向量是其内源表达谱和环境表达谱的凸混合。具体来说，如果 $T_i = \\sum_{g=1}^{G} N_{ig}$ 表示细胞 $i$ 中的总观测计数，那么细胞 $i$ 中每个基因的期望环境归因计数与 $c_i T_i$ 成正比，并根据 $\\mathbf{a}$ 分布在各个基因上，这反映了环境污染会按照环境分布增加计数这一事实。真实的、去污染后的计数应该移除环境归因部分，同时要遵守计数的非负性。\n\n标记基因特异性。假设每个细胞 $i$ 都被赋予一个来自有限细胞类型集合 $\\mathcal{Y}$ 的标签 $y_i$，并且对于每种类型 $y \\in \\mathcal{Y}$，都有一个标记基因集 $\\mathcal{S}(y) \\subseteq \\{1,\\dots,G\\}$。在计数矩阵 $\\mathbf{X} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$ 下，细胞 $i$ 的标记基因特异性定义为其总计数中落在 $\\mathcal{S}(y_i)$ 内的比例：\n$$\ns_i(\\mathbf{X}) \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{g \\in \\mathcal{S}(y_i)} X_{ig}}{\\sum_{g=1}^{G} X_{ig}}  \\text{if } \\sum_{g=1}^{G} X_{ig} > 0, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n为了评估去污染对标记基因特异性的影响，需要比较去污染前后所有细胞的平均特异性，即计算\n$$\n\\Delta \\;=\\; \\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D}) \\;-\\; \\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N}),\n$$\n其中 $\\mathbf{N}$ 是观测计数，$\\mathbf{D}$ 是去污染后的计数。\n\n任务。从上述基本混合模型观点出发，设计并实现一个程序，该程序能够：\n- 基于 $\\mathbf{a}$、$c_i$ 和 $T_i$ 推导出一个非负的去污染算子，该算子移除每个细胞中每个基因的期望环境归因计数，从而得到一个去污染后的计数矩阵 $\\mathbf{D}$。\n- 为每个测试用例计算 $\\mathbf{N}$ 和 $\\mathbf{D}$ 之间的平均标记基因特异性提升值 $\\Delta$。\n\n您的算法必须满足以下约束：\n- 如果环境表达谱 $\\mathbf{a}$ 的总和不为 $1$，则必须将其归一化。\n- 每个基因的去污染后计数必须为非负；如果减法操作导致负值，必须将其截断为 $0$。\n- 如果一个细胞的去污染后总计数为 $0$，其特异性必须定义为 $0$。\n- 如果一个细胞类型的标记基因集为空，则该细胞的特异性贡献为 $0$。\n\n测试集。为以下参数集实现您的解决方案。每个测试用例都指定了观测计数矩阵 $\\mathbf{N}^{(k)}$、环境表达谱 $\\mathbf{a}^{(k)}$、各细胞污染分数 $\\mathbf{c}^{(k)}$、细胞标签 $\\mathbf{y}^{(k)}$ 和标记基因集 $\\mathcal{S}^{(k)}$。标记基因集中的基因索引均为从 0 开始。\n\n测试用例 1（正常路径，中度污染）：\n- $n = 3$, $G = 5$,\n- $\\mathbf{N}^{(1)} = \\begin{bmatrix}\n12  8  1  3  0 \\\\\n2  4  15  0  1 \\\\\n0  1  0  20  5\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(1)} = \\begin{bmatrix} 0.25  0.25  0.2  0.2  0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(1)} = \\begin{bmatrix} 0.2  0.3  0.15 \\end{bmatrix}$,\n- $\\mathbf{y}^{(1)} = \\begin{bmatrix} \\text{A}  \\text{B}  \\text{C} \\end{bmatrix}$,\n- $\\mathcal{S}^{(1)}(\\text{A}) = \\{0,1\\}$, $\\mathcal{S}^{(1)}(\\text{B}) = \\{2\\}$, $\\mathcal{S}^{(1)}(\\text{C}) = \\{3\\}$.\n\n测试用例 2（边界条件，零污染）：\n- $n = 2$, $G = 4$,\n- $\\mathbf{N}^{(2)} = \\begin{bmatrix}\n5  0  0  5 \\\\\n0  10  0  0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(2)} = \\begin{bmatrix} 0.4  0.1  0.4  0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(2)} = \\begin{bmatrix} 0  0 \\end{bmatrix}$,\n- $\\mathbf{y}^{(2)} = \\begin{bmatrix} \\text{C}  \\text{A} \\end{bmatrix}$,\n- $\\mathcal{S}^{(2)}(\\text{A}) = \\{1\\}$, $\\mathcal{S}^{(2)}(\\text{C}) = \\{3\\}$.\n\n测试用例 3（边缘情况，高污染和截断）：\n- $n = 2$, $G = 4$,\n- $\\mathbf{N}^{(3)} = \\begin{bmatrix}\n3  1  0  0 \\\\\n1  0  2  0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(3)} = \\begin{bmatrix} 0.7  0.2  0.1  0.0 \\end{bmatrix}$,\n- $\\mathbf{c}^{(3)} = \\begin{bmatrix} 0.95  0.8 \\end{bmatrix}$,\n- $\\mathbf{y}^{(3)} = \\begin{bmatrix} \\text{A}  \\text{B} \\end{bmatrix}$,\n- $\\mathcal{S}^{(3)}(\\text{A}) = \\{0\\}$, $\\mathcal{S}^{(3)}(\\text{B}) = \\{2\\}$.\n\n测试用例 4（边缘情况，去污染后总计数为零）：\n- $n = 1$, $G = 3$,\n- $\\mathbf{N}^{(4)} = \\begin{bmatrix}\n1  0  0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(4)} = \\begin{bmatrix} 0.6  0.3  0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(4)} = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n- $\\mathbf{y}^{(4)} = \\begin{bmatrix} \\text{A} \\end{bmatrix}$,\n- $\\mathcal{S}^{(4)}(\\text{A}) = \\{0\\}$.\n\n测试用例 5（边缘情况，一个标签的标记基因集为空）：\n- $n = 2$, $G = 3$,\n- $\\mathbf{N}^{(5)} = \\begin{bmatrix}\n10  5  0 \\\\\n0  0  8\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(5)} = \\begin{bmatrix} 0.2  0.2  0.6 \\end{bmatrix}$,\n- $\\mathbf{c}^{(5)} = \\begin{bmatrix} 0.2  0.4 \\end{bmatrix}$,\n- $\\mathbf{y}^{(5)} = \\begin{bmatrix} \\text{D}  \\text{B} \\end{bmatrix}$,\n- $\\mathcal{S}^{(5)}(\\text{D}) = \\varnothing$, $\\mathcal{S}^{(5)}(\\text{B}) = \\{2\\}$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是浮点数 $\\Delta$，并四舍五入到六位小数。例如，输出应类似于 `[\\delta_1,\\delta_2,\\dots,\\delta_5]`，其中每个 $\\delta_k$ 是一个有六位小数的十进制数。不应打印任何其他文本。", "solution": "该问题是有效的。它在科学上基于单细胞 RNA 测序中既定的环境 RNA 污染模型，其定义和约束条件明确，表述客观。所有必要的参数和条件都已提供，足以推导出唯一且有意义的解。\n\n解决方案分三个阶段展开：首先，从给定的生成模型推导出-去污染算子；其次，将标记基因特异性指标形式化；第三，详细说明计算平均标记基因特异性变化量 $\\Delta$ 的完整算法。\n\n**1. 去污染算子的推导**\n\n问题设定了一个生成模型，其中 $n$ 个细胞和 $G$ 个基因的观测 UMI 计数 $\\mathbf{N} \\in \\mathbb{N}_0^{n \\times G}$ 是真实细胞计数和环境 RNA 计数的混合。环境 RNA 的贡献由一个环境表达谱 $\\mathbf{a} \\in \\mathbb{R}_{\\ge 0}^{G}$（一个基因上的概率分布，$\\sum_{g=1}^{G} a_g = 1$）和每个细胞的污染分数 $c_i \\in [0,1]$ 定义。\n\n对于每个细胞 $i$，总观测 UMI 计数为 $T_i = \\sum_{g=1}^{G} N_{ig}$。污染分数 $c_i$ 代表这些总计数中源自环境池的期望比例。因此，细胞 $i$ 中期望的环境计数总数为 $c_i T_i$。\n\n这些环境计数根据环境表达谱 $\\mathbf{a}$ 分布在 $G$ 个基因上。细胞 $i$ 中特定基因 $g$ 的期望环境计数（表示为 $A_{ig}$）是该细胞的总期望环境计数乘以基因 $g$ 在环境表达谱中的相对频率 $a_g$。\n$$\nE[A_{ig}] = (c_i T_i) a_g\n$$\n去污染的目标是通过从观测计数 $N_{ig}$ 中移除这一期望的环境部分来估计真实的细胞内源计数。设 $\\mathbf{D} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$ 为去污染后的计数矩阵。元素 $D_{ig}$ 通过从观测计数中减去期望的环境计数获得：\n$$\nD_{ig} = N_{ig} - c_i T_i a_g\n$$\n一个关键约束是计数必须为非负。如果减法结果为负值（当观测计数 $N_{ig}$ 由于采样噪声而低于期望的环境贡献时，可能发生这种情况），则该值必须在 $0$ 处截断。这导出了去污染算子的最终形式：\n$$\nD_{ig} = \\max(0, N_{ig} - c_i T_i a_g)\n$$\n此操作应用于每个细胞中的每个基因，以生成完整的去污染矩阵 $\\mathbf{D}$。\n\n**2. 标记基因特异性**\n\n细胞 $i$ 的标记基因特异性定义为其总 UMI 计数中归属于其指定细胞类型 $y_i$ 的标记基因集 $\\mathcal{S}(y_i)$ 的比例。对于一个通用的计数矩阵 $\\mathbf{X} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$，其特异性 $s_i(\\mathbf{X})$ 为：\n$$\ns_i(\\mathbf{X}) \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{g \\in \\mathcal{S}(y_i)} X_{ig}}{\\sum_{g=1}^{G} X_{ig}}  \\text{if } \\sum_{g=1}^{G} X_{ig} > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n此公式适用于观测计数矩阵 $\\mathbf{N}$ 和去污染后的计数矩阵 $\\mathbf{D}$。问题还规定，如果标记基因集 $\\mathcal{S}(y_i)$ 为空，则分子为 $0$，因此 $s_i(\\mathbf{X}) = 0$。总体质量指标是去污染后所有 $n$ 个细胞的平均特异性变化：\n$$\n\\Delta \\;=\\; \\bar{s}(\\mathbf{D}) - \\bar{s}(\\mathbf{N}) \\;=\\; \\left(\\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D})\\right) \\;-\\; \\left(\\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N})\\right)\n$$\n\n**3. 计算特异性提升值 $\\Delta$ 的算法**\n\n对于给定的测试用例（$\\mathbf{N}, \\mathbf{a}, \\mathbf{c}, \\mathbf{y}, \\mathcal{S}$），完整算法如下：\n\n1.  **归一化环境表达谱**：检查是否 $\\sum_{g=1}^{G} a_g = 1$。如果不满足，则将 $\\mathbf{a}$ 除以其总和进行归一化。设归一化后的表达谱为 $\\mathbf{a}'$。\n    $$\n    \\mathbf{a}' = \\dfrac{\\mathbf{a}}{\\sum_{g=1}^{G} a_g}\n    $$\n2.  **计算观测计数的平均特异性**：\n    a. 对于每个细胞 $i=1, \\dots, n$，计算总观测计数 $T_i = \\sum_{g=1}^{G} N_{ig}$。\n    b. 对于每个细胞 $i$，使用公式、其标签 $y_i$ 和对应的标记基因集 $\\mathcal{S}(y_i)$ 计算其特异性 $s_i(\\mathbf{N})$。处理 $T_i=0$ 或 $\\mathcal{S}(y_i)$ 为空的情况。\n    c. 计算平均观测特异性 $\\bar{s}(\\mathbf{N}) = \\frac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N})$。\n\n3.  **执行去污染**：\n    a. 对于每个细胞 $i=1, \\dots, n$，使用上面推导的算子计算去污染后的计数向量 $\\mathbf{D}_{i,:}$：\n       $$\n       D_{ig} = \\max(0, N_{ig} - c_i T_i a'_g) \\quad \\text{for } g=1, \\dots, G\n       $$\n    b. 这些向量构成了去污染后的矩阵 $\\mathbf{D}$。\n\n4.  **计算去污染后计数的平均特异性**：\n    a. 对于每个细胞 $i=1, \\dots, n$，计算去污染后的总计数 $T'_i = \\sum_{g=1}^{G} D_{ig}$。\n    b. 对于每个细胞 $i$，使用公式计算其去污染后的特异性 $s_i(\\mathbf{D})$，其中 $T'_i=0$ 会导致 $s_i(\\mathbf{D})=0$。\n    c. 计算平均去污染后特异性 $\\bar{s}(\\mathbf{D}) = \\frac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D})$。\n\n5.  **计算最终指标**：计算差值 $\\Delta = \\bar{s}(\\mathbf{D}) - \\bar{s}(\\mathbf{N})$。结果按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": np.array([[12, 8, 1, 3, 0], [2, 4, 15, 0, 1], [0, 1, 0, 20, 5]]),\n            \"a\": np.array([0.25, 0.25, 0.2, 0.2, 0.1]),\n            \"c\": np.array([0.2, 0.3, 0.15]),\n            \"y\": ['A', 'B', 'C'],\n            \"S\": {'A': {0, 1}, 'B': {2}, 'C': {3}}\n        },\n        {\n            \"N\": np.array([[5, 0, 0, 5], [0, 10, 0, 0]]),\n            \"a\": np.array([0.4, 0.1, 0.4, 0.1]),\n            \"c\": np.array([0.0, 0.0]),\n            \"y\": ['C', 'A'],\n            \"S\": {'A': {1}, 'C': {3}}\n        },\n        {\n            \"N\": np.array([[3, 1, 0, 0], [1, 0, 2, 0]]),\n            \"a\": np.array([0.7, 0.2, 0.1, 0.0]),\n            \"c\": np.array([0.95, 0.8]),\n            \"y\": ['A', 'B'],\n            \"S\": {'A': {0}, 'B': {2}}\n        },\n        {\n            \"N\": np.array([[1, 0, 0]]),\n            \"a\": np.array([0.6, 0.3, 0.1]),\n            \"c\": np.array([1.0]),\n            \"y\": ['A'],\n            \"S\": {'A': {0}}\n        },\n        {\n            \"N\": np.array([[10, 5, 0], [0, 0, 8]]),\n            \"a\": np.array([0.2, 0.2, 0.6]),\n            \"c\": np.array([0.2, 0.4]),\n            \"y\": ['D', 'B'],\n            \"S\": {'D': set(), 'B': {2}}\n        }\n    ]\n\n    results = []\n\n    def calculate_mean_specificity(X, y_labels, marker_sets):\n        \"\"\"\n        Helper function to calculate the mean marker specificity for a count matrix.\n        \"\"\"\n        n, _ = X.shape\n        total_specificity = 0.0\n        for i in range(n):\n            total_counts_i = np.sum(X[i, :])\n            if total_counts_i == 0:\n                specificity_i = 0.0\n            else:\n                cell_type = y_labels[i]\n                marker_genes = marker_sets.get(cell_type, set())\n                if not marker_genes:\n                    specificity_i = 0.0\n                else:\n                    marker_indices = list(marker_genes)\n                    marker_counts = np.sum(X[i, marker_indices])\n                    specificity_i = marker_counts / total_counts_i\n            total_specificity += specificity_i\n        return total_specificity / n\n\n    for case in test_cases:\n        N, a, c, y, S = case[\"N\"], case[\"a\"], case[\"c\"], case[\"y\"], case[\"S\"]\n        \n        # Step 1: Normalize ambient profile 'a' if necessary\n        a_sum = np.sum(a)\n        if not np.isclose(a_sum, 1.0):\n            a = a / a_sum\n\n        # Step 2: Calculate mean specificity for observed counts N\n        mean_specificity_N = calculate_mean_specificity(N, y, S)\n\n        # Step 3: Perform decontamination\n        # Calculate total observed counts per cell\n        T = np.sum(N, axis=1)\n        \n        # Calculate the expected ambient counts to subtract for each cell and gene.\n        # This requires broadcasting:\n        # c (n,1) * T (n,1) * a (1,G) -> (n,G)\n        ambient_subtraction_matrix = c.reshape(-1, 1) * T.reshape(-1, 1) * a.reshape(1, -1)\n\n        # Decontaminate by subtracting and clipping at 0\n        D = np.maximum(0, N - ambient_subtraction_matrix)\n\n        # Step 4: Calculate mean specificity for decontaminated counts D\n        mean_specificity_D = calculate_mean_specificity(D, y, S)\n        \n        # Step 5: Compute the final metric delta\n        delta = mean_specificity_D - mean_specificity_N\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3348555"}, {"introduction": "拥有一个经过清理的计数矩阵后，我们的目标便转向识别驱动细胞间生物学差异的关键基因。本练习将介绍高可变基因（Highly Variable Genes, HVGs）的概念，这些基因的表达变化超越了仅由技术噪声所能解释的范畴。您将学习如何使用泊松（Poisson）和负二项（Negative Binomial）分布这两种关键统计模型来对基因表达的均值-方差关系进行建模，并利用这些模型来量化和筛选出具有显著生物学变异的基因，这是细胞聚类、轨迹推断等所有下游分析的基石 ([@problem_id:3348549])。", "problem": "对于每个数据集，您会获得标准化的计数矩阵和一条拟合的均值-方差曲线。您的任务是根据两种噪声模型（泊松模型和负二项式模型）以编程方式计算高变异基因 (HVGs)，并比较所选出的基因。您的程序必须严格遵循下述定义和步骤，并生成一个单行输出，该输出汇总了所有给定测试用例的结果。\n\n定义和计算要求：\n- 令 $X \\in \\mathbb{R}^{n \\times p}$ 表示一个标准化的计数矩阵，其中包含 $n$ 个细胞（行）和 $p$ 个基因（列）。\n- 对于每个基因 $g \\in \\{0,1,\\dots,p-1\\}$，计算其在所有细胞中的样本均值\n  $$\\bar{x}_g \\equiv \\frac{1}{n} \\sum_{i=1}^{n} x_{ig},$$\n  以及无偏样本方差\n  $$s_g^2 \\equiv \\frac{1}{n-1} \\sum_{i=1}^{n} \\left(x_{ig} - \\bar{x}_g\\right)^2.$$\n- 拟合的均值-方差曲线以二次函数的形式给出\n  $$\\hat{v}_{\\text{trend}}(m) = a + b\\,m + c\\,m^2,$$\n  每个数据集都有给定的系数 $a$、 $b$ 和 $c$。\n- 在泊松噪声模型下，方差-均值关系为 $v_{\\text{P}}(m) = m$。定义模型约束的期望方差为\n  $$E_{\\text{P}}(m) \\equiv \\max\\left( \\hat{v}_{\\text{trend}}(m), \\, v_{\\text{P}}(m) \\right) = \\max\\left( a + b\\,m + c\\,m^2,\\, m \\right).$$\n- 在离散参数为 $\\alpha > 0$ 的负二项式噪声模型下，方差-均值关系为 $v_{\\text{NB}}(m) = m + \\alpha\\,m^2$。定义模型约束的期望方差为\n  $$E_{\\text{NB}}(m) \\equiv \\max\\left( \\hat{v}_{\\text{trend}}(m), \\, v_{\\text{NB}}(m) \\right) = \\max\\left( a + b\\,m + c\\,m^2,\\, m + \\alpha\\,m^2 \\right).$$\n- 为保证数值稳定性，当除以期望方差时，使用一个小数常量 $\\varepsilon = 10^{-8}$ 来避免除以零，方法是将任何分母 $d$ 替换为 $\\max(d, \\varepsilon)$。\n- 定义在特定模型下每个基因 $g$ 的标准化残差离散度为\n  $$r_g^{(\\cdot)} \\equiv \\frac{s_g^2 - E_{(\\cdot)}(\\bar{x}_g)}{\\max\\left( E_{(\\cdot)}(\\bar{x}_g), \\, \\varepsilon \\right)},$$\n  其中 $(\\cdot) \\in \\{\\text{P}, \\text{NB}\\}$ 表示所用模型。\n- 对于给定模型的 HVG 选择规则：在残差 $r_g^{(\\cdot)} > 0$（严格为正）的基因中，按 $r_g^{(\\cdot)}$ 的降序选择前 $K$ 个基因的索引。如果严格为正残差的基因少于 $K$ 个，则返回所有具有严格为正残差的基因。平局决胜规则如下：\n  $1)$ 更大的 $\\bar{x}_g$（降序），\n  $2)$ 更小的基因索引 $g$（升序）。\n- 所有基因索引均为从 0 开始的整数。\n\n测试套件：\n对于每个测试用例 $t \\in \\{1,2,3,4\\}$，您会获得一个矩阵 $X^{(t)}$、系数 $(a^{(t)}, b^{(t)}, c^{(t)})$、一个负二项式离散度 $\\alpha^{(t)}$ 和一个目标数量 $K^{(t)}$。您的程序必须为每个测试 $t$ 计算并返回一对列表：分别是泊松模型下的 HVG 索引和负二项式模型下的 HVG 索引。\n\n- 测试用例 $1$：\n  - $X^{(1)}$ 有 $n=5$ 行和 $p=6$ 列，各行为\n    $[2, 0, 3, 1, 10, 5]$,\n    $[3, 0, 4, 1, 11, 6]$,\n    $[2, 0, 8, 1, 9, 5]$,\n    $[3, 0, 2, 1, 12, 4]$,\n    $[2, 0, 5, 1, 8, 5]$。\n  - $(a^{(1)}, b^{(1)}, c^{(1)}) = (0.2, 0.7, 0.02)$。\n  - $\\alpha^{(1)} = 0.1$。\n  - $K^{(1)} = 3$。\n\n- 测试用例 $2$：\n  - $X^{(2)}$ 有 $n=4$ 行和 $p=4$ 列，各行为\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 11]$。\n  - $(a^{(2)}, b^{(2)}, c^{(2)}) = (0.1, 0.1, 0.01)$。\n  - $\\alpha^{(2)} = 0.05$。\n  - $K^{(2)} = 2$。\n\n- 测试用例 $3$：\n  - $X^{(3)}$ 有 $n=5$ 行和 $p=4$ 列，各行为\n    $[0, 5, 0, 1]$,\n    $[0, 5, 0, 1]$,\n    $[0, 5, 50, 1]$,\n    $[0, 5, 0, 1]$,\n    $[0, 5, 0, 1]$。\n  - $(a^{(3)}, b^{(3)}, c^{(3)}) = (0.1, 0.2, 0.0)$。\n  - $\\alpha^{(3)} = 0.1$。\n  - $K^{(3)} = 1$。\n\n- 测试用例 $4$：\n  - $X^{(4)}$ 有 $n=4$ 行和 $p=3$ 列，各行为\n    $[5, 10, 0]$,\n    $[7, 10, 5]$,\n    $[6, 10, 0]$,\n    $[8, 10, 5]$。\n  - $(a^{(4)}, b^{(4)}, c^{(4)}) = (0.1, 0.5, 0.0)$。\n  - $\\alpha^{(4)} = 1.0$。\n  - $K^{(4)} = 2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，按 $t=1,2,3,4$ 的顺序排列。\n- 每个条目必须是一个包含两个元素的列表：第一个元素是泊松模型下的 HVG 索引列表，第二个元素是负二项式模型下的 HVG 索引列表。\n- 整个输出必须打印在单一行上，使用逗号分隔且无空格，例如：\n  `[[[i_P_1,i_P_2],[i_NB_1]],[[],[]],[[],[]],[[],[]]]`\n其中 $i\\_P\\_\\cdot$ 和 $i\\_{NB}\\_\\cdot$ 是整数。如果列表为空，则必须打印为 `[]`。您的程序不得打印任何其他文本。", "solution": "该问题要求使用两种不同的统计噪声模型（泊松模型和负二项式模型），从标准化的单细胞 RNA 测序 (scRNA-seq) 计数数据中识别高变异基因 (HVGs)。该过程是生物信息学中一个定义明确的标准计算工作流程，旨在区分具有显著生物学变异的基因和那些观测方差与测序过程中固有的统计噪声相符的基因。\n\n其基本原理是分析基因表达计数的均值-方差关系。对于计数数据，一个基因在细胞间的表达方差内在地与其平均表达水平相关联。我们将系统地计算每个基因的统计数据，基于均值对期望方差进行建模，然后识别那些观测方差显著超过此期望的基因。\n\n算法流程如下：\n\n1.  **逐基因统计量计算**：对于每个数据集（由一个大小为 $n \\times p$ 的标准化计数矩阵 $X$ 表示，其中 $n$ 是细胞数，$p$ 是基因数），我们首先为每个基因 $g$ 计算两个基本统计量：\n    -   样本均值表达量，$\\bar{x}_g = \\frac{1}{n} \\sum_{i=1}^{n} x_{ig}$。\n    -   无偏样本表达方差， $s_g^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_{ig} - \\bar{x}_g)^2$。\n    这些计算是针对 $p$ 个基因中的每一个，在 $n$ 个细胞上进行的。\n\n2.  **期望方差建模**：HVG 检测的核心在于将观测方差 $s_g^2$ 与源自模型的期望方差进行比较。问题指定了两种此类模型，并将它们与预先拟合的趋势相结合。\n\n    -   方差与均值的总体趋势由一个拟合的二次函数 $\\hat{v}_{\\text{trend}}(m) = a + b m + c m^2$ 捕获。此趋势解释了数据中的系统性偏差和全局模式。\n\n    -   **泊松模型**：该模型假设均值为 $m$ 的基因计数服从泊松分布，其方差等于均值。理论方差为 $v_{\\text{P}}(m) = m$。此模型下的期望方差 $E_{\\text{P}}(m)$ 定义为拟合趋势与理论泊松方差的最大值：$E_{\\text{P}}(m) \\equiv \\max(\\hat{v}_{\\text{trend}}(m), v_{\\text{P}}(m))$。这种公式确保了期望方差至少与通用趋势和基础噪声模型两者所预测的一样大。\n\n    -   **负二项式 (NB) 模型**：NB 分布是用于过离散计数数据（scRNA-seq 的典型特征）的更灵活模型。其方差是均值的二次函数：$v_{\\text{NB}}(m) = m + \\alpha m^2$，其中 $\\alpha > 0$ 是离散参数。较大的 $\\alpha$ 表示更大的过离散（方差远大于均值）。NB 模型的期望方差定义类似：$E_{\\text{NB}}(m) \\equiv \\max(\\hat{v}_{\\text{trend}}(m), v_{\\text{NB}}(m))$。\n\n3.  **量化过度变异**：为了识别具有异常高方差的基因，我们为每个基因计算标准化残差离散度 $r_g$。该指标量化了观测方差 $s_g^2$ 偏离期望方差 $E_{(\\cdot)}(\\bar{x}_g)$ 的程度，并通过期望方差本身进行归一化。对于给定模型 $(\\cdot) \\in \\{\\text{P}, \\text{NB}\\}$，其计算公式为：\n    $$r_g^{(\\cdot)} = \\frac{s_g^2 - E_{(\\cdot)}(\\bar{x}_g)}{\\max(E_{(\\cdot)}(\\bar{x}_g), \\varepsilon)}$$\n    在分母中使用一个小数常量 $\\varepsilon = 10^{-8}$ 以防止除以零，这对于期望方差为零或接近零的基因是必要的预防措施。一个正的残差 $r_g^{(\\cdot)} > 0$ 表明该基因的观测方差高于模型预期，意味着它可能是 HVG 的候选者。\n\n4.  **HVG 选择与排序**：最后一步是根据基因的残差离散度值选择顶部的 HVG。\n    -   首先，我们筛选基因，只保留那些具有严格为正残差的基因，即 $r_g^{(\\cdot)} > 0$。\n    -   接着，对这些候选基因进行排序。主要排序键是残差离散度 $r_g^{(\\cdot)}$，按降序排列。为了确保排名唯一且确定，使用两个后续标准来打破平局：首先是更高的均值表达量 $\\bar{x}_g$（降序），然后是更小的基因索引 $g$（升序）。\n    -   最后，我们从此排序列表中选择前 $K$ 个基因的索引。如果具有正残差的基因数量少于 $K$ 个，则选择所有这些基因。\n\n此过程对每个提供的测试用例中的泊松模型和负二项式模型分别独立应用。实现将利用向量化操作来提高效率，同时计算所有基因的均值、方差和残差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final aggregated result.\n    \"\"\"\n    test_cases = [\n        {\n            \"X\": np.array([\n                [2, 0, 3, 1, 10, 5],\n                [3, 0, 4, 1, 11, 6],\n                [2, 0, 8, 1, 9, 5],\n                [3, 0, 2, 1, 12, 4],\n                [2, 0, 5, 1, 8, 5]\n            ], dtype=float),\n            \"coeffs\": (0.2, 0.7, 0.02),\n            \"alpha\": 0.1,\n            \"K\": 3\n        },\n        {\n            \"X\": np.array([\n                [0, 0, 0, 10],\n                [0, 0, 0, 10],\n                [0, 0, 0, 10],\n                [0, 0, 0, 11]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.1, 0.01),\n            \"alpha\": 0.05,\n            \"K\": 2\n        },\n        {\n            \"X\": np.array([\n                [0, 5, 0, 1],\n                [0, 5, 0, 1],\n                [0, 5, 50, 1],\n                [0, 5, 0, 1],\n                [0, 5, 0, 1]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.2, 0.0),\n            \"alpha\": 0.1,\n            \"K\": 1\n        },\n        {\n            \"X\": np.array([\n                [5, 10, 0],\n                [7, 10, 5],\n                [6, 10, 0],\n                [8, 10, 5]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.5, 0.0),\n            \"alpha\": 1.0,\n            \"K\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        hvg_p = compute_hvgs(case[\"X\"], case[\"coeffs\"], case[\"K\"], model='poisson')\n        hvg_nb = compute_hvgs(case[\"X\"], case[\"coeffs\"], case[\"K\"], model='neg_binomial', alpha=case[\"alpha\"])\n        results.append([hvg_p, hvg_nb])\n\n    # Format the final output string exactly as specified.\n    case_strings = []\n    for res_pair in results:\n        p_str = ','.join(map(str, res_pair[0]))\n        nb_str = ','.join(map(str, res_pair[1]))\n        case_strings.append(f'[[{p_str}],[{nb_str}]]')\n    \n    print(f\"[{','.join(case_strings)}]\")\n\ndef compute_hvgs(X, coeffs, K, model, alpha=None):\n    \"\"\"\n    Computes Highly Variable Genes (HVGs) for a given counts matrix and parameters.\n\n    Args:\n        X (np.ndarray): n x p normalized counts matrix.\n        coeffs (tuple): (a, b, c) coefficients for the mean-variance trend.\n        K (int): The number of top HVGs to select.\n        model (str): 'poisson' or 'neg_binomial'.\n        alpha (float, optional): Dispersion parameter for the NB model. Required if model is 'neg_binomial'.\n\n    Returns:\n        list: A list of 0-based integer indices of the selected HVGs.\n    \"\"\"\n    n, p = X.shape\n    if n  2:\n        return []\n\n    a, b, c = coeffs\n    epsilon = 1e-8\n\n    # Step 1: Compute per-gene sample mean and variance\n    means = np.mean(X, axis=0)\n    # ddof=1 for unbiased sample variance (1/(n-1))\n    variances = np.var(X, axis=0, ddof=1)\n\n    # Step 2: Compute expected variance based on the model\n    v_trend = a + b * means + c * means**2\n\n    if model == 'poisson':\n        v_model = means\n    elif model == 'neg_binomial':\n        if alpha is None:\n            raise ValueError(\"alpha must be provided for the Negative Binomial model.\")\n        v_model = means + alpha * means**2\n    else:\n        raise ValueError(\"Unknown model specified.\")\n\n    expected_variances = np.maximum(v_trend, v_model)\n\n    # Step 3: Compute standardized residual dispersion\n    denominators = np.maximum(expected_variances, epsilon)\n    residuals = (variances - expected_variances) / denominators\n\n    # Step 4: Filter, rank, and select HVGs\n    candidates = []\n    for g in range(p):\n        if residuals[g] > 0:\n            # Store (residual, mean, gene_index) for sorting\n            candidates.append((residuals[g], means[g], g))\n\n    # Sort based on the specified tie-breaking rules:\n    # 1. residual descending (reverse=True on item[0])\n    # 2. mean descending (reverse=True on item[1])\n    # 3. gene index ascending (reverse=False on item[2], so we use -item[2] with reverse=True)\n    candidates.sort(key=lambda item: (item[0], item[1], -item[2]), reverse=True)\n\n    # Select the top K gene indices\n    hvg_indices = [item[2] for item in candidates[:K]]\n    \n    return hvg_indices\n\nsolve()\n```", "id": "3348549"}]}