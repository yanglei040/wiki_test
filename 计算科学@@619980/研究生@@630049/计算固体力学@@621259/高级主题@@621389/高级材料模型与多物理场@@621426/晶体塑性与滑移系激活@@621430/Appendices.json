{"hands_on_practices": [{"introduction": "本次实践是晶体塑性理论的核心：控制塑性流动的本构律。你将实现一个应用广泛的幂律关系，它将滑移系上的分解剪应力 $\\tau^\\alpha$ 与产生的滑移率 $\\dot{\\gamma}^\\alpha$ 联系起来，并学习如何判断哪些滑移系处于激活状态。[@problem_id:3556441] 这个练习对于理解材料的率敏感性等特性如何影响微观尺度上的塑性行为至关重要。", "problem": "在晶体塑性（CP）的背景下，给定一组由 $\\alpha$ 索引的滑移系。每个滑移系都由一个分解切应力 $\\tau^\\alpha$ 和一个滑移抗力（也称为临界分解切应力）$g^\\alpha$ 来表征，二者单位均为应力。该材料是率相关的，具有一个无量纲的率敏感性参数 $m$ 和一个参考滑移率 $\\dot{\\gamma}_0$（单位为 $\\mathrm{s}^{-1}$）。机械耗散定义为 $D = \\sum_\\alpha \\tau^\\alpha \\dot{\\gamma}^\\alpha$，并假设存在一个凸耗散势来生成相关联流动法则。目标是基于此原理计算每个滑移系的滑移率 $\\dot{\\gamma}^\\alpha$，然后使用阈值算法确定激活集。如果一个滑移系的过应力比 $r^\\alpha = \\left|\\tau^\\alpha\\right| / g^\\alpha$ 高于指定的比率阈值，且其滑移率量值高于规定的容差，则该滑移系被认为是激活的。\n\n推导和实现的基本依据：\n- 率相关的本构描述源于一个凸耗散伪势的假设，该伪势取决于滑移率的量值和滑移抗力。\n- 通过强制要求分解切应力是耗散势相对于滑移率的次微分，从而获得与热力学第二定律一致的相关联流动法则。\n\n您必须编写一个完整的程序，针对下面指定的每个测试用例，计算：\n1. 所有滑移系的滑移率 $\\dot{\\gamma}^\\alpha$（单位为 $\\mathrm{s}^{-1}$）。\n2. 由如下定义的阈值算法确定的激活集标志 $A^\\alpha \\in \\{\\text{True}, \\text{False}\\}$：\n   - 计算过应力比 $r^\\alpha = \\left|\\tau^\\alpha\\right| / g^\\alpha$（无量纲）。\n   - 如果同时满足 $r^\\alpha \\ge r_{\\mathrm{thr}}$ 和 $\\left|\\dot{\\gamma}^\\alpha\\right| \\ge \\dot{\\gamma}_{\\mathrm{tol}}$，则该滑移系是激活的。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果，结果为用方括号括起来的逗号分隔列表。每个测试用例的结果必须表示为一个包含两个列表的列表：第一个是滑移率列表（单位为 $\\mathrm{s}^{-1}$），第二个是激活集的布尔值列表。例如：$[\\,[\\,[\\dot{\\gamma}^1,\\dot{\\gamma}^2,\\ldots],\\,[A^1,A^2,\\ldots]\\,],\\ldots\\,]$。\n\n使用以下测试套件。所有应力 $\\tau^\\alpha$ 和 $g^\\alpha$ 的单位均解释为 $\\mathrm{MPa}$，滑移率单位为 $\\mathrm{s}^{-1}$，本问题中不使用角度。\n\n- 测试用例 1（一般情况，混合正负号与零应力）：\n  - $\\boldsymbol{\\tau} = [\\,120,\\,80,\\,-110,\\,20,\\,0,\\,95\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,100,\\,100,\\,100,\\,100,\\,100,\\,100\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.05$，\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 0.98$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-6}\\,\\mathrm{s}^{-1}$。\n\n- 测试用例 2（边界条件，包括 $\\left|\\tau^\\alpha\\right| = g^\\alpha$ 和零应力）：\n  - $\\boldsymbol{\\tau} = [\\,100,\\,100,\\,-100,\\,50,\\,-50,\\,0\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,100,\\,120,\\,100,\\,60,\\,50,\\,80\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.2$，\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 1.0$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 5\\times 10^{-6}\\,\\mathrm{s}^{-1}$。\n\n- 测试用例 3（低过应力比，中等率敏感性）：\n  - $\\boldsymbol{\\tau} = [\\,30,\\,-45,\\,70,\\,-10,\\,5,\\,15\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,150,\\,150,\\,200,\\,200,\\,180,\\,160\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.5$，\n  - $\\dot{\\gamma}_0 = 10^{-2}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 0.9$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-4}\\,\\mathrm{s}^{-1}$。\n\n- 测试用例 4（接近零的应力以探测数值稳定性）：\n  - $\\boldsymbol{\\tau} = [\\,0.1,\\,-0.2,\\,0.0,\\,0.05,\\,-0.05,\\,0.01\\,]\\,\\mathrm{MPa}$，\n  - $\\boldsymbol{g} = [\\,100,\\,100,\\,100,\\,120,\\,120,\\,150\\,]\\,\\mathrm{MPa}$，\n  - $m = 0.05$，\n  - $\\dot{\\gamma}_0 = 10^{-3}\\,\\mathrm{s}^{-1}$，\n  - $r_{\\mathrm{thr}} = 0.95$，\n  - $\\dot{\\gamma}_{\\mathrm{tol}} = 10^{-8}\\,\\mathrm{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，格式为 $[\\,[\\dot{\\gamma}^1,\\dot{\\gamma}^2,\\ldots],\\,[A^1,A^2,\\ldots]\\,]$。所有滑移率必须以 $\\mathrm{s}^{-1}$ 为单位表示。", "solution": "所述问题是有效的。它在科学上基于连续介质力学和材料科学的原理，特别是在率相关晶体塑性领域。该问题是适定的、客观的，并包含推导唯一且有意义解所需的所有信息。该公式是该领域的标准公式，依赖于分解切应力与滑移率之间的幂律关系，该关系可从凸耗散势中推导得出。\n\n晶体塑性的热力学框架假定存在一个耗散势 $\\Psi$，它是滑移率 $\\dot{\\gamma}^\\alpha$ 的凸函数。然后，通过相关联流动法则从该势函数中导出每个滑移系 $\\alpha$ 上的分解切应力 $\\tau^\\alpha$，确保耗散 $D = \\sum_\\alpha \\tau^\\alpha \\dot{\\gamma}^\\alpha$ 为非负值。这表示为：\n$$\n\\tau^\\alpha = \\frac{\\partial \\Psi}{\\partial \\dot{\\gamma}^\\alpha}\n$$\n一个常用的耗散势形式，它能导出指定的幂律粘塑性模型，其形式为：\n$$\n\\Psi(\\{\\dot{\\gamma}^\\beta\\}; \\{g^\\beta\\}) = \\sum_{\\beta} \\frac{g^\\beta \\dot{\\gamma}_0}{m+1} \\left( \\frac{|\\dot{\\gamma}^\\beta|}{\\dot{\\gamma}_0} \\right)^{m+1}\n$$\n其中 $g^\\beta$ 是滑移系 $\\beta$ 的滑移抗力，$\\dot{\\gamma}_0$ 是参考滑移率，$m$ 是率敏感性参数。所有这些量在问题陈述中都已给出。\n\n应用相关联流动法则，我们将势函数 $\\Psi$ 对特定的滑移率 $\\dot{\\gamma}^\\alpha$ 求导：\n$$\n\\tau^\\alpha = \\frac{\\partial}{\\partial \\dot{\\gamma}^\\alpha} \\left[ \\sum_{\\beta} \\frac{g^\\beta \\dot{\\gamma}_0}{m+1} \\left( \\frac{|\\dot{\\gamma}^\\beta|}{\\dot{\\gamma}_0} \\right)^{m+1} \\right]\n$$\n由于滑移系在势函数中是解耦的，当 $\\beta \\neq \\alpha$ 时导数为零。我们剩下：\n$$\n\\tau^\\alpha = \\frac{g^\\alpha \\dot{\\gamma}_0}{m+1} \\frac{\\partial}{\\partial \\dot{\\gamma}^\\alpha} \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^{m+1}\n$$\n使用链式法则，并注意到 $\\frac{d|x|}{dx} = \\mathrm{sgn}(x)$，我们得到：\n$$\n\\tau^\\alpha = \\frac{g^\\alpha \\dot{\\gamma}_0}{m+1} (m+1) \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^{m} \\frac{1}{\\dot{\\gamma}_0} \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)\n$$\n简化此表达式可得到分解切应力与滑移率之间的关系：\n$$\n\\tau^\\alpha = g^\\alpha \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)\n$$\n为确保非负耗散（$\\tau^\\alpha \\dot{\\gamma}^\\alpha \\ge 0$），$\\tau^\\alpha$ 和 $\\dot{\\gamma}^\\alpha$ 的符号必须相同，因此 $\\mathrm{sgn}(\\tau^\\alpha) = \\mathrm{sgn}(\\dot{\\gamma}^\\alpha)$。对两边取绝对值：\n$$\n|\\tau^\\alpha| = g^\\alpha \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m\n$$\n现在我们可以求解滑移率的量值 $|\\dot{\\gamma}^\\alpha|$：\n$$\n\\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right) = \\left( \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\right)^m \\implies \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m} = \\frac{|\\dot{\\gamma}^\\alpha|}{\\dot{\\gamma}_0} \\implies |\\dot{\\gamma}^\\alpha| = \\dot{\\gamma}_0 \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m}\n$$\n重新引入符号，我们得到滑移系 $\\alpha$ 上滑移率的最终本构方程：\n$$\n\\dot{\\gamma}^\\alpha = \\dot{\\gamma}_0 \\left( \\frac{|\\tau^\\alpha|}{g^\\alpha} \\right)^{1/m} \\mathrm{sgn}(\\tau^\\alpha)\n$$\n该方程提供了一种直接的方法，用于在给定分解切应力 $\\tau^\\alpha$、当前滑移抗力 $g^\\alpha$、参考滑移率 $\\dot{\\gamma}_0$ 和率敏感性指数 $m$ 的情况下，计算每个滑移系的滑移率 $\\dot{\\gamma}^\\alpha$。值得注意的是，如果 $\\tau^\\alpha = 0$，则 $\\dot{\\gamma}^\\alpha = 0$，这在物理上和数学上都是一致的。所有给定的滑移抗力 $g^\\alpha$ 都是严格为正的，从而避免了任何除以零的情况。\n\n问题的第二部分要求确定滑移系的激活集。一个滑移系 $\\alpha$ 被定义为激活的，需同时满足两个条件：\n1.  过应力比 $r^\\alpha = \\frac{|\\tau^\\alpha|}{g^\\alpha}$ 必须大于或等于指定的阈值 $r_{\\mathrm{thr}}$。\n2.  滑移率的量值 $|\\dot{\\gamma}^\\alpha|$ 必须大于或等于指定的容差 $\\dot{\\gamma}_{\\mathrm{tol}}$。\n\n因此，每个滑移系的激活标志 $A^\\alpha$ 由逻辑表达式确定：\n$$\nA^\\alpha = (r^\\alpha \\ge r_{\\mathrm{thr}}) \\land (|\\dot{\\gamma}^\\alpha| \\ge \\dot{\\gamma}_{\\mathrm{tol}})\n$$\n其中 $\\land$ 代表逻辑与运算符。\n\n每个测试用例的计算过程如下：\n1.  对于从 $1$ 到 $N$ 的每个滑移系 $\\alpha$，其中 $N$ 是给定测试用例中的滑移系数量：\n    a.  获取 $\\tau^\\alpha$、 $g^\\alpha$、 $m$ 和 $\\dot{\\gamma}_0$ 的值。\n    b.  使用推导出的幂律方程计算滑移率 $\\dot{\\gamma}^\\alpha$。\n    c.  计算过应力比 $r^\\alpha = |\\tau^\\alpha| / g^\\alpha$。\n    d.  通过检查 $r^\\alpha \\ge r_{\\mathrm{thr}}$ 和 $|\\dot{\\gamma}^\\alpha| \\ge \\dot{\\gamma}_{\\mathrm{tol}}$ 是否均为 `True` 来评估激活标志 $A^\\alpha$。\n2.  将计算出的滑移率收集到一个列表 $[\\dot{\\gamma}^1, \\dot{\\gamma}^2, \\ldots, \\dot{\\gamma}^N]$ 中。\n3.  将激活标志收集到一个列表 $[A^1, A^2, \\ldots, A^N]$ 中。\n4.  将这两个列表组合成该测试用例的最终结构：$[[\\dot{\\gamma}^1, \\ldots], [A^1, \\ldots]]$。\n对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes slip rates and active sets for crystal plasticity problems.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (tau, g, m, gamma0_dot, r_thr, gamma_tol_dot)\n    # Stresses are in MPa, slip rates in s^-1.\n    test_cases = [\n        (\n            np.array([120.0, 80.0, -110.0, 20.0, 0.0, 95.0]),  # tau (MPa)\n            np.array([100.0, 100.0, 100.0, 100.0, 100.0, 100.0]),  # g (MPa)\n            0.05,  # m\n            1e-3,  # gamma0_dot (s^-1)\n            0.98,  # r_thr\n            1e-6   # gamma_tol_dot (s^-1)\n        ),\n        (\n            np.array([100.0, 100.0, -100.0, 50.0, -50.0, 0.0]),\n            np.array([100.0, 120.0, 100.0, 60.0, 50.0, 80.0]),\n            0.2,\n            1e-3,\n            1.0,\n            5e-6\n        ),\n        (\n            np.array([30.0, -45.0, 70.0, -10.0, 5.0, 15.0]),\n            np.array([150.0, 150.0, 200.0, 200.0, 180.0, 160.0]),\n            0.5,\n            1e-2,\n            0.9,\n            1e-4\n        ),\n        (\n            np.array([0.1, -0.2, 0.0, 0.05, -0.05, 0.01]),\n            np.array([100.0, 100.0, 100.0, 120.0, 120.0, 150.0]),\n            0.05,\n            1e-3,\n            0.95,\n            1e-8\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, g, m, gamma0_dot, r_thr, gamma_tol_dot = case\n\n        # Ensure g is not zero to avoid division by zero, though not present in test data.\n        # Create a mask for non-zero g for safe division.\n        g_is_zero = (g == 0)\n        overstress_ratio = np.full_like(tau, 0.0)\n        \n        # Calculate overstress ratio only where g is not zero\n        # Where g is zero, overstress is infinite if tau is non-zero, handled implicitly\n        # since gamma_dot would be infinite. In this problem, all g > 0.\n        overstress_ratio = np.abs(tau) / g\n\n        # Calculate slip rates using the power-law constitutive equation.\n        # np.power(0, positive_number) is 0, correctly handling tau=0.\n        # np.sign(0) is 0, also handled correctly.\n        exponent = 1.0 / m\n        gamma_dot = gamma0_dot * np.power(overstress_ratio, exponent) * np.sign(tau)\n\n        # Determine the active set based on the two conditions.\n        # 1. Overstress ratio threshold\n        # 2. Slip rate magnitude tolerance\n        active_set_flags = (overstress_ratio >= r_thr)  (np.abs(gamma_dot) >= gamma_tol_dot)\n\n        # Format results for the current case as required\n        gamma_dot_list = gamma_dot.tolist()\n        active_set_list = active_set_flags.tolist()\n        \n        results.append([gamma_dot_list, active_set_list])\n\n    # Convert the list of results to the required string format.\n    # The default str() representation for lists includes spaces after commas,\n    # which is consistent with the visual spacing in the problem's LaTeX example.\n    result_strings = [str(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```", "id": "3556441"}, {"introduction": "在确定了滑移率之后，下一个挑战是在晶体变形时正确描述滑移系的取向。本次实践将一个简化的描述晶格旋转的加法模型与更严谨的乘法极分解方法进行对比。[@problem_id:3556422] 通过对这两种方法的基准测试，你将对为何一个恰当的运动学描述至关重要（尤其是在处理大转动时）获得一个具体的认识。", "problem": "你需要实现一个基准测试，用于比较小应变晶体塑性中使用的两种晶格旋转运动学描述：一种是加法小应变近似，另一种是基于乘法极分解的旋转。目标是量化当施加的变形梯度涉及大空间转动和剪切时，这两种描述在预测滑移系激活方面的差异。\n\n从以下基本依据开始：\n- 变形梯度表示为 $\\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3}$，位移梯度为 $\\boldsymbol{H} = \\boldsymbol{F} - \\boldsymbol{I}$，其中 $\\boldsymbol{I}$ 是单位张量。\n- 小应变张量为 $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\boldsymbol{H} + \\boldsymbol{H}^\\top)$。\n- 对于杨氏模量为 $E$、泊松比为 $\\nu$ 的各向同性线弹性材料，其柯西应力为 $\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}$，其中拉梅参数为 $\\mu = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{\\nu E}{(1+\\nu)(1-2\\nu)}$。\n- 乘法旋转由极分解定义为 $\\boldsymbol{F} = \\boldsymbol{R} \\, \\boldsymbol{U}$，其中 $\\boldsymbol{R}$ 是一个真正常交旋转，$\\boldsymbol{U}$ 是右拉伸张量。通过 $\\boldsymbol{R} = \\boldsymbol{F} \\boldsymbol{U}^{-1}$ 计算 $\\boldsymbol{R}$，其中 $\\boldsymbol{U} = (\\boldsymbol{F}^\\top \\boldsymbol{F})^{1/2}$。\n- 加法小应变晶格旋转近似使用 $\\boldsymbol{H}$ 的反对称部分，即 $\\boldsymbol{W} = \\tfrac{1}{2}(\\boldsymbol{H} - \\boldsymbol{H}^\\top)$，并将晶格旋转更新近似为 $\\boldsymbol{R}_\\mathrm{add} \\approx \\boldsymbol{I} + \\boldsymbol{W}$。\n- 对于一个滑移系 $\\alpha$，其参考滑移方向为 $\\boldsymbol{s}_0^{(\\alpha)}$，滑移面法向为 $\\boldsymbol{n}_0^{(\\alpha)}$（两者均为单位向量且 $\\boldsymbol{s}_0^{(\\alpha)} \\cdot \\boldsymbol{n}_0^{(\\alpha)} = 0$），当前方向按以下方式计算：\n  - 在乘法旋转模型下：$\\boldsymbol{s}_\\mathrm{mul}^{(\\alpha)} = \\boldsymbol{R} \\, \\boldsymbol{s}_0^{(\\alpha)}$，$\\boldsymbol{n}_\\mathrm{mul}^{(\\alpha)} = \\boldsymbol{R} \\, \\boldsymbol{n}_0^{(\\alpha)}$。\n  - 在加法模型下：$\\boldsymbol{s}_\\mathrm{add}^{(\\alpha)} = \\dfrac{(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{s}_0^{(\\alpha)}}{\\|(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{s}_0^{(\\alpha)}\\|}$，$\\boldsymbol{n}_\\mathrm{add}^{(\\alpha)} = \\dfrac{(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{n}_0^{(\\alpha)}}{\\|(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{n}_0^{(\\alpha)}\\|}$。\n- 滑移系 $\\alpha$ 上的分解剪应力为 $\\tau^{(\\alpha)} = \\boldsymbol{s}^{(\\alpha)} \\cdot \\left( \\boldsymbol{\\sigma} \\, \\boldsymbol{n}^{(\\alpha)} \\right)$，对于对称的 $\\boldsymbol{\\sigma}$，这等效于 $\\tau^{(\\alpha)} = \\boldsymbol{\\sigma} : \\tfrac{1}{2}\\left(\\boldsymbol{s}^{(\\alpha)} \\otimes \\boldsymbol{n}^{(\\alpha)} + \\boldsymbol{n}^{(\\alpha)} \\otimes \\boldsymbol{s}^{(\\alpha)}\\right)$。\n- 激活准则由临界分解剪应力 $\\tau_c$ 给出：如果 $\\left|\\tau^{(\\alpha)}\\right| \\ge \\tau_c$，则认为滑移系被激活。\n\n你必须实现以下内容：\n- 使用面心立方晶格，其滑移系族为 $\\mathbb{R}^3$ 中典型的 $\\{111\\}\\langle 110 \\rangle$。构建包含 $12$ 个不同滑移系 $(\\boldsymbol{n}_0^{(\\alpha)}, \\boldsymbol{s}_0^{(\\alpha)})$ 的集合，其中向量为单位向量且 $\\boldsymbol{n}_0^{(\\alpha)} \\cdot \\boldsymbol{s}_0^{(\\alpha)} = 0$，排除仅符号不同的矢量对（即，在计算 $12$ 个滑移系时，将 $\\boldsymbol{s}$ 和 $-\\boldsymbol{s}$ 视为相同的滑移方向）。\n- 对于每个测试用例，使用相同的各向同性线弹性定律从 $\\boldsymbol{\\varepsilon}(\\boldsymbol{F})$ 计算柯西应力 $\\boldsymbol{\\sigma}$，供两种模型使用。\n- 对于乘法模型，使用极分解得到的 $\\boldsymbol{R}$。对于加法模型，使用 $\\boldsymbol{R}_\\mathrm{add} = \\boldsymbol{I} + \\boldsymbol{W}$ 作为瞬时更新，并如上文所述将 $\\boldsymbol{s}_\\mathrm{add}^{(\\alpha)}$ 和 $\\boldsymbol{n}_\\mathrm{add}^{(\\alpha)}$ 归一化为单位长度（不要将 $\\boldsymbol{R}_\\mathrm{add}$ 正交化或投影到 $\\mathrm{SO}(3)$ 上）。\n- 对于每个模型，使用相同的 $\\tau_c$ 确定在给定状态 $\\boldsymbol{F}$ 下的激活滑移系集合。\n- 通过不匹配分数来量化激活预测的差异，该分数定义为激活状态不同的滑移系数量除以 $12$。\n\n此基准测试中的所有量均为无量纲。测试套件中的角度以度为单位指定；在内部对三角函数使用弧度。程序必须为每个测试用例计算不匹配分数，结果为浮点数，四舍五入到六位小数。\n\n测试套件：\n- 材料参数：$E = 1.0$，$\\nu = 0.30$，$\\tau_c = 0.08$。\n- 通过映射 $\\boldsymbol{F}(\\theta, \\gamma) = \\boldsymbol{R}_z(\\theta) \\left(\\boldsymbol{I} + \\boldsymbol{K}(\\gamma)\\right)$ 定义一个绕 z 轴旋转角度为 $\\theta$ 的旋转和一个由 $\\gamma$ 表征的简单剪切，其中\n  $\n  \\boldsymbol{R}_z(\\theta) =\n  \\begin{bmatrix}\n  \\cos\\theta  -\\sin\\theta  0 \\\\\n  \\sin\\theta  \\cos\\theta  0 \\\\\n  0  0  1\n  \\end{bmatrix}\n  $\n  以及\n  $\n  \\boldsymbol{K}(\\gamma) =\n  \\begin{bmatrix}\n  0  \\gamma  0 \\\\\n  0  0  0 \\\\\n  0  0  0\n  \\end{bmatrix}.\n  $\n- 四个测试用例 $(\\theta,\\gamma)$，其中 $\\theta$ 以度为单位：\n  $1.$ $(\\theta,\\gamma) = (5.0, 0.01)$,\n  $2.$ $(\\theta,\\gamma) = (25.0, 0.10)$,\n  $3.$ $(\\theta,\\gamma) = (60.0, 0.30)$,\n  $4.$ $(\\theta,\\gamma) = (90.0, 0.00)$.\n\n你的程序应生成单行输出，其中包含按测试用例顺序排列的四个不匹配分数，形式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数（例如，$\"[0.000000,0.083333,0.250000,0.500000]\"$）。不允许有其他输出。", "solution": "该解答提供了一个计算基准测试，用于比较晶体塑性中两种晶格旋转的运动学描述：一种是严格的乘法分解模型，另一种是简化的加法小应变近似。此比较通过评估面心立方（FCC）晶体在承受包含组合剪切和大旋转的各种变形梯度时，两种模型在预测滑移系激活上的差异来进行。\n\n首先，我们建立基本的连续介质力学框架。材料点的变形由变形梯度张量 $\\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3}$ 描述。位移梯度为 $\\boldsymbol{H} = \\boldsymbol{F} - \\boldsymbol{I}$，其中 $\\boldsymbol{I}$ 是二阶单位张量。对于小变形，无穷小应变张量（或称小应变张量）定义为位移梯度的对称部分：$\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\boldsymbol{H} + \\boldsymbol{H}^\\top)$。材料响应被假定为各向同性线弹性，遵循柯西应力关系 $\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}$。拉梅参数 $\\lambda$ 和 $\\mu$ 由杨氏模量 $E$ 和泊松比 $\\nu$ 通过 $\\mu = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{\\nu E}{(1+\\nu)(1-2\\nu)}$ 确定。对于本问题，$E=1.0$，$\\nu=0.30$。这个应力张量 $\\boldsymbol{\\sigma}$ 从 $\\boldsymbol{F}$ 计算一次，并用于两种模型，因为题目要求只比较晶格旋转的运动学方面。\n\n问题的核心在于对晶格旋转的处理。\n\n乘法分解模型提供了运动学上精确的旋转描述。它基于变形梯度的极分解，$\\boldsymbol{F} = \\boldsymbol{R} \\, \\boldsymbol{U}$。这里，$\\boldsymbol{R}$ 是一个真正常交旋转张量，代表材料单元的刚体旋转；$\\boldsymbol{U}$ 是对称正定的右拉伸张量，代表纯变形部分。$\\boldsymbol{R}$ 的计算公式为 $\\boldsymbol{R} = \\boldsymbol{F} \\boldsymbol{U}^{-1}$，其中 $\\boldsymbol{U}$ 是右柯西-格林变形张量的主平方根，即 $\\boldsymbol{U} = (\\boldsymbol{F}^\\top \\boldsymbol{F})^{1/2}$。在此模型下，滑移系 $\\alpha$ 的参考滑移方向 $\\boldsymbol{s}_0^{(\\alpha)}$ 和滑移面法向 $\\boldsymbol{n}_0^{(\\alpha)}$ 通过 $\\boldsymbol{R}$ 旋转到当前构型：$\\boldsymbol{s}_\\mathrm{mul}^{(\\alpha)} = \\boldsymbol{R} \\, \\boldsymbol{s}_0^{(\\alpha)}$ 和 $\\boldsymbol{n}_\\mathrm{mul}^{(\\alpha)} = \\boldsymbol{R} \\, \\boldsymbol{n}_0^{(\\alpha)}$。\n\n加法小应变近似模型源于位移梯度对其对称和反对称部分的加法分解：$\\boldsymbol{H} = \\boldsymbol{\\varepsilon} + \\boldsymbol{W}$，其中 $\\boldsymbol{W} = \\tfrac{1}{2}(\\boldsymbol{H} - \\boldsymbol{H}^\\top)$ 是无穷小旋转张量。该模型用表达式 $\\boldsymbol{R}_\\mathrm{add} \\approx \\boldsymbol{I} + \\boldsymbol{W}$ 来近似有限旋转 $\\boldsymbol{R}$。这种近似仅对无穷小旋转有效。对于此基准测试，当前滑移矢量是通过应用此近似变换然后进行归一化以保持其单位长度来计算的：$\\boldsymbol{s}_\\mathrm{add}^{(\\alpha)} = \\dfrac{(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{s}_0^{(\\alpha)}}{\\|(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{s}_0^{(\\alpha)}\\|}$ 和 $\\boldsymbol{n}_\\mathrm{add}^{(\\alpha)} = \\dfrac{(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{n}_0^{(\\alpha)}}{\\|(\\boldsymbol{I} + \\boldsymbol{W}) \\boldsymbol{n}_0^{(\\alpha)}\\|}$。\n \n对于两种模型，滑移系 $\\alpha$ 上的分解剪应力均计算为 $\\tau^{(\\alpha)} = \\boldsymbol{s}^{(\\alpha)} \\cdot \\left( \\boldsymbol{\\sigma} \\, \\boldsymbol{n}^{(\\alpha)} \\right)$，其中使用各自计算出的当前矢量 $(\\boldsymbol{s}, \\boldsymbol{n})$。如果其分解剪应力的绝对值达到或超过一个临界值，即 $|\\tau^{(\\alpha)}| \\ge \\tau_c$，则认为该滑移系被激活。对于本问题，$\\tau_c = 0.08$。\n\n实现过程首先构建 FCC 晶格的 $12$ 个典型滑移系集合。这些是 $\\{111\\}\\langle 110 \\rangle$ 系。我们通过识别正交的滑移面法向和滑移方向对，以编程方式生成 $12$ 个不同的滑移系 $(\\boldsymbol{n}_0^{(\\alpha)}, \\boldsymbol{s}_0^{(\\alpha)})$。平面法向集合源自 $(1,1,1)$ 的排列，滑移方向集合源自 $(1,1,0)$ 的排列，同时确保向量是单位向量并遵循晶体学族。\n\n对于每个由旋转角 $\\theta$ 和剪切量 $\\gamma$ 定义的测试用例，变形梯度构建为 $\\boldsymbol{F}(\\theta, \\gamma) = \\boldsymbol{R}_z(\\theta) \\left(\\boldsymbol{I} + \\boldsymbol{K}(\\gamma)\\right)$，其中 $\\boldsymbol{R}_z(\\theta)$ 是绕 z 轴的旋转矩阵，$\\boldsymbol{K}(\\gamma)$ 是一个简单剪切张量。\n\n算法流程如下：\n$1.$ 对于给定的 $(\\theta, \\gamma)$，计算 $\\boldsymbol{F}$，然后计算 $\\boldsymbol{H}$、$\\boldsymbol{\\varepsilon}$，最后计算柯西应力 $\\boldsymbol{\\sigma}$。\n$2.$ 对于乘法模型，从 $\\boldsymbol{F}$ 的极分解中计算旋转张量 $\\boldsymbol{R}$。使用 $\\boldsymbol{R}$ 旋转 $12$ 个参考滑移系 $(\\boldsymbol{n}_0^{(\\alpha)}, \\boldsymbol{s}_0^{(\\alpha)})$ 中的每一个，以得到 $(\\boldsymbol{s}_\\mathrm{mul}^{(\\alpha)}, \\boldsymbol{n}_\\mathrm{mul}^{(\\alpha)})$。计算每个滑移系的分解剪应力 $\\tau_\\mathrm{mul}^{(\\alpha)}$，并通过将 $|\\tau_\\mathrm{mul}^{(\\alpha)}|$ 与 $\\tau_c=0.08$ 比较来确定其激活状态。\n$3.$ 对于加法模型，从 $\\boldsymbol{H}$ 计算反对称张量 $\\boldsymbol{W}$。变换算子是 $\\boldsymbol{T}_\\mathrm{add} = \\boldsymbol{I} + \\boldsymbol{W}$。将此算子应用于每个参考滑移系 $(\\boldsymbol{n}_0^{(\\alpha)}, \\boldsymbol{s}_0^{(\\alpha)})$，并对结果向量进行归一化以获得 $(\\boldsymbol{s}_\\mathrm{add}^{(\\alpha)}, \\boldsymbol{n}_\\mathrm{add}^{(\\alpha)})$。计算分解剪应力 $\\tau_\\mathrm{add}^{(\\alpha)}$，并根据相同的 $\\tau_c$ 确定激活状态。\n$4.$ 比较两种模型对 $12$ 个滑移系中每一个的激活状态（激活/未激活）预测。不匹配分数是激活状态不同的滑移系数量除以 $12$。\n$5.$ 对所有四个测试用例重复此过程：$(\\theta, \\gamma) = (5.0^\\circ, 0.01)$、$(25.0^\\circ, 0.10)$、$(60.0^\\circ, 0.30)$ 和 $(90.0^\\circ, 0.00)$。收集并格式化所得的不匹配分数。\n\n此基准测试量化了由加法小应变旋转近似引入的误差，预计该误差会随着变形梯度中旋转幅度的增大而增加。$\\theta=90.0^\\circ$ 的测试用例代表一个纯粹的有限旋转，在这种情况下，小应变近似是众所周知的特别不准确。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import sqrtm\n\ndef solve():\n    \"\"\"\n    Implements a benchmark to compare multiplicative and additive kinematic\n    descriptions of lattice rotation in small-strain crystal plasticity.\n    \"\"\"\n\n    # Material parameters\n    E = 1.0\n    nu = 0.30\n    tau_c = 0.08\n\n    # Lamé parameters\n    mu = E / (2 * (1 + nu))\n    lambda_lame = (nu * E) / ((1 + nu) * (1 - 2 * nu))\n\n    # Test suite: (theta in degrees, gamma)\n    test_cases = [\n        (5.0, 0.01),\n        (25.0, 0.10),\n        (60.0, 0.30),\n        (90.0, 0.00),\n    ]\n\n    def generate_fcc_slip_systems():\n        \"\"\"\n        Generates the 12 canonical {111}110> slip systems for an FCC lattice.\n        \"\"\"\n        systems = []\n        \n        plane_normals_base = [\n            [1, 1, 1],\n            [1, -1, 1],\n            [-1, 1, 1],\n            [1, 1, -1]\n        ]\n        slip_dirs_base = [\n            [1, -1, 0], [1, 0, -1], [0, 1, -1],\n            [1, 1, 0], [1, 0, 1], [0, 1, 1]\n        ]\n\n        for n_vec in plane_normals_base:\n            for s_vec in slip_dirs_base:\n                if np.dot(n_vec, s_vec) == 0:\n                    n = np.array(n_vec, dtype=float)\n                    s = np.array(s_vec, dtype=float)\n                    n /= np.linalg.norm(n)\n                    s /= np.linalg.norm(s)\n                    systems.append((n, s))\n        return systems\n\n    slip_systems = generate_fcc_slip_systems()\n    num_slip_systems = len(slip_systems)\n    \n    results = []\n\n    for theta_deg, gamma in test_cases:\n        # 1. Construct deformation gradient F\n        theta_rad = np.deg2rad(theta_deg)\n        c, s = np.cos(theta_rad), np.sin(theta_rad)\n        \n        R_z = np.array([\n            [c, -s, 0],\n            [s,  c, 0],\n            [0,  0, 1]\n        ])\n        \n        K = np.array([\n            [0, gamma, 0],\n            [0, 0,     0],\n            [0, 0,     0]\n        ])\n        \n        I = np.identity(3)\n        F = R_z @ (I + K)\n        \n        # 2. Common calculations: H, epsilon, sigma\n        H = F - I\n        epsilon = 0.5 * (H + H.T)\n        sigma = lambda_lame * np.trace(epsilon) * I + 2 * mu * epsilon\n\n        # 3. Multiplicative model\n        F_T_F = F.T @ F\n        U = sqrtm(F_T_F)\n        U_inv = np.linalg.inv(U)\n        R_mul = F @ U_inv\n        \n        active_mul = []\n        for n0, s0 in slip_systems:\n            n_mul = R_mul @ n0\n            s_mul = R_mul @ s0\n            tau_mul = s_mul.T @ sigma @ n_mul\n            active_mul.append(np.abs(tau_mul) >= tau_c)\n\n        # 4. Additive model\n        W = 0.5 * (H - H.T)\n        T_add = I + W\n        \n        active_add = []\n        for n0, s0 in slip_systems:\n            n_prime = T_add @ n0\n            s_prime = T_add @ s0\n            \n            n_add = n_prime / np.linalg.norm(n_prime)\n            s_add = s_prime / np.linalg.norm(s_prime)\n            \n            tau_add = s_add.T @ sigma @ n_add\n            active_add.append(np.abs(tau_add) >= tau_c)\n            \n        # 5. Compare and calculate mismatch fraction\n        mismatch_count = 0\n        for i in range(num_slip_systems):\n            if active_mul[i] != active_add[i]:\n                mismatch_count += 1\n        \n        mismatch_fraction = mismatch_count / num_slip_systems\n        results.append(mismatch_fraction)\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3556422"}, {"introduction": "这最后一个练习将巩固你对现代晶体塑性理论中完整的有限应变框架的理解。你将实现将滑移系在参考构型、中间构型和当前构型之间进行映射的前推和后拉操作。[@problem_id:3556393] 至关重要的是，你还将通过数值方法验证坐标系无关性（客观性）原理，以证实你的物理预测与观察者的运动无关，这是所有有效的连续介质力学模型的基石。", "problem": "实现一个程序，该程序针对大应变晶体塑性运动学，在参考构型、中间构型和当前构型之间执行滑移系的推前和拉回操作，并验证在叠加刚体旋转下分解剪应力启动准则的标架无关性（客观性）。所有量均为无量纲。仅使用下面列举的数学基础，并且不要假定超出这些基础的任何快捷公式。\n\n基本定义和事实：\n- 令总变形梯度为 $F \\in \\mathbb{R}^{3 \\times 3}$，具有乘法分解 $F = F^e F^p$，其中 $F^e$ 是弹性部分，$F^p$ 是塑性部分。\n- 矢量通过 $A$ 推前为 $v \\mapsto A v$。余矢量（例如平面法线）通过 $A^{-T}$ 推前为 $n \\mapsto A^{-T} n$。这些规则在 $n \\cdot v$ 在适当的配对变换下保持不变的意义上保留了对偶性。\n- $F^e$ 的右极分解存在且由 $F^e = R^e U^e$ 给出，其中 $R^e \\in \\mathrm{SO}(3)$ 是一个正常正交旋转，$U^e$ 是一个对称正定伸长张量。旋转为 $R^e = F^e (U^e)^{-1}$，$U^e$ 是 $C^e = (F^e)^T F^e$ 的唯一正定平方根。\n- 对于可压缩的 Neo-Hookean 弹性响应，Kirchhoff 应力为 $\\tau = \\mu (B^e - I) + \\kappa \\ln J \\, I$，其中 $B^e = F^e (F^e)^T$，$J = \\det(F^e)$，$I$ 是单位矩阵，$\\mu$ 是剪切模量，$\\kappa$ 是体积模量。Cauchy 应力为 $\\sigma = \\tau / J$。\n- 在当前构型中，对于滑移方向为 $s$、滑移面法线为 $m$ 的滑移系，其 Schmid 张量为 $P = \\tfrac{1}{2} (s \\otimes m + m \\otimes s)$。对于对称的 Cauchy 应力 $\\sigma$，分解剪应力等于 $\\tau_{\\mathrm{rss}} = \\sigma : P = s \\cdot (\\sigma m)$。\n\n要实现的任务：\n1. 将滑移系 $(s_0, m_0)$ 从参考构型通过 $F^p$ 推前映射到中间构型，将 $s_0$ 视为矢量，$m_0$ 视为余矢量，然后对两者进行归一化，再通过 $R^e$ 将两者旋转到当前构型。具体来说，分别计算在 $F^p$ 和 $(F^p)^{-T}$ 作用下归一化后的像作为中间滑移方向和法线，然后通过与 $R^e$ 的旋转计算出当前滑移方向和法线。确保在当前构型中强制执行正交性 $s \\cdot m = 0$ 和单位范数。\n2. 将滑移系 $(s, m)$ 从当前构型拉回映射到参考构型，方法是先撤销旋转 $R^e$，然后恰当地使用 $F^p$ 的逆（矢量通过 $(F^p)^{-1}$ 拉回，余矢量通过 $(F^p)^T$ 拉回），并在每个阶段进行归一化。验证从参考构型到当前构型再返回的往返过程能够恢复原始方向（可能相差一个符号，这不应影响物理滑移系）。\n3. 使用可压缩 Neo-Hookean 模型，根据给定的 $(\\mu, \\kappa)$ 从 $F^e$ 计算 Cauchy 应力 $\\sigma$，然后计算当前构型中每个滑移系的分解剪应力 $\\tau_{\\mathrm{rss}}$。\n4. 验证客观性：在当前构型上施加一个叠加的刚体旋转 $Q \\in \\mathrm{SO}(3)$，使 $F^e$ 变为 $F^{e\\star} = Q F^e$。在此条件下，重新计算当前滑移系和 Cauchy 应力，并评估分解剪应力 $\\tau_{\\mathrm{rss}}^\\star$。数值上证明在指定容差内 $\\tau_{\\mathrm{rss}}^\\star = \\tau_{\\mathrm{rss}}$。\n\n测试套件和参数：\n- 使用以下三个测试用例。对于每个用例，使用给定的 $F^p$、$F^e$、参考滑移系 $(s_0, m_0)$、刚体旋转 $Q$ 和弹性参数 $(\\mu, \\kappa)$。所有矩阵和向量都必须严格按照规定使用。\n\n案例 A：\n- $F^p = \\begin{bmatrix} 1  0.3  0 \\\\ 0  1  0.2 \\\\ 0  0  1 \\end{bmatrix}$，$F^e = \\begin{bmatrix} 1.1  0.2  0 \\\\ 0  0.9  0.1 \\\\ 0  0  1.05 \\end{bmatrix}$。\n- $(s_0, m_0) = \\left( \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix} \\right)$。\n- $Q = \\begin{bmatrix} 0.5  -0.8660254037844386  0 \\\\ 0.8660254037844386  0.5  0 \\\\ 0  0  1 \\end{bmatrix}$。\n- $(\\mu, \\kappa) = (50, 100)$。\n\n案例 B：\n- $F^p = \\mathrm{diag}(0.9, 1.3, 0.8547008547008547)$，$F^e = \\begin{bmatrix} 1  0  0 \\\\ 0  \\tfrac{\\sqrt{2}}{2}  -\\tfrac{\\sqrt{2}}{2} \\\\ 0  \\tfrac{\\sqrt{2}}{2}  \\tfrac{\\sqrt{2}}{2} \\end{bmatrix}$。\n- $(s_0, m_0) = \\left( \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\right)$。\n- $Q = I = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。\n- $(\\mu, \\kappa) = (50, 100)$。\n\n案例 C：\n- $F^p = \\mathrm{diag}(1.2, 0.9, 0.9259259259)$，$F^e = \\begin{bmatrix} 1  0.15  0 \\\\ 0  1  0.2 \\\\ 0.05  0  1 \\end{bmatrix}$。\n- $(s_0, m_0) = \\left( \\dfrac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix} \\right)$。\n- $Q = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{bmatrix}$。\n- $(\\mu, \\kappa) = (50, 100)$。\n\n每个案例需要计算和验证的内容：\n- 通过推前计算当前滑移系 $(s, m)$，并通过从 $(s, m)$ 拉回恢复参考滑移系 $(\\tilde{s}_0, \\tilde{m}_0)$。在每一步强制进行归一化。数值上验证 $(s, m)$ 的正交性和单位范数，并通过检查 $\\left| \\tilde{s}_0 \\cdot s_0 \\right|$ 和 $\\left| \\tilde{m}_0 \\cdot m_0 \\right|$ 是否接近于 $1$ 来验证 $(s_0, m_0)$ 的往返恢复（允许符号差异）。\n- 从 $F^e$ 和 $(\\mu, \\kappa)$ 计算 $\\sigma$ 及分解剪应力 $\\tau_{\\mathrm{rss}}$。然后，使用 $F^{e\\star} = Q F^e$ 重新计算 $\\sigma^\\star$ 和 $\\tau_{\\mathrm{rss}}^\\star$。通过检查 $\\left| \\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}} \\right|$ 是否在容差范围内来验证客观性。\n\n数值容差和通过标准：\n- 正交性和单位范数检查使用容差 $\\varepsilon_{\\mathrm{orth}} = 10^{-12}$，方向的往返检查使用容差 $\\varepsilon_{\\mathrm{round}} = 10^{-10}$，分解剪应力的客观性检查使用容差 $\\varepsilon_{\\mathrm{obj}} = 10^{-10}$。\n- 一个案例当且仅当所有三个条件都满足时才算通过：(i) $\\left| s \\cdot m \\right| \\le \\varepsilon_{\\mathrm{orth}}$ 且 $\\left| \\lVert s \\rVert - 1 \\right| \\le \\varepsilon_{\\mathrm{orth}}$ 且 $\\left| \\lVert m \\rVert - 1 \\right| \\le \\varepsilon_{\\mathrm{orth}}$；(ii) $\\left| \\tilde{s}_0 \\cdot s_0 \\right| \\ge 1 - \\varepsilon_{\\mathrm{round}}$ 且 $\\left| \\tilde{m}_0 \\cdot m_0 \\right| \\ge 1 - \\varepsilon_{\\mathrm{round}}$；(iii) $\\left| \\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}} \\right| \\le \\varepsilon_{\\mathrm{obj}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 A、B 和 C 的通过或失败结果，格式为用方括号括起来的逗号分隔列表（例如，$\\left[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True} \\right]$ 应打印为“[True,False,True]”）。", "solution": "该问题是有效的，因为它科学地基于连续介质力学和晶体塑性原理，问题陈述清晰（well-posed）并提供了所有必要信息，且以客观、正式的方式表述。这些任务涉及实现计算固体力学中常见但具体的标准运动学变换和本构关系。我们通过执行所需的步骤来解决该问题。\n\n对于每个测试用例，分析都分为四个主要部分，遵循问题描述的步骤：（1）将滑移系从参考构型推前映射到当前构型，（2）进行拉回映射以验证运动学的往返一致性，（3）计算应力和分解剪应力，以及（4）验证在叠加刚体旋转下的标架无关性（客观性）。\n\n**1. 滑移系的推前运动学**\n\n晶体塑性运动学关联三个构型：参考（或未变形）构型 $\\mathcal{B}_0$、当前（或变形）构型 $\\mathcal{B}$，以及一个概念性的中间构型 $\\mathcal{B}_p$。总变形梯度 $F$ 被乘法分解为 $F = F^e F^p$，其中 $F^p$ 从 $\\mathcal{B}_0$ 映射到 $\\mathcal{B}_p$，$F^e$ 从 $\\mathcal{B}_p$ 映射到 $\\mathcal{B}$。\n\n滑移系由一个滑移方向矢量和一个滑移面法线余矢量定义。在参考构型中，它们表示为 $(s_0, m_0)$，是给定的正交单位矢量。\n\n从 $\\mathcal{B}_0$ 到 $\\mathcal{B}_p$ 的推前由 $F^p$ 控制。矢量变换为 $v \\mapsto F^p v$，余矢量（法线）变换为 $n \\mapsto (F^p)^{-T} n$。该变换法则确保了矢量和余矢量之间的点积（对偶配对）在其未归一化的像之间保持不变，即 $((F^p)^{-T} m_0) \\cdot (F^p s_0) = m_0 \\cdot s_0$。中间构型中的滑移系 $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ 通过对这些变换后的矢量进行归一化得到：\n$$s_{\\mathrm{int}} = \\frac{F^p s_0}{\\|F^p s_0\\|}, \\quad m_{\\mathrm{int}} = \\frac{(F^p)^{-T} m_0}{\\| (F^p)^{-T} m_0 \\|}$$\n由于 $s_0 \\cdot m_0 = 0$，因此 $s_{\\mathrm{int}} \\cdot m_{\\mathrm{int}} = 0$。\n\n从 $\\mathcal{B}_p$ 到 $\\mathcal{B}$ 的映射由弹性变形梯度 $F^e$ 控制。问题为这一步指定了一个特定的运动学假设。首先，$F^e$ 通过右极分解被分解为一个正常正交旋转 $R^e \\in \\mathrm{SO}(3)$ 和一个对称正定的右伸长张量 $U^e$，使得 $F^e = R^e U^e$。伸长张量 $U^e$ 计算为右柯西-格林张量 $C^e = (F^e)^T F^e$ 的唯一正定平方根。然后，旋转可以求得为 $R^e = F^e (U^e)^{-1}$。\n\n问题指出，中间构型中的滑移系矢量通过与 $R^e$ 的旋转映射到当前构型。这意味着滑移系被认为嵌入到一个经过弹性旋转但未被拉伸的晶格中。\n$$s = R^e s_{\\mathrm{int}}, \\quad m = R^e m_{\\mathrm{int}}$$\n由于 $R^e$ 是一个旋转且 $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ 是标准正交的，因此得到的当前滑移系 $(s, m)$ 也将由标准正交矢量组成。这一点会根据容差 $\\varepsilon_{\\mathrm{orth}} = 10^{-12}$ 进行数值验证。\n\n**2. 拉回运动学和往返验证**\n\n为了验证运动学映射的一致性，执行从当前构型返回到参考构型的往返操作。这个拉回操作是推前操作的逆过程。\n\n从当前滑移系 $(s, m)$ 开始，我们首先通过撤销旋转 $R^e$ 将其拉回到中间构型：\n$$s_{\\mathrm{int}}^{\\mathrm{rec}} = (R^e)^{-1} s = (R^e)^T s, \\quad m_{\\mathrm{int}}^{\\mathrm{rec}} = (R^e)^{-1} m = (R^e)^T m$$\n接下来，我们从 $\\mathcal{B}_p$ 拉回到 $\\mathcal{B}_0$。矢量通过 $(F^p)^{-1}$ 拉回，余矢量通过 $(F^p)^T$ 拉回。未归一化的参考矢量为：\n$$s_0' = (F^p)^{-1} s_{\\mathrm{int}}^{\\mathrm{rec}}, \\quad m_0' = (F^p)^T m_{\\mathrm{int}}^{\\mathrm{rec}}$$\n最后，我们对这些矢量进行归一化，得到恢复的参考滑移系 $(\\tilde{s}_0, \\tilde{m}_0)$:\n$$\\tilde{s}_0 = \\frac{s_0'}{\\|s_0'\\|}, \\quad \\tilde{m}_0 = \\frac{m_0'}{\\|m_0'\\|}$$\n如果恢复的系统 $(\\tilde{s}_0, \\tilde{m}_0)$ 等效于原始系统 $(s_0, m_0)$，则认为往返过程成功。由于滑移系的物理意义与其方向或法向量的符号无关，我们通过检查它们各自绝对点积是否接近 $1$ 来验证成功：$|\\tilde{s}_0 \\cdot s_0| \\ge 1 - \\varepsilon_{\\mathrm{round}}$ 和 $|\\tilde{m}_0 \\cdot m_0| \\ge 1 - \\varepsilon_{\\mathrm{round}}$，其中 $\\varepsilon_{\\mathrm{round}} = 10^{-10}$。\n\n**3. 应力与分解剪应力计算**\n\n滑移的驱动力是分解剪应力 $\\tau_{\\mathrm{rss}}$，它取决于 Cauchy 应力 $\\sigma$ 和当前滑移系 $(s, m)$。问题指定了一个可压缩的 Neo-Hookean 材料模型。\n\n首先从弹性变形计算 Kirchhoff 应力 $\\tau$。它由以下公式给出：\n$$\\tau = \\mu (B^e - I) + \\kappa \\ln(J) I$$\n其中 $B^e = F^e (F^e)^T$ 是弹性变形的左柯西-格林张量（或 Finger 张量），$J = \\det(F^e)$ 是弹性体积变化，$I$ 是 $3 \\times 3$ 单位矩阵，$(\\mu, \\kappa)$ 是剪切模量和体积模量。\n\nCauchy 应力 $\\sigma$ 与 Kirchhoff 应力通过 $\\sigma = \\tau / J$ 相关。\n\n滑移系 $(s, m)$ 的分解剪应力 $\\tau_{\\mathrm{rss}}$ 是滑移面上的牵引力 $(\\sigma m)$ 在滑移方向 $s$ 上的投影：\n$$\\tau_{\\mathrm{rss}} = s \\cdot (\\sigma m)$$\n对于对称的 Cauchy 应力，这等效于双点积 $\\sigma : P$，其中 $P = \\frac{1}{2}(s \\otimes m + m \\otimes s)$ 是 Schmid 张量。\n\n**4. 客观性验证**\n\n连续介质力学的一个基本原理是标架无关性或客观性，它要求材料响应与观察者无关（即与叠加的刚体运动无关）。我们对分解剪应力验证此原理。\n\n一个刚体旋转被施加到当前构型上，由一个正常正交矩阵 $Q \\in \\mathrm{SO}(3)$ 表示。这将弹性变形梯度变换为 $F^{e\\star} = Q F^e$。所有其他量都必须基于这个新的变形重新计算。\n\n新的极分解是 $F^{e\\star} = R^{e\\star} U^{e\\star}$。我们发现 $U^{e\\star} = U^e$ 且 $R^{e\\star} = Q R^e$。中间构型及其滑移系 $(s_{\\mathrm{int}}, m_{\\mathrm{int}})$ 不受影响，因为它们仅依赖于 $F^p$。新的当前滑移系为：\n$$s^\\star = R^{e\\star} s_{\\mathrm{int}} = (Q R^e) s_{\\mathrm{int}} = Q s, \\quad m^\\star = R^{e\\star} m_{\\mathrm{int}} = (Q R^e) m_{\\mathrm{int}} = Q m$$\n新的应力张量 $\\sigma^\\star$ 从 $F^{e\\star}$ 计算得出。变换后的左柯西-格林张量为 $B^{e\\star} = Q B^e Q^T$，行列式不变，$J^\\star = J$。由此产生的 Kirchhoff 和 Cauchy 应力作为客观的二阶张量进行变换：\n$$\\tau^\\star = Q \\tau Q^T, \\quad \\sigma^\\star = Q \\sigma Q^T$$\n新的分解剪应力 $\\tau_{\\mathrm{rss}}^\\star$ 为：\n$$\\tau_{\\mathrm{rss}}^\\star = s^\\star \\cdot (\\sigma^\\star m^\\star) = (Qs) \\cdot ((Q \\sigma Q^T) (Qm)) = s^T Q^T Q \\sigma Q^T Q m = s^T \\sigma m = \\tau_{\\mathrm{rss}}$$\n分解剪应力必须是不变的。我们通过检查 $|\\tau_{\\mathrm{rss}}^\\star - \\tau_{\\mathrm{rss}}| \\le \\varepsilon_{\\mathrm{obj}}$ 来数值验证这一计算，其中 $\\varepsilon_{\\mathrm{obj}} = 10^{-10}$。一个案例当且仅当所有三个验证标准（标准正交性、往返性和客观性）都得到满足时才算通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import inv, det, sqrtm\n\ndef solve():\n    \"\"\"\n    Main function to run the crystal plasticity kinematics validation\n    for all specified test cases.\n    \"\"\"\n\n    class CrystalPlasticityKinematics:\n        \"\"\"\n        A class to encapsulate the computations and state for a single\n        crystal plasticity test case.\n        \"\"\"\n\n        def __init__(self, Fp, Fe, s0, m0, Q, mu_kappa):\n            \"\"\"\n            Initializes the state with the given parameters for one test case.\n            \"\"\"\n            self.Fp = np.asarray(Fp, dtype=float)\n            self.Fe = np.asarray(Fe, dtype=float)\n            self.s0 = np.asarray(s0, dtype=float) / np.linalg.norm(s0)\n            self.m0 = np.asarray(m0, dtype=float) / np.linalg.norm(m0)\n            self.Q = np.asarray(Q, dtype=float)\n            self.mu, self.kappa = mu_kappa\n\n            # Intermediate and current quantities to be computed\n            self.s_int, self.m_int = None, None\n            self.Re, self.Ue = None, None\n            self.s, self.m = None, None\n            self.sigma, self.tau_rss = None, None\n            self.s_star, self.m_star = None, None\n            self.sigma_star, self.tau_rss_star = None, None\n            \n            # Recovered quantities\n            self.s0_tilde, self.m0_tilde = None, None\n\n        def _perform_polar_decomposition(self, F):\n            \"\"\"Computes the right polar decomposition F = R U.\"\"\"\n            C = F.T @ F\n            U = sqrtm(C)\n            # Ensure U is real, although it should be for positive semi-definite C\n            if np.iscomplexobj(U): U = U.real\n            R = F @ inv(U)\n            return R, U\n\n        def _perform_push_forward(self):\n            \"\"\"Task 1: Pushes the slip system from reference to current config.\"\"\"\n            # Map from reference to intermediate configuration\n            Fp_inv_T = inv(self.Fp).T\n            s_int_prime = self.Fp @ self.s0\n            m_int_prime = Fp_inv_T @ self.m0\n            \n            self.s_int = s_int_prime / np.linalg.norm(s_int_prime)\n            self.m_int = m_int_prime / np.linalg.norm(m_int_prime)\n\n            # Polar decomposition of elastic deformation\n            self.Re, self.Ue = self._perform_polar_decomposition(self.Fe)\n\n            # Map from intermediate to current configuration\n            self.s = self.Re @ self.s_int\n            self.m = self.Re @ self.m_int\n\n        def _perform_pull_back(self):\n            \"\"\"Task 2: Pulls the slip system from current back to reference.\"\"\"\n            # From current to intermediate\n            s_int_rec = self.Re.T @ self.s\n            m_int_rec = self.Re.T @ self.m\n            \n            # From intermediate to reference\n            s0_prime_rec = inv(self.Fp) @ s_int_rec\n            m0_prime_rec = self.Fp.T @ m_int_rec\n            \n            self.s0_tilde = s0_prime_rec / np.linalg.norm(s0_prime_rec)\n            self.m0_tilde = m0_prime_rec / np.linalg.norm(m0_prime_rec)\n\n        def _compute_stress_and_rss(self, F, s, m):\n            \"\"\"Task 3: Computes stress and resolved shear stress.\"\"\"\n            J = det(F)\n            if J = 0: raise ValueError(\"Non-positive determinant.\")\n            Be = F @ F.T\n            I = np.identity(3)\n            tau = self.mu * (Be - I) + self.kappa * np.log(J) * I\n            sigma = tau / J\n            tau_rss = s.dot(sigma @ m)\n            return sigma, tau_rss\n\n        def _compute_rotated_quantities(self):\n            \"\"\"Task 4: Re-computes quantities under superposed rotation.\"\"\"\n            # New elastic deformation gradient\n            Fe_star = self.Q @ self.Fe\n            \n            # New polar decomposition and current slip system\n            Re_star, _ = self._perform_polar_decomposition(Fe_star)\n            self.s_star = Re_star @ self.s_int\n            self.m_star = Re_star @ self.m_int\n\n            # New stress and RSS\n            self.sigma_star, self.tau_rss_star = self._compute_stress_and_rss(\n                Fe_star, self.s_star, self.m_star\n            )\n\n        def run_verifications(self, tolerances):\n            \"\"\"\n            Executes all computational tasks and performs verifications.\n            Returns True if all checks pass, False otherwise.\n            \"\"\"\n            eps_orth, eps_round, eps_obj = tolerances\n\n            # Perform all computations\n            self._perform_push_forward()\n            self._perform_pull_back()\n            self.sigma, self.tau_rss = self._compute_stress_and_rss(self.Fe, self.s, self.m)\n            self._compute_rotated_quantities()\n\n            # Verification (i): Orthonormality in current configuration\n            pass_ortho = (abs(self.s.dot(self.m)) = eps_orth and\n                          abs(np.linalg.norm(self.s) - 1) = eps_orth and\n                          abs(np.linalg.norm(self.m) - 1) = eps_orth)\n\n            # Verification (ii): Round-trip recovery\n            pass_round_trip = (abs(self.s0_tilde.dot(self.s0)) >= 1 - eps_round and\n                               abs(self.m0_tilde.dot(self.m0)) >= 1 - eps_round)\n\n            # Verification (iii): Objectivity of resolved shear stress\n            pass_objectivity = abs(self.tau_rss_star - self.tau_rss) = eps_obj\n\n            return pass_ortho and pass_round_trip and pass_objectivity\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (np.array([[1, 0.3, 0], [0, 1, 0.2], [0, 0, 1]]),\n         np.array([[1.1, 0.2, 0], [0, 0.9, 0.1], [0, 0, 1.05]]),\n         np.array([1, 0, 0]),\n         np.array([0, 1, 0]),\n         np.array([[0.5, -0.8660254037844386, 0], [0.8660254037844386, 0.5, 0], [0, 0, 1]]),\n         (50, 100)),\n        # Case B\n        (np.diag([0.9, 1.3, 0.8547008547008547]),\n         np.array([[1, 0, 0], [0, np.sqrt(2)/2, -np.sqrt(2)/2], [0, np.sqrt(2)/2, np.sqrt(2)/2]]),\n         np.array([0, 1, 0]),\n         np.array([1, 0, 0]),\n         np.identity(3),\n         (50, 100)),\n        # Case C\n        (np.diag([1.2, 0.9, 0.9259259259]),\n         np.array([[1, 0.15, 0], [0, 1, 0.2], [0.05, 0, 1]]),\n         np.array([1/np.sqrt(2), 1/np.sqrt(2), 0]),\n         np.array([0, 0, 1]),\n         np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]]),\n         (50, 100))\n    ]\n\n    tolerances = (1e-12, 1e-10, 1e-10) # (eps_orth, eps_round, eps_obj)\n    results = []\n\n    for case_params in test_cases:\n        Fp, Fe, s0, m0, Q, mu_kappa = case_params\n        \n        try:\n            case_runner = CrystalPlasticityKinematics(Fp, Fe, s0, m0, Q, mu_kappa)\n            result = case_runner.run_verifications(tolerances)\n            results.append(result)\n        except (np.linalg.LinAlgError, ValueError) as e:\n            # In case of singular matrices or other numerical issues\n            print(f\"Error processing a case: {e}\")\n            results.append(False)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3556393"}]}